{
  "content": {
    "base64": "I2RlZmluZSBESVNBQkxFX1NJR05fQ09NUEFSRV9XQVJOSU5HUwoKI2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAiYWRkLWludGVyYWN0aXZlLmgiCiNpbmNsdWRlICJjb2xvci5oIgojaW5jbHVkZSAiY29uZmlnLmgiCiNpbmNsdWRlICJkaWZmY29yZS5oIgojaW5jbHVkZSAiZ2V0dGV4dC5oIgojaW5jbHVkZSAiaGFzaC5oIgojaW5jbHVkZSAiaGV4LmgiCiNpbmNsdWRlICJwcmVsb2FkLWluZGV4LmgiCiNpbmNsdWRlICJyZWFkLWNhY2hlLWxsLmgiCiNpbmNsdWRlICJyZXBvc2l0b3J5LmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgImxvY2tmaWxlLmgiCiNpbmNsdWRlICJkaXIuaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJwcm9tcHQuaCIKI2luY2x1ZGUgInRyZWUuaCIKCnN0YXRpYyB2b2lkIGluaXRfY29sb3Ioc3RydWN0IHJlcG9zaXRvcnkgKnIsIGludCB1c2VfY29sb3IsCgkJICAgICAgIGNvbnN0IGNoYXIgKnNlY3Rpb25fYW5kX3Nsb3QsIGNoYXIgKmRzdCwKCQkgICAgICAgY29uc3QgY2hhciAqZGVmYXVsdF9jb2xvcikKewoJY2hhciAqa2V5ID0geHN0cmZtdCgiY29sb3IuJXMiLCBzZWN0aW9uX2FuZF9zbG90KTsKCWNvbnN0IGNoYXIgKnZhbHVlOwoKCWlmICghdXNlX2NvbG9yKQoJCWRzdFswXSA9ICdcMCc7CgllbHNlIGlmIChyZXBvX2NvbmZpZ19nZXRfdmFsdWUociwga2V5LCAmdmFsdWUpIHx8CgkJIGNvbG9yX3BhcnNlKHZhbHVlLCBkc3QpKQoJCXN0cmxjcHkoZHN0LCBkZWZhdWx0X2NvbG9yLCBDT0xPUl9NQVhMRU4pOwoKCWZyZWUoa2V5KTsKfQoKc3RhdGljIGludCBjaGVja19jb2xvcl9jb25maWcoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IGNoYXIgKnZhcikKewoJY29uc3QgY2hhciAqdmFsdWU7CgllbnVtIGdpdF9jb2xvcmJvb2wgcmV0OwoKCWlmIChyZXBvX2NvbmZpZ19nZXRfdmFsdWUociwgdmFyLCAmdmFsdWUpKQoJCXJldCA9IEdJVF9DT0xPUl9VTktOT1dOOwoJZWxzZQoJCXJldCA9IGdpdF9jb25maWdfY29sb3Jib29sKHZhciwgdmFsdWUpOwoKCS8qCgkgKiBEbyBub3QgcmVseSBvbiB3YW50X2NvbG9yKCkgdG8gZmFsbCBiYWNrIHRvIGNvbG9yLnVpIGZvciB1cy4gSXQgdXNlcwoJICogdGhlIHZhbHVlIHBhcnNlZCBieSBnaXRfY29sb3JfY29uZmlnKCksIHdoaWNoIG1heSBub3QgaGF2ZSBiZWVuCgkgKiBjYWxsZWQgYnkgdGhlIG1haW4gY29tbWFuZC4KCSAqLwoJaWYgKHJldCA9PSBHSVRfQ09MT1JfVU5LTk9XTiAmJgoJICAgICFyZXBvX2NvbmZpZ19nZXRfdmFsdWUociwgImNvbG9yLnVpIiwgJnZhbHVlKSkKCQlyZXQgPSBnaXRfY29uZmlnX2NvbG9yYm9vbCgiY29sb3IudWkiLCB2YWx1ZSk7CgoJcmV0dXJuIHdhbnRfY29sb3IocmV0KTsKfQoKdm9pZCBpbml0X2FkZF9pX3N0YXRlKHN0cnVjdCBhZGRfaV9zdGF0ZSAqcywgc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJICAgICAgc3RydWN0IGFkZF9wX29wdCAqYWRkX3Bfb3B0KQp7CglzLT5yID0gcjsKCXMtPmNvbnRleHQgPSAtMTsKCXMtPmludGVyaHVua2NvbnRleHQgPSAtMTsKCglzLT51c2VfY29sb3JfaW50ZXJhY3RpdmUgPSBjaGVja19jb2xvcl9jb25maWcociwgImNvbG9yLmludGVyYWN0aXZlIik7CgoJaW5pdF9jb2xvcihyLCBzLT51c2VfY29sb3JfaW50ZXJhY3RpdmUsICJpbnRlcmFjdGl2ZS5oZWFkZXIiLAoJCSAgIHMtPmhlYWRlcl9jb2xvciwgR0lUX0NPTE9SX0JPTEQpOwoJaW5pdF9jb2xvcihyLCBzLT51c2VfY29sb3JfaW50ZXJhY3RpdmUsICJpbnRlcmFjdGl2ZS5oZWxwIiwKCQkgICBzLT5oZWxwX2NvbG9yLCBHSVRfQ09MT1JfQk9MRF9SRUQpOwoJaW5pdF9jb2xvcihyLCBzLT51c2VfY29sb3JfaW50ZXJhY3RpdmUsICJpbnRlcmFjdGl2ZS5wcm9tcHQiLAoJCSAgIHMtPnByb21wdF9jb2xvciwgR0lUX0NPTE9SX0JPTERfQkxVRSk7Cglpbml0X2NvbG9yKHIsIHMtPnVzZV9jb2xvcl9pbnRlcmFjdGl2ZSwgImludGVyYWN0aXZlLmVycm9yIiwKCQkgICBzLT5lcnJvcl9jb2xvciwgR0lUX0NPTE9SX0JPTERfUkVEKTsKCXN0cmxjcHkocy0+cmVzZXRfY29sb3JfaW50ZXJhY3RpdmUsCgkJcy0+dXNlX2NvbG9yX2ludGVyYWN0aXZlID8gR0lUX0NPTE9SX1JFU0VUIDogIiIsIENPTE9SX01BWExFTik7CgoJcy0+dXNlX2NvbG9yX2RpZmYgPSBjaGVja19jb2xvcl9jb25maWcociwgImNvbG9yLmRpZmYiKTsKCglpbml0X2NvbG9yKHIsIHMtPnVzZV9jb2xvcl9kaWZmLCAiZGlmZi5mcmFnIiwgcy0+ZnJhZ2luZm9fY29sb3IsCgkJICAgZGlmZl9nZXRfY29sb3Iocy0+dXNlX2NvbG9yX2RpZmYsIERJRkZfRlJBR0lORk8pKTsKCWluaXRfY29sb3Iociwgcy0+dXNlX2NvbG9yX2RpZmYsICJkaWZmLmNvbnRleHQiLCBzLT5jb250ZXh0X2NvbG9yLAoJCSAgICJmYWxsIGJhY2siKTsKCWlmICghc3RyY21wKHMtPmNvbnRleHRfY29sb3IsICJmYWxsIGJhY2siKSkKCQlpbml0X2NvbG9yKHIsIHMtPnVzZV9jb2xvcl9kaWZmLCAiZGlmZi5wbGFpbiIsCgkJCSAgIHMtPmNvbnRleHRfY29sb3IsCgkJCSAgIGRpZmZfZ2V0X2NvbG9yKHMtPnVzZV9jb2xvcl9kaWZmLCBESUZGX0NPTlRFWFQpKTsKCWluaXRfY29sb3Iociwgcy0+dXNlX2NvbG9yX2RpZmYsICJkaWZmLm9sZCIsIHMtPmZpbGVfb2xkX2NvbG9yLAoJCSAgIGRpZmZfZ2V0X2NvbG9yKHMtPnVzZV9jb2xvcl9kaWZmLCBESUZGX0ZJTEVfT0xEKSk7Cglpbml0X2NvbG9yKHIsIHMtPnVzZV9jb2xvcl9kaWZmLCAiZGlmZi5uZXciLCBzLT5maWxlX25ld19jb2xvciwKCQkgICBkaWZmX2dldF9jb2xvcihzLT51c2VfY29sb3JfZGlmZiwgRElGRl9GSUxFX05FVykpOwoJc3RybGNweShzLT5yZXNldF9jb2xvcl9kaWZmLAoJCXMtPnVzZV9jb2xvcl9kaWZmID8gR0lUX0NPTE9SX1JFU0VUIDogIiIsIENPTE9SX01BWExFTik7CgoJRlJFRV9BTkRfTlVMTChzLT5pbnRlcmFjdGl2ZV9kaWZmX2ZpbHRlcik7CglyZXBvX2NvbmZpZ19nZXRfc3RyaW5nKHIsICJpbnRlcmFjdGl2ZS5kaWZmZmlsdGVyIiwKCQkJICAgICAgICZzLT5pbnRlcmFjdGl2ZV9kaWZmX2ZpbHRlcik7CgoJRlJFRV9BTkRfTlVMTChzLT5pbnRlcmFjdGl2ZV9kaWZmX2FsZ29yaXRobSk7CglyZXBvX2NvbmZpZ19nZXRfc3RyaW5nKHIsICJkaWZmLmFsZ29yaXRobSIsCgkJCSAgICAgICAmcy0+aW50ZXJhY3RpdmVfZGlmZl9hbGdvcml0aG0pOwoKCWlmICghcmVwb19jb25maWdfZ2V0X2ludChyLCAiZGlmZi5jb250ZXh0IiwgJnMtPmNvbnRleHQpKQoJCWlmIChzLT5jb250ZXh0IDwgMCkKCQkJZGllKF8oIiVzIGNhbm5vdCBiZSBuZWdhdGl2ZSIpLCAiZGlmZi5jb250ZXh0Iik7CglpZiAoIXJlcG9fY29uZmlnX2dldF9pbnQociwgImRpZmYuaW50ZXJIdW5rQ29udGV4dCIsICZzLT5pbnRlcmh1bmtjb250ZXh0KSkKCQlpZiAocy0+aW50ZXJodW5rY29udGV4dCA8IDApCgkJCWRpZShfKCIlcyBjYW5ub3QgYmUgbmVnYXRpdmUiKSwgImRpZmYuaW50ZXJIdW5rQ29udGV4dCIpOwoKCXJlcG9fY29uZmlnX2dldF9ib29sKHIsICJpbnRlcmFjdGl2ZS5zaW5nbGVrZXkiLCAmcy0+dXNlX3NpbmdsZV9rZXkpOwoJaWYgKHMtPnVzZV9zaW5nbGVfa2V5KQoJCXNldGJ1ZihzdGRpbiwgTlVMTCk7CgoJaWYgKGFkZF9wX29wdC0+Y29udGV4dCAhPSAtMSkgewoJCWlmIChhZGRfcF9vcHQtPmNvbnRleHQgPCAwKQoJCQlkaWUoXygiJXMgY2Fubm90IGJlIG5lZ2F0aXZlIiksICItLXVuaWZpZWQiKTsKCQlzLT5jb250ZXh0ID0gYWRkX3Bfb3B0LT5jb250ZXh0OwoJfQoJaWYgKGFkZF9wX29wdC0+aW50ZXJodW5rY29udGV4dCAhPSAtMSkgewoJCWlmIChhZGRfcF9vcHQtPmludGVyaHVua2NvbnRleHQgPCAwKQoJCQlkaWUoXygiJXMgY2Fubm90IGJlIG5lZ2F0aXZlIiksICItLWludGVyLWh1bmstY29udGV4dCIpOwoJCXMtPmludGVyaHVua2NvbnRleHQgPSBhZGRfcF9vcHQtPmludGVyaHVua2NvbnRleHQ7Cgl9Cn0KCnZvaWQgY2xlYXJfYWRkX2lfc3RhdGUoc3RydWN0IGFkZF9pX3N0YXRlICpzKQp7CglGUkVFX0FORF9OVUxMKHMtPmludGVyYWN0aXZlX2RpZmZfZmlsdGVyKTsKCUZSRUVfQU5EX05VTEwocy0+aW50ZXJhY3RpdmVfZGlmZl9hbGdvcml0aG0pOwoJbWVtc2V0KHMsIDAsIHNpemVvZigqcykpOwoJcy0+dXNlX2NvbG9yX2ludGVyYWN0aXZlID0gR0lUX0NPTE9SX1VOS05PV047CglzLT51c2VfY29sb3JfZGlmZiA9IEdJVF9DT0xPUl9VTktOT1dOOwp9CgovKgogKiBBICJwcmVmaXggaXRlbSBsaXN0IiBpcyBhIGxpc3Qgb2YgaXRlbXMgdGhhdCBhcmUgaWRlbnRpZmllZCBieSBhIHN0cmluZywgYW5kCiAqIGEgdW5pcXVlIHByZWZpeCAoaWYgYW55KSBpcyBkZXRlcm1pbmVkIGZvciBlYWNoIGl0ZW0uCiAqCiAqIEl0IGlzIGltcGxlbWVudGVkIGluIHRoZSBmb3JtIG9mIGEgcGFpciBvZiBgc3RyaW5nX2xpc3RgcywgdGhlIGZpcnN0IG9uZQogKiBkdXBsaWNhdGluZyB0aGUgc3RyaW5ncywgd2l0aCB0aGUgYHV0aWxgIGZpZWxkIHBvaW50aW5nIGF0IGEgc3RydWN0dXJlIHdob3NlCiAqIGZpcnN0IGZpZWxkIG11c3QgYmUgYHNpemVfdCBwcmVmaXhfbGVuZ3RoYC4KICoKICogVGhhdCBgcHJlZml4X2xlbmd0aGAgZmllbGQgd2lsbCBiZSBjb21wdXRlZCBieSBgZmluZF91bmlxdWVfcHJlZml4ZXMoKWA7IEl0CiAqIHdpbGwgYmUgc2V0IHRvIHplcm8gaWYgbm8gdmFsaWQsIHVuaXF1ZSBwcmVmaXggY291bGQgYmUgZm91bmQuCiAqCiAqIFRoZSBzZWNvbmQgYHN0cmluZ19saXN0YCBpcyBjYWxsZWQgYHNvcnRlZGAgYW5kIGRvZXMgX25vdF8gZHVwbGljYXRlIHRoZQogKiBzdHJpbmdzIGJ1dCBzaW1wbHkgcmV1c2VzIHRoZSBmaXJzdCBvbmUncywgd2l0aCB0aGUgYHV0aWxgIGZpZWxkIHBvaW50aW5nIGF0CiAqIHRoZSBgc3RyaW5nX2l0ZW1fbGlzdGAgb2YgdGhlIGZpcnN0IGBzdHJpbmdfbGlzdGAuIEl0ICB3aWxsIGJlIHBvcHVsYXRlZCBhbmQKICogc29ydGVkIGJ5IGBmaW5kX3VuaXF1ZV9wcmVmaXhlcygpYC4KICovCnN0cnVjdCBwcmVmaXhfaXRlbV9saXN0IHsKCXN0cnVjdCBzdHJpbmdfbGlzdCBpdGVtczsKCXN0cnVjdCBzdHJpbmdfbGlzdCBzb3J0ZWQ7CglpbnQgKnNlbGVjdGVkOyAvKiBmb3IgbXVsdGktc2VsZWN0aW9ucyAqLwoJc2l6ZV90IG1pbl9sZW5ndGgsIG1heF9sZW5ndGg7Cn07CiNkZWZpbmUgUFJFRklYX0lURU1fTElTVF9JTklUIHsgXAoJLml0ZW1zID0gU1RSSU5HX0xJU1RfSU5JVF9EVVAsIFwKCS5zb3J0ZWQgPSBTVFJJTkdfTElTVF9JTklUX05PRFVQLCBcCgkubWluX2xlbmd0aCA9IDEsIFwKCS5tYXhfbGVuZ3RoID0gNCwgXAp9CgpzdGF0aWMgdm9pZCBwcmVmaXhfaXRlbV9saXN0X2NsZWFyKHN0cnVjdCBwcmVmaXhfaXRlbV9saXN0ICpsaXN0KQp7CglzdHJpbmdfbGlzdF9jbGVhcigmbGlzdC0+aXRlbXMsIDEpOwoJc3RyaW5nX2xpc3RfY2xlYXIoJmxpc3QtPnNvcnRlZCwgMCk7CglGUkVFX0FORF9OVUxMKGxpc3QtPnNlbGVjdGVkKTsKfQoKc3RhdGljIHZvaWQgZXh0ZW5kX3ByZWZpeF9sZW5ndGgoc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKnAsCgkJCQkgY29uc3QgY2hhciAqb3RoZXJfc3RyaW5nLCBzaXplX3QgbWF4X2xlbmd0aCkKewoJc2l6ZV90ICpsZW4gPSBwLT51dGlsOwoKCWlmICghKmxlbiB8fCBtZW1jbXAocC0+c3RyaW5nLCBvdGhlcl9zdHJpbmcsICpsZW4pKQoJCXJldHVybjsKCglmb3IgKDs7KSB7CgkJY2hhciBjID0gcC0+c3RyaW5nWypsZW5dOwoKCQkvKgoJCSAqIElzIGBwYCBhIHN0cmljdCBwcmVmaXggb2YgYG90aGVyYD8gT3IgaGF2ZSB3ZSBleGhhdXN0ZWQgdGhlCgkJICogbWF4aW1hbCBsZW5ndGggb2YgdGhlIHByZWZpeD8gT3IgaXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGEKCQkgKiBtdWx0aS1ieXRlIFVURi04IG9uZT8gSWYgc28sIHRoZXJlIGlzIG5vIHZhbGlkLCB1bmlxdWUKCQkgKiBwcmVmaXguCgkJICovCgkJaWYgKCFjIHx8ICsrKmxlbiA+IG1heF9sZW5ndGggfHwgIWlzYXNjaWkoYykpIHsKCQkJKmxlbiA9IDA7CgkJCWJyZWFrOwoJCX0KCgkJaWYgKGMgIT0gb3RoZXJfc3RyaW5nWypsZW4gLSAxXSkKCQkJYnJlYWs7Cgl9Cn0KCnN0YXRpYyB2b2lkIGZpbmRfdW5pcXVlX3ByZWZpeGVzKHN0cnVjdCBwcmVmaXhfaXRlbV9saXN0ICpsaXN0KQp7CglzaXplX3QgaTsKCglpZiAobGlzdC0+c29ydGVkLm5yID09IGxpc3QtPml0ZW1zLm5yKQoJCXJldHVybjsKCglzdHJpbmdfbGlzdF9jbGVhcigmbGlzdC0+c29ydGVkLCAwKTsKCS8qIEF2b2lkIHJlYWxsb2NhdGluZyBpbmNyZW1lbnRhbGx5ICovCglsaXN0LT5zb3J0ZWQuaXRlbXMgPSB4bWFsbG9jKHN0X211bHQoc2l6ZW9mKCpsaXN0LT5zb3J0ZWQuaXRlbXMpLAoJCQkJCSAgICAgbGlzdC0+aXRlbXMubnIpKTsKCWxpc3QtPnNvcnRlZC5uciA9IGxpc3QtPnNvcnRlZC5hbGxvYyA9IGxpc3QtPml0ZW1zLm5yOwoKCWZvciAoaSA9IDA7IGkgPCBsaXN0LT5pdGVtcy5ucjsgaSsrKSB7CgkJbGlzdC0+c29ydGVkLml0ZW1zW2ldLnN0cmluZyA9IGxpc3QtPml0ZW1zLml0ZW1zW2ldLnN0cmluZzsKCQlsaXN0LT5zb3J0ZWQuaXRlbXNbaV0udXRpbCA9IGxpc3QtPml0ZW1zLml0ZW1zICsgaTsKCX0KCglzdHJpbmdfbGlzdF9zb3J0KCZsaXN0LT5zb3J0ZWQpOwoKCWZvciAoaSA9IDA7IGkgPCBsaXN0LT5zb3J0ZWQubnI7IGkrKykgewoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICpzb3J0ZWRfaXRlbSA9IGxpc3QtPnNvcnRlZC5pdGVtcyArIGk7CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW0gPSBzb3J0ZWRfaXRlbS0+dXRpbDsKCQlzaXplX3QgKmxlbiA9IGl0ZW0tPnV0aWw7CgoJCSpsZW4gPSAwOwoJCXdoaWxlICgqbGVuIDwgbGlzdC0+bWluX2xlbmd0aCkgewoJCQljaGFyIGMgPSBpdGVtLT5zdHJpbmdbKCpsZW4pKytdOwoKCQkJaWYgKCFjIHx8ICFpc2FzY2lpKGMpKSB7CgkJCQkqbGVuID0gMDsKCQkJCWJyZWFrOwoJCQl9CgkJfQoKCQlpZiAoaSA+IDApCgkJCWV4dGVuZF9wcmVmaXhfbGVuZ3RoKGl0ZW0sIHNvcnRlZF9pdGVtWy0xXS5zdHJpbmcsCgkJCQkJICAgICBsaXN0LT5tYXhfbGVuZ3RoKTsKCQlpZiAoaSArIDEgPCBsaXN0LT5zb3J0ZWQubnIpCgkJCWV4dGVuZF9wcmVmaXhfbGVuZ3RoKGl0ZW0sIHNvcnRlZF9pdGVtWzFdLnN0cmluZywKCQkJCQkgICAgIGxpc3QtPm1heF9sZW5ndGgpOwoJfQp9CgpzdGF0aWMgc3NpemVfdCBmaW5kX3VuaXF1ZShjb25zdCBjaGFyICpzdHJpbmcsIHN0cnVjdCBwcmVmaXhfaXRlbV9saXN0ICpsaXN0KQp7CglpbnQgaW5kZXggPSBzdHJpbmdfbGlzdF9maW5kX2luc2VydF9pbmRleCgmbGlzdC0+c29ydGVkLCBzdHJpbmcsIDEpOwoJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW07CgoJaWYgKGxpc3QtPml0ZW1zLm5yICE9IGxpc3QtPnNvcnRlZC5ucikKCQlCVUcoInByZWZpeF9pdGVtX2xpc3QgaW4gaW5jb25zaXN0ZW50IHN0YXRlICglIlBSSXVNQVgKCQkgICAgIiB2cyAlIlBSSXVNQVgiKSIsCgkJICAgICh1aW50bWF4X3QpbGlzdC0+aXRlbXMubnIsICh1aW50bWF4X3QpbGlzdC0+c29ydGVkLm5yKTsKCglpZiAoaW5kZXggPCAwKQoJCWl0ZW0gPSBsaXN0LT5zb3J0ZWQuaXRlbXNbLTEgLSBpbmRleF0udXRpbDsKCWVsc2UgaWYgKGluZGV4ID4gMCAmJgoJCSBzdGFydHNfd2l0aChsaXN0LT5zb3J0ZWQuaXRlbXNbaW5kZXggLSAxXS5zdHJpbmcsIHN0cmluZykpCgkJcmV0dXJuIC0xOwoJZWxzZSBpZiAoaW5kZXggKyAxIDwgbGlzdC0+c29ydGVkLm5yICYmCgkJIHN0YXJ0c193aXRoKGxpc3QtPnNvcnRlZC5pdGVtc1tpbmRleCArIDFdLnN0cmluZywgc3RyaW5nKSkKCQlyZXR1cm4gLTE7CgllbHNlIGlmIChpbmRleCA8IGxpc3QtPnNvcnRlZC5uciAmJgoJCSBzdGFydHNfd2l0aChsaXN0LT5zb3J0ZWQuaXRlbXNbaW5kZXhdLnN0cmluZywgc3RyaW5nKSkKCQlpdGVtID0gbGlzdC0+c29ydGVkLml0ZW1zW2luZGV4XS51dGlsOwoJZWxzZQoJCXJldHVybiAtMTsKCXJldHVybiBpdGVtIC0gbGlzdC0+aXRlbXMuaXRlbXM7Cn0KCnN0cnVjdCBsaXN0X29wdGlvbnMgewoJaW50IGNvbHVtbnM7Cgljb25zdCBjaGFyICpoZWFkZXI7Cgl2b2lkICgqcHJpbnRfaXRlbSkoaW50IGksIGludCBzZWxlY3RlZCwgc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW0sCgkJCSAgIHZvaWQgKnByaW50X2l0ZW1fZGF0YSk7Cgl2b2lkICpwcmludF9pdGVtX2RhdGE7Cn07CgpzdGF0aWMgdm9pZCBsaXN0KHN0cnVjdCBhZGRfaV9zdGF0ZSAqcywgc3RydWN0IHN0cmluZ19saXN0ICpsaXN0LCBpbnQgKnNlbGVjdGVkLAoJCSBzdHJ1Y3QgbGlzdF9vcHRpb25zICpvcHRzKQp7CglpbnQgaSwgbGFzdF9sZiA9IDA7CgoJaWYgKCFsaXN0LT5ucikKCQlyZXR1cm47CgoJaWYgKG9wdHMtPmhlYWRlcikKCQljb2xvcl9mcHJpbnRmX2xuKHN0ZG91dCwgcy0+aGVhZGVyX2NvbG9yLAoJCQkJICIlcyIsIG9wdHMtPmhlYWRlcik7CgoJZm9yIChpID0gMDsgaSA8IGxpc3QtPm5yOyBpKyspIHsKCQlvcHRzLT5wcmludF9pdGVtKGksIHNlbGVjdGVkID8gc2VsZWN0ZWRbaV0gOiAwLCBsaXN0LT5pdGVtcyArIGksCgkJCQkgb3B0cy0+cHJpbnRfaXRlbV9kYXRhKTsKCgkJaWYgKChvcHRzLT5jb2x1bW5zKSAmJiAoKGkgKyAxKSAlIChvcHRzLT5jb2x1bW5zKSkpIHsKCQkJcHV0Y2hhcignXHQnKTsKCQkJbGFzdF9sZiA9IDA7CgkJfQoJCWVsc2UgewoJCQlwdXRjaGFyKCdcbicpOwoJCQlsYXN0X2xmID0gMTsKCQl9Cgl9CgoJaWYgKCFsYXN0X2xmKQoJCXB1dGNoYXIoJ1xuJyk7Cn0Kc3RydWN0IGxpc3RfYW5kX2Nob29zZV9vcHRpb25zIHsKCXN0cnVjdCBsaXN0X29wdGlvbnMgbGlzdF9vcHRzOwoKCWNvbnN0IGNoYXIgKnByb21wdDsKCWVudW0gewoJCVNJTkdMRVRPTiA9ICgxPDwwKSwKCQlJTU1FRElBVEUgPSAoMTw8MSksCgl9IGZsYWdzOwoJdm9pZCAoKnByaW50X2hlbHApKHN0cnVjdCBhZGRfaV9zdGF0ZSAqcyk7Cn07CgojZGVmaW5lIExJU1RfQU5EX0NIT09TRV9FUlJPUiAoLTEpCiNkZWZpbmUgTElTVF9BTkRfQ0hPT1NFX1FVSVQgICgtMikKCi8qCiAqIFJldHVybnMgdGhlIHNlbGVjdGVkIGluZGV4IGluIHNpbmdsZXRvbiBtb2RlLCB0aGUgbnVtYmVyIG9mIHNlbGVjdGVkIGl0ZW1zCiAqIG90aGVyd2lzZS4KICoKICogSWYgYW4gZXJyb3Igb2NjdXJyZWQsIHJldHVybnMgYExJU1RfQU5EX0NIT09TRV9FUlJPUmAuIFVwb24gRU9GLAogKiBgTElTVF9BTkRfQ0hPT1NFX1FVSVRgIGlzIHJldHVybmVkLgogKi8Kc3RhdGljIHNzaXplX3QgbGlzdF9hbmRfY2hvb3NlKHN0cnVjdCBhZGRfaV9zdGF0ZSAqcywKCQkJICAgICAgIHN0cnVjdCBwcmVmaXhfaXRlbV9saXN0ICppdGVtcywKCQkJICAgICAgIHN0cnVjdCBsaXN0X2FuZF9jaG9vc2Vfb3B0aW9ucyAqb3B0cykKewoJaW50IHNpbmdsZXRvbiA9IG9wdHMtPmZsYWdzICYgU0lOR0xFVE9OOwoJaW50IGltbWVkaWF0ZSA9IG9wdHMtPmZsYWdzICYgSU1NRURJQVRFOwoKCXN0cnVjdCBzdHJidWYgaW5wdXQgPSBTVFJCVUZfSU5JVDsKCXNzaXplX3QgcmVzID0gc2luZ2xldG9uID8gTElTVF9BTkRfQ0hPT1NFX0VSUk9SIDogMDsKCglpZiAoIXNpbmdsZXRvbikgewoJCWZyZWUoaXRlbXMtPnNlbGVjdGVkKTsKCQlDQUxMT0NfQVJSQVkoaXRlbXMtPnNlbGVjdGVkLCBpdGVtcy0+aXRlbXMubnIpOwoJfQoKCWlmIChzaW5nbGV0b24gJiYgIWltbWVkaWF0ZSkKCQlCVUcoInNpbmdsZXRvbiByZXF1aXJlcyBpbW1lZGlhdGUiKTsKCglmaW5kX3VuaXF1ZV9wcmVmaXhlcyhpdGVtcyk7CgoJZm9yICg7OykgewoJCWNoYXIgKnA7CgoJCXN0cmJ1Zl9yZXNldCgmaW5wdXQpOwoKCQlsaXN0KHMsICZpdGVtcy0+aXRlbXMsIGl0ZW1zLT5zZWxlY3RlZCwgJm9wdHMtPmxpc3Rfb3B0cyk7CgoJCWNvbG9yX2ZwcmludGYoc3Rkb3V0LCBzLT5wcm9tcHRfY29sb3IsICIlcyIsIG9wdHMtPnByb21wdCk7CgkJZnB1dHMoc2luZ2xldG9uID8gIj4gIiA6ICI+PiAiLCBzdGRvdXQpOwoJCWZmbHVzaChzdGRvdXQpOwoKCQlpZiAoZ2l0X3JlYWRfbGluZV9pbnRlcmFjdGl2ZWx5KCZpbnB1dCkgPT0gRU9GKSB7CgkJCXB1dGNoYXIoJ1xuJyk7CgkJCWlmIChpbW1lZGlhdGUpCgkJCQlyZXMgPSBMSVNUX0FORF9DSE9PU0VfUVVJVDsKCQkJYnJlYWs7CgkJfQoKCQlpZiAoIWlucHV0LmxlbikKCQkJYnJlYWs7CgoJCWlmICghc3RyY21wKGlucHV0LmJ1ZiwgIj8iKSkgewoJCQlvcHRzLT5wcmludF9oZWxwKHMpOwoJCQljb250aW51ZTsKCQl9CgoJCXAgPSBpbnB1dC5idWY7CgkJZm9yICg7OykgewoJCQlzaXplX3Qgc2VwID0gc3RyY3NwbihwLCAiIFx0XHJcbiwiKTsKCQkJaW50IGNob29zZSA9IDE7CgkJCS8qIGBmcm9tYCBpcyBpbmNsdXNpdmUsIGB0b2AgaXMgZXhjbHVzaXZlICovCgkJCXNzaXplX3QgZnJvbSA9IC0xLCB0byA9IC0xOwoKCQkJaWYgKCFzZXApIHsKCQkJCWlmICghKnApCgkJCQkJYnJlYWs7CgkJCQlwKys7CgkJCQljb250aW51ZTsKCQkJfQoKCQkJLyogSW5wdXQgdGhhdCBiZWdpbnMgd2l0aCAnLSc7IGRlLXNlbGVjdCAqLwoJCQlpZiAoKnAgPT0gJy0nKSB7CgkJCQljaG9vc2UgPSAwOwoJCQkJcCsrOwoJCQkJc2VwLS07CgkJCX0KCgkJCWlmIChzZXAgPT0gMSAmJiAqcCA9PSAnKicpIHsKCQkJCWZyb20gPSAwOwoJCQkJdG8gPSBpdGVtcy0+aXRlbXMubnI7CgkJCX0gZWxzZSBpZiAoaXNkaWdpdCgqcCkpIHsKCQkJCWNoYXIgKmVuZHA7CgkJCQkvKgoJCQkJICogQSByYW5nZSBjYW4gYmUgc3BlY2lmaWVkIGxpa2UgNS03IG9yIDUtLgoJCQkJICoKCQkJCSAqIE5vdGU6IGBmcm9tYCBpcyAwLWJhc2VkIHdoaWxlIHRoZSB1c2VyIGlucHV0CgkJCQkgKiBpcyAxLWJhc2VkLCBoZW5jZSB3ZSBoYXZlIHRvIGRlY3JlbWVudCBieQoJCQkJICogb25lLiBXZSBkbyBub3QgaGF2ZSB0byBkZWNyZW1lbnQgYHRvYCBldmVuCgkJCQkgKiBpZiBpdCBpcyAwLWJhc2VkIGJlY2F1c2UgaXQgaXMgYW4gZXhjbHVzaXZlCgkJCQkgKiBib3VuZGFyeS4KCQkJCSAqLwoJCQkJZnJvbSA9IHN0cnRvdWwocCwgJmVuZHAsIDEwKSAtIDE7CgkJCQlpZiAoZW5kcCA9PSBwICsgc2VwKQoJCQkJCXRvID0gZnJvbSArIDE7CgkJCQllbHNlIGlmICgqZW5kcCA9PSAnLScpIHsKCQkJCQlpZiAoaXNkaWdpdCgqKCsrZW5kcCkpKQoJCQkJCQl0byA9IHN0cnRvdWwoZW5kcCwgJmVuZHAsIDEwKTsKCQkJCQllbHNlCgkJCQkJCXRvID0gaXRlbXMtPml0ZW1zLm5yOwoJCQkJCS8qIGV4dHJhIGNoYXJhY3RlcnMgYWZ0ZXIgdGhlIHJhbmdlPyAqLwoJCQkJCWlmIChlbmRwICE9IHAgKyBzZXApCgkJCQkJCWZyb20gPSAtMTsKCQkJCX0KCQkJfQoKCQkJaWYgKHBbc2VwXSkKCQkJCXBbc2VwKytdID0gJ1wwJzsKCQkJaWYgKGZyb20gPCAwKSB7CgkJCQlmcm9tID0gZmluZF91bmlxdWUocCwgaXRlbXMpOwoJCQkJaWYgKGZyb20gPj0gMCkKCQkJCQl0byA9IGZyb20gKyAxOwoJCQl9CgoJCQlpZiAoZnJvbSA8IDAgfHwgZnJvbSA+PSBpdGVtcy0+aXRlbXMubnIgfHwKCQkJICAgIChzaW5nbGV0b24gJiYgZnJvbSArIDEgIT0gdG8pKSB7CgkJCQljb2xvcl9mcHJpbnRmX2xuKHN0ZGVyciwgcy0+ZXJyb3JfY29sb3IsCgkJCQkJCSBfKCJIdWggKCVzKT8iKSwgcCk7CgkJCQlicmVhazsKCQkJfSBlbHNlIGlmIChzaW5nbGV0b24pIHsKCQkJCXJlcyA9IGZyb207CgkJCQlicmVhazsKCQkJfQoKCQkJaWYgKHRvID4gaXRlbXMtPml0ZW1zLm5yKQoJCQkJdG8gPSBpdGVtcy0+aXRlbXMubnI7CgoJCQlmb3IgKDsgZnJvbSA8IHRvOyBmcm9tKyspCgkJCQlpZiAoaXRlbXMtPnNlbGVjdGVkW2Zyb21dICE9IGNob29zZSkgewoJCQkJCWl0ZW1zLT5zZWxlY3RlZFtmcm9tXSA9IGNob29zZTsKCQkJCQlyZXMgKz0gY2hvb3NlID8gKzEgOiAtMTsKCQkJCX0KCgkJCXAgKz0gc2VwOwoJCX0KCgkJaWYgKChpbW1lZGlhdGUgJiYgcmVzICE9IExJU1RfQU5EX0NIT09TRV9FUlJPUikgfHwKCQkgICAgIXN0cmNtcChpbnB1dC5idWYsICIqIikpCgkJCWJyZWFrOwoJfQoKCXN0cmJ1Zl9yZWxlYXNlKCZpbnB1dCk7CglyZXR1cm4gcmVzOwp9CgpzdHJ1Y3QgYWRkZGVsIHsKCXVpbnRtYXhfdCBhZGQsIGRlbDsKCXVuc2lnbmVkIHNlZW46MSwgdW5tZXJnZWQ6MSwgYmluYXJ5OjE7Cn07CgpzdHJ1Y3QgZmlsZV9pdGVtIHsKCXNpemVfdCBwcmVmaXhfbGVuZ3RoOwoJc3RydWN0IGFkZGRlbCBpbmRleCwgd29ya3RyZWU7Cn07CgpzdGF0aWMgdm9pZCBhZGRfZmlsZV9pdGVtKHN0cnVjdCBzdHJpbmdfbGlzdCAqZmlsZXMsIGNvbnN0IGNoYXIgKm5hbWUpCnsKCXN0cnVjdCBmaWxlX2l0ZW0gKml0ZW0gPSB4Y2FsbG9jKDEsIHNpemVvZigqaXRlbSkpOwoKCXN0cmluZ19saXN0X2FwcGVuZChmaWxlcywgbmFtZSktPnV0aWwgPSBpdGVtOwp9CgpzdHJ1Y3QgcGF0aG5hbWVfZW50cnkgewoJc3RydWN0IGhhc2htYXBfZW50cnkgZW50OwoJY29uc3QgY2hhciAqbmFtZTsKCXN0cnVjdCBmaWxlX2l0ZW0gKml0ZW07Cn07CgpzdGF0aWMgaW50IHBhdGhuYW1lX2VudHJ5X2NtcChjb25zdCB2b2lkICpjbXBfZGF0YSBVTlVTRUQsCgkJCSAgICAgIGNvbnN0IHN0cnVjdCBoYXNobWFwX2VudHJ5ICpoZTEsCgkJCSAgICAgIGNvbnN0IHN0cnVjdCBoYXNobWFwX2VudHJ5ICpoZTIsCgkJCSAgICAgIGNvbnN0IHZvaWQgKm5hbWUpCnsKCWNvbnN0IHN0cnVjdCBwYXRobmFtZV9lbnRyeSAqZTEgPQoJCWNvbnRhaW5lcl9vZihoZTEsIGNvbnN0IHN0cnVjdCBwYXRobmFtZV9lbnRyeSwgZW50KTsKCWNvbnN0IHN0cnVjdCBwYXRobmFtZV9lbnRyeSAqZTIgPQoJCWNvbnRhaW5lcl9vZihoZTIsIGNvbnN0IHN0cnVjdCBwYXRobmFtZV9lbnRyeSwgZW50KTsKCglyZXR1cm4gc3RyY21wKGUxLT5uYW1lLCBuYW1lID8gKGNvbnN0IGNoYXIgKiluYW1lIDogZTItPm5hbWUpOwp9CgpzdHJ1Y3QgY29sbGVjdGlvbl9zdGF0dXMgewoJZW51bSB7IEZST01fV09SS1RSRUUgPSAwLCBGUk9NX0lOREVYID0gMSB9IG1vZGU7CgoJY29uc3QgY2hhciAqcmVmZXJlbmNlOwoKCXVuc2lnbmVkIHNraXBfdW5zZWVuOjE7CglzaXplX3QgdW5tZXJnZWRfY291bnQsIGJpbmFyeV9jb3VudDsKCXN0cnVjdCBzdHJpbmdfbGlzdCAqZmlsZXM7CglzdHJ1Y3QgaGFzaG1hcCBmaWxlX21hcDsKfTsKCnN0YXRpYyB2b2lkIGNvbGxlY3RfY2hhbmdlc19jYihzdHJ1Y3QgZGlmZl9xdWV1ZV9zdHJ1Y3QgKnEsCgkJCSAgICAgICBzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHRpb25zLAoJCQkgICAgICAgdm9pZCAqZGF0YSkKewoJc3RydWN0IGNvbGxlY3Rpb25fc3RhdHVzICpzID0gZGF0YTsKCXN0cnVjdCBkaWZmc3RhdF90IHN0YXQgPSB7IDAgfTsKCWludCBpOwoKCWlmICghcS0+bnIpCgkJcmV0dXJuOwoKCWNvbXB1dGVfZGlmZnN0YXQob3B0aW9ucywgJnN0YXQsIHEpOwoKCWZvciAoaSA9IDA7IGkgPCBzdGF0Lm5yOyBpKyspIHsKCQljb25zdCBjaGFyICpuYW1lID0gc3RhdC5maWxlc1tpXS0+bmFtZTsKCQlpbnQgaGFzaCA9IHN0cmhhc2gobmFtZSk7CgkJc3RydWN0IHBhdGhuYW1lX2VudHJ5ICplbnRyeTsKCQlzdHJ1Y3QgZmlsZV9pdGVtICpmaWxlX2l0ZW07CgkJc3RydWN0IGFkZGRlbCAqYWRkZGVsLCAqb3RoZXJfYWRkZGVsOwoKCQllbnRyeSA9IGhhc2htYXBfZ2V0X2VudHJ5X2Zyb21faGFzaCgmcy0+ZmlsZV9tYXAsIGhhc2gsIG5hbWUsCgkJCQkJCSAgICBzdHJ1Y3QgcGF0aG5hbWVfZW50cnksIGVudCk7CgkJaWYgKCFlbnRyeSkgewoJCQlpZiAocy0+c2tpcF91bnNlZW4pCgkJCQljb250aW51ZTsKCgkJCWFkZF9maWxlX2l0ZW0ocy0+ZmlsZXMsIG5hbWUpOwoKCQkJQ0FMTE9DX0FSUkFZKGVudHJ5LCAxKTsKCQkJaGFzaG1hcF9lbnRyeV9pbml0KCZlbnRyeS0+ZW50LCBoYXNoKTsKCQkJZW50cnktPm5hbWUgPSBzLT5maWxlcy0+aXRlbXNbcy0+ZmlsZXMtPm5yIC0gMV0uc3RyaW5nOwoJCQllbnRyeS0+aXRlbSA9IHMtPmZpbGVzLT5pdGVtc1tzLT5maWxlcy0+bnIgLSAxXS51dGlsOwoJCQloYXNobWFwX2FkZCgmcy0+ZmlsZV9tYXAsICZlbnRyeS0+ZW50KTsKCQl9CgoJCWZpbGVfaXRlbSA9IGVudHJ5LT5pdGVtOwoJCWFkZGRlbCA9IHMtPm1vZGUgPT0gRlJPTV9JTkRFWCA/CgkJCSZmaWxlX2l0ZW0tPmluZGV4IDogJmZpbGVfaXRlbS0+d29ya3RyZWU7CgkJb3RoZXJfYWRkZGVsID0gcy0+bW9kZSA9PSBGUk9NX0lOREVYID8KCQkJJmZpbGVfaXRlbS0+d29ya3RyZWUgOiAmZmlsZV9pdGVtLT5pbmRleDsKCQlhZGRkZWwtPnNlZW4gPSAxOwoJCWFkZGRlbC0+YWRkID0gc3RhdC5maWxlc1tpXS0+YWRkZWQ7CgkJYWRkZGVsLT5kZWwgPSBzdGF0LmZpbGVzW2ldLT5kZWxldGVkOwoJCWlmIChzdGF0LmZpbGVzW2ldLT5pc19iaW5hcnkpIHsKCQkJaWYgKCFvdGhlcl9hZGRkZWwtPmJpbmFyeSkKCQkJCXMtPmJpbmFyeV9jb3VudCsrOwoJCQlhZGRkZWwtPmJpbmFyeSA9IDE7CgkJfQoJCWlmIChzdGF0LmZpbGVzW2ldLT5pc191bm1lcmdlZCkgewoJCQlpZiAoIW90aGVyX2FkZGRlbC0+dW5tZXJnZWQpCgkJCQlzLT51bm1lcmdlZF9jb3VudCsrOwoJCQlhZGRkZWwtPnVubWVyZ2VkID0gMTsKCQl9Cgl9CglmcmVlX2RpZmZzdGF0X2luZm8oJnN0YXQpOwp9CgplbnVtIG1vZGlmaWVkX2ZpbGVzX2ZpbHRlciB7CglOT19GSUxURVIgPSAwLAoJV09SS1RSRUVfT05MWSA9IDEsCglJTkRFWF9PTkxZID0gMiwKfTsKCnN0YXRpYyBpbnQgZ2V0X21vZGlmaWVkX2ZpbGVzKHN0cnVjdCByZXBvc2l0b3J5ICpyLAoJCQkgICAgICBlbnVtIG1vZGlmaWVkX2ZpbGVzX2ZpbHRlciBmaWx0ZXIsCgkJCSAgICAgIHN0cnVjdCBwcmVmaXhfaXRlbV9saXN0ICpmaWxlcywKCQkJICAgICAgY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwcywKCQkJICAgICAgc2l6ZV90ICp1bm1lcmdlZF9jb3VudCwKCQkJICAgICAgc2l6ZV90ICpiaW5hcnlfY291bnQpCnsKCXN0cnVjdCBvYmplY3RfaWQgaGVhZF9vaWQ7CglpbnQgaXNfaW5pdGlhbCA9ICFyZWZzX3Jlc29sdmVfcmVmX3Vuc2FmZShnZXRfbWFpbl9yZWZfc3RvcmUociksCgkJCQkJCSAgIkhFQUQiLCBSRVNPTFZFX1JFRl9SRUFESU5HLAoJCQkJCQkgICZoZWFkX29pZCwgTlVMTCk7CglzdHJ1Y3QgY29sbGVjdGlvbl9zdGF0dXMgcyA9IHsgMCB9OwoJaW50IGk7CgoJZGlzY2FyZF9pbmRleChyLT5pbmRleCk7CglpZiAocmVwb19yZWFkX2luZGV4X3ByZWxvYWQociwgcHMsIDApIDwgMCkKCQlyZXR1cm4gZXJyb3IoXygiY291bGQgbm90IHJlYWQgaW5kZXgiKSk7CgoJcHJlZml4X2l0ZW1fbGlzdF9jbGVhcihmaWxlcyk7CglzLmZpbGVzID0gJmZpbGVzLT5pdGVtczsKCWhhc2htYXBfaW5pdCgmcy5maWxlX21hcCwgcGF0aG5hbWVfZW50cnlfY21wLCBOVUxMLCAwKTsKCglmb3IgKGkgPSAwOyBpIDwgMjsgaSsrKSB7CgkJc3RydWN0IHJldl9pbmZvIHJldjsKCQlzdHJ1Y3Qgc2V0dXBfcmV2aXNpb25fb3B0IG9wdCA9IHsgMCB9OwoKCQlpZiAoZmlsdGVyID09IElOREVYX09OTFkpCgkJCXMubW9kZSA9IChpID09IDApID8gRlJPTV9JTkRFWCA6IEZST01fV09SS1RSRUU7CgkJZWxzZQoJCQlzLm1vZGUgPSAoaSA9PSAwKSA/IEZST01fV09SS1RSRUUgOiBGUk9NX0lOREVYOwoJCXMuc2tpcF91bnNlZW4gPSBmaWx0ZXIgJiYgaTsKCgkJb3B0LmRlZiA9IGlzX2luaXRpYWwgPwoJCQllbXB0eV90cmVlX29pZF9oZXgoci0+aGFzaF9hbGdvKSA6IG9pZF90b19oZXgoJmhlYWRfb2lkKTsKCgkJcmVwb19pbml0X3JldmlzaW9ucyhyLCAmcmV2LCBOVUxMKTsKCQlzZXR1cF9yZXZpc2lvbnMoMCwgTlVMTCwgJnJldiwgJm9wdCk7CgoJCXJldi5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9DQUxMQkFDSzsKCQlyZXYuZGlmZm9wdC5mb3JtYXRfY2FsbGJhY2sgPSBjb2xsZWN0X2NoYW5nZXNfY2I7CgkJcmV2LmRpZmZvcHQuZm9ybWF0X2NhbGxiYWNrX2RhdGEgPSAmczsKCgkJaWYgKHBzKQoJCQljb3B5X3BhdGhzcGVjKCZyZXYucHJ1bmVfZGF0YSwgcHMpOwoKCQlpZiAocy5tb2RlID09IEZST01fSU5ERVgpCgkJCXJ1bl9kaWZmX2luZGV4KCZyZXYsIERJRkZfSU5ERVhfQ0FDSEVEKTsKCQllbHNlIHsKCQkJcmV2LmRpZmZvcHQuZmxhZ3MuaWdub3JlX2RpcnR5X3N1Ym1vZHVsZXMgPSAxOwoJCQlydW5fZGlmZl9maWxlcygmcmV2LCAwKTsKCQl9CgoJCXJlbGVhc2VfcmV2aXNpb25zKCZyZXYpOwoJfQoJaGFzaG1hcF9jbGVhcl9hbmRfZnJlZSgmcy5maWxlX21hcCwgc3RydWN0IHBhdGhuYW1lX2VudHJ5LCBlbnQpOwoJaWYgKHVubWVyZ2VkX2NvdW50KQoJCSp1bm1lcmdlZF9jb3VudCA9IHMudW5tZXJnZWRfY291bnQ7CglpZiAoYmluYXJ5X2NvdW50KQoJCSpiaW5hcnlfY291bnQgPSBzLmJpbmFyeV9jb3VudDsKCgkvKiBXaGlsZSB0aGUgZGlmZnMgYXJlIG9yZGVyZWQgYWxyZWFkeSwgd2UgcmFuICp0d28qIGRpZmZzLi4uICovCglzdHJpbmdfbGlzdF9zb3J0KCZmaWxlcy0+aXRlbXMpOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCByZW5kZXJfYWRkZGVsKHN0cnVjdCBzdHJidWYgKmJ1ZiwKCQkJCXN0cnVjdCBhZGRkZWwgKmFkLCBjb25zdCBjaGFyICpub19jaGFuZ2VzKQp7CglpZiAoYWQtPmJpbmFyeSkKCQlzdHJidWZfYWRkc3RyKGJ1ZiwgXygiYmluYXJ5IikpOwoJZWxzZSBpZiAoYWQtPnNlZW4pCgkJc3RyYnVmX2FkZGYoYnVmLCAiKyUiUFJJdU1BWCIvLSUiUFJJdU1BWCwKCQkJICAgICh1aW50bWF4X3QpYWQtPmFkZCwgKHVpbnRtYXhfdClhZC0+ZGVsKTsKCWVsc2UKCQlzdHJidWZfYWRkc3RyKGJ1Ziwgbm9fY2hhbmdlcyk7Cn0KCi8qIGZpbHRlcnMgb3V0IHByZWZpeGVzIHdoaWNoIGhhdmUgc3BlY2lhbCBtZWFuaW5nIHRvIGxpc3RfYW5kX2Nob29zZSgpICovCnN0YXRpYyBpbnQgaXNfdmFsaWRfcHJlZml4KGNvbnN0IGNoYXIgKnByZWZpeCwgc2l6ZV90IHByZWZpeF9sZW4pCnsKCXJldHVybiBwcmVmaXhfbGVuICYmIHByZWZpeCAmJgoJCS8qCgkJICogV2UgZXhwZWN0IGBwcmVmaXhgIHRvIGJlIE5VTCB0ZXJtaW5hdGVkLCB0aGVyZWZvcmUgdGhpcwoJCSAqIGBzdHJjc3BuKClgIGNhbGwgaXMgb2theSwgZXZlbiBpZiBpdCBtaWdodCBkbyBtdWNoIG1vcmUKCQkgKiB3b3JrIHRoYW4gc3RyaWN0bHkgbmVjZXNzYXJ5LgoJCSAqLwoJCXN0cmNzcG4ocHJlZml4LCAiIFx0XHJcbiwiKSA+PSBwcmVmaXhfbGVuICYmCS8qIHNlcGFyYXRvcnMgKi8KCQkqcHJlZml4ICE9ICctJyAmJgkJCQkvKiBkZXNlbGVjdGlvbiAqLwoJCSFpc2RpZ2l0KCpwcmVmaXgpICYmCQkJCS8qIHNlbGVjdGlvbiAqLwoJCShwcmVmaXhfbGVuICE9IDEgfHwKCQkgKCpwcmVmaXggIT0gJyonICYmCQkJCS8qICJhbGwiIHdpbGRjYXJkICovCgkJICAqcHJlZml4ICE9ICc/JykpOwkJCQkvKiBwcm9tcHQgaGVscCAqLwp9CgpzdHJ1Y3QgcHJpbnRfZmlsZV9pdGVtX2RhdGEgewoJY29uc3QgY2hhciAqbW9kaWZpZWRfZm10LCAqY29sb3IsICpyZXNldDsKCXN0cnVjdCBzdHJidWYgYnVmLCBuYW1lLCBpbmRleCwgd29ya3RyZWU7Cgl1bnNpZ25lZCBvbmx5X25hbWVzOjE7Cn07CgpzdGF0aWMgdm9pZCBwcmludF9maWxlX2l0ZW0oaW50IGksIGludCBzZWxlY3RlZCwgc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW0sCgkJCSAgICB2b2lkICpwcmludF9maWxlX2l0ZW1fZGF0YSkKewoJc3RydWN0IGZpbGVfaXRlbSAqYyA9IGl0ZW0tPnV0aWw7CglzdHJ1Y3QgcHJpbnRfZmlsZV9pdGVtX2RhdGEgKmQgPSBwcmludF9maWxlX2l0ZW1fZGF0YTsKCWNvbnN0IGNoYXIgKmhpZ2hsaWdodGVkID0gTlVMTDsKCglzdHJidWZfcmVzZXQoJmQtPmluZGV4KTsKCXN0cmJ1Zl9yZXNldCgmZC0+d29ya3RyZWUpOwoJc3RyYnVmX3Jlc2V0KCZkLT5idWYpOwoKCS8qIEZvcm1hdCB0aGUgaXRlbSB3aXRoIHRoZSBwcmVmaXggaGlnaGxpZ2h0ZWQuICovCglpZiAoYy0+cHJlZml4X2xlbmd0aCA+IDAgJiYKCSAgICBpc192YWxpZF9wcmVmaXgoaXRlbS0+c3RyaW5nLCBjLT5wcmVmaXhfbGVuZ3RoKSkgewoJCXN0cmJ1Zl9yZXNldCgmZC0+bmFtZSk7CgkJc3RyYnVmX2FkZGYoJmQtPm5hbWUsICIlcyUuKnMlcyVzIiwgZC0+Y29sb3IsCgkJCSAgICAoaW50KWMtPnByZWZpeF9sZW5ndGgsIGl0ZW0tPnN0cmluZywgZC0+cmVzZXQsCgkJCSAgICBpdGVtLT5zdHJpbmcgKyBjLT5wcmVmaXhfbGVuZ3RoKTsKCQloaWdobGlnaHRlZCA9IGQtPm5hbWUuYnVmOwoJfQoKCWlmIChkLT5vbmx5X25hbWVzKSB7CgkJcHJpbnRmKCIlYyUyZDogJXMiLCBzZWxlY3RlZCA/ICcqJyA6ICcgJywgaSArIDEsCgkJICAgICAgIGhpZ2hsaWdodGVkID8gaGlnaGxpZ2h0ZWQgOiBpdGVtLT5zdHJpbmcpOwoJCXJldHVybjsKCX0KCglyZW5kZXJfYWRkZGVsKCZkLT53b3JrdHJlZSwgJmMtPndvcmt0cmVlLCBfKCJub3RoaW5nIikpOwoJcmVuZGVyX2FkZGRlbCgmZC0+aW5kZXgsICZjLT5pbmRleCwgXygidW5jaGFuZ2VkIikpOwoKCXN0cmJ1Zl9hZGRmKCZkLT5idWYsIGQtPm1vZGlmaWVkX2ZtdCwgZC0+aW5kZXguYnVmLCBkLT53b3JrdHJlZS5idWYsCgkJICAgIGhpZ2hsaWdodGVkID8gaGlnaGxpZ2h0ZWQgOiBpdGVtLT5zdHJpbmcpOwoKCXByaW50ZigiJWMlMmQ6ICVzIiwgc2VsZWN0ZWQgPyAnKicgOiAnICcsIGkgKyAxLCBkLT5idWYuYnVmKTsKfQoKc3RhdGljIGludCBydW5fc3RhdHVzKHN0cnVjdCBhZGRfaV9zdGF0ZSAqcywgY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwcywKCQkgICAgICBzdHJ1Y3QgcHJlZml4X2l0ZW1fbGlzdCAqZmlsZXMsCgkJICAgICAgc3RydWN0IGxpc3RfYW5kX2Nob29zZV9vcHRpb25zICpvcHRzKQp7CglpZiAoZ2V0X21vZGlmaWVkX2ZpbGVzKHMtPnIsIE5PX0ZJTFRFUiwgZmlsZXMsIHBzLCBOVUxMLCBOVUxMKSA8IDApCgkJcmV0dXJuIC0xOwoKCWxpc3QocywgJmZpbGVzLT5pdGVtcywgTlVMTCwgJm9wdHMtPmxpc3Rfb3B0cyk7CglwdXRjaGFyKCdcbicpOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHJ1bl91cGRhdGUoc3RydWN0IGFkZF9pX3N0YXRlICpzLCBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBzLAoJCSAgICAgIHN0cnVjdCBwcmVmaXhfaXRlbV9saXN0ICpmaWxlcywKCQkgICAgICBzdHJ1Y3QgbGlzdF9hbmRfY2hvb3NlX29wdGlvbnMgKm9wdHMpCnsKCWludCByZXMgPSAwLCBmZDsKCXNpemVfdCBjb3VudCwgaTsKCXN0cnVjdCBsb2NrX2ZpbGUgaW5kZXhfbG9jazsKCglpZiAoZ2V0X21vZGlmaWVkX2ZpbGVzKHMtPnIsIFdPUktUUkVFX09OTFksIGZpbGVzLCBwcywgTlVMTCwgTlVMTCkgPCAwKQoJCXJldHVybiAtMTsKCglpZiAoIWZpbGVzLT5pdGVtcy5ucikgewoJCXB1dGNoYXIoJ1xuJyk7CgkJcmV0dXJuIDA7Cgl9CgoJb3B0cy0+cHJvbXB0ID0gTl8oIlVwZGF0ZSIpOwoJY291bnQgPSBsaXN0X2FuZF9jaG9vc2UocywgZmlsZXMsIG9wdHMpOwoJaWYgKGNvdW50IDw9IDApIHsKCQlwdXRjaGFyKCdcbicpOwoJCXJldHVybiAwOwoJfQoKCWZkID0gcmVwb19ob2xkX2xvY2tlZF9pbmRleChzLT5yLCAmaW5kZXhfbG9jaywgTE9DS19SRVBPUlRfT05fRVJST1IpOwoJaWYgKGZkIDwgMCkgewoJCXB1dGNoYXIoJ1xuJyk7CgkJcmV0dXJuIC0xOwoJfQoKCWZvciAoaSA9IDA7IGkgPCBmaWxlcy0+aXRlbXMubnI7IGkrKykgewoJCWNvbnN0IGNoYXIgKm5hbWUgPSBmaWxlcy0+aXRlbXMuaXRlbXNbaV0uc3RyaW5nOwoJCXN0cnVjdCBzdGF0IHN0OwoKCQlpZiAoIWZpbGVzLT5zZWxlY3RlZFtpXSkKCQkJY29udGludWU7CgkJaWYgKGxzdGF0KG5hbWUsICZzdCkgJiYgaXNfbWlzc2luZ19maWxlX2Vycm9yKGVycm5vKSkgewoJCQlpZiAocmVtb3ZlX2ZpbGVfZnJvbV9pbmRleChzLT5yLT5pbmRleCwgbmFtZSkgPCAwKSB7CgkJCQlyZXMgPSBlcnJvcihfKCJjb3VsZCBub3Qgc3RhZ2UgJyVzJyIpLCBuYW1lKTsKCQkJCWJyZWFrOwoJCQl9CgkJfSBlbHNlIGlmIChhZGRfZmlsZV90b19pbmRleChzLT5yLT5pbmRleCwgbmFtZSwgMCkgPCAwKSB7CgkJCXJlcyA9IGVycm9yKF8oImNvdWxkIG5vdCBzdGFnZSAnJXMnIiksIG5hbWUpOwoJCQlicmVhazsKCQl9Cgl9CgoJaWYgKCFyZXMgJiYgd3JpdGVfbG9ja2VkX2luZGV4KHMtPnItPmluZGV4LCAmaW5kZXhfbG9jaywgQ09NTUlUX0xPQ0spIDwgMCkKCQlyZXMgPSBlcnJvcihfKCJjb3VsZCBub3Qgd3JpdGUgaW5kZXgiKSk7CgoJaWYgKCFyZXMpCgkJcHJpbnRmKFFfKCJ1cGRhdGVkICVkIHBhdGhcbiIsCgkJCSAgInVwZGF0ZWQgJWQgcGF0aHNcbiIsIGNvdW50KSwgKGludCljb3VudCk7CgoJcHV0Y2hhcignXG4nKTsKCXJldHVybiByZXM7Cn0KCnN0YXRpYyB2b2lkIHJldmVydF9mcm9tX2RpZmYoc3RydWN0IGRpZmZfcXVldWVfc3RydWN0ICpxLAoJCQkgICAgIHN0cnVjdCBkaWZmX29wdGlvbnMgKm9wdCwgdm9pZCAqZGF0YSBVTlVTRUQpCnsKCWludCBpLCBhZGRfZmxhZ3MgPSBBRERfQ0FDSEVfT0tfVE9fQUREIHwgQUREX0NBQ0hFX09LX1RPX1JFUExBQ0U7CgoJZm9yIChpID0gMDsgaSA8IHEtPm5yOyBpKyspIHsKCQlzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqb25lID0gcS0+cXVldWVbaV0tPm9uZTsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlOwoKCQlpZiAoIShvbmUtPm1vZGUgJiYgIWlzX251bGxfb2lkKCZvbmUtPm9pZCkpKSB7CgkJCXJlbW92ZV9maWxlX2Zyb21faW5kZXgob3B0LT5yZXBvLT5pbmRleCwgb25lLT5wYXRoKTsKCQkJcHJpbnRmKF8oIm5vdGU6ICVzIGlzIHVudHJhY2tlZCBub3cuXG4iKSwgb25lLT5wYXRoKTsKCQl9IGVsc2UgewoJCQljZSA9IG1ha2VfY2FjaGVfZW50cnkob3B0LT5yZXBvLT5pbmRleCwgb25lLT5tb2RlLAoJCQkJCSAgICAgICZvbmUtPm9pZCwgb25lLT5wYXRoLCAwLCAwKTsKCQkJaWYgKCFjZSkKCQkJCWRpZShfKCJtYWtlX2NhY2hlX2VudHJ5IGZhaWxlZCBmb3IgcGF0aCAnJXMnIiksCgkJCQkgICAgb25lLT5wYXRoKTsKCQkJYWRkX2luZGV4X2VudHJ5KG9wdC0+cmVwby0+aW5kZXgsIGNlLCBhZGRfZmxhZ3MpOwoJCX0KCX0KfQoKc3RhdGljIGludCBydW5fcmV2ZXJ0KHN0cnVjdCBhZGRfaV9zdGF0ZSAqcywgY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwcywKCQkgICAgICBzdHJ1Y3QgcHJlZml4X2l0ZW1fbGlzdCAqZmlsZXMsCgkJICAgICAgc3RydWN0IGxpc3RfYW5kX2Nob29zZV9vcHRpb25zICpvcHRzKQp7CglpbnQgcmVzID0gMCwgZmQ7CglzaXplX3QgY291bnQsIGksIGo7CgoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CglpbnQgaXNfaW5pdGlhbCA9ICFyZWZzX3Jlc29sdmVfcmVmX3Vuc2FmZShnZXRfbWFpbl9yZWZfc3RvcmUocy0+ciksCgkJCQkJCSAgIkhFQUQiLCBSRVNPTFZFX1JFRl9SRUFESU5HLAoJCQkJCQkgICZvaWQsCgkJCQkJCSAgTlVMTCk7CglzdHJ1Y3QgbG9ja19maWxlIGluZGV4X2xvY2s7Cgljb25zdCBjaGFyICoqcGF0aHM7CglzdHJ1Y3QgdHJlZSAqdHJlZTsKCXN0cnVjdCBkaWZmX29wdGlvbnMgZGlmZm9wdCA9IHsgTlVMTCB9OwoKCWlmIChnZXRfbW9kaWZpZWRfZmlsZXMocy0+ciwgSU5ERVhfT05MWSwgZmlsZXMsIHBzLCBOVUxMLCBOVUxMKSA8IDApCgkJcmV0dXJuIC0xOwoKCWlmICghZmlsZXMtPml0ZW1zLm5yKSB7CgkJcHV0Y2hhcignXG4nKTsKCQlyZXR1cm4gMDsKCX0KCglvcHRzLT5wcm9tcHQgPSBOXygiUmV2ZXJ0Iik7Cgljb3VudCA9IGxpc3RfYW5kX2Nob29zZShzLCBmaWxlcywgb3B0cyk7CglpZiAoY291bnQgPD0gMCkKCQlnb3RvIGZpbmlzaF9yZXZlcnQ7CgoJZmQgPSByZXBvX2hvbGRfbG9ja2VkX2luZGV4KHMtPnIsICZpbmRleF9sb2NrLCBMT0NLX1JFUE9SVF9PTl9FUlJPUik7CglpZiAoZmQgPCAwKSB7CgkJcmVzID0gLTE7CgkJZ290byBmaW5pc2hfcmV2ZXJ0OwoJfQoKCWlmIChpc19pbml0aWFsKQoJCW9pZGNweSgmb2lkLCBzLT5yLT5oYXNoX2FsZ28tPmVtcHR5X3RyZWUpOwoJZWxzZSB7CgkJdHJlZSA9IHBhcnNlX3RyZWVfaW5kaXJlY3QoJm9pZCk7CgkJaWYgKCF0cmVlKSB7CgkJCXJlcyA9IGVycm9yKF8oIkNvdWxkIG5vdCBwYXJzZSBIRUFEXnt0cmVlfSIpKTsKCQkJZ290byBmaW5pc2hfcmV2ZXJ0OwoJCX0KCQlvaWRjcHkoJm9pZCwgJnRyZWUtPm9iamVjdC5vaWQpOwoJfQoKCUFMTE9DX0FSUkFZKHBhdGhzLCBjb3VudCArIDEpOwoJZm9yIChpID0gaiA9IDA7IGkgPCBmaWxlcy0+aXRlbXMubnI7IGkrKykKCQlpZiAoZmlsZXMtPnNlbGVjdGVkW2ldKQoJCQlwYXRoc1tqKytdID0gZmlsZXMtPml0ZW1zLml0ZW1zW2ldLnN0cmluZzsKCXBhdGhzW2pdID0gTlVMTDsKCglwYXJzZV9wYXRoc3BlYygmZGlmZm9wdC5wYXRoc3BlYywgMCwKCQkgICAgICAgUEFUSFNQRUNfUFJFRkVSX0ZVTEwgfCBQQVRIU1BFQ19MSVRFUkFMX1BBVEgsCgkJICAgICAgIE5VTEwsIHBhdGhzKTsKCglkaWZmb3B0Lm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9DQUxMQkFDSzsKCWRpZmZvcHQuZm9ybWF0X2NhbGxiYWNrID0gcmV2ZXJ0X2Zyb21fZGlmZjsKCWRpZmZvcHQuZmxhZ3Mub3ZlcnJpZGVfc3VibW9kdWxlX2NvbmZpZyA9IDE7CglkaWZmb3B0LnJlcG8gPSBzLT5yOwoKCWlmIChkb19kaWZmX2NhY2hlKCZvaWQsICZkaWZmb3B0KSkgewoJCWRpZmZfZnJlZSgmZGlmZm9wdCk7CgkJcmVzID0gLTE7Cgl9IGVsc2UgewoJCWRpZmZjb3JlX3N0ZCgmZGlmZm9wdCk7CgkJZGlmZl9mbHVzaCgmZGlmZm9wdCk7Cgl9CglmcmVlKHBhdGhzKTsKCglpZiAoIXJlcyAmJiB3cml0ZV9sb2NrZWRfaW5kZXgocy0+ci0+aW5kZXgsICZpbmRleF9sb2NrLAoJCQkJICAgICAgIENPTU1JVF9MT0NLKSA8IDApCgkJcmVzID0gLTE7CgllbHNlCgkJcmVzID0gcmVwb19yZWZyZXNoX2FuZF93cml0ZV9pbmRleChzLT5yLCBSRUZSRVNIX1FVSUVULCAwLCAxLAoJCQkJCQkgICBOVUxMLCBOVUxMLCBOVUxMKTsKCglpZiAoIXJlcykKCQlwcmludGYoUV8oInJldmVydGVkICVkIHBhdGhcbiIsCgkJCSAgInJldmVydGVkICVkIHBhdGhzXG4iLCBjb3VudCksIChpbnQpY291bnQpOwoKZmluaXNoX3JldmVydDoKCXB1dGNoYXIoJ1xuJyk7CglyZXR1cm4gcmVzOwp9CgpzdGF0aWMgaW50IGdldF91bnRyYWNrZWRfZmlsZXMoc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCSAgICAgICBzdHJ1Y3QgcHJlZml4X2l0ZW1fbGlzdCAqZmlsZXMsCgkJCSAgICAgICBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBzKQp7CglzdHJ1Y3QgZGlyX3N0cnVjdCBkaXIgPSB7IDAgfTsKCXNpemVfdCBpOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCglpZiAocmVwb19yZWFkX2luZGV4KHIpIDwgMCkKCQlyZXR1cm4gZXJyb3IoXygiY291bGQgbm90IHJlYWQgaW5kZXgiKSk7CgoJcHJlZml4X2l0ZW1fbGlzdF9jbGVhcihmaWxlcyk7CglzZXR1cF9zdGFuZGFyZF9leGNsdWRlcygmZGlyKTsKCWFkZF9wYXR0ZXJuX2xpc3QoJmRpciwgRVhDX0NNREwsICItLWV4Y2x1ZGUgb3B0aW9uIik7CglmaWxsX2RpcmVjdG9yeSgmZGlyLCByLT5pbmRleCwgcHMpOwoKCWZvciAoaSA9IDA7IGkgPCBkaXIubnI7IGkrKykgewoJCXN0cnVjdCBkaXJfZW50cnkgKmVudCA9IGRpci5lbnRyaWVzW2ldOwoKCQlpZiAoaW5kZXhfbmFtZV9pc19vdGhlcihyLT5pbmRleCwgZW50LT5uYW1lLCBlbnQtPmxlbikpIHsKCQkJc3RyYnVmX3Jlc2V0KCZidWYpOwoJCQlzdHJidWZfYWRkKCZidWYsIGVudC0+bmFtZSwgZW50LT5sZW4pOwoJCQlhZGRfZmlsZV9pdGVtKCZmaWxlcy0+aXRlbXMsIGJ1Zi5idWYpOwoJCX0KCX0KCglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCWRpcl9jbGVhcigmZGlyKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHJ1bl9hZGRfdW50cmFja2VkKHN0cnVjdCBhZGRfaV9zdGF0ZSAqcywgY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwcywKCQkgICAgICBzdHJ1Y3QgcHJlZml4X2l0ZW1fbGlzdCAqZmlsZXMsCgkJICAgICAgc3RydWN0IGxpc3RfYW5kX2Nob29zZV9vcHRpb25zICpvcHRzKQp7CglzdHJ1Y3QgcHJpbnRfZmlsZV9pdGVtX2RhdGEgKmQgPSBvcHRzLT5saXN0X29wdHMucHJpbnRfaXRlbV9kYXRhOwoJaW50IHJlcyA9IDAsIGZkOwoJc2l6ZV90IGNvdW50LCBpOwoJc3RydWN0IGxvY2tfZmlsZSBpbmRleF9sb2NrOwoKCWlmIChnZXRfdW50cmFja2VkX2ZpbGVzKHMtPnIsIGZpbGVzLCBwcykgPCAwKQoJCXJldHVybiAtMTsKCglpZiAoIWZpbGVzLT5pdGVtcy5ucikgewoJCXByaW50ZihfKCJObyB1bnRyYWNrZWQgZmlsZXMuXG4iKSk7CgkJZ290byBmaW5pc2hfYWRkX3VudHJhY2tlZDsKCX0KCglvcHRzLT5wcm9tcHQgPSBOXygiQWRkIHVudHJhY2tlZCIpOwoJZC0+b25seV9uYW1lcyA9IDE7Cgljb3VudCA9IGxpc3RfYW5kX2Nob29zZShzLCBmaWxlcywgb3B0cyk7CglkLT5vbmx5X25hbWVzID0gMDsKCWlmIChjb3VudCA8PSAwKQoJCWdvdG8gZmluaXNoX2FkZF91bnRyYWNrZWQ7CgoJZmQgPSByZXBvX2hvbGRfbG9ja2VkX2luZGV4KHMtPnIsICZpbmRleF9sb2NrLCBMT0NLX1JFUE9SVF9PTl9FUlJPUik7CglpZiAoZmQgPCAwKSB7CgkJcmVzID0gLTE7CgkJZ290byBmaW5pc2hfYWRkX3VudHJhY2tlZDsKCX0KCglmb3IgKGkgPSAwOyBpIDwgZmlsZXMtPml0ZW1zLm5yOyBpKyspIHsKCQljb25zdCBjaGFyICpuYW1lID0gZmlsZXMtPml0ZW1zLml0ZW1zW2ldLnN0cmluZzsKCQlpZiAoZmlsZXMtPnNlbGVjdGVkW2ldICYmCgkJICAgIGFkZF9maWxlX3RvX2luZGV4KHMtPnItPmluZGV4LCBuYW1lLCAwKSA8IDApIHsKCQkJcmVzID0gZXJyb3IoXygiY291bGQgbm90IHN0YWdlICclcyciKSwgbmFtZSk7CgkJCWJyZWFrOwoJCX0KCX0KCglpZiAoIXJlcyAmJgoJICAgIHdyaXRlX2xvY2tlZF9pbmRleChzLT5yLT5pbmRleCwgJmluZGV4X2xvY2ssIENPTU1JVF9MT0NLKSA8IDApCgkJcmVzID0gZXJyb3IoXygiY291bGQgbm90IHdyaXRlIGluZGV4IikpOwoKCWlmICghcmVzKQoJCXByaW50ZihRXygiYWRkZWQgJWQgcGF0aFxuIiwKCQkJICAiYWRkZWQgJWQgcGF0aHNcbiIsIGNvdW50KSwgKGludCljb3VudCk7CgpmaW5pc2hfYWRkX3VudHJhY2tlZDoKCXB1dGNoYXIoJ1xuJyk7CglyZXR1cm4gcmVzOwp9CgpzdGF0aWMgaW50IHJ1bl9wYXRjaChzdHJ1Y3QgYWRkX2lfc3RhdGUgKnMsIGNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcHMsCgkJICAgICBzdHJ1Y3QgcHJlZml4X2l0ZW1fbGlzdCAqZmlsZXMsCgkJICAgICBzdHJ1Y3QgbGlzdF9hbmRfY2hvb3NlX29wdGlvbnMgKm9wdHMpCnsKCWludCByZXMgPSAwOwoJc3NpemVfdCBjb3VudCwgaSwgajsKCXNpemVfdCB1bm1lcmdlZF9jb3VudCA9IDAsIGJpbmFyeV9jb3VudCA9IDA7CgoJaWYgKGdldF9tb2RpZmllZF9maWxlcyhzLT5yLCBXT1JLVFJFRV9PTkxZLCBmaWxlcywgcHMsCgkJCSAgICAgICAmdW5tZXJnZWRfY291bnQsICZiaW5hcnlfY291bnQpIDwgMCkKCQlyZXR1cm4gLTE7CgoJaWYgKHVubWVyZ2VkX2NvdW50IHx8IGJpbmFyeV9jb3VudCkgewoJCWZvciAoaSA9IGogPSAwOyBpIDwgZmlsZXMtPml0ZW1zLm5yOyBpKyspIHsKCQkJc3RydWN0IGZpbGVfaXRlbSAqaXRlbSA9IGZpbGVzLT5pdGVtcy5pdGVtc1tpXS51dGlsOwoKCQkJaWYgKGl0ZW0tPmluZGV4LmJpbmFyeSB8fCBpdGVtLT53b3JrdHJlZS5iaW5hcnkpIHsKCQkJCWZyZWUoaXRlbSk7CgkJCQlmcmVlKGZpbGVzLT5pdGVtcy5pdGVtc1tpXS5zdHJpbmcpOwoJCQl9IGVsc2UgaWYgKGl0ZW0tPmluZGV4LnVubWVyZ2VkIHx8CgkJCQkgaXRlbS0+d29ya3RyZWUudW5tZXJnZWQpIHsKCQkJCWNvbG9yX2ZwcmludGZfbG4oc3RkZXJyLCBzLT5lcnJvcl9jb2xvciwKCQkJCQkJIF8oImlnbm9yaW5nIHVubWVyZ2VkOiAlcyIpLAoJCQkJCQkgZmlsZXMtPml0ZW1zLml0ZW1zW2ldLnN0cmluZyk7CgkJCQlmcmVlKGl0ZW0pOwoJCQkJZnJlZShmaWxlcy0+aXRlbXMuaXRlbXNbaV0uc3RyaW5nKTsKCQkJfSBlbHNlCgkJCQlmaWxlcy0+aXRlbXMuaXRlbXNbaisrXSA9IGZpbGVzLT5pdGVtcy5pdGVtc1tpXTsKCQl9CgkJZmlsZXMtPml0ZW1zLm5yID0gajsKCX0KCglpZiAoIWZpbGVzLT5pdGVtcy5ucikgewoJCWlmIChiaW5hcnlfY291bnQpCgkJCWZwcmludGYoc3RkZXJyLCBfKCJPbmx5IGJpbmFyeSBmaWxlcyBjaGFuZ2VkLlxuIikpOwoJCWVsc2UKCQkJZnByaW50ZihzdGRlcnIsIF8oIk5vIGNoYW5nZXMuXG4iKSk7CgkJcmV0dXJuIDA7Cgl9CgoJb3B0cy0+cHJvbXB0ID0gTl8oIlBhdGNoIHVwZGF0ZSIpOwoJY291bnQgPSBsaXN0X2FuZF9jaG9vc2UocywgZmlsZXMsIG9wdHMpOwoJaWYgKGNvdW50ID4gMCkgewoJCXN0cnVjdCBhZGRfcF9vcHQgYWRkX3Bfb3B0ID0gewoJCQkuY29udGV4dCA9IHMtPmNvbnRleHQsCgkJCS5pbnRlcmh1bmtjb250ZXh0ID0gcy0+aW50ZXJodW5rY29udGV4dCwKCQl9OwoJCXN0cnVjdCBzdHJ2ZWMgYXJncyA9IFNUUlZFQ19JTklUOwoJCXN0cnVjdCBwYXRoc3BlYyBwc19zZWxlY3RlZCA9IHsgMCB9OwoKCQlmb3IgKGkgPSAwOyBpIDwgZmlsZXMtPml0ZW1zLm5yOyBpKyspCgkJCWlmIChmaWxlcy0+c2VsZWN0ZWRbaV0pCgkJCQlzdHJ2ZWNfcHVzaCgmYXJncywKCQkJCQkgICAgZmlsZXMtPml0ZW1zLml0ZW1zW2ldLnN0cmluZyk7CgkJcGFyc2VfcGF0aHNwZWMoJnBzX3NlbGVjdGVkLAoJCQkgICAgICAgUEFUSFNQRUNfQUxMX01BR0lDICYgflBBVEhTUEVDX0xJVEVSQUwsCgkJCSAgICAgICBQQVRIU1BFQ19MSVRFUkFMX1BBVEgsICIiLCBhcmdzLnYpOwoJCXJlcyA9IHJ1bl9hZGRfcChzLT5yLCBBRERfUF9BREQsICZhZGRfcF9vcHQsIE5VTEwsICZwc19zZWxlY3RlZCk7CgkJc3RydmVjX2NsZWFyKCZhcmdzKTsKCQljbGVhcl9wYXRoc3BlYygmcHNfc2VsZWN0ZWQpOwoJfQoKCXJldHVybiByZXM7Cn0KCnN0YXRpYyBpbnQgcnVuX2RpZmYoc3RydWN0IGFkZF9pX3N0YXRlICpzLCBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBzLAoJCSAgICBzdHJ1Y3QgcHJlZml4X2l0ZW1fbGlzdCAqZmlsZXMsCgkJICAgIHN0cnVjdCBsaXN0X2FuZF9jaG9vc2Vfb3B0aW9ucyAqb3B0cykKewoJaW50IHJlcyA9IDA7Cglzc2l6ZV90IGNvdW50LCBpOwoKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJaW50IGlzX2luaXRpYWwgPSAhcmVmc19yZXNvbHZlX3JlZl91bnNhZmUoZ2V0X21haW5fcmVmX3N0b3JlKHMtPnIpLAoJCQkJCQkgICJIRUFEIiwgUkVTT0xWRV9SRUZfUkVBRElORywKCQkJCQkJICAmb2lkLAoJCQkJCQkgIE5VTEwpOwoJaWYgKGdldF9tb2RpZmllZF9maWxlcyhzLT5yLCBJTkRFWF9PTkxZLCBmaWxlcywgcHMsIE5VTEwsIE5VTEwpIDwgMCkKCQlyZXR1cm4gLTE7CgoJaWYgKCFmaWxlcy0+aXRlbXMubnIpIHsKCQlwdXRjaGFyKCdcbicpOwoJCXJldHVybiAwOwoJfQoKCW9wdHMtPnByb21wdCA9IE5fKCJSZXZpZXcgZGlmZiIpOwoJb3B0cy0+ZmxhZ3MgPSBJTU1FRElBVEU7Cgljb3VudCA9IGxpc3RfYW5kX2Nob29zZShzLCBmaWxlcywgb3B0cyk7CglvcHRzLT5mbGFncyA9IDA7CglpZiAoY291bnQgPiAwKSB7CgkJc3RydWN0IGNoaWxkX3Byb2Nlc3MgY21kID0gQ0hJTERfUFJPQ0VTU19JTklUOwoKCQlzdHJ2ZWNfcHVzaGwoJmNtZC5hcmdzLCAiZ2l0IiwgImRpZmYiLCAiLXAiLCAiLS1jYWNoZWQiLCBOVUxMKTsKCQlpZiAocy0+Y29udGV4dCAhPSAtMSkKCQkJc3RydmVjX3B1c2hmKCZjbWQuYXJncywgIi0tdW5pZmllZD0laSIsIHMtPmNvbnRleHQpOwoJCWlmIChzLT5pbnRlcmh1bmtjb250ZXh0ICE9IC0xKQoJCQlzdHJ2ZWNfcHVzaGYoJmNtZC5hcmdzLCAiLS1pbnRlci1odW5rLWNvbnRleHQ9JWkiLCBzLT5pbnRlcmh1bmtjb250ZXh0KTsKCQlzdHJ2ZWNfcHVzaGwoJmNtZC5hcmdzLCBvaWRfdG9faGV4KCFpc19pbml0aWFsID8gJm9pZCA6CgkJCSAgICAgcy0+ci0+aGFzaF9hbGdvLT5lbXB0eV90cmVlKSwgIi0tIiwgTlVMTCk7CgkJZm9yIChpID0gMDsgaSA8IGZpbGVzLT5pdGVtcy5ucjsgaSsrKQoJCQlpZiAoZmlsZXMtPnNlbGVjdGVkW2ldKQoJCQkJc3RydmVjX3B1c2goJmNtZC5hcmdzLAoJCQkJCSAgICBmaWxlcy0+aXRlbXMuaXRlbXNbaV0uc3RyaW5nKTsKCQlyZXMgPSBydW5fY29tbWFuZCgmY21kKTsKCX0KCglwdXRjaGFyKCdcbicpOwoJcmV0dXJuIHJlczsKfQoKc3RhdGljIGludCBydW5faGVscChzdHJ1Y3QgYWRkX2lfc3RhdGUgKnMsIGNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcHMgVU5VU0VELAoJCSAgICBzdHJ1Y3QgcHJlZml4X2l0ZW1fbGlzdCAqZmlsZXMgVU5VU0VELAoJCSAgICBzdHJ1Y3QgbGlzdF9hbmRfY2hvb3NlX29wdGlvbnMgKm9wdHMgVU5VU0VEKQp7Cgljb2xvcl9mcHJpbnRmX2xuKHN0ZG91dCwgcy0+aGVscF9jb2xvciwgInN0YXR1cyAgICAgICAgLSAlcyIsCgkJCSBfKCJzaG93IHBhdGhzIHdpdGggY2hhbmdlcyIpKTsKCWNvbG9yX2ZwcmludGZfbG4oc3Rkb3V0LCBzLT5oZWxwX2NvbG9yLCAidXBkYXRlICAgICAgICAtICVzIiwKCQkJIF8oImFkZCB3b3JraW5nIHRyZWUgc3RhdGUgdG8gdGhlIHN0YWdlZCBzZXQgb2YgY2hhbmdlcyIpKTsKCWNvbG9yX2ZwcmludGZfbG4oc3Rkb3V0LCBzLT5oZWxwX2NvbG9yLCAicmV2ZXJ0ICAgICAgICAtICVzIiwKCQkJIF8oInJldmVydCBzdGFnZWQgc2V0IG9mIGNoYW5nZXMgYmFjayB0byB0aGUgSEVBRCB2ZXJzaW9uIikpOwoJY29sb3JfZnByaW50Zl9sbihzdGRvdXQsIHMtPmhlbHBfY29sb3IsICJwYXRjaCAgICAgICAgIC0gJXMiLAoJCQkgXygicGljayBodW5rcyBhbmQgdXBkYXRlIHNlbGVjdGl2ZWx5IikpOwoJY29sb3JfZnByaW50Zl9sbihzdGRvdXQsIHMtPmhlbHBfY29sb3IsICJkaWZmICAgICAgICAgIC0gJXMiLAoJCQkgXygidmlldyBkaWZmIGJldHdlZW4gSEVBRCBhbmQgaW5kZXgiKSk7Cgljb2xvcl9mcHJpbnRmX2xuKHN0ZG91dCwgcy0+aGVscF9jb2xvciwgImFkZCB1bnRyYWNrZWQgLSAlcyIsCgkJCSBfKCJhZGQgY29udGVudHMgb2YgdW50cmFja2VkIGZpbGVzIHRvIHRoZSBzdGFnZWQgc2V0IG9mIGNoYW5nZXMiKSk7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGNob29zZV9wcm9tcHRfaGVscChzdHJ1Y3QgYWRkX2lfc3RhdGUgKnMpCnsKCWNvbG9yX2ZwcmludGZfbG4oc3Rkb3V0LCBzLT5oZWxwX2NvbG9yLCAiJXMiLAoJCQkgXygiUHJvbXB0IGhlbHA6IikpOwoJY29sb3JfZnByaW50Zl9sbihzdGRvdXQsIHMtPmhlbHBfY29sb3IsICIxICAgICAgICAgIC0gJXMiLAoJCQkgXygic2VsZWN0IGEgc2luZ2xlIGl0ZW0iKSk7Cgljb2xvcl9mcHJpbnRmX2xuKHN0ZG91dCwgcy0+aGVscF9jb2xvciwgIjMtNSAgICAgICAgLSAlcyIsCgkJCSBfKCJzZWxlY3QgYSByYW5nZSBvZiBpdGVtcyIpKTsKCWNvbG9yX2ZwcmludGZfbG4oc3Rkb3V0LCBzLT5oZWxwX2NvbG9yLCAiMi0zLDYtOSAgICAtICVzIiwKCQkJIF8oInNlbGVjdCBtdWx0aXBsZSByYW5nZXMiKSk7Cgljb2xvcl9mcHJpbnRmX2xuKHN0ZG91dCwgcy0+aGVscF9jb2xvciwgImZvbyAgICAgICAgLSAlcyIsCgkJCSBfKCJzZWxlY3QgaXRlbSBiYXNlZCBvbiB1bmlxdWUgcHJlZml4IikpOwoJY29sb3JfZnByaW50Zl9sbihzdGRvdXQsIHMtPmhlbHBfY29sb3IsICItLi4uICAgICAgIC0gJXMiLAoJCQkgXygidW5zZWxlY3Qgc3BlY2lmaWVkIGl0ZW1zIikpOwoJY29sb3JfZnByaW50Zl9sbihzdGRvdXQsIHMtPmhlbHBfY29sb3IsICIqICAgICAgICAgIC0gJXMiLAoJCQkgXygiY2hvb3NlIGFsbCBpdGVtcyIpKTsKCWNvbG9yX2ZwcmludGZfbG4oc3Rkb3V0LCBzLT5oZWxwX2NvbG9yLCAiICAgICAgICAgICAtICVzIiwKCQkJIF8oIihlbXB0eSkgZmluaXNoIHNlbGVjdGluZyIpKTsKfQoKdHlwZWRlZiBpbnQgKCpjb21tYW5kX3QpKHN0cnVjdCBhZGRfaV9zdGF0ZSAqcywgY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwcywKCQkJIHN0cnVjdCBwcmVmaXhfaXRlbV9saXN0ICpmaWxlcywKCQkJIHN0cnVjdCBsaXN0X2FuZF9jaG9vc2Vfb3B0aW9ucyAqb3B0cyk7CgpzdHJ1Y3QgY29tbWFuZF9pdGVtIHsKCXNpemVfdCBwcmVmaXhfbGVuZ3RoOwoJY29tbWFuZF90IGNvbW1hbmQ7Cn07CgpzdHJ1Y3QgcHJpbnRfY29tbWFuZF9pdGVtX2RhdGEgewoJY29uc3QgY2hhciAqY29sb3IsICpyZXNldDsKfTsKCnN0YXRpYyB2b2lkIHByaW50X2NvbW1hbmRfaXRlbShpbnQgaSwgaW50IHNlbGVjdGVkIFVOVVNFRCwKCQkJICAgICAgIHN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtLAoJCQkgICAgICAgdm9pZCAqcHJpbnRfY29tbWFuZF9pdGVtX2RhdGEpCnsKCXN0cnVjdCBwcmludF9jb21tYW5kX2l0ZW1fZGF0YSAqZCA9IHByaW50X2NvbW1hbmRfaXRlbV9kYXRhOwoJc3RydWN0IGNvbW1hbmRfaXRlbSAqdXRpbCA9IGl0ZW0tPnV0aWw7CgoJaWYgKCF1dGlsLT5wcmVmaXhfbGVuZ3RoIHx8CgkgICAgIWlzX3ZhbGlkX3ByZWZpeChpdGVtLT5zdHJpbmcsIHV0aWwtPnByZWZpeF9sZW5ndGgpKQoJCXByaW50ZigiICUyZDogJXMiLCBpICsgMSwgaXRlbS0+c3RyaW5nKTsKCWVsc2UKCQlwcmludGYoIiAlMmQ6ICVzJS4qcyVzJXMiLCBpICsgMSwKCQkgICAgICAgZC0+Y29sb3IsIChpbnQpdXRpbC0+cHJlZml4X2xlbmd0aCwgaXRlbS0+c3RyaW5nLAoJCSAgICAgICBkLT5yZXNldCwgaXRlbS0+c3RyaW5nICsgdXRpbC0+cHJlZml4X2xlbmd0aCk7Cn0KCnN0YXRpYyB2b2lkIGNvbW1hbmRfcHJvbXB0X2hlbHAoc3RydWN0IGFkZF9pX3N0YXRlICpzKQp7Cgljb25zdCBjaGFyICpoZWxwX2NvbG9yID0gcy0+aGVscF9jb2xvcjsKCWNvbG9yX2ZwcmludGZfbG4oc3Rkb3V0LCBoZWxwX2NvbG9yLCAiJXMiLCBfKCJQcm9tcHQgaGVscDoiKSk7Cgljb2xvcl9mcHJpbnRmX2xuKHN0ZG91dCwgaGVscF9jb2xvciwgIjEgICAgICAgICAgLSAlcyIsCgkJCSBfKCJzZWxlY3QgYSBudW1iZXJlZCBpdGVtIikpOwoJY29sb3JfZnByaW50Zl9sbihzdGRvdXQsIGhlbHBfY29sb3IsICJmb28gICAgICAgIC0gJXMiLAoJCQkgXygic2VsZWN0IGl0ZW0gYmFzZWQgb24gdW5pcXVlIHByZWZpeCIpKTsKCWNvbG9yX2ZwcmludGZfbG4oc3Rkb3V0LCBoZWxwX2NvbG9yLCAiICAgICAgICAgICAtICVzIiwKCQkJIF8oIihlbXB0eSkgc2VsZWN0IG5vdGhpbmciKSk7Cn0KCmludCBydW5fYWRkX2koc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcHMsCgkgICAgICBzdHJ1Y3QgYWRkX3Bfb3B0ICphZGRfcF9vcHQpCnsKCXN0cnVjdCBhZGRfaV9zdGF0ZSBzID0geyBOVUxMIH07CglzdHJ1Y3QgcHJpbnRfY29tbWFuZF9pdGVtX2RhdGEgZGF0YSA9IHsgIlsiLCAiXSIgfTsKCXN0cnVjdCBsaXN0X2FuZF9jaG9vc2Vfb3B0aW9ucyBtYWluX2xvb3Bfb3B0cyA9IHsKCQl7IDQsIE5fKCIqKiogQ29tbWFuZHMgKioqIiksIHByaW50X2NvbW1hbmRfaXRlbSwgJmRhdGEgfSwKCQlOXygiV2hhdCBub3ciKSwgU0lOR0xFVE9OIHwgSU1NRURJQVRFLCBjb21tYW5kX3Byb21wdF9oZWxwCgl9OwoJc3RydWN0IHsKCQljb25zdCBjaGFyICpzdHJpbmc7CgkJY29tbWFuZF90IGNvbW1hbmQ7Cgl9IGNvbW1hbmRfbGlzdFtdID0gewoJCXsgInN0YXR1cyIsIHJ1bl9zdGF0dXMgfSwKCQl7ICJ1cGRhdGUiLCBydW5fdXBkYXRlIH0sCgkJeyAicmV2ZXJ0IiwgcnVuX3JldmVydCB9LAoJCXsgImFkZCB1bnRyYWNrZWQiLCBydW5fYWRkX3VudHJhY2tlZCB9LAoJCXsgInBhdGNoIiwgcnVuX3BhdGNoIH0sCgkJeyAiZGlmZiIsIHJ1bl9kaWZmIH0sCgkJeyAicXVpdCIsIE5VTEwgfSwKCQl7ICJoZWxwIiwgcnVuX2hlbHAgfSwKCX07CglzdHJ1Y3QgcHJlZml4X2l0ZW1fbGlzdCBjb21tYW5kcyA9IFBSRUZJWF9JVEVNX0xJU1RfSU5JVDsKCglzdHJ1Y3QgcHJpbnRfZmlsZV9pdGVtX2RhdGEgcHJpbnRfZmlsZV9pdGVtX2RhdGEgPSB7CgkJIiUxMnMgJTEycyAlcyIsIE5VTEwsIE5VTEwsCgkJU1RSQlVGX0lOSVQsIFNUUkJVRl9JTklULCBTVFJCVUZfSU5JVCwgU1RSQlVGX0lOSVQKCX07CglzdHJ1Y3QgbGlzdF9hbmRfY2hvb3NlX29wdGlvbnMgb3B0cyA9IHsKCQl7IDAsIE5VTEwsIHByaW50X2ZpbGVfaXRlbSwgJnByaW50X2ZpbGVfaXRlbV9kYXRhIH0sCgkJTlVMTCwgMCwgY2hvb3NlX3Byb21wdF9oZWxwCgl9OwoJc3RydWN0IHN0cmJ1ZiBoZWFkZXIgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBwcmVmaXhfaXRlbV9saXN0IGZpbGVzID0gUFJFRklYX0lURU1fTElTVF9JTklUOwoJc3NpemVfdCBpOwoJaW50IHJlcyA9IDA7CgoJZm9yIChpID0gMDsgaSA8IEFSUkFZX1NJWkUoY29tbWFuZF9saXN0KTsgaSsrKSB7CgkJc3RydWN0IGNvbW1hbmRfaXRlbSAqdXRpbCA9IHhjYWxsb2MoMSwgc2l6ZW9mKCp1dGlsKSk7CgkJdXRpbC0+Y29tbWFuZCA9IGNvbW1hbmRfbGlzdFtpXS5jb21tYW5kOwoJCXN0cmluZ19saXN0X2FwcGVuZCgmY29tbWFuZHMuaXRlbXMsIGNvbW1hbmRfbGlzdFtpXS5zdHJpbmcpCgkJCS0+dXRpbCA9IHV0aWw7Cgl9CgoJaW5pdF9hZGRfaV9zdGF0ZSgmcywgciwgYWRkX3Bfb3B0KTsKCgkvKgoJICogV2hlbiBjb2xvciB3YXMgYXNrZWQgZm9yLCB1c2UgdGhlIHByb21wdCBjb2xvciBmb3IKCSAqIGhpZ2hsaWdodGluZywgb3RoZXJ3aXNlIHVzZSBzcXVhcmUgYnJhY2tldHMuCgkgKi8KCWlmIChzLnVzZV9jb2xvcl9pbnRlcmFjdGl2ZSkgewoJCWRhdGEuY29sb3IgPSBzLnByb21wdF9jb2xvcjsKCQlkYXRhLnJlc2V0ID0gcy5yZXNldF9jb2xvcl9pbnRlcmFjdGl2ZTsKCX0KCXByaW50X2ZpbGVfaXRlbV9kYXRhLmNvbG9yID0gZGF0YS5jb2xvcjsKCXByaW50X2ZpbGVfaXRlbV9kYXRhLnJlc2V0ID0gZGF0YS5yZXNldDsKCglzdHJidWZfYWRkc3RyKCZoZWFkZXIsICIgICAgICIpOwoJc3RyYnVmX2FkZGYoJmhlYWRlciwgcHJpbnRfZmlsZV9pdGVtX2RhdGEubW9kaWZpZWRfZm10LAoJCSAgICBfKCJzdGFnZWQiKSwgXygidW5zdGFnZWQiKSwgXygicGF0aCIpKTsKCW9wdHMubGlzdF9vcHRzLmhlYWRlciA9IGhlYWRlci5idWY7CgoJZGlzY2FyZF9pbmRleChyLT5pbmRleCk7CglpZiAocmVwb19yZWFkX2luZGV4KHIpIDwgMCB8fAoJICAgIHJlcG9fcmVmcmVzaF9hbmRfd3JpdGVfaW5kZXgociwgUkVGUkVTSF9RVUlFVCwgMCwgMSwKCQkJCQkgTlVMTCwgTlVMTCwgTlVMTCkgPCAwKQoJCXdhcm5pbmcoXygiY291bGQgbm90IHJlZnJlc2ggaW5kZXgiKSk7CgoJcmVzID0gcnVuX3N0YXR1cygmcywgcHMsICZmaWxlcywgJm9wdHMpOwoKCWZvciAoOzspIHsKCQlzdHJ1Y3QgY29tbWFuZF9pdGVtICp1dGlsOwoKCQlpID0gbGlzdF9hbmRfY2hvb3NlKCZzLCAmY29tbWFuZHMsICZtYWluX2xvb3Bfb3B0cyk7CgkJaWYgKGkgPCAwIHx8IGkgPj0gY29tbWFuZHMuaXRlbXMubnIpCgkJCXV0aWwgPSBOVUxMOwoJCWVsc2UKCQkJdXRpbCA9IGNvbW1hbmRzLml0ZW1zLml0ZW1zW2ldLnV0aWw7CgoJCWlmIChpID09IExJU1RfQU5EX0NIT09TRV9RVUlUIHx8ICh1dGlsICYmICF1dGlsLT5jb21tYW5kKSkgewoJCQlwcmludGYoXygiQnllLlxuIikpOwoJCQlyZXMgPSAwOwoJCQlicmVhazsKCQl9CgoJCWlmICh1dGlsKQoJCQlyZXMgPSB1dGlsLT5jb21tYW5kKCZzLCBwcywgJmZpbGVzLCAmb3B0cyk7Cgl9CgoJcHJlZml4X2l0ZW1fbGlzdF9jbGVhcigmZmlsZXMpOwoJc3RyYnVmX3JlbGVhc2UoJnByaW50X2ZpbGVfaXRlbV9kYXRhLmJ1Zik7CglzdHJidWZfcmVsZWFzZSgmcHJpbnRfZmlsZV9pdGVtX2RhdGEubmFtZSk7CglzdHJidWZfcmVsZWFzZSgmcHJpbnRfZmlsZV9pdGVtX2RhdGEuaW5kZXgpOwoJc3RyYnVmX3JlbGVhc2UoJnByaW50X2ZpbGVfaXRlbV9kYXRhLndvcmt0cmVlKTsKCXN0cmJ1Zl9yZWxlYXNlKCZoZWFkZXIpOwoJcHJlZml4X2l0ZW1fbGlzdF9jbGVhcigmY29tbWFuZHMpOwoJY2xlYXJfYWRkX2lfc3RhdGUoJnMpOwoKCXJldHVybiByZXM7Cn0K",
    "text": "#define DISABLE_SIGN_COMPARE_WARNINGS\n\n#include \"git-compat-util.h\"\n#include \"add-interactive.h\"\n#include \"color.h\"\n#include \"config.h\"\n#include \"diffcore.h\"\n#include \"gettext.h\"\n#include \"hash.h\"\n#include \"hex.h\"\n#include \"preload-index.h\"\n#include \"read-cache-ll.h\"\n#include \"repository.h\"\n#include \"revision.h\"\n#include \"refs.h\"\n#include \"string-list.h\"\n#include \"lockfile.h\"\n#include \"dir.h\"\n#include \"run-command.h\"\n#include \"prompt.h\"\n#include \"tree.h\"\n\nstatic void init_color(struct repository *r, int use_color,\n\t\t       const char *section_and_slot, char *dst,\n\t\t       const char *default_color)\n{\n\tchar *key = xstrfmt(\"color.%s\", section_and_slot);\n\tconst char *value;\n\n\tif (!use_color)\n\t\tdst[0] = '\\0';\n\telse if (repo_config_get_value(r, key, &value) ||\n\t\t color_parse(value, dst))\n\t\tstrlcpy(dst, default_color, COLOR_MAXLEN);\n\n\tfree(key);\n}\n\nstatic int check_color_config(struct repository *r, const char *var)\n{\n\tconst char *value;\n\tenum git_colorbool ret;\n\n\tif (repo_config_get_value(r, var, &value))\n\t\tret = GIT_COLOR_UNKNOWN;\n\telse\n\t\tret = git_config_colorbool(var, value);\n\n\t/*\n\t * Do not rely on want_color() to fall back to color.ui for us. It uses\n\t * the value parsed by git_color_config(), which may not have been\n\t * called by the main command.\n\t */\n\tif (ret == GIT_COLOR_UNKNOWN &&\n\t    !repo_config_get_value(r, \"color.ui\", &value))\n\t\tret = git_config_colorbool(\"color.ui\", value);\n\n\treturn want_color(ret);\n}\n\nvoid init_add_i_state(struct add_i_state *s, struct repository *r,\n\t\t      struct add_p_opt *add_p_opt)\n{\n\ts->r = r;\n\ts->context = -1;\n\ts->interhunkcontext = -1;\n\n\ts->use_color_interactive = check_color_config(r, \"color.interactive\");\n\n\tinit_color(r, s->use_color_interactive, \"interactive.header\",\n\t\t   s->header_color, GIT_COLOR_BOLD);\n\tinit_color(r, s->use_color_interactive, \"interactive.help\",\n\t\t   s->help_color, GIT_COLOR_BOLD_RED);\n\tinit_color(r, s->use_color_interactive, \"interactive.prompt\",\n\t\t   s->prompt_color, GIT_COLOR_BOLD_BLUE);\n\tinit_color(r, s->use_color_interactive, \"interactive.error\",\n\t\t   s->error_color, GIT_COLOR_BOLD_RED);\n\tstrlcpy(s->reset_color_interactive,\n\t\ts->use_color_interactive ? GIT_COLOR_RESET : \"\", COLOR_MAXLEN);\n\n\ts->use_color_diff = check_color_config(r, \"color.diff\");\n\n\tinit_color(r, s->use_color_diff, \"diff.frag\", s->fraginfo_color,\n\t\t   diff_get_color(s->use_color_diff, DIFF_FRAGINFO));\n\tinit_color(r, s->use_color_diff, \"diff.context\", s->context_color,\n\t\t   \"fall back\");\n\tif (!strcmp(s->context_color, \"fall back\"))\n\t\tinit_color(r, s->use_color_diff, \"diff.plain\",\n\t\t\t   s->context_color,\n\t\t\t   diff_get_color(s->use_color_diff, DIFF_CONTEXT));\n\tinit_color(r, s->use_color_diff, \"diff.old\", s->file_old_color,\n\t\t   diff_get_color(s->use_color_diff, DIFF_FILE_OLD));\n\tinit_color(r, s->use_color_diff, \"diff.new\", s->file_new_color,\n\t\t   diff_get_color(s->use_color_diff, DIFF_FILE_NEW));\n\tstrlcpy(s->reset_color_diff,\n\t\ts->use_color_diff ? GIT_COLOR_RESET : \"\", COLOR_MAXLEN);\n\n\tFREE_AND_NULL(s->interactive_diff_filter);\n\trepo_config_get_string(r, \"interactive.difffilter\",\n\t\t\t       &s->interactive_diff_filter);\n\n\tFREE_AND_NULL(s->interactive_diff_algorithm);\n\trepo_config_get_string(r, \"diff.algorithm\",\n\t\t\t       &s->interactive_diff_algorithm);\n\n\tif (!repo_config_get_int(r, \"diff.context\", &s->context))\n\t\tif (s->context < 0)\n\t\t\tdie(_(\"%s cannot be negative\"), \"diff.context\");\n\tif (!repo_config_get_int(r, \"diff.interHunkContext\", &s->interhunkcontext))\n\t\tif (s->interhunkcontext < 0)\n\t\t\tdie(_(\"%s cannot be negative\"), \"diff.interHunkContext\");\n\n\trepo_config_get_bool(r, \"interactive.singlekey\", &s->use_single_key);\n\tif (s->use_single_key)\n\t\tsetbuf(stdin, NULL);\n\n\tif (add_p_opt->context != -1) {\n\t\tif (add_p_opt->context < 0)\n\t\t\tdie(_(\"%s cannot be negative\"), \"--unified\");\n\t\ts->context = add_p_opt->context;\n\t}\n\tif (add_p_opt->interhunkcontext != -1) {\n\t\tif (add_p_opt->interhunkcontext < 0)\n\t\t\tdie(_(\"%s cannot be negative\"), \"--inter-hunk-context\");\n\t\ts->interhunkcontext = add_p_opt->interhunkcontext;\n\t}\n}\n\nvoid clear_add_i_state(struct add_i_state *s)\n{\n\tFREE_AND_NULL(s->interactive_diff_filter);\n\tFREE_AND_NULL(s->interactive_diff_algorithm);\n\tmemset(s, 0, sizeof(*s));\n\ts->use_color_interactive = GIT_COLOR_UNKNOWN;\n\ts->use_color_diff = GIT_COLOR_UNKNOWN;\n}\n\n/*\n * A \"prefix item list\" is a list of items that are identified by a string, and\n * a unique prefix (if any) is determined for each item.\n *\n * It is implemented in the form of a pair of `string_list`s, the first one\n * duplicating the strings, with the `util` field pointing at a structure whose\n * first field must be `size_t prefix_length`.\n *\n * That `prefix_length` field will be computed by `find_unique_prefixes()`; It\n * will be set to zero if no valid, unique prefix could be found.\n *\n * The second `string_list` is called `sorted` and does _not_ duplicate the\n * strings but simply reuses the first one's, with the `util` field pointing at\n * the `string_item_list` of the first `string_list`. It  will be populated and\n * sorted by `find_unique_prefixes()`.\n */\nstruct prefix_item_list {\n\tstruct string_list items;\n\tstruct string_list sorted;\n\tint *selected; /* for multi-selections */\n\tsize_t min_length, max_length;\n};\n#define PREFIX_ITEM_LIST_INIT { \\\n\t.items = STRING_LIST_INIT_DUP, \\\n\t.sorted = STRING_LIST_INIT_NODUP, \\\n\t.min_length = 1, \\\n\t.max_length = 4, \\\n}\n\nstatic void prefix_item_list_clear(struct prefix_item_list *list)\n{\n\tstring_list_clear(&list->items, 1);\n\tstring_list_clear(&list->sorted, 0);\n\tFREE_AND_NULL(list->selected);\n}\n\nstatic void extend_prefix_length(struct string_list_item *p,\n\t\t\t\t const char *other_string, size_t max_length)\n{\n\tsize_t *len = p->util;\n\n\tif (!*len || memcmp(p->string, other_string, *len))\n\t\treturn;\n\n\tfor (;;) {\n\t\tchar c = p->string[*len];\n\n\t\t/*\n\t\t * Is `p` a strict prefix of `other`? Or have we exhausted the\n\t\t * maximal length of the prefix? Or is the current character a\n\t\t * multi-byte UTF-8 one? If so, there is no valid, unique\n\t\t * prefix.\n\t\t */\n\t\tif (!c || ++*len > max_length || !isascii(c)) {\n\t\t\t*len = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (c != other_string[*len - 1])\n\t\t\tbreak;\n\t}\n}\n\nstatic void find_unique_prefixes(struct prefix_item_list *list)\n{\n\tsize_t i;\n\n\tif (list->sorted.nr == list->items.nr)\n\t\treturn;\n\n\tstring_list_clear(&list->sorted, 0);\n\t/* Avoid reallocating incrementally */\n\tlist->sorted.items = xmalloc(st_mult(sizeof(*list->sorted.items),\n\t\t\t\t\t     list->items.nr));\n\tlist->sorted.nr = list->sorted.alloc = list->items.nr;\n\n\tfor (i = 0; i < list->items.nr; i++) {\n\t\tlist->sorted.items[i].string = list->items.items[i].string;\n\t\tlist->sorted.items[i].util = list->items.items + i;\n\t}\n\n\tstring_list_sort(&list->sorted);\n\n\tfor (i = 0; i < list->sorted.nr; i++) {\n\t\tstruct string_list_item *sorted_item = list->sorted.items + i;\n\t\tstruct string_list_item *item = sorted_item->util;\n\t\tsize_t *len = item->util;\n\n\t\t*len = 0;\n\t\twhile (*len < list->min_length) {\n\t\t\tchar c = item->string[(*len)++];\n\n\t\t\tif (!c || !isascii(c)) {\n\t\t\t\t*len = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i > 0)\n\t\t\textend_prefix_length(item, sorted_item[-1].string,\n\t\t\t\t\t     list->max_length);\n\t\tif (i + 1 < list->sorted.nr)\n\t\t\textend_prefix_length(item, sorted_item[1].string,\n\t\t\t\t\t     list->max_length);\n\t}\n}\n\nstatic ssize_t find_unique(const char *string, struct prefix_item_list *list)\n{\n\tint index = string_list_find_insert_index(&list->sorted, string, 1);\n\tstruct string_list_item *item;\n\n\tif (list->items.nr != list->sorted.nr)\n\t\tBUG(\"prefix_item_list in inconsistent state (%\"PRIuMAX\n\t\t    \" vs %\"PRIuMAX\")\",\n\t\t    (uintmax_t)list->items.nr, (uintmax_t)list->sorted.nr);\n\n\tif (index < 0)\n\t\titem = list->sorted.items[-1 - index].util;\n\telse if (index > 0 &&\n\t\t starts_with(list->sorted.items[index - 1].string, string))\n\t\treturn -1;\n\telse if (index + 1 < list->sorted.nr &&\n\t\t starts_with(list->sorted.items[index + 1].string, string))\n\t\treturn -1;\n\telse if (index < list->sorted.nr &&\n\t\t starts_with(list->sorted.items[index].string, string))\n\t\titem = list->sorted.items[index].util;\n\telse\n\t\treturn -1;\n\treturn item - list->items.items;\n}\n\nstruct list_options {\n\tint columns;\n\tconst char *header;\n\tvoid (*print_item)(int i, int selected, struct string_list_item *item,\n\t\t\t   void *print_item_data);\n\tvoid *print_item_data;\n};\n\nstatic void list(struct add_i_state *s, struct string_list *list, int *selected,\n\t\t struct list_options *opts)\n{\n\tint i, last_lf = 0;\n\n\tif (!list->nr)\n\t\treturn;\n\n\tif (opts->header)\n\t\tcolor_fprintf_ln(stdout, s->header_color,\n\t\t\t\t \"%s\", opts->header);\n\n\tfor (i = 0; i < list->nr; i++) {\n\t\topts->print_item(i, selected ? selected[i] : 0, list->items + i,\n\t\t\t\t opts->print_item_data);\n\n\t\tif ((opts->columns) && ((i + 1) % (opts->columns))) {\n\t\t\tputchar('\\t');\n\t\t\tlast_lf = 0;\n\t\t}\n\t\telse {\n\t\t\tputchar('\\n');\n\t\t\tlast_lf = 1;\n\t\t}\n\t}\n\n\tif (!last_lf)\n\t\tputchar('\\n');\n}\nstruct list_and_choose_options {\n\tstruct list_options list_opts;\n\n\tconst char *prompt;\n\tenum {\n\t\tSINGLETON = (1<<0),\n\t\tIMMEDIATE = (1<<1),\n\t} flags;\n\tvoid (*print_help)(struct add_i_state *s);\n};\n\n#define LIST_AND_CHOOSE_ERROR (-1)\n#define LIST_AND_CHOOSE_QUIT  (-2)\n\n/*\n * Returns the selected index in singleton mode, the number of selected items\n * otherwise.\n *\n * If an error occurred, returns `LIST_AND_CHOOSE_ERROR`. Upon EOF,\n * `LIST_AND_CHOOSE_QUIT` is returned.\n */\nstatic ssize_t list_and_choose(struct add_i_state *s,\n\t\t\t       struct prefix_item_list *items,\n\t\t\t       struct list_and_choose_options *opts)\n{\n\tint singleton = opts->flags & SINGLETON;\n\tint immediate = opts->flags & IMMEDIATE;\n\n\tstruct strbuf input = STRBUF_INIT;\n\tssize_t res = singleton ? LIST_AND_CHOOSE_ERROR : 0;\n\n\tif (!singleton) {\n\t\tfree(items->selected);\n\t\tCALLOC_ARRAY(items->selected, items->items.nr);\n\t}\n\n\tif (singleton && !immediate)\n\t\tBUG(\"singleton requires immediate\");\n\n\tfind_unique_prefixes(items);\n\n\tfor (;;) {\n\t\tchar *p;\n\n\t\tstrbuf_reset(&input);\n\n\t\tlist(s, &items->items, items->selected, &opts->list_opts);\n\n\t\tcolor_fprintf(stdout, s->prompt_color, \"%s\", opts->prompt);\n\t\tfputs(singleton ? \"> \" : \">> \", stdout);\n\t\tfflush(stdout);\n\n\t\tif (git_read_line_interactively(&input) == EOF) {\n\t\t\tputchar('\\n');\n\t\t\tif (immediate)\n\t\t\t\tres = LIST_AND_CHOOSE_QUIT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!input.len)\n\t\t\tbreak;\n\n\t\tif (!strcmp(input.buf, \"?\")) {\n\t\t\topts->print_help(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\tp = input.buf;\n\t\tfor (;;) {\n\t\t\tsize_t sep = strcspn(p, \" \\t\\r\\n,\");\n\t\t\tint choose = 1;\n\t\t\t/* `from` is inclusive, `to` is exclusive */\n\t\t\tssize_t from = -1, to = -1;\n\n\t\t\tif (!sep) {\n\t\t\t\tif (!*p)\n\t\t\t\t\tbreak;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Input that begins with '-'; de-select */\n\t\t\tif (*p == '-') {\n\t\t\t\tchoose = 0;\n\t\t\t\tp++;\n\t\t\t\tsep--;\n\t\t\t}\n\n\t\t\tif (sep == 1 && *p == '*') {\n\t\t\t\tfrom = 0;\n\t\t\t\tto = items->items.nr;\n\t\t\t} else if (isdigit(*p)) {\n\t\t\t\tchar *endp;\n\t\t\t\t/*\n\t\t\t\t * A range can be specified like 5-7 or 5-.\n\t\t\t\t *\n\t\t\t\t * Note: `from` is 0-based while the user input\n\t\t\t\t * is 1-based, hence we have to decrement by\n\t\t\t\t * one. We do not have to decrement `to` even\n\t\t\t\t * if it is 0-based because it is an exclusive\n\t\t\t\t * boundary.\n\t\t\t\t */\n\t\t\t\tfrom = strtoul(p, &endp, 10) - 1;\n\t\t\t\tif (endp == p + sep)\n\t\t\t\t\tto = from + 1;\n\t\t\t\telse if (*endp == '-') {\n\t\t\t\t\tif (isdigit(*(++endp)))\n\t\t\t\t\t\tto = strtoul(endp, &endp, 10);\n\t\t\t\t\telse\n\t\t\t\t\t\tto = items->items.nr;\n\t\t\t\t\t/* extra characters after the range? */\n\t\t\t\t\tif (endp != p + sep)\n\t\t\t\t\t\tfrom = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p[sep])\n\t\t\t\tp[sep++] = '\\0';\n\t\t\tif (from < 0) {\n\t\t\t\tfrom = find_unique(p, items);\n\t\t\t\tif (from >= 0)\n\t\t\t\t\tto = from + 1;\n\t\t\t}\n\n\t\t\tif (from < 0 || from >= items->items.nr ||\n\t\t\t    (singleton && from + 1 != to)) {\n\t\t\t\tcolor_fprintf_ln(stderr, s->error_color,\n\t\t\t\t\t\t _(\"Huh (%s)?\"), p);\n\t\t\t\tbreak;\n\t\t\t} else if (singleton) {\n\t\t\t\tres = from;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (to > items->items.nr)\n\t\t\t\tto = items->items.nr;\n\n\t\t\tfor (; from < to; from++)\n\t\t\t\tif (items->selected[from] != choose) {\n\t\t\t\t\titems->selected[from] = choose;\n\t\t\t\t\tres += choose ? +1 : -1;\n\t\t\t\t}\n\n\t\t\tp += sep;\n\t\t}\n\n\t\tif ((immediate && res != LIST_AND_CHOOSE_ERROR) ||\n\t\t    !strcmp(input.buf, \"*\"))\n\t\t\tbreak;\n\t}\n\n\tstrbuf_release(&input);\n\treturn res;\n}\n\nstruct adddel {\n\tuintmax_t add, del;\n\tunsigned seen:1, unmerged:1, binary:1;\n};\n\nstruct file_item {\n\tsize_t prefix_length;\n\tstruct adddel index, worktree;\n};\n\nstatic void add_file_item(struct string_list *files, const char *name)\n{\n\tstruct file_item *item = xcalloc(1, sizeof(*item));\n\n\tstring_list_append(files, name)->util = item;\n}\n\nstruct pathname_entry {\n\tstruct hashmap_entry ent;\n\tconst char *name;\n\tstruct file_item *item;\n};\n\nstatic int pathname_entry_cmp(const void *cmp_data UNUSED,\n\t\t\t      const struct hashmap_entry *he1,\n\t\t\t      const struct hashmap_entry *he2,\n\t\t\t      const void *name)\n{\n\tconst struct pathname_entry *e1 =\n\t\tcontainer_of(he1, const struct pathname_entry, ent);\n\tconst struct pathname_entry *e2 =\n\t\tcontainer_of(he2, const struct pathname_entry, ent);\n\n\treturn strcmp(e1->name, name ? (const char *)name : e2->name);\n}\n\nstruct collection_status {\n\tenum { FROM_WORKTREE = 0, FROM_INDEX = 1 } mode;\n\n\tconst char *reference;\n\n\tunsigned skip_unseen:1;\n\tsize_t unmerged_count, binary_count;\n\tstruct string_list *files;\n\tstruct hashmap file_map;\n};\n\nstatic void collect_changes_cb(struct diff_queue_struct *q,\n\t\t\t       struct diff_options *options,\n\t\t\t       void *data)\n{\n\tstruct collection_status *s = data;\n\tstruct diffstat_t stat = { 0 };\n\tint i;\n\n\tif (!q->nr)\n\t\treturn;\n\n\tcompute_diffstat(options, &stat, q);\n\n\tfor (i = 0; i < stat.nr; i++) {\n\t\tconst char *name = stat.files[i]->name;\n\t\tint hash = strhash(name);\n\t\tstruct pathname_entry *entry;\n\t\tstruct file_item *file_item;\n\t\tstruct adddel *adddel, *other_adddel;\n\n\t\tentry = hashmap_get_entry_from_hash(&s->file_map, hash, name,\n\t\t\t\t\t\t    struct pathname_entry, ent);\n\t\tif (!entry) {\n\t\t\tif (s->skip_unseen)\n\t\t\t\tcontinue;\n\n\t\t\tadd_file_item(s->files, name);\n\n\t\t\tCALLOC_ARRAY(entry, 1);\n\t\t\thashmap_entry_init(&entry->ent, hash);\n\t\t\tentry->name = s->files->items[s->files->nr - 1].string;\n\t\t\tentry->item = s->files->items[s->files->nr - 1].util;\n\t\t\thashmap_add(&s->file_map, &entry->ent);\n\t\t}\n\n\t\tfile_item = entry->item;\n\t\tadddel = s->mode == FROM_INDEX ?\n\t\t\t&file_item->index : &file_item->worktree;\n\t\tother_adddel = s->mode == FROM_INDEX ?\n\t\t\t&file_item->worktree : &file_item->index;\n\t\tadddel->seen = 1;\n\t\tadddel->add = stat.files[i]->added;\n\t\tadddel->del = stat.files[i]->deleted;\n\t\tif (stat.files[i]->is_binary) {\n\t\t\tif (!other_adddel->binary)\n\t\t\t\ts->binary_count++;\n\t\t\tadddel->binary = 1;\n\t\t}\n\t\tif (stat.files[i]->is_unmerged) {\n\t\t\tif (!other_adddel->unmerged)\n\t\t\t\ts->unmerged_count++;\n\t\t\tadddel->unmerged = 1;\n\t\t}\n\t}\n\tfree_diffstat_info(&stat);\n}\n\nenum modified_files_filter {\n\tNO_FILTER = 0,\n\tWORKTREE_ONLY = 1,\n\tINDEX_ONLY = 2,\n};\n\nstatic int get_modified_files(struct repository *r,\n\t\t\t      enum modified_files_filter filter,\n\t\t\t      struct prefix_item_list *files,\n\t\t\t      const struct pathspec *ps,\n\t\t\t      size_t *unmerged_count,\n\t\t\t      size_t *binary_count)\n{\n\tstruct object_id head_oid;\n\tint is_initial = !refs_resolve_ref_unsafe(get_main_ref_store(r),\n\t\t\t\t\t\t  \"HEAD\", RESOLVE_REF_READING,\n\t\t\t\t\t\t  &head_oid, NULL);\n\tstruct collection_status s = { 0 };\n\tint i;\n\n\tdiscard_index(r->index);\n\tif (repo_read_index_preload(r, ps, 0) < 0)\n\t\treturn error(_(\"could not read index\"));\n\n\tprefix_item_list_clear(files);\n\ts.files = &files->items;\n\thashmap_init(&s.file_map, pathname_entry_cmp, NULL, 0);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct rev_info rev;\n\t\tstruct setup_revision_opt opt = { 0 };\n\n\t\tif (filter == INDEX_ONLY)\n\t\t\ts.mode = (i == 0) ? FROM_INDEX : FROM_WORKTREE;\n\t\telse\n\t\t\ts.mode = (i == 0) ? FROM_WORKTREE : FROM_INDEX;\n\t\ts.skip_unseen = filter && i;\n\n\t\topt.def = is_initial ?\n\t\t\tempty_tree_oid_hex(r->hash_algo) : oid_to_hex(&head_oid);\n\n\t\trepo_init_revisions(r, &rev, NULL);\n\t\tsetup_revisions(0, NULL, &rev, &opt);\n\n\t\trev.diffopt.output_format = DIFF_FORMAT_CALLBACK;\n\t\trev.diffopt.format_callback = collect_changes_cb;\n\t\trev.diffopt.format_callback_data = &s;\n\n\t\tif (ps)\n\t\t\tcopy_pathspec(&rev.prune_data, ps);\n\n\t\tif (s.mode == FROM_INDEX)\n\t\t\trun_diff_index(&rev, DIFF_INDEX_CACHED);\n\t\telse {\n\t\t\trev.diffopt.flags.ignore_dirty_submodules = 1;\n\t\t\trun_diff_files(&rev, 0);\n\t\t}\n\n\t\trelease_revisions(&rev);\n\t}\n\thashmap_clear_and_free(&s.file_map, struct pathname_entry, ent);\n\tif (unmerged_count)\n\t\t*unmerged_count = s.unmerged_count;\n\tif (binary_count)\n\t\t*binary_count = s.binary_count;\n\n\t/* While the diffs are ordered already, we ran *two* diffs... */\n\tstring_list_sort(&files->items);\n\n\treturn 0;\n}\n\nstatic void render_adddel(struct strbuf *buf,\n\t\t\t\tstruct adddel *ad, const char *no_changes)\n{\n\tif (ad->binary)\n\t\tstrbuf_addstr(buf, _(\"binary\"));\n\telse if (ad->seen)\n\t\tstrbuf_addf(buf, \"+%\"PRIuMAX\"/-%\"PRIuMAX,\n\t\t\t    (uintmax_t)ad->add, (uintmax_t)ad->del);\n\telse\n\t\tstrbuf_addstr(buf, no_changes);\n}\n\n/* filters out prefixes which have special meaning to list_and_choose() */\nstatic int is_valid_prefix(const char *prefix, size_t prefix_len)\n{\n\treturn prefix_len && prefix &&\n\t\t/*\n\t\t * We expect `prefix` to be NUL terminated, therefore this\n\t\t * `strcspn()` call is okay, even if it might do much more\n\t\t * work than strictly necessary.\n\t\t */\n\t\tstrcspn(prefix, \" \\t\\r\\n,\") >= prefix_len &&\t/* separators */\n\t\t*prefix != '-' &&\t\t\t\t/* deselection */\n\t\t!isdigit(*prefix) &&\t\t\t\t/* selection */\n\t\t(prefix_len != 1 ||\n\t\t (*prefix != '*' &&\t\t\t\t/* \"all\" wildcard */\n\t\t  *prefix != '?'));\t\t\t\t/* prompt help */\n}\n\nstruct print_file_item_data {\n\tconst char *modified_fmt, *color, *reset;\n\tstruct strbuf buf, name, index, worktree;\n\tunsigned only_names:1;\n};\n\nstatic void print_file_item(int i, int selected, struct string_list_item *item,\n\t\t\t    void *print_file_item_data)\n{\n\tstruct file_item *c = item->util;\n\tstruct print_file_item_data *d = print_file_item_data;\n\tconst char *highlighted = NULL;\n\n\tstrbuf_reset(&d->index);\n\tstrbuf_reset(&d->worktree);\n\tstrbuf_reset(&d->buf);\n\n\t/* Format the item with the prefix highlighted. */\n\tif (c->prefix_length > 0 &&\n\t    is_valid_prefix(item->string, c->prefix_length)) {\n\t\tstrbuf_reset(&d->name);\n\t\tstrbuf_addf(&d->name, \"%s%.*s%s%s\", d->color,\n\t\t\t    (int)c->prefix_length, item->string, d->reset,\n\t\t\t    item->string + c->prefix_length);\n\t\thighlighted = d->name.buf;\n\t}\n\n\tif (d->only_names) {\n\t\tprintf(\"%c%2d: %s\", selected ? '*' : ' ', i + 1,\n\t\t       highlighted ? highlighted : item->string);\n\t\treturn;\n\t}\n\n\trender_adddel(&d->worktree, &c->worktree, _(\"nothing\"));\n\trender_adddel(&d->index, &c->index, _(\"unchanged\"));\n\n\tstrbuf_addf(&d->buf, d->modified_fmt, d->index.buf, d->worktree.buf,\n\t\t    highlighted ? highlighted : item->string);\n\n\tprintf(\"%c%2d: %s\", selected ? '*' : ' ', i + 1, d->buf.buf);\n}\n\nstatic int run_status(struct add_i_state *s, const struct pathspec *ps,\n\t\t      struct prefix_item_list *files,\n\t\t      struct list_and_choose_options *opts)\n{\n\tif (get_modified_files(s->r, NO_FILTER, files, ps, NULL, NULL) < 0)\n\t\treturn -1;\n\n\tlist(s, &files->items, NULL, &opts->list_opts);\n\tputchar('\\n');\n\n\treturn 0;\n}\n\nstatic int run_update(struct add_i_state *s, const struct pathspec *ps,\n\t\t      struct prefix_item_list *files,\n\t\t      struct list_and_choose_options *opts)\n{\n\tint res = 0, fd;\n\tsize_t count, i;\n\tstruct lock_file index_lock;\n\n\tif (get_modified_files(s->r, WORKTREE_ONLY, files, ps, NULL, NULL) < 0)\n\t\treturn -1;\n\n\tif (!files->items.nr) {\n\t\tputchar('\\n');\n\t\treturn 0;\n\t}\n\n\topts->prompt = N_(\"Update\");\n\tcount = list_and_choose(s, files, opts);\n\tif (count <= 0) {\n\t\tputchar('\\n');\n\t\treturn 0;\n\t}\n\n\tfd = repo_hold_locked_index(s->r, &index_lock, LOCK_REPORT_ON_ERROR);\n\tif (fd < 0) {\n\t\tputchar('\\n');\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < files->items.nr; i++) {\n\t\tconst char *name = files->items.items[i].string;\n\t\tstruct stat st;\n\n\t\tif (!files->selected[i])\n\t\t\tcontinue;\n\t\tif (lstat(name, &st) && is_missing_file_error(errno)) {\n\t\t\tif (remove_file_from_index(s->r->index, name) < 0) {\n\t\t\t\tres = error(_(\"could not stage '%s'\"), name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (add_file_to_index(s->r->index, name, 0) < 0) {\n\t\t\tres = error(_(\"could not stage '%s'\"), name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!res && write_locked_index(s->r->index, &index_lock, COMMIT_LOCK) < 0)\n\t\tres = error(_(\"could not write index\"));\n\n\tif (!res)\n\t\tprintf(Q_(\"updated %d path\\n\",\n\t\t\t  \"updated %d paths\\n\", count), (int)count);\n\n\tputchar('\\n');\n\treturn res;\n}\n\nstatic void revert_from_diff(struct diff_queue_struct *q,\n\t\t\t     struct diff_options *opt, void *data UNUSED)\n{\n\tint i, add_flags = ADD_CACHE_OK_TO_ADD | ADD_CACHE_OK_TO_REPLACE;\n\n\tfor (i = 0; i < q->nr; i++) {\n\t\tstruct diff_filespec *one = q->queue[i]->one;\n\t\tstruct cache_entry *ce;\n\n\t\tif (!(one->mode && !is_null_oid(&one->oid))) {\n\t\t\tremove_file_from_index(opt->repo->index, one->path);\n\t\t\tprintf(_(\"note: %s is untracked now.\\n\"), one->path);\n\t\t} else {\n\t\t\tce = make_cache_entry(opt->repo->index, one->mode,\n\t\t\t\t\t      &one->oid, one->path, 0, 0);\n\t\t\tif (!ce)\n\t\t\t\tdie(_(\"make_cache_entry failed for path '%s'\"),\n\t\t\t\t    one->path);\n\t\t\tadd_index_entry(opt->repo->index, ce, add_flags);\n\t\t}\n\t}\n}\n\nstatic int run_revert(struct add_i_state *s, const struct pathspec *ps,\n\t\t      struct prefix_item_list *files,\n\t\t      struct list_and_choose_options *opts)\n{\n\tint res = 0, fd;\n\tsize_t count, i, j;\n\n\tstruct object_id oid;\n\tint is_initial = !refs_resolve_ref_unsafe(get_main_ref_store(s->r),\n\t\t\t\t\t\t  \"HEAD\", RESOLVE_REF_READING,\n\t\t\t\t\t\t  &oid,\n\t\t\t\t\t\t  NULL);\n\tstruct lock_file index_lock;\n\tconst char **paths;\n\tstruct tree *tree;\n\tstruct diff_options diffopt = { NULL };\n\n\tif (get_modified_files(s->r, INDEX_ONLY, files, ps, NULL, NULL) < 0)\n\t\treturn -1;\n\n\tif (!files->items.nr) {\n\t\tputchar('\\n');\n\t\treturn 0;\n\t}\n\n\topts->prompt = N_(\"Revert\");\n\tcount = list_and_choose(s, files, opts);\n\tif (count <= 0)\n\t\tgoto finish_revert;\n\n\tfd = repo_hold_locked_index(s->r, &index_lock, LOCK_REPORT_ON_ERROR);\n\tif (fd < 0) {\n\t\tres = -1;\n\t\tgoto finish_revert;\n\t}\n\n\tif (is_initial)\n\t\toidcpy(&oid, s->r->hash_algo->empty_tree);\n\telse {\n\t\ttree = parse_tree_indirect(&oid);\n\t\tif (!tree) {\n\t\t\tres = error(_(\"Could not parse HEAD^{tree}\"));\n\t\t\tgoto finish_revert;\n\t\t}\n\t\toidcpy(&oid, &tree->object.oid);\n\t}\n\n\tALLOC_ARRAY(paths, count + 1);\n\tfor (i = j = 0; i < files->items.nr; i++)\n\t\tif (files->selected[i])\n\t\t\tpaths[j++] = files->items.items[i].string;\n\tpaths[j] = NULL;\n\n\tparse_pathspec(&diffopt.pathspec, 0,\n\t\t       PATHSPEC_PREFER_FULL | PATHSPEC_LITERAL_PATH,\n\t\t       NULL, paths);\n\n\tdiffopt.output_format = DIFF_FORMAT_CALLBACK;\n\tdiffopt.format_callback = revert_from_diff;\n\tdiffopt.flags.override_submodule_config = 1;\n\tdiffopt.repo = s->r;\n\n\tif (do_diff_cache(&oid, &diffopt)) {\n\t\tdiff_free(&diffopt);\n\t\tres = -1;\n\t} else {\n\t\tdiffcore_std(&diffopt);\n\t\tdiff_flush(&diffopt);\n\t}\n\tfree(paths);\n\n\tif (!res && write_locked_index(s->r->index, &index_lock,\n\t\t\t\t       COMMIT_LOCK) < 0)\n\t\tres = -1;\n\telse\n\t\tres = repo_refresh_and_write_index(s->r, REFRESH_QUIET, 0, 1,\n\t\t\t\t\t\t   NULL, NULL, NULL);\n\n\tif (!res)\n\t\tprintf(Q_(\"reverted %d path\\n\",\n\t\t\t  \"reverted %d paths\\n\", count), (int)count);\n\nfinish_revert:\n\tputchar('\\n');\n\treturn res;\n}\n\nstatic int get_untracked_files(struct repository *r,\n\t\t\t       struct prefix_item_list *files,\n\t\t\t       const struct pathspec *ps)\n{\n\tstruct dir_struct dir = { 0 };\n\tsize_t i;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tif (repo_read_index(r) < 0)\n\t\treturn error(_(\"could not read index\"));\n\n\tprefix_item_list_clear(files);\n\tsetup_standard_excludes(&dir);\n\tadd_pattern_list(&dir, EXC_CMDL, \"--exclude option\");\n\tfill_directory(&dir, r->index, ps);\n\n\tfor (i = 0; i < dir.nr; i++) {\n\t\tstruct dir_entry *ent = dir.entries[i];\n\n\t\tif (index_name_is_other(r->index, ent->name, ent->len)) {\n\t\t\tstrbuf_reset(&buf);\n\t\t\tstrbuf_add(&buf, ent->name, ent->len);\n\t\t\tadd_file_item(&files->items, buf.buf);\n\t\t}\n\t}\n\n\tstrbuf_release(&buf);\n\tdir_clear(&dir);\n\treturn 0;\n}\n\nstatic int run_add_untracked(struct add_i_state *s, const struct pathspec *ps,\n\t\t      struct prefix_item_list *files,\n\t\t      struct list_and_choose_options *opts)\n{\n\tstruct print_file_item_data *d = opts->list_opts.print_item_data;\n\tint res = 0, fd;\n\tsize_t count, i;\n\tstruct lock_file index_lock;\n\n\tif (get_untracked_files(s->r, files, ps) < 0)\n\t\treturn -1;\n\n\tif (!files->items.nr) {\n\t\tprintf(_(\"No untracked files.\\n\"));\n\t\tgoto finish_add_untracked;\n\t}\n\n\topts->prompt = N_(\"Add untracked\");\n\td->only_names = 1;\n\tcount = list_and_choose(s, files, opts);\n\td->only_names = 0;\n\tif (count <= 0)\n\t\tgoto finish_add_untracked;\n\n\tfd = repo_hold_locked_index(s->r, &index_lock, LOCK_REPORT_ON_ERROR);\n\tif (fd < 0) {\n\t\tres = -1;\n\t\tgoto finish_add_untracked;\n\t}\n\n\tfor (i = 0; i < files->items.nr; i++) {\n\t\tconst char *name = files->items.items[i].string;\n\t\tif (files->selected[i] &&\n\t\t    add_file_to_index(s->r->index, name, 0) < 0) {\n\t\t\tres = error(_(\"could not stage '%s'\"), name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!res &&\n\t    write_locked_index(s->r->index, &index_lock, COMMIT_LOCK) < 0)\n\t\tres = error(_(\"could not write index\"));\n\n\tif (!res)\n\t\tprintf(Q_(\"added %d path\\n\",\n\t\t\t  \"added %d paths\\n\", count), (int)count);\n\nfinish_add_untracked:\n\tputchar('\\n');\n\treturn res;\n}\n\nstatic int run_patch(struct add_i_state *s, const struct pathspec *ps,\n\t\t     struct prefix_item_list *files,\n\t\t     struct list_and_choose_options *opts)\n{\n\tint res = 0;\n\tssize_t count, i, j;\n\tsize_t unmerged_count = 0, binary_count = 0;\n\n\tif (get_modified_files(s->r, WORKTREE_ONLY, files, ps,\n\t\t\t       &unmerged_count, &binary_count) < 0)\n\t\treturn -1;\n\n\tif (unmerged_count || binary_count) {\n\t\tfor (i = j = 0; i < files->items.nr; i++) {\n\t\t\tstruct file_item *item = files->items.items[i].util;\n\n\t\t\tif (item->index.binary || item->worktree.binary) {\n\t\t\t\tfree(item);\n\t\t\t\tfree(files->items.items[i].string);\n\t\t\t} else if (item->index.unmerged ||\n\t\t\t\t item->worktree.unmerged) {\n\t\t\t\tcolor_fprintf_ln(stderr, s->error_color,\n\t\t\t\t\t\t _(\"ignoring unmerged: %s\"),\n\t\t\t\t\t\t files->items.items[i].string);\n\t\t\t\tfree(item);\n\t\t\t\tfree(files->items.items[i].string);\n\t\t\t} else\n\t\t\t\tfiles->items.items[j++] = files->items.items[i];\n\t\t}\n\t\tfiles->items.nr = j;\n\t}\n\n\tif (!files->items.nr) {\n\t\tif (binary_count)\n\t\t\tfprintf(stderr, _(\"Only binary files changed.\\n\"));\n\t\telse\n\t\t\tfprintf(stderr, _(\"No changes.\\n\"));\n\t\treturn 0;\n\t}\n\n\topts->prompt = N_(\"Patch update\");\n\tcount = list_and_choose(s, files, opts);\n\tif (count > 0) {\n\t\tstruct add_p_opt add_p_opt = {\n\t\t\t.context = s->context,\n\t\t\t.interhunkcontext = s->interhunkcontext,\n\t\t};\n\t\tstruct strvec args = STRVEC_INIT;\n\t\tstruct pathspec ps_selected = { 0 };\n\n\t\tfor (i = 0; i < files->items.nr; i++)\n\t\t\tif (files->selected[i])\n\t\t\t\tstrvec_push(&args,\n\t\t\t\t\t    files->items.items[i].string);\n\t\tparse_pathspec(&ps_selected,\n\t\t\t       PATHSPEC_ALL_MAGIC & ~PATHSPEC_LITERAL,\n\t\t\t       PATHSPEC_LITERAL_PATH, \"\", args.v);\n\t\tres = run_add_p(s->r, ADD_P_ADD, &add_p_opt, NULL, &ps_selected);\n\t\tstrvec_clear(&args);\n\t\tclear_pathspec(&ps_selected);\n\t}\n\n\treturn res;\n}\n\nstatic int run_diff(struct add_i_state *s, const struct pathspec *ps,\n\t\t    struct prefix_item_list *files,\n\t\t    struct list_and_choose_options *opts)\n{\n\tint res = 0;\n\tssize_t count, i;\n\n\tstruct object_id oid;\n\tint is_initial = !refs_resolve_ref_unsafe(get_main_ref_store(s->r),\n\t\t\t\t\t\t  \"HEAD\", RESOLVE_REF_READING,\n\t\t\t\t\t\t  &oid,\n\t\t\t\t\t\t  NULL);\n\tif (get_modified_files(s->r, INDEX_ONLY, files, ps, NULL, NULL) < 0)\n\t\treturn -1;\n\n\tif (!files->items.nr) {\n\t\tputchar('\\n');\n\t\treturn 0;\n\t}\n\n\topts->prompt = N_(\"Review diff\");\n\topts->flags = IMMEDIATE;\n\tcount = list_and_choose(s, files, opts);\n\topts->flags = 0;\n\tif (count > 0) {\n\t\tstruct child_process cmd = CHILD_PROCESS_INIT;\n\n\t\tstrvec_pushl(&cmd.args, \"git\", \"diff\", \"-p\", \"--cached\", NULL);\n\t\tif (s->context != -1)\n\t\t\tstrvec_pushf(&cmd.args, \"--unified=%i\", s->context);\n\t\tif (s->interhunkcontext != -1)\n\t\t\tstrvec_pushf(&cmd.args, \"--inter-hunk-context=%i\", s->interhunkcontext);\n\t\tstrvec_pushl(&cmd.args, oid_to_hex(!is_initial ? &oid :\n\t\t\t     s->r->hash_algo->empty_tree), \"--\", NULL);\n\t\tfor (i = 0; i < files->items.nr; i++)\n\t\t\tif (files->selected[i])\n\t\t\t\tstrvec_push(&cmd.args,\n\t\t\t\t\t    files->items.items[i].string);\n\t\tres = run_command(&cmd);\n\t}\n\n\tputchar('\\n');\n\treturn res;\n}\n\nstatic int run_help(struct add_i_state *s, const struct pathspec *ps UNUSED,\n\t\t    struct prefix_item_list *files UNUSED,\n\t\t    struct list_and_choose_options *opts UNUSED)\n{\n\tcolor_fprintf_ln(stdout, s->help_color, \"status        - %s\",\n\t\t\t _(\"show paths with changes\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"update        - %s\",\n\t\t\t _(\"add working tree state to the staged set of changes\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"revert        - %s\",\n\t\t\t _(\"revert staged set of changes back to the HEAD version\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"patch         - %s\",\n\t\t\t _(\"pick hunks and update selectively\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"diff          - %s\",\n\t\t\t _(\"view diff between HEAD and index\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"add untracked - %s\",\n\t\t\t _(\"add contents of untracked files to the staged set of changes\"));\n\n\treturn 0;\n}\n\nstatic void choose_prompt_help(struct add_i_state *s)\n{\n\tcolor_fprintf_ln(stdout, s->help_color, \"%s\",\n\t\t\t _(\"Prompt help:\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"1          - %s\",\n\t\t\t _(\"select a single item\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"3-5        - %s\",\n\t\t\t _(\"select a range of items\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"2-3,6-9    - %s\",\n\t\t\t _(\"select multiple ranges\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"foo        - %s\",\n\t\t\t _(\"select item based on unique prefix\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"-...       - %s\",\n\t\t\t _(\"unselect specified items\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"*          - %s\",\n\t\t\t _(\"choose all items\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"           - %s\",\n\t\t\t _(\"(empty) finish selecting\"));\n}\n\ntypedef int (*command_t)(struct add_i_state *s, const struct pathspec *ps,\n\t\t\t struct prefix_item_list *files,\n\t\t\t struct list_and_choose_options *opts);\n\nstruct command_item {\n\tsize_t prefix_length;\n\tcommand_t command;\n};\n\nstruct print_command_item_data {\n\tconst char *color, *reset;\n};\n\nstatic void print_command_item(int i, int selected UNUSED,\n\t\t\t       struct string_list_item *item,\n\t\t\t       void *print_command_item_data)\n{\n\tstruct print_command_item_data *d = print_command_item_data;\n\tstruct command_item *util = item->util;\n\n\tif (!util->prefix_length ||\n\t    !is_valid_prefix(item->string, util->prefix_length))\n\t\tprintf(\" %2d: %s\", i + 1, item->string);\n\telse\n\t\tprintf(\" %2d: %s%.*s%s%s\", i + 1,\n\t\t       d->color, (int)util->prefix_length, item->string,\n\t\t       d->reset, item->string + util->prefix_length);\n}\n\nstatic void command_prompt_help(struct add_i_state *s)\n{\n\tconst char *help_color = s->help_color;\n\tcolor_fprintf_ln(stdout, help_color, \"%s\", _(\"Prompt help:\"));\n\tcolor_fprintf_ln(stdout, help_color, \"1          - %s\",\n\t\t\t _(\"select a numbered item\"));\n\tcolor_fprintf_ln(stdout, help_color, \"foo        - %s\",\n\t\t\t _(\"select item based on unique prefix\"));\n\tcolor_fprintf_ln(stdout, help_color, \"           - %s\",\n\t\t\t _(\"(empty) select nothing\"));\n}\n\nint run_add_i(struct repository *r, const struct pathspec *ps,\n\t      struct add_p_opt *add_p_opt)\n{\n\tstruct add_i_state s = { NULL };\n\tstruct print_command_item_data data = { \"[\", \"]\" };\n\tstruct list_and_choose_options main_loop_opts = {\n\t\t{ 4, N_(\"*** Commands ***\"), print_command_item, &data },\n\t\tN_(\"What now\"), SINGLETON | IMMEDIATE, command_prompt_help\n\t};\n\tstruct {\n\t\tconst char *string;\n\t\tcommand_t command;\n\t} command_list[] = {\n\t\t{ \"status\", run_status },\n\t\t{ \"update\", run_update },\n\t\t{ \"revert\", run_revert },\n\t\t{ \"add untracked\", run_add_untracked },\n\t\t{ \"patch\", run_patch },\n\t\t{ \"diff\", run_diff },\n\t\t{ \"quit\", NULL },\n\t\t{ \"help\", run_help },\n\t};\n\tstruct prefix_item_list commands = PREFIX_ITEM_LIST_INIT;\n\n\tstruct print_file_item_data print_file_item_data = {\n\t\t\"%12s %12s %s\", NULL, NULL,\n\t\tSTRBUF_INIT, STRBUF_INIT, STRBUF_INIT, STRBUF_INIT\n\t};\n\tstruct list_and_choose_options opts = {\n\t\t{ 0, NULL, print_file_item, &print_file_item_data },\n\t\tNULL, 0, choose_prompt_help\n\t};\n\tstruct strbuf header = STRBUF_INIT;\n\tstruct prefix_item_list files = PREFIX_ITEM_LIST_INIT;\n\tssize_t i;\n\tint res = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(command_list); i++) {\n\t\tstruct command_item *util = xcalloc(1, sizeof(*util));\n\t\tutil->command = command_list[i].command;\n\t\tstring_list_append(&commands.items, command_list[i].string)\n\t\t\t->util = util;\n\t}\n\n\tinit_add_i_state(&s, r, add_p_opt);\n\n\t/*\n\t * When color was asked for, use the prompt color for\n\t * highlighting, otherwise use square brackets.\n\t */\n\tif (s.use_color_interactive) {\n\t\tdata.color = s.prompt_color;\n\t\tdata.reset = s.reset_color_interactive;\n\t}\n\tprint_file_item_data.color = data.color;\n\tprint_file_item_data.reset = data.reset;\n\n\tstrbuf_addstr(&header, \"     \");\n\tstrbuf_addf(&header, print_file_item_data.modified_fmt,\n\t\t    _(\"staged\"), _(\"unstaged\"), _(\"path\"));\n\topts.list_opts.header = header.buf;\n\n\tdiscard_index(r->index);\n\tif (repo_read_index(r) < 0 ||\n\t    repo_refresh_and_write_index(r, REFRESH_QUIET, 0, 1,\n\t\t\t\t\t NULL, NULL, NULL) < 0)\n\t\twarning(_(\"could not refresh index\"));\n\n\tres = run_status(&s, ps, &files, &opts);\n\n\tfor (;;) {\n\t\tstruct command_item *util;\n\n\t\ti = list_and_choose(&s, &commands, &main_loop_opts);\n\t\tif (i < 0 || i >= commands.items.nr)\n\t\t\tutil = NULL;\n\t\telse\n\t\t\tutil = commands.items.items[i].util;\n\n\t\tif (i == LIST_AND_CHOOSE_QUIT || (util && !util->command)) {\n\t\t\tprintf(_(\"Bye.\\n\"));\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (util)\n\t\t\tres = util->command(&s, ps, &files, &opts);\n\t}\n\n\tprefix_item_list_clear(&files);\n\tstrbuf_release(&print_file_item_data.buf);\n\tstrbuf_release(&print_file_item_data.name);\n\tstrbuf_release(&print_file_item_data.index);\n\tstrbuf_release(&print_file_item_data.worktree);\n\tstrbuf_release(&header);\n\tprefix_item_list_clear(&commands);\n\tclear_add_i_state(&s);\n\n\treturn res;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "000315971eda13982d9e42a901bbc848c112d4d5",
  "sha1_ok": false,
  "size": 33783
}
