{
  "content": {
    "base64": "LyoKICogImdpdCByZXNldCIgYnVpbHRpbiBjb21tYW5kCiAqCiAqIENvcHlyaWdodCAoYykgMjAwNyBDYXJsb3MgUmljYQogKgogKiBCYXNlZCBvbiBnaXQtcmVzZXQuc2gsIHdoaWNoIGlzCiAqCiAqIENvcHlyaWdodCAoYykgMjAwNSwgMjAwNiBMaW51cyBUb3J2YWxkcyBhbmQgSnVuaW8gQyBIYW1hbm8KICovCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImxvY2tmaWxlLmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgIm9iamVjdC5oIgojaW5jbHVkZSAicHJldHR5LmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAiZGlmZmNvcmUuaCIKI2luY2x1ZGUgInRyZWUuaCIKI2luY2x1ZGUgImJyYW5jaC5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAidW5wYWNrLXRyZWVzLmgiCiNpbmNsdWRlICJjYWNoZS10cmVlLmgiCiNpbmNsdWRlICJzdWJtb2R1bGUuaCIKI2luY2x1ZGUgInN1Ym1vZHVsZS1jb25maWcuaCIKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgZ2l0X3Jlc2V0X3VzYWdlW10gPSB7CglOXygiZ2l0IHJlc2V0IFstLW1peGVkIHwgLS1zb2Z0IHwgLS1oYXJkIHwgLS1tZXJnZSB8IC0ta2VlcF0gWy1xXSBbPGNvbW1pdD5dIiksCglOXygiZ2l0IHJlc2V0IFstcV0gWzx0cmVlLWlzaD5dIFstLV0gPHBhdGhzPi4uLiIpLAoJTl8oImdpdCByZXNldCAtLXBhdGNoIFs8dHJlZS1pc2g+XSBbLS1dIFs8cGF0aHM+Li4uXSIpLAoJTlVMTAp9OwoKZW51bSByZXNldF90eXBlIHsgTUlYRUQsIFNPRlQsIEhBUkQsIE1FUkdFLCBLRUVQLCBOT05FIH07CnN0YXRpYyBjb25zdCBjaGFyICpyZXNldF90eXBlX25hbWVzW10gPSB7CglOXygibWl4ZWQiKSwgTl8oInNvZnQiKSwgTl8oImhhcmQiKSwgTl8oIm1lcmdlIiksIE5fKCJrZWVwIiksIE5VTEwKfTsKCnN0YXRpYyBpbmxpbmUgaW50IGlzX21lcmdlKHZvaWQpCnsKCXJldHVybiAhYWNjZXNzKGdpdF9wYXRoX21lcmdlX2hlYWQoKSwgRl9PSyk7Cn0KCnN0YXRpYyBpbnQgcmVzZXRfaW5kZXgoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBpbnQgcmVzZXRfdHlwZSwgaW50IHF1aWV0KQp7CglpbnQgaSwgbnIgPSAwOwoJc3RydWN0IHRyZWVfZGVzYyBkZXNjWzJdOwoJc3RydWN0IHRyZWUgKnRyZWU7CglzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgb3B0czsKCWludCByZXQgPSAtMTsKCgltZW1zZXQoJm9wdHMsIDAsIHNpemVvZihvcHRzKSk7CglvcHRzLmhlYWRfaWR4ID0gMTsKCW9wdHMuc3JjX2luZGV4ID0gJnRoZV9pbmRleDsKCW9wdHMuZHN0X2luZGV4ID0gJnRoZV9pbmRleDsKCW9wdHMuZm4gPSBvbmV3YXlfbWVyZ2U7CglvcHRzLm1lcmdlID0gMTsKCWlmICghcXVpZXQpCgkJb3B0cy52ZXJib3NlX3VwZGF0ZSA9IDE7Cglzd2l0Y2ggKHJlc2V0X3R5cGUpIHsKCWNhc2UgS0VFUDoKCWNhc2UgTUVSR0U6CgkJb3B0cy51cGRhdGUgPSAxOwoJCWJyZWFrOwoJY2FzZSBIQVJEOgoJCW9wdHMudXBkYXRlID0gMTsKCQkvKiBmYWxsdGhyb3VnaCAqLwoJZGVmYXVsdDoKCQlvcHRzLnJlc2V0ID0gMTsKCX0KCglyZWFkX2NhY2hlX3VubWVyZ2VkKCk7CgoJaWYgKHJlc2V0X3R5cGUgPT0gS0VFUCkgewoJCXN0cnVjdCBvYmplY3RfaWQgaGVhZF9vaWQ7CgkJaWYgKGdldF9vaWQoIkhFQUQiLCAmaGVhZF9vaWQpKQoJCQlyZXR1cm4gZXJyb3IoXygiWW91IGRvIG5vdCBoYXZlIGEgdmFsaWQgSEVBRC4iKSk7CgkJaWYgKCFmaWxsX3RyZWVfZGVzY3JpcHRvcihkZXNjICsgbnIsICZoZWFkX29pZCkpCgkJCXJldHVybiBlcnJvcihfKCJGYWlsZWQgdG8gZmluZCB0cmVlIG9mIEhFQUQuIikpOwoJCW5yKys7CgkJb3B0cy5mbiA9IHR3b3dheV9tZXJnZTsKCX0KCglpZiAoIWZpbGxfdHJlZV9kZXNjcmlwdG9yKGRlc2MgKyBuciwgb2lkKSkgewoJCWVycm9yKF8oIkZhaWxlZCB0byBmaW5kIHRyZWUgb2YgJXMuIiksIG9pZF90b19oZXgob2lkKSk7CgkJZ290byBvdXQ7Cgl9CglucisrOwoKCWlmICh1bnBhY2tfdHJlZXMobnIsIGRlc2MsICZvcHRzKSkKCQlnb3RvIG91dDsKCglpZiAocmVzZXRfdHlwZSA9PSBNSVhFRCB8fCByZXNldF90eXBlID09IEhBUkQpIHsKCQl0cmVlID0gcGFyc2VfdHJlZV9pbmRpcmVjdChvaWQpOwoJCXByaW1lX2NhY2hlX3RyZWUoJnRoZV9pbmRleCwgdHJlZSk7Cgl9CgoJcmV0ID0gMDsKCm91dDoKCWZvciAoaSA9IDA7IGkgPCBucjsgaSsrKQoJCWZyZWUoKHZvaWQgKilkZXNjW2ldLmJ1ZmZlcik7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgdm9pZCBwcmludF9uZXdfaGVhZF9saW5lKHN0cnVjdCBjb21taXQgKmNvbW1pdCkKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCglwcmludGYoXygiSEVBRCBpcyBub3cgYXQgJXMiKSwKCQlmaW5kX3VuaXF1ZV9hYmJyZXYoJmNvbW1pdC0+b2JqZWN0Lm9pZCwgREVGQVVMVF9BQkJSRVYpKTsKCglwcF9jb21taXRfZWFzeShDTUlUX0ZNVF9PTkVMSU5FLCBjb21taXQsICZidWYpOwoJaWYgKGJ1Zi5sZW4gPiAwKQoJCXByaW50ZigiICVzIiwgYnVmLmJ1Zik7CglwdXRjaGFyKCdcbicpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7Cn0KCnN0YXRpYyB2b2lkIHVwZGF0ZV9pbmRleF9mcm9tX2RpZmYoc3RydWN0IGRpZmZfcXVldWVfc3RydWN0ICpxLAoJCXN0cnVjdCBkaWZmX29wdGlvbnMgKm9wdCwgdm9pZCAqZGF0YSkKewoJaW50IGk7CglpbnQgaW50ZW50X3RvX2FkZCA9ICooaW50ICopZGF0YTsKCglmb3IgKGkgPSAwOyBpIDwgcS0+bnI7IGkrKykgewoJCXN0cnVjdCBkaWZmX2ZpbGVzcGVjICpvbmUgPSBxLT5xdWV1ZVtpXS0+b25lOwoJCWludCBpc19taXNzaW5nID0gIShvbmUtPm1vZGUgJiYgIWlzX251bGxfb2lkKCZvbmUtPm9pZCkpOwoJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2U7CgoJCWlmIChpc19taXNzaW5nICYmICFpbnRlbnRfdG9fYWRkKSB7CgkJCXJlbW92ZV9maWxlX2Zyb21fY2FjaGUob25lLT5wYXRoKTsKCQkJY29udGludWU7CgkJfQoKCQljZSA9IG1ha2VfY2FjaGVfZW50cnkob25lLT5tb2RlLCAmb25lLT5vaWQsIG9uZS0+cGF0aCwKCQkJCSAgICAgIDAsIDApOwoJCWlmICghY2UpCgkJCWRpZShfKCJtYWtlX2NhY2hlX2VudHJ5IGZhaWxlZCBmb3IgcGF0aCAnJXMnIiksCgkJCSAgICBvbmUtPnBhdGgpOwoJCWlmIChpc19taXNzaW5nKSB7CgkJCWNlLT5jZV9mbGFncyB8PSBDRV9JTlRFTlRfVE9fQUREOwoJCQlzZXRfb2JqZWN0X25hbWVfZm9yX2ludGVudF90b19hZGRfZW50cnkoY2UpOwoJCX0KCQlhZGRfY2FjaGVfZW50cnkoY2UsIEFERF9DQUNIRV9PS19UT19BREQgfCBBRERfQ0FDSEVfT0tfVE9fUkVQTEFDRSk7Cgl9Cn0KCnN0YXRpYyBpbnQgcmVhZF9mcm9tX3RyZWUoY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwYXRoc3BlYywKCQkJICBzdHJ1Y3Qgb2JqZWN0X2lkICp0cmVlX29pZCwKCQkJICBpbnQgaW50ZW50X3RvX2FkZCkKewoJc3RydWN0IGRpZmZfb3B0aW9ucyBvcHQ7CgoJbWVtc2V0KCZvcHQsIDAsIHNpemVvZihvcHQpKTsKCWNvcHlfcGF0aHNwZWMoJm9wdC5wYXRoc3BlYywgcGF0aHNwZWMpOwoJb3B0Lm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9DQUxMQkFDSzsKCW9wdC5mb3JtYXRfY2FsbGJhY2sgPSB1cGRhdGVfaW5kZXhfZnJvbV9kaWZmOwoJb3B0LmZvcm1hdF9jYWxsYmFja19kYXRhID0gJmludGVudF90b19hZGQ7CglvcHQuZmxhZ3Mub3ZlcnJpZGVfc3VibW9kdWxlX2NvbmZpZyA9IDE7CgoJaWYgKGRvX2RpZmZfY2FjaGUodHJlZV9vaWQsICZvcHQpKQoJCXJldHVybiAxOwoJZGlmZmNvcmVfc3RkKCZvcHQpOwoJZGlmZl9mbHVzaCgmb3B0KTsKCWNsZWFyX3BhdGhzcGVjKCZvcHQucGF0aHNwZWMpOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBzZXRfcmVmbG9nX21lc3NhZ2Uoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKmFjdGlvbiwKCQkJICAgICAgIGNvbnN0IGNoYXIgKnJldikKewoJY29uc3QgY2hhciAqcmxhID0gZ2V0ZW52KCJHSVRfUkVGTE9HX0FDVElPTiIpOwoKCXN0cmJ1Zl9yZXNldChzYik7CglpZiAocmxhKQoJCXN0cmJ1Zl9hZGRmKHNiLCAiJXM6ICVzIiwgcmxhLCBhY3Rpb24pOwoJZWxzZSBpZiAocmV2KQoJCXN0cmJ1Zl9hZGRmKHNiLCAicmVzZXQ6IG1vdmluZyB0byAlcyIsIHJldik7CgllbHNlCgkJc3RyYnVmX2FkZGYoc2IsICJyZXNldDogJXMiLCBhY3Rpb24pOwp9CgpzdGF0aWMgdm9pZCBkaWVfaWZfdW5tZXJnZWRfY2FjaGUoaW50IHJlc2V0X3R5cGUpCnsKCWlmIChpc19tZXJnZSgpIHx8IHVubWVyZ2VkX2NhY2hlKCkpCgkJZGllKF8oIkNhbm5vdCBkbyBhICVzIHJlc2V0IGluIHRoZSBtaWRkbGUgb2YgYSBtZXJnZS4iKSwKCQkgICAgXyhyZXNldF90eXBlX25hbWVzW3Jlc2V0X3R5cGVdKSk7Cgp9CgpzdGF0aWMgdm9pZCBwYXJzZV9hcmdzKHN0cnVjdCBwYXRoc3BlYyAqcGF0aHNwZWMsCgkJICAgICAgIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgsCgkJICAgICAgIGludCBwYXRjaF9tb2RlLAoJCSAgICAgICBjb25zdCBjaGFyICoqcmV2X3JldCkKewoJY29uc3QgY2hhciAqcmV2ID0gIkhFQUQiOwoJc3RydWN0IG9iamVjdF9pZCB1bnVzZWQ7CgkvKgoJICogUG9zc2libGUgYXJndW1lbnRzIGFyZToKCSAqCgkgKiBnaXQgcmVzZXQgWy1vcHRzXSBbPHJldj5dCgkgKiBnaXQgcmVzZXQgWy1vcHRzXSA8dHJlZT4gWzxwYXRocz4uLi5dCgkgKiBnaXQgcmVzZXQgWy1vcHRzXSA8dHJlZT4gLS0gWzxwYXRocz4uLi5dCgkgKiBnaXQgcmVzZXQgWy1vcHRzXSAtLSBbPHBhdGhzPi4uLl0KCSAqIGdpdCByZXNldCBbLW9wdHNdIDxwYXRocz4uLi4KCSAqCgkgKiBBdCB0aGlzIHBvaW50LCBhcmd2IHBvaW50cyBpbW1lZGlhdGVseSBhZnRlciBbLW9wdHNdLgoJICovCgoJaWYgKGFyZ3ZbMF0pIHsKCQlpZiAoIXN0cmNtcChhcmd2WzBdLCAiLS0iKSkgewoJCQlhcmd2Kys7IC8qIHJlc2V0IHRvIEhFQUQsIHBvc3NpYmx5IHdpdGggcGF0aHMgKi8KCQl9IGVsc2UgaWYgKGFyZ3ZbMV0gJiYgIXN0cmNtcChhcmd2WzFdLCAiLS0iKSkgewoJCQlyZXYgPSBhcmd2WzBdOwoJCQlhcmd2ICs9IDI7CgkJfQoJCS8qCgkJICogT3RoZXJ3aXNlLCBhcmd2WzBdIGNvdWxkIGJlIGVpdGhlciA8cmV2PiBvciA8cGF0aHM+IGFuZAoJCSAqIGhhcyB0byBiZSB1bmFtYmlndW91cy4gSWYgdGhlcmUgaXMgYSBzaW5nbGUgYXJndW1lbnQsIGl0CgkJICogY2FuIG5vdCBiZSBhIHRyZWUKCQkgKi8KCQllbHNlIGlmICgoIWFyZ3ZbMV0gJiYgIWdldF9vaWRfY29tbWl0dGlzaChhcmd2WzBdLCAmdW51c2VkKSkgfHwKCQkJIChhcmd2WzFdICYmICFnZXRfb2lkX3RyZWVpc2goYXJndlswXSwgJnVudXNlZCkpKSB7CgkJCS8qCgkJCSAqIE9rLCBhcmd2WzBdIGxvb2tzIGxpa2UgYSBjb21taXQvdHJlZTsgaXQgc2hvdWxkIG5vdAoJCQkgKiBiZSBhIGZpbGVuYW1lLgoJCQkgKi8KCQkJdmVyaWZ5X25vbl9maWxlbmFtZShwcmVmaXgsIGFyZ3ZbMF0pOwoJCQlyZXYgPSAqYXJndisrOwoJCX0gZWxzZSB7CgkJCS8qIE90aGVyd2lzZSB3ZSB0cmVhdCB0aGlzIGFzIGEgZmlsZW5hbWUgKi8KCQkJdmVyaWZ5X2ZpbGVuYW1lKHByZWZpeCwgYXJndlswXSwgMSk7CgkJfQoJfQoJKnJldl9yZXQgPSByZXY7CgoJaWYgKHJlYWRfY2FjaGUoKSA8IDApCgkJZGllKF8oImluZGV4IGZpbGUgY29ycnVwdCIpKTsKCglwYXJzZV9wYXRoc3BlYyhwYXRoc3BlYywgMCwKCQkgICAgICAgUEFUSFNQRUNfUFJFRkVSX0ZVTEwgfAoJCSAgICAgICAocGF0Y2hfbW9kZSA/IFBBVEhTUEVDX1BSRUZJWF9PUklHSU4gOiAwKSwKCQkgICAgICAgcHJlZml4LCBhcmd2KTsKfQoKc3RhdGljIGludCByZXNldF9yZWZzKGNvbnN0IGNoYXIgKnJldiwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglpbnQgdXBkYXRlX3JlZl9zdGF0dXM7CglzdHJ1Y3Qgc3RyYnVmIG1zZyA9IFNUUkJVRl9JTklUOwoJc3RydWN0IG9iamVjdF9pZCAqb3JpZyA9IE5VTEwsIG9pZF9vcmlnLAoJCSpvbGRfb3JpZyA9IE5VTEwsIG9pZF9vbGRfb3JpZzsKCglpZiAoIWdldF9vaWQoIk9SSUdfSEVBRCIsICZvaWRfb2xkX29yaWcpKQoJCW9sZF9vcmlnID0gJm9pZF9vbGRfb3JpZzsKCWlmICghZ2V0X29pZCgiSEVBRCIsICZvaWRfb3JpZykpIHsKCQlvcmlnID0gJm9pZF9vcmlnOwoJCXNldF9yZWZsb2dfbWVzc2FnZSgmbXNnLCAidXBkYXRpbmcgT1JJR19IRUFEIiwgTlVMTCk7CgkJdXBkYXRlX3JlZihtc2cuYnVmLCAiT1JJR19IRUFEIiwgb3JpZywgb2xkX29yaWcsIDAsCgkJCSAgIFVQREFURV9SRUZTX01TR19PTl9FUlIpOwoJfSBlbHNlIGlmIChvbGRfb3JpZykKCQlkZWxldGVfcmVmKE5VTEwsICJPUklHX0hFQUQiLCBvbGRfb3JpZywgMCk7CglzZXRfcmVmbG9nX21lc3NhZ2UoJm1zZywgInVwZGF0aW5nIEhFQUQiLCByZXYpOwoJdXBkYXRlX3JlZl9zdGF0dXMgPSB1cGRhdGVfcmVmKG1zZy5idWYsICJIRUFEIiwgb2lkLCBvcmlnLCAwLAoJCQkJICAgICAgIFVQREFURV9SRUZTX01TR19PTl9FUlIpOwoJc3RyYnVmX3JlbGVhc2UoJm1zZyk7CglyZXR1cm4gdXBkYXRlX3JlZl9zdGF0dXM7Cn0KCnN0YXRpYyBpbnQgZ2l0X3Jlc2V0X2NvbmZpZyhjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlLCB2b2lkICpjYikKewoJaWYgKCFzdHJjbXAodmFyLCAic3VibW9kdWxlLnJlY3Vyc2UiKSkKCQlyZXR1cm4gZ2l0X2RlZmF1bHRfc3VibW9kdWxlX2NvbmZpZyh2YXIsIHZhbHVlLCBjYik7CgoJcmV0dXJuIGdpdF9kZWZhdWx0X2NvbmZpZyh2YXIsIHZhbHVlLCBjYik7Cn0KCmludCBjbWRfcmVzZXQoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCWludCByZXNldF90eXBlID0gTk9ORSwgdXBkYXRlX3JlZl9zdGF0dXMgPSAwLCBxdWlldCA9IDA7CglpbnQgcGF0Y2hfbW9kZSA9IDAsIHVuYm9ybjsKCWNvbnN0IGNoYXIgKnJldjsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJc3RydWN0IHBhdGhzcGVjIHBhdGhzcGVjOwoJaW50IGludGVudF90b19hZGQgPSAwOwoJY29uc3Qgc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJT1BUX19RVUlFVCgmcXVpZXQsIE5fKCJiZSBxdWlldCwgb25seSByZXBvcnQgZXJyb3JzIikpLAoJCU9QVF9TRVRfSU5UKDAsICJtaXhlZCIsICZyZXNldF90eXBlLAoJCQkJCQlOXygicmVzZXQgSEVBRCBhbmQgaW5kZXgiKSwgTUlYRUQpLAoJCU9QVF9TRVRfSU5UKDAsICJzb2Z0IiwgJnJlc2V0X3R5cGUsIE5fKCJyZXNldCBvbmx5IEhFQUQiKSwgU09GVCksCgkJT1BUX1NFVF9JTlQoMCwgImhhcmQiLCAmcmVzZXRfdHlwZSwKCQkJCU5fKCJyZXNldCBIRUFELCBpbmRleCBhbmQgd29ya2luZyB0cmVlIiksIEhBUkQpLAoJCU9QVF9TRVRfSU5UKDAsICJtZXJnZSIsICZyZXNldF90eXBlLAoJCQkJTl8oInJlc2V0IEhFQUQsIGluZGV4IGFuZCB3b3JraW5nIHRyZWUiKSwgTUVSR0UpLAoJCU9QVF9TRVRfSU5UKDAsICJrZWVwIiwgJnJlc2V0X3R5cGUsCgkJCQlOXygicmVzZXQgSEVBRCBidXQga2VlcCBsb2NhbCBjaGFuZ2VzIiksIEtFRVApLAoJCXsgT1BUSU9OX0NBTExCQUNLLCAwLCAicmVjdXJzZS1zdWJtb2R1bGVzIiwgTlVMTCwKCQkJICAgICJyZXNldCIsICJjb250cm9sIHJlY3Vyc2l2ZSB1cGRhdGluZyBvZiBzdWJtb2R1bGVzIiwKCQkJICAgIFBBUlNFX09QVF9PUFRBUkcsIG9wdGlvbl9wYXJzZV9yZWN1cnNlX3N1Ym1vZHVsZXNfd29ya3RyZWVfdXBkYXRlciB9LAoJCU9QVF9CT09MKCdwJywgInBhdGNoIiwgJnBhdGNoX21vZGUsIE5fKCJzZWxlY3QgaHVua3MgaW50ZXJhY3RpdmVseSIpKSwKCQlPUFRfQk9PTCgnTicsICJpbnRlbnQtdG8tYWRkIiwgJmludGVudF90b19hZGQsCgkJCQlOXygicmVjb3JkIG9ubHkgdGhlIGZhY3QgdGhhdCByZW1vdmVkIHBhdGhzIHdpbGwgYmUgYWRkZWQgbGF0ZXIiKSksCgkJT1BUX0VORCgpCgl9OwoKCWdpdF9jb25maWcoZ2l0X3Jlc2V0X2NvbmZpZywgTlVMTCk7CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBvcHRpb25zLCBnaXRfcmVzZXRfdXNhZ2UsCgkJCQkJCVBBUlNFX09QVF9LRUVQX0RBU0hEQVNIKTsKCXBhcnNlX2FyZ3MoJnBhdGhzcGVjLCBhcmd2LCBwcmVmaXgsIHBhdGNoX21vZGUsICZyZXYpOwoKCXVuYm9ybiA9ICFzdHJjbXAocmV2LCAiSEVBRCIpICYmIGdldF9vaWQoIkhFQUQiLCAmb2lkKTsKCWlmICh1bmJvcm4pIHsKCQkvKiByZXNldCBvbiB1bmJvcm4gYnJhbmNoOiB0cmVhdCBhcyByZXNldCB0byBlbXB0eSB0cmVlICovCgkJb2lkY3B5KCZvaWQsIHRoZV9oYXNoX2FsZ28tPmVtcHR5X3RyZWUpOwoJfSBlbHNlIGlmICghcGF0aHNwZWMubnIpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgkJaWYgKGdldF9vaWRfY29tbWl0dGlzaChyZXYsICZvaWQpKQoJCQlkaWUoXygiRmFpbGVkIHRvIHJlc29sdmUgJyVzJyBhcyBhIHZhbGlkIHJldmlzaW9uLiIpLCByZXYpOwoJCWNvbW1pdCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlKCZvaWQpOwoJCWlmICghY29tbWl0KQoJCQlkaWUoXygiQ291bGQgbm90IHBhcnNlIG9iamVjdCAnJXMnLiIpLCByZXYpOwoJCW9pZGNweSgmb2lkLCAmY29tbWl0LT5vYmplY3Qub2lkKTsKCX0gZWxzZSB7CgkJc3RydWN0IHRyZWUgKnRyZWU7CgkJaWYgKGdldF9vaWRfdHJlZWlzaChyZXYsICZvaWQpKQoJCQlkaWUoXygiRmFpbGVkIHRvIHJlc29sdmUgJyVzJyBhcyBhIHZhbGlkIHRyZWUuIiksIHJldik7CgkJdHJlZSA9IHBhcnNlX3RyZWVfaW5kaXJlY3QoJm9pZCk7CgkJaWYgKCF0cmVlKQoJCQlkaWUoXygiQ291bGQgbm90IHBhcnNlIG9iamVjdCAnJXMnLiIpLCByZXYpOwoJCW9pZGNweSgmb2lkLCAmdHJlZS0+b2JqZWN0Lm9pZCk7Cgl9CgoJaWYgKHBhdGNoX21vZGUpIHsKCQlpZiAocmVzZXRfdHlwZSAhPSBOT05FKQoJCQlkaWUoXygiLS1wYXRjaCBpcyBpbmNvbXBhdGlibGUgd2l0aCAtLXtoYXJkLG1peGVkLHNvZnR9IikpOwoJCXJldHVybiBydW5fYWRkX2ludGVyYWN0aXZlKHJldiwgIi0tcGF0Y2g9cmVzZXQiLCAmcGF0aHNwZWMpOwoJfQoKCS8qIGdpdCByZXNldCB0cmVlIFstLV0gcGF0aHMuLi4gY2FuIGJlIHVzZWQgdG8KCSAqIGxvYWQgY2hvc2VuIHBhdGhzIGZyb20gdGhlIHRyZWUgaW50byB0aGUgaW5kZXggd2l0aG91dAoJICogYWZmZWN0aW5nIHRoZSB3b3JraW5nIHRyZWUgbm9yIEhFQUQuICovCglpZiAocGF0aHNwZWMubnIpIHsKCQlpZiAocmVzZXRfdHlwZSA9PSBNSVhFRCkKCQkJd2FybmluZyhfKCItLW1peGVkIHdpdGggcGF0aHMgaXMgZGVwcmVjYXRlZDsgdXNlICdnaXQgcmVzZXQgLS0gPHBhdGhzPicgaW5zdGVhZC4iKSk7CgkJZWxzZSBpZiAocmVzZXRfdHlwZSAhPSBOT05FKQoJCQlkaWUoXygiQ2Fubm90IGRvICVzIHJlc2V0IHdpdGggcGF0aHMuIiksCgkJCQkJXyhyZXNldF90eXBlX25hbWVzW3Jlc2V0X3R5cGVdKSk7Cgl9CglpZiAocmVzZXRfdHlwZSA9PSBOT05FKQoJCXJlc2V0X3R5cGUgPSBNSVhFRDsgLyogYnkgZGVmYXVsdCAqLwoKCWlmIChyZXNldF90eXBlICE9IFNPRlQgJiYgKHJlc2V0X3R5cGUgIT0gTUlYRUQgfHwgZ2V0X2dpdF93b3JrX3RyZWUoKSkpCgkJc2V0dXBfd29ya190cmVlKCk7CgoJaWYgKHJlc2V0X3R5cGUgPT0gTUlYRUQgJiYgaXNfYmFyZV9yZXBvc2l0b3J5KCkpCgkJZGllKF8oIiVzIHJlc2V0IGlzIG5vdCBhbGxvd2VkIGluIGEgYmFyZSByZXBvc2l0b3J5IiksCgkJICAgIF8ocmVzZXRfdHlwZV9uYW1lc1tyZXNldF90eXBlXSkpOwoKCWlmIChpbnRlbnRfdG9fYWRkICYmIHJlc2V0X3R5cGUgIT0gTUlYRUQpCgkJZGllKF8oIi1OIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCAtLW1peGVkIikpOwoKCS8qIFNvZnQgcmVzZXQgZG9lcyBub3QgdG91Y2ggdGhlIGluZGV4IGZpbGUgbm9yIHRoZSB3b3JraW5nIHRyZWUKCSAqIGF0IGFsbCwgYnV0IHJlcXVpcmVzIHRoZW0gaW4gYSBnb29kIG9yZGVyLiAgT3RoZXIgcmVzZXRzIHJlc2V0CgkgKiB0aGUgaW5kZXggZmlsZSB0byB0aGUgdHJlZSBvYmplY3Qgd2UgYXJlIHN3aXRjaGluZyB0by4gKi8KCWlmIChyZXNldF90eXBlID09IFNPRlQgfHwgcmVzZXRfdHlwZSA9PSBLRUVQKQoJCWRpZV9pZl91bm1lcmdlZF9jYWNoZShyZXNldF90eXBlKTsKCglpZiAocmVzZXRfdHlwZSAhPSBTT0ZUKSB7CgkJc3RydWN0IGxvY2tfZmlsZSBsb2NrID0gTE9DS19JTklUOwoJCWhvbGRfbG9ja2VkX2luZGV4KCZsb2NrLCBMT0NLX0RJRV9PTl9FUlJPUik7CgkJaWYgKHJlc2V0X3R5cGUgPT0gTUlYRUQpIHsKCQkJaW50IGZsYWdzID0gcXVpZXQgPyBSRUZSRVNIX1FVSUVUIDogUkVGUkVTSF9JTl9QT1JDRUxBSU47CgkJCWlmIChyZWFkX2Zyb21fdHJlZSgmcGF0aHNwZWMsICZvaWQsIGludGVudF90b19hZGQpKQoJCQkJcmV0dXJuIDE7CgkJCWlmIChnZXRfZ2l0X3dvcmtfdHJlZSgpKQoJCQkJcmVmcmVzaF9pbmRleCgmdGhlX2luZGV4LCBmbGFncywgTlVMTCwgTlVMTCwKCQkJCQkgICAgICBfKCJVbnN0YWdlZCBjaGFuZ2VzIGFmdGVyIHJlc2V0OiIpKTsKCQl9IGVsc2UgewoJCQlpbnQgZXJyID0gcmVzZXRfaW5kZXgoJm9pZCwgcmVzZXRfdHlwZSwgcXVpZXQpOwoJCQlpZiAocmVzZXRfdHlwZSA9PSBLRUVQICYmICFlcnIpCgkJCQllcnIgPSByZXNldF9pbmRleCgmb2lkLCBNSVhFRCwgcXVpZXQpOwoJCQlpZiAoZXJyKQoJCQkJZGllKF8oIkNvdWxkIG5vdCByZXNldCBpbmRleCBmaWxlIHRvIHJldmlzaW9uICclcycuIiksIHJldik7CgkJfQoKCQlpZiAod3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZsb2NrLCBDT01NSVRfTE9DSykpCgkJCWRpZShfKCJDb3VsZCBub3Qgd3JpdGUgbmV3IGluZGV4IGZpbGUuIikpOwoJfQoKCWlmICghcGF0aHNwZWMubnIgJiYgIXVuYm9ybikgewoJCS8qIEFueSByZXNldHMgd2l0aG91dCBwYXRocyB1cGRhdGUgSEVBRCB0byB0aGUgaGVhZCBiZWluZwoJCSAqIHN3aXRjaGVkIHRvLCBzYXZpbmcgdGhlIHByZXZpb3VzIGhlYWQgaW4gT1JJR19IRUFEIGJlZm9yZS4gKi8KCQl1cGRhdGVfcmVmX3N0YXR1cyA9IHJlc2V0X3JlZnMocmV2LCAmb2lkKTsKCgkJaWYgKHJlc2V0X3R5cGUgPT0gSEFSRCAmJiAhdXBkYXRlX3JlZl9zdGF0dXMgJiYgIXF1aWV0KQoJCQlwcmludF9uZXdfaGVhZF9saW5lKGxvb2t1cF9jb21taXRfcmVmZXJlbmNlKCZvaWQpKTsKCX0KCWlmICghcGF0aHNwZWMubnIpCgkJcmVtb3ZlX2JyYW5jaF9zdGF0ZSgpOwoKCXJldHVybiB1cGRhdGVfcmVmX3N0YXR1czsKfQo=",
    "text": "/*\n * \"git reset\" builtin command\n *\n * Copyright (c) 2007 Carlos Rica\n *\n * Based on git-reset.sh, which is\n *\n * Copyright (c) 2005, 2006 Linus Torvalds and Junio C Hamano\n */\n#include \"builtin.h\"\n#include \"config.h\"\n#include \"lockfile.h\"\n#include \"tag.h\"\n#include \"object.h\"\n#include \"pretty.h\"\n#include \"run-command.h\"\n#include \"refs.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"tree.h\"\n#include \"branch.h\"\n#include \"parse-options.h\"\n#include \"unpack-trees.h\"\n#include \"cache-tree.h\"\n#include \"submodule.h\"\n#include \"submodule-config.h\"\n\nstatic const char * const git_reset_usage[] = {\n\tN_(\"git reset [--mixed | --soft | --hard | --merge | --keep] [-q] [<commit>]\"),\n\tN_(\"git reset [-q] [<tree-ish>] [--] <paths>...\"),\n\tN_(\"git reset --patch [<tree-ish>] [--] [<paths>...]\"),\n\tNULL\n};\n\nenum reset_type { MIXED, SOFT, HARD, MERGE, KEEP, NONE };\nstatic const char *reset_type_names[] = {\n\tN_(\"mixed\"), N_(\"soft\"), N_(\"hard\"), N_(\"merge\"), N_(\"keep\"), NULL\n};\n\nstatic inline int is_merge(void)\n{\n\treturn !access(git_path_merge_head(), F_OK);\n}\n\nstatic int reset_index(const struct object_id *oid, int reset_type, int quiet)\n{\n\tint i, nr = 0;\n\tstruct tree_desc desc[2];\n\tstruct tree *tree;\n\tstruct unpack_trees_options opts;\n\tint ret = -1;\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.head_idx = 1;\n\topts.src_index = &the_index;\n\topts.dst_index = &the_index;\n\topts.fn = oneway_merge;\n\topts.merge = 1;\n\tif (!quiet)\n\t\topts.verbose_update = 1;\n\tswitch (reset_type) {\n\tcase KEEP:\n\tcase MERGE:\n\t\topts.update = 1;\n\t\tbreak;\n\tcase HARD:\n\t\topts.update = 1;\n\t\t/* fallthrough */\n\tdefault:\n\t\topts.reset = 1;\n\t}\n\n\tread_cache_unmerged();\n\n\tif (reset_type == KEEP) {\n\t\tstruct object_id head_oid;\n\t\tif (get_oid(\"HEAD\", &head_oid))\n\t\t\treturn error(_(\"You do not have a valid HEAD.\"));\n\t\tif (!fill_tree_descriptor(desc + nr, &head_oid))\n\t\t\treturn error(_(\"Failed to find tree of HEAD.\"));\n\t\tnr++;\n\t\topts.fn = twoway_merge;\n\t}\n\n\tif (!fill_tree_descriptor(desc + nr, oid)) {\n\t\terror(_(\"Failed to find tree of %s.\"), oid_to_hex(oid));\n\t\tgoto out;\n\t}\n\tnr++;\n\n\tif (unpack_trees(nr, desc, &opts))\n\t\tgoto out;\n\n\tif (reset_type == MIXED || reset_type == HARD) {\n\t\ttree = parse_tree_indirect(oid);\n\t\tprime_cache_tree(&the_index, tree);\n\t}\n\n\tret = 0;\n\nout:\n\tfor (i = 0; i < nr; i++)\n\t\tfree((void *)desc[i].buffer);\n\treturn ret;\n}\n\nstatic void print_new_head_line(struct commit *commit)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tprintf(_(\"HEAD is now at %s\"),\n\t\tfind_unique_abbrev(&commit->object.oid, DEFAULT_ABBREV));\n\n\tpp_commit_easy(CMIT_FMT_ONELINE, commit, &buf);\n\tif (buf.len > 0)\n\t\tprintf(\" %s\", buf.buf);\n\tputchar('\\n');\n\tstrbuf_release(&buf);\n}\n\nstatic void update_index_from_diff(struct diff_queue_struct *q,\n\t\tstruct diff_options *opt, void *data)\n{\n\tint i;\n\tint intent_to_add = *(int *)data;\n\n\tfor (i = 0; i < q->nr; i++) {\n\t\tstruct diff_filespec *one = q->queue[i]->one;\n\t\tint is_missing = !(one->mode && !is_null_oid(&one->oid));\n\t\tstruct cache_entry *ce;\n\n\t\tif (is_missing && !intent_to_add) {\n\t\t\tremove_file_from_cache(one->path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tce = make_cache_entry(one->mode, &one->oid, one->path,\n\t\t\t\t      0, 0);\n\t\tif (!ce)\n\t\t\tdie(_(\"make_cache_entry failed for path '%s'\"),\n\t\t\t    one->path);\n\t\tif (is_missing) {\n\t\t\tce->ce_flags |= CE_INTENT_TO_ADD;\n\t\t\tset_object_name_for_intent_to_add_entry(ce);\n\t\t}\n\t\tadd_cache_entry(ce, ADD_CACHE_OK_TO_ADD | ADD_CACHE_OK_TO_REPLACE);\n\t}\n}\n\nstatic int read_from_tree(const struct pathspec *pathspec,\n\t\t\t  struct object_id *tree_oid,\n\t\t\t  int intent_to_add)\n{\n\tstruct diff_options opt;\n\n\tmemset(&opt, 0, sizeof(opt));\n\tcopy_pathspec(&opt.pathspec, pathspec);\n\topt.output_format = DIFF_FORMAT_CALLBACK;\n\topt.format_callback = update_index_from_diff;\n\topt.format_callback_data = &intent_to_add;\n\topt.flags.override_submodule_config = 1;\n\n\tif (do_diff_cache(tree_oid, &opt))\n\t\treturn 1;\n\tdiffcore_std(&opt);\n\tdiff_flush(&opt);\n\tclear_pathspec(&opt.pathspec);\n\n\treturn 0;\n}\n\nstatic void set_reflog_message(struct strbuf *sb, const char *action,\n\t\t\t       const char *rev)\n{\n\tconst char *rla = getenv(\"GIT_REFLOG_ACTION\");\n\n\tstrbuf_reset(sb);\n\tif (rla)\n\t\tstrbuf_addf(sb, \"%s: %s\", rla, action);\n\telse if (rev)\n\t\tstrbuf_addf(sb, \"reset: moving to %s\", rev);\n\telse\n\t\tstrbuf_addf(sb, \"reset: %s\", action);\n}\n\nstatic void die_if_unmerged_cache(int reset_type)\n{\n\tif (is_merge() || unmerged_cache())\n\t\tdie(_(\"Cannot do a %s reset in the middle of a merge.\"),\n\t\t    _(reset_type_names[reset_type]));\n\n}\n\nstatic void parse_args(struct pathspec *pathspec,\n\t\t       const char **argv, const char *prefix,\n\t\t       int patch_mode,\n\t\t       const char **rev_ret)\n{\n\tconst char *rev = \"HEAD\";\n\tstruct object_id unused;\n\t/*\n\t * Possible arguments are:\n\t *\n\t * git reset [-opts] [<rev>]\n\t * git reset [-opts] <tree> [<paths>...]\n\t * git reset [-opts] <tree> -- [<paths>...]\n\t * git reset [-opts] -- [<paths>...]\n\t * git reset [-opts] <paths>...\n\t *\n\t * At this point, argv points immediately after [-opts].\n\t */\n\n\tif (argv[0]) {\n\t\tif (!strcmp(argv[0], \"--\")) {\n\t\t\targv++; /* reset to HEAD, possibly with paths */\n\t\t} else if (argv[1] && !strcmp(argv[1], \"--\")) {\n\t\t\trev = argv[0];\n\t\t\targv += 2;\n\t\t}\n\t\t/*\n\t\t * Otherwise, argv[0] could be either <rev> or <paths> and\n\t\t * has to be unambiguous. If there is a single argument, it\n\t\t * can not be a tree\n\t\t */\n\t\telse if ((!argv[1] && !get_oid_committish(argv[0], &unused)) ||\n\t\t\t (argv[1] && !get_oid_treeish(argv[0], &unused))) {\n\t\t\t/*\n\t\t\t * Ok, argv[0] looks like a commit/tree; it should not\n\t\t\t * be a filename.\n\t\t\t */\n\t\t\tverify_non_filename(prefix, argv[0]);\n\t\t\trev = *argv++;\n\t\t} else {\n\t\t\t/* Otherwise we treat this as a filename */\n\t\t\tverify_filename(prefix, argv[0], 1);\n\t\t}\n\t}\n\t*rev_ret = rev;\n\n\tif (read_cache() < 0)\n\t\tdie(_(\"index file corrupt\"));\n\n\tparse_pathspec(pathspec, 0,\n\t\t       PATHSPEC_PREFER_FULL |\n\t\t       (patch_mode ? PATHSPEC_PREFIX_ORIGIN : 0),\n\t\t       prefix, argv);\n}\n\nstatic int reset_refs(const char *rev, const struct object_id *oid)\n{\n\tint update_ref_status;\n\tstruct strbuf msg = STRBUF_INIT;\n\tstruct object_id *orig = NULL, oid_orig,\n\t\t*old_orig = NULL, oid_old_orig;\n\n\tif (!get_oid(\"ORIG_HEAD\", &oid_old_orig))\n\t\told_orig = &oid_old_orig;\n\tif (!get_oid(\"HEAD\", &oid_orig)) {\n\t\torig = &oid_orig;\n\t\tset_reflog_message(&msg, \"updating ORIG_HEAD\", NULL);\n\t\tupdate_ref(msg.buf, \"ORIG_HEAD\", orig, old_orig, 0,\n\t\t\t   UPDATE_REFS_MSG_ON_ERR);\n\t} else if (old_orig)\n\t\tdelete_ref(NULL, \"ORIG_HEAD\", old_orig, 0);\n\tset_reflog_message(&msg, \"updating HEAD\", rev);\n\tupdate_ref_status = update_ref(msg.buf, \"HEAD\", oid, orig, 0,\n\t\t\t\t       UPDATE_REFS_MSG_ON_ERR);\n\tstrbuf_release(&msg);\n\treturn update_ref_status;\n}\n\nstatic int git_reset_config(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(var, \"submodule.recurse\"))\n\t\treturn git_default_submodule_config(var, value, cb);\n\n\treturn git_default_config(var, value, cb);\n}\n\nint cmd_reset(int argc, const char **argv, const char *prefix)\n{\n\tint reset_type = NONE, update_ref_status = 0, quiet = 0;\n\tint patch_mode = 0, unborn;\n\tconst char *rev;\n\tstruct object_id oid;\n\tstruct pathspec pathspec;\n\tint intent_to_add = 0;\n\tconst struct option options[] = {\n\t\tOPT__QUIET(&quiet, N_(\"be quiet, only report errors\")),\n\t\tOPT_SET_INT(0, \"mixed\", &reset_type,\n\t\t\t\t\t\tN_(\"reset HEAD and index\"), MIXED),\n\t\tOPT_SET_INT(0, \"soft\", &reset_type, N_(\"reset only HEAD\"), SOFT),\n\t\tOPT_SET_INT(0, \"hard\", &reset_type,\n\t\t\t\tN_(\"reset HEAD, index and working tree\"), HARD),\n\t\tOPT_SET_INT(0, \"merge\", &reset_type,\n\t\t\t\tN_(\"reset HEAD, index and working tree\"), MERGE),\n\t\tOPT_SET_INT(0, \"keep\", &reset_type,\n\t\t\t\tN_(\"reset HEAD but keep local changes\"), KEEP),\n\t\t{ OPTION_CALLBACK, 0, \"recurse-submodules\", NULL,\n\t\t\t    \"reset\", \"control recursive updating of submodules\",\n\t\t\t    PARSE_OPT_OPTARG, option_parse_recurse_submodules_worktree_updater },\n\t\tOPT_BOOL('p', \"patch\", &patch_mode, N_(\"select hunks interactively\")),\n\t\tOPT_BOOL('N', \"intent-to-add\", &intent_to_add,\n\t\t\t\tN_(\"record only the fact that removed paths will be added later\")),\n\t\tOPT_END()\n\t};\n\n\tgit_config(git_reset_config, NULL);\n\n\targc = parse_options(argc, argv, prefix, options, git_reset_usage,\n\t\t\t\t\t\tPARSE_OPT_KEEP_DASHDASH);\n\tparse_args(&pathspec, argv, prefix, patch_mode, &rev);\n\n\tunborn = !strcmp(rev, \"HEAD\") && get_oid(\"HEAD\", &oid);\n\tif (unborn) {\n\t\t/* reset on unborn branch: treat as reset to empty tree */\n\t\toidcpy(&oid, the_hash_algo->empty_tree);\n\t} else if (!pathspec.nr) {\n\t\tstruct commit *commit;\n\t\tif (get_oid_committish(rev, &oid))\n\t\t\tdie(_(\"Failed to resolve '%s' as a valid revision.\"), rev);\n\t\tcommit = lookup_commit_reference(&oid);\n\t\tif (!commit)\n\t\t\tdie(_(\"Could not parse object '%s'.\"), rev);\n\t\toidcpy(&oid, &commit->object.oid);\n\t} else {\n\t\tstruct tree *tree;\n\t\tif (get_oid_treeish(rev, &oid))\n\t\t\tdie(_(\"Failed to resolve '%s' as a valid tree.\"), rev);\n\t\ttree = parse_tree_indirect(&oid);\n\t\tif (!tree)\n\t\t\tdie(_(\"Could not parse object '%s'.\"), rev);\n\t\toidcpy(&oid, &tree->object.oid);\n\t}\n\n\tif (patch_mode) {\n\t\tif (reset_type != NONE)\n\t\t\tdie(_(\"--patch is incompatible with --{hard,mixed,soft}\"));\n\t\treturn run_add_interactive(rev, \"--patch=reset\", &pathspec);\n\t}\n\n\t/* git reset tree [--] paths... can be used to\n\t * load chosen paths from the tree into the index without\n\t * affecting the working tree nor HEAD. */\n\tif (pathspec.nr) {\n\t\tif (reset_type == MIXED)\n\t\t\twarning(_(\"--mixed with paths is deprecated; use 'git reset -- <paths>' instead.\"));\n\t\telse if (reset_type != NONE)\n\t\t\tdie(_(\"Cannot do %s reset with paths.\"),\n\t\t\t\t\t_(reset_type_names[reset_type]));\n\t}\n\tif (reset_type == NONE)\n\t\treset_type = MIXED; /* by default */\n\n\tif (reset_type != SOFT && (reset_type != MIXED || get_git_work_tree()))\n\t\tsetup_work_tree();\n\n\tif (reset_type == MIXED && is_bare_repository())\n\t\tdie(_(\"%s reset is not allowed in a bare repository\"),\n\t\t    _(reset_type_names[reset_type]));\n\n\tif (intent_to_add && reset_type != MIXED)\n\t\tdie(_(\"-N can only be used with --mixed\"));\n\n\t/* Soft reset does not touch the index file nor the working tree\n\t * at all, but requires them in a good order.  Other resets reset\n\t * the index file to the tree object we are switching to. */\n\tif (reset_type == SOFT || reset_type == KEEP)\n\t\tdie_if_unmerged_cache(reset_type);\n\n\tif (reset_type != SOFT) {\n\t\tstruct lock_file lock = LOCK_INIT;\n\t\thold_locked_index(&lock, LOCK_DIE_ON_ERROR);\n\t\tif (reset_type == MIXED) {\n\t\t\tint flags = quiet ? REFRESH_QUIET : REFRESH_IN_PORCELAIN;\n\t\t\tif (read_from_tree(&pathspec, &oid, intent_to_add))\n\t\t\t\treturn 1;\n\t\t\tif (get_git_work_tree())\n\t\t\t\trefresh_index(&the_index, flags, NULL, NULL,\n\t\t\t\t\t      _(\"Unstaged changes after reset:\"));\n\t\t} else {\n\t\t\tint err = reset_index(&oid, reset_type, quiet);\n\t\t\tif (reset_type == KEEP && !err)\n\t\t\t\terr = reset_index(&oid, MIXED, quiet);\n\t\t\tif (err)\n\t\t\t\tdie(_(\"Could not reset index file to revision '%s'.\"), rev);\n\t\t}\n\n\t\tif (write_locked_index(&the_index, &lock, COMMIT_LOCK))\n\t\t\tdie(_(\"Could not write new index file.\"));\n\t}\n\n\tif (!pathspec.nr && !unborn) {\n\t\t/* Any resets without paths update HEAD to the head being\n\t\t * switched to, saving the previous head in ORIG_HEAD before. */\n\t\tupdate_ref_status = reset_refs(rev, &oid);\n\n\t\tif (reset_type == HARD && !update_ref_status && !quiet)\n\t\t\tprint_new_head_line(lookup_commit_reference(&oid));\n\t}\n\tif (!pathspec.nr)\n\t\tremove_branch_state();\n\n\treturn update_ref_status;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00109b041f9130dbd8d0e908032bfb60c3e1552b",
  "sha1_ok": true,
  "size": 11285
}
