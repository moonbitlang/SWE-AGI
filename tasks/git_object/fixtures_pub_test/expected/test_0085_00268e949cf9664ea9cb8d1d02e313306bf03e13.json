{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IG5vdGVzIgogKgogKiBDb3B5cmlnaHQgKGMpIDIwMTAgSm9oYW4gSGVybGFuZCA8am9oYW5AaGVybGFuZC5uZXQ+CiAqCiAqIEJhc2VkIG9uIGdpdC1ub3Rlcy5zaCBieSBKb2hhbm5lcyBTY2hpbmRlbGluLAogKiBhbmQgYnVpbHRpbi90YWcuYyBieSBLcmlzdGlhbiBIw7hnc2JlcmcgYW5kIENhcmxvcyBSaWNhLgogKi8KCiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAiYWxsb2MuaCIKI2luY2x1ZGUgImNvbmZpZy5oIgojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAiZ2V0dGV4dC5oIgojaW5jbHVkZSAiaGV4LmgiCiNpbmNsdWRlICJub3Rlcy5oIgojaW5jbHVkZSAib2JqZWN0LXN0b3JlLmgiCiNpbmNsdWRlICJyZXBvc2l0b3J5LmgiCiNpbmNsdWRlICJibG9iLmgiCiNpbmNsdWRlICJwcmV0dHkuaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgImV4ZWMtY21kLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgIm5vdGVzLW1lcmdlLmgiCiNpbmNsdWRlICJub3Rlcy11dGlscy5oIgojaW5jbHVkZSAid29ya3RyZWUuaCIKI2luY2x1ZGUgIndyaXRlLW9yLWRpZS5oIgoKc3RhdGljIGNvbnN0IGNoYXIgKnNlcGFyYXRvciA9ICJcbiI7CnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgZ2l0X25vdGVzX3VzYWdlW10gPSB7CglOXygiZ2l0IG5vdGVzIFstLXJlZiA8bm90ZXMtcmVmPl0gW2xpc3QgWzxvYmplY3Q+XV0iKSwKCU5fKCJnaXQgbm90ZXMgWy0tcmVmIDxub3Rlcy1yZWY+XSBhZGQgWy1mXSBbLS1hbGxvdy1lbXB0eV0gWy0tW25vLV1zZXBhcmF0b3J8LS1zZXBhcmF0b3I9PHBhcmFncmFwaC1icmVhaz5dIFstLVtuby1dc3RyaXBzcGFjZV0gWy1tIDxtc2c+IHwgLUYgPGZpbGU+IHwgKC1jIHwgLUMpIDxvYmplY3Q+XSBbPG9iamVjdD5dIiksCglOXygiZ2l0IG5vdGVzIFstLXJlZiA8bm90ZXMtcmVmPl0gY29weSBbLWZdIDxmcm9tLW9iamVjdD4gPHRvLW9iamVjdD4iKSwKCU5fKCJnaXQgbm90ZXMgWy0tcmVmIDxub3Rlcy1yZWY+XSBhcHBlbmQgWy0tYWxsb3ctZW1wdHldIFstLVtuby1dc2VwYXJhdG9yfC0tc2VwYXJhdG9yPTxwYXJhZ3JhcGgtYnJlYWs+XSBbLS1bbm8tXXN0cmlwc3BhY2VdIFstbSA8bXNnPiB8IC1GIDxmaWxlPiB8ICgtYyB8IC1DKSA8b2JqZWN0Pl0gWzxvYmplY3Q+XSIpLAoJTl8oImdpdCBub3RlcyBbLS1yZWYgPG5vdGVzLXJlZj5dIGVkaXQgWy0tYWxsb3ctZW1wdHldIFs8b2JqZWN0Pl0iKSwKCU5fKCJnaXQgbm90ZXMgWy0tcmVmIDxub3Rlcy1yZWY+XSBzaG93IFs8b2JqZWN0Pl0iKSwKCU5fKCJnaXQgbm90ZXMgWy0tcmVmIDxub3Rlcy1yZWY+XSBtZXJnZSBbLXYgfCAtcV0gWy1zIDxzdHJhdGVneT5dIDxub3Rlcy1yZWY+IiksCgkiZ2l0IG5vdGVzIG1lcmdlIC0tY29tbWl0IFstdiB8IC1xXSIsCgkiZ2l0IG5vdGVzIG1lcmdlIC0tYWJvcnQgWy12IHwgLXFdIiwKCU5fKCJnaXQgbm90ZXMgWy0tcmVmIDxub3Rlcy1yZWY+XSByZW1vdmUgWzxvYmplY3Q+Li4uXSIpLAoJTl8oImdpdCBub3RlcyBbLS1yZWYgPG5vdGVzLXJlZj5dIHBydW5lIFstbl0gWy12XSIpLAoJTl8oImdpdCBub3RlcyBbLS1yZWYgPG5vdGVzLXJlZj5dIGdldC1yZWYiKSwKCU5VTEwKfTsKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgZ2l0X25vdGVzX2xpc3RfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgbm90ZXMgW2xpc3QgWzxvYmplY3Q+XV0iKSwKCU5VTEwKfTsKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgZ2l0X25vdGVzX2FkZF91c2FnZVtdID0gewoJTl8oImdpdCBub3RlcyBhZGQgWzxvcHRpb25zPl0gWzxvYmplY3Q+XSIpLAoJTlVMTAp9OwoKc3RhdGljIGNvbnN0IGNoYXIgKiBjb25zdCBnaXRfbm90ZXNfY29weV91c2FnZVtdID0gewoJTl8oImdpdCBub3RlcyBjb3B5IFs8b3B0aW9ucz5dIDxmcm9tLW9iamVjdD4gPHRvLW9iamVjdD4iKSwKCU5fKCJnaXQgbm90ZXMgY29weSAtLXN0ZGluIFs8ZnJvbS1vYmplY3Q+IDx0by1vYmplY3Q+XS4uLiIpLAoJTlVMTAp9OwoKc3RhdGljIGNvbnN0IGNoYXIgKiBjb25zdCBnaXRfbm90ZXNfYXBwZW5kX3VzYWdlW10gPSB7CglOXygiZ2l0IG5vdGVzIGFwcGVuZCBbPG9wdGlvbnM+XSBbPG9iamVjdD5dIiksCglOVUxMCn07CgpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGdpdF9ub3Rlc19lZGl0X3VzYWdlW10gPSB7CglOXygiZ2l0IG5vdGVzIGVkaXQgWzxvYmplY3Q+XSIpLAoJTlVMTAp9OwoKc3RhdGljIGNvbnN0IGNoYXIgKiBjb25zdCBnaXRfbm90ZXNfc2hvd191c2FnZVtdID0gewoJTl8oImdpdCBub3RlcyBzaG93IFs8b2JqZWN0Pl0iKSwKCU5VTEwKfTsKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgZ2l0X25vdGVzX21lcmdlX3VzYWdlW10gPSB7CglOXygiZ2l0IG5vdGVzIG1lcmdlIFs8b3B0aW9ucz5dIDxub3Rlcy1yZWY+IiksCglOXygiZ2l0IG5vdGVzIG1lcmdlIC0tY29tbWl0IFs8b3B0aW9ucz5dIiksCglOXygiZ2l0IG5vdGVzIG1lcmdlIC0tYWJvcnQgWzxvcHRpb25zPl0iKSwKCU5VTEwKfTsKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgZ2l0X25vdGVzX3JlbW92ZV91c2FnZVtdID0gewoJTl8oImdpdCBub3RlcyByZW1vdmUgWzxvYmplY3Q+XSIpLAoJTlVMTAp9OwoKc3RhdGljIGNvbnN0IGNoYXIgKiBjb25zdCBnaXRfbm90ZXNfcHJ1bmVfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgbm90ZXMgcHJ1bmUgWzxvcHRpb25zPl0iKSwKCU5VTEwKfTsKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgZ2l0X25vdGVzX2dldF9yZWZfdXNhZ2VbXSA9IHsKCSJnaXQgbm90ZXMgZ2V0LXJlZiIsCglOVUxMCn07CgpzdGF0aWMgY29uc3QgY2hhciBub3RlX3RlbXBsYXRlW10gPQoJTl8oIldyaXRlL2VkaXQgdGhlIG5vdGVzIGZvciB0aGUgZm9sbG93aW5nIG9iamVjdDoiKTsKCmVudW0gbm90ZXNfc3RyaXBzcGFjZSB7CglVTlNQRUNJRklFRCA9IC0xLAoJTk9fU1RSSVBTUEFDRSA9IDAsCglTVFJJUFNQQUNFID0gMSwKfTsKCnN0cnVjdCBub3RlX21zZyB7CgllbnVtIG5vdGVzX3N0cmlwc3BhY2Ugc3RyaXBzcGFjZTsKCXN0cnVjdCBzdHJidWYgYnVmOwp9OwoKc3RydWN0IG5vdGVfZGF0YSB7CglpbnQgZ2l2ZW47CglpbnQgdXNlX2VkaXRvcjsKCWludCBzdHJpcHNwYWNlOwoJY2hhciAqZWRpdF9wYXRoOwoJc3RydWN0IHN0cmJ1ZiBidWY7CglzdHJ1Y3Qgbm90ZV9tc2cgKiptZXNzYWdlczsKCXNpemVfdCBtc2dfbnI7CglzaXplX3QgbXNnX2FsbG9jOwp9OwoKc3RhdGljIHZvaWQgZnJlZV9ub3RlX2RhdGEoc3RydWN0IG5vdGVfZGF0YSAqZCkKewoJaWYgKGQtPmVkaXRfcGF0aCkgewoJCXVubGlua19vcl93YXJuKGQtPmVkaXRfcGF0aCk7CgkJZnJlZShkLT5lZGl0X3BhdGgpOwoJfQoJc3RyYnVmX3JlbGVhc2UoJmQtPmJ1Zik7CgoJd2hpbGUgKGQtPm1zZ19uci0tKSB7CgkJc3RyYnVmX3JlbGVhc2UoJmQtPm1lc3NhZ2VzW2QtPm1zZ19ucl0tPmJ1Zik7CgkJZnJlZShkLT5tZXNzYWdlc1tkLT5tc2dfbnJdKTsKCX0KCWZyZWUoZC0+bWVzc2FnZXMpOwp9CgpzdGF0aWMgaW50IGxpc3RfZWFjaF9ub3RlKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9iamVjdF9vaWQsCgkJCSAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqbm90ZV9vaWQsCgkJCSAgY2hhciAqbm90ZV9wYXRoIFVOVVNFRCwKCQkJICB2b2lkICpjYl9kYXRhIFVOVVNFRCkKewoJcHJpbnRmKCIlcyAlc1xuIiwgb2lkX3RvX2hleChub3RlX29pZCksIG9pZF90b19oZXgob2JqZWN0X29pZCkpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGNvcHlfb2JqX3RvX2ZkKGludCBmZCwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7Cgl1bnNpZ25lZCBsb25nIHNpemU7CgllbnVtIG9iamVjdF90eXBlIHR5cGU7CgljaGFyICpidWYgPSByZXBvX3JlYWRfb2JqZWN0X2ZpbGUodGhlX3JlcG9zaXRvcnksIG9pZCwgJnR5cGUsICZzaXplKTsKCWlmIChidWYpIHsKCQlpZiAoc2l6ZSkKCQkJd3JpdGVfb3JfZGllKGZkLCBidWYsIHNpemUpOwoJCWZyZWUoYnVmKTsKCX0KfQoKc3RhdGljIHZvaWQgd3JpdGVfY29tbWVudGVkX29iamVjdChpbnQgZmQsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9iamVjdCkKewoJc3RydWN0IGNoaWxkX3Byb2Nlc3Mgc2hvdyA9IENISUxEX1BST0NFU1NfSU5JVDsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGNidWYgPSBTVFJCVUZfSU5JVDsKCgkvKiBJbnZva2UgImdpdCBzaG93IC0tc3RhdCAtLW5vLW5vdGVzICRvYmplY3QiICovCglzdHJ2ZWNfcHVzaGwoJnNob3cuYXJncywgInNob3ciLCAiLS1zdGF0IiwgIi0tbm8tbm90ZXMiLAoJCSAgICAgb2lkX3RvX2hleChvYmplY3QpLCBOVUxMKTsKCXNob3cubm9fc3RkaW4gPSAxOwoJc2hvdy5vdXQgPSAtMTsKCXNob3cuZXJyID0gMDsKCXNob3cuZ2l0X2NtZCA9IDE7CglpZiAoc3RhcnRfY29tbWFuZCgmc2hvdykpCgkJZGllKF8oInVuYWJsZSB0byBzdGFydCAnc2hvdycgZm9yIG9iamVjdCAnJXMnIiksCgkJICAgIG9pZF90b19oZXgob2JqZWN0KSk7CgoJaWYgKHN0cmJ1Zl9yZWFkKCZidWYsIHNob3cub3V0LCAwKSA8IDApCgkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkICdzaG93JyBvdXRwdXQiKSk7CglzdHJidWZfYWRkX2NvbW1lbnRlZF9saW5lcygmY2J1ZiwgYnVmLmJ1ZiwgYnVmLmxlbik7Cgl3cml0ZV9vcl9kaWUoZmQsIGNidWYuYnVmLCBjYnVmLmxlbik7CgoJc3RyYnVmX3JlbGVhc2UoJmNidWYpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CgoJaWYgKGZpbmlzaF9jb21tYW5kKCZzaG93KSkKCQlkaWUoXygiZmFpbGVkIHRvIGZpbmlzaCAnc2hvdycgZm9yIG9iamVjdCAnJXMnIiksCgkJICAgIG9pZF90b19oZXgob2JqZWN0KSk7Cn0KCnN0YXRpYyB2b2lkIHByZXBhcmVfbm90ZV9kYXRhKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9iamVjdCwgc3RydWN0IG5vdGVfZGF0YSAqZCwKCQljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvbGRfbm90ZSkKewoJaWYgKGQtPnVzZV9lZGl0b3IgfHwgIWQtPmdpdmVuKSB7CgkJaW50IGZkOwoJCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJCS8qIHdyaXRlIHRoZSB0ZW1wbGF0ZSBtZXNzYWdlIGJlZm9yZSBlZGl0aW5nOiAqLwoJCWQtPmVkaXRfcGF0aCA9IGdpdF9wYXRoZHVwKCJOT1RFU19FRElUTVNHIik7CgkJZmQgPSB4b3BlbihkLT5lZGl0X3BhdGgsIE9fQ1JFQVQgfCBPX1RSVU5DIHwgT19XUk9OTFksIDA2MDApOwoKCQlpZiAoZC0+Z2l2ZW4pCgkJCXdyaXRlX29yX2RpZShmZCwgZC0+YnVmLmJ1ZiwgZC0+YnVmLmxlbik7CgkJZWxzZSBpZiAob2xkX25vdGUpCgkJCWNvcHlfb2JqX3RvX2ZkKGZkLCBvbGRfbm90ZSk7CgoJCXN0cmJ1Zl9hZGRjaCgmYnVmLCAnXG4nKTsKCQlzdHJidWZfYWRkX2NvbW1lbnRlZF9saW5lcygmYnVmLCAiXG4iLCBzdHJsZW4oIlxuIikpOwoJCXN0cmJ1Zl9hZGRfY29tbWVudGVkX2xpbmVzKCZidWYsIF8obm90ZV90ZW1wbGF0ZSksIHN0cmxlbihfKG5vdGVfdGVtcGxhdGUpKSk7CgkJc3RyYnVmX2FkZF9jb21tZW50ZWRfbGluZXMoJmJ1ZiwgIlxuIiwgc3RybGVuKCJcbiIpKTsKCQl3cml0ZV9vcl9kaWUoZmQsIGJ1Zi5idWYsIGJ1Zi5sZW4pOwoKCQl3cml0ZV9jb21tZW50ZWRfb2JqZWN0KGZkLCBvYmplY3QpOwoKCQljbG9zZShmZCk7CgkJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CgkJc3RyYnVmX3Jlc2V0KCZkLT5idWYpOwoKCQlpZiAobGF1bmNoX2VkaXRvcihkLT5lZGl0X3BhdGgsICZkLT5idWYsIE5VTEwpKSB7CgkJCWRpZShfKCJwbGVhc2Ugc3VwcGx5IHRoZSBub3RlIGNvbnRlbnRzIHVzaW5nIGVpdGhlciAtbSBvciAtRiBvcHRpb24iKSk7CgkJfQoJCWlmIChkLT5zdHJpcHNwYWNlKQoJCQlzdHJidWZfc3RyaXBzcGFjZSgmZC0+YnVmLCAxKTsKCX0KfQoKc3RhdGljIHZvaWQgd3JpdGVfbm90ZV9kYXRhKHN0cnVjdCBub3RlX2RhdGEgKmQsIHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJaWYgKHdyaXRlX29iamVjdF9maWxlKGQtPmJ1Zi5idWYsIGQtPmJ1Zi5sZW4sIE9CSl9CTE9CLCBvaWQpKSB7CgkJaW50IHN0YXR1cyA9IGRpZV9tZXNzYWdlKF8oInVuYWJsZSB0byB3cml0ZSBub3RlIG9iamVjdCIpKTsKCgkJaWYgKGQtPmVkaXRfcGF0aCkKCQkJZGllX21lc3NhZ2UoXygidGhlIG5vdGUgY29udGVudHMgaGF2ZSBiZWVuIGxlZnQgaW4gJXMiKSwKCQkJCSAgICBkLT5lZGl0X3BhdGgpOwoJCWV4aXQoc3RhdHVzKTsKCX0KfQoKc3RhdGljIHZvaWQgYXBwZW5kX3NlcGFyYXRvcihzdHJ1Y3Qgc3RyYnVmICptZXNzYWdlKQp7CglzaXplX3Qgc2VwX2xlbiA9IDA7CgoJaWYgKCFzZXBhcmF0b3IpCgkJcmV0dXJuOwoJZWxzZSBpZiAoKHNlcF9sZW4gPSBzdHJsZW4oc2VwYXJhdG9yKSkgJiYgc2VwYXJhdG9yW3NlcF9sZW4gLSAxXSA9PSAnXG4nKQoJCXN0cmJ1Zl9hZGRzdHIobWVzc2FnZSwgc2VwYXJhdG9yKTsKCWVsc2UKCQlzdHJidWZfYWRkZihtZXNzYWdlLCAiJXMlcyIsIHNlcGFyYXRvciwgIlxuIik7Cn0KCnN0YXRpYyB2b2lkIGNvbmNhdF9tZXNzYWdlcyhzdHJ1Y3Qgbm90ZV9kYXRhICpkKQp7CglzdHJ1Y3Qgc3RyYnVmIG1zZyA9IFNUUkJVRl9JTklUOwoJc2l6ZV90IGk7CgoJZm9yIChpID0gMDsgaSA8IGQtPm1zZ19uciA7IGkrKykgewoJCWlmIChkLT5idWYubGVuKQoJCQlhcHBlbmRfc2VwYXJhdG9yKCZkLT5idWYpOwoJCXN0cmJ1Zl9hZGQoJm1zZywgZC0+bWVzc2FnZXNbaV0tPmJ1Zi5idWYsIGQtPm1lc3NhZ2VzW2ldLT5idWYubGVuKTsKCQlzdHJidWZfYWRkYnVmKCZkLT5idWYsICZtc2cpOwoJCWlmICgoZC0+c3RyaXBzcGFjZSA9PSBVTlNQRUNJRklFRCAmJgoJCSAgICAgZC0+bWVzc2FnZXNbaV0tPnN0cmlwc3BhY2UgPT0gU1RSSVBTUEFDRSkgfHwKCQkgICAgZC0+c3RyaXBzcGFjZSA9PSBTVFJJUFNQQUNFKQoJCQlzdHJidWZfc3RyaXBzcGFjZSgmZC0+YnVmLCAwKTsKCQlzdHJidWZfcmVzZXQoJm1zZyk7Cgl9CglzdHJidWZfcmVsZWFzZSgmbXNnKTsKfQoKc3RhdGljIGludCBwYXJzZV9tc2dfYXJnKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCXN0cnVjdCBub3RlX2RhdGEgKmQgPSBvcHQtPnZhbHVlOwoJc3RydWN0IG5vdGVfbXNnICptc2cgPSB4bWFsbG9jKHNpemVvZigqbXNnKSk7CgoJQlVHX09OX09QVF9ORUcodW5zZXQpOwoKCXN0cmJ1Zl9pbml0KCZtc2ctPmJ1Ziwgc3RybGVuKGFyZykpOwoJc3RyYnVmX2FkZHN0cigmbXNnLT5idWYsIGFyZyk7CglBTExPQ19HUk9XX0JZKGQtPm1lc3NhZ2VzLCBkLT5tc2dfbnIsIDEsIGQtPm1zZ19hbGxvYyk7CglkLT5tZXNzYWdlc1tkLT5tc2dfbnIgLSAxXSA9IG1zZzsKCW1zZy0+c3RyaXBzcGFjZSA9IFNUUklQU1BBQ0U7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBwYXJzZV9maWxlX2FyZyhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglzdHJ1Y3Qgbm90ZV9kYXRhICpkID0gb3B0LT52YWx1ZTsKCXN0cnVjdCBub3RlX21zZyAqbXNnID0geG1hbGxvYyhzaXplb2YoKm1zZykpOwoKCUJVR19PTl9PUFRfTkVHKHVuc2V0KTsKCglzdHJidWZfaW5pdCgmbXNnLT5idWYgLCAwKTsKCWlmICghc3RyY21wKGFyZywgIi0iKSkgewoJCWlmIChzdHJidWZfcmVhZCgmbXNnLT5idWYsIDAsIDEwMjQpIDwgMCkKCQkJZGllX2Vycm5vKF8oImNhbm5vdCByZWFkICclcyciKSwgYXJnKTsKCX0gZWxzZSBpZiAoc3RyYnVmX3JlYWRfZmlsZSgmbXNnLT5idWYsIGFyZywgMTAyNCkgPCAwKQoJCWRpZV9lcnJubyhfKCJjb3VsZCBub3Qgb3BlbiBvciByZWFkICclcyciKSwgYXJnKTsKCglBTExPQ19HUk9XX0JZKGQtPm1lc3NhZ2VzLCBkLT5tc2dfbnIsIDEsIGQtPm1zZ19hbGxvYyk7CglkLT5tZXNzYWdlc1tkLT5tc2dfbnIgLSAxXSA9IG1zZzsKCW1zZy0+c3RyaXBzcGFjZSA9IFNUUklQU1BBQ0U7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBwYXJzZV9yZXVzZV9hcmcoY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJc3RydWN0IG5vdGVfZGF0YSAqZCA9IG9wdC0+dmFsdWU7CglzdHJ1Y3Qgbm90ZV9tc2cgKm1zZyA9IHhtYWxsb2Moc2l6ZW9mKCptc2cpKTsKCWNoYXIgKnZhbHVlOwoJc3RydWN0IG9iamVjdF9pZCBvYmplY3Q7CgllbnVtIG9iamVjdF90eXBlIHR5cGU7Cgl1bnNpZ25lZCBsb25nIGxlbjsKCglCVUdfT05fT1BUX05FRyh1bnNldCk7CgoJc3RyYnVmX2luaXQoJm1zZy0+YnVmLCAwKTsKCWlmIChyZXBvX2dldF9vaWQodGhlX3JlcG9zaXRvcnksIGFyZywgJm9iamVjdCkpCgkJZGllKF8oImZhaWxlZCB0byByZXNvbHZlICclcycgYXMgYSB2YWxpZCByZWYuIiksIGFyZyk7CglpZiAoISh2YWx1ZSA9IHJlcG9fcmVhZF9vYmplY3RfZmlsZSh0aGVfcmVwb3NpdG9yeSwgJm9iamVjdCwgJnR5cGUsICZsZW4pKSkKCQlkaWUoXygiZmFpbGVkIHRvIHJlYWQgb2JqZWN0ICclcycuIiksIGFyZyk7CglpZiAodHlwZSAhPSBPQkpfQkxPQikgewoJCXN0cmJ1Zl9yZWxlYXNlKCZtc2ctPmJ1Zik7CgkJZnJlZSh2YWx1ZSk7CgkJZnJlZShtc2cpOwoJCWRpZShfKCJjYW5ub3QgcmVhZCBub3RlIGRhdGEgZnJvbSBub24tYmxvYiBvYmplY3QgJyVzJy4iKSwgYXJnKTsKCX0KCglzdHJidWZfYWRkKCZtc2ctPmJ1ZiwgdmFsdWUsIGxlbik7CglmcmVlKHZhbHVlKTsKCgltc2ctPmJ1Zi5sZW4gPSBsZW47CglBTExPQ19HUk9XX0JZKGQtPm1lc3NhZ2VzLCBkLT5tc2dfbnIsIDEsIGQtPm1zZ19hbGxvYyk7CglkLT5tZXNzYWdlc1tkLT5tc2dfbnIgLSAxXSA9IG1zZzsKCW1zZy0+c3RyaXBzcGFjZSA9IE5PX1NUUklQU1BBQ0U7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBwYXJzZV9yZWVkaXRfYXJnKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCXN0cnVjdCBub3RlX2RhdGEgKmQgPSBvcHQtPnZhbHVlOwoJQlVHX09OX09QVF9ORUcodW5zZXQpOwoJZC0+dXNlX2VkaXRvciA9IDE7CglyZXR1cm4gcGFyc2VfcmV1c2VfYXJnKG9wdCwgYXJnLCB1bnNldCk7Cn0KCnN0YXRpYyBpbnQgcGFyc2Vfc2VwYXJhdG9yX2FyZyhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywKCQkJICAgICAgIGludCB1bnNldCkKewoJaWYgKHVuc2V0KQoJCSooY29uc3QgY2hhciAqKilvcHQtPnZhbHVlID0gTlVMTDsKCWVsc2UKCQkqKGNvbnN0IGNoYXIgKiopb3B0LT52YWx1ZSA9IGFyZyA/IGFyZyA6ICJcbiI7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBub3Rlc19jb3B5X2Zyb21fc3RkaW4oaW50IGZvcmNlLCBjb25zdCBjaGFyICpyZXdyaXRlX2NtZCkKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBub3Rlc19yZXdyaXRlX2NmZyAqYyA9IE5VTEw7CglzdHJ1Y3Qgbm90ZXNfdHJlZSAqdCA9IE5VTEw7CglpbnQgcmV0ID0gMDsKCWNvbnN0IGNoYXIgKm1zZyA9ICJOb3RlcyBhZGRlZCBieSAnZ2l0IG5vdGVzIGNvcHknIjsKCglpZiAocmV3cml0ZV9jbWQpIHsKCQljID0gaW5pdF9jb3B5X25vdGVzX2Zvcl9yZXdyaXRlKHJld3JpdGVfY21kKTsKCQlpZiAoIWMpCgkJCXJldHVybiAwOwoJfSBlbHNlIHsKCQlpbml0X25vdGVzKE5VTEwsIE5VTEwsIE5VTEwsIE5PVEVTX0lOSVRfV1JJVEFCTEUpOwoJCXQgPSAmZGVmYXVsdF9ub3Rlc190cmVlOwoJfQoKCXdoaWxlIChzdHJidWZfZ2V0bGluZV9sZigmYnVmLCBzdGRpbikgIT0gRU9GKSB7CgkJc3RydWN0IG9iamVjdF9pZCBmcm9tX29iaiwgdG9fb2JqOwoJCXN0cnVjdCBzdHJidWYgKipzcGxpdDsKCQlpbnQgZXJyOwoKCQlzcGxpdCA9IHN0cmJ1Zl9zcGxpdCgmYnVmLCAnICcpOwoJCWlmICghc3BsaXRbMF0gfHwgIXNwbGl0WzFdKQoJCQlkaWUoXygibWFsZm9ybWVkIGlucHV0IGxpbmU6ICclcycuIiksIGJ1Zi5idWYpOwoJCXN0cmJ1Zl9ydHJpbShzcGxpdFswXSk7CgkJc3RyYnVmX3J0cmltKHNwbGl0WzFdKTsKCQlpZiAocmVwb19nZXRfb2lkKHRoZV9yZXBvc2l0b3J5LCBzcGxpdFswXS0+YnVmLCAmZnJvbV9vYmopKQoJCQlkaWUoXygiZmFpbGVkIHRvIHJlc29sdmUgJyVzJyBhcyBhIHZhbGlkIHJlZi4iKSwgc3BsaXRbMF0tPmJ1Zik7CgkJaWYgKHJlcG9fZ2V0X29pZCh0aGVfcmVwb3NpdG9yeSwgc3BsaXRbMV0tPmJ1ZiwgJnRvX29iaikpCgkJCWRpZShfKCJmYWlsZWQgdG8gcmVzb2x2ZSAnJXMnIGFzIGEgdmFsaWQgcmVmLiIpLCBzcGxpdFsxXS0+YnVmKTsKCgkJaWYgKHJld3JpdGVfY21kKQoJCQllcnIgPSBjb3B5X25vdGVfZm9yX3Jld3JpdGUoYywgJmZyb21fb2JqLCAmdG9fb2JqKTsKCQllbHNlCgkJCWVyciA9IGNvcHlfbm90ZSh0LCAmZnJvbV9vYmosICZ0b19vYmosIGZvcmNlLAoJCQkJCWNvbWJpbmVfbm90ZXNfb3ZlcndyaXRlKTsKCgkJaWYgKGVycikgewoJCQllcnJvcihfKCJmYWlsZWQgdG8gY29weSBub3RlcyBmcm9tICclcycgdG8gJyVzJyIpLAoJCQkgICAgICBzcGxpdFswXS0+YnVmLCBzcGxpdFsxXS0+YnVmKTsKCQkJcmV0ID0gMTsKCQl9CgoJCXN0cmJ1Zl9saXN0X2ZyZWUoc3BsaXQpOwoJfQoKCWlmICghcmV3cml0ZV9jbWQpIHsKCQljb21taXRfbm90ZXModGhlX3JlcG9zaXRvcnksIHQsIG1zZyk7CgkJZnJlZV9ub3Rlcyh0KTsKCX0gZWxzZSB7CgkJZmluaXNoX2NvcHlfbm90ZXNfZm9yX3Jld3JpdGUodGhlX3JlcG9zaXRvcnksIGMsIG1zZyk7Cgl9CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBzdHJ1Y3Qgbm90ZXNfdHJlZSAqaW5pdF9ub3Rlc19jaGVjayhjb25zdCBjaGFyICpzdWJjb21tYW5kLAoJCQkJCSAgIGludCBmbGFncykKewoJc3RydWN0IG5vdGVzX3RyZWUgKnQ7Cgljb25zdCBjaGFyICpyZWY7Cglpbml0X25vdGVzKE5VTEwsIE5VTEwsIE5VTEwsIGZsYWdzKTsKCXQgPSAmZGVmYXVsdF9ub3Rlc190cmVlOwoKCXJlZiA9IChmbGFncyAmIE5PVEVTX0lOSVRfV1JJVEFCTEUpID8gdC0+dXBkYXRlX3JlZiA6IHQtPnJlZjsKCWlmICghc3RhcnRzX3dpdGgocmVmLCAicmVmcy9ub3Rlcy8iKSkKCQkvKgoJCSAqIFRSQU5TTEFUT1JTOiB0aGUgZmlyc3QgJXMgd2lsbCBiZSByZXBsYWNlZCBieSBhIGdpdAoJCSAqIG5vdGVzIGNvbW1hbmQ6ICdhZGQnLCAnbWVyZ2UnLCAncmVtb3ZlJywgZXRjLgoJCSAqLwoJCWRpZShfKCJyZWZ1c2luZyB0byAlcyBub3RlcyBpbiAlcyAob3V0c2lkZSBvZiByZWZzL25vdGVzLykiKSwKCQkgICAgc3ViY29tbWFuZCwgcmVmKTsKCXJldHVybiB0Owp9CgpzdGF0aWMgaW50IGxpc3QoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0cnVjdCBub3Rlc190cmVlICp0OwoJc3RydWN0IG9iamVjdF9pZCBvYmplY3Q7Cgljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpub3RlOwoJaW50IHJldHZhbCA9IC0xOwoJc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJT1BUX0VORCgpCgl9OwoKCWlmIChhcmdjKQoJCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgb3B0aW9ucywKCQkJCSAgICAgZ2l0X25vdGVzX2xpc3RfdXNhZ2UsIDApOwoKCWlmICgxIDwgYXJnYykgewoJCWVycm9yKF8oInRvbyBtYW55IGFyZ3VtZW50cyIpKTsKCQl1c2FnZV93aXRoX29wdGlvbnMoZ2l0X25vdGVzX2xpc3RfdXNhZ2UsIG9wdGlvbnMpOwoJfQoKCXQgPSBpbml0X25vdGVzX2NoZWNrKCJsaXN0IiwgMCk7CglpZiAoYXJnYykgewoJCWlmIChyZXBvX2dldF9vaWQodGhlX3JlcG9zaXRvcnksIGFyZ3ZbMF0sICZvYmplY3QpKQoJCQlkaWUoXygiZmFpbGVkIHRvIHJlc29sdmUgJyVzJyBhcyBhIHZhbGlkIHJlZi4iKSwgYXJndlswXSk7CgkJbm90ZSA9IGdldF9ub3RlKHQsICZvYmplY3QpOwoJCWlmIChub3RlKSB7CgkJCXB1dHMob2lkX3RvX2hleChub3RlKSk7CgkJCXJldHZhbCA9IDA7CgkJfSBlbHNlCgkJCXJldHZhbCA9IGVycm9yKF8oIm5vIG5vdGUgZm91bmQgZm9yIG9iamVjdCAlcy4iKSwKCQkJCSAgICAgICBvaWRfdG9faGV4KCZvYmplY3QpKTsKCX0gZWxzZQoJCXJldHZhbCA9IGZvcl9lYWNoX25vdGUodCwgMCwgbGlzdF9lYWNoX25vdGUsIE5VTEwpOwoKCWZyZWVfbm90ZXModCk7CglyZXR1cm4gcmV0dmFsOwp9CgpzdGF0aWMgaW50IGFwcGVuZF9lZGl0KGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KTsKCnN0YXRpYyBpbnQgYWRkKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglpbnQgZm9yY2UgPSAwLCBhbGxvd19lbXB0eSA9IDA7Cgljb25zdCBjaGFyICpvYmplY3RfcmVmOwoJc3RydWN0IG5vdGVzX3RyZWUgKnQ7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9iamVjdCwgbmV3X25vdGU7Cgljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpub3RlOwoJc3RydWN0IG5vdGVfZGF0YSBkID0geyAuYnVmID0gU1RSQlVGX0lOSVQsIC5zdHJpcHNwYWNlID0gVU5TUEVDSUZJRUQgfTsKCglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfQ0FMTEJBQ0tfRignbScsICJtZXNzYWdlIiwgJmQsIE5fKCJtZXNzYWdlIiksCgkJCU5fKCJub3RlIGNvbnRlbnRzIGFzIGEgc3RyaW5nIiksIFBBUlNFX09QVF9OT05FRywKCQkJcGFyc2VfbXNnX2FyZyksCgkJT1BUX0NBTExCQUNLX0YoJ0YnLCAiZmlsZSIsICZkLCBOXygiZmlsZSIpLAoJCQlOXygibm90ZSBjb250ZW50cyBpbiBhIGZpbGUiKSwgUEFSU0VfT1BUX05PTkVHLAoJCQlwYXJzZV9maWxlX2FyZyksCgkJT1BUX0NBTExCQUNLX0YoJ2MnLCAicmVlZGl0LW1lc3NhZ2UiLCAmZCwgTl8oIm9iamVjdCIpLAoJCQlOXygicmV1c2UgYW5kIGVkaXQgc3BlY2lmaWVkIG5vdGUgb2JqZWN0IiksIFBBUlNFX09QVF9OT05FRywKCQkJcGFyc2VfcmVlZGl0X2FyZyksCgkJT1BUX0NBTExCQUNLX0YoJ0MnLCAicmV1c2UtbWVzc2FnZSIsICZkLCBOXygib2JqZWN0IiksCgkJCU5fKCJyZXVzZSBzcGVjaWZpZWQgbm90ZSBvYmplY3QiKSwgUEFSU0VfT1BUX05PTkVHLAoJCQlwYXJzZV9yZXVzZV9hcmcpLAoJCU9QVF9CT09MKDAsICJhbGxvdy1lbXB0eSIsICZhbGxvd19lbXB0eSwKCQkJTl8oImFsbG93IHN0b3JpbmcgZW1wdHkgbm90ZSIpKSwKCQlPUFRfX0ZPUkNFKCZmb3JjZSwgTl8oInJlcGxhY2UgZXhpc3Rpbmcgbm90ZXMiKSwgUEFSU0VfT1BUX05PQ09NUExFVEUpLAoJCU9QVF9DQUxMQkFDS19GKDAsICJzZXBhcmF0b3IiLCAmc2VwYXJhdG9yLAoJCQlOXygiPHBhcmFncmFwaC1icmVhaz4iKSwKCQkJTl8oImluc2VydCA8cGFyYWdyYXBoLWJyZWFrPiBiZXR3ZWVuIHBhcmFncmFwaHMiKSwKCQkJUEFSU0VfT1BUX09QVEFSRywgcGFyc2Vfc2VwYXJhdG9yX2FyZyksCgkJT1BUX0JPT0woMCwgInN0cmlwc3BhY2UiLCAmZC5zdHJpcHNwYWNlLAoJCQlOXygicmVtb3ZlIHVubmVjZXNzYXJ5IHdoaXRlc3BhY2UiKSksCgkJT1BUX0VORCgpCgl9OwoKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgb3B0aW9ucywgZ2l0X25vdGVzX2FkZF91c2FnZSwKCQkJICAgICBQQVJTRV9PUFRfS0VFUF9BUkdWMCk7CgoJaWYgKDIgPCBhcmdjKSB7CgkJZXJyb3IoXygidG9vIG1hbnkgYXJndW1lbnRzIikpOwoJCXVzYWdlX3dpdGhfb3B0aW9ucyhnaXRfbm90ZXNfYWRkX3VzYWdlLCBvcHRpb25zKTsKCX0KCglpZiAoZC5tc2dfbnIpCgkJY29uY2F0X21lc3NhZ2VzKCZkKTsKCWQuZ2l2ZW4gPSAhIWQuYnVmLmxlbjsKCglvYmplY3RfcmVmID0gYXJnYyA+IDEgPyBhcmd2WzFdIDogIkhFQUQiOwoKCWlmIChyZXBvX2dldF9vaWQodGhlX3JlcG9zaXRvcnksIG9iamVjdF9yZWYsICZvYmplY3QpKQoJCWRpZShfKCJmYWlsZWQgdG8gcmVzb2x2ZSAnJXMnIGFzIGEgdmFsaWQgcmVmLiIpLCBvYmplY3RfcmVmKTsKCgl0ID0gaW5pdF9ub3Rlc19jaGVjaygiYWRkIiwgTk9URVNfSU5JVF9XUklUQUJMRSk7Cglub3RlID0gZ2V0X25vdGUodCwgJm9iamVjdCk7CgoJaWYgKG5vdGUpIHsKCQlpZiAoIWZvcmNlKSB7CgkJCWZyZWVfbm90ZXModCk7CgkJCWlmIChkLmdpdmVuKSB7CgkJCQlmcmVlX25vdGVfZGF0YSgmZCk7CgkJCQlyZXR1cm4gZXJyb3IoXygiQ2Fubm90IGFkZCBub3Rlcy4gIgoJCQkJCSJGb3VuZCBleGlzdGluZyBub3RlcyBmb3Igb2JqZWN0ICVzLiAiCgkJCQkJIlVzZSAnLWYnIHRvIG92ZXJ3cml0ZSBleGlzdGluZyBub3RlcyIpLAoJCQkJCW9pZF90b19oZXgoJm9iamVjdCkpOwoJCQl9CgkJCS8qCgkJCSAqIFJlZGlyZWN0IHRvICJlZGl0IiBzdWJjb21tYW5kLgoJCQkgKgoJCQkgKiBXZSBvbmx5IGVuZCB1cCBoZXJlIGlmIG5vbmUgb2YgLW0vLUYvLWMvLUMgb3IgLWYgYXJlCgkJCSAqIGdpdmVuLiBUaGUgb3JpZ2luYWwgYXJncyBhcmUgdGhlcmVmb3JlIHN0aWxsIGluCgkJCSAqIGFyZ3ZbMC0xXS4KCQkJICovCgkJCWFyZ3ZbMF0gPSAiZWRpdCI7CgkJCXJldHVybiBhcHBlbmRfZWRpdChhcmdjLCBhcmd2LCBwcmVmaXgpOwoJCX0KCQlmcHJpbnRmKHN0ZGVyciwgXygiT3ZlcndyaXRpbmcgZXhpc3Rpbmcgbm90ZXMgZm9yIG9iamVjdCAlc1xuIiksCgkJCW9pZF90b19oZXgoJm9iamVjdCkpOwoJfQoKCXByZXBhcmVfbm90ZV9kYXRhKCZvYmplY3QsICZkLCBub3RlKTsKCWlmIChkLmJ1Zi5sZW4gfHwgYWxsb3dfZW1wdHkpIHsKCQl3cml0ZV9ub3RlX2RhdGEoJmQsICZuZXdfbm90ZSk7CgkJaWYgKGFkZF9ub3RlKHQsICZvYmplY3QsICZuZXdfbm90ZSwgY29tYmluZV9ub3Rlc19vdmVyd3JpdGUpKQoJCQlCVUcoImNvbWJpbmVfbm90ZXNfb3ZlcndyaXRlIGZhaWxlZCIpOwoJCWNvbW1pdF9ub3Rlcyh0aGVfcmVwb3NpdG9yeSwgdCwKCQkJICAgICAiTm90ZXMgYWRkZWQgYnkgJ2dpdCBub3RlcyBhZGQnIik7Cgl9IGVsc2UgewoJCWZwcmludGYoc3RkZXJyLCBfKCJSZW1vdmluZyBub3RlIGZvciBvYmplY3QgJXNcbiIpLAoJCQlvaWRfdG9faGV4KCZvYmplY3QpKTsKCQlyZW1vdmVfbm90ZSh0LCBvYmplY3QuaGFzaCk7CgkJY29tbWl0X25vdGVzKHRoZV9yZXBvc2l0b3J5LCB0LAoJCQkgICAgICJOb3RlcyByZW1vdmVkIGJ5ICdnaXQgbm90ZXMgYWRkJyIpOwoJfQoKCWZyZWVfbm90ZV9kYXRhKCZkKTsKCWZyZWVfbm90ZXModCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBjb3B5KGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglpbnQgcmV0dmFsID0gMCwgZm9yY2UgPSAwLCBmcm9tX3N0ZGluID0gMDsKCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKmZyb21fbm90ZSwgKm5vdGU7Cgljb25zdCBjaGFyICpvYmplY3RfcmVmOwoJc3RydWN0IG9iamVjdF9pZCBvYmplY3QsIGZyb21fb2JqOwoJc3RydWN0IG5vdGVzX3RyZWUgKnQ7Cgljb25zdCBjaGFyICpyZXdyaXRlX2NtZCA9IE5VTEw7CglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfX0ZPUkNFKCZmb3JjZSwgTl8oInJlcGxhY2UgZXhpc3Rpbmcgbm90ZXMiKSwgUEFSU0VfT1BUX05PQ09NUExFVEUpLAoJCU9QVF9CT09MKDAsICJzdGRpbiIsICZmcm9tX3N0ZGluLCBOXygicmVhZCBvYmplY3RzIGZyb20gc3RkaW4iKSksCgkJT1BUX1NUUklORygwLCAiZm9yLXJld3JpdGUiLCAmcmV3cml0ZV9jbWQsIE5fKCJjb21tYW5kIiksCgkJCSAgIE5fKCJsb2FkIHJld3JpdGluZyBjb25maWcgZm9yIDxjb21tYW5kPiAoaW1wbGllcyAiCgkJCSAgICAgICItLXN0ZGluKSIpKSwKCQlPUFRfRU5EKCkKCX07CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBvcHRpb25zLCBnaXRfbm90ZXNfY29weV91c2FnZSwKCQkJICAgICAwKTsKCglpZiAoZnJvbV9zdGRpbiB8fCByZXdyaXRlX2NtZCkgewoJCWlmIChhcmdjKSB7CgkJCWVycm9yKF8oInRvbyBtYW55IGFyZ3VtZW50cyIpKTsKCQkJdXNhZ2Vfd2l0aF9vcHRpb25zKGdpdF9ub3Rlc19jb3B5X3VzYWdlLCBvcHRpb25zKTsKCQl9IGVsc2UgewoJCQlyZXR1cm4gbm90ZXNfY29weV9mcm9tX3N0ZGluKGZvcmNlLCByZXdyaXRlX2NtZCk7CgkJfQoJfQoKCWlmIChhcmdjIDwgMSkgewoJCWVycm9yKF8oInRvbyBmZXcgYXJndW1lbnRzIikpOwoJCXVzYWdlX3dpdGhfb3B0aW9ucyhnaXRfbm90ZXNfY29weV91c2FnZSwgb3B0aW9ucyk7Cgl9CglpZiAoMiA8IGFyZ2MpIHsKCQllcnJvcihfKCJ0b28gbWFueSBhcmd1bWVudHMiKSk7CgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGdpdF9ub3Rlc19jb3B5X3VzYWdlLCBvcHRpb25zKTsKCX0KCglpZiAocmVwb19nZXRfb2lkKHRoZV9yZXBvc2l0b3J5LCBhcmd2WzBdLCAmZnJvbV9vYmopKQoJCWRpZShfKCJmYWlsZWQgdG8gcmVzb2x2ZSAnJXMnIGFzIGEgdmFsaWQgcmVmLiIpLCBhcmd2WzBdKTsKCglvYmplY3RfcmVmID0gMSA8IGFyZ2MgPyBhcmd2WzFdIDogIkhFQUQiOwoKCWlmIChyZXBvX2dldF9vaWQodGhlX3JlcG9zaXRvcnksIG9iamVjdF9yZWYsICZvYmplY3QpKQoJCWRpZShfKCJmYWlsZWQgdG8gcmVzb2x2ZSAnJXMnIGFzIGEgdmFsaWQgcmVmLiIpLCBvYmplY3RfcmVmKTsKCgl0ID0gaW5pdF9ub3Rlc19jaGVjaygiY29weSIsIE5PVEVTX0lOSVRfV1JJVEFCTEUpOwoJbm90ZSA9IGdldF9ub3RlKHQsICZvYmplY3QpOwoKCWlmIChub3RlKSB7CgkJaWYgKCFmb3JjZSkgewoJCQlyZXR2YWwgPSBlcnJvcihfKCJDYW5ub3QgY29weSBub3Rlcy4gRm91bmQgZXhpc3RpbmcgIgoJCQkJICAgICAgICJub3RlcyBmb3Igb2JqZWN0ICVzLiBVc2UgJy1mJyB0byAiCgkJCQkgICAgICAgIm92ZXJ3cml0ZSBleGlzdGluZyBub3RlcyIpLAoJCQkJICAgICAgIG9pZF90b19oZXgoJm9iamVjdCkpOwoJCQlnb3RvIG91dDsKCQl9CgkJZnByaW50ZihzdGRlcnIsIF8oIk92ZXJ3cml0aW5nIGV4aXN0aW5nIG5vdGVzIGZvciBvYmplY3QgJXNcbiIpLAoJCQlvaWRfdG9faGV4KCZvYmplY3QpKTsKCX0KCglmcm9tX25vdGUgPSBnZXRfbm90ZSh0LCAmZnJvbV9vYmopOwoJaWYgKCFmcm9tX25vdGUpIHsKCQlyZXR2YWwgPSBlcnJvcihfKCJtaXNzaW5nIG5vdGVzIG9uIHNvdXJjZSBvYmplY3QgJXMuIENhbm5vdCAiCgkJCSAgICAgICAiY29weS4iKSwgb2lkX3RvX2hleCgmZnJvbV9vYmopKTsKCQlnb3RvIG91dDsKCX0KCglpZiAoYWRkX25vdGUodCwgJm9iamVjdCwgZnJvbV9ub3RlLCBjb21iaW5lX25vdGVzX292ZXJ3cml0ZSkpCgkJQlVHKCJjb21iaW5lX25vdGVzX292ZXJ3cml0ZSBmYWlsZWQiKTsKCWNvbW1pdF9ub3Rlcyh0aGVfcmVwb3NpdG9yeSwgdCwKCQkgICAgICJOb3RlcyBhZGRlZCBieSAnZ2l0IG5vdGVzIGNvcHknIik7Cm91dDoKCWZyZWVfbm90ZXModCk7CglyZXR1cm4gcmV0dmFsOwp9CgpzdGF0aWMgaW50IGFwcGVuZF9lZGl0KGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglpbnQgYWxsb3dfZW1wdHkgPSAwOwoJY29uc3QgY2hhciAqb2JqZWN0X3JlZjsKCXN0cnVjdCBub3Rlc190cmVlICp0OwoJc3RydWN0IG9iamVjdF9pZCBvYmplY3QsIG5ld19ub3RlOwoJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqbm90ZTsKCWNoYXIgKmxvZ21zZzsKCWNvbnN0IGNoYXIgKiBjb25zdCAqdXNhZ2U7CglzdHJ1Y3Qgbm90ZV9kYXRhIGQgPSB7IC5idWYgPSBTVFJCVUZfSU5JVCwgLnN0cmlwc3BhY2UgPSBVTlNQRUNJRklFRCB9OwoJc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJT1BUX0NBTExCQUNLX0YoJ20nLCAibWVzc2FnZSIsICZkLCBOXygibWVzc2FnZSIpLAoJCQlOXygibm90ZSBjb250ZW50cyBhcyBhIHN0cmluZyIpLCBQQVJTRV9PUFRfTk9ORUcsCgkJCXBhcnNlX21zZ19hcmcpLAoJCU9QVF9DQUxMQkFDS19GKCdGJywgImZpbGUiLCAmZCwgTl8oImZpbGUiKSwKCQkJTl8oIm5vdGUgY29udGVudHMgaW4gYSBmaWxlIiksIFBBUlNFX09QVF9OT05FRywKCQkJcGFyc2VfZmlsZV9hcmcpLAoJCU9QVF9DQUxMQkFDS19GKCdjJywgInJlZWRpdC1tZXNzYWdlIiwgJmQsIE5fKCJvYmplY3QiKSwKCQkJTl8oInJldXNlIGFuZCBlZGl0IHNwZWNpZmllZCBub3RlIG9iamVjdCIpLCBQQVJTRV9PUFRfTk9ORUcsCgkJCXBhcnNlX3JlZWRpdF9hcmcpLAoJCU9QVF9DQUxMQkFDS19GKCdDJywgInJldXNlLW1lc3NhZ2UiLCAmZCwgTl8oIm9iamVjdCIpLAoJCQlOXygicmV1c2Ugc3BlY2lmaWVkIG5vdGUgb2JqZWN0IiksIFBBUlNFX09QVF9OT05FRywKCQkJcGFyc2VfcmV1c2VfYXJnKSwKCQlPUFRfQk9PTCgwLCAiYWxsb3ctZW1wdHkiLCAmYWxsb3dfZW1wdHksCgkJCU5fKCJhbGxvdyBzdG9yaW5nIGVtcHR5IG5vdGUiKSksCgkJT1BUX0NBTExCQUNLX0YoMCwgInNlcGFyYXRvciIsICZzZXBhcmF0b3IsCgkJCU5fKCI8cGFyYWdyYXBoLWJyZWFrPiIpLAoJCQlOXygiaW5zZXJ0IDxwYXJhZ3JhcGgtYnJlYWs+IGJldHdlZW4gcGFyYWdyYXBocyIpLAoJCQlQQVJTRV9PUFRfT1BUQVJHLCBwYXJzZV9zZXBhcmF0b3JfYXJnKSwKCQlPUFRfQk9PTCgwLCAic3RyaXBzcGFjZSIsICZkLnN0cmlwc3BhY2UsCgkJCU5fKCJyZW1vdmUgdW5uZWNlc3Nhcnkgd2hpdGVzcGFjZSIpKSwKCQlPUFRfRU5EKCkKCX07CglpbnQgZWRpdCA9ICFzdHJjbXAoYXJndlswXSwgImVkaXQiKTsKCgl1c2FnZSA9IGVkaXQgPyBnaXRfbm90ZXNfZWRpdF91c2FnZSA6IGdpdF9ub3Rlc19hcHBlbmRfdXNhZ2U7CglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIG9wdGlvbnMsIHVzYWdlLAoJCQkgICAgIFBBUlNFX09QVF9LRUVQX0FSR1YwKTsKCglpZiAoMiA8IGFyZ2MpIHsKCQllcnJvcihfKCJ0b28gbWFueSBhcmd1bWVudHMiKSk7CgkJdXNhZ2Vfd2l0aF9vcHRpb25zKHVzYWdlLCBvcHRpb25zKTsKCX0KCglpZiAoZC5tc2dfbnIpCgkJY29uY2F0X21lc3NhZ2VzKCZkKTsKCWQuZ2l2ZW4gPSAhIWQuYnVmLmxlbjsKCglpZiAoZC5naXZlbiAmJiBlZGl0KQoJCWZwcmludGYoc3RkZXJyLCBfKCJUaGUgLW0vLUYvLWMvLUMgb3B0aW9ucyBoYXZlIGJlZW4gZGVwcmVjYXRlZCAiCgkJCSJmb3IgdGhlICdlZGl0JyBzdWJjb21tYW5kLlxuIgoJCQkiUGxlYXNlIHVzZSAnZ2l0IG5vdGVzIGFkZCAtZiAtbS8tRi8tYy8tQycgaW5zdGVhZC5cbiIpKTsKCglvYmplY3RfcmVmID0gMSA8IGFyZ2MgPyBhcmd2WzFdIDogIkhFQUQiOwoKCWlmIChyZXBvX2dldF9vaWQodGhlX3JlcG9zaXRvcnksIG9iamVjdF9yZWYsICZvYmplY3QpKQoJCWRpZShfKCJmYWlsZWQgdG8gcmVzb2x2ZSAnJXMnIGFzIGEgdmFsaWQgcmVmLiIpLCBvYmplY3RfcmVmKTsKCgl0ID0gaW5pdF9ub3Rlc19jaGVjayhhcmd2WzBdLCBOT1RFU19JTklUX1dSSVRBQkxFKTsKCW5vdGUgPSBnZXRfbm90ZSh0LCAmb2JqZWN0KTsKCglwcmVwYXJlX25vdGVfZGF0YSgmb2JqZWN0LCAmZCwgZWRpdCAmJiBub3RlID8gbm90ZSA6IE5VTEwpOwoKCWlmIChub3RlICYmICFlZGl0KSB7CgkJLyogQXBwZW5kIGJ1ZiB0byBwcmV2aW91cyBub3RlIGNvbnRlbnRzICovCgkJdW5zaWduZWQgbG9uZyBzaXplOwoJCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCQlzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJCWNoYXIgKnByZXZfYnVmID0gcmVwb19yZWFkX29iamVjdF9maWxlKHRoZV9yZXBvc2l0b3J5LCBub3RlLCAmdHlwZSwgJnNpemUpOwoKCQlpZiAocHJldl9idWYgJiYgc2l6ZSkKCQkJc3RyYnVmX2FkZCgmYnVmLCBwcmV2X2J1Ziwgc2l6ZSk7CgkJaWYgKGQuYnVmLmxlbiAmJiBwcmV2X2J1ZiAmJiBzaXplKQoJCQlhcHBlbmRfc2VwYXJhdG9yKCZidWYpOwoJCXN0cmJ1Zl9pbnNlcnQoJmQuYnVmLCAwLCBidWYuYnVmLCBidWYubGVuKTsKCgkJZnJlZShwcmV2X2J1Zik7CgkJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7Cgl9CgoJaWYgKGQuYnVmLmxlbiB8fCBhbGxvd19lbXB0eSkgewoJCXdyaXRlX25vdGVfZGF0YSgmZCwgJm5ld19ub3RlKTsKCQlpZiAoYWRkX25vdGUodCwgJm9iamVjdCwgJm5ld19ub3RlLCBjb21iaW5lX25vdGVzX292ZXJ3cml0ZSkpCgkJCUJVRygiY29tYmluZV9ub3Rlc19vdmVyd3JpdGUgZmFpbGVkIik7CgkJbG9nbXNnID0geHN0cmZtdCgiTm90ZXMgYWRkZWQgYnkgJ2dpdCBub3RlcyAlcyciLCBhcmd2WzBdKTsKCX0gZWxzZSB7CgkJZnByaW50ZihzdGRlcnIsIF8oIlJlbW92aW5nIG5vdGUgZm9yIG9iamVjdCAlc1xuIiksCgkJCW9pZF90b19oZXgoJm9iamVjdCkpOwoJCXJlbW92ZV9ub3RlKHQsIG9iamVjdC5oYXNoKTsKCQlsb2dtc2cgPSB4c3RyZm10KCJOb3RlcyByZW1vdmVkIGJ5ICdnaXQgbm90ZXMgJXMnIiwgYXJndlswXSk7Cgl9Cgljb21taXRfbm90ZXModGhlX3JlcG9zaXRvcnksIHQsIGxvZ21zZyk7CgoJZnJlZShsb2dtc2cpOwoJZnJlZV9ub3RlX2RhdGEoJmQpOwoJZnJlZV9ub3Rlcyh0KTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHNob3coaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCWNvbnN0IGNoYXIgKm9iamVjdF9yZWY7CglzdHJ1Y3Qgbm90ZXNfdHJlZSAqdDsKCXN0cnVjdCBvYmplY3RfaWQgb2JqZWN0OwoJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqbm90ZTsKCWludCByZXR2YWw7CglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfRU5EKCkKCX07CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBvcHRpb25zLCBnaXRfbm90ZXNfc2hvd191c2FnZSwKCQkJICAgICAwKTsKCglpZiAoMSA8IGFyZ2MpIHsKCQllcnJvcihfKCJ0b28gbWFueSBhcmd1bWVudHMiKSk7CgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGdpdF9ub3Rlc19zaG93X3VzYWdlLCBvcHRpb25zKTsKCX0KCglvYmplY3RfcmVmID0gYXJnYyA/IGFyZ3ZbMF0gOiAiSEVBRCI7CgoJaWYgKHJlcG9fZ2V0X29pZCh0aGVfcmVwb3NpdG9yeSwgb2JqZWN0X3JlZiwgJm9iamVjdCkpCgkJZGllKF8oImZhaWxlZCB0byByZXNvbHZlICclcycgYXMgYSB2YWxpZCByZWYuIiksIG9iamVjdF9yZWYpOwoKCXQgPSBpbml0X25vdGVzX2NoZWNrKCJzaG93IiwgMCk7Cglub3RlID0gZ2V0X25vdGUodCwgJm9iamVjdCk7CgoJaWYgKCFub3RlKQoJCXJldHZhbCA9IGVycm9yKF8oIm5vIG5vdGUgZm91bmQgZm9yIG9iamVjdCAlcy4iKSwKCQkJICAgICAgIG9pZF90b19oZXgoJm9iamVjdCkpOwoJZWxzZSB7CgkJY29uc3QgY2hhciAqc2hvd19hcmdzWzNdID0geyJzaG93Iiwgb2lkX3RvX2hleChub3RlKSwgTlVMTH07CgkJcmV0dmFsID0gZXhlY3ZfZ2l0X2NtZChzaG93X2FyZ3MpOwoJfQoJZnJlZV9ub3Rlcyh0KTsKCXJldHVybiByZXR2YWw7Cn0KCnN0YXRpYyBpbnQgbWVyZ2VfYWJvcnQoc3RydWN0IG5vdGVzX21lcmdlX29wdGlvbnMgKm8pCnsKCWludCByZXQgPSAwOwoKCS8qCgkgKiBSZW1vdmUgLmdpdC9OT1RFU19NRVJHRV9QQVJUSUFMIGFuZCAuZ2l0L05PVEVTX01FUkdFX1JFRiwgYW5kIGNhbGwKCSAqIG5vdGVzX21lcmdlX2Fib3J0KCkgdG8gcmVtb3ZlIC5naXQvTk9URVNfTUVSR0VfV09SS1RSRUUuCgkgKi8KCglpZiAoZGVsZXRlX3JlZihOVUxMLCAiTk9URVNfTUVSR0VfUEFSVElBTCIsIE5VTEwsIDApKQoJCXJldCArPSBlcnJvcihfKCJmYWlsZWQgdG8gZGVsZXRlIHJlZiBOT1RFU19NRVJHRV9QQVJUSUFMIikpOwoJaWYgKGRlbGV0ZV9yZWYoTlVMTCwgIk5PVEVTX01FUkdFX1JFRiIsIE5VTEwsIFJFRl9OT19ERVJFRikpCgkJcmV0ICs9IGVycm9yKF8oImZhaWxlZCB0byBkZWxldGUgcmVmIE5PVEVTX01FUkdFX1JFRiIpKTsKCWlmIChub3Rlc19tZXJnZV9hYm9ydChvKSkKCQlyZXQgKz0gZXJyb3IoXygiZmFpbGVkIHRvIHJlbW92ZSAnZ2l0IG5vdGVzIG1lcmdlJyB3b3JrdHJlZSIpKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQgbWVyZ2VfY29tbWl0KHN0cnVjdCBub3Rlc19tZXJnZV9vcHRpb25zICpvKQp7CglzdHJ1Y3Qgc3RyYnVmIG1zZyA9IFNUUkJVRl9JTklUOwoJc3RydWN0IG9iamVjdF9pZCBvaWQsIHBhcmVudF9vaWQ7CglzdHJ1Y3Qgbm90ZXNfdHJlZSAqdDsKCXN0cnVjdCBjb21taXQgKnBhcnRpYWw7CglzdHJ1Y3QgcHJldHR5X3ByaW50X2NvbnRleHQgcHJldHR5X2N0eDsKCXZvaWQgKmxvY2FsX3JlZl90b19mcmVlOwoJaW50IHJldDsKCgkvKgoJICogUmVhZCBwYXJ0aWFsIG1lcmdlIHJlc3VsdCBmcm9tIC5naXQvTk9URVNfTUVSR0VfUEFSVElBTCwKCSAqIGFuZCB0YXJnZXQgbm90ZXMgcmVmIGZyb20gLmdpdC9OT1RFU19NRVJHRV9SRUYuCgkgKi8KCglpZiAocmVwb19nZXRfb2lkKHRoZV9yZXBvc2l0b3J5LCAiTk9URVNfTUVSR0VfUEFSVElBTCIsICZvaWQpKQoJCWRpZShfKCJmYWlsZWQgdG8gcmVhZCByZWYgTk9URVNfTUVSR0VfUEFSVElBTCIpKTsKCWVsc2UgaWYgKCEocGFydGlhbCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlKHRoZV9yZXBvc2l0b3J5LCAmb2lkKSkpCgkJZGllKF8oImNvdWxkIG5vdCBmaW5kIGNvbW1pdCBmcm9tIE5PVEVTX01FUkdFX1BBUlRJQUwuIikpOwoJZWxzZSBpZiAocmVwb19wYXJzZV9jb21taXQodGhlX3JlcG9zaXRvcnksIHBhcnRpYWwpKQoJCWRpZShfKCJjb3VsZCBub3QgcGFyc2UgY29tbWl0IGZyb20gTk9URVNfTUVSR0VfUEFSVElBTC4iKSk7CgoJaWYgKHBhcnRpYWwtPnBhcmVudHMpCgkJb2lkY3B5KCZwYXJlbnRfb2lkLCAmcGFydGlhbC0+cGFyZW50cy0+aXRlbS0+b2JqZWN0Lm9pZCk7CgllbHNlCgkJb2lkY2xyKCZwYXJlbnRfb2lkKTsKCglDQUxMT0NfQVJSQVkodCwgMSk7Cglpbml0X25vdGVzKHQsICJOT1RFU19NRVJHRV9QQVJUSUFMIiwgY29tYmluZV9ub3Rlc19vdmVyd3JpdGUsIDApOwoKCW8tPmxvY2FsX3JlZiA9IGxvY2FsX3JlZl90b19mcmVlID0KCQlyZXNvbHZlX3JlZmR1cCgiTk9URVNfTUVSR0VfUkVGIiwgMCwgJm9pZCwgTlVMTCk7CglpZiAoIW8tPmxvY2FsX3JlZikKCQlkaWUoXygiZmFpbGVkIHRvIHJlc29sdmUgTk9URVNfTUVSR0VfUkVGIikpOwoKCWlmIChub3Rlc19tZXJnZV9jb21taXQobywgdCwgcGFydGlhbCwgJm9pZCkpCgkJZGllKF8oImZhaWxlZCB0byBmaW5hbGl6ZSBub3RlcyBtZXJnZSIpKTsKCgkvKiBSZXVzZSBleGlzdGluZyBjb21taXQgbWVzc2FnZSBpbiByZWZsb2cgbWVzc2FnZSAqLwoJbWVtc2V0KCZwcmV0dHlfY3R4LCAwLCBzaXplb2YocHJldHR5X2N0eCkpOwoJcmVwb19mb3JtYXRfY29tbWl0X21lc3NhZ2UodGhlX3JlcG9zaXRvcnksIHBhcnRpYWwsICIlcyIsICZtc2csCgkJCQkgICAmcHJldHR5X2N0eCk7CglzdHJidWZfdHJpbSgmbXNnKTsKCXN0cmJ1Zl9pbnNlcnRzdHIoJm1zZywgMCwgIm5vdGVzOiAiKTsKCXVwZGF0ZV9yZWYobXNnLmJ1Ziwgby0+bG9jYWxfcmVmLCAmb2lkLAoJCSAgIGlzX251bGxfb2lkKCZwYXJlbnRfb2lkKSA/IE5VTEwgOiAmcGFyZW50X29pZCwKCQkgICAwLCBVUERBVEVfUkVGU19ESUVfT05fRVJSKTsKCglmcmVlX25vdGVzKHQpOwoJc3RyYnVmX3JlbGVhc2UoJm1zZyk7CglyZXQgPSBtZXJnZV9hYm9ydChvKTsKCWZyZWUobG9jYWxfcmVmX3RvX2ZyZWUpOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIGludCBnaXRfY29uZmlnX2dldF9ub3Rlc19zdHJhdGVneShjb25zdCBjaGFyICprZXksCgkJCQkJIGVudW0gbm90ZXNfbWVyZ2Vfc3RyYXRlZ3kgKnN0cmF0ZWd5KQp7CgljaGFyICp2YWx1ZTsKCglpZiAoZ2l0X2NvbmZpZ19nZXRfc3RyaW5nKGtleSwgJnZhbHVlKSkKCQlyZXR1cm4gMTsKCWlmIChwYXJzZV9ub3Rlc19tZXJnZV9zdHJhdGVneSh2YWx1ZSwgc3RyYXRlZ3kpKQoJCWdpdF9kaWVfY29uZmlnKGtleSwgXygidW5rbm93biBub3RlcyBtZXJnZSBzdHJhdGVneSAlcyIpLCB2YWx1ZSk7CgoJZnJlZSh2YWx1ZSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBtZXJnZShpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IHN0cmJ1ZiByZW1vdGVfcmVmID0gU1RSQlVGX0lOSVQsIG1zZyA9IFNUUkJVRl9JTklUOwoJc3RydWN0IG9iamVjdF9pZCByZXN1bHRfb2lkOwoJc3RydWN0IG5vdGVzX3RyZWUgKnQ7CglzdHJ1Y3Qgbm90ZXNfbWVyZ2Vfb3B0aW9ucyBvOwoJaW50IGRvX21lcmdlID0gMCwgZG9fY29tbWl0ID0gMCwgZG9fYWJvcnQgPSAwOwoJaW50IHZlcmJvc2l0eSA9IDAsIHJlc3VsdDsKCWNvbnN0IGNoYXIgKnN0cmF0ZWd5ID0gTlVMTDsKCXN0cnVjdCBvcHRpb24gb3B0aW9uc1tdID0gewoJCU9QVF9HUk9VUChOXygiR2VuZXJhbCBvcHRpb25zIikpLAoJCU9QVF9fVkVSQk9TSVRZKCZ2ZXJib3NpdHkpLAoJCU9QVF9HUk9VUChOXygiTWVyZ2Ugb3B0aW9ucyIpKSwKCQlPUFRfU1RSSU5HKCdzJywgInN0cmF0ZWd5IiwgJnN0cmF0ZWd5LCBOXygic3RyYXRlZ3kiKSwKCQkJICAgTl8oInJlc29sdmUgbm90ZXMgY29uZmxpY3RzIHVzaW5nIHRoZSBnaXZlbiBzdHJhdGVneSAiCgkJCSAgICAgICIobWFudWFsL291cnMvdGhlaXJzL3VuaW9uL2NhdF9zb3J0X3VuaXEpIikpLAoJCU9QVF9HUk9VUChOXygiQ29tbWl0dGluZyB1bm1lcmdlZCBub3RlcyIpKSwKCQlPUFRfU0VUX0lOVF9GKDAsICJjb21taXQiLCAmZG9fY29tbWl0LAoJCQkgICAgICBOXygiZmluYWxpemUgbm90ZXMgbWVyZ2UgYnkgY29tbWl0dGluZyB1bm1lcmdlZCBub3RlcyIpLAoJCQkgICAgICAxLCBQQVJTRV9PUFRfTk9ORUcpLAoJCU9QVF9HUk9VUChOXygiQWJvcnRpbmcgbm90ZXMgbWVyZ2UgcmVzb2x1dGlvbiIpKSwKCQlPUFRfU0VUX0lOVF9GKDAsICJhYm9ydCIsICZkb19hYm9ydCwKCQkJICAgICAgTl8oImFib3J0IG5vdGVzIG1lcmdlIiksCgkJCSAgICAgIDEsIFBBUlNFX09QVF9OT05FRyksCgkJT1BUX0VORCgpCgl9OwoKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgb3B0aW9ucywKCQkJICAgICBnaXRfbm90ZXNfbWVyZ2VfdXNhZ2UsIDApOwoKCWlmIChzdHJhdGVneSB8fCBkb19jb21taXQgKyBkb19hYm9ydCA9PSAwKQoJCWRvX21lcmdlID0gMTsKCWlmIChkb19tZXJnZSArIGRvX2NvbW1pdCArIGRvX2Fib3J0ICE9IDEpIHsKCQllcnJvcihfKCJjYW5ub3QgbWl4IC0tY29tbWl0LCAtLWFib3J0IG9yIC1zLy0tc3RyYXRlZ3kiKSk7CgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGdpdF9ub3Rlc19tZXJnZV91c2FnZSwgb3B0aW9ucyk7Cgl9CgoJaWYgKGRvX21lcmdlICYmIGFyZ2MgIT0gMSkgewoJCWVycm9yKF8oIm11c3Qgc3BlY2lmeSBhIG5vdGVzIHJlZiB0byBtZXJnZSIpKTsKCQl1c2FnZV93aXRoX29wdGlvbnMoZ2l0X25vdGVzX21lcmdlX3VzYWdlLCBvcHRpb25zKTsKCX0gZWxzZSBpZiAoIWRvX21lcmdlICYmIGFyZ2MpIHsKCQllcnJvcihfKCJ0b28gbWFueSBhcmd1bWVudHMiKSk7CgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGdpdF9ub3Rlc19tZXJnZV91c2FnZSwgb3B0aW9ucyk7Cgl9CgoJaW5pdF9ub3Rlc19tZXJnZV9vcHRpb25zKHRoZV9yZXBvc2l0b3J5LCAmbyk7CglvLnZlcmJvc2l0eSA9IHZlcmJvc2l0eSArIE5PVEVTX01FUkdFX1ZFUkJPU0lUWV9ERUZBVUxUOwoKCWlmIChkb19hYm9ydCkKCQlyZXR1cm4gbWVyZ2VfYWJvcnQoJm8pOwoJaWYgKGRvX2NvbW1pdCkKCQlyZXR1cm4gbWVyZ2VfY29tbWl0KCZvKTsKCglvLmxvY2FsX3JlZiA9IGRlZmF1bHRfbm90ZXNfcmVmKCk7CglzdHJidWZfYWRkc3RyKCZyZW1vdGVfcmVmLCBhcmd2WzBdKTsKCWV4cGFuZF9sb29zZV9ub3Rlc19yZWYoJnJlbW90ZV9yZWYpOwoJby5yZW1vdGVfcmVmID0gcmVtb3RlX3JlZi5idWY7CgoJdCA9IGluaXRfbm90ZXNfY2hlY2soIm1lcmdlIiwgTk9URVNfSU5JVF9XUklUQUJMRSk7CgoJaWYgKHN0cmF0ZWd5KSB7CgkJaWYgKHBhcnNlX25vdGVzX21lcmdlX3N0cmF0ZWd5KHN0cmF0ZWd5LCAmby5zdHJhdGVneSkpIHsKCQkJZXJyb3IoXygidW5rbm93biAtcy8tLXN0cmF0ZWd5OiAlcyIpLCBzdHJhdGVneSk7CgkJCXVzYWdlX3dpdGhfb3B0aW9ucyhnaXRfbm90ZXNfbWVyZ2VfdXNhZ2UsIG9wdGlvbnMpOwoJCX0KCX0gZWxzZSB7CgkJc3RydWN0IHN0cmJ1ZiBtZXJnZV9rZXkgPSBTVFJCVUZfSU5JVDsKCQljb25zdCBjaGFyICpzaG9ydF9yZWYgPSBOVUxMOwoKCQlpZiAoIXNraXBfcHJlZml4KG8ubG9jYWxfcmVmLCAicmVmcy9ub3Rlcy8iLCAmc2hvcnRfcmVmKSkKCQkJQlVHKCJsb2NhbCByZWYgJXMgaXMgb3V0c2lkZSBvZiByZWZzL25vdGVzLyIsCgkJCSAgICBvLmxvY2FsX3JlZik7CgoJCXN0cmJ1Zl9hZGRmKCZtZXJnZV9rZXksICJub3Rlcy4lcy5tZXJnZVN0cmF0ZWd5Iiwgc2hvcnRfcmVmKTsKCgkJaWYgKGdpdF9jb25maWdfZ2V0X25vdGVzX3N0cmF0ZWd5KG1lcmdlX2tleS5idWYsICZvLnN0cmF0ZWd5KSkKCQkJZ2l0X2NvbmZpZ19nZXRfbm90ZXNfc3RyYXRlZ3koIm5vdGVzLm1lcmdlU3RyYXRlZ3kiLCAmby5zdHJhdGVneSk7CgoJCXN0cmJ1Zl9yZWxlYXNlKCZtZXJnZV9rZXkpOwoJfQoKCXN0cmJ1Zl9hZGRmKCZtc2csICJub3RlczogTWVyZ2VkIG5vdGVzIGZyb20gJXMgaW50byAlcyIsCgkJICAgIHJlbW90ZV9yZWYuYnVmLCBkZWZhdWx0X25vdGVzX3JlZigpKTsKCXN0cmJ1Zl9hZGQoJihvLmNvbW1pdF9tc2cpLCBtc2cuYnVmICsgNywgbXNnLmxlbiAtIDcpOyAvKiBza2lwICJub3RlczogIiAqLwoKCXJlc3VsdCA9IG5vdGVzX21lcmdlKCZvLCB0LCAmcmVzdWx0X29pZCk7CgoJaWYgKHJlc3VsdCA+PSAwKSAvKiBNZXJnZSByZXN1bHRlZCAodHJpdmlhbGx5KSBpbiByZXN1bHRfb2lkICovCgkJLyogVXBkYXRlIGRlZmF1bHQgbm90ZXMgcmVmIHdpdGggbmV3IGNvbW1pdCAqLwoJCXVwZGF0ZV9yZWYobXNnLmJ1ZiwgZGVmYXVsdF9ub3Rlc19yZWYoKSwgJnJlc3VsdF9vaWQsIE5VTEwsIDAsCgkJCSAgIFVQREFURV9SRUZTX0RJRV9PTl9FUlIpOwoJZWxzZSB7IC8qIE1lcmdlIGhhcyB1bnJlc29sdmVkIGNvbmZsaWN0cyAqLwoJCXN0cnVjdCB3b3JrdHJlZSAqKndvcmt0cmVlczsKCQljb25zdCBzdHJ1Y3Qgd29ya3RyZWUgKnd0OwoJCS8qIFVwZGF0ZSAuZ2l0L05PVEVTX01FUkdFX1BBUlRJQUwgd2l0aCBwYXJ0aWFsIG1lcmdlIHJlc3VsdCAqLwoJCXVwZGF0ZV9yZWYobXNnLmJ1ZiwgIk5PVEVTX01FUkdFX1BBUlRJQUwiLCAmcmVzdWx0X29pZCwgTlVMTCwKCQkJICAgMCwgVVBEQVRFX1JFRlNfRElFX09OX0VSUik7CgkJLyogU3RvcmUgcmVmLXRvLWJlLXVwZGF0ZWQgaW50byAuZ2l0L05PVEVTX01FUkdFX1JFRiAqLwoJCXdvcmt0cmVlcyA9IGdldF93b3JrdHJlZXMoKTsKCQl3dCA9IGZpbmRfc2hhcmVkX3N5bXJlZih3b3JrdHJlZXMsICJOT1RFU19NRVJHRV9SRUYiLAoJCQkJCWRlZmF1bHRfbm90ZXNfcmVmKCkpOwoJCWlmICh3dCkKCQkJZGllKF8oImEgbm90ZXMgbWVyZ2UgaW50byAlcyBpcyBhbHJlYWR5IGluLXByb2dyZXNzIGF0ICVzIiksCgkJCSAgICBkZWZhdWx0X25vdGVzX3JlZigpLCB3dC0+cGF0aCk7CgkJZnJlZV93b3JrdHJlZXMod29ya3RyZWVzKTsKCQlpZiAoY3JlYXRlX3N5bXJlZigiTk9URVNfTUVSR0VfUkVGIiwgZGVmYXVsdF9ub3Rlc19yZWYoKSwgTlVMTCkpCgkJCWRpZShfKCJmYWlsZWQgdG8gc3RvcmUgbGluayB0byBjdXJyZW50IG5vdGVzIHJlZiAoJXMpIiksCgkJCSAgICBkZWZhdWx0X25vdGVzX3JlZigpKTsKCQlmcHJpbnRmKHN0ZGVyciwgXygiQXV0b21hdGljIG5vdGVzIG1lcmdlIGZhaWxlZC4gRml4IGNvbmZsaWN0cyBpbiAlcyAiCgkJCQkgICJhbmQgY29tbWl0IHRoZSByZXN1bHQgd2l0aCAnZ2l0IG5vdGVzIG1lcmdlIC0tY29tbWl0JywgIgoJCQkJICAib3IgYWJvcnQgdGhlIG1lcmdlIHdpdGggJ2dpdCBub3RlcyBtZXJnZSAtLWFib3J0Jy5cbiIpLAoJCQlnaXRfcGF0aChOT1RFU19NRVJHRV9XT1JLVFJFRSkpOwoJfQoKCWZyZWVfbm90ZXModCk7CglzdHJidWZfcmVsZWFzZSgmcmVtb3RlX3JlZik7CglzdHJidWZfcmVsZWFzZSgmbXNnKTsKCXJldHVybiByZXN1bHQgPCAwOyAvKiByZXR1cm4gbm9uLXplcm8gb24gY29uZmxpY3RzICovCn0KCiNkZWZpbmUgSUdOT1JFX01JU1NJTkcgMQoKc3RhdGljIGludCByZW1vdmVfb25lX25vdGUoc3RydWN0IG5vdGVzX3RyZWUgKnQsIGNvbnN0IGNoYXIgKm5hbWUsIHVuc2lnbmVkIGZsYWcpCnsKCWludCBzdGF0dXM7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCWlmIChyZXBvX2dldF9vaWQodGhlX3JlcG9zaXRvcnksIG5hbWUsICZvaWQpKQoJCXJldHVybiBlcnJvcihfKCJGYWlsZWQgdG8gcmVzb2x2ZSAnJXMnIGFzIGEgdmFsaWQgcmVmLiIpLCBuYW1lKTsKCXN0YXR1cyA9IHJlbW92ZV9ub3RlKHQsIG9pZC5oYXNoKTsKCWlmIChzdGF0dXMpCgkJZnByaW50ZihzdGRlcnIsIF8oIk9iamVjdCAlcyBoYXMgbm8gbm90ZVxuIiksIG5hbWUpOwoJZWxzZQoJCWZwcmludGYoc3RkZXJyLCBfKCJSZW1vdmluZyBub3RlIGZvciBvYmplY3QgJXNcbiIpLCBuYW1lKTsKCXJldHVybiAoZmxhZyAmIElHTk9SRV9NSVNTSU5HKSA/IDAgOiBzdGF0dXM7Cn0KCnN0YXRpYyBpbnQgcmVtb3ZlX2NtZChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJdW5zaWduZWQgZmxhZyA9IDA7CglpbnQgZnJvbV9zdGRpbiA9IDA7CglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfQklUKDAsICJpZ25vcmUtbWlzc2luZyIsICZmbGFnLAoJCQlOXygiYXR0ZW1wdCB0byByZW1vdmUgbm9uLWV4aXN0ZW50IG5vdGUgaXMgbm90IGFuIGVycm9yIiksCgkJCUlHTk9SRV9NSVNTSU5HKSwKCQlPUFRfQk9PTCgwLCAic3RkaW4iLCAmZnJvbV9zdGRpbiwKCQkJICAgIE5fKCJyZWFkIG9iamVjdCBuYW1lcyBmcm9tIHRoZSBzdGFuZGFyZCBpbnB1dCIpKSwKCQlPUFRfRU5EKCkKCX07CglzdHJ1Y3Qgbm90ZXNfdHJlZSAqdDsKCWludCByZXR2YWwgPSAwOwoKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgb3B0aW9ucywKCQkJICAgICBnaXRfbm90ZXNfcmVtb3ZlX3VzYWdlLCAwKTsKCgl0ID0gaW5pdF9ub3Rlc19jaGVjaygicmVtb3ZlIiwgTk9URVNfSU5JVF9XUklUQUJMRSk7CgoJaWYgKCFhcmdjICYmICFmcm9tX3N0ZGluKSB7CgkJcmV0dmFsID0gcmVtb3ZlX29uZV9ub3RlKHQsICJIRUFEIiwgZmxhZyk7Cgl9IGVsc2UgewoJCXdoaWxlICgqYXJndikgewoJCQlyZXR2YWwgfD0gcmVtb3ZlX29uZV9ub3RlKHQsICphcmd2LCBmbGFnKTsKCQkJYXJndisrOwoJCX0KCX0KCWlmIChmcm9tX3N0ZGluKSB7CgkJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJCXdoaWxlIChzdHJidWZfZ2V0d2hvbGVsaW5lKCZzYiwgc3RkaW4sICdcbicpICE9IEVPRikgewoJCQlzdHJidWZfcnRyaW0oJnNiKTsKCQkJcmV0dmFsIHw9IHJlbW92ZV9vbmVfbm90ZSh0LCBzYi5idWYsIGZsYWcpOwoJCX0KCQlzdHJidWZfcmVsZWFzZSgmc2IpOwoJfQoJaWYgKCFyZXR2YWwpCgkJY29tbWl0X25vdGVzKHRoZV9yZXBvc2l0b3J5LCB0LAoJCQkgICAgICJOb3RlcyByZW1vdmVkIGJ5ICdnaXQgbm90ZXMgcmVtb3ZlJyIpOwoJZnJlZV9ub3Rlcyh0KTsKCXJldHVybiByZXR2YWw7Cn0KCnN0YXRpYyBpbnQgcHJ1bmUoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0cnVjdCBub3Rlc190cmVlICp0OwoJaW50IHNob3dfb25seSA9IDAsIHZlcmJvc2UgPSAwOwoJc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJT1BUX19EUllfUlVOKCZzaG93X29ubHksIE5fKCJkbyBub3QgcmVtb3ZlLCBzaG93IG9ubHkiKSksCgkJT1BUX19WRVJCT1NFKCZ2ZXJib3NlLCBOXygicmVwb3J0IHBydW5lZCBub3RlcyIpKSwKCQlPUFRfRU5EKCkKCX07CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBvcHRpb25zLCBnaXRfbm90ZXNfcHJ1bmVfdXNhZ2UsCgkJCSAgICAgMCk7CgoJaWYgKGFyZ2MpIHsKCQllcnJvcihfKCJ0b28gbWFueSBhcmd1bWVudHMiKSk7CgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGdpdF9ub3Rlc19wcnVuZV91c2FnZSwgb3B0aW9ucyk7Cgl9CgoJdCA9IGluaXRfbm90ZXNfY2hlY2soInBydW5lIiwgTk9URVNfSU5JVF9XUklUQUJMRSk7CgoJcHJ1bmVfbm90ZXModCwgKHZlcmJvc2UgPyBOT1RFU19QUlVORV9WRVJCT1NFIDogMCkgfAoJCShzaG93X29ubHkgPyBOT1RFU19QUlVORV9WRVJCT1NFfE5PVEVTX1BSVU5FX0RSWVJVTiA6IDApICk7CglpZiAoIXNob3dfb25seSkKCQljb21taXRfbm90ZXModGhlX3JlcG9zaXRvcnksIHQsCgkJCSAgICAgIk5vdGVzIHJlbW92ZWQgYnkgJ2dpdCBub3RlcyBwcnVuZSciKTsKCWZyZWVfbm90ZXModCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBnZXRfcmVmKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsgT1BUX0VORCgpIH07CglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIG9wdGlvbnMsCgkJCSAgICAgZ2l0X25vdGVzX2dldF9yZWZfdXNhZ2UsIDApOwoKCWlmIChhcmdjKSB7CgkJZXJyb3IoXygidG9vIG1hbnkgYXJndW1lbnRzIikpOwoJCXVzYWdlX3dpdGhfb3B0aW9ucyhnaXRfbm90ZXNfZ2V0X3JlZl91c2FnZSwgb3B0aW9ucyk7Cgl9CgoJcHV0cyhkZWZhdWx0X25vdGVzX3JlZigpKTsKCXJldHVybiAwOwp9CgppbnQgY21kX25vdGVzKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7Cgljb25zdCBjaGFyICpvdmVycmlkZV9ub3Rlc19yZWYgPSBOVUxMOwoJcGFyc2Vfb3B0X3N1YmNvbW1hbmRfZm4gKmZuID0gTlVMTDsKCXN0cnVjdCBvcHRpb24gb3B0aW9uc1tdID0gewoJCU9QVF9TVFJJTkcoMCwgInJlZiIsICZvdmVycmlkZV9ub3Rlc19yZWYsIE5fKCJub3Rlcy1yZWYiKSwKCQkJICAgTl8oInVzZSBub3RlcyBmcm9tIDxub3Rlcy1yZWY+IikpLAoJCU9QVF9TVUJDT01NQU5EKCJsaXN0IiwgJmZuLCBsaXN0KSwKCQlPUFRfU1VCQ09NTUFORCgiYWRkIiwgJmZuLCBhZGQpLAoJCU9QVF9TVUJDT01NQU5EKCJjb3B5IiwgJmZuLCBjb3B5KSwKCQlPUFRfU1VCQ09NTUFORCgiYXBwZW5kIiwgJmZuLCBhcHBlbmRfZWRpdCksCgkJT1BUX1NVQkNPTU1BTkQoImVkaXQiLCAmZm4sIGFwcGVuZF9lZGl0KSwKCQlPUFRfU1VCQ09NTUFORCgic2hvdyIsICZmbiwgc2hvdyksCgkJT1BUX1NVQkNPTU1BTkQoIm1lcmdlIiwgJmZuLCBtZXJnZSksCgkJT1BUX1NVQkNPTU1BTkQoInJlbW92ZSIsICZmbiwgcmVtb3ZlX2NtZCksCgkJT1BUX1NVQkNPTU1BTkQoInBydW5lIiwgJmZuLCBwcnVuZSksCgkJT1BUX1NVQkNPTU1BTkQoImdldC1yZWYiLCAmZm4sIGdldF9yZWYpLAoJCU9QVF9FTkQoKQoJfTsKCglnaXRfY29uZmlnKGdpdF9kZWZhdWx0X2NvbmZpZywgTlVMTCk7CglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIG9wdGlvbnMsIGdpdF9ub3Rlc191c2FnZSwKCQkJICAgICBQQVJTRV9PUFRfU1VCQ09NTUFORF9PUFRJT05BTCk7CglpZiAoIWZuKSB7CgkJaWYgKGFyZ2MpIHsKCQkJZXJyb3IoXygidW5rbm93biBzdWJjb21tYW5kOiBgJXMnIiksIGFyZ3ZbMF0pOwoJCQl1c2FnZV93aXRoX29wdGlvbnMoZ2l0X25vdGVzX3VzYWdlLCBvcHRpb25zKTsKCQl9CgkJZm4gPSBsaXN0OwoJfQoKCWlmIChvdmVycmlkZV9ub3Rlc19yZWYpIHsKCQlzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CgkJc3RyYnVmX2FkZHN0cigmc2IsIG92ZXJyaWRlX25vdGVzX3JlZik7CgkJZXhwYW5kX25vdGVzX3JlZigmc2IpOwoJCXNldGVudigiR0lUX05PVEVTX1JFRiIsIHNiLmJ1ZiwgMSk7CgkJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCX0KCglyZXR1cm4gISFmbihhcmdjLCBhcmd2LCBwcmVmaXgpOwp9Cg==",
    "text": "/*\n * Builtin \"git notes\"\n *\n * Copyright (c) 2010 Johan Herland <johan@herland.net>\n *\n * Based on git-notes.sh by Johannes Schindelin,\n * and builtin/tag.c by Kristian H\u00f8gsberg and Carlos Rica.\n */\n\n#include \"cache.h\"\n#include \"alloc.h\"\n#include \"config.h\"\n#include \"builtin.h\"\n#include \"gettext.h\"\n#include \"hex.h\"\n#include \"notes.h\"\n#include \"object-store.h\"\n#include \"repository.h\"\n#include \"blob.h\"\n#include \"pretty.h\"\n#include \"refs.h\"\n#include \"exec-cmd.h\"\n#include \"run-command.h\"\n#include \"parse-options.h\"\n#include \"string-list.h\"\n#include \"notes-merge.h\"\n#include \"notes-utils.h\"\n#include \"worktree.h\"\n#include \"write-or-die.h\"\n\nstatic const char *separator = \"\\n\";\nstatic const char * const git_notes_usage[] = {\n\tN_(\"git notes [--ref <notes-ref>] [list [<object>]]\"),\n\tN_(\"git notes [--ref <notes-ref>] add [-f] [--allow-empty] [--[no-]separator|--separator=<paragraph-break>] [--[no-]stripspace] [-m <msg> | -F <file> | (-c | -C) <object>] [<object>]\"),\n\tN_(\"git notes [--ref <notes-ref>] copy [-f] <from-object> <to-object>\"),\n\tN_(\"git notes [--ref <notes-ref>] append [--allow-empty] [--[no-]separator|--separator=<paragraph-break>] [--[no-]stripspace] [-m <msg> | -F <file> | (-c | -C) <object>] [<object>]\"),\n\tN_(\"git notes [--ref <notes-ref>] edit [--allow-empty] [<object>]\"),\n\tN_(\"git notes [--ref <notes-ref>] show [<object>]\"),\n\tN_(\"git notes [--ref <notes-ref>] merge [-v | -q] [-s <strategy>] <notes-ref>\"),\n\t\"git notes merge --commit [-v | -q]\",\n\t\"git notes merge --abort [-v | -q]\",\n\tN_(\"git notes [--ref <notes-ref>] remove [<object>...]\"),\n\tN_(\"git notes [--ref <notes-ref>] prune [-n] [-v]\"),\n\tN_(\"git notes [--ref <notes-ref>] get-ref\"),\n\tNULL\n};\n\nstatic const char * const git_notes_list_usage[] = {\n\tN_(\"git notes [list [<object>]]\"),\n\tNULL\n};\n\nstatic const char * const git_notes_add_usage[] = {\n\tN_(\"git notes add [<options>] [<object>]\"),\n\tNULL\n};\n\nstatic const char * const git_notes_copy_usage[] = {\n\tN_(\"git notes copy [<options>] <from-object> <to-object>\"),\n\tN_(\"git notes copy --stdin [<from-object> <to-object>]...\"),\n\tNULL\n};\n\nstatic const char * const git_notes_append_usage[] = {\n\tN_(\"git notes append [<options>] [<object>]\"),\n\tNULL\n};\n\nstatic const char * const git_notes_edit_usage[] = {\n\tN_(\"git notes edit [<object>]\"),\n\tNULL\n};\n\nstatic const char * const git_notes_show_usage[] = {\n\tN_(\"git notes show [<object>]\"),\n\tNULL\n};\n\nstatic const char * const git_notes_merge_usage[] = {\n\tN_(\"git notes merge [<options>] <notes-ref>\"),\n\tN_(\"git notes merge --commit [<options>]\"),\n\tN_(\"git notes merge --abort [<options>]\"),\n\tNULL\n};\n\nstatic const char * const git_notes_remove_usage[] = {\n\tN_(\"git notes remove [<object>]\"),\n\tNULL\n};\n\nstatic const char * const git_notes_prune_usage[] = {\n\tN_(\"git notes prune [<options>]\"),\n\tNULL\n};\n\nstatic const char * const git_notes_get_ref_usage[] = {\n\t\"git notes get-ref\",\n\tNULL\n};\n\nstatic const char note_template[] =\n\tN_(\"Write/edit the notes for the following object:\");\n\nenum notes_stripspace {\n\tUNSPECIFIED = -1,\n\tNO_STRIPSPACE = 0,\n\tSTRIPSPACE = 1,\n};\n\nstruct note_msg {\n\tenum notes_stripspace stripspace;\n\tstruct strbuf buf;\n};\n\nstruct note_data {\n\tint given;\n\tint use_editor;\n\tint stripspace;\n\tchar *edit_path;\n\tstruct strbuf buf;\n\tstruct note_msg **messages;\n\tsize_t msg_nr;\n\tsize_t msg_alloc;\n};\n\nstatic void free_note_data(struct note_data *d)\n{\n\tif (d->edit_path) {\n\t\tunlink_or_warn(d->edit_path);\n\t\tfree(d->edit_path);\n\t}\n\tstrbuf_release(&d->buf);\n\n\twhile (d->msg_nr--) {\n\t\tstrbuf_release(&d->messages[d->msg_nr]->buf);\n\t\tfree(d->messages[d->msg_nr]);\n\t}\n\tfree(d->messages);\n}\n\nstatic int list_each_note(const struct object_id *object_oid,\n\t\t\t  const struct object_id *note_oid,\n\t\t\t  char *note_path UNUSED,\n\t\t\t  void *cb_data UNUSED)\n{\n\tprintf(\"%s %s\\n\", oid_to_hex(note_oid), oid_to_hex(object_oid));\n\treturn 0;\n}\n\nstatic void copy_obj_to_fd(int fd, const struct object_id *oid)\n{\n\tunsigned long size;\n\tenum object_type type;\n\tchar *buf = repo_read_object_file(the_repository, oid, &type, &size);\n\tif (buf) {\n\t\tif (size)\n\t\t\twrite_or_die(fd, buf, size);\n\t\tfree(buf);\n\t}\n}\n\nstatic void write_commented_object(int fd, const struct object_id *object)\n{\n\tstruct child_process show = CHILD_PROCESS_INIT;\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf cbuf = STRBUF_INIT;\n\n\t/* Invoke \"git show --stat --no-notes $object\" */\n\tstrvec_pushl(&show.args, \"show\", \"--stat\", \"--no-notes\",\n\t\t     oid_to_hex(object), NULL);\n\tshow.no_stdin = 1;\n\tshow.out = -1;\n\tshow.err = 0;\n\tshow.git_cmd = 1;\n\tif (start_command(&show))\n\t\tdie(_(\"unable to start 'show' for object '%s'\"),\n\t\t    oid_to_hex(object));\n\n\tif (strbuf_read(&buf, show.out, 0) < 0)\n\t\tdie_errno(_(\"could not read 'show' output\"));\n\tstrbuf_add_commented_lines(&cbuf, buf.buf, buf.len);\n\twrite_or_die(fd, cbuf.buf, cbuf.len);\n\n\tstrbuf_release(&cbuf);\n\tstrbuf_release(&buf);\n\n\tif (finish_command(&show))\n\t\tdie(_(\"failed to finish 'show' for object '%s'\"),\n\t\t    oid_to_hex(object));\n}\n\nstatic void prepare_note_data(const struct object_id *object, struct note_data *d,\n\t\tconst struct object_id *old_note)\n{\n\tif (d->use_editor || !d->given) {\n\t\tint fd;\n\t\tstruct strbuf buf = STRBUF_INIT;\n\n\t\t/* write the template message before editing: */\n\t\td->edit_path = git_pathdup(\"NOTES_EDITMSG\");\n\t\tfd = xopen(d->edit_path, O_CREAT | O_TRUNC | O_WRONLY, 0600);\n\n\t\tif (d->given)\n\t\t\twrite_or_die(fd, d->buf.buf, d->buf.len);\n\t\telse if (old_note)\n\t\t\tcopy_obj_to_fd(fd, old_note);\n\n\t\tstrbuf_addch(&buf, '\\n');\n\t\tstrbuf_add_commented_lines(&buf, \"\\n\", strlen(\"\\n\"));\n\t\tstrbuf_add_commented_lines(&buf, _(note_template), strlen(_(note_template)));\n\t\tstrbuf_add_commented_lines(&buf, \"\\n\", strlen(\"\\n\"));\n\t\twrite_or_die(fd, buf.buf, buf.len);\n\n\t\twrite_commented_object(fd, object);\n\n\t\tclose(fd);\n\t\tstrbuf_release(&buf);\n\t\tstrbuf_reset(&d->buf);\n\n\t\tif (launch_editor(d->edit_path, &d->buf, NULL)) {\n\t\t\tdie(_(\"please supply the note contents using either -m or -F option\"));\n\t\t}\n\t\tif (d->stripspace)\n\t\t\tstrbuf_stripspace(&d->buf, 1);\n\t}\n}\n\nstatic void write_note_data(struct note_data *d, struct object_id *oid)\n{\n\tif (write_object_file(d->buf.buf, d->buf.len, OBJ_BLOB, oid)) {\n\t\tint status = die_message(_(\"unable to write note object\"));\n\n\t\tif (d->edit_path)\n\t\t\tdie_message(_(\"the note contents have been left in %s\"),\n\t\t\t\t    d->edit_path);\n\t\texit(status);\n\t}\n}\n\nstatic void append_separator(struct strbuf *message)\n{\n\tsize_t sep_len = 0;\n\n\tif (!separator)\n\t\treturn;\n\telse if ((sep_len = strlen(separator)) && separator[sep_len - 1] == '\\n')\n\t\tstrbuf_addstr(message, separator);\n\telse\n\t\tstrbuf_addf(message, \"%s%s\", separator, \"\\n\");\n}\n\nstatic void concat_messages(struct note_data *d)\n{\n\tstruct strbuf msg = STRBUF_INIT;\n\tsize_t i;\n\n\tfor (i = 0; i < d->msg_nr ; i++) {\n\t\tif (d->buf.len)\n\t\t\tappend_separator(&d->buf);\n\t\tstrbuf_add(&msg, d->messages[i]->buf.buf, d->messages[i]->buf.len);\n\t\tstrbuf_addbuf(&d->buf, &msg);\n\t\tif ((d->stripspace == UNSPECIFIED &&\n\t\t     d->messages[i]->stripspace == STRIPSPACE) ||\n\t\t    d->stripspace == STRIPSPACE)\n\t\t\tstrbuf_stripspace(&d->buf, 0);\n\t\tstrbuf_reset(&msg);\n\t}\n\tstrbuf_release(&msg);\n}\n\nstatic int parse_msg_arg(const struct option *opt, const char *arg, int unset)\n{\n\tstruct note_data *d = opt->value;\n\tstruct note_msg *msg = xmalloc(sizeof(*msg));\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tstrbuf_init(&msg->buf, strlen(arg));\n\tstrbuf_addstr(&msg->buf, arg);\n\tALLOC_GROW_BY(d->messages, d->msg_nr, 1, d->msg_alloc);\n\td->messages[d->msg_nr - 1] = msg;\n\tmsg->stripspace = STRIPSPACE;\n\treturn 0;\n}\n\nstatic int parse_file_arg(const struct option *opt, const char *arg, int unset)\n{\n\tstruct note_data *d = opt->value;\n\tstruct note_msg *msg = xmalloc(sizeof(*msg));\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tstrbuf_init(&msg->buf , 0);\n\tif (!strcmp(arg, \"-\")) {\n\t\tif (strbuf_read(&msg->buf, 0, 1024) < 0)\n\t\t\tdie_errno(_(\"cannot read '%s'\"), arg);\n\t} else if (strbuf_read_file(&msg->buf, arg, 1024) < 0)\n\t\tdie_errno(_(\"could not open or read '%s'\"), arg);\n\n\tALLOC_GROW_BY(d->messages, d->msg_nr, 1, d->msg_alloc);\n\td->messages[d->msg_nr - 1] = msg;\n\tmsg->stripspace = STRIPSPACE;\n\treturn 0;\n}\n\nstatic int parse_reuse_arg(const struct option *opt, const char *arg, int unset)\n{\n\tstruct note_data *d = opt->value;\n\tstruct note_msg *msg = xmalloc(sizeof(*msg));\n\tchar *value;\n\tstruct object_id object;\n\tenum object_type type;\n\tunsigned long len;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tstrbuf_init(&msg->buf, 0);\n\tif (repo_get_oid(the_repository, arg, &object))\n\t\tdie(_(\"failed to resolve '%s' as a valid ref.\"), arg);\n\tif (!(value = repo_read_object_file(the_repository, &object, &type, &len)))\n\t\tdie(_(\"failed to read object '%s'.\"), arg);\n\tif (type != OBJ_BLOB) {\n\t\tstrbuf_release(&msg->buf);\n\t\tfree(value);\n\t\tfree(msg);\n\t\tdie(_(\"cannot read note data from non-blob object '%s'.\"), arg);\n\t}\n\n\tstrbuf_add(&msg->buf, value, len);\n\tfree(value);\n\n\tmsg->buf.len = len;\n\tALLOC_GROW_BY(d->messages, d->msg_nr, 1, d->msg_alloc);\n\td->messages[d->msg_nr - 1] = msg;\n\tmsg->stripspace = NO_STRIPSPACE;\n\treturn 0;\n}\n\nstatic int parse_reedit_arg(const struct option *opt, const char *arg, int unset)\n{\n\tstruct note_data *d = opt->value;\n\tBUG_ON_OPT_NEG(unset);\n\td->use_editor = 1;\n\treturn parse_reuse_arg(opt, arg, unset);\n}\n\nstatic int parse_separator_arg(const struct option *opt, const char *arg,\n\t\t\t       int unset)\n{\n\tif (unset)\n\t\t*(const char **)opt->value = NULL;\n\telse\n\t\t*(const char **)opt->value = arg ? arg : \"\\n\";\n\treturn 0;\n}\n\nstatic int notes_copy_from_stdin(int force, const char *rewrite_cmd)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct notes_rewrite_cfg *c = NULL;\n\tstruct notes_tree *t = NULL;\n\tint ret = 0;\n\tconst char *msg = \"Notes added by 'git notes copy'\";\n\n\tif (rewrite_cmd) {\n\t\tc = init_copy_notes_for_rewrite(rewrite_cmd);\n\t\tif (!c)\n\t\t\treturn 0;\n\t} else {\n\t\tinit_notes(NULL, NULL, NULL, NOTES_INIT_WRITABLE);\n\t\tt = &default_notes_tree;\n\t}\n\n\twhile (strbuf_getline_lf(&buf, stdin) != EOF) {\n\t\tstruct object_id from_obj, to_obj;\n\t\tstruct strbuf **split;\n\t\tint err;\n\n\t\tsplit = strbuf_split(&buf, ' ');\n\t\tif (!split[0] || !split[1])\n\t\t\tdie(_(\"malformed input line: '%s'.\"), buf.buf);\n\t\tstrbuf_rtrim(split[0]);\n\t\tstrbuf_rtrim(split[1]);\n\t\tif (repo_get_oid(the_repository, split[0]->buf, &from_obj))\n\t\t\tdie(_(\"failed to resolve '%s' as a valid ref.\"), split[0]->buf);\n\t\tif (repo_get_oid(the_repository, split[1]->buf, &to_obj))\n\t\t\tdie(_(\"failed to resolve '%s' as a valid ref.\"), split[1]->buf);\n\n\t\tif (rewrite_cmd)\n\t\t\terr = copy_note_for_rewrite(c, &from_obj, &to_obj);\n\t\telse\n\t\t\terr = copy_note(t, &from_obj, &to_obj, force,\n\t\t\t\t\tcombine_notes_overwrite);\n\n\t\tif (err) {\n\t\t\terror(_(\"failed to copy notes from '%s' to '%s'\"),\n\t\t\t      split[0]->buf, split[1]->buf);\n\t\t\tret = 1;\n\t\t}\n\n\t\tstrbuf_list_free(split);\n\t}\n\n\tif (!rewrite_cmd) {\n\t\tcommit_notes(the_repository, t, msg);\n\t\tfree_notes(t);\n\t} else {\n\t\tfinish_copy_notes_for_rewrite(the_repository, c, msg);\n\t}\n\tstrbuf_release(&buf);\n\treturn ret;\n}\n\nstatic struct notes_tree *init_notes_check(const char *subcommand,\n\t\t\t\t\t   int flags)\n{\n\tstruct notes_tree *t;\n\tconst char *ref;\n\tinit_notes(NULL, NULL, NULL, flags);\n\tt = &default_notes_tree;\n\n\tref = (flags & NOTES_INIT_WRITABLE) ? t->update_ref : t->ref;\n\tif (!starts_with(ref, \"refs/notes/\"))\n\t\t/*\n\t\t * TRANSLATORS: the first %s will be replaced by a git\n\t\t * notes command: 'add', 'merge', 'remove', etc.\n\t\t */\n\t\tdie(_(\"refusing to %s notes in %s (outside of refs/notes/)\"),\n\t\t    subcommand, ref);\n\treturn t;\n}\n\nstatic int list(int argc, const char **argv, const char *prefix)\n{\n\tstruct notes_tree *t;\n\tstruct object_id object;\n\tconst struct object_id *note;\n\tint retval = -1;\n\tstruct option options[] = {\n\t\tOPT_END()\n\t};\n\n\tif (argc)\n\t\targc = parse_options(argc, argv, prefix, options,\n\t\t\t\t     git_notes_list_usage, 0);\n\n\tif (1 < argc) {\n\t\terror(_(\"too many arguments\"));\n\t\tusage_with_options(git_notes_list_usage, options);\n\t}\n\n\tt = init_notes_check(\"list\", 0);\n\tif (argc) {\n\t\tif (repo_get_oid(the_repository, argv[0], &object))\n\t\t\tdie(_(\"failed to resolve '%s' as a valid ref.\"), argv[0]);\n\t\tnote = get_note(t, &object);\n\t\tif (note) {\n\t\t\tputs(oid_to_hex(note));\n\t\t\tretval = 0;\n\t\t} else\n\t\t\tretval = error(_(\"no note found for object %s.\"),\n\t\t\t\t       oid_to_hex(&object));\n\t} else\n\t\tretval = for_each_note(t, 0, list_each_note, NULL);\n\n\tfree_notes(t);\n\treturn retval;\n}\n\nstatic int append_edit(int argc, const char **argv, const char *prefix);\n\nstatic int add(int argc, const char **argv, const char *prefix)\n{\n\tint force = 0, allow_empty = 0;\n\tconst char *object_ref;\n\tstruct notes_tree *t;\n\tstruct object_id object, new_note;\n\tconst struct object_id *note;\n\tstruct note_data d = { .buf = STRBUF_INIT, .stripspace = UNSPECIFIED };\n\n\tstruct option options[] = {\n\t\tOPT_CALLBACK_F('m', \"message\", &d, N_(\"message\"),\n\t\t\tN_(\"note contents as a string\"), PARSE_OPT_NONEG,\n\t\t\tparse_msg_arg),\n\t\tOPT_CALLBACK_F('F', \"file\", &d, N_(\"file\"),\n\t\t\tN_(\"note contents in a file\"), PARSE_OPT_NONEG,\n\t\t\tparse_file_arg),\n\t\tOPT_CALLBACK_F('c', \"reedit-message\", &d, N_(\"object\"),\n\t\t\tN_(\"reuse and edit specified note object\"), PARSE_OPT_NONEG,\n\t\t\tparse_reedit_arg),\n\t\tOPT_CALLBACK_F('C', \"reuse-message\", &d, N_(\"object\"),\n\t\t\tN_(\"reuse specified note object\"), PARSE_OPT_NONEG,\n\t\t\tparse_reuse_arg),\n\t\tOPT_BOOL(0, \"allow-empty\", &allow_empty,\n\t\t\tN_(\"allow storing empty note\")),\n\t\tOPT__FORCE(&force, N_(\"replace existing notes\"), PARSE_OPT_NOCOMPLETE),\n\t\tOPT_CALLBACK_F(0, \"separator\", &separator,\n\t\t\tN_(\"<paragraph-break>\"),\n\t\t\tN_(\"insert <paragraph-break> between paragraphs\"),\n\t\t\tPARSE_OPT_OPTARG, parse_separator_arg),\n\t\tOPT_BOOL(0, \"stripspace\", &d.stripspace,\n\t\t\tN_(\"remove unnecessary whitespace\")),\n\t\tOPT_END()\n\t};\n\n\targc = parse_options(argc, argv, prefix, options, git_notes_add_usage,\n\t\t\t     PARSE_OPT_KEEP_ARGV0);\n\n\tif (2 < argc) {\n\t\terror(_(\"too many arguments\"));\n\t\tusage_with_options(git_notes_add_usage, options);\n\t}\n\n\tif (d.msg_nr)\n\t\tconcat_messages(&d);\n\td.given = !!d.buf.len;\n\n\tobject_ref = argc > 1 ? argv[1] : \"HEAD\";\n\n\tif (repo_get_oid(the_repository, object_ref, &object))\n\t\tdie(_(\"failed to resolve '%s' as a valid ref.\"), object_ref);\n\n\tt = init_notes_check(\"add\", NOTES_INIT_WRITABLE);\n\tnote = get_note(t, &object);\n\n\tif (note) {\n\t\tif (!force) {\n\t\t\tfree_notes(t);\n\t\t\tif (d.given) {\n\t\t\t\tfree_note_data(&d);\n\t\t\t\treturn error(_(\"Cannot add notes. \"\n\t\t\t\t\t\"Found existing notes for object %s. \"\n\t\t\t\t\t\"Use '-f' to overwrite existing notes\"),\n\t\t\t\t\toid_to_hex(&object));\n\t\t\t}\n\t\t\t/*\n\t\t\t * Redirect to \"edit\" subcommand.\n\t\t\t *\n\t\t\t * We only end up here if none of -m/-F/-c/-C or -f are\n\t\t\t * given. The original args are therefore still in\n\t\t\t * argv[0-1].\n\t\t\t */\n\t\t\targv[0] = \"edit\";\n\t\t\treturn append_edit(argc, argv, prefix);\n\t\t}\n\t\tfprintf(stderr, _(\"Overwriting existing notes for object %s\\n\"),\n\t\t\toid_to_hex(&object));\n\t}\n\n\tprepare_note_data(&object, &d, note);\n\tif (d.buf.len || allow_empty) {\n\t\twrite_note_data(&d, &new_note);\n\t\tif (add_note(t, &object, &new_note, combine_notes_overwrite))\n\t\t\tBUG(\"combine_notes_overwrite failed\");\n\t\tcommit_notes(the_repository, t,\n\t\t\t     \"Notes added by 'git notes add'\");\n\t} else {\n\t\tfprintf(stderr, _(\"Removing note for object %s\\n\"),\n\t\t\toid_to_hex(&object));\n\t\tremove_note(t, object.hash);\n\t\tcommit_notes(the_repository, t,\n\t\t\t     \"Notes removed by 'git notes add'\");\n\t}\n\n\tfree_note_data(&d);\n\tfree_notes(t);\n\treturn 0;\n}\n\nstatic int copy(int argc, const char **argv, const char *prefix)\n{\n\tint retval = 0, force = 0, from_stdin = 0;\n\tconst struct object_id *from_note, *note;\n\tconst char *object_ref;\n\tstruct object_id object, from_obj;\n\tstruct notes_tree *t;\n\tconst char *rewrite_cmd = NULL;\n\tstruct option options[] = {\n\t\tOPT__FORCE(&force, N_(\"replace existing notes\"), PARSE_OPT_NOCOMPLETE),\n\t\tOPT_BOOL(0, \"stdin\", &from_stdin, N_(\"read objects from stdin\")),\n\t\tOPT_STRING(0, \"for-rewrite\", &rewrite_cmd, N_(\"command\"),\n\t\t\t   N_(\"load rewriting config for <command> (implies \"\n\t\t\t      \"--stdin)\")),\n\t\tOPT_END()\n\t};\n\n\targc = parse_options(argc, argv, prefix, options, git_notes_copy_usage,\n\t\t\t     0);\n\n\tif (from_stdin || rewrite_cmd) {\n\t\tif (argc) {\n\t\t\terror(_(\"too many arguments\"));\n\t\t\tusage_with_options(git_notes_copy_usage, options);\n\t\t} else {\n\t\t\treturn notes_copy_from_stdin(force, rewrite_cmd);\n\t\t}\n\t}\n\n\tif (argc < 1) {\n\t\terror(_(\"too few arguments\"));\n\t\tusage_with_options(git_notes_copy_usage, options);\n\t}\n\tif (2 < argc) {\n\t\terror(_(\"too many arguments\"));\n\t\tusage_with_options(git_notes_copy_usage, options);\n\t}\n\n\tif (repo_get_oid(the_repository, argv[0], &from_obj))\n\t\tdie(_(\"failed to resolve '%s' as a valid ref.\"), argv[0]);\n\n\tobject_ref = 1 < argc ? argv[1] : \"HEAD\";\n\n\tif (repo_get_oid(the_repository, object_ref, &object))\n\t\tdie(_(\"failed to resolve '%s' as a valid ref.\"), object_ref);\n\n\tt = init_notes_check(\"copy\", NOTES_INIT_WRITABLE);\n\tnote = get_note(t, &object);\n\n\tif (note) {\n\t\tif (!force) {\n\t\t\tretval = error(_(\"Cannot copy notes. Found existing \"\n\t\t\t\t       \"notes for object %s. Use '-f' to \"\n\t\t\t\t       \"overwrite existing notes\"),\n\t\t\t\t       oid_to_hex(&object));\n\t\t\tgoto out;\n\t\t}\n\t\tfprintf(stderr, _(\"Overwriting existing notes for object %s\\n\"),\n\t\t\toid_to_hex(&object));\n\t}\n\n\tfrom_note = get_note(t, &from_obj);\n\tif (!from_note) {\n\t\tretval = error(_(\"missing notes on source object %s. Cannot \"\n\t\t\t       \"copy.\"), oid_to_hex(&from_obj));\n\t\tgoto out;\n\t}\n\n\tif (add_note(t, &object, from_note, combine_notes_overwrite))\n\t\tBUG(\"combine_notes_overwrite failed\");\n\tcommit_notes(the_repository, t,\n\t\t     \"Notes added by 'git notes copy'\");\nout:\n\tfree_notes(t);\n\treturn retval;\n}\n\nstatic int append_edit(int argc, const char **argv, const char *prefix)\n{\n\tint allow_empty = 0;\n\tconst char *object_ref;\n\tstruct notes_tree *t;\n\tstruct object_id object, new_note;\n\tconst struct object_id *note;\n\tchar *logmsg;\n\tconst char * const *usage;\n\tstruct note_data d = { .buf = STRBUF_INIT, .stripspace = UNSPECIFIED };\n\tstruct option options[] = {\n\t\tOPT_CALLBACK_F('m', \"message\", &d, N_(\"message\"),\n\t\t\tN_(\"note contents as a string\"), PARSE_OPT_NONEG,\n\t\t\tparse_msg_arg),\n\t\tOPT_CALLBACK_F('F', \"file\", &d, N_(\"file\"),\n\t\t\tN_(\"note contents in a file\"), PARSE_OPT_NONEG,\n\t\t\tparse_file_arg),\n\t\tOPT_CALLBACK_F('c', \"reedit-message\", &d, N_(\"object\"),\n\t\t\tN_(\"reuse and edit specified note object\"), PARSE_OPT_NONEG,\n\t\t\tparse_reedit_arg),\n\t\tOPT_CALLBACK_F('C', \"reuse-message\", &d, N_(\"object\"),\n\t\t\tN_(\"reuse specified note object\"), PARSE_OPT_NONEG,\n\t\t\tparse_reuse_arg),\n\t\tOPT_BOOL(0, \"allow-empty\", &allow_empty,\n\t\t\tN_(\"allow storing empty note\")),\n\t\tOPT_CALLBACK_F(0, \"separator\", &separator,\n\t\t\tN_(\"<paragraph-break>\"),\n\t\t\tN_(\"insert <paragraph-break> between paragraphs\"),\n\t\t\tPARSE_OPT_OPTARG, parse_separator_arg),\n\t\tOPT_BOOL(0, \"stripspace\", &d.stripspace,\n\t\t\tN_(\"remove unnecessary whitespace\")),\n\t\tOPT_END()\n\t};\n\tint edit = !strcmp(argv[0], \"edit\");\n\n\tusage = edit ? git_notes_edit_usage : git_notes_append_usage;\n\targc = parse_options(argc, argv, prefix, options, usage,\n\t\t\t     PARSE_OPT_KEEP_ARGV0);\n\n\tif (2 < argc) {\n\t\terror(_(\"too many arguments\"));\n\t\tusage_with_options(usage, options);\n\t}\n\n\tif (d.msg_nr)\n\t\tconcat_messages(&d);\n\td.given = !!d.buf.len;\n\n\tif (d.given && edit)\n\t\tfprintf(stderr, _(\"The -m/-F/-c/-C options have been deprecated \"\n\t\t\t\"for the 'edit' subcommand.\\n\"\n\t\t\t\"Please use 'git notes add -f -m/-F/-c/-C' instead.\\n\"));\n\n\tobject_ref = 1 < argc ? argv[1] : \"HEAD\";\n\n\tif (repo_get_oid(the_repository, object_ref, &object))\n\t\tdie(_(\"failed to resolve '%s' as a valid ref.\"), object_ref);\n\n\tt = init_notes_check(argv[0], NOTES_INIT_WRITABLE);\n\tnote = get_note(t, &object);\n\n\tprepare_note_data(&object, &d, edit && note ? note : NULL);\n\n\tif (note && !edit) {\n\t\t/* Append buf to previous note contents */\n\t\tunsigned long size;\n\t\tenum object_type type;\n\t\tstruct strbuf buf = STRBUF_INIT;\n\t\tchar *prev_buf = repo_read_object_file(the_repository, note, &type, &size);\n\n\t\tif (prev_buf && size)\n\t\t\tstrbuf_add(&buf, prev_buf, size);\n\t\tif (d.buf.len && prev_buf && size)\n\t\t\tappend_separator(&buf);\n\t\tstrbuf_insert(&d.buf, 0, buf.buf, buf.len);\n\n\t\tfree(prev_buf);\n\t\tstrbuf_release(&buf);\n\t}\n\n\tif (d.buf.len || allow_empty) {\n\t\twrite_note_data(&d, &new_note);\n\t\tif (add_note(t, &object, &new_note, combine_notes_overwrite))\n\t\t\tBUG(\"combine_notes_overwrite failed\");\n\t\tlogmsg = xstrfmt(\"Notes added by 'git notes %s'\", argv[0]);\n\t} else {\n\t\tfprintf(stderr, _(\"Removing note for object %s\\n\"),\n\t\t\toid_to_hex(&object));\n\t\tremove_note(t, object.hash);\n\t\tlogmsg = xstrfmt(\"Notes removed by 'git notes %s'\", argv[0]);\n\t}\n\tcommit_notes(the_repository, t, logmsg);\n\n\tfree(logmsg);\n\tfree_note_data(&d);\n\tfree_notes(t);\n\treturn 0;\n}\n\nstatic int show(int argc, const char **argv, const char *prefix)\n{\n\tconst char *object_ref;\n\tstruct notes_tree *t;\n\tstruct object_id object;\n\tconst struct object_id *note;\n\tint retval;\n\tstruct option options[] = {\n\t\tOPT_END()\n\t};\n\n\targc = parse_options(argc, argv, prefix, options, git_notes_show_usage,\n\t\t\t     0);\n\n\tif (1 < argc) {\n\t\terror(_(\"too many arguments\"));\n\t\tusage_with_options(git_notes_show_usage, options);\n\t}\n\n\tobject_ref = argc ? argv[0] : \"HEAD\";\n\n\tif (repo_get_oid(the_repository, object_ref, &object))\n\t\tdie(_(\"failed to resolve '%s' as a valid ref.\"), object_ref);\n\n\tt = init_notes_check(\"show\", 0);\n\tnote = get_note(t, &object);\n\n\tif (!note)\n\t\tretval = error(_(\"no note found for object %s.\"),\n\t\t\t       oid_to_hex(&object));\n\telse {\n\t\tconst char *show_args[3] = {\"show\", oid_to_hex(note), NULL};\n\t\tretval = execv_git_cmd(show_args);\n\t}\n\tfree_notes(t);\n\treturn retval;\n}\n\nstatic int merge_abort(struct notes_merge_options *o)\n{\n\tint ret = 0;\n\n\t/*\n\t * Remove .git/NOTES_MERGE_PARTIAL and .git/NOTES_MERGE_REF, and call\n\t * notes_merge_abort() to remove .git/NOTES_MERGE_WORKTREE.\n\t */\n\n\tif (delete_ref(NULL, \"NOTES_MERGE_PARTIAL\", NULL, 0))\n\t\tret += error(_(\"failed to delete ref NOTES_MERGE_PARTIAL\"));\n\tif (delete_ref(NULL, \"NOTES_MERGE_REF\", NULL, REF_NO_DEREF))\n\t\tret += error(_(\"failed to delete ref NOTES_MERGE_REF\"));\n\tif (notes_merge_abort(o))\n\t\tret += error(_(\"failed to remove 'git notes merge' worktree\"));\n\treturn ret;\n}\n\nstatic int merge_commit(struct notes_merge_options *o)\n{\n\tstruct strbuf msg = STRBUF_INIT;\n\tstruct object_id oid, parent_oid;\n\tstruct notes_tree *t;\n\tstruct commit *partial;\n\tstruct pretty_print_context pretty_ctx;\n\tvoid *local_ref_to_free;\n\tint ret;\n\n\t/*\n\t * Read partial merge result from .git/NOTES_MERGE_PARTIAL,\n\t * and target notes ref from .git/NOTES_MERGE_REF.\n\t */\n\n\tif (repo_get_oid(the_repository, \"NOTES_MERGE_PARTIAL\", &oid))\n\t\tdie(_(\"failed to read ref NOTES_MERGE_PARTIAL\"));\n\telse if (!(partial = lookup_commit_reference(the_repository, &oid)))\n\t\tdie(_(\"could not find commit from NOTES_MERGE_PARTIAL.\"));\n\telse if (repo_parse_commit(the_repository, partial))\n\t\tdie(_(\"could not parse commit from NOTES_MERGE_PARTIAL.\"));\n\n\tif (partial->parents)\n\t\toidcpy(&parent_oid, &partial->parents->item->object.oid);\n\telse\n\t\toidclr(&parent_oid);\n\n\tCALLOC_ARRAY(t, 1);\n\tinit_notes(t, \"NOTES_MERGE_PARTIAL\", combine_notes_overwrite, 0);\n\n\to->local_ref = local_ref_to_free =\n\t\tresolve_refdup(\"NOTES_MERGE_REF\", 0, &oid, NULL);\n\tif (!o->local_ref)\n\t\tdie(_(\"failed to resolve NOTES_MERGE_REF\"));\n\n\tif (notes_merge_commit(o, t, partial, &oid))\n\t\tdie(_(\"failed to finalize notes merge\"));\n\n\t/* Reuse existing commit message in reflog message */\n\tmemset(&pretty_ctx, 0, sizeof(pretty_ctx));\n\trepo_format_commit_message(the_repository, partial, \"%s\", &msg,\n\t\t\t\t   &pretty_ctx);\n\tstrbuf_trim(&msg);\n\tstrbuf_insertstr(&msg, 0, \"notes: \");\n\tupdate_ref(msg.buf, o->local_ref, &oid,\n\t\t   is_null_oid(&parent_oid) ? NULL : &parent_oid,\n\t\t   0, UPDATE_REFS_DIE_ON_ERR);\n\n\tfree_notes(t);\n\tstrbuf_release(&msg);\n\tret = merge_abort(o);\n\tfree(local_ref_to_free);\n\treturn ret;\n}\n\nstatic int git_config_get_notes_strategy(const char *key,\n\t\t\t\t\t enum notes_merge_strategy *strategy)\n{\n\tchar *value;\n\n\tif (git_config_get_string(key, &value))\n\t\treturn 1;\n\tif (parse_notes_merge_strategy(value, strategy))\n\t\tgit_die_config(key, _(\"unknown notes merge strategy %s\"), value);\n\n\tfree(value);\n\treturn 0;\n}\n\nstatic int merge(int argc, const char **argv, const char *prefix)\n{\n\tstruct strbuf remote_ref = STRBUF_INIT, msg = STRBUF_INIT;\n\tstruct object_id result_oid;\n\tstruct notes_tree *t;\n\tstruct notes_merge_options o;\n\tint do_merge = 0, do_commit = 0, do_abort = 0;\n\tint verbosity = 0, result;\n\tconst char *strategy = NULL;\n\tstruct option options[] = {\n\t\tOPT_GROUP(N_(\"General options\")),\n\t\tOPT__VERBOSITY(&verbosity),\n\t\tOPT_GROUP(N_(\"Merge options\")),\n\t\tOPT_STRING('s', \"strategy\", &strategy, N_(\"strategy\"),\n\t\t\t   N_(\"resolve notes conflicts using the given strategy \"\n\t\t\t      \"(manual/ours/theirs/union/cat_sort_uniq)\")),\n\t\tOPT_GROUP(N_(\"Committing unmerged notes\")),\n\t\tOPT_SET_INT_F(0, \"commit\", &do_commit,\n\t\t\t      N_(\"finalize notes merge by committing unmerged notes\"),\n\t\t\t      1, PARSE_OPT_NONEG),\n\t\tOPT_GROUP(N_(\"Aborting notes merge resolution\")),\n\t\tOPT_SET_INT_F(0, \"abort\", &do_abort,\n\t\t\t      N_(\"abort notes merge\"),\n\t\t\t      1, PARSE_OPT_NONEG),\n\t\tOPT_END()\n\t};\n\n\targc = parse_options(argc, argv, prefix, options,\n\t\t\t     git_notes_merge_usage, 0);\n\n\tif (strategy || do_commit + do_abort == 0)\n\t\tdo_merge = 1;\n\tif (do_merge + do_commit + do_abort != 1) {\n\t\terror(_(\"cannot mix --commit, --abort or -s/--strategy\"));\n\t\tusage_with_options(git_notes_merge_usage, options);\n\t}\n\n\tif (do_merge && argc != 1) {\n\t\terror(_(\"must specify a notes ref to merge\"));\n\t\tusage_with_options(git_notes_merge_usage, options);\n\t} else if (!do_merge && argc) {\n\t\terror(_(\"too many arguments\"));\n\t\tusage_with_options(git_notes_merge_usage, options);\n\t}\n\n\tinit_notes_merge_options(the_repository, &o);\n\to.verbosity = verbosity + NOTES_MERGE_VERBOSITY_DEFAULT;\n\n\tif (do_abort)\n\t\treturn merge_abort(&o);\n\tif (do_commit)\n\t\treturn merge_commit(&o);\n\n\to.local_ref = default_notes_ref();\n\tstrbuf_addstr(&remote_ref, argv[0]);\n\texpand_loose_notes_ref(&remote_ref);\n\to.remote_ref = remote_ref.buf;\n\n\tt = init_notes_check(\"merge\", NOTES_INIT_WRITABLE);\n\n\tif (strategy) {\n\t\tif (parse_notes_merge_strategy(strategy, &o.strategy)) {\n\t\t\terror(_(\"unknown -s/--strategy: %s\"), strategy);\n\t\t\tusage_with_options(git_notes_merge_usage, options);\n\t\t}\n\t} else {\n\t\tstruct strbuf merge_key = STRBUF_INIT;\n\t\tconst char *short_ref = NULL;\n\n\t\tif (!skip_prefix(o.local_ref, \"refs/notes/\", &short_ref))\n\t\t\tBUG(\"local ref %s is outside of refs/notes/\",\n\t\t\t    o.local_ref);\n\n\t\tstrbuf_addf(&merge_key, \"notes.%s.mergeStrategy\", short_ref);\n\n\t\tif (git_config_get_notes_strategy(merge_key.buf, &o.strategy))\n\t\t\tgit_config_get_notes_strategy(\"notes.mergeStrategy\", &o.strategy);\n\n\t\tstrbuf_release(&merge_key);\n\t}\n\n\tstrbuf_addf(&msg, \"notes: Merged notes from %s into %s\",\n\t\t    remote_ref.buf, default_notes_ref());\n\tstrbuf_add(&(o.commit_msg), msg.buf + 7, msg.len - 7); /* skip \"notes: \" */\n\n\tresult = notes_merge(&o, t, &result_oid);\n\n\tif (result >= 0) /* Merge resulted (trivially) in result_oid */\n\t\t/* Update default notes ref with new commit */\n\t\tupdate_ref(msg.buf, default_notes_ref(), &result_oid, NULL, 0,\n\t\t\t   UPDATE_REFS_DIE_ON_ERR);\n\telse { /* Merge has unresolved conflicts */\n\t\tstruct worktree **worktrees;\n\t\tconst struct worktree *wt;\n\t\t/* Update .git/NOTES_MERGE_PARTIAL with partial merge result */\n\t\tupdate_ref(msg.buf, \"NOTES_MERGE_PARTIAL\", &result_oid, NULL,\n\t\t\t   0, UPDATE_REFS_DIE_ON_ERR);\n\t\t/* Store ref-to-be-updated into .git/NOTES_MERGE_REF */\n\t\tworktrees = get_worktrees();\n\t\twt = find_shared_symref(worktrees, \"NOTES_MERGE_REF\",\n\t\t\t\t\tdefault_notes_ref());\n\t\tif (wt)\n\t\t\tdie(_(\"a notes merge into %s is already in-progress at %s\"),\n\t\t\t    default_notes_ref(), wt->path);\n\t\tfree_worktrees(worktrees);\n\t\tif (create_symref(\"NOTES_MERGE_REF\", default_notes_ref(), NULL))\n\t\t\tdie(_(\"failed to store link to current notes ref (%s)\"),\n\t\t\t    default_notes_ref());\n\t\tfprintf(stderr, _(\"Automatic notes merge failed. Fix conflicts in %s \"\n\t\t\t\t  \"and commit the result with 'git notes merge --commit', \"\n\t\t\t\t  \"or abort the merge with 'git notes merge --abort'.\\n\"),\n\t\t\tgit_path(NOTES_MERGE_WORKTREE));\n\t}\n\n\tfree_notes(t);\n\tstrbuf_release(&remote_ref);\n\tstrbuf_release(&msg);\n\treturn result < 0; /* return non-zero on conflicts */\n}\n\n#define IGNORE_MISSING 1\n\nstatic int remove_one_note(struct notes_tree *t, const char *name, unsigned flag)\n{\n\tint status;\n\tstruct object_id oid;\n\tif (repo_get_oid(the_repository, name, &oid))\n\t\treturn error(_(\"Failed to resolve '%s' as a valid ref.\"), name);\n\tstatus = remove_note(t, oid.hash);\n\tif (status)\n\t\tfprintf(stderr, _(\"Object %s has no note\\n\"), name);\n\telse\n\t\tfprintf(stderr, _(\"Removing note for object %s\\n\"), name);\n\treturn (flag & IGNORE_MISSING) ? 0 : status;\n}\n\nstatic int remove_cmd(int argc, const char **argv, const char *prefix)\n{\n\tunsigned flag = 0;\n\tint from_stdin = 0;\n\tstruct option options[] = {\n\t\tOPT_BIT(0, \"ignore-missing\", &flag,\n\t\t\tN_(\"attempt to remove non-existent note is not an error\"),\n\t\t\tIGNORE_MISSING),\n\t\tOPT_BOOL(0, \"stdin\", &from_stdin,\n\t\t\t    N_(\"read object names from the standard input\")),\n\t\tOPT_END()\n\t};\n\tstruct notes_tree *t;\n\tint retval = 0;\n\n\targc = parse_options(argc, argv, prefix, options,\n\t\t\t     git_notes_remove_usage, 0);\n\n\tt = init_notes_check(\"remove\", NOTES_INIT_WRITABLE);\n\n\tif (!argc && !from_stdin) {\n\t\tretval = remove_one_note(t, \"HEAD\", flag);\n\t} else {\n\t\twhile (*argv) {\n\t\t\tretval |= remove_one_note(t, *argv, flag);\n\t\t\targv++;\n\t\t}\n\t}\n\tif (from_stdin) {\n\t\tstruct strbuf sb = STRBUF_INIT;\n\t\twhile (strbuf_getwholeline(&sb, stdin, '\\n') != EOF) {\n\t\t\tstrbuf_rtrim(&sb);\n\t\t\tretval |= remove_one_note(t, sb.buf, flag);\n\t\t}\n\t\tstrbuf_release(&sb);\n\t}\n\tif (!retval)\n\t\tcommit_notes(the_repository, t,\n\t\t\t     \"Notes removed by 'git notes remove'\");\n\tfree_notes(t);\n\treturn retval;\n}\n\nstatic int prune(int argc, const char **argv, const char *prefix)\n{\n\tstruct notes_tree *t;\n\tint show_only = 0, verbose = 0;\n\tstruct option options[] = {\n\t\tOPT__DRY_RUN(&show_only, N_(\"do not remove, show only\")),\n\t\tOPT__VERBOSE(&verbose, N_(\"report pruned notes\")),\n\t\tOPT_END()\n\t};\n\n\targc = parse_options(argc, argv, prefix, options, git_notes_prune_usage,\n\t\t\t     0);\n\n\tif (argc) {\n\t\terror(_(\"too many arguments\"));\n\t\tusage_with_options(git_notes_prune_usage, options);\n\t}\n\n\tt = init_notes_check(\"prune\", NOTES_INIT_WRITABLE);\n\n\tprune_notes(t, (verbose ? NOTES_PRUNE_VERBOSE : 0) |\n\t\t(show_only ? NOTES_PRUNE_VERBOSE|NOTES_PRUNE_DRYRUN : 0) );\n\tif (!show_only)\n\t\tcommit_notes(the_repository, t,\n\t\t\t     \"Notes removed by 'git notes prune'\");\n\tfree_notes(t);\n\treturn 0;\n}\n\nstatic int get_ref(int argc, const char **argv, const char *prefix)\n{\n\tstruct option options[] = { OPT_END() };\n\targc = parse_options(argc, argv, prefix, options,\n\t\t\t     git_notes_get_ref_usage, 0);\n\n\tif (argc) {\n\t\terror(_(\"too many arguments\"));\n\t\tusage_with_options(git_notes_get_ref_usage, options);\n\t}\n\n\tputs(default_notes_ref());\n\treturn 0;\n}\n\nint cmd_notes(int argc, const char **argv, const char *prefix)\n{\n\tconst char *override_notes_ref = NULL;\n\tparse_opt_subcommand_fn *fn = NULL;\n\tstruct option options[] = {\n\t\tOPT_STRING(0, \"ref\", &override_notes_ref, N_(\"notes-ref\"),\n\t\t\t   N_(\"use notes from <notes-ref>\")),\n\t\tOPT_SUBCOMMAND(\"list\", &fn, list),\n\t\tOPT_SUBCOMMAND(\"add\", &fn, add),\n\t\tOPT_SUBCOMMAND(\"copy\", &fn, copy),\n\t\tOPT_SUBCOMMAND(\"append\", &fn, append_edit),\n\t\tOPT_SUBCOMMAND(\"edit\", &fn, append_edit),\n\t\tOPT_SUBCOMMAND(\"show\", &fn, show),\n\t\tOPT_SUBCOMMAND(\"merge\", &fn, merge),\n\t\tOPT_SUBCOMMAND(\"remove\", &fn, remove_cmd),\n\t\tOPT_SUBCOMMAND(\"prune\", &fn, prune),\n\t\tOPT_SUBCOMMAND(\"get-ref\", &fn, get_ref),\n\t\tOPT_END()\n\t};\n\n\tgit_config(git_default_config, NULL);\n\targc = parse_options(argc, argv, prefix, options, git_notes_usage,\n\t\t\t     PARSE_OPT_SUBCOMMAND_OPTIONAL);\n\tif (!fn) {\n\t\tif (argc) {\n\t\t\terror(_(\"unknown subcommand: `%s'\"), argv[0]);\n\t\t\tusage_with_options(git_notes_usage, options);\n\t\t}\n\t\tfn = list;\n\t}\n\n\tif (override_notes_ref) {\n\t\tstruct strbuf sb = STRBUF_INIT;\n\t\tstrbuf_addstr(&sb, override_notes_ref);\n\t\texpand_notes_ref(&sb);\n\t\tsetenv(\"GIT_NOTES_REF\", sb.buf, 1);\n\t\tstrbuf_release(&sb);\n\t}\n\n\treturn !!fn(argc, argv, prefix);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00268e949cf9664ea9cb8d1d02e313306bf03e13",
  "sha1_ok": true,
  "size": 31870
}
