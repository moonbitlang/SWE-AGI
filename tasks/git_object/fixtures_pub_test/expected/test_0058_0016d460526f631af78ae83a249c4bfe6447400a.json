{
  "content": {
    "base64": "LyoKICogR0lUIC0gVGhlIGluZm9ybWF0aW9uIG1hbmFnZXIgZnJvbSBoZWxsCiAqCiAqIENvcHlyaWdodCAoQykgTGludXMgVG9ydmFsZHMsIDIwMDUKICoKICogVGhpcyBoYW5kbGVzIGJhc2ljIGdpdCBzaGExIG9iamVjdCBmaWxlcyAtIHBhY2tpbmcsIHVucGFja2luZywKICogY3JlYXRpb24gZXRjLgogKi8KI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgInN0cmluZy1saXN0LmgiCiNpbmNsdWRlICJsb2NrZmlsZS5oIgojaW5jbHVkZSAiZGVsdGEuaCIKI2luY2x1ZGUgInBhY2suaCIKI2luY2x1ZGUgImJsb2IuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAicnVuLWNvbW1hbmQuaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAidHJlZS5oIgojaW5jbHVkZSAidHJlZS13YWxrLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJwYWNrLXJldmluZGV4LmgiCiNpbmNsdWRlICJzaGExLWxvb2t1cC5oIgojaW5jbHVkZSAiYnVsay1jaGVja2luLmgiCiNpbmNsdWRlICJyZXBvc2l0b3J5LmgiCiNpbmNsdWRlICJyZXBsYWNlLW9iamVjdC5oIgojaW5jbHVkZSAic3RyZWFtaW5nLmgiCiNpbmNsdWRlICJkaXIuaCIKI2luY2x1ZGUgImxpc3QuaCIKI2luY2x1ZGUgIm1lcmdlc29ydC5oIgojaW5jbHVkZSAicXVvdGUuaCIKI2luY2x1ZGUgInBhY2tmaWxlLmgiCiNpbmNsdWRlICJmZXRjaC1vYmplY3QuaCIKI2luY2x1ZGUgIm9iamVjdC1zdG9yZS5oIgoKLyogVGhlIG1heGltdW0gc2l6ZSBmb3IgYW4gb2JqZWN0IGhlYWRlci4gKi8KI2RlZmluZSBNQVhfSEVBREVSX0xFTiAzMgoKCiNkZWZpbmUgRU1QVFlfVFJFRV9TSEExX0JJTl9MSVRFUkFMIFwKCSAiXHg0Ylx4ODJceDVkXHhjNlx4NDJceGNiXHg2ZVx4YjlceGEwXHg2MCIgXAoJICJceGU1XHg0Ylx4ZjhceGQ2XHg5Mlx4ODhceGZiXHhlZVx4NDlceDA0IgoKI2RlZmluZSBFTVBUWV9CTE9CX1NIQTFfQklOX0xJVEVSQUwgXAoJIlx4ZTZceDlkXHhlMlx4OWJceGIyXHhkMVx4ZDZceDQzXHg0Ylx4OGIiIFwKCSJceDI5XHhhZVx4NzdceDVhXHhkOFx4YzJceGU0XHg4Y1x4NTNceDkxIgoKY29uc3QgdW5zaWduZWQgY2hhciBudWxsX3NoYTFbR0lUX01BWF9SQVdTWl07CmNvbnN0IHN0cnVjdCBvYmplY3RfaWQgbnVsbF9vaWQ7CnN0YXRpYyBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkIGVtcHR5X3RyZWVfb2lkID0gewoJRU1QVFlfVFJFRV9TSEExX0JJTl9MSVRFUkFMCn07CnN0YXRpYyBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkIGVtcHR5X2Jsb2Jfb2lkID0gewoJRU1QVFlfQkxPQl9TSEExX0JJTl9MSVRFUkFMCn07CgpzdGF0aWMgdm9pZCBnaXRfaGFzaF9zaGExX2luaXQoZ2l0X2hhc2hfY3R4ICpjdHgpCnsKCWdpdF9TSEExX0luaXQoJmN0eC0+c2hhMSk7Cn0KCnN0YXRpYyB2b2lkIGdpdF9oYXNoX3NoYTFfdXBkYXRlKGdpdF9oYXNoX2N0eCAqY3R4LCBjb25zdCB2b2lkICpkYXRhLCBzaXplX3QgbGVuKQp7CglnaXRfU0hBMV9VcGRhdGUoJmN0eC0+c2hhMSwgZGF0YSwgbGVuKTsKfQoKc3RhdGljIHZvaWQgZ2l0X2hhc2hfc2hhMV9maW5hbCh1bnNpZ25lZCBjaGFyICpoYXNoLCBnaXRfaGFzaF9jdHggKmN0eCkKewoJZ2l0X1NIQTFfRmluYWwoaGFzaCwgJmN0eC0+c2hhMSk7Cn0KCnN0YXRpYyB2b2lkIGdpdF9oYXNoX3Vua25vd25faW5pdChnaXRfaGFzaF9jdHggKmN0eCkKewoJZGllKCJ0cnlpbmcgdG8gaW5pdCB1bmtub3duIGhhc2giKTsKfQoKc3RhdGljIHZvaWQgZ2l0X2hhc2hfdW5rbm93bl91cGRhdGUoZ2l0X2hhc2hfY3R4ICpjdHgsIGNvbnN0IHZvaWQgKmRhdGEsIHNpemVfdCBsZW4pCnsKCWRpZSgidHJ5aW5nIHRvIHVwZGF0ZSB1bmtub3duIGhhc2giKTsKfQoKc3RhdGljIHZvaWQgZ2l0X2hhc2hfdW5rbm93bl9maW5hbCh1bnNpZ25lZCBjaGFyICpoYXNoLCBnaXRfaGFzaF9jdHggKmN0eCkKewoJZGllKCJ0cnlpbmcgdG8gZmluYWxpemUgdW5rbm93biBoYXNoIik7Cn0KCmNvbnN0IHN0cnVjdCBnaXRfaGFzaF9hbGdvIGhhc2hfYWxnb3NbR0lUX0hBU0hfTkFMR09TXSA9IHsKCXsKCQlOVUxMLAoJCTB4MDAwMDAwMDAsCgkJMCwKCQkwLAoJCWdpdF9oYXNoX3Vua25vd25faW5pdCwKCQlnaXRfaGFzaF91bmtub3duX3VwZGF0ZSwKCQlnaXRfaGFzaF91bmtub3duX2ZpbmFsLAoJCU5VTEwsCgkJTlVMTCwKCX0sCgl7CgkJInNoYS0xIiwKCQkvKiAic2hhMSIsIGJpZy1lbmRpYW4gKi8KCQkweDczNjg2MTMxLAoJCUdJVF9TSEExX1JBV1NaLAoJCUdJVF9TSEExX0hFWFNaLAoJCWdpdF9oYXNoX3NoYTFfaW5pdCwKCQlnaXRfaGFzaF9zaGExX3VwZGF0ZSwKCQlnaXRfaGFzaF9zaGExX2ZpbmFsLAoJCSZlbXB0eV90cmVlX29pZCwKCQkmZW1wdHlfYmxvYl9vaWQsCgl9LAp9OwoKY29uc3QgY2hhciAqZW1wdHlfdHJlZV9vaWRfaGV4KHZvaWQpCnsKCXN0YXRpYyBjaGFyIGJ1ZltHSVRfTUFYX0hFWFNaICsgMV07CglyZXR1cm4gb2lkX3RvX2hleF9yKGJ1ZiwgdGhlX2hhc2hfYWxnby0+ZW1wdHlfdHJlZSk7Cn0KCmNvbnN0IGNoYXIgKmVtcHR5X2Jsb2Jfb2lkX2hleCh2b2lkKQp7CglzdGF0aWMgY2hhciBidWZbR0lUX01BWF9IRVhTWiArIDFdOwoJcmV0dXJuIG9pZF90b19oZXhfcihidWYsIHRoZV9oYXNoX2FsZ28tPmVtcHR5X2Jsb2IpOwp9CgovKgogKiBUaGlzIGlzIG1lYW50IHRvIGhvbGQgYSAqc21hbGwqIG51bWJlciBvZiBvYmplY3RzIHRoYXQgeW91IHdvdWxkCiAqIHdhbnQgcmVhZF9zaGExX2ZpbGUoKSB0byBiZSBhYmxlIHRvIHJldHVybiwgYnV0IHlldCB5b3UgZG8gbm90IHdhbnQKICogdG8gd3JpdGUgdGhlbSBpbnRvIHRoZSBvYmplY3Qgc3RvcmUgKGUuZy4gYSBicm93c2Utb25seQogKiBhcHBsaWNhdGlvbikuCiAqLwpzdGF0aWMgc3RydWN0IGNhY2hlZF9vYmplY3QgewoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CgllbnVtIG9iamVjdF90eXBlIHR5cGU7Cgl2b2lkICpidWY7Cgl1bnNpZ25lZCBsb25nIHNpemU7Cn0gKmNhY2hlZF9vYmplY3RzOwpzdGF0aWMgaW50IGNhY2hlZF9vYmplY3RfbnIsIGNhY2hlZF9vYmplY3RfYWxsb2M7CgpzdGF0aWMgc3RydWN0IGNhY2hlZF9vYmplY3QgZW1wdHlfdHJlZSA9IHsKCXsgRU1QVFlfVFJFRV9TSEExX0JJTl9MSVRFUkFMIH0sCglPQkpfVFJFRSwKCSIiLAoJMAp9OwoKc3RhdGljIHN0cnVjdCBjYWNoZWRfb2JqZWN0ICpmaW5kX2NhY2hlZF9vYmplY3QoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglpbnQgaTsKCXN0cnVjdCBjYWNoZWRfb2JqZWN0ICpjbyA9IGNhY2hlZF9vYmplY3RzOwoKCWZvciAoaSA9IDA7IGkgPCBjYWNoZWRfb2JqZWN0X25yOyBpKyssIGNvKyspIHsKCQlpZiAoIW9pZGNtcCgmY28tPm9pZCwgb2lkKSkKCQkJcmV0dXJuIGNvOwoJfQoJaWYgKCFvaWRjbXAob2lkLCB0aGVfaGFzaF9hbGdvLT5lbXB0eV90cmVlKSkKCQlyZXR1cm4gJmVtcHR5X3RyZWU7CglyZXR1cm4gTlVMTDsKfQoKCnN0YXRpYyBpbnQgZ2V0X2NvbnZfZmxhZ3ModW5zaWduZWQgZmxhZ3MpCnsKCWlmIChmbGFncyAmIEhBU0hfUkVOT1JNQUxJWkUpCgkJcmV0dXJuIENPTlZfRU9MX1JFTk9STUFMSVpFOwoJZWxzZSBpZiAoZmxhZ3MgJiBIQVNIX1dSSVRFX09CSkVDVCkKCQlyZXR1cm4gZ2xvYmFsX2NvbnZfZmxhZ3NfZW9sIHwgQ09OVl9XUklURV9PQkpFQ1Q7CgllbHNlCgkJcmV0dXJuIDA7Cn0KCgppbnQgbWtkaXJfaW5fZ2l0ZGlyKGNvbnN0IGNoYXIgKnBhdGgpCnsKCWlmIChta2RpcihwYXRoLCAwNzc3KSkgewoJCWludCBzYXZlZF9lcnJubyA9IGVycm5vOwoJCXN0cnVjdCBzdGF0IHN0OwoJCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCgkJaWYgKGVycm5vICE9IEVFWElTVCkKCQkJcmV0dXJuIC0xOwoJCS8qCgkJICogQXJlIHdlIGxvb2tpbmcgYXQgYSBwYXRoIGluIGEgc3ltbGlua2VkIHdvcmt0cmVlCgkJICogd2hvc2Ugb3JpZ2luYWwgcmVwb3NpdG9yeSBkb2VzIG5vdCB5ZXQgaGF2ZSBpdD8KCQkgKiBlLmcuIC5naXQvcnItY2FjaGUgcG9pbnRpbmcgYXQgaXRzIG9yaWdpbmFsCgkJICogcmVwb3NpdG9yeSBpbiB3aGljaCB0aGUgdXNlciBoYXNuJ3QgcGVyZm9ybWVkIGFueQoJCSAqIGNvbmZsaWN0IHJlc29sdXRpb24geWV0PwoJCSAqLwoJCWlmIChsc3RhdChwYXRoLCAmc3QpIHx8ICFTX0lTTE5LKHN0LnN0X21vZGUpIHx8CgkJICAgIHN0cmJ1Zl9yZWFkbGluaygmc2IsIHBhdGgsIHN0LnN0X3NpemUpIHx8CgkJICAgICFpc19hYnNvbHV0ZV9wYXRoKHNiLmJ1ZikgfHwKCQkgICAgbWtkaXIoc2IuYnVmLCAwNzc3KSkgewoJCQlzdHJidWZfcmVsZWFzZSgmc2IpOwoJCQllcnJubyA9IHNhdmVkX2Vycm5vOwoJCQlyZXR1cm4gLTE7CgkJfQoJCXN0cmJ1Zl9yZWxlYXNlKCZzYik7Cgl9CglyZXR1cm4gYWRqdXN0X3NoYXJlZF9wZXJtKHBhdGgpOwp9CgplbnVtIHNjbGRfZXJyb3Igc2FmZV9jcmVhdGVfbGVhZGluZ19kaXJlY3RvcmllcyhjaGFyICpwYXRoKQp7CgljaGFyICpuZXh0X2NvbXBvbmVudCA9IHBhdGggKyBvZmZzZXRfMXN0X2NvbXBvbmVudChwYXRoKTsKCWVudW0gc2NsZF9lcnJvciByZXQgPSBTQ0xEX09LOwoKCXdoaWxlIChyZXQgPT0gU0NMRF9PSyAmJiBuZXh0X2NvbXBvbmVudCkgewoJCXN0cnVjdCBzdGF0IHN0OwoJCWNoYXIgKnNsYXNoID0gbmV4dF9jb21wb25lbnQsIHNsYXNoX2NoYXJhY3RlcjsKCgkJd2hpbGUgKCpzbGFzaCAmJiAhaXNfZGlyX3NlcCgqc2xhc2gpKQoJCQlzbGFzaCsrOwoKCQlpZiAoISpzbGFzaCkKCQkJYnJlYWs7CgoJCW5leHRfY29tcG9uZW50ID0gc2xhc2ggKyAxOwoJCXdoaWxlIChpc19kaXJfc2VwKCpuZXh0X2NvbXBvbmVudCkpCgkJCW5leHRfY29tcG9uZW50Kys7CgkJaWYgKCEqbmV4dF9jb21wb25lbnQpCgkJCWJyZWFrOwoKCQlzbGFzaF9jaGFyYWN0ZXIgPSAqc2xhc2g7CgkJKnNsYXNoID0gJ1wwJzsKCQlpZiAoIXN0YXQocGF0aCwgJnN0KSkgewoJCQkvKiBwYXRoIGV4aXN0cyAqLwoJCQlpZiAoIVNfSVNESVIoc3Quc3RfbW9kZSkpIHsKCQkJCWVycm5vID0gRU5PVERJUjsKCQkJCXJldCA9IFNDTERfRVhJU1RTOwoJCQl9CgkJfSBlbHNlIGlmIChta2RpcihwYXRoLCAwNzc3KSkgewoJCQlpZiAoZXJybm8gPT0gRUVYSVNUICYmCgkJCSAgICAhc3RhdChwYXRoLCAmc3QpICYmIFNfSVNESVIoc3Quc3RfbW9kZSkpCgkJCQk7IC8qIHNvbWVib2R5IGNyZWF0ZWQgaXQgc2luY2Ugd2UgY2hlY2tlZCAqLwoJCQllbHNlIGlmIChlcnJubyA9PSBFTk9FTlQpCgkJCQkvKgoJCQkJICogRWl0aGVyIG1rZGlyKCkgZmFpbGVkIGJlY2F1c2UKCQkJCSAqIHNvbWVib2R5IGp1c3QgcHJ1bmVkIHRoZSBjb250YWluaW5nCgkJCQkgKiBkaXJlY3RvcnksIG9yIHN0YXQoKSBmYWlsZWQgYmVjYXVzZQoJCQkJICogdGhlIGZpbGUgdGhhdCB3YXMgaW4gb3VyIHdheSB3YXMKCQkJCSAqIGp1c3QgcmVtb3ZlZC4gIEVpdGhlciB3YXksIGluZm9ybQoJCQkJICogdGhlIGNhbGxlciB0aGF0IGl0IG1pZ2h0IGJlIHdvcnRoCgkJCQkgKiB0cnlpbmcgYWdhaW46CgkJCQkgKi8KCQkJCXJldCA9IFNDTERfVkFOSVNIRUQ7CgkJCWVsc2UKCQkJCXJldCA9IFNDTERfRkFJTEVEOwoJCX0gZWxzZSBpZiAoYWRqdXN0X3NoYXJlZF9wZXJtKHBhdGgpKSB7CgkJCXJldCA9IFNDTERfUEVSTVM7CgkJfQoJCSpzbGFzaCA9IHNsYXNoX2NoYXJhY3RlcjsKCX0KCXJldHVybiByZXQ7Cn0KCmVudW0gc2NsZF9lcnJvciBzYWZlX2NyZWF0ZV9sZWFkaW5nX2RpcmVjdG9yaWVzX2NvbnN0KGNvbnN0IGNoYXIgKnBhdGgpCnsKCWludCBzYXZlX2Vycm5vOwoJLyogcGF0aCBwb2ludHMgdG8gY2FjaGUgZW50cmllcywgc28geHN0cmR1cCBiZWZvcmUgbWVzc2luZyB3aXRoIGl0ICovCgljaGFyICpidWYgPSB4c3RyZHVwKHBhdGgpOwoJZW51bSBzY2xkX2Vycm9yIHJlc3VsdCA9IHNhZmVfY3JlYXRlX2xlYWRpbmdfZGlyZWN0b3JpZXMoYnVmKTsKCglzYXZlX2Vycm5vID0gZXJybm87CglmcmVlKGJ1Zik7CgllcnJubyA9IHNhdmVfZXJybm87CglyZXR1cm4gcmVzdWx0Owp9CgppbnQgcmFjZXByb29mX2NyZWF0ZV9maWxlKGNvbnN0IGNoYXIgKnBhdGgsIGNyZWF0ZV9maWxlX2ZuIGZuLCB2b2lkICpjYikKewoJLyoKCSAqIFRoZSBudW1iZXIgb2YgdGltZXMgd2Ugd2lsbCB0cnkgdG8gcmVtb3ZlIGVtcHR5IGRpcmVjdG9yaWVzCgkgKiBpbiB0aGUgd2F5IG9mIHBhdGguIFRoaXMgaXMgb25seSAxIGJlY2F1c2UgaWYgYW5vdGhlcgoJICogcHJvY2VzcyBpcyByYWNpbHkgY3JlYXRpbmcgZGlyZWN0b3JpZXMgdGhhdCBjb25mbGljdCB3aXRoCgkgKiB1cywgd2UgZG9uJ3Qgd2FudCB0byBmaWdodCBhZ2FpbnN0IHRoZW0uCgkgKi8KCWludCByZW1vdmVfZGlyZWN0b3JpZXNfcmVtYWluaW5nID0gMTsKCgkvKgoJICogVGhlIG51bWJlciBvZiB0aW1lcyB0aGF0IHdlIHdpbGwgdHJ5IHRvIGNyZWF0ZSB0aGUKCSAqIGRpcmVjdG9yaWVzIGNvbnRhaW5pbmcgcGF0aC4gV2UgYXJlIHdpbGxpbmcgdG8gYXR0ZW1wdCB0aGlzCgkgKiBtb3JlIHRoYW4gb25jZSwgYmVjYXVzZSBhbm90aGVyIHByb2Nlc3MgY291bGQgYmUgdHJ5aW5nIHRvCgkgKiBjbGVhbiB1cCBlbXB0eSBkaXJlY3RvcmllcyBhdCB0aGUgc2FtZSB0aW1lIGFzIHdlIGFyZQoJICogdHJ5aW5nIHRvIGNyZWF0ZSB0aGVtLgoJICovCglpbnQgY3JlYXRlX2RpcmVjdG9yaWVzX3JlbWFpbmluZyA9IDM7CgoJLyogQSBzY3JhdGNoIGNvcHkgb2YgcGF0aCwgZmlsbGVkIGxhemlseSBpZiB3ZSBuZWVkIGl0OiAqLwoJc3RydWN0IHN0cmJ1ZiBwYXRoX2NvcHkgPSBTVFJCVUZfSU5JVDsKCglpbnQgcmV0LCBzYXZlX2Vycm5vOwoKCS8qIFNhbml0eSBjaGVjazogKi8KCWFzc2VydCgqcGF0aCk7CgpyZXRyeV9mbjoKCXJldCA9IGZuKHBhdGgsIGNiKTsKCXNhdmVfZXJybm8gPSBlcnJubzsKCWlmICghcmV0KQoJCWdvdG8gb3V0OwoKCWlmIChlcnJubyA9PSBFSVNESVIgJiYgcmVtb3ZlX2RpcmVjdG9yaWVzX3JlbWFpbmluZy0tID4gMCkgewoJCS8qCgkJICogQSBkaXJlY3RvcnkgaXMgaW4gdGhlIHdheS4gTWF5YmUgaXQgaXMgZW1wdHk7IHRyeQoJCSAqIHRvIHJlbW92ZSBpdDoKCQkgKi8KCQlpZiAoIXBhdGhfY29weS5sZW4pCgkJCXN0cmJ1Zl9hZGRzdHIoJnBhdGhfY29weSwgcGF0aCk7CgoJCWlmICghcmVtb3ZlX2Rpcl9yZWN1cnNpdmVseSgmcGF0aF9jb3B5LCBSRU1PVkVfRElSX0VNUFRZX09OTFkpKQoJCQlnb3RvIHJldHJ5X2ZuOwoJfSBlbHNlIGlmIChlcnJubyA9PSBFTk9FTlQgJiYgY3JlYXRlX2RpcmVjdG9yaWVzX3JlbWFpbmluZy0tID4gMCkgewoJCS8qCgkJICogTWF5YmUgdGhlIGNvbnRhaW5pbmcgZGlyZWN0b3J5IGRpZG4ndCBleGlzdCwgb3IKCQkgKiBtYXliZSBpdCB3YXMganVzdCBkZWxldGVkIGJ5IGEgcHJvY2VzcyB0aGF0IGlzCgkJICogcmFjaW5nIHdpdGggdXMgdG8gY2xlYW4gdXAgZW1wdHkgZGlyZWN0b3JpZXMuIFRyeQoJCSAqIHRvIGNyZWF0ZSBpdDoKCQkgKi8KCQllbnVtIHNjbGRfZXJyb3Igc2NsZF9yZXN1bHQ7CgoJCWlmICghcGF0aF9jb3B5LmxlbikKCQkJc3RyYnVmX2FkZHN0cigmcGF0aF9jb3B5LCBwYXRoKTsKCgkJZG8gewoJCQlzY2xkX3Jlc3VsdCA9IHNhZmVfY3JlYXRlX2xlYWRpbmdfZGlyZWN0b3JpZXMocGF0aF9jb3B5LmJ1Zik7CgkJCWlmIChzY2xkX3Jlc3VsdCA9PSBTQ0xEX09LKQoJCQkJZ290byByZXRyeV9mbjsKCQl9IHdoaWxlIChzY2xkX3Jlc3VsdCA9PSBTQ0xEX1ZBTklTSEVEICYmIGNyZWF0ZV9kaXJlY3Rvcmllc19yZW1haW5pbmctLSA+IDApOwoJfQoKb3V0OgoJc3RyYnVmX3JlbGVhc2UoJnBhdGhfY29weSk7CgllcnJubyA9IHNhdmVfZXJybm87CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgdm9pZCBmaWxsX3NoYTFfcGF0aChzdHJ1Y3Qgc3RyYnVmICpidWYsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCWludCBpOwoJZm9yIChpID0gMDsgaSA8IHRoZV9oYXNoX2FsZ28tPnJhd3N6OyBpKyspIHsKCQlzdGF0aWMgY2hhciBoZXhbXSA9ICIwMTIzNDU2Nzg5YWJjZGVmIjsKCQl1bnNpZ25lZCBpbnQgdmFsID0gc2hhMVtpXTsKCQlzdHJidWZfYWRkY2goYnVmLCBoZXhbdmFsID4+IDRdKTsKCQlzdHJidWZfYWRkY2goYnVmLCBoZXhbdmFsICYgMHhmXSk7CgkJaWYgKCFpKQoJCQlzdHJidWZfYWRkY2goYnVmLCAnLycpOwoJfQp9Cgp2b2lkIHNoYTFfZmlsZV9uYW1lKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBzdHJ1Y3Qgc3RyYnVmICpidWYsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXN0cmJ1Zl9hZGRzdHIoYnVmLCByLT5vYmplY3RzLT5vYmplY3RkaXIpOwoJc3RyYnVmX2FkZGNoKGJ1ZiwgJy8nKTsKCWZpbGxfc2hhMV9wYXRoKGJ1Ziwgc2hhMSk7Cn0KCnN0cnVjdCBzdHJidWYgKmFsdF9zY3JhdGNoX2J1ZihzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSAqYWx0KQp7CglzdHJidWZfc2V0bGVuKCZhbHQtPnNjcmF0Y2gsIGFsdC0+YmFzZV9sZW4pOwoJcmV0dXJuICZhbHQtPnNjcmF0Y2g7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICphbHRfc2hhMV9wYXRoKHN0cnVjdCBhbHRlcm5hdGVfb2JqZWN0X2RhdGFiYXNlICphbHQsCgkJCQkgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJc3RydWN0IHN0cmJ1ZiAqYnVmID0gYWx0X3NjcmF0Y2hfYnVmKGFsdCk7CglmaWxsX3NoYTFfcGF0aChidWYsIHNoYTEpOwoJcmV0dXJuIGJ1Zi0+YnVmOwp9CgovKgogKiBSZXR1cm4gbm9uLXplcm8gaWZmIHRoZSBwYXRoIGlzIHVzYWJsZSBhcyBhbiBhbHRlcm5hdGUgb2JqZWN0IGRhdGFiYXNlLgogKi8Kc3RhdGljIGludCBhbHRfb2RiX3VzYWJsZShzdHJ1Y3QgcmF3X29iamVjdF9zdG9yZSAqbywKCQkJICBzdHJ1Y3Qgc3RyYnVmICpwYXRoLAoJCQkgIGNvbnN0IGNoYXIgKm5vcm1hbGl6ZWRfb2JqZGlyKQp7CglzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSAqYWx0OwoKCS8qIERldGVjdCBjYXNlcyB3aGVyZSBhbHRlcm5hdGUgZGlzYXBwZWFyZWQgKi8KCWlmICghaXNfZGlyZWN0b3J5KHBhdGgtPmJ1ZikpIHsKCQllcnJvcigib2JqZWN0IGRpcmVjdG9yeSAlcyBkb2VzIG5vdCBleGlzdDsgIgoJCSAgICAgICJjaGVjayAuZ2l0L29iamVjdHMvaW5mby9hbHRlcm5hdGVzLiIsCgkJICAgICAgcGF0aC0+YnVmKTsKCQlyZXR1cm4gMDsKCX0KCgkvKgoJICogUHJldmVudCB0aGUgY29tbW9uIG1pc3Rha2Ugb2YgbGlzdGluZyB0aGUgc2FtZQoJICogdGhpbmcgdHdpY2UsIG9yIG9iamVjdCBkaXJlY3RvcnkgaXRzZWxmLgoJICovCglmb3IgKGFsdCA9IG8tPmFsdF9vZGJfbGlzdDsgYWx0OyBhbHQgPSBhbHQtPm5leHQpIHsKCQlpZiAoIWZzcGF0aGNtcChwYXRoLT5idWYsIGFsdC0+cGF0aCkpCgkJCXJldHVybiAwOwoJfQoJaWYgKCFmc3BhdGhjbXAocGF0aC0+YnVmLCBub3JtYWxpemVkX29iamRpcikpCgkJcmV0dXJuIDA7CgoJcmV0dXJuIDE7Cn0KCi8qCiAqIFByZXBhcmUgYWx0ZXJuYXRlIG9iamVjdCBkYXRhYmFzZSByZWdpc3RyeS4KICoKICogVGhlIHZhcmlhYmxlIGFsdF9vZGJfbGlzdCBwb2ludHMgYXQgdGhlIGxpc3Qgb2Ygc3RydWN0CiAqIGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UuICBUaGUgZWxlbWVudHMgb24gdGhpcyBsaXN0IGNvbWUgZnJvbQogKiBub24tZW1wdHkgZWxlbWVudHMgZnJvbSBjb2xvbiBzZXBhcmF0ZWQgQUxURVJOQVRFX0RCX0VOVklST05NRU5UCiAqIGVudmlyb25tZW50IHZhcmlhYmxlLCBhbmQgJEdJVF9PQkpFQ1RfRElSRUNUT1JZL2luZm8vYWx0ZXJuYXRlcywKICogd2hvc2UgY29udGVudHMgaXMgc2ltaWxhciB0byB0aGF0IGVudmlyb25tZW50IHZhcmlhYmxlIGJ1dCBjYW4gYmUKICogTEYgc2VwYXJhdGVkLiAgSXRzIGJhc2UgcG9pbnRzIGF0IGEgc3RhdGljYWxseSBhbGxvY2F0ZWQgYnVmZmVyIHRoYXQKICogY29udGFpbnMgIi90aGUvZGlyZWN0b3J5L2NvcnJlc3BvbmRpbmcvdG8vLmdpdC9vYmplY3RzLy4uLiIsIHdoaWxlCiAqIGl0cyBuYW1lIHBvaW50cyBqdXN0IGFmdGVyIHRoZSBzbGFzaCBhdCB0aGUgZW5kIG9mICIuZ2l0L29iamVjdHMvIgogKiBpbiB0aGUgZXhhbXBsZSBhYm92ZSwgYW5kIGhhcyBlbm91Z2ggc3BhY2UgdG8gaG9sZCA0MC1ieXRlIGhleAogKiBTSEExLCBhbiBleHRyYSBzbGFzaCBmb3IgdGhlIGZpcnN0IGxldmVsIGluZGlyZWN0aW9uLCBhbmQgdGhlCiAqIHRlcm1pbmF0aW5nIE5VTC4KICovCnN0YXRpYyB2b2lkIHJlYWRfaW5mb19hbHRlcm5hdGVzKHN0cnVjdCByZXBvc2l0b3J5ICpyLAoJCQkJIGNvbnN0IGNoYXIgKnJlbGF0aXZlX2Jhc2UsCgkJCQkgaW50IGRlcHRoKTsKc3RhdGljIGludCBsaW5rX2FsdF9vZGJfZW50cnkoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IGNoYXIgKmVudHJ5LAoJY29uc3QgY2hhciAqcmVsYXRpdmVfYmFzZSwgaW50IGRlcHRoLCBjb25zdCBjaGFyICpub3JtYWxpemVkX29iamRpcikKewoJc3RydWN0IGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UgKmVudDsKCXN0cnVjdCBzdHJidWYgcGF0aGJ1ZiA9IFNUUkJVRl9JTklUOwoKCWlmICghaXNfYWJzb2x1dGVfcGF0aChlbnRyeSkgJiYgcmVsYXRpdmVfYmFzZSkgewoJCXN0cmJ1Zl9yZWFscGF0aCgmcGF0aGJ1ZiwgcmVsYXRpdmVfYmFzZSwgMSk7CgkJc3RyYnVmX2FkZGNoKCZwYXRoYnVmLCAnLycpOwoJfQoJc3RyYnVmX2FkZHN0cigmcGF0aGJ1ZiwgZW50cnkpOwoKCWlmIChzdHJidWZfbm9ybWFsaXplX3BhdGgoJnBhdGhidWYpIDwgMCAmJiByZWxhdGl2ZV9iYXNlKSB7CgkJZXJyb3IoInVuYWJsZSB0byBub3JtYWxpemUgYWx0ZXJuYXRlIG9iamVjdCBwYXRoOiAlcyIsCgkJICAgICAgcGF0aGJ1Zi5idWYpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZwYXRoYnVmKTsKCQlyZXR1cm4gLTE7Cgl9CgoJLyoKCSAqIFRoZSB0cmFpbGluZyBzbGFzaCBhZnRlciB0aGUgZGlyZWN0b3J5IG5hbWUgaXMgZ2l2ZW4gYnkKCSAqIHRoaXMgZnVuY3Rpb24gYXQgdGhlIGVuZC4gUmVtb3ZlIGR1cGxpY2F0ZXMuCgkgKi8KCXdoaWxlIChwYXRoYnVmLmxlbiAmJiBwYXRoYnVmLmJ1ZltwYXRoYnVmLmxlbiAtIDFdID09ICcvJykKCQlzdHJidWZfc2V0bGVuKCZwYXRoYnVmLCBwYXRoYnVmLmxlbiAtIDEpOwoKCWlmICghYWx0X29kYl91c2FibGUoci0+b2JqZWN0cywgJnBhdGhidWYsIG5vcm1hbGl6ZWRfb2JqZGlyKSkgewoJCXN0cmJ1Zl9yZWxlYXNlKCZwYXRoYnVmKTsKCQlyZXR1cm4gLTE7Cgl9CgoJZW50ID0gYWxsb2NfYWx0X29kYihwYXRoYnVmLmJ1Zik7CgoJLyogYWRkIHRoZSBhbHRlcm5hdGUgZW50cnkgKi8KCSpyLT5vYmplY3RzLT5hbHRfb2RiX3RhaWwgPSBlbnQ7CglyLT5vYmplY3RzLT5hbHRfb2RiX3RhaWwgPSAmKGVudC0+bmV4dCk7CgllbnQtPm5leHQgPSBOVUxMOwoKCS8qIHJlY3Vyc2l2ZWx5IGFkZCBhbHRlcm5hdGVzICovCglyZWFkX2luZm9fYWx0ZXJuYXRlcyhyLCBwYXRoYnVmLmJ1ZiwgZGVwdGggKyAxKTsKCglzdHJidWZfcmVsZWFzZSgmcGF0aGJ1Zik7CglyZXR1cm4gMDsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnBhcnNlX2FsdF9vZGJfZW50cnkoY29uc3QgY2hhciAqc3RyaW5nLAoJCQkJICAgICAgIGludCBzZXAsCgkJCQkgICAgICAgc3RydWN0IHN0cmJ1ZiAqb3V0KQp7Cgljb25zdCBjaGFyICplbmQ7CgoJc3RyYnVmX3Jlc2V0KG91dCk7CgoJaWYgKCpzdHJpbmcgPT0gJyMnKSB7CgkJLyogY29tbWVudDsgY29uc3VtZSB1cCB0byBuZXh0IHNlcGFyYXRvciAqLwoJCWVuZCA9IHN0cmNocm51bChzdHJpbmcsIHNlcCk7Cgl9IGVsc2UgaWYgKCpzdHJpbmcgPT0gJyInICYmICF1bnF1b3RlX2Nfc3R5bGUob3V0LCBzdHJpbmcsICZlbmQpKSB7CgkJLyoKCQkgKiBxdW90ZWQgcGF0aDsgdW5xdW90ZV9jX3N0eWxlIGhhcyBjb3BpZWQgdGhlCgkJICogZGF0YSBmb3IgdXMgYW5kIHNldCAiZW5kIi4gQnJva2VuIHF1b3RpbmcgKGUuZy4sCgkJICogYW4gZW50cnkgdGhhdCBkb2Vzbid0IGVuZCB3aXRoIGEgcXVvdGUpIGZhbGxzCgkJICogYmFjayB0byB0aGUgdW5xdW90ZWQgY2FzZSBiZWxvdy4KCQkgKi8KCX0gZWxzZSB7CgkJLyogbm9ybWFsLCB1bnF1b3RlZCBwYXRoICovCgkJZW5kID0gc3RyY2hybnVsKHN0cmluZywgc2VwKTsKCQlzdHJidWZfYWRkKG91dCwgc3RyaW5nLCBlbmQgLSBzdHJpbmcpOwoJfQoKCWlmICgqZW5kKQoJCWVuZCsrOwoJcmV0dXJuIGVuZDsKfQoKc3RhdGljIHZvaWQgbGlua19hbHRfb2RiX2VudHJpZXMoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IGNoYXIgKmFsdCwKCQkJCSBpbnQgc2VwLCBjb25zdCBjaGFyICpyZWxhdGl2ZV9iYXNlLCBpbnQgZGVwdGgpCnsKCXN0cnVjdCBzdHJidWYgb2JqZGlyYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGVudHJ5ID0gU1RSQlVGX0lOSVQ7CgoJaWYgKCFhbHQgfHwgISphbHQpCgkJcmV0dXJuOwoKCWlmIChkZXB0aCA+IDUpIHsKCQllcnJvcigiJXM6IGlnbm9yaW5nIGFsdGVybmF0ZSBvYmplY3Qgc3RvcmVzLCBuZXN0aW5nIHRvbyBkZWVwLiIsCgkJCQlyZWxhdGl2ZV9iYXNlKTsKCQlyZXR1cm47Cgl9CgoJc3RyYnVmX2FkZF9hYnNvbHV0ZV9wYXRoKCZvYmpkaXJidWYsIHItPm9iamVjdHMtPm9iamVjdGRpcik7CglpZiAoc3RyYnVmX25vcm1hbGl6ZV9wYXRoKCZvYmpkaXJidWYpIDwgMCkKCQlkaWUoInVuYWJsZSB0byBub3JtYWxpemUgb2JqZWN0IGRpcmVjdG9yeTogJXMiLAoJCSAgICBvYmpkaXJidWYuYnVmKTsKCgl3aGlsZSAoKmFsdCkgewoJCWFsdCA9IHBhcnNlX2FsdF9vZGJfZW50cnkoYWx0LCBzZXAsICZlbnRyeSk7CgkJaWYgKCFlbnRyeS5sZW4pCgkJCWNvbnRpbnVlOwoJCWxpbmtfYWx0X29kYl9lbnRyeShyLCBlbnRyeS5idWYsCgkJCQkgICByZWxhdGl2ZV9iYXNlLCBkZXB0aCwgb2JqZGlyYnVmLmJ1Zik7Cgl9CglzdHJidWZfcmVsZWFzZSgmZW50cnkpOwoJc3RyYnVmX3JlbGVhc2UoJm9iamRpcmJ1Zik7Cn0KCnN0YXRpYyB2b2lkIHJlYWRfaW5mb19hbHRlcm5hdGVzKHN0cnVjdCByZXBvc2l0b3J5ICpyLAoJCQkJIGNvbnN0IGNoYXIgKnJlbGF0aXZlX2Jhc2UsCgkJCQkgaW50IGRlcHRoKQp7CgljaGFyICpwYXRoOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCglwYXRoID0geHN0cmZtdCgiJXMvaW5mby9hbHRlcm5hdGVzIiwgcmVsYXRpdmVfYmFzZSk7CglpZiAoc3RyYnVmX3JlYWRfZmlsZSgmYnVmLCBwYXRoLCAxMDI0KSA8IDApIHsKCQl3YXJuX29uX2ZvcGVuX2Vycm9ycyhwYXRoKTsKCQlmcmVlKHBhdGgpOwoJCXJldHVybjsKCX0KCglsaW5rX2FsdF9vZGJfZW50cmllcyhyLCBidWYuYnVmLCAnXG4nLCByZWxhdGl2ZV9iYXNlLCBkZXB0aCk7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCWZyZWUocGF0aCk7Cn0KCnN0cnVjdCBhbHRlcm5hdGVfb2JqZWN0X2RhdGFiYXNlICphbGxvY19hbHRfb2RiKGNvbnN0IGNoYXIgKmRpcikKewoJc3RydWN0IGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UgKmVudDsKCglGTEVYX0FMTE9DX1NUUihlbnQsIHBhdGgsIGRpcik7CglzdHJidWZfaW5pdCgmZW50LT5zY3JhdGNoLCAwKTsKCXN0cmJ1Zl9hZGRmKCZlbnQtPnNjcmF0Y2gsICIlcy8iLCBkaXIpOwoJZW50LT5iYXNlX2xlbiA9IGVudC0+c2NyYXRjaC5sZW47CgoJcmV0dXJuIGVudDsKfQoKdm9pZCBhZGRfdG9fYWx0ZXJuYXRlc19maWxlKGNvbnN0IGNoYXIgKnJlZmVyZW5jZSkKewoJc3RydWN0IGxvY2tfZmlsZSBsb2NrID0gTE9DS19JTklUOwoJY2hhciAqYWx0cyA9IGdpdF9wYXRoZHVwKCJvYmplY3RzL2luZm8vYWx0ZXJuYXRlcyIpOwoJRklMRSAqaW4sICpvdXQ7CglpbnQgZm91bmQgPSAwOwoKCWhvbGRfbG9ja19maWxlX2Zvcl91cGRhdGUoJmxvY2ssIGFsdHMsIExPQ0tfRElFX09OX0VSUk9SKTsKCW91dCA9IGZkb3Blbl9sb2NrX2ZpbGUoJmxvY2ssICJ3Iik7CglpZiAoIW91dCkKCQlkaWVfZXJybm8oInVuYWJsZSB0byBmZG9wZW4gYWx0ZXJuYXRlcyBsb2NrZmlsZSIpOwoKCWluID0gZm9wZW4oYWx0cywgInIiKTsKCWlmIChpbikgewoJCXN0cnVjdCBzdHJidWYgbGluZSA9IFNUUkJVRl9JTklUOwoKCQl3aGlsZSAoc3RyYnVmX2dldGxpbmUoJmxpbmUsIGluKSAhPSBFT0YpIHsKCQkJaWYgKCFzdHJjbXAocmVmZXJlbmNlLCBsaW5lLmJ1ZikpIHsKCQkJCWZvdW5kID0gMTsKCQkJCWJyZWFrOwoJCQl9CgkJCWZwcmludGZfb3JfZGllKG91dCwgIiVzXG4iLCBsaW5lLmJ1Zik7CgkJfQoKCQlzdHJidWZfcmVsZWFzZSgmbGluZSk7CgkJZmNsb3NlKGluKTsKCX0KCWVsc2UgaWYgKGVycm5vICE9IEVOT0VOVCkKCQlkaWVfZXJybm8oInVuYWJsZSB0byByZWFkIGFsdGVybmF0ZXMgZmlsZSIpOwoKCWlmIChmb3VuZCkgewoJCXJvbGxiYWNrX2xvY2tfZmlsZSgmbG9jayk7Cgl9IGVsc2UgewoJCWZwcmludGZfb3JfZGllKG91dCwgIiVzXG4iLCByZWZlcmVuY2UpOwoJCWlmIChjb21taXRfbG9ja19maWxlKCZsb2NrKSkKCQkJZGllX2Vycm5vKCJ1bmFibGUgdG8gbW92ZSBuZXcgYWx0ZXJuYXRlcyBmaWxlIGludG8gcGxhY2UiKTsKCQlpZiAodGhlX3JlcG9zaXRvcnktPm9iamVjdHMtPmFsdF9vZGJfdGFpbCkKCQkJbGlua19hbHRfb2RiX2VudHJpZXModGhlX3JlcG9zaXRvcnksIHJlZmVyZW5jZSwKCQkJCQkgICAgICdcbicsIE5VTEwsIDApOwoJfQoJZnJlZShhbHRzKTsKfQoKdm9pZCBhZGRfdG9fYWx0ZXJuYXRlc19tZW1vcnkoY29uc3QgY2hhciAqcmVmZXJlbmNlKQp7CgkvKgoJICogTWFrZSBzdXJlIGFsdGVybmF0ZXMgYXJlIGluaXRpYWxpemVkLCBvciBlbHNlIG91ciBlbnRyeSBtYXkgYmUKCSAqIG92ZXJ3cml0dGVuIHdoZW4gdGhleSBhcmUuCgkgKi8KCXByZXBhcmVfYWx0X29kYih0aGVfcmVwb3NpdG9yeSk7CgoJbGlua19hbHRfb2RiX2VudHJpZXModGhlX3JlcG9zaXRvcnksIHJlZmVyZW5jZSwKCQkJICAgICAnXG4nLCBOVUxMLCAwKTsKfQoKLyoKICogQ29tcHV0ZSB0aGUgZXhhY3QgcGF0aCBhbiBhbHRlcm5hdGUgaXMgYXQgYW5kIHJldHVybnMgaXQuIEluIGNhc2Ugb2YKICogZXJyb3IgTlVMTCBpcyByZXR1cm5lZCBhbmQgdGhlIGh1bWFuIHJlYWRhYmxlIGVycm9yIGlzIGFkZGVkIHRvIGBlcnJgCiAqIGBwYXRoYCBtYXkgYmUgcmVsYXRpdmUgYW5kIHNob3VsZCBwb2ludCB0byAkR0lUX0RJUi4KICogYGVycmAgbXVzdCBub3QgYmUgbnVsbC4KICovCmNoYXIgKmNvbXB1dGVfYWx0ZXJuYXRlX3BhdGgoY29uc3QgY2hhciAqcGF0aCwgc3RydWN0IHN0cmJ1ZiAqZXJyKQp7CgljaGFyICpyZWZfZ2l0ID0gTlVMTDsKCWNvbnN0IGNoYXIgKnJlcG8sICpyZWZfZ2l0X3M7CglpbnQgc2Vlbl9lcnJvciA9IDA7CgoJcmVmX2dpdF9zID0gcmVhbF9wYXRoX2lmX3ZhbGlkKHBhdGgpOwoJaWYgKCFyZWZfZ2l0X3MpIHsKCQlzZWVuX2Vycm9yID0gMTsKCQlzdHJidWZfYWRkZihlcnIsIF8oInBhdGggJyVzJyBkb2VzIG5vdCBleGlzdCIpLCBwYXRoKTsKCQlnb3RvIG91dDsKCX0gZWxzZQoJCS8qCgkJICogQmV3YXJlOiByZWFkX2dpdGZpbGUoKSwgcmVhbF9wYXRoKCkgYW5kIG1rcGF0aCgpCgkJICogcmV0dXJuIHN0YXRpYyBidWZmZXIKCQkgKi8KCQlyZWZfZ2l0ID0geHN0cmR1cChyZWZfZ2l0X3MpOwoKCXJlcG8gPSByZWFkX2dpdGZpbGUocmVmX2dpdCk7CglpZiAoIXJlcG8pCgkJcmVwbyA9IHJlYWRfZ2l0ZmlsZShta3BhdGgoIiVzLy5naXQiLCByZWZfZ2l0KSk7CglpZiAocmVwbykgewoJCWZyZWUocmVmX2dpdCk7CgkJcmVmX2dpdCA9IHhzdHJkdXAocmVwbyk7Cgl9CgoJaWYgKCFyZXBvICYmIGlzX2RpcmVjdG9yeShta3BhdGgoIiVzLy5naXQvb2JqZWN0cyIsIHJlZl9naXQpKSkgewoJCWNoYXIgKnJlZl9naXRfZ2l0ID0gbWtwYXRoZHVwKCIlcy8uZ2l0IiwgcmVmX2dpdCk7CgkJZnJlZShyZWZfZ2l0KTsKCQlyZWZfZ2l0ID0gcmVmX2dpdF9naXQ7Cgl9IGVsc2UgaWYgKCFpc19kaXJlY3RvcnkobWtwYXRoKCIlcy9vYmplY3RzIiwgcmVmX2dpdCkpKSB7CgkJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJCXNlZW5fZXJyb3IgPSAxOwoJCWlmIChnZXRfY29tbW9uX2Rpcigmc2IsIHJlZl9naXQpKSB7CgkJCXN0cmJ1Zl9hZGRmKGVyciwKCQkJCSAgICBfKCJyZWZlcmVuY2UgcmVwb3NpdG9yeSAnJXMnIGFzIGEgbGlua2VkICIKCQkJCSAgICAgICJjaGVja291dCBpcyBub3Qgc3VwcG9ydGVkIHlldC4iKSwKCQkJCSAgICBwYXRoKTsKCQkJZ290byBvdXQ7CgkJfQoKCQlzdHJidWZfYWRkZihlcnIsIF8oInJlZmVyZW5jZSByZXBvc2l0b3J5ICclcycgaXMgbm90IGEgIgoJCQkJCSJsb2NhbCByZXBvc2l0b3J5LiIpLCBwYXRoKTsKCQlnb3RvIG91dDsKCX0KCglpZiAoIWFjY2Vzcyhta3BhdGgoIiVzL3NoYWxsb3ciLCByZWZfZ2l0KSwgRl9PSykpIHsKCQlzdHJidWZfYWRkZihlcnIsIF8oInJlZmVyZW5jZSByZXBvc2l0b3J5ICclcycgaXMgc2hhbGxvdyIpLAoJCQkgICAgcGF0aCk7CgkJc2Vlbl9lcnJvciA9IDE7CgkJZ290byBvdXQ7Cgl9CgoJaWYgKCFhY2Nlc3MobWtwYXRoKCIlcy9pbmZvL2dyYWZ0cyIsIHJlZl9naXQpLCBGX09LKSkgewoJCXN0cmJ1Zl9hZGRmKGVyciwKCQkJICAgIF8oInJlZmVyZW5jZSByZXBvc2l0b3J5ICclcycgaXMgZ3JhZnRlZCIpLAoJCQkgICAgcGF0aCk7CgkJc2Vlbl9lcnJvciA9IDE7CgkJZ290byBvdXQ7Cgl9CgpvdXQ6CglpZiAoc2Vlbl9lcnJvcikgewoJCUZSRUVfQU5EX05VTEwocmVmX2dpdCk7Cgl9CgoJcmV0dXJuIHJlZl9naXQ7Cn0KCmludCBmb3JlYWNoX2FsdF9vZGIoYWx0X29kYl9mbiBmbiwgdm9pZCAqY2IpCnsKCXN0cnVjdCBhbHRlcm5hdGVfb2JqZWN0X2RhdGFiYXNlICplbnQ7CglpbnQgciA9IDA7CgoJcHJlcGFyZV9hbHRfb2RiKHRoZV9yZXBvc2l0b3J5KTsKCWZvciAoZW50ID0gdGhlX3JlcG9zaXRvcnktPm9iamVjdHMtPmFsdF9vZGJfbGlzdDsgZW50OyBlbnQgPSBlbnQtPm5leHQpIHsKCQlyID0gZm4oZW50LCBjYik7CgkJaWYgKHIpCgkJCWJyZWFrOwoJfQoJcmV0dXJuIHI7Cn0KCnZvaWQgcHJlcGFyZV9hbHRfb2RiKHN0cnVjdCByZXBvc2l0b3J5ICpyKQp7CglpZiAoci0+b2JqZWN0cy0+YWx0X29kYl90YWlsKQoJCXJldHVybjsKCglyLT5vYmplY3RzLT5hbHRfb2RiX3RhaWwgPSAmci0+b2JqZWN0cy0+YWx0X29kYl9saXN0OwoJbGlua19hbHRfb2RiX2VudHJpZXMociwgci0+b2JqZWN0cy0+YWx0ZXJuYXRlX2RiLCBQQVRIX1NFUCwgTlVMTCwgMCk7CgoJcmVhZF9pbmZvX2FsdGVybmF0ZXMociwgci0+b2JqZWN0cy0+b2JqZWN0ZGlyLCAwKTsKfQoKLyogUmV0dXJucyAxIGlmIHdlIGhhdmUgc3VjY2Vzc2Z1bGx5IGZyZXNoZW5lZCB0aGUgZmlsZSwgMCBvdGhlcndpc2UuICovCnN0YXRpYyBpbnQgZnJlc2hlbl9maWxlKGNvbnN0IGNoYXIgKmZuKQp7CglzdHJ1Y3QgdXRpbWJ1ZiB0OwoJdC5hY3RpbWUgPSB0Lm1vZHRpbWUgPSB0aW1lKE5VTEwpOwoJcmV0dXJuICF1dGltZShmbiwgJnQpOwp9CgovKgogKiBBbGwgb2YgdGhlIGNoZWNrX2FuZF9mcmVzaGVuIGZ1bmN0aW9ucyByZXR1cm4gMSBpZiB0aGUgZmlsZSBleGlzdHMgYW5kIHdhcwogKiBmcmVzaGVuZWQgKGlmIGZyZXNoZW5pbmcgd2FzIHJlcXVlc3RlZCksIDAgb3RoZXJ3aXNlLiBJZiB0aGV5IHJldHVybgogKiAwLCB5b3Ugc2hvdWxkIG5vdCBhc3N1bWUgdGhhdCBpdCBpcyBzYWZlIHRvIHNraXAgYSB3cml0ZSBvZiB0aGUgb2JqZWN0IChpdAogKiBlaXRoZXIgZG9lcyBub3QgZXhpc3Qgb24gZGlzaywgb3IgaGFzIGEgc3RhbGUgbXRpbWUgYW5kIG1heSBiZSBzdWJqZWN0IHRvCiAqIHBydW5pbmcpLgogKi8KaW50IGNoZWNrX2FuZF9mcmVzaGVuX2ZpbGUoY29uc3QgY2hhciAqZm4sIGludCBmcmVzaGVuKQp7CglpZiAoYWNjZXNzKGZuLCBGX09LKSkKCQlyZXR1cm4gMDsKCWlmIChmcmVzaGVuICYmICFmcmVzaGVuX2ZpbGUoZm4pKQoJCXJldHVybiAwOwoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBpbnQgY2hlY2tfYW5kX2ZyZXNoZW5fbG9jYWwoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBpbnQgZnJlc2hlbikKewoJc3RhdGljIHN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJc3RyYnVmX3Jlc2V0KCZidWYpOwoJc2hhMV9maWxlX25hbWUodGhlX3JlcG9zaXRvcnksICZidWYsIG9pZC0+aGFzaCk7CgoJcmV0dXJuIGNoZWNrX2FuZF9mcmVzaGVuX2ZpbGUoYnVmLmJ1ZiwgZnJlc2hlbik7Cn0KCnN0YXRpYyBpbnQgY2hlY2tfYW5kX2ZyZXNoZW5fbm9ubG9jYWwoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBpbnQgZnJlc2hlbikKewoJc3RydWN0IGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UgKmFsdDsKCXByZXBhcmVfYWx0X29kYih0aGVfcmVwb3NpdG9yeSk7Cglmb3IgKGFsdCA9IHRoZV9yZXBvc2l0b3J5LT5vYmplY3RzLT5hbHRfb2RiX2xpc3Q7IGFsdDsgYWx0ID0gYWx0LT5uZXh0KSB7CgkJY29uc3QgY2hhciAqcGF0aCA9IGFsdF9zaGExX3BhdGgoYWx0LCBvaWQtPmhhc2gpOwoJCWlmIChjaGVja19hbmRfZnJlc2hlbl9maWxlKHBhdGgsIGZyZXNoZW4pKQoJCQlyZXR1cm4gMTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGNoZWNrX2FuZF9mcmVzaGVuKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgaW50IGZyZXNoZW4pCnsKCXJldHVybiBjaGVja19hbmRfZnJlc2hlbl9sb2NhbChvaWQsIGZyZXNoZW4pIHx8CgkgICAgICAgY2hlY2tfYW5kX2ZyZXNoZW5fbm9ubG9jYWwob2lkLCBmcmVzaGVuKTsKfQoKaW50IGhhc19sb29zZV9vYmplY3Rfbm9ubG9jYWwoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglyZXR1cm4gY2hlY2tfYW5kX2ZyZXNoZW5fbm9ubG9jYWwob2lkLCAwKTsKfQoKc3RhdGljIGludCBoYXNfbG9vc2Vfb2JqZWN0KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJcmV0dXJuIGNoZWNrX2FuZF9mcmVzaGVuKG9pZCwgMCk7Cn0KCnN0YXRpYyB2b2lkIG1tYXBfbGltaXRfY2hlY2soc2l6ZV90IGxlbmd0aCkKewoJc3RhdGljIHNpemVfdCBsaW1pdCA9IDA7CglpZiAoIWxpbWl0KSB7CgkJbGltaXQgPSBnaXRfZW52X3Vsb25nKCJHSVRfTU1BUF9MSU1JVCIsIDApOwoJCWlmICghbGltaXQpCgkJCWxpbWl0ID0gU0laRV9NQVg7Cgl9CglpZiAobGVuZ3RoID4gbGltaXQpCgkJZGllKCJhdHRlbXB0aW5nIHRvIG1tYXAgJSJQUkl1TUFYIiBvdmVyIGxpbWl0ICUiUFJJdU1BWCwKCQkgICAgKHVpbnRtYXhfdClsZW5ndGgsICh1aW50bWF4X3QpbGltaXQpOwp9Cgp2b2lkICp4bW1hcF9nZW50bHkodm9pZCAqc3RhcnQsIHNpemVfdCBsZW5ndGgsCgkJICBpbnQgcHJvdCwgaW50IGZsYWdzLCBpbnQgZmQsIG9mZl90IG9mZnNldCkKewoJdm9pZCAqcmV0OwoKCW1tYXBfbGltaXRfY2hlY2sobGVuZ3RoKTsKCXJldCA9IG1tYXAoc3RhcnQsIGxlbmd0aCwgcHJvdCwgZmxhZ3MsIGZkLCBvZmZzZXQpOwoJaWYgKHJldCA9PSBNQVBfRkFJTEVEKSB7CgkJaWYgKCFsZW5ndGgpCgkJCXJldHVybiBOVUxMOwoJCXJlbGVhc2VfcGFja19tZW1vcnkobGVuZ3RoKTsKCQlyZXQgPSBtbWFwKHN0YXJ0LCBsZW5ndGgsIHByb3QsIGZsYWdzLCBmZCwgb2Zmc2V0KTsKCX0KCXJldHVybiByZXQ7Cn0KCnZvaWQgKnhtbWFwKHZvaWQgKnN0YXJ0LCBzaXplX3QgbGVuZ3RoLAoJaW50IHByb3QsIGludCBmbGFncywgaW50IGZkLCBvZmZfdCBvZmZzZXQpCnsKCXZvaWQgKnJldCA9IHhtbWFwX2dlbnRseShzdGFydCwgbGVuZ3RoLCBwcm90LCBmbGFncywgZmQsIG9mZnNldCk7CglpZiAocmV0ID09IE1BUF9GQUlMRUQpCgkJZGllX2Vycm5vKCJtbWFwIGZhaWxlZCIpOwoJcmV0dXJuIHJldDsKfQoKLyoKICogV2l0aCBhbiBpbi1jb3JlIG9iamVjdCBkYXRhIGluICJtYXAiLCByZWhhc2ggaXQgdG8gbWFrZSBzdXJlIHRoZQogKiBvYmplY3QgbmFtZSBhY3R1YWxseSBtYXRjaGVzICJzaGExIiB0byBkZXRlY3Qgb2JqZWN0IGNvcnJ1cHRpb24uCiAqIFdpdGggIm1hcCIgPT0gTlVMTCwgdHJ5IHJlYWRpbmcgdGhlIG9iamVjdCBuYW1lZCB3aXRoICJzaGExIiB1c2luZwogKiB0aGUgc3RyZWFtaW5nIGludGVyZmFjZSBhbmQgcmVoYXNoIGl0IHRvIGRvIHRoZSBzYW1lLgogKi8KaW50IGNoZWNrX29iamVjdF9zaWduYXR1cmUoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCB2b2lkICptYXAsCgkJCSAgIHVuc2lnbmVkIGxvbmcgc2l6ZSwgY29uc3QgY2hhciAqdHlwZSkKewoJc3RydWN0IG9iamVjdF9pZCByZWFsX29pZDsKCWVudW0gb2JqZWN0X3R5cGUgb2JqX3R5cGU7CglzdHJ1Y3QgZ2l0X2lzdHJlYW0gKnN0OwoJZ2l0X2hhc2hfY3R4IGM7CgljaGFyIGhkcltNQVhfSEVBREVSX0xFTl07CglpbnQgaGRybGVuOwoKCWlmIChtYXApIHsKCQloYXNoX29iamVjdF9maWxlKG1hcCwgc2l6ZSwgdHlwZSwgJnJlYWxfb2lkKTsKCQlyZXR1cm4gb2lkY21wKG9pZCwgJnJlYWxfb2lkKSA/IC0xIDogMDsKCX0KCglzdCA9IG9wZW5faXN0cmVhbShvaWQsICZvYmpfdHlwZSwgJnNpemUsIE5VTEwpOwoJaWYgKCFzdCkKCQlyZXR1cm4gLTE7CgoJLyogR2VuZXJhdGUgdGhlIGhlYWRlciAqLwoJaGRybGVuID0geHNucHJpbnRmKGhkciwgc2l6ZW9mKGhkciksICIlcyAlbHUiLCB0eXBlX25hbWUob2JqX3R5cGUpLCBzaXplKSArIDE7CgoJLyogU2hhMS4uICovCgl0aGVfaGFzaF9hbGdvLT5pbml0X2ZuKCZjKTsKCXRoZV9oYXNoX2FsZ28tPnVwZGF0ZV9mbigmYywgaGRyLCBoZHJsZW4pOwoJZm9yICg7OykgewoJCWNoYXIgYnVmWzEwMjQgKiAxNl07CgkJc3NpemVfdCByZWFkbGVuID0gcmVhZF9pc3RyZWFtKHN0LCBidWYsIHNpemVvZihidWYpKTsKCgkJaWYgKHJlYWRsZW4gPCAwKSB7CgkJCWNsb3NlX2lzdHJlYW0oc3QpOwoJCQlyZXR1cm4gLTE7CgkJfQoJCWlmICghcmVhZGxlbikKCQkJYnJlYWs7CgkJdGhlX2hhc2hfYWxnby0+dXBkYXRlX2ZuKCZjLCBidWYsIHJlYWRsZW4pOwoJfQoJdGhlX2hhc2hfYWxnby0+ZmluYWxfZm4ocmVhbF9vaWQuaGFzaCwgJmMpOwoJY2xvc2VfaXN0cmVhbShzdCk7CglyZXR1cm4gb2lkY21wKG9pZCwgJnJlYWxfb2lkKSA/IC0xIDogMDsKfQoKaW50IGdpdF9vcGVuX2Nsb2V4ZWMoY29uc3QgY2hhciAqbmFtZSwgaW50IGZsYWdzKQp7CglpbnQgZmQ7CglzdGF0aWMgaW50IG9fY2xvZXhlYyA9IE9fQ0xPRVhFQzsKCglmZCA9IG9wZW4obmFtZSwgZmxhZ3MgfCBvX2Nsb2V4ZWMpOwoJaWYgKChvX2Nsb2V4ZWMgJiBPX0NMT0VYRUMpICYmIGZkIDwgMCAmJiBlcnJubyA9PSBFSU5WQUwpIHsKCQkvKiBUcnkgYWdhaW4gdy9vIE9fQ0xPRVhFQzogdGhlIGtlcm5lbCBtaWdodCBub3Qgc3VwcG9ydCBpdCAqLwoJCW9fY2xvZXhlYyAmPSB+T19DTE9FWEVDOwoJCWZkID0gb3BlbihuYW1lLCBmbGFncyB8IG9fY2xvZXhlYyk7Cgl9CgojaWYgZGVmaW5lZChGX0dFVEZEKSAmJiBkZWZpbmVkKEZfU0VURkQpICYmIGRlZmluZWQoRkRfQ0xPRVhFQykKCXsKCQlzdGF0aWMgaW50IGZkX2Nsb2V4ZWMgPSBGRF9DTE9FWEVDOwoKCQlpZiAoIW9fY2xvZXhlYyAmJiAwIDw9IGZkICYmIGZkX2Nsb2V4ZWMpIHsKCQkJLyogT3BlbmVkIHcvbyBPX0NMT0VYRUM/ICB0cnkgd2l0aCBmY250bCgyKSB0byBhZGQgaXQgKi8KCQkJaW50IGZsYWdzID0gZmNudGwoZmQsIEZfR0VURkQpOwoJCQlpZiAoZmNudGwoZmQsIEZfU0VURkQsIGZsYWdzIHwgZmRfY2xvZXhlYykpCgkJCQlmZF9jbG9leGVjID0gMDsKCQl9Cgl9CiNlbmRpZgoJcmV0dXJuIGZkOwp9CgovKgogKiBGaW5kICJzaGExIiBhcyBhIGxvb3NlIG9iamVjdCBpbiB0aGUgbG9jYWwgcmVwb3NpdG9yeSBvciBpbiBhbiBhbHRlcm5hdGUuCiAqIFJldHVybnMgMCBvbiBzdWNjZXNzLCBuZWdhdGl2ZSBvbiBmYWlsdXJlLgogKgogKiBUaGUgInBhdGgiIG91dC1wYXJhbWV0ZXIgd2lsbCBnaXZlIHRoZSBwYXRoIG9mIHRoZSBvYmplY3Qgd2UgZm91bmQgKGlmIGFueSkuCiAqIE5vdGUgdGhhdCBpdCBtYXkgcG9pbnQgdG8gc3RhdGljIHN0b3JhZ2UgYW5kIGlzIG9ubHkgdmFsaWQgdW50aWwgYW5vdGhlcgogKiBjYWxsIHRvIHNoYTFfZmlsZV9uYW1lKCksIGV0Yy4KICovCnN0YXRpYyBpbnQgc3RhdF9zaGExX2ZpbGUoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsCgkJCSAgc3RydWN0IHN0YXQgKnN0LCBjb25zdCBjaGFyICoqcGF0aCkKewoJc3RydWN0IGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UgKmFsdDsKCXN0YXRpYyBzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoKCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCXNoYTFfZmlsZV9uYW1lKHIsICZidWYsIHNoYTEpOwoJKnBhdGggPSBidWYuYnVmOwoKCWlmICghbHN0YXQoKnBhdGgsIHN0KSkKCQlyZXR1cm4gMDsKCglwcmVwYXJlX2FsdF9vZGIocik7CgllcnJubyA9IEVOT0VOVDsKCWZvciAoYWx0ID0gci0+b2JqZWN0cy0+YWx0X29kYl9saXN0OyBhbHQ7IGFsdCA9IGFsdC0+bmV4dCkgewoJCSpwYXRoID0gYWx0X3NoYTFfcGF0aChhbHQsIHNoYTEpOwoJCWlmICghbHN0YXQoKnBhdGgsIHN0KSkKCQkJcmV0dXJuIDA7Cgl9CgoJcmV0dXJuIC0xOwp9CgovKgogKiBMaWtlIHN0YXRfc2hhMV9maWxlKCksIGJ1dCBhY3R1YWxseSBvcGVuIHRoZSBvYmplY3QgYW5kIHJldHVybiB0aGUKICogZGVzY3JpcHRvci4gU2VlIHRoZSBjYXZlYXRzIG9uIHRoZSAicGF0aCIgcGFyYW1ldGVyIGFib3ZlLgogKi8Kc3RhdGljIGludCBvcGVuX3NoYTFfZmlsZShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJICBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBjb25zdCBjaGFyICoqcGF0aCkKewoJaW50IGZkOwoJc3RydWN0IGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UgKmFsdDsKCWludCBtb3N0X2ludGVyZXN0aW5nX2Vycm5vOwoJc3RhdGljIHN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJc3RyYnVmX3Jlc2V0KCZidWYpOwoJc2hhMV9maWxlX25hbWUociwgJmJ1Ziwgc2hhMSk7CgkqcGF0aCA9IGJ1Zi5idWY7CgoJZmQgPSBnaXRfb3BlbigqcGF0aCk7CglpZiAoZmQgPj0gMCkKCQlyZXR1cm4gZmQ7Cgltb3N0X2ludGVyZXN0aW5nX2Vycm5vID0gZXJybm87CgoJcHJlcGFyZV9hbHRfb2RiKHIpOwoJZm9yIChhbHQgPSByLT5vYmplY3RzLT5hbHRfb2RiX2xpc3Q7IGFsdDsgYWx0ID0gYWx0LT5uZXh0KSB7CgkJKnBhdGggPSBhbHRfc2hhMV9wYXRoKGFsdCwgc2hhMSk7CgkJZmQgPSBnaXRfb3BlbigqcGF0aCk7CgkJaWYgKGZkID49IDApCgkJCXJldHVybiBmZDsKCQlpZiAobW9zdF9pbnRlcmVzdGluZ19lcnJubyA9PSBFTk9FTlQpCgkJCW1vc3RfaW50ZXJlc3RpbmdfZXJybm8gPSBlcnJubzsKCX0KCWVycm5vID0gbW9zdF9pbnRlcmVzdGluZ19lcnJubzsKCXJldHVybiAtMTsKfQoKLyoKICogTWFwIHRoZSBsb29zZSBvYmplY3QgYXQgInBhdGgiIGlmIGl0IGlzIG5vdCBOVUxMLCBvciB0aGUgcGF0aCBmb3VuZCBieQogKiBzZWFyY2hpbmcgZm9yIGEgbG9vc2Ugb2JqZWN0IG5hbWVkICJzaGExIi4KICovCnN0YXRpYyB2b2lkICptYXBfc2hhMV9maWxlXzEoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IGNoYXIgKnBhdGgsCgkJCSAgICAgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgdW5zaWduZWQgbG9uZyAqc2l6ZSkKewoJdm9pZCAqbWFwOwoJaW50IGZkOwoKCWlmIChwYXRoKQoJCWZkID0gZ2l0X29wZW4ocGF0aCk7CgllbHNlCgkJZmQgPSBvcGVuX3NoYTFfZmlsZShyLCBzaGExLCAmcGF0aCk7CgltYXAgPSBOVUxMOwoJaWYgKGZkID49IDApIHsKCQlzdHJ1Y3Qgc3RhdCBzdDsKCgkJaWYgKCFmc3RhdChmZCwgJnN0KSkgewoJCQkqc2l6ZSA9IHhzaXplX3Qoc3Quc3Rfc2l6ZSk7CgkJCWlmICghKnNpemUpIHsKCQkJCS8qIG1tYXAoKSBpcyBmb3JiaWRkZW4gb24gZW1wdHkgZmlsZXMgKi8KCQkJCWVycm9yKCJvYmplY3QgZmlsZSAlcyBpcyBlbXB0eSIsIHBhdGgpOwoJCQkJcmV0dXJuIE5VTEw7CgkJCX0KCQkJbWFwID0geG1tYXAoTlVMTCwgKnNpemUsIFBST1RfUkVBRCwgTUFQX1BSSVZBVEUsIGZkLCAwKTsKCQl9CgkJY2xvc2UoZmQpOwoJfQoJcmV0dXJuIG1hcDsKfQoKdm9pZCAqbWFwX3NoYTFfZmlsZShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkgICAgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgdW5zaWduZWQgbG9uZyAqc2l6ZSkKewoJcmV0dXJuIG1hcF9zaGExX2ZpbGVfMShyLCBOVUxMLCBzaGExLCBzaXplKTsKfQoKc3RhdGljIGludCB1bnBhY2tfc2hhMV9zaG9ydF9oZWFkZXIoZ2l0X3pzdHJlYW0gKnN0cmVhbSwKCQkJCSAgICB1bnNpZ25lZCBjaGFyICptYXAsIHVuc2lnbmVkIGxvbmcgbWFwc2l6ZSwKCQkJCSAgICB2b2lkICpidWZmZXIsIHVuc2lnbmVkIGxvbmcgYnVmc2l6KQp7CgkvKiBHZXQgdGhlIGRhdGEgc3RyZWFtICovCgltZW1zZXQoc3RyZWFtLCAwLCBzaXplb2YoKnN0cmVhbSkpOwoJc3RyZWFtLT5uZXh0X2luID0gbWFwOwoJc3RyZWFtLT5hdmFpbF9pbiA9IG1hcHNpemU7CglzdHJlYW0tPm5leHRfb3V0ID0gYnVmZmVyOwoJc3RyZWFtLT5hdmFpbF9vdXQgPSBidWZzaXo7CgoJZ2l0X2luZmxhdGVfaW5pdChzdHJlYW0pOwoJcmV0dXJuIGdpdF9pbmZsYXRlKHN0cmVhbSwgMCk7Cn0KCmludCB1bnBhY2tfc2hhMV9oZWFkZXIoZ2l0X3pzdHJlYW0gKnN0cmVhbSwKCQkgICAgICAgdW5zaWduZWQgY2hhciAqbWFwLCB1bnNpZ25lZCBsb25nIG1hcHNpemUsCgkJICAgICAgIHZvaWQgKmJ1ZmZlciwgdW5zaWduZWQgbG9uZyBidWZzaXopCnsKCWludCBzdGF0dXMgPSB1bnBhY2tfc2hhMV9zaG9ydF9oZWFkZXIoc3RyZWFtLCBtYXAsIG1hcHNpemUsCgkJCQkJICAgICAgYnVmZmVyLCBidWZzaXopOwoKCWlmIChzdGF0dXMgPCBaX09LKQoJCXJldHVybiBzdGF0dXM7CgoJLyogTWFrZSBzdXJlIHdlIGhhdmUgdGhlIHRlcm1pbmF0aW5nIE5VTCAqLwoJaWYgKCFtZW1jaHIoYnVmZmVyLCAnXDAnLCBzdHJlYW0tPm5leHRfb3V0IC0gKHVuc2lnbmVkIGNoYXIgKilidWZmZXIpKQoJCXJldHVybiAtMTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHVucGFja19zaGExX2hlYWRlcl90b19zdHJidWYoZ2l0X3pzdHJlYW0gKnN0cmVhbSwgdW5zaWduZWQgY2hhciAqbWFwLAoJCQkJCXVuc2lnbmVkIGxvbmcgbWFwc2l6ZSwgdm9pZCAqYnVmZmVyLAoJCQkJCXVuc2lnbmVkIGxvbmcgYnVmc2l6LCBzdHJ1Y3Qgc3RyYnVmICpoZWFkZXIpCnsKCWludCBzdGF0dXM7CgoJc3RhdHVzID0gdW5wYWNrX3NoYTFfc2hvcnRfaGVhZGVyKHN0cmVhbSwgbWFwLCBtYXBzaXplLCBidWZmZXIsIGJ1ZnNpeik7CglpZiAoc3RhdHVzIDwgWl9PSykKCQlyZXR1cm4gLTE7CgoJLyoKCSAqIENoZWNrIGlmIGVudGlyZSBoZWFkZXIgaXMgdW5wYWNrZWQgaW4gdGhlIGZpcnN0IGl0ZXJhdGlvbi4KCSAqLwoJaWYgKG1lbWNocihidWZmZXIsICdcMCcsIHN0cmVhbS0+bmV4dF9vdXQgLSAodW5zaWduZWQgY2hhciAqKWJ1ZmZlcikpCgkJcmV0dXJuIDA7CgoJLyoKCSAqIGJ1ZmZlclswLi5idWZzaXpdIHdhcyBub3QgbGFyZ2UgZW5vdWdoLiAgQ29weSB0aGUgcGFydGlhbAoJICogcmVzdWx0IG91dCB0byBoZWFkZXIsIGFuZCB0aGVuIGFwcGVuZCB0aGUgcmVzdWx0IG9mIGZ1cnRoZXIKCSAqIHJlYWRpbmcgdGhlIHN0cmVhbS4KCSAqLwoJc3RyYnVmX2FkZChoZWFkZXIsIGJ1ZmZlciwgc3RyZWFtLT5uZXh0X291dCAtICh1bnNpZ25lZCBjaGFyICopYnVmZmVyKTsKCXN0cmVhbS0+bmV4dF9vdXQgPSBidWZmZXI7CglzdHJlYW0tPmF2YWlsX291dCA9IGJ1ZnNpejsKCglkbyB7CgkJc3RhdHVzID0gZ2l0X2luZmxhdGUoc3RyZWFtLCAwKTsKCQlzdHJidWZfYWRkKGhlYWRlciwgYnVmZmVyLCBzdHJlYW0tPm5leHRfb3V0IC0gKHVuc2lnbmVkIGNoYXIgKilidWZmZXIpOwoJCWlmIChtZW1jaHIoYnVmZmVyLCAnXDAnLCBzdHJlYW0tPm5leHRfb3V0IC0gKHVuc2lnbmVkIGNoYXIgKilidWZmZXIpKQoJCQlyZXR1cm4gMDsKCQlzdHJlYW0tPm5leHRfb3V0ID0gYnVmZmVyOwoJCXN0cmVhbS0+YXZhaWxfb3V0ID0gYnVmc2l6OwoJfSB3aGlsZSAoc3RhdHVzICE9IFpfU1RSRUFNX0VORCk7CglyZXR1cm4gLTE7Cn0KCnN0YXRpYyB2b2lkICp1bnBhY2tfc2hhMV9yZXN0KGdpdF96c3RyZWFtICpzdHJlYW0sIHZvaWQgKmJ1ZmZlciwgdW5zaWduZWQgbG9uZyBzaXplLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglpbnQgYnl0ZXMgPSBzdHJsZW4oYnVmZmVyKSArIDE7Cgl1bnNpZ25lZCBjaGFyICpidWYgPSB4bWFsbG9jeihzaXplKTsKCXVuc2lnbmVkIGxvbmcgbjsKCWludCBzdGF0dXMgPSBaX09LOwoKCW4gPSBzdHJlYW0tPnRvdGFsX291dCAtIGJ5dGVzOwoJaWYgKG4gPiBzaXplKQoJCW4gPSBzaXplOwoJbWVtY3B5KGJ1ZiwgKGNoYXIgKikgYnVmZmVyICsgYnl0ZXMsIG4pOwoJYnl0ZXMgPSBuOwoJaWYgKGJ5dGVzIDw9IHNpemUpIHsKCQkvKgoJCSAqIFRoZSBhYm92ZSBjb25kaXRpb24gbXVzdCBiZSAoYnl0ZXMgPD0gc2l6ZSksIG5vdAoJCSAqIChieXRlcyA8IHNpemUpLiAgSW4gb3RoZXIgd29yZHMsIGV2ZW4gdGhvdWdoIHdlCgkJICogZXhwZWN0IG5vIG1vcmUgb3V0cHV0IGFuZCBzZXQgYXZhaWxfb3V0IHRvIHplcm8sCgkJICogdGhlIGlucHV0IHpsaWIgc3RyZWFtIG1heSBoYXZlIGJ5dGVzIHRoYXQgZXhwcmVzcwoJCSAqICJ0aGlzIGNvbmNsdWRlcyB0aGUgc3RyZWFtIiwgYW5kIHdlICpkbyogd2FudCB0bwoJCSAqIGVhdCB0aGF0IGlucHV0LgoJCSAqCgkJICogT3RoZXJ3aXNlIHdlIHdvdWxkIG5vdCBiZSBhYmxlIHRvIHRlc3QgdGhhdCB3ZQoJCSAqIGNvbnN1bWVkIGFsbCB0aGUgaW5wdXQgdG8gcmVhY2ggdGhlIGV4cGVjdGVkIHNpemU7CgkJICogd2UgYWxzbyB3YW50IHRvIGNoZWNrIHRoYXQgemxpYiB0ZWxscyB1cyB0aGF0IGFsbAoJCSAqIHdlbnQgd2VsbCB3aXRoIHN0YXR1cyA9PSBaX1NUUkVBTV9FTkQgYXQgdGhlIGVuZC4KCQkgKi8KCQlzdHJlYW0tPm5leHRfb3V0ID0gYnVmICsgYnl0ZXM7CgkJc3RyZWFtLT5hdmFpbF9vdXQgPSBzaXplIC0gYnl0ZXM7CgkJd2hpbGUgKHN0YXR1cyA9PSBaX09LKQoJCQlzdGF0dXMgPSBnaXRfaW5mbGF0ZShzdHJlYW0sIFpfRklOSVNIKTsKCX0KCWlmIChzdGF0dXMgPT0gWl9TVFJFQU1fRU5EICYmICFzdHJlYW0tPmF2YWlsX2luKSB7CgkJZ2l0X2luZmxhdGVfZW5kKHN0cmVhbSk7CgkJcmV0dXJuIGJ1ZjsKCX0KCglpZiAoc3RhdHVzIDwgMCkKCQllcnJvcigiY29ycnVwdCBsb29zZSBvYmplY3QgJyVzJyIsIHNoYTFfdG9faGV4KHNoYTEpKTsKCWVsc2UgaWYgKHN0cmVhbS0+YXZhaWxfaW4pCgkJZXJyb3IoImdhcmJhZ2UgYXQgZW5kIG9mIGxvb3NlIG9iamVjdCAnJXMnIiwKCQkgICAgICBzaGExX3RvX2hleChzaGExKSk7CglmcmVlKGJ1Zik7CglyZXR1cm4gTlVMTDsKfQoKLyoKICogV2UgdXNlZCB0byBqdXN0IHVzZSAic3NjYW5mKCkiLCBidXQgdGhhdCdzIGFjdHVhbGx5IHdheQogKiB0b28gcGVybWlzc2l2ZSBmb3Igd2hhdCB3ZSB3YW50IHRvIGNoZWNrLiBTbyBkbyBhbiBhbmFsCiAqIG9iamVjdCBoZWFkZXIgcGFyc2UgYnkgaGFuZC4KICovCnN0YXRpYyBpbnQgcGFyc2Vfc2hhMV9oZWFkZXJfZXh0ZW5kZWQoY29uc3QgY2hhciAqaGRyLCBzdHJ1Y3Qgb2JqZWN0X2luZm8gKm9pLAoJCQkgICAgICAgdW5zaWduZWQgaW50IGZsYWdzKQp7Cgljb25zdCBjaGFyICp0eXBlX2J1ZiA9IGhkcjsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCWludCB0eXBlLCB0eXBlX2xlbiA9IDA7CgoJLyoKCSAqIFRoZSB0eXBlIGNhbiBiZSBvZiBhbnkgc2l6ZSBidXQgaXMgZm9sbG93ZWQgYnkKCSAqIGEgc3BhY2UuCgkgKi8KCWZvciAoOzspIHsKCQljaGFyIGMgPSAqaGRyKys7CgkJaWYgKCFjKQoJCQlyZXR1cm4gLTE7CgkJaWYgKGMgPT0gJyAnKQoJCQlicmVhazsKCQl0eXBlX2xlbisrOwoJfQoKCXR5cGUgPSB0eXBlX2Zyb21fc3RyaW5nX2dlbnRseSh0eXBlX2J1ZiwgdHlwZV9sZW4sIDEpOwoJaWYgKG9pLT50eXBlX25hbWUpCgkJc3RyYnVmX2FkZChvaS0+dHlwZV9uYW1lLCB0eXBlX2J1ZiwgdHlwZV9sZW4pOwoJLyoKCSAqIFNldCB0eXBlIHRvIDAgaWYgaXRzIGFuIHVua25vd24gb2JqZWN0IGFuZAoJICogd2UncmUgb2J0YWluaW5nIHRoZSB0eXBlIHVzaW5nICctLWFsbG93LXVua25vd24tdHlwZScKCSAqIG9wdGlvbi4KCSAqLwoJaWYgKChmbGFncyAmIE9CSkVDVF9JTkZPX0FMTE9XX1VOS05PV05fVFlQRSkgJiYgKHR5cGUgPCAwKSkKCQl0eXBlID0gMDsKCWVsc2UgaWYgKHR5cGUgPCAwKQoJCWRpZSgiaW52YWxpZCBvYmplY3QgdHlwZSIpOwoJaWYgKG9pLT50eXBlcCkKCQkqb2ktPnR5cGVwID0gdHlwZTsKCgkvKgoJICogVGhlIGxlbmd0aCBtdXN0IGZvbGxvdyBpbW1lZGlhdGVseSwgYW5kIGJlIGluIGNhbm9uaWNhbAoJICogZGVjaW1hbCBmb3JtYXQgKGllICIwMTAiIGlzIG5vdCB2YWxpZCkuCgkgKi8KCXNpemUgPSAqaGRyKysgLSAnMCc7CglpZiAoc2l6ZSA+IDkpCgkJcmV0dXJuIC0xOwoJaWYgKHNpemUpIHsKCQlmb3IgKDs7KSB7CgkJCXVuc2lnbmVkIGxvbmcgYyA9ICpoZHIgLSAnMCc7CgkJCWlmIChjID4gOSkKCQkJCWJyZWFrOwoJCQloZHIrKzsKCQkJc2l6ZSA9IHNpemUgKiAxMCArIGM7CgkJfQoJfQoKCWlmIChvaS0+c2l6ZXApCgkJKm9pLT5zaXplcCA9IHNpemU7CgoJLyoKCSAqIFRoZSBsZW5ndGggbXVzdCBiZSBmb2xsb3dlZCBieSBhIHplcm8gYnl0ZQoJICovCglyZXR1cm4gKmhkciA/IC0xIDogdHlwZTsKfQoKaW50IHBhcnNlX3NoYTFfaGVhZGVyKGNvbnN0IGNoYXIgKmhkciwgdW5zaWduZWQgbG9uZyAqc2l6ZXApCnsKCXN0cnVjdCBvYmplY3RfaW5mbyBvaSA9IE9CSkVDVF9JTkZPX0lOSVQ7CgoJb2kuc2l6ZXAgPSBzaXplcDsKCXJldHVybiBwYXJzZV9zaGExX2hlYWRlcl9leHRlbmRlZChoZHIsICZvaSwgMCk7Cn0KCnN0YXRpYyBpbnQgc2hhMV9sb29zZV9vYmplY3RfaW5mbyhzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJCSAgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkJCSAgc3RydWN0IG9iamVjdF9pbmZvICpvaSwgaW50IGZsYWdzKQp7CglpbnQgc3RhdHVzID0gMDsKCXVuc2lnbmVkIGxvbmcgbWFwc2l6ZTsKCXZvaWQgKm1hcDsKCWdpdF96c3RyZWFtIHN0cmVhbTsKCWNoYXIgaGRyW01BWF9IRUFERVJfTEVOXTsKCXN0cnVjdCBzdHJidWYgaGRyYnVmID0gU1RSQlVGX0lOSVQ7Cgl1bnNpZ25lZCBsb25nIHNpemVfc2NyYXRjaDsKCglpZiAob2ktPmRlbHRhX2Jhc2Vfc2hhMSkKCQloYXNoY2xyKG9pLT5kZWx0YV9iYXNlX3NoYTEpOwoKCS8qCgkgKiBJZiB3ZSBkb24ndCBjYXJlIGFib3V0IHR5cGUgb3Igc2l6ZSwgdGhlbiB3ZSBkb24ndAoJICogbmVlZCB0byBsb29rIGluc2lkZSB0aGUgb2JqZWN0IGF0IGFsbC4gTm90ZSB0aGF0IHdlCgkgKiBkbyBub3Qgb3B0aW1pemUgb3V0IHRoZSBzdGF0IGNhbGwsIGV2ZW4gaWYgdGhlCgkgKiBjYWxsZXIgZG9lc24ndCBjYXJlIGFib3V0IHRoZSBkaXNrLXNpemUsIHNpbmNlIG91cgoJICogcmV0dXJuIHZhbHVlIGltcGxpY2l0bHkgaW5kaWNhdGVzIHdoZXRoZXIgdGhlCgkgKiBvYmplY3QgZXZlbiBleGlzdHMuCgkgKi8KCWlmICghb2ktPnR5cGVwICYmICFvaS0+dHlwZV9uYW1lICYmICFvaS0+c2l6ZXAgJiYgIW9pLT5jb250ZW50cCkgewoJCWNvbnN0IGNoYXIgKnBhdGg7CgkJc3RydWN0IHN0YXQgc3Q7CgkJaWYgKHN0YXRfc2hhMV9maWxlKHIsIHNoYTEsICZzdCwgJnBhdGgpIDwgMCkKCQkJcmV0dXJuIC0xOwoJCWlmIChvaS0+ZGlza19zaXplcCkKCQkJKm9pLT5kaXNrX3NpemVwID0gc3Quc3Rfc2l6ZTsKCQlyZXR1cm4gMDsKCX0KCgltYXAgPSBtYXBfc2hhMV9maWxlKHIsIHNoYTEsICZtYXBzaXplKTsKCWlmICghbWFwKQoJCXJldHVybiAtMTsKCglpZiAoIW9pLT5zaXplcCkKCQlvaS0+c2l6ZXAgPSAmc2l6ZV9zY3JhdGNoOwoKCWlmIChvaS0+ZGlza19zaXplcCkKCQkqb2ktPmRpc2tfc2l6ZXAgPSBtYXBzaXplOwoJaWYgKChmbGFncyAmIE9CSkVDVF9JTkZPX0FMTE9XX1VOS05PV05fVFlQRSkpIHsKCQlpZiAodW5wYWNrX3NoYTFfaGVhZGVyX3RvX3N0cmJ1Zigmc3RyZWFtLCBtYXAsIG1hcHNpemUsIGhkciwgc2l6ZW9mKGhkciksICZoZHJidWYpIDwgMCkKCQkJc3RhdHVzID0gZXJyb3IoInVuYWJsZSB0byB1bnBhY2sgJXMgaGVhZGVyIHdpdGggLS1hbGxvdy11bmtub3duLXR5cGUiLAoJCQkJICAgICAgIHNoYTFfdG9faGV4KHNoYTEpKTsKCX0gZWxzZSBpZiAodW5wYWNrX3NoYTFfaGVhZGVyKCZzdHJlYW0sIG1hcCwgbWFwc2l6ZSwgaGRyLCBzaXplb2YoaGRyKSkgPCAwKQoJCXN0YXR1cyA9IGVycm9yKCJ1bmFibGUgdG8gdW5wYWNrICVzIGhlYWRlciIsCgkJCSAgICAgICBzaGExX3RvX2hleChzaGExKSk7CglpZiAoc3RhdHVzIDwgMCkKCQk7IC8qIERvIG5vdGhpbmcgKi8KCWVsc2UgaWYgKGhkcmJ1Zi5sZW4pIHsKCQlpZiAoKHN0YXR1cyA9IHBhcnNlX3NoYTFfaGVhZGVyX2V4dGVuZGVkKGhkcmJ1Zi5idWYsIG9pLCBmbGFncykpIDwgMCkKCQkJc3RhdHVzID0gZXJyb3IoInVuYWJsZSB0byBwYXJzZSAlcyBoZWFkZXIgd2l0aCAtLWFsbG93LXVua25vd24tdHlwZSIsCgkJCQkgICAgICAgc2hhMV90b19oZXgoc2hhMSkpOwoJfSBlbHNlIGlmICgoc3RhdHVzID0gcGFyc2Vfc2hhMV9oZWFkZXJfZXh0ZW5kZWQoaGRyLCBvaSwgZmxhZ3MpKSA8IDApCgkJc3RhdHVzID0gZXJyb3IoInVuYWJsZSB0byBwYXJzZSAlcyBoZWFkZXIiLCBzaGExX3RvX2hleChzaGExKSk7CgoJaWYgKHN0YXR1cyA+PSAwICYmIG9pLT5jb250ZW50cCkgewoJCSpvaS0+Y29udGVudHAgPSB1bnBhY2tfc2hhMV9yZXN0KCZzdHJlYW0sIGhkciwKCQkJCQkJICpvaS0+c2l6ZXAsIHNoYTEpOwoJCWlmICghKm9pLT5jb250ZW50cCkgewoJCQlnaXRfaW5mbGF0ZV9lbmQoJnN0cmVhbSk7CgkJCXN0YXR1cyA9IC0xOwoJCX0KCX0gZWxzZQoJCWdpdF9pbmZsYXRlX2VuZCgmc3RyZWFtKTsKCgltdW5tYXAobWFwLCBtYXBzaXplKTsKCWlmIChzdGF0dXMgJiYgb2ktPnR5cGVwKQoJCSpvaS0+dHlwZXAgPSBzdGF0dXM7CglpZiAob2ktPnNpemVwID09ICZzaXplX3NjcmF0Y2gpCgkJb2ktPnNpemVwID0gTlVMTDsKCXN0cmJ1Zl9yZWxlYXNlKCZoZHJidWYpOwoJb2ktPndoZW5jZSA9IE9JX0xPT1NFOwoJcmV0dXJuIChzdGF0dXMgPCAwKSA/IHN0YXR1cyA6IDA7Cn0KCmludCBmZXRjaF9pZl9taXNzaW5nID0gMTsKCmludCBvaWRfb2JqZWN0X2luZm9fZXh0ZW5kZWQoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJICAgICBzdHJ1Y3Qgb2JqZWN0X2luZm8gKm9pLCB1bnNpZ25lZCBmbGFncykKewoJc3RhdGljIHN0cnVjdCBvYmplY3RfaW5mbyBibGFua19vaSA9IE9CSkVDVF9JTkZPX0lOSVQ7CglzdHJ1Y3QgcGFja19lbnRyeSBlOwoJaW50IHJ0eXBlOwoJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqcmVhbCA9IG9pZDsKCWludCBhbHJlYWR5X3JldHJpZWQgPSAwOwoKCWlmIChmbGFncyAmIE9CSkVDVF9JTkZPX0xPT0tVUF9SRVBMQUNFKQoJCXJlYWwgPSBsb29rdXBfcmVwbGFjZV9vYmplY3Qociwgb2lkKTsKCglpZiAoaXNfbnVsbF9vaWQocmVhbCkpCgkJcmV0dXJuIC0xOwoKCWlmICghb2kpCgkJb2kgPSAmYmxhbmtfb2k7CgoJaWYgKCEoZmxhZ3MgJiBPQkpFQ1RfSU5GT19TS0lQX0NBQ0hFRCkpIHsKCQlzdHJ1Y3QgY2FjaGVkX29iamVjdCAqY28gPSBmaW5kX2NhY2hlZF9vYmplY3QocmVhbCk7CgkJaWYgKGNvKSB7CgkJCWlmIChvaS0+dHlwZXApCgkJCQkqKG9pLT50eXBlcCkgPSBjby0+dHlwZTsKCQkJaWYgKG9pLT5zaXplcCkKCQkJCSoob2ktPnNpemVwKSA9IGNvLT5zaXplOwoJCQlpZiAob2ktPmRpc2tfc2l6ZXApCgkJCQkqKG9pLT5kaXNrX3NpemVwKSA9IDA7CgkJCWlmIChvaS0+ZGVsdGFfYmFzZV9zaGExKQoJCQkJaGFzaGNscihvaS0+ZGVsdGFfYmFzZV9zaGExKTsKCQkJaWYgKG9pLT50eXBlX25hbWUpCgkJCQlzdHJidWZfYWRkc3RyKG9pLT50eXBlX25hbWUsIHR5cGVfbmFtZShjby0+dHlwZSkpOwoJCQlpZiAob2ktPmNvbnRlbnRwKQoJCQkJKm9pLT5jb250ZW50cCA9IHhtZW1kdXB6KGNvLT5idWYsIGNvLT5zaXplKTsKCQkJb2ktPndoZW5jZSA9IE9JX0NBQ0hFRDsKCQkJcmV0dXJuIDA7CgkJfQoJfQoKCXdoaWxlICgxKSB7CgkJaWYgKGZpbmRfcGFja19lbnRyeShyLCByZWFsLCAmZSkpCgkJCWJyZWFrOwoKCQlpZiAoZmxhZ3MgJiBPQkpFQ1RfSU5GT19JR05PUkVfTE9PU0UpCgkJCXJldHVybiAtMTsKCgkJLyogTW9zdCBsaWtlbHkgaXQncyBhIGxvb3NlIG9iamVjdC4gKi8KCQlpZiAoIXNoYTFfbG9vc2Vfb2JqZWN0X2luZm8ociwgcmVhbC0+aGFzaCwgb2ksIGZsYWdzKSkKCQkJcmV0dXJuIDA7CgoJCS8qIE5vdCBhIGxvb3NlIG9iamVjdDsgc29tZW9uZSBlbHNlIG1heSBoYXZlIGp1c3QgcGFja2VkIGl0LiAqLwoJCWlmICghKGZsYWdzICYgT0JKRUNUX0lORk9fUVVJQ0spKSB7CgkJCXJlcHJlcGFyZV9wYWNrZWRfZ2l0KHIpOwoJCQlpZiAoZmluZF9wYWNrX2VudHJ5KHIsIHJlYWwsICZlKSkKCQkJCWJyZWFrOwoJCX0KCgkJLyogQ2hlY2sgaWYgaXQgaXMgYSBtaXNzaW5nIG9iamVjdCAqLwoJCWlmIChmZXRjaF9pZl9taXNzaW5nICYmIHJlcG9zaXRvcnlfZm9ybWF0X3BhcnRpYWxfY2xvbmUgJiYKCQkgICAgIWFscmVhZHlfcmV0cmllZCAmJiByID09IHRoZV9yZXBvc2l0b3J5KSB7CgkJCS8qCgkJCSAqIFRPRE8gSW52ZXN0aWdhdGUgaGF2aW5nIGZldGNoX29iamVjdCgpIHJldHVybgoJCQkgKiBUT0RPIGVycm9yL3N1Y2Nlc3MgYW5kIHN0b3BwaW5nIHRoZSBtdXNpYyBoZXJlLgoJCQkgKiBUT0RPIFBhc3MgYSByZXBvc2l0b3J5IHN0cnVjdCB0aHJvdWdoIGZldGNoX29iamVjdCwKCQkJICogc3VjaCB0aGF0IGFyYml0cmFyeSByZXBvc2l0b3JpZXMgd29yay4KCQkJICovCgkJCWZldGNoX29iamVjdChyZXBvc2l0b3J5X2Zvcm1hdF9wYXJ0aWFsX2Nsb25lLCByZWFsLT5oYXNoKTsKCQkJYWxyZWFkeV9yZXRyaWVkID0gMTsKCQkJY29udGludWU7CgkJfQoKCQlyZXR1cm4gLTE7Cgl9CgoJaWYgKG9pID09ICZibGFua19vaSkKCQkvKgoJCSAqIFdlIGtub3cgdGhhdCB0aGUgY2FsbGVyIGRvZXNuJ3QgYWN0dWFsbHkgbmVlZCB0aGUKCQkgKiBpbmZvcm1hdGlvbiBiZWxvdywgc28gcmV0dXJuIGVhcmx5LgoJCSAqLwoJCXJldHVybiAwOwoJcnR5cGUgPSBwYWNrZWRfb2JqZWN0X2luZm8ociwgZS5wLCBlLm9mZnNldCwgb2kpOwoJaWYgKHJ0eXBlIDwgMCkgewoJCW1hcmtfYmFkX3BhY2tlZF9vYmplY3QoZS5wLCByZWFsLT5oYXNoKTsKCQlyZXR1cm4gb2lkX29iamVjdF9pbmZvX2V4dGVuZGVkKHIsIHJlYWwsIG9pLCAwKTsKCX0gZWxzZSBpZiAob2ktPndoZW5jZSA9PSBPSV9QQUNLRUQpIHsKCQlvaS0+dS5wYWNrZWQub2Zmc2V0ID0gZS5vZmZzZXQ7CgkJb2ktPnUucGFja2VkLnBhY2sgPSBlLnA7CgkJb2ktPnUucGFja2VkLmlzX2RlbHRhID0gKHJ0eXBlID09IE9CSl9SRUZfREVMVEEgfHwKCQkJCQkgcnR5cGUgPT0gT0JKX09GU19ERUxUQSk7Cgl9CgoJcmV0dXJuIDA7Cn0KCi8qIHJldHVybnMgZW51bSBvYmplY3RfdHlwZSBvciBuZWdhdGl2ZSAqLwppbnQgb2lkX29iamVjdF9pbmZvKHN0cnVjdCByZXBvc2l0b3J5ICpyLAoJCSAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJICAgIHVuc2lnbmVkIGxvbmcgKnNpemVwKQp7CgllbnVtIG9iamVjdF90eXBlIHR5cGU7CglzdHJ1Y3Qgb2JqZWN0X2luZm8gb2kgPSBPQkpFQ1RfSU5GT19JTklUOwoKCW9pLnR5cGVwID0gJnR5cGU7CglvaS5zaXplcCA9IHNpemVwOwoJaWYgKG9pZF9vYmplY3RfaW5mb19leHRlbmRlZChyLCBvaWQsICZvaSwKCQkJCSAgICAgIE9CSkVDVF9JTkZPX0xPT0tVUF9SRVBMQUNFKSA8IDApCgkJcmV0dXJuIC0xOwoJcmV0dXJuIHR5cGU7Cn0KCnN0YXRpYyB2b2lkICpyZWFkX29iamVjdChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBlbnVtIG9iamVjdF90eXBlICp0eXBlLAoJCQkgdW5zaWduZWQgbG9uZyAqc2l6ZSkKewoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CglzdHJ1Y3Qgb2JqZWN0X2luZm8gb2kgPSBPQkpFQ1RfSU5GT19JTklUOwoJdm9pZCAqY29udGVudDsKCW9pLnR5cGVwID0gdHlwZTsKCW9pLnNpemVwID0gc2l6ZTsKCW9pLmNvbnRlbnRwID0gJmNvbnRlbnQ7CgoJaGFzaGNweShvaWQuaGFzaCwgc2hhMSk7CgoJaWYgKG9pZF9vYmplY3RfaW5mb19leHRlbmRlZCh0aGVfcmVwb3NpdG9yeSwgJm9pZCwgJm9pLCAwKSA8IDApCgkJcmV0dXJuIE5VTEw7CglyZXR1cm4gY29udGVudDsKfQoKaW50IHByZXRlbmRfb2JqZWN0X2ZpbGUodm9pZCAqYnVmLCB1bnNpZ25lZCBsb25nIGxlbiwgZW51bSBvYmplY3RfdHlwZSB0eXBlLAoJCQlzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXN0cnVjdCBjYWNoZWRfb2JqZWN0ICpjbzsKCgloYXNoX29iamVjdF9maWxlKGJ1ZiwgbGVuLCB0eXBlX25hbWUodHlwZSksIG9pZCk7CglpZiAoaGFzX3NoYTFfZmlsZShvaWQtPmhhc2gpIHx8IGZpbmRfY2FjaGVkX29iamVjdChvaWQpKQoJCXJldHVybiAwOwoJQUxMT0NfR1JPVyhjYWNoZWRfb2JqZWN0cywgY2FjaGVkX29iamVjdF9uciArIDEsIGNhY2hlZF9vYmplY3RfYWxsb2MpOwoJY28gPSAmY2FjaGVkX29iamVjdHNbY2FjaGVkX29iamVjdF9ucisrXTsKCWNvLT5zaXplID0gbGVuOwoJY28tPnR5cGUgPSB0eXBlOwoJY28tPmJ1ZiA9IHhtYWxsb2MobGVuKTsKCW1lbWNweShjby0+YnVmLCBidWYsIGxlbik7CglvaWRjcHkoJmNvLT5vaWQsIG9pZCk7CglyZXR1cm4gMDsKfQoKLyoKICogVGhpcyBmdW5jdGlvbiBkaWVzIG9uIGNvcnJ1cHQgb2JqZWN0czsgdGhlIGNhbGxlcnMgd2hvIHdhbnQgdG8KICogZGVhbCB3aXRoIHRoZW0gc2hvdWxkIGFycmFuZ2UgdG8gY2FsbCByZWFkX29iamVjdCgpIGFuZCBnaXZlIGVycm9yCiAqIG1lc3NhZ2VzIHRoZW1zZWx2ZXMuCiAqLwp2b2lkICpyZWFkX29iamVjdF9maWxlX2V4dGVuZGVkKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCWVudW0gb2JqZWN0X3R5cGUgKnR5cGUsCgkJCQl1bnNpZ25lZCBsb25nICpzaXplLAoJCQkJaW50IGxvb2t1cF9yZXBsYWNlKQp7Cgl2b2lkICpkYXRhOwoJY29uc3Qgc3RydWN0IHBhY2tlZF9naXQgKnA7Cgljb25zdCBjaGFyICpwYXRoOwoJc3RydWN0IHN0YXQgc3Q7Cgljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpyZXBsID0gbG9va3VwX3JlcGxhY2UgPwoJCWxvb2t1cF9yZXBsYWNlX29iamVjdCh0aGVfcmVwb3NpdG9yeSwgb2lkKSA6IG9pZDsKCgllcnJubyA9IDA7CglkYXRhID0gcmVhZF9vYmplY3QocmVwbC0+aGFzaCwgdHlwZSwgc2l6ZSk7CglpZiAoZGF0YSkKCQlyZXR1cm4gZGF0YTsKCglpZiAoZXJybm8gJiYgZXJybm8gIT0gRU5PRU5UKQoJCWRpZV9lcnJubygiZmFpbGVkIHRvIHJlYWQgb2JqZWN0ICVzIiwgb2lkX3RvX2hleChvaWQpKTsKCgkvKiBkaWUgaWYgd2UgcmVwbGFjZWQgYW4gb2JqZWN0IHdpdGggb25lIHRoYXQgZG9lcyBub3QgZXhpc3QgKi8KCWlmIChyZXBsICE9IG9pZCkKCQlkaWUoInJlcGxhY2VtZW50ICVzIG5vdCBmb3VuZCBmb3IgJXMiLAoJCSAgICBvaWRfdG9faGV4KHJlcGwpLCBvaWRfdG9faGV4KG9pZCkpOwoKCWlmICghc3RhdF9zaGExX2ZpbGUodGhlX3JlcG9zaXRvcnksIHJlcGwtPmhhc2gsICZzdCwgJnBhdGgpKQoJCWRpZSgibG9vc2Ugb2JqZWN0ICVzIChzdG9yZWQgaW4gJXMpIGlzIGNvcnJ1cHQiLAoJCSAgICBvaWRfdG9faGV4KHJlcGwpLCBwYXRoKTsKCglpZiAoKHAgPSBoYXNfcGFja2VkX2FuZF9iYWQocmVwbC0+aGFzaCkpICE9IE5VTEwpCgkJZGllKCJwYWNrZWQgb2JqZWN0ICVzIChzdG9yZWQgaW4gJXMpIGlzIGNvcnJ1cHQiLAoJCSAgICBvaWRfdG9faGV4KHJlcGwpLCBwLT5wYWNrX25hbWUpOwoKCXJldHVybiBOVUxMOwp9Cgp2b2lkICpyZWFkX29iamVjdF93aXRoX3JlZmVyZW5jZShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCQkgY29uc3QgY2hhciAqcmVxdWlyZWRfdHlwZV9uYW1lLAoJCQkJIHVuc2lnbmVkIGxvbmcgKnNpemUsCgkJCQkgc3RydWN0IG9iamVjdF9pZCAqYWN0dWFsX29pZF9yZXR1cm4pCnsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZSwgcmVxdWlyZWRfdHlwZTsKCXZvaWQgKmJ1ZmZlcjsKCXVuc2lnbmVkIGxvbmcgaXNpemU7CglzdHJ1Y3Qgb2JqZWN0X2lkIGFjdHVhbF9vaWQ7CgoJcmVxdWlyZWRfdHlwZSA9IHR5cGVfZnJvbV9zdHJpbmcocmVxdWlyZWRfdHlwZV9uYW1lKTsKCW9pZGNweSgmYWN0dWFsX29pZCwgb2lkKTsKCXdoaWxlICgxKSB7CgkJaW50IHJlZl9sZW5ndGggPSAtMTsKCQljb25zdCBjaGFyICpyZWZfdHlwZSA9IE5VTEw7CgoJCWJ1ZmZlciA9IHJlYWRfb2JqZWN0X2ZpbGUoJmFjdHVhbF9vaWQsICZ0eXBlLCAmaXNpemUpOwoJCWlmICghYnVmZmVyKQoJCQlyZXR1cm4gTlVMTDsKCQlpZiAodHlwZSA9PSByZXF1aXJlZF90eXBlKSB7CgkJCSpzaXplID0gaXNpemU7CgkJCWlmIChhY3R1YWxfb2lkX3JldHVybikKCQkJCW9pZGNweShhY3R1YWxfb2lkX3JldHVybiwgJmFjdHVhbF9vaWQpOwoJCQlyZXR1cm4gYnVmZmVyOwoJCX0KCQkvKiBIYW5kbGUgcmVmZXJlbmNlcyAqLwoJCWVsc2UgaWYgKHR5cGUgPT0gT0JKX0NPTU1JVCkKCQkJcmVmX3R5cGUgPSAidHJlZSAiOwoJCWVsc2UgaWYgKHR5cGUgPT0gT0JKX1RBRykKCQkJcmVmX3R5cGUgPSAib2JqZWN0ICI7CgkJZWxzZSB7CgkJCWZyZWUoYnVmZmVyKTsKCQkJcmV0dXJuIE5VTEw7CgkJfQoJCXJlZl9sZW5ndGggPSBzdHJsZW4ocmVmX3R5cGUpOwoKCQlpZiAocmVmX2xlbmd0aCArIHRoZV9oYXNoX2FsZ28tPmhleHN6ID4gaXNpemUgfHwKCQkgICAgbWVtY21wKGJ1ZmZlciwgcmVmX3R5cGUsIHJlZl9sZW5ndGgpIHx8CgkJICAgIGdldF9vaWRfaGV4KChjaGFyICopIGJ1ZmZlciArIHJlZl9sZW5ndGgsICZhY3R1YWxfb2lkKSkgewoJCQlmcmVlKGJ1ZmZlcik7CgkJCXJldHVybiBOVUxMOwoJCX0KCQlmcmVlKGJ1ZmZlcik7CgkJLyogTm93IHdlIGhhdmUgdGhlIElEIG9mIHRoZSByZWZlcnJlZC10byBvYmplY3QgaW4KCQkgKiBhY3R1YWxfb2lkLiAgQ2hlY2sgYWdhaW4uICovCgl9Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX29iamVjdF9maWxlX3ByZXBhcmUoY29uc3Qgdm9pZCAqYnVmLCB1bnNpZ25lZCBsb25nIGxlbiwKCQkJCSAgICAgIGNvbnN0IGNoYXIgKnR5cGUsIHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCSAgICAgIGNoYXIgKmhkciwgaW50ICpoZHJsZW4pCnsKCWdpdF9oYXNoX2N0eCBjOwoKCS8qIEdlbmVyYXRlIHRoZSBoZWFkZXIgKi8KCSpoZHJsZW4gPSB4c25wcmludGYoaGRyLCAqaGRybGVuLCAiJXMgJWx1IiwgdHlwZSwgbGVuKSsxOwoKCS8qIFNoYTEuLiAqLwoJdGhlX2hhc2hfYWxnby0+aW5pdF9mbigmYyk7Cgl0aGVfaGFzaF9hbGdvLT51cGRhdGVfZm4oJmMsIGhkciwgKmhkcmxlbik7Cgl0aGVfaGFzaF9hbGdvLT51cGRhdGVfZm4oJmMsIGJ1ZiwgbGVuKTsKCXRoZV9oYXNoX2FsZ28tPmZpbmFsX2ZuKG9pZC0+aGFzaCwgJmMpOwp9CgovKgogKiBNb3ZlIHRoZSBqdXN0IHdyaXR0ZW4gb2JqZWN0IGludG8gaXRzIGZpbmFsIHJlc3RpbmcgcGxhY2UuCiAqLwppbnQgZmluYWxpemVfb2JqZWN0X2ZpbGUoY29uc3QgY2hhciAqdG1wZmlsZSwgY29uc3QgY2hhciAqZmlsZW5hbWUpCnsKCWludCByZXQgPSAwOwoKCWlmIChvYmplY3RfY3JlYXRpb25fbW9kZSA9PSBPQkpFQ1RfQ1JFQVRJT05fVVNFU19SRU5BTUVTKQoJCWdvdG8gdHJ5X3JlbmFtZTsKCWVsc2UgaWYgKGxpbmsodG1wZmlsZSwgZmlsZW5hbWUpKQoJCXJldCA9IGVycm5vOwoKCS8qCgkgKiBDb2RhIGhhY2sgLSBjb2RhIGRvZXNuJ3QgbGlrZSBjcm9zcy1kaXJlY3RvcnkgbGlua3MsCgkgKiBzbyB3ZSBmYWxsIGJhY2sgdG8gYSByZW5hbWUsIHdoaWNoIHdpbGwgbWVhbiB0aGF0IGl0CgkgKiB3b24ndCBiZSBhYmxlIHRvIGNoZWNrIGNvbGxpc2lvbnMsIGJ1dCB0aGF0J3Mgbm90IGEKCSAqIGJpZyBkZWFsLgoJICoKCSAqIFRoZSBzYW1lIGhvbGRzIGZvciBGQVQgZm9ybWF0dGVkIG1lZGlhLgoJICoKCSAqIFdoZW4gdGhpcyBzdWNjZWVkcywgd2UganVzdCByZXR1cm4uICBXZSBoYXZlIG5vdGhpbmcKCSAqIGxlZnQgdG8gdW5saW5rLgoJICovCglpZiAocmV0ICYmIHJldCAhPSBFRVhJU1QpIHsKCXRyeV9yZW5hbWU6CgkJaWYgKCFyZW5hbWUodG1wZmlsZSwgZmlsZW5hbWUpKQoJCQlnb3RvIG91dDsKCQlyZXQgPSBlcnJubzsKCX0KCXVubGlua19vcl93YXJuKHRtcGZpbGUpOwoJaWYgKHJldCkgewoJCWlmIChyZXQgIT0gRUVYSVNUKSB7CgkJCXJldHVybiBlcnJvcl9lcnJubygidW5hYmxlIHRvIHdyaXRlIHNoYTEgZmlsZW5hbWUgJXMiLCBmaWxlbmFtZSk7CgkJfQoJCS8qIEZJWE1FISEhIENvbGxpc2lvbiBjaGVjayBoZXJlID8gKi8KCX0KCm91dDoKCWlmIChhZGp1c3Rfc2hhcmVkX3Blcm0oZmlsZW5hbWUpKQoJCXJldHVybiBlcnJvcigidW5hYmxlIHRvIHNldCBwZXJtaXNzaW9uIHRvICclcyciLCBmaWxlbmFtZSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCB3cml0ZV9idWZmZXIoaW50IGZkLCBjb25zdCB2b2lkICpidWYsIHNpemVfdCBsZW4pCnsKCWlmICh3cml0ZV9pbl9mdWxsKGZkLCBidWYsIGxlbikgPCAwKQoJCXJldHVybiBlcnJvcl9lcnJubygiZmlsZSB3cml0ZSBlcnJvciIpOwoJcmV0dXJuIDA7Cn0KCmludCBoYXNoX29iamVjdF9maWxlKGNvbnN0IHZvaWQgKmJ1ZiwgdW5zaWduZWQgbG9uZyBsZW4sIGNvbnN0IGNoYXIgKnR5cGUsCgkJICAgICBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCWNoYXIgaGRyW01BWF9IRUFERVJfTEVOXTsKCWludCBoZHJsZW4gPSBzaXplb2YoaGRyKTsKCXdyaXRlX29iamVjdF9maWxlX3ByZXBhcmUoYnVmLCBsZW4sIHR5cGUsIG9pZCwgaGRyLCAmaGRybGVuKTsKCXJldHVybiAwOwp9CgovKiBGaW5hbGl6ZSBhIGZpbGUgb24gZGlzaywgYW5kIGNsb3NlIGl0LiAqLwpzdGF0aWMgdm9pZCBjbG9zZV9zaGExX2ZpbGUoaW50IGZkKQp7CglpZiAoZnN5bmNfb2JqZWN0X2ZpbGVzKQoJCWZzeW5jX29yX2RpZShmZCwgInNoYTEgZmlsZSIpOwoJaWYgKGNsb3NlKGZkKSAhPSAwKQoJCWRpZV9lcnJubygiZXJyb3Igd2hlbiBjbG9zaW5nIHNoYTEgZmlsZSIpOwp9CgovKiBTaXplIG9mIGRpcmVjdG9yeSBjb21wb25lbnQsIGluY2x1ZGluZyB0aGUgZW5kaW5nICcvJyAqLwpzdGF0aWMgaW5saW5lIGludCBkaXJlY3Rvcnlfc2l6ZShjb25zdCBjaGFyICpmaWxlbmFtZSkKewoJY29uc3QgY2hhciAqcyA9IHN0cnJjaHIoZmlsZW5hbWUsICcvJyk7CglpZiAoIXMpCgkJcmV0dXJuIDA7CglyZXR1cm4gcyAtIGZpbGVuYW1lICsgMTsKfQoKLyoKICogVGhpcyBjcmVhdGVzIGEgdGVtcG9yYXJ5IGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5IGFzIHRoZSBmaW5hbAogKiAnZmlsZW5hbWUnCiAqCiAqIFdlIHdhbnQgdG8gYXZvaWQgY3Jvc3MtZGlyZWN0b3J5IGZpbGVuYW1lIHJlbmFtZXMsIGJlY2F1c2UgdGhvc2UKICogY2FuIGhhdmUgcHJvYmxlbXMgb24gdmFyaW91cyBmaWxlc3lzdGVtcyAoRkFULCBORlMsIENvZGEpLgogKi8Kc3RhdGljIGludCBjcmVhdGVfdG1wZmlsZShzdHJ1Y3Qgc3RyYnVmICp0bXAsIGNvbnN0IGNoYXIgKmZpbGVuYW1lKQp7CglpbnQgZmQsIGRpcmxlbiA9IGRpcmVjdG9yeV9zaXplKGZpbGVuYW1lKTsKCglzdHJidWZfcmVzZXQodG1wKTsKCXN0cmJ1Zl9hZGQodG1wLCBmaWxlbmFtZSwgZGlybGVuKTsKCXN0cmJ1Zl9hZGRzdHIodG1wLCAidG1wX29ial9YWFhYWFgiKTsKCWZkID0gZ2l0X21rc3RlbXBfbW9kZSh0bXAtPmJ1ZiwgMDQ0NCk7CglpZiAoZmQgPCAwICYmIGRpcmxlbiAmJiBlcnJubyA9PSBFTk9FTlQpIHsKCQkvKgoJCSAqIE1ha2Ugc3VyZSB0aGUgZGlyZWN0b3J5IGV4aXN0czsgbm90ZSB0aGF0IHRoZSBjb250ZW50cwoJCSAqIG9mIHRoZSBidWZmZXIgYXJlIHVuZGVmaW5lZCBhZnRlciBta3N0ZW1wIHJldHVybnMgYW4KCQkgKiBlcnJvciwgc28gd2UgaGF2ZSB0byByZXdyaXRlIHRoZSB3aG9sZSBidWZmZXIgZnJvbQoJCSAqIHNjcmF0Y2guCgkJICovCgkJc3RyYnVmX3Jlc2V0KHRtcCk7CgkJc3RyYnVmX2FkZCh0bXAsIGZpbGVuYW1lLCBkaXJsZW4gLSAxKTsKCQlpZiAobWtkaXIodG1wLT5idWYsIDA3NzcpICYmIGVycm5vICE9IEVFWElTVCkKCQkJcmV0dXJuIC0xOwoJCWlmIChhZGp1c3Rfc2hhcmVkX3Blcm0odG1wLT5idWYpKQoJCQlyZXR1cm4gLTE7CgoJCS8qIFRyeSBhZ2FpbiAqLwoJCXN0cmJ1Zl9hZGRzdHIodG1wLCAiL3RtcF9vYmpfWFhYWFhYIik7CgkJZmQgPSBnaXRfbWtzdGVtcF9tb2RlKHRtcC0+YnVmLCAwNDQ0KTsKCX0KCXJldHVybiBmZDsKfQoKc3RhdGljIGludCB3cml0ZV9sb29zZV9vYmplY3QoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBjaGFyICpoZHIsCgkJCSAgICAgIGludCBoZHJsZW4sIGNvbnN0IHZvaWQgKmJ1ZiwgdW5zaWduZWQgbG9uZyBsZW4sCgkJCSAgICAgIHRpbWVfdCBtdGltZSkKewoJaW50IGZkLCByZXQ7Cgl1bnNpZ25lZCBjaGFyIGNvbXByZXNzZWRbNDA5Nl07CglnaXRfenN0cmVhbSBzdHJlYW07CglnaXRfaGFzaF9jdHggYzsKCXN0cnVjdCBvYmplY3RfaWQgcGFyYW5vX29pZDsKCXN0YXRpYyBzdHJ1Y3Qgc3RyYnVmIHRtcF9maWxlID0gU1RSQlVGX0lOSVQ7CglzdGF0aWMgc3RydWN0IHN0cmJ1ZiBmaWxlbmFtZSA9IFNUUkJVRl9JTklUOwoKCXN0cmJ1Zl9yZXNldCgmZmlsZW5hbWUpOwoJc2hhMV9maWxlX25hbWUodGhlX3JlcG9zaXRvcnksICZmaWxlbmFtZSwgb2lkLT5oYXNoKTsKCglmZCA9IGNyZWF0ZV90bXBmaWxlKCZ0bXBfZmlsZSwgZmlsZW5hbWUuYnVmKTsKCWlmIChmZCA8IDApIHsKCQlpZiAoZXJybm8gPT0gRUFDQ0VTKQoJCQlyZXR1cm4gZXJyb3IoImluc3VmZmljaWVudCBwZXJtaXNzaW9uIGZvciBhZGRpbmcgYW4gb2JqZWN0IHRvIHJlcG9zaXRvcnkgZGF0YWJhc2UgJXMiLCBnZXRfb2JqZWN0X2RpcmVjdG9yeSgpKTsKCQllbHNlCgkJCXJldHVybiBlcnJvcl9lcnJubygidW5hYmxlIHRvIGNyZWF0ZSB0ZW1wb3JhcnkgZmlsZSIpOwoJfQoKCS8qIFNldCBpdCB1cCAqLwoJZ2l0X2RlZmxhdGVfaW5pdCgmc3RyZWFtLCB6bGliX2NvbXByZXNzaW9uX2xldmVsKTsKCXN0cmVhbS5uZXh0X291dCA9IGNvbXByZXNzZWQ7CglzdHJlYW0uYXZhaWxfb3V0ID0gc2l6ZW9mKGNvbXByZXNzZWQpOwoJdGhlX2hhc2hfYWxnby0+aW5pdF9mbigmYyk7CgoJLyogRmlyc3QgaGVhZGVyLi4gKi8KCXN0cmVhbS5uZXh0X2luID0gKHVuc2lnbmVkIGNoYXIgKiloZHI7CglzdHJlYW0uYXZhaWxfaW4gPSBoZHJsZW47Cgl3aGlsZSAoZ2l0X2RlZmxhdGUoJnN0cmVhbSwgMCkgPT0gWl9PSykKCQk7IC8qIG5vdGhpbmcgKi8KCXRoZV9oYXNoX2FsZ28tPnVwZGF0ZV9mbigmYywgaGRyLCBoZHJsZW4pOwoKCS8qIFRoZW4gdGhlIGRhdGEgaXRzZWxmLi4gKi8KCXN0cmVhbS5uZXh0X2luID0gKHZvaWQgKilidWY7CglzdHJlYW0uYXZhaWxfaW4gPSBsZW47CglkbyB7CgkJdW5zaWduZWQgY2hhciAqaW4wID0gc3RyZWFtLm5leHRfaW47CgkJcmV0ID0gZ2l0X2RlZmxhdGUoJnN0cmVhbSwgWl9GSU5JU0gpOwoJCXRoZV9oYXNoX2FsZ28tPnVwZGF0ZV9mbigmYywgaW4wLCBzdHJlYW0ubmV4dF9pbiAtIGluMCk7CgkJaWYgKHdyaXRlX2J1ZmZlcihmZCwgY29tcHJlc3NlZCwgc3RyZWFtLm5leHRfb3V0IC0gY29tcHJlc3NlZCkgPCAwKQoJCQlkaWUoInVuYWJsZSB0byB3cml0ZSBzaGExIGZpbGUiKTsKCQlzdHJlYW0ubmV4dF9vdXQgPSBjb21wcmVzc2VkOwoJCXN0cmVhbS5hdmFpbF9vdXQgPSBzaXplb2YoY29tcHJlc3NlZCk7Cgl9IHdoaWxlIChyZXQgPT0gWl9PSyk7CgoJaWYgKHJldCAhPSBaX1NUUkVBTV9FTkQpCgkJZGllKCJ1bmFibGUgdG8gZGVmbGF0ZSBuZXcgb2JqZWN0ICVzICglZCkiLCBvaWRfdG9faGV4KG9pZCksCgkJICAgIHJldCk7CglyZXQgPSBnaXRfZGVmbGF0ZV9lbmRfZ2VudGx5KCZzdHJlYW0pOwoJaWYgKHJldCAhPSBaX09LKQoJCWRpZSgiZGVmbGF0ZUVuZCBvbiBvYmplY3QgJXMgZmFpbGVkICglZCkiLCBvaWRfdG9faGV4KG9pZCksCgkJICAgIHJldCk7Cgl0aGVfaGFzaF9hbGdvLT5maW5hbF9mbihwYXJhbm9fb2lkLmhhc2gsICZjKTsKCWlmIChvaWRjbXAob2lkLCAmcGFyYW5vX29pZCkgIT0gMCkKCQlkaWUoImNvbmZ1c2VkIGJ5IHVuc3RhYmxlIG9iamVjdCBzb3VyY2UgZGF0YSBmb3IgJXMiLAoJCSAgICBvaWRfdG9faGV4KG9pZCkpOwoKCWNsb3NlX3NoYTFfZmlsZShmZCk7CgoJaWYgKG10aW1lKSB7CgkJc3RydWN0IHV0aW1idWYgdXRiOwoJCXV0Yi5hY3RpbWUgPSBtdGltZTsKCQl1dGIubW9kdGltZSA9IG10aW1lOwoJCWlmICh1dGltZSh0bXBfZmlsZS5idWYsICZ1dGIpIDwgMCkKCQkJd2FybmluZ19lcnJubygiZmFpbGVkIHV0aW1lKCkgb24gJXMiLCB0bXBfZmlsZS5idWYpOwoJfQoKCXJldHVybiBmaW5hbGl6ZV9vYmplY3RfZmlsZSh0bXBfZmlsZS5idWYsIGZpbGVuYW1lLmJ1Zik7Cn0KCnN0YXRpYyBpbnQgZnJlc2hlbl9sb29zZV9vYmplY3QoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglyZXR1cm4gY2hlY2tfYW5kX2ZyZXNoZW4ob2lkLCAxKTsKfQoKc3RhdGljIGludCBmcmVzaGVuX3BhY2tlZF9vYmplY3QoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglzdHJ1Y3QgcGFja19lbnRyeSBlOwoJaWYgKCFmaW5kX3BhY2tfZW50cnkodGhlX3JlcG9zaXRvcnksIG9pZCwgJmUpKQoJCXJldHVybiAwOwoJaWYgKGUucC0+ZnJlc2hlbmVkKQoJCXJldHVybiAxOwoJaWYgKCFmcmVzaGVuX2ZpbGUoZS5wLT5wYWNrX25hbWUpKQoJCXJldHVybiAwOwoJZS5wLT5mcmVzaGVuZWQgPSAxOwoJcmV0dXJuIDE7Cn0KCmludCB3cml0ZV9vYmplY3RfZmlsZShjb25zdCB2b2lkICpidWYsIHVuc2lnbmVkIGxvbmcgbGVuLCBjb25zdCBjaGFyICp0eXBlLAoJCSAgICAgIHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJY2hhciBoZHJbTUFYX0hFQURFUl9MRU5dOwoJaW50IGhkcmxlbiA9IHNpemVvZihoZHIpOwoKCS8qIE5vcm1hbGx5IGlmIHdlIGhhdmUgaXQgaW4gdGhlIHBhY2sgdGhlbiB3ZSBkbyBub3QgYm90aGVyIHdyaXRpbmcKCSAqIGl0IG91dCBpbnRvIC5naXQvb2JqZWN0cy8/Py8/ezM4fSBmaWxlLgoJICovCgl3cml0ZV9vYmplY3RfZmlsZV9wcmVwYXJlKGJ1ZiwgbGVuLCB0eXBlLCBvaWQsIGhkciwgJmhkcmxlbik7CglpZiAoZnJlc2hlbl9wYWNrZWRfb2JqZWN0KG9pZCkgfHwgZnJlc2hlbl9sb29zZV9vYmplY3Qob2lkKSkKCQlyZXR1cm4gMDsKCXJldHVybiB3cml0ZV9sb29zZV9vYmplY3Qob2lkLCBoZHIsIGhkcmxlbiwgYnVmLCBsZW4sIDApOwp9CgppbnQgaGFzaF9vYmplY3RfZmlsZV9saXRlcmFsbHkoY29uc3Qgdm9pZCAqYnVmLCB1bnNpZ25lZCBsb25nIGxlbiwKCQkJICAgICAgIGNvbnN0IGNoYXIgKnR5cGUsIHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJICAgICAgIHVuc2lnbmVkIGZsYWdzKQp7CgljaGFyICpoZWFkZXI7CglpbnQgaGRybGVuLCBzdGF0dXMgPSAwOwoKCS8qIHR5cGUgc3RyaW5nLCBTUCwgJWx1IG9mIHRoZSBsZW5ndGggcGx1cyBOVUwgbXVzdCBmaXQgdGhpcyAqLwoJaGRybGVuID0gc3RybGVuKHR5cGUpICsgTUFYX0hFQURFUl9MRU47CgloZWFkZXIgPSB4bWFsbG9jKGhkcmxlbik7Cgl3cml0ZV9vYmplY3RfZmlsZV9wcmVwYXJlKGJ1ZiwgbGVuLCB0eXBlLCBvaWQsIGhlYWRlciwgJmhkcmxlbik7CgoJaWYgKCEoZmxhZ3MgJiBIQVNIX1dSSVRFX09CSkVDVCkpCgkJZ290byBjbGVhbnVwOwoJaWYgKGZyZXNoZW5fcGFja2VkX29iamVjdChvaWQpIHx8IGZyZXNoZW5fbG9vc2Vfb2JqZWN0KG9pZCkpCgkJZ290byBjbGVhbnVwOwoJc3RhdHVzID0gd3JpdGVfbG9vc2Vfb2JqZWN0KG9pZCwgaGVhZGVyLCBoZHJsZW4sIGJ1ZiwgbGVuLCAwKTsKCmNsZWFudXA6CglmcmVlKGhlYWRlcik7CglyZXR1cm4gc3RhdHVzOwp9CgppbnQgZm9yY2Vfb2JqZWN0X2xvb3NlKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgdGltZV90IG10aW1lKQp7Cgl2b2lkICpidWY7Cgl1bnNpZ25lZCBsb25nIGxlbjsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCWNoYXIgaGRyW01BWF9IRUFERVJfTEVOXTsKCWludCBoZHJsZW47CglpbnQgcmV0OwoKCWlmIChoYXNfbG9vc2Vfb2JqZWN0KG9pZCkpCgkJcmV0dXJuIDA7CglidWYgPSByZWFkX29iamVjdChvaWQtPmhhc2gsICZ0eXBlLCAmbGVuKTsKCWlmICghYnVmKQoJCXJldHVybiBlcnJvcigiY2Fubm90IHJlYWQgc2hhMV9maWxlIGZvciAlcyIsIG9pZF90b19oZXgob2lkKSk7CgloZHJsZW4gPSB4c25wcmludGYoaGRyLCBzaXplb2YoaGRyKSwgIiVzICVsdSIsIHR5cGVfbmFtZSh0eXBlKSwgbGVuKSArIDE7CglyZXQgPSB3cml0ZV9sb29zZV9vYmplY3Qob2lkLCBoZHIsIGhkcmxlbiwgYnVmLCBsZW4sIG10aW1lKTsKCWZyZWUoYnVmKTsKCglyZXR1cm4gcmV0Owp9CgppbnQgaGFzX3NoYTFfZmlsZV93aXRoX2ZsYWdzKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIGludCBmbGFncykKewoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CglpZiAoIXN0YXJ0dXBfaW5mby0+aGF2ZV9yZXBvc2l0b3J5KQoJCXJldHVybiAwOwoJaGFzaGNweShvaWQuaGFzaCwgc2hhMSk7CglyZXR1cm4gb2lkX29iamVjdF9pbmZvX2V4dGVuZGVkKHRoZV9yZXBvc2l0b3J5LCAmb2lkLCBOVUxMLAoJCQkJCWZsYWdzIHwgT0JKRUNUX0lORk9fU0tJUF9DQUNIRUQpID49IDA7Cn0KCmludCBoYXNfb2JqZWN0X2ZpbGUoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglyZXR1cm4gaGFzX3NoYTFfZmlsZShvaWQtPmhhc2gpOwp9CgppbnQgaGFzX29iamVjdF9maWxlX3dpdGhfZmxhZ3MoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBpbnQgZmxhZ3MpCnsKCXJldHVybiBoYXNfc2hhMV9maWxlX3dpdGhfZmxhZ3Mob2lkLT5oYXNoLCBmbGFncyk7Cn0KCnN0YXRpYyB2b2lkIGNoZWNrX3RyZWUoY29uc3Qgdm9pZCAqYnVmLCBzaXplX3Qgc2l6ZSkKewoJc3RydWN0IHRyZWVfZGVzYyBkZXNjOwoJc3RydWN0IG5hbWVfZW50cnkgZW50cnk7CgoJaW5pdF90cmVlX2Rlc2MoJmRlc2MsIGJ1Ziwgc2l6ZSk7Cgl3aGlsZSAodHJlZV9lbnRyeSgmZGVzYywgJmVudHJ5KSkKCQkvKiBkbyBub3RoaW5nCgkJICogdHJlZV9lbnRyeSgpIHdpbGwgZGllKCkgb24gbWFsZm9ybWVkIGVudHJpZXMgKi8KCQk7Cn0KCnN0YXRpYyB2b2lkIGNoZWNrX2NvbW1pdChjb25zdCB2b2lkICpidWYsIHNpemVfdCBzaXplKQp7CglzdHJ1Y3QgY29tbWl0IGM7CgltZW1zZXQoJmMsIDAsIHNpemVvZihjKSk7CglpZiAocGFyc2VfY29tbWl0X2J1ZmZlcih0aGVfcmVwb3NpdG9yeSwgJmMsIGJ1Ziwgc2l6ZSwgMCkpCgkJZGllKCJjb3JydXB0IGNvbW1pdCIpOwp9CgpzdGF0aWMgdm9pZCBjaGVja190YWcoY29uc3Qgdm9pZCAqYnVmLCBzaXplX3Qgc2l6ZSkKewoJc3RydWN0IHRhZyB0OwoJbWVtc2V0KCZ0LCAwLCBzaXplb2YodCkpOwoJaWYgKHBhcnNlX3RhZ19idWZmZXIodGhlX3JlcG9zaXRvcnksICZ0LCBidWYsIHNpemUpKQoJCWRpZSgiY29ycnVwdCB0YWciKTsKfQoKc3RhdGljIGludCBpbmRleF9tZW0oc3RydWN0IG9iamVjdF9pZCAqb2lkLCB2b2lkICpidWYsIHNpemVfdCBzaXplLAoJCSAgICAgZW51bSBvYmplY3RfdHlwZSB0eXBlLAoJCSAgICAgY29uc3QgY2hhciAqcGF0aCwgdW5zaWduZWQgZmxhZ3MpCnsKCWludCByZXQsIHJlX2FsbG9jYXRlZCA9IDA7CglpbnQgd3JpdGVfb2JqZWN0ID0gZmxhZ3MgJiBIQVNIX1dSSVRFX09CSkVDVDsKCglpZiAoIXR5cGUpCgkJdHlwZSA9IE9CSl9CTE9COwoKCS8qCgkgKiBDb252ZXJ0IGJsb2JzIHRvIGdpdCBpbnRlcm5hbCBmb3JtYXQKCSAqLwoJaWYgKCh0eXBlID09IE9CSl9CTE9CKSAmJiBwYXRoKSB7CgkJc3RydWN0IHN0cmJ1ZiBuYnVmID0gU1RSQlVGX0lOSVQ7CgkJaWYgKGNvbnZlcnRfdG9fZ2l0KCZ0aGVfaW5kZXgsIHBhdGgsIGJ1Ziwgc2l6ZSwgJm5idWYsCgkJCQkgICBnZXRfY29udl9mbGFncyhmbGFncykpKSB7CgkJCWJ1ZiA9IHN0cmJ1Zl9kZXRhY2goJm5idWYsICZzaXplKTsKCQkJcmVfYWxsb2NhdGVkID0gMTsKCQl9Cgl9CglpZiAoZmxhZ3MgJiBIQVNIX0ZPUk1BVF9DSEVDSykgewoJCWlmICh0eXBlID09IE9CSl9UUkVFKQoJCQljaGVja190cmVlKGJ1Ziwgc2l6ZSk7CgkJaWYgKHR5cGUgPT0gT0JKX0NPTU1JVCkKCQkJY2hlY2tfY29tbWl0KGJ1Ziwgc2l6ZSk7CgkJaWYgKHR5cGUgPT0gT0JKX1RBRykKCQkJY2hlY2tfdGFnKGJ1Ziwgc2l6ZSk7Cgl9CgoJaWYgKHdyaXRlX29iamVjdCkKCQlyZXQgPSB3cml0ZV9vYmplY3RfZmlsZShidWYsIHNpemUsIHR5cGVfbmFtZSh0eXBlKSwgb2lkKTsKCWVsc2UKCQlyZXQgPSBoYXNoX29iamVjdF9maWxlKGJ1Ziwgc2l6ZSwgdHlwZV9uYW1lKHR5cGUpLCBvaWQpOwoJaWYgKHJlX2FsbG9jYXRlZCkKCQlmcmVlKGJ1Zik7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IGluZGV4X3N0cmVhbV9jb252ZXJ0X2Jsb2Ioc3RydWN0IG9iamVjdF9pZCAqb2lkLCBpbnQgZmQsCgkJCQkgICAgIGNvbnN0IGNoYXIgKnBhdGgsIHVuc2lnbmVkIGZsYWdzKQp7CglpbnQgcmV0OwoJY29uc3QgaW50IHdyaXRlX29iamVjdCA9IGZsYWdzICYgSEFTSF9XUklURV9PQkpFQ1Q7CglzdHJ1Y3Qgc3RyYnVmIHNidWYgPSBTVFJCVUZfSU5JVDsKCglhc3NlcnQocGF0aCk7Cglhc3NlcnQod291bGRfY29udmVydF90b19naXRfZmlsdGVyX2ZkKCZ0aGVfaW5kZXgsIHBhdGgpKTsKCgljb252ZXJ0X3RvX2dpdF9maWx0ZXJfZmQoJnRoZV9pbmRleCwgcGF0aCwgZmQsICZzYnVmLAoJCQkJIGdldF9jb252X2ZsYWdzKGZsYWdzKSk7CgoJaWYgKHdyaXRlX29iamVjdCkKCQlyZXQgPSB3cml0ZV9vYmplY3RfZmlsZShzYnVmLmJ1Ziwgc2J1Zi5sZW4sIHR5cGVfbmFtZShPQkpfQkxPQiksCgkJCQkJb2lkKTsKCWVsc2UKCQlyZXQgPSBoYXNoX29iamVjdF9maWxlKHNidWYuYnVmLCBzYnVmLmxlbiwgdHlwZV9uYW1lKE9CSl9CTE9CKSwKCQkJCSAgICAgICBvaWQpOwoJc3RyYnVmX3JlbGVhc2UoJnNidWYpOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIGludCBpbmRleF9waXBlKHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgaW50IGZkLCBlbnVtIG9iamVjdF90eXBlIHR5cGUsCgkJICAgICAgY29uc3QgY2hhciAqcGF0aCwgdW5zaWduZWQgZmxhZ3MpCnsKCXN0cnVjdCBzdHJidWYgc2J1ZiA9IFNUUkJVRl9JTklUOwoJaW50IHJldDsKCglpZiAoc3RyYnVmX3JlYWQoJnNidWYsIGZkLCA0MDk2KSA+PSAwKQoJCXJldCA9IGluZGV4X21lbShvaWQsIHNidWYuYnVmLCBzYnVmLmxlbiwgdHlwZSwgcGF0aCwgZmxhZ3MpOwoJZWxzZQoJCXJldCA9IC0xOwoJc3RyYnVmX3JlbGVhc2UoJnNidWYpOwoJcmV0dXJuIHJldDsKfQoKI2RlZmluZSBTTUFMTF9GSUxFX1NJWkUgKDMyKjEwMjQpCgpzdGF0aWMgaW50IGluZGV4X2NvcmUoc3RydWN0IG9iamVjdF9pZCAqb2lkLCBpbnQgZmQsIHNpemVfdCBzaXplLAoJCSAgICAgIGVudW0gb2JqZWN0X3R5cGUgdHlwZSwgY29uc3QgY2hhciAqcGF0aCwKCQkgICAgICB1bnNpZ25lZCBmbGFncykKewoJaW50IHJldDsKCglpZiAoIXNpemUpIHsKCQlyZXQgPSBpbmRleF9tZW0ob2lkLCAiIiwgc2l6ZSwgdHlwZSwgcGF0aCwgZmxhZ3MpOwoJfSBlbHNlIGlmIChzaXplIDw9IFNNQUxMX0ZJTEVfU0laRSkgewoJCWNoYXIgKmJ1ZiA9IHhtYWxsb2Moc2l6ZSk7CgkJc3NpemVfdCByZWFkX3Jlc3VsdCA9IHJlYWRfaW5fZnVsbChmZCwgYnVmLCBzaXplKTsKCQlpZiAocmVhZF9yZXN1bHQgPCAwKQoJCQlyZXQgPSBlcnJvcl9lcnJubygicmVhZCBlcnJvciB3aGlsZSBpbmRleGluZyAlcyIsCgkJCQkJICBwYXRoID8gcGF0aCA6ICI8dW5rbm93bj4iKTsKCQllbHNlIGlmIChyZWFkX3Jlc3VsdCAhPSBzaXplKQoJCQlyZXQgPSBlcnJvcigic2hvcnQgcmVhZCB3aGlsZSBpbmRleGluZyAlcyIsCgkJCQkgICAgcGF0aCA/IHBhdGggOiAiPHVua25vd24+Iik7CgkJZWxzZQoJCQlyZXQgPSBpbmRleF9tZW0ob2lkLCBidWYsIHNpemUsIHR5cGUsIHBhdGgsIGZsYWdzKTsKCQlmcmVlKGJ1Zik7Cgl9IGVsc2UgewoJCXZvaWQgKmJ1ZiA9IHhtbWFwKE5VTEwsIHNpemUsIFBST1RfUkVBRCwgTUFQX1BSSVZBVEUsIGZkLCAwKTsKCQlyZXQgPSBpbmRleF9tZW0ob2lkLCBidWYsIHNpemUsIHR5cGUsIHBhdGgsIGZsYWdzKTsKCQltdW5tYXAoYnVmLCBzaXplKTsKCX0KCXJldHVybiByZXQ7Cn0KCi8qCiAqIFRoaXMgY3JlYXRlcyBvbmUgcGFja2ZpbGUgcGVyIGxhcmdlIGJsb2IgdW5sZXNzIGJ1bGstY2hlY2tpbgogKiBtYWNoaW5lcnkgaXMgInBsdWdnZWQiLgogKgogKiBUaGlzIGFsc28gYnlwYXNzZXMgdGhlIHVzdWFsICJjb252ZXJ0LXRvLWdpdCIgZGFuY2UsIGFuZCB0aGF0IGlzIG9uCiAqIHB1cnBvc2UuIFdlIGNvdWxkIHdyaXRlIGEgc3RyZWFtaW5nIHZlcnNpb24gb2YgdGhlIGNvbnZlcnRpbmcKICogZnVuY3Rpb25zIGFuZCBpbnNlcnQgdGhhdCBiZWZvcmUgZmVlZGluZyB0aGUgZGF0YSB0byBmYXN0LWltcG9ydAogKiAob3IgZXF1aXZhbGVudCBpbi1jb3JlIEFQSSBkZXNjcmliZWQgYWJvdmUpLiBIb3dldmVyLCB0aGF0IGlzCiAqIHNvbWV3aGF0IGNvbXBsaWNhdGVkLCBhcyB3ZSBkbyBub3Qga25vdyB0aGUgc2l6ZSBvZiB0aGUgZmlsdGVyCiAqIHJlc3VsdCwgd2hpY2ggd2UgbmVlZCB0byBrbm93IGJlZm9yZWhhbmQgd2hlbiB3cml0aW5nIGEgZ2l0IG9iamVjdC4KICogU2luY2UgdGhlIHByaW1hcnkgbW90aXZhdGlvbiBmb3IgdHJ5aW5nIHRvIHN0cmVhbSBmcm9tIHRoZSB3b3JraW5nCiAqIHRyZWUgZmlsZSBhbmQgdG8gYXZvaWQgbW1hcGluZyBpdCBpbiBjb3JlIGlzIHRvIGRlYWwgd2l0aCBsYXJnZQogKiBiaW5hcnkgYmxvYnMsIHRoZXkgZ2VuZXJhbGx5IGRvIG5vdCB3YW50IHRvIGdldCBhbnkgY29udmVyc2lvbiwgYW5kCiAqIGNhbGxlcnMgc2hvdWxkIGF2b2lkIHRoaXMgY29kZSBwYXRoIHdoZW4gZmlsdGVycyBhcmUgcmVxdWVzdGVkLgogKi8Kc3RhdGljIGludCBpbmRleF9zdHJlYW0oc3RydWN0IG9iamVjdF9pZCAqb2lkLCBpbnQgZmQsIHNpemVfdCBzaXplLAoJCQllbnVtIG9iamVjdF90eXBlIHR5cGUsIGNvbnN0IGNoYXIgKnBhdGgsCgkJCXVuc2lnbmVkIGZsYWdzKQp7CglyZXR1cm4gaW5kZXhfYnVsa19jaGVja2luKG9pZCwgZmQsIHNpemUsIHR5cGUsIHBhdGgsIGZsYWdzKTsKfQoKaW50IGluZGV4X2ZkKHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgaW50IGZkLCBzdHJ1Y3Qgc3RhdCAqc3QsCgkgICAgIGVudW0gb2JqZWN0X3R5cGUgdHlwZSwgY29uc3QgY2hhciAqcGF0aCwgdW5zaWduZWQgZmxhZ3MpCnsKCWludCByZXQ7CgoJLyoKCSAqIENhbGwgeHNpemVfdCgpIG9ubHkgd2hlbiBuZWVkZWQgdG8gYXZvaWQgcG90ZW50aWFsbHkgdW5uZWNlc3NhcnkKCSAqIGRpZSgpIGZvciBsYXJnZSBmaWxlcy4KCSAqLwoJaWYgKHR5cGUgPT0gT0JKX0JMT0IgJiYgcGF0aCAmJiB3b3VsZF9jb252ZXJ0X3RvX2dpdF9maWx0ZXJfZmQoJnRoZV9pbmRleCwgcGF0aCkpCgkJcmV0ID0gaW5kZXhfc3RyZWFtX2NvbnZlcnRfYmxvYihvaWQsIGZkLCBwYXRoLCBmbGFncyk7CgllbHNlIGlmICghU19JU1JFRyhzdC0+c3RfbW9kZSkpCgkJcmV0ID0gaW5kZXhfcGlwZShvaWQsIGZkLCB0eXBlLCBwYXRoLCBmbGFncyk7CgllbHNlIGlmIChzdC0+c3Rfc2l6ZSA8PSBiaWdfZmlsZV90aHJlc2hvbGQgfHwgdHlwZSAhPSBPQkpfQkxPQiB8fAoJCSAocGF0aCAmJiB3b3VsZF9jb252ZXJ0X3RvX2dpdCgmdGhlX2luZGV4LCBwYXRoKSkpCgkJcmV0ID0gaW5kZXhfY29yZShvaWQsIGZkLCB4c2l6ZV90KHN0LT5zdF9zaXplKSwgdHlwZSwgcGF0aCwKCQkJCSBmbGFncyk7CgllbHNlCgkJcmV0ID0gaW5kZXhfc3RyZWFtKG9pZCwgZmQsIHhzaXplX3Qoc3QtPnN0X3NpemUpLCB0eXBlLCBwYXRoLAoJCQkJICAgZmxhZ3MpOwoJY2xvc2UoZmQpOwoJcmV0dXJuIHJldDsKfQoKaW50IGluZGV4X3BhdGgoc3RydWN0IG9iamVjdF9pZCAqb2lkLCBjb25zdCBjaGFyICpwYXRoLCBzdHJ1Y3Qgc3RhdCAqc3QsIHVuc2lnbmVkIGZsYWdzKQp7CglpbnQgZmQ7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CglpbnQgcmMgPSAwOwoKCXN3aXRjaCAoc3QtPnN0X21vZGUgJiBTX0lGTVQpIHsKCWNhc2UgU19JRlJFRzoKCQlmZCA9IG9wZW4ocGF0aCwgT19SRE9OTFkpOwoJCWlmIChmZCA8IDApCgkJCXJldHVybiBlcnJvcl9lcnJubygib3BlbihcIiVzXCIpIiwgcGF0aCk7CgkJaWYgKGluZGV4X2ZkKG9pZCwgZmQsIHN0LCBPQkpfQkxPQiwgcGF0aCwgZmxhZ3MpIDwgMCkKCQkJcmV0dXJuIGVycm9yKCIlczogZmFpbGVkIHRvIGluc2VydCBpbnRvIGRhdGFiYXNlIiwKCQkJCSAgICAgcGF0aCk7CgkJYnJlYWs7CgljYXNlIFNfSUZMTks6CgkJaWYgKHN0cmJ1Zl9yZWFkbGluaygmc2IsIHBhdGgsIHN0LT5zdF9zaXplKSkKCQkJcmV0dXJuIGVycm9yX2Vycm5vKCJyZWFkbGluayhcIiVzXCIpIiwgcGF0aCk7CgkJaWYgKCEoZmxhZ3MgJiBIQVNIX1dSSVRFX09CSkVDVCkpCgkJCWhhc2hfb2JqZWN0X2ZpbGUoc2IuYnVmLCBzYi5sZW4sIGJsb2JfdHlwZSwgb2lkKTsKCQllbHNlIGlmICh3cml0ZV9vYmplY3RfZmlsZShzYi5idWYsIHNiLmxlbiwgYmxvYl90eXBlLCBvaWQpKQoJCQlyYyA9IGVycm9yKCIlczogZmFpbGVkIHRvIGluc2VydCBpbnRvIGRhdGFiYXNlIiwgcGF0aCk7CgkJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCQlicmVhazsKCWNhc2UgU19JRkRJUjoKCQlyZXR1cm4gcmVzb2x2ZV9naXRsaW5rX3JlZihwYXRoLCAiSEVBRCIsIG9pZCk7CglkZWZhdWx0OgoJCXJldHVybiBlcnJvcigiJXM6IHVuc3VwcG9ydGVkIGZpbGUgdHlwZSIsIHBhdGgpOwoJfQoJcmV0dXJuIHJjOwp9CgppbnQgcmVhZF9wYWNrX2hlYWRlcihpbnQgZmQsIHN0cnVjdCBwYWNrX2hlYWRlciAqaGVhZGVyKQp7CglpZiAocmVhZF9pbl9mdWxsKGZkLCBoZWFkZXIsIHNpemVvZigqaGVhZGVyKSkgIT0gc2l6ZW9mKCpoZWFkZXIpKQoJCS8qICJlb2YgYmVmb3JlIHBhY2sgaGVhZGVyIHdhcyBmdWxseSByZWFkIiAqLwoJCXJldHVybiBQSF9FUlJPUl9FT0Y7CgoJaWYgKGhlYWRlci0+aGRyX3NpZ25hdHVyZSAhPSBodG9ubChQQUNLX1NJR05BVFVSRSkpCgkJLyogInByb3RvY29sIGVycm9yIChwYWNrIHNpZ25hdHVyZSBtaXNtYXRjaCBkZXRlY3RlZCkiICovCgkJcmV0dXJuIFBIX0VSUk9SX1BBQ0tfU0lHTkFUVVJFOwoJaWYgKCFwYWNrX3ZlcnNpb25fb2soaGVhZGVyLT5oZHJfdmVyc2lvbikpCgkJLyogInByb3RvY29sIGVycm9yIChwYWNrIHZlcnNpb24gdW5zdXBwb3J0ZWQpIiAqLwoJCXJldHVybiBQSF9FUlJPUl9QUk9UT0NPTDsKCXJldHVybiAwOwp9Cgp2b2lkIGFzc2VydF9vaWRfdHlwZShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGVudW0gb2JqZWN0X3R5cGUgZXhwZWN0KQp7CgllbnVtIG9iamVjdF90eXBlIHR5cGUgPSBvaWRfb2JqZWN0X2luZm8odGhlX3JlcG9zaXRvcnksIG9pZCwgTlVMTCk7CglpZiAodHlwZSA8IDApCgkJZGllKCIlcyBpcyBub3QgYSB2YWxpZCBvYmplY3QiLCBvaWRfdG9faGV4KG9pZCkpOwoJaWYgKHR5cGUgIT0gZXhwZWN0KQoJCWRpZSgiJXMgaXMgbm90IGEgdmFsaWQgJyVzJyBvYmplY3QiLCBvaWRfdG9faGV4KG9pZCksCgkJICAgIHR5cGVfbmFtZShleHBlY3QpKTsKfQoKaW50IGZvcl9lYWNoX2ZpbGVfaW5fb2JqX3N1YmRpcih1bnNpZ25lZCBpbnQgc3ViZGlyX25yLAoJCQkJc3RydWN0IHN0cmJ1ZiAqcGF0aCwKCQkJCWVhY2hfbG9vc2Vfb2JqZWN0X2ZuIG9ial9jYiwKCQkJCWVhY2hfbG9vc2VfY3J1ZnRfZm4gY3J1ZnRfY2IsCgkJCQllYWNoX2xvb3NlX3N1YmRpcl9mbiBzdWJkaXJfY2IsCgkJCQl2b2lkICpkYXRhKQp7CglzaXplX3Qgb3JpZ2xlbiwgYmFzZWxlbjsKCURJUiAqZGlyOwoJc3RydWN0IGRpcmVudCAqZGU7CglpbnQgciA9IDA7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCglpZiAoc3ViZGlyX25yID4gMHhmZikKCQlCVUcoImludmFsaWQgbG9vc2Ugb2JqZWN0IHN1YmRpcmVjdG9yeTogJXgiLCBzdWJkaXJfbnIpOwoKCW9yaWdsZW4gPSBwYXRoLT5sZW47CglzdHJidWZfY29tcGxldGUocGF0aCwgJy8nKTsKCXN0cmJ1Zl9hZGRmKHBhdGgsICIlMDJ4Iiwgc3ViZGlyX25yKTsKCglkaXIgPSBvcGVuZGlyKHBhdGgtPmJ1Zik7CglpZiAoIWRpcikgewoJCWlmIChlcnJubyAhPSBFTk9FTlQpCgkJCXIgPSBlcnJvcl9lcnJubygidW5hYmxlIHRvIG9wZW4gJXMiLCBwYXRoLT5idWYpOwoJCXN0cmJ1Zl9zZXRsZW4ocGF0aCwgb3JpZ2xlbik7CgkJcmV0dXJuIHI7Cgl9CgoJb2lkLmhhc2hbMF0gPSBzdWJkaXJfbnI7CglzdHJidWZfYWRkY2gocGF0aCwgJy8nKTsKCWJhc2VsZW4gPSBwYXRoLT5sZW47CgoJd2hpbGUgKChkZSA9IHJlYWRkaXIoZGlyKSkpIHsKCQlzaXplX3QgbmFtZWxlbjsKCQlpZiAoaXNfZG90X29yX2RvdGRvdChkZS0+ZF9uYW1lKSkKCQkJY29udGludWU7CgoJCW5hbWVsZW4gPSBzdHJsZW4oZGUtPmRfbmFtZSk7CgkJc3RyYnVmX3NldGxlbihwYXRoLCBiYXNlbGVuKTsKCQlzdHJidWZfYWRkKHBhdGgsIGRlLT5kX25hbWUsIG5hbWVsZW4pOwoJCWlmIChuYW1lbGVuID09IHRoZV9oYXNoX2FsZ28tPmhleHN6IC0gMiAmJgoJCSAgICAhaGV4X3RvX2J5dGVzKG9pZC5oYXNoICsgMSwgZGUtPmRfbmFtZSwKCQkJCSAgdGhlX2hhc2hfYWxnby0+cmF3c3ogLSAxKSkgewoJCQlpZiAob2JqX2NiKSB7CgkJCQlyID0gb2JqX2NiKCZvaWQsIHBhdGgtPmJ1ZiwgZGF0YSk7CgkJCQlpZiAocikKCQkJCQlicmVhazsKCQkJfQoJCQljb250aW51ZTsKCQl9CgoJCWlmIChjcnVmdF9jYikgewoJCQlyID0gY3J1ZnRfY2IoZGUtPmRfbmFtZSwgcGF0aC0+YnVmLCBkYXRhKTsKCQkJaWYgKHIpCgkJCQlicmVhazsKCQl9Cgl9CgljbG9zZWRpcihkaXIpOwoKCXN0cmJ1Zl9zZXRsZW4ocGF0aCwgYmFzZWxlbiAtIDEpOwoJaWYgKCFyICYmIHN1YmRpcl9jYikKCQlyID0gc3ViZGlyX2NiKHN1YmRpcl9uciwgcGF0aC0+YnVmLCBkYXRhKTsKCglzdHJidWZfc2V0bGVuKHBhdGgsIG9yaWdsZW4pOwoKCXJldHVybiByOwp9CgppbnQgZm9yX2VhY2hfbG9vc2VfZmlsZV9pbl9vYmpkaXJfYnVmKHN0cnVjdCBzdHJidWYgKnBhdGgsCgkJCSAgICBlYWNoX2xvb3NlX29iamVjdF9mbiBvYmpfY2IsCgkJCSAgICBlYWNoX2xvb3NlX2NydWZ0X2ZuIGNydWZ0X2NiLAoJCQkgICAgZWFjaF9sb29zZV9zdWJkaXJfZm4gc3ViZGlyX2NiLAoJCQkgICAgdm9pZCAqZGF0YSkKewoJaW50IHIgPSAwOwoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7CgkJciA9IGZvcl9lYWNoX2ZpbGVfaW5fb2JqX3N1YmRpcihpLCBwYXRoLCBvYmpfY2IsIGNydWZ0X2NiLAoJCQkJCQlzdWJkaXJfY2IsIGRhdGEpOwoJCWlmIChyKQoJCQlicmVhazsKCX0KCglyZXR1cm4gcjsKfQoKaW50IGZvcl9lYWNoX2xvb3NlX2ZpbGVfaW5fb2JqZGlyKGNvbnN0IGNoYXIgKnBhdGgsCgkJCQkgIGVhY2hfbG9vc2Vfb2JqZWN0X2ZuIG9ial9jYiwKCQkJCSAgZWFjaF9sb29zZV9jcnVmdF9mbiBjcnVmdF9jYiwKCQkJCSAgZWFjaF9sb29zZV9zdWJkaXJfZm4gc3ViZGlyX2NiLAoJCQkJICB2b2lkICpkYXRhKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaW50IHI7CgoJc3RyYnVmX2FkZHN0cigmYnVmLCBwYXRoKTsKCXIgPSBmb3JfZWFjaF9sb29zZV9maWxlX2luX29iamRpcl9idWYoJmJ1Ziwgb2JqX2NiLCBjcnVmdF9jYiwKCQkJCQkgICAgICBzdWJkaXJfY2IsIGRhdGEpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CgoJcmV0dXJuIHI7Cn0KCnN0cnVjdCBsb29zZV9hbHRfb2RiX2RhdGEgewoJZWFjaF9sb29zZV9vYmplY3RfZm4gKmNiOwoJdm9pZCAqZGF0YTsKfTsKCnN0YXRpYyBpbnQgbG9vc2VfZnJvbV9hbHRfb2RiKHN0cnVjdCBhbHRlcm5hdGVfb2JqZWN0X2RhdGFiYXNlICphbHQsCgkJCSAgICAgIHZvaWQgKnZkYXRhKQp7CglzdHJ1Y3QgbG9vc2VfYWx0X29kYl9kYXRhICpkYXRhID0gdmRhdGE7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaW50IHI7CgoJc3RyYnVmX2FkZHN0cigmYnVmLCBhbHQtPnBhdGgpOwoJciA9IGZvcl9lYWNoX2xvb3NlX2ZpbGVfaW5fb2JqZGlyX2J1ZigmYnVmLAoJCQkJCSAgICAgIGRhdGEtPmNiLCBOVUxMLCBOVUxMLAoJCQkJCSAgICAgIGRhdGEtPmRhdGEpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CglyZXR1cm4gcjsKfQoKaW50IGZvcl9lYWNoX2xvb3NlX29iamVjdChlYWNoX2xvb3NlX29iamVjdF9mbiBjYiwgdm9pZCAqZGF0YSwgdW5zaWduZWQgZmxhZ3MpCnsKCXN0cnVjdCBsb29zZV9hbHRfb2RiX2RhdGEgYWx0OwoJaW50IHI7CgoJciA9IGZvcl9lYWNoX2xvb3NlX2ZpbGVfaW5fb2JqZGlyKGdldF9vYmplY3RfZGlyZWN0b3J5KCksCgkJCQkJICBjYiwgTlVMTCwgTlVMTCwgZGF0YSk7CglpZiAocikKCQlyZXR1cm4gcjsKCglpZiAoZmxhZ3MgJiBGT1JfRUFDSF9PQkpFQ1RfTE9DQUxfT05MWSkKCQlyZXR1cm4gMDsKCglhbHQuY2IgPSBjYjsKCWFsdC5kYXRhID0gZGF0YTsKCXJldHVybiBmb3JlYWNoX2FsdF9vZGIobG9vc2VfZnJvbV9hbHRfb2RiLCAmYWx0KTsKfQoKc3RhdGljIGludCBjaGVja19zdHJlYW1fc2hhMShnaXRfenN0cmVhbSAqc3RyZWFtLAoJCQkgICAgIGNvbnN0IGNoYXIgKmhkciwKCQkJICAgICB1bnNpZ25lZCBsb25nIHNpemUsCgkJCSAgICAgY29uc3QgY2hhciAqcGF0aCwKCQkJICAgICBjb25zdCB1bnNpZ25lZCBjaGFyICpleHBlY3RlZF9zaGExKQp7CglnaXRfaGFzaF9jdHggYzsKCXVuc2lnbmVkIGNoYXIgcmVhbF9zaGExW0dJVF9NQVhfUkFXU1pdOwoJdW5zaWduZWQgY2hhciBidWZbNDA5Nl07Cgl1bnNpZ25lZCBsb25nIHRvdGFsX3JlYWQ7CglpbnQgc3RhdHVzID0gWl9PSzsKCgl0aGVfaGFzaF9hbGdvLT5pbml0X2ZuKCZjKTsKCXRoZV9oYXNoX2FsZ28tPnVwZGF0ZV9mbigmYywgaGRyLCBzdHJlYW0tPnRvdGFsX291dCk7CgoJLyoKCSAqIFdlIGFscmVhZHkgcmVhZCBzb21lIGJ5dGVzIGludG8gaGRyLCBidXQgdGhlIG9uZXMgdXAgdG8gdGhlIE5VTAoJICogZG8gbm90IGNvdW50IGFnYWluc3QgdGhlIG9iamVjdCdzIGNvbnRlbnQgc2l6ZS4KCSAqLwoJdG90YWxfcmVhZCA9IHN0cmVhbS0+dG90YWxfb3V0IC0gc3RybGVuKGhkcikgLSAxOwoKCS8qCgkgKiBUaGlzIHNpemUgY29tcGFyaXNvbiBtdXN0IGJlICI8PSIgdG8gcmVhZCB0aGUgZmluYWwgemxpYiBwYWNrZXRzOwoJICogc2VlIHRoZSBjb21tZW50IGluIHVucGFja19zaGExX3Jlc3QgZm9yIGRldGFpbHMuCgkgKi8KCXdoaWxlICh0b3RhbF9yZWFkIDw9IHNpemUgJiYKCSAgICAgICAoc3RhdHVzID09IFpfT0sgfHwgc3RhdHVzID09IFpfQlVGX0VSUk9SKSkgewoJCXN0cmVhbS0+bmV4dF9vdXQgPSBidWY7CgkJc3RyZWFtLT5hdmFpbF9vdXQgPSBzaXplb2YoYnVmKTsKCQlpZiAoc2l6ZSAtIHRvdGFsX3JlYWQgPCBzdHJlYW0tPmF2YWlsX291dCkKCQkJc3RyZWFtLT5hdmFpbF9vdXQgPSBzaXplIC0gdG90YWxfcmVhZDsKCQlzdGF0dXMgPSBnaXRfaW5mbGF0ZShzdHJlYW0sIFpfRklOSVNIKTsKCQl0aGVfaGFzaF9hbGdvLT51cGRhdGVfZm4oJmMsIGJ1Ziwgc3RyZWFtLT5uZXh0X291dCAtIGJ1Zik7CgkJdG90YWxfcmVhZCArPSBzdHJlYW0tPm5leHRfb3V0IC0gYnVmOwoJfQoJZ2l0X2luZmxhdGVfZW5kKHN0cmVhbSk7CgoJaWYgKHN0YXR1cyAhPSBaX1NUUkVBTV9FTkQpIHsKCQllcnJvcigiY29ycnVwdCBsb29zZSBvYmplY3QgJyVzJyIsIHNoYTFfdG9faGV4KGV4cGVjdGVkX3NoYTEpKTsKCQlyZXR1cm4gLTE7Cgl9CglpZiAoc3RyZWFtLT5hdmFpbF9pbikgewoJCWVycm9yKCJnYXJiYWdlIGF0IGVuZCBvZiBsb29zZSBvYmplY3QgJyVzJyIsCgkJICAgICAgc2hhMV90b19oZXgoZXhwZWN0ZWRfc2hhMSkpOwoJCXJldHVybiAtMTsKCX0KCgl0aGVfaGFzaF9hbGdvLT5maW5hbF9mbihyZWFsX3NoYTEsICZjKTsKCWlmIChoYXNoY21wKGV4cGVjdGVkX3NoYTEsIHJlYWxfc2hhMSkpIHsKCQllcnJvcigic2hhMSBtaXNtYXRjaCBmb3IgJXMgKGV4cGVjdGVkICVzKSIsIHBhdGgsCgkJICAgICAgc2hhMV90b19oZXgoZXhwZWN0ZWRfc2hhMSkpOwoJCXJldHVybiAtMTsKCX0KCglyZXR1cm4gMDsKfQoKaW50IHJlYWRfbG9vc2Vfb2JqZWN0KGNvbnN0IGNoYXIgKnBhdGgsCgkJICAgICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqZXhwZWN0ZWRfb2lkLAoJCSAgICAgIGVudW0gb2JqZWN0X3R5cGUgKnR5cGUsCgkJICAgICAgdW5zaWduZWQgbG9uZyAqc2l6ZSwKCQkgICAgICB2b2lkICoqY29udGVudHMpCnsKCWludCByZXQgPSAtMTsKCXZvaWQgKm1hcCA9IE5VTEw7Cgl1bnNpZ25lZCBsb25nIG1hcHNpemU7CglnaXRfenN0cmVhbSBzdHJlYW07CgljaGFyIGhkcltNQVhfSEVBREVSX0xFTl07CgoJKmNvbnRlbnRzID0gTlVMTDsKCgltYXAgPSBtYXBfc2hhMV9maWxlXzEodGhlX3JlcG9zaXRvcnksIHBhdGgsIE5VTEwsICZtYXBzaXplKTsKCWlmICghbWFwKSB7CgkJZXJyb3JfZXJybm8oInVuYWJsZSB0byBtbWFwICVzIiwgcGF0aCk7CgkJZ290byBvdXQ7Cgl9CgoJaWYgKHVucGFja19zaGExX2hlYWRlcigmc3RyZWFtLCBtYXAsIG1hcHNpemUsIGhkciwgc2l6ZW9mKGhkcikpIDwgMCkgewoJCWVycm9yKCJ1bmFibGUgdG8gdW5wYWNrIGhlYWRlciBvZiAlcyIsIHBhdGgpOwoJCWdvdG8gb3V0OwoJfQoKCSp0eXBlID0gcGFyc2Vfc2hhMV9oZWFkZXIoaGRyLCBzaXplKTsKCWlmICgqdHlwZSA8IDApIHsKCQllcnJvcigidW5hYmxlIHRvIHBhcnNlIGhlYWRlciBvZiAlcyIsIHBhdGgpOwoJCWdpdF9pbmZsYXRlX2VuZCgmc3RyZWFtKTsKCQlnb3RvIG91dDsKCX0KCglpZiAoKnR5cGUgPT0gT0JKX0JMT0IgJiYgKnNpemUgPiBiaWdfZmlsZV90aHJlc2hvbGQpIHsKCQlpZiAoY2hlY2tfc3RyZWFtX3NoYTEoJnN0cmVhbSwgaGRyLCAqc2l6ZSwgcGF0aCwgZXhwZWN0ZWRfb2lkLT5oYXNoKSA8IDApCgkJCWdvdG8gb3V0OwoJfSBlbHNlIHsKCQkqY29udGVudHMgPSB1bnBhY2tfc2hhMV9yZXN0KCZzdHJlYW0sIGhkciwgKnNpemUsIGV4cGVjdGVkX29pZC0+aGFzaCk7CgkJaWYgKCEqY29udGVudHMpIHsKCQkJZXJyb3IoInVuYWJsZSB0byB1bnBhY2sgY29udGVudHMgb2YgJXMiLCBwYXRoKTsKCQkJZ2l0X2luZmxhdGVfZW5kKCZzdHJlYW0pOwoJCQlnb3RvIG91dDsKCQl9CgkJaWYgKGNoZWNrX29iamVjdF9zaWduYXR1cmUoZXhwZWN0ZWRfb2lkLCAqY29udGVudHMsCgkJCQkJICpzaXplLCB0eXBlX25hbWUoKnR5cGUpKSkgewoJCQllcnJvcigic2hhMSBtaXNtYXRjaCBmb3IgJXMgKGV4cGVjdGVkICVzKSIsIHBhdGgsCgkJCSAgICAgIG9pZF90b19oZXgoZXhwZWN0ZWRfb2lkKSk7CgkJCWZyZWUoKmNvbnRlbnRzKTsKCQkJZ290byBvdXQ7CgkJfQoJfQoKCXJldCA9IDA7IC8qIGV2ZXJ5dGhpbmcgY2hlY2tzIG91dCAqLwoKb3V0OgoJaWYgKG1hcCkKCQltdW5tYXAobWFwLCBtYXBzaXplKTsKCXJldHVybiByZXQ7Cn0K",
    "text": "/*\n * GIT - The information manager from hell\n *\n * Copyright (C) Linus Torvalds, 2005\n *\n * This handles basic git sha1 object files - packing, unpacking,\n * creation etc.\n */\n#include \"cache.h\"\n#include \"config.h\"\n#include \"string-list.h\"\n#include \"lockfile.h\"\n#include \"delta.h\"\n#include \"pack.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"run-command.h\"\n#include \"tag.h\"\n#include \"tree.h\"\n#include \"tree-walk.h\"\n#include \"refs.h\"\n#include \"pack-revindex.h\"\n#include \"sha1-lookup.h\"\n#include \"bulk-checkin.h\"\n#include \"repository.h\"\n#include \"replace-object.h\"\n#include \"streaming.h\"\n#include \"dir.h\"\n#include \"list.h\"\n#include \"mergesort.h\"\n#include \"quote.h\"\n#include \"packfile.h\"\n#include \"fetch-object.h\"\n#include \"object-store.h\"\n\n/* The maximum size for an object header. */\n#define MAX_HEADER_LEN 32\n\n\n#define EMPTY_TREE_SHA1_BIN_LITERAL \\\n\t \"\\x4b\\x82\\x5d\\xc6\\x42\\xcb\\x6e\\xb9\\xa0\\x60\" \\\n\t \"\\xe5\\x4b\\xf8\\xd6\\x92\\x88\\xfb\\xee\\x49\\x04\"\n\n#define EMPTY_BLOB_SHA1_BIN_LITERAL \\\n\t\"\\xe6\\x9d\\xe2\\x9b\\xb2\\xd1\\xd6\\x43\\x4b\\x8b\" \\\n\t\"\\x29\\xae\\x77\\x5a\\xd8\\xc2\\xe4\\x8c\\x53\\x91\"\n\nconst unsigned char null_sha1[GIT_MAX_RAWSZ];\nconst struct object_id null_oid;\nstatic const struct object_id empty_tree_oid = {\n\tEMPTY_TREE_SHA1_BIN_LITERAL\n};\nstatic const struct object_id empty_blob_oid = {\n\tEMPTY_BLOB_SHA1_BIN_LITERAL\n};\n\nstatic void git_hash_sha1_init(git_hash_ctx *ctx)\n{\n\tgit_SHA1_Init(&ctx->sha1);\n}\n\nstatic void git_hash_sha1_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tgit_SHA1_Update(&ctx->sha1, data, len);\n}\n\nstatic void git_hash_sha1_final(unsigned char *hash, git_hash_ctx *ctx)\n{\n\tgit_SHA1_Final(hash, &ctx->sha1);\n}\n\nstatic void git_hash_unknown_init(git_hash_ctx *ctx)\n{\n\tdie(\"trying to init unknown hash\");\n}\n\nstatic void git_hash_unknown_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tdie(\"trying to update unknown hash\");\n}\n\nstatic void git_hash_unknown_final(unsigned char *hash, git_hash_ctx *ctx)\n{\n\tdie(\"trying to finalize unknown hash\");\n}\n\nconst struct git_hash_algo hash_algos[GIT_HASH_NALGOS] = {\n\t{\n\t\tNULL,\n\t\t0x00000000,\n\t\t0,\n\t\t0,\n\t\tgit_hash_unknown_init,\n\t\tgit_hash_unknown_update,\n\t\tgit_hash_unknown_final,\n\t\tNULL,\n\t\tNULL,\n\t},\n\t{\n\t\t\"sha-1\",\n\t\t/* \"sha1\", big-endian */\n\t\t0x73686131,\n\t\tGIT_SHA1_RAWSZ,\n\t\tGIT_SHA1_HEXSZ,\n\t\tgit_hash_sha1_init,\n\t\tgit_hash_sha1_update,\n\t\tgit_hash_sha1_final,\n\t\t&empty_tree_oid,\n\t\t&empty_blob_oid,\n\t},\n};\n\nconst char *empty_tree_oid_hex(void)\n{\n\tstatic char buf[GIT_MAX_HEXSZ + 1];\n\treturn oid_to_hex_r(buf, the_hash_algo->empty_tree);\n}\n\nconst char *empty_blob_oid_hex(void)\n{\n\tstatic char buf[GIT_MAX_HEXSZ + 1];\n\treturn oid_to_hex_r(buf, the_hash_algo->empty_blob);\n}\n\n/*\n * This is meant to hold a *small* number of objects that you would\n * want read_sha1_file() to be able to return, but yet you do not want\n * to write them into the object store (e.g. a browse-only\n * application).\n */\nstatic struct cached_object {\n\tstruct object_id oid;\n\tenum object_type type;\n\tvoid *buf;\n\tunsigned long size;\n} *cached_objects;\nstatic int cached_object_nr, cached_object_alloc;\n\nstatic struct cached_object empty_tree = {\n\t{ EMPTY_TREE_SHA1_BIN_LITERAL },\n\tOBJ_TREE,\n\t\"\",\n\t0\n};\n\nstatic struct cached_object *find_cached_object(const struct object_id *oid)\n{\n\tint i;\n\tstruct cached_object *co = cached_objects;\n\n\tfor (i = 0; i < cached_object_nr; i++, co++) {\n\t\tif (!oidcmp(&co->oid, oid))\n\t\t\treturn co;\n\t}\n\tif (!oidcmp(oid, the_hash_algo->empty_tree))\n\t\treturn &empty_tree;\n\treturn NULL;\n}\n\n\nstatic int get_conv_flags(unsigned flags)\n{\n\tif (flags & HASH_RENORMALIZE)\n\t\treturn CONV_EOL_RENORMALIZE;\n\telse if (flags & HASH_WRITE_OBJECT)\n\t\treturn global_conv_flags_eol | CONV_WRITE_OBJECT;\n\telse\n\t\treturn 0;\n}\n\n\nint mkdir_in_gitdir(const char *path)\n{\n\tif (mkdir(path, 0777)) {\n\t\tint saved_errno = errno;\n\t\tstruct stat st;\n\t\tstruct strbuf sb = STRBUF_INIT;\n\n\t\tif (errno != EEXIST)\n\t\t\treturn -1;\n\t\t/*\n\t\t * Are we looking at a path in a symlinked worktree\n\t\t * whose original repository does not yet have it?\n\t\t * e.g. .git/rr-cache pointing at its original\n\t\t * repository in which the user hasn't performed any\n\t\t * conflict resolution yet?\n\t\t */\n\t\tif (lstat(path, &st) || !S_ISLNK(st.st_mode) ||\n\t\t    strbuf_readlink(&sb, path, st.st_size) ||\n\t\t    !is_absolute_path(sb.buf) ||\n\t\t    mkdir(sb.buf, 0777)) {\n\t\t\tstrbuf_release(&sb);\n\t\t\terrno = saved_errno;\n\t\t\treturn -1;\n\t\t}\n\t\tstrbuf_release(&sb);\n\t}\n\treturn adjust_shared_perm(path);\n}\n\nenum scld_error safe_create_leading_directories(char *path)\n{\n\tchar *next_component = path + offset_1st_component(path);\n\tenum scld_error ret = SCLD_OK;\n\n\twhile (ret == SCLD_OK && next_component) {\n\t\tstruct stat st;\n\t\tchar *slash = next_component, slash_character;\n\n\t\twhile (*slash && !is_dir_sep(*slash))\n\t\t\tslash++;\n\n\t\tif (!*slash)\n\t\t\tbreak;\n\n\t\tnext_component = slash + 1;\n\t\twhile (is_dir_sep(*next_component))\n\t\t\tnext_component++;\n\t\tif (!*next_component)\n\t\t\tbreak;\n\n\t\tslash_character = *slash;\n\t\t*slash = '\\0';\n\t\tif (!stat(path, &st)) {\n\t\t\t/* path exists */\n\t\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\t\terrno = ENOTDIR;\n\t\t\t\tret = SCLD_EXISTS;\n\t\t\t}\n\t\t} else if (mkdir(path, 0777)) {\n\t\t\tif (errno == EEXIST &&\n\t\t\t    !stat(path, &st) && S_ISDIR(st.st_mode))\n\t\t\t\t; /* somebody created it since we checked */\n\t\t\telse if (errno == ENOENT)\n\t\t\t\t/*\n\t\t\t\t * Either mkdir() failed because\n\t\t\t\t * somebody just pruned the containing\n\t\t\t\t * directory, or stat() failed because\n\t\t\t\t * the file that was in our way was\n\t\t\t\t * just removed.  Either way, inform\n\t\t\t\t * the caller that it might be worth\n\t\t\t\t * trying again:\n\t\t\t\t */\n\t\t\t\tret = SCLD_VANISHED;\n\t\t\telse\n\t\t\t\tret = SCLD_FAILED;\n\t\t} else if (adjust_shared_perm(path)) {\n\t\t\tret = SCLD_PERMS;\n\t\t}\n\t\t*slash = slash_character;\n\t}\n\treturn ret;\n}\n\nenum scld_error safe_create_leading_directories_const(const char *path)\n{\n\tint save_errno;\n\t/* path points to cache entries, so xstrdup before messing with it */\n\tchar *buf = xstrdup(path);\n\tenum scld_error result = safe_create_leading_directories(buf);\n\n\tsave_errno = errno;\n\tfree(buf);\n\terrno = save_errno;\n\treturn result;\n}\n\nint raceproof_create_file(const char *path, create_file_fn fn, void *cb)\n{\n\t/*\n\t * The number of times we will try to remove empty directories\n\t * in the way of path. This is only 1 because if another\n\t * process is racily creating directories that conflict with\n\t * us, we don't want to fight against them.\n\t */\n\tint remove_directories_remaining = 1;\n\n\t/*\n\t * The number of times that we will try to create the\n\t * directories containing path. We are willing to attempt this\n\t * more than once, because another process could be trying to\n\t * clean up empty directories at the same time as we are\n\t * trying to create them.\n\t */\n\tint create_directories_remaining = 3;\n\n\t/* A scratch copy of path, filled lazily if we need it: */\n\tstruct strbuf path_copy = STRBUF_INIT;\n\n\tint ret, save_errno;\n\n\t/* Sanity check: */\n\tassert(*path);\n\nretry_fn:\n\tret = fn(path, cb);\n\tsave_errno = errno;\n\tif (!ret)\n\t\tgoto out;\n\n\tif (errno == EISDIR && remove_directories_remaining-- > 0) {\n\t\t/*\n\t\t * A directory is in the way. Maybe it is empty; try\n\t\t * to remove it:\n\t\t */\n\t\tif (!path_copy.len)\n\t\t\tstrbuf_addstr(&path_copy, path);\n\n\t\tif (!remove_dir_recursively(&path_copy, REMOVE_DIR_EMPTY_ONLY))\n\t\t\tgoto retry_fn;\n\t} else if (errno == ENOENT && create_directories_remaining-- > 0) {\n\t\t/*\n\t\t * Maybe the containing directory didn't exist, or\n\t\t * maybe it was just deleted by a process that is\n\t\t * racing with us to clean up empty directories. Try\n\t\t * to create it:\n\t\t */\n\t\tenum scld_error scld_result;\n\n\t\tif (!path_copy.len)\n\t\t\tstrbuf_addstr(&path_copy, path);\n\n\t\tdo {\n\t\t\tscld_result = safe_create_leading_directories(path_copy.buf);\n\t\t\tif (scld_result == SCLD_OK)\n\t\t\t\tgoto retry_fn;\n\t\t} while (scld_result == SCLD_VANISHED && create_directories_remaining-- > 0);\n\t}\n\nout:\n\tstrbuf_release(&path_copy);\n\terrno = save_errno;\n\treturn ret;\n}\n\nstatic void fill_sha1_path(struct strbuf *buf, const unsigned char *sha1)\n{\n\tint i;\n\tfor (i = 0; i < the_hash_algo->rawsz; i++) {\n\t\tstatic char hex[] = \"0123456789abcdef\";\n\t\tunsigned int val = sha1[i];\n\t\tstrbuf_addch(buf, hex[val >> 4]);\n\t\tstrbuf_addch(buf, hex[val & 0xf]);\n\t\tif (!i)\n\t\t\tstrbuf_addch(buf, '/');\n\t}\n}\n\nvoid sha1_file_name(struct repository *r, struct strbuf *buf, const unsigned char *sha1)\n{\n\tstrbuf_addstr(buf, r->objects->objectdir);\n\tstrbuf_addch(buf, '/');\n\tfill_sha1_path(buf, sha1);\n}\n\nstruct strbuf *alt_scratch_buf(struct alternate_object_database *alt)\n{\n\tstrbuf_setlen(&alt->scratch, alt->base_len);\n\treturn &alt->scratch;\n}\n\nstatic const char *alt_sha1_path(struct alternate_object_database *alt,\n\t\t\t\t const unsigned char *sha1)\n{\n\tstruct strbuf *buf = alt_scratch_buf(alt);\n\tfill_sha1_path(buf, sha1);\n\treturn buf->buf;\n}\n\n/*\n * Return non-zero iff the path is usable as an alternate object database.\n */\nstatic int alt_odb_usable(struct raw_object_store *o,\n\t\t\t  struct strbuf *path,\n\t\t\t  const char *normalized_objdir)\n{\n\tstruct alternate_object_database *alt;\n\n\t/* Detect cases where alternate disappeared */\n\tif (!is_directory(path->buf)) {\n\t\terror(\"object directory %s does not exist; \"\n\t\t      \"check .git/objects/info/alternates.\",\n\t\t      path->buf);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Prevent the common mistake of listing the same\n\t * thing twice, or object directory itself.\n\t */\n\tfor (alt = o->alt_odb_list; alt; alt = alt->next) {\n\t\tif (!fspathcmp(path->buf, alt->path))\n\t\t\treturn 0;\n\t}\n\tif (!fspathcmp(path->buf, normalized_objdir))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/*\n * Prepare alternate object database registry.\n *\n * The variable alt_odb_list points at the list of struct\n * alternate_object_database.  The elements on this list come from\n * non-empty elements from colon separated ALTERNATE_DB_ENVIRONMENT\n * environment variable, and $GIT_OBJECT_DIRECTORY/info/alternates,\n * whose contents is similar to that environment variable but can be\n * LF separated.  Its base points at a statically allocated buffer that\n * contains \"/the/directory/corresponding/to/.git/objects/...\", while\n * its name points just after the slash at the end of \".git/objects/\"\n * in the example above, and has enough space to hold 40-byte hex\n * SHA1, an extra slash for the first level indirection, and the\n * terminating NUL.\n */\nstatic void read_info_alternates(struct repository *r,\n\t\t\t\t const char *relative_base,\n\t\t\t\t int depth);\nstatic int link_alt_odb_entry(struct repository *r, const char *entry,\n\tconst char *relative_base, int depth, const char *normalized_objdir)\n{\n\tstruct alternate_object_database *ent;\n\tstruct strbuf pathbuf = STRBUF_INIT;\n\n\tif (!is_absolute_path(entry) && relative_base) {\n\t\tstrbuf_realpath(&pathbuf, relative_base, 1);\n\t\tstrbuf_addch(&pathbuf, '/');\n\t}\n\tstrbuf_addstr(&pathbuf, entry);\n\n\tif (strbuf_normalize_path(&pathbuf) < 0 && relative_base) {\n\t\terror(\"unable to normalize alternate object path: %s\",\n\t\t      pathbuf.buf);\n\t\tstrbuf_release(&pathbuf);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * The trailing slash after the directory name is given by\n\t * this function at the end. Remove duplicates.\n\t */\n\twhile (pathbuf.len && pathbuf.buf[pathbuf.len - 1] == '/')\n\t\tstrbuf_setlen(&pathbuf, pathbuf.len - 1);\n\n\tif (!alt_odb_usable(r->objects, &pathbuf, normalized_objdir)) {\n\t\tstrbuf_release(&pathbuf);\n\t\treturn -1;\n\t}\n\n\tent = alloc_alt_odb(pathbuf.buf);\n\n\t/* add the alternate entry */\n\t*r->objects->alt_odb_tail = ent;\n\tr->objects->alt_odb_tail = &(ent->next);\n\tent->next = NULL;\n\n\t/* recursively add alternates */\n\tread_info_alternates(r, pathbuf.buf, depth + 1);\n\n\tstrbuf_release(&pathbuf);\n\treturn 0;\n}\n\nstatic const char *parse_alt_odb_entry(const char *string,\n\t\t\t\t       int sep,\n\t\t\t\t       struct strbuf *out)\n{\n\tconst char *end;\n\n\tstrbuf_reset(out);\n\n\tif (*string == '#') {\n\t\t/* comment; consume up to next separator */\n\t\tend = strchrnul(string, sep);\n\t} else if (*string == '\"' && !unquote_c_style(out, string, &end)) {\n\t\t/*\n\t\t * quoted path; unquote_c_style has copied the\n\t\t * data for us and set \"end\". Broken quoting (e.g.,\n\t\t * an entry that doesn't end with a quote) falls\n\t\t * back to the unquoted case below.\n\t\t */\n\t} else {\n\t\t/* normal, unquoted path */\n\t\tend = strchrnul(string, sep);\n\t\tstrbuf_add(out, string, end - string);\n\t}\n\n\tif (*end)\n\t\tend++;\n\treturn end;\n}\n\nstatic void link_alt_odb_entries(struct repository *r, const char *alt,\n\t\t\t\t int sep, const char *relative_base, int depth)\n{\n\tstruct strbuf objdirbuf = STRBUF_INIT;\n\tstruct strbuf entry = STRBUF_INIT;\n\n\tif (!alt || !*alt)\n\t\treturn;\n\n\tif (depth > 5) {\n\t\terror(\"%s: ignoring alternate object stores, nesting too deep.\",\n\t\t\t\trelative_base);\n\t\treturn;\n\t}\n\n\tstrbuf_add_absolute_path(&objdirbuf, r->objects->objectdir);\n\tif (strbuf_normalize_path(&objdirbuf) < 0)\n\t\tdie(\"unable to normalize object directory: %s\",\n\t\t    objdirbuf.buf);\n\n\twhile (*alt) {\n\t\talt = parse_alt_odb_entry(alt, sep, &entry);\n\t\tif (!entry.len)\n\t\t\tcontinue;\n\t\tlink_alt_odb_entry(r, entry.buf,\n\t\t\t\t   relative_base, depth, objdirbuf.buf);\n\t}\n\tstrbuf_release(&entry);\n\tstrbuf_release(&objdirbuf);\n}\n\nstatic void read_info_alternates(struct repository *r,\n\t\t\t\t const char *relative_base,\n\t\t\t\t int depth)\n{\n\tchar *path;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tpath = xstrfmt(\"%s/info/alternates\", relative_base);\n\tif (strbuf_read_file(&buf, path, 1024) < 0) {\n\t\twarn_on_fopen_errors(path);\n\t\tfree(path);\n\t\treturn;\n\t}\n\n\tlink_alt_odb_entries(r, buf.buf, '\\n', relative_base, depth);\n\tstrbuf_release(&buf);\n\tfree(path);\n}\n\nstruct alternate_object_database *alloc_alt_odb(const char *dir)\n{\n\tstruct alternate_object_database *ent;\n\n\tFLEX_ALLOC_STR(ent, path, dir);\n\tstrbuf_init(&ent->scratch, 0);\n\tstrbuf_addf(&ent->scratch, \"%s/\", dir);\n\tent->base_len = ent->scratch.len;\n\n\treturn ent;\n}\n\nvoid add_to_alternates_file(const char *reference)\n{\n\tstruct lock_file lock = LOCK_INIT;\n\tchar *alts = git_pathdup(\"objects/info/alternates\");\n\tFILE *in, *out;\n\tint found = 0;\n\n\thold_lock_file_for_update(&lock, alts, LOCK_DIE_ON_ERROR);\n\tout = fdopen_lock_file(&lock, \"w\");\n\tif (!out)\n\t\tdie_errno(\"unable to fdopen alternates lockfile\");\n\n\tin = fopen(alts, \"r\");\n\tif (in) {\n\t\tstruct strbuf line = STRBUF_INIT;\n\n\t\twhile (strbuf_getline(&line, in) != EOF) {\n\t\t\tif (!strcmp(reference, line.buf)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf_or_die(out, \"%s\\n\", line.buf);\n\t\t}\n\n\t\tstrbuf_release(&line);\n\t\tfclose(in);\n\t}\n\telse if (errno != ENOENT)\n\t\tdie_errno(\"unable to read alternates file\");\n\n\tif (found) {\n\t\trollback_lock_file(&lock);\n\t} else {\n\t\tfprintf_or_die(out, \"%s\\n\", reference);\n\t\tif (commit_lock_file(&lock))\n\t\t\tdie_errno(\"unable to move new alternates file into place\");\n\t\tif (the_repository->objects->alt_odb_tail)\n\t\t\tlink_alt_odb_entries(the_repository, reference,\n\t\t\t\t\t     '\\n', NULL, 0);\n\t}\n\tfree(alts);\n}\n\nvoid add_to_alternates_memory(const char *reference)\n{\n\t/*\n\t * Make sure alternates are initialized, or else our entry may be\n\t * overwritten when they are.\n\t */\n\tprepare_alt_odb(the_repository);\n\n\tlink_alt_odb_entries(the_repository, reference,\n\t\t\t     '\\n', NULL, 0);\n}\n\n/*\n * Compute the exact path an alternate is at and returns it. In case of\n * error NULL is returned and the human readable error is added to `err`\n * `path` may be relative and should point to $GIT_DIR.\n * `err` must not be null.\n */\nchar *compute_alternate_path(const char *path, struct strbuf *err)\n{\n\tchar *ref_git = NULL;\n\tconst char *repo, *ref_git_s;\n\tint seen_error = 0;\n\n\tref_git_s = real_path_if_valid(path);\n\tif (!ref_git_s) {\n\t\tseen_error = 1;\n\t\tstrbuf_addf(err, _(\"path '%s' does not exist\"), path);\n\t\tgoto out;\n\t} else\n\t\t/*\n\t\t * Beware: read_gitfile(), real_path() and mkpath()\n\t\t * return static buffer\n\t\t */\n\t\tref_git = xstrdup(ref_git_s);\n\n\trepo = read_gitfile(ref_git);\n\tif (!repo)\n\t\trepo = read_gitfile(mkpath(\"%s/.git\", ref_git));\n\tif (repo) {\n\t\tfree(ref_git);\n\t\tref_git = xstrdup(repo);\n\t}\n\n\tif (!repo && is_directory(mkpath(\"%s/.git/objects\", ref_git))) {\n\t\tchar *ref_git_git = mkpathdup(\"%s/.git\", ref_git);\n\t\tfree(ref_git);\n\t\tref_git = ref_git_git;\n\t} else if (!is_directory(mkpath(\"%s/objects\", ref_git))) {\n\t\tstruct strbuf sb = STRBUF_INIT;\n\t\tseen_error = 1;\n\t\tif (get_common_dir(&sb, ref_git)) {\n\t\t\tstrbuf_addf(err,\n\t\t\t\t    _(\"reference repository '%s' as a linked \"\n\t\t\t\t      \"checkout is not supported yet.\"),\n\t\t\t\t    path);\n\t\t\tgoto out;\n\t\t}\n\n\t\tstrbuf_addf(err, _(\"reference repository '%s' is not a \"\n\t\t\t\t\t\"local repository.\"), path);\n\t\tgoto out;\n\t}\n\n\tif (!access(mkpath(\"%s/shallow\", ref_git), F_OK)) {\n\t\tstrbuf_addf(err, _(\"reference repository '%s' is shallow\"),\n\t\t\t    path);\n\t\tseen_error = 1;\n\t\tgoto out;\n\t}\n\n\tif (!access(mkpath(\"%s/info/grafts\", ref_git), F_OK)) {\n\t\tstrbuf_addf(err,\n\t\t\t    _(\"reference repository '%s' is grafted\"),\n\t\t\t    path);\n\t\tseen_error = 1;\n\t\tgoto out;\n\t}\n\nout:\n\tif (seen_error) {\n\t\tFREE_AND_NULL(ref_git);\n\t}\n\n\treturn ref_git;\n}\n\nint foreach_alt_odb(alt_odb_fn fn, void *cb)\n{\n\tstruct alternate_object_database *ent;\n\tint r = 0;\n\n\tprepare_alt_odb(the_repository);\n\tfor (ent = the_repository->objects->alt_odb_list; ent; ent = ent->next) {\n\t\tr = fn(ent, cb);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\treturn r;\n}\n\nvoid prepare_alt_odb(struct repository *r)\n{\n\tif (r->objects->alt_odb_tail)\n\t\treturn;\n\n\tr->objects->alt_odb_tail = &r->objects->alt_odb_list;\n\tlink_alt_odb_entries(r, r->objects->alternate_db, PATH_SEP, NULL, 0);\n\n\tread_info_alternates(r, r->objects->objectdir, 0);\n}\n\n/* Returns 1 if we have successfully freshened the file, 0 otherwise. */\nstatic int freshen_file(const char *fn)\n{\n\tstruct utimbuf t;\n\tt.actime = t.modtime = time(NULL);\n\treturn !utime(fn, &t);\n}\n\n/*\n * All of the check_and_freshen functions return 1 if the file exists and was\n * freshened (if freshening was requested), 0 otherwise. If they return\n * 0, you should not assume that it is safe to skip a write of the object (it\n * either does not exist on disk, or has a stale mtime and may be subject to\n * pruning).\n */\nint check_and_freshen_file(const char *fn, int freshen)\n{\n\tif (access(fn, F_OK))\n\t\treturn 0;\n\tif (freshen && !freshen_file(fn))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int check_and_freshen_local(const struct object_id *oid, int freshen)\n{\n\tstatic struct strbuf buf = STRBUF_INIT;\n\n\tstrbuf_reset(&buf);\n\tsha1_file_name(the_repository, &buf, oid->hash);\n\n\treturn check_and_freshen_file(buf.buf, freshen);\n}\n\nstatic int check_and_freshen_nonlocal(const struct object_id *oid, int freshen)\n{\n\tstruct alternate_object_database *alt;\n\tprepare_alt_odb(the_repository);\n\tfor (alt = the_repository->objects->alt_odb_list; alt; alt = alt->next) {\n\t\tconst char *path = alt_sha1_path(alt, oid->hash);\n\t\tif (check_and_freshen_file(path, freshen))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int check_and_freshen(const struct object_id *oid, int freshen)\n{\n\treturn check_and_freshen_local(oid, freshen) ||\n\t       check_and_freshen_nonlocal(oid, freshen);\n}\n\nint has_loose_object_nonlocal(const struct object_id *oid)\n{\n\treturn check_and_freshen_nonlocal(oid, 0);\n}\n\nstatic int has_loose_object(const struct object_id *oid)\n{\n\treturn check_and_freshen(oid, 0);\n}\n\nstatic void mmap_limit_check(size_t length)\n{\n\tstatic size_t limit = 0;\n\tif (!limit) {\n\t\tlimit = git_env_ulong(\"GIT_MMAP_LIMIT\", 0);\n\t\tif (!limit)\n\t\t\tlimit = SIZE_MAX;\n\t}\n\tif (length > limit)\n\t\tdie(\"attempting to mmap %\"PRIuMAX\" over limit %\"PRIuMAX,\n\t\t    (uintmax_t)length, (uintmax_t)limit);\n}\n\nvoid *xmmap_gently(void *start, size_t length,\n\t\t  int prot, int flags, int fd, off_t offset)\n{\n\tvoid *ret;\n\n\tmmap_limit_check(length);\n\tret = mmap(start, length, prot, flags, fd, offset);\n\tif (ret == MAP_FAILED) {\n\t\tif (!length)\n\t\t\treturn NULL;\n\t\trelease_pack_memory(length);\n\t\tret = mmap(start, length, prot, flags, fd, offset);\n\t}\n\treturn ret;\n}\n\nvoid *xmmap(void *start, size_t length,\n\tint prot, int flags, int fd, off_t offset)\n{\n\tvoid *ret = xmmap_gently(start, length, prot, flags, fd, offset);\n\tif (ret == MAP_FAILED)\n\t\tdie_errno(\"mmap failed\");\n\treturn ret;\n}\n\n/*\n * With an in-core object data in \"map\", rehash it to make sure the\n * object name actually matches \"sha1\" to detect object corruption.\n * With \"map\" == NULL, try reading the object named with \"sha1\" using\n * the streaming interface and rehash it to do the same.\n */\nint check_object_signature(const struct object_id *oid, void *map,\n\t\t\t   unsigned long size, const char *type)\n{\n\tstruct object_id real_oid;\n\tenum object_type obj_type;\n\tstruct git_istream *st;\n\tgit_hash_ctx c;\n\tchar hdr[MAX_HEADER_LEN];\n\tint hdrlen;\n\n\tif (map) {\n\t\thash_object_file(map, size, type, &real_oid);\n\t\treturn oidcmp(oid, &real_oid) ? -1 : 0;\n\t}\n\n\tst = open_istream(oid, &obj_type, &size, NULL);\n\tif (!st)\n\t\treturn -1;\n\n\t/* Generate the header */\n\thdrlen = xsnprintf(hdr, sizeof(hdr), \"%s %lu\", type_name(obj_type), size) + 1;\n\n\t/* Sha1.. */\n\tthe_hash_algo->init_fn(&c);\n\tthe_hash_algo->update_fn(&c, hdr, hdrlen);\n\tfor (;;) {\n\t\tchar buf[1024 * 16];\n\t\tssize_t readlen = read_istream(st, buf, sizeof(buf));\n\n\t\tif (readlen < 0) {\n\t\t\tclose_istream(st);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!readlen)\n\t\t\tbreak;\n\t\tthe_hash_algo->update_fn(&c, buf, readlen);\n\t}\n\tthe_hash_algo->final_fn(real_oid.hash, &c);\n\tclose_istream(st);\n\treturn oidcmp(oid, &real_oid) ? -1 : 0;\n}\n\nint git_open_cloexec(const char *name, int flags)\n{\n\tint fd;\n\tstatic int o_cloexec = O_CLOEXEC;\n\n\tfd = open(name, flags | o_cloexec);\n\tif ((o_cloexec & O_CLOEXEC) && fd < 0 && errno == EINVAL) {\n\t\t/* Try again w/o O_CLOEXEC: the kernel might not support it */\n\t\to_cloexec &= ~O_CLOEXEC;\n\t\tfd = open(name, flags | o_cloexec);\n\t}\n\n#if defined(F_GETFD) && defined(F_SETFD) && defined(FD_CLOEXEC)\n\t{\n\t\tstatic int fd_cloexec = FD_CLOEXEC;\n\n\t\tif (!o_cloexec && 0 <= fd && fd_cloexec) {\n\t\t\t/* Opened w/o O_CLOEXEC?  try with fcntl(2) to add it */\n\t\t\tint flags = fcntl(fd, F_GETFD);\n\t\t\tif (fcntl(fd, F_SETFD, flags | fd_cloexec))\n\t\t\t\tfd_cloexec = 0;\n\t\t}\n\t}\n#endif\n\treturn fd;\n}\n\n/*\n * Find \"sha1\" as a loose object in the local repository or in an alternate.\n * Returns 0 on success, negative on failure.\n *\n * The \"path\" out-parameter will give the path of the object we found (if any).\n * Note that it may point to static storage and is only valid until another\n * call to sha1_file_name(), etc.\n */\nstatic int stat_sha1_file(struct repository *r, const unsigned char *sha1,\n\t\t\t  struct stat *st, const char **path)\n{\n\tstruct alternate_object_database *alt;\n\tstatic struct strbuf buf = STRBUF_INIT;\n\n\tstrbuf_reset(&buf);\n\tsha1_file_name(r, &buf, sha1);\n\t*path = buf.buf;\n\n\tif (!lstat(*path, st))\n\t\treturn 0;\n\n\tprepare_alt_odb(r);\n\terrno = ENOENT;\n\tfor (alt = r->objects->alt_odb_list; alt; alt = alt->next) {\n\t\t*path = alt_sha1_path(alt, sha1);\n\t\tif (!lstat(*path, st))\n\t\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\n/*\n * Like stat_sha1_file(), but actually open the object and return the\n * descriptor. See the caveats on the \"path\" parameter above.\n */\nstatic int open_sha1_file(struct repository *r,\n\t\t\t  const unsigned char *sha1, const char **path)\n{\n\tint fd;\n\tstruct alternate_object_database *alt;\n\tint most_interesting_errno;\n\tstatic struct strbuf buf = STRBUF_INIT;\n\n\tstrbuf_reset(&buf);\n\tsha1_file_name(r, &buf, sha1);\n\t*path = buf.buf;\n\n\tfd = git_open(*path);\n\tif (fd >= 0)\n\t\treturn fd;\n\tmost_interesting_errno = errno;\n\n\tprepare_alt_odb(r);\n\tfor (alt = r->objects->alt_odb_list; alt; alt = alt->next) {\n\t\t*path = alt_sha1_path(alt, sha1);\n\t\tfd = git_open(*path);\n\t\tif (fd >= 0)\n\t\t\treturn fd;\n\t\tif (most_interesting_errno == ENOENT)\n\t\t\tmost_interesting_errno = errno;\n\t}\n\terrno = most_interesting_errno;\n\treturn -1;\n}\n\n/*\n * Map the loose object at \"path\" if it is not NULL, or the path found by\n * searching for a loose object named \"sha1\".\n */\nstatic void *map_sha1_file_1(struct repository *r, const char *path,\n\t\t\t     const unsigned char *sha1, unsigned long *size)\n{\n\tvoid *map;\n\tint fd;\n\n\tif (path)\n\t\tfd = git_open(path);\n\telse\n\t\tfd = open_sha1_file(r, sha1, &path);\n\tmap = NULL;\n\tif (fd >= 0) {\n\t\tstruct stat st;\n\n\t\tif (!fstat(fd, &st)) {\n\t\t\t*size = xsize_t(st.st_size);\n\t\t\tif (!*size) {\n\t\t\t\t/* mmap() is forbidden on empty files */\n\t\t\t\terror(\"object file %s is empty\", path);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmap = xmmap(NULL, *size, PROT_READ, MAP_PRIVATE, fd, 0);\n\t\t}\n\t\tclose(fd);\n\t}\n\treturn map;\n}\n\nvoid *map_sha1_file(struct repository *r,\n\t\t    const unsigned char *sha1, unsigned long *size)\n{\n\treturn map_sha1_file_1(r, NULL, sha1, size);\n}\n\nstatic int unpack_sha1_short_header(git_zstream *stream,\n\t\t\t\t    unsigned char *map, unsigned long mapsize,\n\t\t\t\t    void *buffer, unsigned long bufsiz)\n{\n\t/* Get the data stream */\n\tmemset(stream, 0, sizeof(*stream));\n\tstream->next_in = map;\n\tstream->avail_in = mapsize;\n\tstream->next_out = buffer;\n\tstream->avail_out = bufsiz;\n\n\tgit_inflate_init(stream);\n\treturn git_inflate(stream, 0);\n}\n\nint unpack_sha1_header(git_zstream *stream,\n\t\t       unsigned char *map, unsigned long mapsize,\n\t\t       void *buffer, unsigned long bufsiz)\n{\n\tint status = unpack_sha1_short_header(stream, map, mapsize,\n\t\t\t\t\t      buffer, bufsiz);\n\n\tif (status < Z_OK)\n\t\treturn status;\n\n\t/* Make sure we have the terminating NUL */\n\tif (!memchr(buffer, '\\0', stream->next_out - (unsigned char *)buffer))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int unpack_sha1_header_to_strbuf(git_zstream *stream, unsigned char *map,\n\t\t\t\t\tunsigned long mapsize, void *buffer,\n\t\t\t\t\tunsigned long bufsiz, struct strbuf *header)\n{\n\tint status;\n\n\tstatus = unpack_sha1_short_header(stream, map, mapsize, buffer, bufsiz);\n\tif (status < Z_OK)\n\t\treturn -1;\n\n\t/*\n\t * Check if entire header is unpacked in the first iteration.\n\t */\n\tif (memchr(buffer, '\\0', stream->next_out - (unsigned char *)buffer))\n\t\treturn 0;\n\n\t/*\n\t * buffer[0..bufsiz] was not large enough.  Copy the partial\n\t * result out to header, and then append the result of further\n\t * reading the stream.\n\t */\n\tstrbuf_add(header, buffer, stream->next_out - (unsigned char *)buffer);\n\tstream->next_out = buffer;\n\tstream->avail_out = bufsiz;\n\n\tdo {\n\t\tstatus = git_inflate(stream, 0);\n\t\tstrbuf_add(header, buffer, stream->next_out - (unsigned char *)buffer);\n\t\tif (memchr(buffer, '\\0', stream->next_out - (unsigned char *)buffer))\n\t\t\treturn 0;\n\t\tstream->next_out = buffer;\n\t\tstream->avail_out = bufsiz;\n\t} while (status != Z_STREAM_END);\n\treturn -1;\n}\n\nstatic void *unpack_sha1_rest(git_zstream *stream, void *buffer, unsigned long size, const unsigned char *sha1)\n{\n\tint bytes = strlen(buffer) + 1;\n\tunsigned char *buf = xmallocz(size);\n\tunsigned long n;\n\tint status = Z_OK;\n\n\tn = stream->total_out - bytes;\n\tif (n > size)\n\t\tn = size;\n\tmemcpy(buf, (char *) buffer + bytes, n);\n\tbytes = n;\n\tif (bytes <= size) {\n\t\t/*\n\t\t * The above condition must be (bytes <= size), not\n\t\t * (bytes < size).  In other words, even though we\n\t\t * expect no more output and set avail_out to zero,\n\t\t * the input zlib stream may have bytes that express\n\t\t * \"this concludes the stream\", and we *do* want to\n\t\t * eat that input.\n\t\t *\n\t\t * Otherwise we would not be able to test that we\n\t\t * consumed all the input to reach the expected size;\n\t\t * we also want to check that zlib tells us that all\n\t\t * went well with status == Z_STREAM_END at the end.\n\t\t */\n\t\tstream->next_out = buf + bytes;\n\t\tstream->avail_out = size - bytes;\n\t\twhile (status == Z_OK)\n\t\t\tstatus = git_inflate(stream, Z_FINISH);\n\t}\n\tif (status == Z_STREAM_END && !stream->avail_in) {\n\t\tgit_inflate_end(stream);\n\t\treturn buf;\n\t}\n\n\tif (status < 0)\n\t\terror(\"corrupt loose object '%s'\", sha1_to_hex(sha1));\n\telse if (stream->avail_in)\n\t\terror(\"garbage at end of loose object '%s'\",\n\t\t      sha1_to_hex(sha1));\n\tfree(buf);\n\treturn NULL;\n}\n\n/*\n * We used to just use \"sscanf()\", but that's actually way\n * too permissive for what we want to check. So do an anal\n * object header parse by hand.\n */\nstatic int parse_sha1_header_extended(const char *hdr, struct object_info *oi,\n\t\t\t       unsigned int flags)\n{\n\tconst char *type_buf = hdr;\n\tunsigned long size;\n\tint type, type_len = 0;\n\n\t/*\n\t * The type can be of any size but is followed by\n\t * a space.\n\t */\n\tfor (;;) {\n\t\tchar c = *hdr++;\n\t\tif (!c)\n\t\t\treturn -1;\n\t\tif (c == ' ')\n\t\t\tbreak;\n\t\ttype_len++;\n\t}\n\n\ttype = type_from_string_gently(type_buf, type_len, 1);\n\tif (oi->type_name)\n\t\tstrbuf_add(oi->type_name, type_buf, type_len);\n\t/*\n\t * Set type to 0 if its an unknown object and\n\t * we're obtaining the type using '--allow-unknown-type'\n\t * option.\n\t */\n\tif ((flags & OBJECT_INFO_ALLOW_UNKNOWN_TYPE) && (type < 0))\n\t\ttype = 0;\n\telse if (type < 0)\n\t\tdie(\"invalid object type\");\n\tif (oi->typep)\n\t\t*oi->typep = type;\n\n\t/*\n\t * The length must follow immediately, and be in canonical\n\t * decimal format (ie \"010\" is not valid).\n\t */\n\tsize = *hdr++ - '0';\n\tif (size > 9)\n\t\treturn -1;\n\tif (size) {\n\t\tfor (;;) {\n\t\t\tunsigned long c = *hdr - '0';\n\t\t\tif (c > 9)\n\t\t\t\tbreak;\n\t\t\thdr++;\n\t\t\tsize = size * 10 + c;\n\t\t}\n\t}\n\n\tif (oi->sizep)\n\t\t*oi->sizep = size;\n\n\t/*\n\t * The length must be followed by a zero byte\n\t */\n\treturn *hdr ? -1 : type;\n}\n\nint parse_sha1_header(const char *hdr, unsigned long *sizep)\n{\n\tstruct object_info oi = OBJECT_INFO_INIT;\n\n\toi.sizep = sizep;\n\treturn parse_sha1_header_extended(hdr, &oi, 0);\n}\n\nstatic int sha1_loose_object_info(struct repository *r,\n\t\t\t\t  const unsigned char *sha1,\n\t\t\t\t  struct object_info *oi, int flags)\n{\n\tint status = 0;\n\tunsigned long mapsize;\n\tvoid *map;\n\tgit_zstream stream;\n\tchar hdr[MAX_HEADER_LEN];\n\tstruct strbuf hdrbuf = STRBUF_INIT;\n\tunsigned long size_scratch;\n\n\tif (oi->delta_base_sha1)\n\t\thashclr(oi->delta_base_sha1);\n\n\t/*\n\t * If we don't care about type or size, then we don't\n\t * need to look inside the object at all. Note that we\n\t * do not optimize out the stat call, even if the\n\t * caller doesn't care about the disk-size, since our\n\t * return value implicitly indicates whether the\n\t * object even exists.\n\t */\n\tif (!oi->typep && !oi->type_name && !oi->sizep && !oi->contentp) {\n\t\tconst char *path;\n\t\tstruct stat st;\n\t\tif (stat_sha1_file(r, sha1, &st, &path) < 0)\n\t\t\treturn -1;\n\t\tif (oi->disk_sizep)\n\t\t\t*oi->disk_sizep = st.st_size;\n\t\treturn 0;\n\t}\n\n\tmap = map_sha1_file(r, sha1, &mapsize);\n\tif (!map)\n\t\treturn -1;\n\n\tif (!oi->sizep)\n\t\toi->sizep = &size_scratch;\n\n\tif (oi->disk_sizep)\n\t\t*oi->disk_sizep = mapsize;\n\tif ((flags & OBJECT_INFO_ALLOW_UNKNOWN_TYPE)) {\n\t\tif (unpack_sha1_header_to_strbuf(&stream, map, mapsize, hdr, sizeof(hdr), &hdrbuf) < 0)\n\t\t\tstatus = error(\"unable to unpack %s header with --allow-unknown-type\",\n\t\t\t\t       sha1_to_hex(sha1));\n\t} else if (unpack_sha1_header(&stream, map, mapsize, hdr, sizeof(hdr)) < 0)\n\t\tstatus = error(\"unable to unpack %s header\",\n\t\t\t       sha1_to_hex(sha1));\n\tif (status < 0)\n\t\t; /* Do nothing */\n\telse if (hdrbuf.len) {\n\t\tif ((status = parse_sha1_header_extended(hdrbuf.buf, oi, flags)) < 0)\n\t\t\tstatus = error(\"unable to parse %s header with --allow-unknown-type\",\n\t\t\t\t       sha1_to_hex(sha1));\n\t} else if ((status = parse_sha1_header_extended(hdr, oi, flags)) < 0)\n\t\tstatus = error(\"unable to parse %s header\", sha1_to_hex(sha1));\n\n\tif (status >= 0 && oi->contentp) {\n\t\t*oi->contentp = unpack_sha1_rest(&stream, hdr,\n\t\t\t\t\t\t *oi->sizep, sha1);\n\t\tif (!*oi->contentp) {\n\t\t\tgit_inflate_end(&stream);\n\t\t\tstatus = -1;\n\t\t}\n\t} else\n\t\tgit_inflate_end(&stream);\n\n\tmunmap(map, mapsize);\n\tif (status && oi->typep)\n\t\t*oi->typep = status;\n\tif (oi->sizep == &size_scratch)\n\t\toi->sizep = NULL;\n\tstrbuf_release(&hdrbuf);\n\toi->whence = OI_LOOSE;\n\treturn (status < 0) ? status : 0;\n}\n\nint fetch_if_missing = 1;\n\nint oid_object_info_extended(struct repository *r, const struct object_id *oid,\n\t\t\t     struct object_info *oi, unsigned flags)\n{\n\tstatic struct object_info blank_oi = OBJECT_INFO_INIT;\n\tstruct pack_entry e;\n\tint rtype;\n\tconst struct object_id *real = oid;\n\tint already_retried = 0;\n\n\tif (flags & OBJECT_INFO_LOOKUP_REPLACE)\n\t\treal = lookup_replace_object(r, oid);\n\n\tif (is_null_oid(real))\n\t\treturn -1;\n\n\tif (!oi)\n\t\toi = &blank_oi;\n\n\tif (!(flags & OBJECT_INFO_SKIP_CACHED)) {\n\t\tstruct cached_object *co = find_cached_object(real);\n\t\tif (co) {\n\t\t\tif (oi->typep)\n\t\t\t\t*(oi->typep) = co->type;\n\t\t\tif (oi->sizep)\n\t\t\t\t*(oi->sizep) = co->size;\n\t\t\tif (oi->disk_sizep)\n\t\t\t\t*(oi->disk_sizep) = 0;\n\t\t\tif (oi->delta_base_sha1)\n\t\t\t\thashclr(oi->delta_base_sha1);\n\t\t\tif (oi->type_name)\n\t\t\t\tstrbuf_addstr(oi->type_name, type_name(co->type));\n\t\t\tif (oi->contentp)\n\t\t\t\t*oi->contentp = xmemdupz(co->buf, co->size);\n\t\t\toi->whence = OI_CACHED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tif (find_pack_entry(r, real, &e))\n\t\t\tbreak;\n\n\t\tif (flags & OBJECT_INFO_IGNORE_LOOSE)\n\t\t\treturn -1;\n\n\t\t/* Most likely it's a loose object. */\n\t\tif (!sha1_loose_object_info(r, real->hash, oi, flags))\n\t\t\treturn 0;\n\n\t\t/* Not a loose object; someone else may have just packed it. */\n\t\tif (!(flags & OBJECT_INFO_QUICK)) {\n\t\t\treprepare_packed_git(r);\n\t\t\tif (find_pack_entry(r, real, &e))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Check if it is a missing object */\n\t\tif (fetch_if_missing && repository_format_partial_clone &&\n\t\t    !already_retried && r == the_repository) {\n\t\t\t/*\n\t\t\t * TODO Investigate having fetch_object() return\n\t\t\t * TODO error/success and stopping the music here.\n\t\t\t * TODO Pass a repository struct through fetch_object,\n\t\t\t * such that arbitrary repositories work.\n\t\t\t */\n\t\t\tfetch_object(repository_format_partial_clone, real->hash);\n\t\t\talready_retried = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tif (oi == &blank_oi)\n\t\t/*\n\t\t * We know that the caller doesn't actually need the\n\t\t * information below, so return early.\n\t\t */\n\t\treturn 0;\n\trtype = packed_object_info(r, e.p, e.offset, oi);\n\tif (rtype < 0) {\n\t\tmark_bad_packed_object(e.p, real->hash);\n\t\treturn oid_object_info_extended(r, real, oi, 0);\n\t} else if (oi->whence == OI_PACKED) {\n\t\toi->u.packed.offset = e.offset;\n\t\toi->u.packed.pack = e.p;\n\t\toi->u.packed.is_delta = (rtype == OBJ_REF_DELTA ||\n\t\t\t\t\t rtype == OBJ_OFS_DELTA);\n\t}\n\n\treturn 0;\n}\n\n/* returns enum object_type or negative */\nint oid_object_info(struct repository *r,\n\t\t    const struct object_id *oid,\n\t\t    unsigned long *sizep)\n{\n\tenum object_type type;\n\tstruct object_info oi = OBJECT_INFO_INIT;\n\n\toi.typep = &type;\n\toi.sizep = sizep;\n\tif (oid_object_info_extended(r, oid, &oi,\n\t\t\t\t      OBJECT_INFO_LOOKUP_REPLACE) < 0)\n\t\treturn -1;\n\treturn type;\n}\n\nstatic void *read_object(const unsigned char *sha1, enum object_type *type,\n\t\t\t unsigned long *size)\n{\n\tstruct object_id oid;\n\tstruct object_info oi = OBJECT_INFO_INIT;\n\tvoid *content;\n\toi.typep = type;\n\toi.sizep = size;\n\toi.contentp = &content;\n\n\thashcpy(oid.hash, sha1);\n\n\tif (oid_object_info_extended(the_repository, &oid, &oi, 0) < 0)\n\t\treturn NULL;\n\treturn content;\n}\n\nint pretend_object_file(void *buf, unsigned long len, enum object_type type,\n\t\t\tstruct object_id *oid)\n{\n\tstruct cached_object *co;\n\n\thash_object_file(buf, len, type_name(type), oid);\n\tif (has_sha1_file(oid->hash) || find_cached_object(oid))\n\t\treturn 0;\n\tALLOC_GROW(cached_objects, cached_object_nr + 1, cached_object_alloc);\n\tco = &cached_objects[cached_object_nr++];\n\tco->size = len;\n\tco->type = type;\n\tco->buf = xmalloc(len);\n\tmemcpy(co->buf, buf, len);\n\toidcpy(&co->oid, oid);\n\treturn 0;\n}\n\n/*\n * This function dies on corrupt objects; the callers who want to\n * deal with them should arrange to call read_object() and give error\n * messages themselves.\n */\nvoid *read_object_file_extended(const struct object_id *oid,\n\t\t\t\tenum object_type *type,\n\t\t\t\tunsigned long *size,\n\t\t\t\tint lookup_replace)\n{\n\tvoid *data;\n\tconst struct packed_git *p;\n\tconst char *path;\n\tstruct stat st;\n\tconst struct object_id *repl = lookup_replace ?\n\t\tlookup_replace_object(the_repository, oid) : oid;\n\n\terrno = 0;\n\tdata = read_object(repl->hash, type, size);\n\tif (data)\n\t\treturn data;\n\n\tif (errno && errno != ENOENT)\n\t\tdie_errno(\"failed to read object %s\", oid_to_hex(oid));\n\n\t/* die if we replaced an object with one that does not exist */\n\tif (repl != oid)\n\t\tdie(\"replacement %s not found for %s\",\n\t\t    oid_to_hex(repl), oid_to_hex(oid));\n\n\tif (!stat_sha1_file(the_repository, repl->hash, &st, &path))\n\t\tdie(\"loose object %s (stored in %s) is corrupt\",\n\t\t    oid_to_hex(repl), path);\n\n\tif ((p = has_packed_and_bad(repl->hash)) != NULL)\n\t\tdie(\"packed object %s (stored in %s) is corrupt\",\n\t\t    oid_to_hex(repl), p->pack_name);\n\n\treturn NULL;\n}\n\nvoid *read_object_with_reference(const struct object_id *oid,\n\t\t\t\t const char *required_type_name,\n\t\t\t\t unsigned long *size,\n\t\t\t\t struct object_id *actual_oid_return)\n{\n\tenum object_type type, required_type;\n\tvoid *buffer;\n\tunsigned long isize;\n\tstruct object_id actual_oid;\n\n\trequired_type = type_from_string(required_type_name);\n\toidcpy(&actual_oid, oid);\n\twhile (1) {\n\t\tint ref_length = -1;\n\t\tconst char *ref_type = NULL;\n\n\t\tbuffer = read_object_file(&actual_oid, &type, &isize);\n\t\tif (!buffer)\n\t\t\treturn NULL;\n\t\tif (type == required_type) {\n\t\t\t*size = isize;\n\t\t\tif (actual_oid_return)\n\t\t\t\toidcpy(actual_oid_return, &actual_oid);\n\t\t\treturn buffer;\n\t\t}\n\t\t/* Handle references */\n\t\telse if (type == OBJ_COMMIT)\n\t\t\tref_type = \"tree \";\n\t\telse if (type == OBJ_TAG)\n\t\t\tref_type = \"object \";\n\t\telse {\n\t\t\tfree(buffer);\n\t\t\treturn NULL;\n\t\t}\n\t\tref_length = strlen(ref_type);\n\n\t\tif (ref_length + the_hash_algo->hexsz > isize ||\n\t\t    memcmp(buffer, ref_type, ref_length) ||\n\t\t    get_oid_hex((char *) buffer + ref_length, &actual_oid)) {\n\t\t\tfree(buffer);\n\t\t\treturn NULL;\n\t\t}\n\t\tfree(buffer);\n\t\t/* Now we have the ID of the referred-to object in\n\t\t * actual_oid.  Check again. */\n\t}\n}\n\nstatic void write_object_file_prepare(const void *buf, unsigned long len,\n\t\t\t\t      const char *type, struct object_id *oid,\n\t\t\t\t      char *hdr, int *hdrlen)\n{\n\tgit_hash_ctx c;\n\n\t/* Generate the header */\n\t*hdrlen = xsnprintf(hdr, *hdrlen, \"%s %lu\", type, len)+1;\n\n\t/* Sha1.. */\n\tthe_hash_algo->init_fn(&c);\n\tthe_hash_algo->update_fn(&c, hdr, *hdrlen);\n\tthe_hash_algo->update_fn(&c, buf, len);\n\tthe_hash_algo->final_fn(oid->hash, &c);\n}\n\n/*\n * Move the just written object into its final resting place.\n */\nint finalize_object_file(const char *tmpfile, const char *filename)\n{\n\tint ret = 0;\n\n\tif (object_creation_mode == OBJECT_CREATION_USES_RENAMES)\n\t\tgoto try_rename;\n\telse if (link(tmpfile, filename))\n\t\tret = errno;\n\n\t/*\n\t * Coda hack - coda doesn't like cross-directory links,\n\t * so we fall back to a rename, which will mean that it\n\t * won't be able to check collisions, but that's not a\n\t * big deal.\n\t *\n\t * The same holds for FAT formatted media.\n\t *\n\t * When this succeeds, we just return.  We have nothing\n\t * left to unlink.\n\t */\n\tif (ret && ret != EEXIST) {\n\ttry_rename:\n\t\tif (!rename(tmpfile, filename))\n\t\t\tgoto out;\n\t\tret = errno;\n\t}\n\tunlink_or_warn(tmpfile);\n\tif (ret) {\n\t\tif (ret != EEXIST) {\n\t\t\treturn error_errno(\"unable to write sha1 filename %s\", filename);\n\t\t}\n\t\t/* FIXME!!! Collision check here ? */\n\t}\n\nout:\n\tif (adjust_shared_perm(filename))\n\t\treturn error(\"unable to set permission to '%s'\", filename);\n\treturn 0;\n}\n\nstatic int write_buffer(int fd, const void *buf, size_t len)\n{\n\tif (write_in_full(fd, buf, len) < 0)\n\t\treturn error_errno(\"file write error\");\n\treturn 0;\n}\n\nint hash_object_file(const void *buf, unsigned long len, const char *type,\n\t\t     struct object_id *oid)\n{\n\tchar hdr[MAX_HEADER_LEN];\n\tint hdrlen = sizeof(hdr);\n\twrite_object_file_prepare(buf, len, type, oid, hdr, &hdrlen);\n\treturn 0;\n}\n\n/* Finalize a file on disk, and close it. */\nstatic void close_sha1_file(int fd)\n{\n\tif (fsync_object_files)\n\t\tfsync_or_die(fd, \"sha1 file\");\n\tif (close(fd) != 0)\n\t\tdie_errno(\"error when closing sha1 file\");\n}\n\n/* Size of directory component, including the ending '/' */\nstatic inline int directory_size(const char *filename)\n{\n\tconst char *s = strrchr(filename, '/');\n\tif (!s)\n\t\treturn 0;\n\treturn s - filename + 1;\n}\n\n/*\n * This creates a temporary file in the same directory as the final\n * 'filename'\n *\n * We want to avoid cross-directory filename renames, because those\n * can have problems on various filesystems (FAT, NFS, Coda).\n */\nstatic int create_tmpfile(struct strbuf *tmp, const char *filename)\n{\n\tint fd, dirlen = directory_size(filename);\n\n\tstrbuf_reset(tmp);\n\tstrbuf_add(tmp, filename, dirlen);\n\tstrbuf_addstr(tmp, \"tmp_obj_XXXXXX\");\n\tfd = git_mkstemp_mode(tmp->buf, 0444);\n\tif (fd < 0 && dirlen && errno == ENOENT) {\n\t\t/*\n\t\t * Make sure the directory exists; note that the contents\n\t\t * of the buffer are undefined after mkstemp returns an\n\t\t * error, so we have to rewrite the whole buffer from\n\t\t * scratch.\n\t\t */\n\t\tstrbuf_reset(tmp);\n\t\tstrbuf_add(tmp, filename, dirlen - 1);\n\t\tif (mkdir(tmp->buf, 0777) && errno != EEXIST)\n\t\t\treturn -1;\n\t\tif (adjust_shared_perm(tmp->buf))\n\t\t\treturn -1;\n\n\t\t/* Try again */\n\t\tstrbuf_addstr(tmp, \"/tmp_obj_XXXXXX\");\n\t\tfd = git_mkstemp_mode(tmp->buf, 0444);\n\t}\n\treturn fd;\n}\n\nstatic int write_loose_object(const struct object_id *oid, char *hdr,\n\t\t\t      int hdrlen, const void *buf, unsigned long len,\n\t\t\t      time_t mtime)\n{\n\tint fd, ret;\n\tunsigned char compressed[4096];\n\tgit_zstream stream;\n\tgit_hash_ctx c;\n\tstruct object_id parano_oid;\n\tstatic struct strbuf tmp_file = STRBUF_INIT;\n\tstatic struct strbuf filename = STRBUF_INIT;\n\n\tstrbuf_reset(&filename);\n\tsha1_file_name(the_repository, &filename, oid->hash);\n\n\tfd = create_tmpfile(&tmp_file, filename.buf);\n\tif (fd < 0) {\n\t\tif (errno == EACCES)\n\t\t\treturn error(\"insufficient permission for adding an object to repository database %s\", get_object_directory());\n\t\telse\n\t\t\treturn error_errno(\"unable to create temporary file\");\n\t}\n\n\t/* Set it up */\n\tgit_deflate_init(&stream, zlib_compression_level);\n\tstream.next_out = compressed;\n\tstream.avail_out = sizeof(compressed);\n\tthe_hash_algo->init_fn(&c);\n\n\t/* First header.. */\n\tstream.next_in = (unsigned char *)hdr;\n\tstream.avail_in = hdrlen;\n\twhile (git_deflate(&stream, 0) == Z_OK)\n\t\t; /* nothing */\n\tthe_hash_algo->update_fn(&c, hdr, hdrlen);\n\n\t/* Then the data itself.. */\n\tstream.next_in = (void *)buf;\n\tstream.avail_in = len;\n\tdo {\n\t\tunsigned char *in0 = stream.next_in;\n\t\tret = git_deflate(&stream, Z_FINISH);\n\t\tthe_hash_algo->update_fn(&c, in0, stream.next_in - in0);\n\t\tif (write_buffer(fd, compressed, stream.next_out - compressed) < 0)\n\t\t\tdie(\"unable to write sha1 file\");\n\t\tstream.next_out = compressed;\n\t\tstream.avail_out = sizeof(compressed);\n\t} while (ret == Z_OK);\n\n\tif (ret != Z_STREAM_END)\n\t\tdie(\"unable to deflate new object %s (%d)\", oid_to_hex(oid),\n\t\t    ret);\n\tret = git_deflate_end_gently(&stream);\n\tif (ret != Z_OK)\n\t\tdie(\"deflateEnd on object %s failed (%d)\", oid_to_hex(oid),\n\t\t    ret);\n\tthe_hash_algo->final_fn(parano_oid.hash, &c);\n\tif (oidcmp(oid, &parano_oid) != 0)\n\t\tdie(\"confused by unstable object source data for %s\",\n\t\t    oid_to_hex(oid));\n\n\tclose_sha1_file(fd);\n\n\tif (mtime) {\n\t\tstruct utimbuf utb;\n\t\tutb.actime = mtime;\n\t\tutb.modtime = mtime;\n\t\tif (utime(tmp_file.buf, &utb) < 0)\n\t\t\twarning_errno(\"failed utime() on %s\", tmp_file.buf);\n\t}\n\n\treturn finalize_object_file(tmp_file.buf, filename.buf);\n}\n\nstatic int freshen_loose_object(const struct object_id *oid)\n{\n\treturn check_and_freshen(oid, 1);\n}\n\nstatic int freshen_packed_object(const struct object_id *oid)\n{\n\tstruct pack_entry e;\n\tif (!find_pack_entry(the_repository, oid, &e))\n\t\treturn 0;\n\tif (e.p->freshened)\n\t\treturn 1;\n\tif (!freshen_file(e.p->pack_name))\n\t\treturn 0;\n\te.p->freshened = 1;\n\treturn 1;\n}\n\nint write_object_file(const void *buf, unsigned long len, const char *type,\n\t\t      struct object_id *oid)\n{\n\tchar hdr[MAX_HEADER_LEN];\n\tint hdrlen = sizeof(hdr);\n\n\t/* Normally if we have it in the pack then we do not bother writing\n\t * it out into .git/objects/??/?{38} file.\n\t */\n\twrite_object_file_prepare(buf, len, type, oid, hdr, &hdrlen);\n\tif (freshen_packed_object(oid) || freshen_loose_object(oid))\n\t\treturn 0;\n\treturn write_loose_object(oid, hdr, hdrlen, buf, len, 0);\n}\n\nint hash_object_file_literally(const void *buf, unsigned long len,\n\t\t\t       const char *type, struct object_id *oid,\n\t\t\t       unsigned flags)\n{\n\tchar *header;\n\tint hdrlen, status = 0;\n\n\t/* type string, SP, %lu of the length plus NUL must fit this */\n\thdrlen = strlen(type) + MAX_HEADER_LEN;\n\theader = xmalloc(hdrlen);\n\twrite_object_file_prepare(buf, len, type, oid, header, &hdrlen);\n\n\tif (!(flags & HASH_WRITE_OBJECT))\n\t\tgoto cleanup;\n\tif (freshen_packed_object(oid) || freshen_loose_object(oid))\n\t\tgoto cleanup;\n\tstatus = write_loose_object(oid, header, hdrlen, buf, len, 0);\n\ncleanup:\n\tfree(header);\n\treturn status;\n}\n\nint force_object_loose(const struct object_id *oid, time_t mtime)\n{\n\tvoid *buf;\n\tunsigned long len;\n\tenum object_type type;\n\tchar hdr[MAX_HEADER_LEN];\n\tint hdrlen;\n\tint ret;\n\n\tif (has_loose_object(oid))\n\t\treturn 0;\n\tbuf = read_object(oid->hash, &type, &len);\n\tif (!buf)\n\t\treturn error(\"cannot read sha1_file for %s\", oid_to_hex(oid));\n\thdrlen = xsnprintf(hdr, sizeof(hdr), \"%s %lu\", type_name(type), len) + 1;\n\tret = write_loose_object(oid, hdr, hdrlen, buf, len, mtime);\n\tfree(buf);\n\n\treturn ret;\n}\n\nint has_sha1_file_with_flags(const unsigned char *sha1, int flags)\n{\n\tstruct object_id oid;\n\tif (!startup_info->have_repository)\n\t\treturn 0;\n\thashcpy(oid.hash, sha1);\n\treturn oid_object_info_extended(the_repository, &oid, NULL,\n\t\t\t\t\tflags | OBJECT_INFO_SKIP_CACHED) >= 0;\n}\n\nint has_object_file(const struct object_id *oid)\n{\n\treturn has_sha1_file(oid->hash);\n}\n\nint has_object_file_with_flags(const struct object_id *oid, int flags)\n{\n\treturn has_sha1_file_with_flags(oid->hash, flags);\n}\n\nstatic void check_tree(const void *buf, size_t size)\n{\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\n\tinit_tree_desc(&desc, buf, size);\n\twhile (tree_entry(&desc, &entry))\n\t\t/* do nothing\n\t\t * tree_entry() will die() on malformed entries */\n\t\t;\n}\n\nstatic void check_commit(const void *buf, size_t size)\n{\n\tstruct commit c;\n\tmemset(&c, 0, sizeof(c));\n\tif (parse_commit_buffer(the_repository, &c, buf, size, 0))\n\t\tdie(\"corrupt commit\");\n}\n\nstatic void check_tag(const void *buf, size_t size)\n{\n\tstruct tag t;\n\tmemset(&t, 0, sizeof(t));\n\tif (parse_tag_buffer(the_repository, &t, buf, size))\n\t\tdie(\"corrupt tag\");\n}\n\nstatic int index_mem(struct object_id *oid, void *buf, size_t size,\n\t\t     enum object_type type,\n\t\t     const char *path, unsigned flags)\n{\n\tint ret, re_allocated = 0;\n\tint write_object = flags & HASH_WRITE_OBJECT;\n\n\tif (!type)\n\t\ttype = OBJ_BLOB;\n\n\t/*\n\t * Convert blobs to git internal format\n\t */\n\tif ((type == OBJ_BLOB) && path) {\n\t\tstruct strbuf nbuf = STRBUF_INIT;\n\t\tif (convert_to_git(&the_index, path, buf, size, &nbuf,\n\t\t\t\t   get_conv_flags(flags))) {\n\t\t\tbuf = strbuf_detach(&nbuf, &size);\n\t\t\tre_allocated = 1;\n\t\t}\n\t}\n\tif (flags & HASH_FORMAT_CHECK) {\n\t\tif (type == OBJ_TREE)\n\t\t\tcheck_tree(buf, size);\n\t\tif (type == OBJ_COMMIT)\n\t\t\tcheck_commit(buf, size);\n\t\tif (type == OBJ_TAG)\n\t\t\tcheck_tag(buf, size);\n\t}\n\n\tif (write_object)\n\t\tret = write_object_file(buf, size, type_name(type), oid);\n\telse\n\t\tret = hash_object_file(buf, size, type_name(type), oid);\n\tif (re_allocated)\n\t\tfree(buf);\n\treturn ret;\n}\n\nstatic int index_stream_convert_blob(struct object_id *oid, int fd,\n\t\t\t\t     const char *path, unsigned flags)\n{\n\tint ret;\n\tconst int write_object = flags & HASH_WRITE_OBJECT;\n\tstruct strbuf sbuf = STRBUF_INIT;\n\n\tassert(path);\n\tassert(would_convert_to_git_filter_fd(&the_index, path));\n\n\tconvert_to_git_filter_fd(&the_index, path, fd, &sbuf,\n\t\t\t\t get_conv_flags(flags));\n\n\tif (write_object)\n\t\tret = write_object_file(sbuf.buf, sbuf.len, type_name(OBJ_BLOB),\n\t\t\t\t\toid);\n\telse\n\t\tret = hash_object_file(sbuf.buf, sbuf.len, type_name(OBJ_BLOB),\n\t\t\t\t       oid);\n\tstrbuf_release(&sbuf);\n\treturn ret;\n}\n\nstatic int index_pipe(struct object_id *oid, int fd, enum object_type type,\n\t\t      const char *path, unsigned flags)\n{\n\tstruct strbuf sbuf = STRBUF_INIT;\n\tint ret;\n\n\tif (strbuf_read(&sbuf, fd, 4096) >= 0)\n\t\tret = index_mem(oid, sbuf.buf, sbuf.len, type, path, flags);\n\telse\n\t\tret = -1;\n\tstrbuf_release(&sbuf);\n\treturn ret;\n}\n\n#define SMALL_FILE_SIZE (32*1024)\n\nstatic int index_core(struct object_id *oid, int fd, size_t size,\n\t\t      enum object_type type, const char *path,\n\t\t      unsigned flags)\n{\n\tint ret;\n\n\tif (!size) {\n\t\tret = index_mem(oid, \"\", size, type, path, flags);\n\t} else if (size <= SMALL_FILE_SIZE) {\n\t\tchar *buf = xmalloc(size);\n\t\tssize_t read_result = read_in_full(fd, buf, size);\n\t\tif (read_result < 0)\n\t\t\tret = error_errno(\"read error while indexing %s\",\n\t\t\t\t\t  path ? path : \"<unknown>\");\n\t\telse if (read_result != size)\n\t\t\tret = error(\"short read while indexing %s\",\n\t\t\t\t    path ? path : \"<unknown>\");\n\t\telse\n\t\t\tret = index_mem(oid, buf, size, type, path, flags);\n\t\tfree(buf);\n\t} else {\n\t\tvoid *buf = xmmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);\n\t\tret = index_mem(oid, buf, size, type, path, flags);\n\t\tmunmap(buf, size);\n\t}\n\treturn ret;\n}\n\n/*\n * This creates one packfile per large blob unless bulk-checkin\n * machinery is \"plugged\".\n *\n * This also bypasses the usual \"convert-to-git\" dance, and that is on\n * purpose. We could write a streaming version of the converting\n * functions and insert that before feeding the data to fast-import\n * (or equivalent in-core API described above). However, that is\n * somewhat complicated, as we do not know the size of the filter\n * result, which we need to know beforehand when writing a git object.\n * Since the primary motivation for trying to stream from the working\n * tree file and to avoid mmaping it in core is to deal with large\n * binary blobs, they generally do not want to get any conversion, and\n * callers should avoid this code path when filters are requested.\n */\nstatic int index_stream(struct object_id *oid, int fd, size_t size,\n\t\t\tenum object_type type, const char *path,\n\t\t\tunsigned flags)\n{\n\treturn index_bulk_checkin(oid, fd, size, type, path, flags);\n}\n\nint index_fd(struct object_id *oid, int fd, struct stat *st,\n\t     enum object_type type, const char *path, unsigned flags)\n{\n\tint ret;\n\n\t/*\n\t * Call xsize_t() only when needed to avoid potentially unnecessary\n\t * die() for large files.\n\t */\n\tif (type == OBJ_BLOB && path && would_convert_to_git_filter_fd(&the_index, path))\n\t\tret = index_stream_convert_blob(oid, fd, path, flags);\n\telse if (!S_ISREG(st->st_mode))\n\t\tret = index_pipe(oid, fd, type, path, flags);\n\telse if (st->st_size <= big_file_threshold || type != OBJ_BLOB ||\n\t\t (path && would_convert_to_git(&the_index, path)))\n\t\tret = index_core(oid, fd, xsize_t(st->st_size), type, path,\n\t\t\t\t flags);\n\telse\n\t\tret = index_stream(oid, fd, xsize_t(st->st_size), type, path,\n\t\t\t\t   flags);\n\tclose(fd);\n\treturn ret;\n}\n\nint index_path(struct object_id *oid, const char *path, struct stat *st, unsigned flags)\n{\n\tint fd;\n\tstruct strbuf sb = STRBUF_INIT;\n\tint rc = 0;\n\n\tswitch (st->st_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tfd = open(path, O_RDONLY);\n\t\tif (fd < 0)\n\t\t\treturn error_errno(\"open(\\\"%s\\\")\", path);\n\t\tif (index_fd(oid, fd, st, OBJ_BLOB, path, flags) < 0)\n\t\t\treturn error(\"%s: failed to insert into database\",\n\t\t\t\t     path);\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (strbuf_readlink(&sb, path, st->st_size))\n\t\t\treturn error_errno(\"readlink(\\\"%s\\\")\", path);\n\t\tif (!(flags & HASH_WRITE_OBJECT))\n\t\t\thash_object_file(sb.buf, sb.len, blob_type, oid);\n\t\telse if (write_object_file(sb.buf, sb.len, blob_type, oid))\n\t\t\trc = error(\"%s: failed to insert into database\", path);\n\t\tstrbuf_release(&sb);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\treturn resolve_gitlink_ref(path, \"HEAD\", oid);\n\tdefault:\n\t\treturn error(\"%s: unsupported file type\", path);\n\t}\n\treturn rc;\n}\n\nint read_pack_header(int fd, struct pack_header *header)\n{\n\tif (read_in_full(fd, header, sizeof(*header)) != sizeof(*header))\n\t\t/* \"eof before pack header was fully read\" */\n\t\treturn PH_ERROR_EOF;\n\n\tif (header->hdr_signature != htonl(PACK_SIGNATURE))\n\t\t/* \"protocol error (pack signature mismatch detected)\" */\n\t\treturn PH_ERROR_PACK_SIGNATURE;\n\tif (!pack_version_ok(header->hdr_version))\n\t\t/* \"protocol error (pack version unsupported)\" */\n\t\treturn PH_ERROR_PROTOCOL;\n\treturn 0;\n}\n\nvoid assert_oid_type(const struct object_id *oid, enum object_type expect)\n{\n\tenum object_type type = oid_object_info(the_repository, oid, NULL);\n\tif (type < 0)\n\t\tdie(\"%s is not a valid object\", oid_to_hex(oid));\n\tif (type != expect)\n\t\tdie(\"%s is not a valid '%s' object\", oid_to_hex(oid),\n\t\t    type_name(expect));\n}\n\nint for_each_file_in_obj_subdir(unsigned int subdir_nr,\n\t\t\t\tstruct strbuf *path,\n\t\t\t\teach_loose_object_fn obj_cb,\n\t\t\t\teach_loose_cruft_fn cruft_cb,\n\t\t\t\teach_loose_subdir_fn subdir_cb,\n\t\t\t\tvoid *data)\n{\n\tsize_t origlen, baselen;\n\tDIR *dir;\n\tstruct dirent *de;\n\tint r = 0;\n\tstruct object_id oid;\n\n\tif (subdir_nr > 0xff)\n\t\tBUG(\"invalid loose object subdirectory: %x\", subdir_nr);\n\n\toriglen = path->len;\n\tstrbuf_complete(path, '/');\n\tstrbuf_addf(path, \"%02x\", subdir_nr);\n\n\tdir = opendir(path->buf);\n\tif (!dir) {\n\t\tif (errno != ENOENT)\n\t\t\tr = error_errno(\"unable to open %s\", path->buf);\n\t\tstrbuf_setlen(path, origlen);\n\t\treturn r;\n\t}\n\n\toid.hash[0] = subdir_nr;\n\tstrbuf_addch(path, '/');\n\tbaselen = path->len;\n\n\twhile ((de = readdir(dir))) {\n\t\tsize_t namelen;\n\t\tif (is_dot_or_dotdot(de->d_name))\n\t\t\tcontinue;\n\n\t\tnamelen = strlen(de->d_name);\n\t\tstrbuf_setlen(path, baselen);\n\t\tstrbuf_add(path, de->d_name, namelen);\n\t\tif (namelen == the_hash_algo->hexsz - 2 &&\n\t\t    !hex_to_bytes(oid.hash + 1, de->d_name,\n\t\t\t\t  the_hash_algo->rawsz - 1)) {\n\t\t\tif (obj_cb) {\n\t\t\t\tr = obj_cb(&oid, path->buf, data);\n\t\t\t\tif (r)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cruft_cb) {\n\t\t\tr = cruft_cb(de->d_name, path->buf, data);\n\t\t\tif (r)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tclosedir(dir);\n\n\tstrbuf_setlen(path, baselen - 1);\n\tif (!r && subdir_cb)\n\t\tr = subdir_cb(subdir_nr, path->buf, data);\n\n\tstrbuf_setlen(path, origlen);\n\n\treturn r;\n}\n\nint for_each_loose_file_in_objdir_buf(struct strbuf *path,\n\t\t\t    each_loose_object_fn obj_cb,\n\t\t\t    each_loose_cruft_fn cruft_cb,\n\t\t\t    each_loose_subdir_fn subdir_cb,\n\t\t\t    void *data)\n{\n\tint r = 0;\n\tint i;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tr = for_each_file_in_obj_subdir(i, path, obj_cb, cruft_cb,\n\t\t\t\t\t\tsubdir_cb, data);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nint for_each_loose_file_in_objdir(const char *path,\n\t\t\t\t  each_loose_object_fn obj_cb,\n\t\t\t\t  each_loose_cruft_fn cruft_cb,\n\t\t\t\t  each_loose_subdir_fn subdir_cb,\n\t\t\t\t  void *data)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tint r;\n\n\tstrbuf_addstr(&buf, path);\n\tr = for_each_loose_file_in_objdir_buf(&buf, obj_cb, cruft_cb,\n\t\t\t\t\t      subdir_cb, data);\n\tstrbuf_release(&buf);\n\n\treturn r;\n}\n\nstruct loose_alt_odb_data {\n\teach_loose_object_fn *cb;\n\tvoid *data;\n};\n\nstatic int loose_from_alt_odb(struct alternate_object_database *alt,\n\t\t\t      void *vdata)\n{\n\tstruct loose_alt_odb_data *data = vdata;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint r;\n\n\tstrbuf_addstr(&buf, alt->path);\n\tr = for_each_loose_file_in_objdir_buf(&buf,\n\t\t\t\t\t      data->cb, NULL, NULL,\n\t\t\t\t\t      data->data);\n\tstrbuf_release(&buf);\n\treturn r;\n}\n\nint for_each_loose_object(each_loose_object_fn cb, void *data, unsigned flags)\n{\n\tstruct loose_alt_odb_data alt;\n\tint r;\n\n\tr = for_each_loose_file_in_objdir(get_object_directory(),\n\t\t\t\t\t  cb, NULL, NULL, data);\n\tif (r)\n\t\treturn r;\n\n\tif (flags & FOR_EACH_OBJECT_LOCAL_ONLY)\n\t\treturn 0;\n\n\talt.cb = cb;\n\talt.data = data;\n\treturn foreach_alt_odb(loose_from_alt_odb, &alt);\n}\n\nstatic int check_stream_sha1(git_zstream *stream,\n\t\t\t     const char *hdr,\n\t\t\t     unsigned long size,\n\t\t\t     const char *path,\n\t\t\t     const unsigned char *expected_sha1)\n{\n\tgit_hash_ctx c;\n\tunsigned char real_sha1[GIT_MAX_RAWSZ];\n\tunsigned char buf[4096];\n\tunsigned long total_read;\n\tint status = Z_OK;\n\n\tthe_hash_algo->init_fn(&c);\n\tthe_hash_algo->update_fn(&c, hdr, stream->total_out);\n\n\t/*\n\t * We already read some bytes into hdr, but the ones up to the NUL\n\t * do not count against the object's content size.\n\t */\n\ttotal_read = stream->total_out - strlen(hdr) - 1;\n\n\t/*\n\t * This size comparison must be \"<=\" to read the final zlib packets;\n\t * see the comment in unpack_sha1_rest for details.\n\t */\n\twhile (total_read <= size &&\n\t       (status == Z_OK || status == Z_BUF_ERROR)) {\n\t\tstream->next_out = buf;\n\t\tstream->avail_out = sizeof(buf);\n\t\tif (size - total_read < stream->avail_out)\n\t\t\tstream->avail_out = size - total_read;\n\t\tstatus = git_inflate(stream, Z_FINISH);\n\t\tthe_hash_algo->update_fn(&c, buf, stream->next_out - buf);\n\t\ttotal_read += stream->next_out - buf;\n\t}\n\tgit_inflate_end(stream);\n\n\tif (status != Z_STREAM_END) {\n\t\terror(\"corrupt loose object '%s'\", sha1_to_hex(expected_sha1));\n\t\treturn -1;\n\t}\n\tif (stream->avail_in) {\n\t\terror(\"garbage at end of loose object '%s'\",\n\t\t      sha1_to_hex(expected_sha1));\n\t\treturn -1;\n\t}\n\n\tthe_hash_algo->final_fn(real_sha1, &c);\n\tif (hashcmp(expected_sha1, real_sha1)) {\n\t\terror(\"sha1 mismatch for %s (expected %s)\", path,\n\t\t      sha1_to_hex(expected_sha1));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint read_loose_object(const char *path,\n\t\t      const struct object_id *expected_oid,\n\t\t      enum object_type *type,\n\t\t      unsigned long *size,\n\t\t      void **contents)\n{\n\tint ret = -1;\n\tvoid *map = NULL;\n\tunsigned long mapsize;\n\tgit_zstream stream;\n\tchar hdr[MAX_HEADER_LEN];\n\n\t*contents = NULL;\n\n\tmap = map_sha1_file_1(the_repository, path, NULL, &mapsize);\n\tif (!map) {\n\t\terror_errno(\"unable to mmap %s\", path);\n\t\tgoto out;\n\t}\n\n\tif (unpack_sha1_header(&stream, map, mapsize, hdr, sizeof(hdr)) < 0) {\n\t\terror(\"unable to unpack header of %s\", path);\n\t\tgoto out;\n\t}\n\n\t*type = parse_sha1_header(hdr, size);\n\tif (*type < 0) {\n\t\terror(\"unable to parse header of %s\", path);\n\t\tgit_inflate_end(&stream);\n\t\tgoto out;\n\t}\n\n\tif (*type == OBJ_BLOB && *size > big_file_threshold) {\n\t\tif (check_stream_sha1(&stream, hdr, *size, path, expected_oid->hash) < 0)\n\t\t\tgoto out;\n\t} else {\n\t\t*contents = unpack_sha1_rest(&stream, hdr, *size, expected_oid->hash);\n\t\tif (!*contents) {\n\t\t\terror(\"unable to unpack contents of %s\", path);\n\t\t\tgit_inflate_end(&stream);\n\t\t\tgoto out;\n\t\t}\n\t\tif (check_object_signature(expected_oid, *contents,\n\t\t\t\t\t *size, type_name(*type))) {\n\t\t\terror(\"sha1 mismatch for %s (expected %s)\", path,\n\t\t\t      oid_to_hex(expected_oid));\n\t\t\tfree(*contents);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0; /* everything checks out */\n\nout:\n\tif (map)\n\t\tmunmap(map, mapsize);\n\treturn ret;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0016d460526f631af78ae83a249c4bfe6447400a",
  "sha1_ok": true,
  "size": 57543
}
