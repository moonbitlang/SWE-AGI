{
  "content": {
    "base64": "I2lmbmRlZiBDT01NSVRfSAojZGVmaW5lIENPTU1JVF9ICgojaW5jbHVkZSAib2JqZWN0LmgiCiNpbmNsdWRlICJ0cmVlLmgiCiNpbmNsdWRlICJzdHJidWYuaCIKI2luY2x1ZGUgImRlY29yYXRlLmgiCiNpbmNsdWRlICJncGctaW50ZXJmYWNlLmgiCiNpbmNsdWRlICJzdHJpbmctbGlzdC5oIgojaW5jbHVkZSAicHJldHR5LmgiCgojZGVmaW5lIENPTU1JVF9OT1RfRlJPTV9HUkFQSCAweEZGRkZGRkZGCiNkZWZpbmUgR0VORVJBVElPTl9OVU1CRVJfSU5GSU5JVFkgMHhGRkZGRkZGRgojZGVmaW5lIEdFTkVSQVRJT05fTlVNQkVSX01BWCAweDNGRkZGRkZGCiNkZWZpbmUgR0VORVJBVElPTl9OVU1CRVJfWkVSTyAwCgpzdHJ1Y3QgY29tbWl0X2xpc3QgewoJc3RydWN0IGNvbW1pdCAqaXRlbTsKCXN0cnVjdCBjb21taXRfbGlzdCAqbmV4dDsKfTsKCi8qCiAqIFRoZSBzaXplIG9mIHRoaXMgc3RydWN0IG1hdHRlcnMgaW4gZnVsbCByZXBvIHdhbGsgb3BlcmF0aW9ucyBsaWtlCiAqICdnaXQgY2xvbmUnIG9yICdnaXQgZ2MnLiBDb25zaWRlciB1c2luZyBjb21taXQtc2xhYiB0byBhdHRhY2ggZGF0YQogKiB0byBhIGNvbW1pdCBpbnN0ZWFkIG9mIGFkZGluZyBuZXcgZmllbGRzIGhlcmUuCiAqLwpzdHJ1Y3QgY29tbWl0IHsKCXN0cnVjdCBvYmplY3Qgb2JqZWN0OwoJdGltZXN0YW1wX3QgZGF0ZTsKCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50czsKCgkvKgoJICogSWYgdGhlIGNvbW1pdCBpcyBsb2FkZWQgZnJvbSB0aGUgY29tbWl0LWdyYXBoIGZpbGUsIHRoZW4gdGhpcwoJICogbWVtYmVyIG1heSBiZSBOVUxMLiBPbmx5IGFjY2VzcyBpdCB0aHJvdWdoIGdldF9jb21taXRfdHJlZSgpCgkgKiBvciBnZXRfY29tbWl0X3RyZWVfb2lkKCkuCgkgKi8KCXN0cnVjdCB0cmVlICptYXliZV90cmVlOwoJdWludDMyX3QgZ3JhcGhfcG9zOwoJdWludDMyX3QgZ2VuZXJhdGlvbjsKCXVuc2lnbmVkIGludCBpbmRleDsKfTsKCmV4dGVybiBpbnQgc2F2ZV9jb21taXRfYnVmZmVyOwpleHRlcm4gY29uc3QgY2hhciAqY29tbWl0X3R5cGU7CgovKiBXaGlsZSB3ZSBjYW4gZGVjb3JhdGUgYW55IG9iamVjdCB3aXRoIGEgbmFtZSwgaXQncyBvbmx5IHVzZWQgZm9yIGNvbW1pdHMuLiAqLwpzdHJ1Y3QgbmFtZV9kZWNvcmF0aW9uIHsKCXN0cnVjdCBuYW1lX2RlY29yYXRpb24gKm5leHQ7CglpbnQgdHlwZTsKCWNoYXIgbmFtZVtGTEVYX0FSUkFZXTsKfTsKCmVudW0gZGVjb3JhdGlvbl90eXBlIHsKCURFQ09SQVRJT05fTk9ORSA9IDAsCglERUNPUkFUSU9OX1JFRl9MT0NBTCwKCURFQ09SQVRJT05fUkVGX1JFTU9URSwKCURFQ09SQVRJT05fUkVGX1RBRywKCURFQ09SQVRJT05fUkVGX1NUQVNILAoJREVDT1JBVElPTl9SRUZfSEVBRCwKCURFQ09SQVRJT05fR1JBRlRFRCwKfTsKCnZvaWQgYWRkX25hbWVfZGVjb3JhdGlvbihlbnVtIGRlY29yYXRpb25fdHlwZSB0eXBlLCBjb25zdCBjaGFyICpuYW1lLCBzdHJ1Y3Qgb2JqZWN0ICpvYmopOwpjb25zdCBzdHJ1Y3QgbmFtZV9kZWNvcmF0aW9uICpnZXRfbmFtZV9kZWNvcmF0aW9uKGNvbnN0IHN0cnVjdCBvYmplY3QgKm9iaik7CgpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCk7CnN0cnVjdCBjb21taXQgKmxvb2t1cF9jb21taXRfcmVmZXJlbmNlKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCk7CiNkZWZpbmUgbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfZ2VudGx5KHIsIG8sIHEpIFwKCQlsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHlfIyNyKG8sIHEpCnN0cnVjdCBjb21taXQgKmxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseV90aGVfcmVwb3NpdG9yeSgKCQkJCQkgICAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCQkJICAgICAgaW50IHF1aWV0KTsKc3RydWN0IGNvbW1pdCAqbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfYnlfbmFtZShjb25zdCBjaGFyICpuYW1lKTsKCi8qCiAqIExvb2sgdXAgb2JqZWN0IG5hbWVkIGJ5ICJvaWQiLCBkZXJlZmVyZW5jZSB0YWcgYXMgbmVjZXNzYXJ5LAogKiBnZXQgYSBjb21taXQgYW5kIHJldHVybiBpdC4gSWYgIm9pZCIgZG9lcyBub3QgZGVyZWZlcmVuY2UgdG8KICogYSBjb21taXQsIHVzZSByZWZfbmFtZSB0byByZXBvcnQgYW4gZXJyb3IgYW5kIGRpZS4KICovCnN0cnVjdCBjb21taXQgKmxvb2t1cF9jb21taXRfb3JfZGllKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgY29uc3QgY2hhciAqcmVmX25hbWUpOwoKaW50IHBhcnNlX2NvbW1pdF9idWZmZXIoc3RydWN0IGNvbW1pdCAqaXRlbSwgY29uc3Qgdm9pZCAqYnVmZmVyLCB1bnNpZ25lZCBsb25nIHNpemUsIGludCBjaGVja19ncmFwaCk7CmludCBwYXJzZV9jb21taXRfZ2VudGx5KHN0cnVjdCBjb21taXQgKml0ZW0sIGludCBxdWlldF9vbl9taXNzaW5nKTsKc3RhdGljIGlubGluZSBpbnQgcGFyc2VfY29tbWl0KHN0cnVjdCBjb21taXQgKml0ZW0pCnsKCXJldHVybiBwYXJzZV9jb21taXRfZ2VudGx5KGl0ZW0sIDApOwp9CnZvaWQgcGFyc2VfY29tbWl0X29yX2RpZShzdHJ1Y3QgY29tbWl0ICppdGVtKTsKCi8qCiAqIEFzc29jaWF0ZSBhbiBvYmplY3QgYnVmZmVyIHdpdGggdGhlIGNvbW1pdC4gVGhlIG93bmVyc2hpcCBvZiB0aGUKICogbWVtb3J5IGlzIGhhbmRlZCBvdmVyIHRvIHRoZSBjb21taXQsIGFuZCBtdXN0IGJlIGZyZWUoKS1hYmxlLgogKi8Kdm9pZCBzZXRfY29tbWl0X2J1ZmZlcihzdHJ1Y3QgY29tbWl0ICosIHZvaWQgKmJ1ZmZlciwgdW5zaWduZWQgbG9uZyBzaXplKTsKCi8qCiAqIEdldCBhbnkgY2FjaGVkIG9iamVjdCBidWZmZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb21taXQuIFJldHVybnMgTlVMTAogKiBpZiBub25lLiBUaGUgcmVzdWx0aW5nIG1lbW9yeSBzaG91bGQgbm90IGJlIGZyZWVkLgogKi8KY29uc3Qgdm9pZCAqZ2V0X2NhY2hlZF9jb21taXRfYnVmZmVyKGNvbnN0IHN0cnVjdCBjb21taXQgKiwgdW5zaWduZWQgbG9uZyAqc2l6ZSk7CgovKgogKiBHZXQgdGhlIGNvbW1pdCdzIG9iamVjdCBjb250ZW50cywgZWl0aGVyIGZyb20gY2FjaGUgb3IgYnkgcmVhZGluZyB0aGUgb2JqZWN0CiAqIGZyb20gZGlzay4gVGhlIHJlc3VsdGluZyBtZW1vcnkgc2hvdWxkIG5vdCBiZSBtb2RpZmllZCwgYW5kIG11c3QgYmUgZ2l2ZW4KICogdG8gdW51c2VfY29tbWl0X2J1ZmZlciB3aGVuIHRoZSBjYWxsZXIgaXMgZG9uZS4KICovCmNvbnN0IHZvaWQgKmdldF9jb21taXRfYnVmZmVyKGNvbnN0IHN0cnVjdCBjb21taXQgKiwgdW5zaWduZWQgbG9uZyAqc2l6ZSk7CgovKgogKiBUZWxsIHRoZSBjb21taXQgc3Vic3l0ZW0gdGhhdCB3ZSBhcmUgZG9uZSB3aXRoIGEgcGFydGljdWxhciBjb21taXQgYnVmZmVyLgogKiBUaGUgY29tbWl0IGFuZCBidWZmZXIgc2hvdWxkIGJlIHRoZSBpbnB1dCBhbmQgcmV0dXJuIHZhbHVlLCByZXNwZWN0aXZlbHksCiAqIGZyb20gYW4gZWFybGllciBjYWxsIHRvIGdldF9jb21taXRfYnVmZmVyLiAgVGhlIGJ1ZmZlciBtYXkgb3IgbWF5IG5vdCBiZQogKiBmcmVlZCBieSB0aGlzIGNhbGw7IGNhbGxlcnMgc2hvdWxkIG5vdCBhY2Nlc3MgdGhlIG1lbW9yeSBhZnRlcndhcmRzLgogKi8Kdm9pZCB1bnVzZV9jb21taXRfYnVmZmVyKGNvbnN0IHN0cnVjdCBjb21taXQgKiwgY29uc3Qgdm9pZCAqYnVmZmVyKTsKCi8qCiAqIEZyZWUgYW55IGNhY2hlZCBvYmplY3QgYnVmZmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29tbWl0LgogKi8Kdm9pZCBmcmVlX2NvbW1pdF9idWZmZXIoc3RydWN0IGNvbW1pdCAqKTsKCnN0cnVjdCB0cmVlICpnZXRfY29tbWl0X3RyZWUoY29uc3Qgc3RydWN0IGNvbW1pdCAqKTsKc3RydWN0IG9iamVjdF9pZCAqZ2V0X2NvbW1pdF90cmVlX29pZChjb25zdCBzdHJ1Y3QgY29tbWl0ICopOwoKLyoKICogUmVsZWFzZSBtZW1vcnkgcmVsYXRlZCB0byBhIGNvbW1pdCwgaW5jbHVkaW5nIHRoZSBwYXJlbnQgbGlzdCBhbmQKICogYW55IGNhY2hlZCBvYmplY3QgYnVmZmVyLgogKi8Kdm9pZCByZWxlYXNlX2NvbW1pdF9tZW1vcnkoc3RydWN0IGNvbW1pdCAqYyk7CgovKgogKiBEaXNhc3NvY2lhdGUgYW55IGNhY2hlZCBvYmplY3QgYnVmZmVyIGZyb20gdGhlIGNvbW1pdCwgYnV0IGRvIG5vdCBmcmVlIGl0LgogKiBUaGUgYnVmZmVyIChvciBOVUxMLCBpZiBub25lKSBpcyByZXR1cm5lZC4KICovCmNvbnN0IHZvaWQgKmRldGFjaF9jb21taXRfYnVmZmVyKHN0cnVjdCBjb21taXQgKiwgdW5zaWduZWQgbG9uZyAqc2l6ZXApOwoKLyogRmluZCBiZWdpbm5pbmcgYW5kIGxlbmd0aCBvZiBjb21taXQgc3ViamVjdC4gKi8KaW50IGZpbmRfY29tbWl0X3N1YmplY3QoY29uc3QgY2hhciAqY29tbWl0X2J1ZmZlciwgY29uc3QgY2hhciAqKnN1YmplY3QpOwoKc3RydWN0IGNvbW1pdF9saXN0ICpjb21taXRfbGlzdF9pbnNlcnQoc3RydWN0IGNvbW1pdCAqaXRlbSwKCQkJCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKipsaXN0KTsKc3RydWN0IGNvbW1pdF9saXN0ICoqY29tbWl0X2xpc3RfYXBwZW5kKHN0cnVjdCBjb21taXQgKmNvbW1pdCwKCQkJCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKipuZXh0KTsKdW5zaWduZWQgY29tbWl0X2xpc3RfY291bnQoY29uc3Qgc3RydWN0IGNvbW1pdF9saXN0ICpsKTsKc3RydWN0IGNvbW1pdF9saXN0ICpjb21taXRfbGlzdF9pbnNlcnRfYnlfZGF0ZShzdHJ1Y3QgY29tbWl0ICppdGVtLAoJCQkJICAgIHN0cnVjdCBjb21taXRfbGlzdCAqKmxpc3QpOwp2b2lkIGNvbW1pdF9saXN0X3NvcnRfYnlfZGF0ZShzdHJ1Y3QgY29tbWl0X2xpc3QgKipsaXN0KTsKCi8qIFNoYWxsb3cgY29weSBvZiB0aGUgaW5wdXQgbGlzdCAqLwpzdHJ1Y3QgY29tbWl0X2xpc3QgKmNvcHlfY29tbWl0X2xpc3Qoc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0KTsKCnZvaWQgZnJlZV9jb21taXRfbGlzdChzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QpOwoKc3RydWN0IHJldl9pbmZvOyAvKiBpbiByZXZpc2lvbi5oLCBpdCBjaXJjdWxhcmx5IHVzZXMgZW51bSBjbWl0X2ZtdCAqLwoKZXh0ZXJuIGludCBoYXNfbm9uX2FzY2lpKGNvbnN0IGNoYXIgKnRleHQpOwpleHRlcm4gY29uc3QgY2hhciAqbG9nbXNnX3JlZW5jb2RlKGNvbnN0IHN0cnVjdCBjb21taXQgKmNvbW1pdCwKCQkJCSAgIGNoYXIgKipjb21taXRfZW5jb2RpbmcsCgkJCQkgICBjb25zdCBjaGFyICpvdXRwdXRfZW5jb2RpbmcpOwpleHRlcm4gY29uc3QgY2hhciAqc2tpcF9ibGFua19saW5lcyhjb25zdCBjaGFyICptc2cpOwoKLyoqIFJlbW92ZXMgdGhlIGZpcnN0IGNvbW1pdCBmcm9tIGEgbGlzdCBzb3J0ZWQgYnkgZGF0ZSwgYW5kIGFkZHMgYWxsCiAqIG9mIGl0cyBwYXJlbnRzLgogKiovCnN0cnVjdCBjb21taXQgKnBvcF9tb3N0X3JlY2VudF9jb21taXQoc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCwKCQkJCSAgICAgIHVuc2lnbmVkIGludCBtYXJrKTsKCnN0cnVjdCBjb21taXQgKnBvcF9jb21taXQoc3RydWN0IGNvbW1pdF9saXN0ICoqc3RhY2spOwoKdm9pZCBjbGVhcl9jb21taXRfbWFya3Moc3RydWN0IGNvbW1pdCAqY29tbWl0LCB1bnNpZ25lZCBpbnQgbWFyayk7CnZvaWQgY2xlYXJfY29tbWl0X21hcmtzX21hbnkoaW50IG5yLCBzdHJ1Y3QgY29tbWl0ICoqY29tbWl0LCB1bnNpZ25lZCBpbnQgbWFyayk7CgoKZW51bSByZXZfc29ydF9vcmRlciB7CglSRVZfU09SVF9JTl9HUkFQSF9PUkRFUiA9IDAsCglSRVZfU09SVF9CWV9DT01NSVRfREFURSwKCVJFVl9TT1JUX0JZX0FVVEhPUl9EQVRFCn07CgovKgogKiBQZXJmb3JtcyBhbiBpbi1wbGFjZSB0b3BvbG9naWNhbCBzb3J0IG9mIGxpc3Qgc3VwcGxpZWQuCiAqCiAqICAgaW52YXJpYW50IG9mIHJlc3VsdGluZyBsaXN0IGlzOgogKiAgICAgIGEgcmVhY2hhYmxlIGZyb20gYiA9PiBvcmQoYikgPCBvcmQoYSkKICogICBzb3J0X29yZGVyIGZ1cnRoZXIgc3BlY2lmaWVzOgogKiAgIFJFVl9TT1JUX0lOX0dSQVBIX09SREVSOiB0cnkgdG8gc2hvdyBhIGNvbW1pdCBvbiBhIHNpbmdsZS1wYXJlbnQKICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gdG9nZXRoZXIuCiAqICAgUkVWX1NPUlRfQllfQ09NTUlUX0RBVEU6IHNob3cgZWxpZ2libGUgY29tbWl0cyBpbiBjb21taXR0ZXItZGF0ZSBvcmRlci4KICovCnZvaWQgc29ydF9pbl90b3BvbG9naWNhbF9vcmRlcihzdHJ1Y3QgY29tbWl0X2xpc3QgKiosIGVudW0gcmV2X3NvcnRfb3JkZXIpOwoKc3RydWN0IGNvbW1pdF9ncmFmdCB7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCWludCBucl9wYXJlbnQ7IC8qIDwgMCBpZiBzaGFsbG93IGNvbW1pdCAqLwoJc3RydWN0IG9iamVjdF9pZCBwYXJlbnRbRkxFWF9BUlJBWV07IC8qIG1vcmUgKi8KfTsKdHlwZWRlZiBpbnQgKCplYWNoX2NvbW1pdF9ncmFmdF9mbikoY29uc3Qgc3RydWN0IGNvbW1pdF9ncmFmdCAqLCB2b2lkICopOwoKc3RydWN0IGNvbW1pdF9ncmFmdCAqcmVhZF9ncmFmdF9saW5lKHN0cnVjdCBzdHJidWYgKmxpbmUpOwppbnQgcmVnaXN0ZXJfY29tbWl0X2dyYWZ0KHN0cnVjdCByZXBvc2l0b3J5ICpyLCBzdHJ1Y3QgY29tbWl0X2dyYWZ0ICosIGludCk7CnN0cnVjdCBjb21taXRfZ3JhZnQgKmxvb2t1cF9jb21taXRfZ3JhZnQoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCk7CgpleHRlcm4gc3RydWN0IGNvbW1pdF9saXN0ICpnZXRfbWVyZ2VfYmFzZXMoc3RydWN0IGNvbW1pdCAqcmV2MSwgc3RydWN0IGNvbW1pdCAqcmV2Mik7CmV4dGVybiBzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9tZXJnZV9iYXNlc19tYW55KHN0cnVjdCBjb21taXQgKm9uZSwgaW50IG4sIHN0cnVjdCBjb21taXQgKip0d29zKTsKZXh0ZXJuIHN0cnVjdCBjb21taXRfbGlzdCAqZ2V0X29jdG9wdXNfbWVyZ2VfYmFzZXMoc3RydWN0IGNvbW1pdF9saXN0ICppbik7CgovKiBUbyBiZSB1c2VkIG9ubHkgd2hlbiBvYmplY3QgZmxhZ3MgYWZ0ZXIgdGhpcyBjYWxsIG5vIGxvbmdlciBtYXR0ZXIgKi8KZXh0ZXJuIHN0cnVjdCBjb21taXRfbGlzdCAqZ2V0X21lcmdlX2Jhc2VzX21hbnlfZGlydHkoc3RydWN0IGNvbW1pdCAqb25lLCBpbnQgbiwgc3RydWN0IGNvbW1pdCAqKnR3b3MpOwoKLyogbGFyZ2VzdCBwb3NpdGl2ZSBudW1iZXIgYSBzaWduZWQgMzItYml0IGludGVnZXIgY2FuIGNvbnRhaW4gKi8KI2RlZmluZSBJTkZJTklURV9ERVBUSCAweDdmZmZmZmZmCgpzdHJ1Y3Qgb2lkX2FycmF5OwpzdHJ1Y3QgcmVmOwpleHRlcm4gaW50IHJlZ2lzdGVyX3NoYWxsb3coc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCk7CmV4dGVybiBpbnQgdW5yZWdpc3Rlcl9zaGFsbG93KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCk7CmV4dGVybiBpbnQgZm9yX2VhY2hfY29tbWl0X2dyYWZ0KGVhY2hfY29tbWl0X2dyYWZ0X2ZuLCB2b2lkICopOwpleHRlcm4gaW50IGlzX3JlcG9zaXRvcnlfc2hhbGxvdyhzdHJ1Y3QgcmVwb3NpdG9yeSAqcik7CmV4dGVybiBzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9zaGFsbG93X2NvbW1pdHMoc3RydWN0IG9iamVjdF9hcnJheSAqaGVhZHMsCgkJaW50IGRlcHRoLCBpbnQgc2hhbGxvd19mbGFnLCBpbnQgbm90X3NoYWxsb3dfZmxhZyk7CmV4dGVybiBzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9zaGFsbG93X2NvbW1pdHNfYnlfcmV2X2xpc3QoCgkJaW50IGFjLCBjb25zdCBjaGFyICoqYXYsIGludCBzaGFsbG93X2ZsYWcsIGludCBub3Rfc2hhbGxvd19mbGFnKTsKZXh0ZXJuIHZvaWQgc2V0X2FsdGVybmF0ZV9zaGFsbG93X2ZpbGUoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IGNoYXIgKnBhdGgsIGludCBvdmVycmlkZSk7CmV4dGVybiBpbnQgd3JpdGVfc2hhbGxvd19jb21taXRzKHN0cnVjdCBzdHJidWYgKm91dCwgaW50IHVzZV9wYWNrX3Byb3RvY29sLAoJCQkJIGNvbnN0IHN0cnVjdCBvaWRfYXJyYXkgKmV4dHJhKTsKZXh0ZXJuIHZvaWQgc2V0dXBfYWx0ZXJuYXRlX3NoYWxsb3coc3RydWN0IGxvY2tfZmlsZSAqc2hhbGxvd19sb2NrLAoJCQkJICAgIGNvbnN0IGNoYXIgKiphbHRlcm5hdGVfc2hhbGxvd19maWxlLAoJCQkJICAgIGNvbnN0IHN0cnVjdCBvaWRfYXJyYXkgKmV4dHJhKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKnNldHVwX3RlbXBvcmFyeV9zaGFsbG93KGNvbnN0IHN0cnVjdCBvaWRfYXJyYXkgKmV4dHJhKTsKZXh0ZXJuIHZvaWQgYWR2ZXJ0aXNlX3NoYWxsb3dfZ3JhZnRzKGludCk7CgpzdHJ1Y3Qgc2hhbGxvd19pbmZvIHsKCXN0cnVjdCBvaWRfYXJyYXkgKnNoYWxsb3c7CglpbnQgKm91cnMsIG5yX291cnM7CglpbnQgKnRoZWlycywgbnJfdGhlaXJzOwoJc3RydWN0IG9pZF9hcnJheSAqcmVmOwoKCS8qIGZvciByZWNlaXZlLXBhY2sgKi8KCXVpbnQzMl90ICoqdXNlZF9zaGFsbG93OwoJaW50ICpuZWVkX3JlYWNoYWJpbGl0eV90ZXN0OwoJaW50ICpyZWFjaGFibGU7CglpbnQgKnNoYWxsb3dfcmVmOwoJc3RydWN0IGNvbW1pdCAqKmNvbW1pdHM7CglpbnQgbnJfY29tbWl0czsKfTsKCmV4dGVybiB2b2lkIHByZXBhcmVfc2hhbGxvd19pbmZvKHN0cnVjdCBzaGFsbG93X2luZm8gKiwgc3RydWN0IG9pZF9hcnJheSAqKTsKZXh0ZXJuIHZvaWQgY2xlYXJfc2hhbGxvd19pbmZvKHN0cnVjdCBzaGFsbG93X2luZm8gKik7CmV4dGVybiB2b2lkIHJlbW92ZV9ub25leGlzdGVudF90aGVpcnNfc2hhbGxvdyhzdHJ1Y3Qgc2hhbGxvd19pbmZvICopOwpleHRlcm4gdm9pZCBhc3NpZ25fc2hhbGxvd19jb21taXRzX3RvX3JlZnMoc3RydWN0IHNoYWxsb3dfaW5mbyAqaW5mbywKCQkJCQkgICB1aW50MzJfdCAqKnVzZWQsCgkJCQkJICAgaW50ICpyZWZfc3RhdHVzKTsKZXh0ZXJuIGludCBkZWxheWVkX3JlYWNoYWJpbGl0eV90ZXN0KHN0cnVjdCBzaGFsbG93X2luZm8gKnNpLCBpbnQgYyk7CmV4dGVybiB2b2lkIHBydW5lX3NoYWxsb3coaW50IHNob3dfb25seSk7CmV4dGVybiBzdHJ1Y3QgdHJhY2Vfa2V5IHRyYWNlX3NoYWxsb3c7CgppbnQgaXNfZGVzY2VuZGFudF9vZihzdHJ1Y3QgY29tbWl0ICosIHN0cnVjdCBjb21taXRfbGlzdCAqKTsKaW50IGluX21lcmdlX2Jhc2VzKHN0cnVjdCBjb21taXQgKiwgc3RydWN0IGNvbW1pdCAqKTsKaW50IGluX21lcmdlX2Jhc2VzX21hbnkoc3RydWN0IGNvbW1pdCAqLCBpbnQsIHN0cnVjdCBjb21taXQgKiopOwoKZXh0ZXJuIGludCBpbnRlcmFjdGl2ZV9hZGQoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgsIGludCBwYXRjaCk7CmV4dGVybiBpbnQgcnVuX2FkZF9pbnRlcmFjdGl2ZShjb25zdCBjaGFyICpyZXZpc2lvbiwgY29uc3QgY2hhciAqcGF0Y2hfbW9kZSwKCQkJICAgICAgIGNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcGF0aHNwZWMpOwoKLyoKICogVGFrZXMgYSBsaXN0IG9mIGNvbW1pdHMgYW5kIHJldHVybnMgYSBuZXcgbGlzdCB3aGVyZSB0aG9zZQogKiBoYXZlIGJlZW4gcmVtb3ZlZCB0aGF0IGNhbiBiZSByZWFjaGVkIGZyb20gb3RoZXIgY29tbWl0cyBpbgogKiB0aGUgbGlzdC4gSXQgaXMgdXNlZnVsIGZvciwgZS5nLiwgcmVkdWNpbmcgdGhlIGNvbW1pdHMKICogcmFuZG9tbHkgdGhyb3duIGF0IHRoZSBnaXQtbWVyZ2UgY29tbWFuZCBhbmQgcmVtb3ZpbmcKICogcmVkdW5kYW50IGNvbW1pdHMgdGhhdCB0aGUgdXNlciBzaG91bGRuJ3QgaGF2ZSBnaXZlbiB0byBpdC4KICoKICogVGhpcyBmdW5jdGlvbiBkZXN0cm95cyB0aGUgU1RBTEUgYml0IG9mIHRoZSBjb21taXQgb2JqZWN0cycKICogZmxhZ3MuCiAqLwpleHRlcm4gc3RydWN0IGNvbW1pdF9saXN0ICpyZWR1Y2VfaGVhZHMoc3RydWN0IGNvbW1pdF9saXN0ICpoZWFkcyk7CgovKgogKiBMaWtlIGByZWR1Y2VfaGVhZHMoKWAsIGV4Y2VwdCBpdCByZXBsYWNlcyB0aGUgbGlzdC4gVXNlIHRoaXMKICogaW5zdGVhZCBvZiBgZm9vID0gcmVkdWNlX2hlYWRzKGZvbyk7YCB0byBhdm9pZCBtZW1vcnkgbGVha3MuCiAqLwpleHRlcm4gdm9pZCByZWR1Y2VfaGVhZHNfcmVwbGFjZShzdHJ1Y3QgY29tbWl0X2xpc3QgKipoZWFkcyk7CgpzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciB7CglzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqbmV4dDsKCWNoYXIgKmtleTsKCWNoYXIgKnZhbHVlOwoJc2l6ZV90IGxlbjsKfTsKCmV4dGVybiB2b2lkIGFwcGVuZF9tZXJnZV90YWdfaGVhZGVycyhzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMsCgkJCQkgICAgIHN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICoqKnRhaWwpOwoKZXh0ZXJuIGludCBjb21taXRfdHJlZShjb25zdCBjaGFyICptc2csIHNpemVfdCBtc2dfbGVuLAoJCSAgICAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICp0cmVlLAoJCSAgICAgICBzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMsIHN0cnVjdCBvYmplY3RfaWQgKnJldCwKCQkgICAgICAgY29uc3QgY2hhciAqYXV0aG9yLCBjb25zdCBjaGFyICpzaWduX2NvbW1pdCk7CgpleHRlcm4gaW50IGNvbW1pdF90cmVlX2V4dGVuZGVkKGNvbnN0IGNoYXIgKm1zZywgc2l6ZV90IG1zZ19sZW4sCgkJCQljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICp0cmVlLAoJCQkJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzLAoJCQkJc3RydWN0IG9iamVjdF9pZCAqcmV0LCBjb25zdCBjaGFyICphdXRob3IsCgkJCQljb25zdCBjaGFyICpzaWduX2NvbW1pdCwKCQkJCXN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICopOwoKZXh0ZXJuIHN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpyZWFkX2NvbW1pdF9leHRyYV9oZWFkZXJzKHN0cnVjdCBjb21taXQgKiwgY29uc3QgY2hhciAqKik7CgpleHRlcm4gdm9pZCBmcmVlX2NvbW1pdF9leHRyYV9oZWFkZXJzKHN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpleHRyYSk7CgovKgogKiBTZWFyY2ggdGhlIGNvbW1pdCBvYmplY3QgY29udGVudHMgZ2l2ZW4gYnkgIm1zZyIgZm9yIHRoZSBoZWFkZXIgImtleSIuCiAqIFJldHVybnMgYSBwb2ludGVyIHRvIHRoZSBzdGFydCBvZiB0aGUgaGVhZGVyIGNvbnRlbnRzLCBvciBOVUxMLiBUaGUgbGVuZ3RoCiAqIG9mIHRoZSBoZWFkZXIsIHVwIHRvIHRoZSBmaXJzdCBuZXdsaW5lLCBpcyByZXR1cm5lZCB2aWEgb3V0X2xlbi4KICoKICogTm90ZSB0aGF0IHNvbWUgaGVhZGVycyAobGlrZSBtZXJnZXRhZykgbWF5IGJlIG11bHRpLWxpbmUuIEl0IGlzIHRoZSBjYWxsZXIncwogKiByZXNwb25zaWJpbGl0eSB0byBwYXJzZSBmdXJ0aGVyIGluIHRoaXMgY2FzZSEKICovCmV4dGVybiBjb25zdCBjaGFyICpmaW5kX2NvbW1pdF9oZWFkZXIoY29uc3QgY2hhciAqbXNnLCBjb25zdCBjaGFyICprZXksCgkJCQkgICAgICBzaXplX3QgKm91dF9sZW4pOwoKLyogRmluZCB0aGUgZW5kIG9mIHRoZSBsb2cgbWVzc2FnZSwgdGhlIHJpZ2h0IHBsYWNlIGZvciBhIG5ldyB0cmFpbGVyLiAqLwpleHRlcm4gaW50IGlnbm9yZV9ub25fdHJhaWxlcihjb25zdCBjaGFyICpidWYsIHNpemVfdCBsZW4pOwoKdHlwZWRlZiBpbnQgKCplYWNoX21lcmdldGFnX2ZuKShzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpleHRyYSwKCQkJCSB2b2lkICpjYl9kYXRhKTsKCmV4dGVybiBpbnQgZm9yX2VhY2hfbWVyZ2V0YWcoZWFjaF9tZXJnZXRhZ19mbiBmbiwgc3RydWN0IGNvbW1pdCAqY29tbWl0LCB2b2lkICpkYXRhKTsKCnN0cnVjdCBtZXJnZV9yZW1vdGVfZGVzYyB7CglzdHJ1Y3Qgb2JqZWN0ICpvYmo7IC8qIHRoZSBuYW1lZCBvYmplY3QsIGNvdWxkIGJlIGEgdGFnICovCgljaGFyIG5hbWVbRkxFWF9BUlJBWV07Cn07CmV4dGVybiBzdHJ1Y3QgbWVyZ2VfcmVtb3RlX2Rlc2MgKm1lcmdlX3JlbW90ZV91dGlsKHN0cnVjdCBjb21taXQgKik7CmV4dGVybiB2b2lkIHNldF9tZXJnZV9yZW1vdGVfZGVzYyhzdHJ1Y3QgY29tbWl0ICpjb21taXQsCgkJCQkgIGNvbnN0IGNoYXIgKm5hbWUsIHN0cnVjdCBvYmplY3QgKm9iaik7CgovKgogKiBHaXZlbiAibmFtZSIgZnJvbSB0aGUgY29tbWFuZCBsaW5lIHRvIG1lcmdlLCBmaW5kIHRoZSBjb21taXQgb2JqZWN0CiAqIGFuZCByZXR1cm4gaXQsIHdoaWxlIHN0b3JpbmcgbWVyZ2VfcmVtb3RlX2Rlc2MgaW4gaXRzIC0+dXRpbCBmaWVsZCwKICogdG8gYWxsb3cgY2FsbGVycyB0byB0ZWxsIGlmIHdlIGFyZSB0b2xkIHRvIG1lcmdlIGEgdGFnLgogKi8Kc3RydWN0IGNvbW1pdCAqZ2V0X21lcmdlX3BhcmVudChjb25zdCBjaGFyICpuYW1lKTsKCmV4dGVybiBpbnQgcGFyc2Vfc2lnbmVkX2NvbW1pdChjb25zdCBzdHJ1Y3QgY29tbWl0ICpjb21taXQsCgkJCSAgICAgICBzdHJ1Y3Qgc3RyYnVmICptZXNzYWdlLCBzdHJ1Y3Qgc3RyYnVmICpzaWduYXR1cmUpOwpleHRlcm4gaW50IHJlbW92ZV9zaWduYXR1cmUoc3RydWN0IHN0cmJ1ZiAqYnVmKTsKCi8qCiAqIENoZWNrIHRoZSBzaWduYXR1cmUgb2YgdGhlIGdpdmVuIGNvbW1pdC4gVGhlIHJlc3VsdCBvZiB0aGUgY2hlY2sgaXMgc3RvcmVkCiAqIGluIHNpZy0+Y2hlY2tfcmVzdWx0LCAnRycgZm9yIGEgZ29vZCBzaWduYXR1cmUsICdVJyBmb3IgYSBnb29kIHNpZ25hdHVyZQogKiBmcm9tIGFuIHVudHJ1c3RlZCBzaWduZXIsICdCJyBmb3IgYSBiYWQgc2lnbmF0dXJlIGFuZCAnTicgZm9yIG5vIHNpZ25hdHVyZQogKiBhdCBhbGwuICBUaGlzIG1heSBhbGxvY2F0ZSBtZW1vcnkgZm9yIHNpZy0+Z3BnX291dHB1dCwgc2lnLT5ncGdfc3RhdHVzLAogKiBzaWctPnNpZ25lciBhbmQgc2lnLT5rZXkuCiAqLwpleHRlcm4gaW50IGNoZWNrX2NvbW1pdF9zaWduYXR1cmUoY29uc3Qgc3RydWN0IGNvbW1pdCAqY29tbWl0LCBzdHJ1Y3Qgc2lnbmF0dXJlX2NoZWNrICpzaWdjKTsKCmludCBjb21wYXJlX2NvbW1pdHNfYnlfY29tbWl0X2RhdGUoY29uc3Qgdm9pZCAqYV8sIGNvbnN0IHZvaWQgKmJfLCB2b2lkICp1bnVzZWQpOwppbnQgY29tcGFyZV9jb21taXRzX2J5X2dlbl90aGVuX2NvbW1pdF9kYXRlKGNvbnN0IHZvaWQgKmFfLCBjb25zdCB2b2lkICpiXywgdm9pZCAqdW51c2VkKTsKCkxBU1RfQVJHX01VU1RfQkVfTlVMTApleHRlcm4gaW50IHJ1bl9jb21taXRfaG9vayhpbnQgZWRpdG9yX2lzX3VzZWQsIGNvbnN0IGNoYXIgKmluZGV4X2ZpbGUsIGNvbnN0IGNoYXIgKm5hbWUsIC4uLik7CgojZW5kaWYgLyogQ09NTUlUX0ggKi8K",
    "text": "#ifndef COMMIT_H\n#define COMMIT_H\n\n#include \"object.h\"\n#include \"tree.h\"\n#include \"strbuf.h\"\n#include \"decorate.h\"\n#include \"gpg-interface.h\"\n#include \"string-list.h\"\n#include \"pretty.h\"\n\n#define COMMIT_NOT_FROM_GRAPH 0xFFFFFFFF\n#define GENERATION_NUMBER_INFINITY 0xFFFFFFFF\n#define GENERATION_NUMBER_MAX 0x3FFFFFFF\n#define GENERATION_NUMBER_ZERO 0\n\nstruct commit_list {\n\tstruct commit *item;\n\tstruct commit_list *next;\n};\n\n/*\n * The size of this struct matters in full repo walk operations like\n * 'git clone' or 'git gc'. Consider using commit-slab to attach data\n * to a commit instead of adding new fields here.\n */\nstruct commit {\n\tstruct object object;\n\ttimestamp_t date;\n\tstruct commit_list *parents;\n\n\t/*\n\t * If the commit is loaded from the commit-graph file, then this\n\t * member may be NULL. Only access it through get_commit_tree()\n\t * or get_commit_tree_oid().\n\t */\n\tstruct tree *maybe_tree;\n\tuint32_t graph_pos;\n\tuint32_t generation;\n\tunsigned int index;\n};\n\nextern int save_commit_buffer;\nextern const char *commit_type;\n\n/* While we can decorate any object with a name, it's only used for commits.. */\nstruct name_decoration {\n\tstruct name_decoration *next;\n\tint type;\n\tchar name[FLEX_ARRAY];\n};\n\nenum decoration_type {\n\tDECORATION_NONE = 0,\n\tDECORATION_REF_LOCAL,\n\tDECORATION_REF_REMOTE,\n\tDECORATION_REF_TAG,\n\tDECORATION_REF_STASH,\n\tDECORATION_REF_HEAD,\n\tDECORATION_GRAFTED,\n};\n\nvoid add_name_decoration(enum decoration_type type, const char *name, struct object *obj);\nconst struct name_decoration *get_name_decoration(const struct object *obj);\n\nstruct commit *lookup_commit(const struct object_id *oid);\nstruct commit *lookup_commit_reference(const struct object_id *oid);\n#define lookup_commit_reference_gently(r, o, q) \\\n\t\tlookup_commit_reference_gently_##r(o, q)\nstruct commit *lookup_commit_reference_gently_the_repository(\n\t\t\t\t\t      const struct object_id *oid,\n\t\t\t\t\t      int quiet);\nstruct commit *lookup_commit_reference_by_name(const char *name);\n\n/*\n * Look up object named by \"oid\", dereference tag as necessary,\n * get a commit and return it. If \"oid\" does not dereference to\n * a commit, use ref_name to report an error and die.\n */\nstruct commit *lookup_commit_or_die(const struct object_id *oid, const char *ref_name);\n\nint parse_commit_buffer(struct commit *item, const void *buffer, unsigned long size, int check_graph);\nint parse_commit_gently(struct commit *item, int quiet_on_missing);\nstatic inline int parse_commit(struct commit *item)\n{\n\treturn parse_commit_gently(item, 0);\n}\nvoid parse_commit_or_die(struct commit *item);\n\n/*\n * Associate an object buffer with the commit. The ownership of the\n * memory is handed over to the commit, and must be free()-able.\n */\nvoid set_commit_buffer(struct commit *, void *buffer, unsigned long size);\n\n/*\n * Get any cached object buffer associated with the commit. Returns NULL\n * if none. The resulting memory should not be freed.\n */\nconst void *get_cached_commit_buffer(const struct commit *, unsigned long *size);\n\n/*\n * Get the commit's object contents, either from cache or by reading the object\n * from disk. The resulting memory should not be modified, and must be given\n * to unuse_commit_buffer when the caller is done.\n */\nconst void *get_commit_buffer(const struct commit *, unsigned long *size);\n\n/*\n * Tell the commit subsytem that we are done with a particular commit buffer.\n * The commit and buffer should be the input and return value, respectively,\n * from an earlier call to get_commit_buffer.  The buffer may or may not be\n * freed by this call; callers should not access the memory afterwards.\n */\nvoid unuse_commit_buffer(const struct commit *, const void *buffer);\n\n/*\n * Free any cached object buffer associated with the commit.\n */\nvoid free_commit_buffer(struct commit *);\n\nstruct tree *get_commit_tree(const struct commit *);\nstruct object_id *get_commit_tree_oid(const struct commit *);\n\n/*\n * Release memory related to a commit, including the parent list and\n * any cached object buffer.\n */\nvoid release_commit_memory(struct commit *c);\n\n/*\n * Disassociate any cached object buffer from the commit, but do not free it.\n * The buffer (or NULL, if none) is returned.\n */\nconst void *detach_commit_buffer(struct commit *, unsigned long *sizep);\n\n/* Find beginning and length of commit subject. */\nint find_commit_subject(const char *commit_buffer, const char **subject);\n\nstruct commit_list *commit_list_insert(struct commit *item,\n\t\t\t\t\tstruct commit_list **list);\nstruct commit_list **commit_list_append(struct commit *commit,\n\t\t\t\t\tstruct commit_list **next);\nunsigned commit_list_count(const struct commit_list *l);\nstruct commit_list *commit_list_insert_by_date(struct commit *item,\n\t\t\t\t    struct commit_list **list);\nvoid commit_list_sort_by_date(struct commit_list **list);\n\n/* Shallow copy of the input list */\nstruct commit_list *copy_commit_list(struct commit_list *list);\n\nvoid free_commit_list(struct commit_list *list);\n\nstruct rev_info; /* in revision.h, it circularly uses enum cmit_fmt */\n\nextern int has_non_ascii(const char *text);\nextern const char *logmsg_reencode(const struct commit *commit,\n\t\t\t\t   char **commit_encoding,\n\t\t\t\t   const char *output_encoding);\nextern const char *skip_blank_lines(const char *msg);\n\n/** Removes the first commit from a list sorted by date, and adds all\n * of its parents.\n **/\nstruct commit *pop_most_recent_commit(struct commit_list **list,\n\t\t\t\t      unsigned int mark);\n\nstruct commit *pop_commit(struct commit_list **stack);\n\nvoid clear_commit_marks(struct commit *commit, unsigned int mark);\nvoid clear_commit_marks_many(int nr, struct commit **commit, unsigned int mark);\n\n\nenum rev_sort_order {\n\tREV_SORT_IN_GRAPH_ORDER = 0,\n\tREV_SORT_BY_COMMIT_DATE,\n\tREV_SORT_BY_AUTHOR_DATE\n};\n\n/*\n * Performs an in-place topological sort of list supplied.\n *\n *   invariant of resulting list is:\n *      a reachable from b => ord(b) < ord(a)\n *   sort_order further specifies:\n *   REV_SORT_IN_GRAPH_ORDER: try to show a commit on a single-parent\n *                            chain together.\n *   REV_SORT_BY_COMMIT_DATE: show eligible commits in committer-date order.\n */\nvoid sort_in_topological_order(struct commit_list **, enum rev_sort_order);\n\nstruct commit_graft {\n\tstruct object_id oid;\n\tint nr_parent; /* < 0 if shallow commit */\n\tstruct object_id parent[FLEX_ARRAY]; /* more */\n};\ntypedef int (*each_commit_graft_fn)(const struct commit_graft *, void *);\n\nstruct commit_graft *read_graft_line(struct strbuf *line);\nint register_commit_graft(struct repository *r, struct commit_graft *, int);\nstruct commit_graft *lookup_commit_graft(struct repository *r, const struct object_id *oid);\n\nextern struct commit_list *get_merge_bases(struct commit *rev1, struct commit *rev2);\nextern struct commit_list *get_merge_bases_many(struct commit *one, int n, struct commit **twos);\nextern struct commit_list *get_octopus_merge_bases(struct commit_list *in);\n\n/* To be used only when object flags after this call no longer matter */\nextern struct commit_list *get_merge_bases_many_dirty(struct commit *one, int n, struct commit **twos);\n\n/* largest positive number a signed 32-bit integer can contain */\n#define INFINITE_DEPTH 0x7fffffff\n\nstruct oid_array;\nstruct ref;\nextern int register_shallow(struct repository *r, const struct object_id *oid);\nextern int unregister_shallow(const struct object_id *oid);\nextern int for_each_commit_graft(each_commit_graft_fn, void *);\nextern int is_repository_shallow(struct repository *r);\nextern struct commit_list *get_shallow_commits(struct object_array *heads,\n\t\tint depth, int shallow_flag, int not_shallow_flag);\nextern struct commit_list *get_shallow_commits_by_rev_list(\n\t\tint ac, const char **av, int shallow_flag, int not_shallow_flag);\nextern void set_alternate_shallow_file(struct repository *r, const char *path, int override);\nextern int write_shallow_commits(struct strbuf *out, int use_pack_protocol,\n\t\t\t\t const struct oid_array *extra);\nextern void setup_alternate_shallow(struct lock_file *shallow_lock,\n\t\t\t\t    const char **alternate_shallow_file,\n\t\t\t\t    const struct oid_array *extra);\nextern const char *setup_temporary_shallow(const struct oid_array *extra);\nextern void advertise_shallow_grafts(int);\n\nstruct shallow_info {\n\tstruct oid_array *shallow;\n\tint *ours, nr_ours;\n\tint *theirs, nr_theirs;\n\tstruct oid_array *ref;\n\n\t/* for receive-pack */\n\tuint32_t **used_shallow;\n\tint *need_reachability_test;\n\tint *reachable;\n\tint *shallow_ref;\n\tstruct commit **commits;\n\tint nr_commits;\n};\n\nextern void prepare_shallow_info(struct shallow_info *, struct oid_array *);\nextern void clear_shallow_info(struct shallow_info *);\nextern void remove_nonexistent_theirs_shallow(struct shallow_info *);\nextern void assign_shallow_commits_to_refs(struct shallow_info *info,\n\t\t\t\t\t   uint32_t **used,\n\t\t\t\t\t   int *ref_status);\nextern int delayed_reachability_test(struct shallow_info *si, int c);\nextern void prune_shallow(int show_only);\nextern struct trace_key trace_shallow;\n\nint is_descendant_of(struct commit *, struct commit_list *);\nint in_merge_bases(struct commit *, struct commit *);\nint in_merge_bases_many(struct commit *, int, struct commit **);\n\nextern int interactive_add(int argc, const char **argv, const char *prefix, int patch);\nextern int run_add_interactive(const char *revision, const char *patch_mode,\n\t\t\t       const struct pathspec *pathspec);\n\n/*\n * Takes a list of commits and returns a new list where those\n * have been removed that can be reached from other commits in\n * the list. It is useful for, e.g., reducing the commits\n * randomly thrown at the git-merge command and removing\n * redundant commits that the user shouldn't have given to it.\n *\n * This function destroys the STALE bit of the commit objects'\n * flags.\n */\nextern struct commit_list *reduce_heads(struct commit_list *heads);\n\n/*\n * Like `reduce_heads()`, except it replaces the list. Use this\n * instead of `foo = reduce_heads(foo);` to avoid memory leaks.\n */\nextern void reduce_heads_replace(struct commit_list **heads);\n\nstruct commit_extra_header {\n\tstruct commit_extra_header *next;\n\tchar *key;\n\tchar *value;\n\tsize_t len;\n};\n\nextern void append_merge_tag_headers(struct commit_list *parents,\n\t\t\t\t     struct commit_extra_header ***tail);\n\nextern int commit_tree(const char *msg, size_t msg_len,\n\t\t       const struct object_id *tree,\n\t\t       struct commit_list *parents, struct object_id *ret,\n\t\t       const char *author, const char *sign_commit);\n\nextern int commit_tree_extended(const char *msg, size_t msg_len,\n\t\t\t\tconst struct object_id *tree,\n\t\t\t\tstruct commit_list *parents,\n\t\t\t\tstruct object_id *ret, const char *author,\n\t\t\t\tconst char *sign_commit,\n\t\t\t\tstruct commit_extra_header *);\n\nextern struct commit_extra_header *read_commit_extra_headers(struct commit *, const char **);\n\nextern void free_commit_extra_headers(struct commit_extra_header *extra);\n\n/*\n * Search the commit object contents given by \"msg\" for the header \"key\".\n * Returns a pointer to the start of the header contents, or NULL. The length\n * of the header, up to the first newline, is returned via out_len.\n *\n * Note that some headers (like mergetag) may be multi-line. It is the caller's\n * responsibility to parse further in this case!\n */\nextern const char *find_commit_header(const char *msg, const char *key,\n\t\t\t\t      size_t *out_len);\n\n/* Find the end of the log message, the right place for a new trailer. */\nextern int ignore_non_trailer(const char *buf, size_t len);\n\ntypedef int (*each_mergetag_fn)(struct commit *commit, struct commit_extra_header *extra,\n\t\t\t\t void *cb_data);\n\nextern int for_each_mergetag(each_mergetag_fn fn, struct commit *commit, void *data);\n\nstruct merge_remote_desc {\n\tstruct object *obj; /* the named object, could be a tag */\n\tchar name[FLEX_ARRAY];\n};\nextern struct merge_remote_desc *merge_remote_util(struct commit *);\nextern void set_merge_remote_desc(struct commit *commit,\n\t\t\t\t  const char *name, struct object *obj);\n\n/*\n * Given \"name\" from the command line to merge, find the commit object\n * and return it, while storing merge_remote_desc in its ->util field,\n * to allow callers to tell if we are told to merge a tag.\n */\nstruct commit *get_merge_parent(const char *name);\n\nextern int parse_signed_commit(const struct commit *commit,\n\t\t\t       struct strbuf *message, struct strbuf *signature);\nextern int remove_signature(struct strbuf *buf);\n\n/*\n * Check the signature of the given commit. The result of the check is stored\n * in sig->check_result, 'G' for a good signature, 'U' for a good signature\n * from an untrusted signer, 'B' for a bad signature and 'N' for no signature\n * at all.  This may allocate memory for sig->gpg_output, sig->gpg_status,\n * sig->signer and sig->key.\n */\nextern int check_commit_signature(const struct commit *commit, struct signature_check *sigc);\n\nint compare_commits_by_commit_date(const void *a_, const void *b_, void *unused);\nint compare_commits_by_gen_then_commit_date(const void *a_, const void *b_, void *unused);\n\nLAST_ARG_MUST_BE_NULL\nextern int run_commit_hook(int editor_is_used, const char *index_file, const char *name, ...);\n\n#endif /* COMMIT_H */\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "000d194f8aac0fb2953408d257d0398f5a667216",
  "sha1_ok": true,
  "size": 13131
}
