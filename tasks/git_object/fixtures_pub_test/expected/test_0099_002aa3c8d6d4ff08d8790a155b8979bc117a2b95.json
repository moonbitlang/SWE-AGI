{
  "content": {
    "base64": "LyoKICogR0lUIC0gVGhlIGluZm9ybWF0aW9uIG1hbmFnZXIgZnJvbSBoZWxsCiAqCiAqIENvcHlyaWdodCAoQykgTGludXMgVG9ydmFsZHMsIDIwMDUKICovCgojaW5jbHVkZSAiY2FjaGUuaCIKCi8qCiAqIFRoaXMgaXMgbGlrZSBta3RpbWUsIGJ1dCB3aXRob3V0IG5vcm1hbGl6YXRpb24gb2YgdG1fd2RheSBhbmQgdG1feWRheS4KICovCnN0YXRpYyB0aW1lX3QgdG1fdG9fdGltZV90KGNvbnN0IHN0cnVjdCB0bSAqdG0pCnsKCXN0YXRpYyBjb25zdCBpbnQgbWRheXNbXSA9IHsKCSAgICAwLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNAoJfTsKCWludCB5ZWFyID0gdG0tPnRtX3llYXIgLSA3MDsKCWludCBtb250aCA9IHRtLT50bV9tb247CglpbnQgZGF5ID0gdG0tPnRtX21kYXk7CgoJaWYgKHllYXIgPCAwIHx8IHllYXIgPiAxMjkpIC8qIGFsZ28gb25seSB3b3JrcyBmb3IgMTk3MC0yMDk5ICovCgkJcmV0dXJuIC0xOwoJaWYgKG1vbnRoIDwgMCB8fCBtb250aCA+IDExKSAvKiBhcnJheSBib3VuZHMgKi8KCQlyZXR1cm4gLTE7CglpZiAobW9udGggPCAyIHx8ICh5ZWFyICsgMikgJSA0KQoJCWRheS0tOwoJaWYgKHRtLT50bV9ob3VyIDwgMCB8fCB0bS0+dG1fbWluIDwgMCB8fCB0bS0+dG1fc2VjIDwgMCkKCQlyZXR1cm4gLTE7CglyZXR1cm4gKHllYXIgKiAzNjUgKyAoeWVhciArIDEpIC8gNCArIG1kYXlzW21vbnRoXSArIGRheSkgKiAyNCo2MCo2MFVMICsKCQl0bS0+dG1faG91ciAqIDYwKjYwICsgdG0tPnRtX21pbiAqIDYwICsgdG0tPnRtX3NlYzsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKm1vbnRoX25hbWVzW10gPSB7CgkiSmFudWFyeSIsICJGZWJydWFyeSIsICJNYXJjaCIsICJBcHJpbCIsICJNYXkiLCAiSnVuZSIsCgkiSnVseSIsICJBdWd1c3QiLCAiU2VwdGVtYmVyIiwgIk9jdG9iZXIiLCAiTm92ZW1iZXIiLCAiRGVjZW1iZXIiCn07CgpzdGF0aWMgY29uc3QgY2hhciAqd2Vla2RheV9uYW1lc1tdID0gewoJIlN1bmRheXMiLCAiTW9uZGF5cyIsICJUdWVzZGF5cyIsICJXZWRuZXNkYXlzIiwgIlRodXJzZGF5cyIsICJGcmlkYXlzIiwgIlNhdHVyZGF5cyIKfTsKCnN0YXRpYyB0aW1lX3QgZ21fdGltZV90KHVuc2lnbmVkIGxvbmcgdGltZSwgaW50IHR6KQp7CglpbnQgbWludXRlczsKCgltaW51dGVzID0gdHogPCAwID8gLXR6IDogdHo7CgltaW51dGVzID0gKG1pbnV0ZXMgLyAxMDApKjYwICsgKG1pbnV0ZXMgJSAxMDApOwoJbWludXRlcyA9IHR6IDwgMCA/IC1taW51dGVzIDogbWludXRlczsKCXJldHVybiB0aW1lICsgbWludXRlcyAqIDYwOwp9CgovKgogKiBUaGUgInR6IiB0aGluZyBpcyBwYXNzZWQgaW4gYXMgdGhpcyBzdHJhbmdlICJkZWNpbWFsIHBhcnNlIG9mIHR6IgogKiB0aGluZywgd2hpY2ggbWVhbnMgdGhhdCB0eiAtMDEwMCBpcyBwYXNzZWQgaW4gYXMgdGhlIGludGVnZXIgLTEwMCwKICogZXZlbiB0aG91Z2ggaXQgbWVhbnMgInNpeHR5IG1pbnV0ZXMgb2ZmIgogKi8Kc3RhdGljIHN0cnVjdCB0bSAqdGltZV90b190bSh1bnNpZ25lZCBsb25nIHRpbWUsIGludCB0eikKewoJdGltZV90IHQgPSBnbV90aW1lX3QodGltZSwgdHopOwoJcmV0dXJuIGdtdGltZSgmdCk7Cn0KCi8qCiAqIFdoYXQgdmFsdWUgb2YgInR6IiB3YXMgaW4gZWZmZWN0IGJhY2sgdGhlbiBhdCAidGltZSIgaW4gdGhlCiAqIGxvY2FsIHRpbWV6b25lPwogKi8Kc3RhdGljIGludCBsb2NhbF90em9mZnNldCh1bnNpZ25lZCBsb25nIHRpbWUpCnsKCXRpbWVfdCB0LCB0X2xvY2FsOwoJc3RydWN0IHRtIHRtOwoJaW50IG9mZnNldCwgZWFzdHdlc3Q7CgoJdCA9IHRpbWU7Cglsb2NhbHRpbWVfcigmdCwgJnRtKTsKCXRfbG9jYWwgPSB0bV90b190aW1lX3QoJnRtKTsKCglpZiAodF9sb2NhbCA8IHQpIHsKCQllYXN0d2VzdCA9IC0xOwoJCW9mZnNldCA9IHQgLSB0X2xvY2FsOwoJfSBlbHNlIHsKCQllYXN0d2VzdCA9IDE7CgkJb2Zmc2V0ID0gdF9sb2NhbCAtIHQ7Cgl9CglvZmZzZXQgLz0gNjA7IC8qIGluIG1pbnV0ZXMgKi8KCW9mZnNldCA9IChvZmZzZXQgJSA2MCkgKyAoKG9mZnNldCAvIDYwKSAqIDEwMCk7CglyZXR1cm4gb2Zmc2V0ICogZWFzdHdlc3Q7Cn0KCmNvbnN0IGNoYXIgKnNob3dfZGF0ZV9yZWxhdGl2ZSh1bnNpZ25lZCBsb25nIHRpbWUsIGludCB0eiwKCQkJICAgICAgIGNvbnN0IHN0cnVjdCB0aW1ldmFsICpub3csCgkJCSAgICAgICBjaGFyICp0aW1lYnVmLAoJCQkgICAgICAgc2l6ZV90IHRpbWVidWZfc2l6ZSkKewoJdW5zaWduZWQgbG9uZyBkaWZmOwoJaWYgKG5vdy0+dHZfc2VjIDwgdGltZSkKCQlyZXR1cm4gImluIHRoZSBmdXR1cmUiOwoJZGlmZiA9IG5vdy0+dHZfc2VjIC0gdGltZTsKCWlmIChkaWZmIDwgOTApIHsKCQlzbnByaW50Zih0aW1lYnVmLCB0aW1lYnVmX3NpemUsICIlbHUgc2Vjb25kcyBhZ28iLCBkaWZmKTsKCQlyZXR1cm4gdGltZWJ1ZjsKCX0KCS8qIFR1cm4gaXQgaW50byBtaW51dGVzICovCglkaWZmID0gKGRpZmYgKyAzMCkgLyA2MDsKCWlmIChkaWZmIDwgOTApIHsKCQlzbnByaW50Zih0aW1lYnVmLCB0aW1lYnVmX3NpemUsICIlbHUgbWludXRlcyBhZ28iLCBkaWZmKTsKCQlyZXR1cm4gdGltZWJ1ZjsKCX0KCS8qIFR1cm4gaXQgaW50byBob3VycyAqLwoJZGlmZiA9IChkaWZmICsgMzApIC8gNjA7CglpZiAoZGlmZiA8IDM2KSB7CgkJc25wcmludGYodGltZWJ1ZiwgdGltZWJ1Zl9zaXplLCAiJWx1IGhvdXJzIGFnbyIsIGRpZmYpOwoJCXJldHVybiB0aW1lYnVmOwoJfQoJLyogV2UgZGVhbCB3aXRoIG51bWJlciBvZiBkYXlzIGZyb20gaGVyZSBvbiAqLwoJZGlmZiA9IChkaWZmICsgMTIpIC8gMjQ7CglpZiAoZGlmZiA8IDE0KSB7CgkJc25wcmludGYodGltZWJ1ZiwgdGltZWJ1Zl9zaXplLCAiJWx1IGRheXMgYWdvIiwgZGlmZik7CgkJcmV0dXJuIHRpbWVidWY7Cgl9CgkvKiBTYXkgd2Vla3MgZm9yIHRoZSBwYXN0IDEwIHdlZWtzIG9yIHNvICovCglpZiAoZGlmZiA8IDcwKSB7CgkJc25wcmludGYodGltZWJ1ZiwgdGltZWJ1Zl9zaXplLCAiJWx1IHdlZWtzIGFnbyIsIChkaWZmICsgMykgLyA3KTsKCQlyZXR1cm4gdGltZWJ1ZjsKCX0KCS8qIFNheSBtb250aHMgZm9yIHRoZSBwYXN0IDEyIG1vbnRocyBvciBzbyAqLwoJaWYgKGRpZmYgPCAzNjUpIHsKCQlzbnByaW50Zih0aW1lYnVmLCB0aW1lYnVmX3NpemUsICIlbHUgbW9udGhzIGFnbyIsIChkaWZmICsgMTUpIC8gMzApOwoJCXJldHVybiB0aW1lYnVmOwoJfQoJLyogR2l2ZSB5ZWFycyBhbmQgbW9udGhzIGZvciA1IHllYXJzIG9yIHNvICovCglpZiAoZGlmZiA8IDE4MjUpIHsKCQl1bnNpZ25lZCBsb25nIHllYXJzID0gZGlmZiAvIDM2NTsKCQl1bnNpZ25lZCBsb25nIG1vbnRocyA9IChkaWZmICUgMzY1ICsgMTUpIC8gMzA7CgkJaW50IG47CgkJbiA9IHNucHJpbnRmKHRpbWVidWYsIHRpbWVidWZfc2l6ZSwgIiVsdSB5ZWFyJXMiLAoJCQkJeWVhcnMsICh5ZWFycyA+IDEgPyAicyIgOiAiIikpOwoJCWlmIChtb250aHMpCgkJCXNucHJpbnRmKHRpbWVidWYgKyBuLCB0aW1lYnVmX3NpemUgLSBuLAoJCQkJCSIsICVsdSBtb250aCVzIGFnbyIsCgkJCQkJbW9udGhzLCAobW9udGhzID4gMSA/ICJzIiA6ICIiKSk7CgkJZWxzZQoJCQlzbnByaW50Zih0aW1lYnVmICsgbiwgdGltZWJ1Zl9zaXplIC0gbiwgIiBhZ28iKTsKCQlyZXR1cm4gdGltZWJ1ZjsKCX0KCS8qIE90aGVyd2lzZSwganVzdCB5ZWFycy4gQ2VudHVyaWVzIGlzIHByb2JhYmx5IG92ZXJraWxsLiAqLwoJc25wcmludGYodGltZWJ1ZiwgdGltZWJ1Zl9zaXplLCAiJWx1IHllYXJzIGFnbyIsIChkaWZmICsgMTgzKSAvIDM2NSk7CglyZXR1cm4gdGltZWJ1ZjsKfQoKY29uc3QgY2hhciAqc2hvd19kYXRlKHVuc2lnbmVkIGxvbmcgdGltZSwgaW50IHR6LCBlbnVtIGRhdGVfbW9kZSBtb2RlKQp7CglzdHJ1Y3QgdG0gKnRtOwoJc3RhdGljIGNoYXIgdGltZWJ1ZlsyMDBdOwoKCWlmIChtb2RlID09IERBVEVfUkFXKSB7CgkJc25wcmludGYodGltZWJ1Ziwgc2l6ZW9mKHRpbWVidWYpLCAiJWx1ICUrMDVkIiwgdGltZSwgdHopOwoJCXJldHVybiB0aW1lYnVmOwoJfQoKCWlmIChtb2RlID09IERBVEVfUkVMQVRJVkUpIHsKCQlzdHJ1Y3QgdGltZXZhbCBub3c7CgkJZ2V0dGltZW9mZGF5KCZub3csIE5VTEwpOwoJCXJldHVybiBzaG93X2RhdGVfcmVsYXRpdmUodGltZSwgdHosICZub3csCgkJCQkJICB0aW1lYnVmLCBzaXplb2YodGltZWJ1ZikpOwoJfQoKCWlmIChtb2RlID09IERBVEVfTE9DQUwpCgkJdHogPSBsb2NhbF90em9mZnNldCh0aW1lKTsKCgl0bSA9IHRpbWVfdG9fdG0odGltZSwgdHopOwoJaWYgKCF0bSkKCQlyZXR1cm4gTlVMTDsKCWlmIChtb2RlID09IERBVEVfU0hPUlQpCgkJc3ByaW50Zih0aW1lYnVmLCAiJTA0ZC0lMDJkLSUwMmQiLCB0bS0+dG1feWVhciArIDE5MDAsCgkJCQl0bS0+dG1fbW9uICsgMSwgdG0tPnRtX21kYXkpOwoJZWxzZSBpZiAobW9kZSA9PSBEQVRFX0lTTzg2MDEpCgkJc3ByaW50Zih0aW1lYnVmLCAiJTA0ZC0lMDJkLSUwMmQgJTAyZDolMDJkOiUwMmQgJSswNWQiLAoJCQkJdG0tPnRtX3llYXIgKyAxOTAwLAoJCQkJdG0tPnRtX21vbiArIDEsCgkJCQl0bS0+dG1fbWRheSwKCQkJCXRtLT50bV9ob3VyLCB0bS0+dG1fbWluLCB0bS0+dG1fc2VjLAoJCQkJdHopOwoJZWxzZSBpZiAobW9kZSA9PSBEQVRFX1JGQzI4MjIpCgkJc3ByaW50Zih0aW1lYnVmLCAiJS4zcywgJWQgJS4zcyAlZCAlMDJkOiUwMmQ6JTAyZCAlKzA1ZCIsCgkJCXdlZWtkYXlfbmFtZXNbdG0tPnRtX3dkYXldLCB0bS0+dG1fbWRheSwKCQkJbW9udGhfbmFtZXNbdG0tPnRtX21vbl0sIHRtLT50bV95ZWFyICsgMTkwMCwKCQkJdG0tPnRtX2hvdXIsIHRtLT50bV9taW4sIHRtLT50bV9zZWMsIHR6KTsKCWVsc2UKCQlzcHJpbnRmKHRpbWVidWYsICIlLjNzICUuM3MgJWQgJTAyZDolMDJkOiUwMmQgJWQlYyUrMDVkIiwKCQkJCXdlZWtkYXlfbmFtZXNbdG0tPnRtX3dkYXldLAoJCQkJbW9udGhfbmFtZXNbdG0tPnRtX21vbl0sCgkJCQl0bS0+dG1fbWRheSwKCQkJCXRtLT50bV9ob3VyLCB0bS0+dG1fbWluLCB0bS0+dG1fc2VjLAoJCQkJdG0tPnRtX3llYXIgKyAxOTAwLAoJCQkJKG1vZGUgPT0gREFURV9MT0NBTCkgPyAwIDogJyAnLAoJCQkJdHopOwoJcmV0dXJuIHRpbWVidWY7Cn0KCi8qCiAqIENoZWNrIHRoZXNlLiBBbmQgbm90ZSBob3cgaXQgZG9lc24ndCBkbyB0aGUgc3VtbWVyLXRpbWUgY29udmVyc2lvbi4KICoKICogSW4gbXkgd29ybGQsIGl0J3MgYWx3YXlzIHN1bW1lciwgYW5kIHRoaW5ncyBhcmUgcHJvYmFibHkgYSBiaXQgb2ZmCiAqIGluIG90aGVyIHdheXMgdG9vLgogKi8Kc3RhdGljIGNvbnN0IHN0cnVjdCB7Cgljb25zdCBjaGFyICpuYW1lOwoJaW50IG9mZnNldDsKCWludCBkc3Q7Cn0gdGltZXpvbmVfbmFtZXNbXSA9IHsKCXsgIklETFciLCAtMTIsIDAsIH0sCS8qIEludGVybmF0aW9uYWwgRGF0ZSBMaW5lIFdlc3QgKi8KCXsgIk5UIiwgICAtMTEsIDAsIH0sCS8qIE5vbWUgKi8KCXsgIkNBVCIsICAtMTAsIDAsIH0sCS8qIENlbnRyYWwgQWxhc2thICovCgl7ICJIU1QiLCAgLTEwLCAwLCB9LAkvKiBIYXdhaWkgU3RhbmRhcmQgKi8KCXsgIkhEVCIsICAtMTAsIDEsIH0sCS8qIEhhd2FpaSBEYXlsaWdodCAqLwoJeyAiWVNUIiwgICAtOSwgMCwgfSwJLyogWXVrb24gU3RhbmRhcmQgKi8KCXsgIllEVCIsICAgLTksIDEsIH0sCS8qIFl1a29uIERheWxpZ2h0ICovCgl7ICJQU1QiLCAgIC04LCAwLCB9LAkvKiBQYWNpZmljIFN0YW5kYXJkICovCgl7ICJQRFQiLCAgIC04LCAxLCB9LAkvKiBQYWNpZmljIERheWxpZ2h0ICovCgl7ICJNU1QiLCAgIC03LCAwLCB9LAkvKiBNb3VudGFpbiBTdGFuZGFyZCAqLwoJeyAiTURUIiwgICAtNywgMSwgfSwJLyogTW91bnRhaW4gRGF5bGlnaHQgKi8KCXsgIkNTVCIsICAgLTYsIDAsIH0sCS8qIENlbnRyYWwgU3RhbmRhcmQgKi8KCXsgIkNEVCIsICAgLTYsIDEsIH0sCS8qIENlbnRyYWwgRGF5bGlnaHQgKi8KCXsgIkVTVCIsICAgLTUsIDAsIH0sCS8qIEVhc3Rlcm4gU3RhbmRhcmQgKi8KCXsgIkVEVCIsICAgLTUsIDEsIH0sCS8qIEVhc3Rlcm4gRGF5bGlnaHQgKi8KCXsgIkFTVCIsICAgLTMsIDAsIH0sCS8qIEF0bGFudGljIFN0YW5kYXJkICovCgl7ICJBRFQiLCAgIC0zLCAxLCB9LAkvKiBBdGxhbnRpYyBEYXlsaWdodCAqLwoJeyAiV0FUIiwgICAtMSwgMCwgfSwJLyogV2VzdCBBZnJpY2EgKi8KCgl7ICJHTVQiLCAgICAwLCAwLCB9LAkvKiBHcmVlbndpY2ggTWVhbiAqLwoJeyAiVVRDIiwgICAgMCwgMCwgfSwJLyogVW5pdmVyc2FsIChDb29yZGluYXRlZCkgKi8KCgl7ICJXRVQiLCAgICAwLCAwLCB9LAkvKiBXZXN0ZXJuIEV1cm9wZWFuICovCgl7ICJCU1QiLCAgICAwLCAxLCB9LAkvKiBCcml0aXNoIFN1bW1lciAqLwoJeyAiQ0VUIiwgICArMSwgMCwgfSwJLyogQ2VudHJhbCBFdXJvcGVhbiAqLwoJeyAiTUVUIiwgICArMSwgMCwgfSwJLyogTWlkZGxlIEV1cm9wZWFuICovCgl7ICJNRVdUIiwgICsxLCAwLCB9LAkvKiBNaWRkbGUgRXVyb3BlYW4gV2ludGVyICovCgl7ICJNRVNUIiwgICsxLCAxLCB9LAkvKiBNaWRkbGUgRXVyb3BlYW4gU3VtbWVyICovCgl7ICJDRVNUIiwgICsxLCAxLCB9LAkvKiBDZW50cmFsIEV1cm9wZWFuIFN1bW1lciAqLwoJeyAiTUVTWiIsICArMSwgMSwgfSwJLyogTWlkZGxlIEV1cm9wZWFuIFN1bW1lciAqLwoJeyAiRldUIiwgICArMSwgMCwgfSwJLyogRnJlbmNoIFdpbnRlciAqLwoJeyAiRlNUIiwgICArMSwgMSwgfSwJLyogRnJlbmNoIFN1bW1lciAqLwoJeyAiRUVUIiwgICArMiwgMCwgfSwJLyogRWFzdGVybiBFdXJvcGUsIFVTU1IgWm9uZSAxICovCgl7ICJFRVNUIiwgICsyLCAxLCB9LAkvKiBFYXN0ZXJuIEV1cm9wZWFuIERheWxpZ2h0ICovCgl7ICJXQVNUIiwgICs3LCAwLCB9LAkvKiBXZXN0IEF1c3RyYWxpYW4gU3RhbmRhcmQgKi8KCXsgIldBRFQiLCAgKzcsIDEsIH0sCS8qIFdlc3QgQXVzdHJhbGlhbiBEYXlsaWdodCAqLwoJeyAiQ0NUIiwgICArOCwgMCwgfSwJLyogQ2hpbmEgQ29hc3QsIFVTU1IgWm9uZSA3ICovCgl7ICJKU1QiLCAgICs5LCAwLCB9LAkvKiBKYXBhbiBTdGFuZGFyZCwgVVNTUiBab25lIDggKi8KCXsgIkVBU1QiLCArMTAsIDAsIH0sCS8qIEVhc3Rlcm4gQXVzdHJhbGlhbiBTdGFuZGFyZCAqLwoJeyAiRUFEVCIsICsxMCwgMSwgfSwJLyogRWFzdGVybiBBdXN0cmFsaWFuIERheWxpZ2h0ICovCgl7ICJHU1QiLCAgKzEwLCAwLCB9LAkvKiBHdWFtIFN0YW5kYXJkLCBVU1NSIFpvbmUgOSAqLwoJeyAiTlpUIiwgICsxMiwgMCwgfSwJLyogTmV3IFplYWxhbmQgKi8KCXsgIk5aU1QiLCArMTIsIDAsIH0sCS8qIE5ldyBaZWFsYW5kIFN0YW5kYXJkICovCgl7ICJOWkRUIiwgKzEyLCAxLCB9LAkvKiBOZXcgWmVhbGFuZCBEYXlsaWdodCAqLwoJeyAiSURMRSIsICsxMiwgMCwgfSwJLyogSW50ZXJuYXRpb25hbCBEYXRlIExpbmUgRWFzdCAqLwp9OwoKc3RhdGljIGludCBtYXRjaF9zdHJpbmcoY29uc3QgY2hhciAqZGF0ZSwgY29uc3QgY2hhciAqc3RyKQp7CglpbnQgaSA9IDA7CgoJZm9yIChpID0gMDsgKmRhdGU7IGRhdGUrKywgc3RyKyssIGkrKykgewoJCWlmICgqZGF0ZSA9PSAqc3RyKQoJCQljb250aW51ZTsKCQlpZiAodG91cHBlcigqZGF0ZSkgPT0gdG91cHBlcigqc3RyKSkKCQkJY29udGludWU7CgkJaWYgKCFpc2FsbnVtKCpkYXRlKSkKCQkJYnJlYWs7CgkJcmV0dXJuIDA7Cgl9CglyZXR1cm4gaTsKfQoKc3RhdGljIGludCBza2lwX2FscGhhKGNvbnN0IGNoYXIgKmRhdGUpCnsKCWludCBpID0gMDsKCWRvIHsKCQlpKys7Cgl9IHdoaWxlIChpc2FscGhhKGRhdGVbaV0pKTsKCXJldHVybiBpOwp9CgovKgoqIFBhcnNlIG1vbnRoLCB3ZWVrZGF5LCBvciB0aW1lem9uZSBuYW1lCiovCnN0YXRpYyBpbnQgbWF0Y2hfYWxwaGEoY29uc3QgY2hhciAqZGF0ZSwgc3RydWN0IHRtICp0bSwgaW50ICpvZmZzZXQpCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7CgkJaW50IG1hdGNoID0gbWF0Y2hfc3RyaW5nKGRhdGUsIG1vbnRoX25hbWVzW2ldKTsKCQlpZiAobWF0Y2ggPj0gMykgewoJCQl0bS0+dG1fbW9uID0gaTsKCQkJcmV0dXJuIG1hdGNoOwoJCX0KCX0KCglmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7CgkJaW50IG1hdGNoID0gbWF0Y2hfc3RyaW5nKGRhdGUsIHdlZWtkYXlfbmFtZXNbaV0pOwoJCWlmIChtYXRjaCA+PSAzKSB7CgkJCXRtLT50bV93ZGF5ID0gaTsKCQkJcmV0dXJuIG1hdGNoOwoJCX0KCX0KCglmb3IgKGkgPSAwOyBpIDwgQVJSQVlfU0laRSh0aW1lem9uZV9uYW1lcyk7IGkrKykgewoJCWludCBtYXRjaCA9IG1hdGNoX3N0cmluZyhkYXRlLCB0aW1lem9uZV9uYW1lc1tpXS5uYW1lKTsKCQlpZiAobWF0Y2ggPj0gMykgewoJCQlpbnQgb2ZmID0gdGltZXpvbmVfbmFtZXNbaV0ub2Zmc2V0OwoKCQkJLyogVGhpcyBpcyBib2d1cywgYnV0IHdlIGxpa2Ugc3VtbWVyICovCgkJCW9mZiArPSB0aW1lem9uZV9uYW1lc1tpXS5kc3Q7CgoJCQkvKiBPbmx5IHVzZSB0aGUgdHogbmFtZSBvZmZzZXQgaWYgd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyBiZXR0ZXIgKi8KCQkJaWYgKCpvZmZzZXQgPT0gLTEpCgkJCQkqb2Zmc2V0ID0gNjAqb2ZmOwoKCQkJcmV0dXJuIG1hdGNoOwoJCX0KCX0KCglpZiAobWF0Y2hfc3RyaW5nKGRhdGUsICJQTSIpID09IDIpIHsKCQl0bS0+dG1faG91ciA9ICh0bS0+dG1faG91ciAlIDEyKSArIDEyOwoJCXJldHVybiAyOwoJfQoKCWlmIChtYXRjaF9zdHJpbmcoZGF0ZSwgIkFNIikgPT0gMikgewoJCXRtLT50bV9ob3VyID0gKHRtLT50bV9ob3VyICUgMTIpICsgMDsKCQlyZXR1cm4gMjsKCX0KCgkvKiBCQUQgQ1JBUCAqLwoJcmV0dXJuIHNraXBfYWxwaGEoZGF0ZSk7Cn0KCnN0YXRpYyBpbnQgaXNfZGF0ZShpbnQgeWVhciwgaW50IG1vbnRoLCBpbnQgZGF5LCBzdHJ1Y3QgdG0gKm5vd190bSwgdGltZV90IG5vdywgc3RydWN0IHRtICp0bSkKewoJaWYgKG1vbnRoID4gMCAmJiBtb250aCA8IDEzICYmIGRheSA+IDAgJiYgZGF5IDwgMzIpIHsKCQlzdHJ1Y3QgdG0gY2hlY2sgPSAqdG07CgkJc3RydWN0IHRtICpyID0gKG5vd190bSA/ICZjaGVjayA6IHRtKTsKCQl0aW1lX3Qgc3BlY2lmaWVkOwoKCQlyLT50bV9tb24gPSBtb250aCAtIDE7CgkJci0+dG1fbWRheSA9IGRheTsKCQlpZiAoeWVhciA9PSAtMSkgewoJCQlpZiAoIW5vd190bSkKCQkJCXJldHVybiAxOwoJCQlyLT50bV95ZWFyID0gbm93X3RtLT50bV95ZWFyOwoJCX0KCQllbHNlIGlmICh5ZWFyID49IDE5NzAgJiYgeWVhciA8IDIxMDApCgkJCXItPnRtX3llYXIgPSB5ZWFyIC0gMTkwMDsKCQllbHNlIGlmICh5ZWFyID4gNzAgJiYgeWVhciA8IDEwMCkKCQkJci0+dG1feWVhciA9IHllYXI7CgkJZWxzZSBpZiAoeWVhciA8IDM4KQoJCQlyLT50bV95ZWFyID0geWVhciArIDEwMDsKCQllbHNlCgkJCXJldHVybiAwOwoJCWlmICghbm93X3RtKQoJCQlyZXR1cm4gMTsKCgkJc3BlY2lmaWVkID0gdG1fdG9fdGltZV90KHIpOwoKCQkvKiBCZSBpdCBjb21taXQgdGltZSBvciBhdXRob3IgdGltZSwgaXQgZG9lcyBub3QgbWFrZQoJCSAqIHNlbnNlIHRvIHNwZWNpZnkgdGltZXN0YW1wIHdheSBpbnRvIHRoZSBmdXR1cmUuICBNYWtlCgkJICogc3VyZSBpdCBpcyBub3QgbGF0ZXIgdGhhbiB0ZW4gZGF5cyBmcm9tIG5vdy4uLgoJCSAqLwoJCWlmIChub3cgKyAxMCoyNCozNjAwIDwgc3BlY2lmaWVkKQoJCQlyZXR1cm4gMDsKCQl0bS0+dG1fbW9uID0gci0+dG1fbW9uOwoJCXRtLT50bV9tZGF5ID0gci0+dG1fbWRheTsKCQlpZiAoeWVhciAhPSAtMSkKCQkJdG0tPnRtX3llYXIgPSByLT50bV95ZWFyOwoJCXJldHVybiAxOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgbWF0Y2hfbXVsdGlfbnVtYmVyKHVuc2lnbmVkIGxvbmcgbnVtLCBjaGFyIGMsIGNvbnN0IGNoYXIgKmRhdGUsIGNoYXIgKmVuZCwgc3RydWN0IHRtICp0bSkKewoJdGltZV90IG5vdzsKCXN0cnVjdCB0bSBub3dfdG07CglzdHJ1Y3QgdG0gKnJlZnVzZV9mdXR1cmU7Cglsb25nIG51bTIsIG51bTM7CgoJbnVtMiA9IHN0cnRvbChlbmQrMSwgJmVuZCwgMTApOwoJbnVtMyA9IC0xOwoJaWYgKCplbmQgPT0gYyAmJiBpc2RpZ2l0KGVuZFsxXSkpCgkJbnVtMyA9IHN0cnRvbChlbmQrMSwgJmVuZCwgMTApOwoKCS8qIFRpbWU/IERhdGU/ICovCglzd2l0Y2ggKGMpIHsKCWNhc2UgJzonOgoJCWlmIChudW0zIDwgMCkKCQkJbnVtMyA9IDA7CgkJaWYgKG51bSA8IDI1ICYmIG51bTIgPj0gMCAmJiBudW0yIDwgNjAgJiYgbnVtMyA+PSAwICYmIG51bTMgPD0gNjApIHsKCQkJdG0tPnRtX2hvdXIgPSBudW07CgkJCXRtLT50bV9taW4gPSBudW0yOwoJCQl0bS0+dG1fc2VjID0gbnVtMzsKCQkJYnJlYWs7CgkJfQoJCXJldHVybiAwOwoKCWNhc2UgJy0nOgoJY2FzZSAnLyc6CgljYXNlICcuJzoKCQlub3cgPSB0aW1lKE5VTEwpOwoJCXJlZnVzZV9mdXR1cmUgPSBOVUxMOwoJCWlmIChnbXRpbWVfcigmbm93LCAmbm93X3RtKSkKCQkJcmVmdXNlX2Z1dHVyZSA9ICZub3dfdG07CgoJCWlmIChudW0gPiA3MCkgewoJCQkvKiB5eXl5LW1tLWRkPyAqLwoJCQlpZiAoaXNfZGF0ZShudW0sIG51bTIsIG51bTMsIHJlZnVzZV9mdXR1cmUsIG5vdywgdG0pKQoJCQkJYnJlYWs7CgkJCS8qIHl5eXktZGQtbW0/ICovCgkJCWlmIChpc19kYXRlKG51bSwgbnVtMywgbnVtMiwgcmVmdXNlX2Z1dHVyZSwgbm93LCB0bSkpCgkJCQlicmVhazsKCQl9CgkJLyogT3VyIGVhc3Rlcm4gRXVyb3BlYW4gZnJpZW5kcyBzYXkgZGQubW0ueXlbeXldCgkJICogaXMgdGhlIG5vcm0gdGhlcmUsIHNvIGdpdmluZyBwcmVjZWRlbmNlIHRvCgkJICogbW0vZGQveXlbeXldIGZvcm0gb25seSB3aGVuIHNlcGFyYXRvciBpcyBub3QgJy4nCgkJICovCgkJaWYgKGMgIT0gJy4nICYmCgkJICAgIGlzX2RhdGUobnVtMywgbnVtLCBudW0yLCByZWZ1c2VfZnV0dXJlLCBub3csIHRtKSkKCQkJYnJlYWs7CgkJLyogRXVyb3BlYW4gZGQubW0ueXlbeXldIG9yIGZ1bm55IFVTIGRkL21tL3l5W3l5XSAqLwoJCWlmIChpc19kYXRlKG51bTMsIG51bTIsIG51bSwgcmVmdXNlX2Z1dHVyZSwgbm93LCB0bSkpCgkJCWJyZWFrOwoJCS8qIEZ1bm55IEV1cm9wZWFuIG1tLmRkLnl5ICovCgkJaWYgKGMgPT0gJy4nICYmCgkJICAgIGlzX2RhdGUobnVtMywgbnVtLCBudW0yLCByZWZ1c2VfZnV0dXJlLCBub3csIHRtKSkKCQkJYnJlYWs7CgkJcmV0dXJuIDA7Cgl9CglyZXR1cm4gZW5kIC0gZGF0ZTsKfQoKLyoKICogSGF2ZSB3ZSBmaWxsZWQgaW4gYW55IHBhcnQgb2YgdGhlIHRpbWUvZGF0ZSB5ZXQ/CiAqIFdlIGp1c3QgZG8gYSBiaW5hcnkgJ2FuZCcgdG8gc2VlIGlmIHRoZSBzaWduIGJpdAogKiBpcyBzZXQgaW4gYWxsIHRoZSB2YWx1ZXMuCiAqLwpzdGF0aWMgaW5saW5lIGludCBub2RhdGUoc3RydWN0IHRtICp0bSkKewoJcmV0dXJuICh0bS0+dG1feWVhciAmCgkJdG0tPnRtX21vbiAmCgkJdG0tPnRtX21kYXkgJgoJCXRtLT50bV9ob3VyICYKCQl0bS0+dG1fbWluICYKCQl0bS0+dG1fc2VjKSA8IDA7Cn0KCi8qCiAqIFdlJ3ZlIHNlZW4gYSBkaWdpdC4gVGltZT8gWWVhcj8gRGF0ZT8KICovCnN0YXRpYyBpbnQgbWF0Y2hfZGlnaXQoY29uc3QgY2hhciAqZGF0ZSwgc3RydWN0IHRtICp0bSwgaW50ICpvZmZzZXQsIGludCAqdG1fZ210KQp7CglpbnQgbjsKCWNoYXIgKmVuZDsKCXVuc2lnbmVkIGxvbmcgbnVtOwoKCW51bSA9IHN0cnRvdWwoZGF0ZSwgJmVuZCwgMTApOwoKCS8qCgkgKiBTZWNvbmRzIHNpbmNlIDE5NzA/IFdlIHRyaWdnZXIgb24gdGhhdCBmb3IgYW55IG51bWJlcnMgd2l0aAoJICogbW9yZSB0aGFuIDggZGlnaXRzLiBUaGlzIGlzIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBydWxlIG91dAoJICogbnVtYmVycyBsaWtlIDIwMDcwNjA2IGFzIGEgWVlZWU1NREQgZGF0ZS4KCSAqLwoJaWYgKG51bSA+PSAxMDAwMDAwMDAgJiYgbm9kYXRlKHRtKSkgewoJCXRpbWVfdCB0aW1lID0gbnVtOwoJCWlmIChnbXRpbWVfcigmdGltZSwgdG0pKSB7CgkJCSp0bV9nbXQgPSAxOwoJCQlyZXR1cm4gZW5kIC0gZGF0ZTsKCQl9Cgl9CgoJLyoKCSAqIENoZWNrIGZvciBzcGVjaWFsIGZvcm1hdHM6IG51bVstLjovXW51bVtzYW1lXW51bQoJICovCglzd2l0Y2ggKCplbmQpIHsKCWNhc2UgJzonOgoJY2FzZSAnLic6CgljYXNlICcvJzoKCWNhc2UgJy0nOgoJCWlmIChpc2RpZ2l0KGVuZFsxXSkpIHsKCQkJaW50IG1hdGNoID0gbWF0Y2hfbXVsdGlfbnVtYmVyKG51bSwgKmVuZCwgZGF0ZSwgZW5kLCB0bSk7CgkJCWlmIChtYXRjaCkKCQkJCXJldHVybiBtYXRjaDsKCQl9Cgl9CgoJLyoKCSAqIE5vbmUgb2YgdGhlIHNwZWNpYWwgZm9ybWF0cz8gVHJ5IHRvIGd1ZXNzIHdoYXQKCSAqIHRoZSBudW1iZXIgbWVhbnQuIFdlIHVzZSB0aGUgbnVtYmVyIG9mIGRpZ2l0cwoJICogdG8gbWFrZSBhIG1vcmUgZWR1Y2F0ZWQgZ3Vlc3MuLgoJICovCgluID0gMDsKCWRvIHsKCQluKys7Cgl9IHdoaWxlIChpc2RpZ2l0KGRhdGVbbl0pKTsKCgkvKiBGb3VyLWRpZ2l0IHllYXIgb3IgYSB0aW1lem9uZT8gKi8KCWlmIChuID09IDQpIHsKCQlpZiAobnVtIDw9IDE0MDAgJiYgKm9mZnNldCA9PSAtMSkgewoJCQl1bnNpZ25lZCBpbnQgbWludXRlcyA9IG51bSAlIDEwMDsKCQkJdW5zaWduZWQgaW50IGhvdXJzID0gbnVtIC8gMTAwOwoJCQkqb2Zmc2V0ID0gaG91cnMqNjAgKyBtaW51dGVzOwoJCX0gZWxzZSBpZiAobnVtID4gMTkwMCAmJiBudW0gPCAyMTAwKQoJCQl0bS0+dG1feWVhciA9IG51bSAtIDE5MDA7CgkJcmV0dXJuIG47Cgl9CgoJLyoKCSAqIElnbm9yZSBsb3RzIG9mIG51bWVyYWxzLiBXZSB0b29rIGNhcmUgb2YgNC1kaWdpdCB5ZWFycyBhYm92ZS4KCSAqIERheXMgb3IgbW9udGhzIG11c3QgYmUgb25lIG9yIHR3byBkaWdpdHMuCgkgKi8KCWlmIChuID4gMikKCQlyZXR1cm4gbjsKCgkvKgoJICogTk9URSEgV2Ugd2lsbCBnaXZlIHByZWNlZGVuY2UgdG8gZGF5LW9mLW1vbnRoIG92ZXIgbW9udGggb3IKCSAqIHllYXIgbnVtYmVycyBpbiB0aGUgMS0xMiByYW5nZS4gU28gMDUgaXMgYWx3YXlzICJtZGF5IDUiLAoJICogdW5sZXNzIHdlIGFscmVhZHkgaGF2ZSBhIG1kYXkuLgoJICoKCSAqIElPVywgMDEgQXByIDA1IHBhcnNlcyBhcyAiQXByaWwgMXN0LCAyMDA1Ii4KCSAqLwoJaWYgKG51bSA+IDAgJiYgbnVtIDwgMzIgJiYgdG0tPnRtX21kYXkgPCAwKSB7CgkJdG0tPnRtX21kYXkgPSBudW07CgkJcmV0dXJuIG47Cgl9CgoJLyogVHdvLWRpZ2l0IHllYXI/ICovCglpZiAobiA9PSAyICYmIHRtLT50bV95ZWFyIDwgMCkgewoJCWlmIChudW0gPCAxMCAmJiB0bS0+dG1fbWRheSA+PSAwKSB7CgkJCXRtLT50bV95ZWFyID0gbnVtICsgMTAwOwoJCQlyZXR1cm4gbjsKCQl9CgkJaWYgKG51bSA+PSA3MCkgewoJCQl0bS0+dG1feWVhciA9IG51bTsKCQkJcmV0dXJuIG47CgkJfQoJfQoKCWlmIChudW0gPiAwICYmIG51bSA8IDEzICYmIHRtLT50bV9tb24gPCAwKQoJCXRtLT50bV9tb24gPSBudW0tMTsKCglyZXR1cm4gbjsKfQoKc3RhdGljIGludCBtYXRjaF90eihjb25zdCBjaGFyICpkYXRlLCBpbnQgKm9mZnApCnsKCWNoYXIgKmVuZDsKCWludCBvZmZzZXQgPSBzdHJ0b3VsKGRhdGUrMSwgJmVuZCwgMTApOwoJaW50IG1pbiwgaG91cjsKCWludCBuID0gZW5kIC0gZGF0ZSAtIDE7CgoJbWluID0gb2Zmc2V0ICUgMTAwOwoJaG91ciA9IG9mZnNldCAvIDEwMDsKCgkvKgoJICogRG9uJ3QgYWNjZXB0IGFueSByYW5kb20gY3JhcC4uIEF0IGxlYXN0IDMgZGlnaXRzLCBhbmQKCSAqIGEgdmFsaWQgbWludXRlLiBXZSBtaWdodCB3YW50IHRvIGNoZWNrIHRoYXQgdGhlIG1pbnV0ZXMKCSAqIGFyZSBkaXZpc2libGUgYnkgMzAgb3Igc29tZXRoaW5nIHRvby4KCSAqLwoJaWYgKG1pbiA8IDYwICYmIG4gPiAyKSB7CgkJb2Zmc2V0ID0gaG91cio2MCttaW47CgkJaWYgKCpkYXRlID09ICctJykKCQkJb2Zmc2V0ID0gLW9mZnNldDsKCgkJKm9mZnAgPSBvZmZzZXQ7Cgl9CglyZXR1cm4gZW5kIC0gZGF0ZTsKfQoKc3RhdGljIGludCBkYXRlX3N0cmluZyh1bnNpZ25lZCBsb25nIGRhdGUsIGludCBvZmZzZXQsIGNoYXIgKmJ1ZiwgaW50IGxlbikKewoJaW50IHNpZ24gPSAnKyc7CgoJaWYgKG9mZnNldCA8IDApIHsKCQlvZmZzZXQgPSAtb2Zmc2V0OwoJCXNpZ24gPSAnLSc7Cgl9CglyZXR1cm4gc25wcmludGYoYnVmLCBsZW4sICIlbHUgJWMlMDJkJTAyZCIsIGRhdGUsIHNpZ24sIG9mZnNldCAvIDYwLCBvZmZzZXQgJSA2MCk7Cn0KCi8qIEdyLiBzdHJwdGltZSBpcyBjcmFwIGZvciB0aGlzOyBpdCBkb2Vzbid0IGhhdmUgYSB3YXkgdG8gcmVxdWlyZSBSRkMyODIyCiAgIChpLmUuIEVuZ2xpc2gpIGRheS9tb250aCBuYW1lcywgYW5kIGl0IGRvZXNuJ3Qgd29yayBjb3JyZWN0bHkgd2l0aCAlei4gKi8KaW50IHBhcnNlX2RhdGUoY29uc3QgY2hhciAqZGF0ZSwgY2hhciAqcmVzdWx0LCBpbnQgbWF4bGVuKQp7CglzdHJ1Y3QgdG0gdG07CglpbnQgb2Zmc2V0LCB0bV9nbXQ7Cgl0aW1lX3QgdGhlbjsKCgltZW1zZXQoJnRtLCAwLCBzaXplb2YodG0pKTsKCXRtLnRtX3llYXIgPSAtMTsKCXRtLnRtX21vbiA9IC0xOwoJdG0udG1fbWRheSA9IC0xOwoJdG0udG1faXNkc3QgPSAtMTsKCXRtLnRtX2hvdXIgPSAtMTsKCXRtLnRtX21pbiA9IC0xOwoJdG0udG1fc2VjID0gLTE7CglvZmZzZXQgPSAtMTsKCXRtX2dtdCA9IDA7CgoJZm9yICg7OykgewoJCWludCBtYXRjaCA9IDA7CgkJdW5zaWduZWQgY2hhciBjID0gKmRhdGU7CgoJCS8qIFN0b3AgYXQgZW5kIG9mIHN0cmluZyBvciBuZXdsaW5lICovCgkJaWYgKCFjIHx8IGMgPT0gJ1xuJykKCQkJYnJlYWs7CgoJCWlmIChpc2FscGhhKGMpKQoJCQltYXRjaCA9IG1hdGNoX2FscGhhKGRhdGUsICZ0bSwgJm9mZnNldCk7CgkJZWxzZSBpZiAoaXNkaWdpdChjKSkKCQkJbWF0Y2ggPSBtYXRjaF9kaWdpdChkYXRlLCAmdG0sICZvZmZzZXQsICZ0bV9nbXQpOwoJCWVsc2UgaWYgKChjID09ICctJyB8fCBjID09ICcrJykgJiYgaXNkaWdpdChkYXRlWzFdKSkKCQkJbWF0Y2ggPSBtYXRjaF90eihkYXRlLCAmb2Zmc2V0KTsKCgkJaWYgKCFtYXRjaCkgewoJCQkvKiBCQUQgQ1JBUCAqLwoJCQltYXRjaCA9IDE7CgkJfQoKCQlkYXRlICs9IG1hdGNoOwoJfQoKCS8qIG1rdGltZSB1c2VzIGxvY2FsIHRpbWV6b25lICovCgl0aGVuID0gdG1fdG9fdGltZV90KCZ0bSk7CglpZiAob2Zmc2V0ID09IC0xKQoJCW9mZnNldCA9ICh0aGVuIC0gbWt0aW1lKCZ0bSkpIC8gNjA7CgoJaWYgKHRoZW4gPT0gLTEpCgkJcmV0dXJuIC0xOwoKCWlmICghdG1fZ210KQoJCXRoZW4gLT0gb2Zmc2V0ICogNjA7CglyZXR1cm4gZGF0ZV9zdHJpbmcodGhlbiwgb2Zmc2V0LCByZXN1bHQsIG1heGxlbik7Cn0KCmVudW0gZGF0ZV9tb2RlIHBhcnNlX2RhdGVfZm9ybWF0KGNvbnN0IGNoYXIgKmZvcm1hdCkKewoJaWYgKCFzdHJjbXAoZm9ybWF0LCAicmVsYXRpdmUiKSkKCQlyZXR1cm4gREFURV9SRUxBVElWRTsKCWVsc2UgaWYgKCFzdHJjbXAoZm9ybWF0LCAiaXNvODYwMSIpIHx8CgkJICFzdHJjbXAoZm9ybWF0LCAiaXNvIikpCgkJcmV0dXJuIERBVEVfSVNPODYwMTsKCWVsc2UgaWYgKCFzdHJjbXAoZm9ybWF0LCAicmZjMjgyMiIpIHx8CgkJICFzdHJjbXAoZm9ybWF0LCAicmZjIikpCgkJcmV0dXJuIERBVEVfUkZDMjgyMjsKCWVsc2UgaWYgKCFzdHJjbXAoZm9ybWF0LCAic2hvcnQiKSkKCQlyZXR1cm4gREFURV9TSE9SVDsKCWVsc2UgaWYgKCFzdHJjbXAoZm9ybWF0LCAibG9jYWwiKSkKCQlyZXR1cm4gREFURV9MT0NBTDsKCWVsc2UgaWYgKCFzdHJjbXAoZm9ybWF0LCAiZGVmYXVsdCIpKQoJCXJldHVybiBEQVRFX05PUk1BTDsKCWVsc2UgaWYgKCFzdHJjbXAoZm9ybWF0LCAicmF3IikpCgkJcmV0dXJuIERBVEVfUkFXOwoJZWxzZQoJCWRpZSgidW5rbm93biBkYXRlIGZvcm1hdCAlcyIsIGZvcm1hdCk7Cn0KCnZvaWQgZGF0ZXN0YW1wKGNoYXIgKmJ1ZiwgaW50IGJ1ZnNpemUpCnsKCXRpbWVfdCBub3c7CglpbnQgb2Zmc2V0OwoKCXRpbWUoJm5vdyk7CgoJb2Zmc2V0ID0gdG1fdG9fdGltZV90KGxvY2FsdGltZSgmbm93KSkgLSBub3c7CglvZmZzZXQgLz0gNjA7CgoJZGF0ZV9zdHJpbmcobm93LCBvZmZzZXQsIGJ1ZiwgYnVmc2l6ZSk7Cn0KCi8qCiAqIFJlbGF0aXZlIHRpbWUgdXBkYXRlIChlZyAiMiBkYXlzIGFnbyIpLiAgSWYgd2UgaGF2ZW4ndCBzZXQgdGhlIHRpbWUKICogeWV0LCB3ZSBuZWVkIHRvIHNldCBpdCBmcm9tIGN1cnJlbnQgdGltZS4KICovCnN0YXRpYyB1bnNpZ25lZCBsb25nIHVwZGF0ZV90bShzdHJ1Y3QgdG0gKnRtLCBzdHJ1Y3QgdG0gKm5vdywgdW5zaWduZWQgbG9uZyBzZWMpCnsKCXRpbWVfdCBuOwoKCWlmICh0bS0+dG1fbWRheSA8IDApCgkJdG0tPnRtX21kYXkgPSBub3ctPnRtX21kYXk7CglpZiAodG0tPnRtX21vbiA8IDApCgkJdG0tPnRtX21vbiA9IG5vdy0+dG1fbW9uOwoJaWYgKHRtLT50bV95ZWFyIDwgMCkgewoJCXRtLT50bV95ZWFyID0gbm93LT50bV95ZWFyOwoJCWlmICh0bS0+dG1fbW9uID4gbm93LT50bV9tb24pCgkJCXRtLT50bV95ZWFyLS07Cgl9CgoJbiA9IG1rdGltZSh0bSkgLSBzZWM7Cglsb2NhbHRpbWVfcigmbiwgdG0pOwoJcmV0dXJuIG47Cn0KCnN0YXRpYyB2b2lkIGRhdGVfbm93KHN0cnVjdCB0bSAqdG0sIHN0cnVjdCB0bSAqbm93LCBpbnQgKm51bSkKewoJdXBkYXRlX3RtKHRtLCBub3csIDApOwp9CgpzdGF0aWMgdm9pZCBkYXRlX3llc3RlcmRheShzdHJ1Y3QgdG0gKnRtLCBzdHJ1Y3QgdG0gKm5vdywgaW50ICpudW0pCnsKCXVwZGF0ZV90bSh0bSwgbm93LCAyNCo2MCo2MCk7Cn0KCnN0YXRpYyB2b2lkIGRhdGVfdGltZShzdHJ1Y3QgdG0gKnRtLCBzdHJ1Y3QgdG0gKm5vdywgaW50IGhvdXIpCnsKCWlmICh0bS0+dG1faG91ciA8IGhvdXIpCgkJZGF0ZV95ZXN0ZXJkYXkodG0sIG5vdywgTlVMTCk7Cgl0bS0+dG1faG91ciA9IGhvdXI7Cgl0bS0+dG1fbWluID0gMDsKCXRtLT50bV9zZWMgPSAwOwp9CgpzdGF0aWMgdm9pZCBkYXRlX21pZG5pZ2h0KHN0cnVjdCB0bSAqdG0sIHN0cnVjdCB0bSAqbm93LCBpbnQgKm51bSkKewoJZGF0ZV90aW1lKHRtLCBub3csIDApOwp9CgpzdGF0aWMgdm9pZCBkYXRlX25vb24oc3RydWN0IHRtICp0bSwgc3RydWN0IHRtICpub3csIGludCAqbnVtKQp7CglkYXRlX3RpbWUodG0sIG5vdywgMTIpOwp9CgpzdGF0aWMgdm9pZCBkYXRlX3RlYShzdHJ1Y3QgdG0gKnRtLCBzdHJ1Y3QgdG0gKm5vdywgaW50ICpudW0pCnsKCWRhdGVfdGltZSh0bSwgbm93LCAxNyk7Cn0KCnN0YXRpYyB2b2lkIGRhdGVfcG0oc3RydWN0IHRtICp0bSwgc3RydWN0IHRtICpub3csIGludCAqbnVtKQp7CglpbnQgaG91ciwgbiA9ICpudW07CgkqbnVtID0gMDsKCglob3VyID0gdG0tPnRtX2hvdXI7CglpZiAobikgewoJCWhvdXIgPSBuOwoJCXRtLT50bV9taW4gPSAwOwoJCXRtLT50bV9zZWMgPSAwOwoJfQoJdG0tPnRtX2hvdXIgPSAoaG91ciAlIDEyKSArIDEyOwp9CgpzdGF0aWMgdm9pZCBkYXRlX2FtKHN0cnVjdCB0bSAqdG0sIHN0cnVjdCB0bSAqbm93LCBpbnQgKm51bSkKewoJaW50IGhvdXIsIG4gPSAqbnVtOwoJKm51bSA9IDA7CgoJaG91ciA9IHRtLT50bV9ob3VyOwoJaWYgKG4pIHsKCQlob3VyID0gbjsKCQl0bS0+dG1fbWluID0gMDsKCQl0bS0+dG1fc2VjID0gMDsKCX0KCXRtLT50bV9ob3VyID0gKGhvdXIgJSAxMik7Cn0KCnN0YXRpYyB2b2lkIGRhdGVfbmV2ZXIoc3RydWN0IHRtICp0bSwgc3RydWN0IHRtICpub3csIGludCAqbnVtKQp7Cgl0aW1lX3QgbiA9IDA7Cglsb2NhbHRpbWVfcigmbiwgdG0pOwp9CgpzdGF0aWMgY29uc3Qgc3RydWN0IHNwZWNpYWwgewoJY29uc3QgY2hhciAqbmFtZTsKCXZvaWQgKCpmbikoc3RydWN0IHRtICosIHN0cnVjdCB0bSAqLCBpbnQgKik7Cn0gc3BlY2lhbFtdID0gewoJeyAieWVzdGVyZGF5IiwgZGF0ZV95ZXN0ZXJkYXkgfSwKCXsgIm5vb24iLCBkYXRlX25vb24gfSwKCXsgIm1pZG5pZ2h0IiwgZGF0ZV9taWRuaWdodCB9LAoJeyAidGVhIiwgZGF0ZV90ZWEgfSwKCXsgIlBNIiwgZGF0ZV9wbSB9LAoJeyAiQU0iLCBkYXRlX2FtIH0sCgl7ICJuZXZlciIsIGRhdGVfbmV2ZXIgfSwKCXsgIm5vdyIsIGRhdGVfbm93IH0sCgl7IE5VTEwgfQp9OwoKc3RhdGljIGNvbnN0IGNoYXIgKm51bWJlcl9uYW1lW10gPSB7CgkiemVybyIsICJvbmUiLCAidHdvIiwgInRocmVlIiwgImZvdXIiLAoJImZpdmUiLCAic2l4IiwgInNldmVuIiwgImVpZ2h0IiwgIm5pbmUiLCAidGVuIiwKfTsKCnN0YXRpYyBjb25zdCBzdHJ1Y3QgdHlwZWxlbiB7Cgljb25zdCBjaGFyICp0eXBlOwoJaW50IGxlbmd0aDsKfSB0eXBlbGVuW10gPSB7Cgl7ICJzZWNvbmRzIiwgMSB9LAoJeyAibWludXRlcyIsIDYwIH0sCgl7ICJob3VycyIsIDYwKjYwIH0sCgl7ICJkYXlzIiwgMjQqNjAqNjAgfSwKCXsgIndlZWtzIiwgNyoyNCo2MCo2MCB9LAoJeyBOVUxMIH0KfTsKCnN0YXRpYyBjb25zdCBjaGFyICphcHByb3hpZGF0ZV9hbHBoYShjb25zdCBjaGFyICpkYXRlLCBzdHJ1Y3QgdG0gKnRtLCBzdHJ1Y3QgdG0gKm5vdywgaW50ICpudW0sIGludCAqdG91Y2hlZCkKewoJY29uc3Qgc3RydWN0IHR5cGVsZW4gKnRsOwoJY29uc3Qgc3RydWN0IHNwZWNpYWwgKnM7Cgljb25zdCBjaGFyICplbmQgPSBkYXRlOwoJaW50IGk7CgoJd2hpbGUgKGlzYWxwaGEoKisrZW5kKSk7CgkJOwoKCWZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7CgkJaW50IG1hdGNoID0gbWF0Y2hfc3RyaW5nKGRhdGUsIG1vbnRoX25hbWVzW2ldKTsKCQlpZiAobWF0Y2ggPj0gMykgewoJCQl0bS0+dG1fbW9uID0gaTsKCQkJKnRvdWNoZWQgPSAxOwoJCQlyZXR1cm4gZW5kOwoJCX0KCX0KCglmb3IgKHMgPSBzcGVjaWFsOyBzLT5uYW1lOyBzKyspIHsKCQlpbnQgbGVuID0gc3RybGVuKHMtPm5hbWUpOwoJCWlmIChtYXRjaF9zdHJpbmcoZGF0ZSwgcy0+bmFtZSkgPT0gbGVuKSB7CgkJCXMtPmZuKHRtLCBub3csIG51bSk7CgkJCSp0b3VjaGVkID0gMTsKCQkJcmV0dXJuIGVuZDsKCQl9Cgl9CgoJaWYgKCEqbnVtKSB7CgkJZm9yIChpID0gMTsgaSA8IDExOyBpKyspIHsKCQkJaW50IGxlbiA9IHN0cmxlbihudW1iZXJfbmFtZVtpXSk7CgkJCWlmIChtYXRjaF9zdHJpbmcoZGF0ZSwgbnVtYmVyX25hbWVbaV0pID09IGxlbikgewoJCQkJKm51bSA9IGk7CgkJCQkqdG91Y2hlZCA9IDE7CgkJCQlyZXR1cm4gZW5kOwoJCQl9CgkJfQoJCWlmIChtYXRjaF9zdHJpbmcoZGF0ZSwgImxhc3QiKSA9PSA0KSB7CgkJCSpudW0gPSAxOwoJCQkqdG91Y2hlZCA9IDE7CgkJfQoJCXJldHVybiBlbmQ7Cgl9CgoJdGwgPSB0eXBlbGVuOwoJd2hpbGUgKHRsLT50eXBlKSB7CgkJaW50IGxlbiA9IHN0cmxlbih0bC0+dHlwZSk7CgkJaWYgKG1hdGNoX3N0cmluZyhkYXRlLCB0bC0+dHlwZSkgPj0gbGVuLTEpIHsKCQkJdXBkYXRlX3RtKHRtLCBub3csIHRsLT5sZW5ndGggKiAqbnVtKTsKCQkJKm51bSA9IDA7CgkJCSp0b3VjaGVkID0gMTsKCQkJcmV0dXJuIGVuZDsKCQl9CgkJdGwrKzsKCX0KCglmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7CgkJaW50IG1hdGNoID0gbWF0Y2hfc3RyaW5nKGRhdGUsIHdlZWtkYXlfbmFtZXNbaV0pOwoJCWlmIChtYXRjaCA+PSAzKSB7CgkJCWludCBkaWZmLCBuID0gKm51bSAtMTsKCQkJKm51bSA9IDA7CgoJCQlkaWZmID0gdG0tPnRtX3dkYXkgLSBpOwoJCQlpZiAoZGlmZiA8PSAwKQoJCQkJbisrOwoJCQlkaWZmICs9IDcqbjsKCgkJCXVwZGF0ZV90bSh0bSwgbm93LCBkaWZmICogMjQgKiA2MCAqIDYwKTsKCQkJKnRvdWNoZWQgPSAxOwoJCQlyZXR1cm4gZW5kOwoJCX0KCX0KCglpZiAobWF0Y2hfc3RyaW5nKGRhdGUsICJtb250aHMiKSA+PSA1KSB7CgkJaW50IG47CgkJdXBkYXRlX3RtKHRtLCBub3csIDApOyAvKiBmaWxsIGluIGRhdGUgZmllbGRzIGlmIG5lZWRlZCAqLwoJCW4gPSB0bS0+dG1fbW9uIC0gKm51bTsKCQkqbnVtID0gMDsKCQl3aGlsZSAobiA8IDApIHsKCQkJbiArPSAxMjsKCQkJdG0tPnRtX3llYXItLTsKCQl9CgkJdG0tPnRtX21vbiA9IG47CgkJKnRvdWNoZWQgPSAxOwoJCXJldHVybiBlbmQ7Cgl9CgoJaWYgKG1hdGNoX3N0cmluZyhkYXRlLCAieWVhcnMiKSA+PSA0KSB7CgkJdXBkYXRlX3RtKHRtLCBub3csIDApOyAvKiBmaWxsIGluIGRhdGUgZmllbGRzIGlmIG5lZWRlZCAqLwoJCXRtLT50bV95ZWFyIC09ICpudW07CgkJKm51bSA9IDA7CgkJKnRvdWNoZWQgPSAxOwoJCXJldHVybiBlbmQ7Cgl9CgoJcmV0dXJuIGVuZDsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKmFwcHJveGlkYXRlX2RpZ2l0KGNvbnN0IGNoYXIgKmRhdGUsIHN0cnVjdCB0bSAqdG0sIGludCAqbnVtKQp7CgljaGFyICplbmQ7Cgl1bnNpZ25lZCBsb25nIG51bWJlciA9IHN0cnRvdWwoZGF0ZSwgJmVuZCwgMTApOwoKCXN3aXRjaCAoKmVuZCkgewoJY2FzZSAnOic6CgljYXNlICcuJzoKCWNhc2UgJy8nOgoJY2FzZSAnLSc6CgkJaWYgKGlzZGlnaXQoZW5kWzFdKSkgewoJCQlpbnQgbWF0Y2ggPSBtYXRjaF9tdWx0aV9udW1iZXIobnVtYmVyLCAqZW5kLCBkYXRlLCBlbmQsIHRtKTsKCQkJaWYgKG1hdGNoKQoJCQkJcmV0dXJuIGRhdGUgKyBtYXRjaDsKCQl9Cgl9CgoJLyogQWNjZXB0IHplcm8tcGFkZGluZyBvbmx5IGZvciBzbWFsbCBudW1iZXJzICgiRGVjIDAyIiwgbmV2ZXIgIkRlYyAwMDAyIikgKi8KCWlmIChkYXRlWzBdICE9ICcwJyB8fCBlbmQgLSBkYXRlIDw9IDIpCgkJKm51bSA9IG51bWJlcjsKCXJldHVybiBlbmQ7Cn0KCi8qCiAqIERvIHdlIGhhdmUgYSBwZW5kaW5nIG51bWJlciBhdCB0aGUgZW5kLCBvciB3aGVuCiAqIHdlIHNlZSBhIG5ldyBvbmU/IExldCdzIGFzc3VtZSBpdCdzIGEgbW9udGggZGF5LAogKiBhcyBpbiAiRGVjIDYsIDE5OTIiCiAqLwpzdGF0aWMgdm9pZCBwZW5kaW5nX251bWJlcihzdHJ1Y3QgdG0gKnRtLCBpbnQgKm51bSkKewoJaW50IG51bWJlciA9ICpudW07CgoJaWYgKG51bWJlcikgewoJCSpudW0gPSAwOwoJCWlmICh0bS0+dG1fbWRheSA8IDAgJiYgbnVtYmVyIDwgMzIpCgkJCXRtLT50bV9tZGF5ID0gbnVtYmVyOwoJCWVsc2UgaWYgKHRtLT50bV9tb24gPCAwICYmIG51bWJlciA8IDEzKQoJCQl0bS0+dG1fbW9uID0gbnVtYmVyLTE7CgkJZWxzZSBpZiAodG0tPnRtX3llYXIgPCAwKSB7CgkJCWlmIChudW1iZXIgPiAxOTY5ICYmIG51bWJlciA8IDIxMDApCgkJCQl0bS0+dG1feWVhciA9IG51bWJlciAtIDE5MDA7CgkJCWVsc2UgaWYgKG51bWJlciA+IDY5ICYmIG51bWJlciA8IDEwMCkKCQkJCXRtLT50bV95ZWFyID0gbnVtYmVyOwoJCQllbHNlIGlmIChudW1iZXIgPCAzOCkKCQkJCXRtLT50bV95ZWFyID0gMTAwICsgbnVtYmVyOwoJCQkvKiBXZSBzY3JldyB1cCBmb3IgbnVtYmVyID0gMDAgPyAqLwoJCX0KCX0KfQoKc3RhdGljIHVuc2lnbmVkIGxvbmcgYXBwcm94aWRhdGVfc3RyKGNvbnN0IGNoYXIgKmRhdGUsCgkJCQkgICAgIGNvbnN0IHN0cnVjdCB0aW1ldmFsICp0diwKCQkJCSAgICAgaW50ICplcnJvcl9yZXQpCnsKCWludCBudW1iZXIgPSAwOwoJaW50IHRvdWNoZWQgPSAwOwoJc3RydWN0IHRtIHRtLCBub3c7Cgl0aW1lX3QgdGltZV9zZWM7CgoJdGltZV9zZWMgPSB0di0+dHZfc2VjOwoJbG9jYWx0aW1lX3IoJnRpbWVfc2VjLCAmdG0pOwoJbm93ID0gdG07CgoJdG0udG1feWVhciA9IC0xOwoJdG0udG1fbW9uID0gLTE7Cgl0bS50bV9tZGF5ID0gLTE7CgoJZm9yICg7OykgewoJCXVuc2lnbmVkIGNoYXIgYyA9ICpkYXRlOwoJCWlmICghYykKCQkJYnJlYWs7CgkJZGF0ZSsrOwoJCWlmIChpc2RpZ2l0KGMpKSB7CgkJCXBlbmRpbmdfbnVtYmVyKCZ0bSwgJm51bWJlcik7CgkJCWRhdGUgPSBhcHByb3hpZGF0ZV9kaWdpdChkYXRlLTEsICZ0bSwgJm51bWJlcik7CgkJCXRvdWNoZWQgPSAxOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKGlzYWxwaGEoYykpCgkJCWRhdGUgPSBhcHByb3hpZGF0ZV9hbHBoYShkYXRlLTEsICZ0bSwgJm5vdywgJm51bWJlciwgJnRvdWNoZWQpOwoJfQoJcGVuZGluZ19udW1iZXIoJnRtLCAmbnVtYmVyKTsKCWlmICghdG91Y2hlZCkKCQkqZXJyb3JfcmV0ID0gMTsKCXJldHVybiB1cGRhdGVfdG0oJnRtLCAmbm93LCAwKTsKfQoKdW5zaWduZWQgbG9uZyBhcHByb3hpZGF0ZV9yZWxhdGl2ZShjb25zdCBjaGFyICpkYXRlLCBjb25zdCBzdHJ1Y3QgdGltZXZhbCAqdHYpCnsKCWNoYXIgYnVmZmVyWzUwXTsKCWludCBlcnJvcnMgPSAwOwoKCWlmIChwYXJzZV9kYXRlKGRhdGUsIGJ1ZmZlciwgc2l6ZW9mKGJ1ZmZlcikpID4gMCkKCQlyZXR1cm4gc3RydG91bChidWZmZXIsIE5VTEwsIDApOwoKCXJldHVybiBhcHByb3hpZGF0ZV9zdHIoZGF0ZSwgdHYsICZlcnJvcnMpOwp9Cgp1bnNpZ25lZCBsb25nIGFwcHJveGlkYXRlX2NhcmVmdWwoY29uc3QgY2hhciAqZGF0ZSwgaW50ICplcnJvcl9yZXQpCnsKCXN0cnVjdCB0aW1ldmFsIHR2OwoJY2hhciBidWZmZXJbNTBdOwoJaW50IGR1bW15ID0gMDsKCWlmICghZXJyb3JfcmV0KQoJCWVycm9yX3JldCA9ICZkdW1teTsKCglpZiAocGFyc2VfZGF0ZShkYXRlLCBidWZmZXIsIHNpemVvZihidWZmZXIpKSA+IDApIHsKCQkqZXJyb3JfcmV0ID0gMDsKCQlyZXR1cm4gc3RydG91bChidWZmZXIsIE5VTEwsIDApOwoJfQoKCWdldHRpbWVvZmRheSgmdHYsIE5VTEwpOwoJcmV0dXJuIGFwcHJveGlkYXRlX3N0cihkYXRlLCAmdHYsIGVycm9yX3JldCk7Cn0K",
    "text": "/*\n * GIT - The information manager from hell\n *\n * Copyright (C) Linus Torvalds, 2005\n */\n\n#include \"cache.h\"\n\n/*\n * This is like mktime, but without normalization of tm_wday and tm_yday.\n */\nstatic time_t tm_to_time_t(const struct tm *tm)\n{\n\tstatic const int mdays[] = {\n\t    0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334\n\t};\n\tint year = tm->tm_year - 70;\n\tint month = tm->tm_mon;\n\tint day = tm->tm_mday;\n\n\tif (year < 0 || year > 129) /* algo only works for 1970-2099 */\n\t\treturn -1;\n\tif (month < 0 || month > 11) /* array bounds */\n\t\treturn -1;\n\tif (month < 2 || (year + 2) % 4)\n\t\tday--;\n\tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_sec < 0)\n\t\treturn -1;\n\treturn (year * 365 + (year + 1) / 4 + mdays[month] + day) * 24*60*60UL +\n\t\ttm->tm_hour * 60*60 + tm->tm_min * 60 + tm->tm_sec;\n}\n\nstatic const char *month_names[] = {\n\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n\t\"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n};\n\nstatic const char *weekday_names[] = {\n\t\"Sundays\", \"Mondays\", \"Tuesdays\", \"Wednesdays\", \"Thursdays\", \"Fridays\", \"Saturdays\"\n};\n\nstatic time_t gm_time_t(unsigned long time, int tz)\n{\n\tint minutes;\n\n\tminutes = tz < 0 ? -tz : tz;\n\tminutes = (minutes / 100)*60 + (minutes % 100);\n\tminutes = tz < 0 ? -minutes : minutes;\n\treturn time + minutes * 60;\n}\n\n/*\n * The \"tz\" thing is passed in as this strange \"decimal parse of tz\"\n * thing, which means that tz -0100 is passed in as the integer -100,\n * even though it means \"sixty minutes off\"\n */\nstatic struct tm *time_to_tm(unsigned long time, int tz)\n{\n\ttime_t t = gm_time_t(time, tz);\n\treturn gmtime(&t);\n}\n\n/*\n * What value of \"tz\" was in effect back then at \"time\" in the\n * local timezone?\n */\nstatic int local_tzoffset(unsigned long time)\n{\n\ttime_t t, t_local;\n\tstruct tm tm;\n\tint offset, eastwest;\n\n\tt = time;\n\tlocaltime_r(&t, &tm);\n\tt_local = tm_to_time_t(&tm);\n\n\tif (t_local < t) {\n\t\teastwest = -1;\n\t\toffset = t - t_local;\n\t} else {\n\t\teastwest = 1;\n\t\toffset = t_local - t;\n\t}\n\toffset /= 60; /* in minutes */\n\toffset = (offset % 60) + ((offset / 60) * 100);\n\treturn offset * eastwest;\n}\n\nconst char *show_date_relative(unsigned long time, int tz,\n\t\t\t       const struct timeval *now,\n\t\t\t       char *timebuf,\n\t\t\t       size_t timebuf_size)\n{\n\tunsigned long diff;\n\tif (now->tv_sec < time)\n\t\treturn \"in the future\";\n\tdiff = now->tv_sec - time;\n\tif (diff < 90) {\n\t\tsnprintf(timebuf, timebuf_size, \"%lu seconds ago\", diff);\n\t\treturn timebuf;\n\t}\n\t/* Turn it into minutes */\n\tdiff = (diff + 30) / 60;\n\tif (diff < 90) {\n\t\tsnprintf(timebuf, timebuf_size, \"%lu minutes ago\", diff);\n\t\treturn timebuf;\n\t}\n\t/* Turn it into hours */\n\tdiff = (diff + 30) / 60;\n\tif (diff < 36) {\n\t\tsnprintf(timebuf, timebuf_size, \"%lu hours ago\", diff);\n\t\treturn timebuf;\n\t}\n\t/* We deal with number of days from here on */\n\tdiff = (diff + 12) / 24;\n\tif (diff < 14) {\n\t\tsnprintf(timebuf, timebuf_size, \"%lu days ago\", diff);\n\t\treturn timebuf;\n\t}\n\t/* Say weeks for the past 10 weeks or so */\n\tif (diff < 70) {\n\t\tsnprintf(timebuf, timebuf_size, \"%lu weeks ago\", (diff + 3) / 7);\n\t\treturn timebuf;\n\t}\n\t/* Say months for the past 12 months or so */\n\tif (diff < 365) {\n\t\tsnprintf(timebuf, timebuf_size, \"%lu months ago\", (diff + 15) / 30);\n\t\treturn timebuf;\n\t}\n\t/* Give years and months for 5 years or so */\n\tif (diff < 1825) {\n\t\tunsigned long years = diff / 365;\n\t\tunsigned long months = (diff % 365 + 15) / 30;\n\t\tint n;\n\t\tn = snprintf(timebuf, timebuf_size, \"%lu year%s\",\n\t\t\t\tyears, (years > 1 ? \"s\" : \"\"));\n\t\tif (months)\n\t\t\tsnprintf(timebuf + n, timebuf_size - n,\n\t\t\t\t\t\", %lu month%s ago\",\n\t\t\t\t\tmonths, (months > 1 ? \"s\" : \"\"));\n\t\telse\n\t\t\tsnprintf(timebuf + n, timebuf_size - n, \" ago\");\n\t\treturn timebuf;\n\t}\n\t/* Otherwise, just years. Centuries is probably overkill. */\n\tsnprintf(timebuf, timebuf_size, \"%lu years ago\", (diff + 183) / 365);\n\treturn timebuf;\n}\n\nconst char *show_date(unsigned long time, int tz, enum date_mode mode)\n{\n\tstruct tm *tm;\n\tstatic char timebuf[200];\n\n\tif (mode == DATE_RAW) {\n\t\tsnprintf(timebuf, sizeof(timebuf), \"%lu %+05d\", time, tz);\n\t\treturn timebuf;\n\t}\n\n\tif (mode == DATE_RELATIVE) {\n\t\tstruct timeval now;\n\t\tgettimeofday(&now, NULL);\n\t\treturn show_date_relative(time, tz, &now,\n\t\t\t\t\t  timebuf, sizeof(timebuf));\n\t}\n\n\tif (mode == DATE_LOCAL)\n\t\ttz = local_tzoffset(time);\n\n\ttm = time_to_tm(time, tz);\n\tif (!tm)\n\t\treturn NULL;\n\tif (mode == DATE_SHORT)\n\t\tsprintf(timebuf, \"%04d-%02d-%02d\", tm->tm_year + 1900,\n\t\t\t\ttm->tm_mon + 1, tm->tm_mday);\n\telse if (mode == DATE_ISO8601)\n\t\tsprintf(timebuf, \"%04d-%02d-%02d %02d:%02d:%02d %+05d\",\n\t\t\t\ttm->tm_year + 1900,\n\t\t\t\ttm->tm_mon + 1,\n\t\t\t\ttm->tm_mday,\n\t\t\t\ttm->tm_hour, tm->tm_min, tm->tm_sec,\n\t\t\t\ttz);\n\telse if (mode == DATE_RFC2822)\n\t\tsprintf(timebuf, \"%.3s, %d %.3s %d %02d:%02d:%02d %+05d\",\n\t\t\tweekday_names[tm->tm_wday], tm->tm_mday,\n\t\t\tmonth_names[tm->tm_mon], tm->tm_year + 1900,\n\t\t\ttm->tm_hour, tm->tm_min, tm->tm_sec, tz);\n\telse\n\t\tsprintf(timebuf, \"%.3s %.3s %d %02d:%02d:%02d %d%c%+05d\",\n\t\t\t\tweekday_names[tm->tm_wday],\n\t\t\t\tmonth_names[tm->tm_mon],\n\t\t\t\ttm->tm_mday,\n\t\t\t\ttm->tm_hour, tm->tm_min, tm->tm_sec,\n\t\t\t\ttm->tm_year + 1900,\n\t\t\t\t(mode == DATE_LOCAL) ? 0 : ' ',\n\t\t\t\ttz);\n\treturn timebuf;\n}\n\n/*\n * Check these. And note how it doesn't do the summer-time conversion.\n *\n * In my world, it's always summer, and things are probably a bit off\n * in other ways too.\n */\nstatic const struct {\n\tconst char *name;\n\tint offset;\n\tint dst;\n} timezone_names[] = {\n\t{ \"IDLW\", -12, 0, },\t/* International Date Line West */\n\t{ \"NT\",   -11, 0, },\t/* Nome */\n\t{ \"CAT\",  -10, 0, },\t/* Central Alaska */\n\t{ \"HST\",  -10, 0, },\t/* Hawaii Standard */\n\t{ \"HDT\",  -10, 1, },\t/* Hawaii Daylight */\n\t{ \"YST\",   -9, 0, },\t/* Yukon Standard */\n\t{ \"YDT\",   -9, 1, },\t/* Yukon Daylight */\n\t{ \"PST\",   -8, 0, },\t/* Pacific Standard */\n\t{ \"PDT\",   -8, 1, },\t/* Pacific Daylight */\n\t{ \"MST\",   -7, 0, },\t/* Mountain Standard */\n\t{ \"MDT\",   -7, 1, },\t/* Mountain Daylight */\n\t{ \"CST\",   -6, 0, },\t/* Central Standard */\n\t{ \"CDT\",   -6, 1, },\t/* Central Daylight */\n\t{ \"EST\",   -5, 0, },\t/* Eastern Standard */\n\t{ \"EDT\",   -5, 1, },\t/* Eastern Daylight */\n\t{ \"AST\",   -3, 0, },\t/* Atlantic Standard */\n\t{ \"ADT\",   -3, 1, },\t/* Atlantic Daylight */\n\t{ \"WAT\",   -1, 0, },\t/* West Africa */\n\n\t{ \"GMT\",    0, 0, },\t/* Greenwich Mean */\n\t{ \"UTC\",    0, 0, },\t/* Universal (Coordinated) */\n\n\t{ \"WET\",    0, 0, },\t/* Western European */\n\t{ \"BST\",    0, 1, },\t/* British Summer */\n\t{ \"CET\",   +1, 0, },\t/* Central European */\n\t{ \"MET\",   +1, 0, },\t/* Middle European */\n\t{ \"MEWT\",  +1, 0, },\t/* Middle European Winter */\n\t{ \"MEST\",  +1, 1, },\t/* Middle European Summer */\n\t{ \"CEST\",  +1, 1, },\t/* Central European Summer */\n\t{ \"MESZ\",  +1, 1, },\t/* Middle European Summer */\n\t{ \"FWT\",   +1, 0, },\t/* French Winter */\n\t{ \"FST\",   +1, 1, },\t/* French Summer */\n\t{ \"EET\",   +2, 0, },\t/* Eastern Europe, USSR Zone 1 */\n\t{ \"EEST\",  +2, 1, },\t/* Eastern European Daylight */\n\t{ \"WAST\",  +7, 0, },\t/* West Australian Standard */\n\t{ \"WADT\",  +7, 1, },\t/* West Australian Daylight */\n\t{ \"CCT\",   +8, 0, },\t/* China Coast, USSR Zone 7 */\n\t{ \"JST\",   +9, 0, },\t/* Japan Standard, USSR Zone 8 */\n\t{ \"EAST\", +10, 0, },\t/* Eastern Australian Standard */\n\t{ \"EADT\", +10, 1, },\t/* Eastern Australian Daylight */\n\t{ \"GST\",  +10, 0, },\t/* Guam Standard, USSR Zone 9 */\n\t{ \"NZT\",  +12, 0, },\t/* New Zealand */\n\t{ \"NZST\", +12, 0, },\t/* New Zealand Standard */\n\t{ \"NZDT\", +12, 1, },\t/* New Zealand Daylight */\n\t{ \"IDLE\", +12, 0, },\t/* International Date Line East */\n};\n\nstatic int match_string(const char *date, const char *str)\n{\n\tint i = 0;\n\n\tfor (i = 0; *date; date++, str++, i++) {\n\t\tif (*date == *str)\n\t\t\tcontinue;\n\t\tif (toupper(*date) == toupper(*str))\n\t\t\tcontinue;\n\t\tif (!isalnum(*date))\n\t\t\tbreak;\n\t\treturn 0;\n\t}\n\treturn i;\n}\n\nstatic int skip_alpha(const char *date)\n{\n\tint i = 0;\n\tdo {\n\t\ti++;\n\t} while (isalpha(date[i]));\n\treturn i;\n}\n\n/*\n* Parse month, weekday, or timezone name\n*/\nstatic int match_alpha(const char *date, struct tm *tm, int *offset)\n{\n\tint i;\n\n\tfor (i = 0; i < 12; i++) {\n\t\tint match = match_string(date, month_names[i]);\n\t\tif (match >= 3) {\n\t\t\ttm->tm_mon = i;\n\t\t\treturn match;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 7; i++) {\n\t\tint match = match_string(date, weekday_names[i]);\n\t\tif (match >= 3) {\n\t\t\ttm->tm_wday = i;\n\t\t\treturn match;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(timezone_names); i++) {\n\t\tint match = match_string(date, timezone_names[i].name);\n\t\tif (match >= 3) {\n\t\t\tint off = timezone_names[i].offset;\n\n\t\t\t/* This is bogus, but we like summer */\n\t\t\toff += timezone_names[i].dst;\n\n\t\t\t/* Only use the tz name offset if we don't have anything better */\n\t\t\tif (*offset == -1)\n\t\t\t\t*offset = 60*off;\n\n\t\t\treturn match;\n\t\t}\n\t}\n\n\tif (match_string(date, \"PM\") == 2) {\n\t\ttm->tm_hour = (tm->tm_hour % 12) + 12;\n\t\treturn 2;\n\t}\n\n\tif (match_string(date, \"AM\") == 2) {\n\t\ttm->tm_hour = (tm->tm_hour % 12) + 0;\n\t\treturn 2;\n\t}\n\n\t/* BAD CRAP */\n\treturn skip_alpha(date);\n}\n\nstatic int is_date(int year, int month, int day, struct tm *now_tm, time_t now, struct tm *tm)\n{\n\tif (month > 0 && month < 13 && day > 0 && day < 32) {\n\t\tstruct tm check = *tm;\n\t\tstruct tm *r = (now_tm ? &check : tm);\n\t\ttime_t specified;\n\n\t\tr->tm_mon = month - 1;\n\t\tr->tm_mday = day;\n\t\tif (year == -1) {\n\t\t\tif (!now_tm)\n\t\t\t\treturn 1;\n\t\t\tr->tm_year = now_tm->tm_year;\n\t\t}\n\t\telse if (year >= 1970 && year < 2100)\n\t\t\tr->tm_year = year - 1900;\n\t\telse if (year > 70 && year < 100)\n\t\t\tr->tm_year = year;\n\t\telse if (year < 38)\n\t\t\tr->tm_year = year + 100;\n\t\telse\n\t\t\treturn 0;\n\t\tif (!now_tm)\n\t\t\treturn 1;\n\n\t\tspecified = tm_to_time_t(r);\n\n\t\t/* Be it commit time or author time, it does not make\n\t\t * sense to specify timestamp way into the future.  Make\n\t\t * sure it is not later than ten days from now...\n\t\t */\n\t\tif (now + 10*24*3600 < specified)\n\t\t\treturn 0;\n\t\ttm->tm_mon = r->tm_mon;\n\t\ttm->tm_mday = r->tm_mday;\n\t\tif (year != -1)\n\t\t\ttm->tm_year = r->tm_year;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int match_multi_number(unsigned long num, char c, const char *date, char *end, struct tm *tm)\n{\n\ttime_t now;\n\tstruct tm now_tm;\n\tstruct tm *refuse_future;\n\tlong num2, num3;\n\n\tnum2 = strtol(end+1, &end, 10);\n\tnum3 = -1;\n\tif (*end == c && isdigit(end[1]))\n\t\tnum3 = strtol(end+1, &end, 10);\n\n\t/* Time? Date? */\n\tswitch (c) {\n\tcase ':':\n\t\tif (num3 < 0)\n\t\t\tnum3 = 0;\n\t\tif (num < 25 && num2 >= 0 && num2 < 60 && num3 >= 0 && num3 <= 60) {\n\t\t\ttm->tm_hour = num;\n\t\t\ttm->tm_min = num2;\n\t\t\ttm->tm_sec = num3;\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\n\tcase '-':\n\tcase '/':\n\tcase '.':\n\t\tnow = time(NULL);\n\t\trefuse_future = NULL;\n\t\tif (gmtime_r(&now, &now_tm))\n\t\t\trefuse_future = &now_tm;\n\n\t\tif (num > 70) {\n\t\t\t/* yyyy-mm-dd? */\n\t\t\tif (is_date(num, num2, num3, refuse_future, now, tm))\n\t\t\t\tbreak;\n\t\t\t/* yyyy-dd-mm? */\n\t\t\tif (is_date(num, num3, num2, refuse_future, now, tm))\n\t\t\t\tbreak;\n\t\t}\n\t\t/* Our eastern European friends say dd.mm.yy[yy]\n\t\t * is the norm there, so giving precedence to\n\t\t * mm/dd/yy[yy] form only when separator is not '.'\n\t\t */\n\t\tif (c != '.' &&\n\t\t    is_date(num3, num, num2, refuse_future, now, tm))\n\t\t\tbreak;\n\t\t/* European dd.mm.yy[yy] or funny US dd/mm/yy[yy] */\n\t\tif (is_date(num3, num2, num, refuse_future, now, tm))\n\t\t\tbreak;\n\t\t/* Funny European mm.dd.yy */\n\t\tif (c == '.' &&\n\t\t    is_date(num3, num, num2, refuse_future, now, tm))\n\t\t\tbreak;\n\t\treturn 0;\n\t}\n\treturn end - date;\n}\n\n/*\n * Have we filled in any part of the time/date yet?\n * We just do a binary 'and' to see if the sign bit\n * is set in all the values.\n */\nstatic inline int nodate(struct tm *tm)\n{\n\treturn (tm->tm_year &\n\t\ttm->tm_mon &\n\t\ttm->tm_mday &\n\t\ttm->tm_hour &\n\t\ttm->tm_min &\n\t\ttm->tm_sec) < 0;\n}\n\n/*\n * We've seen a digit. Time? Year? Date?\n */\nstatic int match_digit(const char *date, struct tm *tm, int *offset, int *tm_gmt)\n{\n\tint n;\n\tchar *end;\n\tunsigned long num;\n\n\tnum = strtoul(date, &end, 10);\n\n\t/*\n\t * Seconds since 1970? We trigger on that for any numbers with\n\t * more than 8 digits. This is because we don't want to rule out\n\t * numbers like 20070606 as a YYYYMMDD date.\n\t */\n\tif (num >= 100000000 && nodate(tm)) {\n\t\ttime_t time = num;\n\t\tif (gmtime_r(&time, tm)) {\n\t\t\t*tm_gmt = 1;\n\t\t\treturn end - date;\n\t\t}\n\t}\n\n\t/*\n\t * Check for special formats: num[-.:/]num[same]num\n\t */\n\tswitch (*end) {\n\tcase ':':\n\tcase '.':\n\tcase '/':\n\tcase '-':\n\t\tif (isdigit(end[1])) {\n\t\t\tint match = match_multi_number(num, *end, date, end, tm);\n\t\t\tif (match)\n\t\t\t\treturn match;\n\t\t}\n\t}\n\n\t/*\n\t * None of the special formats? Try to guess what\n\t * the number meant. We use the number of digits\n\t * to make a more educated guess..\n\t */\n\tn = 0;\n\tdo {\n\t\tn++;\n\t} while (isdigit(date[n]));\n\n\t/* Four-digit year or a timezone? */\n\tif (n == 4) {\n\t\tif (num <= 1400 && *offset == -1) {\n\t\t\tunsigned int minutes = num % 100;\n\t\t\tunsigned int hours = num / 100;\n\t\t\t*offset = hours*60 + minutes;\n\t\t} else if (num > 1900 && num < 2100)\n\t\t\ttm->tm_year = num - 1900;\n\t\treturn n;\n\t}\n\n\t/*\n\t * Ignore lots of numerals. We took care of 4-digit years above.\n\t * Days or months must be one or two digits.\n\t */\n\tif (n > 2)\n\t\treturn n;\n\n\t/*\n\t * NOTE! We will give precedence to day-of-month over month or\n\t * year numbers in the 1-12 range. So 05 is always \"mday 5\",\n\t * unless we already have a mday..\n\t *\n\t * IOW, 01 Apr 05 parses as \"April 1st, 2005\".\n\t */\n\tif (num > 0 && num < 32 && tm->tm_mday < 0) {\n\t\ttm->tm_mday = num;\n\t\treturn n;\n\t}\n\n\t/* Two-digit year? */\n\tif (n == 2 && tm->tm_year < 0) {\n\t\tif (num < 10 && tm->tm_mday >= 0) {\n\t\t\ttm->tm_year = num + 100;\n\t\t\treturn n;\n\t\t}\n\t\tif (num >= 70) {\n\t\t\ttm->tm_year = num;\n\t\t\treturn n;\n\t\t}\n\t}\n\n\tif (num > 0 && num < 13 && tm->tm_mon < 0)\n\t\ttm->tm_mon = num-1;\n\n\treturn n;\n}\n\nstatic int match_tz(const char *date, int *offp)\n{\n\tchar *end;\n\tint offset = strtoul(date+1, &end, 10);\n\tint min, hour;\n\tint n = end - date - 1;\n\n\tmin = offset % 100;\n\thour = offset / 100;\n\n\t/*\n\t * Don't accept any random crap.. At least 3 digits, and\n\t * a valid minute. We might want to check that the minutes\n\t * are divisible by 30 or something too.\n\t */\n\tif (min < 60 && n > 2) {\n\t\toffset = hour*60+min;\n\t\tif (*date == '-')\n\t\t\toffset = -offset;\n\n\t\t*offp = offset;\n\t}\n\treturn end - date;\n}\n\nstatic int date_string(unsigned long date, int offset, char *buf, int len)\n{\n\tint sign = '+';\n\n\tif (offset < 0) {\n\t\toffset = -offset;\n\t\tsign = '-';\n\t}\n\treturn snprintf(buf, len, \"%lu %c%02d%02d\", date, sign, offset / 60, offset % 60);\n}\n\n/* Gr. strptime is crap for this; it doesn't have a way to require RFC2822\n   (i.e. English) day/month names, and it doesn't work correctly with %z. */\nint parse_date(const char *date, char *result, int maxlen)\n{\n\tstruct tm tm;\n\tint offset, tm_gmt;\n\ttime_t then;\n\n\tmemset(&tm, 0, sizeof(tm));\n\ttm.tm_year = -1;\n\ttm.tm_mon = -1;\n\ttm.tm_mday = -1;\n\ttm.tm_isdst = -1;\n\ttm.tm_hour = -1;\n\ttm.tm_min = -1;\n\ttm.tm_sec = -1;\n\toffset = -1;\n\ttm_gmt = 0;\n\n\tfor (;;) {\n\t\tint match = 0;\n\t\tunsigned char c = *date;\n\n\t\t/* Stop at end of string or newline */\n\t\tif (!c || c == '\\n')\n\t\t\tbreak;\n\n\t\tif (isalpha(c))\n\t\t\tmatch = match_alpha(date, &tm, &offset);\n\t\telse if (isdigit(c))\n\t\t\tmatch = match_digit(date, &tm, &offset, &tm_gmt);\n\t\telse if ((c == '-' || c == '+') && isdigit(date[1]))\n\t\t\tmatch = match_tz(date, &offset);\n\n\t\tif (!match) {\n\t\t\t/* BAD CRAP */\n\t\t\tmatch = 1;\n\t\t}\n\n\t\tdate += match;\n\t}\n\n\t/* mktime uses local timezone */\n\tthen = tm_to_time_t(&tm);\n\tif (offset == -1)\n\t\toffset = (then - mktime(&tm)) / 60;\n\n\tif (then == -1)\n\t\treturn -1;\n\n\tif (!tm_gmt)\n\t\tthen -= offset * 60;\n\treturn date_string(then, offset, result, maxlen);\n}\n\nenum date_mode parse_date_format(const char *format)\n{\n\tif (!strcmp(format, \"relative\"))\n\t\treturn DATE_RELATIVE;\n\telse if (!strcmp(format, \"iso8601\") ||\n\t\t !strcmp(format, \"iso\"))\n\t\treturn DATE_ISO8601;\n\telse if (!strcmp(format, \"rfc2822\") ||\n\t\t !strcmp(format, \"rfc\"))\n\t\treturn DATE_RFC2822;\n\telse if (!strcmp(format, \"short\"))\n\t\treturn DATE_SHORT;\n\telse if (!strcmp(format, \"local\"))\n\t\treturn DATE_LOCAL;\n\telse if (!strcmp(format, \"default\"))\n\t\treturn DATE_NORMAL;\n\telse if (!strcmp(format, \"raw\"))\n\t\treturn DATE_RAW;\n\telse\n\t\tdie(\"unknown date format %s\", format);\n}\n\nvoid datestamp(char *buf, int bufsize)\n{\n\ttime_t now;\n\tint offset;\n\n\ttime(&now);\n\n\toffset = tm_to_time_t(localtime(&now)) - now;\n\toffset /= 60;\n\n\tdate_string(now, offset, buf, bufsize);\n}\n\n/*\n * Relative time update (eg \"2 days ago\").  If we haven't set the time\n * yet, we need to set it from current time.\n */\nstatic unsigned long update_tm(struct tm *tm, struct tm *now, unsigned long sec)\n{\n\ttime_t n;\n\n\tif (tm->tm_mday < 0)\n\t\ttm->tm_mday = now->tm_mday;\n\tif (tm->tm_mon < 0)\n\t\ttm->tm_mon = now->tm_mon;\n\tif (tm->tm_year < 0) {\n\t\ttm->tm_year = now->tm_year;\n\t\tif (tm->tm_mon > now->tm_mon)\n\t\t\ttm->tm_year--;\n\t}\n\n\tn = mktime(tm) - sec;\n\tlocaltime_r(&n, tm);\n\treturn n;\n}\n\nstatic void date_now(struct tm *tm, struct tm *now, int *num)\n{\n\tupdate_tm(tm, now, 0);\n}\n\nstatic void date_yesterday(struct tm *tm, struct tm *now, int *num)\n{\n\tupdate_tm(tm, now, 24*60*60);\n}\n\nstatic void date_time(struct tm *tm, struct tm *now, int hour)\n{\n\tif (tm->tm_hour < hour)\n\t\tdate_yesterday(tm, now, NULL);\n\ttm->tm_hour = hour;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n}\n\nstatic void date_midnight(struct tm *tm, struct tm *now, int *num)\n{\n\tdate_time(tm, now, 0);\n}\n\nstatic void date_noon(struct tm *tm, struct tm *now, int *num)\n{\n\tdate_time(tm, now, 12);\n}\n\nstatic void date_tea(struct tm *tm, struct tm *now, int *num)\n{\n\tdate_time(tm, now, 17);\n}\n\nstatic void date_pm(struct tm *tm, struct tm *now, int *num)\n{\n\tint hour, n = *num;\n\t*num = 0;\n\n\thour = tm->tm_hour;\n\tif (n) {\n\t\thour = n;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t}\n\ttm->tm_hour = (hour % 12) + 12;\n}\n\nstatic void date_am(struct tm *tm, struct tm *now, int *num)\n{\n\tint hour, n = *num;\n\t*num = 0;\n\n\thour = tm->tm_hour;\n\tif (n) {\n\t\thour = n;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t}\n\ttm->tm_hour = (hour % 12);\n}\n\nstatic void date_never(struct tm *tm, struct tm *now, int *num)\n{\n\ttime_t n = 0;\n\tlocaltime_r(&n, tm);\n}\n\nstatic const struct special {\n\tconst char *name;\n\tvoid (*fn)(struct tm *, struct tm *, int *);\n} special[] = {\n\t{ \"yesterday\", date_yesterday },\n\t{ \"noon\", date_noon },\n\t{ \"midnight\", date_midnight },\n\t{ \"tea\", date_tea },\n\t{ \"PM\", date_pm },\n\t{ \"AM\", date_am },\n\t{ \"never\", date_never },\n\t{ \"now\", date_now },\n\t{ NULL }\n};\n\nstatic const char *number_name[] = {\n\t\"zero\", \"one\", \"two\", \"three\", \"four\",\n\t\"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n};\n\nstatic const struct typelen {\n\tconst char *type;\n\tint length;\n} typelen[] = {\n\t{ \"seconds\", 1 },\n\t{ \"minutes\", 60 },\n\t{ \"hours\", 60*60 },\n\t{ \"days\", 24*60*60 },\n\t{ \"weeks\", 7*24*60*60 },\n\t{ NULL }\n};\n\nstatic const char *approxidate_alpha(const char *date, struct tm *tm, struct tm *now, int *num, int *touched)\n{\n\tconst struct typelen *tl;\n\tconst struct special *s;\n\tconst char *end = date;\n\tint i;\n\n\twhile (isalpha(*++end));\n\t\t;\n\n\tfor (i = 0; i < 12; i++) {\n\t\tint match = match_string(date, month_names[i]);\n\t\tif (match >= 3) {\n\t\t\ttm->tm_mon = i;\n\t\t\t*touched = 1;\n\t\t\treturn end;\n\t\t}\n\t}\n\n\tfor (s = special; s->name; s++) {\n\t\tint len = strlen(s->name);\n\t\tif (match_string(date, s->name) == len) {\n\t\t\ts->fn(tm, now, num);\n\t\t\t*touched = 1;\n\t\t\treturn end;\n\t\t}\n\t}\n\n\tif (!*num) {\n\t\tfor (i = 1; i < 11; i++) {\n\t\t\tint len = strlen(number_name[i]);\n\t\t\tif (match_string(date, number_name[i]) == len) {\n\t\t\t\t*num = i;\n\t\t\t\t*touched = 1;\n\t\t\t\treturn end;\n\t\t\t}\n\t\t}\n\t\tif (match_string(date, \"last\") == 4) {\n\t\t\t*num = 1;\n\t\t\t*touched = 1;\n\t\t}\n\t\treturn end;\n\t}\n\n\ttl = typelen;\n\twhile (tl->type) {\n\t\tint len = strlen(tl->type);\n\t\tif (match_string(date, tl->type) >= len-1) {\n\t\t\tupdate_tm(tm, now, tl->length * *num);\n\t\t\t*num = 0;\n\t\t\t*touched = 1;\n\t\t\treturn end;\n\t\t}\n\t\ttl++;\n\t}\n\n\tfor (i = 0; i < 7; i++) {\n\t\tint match = match_string(date, weekday_names[i]);\n\t\tif (match >= 3) {\n\t\t\tint diff, n = *num -1;\n\t\t\t*num = 0;\n\n\t\t\tdiff = tm->tm_wday - i;\n\t\t\tif (diff <= 0)\n\t\t\t\tn++;\n\t\t\tdiff += 7*n;\n\n\t\t\tupdate_tm(tm, now, diff * 24 * 60 * 60);\n\t\t\t*touched = 1;\n\t\t\treturn end;\n\t\t}\n\t}\n\n\tif (match_string(date, \"months\") >= 5) {\n\t\tint n;\n\t\tupdate_tm(tm, now, 0); /* fill in date fields if needed */\n\t\tn = tm->tm_mon - *num;\n\t\t*num = 0;\n\t\twhile (n < 0) {\n\t\t\tn += 12;\n\t\t\ttm->tm_year--;\n\t\t}\n\t\ttm->tm_mon = n;\n\t\t*touched = 1;\n\t\treturn end;\n\t}\n\n\tif (match_string(date, \"years\") >= 4) {\n\t\tupdate_tm(tm, now, 0); /* fill in date fields if needed */\n\t\ttm->tm_year -= *num;\n\t\t*num = 0;\n\t\t*touched = 1;\n\t\treturn end;\n\t}\n\n\treturn end;\n}\n\nstatic const char *approxidate_digit(const char *date, struct tm *tm, int *num)\n{\n\tchar *end;\n\tunsigned long number = strtoul(date, &end, 10);\n\n\tswitch (*end) {\n\tcase ':':\n\tcase '.':\n\tcase '/':\n\tcase '-':\n\t\tif (isdigit(end[1])) {\n\t\t\tint match = match_multi_number(number, *end, date, end, tm);\n\t\t\tif (match)\n\t\t\t\treturn date + match;\n\t\t}\n\t}\n\n\t/* Accept zero-padding only for small numbers (\"Dec 02\", never \"Dec 0002\") */\n\tif (date[0] != '0' || end - date <= 2)\n\t\t*num = number;\n\treturn end;\n}\n\n/*\n * Do we have a pending number at the end, or when\n * we see a new one? Let's assume it's a month day,\n * as in \"Dec 6, 1992\"\n */\nstatic void pending_number(struct tm *tm, int *num)\n{\n\tint number = *num;\n\n\tif (number) {\n\t\t*num = 0;\n\t\tif (tm->tm_mday < 0 && number < 32)\n\t\t\ttm->tm_mday = number;\n\t\telse if (tm->tm_mon < 0 && number < 13)\n\t\t\ttm->tm_mon = number-1;\n\t\telse if (tm->tm_year < 0) {\n\t\t\tif (number > 1969 && number < 2100)\n\t\t\t\ttm->tm_year = number - 1900;\n\t\t\telse if (number > 69 && number < 100)\n\t\t\t\ttm->tm_year = number;\n\t\t\telse if (number < 38)\n\t\t\t\ttm->tm_year = 100 + number;\n\t\t\t/* We screw up for number = 00 ? */\n\t\t}\n\t}\n}\n\nstatic unsigned long approxidate_str(const char *date,\n\t\t\t\t     const struct timeval *tv,\n\t\t\t\t     int *error_ret)\n{\n\tint number = 0;\n\tint touched = 0;\n\tstruct tm tm, now;\n\ttime_t time_sec;\n\n\ttime_sec = tv->tv_sec;\n\tlocaltime_r(&time_sec, &tm);\n\tnow = tm;\n\n\ttm.tm_year = -1;\n\ttm.tm_mon = -1;\n\ttm.tm_mday = -1;\n\n\tfor (;;) {\n\t\tunsigned char c = *date;\n\t\tif (!c)\n\t\t\tbreak;\n\t\tdate++;\n\t\tif (isdigit(c)) {\n\t\t\tpending_number(&tm, &number);\n\t\t\tdate = approxidate_digit(date-1, &tm, &number);\n\t\t\ttouched = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (isalpha(c))\n\t\t\tdate = approxidate_alpha(date-1, &tm, &now, &number, &touched);\n\t}\n\tpending_number(&tm, &number);\n\tif (!touched)\n\t\t*error_ret = 1;\n\treturn update_tm(&tm, &now, 0);\n}\n\nunsigned long approxidate_relative(const char *date, const struct timeval *tv)\n{\n\tchar buffer[50];\n\tint errors = 0;\n\n\tif (parse_date(date, buffer, sizeof(buffer)) > 0)\n\t\treturn strtoul(buffer, NULL, 0);\n\n\treturn approxidate_str(date, tv, &errors);\n}\n\nunsigned long approxidate_careful(const char *date, int *error_ret)\n{\n\tstruct timeval tv;\n\tchar buffer[50];\n\tint dummy = 0;\n\tif (!error_ret)\n\t\terror_ret = &dummy;\n\n\tif (parse_date(date, buffer, sizeof(buffer)) > 0) {\n\t\t*error_ret = 0;\n\t\treturn strtoul(buffer, NULL, 0);\n\t}\n\n\tgettimeofday(&tv, NULL);\n\treturn approxidate_str(date, &tv, error_ret);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "002aa3c8d6d4ff08d8790a155b8979bc117a2b95",
  "sha1_ok": true,
  "size": 22698
}
