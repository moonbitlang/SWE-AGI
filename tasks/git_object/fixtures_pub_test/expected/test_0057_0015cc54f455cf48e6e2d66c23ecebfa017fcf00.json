{
  "content": {
    "base64": "LyoKICogVGhpcyBoYW5kbGVzIHJlY3Vyc2l2ZSBmaWxlbmFtZSBkZXRlY3Rpb24gd2l0aCBleGNsdWRlCiAqIGZpbGVzLCBpbmRleCBrbm93bGVkZ2UgZXRjLi4KICoKICogQ29weXJpZ2h0IChDKSBMaW51cyBUb3J2YWxkcywgMjAwNS0yMDA2CiAqCQkgSnVuaW8gSGFtYW5vLCAyMDA1LTIwMDYKICovCiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJyZWZzLmgiCgpzdHJ1Y3QgcGF0aF9zaW1wbGlmeSB7CglpbnQgbGVuOwoJY29uc3QgY2hhciAqcGF0aDsKfTsKCnN0YXRpYyBpbnQgcmVhZF9kaXJlY3RvcnlfcmVjdXJzaXZlKHN0cnVjdCBkaXJfc3RydWN0ICpkaXIsIGNvbnN0IGNoYXIgKnBhdGgsIGludCBsZW4sCglpbnQgY2hlY2tfb25seSwgY29uc3Qgc3RydWN0IHBhdGhfc2ltcGxpZnkgKnNpbXBsaWZ5KTsKc3RhdGljIGludCBnZXRfZHR5cGUoc3RydWN0IGRpcmVudCAqZGUsIGNvbnN0IGNoYXIgKnBhdGgsIGludCBsZW4pOwoKLyogaGVscGVyIHN0cmluZyBmdW5jdGlvbnMgd2l0aCBzdXBwb3J0IGZvciB0aGUgaWdub3JlX2Nhc2UgZmxhZyAqLwppbnQgc3RyY21wX2ljYXNlKGNvbnN0IGNoYXIgKmEsIGNvbnN0IGNoYXIgKmIpCnsKCXJldHVybiBpZ25vcmVfY2FzZSA/IHN0cmNhc2VjbXAoYSwgYikgOiBzdHJjbXAoYSwgYik7Cn0KCmludCBzdHJuY21wX2ljYXNlKGNvbnN0IGNoYXIgKmEsIGNvbnN0IGNoYXIgKmIsIHNpemVfdCBjb3VudCkKewoJcmV0dXJuIGlnbm9yZV9jYXNlID8gc3RybmNhc2VjbXAoYSwgYiwgY291bnQpIDogc3RybmNtcChhLCBiLCBjb3VudCk7Cn0KCmludCBmbm1hdGNoX2ljYXNlKGNvbnN0IGNoYXIgKnBhdHRlcm4sIGNvbnN0IGNoYXIgKnN0cmluZywgaW50IGZsYWdzKQp7CglyZXR1cm4gZm5tYXRjaChwYXR0ZXJuLCBzdHJpbmcsIGZsYWdzIHwgKGlnbm9yZV9jYXNlID8gRk5NX0NBU0VGT0xEIDogMCkpOwp9CgpzdGF0aWMgc2l6ZV90IGNvbW1vbl9wcmVmaXhfbGVuKGNvbnN0IGNoYXIgKipwYXRoc3BlYykKewoJY29uc3QgY2hhciAqbiwgKmZpcnN0OwoJc2l6ZV90IG1heCA9IDA7CgoJaWYgKCFwYXRoc3BlYykKCQlyZXR1cm4gbWF4OwoKCWZpcnN0ID0gKnBhdGhzcGVjOwoJd2hpbGUgKChuID0gKnBhdGhzcGVjKyspKSB7CgkJc2l6ZV90IGksIGxlbiA9IDA7CgkJZm9yIChpID0gMDsgZmlyc3QgPT0gbiB8fCBpIDwgbWF4OyBpKyspIHsKCQkJY2hhciBjID0gbltpXTsKCQkJaWYgKCFjIHx8IGMgIT0gZmlyc3RbaV0gfHwgaXNfZ2xvYl9zcGVjaWFsKGMpKQoJCQkJYnJlYWs7CgkJCWlmIChjID09ICcvJykKCQkJCWxlbiA9IGkgKyAxOwoJCX0KCQlpZiAoZmlyc3QgPT0gbiB8fCBsZW4gPCBtYXgpIHsKCQkJbWF4ID0gbGVuOwoJCQlpZiAoIW1heCkKCQkJCWJyZWFrOwoJCX0KCX0KCXJldHVybiBtYXg7Cn0KCi8qCiAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBsb25nZXN0IGxlYWRpbmcgcGF0aCBjb21tb24gYW1vbmcgYWxsCiAqIHBhdGhzcGVjcy4KICovCmNoYXIgKmNvbW1vbl9wcmVmaXgoY29uc3QgY2hhciAqKnBhdGhzcGVjKQp7Cgl1bnNpZ25lZCBsb25nIGxlbiA9IGNvbW1vbl9wcmVmaXhfbGVuKHBhdGhzcGVjKTsKCglyZXR1cm4gbGVuID8geG1lbWR1cHooKnBhdGhzcGVjLCBsZW4pIDogTlVMTDsKfQoKaW50IGZpbGxfZGlyZWN0b3J5KHN0cnVjdCBkaXJfc3RydWN0ICpkaXIsIGNvbnN0IGNoYXIgKipwYXRoc3BlYykKewoJc2l6ZV90IGxlbjsKCgkvKgoJICogQ2FsY3VsYXRlIGNvbW1vbiBwcmVmaXggZm9yIHRoZSBwYXRoc3BlYywgYW5kCgkgKiB1c2UgdGhhdCB0byBvcHRpbWl6ZSB0aGUgZGlyZWN0b3J5IHdhbGsKCSAqLwoJbGVuID0gY29tbW9uX3ByZWZpeF9sZW4ocGF0aHNwZWMpOwoKCS8qIFJlYWQgdGhlIGRpcmVjdG9yeSBhbmQgcHJ1bmUgaXQgKi8KCXJlYWRfZGlyZWN0b3J5KGRpciwgcGF0aHNwZWMgPyAqcGF0aHNwZWMgOiAiIiwgbGVuLCBwYXRoc3BlYyk7CglyZXR1cm4gbGVuOwp9CgppbnQgd2l0aGluX2RlcHRoKGNvbnN0IGNoYXIgKm5hbWUsIGludCBuYW1lbGVuLAoJCQlpbnQgZGVwdGgsIGludCBtYXhfZGVwdGgpCnsKCWNvbnN0IGNoYXIgKmNwID0gbmFtZSwgKmNwZSA9IG5hbWUgKyBuYW1lbGVuOwoKCXdoaWxlIChjcCA8IGNwZSkgewoJCWlmICgqY3ArKyAhPSAnLycpCgkJCWNvbnRpbnVlOwoJCWRlcHRoKys7CgkJaWYgKGRlcHRoID4gbWF4X2RlcHRoKQoJCQlyZXR1cm4gMDsKCX0KCXJldHVybiAxOwp9CgovKgogKiBEb2VzICdtYXRjaCcgbWF0Y2ggdGhlIGdpdmVuIG5hbWU/CiAqIEEgbWF0Y2ggaXMgZm91bmQgaWYKICoKICogKDEpIHRoZSAnbWF0Y2gnIHN0cmluZyBpcyBsZWFkaW5nIGRpcmVjdG9yeSBvZiAnbmFtZScsIG9yCiAqICgyKSB0aGUgJ21hdGNoJyBzdHJpbmcgaXMgYSB3aWxkY2FyZCBhbmQgbWF0Y2hlcyAnbmFtZScsIG9yCiAqICgzKSB0aGUgJ21hdGNoJyBzdHJpbmcgaXMgZXhhY3RseSB0aGUgc2FtZSBhcyAnbmFtZScuCiAqCiAqIGFuZCB0aGUgcmV0dXJuIHZhbHVlIHRlbGxzIHdoaWNoIGNhc2UgaXQgd2FzLgogKgogKiBJdCByZXR1cm5zIDAgd2hlbiB0aGVyZSBpcyBubyBtYXRjaC4KICovCnN0YXRpYyBpbnQgbWF0Y2hfb25lKGNvbnN0IGNoYXIgKm1hdGNoLCBjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbikKewoJaW50IG1hdGNobGVuOwoKCS8qIElmIHRoZSBtYXRjaCB3YXMganVzdCB0aGUgcHJlZml4LCB3ZSBtYXRjaGVkICovCglpZiAoISptYXRjaCkKCQlyZXR1cm4gTUFUQ0hFRF9SRUNVUlNJVkVMWTsKCglpZiAoaWdub3JlX2Nhc2UpIHsKCQlmb3IgKDs7KSB7CgkJCXVuc2lnbmVkIGNoYXIgYzEgPSB0b2xvd2VyKCptYXRjaCk7CgkJCXVuc2lnbmVkIGNoYXIgYzIgPSB0b2xvd2VyKCpuYW1lKTsKCQkJaWYgKGMxID09ICdcMCcgfHwgaXNfZ2xvYl9zcGVjaWFsKGMxKSkKCQkJCWJyZWFrOwoJCQlpZiAoYzEgIT0gYzIpCgkJCQlyZXR1cm4gMDsKCQkJbWF0Y2grKzsKCQkJbmFtZSsrOwoJCQluYW1lbGVuLS07CgkJfQoJfSBlbHNlIHsKCQlmb3IgKDs7KSB7CgkJCXVuc2lnbmVkIGNoYXIgYzEgPSAqbWF0Y2g7CgkJCXVuc2lnbmVkIGNoYXIgYzIgPSAqbmFtZTsKCQkJaWYgKGMxID09ICdcMCcgfHwgaXNfZ2xvYl9zcGVjaWFsKGMxKSkKCQkJCWJyZWFrOwoJCQlpZiAoYzEgIT0gYzIpCgkJCQlyZXR1cm4gMDsKCQkJbWF0Y2grKzsKCQkJbmFtZSsrOwoJCQluYW1lbGVuLS07CgkJfQoJfQoKCgkvKgoJICogSWYgd2UgZG9uJ3QgbWF0Y2ggdGhlIG1hdGNoc3RyaW5nIGV4YWN0bHksCgkgKiB3ZSBuZWVkIHRvIG1hdGNoIGJ5IGZubWF0Y2gKCSAqLwoJbWF0Y2hsZW4gPSBzdHJsZW4obWF0Y2gpOwoJaWYgKHN0cm5jbXBfaWNhc2UobWF0Y2gsIG5hbWUsIG1hdGNobGVuKSkKCQlyZXR1cm4gIWZubWF0Y2hfaWNhc2UobWF0Y2gsIG5hbWUsIDApID8gTUFUQ0hFRF9GTk1BVENIIDogMDsKCglpZiAobmFtZWxlbiA9PSBtYXRjaGxlbikKCQlyZXR1cm4gTUFUQ0hFRF9FWEFDVExZOwoJaWYgKG1hdGNoW21hdGNobGVuLTFdID09ICcvJyB8fCBuYW1lW21hdGNobGVuXSA9PSAnLycpCgkJcmV0dXJuIE1BVENIRURfUkVDVVJTSVZFTFk7CglyZXR1cm4gMDsKfQoKLyoKICogR2l2ZW4gYSBuYW1lIGFuZCBhIGxpc3Qgb2YgcGF0aHNwZWNzLCBzZWUgaWYgdGhlIG5hbWUgbWF0Y2hlcwogKiBhbnkgb2YgdGhlIHBhdGhzcGVjcy4gIFRoZSBjYWxsZXIgaXMgYWxzbyBpbnRlcmVzdGVkIGluIHNlZWluZwogKiBhbGwgcGF0aHNwZWMgbWF0Y2hlcyBzb21lIG5hbWVzIGl0IGNhbGxzIHRoaXMgZnVuY3Rpb24gd2l0aAogKiAob3RoZXJ3aXNlIHRoZSB1c2VyIGNvdWxkIGhhdmUgbWlzdHlwZWQgdGhlIHVubWF0Y2hlZCBwYXRoc3BlYyksCiAqIGFuZCBhIG1hcmsgaXMgbGVmdCBpbiBzZWVuW10gYXJyYXkgZm9yIHBhdGhzcGVjIGVsZW1lbnQgdGhhdAogKiBhY3R1YWxseSBtYXRjaGVkIGFueXRoaW5nLgogKi8KaW50IG1hdGNoX3BhdGhzcGVjKGNvbnN0IGNoYXIgKipwYXRoc3BlYywgY29uc3QgY2hhciAqbmFtZSwgaW50IG5hbWVsZW4sCgkJaW50IHByZWZpeCwgY2hhciAqc2VlbikKewoJaW50IGksIHJldHZhbCA9IDA7CgoJaWYgKCFwYXRoc3BlYykKCQlyZXR1cm4gMTsKCgluYW1lICs9IHByZWZpeDsKCW5hbWVsZW4gLT0gcHJlZml4OwoKCWZvciAoaSA9IDA7IHBhdGhzcGVjW2ldICE9IE5VTEw7IGkrKykgewoJCWludCBob3c7CgkJY29uc3QgY2hhciAqbWF0Y2ggPSBwYXRoc3BlY1tpXSArIHByZWZpeDsKCQlpZiAoc2VlbiAmJiBzZWVuW2ldID09IE1BVENIRURfRVhBQ1RMWSkKCQkJY29udGludWU7CgkJaG93ID0gbWF0Y2hfb25lKG1hdGNoLCBuYW1lLCBuYW1lbGVuKTsKCQlpZiAoaG93KSB7CgkJCWlmIChyZXR2YWwgPCBob3cpCgkJCQlyZXR2YWwgPSBob3c7CgkJCWlmIChzZWVuICYmIHNlZW5baV0gPCBob3cpCgkJCQlzZWVuW2ldID0gaG93OwoJCX0KCX0KCXJldHVybiByZXR2YWw7Cn0KCi8qCiAqIERvZXMgJ21hdGNoJyBtYXRjaCB0aGUgZ2l2ZW4gbmFtZT8KICogQSBtYXRjaCBpcyBmb3VuZCBpZgogKgogKiAoMSkgdGhlICdtYXRjaCcgc3RyaW5nIGlzIGxlYWRpbmcgZGlyZWN0b3J5IG9mICduYW1lJywgb3IKICogKDIpIHRoZSAnbWF0Y2gnIHN0cmluZyBpcyBhIHdpbGRjYXJkIGFuZCBtYXRjaGVzICduYW1lJywgb3IKICogKDMpIHRoZSAnbWF0Y2gnIHN0cmluZyBpcyBleGFjdGx5IHRoZSBzYW1lIGFzICduYW1lJy4KICoKICogYW5kIHRoZSByZXR1cm4gdmFsdWUgdGVsbHMgd2hpY2ggY2FzZSBpdCB3YXMuCiAqCiAqIEl0IHJldHVybnMgMCB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoLgogKi8Kc3RhdGljIGludCBtYXRjaF9wYXRoc3BlY19pdGVtKGNvbnN0IHN0cnVjdCBwYXRoc3BlY19pdGVtICppdGVtLCBpbnQgcHJlZml4LAoJCQkgICAgICAgY29uc3QgY2hhciAqbmFtZSwgaW50IG5hbWVsZW4pCnsKCS8qIG5hbWUvbmFtZWxlbiBoYXMgcHJlZml4IGN1dCBvZmYgYnkgY2FsbGVyICovCgljb25zdCBjaGFyICptYXRjaCA9IGl0ZW0tPm1hdGNoICsgcHJlZml4OwoJaW50IG1hdGNobGVuID0gaXRlbS0+bGVuIC0gcHJlZml4OwoKCS8qIElmIHRoZSBtYXRjaCB3YXMganVzdCB0aGUgcHJlZml4LCB3ZSBtYXRjaGVkICovCglpZiAoISptYXRjaCkKCQlyZXR1cm4gTUFUQ0hFRF9SRUNVUlNJVkVMWTsKCglpZiAobWF0Y2hsZW4gPD0gbmFtZWxlbiAmJiAhc3RybmNtcChtYXRjaCwgbmFtZSwgbWF0Y2hsZW4pKSB7CgkJaWYgKG1hdGNobGVuID09IG5hbWVsZW4pCgkJCXJldHVybiBNQVRDSEVEX0VYQUNUTFk7CgoJCWlmIChtYXRjaFttYXRjaGxlbi0xXSA9PSAnLycgfHwgbmFtZVttYXRjaGxlbl0gPT0gJy8nKQoJCQlyZXR1cm4gTUFUQ0hFRF9SRUNVUlNJVkVMWTsKCX0KCglpZiAoaXRlbS0+dXNlX3dpbGRjYXJkICYmICFmbm1hdGNoKG1hdGNoLCBuYW1lLCAwKSkKCQlyZXR1cm4gTUFUQ0hFRF9GTk1BVENIOwoKCXJldHVybiAwOwp9CgovKgogKiBHaXZlbiBhIG5hbWUgYW5kIGEgbGlzdCBvZiBwYXRoc3BlY3MsIHNlZSBpZiB0aGUgbmFtZSBtYXRjaGVzCiAqIGFueSBvZiB0aGUgcGF0aHNwZWNzLiAgVGhlIGNhbGxlciBpcyBhbHNvIGludGVyZXN0ZWQgaW4gc2VlaW5nCiAqIGFsbCBwYXRoc3BlYyBtYXRjaGVzIHNvbWUgbmFtZXMgaXQgY2FsbHMgdGhpcyBmdW5jdGlvbiB3aXRoCiAqIChvdGhlcndpc2UgdGhlIHVzZXIgY291bGQgaGF2ZSBtaXN0eXBlZCB0aGUgdW5tYXRjaGVkIHBhdGhzcGVjKSwKICogYW5kIGEgbWFyayBpcyBsZWZ0IGluIHNlZW5bXSBhcnJheSBmb3IgcGF0aHNwZWMgZWxlbWVudCB0aGF0CiAqIGFjdHVhbGx5IG1hdGNoZWQgYW55dGhpbmcuCiAqLwppbnQgbWF0Y2hfcGF0aHNwZWNfZGVwdGgoY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwcywKCQkJIGNvbnN0IGNoYXIgKm5hbWUsIGludCBuYW1lbGVuLAoJCQkgaW50IHByZWZpeCwgY2hhciAqc2VlbikKewoJaW50IGksIHJldHZhbCA9IDA7CgoJaWYgKCFwcy0+bnIpIHsKCQlpZiAoIXBzLT5yZWN1cnNpdmUgfHwgcHMtPm1heF9kZXB0aCA9PSAtMSkKCQkJcmV0dXJuIE1BVENIRURfUkVDVVJTSVZFTFk7CgoJCWlmICh3aXRoaW5fZGVwdGgobmFtZSwgbmFtZWxlbiwgMCwgcHMtPm1heF9kZXB0aCkpCgkJCXJldHVybiBNQVRDSEVEX0VYQUNUTFk7CgkJZWxzZQoJCQlyZXR1cm4gMDsKCX0KCgluYW1lICs9IHByZWZpeDsKCW5hbWVsZW4gLT0gcHJlZml4OwoKCWZvciAoaSA9IHBzLT5uciAtIDE7IGkgPj0gMDsgaS0tKSB7CgkJaW50IGhvdzsKCQlpZiAoc2VlbiAmJiBzZWVuW2ldID09IE1BVENIRURfRVhBQ1RMWSkKCQkJY29udGludWU7CgkJaG93ID0gbWF0Y2hfcGF0aHNwZWNfaXRlbShwcy0+aXRlbXMraSwgcHJlZml4LCBuYW1lLCBuYW1lbGVuKTsKCQlpZiAocHMtPnJlY3Vyc2l2ZSAmJiBwcy0+bWF4X2RlcHRoICE9IC0xICYmCgkJICAgIGhvdyAmJiBob3cgIT0gTUFUQ0hFRF9GTk1BVENIKSB7CgkJCWludCBsZW4gPSBwcy0+aXRlbXNbaV0ubGVuOwoJCQlpZiAobmFtZVtsZW5dID09ICcvJykKCQkJCWxlbisrOwoJCQlpZiAod2l0aGluX2RlcHRoKG5hbWUrbGVuLCBuYW1lbGVuLWxlbiwgMCwgcHMtPm1heF9kZXB0aCkpCgkJCQlob3cgPSBNQVRDSEVEX0VYQUNUTFk7CgkJCWVsc2UKCQkJCWhvdyA9IDA7CgkJfQoJCWlmIChob3cpIHsKCQkJaWYgKHJldHZhbCA8IGhvdykKCQkJCXJldHZhbCA9IGhvdzsKCQkJaWYgKHNlZW4gJiYgc2VlbltpXSA8IGhvdykKCQkJCXNlZW5baV0gPSBob3c7CgkJfQoJfQoJcmV0dXJuIHJldHZhbDsKfQoKLyoKICogUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlICJzaW1wbGUiIHBhcnQgb2YgYSBwYXRoIG1hdGNoIGxpbWl0ZXIuCiAqLwpzdGF0aWMgaW50IHNpbXBsZV9sZW5ndGgoY29uc3QgY2hhciAqbWF0Y2gpCnsKCWludCBsZW4gPSAtMTsKCglmb3IgKDs7KSB7CgkJdW5zaWduZWQgY2hhciBjID0gKm1hdGNoKys7CgkJbGVuKys7CgkJaWYgKGMgPT0gJ1wwJyB8fCBpc19nbG9iX3NwZWNpYWwoYykpCgkJCXJldHVybiBsZW47Cgl9Cn0KCnN0YXRpYyBpbnQgbm9fd2lsZGNhcmQoY29uc3QgY2hhciAqc3RyaW5nKQp7CglyZXR1cm4gc3RyaW5nW3NpbXBsZV9sZW5ndGgoc3RyaW5nKV0gPT0gJ1wwJzsKfQoKdm9pZCBhZGRfZXhjbHVkZShjb25zdCBjaGFyICpzdHJpbmcsIGNvbnN0IGNoYXIgKmJhc2UsCgkJIGludCBiYXNlbGVuLCBzdHJ1Y3QgZXhjbHVkZV9saXN0ICp3aGljaCkKewoJc3RydWN0IGV4Y2x1ZGUgKng7CglzaXplX3QgbGVuOwoJaW50IHRvX2V4Y2x1ZGUgPSAxOwoJaW50IGZsYWdzID0gMDsKCglpZiAoKnN0cmluZyA9PSAnIScpIHsKCQl0b19leGNsdWRlID0gMDsKCQlzdHJpbmcrKzsKCX0KCWxlbiA9IHN0cmxlbihzdHJpbmcpOwoJaWYgKGxlbiAmJiBzdHJpbmdbbGVuIC0gMV0gPT0gJy8nKSB7CgkJY2hhciAqczsKCQl4ID0geG1hbGxvYyhzaXplb2YoKngpICsgbGVuKTsKCQlzID0gKGNoYXIgKikoeCsxKTsKCQltZW1jcHkocywgc3RyaW5nLCBsZW4gLSAxKTsKCQlzW2xlbiAtIDFdID0gJ1wwJzsKCQlzdHJpbmcgPSBzOwoJCXgtPnBhdHRlcm4gPSBzOwoJCWZsYWdzID0gRVhDX0ZMQUdfTVVTVEJFRElSOwoJfSBlbHNlIHsKCQl4ID0geG1hbGxvYyhzaXplb2YoKngpKTsKCQl4LT5wYXR0ZXJuID0gc3RyaW5nOwoJfQoJeC0+dG9fZXhjbHVkZSA9IHRvX2V4Y2x1ZGU7Cgl4LT5wYXR0ZXJubGVuID0gc3RybGVuKHN0cmluZyk7Cgl4LT5iYXNlID0gYmFzZTsKCXgtPmJhc2VsZW4gPSBiYXNlbGVuOwoJeC0+ZmxhZ3MgPSBmbGFnczsKCWlmICghc3RyY2hyKHN0cmluZywgJy8nKSkKCQl4LT5mbGFncyB8PSBFWENfRkxBR19OT0RJUjsKCXgtPm5vd2lsZGNhcmRsZW4gPSBzaW1wbGVfbGVuZ3RoKHN0cmluZyk7CglpZiAoKnN0cmluZyA9PSAnKicgJiYgbm9fd2lsZGNhcmQoc3RyaW5nKzEpKQoJCXgtPmZsYWdzIHw9IEVYQ19GTEFHX0VORFNXSVRIOwoJQUxMT0NfR1JPVyh3aGljaC0+ZXhjbHVkZXMsIHdoaWNoLT5uciArIDEsIHdoaWNoLT5hbGxvYyk7Cgl3aGljaC0+ZXhjbHVkZXNbd2hpY2gtPm5yKytdID0geDsKfQoKc3RhdGljIHZvaWQgKnJlYWRfc2tpcF93b3JrdHJlZV9maWxlX2Zyb21faW5kZXgoY29uc3QgY2hhciAqcGF0aCwgc2l6ZV90ICpzaXplKQp7CglpbnQgcG9zLCBsZW47Cgl1bnNpZ25lZCBsb25nIHN6OwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJdm9pZCAqZGF0YTsKCXN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlID0gJnRoZV9pbmRleDsKCglsZW4gPSBzdHJsZW4ocGF0aCk7Cglwb3MgPSBpbmRleF9uYW1lX3Bvcyhpc3RhdGUsIHBhdGgsIGxlbik7CglpZiAocG9zIDwgMCkKCQlyZXR1cm4gTlVMTDsKCWlmICghY2Vfc2tpcF93b3JrdHJlZShpc3RhdGUtPmNhY2hlW3Bvc10pKQoJCXJldHVybiBOVUxMOwoJZGF0YSA9IHJlYWRfc2hhMV9maWxlKGlzdGF0ZS0+Y2FjaGVbcG9zXS0+c2hhMSwgJnR5cGUsICZzeik7CglpZiAoIWRhdGEgfHwgdHlwZSAhPSBPQkpfQkxPQikgewoJCWZyZWUoZGF0YSk7CgkJcmV0dXJuIE5VTEw7Cgl9Cgkqc2l6ZSA9IHhzaXplX3Qoc3opOwoJcmV0dXJuIGRhdGE7Cn0KCnZvaWQgZnJlZV9leGNsdWRlcyhzdHJ1Y3QgZXhjbHVkZV9saXN0ICplbCkKewoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IGVsLT5ucjsgaSsrKQoJCWZyZWUoZWwtPmV4Y2x1ZGVzW2ldKTsKCWZyZWUoZWwtPmV4Y2x1ZGVzKTsKCgllbC0+bnIgPSAwOwoJZWwtPmV4Y2x1ZGVzID0gTlVMTDsKfQoKaW50IGFkZF9leGNsdWRlc19mcm9tX2ZpbGVfdG9fbGlzdChjb25zdCBjaGFyICpmbmFtZSwKCQkJCSAgIGNvbnN0IGNoYXIgKmJhc2UsCgkJCQkgICBpbnQgYmFzZWxlbiwKCQkJCSAgIGNoYXIgKipidWZfcCwKCQkJCSAgIHN0cnVjdCBleGNsdWRlX2xpc3QgKndoaWNoLAoJCQkJICAgaW50IGNoZWNrX2luZGV4KQp7CglzdHJ1Y3Qgc3RhdCBzdDsKCWludCBmZCwgaTsKCXNpemVfdCBzaXplID0gMDsKCWNoYXIgKmJ1ZiwgKmVudHJ5OwoKCWZkID0gb3BlbihmbmFtZSwgT19SRE9OTFkpOwoJaWYgKGZkIDwgMCB8fCBmc3RhdChmZCwgJnN0KSA8IDApIHsKCQlpZiAoMCA8PSBmZCkKCQkJY2xvc2UoZmQpOwoJCWlmICghY2hlY2tfaW5kZXggfHwKCQkgICAgKGJ1ZiA9IHJlYWRfc2tpcF93b3JrdHJlZV9maWxlX2Zyb21faW5kZXgoZm5hbWUsICZzaXplKSkgPT0gTlVMTCkKCQkJcmV0dXJuIC0xOwoJCWlmIChzaXplID09IDApIHsKCQkJZnJlZShidWYpOwoJCQlyZXR1cm4gMDsKCQl9CgkJaWYgKGJ1ZltzaXplLTFdICE9ICdcbicpIHsKCQkJYnVmID0geHJlYWxsb2MoYnVmLCBzaXplKzEpOwoJCQlidWZbc2l6ZSsrXSA9ICdcbic7CgkJfQoJfQoJZWxzZSB7CgkJc2l6ZSA9IHhzaXplX3Qoc3Quc3Rfc2l6ZSk7CgkJaWYgKHNpemUgPT0gMCkgewoJCQljbG9zZShmZCk7CgkJCXJldHVybiAwOwoJCX0KCQlidWYgPSB4bWFsbG9jKHNpemUrMSk7CgkJaWYgKHJlYWRfaW5fZnVsbChmZCwgYnVmLCBzaXplKSAhPSBzaXplKSB7CgkJCWZyZWUoYnVmKTsKCQkJY2xvc2UoZmQpOwoJCQlyZXR1cm4gLTE7CgkJfQoJCWJ1ZltzaXplKytdID0gJ1xuJzsKCQljbG9zZShmZCk7Cgl9CgoJaWYgKGJ1Zl9wKQoJCSpidWZfcCA9IGJ1ZjsKCWVudHJ5ID0gYnVmOwoJZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykgewoJCWlmIChidWZbaV0gPT0gJ1xuJykgewoJCQlpZiAoZW50cnkgIT0gYnVmICsgaSAmJiBlbnRyeVswXSAhPSAnIycpIHsKCQkJCWJ1ZltpIC0gKGkgJiYgYnVmW2ktMV0gPT0gJ1xyJyldID0gMDsKCQkJCWFkZF9leGNsdWRlKGVudHJ5LCBiYXNlLCBiYXNlbGVuLCB3aGljaCk7CgkJCX0KCQkJZW50cnkgPSBidWYgKyBpICsgMTsKCQl9Cgl9CglyZXR1cm4gMDsKfQoKdm9pZCBhZGRfZXhjbHVkZXNfZnJvbV9maWxlKHN0cnVjdCBkaXJfc3RydWN0ICpkaXIsIGNvbnN0IGNoYXIgKmZuYW1lKQp7CglpZiAoYWRkX2V4Y2x1ZGVzX2Zyb21fZmlsZV90b19saXN0KGZuYW1lLCAiIiwgMCwgTlVMTCwKCQkJCQkgICAmZGlyLT5leGNsdWRlX2xpc3RbRVhDX0ZJTEVdLCAwKSA8IDApCgkJZGllKCJjYW5ub3QgdXNlICVzIGFzIGFuIGV4Y2x1ZGUgZmlsZSIsIGZuYW1lKTsKfQoKc3RhdGljIHZvaWQgcHJlcF9leGNsdWRlKHN0cnVjdCBkaXJfc3RydWN0ICpkaXIsIGNvbnN0IGNoYXIgKmJhc2UsIGludCBiYXNlbGVuKQp7CglzdHJ1Y3QgZXhjbHVkZV9saXN0ICplbDsKCXN0cnVjdCBleGNsdWRlX3N0YWNrICpzdGsgPSBOVUxMOwoJaW50IGN1cnJlbnQ7CgoJaWYgKCghZGlyLT5leGNsdWRlX3Blcl9kaXIpIHx8CgkgICAgKGJhc2VsZW4gKyBzdHJsZW4oZGlyLT5leGNsdWRlX3Blcl9kaXIpID49IFBBVEhfTUFYKSkKCQlyZXR1cm47IC8qIHRvbyBsb25nIGEgcGF0aCAtLSBpZ25vcmUgKi8KCgkvKiBQb3AgdGhlIG9uZXMgdGhhdCBhcmUgbm90IHRoZSBwcmVmaXggb2YgdGhlIHBhdGggYmVpbmcgY2hlY2tlZC4gKi8KCWVsID0gJmRpci0+ZXhjbHVkZV9saXN0W0VYQ19ESVJTXTsKCXdoaWxlICgoc3RrID0gZGlyLT5leGNsdWRlX3N0YWNrKSAhPSBOVUxMKSB7CgkJaWYgKHN0ay0+YmFzZWxlbiA8PSBiYXNlbGVuICYmCgkJICAgICFzdHJuY21wKGRpci0+YmFzZWJ1ZiwgYmFzZSwgc3RrLT5iYXNlbGVuKSkKCQkJYnJlYWs7CgkJZGlyLT5leGNsdWRlX3N0YWNrID0gc3RrLT5wcmV2OwoJCXdoaWxlIChzdGstPmV4Y2x1ZGVfaXggPCBlbC0+bnIpCgkJCWZyZWUoZWwtPmV4Y2x1ZGVzWy0tZWwtPm5yXSk7CgkJZnJlZShzdGstPmZpbGVidWYpOwoJCWZyZWUoc3RrKTsKCX0KCgkvKiBSZWFkIGZyb20gdGhlIHBhcmVudCBkaXJlY3RvcmllcyBhbmQgcHVzaCB0aGVtIGRvd24uICovCgljdXJyZW50ID0gc3RrID8gc3RrLT5iYXNlbGVuIDogLTE7Cgl3aGlsZSAoY3VycmVudCA8IGJhc2VsZW4pIHsKCQlzdHJ1Y3QgZXhjbHVkZV9zdGFjayAqc3RrID0geGNhbGxvYygxLCBzaXplb2YoKnN0aykpOwoJCWNvbnN0IGNoYXIgKmNwOwoKCQlpZiAoY3VycmVudCA8IDApIHsKCQkJY3AgPSBiYXNlOwoJCQljdXJyZW50ID0gMDsKCQl9CgkJZWxzZSB7CgkJCWNwID0gc3RyY2hyKGJhc2UgKyBjdXJyZW50ICsgMSwgJy8nKTsKCQkJaWYgKCFjcCkKCQkJCWRpZSgib29wcyBpbiBwcmVwX2V4Y2x1ZGUiKTsKCQkJY3ArKzsKCQl9CgkJc3RrLT5wcmV2ID0gZGlyLT5leGNsdWRlX3N0YWNrOwoJCXN0ay0+YmFzZWxlbiA9IGNwIC0gYmFzZTsKCQlzdGstPmV4Y2x1ZGVfaXggPSBlbC0+bnI7CgkJbWVtY3B5KGRpci0+YmFzZWJ1ZiArIGN1cnJlbnQsIGJhc2UgKyBjdXJyZW50LAoJCSAgICAgICBzdGstPmJhc2VsZW4gLSBjdXJyZW50KTsKCQlzdHJjcHkoZGlyLT5iYXNlYnVmICsgc3RrLT5iYXNlbGVuLCBkaXItPmV4Y2x1ZGVfcGVyX2Rpcik7CgkJYWRkX2V4Y2x1ZGVzX2Zyb21fZmlsZV90b19saXN0KGRpci0+YmFzZWJ1ZiwKCQkJCQkgICAgICAgZGlyLT5iYXNlYnVmLCBzdGstPmJhc2VsZW4sCgkJCQkJICAgICAgICZzdGstPmZpbGVidWYsIGVsLCAxKTsKCQlkaXItPmV4Y2x1ZGVfc3RhY2sgPSBzdGs7CgkJY3VycmVudCA9IHN0ay0+YmFzZWxlbjsKCX0KCWRpci0+YmFzZWJ1ZltiYXNlbGVuXSA9ICdcMCc7Cn0KCi8qIFNjYW4gdGhlIGxpc3QgYW5kIGxldCB0aGUgbGFzdCBtYXRjaCBkZXRlcm1pbmUgdGhlIGZhdGUuCiAqIFJldHVybiAxIGZvciBleGNsdWRlLCAwIGZvciBpbmNsdWRlIGFuZCAtMSBmb3IgdW5kZWNpZGVkLgogKi8KaW50IGV4Y2x1ZGVkX2Zyb21fbGlzdChjb25zdCBjaGFyICpwYXRobmFtZSwKCQkgICAgICAgaW50IHBhdGhsZW4sIGNvbnN0IGNoYXIgKmJhc2VuYW1lLCBpbnQgKmR0eXBlLAoJCSAgICAgICBzdHJ1Y3QgZXhjbHVkZV9saXN0ICplbCkKewoJaW50IGk7CgoJaWYgKCFlbC0+bnIpCgkJcmV0dXJuIC0xOwkvKiB1bmRlZmluZWQgKi8KCglmb3IgKGkgPSBlbC0+bnIgLSAxOyAwIDw9IGk7IGktLSkgewoJCXN0cnVjdCBleGNsdWRlICp4ID0gZWwtPmV4Y2x1ZGVzW2ldOwoJCWNvbnN0IGNoYXIgKm5hbWUsICpleGNsdWRlID0geC0+cGF0dGVybjsKCQlpbnQgdG9fZXhjbHVkZSA9IHgtPnRvX2V4Y2x1ZGU7CgkJaW50IG5hbWVsZW4sIHByZWZpeCA9IHgtPm5vd2lsZGNhcmRsZW47CgoJCWlmICh4LT5mbGFncyAmIEVYQ19GTEFHX01VU1RCRURJUikgewoJCQlpZiAoKmR0eXBlID09IERUX1VOS05PV04pCgkJCQkqZHR5cGUgPSBnZXRfZHR5cGUoTlVMTCwgcGF0aG5hbWUsIHBhdGhsZW4pOwoJCQlpZiAoKmR0eXBlICE9IERUX0RJUikKCQkJCWNvbnRpbnVlOwoJCX0KCgkJaWYgKHgtPmZsYWdzICYgRVhDX0ZMQUdfTk9ESVIpIHsKCQkJLyogbWF0Y2ggYmFzZW5hbWUgKi8KCQkJaWYgKHByZWZpeCA9PSB4LT5wYXR0ZXJubGVuKSB7CgkJCQlpZiAoIXN0cmNtcF9pY2FzZShleGNsdWRlLCBiYXNlbmFtZSkpCgkJCQkJcmV0dXJuIHRvX2V4Y2x1ZGU7CgkJCX0gZWxzZSBpZiAoeC0+ZmxhZ3MgJiBFWENfRkxBR19FTkRTV0lUSCkgewoJCQkJaWYgKHgtPnBhdHRlcm5sZW4gLSAxIDw9IHBhdGhsZW4gJiYKCQkJCSAgICAhc3RyY21wX2ljYXNlKGV4Y2x1ZGUgKyAxLCBwYXRobmFtZSArIHBhdGhsZW4gLSB4LT5wYXR0ZXJubGVuICsgMSkpCgkJCQkJcmV0dXJuIHRvX2V4Y2x1ZGU7CgkJCX0gZWxzZSB7CgkJCQlpZiAoZm5tYXRjaF9pY2FzZShleGNsdWRlLCBiYXNlbmFtZSwgMCkgPT0gMCkKCQkJCQlyZXR1cm4gdG9fZXhjbHVkZTsKCQkJfQoJCQljb250aW51ZTsKCQl9CgoJCS8qIG1hdGNoIHdpdGggRk5NX1BBVEhOQU1FOgoJCSAqIGV4Y2x1ZGUgaGFzIGJhc2UgKGJhc2VsZW4gbG9uZykgaW1wbGljaXRseSBpbiBmcm9udCBvZiBpdC4KCQkgKi8KCQlpZiAoKmV4Y2x1ZGUgPT0gJy8nKSB7CgkJCWV4Y2x1ZGUrKzsKCQkJcHJlZml4LS07CgkJfQoKCQlpZiAocGF0aGxlbiA8IHgtPmJhc2VsZW4gfHwKCQkgICAgKHgtPmJhc2VsZW4gJiYgcGF0aG5hbWVbeC0+YmFzZWxlbi0xXSAhPSAnLycpIHx8CgkJICAgIHN0cm5jbXBfaWNhc2UocGF0aG5hbWUsIHgtPmJhc2UsIHgtPmJhc2VsZW4pKQoJCQljb250aW51ZTsKCgkJbmFtZWxlbiA9IHgtPmJhc2VsZW4gPyBwYXRobGVuIC0geC0+YmFzZWxlbiA6IHBhdGhsZW47CgkJbmFtZSA9IHBhdGhuYW1lICsgcGF0aGxlbiAgLSBuYW1lbGVuOwoKCQkvKiBpZiB0aGUgbm9uLXdpbGRjYXJkIHBhcnQgaXMgbG9uZ2VyIHRoYW4gdGhlCgkJICAgcmVtYWluaW5nIHBhdGhuYW1lLCBzdXJlbHkgaXQgY2Fubm90IG1hdGNoICovCgkJaWYgKHByZWZpeCA+IG5hbWVsZW4pCgkJCWNvbnRpbnVlOwoKCQlpZiAocHJlZml4KSB7CgkJCWlmIChzdHJuY21wX2ljYXNlKGV4Y2x1ZGUsIG5hbWUsIHByZWZpeCkpCgkJCQljb250aW51ZTsKCQkJZXhjbHVkZSArPSBwcmVmaXg7CgkJCW5hbWUgICAgKz0gcHJlZml4OwoJCQluYW1lbGVuIC09IHByZWZpeDsKCQl9CgoJCWlmICghbmFtZWxlbiB8fCAhZm5tYXRjaF9pY2FzZShleGNsdWRlLCBuYW1lLCBGTk1fUEFUSE5BTUUpKQoJCQlyZXR1cm4gdG9fZXhjbHVkZTsKCX0KCXJldHVybiAtMTsgLyogdW5kZWNpZGVkICovCn0KCnN0YXRpYyBpbnQgZXhjbHVkZWQoc3RydWN0IGRpcl9zdHJ1Y3QgKmRpciwgY29uc3QgY2hhciAqcGF0aG5hbWUsIGludCAqZHR5cGVfcCkKewoJaW50IHBhdGhsZW4gPSBzdHJsZW4ocGF0aG5hbWUpOwoJaW50IHN0OwoJY29uc3QgY2hhciAqYmFzZW5hbWUgPSBzdHJyY2hyKHBhdGhuYW1lLCAnLycpOwoJYmFzZW5hbWUgPSAoYmFzZW5hbWUpID8gYmFzZW5hbWUrMSA6IHBhdGhuYW1lOwoKCXByZXBfZXhjbHVkZShkaXIsIHBhdGhuYW1lLCBiYXNlbmFtZS1wYXRobmFtZSk7Cglmb3IgKHN0ID0gRVhDX0NNREw7IHN0IDw9IEVYQ19GSUxFOyBzdCsrKSB7CgkJc3dpdGNoIChleGNsdWRlZF9mcm9tX2xpc3QocGF0aG5hbWUsIHBhdGhsZW4sIGJhc2VuYW1lLAoJCQkJCSAgIGR0eXBlX3AsICZkaXItPmV4Y2x1ZGVfbGlzdFtzdF0pKSB7CgkJY2FzZSAwOgoJCQlyZXR1cm4gMDsKCQljYXNlIDE6CgkJCXJldHVybiAxOwoJCX0KCX0KCXJldHVybiAwOwp9Cgp2b2lkIHBhdGhfZXhjbHVkZV9jaGVja19pbml0KHN0cnVjdCBwYXRoX2V4Y2x1ZGVfY2hlY2sgKmNoZWNrLAoJCQkgICAgIHN0cnVjdCBkaXJfc3RydWN0ICpkaXIpCnsKCWNoZWNrLT5kaXIgPSBkaXI7CglzdHJidWZfaW5pdCgmY2hlY2stPnBhdGgsIDI1Nik7Cn0KCnZvaWQgcGF0aF9leGNsdWRlX2NoZWNrX2NsZWFyKHN0cnVjdCBwYXRoX2V4Y2x1ZGVfY2hlY2sgKmNoZWNrKQp7CglzdHJidWZfcmVsZWFzZSgmY2hlY2stPnBhdGgpOwp9CgovKgogKiBJcyB0aGlzIG5hbWUgZXhjbHVkZWQ/ICBUaGlzIGlzIGZvciBhIGNhbGxlciBsaWtlIHNob3dfZmlsZXMoKSB0aGF0CiAqIGRvIG5vdCBob25vciBkaXJlY3RvcnkgaGllcmFyY2h5IGFuZCBpdGVyYXRlIHRocm91Z2ggcGF0aHMgdGhhdCBhcmUKICogcG9zc2libHkgaW4gYW4gaWdub3JlZCBkaXJlY3RvcnkuCiAqCiAqIEEgcGF0aCB0byBhIGRpcmVjdG9yeSBrbm93biB0byBiZSBleGNsdWRlZCBpcyBsZWZ0IGluIGNoZWNrLT5wYXRoIHRvCiAqIG9wdGltaXplIGZvciByZXBlYXRlZCBjaGVja3MgZm9yIGZpbGVzIGluIHRoZSBzYW1lIGV4Y2x1ZGVkIGRpcmVjdG9yeS4KICovCmludCBwYXRoX2V4Y2x1ZGVkKHN0cnVjdCBwYXRoX2V4Y2x1ZGVfY2hlY2sgKmNoZWNrLAoJCSAgY29uc3QgY2hhciAqbmFtZSwgaW50IG5hbWVsZW4sIGludCAqZHR5cGUpCnsKCWludCBpOwoJc3RydWN0IHN0cmJ1ZiAqcGF0aCA9ICZjaGVjay0+cGF0aDsKCgkvKgoJICogd2UgYWxsb3cgdGhlIGNhbGxlciB0byBwYXNzIG5hbWVsZW4gYXMgYW4gb3B0aW1pemF0aW9uOyBpdAoJICogbXVzdCBtYXRjaCB0aGUgbGVuZ3RoIG9mIHRoZSBuYW1lLCBhcyB3ZSBldmVudHVhbGx5IGNhbGwKCSAqIGV4Y2x1ZGVkKCkgb24gdGhlIHdob2xlIG5hbWUgc3RyaW5nLgoJICovCglpZiAobmFtZWxlbiA8IDApCgkJbmFtZWxlbiA9IHN0cmxlbihuYW1lKTsKCglpZiAocGF0aC0+bGVuICYmCgkgICAgcGF0aC0+bGVuIDw9IG5hbWVsZW4gJiYKCSAgICAhbWVtY21wKG5hbWUsIHBhdGgtPmJ1ZiwgcGF0aC0+bGVuKSAmJgoJICAgICghbmFtZVtwYXRoLT5sZW5dIHx8IG5hbWVbcGF0aC0+bGVuXSA9PSAnLycpKQoJCXJldHVybiAxOwoKCXN0cmJ1Zl9zZXRsZW4ocGF0aCwgMCk7Cglmb3IgKGkgPSAwOyBuYW1lW2ldOyBpKyspIHsKCQlpbnQgY2ggPSBuYW1lW2ldOwoKCQlpZiAoY2ggPT0gJy8nKSB7CgkJCWludCBkdCA9IERUX0RJUjsKCQkJaWYgKGV4Y2x1ZGVkKGNoZWNrLT5kaXIsIHBhdGgtPmJ1ZiwgJmR0KSkKCQkJCXJldHVybiAxOwoJCX0KCQlzdHJidWZfYWRkY2gocGF0aCwgY2gpOwoJfQoKCS8qIEFuIGVudHJ5IGluIHRoZSBpbmRleDsgY2Fubm90IGJlIGEgZGlyZWN0b3J5IHdpdGggc3ViZW50cmllcyAqLwoJc3RyYnVmX3NldGxlbihwYXRoLCAwKTsKCglyZXR1cm4gZXhjbHVkZWQoY2hlY2stPmRpciwgbmFtZSwgZHR5cGUpOwp9CgpzdGF0aWMgc3RydWN0IGRpcl9lbnRyeSAqZGlyX2VudHJ5X25ldyhjb25zdCBjaGFyICpwYXRobmFtZSwgaW50IGxlbikKewoJc3RydWN0IGRpcl9lbnRyeSAqZW50OwoKCWVudCA9IHhtYWxsb2Moc2l6ZW9mKCplbnQpICsgbGVuICsgMSk7CgllbnQtPmxlbiA9IGxlbjsKCW1lbWNweShlbnQtPm5hbWUsIHBhdGhuYW1lLCBsZW4pOwoJZW50LT5uYW1lW2xlbl0gPSAwOwoJcmV0dXJuIGVudDsKfQoKc3RhdGljIHN0cnVjdCBkaXJfZW50cnkgKmRpcl9hZGRfbmFtZShzdHJ1Y3QgZGlyX3N0cnVjdCAqZGlyLCBjb25zdCBjaGFyICpwYXRobmFtZSwgaW50IGxlbikKewoJaWYgKGNhY2hlX25hbWVfZXhpc3RzKHBhdGhuYW1lLCBsZW4sIGlnbm9yZV9jYXNlKSkKCQlyZXR1cm4gTlVMTDsKCglBTExPQ19HUk9XKGRpci0+ZW50cmllcywgZGlyLT5ucisxLCBkaXItPmFsbG9jKTsKCXJldHVybiBkaXItPmVudHJpZXNbZGlyLT5ucisrXSA9IGRpcl9lbnRyeV9uZXcocGF0aG5hbWUsIGxlbik7Cn0KCnN0cnVjdCBkaXJfZW50cnkgKmRpcl9hZGRfaWdub3JlZChzdHJ1Y3QgZGlyX3N0cnVjdCAqZGlyLCBjb25zdCBjaGFyICpwYXRobmFtZSwgaW50IGxlbikKewoJaWYgKCFjYWNoZV9uYW1lX2lzX290aGVyKHBhdGhuYW1lLCBsZW4pKQoJCXJldHVybiBOVUxMOwoKCUFMTE9DX0dST1coZGlyLT5pZ25vcmVkLCBkaXItPmlnbm9yZWRfbnIrMSwgZGlyLT5pZ25vcmVkX2FsbG9jKTsKCXJldHVybiBkaXItPmlnbm9yZWRbZGlyLT5pZ25vcmVkX25yKytdID0gZGlyX2VudHJ5X25ldyhwYXRobmFtZSwgbGVuKTsKfQoKZW51bSBleGlzdF9zdGF0dXMgewoJaW5kZXhfbm9uZXhpc3RlbnQgPSAwLAoJaW5kZXhfZGlyZWN0b3J5LAoJaW5kZXhfZ2l0ZGlyCn07CgovKgogKiBEbyBub3QgdXNlIHRoZSBhbHBoYWJldGljYWxseSBzdG9yZWQgaW5kZXggdG8gbG9vayB1cAogKiB0aGUgZGlyZWN0b3J5IG5hbWU7IGluc3RlYWQsIHVzZSB0aGUgY2FzZSBpbnNlbnNpdGl2ZQogKiBuYW1lIGhhc2guCiAqLwpzdGF0aWMgZW51bSBleGlzdF9zdGF0dXMgZGlyZWN0b3J5X2V4aXN0c19pbl9pbmRleF9pY2FzZShjb25zdCBjaGFyICpkaXJuYW1lLCBpbnQgbGVuKQp7CglzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gaW5kZXhfbmFtZV9leGlzdHMoJnRoZV9pbmRleCwgZGlybmFtZSwgbGVuICsgMSwgaWdub3JlX2Nhc2UpOwoJdW5zaWduZWQgY2hhciBlbmRjaGFyOwoKCWlmICghY2UpCgkJcmV0dXJuIGluZGV4X25vbmV4aXN0ZW50OwoJZW5kY2hhciA9IGNlLT5uYW1lW2xlbl07CgoJLyoKCSAqIFRoZSBjYWNoZV9lbnRyeSBzdHJ1Y3R1cmUgcmV0dXJuZWQgd2lsbCBjb250YWluIHRoaXMgZGlybmFtZQoJICogYW5kIHBvc3NpYmx5IGFkZGl0aW9uYWwgcGF0aCBjb21wb25lbnRzLgoJICovCglpZiAoZW5kY2hhciA9PSAnLycpCgkJcmV0dXJuIGluZGV4X2RpcmVjdG9yeTsKCgkvKgoJICogSWYgdGhlcmUgYXJlIG5vIGFkZGl0aW9uYWwgcGF0aCBjb21wb25lbnRzLCB0aGVuIHRoaXMgY2FjaGVfZW50cnkKCSAqIHJlcHJlc2VudHMgYSBzdWJtb2R1bGUuICBTdWJtb2R1bGVzLCBkZXNwaXRlIGJlaW5nIGRpcmVjdG9yaWVzLAoJICogYXJlIHN0b3JlZCBpbiB0aGUgY2FjaGUgd2l0aG91dCBhIGNsb3Npbmcgc2xhc2guCgkgKi8KCWlmICghZW5kY2hhciAmJiBTX0lTR0lUTElOSyhjZS0+Y2VfbW9kZSkpCgkJcmV0dXJuIGluZGV4X2dpdGRpcjsKCgkvKiBUaGlzIHNob3VsZCBuZXZlciBiZSBoaXQsIGJ1dCBpdCBleGlzdHMganVzdCBpbiBjYXNlLiAqLwoJcmV0dXJuIGluZGV4X25vbmV4aXN0ZW50Owp9CgovKgogKiBUaGUgaW5kZXggc29ydHMgYWxwaGFiZXRpY2FsbHkgYnkgZW50cnkgbmFtZSwgd2hpY2gKICogbWVhbnMgdGhhdCBhIGdpdGxpbmsgc29ydHMgYXMgJ1wwJyBhdCB0aGUgZW5kLCB3aGlsZQogKiBhIGRpcmVjdG9yeSAod2hpY2ggaXMgZGVmaW5lZCBub3QgYXMgYW4gZW50cnksIGJ1dCBhcwogKiB0aGUgZmlsZXMgaXQgY29udGFpbnMpIHdpbGwgc29ydCB3aXRoIHRoZSAnLycgYXQgdGhlCiAqIGVuZC4KICovCnN0YXRpYyBlbnVtIGV4aXN0X3N0YXR1cyBkaXJlY3RvcnlfZXhpc3RzX2luX2luZGV4KGNvbnN0IGNoYXIgKmRpcm5hbWUsIGludCBsZW4pCnsKCWludCBwb3M7CgoJaWYgKGlnbm9yZV9jYXNlKQoJCXJldHVybiBkaXJlY3RvcnlfZXhpc3RzX2luX2luZGV4X2ljYXNlKGRpcm5hbWUsIGxlbik7CgoJcG9zID0gY2FjaGVfbmFtZV9wb3MoZGlybmFtZSwgbGVuKTsKCWlmIChwb3MgPCAwKQoJCXBvcyA9IC1wb3MtMTsKCXdoaWxlIChwb3MgPCBhY3RpdmVfbnIpIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gYWN0aXZlX2NhY2hlW3BvcysrXTsKCQl1bnNpZ25lZCBjaGFyIGVuZGNoYXI7CgoJCWlmIChzdHJuY21wKGNlLT5uYW1lLCBkaXJuYW1lLCBsZW4pKQoJCQlicmVhazsKCQllbmRjaGFyID0gY2UtPm5hbWVbbGVuXTsKCQlpZiAoZW5kY2hhciA+ICcvJykKCQkJYnJlYWs7CgkJaWYgKGVuZGNoYXIgPT0gJy8nKQoJCQlyZXR1cm4gaW5kZXhfZGlyZWN0b3J5OwoJCWlmICghZW5kY2hhciAmJiBTX0lTR0lUTElOSyhjZS0+Y2VfbW9kZSkpCgkJCXJldHVybiBpbmRleF9naXRkaXI7Cgl9CglyZXR1cm4gaW5kZXhfbm9uZXhpc3RlbnQ7Cn0KCi8qCiAqIFdoZW4gd2UgZmluZCBhIGRpcmVjdG9yeSB3aGVuIHRyYXZlcnNpbmcgdGhlIGZpbGVzeXN0ZW0sIHdlCiAqIGhhdmUgdGhyZWUgZGlzdGluY3QgY2FzZXM6CiAqCiAqICAtIGlnbm9yZSBpdAogKiAgLSBzZWUgaXQgYXMgYSBkaXJlY3RvcnkKICogIC0gcmVjdXJzZSBpbnRvIGl0CiAqCiAqIGFuZCB3aGljaCBvbmUgd2UgY2hvb3NlIGRlcGVuZHMgb24gYSBjb21iaW5hdGlvbiBvZiBleGlzdGluZwogKiBnaXQgaW5kZXggY29udGVudHMgYW5kIHRoZSBmbGFncyBwYXNzZWQgaW50byB0aGUgZGlyZWN0b3J5CiAqIHRyYXZlcnNhbCByb3V0aW5lLgogKgogKiBDYXNlIDE6IElmIHdlICphbHJlYWR5KiBoYXZlIGVudHJpZXMgaW4gdGhlIGluZGV4IHVuZGVyIHRoYXQKICogZGlyZWN0b3J5IG5hbWUsIHdlIGFsd2F5cyByZWN1cnNlIGludG8gdGhlIGRpcmVjdG9yeSB0byBzZWUKICogYWxsIHRoZSBmaWxlcy4KICoKICogQ2FzZSAyOiBJZiB3ZSAqYWxyZWFkeSogaGF2ZSB0aGF0IGRpcmVjdG9yeSBuYW1lIGFzIGEgZ2l0bGluaywKICogd2UgYWx3YXlzIGNvbnRpbnVlIHRvIHNlZSBpdCBhcyBhIGdpdGxpbmssIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlcgogKiB0aGVyZSBpcyBhbiBhY3R1YWwgZ2l0IGRpcmVjdG9yeSB0aGVyZSBvciBub3QgKGl0IG1pZ2h0IG5vdAogKiBiZSBjaGVja2VkIG91dCBhcyBhIHN1YnByb2plY3QhKQogKgogKiBDYXNlIDM6IGlmIHdlIGRpZG4ndCBoYXZlIGl0IGluIHRoZSBpbmRleCBwcmV2aW91c2x5LCB3ZQogKiBoYXZlIGEgZmV3IHN1Yi1jYXNlczoKICoKICogIChhKSBpZiAic2hvd19vdGhlcl9kaXJlY3RvcmllcyIgaXMgdHJ1ZSwgd2Ugc2hvdyBpdCBhcwogKiAgICAgIGp1c3QgYSBkaXJlY3RvcnksIHVubGVzcyAiaGlkZV9lbXB0eV9kaXJlY3RvcmllcyIgaXMKICogICAgICBhbHNvIHRydWUgYW5kIHRoZSBkaXJlY3RvcnkgaXMgZW1wdHksIGluIHdoaWNoIGNhc2UKICogICAgICB3ZSBqdXN0IGlnbm9yZSBpdCBlbnRpcmVseS4KICogIChiKSBpZiBpdCBsb29rcyBsaWtlIGEgZ2l0IGRpcmVjdG9yeSwgYW5kIHdlIGRvbid0IGhhdmUKICogICAgICAnbm9fZ2l0bGlua3MnIHNldCB3ZSB0cmVhdCBpdCBhcyBhIGdpdGxpbmssIGFuZCBzaG93IGl0CiAqICAgICAgYXMgYSBkaXJlY3RvcnkuCiAqICAoYykgb3RoZXJ3aXNlLCB3ZSByZWN1cnNlIGludG8gaXQuCiAqLwplbnVtIGRpcmVjdG9yeV90cmVhdG1lbnQgewoJc2hvd19kaXJlY3RvcnksCglpZ25vcmVfZGlyZWN0b3J5LAoJcmVjdXJzZV9pbnRvX2RpcmVjdG9yeQp9OwoKc3RhdGljIGVudW0gZGlyZWN0b3J5X3RyZWF0bWVudCB0cmVhdF9kaXJlY3Rvcnkoc3RydWN0IGRpcl9zdHJ1Y3QgKmRpciwKCWNvbnN0IGNoYXIgKmRpcm5hbWUsIGludCBsZW4sCgljb25zdCBzdHJ1Y3QgcGF0aF9zaW1wbGlmeSAqc2ltcGxpZnkpCnsKCS8qIFRoZSAibGVuLTEiIGlzIHRvIHN0cmlwIHRoZSBmaW5hbCAnLycgKi8KCXN3aXRjaCAoZGlyZWN0b3J5X2V4aXN0c19pbl9pbmRleChkaXJuYW1lLCBsZW4tMSkpIHsKCWNhc2UgaW5kZXhfZGlyZWN0b3J5OgoJCXJldHVybiByZWN1cnNlX2ludG9fZGlyZWN0b3J5OwoKCWNhc2UgaW5kZXhfZ2l0ZGlyOgoJCWlmIChkaXItPmZsYWdzICYgRElSX1NIT1dfT1RIRVJfRElSRUNUT1JJRVMpCgkJCXJldHVybiBpZ25vcmVfZGlyZWN0b3J5OwoJCXJldHVybiBzaG93X2RpcmVjdG9yeTsKCgljYXNlIGluZGV4X25vbmV4aXN0ZW50OgoJCWlmIChkaXItPmZsYWdzICYgRElSX1NIT1dfT1RIRVJfRElSRUNUT1JJRVMpCgkJCWJyZWFrOwoJCWlmICghKGRpci0+ZmxhZ3MgJiBESVJfTk9fR0lUTElOS1MpKSB7CgkJCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgkJCWlmIChyZXNvbHZlX2dpdGxpbmtfcmVmKGRpcm5hbWUsICJIRUFEIiwgc2hhMSkgPT0gMCkKCQkJCXJldHVybiBzaG93X2RpcmVjdG9yeTsKCQl9CgkJcmV0dXJuIHJlY3Vyc2VfaW50b19kaXJlY3Rvcnk7Cgl9CgoJLyogVGhpcyBpcyB0aGUgInNob3dfb3RoZXJfZGlyZWN0b3JpZXMiIGNhc2UgKi8KCWlmICghKGRpci0+ZmxhZ3MgJiBESVJfSElERV9FTVBUWV9ESVJFQ1RPUklFUykpCgkJcmV0dXJuIHNob3dfZGlyZWN0b3J5OwoJaWYgKCFyZWFkX2RpcmVjdG9yeV9yZWN1cnNpdmUoZGlyLCBkaXJuYW1lLCBsZW4sIDEsIHNpbXBsaWZ5KSkKCQlyZXR1cm4gaWdub3JlX2RpcmVjdG9yeTsKCXJldHVybiBzaG93X2RpcmVjdG9yeTsKfQoKLyoKICogVGhpcyBpcyBhbiBpbmV4YWN0IGVhcmx5IHBydW5pbmcgb2YgYW55IHJlY3Vyc2l2ZSBkaXJlY3RvcnkKICogcmVhZGluZyAtIGlmIHRoZSBwYXRoIGNhbm5vdCBwb3NzaWJseSBiZSBpbiB0aGUgcGF0aHNwZWMsCiAqIHJldHVybiB0cnVlLCBhbmQgd2UnbGwgc2tpcCBpdCBlYXJseS4KICovCnN0YXRpYyBpbnQgc2ltcGxpZnlfYXdheShjb25zdCBjaGFyICpwYXRoLCBpbnQgcGF0aGxlbiwgY29uc3Qgc3RydWN0IHBhdGhfc2ltcGxpZnkgKnNpbXBsaWZ5KQp7CglpZiAoc2ltcGxpZnkpIHsKCQlmb3IgKDs7KSB7CgkJCWNvbnN0IGNoYXIgKm1hdGNoID0gc2ltcGxpZnktPnBhdGg7CgkJCWludCBsZW4gPSBzaW1wbGlmeS0+bGVuOwoKCQkJaWYgKCFtYXRjaCkKCQkJCWJyZWFrOwoJCQlpZiAobGVuID4gcGF0aGxlbikKCQkJCWxlbiA9IHBhdGhsZW47CgkJCWlmICghbWVtY21wKHBhdGgsIG1hdGNoLCBsZW4pKQoJCQkJcmV0dXJuIDA7CgkJCXNpbXBsaWZ5Kys7CgkJfQoJCXJldHVybiAxOwoJfQoJcmV0dXJuIDA7Cn0KCi8qCiAqIFRoaXMgZnVuY3Rpb24gdGVsbHMgdXMgd2hldGhlciBhbiBleGNsdWRlZCBwYXRoIG1hdGNoZXMgYQogKiBsaXN0IG9mICJpbnRlcmVzdGluZyIgcGF0aHNwZWNzLiBUaGF0IGlzLCB3aGV0aGVyIGEgcGF0aCBtYXRjaGVkCiAqIGJ5IGFueSBvZiB0aGUgcGF0aHNwZWNzIGNvdWxkIHBvc3NpYmx5IGJlIGlnbm9yZWQgYnkgZXhjbHVkaW5nCiAqIHRoZSBzcGVjaWZpZWQgcGF0aC4gVGhpcyBjYW4gaGFwcGVuIGlmOgogKgogKiAgIDEuIHRoZSBwYXRoIGlzIG1lbnRpb25lZCBleHBsaWNpdGx5IGluIHRoZSBwYXRoc3BlYwogKgogKiAgIDIuIHRoZSBwYXRoIGlzIGEgZGlyZWN0b3J5IHByZWZpeCBvZiBzb21lIGVsZW1lbnQgaW4gdGhlCiAqICAgICAgcGF0aHNwZWMKICovCnN0YXRpYyBpbnQgZXhjbHVkZV9tYXRjaGVzX3BhdGhzcGVjKGNvbnN0IGNoYXIgKnBhdGgsIGludCBsZW4sCgkJY29uc3Qgc3RydWN0IHBhdGhfc2ltcGxpZnkgKnNpbXBsaWZ5KQp7CglpZiAoc2ltcGxpZnkpIHsKCQlmb3IgKDsgc2ltcGxpZnktPnBhdGg7IHNpbXBsaWZ5KyspIHsKCQkJaWYgKGxlbiA9PSBzaW1wbGlmeS0+bGVuCgkJCSAgICAmJiAhbWVtY21wKHBhdGgsIHNpbXBsaWZ5LT5wYXRoLCBsZW4pKQoJCQkJcmV0dXJuIDE7CgkJCWlmIChsZW4gPCBzaW1wbGlmeS0+bGVuCgkJCSAgICAmJiBzaW1wbGlmeS0+cGF0aFtsZW5dID09ICcvJwoJCQkgICAgJiYgIW1lbWNtcChwYXRoLCBzaW1wbGlmeS0+cGF0aCwgbGVuKSkKCQkJCXJldHVybiAxOwoJCX0KCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdldF9pbmRleF9kdHlwZShjb25zdCBjaGFyICpwYXRoLCBpbnQgbGVuKQp7CglpbnQgcG9zOwoJc3RydWN0IGNhY2hlX2VudHJ5ICpjZTsKCgljZSA9IGNhY2hlX25hbWVfZXhpc3RzKHBhdGgsIGxlbiwgMCk7CglpZiAoY2UpIHsKCQlpZiAoIWNlX3VwdG9kYXRlKGNlKSkKCQkJcmV0dXJuIERUX1VOS05PV047CgkJaWYgKFNfSVNHSVRMSU5LKGNlLT5jZV9tb2RlKSkKCQkJcmV0dXJuIERUX0RJUjsKCQkvKgoJCSAqIE5vYm9keSBhY3R1YWxseSBjYXJlcyBhYm91dCB0aGUKCQkgKiBkaWZmZXJlbmNlIGJldHdlZW4gRFRfTE5LIGFuZCBEVF9SRUcKCQkgKi8KCQlyZXR1cm4gRFRfUkVHOwoJfQoKCS8qIFRyeSB0byBsb29rIGl0IHVwIGFzIGEgZGlyZWN0b3J5ICovCglwb3MgPSBjYWNoZV9uYW1lX3BvcyhwYXRoLCBsZW4pOwoJaWYgKHBvcyA+PSAwKQoJCXJldHVybiBEVF9VTktOT1dOOwoJcG9zID0gLXBvcy0xOwoJd2hpbGUgKHBvcyA8IGFjdGl2ZV9ucikgewoJCWNlID0gYWN0aXZlX2NhY2hlW3BvcysrXTsKCQlpZiAoc3RybmNtcChjZS0+bmFtZSwgcGF0aCwgbGVuKSkKCQkJYnJlYWs7CgkJaWYgKGNlLT5uYW1lW2xlbl0gPiAnLycpCgkJCWJyZWFrOwoJCWlmIChjZS0+bmFtZVtsZW5dIDwgJy8nKQoJCQljb250aW51ZTsKCQlpZiAoIWNlX3VwdG9kYXRlKGNlKSkKCQkJYnJlYWs7CS8qIGNvbnRpbnVlPyAqLwoJCXJldHVybiBEVF9ESVI7Cgl9CglyZXR1cm4gRFRfVU5LTk9XTjsKfQoKc3RhdGljIGludCBnZXRfZHR5cGUoc3RydWN0IGRpcmVudCAqZGUsIGNvbnN0IGNoYXIgKnBhdGgsIGludCBsZW4pCnsKCWludCBkdHlwZSA9IGRlID8gRFRZUEUoZGUpIDogRFRfVU5LTk9XTjsKCXN0cnVjdCBzdGF0IHN0OwoKCWlmIChkdHlwZSAhPSBEVF9VTktOT1dOKQoJCXJldHVybiBkdHlwZTsKCWR0eXBlID0gZ2V0X2luZGV4X2R0eXBlKHBhdGgsIGxlbik7CglpZiAoZHR5cGUgIT0gRFRfVU5LTk9XTikKCQlyZXR1cm4gZHR5cGU7CglpZiAobHN0YXQocGF0aCwgJnN0KSkKCQlyZXR1cm4gZHR5cGU7CglpZiAoU19JU1JFRyhzdC5zdF9tb2RlKSkKCQlyZXR1cm4gRFRfUkVHOwoJaWYgKFNfSVNESVIoc3Quc3RfbW9kZSkpCgkJcmV0dXJuIERUX0RJUjsKCWlmIChTX0lTTE5LKHN0LnN0X21vZGUpKQoJCXJldHVybiBEVF9MTks7CglyZXR1cm4gZHR5cGU7Cn0KCmVudW0gcGF0aF90cmVhdG1lbnQgewoJcGF0aF9pZ25vcmVkLAoJcGF0aF9oYW5kbGVkLAoJcGF0aF9yZWN1cnNlCn07CgpzdGF0aWMgZW51bSBwYXRoX3RyZWF0bWVudCB0cmVhdF9vbmVfcGF0aChzdHJ1Y3QgZGlyX3N0cnVjdCAqZGlyLAoJCQkJCSAgc3RydWN0IHN0cmJ1ZiAqcGF0aCwKCQkJCQkgIGNvbnN0IHN0cnVjdCBwYXRoX3NpbXBsaWZ5ICpzaW1wbGlmeSwKCQkJCQkgIGludCBkdHlwZSwgc3RydWN0IGRpcmVudCAqZGUpCnsKCWludCBleGNsdWRlID0gZXhjbHVkZWQoZGlyLCBwYXRoLT5idWYsICZkdHlwZSk7CglpZiAoZXhjbHVkZSAmJiAoZGlyLT5mbGFncyAmIERJUl9DT0xMRUNUX0lHTk9SRUQpCgkgICAgJiYgZXhjbHVkZV9tYXRjaGVzX3BhdGhzcGVjKHBhdGgtPmJ1ZiwgcGF0aC0+bGVuLCBzaW1wbGlmeSkpCgkJZGlyX2FkZF9pZ25vcmVkKGRpciwgcGF0aC0+YnVmLCBwYXRoLT5sZW4pOwoKCS8qCgkgKiBFeGNsdWRlZD8gSWYgd2UgZG9uJ3QgZXhwbGljaXRseSB3YW50IHRvIHNob3cKCSAqIGlnbm9yZWQgZmlsZXMsIGlnbm9yZSBpdAoJICovCglpZiAoZXhjbHVkZSAmJiAhKGRpci0+ZmxhZ3MgJiBESVJfU0hPV19JR05PUkVEKSkKCQlyZXR1cm4gcGF0aF9pZ25vcmVkOwoKCWlmIChkdHlwZSA9PSBEVF9VTktOT1dOKQoJCWR0eXBlID0gZ2V0X2R0eXBlKGRlLCBwYXRoLT5idWYsIHBhdGgtPmxlbik7CgoJLyoKCSAqIERvIHdlIHdhbnQgdG8gc2VlIGp1c3QgdGhlIGlnbm9yZWQgZmlsZXM/CgkgKiBXZSBzdGlsbCBuZWVkIHRvIHJlY3Vyc2UgaW50byBkaXJlY3RvcmllcywKCSAqIGV2ZW4gaWYgd2UgZG9uJ3QgaWdub3JlIHRoZW0sIHNpbmNlIHRoZQoJICogZGlyZWN0b3J5IG1heSBjb250YWluIGZpbGVzIHRoYXQgd2UgZG8uLgoJICovCglpZiAoIWV4Y2x1ZGUgJiYgKGRpci0+ZmxhZ3MgJiBESVJfU0hPV19JR05PUkVEKSkgewoJCWlmIChkdHlwZSAhPSBEVF9ESVIpCgkJCXJldHVybiBwYXRoX2lnbm9yZWQ7Cgl9CgoJc3dpdGNoIChkdHlwZSkgewoJZGVmYXVsdDoKCQlyZXR1cm4gcGF0aF9pZ25vcmVkOwoJY2FzZSBEVF9ESVI6CgkJc3RyYnVmX2FkZGNoKHBhdGgsICcvJyk7CgkJc3dpdGNoICh0cmVhdF9kaXJlY3RvcnkoZGlyLCBwYXRoLT5idWYsIHBhdGgtPmxlbiwgc2ltcGxpZnkpKSB7CgkJY2FzZSBzaG93X2RpcmVjdG9yeToKCQkJaWYgKGV4Y2x1ZGUgIT0gISEoZGlyLT5mbGFncwoJCQkJCSAgJiBESVJfU0hPV19JR05PUkVEKSkKCQkJCXJldHVybiBwYXRoX2lnbm9yZWQ7CgkJCWJyZWFrOwoJCWNhc2UgcmVjdXJzZV9pbnRvX2RpcmVjdG9yeToKCQkJcmV0dXJuIHBhdGhfcmVjdXJzZTsKCQljYXNlIGlnbm9yZV9kaXJlY3Rvcnk6CgkJCXJldHVybiBwYXRoX2lnbm9yZWQ7CgkJfQoJCWJyZWFrOwoJY2FzZSBEVF9SRUc6CgljYXNlIERUX0xOSzoKCQlicmVhazsKCX0KCXJldHVybiBwYXRoX2hhbmRsZWQ7Cn0KCnN0YXRpYyBlbnVtIHBhdGhfdHJlYXRtZW50IHRyZWF0X3BhdGgoc3RydWN0IGRpcl9zdHJ1Y3QgKmRpciwKCQkJCSAgICAgIHN0cnVjdCBkaXJlbnQgKmRlLAoJCQkJICAgICAgc3RydWN0IHN0cmJ1ZiAqcGF0aCwKCQkJCSAgICAgIGludCBiYXNlbGVuLAoJCQkJICAgICAgY29uc3Qgc3RydWN0IHBhdGhfc2ltcGxpZnkgKnNpbXBsaWZ5KQp7CglpbnQgZHR5cGU7CgoJaWYgKGlzX2RvdF9vcl9kb3Rkb3QoZGUtPmRfbmFtZSkgfHwgIXN0cmNtcChkZS0+ZF9uYW1lLCAiLmdpdCIpKQoJCXJldHVybiBwYXRoX2lnbm9yZWQ7CglzdHJidWZfc2V0bGVuKHBhdGgsIGJhc2VsZW4pOwoJc3RyYnVmX2FkZHN0cihwYXRoLCBkZS0+ZF9uYW1lKTsKCWlmIChzaW1wbGlmeV9hd2F5KHBhdGgtPmJ1ZiwgcGF0aC0+bGVuLCBzaW1wbGlmeSkpCgkJcmV0dXJuIHBhdGhfaWdub3JlZDsKCglkdHlwZSA9IERUWVBFKGRlKTsKCXJldHVybiB0cmVhdF9vbmVfcGF0aChkaXIsIHBhdGgsIHNpbXBsaWZ5LCBkdHlwZSwgZGUpOwp9CgovKgogKiBSZWFkIGEgZGlyZWN0b3J5IHRyZWUuIFdlIGN1cnJlbnRseSBpZ25vcmUgYW55dGhpbmcgYnV0CiAqIGRpcmVjdG9yaWVzLCByZWd1bGFyIGZpbGVzIGFuZCBzeW1saW5rcy4gVGhhdCdzIGJlY2F1c2UgZ2l0CiAqIGRvZXNuJ3QgaGFuZGxlIHRoZW0gYXQgYWxsIHlldC4gTWF5YmUgdGhhdCB3aWxsIGNoYW5nZSBzb21lCiAqIGRheS4KICoKICogQWxzbywgd2UgaWdub3JlIHRoZSBuYW1lICIuZ2l0IiAoZXZlbiBpZiBpdCBpcyBub3QgYSBkaXJlY3RvcnkpLgogKiBUaGF0IGxpa2VseSB3aWxsIG5vdCBjaGFuZ2UuCiAqLwpzdGF0aWMgaW50IHJlYWRfZGlyZWN0b3J5X3JlY3Vyc2l2ZShzdHJ1Y3QgZGlyX3N0cnVjdCAqZGlyLAoJCQkJICAgIGNvbnN0IGNoYXIgKmJhc2UsIGludCBiYXNlbGVuLAoJCQkJICAgIGludCBjaGVja19vbmx5LAoJCQkJICAgIGNvbnN0IHN0cnVjdCBwYXRoX3NpbXBsaWZ5ICpzaW1wbGlmeSkKewoJRElSICpmZGlyOwoJaW50IGNvbnRlbnRzID0gMDsKCXN0cnVjdCBkaXJlbnQgKmRlOwoJc3RydWN0IHN0cmJ1ZiBwYXRoID0gU1RSQlVGX0lOSVQ7CgoJc3RyYnVmX2FkZCgmcGF0aCwgYmFzZSwgYmFzZWxlbik7CgoJZmRpciA9IG9wZW5kaXIocGF0aC5sZW4gPyBwYXRoLmJ1ZiA6ICIuIik7CglpZiAoIWZkaXIpCgkJZ290byBvdXQ7CgoJd2hpbGUgKChkZSA9IHJlYWRkaXIoZmRpcikpICE9IE5VTEwpIHsKCQlzd2l0Y2ggKHRyZWF0X3BhdGgoZGlyLCBkZSwgJnBhdGgsIGJhc2VsZW4sIHNpbXBsaWZ5KSkgewoJCWNhc2UgcGF0aF9yZWN1cnNlOgoJCQljb250ZW50cyArPSByZWFkX2RpcmVjdG9yeV9yZWN1cnNpdmUoZGlyLCBwYXRoLmJ1ZiwKCQkJCQkJCSAgICAgcGF0aC5sZW4sIDAsCgkJCQkJCQkgICAgIHNpbXBsaWZ5KTsKCQkJY29udGludWU7CgkJY2FzZSBwYXRoX2lnbm9yZWQ6CgkJCWNvbnRpbnVlOwoJCWNhc2UgcGF0aF9oYW5kbGVkOgoJCQlicmVhazsKCQl9CgkJY29udGVudHMrKzsKCQlpZiAoY2hlY2tfb25seSkKCQkJYnJlYWs7CgkJZGlyX2FkZF9uYW1lKGRpciwgcGF0aC5idWYsIHBhdGgubGVuKTsKCX0KCWNsb3NlZGlyKGZkaXIpOwogb3V0OgoJc3RyYnVmX3JlbGVhc2UoJnBhdGgpOwoKCXJldHVybiBjb250ZW50czsKfQoKc3RhdGljIGludCBjbXBfbmFtZShjb25zdCB2b2lkICpwMSwgY29uc3Qgdm9pZCAqcDIpCnsKCWNvbnN0IHN0cnVjdCBkaXJfZW50cnkgKmUxID0gKihjb25zdCBzdHJ1Y3QgZGlyX2VudHJ5ICoqKXAxOwoJY29uc3Qgc3RydWN0IGRpcl9lbnRyeSAqZTIgPSAqKGNvbnN0IHN0cnVjdCBkaXJfZW50cnkgKiopcDI7CgoJcmV0dXJuIGNhY2hlX25hbWVfY29tcGFyZShlMS0+bmFtZSwgZTEtPmxlbiwKCQkJCSAgZTItPm5hbWUsIGUyLT5sZW4pOwp9CgpzdGF0aWMgc3RydWN0IHBhdGhfc2ltcGxpZnkgKmNyZWF0ZV9zaW1wbGlmeShjb25zdCBjaGFyICoqcGF0aHNwZWMpCnsKCWludCBuciwgYWxsb2MgPSAwOwoJc3RydWN0IHBhdGhfc2ltcGxpZnkgKnNpbXBsaWZ5ID0gTlVMTDsKCglpZiAoIXBhdGhzcGVjKQoJCXJldHVybiBOVUxMOwoKCWZvciAobnIgPSAwIDsgOyBucisrKSB7CgkJY29uc3QgY2hhciAqbWF0Y2g7CgkJaWYgKG5yID49IGFsbG9jKSB7CgkJCWFsbG9jID0gYWxsb2NfbnIoYWxsb2MpOwoJCQlzaW1wbGlmeSA9IHhyZWFsbG9jKHNpbXBsaWZ5LCBhbGxvYyAqIHNpemVvZigqc2ltcGxpZnkpKTsKCQl9CgkJbWF0Y2ggPSAqcGF0aHNwZWMrKzsKCQlpZiAoIW1hdGNoKQoJCQlicmVhazsKCQlzaW1wbGlmeVtucl0ucGF0aCA9IG1hdGNoOwoJCXNpbXBsaWZ5W25yXS5sZW4gPSBzaW1wbGVfbGVuZ3RoKG1hdGNoKTsKCX0KCXNpbXBsaWZ5W25yXS5wYXRoID0gTlVMTDsKCXNpbXBsaWZ5W25yXS5sZW4gPSAwOwoJcmV0dXJuIHNpbXBsaWZ5Owp9CgpzdGF0aWMgdm9pZCBmcmVlX3NpbXBsaWZ5KHN0cnVjdCBwYXRoX3NpbXBsaWZ5ICpzaW1wbGlmeSkKewoJZnJlZShzaW1wbGlmeSk7Cn0KCnN0YXRpYyBpbnQgdHJlYXRfbGVhZGluZ19wYXRoKHN0cnVjdCBkaXJfc3RydWN0ICpkaXIsCgkJCSAgICAgIGNvbnN0IGNoYXIgKnBhdGgsIGludCBsZW4sCgkJCSAgICAgIGNvbnN0IHN0cnVjdCBwYXRoX3NpbXBsaWZ5ICpzaW1wbGlmeSkKewoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJaW50IGJhc2VsZW4sIHJjID0gMDsKCWNvbnN0IGNoYXIgKmNwOwoKCXdoaWxlIChsZW4gJiYgcGF0aFtsZW4gLSAxXSA9PSAnLycpCgkJbGVuLS07CglpZiAoIWxlbikKCQlyZXR1cm4gMTsKCWJhc2VsZW4gPSAwOwoJd2hpbGUgKDEpIHsKCQljcCA9IHBhdGggKyBiYXNlbGVuICsgISFiYXNlbGVuOwoJCWNwID0gbWVtY2hyKGNwLCAnLycsIHBhdGggKyBsZW4gLSBjcCk7CgkJaWYgKCFjcCkKCQkJYmFzZWxlbiA9IGxlbjsKCQllbHNlCgkJCWJhc2VsZW4gPSBjcCAtIHBhdGg7CgkJc3RyYnVmX3NldGxlbigmc2IsIDApOwoJCXN0cmJ1Zl9hZGQoJnNiLCBwYXRoLCBiYXNlbGVuKTsKCQlpZiAoIWlzX2RpcmVjdG9yeShzYi5idWYpKQoJCQlicmVhazsKCQlpZiAoc2ltcGxpZnlfYXdheShzYi5idWYsIHNiLmxlbiwgc2ltcGxpZnkpKQoJCQlicmVhazsKCQlpZiAodHJlYXRfb25lX3BhdGgoZGlyLCAmc2IsIHNpbXBsaWZ5LAoJCQkJICAgRFRfRElSLCBOVUxMKSA9PSBwYXRoX2lnbm9yZWQpCgkJCWJyZWFrOyAvKiBkbyBub3QgcmVjdXJzZSBpbnRvIGl0ICovCgkJaWYgKGxlbiA8PSBiYXNlbGVuKSB7CgkJCXJjID0gMTsKCQkJYnJlYWs7IC8qIGZpbmlzaGVkIGNoZWNraW5nICovCgkJfQoJfQoJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCXJldHVybiByYzsKfQoKaW50IHJlYWRfZGlyZWN0b3J5KHN0cnVjdCBkaXJfc3RydWN0ICpkaXIsIGNvbnN0IGNoYXIgKnBhdGgsIGludCBsZW4sIGNvbnN0IGNoYXIgKipwYXRoc3BlYykKewoJc3RydWN0IHBhdGhfc2ltcGxpZnkgKnNpbXBsaWZ5OwoKCWlmIChoYXNfc3ltbGlua19sZWFkaW5nX3BhdGgocGF0aCwgbGVuKSkKCQlyZXR1cm4gZGlyLT5ucjsKCglzaW1wbGlmeSA9IGNyZWF0ZV9zaW1wbGlmeShwYXRoc3BlYyk7CglpZiAoIWxlbiB8fCB0cmVhdF9sZWFkaW5nX3BhdGgoZGlyLCBwYXRoLCBsZW4sIHNpbXBsaWZ5KSkKCQlyZWFkX2RpcmVjdG9yeV9yZWN1cnNpdmUoZGlyLCBwYXRoLCBsZW4sIDAsIHNpbXBsaWZ5KTsKCWZyZWVfc2ltcGxpZnkoc2ltcGxpZnkpOwoJcXNvcnQoZGlyLT5lbnRyaWVzLCBkaXItPm5yLCBzaXplb2Yoc3RydWN0IGRpcl9lbnRyeSAqKSwgY21wX25hbWUpOwoJcXNvcnQoZGlyLT5pZ25vcmVkLCBkaXItPmlnbm9yZWRfbnIsIHNpemVvZihzdHJ1Y3QgZGlyX2VudHJ5ICopLCBjbXBfbmFtZSk7CglyZXR1cm4gZGlyLT5ucjsKfQoKaW50IGZpbGVfZXhpc3RzKGNvbnN0IGNoYXIgKmYpCnsKCXN0cnVjdCBzdGF0IHNiOwoJcmV0dXJuIGxzdGF0KGYsICZzYikgPT0gMDsKfQoKLyoKICogR2l2ZW4gdHdvIG5vcm1hbGl6ZWQgcGF0aHMgKGEgdHJhaWxpbmcgc2xhc2ggaXMgb2spLCBpZiBzdWJkaXIgaXMKICogb3V0c2lkZSBkaXIsIHJldHVybiAtMS4gIE90aGVyd2lzZSByZXR1cm4gdGhlIG9mZnNldCBpbiBzdWJkaXIgdGhhdAogKiBjYW4gYmUgdXNlZCBhcyByZWxhdGl2ZSBwYXRoIHRvIGRpci4KICovCmludCBkaXJfaW5zaWRlX29mKGNvbnN0IGNoYXIgKnN1YmRpciwgY29uc3QgY2hhciAqZGlyKQp7CglpbnQgb2Zmc2V0ID0gMDsKCglhc3NlcnQoZGlyICYmIHN1YmRpciAmJiAqZGlyICYmICpzdWJkaXIpOwoKCXdoaWxlICgqZGlyICYmICpzdWJkaXIgJiYgKmRpciA9PSAqc3ViZGlyKSB7CgkJZGlyKys7CgkJc3ViZGlyKys7CgkJb2Zmc2V0Kys7Cgl9CgoJLyogaGVsW3BdL21lIHZzIGhlbFtsXS95ZWFoICovCglpZiAoKmRpciAmJiAqc3ViZGlyKQoJCXJldHVybiAtMTsKCglpZiAoISpzdWJkaXIpCgkJcmV0dXJuICEqZGlyID8gb2Zmc2V0IDogLTE7IC8qIHNhbWUgZGlyICovCgoJLyogZm9vL1tiXWFyIHZzIGZvby9bXSAqLwoJaWYgKGlzX2Rpcl9zZXAoZGlyWy0xXSkpCgkJcmV0dXJuIGlzX2Rpcl9zZXAoc3ViZGlyWy0xXSkgPyBvZmZzZXQgOiAtMTsKCgkvKiBmb29bL11iYXIgdnMgZm9vW10gKi8KCXJldHVybiBpc19kaXJfc2VwKCpzdWJkaXIpID8gb2Zmc2V0ICsgMSA6IC0xOwp9CgppbnQgaXNfaW5zaWRlX2Rpcihjb25zdCBjaGFyICpkaXIpCnsKCWNoYXIgY3dkW1BBVEhfTUFYXTsKCWlmICghZGlyKQoJCXJldHVybiAwOwoJaWYgKCFnZXRjd2QoY3dkLCBzaXplb2YoY3dkKSkpCgkJZGllX2Vycm5vKCJjYW4ndCBmaW5kIHRoZSBjdXJyZW50IGRpcmVjdG9yeSIpOwoJcmV0dXJuIGRpcl9pbnNpZGVfb2YoY3dkLCBkaXIpID49IDA7Cn0KCmludCBpc19lbXB0eV9kaXIoY29uc3QgY2hhciAqcGF0aCkKewoJRElSICpkaXIgPSBvcGVuZGlyKHBhdGgpOwoJc3RydWN0IGRpcmVudCAqZTsKCWludCByZXQgPSAxOwoKCWlmICghZGlyKQoJCXJldHVybiAwOwoKCXdoaWxlICgoZSA9IHJlYWRkaXIoZGlyKSkgIT0gTlVMTCkKCQlpZiAoIWlzX2RvdF9vcl9kb3Rkb3QoZS0+ZF9uYW1lKSkgewoJCQlyZXQgPSAwOwoJCQlicmVhazsKCQl9CgoJY2xvc2VkaXIoZGlyKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQgcmVtb3ZlX2Rpcl9yZWN1cnNlKHN0cnVjdCBzdHJidWYgKnBhdGgsIGludCBmbGFnLCBpbnQgKmtlcHRfdXApCnsKCURJUiAqZGlyOwoJc3RydWN0IGRpcmVudCAqZTsKCWludCByZXQgPSAwLCBvcmlnaW5hbF9sZW4gPSBwYXRoLT5sZW4sIGxlbiwga2VwdF9kb3duID0gMDsKCWludCBvbmx5X2VtcHR5ID0gKGZsYWcgJiBSRU1PVkVfRElSX0VNUFRZX09OTFkpOwoJaW50IGtlZXBfdG9wbGV2ZWwgPSAoZmxhZyAmIFJFTU9WRV9ESVJfS0VFUF9UT1BMRVZFTCk7Cgl1bnNpZ25lZCBjaGFyIHN1Ym1vZHVsZV9oZWFkWzIwXTsKCglpZiAoKGZsYWcgJiBSRU1PVkVfRElSX0tFRVBfTkVTVEVEX0dJVCkgJiYKCSAgICAhcmVzb2x2ZV9naXRsaW5rX3JlZihwYXRoLT5idWYsICJIRUFEIiwgc3VibW9kdWxlX2hlYWQpKSB7CgkJLyogRG8gbm90IGRlc2NlbmQgYW5kIG51a2UgYSBuZXN0ZWQgZ2l0IHdvcmsgdHJlZS4gKi8KCQlpZiAoa2VwdF91cCkKCQkJKmtlcHRfdXAgPSAxOwoJCXJldHVybiAwOwoJfQoKCWZsYWcgJj0gflJFTU9WRV9ESVJfS0VFUF9UT1BMRVZFTDsKCWRpciA9IG9wZW5kaXIocGF0aC0+YnVmKTsKCWlmICghZGlyKSB7CgkJLyogYW4gZW1wdHkgZGlyIGNvdWxkIGJlIHJlbW92ZWQgZXZlbiBpZiBpdCBpcyB1bnJlYWRibGUgKi8KCQlpZiAoIWtlZXBfdG9wbGV2ZWwpCgkJCXJldHVybiBybWRpcihwYXRoLT5idWYpOwoJCWVsc2UKCQkJcmV0dXJuIC0xOwoJfQoJaWYgKHBhdGgtPmJ1ZltvcmlnaW5hbF9sZW4gLSAxXSAhPSAnLycpCgkJc3RyYnVmX2FkZGNoKHBhdGgsICcvJyk7CgoJbGVuID0gcGF0aC0+bGVuOwoJd2hpbGUgKChlID0gcmVhZGRpcihkaXIpKSAhPSBOVUxMKSB7CgkJc3RydWN0IHN0YXQgc3Q7CgkJaWYgKGlzX2RvdF9vcl9kb3Rkb3QoZS0+ZF9uYW1lKSkKCQkJY29udGludWU7CgoJCXN0cmJ1Zl9zZXRsZW4ocGF0aCwgbGVuKTsKCQlzdHJidWZfYWRkc3RyKHBhdGgsIGUtPmRfbmFtZSk7CgkJaWYgKGxzdGF0KHBhdGgtPmJ1ZiwgJnN0KSkKCQkJOyAvKiBmYWxsIHRocnUgKi8KCQllbHNlIGlmIChTX0lTRElSKHN0LnN0X21vZGUpKSB7CgkJCWlmICghcmVtb3ZlX2Rpcl9yZWN1cnNlKHBhdGgsIGZsYWcsICZrZXB0X2Rvd24pKQoJCQkJY29udGludWU7IC8qIGhhcHB5ICovCgkJfSBlbHNlIGlmICghb25seV9lbXB0eSAmJiAhdW5saW5rKHBhdGgtPmJ1ZikpCgkJCWNvbnRpbnVlOyAvKiBoYXBweSwgdG9vICovCgoJCS8qIHBhdGggdG9vIGxvbmcsIHN0YXQgZmFpbHMsIG9yIG5vbi1kaXJlY3Rvcnkgc3RpbGwgZXhpc3RzICovCgkJcmV0ID0gLTE7CgkJYnJlYWs7Cgl9CgljbG9zZWRpcihkaXIpOwoKCXN0cmJ1Zl9zZXRsZW4ocGF0aCwgb3JpZ2luYWxfbGVuKTsKCWlmICghcmV0ICYmICFrZWVwX3RvcGxldmVsICYmICFrZXB0X2Rvd24pCgkJcmV0ID0gcm1kaXIocGF0aC0+YnVmKTsKCWVsc2UgaWYgKGtlcHRfdXApCgkJLyoKCQkgKiByZXBvcnQgdGhlIHVwbGV2ZWwgdGhhdCBpdCBpcyBub3QgYW4gZXJyb3IgdGhhdCB3ZQoJCSAqIGRpZCBub3Qgcm1kaXIoKSBvdXIgZGlyZWN0b3J5LgoJCSAqLwoJCSprZXB0X3VwID0gIXJldDsKCXJldHVybiByZXQ7Cn0KCmludCByZW1vdmVfZGlyX3JlY3Vyc2l2ZWx5KHN0cnVjdCBzdHJidWYgKnBhdGgsIGludCBmbGFnKQp7CglyZXR1cm4gcmVtb3ZlX2Rpcl9yZWN1cnNlKHBhdGgsIGZsYWcsIE5VTEwpOwp9Cgp2b2lkIHNldHVwX3N0YW5kYXJkX2V4Y2x1ZGVzKHN0cnVjdCBkaXJfc3RydWN0ICpkaXIpCnsKCWNvbnN0IGNoYXIgKnBhdGg7CgoJZGlyLT5leGNsdWRlX3Blcl9kaXIgPSAiLmdpdGlnbm9yZSI7CglwYXRoID0gZ2l0X3BhdGgoImluZm8vZXhjbHVkZSIpOwoJaWYgKCFhY2Nlc3MocGF0aCwgUl9PSykpCgkJYWRkX2V4Y2x1ZGVzX2Zyb21fZmlsZShkaXIsIHBhdGgpOwoJaWYgKGV4Y2x1ZGVzX2ZpbGUgJiYgIWFjY2VzcyhleGNsdWRlc19maWxlLCBSX09LKSkKCQlhZGRfZXhjbHVkZXNfZnJvbV9maWxlKGRpciwgZXhjbHVkZXNfZmlsZSk7Cn0KCmludCByZW1vdmVfcGF0aChjb25zdCBjaGFyICpuYW1lKQp7CgljaGFyICpzbGFzaDsKCglpZiAodW5saW5rKG5hbWUpICYmIGVycm5vICE9IEVOT0VOVCkKCQlyZXR1cm4gLTE7CgoJc2xhc2ggPSBzdHJyY2hyKG5hbWUsICcvJyk7CglpZiAoc2xhc2gpIHsKCQljaGFyICpkaXJzID0geHN0cmR1cChuYW1lKTsKCQlzbGFzaCA9IGRpcnMgKyAoc2xhc2ggLSBuYW1lKTsKCQlkbyB7CgkJCSpzbGFzaCA9ICdcMCc7CgkJfSB3aGlsZSAocm1kaXIoZGlycykgPT0gMCAmJiAoc2xhc2ggPSBzdHJyY2hyKGRpcnMsICcvJykpKTsKCQlmcmVlKGRpcnMpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgcGF0aHNwZWNfaXRlbV9jbXAoY29uc3Qgdm9pZCAqYV8sIGNvbnN0IHZvaWQgKmJfKQp7CglzdHJ1Y3QgcGF0aHNwZWNfaXRlbSAqYSwgKmI7CgoJYSA9IChzdHJ1Y3QgcGF0aHNwZWNfaXRlbSAqKWFfOwoJYiA9IChzdHJ1Y3QgcGF0aHNwZWNfaXRlbSAqKWJfOwoJcmV0dXJuIHN0cmNtcChhLT5tYXRjaCwgYi0+bWF0Y2gpOwp9CgppbnQgaW5pdF9wYXRoc3BlYyhzdHJ1Y3QgcGF0aHNwZWMgKnBhdGhzcGVjLCBjb25zdCBjaGFyICoqcGF0aHMpCnsKCWNvbnN0IGNoYXIgKipwID0gcGF0aHM7CglpbnQgaTsKCgltZW1zZXQocGF0aHNwZWMsIDAsIHNpemVvZigqcGF0aHNwZWMpKTsKCWlmICghcCkKCQlyZXR1cm4gMDsKCXdoaWxlICgqcCkKCQlwKys7CglwYXRoc3BlYy0+cmF3ID0gcGF0aHM7CglwYXRoc3BlYy0+bnIgPSBwIC0gcGF0aHM7CglpZiAoIXBhdGhzcGVjLT5ucikKCQlyZXR1cm4gMDsKCglwYXRoc3BlYy0+aXRlbXMgPSB4bWFsbG9jKHNpemVvZihzdHJ1Y3QgcGF0aHNwZWNfaXRlbSkqcGF0aHNwZWMtPm5yKTsKCWZvciAoaSA9IDA7IGkgPCBwYXRoc3BlYy0+bnI7IGkrKykgewoJCXN0cnVjdCBwYXRoc3BlY19pdGVtICppdGVtID0gcGF0aHNwZWMtPml0ZW1zK2k7CgkJY29uc3QgY2hhciAqcGF0aCA9IHBhdGhzW2ldOwoKCQlpdGVtLT5tYXRjaCA9IHBhdGg7CgkJaXRlbS0+bGVuID0gc3RybGVuKHBhdGgpOwoJCWl0ZW0tPnVzZV93aWxkY2FyZCA9ICFub193aWxkY2FyZChwYXRoKTsKCQlpZiAoaXRlbS0+dXNlX3dpbGRjYXJkKQoJCQlwYXRoc3BlYy0+aGFzX3dpbGRjYXJkID0gMTsKCX0KCglxc29ydChwYXRoc3BlYy0+aXRlbXMsIHBhdGhzcGVjLT5uciwKCSAgICAgIHNpemVvZihzdHJ1Y3QgcGF0aHNwZWNfaXRlbSksIHBhdGhzcGVjX2l0ZW1fY21wKTsKCglyZXR1cm4gMDsKfQoKdm9pZCBmcmVlX3BhdGhzcGVjKHN0cnVjdCBwYXRoc3BlYyAqcGF0aHNwZWMpCnsKCWZyZWUocGF0aHNwZWMtPml0ZW1zKTsKCXBhdGhzcGVjLT5pdGVtcyA9IE5VTEw7Cn0K",
    "text": "/*\n * This handles recursive filename detection with exclude\n * files, index knowledge etc..\n *\n * Copyright (C) Linus Torvalds, 2005-2006\n *\t\t Junio Hamano, 2005-2006\n */\n#include \"cache.h\"\n#include \"dir.h\"\n#include \"refs.h\"\n\nstruct path_simplify {\n\tint len;\n\tconst char *path;\n};\n\nstatic int read_directory_recursive(struct dir_struct *dir, const char *path, int len,\n\tint check_only, const struct path_simplify *simplify);\nstatic int get_dtype(struct dirent *de, const char *path, int len);\n\n/* helper string functions with support for the ignore_case flag */\nint strcmp_icase(const char *a, const char *b)\n{\n\treturn ignore_case ? strcasecmp(a, b) : strcmp(a, b);\n}\n\nint strncmp_icase(const char *a, const char *b, size_t count)\n{\n\treturn ignore_case ? strncasecmp(a, b, count) : strncmp(a, b, count);\n}\n\nint fnmatch_icase(const char *pattern, const char *string, int flags)\n{\n\treturn fnmatch(pattern, string, flags | (ignore_case ? FNM_CASEFOLD : 0));\n}\n\nstatic size_t common_prefix_len(const char **pathspec)\n{\n\tconst char *n, *first;\n\tsize_t max = 0;\n\n\tif (!pathspec)\n\t\treturn max;\n\n\tfirst = *pathspec;\n\twhile ((n = *pathspec++)) {\n\t\tsize_t i, len = 0;\n\t\tfor (i = 0; first == n || i < max; i++) {\n\t\t\tchar c = n[i];\n\t\t\tif (!c || c != first[i] || is_glob_special(c))\n\t\t\t\tbreak;\n\t\t\tif (c == '/')\n\t\t\t\tlen = i + 1;\n\t\t}\n\t\tif (first == n || len < max) {\n\t\t\tmax = len;\n\t\t\tif (!max)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn max;\n}\n\n/*\n * Returns a copy of the longest leading path common among all\n * pathspecs.\n */\nchar *common_prefix(const char **pathspec)\n{\n\tunsigned long len = common_prefix_len(pathspec);\n\n\treturn len ? xmemdupz(*pathspec, len) : NULL;\n}\n\nint fill_directory(struct dir_struct *dir, const char **pathspec)\n{\n\tsize_t len;\n\n\t/*\n\t * Calculate common prefix for the pathspec, and\n\t * use that to optimize the directory walk\n\t */\n\tlen = common_prefix_len(pathspec);\n\n\t/* Read the directory and prune it */\n\tread_directory(dir, pathspec ? *pathspec : \"\", len, pathspec);\n\treturn len;\n}\n\nint within_depth(const char *name, int namelen,\n\t\t\tint depth, int max_depth)\n{\n\tconst char *cp = name, *cpe = name + namelen;\n\n\twhile (cp < cpe) {\n\t\tif (*cp++ != '/')\n\t\t\tcontinue;\n\t\tdepth++;\n\t\tif (depth > max_depth)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/*\n * Does 'match' match the given name?\n * A match is found if\n *\n * (1) the 'match' string is leading directory of 'name', or\n * (2) the 'match' string is a wildcard and matches 'name', or\n * (3) the 'match' string is exactly the same as 'name'.\n *\n * and the return value tells which case it was.\n *\n * It returns 0 when there is no match.\n */\nstatic int match_one(const char *match, const char *name, int namelen)\n{\n\tint matchlen;\n\n\t/* If the match was just the prefix, we matched */\n\tif (!*match)\n\t\treturn MATCHED_RECURSIVELY;\n\n\tif (ignore_case) {\n\t\tfor (;;) {\n\t\t\tunsigned char c1 = tolower(*match);\n\t\t\tunsigned char c2 = tolower(*name);\n\t\t\tif (c1 == '\\0' || is_glob_special(c1))\n\t\t\t\tbreak;\n\t\t\tif (c1 != c2)\n\t\t\t\treturn 0;\n\t\t\tmatch++;\n\t\t\tname++;\n\t\t\tnamelen--;\n\t\t}\n\t} else {\n\t\tfor (;;) {\n\t\t\tunsigned char c1 = *match;\n\t\t\tunsigned char c2 = *name;\n\t\t\tif (c1 == '\\0' || is_glob_special(c1))\n\t\t\t\tbreak;\n\t\t\tif (c1 != c2)\n\t\t\t\treturn 0;\n\t\t\tmatch++;\n\t\t\tname++;\n\t\t\tnamelen--;\n\t\t}\n\t}\n\n\n\t/*\n\t * If we don't match the matchstring exactly,\n\t * we need to match by fnmatch\n\t */\n\tmatchlen = strlen(match);\n\tif (strncmp_icase(match, name, matchlen))\n\t\treturn !fnmatch_icase(match, name, 0) ? MATCHED_FNMATCH : 0;\n\n\tif (namelen == matchlen)\n\t\treturn MATCHED_EXACTLY;\n\tif (match[matchlen-1] == '/' || name[matchlen] == '/')\n\t\treturn MATCHED_RECURSIVELY;\n\treturn 0;\n}\n\n/*\n * Given a name and a list of pathspecs, see if the name matches\n * any of the pathspecs.  The caller is also interested in seeing\n * all pathspec matches some names it calls this function with\n * (otherwise the user could have mistyped the unmatched pathspec),\n * and a mark is left in seen[] array for pathspec element that\n * actually matched anything.\n */\nint match_pathspec(const char **pathspec, const char *name, int namelen,\n\t\tint prefix, char *seen)\n{\n\tint i, retval = 0;\n\n\tif (!pathspec)\n\t\treturn 1;\n\n\tname += prefix;\n\tnamelen -= prefix;\n\n\tfor (i = 0; pathspec[i] != NULL; i++) {\n\t\tint how;\n\t\tconst char *match = pathspec[i] + prefix;\n\t\tif (seen && seen[i] == MATCHED_EXACTLY)\n\t\t\tcontinue;\n\t\thow = match_one(match, name, namelen);\n\t\tif (how) {\n\t\t\tif (retval < how)\n\t\t\t\tretval = how;\n\t\t\tif (seen && seen[i] < how)\n\t\t\t\tseen[i] = how;\n\t\t}\n\t}\n\treturn retval;\n}\n\n/*\n * Does 'match' match the given name?\n * A match is found if\n *\n * (1) the 'match' string is leading directory of 'name', or\n * (2) the 'match' string is a wildcard and matches 'name', or\n * (3) the 'match' string is exactly the same as 'name'.\n *\n * and the return value tells which case it was.\n *\n * It returns 0 when there is no match.\n */\nstatic int match_pathspec_item(const struct pathspec_item *item, int prefix,\n\t\t\t       const char *name, int namelen)\n{\n\t/* name/namelen has prefix cut off by caller */\n\tconst char *match = item->match + prefix;\n\tint matchlen = item->len - prefix;\n\n\t/* If the match was just the prefix, we matched */\n\tif (!*match)\n\t\treturn MATCHED_RECURSIVELY;\n\n\tif (matchlen <= namelen && !strncmp(match, name, matchlen)) {\n\t\tif (matchlen == namelen)\n\t\t\treturn MATCHED_EXACTLY;\n\n\t\tif (match[matchlen-1] == '/' || name[matchlen] == '/')\n\t\t\treturn MATCHED_RECURSIVELY;\n\t}\n\n\tif (item->use_wildcard && !fnmatch(match, name, 0))\n\t\treturn MATCHED_FNMATCH;\n\n\treturn 0;\n}\n\n/*\n * Given a name and a list of pathspecs, see if the name matches\n * any of the pathspecs.  The caller is also interested in seeing\n * all pathspec matches some names it calls this function with\n * (otherwise the user could have mistyped the unmatched pathspec),\n * and a mark is left in seen[] array for pathspec element that\n * actually matched anything.\n */\nint match_pathspec_depth(const struct pathspec *ps,\n\t\t\t const char *name, int namelen,\n\t\t\t int prefix, char *seen)\n{\n\tint i, retval = 0;\n\n\tif (!ps->nr) {\n\t\tif (!ps->recursive || ps->max_depth == -1)\n\t\t\treturn MATCHED_RECURSIVELY;\n\n\t\tif (within_depth(name, namelen, 0, ps->max_depth))\n\t\t\treturn MATCHED_EXACTLY;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tname += prefix;\n\tnamelen -= prefix;\n\n\tfor (i = ps->nr - 1; i >= 0; i--) {\n\t\tint how;\n\t\tif (seen && seen[i] == MATCHED_EXACTLY)\n\t\t\tcontinue;\n\t\thow = match_pathspec_item(ps->items+i, prefix, name, namelen);\n\t\tif (ps->recursive && ps->max_depth != -1 &&\n\t\t    how && how != MATCHED_FNMATCH) {\n\t\t\tint len = ps->items[i].len;\n\t\t\tif (name[len] == '/')\n\t\t\t\tlen++;\n\t\t\tif (within_depth(name+len, namelen-len, 0, ps->max_depth))\n\t\t\t\thow = MATCHED_EXACTLY;\n\t\t\telse\n\t\t\t\thow = 0;\n\t\t}\n\t\tif (how) {\n\t\t\tif (retval < how)\n\t\t\t\tretval = how;\n\t\t\tif (seen && seen[i] < how)\n\t\t\t\tseen[i] = how;\n\t\t}\n\t}\n\treturn retval;\n}\n\n/*\n * Return the length of the \"simple\" part of a path match limiter.\n */\nstatic int simple_length(const char *match)\n{\n\tint len = -1;\n\n\tfor (;;) {\n\t\tunsigned char c = *match++;\n\t\tlen++;\n\t\tif (c == '\\0' || is_glob_special(c))\n\t\t\treturn len;\n\t}\n}\n\nstatic int no_wildcard(const char *string)\n{\n\treturn string[simple_length(string)] == '\\0';\n}\n\nvoid add_exclude(const char *string, const char *base,\n\t\t int baselen, struct exclude_list *which)\n{\n\tstruct exclude *x;\n\tsize_t len;\n\tint to_exclude = 1;\n\tint flags = 0;\n\n\tif (*string == '!') {\n\t\tto_exclude = 0;\n\t\tstring++;\n\t}\n\tlen = strlen(string);\n\tif (len && string[len - 1] == '/') {\n\t\tchar *s;\n\t\tx = xmalloc(sizeof(*x) + len);\n\t\ts = (char *)(x+1);\n\t\tmemcpy(s, string, len - 1);\n\t\ts[len - 1] = '\\0';\n\t\tstring = s;\n\t\tx->pattern = s;\n\t\tflags = EXC_FLAG_MUSTBEDIR;\n\t} else {\n\t\tx = xmalloc(sizeof(*x));\n\t\tx->pattern = string;\n\t}\n\tx->to_exclude = to_exclude;\n\tx->patternlen = strlen(string);\n\tx->base = base;\n\tx->baselen = baselen;\n\tx->flags = flags;\n\tif (!strchr(string, '/'))\n\t\tx->flags |= EXC_FLAG_NODIR;\n\tx->nowildcardlen = simple_length(string);\n\tif (*string == '*' && no_wildcard(string+1))\n\t\tx->flags |= EXC_FLAG_ENDSWITH;\n\tALLOC_GROW(which->excludes, which->nr + 1, which->alloc);\n\twhich->excludes[which->nr++] = x;\n}\n\nstatic void *read_skip_worktree_file_from_index(const char *path, size_t *size)\n{\n\tint pos, len;\n\tunsigned long sz;\n\tenum object_type type;\n\tvoid *data;\n\tstruct index_state *istate = &the_index;\n\n\tlen = strlen(path);\n\tpos = index_name_pos(istate, path, len);\n\tif (pos < 0)\n\t\treturn NULL;\n\tif (!ce_skip_worktree(istate->cache[pos]))\n\t\treturn NULL;\n\tdata = read_sha1_file(istate->cache[pos]->sha1, &type, &sz);\n\tif (!data || type != OBJ_BLOB) {\n\t\tfree(data);\n\t\treturn NULL;\n\t}\n\t*size = xsize_t(sz);\n\treturn data;\n}\n\nvoid free_excludes(struct exclude_list *el)\n{\n\tint i;\n\n\tfor (i = 0; i < el->nr; i++)\n\t\tfree(el->excludes[i]);\n\tfree(el->excludes);\n\n\tel->nr = 0;\n\tel->excludes = NULL;\n}\n\nint add_excludes_from_file_to_list(const char *fname,\n\t\t\t\t   const char *base,\n\t\t\t\t   int baselen,\n\t\t\t\t   char **buf_p,\n\t\t\t\t   struct exclude_list *which,\n\t\t\t\t   int check_index)\n{\n\tstruct stat st;\n\tint fd, i;\n\tsize_t size = 0;\n\tchar *buf, *entry;\n\n\tfd = open(fname, O_RDONLY);\n\tif (fd < 0 || fstat(fd, &st) < 0) {\n\t\tif (0 <= fd)\n\t\t\tclose(fd);\n\t\tif (!check_index ||\n\t\t    (buf = read_skip_worktree_file_from_index(fname, &size)) == NULL)\n\t\t\treturn -1;\n\t\tif (size == 0) {\n\t\t\tfree(buf);\n\t\t\treturn 0;\n\t\t}\n\t\tif (buf[size-1] != '\\n') {\n\t\t\tbuf = xrealloc(buf, size+1);\n\t\t\tbuf[size++] = '\\n';\n\t\t}\n\t}\n\telse {\n\t\tsize = xsize_t(st.st_size);\n\t\tif (size == 0) {\n\t\t\tclose(fd);\n\t\t\treturn 0;\n\t\t}\n\t\tbuf = xmalloc(size+1);\n\t\tif (read_in_full(fd, buf, size) != size) {\n\t\t\tfree(buf);\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\t\tbuf[size++] = '\\n';\n\t\tclose(fd);\n\t}\n\n\tif (buf_p)\n\t\t*buf_p = buf;\n\tentry = buf;\n\tfor (i = 0; i < size; i++) {\n\t\tif (buf[i] == '\\n') {\n\t\t\tif (entry != buf + i && entry[0] != '#') {\n\t\t\t\tbuf[i - (i && buf[i-1] == '\\r')] = 0;\n\t\t\t\tadd_exclude(entry, base, baselen, which);\n\t\t\t}\n\t\t\tentry = buf + i + 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid add_excludes_from_file(struct dir_struct *dir, const char *fname)\n{\n\tif (add_excludes_from_file_to_list(fname, \"\", 0, NULL,\n\t\t\t\t\t   &dir->exclude_list[EXC_FILE], 0) < 0)\n\t\tdie(\"cannot use %s as an exclude file\", fname);\n}\n\nstatic void prep_exclude(struct dir_struct *dir, const char *base, int baselen)\n{\n\tstruct exclude_list *el;\n\tstruct exclude_stack *stk = NULL;\n\tint current;\n\n\tif ((!dir->exclude_per_dir) ||\n\t    (baselen + strlen(dir->exclude_per_dir) >= PATH_MAX))\n\t\treturn; /* too long a path -- ignore */\n\n\t/* Pop the ones that are not the prefix of the path being checked. */\n\tel = &dir->exclude_list[EXC_DIRS];\n\twhile ((stk = dir->exclude_stack) != NULL) {\n\t\tif (stk->baselen <= baselen &&\n\t\t    !strncmp(dir->basebuf, base, stk->baselen))\n\t\t\tbreak;\n\t\tdir->exclude_stack = stk->prev;\n\t\twhile (stk->exclude_ix < el->nr)\n\t\t\tfree(el->excludes[--el->nr]);\n\t\tfree(stk->filebuf);\n\t\tfree(stk);\n\t}\n\n\t/* Read from the parent directories and push them down. */\n\tcurrent = stk ? stk->baselen : -1;\n\twhile (current < baselen) {\n\t\tstruct exclude_stack *stk = xcalloc(1, sizeof(*stk));\n\t\tconst char *cp;\n\n\t\tif (current < 0) {\n\t\t\tcp = base;\n\t\t\tcurrent = 0;\n\t\t}\n\t\telse {\n\t\t\tcp = strchr(base + current + 1, '/');\n\t\t\tif (!cp)\n\t\t\t\tdie(\"oops in prep_exclude\");\n\t\t\tcp++;\n\t\t}\n\t\tstk->prev = dir->exclude_stack;\n\t\tstk->baselen = cp - base;\n\t\tstk->exclude_ix = el->nr;\n\t\tmemcpy(dir->basebuf + current, base + current,\n\t\t       stk->baselen - current);\n\t\tstrcpy(dir->basebuf + stk->baselen, dir->exclude_per_dir);\n\t\tadd_excludes_from_file_to_list(dir->basebuf,\n\t\t\t\t\t       dir->basebuf, stk->baselen,\n\t\t\t\t\t       &stk->filebuf, el, 1);\n\t\tdir->exclude_stack = stk;\n\t\tcurrent = stk->baselen;\n\t}\n\tdir->basebuf[baselen] = '\\0';\n}\n\n/* Scan the list and let the last match determine the fate.\n * Return 1 for exclude, 0 for include and -1 for undecided.\n */\nint excluded_from_list(const char *pathname,\n\t\t       int pathlen, const char *basename, int *dtype,\n\t\t       struct exclude_list *el)\n{\n\tint i;\n\n\tif (!el->nr)\n\t\treturn -1;\t/* undefined */\n\n\tfor (i = el->nr - 1; 0 <= i; i--) {\n\t\tstruct exclude *x = el->excludes[i];\n\t\tconst char *name, *exclude = x->pattern;\n\t\tint to_exclude = x->to_exclude;\n\t\tint namelen, prefix = x->nowildcardlen;\n\n\t\tif (x->flags & EXC_FLAG_MUSTBEDIR) {\n\t\t\tif (*dtype == DT_UNKNOWN)\n\t\t\t\t*dtype = get_dtype(NULL, pathname, pathlen);\n\t\t\tif (*dtype != DT_DIR)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (x->flags & EXC_FLAG_NODIR) {\n\t\t\t/* match basename */\n\t\t\tif (prefix == x->patternlen) {\n\t\t\t\tif (!strcmp_icase(exclude, basename))\n\t\t\t\t\treturn to_exclude;\n\t\t\t} else if (x->flags & EXC_FLAG_ENDSWITH) {\n\t\t\t\tif (x->patternlen - 1 <= pathlen &&\n\t\t\t\t    !strcmp_icase(exclude + 1, pathname + pathlen - x->patternlen + 1))\n\t\t\t\t\treturn to_exclude;\n\t\t\t} else {\n\t\t\t\tif (fnmatch_icase(exclude, basename, 0) == 0)\n\t\t\t\t\treturn to_exclude;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* match with FNM_PATHNAME:\n\t\t * exclude has base (baselen long) implicitly in front of it.\n\t\t */\n\t\tif (*exclude == '/') {\n\t\t\texclude++;\n\t\t\tprefix--;\n\t\t}\n\n\t\tif (pathlen < x->baselen ||\n\t\t    (x->baselen && pathname[x->baselen-1] != '/') ||\n\t\t    strncmp_icase(pathname, x->base, x->baselen))\n\t\t\tcontinue;\n\n\t\tnamelen = x->baselen ? pathlen - x->baselen : pathlen;\n\t\tname = pathname + pathlen  - namelen;\n\n\t\t/* if the non-wildcard part is longer than the\n\t\t   remaining pathname, surely it cannot match */\n\t\tif (prefix > namelen)\n\t\t\tcontinue;\n\n\t\tif (prefix) {\n\t\t\tif (strncmp_icase(exclude, name, prefix))\n\t\t\t\tcontinue;\n\t\t\texclude += prefix;\n\t\t\tname    += prefix;\n\t\t\tnamelen -= prefix;\n\t\t}\n\n\t\tif (!namelen || !fnmatch_icase(exclude, name, FNM_PATHNAME))\n\t\t\treturn to_exclude;\n\t}\n\treturn -1; /* undecided */\n}\n\nstatic int excluded(struct dir_struct *dir, const char *pathname, int *dtype_p)\n{\n\tint pathlen = strlen(pathname);\n\tint st;\n\tconst char *basename = strrchr(pathname, '/');\n\tbasename = (basename) ? basename+1 : pathname;\n\n\tprep_exclude(dir, pathname, basename-pathname);\n\tfor (st = EXC_CMDL; st <= EXC_FILE; st++) {\n\t\tswitch (excluded_from_list(pathname, pathlen, basename,\n\t\t\t\t\t   dtype_p, &dir->exclude_list[st])) {\n\t\tcase 0:\n\t\t\treturn 0;\n\t\tcase 1:\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid path_exclude_check_init(struct path_exclude_check *check,\n\t\t\t     struct dir_struct *dir)\n{\n\tcheck->dir = dir;\n\tstrbuf_init(&check->path, 256);\n}\n\nvoid path_exclude_check_clear(struct path_exclude_check *check)\n{\n\tstrbuf_release(&check->path);\n}\n\n/*\n * Is this name excluded?  This is for a caller like show_files() that\n * do not honor directory hierarchy and iterate through paths that are\n * possibly in an ignored directory.\n *\n * A path to a directory known to be excluded is left in check->path to\n * optimize for repeated checks for files in the same excluded directory.\n */\nint path_excluded(struct path_exclude_check *check,\n\t\t  const char *name, int namelen, int *dtype)\n{\n\tint i;\n\tstruct strbuf *path = &check->path;\n\n\t/*\n\t * we allow the caller to pass namelen as an optimization; it\n\t * must match the length of the name, as we eventually call\n\t * excluded() on the whole name string.\n\t */\n\tif (namelen < 0)\n\t\tnamelen = strlen(name);\n\n\tif (path->len &&\n\t    path->len <= namelen &&\n\t    !memcmp(name, path->buf, path->len) &&\n\t    (!name[path->len] || name[path->len] == '/'))\n\t\treturn 1;\n\n\tstrbuf_setlen(path, 0);\n\tfor (i = 0; name[i]; i++) {\n\t\tint ch = name[i];\n\n\t\tif (ch == '/') {\n\t\t\tint dt = DT_DIR;\n\t\t\tif (excluded(check->dir, path->buf, &dt))\n\t\t\t\treturn 1;\n\t\t}\n\t\tstrbuf_addch(path, ch);\n\t}\n\n\t/* An entry in the index; cannot be a directory with subentries */\n\tstrbuf_setlen(path, 0);\n\n\treturn excluded(check->dir, name, dtype);\n}\n\nstatic struct dir_entry *dir_entry_new(const char *pathname, int len)\n{\n\tstruct dir_entry *ent;\n\n\tent = xmalloc(sizeof(*ent) + len + 1);\n\tent->len = len;\n\tmemcpy(ent->name, pathname, len);\n\tent->name[len] = 0;\n\treturn ent;\n}\n\nstatic struct dir_entry *dir_add_name(struct dir_struct *dir, const char *pathname, int len)\n{\n\tif (cache_name_exists(pathname, len, ignore_case))\n\t\treturn NULL;\n\n\tALLOC_GROW(dir->entries, dir->nr+1, dir->alloc);\n\treturn dir->entries[dir->nr++] = dir_entry_new(pathname, len);\n}\n\nstruct dir_entry *dir_add_ignored(struct dir_struct *dir, const char *pathname, int len)\n{\n\tif (!cache_name_is_other(pathname, len))\n\t\treturn NULL;\n\n\tALLOC_GROW(dir->ignored, dir->ignored_nr+1, dir->ignored_alloc);\n\treturn dir->ignored[dir->ignored_nr++] = dir_entry_new(pathname, len);\n}\n\nenum exist_status {\n\tindex_nonexistent = 0,\n\tindex_directory,\n\tindex_gitdir\n};\n\n/*\n * Do not use the alphabetically stored index to look up\n * the directory name; instead, use the case insensitive\n * name hash.\n */\nstatic enum exist_status directory_exists_in_index_icase(const char *dirname, int len)\n{\n\tstruct cache_entry *ce = index_name_exists(&the_index, dirname, len + 1, ignore_case);\n\tunsigned char endchar;\n\n\tif (!ce)\n\t\treturn index_nonexistent;\n\tendchar = ce->name[len];\n\n\t/*\n\t * The cache_entry structure returned will contain this dirname\n\t * and possibly additional path components.\n\t */\n\tif (endchar == '/')\n\t\treturn index_directory;\n\n\t/*\n\t * If there are no additional path components, then this cache_entry\n\t * represents a submodule.  Submodules, despite being directories,\n\t * are stored in the cache without a closing slash.\n\t */\n\tif (!endchar && S_ISGITLINK(ce->ce_mode))\n\t\treturn index_gitdir;\n\n\t/* This should never be hit, but it exists just in case. */\n\treturn index_nonexistent;\n}\n\n/*\n * The index sorts alphabetically by entry name, which\n * means that a gitlink sorts as '\\0' at the end, while\n * a directory (which is defined not as an entry, but as\n * the files it contains) will sort with the '/' at the\n * end.\n */\nstatic enum exist_status directory_exists_in_index(const char *dirname, int len)\n{\n\tint pos;\n\n\tif (ignore_case)\n\t\treturn directory_exists_in_index_icase(dirname, len);\n\n\tpos = cache_name_pos(dirname, len);\n\tif (pos < 0)\n\t\tpos = -pos-1;\n\twhile (pos < active_nr) {\n\t\tstruct cache_entry *ce = active_cache[pos++];\n\t\tunsigned char endchar;\n\n\t\tif (strncmp(ce->name, dirname, len))\n\t\t\tbreak;\n\t\tendchar = ce->name[len];\n\t\tif (endchar > '/')\n\t\t\tbreak;\n\t\tif (endchar == '/')\n\t\t\treturn index_directory;\n\t\tif (!endchar && S_ISGITLINK(ce->ce_mode))\n\t\t\treturn index_gitdir;\n\t}\n\treturn index_nonexistent;\n}\n\n/*\n * When we find a directory when traversing the filesystem, we\n * have three distinct cases:\n *\n *  - ignore it\n *  - see it as a directory\n *  - recurse into it\n *\n * and which one we choose depends on a combination of existing\n * git index contents and the flags passed into the directory\n * traversal routine.\n *\n * Case 1: If we *already* have entries in the index under that\n * directory name, we always recurse into the directory to see\n * all the files.\n *\n * Case 2: If we *already* have that directory name as a gitlink,\n * we always continue to see it as a gitlink, regardless of whether\n * there is an actual git directory there or not (it might not\n * be checked out as a subproject!)\n *\n * Case 3: if we didn't have it in the index previously, we\n * have a few sub-cases:\n *\n *  (a) if \"show_other_directories\" is true, we show it as\n *      just a directory, unless \"hide_empty_directories\" is\n *      also true and the directory is empty, in which case\n *      we just ignore it entirely.\n *  (b) if it looks like a git directory, and we don't have\n *      'no_gitlinks' set we treat it as a gitlink, and show it\n *      as a directory.\n *  (c) otherwise, we recurse into it.\n */\nenum directory_treatment {\n\tshow_directory,\n\tignore_directory,\n\trecurse_into_directory\n};\n\nstatic enum directory_treatment treat_directory(struct dir_struct *dir,\n\tconst char *dirname, int len,\n\tconst struct path_simplify *simplify)\n{\n\t/* The \"len-1\" is to strip the final '/' */\n\tswitch (directory_exists_in_index(dirname, len-1)) {\n\tcase index_directory:\n\t\treturn recurse_into_directory;\n\n\tcase index_gitdir:\n\t\tif (dir->flags & DIR_SHOW_OTHER_DIRECTORIES)\n\t\t\treturn ignore_directory;\n\t\treturn show_directory;\n\n\tcase index_nonexistent:\n\t\tif (dir->flags & DIR_SHOW_OTHER_DIRECTORIES)\n\t\t\tbreak;\n\t\tif (!(dir->flags & DIR_NO_GITLINKS)) {\n\t\t\tunsigned char sha1[20];\n\t\t\tif (resolve_gitlink_ref(dirname, \"HEAD\", sha1) == 0)\n\t\t\t\treturn show_directory;\n\t\t}\n\t\treturn recurse_into_directory;\n\t}\n\n\t/* This is the \"show_other_directories\" case */\n\tif (!(dir->flags & DIR_HIDE_EMPTY_DIRECTORIES))\n\t\treturn show_directory;\n\tif (!read_directory_recursive(dir, dirname, len, 1, simplify))\n\t\treturn ignore_directory;\n\treturn show_directory;\n}\n\n/*\n * This is an inexact early pruning of any recursive directory\n * reading - if the path cannot possibly be in the pathspec,\n * return true, and we'll skip it early.\n */\nstatic int simplify_away(const char *path, int pathlen, const struct path_simplify *simplify)\n{\n\tif (simplify) {\n\t\tfor (;;) {\n\t\t\tconst char *match = simplify->path;\n\t\t\tint len = simplify->len;\n\n\t\t\tif (!match)\n\t\t\t\tbreak;\n\t\t\tif (len > pathlen)\n\t\t\t\tlen = pathlen;\n\t\t\tif (!memcmp(path, match, len))\n\t\t\t\treturn 0;\n\t\t\tsimplify++;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * This function tells us whether an excluded path matches a\n * list of \"interesting\" pathspecs. That is, whether a path matched\n * by any of the pathspecs could possibly be ignored by excluding\n * the specified path. This can happen if:\n *\n *   1. the path is mentioned explicitly in the pathspec\n *\n *   2. the path is a directory prefix of some element in the\n *      pathspec\n */\nstatic int exclude_matches_pathspec(const char *path, int len,\n\t\tconst struct path_simplify *simplify)\n{\n\tif (simplify) {\n\t\tfor (; simplify->path; simplify++) {\n\t\t\tif (len == simplify->len\n\t\t\t    && !memcmp(path, simplify->path, len))\n\t\t\t\treturn 1;\n\t\t\tif (len < simplify->len\n\t\t\t    && simplify->path[len] == '/'\n\t\t\t    && !memcmp(path, simplify->path, len))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int get_index_dtype(const char *path, int len)\n{\n\tint pos;\n\tstruct cache_entry *ce;\n\n\tce = cache_name_exists(path, len, 0);\n\tif (ce) {\n\t\tif (!ce_uptodate(ce))\n\t\t\treturn DT_UNKNOWN;\n\t\tif (S_ISGITLINK(ce->ce_mode))\n\t\t\treturn DT_DIR;\n\t\t/*\n\t\t * Nobody actually cares about the\n\t\t * difference between DT_LNK and DT_REG\n\t\t */\n\t\treturn DT_REG;\n\t}\n\n\t/* Try to look it up as a directory */\n\tpos = cache_name_pos(path, len);\n\tif (pos >= 0)\n\t\treturn DT_UNKNOWN;\n\tpos = -pos-1;\n\twhile (pos < active_nr) {\n\t\tce = active_cache[pos++];\n\t\tif (strncmp(ce->name, path, len))\n\t\t\tbreak;\n\t\tif (ce->name[len] > '/')\n\t\t\tbreak;\n\t\tif (ce->name[len] < '/')\n\t\t\tcontinue;\n\t\tif (!ce_uptodate(ce))\n\t\t\tbreak;\t/* continue? */\n\t\treturn DT_DIR;\n\t}\n\treturn DT_UNKNOWN;\n}\n\nstatic int get_dtype(struct dirent *de, const char *path, int len)\n{\n\tint dtype = de ? DTYPE(de) : DT_UNKNOWN;\n\tstruct stat st;\n\n\tif (dtype != DT_UNKNOWN)\n\t\treturn dtype;\n\tdtype = get_index_dtype(path, len);\n\tif (dtype != DT_UNKNOWN)\n\t\treturn dtype;\n\tif (lstat(path, &st))\n\t\treturn dtype;\n\tif (S_ISREG(st.st_mode))\n\t\treturn DT_REG;\n\tif (S_ISDIR(st.st_mode))\n\t\treturn DT_DIR;\n\tif (S_ISLNK(st.st_mode))\n\t\treturn DT_LNK;\n\treturn dtype;\n}\n\nenum path_treatment {\n\tpath_ignored,\n\tpath_handled,\n\tpath_recurse\n};\n\nstatic enum path_treatment treat_one_path(struct dir_struct *dir,\n\t\t\t\t\t  struct strbuf *path,\n\t\t\t\t\t  const struct path_simplify *simplify,\n\t\t\t\t\t  int dtype, struct dirent *de)\n{\n\tint exclude = excluded(dir, path->buf, &dtype);\n\tif (exclude && (dir->flags & DIR_COLLECT_IGNORED)\n\t    && exclude_matches_pathspec(path->buf, path->len, simplify))\n\t\tdir_add_ignored(dir, path->buf, path->len);\n\n\t/*\n\t * Excluded? If we don't explicitly want to show\n\t * ignored files, ignore it\n\t */\n\tif (exclude && !(dir->flags & DIR_SHOW_IGNORED))\n\t\treturn path_ignored;\n\n\tif (dtype == DT_UNKNOWN)\n\t\tdtype = get_dtype(de, path->buf, path->len);\n\n\t/*\n\t * Do we want to see just the ignored files?\n\t * We still need to recurse into directories,\n\t * even if we don't ignore them, since the\n\t * directory may contain files that we do..\n\t */\n\tif (!exclude && (dir->flags & DIR_SHOW_IGNORED)) {\n\t\tif (dtype != DT_DIR)\n\t\t\treturn path_ignored;\n\t}\n\n\tswitch (dtype) {\n\tdefault:\n\t\treturn path_ignored;\n\tcase DT_DIR:\n\t\tstrbuf_addch(path, '/');\n\t\tswitch (treat_directory(dir, path->buf, path->len, simplify)) {\n\t\tcase show_directory:\n\t\t\tif (exclude != !!(dir->flags\n\t\t\t\t\t  & DIR_SHOW_IGNORED))\n\t\t\t\treturn path_ignored;\n\t\t\tbreak;\n\t\tcase recurse_into_directory:\n\t\t\treturn path_recurse;\n\t\tcase ignore_directory:\n\t\t\treturn path_ignored;\n\t\t}\n\t\tbreak;\n\tcase DT_REG:\n\tcase DT_LNK:\n\t\tbreak;\n\t}\n\treturn path_handled;\n}\n\nstatic enum path_treatment treat_path(struct dir_struct *dir,\n\t\t\t\t      struct dirent *de,\n\t\t\t\t      struct strbuf *path,\n\t\t\t\t      int baselen,\n\t\t\t\t      const struct path_simplify *simplify)\n{\n\tint dtype;\n\n\tif (is_dot_or_dotdot(de->d_name) || !strcmp(de->d_name, \".git\"))\n\t\treturn path_ignored;\n\tstrbuf_setlen(path, baselen);\n\tstrbuf_addstr(path, de->d_name);\n\tif (simplify_away(path->buf, path->len, simplify))\n\t\treturn path_ignored;\n\n\tdtype = DTYPE(de);\n\treturn treat_one_path(dir, path, simplify, dtype, de);\n}\n\n/*\n * Read a directory tree. We currently ignore anything but\n * directories, regular files and symlinks. That's because git\n * doesn't handle them at all yet. Maybe that will change some\n * day.\n *\n * Also, we ignore the name \".git\" (even if it is not a directory).\n * That likely will not change.\n */\nstatic int read_directory_recursive(struct dir_struct *dir,\n\t\t\t\t    const char *base, int baselen,\n\t\t\t\t    int check_only,\n\t\t\t\t    const struct path_simplify *simplify)\n{\n\tDIR *fdir;\n\tint contents = 0;\n\tstruct dirent *de;\n\tstruct strbuf path = STRBUF_INIT;\n\n\tstrbuf_add(&path, base, baselen);\n\n\tfdir = opendir(path.len ? path.buf : \".\");\n\tif (!fdir)\n\t\tgoto out;\n\n\twhile ((de = readdir(fdir)) != NULL) {\n\t\tswitch (treat_path(dir, de, &path, baselen, simplify)) {\n\t\tcase path_recurse:\n\t\t\tcontents += read_directory_recursive(dir, path.buf,\n\t\t\t\t\t\t\t     path.len, 0,\n\t\t\t\t\t\t\t     simplify);\n\t\t\tcontinue;\n\t\tcase path_ignored:\n\t\t\tcontinue;\n\t\tcase path_handled:\n\t\t\tbreak;\n\t\t}\n\t\tcontents++;\n\t\tif (check_only)\n\t\t\tbreak;\n\t\tdir_add_name(dir, path.buf, path.len);\n\t}\n\tclosedir(fdir);\n out:\n\tstrbuf_release(&path);\n\n\treturn contents;\n}\n\nstatic int cmp_name(const void *p1, const void *p2)\n{\n\tconst struct dir_entry *e1 = *(const struct dir_entry **)p1;\n\tconst struct dir_entry *e2 = *(const struct dir_entry **)p2;\n\n\treturn cache_name_compare(e1->name, e1->len,\n\t\t\t\t  e2->name, e2->len);\n}\n\nstatic struct path_simplify *create_simplify(const char **pathspec)\n{\n\tint nr, alloc = 0;\n\tstruct path_simplify *simplify = NULL;\n\n\tif (!pathspec)\n\t\treturn NULL;\n\n\tfor (nr = 0 ; ; nr++) {\n\t\tconst char *match;\n\t\tif (nr >= alloc) {\n\t\t\talloc = alloc_nr(alloc);\n\t\t\tsimplify = xrealloc(simplify, alloc * sizeof(*simplify));\n\t\t}\n\t\tmatch = *pathspec++;\n\t\tif (!match)\n\t\t\tbreak;\n\t\tsimplify[nr].path = match;\n\t\tsimplify[nr].len = simple_length(match);\n\t}\n\tsimplify[nr].path = NULL;\n\tsimplify[nr].len = 0;\n\treturn simplify;\n}\n\nstatic void free_simplify(struct path_simplify *simplify)\n{\n\tfree(simplify);\n}\n\nstatic int treat_leading_path(struct dir_struct *dir,\n\t\t\t      const char *path, int len,\n\t\t\t      const struct path_simplify *simplify)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tint baselen, rc = 0;\n\tconst char *cp;\n\n\twhile (len && path[len - 1] == '/')\n\t\tlen--;\n\tif (!len)\n\t\treturn 1;\n\tbaselen = 0;\n\twhile (1) {\n\t\tcp = path + baselen + !!baselen;\n\t\tcp = memchr(cp, '/', path + len - cp);\n\t\tif (!cp)\n\t\t\tbaselen = len;\n\t\telse\n\t\t\tbaselen = cp - path;\n\t\tstrbuf_setlen(&sb, 0);\n\t\tstrbuf_add(&sb, path, baselen);\n\t\tif (!is_directory(sb.buf))\n\t\t\tbreak;\n\t\tif (simplify_away(sb.buf, sb.len, simplify))\n\t\t\tbreak;\n\t\tif (treat_one_path(dir, &sb, simplify,\n\t\t\t\t   DT_DIR, NULL) == path_ignored)\n\t\t\tbreak; /* do not recurse into it */\n\t\tif (len <= baselen) {\n\t\t\trc = 1;\n\t\t\tbreak; /* finished checking */\n\t\t}\n\t}\n\tstrbuf_release(&sb);\n\treturn rc;\n}\n\nint read_directory(struct dir_struct *dir, const char *path, int len, const char **pathspec)\n{\n\tstruct path_simplify *simplify;\n\n\tif (has_symlink_leading_path(path, len))\n\t\treturn dir->nr;\n\n\tsimplify = create_simplify(pathspec);\n\tif (!len || treat_leading_path(dir, path, len, simplify))\n\t\tread_directory_recursive(dir, path, len, 0, simplify);\n\tfree_simplify(simplify);\n\tqsort(dir->entries, dir->nr, sizeof(struct dir_entry *), cmp_name);\n\tqsort(dir->ignored, dir->ignored_nr, sizeof(struct dir_entry *), cmp_name);\n\treturn dir->nr;\n}\n\nint file_exists(const char *f)\n{\n\tstruct stat sb;\n\treturn lstat(f, &sb) == 0;\n}\n\n/*\n * Given two normalized paths (a trailing slash is ok), if subdir is\n * outside dir, return -1.  Otherwise return the offset in subdir that\n * can be used as relative path to dir.\n */\nint dir_inside_of(const char *subdir, const char *dir)\n{\n\tint offset = 0;\n\n\tassert(dir && subdir && *dir && *subdir);\n\n\twhile (*dir && *subdir && *dir == *subdir) {\n\t\tdir++;\n\t\tsubdir++;\n\t\toffset++;\n\t}\n\n\t/* hel[p]/me vs hel[l]/yeah */\n\tif (*dir && *subdir)\n\t\treturn -1;\n\n\tif (!*subdir)\n\t\treturn !*dir ? offset : -1; /* same dir */\n\n\t/* foo/[b]ar vs foo/[] */\n\tif (is_dir_sep(dir[-1]))\n\t\treturn is_dir_sep(subdir[-1]) ? offset : -1;\n\n\t/* foo[/]bar vs foo[] */\n\treturn is_dir_sep(*subdir) ? offset + 1 : -1;\n}\n\nint is_inside_dir(const char *dir)\n{\n\tchar cwd[PATH_MAX];\n\tif (!dir)\n\t\treturn 0;\n\tif (!getcwd(cwd, sizeof(cwd)))\n\t\tdie_errno(\"can't find the current directory\");\n\treturn dir_inside_of(cwd, dir) >= 0;\n}\n\nint is_empty_dir(const char *path)\n{\n\tDIR *dir = opendir(path);\n\tstruct dirent *e;\n\tint ret = 1;\n\n\tif (!dir)\n\t\treturn 0;\n\n\twhile ((e = readdir(dir)) != NULL)\n\t\tif (!is_dot_or_dotdot(e->d_name)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\tclosedir(dir);\n\treturn ret;\n}\n\nstatic int remove_dir_recurse(struct strbuf *path, int flag, int *kept_up)\n{\n\tDIR *dir;\n\tstruct dirent *e;\n\tint ret = 0, original_len = path->len, len, kept_down = 0;\n\tint only_empty = (flag & REMOVE_DIR_EMPTY_ONLY);\n\tint keep_toplevel = (flag & REMOVE_DIR_KEEP_TOPLEVEL);\n\tunsigned char submodule_head[20];\n\n\tif ((flag & REMOVE_DIR_KEEP_NESTED_GIT) &&\n\t    !resolve_gitlink_ref(path->buf, \"HEAD\", submodule_head)) {\n\t\t/* Do not descend and nuke a nested git work tree. */\n\t\tif (kept_up)\n\t\t\t*kept_up = 1;\n\t\treturn 0;\n\t}\n\n\tflag &= ~REMOVE_DIR_KEEP_TOPLEVEL;\n\tdir = opendir(path->buf);\n\tif (!dir) {\n\t\t/* an empty dir could be removed even if it is unreadble */\n\t\tif (!keep_toplevel)\n\t\t\treturn rmdir(path->buf);\n\t\telse\n\t\t\treturn -1;\n\t}\n\tif (path->buf[original_len - 1] != '/')\n\t\tstrbuf_addch(path, '/');\n\n\tlen = path->len;\n\twhile ((e = readdir(dir)) != NULL) {\n\t\tstruct stat st;\n\t\tif (is_dot_or_dotdot(e->d_name))\n\t\t\tcontinue;\n\n\t\tstrbuf_setlen(path, len);\n\t\tstrbuf_addstr(path, e->d_name);\n\t\tif (lstat(path->buf, &st))\n\t\t\t; /* fall thru */\n\t\telse if (S_ISDIR(st.st_mode)) {\n\t\t\tif (!remove_dir_recurse(path, flag, &kept_down))\n\t\t\t\tcontinue; /* happy */\n\t\t} else if (!only_empty && !unlink(path->buf))\n\t\t\tcontinue; /* happy, too */\n\n\t\t/* path too long, stat fails, or non-directory still exists */\n\t\tret = -1;\n\t\tbreak;\n\t}\n\tclosedir(dir);\n\n\tstrbuf_setlen(path, original_len);\n\tif (!ret && !keep_toplevel && !kept_down)\n\t\tret = rmdir(path->buf);\n\telse if (kept_up)\n\t\t/*\n\t\t * report the uplevel that it is not an error that we\n\t\t * did not rmdir() our directory.\n\t\t */\n\t\t*kept_up = !ret;\n\treturn ret;\n}\n\nint remove_dir_recursively(struct strbuf *path, int flag)\n{\n\treturn remove_dir_recurse(path, flag, NULL);\n}\n\nvoid setup_standard_excludes(struct dir_struct *dir)\n{\n\tconst char *path;\n\n\tdir->exclude_per_dir = \".gitignore\";\n\tpath = git_path(\"info/exclude\");\n\tif (!access(path, R_OK))\n\t\tadd_excludes_from_file(dir, path);\n\tif (excludes_file && !access(excludes_file, R_OK))\n\t\tadd_excludes_from_file(dir, excludes_file);\n}\n\nint remove_path(const char *name)\n{\n\tchar *slash;\n\n\tif (unlink(name) && errno != ENOENT)\n\t\treturn -1;\n\n\tslash = strrchr(name, '/');\n\tif (slash) {\n\t\tchar *dirs = xstrdup(name);\n\t\tslash = dirs + (slash - name);\n\t\tdo {\n\t\t\t*slash = '\\0';\n\t\t} while (rmdir(dirs) == 0 && (slash = strrchr(dirs, '/')));\n\t\tfree(dirs);\n\t}\n\treturn 0;\n}\n\nstatic int pathspec_item_cmp(const void *a_, const void *b_)\n{\n\tstruct pathspec_item *a, *b;\n\n\ta = (struct pathspec_item *)a_;\n\tb = (struct pathspec_item *)b_;\n\treturn strcmp(a->match, b->match);\n}\n\nint init_pathspec(struct pathspec *pathspec, const char **paths)\n{\n\tconst char **p = paths;\n\tint i;\n\n\tmemset(pathspec, 0, sizeof(*pathspec));\n\tif (!p)\n\t\treturn 0;\n\twhile (*p)\n\t\tp++;\n\tpathspec->raw = paths;\n\tpathspec->nr = p - paths;\n\tif (!pathspec->nr)\n\t\treturn 0;\n\n\tpathspec->items = xmalloc(sizeof(struct pathspec_item)*pathspec->nr);\n\tfor (i = 0; i < pathspec->nr; i++) {\n\t\tstruct pathspec_item *item = pathspec->items+i;\n\t\tconst char *path = paths[i];\n\n\t\titem->match = path;\n\t\titem->len = strlen(path);\n\t\titem->use_wildcard = !no_wildcard(path);\n\t\tif (item->use_wildcard)\n\t\t\tpathspec->has_wildcard = 1;\n\t}\n\n\tqsort(pathspec->items, pathspec->nr,\n\t      sizeof(struct pathspec_item), pathspec_item_cmp);\n\n\treturn 0;\n}\n\nvoid free_pathspec(struct pathspec *pathspec)\n{\n\tfree(pathspec->items);\n\tpathspec->items = NULL;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0015cc54f455cf48e6e2d66c23ecebfa017fcf00",
  "sha1_ok": true,
  "size": 32667
}
