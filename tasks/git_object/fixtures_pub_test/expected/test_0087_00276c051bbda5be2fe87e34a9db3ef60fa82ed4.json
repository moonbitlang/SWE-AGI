{
  "content": {
    "base64": "IyEvdXNyL2Jpbi9wZXJsCiMgQ29weXJpZ2h0IChDKSAyMDA2LCBFcmljIFdvbmcgPG5vcm1hbHBlcnNvbkB5aGJ0Lm5ldD4KIyBMaWNlbnNlOiBHUEwgdjIgb3IgbGF0ZXIKdXNlIDUuMDA4Owp1c2Ugd2FybmluZ3M7CnVzZSBzdHJpY3Q7CnVzZSB2YXJzIHF3LwkkQVVUSE9SICRWRVJTSU9OCgkJJG9pZCAkb2lkX3Nob3J0ICRvaWRfbGVuZ3RoCgkJJF9yZXZpc2lvbiAkX3JlcG9zaXRvcnkKCQkkX3EgJF9hdXRob3JzICRfYXV0aG9yc19wcm9nICV1c2Vycy87CiRBVVRIT1IgPSAnRXJpYyBXb25nIDxub3JtYWxwZXJzb25AeWhidC5uZXQ+JzsKJFZFUlNJT04gPSAnQEBHSVRfVkVSU0lPTkBAJzsKCnVzZSBDYXJwIHF3L2Nyb2FrLzsKdXNlIEZpbGU6OkJhc2VuYW1lIHF3L2Rpcm5hbWUgYmFzZW5hbWUvOwp1c2UgRmlsZTo6UGF0aCBxdy9ta3BhdGgvOwp1c2UgRmlsZTo6U3BlYzsKdXNlIEdldG9wdDo6TG9uZyBxdy86Y29uZmlnIGdudV9nZXRvcHQgbm9faWdub3JlX2Nhc2UgYXV0b19hYmJyZXYvOwp1c2UgTWVtb2l6ZTsKCnVzZSBHaXQ6OlNWTjsKdXNlIEdpdDo6U1ZOOjpFZGl0b3I7CnVzZSBHaXQ6OlNWTjo6RmV0Y2hlcjsKdXNlIEdpdDo6U1ZOOjpSYTsKdXNlIEdpdDo6U1ZOOjpQcm9tcHQ7CnVzZSBHaXQ6OlNWTjo6TG9nOwp1c2UgR2l0OjpTVk46Ok1pZ3JhdGlvbjsKCnVzZSBHaXQ6OlNWTjo6VXRpbHMgcXcoCglmYXRhbAoJY2FuX2NvbXByZXNzCgljYW5vbmljYWxpemVfcGF0aAoJY2Fub25pY2FsaXplX3VybAoJam9pbl9wYXRocwoJYWRkX3BhdGhfdG9fdXJsCglqb2luX3BhdGhzCik7Cgp1c2UgR2l0IHF3KAoJZ2l0X2NtZF90cnkKCWNvbW1hbmQKCWNvbW1hbmRfb25lbGluZQoJY29tbWFuZF9ub2lzeQoJY29tbWFuZF9vdXRwdXRfcGlwZQoJY29tbWFuZF9jbG9zZV9waXBlCgljb21tYW5kX2JpZGlfcGlwZQoJY29tbWFuZF9jbG9zZV9iaWRpX3BpcGUKCWdldF9yZWNvcmQKKTsKCkJFR0lOIHsKCU1lbW9pemU6Om1lbW9pemUgJ0dpdDo6Y29uZmlnJzsKCU1lbW9pemU6Om1lbW9pemUgJ0dpdDo6Y29uZmlnX2Jvb2wnOwp9CgoKIyBGcm9tIHdoaWNoIHN1YmRpciBoYXZlIHdlIGJlZW4gaW52b2tlZD8KbXkgJGNtZF9kaXJfcHJlZml4ID0gZXZhbCB7Cgljb21tYW5kX29uZWxpbmUoW3F3L3Jldi1wYXJzZSAtLXNob3ctcHJlZml4L10sIFNUREVSUiA9PiAwKQp9IHx8ICcnOwoKJEdpdDo6U1ZOOjpSYTo6X2xvZ193aW5kb3dfc2l6ZSA9IDEwMDsKCmlmICghIGV4aXN0cyAkRU5We1NWTl9TU0h9ICYmIGV4aXN0cyAkRU5We0dJVF9TU0h9KSB7CgkkRU5We1NWTl9TU0h9ID0gJEVOVntHSVRfU1NIfTsKfQoKaWYgKGV4aXN0cyAkRU5We1NWTl9TU0h9ICYmICReTyBlcSAnbXN5cycpIHsKCSRFTlZ7U1ZOX1NTSH0gPX4gcy9cXC9cXFxcL2c7CgkkRU5We1NWTl9TU0h9ID1+IHMvKC4qKS8iJDEiLzsKfQoKJEdpdDo6U1ZOOjpMb2c6OlRaID0gJEVOVntUWn07CiRFTlZ7VFp9ID0gJ1VUQyc7CiR8ID0gMTsgIyB1bmJ1ZmZlciBTVERPVVQKCiMgQWxsIFNWTiBjb21tYW5kcyBkbyBpdC4gIE90aGVyd2lzZSB3ZSBtYXkgZGllIG9uIFNJR1BJUEUgd2hlbiB0aGUgcmVtb3RlCiMgcmVwb3NpdG9yeSBkZWNpZGVzIHRvIGNsb3NlIHRoZSBjb25uZWN0aW9uIHdoaWNoIHdlIGV4cGVjdCB0byBiZSBrZXB0IGFsaXZlLgokU0lHe1BJUEV9ID0gJ0lHTk9SRSc7CgojIEdpdmVuIGEgZG90IHNlcGFyYXRlZCB2ZXJzaW9uIG51bWJlciwgInN1YnRyYWN0IiBpdCBmcm9tCiMgdGhlIFNWTjo6Q29yZTo6VkVSU0lPTjsgbm9uLW5lZ2FpdGl2ZSByZXR1cm4gbWVhbnMgdGhlIFNWTjo6Q29yZQojIGlzIGF0IGxlYXN0IGF0IHRoZSB2ZXJzaW9uIHRoZSBjYWxsZXIgYXNrZWQgZm9yLgpzdWIgY29tcGFyZV9zdm5fdmVyc2lvbiB7CglteSAoQG91cnMpID0gc3BsaXQoL1wuLywgJFNWTjo6Q29yZTo6VkVSU0lPTik7CglteSAoQHRoZWlycykgPSBzcGxpdCgvXC4vLCAkX1swXSk7CglteSAoJGksICRkaWZmKTsKCglmb3IgKCRpID0gMDsgJGkgPCBAb3VycyAmJiAkaSA8IEB0aGVpcnM7ICRpKyspIHsKCQkkZGlmZiA9ICRvdXJzWyRpXSAtICR0aGVpcnNbJGldOwoJCXJldHVybiAkZGlmZiBpZiAoJGRpZmYpOwoJfQoJcmV0dXJuIDEgaWYgKCRpIDwgQG91cnMpOwoJcmV0dXJuIC0xIGlmICgkaSA8IEB0aGVpcnMpOwoJcmV0dXJuIDA7Cn0KCnN1YiBfcmVxX3N2biB7CglyZXF1aXJlIFNWTjo6Q29yZTsgIyB1c2UoKS1pbmcgdGhpcyBjYXVzZXMgc2VnZmF1bHRzIGZvciBtZS4uLiAqc2hydWcqCglyZXF1aXJlIFNWTjo6UmE7CglyZXF1aXJlIFNWTjo6RGVsdGE7CglpZiAoOjpjb21wYXJlX3N2bl92ZXJzaW9uKCcxLjEuMCcpIDwgMCkgewoJCWZhdGFsICJOZWVkIFNWTjo6Q29yZSAxLjEuMCBvciBiZXR0ZXIgKGdvdCAkU1ZOOjpDb3JlOjpWRVJTSU9OKSI7Cgl9Cn0KCiRvaWQgPSBxci8oPzpbYS1mXGRdezQwfSg/OlthLWZcZF17MjR9KT8pLzsKJG9pZF9zaG9ydCA9IHFyL1thLWZcZF17NCw2NH0vOwokb2lkX2xlbmd0aCA9IDQwOwpteSAoJF9zdGRpbiwgJF9oZWxwLCAkX2VkaXQsCgkkX21lc3NhZ2UsICRfZmlsZSwgJF9icmFuY2hfZGVzdCwKCSRfdGVtcGxhdGUsICRfc2hhcmVkLAoJJF92ZXJzaW9uLCAkX2ZldGNoX2FsbCwgJF9ub19yZWJhc2UsICRfZmV0Y2hfcGFyZW50LAoJJF9iZWZvcmUsICRfYWZ0ZXIsCgkkX21lcmdlLCAkX3N0cmF0ZWd5LCAkX3JlYmFzZV9tZXJnZXMsICRfZHJ5X3J1biwgJF9wYXJlbnRzLCAkX2xvY2FsLAoJJF9wcmVmaXgsICRfbm9fY2hlY2tvdXQsICRfdXJsLCAkX3ZlcmJvc2UsCgkkX2NvbW1pdF91cmwsICRfdGFnLCAkX21lcmdlX2luZm8sICRfaW50ZXJhY3RpdmUsICRfc2V0X3N2bl9wcm9wcyk7CgojIFRoaXMgaXMgYSByZWZhY3RvcmluZyBhcnRpZmFjdCBzbyBHaXQ6OlNWTiBjYW4gZ2V0IGF0IHRoaXMgZ2l0LXN2biBzd2l0Y2guCnN1YiBvcHRfcHJlZml4IHsgcmV0dXJuICRfcHJlZml4IHx8ICcnIH0KCiRHaXQ6OlNWTjo6RmV0Y2hlcjo6X3BsYWNlaG9sZGVyX2ZpbGVuYW1lID0gIi5naXRpZ25vcmUiOwokX3EgfHw9IDA7Cm15ICVyZW1vdGVfb3B0cyA9ICggJ3VzZXJuYW1lPXMnID0+IFwkR2l0OjpTVk46OlByb21wdDo6X3VzZXJuYW1lLAogICAgICAgICAgICAgICAgICAgICdjb25maWctZGlyPXMnID0+IFwkR2l0OjpTVk46OlJhOjpjb25maWdfZGlyLAogICAgICAgICAgICAgICAgICAgICduby1hdXRoLWNhY2hlJyA9PiBcJEdpdDo6U1ZOOjpQcm9tcHQ6Ol9ub19hdXRoX2NhY2hlLAogICAgICAgICAgICAgICAgICAgICdpZ25vcmUtcGF0aHM9cycgPT4gXCRHaXQ6OlNWTjo6RmV0Y2hlcjo6X2lnbm9yZV9yZWdleCwKICAgICAgICAgICAgICAgICAgICAnaW5jbHVkZS1wYXRocz1zJyA9PiBcJEdpdDo6U1ZOOjpGZXRjaGVyOjpfaW5jbHVkZV9yZWdleCwKICAgICAgICAgICAgICAgICAgICAnaWdub3JlLXJlZnM9cycgPT4gXCRHaXQ6OlNWTjo6UmE6Ol9pZ25vcmVfcmVmc19yZWdleCApOwpteSAlZmNfb3B0cyA9ICggJ2ZvbGxvdy1wYXJlbnR8Zm9sbG93IScgPT4gXCRHaXQ6OlNWTjo6X2ZvbGxvd19wYXJlbnQsCgkJJ2F1dGhvcnMtZmlsZXxBPXMnID0+IFwkX2F1dGhvcnMsCgkJJ2F1dGhvcnMtcHJvZz1zJyA9PiBcJF9hdXRob3JzX3Byb2csCgkJJ3JlcGFjazppJyA9PiBcJEdpdDo6U1ZOOjpfcmVwYWNrLAoJCSdub01ldGFkYXRhJyA9PiBcJEdpdDo6U1ZOOjpfbm9fbWV0YWRhdGEsCgkJJ3VzZVN2bVByb3BzJyA9PiBcJEdpdDo6U1ZOOjpfdXNlX3N2bV9wcm9wcywKCQkndXNlU3Zuc3luY1Byb3BzJyA9PiBcJEdpdDo6U1ZOOjpfdXNlX3N2bnN5bmNfcHJvcHMsCgkJJ2xvZy13aW5kb3ctc2l6ZT1pJyA9PiBcJEdpdDo6U1ZOOjpSYTo6X2xvZ193aW5kb3dfc2l6ZSwKCQknbm8tY2hlY2tvdXQnID0+IFwkX25vX2NoZWNrb3V0LAoJCSdxdWlldHxxKycgPT4gXCRfcSwKCQkncmVwYWNrLWZsYWdzfHJlcGFjay1hcmdzfHJlcGFjay1vcHRzPXMnID0+CgkJICAgXCRHaXQ6OlNWTjo6X3JlcGFja19mbGFncywKCQkndXNlLWxvZy1hdXRob3InID0+IFwkR2l0OjpTVk46Ol91c2VfbG9nX2F1dGhvciwKCQknYWRkLWF1dGhvci1mcm9tJyA9PiBcJEdpdDo6U1ZOOjpfYWRkX2F1dGhvcl9mcm9tLAoJCSdsb2NhbHRpbWUnID0+IFwkR2l0OjpTVk46Ol9sb2NhbHRpbWUsCgkJJXJlbW90ZV9vcHRzICk7CgpteSAoJF90cnVuaywgQF90YWdzLCBAX2JyYW5jaGVzLCAkX3N0ZGxheW91dCk7Cm15ICVpY3Y7Cm15ICVpbml0X29wdHMgPSAoICd0ZW1wbGF0ZT1zJyA9PiBcJF90ZW1wbGF0ZSwgJ3NoYXJlZDpzJyA9PiBcJF9zaGFyZWQsCiAgICAgICAgICAgICAgICAgICd0cnVua3xUPXMnID0+IFwkX3RydW5rLCAndGFnc3x0PXNAJyA9PiBcQF90YWdzLAogICAgICAgICAgICAgICAgICAnYnJhbmNoZXN8Yj1zQCcgPT4gXEBfYnJhbmNoZXMsICdwcmVmaXg9cycgPT4gXCRfcHJlZml4LAogICAgICAgICAgICAgICAgICAnc3RkbGF5b3V0fHMnID0+IFwkX3N0ZGxheW91dCwKICAgICAgICAgICAgICAgICAgJ21pbmltaXplLXVybHxtIScgPT4gXCRHaXQ6OlNWTjo6X21pbmltaXplX3VybCwKCQkgICduby1tZXRhZGF0YScgPT4gc3ViIHsgJGljdntub01ldGFkYXRhfSA9IDEgfSwKCQkgICd1c2Utc3ZtLXByb3BzJyA9PiBzdWIgeyAkaWN2e3VzZVN2bVByb3BzfSA9IDEgfSwKCQkgICd1c2Utc3Zuc3luYy1wcm9wcycgPT4gc3ViIHsgJGljdnt1c2VTdm5zeW5jUHJvcHN9ID0gMSB9LAoJCSAgJ3Jld3JpdGUtcm9vdD1zJyA9PiBzdWIgeyAkaWN2e3Jld3JpdGVSb290fSA9ICRfWzFdIH0sCgkJICAncmV3cml0ZS11dWlkPXMnID0+IHN1YiB7ICRpY3Z7cmV3cml0ZVVVSUR9ID0gJF9bMV0gfSwKICAgICAgICAgICAgICAgICAgJXJlbW90ZV9vcHRzICk7Cm15ICVjbXRfb3B0cyA9ICggJ2VkaXR8ZScgPT4gXCRfZWRpdCwKCQkncm1kaXInID0+IFwkR2l0OjpTVk46OkVkaXRvcjo6X3JtZGlyLAoJCSdmaW5kLWNvcGllcy1oYXJkZXInID0+IFwkR2l0OjpTVk46OkVkaXRvcjo6X2ZpbmRfY29waWVzX2hhcmRlciwKCQknbD1pJyA9PiBcJEdpdDo6U1ZOOjpFZGl0b3I6Ol9yZW5hbWVfbGltaXQsCgkJJ2NvcHktc2ltaWxhcml0eXxDPWknPT4gXCRHaXQ6OlNWTjo6RWRpdG9yOjpfY3Bfc2ltaWxhcml0eQopOwoKbXkgJWNtZCA9ICgKCWZldGNoID0+IFsgXCZjbWRfZmV0Y2gsICJEb3dubG9hZCBuZXcgcmV2aXNpb25zIGZyb20gU1ZOIiwKCQkJeyAncmV2aXNpb258cj1zJyA9PiBcJF9yZXZpc2lvbiwKCQkJICAnZmV0Y2gtYWxsfGFsbCcgPT4gXCRfZmV0Y2hfYWxsLAoJCQkgICdwYXJlbnR8cCcgPT4gXCRfZmV0Y2hfcGFyZW50LAoJCQkgICAlZmNfb3B0cyB9IF0sCgljbG9uZSA9PiBbIFwmY21kX2Nsb25lLCAiSW5pdGlhbGl6ZSBhbmQgZmV0Y2ggcmV2aXNpb25zIiwKCQkJeyAncmV2aXNpb258cj1zJyA9PiBcJF9yZXZpc2lvbiwKCQkJICAncHJlc2VydmUtZW1wdHktZGlycycgPT4KCQkJCVwkR2l0OjpTVk46OkZldGNoZXI6Ol9wcmVzZXJ2ZV9lbXB0eV9kaXJzLAoJCQkgICdwbGFjZWhvbGRlci1maWxlbmFtZT1zJyA9PgoJCQkJXCRHaXQ6OlNWTjo6RmV0Y2hlcjo6X3BsYWNlaG9sZGVyX2ZpbGVuYW1lLAoJCQkgICAlZmNfb3B0cywgJWluaXRfb3B0cyB9IF0sCglpbml0ID0+IFsgXCZjbWRfaW5pdCwgIkluaXRpYWxpemUgYSByZXBvIGZvciB0cmFja2luZyIgLgoJCQkgICIgKHJlcXVpcmVzIFVSTCBhcmd1bWVudCkiLAoJCQkgIFwlaW5pdF9vcHRzIF0sCgknbXVsdGktaW5pdCcgPT4gWyBcJmNtZF9tdWx0aV9pbml0LAoJICAgICAgICAgICAgICAgICAgIkRlcHJlY2F0ZWQgYWxpYXMgZm9yICIuCgkJCSAgIickMCBpbml0IC1UPHRydW5rPiAtYjxicmFuY2hlcz4gLXQ8dGFncz4nIiwKCQkJICBcJWluaXRfb3B0cyBdLAoJZGNvbW1pdCA9PiBbIFwmY21kX2Rjb21taXQsCgkgICAgICAgICAgICAgJ0NvbW1pdCBzZXZlcmFsIGRpZmZzIHRvIG1lcmdlIHdpdGggdXBzdHJlYW0nLAoJCQl7ICdtZXJnZXxtfE0nID0+IFwkX21lcmdlLAoJCQkgICdzdHJhdGVneXxzPXMnID0+IFwkX3N0cmF0ZWd5LAoJCQkgICd2ZXJib3NlfHYnID0+IFwkX3ZlcmJvc2UsCgkJCSAgJ2RyeS1ydW58bicgPT4gXCRfZHJ5X3J1biwKCQkJICAnZmV0Y2gtYWxsfGFsbCcgPT4gXCRfZmV0Y2hfYWxsLAoJCQkgICdjb21taXQtdXJsPXMnID0+IFwkX2NvbW1pdF91cmwsCgkJCSAgJ3NldC1zdm4tcHJvcHM9cycgPT4gXCRfc2V0X3N2bl9wcm9wcywKCQkJICAncmV2aXNpb258cj1pJyA9PiBcJF9yZXZpc2lvbiwKCQkJICAnbm8tcmViYXNlJyA9PiBcJF9ub19yZWJhc2UsCgkJCSAgJ21lcmdlaW5mbz1zJyA9PiBcJF9tZXJnZV9pbmZvLAoJCQkgICdpbnRlcmFjdGl2ZXxpJyA9PiBcJF9pbnRlcmFjdGl2ZSwKCQkJJWNtdF9vcHRzLCAlZmNfb3B0cyB9IF0sCglicmFuY2ggPT4gWyBcJmNtZF9icmFuY2gsCgkgICAgICAgICAgICAnQ3JlYXRlIGEgYnJhbmNoIGluIHRoZSBTVk4gcmVwb3NpdG9yeScsCgkgICAgICAgICAgICB7ICdtZXNzYWdlfG09cycgPT4gXCRfbWVzc2FnZSwKCSAgICAgICAgICAgICAgJ2Rlc3RpbmF0aW9ufGQ9cycgPT4gXCRfYnJhbmNoX2Rlc3QsCgkgICAgICAgICAgICAgICdkcnktcnVufG4nID0+IFwkX2RyeV9ydW4sCgkgICAgICAgICAgICAgICdwYXJlbnRzJyA9PiBcJF9wYXJlbnRzLAoJICAgICAgICAgICAgICAndGFnfHQnID0+IFwkX3RhZywKCSAgICAgICAgICAgICAgJ3VzZXJuYW1lPXMnID0+IFwkR2l0OjpTVk46OlByb21wdDo6X3VzZXJuYW1lLAoJICAgICAgICAgICAgICAnY29tbWl0LXVybD1zJyA9PiBcJF9jb21taXRfdXJsIH0gXSwKCXRhZyA9PiBbIHN1YiB7ICRfdGFnID0gMTsgY21kX2JyYW5jaChAXykgfSwKCSAgICAgICAgICdDcmVhdGUgYSB0YWcgaW4gdGhlIFNWTiByZXBvc2l0b3J5JywKCSAgICAgICAgIHsgJ21lc3NhZ2V8bT1zJyA9PiBcJF9tZXNzYWdlLAoJICAgICAgICAgICAnZGVzdGluYXRpb258ZD1zJyA9PiBcJF9icmFuY2hfZGVzdCwKCSAgICAgICAgICAgJ2RyeS1ydW58bicgPT4gXCRfZHJ5X3J1biwKCSAgICAgICAgICAgJ3BhcmVudHMnID0+IFwkX3BhcmVudHMsCgkgICAgICAgICAgICd1c2VybmFtZT1zJyA9PiBcJEdpdDo6U1ZOOjpQcm9tcHQ6Ol91c2VybmFtZSwKCSAgICAgICAgICAgJ2NvbW1pdC11cmw9cycgPT4gXCRfY29tbWl0X3VybCB9IF0sCgknc2V0LXRyZWUnID0+IFsgXCZjbWRfc2V0X3RyZWUsCgkgICAgICAgICAgICAgICAgIlNldCBhbiBTVk4gcmVwb3NpdG9yeSB0byBhIGdpdCB0cmVlLWlzaCIsCgkJCXsgJ3N0ZGluJyA9PiBcJF9zdGRpbiwgJWNtdF9vcHRzLCAlZmNfb3B0cywgfSBdLAoJJ2NyZWF0ZS1pZ25vcmUnID0+IFsgXCZjbWRfY3JlYXRlX2lnbm9yZSwKCQkJICAgICAnQ3JlYXRlIGEgLmdpdGlnbm9yZSBwZXIgc3ZuOmlnbm9yZScsCgkJCSAgICAgeyAncmV2aXNpb258cj1pJyA9PiBcJF9yZXZpc2lvbgoJCQkgICAgIH0gXSwKCSdta2RpcnMnID0+IFsgXCZjbWRfbWtkaXJzICwKCSAgICAgICAgICAgICAgInJlY3JlYXRlIGVtcHR5IGRpcmVjdG9yaWVzIGFmdGVyIGEgY2hlY2tvdXQiLAoJICAgICAgICAgICAgICB7ICdyZXZpc2lvbnxyPWknID0+IFwkX3JldmlzaW9uIH0gXSwKICAgICAgICAncHJvcGdldCcgPT4gWyBcJmNtZF9wcm9wZ2V0LAoJCSAgICAgICAnUHJpbnQgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgb24gYSBmaWxlIG9yIGRpcmVjdG9yeScsCgkJICAgICAgIHsgJ3JldmlzaW9ufHI9aScgPT4gXCRfcmV2aXNpb24gfSBdLAogICAgICAgICdwcm9wc2V0JyA9PiBbIFwmY21kX3Byb3BzZXQsCgkJICAgICAgICdTZXQgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgb24gYSBmaWxlIG9yIGRpcmVjdG9yeSAtIHdpbGwgYmUgc2V0IG9uIGNvbW1pdCcsCgkJICAgICAgIHt9IF0sCiAgICAgICAgJ3Byb3BsaXN0JyA9PiBbIFwmY21kX3Byb3BsaXN0LAoJCSAgICAgICAnTGlzdCBhbGwgcHJvcGVydGllcyBvZiBhIGZpbGUgb3IgZGlyZWN0b3J5JywKCQkgICAgICAgeyAncmV2aXNpb258cj1pJyA9PiBcJF9yZXZpc2lvbiB9IF0sCgknc2hvdy1pZ25vcmUnID0+IFsgXCZjbWRfc2hvd19pZ25vcmUsICJTaG93IHN2bjppZ25vcmUgbGlzdGluZ3MiLAoJCQl7ICdyZXZpc2lvbnxyPWknID0+IFwkX3JldmlzaW9uCgkJCX0gXSwKCSdzaG93LWV4dGVybmFscycgPT4gWyBcJmNtZF9zaG93X2V4dGVybmFscywgIlNob3cgc3ZuOmV4dGVybmFscyBsaXN0aW5ncyIsCgkJCXsgJ3JldmlzaW9ufHI9aScgPT4gXCRfcmV2aXNpb24KCQkJfSBdLAoJJ211bHRpLWZldGNoJyA9PiBbIFwmY21kX211bHRpX2ZldGNoLAoJICAgICAgICAgICAgICAgICAgICJEZXByZWNhdGVkIGFsaWFzIGZvciAkMCBmZXRjaCAtLWFsbCIsCgkJCSAgIHsgJ3JldmlzaW9ufHI9cycgPT4gXCRfcmV2aXNpb24sICVmY19vcHRzIH0gXSwKCSdtaWdyYXRlJyA9PiBbIHN1YiB7IH0sCgkgICAgICAgICAgICAgICAjIG5vLW9wLCB3ZSBhdXRvbWF0aWNhbGx5IHJ1biB0aGlzIGFueXdheXMsCgkgICAgICAgICAgICAgICAnTWlncmF0ZSBjb25maWd1cmF0aW9uL21ldGFkYXRhL2xheW91dCBmcm9tCgkJICAgICAgICBwcmV2aW91cyB2ZXJzaW9ucyBvZiBnaXQtc3ZuJywKICAgICAgICAgICAgICAgICAgICAgICB7ICdtaW5pbWl6ZScgPT4gXCRHaXQ6OlNWTjo6TWlncmF0aW9uOjpfbWluaW1pemUsCgkJCSAlcmVtb3RlX29wdHMgfSBdLAoJJ2xvZycgPT4gWyBcJkdpdDo6U1ZOOjpMb2c6OmNtZF9zaG93X2xvZywgJ1Nob3cgY29tbWl0IGxvZ3MnLAoJCQl7ICdsaW1pdD1pJyA9PiBcJEdpdDo6U1ZOOjpMb2c6OmxpbWl0LAoJCQkgICdyZXZpc2lvbnxyPXMnID0+IFwkX3JldmlzaW9uLAoJCQkgICd2ZXJib3NlfHYnID0+IFwkR2l0OjpTVk46OkxvZzo6dmVyYm9zZSwKCQkJICAnaW5jcmVtZW50YWwnID0+IFwkR2l0OjpTVk46OkxvZzo6aW5jcmVtZW50YWwsCgkJCSAgJ29uZWxpbmUnID0+IFwkR2l0OjpTVk46OkxvZzo6b25lbGluZSwKCQkJICAnc2hvdy1jb21taXQnID0+IFwkR2l0OjpTVk46OkxvZzo6c2hvd19jb21taXQsCgkJCSAgJ25vbi1yZWN1cnNpdmUnID0+IFwkR2l0OjpTVk46OkxvZzo6bm9uX3JlY3Vyc2l2ZSwKCQkJICAnYXV0aG9ycy1maWxlfEE9cycgPT4gXCRfYXV0aG9ycywKCQkJICAnY29sb3InID0+IFwkR2l0OjpTVk46OkxvZzo6Y29sb3IsCgkJCSAgJ3BhZ2VyPXMnID0+IFwkR2l0OjpTVk46OkxvZzo6cGFnZXIKCQkJfSBdLAoJJ2ZpbmQtcmV2JyA9PiBbIFwmY21kX2ZpbmRfcmV2LAoJICAgICAgICAgICAgICAgICJUcmFuc2xhdGUgYmV0d2VlbiBTVk4gcmV2aXNpb24gbnVtYmVycyBhbmQgdHJlZS1pc2giLAoJCQl7ICdCfGJlZm9yZScgPT4gXCRfYmVmb3JlLAoJCQkgICdBfGFmdGVyJyA9PiBcJF9hZnRlciB9IF0sCgkncmViYXNlJyA9PiBbIFwmY21kX3JlYmFzZSwgIkZldGNoIGFuZCByZWJhc2UgeW91ciB3b3JraW5nIGRpcmVjdG9yeSIsCgkJCXsgJ21lcmdlfG18TScgPT4gXCRfbWVyZ2UsCgkJCSAgJ3ZlcmJvc2V8dicgPT4gXCRfdmVyYm9zZSwKCQkJICAnc3RyYXRlZ3l8cz1zJyA9PiBcJF9zdHJhdGVneSwKCQkJICAnbG9jYWx8bCcgPT4gXCRfbG9jYWwsCgkJCSAgJ2ZldGNoLWFsbHxhbGwnID0+IFwkX2ZldGNoX2FsbCwKCQkJICAnZHJ5LXJ1bnxuJyA9PiBcJF9kcnlfcnVuLAoJCQkgICdyZWJhc2UtbWVyZ2VzfHAnID0+IFwkX3JlYmFzZV9tZXJnZXMsCgkJCSAgJ3ByZXNlcnZlLW1lcmdlc3xwJyA9PiBcJF9yZWJhc2VfbWVyZ2VzLAoJCQkgICVmY19vcHRzIH0gXSwKCSdjb21taXQtZGlmZicgPT4gWyBcJmNtZF9jb21taXRfZGlmZiwKCSAgICAgICAgICAgICAgICAgICAnQ29tbWl0IGEgZGlmZiBiZXR3ZWVuIHR3byB0cmVlcycsCgkJCXsgJ21lc3NhZ2V8bT1zJyA9PiBcJF9tZXNzYWdlLAoJCQkgICdmaWxlfEY9cycgPT4gXCRfZmlsZSwKCQkJICAncmV2aXNpb258cj1zJyA9PiBcJF9yZXZpc2lvbiwKCQkJJWNtdF9vcHRzIH0gXSwKCSdpbmZvJyA9PiBbIFwmY21kX2luZm8sCgkJICAgICJTaG93IGluZm8gYWJvdXQgdGhlIGxhdGVzdCBTVk4gcmV2aXNpb24KCQkgICAgIG9uIHRoZSBjdXJyZW50IGJyYW5jaCIsCgkJICAgIHsgJ3VybCcgPT4gXCRfdXJsLCB9IF0sCgknYmxhbWUnID0+IFsgXCZHaXQ6OlNWTjo6TG9nOjpjbWRfYmxhbWUsCgkgICAgICAgICAgICAiU2hvdyB3aGF0IHJldmlzaW9uIGFuZCBhdXRob3IgbGFzdCBtb2RpZmllZCBlYWNoIGxpbmUgb2YgYSBmaWxlIiwKCQkgICAgeyAnZ2l0LWZvcm1hdCcgPT4gXCRHaXQ6OlNWTjo6TG9nOjpfZ2l0X2Zvcm1hdCB9IF0sCgkncmVzZXQnID0+IFsgXCZjbWRfcmVzZXQsCgkJICAgICAiVW5kbyBmZXRjaGVzIGJhY2sgdG8gdGhlIHNwZWNpZmllZCBTVk4gcmV2aXNpb24iLAoJCSAgICAgeyAncmV2aXNpb258cj1zJyA9PiBcJF9yZXZpc2lvbiwKCQkgICAgICAgJ3BhcmVudHxwJyA9PiBcJF9mZXRjaF9wYXJlbnQgfSBdLAoJJ2djJyA9PiBbIFwmY21kX2djLAoJCSAgIkNvbXByZXNzIHVuaGFuZGxlZC5sb2cgZmlsZXMgaW4gLmdpdC9zdm4gYW5kIHJlbW92ZSAiIC4KCQkgICJpbmRleCBmaWxlcyBpbiAuZ2l0L3N2biIsCgkJe30gXSwKKTsKCnBhY2thZ2UgRmFrZVRlcm07CnN1YiBuZXcgewoJbXkgKCRjbGFzcywgJHJlYXNvbikgPSBAXzsKCXJldHVybiBibGVzcyBcJHJlYXNvbiwgc2hpZnQ7Cn0Kc3ViIHJlYWRsaW5lIHsKCW15ICRzZWxmID0gc2hpZnQ7CglkaWUgIkNhbm5vdCB1c2UgcmVhZGxpbmUgb24gRmFrZVRlcm06ICQkc2VsZiI7Cn0KcGFja2FnZSBtYWluOwoKbXkgJHRlcm07CnN1YiB0ZXJtX2luaXQgewoJJHRlcm0gPSBldmFsIHsKCQlyZXF1aXJlIFRlcm06OlJlYWRMaW5lOwoJCSRFTlZ7IkdJVF9TVk5fTk9UVFkifQoJCQk/IG5ldyBUZXJtOjpSZWFkTGluZSAnZ2l0LXN2bicsIFwqU1RESU4sIFwqU1RET1VUCgkJCTogbmV3IFRlcm06OlJlYWRMaW5lICdnaXQtc3ZuJzsKCX07CglpZiAoJEApIHsKCQkkdGVybSA9IG5ldyBGYWtlVGVybSAiJEA6IGdvaW5nIG5vbi1pbnRlcmFjdGl2ZSI7Cgl9Cn0KCm15ICRjbWQ7CmZvciAobXkgJGkgPSAwOyAkaSA8IEBBUkdWOyAkaSsrKSB7CglpZiAoZGVmaW5lZCAkY21keyRBUkdWWyRpXX0pIHsKCQkkY21kID0gJEFSR1ZbJGldOwoJCXNwbGljZSBAQVJHViwgJGksIDE7CgkJbGFzdDsKCX0gZWxzaWYgKCRBUkdWWyRpXSBlcSAnaGVscCcpIHsKCQkkY21kID0gJEFSR1ZbJGkrMV07CgkJdXNhZ2UoMCk7Cgl9Cn07CgojIG1ha2Ugc3VyZSB3ZSdyZSBhbHdheXMgcnVubmluZyBhdCB0aGUgdG9wLWxldmVsIHdvcmtpbmcgZGlyZWN0b3J5CmlmICgkY21kICYmICRjbWQgPX4gLyg/OmNsb25lfGluaXR8bXVsdGktaW5pdCkkLykgewoJJEVOVntHSVRfRElSfSB8fD0gIi5naXQiOwoJIyBjYXRjaCB0aGUgc3VibW9kdWxlIGNhc2UKCWlmICgtZiAkRU5We0dJVF9ESVJ9KSB7CgkJb3BlbihteSAkZmgsICc8JywgJEVOVntHSVRfRElSfSkgb3IKCQkJZGllICJmYWlsZWQgdG8gb3BlbiAkRU5We0dJVF9ESVJ9OiAkIVxuIjsKCQkkRU5We0dJVF9ESVJ9ID0gJDEgaWYgPCRmaD4gPX4gL15naXRkaXI6ICguKykkLzsKCX0KfSBlbHNpZiAoJGNtZCkgewoJbXkgKCRnaXRfZGlyLCAkY2R1cCk7CglnaXRfY21kX3RyeSB7CgkJJGdpdF9kaXIgPSBjb21tYW5kX29uZWxpbmUoW3F3L3Jldi1wYXJzZSAtLWdpdC1kaXIvXSk7Cgl9ICJVbmFibGUgdG8gZmluZCAuZ2l0IGRpcmVjdG9yeVxuIjsKCWdpdF9jbWRfdHJ5IHsKCQkkY2R1cCA9IGNvbW1hbmRfb25lbGluZShxdy9yZXYtcGFyc2UgLS1zaG93LWNkdXAvKTsKCQljaG9tcCAkY2R1cCBpZiAoJGNkdXApOwoJCSRjZHVwID0gIi4iIHVubGVzcyAoJGNkdXAgJiYgbGVuZ3RoICRjZHVwKTsKCX0gIkFscmVhZHkgYXQgdG9wbGV2ZWwsIGJ1dCAkZ2l0X2RpciBub3QgZm91bmRcbiI7CgkkRU5We0dJVF9ESVJ9ID0gJGdpdF9kaXI7CgljaGRpciAkY2R1cCBvciBkaWUgIlVuYWJsZSB0byBjaGRpciB1cCB0byAnJGNkdXAnXG4iOwoJJF9yZXBvc2l0b3J5ID0gR2l0LT5yZXBvc2l0b3J5KFJlcG9zaXRvcnkgPT4gJEVOVntHSVRfRElSfSk7Cn0KCm15ICVvcHRzID0gJXskY21keyRjbWR9LT5bMl19IGlmIChkZWZpbmVkICRjbWQpOwoKcmVhZF9naXRfY29uZmlnKFwlb3B0cykgaWYgJEVOVntHSVRfRElSfTsKaWYgKCRjbWQgJiYgKCRjbWQgZXEgJ2xvZycgfHwgJGNtZCBlcSAnYmxhbWUnKSkgewoJR2V0b3B0OjpMb25nOjpDb25maWd1cmUoJ3Bhc3NfdGhyb3VnaCcpOwp9Cm15ICRydiA9IEdldE9wdGlvbnMoJW9wdHMsICdofEgnID0+IFwkX2hlbHAsICd2ZXJzaW9ufFYnID0+IFwkX3ZlcnNpb24sCiAgICAgICAgICAgICAgICAgICAgJ21pbmltaXplLWNvbm5lY3Rpb25zJyA9PiBcJEdpdDo6U1ZOOjpNaWdyYXRpb246Ol9taW5pbWl6ZSwKICAgICAgICAgICAgICAgICAgICAnaWR8aT1zJyA9PiBcJEdpdDo6U1ZOOjpkZWZhdWx0X3JlZl9pZCwKICAgICAgICAgICAgICAgICAgICAnc3ZuLXJlbW90ZXxyZW1vdGV8Uj1zJyA9PiBzdWIgewogICAgICAgICAgICAgICAgICAgICAgICRHaXQ6OlNWTjo6bm9fcmV1c2VfZXhpc3RpbmcgPSAxOwogICAgICAgICAgICAgICAgICAgICAgICRHaXQ6OlNWTjo6ZGVmYXVsdF9yZXBvX2lkID0gJF9bMV0gfSk7CmV4aXQgMSBpZiAoISRydiAmJiAkY21kICYmICRjbWQgbmUgJ2xvZycpOwoKdXNhZ2UoMCkgaWYgJF9oZWxwOwp2ZXJzaW9uKCkgaWYgJF92ZXJzaW9uOwp1c2FnZSgxKSB1bmxlc3MgZGVmaW5lZCAkY21kOwpsb2FkX2F1dGhvcnMoKSBpZiAkX2F1dGhvcnM7CmlmIChkZWZpbmVkICRfYXV0aG9yc19wcm9nKSB7CglteSAkYWJzX2ZpbGUgPSBGaWxlOjpTcGVjLT5yZWwyYWJzKCRfYXV0aG9yc19wcm9nKTsKCSRfYXV0aG9yc19wcm9nID0gIiciIC4gJGFic19maWxlIC4gIiciIGlmIC14ICRhYnNfZmlsZTsKfQoKdW5sZXNzICgkY21kID1+IC9eKD86Y2xvbmV8aW5pdHxtdWx0aS1pbml0fGNvbW1pdC1kaWZmKSQvKSB7CglHaXQ6OlNWTjo6TWlncmF0aW9uOjptaWdyYXRpb25fY2hlY2soKTsKfQpHaXQ6OlNWTjo6aW5pdF92YXJzKCk7CmV2YWwgewoJR2l0OjpTVk46OnZlcmlmeV9yZW1vdGVzX3Nhbml0eSgpOwoJJGNtZHskY21kfS0+WzBdLT4oQEFSR1YpOwoJcG9zdF9mZXRjaF9jaGVja291dCgpOwp9OwpmYXRhbCAkQCBpZiAkQDsKZXhpdCAwOwoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgcHJpbWFyeSBmdW5jdGlvbnMgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwpzdWIgdXNhZ2UgewoJbXkgJGV4aXQgPSBzaGlmdCB8fCAwOwoJbXkgJGZkID0gJGV4aXQgPyBcKlNUREVSUiA6IFwqU1RET1VUOwoJcHJpbnQgJGZkIDw8IiI7CmdpdC1zdm4gLSBiaWRpcmVjdGlvbmFsIG9wZXJhdGlvbnMgYmV0d2VlbiBhIHNpbmdsZSBTdWJ2ZXJzaW9uIHRyZWUgYW5kIGdpdAp1c2FnZTogZ2l0IHN2biA8Y29tbWFuZD4gW29wdGlvbnNdIFthcmd1bWVudHNdXG4KCglwcmludCAkZmQgIkF2YWlsYWJsZSBjb21tYW5kczpcbiIgdW5sZXNzICRjbWQ7CgoJZm9yZWFjaCAoc29ydCBrZXlzICVjbWQpIHsKCQluZXh0IGlmICRjbWQgJiYgJGNtZCBuZSAkXzsKCQluZXh0IGlmIC9ebXVsdGktLzsgIyBkb24ndCBzaG93IGRlcHJlY2F0ZWQgY29tbWFuZHMKCQlwcmludCAkZmQgJyAgJyxwYWNrKCdBMTcnLCRfKSwkY21keyRffS0+WzFdLCJcbiI7CgkJZm9yZWFjaCAoc29ydCBrZXlzICV7JGNtZHskX30tPlsyXX0pIHsKCQkJIyBtaXhlZC1jYXNlIG9wdGlvbnMgYXJlIGZvciAuZ2l0L2NvbmZpZyBvbmx5CgkJCW5leHQgaWYgL1tBLVpdLyAmJiAvXlthLXpdKyQvaTsKCQkJIyBwcmludHMgb3V0IGFyZ3VtZW50cyBhcyB0aGV5IHNob3VsZCBiZSBwYXNzZWQ6CgkJCW15ICR4ID0gcyNbOj1dcyQjIyA/ICc8YXJnPicgOiBzI1s6PV1pJCMjID8gJzxudW0+JyA6ICcnOwoJCQlwcmludCAkZmQgJyAnIHggMjEsIGpvaW4oJywgJywgbWFwIHsgbGVuZ3RoICRfID4gMSA/CgkJCQkJCQkiLS0kXyIgOiAiLSRfIiB9CgkJCQkJCXNwbGl0IC9cfC8sJF8pLCIgJHhcbiI7CgkJfQoJfQoJcHJpbnQgJGZkIDw8IiI7ClxuR0lUX1NWTl9JRCBtYXkgYmUgc2V0IGluIHRoZSBlbnZpcm9ubWVudCBvciB2aWEgdGhlIC0taWQvLWkgc3dpdGNoIHRvIGFuCmFyYml0cmFyeSBpZGVudGlmaWVyIGlmIHlvdSdyZSB0cmFja2luZyBtdWx0aXBsZSBTVk4gYnJhbmNoZXMvcmVwb3NpdG9yaWVzIGluCm9uZSBnaXQgcmVwb3NpdG9yeSBhbmQgd2FudCB0byBrZWVwIHRoZW0gc2VwYXJhdGUuICBTZWUgZ2l0LXN2bigxKSBmb3IgbW9yZQppbmZvcm1hdGlvbi4KCglleGl0ICRleGl0Owp9CgpzdWIgdmVyc2lvbiB7Cgk6Ol9yZXFfc3ZuKCk7CglwcmludCAiZ2l0LXN2biB2ZXJzaW9uICRWRVJTSU9OIChzdm4gJFNWTjo6Q29yZTo6VkVSU0lPTilcbiI7CglleGl0IDA7Cn0KCnN1YiBhc2sgewoJbXkgKCRwcm9tcHQsICVhcmcpID0gQF87CglteSAkdmFsaWRfcmUgPSAkYXJne3ZhbGlkX3JlfTsKCW15ICRkZWZhdWx0ID0gJGFyZ3tkZWZhdWx0fTsKCW15ICRyZXNwOwoJbXkgJGkgPSAwOwoJdGVybV9pbml0KCkgdW5sZXNzICR0ZXJtOwoKCWlmICggISggZGVmaW5lZCgkdGVybS0+SU4pCiAgICAgICAgICAgICYmIGRlZmluZWQoIGZpbGVubygkdGVybS0+SU4pICkKICAgICAgICAgICAgJiYgZGVmaW5lZCggJHRlcm0tPk9VVCApCiAgICAgICAgICAgICYmIGRlZmluZWQoIGZpbGVubygkdGVybS0+T1VUKSApICkgKXsKCQlyZXR1cm4gZGVmaW5lZCgkZGVmYXVsdCkgPyAkZGVmYXVsdCA6IHVuZGVmOwoJfQoKCXdoaWxlICgkaSsrIDwgMTApIHsKCQkkcmVzcCA9ICR0ZXJtLT5yZWFkbGluZSgkcHJvbXB0KTsKCQlpZiAoIWRlZmluZWQgJHJlc3ApIHsgIyBFT0YKCQkJcHJpbnQgIlxuIjsKCQkJcmV0dXJuIGRlZmluZWQgJGRlZmF1bHQgPyAkZGVmYXVsdCA6IHVuZGVmOwoJCX0KCQlpZiAoJHJlc3AgZXEgJycgYW5kIGRlZmluZWQgJGRlZmF1bHQpIHsKCQkJcmV0dXJuICRkZWZhdWx0OwoJCX0KCQlpZiAoIWRlZmluZWQgJHZhbGlkX3JlIG9yICRyZXNwID1+IC8kdmFsaWRfcmUvKSB7CgkJCXJldHVybiAkcmVzcDsKCQl9Cgl9CglyZXR1cm4gdW5kZWY7Cn0KCnN1YiBkb19naXRfaW5pdF9kYiB7Cgl1bmxlc3MgKC1kICRFTlZ7R0lUX0RJUn0pIHsKCQlteSBAaW5pdF9kYiA9ICgnaW5pdCcpOwoJCXB1c2ggQGluaXRfZGIsICItLXRlbXBsYXRlPSRfdGVtcGxhdGUiIGlmIGRlZmluZWQgJF90ZW1wbGF0ZTsKCQlpZiAoZGVmaW5lZCAkX3NoYXJlZCkgewoJCQlpZiAoJF9zaGFyZWQgPX4gL1thLXpdLykgewoJCQkJcHVzaCBAaW5pdF9kYiwgIi0tc2hhcmVkPSRfc2hhcmVkIjsKCQkJfSBlbHNlIHsKCQkJCXB1c2ggQGluaXRfZGIsICItLXNoYXJlZCI7CgkJCX0KCQl9CgkJY29tbWFuZF9ub2lzeShAaW5pdF9kYik7CgkJJF9yZXBvc2l0b3J5ID0gR2l0LT5yZXBvc2l0b3J5KFJlcG9zaXRvcnkgPT4gIi5naXQiKTsKCX0KCW15ICRzZXQ7CglteSAkcGZ4ID0gInN2bi1yZW1vdGUuJEdpdDo6U1ZOOjpkZWZhdWx0X3JlcG9faWQiOwoJZm9yZWFjaCBteSAkaSAoa2V5cyAlaWN2KSB7CgkJZGllICInJHNldCcgYW5kICckaScgY2Fubm90IGJvdGggYmUgc2V0XG4iIGlmICRzZXQ7CgkJbmV4dCB1bmxlc3MgZGVmaW5lZCAkaWN2eyRpfTsKCQljb21tYW5kX25vaXN5KCdjb25maWcnLCAiJHBmeC4kaSIsICRpY3Z7JGl9KTsKCQkkc2V0ID0gJGk7Cgl9CglteSAkaWdub3JlX3BhdGhzX3JlZ2V4ID0gXCRHaXQ6OlNWTjo6RmV0Y2hlcjo6X2lnbm9yZV9yZWdleDsKCWNvbW1hbmRfbm9pc3koJ2NvbmZpZycsICIkcGZ4Lmlnbm9yZS1wYXRocyIsICQkaWdub3JlX3BhdGhzX3JlZ2V4KQoJCWlmIGRlZmluZWQgJCRpZ25vcmVfcGF0aHNfcmVnZXg7CglteSAkaW5jbHVkZV9wYXRoc19yZWdleCA9IFwkR2l0OjpTVk46OkZldGNoZXI6Ol9pbmNsdWRlX3JlZ2V4OwoJY29tbWFuZF9ub2lzeSgnY29uZmlnJywgIiRwZnguaW5jbHVkZS1wYXRocyIsICQkaW5jbHVkZV9wYXRoc19yZWdleCkKCQlpZiBkZWZpbmVkICQkaW5jbHVkZV9wYXRoc19yZWdleDsKCW15ICRpZ25vcmVfcmVmc19yZWdleCA9IFwkR2l0OjpTVk46OlJhOjpfaWdub3JlX3JlZnNfcmVnZXg7Cgljb21tYW5kX25vaXN5KCdjb25maWcnLCAiJHBmeC5pZ25vcmUtcmVmcyIsICQkaWdub3JlX3JlZnNfcmVnZXgpCgkJaWYgZGVmaW5lZCAkJGlnbm9yZV9yZWZzX3JlZ2V4OwoKCWlmIChkZWZpbmVkICRHaXQ6OlNWTjo6RmV0Y2hlcjo6X3ByZXNlcnZlX2VtcHR5X2RpcnMpIHsKCQlteSAkZm5hbWUgPSBcJEdpdDo6U1ZOOjpGZXRjaGVyOjpfcGxhY2Vob2xkZXJfZmlsZW5hbWU7CgkJY29tbWFuZF9ub2lzeSgnY29uZmlnJywgIiRwZngucHJlc2VydmUtZW1wdHktZGlycyIsICd0cnVlJyk7CgkJY29tbWFuZF9ub2lzeSgnY29uZmlnJywgIiRwZngucGxhY2Vob2xkZXItZmlsZW5hbWUiLCAkJGZuYW1lKTsKCX0KfQoKc3ViIGluaXRfc3ViZGlyIHsKCW15ICRyZXBvX3BhdGggPSBzaGlmdCBvciByZXR1cm47Cglta3BhdGgoWyRyZXBvX3BhdGhdKSB1bmxlc3MgLWQgJHJlcG9fcGF0aDsKCWNoZGlyICRyZXBvX3BhdGggb3IgZGllICJDb3VsZG4ndCBjaGRpciB0byAkcmVwb19wYXRoOiAkIVxuIjsKCSRFTlZ7R0lUX0RJUn0gPSAnLmdpdCc7CgkkX3JlcG9zaXRvcnkgPSBHaXQtPnJlcG9zaXRvcnkoUmVwb3NpdG9yeSA9PiAkRU5We0dJVF9ESVJ9KTsKfQoKc3ViIGNtZF9jbG9uZSB7CglteSAoJHVybCwgJHBhdGgpID0gQF87CglpZiAoISR1cmwpIHsKCQlkaWUgIlNWTiByZXBvc2l0b3J5IGxvY2F0aW9uIHJlcXVpcmVkICIsCgkJICAgICJhcyBhIGNvbW1hbmQtbGluZSBhcmd1bWVudFxuIjsKCX0gZWxzaWYgKCFkZWZpbmVkICRwYXRoICYmCgkgICAgKGRlZmluZWQgJF90cnVuayB8fCBAX2JyYW5jaGVzIHx8IEBfdGFncyB8fAoJICAgICBkZWZpbmVkICRfc3RkbGF5b3V0KSAmJgoJICAgICR1cmwgIX4gbSNeW2EtelwrXSs6Ly8jKSB7CgkJJHBhdGggPSAkdXJsOwoJfQoJJHBhdGggPSBiYXNlbmFtZSgkdXJsKSBpZiAhZGVmaW5lZCAkcGF0aCB8fCAhbGVuZ3RoICRwYXRoOwoJbXkgJGF1dGhvcnNfYWJzb2x1dGUgPSAkX2F1dGhvcnMgPyBGaWxlOjpTcGVjLT5yZWwyYWJzKCRfYXV0aG9ycykgOiAiIjsKCWNtZF9pbml0KCR1cmwsICRwYXRoKTsKCWNvbW1hbmRfb25lbGluZSgnY29uZmlnJywgJ3N2bi5hdXRob3JzZmlsZScsICRhdXRob3JzX2Fic29sdXRlKQoJICAgIGlmICRfYXV0aG9yczsKCUdpdDo6U1ZOOjpmZXRjaF9hbGwoJEdpdDo6U1ZOOjpkZWZhdWx0X3JlcG9faWQpOwp9CgpzdWIgY21kX2luaXQgewoJaWYgKGRlZmluZWQgJF9zdGRsYXlvdXQpIHsKCQkkX3RydW5rID0gJ3RydW5rJyBpZiAoIWRlZmluZWQgJF90cnVuayk7CgkJQF90YWdzID0gJ3RhZ3MnIGlmICghIEBfdGFncyk7CgkJQF9icmFuY2hlcyA9ICdicmFuY2hlcycgaWYgKCEgQF9icmFuY2hlcyk7Cgl9CglpZiAoZGVmaW5lZCAkX3RydW5rIHx8IEBfYnJhbmNoZXMgfHwgQF90YWdzKSB7CgkJcmV0dXJuIGNtZF9tdWx0aV9pbml0KEBfKTsKCX0KCW15ICR1cmwgPSBzaGlmdCBvciBkaWUgIlNWTiByZXBvc2l0b3J5IGxvY2F0aW9uIHJlcXVpcmVkICIsCgkgICAgICAgICAgICAgICAgICAgICAgICJhcyBhIGNvbW1hbmQtbGluZSBhcmd1bWVudFxuIjsKCSR1cmwgPSBjYW5vbmljYWxpemVfdXJsKCR1cmwpOwoJaW5pdF9zdWJkaXIoQF8pOwoJZG9fZ2l0X2luaXRfZGIoKTsKCglpZiAoJEdpdDo6U1ZOOjpfbWluaW1pemVfdXJsIGVxICd1bnNldCcpIHsKCQkkR2l0OjpTVk46Ol9taW5pbWl6ZV91cmwgPSAwOwoJfQoKCUdpdDo6U1ZOLT5pbml0KCR1cmwpOwp9CgpzdWIgY21kX2ZldGNoIHsKCWlmIChncmVwIC9eXGQrPS4vLCBAXykgewoJCWRpZSAiJzxyZXY+PTxjb21taXQ+JyBmZXRjaCBhcmd1bWVudHMgYXJlICIsCgkJICAgICJubyBsb25nZXIgc3VwcG9ydGVkLlxuIjsKCX0KCW15ICgkcmVtb3RlKSA9IEBfOwoJaWYgKEBfID4gMSkgewoJCWRpZSAidXNhZ2U6ICQwIGZldGNoIFstLWFsbF0gWy0tcGFyZW50XSBbc3ZuLXJlbW90ZV1cbiI7Cgl9CgkkR2l0OjpTVk46Om5vX3JldXNlX2V4aXN0aW5nID0gdW5kZWY7CglpZiAoJF9mZXRjaF9wYXJlbnQpIHsKCQlteSAoJHVybCwgJHJldiwgJHV1aWQsICRncykgPSB3b3JraW5nX2hlYWRfaW5mbygnSEVBRCcpOwoJCXVubGVzcyAoJGdzKSB7CgkJCWRpZSAiVW5hYmxlIHRvIGRldGVybWluZSB1cHN0cmVhbSBTVk4gaW5mb3JtYXRpb24gZnJvbSAiLAoJCQkgICAgIndvcmtpbmcgdHJlZSBoaXN0b3J5XG4iOwoJCX0KCSAgICAgICAgIyBqdXN0IGZldGNoLCBkb24ndCBjaGVja291dC4KCQkkX25vX2NoZWNrb3V0ID0gJ3RydWUnOwoJCSRfZmV0Y2hfYWxsID8gJGdzLT5mZXRjaF9hbGwgOiAkZ3MtPmZldGNoOwoJfSBlbHNpZiAoJF9mZXRjaF9hbGwpIHsKCQljbWRfbXVsdGlfZmV0Y2goKTsKCX0gZWxzZSB7CgkJJHJlbW90ZSB8fD0gJEdpdDo6U1ZOOjpkZWZhdWx0X3JlcG9faWQ7CgkJR2l0OjpTVk46OmZldGNoX2FsbCgkcmVtb3RlLCBHaXQ6OlNWTjo6cmVhZF9hbGxfcmVtb3RlcygpKTsKCX0KfQoKc3ViIGNtZF9zZXRfdHJlZSB7CglteSAoQGNvbW1pdHMpID0gQF87CglpZiAoJF9zdGRpbiB8fCAhQGNvbW1pdHMpIHsKCQlwcmludCAiUmVhZGluZyBmcm9tIHN0ZGluLi4uXG4iOwoJCUBjb21taXRzID0gKCk7CgkJd2hpbGUgKDxTVERJTj4pIHsKCQkJaWYgKC9cYigkb2lkX3Nob3J0KVxiL28pIHsKCQkJCXVuc2hpZnQgQGNvbW1pdHMsICQxOwoJCQl9CgkJfQoJfQoJbXkgQHJldnM7Cglmb3JlYWNoIG15ICRjIChAY29tbWl0cykgewoJCW15IEB0bXAgPSBjb21tYW5kKCdyZXYtcGFyc2UnLCRjKTsKCQlpZiAoc2NhbGFyIEB0bXAgPT0gMSkgewoJCQlwdXNoIEByZXZzLCAkdG1wWzBdOwoJCX0gZWxzaWYgKHNjYWxhciBAdG1wID4gMSkgewoJCQlwdXNoIEByZXZzLCByZXZlcnNlKGNvbW1hbmQoJ3Jldi1saXN0JyxAdG1wKSk7CgkJfSBlbHNlIHsKCQkJZmF0YWwgIkZhaWxlZCB0byByZXYtcGFyc2UgJGMiOwoJCX0KCX0KCW15ICRncyA9IEdpdDo6U1ZOLT5uZXc7CglteSAoJHJfbGFzdCwgJGNtdF9sYXN0KSA9ICRncy0+bGFzdF9yZXZfY29tbWl0OwoJJGdzLT5mZXRjaDsKCWlmIChkZWZpbmVkICRncy0+e2xhc3RfcmV2fSAmJiAkcl9sYXN0ICE9ICRncy0+e2xhc3RfcmV2fSkgewoJCWZhdGFsICJUaGVyZSBhcmUgbmV3IHJldmlzaW9ucyB0aGF0IHdlcmUgZmV0Y2hlZCAiLAoJCSAgICAgICJhbmQgbmVlZCB0byBiZSBtZXJnZWQgKG9yIGFja25vd2xlZGdlZCkgIiwKCQkgICAgICAiYmVmb3JlIGNvbW1pdHRpbmcuXG5sYXN0IHJldjogJHJfbGFzdFxuIiwKCQkgICAgICAiIGN1cnJlbnQ6ICRncy0+e2xhc3RfcmV2fSI7Cgl9CgkkZ3MtPnNldF90cmVlKCRfKSBmb3JlYWNoIEByZXZzOwoJcHJpbnQgIkRvbmUgY29tbWl0dGluZyAiLHNjYWxhciBAcmV2cywiIHJldmlzaW9ucyB0byBTVk5cbiI7Cgl1bmxpbmsgJGdzLT57aW5kZXh9Owp9CgpzdWIgc3BsaXRfbWVyZ2VfaW5mb19yYW5nZSB7CglteSAoJHJhbmdlKSA9IEBfOwoJaWYgKCRyYW5nZSA9fiAvKFxkKyktKFxkKykvKSB7CgkJcmV0dXJuIChpbnQoJDEpLCBpbnQoJDIpKTsKCX0gZWxzZSB7CgkJcmV0dXJuIChpbnQoJHJhbmdlKSwgaW50KCRyYW5nZSkpOwoJfQp9CgpzdWIgY29tYmluZV9yYW5nZXMgewoJbXkgKCRpbikgPSBAXzsKCglteSBAZm51bXMgPSAoKTsKCW15IEBhcnIgPSBzcGxpdCgvLC8sICRpbik7Cglmb3IgbXkgJGVsZW1lbnQgKEBhcnIpIHsKCQlteSAoJHN0YXJ0LCAkZW5kKSA9IHNwbGl0X21lcmdlX2luZm9fcmFuZ2UoJGVsZW1lbnQpOwoJCXB1c2ggQGZudW1zLCAkc3RhcnQ7Cgl9CgoJbXkgQHNvcnRlZCA9IEBhcnIgWyBzb3J0IHsKCQkkZm51bXNbJGFdIDw9PiAkZm51bXNbJGJdCgl9IDAuLiQjYXJyIF07CgoJbXkgQHJldHVybiA9ICgpOwoJbXkgJGxhc3QgPSAtMTsKCW15ICRmaXJzdCA9IC0xOwoJZm9yIG15ICRlbGVtZW50IChAc29ydGVkKSB7CgkJbXkgKCRzdGFydCwgJGVuZCkgPSBzcGxpdF9tZXJnZV9pbmZvX3JhbmdlKCRlbGVtZW50KTsKCgkJaWYgKCRsYXN0ID09IC0xKSB7CgkJCSRmaXJzdCA9ICRzdGFydDsKCQkJJGxhc3QgPSAkZW5kOwoJCQluZXh0OwoJCX0KCQlpZiAoJHN0YXJ0IDw9ICRsYXN0KzEpIHsKCQkJaWYgKCRlbmQgPiAkbGFzdCkgewoJCQkJJGxhc3QgPSAkZW5kOwoJCQl9CgkJCW5leHQ7CgkJfQoJCWlmICgkZmlyc3QgPT0gJGxhc3QpIHsKCQkJcHVzaCBAcmV0dXJuLCAiJGZpcnN0IjsKCQl9IGVsc2UgewoJCQlwdXNoIEByZXR1cm4sICIkZmlyc3QtJGxhc3QiOwoJCX0KCQkkZmlyc3QgPSAkc3RhcnQ7CgkJJGxhc3QgPSAkZW5kOwoJfQoKCWlmICgkZmlyc3QgIT0gLTEpIHsKCQlpZiAoJGZpcnN0ID09ICRsYXN0KSB7CgkJCXB1c2ggQHJldHVybiwgIiRmaXJzdCI7CgkJfSBlbHNlIHsKCQkJcHVzaCBAcmV0dXJuLCAiJGZpcnN0LSRsYXN0IjsKCQl9Cgl9CgoJcmV0dXJuIGpvaW4oJywnLCBAcmV0dXJuKTsKfQoKc3ViIG1lcmdlX3JldnNfaW50b19oYXNoIHsKCW15ICgkaGFzaCwgJG1pbmZvKSA9IEBfOwoJbXkgQGxpbmVzID0gc3BsaXQoJyAnLCAkbWluZm8pOwoKCWZvciBteSAkbGluZSAoQGxpbmVzKSB7CgkJbXkgKCRicmFuY2hwYXRoLCAkcmV2cykgPSBzcGxpdCgvOi8sICRsaW5lKTsKCgkJaWYgKGV4aXN0cygkaGFzaC0+eyRicmFuY2hwYXRofSkpIHsKCQkJIyBNZXJnZSB0aGUgdHdvIHJldmlzaW9uIHNldHMKCQkJbXkgJGNvbWJpbmVkID0gIiRoYXNoLT57JGJyYW5jaHBhdGh9LCRyZXZzIjsKCQkJJGhhc2gtPnskYnJhbmNocGF0aH0gPSBjb21iaW5lX3JhbmdlcygkY29tYmluZWQpOwoJCX0gZWxzZSB7CgkJCSMgSnVzdCBkbyByYW5nZSBjb21iaW5pbmcgZm9yIGNvbnNvbGlkYXRpb24KCQkJJGhhc2gtPnskYnJhbmNocGF0aH0gPSBjb21iaW5lX3JhbmdlcygkcmV2cyk7CgkJfQoJfQp9CgpzdWIgbWVyZ2VfbWVyZ2VfaW5mbyB7CglteSAoJG1lcmdlaW5mb19vbmUsICRtZXJnZWluZm9fdHdvLCAkaWdub3JlX2JyYW5jaCkgPSBAXzsKCW15ICVyZXN1bHRfaGFzaCA9ICgpOwoKCW1lcmdlX3JldnNfaW50b19oYXNoKFwlcmVzdWx0X2hhc2gsICRtZXJnZWluZm9fb25lKTsKCW1lcmdlX3JldnNfaW50b19oYXNoKFwlcmVzdWx0X2hhc2gsICRtZXJnZWluZm9fdHdvKTsKCglkZWxldGUgJHJlc3VsdF9oYXNoeyRpZ25vcmVfYnJhbmNofSBpZiAkaWdub3JlX2JyYW5jaDsKCglteSAkcmVzdWx0ID0gJyc7CgkjIFNvcnQgYmVsb3cgaXMgZm9yIGNvbnNpc3RlbmN5J3Mgc2FrZQoJZm9yIG15ICRicmFuY2huYW1lIChzb3J0IGtleXMoJXJlc3VsdF9oYXNoKSkgewoJCW15ICRyZXZsaXN0ID0gJHJlc3VsdF9oYXNoeyRicmFuY2huYW1lfTsKCQkkcmVzdWx0IC49ICIkYnJhbmNobmFtZTokcmV2bGlzdFxuIgoJfQoJcmV0dXJuICRyZXN1bHQ7Cn0KCnN1YiBwb3B1bGF0ZV9tZXJnZV9pbmZvIHsKCW15ICgkZCwgJGdzLCAkdXVpZCwgJGxpbmVhcl9yZWZzLCAkcmV3cml0dGVuX3BhcmVudCkgPSBAXzsKCglteSAlcGFyZW50c2hhc2g7CglyZWFkX2NvbW1pdF9wYXJlbnRzKFwlcGFyZW50c2hhc2gsICRkKTsKCW15IEBwYXJlbnRzID0gQHskcGFyZW50c2hhc2h7JGR9fTsKCWlmICgkI3BhcmVudHMgPiAwKSB7CgkJIyBNZXJnZSBjb21taXQKCQlteSAkYWxsX3BhcmVudHNfb2sgPSAxOwoJCW15ICRhZ2dyZWdhdGVfbWVyZ2VpbmZvID0gJyc7CgkJbXkgJHJvb3R1cmwgPSAkZ3MtPnJlcG9zX3Jvb3Q7CgkJbXkgKCR0YXJnZXRfYnJhbmNoKSA9ICRncy0+ZnVsbF9wdXNodXJsID1+IC9eXFEkcm9vdHVybFxFKC4qKS87CgoJCWlmIChkZWZpbmVkKCRyZXdyaXR0ZW5fcGFyZW50KSkgewoJCQkjIFJlcGxhY2UgZmlyc3QgcGFyZW50IHdpdGggbmV3bHktcmV3cml0dGVuIHZlcnNpb24KCQkJc2hpZnQgQHBhcmVudHM7CgkJCXVuc2hpZnQgQHBhcmVudHMsICRyZXdyaXR0ZW5fcGFyZW50OwoJCX0KCgkJZm9yZWFjaCBteSAkcGFyZW50IChAcGFyZW50cykgewoJCQlteSAoJGJyYW5jaHVybCwgJHN2bnJldiwgJHBhcnV1aWQpID0KCQkJCWNtdF9tZXRhZGF0YSgkcGFyZW50KTsKCgkJCXVubGVzcyAoZGVmaW5lZCgkc3ZucmV2KSkgewoJCQkJIyBTaG91bGQgaGF2ZSBiZWVuIGNhdWdodCBiZSBwcmVmbGlnaHQgY2hlY2sKCQkJCWZhdGFsICJtZXJnZSBjb21taXQgJGQgaGFzIGFuY2VzdG9yICRwYXJlbnQsIGJ1dCB0aGF0IGNoYW5nZSAiCiAgICAgICAgICAgICAgICAgICAgIC4iZG9lcyBub3QgaGF2ZSBnaXQtc3ZuIG1ldGFkYXRhISI7CgkJCX0KCQkJdW5sZXNzICgkYnJhbmNodXJsID1+IC9eXFEkcm9vdHVybFxFKC4qKS8pIHsKCQkJCWZhdGFsICJjb21taXQgJHBhcmVudCBnaXQtc3ZuIG1ldGFkYXRhIGNoYW5nZWQgbWlkLXJ1biEiOwoJCQl9CgkJCW15ICRicmFuY2hwYXRoID0gJDE7CgoJCQlteSAkcmEgPSBHaXQ6OlNWTjo6UmEtPm5ldygkYnJhbmNodXJsKTsKCQkJbXkgKHVuZGVmLCB1bmRlZiwgJHByb3BzKSA9CgkJCQkkcmEtPmdldF9kaXIoY2Fub25pY2FsaXplX3BhdGgoIi4iKSwgJHN2bnJldik7CgkJCW15ICRwYXJfbWVyZ2VpbmZvID0gJHByb3BzLT57J3N2bjptZXJnZWluZm8nfTsKCQkJdW5sZXNzIChkZWZpbmVkICRwYXJfbWVyZ2VpbmZvKSB7CgkJCQkkcGFyX21lcmdlaW5mbyA9ICcnOwoJCQl9CgkJCSMgTWVyZ2UgcHJldmlvdXMgbWVyZ2VpbmZvIHZhbHVlcwoJCQkkYWdncmVnYXRlX21lcmdlaW5mbyA9CgkJCQltZXJnZV9tZXJnZV9pbmZvKCRhZ2dyZWdhdGVfbWVyZ2VpbmZvLAoJCQkJCQkJCSRwYXJfbWVyZ2VpbmZvLAoJCQkJCQkJCSR0YXJnZXRfYnJhbmNoKTsKCgkJCW5leHQgaWYgJHBhcmVudCBlcSAkcGFyZW50c1swXTsgIyBTa2lwIGZpcnN0IHBhcmVudAoJCQkjIEFkZCBuZXcgY2hhbmdlcyBiZWluZyBwbGFjZWQgaW4gdHJlZSBieSBtZXJnZQoJCQlteSBAY21kID0gKHF3L3Jldi1saXN0IC0tcmV2ZXJzZS8sCgkJCQkJICAgJHBhcmVudCwgcXcvLS1ub3QvKTsKCQkJZm9yZWFjaCBteSAkcGFyIChAcGFyZW50cykgewoJCQkJdW5sZXNzICgkcGFyIGVxICRwYXJlbnQpIHsKCQkJCQlwdXNoIEBjbWQsICRwYXI7CgkJCQl9CgkJCX0KCQkJbXkgQHJldnNpbiA9ICgpOwoJCQlteSAoJHJldmxpc3QsICRjdHgpID0gY29tbWFuZF9vdXRwdXRfcGlwZShAY21kKTsKCQkJd2hpbGUgKDwkcmV2bGlzdD4pIHsKCQkJCW15ICRpcmV2ID0gJF87CgkJCQljaG9tcCAkaXJldjsKCQkJCW15ICh1bmRlZiwgJGNzdm5yZXYsIHVuZGVmKSA9CgkJCQkJY210X21ldGFkYXRhKCRpcmV2KTsKCQkJCXVubGVzcyAoZGVmaW5lZCAkY3N2bnJldikgewoJCQkJCSMgQSBjaGlsZCBpcyBtaXNzaW5nIFNWTiBhbm5vdGF0aW9ucy4uLgoJCQkJCSMgdGhpcyBtaWdodCBiZSBPSywgb3IgbWlnaHQgbm90IGJlLgoJCQkJCXdhcm4gIlc6Y2hpbGQgJGlyZXYgaXMgbWVyZ2VkIGludG8gcmV2aXNpb24gIgoJCQkJCQkgLiIkZCBidXQgZG9lcyBub3QgaGF2ZSBnaXQtc3ZuIG1ldGFkYXRhLiAiCgkJCQkJCSAuIlRoaXMgbWVhbnMgZ2l0LXN2biBjYW5ub3QgZGV0ZXJtaW5lIHRoZSAiCgkJCQkJCSAuInN2biByZXZpc2lvbiBudW1iZXJzIHRvIHBsYWNlIGludG8gdGhlICIKCQkJCQkJIC4ic3ZuOm1lcmdlaW5mbyBwcm9wZXJ0eS4gWW91IG11c3QgZW5zdXJlICIKCQkJCQkJIC4iYSBicmFuY2ggaXMgZW50aXJlbHkgY29tbWl0dGVkIHRvICIKCQkJCQkJIC4iU1ZOIGJlZm9yZSBtZXJnaW5nIGl0IGluIG9yZGVyIGZvciAiCgkJCQkJCSAuInN2bjptZXJnZWluZm8gcG9wdWxhdGlvbiB0byBmdW5jdGlvbiAiCgkJCQkJCSAuInByb3Blcmx5IjsKCQkJCX0KCQkJCXB1c2ggQHJldnNpbiwgJGNzdm5yZXY7CgkJCX0KCQkJY29tbWFuZF9jbG9zZV9waXBlKCRyZXZsaXN0LCAkY3R4KTsKCgkJCWxhc3QgdW5sZXNzICRhbGxfcGFyZW50c19vazsKCgkJCSMgV2Ugbm93IGhhdmUgYSBsaXN0IG9mIGFsbCBTVk4gcmV2bm9zIHdoaWNoIGFyZQoJCQkjIG1lcmdlZCBieSB0aGlzIHBhcnRpY3VsYXIgcGFyZW50LiBJbnRlZ3JhdGUgdGhlbS4KCQkJbmV4dCBpZiAkI3JldnNpbiA9PSAtMTsKCQkJbXkgJG5ld21lcmdlaW5mbyA9ICIkYnJhbmNocGF0aDoiIC4gam9pbignLCcsIEByZXZzaW4pOwoJCQkkYWdncmVnYXRlX21lcmdlaW5mbyA9CgkJCQltZXJnZV9tZXJnZV9pbmZvKCRhZ2dyZWdhdGVfbWVyZ2VpbmZvLAoJCQkJCQkJCSRuZXdtZXJnZWluZm8sCgkJCQkJCQkJJHRhcmdldF9icmFuY2gpOwoJCX0KCQlpZiAoJGFsbF9wYXJlbnRzX29rIGFuZCAkYWdncmVnYXRlX21lcmdlaW5mbykgewoJCQlyZXR1cm4gJGFnZ3JlZ2F0ZV9tZXJnZWluZm87CgkJfQoJfQoKCXJldHVybiB1bmRlZjsKfQoKc3ViIGRjb21taXRfcmViYXNlIHsKCW15ICgkaXNfbGFzdCwgJGN1cnJlbnQsICRmZXRjaGVkX3JlZiwgJHN2bl9lcnJvcikgPSBAXzsKCW15IEBkaWZmOwoKCWlmICgkc3ZuX2Vycm9yKSB7CgkJcHJpbnQgU1RERVJSICJcbkVSUk9SIGZyb20gU1ZOOlxuIiwKCQkJCSRzdm5fZXJyb3ItPmV4cGFuZGVkX21lc3NhZ2UsICJcbiI7Cgl9Cgl1bmxlc3MgKCRfbm9fcmViYXNlKSB7CgkJIyB3ZSBhbHdheXMgd2FudCB0byByZWJhc2UgYWdhaW5zdCB0aGUgY3VycmVudCBIRUFELAoJCSMgbm90IGFueSBoZWFkIHRoYXQgd2FzIHBhc3NlZCB0byB1cwoJCUBkaWZmID0gY29tbWFuZCgnZGlmZi10cmVlJywgJGN1cnJlbnQsCgkgICAgICAgICAgICAgICAgICAgJGZldGNoZWRfcmVmLCAnLS0nKTsKCQlteSBAZmluaXNoOwoJCWlmIChAZGlmZikgewoJCQlAZmluaXNoID0gcmViYXNlX2NtZCgpOwoJCQlwcmludCBTVERFUlIgIlc6ICRjdXJyZW50IGFuZCAiLCAkZmV0Y2hlZF9yZWYsCgkJCSAgICAgICAgICAgICAiIGRpZmZlciwgdXNpbmcgQGZpbmlzaDpcbiIsCgkJCSAgICAgICAgICAgICBqb2luKCJcbiIsIEBkaWZmKSwgIlxuIjsKCQl9IGVsc2lmICgkaXNfbGFzdCkgewoJCQlwcmludCAiTm8gY2hhbmdlcyBiZXR3ZWVuICIsICRjdXJyZW50LCAiIGFuZCAiLAoJCQkgICAgICAkZmV0Y2hlZF9yZWYsCgkJCSAgICAgICJcblJlc2V0dGluZyB0byB0aGUgbGF0ZXN0ICIsCgkJCSAgICAgICRmZXRjaGVkX3JlZiwgIlxuIjsKCQkJQGZpbmlzaCA9IHF3L3Jlc2V0IC0tbWl4ZWQvOwoJCX0KCQljb21tYW5kX25vaXN5KEBmaW5pc2gsICRmZXRjaGVkX3JlZikgaWYgQGZpbmlzaDsKCX0KCWlmICgkc3ZuX2Vycm9yKSB7CgkJZGllICJFUlJPUjogTm90IGFsbCBjaGFuZ2VzIGhhdmUgYmVlbiBjb21taXR0ZWQgaW50byBTVk4iCgkJCS4oJF9ub19yZWJhc2UgPyAiLlxuIiA6ICIsIGhvd2V2ZXIgdGhlIGNvbW1pdHRlZFxuIgoJCQkuIm9uZXMgKGlmIGFueSkgc2VlbSB0byBiZSBzdWNjZXNzZnVsbHkgaW50ZWdyYXRlZCAiCgkJCS4iaW50byB0aGUgd29ya2luZyB0cmVlLlxuIikKCQkJLiJQbGVhc2Ugc2VlIHRoZSBhYm92ZSBtZXNzYWdlcyBmb3IgZGV0YWlscy5cbiI7Cgl9CglyZXR1cm4gQGRpZmY7Cn0KCnN1YiBjbWRfZGNvbW1pdCB7CglteSAkaGVhZCA9IHNoaWZ0OwoJY29tbWFuZF9ub2lzeShxdy91cGRhdGUtaW5kZXggLS1yZWZyZXNoLyk7CglnaXRfY21kX3RyeSB7IGNvbW1hbmRfb25lbGluZShxdy9kaWZmLWluZGV4IC0tcXVpZXQgSEVBRCAtLS8pIH0KCQknQ2Fubm90IGRjb21taXQgd2l0aCBhIGRpcnR5IGluZGV4LiAgQ29tbWl0IHlvdXIgY2hhbmdlcyBmaXJzdCwgJwoJCS4gIm9yIHN0YXNoIHRoZW0gd2l0aCBgZ2l0IHN0YXNoJy5cbiI7CgkkaGVhZCB8fD0gJ0hFQUQnOwoKCW15ICRvbGRfaGVhZDsKCWlmICgkaGVhZCBuZSAnSEVBRCcpIHsKCQkkb2xkX2hlYWQgPSBldmFsIHsKCQkJY29tbWFuZF9vbmVsaW5lKFtxdy9zeW1ib2xpYy1yZWYgLXEgSEVBRC9dKQoJCX07CgkJaWYgKCRvbGRfaGVhZCkgewoJCQkkb2xkX2hlYWQgPX4gc3tecmVmcy9oZWFkcy99e307CgkJfSBlbHNlIHsKCQkJJG9sZF9oZWFkID0gZXZhbCB7IGNvbW1hbmRfb25lbGluZShxdy9yZXYtcGFyc2UgSEVBRC8pIH07CgkJfQoJCWNvbW1hbmQoWydjaGVja291dCcsICRoZWFkXSwgU1RERVJSID0+IDApOwoJfQoKCW15IEByZWZzOwoJbXkgKCR1cmwsICRyZXYsICR1dWlkLCAkZ3MpID0gd29ya2luZ19oZWFkX2luZm8oJ0hFQUQnLCBcQHJlZnMpOwoJdW5sZXNzICgkZ3MpIHsKCQlkaWUgIlVuYWJsZSB0byBkZXRlcm1pbmUgdXBzdHJlYW0gU1ZOIGluZm9ybWF0aW9uIGZyb20gIiwKCQkgICAgIiRoZWFkIGhpc3RvcnkuXG5QZXJoYXBzIHRoZSByZXBvc2l0b3J5IGlzIGVtcHR5LiI7Cgl9CgoJaWYgKGRlZmluZWQgJF9jb21taXRfdXJsKSB7CgkJJHVybCA9ICRfY29tbWl0X3VybDsKCX0gZWxzZSB7CgkJJHVybCA9IGV2YWwgeyBjb21tYW5kX29uZWxpbmUoJ2NvbmZpZycsICctLWdldCcsCgkJCSAgICAgICJzdm4tcmVtb3RlLiRncy0+e3JlcG9faWR9LmNvbW1pdHVybCIpIH07CgkJaWYgKCEkdXJsKSB7CgkJCSR1cmwgPSAkZ3MtPmZ1bGxfcHVzaHVybAoJCX0KCX0KCglteSAkbGFzdF9yZXYgPSAkX3JldmlzaW9uIGlmIGRlZmluZWQgJF9yZXZpc2lvbjsKCWlmICgkdXJsKSB7CgkJcHJpbnQgIkNvbW1pdHRpbmcgdG8gJHVybCAuLi5cbiI7Cgl9CglteSAoJGxpbmVhcl9yZWZzLCAkcGFyZW50cykgPSBsaW5lYXJpemVfaGlzdG9yeSgkZ3MsIFxAcmVmcyk7CglpZiAoJF9ub19yZWJhc2UgJiYgc2NhbGFyKEAkbGluZWFyX3JlZnMpID4gMSkgewoJCXdhcm4gIkF0dGVtcHRpbmcgdG8gY29tbWl0IG1vcmUgdGhhbiBvbmUgY2hhbmdlIHdoaWxlICIsCgkJICAgICAiLS1uby1yZWJhc2UgaXMgZW5hYmxlZC5cbiIsCgkJICAgICAiSWYgdGhlc2UgY2hhbmdlcyBkZXBlbmQgb24gZWFjaCBvdGhlciwgcmUtcnVubmluZyAiLAoJCSAgICAgIndpdGhvdXQgLS1uby1yZWJhc2UgbWF5IGJlIHJlcXVpcmVkLiIKCX0KCglpZiAoZGVmaW5lZCAkX2ludGVyYWN0aXZlKXsKCQlteSAkYXNrX2RlZmF1bHQgPSAieSI7CgkJZm9yZWFjaCBteSAkZCAoQCRsaW5lYXJfcmVmcyl7CgkJCW15ICgkZmgsICRjdHgpID0gY29tbWFuZF9vdXRwdXRfcGlwZShxdyhzaG93IC0tc3VtbWFyeSksICIkZCIpOwoJCQl3aGlsZSAoPCRmaD4pewoJCQkJcHJpbnQgJF87CgkJCX0KCQkJY29tbWFuZF9jbG9zZV9waXBlKCRmaCwgJGN0eCk7CgkJCSRfID0gYXNrKCJDb21taXQgdGhpcyBwYXRjaCB0byBTVk4/IChbeV1lcyAoZGVmYXVsdCl8W25db3xbcV11aXR8W2FdbGwpOiAiLAoJCQkgICAgICAgICB2YWxpZF9yZSA9PiBxci9eKD86eWVzfHl8bm98bnxxdWl0fHF8YWxsfGEpL2ksCgkJCSAgICAgICAgIGRlZmF1bHQgPT4gJGFza19kZWZhdWx0KTsKCQkJZGllICJDb21taXQgdGhpcyBwYXRjaCByZXBseSByZXF1aXJlZCIgdW5sZXNzIGRlZmluZWQgJF87CgkJCWlmICgvXltucV0vaSkgewoJCQkJZXhpdCgwKTsKCQkJfSBlbHNpZiAoL15hL2kpIHsKCQkJCWxhc3Q7CgkJCX0KCQl9Cgl9CgoJbXkgJGV4cGVjdF91cmwgPSAkdXJsOwoKCW15ICRwdXNoX21lcmdlX2luZm8gPSBldmFsIHsKCQljb21tYW5kX29uZWxpbmUocXcvY29uZmlnIC0tZ2V0IHN2bi5wdXNobWVyZ2VpbmZvLykKCQl9OwoJaWYgKG5vdCBkZWZpbmVkKCRwdXNoX21lcmdlX2luZm8pCgkJCW9yICRwdXNoX21lcmdlX2luZm8gZXEgImZhbHNlIgoJCQlvciAkcHVzaF9tZXJnZV9pbmZvIGVxICJubyIKCQkJb3IgJHB1c2hfbWVyZ2VfaW5mbyBlcSAibmV2ZXIiKSB7CgkJJHB1c2hfbWVyZ2VfaW5mbyA9IDA7Cgl9CgoJdW5sZXNzIChkZWZpbmVkKCRfbWVyZ2VfaW5mbykgfHwgISAkcHVzaF9tZXJnZV9pbmZvKSB7CgkJIyBQcmVmbGlnaHQgY2hlY2sgb2YgY2hhbmdlcyB0byBlbnN1cmUgbm8gaXNzdWVzIHdpdGggbWVyZ2VpbmZvCgkJIyBUaGlzIGluY2x1ZGVzIGNoZWNrIGZvciB1bmNvbW1pdHRlZC10by1TVk4gcGFyZW50cwoJCSMgKG90aGVyIHRoYW4gdGhlIGZpcnN0IHBhcmVudCwgd2hpY2ggd2Ugd2lsbCBoYW5kbGUpLAoJCSMgaW5mb3JtYXRpb24gZnJvbSBkaWZmZXJlbnQgU1ZOIHJlcG9zLCBhbmQgcGF0aHMKCQkjIHdoaWNoIGFyZSBub3QgdW5kZXJuZWF0aCB0aGlzIHJlcG9zaXRvcnkgcm9vdC4KCQlteSAkcm9vdHVybCA9ICRncy0+cmVwb3Nfcm9vdDsKCSAgICAgICAgR2l0OjpTVk46OnJlbW92ZV91c2VybmFtZSgkcm9vdHVybCk7CgkJZm9yZWFjaCBteSAkZCAoQCRsaW5lYXJfcmVmcykgewoJCQlteSAlcGFyZW50c2hhc2g7CgkJCXJlYWRfY29tbWl0X3BhcmVudHMoXCVwYXJlbnRzaGFzaCwgJGQpOwoJCQlteSBAcmVhbHBhcmVudHMgPSBAeyRwYXJlbnRzaGFzaHskZH19OwoJCQlpZiAoJCNyZWFscGFyZW50cyA+IDApIHsKCQkJCSMgTWVyZ2UgY29tbWl0CgkJCQlzaGlmdCBAcmVhbHBhcmVudHM7ICMgUmVtb3ZlL2lnbm9yZSBmaXJzdCBwYXJlbnQKCQkJCWZvcmVhY2ggbXkgJHBhcmVudCAoQHJlYWxwYXJlbnRzKSB7CgkJCQkJbXkgKCRicmFuY2h1cmwsICRzdm5yZXYsICRwYXJ1dWlkKSA9IGNtdF9tZXRhZGF0YSgkcGFyZW50KTsKCQkJCQl1bmxlc3MgKGRlZmluZWQgJHBhcnV1aWQpIHsKCQkJCQkJIyBBIHBhcmVudCBpcyBtaXNzaW5nIFNWTiBhbm5vdGF0aW9ucy4uLgoJCQkJCQkjIGFib3J0IHRoZSB3aG9sZSBvcGVyYXRpb24uCgkJCQkJCWZhdGFsICIkcGFyZW50IGlzIG1lcmdlZCBpbnRvIHJldmlzaW9uICRkLCAiCgkJCQkJCQkgLiJidXQgZG9lcyBub3QgaGF2ZSBnaXQtc3ZuIG1ldGFkYXRhLiAiCgkJCQkJCQkgLiJFaXRoZXIgZGNvbW1pdCB0aGUgYnJhbmNoIG9yIHVzZSBhICIKCQkJCQkJCSAuImxvY2FsIGNoZXJyeS1waWNrLCBGRiBtZXJnZSwgb3IgcmViYXNlICIKCQkJCQkJCSAuImluc3RlYWQgb2YgYW4gZXhwbGljaXQgbWVyZ2UgY29tbWl0LiI7CgkJCQkJfQoKCQkJCQl1bmxlc3MgKCRwYXJ1dWlkIGVxICR1dWlkKSB7CgkJCQkJCSMgUGFyZW50IGhhcyBTVk4gbWV0YWRhdGEgZnJvbSBkaWZmZXJlbnQgcmVwb3NpdG9yeQoJCQkJCQlmYXRhbCAibWVyZ2UgcGFyZW50ICRwYXJlbnQgZm9yIGNoYW5nZSAkZCBoYXMgIgoJCQkJCQkJIC4iZ2l0LXN2biB1dWlkICRwYXJ1dWlkLCB3aGlsZSBjdXJyZW50IGNoYW5nZSAiCgkJCQkJCQkgLiJoYXMgdXVpZCAkdXVpZCEiOwoJCQkJCX0KCgkJCQkJdW5sZXNzICgkYnJhbmNodXJsID1+IC9eXFEkcm9vdHVybFxFKC4qKS8pIHsKCQkJCQkJIyBUaGlzIGJyYW5jaCBpcyB2ZXJ5IHN0cmFuZ2UgaW5kZWVkLgoJCQkJCQlmYXRhbCAibWVyZ2UgcGFyZW50ICRwYXJlbnQgZm9yICRkIGlzIG9uIGJyYW5jaCAiCgkJCQkJCQkgLiIkYnJhbmNodXJsLCB3aGljaCBpcyBub3QgdW5kZXIgdGhlICIKCQkJCQkJCSAuImdpdC1zdm4gcm9vdCAkcm9vdHVybCEiOwoJCQkJCX0KCQkJCX0KCQkJfQoJCX0KCX0KCglteSAkcmV3cml0dGVuX3BhcmVudDsKCW15ICRjdXJyZW50X2hlYWQgPSBjb21tYW5kX29uZWxpbmUocXcvcmV2LXBhcnNlIEhFQUQvKTsKCUdpdDo6U1ZOOjpyZW1vdmVfdXNlcm5hbWUoJGV4cGVjdF91cmwpOwoJaWYgKGRlZmluZWQoJF9tZXJnZV9pbmZvKSkgewoJCSRfbWVyZ2VfaW5mbyA9fiB0cnsgfXtcbn07Cgl9Cgl3aGlsZSAoMSkgewoJCW15ICRkID0gc2hpZnQgQCRsaW5lYXJfcmVmcyBvciBsYXN0OwoJCXVubGVzcyAoZGVmaW5lZCAkbGFzdF9yZXYpIHsKCQkJKHVuZGVmLCAkbGFzdF9yZXYsIHVuZGVmKSA9IGNtdF9tZXRhZGF0YSgiJGR+MSIpOwoJCQl1bmxlc3MgKGRlZmluZWQgJGxhc3RfcmV2KSB7CgkJCQlmYXRhbCAiVW5hYmxlIHRvIGV4dHJhY3QgcmV2aXNpb24gaW5mb3JtYXRpb24gIiwKCQkJCSAgICAgICJmcm9tIGNvbW1pdCAkZH4xIjsKCQkJfQoJCX0KCQlpZiAoJF9kcnlfcnVuKSB7CgkJCXByaW50ICJkaWZmLXRyZWUgJGR+MSAkZFxuIjsKCQl9IGVsc2UgewoJCQlteSAkY210X3JldjsKCgkJCXVubGVzcyAoZGVmaW5lZCgkX21lcmdlX2luZm8pIHx8ICEgJHB1c2hfbWVyZ2VfaW5mbykgewoJCQkJJF9tZXJnZV9pbmZvID0gcG9wdWxhdGVfbWVyZ2VfaW5mbygkZCwgJGdzLAoJCQkJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdXVpZCwKCQkJCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxpbmVhcl9yZWZzLAoJCQkJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcmV3cml0dGVuX3BhcmVudCk7CgkJCX0KCgkJCW15ICVlZF9vcHRzID0gKCByID0+ICRsYXN0X3JldiwKCQkJICAgICAgICAgICAgICAgIGxvZyA9PiBnZXRfY29tbWl0X2VudHJ5KCRkKS0+e2xvZ30sCgkJCSAgICAgICAgICAgICAgICByYSA9PiBHaXQ6OlNWTjo6UmEtPm5ldygkdXJsKSwKCQkJICAgICAgICAgICAgICAgIGNvbmZpZyA9PiBTVk46OkNvcmU6OmNvbmZpZ19nZXRfY29uZmlnKAoJCQkgICAgICAgICAgICAgICAgICAgICAgICAkR2l0OjpTVk46OlJhOjpjb25maWdfZGlyCgkJCSAgICAgICAgICAgICAgICApLAoJCQkgICAgICAgICAgICAgICAgdHJlZV9hID0+ICIkZH4xIiwKCQkJICAgICAgICAgICAgICAgIHRyZWVfYiA9PiAkZCwKCQkJICAgICAgICAgICAgICAgIGVkaXRvcl9jYiA9PiBzdWIgewoJCQkgICAgICAgICAgICAgICAgICAgICAgIHByaW50ICJDb21taXR0ZWQgciRfWzBdXG4iOwoJCQkgICAgICAgICAgICAgICAgICAgICAgICRjbXRfcmV2ID0gJF9bMF07CgkJCSAgICAgICAgICAgICAgICB9LAoJCQkJCW1lcmdlaW5mbyA9PiAkX21lcmdlX2luZm8sCgkJCSAgICAgICAgICAgICAgICBzdm5fcGF0aCA9PiAnJyk7CgoJCQlteSAkZXJyX2hhbmRsZXIgPSAkU1ZOOjpFcnJvcjo6aGFuZGxlcjsKCQkJJFNWTjo6RXJyb3I6OmhhbmRsZXIgPSBzdWIgewoJCQkJbXkgJGVyciA9IHNoaWZ0OwoJCQkJZGNvbW1pdF9yZWJhc2UoMSwgJGN1cnJlbnRfaGVhZCwgJGdzLT5yZWZuYW1lLAoJCQkJCSRlcnIpOwoJCQl9OwoKCQkJaWYgKCFHaXQ6OlNWTjo6RWRpdG9yLT5uZXcoXCVlZF9vcHRzKS0+YXBwbHlfZGlmZikgewoJCQkJcHJpbnQgIk5vIGNoYW5nZXNcbiRkfjEgPT0gJGRcbiI7CgkJCX0gZWxzaWYgKCRwYXJlbnRzLT57JGR9ICYmIEB7JHBhcmVudHMtPnskZH19KSB7CgkJCQkkZ3MtPntpbmplY3RfcGFyZW50c19kY29tbWl0fS0+eyRjbXRfcmV2fSA9CgkJCQkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHBhcmVudHMtPnskZH07CgkJCX0KCQkJJF9mZXRjaF9hbGwgPyAkZ3MtPmZldGNoX2FsbCA6ICRncy0+ZmV0Y2g7CgkJCSRTVk46OkVycm9yOjpoYW5kbGVyID0gJGVycl9oYW5kbGVyOwoJCQkkbGFzdF9yZXYgPSAkY210X3JldjsKCQkJbmV4dCBpZiAkX25vX3JlYmFzZTsKCgkJCW15IEBkaWZmID0gZGNvbW1pdF9yZWJhc2UoQCRsaW5lYXJfcmVmcyA9PSAwLCAkZCwKCQkJCQkJJGdzLT5yZWZuYW1lLCB1bmRlZik7CgoJCQkkcmV3cml0dGVuX3BhcmVudCA9IGNvbW1hbmRfb25lbGluZShxdy9yZXYtcGFyc2UvLAoJCQkJCQkJJGdzLT5yZWZuYW1lKTsKCgkJCWlmIChAZGlmZikgewoJCQkJJGN1cnJlbnRfaGVhZCA9IGNvbW1hbmRfb25lbGluZShxdy9yZXYtcGFyc2UKCQkJCQkJCQlIRUFELyk7CgkJCQlAcmVmcyA9ICgpOwoJCQkJbXkgKCR1cmxfLCAkcmV2XywgJHV1aWRfLCAkZ3NfKSA9CgkJCQkgICAgICAgICAgICAgIHdvcmtpbmdfaGVhZF9pbmZvKCdIRUFEJywgXEByZWZzKTsKCQkJCW15ICgkbGluZWFyX3JlZnNfLCAkcGFyZW50c18pID0KCQkJCSAgICAgICAgICAgICAgbGluZWFyaXplX2hpc3RvcnkoJGdzXywgXEByZWZzKTsKCQkJCWlmIChzY2FsYXIoQCRsaW5lYXJfcmVmcykgIT0KCQkJCSAgICBzY2FsYXIoQCRsaW5lYXJfcmVmc18pKSB7CgkJCQkJZmF0YWwgIiMgb2YgcmV2aXNpb25zIGNoYW5nZWQgIiwKCQkJCQkgICJcbmJlZm9yZTpcbiIsCgkJCQkJICBqb2luKCJcbiIsIEAkbGluZWFyX3JlZnMpLAoJCQkJCSAgIlxuXG5hZnRlcjpcbiIsCgkJCQkJICBqb2luKCJcbiIsIEAkbGluZWFyX3JlZnNfKSwgIlxuIiwKCQkJCQkgICdJZiB5b3UgYXJlIGF0dGVtcHRpbmcgdG8gY29tbWl0ICcsCgkJCQkJICAibWVyZ2VzLCB0cnkgcnVubmluZzpcblx0IiwKCQkJCQkgICdnaXQgcmViYXNlIC0taW50ZXJhY3RpdmUnLAoJCQkJCSAgJy0tcmViYXNlLW1lcmdlcyAnLAoJCQkJCSAgJGdzLT5yZWZuYW1lLAoJCQkJCSAgIlxuQmVmb3JlIGRjb21taXR0aW5nIjsKCQkJCX0KCQkJCWlmICgkdXJsXyBuZSAkZXhwZWN0X3VybCkgewoJCQkJCWlmICgkdXJsXyBlcSAkZ3MtPm1ldGFkYXRhX3VybCkgewoJCQkJCQlwcmludAoJCQkJCQkgICJBY2NlcHRpbmcgcmV3cml0dGVuIFVSTDoiLAoJCQkJCQkgICIgJHVybF9cbiI7CgkJCQkJfSBlbHNlIHsKCQkJCQkJZmF0YWwKCQkJCQkJICAiVVJMIG1pc21hdGNoIGFmdGVyIHJlYmFzZToiLAoJCQkJCQkgICIgJHVybF8gIT0gJGV4cGVjdF91cmwiOwoJCQkJCX0KCQkJCX0KCQkJCWlmICgkdXVpZF8gbmUgJHV1aWQpIHsKCQkJCQlmYXRhbCAidXVpZCBtaXNtYXRjaCBhZnRlciByZWJhc2U6ICIsCgkJCQkJICAgICAgIiR1dWlkXyAhPSAkdXVpZCI7CgkJCQl9CgkJCQkjIHJlbWFwIHBhcmVudHMKCQkJCW15ICglcCwgQGwsICRpKTsKCQkJCWZvciAoJGkgPSAwOyAkaSA8IHNjYWxhciBAJGxpbmVhcl9yZWZzOyAkaSsrKSB7CgkJCQkJbXkgJG5ldyA9ICRsaW5lYXJfcmVmc18tPlskaV0gb3IgbmV4dDsKCQkJCQkkcHskbmV3fSA9CgkJCQkJCSRwYXJlbnRzLT57JGxpbmVhcl9yZWZzLT5bJGldfTsKCQkJCQlwdXNoIEBsLCAkbmV3OwoJCQkJfQoJCQkJJHBhcmVudHMgPSBcJXA7CgkJCQkkbGluZWFyX3JlZnMgPSBcQGw7CgkJCQl1bmRlZiAkbGFzdF9yZXY7CgkJCX0KCQl9Cgl9CgoJaWYgKCRvbGRfaGVhZCkgewoJCW15ICRuZXdfaGVhZCA9IGNvbW1hbmRfb25lbGluZShxdy9yZXYtcGFyc2UgSEVBRC8pOwoJCW15ICRuZXdfaXNfc3ltYm9saWMgPSBldmFsIHsKCQkJY29tbWFuZF9vbmVsaW5lKHF3L3N5bWJvbGljLXJlZiAtcSBIRUFELyk7CgkJfTsKCQlpZiAoJG5ld19pc19zeW1ib2xpYykgewoJCQlwcmludCAiZGNvbW1pdHRlZCB0aGUgYnJhbmNoICIsICRoZWFkLCAiXG4iOwoJCX0gZWxzZSB7CgkJCXByaW50ICJkY29tbWl0dGVkIG9uIGEgZGV0YWNoZWQgSEVBRCBiZWNhdXNlIHlvdSBnYXZlICIsCgkJCSAgICAgICJhIHJldmlzaW9uIGFyZ3VtZW50LlxuIiwKCQkJICAgICAgIlRoZSByZXdyaXR0ZW4gY29tbWl0IGlzOiAiLCAkbmV3X2hlYWQsICJcbiI7CgkJfQoJCWNvbW1hbmQoWydjaGVja291dCcsICRvbGRfaGVhZF0sIFNUREVSUiA9PiAwKTsKCX0KCgl1bmxpbmsgJGdzLT57aW5kZXh9Owp9CgpzdWIgY21kX2JyYW5jaCB7CglteSAoJGJyYW5jaF9uYW1lLCAkaGVhZCkgPSBAXzsKCgl1bmxlc3MgKGRlZmluZWQgJGJyYW5jaF9uYW1lICYmIGxlbmd0aCAkYnJhbmNoX25hbWUpIHsKCQlkaWUoKCRfdGFnID8gInRhZyIgOiAiYnJhbmNoIikgLiAiIG5hbWUgcmVxdWlyZWRcbiIpOwoJfQoJJGhlYWQgfHw9ICdIRUFEJzsKCglteSAodW5kZWYsICRyZXYsIHVuZGVmLCAkZ3MpID0gd29ya2luZ19oZWFkX2luZm8oJGhlYWQpOwoJbXkgJHNyYyA9ICRncy0+ZnVsbF9wdXNodXJsOwoKCW15ICRyZW1vdGUgPSBHaXQ6OlNWTjo6cmVhZF9hbGxfcmVtb3RlcygpLT57JGdzLT57cmVwb19pZH19OwoJbXkgJGFsbGdsb2JzID0gJHJlbW90ZS0+eyAkX3RhZyA/ICd0YWdzJyA6ICdicmFuY2hlcycgfTsKCW15ICRnbG9iOwoJaWYgKCQjeyRhbGxnbG9ic30gPT0gMCkgewoJCSRnbG9iID0gJGFsbGdsb2JzLT5bMF07Cgl9IGVsc2UgewoJCXVubGVzcyhkZWZpbmVkICRfYnJhbmNoX2Rlc3QpIHsKCQkJZGllICJNdWx0aXBsZSAiLAoJCQkgICAgJF90YWcgPyAidGFnIiA6ICJicmFuY2giLAoJCQkgICAgIiBwYXRocyBkZWZpbmVkIGZvciBTdWJ2ZXJzaW9uIHJlcG9zaXRvcnkuXG4iLAoJCSAgICAgICAgICAgICJZb3UgbXVzdCBzcGVjaWZ5IHdoZXJlIHlvdSB3YW50IHRvIGNyZWF0ZSB0aGUgIiwKCQkgICAgICAgICAgICAkX3RhZyA/ICJ0YWciIDogImJyYW5jaCIsCgkJICAgICAgICAgICAgIiB3aXRoIHRoZSAtLWRlc3RpbmF0aW9uIGFyZ3VtZW50LlxuIjsKCQl9CgkJZm9yZWFjaCBteSAkZyAoQHskYWxsZ2xvYnN9KSB7CgkJCW15ICRyZSA9IEdpdDo6U1ZOOjpFZGl0b3I6Omdsb2IycGF0KCRnLT57cGF0aH0tPntsZWZ0fSk7CgkJCWlmICgkX2JyYW5jaF9kZXN0ID1+IC8kcmUvKSB7CgkJCQkkZ2xvYiA9ICRnOwoJCQkJbGFzdDsKCQkJfQoJCX0KCQl1bmxlc3MgKGRlZmluZWQgJGdsb2IpIHsKCQkJbXkgJGRlc3RfcmUgPSBxci9cYlxRJF9icmFuY2hfZGVzdFxFXGIvOwoJCQlmb3JlYWNoIG15ICRnIChAeyRhbGxnbG9ic30pIHsKCQkJCSRnLT57cGF0aH0tPntsZWZ0fSA9fiAvJGRlc3RfcmUvIG9yIG5leHQ7CgkJCQlpZiAoZGVmaW5lZCAkZ2xvYikgewoJCQkJCWRpZSAiQW1iaWd1b3VzIGRlc3RpbmF0aW9uOiAiLAoJCQkJCSAgICAkX2JyYW5jaF9kZXN0LCAiXG5tYXRjaGVzIGJvdGggJyIsCgkJCQkJICAgICRnbG9iLT57cGF0aH0tPntsZWZ0fSwgIicgYW5kICciLAoJCQkJCSAgICAkZy0+e3BhdGh9LT57bGVmdH0sICInXG4iOwoJCQkJfQoJCQkJJGdsb2IgPSAkZzsKCQkJfQoJCQl1bmxlc3MgKGRlZmluZWQgJGdsb2IpIHsKCQkJCWRpZSAiVW5rbm93biAiLAoJCQkJICAgICRfdGFnID8gInRhZyIgOiAiYnJhbmNoIiwKCQkJCSAgICAiIGRlc3RpbmF0aW9uICRfYnJhbmNoX2Rlc3RcbiI7CgkJCX0KCQl9Cgl9CglteSAoJGxmdCwgJHJndCkgPSBAeyAkZ2xvYi0+e3BhdGh9IH17cXcvbGVmdCByaWdodC99OwoJbXkgJHVybDsKCWlmIChkZWZpbmVkICRfY29tbWl0X3VybCkgewoJCSR1cmwgPSAkX2NvbW1pdF91cmw7Cgl9IGVsc2UgewoJCSR1cmwgPSBldmFsIHsgY29tbWFuZF9vbmVsaW5lKCdjb25maWcnLCAnLS1nZXQnLAoJCQkic3ZuLXJlbW90ZS4kZ3MtPntyZXBvX2lkfS5jb21taXR1cmwiKSB9OwoJCWlmICghJHVybCkgewoJCQkkdXJsID0gJHJlbW90ZS0+e3B1c2h1cmx9IHx8ICRyZW1vdGUtPnt1cmx9OwoJCX0KCX0KCW15ICRkc3QgPSBqb2luICcvJywgJHVybCwgJGxmdCwgJGJyYW5jaF9uYW1lLCAoJHJndCB8fCAoKSk7CgoJaWYgKCRkc3QgPX4gL15odHRwczovICYmICRzcmMgPX4gL15odHRwOi8pIHsKCQkkc3JjPX5zL15odHRwOi9odHRwczovOwoJfQoKCTo6X3JlcV9zdm4oKTsKCXJlcXVpcmUgU1ZOOjpDbGllbnQ7CgoJbXkgKCRjb25maWcsICRiYXRvbiwgdW5kZWYpID0gR2l0OjpTVk46OlJhOjpwcmVwYXJlX2NvbmZpZ19vbmNlKCk7CglteSAkY3R4ID0gU1ZOOjpDbGllbnQtPm5ldygKCQlhdXRoID0+ICRiYXRvbiwKCQljb25maWcgPT4gJGNvbmZpZywKCQlsb2dfbXNnID0+IHN1YiB7CgkJCSR7ICRfWzBdIH0gPSBkZWZpbmVkICRfbWVzc2FnZQoJCQkJPyAkX21lc3NhZ2UKCQkJCTogJ0NyZWF0ZSAnIC4gKCRfdGFnID8gJ3RhZyAnIDogJ2JyYW5jaCAnICkKCQkJCS4gJGJyYW5jaF9uYW1lOwoJCX0sCgkpOwoKCWV2YWwgewoJCSRjdHgtPmxzKCRkc3QsICdIRUFEJywgMCk7Cgl9IGFuZCBkaWUgImJyYW5jaCAke2JyYW5jaF9uYW1lfSBhbHJlYWR5IGV4aXN0c1xuIjsKCglpZiAoJF9wYXJlbnRzKSB7CgkJbWtfcGFyZW50X2RpcnMoJGN0eCwgJGRzdCk7Cgl9CgoJcHJpbnQgIkNvcHlpbmcgJHtzcmN9IGF0IHIke3Jldn0gdG8gJHtkc3R9Li4uXG4iOwoJJGN0eC0+Y29weSgkc3JjLCAkcmV2LCAkZHN0KQoJCXVubGVzcyAkX2RyeV9ydW47CgoJIyBSZWxlYXNlIHJlc291cmNlcyBoZWxkIGJ5IGN0eCBiZWZvcmUgY3JlYXRpbmcgYW5vdGhlciBTVk46OlJhCgkjIHNvIGRlc3RydWN0aW9uIGlzIG9yZGVybHkuICBUaGlzIHNlZW1zIG5lY2Vzc2FyeSB3aXRoIFNWTiAxLjkuNQoJIyB0byBhdm9pZCBzZWdmYXVsdHMuCgkkY3R4ID0gdW5kZWY7CgoJJGdzLT5mZXRjaF9hbGw7Cn0KCnN1YiBta19wYXJlbnRfZGlycyB7CglteSAoJGN0eCwgJHBhcmVudCkgPSBAXzsKCSRwYXJlbnQgPX4gc3svW14vXSokfXt9OwoKCWlmICghZXZhbHskY3R4LT5scygkcGFyZW50LCAnSEVBRCcsIDApfSkgewoJCW1rX3BhcmVudF9kaXJzKCRjdHgsICRwYXJlbnQpOwoJCXByaW50ICJDcmVhdGluZyBwYXJlbnQgZm9sZGVyICR7cGFyZW50fSAuLi5cbiI7CgkJJGN0eC0+bWtkaXIoJHBhcmVudCkgdW5sZXNzICRfZHJ5X3J1bjsKCX0KfQoKc3ViIGNtZF9maW5kX3JldiB7CglteSAkcmV2aXNpb25fb3JfaGFzaCA9IHNoaWZ0IG9yIGRpZSAiU1ZOIG9yIGdpdCByZXZpc2lvbiByZXF1aXJlZCAiLAoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImFzIGEgY29tbWFuZC1saW5lIGFyZ3VtZW50XG4iOwoJbXkgJHJlc3VsdDsKCWlmICgkcmV2aXNpb25fb3JfaGFzaCA9fiAvXnJcZCskLykgewoJCW15ICRoZWFkID0gc2hpZnQ7CgkJJGhlYWQgfHw9ICdIRUFEJzsKCQlteSBAcmVmczsKCQlteSAodW5kZWYsIHVuZGVmLCAkdXVpZCwgJGdzKSA9IHdvcmtpbmdfaGVhZF9pbmZvKCRoZWFkLCBcQHJlZnMpOwoJCXVubGVzcyAoJGdzKSB7CgkJCWRpZSAiVW5hYmxlIHRvIGRldGVybWluZSB1cHN0cmVhbSBTVk4gaW5mb3JtYXRpb24gZnJvbSAiLAoJCQkgICAgIiRoZWFkIGhpc3RvcnlcbiI7CgkJfQoJCW15ICRkZXNpcmVkX3JldmlzaW9uID0gc3Vic3RyKCRyZXZpc2lvbl9vcl9oYXNoLCAxKTsKCQlpZiAoJF9iZWZvcmUpIHsKCQkJJHJlc3VsdCA9ICRncy0+ZmluZF9yZXZfYmVmb3JlKCRkZXNpcmVkX3JldmlzaW9uLCAxKTsKCQl9IGVsc2lmICgkX2FmdGVyKSB7CgkJCSRyZXN1bHQgPSAkZ3MtPmZpbmRfcmV2X2FmdGVyKCRkZXNpcmVkX3JldmlzaW9uLCAxKTsKCQl9IGVsc2UgewoJCQkkcmVzdWx0ID0gJGdzLT5yZXZfbWFwX2dldCgkZGVzaXJlZF9yZXZpc2lvbiwgJHV1aWQpOwoJCX0KCX0gZWxzZSB7CgkJbXkgKHVuZGVmLCAkcmV2LCB1bmRlZikgPSBjbXRfbWV0YWRhdGEoJHJldmlzaW9uX29yX2hhc2gpOwoJCSRyZXN1bHQgPSAkcmV2OwoJfQoJcHJpbnQgIiRyZXN1bHRcbiIgaWYgJHJlc3VsdDsKfQoKc3ViIGF1dG9fY3JlYXRlX2VtcHR5X2RpcmVjdG9yaWVzIHsKCW15ICgkZ3MpID0gQF87CglteSAkdmFyID0gZXZhbCB7IGNvbW1hbmRfb25lbGluZSgnY29uZmlnJywgJy0tZ2V0JywgJy0tYm9vbCcsCgkJCQkJICJzdm4tcmVtb3RlLiRncy0+e3JlcG9faWR9LmF1dG9ta2RpcnMiKSB9OwoJIyBCeSBkZWZhdWx0LCBjcmVhdGUgZW1wdHkgZGlyZWN0b3JpZXMgYnkgY29uc3VsdGluZyB0aGUgdW5oYW5kbGVkIGxvZywKCSMgYnV0IGFsbG93IHNldHRpbmcgaXQgdG8gJ2ZhbHNlJyB0byBza2lwIGl0LgoJcmV0dXJuICEoJHZhciAmJiAkdmFyIGVxICdmYWxzZScpOwp9CgpzdWIgY21kX3JlYmFzZSB7Cgljb21tYW5kX25vaXN5KHF3L3VwZGF0ZS1pbmRleCAtLXJlZnJlc2gvKTsKCW15ICgkdXJsLCAkcmV2LCAkdXVpZCwgJGdzKSA9IHdvcmtpbmdfaGVhZF9pbmZvKCdIRUFEJyk7Cgl1bmxlc3MgKCRncykgewoJCWRpZSAiVW5hYmxlIHRvIGRldGVybWluZSB1cHN0cmVhbSBTVk4gaW5mb3JtYXRpb24gZnJvbSAiLAoJCSAgICAid29ya2luZyB0cmVlIGhpc3RvcnlcbiI7Cgl9CglpZiAoJF9kcnlfcnVuKSB7CgkJcHJpbnQgIlJlbW90ZSBCcmFuY2g6ICIgLiAkZ3MtPnJlZm5hbWUgLiAiXG4iOwoJCXByaW50ICJTVk4gVVJMOiAiIC4gJHVybCAuICJcbiI7CgkJcmV0dXJuOwoJfQoJaWYgKGNvbW1hbmQocXcvZGlmZi1pbmRleCBIRUFEIC0tLykpIHsKCQlwcmludCBTVERFUlIgIkNhbm5vdCByZWJhc2Ugd2l0aCB1bmNvbW1pdHRlZCBjaGFuZ2VzOlxuIjsKCQljb21tYW5kX25vaXN5KCdzdGF0dXMnKTsKCQlleGl0IDE7Cgl9Cgl1bmxlc3MgKCRfbG9jYWwpIHsKCQkjIHJlYmFzZSB3aWxsIGNoZWNrb3V0IGZvciB1cywgc28gbm8gbmVlZCB0byBkbyBpdCBleHBsaWNpdGx5CgkJJF9ub19jaGVja291dCA9ICd0cnVlJzsKCQkkX2ZldGNoX2FsbCA/ICRncy0+ZmV0Y2hfYWxsIDogJGdzLT5mZXRjaDsKCX0KCWNvbW1hbmRfbm9pc3kocmViYXNlX2NtZCgpLCAkZ3MtPnJlZm5hbWUpOwoJaWYgKGF1dG9fY3JlYXRlX2VtcHR5X2RpcmVjdG9yaWVzKCRncykpIHsKCQkkZ3MtPm1rZW1wdHlkaXJzOwoJfQp9CgpzdWIgY21kX3Nob3dfaWdub3JlIHsKCW15ICgkdXJsLCAkcmV2LCAkdXVpZCwgJGdzKSA9IHdvcmtpbmdfaGVhZF9pbmZvKCdIRUFEJyk7CgkkZ3MgfHw9IEdpdDo6U1ZOLT5uZXc7CglteSAkciA9IChkZWZpbmVkICRfcmV2aXNpb24gPyAkX3JldmlzaW9uIDogJGdzLT5yYS0+Z2V0X2xhdGVzdF9yZXZudW0pOwoJJGdzLT5wcm9wX3dhbGsoJGdzLT5wYXRoLCAkciwgc3ViIHsKCQlteSAoJGdzLCAkcGF0aCwgJHByb3BzKSA9IEBfOwoJCXByaW50IFNURE9VVCAiXG4jICRwYXRoXG4iOwoJCW15ICRzID0gJHByb3BzLT57J3N2bjppZ25vcmUnfSBvciByZXR1cm47CgkJJHMgPX4gcy9bXHJcbl0rL1xuL2c7CgkJJHMgPX4gcy9eXG4rLy87CgkJY2hvbXAgJHM7CgkJJHMgPX4gcyNeIyRwYXRoI2dtOwoJCXByaW50IFNURE9VVCAiJHNcbiI7Cgl9KTsKfQoKc3ViIGNtZF9zaG93X2V4dGVybmFscyB7CglteSAoJHVybCwgJHJldiwgJHV1aWQsICRncykgPSB3b3JraW5nX2hlYWRfaW5mbygnSEVBRCcpOwoJJGdzIHx8PSBHaXQ6OlNWTi0+bmV3OwoJbXkgJHIgPSAoZGVmaW5lZCAkX3JldmlzaW9uID8gJF9yZXZpc2lvbiA6ICRncy0+cmEtPmdldF9sYXRlc3RfcmV2bnVtKTsKCSRncy0+cHJvcF93YWxrKCRncy0+cGF0aCwgJHIsIHN1YiB7CgkJbXkgKCRncywgJHBhdGgsICRwcm9wcykgPSBAXzsKCQlwcmludCBTVERPVVQgIlxuIyAkcGF0aFxuIjsKCQlteSAkcyA9ICRwcm9wcy0+eydzdm46ZXh0ZXJuYWxzJ30gb3IgcmV0dXJuOwoJCSRzID1+IHMvW1xyXG5dKy9cbi9nOwoJCWNob21wICRzOwoJCSRzID1+IHMjXiMkcGF0aCNnbTsKCQlwcmludCBTVERPVVQgIiRzXG4iOwoJfSk7Cn0KCnN1YiBjbWRfY3JlYXRlX2lnbm9yZSB7CglteSAoJHVybCwgJHJldiwgJHV1aWQsICRncykgPSB3b3JraW5nX2hlYWRfaW5mbygnSEVBRCcpOwoJJGdzIHx8PSBHaXQ6OlNWTi0+bmV3OwoJbXkgJHIgPSAoZGVmaW5lZCAkX3JldmlzaW9uID8gJF9yZXZpc2lvbiA6ICRncy0+cmEtPmdldF9sYXRlc3RfcmV2bnVtKTsKCSRncy0+cHJvcF93YWxrKCRncy0+cGF0aCwgJHIsIHN1YiB7CgkJbXkgKCRncywgJHBhdGgsICRwcm9wcykgPSBAXzsKCQkjICRwYXRoIGlzIG9mIHRoZSBmb3JtIC9wYXRoL3RvL2Rpci8KCQkkcGF0aCA9ICcuJyAuICRwYXRoOwoJCSMgU1ZOIGNhbiBoYXZlIGF0dHJpYnV0ZXMgb24gZW1wdHkgZGlyZWN0b3JpZXMsCgkJIyB3aGljaCBnaXQgd29uJ3QgdHJhY2sKCQlta3BhdGgoWyRwYXRoXSkgdW5sZXNzIC1kICRwYXRoOwoJCW15ICRpZ25vcmUgPSAkcGF0aCAuICcuZ2l0aWdub3JlJzsKCQlteSAkcyA9ICRwcm9wcy0+eydzdm46aWdub3JlJ30gb3IgcmV0dXJuOwoJCW9wZW4oR0lUSUdOT1JFLCAnPicsICRpZ25vcmUpCgkJICBvciBmYXRhbCgiRmFpbGVkIHRvIG9wZW4gYCRpZ25vcmUnIGZvciB3cml0aW5nOiAkISIpOwoJCSRzID1+IHMvW1xyXG5dKy9cbi9nOwoJCSRzID1+IHMvXlxuKy8vOwoJCWNob21wICRzOwoJCSMgUHJlZml4IGFsbCBwYXR0ZXJucyBzbyB0aGF0IHRoZSBpZ25vcmUgZG9lc24ndCBhcHBseQoJCSMgdG8gc3ViLWRpcmVjdG9yaWVzLgoJCSRzID1+IHMjXiMvI2dtOwoJCXByaW50IEdJVElHTk9SRSAiJHNcbiI7CgkJY2xvc2UoR0lUSUdOT1JFKQoJCSAgb3IgZmF0YWwoIkZhaWxlZCB0byBjbG9zZSBgJGlnbm9yZSc6ICQhIik7CgkJY29tbWFuZF9ub2lzeSgnYWRkJywgJy1mJywgJGlnbm9yZSk7Cgl9KTsKfQoKc3ViIGNtZF9ta2RpcnMgewoJbXkgKCR1cmwsICRyZXYsICR1dWlkLCAkZ3MpID0gd29ya2luZ19oZWFkX2luZm8oJ0hFQUQnKTsKCSRncyB8fD0gR2l0OjpTVk4tPm5ldzsKCSRncy0+bWtlbXB0eWRpcnMoJF9yZXZpc2lvbik7Cn0KCiMgZ2V0X3N2bnByb3BzKFBBVEgpCiMgLS0tLS0tLS0tLS0tLS0tLS0tCiMgSGVscGVyIGZvciBjbWRfcHJvcGdldCBhbmQgY21kX3Byb3BsaXN0IGJlbG93LgpzdWIgZ2V0X3N2bnByb3BzIHsKCW15ICRwYXRoID0gc2hpZnQ7CglteSAoJHVybCwgJHJldiwgJHV1aWQsICRncykgPSB3b3JraW5nX2hlYWRfaW5mbygnSEVBRCcpOwoJJGdzIHx8PSBHaXQ6OlNWTi0+bmV3OwoKCSMgcHJlZml4IFRIRSBQQVRIIGJ5IHRoZSBzdWItZGlyZWN0b3J5IGZyb20gd2hpY2ggdGhlIHVzZXIKCSMgaW52b2tlZCB1cy4KCSRwYXRoID0gJGNtZF9kaXJfcHJlZml4IC4gJHBhdGg7CglmYXRhbCgiTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeTogJHBhdGgiKSB1bmxlc3MgLWUgJHBhdGg7CglteSAkaXNfZGlyID0gLWQgJHBhdGggPyAxIDogMDsKCSRwYXRoID0gam9pbl9wYXRocygkZ3MtPnBhdGgsICRwYXRoKTsKCgkjIGNhbm9uaWNhbGl6ZSB0aGUgcGF0aCAob3RoZXJ3aXNlIGxpYnN2biB3aWxsIGFib3J0IG9yIGZhaWwgdG8KCSMgZmluZCB0aGUgZmlsZSkKCSRwYXRoID0gY2Fub25pY2FsaXplX3BhdGgoJHBhdGgpOwoKCW15ICRyID0gKGRlZmluZWQgJF9yZXZpc2lvbiA/ICRfcmV2aXNpb24gOiAkZ3MtPnJhLT5nZXRfbGF0ZXN0X3Jldm51bSk7CglteSAkcHJvcHM7CglpZiAoJGlzX2RpcikgewoJCSh1bmRlZiwgdW5kZWYsICRwcm9wcykgPSAkZ3MtPnJhLT5nZXRfZGlyKCRwYXRoLCAkcik7Cgl9CgllbHNlIHsKCQkodW5kZWYsICRwcm9wcykgPSAkZ3MtPnJhLT5nZXRfZmlsZSgkcGF0aCwgJHIsIHVuZGVmKTsKCX0KCXJldHVybiAkcHJvcHM7Cn0KCiMgY21kX3Byb3BnZXQgKFBST1AsIFBBVEgpCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiMgUHJpbnQgdGhlIFNWTiBwcm9wZXJ0eSBQUk9QIGZvciBQQVRILgpzdWIgY21kX3Byb3BnZXQgewoJbXkgKCRwcm9wLCAkcGF0aCkgPSBAXzsKCSRwYXRoID0gJy4nIGlmIG5vdCBkZWZpbmVkICRwYXRoOwoJdXNhZ2UoMSkgaWYgbm90IGRlZmluZWQgJHByb3A7CglteSAkcHJvcHMgPSBnZXRfc3ZucHJvcHMoJHBhdGgpOwoJaWYgKG5vdCBkZWZpbmVkICRwcm9wcy0+eyRwcm9wfSkgewoJCWZhdGFsKCJgJHBhdGgnIGRvZXMgbm90IGhhdmUgYSBgJHByb3AnIFNWTiBwcm9wZXJ0eS4iKTsKCX0KCXByaW50ICRwcm9wcy0+eyRwcm9wfSAuICJcbiI7Cn0KCiMgY21kX3Byb3BzZXQgKFBST1BOQU1FLCBQUk9QVkFMLCBQQVRIKQojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojIEFkanVzdCB0aGUgU1ZOIHByb3BlcnR5IFBST1BOQU1FIHRvIFBST1BWQUwgZm9yIFBBVEguCnN1YiBjbWRfcHJvcHNldCB7CglteSAoJHByb3BuYW1lLCAkcHJvcHZhbCwgJHBhdGgpID0gQF87CgkkcGF0aCA9ICcuJyBpZiBub3QgZGVmaW5lZCAkcGF0aDsKCSRwYXRoID0gJGNtZF9kaXJfcHJlZml4IC4gJHBhdGg7Cgl1c2FnZSgxKSBpZiBub3QgZGVmaW5lZCAkcHJvcG5hbWU7Cgl1c2FnZSgxKSBpZiBub3QgZGVmaW5lZCAkcHJvcHZhbDsKCW15ICRmaWxlID0gYmFzZW5hbWUoJHBhdGgpOwoJbXkgJGRuID0gZGlybmFtZSgkcGF0aCk7CglteSAkY3VyX3Byb3BzID0gR2l0OjpTVk46OkVkaXRvcjo6Y2hlY2tfYXR0ciggInN2bi1wcm9wZXJ0aWVzIiwgJHBhdGggKTsKCW15IEBuZXdfcHJvcHM7CglpZiAoISRjdXJfcHJvcHMgfHwgJGN1cl9wcm9wcyBlcSAidW5zZXQiIHx8ICRjdXJfcHJvcHMgZXEgIiIgfHwgJGN1cl9wcm9wcyBlcSAic2V0IikgewoJCXB1c2ggQG5ld19wcm9wcywgIiRwcm9wbmFtZT0kcHJvcHZhbCI7Cgl9IGVsc2UgewoJCSMgVE9ETzogaGFuZGxlIGNvbWJpbmluZyBwcm9wZXJ0aWVzIGJldHRlcgoJCW15IEBwcm9wcyA9IHNwbGl0KC87LywgJGN1cl9wcm9wcyk7CgkJbXkgJHJlcGxhY2VkX3Byb3A7CgkJZm9yZWFjaCBteSAkcHJvcCAoQHByb3BzKSB7CgkJCSMgUGFyc2UgJ25hbWU9dmFsdWUnIHN5bnRheCBhbmQgc2V0IHRoZSBwcm9wZXJ0eS4KCQkJaWYgKCRwcm9wID1+IC8oW149XSspPSguKikvKSB7CgkJCQlteSAoJG4sJHYpID0gKCQxLCQyKTsKCQkJCWlmICgkbiBlcSAkcHJvcG5hbWUpIHsKCQkJCQkkdiA9ICRwcm9wdmFsOwoJCQkJCSRyZXBsYWNlZF9wcm9wID0gMTsKCQkJCX0KCQkJCXB1c2ggQG5ld19wcm9wcywgIiRuPSR2IjsKCQkJfQoJCX0KCQlpZiAoISRyZXBsYWNlZF9wcm9wKSB7CgkJCXB1c2ggQG5ld19wcm9wcywgIiRwcm9wbmFtZT0kcHJvcHZhbCI7CgkJfQoJfQoJbXkgJGF0dHJmaWxlID0gIiRkbi8uZ2l0YXR0cmlidXRlcyI7CglvcGVuIG15ICRhdHRyZmgsICc+PicsICRhdHRyZmlsZSBvciBkaWUgIkNhbid0IG9wZW4gJGF0dHJmaWxlOiAkIVxuIjsKCSMgVE9ETzogZG9uJ3Qgc2ltcGx5IGFwcGVuZCBoZXJlIGlmICRmaWxlIGFscmVhZHkgaGFzIHN2bi1wcm9wZXJ0aWVzCglteSAkbmV3X3Byb3BzID0gam9pbignOycsIEBuZXdfcHJvcHMpOwoJcHJpbnQgJGF0dHJmaCAiJGZpbGUgc3ZuLXByb3BlcnRpZXM9JG5ld19wcm9wc1xuIiBvcgoJCWRpZSAid3JpdGUgdG8gJGF0dHJmaWxlOiAkIVxuIjsKCWNsb3NlICRhdHRyZmggb3IgZGllICJjbG9zZSAkYXR0cmZpbGU6ICQhXG4iOwp9CgojIGNtZF9wcm9wbGlzdCAoUEFUSCkKIyAtLS0tLS0tLS0tLS0tLS0tLS0tCiMgUHJpbnQgdGhlIGxpc3Qgb2YgU1ZOIHByb3BlcnRpZXMgZm9yIFBBVEguCnN1YiBjbWRfcHJvcGxpc3QgewoJbXkgJHBhdGggPSBzaGlmdDsKCSRwYXRoID0gJy4nIGlmIG5vdCBkZWZpbmVkICRwYXRoOwoJbXkgJHByb3BzID0gZ2V0X3N2bnByb3BzKCRwYXRoKTsKCXByaW50ICJQcm9wZXJ0aWVzIG9uICckcGF0aCc6XG4iOwoJZm9yZWFjaCAoc29ydCBrZXlzICV7JHByb3BzfSkgewoJCXByaW50ICIgICRfXG4iOwoJfQp9CgpzdWIgY21kX211bHRpX2luaXQgewoJbXkgJHVybCA9IHNoaWZ0OwoJdW5sZXNzIChkZWZpbmVkICRfdHJ1bmsgfHwgQF9icmFuY2hlcyB8fCBAX3RhZ3MpIHsKCQl1c2FnZSgxKTsKCX0KCgkkX3ByZWZpeCA9ICdvcmlnaW4vJyB1bmxlc3MgZGVmaW5lZCAkX3ByZWZpeDsKCWlmIChkZWZpbmVkICR1cmwpIHsKCQkkdXJsID0gY2Fub25pY2FsaXplX3VybCgkdXJsKTsKCQlpbml0X3N1YmRpcihAXyk7Cgl9Cglkb19naXRfaW5pdF9kYigpOwoJaWYgKGRlZmluZWQgJF90cnVuaykgewoJCSRfdHJ1bmsgPX4gcyNeLysjIzsKCQlteSAkdHJ1bmtfcmVmID0gJ3JlZnMvcmVtb3Rlcy8nIC4gJF9wcmVmaXggLiAndHJ1bmsnOwoJCSMgdHJ5IGJvdGggb2xkLXN0eWxlIGFuZCBuZXctc3R5bGUgbG9va3VwczoKCQlteSAkZ3NfdHJ1bmsgPSBldmFsIHsgR2l0OjpTVk4tPm5ldygkdHJ1bmtfcmVmKSB9OwoJCXVubGVzcyAoJGdzX3RydW5rKSB7CgkJCW15ICgkdHJ1bmtfdXJsLCAkdHJ1bmtfcGF0aCkgPQoJCQkgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVfc3ZuX3VybCgkdXJsLCAkX3RydW5rKTsKCQkJJGdzX3RydW5rID0gR2l0OjpTVk4tPmluaXQoJHRydW5rX3VybCwgJHRydW5rX3BhdGgsCgkJCQkJCSAgIHVuZGVmLCAkdHJ1bmtfcmVmKTsKCQl9Cgl9CglyZXR1cm4gdW5sZXNzIEBfYnJhbmNoZXMgfHwgQF90YWdzOwoJbXkgJHJhID0gJHVybCA/IEdpdDo6U1ZOOjpSYS0+bmV3KCR1cmwpIDogdW5kZWY7Cglmb3JlYWNoIG15ICRwYXRoIChAX2JyYW5jaGVzKSB7CgkJY29tcGxldGVfdXJsX2xzX2luaXQoJHJhLCAkcGF0aCwgJy0tYnJhbmNoZXMvLWInLCAkX3ByZWZpeCk7Cgl9Cglmb3JlYWNoIG15ICRwYXRoIChAX3RhZ3MpIHsKCQljb21wbGV0ZV91cmxfbHNfaW5pdCgkcmEsICRwYXRoLCAnLS10YWdzLy10JywgJF9wcmVmaXguJ3RhZ3MvJyk7Cgl9Cn0KCnN1YiBjbWRfbXVsdGlfZmV0Y2ggewoJJEdpdDo6U1ZOOjpub19yZXVzZV9leGlzdGluZyA9IHVuZGVmOwoJbXkgJHJlbW90ZXMgPSBHaXQ6OlNWTjo6cmVhZF9hbGxfcmVtb3RlcygpOwoJZm9yZWFjaCBteSAkcmVwb19pZCAoc29ydCBrZXlzICUkcmVtb3RlcykgewoJCWlmICgkcmVtb3Rlcy0+eyRyZXBvX2lkfS0+e3VybH0pIHsKCQkJR2l0OjpTVk46OmZldGNoX2FsbCgkcmVwb19pZCwgJHJlbW90ZXMpOwoJCX0KCX0KfQoKIyB0aGlzIGNvbW1hbmQgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IHJlcXVpcmVzIG5vIG1ldGFkYXRhCnN1YiBjbWRfY29tbWl0X2RpZmYgewoJbXkgKCR0YSwgJHRiLCAkdXJsKSA9IEBfOwoJbXkgJHVzYWdlID0gInVzYWdlOiAkMCBjb21taXQtZGlmZiAtcjxyZXZpc2lvbj4gIi4KCSAgICAgICAgICAgICI8dHJlZS1pc2g+IDx0cmVlLWlzaD4gWzxVUkw+XSI7CglmYXRhbCgkdXNhZ2UpIGlmICghZGVmaW5lZCAkdGEgfHwgIWRlZmluZWQgJHRiKTsKCW15ICRzdm5fcGF0aCA9ICcnOwoJaWYgKCFkZWZpbmVkICR1cmwpIHsKCQlteSAkZ3MgPSBldmFsIHsgR2l0OjpTVk4tPm5ldyB9OwoJCWlmICghJGdzKSB7CgkJCWZhdGFsKCJOZWVkZWQgVVJMIG9yIHVzYWJsZSBnaXQtc3ZuIC0taWQgaW4gIiwKCQkJICAgICAgInRoZSBjb21tYW5kLWxpbmVcbiIsICR1c2FnZSk7CgkJfQoJCSR1cmwgPSAkZ3MtPnVybDsKCQkkc3ZuX3BhdGggPSAkZ3MtPnBhdGg7Cgl9Cgl1bmxlc3MgKGRlZmluZWQgJF9yZXZpc2lvbikgewoJCWZhdGFsKCItcnwtLXJldmlzaW9uIGlzIGEgcmVxdWlyZWQgYXJndW1lbnRcbiIsICR1c2FnZSk7Cgl9CglpZiAoZGVmaW5lZCAkX21lc3NhZ2UgJiYgZGVmaW5lZCAkX2ZpbGUpIHsKCQlmYXRhbCgiQm90aCAtLW1lc3NhZ2UvLW0gYW5kIC0tZmlsZS8tRiBzcGVjaWZpZWQgIiwKCQkgICAgICAiZm9yIHRoZSBjb21taXQgbWVzc2FnZS5cbiIsCgkJICAgICAgIkkgaGF2ZSBubyBpZGVhIHdoYXQgeW91IG1lYW4iKTsKCX0KCWlmIChkZWZpbmVkICRfZmlsZSkgewoJCSRfbWVzc2FnZSA9IGZpbGVfdG9fcygkX2ZpbGUpOwoJfSBlbHNlIHsKCQkkX21lc3NhZ2UgfHw9IGdldF9jb21taXRfZW50cnkoJHRiKS0+e2xvZ307Cgl9CglteSAkcmEgfHw9IEdpdDo6U1ZOOjpSYS0+bmV3KCR1cmwpOwoJbXkgJHIgPSAkX3JldmlzaW9uOwoJaWYgKCRyIGVxICdIRUFEJykgewoJCSRyID0gJHJhLT5nZXRfbGF0ZXN0X3Jldm51bTsKCX0gZWxzaWYgKCRyICF+IC9eXGQrJC8pIHsKCQlkaWUgInJldmlzaW9uIGFyZ3VtZW50OiAkciBub3QgdW5kZXJzdG9vZCBieSBnaXQtc3ZuXG4iOwoJfQoJbXkgJWVkX29wdHMgPSAoIHIgPT4gJHIsCgkgICAgICAgICAgICAgICAgbG9nID0+ICRfbWVzc2FnZSwKCSAgICAgICAgICAgICAgICByYSA9PiAkcmEsCgkgICAgICAgICAgICAgICAgdHJlZV9hID0+ICR0YSwKCSAgICAgICAgICAgICAgICB0cmVlX2IgPT4gJHRiLAoJICAgICAgICAgICAgICAgIGVkaXRvcl9jYiA9PiBzdWIgeyBwcmludCAiQ29tbWl0dGVkIHIkX1swXVxuIiB9LAoJICAgICAgICAgICAgICAgIHN2bl9wYXRoID0+ICRzdm5fcGF0aCApOwoJaWYgKCFHaXQ6OlNWTjo6RWRpdG9yLT5uZXcoXCVlZF9vcHRzKS0+YXBwbHlfZGlmZikgewoJCXByaW50ICJObyBjaGFuZ2VzXG4kdGEgPT0gJHRiXG4iOwoJfQp9CgpzdWIgY21kX2luZm8gewoJbXkgJHBhdGhfYXJnID0gZGVmaW5lZCgkX1swXSkgPyAkX1swXSA6ICcuJzsKCW15ICRwYXRoID0gJHBhdGhfYXJnOwoJaWYgKEZpbGU6OlNwZWMtPmZpbGVfbmFtZV9pc19hYnNvbHV0ZSgkcGF0aCkpIHsKCQkkcGF0aCA9IGNhbm9uaWNhbGl6ZV9wYXRoKCRwYXRoKTsKCgkJbXkgJHRvcGxldmVsID0gZXZhbCB7CgkJCW15IEBjbWQgPSBxdy9yZXYtcGFyc2UgLS1zaG93LXRvcGxldmVsLzsKCQkJY29tbWFuZF9vbmVsaW5lKFxAY21kLCBTVERFUlIgPT4gMCk7CgkJfTsKCgkJIyByZW1vdmUgJHRvcGxldmVsIGZyb20gdGhlIGFic29sdXRlIHBhdGg6CgkJbXkgKCR2b2wsICRkaXJzLCAkZmlsZSkgPSBGaWxlOjpTcGVjLT5zcGxpdHBhdGgoJHBhdGgpOwoJCW15ICh1bmRlZiwgJHRkaXJzLCAkdGZpbGUpID0gRmlsZTo6U3BlYy0+c3BsaXRwYXRoKCR0b3BsZXZlbCk7CgkJbXkgQGRpcnMgPSBGaWxlOjpTcGVjLT5zcGxpdGRpcigkZGlycyk7CgkJbXkgQHRkaXJzID0gRmlsZTo6U3BlYy0+c3BsaXRkaXIoJHRkaXJzKTsKCQlwb3AgQGRpcnMgaWYgJGRpcnNbLTFdIGVxICcnOwoJCXBvcCBAdGRpcnMgaWYgJHRkaXJzWy0xXSBlcSAnJzsKCQlwdXNoIEBkaXJzLCAkZmlsZTsKCQlwdXNoIEB0ZGlycywgJHRmaWxlOwoJCXdoaWxlIChAdGRpcnMgJiYgQGRpcnMgJiYgJHRkaXJzWzBdIGVxICRkaXJzWzBdKSB7CgkJCXNoaWZ0IEBkaXJzOwoJCQlzaGlmdCBAdGRpcnM7CgkJfQoJCSRkaXJzID0gRmlsZTo6U3BlYy0+Y2F0ZGlyKEBkaXJzKTsKCQkkcGF0aCA9IEZpbGU6OlNwZWMtPmNhdHBhdGgoJHZvbCwgJGRpcnMpOwoKCQkkcGF0aCA9IGNhbm9uaWNhbGl6ZV9wYXRoKCRwYXRoKTsKCX0gZWxzZSB7CgkJJHBhdGggPSBjYW5vbmljYWxpemVfcGF0aCgkY21kX2Rpcl9wcmVmaXggLiAkcGF0aCk7Cgl9CglpZiAoZXhpc3RzICRfWzFdKSB7CgkJZGllICJUb28gbWFueSBhcmd1bWVudHMgc3BlY2lmaWVkXG4iOwoJfQoKCW15ICgkZmlsZV90eXBlLCAkZGlmZl9zdGF0dXMpID0gZmluZF9maWxlX3R5cGVfYW5kX2RpZmZfc3RhdHVzKCRwYXRoKTsKCglpZiAoISRmaWxlX3R5cGUgJiYgISRkaWZmX3N0YXR1cykgewoJCXByaW50IFNUREVSUiAic3ZuOiAnJHBhdGgnIGlzIG5vdCB1bmRlciB2ZXJzaW9uIGNvbnRyb2xcbiI7CgkJZXhpdCAxOwoJfQoKCW15ICgkdXJsLCAkcmV2LCAkdXVpZCwgJGdzKSA9IHdvcmtpbmdfaGVhZF9pbmZvKCdIRUFEJyk7Cgl1bmxlc3MgKCRncykgewoJCWRpZSAiVW5hYmxlIHRvIGRldGVybWluZSB1cHN0cmVhbSBTVk4gaW5mb3JtYXRpb24gZnJvbSAiLAoJCSAgICAid29ya2luZyB0cmVlIGhpc3RvcnlcbiI7Cgl9CgoJIyBjYW5vbmljYWxpemVfcGF0aCgpIHdpbGwgcmV0dXJuICIiIHRvIG1ha2UgbGlic3ZuIDEuNS54IGhhcHB5LAoJJHBhdGggPSAiLiIgaWYgJHBhdGggZXEgIiI7CgoJbXkgJGZ1bGxfdXJsID0gY2Fub25pY2FsaXplX3VybCggYWRkX3BhdGhfdG9fdXJsKCAkdXJsLCAkcGF0aCApICk7CgoJaWYgKCRfdXJsKSB7CgkJcHJpbnQgIiRmdWxsX3VybFxuIjsKCQlyZXR1cm47Cgl9CgoJbXkgJHJlc3VsdCA9ICJQYXRoOiAkcGF0aF9hcmdcbiI7CgkkcmVzdWx0IC49ICJOYW1lOiAiIC4gYmFzZW5hbWUoJHBhdGgpIC4gIlxuIiBpZiAkZmlsZV90eXBlIG5lICJkaXIiOwoJJHJlc3VsdCAuPSAiVVJMOiAkZnVsbF91cmxcbiI7CgoJZXZhbCB7CgkJbXkgJHJlcG9zX3Jvb3QgPSAkZ3MtPnJlcG9zX3Jvb3Q7CgkJR2l0OjpTVk46OnJlbW92ZV91c2VybmFtZSgkcmVwb3Nfcm9vdCk7CgkJJHJlc3VsdCAuPSAiUmVwb3NpdG9yeSBSb290OiAiIC4gY2Fub25pY2FsaXplX3VybCgkcmVwb3Nfcm9vdCkgLiAiXG4iOwoJfTsKCWlmICgkQCkgewoJCSRyZXN1bHQgLj0gIlJlcG9zaXRvcnkgUm9vdDogKG9mZmxpbmUpXG4iOwoJfQoJOjpfcmVxX3N2bigpOwoJJHJlc3VsdCAuPSAiUmVwb3NpdG9yeSBVVUlEOiAkdXVpZFxuIiB1bmxlc3MgJGRpZmZfc3RhdHVzIGVxICJBIiAmJgoJCSg6OmNvbXBhcmVfc3ZuX3ZlcnNpb24oJzEuNS40JykgPD0gMCB8fCAkZmlsZV90eXBlIG5lICJkaXIiKTsKCSRyZXN1bHQgLj0gIlJldmlzaW9uOiAiIC4gKCRkaWZmX3N0YXR1cyBlcSAiQSIgPyAwIDogJHJldikgLiAiXG4iOwoKCSRyZXN1bHQgLj0gIk5vZGUgS2luZDogIiAuCgkJICAgKCRmaWxlX3R5cGUgZXEgImRpciIgPyAiZGlyZWN0b3J5IiA6ICJmaWxlIikgLiAiXG4iOwoKCW15ICRzY2hlZHVsZSA9ICRkaWZmX3N0YXR1cyBlcSAiQSIKCQkgICAgICAgPyAiYWRkIgoJCSAgICAgICA6ICgkZGlmZl9zdGF0dXMgZXEgIkQiID8gImRlbGV0ZSIgOiAibm9ybWFsIik7CgkkcmVzdWx0IC49ICJTY2hlZHVsZTogJHNjaGVkdWxlXG4iOwoKCWlmICgkZGlmZl9zdGF0dXMgZXEgIkEiKSB7CgkJcHJpbnQgJHJlc3VsdCwgIlxuIjsKCQlyZXR1cm47Cgl9CgoJbXkgKCRsY19hdXRob3IsICRsY19yZXYsICRsY19kYXRlX3V0Yyk7CglteSBAYXJncyA9IEdpdDo6U1ZOOjpMb2c6OmdpdF9zdm5fbG9nX2NtZCgkcmV2LCAkcmV2LCAiLS0iLCAkcGF0aCk7CglteSAkbG9nID0gY29tbWFuZF9vdXRwdXRfcGlwZShAYXJncyk7CglteSAkZXNjX2NvbG9yID0gcXIvKD86XDAzM1xbKD86KD86XGQrOykqXGQqKT9tKSovOwoJd2hpbGUgKDwkbG9nPikgewoJCWlmICgvXiR7ZXNjX2NvbG9yfWF1dGhvciAoLispIDxbXj5dKz4gKFxkKykgKFtcLVwrXT9cZCspJC9vKSB7CgkJCSRsY19hdXRob3IgPSAkMTsKCQkJJGxjX2RhdGVfdXRjID0gR2l0OjpTVk46OkxvZzo6cGFyc2VfZ2l0X2RhdGUoJDIsICQzKTsKCQl9IGVsc2lmICgvXiR7ZXNjX2NvbG9yfSAgICAoZ2l0LXN2bi1pZDouKykkL28pIHsKCQkJKHVuZGVmLCAkbGNfcmV2LCB1bmRlZikgPSA6OmV4dHJhY3RfbWV0YWRhdGEoJDEpOwoJCX0KCX0KCWNsb3NlICRsb2c7CgoJR2l0OjpTVk46OkxvZzo6c2V0X2xvY2FsX3RpbWV6b25lKCk7CgoJJHJlc3VsdCAuPSAiTGFzdCBDaGFuZ2VkIEF1dGhvcjogJGxjX2F1dGhvclxuIjsKCSRyZXN1bHQgLj0gIkxhc3QgQ2hhbmdlZCBSZXY6ICRsY19yZXZcbiI7CgkkcmVzdWx0IC49ICJMYXN0IENoYW5nZWQgRGF0ZTogIiAuCgkJICAgR2l0OjpTVk46OkxvZzo6Zm9ybWF0X3N2bl9kYXRlKCRsY19kYXRlX3V0YykgLiAiXG4iOwoKCWlmICgkZmlsZV90eXBlIG5lICJkaXIiKSB7CgkJbXkgJHRleHRfbGFzdF91cGRhdGVkX2RhdGUgPQoJCSAgICAoJGRpZmZfc3RhdHVzIGVxICJEIiA/ICRsY19kYXRlX3V0YyA6IChzdGF0ICRwYXRoKVs5XSk7CgkJJHJlc3VsdCAuPQoJCSAgICAiVGV4dCBMYXN0IFVwZGF0ZWQ6ICIgLgoJCSAgICBHaXQ6OlNWTjo6TG9nOjpmb3JtYXRfc3ZuX2RhdGUoJHRleHRfbGFzdF91cGRhdGVkX2RhdGUpIC4KCQkgICAgIlxuIjsKCQlteSAkY2hlY2tzdW07CgkJaWYgKCRkaWZmX3N0YXR1cyBlcSAiRCIpIHsKCQkJbXkgKCRmaCwgJGN0eCkgPQoJCQkgICAgY29tbWFuZF9vdXRwdXRfcGlwZShxdyhjYXQtZmlsZSBibG9iKSwgIkhFQUQ6JHBhdGgiKTsKCQkJaWYgKCRmaWxlX3R5cGUgZXEgImxpbmsiKSB7CgkJCQlteSAkZmlsZV9uYW1lID0gPCRmaD47CgkJCQkkY2hlY2tzdW0gPSBtZDVzdW0oImxpbmsgJGZpbGVfbmFtZSIpOwoJCQl9IGVsc2UgewoJCQkJJGNoZWNrc3VtID0gbWQ1c3VtKCRmaCk7CgkJCX0KCQkJY29tbWFuZF9jbG9zZV9waXBlKCRmaCwgJGN0eCk7CgkJfSBlbHNpZiAoJGZpbGVfdHlwZSBlcSAibGluayIpIHsKCQkJbXkgJGZpbGVfbmFtZSA9CgkJCSAgICBjb21tYW5kKHF3KGNhdC1maWxlIGJsb2IpLCAiSEVBRDokcGF0aCIpOwoJCQkkY2hlY2tzdW0gPQoJCQkgICAgbWQ1c3VtKCJsaW5rICIgLiAkZmlsZV9uYW1lKTsKCQl9IGVsc2UgewoJCQlvcGVuIEZJTEUsICI8IiwgJHBhdGggb3IgZGllICQhOwoJCQkkY2hlY2tzdW0gPSBtZDVzdW0oXCpGSUxFKTsKCQkJY2xvc2UgRklMRSBvciBkaWUgJCE7CgkJfQoJCSRyZXN1bHQgLj0gIkNoZWNrc3VtOiAiIC4gJGNoZWNrc3VtIC4gIlxuIjsKCX0KCglwcmludCAkcmVzdWx0LCAiXG4iOwp9CgpzdWIgY21kX3Jlc2V0IHsKCW15ICR0YXJnZXQgPSBzaGlmdCB8fCAkX3JldmlzaW9uIG9yIGRpZSAiU1ZOIHJldmlzaW9uIHJlcXVpcmVkXG4iOwoJJHRhcmdldCA9ICQxIGlmICR0YXJnZXQgPX4gL15yKFxkKykkLzsKCSR0YXJnZXQgPX4gL15cZCskLyBvciBkaWUgIk51bWVyaWMgU1ZOIHJldmlzaW9uIGV4cGVjdGVkXG4iOwoJbXkgKCR1cmwsICRyZXYsICR1dWlkLCAkZ3MpID0gd29ya2luZ19oZWFkX2luZm8oJ0hFQUQnKTsKCXVubGVzcyAoJGdzKSB7CgkJZGllICJVbmFibGUgdG8gZGV0ZXJtaW5lIHVwc3RyZWFtIFNWTiBpbmZvcm1hdGlvbiBmcm9tICIuCgkJICAgICJoaXN0b3J5XG4iOwoJfQoJbXkgKCRyLCAkYykgPSAkZ3MtPmZpbmRfcmV2X2JlZm9yZSgkdGFyZ2V0LCBub3QgJF9mZXRjaF9wYXJlbnQpOwoJZGllICJDYW5ub3QgZmluZCBTVk4gcmV2aXNpb24gJHRhcmdldFxuIiB1bmxlc3MgZGVmaW5lZCgkYyk7CgkkZ3MtPnJldl9tYXBfc2V0KCRyLCAkYywgJ3Jlc2V0JywgJHV1aWQpOwoJcHJpbnQgInIkciA9ICRjICgkZ3MtPntyZWZfaWR9KVxuIjsKfQoKc3ViIGNtZF9nYyB7CglyZXF1aXJlIEZpbGU6OkZpbmQ7CglpZiAoIWNhbl9jb21wcmVzcygpKSB7CgkJd2FybiAiQ29tcHJlc3M6OlpsaWIgY291bGQgbm90IGJlIGZvdW5kOyB1bmhhbmRsZWQubG9nICIgLgoJCSAgICAgImZpbGVzIHdpbGwgbm90IGJlIGNvbXByZXNzZWQuXG4iOwoJfQoJRmlsZTo6RmluZDo6ZmluZCh7IHdhbnRlZCA9PiBcJmdjX2RpcmVjdG9yeSwgbm9fY2hkaXIgPT4gMX0sCgkJCSBHaXQ6OlNWTjo6c3ZuX2RpcigpKTsKfQoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIHV0aWxpdHkgZnVuY3Rpb25zICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKCnN1YiByZWJhc2VfY21kIHsKCW15IEBjbWQgPSBxdy9yZWJhc2UvOwoJcHVzaCBAY21kLCAnLXYnIGlmICRfdmVyYm9zZTsKCXB1c2ggQGNtZCwgcXcvLS1tZXJnZS8gaWYgJF9tZXJnZTsKCXB1c2ggQGNtZCwgIi0tc3RyYXRlZ3k9JF9zdHJhdGVneSIgaWYgJF9zdHJhdGVneTsKCXB1c2ggQGNtZCwgIi0tcmViYXNlLW1lcmdlcyIgaWYgJF9yZWJhc2VfbWVyZ2VzOwoJQGNtZDsKfQoKc3ViIHBvc3RfZmV0Y2hfY2hlY2tvdXQgewoJcmV0dXJuIGlmICRfbm9fY2hlY2tvdXQ7CglyZXR1cm4gaWYgdmVyaWZ5X3JlZignSEVBRF4wJyk7CglteSAkZ3MgPSAkR2l0OjpTVk46Ol9oZWFkIG9yIHJldHVybjsKCgkjIGxvb2sgZm9yICJ0cnVuayIgcmVmIGlmIGl0IGV4aXN0cwoJbXkgJHJlbW90ZSA9IEdpdDo6U1ZOOjpyZWFkX2FsbF9yZW1vdGVzKCktPnskZ3MtPntyZXBvX2lkfX07CglteSAkZmV0Y2ggPSAkcmVtb3RlLT57ZmV0Y2h9OwoJaWYgKCRmZXRjaCkgewoJCWZvcmVhY2ggbXkgJHAgKGtleXMgJSRmZXRjaCkgewoJCQliYXNlbmFtZSgkZmV0Y2gtPnskcH0pIGVxICd0cnVuaycgb3IgbmV4dDsKCQkJJGdzID0gR2l0OjpTVk4tPm5ldygkZmV0Y2gtPnskcH0sICRncy0+e3JlcG9faWR9LCAkcCk7CgkJCWxhc3Q7CgkJfQoJfQoKCWNvbW1hbmRfbm9pc3kocXcodXBkYXRlLXJlZiBIRUFEKSwgJGdzLT5yZWZuYW1lKTsKCXJldHVybiB1bmxlc3MgdmVyaWZ5X3JlZignSEVBRF4wJyk7CgoJcmV0dXJuIGlmICRFTlZ7R0lUX0RJUn0gIX4gbSNeKD86LiovKT9cLmdpdCQjOwoJbXkgJGluZGV4ID0gY29tbWFuZF9vbmVsaW5lKHF3KHJldi1wYXJzZSAtLWdpdC1wYXRoIGluZGV4KSk7CglyZXR1cm4gaWYgLWYgJGluZGV4OwoKCXJldHVybiBpZiBjb21tYW5kX29uZWxpbmUocXcvcmV2LXBhcnNlIC0taXMtaW5zaWRlLXdvcmstdHJlZS8pIGVxICdmYWxzZSc7CglyZXR1cm4gaWYgY29tbWFuZF9vbmVsaW5lKHF3L3Jldi1wYXJzZSAtLWlzLWluc2lkZS1naXQtZGlyLykgZXEgJ3RydWUnOwoJY29tbWFuZF9ub2lzeShxdy9yZWFkLXRyZWUgLW0gLXUgLXYgSEVBRCBIRUFELyk7CglwcmludCBTVERFUlIgIkNoZWNrZWQgb3V0IEhFQUQ6XG4gICIsCgkgICAgICAgICAgICAgJGdzLT5mdWxsX3VybCwgIiByIiwgJGdzLT5sYXN0X3JldiwgIlxuIjsKCWlmIChhdXRvX2NyZWF0ZV9lbXB0eV9kaXJlY3RvcmllcygkZ3MpKSB7CgkJJGdzLT5ta2VtcHR5ZGlycygkZ3MtPmxhc3RfcmV2KTsKCX0KfQoKc3ViIGNvbXBsZXRlX3N2bl91cmwgewoJbXkgKCR1cmwsICRwYXRoKSA9IEBfOwoKCWlmICgkcGF0aCA9fiBtI15bYS16XCtdKzovLyNpKSB7ICMgcGF0aCBpcyBhIFVSTAoJCSRwYXRoID0gY2Fub25pY2FsaXplX3VybCgkcGF0aCk7Cgl9IGVsc2UgewoJCSRwYXRoID0gY2Fub25pY2FsaXplX3BhdGgoJHBhdGgpOwoJCWlmICghZGVmaW5lZCAkdXJsIHx8ICR1cmwgIX4gbSNeW2EtelwrXSs6Ly8jaSkgewoJCQlmYXRhbCgiRTogJyRwYXRoJyBpcyBub3QgYSBjb21wbGV0ZSBVUkwgIiwKCQkJICAgICAgImFuZCBhIHNlcGFyYXRlIFVSTCBpcyBub3Qgc3BlY2lmaWVkIik7CgkJfQoJCXJldHVybiAoJHVybCwgJHBhdGgpOwoJfQoJcmV0dXJuICgkcGF0aCwgJycpOwp9CgpzdWIgY29tcGxldGVfdXJsX2xzX2luaXQgewoJbXkgKCRyYSwgJHJlcG9fcGF0aCwgJHN3aXRjaCwgJHBmeCkgPSBAXzsKCXVubGVzcyAoJHJlcG9fcGF0aCkgewoJCXByaW50IFNUREVSUiAiVzogJHN3aXRjaCBub3Qgc3BlY2lmaWVkXG4iOwoJCXJldHVybjsKCX0KCWlmICgkcmVwb19wYXRoID1+IG0jXlthLXpcK10rOi8vI2kpIHsKCQkkcmVwb19wYXRoID0gY2Fub25pY2FsaXplX3VybCgkcmVwb19wYXRoKTsKCQkkcmEgPSBHaXQ6OlNWTjo6UmEtPm5ldygkcmVwb19wYXRoKTsKCQkkcmVwb19wYXRoID0gJyc7Cgl9IGVsc2UgewoJCSRyZXBvX3BhdGggPSBjYW5vbmljYWxpemVfcGF0aCgkcmVwb19wYXRoKTsKCQkkcmVwb19wYXRoID1+IHMjXi8rIyM7CgkJdW5sZXNzICgkcmEpIHsKCQkJZmF0YWwoIkU6ICckcmVwb19wYXRoJyBpcyBub3QgYSBjb21wbGV0ZSBVUkwgIiwKCQkJICAgICAgImFuZCBhIHNlcGFyYXRlIFVSTCBpcyBub3Qgc3BlY2lmaWVkIik7CgkJfQoJfQoJbXkgJHVybCA9ICRyYS0+dXJsOwoJbXkgJGdzID0gR2l0OjpTVk4tPmluaXQoJHVybCwgdW5kZWYsIHVuZGVmLCB1bmRlZiwgMSk7CglteSAkayA9ICJzdm4tcmVtb3RlLiRncy0+e3JlcG9faWR9LnVybCI7CglteSAkb3JpZ191cmwgPSBldmFsIHsgY29tbWFuZF9vbmVsaW5lKHF3L2NvbmZpZyAtLWdldC8sICRrKSB9OwoJaWYgKCRvcmlnX3VybCAmJiAoJG9yaWdfdXJsIG5lICRncy0+dXJsKSkgewoJCWRpZSAiJGsgYWxyZWFkeSBzZXQ6ICRvcmlnX3VybFxuIiwKCQkgICAgIndhbnRlZCB0byBzZXQgdG86ICRncy0+dXJsXG4iOwoJfQoJY29tbWFuZF9vbmVsaW5lKCdjb25maWcnLCAkaywgJGdzLT51cmwpIHVubGVzcyAkb3JpZ191cmw7CgoJbXkgJHJlbW90ZV9wYXRoID0gam9pbl9wYXRocyggJGdzLT5wYXRoLCAkcmVwb19wYXRoICk7CgkkcmVtb3RlX3BhdGggPX4gc3slKFswLTlBLUZdezJ9KX17Y2hyIGhleCgkMSl9aWVnOwoJJHJlbW90ZV9wYXRoID1+IHMjXi8jI2c7CgkkcmVtb3RlX3BhdGggLj0gIi8qIiBpZiAkcmVtb3RlX3BhdGggIX4gL1wqLzsKCW15ICgkbikgPSAoJHN3aXRjaCA9fiAvXi0tKFx3KykvKTsKCWlmIChsZW5ndGggJHBmeCAmJiAkcGZ4ICF+IG0jLyQjKSB7CgkJZGllICItLXByZWZpeD0nJHBmeCcgbXVzdCBoYXZlIGEgdHJhaWxpbmcgc2xhc2ggJy8nXG4iOwoJfQoJY29tbWFuZF9ub2lzeSgnY29uZmlnJywKCQkgICAgICAnLS1hZGQnLAoJICAgICAgICAgICAgICAic3ZuLXJlbW90ZS4kZ3MtPntyZXBvX2lkfS4kbiIsCgkgICAgICAgICAgICAgICIkcmVtb3RlX3BhdGg6cmVmcy9yZW1vdGVzLyRwZngqIiAuCgkgICAgICAgICAgICAgICAgKCcvKicgeCAoKCRyZW1vdGVfcGF0aCA9fiB0ci8qLyovKSAtIDEpKSApOwp9CgpzdWIgdmVyaWZ5X3JlZiB7CglteSAoJHJlZikgPSBAXzsKCWV2YWwgeyBjb21tYW5kX29uZWxpbmUoWyAncmV2LXBhcnNlJywgJy0tdmVyaWZ5JywgJHJlZiBdLAoJICAgICAgICAgICAgICAgICAgICAgICB7IFNUREVSUiA9PiAwIH0pOyB9Owp9CgpzdWIgZ2V0X3RyZWVfZnJvbV90cmVlaXNoIHsKCW15ICgkdHJlZWlzaCkgPSBAXzsKCSMgJHRyZWVpc2ggY2FuIGJlIGEgc3ltYm9saWMgcmVmLCB0b286CglteSAkdHlwZSA9IGNvbW1hbmRfb25lbGluZShxdy9jYXQtZmlsZSAtdC8sICR0cmVlaXNoKTsKCW15ICRleHBlY3RlZDsKCXdoaWxlICgkdHlwZSBlcSAndGFnJykgewoJCSgkdHJlZWlzaCwgJHR5cGUpID0gY29tbWFuZChxdy9jYXQtZmlsZSB0YWcvLCAkdHJlZWlzaCk7Cgl9CglpZiAoJHR5cGUgZXEgJ2NvbW1pdCcpIHsKCQkkZXhwZWN0ZWQgPSAoZ3JlcCAvXnRyZWUgLywgY29tbWFuZChxdy9jYXQtZmlsZSBjb21taXQvLAoJCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0cmVlaXNoKSlbMF07CgkJKCRleHBlY3RlZCkgPSAoJGV4cGVjdGVkID1+IC9edHJlZSAoJG9pZCkkL28pOwoJCWRpZSAiVW5hYmxlIHRvIGdldCB0cmVlIGZyb20gJHRyZWVpc2hcbiIgdW5sZXNzICRleHBlY3RlZDsKCX0gZWxzaWYgKCR0eXBlIGVxICd0cmVlJykgewoJCSRleHBlY3RlZCA9ICR0cmVlaXNoOwoJfSBlbHNlIHsKCQlkaWUgIiR0cmVlaXNoIGlzIGEgJHR5cGUsIGV4cGVjdGVkIHRyZWUsIHRhZyBvciBjb21taXRcbiI7Cgl9CglyZXR1cm4gJGV4cGVjdGVkOwp9CgpzdWIgZ2V0X2NvbW1pdF9lbnRyeSB7CglteSAoJHRyZWVpc2gpID0gc2hpZnQ7CglteSAlbG9nX2VudHJ5ID0gKCBsb2cgPT4gJycsIHRyZWUgPT4gZ2V0X3RyZWVfZnJvbV90cmVlaXNoKCR0cmVlaXNoKSApOwoJbXkgQGdpdF9wYXRoID0gcXcocmV2LXBhcnNlIC0tZ2l0LXBhdGgpOwoJbXkgJGNvbW1pdF9lZGl0bXNnID0gY29tbWFuZF9vbmVsaW5lKEBnaXRfcGF0aCwgJ0NPTU1JVF9FRElUTVNHJyk7CglteSAkY29tbWl0X21zZyA9IGNvbW1hbmRfb25lbGluZShAZ2l0X3BhdGgsICdDT01NSVRfTVNHJyk7CglvcGVuIG15ICRsb2dfZmgsICc+JywgJGNvbW1pdF9lZGl0bXNnIG9yIGNyb2FrICQhOwoKCW15ICR0eXBlID0gY29tbWFuZF9vbmVsaW5lKHF3L2NhdC1maWxlIC10LywgJHRyZWVpc2gpOwoJaWYgKCR0eXBlIGVxICdjb21taXQnIHx8ICR0eXBlIGVxICd0YWcnKSB7CgkJbXkgKCRtc2dfZmgsICRjdHgpID0gY29tbWFuZF9vdXRwdXRfcGlwZSgnY2F0LWZpbGUnLAoJCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHR5cGUsICR0cmVlaXNoKTsKCQlteSAkaW5fbXNnID0gMDsKCQlteSAkYXV0aG9yOwoJCW15ICRzYXdfZnJvbSA9IDA7CgkJbXkgJG1zZ2J1ZiA9ICIiOwoJCXdoaWxlICg8JG1zZ19maD4pIHsKCQkJaWYgKCEkaW5fbXNnKSB7CgkJCQkkaW5fbXNnID0gMSBpZiAoL14kLyk7CgkJCQkkYXV0aG9yID0gJDEgaWYgKC9eYXV0aG9yICguKj4pLyk7CgkJCX0gZWxzaWYgKC9eZ2l0LXN2bi1pZDogLykgewoJCQkJIyBza2lwIHRoaXMgZm9yIG5vdywgd2UgcmVnZW5lcmF0ZSB0aGUKCQkJCSMgY29ycmVjdCBvbmUgb24gcmUtZmV0Y2ggYW55d2F5cwoJCQkJIyBUT0RPOiBzZXQgKjptZXJnZSBwcm9wZXJ0aWVzIG9yIGxpa2UuLi4KCQkJfSBlbHNlIHsKCQkJCWlmICgvXkZyb206LyB8fCAvXlNpZ25lZC1vZmYtYnk6LykgewoJCQkJCSRzYXdfZnJvbSA9IDE7CgkJCQl9CgkJCQkkbXNnYnVmIC49ICRfOwoJCQl9CgkJfQoJCSRtc2didWYgPX4gcy9ccyskLy9zOwoJCSRtc2didWYgPX4gcy9cclxuL1xuL3NnOyAjIFNWTiAxLjYrIGRpc2FsbG93cyBDUkxGCgkJaWYgKCRHaXQ6OlNWTjo6X2FkZF9hdXRob3JfZnJvbSAmJiBkZWZpbmVkKCRhdXRob3IpCgkJICAgICYmICEkc2F3X2Zyb20pIHsKCQkJJG1zZ2J1ZiAuPSAiXG5cbkZyb206ICRhdXRob3IiOwoJCX0KCQlwcmludCAkbG9nX2ZoICRtc2didWYgb3IgY3JvYWsgJCE7CgkJY29tbWFuZF9jbG9zZV9waXBlKCRtc2dfZmgsICRjdHgpOwoJfQoJY2xvc2UgJGxvZ19maCBvciBjcm9hayAkITsKCglpZiAoJF9lZGl0IHx8ICgkdHlwZSBlcSAndHJlZScpKSB7CgkJY2hvbXAobXkgJGVkaXRvciA9IGNvbW1hbmRfb25lbGluZShxdyh2YXIgR0lUX0VESVRPUikpKTsKCQlzeXN0ZW0oJ3NoJywgJy1jJywgJGVkaXRvci4nICIkQCInLCAkZWRpdG9yLCAkY29tbWl0X2VkaXRtc2cpOwoJfQoJcmVuYW1lICRjb21taXRfZWRpdG1zZywgJGNvbW1pdF9tc2cgb3IgY3JvYWsgJCE7Cgl7CgkJcmVxdWlyZSBFbmNvZGU7CgkJIyBTVk4gcmVxdWlyZXMgbWVzc2FnZXMgdG8gYmUgVVRGLTggd2hlbiBlbnRlcmluZyB0aGUgcmVwbwoJCW9wZW4gJGxvZ19maCwgJzwnLCAkY29tbWl0X21zZyBvciBjcm9hayAkITsKCQliaW5tb2RlICRsb2dfZmg7CgkJY2hvbXAoJGxvZ19lbnRyeXtsb2d9ID0gZ2V0X3JlY29yZCgkbG9nX2ZoLCB1bmRlZikpOwoKCQlteSAkZW5jID0gR2l0Ojpjb25maWcoJ2kxOG4uY29tbWl0ZW5jb2RpbmcnKSB8fCAnVVRGLTgnOwoJCW15ICRtc2cgPSAkbG9nX2VudHJ5e2xvZ307CgoJCWV2YWwgeyAkbXNnID0gRW5jb2RlOjpkZWNvZGUoJGVuYywgJG1zZywgMSkgfTsKCQlpZiAoJEApIHsKCQkJZGllICJDb3VsZCBub3QgZGVjb2RlIGFzICRlbmM6XG4iLCAkbXNnLAoJCQkgICAgIlxuUGVyaGFwcyB5b3UgbmVlZCB0byBzZXQgaTE4bi5jb21taXRlbmNvZGluZ1xuIjsKCQl9CgoJCWV2YWwgeyAkbXNnID0gRW5jb2RlOjplbmNvZGUoJ1VURi04JywgJG1zZywgMSkgfTsKCQlkaWUgIkNvdWxkIG5vdCBlbmNvZGUgYXMgVVRGLTg6XG4kbXNnXG4iIGlmICRAOwoKCQkkbG9nX2VudHJ5e2xvZ30gPSAkbXNnOwoKCQljbG9zZSAkbG9nX2ZoIG9yIGNyb2FrICQhOwoJfQoJdW5saW5rICRjb21taXRfbXNnOwoJXCVsb2dfZW50cnk7Cn0KCnN1YiBzX3RvX2ZpbGUgewoJbXkgKCRzdHIsICRmaWxlLCAkbW9kZSkgPSBAXzsKCW9wZW4gbXkgJGZkLCc+JywkZmlsZSBvciBjcm9hayAkITsKCXByaW50ICRmZCAkc3RyLCJcbiIgb3IgY3JvYWsgJCE7CgljbG9zZSAkZmQgb3IgY3JvYWsgJCE7CgljaG1vZCAoJG1vZGUgJn4gdW1hc2ssICRmaWxlKSBpZiAoZGVmaW5lZCAkbW9kZSk7Cn0KCnN1YiBmaWxlX3RvX3MgewoJbXkgJGZpbGUgPSBzaGlmdDsKCW9wZW4gbXkgJGZkLCc8JywkZmlsZSBvciBjcm9hayAiJCE6IGZpbGU6ICRmaWxlXG4iOwoJbG9jYWwgJC87CglteSAkcmV0ID0gPCRmZD47CgljbG9zZSAkZmQgb3IgY3JvYWsgJCE7CgkkcmV0ID1+IHMvXHMqJC8vczsKCXJldHVybiAkcmV0Owp9CgojICc8c3ZuIHVzZXJuYW1lPiA9IHJlYWwtbmFtZSA8ZW1haWwgYWRkcmVzcz4nIG1hcHBpbmcgYmFzZWQgb24gZ2l0LXN2bmltcG9ydDoKc3ViIGxvYWRfYXV0aG9ycyB7CglvcGVuIG15ICRhdXRob3JzLCAnPCcsICRfYXV0aG9ycyBvciBkaWUgIkNhbid0IG9wZW4gJF9hdXRob3JzICQhXG4iOwoJbXkgJGxvZyA9ICRjbWQgZXEgJ2xvZyc7Cgl3aGlsZSAoPCRhdXRob3JzPikgewoJCWNob21wOwoJCW5leHQgdW5sZXNzIC9eKC4rP3xcKG5vIGF1dGhvclwpKVxzKj1ccyooLis/KVxzKjwoLiopPlxzKiQvOwoJCW15ICgkdXNlciwgJG5hbWUsICRlbWFpbCkgPSAoJDEsICQyLCAkMyk7CgkJaWYgKCRsb2cpIHsKCQkJJEdpdDo6U1ZOOjpMb2c6OnJ1c2Vyc3siJG5hbWUgPCRlbWFpbD4ifSA9ICR1c2VyOwoJCX0gZWxzZSB7CgkJCSR1c2Vyc3skdXNlcn0gPSBbJG5hbWUsICRlbWFpbF07CgkJfQoJfQoJY2xvc2UgJGF1dGhvcnMgb3IgY3JvYWsgJCE7Cn0KCiMgY29udmVydCBHZXRPcHQ6Okxvbmcgc3BlY3MgZm9yIHVzZSBieSBnaXQtY29uZmlnCnN1YiByZWFkX2dpdF9jb25maWcgewoJbXkgJG9wdHMgPSBzaGlmdDsKCW15IEBjb25maWdfb25seTsKCWZvcmVhY2ggbXkgJG8gKGtleXMgJSRvcHRzKSB7CgkJIyBpZiB3ZSBoYXZlIG1peGVkQ2FzZSBhbmQgYSBsb25nIG9wdGlvbi1vbmx5LCB0aGVuCgkJIyBpdCdzIGEgY29uZmlnLW9ubHkgdmFyaWFibGUgdGhhdCB3ZSBkb24ndCBuZWVkIGZvcgoJCSMgdGhlIGNvbW1hbmQtbGluZS4KCQlwdXNoIEBjb25maWdfb25seSwgJG8gaWYgKCRvID1+IC9bQS1aXS8gJiYgJG8gPX4gL15bYS16XSskL2kpOwoJCW15ICR2ID0gJG9wdHMtPnskb307CgkJbXkgKCRrZXkpID0gKCRvID1+IC9eKFthLXpBLVpcLV0rKS8pOwoJCSRrZXkgPX4gcy8tLy9nOwoJCW15ICRhcmcgPSAnZ2l0IGNvbmZpZyc7CgkJJGFyZyAuPSAnIC0taW50JyBpZiAoJG8gPX4gL1s6PV1pJC8pOwoJCSRhcmcgLj0gJyAtLWJvb2wnIGlmICgkbyAhfiAvWzo9XVtzZmldJC8pOwoJCWlmIChyZWYgJHYgZXEgJ0FSUkFZJykgewoJCQljaG9tcChteSBAdG1wID0gYCRhcmcgLS1nZXQtYWxsIHN2bi4ka2V5YCk7CgkJCUAkdiA9IEB0bXAgaWYgQHRtcDsKCQl9IGVsc2UgewoJCQljaG9tcChteSAkdG1wID0gYCRhcmcgLS1nZXQgc3ZuLiRrZXlgKTsKCQkJaWYgKCR0bXAgJiYgISgkYXJnID1+IC8gLS1ib29sLyAmJiAkdG1wIGVxICdmYWxzZScpKSB7CgkJCQkkJHYgPSAkdG1wOwoJCQl9CgkJfQoJfQoJZGVsZXRlIEAkb3B0c3tAY29uZmlnX29ubHl9IGlmIEBjb25maWdfb25seTsKfQoKc3ViIGV4dHJhY3RfbWV0YWRhdGEgewoJbXkgJGlkID0gc2hpZnQgb3IgcmV0dXJuICh1bmRlZiwgdW5kZWYsIHVuZGVmKTsKCW15ICgkdXJsLCAkcmV2LCAkdXVpZCkgPSAoJGlkID1+IC9eXHMqZ2l0LXN2bi1pZDpccysoLiopXEAoXGQrKQoJCQkJCQkJXHMoW2EtZlxkXC1dKykkL2l4KTsKCWlmICghZGVmaW5lZCAkcmV2IHx8ICEkdXVpZCB8fCAhJHVybCkgewoJCSMgc29tZSBvZiB0aGUgb3JpZ2luYWwgcmVwb3NpdG9yaWVzIEkgbWFkZSBoYWQKCQkjIGlkZW50aWZpZXJzIGxpa2UgdGhpczoKCQkoJHJldiwgJHV1aWQpID0gKCRpZCA9fi9eXHMqZ2l0LXN2bi1pZDpccyhcZCspXEAoW2EtZlxkXC1dKykvaSk7Cgl9CglyZXR1cm4gKCR1cmwsICRyZXYsICR1dWlkKTsKfQoKc3ViIGNtdF9tZXRhZGF0YSB7CglyZXR1cm4gZXh0cmFjdF9tZXRhZGF0YSgoZ3JlcCgvXmdpdC1zdm4taWQ6IC8sCgkJY29tbWFuZChxdy9jYXQtZmlsZSBjb21taXQvLCBzaGlmdCkpKVstMV0pOwp9CgpzdWIgY210X3NoYTJyZXZfYmF0Y2ggewoJbXkgJXMycjsKCW15ICgkcGlkLCAkaW4sICRvdXQsICRjdHgpID0gY29tbWFuZF9iaWRpX3BpcGUocXcvY2F0LWZpbGUgLS1iYXRjaC8pOwoJbXkgJGxpc3QgPSBzaGlmdDsKCglmb3JlYWNoIG15ICRzaGEgKEB7JGxpc3R9KSB7CgkJbXkgJGZpcnN0ID0gMTsKCQlteSAkc2l6ZSA9IDA7CgkJcHJpbnQgJG91dCAkc2hhLCAiXG4iOwoKCQl3aGlsZSAobXkgJGxpbmUgPSA8JGluPikgewoJCQlpZiAoJGZpcnN0ICYmICRsaW5lID1+IC9eJDo6b2lkXHNtaXNzaW5nJC8pIHsKCQkJCWxhc3Q7CgkJCX0gZWxzaWYgKCRmaXJzdCAmJgoJCQkgICAgICAgJGxpbmUgPX4gL14kOjpvaWRcc2NvbW1pdFxzKFxkKykkLykgewoJCQkJJGZpcnN0ID0gMDsKCQkJCSRzaXplID0gJDE7CgkJCQluZXh0OwoJCQl9IGVsc2lmICgkbGluZSA9fiAvXihnaXQtc3ZuLWlkOiApLykgewoJCQkJbXkgKHVuZGVmLCAkcmV2LCB1bmRlZikgPQoJCQkJICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RfbWV0YWRhdGEoJGxpbmUpOwoJCQkJJHMycnskc2hhfSA9ICRyZXY7CgkJCX0KCgkJCSRzaXplIC09IGxlbmd0aCgkbGluZSk7CgkJCWxhc3QgaWYgKCRzaXplID09IDApOwoJCX0KCX0KCgljb21tYW5kX2Nsb3NlX2JpZGlfcGlwZSgkcGlkLCAkaW4sICRvdXQsICRjdHgpOwoKCXJldHVybiBcJXMycjsKfQoKc3ViIHdvcmtpbmdfaGVhZF9pbmZvIHsKCW15ICgkaGVhZCwgJHJlZnMpID0gQF87CglteSBAYXJncyA9IHF3L3Jldi1saXN0IC0tZmlyc3QtcGFyZW50IC0tcHJldHR5PW1lZGl1bS87CglteSAoJGZoLCAkY3R4KSA9IGNvbW1hbmRfb3V0cHV0X3BpcGUoQGFyZ3MsICRoZWFkLCAiLS0iKTsKCW15ICRoYXNoOwoJbXkgJW1heDsKCXdoaWxlICg8JGZoPikgewoJCWlmICggbXteY29tbWl0ICgkOjpvaWQpJH0gKSB7CgkJCXVuc2hpZnQgQCRyZWZzLCAkaGFzaCBpZiAkaGFzaCBhbmQgJHJlZnM7CgkJCSRoYXNoID0gJDE7CgkJCW5leHQ7CgkJfQoJCW5leHQgdW5sZXNzIHN7XlxzKihnaXQtc3ZuLWlkOil9eyQxfTsKCQlteSAoJHVybCwgJHJldiwgJHV1aWQpID0gZXh0cmFjdF9tZXRhZGF0YSgkXyk7CgkJaWYgKGRlZmluZWQgJHVybCAmJiBkZWZpbmVkICRyZXYpIHsKCQkJbmV4dCBpZiAkbWF4eyR1cmx9IGFuZCAkbWF4eyR1cmx9IDwgJHJldjsKCQkJaWYgKG15ICRncyA9IEdpdDo6U1ZOLT5maW5kX2J5X3VybCgkdXJsKSkgewoJCQkJbXkgJGMgPSAkZ3MtPnJldl9tYXBfZ2V0KCRyZXYsICR1dWlkKTsKCQkJCWlmICgkYyAmJiAkYyBlcSAkaGFzaCkgewoJCQkJCWNsb3NlICRmaDsgIyBicmVhayB0aGUgcGlwZQoJCQkJCXJldHVybiAoJHVybCwgJHJldiwgJHV1aWQsICRncyk7CgkJCQl9IGVsc2UgewoJCQkJCSRtYXh7JHVybH0gfHw9ICRncy0+cmV2X21hcF9tYXg7CgkJCQl9CgkJCX0KCQl9Cgl9Cgljb21tYW5kX2Nsb3NlX3BpcGUoJGZoLCAkY3R4KTsKCSh1bmRlZiwgdW5kZWYsIHVuZGVmLCB1bmRlZik7Cn0KCnN1YiByZWFkX2NvbW1pdF9wYXJlbnRzIHsKCW15ICgkcGFyZW50cywgJGMpID0gQF87CgljaG9tcChteSAkcCA9IGNvbW1hbmRfb25lbGluZShxdy9yZXYtbGlzdCAtLXBhcmVudHMgLTEvLCAkYykpOwoJJHAgPX4gcy9eKCRjKVxzKi8vIG9yIGRpZSAicmV2LWxpc3QgLS1wYXJlbnRzIC0xICRjIGZhaWxlZCFcbiI7CglAeyRwYXJlbnRzLT57JGN9fSA9IHNwbGl0KC8gLywgJHApOwp9CgpzdWIgbGluZWFyaXplX2hpc3RvcnkgewoJbXkgKCRncywgJHJlZnMpID0gQF87CglteSAlcGFyZW50czsKCWZvcmVhY2ggbXkgJGMgKEAkcmVmcykgewoJCXJlYWRfY29tbWl0X3BhcmVudHMoXCVwYXJlbnRzLCAkYyk7Cgl9CgoJbXkgQGxpbmVhcl9yZWZzOwoJbXkgJXNraXAgPSAoKTsKCW15ICRsYXN0X3N2bl9jb21taXQgPSAkZ3MtPmxhc3RfY29tbWl0OwoJZm9yZWFjaCBteSAkYyAocmV2ZXJzZSBAJHJlZnMpIHsKCQluZXh0IGlmICRjIGVxICRsYXN0X3N2bl9jb21taXQ7CgkJbGFzdCBpZiAkc2tpcHskY307CgoJCXVuc2hpZnQgQGxpbmVhcl9yZWZzLCAkYzsKCQkkc2tpcHskY30gPSAxOwoKCQkjIHdlIG9ubHkgd2FudCB0aGUgZmlyc3QgcGFyZW50IHRvIGRpZmYgYWdhaW5zdCBmb3IgbGluZWFyCgkJIyBoaXN0b3J5LCB3ZSBzYXZlIHRoZSByZXN0IHRvIGluamVjdCB3aGVuIHdlIGZpbmFsaXplIHRoZQoJCSMgc3ZuIGNvbW1pdAoJCW15ICRmcF9hID0gdmVyaWZ5X3JlZigiJGN+MSIpOwoJCW15ICRmcF9iID0gc2hpZnQgQHskcGFyZW50c3skY319IGlmICRwYXJlbnRzeyRjfTsKCQlpZiAoISRmcF9hIHx8ICEkZnBfYikgewoJCQlkaWUgIkNvbW1pdCAkY1xuIiwKCQkJICAgICJoYXMgbm8gcGFyZW50IGNvbW1pdCwgYW5kIHRoZXJlZm9yZSAiLAoJCQkgICAgIm5vdGhpbmcgdG8gZGlmZiBhZ2FpbnN0LlxuIiwKCQkJICAgICJZb3Ugc2hvdWxkIGJlIHdvcmtpbmcgZnJvbSBhIHJlcG9zaXRvcnkgIiwKCQkJICAgICJvcmlnaW5hbGx5IGNyZWF0ZWQgYnkgZ2l0LXN2blxuIjsKCQl9CgkJaWYgKCRmcF9hIG5lICRmcF9iKSB7CgkJCWRpZSAiJGN+MSA9ICRmcF9hLCBob3dldmVyIHBhcnNpbmcgY29tbWl0ICRjICIsCgkJCSAgICAicmV2ZWFsZWQgdGhhdDpcbiRjfjEgPSAkZnBfYlxuQlVHIVxuIjsKCQl9CgoJCWZvcmVhY2ggbXkgJHAgKEB7JHBhcmVudHN7JGN9fSkgewoJCQkkc2tpcHskcH0gPSAxOwoJCX0KCX0KCShcQGxpbmVhcl9yZWZzLCBcJXBhcmVudHMpOwp9CgpzdWIgZmluZF9maWxlX3R5cGVfYW5kX2RpZmZfc3RhdHVzIHsKCW15ICgkcGF0aCkgPSBAXzsKCXJldHVybiAoJ2RpcicsICcnKSBpZiAkcGF0aCBlcSAnJzsKCglteSAkZGlmZl9vdXRwdXQgPQoJICAgIGNvbW1hbmRfb25lbGluZShxdyhkaWZmIC0tY2FjaGVkIC0tbmFtZS1zdGF0dXMgLS0pLCAkcGF0aCkgfHwgIiI7CglteSAkZGlmZl9zdGF0dXMgPSAoc3BsaXQoJyAnLCAkZGlmZl9vdXRwdXQpKVswXSB8fCAiIjsKCglteSAkbHNfdHJlZSA9IGNvbW1hbmRfb25lbGluZShxdyhscy10cmVlIEhFQUQpLCAkcGF0aCkgfHwgIiI7CgoJcmV0dXJuICh1bmRlZiwgdW5kZWYpIGlmICEkZGlmZl9zdGF0dXMgJiYgISRsc190cmVlOwoKCWlmICgkZGlmZl9zdGF0dXMgZXEgIkEiKSB7CgkJcmV0dXJuICgibGluayIsICRkaWZmX3N0YXR1cykgaWYgLWwgJHBhdGg7CgkJcmV0dXJuICgiZGlyIiwgJGRpZmZfc3RhdHVzKSBpZiAtZCAkcGF0aDsKCQlyZXR1cm4gKCJmaWxlIiwgJGRpZmZfc3RhdHVzKTsKCX0KCglteSAkbW9kZSA9IChzcGxpdCgnICcsICRsc190cmVlKSlbMF0gfHwgIiI7CgoJcmV0dXJuICgibGluayIsICRkaWZmX3N0YXR1cykgaWYgJG1vZGUgZXEgIjEyMDAwMCI7CglyZXR1cm4gKCJkaXIiLCAkZGlmZl9zdGF0dXMpIGlmICRtb2RlIGVxICIwNDAwMDAiOwoJcmV0dXJuICgiZmlsZSIsICRkaWZmX3N0YXR1cyk7Cn0KCnN1YiBtZDVzdW0gewoJbXkgJGFyZyA9IHNoaWZ0OwoJbXkgJHJlZiA9IHJlZiAkYXJnOwoJcmVxdWlyZSBEaWdlc3Q6Ok1ENTsKCW15ICRtZDUgPSBEaWdlc3Q6Ok1ENS0+bmV3KCk7CiAgICAgICAgaWYgKCRyZWYgZXEgJ0dMT0InIHx8ICRyZWYgZXEgJ0lPOjpGaWxlJyB8fCAkcmVmIGVxICdGaWxlOjpUZW1wJykgewoJCSRtZDUtPmFkZGZpbGUoJGFyZykgb3IgY3JvYWsgJCE7Cgl9IGVsc2lmICgkcmVmIGVxICdTQ0FMQVInKSB7CgkJJG1kNS0+YWRkKCQkYXJnKSBvciBjcm9hayAkITsKCX0gZWxzaWYgKCEkcmVmKSB7CgkJJG1kNS0+YWRkKCRhcmcpIG9yIGNyb2FrICQhOwoJfSBlbHNlIHsKCQlmYXRhbCAiQ2FuJ3QgcHJvdmlkZSBNRDUgaGFzaCBmb3IgdW5rbm93biByZWYgdHlwZTogJyIsICRyZWYsICInIjsKCX0KCXJldHVybiAkbWQ1LT5oZXhkaWdlc3QoKTsKfQoKc3ViIGdjX2RpcmVjdG9yeSB7CglpZiAoY2FuX2NvbXByZXNzKCkgJiYgLWYgJF8gJiYgYmFzZW5hbWUoJF8pIGVxICJ1bmhhbmRsZWQubG9nIikgewoJCW15ICRvdXRfZmlsZW5hbWUgPSAkXyAuICIuZ3oiOwoJCW9wZW4gbXkgJGluX2ZoLCAiPCIsICRfIG9yIGRpZSAiVW5hYmxlIHRvIG9wZW4gJF86ICQhXG4iOwoJCWJpbm1vZGUgJGluX2ZoOwoJCW15ICRneiA9IENvbXByZXNzOjpabGliOjpnem9wZW4oJG91dF9maWxlbmFtZSwgImFiIikgb3IKCQkJCWRpZSAiVW5hYmxlIHRvIG9wZW4gJG91dF9maWxlbmFtZTogJCFcbiI7CgoJCW15ICRyZXM7CgkJd2hpbGUgKCRyZXMgPSBzeXNyZWFkKCRpbl9maCwgbXkgJHN0ciwgMTAyNCkpIHsKCQkJJGd6LT5nendyaXRlKCRzdHIpIG9yCgkJCQlkaWUgIlVuYWJsZSB0byB3cml0ZTogIi4kZ3otPmd6ZXJyb3IoKS4iIVxuIjsKCQl9CgkJbm8gd2FybmluZ3MgJ29uY2UnOyAjICRGaWxlOjpGaW5kOjpuYW1lIHdvdWxkIHdhcm4KCQl1bmxpbmsgJF8gb3IgZGllICJ1bmxpbmsgJEZpbGU6OkZpbmQ6Om5hbWU6ICQhXG4iOwoJfSBlbHNpZiAoLWYgJF8gJiYgYmFzZW5hbWUoJF8pIGVxICJpbmRleCIpIHsKCQl1bmxpbmsgJF8gb3IgZGllICJ1bmxpbmsgJF86ICQhXG4iOwoJfQp9CgpfX0VORF9fCgpEYXRhIHN0cnVjdHVyZXM6CgoKJHJlbW90ZXMgPSB7ICMgcmV0dXJuZWQgYnkgcmVhZF9hbGxfcmVtb3RlcygpCgknc3ZuJyA9PiB7CgkJIyBzdm4tcmVtb3RlLnN2bi51cmw9aHR0cHM6Ly9zdm4ubXVzaWNwZC5vcmcKCQl1cmwgPT4gJ2h0dHBzOi8vc3ZuLm11c2ljcGQub3JnJywKCQkjIHN2bi1yZW1vdGUuc3ZuLmZldGNoPW1wZC90cnVuazp0cnVuawoJCWZldGNoID0+IHsKCQkJJ21wZC90cnVuaycgPT4gJ3RydW5rJywKCQl9LAoJCSMgc3ZuLXJlbW90ZS5zdm4udGFncz1tcGQvdGFncy8qOnRhZ3MvKgoJCXRhZ3MgPT4gewoJCQlwYXRoID0+IHsKCQkJCWxlZnQgPT4gJ21wZC90YWdzJywKCQkJCXJpZ2h0ID0+ICcnLAoJCQkJcmVnZXggPT4gcXIhbXBkL3RhZ3MvKFteL10rKSQhLAoJCQkJZ2xvYiA9PiAndGFncy8qJywKCQkJfSwKCQkJcmVmID0+IHsKCQkJCWxlZnQgPT4gJ3RhZ3MnLAoJCQkJcmlnaHQgPT4gJycsCgkJCQlyZWdleCA9PiBxciF0YWdzLyhbXi9dKykkISwKCQkJCWdsb2IgPT4gJ3RhZ3MvKicsCgkJCX0sCgkJfQoJfQp9OwoKJGxvZ19lbnRyeSBoYXNocmVmIGFzIHJldHVybmVkIGJ5IGxpYnN2bl9sb2dfZW50cnkoKQp7Cglsb2cgPT4gJ3doaXRlc3BhY2UtZm9ybWF0dGVkIGxvZyBlbnRyeQonLAkJCQkJCSMgdHJhaWxpbmcgbmV3bGluZSBpcyBwcmVzZXJ2ZWQKCXJldmlzaW9uID0+ICc4JywJCQkjIGludGVnZXIKCWRhdGUgPT4gJzIwMDQtMDItMjRUMTc6MDE6NDQuMTA4MzQ1WicsCSMgY29tbWl0IGRhdGUKCWF1dGhvciA9PiAnY29tbWl0dGVyIG5hbWUnCn07CgoKIyB0aGlzIGlzIGdlbmVyYXRlZCBieSBnZW5lcmF0ZV9kaWZmKCk7CkBtb2RzID0gYXJyYXkgb2YgZGlmZi1pbmRleCBsaW5lIGhhc2hlcywgZWFjaCBlbGVtZW50IHJlcHJlc2VudHMgb25lIGxpbmUKCW9mIGRpZmYtaW5kZXggb3V0cHV0CgpkaWZmLWluZGV4IGxpbmUgKCRtIGhhc2gpCnsKCW1vZGVfYSA9PiBmaXJzdCBjb2x1bW4gb2YgZGlmZi1pbmRleCBvdXRwdXQsIG5vIGxlYWRpbmcgJzonLAoJbW9kZV9iID0+IHNlY29uZCBjb2x1bW4gb2YgZGlmZi1pbmRleCBvdXRwdXQsCglzaGExX2IgPT4gc2hhMXN1bSBvZiB0aGUgZmluYWwgYmxvYiwKCWNoZyA9PiBjaGFuZ2UgdHlwZSBbTUNSQURUXSwKCWZpbGVfYSA9PiBvcmlnaW5hbCBmaWxlIG5hbWUgb2YgYSBmaWxlIChpZmYgY2hnIGlzICdDJyBvciAnUicpCglmaWxlX2IgPT4gbmV3L2N1cnJlbnQgZmlsZSBuYW1lIG9mIGEgZmlsZSAoYW55IGNoZykKfQo7CgojIHJldHZhbCBvZiByZWFkX3VybF9wYXRoc3ssX2FsbH0oKTsKJGxfbWFwID0gewoJIyByZXBvc2l0b3J5IHJvb3QgdXJsCgknaHR0cHM6Ly9zdm4ubXVzaWNwZC5vcmcnID0+IHsKCQkjIHJlcG9zaXRvcnkgcGF0aCAJCSMgR0lUX1NWTl9JRAoJCSdtcGQvdHJ1bmsnCQk9PgkndHJ1bmsnLAoJCSdtcGQvdGFncy8wLjExLjUnCT0+CSd0YWdzLzAuMTEuNScsCgl9LAp9CgpOb3RlczoKCUkgZG9uJ3QgdHJ1c3QgdGhlIGVhY2goKSBmdW5jdGlvbiBvbiB1bmxlc3MgSSBjcmVhdGVkICVoYXNoIG15c2VsZgoJYmVjYXVzZSB0aGUgaW50ZXJuYWwgaXRlcmF0b3IgbWF5IG5vdCBoYXZlIHN0YXJ0ZWQgYXQgYmFzZS4K",
    "text": "#!/usr/bin/perl\n# Copyright (C) 2006, Eric Wong <normalperson@yhbt.net>\n# License: GPL v2 or later\nuse 5.008;\nuse warnings;\nuse strict;\nuse vars qw/\t$AUTHOR $VERSION\n\t\t$oid $oid_short $oid_length\n\t\t$_revision $_repository\n\t\t$_q $_authors $_authors_prog %users/;\n$AUTHOR = 'Eric Wong <normalperson@yhbt.net>';\n$VERSION = '@@GIT_VERSION@@';\n\nuse Carp qw/croak/;\nuse File::Basename qw/dirname basename/;\nuse File::Path qw/mkpath/;\nuse File::Spec;\nuse Getopt::Long qw/:config gnu_getopt no_ignore_case auto_abbrev/;\nuse Memoize;\n\nuse Git::SVN;\nuse Git::SVN::Editor;\nuse Git::SVN::Fetcher;\nuse Git::SVN::Ra;\nuse Git::SVN::Prompt;\nuse Git::SVN::Log;\nuse Git::SVN::Migration;\n\nuse Git::SVN::Utils qw(\n\tfatal\n\tcan_compress\n\tcanonicalize_path\n\tcanonicalize_url\n\tjoin_paths\n\tadd_path_to_url\n\tjoin_paths\n);\n\nuse Git qw(\n\tgit_cmd_try\n\tcommand\n\tcommand_oneline\n\tcommand_noisy\n\tcommand_output_pipe\n\tcommand_close_pipe\n\tcommand_bidi_pipe\n\tcommand_close_bidi_pipe\n\tget_record\n);\n\nBEGIN {\n\tMemoize::memoize 'Git::config';\n\tMemoize::memoize 'Git::config_bool';\n}\n\n\n# From which subdir have we been invoked?\nmy $cmd_dir_prefix = eval {\n\tcommand_oneline([qw/rev-parse --show-prefix/], STDERR => 0)\n} || '';\n\n$Git::SVN::Ra::_log_window_size = 100;\n\nif (! exists $ENV{SVN_SSH} && exists $ENV{GIT_SSH}) {\n\t$ENV{SVN_SSH} = $ENV{GIT_SSH};\n}\n\nif (exists $ENV{SVN_SSH} && $^O eq 'msys') {\n\t$ENV{SVN_SSH} =~ s/\\\\/\\\\\\\\/g;\n\t$ENV{SVN_SSH} =~ s/(.*)/\"$1\"/;\n}\n\n$Git::SVN::Log::TZ = $ENV{TZ};\n$ENV{TZ} = 'UTC';\n$| = 1; # unbuffer STDOUT\n\n# All SVN commands do it.  Otherwise we may die on SIGPIPE when the remote\n# repository decides to close the connection which we expect to be kept alive.\n$SIG{PIPE} = 'IGNORE';\n\n# Given a dot separated version number, \"subtract\" it from\n# the SVN::Core::VERSION; non-negaitive return means the SVN::Core\n# is at least at the version the caller asked for.\nsub compare_svn_version {\n\tmy (@ours) = split(/\\./, $SVN::Core::VERSION);\n\tmy (@theirs) = split(/\\./, $_[0]);\n\tmy ($i, $diff);\n\n\tfor ($i = 0; $i < @ours && $i < @theirs; $i++) {\n\t\t$diff = $ours[$i] - $theirs[$i];\n\t\treturn $diff if ($diff);\n\t}\n\treturn 1 if ($i < @ours);\n\treturn -1 if ($i < @theirs);\n\treturn 0;\n}\n\nsub _req_svn {\n\trequire SVN::Core; # use()-ing this causes segfaults for me... *shrug*\n\trequire SVN::Ra;\n\trequire SVN::Delta;\n\tif (::compare_svn_version('1.1.0') < 0) {\n\t\tfatal \"Need SVN::Core 1.1.0 or better (got $SVN::Core::VERSION)\";\n\t}\n}\n\n$oid = qr/(?:[a-f\\d]{40}(?:[a-f\\d]{24})?)/;\n$oid_short = qr/[a-f\\d]{4,64}/;\n$oid_length = 40;\nmy ($_stdin, $_help, $_edit,\n\t$_message, $_file, $_branch_dest,\n\t$_template, $_shared,\n\t$_version, $_fetch_all, $_no_rebase, $_fetch_parent,\n\t$_before, $_after,\n\t$_merge, $_strategy, $_rebase_merges, $_dry_run, $_parents, $_local,\n\t$_prefix, $_no_checkout, $_url, $_verbose,\n\t$_commit_url, $_tag, $_merge_info, $_interactive, $_set_svn_props);\n\n# This is a refactoring artifact so Git::SVN can get at this git-svn switch.\nsub opt_prefix { return $_prefix || '' }\n\n$Git::SVN::Fetcher::_placeholder_filename = \".gitignore\";\n$_q ||= 0;\nmy %remote_opts = ( 'username=s' => \\$Git::SVN::Prompt::_username,\n                    'config-dir=s' => \\$Git::SVN::Ra::config_dir,\n                    'no-auth-cache' => \\$Git::SVN::Prompt::_no_auth_cache,\n                    'ignore-paths=s' => \\$Git::SVN::Fetcher::_ignore_regex,\n                    'include-paths=s' => \\$Git::SVN::Fetcher::_include_regex,\n                    'ignore-refs=s' => \\$Git::SVN::Ra::_ignore_refs_regex );\nmy %fc_opts = ( 'follow-parent|follow!' => \\$Git::SVN::_follow_parent,\n\t\t'authors-file|A=s' => \\$_authors,\n\t\t'authors-prog=s' => \\$_authors_prog,\n\t\t'repack:i' => \\$Git::SVN::_repack,\n\t\t'noMetadata' => \\$Git::SVN::_no_metadata,\n\t\t'useSvmProps' => \\$Git::SVN::_use_svm_props,\n\t\t'useSvnsyncProps' => \\$Git::SVN::_use_svnsync_props,\n\t\t'log-window-size=i' => \\$Git::SVN::Ra::_log_window_size,\n\t\t'no-checkout' => \\$_no_checkout,\n\t\t'quiet|q+' => \\$_q,\n\t\t'repack-flags|repack-args|repack-opts=s' =>\n\t\t   \\$Git::SVN::_repack_flags,\n\t\t'use-log-author' => \\$Git::SVN::_use_log_author,\n\t\t'add-author-from' => \\$Git::SVN::_add_author_from,\n\t\t'localtime' => \\$Git::SVN::_localtime,\n\t\t%remote_opts );\n\nmy ($_trunk, @_tags, @_branches, $_stdlayout);\nmy %icv;\nmy %init_opts = ( 'template=s' => \\$_template, 'shared:s' => \\$_shared,\n                  'trunk|T=s' => \\$_trunk, 'tags|t=s@' => \\@_tags,\n                  'branches|b=s@' => \\@_branches, 'prefix=s' => \\$_prefix,\n                  'stdlayout|s' => \\$_stdlayout,\n                  'minimize-url|m!' => \\$Git::SVN::_minimize_url,\n\t\t  'no-metadata' => sub { $icv{noMetadata} = 1 },\n\t\t  'use-svm-props' => sub { $icv{useSvmProps} = 1 },\n\t\t  'use-svnsync-props' => sub { $icv{useSvnsyncProps} = 1 },\n\t\t  'rewrite-root=s' => sub { $icv{rewriteRoot} = $_[1] },\n\t\t  'rewrite-uuid=s' => sub { $icv{rewriteUUID} = $_[1] },\n                  %remote_opts );\nmy %cmt_opts = ( 'edit|e' => \\$_edit,\n\t\t'rmdir' => \\$Git::SVN::Editor::_rmdir,\n\t\t'find-copies-harder' => \\$Git::SVN::Editor::_find_copies_harder,\n\t\t'l=i' => \\$Git::SVN::Editor::_rename_limit,\n\t\t'copy-similarity|C=i'=> \\$Git::SVN::Editor::_cp_similarity\n);\n\nmy %cmd = (\n\tfetch => [ \\&cmd_fetch, \"Download new revisions from SVN\",\n\t\t\t{ 'revision|r=s' => \\$_revision,\n\t\t\t  'fetch-all|all' => \\$_fetch_all,\n\t\t\t  'parent|p' => \\$_fetch_parent,\n\t\t\t   %fc_opts } ],\n\tclone => [ \\&cmd_clone, \"Initialize and fetch revisions\",\n\t\t\t{ 'revision|r=s' => \\$_revision,\n\t\t\t  'preserve-empty-dirs' =>\n\t\t\t\t\\$Git::SVN::Fetcher::_preserve_empty_dirs,\n\t\t\t  'placeholder-filename=s' =>\n\t\t\t\t\\$Git::SVN::Fetcher::_placeholder_filename,\n\t\t\t   %fc_opts, %init_opts } ],\n\tinit => [ \\&cmd_init, \"Initialize a repo for tracking\" .\n\t\t\t  \" (requires URL argument)\",\n\t\t\t  \\%init_opts ],\n\t'multi-init' => [ \\&cmd_multi_init,\n\t                  \"Deprecated alias for \".\n\t\t\t  \"'$0 init -T<trunk> -b<branches> -t<tags>'\",\n\t\t\t  \\%init_opts ],\n\tdcommit => [ \\&cmd_dcommit,\n\t             'Commit several diffs to merge with upstream',\n\t\t\t{ 'merge|m|M' => \\$_merge,\n\t\t\t  'strategy|s=s' => \\$_strategy,\n\t\t\t  'verbose|v' => \\$_verbose,\n\t\t\t  'dry-run|n' => \\$_dry_run,\n\t\t\t  'fetch-all|all' => \\$_fetch_all,\n\t\t\t  'commit-url=s' => \\$_commit_url,\n\t\t\t  'set-svn-props=s' => \\$_set_svn_props,\n\t\t\t  'revision|r=i' => \\$_revision,\n\t\t\t  'no-rebase' => \\$_no_rebase,\n\t\t\t  'mergeinfo=s' => \\$_merge_info,\n\t\t\t  'interactive|i' => \\$_interactive,\n\t\t\t%cmt_opts, %fc_opts } ],\n\tbranch => [ \\&cmd_branch,\n\t            'Create a branch in the SVN repository',\n\t            { 'message|m=s' => \\$_message,\n\t              'destination|d=s' => \\$_branch_dest,\n\t              'dry-run|n' => \\$_dry_run,\n\t              'parents' => \\$_parents,\n\t              'tag|t' => \\$_tag,\n\t              'username=s' => \\$Git::SVN::Prompt::_username,\n\t              'commit-url=s' => \\$_commit_url } ],\n\ttag => [ sub { $_tag = 1; cmd_branch(@_) },\n\t         'Create a tag in the SVN repository',\n\t         { 'message|m=s' => \\$_message,\n\t           'destination|d=s' => \\$_branch_dest,\n\t           'dry-run|n' => \\$_dry_run,\n\t           'parents' => \\$_parents,\n\t           'username=s' => \\$Git::SVN::Prompt::_username,\n\t           'commit-url=s' => \\$_commit_url } ],\n\t'set-tree' => [ \\&cmd_set_tree,\n\t                \"Set an SVN repository to a git tree-ish\",\n\t\t\t{ 'stdin' => \\$_stdin, %cmt_opts, %fc_opts, } ],\n\t'create-ignore' => [ \\&cmd_create_ignore,\n\t\t\t     'Create a .gitignore per svn:ignore',\n\t\t\t     { 'revision|r=i' => \\$_revision\n\t\t\t     } ],\n\t'mkdirs' => [ \\&cmd_mkdirs ,\n\t              \"recreate empty directories after a checkout\",\n\t              { 'revision|r=i' => \\$_revision } ],\n        'propget' => [ \\&cmd_propget,\n\t\t       'Print the value of a property on a file or directory',\n\t\t       { 'revision|r=i' => \\$_revision } ],\n        'propset' => [ \\&cmd_propset,\n\t\t       'Set the value of a property on a file or directory - will be set on commit',\n\t\t       {} ],\n        'proplist' => [ \\&cmd_proplist,\n\t\t       'List all properties of a file or directory',\n\t\t       { 'revision|r=i' => \\$_revision } ],\n\t'show-ignore' => [ \\&cmd_show_ignore, \"Show svn:ignore listings\",\n\t\t\t{ 'revision|r=i' => \\$_revision\n\t\t\t} ],\n\t'show-externals' => [ \\&cmd_show_externals, \"Show svn:externals listings\",\n\t\t\t{ 'revision|r=i' => \\$_revision\n\t\t\t} ],\n\t'multi-fetch' => [ \\&cmd_multi_fetch,\n\t                   \"Deprecated alias for $0 fetch --all\",\n\t\t\t   { 'revision|r=s' => \\$_revision, %fc_opts } ],\n\t'migrate' => [ sub { },\n\t               # no-op, we automatically run this anyways,\n\t               'Migrate configuration/metadata/layout from\n\t\t        previous versions of git-svn',\n                       { 'minimize' => \\$Git::SVN::Migration::_minimize,\n\t\t\t %remote_opts } ],\n\t'log' => [ \\&Git::SVN::Log::cmd_show_log, 'Show commit logs',\n\t\t\t{ 'limit=i' => \\$Git::SVN::Log::limit,\n\t\t\t  'revision|r=s' => \\$_revision,\n\t\t\t  'verbose|v' => \\$Git::SVN::Log::verbose,\n\t\t\t  'incremental' => \\$Git::SVN::Log::incremental,\n\t\t\t  'oneline' => \\$Git::SVN::Log::oneline,\n\t\t\t  'show-commit' => \\$Git::SVN::Log::show_commit,\n\t\t\t  'non-recursive' => \\$Git::SVN::Log::non_recursive,\n\t\t\t  'authors-file|A=s' => \\$_authors,\n\t\t\t  'color' => \\$Git::SVN::Log::color,\n\t\t\t  'pager=s' => \\$Git::SVN::Log::pager\n\t\t\t} ],\n\t'find-rev' => [ \\&cmd_find_rev,\n\t                \"Translate between SVN revision numbers and tree-ish\",\n\t\t\t{ 'B|before' => \\$_before,\n\t\t\t  'A|after' => \\$_after } ],\n\t'rebase' => [ \\&cmd_rebase, \"Fetch and rebase your working directory\",\n\t\t\t{ 'merge|m|M' => \\$_merge,\n\t\t\t  'verbose|v' => \\$_verbose,\n\t\t\t  'strategy|s=s' => \\$_strategy,\n\t\t\t  'local|l' => \\$_local,\n\t\t\t  'fetch-all|all' => \\$_fetch_all,\n\t\t\t  'dry-run|n' => \\$_dry_run,\n\t\t\t  'rebase-merges|p' => \\$_rebase_merges,\n\t\t\t  'preserve-merges|p' => \\$_rebase_merges,\n\t\t\t  %fc_opts } ],\n\t'commit-diff' => [ \\&cmd_commit_diff,\n\t                   'Commit a diff between two trees',\n\t\t\t{ 'message|m=s' => \\$_message,\n\t\t\t  'file|F=s' => \\$_file,\n\t\t\t  'revision|r=s' => \\$_revision,\n\t\t\t%cmt_opts } ],\n\t'info' => [ \\&cmd_info,\n\t\t    \"Show info about the latest SVN revision\n\t\t     on the current branch\",\n\t\t    { 'url' => \\$_url, } ],\n\t'blame' => [ \\&Git::SVN::Log::cmd_blame,\n\t            \"Show what revision and author last modified each line of a file\",\n\t\t    { 'git-format' => \\$Git::SVN::Log::_git_format } ],\n\t'reset' => [ \\&cmd_reset,\n\t\t     \"Undo fetches back to the specified SVN revision\",\n\t\t     { 'revision|r=s' => \\$_revision,\n\t\t       'parent|p' => \\$_fetch_parent } ],\n\t'gc' => [ \\&cmd_gc,\n\t\t  \"Compress unhandled.log files in .git/svn and remove \" .\n\t\t  \"index files in .git/svn\",\n\t\t{} ],\n);\n\npackage FakeTerm;\nsub new {\n\tmy ($class, $reason) = @_;\n\treturn bless \\$reason, shift;\n}\nsub readline {\n\tmy $self = shift;\n\tdie \"Cannot use readline on FakeTerm: $$self\";\n}\npackage main;\n\nmy $term;\nsub term_init {\n\t$term = eval {\n\t\trequire Term::ReadLine;\n\t\t$ENV{\"GIT_SVN_NOTTY\"}\n\t\t\t? new Term::ReadLine 'git-svn', \\*STDIN, \\*STDOUT\n\t\t\t: new Term::ReadLine 'git-svn';\n\t};\n\tif ($@) {\n\t\t$term = new FakeTerm \"$@: going non-interactive\";\n\t}\n}\n\nmy $cmd;\nfor (my $i = 0; $i < @ARGV; $i++) {\n\tif (defined $cmd{$ARGV[$i]}) {\n\t\t$cmd = $ARGV[$i];\n\t\tsplice @ARGV, $i, 1;\n\t\tlast;\n\t} elsif ($ARGV[$i] eq 'help') {\n\t\t$cmd = $ARGV[$i+1];\n\t\tusage(0);\n\t}\n};\n\n# make sure we're always running at the top-level working directory\nif ($cmd && $cmd =~ /(?:clone|init|multi-init)$/) {\n\t$ENV{GIT_DIR} ||= \".git\";\n\t# catch the submodule case\n\tif (-f $ENV{GIT_DIR}) {\n\t\topen(my $fh, '<', $ENV{GIT_DIR}) or\n\t\t\tdie \"failed to open $ENV{GIT_DIR}: $!\\n\";\n\t\t$ENV{GIT_DIR} = $1 if <$fh> =~ /^gitdir: (.+)$/;\n\t}\n} elsif ($cmd) {\n\tmy ($git_dir, $cdup);\n\tgit_cmd_try {\n\t\t$git_dir = command_oneline([qw/rev-parse --git-dir/]);\n\t} \"Unable to find .git directory\\n\";\n\tgit_cmd_try {\n\t\t$cdup = command_oneline(qw/rev-parse --show-cdup/);\n\t\tchomp $cdup if ($cdup);\n\t\t$cdup = \".\" unless ($cdup && length $cdup);\n\t} \"Already at toplevel, but $git_dir not found\\n\";\n\t$ENV{GIT_DIR} = $git_dir;\n\tchdir $cdup or die \"Unable to chdir up to '$cdup'\\n\";\n\t$_repository = Git->repository(Repository => $ENV{GIT_DIR});\n}\n\nmy %opts = %{$cmd{$cmd}->[2]} if (defined $cmd);\n\nread_git_config(\\%opts) if $ENV{GIT_DIR};\nif ($cmd && ($cmd eq 'log' || $cmd eq 'blame')) {\n\tGetopt::Long::Configure('pass_through');\n}\nmy $rv = GetOptions(%opts, 'h|H' => \\$_help, 'version|V' => \\$_version,\n                    'minimize-connections' => \\$Git::SVN::Migration::_minimize,\n                    'id|i=s' => \\$Git::SVN::default_ref_id,\n                    'svn-remote|remote|R=s' => sub {\n                       $Git::SVN::no_reuse_existing = 1;\n                       $Git::SVN::default_repo_id = $_[1] });\nexit 1 if (!$rv && $cmd && $cmd ne 'log');\n\nusage(0) if $_help;\nversion() if $_version;\nusage(1) unless defined $cmd;\nload_authors() if $_authors;\nif (defined $_authors_prog) {\n\tmy $abs_file = File::Spec->rel2abs($_authors_prog);\n\t$_authors_prog = \"'\" . $abs_file . \"'\" if -x $abs_file;\n}\n\nunless ($cmd =~ /^(?:clone|init|multi-init|commit-diff)$/) {\n\tGit::SVN::Migration::migration_check();\n}\nGit::SVN::init_vars();\neval {\n\tGit::SVN::verify_remotes_sanity();\n\t$cmd{$cmd}->[0]->(@ARGV);\n\tpost_fetch_checkout();\n};\nfatal $@ if $@;\nexit 0;\n\n####################### primary functions ######################\nsub usage {\n\tmy $exit = shift || 0;\n\tmy $fd = $exit ? \\*STDERR : \\*STDOUT;\n\tprint $fd <<\"\";\ngit-svn - bidirectional operations between a single Subversion tree and git\nusage: git svn <command> [options] [arguments]\\n\n\n\tprint $fd \"Available commands:\\n\" unless $cmd;\n\n\tforeach (sort keys %cmd) {\n\t\tnext if $cmd && $cmd ne $_;\n\t\tnext if /^multi-/; # don't show deprecated commands\n\t\tprint $fd '  ',pack('A17',$_),$cmd{$_}->[1],\"\\n\";\n\t\tforeach (sort keys %{$cmd{$_}->[2]}) {\n\t\t\t# mixed-case options are for .git/config only\n\t\t\tnext if /[A-Z]/ && /^[a-z]+$/i;\n\t\t\t# prints out arguments as they should be passed:\n\t\t\tmy $x = s#[:=]s$## ? '<arg>' : s#[:=]i$## ? '<num>' : '';\n\t\t\tprint $fd ' ' x 21, join(', ', map { length $_ > 1 ?\n\t\t\t\t\t\t\t\"--$_\" : \"-$_\" }\n\t\t\t\t\t\tsplit /\\|/,$_),\" $x\\n\";\n\t\t}\n\t}\n\tprint $fd <<\"\";\n\\nGIT_SVN_ID may be set in the environment or via the --id/-i switch to an\narbitrary identifier if you're tracking multiple SVN branches/repositories in\none git repository and want to keep them separate.  See git-svn(1) for more\ninformation.\n\n\texit $exit;\n}\n\nsub version {\n\t::_req_svn();\n\tprint \"git-svn version $VERSION (svn $SVN::Core::VERSION)\\n\";\n\texit 0;\n}\n\nsub ask {\n\tmy ($prompt, %arg) = @_;\n\tmy $valid_re = $arg{valid_re};\n\tmy $default = $arg{default};\n\tmy $resp;\n\tmy $i = 0;\n\tterm_init() unless $term;\n\n\tif ( !( defined($term->IN)\n            && defined( fileno($term->IN) )\n            && defined( $term->OUT )\n            && defined( fileno($term->OUT) ) ) ){\n\t\treturn defined($default) ? $default : undef;\n\t}\n\n\twhile ($i++ < 10) {\n\t\t$resp = $term->readline($prompt);\n\t\tif (!defined $resp) { # EOF\n\t\t\tprint \"\\n\";\n\t\t\treturn defined $default ? $default : undef;\n\t\t}\n\t\tif ($resp eq '' and defined $default) {\n\t\t\treturn $default;\n\t\t}\n\t\tif (!defined $valid_re or $resp =~ /$valid_re/) {\n\t\t\treturn $resp;\n\t\t}\n\t}\n\treturn undef;\n}\n\nsub do_git_init_db {\n\tunless (-d $ENV{GIT_DIR}) {\n\t\tmy @init_db = ('init');\n\t\tpush @init_db, \"--template=$_template\" if defined $_template;\n\t\tif (defined $_shared) {\n\t\t\tif ($_shared =~ /[a-z]/) {\n\t\t\t\tpush @init_db, \"--shared=$_shared\";\n\t\t\t} else {\n\t\t\t\tpush @init_db, \"--shared\";\n\t\t\t}\n\t\t}\n\t\tcommand_noisy(@init_db);\n\t\t$_repository = Git->repository(Repository => \".git\");\n\t}\n\tmy $set;\n\tmy $pfx = \"svn-remote.$Git::SVN::default_repo_id\";\n\tforeach my $i (keys %icv) {\n\t\tdie \"'$set' and '$i' cannot both be set\\n\" if $set;\n\t\tnext unless defined $icv{$i};\n\t\tcommand_noisy('config', \"$pfx.$i\", $icv{$i});\n\t\t$set = $i;\n\t}\n\tmy $ignore_paths_regex = \\$Git::SVN::Fetcher::_ignore_regex;\n\tcommand_noisy('config', \"$pfx.ignore-paths\", $$ignore_paths_regex)\n\t\tif defined $$ignore_paths_regex;\n\tmy $include_paths_regex = \\$Git::SVN::Fetcher::_include_regex;\n\tcommand_noisy('config', \"$pfx.include-paths\", $$include_paths_regex)\n\t\tif defined $$include_paths_regex;\n\tmy $ignore_refs_regex = \\$Git::SVN::Ra::_ignore_refs_regex;\n\tcommand_noisy('config', \"$pfx.ignore-refs\", $$ignore_refs_regex)\n\t\tif defined $$ignore_refs_regex;\n\n\tif (defined $Git::SVN::Fetcher::_preserve_empty_dirs) {\n\t\tmy $fname = \\$Git::SVN::Fetcher::_placeholder_filename;\n\t\tcommand_noisy('config', \"$pfx.preserve-empty-dirs\", 'true');\n\t\tcommand_noisy('config', \"$pfx.placeholder-filename\", $$fname);\n\t}\n}\n\nsub init_subdir {\n\tmy $repo_path = shift or return;\n\tmkpath([$repo_path]) unless -d $repo_path;\n\tchdir $repo_path or die \"Couldn't chdir to $repo_path: $!\\n\";\n\t$ENV{GIT_DIR} = '.git';\n\t$_repository = Git->repository(Repository => $ENV{GIT_DIR});\n}\n\nsub cmd_clone {\n\tmy ($url, $path) = @_;\n\tif (!$url) {\n\t\tdie \"SVN repository location required \",\n\t\t    \"as a command-line argument\\n\";\n\t} elsif (!defined $path &&\n\t    (defined $_trunk || @_branches || @_tags ||\n\t     defined $_stdlayout) &&\n\t    $url !~ m#^[a-z\\+]+://#) {\n\t\t$path = $url;\n\t}\n\t$path = basename($url) if !defined $path || !length $path;\n\tmy $authors_absolute = $_authors ? File::Spec->rel2abs($_authors) : \"\";\n\tcmd_init($url, $path);\n\tcommand_oneline('config', 'svn.authorsfile', $authors_absolute)\n\t    if $_authors;\n\tGit::SVN::fetch_all($Git::SVN::default_repo_id);\n}\n\nsub cmd_init {\n\tif (defined $_stdlayout) {\n\t\t$_trunk = 'trunk' if (!defined $_trunk);\n\t\t@_tags = 'tags' if (! @_tags);\n\t\t@_branches = 'branches' if (! @_branches);\n\t}\n\tif (defined $_trunk || @_branches || @_tags) {\n\t\treturn cmd_multi_init(@_);\n\t}\n\tmy $url = shift or die \"SVN repository location required \",\n\t                       \"as a command-line argument\\n\";\n\t$url = canonicalize_url($url);\n\tinit_subdir(@_);\n\tdo_git_init_db();\n\n\tif ($Git::SVN::_minimize_url eq 'unset') {\n\t\t$Git::SVN::_minimize_url = 0;\n\t}\n\n\tGit::SVN->init($url);\n}\n\nsub cmd_fetch {\n\tif (grep /^\\d+=./, @_) {\n\t\tdie \"'<rev>=<commit>' fetch arguments are \",\n\t\t    \"no longer supported.\\n\";\n\t}\n\tmy ($remote) = @_;\n\tif (@_ > 1) {\n\t\tdie \"usage: $0 fetch [--all] [--parent] [svn-remote]\\n\";\n\t}\n\t$Git::SVN::no_reuse_existing = undef;\n\tif ($_fetch_parent) {\n\t\tmy ($url, $rev, $uuid, $gs) = working_head_info('HEAD');\n\t\tunless ($gs) {\n\t\t\tdie \"Unable to determine upstream SVN information from \",\n\t\t\t    \"working tree history\\n\";\n\t\t}\n\t        # just fetch, don't checkout.\n\t\t$_no_checkout = 'true';\n\t\t$_fetch_all ? $gs->fetch_all : $gs->fetch;\n\t} elsif ($_fetch_all) {\n\t\tcmd_multi_fetch();\n\t} else {\n\t\t$remote ||= $Git::SVN::default_repo_id;\n\t\tGit::SVN::fetch_all($remote, Git::SVN::read_all_remotes());\n\t}\n}\n\nsub cmd_set_tree {\n\tmy (@commits) = @_;\n\tif ($_stdin || !@commits) {\n\t\tprint \"Reading from stdin...\\n\";\n\t\t@commits = ();\n\t\twhile (<STDIN>) {\n\t\t\tif (/\\b($oid_short)\\b/o) {\n\t\t\t\tunshift @commits, $1;\n\t\t\t}\n\t\t}\n\t}\n\tmy @revs;\n\tforeach my $c (@commits) {\n\t\tmy @tmp = command('rev-parse',$c);\n\t\tif (scalar @tmp == 1) {\n\t\t\tpush @revs, $tmp[0];\n\t\t} elsif (scalar @tmp > 1) {\n\t\t\tpush @revs, reverse(command('rev-list',@tmp));\n\t\t} else {\n\t\t\tfatal \"Failed to rev-parse $c\";\n\t\t}\n\t}\n\tmy $gs = Git::SVN->new;\n\tmy ($r_last, $cmt_last) = $gs->last_rev_commit;\n\t$gs->fetch;\n\tif (defined $gs->{last_rev} && $r_last != $gs->{last_rev}) {\n\t\tfatal \"There are new revisions that were fetched \",\n\t\t      \"and need to be merged (or acknowledged) \",\n\t\t      \"before committing.\\nlast rev: $r_last\\n\",\n\t\t      \" current: $gs->{last_rev}\";\n\t}\n\t$gs->set_tree($_) foreach @revs;\n\tprint \"Done committing \",scalar @revs,\" revisions to SVN\\n\";\n\tunlink $gs->{index};\n}\n\nsub split_merge_info_range {\n\tmy ($range) = @_;\n\tif ($range =~ /(\\d+)-(\\d+)/) {\n\t\treturn (int($1), int($2));\n\t} else {\n\t\treturn (int($range), int($range));\n\t}\n}\n\nsub combine_ranges {\n\tmy ($in) = @_;\n\n\tmy @fnums = ();\n\tmy @arr = split(/,/, $in);\n\tfor my $element (@arr) {\n\t\tmy ($start, $end) = split_merge_info_range($element);\n\t\tpush @fnums, $start;\n\t}\n\n\tmy @sorted = @arr [ sort {\n\t\t$fnums[$a] <=> $fnums[$b]\n\t} 0..$#arr ];\n\n\tmy @return = ();\n\tmy $last = -1;\n\tmy $first = -1;\n\tfor my $element (@sorted) {\n\t\tmy ($start, $end) = split_merge_info_range($element);\n\n\t\tif ($last == -1) {\n\t\t\t$first = $start;\n\t\t\t$last = $end;\n\t\t\tnext;\n\t\t}\n\t\tif ($start <= $last+1) {\n\t\t\tif ($end > $last) {\n\t\t\t\t$last = $end;\n\t\t\t}\n\t\t\tnext;\n\t\t}\n\t\tif ($first == $last) {\n\t\t\tpush @return, \"$first\";\n\t\t} else {\n\t\t\tpush @return, \"$first-$last\";\n\t\t}\n\t\t$first = $start;\n\t\t$last = $end;\n\t}\n\n\tif ($first != -1) {\n\t\tif ($first == $last) {\n\t\t\tpush @return, \"$first\";\n\t\t} else {\n\t\t\tpush @return, \"$first-$last\";\n\t\t}\n\t}\n\n\treturn join(',', @return);\n}\n\nsub merge_revs_into_hash {\n\tmy ($hash, $minfo) = @_;\n\tmy @lines = split(' ', $minfo);\n\n\tfor my $line (@lines) {\n\t\tmy ($branchpath, $revs) = split(/:/, $line);\n\n\t\tif (exists($hash->{$branchpath})) {\n\t\t\t# Merge the two revision sets\n\t\t\tmy $combined = \"$hash->{$branchpath},$revs\";\n\t\t\t$hash->{$branchpath} = combine_ranges($combined);\n\t\t} else {\n\t\t\t# Just do range combining for consolidation\n\t\t\t$hash->{$branchpath} = combine_ranges($revs);\n\t\t}\n\t}\n}\n\nsub merge_merge_info {\n\tmy ($mergeinfo_one, $mergeinfo_two, $ignore_branch) = @_;\n\tmy %result_hash = ();\n\n\tmerge_revs_into_hash(\\%result_hash, $mergeinfo_one);\n\tmerge_revs_into_hash(\\%result_hash, $mergeinfo_two);\n\n\tdelete $result_hash{$ignore_branch} if $ignore_branch;\n\n\tmy $result = '';\n\t# Sort below is for consistency's sake\n\tfor my $branchname (sort keys(%result_hash)) {\n\t\tmy $revlist = $result_hash{$branchname};\n\t\t$result .= \"$branchname:$revlist\\n\"\n\t}\n\treturn $result;\n}\n\nsub populate_merge_info {\n\tmy ($d, $gs, $uuid, $linear_refs, $rewritten_parent) = @_;\n\n\tmy %parentshash;\n\tread_commit_parents(\\%parentshash, $d);\n\tmy @parents = @{$parentshash{$d}};\n\tif ($#parents > 0) {\n\t\t# Merge commit\n\t\tmy $all_parents_ok = 1;\n\t\tmy $aggregate_mergeinfo = '';\n\t\tmy $rooturl = $gs->repos_root;\n\t\tmy ($target_branch) = $gs->full_pushurl =~ /^\\Q$rooturl\\E(.*)/;\n\n\t\tif (defined($rewritten_parent)) {\n\t\t\t# Replace first parent with newly-rewritten version\n\t\t\tshift @parents;\n\t\t\tunshift @parents, $rewritten_parent;\n\t\t}\n\n\t\tforeach my $parent (@parents) {\n\t\t\tmy ($branchurl, $svnrev, $paruuid) =\n\t\t\t\tcmt_metadata($parent);\n\n\t\t\tunless (defined($svnrev)) {\n\t\t\t\t# Should have been caught be preflight check\n\t\t\t\tfatal \"merge commit $d has ancestor $parent, but that change \"\n                     .\"does not have git-svn metadata!\";\n\t\t\t}\n\t\t\tunless ($branchurl =~ /^\\Q$rooturl\\E(.*)/) {\n\t\t\t\tfatal \"commit $parent git-svn metadata changed mid-run!\";\n\t\t\t}\n\t\t\tmy $branchpath = $1;\n\n\t\t\tmy $ra = Git::SVN::Ra->new($branchurl);\n\t\t\tmy (undef, undef, $props) =\n\t\t\t\t$ra->get_dir(canonicalize_path(\".\"), $svnrev);\n\t\t\tmy $par_mergeinfo = $props->{'svn:mergeinfo'};\n\t\t\tunless (defined $par_mergeinfo) {\n\t\t\t\t$par_mergeinfo = '';\n\t\t\t}\n\t\t\t# Merge previous mergeinfo values\n\t\t\t$aggregate_mergeinfo =\n\t\t\t\tmerge_merge_info($aggregate_mergeinfo,\n\t\t\t\t\t\t\t\t$par_mergeinfo,\n\t\t\t\t\t\t\t\t$target_branch);\n\n\t\t\tnext if $parent eq $parents[0]; # Skip first parent\n\t\t\t# Add new changes being placed in tree by merge\n\t\t\tmy @cmd = (qw/rev-list --reverse/,\n\t\t\t\t\t   $parent, qw/--not/);\n\t\t\tforeach my $par (@parents) {\n\t\t\t\tunless ($par eq $parent) {\n\t\t\t\t\tpush @cmd, $par;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmy @revsin = ();\n\t\t\tmy ($revlist, $ctx) = command_output_pipe(@cmd);\n\t\t\twhile (<$revlist>) {\n\t\t\t\tmy $irev = $_;\n\t\t\t\tchomp $irev;\n\t\t\t\tmy (undef, $csvnrev, undef) =\n\t\t\t\t\tcmt_metadata($irev);\n\t\t\t\tunless (defined $csvnrev) {\n\t\t\t\t\t# A child is missing SVN annotations...\n\t\t\t\t\t# this might be OK, or might not be.\n\t\t\t\t\twarn \"W:child $irev is merged into revision \"\n\t\t\t\t\t\t .\"$d but does not have git-svn metadata. \"\n\t\t\t\t\t\t .\"This means git-svn cannot determine the \"\n\t\t\t\t\t\t .\"svn revision numbers to place into the \"\n\t\t\t\t\t\t .\"svn:mergeinfo property. You must ensure \"\n\t\t\t\t\t\t .\"a branch is entirely committed to \"\n\t\t\t\t\t\t .\"SVN before merging it in order for \"\n\t\t\t\t\t\t .\"svn:mergeinfo population to function \"\n\t\t\t\t\t\t .\"properly\";\n\t\t\t\t}\n\t\t\t\tpush @revsin, $csvnrev;\n\t\t\t}\n\t\t\tcommand_close_pipe($revlist, $ctx);\n\n\t\t\tlast unless $all_parents_ok;\n\n\t\t\t# We now have a list of all SVN revnos which are\n\t\t\t# merged by this particular parent. Integrate them.\n\t\t\tnext if $#revsin == -1;\n\t\t\tmy $newmergeinfo = \"$branchpath:\" . join(',', @revsin);\n\t\t\t$aggregate_mergeinfo =\n\t\t\t\tmerge_merge_info($aggregate_mergeinfo,\n\t\t\t\t\t\t\t\t$newmergeinfo,\n\t\t\t\t\t\t\t\t$target_branch);\n\t\t}\n\t\tif ($all_parents_ok and $aggregate_mergeinfo) {\n\t\t\treturn $aggregate_mergeinfo;\n\t\t}\n\t}\n\n\treturn undef;\n}\n\nsub dcommit_rebase {\n\tmy ($is_last, $current, $fetched_ref, $svn_error) = @_;\n\tmy @diff;\n\n\tif ($svn_error) {\n\t\tprint STDERR \"\\nERROR from SVN:\\n\",\n\t\t\t\t$svn_error->expanded_message, \"\\n\";\n\t}\n\tunless ($_no_rebase) {\n\t\t# we always want to rebase against the current HEAD,\n\t\t# not any head that was passed to us\n\t\t@diff = command('diff-tree', $current,\n\t                   $fetched_ref, '--');\n\t\tmy @finish;\n\t\tif (@diff) {\n\t\t\t@finish = rebase_cmd();\n\t\t\tprint STDERR \"W: $current and \", $fetched_ref,\n\t\t\t             \" differ, using @finish:\\n\",\n\t\t\t             join(\"\\n\", @diff), \"\\n\";\n\t\t} elsif ($is_last) {\n\t\t\tprint \"No changes between \", $current, \" and \",\n\t\t\t      $fetched_ref,\n\t\t\t      \"\\nResetting to the latest \",\n\t\t\t      $fetched_ref, \"\\n\";\n\t\t\t@finish = qw/reset --mixed/;\n\t\t}\n\t\tcommand_noisy(@finish, $fetched_ref) if @finish;\n\t}\n\tif ($svn_error) {\n\t\tdie \"ERROR: Not all changes have been committed into SVN\"\n\t\t\t.($_no_rebase ? \".\\n\" : \", however the committed\\n\"\n\t\t\t.\"ones (if any) seem to be successfully integrated \"\n\t\t\t.\"into the working tree.\\n\")\n\t\t\t.\"Please see the above messages for details.\\n\";\n\t}\n\treturn @diff;\n}\n\nsub cmd_dcommit {\n\tmy $head = shift;\n\tcommand_noisy(qw/update-index --refresh/);\n\tgit_cmd_try { command_oneline(qw/diff-index --quiet HEAD --/) }\n\t\t'Cannot dcommit with a dirty index.  Commit your changes first, '\n\t\t. \"or stash them with `git stash'.\\n\";\n\t$head ||= 'HEAD';\n\n\tmy $old_head;\n\tif ($head ne 'HEAD') {\n\t\t$old_head = eval {\n\t\t\tcommand_oneline([qw/symbolic-ref -q HEAD/])\n\t\t};\n\t\tif ($old_head) {\n\t\t\t$old_head =~ s{^refs/heads/}{};\n\t\t} else {\n\t\t\t$old_head = eval { command_oneline(qw/rev-parse HEAD/) };\n\t\t}\n\t\tcommand(['checkout', $head], STDERR => 0);\n\t}\n\n\tmy @refs;\n\tmy ($url, $rev, $uuid, $gs) = working_head_info('HEAD', \\@refs);\n\tunless ($gs) {\n\t\tdie \"Unable to determine upstream SVN information from \",\n\t\t    \"$head history.\\nPerhaps the repository is empty.\";\n\t}\n\n\tif (defined $_commit_url) {\n\t\t$url = $_commit_url;\n\t} else {\n\t\t$url = eval { command_oneline('config', '--get',\n\t\t\t      \"svn-remote.$gs->{repo_id}.commiturl\") };\n\t\tif (!$url) {\n\t\t\t$url = $gs->full_pushurl\n\t\t}\n\t}\n\n\tmy $last_rev = $_revision if defined $_revision;\n\tif ($url) {\n\t\tprint \"Committing to $url ...\\n\";\n\t}\n\tmy ($linear_refs, $parents) = linearize_history($gs, \\@refs);\n\tif ($_no_rebase && scalar(@$linear_refs) > 1) {\n\t\twarn \"Attempting to commit more than one change while \",\n\t\t     \"--no-rebase is enabled.\\n\",\n\t\t     \"If these changes depend on each other, re-running \",\n\t\t     \"without --no-rebase may be required.\"\n\t}\n\n\tif (defined $_interactive){\n\t\tmy $ask_default = \"y\";\n\t\tforeach my $d (@$linear_refs){\n\t\t\tmy ($fh, $ctx) = command_output_pipe(qw(show --summary), \"$d\");\n\t\t\twhile (<$fh>){\n\t\t\t\tprint $_;\n\t\t\t}\n\t\t\tcommand_close_pipe($fh, $ctx);\n\t\t\t$_ = ask(\"Commit this patch to SVN? ([y]es (default)|[n]o|[q]uit|[a]ll): \",\n\t\t\t         valid_re => qr/^(?:yes|y|no|n|quit|q|all|a)/i,\n\t\t\t         default => $ask_default);\n\t\t\tdie \"Commit this patch reply required\" unless defined $_;\n\t\t\tif (/^[nq]/i) {\n\t\t\t\texit(0);\n\t\t\t} elsif (/^a/i) {\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t}\n\n\tmy $expect_url = $url;\n\n\tmy $push_merge_info = eval {\n\t\tcommand_oneline(qw/config --get svn.pushmergeinfo/)\n\t\t};\n\tif (not defined($push_merge_info)\n\t\t\tor $push_merge_info eq \"false\"\n\t\t\tor $push_merge_info eq \"no\"\n\t\t\tor $push_merge_info eq \"never\") {\n\t\t$push_merge_info = 0;\n\t}\n\n\tunless (defined($_merge_info) || ! $push_merge_info) {\n\t\t# Preflight check of changes to ensure no issues with mergeinfo\n\t\t# This includes check for uncommitted-to-SVN parents\n\t\t# (other than the first parent, which we will handle),\n\t\t# information from different SVN repos, and paths\n\t\t# which are not underneath this repository root.\n\t\tmy $rooturl = $gs->repos_root;\n\t        Git::SVN::remove_username($rooturl);\n\t\tforeach my $d (@$linear_refs) {\n\t\t\tmy %parentshash;\n\t\t\tread_commit_parents(\\%parentshash, $d);\n\t\t\tmy @realparents = @{$parentshash{$d}};\n\t\t\tif ($#realparents > 0) {\n\t\t\t\t# Merge commit\n\t\t\t\tshift @realparents; # Remove/ignore first parent\n\t\t\t\tforeach my $parent (@realparents) {\n\t\t\t\t\tmy ($branchurl, $svnrev, $paruuid) = cmt_metadata($parent);\n\t\t\t\t\tunless (defined $paruuid) {\n\t\t\t\t\t\t# A parent is missing SVN annotations...\n\t\t\t\t\t\t# abort the whole operation.\n\t\t\t\t\t\tfatal \"$parent is merged into revision $d, \"\n\t\t\t\t\t\t\t .\"but does not have git-svn metadata. \"\n\t\t\t\t\t\t\t .\"Either dcommit the branch or use a \"\n\t\t\t\t\t\t\t .\"local cherry-pick, FF merge, or rebase \"\n\t\t\t\t\t\t\t .\"instead of an explicit merge commit.\";\n\t\t\t\t\t}\n\n\t\t\t\t\tunless ($paruuid eq $uuid) {\n\t\t\t\t\t\t# Parent has SVN metadata from different repository\n\t\t\t\t\t\tfatal \"merge parent $parent for change $d has \"\n\t\t\t\t\t\t\t .\"git-svn uuid $paruuid, while current change \"\n\t\t\t\t\t\t\t .\"has uuid $uuid!\";\n\t\t\t\t\t}\n\n\t\t\t\t\tunless ($branchurl =~ /^\\Q$rooturl\\E(.*)/) {\n\t\t\t\t\t\t# This branch is very strange indeed.\n\t\t\t\t\t\tfatal \"merge parent $parent for $d is on branch \"\n\t\t\t\t\t\t\t .\"$branchurl, which is not under the \"\n\t\t\t\t\t\t\t .\"git-svn root $rooturl!\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmy $rewritten_parent;\n\tmy $current_head = command_oneline(qw/rev-parse HEAD/);\n\tGit::SVN::remove_username($expect_url);\n\tif (defined($_merge_info)) {\n\t\t$_merge_info =~ tr{ }{\\n};\n\t}\n\twhile (1) {\n\t\tmy $d = shift @$linear_refs or last;\n\t\tunless (defined $last_rev) {\n\t\t\t(undef, $last_rev, undef) = cmt_metadata(\"$d~1\");\n\t\t\tunless (defined $last_rev) {\n\t\t\t\tfatal \"Unable to extract revision information \",\n\t\t\t\t      \"from commit $d~1\";\n\t\t\t}\n\t\t}\n\t\tif ($_dry_run) {\n\t\t\tprint \"diff-tree $d~1 $d\\n\";\n\t\t} else {\n\t\t\tmy $cmt_rev;\n\n\t\t\tunless (defined($_merge_info) || ! $push_merge_info) {\n\t\t\t\t$_merge_info = populate_merge_info($d, $gs,\n\t\t\t\t                             $uuid,\n\t\t\t\t                             $linear_refs,\n\t\t\t\t                             $rewritten_parent);\n\t\t\t}\n\n\t\t\tmy %ed_opts = ( r => $last_rev,\n\t\t\t                log => get_commit_entry($d)->{log},\n\t\t\t                ra => Git::SVN::Ra->new($url),\n\t\t\t                config => SVN::Core::config_get_config(\n\t\t\t                        $Git::SVN::Ra::config_dir\n\t\t\t                ),\n\t\t\t                tree_a => \"$d~1\",\n\t\t\t                tree_b => $d,\n\t\t\t                editor_cb => sub {\n\t\t\t                       print \"Committed r$_[0]\\n\";\n\t\t\t                       $cmt_rev = $_[0];\n\t\t\t                },\n\t\t\t\t\tmergeinfo => $_merge_info,\n\t\t\t                svn_path => '');\n\n\t\t\tmy $err_handler = $SVN::Error::handler;\n\t\t\t$SVN::Error::handler = sub {\n\t\t\t\tmy $err = shift;\n\t\t\t\tdcommit_rebase(1, $current_head, $gs->refname,\n\t\t\t\t\t$err);\n\t\t\t};\n\n\t\t\tif (!Git::SVN::Editor->new(\\%ed_opts)->apply_diff) {\n\t\t\t\tprint \"No changes\\n$d~1 == $d\\n\";\n\t\t\t} elsif ($parents->{$d} && @{$parents->{$d}}) {\n\t\t\t\t$gs->{inject_parents_dcommit}->{$cmt_rev} =\n\t\t\t\t                               $parents->{$d};\n\t\t\t}\n\t\t\t$_fetch_all ? $gs->fetch_all : $gs->fetch;\n\t\t\t$SVN::Error::handler = $err_handler;\n\t\t\t$last_rev = $cmt_rev;\n\t\t\tnext if $_no_rebase;\n\n\t\t\tmy @diff = dcommit_rebase(@$linear_refs == 0, $d,\n\t\t\t\t\t\t$gs->refname, undef);\n\n\t\t\t$rewritten_parent = command_oneline(qw/rev-parse/,\n\t\t\t\t\t\t\t$gs->refname);\n\n\t\t\tif (@diff) {\n\t\t\t\t$current_head = command_oneline(qw/rev-parse\n\t\t\t\t\t\t\t\tHEAD/);\n\t\t\t\t@refs = ();\n\t\t\t\tmy ($url_, $rev_, $uuid_, $gs_) =\n\t\t\t\t              working_head_info('HEAD', \\@refs);\n\t\t\t\tmy ($linear_refs_, $parents_) =\n\t\t\t\t              linearize_history($gs_, \\@refs);\n\t\t\t\tif (scalar(@$linear_refs) !=\n\t\t\t\t    scalar(@$linear_refs_)) {\n\t\t\t\t\tfatal \"# of revisions changed \",\n\t\t\t\t\t  \"\\nbefore:\\n\",\n\t\t\t\t\t  join(\"\\n\", @$linear_refs),\n\t\t\t\t\t  \"\\n\\nafter:\\n\",\n\t\t\t\t\t  join(\"\\n\", @$linear_refs_), \"\\n\",\n\t\t\t\t\t  'If you are attempting to commit ',\n\t\t\t\t\t  \"merges, try running:\\n\\t\",\n\t\t\t\t\t  'git rebase --interactive',\n\t\t\t\t\t  '--rebase-merges ',\n\t\t\t\t\t  $gs->refname,\n\t\t\t\t\t  \"\\nBefore dcommitting\";\n\t\t\t\t}\n\t\t\t\tif ($url_ ne $expect_url) {\n\t\t\t\t\tif ($url_ eq $gs->metadata_url) {\n\t\t\t\t\t\tprint\n\t\t\t\t\t\t  \"Accepting rewritten URL:\",\n\t\t\t\t\t\t  \" $url_\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfatal\n\t\t\t\t\t\t  \"URL mismatch after rebase:\",\n\t\t\t\t\t\t  \" $url_ != $expect_url\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ($uuid_ ne $uuid) {\n\t\t\t\t\tfatal \"uuid mismatch after rebase: \",\n\t\t\t\t\t      \"$uuid_ != $uuid\";\n\t\t\t\t}\n\t\t\t\t# remap parents\n\t\t\t\tmy (%p, @l, $i);\n\t\t\t\tfor ($i = 0; $i < scalar @$linear_refs; $i++) {\n\t\t\t\t\tmy $new = $linear_refs_->[$i] or next;\n\t\t\t\t\t$p{$new} =\n\t\t\t\t\t\t$parents->{$linear_refs->[$i]};\n\t\t\t\t\tpush @l, $new;\n\t\t\t\t}\n\t\t\t\t$parents = \\%p;\n\t\t\t\t$linear_refs = \\@l;\n\t\t\t\tundef $last_rev;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ($old_head) {\n\t\tmy $new_head = command_oneline(qw/rev-parse HEAD/);\n\t\tmy $new_is_symbolic = eval {\n\t\t\tcommand_oneline(qw/symbolic-ref -q HEAD/);\n\t\t};\n\t\tif ($new_is_symbolic) {\n\t\t\tprint \"dcommitted the branch \", $head, \"\\n\";\n\t\t} else {\n\t\t\tprint \"dcommitted on a detached HEAD because you gave \",\n\t\t\t      \"a revision argument.\\n\",\n\t\t\t      \"The rewritten commit is: \", $new_head, \"\\n\";\n\t\t}\n\t\tcommand(['checkout', $old_head], STDERR => 0);\n\t}\n\n\tunlink $gs->{index};\n}\n\nsub cmd_branch {\n\tmy ($branch_name, $head) = @_;\n\n\tunless (defined $branch_name && length $branch_name) {\n\t\tdie(($_tag ? \"tag\" : \"branch\") . \" name required\\n\");\n\t}\n\t$head ||= 'HEAD';\n\n\tmy (undef, $rev, undef, $gs) = working_head_info($head);\n\tmy $src = $gs->full_pushurl;\n\n\tmy $remote = Git::SVN::read_all_remotes()->{$gs->{repo_id}};\n\tmy $allglobs = $remote->{ $_tag ? 'tags' : 'branches' };\n\tmy $glob;\n\tif ($#{$allglobs} == 0) {\n\t\t$glob = $allglobs->[0];\n\t} else {\n\t\tunless(defined $_branch_dest) {\n\t\t\tdie \"Multiple \",\n\t\t\t    $_tag ? \"tag\" : \"branch\",\n\t\t\t    \" paths defined for Subversion repository.\\n\",\n\t\t            \"You must specify where you want to create the \",\n\t\t            $_tag ? \"tag\" : \"branch\",\n\t\t            \" with the --destination argument.\\n\";\n\t\t}\n\t\tforeach my $g (@{$allglobs}) {\n\t\t\tmy $re = Git::SVN::Editor::glob2pat($g->{path}->{left});\n\t\t\tif ($_branch_dest =~ /$re/) {\n\t\t\t\t$glob = $g;\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t\tunless (defined $glob) {\n\t\t\tmy $dest_re = qr/\\b\\Q$_branch_dest\\E\\b/;\n\t\t\tforeach my $g (@{$allglobs}) {\n\t\t\t\t$g->{path}->{left} =~ /$dest_re/ or next;\n\t\t\t\tif (defined $glob) {\n\t\t\t\t\tdie \"Ambiguous destination: \",\n\t\t\t\t\t    $_branch_dest, \"\\nmatches both '\",\n\t\t\t\t\t    $glob->{path}->{left}, \"' and '\",\n\t\t\t\t\t    $g->{path}->{left}, \"'\\n\";\n\t\t\t\t}\n\t\t\t\t$glob = $g;\n\t\t\t}\n\t\t\tunless (defined $glob) {\n\t\t\t\tdie \"Unknown \",\n\t\t\t\t    $_tag ? \"tag\" : \"branch\",\n\t\t\t\t    \" destination $_branch_dest\\n\";\n\t\t\t}\n\t\t}\n\t}\n\tmy ($lft, $rgt) = @{ $glob->{path} }{qw/left right/};\n\tmy $url;\n\tif (defined $_commit_url) {\n\t\t$url = $_commit_url;\n\t} else {\n\t\t$url = eval { command_oneline('config', '--get',\n\t\t\t\"svn-remote.$gs->{repo_id}.commiturl\") };\n\t\tif (!$url) {\n\t\t\t$url = $remote->{pushurl} || $remote->{url};\n\t\t}\n\t}\n\tmy $dst = join '/', $url, $lft, $branch_name, ($rgt || ());\n\n\tif ($dst =~ /^https:/ && $src =~ /^http:/) {\n\t\t$src=~s/^http:/https:/;\n\t}\n\n\t::_req_svn();\n\trequire SVN::Client;\n\n\tmy ($config, $baton, undef) = Git::SVN::Ra::prepare_config_once();\n\tmy $ctx = SVN::Client->new(\n\t\tauth => $baton,\n\t\tconfig => $config,\n\t\tlog_msg => sub {\n\t\t\t${ $_[0] } = defined $_message\n\t\t\t\t? $_message\n\t\t\t\t: 'Create ' . ($_tag ? 'tag ' : 'branch ' )\n\t\t\t\t. $branch_name;\n\t\t},\n\t);\n\n\teval {\n\t\t$ctx->ls($dst, 'HEAD', 0);\n\t} and die \"branch ${branch_name} already exists\\n\";\n\n\tif ($_parents) {\n\t\tmk_parent_dirs($ctx, $dst);\n\t}\n\n\tprint \"Copying ${src} at r${rev} to ${dst}...\\n\";\n\t$ctx->copy($src, $rev, $dst)\n\t\tunless $_dry_run;\n\n\t# Release resources held by ctx before creating another SVN::Ra\n\t# so destruction is orderly.  This seems necessary with SVN 1.9.5\n\t# to avoid segfaults.\n\t$ctx = undef;\n\n\t$gs->fetch_all;\n}\n\nsub mk_parent_dirs {\n\tmy ($ctx, $parent) = @_;\n\t$parent =~ s{/[^/]*$}{};\n\n\tif (!eval{$ctx->ls($parent, 'HEAD', 0)}) {\n\t\tmk_parent_dirs($ctx, $parent);\n\t\tprint \"Creating parent folder ${parent} ...\\n\";\n\t\t$ctx->mkdir($parent) unless $_dry_run;\n\t}\n}\n\nsub cmd_find_rev {\n\tmy $revision_or_hash = shift or die \"SVN or git revision required \",\n\t                                    \"as a command-line argument\\n\";\n\tmy $result;\n\tif ($revision_or_hash =~ /^r\\d+$/) {\n\t\tmy $head = shift;\n\t\t$head ||= 'HEAD';\n\t\tmy @refs;\n\t\tmy (undef, undef, $uuid, $gs) = working_head_info($head, \\@refs);\n\t\tunless ($gs) {\n\t\t\tdie \"Unable to determine upstream SVN information from \",\n\t\t\t    \"$head history\\n\";\n\t\t}\n\t\tmy $desired_revision = substr($revision_or_hash, 1);\n\t\tif ($_before) {\n\t\t\t$result = $gs->find_rev_before($desired_revision, 1);\n\t\t} elsif ($_after) {\n\t\t\t$result = $gs->find_rev_after($desired_revision, 1);\n\t\t} else {\n\t\t\t$result = $gs->rev_map_get($desired_revision, $uuid);\n\t\t}\n\t} else {\n\t\tmy (undef, $rev, undef) = cmt_metadata($revision_or_hash);\n\t\t$result = $rev;\n\t}\n\tprint \"$result\\n\" if $result;\n}\n\nsub auto_create_empty_directories {\n\tmy ($gs) = @_;\n\tmy $var = eval { command_oneline('config', '--get', '--bool',\n\t\t\t\t\t \"svn-remote.$gs->{repo_id}.automkdirs\") };\n\t# By default, create empty directories by consulting the unhandled log,\n\t# but allow setting it to 'false' to skip it.\n\treturn !($var && $var eq 'false');\n}\n\nsub cmd_rebase {\n\tcommand_noisy(qw/update-index --refresh/);\n\tmy ($url, $rev, $uuid, $gs) = working_head_info('HEAD');\n\tunless ($gs) {\n\t\tdie \"Unable to determine upstream SVN information from \",\n\t\t    \"working tree history\\n\";\n\t}\n\tif ($_dry_run) {\n\t\tprint \"Remote Branch: \" . $gs->refname . \"\\n\";\n\t\tprint \"SVN URL: \" . $url . \"\\n\";\n\t\treturn;\n\t}\n\tif (command(qw/diff-index HEAD --/)) {\n\t\tprint STDERR \"Cannot rebase with uncommitted changes:\\n\";\n\t\tcommand_noisy('status');\n\t\texit 1;\n\t}\n\tunless ($_local) {\n\t\t# rebase will checkout for us, so no need to do it explicitly\n\t\t$_no_checkout = 'true';\n\t\t$_fetch_all ? $gs->fetch_all : $gs->fetch;\n\t}\n\tcommand_noisy(rebase_cmd(), $gs->refname);\n\tif (auto_create_empty_directories($gs)) {\n\t\t$gs->mkemptydirs;\n\t}\n}\n\nsub cmd_show_ignore {\n\tmy ($url, $rev, $uuid, $gs) = working_head_info('HEAD');\n\t$gs ||= Git::SVN->new;\n\tmy $r = (defined $_revision ? $_revision : $gs->ra->get_latest_revnum);\n\t$gs->prop_walk($gs->path, $r, sub {\n\t\tmy ($gs, $path, $props) = @_;\n\t\tprint STDOUT \"\\n# $path\\n\";\n\t\tmy $s = $props->{'svn:ignore'} or return;\n\t\t$s =~ s/[\\r\\n]+/\\n/g;\n\t\t$s =~ s/^\\n+//;\n\t\tchomp $s;\n\t\t$s =~ s#^#$path#gm;\n\t\tprint STDOUT \"$s\\n\";\n\t});\n}\n\nsub cmd_show_externals {\n\tmy ($url, $rev, $uuid, $gs) = working_head_info('HEAD');\n\t$gs ||= Git::SVN->new;\n\tmy $r = (defined $_revision ? $_revision : $gs->ra->get_latest_revnum);\n\t$gs->prop_walk($gs->path, $r, sub {\n\t\tmy ($gs, $path, $props) = @_;\n\t\tprint STDOUT \"\\n# $path\\n\";\n\t\tmy $s = $props->{'svn:externals'} or return;\n\t\t$s =~ s/[\\r\\n]+/\\n/g;\n\t\tchomp $s;\n\t\t$s =~ s#^#$path#gm;\n\t\tprint STDOUT \"$s\\n\";\n\t});\n}\n\nsub cmd_create_ignore {\n\tmy ($url, $rev, $uuid, $gs) = working_head_info('HEAD');\n\t$gs ||= Git::SVN->new;\n\tmy $r = (defined $_revision ? $_revision : $gs->ra->get_latest_revnum);\n\t$gs->prop_walk($gs->path, $r, sub {\n\t\tmy ($gs, $path, $props) = @_;\n\t\t# $path is of the form /path/to/dir/\n\t\t$path = '.' . $path;\n\t\t# SVN can have attributes on empty directories,\n\t\t# which git won't track\n\t\tmkpath([$path]) unless -d $path;\n\t\tmy $ignore = $path . '.gitignore';\n\t\tmy $s = $props->{'svn:ignore'} or return;\n\t\topen(GITIGNORE, '>', $ignore)\n\t\t  or fatal(\"Failed to open `$ignore' for writing: $!\");\n\t\t$s =~ s/[\\r\\n]+/\\n/g;\n\t\t$s =~ s/^\\n+//;\n\t\tchomp $s;\n\t\t# Prefix all patterns so that the ignore doesn't apply\n\t\t# to sub-directories.\n\t\t$s =~ s#^#/#gm;\n\t\tprint GITIGNORE \"$s\\n\";\n\t\tclose(GITIGNORE)\n\t\t  or fatal(\"Failed to close `$ignore': $!\");\n\t\tcommand_noisy('add', '-f', $ignore);\n\t});\n}\n\nsub cmd_mkdirs {\n\tmy ($url, $rev, $uuid, $gs) = working_head_info('HEAD');\n\t$gs ||= Git::SVN->new;\n\t$gs->mkemptydirs($_revision);\n}\n\n# get_svnprops(PATH)\n# ------------------\n# Helper for cmd_propget and cmd_proplist below.\nsub get_svnprops {\n\tmy $path = shift;\n\tmy ($url, $rev, $uuid, $gs) = working_head_info('HEAD');\n\t$gs ||= Git::SVN->new;\n\n\t# prefix THE PATH by the sub-directory from which the user\n\t# invoked us.\n\t$path = $cmd_dir_prefix . $path;\n\tfatal(\"No such file or directory: $path\") unless -e $path;\n\tmy $is_dir = -d $path ? 1 : 0;\n\t$path = join_paths($gs->path, $path);\n\n\t# canonicalize the path (otherwise libsvn will abort or fail to\n\t# find the file)\n\t$path = canonicalize_path($path);\n\n\tmy $r = (defined $_revision ? $_revision : $gs->ra->get_latest_revnum);\n\tmy $props;\n\tif ($is_dir) {\n\t\t(undef, undef, $props) = $gs->ra->get_dir($path, $r);\n\t}\n\telse {\n\t\t(undef, $props) = $gs->ra->get_file($path, $r, undef);\n\t}\n\treturn $props;\n}\n\n# cmd_propget (PROP, PATH)\n# ------------------------\n# Print the SVN property PROP for PATH.\nsub cmd_propget {\n\tmy ($prop, $path) = @_;\n\t$path = '.' if not defined $path;\n\tusage(1) if not defined $prop;\n\tmy $props = get_svnprops($path);\n\tif (not defined $props->{$prop}) {\n\t\tfatal(\"`$path' does not have a `$prop' SVN property.\");\n\t}\n\tprint $props->{$prop} . \"\\n\";\n}\n\n# cmd_propset (PROPNAME, PROPVAL, PATH)\n# ------------------------\n# Adjust the SVN property PROPNAME to PROPVAL for PATH.\nsub cmd_propset {\n\tmy ($propname, $propval, $path) = @_;\n\t$path = '.' if not defined $path;\n\t$path = $cmd_dir_prefix . $path;\n\tusage(1) if not defined $propname;\n\tusage(1) if not defined $propval;\n\tmy $file = basename($path);\n\tmy $dn = dirname($path);\n\tmy $cur_props = Git::SVN::Editor::check_attr( \"svn-properties\", $path );\n\tmy @new_props;\n\tif (!$cur_props || $cur_props eq \"unset\" || $cur_props eq \"\" || $cur_props eq \"set\") {\n\t\tpush @new_props, \"$propname=$propval\";\n\t} else {\n\t\t# TODO: handle combining properties better\n\t\tmy @props = split(/;/, $cur_props);\n\t\tmy $replaced_prop;\n\t\tforeach my $prop (@props) {\n\t\t\t# Parse 'name=value' syntax and set the property.\n\t\t\tif ($prop =~ /([^=]+)=(.*)/) {\n\t\t\t\tmy ($n,$v) = ($1,$2);\n\t\t\t\tif ($n eq $propname) {\n\t\t\t\t\t$v = $propval;\n\t\t\t\t\t$replaced_prop = 1;\n\t\t\t\t}\n\t\t\t\tpush @new_props, \"$n=$v\";\n\t\t\t}\n\t\t}\n\t\tif (!$replaced_prop) {\n\t\t\tpush @new_props, \"$propname=$propval\";\n\t\t}\n\t}\n\tmy $attrfile = \"$dn/.gitattributes\";\n\topen my $attrfh, '>>', $attrfile or die \"Can't open $attrfile: $!\\n\";\n\t# TODO: don't simply append here if $file already has svn-properties\n\tmy $new_props = join(';', @new_props);\n\tprint $attrfh \"$file svn-properties=$new_props\\n\" or\n\t\tdie \"write to $attrfile: $!\\n\";\n\tclose $attrfh or die \"close $attrfile: $!\\n\";\n}\n\n# cmd_proplist (PATH)\n# -------------------\n# Print the list of SVN properties for PATH.\nsub cmd_proplist {\n\tmy $path = shift;\n\t$path = '.' if not defined $path;\n\tmy $props = get_svnprops($path);\n\tprint \"Properties on '$path':\\n\";\n\tforeach (sort keys %{$props}) {\n\t\tprint \"  $_\\n\";\n\t}\n}\n\nsub cmd_multi_init {\n\tmy $url = shift;\n\tunless (defined $_trunk || @_branches || @_tags) {\n\t\tusage(1);\n\t}\n\n\t$_prefix = 'origin/' unless defined $_prefix;\n\tif (defined $url) {\n\t\t$url = canonicalize_url($url);\n\t\tinit_subdir(@_);\n\t}\n\tdo_git_init_db();\n\tif (defined $_trunk) {\n\t\t$_trunk =~ s#^/+##;\n\t\tmy $trunk_ref = 'refs/remotes/' . $_prefix . 'trunk';\n\t\t# try both old-style and new-style lookups:\n\t\tmy $gs_trunk = eval { Git::SVN->new($trunk_ref) };\n\t\tunless ($gs_trunk) {\n\t\t\tmy ($trunk_url, $trunk_path) =\n\t\t\t                      complete_svn_url($url, $_trunk);\n\t\t\t$gs_trunk = Git::SVN->init($trunk_url, $trunk_path,\n\t\t\t\t\t\t   undef, $trunk_ref);\n\t\t}\n\t}\n\treturn unless @_branches || @_tags;\n\tmy $ra = $url ? Git::SVN::Ra->new($url) : undef;\n\tforeach my $path (@_branches) {\n\t\tcomplete_url_ls_init($ra, $path, '--branches/-b', $_prefix);\n\t}\n\tforeach my $path (@_tags) {\n\t\tcomplete_url_ls_init($ra, $path, '--tags/-t', $_prefix.'tags/');\n\t}\n}\n\nsub cmd_multi_fetch {\n\t$Git::SVN::no_reuse_existing = undef;\n\tmy $remotes = Git::SVN::read_all_remotes();\n\tforeach my $repo_id (sort keys %$remotes) {\n\t\tif ($remotes->{$repo_id}->{url}) {\n\t\t\tGit::SVN::fetch_all($repo_id, $remotes);\n\t\t}\n\t}\n}\n\n# this command is special because it requires no metadata\nsub cmd_commit_diff {\n\tmy ($ta, $tb, $url) = @_;\n\tmy $usage = \"usage: $0 commit-diff -r<revision> \".\n\t            \"<tree-ish> <tree-ish> [<URL>]\";\n\tfatal($usage) if (!defined $ta || !defined $tb);\n\tmy $svn_path = '';\n\tif (!defined $url) {\n\t\tmy $gs = eval { Git::SVN->new };\n\t\tif (!$gs) {\n\t\t\tfatal(\"Needed URL or usable git-svn --id in \",\n\t\t\t      \"the command-line\\n\", $usage);\n\t\t}\n\t\t$url = $gs->url;\n\t\t$svn_path = $gs->path;\n\t}\n\tunless (defined $_revision) {\n\t\tfatal(\"-r|--revision is a required argument\\n\", $usage);\n\t}\n\tif (defined $_message && defined $_file) {\n\t\tfatal(\"Both --message/-m and --file/-F specified \",\n\t\t      \"for the commit message.\\n\",\n\t\t      \"I have no idea what you mean\");\n\t}\n\tif (defined $_file) {\n\t\t$_message = file_to_s($_file);\n\t} else {\n\t\t$_message ||= get_commit_entry($tb)->{log};\n\t}\n\tmy $ra ||= Git::SVN::Ra->new($url);\n\tmy $r = $_revision;\n\tif ($r eq 'HEAD') {\n\t\t$r = $ra->get_latest_revnum;\n\t} elsif ($r !~ /^\\d+$/) {\n\t\tdie \"revision argument: $r not understood by git-svn\\n\";\n\t}\n\tmy %ed_opts = ( r => $r,\n\t                log => $_message,\n\t                ra => $ra,\n\t                tree_a => $ta,\n\t                tree_b => $tb,\n\t                editor_cb => sub { print \"Committed r$_[0]\\n\" },\n\t                svn_path => $svn_path );\n\tif (!Git::SVN::Editor->new(\\%ed_opts)->apply_diff) {\n\t\tprint \"No changes\\n$ta == $tb\\n\";\n\t}\n}\n\nsub cmd_info {\n\tmy $path_arg = defined($_[0]) ? $_[0] : '.';\n\tmy $path = $path_arg;\n\tif (File::Spec->file_name_is_absolute($path)) {\n\t\t$path = canonicalize_path($path);\n\n\t\tmy $toplevel = eval {\n\t\t\tmy @cmd = qw/rev-parse --show-toplevel/;\n\t\t\tcommand_oneline(\\@cmd, STDERR => 0);\n\t\t};\n\n\t\t# remove $toplevel from the absolute path:\n\t\tmy ($vol, $dirs, $file) = File::Spec->splitpath($path);\n\t\tmy (undef, $tdirs, $tfile) = File::Spec->splitpath($toplevel);\n\t\tmy @dirs = File::Spec->splitdir($dirs);\n\t\tmy @tdirs = File::Spec->splitdir($tdirs);\n\t\tpop @dirs if $dirs[-1] eq '';\n\t\tpop @tdirs if $tdirs[-1] eq '';\n\t\tpush @dirs, $file;\n\t\tpush @tdirs, $tfile;\n\t\twhile (@tdirs && @dirs && $tdirs[0] eq $dirs[0]) {\n\t\t\tshift @dirs;\n\t\t\tshift @tdirs;\n\t\t}\n\t\t$dirs = File::Spec->catdir(@dirs);\n\t\t$path = File::Spec->catpath($vol, $dirs);\n\n\t\t$path = canonicalize_path($path);\n\t} else {\n\t\t$path = canonicalize_path($cmd_dir_prefix . $path);\n\t}\n\tif (exists $_[1]) {\n\t\tdie \"Too many arguments specified\\n\";\n\t}\n\n\tmy ($file_type, $diff_status) = find_file_type_and_diff_status($path);\n\n\tif (!$file_type && !$diff_status) {\n\t\tprint STDERR \"svn: '$path' is not under version control\\n\";\n\t\texit 1;\n\t}\n\n\tmy ($url, $rev, $uuid, $gs) = working_head_info('HEAD');\n\tunless ($gs) {\n\t\tdie \"Unable to determine upstream SVN information from \",\n\t\t    \"working tree history\\n\";\n\t}\n\n\t# canonicalize_path() will return \"\" to make libsvn 1.5.x happy,\n\t$path = \".\" if $path eq \"\";\n\n\tmy $full_url = canonicalize_url( add_path_to_url( $url, $path ) );\n\n\tif ($_url) {\n\t\tprint \"$full_url\\n\";\n\t\treturn;\n\t}\n\n\tmy $result = \"Path: $path_arg\\n\";\n\t$result .= \"Name: \" . basename($path) . \"\\n\" if $file_type ne \"dir\";\n\t$result .= \"URL: $full_url\\n\";\n\n\teval {\n\t\tmy $repos_root = $gs->repos_root;\n\t\tGit::SVN::remove_username($repos_root);\n\t\t$result .= \"Repository Root: \" . canonicalize_url($repos_root) . \"\\n\";\n\t};\n\tif ($@) {\n\t\t$result .= \"Repository Root: (offline)\\n\";\n\t}\n\t::_req_svn();\n\t$result .= \"Repository UUID: $uuid\\n\" unless $diff_status eq \"A\" &&\n\t\t(::compare_svn_version('1.5.4') <= 0 || $file_type ne \"dir\");\n\t$result .= \"Revision: \" . ($diff_status eq \"A\" ? 0 : $rev) . \"\\n\";\n\n\t$result .= \"Node Kind: \" .\n\t\t   ($file_type eq \"dir\" ? \"directory\" : \"file\") . \"\\n\";\n\n\tmy $schedule = $diff_status eq \"A\"\n\t\t       ? \"add\"\n\t\t       : ($diff_status eq \"D\" ? \"delete\" : \"normal\");\n\t$result .= \"Schedule: $schedule\\n\";\n\n\tif ($diff_status eq \"A\") {\n\t\tprint $result, \"\\n\";\n\t\treturn;\n\t}\n\n\tmy ($lc_author, $lc_rev, $lc_date_utc);\n\tmy @args = Git::SVN::Log::git_svn_log_cmd($rev, $rev, \"--\", $path);\n\tmy $log = command_output_pipe(@args);\n\tmy $esc_color = qr/(?:\\033\\[(?:(?:\\d+;)*\\d*)?m)*/;\n\twhile (<$log>) {\n\t\tif (/^${esc_color}author (.+) <[^>]+> (\\d+) ([\\-\\+]?\\d+)$/o) {\n\t\t\t$lc_author = $1;\n\t\t\t$lc_date_utc = Git::SVN::Log::parse_git_date($2, $3);\n\t\t} elsif (/^${esc_color}    (git-svn-id:.+)$/o) {\n\t\t\t(undef, $lc_rev, undef) = ::extract_metadata($1);\n\t\t}\n\t}\n\tclose $log;\n\n\tGit::SVN::Log::set_local_timezone();\n\n\t$result .= \"Last Changed Author: $lc_author\\n\";\n\t$result .= \"Last Changed Rev: $lc_rev\\n\";\n\t$result .= \"Last Changed Date: \" .\n\t\t   Git::SVN::Log::format_svn_date($lc_date_utc) . \"\\n\";\n\n\tif ($file_type ne \"dir\") {\n\t\tmy $text_last_updated_date =\n\t\t    ($diff_status eq \"D\" ? $lc_date_utc : (stat $path)[9]);\n\t\t$result .=\n\t\t    \"Text Last Updated: \" .\n\t\t    Git::SVN::Log::format_svn_date($text_last_updated_date) .\n\t\t    \"\\n\";\n\t\tmy $checksum;\n\t\tif ($diff_status eq \"D\") {\n\t\t\tmy ($fh, $ctx) =\n\t\t\t    command_output_pipe(qw(cat-file blob), \"HEAD:$path\");\n\t\t\tif ($file_type eq \"link\") {\n\t\t\t\tmy $file_name = <$fh>;\n\t\t\t\t$checksum = md5sum(\"link $file_name\");\n\t\t\t} else {\n\t\t\t\t$checksum = md5sum($fh);\n\t\t\t}\n\t\t\tcommand_close_pipe($fh, $ctx);\n\t\t} elsif ($file_type eq \"link\") {\n\t\t\tmy $file_name =\n\t\t\t    command(qw(cat-file blob), \"HEAD:$path\");\n\t\t\t$checksum =\n\t\t\t    md5sum(\"link \" . $file_name);\n\t\t} else {\n\t\t\topen FILE, \"<\", $path or die $!;\n\t\t\t$checksum = md5sum(\\*FILE);\n\t\t\tclose FILE or die $!;\n\t\t}\n\t\t$result .= \"Checksum: \" . $checksum . \"\\n\";\n\t}\n\n\tprint $result, \"\\n\";\n}\n\nsub cmd_reset {\n\tmy $target = shift || $_revision or die \"SVN revision required\\n\";\n\t$target = $1 if $target =~ /^r(\\d+)$/;\n\t$target =~ /^\\d+$/ or die \"Numeric SVN revision expected\\n\";\n\tmy ($url, $rev, $uuid, $gs) = working_head_info('HEAD');\n\tunless ($gs) {\n\t\tdie \"Unable to determine upstream SVN information from \".\n\t\t    \"history\\n\";\n\t}\n\tmy ($r, $c) = $gs->find_rev_before($target, not $_fetch_parent);\n\tdie \"Cannot find SVN revision $target\\n\" unless defined($c);\n\t$gs->rev_map_set($r, $c, 'reset', $uuid);\n\tprint \"r$r = $c ($gs->{ref_id})\\n\";\n}\n\nsub cmd_gc {\n\trequire File::Find;\n\tif (!can_compress()) {\n\t\twarn \"Compress::Zlib could not be found; unhandled.log \" .\n\t\t     \"files will not be compressed.\\n\";\n\t}\n\tFile::Find::find({ wanted => \\&gc_directory, no_chdir => 1},\n\t\t\t Git::SVN::svn_dir());\n}\n\n########################### utility functions #########################\n\nsub rebase_cmd {\n\tmy @cmd = qw/rebase/;\n\tpush @cmd, '-v' if $_verbose;\n\tpush @cmd, qw/--merge/ if $_merge;\n\tpush @cmd, \"--strategy=$_strategy\" if $_strategy;\n\tpush @cmd, \"--rebase-merges\" if $_rebase_merges;\n\t@cmd;\n}\n\nsub post_fetch_checkout {\n\treturn if $_no_checkout;\n\treturn if verify_ref('HEAD^0');\n\tmy $gs = $Git::SVN::_head or return;\n\n\t# look for \"trunk\" ref if it exists\n\tmy $remote = Git::SVN::read_all_remotes()->{$gs->{repo_id}};\n\tmy $fetch = $remote->{fetch};\n\tif ($fetch) {\n\t\tforeach my $p (keys %$fetch) {\n\t\t\tbasename($fetch->{$p}) eq 'trunk' or next;\n\t\t\t$gs = Git::SVN->new($fetch->{$p}, $gs->{repo_id}, $p);\n\t\t\tlast;\n\t\t}\n\t}\n\n\tcommand_noisy(qw(update-ref HEAD), $gs->refname);\n\treturn unless verify_ref('HEAD^0');\n\n\treturn if $ENV{GIT_DIR} !~ m#^(?:.*/)?\\.git$#;\n\tmy $index = command_oneline(qw(rev-parse --git-path index));\n\treturn if -f $index;\n\n\treturn if command_oneline(qw/rev-parse --is-inside-work-tree/) eq 'false';\n\treturn if command_oneline(qw/rev-parse --is-inside-git-dir/) eq 'true';\n\tcommand_noisy(qw/read-tree -m -u -v HEAD HEAD/);\n\tprint STDERR \"Checked out HEAD:\\n  \",\n\t             $gs->full_url, \" r\", $gs->last_rev, \"\\n\";\n\tif (auto_create_empty_directories($gs)) {\n\t\t$gs->mkemptydirs($gs->last_rev);\n\t}\n}\n\nsub complete_svn_url {\n\tmy ($url, $path) = @_;\n\n\tif ($path =~ m#^[a-z\\+]+://#i) { # path is a URL\n\t\t$path = canonicalize_url($path);\n\t} else {\n\t\t$path = canonicalize_path($path);\n\t\tif (!defined $url || $url !~ m#^[a-z\\+]+://#i) {\n\t\t\tfatal(\"E: '$path' is not a complete URL \",\n\t\t\t      \"and a separate URL is not specified\");\n\t\t}\n\t\treturn ($url, $path);\n\t}\n\treturn ($path, '');\n}\n\nsub complete_url_ls_init {\n\tmy ($ra, $repo_path, $switch, $pfx) = @_;\n\tunless ($repo_path) {\n\t\tprint STDERR \"W: $switch not specified\\n\";\n\t\treturn;\n\t}\n\tif ($repo_path =~ m#^[a-z\\+]+://#i) {\n\t\t$repo_path = canonicalize_url($repo_path);\n\t\t$ra = Git::SVN::Ra->new($repo_path);\n\t\t$repo_path = '';\n\t} else {\n\t\t$repo_path = canonicalize_path($repo_path);\n\t\t$repo_path =~ s#^/+##;\n\t\tunless ($ra) {\n\t\t\tfatal(\"E: '$repo_path' is not a complete URL \",\n\t\t\t      \"and a separate URL is not specified\");\n\t\t}\n\t}\n\tmy $url = $ra->url;\n\tmy $gs = Git::SVN->init($url, undef, undef, undef, 1);\n\tmy $k = \"svn-remote.$gs->{repo_id}.url\";\n\tmy $orig_url = eval { command_oneline(qw/config --get/, $k) };\n\tif ($orig_url && ($orig_url ne $gs->url)) {\n\t\tdie \"$k already set: $orig_url\\n\",\n\t\t    \"wanted to set to: $gs->url\\n\";\n\t}\n\tcommand_oneline('config', $k, $gs->url) unless $orig_url;\n\n\tmy $remote_path = join_paths( $gs->path, $repo_path );\n\t$remote_path =~ s{%([0-9A-F]{2})}{chr hex($1)}ieg;\n\t$remote_path =~ s#^/##g;\n\t$remote_path .= \"/*\" if $remote_path !~ /\\*/;\n\tmy ($n) = ($switch =~ /^--(\\w+)/);\n\tif (length $pfx && $pfx !~ m#/$#) {\n\t\tdie \"--prefix='$pfx' must have a trailing slash '/'\\n\";\n\t}\n\tcommand_noisy('config',\n\t\t      '--add',\n\t              \"svn-remote.$gs->{repo_id}.$n\",\n\t              \"$remote_path:refs/remotes/$pfx*\" .\n\t                ('/*' x (($remote_path =~ tr/*/*/) - 1)) );\n}\n\nsub verify_ref {\n\tmy ($ref) = @_;\n\teval { command_oneline([ 'rev-parse', '--verify', $ref ],\n\t                       { STDERR => 0 }); };\n}\n\nsub get_tree_from_treeish {\n\tmy ($treeish) = @_;\n\t# $treeish can be a symbolic ref, too:\n\tmy $type = command_oneline(qw/cat-file -t/, $treeish);\n\tmy $expected;\n\twhile ($type eq 'tag') {\n\t\t($treeish, $type) = command(qw/cat-file tag/, $treeish);\n\t}\n\tif ($type eq 'commit') {\n\t\t$expected = (grep /^tree /, command(qw/cat-file commit/,\n\t\t                                    $treeish))[0];\n\t\t($expected) = ($expected =~ /^tree ($oid)$/o);\n\t\tdie \"Unable to get tree from $treeish\\n\" unless $expected;\n\t} elsif ($type eq 'tree') {\n\t\t$expected = $treeish;\n\t} else {\n\t\tdie \"$treeish is a $type, expected tree, tag or commit\\n\";\n\t}\n\treturn $expected;\n}\n\nsub get_commit_entry {\n\tmy ($treeish) = shift;\n\tmy %log_entry = ( log => '', tree => get_tree_from_treeish($treeish) );\n\tmy @git_path = qw(rev-parse --git-path);\n\tmy $commit_editmsg = command_oneline(@git_path, 'COMMIT_EDITMSG');\n\tmy $commit_msg = command_oneline(@git_path, 'COMMIT_MSG');\n\topen my $log_fh, '>', $commit_editmsg or croak $!;\n\n\tmy $type = command_oneline(qw/cat-file -t/, $treeish);\n\tif ($type eq 'commit' || $type eq 'tag') {\n\t\tmy ($msg_fh, $ctx) = command_output_pipe('cat-file',\n\t\t                                         $type, $treeish);\n\t\tmy $in_msg = 0;\n\t\tmy $author;\n\t\tmy $saw_from = 0;\n\t\tmy $msgbuf = \"\";\n\t\twhile (<$msg_fh>) {\n\t\t\tif (!$in_msg) {\n\t\t\t\t$in_msg = 1 if (/^$/);\n\t\t\t\t$author = $1 if (/^author (.*>)/);\n\t\t\t} elsif (/^git-svn-id: /) {\n\t\t\t\t# skip this for now, we regenerate the\n\t\t\t\t# correct one on re-fetch anyways\n\t\t\t\t# TODO: set *:merge properties or like...\n\t\t\t} else {\n\t\t\t\tif (/^From:/ || /^Signed-off-by:/) {\n\t\t\t\t\t$saw_from = 1;\n\t\t\t\t}\n\t\t\t\t$msgbuf .= $_;\n\t\t\t}\n\t\t}\n\t\t$msgbuf =~ s/\\s+$//s;\n\t\t$msgbuf =~ s/\\r\\n/\\n/sg; # SVN 1.6+ disallows CRLF\n\t\tif ($Git::SVN::_add_author_from && defined($author)\n\t\t    && !$saw_from) {\n\t\t\t$msgbuf .= \"\\n\\nFrom: $author\";\n\t\t}\n\t\tprint $log_fh $msgbuf or croak $!;\n\t\tcommand_close_pipe($msg_fh, $ctx);\n\t}\n\tclose $log_fh or croak $!;\n\n\tif ($_edit || ($type eq 'tree')) {\n\t\tchomp(my $editor = command_oneline(qw(var GIT_EDITOR)));\n\t\tsystem('sh', '-c', $editor.' \"$@\"', $editor, $commit_editmsg);\n\t}\n\trename $commit_editmsg, $commit_msg or croak $!;\n\t{\n\t\trequire Encode;\n\t\t# SVN requires messages to be UTF-8 when entering the repo\n\t\topen $log_fh, '<', $commit_msg or croak $!;\n\t\tbinmode $log_fh;\n\t\tchomp($log_entry{log} = get_record($log_fh, undef));\n\n\t\tmy $enc = Git::config('i18n.commitencoding') || 'UTF-8';\n\t\tmy $msg = $log_entry{log};\n\n\t\teval { $msg = Encode::decode($enc, $msg, 1) };\n\t\tif ($@) {\n\t\t\tdie \"Could not decode as $enc:\\n\", $msg,\n\t\t\t    \"\\nPerhaps you need to set i18n.commitencoding\\n\";\n\t\t}\n\n\t\teval { $msg = Encode::encode('UTF-8', $msg, 1) };\n\t\tdie \"Could not encode as UTF-8:\\n$msg\\n\" if $@;\n\n\t\t$log_entry{log} = $msg;\n\n\t\tclose $log_fh or croak $!;\n\t}\n\tunlink $commit_msg;\n\t\\%log_entry;\n}\n\nsub s_to_file {\n\tmy ($str, $file, $mode) = @_;\n\topen my $fd,'>',$file or croak $!;\n\tprint $fd $str,\"\\n\" or croak $!;\n\tclose $fd or croak $!;\n\tchmod ($mode &~ umask, $file) if (defined $mode);\n}\n\nsub file_to_s {\n\tmy $file = shift;\n\topen my $fd,'<',$file or croak \"$!: file: $file\\n\";\n\tlocal $/;\n\tmy $ret = <$fd>;\n\tclose $fd or croak $!;\n\t$ret =~ s/\\s*$//s;\n\treturn $ret;\n}\n\n# '<svn username> = real-name <email address>' mapping based on git-svnimport:\nsub load_authors {\n\topen my $authors, '<', $_authors or die \"Can't open $_authors $!\\n\";\n\tmy $log = $cmd eq 'log';\n\twhile (<$authors>) {\n\t\tchomp;\n\t\tnext unless /^(.+?|\\(no author\\))\\s*=\\s*(.+?)\\s*<(.*)>\\s*$/;\n\t\tmy ($user, $name, $email) = ($1, $2, $3);\n\t\tif ($log) {\n\t\t\t$Git::SVN::Log::rusers{\"$name <$email>\"} = $user;\n\t\t} else {\n\t\t\t$users{$user} = [$name, $email];\n\t\t}\n\t}\n\tclose $authors or croak $!;\n}\n\n# convert GetOpt::Long specs for use by git-config\nsub read_git_config {\n\tmy $opts = shift;\n\tmy @config_only;\n\tforeach my $o (keys %$opts) {\n\t\t# if we have mixedCase and a long option-only, then\n\t\t# it's a config-only variable that we don't need for\n\t\t# the command-line.\n\t\tpush @config_only, $o if ($o =~ /[A-Z]/ && $o =~ /^[a-z]+$/i);\n\t\tmy $v = $opts->{$o};\n\t\tmy ($key) = ($o =~ /^([a-zA-Z\\-]+)/);\n\t\t$key =~ s/-//g;\n\t\tmy $arg = 'git config';\n\t\t$arg .= ' --int' if ($o =~ /[:=]i$/);\n\t\t$arg .= ' --bool' if ($o !~ /[:=][sfi]$/);\n\t\tif (ref $v eq 'ARRAY') {\n\t\t\tchomp(my @tmp = `$arg --get-all svn.$key`);\n\t\t\t@$v = @tmp if @tmp;\n\t\t} else {\n\t\t\tchomp(my $tmp = `$arg --get svn.$key`);\n\t\t\tif ($tmp && !($arg =~ / --bool/ && $tmp eq 'false')) {\n\t\t\t\t$$v = $tmp;\n\t\t\t}\n\t\t}\n\t}\n\tdelete @$opts{@config_only} if @config_only;\n}\n\nsub extract_metadata {\n\tmy $id = shift or return (undef, undef, undef);\n\tmy ($url, $rev, $uuid) = ($id =~ /^\\s*git-svn-id:\\s+(.*)\\@(\\d+)\n\t\t\t\t\t\t\t\\s([a-f\\d\\-]+)$/ix);\n\tif (!defined $rev || !$uuid || !$url) {\n\t\t# some of the original repositories I made had\n\t\t# identifiers like this:\n\t\t($rev, $uuid) = ($id =~/^\\s*git-svn-id:\\s(\\d+)\\@([a-f\\d\\-]+)/i);\n\t}\n\treturn ($url, $rev, $uuid);\n}\n\nsub cmt_metadata {\n\treturn extract_metadata((grep(/^git-svn-id: /,\n\t\tcommand(qw/cat-file commit/, shift)))[-1]);\n}\n\nsub cmt_sha2rev_batch {\n\tmy %s2r;\n\tmy ($pid, $in, $out, $ctx) = command_bidi_pipe(qw/cat-file --batch/);\n\tmy $list = shift;\n\n\tforeach my $sha (@{$list}) {\n\t\tmy $first = 1;\n\t\tmy $size = 0;\n\t\tprint $out $sha, \"\\n\";\n\n\t\twhile (my $line = <$in>) {\n\t\t\tif ($first && $line =~ /^$::oid\\smissing$/) {\n\t\t\t\tlast;\n\t\t\t} elsif ($first &&\n\t\t\t       $line =~ /^$::oid\\scommit\\s(\\d+)$/) {\n\t\t\t\t$first = 0;\n\t\t\t\t$size = $1;\n\t\t\t\tnext;\n\t\t\t} elsif ($line =~ /^(git-svn-id: )/) {\n\t\t\t\tmy (undef, $rev, undef) =\n\t\t\t\t                      extract_metadata($line);\n\t\t\t\t$s2r{$sha} = $rev;\n\t\t\t}\n\n\t\t\t$size -= length($line);\n\t\t\tlast if ($size == 0);\n\t\t}\n\t}\n\n\tcommand_close_bidi_pipe($pid, $in, $out, $ctx);\n\n\treturn \\%s2r;\n}\n\nsub working_head_info {\n\tmy ($head, $refs) = @_;\n\tmy @args = qw/rev-list --first-parent --pretty=medium/;\n\tmy ($fh, $ctx) = command_output_pipe(@args, $head, \"--\");\n\tmy $hash;\n\tmy %max;\n\twhile (<$fh>) {\n\t\tif ( m{^commit ($::oid)$} ) {\n\t\t\tunshift @$refs, $hash if $hash and $refs;\n\t\t\t$hash = $1;\n\t\t\tnext;\n\t\t}\n\t\tnext unless s{^\\s*(git-svn-id:)}{$1};\n\t\tmy ($url, $rev, $uuid) = extract_metadata($_);\n\t\tif (defined $url && defined $rev) {\n\t\t\tnext if $max{$url} and $max{$url} < $rev;\n\t\t\tif (my $gs = Git::SVN->find_by_url($url)) {\n\t\t\t\tmy $c = $gs->rev_map_get($rev, $uuid);\n\t\t\t\tif ($c && $c eq $hash) {\n\t\t\t\t\tclose $fh; # break the pipe\n\t\t\t\t\treturn ($url, $rev, $uuid, $gs);\n\t\t\t\t} else {\n\t\t\t\t\t$max{$url} ||= $gs->rev_map_max;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcommand_close_pipe($fh, $ctx);\n\t(undef, undef, undef, undef);\n}\n\nsub read_commit_parents {\n\tmy ($parents, $c) = @_;\n\tchomp(my $p = command_oneline(qw/rev-list --parents -1/, $c));\n\t$p =~ s/^($c)\\s*// or die \"rev-list --parents -1 $c failed!\\n\";\n\t@{$parents->{$c}} = split(/ /, $p);\n}\n\nsub linearize_history {\n\tmy ($gs, $refs) = @_;\n\tmy %parents;\n\tforeach my $c (@$refs) {\n\t\tread_commit_parents(\\%parents, $c);\n\t}\n\n\tmy @linear_refs;\n\tmy %skip = ();\n\tmy $last_svn_commit = $gs->last_commit;\n\tforeach my $c (reverse @$refs) {\n\t\tnext if $c eq $last_svn_commit;\n\t\tlast if $skip{$c};\n\n\t\tunshift @linear_refs, $c;\n\t\t$skip{$c} = 1;\n\n\t\t# we only want the first parent to diff against for linear\n\t\t# history, we save the rest to inject when we finalize the\n\t\t# svn commit\n\t\tmy $fp_a = verify_ref(\"$c~1\");\n\t\tmy $fp_b = shift @{$parents{$c}} if $parents{$c};\n\t\tif (!$fp_a || !$fp_b) {\n\t\t\tdie \"Commit $c\\n\",\n\t\t\t    \"has no parent commit, and therefore \",\n\t\t\t    \"nothing to diff against.\\n\",\n\t\t\t    \"You should be working from a repository \",\n\t\t\t    \"originally created by git-svn\\n\";\n\t\t}\n\t\tif ($fp_a ne $fp_b) {\n\t\t\tdie \"$c~1 = $fp_a, however parsing commit $c \",\n\t\t\t    \"revealed that:\\n$c~1 = $fp_b\\nBUG!\\n\";\n\t\t}\n\n\t\tforeach my $p (@{$parents{$c}}) {\n\t\t\t$skip{$p} = 1;\n\t\t}\n\t}\n\t(\\@linear_refs, \\%parents);\n}\n\nsub find_file_type_and_diff_status {\n\tmy ($path) = @_;\n\treturn ('dir', '') if $path eq '';\n\n\tmy $diff_output =\n\t    command_oneline(qw(diff --cached --name-status --), $path) || \"\";\n\tmy $diff_status = (split(' ', $diff_output))[0] || \"\";\n\n\tmy $ls_tree = command_oneline(qw(ls-tree HEAD), $path) || \"\";\n\n\treturn (undef, undef) if !$diff_status && !$ls_tree;\n\n\tif ($diff_status eq \"A\") {\n\t\treturn (\"link\", $diff_status) if -l $path;\n\t\treturn (\"dir\", $diff_status) if -d $path;\n\t\treturn (\"file\", $diff_status);\n\t}\n\n\tmy $mode = (split(' ', $ls_tree))[0] || \"\";\n\n\treturn (\"link\", $diff_status) if $mode eq \"120000\";\n\treturn (\"dir\", $diff_status) if $mode eq \"040000\";\n\treturn (\"file\", $diff_status);\n}\n\nsub md5sum {\n\tmy $arg = shift;\n\tmy $ref = ref $arg;\n\trequire Digest::MD5;\n\tmy $md5 = Digest::MD5->new();\n        if ($ref eq 'GLOB' || $ref eq 'IO::File' || $ref eq 'File::Temp') {\n\t\t$md5->addfile($arg) or croak $!;\n\t} elsif ($ref eq 'SCALAR') {\n\t\t$md5->add($$arg) or croak $!;\n\t} elsif (!$ref) {\n\t\t$md5->add($arg) or croak $!;\n\t} else {\n\t\tfatal \"Can't provide MD5 hash for unknown ref type: '\", $ref, \"'\";\n\t}\n\treturn $md5->hexdigest();\n}\n\nsub gc_directory {\n\tif (can_compress() && -f $_ && basename($_) eq \"unhandled.log\") {\n\t\tmy $out_filename = $_ . \".gz\";\n\t\topen my $in_fh, \"<\", $_ or die \"Unable to open $_: $!\\n\";\n\t\tbinmode $in_fh;\n\t\tmy $gz = Compress::Zlib::gzopen($out_filename, \"ab\") or\n\t\t\t\tdie \"Unable to open $out_filename: $!\\n\";\n\n\t\tmy $res;\n\t\twhile ($res = sysread($in_fh, my $str, 1024)) {\n\t\t\t$gz->gzwrite($str) or\n\t\t\t\tdie \"Unable to write: \".$gz->gzerror().\"!\\n\";\n\t\t}\n\t\tno warnings 'once'; # $File::Find::name would warn\n\t\tunlink $_ or die \"unlink $File::Find::name: $!\\n\";\n\t} elsif (-f $_ && basename($_) eq \"index\") {\n\t\tunlink $_ or die \"unlink $_: $!\\n\";\n\t}\n}\n\n__END__\n\nData structures:\n\n\n$remotes = { # returned by read_all_remotes()\n\t'svn' => {\n\t\t# svn-remote.svn.url=https://svn.musicpd.org\n\t\turl => 'https://svn.musicpd.org',\n\t\t# svn-remote.svn.fetch=mpd/trunk:trunk\n\t\tfetch => {\n\t\t\t'mpd/trunk' => 'trunk',\n\t\t},\n\t\t# svn-remote.svn.tags=mpd/tags/*:tags/*\n\t\ttags => {\n\t\t\tpath => {\n\t\t\t\tleft => 'mpd/tags',\n\t\t\t\tright => '',\n\t\t\t\tregex => qr!mpd/tags/([^/]+)$!,\n\t\t\t\tglob => 'tags/*',\n\t\t\t},\n\t\t\tref => {\n\t\t\t\tleft => 'tags',\n\t\t\t\tright => '',\n\t\t\t\tregex => qr!tags/([^/]+)$!,\n\t\t\t\tglob => 'tags/*',\n\t\t\t},\n\t\t}\n\t}\n};\n\n$log_entry hashref as returned by libsvn_log_entry()\n{\n\tlog => 'whitespace-formatted log entry\n',\t\t\t\t\t\t# trailing newline is preserved\n\trevision => '8',\t\t\t# integer\n\tdate => '2004-02-24T17:01:44.108345Z',\t# commit date\n\tauthor => 'committer name'\n};\n\n\n# this is generated by generate_diff();\n@mods = array of diff-index line hashes, each element represents one line\n\tof diff-index output\n\ndiff-index line ($m hash)\n{\n\tmode_a => first column of diff-index output, no leading ':',\n\tmode_b => second column of diff-index output,\n\tsha1_b => sha1sum of the final blob,\n\tchg => change type [MCRADT],\n\tfile_a => original file name of a file (iff chg is 'C' or 'R')\n\tfile_b => new/current file name of a file (any chg)\n}\n;\n\n# retval of read_url_paths{,_all}();\n$l_map = {\n\t# repository root url\n\t'https://svn.musicpd.org' => {\n\t\t# repository path \t\t# GIT_SVN_ID\n\t\t'mpd/trunk'\t\t=>\t'trunk',\n\t\t'mpd/tags/0.11.5'\t=>\t'tags/0.11.5',\n\t},\n}\n\nNotes:\n\tI don't trust the each() function on unless I created %hash myself\n\tbecause the internal iterator may not have started at base.\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00276c051bbda5be2fe87e34a9db3ef60fa82ed4",
  "sha1_ok": true,
  "size": 64476
}
