{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJvYmplY3QuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAidGFnLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAiZXhlY19jbWQuaCIKI2luY2x1ZGUgInV0ZjguaCIKI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCIKI2luY2x1ZGUgImNhY2hlLXRyZWUuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgInJldmlzaW9uLmgiCiNpbmNsdWRlICJyZXJlcmUuaCIKI2luY2x1ZGUgIm1lcmdlLXJlY3Vyc2l2ZS5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJzZXF1ZW5jZXIuaCIKCi8qCiAqIFRoaXMgaW1wbGVtZW50cyB0aGUgYnVpbHRpbnMgcmV2ZXJ0IGFuZCBjaGVycnktcGljay4KICoKICogQ29weXJpZ2h0IChjKSAyMDA3IEpvaGFubmVzIEUuIFNjaGluZGVsaW4KICoKICogQmFzZWQgb24gZ2l0LXJldmVydC5zaCwgd2hpY2ggaXMKICoKICogQ29weXJpZ2h0IChjKSAyMDA1IExpbnVzIFRvcnZhbGRzCiAqIENvcHlyaWdodCAoYykgMjAwNSBKdW5pbyBDIEhhbWFubwogKi8KCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgcmV2ZXJ0X3VzYWdlW10gPSB7CgkiZ2l0IHJldmVydCBbb3B0aW9uc10gPGNvbW1pdC1pc2g+IiwKCSJnaXQgcmV2ZXJ0IDxzdWJjb21tYW5kPiIsCglOVUxMCn07CgpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGNoZXJyeV9waWNrX3VzYWdlW10gPSB7CgkiZ2l0IGNoZXJyeS1waWNrIFtvcHRpb25zXSA8Y29tbWl0LWlzaD4iLAoJImdpdCBjaGVycnktcGljayA8c3ViY29tbWFuZD4iLAoJTlVMTAp9OwoKZW51bSByZXBsYXlfYWN0aW9uIHsgUkVWRVJULCBDSEVSUllfUElDSyB9OwplbnVtIHJlcGxheV9zdWJjb21tYW5kIHsgUkVQTEFZX05PTkUsIFJFUExBWV9SRVNFVCB9OwoKc3RydWN0IHJlcGxheV9vcHRzIHsKCWVudW0gcmVwbGF5X2FjdGlvbiBhY3Rpb247CgllbnVtIHJlcGxheV9zdWJjb21tYW5kIHN1YmNvbW1hbmQ7CgoJLyogQm9vbGVhbiBvcHRpb25zICovCglpbnQgZWRpdDsKCWludCByZWNvcmRfb3JpZ2luOwoJaW50IG5vX2NvbW1pdDsKCWludCBzaWdub2ZmOwoJaW50IGFsbG93X2ZmOwoJaW50IGFsbG93X3JlcmVyZV9hdXRvOwoKCWludCBtYWlubGluZTsKCWludCBjb21taXRfYXJnYzsKCWNvbnN0IGNoYXIgKipjb21taXRfYXJndjsKCgkvKiBNZXJnZSBzdHJhdGVneSAqLwoJY29uc3QgY2hhciAqc3RyYXRlZ3k7Cgljb25zdCBjaGFyICoqeG9wdHM7CglzaXplX3QgeG9wdHNfbnIsIHhvcHRzX2FsbG9jOwp9OwoKI2RlZmluZSBHSVRfUkVGTE9HX0FDVElPTiAiR0lUX1JFRkxPR19BQ1RJT04iCgpzdGF0aWMgY29uc3QgY2hhciAqYWN0aW9uX25hbWUoY29uc3Qgc3RydWN0IHJlcGxheV9vcHRzICpvcHRzKQp7CglyZXR1cm4gb3B0cy0+YWN0aW9uID09IFJFVkVSVCA/ICJyZXZlcnQiIDogImNoZXJyeS1waWNrIjsKfQoKc3RhdGljIGNoYXIgKmdldF9lbmNvZGluZyhjb25zdCBjaGFyICptZXNzYWdlKTsKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgKnJldmVydF9vcl9jaGVycnlfcGlja191c2FnZShzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMpCnsKCXJldHVybiBvcHRzLT5hY3Rpb24gPT0gUkVWRVJUID8gcmV2ZXJ0X3VzYWdlIDogY2hlcnJ5X3BpY2tfdXNhZ2U7Cn0KCnN0YXRpYyBpbnQgb3B0aW9uX3BhcnNlX3goY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LAoJCQkgIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglzdHJ1Y3QgcmVwbGF5X29wdHMgKipvcHRzX3B0ciA9IG9wdC0+dmFsdWU7CglzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMgPSAqb3B0c19wdHI7CgoJaWYgKHVuc2V0KQoJCXJldHVybiAwOwoKCUFMTE9DX0dST1cob3B0cy0+eG9wdHMsIG9wdHMtPnhvcHRzX25yICsgMSwgb3B0cy0+eG9wdHNfYWxsb2MpOwoJb3B0cy0+eG9wdHNbb3B0cy0+eG9wdHNfbnIrK10gPSB4c3RyZHVwKGFyZyk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgdmVyaWZ5X29wdF9jb21wYXRpYmxlKGNvbnN0IGNoYXIgKm1lLCBjb25zdCBjaGFyICpiYXNlX29wdCwgLi4uKQp7Cgljb25zdCBjaGFyICp0aGlzX29wdDsKCXZhX2xpc3QgYXA7CgoJdmFfc3RhcnQoYXAsIGJhc2Vfb3B0KTsKCXdoaWxlICgodGhpc19vcHQgPSB2YV9hcmcoYXAsIGNvbnN0IGNoYXIgKikpKSB7CgkJaWYgKHZhX2FyZyhhcCwgaW50KSkKCQkJYnJlYWs7Cgl9Cgl2YV9lbmQoYXApOwoKCWlmICh0aGlzX29wdCkKCQlkaWUoXygiJXM6ICVzIGNhbm5vdCBiZSB1c2VkIHdpdGggJXMiKSwgbWUsIHRoaXNfb3B0LCBiYXNlX29wdCk7Cn0KCnN0YXRpYyB2b2lkIHBhcnNlX2FyZ3MoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMpCnsKCWNvbnN0IGNoYXIgKiBjb25zdCAqIHVzYWdlX3N0ciA9IHJldmVydF9vcl9jaGVycnlfcGlja191c2FnZShvcHRzKTsKCWNvbnN0IGNoYXIgKm1lID0gYWN0aW9uX25hbWUob3B0cyk7CglpbnQgbm9vcDsKCWludCByZXNldCA9IDA7CglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfQk9PTEVBTigwLCAicmVzZXQiLCAmcmVzZXQsICJmb3JnZXQgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIiksCgkJT1BUX0JPT0xFQU4oJ24nLCAibm8tY29tbWl0IiwgJm9wdHMtPm5vX2NvbW1pdCwgImRvbid0IGF1dG9tYXRpY2FsbHkgY29tbWl0IiksCgkJT1BUX0JPT0xFQU4oJ2UnLCAiZWRpdCIsICZvcHRzLT5lZGl0LCAiZWRpdCB0aGUgY29tbWl0IG1lc3NhZ2UiKSwKCQl7IE9QVElPTl9CT09MRUFOLCAncicsIE5VTEwsICZub29wLCBOVUxMLCAibm8tb3AgKGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpIiwKCQkgIFBBUlNFX09QVF9OT0FSRyB8IFBBUlNFX09QVF9ISURERU4sIE5VTEwsIDAgfSwKCQlPUFRfQk9PTEVBTigncycsICJzaWdub2ZmIiwgJm9wdHMtPnNpZ25vZmYsICJhZGQgU2lnbmVkLW9mZi1ieToiKSwKCQlPUFRfSU5URUdFUignbScsICJtYWlubGluZSIsICZvcHRzLT5tYWlubGluZSwgInBhcmVudCBudW1iZXIiKSwKCQlPUFRfUkVSRVJFX0FVVE9VUERBVEUoJm9wdHMtPmFsbG93X3JlcmVyZV9hdXRvKSwKCQlPUFRfU1RSSU5HKDAsICJzdHJhdGVneSIsICZvcHRzLT5zdHJhdGVneSwgInN0cmF0ZWd5IiwgIm1lcmdlIHN0cmF0ZWd5IiksCgkJT1BUX0NBTExCQUNLKCdYJywgInN0cmF0ZWd5LW9wdGlvbiIsICZvcHRzLCAib3B0aW9uIiwKCQkJIm9wdGlvbiBmb3IgbWVyZ2Ugc3RyYXRlZ3kiLCBvcHRpb25fcGFyc2VfeCksCgkJT1BUX0VORCgpLAoJCU9QVF9FTkQoKSwKCQlPUFRfRU5EKCksCgl9OwoKCWlmIChvcHRzLT5hY3Rpb24gPT0gQ0hFUlJZX1BJQ0spIHsKCQlzdHJ1Y3Qgb3B0aW9uIGNwX2V4dHJhW10gPSB7CgkJCU9QVF9CT09MRUFOKCd4JywgTlVMTCwgJm9wdHMtPnJlY29yZF9vcmlnaW4sICJhcHBlbmQgY29tbWl0IG5hbWUiKSwKCQkJT1BUX0JPT0xFQU4oMCwgImZmIiwgJm9wdHMtPmFsbG93X2ZmLCAiYWxsb3cgZmFzdC1mb3J3YXJkIiksCgkJCU9QVF9FTkQoKSwKCQl9OwoJCWlmIChwYXJzZV9vcHRpb25zX2NvbmNhdChvcHRpb25zLCBBUlJBWV9TSVpFKG9wdGlvbnMpLCBjcF9leHRyYSkpCgkJCWRpZShfKCJwcm9ncmFtIGVycm9yIikpOwoJfQoKCW9wdHMtPmNvbW1pdF9hcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBOVUxMLCBvcHRpb25zLCB1c2FnZV9zdHIsCgkJCQkJUEFSU0VfT1BUX0tFRVBfQVJHVjAgfAoJCQkJCVBBUlNFX09QVF9LRUVQX1VOS05PV04pOwoKCS8qIFNldCB0aGUgc3ViY29tbWFuZCAqLwoJaWYgKHJlc2V0KQoJCW9wdHMtPnN1YmNvbW1hbmQgPSBSRVBMQVlfUkVTRVQ7CgllbHNlCgkJb3B0cy0+c3ViY29tbWFuZCA9IFJFUExBWV9OT05FOwoKCS8qIENoZWNrIGZvciBpbmNvbXBhdGlibGUgY29tbWFuZCBsaW5lIGFyZ3VtZW50cyAqLwoJaWYgKG9wdHMtPnN1YmNvbW1hbmQgPT0gUkVQTEFZX1JFU0VUKSB7CgkJdmVyaWZ5X29wdF9jb21wYXRpYmxlKG1lLCAiLS1yZXNldCIsCgkJCQkiLS1uby1jb21taXQiLCBvcHRzLT5ub19jb21taXQsCgkJCQkiLS1zaWdub2ZmIiwgb3B0cy0+c2lnbm9mZiwKCQkJCSItLW1haW5saW5lIiwgb3B0cy0+bWFpbmxpbmUsCgkJCQkiLS1zdHJhdGVneSIsIG9wdHMtPnN0cmF0ZWd5ID8gMSA6IDAsCgkJCQkiLS1zdHJhdGVneS1vcHRpb24iLCBvcHRzLT54b3B0cyA/IDEgOiAwLAoJCQkJIi14Iiwgb3B0cy0+cmVjb3JkX29yaWdpbiwKCQkJCSItLWZmIiwgb3B0cy0+YWxsb3dfZmYsCgkJCQlOVUxMKTsKCX0KCgllbHNlIGlmIChvcHRzLT5jb21taXRfYXJnYyA8IDIpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKHVzYWdlX3N0ciwgb3B0aW9ucyk7CgoJaWYgKG9wdHMtPmFsbG93X2ZmKQoJCXZlcmlmeV9vcHRfY29tcGF0aWJsZShtZSwgIi0tZmYiLAoJCQkJIi0tc2lnbm9mZiIsIG9wdHMtPnNpZ25vZmYsCgkJCQkiLS1uby1jb21taXQiLCBvcHRzLT5ub19jb21taXQsCgkJCQkiLXgiLCBvcHRzLT5yZWNvcmRfb3JpZ2luLAoJCQkJIi0tZWRpdCIsIG9wdHMtPmVkaXQsCgkJCQlOVUxMKTsKCW9wdHMtPmNvbW1pdF9hcmd2ID0gYXJndjsKfQoKc3RydWN0IGNvbW1pdF9tZXNzYWdlIHsKCWNoYXIgKnBhcmVudF9sYWJlbDsKCWNvbnN0IGNoYXIgKmxhYmVsOwoJY29uc3QgY2hhciAqc3ViamVjdDsKCWNoYXIgKnJlZW5jb2RlZF9tZXNzYWdlOwoJY29uc3QgY2hhciAqbWVzc2FnZTsKfTsKCnN0YXRpYyBpbnQgZ2V0X21lc3NhZ2Uoc3RydWN0IGNvbW1pdCAqY29tbWl0LCBzdHJ1Y3QgY29tbWl0X21lc3NhZ2UgKm91dCkKewoJY29uc3QgY2hhciAqZW5jb2Rpbmc7Cgljb25zdCBjaGFyICphYmJyZXYsICpzdWJqZWN0OwoJaW50IGFiYnJldl9sZW4sIHN1YmplY3RfbGVuOwoJY2hhciAqcTsKCglpZiAoIWNvbW1pdC0+YnVmZmVyKQoJCXJldHVybiAtMTsKCWVuY29kaW5nID0gZ2V0X2VuY29kaW5nKGNvbW1pdC0+YnVmZmVyKTsKCWlmICghZW5jb2RpbmcpCgkJZW5jb2RpbmcgPSAiVVRGLTgiOwoJaWYgKCFnaXRfY29tbWl0X2VuY29kaW5nKQoJCWdpdF9jb21taXRfZW5jb2RpbmcgPSAiVVRGLTgiOwoKCW91dC0+cmVlbmNvZGVkX21lc3NhZ2UgPSBOVUxMOwoJb3V0LT5tZXNzYWdlID0gY29tbWl0LT5idWZmZXI7CglpZiAoc3RyY21wKGVuY29kaW5nLCBnaXRfY29tbWl0X2VuY29kaW5nKSkKCQlvdXQtPnJlZW5jb2RlZF9tZXNzYWdlID0gcmVlbmNvZGVfc3RyaW5nKGNvbW1pdC0+YnVmZmVyLAoJCQkJCWdpdF9jb21taXRfZW5jb2RpbmcsIGVuY29kaW5nKTsKCWlmIChvdXQtPnJlZW5jb2RlZF9tZXNzYWdlKQoJCW91dC0+bWVzc2FnZSA9IG91dC0+cmVlbmNvZGVkX21lc3NhZ2U7CgoJYWJicmV2ID0gZmluZF91bmlxdWVfYWJicmV2KGNvbW1pdC0+b2JqZWN0LnNoYTEsIERFRkFVTFRfQUJCUkVWKTsKCWFiYnJldl9sZW4gPSBzdHJsZW4oYWJicmV2KTsKCglzdWJqZWN0X2xlbiA9IGZpbmRfY29tbWl0X3N1YmplY3Qob3V0LT5tZXNzYWdlLCAmc3ViamVjdCk7CgoJb3V0LT5wYXJlbnRfbGFiZWwgPSB4bWFsbG9jKHN0cmxlbigicGFyZW50IG9mICIpICsgYWJicmV2X2xlbiArCgkJCSAgICAgIHN0cmxlbigiLi4uICIpICsgc3ViamVjdF9sZW4gKyAxKTsKCXEgPSBvdXQtPnBhcmVudF9sYWJlbDsKCXEgPSBtZW1wY3B5KHEsICJwYXJlbnQgb2YgIiwgc3RybGVuKCJwYXJlbnQgb2YgIikpOwoJb3V0LT5sYWJlbCA9IHE7CglxID0gbWVtcGNweShxLCBhYmJyZXYsIGFiYnJldl9sZW4pOwoJcSA9IG1lbXBjcHkocSwgIi4uLiAiLCBzdHJsZW4oIi4uLiAiKSk7CglvdXQtPnN1YmplY3QgPSBxOwoJcSA9IG1lbXBjcHkocSwgc3ViamVjdCwgc3ViamVjdF9sZW4pOwoJKnEgPSAnXDAnOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGZyZWVfbWVzc2FnZShzdHJ1Y3QgY29tbWl0X21lc3NhZ2UgKm1zZykKewoJZnJlZShtc2ctPnBhcmVudF9sYWJlbCk7CglmcmVlKG1zZy0+cmVlbmNvZGVkX21lc3NhZ2UpOwp9CgpzdGF0aWMgY2hhciAqZ2V0X2VuY29kaW5nKGNvbnN0IGNoYXIgKm1lc3NhZ2UpCnsKCWNvbnN0IGNoYXIgKnAgPSBtZXNzYWdlLCAqZW9sOwoKCXdoaWxlICgqcCAmJiAqcCAhPSAnXG4nKSB7CgkJZm9yIChlb2wgPSBwICsgMTsgKmVvbCAmJiAqZW9sICE9ICdcbic7IGVvbCsrKQoJCQk7IC8qIGRvIG5vdGhpbmcgKi8KCQlpZiAoIXByZWZpeGNtcChwLCAiZW5jb2RpbmcgIikpIHsKCQkJY2hhciAqcmVzdWx0ID0geG1hbGxvYyhlb2wgLSA4IC0gcCk7CgkJCXN0cmxjcHkocmVzdWx0LCBwICsgOSwgZW9sIC0gOCAtIHApOwoJCQlyZXR1cm4gcmVzdWx0OwoJCX0KCQlwID0gZW9sOwoJCWlmICgqcCA9PSAnXG4nKQoJCQlwKys7Cgl9CglyZXR1cm4gTlVMTDsKfQoKc3RhdGljIHZvaWQgd3JpdGVfY2hlcnJ5X3BpY2tfaGVhZChzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCWludCBmZDsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJc3RyYnVmX2FkZGYoJmJ1ZiwgIiVzXG4iLCBzaGExX3RvX2hleChjb21taXQtPm9iamVjdC5zaGExKSk7CgoJZmQgPSBvcGVuKGdpdF9wYXRoKCJDSEVSUllfUElDS19IRUFEIiksIE9fV1JPTkxZIHwgT19DUkVBVCwgMDY2Nik7CglpZiAoZmQgPCAwKQoJCWRpZV9lcnJubyhfKCJDb3VsZCBub3Qgb3BlbiAnJXMnIGZvciB3cml0aW5nIiksCgkJCSAgZ2l0X3BhdGgoIkNIRVJSWV9QSUNLX0hFQUQiKSk7CglpZiAod3JpdGVfaW5fZnVsbChmZCwgYnVmLmJ1ZiwgYnVmLmxlbikgIT0gYnVmLmxlbiB8fCBjbG9zZShmZCkpCgkJZGllX2Vycm5vKF8oIkNvdWxkIG5vdCB3cml0ZSB0byAnJXMnIiksIGdpdF9wYXRoKCJDSEVSUllfUElDS19IRUFEIikpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7Cn0KCnN0YXRpYyB2b2lkIHByaW50X2FkdmljZSh2b2lkKQp7CgljaGFyICptc2cgPSBnZXRlbnYoIkdJVF9DSEVSUllfUElDS19IRUxQIik7CgoJaWYgKG1zZykgewoJCWZwcmludGYoc3RkZXJyLCAiJXNcbiIsIG1zZyk7CgkJLyoKCQkgKiBBIGNvbmZsaWN0IGhhcyBvY2N1cmVkIGJ1dCB0aGUgcG9yY2VsYWluCgkJICogKHR5cGljYWxseSByZWJhc2UgLS1pbnRlcmFjdGl2ZSkgd2FudHMgdG8gdGFrZSBjYXJlCgkJICogb2YgdGhlIGNvbW1pdCBpdHNlbGYgc28gcmVtb3ZlIENIRVJSWV9QSUNLX0hFQUQKCQkgKi8KCQl1bmxpbmsoZ2l0X3BhdGgoIkNIRVJSWV9QSUNLX0hFQUQiKSk7CgkJcmV0dXJuOwoJfQoKCWFkdmlzZSgiYWZ0ZXIgcmVzb2x2aW5nIHRoZSBjb25mbGljdHMsIG1hcmsgdGhlIGNvcnJlY3RlZCBwYXRocyIpOwoJYWR2aXNlKCJ3aXRoICdnaXQgYWRkIDxwYXRocz4nIG9yICdnaXQgcm0gPHBhdGhzPiciKTsKCWFkdmlzZSgiYW5kIGNvbW1pdCB0aGUgcmVzdWx0IHdpdGggJ2dpdCBjb21taXQnIik7Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX21lc3NhZ2Uoc3RydWN0IHN0cmJ1ZiAqbXNnYnVmLCBjb25zdCBjaGFyICpmaWxlbmFtZSkKewoJc3RhdGljIHN0cnVjdCBsb2NrX2ZpbGUgbXNnX2ZpbGU7CgoJaW50IG1zZ19mZCA9IGhvbGRfbG9ja19maWxlX2Zvcl91cGRhdGUoJm1zZ19maWxlLCBmaWxlbmFtZSwKCQkJCQkgICAgICAgTE9DS19ESUVfT05fRVJST1IpOwoJaWYgKHdyaXRlX2luX2Z1bGwobXNnX2ZkLCBtc2didWYtPmJ1ZiwgbXNnYnVmLT5sZW4pIDwgMCkKCQlkaWVfZXJybm8oXygiQ291bGQgbm90IHdyaXRlIHRvICVzLiIpLCBmaWxlbmFtZSk7CglzdHJidWZfcmVsZWFzZShtc2didWYpOwoJaWYgKGNvbW1pdF9sb2NrX2ZpbGUoJm1zZ19maWxlKSA8IDApCgkJZGllKF8oIkVycm9yIHdyYXBwaW5nIHVwICVzIiksIGZpbGVuYW1lKTsKfQoKc3RhdGljIHN0cnVjdCB0cmVlICplbXB0eV90cmVlKHZvaWQpCnsKCXN0cnVjdCB0cmVlICp0cmVlID0geGNhbGxvYygxLCBzaXplb2Yoc3RydWN0IHRyZWUpKTsKCgl0cmVlLT5vYmplY3QucGFyc2VkID0gMTsKCXRyZWUtPm9iamVjdC50eXBlID0gT0JKX1RSRUU7CglwcmV0ZW5kX3NoYTFfZmlsZShOVUxMLCAwLCBPQkpfVFJFRSwgdHJlZS0+b2JqZWN0LnNoYTEpOwoJcmV0dXJuIHRyZWU7Cn0KCnN0YXRpYyBOT1JFVFVSTiB2b2lkIGRpZV9kaXJ0eV9pbmRleChzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMpCnsKCWlmIChyZWFkX2NhY2hlX3VubWVyZ2VkKCkpIHsKCQlkaWVfcmVzb2x2ZV9jb25mbGljdChhY3Rpb25fbmFtZShvcHRzKSk7Cgl9IGVsc2UgewoJCWlmIChhZHZpY2VfY29tbWl0X2JlZm9yZV9tZXJnZSkgewoJCQlpZiAob3B0cy0+YWN0aW9uID09IFJFVkVSVCkKCQkJCWRpZShfKCJZb3VyIGxvY2FsIGNoYW5nZXMgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgcmV2ZXJ0LlxuIgoJCQkJCSAgIlBsZWFzZSwgY29tbWl0IHlvdXIgY2hhbmdlcyBvciBzdGFzaCB0aGVtIHRvIHByb2NlZWQuIikpOwoJCQllbHNlCgkJCQlkaWUoXygiWW91ciBsb2NhbCBjaGFuZ2VzIHdvdWxkIGJlIG92ZXJ3cml0dGVuIGJ5IGNoZXJyeS1waWNrLlxuIgoJCQkJCSAgIlBsZWFzZSwgY29tbWl0IHlvdXIgY2hhbmdlcyBvciBzdGFzaCB0aGVtIHRvIHByb2NlZWQuIikpOwoJCX0gZWxzZSB7CgkJCWlmIChvcHRzLT5hY3Rpb24gPT0gUkVWRVJUKQoJCQkJZGllKF8oIllvdXIgbG9jYWwgY2hhbmdlcyB3b3VsZCBiZSBvdmVyd3JpdHRlbiBieSByZXZlcnQuXG4iKSk7CgkJCWVsc2UKCQkJCWRpZShfKCJZb3VyIGxvY2FsIGNoYW5nZXMgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgY2hlcnJ5LXBpY2suXG4iKSk7CgkJfQoJfQp9CgpzdGF0aWMgaW50IGZhc3RfZm9yd2FyZF90byhjb25zdCB1bnNpZ25lZCBjaGFyICp0bywgY29uc3QgdW5zaWduZWQgY2hhciAqZnJvbSkKewoJc3RydWN0IHJlZl9sb2NrICpyZWZfbG9jazsKCglyZWFkX2NhY2hlKCk7CglpZiAoY2hlY2tvdXRfZmFzdF9mb3J3YXJkKGZyb20sIHRvKSkKCQlleGl0KDEpOyAvKiB0aGUgY2FsbGVlIHNob3VsZCBoYXZlIGNvbXBsYWluZWQgYWxyZWFkeSAqLwoJcmVmX2xvY2sgPSBsb2NrX2FueV9yZWZfZm9yX3VwZGF0ZSgiSEVBRCIsIGZyb20sIDApOwoJcmV0dXJuIHdyaXRlX3JlZl9zaGExKHJlZl9sb2NrLCB0bywgImNoZXJyeS1waWNrIik7Cn0KCnN0YXRpYyBpbnQgZG9fcmVjdXJzaXZlX21lcmdlKHN0cnVjdCBjb21taXQgKmJhc2UsIHN0cnVjdCBjb21taXQgKm5leHQsCgkJCSAgICAgIGNvbnN0IGNoYXIgKmJhc2VfbGFiZWwsIGNvbnN0IGNoYXIgKm5leHRfbGFiZWwsCgkJCSAgICAgIHVuc2lnbmVkIGNoYXIgKmhlYWQsIHN0cnVjdCBzdHJidWYgKm1zZ2J1ZiwKCQkJICAgICAgc3RydWN0IHJlcGxheV9vcHRzICpvcHRzKQp7CglzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyBvOwoJc3RydWN0IHRyZWUgKnJlc3VsdCwgKm5leHRfdHJlZSwgKmJhc2VfdHJlZSwgKmhlYWRfdHJlZTsKCWludCBjbGVhbiwgaW5kZXhfZmQ7Cgljb25zdCBjaGFyICoqeG9wdDsKCXN0YXRpYyBzdHJ1Y3QgbG9ja19maWxlIGluZGV4X2xvY2s7CgoJaW5kZXhfZmQgPSBob2xkX2xvY2tlZF9pbmRleCgmaW5kZXhfbG9jaywgMSk7CgoJcmVhZF9jYWNoZSgpOwoKCWluaXRfbWVyZ2Vfb3B0aW9ucygmbyk7CglvLmFuY2VzdG9yID0gYmFzZSA/IGJhc2VfbGFiZWwgOiAiKGVtcHR5IHRyZWUpIjsKCW8uYnJhbmNoMSA9ICJIRUFEIjsKCW8uYnJhbmNoMiA9IG5leHQgPyBuZXh0X2xhYmVsIDogIihlbXB0eSB0cmVlKSI7CgoJaGVhZF90cmVlID0gcGFyc2VfdHJlZV9pbmRpcmVjdChoZWFkKTsKCW5leHRfdHJlZSA9IG5leHQgPyBuZXh0LT50cmVlIDogZW1wdHlfdHJlZSgpOwoJYmFzZV90cmVlID0gYmFzZSA/IGJhc2UtPnRyZWUgOiBlbXB0eV90cmVlKCk7CgoJZm9yICh4b3B0ID0gb3B0cy0+eG9wdHM7IHhvcHQgIT0gb3B0cy0+eG9wdHMgKyBvcHRzLT54b3B0c19ucjsgeG9wdCsrKQoJCXBhcnNlX21lcmdlX29wdCgmbywgKnhvcHQpOwoKCWNsZWFuID0gbWVyZ2VfdHJlZXMoJm8sCgkJCSAgICBoZWFkX3RyZWUsCgkJCSAgICBuZXh0X3RyZWUsIGJhc2VfdHJlZSwgJnJlc3VsdCk7CgoJaWYgKGFjdGl2ZV9jYWNoZV9jaGFuZ2VkICYmCgkgICAgKHdyaXRlX2NhY2hlKGluZGV4X2ZkLCBhY3RpdmVfY2FjaGUsIGFjdGl2ZV9ucikgfHwKCSAgICAgY29tbWl0X2xvY2tlZF9pbmRleCgmaW5kZXhfbG9jaykpKQoJCS8qIFRSQU5TTEFUT1JTOiAlcyB3aWxsIGJlICJyZXZlcnQiIG9yICJjaGVycnktcGljayIgKi8KCQlkaWUoXygiJXM6IFVuYWJsZSB0byB3cml0ZSBuZXcgaW5kZXggZmlsZSIpLCBhY3Rpb25fbmFtZShvcHRzKSk7Cglyb2xsYmFja19sb2NrX2ZpbGUoJmluZGV4X2xvY2spOwoKCWlmICghY2xlYW4pIHsKCQlpbnQgaTsKCQlzdHJidWZfYWRkc3RyKG1zZ2J1ZiwgIlxuQ29uZmxpY3RzOlxuXG4iKTsKCQlmb3IgKGkgPSAwOyBpIDwgYWN0aXZlX25yOykgewoJCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gYWN0aXZlX2NhY2hlW2krK107CgkJCWlmIChjZV9zdGFnZShjZSkpIHsKCQkJCXN0cmJ1Zl9hZGRjaChtc2didWYsICdcdCcpOwoJCQkJc3RyYnVmX2FkZHN0cihtc2didWYsIGNlLT5uYW1lKTsKCQkJCXN0cmJ1Zl9hZGRjaChtc2didWYsICdcbicpOwoJCQkJd2hpbGUgKGkgPCBhY3RpdmVfbnIgJiYgIXN0cmNtcChjZS0+bmFtZSwKCQkJCQkJYWN0aXZlX2NhY2hlW2ldLT5uYW1lKSkKCQkJCQlpKys7CgkJCX0KCQl9Cgl9CgoJcmV0dXJuICFjbGVhbjsKfQoKLyoKICogSWYgd2UgYXJlIGNoZXJyeS1waWNrLCBhbmQgaWYgdGhlIG1lcmdlIGRpZCBub3QgcmVzdWx0IGluCiAqIGhhbmQtZWRpdGluZywgd2Ugd2lsbCBoaXQgdGhpcyBjb21taXQgYW5kIGluaGVyaXQgdGhlIG9yaWdpbmFsCiAqIGF1dGhvciBkYXRlIGFuZCBuYW1lLgogKiBJZiB3ZSBhcmUgcmV2ZXJ0LCBvciBpZiBvdXIgY2hlcnJ5LXBpY2sgcmVzdWx0cyBpbiBhIGhhbmQgbWVyZ2UsCiAqIHdlIGhhZCBiZXR0ZXIgc2F5IHRoYXQgdGhlIGN1cnJlbnQgdXNlciBpcyByZXNwb25zaWJsZSBmb3IgdGhhdC4KICovCnN0YXRpYyBpbnQgcnVuX2dpdF9jb21taXQoY29uc3QgY2hhciAqZGVmbXNnLCBzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMpCnsKCS8qIDYgaXMgbWF4IHBvc3NpYmxlIGxlbmd0aCBvZiBvdXIgYXJncyBhcnJheSBpbmNsdWRpbmcgTlVMTCAqLwoJY29uc3QgY2hhciAqYXJnc1s2XTsKCWludCBpID0gMDsKCglhcmdzW2krK10gPSAiY29tbWl0IjsKCWFyZ3NbaSsrXSA9ICItbiI7CglpZiAob3B0cy0+c2lnbm9mZikKCQlhcmdzW2krK10gPSAiLXMiOwoJaWYgKCFvcHRzLT5lZGl0KSB7CgkJYXJnc1tpKytdID0gIi1GIjsKCQlhcmdzW2krK10gPSBkZWZtc2c7Cgl9CglhcmdzW2ldID0gTlVMTDsKCglyZXR1cm4gcnVuX2NvbW1hbmRfdl9vcHQoYXJncywgUlVOX0dJVF9DTUQpOwp9CgpzdGF0aWMgaW50IGRvX3BpY2tfY29tbWl0KHN0cnVjdCBjb21taXQgKmNvbW1pdCwgc3RydWN0IHJlcGxheV9vcHRzICpvcHRzKQp7Cgl1bnNpZ25lZCBjaGFyIGhlYWRbMjBdOwoJc3RydWN0IGNvbW1pdCAqYmFzZSwgKm5leHQsICpwYXJlbnQ7Cgljb25zdCBjaGFyICpiYXNlX2xhYmVsLCAqbmV4dF9sYWJlbDsKCXN0cnVjdCBjb21taXRfbWVzc2FnZSBtc2cgPSB7IE5VTEwsIE5VTEwsIE5VTEwsIE5VTEwsIE5VTEwgfTsKCWNoYXIgKmRlZm1zZyA9IE5VTEw7CglzdHJ1Y3Qgc3RyYnVmIG1zZ2J1ZiA9IFNUUkJVRl9JTklUOwoJaW50IHJlczsKCglpZiAob3B0cy0+bm9fY29tbWl0KSB7CgkJLyoKCQkgKiBXZSBkbyBub3QgaW50ZW5kIHRvIGNvbW1pdCBpbW1lZGlhdGVseS4gIFdlIGp1c3Qgd2FudCB0bwoJCSAqIG1lcmdlIHRoZSBkaWZmZXJlbmNlcyBpbiwgc28gbGV0J3MgY29tcHV0ZSB0aGUgdHJlZQoJCSAqIHRoYXQgcmVwcmVzZW50cyB0aGUgImN1cnJlbnQiIHN0YXRlIGZvciBtZXJnZS1yZWN1cnNpdmUKCQkgKiB0byB3b3JrIG9uLgoJCSAqLwoJCWlmICh3cml0ZV9jYWNoZV9hc190cmVlKGhlYWQsIDAsIE5VTEwpKQoJCQlkaWUgKF8oIllvdXIgaW5kZXggZmlsZSBpcyB1bm1lcmdlZC4iKSk7Cgl9IGVsc2UgewoJCWlmIChnZXRfc2hhMSgiSEVBRCIsIGhlYWQpKQoJCQlkaWUgKF8oIllvdSBkbyBub3QgaGF2ZSBhIHZhbGlkIEhFQUQiKSk7CgkJaWYgKGluZGV4X2RpZmZlcnNfZnJvbSgiSEVBRCIsIDApKQoJCQlkaWVfZGlydHlfaW5kZXgob3B0cyk7Cgl9CglkaXNjYXJkX2NhY2hlKCk7CgoJaWYgKCFjb21taXQtPnBhcmVudHMpIHsKCQlwYXJlbnQgPSBOVUxMOwoJfQoJZWxzZSBpZiAoY29tbWl0LT5wYXJlbnRzLT5uZXh0KSB7CgkJLyogUmV2ZXJ0aW5nIG9yIGNoZXJyeS1waWNraW5nIGEgbWVyZ2UgY29tbWl0ICovCgkJaW50IGNudDsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnA7CgoJCWlmICghb3B0cy0+bWFpbmxpbmUpCgkJCWRpZShfKCJDb21taXQgJXMgaXMgYSBtZXJnZSBidXQgbm8gLW0gb3B0aW9uIHdhcyBnaXZlbi4iKSwKCQkJICAgIHNoYTFfdG9faGV4KGNvbW1pdC0+b2JqZWN0LnNoYTEpKTsKCgkJZm9yIChjbnQgPSAxLCBwID0gY29tbWl0LT5wYXJlbnRzOwoJCSAgICAgY250ICE9IG9wdHMtPm1haW5saW5lICYmIHA7CgkJICAgICBjbnQrKykKCQkJcCA9IHAtPm5leHQ7CgkJaWYgKGNudCAhPSBvcHRzLT5tYWlubGluZSB8fCAhcCkKCQkJZGllKF8oIkNvbW1pdCAlcyBkb2VzIG5vdCBoYXZlIHBhcmVudCAlZCIpLAoJCQkgICAgc2hhMV90b19oZXgoY29tbWl0LT5vYmplY3Quc2hhMSksIG9wdHMtPm1haW5saW5lKTsKCQlwYXJlbnQgPSBwLT5pdGVtOwoJfSBlbHNlIGlmICgwIDwgb3B0cy0+bWFpbmxpbmUpCgkJZGllKF8oIk1haW5saW5lIHdhcyBzcGVjaWZpZWQgYnV0IGNvbW1pdCAlcyBpcyBub3QgYSBtZXJnZS4iKSwKCQkgICAgc2hhMV90b19oZXgoY29tbWl0LT5vYmplY3Quc2hhMSkpOwoJZWxzZQoJCXBhcmVudCA9IGNvbW1pdC0+cGFyZW50cy0+aXRlbTsKCglpZiAob3B0cy0+YWxsb3dfZmYgJiYgcGFyZW50ICYmICFoYXNoY21wKHBhcmVudC0+b2JqZWN0LnNoYTEsIGhlYWQpKQoJCXJldHVybiBmYXN0X2ZvcndhcmRfdG8oY29tbWl0LT5vYmplY3Quc2hhMSwgaGVhZCk7CgoJaWYgKHBhcmVudCAmJiBwYXJzZV9jb21taXQocGFyZW50KSA8IDApCgkJLyogVFJBTlNMQVRPUlM6IFRoZSBmaXJzdCAlcyB3aWxsIGJlICJyZXZlcnQiIG9yCgkJICAgImNoZXJyeS1waWNrIiwgdGhlIHNlY29uZCAlcyBhIFNIQTEgKi8KCQlkaWUoXygiJXM6IGNhbm5vdCBwYXJzZSBwYXJlbnQgY29tbWl0ICVzIiksCgkJICAgIGFjdGlvbl9uYW1lKG9wdHMpLCBzaGExX3RvX2hleChwYXJlbnQtPm9iamVjdC5zaGExKSk7CgoJaWYgKGdldF9tZXNzYWdlKGNvbW1pdCwgJm1zZykgIT0gMCkKCQlkaWUoXygiQ2Fubm90IGdldCBjb21taXQgbWVzc2FnZSBmb3IgJXMiKSwKCQkJCXNoYTFfdG9faGV4KGNvbW1pdC0+b2JqZWN0LnNoYTEpKTsKCgkvKgoJICogImNvbW1pdCIgaXMgYW4gZXhpc3RpbmcgY29tbWl0LiAgV2Ugd291bGQgd2FudCB0byBhcHBseQoJICogdGhlIGRpZmZlcmVuY2UgaXQgaW50cm9kdWNlcyBzaW5jZSBpdHMgZmlyc3QgcGFyZW50ICJwcmV2IgoJICogb24gdG9wIG9mIHRoZSBjdXJyZW50IEhFQUQgaWYgd2UgYXJlIGNoZXJyeS1waWNrLiAgT3IgdGhlCgkgKiByZXZlcnNlIG9mIGl0IGlmIHdlIGFyZSByZXZlcnQuCgkgKi8KCglkZWZtc2cgPSBnaXRfcGF0aGR1cCgiTUVSR0VfTVNHIik7CgoJaWYgKG9wdHMtPmFjdGlvbiA9PSBSRVZFUlQpIHsKCQliYXNlID0gY29tbWl0OwoJCWJhc2VfbGFiZWwgPSBtc2cubGFiZWw7CgkJbmV4dCA9IHBhcmVudDsKCQluZXh0X2xhYmVsID0gbXNnLnBhcmVudF9sYWJlbDsKCQlzdHJidWZfYWRkc3RyKCZtc2didWYsICJSZXZlcnQgXCIiKTsKCQlzdHJidWZfYWRkc3RyKCZtc2didWYsIG1zZy5zdWJqZWN0KTsKCQlzdHJidWZfYWRkc3RyKCZtc2didWYsICJcIlxuXG5UaGlzIHJldmVydHMgY29tbWl0ICIpOwoJCXN0cmJ1Zl9hZGRzdHIoJm1zZ2J1Ziwgc2hhMV90b19oZXgoY29tbWl0LT5vYmplY3Quc2hhMSkpOwoKCQlpZiAoY29tbWl0LT5wYXJlbnRzICYmIGNvbW1pdC0+cGFyZW50cy0+bmV4dCkgewoJCQlzdHJidWZfYWRkc3RyKCZtc2didWYsICIsIHJldmVyc2luZ1xuY2hhbmdlcyBtYWRlIHRvICIpOwoJCQlzdHJidWZfYWRkc3RyKCZtc2didWYsIHNoYTFfdG9faGV4KHBhcmVudC0+b2JqZWN0LnNoYTEpKTsKCQl9CgkJc3RyYnVmX2FkZHN0cigmbXNnYnVmLCAiLlxuIik7Cgl9IGVsc2UgewoJCWNvbnN0IGNoYXIgKnA7CgoJCWJhc2UgPSBwYXJlbnQ7CgkJYmFzZV9sYWJlbCA9IG1zZy5wYXJlbnRfbGFiZWw7CgkJbmV4dCA9IGNvbW1pdDsKCQluZXh0X2xhYmVsID0gbXNnLmxhYmVsOwoKCQkvKgoJCSAqIEFwcGVuZCB0aGUgY29tbWl0IGxvZyBtZXNzYWdlIHRvIG1zZ2J1ZjsgaXQgc3RhcnRzCgkJICogYWZ0ZXIgdGhlIHRyZWUsIHBhcmVudCwgYXV0aG9yLCBjb21taXR0ZXIKCQkgKiBpbmZvcm1hdGlvbiBmb2xsb3dlZCBieSAiXG5cbiIuCgkJICovCgkJcCA9IHN0cnN0cihtc2cubWVzc2FnZSwgIlxuXG4iKTsKCQlpZiAocCkgewoJCQlwICs9IDI7CgkJCXN0cmJ1Zl9hZGRzdHIoJm1zZ2J1ZiwgcCk7CgkJfQoKCQlpZiAob3B0cy0+cmVjb3JkX29yaWdpbikgewoJCQlzdHJidWZfYWRkc3RyKCZtc2didWYsICIoY2hlcnJ5IHBpY2tlZCBmcm9tIGNvbW1pdCAiKTsKCQkJc3RyYnVmX2FkZHN0cigmbXNnYnVmLCBzaGExX3RvX2hleChjb21taXQtPm9iamVjdC5zaGExKSk7CgkJCXN0cmJ1Zl9hZGRzdHIoJm1zZ2J1ZiwgIilcbiIpOwoJCX0KCQlpZiAoIW9wdHMtPm5vX2NvbW1pdCkKCQkJd3JpdGVfY2hlcnJ5X3BpY2tfaGVhZChjb21taXQpOwoJfQoKCWlmICghb3B0cy0+c3RyYXRlZ3kgfHwgIXN0cmNtcChvcHRzLT5zdHJhdGVneSwgInJlY3Vyc2l2ZSIpIHx8IG9wdHMtPmFjdGlvbiA9PSBSRVZFUlQpIHsKCQlyZXMgPSBkb19yZWN1cnNpdmVfbWVyZ2UoYmFzZSwgbmV4dCwgYmFzZV9sYWJlbCwgbmV4dF9sYWJlbCwKCQkJCQkgaGVhZCwgJm1zZ2J1Ziwgb3B0cyk7CgkJd3JpdGVfbWVzc2FnZSgmbXNnYnVmLCBkZWZtc2cpOwoJfSBlbHNlIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKmNvbW1vbiA9IE5VTEw7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpyZW1vdGVzID0gTlVMTDsKCgkJd3JpdGVfbWVzc2FnZSgmbXNnYnVmLCBkZWZtc2cpOwoKCQljb21taXRfbGlzdF9pbnNlcnQoYmFzZSwgJmNvbW1vbik7CgkJY29tbWl0X2xpc3RfaW5zZXJ0KG5leHQsICZyZW1vdGVzKTsKCQlyZXMgPSB0cnlfbWVyZ2VfY29tbWFuZChvcHRzLT5zdHJhdGVneSwgb3B0cy0+eG9wdHNfbnIsIG9wdHMtPnhvcHRzLAoJCQkJCWNvbW1vbiwgc2hhMV90b19oZXgoaGVhZCksIHJlbW90ZXMpOwoJCWZyZWVfY29tbWl0X2xpc3QoY29tbW9uKTsKCQlmcmVlX2NvbW1pdF9saXN0KHJlbW90ZXMpOwoJfQoKCWlmIChyZXMpIHsKCQllcnJvcihvcHRzLT5hY3Rpb24gPT0gUkVWRVJUCgkJICAgICAgPyBfKCJjb3VsZCBub3QgcmV2ZXJ0ICVzLi4uICVzIikKCQkgICAgICA6IF8oImNvdWxkIG5vdCBhcHBseSAlcy4uLiAlcyIpLAoJCSAgICAgIGZpbmRfdW5pcXVlX2FiYnJldihjb21taXQtPm9iamVjdC5zaGExLCBERUZBVUxUX0FCQlJFViksCgkJICAgICAgbXNnLnN1YmplY3QpOwoJCXByaW50X2FkdmljZSgpOwoJCXJlcmVyZShvcHRzLT5hbGxvd19yZXJlcmVfYXV0byk7Cgl9IGVsc2UgewoJCWlmICghb3B0cy0+bm9fY29tbWl0KQoJCQlyZXMgPSBydW5fZ2l0X2NvbW1pdChkZWZtc2csIG9wdHMpOwoJfQoKCWZyZWVfbWVzc2FnZSgmbXNnKTsKCWZyZWUoZGVmbXNnKTsKCglyZXR1cm4gcmVzOwp9CgpzdGF0aWMgdm9pZCBwcmVwYXJlX3JldnMoc3RydWN0IHJldl9pbmZvICpyZXZzLCBzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMpCnsKCWludCBhcmdjOwoKCWluaXRfcmV2aXNpb25zKHJldnMsIE5VTEwpOwoJcmV2cy0+bm9fd2FsayA9IDE7CglpZiAob3B0cy0+YWN0aW9uICE9IFJFVkVSVCkKCQlyZXZzLT5yZXZlcnNlID0gMTsKCglhcmdjID0gc2V0dXBfcmV2aXNpb25zKG9wdHMtPmNvbW1pdF9hcmdjLCBvcHRzLT5jb21taXRfYXJndiwgcmV2cywgTlVMTCk7CglpZiAoYXJnYyA+IDEpCgkJdXNhZ2UoKnJldmVydF9vcl9jaGVycnlfcGlja191c2FnZShvcHRzKSk7CgoJaWYgKHByZXBhcmVfcmV2aXNpb25fd2FsayhyZXZzKSkKCQlkaWUoXygicmV2aXNpb24gd2FsayBzZXR1cCBmYWlsZWQiKSk7CgoJaWYgKCFyZXZzLT5jb21taXRzKQoJCWRpZShfKCJlbXB0eSBjb21taXQgc2V0IHBhc3NlZCIpKTsKfQoKc3RhdGljIHZvaWQgcmVhZF9hbmRfcmVmcmVzaF9jYWNoZShzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMpCnsKCXN0YXRpYyBzdHJ1Y3QgbG9ja19maWxlIGluZGV4X2xvY2s7CglpbnQgaW5kZXhfZmQgPSBob2xkX2xvY2tlZF9pbmRleCgmaW5kZXhfbG9jaywgMCk7CglpZiAocmVhZF9pbmRleF9wcmVsb2FkKCZ0aGVfaW5kZXgsIE5VTEwpIDwgMCkKCQlkaWUoXygiZ2l0ICVzOiBmYWlsZWQgdG8gcmVhZCB0aGUgaW5kZXgiKSwgYWN0aW9uX25hbWUob3B0cykpOwoJcmVmcmVzaF9pbmRleCgmdGhlX2luZGV4LCBSRUZSRVNIX1FVSUVUfFJFRlJFU0hfVU5NRVJHRUQsIE5VTEwsIE5VTEwsIE5VTEwpOwoJaWYgKHRoZV9pbmRleC5jYWNoZV9jaGFuZ2VkKSB7CgkJaWYgKHdyaXRlX2luZGV4KCZ0aGVfaW5kZXgsIGluZGV4X2ZkKSB8fAoJCSAgICBjb21taXRfbG9ja2VkX2luZGV4KCZpbmRleF9sb2NrKSkKCQkJZGllKF8oImdpdCAlczogZmFpbGVkIHRvIHJlZnJlc2ggdGhlIGluZGV4IiksIGFjdGlvbl9uYW1lKG9wdHMpKTsKCX0KCXJvbGxiYWNrX2xvY2tfZmlsZSgmaW5kZXhfbG9jayk7Cn0KCi8qCiAqIEFwcGVuZCBhIGNvbW1pdCB0byB0aGUgZW5kIG9mIHRoZSBjb21taXRfbGlzdC4KICoKICogbmV4dCBzdGFydHMgYnkgcG9pbnRpbmcgdG8gdGhlIHZhcmlhYmxlIHRoYXQgaG9sZHMgdGhlIGhlYWQgb2YgYW4KICogZW1wdHkgY29tbWl0X2xpc3QsIGFuZCBpcyB1cGRhdGVkIHRvIHBvaW50IHRvIHRoZSAibmV4dCIgZmllbGQgb2YKICogdGhlIGxhc3QgaXRlbSBvbiB0aGUgbGlzdCBhcyBuZXcgY29tbWl0cyBhcmUgYXBwZW5kZWQuCiAqCiAqIFVzYWdlIGV4YW1wbGU6CiAqCiAqICAgICBzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3Q7CiAqICAgICBzdHJ1Y3QgY29tbWl0X2xpc3QgKipuZXh0ID0gJmxpc3Q7CiAqCiAqICAgICBuZXh0ID0gY29tbWl0X2xpc3RfYXBwZW5kKGMxLCBuZXh0KTsKICogICAgIG5leHQgPSBjb21taXRfbGlzdF9hcHBlbmQoYzIsIG5leHQpOwogKiAgICAgYXNzZXJ0KGNvbW1pdF9saXN0X2NvdW50KGxpc3QpID09IDIpOwogKiAgICAgcmV0dXJuIGxpc3Q7CiAqLwpzdHJ1Y3QgY29tbWl0X2xpc3QgKipjb21taXRfbGlzdF9hcHBlbmQoc3RydWN0IGNvbW1pdCAqY29tbWl0LAoJCQkJCXN0cnVjdCBjb21taXRfbGlzdCAqKm5leHQpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqbmV3ID0geG1hbGxvYyhzaXplb2Yoc3RydWN0IGNvbW1pdF9saXN0KSk7CgluZXctPml0ZW0gPSBjb21taXQ7CgkqbmV4dCA9IG5ldzsKCW5ldy0+bmV4dCA9IE5VTEw7CglyZXR1cm4gJm5ldy0+bmV4dDsKfQoKc3RhdGljIGludCBmb3JtYXRfdG9kbyhzdHJ1Y3Qgc3RyYnVmICpidWYsIHN0cnVjdCBjb21taXRfbGlzdCAqdG9kb19saXN0LAoJCXN0cnVjdCByZXBsYXlfb3B0cyAqb3B0cykKewoJc3RydWN0IGNvbW1pdF9saXN0ICpjdXIgPSBOVUxMOwoJc3RydWN0IGNvbW1pdF9tZXNzYWdlIG1zZyA9IHsgTlVMTCwgTlVMTCwgTlVMTCwgTlVMTCwgTlVMTCB9OwoJY29uc3QgY2hhciAqc2hhMV9hYmJyZXYgPSBOVUxMOwoJY29uc3QgY2hhciAqYWN0aW9uX3N0ciA9IG9wdHMtPmFjdGlvbiA9PSBSRVZFUlQgPyAicmV2ZXJ0IiA6ICJwaWNrIjsKCglmb3IgKGN1ciA9IHRvZG9fbGlzdDsgY3VyOyBjdXIgPSBjdXItPm5leHQpIHsKCQlzaGExX2FiYnJldiA9IGZpbmRfdW5pcXVlX2FiYnJldihjdXItPml0ZW0tPm9iamVjdC5zaGExLCBERUZBVUxUX0FCQlJFVik7CgkJaWYgKGdldF9tZXNzYWdlKGN1ci0+aXRlbSwgJm1zZykpCgkJCXJldHVybiBlcnJvcihfKCJDYW5ub3QgZ2V0IGNvbW1pdCBtZXNzYWdlIGZvciAlcyIpLCBzaGExX2FiYnJldik7CgkJc3RyYnVmX2FkZGYoYnVmLCAiJXMgJXMgJXNcbiIsIGFjdGlvbl9zdHIsIHNoYTFfYWJicmV2LCBtc2cuc3ViamVjdCk7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgd2Fsa19yZXZzX3BvcHVsYXRlX3RvZG8oc3RydWN0IGNvbW1pdF9saXN0ICoqdG9kb19saXN0LAoJCQkJc3RydWN0IHJlcGxheV9vcHRzICpvcHRzKQp7CglzdHJ1Y3QgcmV2X2luZm8gcmV2czsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCXN0cnVjdCBjb21taXRfbGlzdCAqKm5leHQ7CgoJcHJlcGFyZV9yZXZzKCZyZXZzLCBvcHRzKTsKCgluZXh0ID0gdG9kb19saXN0OwoJd2hpbGUgKChjb21taXQgPSBnZXRfcmV2aXNpb24oJnJldnMpKSkKCQluZXh0ID0gY29tbWl0X2xpc3RfYXBwZW5kKGNvbW1pdCwgbmV4dCk7Cn0KCnN0YXRpYyB2b2lkIGNyZWF0ZV9zZXFfZGlyKHZvaWQpCnsKCWNvbnN0IGNoYXIgKnNlcV9kaXIgPSBnaXRfcGF0aChTRVFfRElSKTsKCglpZiAoIShmaWxlX2V4aXN0cyhzZXFfZGlyKSAmJiBpc19kaXJlY3Rvcnkoc2VxX2RpcikpCgkJJiYgbWtkaXIoc2VxX2RpciwgMDc3NykgPCAwKQoJCWRpZV9lcnJubyhfKCJDb3VsZCBub3QgY3JlYXRlIHNlcXVlbmNlciBkaXJlY3RvcnkgJyVzJy4iKSwgc2VxX2Rpcik7Cn0KCnN0YXRpYyB2b2lkIHNhdmVfaGVhZChjb25zdCBjaGFyICpoZWFkKQp7Cgljb25zdCBjaGFyICpoZWFkX2ZpbGUgPSBnaXRfcGF0aChTRVFfSEVBRF9GSUxFKTsKCXN0YXRpYyBzdHJ1Y3QgbG9ja19maWxlIGhlYWRfbG9jazsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglpbnQgZmQ7CgoJZmQgPSBob2xkX2xvY2tfZmlsZV9mb3JfdXBkYXRlKCZoZWFkX2xvY2ssIGhlYWRfZmlsZSwgTE9DS19ESUVfT05fRVJST1IpOwoJc3RyYnVmX2FkZGYoJmJ1ZiwgIiVzXG4iLCBoZWFkKTsKCWlmICh3cml0ZV9pbl9mdWxsKGZkLCBidWYuYnVmLCBidWYubGVuKSA8IDApCgkJZGllX2Vycm5vKF8oIkNvdWxkIG5vdCB3cml0ZSB0byAlcy4iKSwgaGVhZF9maWxlKTsKCWlmIChjb21taXRfbG9ja19maWxlKCZoZWFkX2xvY2spIDwgMCkKCQlkaWUoXygiRXJyb3Igd3JhcHBpbmcgdXAgJXMuIiksIGhlYWRfZmlsZSk7Cn0KCnN0YXRpYyB2b2lkIHNhdmVfdG9kbyhzdHJ1Y3QgY29tbWl0X2xpc3QgKnRvZG9fbGlzdCwgc3RydWN0IHJlcGxheV9vcHRzICpvcHRzKQp7Cgljb25zdCBjaGFyICp0b2RvX2ZpbGUgPSBnaXRfcGF0aChTRVFfVE9ET19GSUxFKTsKCXN0YXRpYyBzdHJ1Y3QgbG9ja19maWxlIHRvZG9fbG9jazsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglpbnQgZmQ7CgoJZmQgPSBob2xkX2xvY2tfZmlsZV9mb3JfdXBkYXRlKCZ0b2RvX2xvY2ssIHRvZG9fZmlsZSwgTE9DS19ESUVfT05fRVJST1IpOwoJaWYgKGZvcm1hdF90b2RvKCZidWYsIHRvZG9fbGlzdCwgb3B0cykgPCAwKQoJCWRpZShfKCJDb3VsZCBub3QgZm9ybWF0ICVzLiIpLCB0b2RvX2ZpbGUpOwoJaWYgKHdyaXRlX2luX2Z1bGwoZmQsIGJ1Zi5idWYsIGJ1Zi5sZW4pIDwgMCkgewoJCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJCWRpZV9lcnJubyhfKCJDb3VsZCBub3Qgd3JpdGUgdG8gJXMuIiksIHRvZG9fZmlsZSk7Cgl9CglpZiAoY29tbWl0X2xvY2tfZmlsZSgmdG9kb19sb2NrKSA8IDApIHsKCQlzdHJidWZfcmVsZWFzZSgmYnVmKTsKCQlkaWUoXygiRXJyb3Igd3JhcHBpbmcgdXAgJXMuIiksIHRvZG9fZmlsZSk7Cgl9CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKfQoKc3RhdGljIHZvaWQgc2F2ZV9vcHRzKHN0cnVjdCByZXBsYXlfb3B0cyAqb3B0cykKewoJY29uc3QgY2hhciAqb3B0c19maWxlID0gZ2l0X3BhdGgoU0VRX09QVFNfRklMRSk7CgoJaWYgKG9wdHMtPm5vX2NvbW1pdCkKCQlnaXRfY29uZmlnX3NldF9pbl9maWxlKG9wdHNfZmlsZSwgIm9wdGlvbnMubm8tY29tbWl0IiwgInRydWUiKTsKCWlmIChvcHRzLT5lZGl0KQoJCWdpdF9jb25maWdfc2V0X2luX2ZpbGUob3B0c19maWxlLCAib3B0aW9ucy5lZGl0IiwgInRydWUiKTsKCWlmIChvcHRzLT5zaWdub2ZmKQoJCWdpdF9jb25maWdfc2V0X2luX2ZpbGUob3B0c19maWxlLCAib3B0aW9ucy5zaWdub2ZmIiwgInRydWUiKTsKCWlmIChvcHRzLT5yZWNvcmRfb3JpZ2luKQoJCWdpdF9jb25maWdfc2V0X2luX2ZpbGUob3B0c19maWxlLCAib3B0aW9ucy5yZWNvcmQtb3JpZ2luIiwgInRydWUiKTsKCWlmIChvcHRzLT5hbGxvd19mZikKCQlnaXRfY29uZmlnX3NldF9pbl9maWxlKG9wdHNfZmlsZSwgIm9wdGlvbnMuYWxsb3ctZmYiLCAidHJ1ZSIpOwoJaWYgKG9wdHMtPm1haW5saW5lKSB7CgkJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCQlzdHJidWZfYWRkZigmYnVmLCAiJWQiLCBvcHRzLT5tYWlubGluZSk7CgkJZ2l0X2NvbmZpZ19zZXRfaW5fZmlsZShvcHRzX2ZpbGUsICJvcHRpb25zLm1haW5saW5lIiwgYnVmLmJ1Zik7CgkJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7Cgl9CglpZiAob3B0cy0+c3RyYXRlZ3kpCgkJZ2l0X2NvbmZpZ19zZXRfaW5fZmlsZShvcHRzX2ZpbGUsICJvcHRpb25zLnN0cmF0ZWd5Iiwgb3B0cy0+c3RyYXRlZ3kpOwoJaWYgKG9wdHMtPnhvcHRzKSB7CgkJaW50IGk7CgkJZm9yIChpID0gMDsgaSA8IG9wdHMtPnhvcHRzX25yOyBpKyspCgkJCWdpdF9jb25maWdfc2V0X211bHRpdmFyX2luX2ZpbGUob3B0c19maWxlLAoJCQkJCQkJIm9wdGlvbnMuc3RyYXRlZ3ktb3B0aW9uIiwKCQkJCQkJCW9wdHMtPnhvcHRzW2ldLCAiXiQiLCAwKTsKCX0KfQoKc3RhdGljIGludCBwaWNrX2NvbW1pdHMoc3RydWN0IGNvbW1pdF9saXN0ICp0b2RvX2xpc3QsIHN0cnVjdCByZXBsYXlfb3B0cyAqb3B0cykKewoJc3RydWN0IGNvbW1pdF9saXN0ICpjdXI7CglpbnQgcmVzOwoKCXNldGVudihHSVRfUkVGTE9HX0FDVElPTiwgYWN0aW9uX25hbWUob3B0cyksIDApOwoJaWYgKG9wdHMtPmFsbG93X2ZmKQoJCWFzc2VydCghKG9wdHMtPnNpZ25vZmYgfHwgb3B0cy0+bm9fY29tbWl0IHx8CgkJCQlvcHRzLT5yZWNvcmRfb3JpZ2luIHx8IG9wdHMtPmVkaXQpKTsKCXJlYWRfYW5kX3JlZnJlc2hfY2FjaGUob3B0cyk7CgoJZm9yIChjdXIgPSB0b2RvX2xpc3Q7IGN1cjsgY3VyID0gY3VyLT5uZXh0KSB7CgkJc2F2ZV90b2RvKGN1ciwgb3B0cyk7CgkJcmVzID0gZG9fcGlja19jb21taXQoY3VyLT5pdGVtLCBvcHRzKTsKCQlpZiAocmVzKSB7CgkJCWlmICghY3VyLT5uZXh0KQoJCQkJLyoKCQkJCSAqIEFuIGVycm9yIHdhcyBlbmNvdW50ZXJlZCB3aGlsZQoJCQkJICogcGlja2luZyB0aGUgbGFzdCBjb21taXQ7IHRoZQoJCQkJICogc2VxdWVuY2VyIHN0YXRlIGlzIHVzZWxlc3Mgbm93IC0tCgkJCQkgKiB0aGUgdXNlciBzaW1wbHkgbmVlZHMgdG8gcmVzb2x2ZQoJCQkJICogdGhlIGNvbmZsaWN0IGFuZCBjb21taXQKCQkJCSAqLwoJCQkJcmVtb3ZlX3NlcXVlbmNlcl9zdGF0ZSgwKTsKCQkJcmV0dXJuIHJlczsKCQl9Cgl9CgoJLyoKCSAqIFNlcXVlbmNlIG9mIHBpY2tzIGZpbmlzaGVkIHN1Y2Nlc3NmdWxseTsgY2xlYW51cCBieQoJICogcmVtb3ZpbmcgdGhlIC5naXQvc2VxdWVuY2VyIGRpcmVjdG9yeQoJICovCglyZW1vdmVfc2VxdWVuY2VyX3N0YXRlKDEpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgcGlja19yZXZpc2lvbnMoc3RydWN0IHJlcGxheV9vcHRzICpvcHRzKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnRvZG9fbGlzdCA9IE5VTEw7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoKCXJlYWRfYW5kX3JlZnJlc2hfY2FjaGUob3B0cyk7CgoJLyoKCSAqIERlY2lkZSB3aGF0IHRvIGRvIGRlcGVuZGluZyBvbiB0aGUgYXJndW1lbnRzOyBhIGZyZXNoCgkgKiBjaGVycnktcGljayBzaG91bGQgYmUgaGFuZGxlZCBkaWZmZXJlbnRseSBmcm9tIGFuIGV4aXN0aW5nCgkgKiBvbmUgdGhhdCBpcyBiZWluZyBjb250aW51ZWQKCSAqLwoJaWYgKG9wdHMtPnN1YmNvbW1hbmQgPT0gUkVQTEFZX1JFU0VUKSB7CgkJcmVtb3ZlX3NlcXVlbmNlcl9zdGF0ZSgxKTsKCQlyZXR1cm4gMDsKCX0gZWxzZSB7CgkJLyogU3RhcnQgYSBuZXcgY2hlcnJ5LXBpY2svIHJldmVydCBzZXF1ZW5jZSAqLwoJCXdhbGtfcmV2c19wb3B1bGF0ZV90b2RvKCZ0b2RvX2xpc3QsIG9wdHMpOwoJCWNyZWF0ZV9zZXFfZGlyKCk7CgkJaWYgKGdldF9zaGExKCJIRUFEIiwgc2hhMSkpIHsKCQkJaWYgKG9wdHMtPmFjdGlvbiA9PSBSRVZFUlQpCgkJCQlkaWUoXygiQ2FuJ3QgcmV2ZXJ0IGFzIGluaXRpYWwgY29tbWl0IikpOwoJCQlkaWUoXygiQ2FuJ3QgY2hlcnJ5LXBpY2sgaW50byBlbXB0eSBoZWFkIikpOwoJCX0KCQlzYXZlX2hlYWQoc2hhMV90b19oZXgoc2hhMSkpOwoJCXNhdmVfb3B0cyhvcHRzKTsKCX0KCXJldHVybiBwaWNrX2NvbW1pdHModG9kb19saXN0LCBvcHRzKTsKfQoKaW50IGNtZF9yZXZlcnQoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0cnVjdCByZXBsYXlfb3B0cyBvcHRzOwoKCW1lbXNldCgmb3B0cywgMCwgc2l6ZW9mKG9wdHMpKTsKCWlmIChpc2F0dHkoMCkpCgkJb3B0cy5lZGl0ID0gMTsKCW9wdHMuYWN0aW9uID0gUkVWRVJUOwoJZ2l0X2NvbmZpZyhnaXRfZGVmYXVsdF9jb25maWcsIE5VTEwpOwoJcGFyc2VfYXJncyhhcmdjLCBhcmd2LCAmb3B0cyk7CglyZXR1cm4gcGlja19yZXZpc2lvbnMoJm9wdHMpOwp9CgppbnQgY21kX2NoZXJyeV9waWNrKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdHJ1Y3QgcmVwbGF5X29wdHMgb3B0czsKCgltZW1zZXQoJm9wdHMsIDAsIHNpemVvZihvcHRzKSk7CglvcHRzLmFjdGlvbiA9IENIRVJSWV9QSUNLOwoJZ2l0X2NvbmZpZyhnaXRfZGVmYXVsdF9jb25maWcsIE5VTEwpOwoJcGFyc2VfYXJncyhhcmdjLCBhcmd2LCAmb3B0cyk7CglyZXR1cm4gcGlja19yZXZpc2lvbnMoJm9wdHMpOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"builtin.h\"\n#include \"object.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"run-command.h\"\n#include \"exec_cmd.h\"\n#include \"utf8.h\"\n#include \"parse-options.h\"\n#include \"cache-tree.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"rerere.h\"\n#include \"merge-recursive.h\"\n#include \"refs.h\"\n#include \"dir.h\"\n#include \"sequencer.h\"\n\n/*\n * This implements the builtins revert and cherry-pick.\n *\n * Copyright (c) 2007 Johannes E. Schindelin\n *\n * Based on git-revert.sh, which is\n *\n * Copyright (c) 2005 Linus Torvalds\n * Copyright (c) 2005 Junio C Hamano\n */\n\nstatic const char * const revert_usage[] = {\n\t\"git revert [options] <commit-ish>\",\n\t\"git revert <subcommand>\",\n\tNULL\n};\n\nstatic const char * const cherry_pick_usage[] = {\n\t\"git cherry-pick [options] <commit-ish>\",\n\t\"git cherry-pick <subcommand>\",\n\tNULL\n};\n\nenum replay_action { REVERT, CHERRY_PICK };\nenum replay_subcommand { REPLAY_NONE, REPLAY_RESET };\n\nstruct replay_opts {\n\tenum replay_action action;\n\tenum replay_subcommand subcommand;\n\n\t/* Boolean options */\n\tint edit;\n\tint record_origin;\n\tint no_commit;\n\tint signoff;\n\tint allow_ff;\n\tint allow_rerere_auto;\n\n\tint mainline;\n\tint commit_argc;\n\tconst char **commit_argv;\n\n\t/* Merge strategy */\n\tconst char *strategy;\n\tconst char **xopts;\n\tsize_t xopts_nr, xopts_alloc;\n};\n\n#define GIT_REFLOG_ACTION \"GIT_REFLOG_ACTION\"\n\nstatic const char *action_name(const struct replay_opts *opts)\n{\n\treturn opts->action == REVERT ? \"revert\" : \"cherry-pick\";\n}\n\nstatic char *get_encoding(const char *message);\n\nstatic const char * const *revert_or_cherry_pick_usage(struct replay_opts *opts)\n{\n\treturn opts->action == REVERT ? revert_usage : cherry_pick_usage;\n}\n\nstatic int option_parse_x(const struct option *opt,\n\t\t\t  const char *arg, int unset)\n{\n\tstruct replay_opts **opts_ptr = opt->value;\n\tstruct replay_opts *opts = *opts_ptr;\n\n\tif (unset)\n\t\treturn 0;\n\n\tALLOC_GROW(opts->xopts, opts->xopts_nr + 1, opts->xopts_alloc);\n\topts->xopts[opts->xopts_nr++] = xstrdup(arg);\n\treturn 0;\n}\n\nstatic void verify_opt_compatible(const char *me, const char *base_opt, ...)\n{\n\tconst char *this_opt;\n\tva_list ap;\n\n\tva_start(ap, base_opt);\n\twhile ((this_opt = va_arg(ap, const char *))) {\n\t\tif (va_arg(ap, int))\n\t\t\tbreak;\n\t}\n\tva_end(ap);\n\n\tif (this_opt)\n\t\tdie(_(\"%s: %s cannot be used with %s\"), me, this_opt, base_opt);\n}\n\nstatic void parse_args(int argc, const char **argv, struct replay_opts *opts)\n{\n\tconst char * const * usage_str = revert_or_cherry_pick_usage(opts);\n\tconst char *me = action_name(opts);\n\tint noop;\n\tint reset = 0;\n\tstruct option options[] = {\n\t\tOPT_BOOLEAN(0, \"reset\", &reset, \"forget the current operation\"),\n\t\tOPT_BOOLEAN('n', \"no-commit\", &opts->no_commit, \"don't automatically commit\"),\n\t\tOPT_BOOLEAN('e', \"edit\", &opts->edit, \"edit the commit message\"),\n\t\t{ OPTION_BOOLEAN, 'r', NULL, &noop, NULL, \"no-op (backward compatibility)\",\n\t\t  PARSE_OPT_NOARG | PARSE_OPT_HIDDEN, NULL, 0 },\n\t\tOPT_BOOLEAN('s', \"signoff\", &opts->signoff, \"add Signed-off-by:\"),\n\t\tOPT_INTEGER('m', \"mainline\", &opts->mainline, \"parent number\"),\n\t\tOPT_RERERE_AUTOUPDATE(&opts->allow_rerere_auto),\n\t\tOPT_STRING(0, \"strategy\", &opts->strategy, \"strategy\", \"merge strategy\"),\n\t\tOPT_CALLBACK('X', \"strategy-option\", &opts, \"option\",\n\t\t\t\"option for merge strategy\", option_parse_x),\n\t\tOPT_END(),\n\t\tOPT_END(),\n\t\tOPT_END(),\n\t};\n\n\tif (opts->action == CHERRY_PICK) {\n\t\tstruct option cp_extra[] = {\n\t\t\tOPT_BOOLEAN('x', NULL, &opts->record_origin, \"append commit name\"),\n\t\t\tOPT_BOOLEAN(0, \"ff\", &opts->allow_ff, \"allow fast-forward\"),\n\t\t\tOPT_END(),\n\t\t};\n\t\tif (parse_options_concat(options, ARRAY_SIZE(options), cp_extra))\n\t\t\tdie(_(\"program error\"));\n\t}\n\n\topts->commit_argc = parse_options(argc, argv, NULL, options, usage_str,\n\t\t\t\t\tPARSE_OPT_KEEP_ARGV0 |\n\t\t\t\t\tPARSE_OPT_KEEP_UNKNOWN);\n\n\t/* Set the subcommand */\n\tif (reset)\n\t\topts->subcommand = REPLAY_RESET;\n\telse\n\t\topts->subcommand = REPLAY_NONE;\n\n\t/* Check for incompatible command line arguments */\n\tif (opts->subcommand == REPLAY_RESET) {\n\t\tverify_opt_compatible(me, \"--reset\",\n\t\t\t\t\"--no-commit\", opts->no_commit,\n\t\t\t\t\"--signoff\", opts->signoff,\n\t\t\t\t\"--mainline\", opts->mainline,\n\t\t\t\t\"--strategy\", opts->strategy ? 1 : 0,\n\t\t\t\t\"--strategy-option\", opts->xopts ? 1 : 0,\n\t\t\t\t\"-x\", opts->record_origin,\n\t\t\t\t\"--ff\", opts->allow_ff,\n\t\t\t\tNULL);\n\t}\n\n\telse if (opts->commit_argc < 2)\n\t\tusage_with_options(usage_str, options);\n\n\tif (opts->allow_ff)\n\t\tverify_opt_compatible(me, \"--ff\",\n\t\t\t\t\"--signoff\", opts->signoff,\n\t\t\t\t\"--no-commit\", opts->no_commit,\n\t\t\t\t\"-x\", opts->record_origin,\n\t\t\t\t\"--edit\", opts->edit,\n\t\t\t\tNULL);\n\topts->commit_argv = argv;\n}\n\nstruct commit_message {\n\tchar *parent_label;\n\tconst char *label;\n\tconst char *subject;\n\tchar *reencoded_message;\n\tconst char *message;\n};\n\nstatic int get_message(struct commit *commit, struct commit_message *out)\n{\n\tconst char *encoding;\n\tconst char *abbrev, *subject;\n\tint abbrev_len, subject_len;\n\tchar *q;\n\n\tif (!commit->buffer)\n\t\treturn -1;\n\tencoding = get_encoding(commit->buffer);\n\tif (!encoding)\n\t\tencoding = \"UTF-8\";\n\tif (!git_commit_encoding)\n\t\tgit_commit_encoding = \"UTF-8\";\n\n\tout->reencoded_message = NULL;\n\tout->message = commit->buffer;\n\tif (strcmp(encoding, git_commit_encoding))\n\t\tout->reencoded_message = reencode_string(commit->buffer,\n\t\t\t\t\tgit_commit_encoding, encoding);\n\tif (out->reencoded_message)\n\t\tout->message = out->reencoded_message;\n\n\tabbrev = find_unique_abbrev(commit->object.sha1, DEFAULT_ABBREV);\n\tabbrev_len = strlen(abbrev);\n\n\tsubject_len = find_commit_subject(out->message, &subject);\n\n\tout->parent_label = xmalloc(strlen(\"parent of \") + abbrev_len +\n\t\t\t      strlen(\"... \") + subject_len + 1);\n\tq = out->parent_label;\n\tq = mempcpy(q, \"parent of \", strlen(\"parent of \"));\n\tout->label = q;\n\tq = mempcpy(q, abbrev, abbrev_len);\n\tq = mempcpy(q, \"... \", strlen(\"... \"));\n\tout->subject = q;\n\tq = mempcpy(q, subject, subject_len);\n\t*q = '\\0';\n\treturn 0;\n}\n\nstatic void free_message(struct commit_message *msg)\n{\n\tfree(msg->parent_label);\n\tfree(msg->reencoded_message);\n}\n\nstatic char *get_encoding(const char *message)\n{\n\tconst char *p = message, *eol;\n\n\twhile (*p && *p != '\\n') {\n\t\tfor (eol = p + 1; *eol && *eol != '\\n'; eol++)\n\t\t\t; /* do nothing */\n\t\tif (!prefixcmp(p, \"encoding \")) {\n\t\t\tchar *result = xmalloc(eol - 8 - p);\n\t\t\tstrlcpy(result, p + 9, eol - 8 - p);\n\t\t\treturn result;\n\t\t}\n\t\tp = eol;\n\t\tif (*p == '\\n')\n\t\t\tp++;\n\t}\n\treturn NULL;\n}\n\nstatic void write_cherry_pick_head(struct commit *commit)\n{\n\tint fd;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tstrbuf_addf(&buf, \"%s\\n\", sha1_to_hex(commit->object.sha1));\n\n\tfd = open(git_path(\"CHERRY_PICK_HEAD\"), O_WRONLY | O_CREAT, 0666);\n\tif (fd < 0)\n\t\tdie_errno(_(\"Could not open '%s' for writing\"),\n\t\t\t  git_path(\"CHERRY_PICK_HEAD\"));\n\tif (write_in_full(fd, buf.buf, buf.len) != buf.len || close(fd))\n\t\tdie_errno(_(\"Could not write to '%s'\"), git_path(\"CHERRY_PICK_HEAD\"));\n\tstrbuf_release(&buf);\n}\n\nstatic void print_advice(void)\n{\n\tchar *msg = getenv(\"GIT_CHERRY_PICK_HELP\");\n\n\tif (msg) {\n\t\tfprintf(stderr, \"%s\\n\", msg);\n\t\t/*\n\t\t * A conflict has occured but the porcelain\n\t\t * (typically rebase --interactive) wants to take care\n\t\t * of the commit itself so remove CHERRY_PICK_HEAD\n\t\t */\n\t\tunlink(git_path(\"CHERRY_PICK_HEAD\"));\n\t\treturn;\n\t}\n\n\tadvise(\"after resolving the conflicts, mark the corrected paths\");\n\tadvise(\"with 'git add <paths>' or 'git rm <paths>'\");\n\tadvise(\"and commit the result with 'git commit'\");\n}\n\nstatic void write_message(struct strbuf *msgbuf, const char *filename)\n{\n\tstatic struct lock_file msg_file;\n\n\tint msg_fd = hold_lock_file_for_update(&msg_file, filename,\n\t\t\t\t\t       LOCK_DIE_ON_ERROR);\n\tif (write_in_full(msg_fd, msgbuf->buf, msgbuf->len) < 0)\n\t\tdie_errno(_(\"Could not write to %s.\"), filename);\n\tstrbuf_release(msgbuf);\n\tif (commit_lock_file(&msg_file) < 0)\n\t\tdie(_(\"Error wrapping up %s\"), filename);\n}\n\nstatic struct tree *empty_tree(void)\n{\n\tstruct tree *tree = xcalloc(1, sizeof(struct tree));\n\n\ttree->object.parsed = 1;\n\ttree->object.type = OBJ_TREE;\n\tpretend_sha1_file(NULL, 0, OBJ_TREE, tree->object.sha1);\n\treturn tree;\n}\n\nstatic NORETURN void die_dirty_index(struct replay_opts *opts)\n{\n\tif (read_cache_unmerged()) {\n\t\tdie_resolve_conflict(action_name(opts));\n\t} else {\n\t\tif (advice_commit_before_merge) {\n\t\t\tif (opts->action == REVERT)\n\t\t\t\tdie(_(\"Your local changes would be overwritten by revert.\\n\"\n\t\t\t\t\t  \"Please, commit your changes or stash them to proceed.\"));\n\t\t\telse\n\t\t\t\tdie(_(\"Your local changes would be overwritten by cherry-pick.\\n\"\n\t\t\t\t\t  \"Please, commit your changes or stash them to proceed.\"));\n\t\t} else {\n\t\t\tif (opts->action == REVERT)\n\t\t\t\tdie(_(\"Your local changes would be overwritten by revert.\\n\"));\n\t\t\telse\n\t\t\t\tdie(_(\"Your local changes would be overwritten by cherry-pick.\\n\"));\n\t\t}\n\t}\n}\n\nstatic int fast_forward_to(const unsigned char *to, const unsigned char *from)\n{\n\tstruct ref_lock *ref_lock;\n\n\tread_cache();\n\tif (checkout_fast_forward(from, to))\n\t\texit(1); /* the callee should have complained already */\n\tref_lock = lock_any_ref_for_update(\"HEAD\", from, 0);\n\treturn write_ref_sha1(ref_lock, to, \"cherry-pick\");\n}\n\nstatic int do_recursive_merge(struct commit *base, struct commit *next,\n\t\t\t      const char *base_label, const char *next_label,\n\t\t\t      unsigned char *head, struct strbuf *msgbuf,\n\t\t\t      struct replay_opts *opts)\n{\n\tstruct merge_options o;\n\tstruct tree *result, *next_tree, *base_tree, *head_tree;\n\tint clean, index_fd;\n\tconst char **xopt;\n\tstatic struct lock_file index_lock;\n\n\tindex_fd = hold_locked_index(&index_lock, 1);\n\n\tread_cache();\n\n\tinit_merge_options(&o);\n\to.ancestor = base ? base_label : \"(empty tree)\";\n\to.branch1 = \"HEAD\";\n\to.branch2 = next ? next_label : \"(empty tree)\";\n\n\thead_tree = parse_tree_indirect(head);\n\tnext_tree = next ? next->tree : empty_tree();\n\tbase_tree = base ? base->tree : empty_tree();\n\n\tfor (xopt = opts->xopts; xopt != opts->xopts + opts->xopts_nr; xopt++)\n\t\tparse_merge_opt(&o, *xopt);\n\n\tclean = merge_trees(&o,\n\t\t\t    head_tree,\n\t\t\t    next_tree, base_tree, &result);\n\n\tif (active_cache_changed &&\n\t    (write_cache(index_fd, active_cache, active_nr) ||\n\t     commit_locked_index(&index_lock)))\n\t\t/* TRANSLATORS: %s will be \"revert\" or \"cherry-pick\" */\n\t\tdie(_(\"%s: Unable to write new index file\"), action_name(opts));\n\trollback_lock_file(&index_lock);\n\n\tif (!clean) {\n\t\tint i;\n\t\tstrbuf_addstr(msgbuf, \"\\nConflicts:\\n\\n\");\n\t\tfor (i = 0; i < active_nr;) {\n\t\t\tstruct cache_entry *ce = active_cache[i++];\n\t\t\tif (ce_stage(ce)) {\n\t\t\t\tstrbuf_addch(msgbuf, '\\t');\n\t\t\t\tstrbuf_addstr(msgbuf, ce->name);\n\t\t\t\tstrbuf_addch(msgbuf, '\\n');\n\t\t\t\twhile (i < active_nr && !strcmp(ce->name,\n\t\t\t\t\t\tactive_cache[i]->name))\n\t\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn !clean;\n}\n\n/*\n * If we are cherry-pick, and if the merge did not result in\n * hand-editing, we will hit this commit and inherit the original\n * author date and name.\n * If we are revert, or if our cherry-pick results in a hand merge,\n * we had better say that the current user is responsible for that.\n */\nstatic int run_git_commit(const char *defmsg, struct replay_opts *opts)\n{\n\t/* 6 is max possible length of our args array including NULL */\n\tconst char *args[6];\n\tint i = 0;\n\n\targs[i++] = \"commit\";\n\targs[i++] = \"-n\";\n\tif (opts->signoff)\n\t\targs[i++] = \"-s\";\n\tif (!opts->edit) {\n\t\targs[i++] = \"-F\";\n\t\targs[i++] = defmsg;\n\t}\n\targs[i] = NULL;\n\n\treturn run_command_v_opt(args, RUN_GIT_CMD);\n}\n\nstatic int do_pick_commit(struct commit *commit, struct replay_opts *opts)\n{\n\tunsigned char head[20];\n\tstruct commit *base, *next, *parent;\n\tconst char *base_label, *next_label;\n\tstruct commit_message msg = { NULL, NULL, NULL, NULL, NULL };\n\tchar *defmsg = NULL;\n\tstruct strbuf msgbuf = STRBUF_INIT;\n\tint res;\n\n\tif (opts->no_commit) {\n\t\t/*\n\t\t * We do not intend to commit immediately.  We just want to\n\t\t * merge the differences in, so let's compute the tree\n\t\t * that represents the \"current\" state for merge-recursive\n\t\t * to work on.\n\t\t */\n\t\tif (write_cache_as_tree(head, 0, NULL))\n\t\t\tdie (_(\"Your index file is unmerged.\"));\n\t} else {\n\t\tif (get_sha1(\"HEAD\", head))\n\t\t\tdie (_(\"You do not have a valid HEAD\"));\n\t\tif (index_differs_from(\"HEAD\", 0))\n\t\t\tdie_dirty_index(opts);\n\t}\n\tdiscard_cache();\n\n\tif (!commit->parents) {\n\t\tparent = NULL;\n\t}\n\telse if (commit->parents->next) {\n\t\t/* Reverting or cherry-picking a merge commit */\n\t\tint cnt;\n\t\tstruct commit_list *p;\n\n\t\tif (!opts->mainline)\n\t\t\tdie(_(\"Commit %s is a merge but no -m option was given.\"),\n\t\t\t    sha1_to_hex(commit->object.sha1));\n\n\t\tfor (cnt = 1, p = commit->parents;\n\t\t     cnt != opts->mainline && p;\n\t\t     cnt++)\n\t\t\tp = p->next;\n\t\tif (cnt != opts->mainline || !p)\n\t\t\tdie(_(\"Commit %s does not have parent %d\"),\n\t\t\t    sha1_to_hex(commit->object.sha1), opts->mainline);\n\t\tparent = p->item;\n\t} else if (0 < opts->mainline)\n\t\tdie(_(\"Mainline was specified but commit %s is not a merge.\"),\n\t\t    sha1_to_hex(commit->object.sha1));\n\telse\n\t\tparent = commit->parents->item;\n\n\tif (opts->allow_ff && parent && !hashcmp(parent->object.sha1, head))\n\t\treturn fast_forward_to(commit->object.sha1, head);\n\n\tif (parent && parse_commit(parent) < 0)\n\t\t/* TRANSLATORS: The first %s will be \"revert\" or\n\t\t   \"cherry-pick\", the second %s a SHA1 */\n\t\tdie(_(\"%s: cannot parse parent commit %s\"),\n\t\t    action_name(opts), sha1_to_hex(parent->object.sha1));\n\n\tif (get_message(commit, &msg) != 0)\n\t\tdie(_(\"Cannot get commit message for %s\"),\n\t\t\t\tsha1_to_hex(commit->object.sha1));\n\n\t/*\n\t * \"commit\" is an existing commit.  We would want to apply\n\t * the difference it introduces since its first parent \"prev\"\n\t * on top of the current HEAD if we are cherry-pick.  Or the\n\t * reverse of it if we are revert.\n\t */\n\n\tdefmsg = git_pathdup(\"MERGE_MSG\");\n\n\tif (opts->action == REVERT) {\n\t\tbase = commit;\n\t\tbase_label = msg.label;\n\t\tnext = parent;\n\t\tnext_label = msg.parent_label;\n\t\tstrbuf_addstr(&msgbuf, \"Revert \\\"\");\n\t\tstrbuf_addstr(&msgbuf, msg.subject);\n\t\tstrbuf_addstr(&msgbuf, \"\\\"\\n\\nThis reverts commit \");\n\t\tstrbuf_addstr(&msgbuf, sha1_to_hex(commit->object.sha1));\n\n\t\tif (commit->parents && commit->parents->next) {\n\t\t\tstrbuf_addstr(&msgbuf, \", reversing\\nchanges made to \");\n\t\t\tstrbuf_addstr(&msgbuf, sha1_to_hex(parent->object.sha1));\n\t\t}\n\t\tstrbuf_addstr(&msgbuf, \".\\n\");\n\t} else {\n\t\tconst char *p;\n\n\t\tbase = parent;\n\t\tbase_label = msg.parent_label;\n\t\tnext = commit;\n\t\tnext_label = msg.label;\n\n\t\t/*\n\t\t * Append the commit log message to msgbuf; it starts\n\t\t * after the tree, parent, author, committer\n\t\t * information followed by \"\\n\\n\".\n\t\t */\n\t\tp = strstr(msg.message, \"\\n\\n\");\n\t\tif (p) {\n\t\t\tp += 2;\n\t\t\tstrbuf_addstr(&msgbuf, p);\n\t\t}\n\n\t\tif (opts->record_origin) {\n\t\t\tstrbuf_addstr(&msgbuf, \"(cherry picked from commit \");\n\t\t\tstrbuf_addstr(&msgbuf, sha1_to_hex(commit->object.sha1));\n\t\t\tstrbuf_addstr(&msgbuf, \")\\n\");\n\t\t}\n\t\tif (!opts->no_commit)\n\t\t\twrite_cherry_pick_head(commit);\n\t}\n\n\tif (!opts->strategy || !strcmp(opts->strategy, \"recursive\") || opts->action == REVERT) {\n\t\tres = do_recursive_merge(base, next, base_label, next_label,\n\t\t\t\t\t head, &msgbuf, opts);\n\t\twrite_message(&msgbuf, defmsg);\n\t} else {\n\t\tstruct commit_list *common = NULL;\n\t\tstruct commit_list *remotes = NULL;\n\n\t\twrite_message(&msgbuf, defmsg);\n\n\t\tcommit_list_insert(base, &common);\n\t\tcommit_list_insert(next, &remotes);\n\t\tres = try_merge_command(opts->strategy, opts->xopts_nr, opts->xopts,\n\t\t\t\t\tcommon, sha1_to_hex(head), remotes);\n\t\tfree_commit_list(common);\n\t\tfree_commit_list(remotes);\n\t}\n\n\tif (res) {\n\t\terror(opts->action == REVERT\n\t\t      ? _(\"could not revert %s... %s\")\n\t\t      : _(\"could not apply %s... %s\"),\n\t\t      find_unique_abbrev(commit->object.sha1, DEFAULT_ABBREV),\n\t\t      msg.subject);\n\t\tprint_advice();\n\t\trerere(opts->allow_rerere_auto);\n\t} else {\n\t\tif (!opts->no_commit)\n\t\t\tres = run_git_commit(defmsg, opts);\n\t}\n\n\tfree_message(&msg);\n\tfree(defmsg);\n\n\treturn res;\n}\n\nstatic void prepare_revs(struct rev_info *revs, struct replay_opts *opts)\n{\n\tint argc;\n\n\tinit_revisions(revs, NULL);\n\trevs->no_walk = 1;\n\tif (opts->action != REVERT)\n\t\trevs->reverse = 1;\n\n\targc = setup_revisions(opts->commit_argc, opts->commit_argv, revs, NULL);\n\tif (argc > 1)\n\t\tusage(*revert_or_cherry_pick_usage(opts));\n\n\tif (prepare_revision_walk(revs))\n\t\tdie(_(\"revision walk setup failed\"));\n\n\tif (!revs->commits)\n\t\tdie(_(\"empty commit set passed\"));\n}\n\nstatic void read_and_refresh_cache(struct replay_opts *opts)\n{\n\tstatic struct lock_file index_lock;\n\tint index_fd = hold_locked_index(&index_lock, 0);\n\tif (read_index_preload(&the_index, NULL) < 0)\n\t\tdie(_(\"git %s: failed to read the index\"), action_name(opts));\n\trefresh_index(&the_index, REFRESH_QUIET|REFRESH_UNMERGED, NULL, NULL, NULL);\n\tif (the_index.cache_changed) {\n\t\tif (write_index(&the_index, index_fd) ||\n\t\t    commit_locked_index(&index_lock))\n\t\t\tdie(_(\"git %s: failed to refresh the index\"), action_name(opts));\n\t}\n\trollback_lock_file(&index_lock);\n}\n\n/*\n * Append a commit to the end of the commit_list.\n *\n * next starts by pointing to the variable that holds the head of an\n * empty commit_list, and is updated to point to the \"next\" field of\n * the last item on the list as new commits are appended.\n *\n * Usage example:\n *\n *     struct commit_list *list;\n *     struct commit_list **next = &list;\n *\n *     next = commit_list_append(c1, next);\n *     next = commit_list_append(c2, next);\n *     assert(commit_list_count(list) == 2);\n *     return list;\n */\nstruct commit_list **commit_list_append(struct commit *commit,\n\t\t\t\t\tstruct commit_list **next)\n{\n\tstruct commit_list *new = xmalloc(sizeof(struct commit_list));\n\tnew->item = commit;\n\t*next = new;\n\tnew->next = NULL;\n\treturn &new->next;\n}\n\nstatic int format_todo(struct strbuf *buf, struct commit_list *todo_list,\n\t\tstruct replay_opts *opts)\n{\n\tstruct commit_list *cur = NULL;\n\tstruct commit_message msg = { NULL, NULL, NULL, NULL, NULL };\n\tconst char *sha1_abbrev = NULL;\n\tconst char *action_str = opts->action == REVERT ? \"revert\" : \"pick\";\n\n\tfor (cur = todo_list; cur; cur = cur->next) {\n\t\tsha1_abbrev = find_unique_abbrev(cur->item->object.sha1, DEFAULT_ABBREV);\n\t\tif (get_message(cur->item, &msg))\n\t\t\treturn error(_(\"Cannot get commit message for %s\"), sha1_abbrev);\n\t\tstrbuf_addf(buf, \"%s %s %s\\n\", action_str, sha1_abbrev, msg.subject);\n\t}\n\treturn 0;\n}\n\nstatic void walk_revs_populate_todo(struct commit_list **todo_list,\n\t\t\t\tstruct replay_opts *opts)\n{\n\tstruct rev_info revs;\n\tstruct commit *commit;\n\tstruct commit_list **next;\n\n\tprepare_revs(&revs, opts);\n\n\tnext = todo_list;\n\twhile ((commit = get_revision(&revs)))\n\t\tnext = commit_list_append(commit, next);\n}\n\nstatic void create_seq_dir(void)\n{\n\tconst char *seq_dir = git_path(SEQ_DIR);\n\n\tif (!(file_exists(seq_dir) && is_directory(seq_dir))\n\t\t&& mkdir(seq_dir, 0777) < 0)\n\t\tdie_errno(_(\"Could not create sequencer directory '%s'.\"), seq_dir);\n}\n\nstatic void save_head(const char *head)\n{\n\tconst char *head_file = git_path(SEQ_HEAD_FILE);\n\tstatic struct lock_file head_lock;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint fd;\n\n\tfd = hold_lock_file_for_update(&head_lock, head_file, LOCK_DIE_ON_ERROR);\n\tstrbuf_addf(&buf, \"%s\\n\", head);\n\tif (write_in_full(fd, buf.buf, buf.len) < 0)\n\t\tdie_errno(_(\"Could not write to %s.\"), head_file);\n\tif (commit_lock_file(&head_lock) < 0)\n\t\tdie(_(\"Error wrapping up %s.\"), head_file);\n}\n\nstatic void save_todo(struct commit_list *todo_list, struct replay_opts *opts)\n{\n\tconst char *todo_file = git_path(SEQ_TODO_FILE);\n\tstatic struct lock_file todo_lock;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint fd;\n\n\tfd = hold_lock_file_for_update(&todo_lock, todo_file, LOCK_DIE_ON_ERROR);\n\tif (format_todo(&buf, todo_list, opts) < 0)\n\t\tdie(_(\"Could not format %s.\"), todo_file);\n\tif (write_in_full(fd, buf.buf, buf.len) < 0) {\n\t\tstrbuf_release(&buf);\n\t\tdie_errno(_(\"Could not write to %s.\"), todo_file);\n\t}\n\tif (commit_lock_file(&todo_lock) < 0) {\n\t\tstrbuf_release(&buf);\n\t\tdie(_(\"Error wrapping up %s.\"), todo_file);\n\t}\n\tstrbuf_release(&buf);\n}\n\nstatic void save_opts(struct replay_opts *opts)\n{\n\tconst char *opts_file = git_path(SEQ_OPTS_FILE);\n\n\tif (opts->no_commit)\n\t\tgit_config_set_in_file(opts_file, \"options.no-commit\", \"true\");\n\tif (opts->edit)\n\t\tgit_config_set_in_file(opts_file, \"options.edit\", \"true\");\n\tif (opts->signoff)\n\t\tgit_config_set_in_file(opts_file, \"options.signoff\", \"true\");\n\tif (opts->record_origin)\n\t\tgit_config_set_in_file(opts_file, \"options.record-origin\", \"true\");\n\tif (opts->allow_ff)\n\t\tgit_config_set_in_file(opts_file, \"options.allow-ff\", \"true\");\n\tif (opts->mainline) {\n\t\tstruct strbuf buf = STRBUF_INIT;\n\t\tstrbuf_addf(&buf, \"%d\", opts->mainline);\n\t\tgit_config_set_in_file(opts_file, \"options.mainline\", buf.buf);\n\t\tstrbuf_release(&buf);\n\t}\n\tif (opts->strategy)\n\t\tgit_config_set_in_file(opts_file, \"options.strategy\", opts->strategy);\n\tif (opts->xopts) {\n\t\tint i;\n\t\tfor (i = 0; i < opts->xopts_nr; i++)\n\t\t\tgit_config_set_multivar_in_file(opts_file,\n\t\t\t\t\t\t\t\"options.strategy-option\",\n\t\t\t\t\t\t\topts->xopts[i], \"^$\", 0);\n\t}\n}\n\nstatic int pick_commits(struct commit_list *todo_list, struct replay_opts *opts)\n{\n\tstruct commit_list *cur;\n\tint res;\n\n\tsetenv(GIT_REFLOG_ACTION, action_name(opts), 0);\n\tif (opts->allow_ff)\n\t\tassert(!(opts->signoff || opts->no_commit ||\n\t\t\t\topts->record_origin || opts->edit));\n\tread_and_refresh_cache(opts);\n\n\tfor (cur = todo_list; cur; cur = cur->next) {\n\t\tsave_todo(cur, opts);\n\t\tres = do_pick_commit(cur->item, opts);\n\t\tif (res) {\n\t\t\tif (!cur->next)\n\t\t\t\t/*\n\t\t\t\t * An error was encountered while\n\t\t\t\t * picking the last commit; the\n\t\t\t\t * sequencer state is useless now --\n\t\t\t\t * the user simply needs to resolve\n\t\t\t\t * the conflict and commit\n\t\t\t\t */\n\t\t\t\tremove_sequencer_state(0);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\t/*\n\t * Sequence of picks finished successfully; cleanup by\n\t * removing the .git/sequencer directory\n\t */\n\tremove_sequencer_state(1);\n\treturn 0;\n}\n\nstatic int pick_revisions(struct replay_opts *opts)\n{\n\tstruct commit_list *todo_list = NULL;\n\tunsigned char sha1[20];\n\n\tread_and_refresh_cache(opts);\n\n\t/*\n\t * Decide what to do depending on the arguments; a fresh\n\t * cherry-pick should be handled differently from an existing\n\t * one that is being continued\n\t */\n\tif (opts->subcommand == REPLAY_RESET) {\n\t\tremove_sequencer_state(1);\n\t\treturn 0;\n\t} else {\n\t\t/* Start a new cherry-pick/ revert sequence */\n\t\twalk_revs_populate_todo(&todo_list, opts);\n\t\tcreate_seq_dir();\n\t\tif (get_sha1(\"HEAD\", sha1)) {\n\t\t\tif (opts->action == REVERT)\n\t\t\t\tdie(_(\"Can't revert as initial commit\"));\n\t\t\tdie(_(\"Can't cherry-pick into empty head\"));\n\t\t}\n\t\tsave_head(sha1_to_hex(sha1));\n\t\tsave_opts(opts);\n\t}\n\treturn pick_commits(todo_list, opts);\n}\n\nint cmd_revert(int argc, const char **argv, const char *prefix)\n{\n\tstruct replay_opts opts;\n\n\tmemset(&opts, 0, sizeof(opts));\n\tif (isatty(0))\n\t\topts.edit = 1;\n\topts.action = REVERT;\n\tgit_config(git_default_config, NULL);\n\tparse_args(argc, argv, &opts);\n\treturn pick_revisions(&opts);\n}\n\nint cmd_cherry_pick(int argc, const char **argv, const char *prefix)\n{\n\tstruct replay_opts opts;\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.action = CHERRY_PICK;\n\tgit_config(git_default_config, NULL);\n\tparse_args(argc, argv, &opts);\n\treturn pick_revisions(&opts);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "000806c7c42b282a0a6c37af8772e01ae9308a5b",
  "sha1_ok": true,
  "size": 23002
}
