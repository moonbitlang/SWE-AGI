{
  "content": {
    "base64": "IyEvYmluL3NoCiMKIyBDb3B5cmlnaHQgKGMpIDIwMjAgR29vZ2xlIExMQwojCgp0ZXN0X2Rlc2NyaXB0aW9uPSdyZWZ0YWJsZSBiYXNpY3MnCgpHSVRfVEVTVF9ERUZBVUxUX0lOSVRJQUxfQlJBTkNIX05BTUU9bWFpbgpleHBvcnQgR0lUX1RFU1RfREVGQVVMVF9JTklUSUFMX0JSQU5DSF9OQU1FCkdJVF9URVNUX0RFRkFVTFRfUkVGX0ZPUk1BVD1yZWZ0YWJsZQpleHBvcnQgR0lUX1RFU1RfREVGQVVMVF9SRUZfRk9STUFUCgouIC4vdGVzdC1saWIuc2gKCklOVkFMSURfT0lEPSQodGVzdF9vaWQgMDAxKQoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncGFjay1yZWZzIGRvZXMgbm90IGNyYXNoIHdpdGggLWgnICcKCXRlc3RfZXhwZWN0X2NvZGUgMTI5IGdpdCBwYWNrLXJlZnMgLWggPnVzYWdlICYmCgl0ZXN0X2dyZXAgIltVdV1zYWdlOiBnaXQgcGFjay1yZWZzICIgdXNhZ2UgJiYKCXRlc3RfZXhwZWN0X2NvZGUgMTI5IG5vbmdpdCBnaXQgcGFjay1yZWZzIC1oID51c2FnZSAmJgoJdGVzdF9ncmVwICJbVXVdc2FnZTogZ2l0IHBhY2stcmVmcyAiIHVzYWdlCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ2luaXQ6IGNyZWF0ZXMgYmFzaWMgcmVmdGFibGUgc3RydWN0dXJlcycgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyIgJiYKCWdpdCBpbml0IHJlcG8gJiYKCXRlc3RfcGF0aF9pc19kaXIgcmVwby8uZ2l0L3JlZnRhYmxlICYmCgl0ZXN0X3BhdGhfaXNfZmlsZSByZXBvLy5naXQvcmVmdGFibGUvdGFibGVzLmxpc3QgJiYKCWVjaG8gcmVmdGFibGUgPmV4cGVjdCAmJgoJZ2l0IC1DIHJlcG8gcmV2LXBhcnNlIC0tc2hvdy1yZWYtZm9ybWF0ID5hY3R1YWwgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnaW5pdDogc2hhMjU2IG9iamVjdCBmb3JtYXQgdmlhIGVudmlyb25tZW50IHZhcmlhYmxlJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJR0lUX0RFRkFVTFRfSEFTSD1zaGEyNTYgZ2l0IGluaXQgcmVwbyAmJgoJY2F0ID5leHBlY3QgPDwtRU9GICYmCglzaGEyNTYKCXJlZnRhYmxlCglFT0YKCWdpdCAtQyByZXBvIHJldi1wYXJzZSAtLXNob3ctb2JqZWN0LWZvcm1hdCAtLXNob3ctcmVmLWZvcm1hdCA+YWN0dWFsICYmCgl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ2luaXQ6IHNoYTI1NiBvYmplY3QgZm9ybWF0IHZpYSBvcHRpb24nICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCAtLW9iamVjdC1mb3JtYXQ9c2hhMjU2IHJlcG8gJiYKCWNhdCA+ZXhwZWN0IDw8LUVPRiAmJgoJc2hhMjU2CglyZWZ0YWJsZQoJRU9GCglnaXQgLUMgcmVwbyByZXYtcGFyc2UgLS1zaG93LW9iamVjdC1mb3JtYXQgLS1zaG93LXJlZi1mb3JtYXQgPmFjdHVhbCAmJgoJdGVzdF9jbXAgZXhwZWN0IGFjdHVhbAonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdpbml0OiByZWluaXRpYWxpemluZyByZWZ0YWJsZSBiYWNrZW5kIHN1Y2NlZWRzJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJdGVzdF9jb21taXQgLUMgcmVwbyBBICYmCgoJZ2l0IC1DIHJlcG8gZm9yLWVhY2gtcmVmID5leHBlY3QgJiYKCWdpdCBpbml0IC0tcmVmLWZvcm1hdD1yZWZ0YWJsZSByZXBvICYmCglnaXQgLUMgcmVwbyBmb3ItZWFjaC1yZWYgPmFjdHVhbCAmJgoJdGVzdF9jbXAgZXhwZWN0IGFjdHVhbAonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdpbml0OiByZWluaXRpYWxpemluZyBmaWxlcyB3aXRoIHJlZnRhYmxlIGJhY2tlbmQgZmFpbHMnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCAtLXJlZi1mb3JtYXQ9ZmlsZXMgcmVwbyAmJgoJdGVzdF9jb21taXQgLUMgcmVwbyBmaWxlICYmCgoJY3AgcmVwby8uZ2l0L0hFQUQgZXhwZWN0ICYmCgl0ZXN0X211c3RfZmFpbCBnaXQgaW5pdCAtLXJlZi1mb3JtYXQ9cmVmdGFibGUgcmVwbyAmJgoJdGVzdF9jbXAgZXhwZWN0IHJlcG8vLmdpdC9IRUFECicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ2luaXQ6IHJlaW5pdGlhbGl6aW5nIHJlZnRhYmxlIHdpdGggZmlsZXMgYmFja2VuZCBmYWlscycgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyIgJiYKCWdpdCBpbml0IC0tcmVmLWZvcm1hdD1yZWZ0YWJsZSByZXBvICYmCgl0ZXN0X2NvbW1pdCAtQyByZXBvIGZpbGUgJiYKCgljcCByZXBvLy5naXQvSEVBRCBleHBlY3QgJiYKCXRlc3RfbXVzdF9mYWlsIGdpdCBpbml0IC0tcmVmLWZvcm1hdD1maWxlcyByZXBvICYmCgl0ZXN0X2NtcCBleHBlY3QgcmVwby8uZ2l0L0hFQUQKJwoKdGVzdF9leHBlY3RfcGVybXMgKCkgewoJbG9jYWwgcGVybXM9IiQxIiAmJgoJbG9jYWwgZmlsZT0iJDIiICYmCglsb2NhbCBhY3R1YWw9IiQobHMgLWwgIiRmaWxlIikiICYmCgoJY2FzZSAiJGFjdHVhbCIgaW4KCSRwZXJtcyopCgkJOiBoYXBweQoJCTs7CgkqKQoJCWVjaG8gIiQoYmFzZW5hbWUgJDIpIGlzIG5vdCAkcGVybXMgYnV0ICRhY3R1YWwiCgkJZmFsc2UKCQk7OwoJZXNhYwp9Cgp0ZXN0X2V4cGVjdF9yZWZ0YWJsZV9wZXJtcyAoKSB7Cglsb2NhbCB1bWFzaz0iJDEiCglsb2NhbCBzaGFyZWQ9IiQyIgoJbG9jYWwgZXhwZWN0PSIkMyIKCgl0ZXN0X2V4cGVjdF9zdWNjZXNzIFBPU0lYUEVSTSAiaW5pdDogaG9ub3JzIC0tc2hhcmVkPSRzaGFyZWQgd2l0aCB1bWFzayAkdW1hc2siICcKCQl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJCSgKCQkJdW1hc2sgJHVtYXNrICYmCgkJCWdpdCBpbml0IC0tc2hhcmVkPSRzaGFyZWQgcmVwbwoJCSkgJiYKCQl0ZXN0X2V4cGVjdF9wZXJtcyAiJGV4cGVjdCIgcmVwby8uZ2l0L3JlZnRhYmxlL3RhYmxlcy5saXN0ICYmCgkJZm9yIHRhYmxlIGluIHJlcG8vLmdpdC9yZWZ0YWJsZS8qLnJlZgoJCWRvCgkJCXRlc3RfZXhwZWN0X3Blcm1zICIkZXhwZWN0IiAiJHRhYmxlIiB8fAoJCQlyZXR1cm4gMQoJCWRvbmUKCScKCgl0ZXN0X2V4cGVjdF9zdWNjZXNzIFBPU0lYUEVSTSAicGFjay1yZWZzOiBob25vcnMgLS1zaGFyZWQ9JHNoYXJlZCB3aXRoIHVtYXNrICR1bWFzayIgJwoJCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCgkJKAoJCQl1bWFzayAkdW1hc2sgJiYKCQkJZ2l0IGluaXQgLS1zaGFyZWQ9JHNoYXJlZCByZXBvICYmCgkJCXRlc3RfY29tbWl0IC1DIHJlcG8gQSAmJgoJCQl0ZXN0X2xpbmVfY291bnQgPSAyIHJlcG8vLmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdCAmJgoJCQlnaXQgLUMgcmVwbyBwYWNrLXJlZnMKCQkpICYmCgkJdGVzdF9leHBlY3RfcGVybXMgIiRleHBlY3QiIHJlcG8vLmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdCAmJgoJCWZvciB0YWJsZSBpbiByZXBvLy5naXQvcmVmdGFibGUvKi5yZWYKCQlkbwoJCQl0ZXN0X2V4cGVjdF9wZXJtcyAiJGV4cGVjdCIgIiR0YWJsZSIgfHwKCQkJcmV0dXJuIDEKCQlkb25lCgknCn0KCnRlc3RfZXhwZWN0X3JlZnRhYmxlX3Blcm1zIDAwMiB1bWFzayAiLXJ3LXJ3LXItLSIKdGVzdF9leHBlY3RfcmVmdGFibGVfcGVybXMgMDIyIHVtYXNrICItcnctci0tci0tIgp0ZXN0X2V4cGVjdF9yZWZ0YWJsZV9wZXJtcyAwMjcgdW1hc2sgIi1ydy1yLS0tLS0iCgp0ZXN0X2V4cGVjdF9yZWZ0YWJsZV9wZXJtcyAwMDIgZ3JvdXAgIi1ydy1ydy1yLS0iCnRlc3RfZXhwZWN0X3JlZnRhYmxlX3Blcm1zIDAyMiBncm91cCAiLXJ3LXJ3LXItLSIKdGVzdF9leHBlY3RfcmVmdGFibGVfcGVybXMgMDI3IGdyb3VwICItcnctcnctLS0tIgoKdGVzdF9leHBlY3RfcmVmdGFibGVfcGVybXMgMDAyIHdvcmxkICItcnctcnctci0tIgp0ZXN0X2V4cGVjdF9yZWZ0YWJsZV9wZXJtcyAwMjIgd29ybGQgIi1ydy1ydy1yLS0iCnRlc3RfZXhwZWN0X3JlZnRhYmxlX3Blcm1zIDAyNyB3b3JsZCAiLXJ3LXJ3LXItLSIKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ2Nsb25lOiBjYW4gY2xvbmUgcmVmdGFibGUgcmVwb3NpdG9yeScgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyBjbG9uZSIgJiYKCWdpdCBpbml0IHJlcG8gJiYKCXRlc3RfY29tbWl0IC1DIHJlcG8gbWVzc2FnZTEgZmlsZTEgJiYKCglnaXQgY2xvbmUgcmVwbyBjbG9uZWQgJiYKCWVjaG8gcmVmdGFibGUgPmV4cGVjdCAmJgoJZ2l0IC1DIGNsb25lZCByZXYtcGFyc2UgLS1zaG93LXJlZi1mb3JtYXQgPmFjdHVhbCAmJgoJdGVzdF9jbXAgZXhwZWN0IGFjdHVhbCAmJgoJdGVzdF9wYXRoX2lzX2ZpbGUgY2xvbmVkL2ZpbGUxCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ2Nsb25lOiBjYW4gY2xvbmUgcmVmZmlsZXMgaW50byByZWZ0YWJsZSByZXBvc2l0b3J5JyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZWZmaWxlcyByZWZ0YWJsZSIgJiYKCWdpdCBpbml0IC0tcmVmLWZvcm1hdD1maWxlcyByZWZmaWxlcyAmJgoJdGVzdF9jb21taXQgLUMgcmVmZmlsZXMgQSAmJgoJZ2l0IGNsb25lIC0tcmVmLWZvcm1hdD1yZWZ0YWJsZSAuL3JlZmZpbGVzIHJlZnRhYmxlICYmCgoJZ2l0IC1DIHJlZmZpbGVzIHJldi1wYXJzZSBIRUFEID5leHBlY3QgJiYKCWdpdCAtQyByZWZ0YWJsZSByZXYtcGFyc2UgSEVBRCA+YWN0dWFsICYmCgl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsICYmCgoJZ2l0IC1DIHJlZnRhYmxlIHJldi1wYXJzZSAtLXNob3ctcmVmLWZvcm1hdCA+YWN0dWFsICYmCgllY2hvIHJlZnRhYmxlID5leHBlY3QgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwgJiYKCglnaXQgLUMgcmVmZmlsZXMgcmV2LXBhcnNlIC0tc2hvdy1yZWYtZm9ybWF0ID5hY3R1YWwgJiYKCWVjaG8gZmlsZXMgPmV4cGVjdCAmJgoJdGVzdF9jbXAgZXhwZWN0IGFjdHVhbAonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdjbG9uZTogY2FuIGNsb25lIHJlZnRhYmxlIGludG8gcmVmZmlsZXMgcmVwb3NpdG9yeScgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVmZmlsZXMgcmVmdGFibGUiICYmCglnaXQgaW5pdCAtLXJlZi1mb3JtYXQ9cmVmdGFibGUgcmVmdGFibGUgJiYKCXRlc3RfY29tbWl0IC1DIHJlZnRhYmxlIEEgJiYKCWdpdCBjbG9uZSAtLXJlZi1mb3JtYXQ9ZmlsZXMgLi9yZWZ0YWJsZSByZWZmaWxlcyAmJgoKCWdpdCAtQyByZWZ0YWJsZSByZXYtcGFyc2UgSEVBRCA+ZXhwZWN0ICYmCglnaXQgLUMgcmVmZmlsZXMgcmV2LXBhcnNlIEhFQUQgPmFjdHVhbCAmJgoJdGVzdF9jbXAgZXhwZWN0IGFjdHVhbCAmJgoKCWdpdCAtQyByZWZ0YWJsZSByZXYtcGFyc2UgLS1zaG93LXJlZi1mb3JtYXQgPmFjdHVhbCAmJgoJZWNobyByZWZ0YWJsZSA+ZXhwZWN0ICYmCgl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsICYmCgoJZ2l0IC1DIHJlZmZpbGVzIHJldi1wYXJzZSAtLXNob3ctcmVmLWZvcm1hdCA+YWN0dWFsICYmCgllY2hvIGZpbGVzID5leHBlY3QgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncmVmIHRyYW5zYWN0aW9uOiBjb3JydXB0ZWQgdGFibGVzIGNhdXNlIGZhaWx1cmUnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgkoCgkJY2QgcmVwbyAmJgoJCXRlc3RfY29tbWl0IGZpbGUxICYmCgkJZm9yIGYgaW4gLmdpdC9yZWZ0YWJsZS8qLnJlZgoJCWRvCgkJCTogPiIkZiIgfHwgcmV0dXJuIDEKCQlkb25lICYmCgkJdGVzdF9tdXN0X2ZhaWwgZ2l0IHVwZGF0ZS1yZWYgcmVmcy9oZWFkcy9tYWluIEhFQUQKCSkKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncmVmIHRyYW5zYWN0aW9uOiBjb3JydXB0ZWQgdGFibGVzLmxpc3QgY2F1c2UgZmFpbHVyZScgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyIgJiYKCWdpdCBpbml0IHJlcG8gJiYKCSgKCQljZCByZXBvICYmCgkJdGVzdF9jb21taXQgZmlsZTEgJiYKCQllY2hvIGdhcmJhZ2UgPi5naXQvcmVmdGFibGUvdGFibGVzLmxpc3QgJiYKCQl0ZXN0X211c3RfZmFpbCBnaXQgdXBkYXRlLXJlZiByZWZzL2hlYWRzL21haW4gSEVBRAoJKQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdyZWYgdHJhbnNhY3Rpb246IHJlZnVzZXMgdG8gd3JpdGUgcmVmIGNhdXNpbmcgRi9EIGNvbmZsaWN0JyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJdGVzdF9jb21taXQgLUMgcmVwbyBmaWxlICYmCgl0ZXN0X211c3RfZmFpbCBnaXQgLUMgcmVwbyB1cGRhdGUtcmVmIHJlZnMvaGVhZHMvbWFpbi9mb3JiaWRkZW4KJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncmVmIHRyYW5zYWN0aW9uOiBkZWxldGluZyByZWYgd2l0aCBpbnZhbGlkIG5hbWUgZmFpbHMnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgl0ZXN0X2NvbW1pdCAtQyByZXBvIGZpbGUgJiYKCXRlc3RfbXVzdF9mYWlsIGdpdCAtQyByZXBvIHVwZGF0ZS1yZWYgLWQgLi4vLi4vbXktcHJpdmF0ZS1maWxlCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3JlZiB0cmFuc2FjdGlvbjogY2FuIHNraXAgb2JqZWN0IElEIHZlcmlmaWNhdGlvbicgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyIgJiYKCWdpdCBpbml0IHJlcG8gJiYKCXRlc3RfbXVzdF9mYWlsIHRlc3QtdG9vbCAtQyByZXBvIHJlZi1zdG9yZSBtYWluIHVwZGF0ZS1yZWYgbXNnIHJlZnMvaGVhZHMvYnJhbmNoICRJTlZBTElEX09JRCAkWkVST19PSUQgMCAmJgoJdGVzdC10b29sIC1DIHJlcG8gcmVmLXN0b3JlIG1haW4gdXBkYXRlLXJlZiBtc2cgcmVmcy9oZWFkcy9icmFuY2ggJElOVkFMSURfT0lEICRaRVJPX09JRCBSRUZfU0tJUF9PSURfVkVSSUZJQ0FUSU9OCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3JlZiB0cmFuc2FjdGlvbjogdXBkYXRpbmcgc2FtZSByZWYgbXVsdGlwbGUgdGltZXMgZmFpbHMnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgl0ZXN0X2NvbW1pdCAtQyByZXBvIEEgJiYKCWNhdCA+dXBkYXRlcyA8PC1FT0YgJiYKCXVwZGF0ZSByZWZzL2hlYWRzL21haW4gJEEKCXVwZGF0ZSByZWZzL2hlYWRzL21haW4gJEEKCUVPRgoJY2F0ID5leHBlY3QgPDwtRU9GICYmCglmYXRhbDogbXVsdGlwbGUgdXBkYXRlcyBmb3IgcmVmICR7U1F9cmVmcy9oZWFkcy9tYWluJHtTUX0gbm90IGFsbG93ZWQKCUVPRgoJdGVzdF9tdXN0X2ZhaWwgZ2l0IC1DIHJlcG8gdXBkYXRlLXJlZiAtLXN0ZGluIDx1cGRhdGVzIDI+ZXJyICYmCgl0ZXN0X2NtcCBleHBlY3QgZXJyCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3JlZiB0cmFuc2FjdGlvbjogY2FuIGRlbGV0ZSBzeW1ib2xpYyBzZWxmLXJlZmVyZW5jZSB3aXRoIGdpdC1zeW1ib2xpYy1yZWYoMSknICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCglnaXQgLUMgcmVwbyBzeW1ib2xpYy1yZWYgcmVmcy9oZWFkcy9zZWxmIHJlZnMvaGVhZHMvc2VsZiAmJgoJZ2l0IC1DIHJlcG8gc3ltYm9saWMtcmVmIC1kIHJlZnMvaGVhZHMvc2VsZgonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdyZWYgdHJhbnNhY3Rpb246IGRlbGV0aW5nIHN5bWJvbGljIHNlbGYtcmVmZXJlbmNlIHdpdGhvdXQgLS1uby1kZXJlZiBmYWlscycgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyIgJiYKCWdpdCBpbml0IHJlcG8gJiYKCWdpdCAtQyByZXBvIHN5bWJvbGljLXJlZiByZWZzL2hlYWRzL3NlbGYgcmVmcy9oZWFkcy9zZWxmICYmCgljYXQgPmV4cGVjdCA8PC1FT0YgJiYKCWVycm9yOiBtdWx0aXBsZSB1cGRhdGVzIGZvciAke1NRfXJlZnMvaGVhZHMvc2VsZiR7U1F9IChpbmNsdWRpbmcgb25lIHZpYSBzeW1yZWYgJHtTUX1yZWZzL2hlYWRzL3NlbGYke1NRfSkgYXJlIG5vdCBhbGxvd2VkCglFT0YKCXRlc3RfbXVzdF9mYWlsIGdpdCAtQyByZXBvIHVwZGF0ZS1yZWYgLWQgcmVmcy9oZWFkcy9zZWxmIDI+ZXJyICYmCgl0ZXN0X2NtcCBleHBlY3QgZXJyCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3JlZiB0cmFuc2FjdGlvbjogZGVsZXRpbmcgc3ltYm9saWMgc2VsZi1yZWZlcmVuY2Ugd2l0aCAtLW5vLWRlcmVmIHN1Y2NlZWRzJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJZ2l0IC1DIHJlcG8gc3ltYm9saWMtcmVmIHJlZnMvaGVhZHMvc2VsZiByZWZzL2hlYWRzL3NlbGYgJiYKCWdpdCAtQyByZXBvIHVwZGF0ZS1yZWYgLWQgLS1uby1kZXJlZiByZWZzL2hlYWRzL3NlbGYKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncmVmIHRyYW5zYWN0aW9uOiBjcmVhdGluZyBzeW1ib2xpYyByZWYgZmFpbHMgd2l0aCBGL0QgY29uZmxpY3QnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgl0ZXN0X2NvbW1pdCAtQyByZXBvIEEgJiYKCWNhdCA+ZXhwZWN0IDw8LUVPRiAmJgoJZXJyb3I6ICR7U1F9cmVmcy9oZWFkcy9tYWluJHtTUX0gZXhpc3RzOyBjYW5ub3QgY3JlYXRlICR7U1F9cmVmcy9oZWFkcyR7U1F9CglFT0YKCXRlc3RfbXVzdF9mYWlsIGdpdCAtQyByZXBvIHN5bWJvbGljLXJlZiByZWZzL2hlYWRzIHJlZnMvaGVhZHMvZm9vIDI+ZXJyICYmCgl0ZXN0X2NtcCBleHBlY3QgZXJyCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3JlZiB0cmFuc2FjdGlvbjogcmVmIGRlbGV0aW9uJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJKAoJCWNkIHJlcG8gJiYKCQl0ZXN0X2NvbW1pdCBmaWxlICYmCgkJSEVBRF9PSUQ9JChnaXQgc2hvdy1yZWYgLXMgLS12ZXJpZnkgSEVBRCkgJiYKCQljYXQgPmV4cGVjdCA8PC1FT0YgJiYKCQkkSEVBRF9PSUQgcmVmcy9oZWFkcy9tYWluCgkJJEhFQURfT0lEIHJlZnMvdGFncy9maWxlCgkJRU9GCgkJZ2l0IHNob3ctcmVmID5hY3R1YWwgJiYKCQl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsICYmCgoJCXRlc3RfbXVzdF9mYWlsIGdpdCB1cGRhdGUtcmVmIC1kIHJlZnMvdGFncy9maWxlICRJTlZBTElEX09JRCAmJgoJCWdpdCBzaG93LXJlZiA+YWN0dWFsICYmCgkJdGVzdF9jbXAgZXhwZWN0IGFjdHVhbCAmJgoKCQlnaXQgdXBkYXRlLXJlZiAtZCByZWZzL3RhZ3MvZmlsZSAkSEVBRF9PSUQgJiYKCQllY2hvICIkSEVBRF9PSUQgcmVmcy9oZWFkcy9tYWluIiA+ZXhwZWN0ICYmCgkJZ2l0IHNob3ctcmVmID5hY3R1YWwgJiYKCQl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsCgkpCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3JlZiB0cmFuc2FjdGlvbjogd3JpdGVzIGNhdXNlIGF1dG8tY29tcGFjdGlvbicgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyIgJiYKCglnaXQgaW5pdCByZXBvICYmCgl0ZXN0X2xpbmVfY291bnQgPSAxIHJlcG8vLmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdCAmJgoKCXRlc3RfY29tbWl0IC1DIHJlcG8gLS1uby10YWcgQSAmJgoJdGVzdF9saW5lX2NvdW50ID0gMSByZXBvLy5naXQvcmVmdGFibGUvdGFibGVzLmxpc3QgJiYKCgl0ZXN0X2NvbW1pdCAtQyByZXBvIC0tbm8tdGFnIEIgJiYKCXRlc3RfbGluZV9jb3VudCA9IDEgcmVwby8uZ2l0L3JlZnRhYmxlL3RhYmxlcy5saXN0CicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3JlZiB0cmFuc2FjdGlvbjogZW52IHZhciBkaXNhYmxlcyBjb21wYWN0aW9uJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoKCWdpdCBpbml0IHJlcG8gJiYKCXRlc3RfY29tbWl0IC1DIHJlcG8gQSAmJgoKCXN0YXJ0PSQod2MgLWwgPHJlcG8vLmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdCkgJiYKCWl0ZXJhdGlvbnM9NSAmJgoJZXhwZWN0ZWQ9JCgoc3RhcnQgKyBpdGVyYXRpb25zKSkgJiYKCglmb3IgaSBpbiAkKHRlc3Rfc2VxICRpdGVyYXRpb25zKQoJZG8KCQlHSVRfVEVTVF9SRUZUQUJMRV9BVVRPQ09NUEFDVElPTj1mYWxzZSBcCgkJZ2l0IC1DIHJlcG8gdXBkYXRlLXJlZiBicmFuY2gtJGkgSEVBRCB8fCByZXR1cm4gMQoJZG9uZSAmJgoJdGVzdF9saW5lX2NvdW50ID0gJGV4cGVjdGVkIHJlcG8vLmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdCAmJgoKCWdpdCAtQyByZXBvIHVwZGF0ZS1yZWYgZm9vIEhFQUQgJiYKCXRlc3RfbGluZV9jb3VudCAtbHQgJGV4cGVjdGVkIHJlcG8vLmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdAonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdyZWYgdHJhbnNhY3Rpb246IGFsdGVybmF0aW5nIHRhYmxlIHNpemVzIGFyZSBjb21wYWN0ZWQnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCgoJZ2l0IGluaXQgcmVwbyAmJgoJdGVzdF9jb21taXQgLUMgcmVwbyBBICYmCglmb3IgaSBpbiAkKHRlc3Rfc2VxIDUpCglkbwoJCWdpdCAtQyByZXBvIGJyYW5jaCAtZiBmb28gJiYKCQlnaXQgLUMgcmVwbyBicmFuY2ggLWQgZm9vIHx8IHJldHVybiAxCglkb25lICYmCgl0ZXN0X2xpbmVfY291bnQgPSAyIHJlcG8vLmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdAonCgpjaGVja19mc3luY19ldmVudHMgKCkgewoJbG9jYWwgdHJhY2U9IiQxIiAmJgoJc2hpZnQgJiYKCgljYXQgPmV4cGVjdCAmJgoJc2VkIC1uIFwKCQktZSAnL157ImV2ZW50IjoiY291bnRlciIsLioiY2F0ZWdvcnkiOiJmc3luYyIsLyB7CgkJCXMvLioiY2F0ZWdvcnkiOiJmc3luYyIsLy87CgkJCXMvfSQvLzsKCQkJcDsKCQl9JyBcCgkJPCIkdHJhY2UiID5hY3R1YWwgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwKfQoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncmVmIHRyYW5zYWN0aW9uOiB3cml0ZXMgYXJlIHN5bmNlZCcgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyIgJiYKCWdpdCBpbml0IHJlcG8gJiYKCXRlc3RfY29tbWl0IC1DIHJlcG8gaW5pdGlhbCAmJgoKCUdJVF9UUkFDRTJfRVZFTlQ9IiQocHdkKS90cmFjZTIudHh0IiBcCglHSVRfVEVTVF9GU1lOQz10cnVlIFwKCQlnaXQgLUMgcmVwbyAtYyBjb3JlLmZzeW5jPXJlZmVyZW5jZSBcCgkJLWMgY29yZS5mc3luY01ldGhvZD1mc3luYyB1cGRhdGUtcmVmIHJlZnMvaGVhZHMvYnJhbmNoIEhFQUQgJiYKCWNoZWNrX2ZzeW5jX2V2ZW50cyB0cmFjZTIudHh0IDw8LUVPRgoJIm5hbWUiOiJoYXJkd2FyZS1mbHVzaCIsImNvdW50Ijo0CglFT0YKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncmVmIHRyYW5zYWN0aW9uOiBlbXB0eSB0cmFuc2FjdGlvbiBpbiBlbXB0eSByZXBvJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJdGVzdF9jb21taXQgLUMgcmVwbyAtLW5vLXRhZyBBICYmCglnaXQgLUMgcmVwbyB1cGRhdGUtcmVmIC1kIHJlZnMvaGVhZHMvbWFpbiAmJgoJdGVzdC10b29sIC1DIHJlcG8gcmVmLXN0b3JlIG1haW4gZGVsZXRlLXJlZnMgUkVGX05PX0RFUkVGIG1zZyBIRUFEICYmCglnaXQgLUMgcmVwbyB1cGRhdGUtcmVmIC0tc3RkaW4gPDwtRU9GCglwcmVwYXJlCgljb21taXQKCUVPRgonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdyZWYgdHJhbnNhY3Rpb246IGZhaWxzIGdyYWNlZnVsbHkgd2hlbiBhdXRvIGNvbXBhY3Rpb24gZmFpbHMnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgkoCgkJY2QgcmVwbyAmJgoKCQl0ZXN0X2NvbW1pdCBBICYmCgkJZm9yIGkgaW4gJCh0ZXN0X3NlcSAxMCkKCQlkbwoJCQlnaXQgYnJhbmNoIGJyYW5jaC0kaSAmJgoJCQlmb3IgdGFibGUgaW4gLmdpdC9yZWZ0YWJsZS8qLnJlZgoJCQlkbwoJCQkJdG91Y2ggIiR0YWJsZS5sb2NrIiB8fCBleGl0IDEKCQkJZG9uZSB8fAoJCQlleGl0IDEKCQlkb25lICYmCgkJdGVzdF9saW5lX2NvdW50ID0gMTAgLmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdAoJKQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdyZWYgdHJhbnNhY3Rpb246IHRpbWVvdXQgYWNxdWlyaW5nIHRhYmxlcy5saXN0IGxvY2snICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgkoCgkJY2QgcmVwbyAmJgoJCXRlc3RfY29tbWl0IGluaXRpYWwgJiYKCQk+LmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdC5sb2NrICYmCgkJdGVzdF9tdXN0X2ZhaWwgZ2l0IHVwZGF0ZS1yZWYgcmVmcy9oZWFkcy9icmFuY2ggSEVBRCAyPmVyciAmJgoJCXRlc3RfZ3JlcCAiY2Fubm90IGxvY2sgcmVmZXJlbmNlcyIgZXJyCgkpCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3JlZiB0cmFuc2FjdGlvbjogcmV0cnkgYWNxdWlyaW5nIHRhYmxlcy5saXN0IGxvY2snICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgkoCgkJY2QgcmVwbyAmJgoJCXRlc3RfY29tbWl0IGluaXRpYWwgJiYKCQlMT0NLPS5naXQvcmVmdGFibGUvdGFibGVzLmxpc3QubG9jayAmJgoJCT4kTE9DSyAmJgoJCXsKCQkJKCBzbGVlcCAxICYmIHJtIC1mICRMT0NLICkgJgoJCX0gJiYKCQlnaXQgLWMgcmVmdGFibGUubG9ja1RpbWVvdXQ9NTAwMCB1cGRhdGUtcmVmIHJlZnMvaGVhZHMvYnJhbmNoIEhFQUQKCSkKJwoKIyBUaGlzIHRlc3QgZmFpbHMgbW9zdCBvZiB0aGUgdGltZSBvbiBDeWd3aW4gc3lzdGVtcy4gVGhlIHJvb3QgY2F1c2UgaXMKIyB0aGF0IFdpbmRvd3MgZG9lcyBub3QgYWxsb3cgdXMgdG8gcmVuYW1lIHRoZSAidGFibGVzLmxpc3QubG9jayIgZmlsZSBpbnRvCiMgcGxhY2Ugd2hlbiAidGFibGVzLmxpc3QiIGlzIG9wZW4gZm9yIHJlYWRpbmcgYnkgYSBjb25jdXJyZW50IHByb2Nlc3MuIFdlIGhhdmUKIyB3b3JrZWQgYXJvdW5kIHRoYXQgaW4gb3VyIE1pbkdXLWJhc2VkIHJlbmFtZSBlbXVsYXRpb24sIGJ1dCB0aGUgQ3lnd2luCiMgZW11bGF0aW9uIHNlZW1zIHRvIGJlIGluc3VmZmljaWVudC4KdGVzdF9leHBlY3Rfc3VjY2VzcyAhQ1lHV0lOICdyZWYgdHJhbnNhY3Rpb246IG1hbnkgY29uY3VycmVudCB3cml0ZXJzJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJKAoJCWNkIHJlcG8gJiYKCQkjIFNldCBhIGhpZ2ggdGltZW91dC4gV2hpbGUgYSBjb3VwbGUgb2Ygc2Vjb25kcyBzaG91bGQgYmUKCQkjIHBsZW50eSwgdXNpbmcgdGhlIGFkZHJlc3Mgc2FuaXRpemVyIHdpbGwgc2lnbmlmaWNhbnRseSBzbG93CgkJIyB1cyBkb3duIGhlcmUuIFNvIHdlIGFyZSBhaW1pbmcgd2F5IGhpZ2hlciB0aGFuIHlvdSB3b3VsZCBldmVyCgkJIyB0aGluayBpcyBuZWNlc3NhcnkganVzdCB0byBrZWVwIHVzIGZyb20gZmxha2luZy4gV2UgY291bGQKCQkjIGFsc28gbG9jayBpbmRlZmluaXRlbHkgYnkgcGFzc2luZyAtMSwgYnV0IHRoYXQgY291bGQKCQkjIHBvdGVudGlhbGx5IGJsb2NrIENJIGpvYnMgaW5kZWZpbml0ZWx5IGlmIHRoZXJlIHdhcyBhIGJ1ZwoJCSMgaGVyZS4KCQlnaXQgY29uZmlnIHNldCByZWZ0YWJsZS5sb2NrVGltZW91dCAzMDAwMDAgJiYKCQl0ZXN0X2NvbW1pdCAtLW5vLXRhZyBpbml0aWFsICYmCgoJCWhlYWQ9JChnaXQgcmV2LXBhcnNlIEhFQUQpICYmCgkJZm9yIGkgaW4gJCh0ZXN0X3NlcSAxMDApCgkJZG8KCQkJcHJpbnRmICIlcyBjb21taXRcdHJlZnMvaGVhZHMvYnJhbmNoLSVzXG4iICIkaGVhZCIgIiRpIiB8fAoJCQlyZXR1cm4gMQoJCWRvbmUgPmV4cGVjdCAmJgoJCXByaW50ZiAiJXMgY29tbWl0XHRyZWZzL2hlYWRzL21haW5cbiIgIiRoZWFkIiA+PmV4cGVjdCAmJgoKCQlmb3IgaSBpbiAkKHRlc3Rfc2VxIDEwMCkKCQlkbwoJCQl7IGdpdCB1cGRhdGUtcmVmIHJlZnMvaGVhZHMvYnJhbmNoLSRpIEhFQUQmIH0gfHwKCQkJcmV0dXJuIDEKCQlkb25lICYmCgoJCXdhaXQgJiYKCQlnaXQgZm9yLWVhY2gtcmVmIC0tc29ydD12OnJlZm5hbWUgPmFjdHVhbCAmJgoJCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwKCSkKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncGFjay1yZWZzOiBjb21wYWN0cyB0YWJsZXMnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgoJdGVzdF9jb21taXQgLUMgcmVwbyBBICYmCglscyAtMSByZXBvLy5naXQvcmVmdGFibGUgPnRhYmxlLWZpbGVzICYmCgl0ZXN0X2xpbmVfY291bnQgPSAzIHRhYmxlLWZpbGVzICYmCgl0ZXN0X2xpbmVfY291bnQgPSAyIHJlcG8vLmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdCAmJgoKCWdpdCAtQyByZXBvIHBhY2stcmVmcyAmJgoJbHMgLTEgcmVwby8uZ2l0L3JlZnRhYmxlID50YWJsZS1maWxlcyAmJgoJdGVzdF9saW5lX2NvdW50ID0gMiB0YWJsZS1maWxlcyAmJgoJdGVzdF9saW5lX2NvdW50ID0gMSByZXBvLy5naXQvcmVmdGFibGUvdGFibGVzLmxpc3QKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncGFjay1yZWZzOiBjb21wYWN0aW9uIHJhaXNlcyBsb2NraW5nIGVycm9ycycgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyIgJiYKCWdpdCBpbml0IHJlcG8gJiYKCXRlc3RfY29tbWl0IC1DIHJlcG8gQSAmJgoJdG91Y2ggcmVwby8uZ2l0L3JlZnRhYmxlL3RhYmxlcy5saXN0LmxvY2sgJiYKCWNhdCA+ZXhwZWN0IDw8LUVPRiAmJgoJZXJyb3I6IHVuYWJsZSB0byBjb21wYWN0IHN0YWNrOiBkYXRhIGlzIGxvY2tlZAoJRU9GCgl0ZXN0X211c3RfZmFpbCBnaXQgLUMgcmVwbyBwYWNrLXJlZnMgMj5lcnIgJiYKCXRlc3RfY21wIGV4cGVjdCBlcnIKJwoKZm9yIGNvbW1hbmQgaW4gcGFjay1yZWZzIGdjICJtYWludGVuYW5jZSBydW4gLS10YXNrPXBhY2stcmVmcyIKZG8KdGVzdF9leHBlY3Rfc3VjY2VzcyAiJGNvbW1hbmQ6IGF1dG8gY29tcGFjdGlvbiIgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyIgJiYKCWdpdCBpbml0IHJlcG8gJiYKCSgKCQljZCByZXBvICYmCgoJCXRlc3RfY29tbWl0IEEgJiYKCgkJIyBXZSBuZWVkIGEgYml0IG9mIHNldHVwIHRvIGVuc3VyZSB0aGF0IGdpdC1nYygxKSBhY3R1YWxseQoJCSMgdHJpZ2dlcnMsIGFuZCB0aGF0IGl0IGRvZXMgbm90IHdyaXRlIGFueXRoaW5nIHRvIHRoZSByZWZkYi4KCQlnaXQgY29uZmlnIGdjLmF1dG8gMSAmJgoJCWdpdCBjb25maWcgZ2MuYXV0b0RldGFjaCAwICYmCgkJZ2l0IGNvbmZpZyBnYy5yZWZsb2dFeHBpcmUgbmV2ZXIgJiYKCQlnaXQgY29uZmlnIGdjLnJlZmxvZ0V4cGlyZVVucmVhY2hhYmxlIG5ldmVyICYmCgkJdGVzdF9vaWQgYmxvYjE3XzEgfCBnaXQgaGFzaC1vYmplY3QgLXcgLS1zdGRpbiAmJgoKCQkjIFRoZSB0YWJsZXMgc2hvdWxkIGhhdmUgYmVlbiBhdXRvLWNvbXBhY3RlZCwgYW5kIHRodXMgYXV0bwoJCSMgY29tcGFjdGlvbiBzaG91bGQgbm90IGhhdmUgdG8gZG8gYW55dGhpbmcuCgkJbHMgLTEgLmdpdC9yZWZ0YWJsZSA+dGFibGVzLWV4cGVjdCAmJgoJCXRlc3RfbGluZV9jb3VudCA9IDMgdGFibGVzLWV4cGVjdCAmJgoJCWdpdCAkY29tbWFuZCAtLWF1dG8gJiYKCQlscyAtMSAuZ2l0L3JlZnRhYmxlID50YWJsZXMtYWN0dWFsICYmCgkJdGVzdF9jbXAgdGFibGVzLWV4cGVjdCB0YWJsZXMtYWN0dWFsICYmCgoJCXRlc3Rfb2lkIGJsb2IxN18yIHwgZ2l0IGhhc2gtb2JqZWN0IC13IC0tc3RkaW4gJiYKCgkJIyBMb2NrIGFsbCB0YWJsZXMsIHdyaXRlIHNvbWUgcmVmcy4gQXV0by1jb21wYWN0aW9uIHdpbGwgYmUKCQkjIHVuYWJsZSB0byBjb21wYWN0IHRhYmxlcyBhbmQgdGh1cyBmYWlscyBncmFjZWZ1bGx5LAoJCSMgY29tcGFjdGluZyBvbmx5IHRob3NlIHRhYmxlcyB3aGljaCBhcmUgbm90IGxvY2tlZC4KCQlscyAuZ2l0L3JlZnRhYmxlLyoucmVmIHwgc29ydCB8CgkJd2hpbGUgcmVhZCB0YWJsZQoJCWRvCgkJCXRvdWNoICIkdGFibGUubG9jayIgJiYKCQkJYmFzZW5hbWUgIiR0YWJsZSIgPj50YWJsZXMuZXhwZWN0IHx8IGV4aXQgMQoJCWRvbmUgJiYKCQl0ZXN0X2xpbmVfY291bnQgPSAyIC5naXQvcmVmdGFibGUvdGFibGVzLmxpc3QgJiYKCQlnaXQgYnJhbmNoIEIgJiYKCQlnaXQgYnJhbmNoIEMgJiYKCgkJIyBUaGUgbmV3IHRhYmxlcyBhcmUgYXV0by1jb21wYWN0ZWQsIGJ1dCB0aGUgbG9ja2VkIHRhYmxlcyBhcmUKCQkjIGxlZnQgaW50YWN0LgoJCXRlc3RfbGluZV9jb3VudCA9IDMgLmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdCAmJgoJCWhlYWQgLW4gMiAuZ2l0L3JlZnRhYmxlL3RhYmxlcy5saXN0ID50YWJsZXMuaGVhZCAmJgoJCXRlc3RfY21wIHRhYmxlcy5leHBlY3QgdGFibGVzLmhlYWQgJiYKCgkJcm0gLmdpdC9yZWZ0YWJsZS8qLmxvY2sgJiYKCQlnaXQgJGNvbW1hbmQgLS1hdXRvICYmCgkJdGVzdF9saW5lX2NvdW50ID0gMSAuZ2l0L3JlZnRhYmxlL3RhYmxlcy5saXN0CgkpCicKZG9uZQoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncGFjay1yZWZzOiBwcnVuZXMgc3RhbGUgdGFibGVzJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJdG91Y2ggcmVwby8uZ2l0L3JlZnRhYmxlL3N0YWxlLXRhYmxlLnJlZiAmJgoJZ2l0IC1DIHJlcG8gcGFjay1yZWZzICYmCgl0ZXN0X3BhdGhfaXNfbWlzc2luZyByZXBvLy5naXQvcmVmdGFibGUvc3RhYmxlLXJlZi5yZWYKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncGFjay1yZWZzOiBkb2VzIG5vdCBwcnVuZSBub24tdGFibGUgZmlsZXMnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgl0b3VjaCByZXBvLy5naXQvcmVmdGFibGUvZ2FyYmFnZSAmJgoJZ2l0IC1DIHJlcG8gcGFjay1yZWZzICYmCgl0ZXN0X3BhdGhfaXNfZmlsZSByZXBvLy5naXQvcmVmdGFibGUvZ2FyYmFnZQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdwYWNrZWQtcmVmczogd3JpdGVzIGFyZSBzeW5jZWQnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgl0ZXN0X2NvbW1pdCAtQyByZXBvIGluaXRpYWwgJiYKCXRlc3RfbGluZV9jb3VudCA9IDIgdGFibGUtZmlsZXMgJiYKCgk6ID50cmFjZTIudHh0ICYmCglHSVRfVFJBQ0UyX0VWRU5UPSIkKHB3ZCkvdHJhY2UyLnR4dCIgXAoJR0lUX1RFU1RfRlNZTkM9dHJ1ZSBcCgkJZ2l0IC1DIHJlcG8gLWMgY29yZS5mc3luYz1yZWZlcmVuY2UgXAoJCS1jIGNvcmUuZnN5bmNNZXRob2Q9ZnN5bmMgcGFjay1yZWZzICYmCgljaGVja19mc3luY19ldmVudHMgdHJhY2UyLnR4dCA8PC1FT0YKCSJuYW1lIjoiaGFyZHdhcmUtZmx1c2giLCJjb3VudCI6MgoJRU9GCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3JlZiBpdGVyYXRvcjogYm9ndXMgbmFtZXMgYXJlIGZsYWdnZWQnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgkoCgkJY2QgcmVwbyAmJgoJCXRlc3RfY29tbWl0IC0tbm8tdGFnIGZpbGUgJiYKCQl0ZXN0LXRvb2wgcmVmLXN0b3JlIG1haW4gdXBkYXRlLXJlZiBtc2cgInJlZnMvaGVhZHMvYm9ndXMuLm5hbWUiICQoZ2l0IHJldi1wYXJzZSBIRUFEKSAkWkVST19PSUQgUkVGX1NLSVBfUkVGTkFNRV9WRVJJRklDQVRJT04gJiYKCgkJY2F0ID5leHBlY3QgPDwtRU9GICYmCgkJJFpFUk9fT0lEIHJlZnMvaGVhZHMvYm9ndXMuLm5hbWUgMHhjCgkJJChnaXQgcmV2LXBhcnNlIEhFQUQpIHJlZnMvaGVhZHMvbWFpbiAweDAKCQlFT0YKCQl0ZXN0LXRvb2wgcmVmLXN0b3JlIG1haW4gZm9yLWVhY2gtcmVmICIiID5hY3R1YWwgJiYKCQl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsCgkpCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3JlZiBpdGVyYXRvcjogbWlzc2luZyBvYmplY3QgSURzIGFyZSBub3QgZmxhZ2dlZCcgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyIgJiYKCWdpdCBpbml0IHJlcG8gJiYKCSgKCQljZCByZXBvICYmCgkJdGVzdC10b29sIHJlZi1zdG9yZSBtYWluIHVwZGF0ZS1yZWYgbXNnICJyZWZzL2hlYWRzL2Jyb2tlbi1oYXNoIiAkSU5WQUxJRF9PSUQgJFpFUk9fT0lEIFJFRl9TS0lQX09JRF9WRVJJRklDQVRJT04gJiYKCgkJY2F0ID5leHBlY3QgPDwtRU9GICYmCgkJJElOVkFMSURfT0lEIHJlZnMvaGVhZHMvYnJva2VuLWhhc2ggMHgwCgkJRU9GCgkJdGVzdC10b29sIHJlZi1zdG9yZSBtYWluIGZvci1lYWNoLXJlZiAiIiA+YWN0dWFsICYmCgkJdGVzdF9jbXAgZXhwZWN0IGFjdHVhbAoJKQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdiYXNpYzogY29tbWl0IGFuZCBsaXN0IHJlZnMnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgl0ZXN0X2NvbW1pdCAtQyByZXBvIGZpbGUgJiYKCXRlc3Rfd3JpdGVfbGluZXMgcmVmcy9oZWFkcy9tYWluIHJlZnMvdGFncy9maWxlID5leHBlY3QgJiYKCWdpdCAtQyByZXBvIGZvci1lYWNoLXJlZiAtLWZvcm1hdD0iJShyZWZuYW1lKSIgPmFjdHVhbCAmJgoJdGVzdF9jbXAgYWN0dWFsIGV4cGVjdAonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdiYXNpYzogY2FuIHdyaXRlIGxhcmdlIGNvbW1pdCBtZXNzYWdlJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJcGVybCAtZSAiCgkJcHJpbnQgXCJ0aGlzIGlzIGEgbG9uZyBjb21taXQgbWVzc2FnZVwiIHggNTAwMDAKCSIgPmNvbW1pdC1tc2cgJiYKCWdpdCAtQyByZXBvIGNvbW1pdCAtLWFsbG93LWVtcHR5IC0tZmlsZT0uLi9jb21taXQtbXNnCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ2Jhc2ljOiBzaG93LXJlZiBmYWlscyB3aXRoIGVtcHR5IHJlcG9zaXRvcnknICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgl0ZXN0X211c3RfZmFpbCBnaXQgLUMgcmVwbyBzaG93LXJlZiA+YWN0dWFsICYmCgl0ZXN0X211c3RfYmVfZW1wdHkgYWN0dWFsCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ2Jhc2ljOiBjYW4gY2hlY2sgb3V0IHVuYm9ybiBicmFuY2gnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCglnaXQgLUMgcmVwbyBjaGVja291dCAtYiBtYWluCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ2Jhc2ljOiBwZWVsZWQgdGFncyBhcmUgc3RvcmVkJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJdGVzdF9jb21taXQgLUMgcmVwbyBmaWxlICYmCglnaXQgLUMgcmVwbyB0YWcgLW0gImFubm90YXRlZCB0YWciIHRlc3RfdGFnIEhFQUQgJiYKCWZvciByZWYgaW4gcmVmcy9oZWFkcy9tYWluIHJlZnMvdGFncy9maWxlIHJlZnMvdGFncy90ZXN0X3RhZyByZWZzL3RhZ3MvdGVzdF90YWdee30KCWRvCgkJZWNobyAiJChnaXQgLUMgcmVwbyByZXYtcGFyc2UgIiRyZWYiKSAkcmVmIiB8fCByZXR1cm4gMQoJZG9uZSA+ZXhwZWN0ICYmCglnaXQgLUMgcmVwbyBzaG93LXJlZiAtZCA+YWN0dWFsICYmCgl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ2Jhc2ljOiBmb3ItZWFjaC1yZWYgY2FuIHByaW50IHN5bXJlZnMnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgkoCgkJY2QgcmVwbyAmJgoJCXRlc3RfY29tbWl0IGZpbGUgJiYKCQlnaXQgYnJhbmNoICYmCgkJZ2l0IHN5bWJvbGljLXJlZiByZWZzL2hlYWRzL3N5bSByZWZzL2hlYWRzL21haW4gJiYKCQljYXQgPmV4cGVjdGVkIDw8LUVPRiAmJgoJCXJlZnMvaGVhZHMvbWFpbgoJCUVPRgoJCWdpdCBmb3ItZWFjaC1yZWYgLS1mb3JtYXQ9IiUoc3ltcmVmKSIgcmVmcy9oZWFkcy9zeW0gPmFjdHVhbCAmJgoJCXRlc3RfY21wIGV4cGVjdGVkIGFjdHVhbAoJKQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdiYXNpYzogbm90ZXMnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgkoCgkJd3JpdGVfc2NyaXB0IGZha2VfZWRpdG9yIDw8LVxFT0YgJiYKCQllY2hvICIkTVNHIiA+IiQxIgoJCWVjaG8gIiRNU0ciID4mMgoJCUVPRgoKCQl0ZXN0X2NvbW1pdCAxc3QgJiYKCQl0ZXN0X2NvbW1pdCAybmQgJiYKCQlHSVRfRURJVE9SPS4vZmFrZV9lZGl0b3IgTVNHPWI0IGdpdCBub3RlcyBhZGQgJiYKCQlHSVRfRURJVE9SPS4vZmFrZV9lZGl0b3IgTVNHPWIzIGdpdCBub3RlcyBlZGl0ICYmCgkJZWNobyBiNCA+ZXhwZWN0ICYmCgkJZ2l0IG5vdGVzIC0tcmVmIGNvbW1pdHNAezF9IHNob3cgPmFjdHVhbCAmJgoJCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwKCSkKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnYmFzaWM6IHN0YXNoJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJKAoJCWNkIHJlcG8gJiYKCQl0ZXN0X2NvbW1pdCBmaWxlICYmCgkJZ2l0IHN0YXNoIGxpc3QgPmV4cGVjdCAmJgoJCXRlc3RfbGluZV9jb3VudCA9IDAgZXhwZWN0ICYmCgoJCWVjaG8gaG9pID4+ZmlsZS50ICYmCgkJZ2l0IHN0YXNoIHB1c2ggLW0gc3Rhc2hlZCAmJgoJCWdpdCBzdGFzaCBsaXN0ID5leHBlY3QgJiYKCQl0ZXN0X2xpbmVfY291bnQgPSAxIGV4cGVjdCAmJgoKCQlnaXQgc3Rhc2ggY2xlYXIgJiYKCQlnaXQgc3Rhc2ggbGlzdCA+ZXhwZWN0ICYmCgkJdGVzdF9saW5lX2NvdW50ID0gMCBleHBlY3QKCSkKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnYmFzaWM6IGNoZXJyeS1waWNrJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJKAoJCWNkIHJlcG8gJiYKCQl0ZXN0X2NvbW1pdCBtZXNzYWdlMSBmaWxlMSAmJgoJCXRlc3RfY29tbWl0IG1lc3NhZ2UyIGZpbGUyICYmCgkJZ2l0IGJyYW5jaCBzb3VyY2UgJiYKCQlnaXQgY2hlY2tvdXQgSEVBRF4gJiYKCQl0ZXN0X2NvbW1pdCBtZXNzYWdlMyBmaWxlMyAmJgoJCWdpdCBjaGVycnktcGljayBzb3VyY2UgJiYKCQl0ZXN0X3BhdGhfaXNfZmlsZSBmaWxlMgoJKQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdiYXNpYzogcmViYXNlJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJKAoJCWNkIHJlcG8gJiYKCQl0ZXN0X2NvbW1pdCBtZXNzYWdlMSBmaWxlMSAmJgoJCXRlc3RfY29tbWl0IG1lc3NhZ2UyIGZpbGUyICYmCgkJZ2l0IGJyYW5jaCBzb3VyY2UgJiYKCQlnaXQgY2hlY2tvdXQgSEVBRF4gJiYKCQl0ZXN0X2NvbW1pdCBtZXNzYWdlMyBmaWxlMyAmJgoJCWdpdCByZWJhc2Ugc291cmNlICYmCgkJdGVzdF9wYXRoX2lzX2ZpbGUgZmlsZTIKCSkKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncmVmbG9nOiBjYW4gZGVsZXRlIHNlcGFyYXRlIHJlZmxvZyBlbnRyaWVzJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJKAoJCWNkIHJlcG8gJiYKCgkJdGVzdF9jb21taXQgZmlsZSAmJgoJCXRlc3RfY29tbWl0IGZpbGUyICYmCgkJdGVzdF9jb21taXQgZmlsZTMgJiYKCQl0ZXN0X2NvbW1pdCBmaWxlNCAmJgoJCWdpdCByZWZsb2cgPmFjdHVhbCAmJgoJCWdyZXAgZmlsZTMgYWN0dWFsICYmCgoJCWdpdCByZWZsb2cgZGVsZXRlIEhFQURAezF9ICYmCgkJZ2l0IHJlZmxvZyA+YWN0dWFsICYmCgkJISBncmVwIGZpbGUzIGFjdHVhbAoJKQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdyZWZsb2c6IGNhbiBzd2l0Y2ggdG8gcHJldmlvdXMgYnJhbmNoJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJKAoJCWNkIHJlcG8gJiYKCQl0ZXN0X2NvbW1pdCBmaWxlMSAmJgoJCWdpdCBjaGVja291dCAtYiBicmFuY2gxICYmCgkJdGVzdF9jb21taXQgZmlsZTIgJiYKCQlnaXQgY2hlY2tvdXQgLWIgYnJhbmNoMiAmJgoJCWdpdCBzd2l0Y2ggLSAmJgoJCWdpdCByZXYtcGFyc2UgLS1zeW1ib2xpYy1mdWxsLW5hbWUgSEVBRCA+YWN0dWFsICYmCgkJZWNobyByZWZzL2hlYWRzL2JyYW5jaDEgPmV4cGVjdCAmJgoJCXRlc3RfY21wIGFjdHVhbCBleHBlY3QKCSkKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncmVmbG9nOiBjb3B5aW5nIGJyYW5jaCB3cml0ZXMgcmVmbG9nIGVudHJ5JyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJKAoJCWNkIHJlcG8gJiYKCQl0ZXN0X2NvbW1pdCBmaWxlMSAmJgoJCXRlc3RfY29tbWl0IGZpbGUyICYmCgkJb2lkPSQoZ2l0IHJldi1wYXJzZSAtLXNob3J0IEhFQUQpICYmCgkJZ2l0IGJyYW5jaCBzcmMgJiYKCQljYXQgPmV4cGVjdCA8PC1FT0YgJiYKCQkke29pZH0gZHN0QHswfTogQnJhbmNoOiBjb3BpZWQgcmVmcy9oZWFkcy9zcmMgdG8gcmVmcy9oZWFkcy9kc3QKCQkke29pZH0gZHN0QHsxfTogYnJhbmNoOiBDcmVhdGVkIGZyb20gbWFpbgoJCUVPRgoJCWdpdCBicmFuY2ggLWMgc3JjIGRzdCAmJgoJCWdpdCByZWZsb2cgZHN0ID5hY3R1YWwgJiYKCQl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsCgkpCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3JlZmxvZzogcmVuYW1pbmcgYnJhbmNoIHdyaXRlcyByZWZsb2cgZW50cnknICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgkoCgkJY2QgcmVwbyAmJgoJCWdpdCBzeW1ib2xpYy1yZWYgSEVBRCByZWZzL2hlYWRzL2JlZm9yZSAmJgoJCXRlc3RfY29tbWl0IGZpbGUgJiYKCQlnaXQgc2hvdy1yZWYgPmV4cGVjdGVkLnJlZnMgJiYKCQlzZWQgcy9iZWZvcmUvYWZ0ZXIvZyA8ZXhwZWN0ZWQucmVmcyA+ZXhwZWN0ZWQgJiYKCQlnaXQgYnJhbmNoIC1NIGFmdGVyICYmCgkJZ2l0IHNob3ctcmVmID5hY3R1YWwgJiYKCQl0ZXN0X2NtcCBleHBlY3RlZCBhY3R1YWwgJiYKCQllY2hvIHJlZnMvaGVhZHMvYWZ0ZXIgPmV4cGVjdGVkICYmCgkJZ2l0IHN5bWJvbGljLXJlZiBIRUFEID5hY3R1YWwgJiYKCQl0ZXN0X2NtcCBleHBlY3RlZCBhY3R1YWwKCSkKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncmVmbG9nOiBjYW4gc3RvcmUgZW1wdHkgbG9ncycgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyIgJiYKCWdpdCBpbml0IHJlcG8gJiYKCSgKCQljZCByZXBvICYmCgoJCXRlc3RfbXVzdF9mYWlsIHRlc3QtdG9vbCByZWYtc3RvcmUgbWFpbiByZWZsb2ctZXhpc3RzIHJlZnMvaGVhZHMvYnJhbmNoICYmCgkJdGVzdC10b29sIHJlZi1zdG9yZSBtYWluIGNyZWF0ZS1yZWZsb2cgcmVmcy9oZWFkcy9icmFuY2ggJiYKCQl0ZXN0LXRvb2wgcmVmLXN0b3JlIG1haW4gcmVmbG9nLWV4aXN0cyByZWZzL2hlYWRzL2JyYW5jaCAmJgoJCXRlc3QtdG9vbCByZWYtc3RvcmUgbWFpbiBmb3ItZWFjaC1yZWZsb2ctZW50LXJldmVyc2UgcmVmcy9oZWFkcy9icmFuY2ggPmFjdHVhbCAmJgoJCXRlc3RfbXVzdF9iZV9lbXB0eSBhY3R1YWwKCSkKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncmVmbG9nOiBleHBpcnkgZW1wdGllcyByZWZsb2cnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgkoCgkJY2QgcmVwbyAmJgoKCQl0ZXN0X2NvbW1pdCBpbml0aWFsICYmCgkJZ2l0IGNoZWNrb3V0IC1iIGJyYW5jaCAmJgoJCXRlc3RfY29tbWl0IGZpbGVBICYmCgkJdGVzdF9jb21taXQgZmlsZUIgJiYKCgkJY2F0ID5leHBlY3QgPDwtRU9GICYmCgkJY29tbWl0OiBmaWxlQgoJCWNvbW1pdDogZmlsZUEKCQlicmFuY2g6IENyZWF0ZWQgZnJvbSBIRUFECgkJRU9GCgkJZ2l0IHJlZmxvZyBzaG93IC0tZm9ybWF0PSIlZ3MiIHJlZnMvaGVhZHMvYnJhbmNoID5hY3R1YWwgJiYKCQl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsICYmCgoJCWdpdCByZWZsb2cgZXhwaXJlIGJyYW5jaCAtLWV4cGlyZT1hbGwgJiYKCQlnaXQgcmVmbG9nIHNob3cgLS1mb3JtYXQ9IiVncyIgcmVmcy9oZWFkcy9icmFuY2ggPmFjdHVhbCAmJgoJCXRlc3RfbXVzdF9iZV9lbXB0eSBhY3R1YWwgJiYKCQl0ZXN0LXRvb2wgcmVmLXN0b3JlIG1haW4gcmVmbG9nLWV4aXN0cyByZWZzL2hlYWRzL2JyYW5jaAoJKQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdyZWZsb2c6IGNhbiBiZSBkZWxldGVkJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJKAoJCWNkIHJlcG8gJiYKCQl0ZXN0X2NvbW1pdCBpbml0aWFsICYmCgkJdGVzdC10b29sIHJlZi1zdG9yZSBtYWluIHJlZmxvZy1leGlzdHMgcmVmcy9oZWFkcy9tYWluICYmCgkJdGVzdC10b29sIHJlZi1zdG9yZSBtYWluIGRlbGV0ZS1yZWZsb2cgcmVmcy9oZWFkcy9tYWluICYmCgkJdGVzdF9tdXN0X2ZhaWwgdGVzdC10b29sIHJlZi1zdG9yZSBtYWluIHJlZmxvZy1leGlzdHMgcmVmcy9oZWFkcy9tYWluCgkpCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3JlZmxvZzogZ2FyYmFnZSBjb2xsZWN0aW9uIGRlbGV0ZXMgcmVmbG9nIGVudHJpZXMnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgkoCgkJY2QgcmVwbyAmJgoKCQlmb3IgY291bnQgaW4gJCh0ZXN0X3NlcSAxIDEwKQoJCWRvCgkJCXRlc3RfY29tbWl0ICJudW1iZXIgJGNvdW50IiBmaWxlLnQgJGNvdW50IG51bWJlci0kY291bnQgfHwKCQkJcmV0dXJuIDEKCQlkb25lICYmCgkJZ2l0IHJlZmxvZyByZWZzL2hlYWRzL21haW4gPmFjdHVhbCAmJgoJCXRlc3RfbGluZV9jb3VudCA9IDEwIGFjdHVhbCAmJgoJCWdyZXAgImNvbW1pdCAoaW5pdGlhbCk6IG51bWJlciAxIiBhY3R1YWwgJiYKCQlncmVwICJjb21taXQ6IG51bWJlciAxMCIgYWN0dWFsICYmCgoJCWdpdCBnYyAmJgoJCWdpdCByZWZsb2cgcmVmcy9oZWFkcy9tYWluID5hY3R1YWwgJiYKCQl0ZXN0X2xpbmVfY291bnQgPSAwIGFjdHVhbAoJKQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdyZWZsb2c6IHVwZGF0ZXMgdmlhIEhFQUQgdXBkYXRlIEhFQUQgcmVmbG9nJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJKAoJCWNkIHJlcG8gJiYKCQl0ZXN0X2NvbW1pdCBtYWluLW9uZSAmJgoJCWdpdCBjaGVja291dCAtYiBuZXctYnJhbmNoICYmCgkJdGVzdF9jb21taXQgbmV3LW9uZSAmJgoJCXRlc3RfY29tbWl0IG5ldy10d28gJiYKCgkJZWNobyBuZXctb25lID5leHBlY3QgJiYKCQlnaXQgbG9nIC0xIC0tZm9ybWF0PSVzIEhFQURAezF9ID5hY3R1YWwgJiYKCQl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsCgkpCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ2JyYW5jaDogY29weWluZyBicmFuY2ggd2l0aCBEL0YgY29uZmxpY3QnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8iICYmCglnaXQgaW5pdCByZXBvICYmCgkoCgkJY2QgcmVwbyAmJgoJCXRlc3RfY29tbWl0IEEgJiYKCQlnaXQgYnJhbmNoIGJyYW5jaCAmJgoJCWNhdCA+ZXhwZWN0IDw8LUVPRiAmJgoJCWVycm9yOiAke1NRfXJlZnMvaGVhZHMvYnJhbmNoJHtTUX0gZXhpc3RzOyBjYW5ub3QgY3JlYXRlICR7U1F9cmVmcy9oZWFkcy9icmFuY2gvbW92ZWQke1NRfQoJCWZhdGFsOiBicmFuY2ggY29weSBmYWlsZWQKCQlFT0YKCQl0ZXN0X211c3RfZmFpbCBnaXQgYnJhbmNoIC1jIGJyYW5jaCBicmFuY2gvbW92ZWQgMj5lcnIgJiYKCQl0ZXN0X2NtcCBleHBlY3QgZXJyCgkpCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ2JyYW5jaDogbW92aW5nIGJyYW5jaCB3aXRoIEQvRiBjb25mbGljdCcgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyIgJiYKCWdpdCBpbml0IHJlcG8gJiYKCSgKCQljZCByZXBvICYmCgkJdGVzdF9jb21taXQgQSAmJgoJCWdpdCBicmFuY2ggYnJhbmNoICYmCgkJZ2l0IGJyYW5jaCBjb25mbGljdCAmJgoJCWNhdCA+ZXhwZWN0IDw8LUVPRiAmJgoJCWVycm9yOiAke1NRfXJlZnMvaGVhZHMvY29uZmxpY3Qke1NRfSBleGlzdHM7IGNhbm5vdCBjcmVhdGUgJHtTUX1yZWZzL2hlYWRzL2NvbmZsaWN0L21vdmVkJHtTUX0KCQlmYXRhbDogYnJhbmNoIHJlbmFtZSBmYWlsZWQKCQlFT0YKCQl0ZXN0X211c3RfZmFpbCBnaXQgYnJhbmNoIC1tIGJyYW5jaCBjb25mbGljdC9tb3ZlZCAyPmVyciAmJgoJCXRlc3RfY21wIGV4cGVjdCBlcnIKCSkKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnd29ya3RyZWU6IGFkZGluZyB3b3JrdHJlZSBjcmVhdGVzIHNlcGFyYXRlIHN0YWNrJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIHdvcmt0cmVlIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJdGVzdF9jb21taXQgLUMgcmVwbyBBICYmCgoJZ2l0IC1DIHJlcG8gd29ya3RyZWUgYWRkIC4uL3dvcmt0cmVlICYmCgl0ZXN0X3BhdGhfaXNfZmlsZSByZXBvLy5naXQvd29ya3RyZWVzL3dvcmt0cmVlL3JlZnMvaGVhZHMgJiYKCWVjaG8gInJlZjogcmVmcy9oZWFkcy8uaW52YWxpZCIgPmV4cGVjdCAmJgoJdGVzdF9jbXAgZXhwZWN0IHJlcG8vLmdpdC93b3JrdHJlZXMvd29ya3RyZWUvSEVBRCAmJgoJdGVzdF9wYXRoX2lzX2RpciByZXBvLy5naXQvd29ya3RyZWVzL3dvcmt0cmVlL3JlZnRhYmxlICYmCgl0ZXN0X3BhdGhfaXNfZmlsZSByZXBvLy5naXQvd29ya3RyZWVzL3dvcmt0cmVlL3JlZnRhYmxlL3RhYmxlcy5saXN0CicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3dvcmt0cmVlOiBwYWNrLXJlZnMgaW4gbWFpbiByZXBvIHBhY2tzIG1haW4gcmVmcycgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyB3b3JrdHJlZSIgJiYKCWdpdCBpbml0IHJlcG8gJiYKCXRlc3RfY29tbWl0IC1DIHJlcG8gQSAmJgoKCUdJVF9URVNUX1JFRlRBQkxFX0FVVE9DT01QQUNUSU9OPWZhbHNlIFwKCWdpdCAtQyByZXBvIHdvcmt0cmVlIGFkZCAuLi93b3JrdHJlZSAmJgoJR0lUX1RFU1RfUkVGVEFCTEVfQVVUT0NPTVBBQ1RJT049ZmFsc2UgXAoJZ2l0IC1DIHdvcmt0cmVlIHVwZGF0ZS1yZWYgcmVmcy93b3JrdHJlZS9wZXItd29ya3RyZWUgSEVBRCAmJgoKCXRlc3RfbGluZV9jb3VudCA9IDQgcmVwby8uZ2l0L3dvcmt0cmVlcy93b3JrdHJlZS9yZWZ0YWJsZS90YWJsZXMubGlzdCAmJgoJdGVzdF9saW5lX2NvdW50ID0gMyByZXBvLy5naXQvcmVmdGFibGUvdGFibGVzLmxpc3QgJiYKCWdpdCAtQyByZXBvIHBhY2stcmVmcyAmJgoJdGVzdF9saW5lX2NvdW50ID0gNCByZXBvLy5naXQvd29ya3RyZWVzL3dvcmt0cmVlL3JlZnRhYmxlL3RhYmxlcy5saXN0ICYmCgl0ZXN0X2xpbmVfY291bnQgPSAxIHJlcG8vLmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdAonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICd3b3JrdHJlZTogcGFjay1yZWZzIGluIHdvcmt0cmVlIHBhY2tzIHdvcmt0cmVlIHJlZnMnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8gd29ya3RyZWUiICYmCglnaXQgaW5pdCByZXBvICYmCgl0ZXN0X2NvbW1pdCAtQyByZXBvIEEgJiYKCglHSVRfVEVTVF9SRUZUQUJMRV9BVVRPQ09NUEFDVElPTj1mYWxzZSBcCglnaXQgLUMgcmVwbyB3b3JrdHJlZSBhZGQgLi4vd29ya3RyZWUgJiYKCUdJVF9URVNUX1JFRlRBQkxFX0FVVE9DT01QQUNUSU9OPWZhbHNlIFwKCWdpdCAtQyB3b3JrdHJlZSB1cGRhdGUtcmVmIHJlZnMvd29ya3RyZWUvcGVyLXdvcmt0cmVlIEhFQUQgJiYKCgl0ZXN0X2xpbmVfY291bnQgPSA0IHJlcG8vLmdpdC93b3JrdHJlZXMvd29ya3RyZWUvcmVmdGFibGUvdGFibGVzLmxpc3QgJiYKCXRlc3RfbGluZV9jb3VudCA9IDMgcmVwby8uZ2l0L3JlZnRhYmxlL3RhYmxlcy5saXN0ICYmCglnaXQgLUMgd29ya3RyZWUgcGFjay1yZWZzICYmCgl0ZXN0X2xpbmVfY291bnQgPSAxIHJlcG8vLmdpdC93b3JrdHJlZXMvd29ya3RyZWUvcmVmdGFibGUvdGFibGVzLmxpc3QgJiYKCXRlc3RfbGluZV9jb3VudCA9IDMgcmVwby8uZ2l0L3JlZnRhYmxlL3RhYmxlcy5saXN0CicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3dvcmt0cmVlOiBjcmVhdGluZyBzaGFyZWQgcmVmIHVwZGF0ZXMgbWFpbiBzdGFjaycgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyB3b3JrdHJlZSIgJiYKCWdpdCBpbml0IHJlcG8gJiYKCXRlc3RfY29tbWl0IC1DIHJlcG8gQSAmJgoKCWdpdCAtQyByZXBvIHdvcmt0cmVlIGFkZCAuLi93b3JrdHJlZSAmJgoJZ2l0IC1DIHJlcG8gcGFjay1yZWZzICYmCglnaXQgLUMgd29ya3RyZWUgcGFjay1yZWZzICYmCgl0ZXN0X2xpbmVfY291bnQgPSAxIHJlcG8vLmdpdC93b3JrdHJlZXMvd29ya3RyZWUvcmVmdGFibGUvdGFibGVzLmxpc3QgJiYKCXRlc3RfbGluZV9jb3VudCA9IDEgcmVwby8uZ2l0L3JlZnRhYmxlL3RhYmxlcy5saXN0ICYmCgoJR0lUX1RFU1RfUkVGVEFCTEVfQVVUT0NPTVBBQ1RJT049ZmFsc2UgXAoJZ2l0IC1DIHdvcmt0cmVlIHVwZGF0ZS1yZWYgcmVmcy9oZWFkcy9zaGFyZWQgSEVBRCAmJgoJdGVzdF9saW5lX2NvdW50ID0gMSByZXBvLy5naXQvd29ya3RyZWVzL3dvcmt0cmVlL3JlZnRhYmxlL3RhYmxlcy5saXN0ICYmCgl0ZXN0X2xpbmVfY291bnQgPSAyIHJlcG8vLmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdAonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICd3b3JrdHJlZTogY3JlYXRpbmcgcGVyLXdvcmt0cmVlIHJlZiB1cGRhdGVzIHdvcmt0cmVlIHN0YWNrJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIHdvcmt0cmVlIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJdGVzdF9jb21taXQgLUMgcmVwbyBBICYmCgoJZ2l0IC1DIHJlcG8gd29ya3RyZWUgYWRkIC4uL3dvcmt0cmVlICYmCglnaXQgLUMgcmVwbyBwYWNrLXJlZnMgJiYKCWdpdCAtQyB3b3JrdHJlZSBwYWNrLXJlZnMgJiYKCXRlc3RfbGluZV9jb3VudCA9IDEgcmVwby8uZ2l0L3dvcmt0cmVlcy93b3JrdHJlZS9yZWZ0YWJsZS90YWJsZXMubGlzdCAmJgoJdGVzdF9saW5lX2NvdW50ID0gMSByZXBvLy5naXQvcmVmdGFibGUvdGFibGVzLmxpc3QgJiYKCglnaXQgLUMgd29ya3RyZWUgdXBkYXRlLXJlZiByZWZzL2Jpc2VjdC9wZXItd29ya3RyZWUgSEVBRCAmJgoJdGVzdF9saW5lX2NvdW50ID0gMiByZXBvLy5naXQvd29ya3RyZWVzL3dvcmt0cmVlL3JlZnRhYmxlL3RhYmxlcy5saXN0ICYmCgl0ZXN0X2xpbmVfY291bnQgPSAxIHJlcG8vLmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdAonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICd3b3JrdHJlZTogY3JlYXRpbmcgcGVyLXdvcmt0cmVlIHJlZiBmcm9tIG1haW4gcmVwbycgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyB3b3JrdHJlZSIgJiYKCWdpdCBpbml0IHJlcG8gJiYKCXRlc3RfY29tbWl0IC1DIHJlcG8gQSAmJgoKCWdpdCAtQyByZXBvIHdvcmt0cmVlIGFkZCAuLi93b3JrdHJlZSAmJgoJZ2l0IC1DIHJlcG8gcGFjay1yZWZzICYmCglnaXQgLUMgd29ya3RyZWUgcGFjay1yZWZzICYmCgl0ZXN0X2xpbmVfY291bnQgPSAxIHJlcG8vLmdpdC93b3JrdHJlZXMvd29ya3RyZWUvcmVmdGFibGUvdGFibGVzLmxpc3QgJiYKCXRlc3RfbGluZV9jb3VudCA9IDEgcmVwby8uZ2l0L3JlZnRhYmxlL3RhYmxlcy5saXN0ICYmCgoJZ2l0IC1DIHJlcG8gdXBkYXRlLXJlZiB3b3JrdHJlZXMvd29ya3RyZWUvcmVmcy9iaXNlY3QvcGVyLXdvcmt0cmVlIEhFQUQgJiYKCXRlc3RfbGluZV9jb3VudCA9IDIgcmVwby8uZ2l0L3dvcmt0cmVlcy93b3JrdHJlZS9yZWZ0YWJsZS90YWJsZXMubGlzdCAmJgoJdGVzdF9saW5lX2NvdW50ID0gMSByZXBvLy5naXQvcmVmdGFibGUvdGFibGVzLmxpc3QKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnd29ya3RyZWU6IGNyZWF0aW5nIHBlci13b3JrdHJlZSByZWYgZnJvbSBzZWNvbmQgd29ya3RyZWUnICcKCXRlc3Rfd2hlbl9maW5pc2hlZCAicm0gLXJmIHJlcG8gd3QxIHd0MiIgJiYKCWdpdCBpbml0IHJlcG8gJiYKCXRlc3RfY29tbWl0IC1DIHJlcG8gQSAmJgoKCWdpdCAtQyByZXBvIHdvcmt0cmVlIGFkZCAuLi93dDEgJiYKCWdpdCAtQyByZXBvIHdvcmt0cmVlIGFkZCAuLi93dDIgJiYKCWdpdCAtQyByZXBvIHBhY2stcmVmcyAmJgoJZ2l0IC1DIHd0MSBwYWNrLXJlZnMgJiYKCWdpdCAtQyB3dDIgcGFjay1yZWZzICYmCgl0ZXN0X2xpbmVfY291bnQgPSAxIHJlcG8vLmdpdC93b3JrdHJlZXMvd3QxL3JlZnRhYmxlL3RhYmxlcy5saXN0ICYmCgl0ZXN0X2xpbmVfY291bnQgPSAxIHJlcG8vLmdpdC93b3JrdHJlZXMvd3QyL3JlZnRhYmxlL3RhYmxlcy5saXN0ICYmCgl0ZXN0X2xpbmVfY291bnQgPSAxIHJlcG8vLmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdCAmJgoKCWdpdCAtQyB3dDEgdXBkYXRlLXJlZiB3b3JrdHJlZXMvd3QyL3JlZnMvYmlzZWN0L3Blci13b3JrdHJlZSBIRUFEICYmCgl0ZXN0X2xpbmVfY291bnQgPSAxIHJlcG8vLmdpdC93b3JrdHJlZXMvd3QxL3JlZnRhYmxlL3RhYmxlcy5saXN0ICYmCgl0ZXN0X2xpbmVfY291bnQgPSAyIHJlcG8vLmdpdC93b3JrdHJlZXMvd3QyL3JlZnRhYmxlL3RhYmxlcy5saXN0ICYmCgl0ZXN0X2xpbmVfY291bnQgPSAxIHJlcG8vLmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdAonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICd3b3JrdHJlZTogY2FuIGNyZWF0ZSBzaGFyZWQgYW5kIHBlci13b3JrdHJlZSByZWYgaW4gb25lIHRyYW5zYWN0aW9uJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIHdvcmt0cmVlIiAmJgoJZ2l0IGluaXQgcmVwbyAmJgoJdGVzdF9jb21taXQgLUMgcmVwbyBBICYmCgoJZ2l0IC1DIHJlcG8gd29ya3RyZWUgYWRkIC4uL3dvcmt0cmVlICYmCglnaXQgLUMgcmVwbyBwYWNrLXJlZnMgJiYKCWdpdCAtQyB3b3JrdHJlZSBwYWNrLXJlZnMgJiYKCXRlc3RfbGluZV9jb3VudCA9IDEgcmVwby8uZ2l0L3dvcmt0cmVlcy93b3JrdHJlZS9yZWZ0YWJsZS90YWJsZXMubGlzdCAmJgoJdGVzdF9saW5lX2NvdW50ID0gMSByZXBvLy5naXQvcmVmdGFibGUvdGFibGVzLmxpc3QgJiYKCgljYXQgPnN0ZGluIDw8LUVPRiAmJgoJY3JlYXRlIHdvcmt0cmVlcy93b3JrdHJlZS9yZWZzL2Jpc2VjdC9wZXItd29ya3RyZWUgSEVBRAoJY3JlYXRlIHJlZnMvYnJhbmNoZXMvc2hhcmVkIEhFQUQKCUVPRgoJZ2l0IC1DIHJlcG8gdXBkYXRlLXJlZiAtLXN0ZGluIDxzdGRpbiAmJgoJdGVzdF9saW5lX2NvdW50ID0gMiByZXBvLy5naXQvd29ya3RyZWVzL3dvcmt0cmVlL3JlZnRhYmxlL3RhYmxlcy5saXN0ICYmCgl0ZXN0X2xpbmVfY291bnQgPSAyIHJlcG8vLmdpdC9yZWZ0YWJsZS90YWJsZXMubGlzdAonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICd3b3JrdHJlZTogY2FuIGFjY2VzcyBjb21tb24gcmVmcycgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyB3b3JrdHJlZSIgJiYKCWdpdCBpbml0IHJlcG8gJiYKCXRlc3RfY29tbWl0IC1DIHJlcG8gZmlsZTEgJiYKCWdpdCAtQyByZXBvIGJyYW5jaCBicmFuY2gxICYmCglnaXQgLUMgcmVwbyB3b3JrdHJlZSBhZGQgLi4vd29ya3RyZWUgJiYKCgllY2hvIHJlZnMvaGVhZHMvd29ya3RyZWUgPmV4cGVjdCAmJgoJZ2l0IC1DIHdvcmt0cmVlIHN5bWJvbGljLXJlZiBIRUFEID5hY3R1YWwgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwgJiYKCWdpdCAtQyB3b3JrdHJlZSBjaGVja291dCBicmFuY2gxCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3dvcmt0cmVlOiBhZGRzIHdvcmt0cmVlIHdpdGggZGV0YWNoZWQgSEVBRCcgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgcmVwbyB3b3JrdHJlZSIgJiYKCglnaXQgaW5pdCByZXBvICYmCgl0ZXN0X2NvbW1pdCAtQyByZXBvIEEgJiYKCWdpdCAtQyByZXBvIHJldi1wYXJzZSBtYWluID5leHBlY3QgJiYKCglnaXQgLUMgcmVwbyB3b3JrdHJlZSBhZGQgLS1kZXRhY2ggLi4vd29ya3RyZWUgbWFpbiAmJgoJZ2l0IC1DIHdvcmt0cmVlIHJldi1wYXJzZSBIRUFEID5hY3R1YWwgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnZmV0Y2g6IGFjY2Vzc2luZyBGRVRDSF9IRUFEIHNwZWNpYWwgcmVmIHdvcmtzJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiByZXBvIHN1YiIgJiYKCglnaXQgaW5pdCBzdWIgJiYKCXRlc3RfY29tbWl0IC1DIHN1YiB0d28gJiYKCWdpdCAtQyBzdWIgcmV2LXBhcnNlIEhFQUQgPmV4cGVjdCAmJgoKCWdpdCBpbml0IHJlcG8gJiYKCXRlc3RfY29tbWl0IC1DIHJlcG8gb25lICYmCglnaXQgLUMgcmVwbyBmZXRjaCAuLi9zdWIgJiYKCWdpdCAtQyByZXBvIHJldi1wYXJzZSBGRVRDSF9IRUFEID5hY3R1YWwgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwKJwoKdGVzdF9kb25lCg==",
    "text": "#!/bin/sh\n#\n# Copyright (c) 2020 Google LLC\n#\n\ntest_description='reftable basics'\n\nGIT_TEST_DEFAULT_INITIAL_BRANCH_NAME=main\nexport GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME\nGIT_TEST_DEFAULT_REF_FORMAT=reftable\nexport GIT_TEST_DEFAULT_REF_FORMAT\n\n. ./test-lib.sh\n\nINVALID_OID=$(test_oid 001)\n\ntest_expect_success 'pack-refs does not crash with -h' '\n\ttest_expect_code 129 git pack-refs -h >usage &&\n\ttest_grep \"[Uu]sage: git pack-refs \" usage &&\n\ttest_expect_code 129 nongit git pack-refs -h >usage &&\n\ttest_grep \"[Uu]sage: git pack-refs \" usage\n'\n\ntest_expect_success 'init: creates basic reftable structures' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\ttest_path_is_dir repo/.git/reftable &&\n\ttest_path_is_file repo/.git/reftable/tables.list &&\n\techo reftable >expect &&\n\tgit -C repo rev-parse --show-ref-format >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'init: sha256 object format via environment variable' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tGIT_DEFAULT_HASH=sha256 git init repo &&\n\tcat >expect <<-EOF &&\n\tsha256\n\treftable\n\tEOF\n\tgit -C repo rev-parse --show-object-format --show-ref-format >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'init: sha256 object format via option' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init --object-format=sha256 repo &&\n\tcat >expect <<-EOF &&\n\tsha256\n\treftable\n\tEOF\n\tgit -C repo rev-parse --show-object-format --show-ref-format >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'init: reinitializing reftable backend succeeds' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\ttest_commit -C repo A &&\n\n\tgit -C repo for-each-ref >expect &&\n\tgit init --ref-format=reftable repo &&\n\tgit -C repo for-each-ref >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'init: reinitializing files with reftable backend fails' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init --ref-format=files repo &&\n\ttest_commit -C repo file &&\n\n\tcp repo/.git/HEAD expect &&\n\ttest_must_fail git init --ref-format=reftable repo &&\n\ttest_cmp expect repo/.git/HEAD\n'\n\ntest_expect_success 'init: reinitializing reftable with files backend fails' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init --ref-format=reftable repo &&\n\ttest_commit -C repo file &&\n\n\tcp repo/.git/HEAD expect &&\n\ttest_must_fail git init --ref-format=files repo &&\n\ttest_cmp expect repo/.git/HEAD\n'\n\ntest_expect_perms () {\n\tlocal perms=\"$1\" &&\n\tlocal file=\"$2\" &&\n\tlocal actual=\"$(ls -l \"$file\")\" &&\n\n\tcase \"$actual\" in\n\t$perms*)\n\t\t: happy\n\t\t;;\n\t*)\n\t\techo \"$(basename $2) is not $perms but $actual\"\n\t\tfalse\n\t\t;;\n\tesac\n}\n\ntest_expect_reftable_perms () {\n\tlocal umask=\"$1\"\n\tlocal shared=\"$2\"\n\tlocal expect=\"$3\"\n\n\ttest_expect_success POSIXPERM \"init: honors --shared=$shared with umask $umask\" '\n\t\ttest_when_finished \"rm -rf repo\" &&\n\t\t(\n\t\t\tumask $umask &&\n\t\t\tgit init --shared=$shared repo\n\t\t) &&\n\t\ttest_expect_perms \"$expect\" repo/.git/reftable/tables.list &&\n\t\tfor table in repo/.git/reftable/*.ref\n\t\tdo\n\t\t\ttest_expect_perms \"$expect\" \"$table\" ||\n\t\t\treturn 1\n\t\tdone\n\t'\n\n\ttest_expect_success POSIXPERM \"pack-refs: honors --shared=$shared with umask $umask\" '\n\t\ttest_when_finished \"rm -rf repo\" &&\n\t\t(\n\t\t\tumask $umask &&\n\t\t\tgit init --shared=$shared repo &&\n\t\t\ttest_commit -C repo A &&\n\t\t\ttest_line_count = 2 repo/.git/reftable/tables.list &&\n\t\t\tgit -C repo pack-refs\n\t\t) &&\n\t\ttest_expect_perms \"$expect\" repo/.git/reftable/tables.list &&\n\t\tfor table in repo/.git/reftable/*.ref\n\t\tdo\n\t\t\ttest_expect_perms \"$expect\" \"$table\" ||\n\t\t\treturn 1\n\t\tdone\n\t'\n}\n\ntest_expect_reftable_perms 002 umask \"-rw-rw-r--\"\ntest_expect_reftable_perms 022 umask \"-rw-r--r--\"\ntest_expect_reftable_perms 027 umask \"-rw-r-----\"\n\ntest_expect_reftable_perms 002 group \"-rw-rw-r--\"\ntest_expect_reftable_perms 022 group \"-rw-rw-r--\"\ntest_expect_reftable_perms 027 group \"-rw-rw----\"\n\ntest_expect_reftable_perms 002 world \"-rw-rw-r--\"\ntest_expect_reftable_perms 022 world \"-rw-rw-r--\"\ntest_expect_reftable_perms 027 world \"-rw-rw-r--\"\n\ntest_expect_success 'clone: can clone reftable repository' '\n\ttest_when_finished \"rm -rf repo clone\" &&\n\tgit init repo &&\n\ttest_commit -C repo message1 file1 &&\n\n\tgit clone repo cloned &&\n\techo reftable >expect &&\n\tgit -C cloned rev-parse --show-ref-format >actual &&\n\ttest_cmp expect actual &&\n\ttest_path_is_file cloned/file1\n'\n\ntest_expect_success 'clone: can clone reffiles into reftable repository' '\n\ttest_when_finished \"rm -rf reffiles reftable\" &&\n\tgit init --ref-format=files reffiles &&\n\ttest_commit -C reffiles A &&\n\tgit clone --ref-format=reftable ./reffiles reftable &&\n\n\tgit -C reffiles rev-parse HEAD >expect &&\n\tgit -C reftable rev-parse HEAD >actual &&\n\ttest_cmp expect actual &&\n\n\tgit -C reftable rev-parse --show-ref-format >actual &&\n\techo reftable >expect &&\n\ttest_cmp expect actual &&\n\n\tgit -C reffiles rev-parse --show-ref-format >actual &&\n\techo files >expect &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'clone: can clone reftable into reffiles repository' '\n\ttest_when_finished \"rm -rf reffiles reftable\" &&\n\tgit init --ref-format=reftable reftable &&\n\ttest_commit -C reftable A &&\n\tgit clone --ref-format=files ./reftable reffiles &&\n\n\tgit -C reftable rev-parse HEAD >expect &&\n\tgit -C reffiles rev-parse HEAD >actual &&\n\ttest_cmp expect actual &&\n\n\tgit -C reftable rev-parse --show-ref-format >actual &&\n\techo reftable >expect &&\n\ttest_cmp expect actual &&\n\n\tgit -C reffiles rev-parse --show-ref-format >actual &&\n\techo files >expect &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'ref transaction: corrupted tables cause failure' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest_commit file1 &&\n\t\tfor f in .git/reftable/*.ref\n\t\tdo\n\t\t\t: >\"$f\" || return 1\n\t\tdone &&\n\t\ttest_must_fail git update-ref refs/heads/main HEAD\n\t)\n'\n\ntest_expect_success 'ref transaction: corrupted tables.list cause failure' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest_commit file1 &&\n\t\techo garbage >.git/reftable/tables.list &&\n\t\ttest_must_fail git update-ref refs/heads/main HEAD\n\t)\n'\n\ntest_expect_success 'ref transaction: refuses to write ref causing F/D conflict' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\ttest_commit -C repo file &&\n\ttest_must_fail git -C repo update-ref refs/heads/main/forbidden\n'\n\ntest_expect_success 'ref transaction: deleting ref with invalid name fails' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\ttest_commit -C repo file &&\n\ttest_must_fail git -C repo update-ref -d ../../my-private-file\n'\n\ntest_expect_success 'ref transaction: can skip object ID verification' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\ttest_must_fail test-tool -C repo ref-store main update-ref msg refs/heads/branch $INVALID_OID $ZERO_OID 0 &&\n\ttest-tool -C repo ref-store main update-ref msg refs/heads/branch $INVALID_OID $ZERO_OID REF_SKIP_OID_VERIFICATION\n'\n\ntest_expect_success 'ref transaction: updating same ref multiple times fails' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\ttest_commit -C repo A &&\n\tcat >updates <<-EOF &&\n\tupdate refs/heads/main $A\n\tupdate refs/heads/main $A\n\tEOF\n\tcat >expect <<-EOF &&\n\tfatal: multiple updates for ref ${SQ}refs/heads/main${SQ} not allowed\n\tEOF\n\ttest_must_fail git -C repo update-ref --stdin <updates 2>err &&\n\ttest_cmp expect err\n'\n\ntest_expect_success 'ref transaction: can delete symbolic self-reference with git-symbolic-ref(1)' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\tgit -C repo symbolic-ref refs/heads/self refs/heads/self &&\n\tgit -C repo symbolic-ref -d refs/heads/self\n'\n\ntest_expect_success 'ref transaction: deleting symbolic self-reference without --no-deref fails' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\tgit -C repo symbolic-ref refs/heads/self refs/heads/self &&\n\tcat >expect <<-EOF &&\n\terror: multiple updates for ${SQ}refs/heads/self${SQ} (including one via symref ${SQ}refs/heads/self${SQ}) are not allowed\n\tEOF\n\ttest_must_fail git -C repo update-ref -d refs/heads/self 2>err &&\n\ttest_cmp expect err\n'\n\ntest_expect_success 'ref transaction: deleting symbolic self-reference with --no-deref succeeds' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\tgit -C repo symbolic-ref refs/heads/self refs/heads/self &&\n\tgit -C repo update-ref -d --no-deref refs/heads/self\n'\n\ntest_expect_success 'ref transaction: creating symbolic ref fails with F/D conflict' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\ttest_commit -C repo A &&\n\tcat >expect <<-EOF &&\n\terror: ${SQ}refs/heads/main${SQ} exists; cannot create ${SQ}refs/heads${SQ}\n\tEOF\n\ttest_must_fail git -C repo symbolic-ref refs/heads refs/heads/foo 2>err &&\n\ttest_cmp expect err\n'\n\ntest_expect_success 'ref transaction: ref deletion' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest_commit file &&\n\t\tHEAD_OID=$(git show-ref -s --verify HEAD) &&\n\t\tcat >expect <<-EOF &&\n\t\t$HEAD_OID refs/heads/main\n\t\t$HEAD_OID refs/tags/file\n\t\tEOF\n\t\tgit show-ref >actual &&\n\t\ttest_cmp expect actual &&\n\n\t\ttest_must_fail git update-ref -d refs/tags/file $INVALID_OID &&\n\t\tgit show-ref >actual &&\n\t\ttest_cmp expect actual &&\n\n\t\tgit update-ref -d refs/tags/file $HEAD_OID &&\n\t\techo \"$HEAD_OID refs/heads/main\" >expect &&\n\t\tgit show-ref >actual &&\n\t\ttest_cmp expect actual\n\t)\n'\n\ntest_expect_success 'ref transaction: writes cause auto-compaction' '\n\ttest_when_finished \"rm -rf repo\" &&\n\n\tgit init repo &&\n\ttest_line_count = 1 repo/.git/reftable/tables.list &&\n\n\ttest_commit -C repo --no-tag A &&\n\ttest_line_count = 1 repo/.git/reftable/tables.list &&\n\n\ttest_commit -C repo --no-tag B &&\n\ttest_line_count = 1 repo/.git/reftable/tables.list\n'\n\ntest_expect_success 'ref transaction: env var disables compaction' '\n\ttest_when_finished \"rm -rf repo\" &&\n\n\tgit init repo &&\n\ttest_commit -C repo A &&\n\n\tstart=$(wc -l <repo/.git/reftable/tables.list) &&\n\titerations=5 &&\n\texpected=$((start + iterations)) &&\n\n\tfor i in $(test_seq $iterations)\n\tdo\n\t\tGIT_TEST_REFTABLE_AUTOCOMPACTION=false \\\n\t\tgit -C repo update-ref branch-$i HEAD || return 1\n\tdone &&\n\ttest_line_count = $expected repo/.git/reftable/tables.list &&\n\n\tgit -C repo update-ref foo HEAD &&\n\ttest_line_count -lt $expected repo/.git/reftable/tables.list\n'\n\ntest_expect_success 'ref transaction: alternating table sizes are compacted' '\n\ttest_when_finished \"rm -rf repo\" &&\n\n\tgit init repo &&\n\ttest_commit -C repo A &&\n\tfor i in $(test_seq 5)\n\tdo\n\t\tgit -C repo branch -f foo &&\n\t\tgit -C repo branch -d foo || return 1\n\tdone &&\n\ttest_line_count = 2 repo/.git/reftable/tables.list\n'\n\ncheck_fsync_events () {\n\tlocal trace=\"$1\" &&\n\tshift &&\n\n\tcat >expect &&\n\tsed -n \\\n\t\t-e '/^{\"event\":\"counter\",.*\"category\":\"fsync\",/ {\n\t\t\ts/.*\"category\":\"fsync\",//;\n\t\t\ts/}$//;\n\t\t\tp;\n\t\t}' \\\n\t\t<\"$trace\" >actual &&\n\ttest_cmp expect actual\n}\n\ntest_expect_success 'ref transaction: writes are synced' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\ttest_commit -C repo initial &&\n\n\tGIT_TRACE2_EVENT=\"$(pwd)/trace2.txt\" \\\n\tGIT_TEST_FSYNC=true \\\n\t\tgit -C repo -c core.fsync=reference \\\n\t\t-c core.fsyncMethod=fsync update-ref refs/heads/branch HEAD &&\n\tcheck_fsync_events trace2.txt <<-EOF\n\t\"name\":\"hardware-flush\",\"count\":4\n\tEOF\n'\n\ntest_expect_success 'ref transaction: empty transaction in empty repo' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\ttest_commit -C repo --no-tag A &&\n\tgit -C repo update-ref -d refs/heads/main &&\n\ttest-tool -C repo ref-store main delete-refs REF_NO_DEREF msg HEAD &&\n\tgit -C repo update-ref --stdin <<-EOF\n\tprepare\n\tcommit\n\tEOF\n'\n\ntest_expect_success 'ref transaction: fails gracefully when auto compaction fails' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\n\t\ttest_commit A &&\n\t\tfor i in $(test_seq 10)\n\t\tdo\n\t\t\tgit branch branch-$i &&\n\t\t\tfor table in .git/reftable/*.ref\n\t\t\tdo\n\t\t\t\ttouch \"$table.lock\" || exit 1\n\t\t\tdone ||\n\t\t\texit 1\n\t\tdone &&\n\t\ttest_line_count = 10 .git/reftable/tables.list\n\t)\n'\n\ntest_expect_success 'ref transaction: timeout acquiring tables.list lock' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest_commit initial &&\n\t\t>.git/reftable/tables.list.lock &&\n\t\ttest_must_fail git update-ref refs/heads/branch HEAD 2>err &&\n\t\ttest_grep \"cannot lock references\" err\n\t)\n'\n\ntest_expect_success 'ref transaction: retry acquiring tables.list lock' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest_commit initial &&\n\t\tLOCK=.git/reftable/tables.list.lock &&\n\t\t>$LOCK &&\n\t\t{\n\t\t\t( sleep 1 && rm -f $LOCK ) &\n\t\t} &&\n\t\tgit -c reftable.lockTimeout=5000 update-ref refs/heads/branch HEAD\n\t)\n'\n\n# This test fails most of the time on Cygwin systems. The root cause is\n# that Windows does not allow us to rename the \"tables.list.lock\" file into\n# place when \"tables.list\" is open for reading by a concurrent process. We have\n# worked around that in our MinGW-based rename emulation, but the Cygwin\n# emulation seems to be insufficient.\ntest_expect_success !CYGWIN 'ref transaction: many concurrent writers' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\t# Set a high timeout. While a couple of seconds should be\n\t\t# plenty, using the address sanitizer will significantly slow\n\t\t# us down here. So we are aiming way higher than you would ever\n\t\t# think is necessary just to keep us from flaking. We could\n\t\t# also lock indefinitely by passing -1, but that could\n\t\t# potentially block CI jobs indefinitely if there was a bug\n\t\t# here.\n\t\tgit config set reftable.lockTimeout 300000 &&\n\t\ttest_commit --no-tag initial &&\n\n\t\thead=$(git rev-parse HEAD) &&\n\t\tfor i in $(test_seq 100)\n\t\tdo\n\t\t\tprintf \"%s commit\\trefs/heads/branch-%s\\n\" \"$head\" \"$i\" ||\n\t\t\treturn 1\n\t\tdone >expect &&\n\t\tprintf \"%s commit\\trefs/heads/main\\n\" \"$head\" >>expect &&\n\n\t\tfor i in $(test_seq 100)\n\t\tdo\n\t\t\t{ git update-ref refs/heads/branch-$i HEAD& } ||\n\t\t\treturn 1\n\t\tdone &&\n\n\t\twait &&\n\t\tgit for-each-ref --sort=v:refname >actual &&\n\t\ttest_cmp expect actual\n\t)\n'\n\ntest_expect_success 'pack-refs: compacts tables' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\n\ttest_commit -C repo A &&\n\tls -1 repo/.git/reftable >table-files &&\n\ttest_line_count = 3 table-files &&\n\ttest_line_count = 2 repo/.git/reftable/tables.list &&\n\n\tgit -C repo pack-refs &&\n\tls -1 repo/.git/reftable >table-files &&\n\ttest_line_count = 2 table-files &&\n\ttest_line_count = 1 repo/.git/reftable/tables.list\n'\n\ntest_expect_success 'pack-refs: compaction raises locking errors' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\ttest_commit -C repo A &&\n\ttouch repo/.git/reftable/tables.list.lock &&\n\tcat >expect <<-EOF &&\n\terror: unable to compact stack: data is locked\n\tEOF\n\ttest_must_fail git -C repo pack-refs 2>err &&\n\ttest_cmp expect err\n'\n\nfor command in pack-refs gc \"maintenance run --task=pack-refs\"\ndo\ntest_expect_success \"$command: auto compaction\" '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\n\t\ttest_commit A &&\n\n\t\t# We need a bit of setup to ensure that git-gc(1) actually\n\t\t# triggers, and that it does not write anything to the refdb.\n\t\tgit config gc.auto 1 &&\n\t\tgit config gc.autoDetach 0 &&\n\t\tgit config gc.reflogExpire never &&\n\t\tgit config gc.reflogExpireUnreachable never &&\n\t\ttest_oid blob17_1 | git hash-object -w --stdin &&\n\n\t\t# The tables should have been auto-compacted, and thus auto\n\t\t# compaction should not have to do anything.\n\t\tls -1 .git/reftable >tables-expect &&\n\t\ttest_line_count = 3 tables-expect &&\n\t\tgit $command --auto &&\n\t\tls -1 .git/reftable >tables-actual &&\n\t\ttest_cmp tables-expect tables-actual &&\n\n\t\ttest_oid blob17_2 | git hash-object -w --stdin &&\n\n\t\t# Lock all tables, write some refs. Auto-compaction will be\n\t\t# unable to compact tables and thus fails gracefully,\n\t\t# compacting only those tables which are not locked.\n\t\tls .git/reftable/*.ref | sort |\n\t\twhile read table\n\t\tdo\n\t\t\ttouch \"$table.lock\" &&\n\t\t\tbasename \"$table\" >>tables.expect || exit 1\n\t\tdone &&\n\t\ttest_line_count = 2 .git/reftable/tables.list &&\n\t\tgit branch B &&\n\t\tgit branch C &&\n\n\t\t# The new tables are auto-compacted, but the locked tables are\n\t\t# left intact.\n\t\ttest_line_count = 3 .git/reftable/tables.list &&\n\t\thead -n 2 .git/reftable/tables.list >tables.head &&\n\t\ttest_cmp tables.expect tables.head &&\n\n\t\trm .git/reftable/*.lock &&\n\t\tgit $command --auto &&\n\t\ttest_line_count = 1 .git/reftable/tables.list\n\t)\n'\ndone\n\ntest_expect_success 'pack-refs: prunes stale tables' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\ttouch repo/.git/reftable/stale-table.ref &&\n\tgit -C repo pack-refs &&\n\ttest_path_is_missing repo/.git/reftable/stable-ref.ref\n'\n\ntest_expect_success 'pack-refs: does not prune non-table files' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\ttouch repo/.git/reftable/garbage &&\n\tgit -C repo pack-refs &&\n\ttest_path_is_file repo/.git/reftable/garbage\n'\n\ntest_expect_success 'packed-refs: writes are synced' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\ttest_commit -C repo initial &&\n\ttest_line_count = 2 table-files &&\n\n\t: >trace2.txt &&\n\tGIT_TRACE2_EVENT=\"$(pwd)/trace2.txt\" \\\n\tGIT_TEST_FSYNC=true \\\n\t\tgit -C repo -c core.fsync=reference \\\n\t\t-c core.fsyncMethod=fsync pack-refs &&\n\tcheck_fsync_events trace2.txt <<-EOF\n\t\"name\":\"hardware-flush\",\"count\":2\n\tEOF\n'\n\ntest_expect_success 'ref iterator: bogus names are flagged' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest_commit --no-tag file &&\n\t\ttest-tool ref-store main update-ref msg \"refs/heads/bogus..name\" $(git rev-parse HEAD) $ZERO_OID REF_SKIP_REFNAME_VERIFICATION &&\n\n\t\tcat >expect <<-EOF &&\n\t\t$ZERO_OID refs/heads/bogus..name 0xc\n\t\t$(git rev-parse HEAD) refs/heads/main 0x0\n\t\tEOF\n\t\ttest-tool ref-store main for-each-ref \"\" >actual &&\n\t\ttest_cmp expect actual\n\t)\n'\n\ntest_expect_success 'ref iterator: missing object IDs are not flagged' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest-tool ref-store main update-ref msg \"refs/heads/broken-hash\" $INVALID_OID $ZERO_OID REF_SKIP_OID_VERIFICATION &&\n\n\t\tcat >expect <<-EOF &&\n\t\t$INVALID_OID refs/heads/broken-hash 0x0\n\t\tEOF\n\t\ttest-tool ref-store main for-each-ref \"\" >actual &&\n\t\ttest_cmp expect actual\n\t)\n'\n\ntest_expect_success 'basic: commit and list refs' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\ttest_commit -C repo file &&\n\ttest_write_lines refs/heads/main refs/tags/file >expect &&\n\tgit -C repo for-each-ref --format=\"%(refname)\" >actual &&\n\ttest_cmp actual expect\n'\n\ntest_expect_success 'basic: can write large commit message' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\tperl -e \"\n\t\tprint \\\"this is a long commit message\\\" x 50000\n\t\" >commit-msg &&\n\tgit -C repo commit --allow-empty --file=../commit-msg\n'\n\ntest_expect_success 'basic: show-ref fails with empty repository' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\ttest_must_fail git -C repo show-ref >actual &&\n\ttest_must_be_empty actual\n'\n\ntest_expect_success 'basic: can check out unborn branch' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\tgit -C repo checkout -b main\n'\n\ntest_expect_success 'basic: peeled tags are stored' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\ttest_commit -C repo file &&\n\tgit -C repo tag -m \"annotated tag\" test_tag HEAD &&\n\tfor ref in refs/heads/main refs/tags/file refs/tags/test_tag refs/tags/test_tag^{}\n\tdo\n\t\techo \"$(git -C repo rev-parse \"$ref\") $ref\" || return 1\n\tdone >expect &&\n\tgit -C repo show-ref -d >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'basic: for-each-ref can print symrefs' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest_commit file &&\n\t\tgit branch &&\n\t\tgit symbolic-ref refs/heads/sym refs/heads/main &&\n\t\tcat >expected <<-EOF &&\n\t\trefs/heads/main\n\t\tEOF\n\t\tgit for-each-ref --format=\"%(symref)\" refs/heads/sym >actual &&\n\t\ttest_cmp expected actual\n\t)\n'\n\ntest_expect_success 'basic: notes' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\twrite_script fake_editor <<-\\EOF &&\n\t\techo \"$MSG\" >\"$1\"\n\t\techo \"$MSG\" >&2\n\t\tEOF\n\n\t\ttest_commit 1st &&\n\t\ttest_commit 2nd &&\n\t\tGIT_EDITOR=./fake_editor MSG=b4 git notes add &&\n\t\tGIT_EDITOR=./fake_editor MSG=b3 git notes edit &&\n\t\techo b4 >expect &&\n\t\tgit notes --ref commits@{1} show >actual &&\n\t\ttest_cmp expect actual\n\t)\n'\n\ntest_expect_success 'basic: stash' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest_commit file &&\n\t\tgit stash list >expect &&\n\t\ttest_line_count = 0 expect &&\n\n\t\techo hoi >>file.t &&\n\t\tgit stash push -m stashed &&\n\t\tgit stash list >expect &&\n\t\ttest_line_count = 1 expect &&\n\n\t\tgit stash clear &&\n\t\tgit stash list >expect &&\n\t\ttest_line_count = 0 expect\n\t)\n'\n\ntest_expect_success 'basic: cherry-pick' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest_commit message1 file1 &&\n\t\ttest_commit message2 file2 &&\n\t\tgit branch source &&\n\t\tgit checkout HEAD^ &&\n\t\ttest_commit message3 file3 &&\n\t\tgit cherry-pick source &&\n\t\ttest_path_is_file file2\n\t)\n'\n\ntest_expect_success 'basic: rebase' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest_commit message1 file1 &&\n\t\ttest_commit message2 file2 &&\n\t\tgit branch source &&\n\t\tgit checkout HEAD^ &&\n\t\ttest_commit message3 file3 &&\n\t\tgit rebase source &&\n\t\ttest_path_is_file file2\n\t)\n'\n\ntest_expect_success 'reflog: can delete separate reflog entries' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\n\t\ttest_commit file &&\n\t\ttest_commit file2 &&\n\t\ttest_commit file3 &&\n\t\ttest_commit file4 &&\n\t\tgit reflog >actual &&\n\t\tgrep file3 actual &&\n\n\t\tgit reflog delete HEAD@{1} &&\n\t\tgit reflog >actual &&\n\t\t! grep file3 actual\n\t)\n'\n\ntest_expect_success 'reflog: can switch to previous branch' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest_commit file1 &&\n\t\tgit checkout -b branch1 &&\n\t\ttest_commit file2 &&\n\t\tgit checkout -b branch2 &&\n\t\tgit switch - &&\n\t\tgit rev-parse --symbolic-full-name HEAD >actual &&\n\t\techo refs/heads/branch1 >expect &&\n\t\ttest_cmp actual expect\n\t)\n'\n\ntest_expect_success 'reflog: copying branch writes reflog entry' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest_commit file1 &&\n\t\ttest_commit file2 &&\n\t\toid=$(git rev-parse --short HEAD) &&\n\t\tgit branch src &&\n\t\tcat >expect <<-EOF &&\n\t\t${oid} dst@{0}: Branch: copied refs/heads/src to refs/heads/dst\n\t\t${oid} dst@{1}: branch: Created from main\n\t\tEOF\n\t\tgit branch -c src dst &&\n\t\tgit reflog dst >actual &&\n\t\ttest_cmp expect actual\n\t)\n'\n\ntest_expect_success 'reflog: renaming branch writes reflog entry' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\tgit symbolic-ref HEAD refs/heads/before &&\n\t\ttest_commit file &&\n\t\tgit show-ref >expected.refs &&\n\t\tsed s/before/after/g <expected.refs >expected &&\n\t\tgit branch -M after &&\n\t\tgit show-ref >actual &&\n\t\ttest_cmp expected actual &&\n\t\techo refs/heads/after >expected &&\n\t\tgit symbolic-ref HEAD >actual &&\n\t\ttest_cmp expected actual\n\t)\n'\n\ntest_expect_success 'reflog: can store empty logs' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\n\t\ttest_must_fail test-tool ref-store main reflog-exists refs/heads/branch &&\n\t\ttest-tool ref-store main create-reflog refs/heads/branch &&\n\t\ttest-tool ref-store main reflog-exists refs/heads/branch &&\n\t\ttest-tool ref-store main for-each-reflog-ent-reverse refs/heads/branch >actual &&\n\t\ttest_must_be_empty actual\n\t)\n'\n\ntest_expect_success 'reflog: expiry empties reflog' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\n\t\ttest_commit initial &&\n\t\tgit checkout -b branch &&\n\t\ttest_commit fileA &&\n\t\ttest_commit fileB &&\n\n\t\tcat >expect <<-EOF &&\n\t\tcommit: fileB\n\t\tcommit: fileA\n\t\tbranch: Created from HEAD\n\t\tEOF\n\t\tgit reflog show --format=\"%gs\" refs/heads/branch >actual &&\n\t\ttest_cmp expect actual &&\n\n\t\tgit reflog expire branch --expire=all &&\n\t\tgit reflog show --format=\"%gs\" refs/heads/branch >actual &&\n\t\ttest_must_be_empty actual &&\n\t\ttest-tool ref-store main reflog-exists refs/heads/branch\n\t)\n'\n\ntest_expect_success 'reflog: can be deleted' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest_commit initial &&\n\t\ttest-tool ref-store main reflog-exists refs/heads/main &&\n\t\ttest-tool ref-store main delete-reflog refs/heads/main &&\n\t\ttest_must_fail test-tool ref-store main reflog-exists refs/heads/main\n\t)\n'\n\ntest_expect_success 'reflog: garbage collection deletes reflog entries' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\n\t\tfor count in $(test_seq 1 10)\n\t\tdo\n\t\t\ttest_commit \"number $count\" file.t $count number-$count ||\n\t\t\treturn 1\n\t\tdone &&\n\t\tgit reflog refs/heads/main >actual &&\n\t\ttest_line_count = 10 actual &&\n\t\tgrep \"commit (initial): number 1\" actual &&\n\t\tgrep \"commit: number 10\" actual &&\n\n\t\tgit gc &&\n\t\tgit reflog refs/heads/main >actual &&\n\t\ttest_line_count = 0 actual\n\t)\n'\n\ntest_expect_success 'reflog: updates via HEAD update HEAD reflog' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest_commit main-one &&\n\t\tgit checkout -b new-branch &&\n\t\ttest_commit new-one &&\n\t\ttest_commit new-two &&\n\n\t\techo new-one >expect &&\n\t\tgit log -1 --format=%s HEAD@{1} >actual &&\n\t\ttest_cmp expect actual\n\t)\n'\n\ntest_expect_success 'branch: copying branch with D/F conflict' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest_commit A &&\n\t\tgit branch branch &&\n\t\tcat >expect <<-EOF &&\n\t\terror: ${SQ}refs/heads/branch${SQ} exists; cannot create ${SQ}refs/heads/branch/moved${SQ}\n\t\tfatal: branch copy failed\n\t\tEOF\n\t\ttest_must_fail git branch -c branch branch/moved 2>err &&\n\t\ttest_cmp expect err\n\t)\n'\n\ntest_expect_success 'branch: moving branch with D/F conflict' '\n\ttest_when_finished \"rm -rf repo\" &&\n\tgit init repo &&\n\t(\n\t\tcd repo &&\n\t\ttest_commit A &&\n\t\tgit branch branch &&\n\t\tgit branch conflict &&\n\t\tcat >expect <<-EOF &&\n\t\terror: ${SQ}refs/heads/conflict${SQ} exists; cannot create ${SQ}refs/heads/conflict/moved${SQ}\n\t\tfatal: branch rename failed\n\t\tEOF\n\t\ttest_must_fail git branch -m branch conflict/moved 2>err &&\n\t\ttest_cmp expect err\n\t)\n'\n\ntest_expect_success 'worktree: adding worktree creates separate stack' '\n\ttest_when_finished \"rm -rf repo worktree\" &&\n\tgit init repo &&\n\ttest_commit -C repo A &&\n\n\tgit -C repo worktree add ../worktree &&\n\ttest_path_is_file repo/.git/worktrees/worktree/refs/heads &&\n\techo \"ref: refs/heads/.invalid\" >expect &&\n\ttest_cmp expect repo/.git/worktrees/worktree/HEAD &&\n\ttest_path_is_dir repo/.git/worktrees/worktree/reftable &&\n\ttest_path_is_file repo/.git/worktrees/worktree/reftable/tables.list\n'\n\ntest_expect_success 'worktree: pack-refs in main repo packs main refs' '\n\ttest_when_finished \"rm -rf repo worktree\" &&\n\tgit init repo &&\n\ttest_commit -C repo A &&\n\n\tGIT_TEST_REFTABLE_AUTOCOMPACTION=false \\\n\tgit -C repo worktree add ../worktree &&\n\tGIT_TEST_REFTABLE_AUTOCOMPACTION=false \\\n\tgit -C worktree update-ref refs/worktree/per-worktree HEAD &&\n\n\ttest_line_count = 4 repo/.git/worktrees/worktree/reftable/tables.list &&\n\ttest_line_count = 3 repo/.git/reftable/tables.list &&\n\tgit -C repo pack-refs &&\n\ttest_line_count = 4 repo/.git/worktrees/worktree/reftable/tables.list &&\n\ttest_line_count = 1 repo/.git/reftable/tables.list\n'\n\ntest_expect_success 'worktree: pack-refs in worktree packs worktree refs' '\n\ttest_when_finished \"rm -rf repo worktree\" &&\n\tgit init repo &&\n\ttest_commit -C repo A &&\n\n\tGIT_TEST_REFTABLE_AUTOCOMPACTION=false \\\n\tgit -C repo worktree add ../worktree &&\n\tGIT_TEST_REFTABLE_AUTOCOMPACTION=false \\\n\tgit -C worktree update-ref refs/worktree/per-worktree HEAD &&\n\n\ttest_line_count = 4 repo/.git/worktrees/worktree/reftable/tables.list &&\n\ttest_line_count = 3 repo/.git/reftable/tables.list &&\n\tgit -C worktree pack-refs &&\n\ttest_line_count = 1 repo/.git/worktrees/worktree/reftable/tables.list &&\n\ttest_line_count = 3 repo/.git/reftable/tables.list\n'\n\ntest_expect_success 'worktree: creating shared ref updates main stack' '\n\ttest_when_finished \"rm -rf repo worktree\" &&\n\tgit init repo &&\n\ttest_commit -C repo A &&\n\n\tgit -C repo worktree add ../worktree &&\n\tgit -C repo pack-refs &&\n\tgit -C worktree pack-refs &&\n\ttest_line_count = 1 repo/.git/worktrees/worktree/reftable/tables.list &&\n\ttest_line_count = 1 repo/.git/reftable/tables.list &&\n\n\tGIT_TEST_REFTABLE_AUTOCOMPACTION=false \\\n\tgit -C worktree update-ref refs/heads/shared HEAD &&\n\ttest_line_count = 1 repo/.git/worktrees/worktree/reftable/tables.list &&\n\ttest_line_count = 2 repo/.git/reftable/tables.list\n'\n\ntest_expect_success 'worktree: creating per-worktree ref updates worktree stack' '\n\ttest_when_finished \"rm -rf repo worktree\" &&\n\tgit init repo &&\n\ttest_commit -C repo A &&\n\n\tgit -C repo worktree add ../worktree &&\n\tgit -C repo pack-refs &&\n\tgit -C worktree pack-refs &&\n\ttest_line_count = 1 repo/.git/worktrees/worktree/reftable/tables.list &&\n\ttest_line_count = 1 repo/.git/reftable/tables.list &&\n\n\tgit -C worktree update-ref refs/bisect/per-worktree HEAD &&\n\ttest_line_count = 2 repo/.git/worktrees/worktree/reftable/tables.list &&\n\ttest_line_count = 1 repo/.git/reftable/tables.list\n'\n\ntest_expect_success 'worktree: creating per-worktree ref from main repo' '\n\ttest_when_finished \"rm -rf repo worktree\" &&\n\tgit init repo &&\n\ttest_commit -C repo A &&\n\n\tgit -C repo worktree add ../worktree &&\n\tgit -C repo pack-refs &&\n\tgit -C worktree pack-refs &&\n\ttest_line_count = 1 repo/.git/worktrees/worktree/reftable/tables.list &&\n\ttest_line_count = 1 repo/.git/reftable/tables.list &&\n\n\tgit -C repo update-ref worktrees/worktree/refs/bisect/per-worktree HEAD &&\n\ttest_line_count = 2 repo/.git/worktrees/worktree/reftable/tables.list &&\n\ttest_line_count = 1 repo/.git/reftable/tables.list\n'\n\ntest_expect_success 'worktree: creating per-worktree ref from second worktree' '\n\ttest_when_finished \"rm -rf repo wt1 wt2\" &&\n\tgit init repo &&\n\ttest_commit -C repo A &&\n\n\tgit -C repo worktree add ../wt1 &&\n\tgit -C repo worktree add ../wt2 &&\n\tgit -C repo pack-refs &&\n\tgit -C wt1 pack-refs &&\n\tgit -C wt2 pack-refs &&\n\ttest_line_count = 1 repo/.git/worktrees/wt1/reftable/tables.list &&\n\ttest_line_count = 1 repo/.git/worktrees/wt2/reftable/tables.list &&\n\ttest_line_count = 1 repo/.git/reftable/tables.list &&\n\n\tgit -C wt1 update-ref worktrees/wt2/refs/bisect/per-worktree HEAD &&\n\ttest_line_count = 1 repo/.git/worktrees/wt1/reftable/tables.list &&\n\ttest_line_count = 2 repo/.git/worktrees/wt2/reftable/tables.list &&\n\ttest_line_count = 1 repo/.git/reftable/tables.list\n'\n\ntest_expect_success 'worktree: can create shared and per-worktree ref in one transaction' '\n\ttest_when_finished \"rm -rf repo worktree\" &&\n\tgit init repo &&\n\ttest_commit -C repo A &&\n\n\tgit -C repo worktree add ../worktree &&\n\tgit -C repo pack-refs &&\n\tgit -C worktree pack-refs &&\n\ttest_line_count = 1 repo/.git/worktrees/worktree/reftable/tables.list &&\n\ttest_line_count = 1 repo/.git/reftable/tables.list &&\n\n\tcat >stdin <<-EOF &&\n\tcreate worktrees/worktree/refs/bisect/per-worktree HEAD\n\tcreate refs/branches/shared HEAD\n\tEOF\n\tgit -C repo update-ref --stdin <stdin &&\n\ttest_line_count = 2 repo/.git/worktrees/worktree/reftable/tables.list &&\n\ttest_line_count = 2 repo/.git/reftable/tables.list\n'\n\ntest_expect_success 'worktree: can access common refs' '\n\ttest_when_finished \"rm -rf repo worktree\" &&\n\tgit init repo &&\n\ttest_commit -C repo file1 &&\n\tgit -C repo branch branch1 &&\n\tgit -C repo worktree add ../worktree &&\n\n\techo refs/heads/worktree >expect &&\n\tgit -C worktree symbolic-ref HEAD >actual &&\n\ttest_cmp expect actual &&\n\tgit -C worktree checkout branch1\n'\n\ntest_expect_success 'worktree: adds worktree with detached HEAD' '\n\ttest_when_finished \"rm -rf repo worktree\" &&\n\n\tgit init repo &&\n\ttest_commit -C repo A &&\n\tgit -C repo rev-parse main >expect &&\n\n\tgit -C repo worktree add --detach ../worktree main &&\n\tgit -C worktree rev-parse HEAD >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'fetch: accessing FETCH_HEAD special ref works' '\n\ttest_when_finished \"rm -rf repo sub\" &&\n\n\tgit init sub &&\n\ttest_commit -C sub two &&\n\tgit -C sub rev-parse HEAD >expect &&\n\n\tgit init repo &&\n\ttest_commit -C repo one &&\n\tgit -C repo fetch ../sub &&\n\tgit -C repo rev-parse FETCH_HEAD >actual &&\n\ttest_cmp expect actual\n'\n\ntest_done\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "002a75dee85f55ec5b77fe371ab06def72fe5216",
  "sha1_ok": true,
  "size": 32104
}
