{
  "content": {
    "base64": "I2lmbmRlZiBHSVRfQ09NUEFUX1VUSUxfSAojZGVmaW5lIEdJVF9DT01QQVRfVVRJTF9ICgojZGVmaW5lIF9GSUxFX09GRlNFVF9CSVRTIDY0CgojaWZuZGVmIEZMRVhfQVJSQVkKLyoKICogU2VlIGlmIG91ciBjb21waWxlciBpcyBrbm93biB0byBzdXBwb3J0IGZsZXhpYmxlIGFycmF5IG1lbWJlcnMuCiAqLwojaWYgZGVmaW5lZChfX1NURENfVkVSU0lPTl9fKSAmJiAoX19TVERDX1ZFUlNJT05fXyA+PSAxOTk5MDFMKSAmJiAoIWRlZmluZWQoX19TVU5QUk9fQykgfHwgKF9fU1VOUFJPX0MgPiAweDU4MCkpCiMgZGVmaW5lIEZMRVhfQVJSQVkgLyogZW1wdHkgKi8KI2VsaWYgZGVmaW5lZChfX0dOVUNfXykKIyBpZiAoX19HTlVDX18gPj0gMykKIyAgZGVmaW5lIEZMRVhfQVJSQVkgLyogZW1wdHkgKi8KIyBlbHNlCiMgIGRlZmluZSBGTEVYX0FSUkFZIDAgLyogb2xkZXIgR05VIGV4dGVuc2lvbiAqLwojIGVuZGlmCiNlbmRpZgoKLyoKICogT3RoZXJ3aXNlLCBkZWZhdWx0IHRvIHNhZmVyIGJ1dCBhIGJpdCB3YXN0ZWZ1bCB0cmFkaXRpb25hbCBzdHlsZQogKi8KI2lmbmRlZiBGTEVYX0FSUkFZCiMgZGVmaW5lIEZMRVhfQVJSQVkgMQojZW5kaWYKI2VuZGlmCgojZGVmaW5lIEFSUkFZX1NJWkUoeCkgKHNpemVvZih4KS9zaXplb2YoeFswXSkpCiNkZWZpbmUgYml0c2l6ZW9mKHgpICAoQ0hBUl9CSVQgKiBzaXplb2YoeCkpCgojaWZkZWYgX19HTlVDX18KI2RlZmluZSBUWVBFT0YoeCkgKF9fdHlwZW9mX18oeCkpCiNlbHNlCiNkZWZpbmUgVFlQRU9GKHgpCiNlbmRpZgoKI2RlZmluZSBNU0IoeCwgYml0cykgKCh4KSAmIFRZUEVPRih4KSh+MFVMTCA8PCAoYml0c2l6ZW9mKHgpIC0gKGJpdHMpKSkpCiNkZWZpbmUgSEFTX01VTFRJX0JJVFMoaSkgICgoaSkgJiAoKGkpIC0gMSkpICAvKiBjaGVja3MgaWYgYW4gaW50ZWdlciBoYXMgbW9yZSB0aGFuIDEgYml0IHNldCAqLwoKI2RlZmluZSBESVZfUk9VTkRfVVAobixkKSAoKChuKSArIChkKSAtIDEpIC8gKGQpKQoKLyogQXBwcm94aW1hdGlvbiBvZiB0aGUgbGVuZ3RoIG9mIHRoZSBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS4gKi8KI2RlZmluZSBkZWNpbWFsX2xlbmd0aCh4KQkoKGludCkoc2l6ZW9mKHgpICogMi41NiArIDAuNSkgKyAxKQoKI2lmIGRlZmluZWQoX19zdW5fXykKIC8qCiAgKiBPbiBTb2xhcmlzLCB3aGVuIF9YT1BFTl9FWFRFTkRFRCBpcyBzZXQsIGl0cyBoZWFkZXIgZmlsZQogICogZm9yY2VzIHRoZSBwcm9ncmFtcyB0byBiZSBYUEc0djIsIGRlZmVhdGluZyBhbnkgX1hPUEVOX1NPVVJDRQogICogc2V0dGluZyB0byBzYXkgd2UgYXJlIFhQRzUgb3IgWFBHNi4gIEFsc28gb24gU29sYXJpcywKICAqIFhQRzYgcHJvZ3JhbXMgbXVzdCBiZSBjb21waWxlZCB3aXRoIGEgYzk5IGNvbXBpbGVyLCB3aGlsZQogICogbm9uIFhQRzYgcHJvZ3JhbXMgbXVzdCBiZSBjb21waWxlZCB3aXRoIGEgcHJlLWM5OSBjb21waWxlci4KICAqLwojIGlmIF9fU1REQ19WRVJTSU9OX18gLSAwID49IDE5OTkwMUwKIyBkZWZpbmUgX1hPUEVOX1NPVVJDRSA2MDAKIyBlbHNlCiMgZGVmaW5lIF9YT1BFTl9TT1VSQ0UgNTAwCiMgZW5kaWYKI2VsaWYgIWRlZmluZWQoX19BUFBMRV9fKSAmJiAhZGVmaW5lZChfX0ZyZWVCU0RfXykgICYmICFkZWZpbmVkKF9fVVNMQ19fKSAmJiAhZGVmaW5lZChfTV9VTklYKSAmJiAhZGVmaW5lZChzZ2kpCiNkZWZpbmUgX1hPUEVOX1NPVVJDRSA2MDAgLyogZ2xpYmMyIGFuZCBBSVggNS4zTCBuZWVkIDUwMCwgT3BlbkJTRCBuZWVkcyA2MDAgZm9yIFNfSVNMTksoKSAqLwojaWZuZGVmIF9fc3VuX18KI2RlZmluZSBfWE9QRU5fU09VUkNFX0VYVEVOREVEIDEgLyogQUlYIDUuM0wgbmVlZHMgdGhpcyAqLwojZW5kaWYKI2VuZGlmCiNkZWZpbmUgX0FMTF9TT1VSQ0UgMQojZGVmaW5lIF9HTlVfU09VUkNFIDEKI2RlZmluZSBfQlNEX1NPVVJDRSAxCiNkZWZpbmUgX05FVEJTRF9TT1VSQ0UgMQojZGVmaW5lIF9TR0lfU09VUkNFIDEKCiNpbmNsdWRlIDx1bmlzdGQuaD4KI2luY2x1ZGUgPHN0ZGlvLmg+CiNpbmNsdWRlIDxzeXMvc3RhdC5oPgojaW5jbHVkZSA8ZmNudGwuaD4KI2luY2x1ZGUgPHN0ZGRlZi5oPgojaW5jbHVkZSA8c3RkbGliLmg+CiNpbmNsdWRlIDxzdGRhcmcuaD4KI2luY2x1ZGUgPHN0cmluZy5oPgojaW5jbHVkZSA8ZXJybm8uaD4KI2luY2x1ZGUgPGxpbWl0cy5oPgojaW5jbHVkZSA8c3lzL3BhcmFtLmg+CiNpbmNsdWRlIDxzeXMvdHlwZXMuaD4KI2luY2x1ZGUgPGRpcmVudC5oPgojaW5jbHVkZSA8c3lzL3RpbWUuaD4KI2luY2x1ZGUgPHRpbWUuaD4KI2luY2x1ZGUgPHNpZ25hbC5oPgojaW5jbHVkZSA8Zm5tYXRjaC5oPgojaW5jbHVkZSA8YXNzZXJ0Lmg+CiNpbmNsdWRlIDxyZWdleC5oPgojaW5jbHVkZSA8dXRpbWUuaD4KI2lmbmRlZiBfX01JTkdXMzJfXwojaW5jbHVkZSA8c3lzL3dhaXQuaD4KI2luY2x1ZGUgPHN5cy9wb2xsLmg+CiNpbmNsdWRlIDxzeXMvc29ja2V0Lmg+CiNpbmNsdWRlIDxzeXMvaW9jdGwuaD4KI2lmbmRlZiBOT19TWVNfU0VMRUNUX0gKI2luY2x1ZGUgPHN5cy9zZWxlY3QuaD4KI2VuZGlmCiNpbmNsdWRlIDxuZXRpbmV0L2luLmg+CiNpbmNsdWRlIDxuZXRpbmV0L3RjcC5oPgojaW5jbHVkZSA8YXJwYS9pbmV0Lmg+CiNpbmNsdWRlIDxuZXRkYi5oPgojaW5jbHVkZSA8cHdkLmg+CiNpbmNsdWRlIDxpbnR0eXBlcy5oPgojaWYgZGVmaW5lZChfX0NZR1dJTl9fKQojdW5kZWYgX1hPUEVOX1NPVVJDRQojaW5jbHVkZSA8Z3JwLmg+CiNkZWZpbmUgX1hPUEVOX1NPVVJDRSA2MDAKI2luY2x1ZGUgImNvbXBhdC9jeWd3aW4uaCIKI2Vsc2UKI3VuZGVmIF9BTExfU09VUkNFIC8qIEFJWCA1LjNMIGRlZmluZXMgYSBzdHJ1Y3QgbGlzdCB3aXRoIF9BTExfU09VUkNFLiAqLwojaW5jbHVkZSA8Z3JwLmg+CiNkZWZpbmUgX0FMTF9TT1VSQ0UgMQojZW5kaWYKI2Vsc2UgCS8qIF9fTUlOR1czMl9fICovCi8qIHB1bGwgaW4gV2luZG93cyBjb21wYXRpYmlsaXR5IHN0dWZmICovCiNpbmNsdWRlICJjb21wYXQvbWluZ3cuaCIKI2VuZGlmCS8qIF9fTUlOR1czMl9fICovCgojaWZuZGVmIE5PX0xJQkdFTl9ICiNpbmNsdWRlIDxsaWJnZW4uaD4KI2Vsc2UKI2RlZmluZSBiYXNlbmFtZSBnaXRiYXNlbmFtZQpleHRlcm4gY2hhciAqZ2l0YmFzZW5hbWUoY2hhciAqKTsKI2VuZGlmCgojaWZuZGVmIE5PX0lDT05WCiNpbmNsdWRlIDxpY29udi5oPgojZW5kaWYKCiNpZm5kZWYgTk9fT1BFTlNTTAojaW5jbHVkZSA8b3BlbnNzbC9zc2wuaD4KI2luY2x1ZGUgPG9wZW5zc2wvZXJyLmg+CiNlbmRpZgoKLyogT24gbW9zdCBzeXN0ZW1zIDxsaW1pdHMuaD4gd291bGQgaGF2ZSBnaXZlbiB1cyB0aGlzLCBidXQKICogbm90IG9uIHNvbWUgc3lzdGVtcyAoZS5nLiBHTlUvSHVyZCkuCiAqLwojaWZuZGVmIFBBVEhfTUFYCiNkZWZpbmUgUEFUSF9NQVggNDA5NgojZW5kaWYKCiNpZm5kZWYgUFJJdU1BWAojZGVmaW5lIFBSSXVNQVggImxsdSIKI2VuZGlmCgojaWZuZGVmIFBSSXUzMgojZGVmaW5lIFBSSXUzMiAidSIKI2VuZGlmCgojaWZuZGVmIFBSSXgzMgojZGVmaW5lIFBSSXgzMiAieCIKI2VuZGlmCgojaWZuZGVmIFBBVEhfU0VQCiNkZWZpbmUgUEFUSF9TRVAgJzonCiNlbmRpZgoKI2lmbmRlZiBTVFJJUF9FWFRFTlNJT04KI2RlZmluZSBTVFJJUF9FWFRFTlNJT04gIiIKI2VuZGlmCgojaWZuZGVmIGhhc19kb3NfZHJpdmVfcHJlZml4CiNkZWZpbmUgaGFzX2Rvc19kcml2ZV9wcmVmaXgocGF0aCkgMAojZW5kaWYKCiNpZm5kZWYgaXNfZGlyX3NlcAojZGVmaW5lIGlzX2Rpcl9zZXAoYykgKChjKSA9PSAnLycpCiNlbmRpZgoKI2lmZGVmIF9fR05VQ19fCiNkZWZpbmUgTk9SRVRVUk4gX19hdHRyaWJ1dGVfXygoX19ub3JldHVybl9fKSkKI2Vsc2UKI2RlZmluZSBOT1JFVFVSTgojaWZuZGVmIF9fYXR0cmlidXRlX18KI2RlZmluZSBfX2F0dHJpYnV0ZV9fKHgpCiNlbmRpZgojZW5kaWYKCiNpbmNsdWRlICJjb21wYXQvYnN3YXAuaCIKCi8qIEdlbmVyYWwgaGVscGVyIGZ1bmN0aW9ucyAqLwpleHRlcm4gdm9pZCB1c2FnZShjb25zdCBjaGFyICplcnIpIE5PUkVUVVJOOwpleHRlcm4gdm9pZCBkaWUoY29uc3QgY2hhciAqZXJyLCAuLi4pIE5PUkVUVVJOIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwpleHRlcm4gdm9pZCBkaWVfZXJybm8oY29uc3QgY2hhciAqZXJyLCAuLi4pIE5PUkVUVVJOIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwpleHRlcm4gaW50IGVycm9yKGNvbnN0IGNoYXIgKmVyciwgLi4uKSBfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMSwgMikpKTsKZXh0ZXJuIHZvaWQgd2FybmluZyhjb25zdCBjaGFyICplcnIsIC4uLikgX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsIDEsIDIpKSk7CgpleHRlcm4gdm9pZCBzZXRfZGllX3JvdXRpbmUodm9pZCAoKnJvdXRpbmUpKGNvbnN0IGNoYXIgKmVyciwgdmFfbGlzdCBwYXJhbXMpIE5PUkVUVVJOKTsKCmV4dGVybiBpbnQgcHJlZml4Y21wKGNvbnN0IGNoYXIgKnN0ciwgY29uc3QgY2hhciAqcHJlZml4KTsKZXh0ZXJuIHRpbWVfdCB0bV90b190aW1lX3QoY29uc3Qgc3RydWN0IHRtICp0bSk7CgpzdGF0aWMgaW5saW5lIGNvbnN0IGNoYXIgKnNraXBfcHJlZml4KGNvbnN0IGNoYXIgKnN0ciwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzaXplX3QgbGVuID0gc3RybGVuKHByZWZpeCk7CglyZXR1cm4gc3RybmNtcChzdHIsIHByZWZpeCwgbGVuKSA/IE5VTEwgOiBzdHIgKyBsZW47Cn0KCiNpZiBkZWZpbmVkKE5PX01NQVApIHx8IGRlZmluZWQoVVNFX1dJTjMyX01NQVApCgojaWZuZGVmIFBST1RfUkVBRAojZGVmaW5lIFBST1RfUkVBRCAxCiNkZWZpbmUgUFJPVF9XUklURSAyCiNkZWZpbmUgTUFQX1BSSVZBVEUgMQojZGVmaW5lIE1BUF9GQUlMRUQgKCh2b2lkKiktMSkKI2VuZGlmCgojZGVmaW5lIG1tYXAgZ2l0X21tYXAKI2RlZmluZSBtdW5tYXAgZ2l0X211bm1hcApleHRlcm4gdm9pZCAqZ2l0X21tYXAodm9pZCAqc3RhcnQsIHNpemVfdCBsZW5ndGgsIGludCBwcm90LCBpbnQgZmxhZ3MsIGludCBmZCwgb2ZmX3Qgb2Zmc2V0KTsKZXh0ZXJuIGludCBnaXRfbXVubWFwKHZvaWQgKnN0YXJ0LCBzaXplX3QgbGVuZ3RoKTsKCiNlbHNlIC8qIE5PX01NQVAgfHwgVVNFX1dJTjMyX01NQVAgKi8KCiNpbmNsdWRlIDxzeXMvbW1hbi5oPgoKI2VuZGlmIC8qIE5PX01NQVAgfHwgVVNFX1dJTjMyX01NQVAgKi8KCiNpZmRlZiBOT19NTUFQCgovKiBUaGlzIHZhbHVlIG11c3QgYmUgbXVsdGlwbGUgb2YgKHBhZ2VzaXplICogMikgKi8KI2RlZmluZSBERUZBVUxUX1BBQ0tFRF9HSVRfV0lORE9XX1NJWkUgKDEgKiAxMDI0ICogMTAyNCkKCiNlbHNlIC8qIE5PX01NQVAgKi8KCi8qIFRoaXMgdmFsdWUgbXVzdCBiZSBtdWx0aXBsZSBvZiAocGFnZXNpemUgKiAyKSAqLwojZGVmaW5lIERFRkFVTFRfUEFDS0VEX0dJVF9XSU5ET1dfU0laRSBcCgkoc2l6ZW9mKHZvaWQqKSA+PSA4IFwKCQk/ICAxICogMTAyNCAqIDEwMjQgKiAxMDI0IFwKCQk6IDMyICogMTAyNCAqIDEwMjQpCgojZW5kaWYgLyogTk9fTU1BUCAqLwoKI2lmZGVmIE5PX1NUX0JMT0NLU19JTl9TVFJVQ1RfU1RBVAojZGVmaW5lIG9uX2Rpc2tfYnl0ZXMoc3QpICgoc3QpLnN0X3NpemUpCiNlbHNlCiNkZWZpbmUgb25fZGlza19ieXRlcyhzdCkgKChzdCkuc3RfYmxvY2tzICogNTEyKQojZW5kaWYKCiNkZWZpbmUgREVGQVVMVF9QQUNLRURfR0lUX0xJTUlUIFwKCSgoMTAyNEwgKiAxMDI0TCkgKiAoc2l6ZW9mKHZvaWQqKSA+PSA4ID8gODE5MiA6IDI1NikpCgojaWZkZWYgTk9fUFJFQUQKI2RlZmluZSBwcmVhZCBnaXRfcHJlYWQKZXh0ZXJuIHNzaXplX3QgZ2l0X3ByZWFkKGludCBmZCwgdm9pZCAqYnVmLCBzaXplX3QgY291bnQsIG9mZl90IG9mZnNldCk7CiNlbmRpZgovKgogKiBGb3J3YXJkIGRlY2wgdGhhdCB3aWxsIHJlbWluZCB1cyBpZiBpdHMgdHdpbiBpbiBjYWNoZS5oIGNoYW5nZXMuCiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbiBjb21wYXQvcHJlYWQuYy4gIEJ1dCB3ZSBjYW4ndCBpbmNsdWRlCiAqIGNhY2hlLmggdGhlcmUuCiAqLwpleHRlcm4gc3NpemVfdCByZWFkX2luX2Z1bGwoaW50IGZkLCB2b2lkICpidWYsIHNpemVfdCBjb3VudCk7CgojaWZkZWYgTk9fU0VURU5WCiNkZWZpbmUgc2V0ZW52IGdpdHNldGVudgpleHRlcm4gaW50IGdpdHNldGVudihjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKiwgaW50KTsKI2VuZGlmCgojaWZkZWYgTk9fTUtEVEVNUAojZGVmaW5lIG1rZHRlbXAgZ2l0bWtkdGVtcApleHRlcm4gY2hhciAqZ2l0bWtkdGVtcChjaGFyICopOwojZW5kaWYKCiNpZmRlZiBOT19NS1NURU1QUwojZGVmaW5lIG1rc3RlbXBzIGdpdG1rc3RlbXBzCmV4dGVybiBpbnQgZ2l0bWtzdGVtcHMoY2hhciAqLCBpbnQpOwojZW5kaWYKCiNpZmRlZiBOT19VTlNFVEVOVgojZGVmaW5lIHVuc2V0ZW52IGdpdHVuc2V0ZW52CmV4dGVybiB2b2lkIGdpdHVuc2V0ZW52KGNvbnN0IGNoYXIgKik7CiNlbmRpZgoKI2lmZGVmIE5PX1NUUkNBU0VTVFIKI2RlZmluZSBzdHJjYXNlc3RyIGdpdHN0cmNhc2VzdHIKZXh0ZXJuIGNoYXIgKmdpdHN0cmNhc2VzdHIoY29uc3QgY2hhciAqaGF5c3RhY2ssIGNvbnN0IGNoYXIgKm5lZWRsZSk7CiNlbmRpZgoKI2lmZGVmIE5PX1NUUkxDUFkKI2RlZmluZSBzdHJsY3B5IGdpdHN0cmxjcHkKZXh0ZXJuIHNpemVfdCBnaXRzdHJsY3B5KGNoYXIgKiwgY29uc3QgY2hhciAqLCBzaXplX3QpOwojZW5kaWYKCiNpZmRlZiBOT19TVFJUT1VNQVgKI2RlZmluZSBzdHJ0b3VtYXggZ2l0c3RydG91bWF4CmV4dGVybiB1aW50bWF4X3QgZ2l0c3RydG91bWF4KGNvbnN0IGNoYXIgKiwgY2hhciAqKiwgaW50KTsKI2VuZGlmCgojaWZkZWYgTk9fSFNUUkVSUk9SCiNkZWZpbmUgaHN0cmVycm9yIGdpdGhzdHJlcnJvcgpleHRlcm4gY29uc3QgY2hhciAqZ2l0aHN0cmVycm9yKGludCBoZXJyb3IpOwojZW5kaWYKCiNpZmRlZiBOT19NRU1NRU0KI2RlZmluZSBtZW1tZW0gZ2l0bWVtbWVtCnZvaWQgKmdpdG1lbW1lbShjb25zdCB2b2lkICpoYXlzdGFjaywgc2l6ZV90IGhheXN0YWNrbGVuLAogICAgICAgICAgICAgICAgY29uc3Qgdm9pZCAqbmVlZGxlLCBzaXplX3QgbmVlZGxlbGVuKTsKI2VuZGlmCgojaWZkZWYgRlJFQURfUkVBRFNfRElSRUNUT1JJRVMKI2lmZGVmIGZvcGVuCiN1bmRlZiBmb3BlbgojZW5kaWYKI2RlZmluZSBmb3BlbihhLGIpIGdpdF9mb3BlbihhLGIpCmV4dGVybiBGSUxFICpnaXRfZm9wZW4oY29uc3QgY2hhciosIGNvbnN0IGNoYXIqKTsKI2VuZGlmCgojaWZkZWYgU05QUklOVEZfUkVUVVJOU19CT0dVUwojZGVmaW5lIHNucHJpbnRmIGdpdF9zbnByaW50ZgpleHRlcm4gaW50IGdpdF9zbnByaW50ZihjaGFyICpzdHIsIHNpemVfdCBtYXhzaXplLAoJCQljb25zdCBjaGFyICpmb3JtYXQsIC4uLik7CiNkZWZpbmUgdnNucHJpbnRmIGdpdF92c25wcmludGYKZXh0ZXJuIGludCBnaXRfdnNucHJpbnRmKGNoYXIgKnN0ciwgc2l6ZV90IG1heHNpemUsCgkJCSBjb25zdCBjaGFyICpmb3JtYXQsIHZhX2xpc3QgYXApOwojZW5kaWYKCiNpZmRlZiBfX0dMSUJDX1BSRVJFUQojaWYgX19HTElCQ19QUkVSRVEoMiwgMSkKI2RlZmluZSBIQVZFX1NUUkNIUk5VTAojZW5kaWYKI2VuZGlmCgojaWZuZGVmIEhBVkVfU1RSQ0hSTlVMCiNkZWZpbmUgc3RyY2hybnVsIGdpdHN0cmNocm51bApzdGF0aWMgaW5saW5lIGNoYXIgKmdpdHN0cmNocm51bChjb25zdCBjaGFyICpzLCBpbnQgYykKewoJd2hpbGUgKCpzICYmICpzICE9IGMpCgkJcysrOwoJcmV0dXJuIChjaGFyICopczsKfQojZW5kaWYKCmV4dGVybiB2b2lkIHJlbGVhc2VfcGFja19tZW1vcnkoc2l6ZV90LCBpbnQpOwoKZXh0ZXJuIGNoYXIgKnhzdHJkdXAoY29uc3QgY2hhciAqc3RyKTsKZXh0ZXJuIHZvaWQgKnhtYWxsb2Moc2l6ZV90IHNpemUpOwpleHRlcm4gdm9pZCAqeG1lbWR1cHooY29uc3Qgdm9pZCAqZGF0YSwgc2l6ZV90IGxlbik7CmV4dGVybiBjaGFyICp4c3RybmR1cChjb25zdCBjaGFyICpzdHIsIHNpemVfdCBsZW4pOwpleHRlcm4gdm9pZCAqeHJlYWxsb2Modm9pZCAqcHRyLCBzaXplX3Qgc2l6ZSk7CmV4dGVybiB2b2lkICp4Y2FsbG9jKHNpemVfdCBubWVtYiwgc2l6ZV90IHNpemUpOwpleHRlcm4gdm9pZCAqeG1tYXAodm9pZCAqc3RhcnQsIHNpemVfdCBsZW5ndGgsIGludCBwcm90LCBpbnQgZmxhZ3MsIGludCBmZCwgb2ZmX3Qgb2Zmc2V0KTsKZXh0ZXJuIHNzaXplX3QgeHJlYWQoaW50IGZkLCB2b2lkICpidWYsIHNpemVfdCBsZW4pOwpleHRlcm4gc3NpemVfdCB4d3JpdGUoaW50IGZkLCBjb25zdCB2b2lkICpidWYsIHNpemVfdCBsZW4pOwpleHRlcm4gaW50IHhkdXAoaW50IGZkKTsKZXh0ZXJuIEZJTEUgKnhmZG9wZW4oaW50IGZkLCBjb25zdCBjaGFyICptb2RlKTsKZXh0ZXJuIGludCB4bWtzdGVtcChjaGFyICp0ZW1wbGF0ZSk7CmV4dGVybiBpbnQgb2RiX21rc3RlbXAoY2hhciAqdGVtcGxhdGUsIHNpemVfdCBsaW1pdCwgY29uc3QgY2hhciAqcGF0dGVybik7CmV4dGVybiBpbnQgb2RiX3BhY2tfa2VlcChjaGFyICpuYW1lLCBzaXplX3QgbmFtZXN6LCB1bnNpZ25lZCBjaGFyICpzaGExKTsKCnN0YXRpYyBpbmxpbmUgc2l6ZV90IHhzaXplX3Qob2ZmX3QgbGVuKQp7CglyZXR1cm4gKHNpemVfdClsZW47Cn0KCnN0YXRpYyBpbmxpbmUgaW50IGhhc19leHRlbnNpb24oY29uc3QgY2hhciAqZmlsZW5hbWUsIGNvbnN0IGNoYXIgKmV4dCkKewoJc2l6ZV90IGxlbiA9IHN0cmxlbihmaWxlbmFtZSk7CglzaXplX3QgZXh0bGVuID0gc3RybGVuKGV4dCk7CglyZXR1cm4gbGVuID4gZXh0bGVuICYmICFtZW1jbXAoZmlsZW5hbWUgKyBsZW4gLSBleHRsZW4sIGV4dCwgZXh0bGVuKTsKfQoKLyogU2FuZSBjdHlwZSAtIG5vIGxvY2FsZSwgYW5kIHdvcmtzIHdpdGggc2lnbmVkIGNoYXJzICovCiN1bmRlZiBpc2FzY2lpCiN1bmRlZiBpc3NwYWNlCiN1bmRlZiBpc2RpZ2l0CiN1bmRlZiBpc2FscGhhCiN1bmRlZiBpc2FsbnVtCiN1bmRlZiB0b2xvd2VyCiN1bmRlZiB0b3VwcGVyCmV4dGVybiB1bnNpZ25lZCBjaGFyIHNhbmVfY3R5cGVbMjU2XTsKI2RlZmluZSBHSVRfU1BBQ0UgMHgwMQojZGVmaW5lIEdJVF9ESUdJVCAweDAyCiNkZWZpbmUgR0lUX0FMUEhBIDB4MDQKI2RlZmluZSBHSVRfR0xPQl9TUEVDSUFMIDB4MDgKI2RlZmluZSBHSVRfUkVHRVhfU1BFQ0lBTCAweDEwCiNkZWZpbmUgc2FuZV9pc3Rlc3QoeCxtYXNrKSAoKHNhbmVfY3R5cGVbKHVuc2lnbmVkIGNoYXIpKHgpXSAmIChtYXNrKSkgIT0gMCkKI2RlZmluZSBpc2FzY2lpKHgpICgoKHgpICYgfjB4N2YpID09IDApCiNkZWZpbmUgaXNzcGFjZSh4KSBzYW5lX2lzdGVzdCh4LEdJVF9TUEFDRSkKI2RlZmluZSBpc2RpZ2l0KHgpIHNhbmVfaXN0ZXN0KHgsR0lUX0RJR0lUKQojZGVmaW5lIGlzYWxwaGEoeCkgc2FuZV9pc3Rlc3QoeCxHSVRfQUxQSEEpCiNkZWZpbmUgaXNhbG51bSh4KSBzYW5lX2lzdGVzdCh4LEdJVF9BTFBIQSB8IEdJVF9ESUdJVCkKI2RlZmluZSBpc19nbG9iX3NwZWNpYWwoeCkgc2FuZV9pc3Rlc3QoeCxHSVRfR0xPQl9TUEVDSUFMKQojZGVmaW5lIGlzX3JlZ2V4X3NwZWNpYWwoeCkgc2FuZV9pc3Rlc3QoeCxHSVRfR0xPQl9TUEVDSUFMIHwgR0lUX1JFR0VYX1NQRUNJQUwpCiNkZWZpbmUgdG9sb3dlcih4KSBzYW5lX2Nhc2UoKHVuc2lnbmVkIGNoYXIpKHgpLCAweDIwKQojZGVmaW5lIHRvdXBwZXIoeCkgc2FuZV9jYXNlKCh1bnNpZ25lZCBjaGFyKSh4KSwgMCkKCnN0YXRpYyBpbmxpbmUgaW50IHNhbmVfY2FzZShpbnQgeCwgaW50IGhpZ2gpCnsKCWlmIChzYW5lX2lzdGVzdCh4LCBHSVRfQUxQSEEpKQoJCXggPSAoeCAmIH4weDIwKSB8IGhpZ2g7CglyZXR1cm4geDsKfQoKc3RhdGljIGlubGluZSBpbnQgc3RydG91bF91aShjaGFyIGNvbnN0ICpzLCBpbnQgYmFzZSwgdW5zaWduZWQgaW50ICpyZXN1bHQpCnsKCXVuc2lnbmVkIGxvbmcgdWw7CgljaGFyICpwOwoKCWVycm5vID0gMDsKCXVsID0gc3RydG91bChzLCAmcCwgYmFzZSk7CglpZiAoZXJybm8gfHwgKnAgfHwgcCA9PSBzIHx8ICh1bnNpZ25lZCBpbnQpIHVsICE9IHVsKQoJCXJldHVybiAtMTsKCSpyZXN1bHQgPSB1bDsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW5saW5lIGludCBzdHJ0b2xfaShjaGFyIGNvbnN0ICpzLCBpbnQgYmFzZSwgaW50ICpyZXN1bHQpCnsKCWxvbmcgdWw7CgljaGFyICpwOwoKCWVycm5vID0gMDsKCXVsID0gc3RydG9sKHMsICZwLCBiYXNlKTsKCWlmIChlcnJubyB8fCAqcCB8fCBwID09IHMgfHwgKGludCkgdWwgIT0gdWwpCgkJcmV0dXJuIC0xOwoJKnJlc3VsdCA9IHVsOwoJcmV0dXJuIDA7Cn0KCiNpZmRlZiBJTlRFUk5BTF9RU09SVAp2b2lkIGdpdF9xc29ydCh2b2lkICpiYXNlLCBzaXplX3Qgbm1lbWIsIHNpemVfdCBzaXplLAoJICAgICAgIGludCgqY29tcGFyKShjb25zdCB2b2lkICosIGNvbnN0IHZvaWQgKikpOwojZGVmaW5lIHFzb3J0IGdpdF9xc29ydAojZW5kaWYKCiNpZm5kZWYgRElSX0hBU19CU0RfR1JPVVBfU0VNQU5USUNTCiMgZGVmaW5lIEZPUkNFX0RJUl9TRVRfR0lEIFNfSVNHSUQKI2Vsc2UKIyBkZWZpbmUgRk9SQ0VfRElSX1NFVF9HSUQgMAojZW5kaWYKCiNpZmRlZiBOT19OU0VDCiN1bmRlZiBVU0VfTlNFQwojZGVmaW5lIFNUX0NUSU1FX05TRUMoc3QpIDAKI2RlZmluZSBTVF9NVElNRV9OU0VDKHN0KSAwCiNlbHNlCiNpZmRlZiBVU0VfU1RfVElNRVNQRUMKI2RlZmluZSBTVF9DVElNRV9OU0VDKHN0KSAoKHVuc2lnbmVkIGludCkoKHN0KS5zdF9jdGltZXNwZWMudHZfbnNlYykpCiNkZWZpbmUgU1RfTVRJTUVfTlNFQyhzdCkgKCh1bnNpZ25lZCBpbnQpKChzdCkuc3RfbXRpbWVzcGVjLnR2X25zZWMpKQojZWxzZQojZGVmaW5lIFNUX0NUSU1FX05TRUMoc3QpICgodW5zaWduZWQgaW50KSgoc3QpLnN0X2N0aW0udHZfbnNlYykpCiNkZWZpbmUgU1RfTVRJTUVfTlNFQyhzdCkgKCh1bnNpZ25lZCBpbnQpKChzdCkuc3RfbXRpbS50dl9uc2VjKSkKI2VuZGlmCiNlbmRpZgoKI2lmZGVmIFVOUkVMSUFCTEVfRlNUQVQKI2RlZmluZSBmc3RhdF9pc19yZWxpYWJsZSgpIDAKI2Vsc2UKI2RlZmluZSBmc3RhdF9pc19yZWxpYWJsZSgpIDEKI2VuZGlmCgovKgogKiBQcmVzZXJ2ZXMgZXJybm8sIHByaW50cyBhIG1lc3NhZ2UsIGJ1dCBnaXZlcyBubyB3YXJuaW5nIGZvciBFTk9FTlQuCiAqIEFsd2F5cyByZXR1cm5zIHRoZSByZXR1cm4gdmFsdWUgb2YgdW5saW5rKDIpLgogKi8KaW50IHVubGlua19vcl93YXJuKGNvbnN0IGNoYXIgKnBhdGgpOwoKI2VuZGlmCg==",
    "text": "#ifndef GIT_COMPAT_UTIL_H\n#define GIT_COMPAT_UTIL_H\n\n#define _FILE_OFFSET_BITS 64\n\n#ifndef FLEX_ARRAY\n/*\n * See if our compiler is known to support flexible array members.\n */\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && (!defined(__SUNPRO_C) || (__SUNPRO_C > 0x580))\n# define FLEX_ARRAY /* empty */\n#elif defined(__GNUC__)\n# if (__GNUC__ >= 3)\n#  define FLEX_ARRAY /* empty */\n# else\n#  define FLEX_ARRAY 0 /* older GNU extension */\n# endif\n#endif\n\n/*\n * Otherwise, default to safer but a bit wasteful traditional style\n */\n#ifndef FLEX_ARRAY\n# define FLEX_ARRAY 1\n#endif\n#endif\n\n#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))\n#define bitsizeof(x)  (CHAR_BIT * sizeof(x))\n\n#ifdef __GNUC__\n#define TYPEOF(x) (__typeof__(x))\n#else\n#define TYPEOF(x)\n#endif\n\n#define MSB(x, bits) ((x) & TYPEOF(x)(~0ULL << (bitsizeof(x) - (bits))))\n#define HAS_MULTI_BITS(i)  ((i) & ((i) - 1))  /* checks if an integer has more than 1 bit set */\n\n#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))\n\n/* Approximation of the length of the decimal representation of this type. */\n#define decimal_length(x)\t((int)(sizeof(x) * 2.56 + 0.5) + 1)\n\n#if defined(__sun__)\n /*\n  * On Solaris, when _XOPEN_EXTENDED is set, its header file\n  * forces the programs to be XPG4v2, defeating any _XOPEN_SOURCE\n  * setting to say we are XPG5 or XPG6.  Also on Solaris,\n  * XPG6 programs must be compiled with a c99 compiler, while\n  * non XPG6 programs must be compiled with a pre-c99 compiler.\n  */\n# if __STDC_VERSION__ - 0 >= 199901L\n# define _XOPEN_SOURCE 600\n# else\n# define _XOPEN_SOURCE 500\n# endif\n#elif !defined(__APPLE__) && !defined(__FreeBSD__)  && !defined(__USLC__) && !defined(_M_UNIX) && !defined(sgi)\n#define _XOPEN_SOURCE 600 /* glibc2 and AIX 5.3L need 500, OpenBSD needs 600 for S_ISLNK() */\n#ifndef __sun__\n#define _XOPEN_SOURCE_EXTENDED 1 /* AIX 5.3L needs this */\n#endif\n#endif\n#define _ALL_SOURCE 1\n#define _GNU_SOURCE 1\n#define _BSD_SOURCE 1\n#define _NETBSD_SOURCE 1\n#define _SGI_SOURCE 1\n\n#include <unistd.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <limits.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <time.h>\n#include <signal.h>\n#include <fnmatch.h>\n#include <assert.h>\n#include <regex.h>\n#include <utime.h>\n#ifndef __MINGW32__\n#include <sys/wait.h>\n#include <sys/poll.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#ifndef NO_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <pwd.h>\n#include <inttypes.h>\n#if defined(__CYGWIN__)\n#undef _XOPEN_SOURCE\n#include <grp.h>\n#define _XOPEN_SOURCE 600\n#include \"compat/cygwin.h\"\n#else\n#undef _ALL_SOURCE /* AIX 5.3L defines a struct list with _ALL_SOURCE. */\n#include <grp.h>\n#define _ALL_SOURCE 1\n#endif\n#else \t/* __MINGW32__ */\n/* pull in Windows compatibility stuff */\n#include \"compat/mingw.h\"\n#endif\t/* __MINGW32__ */\n\n#ifndef NO_LIBGEN_H\n#include <libgen.h>\n#else\n#define basename gitbasename\nextern char *gitbasename(char *);\n#endif\n\n#ifndef NO_ICONV\n#include <iconv.h>\n#endif\n\n#ifndef NO_OPENSSL\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#endif\n\n/* On most systems <limits.h> would have given us this, but\n * not on some systems (e.g. GNU/Hurd).\n */\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\n#ifndef PRIuMAX\n#define PRIuMAX \"llu\"\n#endif\n\n#ifndef PRIu32\n#define PRIu32 \"u\"\n#endif\n\n#ifndef PRIx32\n#define PRIx32 \"x\"\n#endif\n\n#ifndef PATH_SEP\n#define PATH_SEP ':'\n#endif\n\n#ifndef STRIP_EXTENSION\n#define STRIP_EXTENSION \"\"\n#endif\n\n#ifndef has_dos_drive_prefix\n#define has_dos_drive_prefix(path) 0\n#endif\n\n#ifndef is_dir_sep\n#define is_dir_sep(c) ((c) == '/')\n#endif\n\n#ifdef __GNUC__\n#define NORETURN __attribute__((__noreturn__))\n#else\n#define NORETURN\n#ifndef __attribute__\n#define __attribute__(x)\n#endif\n#endif\n\n#include \"compat/bswap.h\"\n\n/* General helper functions */\nextern void usage(const char *err) NORETURN;\nextern void die(const char *err, ...) NORETURN __attribute__((format (printf, 1, 2)));\nextern void die_errno(const char *err, ...) NORETURN __attribute__((format (printf, 1, 2)));\nextern int error(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern void warning(const char *err, ...) __attribute__((format (printf, 1, 2)));\n\nextern void set_die_routine(void (*routine)(const char *err, va_list params) NORETURN);\n\nextern int prefixcmp(const char *str, const char *prefix);\nextern time_t tm_to_time_t(const struct tm *tm);\n\nstatic inline const char *skip_prefix(const char *str, const char *prefix)\n{\n\tsize_t len = strlen(prefix);\n\treturn strncmp(str, prefix, len) ? NULL : str + len;\n}\n\n#if defined(NO_MMAP) || defined(USE_WIN32_MMAP)\n\n#ifndef PROT_READ\n#define PROT_READ 1\n#define PROT_WRITE 2\n#define MAP_PRIVATE 1\n#define MAP_FAILED ((void*)-1)\n#endif\n\n#define mmap git_mmap\n#define munmap git_munmap\nextern void *git_mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nextern int git_munmap(void *start, size_t length);\n\n#else /* NO_MMAP || USE_WIN32_MMAP */\n\n#include <sys/mman.h>\n\n#endif /* NO_MMAP || USE_WIN32_MMAP */\n\n#ifdef NO_MMAP\n\n/* This value must be multiple of (pagesize * 2) */\n#define DEFAULT_PACKED_GIT_WINDOW_SIZE (1 * 1024 * 1024)\n\n#else /* NO_MMAP */\n\n/* This value must be multiple of (pagesize * 2) */\n#define DEFAULT_PACKED_GIT_WINDOW_SIZE \\\n\t(sizeof(void*) >= 8 \\\n\t\t?  1 * 1024 * 1024 * 1024 \\\n\t\t: 32 * 1024 * 1024)\n\n#endif /* NO_MMAP */\n\n#ifdef NO_ST_BLOCKS_IN_STRUCT_STAT\n#define on_disk_bytes(st) ((st).st_size)\n#else\n#define on_disk_bytes(st) ((st).st_blocks * 512)\n#endif\n\n#define DEFAULT_PACKED_GIT_LIMIT \\\n\t((1024L * 1024L) * (sizeof(void*) >= 8 ? 8192 : 256))\n\n#ifdef NO_PREAD\n#define pread git_pread\nextern ssize_t git_pread(int fd, void *buf, size_t count, off_t offset);\n#endif\n/*\n * Forward decl that will remind us if its twin in cache.h changes.\n * This function is used in compat/pread.c.  But we can't include\n * cache.h there.\n */\nextern ssize_t read_in_full(int fd, void *buf, size_t count);\n\n#ifdef NO_SETENV\n#define setenv gitsetenv\nextern int gitsetenv(const char *, const char *, int);\n#endif\n\n#ifdef NO_MKDTEMP\n#define mkdtemp gitmkdtemp\nextern char *gitmkdtemp(char *);\n#endif\n\n#ifdef NO_MKSTEMPS\n#define mkstemps gitmkstemps\nextern int gitmkstemps(char *, int);\n#endif\n\n#ifdef NO_UNSETENV\n#define unsetenv gitunsetenv\nextern void gitunsetenv(const char *);\n#endif\n\n#ifdef NO_STRCASESTR\n#define strcasestr gitstrcasestr\nextern char *gitstrcasestr(const char *haystack, const char *needle);\n#endif\n\n#ifdef NO_STRLCPY\n#define strlcpy gitstrlcpy\nextern size_t gitstrlcpy(char *, const char *, size_t);\n#endif\n\n#ifdef NO_STRTOUMAX\n#define strtoumax gitstrtoumax\nextern uintmax_t gitstrtoumax(const char *, char **, int);\n#endif\n\n#ifdef NO_HSTRERROR\n#define hstrerror githstrerror\nextern const char *githstrerror(int herror);\n#endif\n\n#ifdef NO_MEMMEM\n#define memmem gitmemmem\nvoid *gitmemmem(const void *haystack, size_t haystacklen,\n                const void *needle, size_t needlelen);\n#endif\n\n#ifdef FREAD_READS_DIRECTORIES\n#ifdef fopen\n#undef fopen\n#endif\n#define fopen(a,b) git_fopen(a,b)\nextern FILE *git_fopen(const char*, const char*);\n#endif\n\n#ifdef SNPRINTF_RETURNS_BOGUS\n#define snprintf git_snprintf\nextern int git_snprintf(char *str, size_t maxsize,\n\t\t\tconst char *format, ...);\n#define vsnprintf git_vsnprintf\nextern int git_vsnprintf(char *str, size_t maxsize,\n\t\t\t const char *format, va_list ap);\n#endif\n\n#ifdef __GLIBC_PREREQ\n#if __GLIBC_PREREQ(2, 1)\n#define HAVE_STRCHRNUL\n#endif\n#endif\n\n#ifndef HAVE_STRCHRNUL\n#define strchrnul gitstrchrnul\nstatic inline char *gitstrchrnul(const char *s, int c)\n{\n\twhile (*s && *s != c)\n\t\ts++;\n\treturn (char *)s;\n}\n#endif\n\nextern void release_pack_memory(size_t, int);\n\nextern char *xstrdup(const char *str);\nextern void *xmalloc(size_t size);\nextern void *xmemdupz(const void *data, size_t len);\nextern char *xstrndup(const char *str, size_t len);\nextern void *xrealloc(void *ptr, size_t size);\nextern void *xcalloc(size_t nmemb, size_t size);\nextern void *xmmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nextern ssize_t xread(int fd, void *buf, size_t len);\nextern ssize_t xwrite(int fd, const void *buf, size_t len);\nextern int xdup(int fd);\nextern FILE *xfdopen(int fd, const char *mode);\nextern int xmkstemp(char *template);\nextern int odb_mkstemp(char *template, size_t limit, const char *pattern);\nextern int odb_pack_keep(char *name, size_t namesz, unsigned char *sha1);\n\nstatic inline size_t xsize_t(off_t len)\n{\n\treturn (size_t)len;\n}\n\nstatic inline int has_extension(const char *filename, const char *ext)\n{\n\tsize_t len = strlen(filename);\n\tsize_t extlen = strlen(ext);\n\treturn len > extlen && !memcmp(filename + len - extlen, ext, extlen);\n}\n\n/* Sane ctype - no locale, and works with signed chars */\n#undef isascii\n#undef isspace\n#undef isdigit\n#undef isalpha\n#undef isalnum\n#undef tolower\n#undef toupper\nextern unsigned char sane_ctype[256];\n#define GIT_SPACE 0x01\n#define GIT_DIGIT 0x02\n#define GIT_ALPHA 0x04\n#define GIT_GLOB_SPECIAL 0x08\n#define GIT_REGEX_SPECIAL 0x10\n#define sane_istest(x,mask) ((sane_ctype[(unsigned char)(x)] & (mask)) != 0)\n#define isascii(x) (((x) & ~0x7f) == 0)\n#define isspace(x) sane_istest(x,GIT_SPACE)\n#define isdigit(x) sane_istest(x,GIT_DIGIT)\n#define isalpha(x) sane_istest(x,GIT_ALPHA)\n#define isalnum(x) sane_istest(x,GIT_ALPHA | GIT_DIGIT)\n#define is_glob_special(x) sane_istest(x,GIT_GLOB_SPECIAL)\n#define is_regex_special(x) sane_istest(x,GIT_GLOB_SPECIAL | GIT_REGEX_SPECIAL)\n#define tolower(x) sane_case((unsigned char)(x), 0x20)\n#define toupper(x) sane_case((unsigned char)(x), 0)\n\nstatic inline int sane_case(int x, int high)\n{\n\tif (sane_istest(x, GIT_ALPHA))\n\t\tx = (x & ~0x20) | high;\n\treturn x;\n}\n\nstatic inline int strtoul_ui(char const *s, int base, unsigned int *result)\n{\n\tunsigned long ul;\n\tchar *p;\n\n\terrno = 0;\n\tul = strtoul(s, &p, base);\n\tif (errno || *p || p == s || (unsigned int) ul != ul)\n\t\treturn -1;\n\t*result = ul;\n\treturn 0;\n}\n\nstatic inline int strtol_i(char const *s, int base, int *result)\n{\n\tlong ul;\n\tchar *p;\n\n\terrno = 0;\n\tul = strtol(s, &p, base);\n\tif (errno || *p || p == s || (int) ul != ul)\n\t\treturn -1;\n\t*result = ul;\n\treturn 0;\n}\n\n#ifdef INTERNAL_QSORT\nvoid git_qsort(void *base, size_t nmemb, size_t size,\n\t       int(*compar)(const void *, const void *));\n#define qsort git_qsort\n#endif\n\n#ifndef DIR_HAS_BSD_GROUP_SEMANTICS\n# define FORCE_DIR_SET_GID S_ISGID\n#else\n# define FORCE_DIR_SET_GID 0\n#endif\n\n#ifdef NO_NSEC\n#undef USE_NSEC\n#define ST_CTIME_NSEC(st) 0\n#define ST_MTIME_NSEC(st) 0\n#else\n#ifdef USE_ST_TIMESPEC\n#define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctimespec.tv_nsec))\n#define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtimespec.tv_nsec))\n#else\n#define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctim.tv_nsec))\n#define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtim.tv_nsec))\n#endif\n#endif\n\n#ifdef UNRELIABLE_FSTAT\n#define fstat_is_reliable() 0\n#else\n#define fstat_is_reliable() 1\n#endif\n\n/*\n * Preserves errno, prints a message, but gives no warning for ENOENT.\n * Always returns the return value of unlink(2).\n */\nint unlink_or_warn(const char *path);\n\n#endif\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "000859ed909a286e9caa8b703a2fd10e9c6dc76f",
  "sha1_ok": true,
  "size": 11305
}
