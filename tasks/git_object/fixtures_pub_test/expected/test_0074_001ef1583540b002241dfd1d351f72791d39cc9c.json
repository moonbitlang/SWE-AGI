{
  "content": {
    "base64": "I2lmbmRlZiBSRUZTX1JFRlNfSU5URVJOQUxfSAojZGVmaW5lIFJFRlNfUkVGU19JTlRFUk5BTF9ICgojaW5jbHVkZSAiY2FjaGUuaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgIml0ZXJhdG9yLmgiCgpzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uOwoKLyoKICogRGF0YSBzdHJ1Y3R1cmVzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZSBpbnRlcm5hbCB1c2Ugb2YgdGhlIHJlZnMKICogbW9kdWxlLiBDb2RlIG91dHNpZGUgb2YgdGhlIHJlZnMgbW9kdWxlIHNob3VsZCB1c2Ugb25seSB0aGUgcHVibGljCiAqIGZ1bmN0aW9ucyBkZWZpbmVkIGluICJyZWZzLmgiLCBhbmQgc2hvdWxkICpub3QqIGluY2x1ZGUgdGhpcyBmaWxlLgogKi8KCi8qCiAqIFRoZSBmb2xsb3dpbmcgZmxhZ3MgY2FuIGFwcGVhciBpbiBgcmVmX3VwZGF0ZTo6ZmxhZ3NgLiBUaGVpcgogKiBudW1lcmljYWwgdmFsdWVzIG11c3Qgbm90IGNvbmZsaWN0IHdpdGggdGhvc2Ugb2YgUkVGX05PX0RFUkVGIGFuZAogKiBSRUZfRk9SQ0VfQ1JFQVRFX1JFRkxPRywgd2hpY2ggYXJlIGFsc28gc3RvcmVkIGluCiAqIGByZWZfdXBkYXRlOjpmbGFnc2AuCiAqLwoKLyoKICogVGhlIHJlZmVyZW5jZSBzaG91bGQgYmUgdXBkYXRlZCB0byBuZXdfb2lkLgogKi8KI2RlZmluZSBSRUZfSEFWRV9ORVcgKDEgPDwgMikKCi8qCiAqIFRoZSBjdXJyZW50IHJlZmVyZW5jZSdzIHZhbHVlIHNob3VsZCBiZSBjaGVja2VkIHRvIG1ha2Ugc3VyZSB0aGF0CiAqIGl0IGFncmVlcyB3aXRoIG9sZF9vaWQuCiAqLwojZGVmaW5lIFJFRl9IQVZFX09MRCAoMSA8PCAzKQoKLyoKICogVXNlZCBhcyBhIGZsYWcgaW4gcmVmX3VwZGF0ZTo6ZmxhZ3Mgd2hlbiB3ZSB3YW50IHRvIGxvZyBhIHJlZgogKiB1cGRhdGUgYnV0IG5vdCBhY3R1YWxseSBwZXJmb3JtIGl0LiAgVGhpcyBpcyB1c2VkIHdoZW4gYSBzeW1ib2xpYwogKiByZWYgdXBkYXRlIGlzIHNwbGl0IHVwLgogKi8KI2RlZmluZSBSRUZfTE9HX09OTFkgKDEgPDwgNykKCi8qCiAqIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRpbWUgdG8gcmV0cnkgYWNxdWlyaW5nIGEgbG9vc2UgcmVmZXJlbmNlIGxvY2sKICogYmVmb3JlIGdpdmluZyB1cCwgaW4gbWlsbGlzZWNvbmRzOgogKi8KbG9uZyBnZXRfZmlsZXNfcmVmX2xvY2tfdGltZW91dF9tcyh2b2lkKTsKCi8qCiAqIFJldHVybiB0cnVlIGlmZiByZWZuYW1lIGlzIG1pbmltYWxseSBzYWZlLiAiU2FmZSIgaGVyZSBtZWFucyB0aGF0CiAqIGRlbGV0aW5nIGEgbG9vc2UgcmVmZXJlbmNlIGJ5IHRoaXMgbmFtZSB3aWxsIG5vdCBkbyBhbnkgZGFtYWdlLCBmb3IKICogZXhhbXBsZSBieSBjYXVzaW5nIGEgZmlsZSB0aGF0IGlzIG5vdCBhIHJlZmVyZW5jZSB0byBiZSBkZWxldGVkLgogKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNoZWNrIHRoYXQgdGhlIHJlZmVyZW5jZSBuYW1lIGlzIGxlZ2FsOyBmb3IKICogdGhhdCwgdXNlIGNoZWNrX3JlZm5hbWVfZm9ybWF0KCkuCiAqCiAqIEEgcmVmbmFtZSB0aGF0IHN0YXJ0cyB3aXRoICJyZWZzLyIgaXMgY29uc2lkZXJlZCBzYWZlIGlmZiBpdAogKiBkb2Vzbid0IGNvbnRhaW4gYW55ICIuIiBvciAiLi4iIGNvbXBvbmVudHMgb3IgY29uc2VjdXRpdmUgJy8nCiAqIGNoYXJhY3RlcnMsIGVuZCB3aXRoICcvJywgb3IgKG9uIFdpbmRvd3MpIGNvbnRhaW4gYW55ICdcJwogKiBjaGFyYWN0ZXJzLiBOYW1lcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoICJyZWZzLyIgYXJlIGNvbnNpZGVyZWQKICogc2FmZSBpZmYgdGhleSBjb25zaXN0IGVudGlyZWx5IG9mIHVwcGVyIGNhc2UgY2hhcmFjdGVycyBhbmQgJ18nCiAqIChsaWtlICJIRUFEIiBhbmQgIk1FUkdFX0hFQUQiIGJ1dCBub3QgImNvbmZpZyIgb3IgIkZPTy9CQVIiKS4KICovCmludCByZWZuYW1lX2lzX3NhZmUoY29uc3QgY2hhciAqcmVmbmFtZSk7CgovKgogKiBIZWxwZXIgZnVuY3Rpb246IHJldHVybiB0cnVlIGlmIHJlZm5hbWUsIHdoaWNoIGhhcyB0aGUgc3BlY2lmaWVkCiAqIG9pZCBhbmQgZmxhZ3MsIGNhbiBiZSByZXNvbHZlZCB0byBhbiBvYmplY3QgaW4gdGhlIGRhdGFiYXNlLiBJZiB0aGUKICogcmVmZXJyZWQtdG8gb2JqZWN0IGRvZXMgbm90IGV4aXN0LCBlbWl0IGEgd2FybmluZyBhbmQgcmV0dXJuIGZhbHNlLgogKi8KaW50IHJlZl9yZXNvbHZlc190b19vYmplY3QoY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJICAgc3RydWN0IHJlcG9zaXRvcnkgKnJlcG8sCgkJCSAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJICAgdW5zaWduZWQgaW50IGZsYWdzKTsKCmVudW0gcGVlbF9zdGF0dXMgewoJLyogb2JqZWN0IHdhcyBwZWVsZWQgc3VjY2Vzc2Z1bGx5OiAqLwoJUEVFTF9QRUVMRUQgPSAwLAoKCS8qCgkgKiBvYmplY3QgY2Fubm90IGJlIHBlZWxlZCBiZWNhdXNlIHRoZSBuYW1lZCBvYmplY3QgKG9yIGFuCgkgKiBvYmplY3QgcmVmZXJyZWQgdG8gYnkgYSB0YWcgaW4gdGhlIHBlZWwgY2hhaW4pLCBkb2VzIG5vdAoJICogZXhpc3QuCgkgKi8KCVBFRUxfSU5WQUxJRCA9IC0xLAoKCS8qIG9iamVjdCBjYW5ub3QgYmUgcGVlbGVkIGJlY2F1c2UgaXQgaXMgbm90IGEgdGFnOiAqLwoJUEVFTF9OT05fVEFHID0gLTIsCgoJLyogcmVmX2VudHJ5IGNvbnRhaW5zIG5vIHBlZWxlZCB2YWx1ZSBiZWNhdXNlIGl0IGlzIGEgc3ltcmVmOiAqLwoJUEVFTF9JU19TWU1SRUYgPSAtMywKCgkvKgoJICogcmVmX2VudHJ5IGNhbm5vdCBiZSBwZWVsZWQgYmVjYXVzZSBpdCBpcyBicm9rZW4gKGkuZS4sIHRoZQoJICogc3ltYm9saWMgcmVmZXJlbmNlIGNhbm5vdCBldmVuIGJlIHJlc29sdmVkIHRvIGFuIG9iamVjdAoJICogbmFtZSk6CgkgKi8KCVBFRUxfQlJPS0VOID0gLTQKfTsKCi8qCiAqIFBlZWwgdGhlIG5hbWVkIG9iamVjdDsgaS5lLiwgaWYgdGhlIG9iamVjdCBpcyBhIHRhZywgcmVzb2x2ZSB0aGUKICogdGFnIHJlY3Vyc2l2ZWx5IHVudGlsIGEgbm9uLXRhZyBpcyBmb3VuZC4gIElmIHN1Y2Nlc3NmdWwsIHN0b3JlIHRoZQogKiByZXN1bHQgdG8gb2lkIGFuZCByZXR1cm4gUEVFTF9QRUVMRUQuICBJZiB0aGUgb2JqZWN0IGlzIG5vdCBhIHRhZwogKiBvciBpcyBub3QgdmFsaWQsIHJldHVybiBQRUVMX05PTl9UQUcgb3IgUEVFTF9JTlZBTElELCByZXNwZWN0aXZlbHksCiAqIGFuZCBsZWF2ZSBvaWQgdW5jaGFuZ2VkLgogKi8KZW51bSBwZWVsX3N0YXR1cyBwZWVsX29iamVjdChjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpuYW1lLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpOwoKLyoqCiAqIEluZm9ybWF0aW9uIG5lZWRlZCBmb3IgYSBzaW5nbGUgcmVmIHVwZGF0ZS4gU2V0IG5ld19vaWQgdG8gdGhlIG5ldwogKiB2YWx1ZSBvciB0byBudWxsX29pZCB0byBkZWxldGUgdGhlIHJlZi4gVG8gY2hlY2sgdGhlIG9sZCB2YWx1ZQogKiB3aGlsZSB0aGUgcmVmIGlzIGxvY2tlZCwgc2V0IChmbGFncyAmIFJFRl9IQVZFX09MRCkgYW5kIHNldCBvbGRfb2lkCiAqIHRvIHRoZSBvbGQgdmFsdWUsIG9yIHRvIG51bGxfb2lkIHRvIGVuc3VyZSB0aGUgcmVmIGRvZXMgbm90IGV4aXN0CiAqIGJlZm9yZSB1cGRhdGUuCiAqLwpzdHJ1Y3QgcmVmX3VwZGF0ZSB7CgkvKgoJICogSWYgKGZsYWdzICYgUkVGX0hBVkVfTkVXKSwgc2V0IHRoZSByZWZlcmVuY2UgdG8gdGhpcyB2YWx1ZQoJICogKG9yIGRlbGV0ZSBpdCwgaWYgYG5ld19vaWRgIGlzIGBudWxsX29pZGApLgoJICovCglzdHJ1Y3Qgb2JqZWN0X2lkIG5ld19vaWQ7CgoJLyoKCSAqIElmIChmbGFncyAmIFJFRl9IQVZFX09MRCksIGNoZWNrIHRoYXQgdGhlIHJlZmVyZW5jZQoJICogcHJldmlvdXNseSBoYWQgdGhpcyB2YWx1ZSAob3IgZGlkbid0IHByZXZpb3VzbHkgZXhpc3QsIGlmCgkgKiBgb2xkX29pZGAgaXMgYG51bGxfb2lkYCkuCgkgKi8KCXN0cnVjdCBvYmplY3RfaWQgb2xkX29pZDsKCgkvKgoJICogT25lIG9yIG1vcmUgb2YgUkVGX05PX0RFUkVGLCBSRUZfRk9SQ0VfQ1JFQVRFX1JFRkxPRywKCSAqIFJFRl9IQVZFX05FVywgUkVGX0hBVkVfT0xELCBvciBiYWNrZW5kLXNwZWNpZmljIGZsYWdzLgoJICovCgl1bnNpZ25lZCBpbnQgZmxhZ3M7CgoJdm9pZCAqYmFja2VuZF9kYXRhOwoJdW5zaWduZWQgaW50IHR5cGU7CgljaGFyICptc2c7CgoJLyoKCSAqIElmIHRoaXMgcmVmX3VwZGF0ZSB3YXMgc3BsaXQgb2ZmIG9mIGEgc3ltcmVmIHVwZGF0ZSB2aWEKCSAqIHNwbGl0X3N5bXJlZl91cGRhdGUoKSwgdGhlbiB0aGlzIG1lbWJlciBwb2ludHMgYXQgdGhhdAoJICogdXBkYXRlLiBUaGlzIGlzIHVzZWQgZm9yIHR3byBwdXJwb3NlczoKCSAqIDEuIFdoZW4gcmVwb3J0aW5nIGVycm9ycywgd2UgcmVwb3J0IHRoZSByZWZuYW1lIHVuZGVyIHdoaWNoCgkgKiAgICB0aGUgdXBkYXRlIHdhcyBvcmlnaW5hbGx5IHJlcXVlc3RlZC4KCSAqIDIuIFdoZW4gd2UgcmVhZCB0aGUgb2xkIHZhbHVlIG9mIHRoaXMgcmVmZXJlbmNlLCB3ZQoJICogICAgcHJvcGFnYXRlIGl0IGJhY2sgdG8gaXRzIHBhcmVudCB1cGRhdGUgZm9yIHJlY29yZGluZyBpbgoJICogICAgdGhlIGxhdHRlcidzIHJlZmxvZy4KCSAqLwoJc3RydWN0IHJlZl91cGRhdGUgKnBhcmVudF91cGRhdGU7CgoJY29uc3QgY2hhciByZWZuYW1lW0ZMRVhfQVJSQVldOwp9OwoKaW50IHJlZnNfcmVhZF9yYXdfcmVmKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSwgY29uc3QgY2hhciAqcmVmbmFtZSwKCQkgICAgICBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIHN0cnVjdCBzdHJidWYgKnJlZmVyZW50LAoJCSAgICAgIHVuc2lnbmVkIGludCAqdHlwZSwgaW50ICpmYWlsdXJlX2Vycm5vKTsKCi8qCiAqIFdyaXRlIGFuIGVycm9yIHRvIGBlcnJgIGFuZCByZXR1cm4gYSBub256ZXJvIHZhbHVlIGlmZiB0aGUgc2FtZQogKiByZWZuYW1lIGFwcGVhcnMgbXVsdGlwbGUgdGltZXMgaW4gYHJlZm5hbWVzYC4gYHJlZm5hbWVzYCBtdXN0IGJlCiAqIHNvcnRlZCBvbiBlbnRyeSB0byB0aGlzIGZ1bmN0aW9uLgogKi8KaW50IHJlZl91cGRhdGVfcmVqZWN0X2R1cGxpY2F0ZXMoc3RydWN0IHN0cmluZ19saXN0ICpyZWZuYW1lcywKCQkJCSBzdHJ1Y3Qgc3RyYnVmICplcnIpOwoKLyoKICogQWRkIGEgcmVmX3VwZGF0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcyB0byB0cmFuc2FjdGlvbiwgYW5kCiAqIHJldHVybiBhIHBvaW50ZXIgdG8gdGhlIG5ldyBvYmplY3QuIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgdmVyaWZ5CiAqIHRoYXQgcmVmbmFtZSBpcyB3ZWxsLWZvcm1lZC4gbmV3X29pZCBhbmQgb2xkX29pZCBhcmUgb25seQogKiBkZXJlZmVyZW5jZWQgaWYgdGhlIFJFRl9IQVZFX05FVyBhbmQgUkVGX0hBVkVfT0xEIGJpdHMsCiAqIHJlc3BlY3RpdmVseSwgYXJlIHNldCBpbiBmbGFncy4KICovCnN0cnVjdCByZWZfdXBkYXRlICpyZWZfdHJhbnNhY3Rpb25fYWRkX3VwZGF0ZSgKCQlzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0cmFuc2FjdGlvbiwKCQljb25zdCBjaGFyICpyZWZuYW1lLCB1bnNpZ25lZCBpbnQgZmxhZ3MsCgkJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqbmV3X29pZCwKCQljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvbGRfb2lkLAoJCWNvbnN0IGNoYXIgKm1zZyk7CgovKgogKiBUcmFuc2FjdGlvbiBzdGF0ZXMuCiAqCiAqIE9QRU46ICAgVGhlIHRyYW5zYWN0aW9uIGlzIGluaXRpYWxpemVkIGFuZCBuZXcgdXBkYXRlcyBjYW4gc3RpbGwgYmUKICogICAgICAgICBhZGRlZCB0byBpdC4gQW4gT1BFTiB0cmFuc2FjdGlvbiBjYW4gYmUgcHJlcGFyZWQsCiAqICAgICAgICAgY29tbWl0dGVkLCBmcmVlZCwgb3IgYWJvcnRlZCAoZnJlZWluZyBhbmQgYWJvcnRpbmcgYW4gb3BlbgogKiAgICAgICAgIHRyYW5zYWN0aW9uIGFyZSBlcXVpdmFsZW50KS4KICoKICogUFJFUEFSRUQ6IHJlZl90cmFuc2FjdGlvbl9wcmVwYXJlKCksIHdoaWNoIGxvY2tzIGFsbCBvZiB0aGUKICogICAgICAgICByZWZlcmVuY2VzIGludm9sdmVkIGluIHRoZSB1cGRhdGUgYW5kIGNoZWNrcyB0aGF0IHRoZQogKiAgICAgICAgIHVwZGF0ZSBoYXMgbm8gZXJyb3JzLCBoYXMgYmVlbiBjYWxsZWQgc3VjY2Vzc2Z1bGx5IGZvciB0aGUKICogICAgICAgICB0cmFuc2FjdGlvbi4gQSBQUkVQQVJFRCB0cmFuc2FjdGlvbiBjYW4gYmUgY29tbWl0dGVkIG9yCiAqICAgICAgICAgYWJvcnRlZC4KICoKICogQ0xPU0VEOiBUaGUgdHJhbnNhY3Rpb24gaXMgbm8gbG9uZ2VyIGFjdGl2ZS4gQSB0cmFuc2FjdGlvbiBiZWNvbWVzCiAqICAgICAgICAgQ0xPU0VEIGlmIHRoZXJlIGlzIGEgZmFpbHVyZSB3aGlsZSBidWlsZGluZyB0aGUgdHJhbnNhY3Rpb24KICogICAgICAgICBvciBpZiBhIHRyYW5zYWN0aW9uIGlzIGNvbW1pdHRlZCBvciBhYm9ydGVkLiBBIENMT1NFRAogKiAgICAgICAgIHRyYW5zYWN0aW9uIGNhbiBvbmx5IGJlIGZyZWVkLgogKi8KZW51bSByZWZfdHJhbnNhY3Rpb25fc3RhdGUgewoJUkVGX1RSQU5TQUNUSU9OX09QRU4gICAgID0gMCwKCVJFRl9UUkFOU0FDVElPTl9QUkVQQVJFRCA9IDEsCglSRUZfVFJBTlNBQ1RJT05fQ0xPU0VEICAgPSAyCn07CgovKgogKiBEYXRhIHN0cnVjdHVyZSBmb3IgaG9sZGluZyBhIHJlZmVyZW5jZSB0cmFuc2FjdGlvbiwgd2hpY2ggY2FuCiAqIGNvbnNpc3Qgb2YgY2hlY2tzIGFuZCB1cGRhdGVzIHRvIG11bHRpcGxlIHJlZmVyZW5jZXMsIGNhcnJpZWQgb3V0CiAqIGFzIGF0b21pY2FsbHkgYXMgcG9zc2libGUuICBUaGlzIHN0cnVjdHVyZSBpcyBvcGFxdWUgdG8gY2FsbGVycy4KICovCnN0cnVjdCByZWZfdHJhbnNhY3Rpb24gewoJc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlOwoJc3RydWN0IHJlZl91cGRhdGUgKip1cGRhdGVzOwoJc2l6ZV90IGFsbG9jOwoJc2l6ZV90IG5yOwoJZW51bSByZWZfdHJhbnNhY3Rpb25fc3RhdGUgc3RhdGU7Cgl2b2lkICpiYWNrZW5kX2RhdGE7Cgl1bnNpZ25lZCBpbnQgZmxhZ3M7Cn07CgovKgogKiBDaGVjayBmb3IgZW50cmllcyBpbiBleHRyYXMgdGhhdCBhcmUgd2l0aGluIHRoZSBzcGVjaWZpZWQKICogZGlyZWN0b3J5LCB3aGVyZSBkaXJuYW1lIGlzIGEgcmVmZXJlbmNlIGRpcmVjdG9yeSBuYW1lIGluY2x1ZGluZwogKiB0aGUgdHJhaWxpbmcgc2xhc2ggKGUuZy4sICJyZWZzL2hlYWRzL2Zvby8iKS4gSWdub3JlIGFueQogKiBjb25mbGljdGluZyByZWZlcmVuY2VzIHRoYXQgYXJlIGZvdW5kIGluIHNraXAuIElmIHRoZXJlIGlzIGEKICogY29uZmxpY3RpbmcgcmVmZXJlbmNlLCByZXR1cm4gaXRzIG5hbWUuCiAqCiAqIGV4dHJhcyBhbmQgc2tpcCBtdXN0IGJlIHNvcnRlZCBsaXN0cyBvZiByZWZlcmVuY2UgbmFtZXMuIEVpdGhlciBvbmUKICogY2FuIGJlIE5VTEwsIHNpZ25pZnlpbmcgdGhlIGVtcHR5IGxpc3QuCiAqLwpjb25zdCBjaGFyICpmaW5kX2Rlc2NlbmRhbnRfcmVmKGNvbnN0IGNoYXIgKmRpcm5hbWUsCgkJCQljb25zdCBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmV4dHJhcywKCQkJCWNvbnN0IHN0cnVjdCBzdHJpbmdfbGlzdCAqc2tpcCk7CgovKiBXZSBhbGxvdyAicmVjdXJzaXZlIiBzeW1ib2xpYyByZWZzLiBPbmx5IHdpdGhpbiByZWFzb24sIHRob3VnaCAqLwojZGVmaW5lIFNZTVJFRl9NQVhERVBUSCA1CgovKgogKiBUaGVzZSBmbGFncyBhcmUgcGFzc2VkIHRvIHJlZnNfcmVmX2l0ZXJhdG9yX2JlZ2luKCkgKGFuZCBkb19mb3JfZWFjaF9yZWYoKSwKICogd2hpY2ggZmVlZHMgaXQpLgogKi8KZW51bSBkb19mb3JfZWFjaF9yZWZfZmxhZ3MgewoJLyoKCSAqIEluY2x1ZGUgYnJva2VuIHJlZmVyZW5jZXMgaW4gYSBkb19mb3JfZWFjaF9yZWYqKCkgaXRlcmF0aW9uLCB3aGljaAoJICogd291bGQgbm9ybWFsbHkgYmUgb21pdHRlZC4gVGhpcyBpbmNsdWRlcyBib3RoIHJlZnMgdGhhdCBwb2ludCB0bwoJICogbWlzc2luZyBvYmplY3RzIChhIHRydWUgcmVwb3NpdG9yeSBjb3JydXB0aW9uKSwgb25lcyB3aXRoIGlsbGVnYWwKCSAqIG5hbWVzICh3aGljaCB3ZSBwcmVmZXIgbm90IHRvIGV4cG9zZSB0byBjYWxsZXJzKSwgYXMgd2VsbCBhcwoJICogZGFuZ2xpbmcgc3ltYm9saWMgcmVmcyAoaS5lLiwgdGhvc2UgdGhhdCBwb2ludCB0byBhIG5vbi1leGlzdGVudAoJICogcmVmOyB0aGlzIGlzIG5vdCBhIGNvcnJ1cHRpb24sIGJ1dCBhcyB0aGV5IGhhdmUgbm8gdmFsaWQgb2lkLCB3ZQoJICogb21pdCB0aGVtIGZyb20gbm9ybWFsIGl0ZXJhdGlvbiByZXN1bHRzKS4KCSAqLwoJRE9fRk9SX0VBQ0hfSU5DTFVERV9CUk9LRU4gPSAoMSA8PCAwKSwKCgkvKgoJICogT25seSBpbmNsdWRlIHBlci13b3JrdHJlZSByZWZzIGluIGEgZG9fZm9yX2VhY2hfcmVmKigpIGl0ZXJhdGlvbi4KCSAqIE5vcm1hbGx5IHRoaXMgd2lsbCBiZSB1c2VkIHdpdGggYSBmaWxlcyByZWZfc3RvcmUsIHNpbmNlIHRoYXQncwoJICogd2hlcmUgYWxsIHJlZmVyZW5jZSBiYWNrZW5kcyB3aWxsIHByZXN1bWFibHkgc3RvcmUgdGhlaXIKCSAqIHBlci13b3JrdHJlZSByZWZzLgoJICovCglET19GT1JfRUFDSF9QRVJfV09SS1RSRUVfT05MWSA9ICgxIDw8IDEpLAoKCS8qCgkgKiBPbWl0IGRhbmdsaW5nIHN5bXJlZnMgZnJvbSBvdXRwdXQ7IHRoaXMgb25seSBoYXMgYW4gZWZmZWN0IHdpdGgKCSAqIElOQ0xVREVfQlJPS0VOLCBzaW5jZSB0aGV5IGFyZSBvdGhlcndpc2Ugbm90IGluY2x1ZGVkIGF0IGFsbC4KCSAqLwoJRE9fRk9SX0VBQ0hfT01JVF9EQU5HTElOR19TWU1SRUZTID0gKDEgPDwgMiksCn07CgovKgogKiBSZWZlcmVuY2UgaXRlcmF0b3JzCiAqCiAqIEEgcmVmZXJlbmNlIGl0ZXJhdG9yIGVuY2Fwc3VsYXRlcyB0aGUgc3RhdGUgb2YgYW4gaW4tcHJvZ3Jlc3MKICogaXRlcmF0aW9uIG92ZXIgcmVmZXJlbmNlcy4gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGBzdHJ1Y3QKICogcmVmX2l0ZXJhdG9yYCB2aWEgb25lIG9mIHRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUuCiAqCiAqIEEgZnJlc2hseS1jcmVhdGVkIHJlZl9pdGVyYXRvciBkb2Vzbid0IHlldCBwb2ludCBhdCBhIHJlZmVyZW5jZS4gVG8KICogYWR2YW5jZSB0aGUgaXRlcmF0b3IsIGNhbGwgcmVmX2l0ZXJhdG9yX2FkdmFuY2UoKS4gSWYgc3VjY2Vzc2Z1bCwKICogdGhpcyBzZXRzIHRoZSBpdGVyYXRvcidzIHJlZm5hbWUsIG9pZCwgYW5kIGZsYWdzIGZpZWxkcyB0byBkZXNjcmliZQogKiB0aGUgbmV4dCByZWZlcmVuY2UgYW5kIHJldHVybnMgSVRFUl9PSy4gVGhlIGRhdGEgcG9pbnRlZCBhdCBieQogKiByZWZuYW1lIGFuZCBvaWQgYmVsb25nIHRvIHRoZSBpdGVyYXRvcjsgaWYgeW91IHdhbnQgdG8gcmV0YWluIHRoZW0KICogYWZ0ZXIgY2FsbGluZyByZWZfaXRlcmF0b3JfYWR2YW5jZSgpIGFnYWluIG9yIGNhbGxpbmcKICogcmVmX2l0ZXJhdG9yX2Fib3J0KCksIHlvdSBtdXN0IG1ha2UgYSBjb3B5LiBXaGVuIHRoZSBpdGVyYXRpb24gaGFzCiAqIGJlZW4gZXhoYXVzdGVkLCByZWZfaXRlcmF0b3JfYWR2YW5jZSgpIHJlbGVhc2VzIGFueSByZXNvdXJjZXMKICogYXNzb2NpYXRlZCB3aXRoIHRoZSBpdGVyYXRpb24sIGZyZWVzIHRoZSByZWZfaXRlcmF0b3Igb2JqZWN0LCBhbmQKICogcmV0dXJucyBJVEVSX0RPTkUuIElmIHlvdSB3YW50IHRvIGFib3J0IHRoZSBpdGVyYXRpb24gZWFybHksIGNhbGwKICogcmVmX2l0ZXJhdG9yX2Fib3J0KCksIHdoaWNoIGFsc28gZnJlZXMgdGhlIHJlZl9pdGVyYXRvciBvYmplY3QgYW5kCiAqIGFueSBhc3NvY2lhdGVkIHJlc291cmNlcy4gSWYgdGhlcmUgd2FzIGFuIGludGVybmFsIGVycm9yIGFkdmFuY2luZwogKiB0byB0aGUgbmV4dCBlbnRyeSwgcmVmX2l0ZXJhdG9yX2FkdmFuY2UoKSBhYm9ydHMgdGhlIGl0ZXJhdGlvbiwKICogZnJlZXMgdGhlIHJlZl9pdGVyYXRvciwgYW5kIHJldHVybnMgSVRFUl9FUlJPUi4KICoKICogVGhlIHJlZmVyZW5jZSBjdXJyZW50bHkgYmVpbmcgbG9va2VkIGF0IGNhbiBiZSBwZWVsZWQgYnkgY2FsbGluZwogKiByZWZfaXRlcmF0b3JfcGVlbCgpLiBUaGlzIGZ1bmN0aW9uIGlzIG9mdGVuIGZhc3RlciB0aGFuIHBlZWxfcmVmKCksCiAqIHNvIGl0IHNob3VsZCBiZSBwcmVmZXJyZWQgd2hlbiBpdGVyYXRpbmcgb3ZlciByZWZlcmVuY2VzLgogKgogKiBQdXR0aW5nIGl0IGFsbCB0b2dldGhlciwgYSB0eXBpY2FsIGl0ZXJhdGlvbiBsb29rcyBsaWtlIHRoaXM6CiAqCiAqICAgICBpbnQgb2s7CiAqICAgICBzdHJ1Y3QgcmVmX2l0ZXJhdG9yICppdGVyID0gLi4uOwogKgogKiAgICAgd2hpbGUgKChvayA9IHJlZl9pdGVyYXRvcl9hZHZhbmNlKGl0ZXIpKSA9PSBJVEVSX09LKSB7CiAqICAgICAgICAgICAgIGlmICh3YW50X3RvX3N0b3BfaXRlcmF0aW9uKCkpIHsKICogICAgICAgICAgICAgICAgICAgICBvayA9IHJlZl9pdGVyYXRvcl9hYm9ydChpdGVyKTsKICogICAgICAgICAgICAgICAgICAgICBicmVhazsKICogICAgICAgICAgICAgfQogKgogKiAgICAgICAgICAgICAvLyBBY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgcmVmZXJlbmNlOgogKiAgICAgICAgICAgICBpZiAoIShpdGVyLT5mbGFncyAmIFJFRl9JU1NZTVJFRikpCiAqICAgICAgICAgICAgICAgICAgICAgcHJpbnRmKCIlcyBpcyAlc1xuIiwgaXRlci0+cmVmbmFtZSwgb2lkX3RvX2hleChpdGVyLT5vaWQpKTsKICoKICogICAgICAgICAgICAgLy8gSWYgeW91IG5lZWQgdG8gcGVlbCB0aGUgcmVmZXJlbmNlOgogKiAgICAgICAgICAgICByZWZfaXRlcmF0b3JfcGVlbChpdGVyLCAmb2lkKTsKICogICAgIH0KICoKICogICAgIGlmIChvayAhPSBJVEVSX0RPTkUpCiAqICAgICAgICAgICAgIGhhbmRsZV9lcnJvcigpOwogKi8Kc3RydWN0IHJlZl9pdGVyYXRvciB7CglzdHJ1Y3QgcmVmX2l0ZXJhdG9yX3Z0YWJsZSAqdnRhYmxlOwoKCS8qCgkgKiBEb2VzIHRoaXMgYHJlZl9pdGVyYXRvcmAgaXRlcmF0ZSBvdmVyIHJlZmVyZW5jZXMgaW4gb3JkZXIKCSAqIGJ5IHJlZm5hbWU/CgkgKi8KCXVuc2lnbmVkIGludCBvcmRlcmVkIDogMTsKCgljb25zdCBjaGFyICpyZWZuYW1lOwoJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkOwoJdW5zaWduZWQgaW50IGZsYWdzOwp9OwoKLyoKICogQWR2YW5jZSB0aGUgaXRlcmF0b3IgdG8gdGhlIGZpcnN0IG9yIG5leHQgaXRlbSBhbmQgcmV0dXJuIElURVJfT0suCiAqIElmIHRoZSBpdGVyYXRpb24gaXMgZXhoYXVzdGVkLCBmcmVlIHRoZSByZXNvdXJjZXMgYXNzb2NpYXRlZCB3aXRoCiAqIHRoZSByZWZfaXRlcmF0b3IgYW5kIHJldHVybiBJVEVSX0RPTkUuIE9uIGVycm9ycywgZnJlZSB0aGUgaXRlcmF0b3IKICogcmVzb3VyY2VzIGFuZCByZXR1cm4gSVRFUl9FUlJPUi4gSXQgaXMgYSBidWcgdG8gdXNlIHJlZl9pdGVyYXRvciBvcgogKiBjYWxsIHRoaXMgZnVuY3Rpb24gYWdhaW4gYWZ0ZXIgaXQgaGFzIHJldHVybmVkIElURVJfRE9ORSBvcgogKiBJVEVSX0VSUk9SLgogKi8KaW50IHJlZl9pdGVyYXRvcl9hZHZhbmNlKHN0cnVjdCByZWZfaXRlcmF0b3IgKnJlZl9pdGVyYXRvcik7CgovKgogKiBJZiBwb3NzaWJsZSwgcGVlbCB0aGUgcmVmZXJlbmNlIGN1cnJlbnRseSBiZWluZyB2aWV3ZWQgYnkgdGhlCiAqIGl0ZXJhdG9yLiBSZXR1cm4gMCBvbiBzdWNjZXNzLgogKi8KaW50IHJlZl9pdGVyYXRvcl9wZWVsKHN0cnVjdCByZWZfaXRlcmF0b3IgKnJlZl9pdGVyYXRvciwKCQkgICAgICBzdHJ1Y3Qgb2JqZWN0X2lkICpwZWVsZWQpOwoKLyoKICogRW5kIHRoZSBpdGVyYXRpb24gYmVmb3JlIGl0IGhhcyBiZWVuIGV4aGF1c3RlZCwgZnJlZWluZyB0aGUKICogcmVmZXJlbmNlIGl0ZXJhdG9yIGFuZCBhbnkgYXNzb2NpYXRlZCByZXNvdXJjZXMgYW5kIHJldHVybmluZwogKiBJVEVSX0RPTkUuIElmIHRoZSBhYm9ydCBpdHNlbGYgZmFpbGVkLCByZXR1cm4gSVRFUl9FUlJPUi4KICovCmludCByZWZfaXRlcmF0b3JfYWJvcnQoc3RydWN0IHJlZl9pdGVyYXRvciAqcmVmX2l0ZXJhdG9yKTsKCi8qCiAqIEFuIGl0ZXJhdG9yIG92ZXIgbm90aGluZyAoaXRzIGZpcnN0IHJlZl9pdGVyYXRvcl9hZHZhbmNlKCkgY2FsbAogKiByZXR1cm5zIElURVJfRE9ORSkuCiAqLwpzdHJ1Y3QgcmVmX2l0ZXJhdG9yICplbXB0eV9yZWZfaXRlcmF0b3JfYmVnaW4odm9pZCk7CgovKgogKiBSZXR1cm4gdHJ1ZSBpZmYgcmVmX2l0ZXJhdG9yIGlzIGFuIGVtcHR5X3JlZl9pdGVyYXRvci4KICovCmludCBpc19lbXB0eV9yZWZfaXRlcmF0b3Ioc3RydWN0IHJlZl9pdGVyYXRvciAqcmVmX2l0ZXJhdG9yKTsKCi8qCiAqIFJldHVybiBhbiBpdGVyYXRvciB0aGF0IGdvZXMgb3ZlciBlYWNoIHJlZmVyZW5jZSBpbiBgcmVmc2AgZm9yCiAqIHdoaWNoIHRoZSByZWZuYW1lIGJlZ2lucyB3aXRoIHByZWZpeC4gSWYgdHJpbSBpcyBub24temVybywgdGhlbgogKiB0cmltIHRoYXQgbWFueSBjaGFyYWN0ZXJzIG9mZiB0aGUgYmVnaW5uaW5nIG9mIGVhY2ggcmVmbmFtZS4KICogVGhlIG91dHB1dCBpcyBvcmRlcmVkIGJ5IHJlZm5hbWUuCiAqLwpzdHJ1Y3QgcmVmX2l0ZXJhdG9yICpyZWZzX3JlZl9pdGVyYXRvcl9iZWdpbigKCQlzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLAoJCWNvbnN0IGNoYXIgKnByZWZpeCwgaW50IHRyaW0sCgkJZW51bSBkb19mb3JfZWFjaF9yZWZfZmxhZ3MgZmxhZ3MpOwoKLyoKICogQSBjYWxsYmFjayBmdW5jdGlvbiB1c2VkIHRvIGluc3RydWN0IG1lcmdlX3JlZl9pdGVyYXRvciBob3cgdG8KICogaW50ZXJsZWF2ZSB0aGUgZW50cmllcyBmcm9tIGl0ZXIwIGFuZCBpdGVyMS4gVGhlIGZ1bmN0aW9uIHNob3VsZAogKiByZXR1cm4gb25lIG9mIHRoZSBjb25zdGFudHMgZGVmaW5lZCBpbiBlbnVtIGl0ZXJhdG9yX3NlbGVjdGlvbi4gSXQKICogbXVzdCBub3QgYWR2YW5jZSBlaXRoZXIgb2YgdGhlIGl0ZXJhdG9ycyBpdHNlbGYuCiAqCiAqIFRoZSBmdW5jdGlvbiBtdXN0IGJlIHByZXBhcmVkIHRvIGhhbmRsZSB0aGUgY2FzZSB0aGF0IGl0ZXIwIGFuZC9vcgogKiBpdGVyMSBpcyBOVUxMLCB3aGljaCBpbmRpY2F0ZXMgdGhhdCB0aGUgY29ycmVzcG9uZGluZyBzdWItaXRlcmF0b3IKICogaGFzIGJlZW4gZXhoYXVzdGVkLiBJdHMgcmV0dXJuIHZhbHVlIG11c3QgYmUgY29uc2lzdGVudCB3aXRoIHRoZQogKiBjdXJyZW50IHN0YXRlcyBvZiB0aGUgaXRlcmF0b3JzOyBlLmcuLCBpdCBtdXN0IG5vdCByZXR1cm4KICogSVRFUl9TS0lQXzEgaWYgaXRlcjEgaGFzIGFscmVhZHkgYmVlbiBleGhhdXN0ZWQuCiAqLwp0eXBlZGVmIGVudW0gaXRlcmF0b3Jfc2VsZWN0aW9uIHJlZl9pdGVyYXRvcl9zZWxlY3RfZm4oCgkJc3RydWN0IHJlZl9pdGVyYXRvciAqaXRlcjAsIHN0cnVjdCByZWZfaXRlcmF0b3IgKml0ZXIxLAoJCXZvaWQgKmNiX2RhdGEpOwoKLyoKICogSXRlcmF0ZSBvdmVyIHRoZSBlbnRyaWVzIGZyb20gaXRlcjAgYW5kIGl0ZXIxLCB3aXRoIHRoZSB2YWx1ZXMKICogaW50ZXJsZWF2ZWQgYXMgZGlyZWN0ZWQgYnkgdGhlIHNlbGVjdCBmdW5jdGlvbi4gVGhlIGl0ZXJhdG9yIHRha2VzCiAqIG93bmVyc2hpcCBvZiBpdGVyMCBhbmQgaXRlcjEgYW5kIGZyZWVzIHRoZW0gd2hlbiB0aGUgaXRlcmF0aW9uIGlzCiAqIG92ZXIuIEEgZGVyaXZlZCBjbGFzcyBzaG91bGQgc2V0IGBvcmRlcmVkYCB0byAxIG9yIDAgYmFzZWQgb24KICogd2hldGhlciBpdCBnZW5lcmF0ZXMgaXRzIG91dHB1dCBpbiBvcmRlciBieSByZWZlcmVuY2UgbmFtZS4KICovCnN0cnVjdCByZWZfaXRlcmF0b3IgKm1lcmdlX3JlZl9pdGVyYXRvcl9iZWdpbigKCQlpbnQgb3JkZXJlZCwKCQlzdHJ1Y3QgcmVmX2l0ZXJhdG9yICppdGVyMCwgc3RydWN0IHJlZl9pdGVyYXRvciAqaXRlcjEsCgkJcmVmX2l0ZXJhdG9yX3NlbGVjdF9mbiAqc2VsZWN0LCB2b2lkICpjYl9kYXRhKTsKCi8qCiAqIEFuIGl0ZXJhdG9yIGNvbnNpc3Rpbmcgb2YgdGhlIHVuaW9uIG9mIHRoZSBlbnRyaWVzIGZyb20gZnJvbnQgYW5kCiAqIGJhY2suIElmIHRoZXJlIGFyZSBlbnRyaWVzIGNvbW1vbiB0byB0aGUgdHdvIHN1Yi1pdGVyYXRvcnMsIHVzZSB0aGUKICogb25lIGZyb20gZnJvbnQuIEVhY2ggaXRlcmF0b3IgbXVzdCBpdGVyYXRlIG92ZXIgaXRzIGVudHJpZXMgaW4KICogc3RyY21wKCkgb3JkZXIgYnkgcmVmbmFtZSBmb3IgdGhpcyB0byB3b3JrLgogKgogKiBUaGUgbmV3IGl0ZXJhdG9yIHRha2VzIG93bmVyc2hpcCBvZiBpdHMgYXJndW1lbnRzIGFuZCBmcmVlcyB0aGVtCiAqIHdoZW4gdGhlIGl0ZXJhdGlvbiBpcyBvdmVyLiBBcyBhIGNvbnZlbmllbmNlIHRvIGNhbGxlcnMsIGlmIGZyb250CiAqIG9yIGJhY2sgaXMgYW4gZW1wdHlfcmVmX2l0ZXJhdG9yLCB0aGVuIGFib3J0IHRoYXQgb25lIGltbWVkaWF0ZWx5CiAqIGFuZCByZXR1cm4gdGhlIG90aGVyIGl0ZXJhdG9yIGRpcmVjdGx5LCB3aXRob3V0IHdyYXBwaW5nIGl0LgogKi8Kc3RydWN0IHJlZl9pdGVyYXRvciAqb3ZlcmxheV9yZWZfaXRlcmF0b3JfYmVnaW4oCgkJc3RydWN0IHJlZl9pdGVyYXRvciAqZnJvbnQsIHN0cnVjdCByZWZfaXRlcmF0b3IgKmJhY2spOwoKLyoKICogV3JhcCBpdGVyMCwgb25seSBsZXR0aW5nIHRocm91Z2ggdGhlIHJlZmVyZW5jZXMgd2hvc2UgbmFtZXMgc3RhcnQKICogd2l0aCBwcmVmaXguIElmIHRyaW0gaXMgc2V0LCBzZXQgaXRlci0+cmVmbmFtZSB0byB0aGUgbmFtZSBvZiB0aGUKICogcmVmZXJlbmNlIHdpdGggdGhhdCBtYW55IGNoYXJhY3RlcnMgdHJpbW1lZCBvZmYgdGhlIGZyb250OwogKiBvdGhlcndpc2Ugc2V0IGl0IHRvIHRoZSBmdWxsIHJlZm5hbWUuIFRoZSBuZXcgaXRlcmF0b3IgdGFrZXMgb3ZlcgogKiBvd25lcnNoaXAgb2YgaXRlcjAgYW5kIGZyZWVzIGl0IHdoZW4gaXRlcmF0aW9uIGlzIG92ZXIuIEl0IG1ha2VzCiAqIGl0cyBvd24gY29weSBvZiBwcmVmaXguCiAqCiAqIEFzIGFuIGNvbnZlbmllbmNlIHRvIGNhbGxlcnMsIGlmIHByZWZpeCBpcyB0aGUgZW1wdHkgc3RyaW5nIGFuZAogKiB0cmltIGlzIHplcm8sIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBpdGVyMCBkaXJlY3RseSwgd2l0aG91dAogKiB3cmFwcGluZyBpdC4KICoKICogVGhlIHJlc3VsdGluZyByZWZfaXRlcmF0b3IgaXMgb3JkZXJlZCBpZiBpdGVyMCBpcy4KICovCnN0cnVjdCByZWZfaXRlcmF0b3IgKnByZWZpeF9yZWZfaXRlcmF0b3JfYmVnaW4oc3RydWN0IHJlZl9pdGVyYXRvciAqaXRlcjAsCgkJCQkJICAgICAgIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJCQkgICAgICAgaW50IHRyaW0pOwoKLyogSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgcmVmZXJlbmNlIGl0ZXJhdGlvbjogKi8KCi8qCiAqIEJhc2UgY2xhc3MgY29uc3RydWN0b3IgZm9yIHJlZl9pdGVyYXRvcnMuIEluaXRpYWxpemUgdGhlCiAqIHJlZl9pdGVyYXRvciBwYXJ0IG9mIGl0ZXIsIHNldHRpbmcgaXRzIHZ0YWJsZSBwb2ludGVyIGFzIHNwZWNpZmllZC4KICogYG9yZGVyZWRgIHNob3VsZCBiZSBzZXQgdG8gMSBpZiB0aGUgaXRlcmF0b3Igd2lsbCBpdGVyYXRlIG92ZXIKICogcmVmZXJlbmNlcyBpbiBvcmRlciBieSByZWZuYW1lOyBvdGhlcndpc2UgaXQgc2hvdWxkIGJlIHNldCB0byAwLgogKiBUaGlzIGlzIG1lYW50IHRvIGJlIGNhbGxlZCBvbmx5IGJ5IHRoZSBpbml0aWFsaXplcnMgb2YgZGVyaXZlZAogKiBjbGFzc2VzLgogKi8Kdm9pZCBiYXNlX3JlZl9pdGVyYXRvcl9pbml0KHN0cnVjdCByZWZfaXRlcmF0b3IgKml0ZXIsCgkJCSAgICBzdHJ1Y3QgcmVmX2l0ZXJhdG9yX3Z0YWJsZSAqdnRhYmxlLAoJCQkgICAgaW50IG9yZGVyZWQpOwoKLyoKICogQmFzZSBjbGFzcyBkZXN0cnVjdG9yIGZvciByZWZfaXRlcmF0b3JzLiBEZXN0cm95IHRoZSByZWZfaXRlcmF0b3IKICogcGFydCBvZiBpdGVyIGFuZCBzaGFsbG93LWZyZWUgdGhlIG9iamVjdC4gVGhpcyBpcyBtZWFudCB0byBiZQogKiBjYWxsZWQgb25seSBieSB0aGUgZGVzdHJ1Y3RvcnMgb2YgZGVyaXZlZCBjbGFzc2VzLgogKi8Kdm9pZCBiYXNlX3JlZl9pdGVyYXRvcl9mcmVlKHN0cnVjdCByZWZfaXRlcmF0b3IgKml0ZXIpOwoKLyogVmlydHVhbCBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgZm9yIHJlZl9pdGVyYXRvcnM6ICovCgovKgogKiBiYWNrZW5kLXNwZWNpZmljIGltcGxlbWVudGF0aW9uIG9mIHJlZl9pdGVyYXRvcl9hZHZhbmNlLiBGb3Igc3ltcmVmcywgdGhlCiAqIGZ1bmN0aW9uIHNob3VsZCBzZXQgUkVGX0lTU1lNUkVGLCBhbmQgaXQgc2hvdWxkIGFsc28gZGVyZWZlcmVuY2UgdGhlIHN5bXJlZgogKiB0byBwcm92aWRlIHRoZSBPSUQgcmVmZXJlbnQuIEl0IHNob3VsZCByZXNwZWN0IGRvX2Zvcl9lYWNoX3JlZl9mbGFncwogKiB0aGF0IHdlcmUgcGFzc2VkIHRvIHJlZnNfcmVmX2l0ZXJhdG9yX2JlZ2luKCkuCiAqLwp0eXBlZGVmIGludCByZWZfaXRlcmF0b3JfYWR2YW5jZV9mbihzdHJ1Y3QgcmVmX2l0ZXJhdG9yICpyZWZfaXRlcmF0b3IpOwoKLyoKICogUGVlbHMgdGhlIGN1cnJlbnQgcmVmLCByZXR1cm5pbmcgMCBmb3Igc3VjY2VzcyBvciAtMSBmb3IgZmFpbHVyZS4KICovCnR5cGVkZWYgaW50IHJlZl9pdGVyYXRvcl9wZWVsX2ZuKHN0cnVjdCByZWZfaXRlcmF0b3IgKnJlZl9pdGVyYXRvciwKCQkJCSBzdHJ1Y3Qgb2JqZWN0X2lkICpwZWVsZWQpOwoKLyoKICogSW1wbGVtZW50YXRpb25zIG9mIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGZyZWUgYW55IHJlc291cmNlcyBzcGVjaWZpYwogKiB0byB0aGUgZGVyaXZlZCBjbGFzcywgdGhlbiBjYWxsIGJhc2VfcmVmX2l0ZXJhdG9yX2ZyZWUoKSB0byBjbGVhbgogKiB1cCBhbmQgZnJlZSB0aGUgcmVmX2l0ZXJhdG9yIG9iamVjdC4KICovCnR5cGVkZWYgaW50IHJlZl9pdGVyYXRvcl9hYm9ydF9mbihzdHJ1Y3QgcmVmX2l0ZXJhdG9yICpyZWZfaXRlcmF0b3IpOwoKc3RydWN0IHJlZl9pdGVyYXRvcl92dGFibGUgewoJcmVmX2l0ZXJhdG9yX2FkdmFuY2VfZm4gKmFkdmFuY2U7CglyZWZfaXRlcmF0b3JfcGVlbF9mbiAqcGVlbDsKCXJlZl9pdGVyYXRvcl9hYm9ydF9mbiAqYWJvcnQ7Cn07CgovKgogKiBjdXJyZW50X3JlZl9pdGVyIGlzIGEgcGVyZm9ybWFuY2UgaGFjazogd2hlbiBpdGVyYXRpbmcgb3ZlcgogKiByZWZlcmVuY2VzIHVzaW5nIHRoZSBmb3JfZWFjaF9yZWYqKCkgZnVuY3Rpb25zLCBjdXJyZW50X3JlZl9pdGVyIGlzCiAqIHNldCB0byB0aGUgcmVmZXJlbmNlIGl0ZXJhdG9yIGJlZm9yZSBjYWxsaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbi4KICogSWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGNhbGxzIHBlZWxfcmVmKCksIHRoZW4gcGVlbF9yZWYoKSBmaXJzdAogKiBjaGVja3Mgd2hldGhlciB0aGUgcmVmZXJlbmNlIHRvIGJlIHBlZWxlZCBpcyB0aGUgb25lIHJlZmVycmVkIHRvIGJ5CiAqIHRoZSBpdGVyYXRvciAoaXQgdXN1YWxseSBpcykgYW5kIGlmIHNvLCBhc2tzIHRoZSBpdGVyYXRvciBmb3IgdGhlCiAqIHBlZWxlZCB2ZXJzaW9uIG9mIHRoZSByZWZlcmVuY2UgaWYgaXQgaXMgYXZhaWxhYmxlLiBUaGlzIGF2b2lkcyBhCiAqIHJlZm5hbWUgbG9va3VwIGluIGEgY29tbW9uIGNhc2UuIGN1cnJlbnRfcmVmX2l0ZXIgaXMgc2V0IHRvIE5VTEwKICogd2hlbiB0aGUgaXRlcmF0aW9uIGlzIG92ZXIuCiAqLwpleHRlcm4gc3RydWN0IHJlZl9pdGVyYXRvciAqY3VycmVudF9yZWZfaXRlcjsKCi8qCiAqIFRoZSBjb21tb24gYmFja2VuZCBmb3IgdGhlIGZvcl9lYWNoXypyZWYqIGZ1bmN0aW9ucy4gQ2FsbCBmbiBmb3IKICogZWFjaCByZWZlcmVuY2UgaW4gaXRlci4gSWYgdGhlIGl0ZXJhdG9yIGl0c2VsZiBldmVyIHJldHVybnMKICogSVRFUl9FUlJPUiwgcmV0dXJuIC0xLiBJZiBmbiBldmVyIHJldHVybnMgYSBub24temVybyB2YWx1ZSwgc3RvcAogKiB0aGUgaXRlcmF0aW9uIGFuZCByZXR1cm4gdGhhdCB2YWx1ZS4gT3RoZXJ3aXNlLCByZXR1cm4gMC4gSW4gYW55CiAqIGNhc2UsIGZyZWUgdGhlIGl0ZXJhdG9yIHdoZW4gZG9uZS4gVGhpcyBmdW5jdGlvbiBpcyBiYXNpY2FsbHkgYW4KICogYWRhcHRlciBiZXR3ZWVuIHRoZSBjYWxsYmFjayBzdHlsZSBvZiByZWZlcmVuY2UgaXRlcmF0aW9uIGFuZCB0aGUKICogaXRlcmF0b3Igc3R5bGUuCiAqLwppbnQgZG9fZm9yX2VhY2hfcmVwb19yZWZfaXRlcmF0b3Ioc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCQkgIHN0cnVjdCByZWZfaXRlcmF0b3IgKml0ZXIsCgkJCQkgIGVhY2hfcmVwb19yZWZfZm4gZm4sIHZvaWQgKmNiX2RhdGEpOwoKc3RydWN0IHJlZl9zdG9yZTsKCi8qIHJlZnMgYmFja2VuZHMgKi8KCi8qIHJlZl9zdG9yZV9pbml0IGZsYWdzICovCiNkZWZpbmUgUkVGX1NUT1JFX1JFQUQJCSgxIDw8IDApCiNkZWZpbmUgUkVGX1NUT1JFX1dSSVRFCQkoMSA8PCAxKSAvKiBjYW4gcGVyZm9ybSB1cGRhdGUgb3BlcmF0aW9ucyAqLwojZGVmaW5lIFJFRl9TVE9SRV9PREIJCSgxIDw8IDIpIC8qIGhhcyBhY2Nlc3MgdG8gb2JqZWN0IGRhdGFiYXNlICovCiNkZWZpbmUgUkVGX1NUT1JFX01BSU4JCSgxIDw8IDMpCiNkZWZpbmUgUkVGX1NUT1JFX0FMTF9DQVBTCShSRUZfU1RPUkVfUkVBRCB8IFwKCQkJCSBSRUZfU1RPUkVfV1JJVEUgfCBcCgkJCQkgUkVGX1NUT1JFX09EQiB8IFwKCQkJCSBSRUZfU1RPUkVfTUFJTikKCi8qCiAqIEluaXRpYWxpemUgdGhlIHJlZl9zdG9yZSBmb3IgdGhlIHNwZWNpZmllZCBnaXRkaXIuIFRoZXNlIGZ1bmN0aW9ucwogKiBzaG91bGQgY2FsbCBiYXNlX3JlZl9zdG9yZV9pbml0KCkgdG8gaW5pdGlhbGl6ZSB0aGUgc2hhcmVkIHBhcnQgb2YKICogdGhlIHJlZl9zdG9yZSBhbmQgdG8gcmVjb3JkIHRoZSByZWZfc3RvcmUgZm9yIGxhdGVyIGxvb2t1cC4KICovCnR5cGVkZWYgc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlX2luaXRfZm4oc3RydWN0IHJlcG9zaXRvcnkgKnJlcG8sCgkJCQkJICAgIGNvbnN0IGNoYXIgKmdpdGRpciwKCQkJCQkgICAgdW5zaWduZWQgaW50IGZsYWdzKTsKCnR5cGVkZWYgaW50IHJlZl9pbml0X2RiX2ZuKHN0cnVjdCByZWZfc3RvcmUgKnJlZnMsIHN0cnVjdCBzdHJidWYgKmVycik7Cgp0eXBlZGVmIGludCByZWZfdHJhbnNhY3Rpb25fcHJlcGFyZV9mbihzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLAoJCQkJICAgICAgIHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyYW5zYWN0aW9uLAoJCQkJICAgICAgIHN0cnVjdCBzdHJidWYgKmVycik7Cgp0eXBlZGVmIGludCByZWZfdHJhbnNhY3Rpb25fZmluaXNoX2ZuKHN0cnVjdCByZWZfc3RvcmUgKnJlZnMsCgkJCQkgICAgICBzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0cmFuc2FjdGlvbiwKCQkJCSAgICAgIHN0cnVjdCBzdHJidWYgKmVycik7Cgp0eXBlZGVmIGludCByZWZfdHJhbnNhY3Rpb25fYWJvcnRfZm4oc3RydWN0IHJlZl9zdG9yZSAqcmVmcywKCQkJCSAgICAgc3RydWN0IHJlZl90cmFuc2FjdGlvbiAqdHJhbnNhY3Rpb24sCgkJCQkgICAgIHN0cnVjdCBzdHJidWYgKmVycik7Cgp0eXBlZGVmIGludCByZWZfdHJhbnNhY3Rpb25fY29tbWl0X2ZuKHN0cnVjdCByZWZfc3RvcmUgKnJlZnMsCgkJCQkgICAgICBzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0cmFuc2FjdGlvbiwKCQkJCSAgICAgIHN0cnVjdCBzdHJidWYgKmVycik7Cgp0eXBlZGVmIGludCBwYWNrX3JlZnNfZm4oc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlLCB1bnNpZ25lZCBpbnQgZmxhZ3MpOwp0eXBlZGVmIGludCBjcmVhdGVfc3ltcmVmX2ZuKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSwKCQkJICAgICBjb25zdCBjaGFyICpyZWZfdGFyZ2V0LAoJCQkgICAgIGNvbnN0IGNoYXIgKnJlZnNfaGVhZHNfbWFzdGVyLAoJCQkgICAgIGNvbnN0IGNoYXIgKmxvZ21zZyk7CnR5cGVkZWYgaW50IGRlbGV0ZV9yZWZzX2ZuKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSwgY29uc3QgY2hhciAqbXNnLAoJCQkgICBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnJlZm5hbWVzLCB1bnNpZ25lZCBpbnQgZmxhZ3MpOwp0eXBlZGVmIGludCByZW5hbWVfcmVmX2ZuKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSwKCQkJICBjb25zdCBjaGFyICpvbGRyZWYsIGNvbnN0IGNoYXIgKm5ld3JlZiwKCQkJICBjb25zdCBjaGFyICpsb2dtc2cpOwp0eXBlZGVmIGludCBjb3B5X3JlZl9mbihzdHJ1Y3QgcmVmX3N0b3JlICpyZWZfc3RvcmUsCgkJCSAgY29uc3QgY2hhciAqb2xkcmVmLCBjb25zdCBjaGFyICpuZXdyZWYsCgkJCSAgY29uc3QgY2hhciAqbG9nbXNnKTsKCi8qCiAqIEl0ZXJhdGUgb3ZlciB0aGUgcmVmZXJlbmNlcyBpbiBgcmVmX3N0b3JlYCB3aG9zZSBuYW1lcyBzdGFydCB3aXRoCiAqIGBwcmVmaXhgLiBgcHJlZml4YCBpcyBtYXRjaGVkIGFzIGEgbGl0ZXJhbCBzdHJpbmcsIHdpdGhvdXQgcmVnYXJkCiAqIGZvciBwYXRoIHNlcGFyYXRvcnMuIElmIHByZWZpeCBpcyBOVUxMIG9yIHRoZSBlbXB0eSBzdHJpbmcsIGl0ZXJhdGUKICogb3ZlciBhbGwgcmVmZXJlbmNlcyBpbiBgcmVmX3N0b3JlYC4gVGhlIG91dHB1dCBpcyBvcmRlcmVkIGJ5CiAqIHJlZm5hbWUuCiAqLwp0eXBlZGVmIHN0cnVjdCByZWZfaXRlcmF0b3IgKnJlZl9pdGVyYXRvcl9iZWdpbl9mbigKCQlzdHJ1Y3QgcmVmX3N0b3JlICpyZWZfc3RvcmUsCgkJY29uc3QgY2hhciAqcHJlZml4LCB1bnNpZ25lZCBpbnQgZmxhZ3MpOwoKLyogcmVmbG9nIGZ1bmN0aW9ucyAqLwoKLyoKICogSXRlcmF0ZSBvdmVyIHRoZSByZWZlcmVuY2VzIGluIHRoZSBzcGVjaWZpZWQgcmVmX3N0b3JlIHRoYXQgaGF2ZSBhCiAqIHJlZmxvZy4gVGhlIHJlZnMgYXJlIGl0ZXJhdGVkIG92ZXIgaW4gYXJiaXRyYXJ5IG9yZGVyLgogKi8KdHlwZWRlZiBzdHJ1Y3QgcmVmX2l0ZXJhdG9yICpyZWZsb2dfaXRlcmF0b3JfYmVnaW5fZm4oCgkJc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlKTsKCnR5cGVkZWYgaW50IGZvcl9lYWNoX3JlZmxvZ19lbnRfZm4oc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlLAoJCQkJICAgY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJCSAgIGVhY2hfcmVmbG9nX2VudF9mbiBmbiwKCQkJCSAgIHZvaWQgKmNiX2RhdGEpOwp0eXBlZGVmIGludCBmb3JfZWFjaF9yZWZsb2dfZW50X3JldmVyc2VfZm4oc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlLAoJCQkJCSAgIGNvbnN0IGNoYXIgKnJlZm5hbWUsCgkJCQkJICAgZWFjaF9yZWZsb2dfZW50X2ZuIGZuLAoJCQkJCSAgIHZvaWQgKmNiX2RhdGEpOwp0eXBlZGVmIGludCByZWZsb2dfZXhpc3RzX2ZuKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSwgY29uc3QgY2hhciAqcmVmbmFtZSk7CnR5cGVkZWYgaW50IGNyZWF0ZV9yZWZsb2dfZm4oc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlLCBjb25zdCBjaGFyICpyZWZuYW1lLAoJCQkgICAgIHN0cnVjdCBzdHJidWYgKmVycik7CnR5cGVkZWYgaW50IGRlbGV0ZV9yZWZsb2dfZm4oc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlLCBjb25zdCBjaGFyICpyZWZuYW1lKTsKdHlwZWRlZiBpbnQgcmVmbG9nX2V4cGlyZV9mbihzdHJ1Y3QgcmVmX3N0b3JlICpyZWZfc3RvcmUsCgkJCSAgICAgY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJICAgICB1bnNpZ25lZCBpbnQgZmxhZ3MsCgkJCSAgICAgcmVmbG9nX2V4cGlyeV9wcmVwYXJlX2ZuIHByZXBhcmVfZm4sCgkJCSAgICAgcmVmbG9nX2V4cGlyeV9zaG91bGRfcHJ1bmVfZm4gc2hvdWxkX3BydW5lX2ZuLAoJCQkgICAgIHJlZmxvZ19leHBpcnlfY2xlYW51cF9mbiBjbGVhbnVwX2ZuLAoJCQkgICAgIHZvaWQgKnBvbGljeV9jYl9kYXRhKTsKCi8qCiAqIFJlYWQgYSByZWZlcmVuY2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlZmVyZW5jZSBzdG9yZSwgbm9uLXJlY3Vyc2l2ZWx5LgogKiBTZXQgdHlwZSB0byBkZXNjcmliZSB0aGUgcmVmZXJlbmNlLCBhbmQ6CiAqCiAqIC0gSWYgcmVmbmFtZSBpcyB0aGUgbmFtZSBvZiBhIG5vcm1hbCByZWZlcmVuY2UsIGZpbGwgaW4gb2lkCiAqICAgKGxlYXZpbmcgcmVmZXJlbnQgdW5jaGFuZ2VkKS4KICoKICogLSBJZiByZWZuYW1lIGlzIHRoZSBuYW1lIG9mIGEgc3ltYm9saWMgcmVmZXJlbmNlLCB3cml0ZSB0aGUgZnVsbAogKiAgIG5hbWUgb2YgdGhlIHJlZmVyZW5jZSB0byB3aGljaCBpdCByZWZlcnMgKGUuZy4KICogICAicmVmcy9oZWFkcy9tYXN0ZXIiKSB0byByZWZlcmVudCBhbmQgc2V0IHRoZSBSRUZfSVNTWU1SRUYgYml0IGluCiAqICAgdHlwZSAobGVhdmluZyBvaWQgdW5jaGFuZ2VkKS4gVGhlIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IKICogICB2YWxpZGF0aW5nIHRoYXQgcmVmZXJlbnQgaXMgYSB2YWxpZCByZWZlcmVuY2UgbmFtZS4KICoKICogV0FSTklORzogcmVmbmFtZSBtaWdodCBiZSB1c2VkIGFzIHBhcnQgb2YgYSBmaWxlbmFtZSwgc28gaXQgaXMKICogaW1wb3J0YW50IGZyb20gYSBzZWN1cml0eSBzdGFuZHBvaW50IHRoYXQgaXQgYmUgc2FmZSBpbiB0aGUgc2Vuc2UKICogb2YgcmVmbmFtZV9pc19zYWZlKCkuIE1vcmVvdmVyLCBmb3Igc3ltcmVmcyB0aGlzIGZ1bmN0aW9uIHNldHMKICogcmVmZXJlbnQgdG8gd2hhdGV2ZXIgdGhlIHJlcG9zaXRvcnkgc2F5cywgd2hpY2ggbWlnaHQgbm90IGJlIGEKICogcHJvcGVybHktZm9ybWF0dGVkIG9yIGV2ZW4gc2FmZSByZWZlcmVuY2UgbmFtZS4gTkVJVEhFUiBJTlBVVCBOT1IKICogT1VUUFVUIFJFRkVSRU5DRSBOQU1FUyBBUkUgVkFMSURBVEVEIFdJVEhJTiBUSElTIEZVTkNUSU9OLgogKgogKiBSZXR1cm4gMCBvbiBzdWNjZXNzLCBvciAtMSBvbiBmYWlsdXJlLiBJZiB0aGUgcmVmIGV4aXN0cyBidXQgaXMgbmVpdGhlciBhCiAqIHN5bWJvbGljIHJlZiBub3IgYW4gb2JqZWN0IElELCBpdCBpcyBicm9rZW4uIEluIHRoaXMgY2FzZSBzZXQgUkVGX0lTQlJPS0VOIGluCiAqIHR5cGUsIGFuZCByZXR1cm4gLTEgKGZhaWx1cmVfZXJybm8gc2hvdWxkIG5vdCBiZSBFTk9FTlQpCiAqCiAqIGZhaWx1cmVfZXJybm8gcHJvdmlkZXMgZXJybm8gY29kZXMgdGhhdCBhcmUgaW50ZXJwcmV0ZWQgYmV5b25kIGVycm9yCiAqIHJlcG9ydGluZy4gVGhlIGZvbGxvd2luZyBlcnJvciBjb2RlcyBoYXZlIHNwZWNpYWwgbWVhbmluZzoKICogICAgKiBFTk9FTlQ6IHRoZSByZWYgZG9lc24ndCBleGlzdAogKiAgICAqIEVJU0RJUjogcmVmIG5hbWUgaXMgYSBkaXJlY3RvcnkKICogICAgKiBFTk9URElSOiByZWYgcHJlZml4IGlzIG5vdCBhIGRpcmVjdG9yeQogKgogKiBCYWNrZW5kLXNwZWNpZmljIGZsYWdzIG1pZ2h0IGJlIHNldCBpbiB0eXBlIGFzIHdlbGwsIHJlZ2FyZGxlc3Mgb2YKICogb3V0Y29tZS4KICoKICogSXQgaXMgT0sgZm9yIHJlZm5hbWUgdG8gcG9pbnQgaW50byByZWZlcmVudC4gSWYgc286CiAqCiAqIC0gaWYgdGhlIGZ1bmN0aW9uIHN1Y2NlZWRzIHdpdGggUkVGX0lTU1lNUkVGLCByZWZlcmVudCB3aWxsIGJlCiAqICAgb3ZlcndyaXR0ZW4gYW5kIHRoZSBtZW1vcnkgZm9ybWVybHkgcG9pbnRlZCB0byBieSBpdCBtaWdodCBiZQogKiAgIGNoYW5nZWQgb3IgZXZlbiBmcmVlZC4KICoKICogLSBpbiBhbGwgb3RoZXIgY2FzZXMsIHJlZmVyZW50IHdpbGwgYmUgdW50b3VjaGVkLCBhbmQgdGhlcmVmb3JlCiAqICAgcmVmbmFtZSB3aWxsIHN0aWxsIGJlIHZhbGlkIGFuZCB1bmNoYW5nZWQuCiAqLwp0eXBlZGVmIGludCByZWFkX3Jhd19yZWZfZm4oc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlLCBjb25zdCBjaGFyICpyZWZuYW1lLAoJCQkgICAgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBzdHJ1Y3Qgc3RyYnVmICpyZWZlcmVudCwKCQkJICAgIHVuc2lnbmVkIGludCAqdHlwZSwgaW50ICpmYWlsdXJlX2Vycm5vKTsKCi8qCiAqIFJlYWQgYSBzeW1ib2xpYyByZWZlcmVuY2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlZmVyZW5jZSBzdG9yZS4gVGhpcyBmdW5jdGlvbgogKiBpcyBvcHRpb25hbDogaWYgbm90IGltcGxlbWVudGVkIGJ5IGEgYmFja2VuZCwgdGhlbiBgcmVhZF9yYXdfcmVmX2ZuYCBpcyB1c2VkCiAqIHRvIHJlYWQgdGhlIHN5bWJvbGNpYyByZWZlcmVuY2UgaW5zdGVhZC4gSXQgaXMgaW50ZW5kZWQgdG8gYmUgaW1wbGVtZW50ZWQKICogb25seSBpbiBjYXNlIHRoZSBiYWNrZW5kIGNhbiBvcHRpbWl6ZSB0aGUgcmVhZGluZyBvZiBzeW1ib2xpYyByZWZlcmVuY2VzLgogKgogKiBSZXR1cm4gMCBvbiBzdWNjZXNzLCBvciAtMSBvbiBmYWlsdXJlLiBgcmVmZXJlbnRgIHdpbGwgYmUgc2V0IHRvIHRoZSB0YXJnZXQKICogb2YgdGhlIHN5bWJvbGljIHJlZmVyZW5jZSBvbiBzdWNjZXNzLiBUaGlzIGZ1bmN0aW9uIGV4cGxpY2l0bHkgZG9lcyBub3QKICogZGlzdGluZ3Vpc2ggYmV0d2VlbiBlcnJvciBjYXNlcyBhbmQgdGhlIHJlZmVyZW5jZSBub3QgYmVpbmcgYSBzeW1ib2xpYwogKiByZWZlcmVuY2UgdG8gYWxsb3cgYmFja2VuZHMgdG8gb3B0aW1pemUgdGhpcyBvcGVyYXRpb24gaW4gY2FzZSBzeW1ib2xpYyBhbmQKICogbm9uLXN5bWJvbGljIHJlZmVyZW5jZXMgYXJlIHRyZWF0ZWQgZGlmZmVyZW50bHkuCiAqLwp0eXBlZGVmIGludCByZWFkX3N5bWJvbGljX3JlZl9mbihzdHJ1Y3QgcmVmX3N0b3JlICpyZWZfc3RvcmUsIGNvbnN0IGNoYXIgKnJlZm5hbWUsCgkJCQkgc3RydWN0IHN0cmJ1ZiAqcmVmZXJlbnQpOwoKc3RydWN0IHJlZl9zdG9yYWdlX2JlIHsKCXN0cnVjdCByZWZfc3RvcmFnZV9iZSAqbmV4dDsKCWNvbnN0IGNoYXIgKm5hbWU7CglyZWZfc3RvcmVfaW5pdF9mbiAqaW5pdDsKCXJlZl9pbml0X2RiX2ZuICppbml0X2RiOwoKCXJlZl90cmFuc2FjdGlvbl9wcmVwYXJlX2ZuICp0cmFuc2FjdGlvbl9wcmVwYXJlOwoJcmVmX3RyYW5zYWN0aW9uX2ZpbmlzaF9mbiAqdHJhbnNhY3Rpb25fZmluaXNoOwoJcmVmX3RyYW5zYWN0aW9uX2Fib3J0X2ZuICp0cmFuc2FjdGlvbl9hYm9ydDsKCXJlZl90cmFuc2FjdGlvbl9jb21taXRfZm4gKmluaXRpYWxfdHJhbnNhY3Rpb25fY29tbWl0OwoKCXBhY2tfcmVmc19mbiAqcGFja19yZWZzOwoJY3JlYXRlX3N5bXJlZl9mbiAqY3JlYXRlX3N5bXJlZjsKCWRlbGV0ZV9yZWZzX2ZuICpkZWxldGVfcmVmczsKCXJlbmFtZV9yZWZfZm4gKnJlbmFtZV9yZWY7Cgljb3B5X3JlZl9mbiAqY29weV9yZWY7CgoJcmVmX2l0ZXJhdG9yX2JlZ2luX2ZuICppdGVyYXRvcl9iZWdpbjsKCXJlYWRfcmF3X3JlZl9mbiAqcmVhZF9yYXdfcmVmOwoJcmVhZF9zeW1ib2xpY19yZWZfZm4gKnJlYWRfc3ltYm9saWNfcmVmOwoKCXJlZmxvZ19pdGVyYXRvcl9iZWdpbl9mbiAqcmVmbG9nX2l0ZXJhdG9yX2JlZ2luOwoJZm9yX2VhY2hfcmVmbG9nX2VudF9mbiAqZm9yX2VhY2hfcmVmbG9nX2VudDsKCWZvcl9lYWNoX3JlZmxvZ19lbnRfcmV2ZXJzZV9mbiAqZm9yX2VhY2hfcmVmbG9nX2VudF9yZXZlcnNlOwoJcmVmbG9nX2V4aXN0c19mbiAqcmVmbG9nX2V4aXN0czsKCWNyZWF0ZV9yZWZsb2dfZm4gKmNyZWF0ZV9yZWZsb2c7CglkZWxldGVfcmVmbG9nX2ZuICpkZWxldGVfcmVmbG9nOwoJcmVmbG9nX2V4cGlyZV9mbiAqcmVmbG9nX2V4cGlyZTsKfTsKCmV4dGVybiBzdHJ1Y3QgcmVmX3N0b3JhZ2VfYmUgcmVmc19iZV9maWxlczsKZXh0ZXJuIHN0cnVjdCByZWZfc3RvcmFnZV9iZSByZWZzX2JlX3BhY2tlZDsKCi8qCiAqIEEgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJlZmVyZW5jZSBzdG9yZSBmb3IgdGhlIG1haW4gcmVwb3NpdG9yeSBvcgogKiBhIHN1Ym1vZHVsZS4gVGhlIHJlZl9zdG9yZSBpbnN0YW5jZXMgZm9yIHN1Ym1vZHVsZXMgYXJlIGtlcHQgaW4gYQogKiBoYXNoIG1hcDsgc2VlIGdldF9zdWJtb2R1bGVfcmVmX3N0b3JlKCkgZm9yIG1vcmUgaW5mby4KICovCnN0cnVjdCByZWZfc3RvcmUgewoJLyogVGhlIGJhY2tlbmQgZGVzY3JpYmluZyB0aGlzIHJlZl9zdG9yZSdzIHN0b3JhZ2Ugc2NoZW1lOiAqLwoJY29uc3Qgc3RydWN0IHJlZl9zdG9yYWdlX2JlICpiZTsKCglzdHJ1Y3QgcmVwb3NpdG9yeSAqcmVwbzsKCgkvKgoJICogVGhlIGdpdGRpciB0aGF0IHRoaXMgcmVmX3N0b3JlIGFwcGxpZXMgdG8uIE5vdGUgdGhhdCB0aGlzIGlzIG5vdAoJICogbmVjZXNzYXJpbHkgcmVwby0+Z2l0ZGlyIGlmIHRoZSByZXBvIGhhcyBtdWx0aXBsZSB3b3JrdHJlZXMuCgkgKi8KCWNoYXIgKmdpdGRpcjsKfTsKCi8qCiAqIFBhcnNlIGNvbnRlbnRzIG9mIGEgbG9vc2UgcmVmIGZpbGUuICpmYWlsdXJlX2Vycm5vIG1heWJlIGJlIHNldCB0byBFSU5WQUwgZm9yCiAqIGludmFsaWQgY29udGVudHMuCiAqLwppbnQgcGFyc2VfbG9vc2VfcmVmX2NvbnRlbnRzKGNvbnN0IGNoYXIgKmJ1Ziwgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgICAgIHN0cnVjdCBzdHJidWYgKnJlZmVyZW50LCB1bnNpZ25lZCBpbnQgKnR5cGUsCgkJCSAgICAgaW50ICpmYWlsdXJlX2Vycm5vKTsKCi8qCiAqIEZpbGwgaW4gdGhlIGdlbmVyaWMgcGFydCBvZiByZWZzIGFuZCBhZGQgaXQgdG8gb3VyIGNvbGxlY3Rpb24gb2YKICogcmVmZXJlbmNlIHN0b3Jlcy4KICovCnZvaWQgYmFzZV9yZWZfc3RvcmVfaW5pdChzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLCBzdHJ1Y3QgcmVwb3NpdG9yeSAqcmVwbywKCQkJIGNvbnN0IGNoYXIgKnBhdGgsIGNvbnN0IHN0cnVjdCByZWZfc3RvcmFnZV9iZSAqYmUpOwoKLyoKICogU3VwcG9ydCBHSVRfVFJBQ0VfUkVGUyBieSBvcHRpb25hbGx5IHdyYXBwaW5nIHRoZSBnaXZlbiByZWZfc3RvcmUgaW5zdGFuY2UuCiAqLwpzdHJ1Y3QgcmVmX3N0b3JlICptYXliZV9kZWJ1Z193cmFwX3JlZl9zdG9yZShjb25zdCBjaGFyICpnaXRkaXIsIHN0cnVjdCByZWZfc3RvcmUgKnN0b3JlKTsKCiNlbmRpZiAvKiBSRUZTX1JFRlNfSU5URVJOQUxfSCAqLwo=",
    "text": "#ifndef REFS_REFS_INTERNAL_H\n#define REFS_REFS_INTERNAL_H\n\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n\nstruct ref_transaction;\n\n/*\n * Data structures and functions for the internal use of the refs\n * module. Code outside of the refs module should use only the public\n * functions defined in \"refs.h\", and should *not* include this file.\n */\n\n/*\n * The following flags can appear in `ref_update::flags`. Their\n * numerical values must not conflict with those of REF_NO_DEREF and\n * REF_FORCE_CREATE_REFLOG, which are also stored in\n * `ref_update::flags`.\n */\n\n/*\n * The reference should be updated to new_oid.\n */\n#define REF_HAVE_NEW (1 << 2)\n\n/*\n * The current reference's value should be checked to make sure that\n * it agrees with old_oid.\n */\n#define REF_HAVE_OLD (1 << 3)\n\n/*\n * Used as a flag in ref_update::flags when we want to log a ref\n * update but not actually perform it.  This is used when a symbolic\n * ref update is split up.\n */\n#define REF_LOG_ONLY (1 << 7)\n\n/*\n * Return the length of time to retry acquiring a loose reference lock\n * before giving up, in milliseconds:\n */\nlong get_files_ref_lock_timeout_ms(void);\n\n/*\n * Return true iff refname is minimally safe. \"Safe\" here means that\n * deleting a loose reference by this name will not do any damage, for\n * example by causing a file that is not a reference to be deleted.\n * This function does not check that the reference name is legal; for\n * that, use check_refname_format().\n *\n * A refname that starts with \"refs/\" is considered safe iff it\n * doesn't contain any \".\" or \"..\" components or consecutive '/'\n * characters, end with '/', or (on Windows) contain any '\\'\n * characters. Names that do not start with \"refs/\" are considered\n * safe iff they consist entirely of upper case characters and '_'\n * (like \"HEAD\" and \"MERGE_HEAD\" but not \"config\" or \"FOO/BAR\").\n */\nint refname_is_safe(const char *refname);\n\n/*\n * Helper function: return true if refname, which has the specified\n * oid and flags, can be resolved to an object in the database. If the\n * referred-to object does not exist, emit a warning and return false.\n */\nint ref_resolves_to_object(const char *refname,\n\t\t\t   struct repository *repo,\n\t\t\t   const struct object_id *oid,\n\t\t\t   unsigned int flags);\n\nenum peel_status {\n\t/* object was peeled successfully: */\n\tPEEL_PEELED = 0,\n\n\t/*\n\t * object cannot be peeled because the named object (or an\n\t * object referred to by a tag in the peel chain), does not\n\t * exist.\n\t */\n\tPEEL_INVALID = -1,\n\n\t/* object cannot be peeled because it is not a tag: */\n\tPEEL_NON_TAG = -2,\n\n\t/* ref_entry contains no peeled value because it is a symref: */\n\tPEEL_IS_SYMREF = -3,\n\n\t/*\n\t * ref_entry cannot be peeled because it is broken (i.e., the\n\t * symbolic reference cannot even be resolved to an object\n\t * name):\n\t */\n\tPEEL_BROKEN = -4\n};\n\n/*\n * Peel the named object; i.e., if the object is a tag, resolve the\n * tag recursively until a non-tag is found.  If successful, store the\n * result to oid and return PEEL_PEELED.  If the object is not a tag\n * or is not valid, return PEEL_NON_TAG or PEEL_INVALID, respectively,\n * and leave oid unchanged.\n */\nenum peel_status peel_object(const struct object_id *name, struct object_id *oid);\n\n/**\n * Information needed for a single ref update. Set new_oid to the new\n * value or to null_oid to delete the ref. To check the old value\n * while the ref is locked, set (flags & REF_HAVE_OLD) and set old_oid\n * to the old value, or to null_oid to ensure the ref does not exist\n * before update.\n */\nstruct ref_update {\n\t/*\n\t * If (flags & REF_HAVE_NEW), set the reference to this value\n\t * (or delete it, if `new_oid` is `null_oid`).\n\t */\n\tstruct object_id new_oid;\n\n\t/*\n\t * If (flags & REF_HAVE_OLD), check that the reference\n\t * previously had this value (or didn't previously exist, if\n\t * `old_oid` is `null_oid`).\n\t */\n\tstruct object_id old_oid;\n\n\t/*\n\t * One or more of REF_NO_DEREF, REF_FORCE_CREATE_REFLOG,\n\t * REF_HAVE_NEW, REF_HAVE_OLD, or backend-specific flags.\n\t */\n\tunsigned int flags;\n\n\tvoid *backend_data;\n\tunsigned int type;\n\tchar *msg;\n\n\t/*\n\t * If this ref_update was split off of a symref update via\n\t * split_symref_update(), then this member points at that\n\t * update. This is used for two purposes:\n\t * 1. When reporting errors, we report the refname under which\n\t *    the update was originally requested.\n\t * 2. When we read the old value of this reference, we\n\t *    propagate it back to its parent update for recording in\n\t *    the latter's reflog.\n\t */\n\tstruct ref_update *parent_update;\n\n\tconst char refname[FLEX_ARRAY];\n};\n\nint refs_read_raw_ref(struct ref_store *ref_store, const char *refname,\n\t\t      struct object_id *oid, struct strbuf *referent,\n\t\t      unsigned int *type, int *failure_errno);\n\n/*\n * Write an error to `err` and return a nonzero value iff the same\n * refname appears multiple times in `refnames`. `refnames` must be\n * sorted on entry to this function.\n */\nint ref_update_reject_duplicates(struct string_list *refnames,\n\t\t\t\t struct strbuf *err);\n\n/*\n * Add a ref_update with the specified properties to transaction, and\n * return a pointer to the new object. This function does not verify\n * that refname is well-formed. new_oid and old_oid are only\n * dereferenced if the REF_HAVE_NEW and REF_HAVE_OLD bits,\n * respectively, are set in flags.\n */\nstruct ref_update *ref_transaction_add_update(\n\t\tstruct ref_transaction *transaction,\n\t\tconst char *refname, unsigned int flags,\n\t\tconst struct object_id *new_oid,\n\t\tconst struct object_id *old_oid,\n\t\tconst char *msg);\n\n/*\n * Transaction states.\n *\n * OPEN:   The transaction is initialized and new updates can still be\n *         added to it. An OPEN transaction can be prepared,\n *         committed, freed, or aborted (freeing and aborting an open\n *         transaction are equivalent).\n *\n * PREPARED: ref_transaction_prepare(), which locks all of the\n *         references involved in the update and checks that the\n *         update has no errors, has been called successfully for the\n *         transaction. A PREPARED transaction can be committed or\n *         aborted.\n *\n * CLOSED: The transaction is no longer active. A transaction becomes\n *         CLOSED if there is a failure while building the transaction\n *         or if a transaction is committed or aborted. A CLOSED\n *         transaction can only be freed.\n */\nenum ref_transaction_state {\n\tREF_TRANSACTION_OPEN     = 0,\n\tREF_TRANSACTION_PREPARED = 1,\n\tREF_TRANSACTION_CLOSED   = 2\n};\n\n/*\n * Data structure for holding a reference transaction, which can\n * consist of checks and updates to multiple references, carried out\n * as atomically as possible.  This structure is opaque to callers.\n */\nstruct ref_transaction {\n\tstruct ref_store *ref_store;\n\tstruct ref_update **updates;\n\tsize_t alloc;\n\tsize_t nr;\n\tenum ref_transaction_state state;\n\tvoid *backend_data;\n\tunsigned int flags;\n};\n\n/*\n * Check for entries in extras that are within the specified\n * directory, where dirname is a reference directory name including\n * the trailing slash (e.g., \"refs/heads/foo/\"). Ignore any\n * conflicting references that are found in skip. If there is a\n * conflicting reference, return its name.\n *\n * extras and skip must be sorted lists of reference names. Either one\n * can be NULL, signifying the empty list.\n */\nconst char *find_descendant_ref(const char *dirname,\n\t\t\t\tconst struct string_list *extras,\n\t\t\t\tconst struct string_list *skip);\n\n/* We allow \"recursive\" symbolic refs. Only within reason, though */\n#define SYMREF_MAXDEPTH 5\n\n/*\n * These flags are passed to refs_ref_iterator_begin() (and do_for_each_ref(),\n * which feeds it).\n */\nenum do_for_each_ref_flags {\n\t/*\n\t * Include broken references in a do_for_each_ref*() iteration, which\n\t * would normally be omitted. This includes both refs that point to\n\t * missing objects (a true repository corruption), ones with illegal\n\t * names (which we prefer not to expose to callers), as well as\n\t * dangling symbolic refs (i.e., those that point to a non-existent\n\t * ref; this is not a corruption, but as they have no valid oid, we\n\t * omit them from normal iteration results).\n\t */\n\tDO_FOR_EACH_INCLUDE_BROKEN = (1 << 0),\n\n\t/*\n\t * Only include per-worktree refs in a do_for_each_ref*() iteration.\n\t * Normally this will be used with a files ref_store, since that's\n\t * where all reference backends will presumably store their\n\t * per-worktree refs.\n\t */\n\tDO_FOR_EACH_PER_WORKTREE_ONLY = (1 << 1),\n\n\t/*\n\t * Omit dangling symrefs from output; this only has an effect with\n\t * INCLUDE_BROKEN, since they are otherwise not included at all.\n\t */\n\tDO_FOR_EACH_OMIT_DANGLING_SYMREFS = (1 << 2),\n};\n\n/*\n * Reference iterators\n *\n * A reference iterator encapsulates the state of an in-progress\n * iteration over references. Create an instance of `struct\n * ref_iterator` via one of the functions in this module.\n *\n * A freshly-created ref_iterator doesn't yet point at a reference. To\n * advance the iterator, call ref_iterator_advance(). If successful,\n * this sets the iterator's refname, oid, and flags fields to describe\n * the next reference and returns ITER_OK. The data pointed at by\n * refname and oid belong to the iterator; if you want to retain them\n * after calling ref_iterator_advance() again or calling\n * ref_iterator_abort(), you must make a copy. When the iteration has\n * been exhausted, ref_iterator_advance() releases any resources\n * associated with the iteration, frees the ref_iterator object, and\n * returns ITER_DONE. If you want to abort the iteration early, call\n * ref_iterator_abort(), which also frees the ref_iterator object and\n * any associated resources. If there was an internal error advancing\n * to the next entry, ref_iterator_advance() aborts the iteration,\n * frees the ref_iterator, and returns ITER_ERROR.\n *\n * The reference currently being looked at can be peeled by calling\n * ref_iterator_peel(). This function is often faster than peel_ref(),\n * so it should be preferred when iterating over references.\n *\n * Putting it all together, a typical iteration looks like this:\n *\n *     int ok;\n *     struct ref_iterator *iter = ...;\n *\n *     while ((ok = ref_iterator_advance(iter)) == ITER_OK) {\n *             if (want_to_stop_iteration()) {\n *                     ok = ref_iterator_abort(iter);\n *                     break;\n *             }\n *\n *             // Access information about the current reference:\n *             if (!(iter->flags & REF_ISSYMREF))\n *                     printf(\"%s is %s\\n\", iter->refname, oid_to_hex(iter->oid));\n *\n *             // If you need to peel the reference:\n *             ref_iterator_peel(iter, &oid);\n *     }\n *\n *     if (ok != ITER_DONE)\n *             handle_error();\n */\nstruct ref_iterator {\n\tstruct ref_iterator_vtable *vtable;\n\n\t/*\n\t * Does this `ref_iterator` iterate over references in order\n\t * by refname?\n\t */\n\tunsigned int ordered : 1;\n\n\tconst char *refname;\n\tconst struct object_id *oid;\n\tunsigned int flags;\n};\n\n/*\n * Advance the iterator to the first or next item and return ITER_OK.\n * If the iteration is exhausted, free the resources associated with\n * the ref_iterator and return ITER_DONE. On errors, free the iterator\n * resources and return ITER_ERROR. It is a bug to use ref_iterator or\n * call this function again after it has returned ITER_DONE or\n * ITER_ERROR.\n */\nint ref_iterator_advance(struct ref_iterator *ref_iterator);\n\n/*\n * If possible, peel the reference currently being viewed by the\n * iterator. Return 0 on success.\n */\nint ref_iterator_peel(struct ref_iterator *ref_iterator,\n\t\t      struct object_id *peeled);\n\n/*\n * End the iteration before it has been exhausted, freeing the\n * reference iterator and any associated resources and returning\n * ITER_DONE. If the abort itself failed, return ITER_ERROR.\n */\nint ref_iterator_abort(struct ref_iterator *ref_iterator);\n\n/*\n * An iterator over nothing (its first ref_iterator_advance() call\n * returns ITER_DONE).\n */\nstruct ref_iterator *empty_ref_iterator_begin(void);\n\n/*\n * Return true iff ref_iterator is an empty_ref_iterator.\n */\nint is_empty_ref_iterator(struct ref_iterator *ref_iterator);\n\n/*\n * Return an iterator that goes over each reference in `refs` for\n * which the refname begins with prefix. If trim is non-zero, then\n * trim that many characters off the beginning of each refname.\n * The output is ordered by refname.\n */\nstruct ref_iterator *refs_ref_iterator_begin(\n\t\tstruct ref_store *refs,\n\t\tconst char *prefix, int trim,\n\t\tenum do_for_each_ref_flags flags);\n\n/*\n * A callback function used to instruct merge_ref_iterator how to\n * interleave the entries from iter0 and iter1. The function should\n * return one of the constants defined in enum iterator_selection. It\n * must not advance either of the iterators itself.\n *\n * The function must be prepared to handle the case that iter0 and/or\n * iter1 is NULL, which indicates that the corresponding sub-iterator\n * has been exhausted. Its return value must be consistent with the\n * current states of the iterators; e.g., it must not return\n * ITER_SKIP_1 if iter1 has already been exhausted.\n */\ntypedef enum iterator_selection ref_iterator_select_fn(\n\t\tstruct ref_iterator *iter0, struct ref_iterator *iter1,\n\t\tvoid *cb_data);\n\n/*\n * Iterate over the entries from iter0 and iter1, with the values\n * interleaved as directed by the select function. The iterator takes\n * ownership of iter0 and iter1 and frees them when the iteration is\n * over. A derived class should set `ordered` to 1 or 0 based on\n * whether it generates its output in order by reference name.\n */\nstruct ref_iterator *merge_ref_iterator_begin(\n\t\tint ordered,\n\t\tstruct ref_iterator *iter0, struct ref_iterator *iter1,\n\t\tref_iterator_select_fn *select, void *cb_data);\n\n/*\n * An iterator consisting of the union of the entries from front and\n * back. If there are entries common to the two sub-iterators, use the\n * one from front. Each iterator must iterate over its entries in\n * strcmp() order by refname for this to work.\n *\n * The new iterator takes ownership of its arguments and frees them\n * when the iteration is over. As a convenience to callers, if front\n * or back is an empty_ref_iterator, then abort that one immediately\n * and return the other iterator directly, without wrapping it.\n */\nstruct ref_iterator *overlay_ref_iterator_begin(\n\t\tstruct ref_iterator *front, struct ref_iterator *back);\n\n/*\n * Wrap iter0, only letting through the references whose names start\n * with prefix. If trim is set, set iter->refname to the name of the\n * reference with that many characters trimmed off the front;\n * otherwise set it to the full refname. The new iterator takes over\n * ownership of iter0 and frees it when iteration is over. It makes\n * its own copy of prefix.\n *\n * As an convenience to callers, if prefix is the empty string and\n * trim is zero, this function returns iter0 directly, without\n * wrapping it.\n *\n * The resulting ref_iterator is ordered if iter0 is.\n */\nstruct ref_iterator *prefix_ref_iterator_begin(struct ref_iterator *iter0,\n\t\t\t\t\t       const char *prefix,\n\t\t\t\t\t       int trim);\n\n/* Internal implementation of reference iteration: */\n\n/*\n * Base class constructor for ref_iterators. Initialize the\n * ref_iterator part of iter, setting its vtable pointer as specified.\n * `ordered` should be set to 1 if the iterator will iterate over\n * references in order by refname; otherwise it should be set to 0.\n * This is meant to be called only by the initializers of derived\n * classes.\n */\nvoid base_ref_iterator_init(struct ref_iterator *iter,\n\t\t\t    struct ref_iterator_vtable *vtable,\n\t\t\t    int ordered);\n\n/*\n * Base class destructor for ref_iterators. Destroy the ref_iterator\n * part of iter and shallow-free the object. This is meant to be\n * called only by the destructors of derived classes.\n */\nvoid base_ref_iterator_free(struct ref_iterator *iter);\n\n/* Virtual function declarations for ref_iterators: */\n\n/*\n * backend-specific implementation of ref_iterator_advance. For symrefs, the\n * function should set REF_ISSYMREF, and it should also dereference the symref\n * to provide the OID referent. It should respect do_for_each_ref_flags\n * that were passed to refs_ref_iterator_begin().\n */\ntypedef int ref_iterator_advance_fn(struct ref_iterator *ref_iterator);\n\n/*\n * Peels the current ref, returning 0 for success or -1 for failure.\n */\ntypedef int ref_iterator_peel_fn(struct ref_iterator *ref_iterator,\n\t\t\t\t struct object_id *peeled);\n\n/*\n * Implementations of this function should free any resources specific\n * to the derived class, then call base_ref_iterator_free() to clean\n * up and free the ref_iterator object.\n */\ntypedef int ref_iterator_abort_fn(struct ref_iterator *ref_iterator);\n\nstruct ref_iterator_vtable {\n\tref_iterator_advance_fn *advance;\n\tref_iterator_peel_fn *peel;\n\tref_iterator_abort_fn *abort;\n};\n\n/*\n * current_ref_iter is a performance hack: when iterating over\n * references using the for_each_ref*() functions, current_ref_iter is\n * set to the reference iterator before calling the callback function.\n * If the callback function calls peel_ref(), then peel_ref() first\n * checks whether the reference to be peeled is the one referred to by\n * the iterator (it usually is) and if so, asks the iterator for the\n * peeled version of the reference if it is available. This avoids a\n * refname lookup in a common case. current_ref_iter is set to NULL\n * when the iteration is over.\n */\nextern struct ref_iterator *current_ref_iter;\n\n/*\n * The common backend for the for_each_*ref* functions. Call fn for\n * each reference in iter. If the iterator itself ever returns\n * ITER_ERROR, return -1. If fn ever returns a non-zero value, stop\n * the iteration and return that value. Otherwise, return 0. In any\n * case, free the iterator when done. This function is basically an\n * adapter between the callback style of reference iteration and the\n * iterator style.\n */\nint do_for_each_repo_ref_iterator(struct repository *r,\n\t\t\t\t  struct ref_iterator *iter,\n\t\t\t\t  each_repo_ref_fn fn, void *cb_data);\n\nstruct ref_store;\n\n/* refs backends */\n\n/* ref_store_init flags */\n#define REF_STORE_READ\t\t(1 << 0)\n#define REF_STORE_WRITE\t\t(1 << 1) /* can perform update operations */\n#define REF_STORE_ODB\t\t(1 << 2) /* has access to object database */\n#define REF_STORE_MAIN\t\t(1 << 3)\n#define REF_STORE_ALL_CAPS\t(REF_STORE_READ | \\\n\t\t\t\t REF_STORE_WRITE | \\\n\t\t\t\t REF_STORE_ODB | \\\n\t\t\t\t REF_STORE_MAIN)\n\n/*\n * Initialize the ref_store for the specified gitdir. These functions\n * should call base_ref_store_init() to initialize the shared part of\n * the ref_store and to record the ref_store for later lookup.\n */\ntypedef struct ref_store *ref_store_init_fn(struct repository *repo,\n\t\t\t\t\t    const char *gitdir,\n\t\t\t\t\t    unsigned int flags);\n\ntypedef int ref_init_db_fn(struct ref_store *refs, struct strbuf *err);\n\ntypedef int ref_transaction_prepare_fn(struct ref_store *refs,\n\t\t\t\t       struct ref_transaction *transaction,\n\t\t\t\t       struct strbuf *err);\n\ntypedef int ref_transaction_finish_fn(struct ref_store *refs,\n\t\t\t\t      struct ref_transaction *transaction,\n\t\t\t\t      struct strbuf *err);\n\ntypedef int ref_transaction_abort_fn(struct ref_store *refs,\n\t\t\t\t     struct ref_transaction *transaction,\n\t\t\t\t     struct strbuf *err);\n\ntypedef int ref_transaction_commit_fn(struct ref_store *refs,\n\t\t\t\t      struct ref_transaction *transaction,\n\t\t\t\t      struct strbuf *err);\n\ntypedef int pack_refs_fn(struct ref_store *ref_store, unsigned int flags);\ntypedef int create_symref_fn(struct ref_store *ref_store,\n\t\t\t     const char *ref_target,\n\t\t\t     const char *refs_heads_master,\n\t\t\t     const char *logmsg);\ntypedef int delete_refs_fn(struct ref_store *ref_store, const char *msg,\n\t\t\t   struct string_list *refnames, unsigned int flags);\ntypedef int rename_ref_fn(struct ref_store *ref_store,\n\t\t\t  const char *oldref, const char *newref,\n\t\t\t  const char *logmsg);\ntypedef int copy_ref_fn(struct ref_store *ref_store,\n\t\t\t  const char *oldref, const char *newref,\n\t\t\t  const char *logmsg);\n\n/*\n * Iterate over the references in `ref_store` whose names start with\n * `prefix`. `prefix` is matched as a literal string, without regard\n * for path separators. If prefix is NULL or the empty string, iterate\n * over all references in `ref_store`. The output is ordered by\n * refname.\n */\ntypedef struct ref_iterator *ref_iterator_begin_fn(\n\t\tstruct ref_store *ref_store,\n\t\tconst char *prefix, unsigned int flags);\n\n/* reflog functions */\n\n/*\n * Iterate over the references in the specified ref_store that have a\n * reflog. The refs are iterated over in arbitrary order.\n */\ntypedef struct ref_iterator *reflog_iterator_begin_fn(\n\t\tstruct ref_store *ref_store);\n\ntypedef int for_each_reflog_ent_fn(struct ref_store *ref_store,\n\t\t\t\t   const char *refname,\n\t\t\t\t   each_reflog_ent_fn fn,\n\t\t\t\t   void *cb_data);\ntypedef int for_each_reflog_ent_reverse_fn(struct ref_store *ref_store,\n\t\t\t\t\t   const char *refname,\n\t\t\t\t\t   each_reflog_ent_fn fn,\n\t\t\t\t\t   void *cb_data);\ntypedef int reflog_exists_fn(struct ref_store *ref_store, const char *refname);\ntypedef int create_reflog_fn(struct ref_store *ref_store, const char *refname,\n\t\t\t     struct strbuf *err);\ntypedef int delete_reflog_fn(struct ref_store *ref_store, const char *refname);\ntypedef int reflog_expire_fn(struct ref_store *ref_store,\n\t\t\t     const char *refname,\n\t\t\t     unsigned int flags,\n\t\t\t     reflog_expiry_prepare_fn prepare_fn,\n\t\t\t     reflog_expiry_should_prune_fn should_prune_fn,\n\t\t\t     reflog_expiry_cleanup_fn cleanup_fn,\n\t\t\t     void *policy_cb_data);\n\n/*\n * Read a reference from the specified reference store, non-recursively.\n * Set type to describe the reference, and:\n *\n * - If refname is the name of a normal reference, fill in oid\n *   (leaving referent unchanged).\n *\n * - If refname is the name of a symbolic reference, write the full\n *   name of the reference to which it refers (e.g.\n *   \"refs/heads/master\") to referent and set the REF_ISSYMREF bit in\n *   type (leaving oid unchanged). The caller is responsible for\n *   validating that referent is a valid reference name.\n *\n * WARNING: refname might be used as part of a filename, so it is\n * important from a security standpoint that it be safe in the sense\n * of refname_is_safe(). Moreover, for symrefs this function sets\n * referent to whatever the repository says, which might not be a\n * properly-formatted or even safe reference name. NEITHER INPUT NOR\n * OUTPUT REFERENCE NAMES ARE VALIDATED WITHIN THIS FUNCTION.\n *\n * Return 0 on success, or -1 on failure. If the ref exists but is neither a\n * symbolic ref nor an object ID, it is broken. In this case set REF_ISBROKEN in\n * type, and return -1 (failure_errno should not be ENOENT)\n *\n * failure_errno provides errno codes that are interpreted beyond error\n * reporting. The following error codes have special meaning:\n *    * ENOENT: the ref doesn't exist\n *    * EISDIR: ref name is a directory\n *    * ENOTDIR: ref prefix is not a directory\n *\n * Backend-specific flags might be set in type as well, regardless of\n * outcome.\n *\n * It is OK for refname to point into referent. If so:\n *\n * - if the function succeeds with REF_ISSYMREF, referent will be\n *   overwritten and the memory formerly pointed to by it might be\n *   changed or even freed.\n *\n * - in all other cases, referent will be untouched, and therefore\n *   refname will still be valid and unchanged.\n */\ntypedef int read_raw_ref_fn(struct ref_store *ref_store, const char *refname,\n\t\t\t    struct object_id *oid, struct strbuf *referent,\n\t\t\t    unsigned int *type, int *failure_errno);\n\n/*\n * Read a symbolic reference from the specified reference store. This function\n * is optional: if not implemented by a backend, then `read_raw_ref_fn` is used\n * to read the symbolcic reference instead. It is intended to be implemented\n * only in case the backend can optimize the reading of symbolic references.\n *\n * Return 0 on success, or -1 on failure. `referent` will be set to the target\n * of the symbolic reference on success. This function explicitly does not\n * distinguish between error cases and the reference not being a symbolic\n * reference to allow backends to optimize this operation in case symbolic and\n * non-symbolic references are treated differently.\n */\ntypedef int read_symbolic_ref_fn(struct ref_store *ref_store, const char *refname,\n\t\t\t\t struct strbuf *referent);\n\nstruct ref_storage_be {\n\tstruct ref_storage_be *next;\n\tconst char *name;\n\tref_store_init_fn *init;\n\tref_init_db_fn *init_db;\n\n\tref_transaction_prepare_fn *transaction_prepare;\n\tref_transaction_finish_fn *transaction_finish;\n\tref_transaction_abort_fn *transaction_abort;\n\tref_transaction_commit_fn *initial_transaction_commit;\n\n\tpack_refs_fn *pack_refs;\n\tcreate_symref_fn *create_symref;\n\tdelete_refs_fn *delete_refs;\n\trename_ref_fn *rename_ref;\n\tcopy_ref_fn *copy_ref;\n\n\tref_iterator_begin_fn *iterator_begin;\n\tread_raw_ref_fn *read_raw_ref;\n\tread_symbolic_ref_fn *read_symbolic_ref;\n\n\treflog_iterator_begin_fn *reflog_iterator_begin;\n\tfor_each_reflog_ent_fn *for_each_reflog_ent;\n\tfor_each_reflog_ent_reverse_fn *for_each_reflog_ent_reverse;\n\treflog_exists_fn *reflog_exists;\n\tcreate_reflog_fn *create_reflog;\n\tdelete_reflog_fn *delete_reflog;\n\treflog_expire_fn *reflog_expire;\n};\n\nextern struct ref_storage_be refs_be_files;\nextern struct ref_storage_be refs_be_packed;\n\n/*\n * A representation of the reference store for the main repository or\n * a submodule. The ref_store instances for submodules are kept in a\n * hash map; see get_submodule_ref_store() for more info.\n */\nstruct ref_store {\n\t/* The backend describing this ref_store's storage scheme: */\n\tconst struct ref_storage_be *be;\n\n\tstruct repository *repo;\n\n\t/*\n\t * The gitdir that this ref_store applies to. Note that this is not\n\t * necessarily repo->gitdir if the repo has multiple worktrees.\n\t */\n\tchar *gitdir;\n};\n\n/*\n * Parse contents of a loose ref file. *failure_errno maybe be set to EINVAL for\n * invalid contents.\n */\nint parse_loose_ref_contents(const char *buf, struct object_id *oid,\n\t\t\t     struct strbuf *referent, unsigned int *type,\n\t\t\t     int *failure_errno);\n\n/*\n * Fill in the generic part of refs and add it to our collection of\n * reference stores.\n */\nvoid base_ref_store_init(struct ref_store *refs, struct repository *repo,\n\t\t\t const char *path, const struct ref_storage_be *be);\n\n/*\n * Support GIT_TRACE_REFS by optionally wrapping the given ref_store instance.\n */\nstruct ref_store *maybe_debug_wrap_ref_store(const char *gitdir, struct ref_store *store);\n\n#endif /* REFS_REFS_INTERNAL_H */\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "001ef1583540b002241dfd1d351f72791d39cc9c",
  "sha1_ok": true,
  "size": 26576
}
