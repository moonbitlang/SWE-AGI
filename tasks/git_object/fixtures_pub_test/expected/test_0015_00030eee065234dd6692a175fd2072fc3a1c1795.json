{
  "content": {
    "base64": "LyoKQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQwoKVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUKbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0Cmh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL29wZW4tc291cmNlL2xpY2Vuc2VzL2JzZAoqLwoKI2luY2x1ZGUgImJsb2NrLmgiCgojaW5jbHVkZSAiYmxvY2tzb3VyY2UuaCIKI2luY2x1ZGUgImNvbnN0YW50cy5oIgojaW5jbHVkZSAicmVjb3JkLmgiCiNpbmNsdWRlICJyZWZ0YWJsZS1lcnJvci5oIgojaW5jbHVkZSAic3lzdGVtLmgiCiNpbmNsdWRlIDx6bGliLmg+CgppbnQgaGVhZGVyX3NpemUoaW50IHZlcnNpb24pCnsKCXN3aXRjaCAodmVyc2lvbikgewoJY2FzZSAxOgoJCXJldHVybiAyNDsKCWNhc2UgMjoKCQlyZXR1cm4gMjg7Cgl9CglhYm9ydCgpOwp9CgppbnQgZm9vdGVyX3NpemUoaW50IHZlcnNpb24pCnsKCXN3aXRjaCAodmVyc2lvbikgewoJY2FzZSAxOgoJCXJldHVybiA2ODsKCWNhc2UgMjoKCQlyZXR1cm4gNzI7Cgl9CglhYm9ydCgpOwp9CgpzdGF0aWMgaW50IGJsb2NrX3dyaXRlcl9yZWdpc3Rlcl9yZXN0YXJ0KHN0cnVjdCBibG9ja193cml0ZXIgKncsIGludCBuLAoJCQkJCSBpbnQgaXNfcmVzdGFydCwgc3RydWN0IHN0cmJ1ZiAqa2V5KQp7CglpbnQgcmxlbiA9IHctPnJlc3RhcnRfbGVuOwoJaWYgKHJsZW4gPj0gTUFYX1JFU1RBUlRTKSB7CgkJaXNfcmVzdGFydCA9IDA7Cgl9CgoJaWYgKGlzX3Jlc3RhcnQpIHsKCQlybGVuKys7Cgl9CglpZiAoMiArIDMgKiBybGVuICsgbiA+IHctPmJsb2NrX3NpemUgLSB3LT5uZXh0KQoJCXJldHVybiAtMTsKCWlmIChpc19yZXN0YXJ0KSB7CgkJUkVGVEFCTEVfQUxMT0NfR1JPVyh3LT5yZXN0YXJ0cywgdy0+cmVzdGFydF9sZW4gKyAxLCB3LT5yZXN0YXJ0X2NhcCk7CgkJdy0+cmVzdGFydHNbdy0+cmVzdGFydF9sZW4rK10gPSB3LT5uZXh0OwoJfQoKCXctPm5leHQgKz0gbjsKCglzdHJidWZfcmVzZXQoJnctPmxhc3Rfa2V5KTsKCXN0cmJ1Zl9hZGRidWYoJnctPmxhc3Rfa2V5LCBrZXkpOwoJdy0+ZW50cmllcysrOwoJcmV0dXJuIDA7Cn0KCnZvaWQgYmxvY2tfd3JpdGVyX2luaXQoc3RydWN0IGJsb2NrX3dyaXRlciAqYncsIHVpbnQ4X3QgdHlwLCB1aW50OF90ICpidWYsCgkJICAgICAgIHVpbnQzMl90IGJsb2NrX3NpemUsIHVpbnQzMl90IGhlYWRlcl9vZmYsIGludCBoYXNoX3NpemUpCnsKCWJ3LT5idWYgPSBidWY7Cglidy0+aGFzaF9zaXplID0gaGFzaF9zaXplOwoJYnctPmJsb2NrX3NpemUgPSBibG9ja19zaXplOwoJYnctPmhlYWRlcl9vZmYgPSBoZWFkZXJfb2ZmOwoJYnctPmJ1ZltoZWFkZXJfb2ZmXSA9IHR5cDsKCWJ3LT5uZXh0ID0gaGVhZGVyX29mZiArIDQ7Cglidy0+cmVzdGFydF9pbnRlcnZhbCA9IDE2OwoJYnctPmVudHJpZXMgPSAwOwoJYnctPnJlc3RhcnRfbGVuID0gMDsKCWJ3LT5sYXN0X2tleS5sZW4gPSAwOwoJaWYgKCFidy0+enN0cmVhbSkgewoJCVJFRlRBQkxFX0NBTExPQ19BUlJBWShidy0+enN0cmVhbSwgMSk7CgkJZGVmbGF0ZUluaXQoYnctPnpzdHJlYW0sIDkpOwoJfQp9Cgp1aW50OF90IGJsb2NrX3dyaXRlcl90eXBlKHN0cnVjdCBibG9ja193cml0ZXIgKmJ3KQp7CglyZXR1cm4gYnctPmJ1Zltidy0+aGVhZGVyX29mZl07Cn0KCi8qIEFkZHMgdGhlIHJlZnRhYmxlX3JlY29yZCB0byB0aGUgYmxvY2suIFJldHVybnMgLTEgaWYgaXQgZG9lcyBub3QgZml0LCAwIG9uCiAgIHN1Y2Nlc3MuIFJldHVybnMgUkVGVEFCTEVfQVBJX0VSUk9SIGlmIGF0dGVtcHRpbmcgdG8gd3JpdGUgYSByZWNvcmQgd2l0aAogICBlbXB0eSBrZXkuICovCmludCBibG9ja193cml0ZXJfYWRkKHN0cnVjdCBibG9ja193cml0ZXIgKncsIHN0cnVjdCByZWZ0YWJsZV9yZWNvcmQgKnJlYykKewoJc3RydWN0IHN0cmJ1ZiBlbXB0eSA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBsYXN0ID0KCQl3LT5lbnRyaWVzICUgdy0+cmVzdGFydF9pbnRlcnZhbCA9PSAwID8gZW1wdHkgOiB3LT5sYXN0X2tleTsKCXN0cnVjdCBzdHJpbmdfdmlldyBvdXQgPSB7CgkJLmJ1ZiA9IHctPmJ1ZiArIHctPm5leHQsCgkJLmxlbiA9IHctPmJsb2NrX3NpemUgLSB3LT5uZXh0LAoJfTsKCglzdHJ1Y3Qgc3RyaW5nX3ZpZXcgc3RhcnQgPSBvdXQ7CgoJaW50IGlzX3Jlc3RhcnQgPSAwOwoJc3RydWN0IHN0cmJ1ZiBrZXkgPSBTVFJCVUZfSU5JVDsKCWludCBuID0gMDsKCWludCBlcnIgPSAtMTsKCglyZWZ0YWJsZV9yZWNvcmRfa2V5KHJlYywgJmtleSk7CglpZiAoIWtleS5sZW4pIHsKCQllcnIgPSBSRUZUQUJMRV9BUElfRVJST1I7CgkJZ290byBkb25lOwoJfQoKCW4gPSByZWZ0YWJsZV9lbmNvZGVfa2V5KCZpc19yZXN0YXJ0LCBvdXQsIGxhc3QsIGtleSwKCQkJCXJlZnRhYmxlX3JlY29yZF92YWxfdHlwZShyZWMpKTsKCWlmIChuIDwgMCkKCQlnb3RvIGRvbmU7CglzdHJpbmdfdmlld19jb25zdW1lKCZvdXQsIG4pOwoKCW4gPSByZWZ0YWJsZV9yZWNvcmRfZW5jb2RlKHJlYywgb3V0LCB3LT5oYXNoX3NpemUpOwoJaWYgKG4gPCAwKQoJCWdvdG8gZG9uZTsKCXN0cmluZ192aWV3X2NvbnN1bWUoJm91dCwgbik7CgoJZXJyID0gYmxvY2tfd3JpdGVyX3JlZ2lzdGVyX3Jlc3RhcnQodywgc3RhcnQubGVuIC0gb3V0LmxlbiwgaXNfcmVzdGFydCwKCQkJCQkgICAgJmtleSk7CmRvbmU6CglzdHJidWZfcmVsZWFzZSgma2V5KTsKCXJldHVybiBlcnI7Cn0KCmludCBibG9ja193cml0ZXJfZmluaXNoKHN0cnVjdCBibG9ja193cml0ZXIgKncpCnsKCWludCBpOwoJZm9yIChpID0gMDsgaSA8IHctPnJlc3RhcnRfbGVuOyBpKyspIHsKCQlwdXRfYmUyNCh3LT5idWYgKyB3LT5uZXh0LCB3LT5yZXN0YXJ0c1tpXSk7CgkJdy0+bmV4dCArPSAzOwoJfQoKCXB1dF9iZTE2KHctPmJ1ZiArIHctPm5leHQsIHctPnJlc3RhcnRfbGVuKTsKCXctPm5leHQgKz0gMjsKCXB1dF9iZTI0KHctPmJ1ZiArIDEgKyB3LT5oZWFkZXJfb2ZmLCB3LT5uZXh0KTsKCgkvKgoJICogTG9nIHJlY29yZHMgYXJlIHN0b3JlZCB6bGliLWNvbXByZXNzZWQuIE5vdGUgdGhhdCB0aGUgY29tcHJlc3Npb24KCSAqIGFsc28gc3BhbnMgb3ZlciB0aGUgcmVzdGFydCBwb2ludHMgd2UgaGF2ZSBqdXN0IHdyaXR0ZW4uCgkgKi8KCWlmIChibG9ja193cml0ZXJfdHlwZSh3KSA9PSBCTE9DS19UWVBFX0xPRykgewoJCWludCBibG9ja19oZWFkZXJfc2tpcCA9IDQgKyB3LT5oZWFkZXJfb2ZmOwoJCXVMb25nZiBzcmNfbGVuID0gdy0+bmV4dCAtIGJsb2NrX2hlYWRlcl9za2lwLCBjb21wcmVzc2VkX2xlbjsKCQlpbnQgcmV0OwoKCQlyZXQgPSBkZWZsYXRlUmVzZXQody0+enN0cmVhbSk7CgkJaWYgKHJldCAhPSBaX09LKQoJCQlyZXR1cm4gUkVGVEFCTEVfWkxJQl9FUlJPUjsKCgkJLyoKCQkgKiBQcmVjb21wdXRlIHRoZSB1cHBlciBib3VuZCBvZiBob3cgbWFueSBieXRlcyB0aGUgY29tcHJlc3NlZAoJCSAqIGRhdGEgbWF5IGVuZCB1cCB3aXRoLiBDb21iaW5lZCB3aXRoIGBaX0ZJTklTSGAsIGBkZWZsYXRlKClgCgkJICogaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gYFpfU1RSRUFNX0VORGAuCgkJICovCgkJY29tcHJlc3NlZF9sZW4gPSBkZWZsYXRlQm91bmQody0+enN0cmVhbSwgc3JjX2xlbik7CgkJUkVGVEFCTEVfQUxMT0NfR1JPVyh3LT5jb21wcmVzc2VkLCBjb21wcmVzc2VkX2xlbiwgdy0+Y29tcHJlc3NlZF9jYXApOwoKCQl3LT56c3RyZWFtLT5uZXh0X291dCA9IHctPmNvbXByZXNzZWQ7CgkJdy0+enN0cmVhbS0+YXZhaWxfb3V0ID0gY29tcHJlc3NlZF9sZW47CgkJdy0+enN0cmVhbS0+bmV4dF9pbiA9IHctPmJ1ZiArIGJsb2NrX2hlYWRlcl9za2lwOwoJCXctPnpzdHJlYW0tPmF2YWlsX2luID0gc3JjX2xlbjsKCgkJLyoKCQkgKiBXZSB3YW50IHRvIHBlcmZvcm0gYWxsIGRlY29tcHJlc3Npb24gaW4gYSBzaW5nbGUgc3RlcCwgd2hpY2gKCQkgKiBpcyB3aHkgd2UgY2FuIHBhc3MgWl9GSU5JU0ggaGVyZS4gQXMgd2UgaGF2ZSBwcmVjb21wdXRlZCB0aGUKCQkgKiBkZWZsYXRlZCBidWZmZXIncyBzaXplIHZpYSBgZGVmbGF0ZUJvdW5kKClgIHRoaXMgZnVuY3Rpb24gaXMKCQkgKiBndWFyYW50ZWVkIHRvIHN1Y2NlZWQgYWNjb3JkaW5nIHRvIHRoZSB6bGliIGRvY3VtZW50YXRpb24uCgkJICovCgkJcmV0ID0gZGVmbGF0ZSh3LT56c3RyZWFtLCBaX0ZJTklTSCk7CgkJaWYgKHJldCAhPSBaX1NUUkVBTV9FTkQpCgkJCXJldHVybiBSRUZUQUJMRV9aTElCX0VSUk9SOwoKCQkvKgoJCSAqIE92ZXJ3cml0ZSB0aGUgdW5jb21wcmVzc2VkIGRhdGEgd2UgaGF2ZSBhbHJlYWR5IHdyaXR0ZW4gYW5kCgkJICogYWRqdXN0IHRoZSBgbmV4dGAgcG9pbnRlciB0byBwb2ludCByaWdodCBhZnRlciB0aGUKCQkgKiBjb21wcmVzc2VkIGRhdGEuCgkJICovCgkJbWVtY3B5KHctPmJ1ZiArIGJsb2NrX2hlYWRlcl9za2lwLCB3LT5jb21wcmVzc2VkLAoJCSAgICAgICB3LT56c3RyZWFtLT50b3RhbF9vdXQpOwoJCXctPm5leHQgPSB3LT56c3RyZWFtLT50b3RhbF9vdXQgKyBibG9ja19oZWFkZXJfc2tpcDsKCX0KCglyZXR1cm4gdy0+bmV4dDsKfQoKaW50IGJsb2NrX3JlYWRlcl9pbml0KHN0cnVjdCBibG9ja19yZWFkZXIgKmJyLCBzdHJ1Y3QgcmVmdGFibGVfYmxvY2sgKmJsb2NrLAoJCSAgICAgIHVpbnQzMl90IGhlYWRlcl9vZmYsIHVpbnQzMl90IHRhYmxlX2Jsb2NrX3NpemUsCgkJICAgICAgaW50IGhhc2hfc2l6ZSkKewoJdWludDMyX3QgZnVsbF9ibG9ja19zaXplID0gdGFibGVfYmxvY2tfc2l6ZTsKCXVpbnQ4X3QgdHlwID0gYmxvY2stPmRhdGFbaGVhZGVyX29mZl07Cgl1aW50MzJfdCBzeiA9IGdldF9iZTI0KGJsb2NrLT5kYXRhICsgaGVhZGVyX29mZiArIDEpOwoJaW50IGVyciA9IDA7Cgl1aW50MTZfdCByZXN0YXJ0X2NvdW50ID0gMDsKCXVpbnQzMl90IHJlc3RhcnRfc3RhcnQgPSAwOwoJdWludDhfdCAqcmVzdGFydF9ieXRlcyA9IE5VTEw7CgoJcmVmdGFibGVfYmxvY2tfZG9uZSgmYnItPmJsb2NrKTsKCglpZiAoIXJlZnRhYmxlX2lzX2Jsb2NrX3R5cGUodHlwKSkgewoJCWVyciA9ICBSRUZUQUJMRV9GT1JNQVRfRVJST1I7CgkJZ290byBkb25lOwoJfQoKCWlmICh0eXAgPT0gQkxPQ0tfVFlQRV9MT0cpIHsKCQl1aW50MzJfdCBibG9ja19oZWFkZXJfc2tpcCA9IDQgKyBoZWFkZXJfb2ZmOwoJCXVMb25nIGRzdF9sZW4gPSBzeiAtIGJsb2NrX2hlYWRlcl9za2lwOwoJCXVMb25nIHNyY19sZW4gPSBibG9jay0+bGVuIC0gYmxvY2tfaGVhZGVyX3NraXA7CgoJCS8qIExvZyBibG9ja3Mgc3BlY2lmeSB0aGUgKnVuY29tcHJlc3NlZCogc2l6ZSBpbiB0aGVpciBoZWFkZXIuICovCgkJUkVGVEFCTEVfQUxMT0NfR1JPVyhici0+dW5jb21wcmVzc2VkX2RhdGEsIHN6LAoJCQkJICAgIGJyLT51bmNvbXByZXNzZWRfY2FwKTsKCgkJLyogQ29weSBvdmVyIHRoZSBibG9jayBoZWFkZXIgdmVyYmF0aW0uIEl0J3Mgbm90IGNvbXByZXNzZWQuICovCgkJbWVtY3B5KGJyLT51bmNvbXByZXNzZWRfZGF0YSwgYmxvY2stPmRhdGEsIGJsb2NrX2hlYWRlcl9za2lwKTsKCgkJaWYgKCFici0+enN0cmVhbSkgewoJCQlSRUZUQUJMRV9DQUxMT0NfQVJSQVkoYnItPnpzdHJlYW0sIDEpOwoJCQllcnIgPSBpbmZsYXRlSW5pdChici0+enN0cmVhbSk7CgkJfSBlbHNlIHsKCQkJZXJyID0gaW5mbGF0ZVJlc2V0KGJyLT56c3RyZWFtKTsKCQl9CgkJaWYgKGVyciAhPSBaX09LKSB7CgkJCWVyciA9IFJFRlRBQkxFX1pMSUJfRVJST1I7CgkJCWdvdG8gZG9uZTsKCQl9CgoJCWJyLT56c3RyZWFtLT5uZXh0X2luID0gYmxvY2stPmRhdGEgKyBibG9ja19oZWFkZXJfc2tpcDsKCQlici0+enN0cmVhbS0+YXZhaWxfaW4gPSBzcmNfbGVuOwoJCWJyLT56c3RyZWFtLT5uZXh0X291dCA9IGJyLT51bmNvbXByZXNzZWRfZGF0YSArIGJsb2NrX2hlYWRlcl9za2lwOwoJCWJyLT56c3RyZWFtLT5hdmFpbF9vdXQgPSBkc3RfbGVuOwoKCQkvKgoJCSAqIFdlIGtub3cgYm90aCBpbnB1dCBhcyB3ZWxsIGFzIG91dHB1dCBzaXplLCBhbmQgd2Uga25vdyB0aGF0CgkJICogdGhlIHNpemVzIHNob3VsZCBuZXZlciBiZSBiaWdnZXIgdGhhbiBgdUludF9NQVhgIGJlY2F1c2UKCQkgKiBibG9ja3MgY2FuIGF0IG1vc3QgYmUgMTZNQiBsYXJnZS4gV2UgY2FuIHRodXMgdXNlIGBaX0ZJTklTSGAKCQkgKiBoZXJlIHRvIGluc3RydWN0IHpsaWIgdG8gaW5mbGF0ZSB0aGUgZGF0YSBpbiBvbmUgZ28sIHdoaWNoCgkJICogaXMgbW9yZSBlZmZpY2llbnQgdGhhbiB1c2luZyBgWl9OT19GTFVTSGAuCgkJICovCgkJZXJyID0gaW5mbGF0ZShici0+enN0cmVhbSwgWl9GSU5JU0gpOwoJCWlmIChlcnIgIT0gWl9TVFJFQU1fRU5EKSB7CgkJCWVyciA9IFJFRlRBQkxFX1pMSUJfRVJST1I7CgkJCWdvdG8gZG9uZTsKCQl9CgkJZXJyID0gMDsKCgkJaWYgKGJyLT56c3RyZWFtLT50b3RhbF9vdXQgKyBibG9ja19oZWFkZXJfc2tpcCAhPSBzeikgewoJCQllcnIgPSBSRUZUQUJMRV9GT1JNQVRfRVJST1I7CgkJCWdvdG8gZG9uZTsKCQl9CgoJCS8qIFdlJ3JlIGRvbmUgd2l0aCB0aGUgaW5wdXQgZGF0YS4gKi8KCQlyZWZ0YWJsZV9ibG9ja19kb25lKGJsb2NrKTsKCQlibG9jay0+ZGF0YSA9IGJyLT51bmNvbXByZXNzZWRfZGF0YTsKCQlibG9jay0+bGVuID0gc3o7CgkJZnVsbF9ibG9ja19zaXplID0gc3JjX2xlbiArIGJsb2NrX2hlYWRlcl9za2lwIC0gYnItPnpzdHJlYW0tPmF2YWlsX2luOwoJfSBlbHNlIGlmIChmdWxsX2Jsb2NrX3NpemUgPT0gMCkgewoJCWZ1bGxfYmxvY2tfc2l6ZSA9IHN6OwoJfSBlbHNlIGlmIChzeiA8IGZ1bGxfYmxvY2tfc2l6ZSAmJiBzeiA8IGJsb2NrLT5sZW4gJiYKCQkgICBibG9jay0+ZGF0YVtzel0gIT0gMCkgewoJCS8qIElmIHRoZSBibG9jayBpcyBzbWFsbGVyIHRoYW4gdGhlIGZ1bGwgYmxvY2sgc2l6ZSwgaXQgaXMKCQkgICBwYWRkZWQgKGRhdGEgZm9sbG93ZWQgYnkgJ1wwJykgb3IgdGhlIG5leHQgYmxvY2sgaXMKCQkgICB1bmFsaWduZWQuICovCgkJZnVsbF9ibG9ja19zaXplID0gc3o7Cgl9CgoJcmVzdGFydF9jb3VudCA9IGdldF9iZTE2KGJsb2NrLT5kYXRhICsgc3ogLSAyKTsKCXJlc3RhcnRfc3RhcnQgPSBzeiAtIDIgLSAzICogcmVzdGFydF9jb3VudDsKCXJlc3RhcnRfYnl0ZXMgPSBibG9jay0+ZGF0YSArIHJlc3RhcnRfc3RhcnQ7CgoJLyogdHJhbnNmZXIgb3duZXJzaGlwLiAqLwoJYnItPmJsb2NrID0gKmJsb2NrOwoJYmxvY2stPmRhdGEgPSBOVUxMOwoJYmxvY2stPmxlbiA9IDA7CgoJYnItPmhhc2hfc2l6ZSA9IGhhc2hfc2l6ZTsKCWJyLT5ibG9ja19sZW4gPSByZXN0YXJ0X3N0YXJ0OwoJYnItPmZ1bGxfYmxvY2tfc2l6ZSA9IGZ1bGxfYmxvY2tfc2l6ZTsKCWJyLT5oZWFkZXJfb2ZmID0gaGVhZGVyX29mZjsKCWJyLT5yZXN0YXJ0X2NvdW50ID0gcmVzdGFydF9jb3VudDsKCWJyLT5yZXN0YXJ0X2J5dGVzID0gcmVzdGFydF9ieXRlczsKCmRvbmU6CglyZXR1cm4gZXJyOwp9Cgp2b2lkIGJsb2NrX3JlYWRlcl9yZWxlYXNlKHN0cnVjdCBibG9ja19yZWFkZXIgKmJyKQp7CglpbmZsYXRlRW5kKGJyLT56c3RyZWFtKTsKCXJlZnRhYmxlX2ZyZWUoYnItPnpzdHJlYW0pOwoJcmVmdGFibGVfZnJlZShici0+dW5jb21wcmVzc2VkX2RhdGEpOwoJcmVmdGFibGVfYmxvY2tfZG9uZSgmYnItPmJsb2NrKTsKfQoKdWludDhfdCBibG9ja19yZWFkZXJfdHlwZShjb25zdCBzdHJ1Y3QgYmxvY2tfcmVhZGVyICpyKQp7CglyZXR1cm4gci0+YmxvY2suZGF0YVtyLT5oZWFkZXJfb2ZmXTsKfQoKaW50IGJsb2NrX3JlYWRlcl9maXJzdF9rZXkoY29uc3Qgc3RydWN0IGJsb2NrX3JlYWRlciAqYnIsIHN0cnVjdCBzdHJidWYgKmtleSkKewoJaW50IG9mZiA9IGJyLT5oZWFkZXJfb2ZmICsgNCwgbjsKCXN0cnVjdCBzdHJpbmdfdmlldyBpbiA9IHsKCQkuYnVmID0gYnItPmJsb2NrLmRhdGEgKyBvZmYsCgkJLmxlbiA9IGJyLT5ibG9ja19sZW4gLSBvZmYsCgl9OwoJdWludDhfdCBleHRyYSA9IDA7CgoJc3RyYnVmX3Jlc2V0KGtleSk7CgoJbiA9IHJlZnRhYmxlX2RlY29kZV9rZXkoa2V5LCAmZXh0cmEsIGluKTsKCWlmIChuIDwgMCkKCQlyZXR1cm4gbjsKCWlmICgha2V5LT5sZW4pCgkJcmV0dXJuIFJFRlRBQkxFX0ZPUk1BVF9FUlJPUjsKCglyZXR1cm4gMDsKfQoKc3RhdGljIHVpbnQzMl90IGJsb2NrX3JlYWRlcl9yZXN0YXJ0X29mZnNldChjb25zdCBzdHJ1Y3QgYmxvY2tfcmVhZGVyICpiciwgc2l6ZV90IGlkeCkKewoJcmV0dXJuIGdldF9iZTI0KGJyLT5yZXN0YXJ0X2J5dGVzICsgMyAqIGlkeCk7Cn0KCnZvaWQgYmxvY2tfaXRlcl9zZWVrX3N0YXJ0KHN0cnVjdCBibG9ja19pdGVyICppdCwgY29uc3Qgc3RydWN0IGJsb2NrX3JlYWRlciAqYnIpCnsKCWl0LT5ibG9jayA9IGJyLT5ibG9jay5kYXRhOwoJaXQtPmJsb2NrX2xlbiA9IGJyLT5ibG9ja19sZW47CglpdC0+aGFzaF9zaXplID0gYnItPmhhc2hfc2l6ZTsKCXN0cmJ1Zl9yZXNldCgmaXQtPmxhc3Rfa2V5KTsKCWl0LT5uZXh0X29mZiA9IGJyLT5oZWFkZXJfb2ZmICsgNDsKfQoKc3RydWN0IHJlc3RhcnRfbmVlZGxlX2xlc3NfYXJncyB7CglpbnQgZXJyb3I7CglzdHJ1Y3Qgc3RyYnVmIG5lZWRsZTsKCWNvbnN0IHN0cnVjdCBibG9ja19yZWFkZXIgKnJlYWRlcjsKfTsKCnN0YXRpYyBpbnQgcmVzdGFydF9uZWVkbGVfbGVzcyhzaXplX3QgaWR4LCB2b2lkICpfYXJncykKewoJc3RydWN0IHJlc3RhcnRfbmVlZGxlX2xlc3NfYXJncyAqYXJncyA9IF9hcmdzOwoJdWludDMyX3Qgb2ZmID0gYmxvY2tfcmVhZGVyX3Jlc3RhcnRfb2Zmc2V0KGFyZ3MtPnJlYWRlciwgaWR4KTsKCXN0cnVjdCBzdHJpbmdfdmlldyBpbiA9IHsKCQkuYnVmID0gYXJncy0+cmVhZGVyLT5ibG9jay5kYXRhICsgb2ZmLAoJCS5sZW4gPSBhcmdzLT5yZWFkZXItPmJsb2NrX2xlbiAtIG9mZiwKCX07Cgl1aW50NjRfdCBwcmVmaXhfbGVuLCBzdWZmaXhfbGVuOwoJdWludDhfdCBleHRyYTsKCWludCBuOwoKCS8qCgkgKiBSZWNvcmRzIGF0IHJlc3RhcnQgcG9pbnRzIGFyZSBzdG9yZWQgd2l0aG91dCBwcmVmaXggY29tcHJlc3Npb24sIHNvCgkgKiB0aGVyZSBpcyBubyBuZWVkIHRvIGZ1bGx5IGRlY29kZSB0aGUgcmVjb3JkIGtleSBoZXJlLiBUaGlzIHJlbW92ZXMKCSAqIHRoZSBuZWVkIGZvciBhbGxvY2F0aW5nIG1lbW9yeS4KCSAqLwoJbiA9IHJlZnRhYmxlX2RlY29kZV9rZXlsZW4oaW4sICZwcmVmaXhfbGVuLCAmc3VmZml4X2xlbiwgJmV4dHJhKTsKCWlmIChuIDwgMCB8fCBwcmVmaXhfbGVuKSB7CgkJYXJncy0+ZXJyb3IgPSAxOwoJCXJldHVybiAtMTsKCX0KCglzdHJpbmdfdmlld19jb25zdW1lKCZpbiwgbik7CglpZiAoc3VmZml4X2xlbiA+IGluLmxlbikgewoJCWFyZ3MtPmVycm9yID0gMTsKCQlyZXR1cm4gLTE7Cgl9CgoJbiA9IG1lbWNtcChhcmdzLT5uZWVkbGUuYnVmLCBpbi5idWYsCgkJICAgYXJncy0+bmVlZGxlLmxlbiA8IHN1ZmZpeF9sZW4gPyBhcmdzLT5uZWVkbGUubGVuIDogc3VmZml4X2xlbik7CglpZiAobikKCQlyZXR1cm4gbiA8IDA7CglyZXR1cm4gYXJncy0+bmVlZGxlLmxlbiA8IHN1ZmZpeF9sZW47Cn0KCmludCBibG9ja19pdGVyX25leHQoc3RydWN0IGJsb2NrX2l0ZXIgKml0LCBzdHJ1Y3QgcmVmdGFibGVfcmVjb3JkICpyZWMpCnsKCXN0cnVjdCBzdHJpbmdfdmlldyBpbiA9IHsKCQkuYnVmID0gKHVuc2lnbmVkIGNoYXIgKikgaXQtPmJsb2NrICsgaXQtPm5leHRfb2ZmLAoJCS5sZW4gPSBpdC0+YmxvY2tfbGVuIC0gaXQtPm5leHRfb2ZmLAoJfTsKCXN0cnVjdCBzdHJpbmdfdmlldyBzdGFydCA9IGluOwoJdWludDhfdCBleHRyYSA9IDA7CglpbnQgbiA9IDA7CgoJaWYgKGl0LT5uZXh0X29mZiA+PSBpdC0+YmxvY2tfbGVuKQoJCXJldHVybiAxOwoKCW4gPSByZWZ0YWJsZV9kZWNvZGVfa2V5KCZpdC0+bGFzdF9rZXksICZleHRyYSwgaW4pOwoJaWYgKG4gPCAwKQoJCXJldHVybiAtMTsKCWlmICghaXQtPmxhc3Rfa2V5LmxlbikKCQlyZXR1cm4gUkVGVEFCTEVfRk9STUFUX0VSUk9SOwoKCXN0cmluZ192aWV3X2NvbnN1bWUoJmluLCBuKTsKCW4gPSByZWZ0YWJsZV9yZWNvcmRfZGVjb2RlKHJlYywgaXQtPmxhc3Rfa2V5LCBleHRyYSwgaW4sIGl0LT5oYXNoX3NpemUsCgkJCQkgICAmaXQtPnNjcmF0Y2gpOwoJaWYgKG4gPCAwKQoJCXJldHVybiAtMTsKCXN0cmluZ192aWV3X2NvbnN1bWUoJmluLCBuKTsKCglpdC0+bmV4dF9vZmYgKz0gc3RhcnQubGVuIC0gaW4ubGVuOwoJcmV0dXJuIDA7Cn0KCnZvaWQgYmxvY2tfaXRlcl9yZXNldChzdHJ1Y3QgYmxvY2tfaXRlciAqaXQpCnsKCXN0cmJ1Zl9yZXNldCgmaXQtPmxhc3Rfa2V5KTsKCWl0LT5uZXh0X29mZiA9IDA7CglpdC0+YmxvY2sgPSBOVUxMOwoJaXQtPmJsb2NrX2xlbiA9IDA7CglpdC0+aGFzaF9zaXplID0gMDsKfQoKdm9pZCBibG9ja19pdGVyX2Nsb3NlKHN0cnVjdCBibG9ja19pdGVyICppdCkKewoJc3RyYnVmX3JlbGVhc2UoJml0LT5sYXN0X2tleSk7CglzdHJidWZfcmVsZWFzZSgmaXQtPnNjcmF0Y2gpOwp9CgppbnQgYmxvY2tfaXRlcl9zZWVrX2tleShzdHJ1Y3QgYmxvY2tfaXRlciAqaXQsIGNvbnN0IHN0cnVjdCBibG9ja19yZWFkZXIgKmJyLAoJCQlzdHJ1Y3Qgc3RyYnVmICp3YW50KQp7CglzdHJ1Y3QgcmVzdGFydF9uZWVkbGVfbGVzc19hcmdzIGFyZ3MgPSB7CgkJLm5lZWRsZSA9ICp3YW50LAoJCS5yZWFkZXIgPSBiciwKCX07CglzdHJ1Y3QgcmVmdGFibGVfcmVjb3JkIHJlYzsKCWludCBlcnIgPSAwOwoJc2l6ZV90IGk7CgoJLyoKCSAqIFBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG92ZXIgdGhlIGJsb2NrJ3MgcmVzdGFydCBwb2ludHMsIHdoaWNoCgkgKiBhdm9pZHMgZG9pbmcgYSBsaW5lYXIgc2NhbiBvdmVyIHRoZSB3aG9sZSBibG9jay4gTGlrZSB0aGlzLCB3ZQoJICogaWRlbnRpZnkgdGhlIHNlY3Rpb24gb2YgdGhlIGJsb2NrIHRoYXQgc2hvdWxkIGNvbnRhaW4gb3VyIGtleS4KCSAqCgkgKiBOb3RlIHRoYXQgd2UgZXhwbGljaXRseSBzZWFyY2ggZm9yIHRoZSBmaXJzdCByZXN0YXJ0IHBvaW50IF9ncmVhdGVyXwoJICogdGhhbiB0aGUgc291Z2h0LWFmdGVyIHJlY29yZCwgbm90IF9ncmVhdGVyIG9yIGVxdWFsXyB0byBpdC4gSW4gY2FzZQoJICogdGhlIHNvdWdodC1hZnRlciByZWNvcmQgaXMgbG9jYXRlZCBkaXJlY3RseSBhdCB0aGUgcmVzdGFydCBwb2ludCB3ZQoJICogd291bGQgb3RoZXJ3aXNlIHN0YXJ0IGRvaW5nIHRoZSBsaW5lYXIgc2VhcmNoIGF0IHRoZSBwcmVjZWRpbmcKCSAqIHJlc3RhcnQgcG9pbnQuIFdoaWxlIHRoYXQgd29ya3MgYWxyaWdodCwgd2Ugd291bGQgZW5kIHVwIHNjYW5uaW5nCgkgKiB0b28gbWFueSByZWNvcmQuCgkgKi8KCWkgPSBiaW5zZWFyY2goYnItPnJlc3RhcnRfY291bnQsICZyZXN0YXJ0X25lZWRsZV9sZXNzLCAmYXJncyk7CglpZiAoYXJncy5lcnJvcikgewoJCWVyciA9IFJFRlRBQkxFX0ZPUk1BVF9FUlJPUjsKCQlnb3RvIGRvbmU7Cgl9CgoJLyoKCSAqIE5vdyB0aGVyZSBhcmUgbXVsdGlwbGUgY2FzZXM6CgkgKgoJICogICAtIGBpID09IDBgOiBUaGUgd2FudGVkIHJlY29yZCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlY29yZCBmb3VuZCBhdAoJICogICAgIHRoZSBmaXJzdCByZXN0YXJ0IHBvaW50LiBBcyB0aGUgZmlyc3QgcmVzdGFydCBwb2ludCBpcyB0aGUgZmlyc3QKCSAqICAgICByZWNvcmQgaW4gdGhlIGJsb2NrLCBvdXIgd2FudGVkIHJlY29yZCBjYW5ub3QgYmUgbG9jYXRlZCBpbiB0aGlzCgkgKiAgICAgYmxvY2sgYXQgYWxsLiBXZSBzdGlsbCBuZWVkIHRvIHBvc2l0aW9uIHRoZSBpdGVyYXRvciBzbyB0aGF0IHRoZQoJICogICAgIG5leHQgY2FsbCB0byBgYmxvY2tfaXRlcl9uZXh0KClgIHdpbGwgeWllbGQgYW4gZW5kLW9mLWl0ZXJhdG9yCgkgKiAgICAgc2lnbmFsLgoJICoKCSAqICAgLSBgaSA9PSByZXN0YXJ0X2NvdW50YDogVGhlIHdhbnRlZCByZWNvcmQgd2FzIG5vdCBmb3VuZCBhdCBhbnkgb2YKCSAqICAgICB0aGUgcmVzdGFydCBwb2ludHMuIEFzIHRoZXJlIGlzIG5vIHJlc3RhcnQgcG9pbnQgYXQgdGhlIGVuZCBvZgoJICogICAgIHRoZSBzZWN0aW9uIHRoZSByZWNvcmQgbWF5IHRodXMgYmUgY29udGFpbmVkIGluIHRoZSBsYXN0IGJsb2NrLgoJICoKCSAqICAgLSBgaSA+IDBgOiBUaGUgd2FudGVkIHJlY29yZCBtdXN0IGJlIGNvbnRhaW5lZCBpbiB0aGUgc2VjdGlvbgoJICogICAgIGJlZm9yZSB0aGUgZm91bmQgcmVzdGFydCBwb2ludC4gV2UgdGh1cyBkbyBhIGxpbmVhciBzZWFyY2gKCSAqICAgICBzdGFydGluZyBmcm9tIHRoZSBwcmVjZWRpbmcgcmVzdGFydCBwb2ludC4KCSAqLwoJaWYgKGkgPiAwKQoJCWl0LT5uZXh0X29mZiA9IGJsb2NrX3JlYWRlcl9yZXN0YXJ0X29mZnNldChiciwgaSAtIDEpOwoJZWxzZQoJCWl0LT5uZXh0X29mZiA9IGJyLT5oZWFkZXJfb2ZmICsgNDsKCWl0LT5ibG9jayA9IGJyLT5ibG9jay5kYXRhOwoJaXQtPmJsb2NrX2xlbiA9IGJyLT5ibG9ja19sZW47CglpdC0+aGFzaF9zaXplID0gYnItPmhhc2hfc2l6ZTsKCglyZWZ0YWJsZV9yZWNvcmRfaW5pdCgmcmVjLCBibG9ja19yZWFkZXJfdHlwZShicikpOwoKCS8qCgkgKiBXZSdyZSBsb29raW5nIGZvciB0aGUgbGFzdCBlbnRyeSBsZXNzIHRoYW4gdGhlIHdhbnRlZCBrZXkgc28gdGhhdAoJICogdGhlIG5leHQgY2FsbCB0byBgYmxvY2tfcmVhZGVyX25leHQoKWAgd291bGQgeWllbGQgdGhlIHdhbnRlZAoJICogcmVjb3JkLiBXZSB0aHVzIGRvbid0IHdhbnQgdG8gcG9zaXRpb24gb3VyIHJlYWRlciBhdCB0aGUgc291Z2h0CgkgKiBhZnRlciByZWNvcmQsIGJ1dCBvbmUgYmVmb3JlLiBUbyBkbyBzbywgd2UgaGF2ZSB0byBnbyBvbmUgZW50cnkgdG9vCgkgKiBmYXIgYW5kIHRoZW4gYmFjayB1cC4KCSAqLwoJd2hpbGUgKDEpIHsKCQlzaXplX3QgcHJldl9vZmYgPSBpdC0+bmV4dF9vZmY7CgoJCWVyciA9IGJsb2NrX2l0ZXJfbmV4dChpdCwgJnJlYyk7CgkJaWYgKGVyciA8IDApCgkJCWdvdG8gZG9uZTsKCQlpZiAoZXJyID4gMCkgewoJCQlpdC0+bmV4dF9vZmYgPSBwcmV2X29mZjsKCQkJZXJyID0gMDsKCQkJZ290byBkb25lOwoJCX0KCgkJLyoKCQkgKiBDaGVjayB3aGV0aGVyIHRoZSBjdXJyZW50IGtleSBpcyBncmVhdGVyIG9yIGVxdWFsIHRvIHRoZQoJCSAqIHNvdWdodC1hZnRlciBrZXkuIEluIGNhc2UgaXQgaXMgZ3JlYXRlciB3ZSBrbm93IHRoYXQgdGhlCgkJICogcmVjb3JkIGRvZXMgbm90IGV4aXN0IGluIHRoZSBibG9jayBhbmQgY2FuIHRodXMgYWJvcnQgZWFybHkuCgkJICogSW4gY2FzZSBpdCBpcyBlcXVhbCB0byB0aGUgc291Z2h0LWFmdGVyIGtleSB3ZSBoYXZlIGZvdW5kCgkJICogdGhlIGRlc2lyZWQgcmVjb3JkLgoJCSAqCgkJICogTm90ZSB0aGF0IHdlIHN0b3JlIHRoZSBuZXh0IHJlY29yZCdzIGtleSByZWNvcmQgZGlyZWN0bHkgaW4KCQkgKiBgbGFzdF9rZXlgIHdpdGhvdXQgcmVzdG9yaW5nIHRoZSBrZXkgb2YgdGhlIHByZWNlZGluZyByZWNvcmQKCQkgKiBpbiBjYXNlIHdlIG5lZWQgdG8gZ28gb25lIHJlY29yZCBiYWNrLiBUaGlzIGlzIHNhZmUgdG8gZG8gYXMKCQkgKiBgYmxvY2tfaXRlcl9uZXh0KClgIHdvdWxkIHJldHVybiB0aGUgcmVmIHdob3NlIGtleSBpcyBlcXVhbAoJCSAqIHRvIGBsYXN0X2tleWAgbm93LCBhbmQgbmF0dXJhbGx5IGFsbCBrZXlzIHNoYXJlIGEgcHJlZml4CgkJICogd2l0aCB0aGVtc2VsdmVzLgoJCSAqLwoJCXJlZnRhYmxlX3JlY29yZF9rZXkoJnJlYywgJml0LT5sYXN0X2tleSk7CgkJaWYgKHN0cmJ1Zl9jbXAoJml0LT5sYXN0X2tleSwgd2FudCkgPj0gMCkgewoJCQlpdC0+bmV4dF9vZmYgPSBwcmV2X29mZjsKCQkJZ290byBkb25lOwoJCX0KCX0KCmRvbmU6CglyZWZ0YWJsZV9yZWNvcmRfcmVsZWFzZSgmcmVjKTsKCXJldHVybiBlcnI7Cn0KCnZvaWQgYmxvY2tfd3JpdGVyX3JlbGVhc2Uoc3RydWN0IGJsb2NrX3dyaXRlciAqYncpCnsKCWRlZmxhdGVFbmQoYnctPnpzdHJlYW0pOwoJRlJFRV9BTkRfTlVMTChidy0+enN0cmVhbSk7CglGUkVFX0FORF9OVUxMKGJ3LT5yZXN0YXJ0cyk7CglGUkVFX0FORF9OVUxMKGJ3LT5jb21wcmVzc2VkKTsKCXN0cmJ1Zl9yZWxlYXNlKCZidy0+bGFzdF9rZXkpOwoJLyogdGhlIGJsb2NrIGlzIG5vdCBvd25lZC4gKi8KfQoKdm9pZCByZWZ0YWJsZV9ibG9ja19kb25lKHN0cnVjdCByZWZ0YWJsZV9ibG9jayAqYmxvY2twKQp7CglzdHJ1Y3QgcmVmdGFibGVfYmxvY2tfc291cmNlIHNvdXJjZSA9IGJsb2NrcC0+c291cmNlOwoJaWYgKGJsb2NrcCAmJiBzb3VyY2Uub3BzKQoJCXNvdXJjZS5vcHMtPnJldHVybl9ibG9jayhzb3VyY2UuYXJnLCBibG9ja3ApOwoJYmxvY2twLT5kYXRhID0gTlVMTDsKCWJsb2NrcC0+bGVuID0gMDsKCWJsb2NrcC0+c291cmNlLm9wcyA9IE5VTEw7CglibG9ja3AtPnNvdXJjZS5hcmcgPSBOVUxMOwp9Cg==",
    "text": "/*\nCopyright 2020 Google LLC\n\nUse of this source code is governed by a BSD-style\nlicense that can be found in the LICENSE file or at\nhttps://developers.google.com/open-source/licenses/bsd\n*/\n\n#include \"block.h\"\n\n#include \"blocksource.h\"\n#include \"constants.h\"\n#include \"record.h\"\n#include \"reftable-error.h\"\n#include \"system.h\"\n#include <zlib.h>\n\nint header_size(int version)\n{\n\tswitch (version) {\n\tcase 1:\n\t\treturn 24;\n\tcase 2:\n\t\treturn 28;\n\t}\n\tabort();\n}\n\nint footer_size(int version)\n{\n\tswitch (version) {\n\tcase 1:\n\t\treturn 68;\n\tcase 2:\n\t\treturn 72;\n\t}\n\tabort();\n}\n\nstatic int block_writer_register_restart(struct block_writer *w, int n,\n\t\t\t\t\t int is_restart, struct strbuf *key)\n{\n\tint rlen = w->restart_len;\n\tif (rlen >= MAX_RESTARTS) {\n\t\tis_restart = 0;\n\t}\n\n\tif (is_restart) {\n\t\trlen++;\n\t}\n\tif (2 + 3 * rlen + n > w->block_size - w->next)\n\t\treturn -1;\n\tif (is_restart) {\n\t\tREFTABLE_ALLOC_GROW(w->restarts, w->restart_len + 1, w->restart_cap);\n\t\tw->restarts[w->restart_len++] = w->next;\n\t}\n\n\tw->next += n;\n\n\tstrbuf_reset(&w->last_key);\n\tstrbuf_addbuf(&w->last_key, key);\n\tw->entries++;\n\treturn 0;\n}\n\nvoid block_writer_init(struct block_writer *bw, uint8_t typ, uint8_t *buf,\n\t\t       uint32_t block_size, uint32_t header_off, int hash_size)\n{\n\tbw->buf = buf;\n\tbw->hash_size = hash_size;\n\tbw->block_size = block_size;\n\tbw->header_off = header_off;\n\tbw->buf[header_off] = typ;\n\tbw->next = header_off + 4;\n\tbw->restart_interval = 16;\n\tbw->entries = 0;\n\tbw->restart_len = 0;\n\tbw->last_key.len = 0;\n\tif (!bw->zstream) {\n\t\tREFTABLE_CALLOC_ARRAY(bw->zstream, 1);\n\t\tdeflateInit(bw->zstream, 9);\n\t}\n}\n\nuint8_t block_writer_type(struct block_writer *bw)\n{\n\treturn bw->buf[bw->header_off];\n}\n\n/* Adds the reftable_record to the block. Returns -1 if it does not fit, 0 on\n   success. Returns REFTABLE_API_ERROR if attempting to write a record with\n   empty key. */\nint block_writer_add(struct block_writer *w, struct reftable_record *rec)\n{\n\tstruct strbuf empty = STRBUF_INIT;\n\tstruct strbuf last =\n\t\tw->entries % w->restart_interval == 0 ? empty : w->last_key;\n\tstruct string_view out = {\n\t\t.buf = w->buf + w->next,\n\t\t.len = w->block_size - w->next,\n\t};\n\n\tstruct string_view start = out;\n\n\tint is_restart = 0;\n\tstruct strbuf key = STRBUF_INIT;\n\tint n = 0;\n\tint err = -1;\n\n\treftable_record_key(rec, &key);\n\tif (!key.len) {\n\t\terr = REFTABLE_API_ERROR;\n\t\tgoto done;\n\t}\n\n\tn = reftable_encode_key(&is_restart, out, last, key,\n\t\t\t\treftable_record_val_type(rec));\n\tif (n < 0)\n\t\tgoto done;\n\tstring_view_consume(&out, n);\n\n\tn = reftable_record_encode(rec, out, w->hash_size);\n\tif (n < 0)\n\t\tgoto done;\n\tstring_view_consume(&out, n);\n\n\terr = block_writer_register_restart(w, start.len - out.len, is_restart,\n\t\t\t\t\t    &key);\ndone:\n\tstrbuf_release(&key);\n\treturn err;\n}\n\nint block_writer_finish(struct block_writer *w)\n{\n\tint i;\n\tfor (i = 0; i < w->restart_len; i++) {\n\t\tput_be24(w->buf + w->next, w->restarts[i]);\n\t\tw->next += 3;\n\t}\n\n\tput_be16(w->buf + w->next, w->restart_len);\n\tw->next += 2;\n\tput_be24(w->buf + 1 + w->header_off, w->next);\n\n\t/*\n\t * Log records are stored zlib-compressed. Note that the compression\n\t * also spans over the restart points we have just written.\n\t */\n\tif (block_writer_type(w) == BLOCK_TYPE_LOG) {\n\t\tint block_header_skip = 4 + w->header_off;\n\t\tuLongf src_len = w->next - block_header_skip, compressed_len;\n\t\tint ret;\n\n\t\tret = deflateReset(w->zstream);\n\t\tif (ret != Z_OK)\n\t\t\treturn REFTABLE_ZLIB_ERROR;\n\n\t\t/*\n\t\t * Precompute the upper bound of how many bytes the compressed\n\t\t * data may end up with. Combined with `Z_FINISH`, `deflate()`\n\t\t * is guaranteed to return `Z_STREAM_END`.\n\t\t */\n\t\tcompressed_len = deflateBound(w->zstream, src_len);\n\t\tREFTABLE_ALLOC_GROW(w->compressed, compressed_len, w->compressed_cap);\n\n\t\tw->zstream->next_out = w->compressed;\n\t\tw->zstream->avail_out = compressed_len;\n\t\tw->zstream->next_in = w->buf + block_header_skip;\n\t\tw->zstream->avail_in = src_len;\n\n\t\t/*\n\t\t * We want to perform all decompression in a single step, which\n\t\t * is why we can pass Z_FINISH here. As we have precomputed the\n\t\t * deflated buffer's size via `deflateBound()` this function is\n\t\t * guaranteed to succeed according to the zlib documentation.\n\t\t */\n\t\tret = deflate(w->zstream, Z_FINISH);\n\t\tif (ret != Z_STREAM_END)\n\t\t\treturn REFTABLE_ZLIB_ERROR;\n\n\t\t/*\n\t\t * Overwrite the uncompressed data we have already written and\n\t\t * adjust the `next` pointer to point right after the\n\t\t * compressed data.\n\t\t */\n\t\tmemcpy(w->buf + block_header_skip, w->compressed,\n\t\t       w->zstream->total_out);\n\t\tw->next = w->zstream->total_out + block_header_skip;\n\t}\n\n\treturn w->next;\n}\n\nint block_reader_init(struct block_reader *br, struct reftable_block *block,\n\t\t      uint32_t header_off, uint32_t table_block_size,\n\t\t      int hash_size)\n{\n\tuint32_t full_block_size = table_block_size;\n\tuint8_t typ = block->data[header_off];\n\tuint32_t sz = get_be24(block->data + header_off + 1);\n\tint err = 0;\n\tuint16_t restart_count = 0;\n\tuint32_t restart_start = 0;\n\tuint8_t *restart_bytes = NULL;\n\n\treftable_block_done(&br->block);\n\n\tif (!reftable_is_block_type(typ)) {\n\t\terr =  REFTABLE_FORMAT_ERROR;\n\t\tgoto done;\n\t}\n\n\tif (typ == BLOCK_TYPE_LOG) {\n\t\tuint32_t block_header_skip = 4 + header_off;\n\t\tuLong dst_len = sz - block_header_skip;\n\t\tuLong src_len = block->len - block_header_skip;\n\n\t\t/* Log blocks specify the *uncompressed* size in their header. */\n\t\tREFTABLE_ALLOC_GROW(br->uncompressed_data, sz,\n\t\t\t\t    br->uncompressed_cap);\n\n\t\t/* Copy over the block header verbatim. It's not compressed. */\n\t\tmemcpy(br->uncompressed_data, block->data, block_header_skip);\n\n\t\tif (!br->zstream) {\n\t\t\tREFTABLE_CALLOC_ARRAY(br->zstream, 1);\n\t\t\terr = inflateInit(br->zstream);\n\t\t} else {\n\t\t\terr = inflateReset(br->zstream);\n\t\t}\n\t\tif (err != Z_OK) {\n\t\t\terr = REFTABLE_ZLIB_ERROR;\n\t\t\tgoto done;\n\t\t}\n\n\t\tbr->zstream->next_in = block->data + block_header_skip;\n\t\tbr->zstream->avail_in = src_len;\n\t\tbr->zstream->next_out = br->uncompressed_data + block_header_skip;\n\t\tbr->zstream->avail_out = dst_len;\n\n\t\t/*\n\t\t * We know both input as well as output size, and we know that\n\t\t * the sizes should never be bigger than `uInt_MAX` because\n\t\t * blocks can at most be 16MB large. We can thus use `Z_FINISH`\n\t\t * here to instruct zlib to inflate the data in one go, which\n\t\t * is more efficient than using `Z_NO_FLUSH`.\n\t\t */\n\t\terr = inflate(br->zstream, Z_FINISH);\n\t\tif (err != Z_STREAM_END) {\n\t\t\terr = REFTABLE_ZLIB_ERROR;\n\t\t\tgoto done;\n\t\t}\n\t\terr = 0;\n\n\t\tif (br->zstream->total_out + block_header_skip != sz) {\n\t\t\terr = REFTABLE_FORMAT_ERROR;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* We're done with the input data. */\n\t\treftable_block_done(block);\n\t\tblock->data = br->uncompressed_data;\n\t\tblock->len = sz;\n\t\tfull_block_size = src_len + block_header_skip - br->zstream->avail_in;\n\t} else if (full_block_size == 0) {\n\t\tfull_block_size = sz;\n\t} else if (sz < full_block_size && sz < block->len &&\n\t\t   block->data[sz] != 0) {\n\t\t/* If the block is smaller than the full block size, it is\n\t\t   padded (data followed by '\\0') or the next block is\n\t\t   unaligned. */\n\t\tfull_block_size = sz;\n\t}\n\n\trestart_count = get_be16(block->data + sz - 2);\n\trestart_start = sz - 2 - 3 * restart_count;\n\trestart_bytes = block->data + restart_start;\n\n\t/* transfer ownership. */\n\tbr->block = *block;\n\tblock->data = NULL;\n\tblock->len = 0;\n\n\tbr->hash_size = hash_size;\n\tbr->block_len = restart_start;\n\tbr->full_block_size = full_block_size;\n\tbr->header_off = header_off;\n\tbr->restart_count = restart_count;\n\tbr->restart_bytes = restart_bytes;\n\ndone:\n\treturn err;\n}\n\nvoid block_reader_release(struct block_reader *br)\n{\n\tinflateEnd(br->zstream);\n\treftable_free(br->zstream);\n\treftable_free(br->uncompressed_data);\n\treftable_block_done(&br->block);\n}\n\nuint8_t block_reader_type(const struct block_reader *r)\n{\n\treturn r->block.data[r->header_off];\n}\n\nint block_reader_first_key(const struct block_reader *br, struct strbuf *key)\n{\n\tint off = br->header_off + 4, n;\n\tstruct string_view in = {\n\t\t.buf = br->block.data + off,\n\t\t.len = br->block_len - off,\n\t};\n\tuint8_t extra = 0;\n\n\tstrbuf_reset(key);\n\n\tn = reftable_decode_key(key, &extra, in);\n\tif (n < 0)\n\t\treturn n;\n\tif (!key->len)\n\t\treturn REFTABLE_FORMAT_ERROR;\n\n\treturn 0;\n}\n\nstatic uint32_t block_reader_restart_offset(const struct block_reader *br, size_t idx)\n{\n\treturn get_be24(br->restart_bytes + 3 * idx);\n}\n\nvoid block_iter_seek_start(struct block_iter *it, const struct block_reader *br)\n{\n\tit->block = br->block.data;\n\tit->block_len = br->block_len;\n\tit->hash_size = br->hash_size;\n\tstrbuf_reset(&it->last_key);\n\tit->next_off = br->header_off + 4;\n}\n\nstruct restart_needle_less_args {\n\tint error;\n\tstruct strbuf needle;\n\tconst struct block_reader *reader;\n};\n\nstatic int restart_needle_less(size_t idx, void *_args)\n{\n\tstruct restart_needle_less_args *args = _args;\n\tuint32_t off = block_reader_restart_offset(args->reader, idx);\n\tstruct string_view in = {\n\t\t.buf = args->reader->block.data + off,\n\t\t.len = args->reader->block_len - off,\n\t};\n\tuint64_t prefix_len, suffix_len;\n\tuint8_t extra;\n\tint n;\n\n\t/*\n\t * Records at restart points are stored without prefix compression, so\n\t * there is no need to fully decode the record key here. This removes\n\t * the need for allocating memory.\n\t */\n\tn = reftable_decode_keylen(in, &prefix_len, &suffix_len, &extra);\n\tif (n < 0 || prefix_len) {\n\t\targs->error = 1;\n\t\treturn -1;\n\t}\n\n\tstring_view_consume(&in, n);\n\tif (suffix_len > in.len) {\n\t\targs->error = 1;\n\t\treturn -1;\n\t}\n\n\tn = memcmp(args->needle.buf, in.buf,\n\t\t   args->needle.len < suffix_len ? args->needle.len : suffix_len);\n\tif (n)\n\t\treturn n < 0;\n\treturn args->needle.len < suffix_len;\n}\n\nint block_iter_next(struct block_iter *it, struct reftable_record *rec)\n{\n\tstruct string_view in = {\n\t\t.buf = (unsigned char *) it->block + it->next_off,\n\t\t.len = it->block_len - it->next_off,\n\t};\n\tstruct string_view start = in;\n\tuint8_t extra = 0;\n\tint n = 0;\n\n\tif (it->next_off >= it->block_len)\n\t\treturn 1;\n\n\tn = reftable_decode_key(&it->last_key, &extra, in);\n\tif (n < 0)\n\t\treturn -1;\n\tif (!it->last_key.len)\n\t\treturn REFTABLE_FORMAT_ERROR;\n\n\tstring_view_consume(&in, n);\n\tn = reftable_record_decode(rec, it->last_key, extra, in, it->hash_size,\n\t\t\t\t   &it->scratch);\n\tif (n < 0)\n\t\treturn -1;\n\tstring_view_consume(&in, n);\n\n\tit->next_off += start.len - in.len;\n\treturn 0;\n}\n\nvoid block_iter_reset(struct block_iter *it)\n{\n\tstrbuf_reset(&it->last_key);\n\tit->next_off = 0;\n\tit->block = NULL;\n\tit->block_len = 0;\n\tit->hash_size = 0;\n}\n\nvoid block_iter_close(struct block_iter *it)\n{\n\tstrbuf_release(&it->last_key);\n\tstrbuf_release(&it->scratch);\n}\n\nint block_iter_seek_key(struct block_iter *it, const struct block_reader *br,\n\t\t\tstruct strbuf *want)\n{\n\tstruct restart_needle_less_args args = {\n\t\t.needle = *want,\n\t\t.reader = br,\n\t};\n\tstruct reftable_record rec;\n\tint err = 0;\n\tsize_t i;\n\n\t/*\n\t * Perform a binary search over the block's restart points, which\n\t * avoids doing a linear scan over the whole block. Like this, we\n\t * identify the section of the block that should contain our key.\n\t *\n\t * Note that we explicitly search for the first restart point _greater_\n\t * than the sought-after record, not _greater or equal_ to it. In case\n\t * the sought-after record is located directly at the restart point we\n\t * would otherwise start doing the linear search at the preceding\n\t * restart point. While that works alright, we would end up scanning\n\t * too many record.\n\t */\n\ti = binsearch(br->restart_count, &restart_needle_less, &args);\n\tif (args.error) {\n\t\terr = REFTABLE_FORMAT_ERROR;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Now there are multiple cases:\n\t *\n\t *   - `i == 0`: The wanted record is smaller than the record found at\n\t *     the first restart point. As the first restart point is the first\n\t *     record in the block, our wanted record cannot be located in this\n\t *     block at all. We still need to position the iterator so that the\n\t *     next call to `block_iter_next()` will yield an end-of-iterator\n\t *     signal.\n\t *\n\t *   - `i == restart_count`: The wanted record was not found at any of\n\t *     the restart points. As there is no restart point at the end of\n\t *     the section the record may thus be contained in the last block.\n\t *\n\t *   - `i > 0`: The wanted record must be contained in the section\n\t *     before the found restart point. We thus do a linear search\n\t *     starting from the preceding restart point.\n\t */\n\tif (i > 0)\n\t\tit->next_off = block_reader_restart_offset(br, i - 1);\n\telse\n\t\tit->next_off = br->header_off + 4;\n\tit->block = br->block.data;\n\tit->block_len = br->block_len;\n\tit->hash_size = br->hash_size;\n\n\treftable_record_init(&rec, block_reader_type(br));\n\n\t/*\n\t * We're looking for the last entry less than the wanted key so that\n\t * the next call to `block_reader_next()` would yield the wanted\n\t * record. We thus don't want to position our reader at the sought\n\t * after record, but one before. To do so, we have to go one entry too\n\t * far and then back up.\n\t */\n\twhile (1) {\n\t\tsize_t prev_off = it->next_off;\n\n\t\terr = block_iter_next(it, &rec);\n\t\tif (err < 0)\n\t\t\tgoto done;\n\t\tif (err > 0) {\n\t\t\tit->next_off = prev_off;\n\t\t\terr = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/*\n\t\t * Check whether the current key is greater or equal to the\n\t\t * sought-after key. In case it is greater we know that the\n\t\t * record does not exist in the block and can thus abort early.\n\t\t * In case it is equal to the sought-after key we have found\n\t\t * the desired record.\n\t\t *\n\t\t * Note that we store the next record's key record directly in\n\t\t * `last_key` without restoring the key of the preceding record\n\t\t * in case we need to go one record back. This is safe to do as\n\t\t * `block_iter_next()` would return the ref whose key is equal\n\t\t * to `last_key` now, and naturally all keys share a prefix\n\t\t * with themselves.\n\t\t */\n\t\treftable_record_key(&rec, &it->last_key);\n\t\tif (strbuf_cmp(&it->last_key, want) >= 0) {\n\t\t\tit->next_off = prev_off;\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\treftable_record_release(&rec);\n\treturn err;\n}\n\nvoid block_writer_release(struct block_writer *bw)\n{\n\tdeflateEnd(bw->zstream);\n\tFREE_AND_NULL(bw->zstream);\n\tFREE_AND_NULL(bw->restarts);\n\tFREE_AND_NULL(bw->compressed);\n\tstrbuf_release(&bw->last_key);\n\t/* the block is not owned. */\n}\n\nvoid reftable_block_done(struct reftable_block *blockp)\n{\n\tstruct reftable_block_source source = blockp->source;\n\tif (blockp && source.ops)\n\t\tsource.ops->return_block(source.arg, blockp);\n\tblockp->data = NULL;\n\tblockp->len = 0;\n\tblockp->source.ops = NULL;\n\tblockp->source.arg = NULL;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00030eee065234dd6692a175fd2072fc3a1c1795",
  "sha1_ok": false,
  "size": 14440
}
