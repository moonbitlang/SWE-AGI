{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IG1lcmdlIgogKgogKiBDb3B5cmlnaHQgKGMpIDIwMDggTWlrbG9zIFZham5hIDx2bWlrbG9zQGZydWdhbHdhcmUub3JnPgogKgogKiBCYXNlZCBvbiBnaXQtbWVyZ2Uuc2ggYnkgSnVuaW8gQyBIYW1hbm8uCiAqLwoKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJkaWZmY29yZS5oIgojaW5jbHVkZSAicmV2aXNpb24uaCIKI2luY2x1ZGUgInVucGFjay10cmVlcy5oIgojaW5jbHVkZSAiY2FjaGUtdHJlZS5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJ1dGY4LmgiCiNpbmNsdWRlICJsb2ctdHJlZS5oIgojaW5jbHVkZSAiY29sb3IuaCIKI2luY2x1ZGUgInJlcmVyZS5oIgojaW5jbHVkZSAiaGVscC5oIgojaW5jbHVkZSAibWVyZ2UtcmVjdXJzaXZlLmgiCiNpbmNsdWRlICJyZXNvbHZlLXVuZG8uaCIKI2luY2x1ZGUgInJlbW90ZS5oIgoKI2RlZmluZSBERUZBVUxUX1RXT0hFQUQgKDE8PDApCiNkZWZpbmUgREVGQVVMVF9PQ1RPUFVTICgxPDwxKQojZGVmaW5lIE5PX0ZBU1RfRk9SV0FSRCAoMTw8MikKI2RlZmluZSBOT19UUklWSUFMICAgICAgKDE8PDMpCgpzdHJ1Y3Qgc3RyYXRlZ3kgewoJY29uc3QgY2hhciAqbmFtZTsKCXVuc2lnbmVkIGF0dHI7Cn07CgpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGJ1aWx0aW5fbWVyZ2VfdXNhZ2VbXSA9IHsKCSJnaXQgbWVyZ2UgW29wdGlvbnNdIFs8Y29tbWl0Pi4uLl0iLAoJImdpdCBtZXJnZSBbb3B0aW9uc10gPG1zZz4gSEVBRCA8Y29tbWl0PiIsCgkiZ2l0IG1lcmdlIC0tYWJvcnQiLAoJTlVMTAp9OwoKc3RhdGljIGludCBzaG93X2RpZmZzdGF0ID0gMSwgc2hvcnRsb2dfbGVuLCBzcXVhc2g7CnN0YXRpYyBpbnQgb3B0aW9uX2NvbW1pdCA9IDEsIGFsbG93X2Zhc3RfZm9yd2FyZCA9IDE7CnN0YXRpYyBpbnQgZmFzdF9mb3J3YXJkX29ubHksIG9wdGlvbl9lZGl0ID0gLTE7CnN0YXRpYyBpbnQgYWxsb3dfdHJpdmlhbCA9IDEsIGhhdmVfbWVzc2FnZTsKc3RhdGljIHN0cnVjdCBzdHJidWYgbWVyZ2VfbXNnOwpzdGF0aWMgc3RydWN0IGNvbW1pdF9saXN0ICpyZW1vdGVoZWFkczsKc3RhdGljIHN0cnVjdCBzdHJhdGVneSAqKnVzZV9zdHJhdGVnaWVzOwpzdGF0aWMgc2l6ZV90IHVzZV9zdHJhdGVnaWVzX25yLCB1c2Vfc3RyYXRlZ2llc19hbGxvYzsKc3RhdGljIGNvbnN0IGNoYXIgKip4b3B0czsKc3RhdGljIHNpemVfdCB4b3B0c19uciwgeG9wdHNfYWxsb2M7CnN0YXRpYyBjb25zdCBjaGFyICpicmFuY2g7CnN0YXRpYyBjaGFyICpicmFuY2hfbWVyZ2VvcHRpb25zOwpzdGF0aWMgaW50IG9wdGlvbl9yZW5vcm1hbGl6ZTsKc3RhdGljIGludCB2ZXJib3NpdHk7CnN0YXRpYyBpbnQgYWxsb3dfcmVyZXJlX2F1dG87CnN0YXRpYyBpbnQgYWJvcnRfY3VycmVudF9tZXJnZTsKc3RhdGljIGludCBzaG93X3Byb2dyZXNzID0gLTE7CnN0YXRpYyBpbnQgZGVmYXVsdF90b191cHN0cmVhbTsKCnN0YXRpYyBzdHJ1Y3Qgc3RyYXRlZ3kgYWxsX3N0cmF0ZWd5W10gPSB7Cgl7ICJyZWN1cnNpdmUiLCAgREVGQVVMVF9UV09IRUFEIHwgTk9fVFJJVklBTCB9LAoJeyAib2N0b3B1cyIsICAgIERFRkFVTFRfT0NUT1BVUyB9LAoJeyAicmVzb2x2ZSIsICAgIDAgfSwKCXsgIm91cnMiLCAgICAgICBOT19GQVNUX0ZPUldBUkQgfCBOT19UUklWSUFMIH0sCgl7ICJzdWJ0cmVlIiwgICAgTk9fRkFTVF9GT1JXQVJEIHwgTk9fVFJJVklBTCB9LAp9OwoKc3RhdGljIGNvbnN0IGNoYXIgKnB1bGxfdHdvaGVhZCwgKnB1bGxfb2N0b3B1czsKCnN0YXRpYyBpbnQgb3B0aW9uX3BhcnNlX21lc3NhZ2UoY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LAoJCQkJY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCXN0cnVjdCBzdHJidWYgKmJ1ZiA9IG9wdC0+dmFsdWU7CgoJaWYgKHVuc2V0KQoJCXN0cmJ1Zl9zZXRsZW4oYnVmLCAwKTsKCWVsc2UgaWYgKGFyZykgewoJCXN0cmJ1Zl9hZGRmKGJ1ZiwgIiVzJXMiLCBidWYtPmxlbiA/ICJcblxuIiA6ICIiLCBhcmcpOwoJCWhhdmVfbWVzc2FnZSA9IDE7Cgl9IGVsc2UKCQlyZXR1cm4gZXJyb3IoXygic3dpdGNoIGBtJyByZXF1aXJlcyBhIHZhbHVlIikpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBzdHJ1Y3Qgc3RyYXRlZ3kgKmdldF9zdHJhdGVneShjb25zdCBjaGFyICpuYW1lKQp7CglpbnQgaTsKCXN0cnVjdCBzdHJhdGVneSAqcmV0OwoJc3RhdGljIHN0cnVjdCBjbWRuYW1lcyBtYWluX2NtZHMsIG90aGVyX2NtZHM7CglzdGF0aWMgaW50IGxvYWRlZDsKCglpZiAoIW5hbWUpCgkJcmV0dXJuIE5VTEw7CgoJZm9yIChpID0gMDsgaSA8IEFSUkFZX1NJWkUoYWxsX3N0cmF0ZWd5KTsgaSsrKQoJCWlmICghc3RyY21wKG5hbWUsIGFsbF9zdHJhdGVneVtpXS5uYW1lKSkKCQkJcmV0dXJuICZhbGxfc3RyYXRlZ3lbaV07CgoJaWYgKCFsb2FkZWQpIHsKCQlzdHJ1Y3QgY21kbmFtZXMgbm90X3N0cmF0ZWdpZXM7CgkJbG9hZGVkID0gMTsKCgkJbWVtc2V0KCZub3Rfc3RyYXRlZ2llcywgMCwgc2l6ZW9mKHN0cnVjdCBjbWRuYW1lcykpOwoJCWxvYWRfY29tbWFuZF9saXN0KCJnaXQtbWVyZ2UtIiwgJm1haW5fY21kcywgJm90aGVyX2NtZHMpOwoJCWZvciAoaSA9IDA7IGkgPCBtYWluX2NtZHMuY250OyBpKyspIHsKCQkJaW50IGosIGZvdW5kID0gMDsKCQkJc3RydWN0IGNtZG5hbWUgKmVudCA9IG1haW5fY21kcy5uYW1lc1tpXTsKCQkJZm9yIChqID0gMDsgaiA8IEFSUkFZX1NJWkUoYWxsX3N0cmF0ZWd5KTsgaisrKQoJCQkJaWYgKCFzdHJuY21wKGVudC0+bmFtZSwgYWxsX3N0cmF0ZWd5W2pdLm5hbWUsIGVudC0+bGVuKQoJCQkJCQkmJiAhYWxsX3N0cmF0ZWd5W2pdLm5hbWVbZW50LT5sZW5dKQoJCQkJCWZvdW5kID0gMTsKCQkJaWYgKCFmb3VuZCkKCQkJCWFkZF9jbWRuYW1lKCZub3Rfc3RyYXRlZ2llcywgZW50LT5uYW1lLCBlbnQtPmxlbik7CgkJfQoJCWV4Y2x1ZGVfY21kcygmbWFpbl9jbWRzLCAmbm90X3N0cmF0ZWdpZXMpOwoJfQoJaWYgKCFpc19pbl9jbWRsaXN0KCZtYWluX2NtZHMsIG5hbWUpICYmICFpc19pbl9jbWRsaXN0KCZvdGhlcl9jbWRzLCBuYW1lKSkgewoJCWZwcmludGYoc3RkZXJyLCBfKCJDb3VsZCBub3QgZmluZCBtZXJnZSBzdHJhdGVneSAnJXMnLlxuIiksIG5hbWUpOwoJCWZwcmludGYoc3RkZXJyLCBfKCJBdmFpbGFibGUgc3RyYXRlZ2llcyBhcmU6IikpOwoJCWZvciAoaSA9IDA7IGkgPCBtYWluX2NtZHMuY250OyBpKyspCgkJCWZwcmludGYoc3RkZXJyLCAiICVzIiwgbWFpbl9jbWRzLm5hbWVzW2ldLT5uYW1lKTsKCQlmcHJpbnRmKHN0ZGVyciwgIi5cbiIpOwoJCWlmIChvdGhlcl9jbWRzLmNudCkgewoJCQlmcHJpbnRmKHN0ZGVyciwgXygiQXZhaWxhYmxlIGN1c3RvbSBzdHJhdGVnaWVzIGFyZToiKSk7CgkJCWZvciAoaSA9IDA7IGkgPCBvdGhlcl9jbWRzLmNudDsgaSsrKQoJCQkJZnByaW50ZihzdGRlcnIsICIgJXMiLCBvdGhlcl9jbWRzLm5hbWVzW2ldLT5uYW1lKTsKCQkJZnByaW50ZihzdGRlcnIsICIuXG4iKTsKCQl9CgkJZXhpdCgxKTsKCX0KCglyZXQgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3Qgc3RyYXRlZ3kpKTsKCXJldC0+bmFtZSA9IHhzdHJkdXAobmFtZSk7CglyZXQtPmF0dHIgPSBOT19UUklWSUFMOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIHZvaWQgYXBwZW5kX3N0cmF0ZWd5KHN0cnVjdCBzdHJhdGVneSAqcykKewoJQUxMT0NfR1JPVyh1c2Vfc3RyYXRlZ2llcywgdXNlX3N0cmF0ZWdpZXNfbnIgKyAxLCB1c2Vfc3RyYXRlZ2llc19hbGxvYyk7Cgl1c2Vfc3RyYXRlZ2llc1t1c2Vfc3RyYXRlZ2llc19ucisrXSA9IHM7Cn0KCnN0YXRpYyBpbnQgb3B0aW9uX3BhcnNlX3N0cmF0ZWd5KGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwKCQkJCSBjb25zdCBjaGFyICpuYW1lLCBpbnQgdW5zZXQpCnsKCWlmICh1bnNldCkKCQlyZXR1cm4gMDsKCglhcHBlbmRfc3RyYXRlZ3koZ2V0X3N0cmF0ZWd5KG5hbWUpKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IG9wdGlvbl9wYXJzZV94KGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwKCQkJICBjb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJaWYgKHVuc2V0KQoJCXJldHVybiAwOwoKCUFMTE9DX0dST1coeG9wdHMsIHhvcHRzX25yICsgMSwgeG9wdHNfYWxsb2MpOwoJeG9wdHNbeG9wdHNfbnIrK10gPSB4c3RyZHVwKGFyZyk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBvcHRpb25fcGFyc2Vfbihjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsCgkJCSAgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCXNob3dfZGlmZnN0YXQgPSB1bnNldDsKCXJldHVybiAwOwp9CgpzdGF0aWMgc3RydWN0IG9wdGlvbiBidWlsdGluX21lcmdlX29wdGlvbnNbXSA9IHsKCXsgT1BUSU9OX0NBTExCQUNLLCAnbicsIE5VTEwsIE5VTEwsIE5VTEwsCgkJImRvIG5vdCBzaG93IGEgZGlmZnN0YXQgYXQgdGhlIGVuZCBvZiB0aGUgbWVyZ2UiLAoJCVBBUlNFX09QVF9OT0FSRywgb3B0aW9uX3BhcnNlX24gfSwKCU9QVF9CT09MRUFOKDAsICJzdGF0IiwgJnNob3dfZGlmZnN0YXQsCgkJInNob3cgYSBkaWZmc3RhdCBhdCB0aGUgZW5kIG9mIHRoZSBtZXJnZSIpLAoJT1BUX0JPT0xFQU4oMCwgInN1bW1hcnkiLCAmc2hvd19kaWZmc3RhdCwgIihzeW5vbnltIHRvIC0tc3RhdCkiKSwKCXsgT1BUSU9OX0lOVEVHRVIsIDAsICJsb2ciLCAmc2hvcnRsb2dfbGVuLCAibiIsCgkgICJhZGQgKGF0IG1vc3QgPG4+KSBlbnRyaWVzIGZyb20gc2hvcnRsb2cgdG8gbWVyZ2UgY29tbWl0IG1lc3NhZ2UiLAoJICBQQVJTRV9PUFRfT1BUQVJHLCBOVUxMLCBERUZBVUxUX01FUkdFX0xPR19MRU4gfSwKCU9QVF9CT09MRUFOKDAsICJzcXVhc2giLCAmc3F1YXNoLAoJCSJjcmVhdGUgYSBzaW5nbGUgY29tbWl0IGluc3RlYWQgb2YgZG9pbmcgYSBtZXJnZSIpLAoJT1BUX0JPT0xFQU4oMCwgImNvbW1pdCIsICZvcHRpb25fY29tbWl0LAoJCSJwZXJmb3JtIGEgY29tbWl0IGlmIHRoZSBtZXJnZSBzdWNjZWVkcyAoZGVmYXVsdCkiKSwKCU9QVF9CT09MKCdlJywgImVkaXQiLCAmb3B0aW9uX2VkaXQsCgkJImVkaXQgbWVzc2FnZSBiZWZvcmUgY29tbWl0dGluZyIpLAoJT1BUX0JPT0xFQU4oMCwgImZmIiwgJmFsbG93X2Zhc3RfZm9yd2FyZCwKCQkiYWxsb3cgZmFzdC1mb3J3YXJkIChkZWZhdWx0KSIpLAoJT1BUX0JPT0xFQU4oMCwgImZmLW9ubHkiLCAmZmFzdF9mb3J3YXJkX29ubHksCgkJImFib3J0IGlmIGZhc3QtZm9yd2FyZCBpcyBub3QgcG9zc2libGUiKSwKCU9QVF9SRVJFUkVfQVVUT1VQREFURSgmYWxsb3dfcmVyZXJlX2F1dG8pLAoJT1BUX0NBTExCQUNLKCdzJywgInN0cmF0ZWd5IiwgJnVzZV9zdHJhdGVnaWVzLCAic3RyYXRlZ3kiLAoJCSJtZXJnZSBzdHJhdGVneSB0byB1c2UiLCBvcHRpb25fcGFyc2Vfc3RyYXRlZ3kpLAoJT1BUX0NBTExCQUNLKCdYJywgInN0cmF0ZWd5LW9wdGlvbiIsICZ4b3B0cywgIm9wdGlvbj12YWx1ZSIsCgkJIm9wdGlvbiBmb3Igc2VsZWN0ZWQgbWVyZ2Ugc3RyYXRlZ3kiLCBvcHRpb25fcGFyc2VfeCksCglPUFRfQ0FMTEJBQ0soJ20nLCAibWVzc2FnZSIsICZtZXJnZV9tc2csICJtZXNzYWdlIiwKCQkibWVyZ2UgY29tbWl0IG1lc3NhZ2UgKGZvciBhIG5vbi1mYXN0LWZvcndhcmQgbWVyZ2UpIiwKCQlvcHRpb25fcGFyc2VfbWVzc2FnZSksCglPUFRfX1ZFUkJPU0lUWSgmdmVyYm9zaXR5KSwKCU9QVF9CT09MRUFOKDAsICJhYm9ydCIsICZhYm9ydF9jdXJyZW50X21lcmdlLAoJCSJhYm9ydCB0aGUgY3VycmVudCBpbi1wcm9ncmVzcyBtZXJnZSIpLAoJT1BUX1NFVF9JTlQoMCwgInByb2dyZXNzIiwgJnNob3dfcHJvZ3Jlc3MsICJmb3JjZSBwcm9ncmVzcyByZXBvcnRpbmciLCAxKSwKCU9QVF9FTkQoKQp9OwoKLyogQ2xlYW5zIHVwIG1ldGFkYXRhIHRoYXQgaXMgdW5pbnRlcmVzdGluZyBhZnRlciBhIHN1Y2NlZWRlZCBtZXJnZS4gKi8Kc3RhdGljIHZvaWQgZHJvcF9zYXZlKHZvaWQpCnsKCXVubGluayhnaXRfcGF0aCgiTUVSR0VfSEVBRCIpKTsKCXVubGluayhnaXRfcGF0aCgiTUVSR0VfTVNHIikpOwoJdW5saW5rKGdpdF9wYXRoKCJNRVJHRV9NT0RFIikpOwp9CgpzdGF0aWMgaW50IHNhdmVfc3RhdGUodW5zaWduZWQgY2hhciAqc3Rhc2gpCnsKCWludCBsZW47CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBjcDsKCXN0cnVjdCBzdHJidWYgYnVmZmVyID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICphcmd2W10gPSB7InN0YXNoIiwgImNyZWF0ZSIsIE5VTEx9OwoKCW1lbXNldCgmY3AsIDAsIHNpemVvZihjcCkpOwoJY3AuYXJndiA9IGFyZ3Y7CgljcC5vdXQgPSAtMTsKCWNwLmdpdF9jbWQgPSAxOwoKCWlmIChzdGFydF9jb21tYW5kKCZjcCkpCgkJZGllKF8oImNvdWxkIG5vdCBydW4gc3Rhc2guIikpOwoJbGVuID0gc3RyYnVmX3JlYWQoJmJ1ZmZlciwgY3Aub3V0LCAxMDI0KTsKCWNsb3NlKGNwLm91dCk7CgoJaWYgKGZpbmlzaF9jb21tYW5kKCZjcCkgfHwgbGVuIDwgMCkKCQlkaWUoXygic3Rhc2ggZmFpbGVkIikpOwoJZWxzZSBpZiAoIWxlbikJCS8qIG5vIGNoYW5nZXMgKi8KCQlyZXR1cm4gLTE7CglzdHJidWZfc2V0bGVuKCZidWZmZXIsIGJ1ZmZlci5sZW4tMSk7CglpZiAoZ2V0X3NoYTEoYnVmZmVyLmJ1Ziwgc3Rhc2gpKQoJCWRpZShfKCJub3QgYSB2YWxpZCBvYmplY3Q6ICVzIiksIGJ1ZmZlci5idWYpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHJlYWRfZW1wdHkodW5zaWduZWQgY29uc3QgY2hhciAqc2hhMSwgaW50IHZlcmJvc2UpCnsKCWludCBpID0gMDsKCWNvbnN0IGNoYXIgKmFyZ3NbN107CgoJYXJnc1tpKytdID0gInJlYWQtdHJlZSI7CglpZiAodmVyYm9zZSkKCQlhcmdzW2krK10gPSAiLXYiOwoJYXJnc1tpKytdID0gIi1tIjsKCWFyZ3NbaSsrXSA9ICItdSI7CglhcmdzW2krK10gPSBFTVBUWV9UUkVFX1NIQTFfSEVYOwoJYXJnc1tpKytdID0gc2hhMV90b19oZXgoc2hhMSk7CglhcmdzW2ldID0gTlVMTDsKCglpZiAocnVuX2NvbW1hbmRfdl9vcHQoYXJncywgUlVOX0dJVF9DTUQpKQoJCWRpZShfKCJyZWFkLXRyZWUgZmFpbGVkIikpOwp9CgpzdGF0aWMgdm9pZCByZXNldF9oYXJkKHVuc2lnbmVkIGNvbnN0IGNoYXIgKnNoYTEsIGludCB2ZXJib3NlKQp7CglpbnQgaSA9IDA7Cgljb25zdCBjaGFyICphcmdzWzZdOwoKCWFyZ3NbaSsrXSA9ICJyZWFkLXRyZWUiOwoJaWYgKHZlcmJvc2UpCgkJYXJnc1tpKytdID0gIi12IjsKCWFyZ3NbaSsrXSA9ICItLXJlc2V0IjsKCWFyZ3NbaSsrXSA9ICItdSI7CglhcmdzW2krK10gPSBzaGExX3RvX2hleChzaGExKTsKCWFyZ3NbaV0gPSBOVUxMOwoKCWlmIChydW5fY29tbWFuZF92X29wdChhcmdzLCBSVU5fR0lUX0NNRCkpCgkJZGllKF8oInJlYWQtdHJlZSBmYWlsZWQiKSk7Cn0KCnN0YXRpYyB2b2lkIHJlc3RvcmVfc3RhdGUoY29uc3QgdW5zaWduZWQgY2hhciAqaGVhZCwKCQkJICBjb25zdCB1bnNpZ25lZCBjaGFyICpzdGFzaCkKewoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJY29uc3QgY2hhciAqYXJnc1tdID0geyAic3Rhc2giLCAiYXBwbHkiLCBOVUxMLCBOVUxMIH07CgoJaWYgKGlzX251bGxfc2hhMShzdGFzaCkpCgkJcmV0dXJuOwoKCXJlc2V0X2hhcmQoaGVhZCwgMSk7CgoJYXJnc1syXSA9IHNoYTFfdG9faGV4KHN0YXNoKTsKCgkvKgoJICogSXQgaXMgT0sgdG8gaWdub3JlIGVycm9yIGhlcmUsIGZvciBleGFtcGxlIHdoZW4gdGhlcmUgd2FzCgkgKiBub3RoaW5nIHRvIHJlc3RvcmUuCgkgKi8KCXJ1bl9jb21tYW5kX3Zfb3B0KGFyZ3MsIFJVTl9HSVRfQ01EKTsKCglzdHJidWZfcmVsZWFzZSgmc2IpOwoJcmVmcmVzaF9jYWNoZShSRUZSRVNIX1FVSUVUKTsKfQoKLyogVGhpcyBpcyBjYWxsZWQgd2hlbiBubyBtZXJnZSB3YXMgbmVjZXNzYXJ5LiAqLwpzdGF0aWMgdm9pZCBmaW5pc2hfdXBfdG9fZGF0ZShjb25zdCBjaGFyICptc2cpCnsKCWlmICh2ZXJib3NpdHkgPj0gMCkKCQlwcmludGYoIiVzJXNcbiIsIHNxdWFzaCA/IF8oIiAobm90aGluZyB0byBzcXVhc2gpIikgOiAiIiwgbXNnKTsKCWRyb3Bfc2F2ZSgpOwp9CgpzdGF0aWMgdm9pZCBzcXVhc2hfbWVzc2FnZShzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCXN0cnVjdCByZXZfaW5mbyByZXY7CglzdHJ1Y3Qgc3RyYnVmIG91dCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IGNvbW1pdF9saXN0ICpqOwoJaW50IGZkOwoJc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0IGN0eCA9IHswfTsKCglwcmludGYoXygiU3F1YXNoIGNvbW1pdCAtLSBub3QgdXBkYXRpbmcgSEVBRFxuIikpOwoJZmQgPSBvcGVuKGdpdF9wYXRoKCJTUVVBU0hfTVNHIiksIE9fV1JPTkxZIHwgT19DUkVBVCwgMDY2Nik7CglpZiAoZmQgPCAwKQoJCWRpZV9lcnJubyhfKCJDb3VsZCBub3Qgd3JpdGUgdG8gJyVzJyIpLCBnaXRfcGF0aCgiU1FVQVNIX01TRyIpKTsKCglpbml0X3JldmlzaW9ucygmcmV2LCBOVUxMKTsKCXJldi5pZ25vcmVfbWVyZ2VzID0gMTsKCXJldi5jb21taXRfZm9ybWF0ID0gQ01JVF9GTVRfTUVESVVNOwoKCWNvbW1pdC0+b2JqZWN0LmZsYWdzIHw9IFVOSU5URVJFU1RJTkc7CglhZGRfcGVuZGluZ19vYmplY3QoJnJldiwgJmNvbW1pdC0+b2JqZWN0LCBOVUxMKTsKCglmb3IgKGogPSByZW1vdGVoZWFkczsgajsgaiA9IGotPm5leHQpCgkJYWRkX3BlbmRpbmdfb2JqZWN0KCZyZXYsICZqLT5pdGVtLT5vYmplY3QsIE5VTEwpOwoKCXNldHVwX3JldmlzaW9ucygwLCBOVUxMLCAmcmV2LCBOVUxMKTsKCWlmIChwcmVwYXJlX3JldmlzaW9uX3dhbGsoJnJldikpCgkJZGllKF8oInJldmlzaW9uIHdhbGsgc2V0dXAgZmFpbGVkIikpOwoKCWN0eC5hYmJyZXYgPSByZXYuYWJicmV2OwoJY3R4LmRhdGVfbW9kZSA9IHJldi5kYXRlX21vZGU7CgljdHguZm10ID0gcmV2LmNvbW1pdF9mb3JtYXQ7CgoJc3RyYnVmX2FkZHN0cigmb3V0LCAiU3F1YXNoZWQgY29tbWl0IG9mIHRoZSBmb2xsb3dpbmc6XG4iKTsKCXdoaWxlICgoY29tbWl0ID0gZ2V0X3JldmlzaW9uKCZyZXYpKSAhPSBOVUxMKSB7CgkJc3RyYnVmX2FkZGNoKCZvdXQsICdcbicpOwoJCXN0cmJ1Zl9hZGRmKCZvdXQsICJjb21taXQgJXNcbiIsCgkJCXNoYTFfdG9faGV4KGNvbW1pdC0+b2JqZWN0LnNoYTEpKTsKCQlwcmV0dHlfcHJpbnRfY29tbWl0KCZjdHgsIGNvbW1pdCwgJm91dCk7Cgl9CglpZiAod3JpdGUoZmQsIG91dC5idWYsIG91dC5sZW4pIDwgMCkKCQlkaWVfZXJybm8oXygiV3JpdGluZyBTUVVBU0hfTVNHIikpOwoJaWYgKGNsb3NlKGZkKSkKCQlkaWVfZXJybm8oXygiRmluaXNoaW5nIFNRVUFTSF9NU0ciKSk7CglzdHJidWZfcmVsZWFzZSgmb3V0KTsKfQoKc3RhdGljIHZvaWQgZmluaXNoKHN0cnVjdCBjb21taXQgKmhlYWRfY29tbWl0LAoJCSAgIGNvbnN0IHVuc2lnbmVkIGNoYXIgKm5ld19oZWFkLCBjb25zdCBjaGFyICptc2cpCnsKCXN0cnVjdCBzdHJidWYgcmVmbG9nX21lc3NhZ2UgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IHVuc2lnbmVkIGNoYXIgKmhlYWQgPSBoZWFkX2NvbW1pdC0+b2JqZWN0LnNoYTE7CgoJaWYgKCFtc2cpCgkJc3RyYnVmX2FkZHN0cigmcmVmbG9nX21lc3NhZ2UsIGdldGVudigiR0lUX1JFRkxPR19BQ1RJT04iKSk7CgllbHNlIHsKCQlpZiAodmVyYm9zaXR5ID49IDApCgkJCXByaW50ZigiJXNcbiIsIG1zZyk7CgkJc3RyYnVmX2FkZGYoJnJlZmxvZ19tZXNzYWdlLCAiJXM6ICVzIiwKCQkJZ2V0ZW52KCJHSVRfUkVGTE9HX0FDVElPTiIpLCBtc2cpOwoJfQoJaWYgKHNxdWFzaCkgewoJCXNxdWFzaF9tZXNzYWdlKGhlYWRfY29tbWl0KTsKCX0gZWxzZSB7CgkJaWYgKHZlcmJvc2l0eSA+PSAwICYmICFtZXJnZV9tc2cubGVuKQoJCQlwcmludGYoXygiTm8gbWVyZ2UgbWVzc2FnZSAtLSBub3QgdXBkYXRpbmcgSEVBRFxuIikpOwoJCWVsc2UgewoJCQljb25zdCBjaGFyICphcmd2X2djX2F1dG9bXSA9IHsgImdjIiwgIi0tYXV0byIsIE5VTEwgfTsKCQkJdXBkYXRlX3JlZihyZWZsb2dfbWVzc2FnZS5idWYsICJIRUFEIiwKCQkJCW5ld19oZWFkLCBoZWFkLCAwLAoJCQkJRElFX09OX0VSUik7CgkJCS8qCgkJCSAqIFdlIGlnbm9yZSBlcnJvcnMgaW4gJ2djIC0tYXV0bycsIHNpbmNlIHRoZQoJCQkgKiB1c2VyIHNob3VsZCBzZWUgdGhlbS4KCQkJICovCgkJCXJ1bl9jb21tYW5kX3Zfb3B0KGFyZ3ZfZ2NfYXV0bywgUlVOX0dJVF9DTUQpOwoJCX0KCX0KCWlmIChuZXdfaGVhZCAmJiBzaG93X2RpZmZzdGF0KSB7CgkJc3RydWN0IGRpZmZfb3B0aW9ucyBvcHRzOwoJCWRpZmZfc2V0dXAoJm9wdHMpOwoJCW9wdHMub3V0cHV0X2Zvcm1hdCB8PQoJCQlESUZGX0ZPUk1BVF9TVU1NQVJZIHwgRElGRl9GT1JNQVRfRElGRlNUQVQ7CgkJb3B0cy5kZXRlY3RfcmVuYW1lID0gRElGRl9ERVRFQ1RfUkVOQU1FOwoJCWlmIChkaWZmX3NldHVwX2RvbmUoJm9wdHMpIDwgMCkKCQkJZGllKF8oImRpZmZfc2V0dXBfZG9uZSBmYWlsZWQiKSk7CgkJZGlmZl90cmVlX3NoYTEoaGVhZCwgbmV3X2hlYWQsICIiLCAmb3B0cyk7CgkJZGlmZmNvcmVfc3RkKCZvcHRzKTsKCQlkaWZmX2ZsdXNoKCZvcHRzKTsKCX0KCgkvKiBSdW4gYSBwb3N0LW1lcmdlIGhvb2sgKi8KCXJ1bl9ob29rKE5VTEwsICJwb3N0LW1lcmdlIiwgc3F1YXNoID8gIjEiIDogIjAiLCBOVUxMKTsKCglzdHJidWZfcmVsZWFzZSgmcmVmbG9nX21lc3NhZ2UpOwp9CgovKiBHZXQgdGhlIG5hbWUgZm9yIHRoZSBtZXJnZSBjb21taXQncyBtZXNzYWdlLiAqLwpzdGF0aWMgdm9pZCBtZXJnZV9uYW1lKGNvbnN0IGNoYXIgKnJlbW90ZSwgc3RydWN0IHN0cmJ1ZiAqbXNnKQp7CglzdHJ1Y3QgY29tbWl0ICpyZW1vdGVfaGVhZDsKCXVuc2lnbmVkIGNoYXIgYnJhbmNoX2hlYWRbMjBdLCBidWZfc2hhWzIwXTsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGJuYW1lID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpwdHI7CgljaGFyICpmb3VuZF9yZWY7CglpbnQgbGVuLCBlYXJseTsKCglzdHJidWZfYnJhbmNobmFtZSgmYm5hbWUsIHJlbW90ZSk7CglyZW1vdGUgPSBibmFtZS5idWY7CgoJbWVtc2V0KGJyYW5jaF9oZWFkLCAwLCBzaXplb2YoYnJhbmNoX2hlYWQpKTsKCXJlbW90ZV9oZWFkID0gZ2V0X21lcmdlX3BhcmVudChyZW1vdGUpOwoJaWYgKCFyZW1vdGVfaGVhZCkKCQlkaWUoXygiJyVzJyBkb2VzIG5vdCBwb2ludCB0byBhIGNvbW1pdCIpLCByZW1vdGUpOwoKCWlmIChkd2ltX3JlZihyZW1vdGUsIHN0cmxlbihyZW1vdGUpLCBicmFuY2hfaGVhZCwgJmZvdW5kX3JlZikgPiAwKSB7CgkJaWYgKCFwcmVmaXhjbXAoZm91bmRfcmVmLCAicmVmcy9oZWFkcy8iKSkgewoJCQlzdHJidWZfYWRkZihtc2csICIlc1x0XHRicmFuY2ggJyVzJyBvZiAuXG4iLAoJCQkJICAgIHNoYTFfdG9faGV4KGJyYW5jaF9oZWFkKSwgcmVtb3RlKTsKCQkJZ290byBjbGVhbnVwOwoJCX0KCQlpZiAoIXByZWZpeGNtcChmb3VuZF9yZWYsICJyZWZzL3RhZ3MvIikpIHsKCQkJc3RyYnVmX2FkZGYobXNnLCAiJXNcdFx0dGFnICclcycgb2YgLlxuIiwKCQkJCSAgICBzaGExX3RvX2hleChicmFuY2hfaGVhZCksIHJlbW90ZSk7CgkJCWdvdG8gY2xlYW51cDsKCQl9CgkJaWYgKCFwcmVmaXhjbXAoZm91bmRfcmVmLCAicmVmcy9yZW1vdGVzLyIpKSB7CgkJCXN0cmJ1Zl9hZGRmKG1zZywgIiVzXHRcdHJlbW90ZS10cmFja2luZyBicmFuY2ggJyVzJyBvZiAuXG4iLAoJCQkJICAgIHNoYTFfdG9faGV4KGJyYW5jaF9oZWFkKSwgcmVtb3RlKTsKCQkJZ290byBjbGVhbnVwOwoJCX0KCX0KCgkvKiBTZWUgaWYgcmVtb3RlIG1hdGNoZXMgPG5hbWU+Xl5eLi4gb3IgPG5hbWU+fjxudW1iZXI+ICovCglmb3IgKGxlbiA9IDAsIHB0ciA9IHJlbW90ZSArIHN0cmxlbihyZW1vdGUpOwoJICAgICByZW1vdGUgPCBwdHIgJiYgcHRyWy0xXSA9PSAnXic7CgkgICAgIHB0ci0tKQoJCWxlbisrOwoJaWYgKGxlbikKCQllYXJseSA9IDE7CgllbHNlIHsKCQllYXJseSA9IDA7CgkJcHRyID0gc3RycmNocihyZW1vdGUsICd+Jyk7CgkJaWYgKHB0cikgewoJCQlpbnQgc2Vlbl9ub256ZXJvID0gMDsKCgkJCWxlbisrOyAvKiBjb3VudCB+ICovCgkJCXdoaWxlICgqKytwdHIgJiYgaXNkaWdpdCgqcHRyKSkgewoJCQkJc2Vlbl9ub256ZXJvIHw9ICgqcHRyICE9ICcwJyk7CgkJCQlsZW4rKzsKCQkJfQoJCQlpZiAoKnB0cikKCQkJCWxlbiA9IDA7IC8qIG5vdCAuLi5+PG51bWJlcj4gKi8KCQkJZWxzZSBpZiAoc2Vlbl9ub256ZXJvKQoJCQkJZWFybHkgPSAxOwoJCQllbHNlIGlmIChsZW4gPT0gMSkKCQkJCWVhcmx5ID0gMTsgLyogIm5hbWV+IiBpcyAibmFtZX4xIiEgKi8KCQl9Cgl9CglpZiAobGVuKSB7CgkJc3RydWN0IHN0cmJ1ZiB0cnVuYW1lID0gU1RSQlVGX0lOSVQ7CgkJc3RyYnVmX2FkZHN0cigmdHJ1bmFtZSwgInJlZnMvaGVhZHMvIik7CgkJc3RyYnVmX2FkZHN0cigmdHJ1bmFtZSwgcmVtb3RlKTsKCQlzdHJidWZfc2V0bGVuKCZ0cnVuYW1lLCB0cnVuYW1lLmxlbiAtIGxlbik7CgkJaWYgKHJlc29sdmVfcmVmKHRydW5hbWUuYnVmLCBidWZfc2hhLCAxLCBOVUxMKSkgewoJCQlzdHJidWZfYWRkZihtc2csCgkJCQkgICAgIiVzXHRcdGJyYW5jaCAnJXMnJXMgb2YgLlxuIiwKCQkJCSAgICBzaGExX3RvX2hleChyZW1vdGVfaGVhZC0+b2JqZWN0LnNoYTEpLAoJCQkJICAgIHRydW5hbWUuYnVmICsgMTEsCgkJCQkgICAgKGVhcmx5ID8gIiAoZWFybHkgcGFydCkiIDogIiIpKTsKCQkJc3RyYnVmX3JlbGVhc2UoJnRydW5hbWUpOwoJCQlnb3RvIGNsZWFudXA7CgkJfQoJfQoKCWlmICghc3RyY21wKHJlbW90ZSwgIkZFVENIX0hFQUQiKSAmJgoJCQkhYWNjZXNzKGdpdF9wYXRoKCJGRVRDSF9IRUFEIiksIFJfT0spKSB7CgkJRklMRSAqZnA7CgkJc3RydWN0IHN0cmJ1ZiBsaW5lID0gU1RSQlVGX0lOSVQ7CgkJY2hhciAqcHRyOwoKCQlmcCA9IGZvcGVuKGdpdF9wYXRoKCJGRVRDSF9IRUFEIiksICJyIik7CgkJaWYgKCFmcCkKCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCBvcGVuICclcycgZm9yIHJlYWRpbmciKSwKCQkJCSAgZ2l0X3BhdGgoIkZFVENIX0hFQUQiKSk7CgkJc3RyYnVmX2dldGxpbmUoJmxpbmUsIGZwLCAnXG4nKTsKCQlmY2xvc2UoZnApOwoJCXB0ciA9IHN0cnN0cihsaW5lLmJ1ZiwgIlx0bm90LWZvci1tZXJnZVx0Iik7CgkJaWYgKHB0cikKCQkJc3RyYnVmX3JlbW92ZSgmbGluZSwgcHRyLWxpbmUuYnVmKzEsIDEzKTsKCQlzdHJidWZfYWRkYnVmKG1zZywgJmxpbmUpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZsaW5lKTsKCQlnb3RvIGNsZWFudXA7Cgl9CglzdHJidWZfYWRkZihtc2csICIlc1x0XHRjb21taXQgJyVzJ1xuIiwKCQlzaGExX3RvX2hleChyZW1vdGVfaGVhZC0+b2JqZWN0LnNoYTEpLCByZW1vdGUpOwpjbGVhbnVwOgoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CglzdHJidWZfcmVsZWFzZSgmYm5hbWUpOwp9CgpzdGF0aWMgdm9pZCBwYXJzZV9icmFuY2hfbWVyZ2Vfb3B0aW9ucyhjaGFyICpibW8pCnsKCWNvbnN0IGNoYXIgKiphcmd2OwoJaW50IGFyZ2M7CgoJaWYgKCFibW8pCgkJcmV0dXJuOwoJYXJnYyA9IHNwbGl0X2NtZGxpbmUoYm1vLCAmYXJndik7CglpZiAoYXJnYyA8IDApCgkJZGllKF8oIkJhZCBicmFuY2guJXMubWVyZ2VvcHRpb25zIHN0cmluZzogJXMiKSwgYnJhbmNoLAoJCSAgICBzcGxpdF9jbWRsaW5lX3N0cmVycm9yKGFyZ2MpKTsKCWFyZ3YgPSB4cmVhbGxvYyhhcmd2LCBzaXplb2YoKmFyZ3YpICogKGFyZ2MgKyAyKSk7CgltZW1tb3ZlKGFyZ3YgKyAxLCBhcmd2LCBzaXplb2YoKmFyZ3YpICogKGFyZ2MgKyAxKSk7CglhcmdjKys7Cglhcmd2WzBdID0gImJyYW5jaC4qLm1lcmdlb3B0aW9ucyI7CglwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIE5VTEwsIGJ1aWx0aW5fbWVyZ2Vfb3B0aW9ucywKCQkgICAgICBidWlsdGluX21lcmdlX3VzYWdlLCAwKTsKCWZyZWUoYXJndik7Cn0KCnN0YXRpYyBpbnQgZ2l0X21lcmdlX2NvbmZpZyhjb25zdCBjaGFyICprLCBjb25zdCBjaGFyICp2LCB2b2lkICpjYikKewoJaWYgKGJyYW5jaCAmJiAhcHJlZml4Y21wKGssICJicmFuY2guIikgJiYKCQkhcHJlZml4Y21wKGsgKyA3LCBicmFuY2gpICYmCgkJIXN0cmNtcChrICsgNyArIHN0cmxlbihicmFuY2gpLCAiLm1lcmdlb3B0aW9ucyIpKSB7CgkJZnJlZShicmFuY2hfbWVyZ2VvcHRpb25zKTsKCQlicmFuY2hfbWVyZ2VvcHRpb25zID0geHN0cmR1cCh2KTsKCQlyZXR1cm4gMDsKCX0KCglpZiAoIXN0cmNtcChrLCAibWVyZ2UuZGlmZnN0YXQiKSB8fCAhc3RyY21wKGssICJtZXJnZS5zdGF0IikpCgkJc2hvd19kaWZmc3RhdCA9IGdpdF9jb25maWdfYm9vbChrLCB2KTsKCWVsc2UgaWYgKCFzdHJjbXAoaywgInB1bGwudHdvaGVhZCIpKQoJCXJldHVybiBnaXRfY29uZmlnX3N0cmluZygmcHVsbF90d29oZWFkLCBrLCB2KTsKCWVsc2UgaWYgKCFzdHJjbXAoaywgInB1bGwub2N0b3B1cyIpKQoJCXJldHVybiBnaXRfY29uZmlnX3N0cmluZygmcHVsbF9vY3RvcHVzLCBrLCB2KTsKCWVsc2UgaWYgKCFzdHJjbXAoaywgIm1lcmdlLnJlbm9ybWFsaXplIikpCgkJb3B0aW9uX3Jlbm9ybWFsaXplID0gZ2l0X2NvbmZpZ19ib29sKGssIHYpOwoJZWxzZSBpZiAoIXN0cmNtcChrLCAibWVyZ2UubG9nIikgfHwgIXN0cmNtcChrLCAibWVyZ2Uuc3VtbWFyeSIpKSB7CgkJaW50IGlzX2Jvb2w7CgkJc2hvcnRsb2dfbGVuID0gZ2l0X2NvbmZpZ19ib29sX29yX2ludChrLCB2LCAmaXNfYm9vbCk7CgkJaWYgKCFpc19ib29sICYmIHNob3J0bG9nX2xlbiA8IDApCgkJCXJldHVybiBlcnJvcihfKCIlczogbmVnYXRpdmUgbGVuZ3RoICVzIiksIGssIHYpOwoJCWlmIChpc19ib29sICYmIHNob3J0bG9nX2xlbikKCQkJc2hvcnRsb2dfbGVuID0gREVGQVVMVF9NRVJHRV9MT0dfTEVOOwoJCXJldHVybiAwOwoJfSBlbHNlIGlmICghc3RyY21wKGssICJtZXJnZS5mZiIpKSB7CgkJaW50IGJvb2x2YWwgPSBnaXRfY29uZmlnX21heWJlX2Jvb2woaywgdik7CgkJaWYgKDAgPD0gYm9vbHZhbCkgewoJCQlhbGxvd19mYXN0X2ZvcndhcmQgPSBib29sdmFsOwoJCX0gZWxzZSBpZiAodiAmJiAhc3RyY21wKHYsICJvbmx5IikpIHsKCQkJYWxsb3dfZmFzdF9mb3J3YXJkID0gMTsKCQkJZmFzdF9mb3J3YXJkX29ubHkgPSAxOwoJCX0gLyogZG8gbm90IGJhcmYgb24gdmFsdWVzIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdpdCAqLwoJCXJldHVybiAwOwoJfSBlbHNlIGlmICghc3RyY21wKGssICJtZXJnZS5kZWZhdWx0dG91cHN0cmVhbSIpKSB7CgkJZGVmYXVsdF90b191cHN0cmVhbSA9IGdpdF9jb25maWdfYm9vbChrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCXJldHVybiBnaXRfZGlmZl91aV9jb25maWcoaywgdiwgY2IpOwp9CgpzdGF0aWMgaW50IHJlYWRfdHJlZV90cml2aWFsKHVuc2lnbmVkIGNoYXIgKmNvbW1vbiwgdW5zaWduZWQgY2hhciAqaGVhZCwKCQkJICAgICB1bnNpZ25lZCBjaGFyICpvbmUpCnsKCWludCBpLCBucl90cmVlcyA9IDA7CglzdHJ1Y3QgdHJlZSAqdHJlZXNbTUFYX1VOUEFDS19UUkVFU107CglzdHJ1Y3QgdHJlZV9kZXNjIHRbTUFYX1VOUEFDS19UUkVFU107CglzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgb3B0czsKCgltZW1zZXQoJm9wdHMsIDAsIHNpemVvZihvcHRzKSk7CglvcHRzLmhlYWRfaWR4ID0gMjsKCW9wdHMuc3JjX2luZGV4ID0gJnRoZV9pbmRleDsKCW9wdHMuZHN0X2luZGV4ID0gJnRoZV9pbmRleDsKCW9wdHMudXBkYXRlID0gMTsKCW9wdHMudmVyYm9zZV91cGRhdGUgPSAxOwoJb3B0cy50cml2aWFsX21lcmdlc19vbmx5ID0gMTsKCW9wdHMubWVyZ2UgPSAxOwoJdHJlZXNbbnJfdHJlZXNdID0gcGFyc2VfdHJlZV9pbmRpcmVjdChjb21tb24pOwoJaWYgKCF0cmVlc1tucl90cmVlcysrXSkKCQlyZXR1cm4gLTE7Cgl0cmVlc1tucl90cmVlc10gPSBwYXJzZV90cmVlX2luZGlyZWN0KGhlYWQpOwoJaWYgKCF0cmVlc1tucl90cmVlcysrXSkKCQlyZXR1cm4gLTE7Cgl0cmVlc1tucl90cmVlc10gPSBwYXJzZV90cmVlX2luZGlyZWN0KG9uZSk7CglpZiAoIXRyZWVzW25yX3RyZWVzKytdKQoJCXJldHVybiAtMTsKCW9wdHMuZm4gPSB0aHJlZXdheV9tZXJnZTsKCWNhY2hlX3RyZWVfZnJlZSgmYWN0aXZlX2NhY2hlX3RyZWUpOwoJZm9yIChpID0gMDsgaSA8IG5yX3RyZWVzOyBpKyspIHsKCQlwYXJzZV90cmVlKHRyZWVzW2ldKTsKCQlpbml0X3RyZWVfZGVzYyh0K2ksIHRyZWVzW2ldLT5idWZmZXIsIHRyZWVzW2ldLT5zaXplKTsKCX0KCWlmICh1bnBhY2tfdHJlZXMobnJfdHJlZXMsIHQsICZvcHRzKSkKCQlyZXR1cm4gLTE7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgd3JpdGVfdHJlZV90cml2aWFsKHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCWlmICh3cml0ZV9jYWNoZV9hc190cmVlKHNoYTEsIDAsIE5VTEwpKQoJCWRpZShfKCJnaXQgd3JpdGUtdHJlZSBmYWlsZWQgdG8gd3JpdGUgYSB0cmVlIikpOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqbWVyZ2VfYXJndW1lbnQoc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglpZiAoY29tbWl0KQoJCXJldHVybiBzaGExX3RvX2hleChjb21taXQtPm9iamVjdC5zaGExKTsKCWVsc2UKCQlyZXR1cm4gRU1QVFlfVFJFRV9TSEExX0hFWDsKfQoKaW50IHRyeV9tZXJnZV9jb21tYW5kKGNvbnN0IGNoYXIgKnN0cmF0ZWd5LCBzaXplX3QgeG9wdHNfbnIsCgkJICAgICAgY29uc3QgY2hhciAqKnhvcHRzLCBzdHJ1Y3QgY29tbWl0X2xpc3QgKmNvbW1vbiwKCQkgICAgICBjb25zdCBjaGFyICpoZWFkX2FyZywgc3RydWN0IGNvbW1pdF9saXN0ICpyZW1vdGVzKQp7Cgljb25zdCBjaGFyICoqYXJnczsKCWludCBpID0gMCwgeCA9IDAsIHJldDsKCXN0cnVjdCBjb21taXRfbGlzdCAqajsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJYXJncyA9IHhtYWxsb2MoKDQgKyB4b3B0c19uciArIGNvbW1pdF9saXN0X2NvdW50KGNvbW1vbikgKwoJCQljb21taXRfbGlzdF9jb3VudChyZW1vdGVzKSkgKiBzaXplb2YoY2hhciAqKSk7CglzdHJidWZfYWRkZigmYnVmLCAibWVyZ2UtJXMiLCBzdHJhdGVneSk7CglhcmdzW2krK10gPSBidWYuYnVmOwoJZm9yICh4ID0gMDsgeCA8IHhvcHRzX25yOyB4KyspIHsKCQljaGFyICpzID0geG1hbGxvYyhzdHJsZW4oeG9wdHNbeF0pKzIrMSk7CgkJc3RyY3B5KHMsICItLSIpOwoJCXN0cmNweShzKzIsIHhvcHRzW3hdKTsKCQlhcmdzW2krK10gPSBzOwoJfQoJZm9yIChqID0gY29tbW9uOyBqOyBqID0gai0+bmV4dCkKCQlhcmdzW2krK10gPSB4c3RyZHVwKG1lcmdlX2FyZ3VtZW50KGotPml0ZW0pKTsKCWFyZ3NbaSsrXSA9ICItLSI7CglhcmdzW2krK10gPSBoZWFkX2FyZzsKCWZvciAoaiA9IHJlbW90ZXM7IGo7IGogPSBqLT5uZXh0KQoJCWFyZ3NbaSsrXSA9IHhzdHJkdXAobWVyZ2VfYXJndW1lbnQoai0+aXRlbSkpOwoJYXJnc1tpXSA9IE5VTEw7CglyZXQgPSBydW5fY29tbWFuZF92X29wdChhcmdzLCBSVU5fR0lUX0NNRCk7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCWkgPSAxOwoJZm9yICh4ID0gMDsgeCA8IHhvcHRzX25yOyB4KyspCgkJZnJlZSgodm9pZCAqKWFyZ3NbaSsrXSk7Cglmb3IgKGogPSBjb21tb247IGo7IGogPSBqLT5uZXh0KQoJCWZyZWUoKHZvaWQgKilhcmdzW2krK10pOwoJaSArPSAyOwoJZm9yIChqID0gcmVtb3RlczsgajsgaiA9IGotPm5leHQpCgkJZnJlZSgodm9pZCAqKWFyZ3NbaSsrXSk7CglmcmVlKGFyZ3MpOwoJZGlzY2FyZF9jYWNoZSgpOwoJaWYgKHJlYWRfY2FjaGUoKSA8IDApCgkJZGllKF8oImZhaWxlZCB0byByZWFkIHRoZSBjYWNoZSIpKTsKCXJlc29sdmVfdW5kb19jbGVhcigpOwoKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQgdHJ5X21lcmdlX3N0cmF0ZWd5KGNvbnN0IGNoYXIgKnN0cmF0ZWd5LCBzdHJ1Y3QgY29tbWl0X2xpc3QgKmNvbW1vbiwKCQkJICAgICAgc3RydWN0IGNvbW1pdCAqaGVhZCwgY29uc3QgY2hhciAqaGVhZF9hcmcpCnsKCWludCBpbmRleF9mZDsKCXN0cnVjdCBsb2NrX2ZpbGUgKmxvY2sgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3QgbG9ja19maWxlKSk7CgoJaW5kZXhfZmQgPSBob2xkX2xvY2tlZF9pbmRleChsb2NrLCAxKTsKCXJlZnJlc2hfY2FjaGUoUkVGUkVTSF9RVUlFVCk7CglpZiAoYWN0aXZlX2NhY2hlX2NoYW5nZWQgJiYKCQkJKHdyaXRlX2NhY2hlKGluZGV4X2ZkLCBhY3RpdmVfY2FjaGUsIGFjdGl2ZV9ucikgfHwKCQkJIGNvbW1pdF9sb2NrZWRfaW5kZXgobG9jaykpKQoJCXJldHVybiBlcnJvcihfKCJVbmFibGUgdG8gd3JpdGUgaW5kZXguIikpOwoJcm9sbGJhY2tfbG9ja19maWxlKGxvY2spOwoKCWlmICghc3RyY21wKHN0cmF0ZWd5LCAicmVjdXJzaXZlIikgfHwgIXN0cmNtcChzdHJhdGVneSwgInN1YnRyZWUiKSkgewoJCWludCBjbGVhbiwgeDsKCQlzdHJ1Y3QgY29tbWl0ICpyZXN1bHQ7CgkJc3RydWN0IGxvY2tfZmlsZSAqbG9jayA9IHhjYWxsb2MoMSwgc2l6ZW9mKHN0cnVjdCBsb2NrX2ZpbGUpKTsKCQlpbnQgaW5kZXhfZmQ7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpyZXZlcnNlZCA9IE5VTEw7CgkJc3RydWN0IG1lcmdlX29wdGlvbnMgbzsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKmo7CgoJCWlmIChyZW1vdGVoZWFkcy0+bmV4dCkgewoJCQllcnJvcihfKCJOb3QgaGFuZGxpbmcgYW55dGhpbmcgb3RoZXIgdGhhbiB0d28gaGVhZHMgbWVyZ2UuIikpOwoJCQlyZXR1cm4gMjsKCQl9CgoJCWluaXRfbWVyZ2Vfb3B0aW9ucygmbyk7CgkJaWYgKCFzdHJjbXAoc3RyYXRlZ3ksICJzdWJ0cmVlIikpCgkJCW8uc3VidHJlZV9zaGlmdCA9ICIiOwoKCQlvLnJlbm9ybWFsaXplID0gb3B0aW9uX3Jlbm9ybWFsaXplOwoJCW8uc2hvd19yZW5hbWVfcHJvZ3Jlc3MgPQoJCQlzaG93X3Byb2dyZXNzID09IC0xID8gaXNhdHR5KDIpIDogc2hvd19wcm9ncmVzczsKCgkJZm9yICh4ID0gMDsgeCA8IHhvcHRzX25yOyB4KyspCgkJCWlmIChwYXJzZV9tZXJnZV9vcHQoJm8sIHhvcHRzW3hdKSkKCQkJCWRpZShfKCJVbmtub3duIG9wdGlvbiBmb3IgbWVyZ2UtcmVjdXJzaXZlOiAtWCVzIiksIHhvcHRzW3hdKTsKCgkJby5icmFuY2gxID0gaGVhZF9hcmc7CgkJby5icmFuY2gyID0gbWVyZ2VfcmVtb3RlX3V0aWwocmVtb3RlaGVhZHMtPml0ZW0pLT5uYW1lOwoKCQlmb3IgKGogPSBjb21tb247IGo7IGogPSBqLT5uZXh0KQoJCQljb21taXRfbGlzdF9pbnNlcnQoai0+aXRlbSwgJnJldmVyc2VkKTsKCgkJaW5kZXhfZmQgPSBob2xkX2xvY2tlZF9pbmRleChsb2NrLCAxKTsKCQljbGVhbiA9IG1lcmdlX3JlY3Vyc2l2ZSgmbywgaGVhZCwKCQkJCXJlbW90ZWhlYWRzLT5pdGVtLCByZXZlcnNlZCwgJnJlc3VsdCk7CgkJaWYgKGFjdGl2ZV9jYWNoZV9jaGFuZ2VkICYmCgkJCQkod3JpdGVfY2FjaGUoaW5kZXhfZmQsIGFjdGl2ZV9jYWNoZSwgYWN0aXZlX25yKSB8fAoJCQkJIGNvbW1pdF9sb2NrZWRfaW5kZXgobG9jaykpKQoJCQlkaWUgKF8oInVuYWJsZSB0byB3cml0ZSAlcyIpLCBnZXRfaW5kZXhfZmlsZSgpKTsKCQlyb2xsYmFja19sb2NrX2ZpbGUobG9jayk7CgkJcmV0dXJuIGNsZWFuID8gMCA6IDE7Cgl9IGVsc2UgewoJCXJldHVybiB0cnlfbWVyZ2VfY29tbWFuZChzdHJhdGVneSwgeG9wdHNfbnIsIHhvcHRzLAoJCQkJCQljb21tb24sIGhlYWRfYXJnLCByZW1vdGVoZWFkcyk7Cgl9Cn0KCnN0YXRpYyB2b2lkIGNvdW50X2RpZmZfZmlsZXMoc3RydWN0IGRpZmZfcXVldWVfc3RydWN0ICpxLAoJCQkgICAgIHN0cnVjdCBkaWZmX29wdGlvbnMgKm9wdCwgdm9pZCAqZGF0YSkKewoJaW50ICpjb3VudCA9IGRhdGE7CgoJKCpjb3VudCkgKz0gcS0+bnI7Cn0KCnN0YXRpYyBpbnQgY291bnRfdW5tZXJnZWRfZW50cmllcyh2b2lkKQp7CglpbnQgaSwgcmV0ID0gMDsKCglmb3IgKGkgPSAwOyBpIDwgYWN0aXZlX25yOyBpKyspCgkJaWYgKGNlX3N0YWdlKGFjdGl2ZV9jYWNoZVtpXSkpCgkJCXJldCsrOwoKCXJldHVybiByZXQ7Cn0KCmludCBjaGVja291dF9mYXN0X2ZvcndhcmQoY29uc3QgdW5zaWduZWQgY2hhciAqaGVhZCwgY29uc3QgdW5zaWduZWQgY2hhciAqcmVtb3RlKQp7CglzdHJ1Y3QgdHJlZSAqdHJlZXNbTUFYX1VOUEFDS19UUkVFU107CglzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgb3B0czsKCXN0cnVjdCB0cmVlX2Rlc2MgdFtNQVhfVU5QQUNLX1RSRUVTXTsKCWludCBpLCBmZCwgbnJfdHJlZXMgPSAwOwoJc3RydWN0IGRpcl9zdHJ1Y3QgZGlyOwoJc3RydWN0IGxvY2tfZmlsZSAqbG9ja19maWxlID0geGNhbGxvYygxLCBzaXplb2Yoc3RydWN0IGxvY2tfZmlsZSkpOwoKCXJlZnJlc2hfY2FjaGUoUkVGUkVTSF9RVUlFVCk7CgoJZmQgPSBob2xkX2xvY2tlZF9pbmRleChsb2NrX2ZpbGUsIDEpOwoKCW1lbXNldCgmdHJlZXMsIDAsIHNpemVvZih0cmVlcykpOwoJbWVtc2V0KCZvcHRzLCAwLCBzaXplb2Yob3B0cykpOwoJbWVtc2V0KCZ0LCAwLCBzaXplb2YodCkpOwoJbWVtc2V0KCZkaXIsIDAsIHNpemVvZihkaXIpKTsKCWRpci5mbGFncyB8PSBESVJfU0hPV19JR05PUkVEOwoJZGlyLmV4Y2x1ZGVfcGVyX2RpciA9ICIuZ2l0aWdub3JlIjsKCW9wdHMuZGlyID0gJmRpcjsKCglvcHRzLmhlYWRfaWR4ID0gMTsKCW9wdHMuc3JjX2luZGV4ID0gJnRoZV9pbmRleDsKCW9wdHMuZHN0X2luZGV4ID0gJnRoZV9pbmRleDsKCW9wdHMudXBkYXRlID0gMTsKCW9wdHMudmVyYm9zZV91cGRhdGUgPSAxOwoJb3B0cy5tZXJnZSA9IDE7CglvcHRzLmZuID0gdHdvd2F5X21lcmdlOwoJc2V0dXBfdW5wYWNrX3RyZWVzX3BvcmNlbGFpbigmb3B0cywgIm1lcmdlIik7CgoJdHJlZXNbbnJfdHJlZXNdID0gcGFyc2VfdHJlZV9pbmRpcmVjdChoZWFkKTsKCWlmICghdHJlZXNbbnJfdHJlZXMrK10pCgkJcmV0dXJuIC0xOwoJdHJlZXNbbnJfdHJlZXNdID0gcGFyc2VfdHJlZV9pbmRpcmVjdChyZW1vdGUpOwoJaWYgKCF0cmVlc1tucl90cmVlcysrXSkKCQlyZXR1cm4gLTE7Cglmb3IgKGkgPSAwOyBpIDwgbnJfdHJlZXM7IGkrKykgewoJCXBhcnNlX3RyZWUodHJlZXNbaV0pOwoJCWluaXRfdHJlZV9kZXNjKHQraSwgdHJlZXNbaV0tPmJ1ZmZlciwgdHJlZXNbaV0tPnNpemUpOwoJfQoJaWYgKHVucGFja190cmVlcyhucl90cmVlcywgdCwgJm9wdHMpKQoJCXJldHVybiAtMTsKCWlmICh3cml0ZV9jYWNoZShmZCwgYWN0aXZlX2NhY2hlLCBhY3RpdmVfbnIpIHx8CgkJY29tbWl0X2xvY2tlZF9pbmRleChsb2NrX2ZpbGUpKQoJCWRpZShfKCJ1bmFibGUgdG8gd3JpdGUgbmV3IGluZGV4IGZpbGUiKSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgc3BsaXRfbWVyZ2Vfc3RyYXRlZ2llcyhjb25zdCBjaGFyICpzdHJpbmcsIHN0cnVjdCBzdHJhdGVneSAqKmxpc3QsCgkJCQkgICBpbnQgKm5yLCBpbnQgKmFsbG9jKQp7CgljaGFyICpwLCAqcSwgKmJ1ZjsKCglpZiAoIXN0cmluZykKCQlyZXR1cm47CgoJYnVmID0geHN0cmR1cChzdHJpbmcpOwoJcSA9IGJ1ZjsKCWZvciAoOzspIHsKCQlwID0gc3RyY2hyKHEsICcgJyk7CgkJaWYgKCFwKSB7CgkJCUFMTE9DX0dST1coKmxpc3QsICpuciArIDEsICphbGxvYyk7CgkJCSgqbGlzdClbKCpucikrK10ubmFtZSA9IHhzdHJkdXAocSk7CgkJCWZyZWUoYnVmKTsKCQkJcmV0dXJuOwoJCX0gZWxzZSB7CgkJCSpwID0gJ1wwJzsKCQkJQUxMT0NfR1JPVygqbGlzdCwgKm5yICsgMSwgKmFsbG9jKTsKCQkJKCpsaXN0KVsoKm5yKSsrXS5uYW1lID0geHN0cmR1cChxKTsKCQkJcSA9ICsrcDsKCQl9Cgl9Cn0KCnN0YXRpYyB2b2lkIGFkZF9zdHJhdGVnaWVzKGNvbnN0IGNoYXIgKnN0cmluZywgdW5zaWduZWQgYXR0cikKewoJc3RydWN0IHN0cmF0ZWd5ICpsaXN0ID0gTlVMTDsKCWludCBsaXN0X2FsbG9jID0gMCwgbGlzdF9uciA9IDAsIGk7CgoJbWVtc2V0KCZsaXN0LCAwLCBzaXplb2YobGlzdCkpOwoJc3BsaXRfbWVyZ2Vfc3RyYXRlZ2llcyhzdHJpbmcsICZsaXN0LCAmbGlzdF9uciwgJmxpc3RfYWxsb2MpOwoJaWYgKGxpc3QpIHsKCQlmb3IgKGkgPSAwOyBpIDwgbGlzdF9ucjsgaSsrKQoJCQlhcHBlbmRfc3RyYXRlZ3koZ2V0X3N0cmF0ZWd5KGxpc3RbaV0ubmFtZSkpOwoJCXJldHVybjsKCX0KCWZvciAoaSA9IDA7IGkgPCBBUlJBWV9TSVpFKGFsbF9zdHJhdGVneSk7IGkrKykKCQlpZiAoYWxsX3N0cmF0ZWd5W2ldLmF0dHIgJiBhdHRyKQoJCQlhcHBlbmRfc3RyYXRlZ3koJmFsbF9zdHJhdGVneVtpXSk7Cgp9CgpzdGF0aWMgdm9pZCB3cml0ZV9tZXJnZV9tc2coc3RydWN0IHN0cmJ1ZiAqbXNnKQp7CglpbnQgZmQgPSBvcGVuKGdpdF9wYXRoKCJNRVJHRV9NU0ciKSwgT19XUk9OTFkgfCBPX0NSRUFULCAwNjY2KTsKCWlmIChmZCA8IDApCgkJZGllX2Vycm5vKF8oIkNvdWxkIG5vdCBvcGVuICclcycgZm9yIHdyaXRpbmciKSwKCQkJICBnaXRfcGF0aCgiTUVSR0VfTVNHIikpOwoJaWYgKHdyaXRlX2luX2Z1bGwoZmQsIG1zZy0+YnVmLCBtc2ctPmxlbikgIT0gbXNnLT5sZW4pCgkJZGllX2Vycm5vKF8oIkNvdWxkIG5vdCB3cml0ZSB0byAnJXMnIiksIGdpdF9wYXRoKCJNRVJHRV9NU0ciKSk7CgljbG9zZShmZCk7Cn0KCnN0YXRpYyB2b2lkIHJlYWRfbWVyZ2VfbXNnKHN0cnVjdCBzdHJidWYgKm1zZykKewoJc3RyYnVmX3Jlc2V0KG1zZyk7CglpZiAoc3RyYnVmX3JlYWRfZmlsZShtc2csIGdpdF9wYXRoKCJNRVJHRV9NU0ciKSwgMCkgPCAwKQoJCWRpZV9lcnJubyhfKCJDb3VsZCBub3QgcmVhZCBmcm9tICclcyciKSwgZ2l0X3BhdGgoIk1FUkdFX01TRyIpKTsKfQoKc3RhdGljIHZvaWQgd3JpdGVfbWVyZ2Vfc3RhdGUodm9pZCk7CnN0YXRpYyB2b2lkIGFib3J0X2NvbW1pdChjb25zdCBjaGFyICplcnJfbXNnKQp7CglpZiAoZXJyX21zZykKCQllcnJvcigiJXMiLCBlcnJfbXNnKTsKCWZwcmludGYoc3RkZXJyLAoJCV8oIk5vdCBjb21taXR0aW5nIG1lcmdlOyB1c2UgJ2dpdCBjb21taXQnIHRvIGNvbXBsZXRlIHRoZSBtZXJnZS5cbiIpKTsKCXdyaXRlX21lcmdlX3N0YXRlKCk7CglleGl0KDEpOwp9CgpzdGF0aWMgdm9pZCBwcmVwYXJlX3RvX2NvbW1pdCh2b2lkKQp7CglzdHJ1Y3Qgc3RyYnVmIG1zZyA9IFNUUkJVRl9JTklUOwoJc3RyYnVmX2FkZGJ1ZigmbXNnLCAmbWVyZ2VfbXNnKTsKCXN0cmJ1Zl9hZGRjaCgmbXNnLCAnXG4nKTsKCXdyaXRlX21lcmdlX21zZygmbXNnKTsKCXJ1bl9ob29rKGdldF9pbmRleF9maWxlKCksICJwcmVwYXJlLWNvbW1pdC1tc2ciLAoJCSBnaXRfcGF0aCgiTUVSR0VfTVNHIiksICJtZXJnZSIsIE5VTEwsIE5VTEwpOwoJaWYgKDAgPCBvcHRpb25fZWRpdCkgewoJCWlmIChsYXVuY2hfZWRpdG9yKGdpdF9wYXRoKCJNRVJHRV9NU0ciKSwgTlVMTCwgTlVMTCkpCgkJCWFib3J0X2NvbW1pdChOVUxMKTsKCX0KCXJlYWRfbWVyZ2VfbXNnKCZtc2cpOwoJc3RyaXBzcGFjZSgmbXNnLCAwIDwgb3B0aW9uX2VkaXQpOwoJaWYgKCFtc2cubGVuKQoJCWFib3J0X2NvbW1pdChfKCJFbXB0eSBjb21taXQgbWVzc2FnZS4iKSk7CglzdHJidWZfcmVsZWFzZSgmbWVyZ2VfbXNnKTsKCXN0cmJ1Zl9hZGRidWYoJm1lcmdlX21zZywgJm1zZyk7CglzdHJidWZfcmVsZWFzZSgmbXNnKTsKfQoKc3RhdGljIGludCBtZXJnZV90cml2aWFsKHN0cnVjdCBjb21taXQgKmhlYWQpCnsKCXVuc2lnbmVkIGNoYXIgcmVzdWx0X3RyZWVbMjBdLCByZXN1bHRfY29tbWl0WzIwXTsKCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50ID0geG1hbGxvYyhzaXplb2YoKnBhcmVudCkpOwoKCXdyaXRlX3RyZWVfdHJpdmlhbChyZXN1bHRfdHJlZSk7CglwcmludGYoXygiV29uZGVyZnVsLlxuIikpOwoJcGFyZW50LT5pdGVtID0gaGVhZDsKCXBhcmVudC0+bmV4dCA9IHhtYWxsb2Moc2l6ZW9mKCpwYXJlbnQtPm5leHQpKTsKCXBhcmVudC0+bmV4dC0+aXRlbSA9IHJlbW90ZWhlYWRzLT5pdGVtOwoJcGFyZW50LT5uZXh0LT5uZXh0ID0gTlVMTDsKCXByZXBhcmVfdG9fY29tbWl0KCk7Cgljb21taXRfdHJlZShtZXJnZV9tc2cuYnVmLCByZXN1bHRfdHJlZSwgcGFyZW50LCByZXN1bHRfY29tbWl0LCBOVUxMKTsKCWZpbmlzaChoZWFkLCByZXN1bHRfY29tbWl0LCAiSW4taW5kZXggbWVyZ2UiKTsKCWRyb3Bfc2F2ZSgpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZmluaXNoX2F1dG9tZXJnZShzdHJ1Y3QgY29tbWl0ICpoZWFkLAoJCQkgICAgc3RydWN0IGNvbW1pdF9saXN0ICpjb21tb24sCgkJCSAgICB1bnNpZ25lZCBjaGFyICpyZXN1bHRfdHJlZSwKCQkJICAgIGNvbnN0IGNoYXIgKnd0X3N0cmF0ZWd5KQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMgPSBOVUxMLCAqajsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7Cgl1bnNpZ25lZCBjaGFyIHJlc3VsdF9jb21taXRbMjBdOwoKCWZyZWVfY29tbWl0X2xpc3QoY29tbW9uKTsKCWlmIChhbGxvd19mYXN0X2ZvcndhcmQpIHsKCQlwYXJlbnRzID0gcmVtb3RlaGVhZHM7CgkJY29tbWl0X2xpc3RfaW5zZXJ0KGhlYWQsICZwYXJlbnRzKTsKCQlwYXJlbnRzID0gcmVkdWNlX2hlYWRzKHBhcmVudHMpOwoJfSBlbHNlIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKipwcHRyID0gJnBhcmVudHM7CgoJCXBwdHIgPSAmY29tbWl0X2xpc3RfaW5zZXJ0KGhlYWQsCgkJCQlwcHRyKS0+bmV4dDsKCQlmb3IgKGogPSByZW1vdGVoZWFkczsgajsgaiA9IGotPm5leHQpCgkJCXBwdHIgPSAmY29tbWl0X2xpc3RfaW5zZXJ0KGotPml0ZW0sIHBwdHIpLT5uZXh0OwoJfQoJc3RyYnVmX2FkZGNoKCZtZXJnZV9tc2csICdcbicpOwoJcHJlcGFyZV90b19jb21taXQoKTsKCWZyZWVfY29tbWl0X2xpc3QocmVtb3RlaGVhZHMpOwoJY29tbWl0X3RyZWUobWVyZ2VfbXNnLmJ1ZiwgcmVzdWx0X3RyZWUsIHBhcmVudHMsIHJlc3VsdF9jb21taXQsIE5VTEwpOwoJc3RyYnVmX2FkZGYoJmJ1ZiwgIk1lcmdlIG1hZGUgYnkgdGhlICclcycgc3RyYXRlZ3kuIiwgd3Rfc3RyYXRlZ3kpOwoJZmluaXNoKGhlYWQsIHJlc3VsdF9jb21taXQsIGJ1Zi5idWYpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7Cglkcm9wX3NhdmUoKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHN1Z2dlc3RfY29uZmxpY3RzKGludCByZW5vcm1hbGl6aW5nKQp7CglGSUxFICpmcDsKCWludCBwb3M7CgoJZnAgPSBmb3BlbihnaXRfcGF0aCgiTUVSR0VfTVNHIiksICJhIik7CglpZiAoIWZwKQoJCWRpZV9lcnJubyhfKCJDb3VsZCBub3Qgb3BlbiAnJXMnIGZvciB3cml0aW5nIiksCgkJCSAgZ2l0X3BhdGgoIk1FUkdFX01TRyIpKTsKCWZwcmludGYoZnAsICJcbkNvbmZsaWN0czpcbiIpOwoJZm9yIChwb3MgPSAwOyBwb3MgPCBhY3RpdmVfbnI7IHBvcysrKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGFjdGl2ZV9jYWNoZVtwb3NdOwoKCQlpZiAoY2Vfc3RhZ2UoY2UpKSB7CgkJCWZwcmludGYoZnAsICJcdCVzXG4iLCBjZS0+bmFtZSk7CgkJCXdoaWxlIChwb3MgKyAxIDwgYWN0aXZlX25yICYmCgkJCQkJIXN0cmNtcChjZS0+bmFtZSwKCQkJCQkJYWN0aXZlX2NhY2hlW3BvcyArIDFdLT5uYW1lKSkKCQkJCXBvcysrOwoJCX0KCX0KCWZjbG9zZShmcCk7CglyZXJlcmUoYWxsb3dfcmVyZXJlX2F1dG8pOwoJcHJpbnRmKF8oIkF1dG9tYXRpYyBtZXJnZSBmYWlsZWQ7ICIKCQkJImZpeCBjb25mbGljdHMgYW5kIHRoZW4gY29tbWl0IHRoZSByZXN1bHQuXG4iKSk7CglyZXR1cm4gMTsKfQoKc3RhdGljIHN0cnVjdCBjb21taXQgKmlzX29sZF9zdHlsZV9pbnZvY2F0aW9uKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwKCQkJCQkgICAgICBjb25zdCB1bnNpZ25lZCBjaGFyICpoZWFkKQp7CglzdHJ1Y3QgY29tbWl0ICpzZWNvbmRfdG9rZW4gPSBOVUxMOwoJaWYgKGFyZ2MgPiAyKSB7CgkJdW5zaWduZWQgY2hhciBzZWNvbmRfc2hhMVsyMF07CgoJCWlmIChnZXRfc2hhMShhcmd2WzFdLCBzZWNvbmRfc2hhMSkpCgkJCXJldHVybiBOVUxMOwoJCXNlY29uZF90b2tlbiA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseShzZWNvbmRfc2hhMSwgMCk7CgkJaWYgKCFzZWNvbmRfdG9rZW4pCgkJCWRpZShfKCInJXMnIGlzIG5vdCBhIGNvbW1pdCIpLCBhcmd2WzFdKTsKCQlpZiAoaGFzaGNtcChzZWNvbmRfdG9rZW4tPm9iamVjdC5zaGExLCBoZWFkKSkKCQkJcmV0dXJuIE5VTEw7Cgl9CglyZXR1cm4gc2Vjb25kX3Rva2VuOwp9CgpzdGF0aWMgaW50IGV2YWx1YXRlX3Jlc3VsdCh2b2lkKQp7CglpbnQgY250ID0gMDsKCXN0cnVjdCByZXZfaW5mbyByZXY7CgoJLyogQ2hlY2sgaG93IG1hbnkgZmlsZXMgZGlmZmVyLiAqLwoJaW5pdF9yZXZpc2lvbnMoJnJldiwgIiIpOwoJc2V0dXBfcmV2aXNpb25zKDAsIE5VTEwsICZyZXYsIE5VTEwpOwoJcmV2LmRpZmZvcHQub3V0cHV0X2Zvcm1hdCB8PQoJCURJRkZfRk9STUFUX0NBTExCQUNLOwoJcmV2LmRpZmZvcHQuZm9ybWF0X2NhbGxiYWNrID0gY291bnRfZGlmZl9maWxlczsKCXJldi5kaWZmb3B0LmZvcm1hdF9jYWxsYmFja19kYXRhID0gJmNudDsKCXJ1bl9kaWZmX2ZpbGVzKCZyZXYsIDApOwoKCS8qCgkgKiBDaGVjayBob3cgbWFueSB1bm1lcmdlZCBlbnRyaWVzIGFyZQoJICogdGhlcmUuCgkgKi8KCWNudCArPSBjb3VudF91bm1lcmdlZF9lbnRyaWVzKCk7CgoJcmV0dXJuIGNudDsKfQoKLyoKICogUHJldGVuZCBhcyBpZiB0aGUgdXNlciB0b2xkIHVzIHRvIG1lcmdlIHdpdGggdGhlIHRyYWNraW5nCiAqIGJyYW5jaCB3ZSBoYXZlIGZvciB0aGUgdXBzdHJlYW0gb2YgdGhlIGN1cnJlbnQgYnJhbmNoCiAqLwpzdGF0aWMgaW50IHNldHVwX3dpdGhfdXBzdHJlYW0oY29uc3QgY2hhciAqKiphcmd2KQp7CglzdHJ1Y3QgYnJhbmNoICpicmFuY2ggPSBicmFuY2hfZ2V0KE5VTEwpOwoJaW50IGk7Cgljb25zdCBjaGFyICoqYXJnczsKCglpZiAoIWJyYW5jaCkKCQlkaWUoXygiTm8gY3VycmVudCBicmFuY2guIikpOwoJaWYgKCFicmFuY2gtPnJlbW90ZSkKCQlkaWUoXygiTm8gcmVtb3RlIGZvciB0aGUgY3VycmVudCBicmFuY2guIikpOwoJaWYgKCFicmFuY2gtPm1lcmdlX25yKQoJCWRpZShfKCJObyBkZWZhdWx0IHVwc3RyZWFtIGRlZmluZWQgZm9yIHRoZSBjdXJyZW50IGJyYW5jaC4iKSk7CgoJYXJncyA9IHhjYWxsb2MoYnJhbmNoLT5tZXJnZV9uciArIDEsIHNpemVvZihjaGFyICopKTsKCWZvciAoaSA9IDA7IGkgPCBicmFuY2gtPm1lcmdlX25yOyBpKyspIHsKCQlpZiAoIWJyYW5jaC0+bWVyZ2VbaV0tPmRzdCkKCQkJZGllKF8oIk5vIHJlbW90ZSB0cmFja2luZyBicmFuY2ggZm9yICVzIGZyb20gJXMiKSwKCQkJICAgIGJyYW5jaC0+bWVyZ2VbaV0tPnNyYywgYnJhbmNoLT5yZW1vdGVfbmFtZSk7CgkJYXJnc1tpXSA9IGJyYW5jaC0+bWVyZ2VbaV0tPmRzdDsKCX0KCWFyZ3NbaV0gPSBOVUxMOwoJKmFyZ3YgPSBhcmdzOwoJcmV0dXJuIGk7Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX21lcmdlX3N0YXRlKHZvaWQpCnsKCWludCBmZDsKCXN0cnVjdCBjb21taXRfbGlzdCAqajsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJZm9yIChqID0gcmVtb3RlaGVhZHM7IGo7IGogPSBqLT5uZXh0KSB7CgkJdW5zaWduZWQgY29uc3QgY2hhciAqc2hhMTsKCQlzdHJ1Y3QgY29tbWl0ICpjID0gai0+aXRlbTsKCQlpZiAoYy0+dXRpbCAmJiBtZXJnZV9yZW1vdGVfdXRpbChjKS0+b2JqKSB7CgkJCXNoYTEgPSBtZXJnZV9yZW1vdGVfdXRpbChjKS0+b2JqLT5zaGExOwoJCX0gZWxzZSB7CgkJCXNoYTEgPSBjLT5vYmplY3Quc2hhMTsKCQl9CgkJc3RyYnVmX2FkZGYoJmJ1ZiwgIiVzXG4iLCBzaGExX3RvX2hleChzaGExKSk7Cgl9CglmZCA9IG9wZW4oZ2l0X3BhdGgoIk1FUkdFX0hFQUQiKSwgT19XUk9OTFkgfCBPX0NSRUFULCAwNjY2KTsKCWlmIChmZCA8IDApCgkJZGllX2Vycm5vKF8oIkNvdWxkIG5vdCBvcGVuICclcycgZm9yIHdyaXRpbmciKSwKCQkJICBnaXRfcGF0aCgiTUVSR0VfSEVBRCIpKTsKCWlmICh3cml0ZV9pbl9mdWxsKGZkLCBidWYuYnVmLCBidWYubGVuKSAhPSBidWYubGVuKQoJCWRpZV9lcnJubyhfKCJDb3VsZCBub3Qgd3JpdGUgdG8gJyVzJyIpLCBnaXRfcGF0aCgiTUVSR0VfSEVBRCIpKTsKCWNsb3NlKGZkKTsKCXN0cmJ1Zl9hZGRjaCgmbWVyZ2VfbXNnLCAnXG4nKTsKCXdyaXRlX21lcmdlX21zZygmbWVyZ2VfbXNnKTsKCWZkID0gb3BlbihnaXRfcGF0aCgiTUVSR0VfTU9ERSIpLCBPX1dST05MWSB8IE9fQ1JFQVQgfCBPX1RSVU5DLCAwNjY2KTsKCWlmIChmZCA8IDApCgkJZGllX2Vycm5vKF8oIkNvdWxkIG5vdCBvcGVuICclcycgZm9yIHdyaXRpbmciKSwKCQkJICBnaXRfcGF0aCgiTUVSR0VfTU9ERSIpKTsKCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCWlmICghYWxsb3dfZmFzdF9mb3J3YXJkKQoJCXN0cmJ1Zl9hZGRmKCZidWYsICJuby1mZiIpOwoJaWYgKHdyaXRlX2luX2Z1bGwoZmQsIGJ1Zi5idWYsIGJ1Zi5sZW4pICE9IGJ1Zi5sZW4pCgkJZGllX2Vycm5vKF8oIkNvdWxkIG5vdCB3cml0ZSB0byAnJXMnIiksIGdpdF9wYXRoKCJNRVJHRV9NT0RFIikpOwoJY2xvc2UoZmQpOwp9CgpzdGF0aWMgaW50IGRlZmF1bHRfZWRpdF9vcHRpb24odm9pZCkKewoJc3RhdGljIGNvbnN0IGNoYXIgbmFtZVtdID0gIkdJVF9NRVJHRV9BVVRPRURJVCI7Cgljb25zdCBjaGFyICplID0gZ2V0ZW52KG5hbWUpOwoJc3RydWN0IHN0YXQgc3Rfc3RkaW4sIHN0X3N0ZG91dDsKCglpZiAoaGF2ZV9tZXNzYWdlKQoJCS8qIGFuIGV4cGxpY2l0IC1tIG1zZyB3aXRob3V0IC0tW25vLV1lZGl0ICovCgkJcmV0dXJuIDA7CgoJaWYgKGUpIHsKCQlpbnQgdiA9IGdpdF9jb25maWdfbWF5YmVfYm9vbChuYW1lLCBlKTsKCQlpZiAodiA8IDApCgkJCWRpZSgiQmFkIHZhbHVlICclcycgaW4gZW52aXJvbm1lbnQgJyVzJyIsIGUsIG5hbWUpOwoJCXJldHVybiB2OwoJfQoKCS8qIFVzZSBlZGl0b3IgaWYgc3RkaW4gYW5kIHN0ZG91dCBhcmUgdGhlIHNhbWUgYW5kIGlzIGEgdHR5ICovCglyZXR1cm4gKCFmc3RhdCgwLCAmc3Rfc3RkaW4pICYmCgkJIWZzdGF0KDEsICZzdF9zdGRvdXQpICYmCgkJaXNhdHR5KDApICYmCgkJc3Rfc3RkaW4uc3RfZGV2ID09IHN0X3N0ZG91dC5zdF9kZXYgJiYKCQlzdF9zdGRpbi5zdF9pbm8gPT0gc3Rfc3Rkb3V0LnN0X2lubyAmJgoJCXN0X3N0ZGluLnN0X21vZGUgPT0gc3Rfc3Rkb3V0LnN0X21vZGUpOwp9CgoKaW50IGNtZF9tZXJnZShpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJdW5zaWduZWQgY2hhciByZXN1bHRfdHJlZVsyMF07Cgl1bnNpZ25lZCBjaGFyIHN0YXNoWzIwXTsKCXVuc2lnbmVkIGNoYXIgaGVhZF9zaGExWzIwXTsKCXN0cnVjdCBjb21taXQgKmhlYWRfY29tbWl0OwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKmhlYWRfYXJnOwoJaW50IGZsYWcsIGk7CglpbnQgYmVzdF9jbnQgPSAtMSwgbWVyZ2Vfd2FzX29rID0gMCwgYXV0b21lcmdlX3dhc19vayA9IDA7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKmNvbW1vbiA9IE5VTEw7Cgljb25zdCBjaGFyICpiZXN0X3N0cmF0ZWd5ID0gTlVMTCwgKnd0X3N0cmF0ZWd5ID0gTlVMTDsKCXN0cnVjdCBjb21taXRfbGlzdCAqKnJlbW90ZXMgPSAmcmVtb3RlaGVhZHM7CgoJaWYgKGFyZ2MgPT0gMiAmJiAhc3RyY21wKGFyZ3ZbMV0sICItaCIpKQoJCXVzYWdlX3dpdGhfb3B0aW9ucyhidWlsdGluX21lcmdlX3VzYWdlLCBidWlsdGluX21lcmdlX29wdGlvbnMpOwoKCS8qCgkgKiBDaGVjayBpZiB3ZSBhcmUgX25vdF8gb24gYSBkZXRhY2hlZCBIRUFELCBpLmUuIGlmIHRoZXJlIGlzIGEKCSAqIGN1cnJlbnQgYnJhbmNoLgoJICovCglicmFuY2ggPSByZXNvbHZlX3JlZigiSEVBRCIsIGhlYWRfc2hhMSwgMCwgJmZsYWcpOwoJaWYgKGJyYW5jaCAmJiAhcHJlZml4Y21wKGJyYW5jaCwgInJlZnMvaGVhZHMvIikpCgkJYnJhbmNoICs9IDExOwoJaWYgKCFicmFuY2ggfHwgaXNfbnVsbF9zaGExKGhlYWRfc2hhMSkpCgkJaGVhZF9jb21taXQgPSBOVUxMOwoJZWxzZQoJCWhlYWRfY29tbWl0ID0gbG9va3VwX2NvbW1pdF9vcl9kaWUoaGVhZF9zaGExLCAiSEVBRCIpOwoKCWdpdF9jb25maWcoZ2l0X21lcmdlX2NvbmZpZywgTlVMTCk7CgoJaWYgKGJyYW5jaF9tZXJnZW9wdGlvbnMpCgkJcGFyc2VfYnJhbmNoX21lcmdlX29wdGlvbnMoYnJhbmNoX21lcmdlb3B0aW9ucyk7CglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIGJ1aWx0aW5fbWVyZ2Vfb3B0aW9ucywKCQkJYnVpbHRpbl9tZXJnZV91c2FnZSwgMCk7CgoJaWYgKHZlcmJvc2l0eSA8IDAgJiYgc2hvd19wcm9ncmVzcyA9PSAtMSkKCQlzaG93X3Byb2dyZXNzID0gMDsKCglpZiAoYWJvcnRfY3VycmVudF9tZXJnZSkgewoJCWludCBuYXJnYyA9IDI7CgkJY29uc3QgY2hhciAqbmFyZ3ZbXSA9IHsicmVzZXQiLCAiLS1tZXJnZSIsIE5VTEx9OwoKCQlpZiAoIWZpbGVfZXhpc3RzKGdpdF9wYXRoKCJNRVJHRV9IRUFEIikpKQoJCQlkaWUoXygiVGhlcmUgaXMgbm8gbWVyZ2UgdG8gYWJvcnQgKE1FUkdFX0hFQUQgbWlzc2luZykuIikpOwoKCQkvKiBJbnZva2UgJ2dpdCByZXNldCAtLW1lcmdlJyAqLwoJCXJldHVybiBjbWRfcmVzZXQobmFyZ2MsIG5hcmd2LCBwcmVmaXgpOwoJfQoKCWlmIChyZWFkX2NhY2hlX3VubWVyZ2VkKCkpCgkJZGllX3Jlc29sdmVfY29uZmxpY3QoIm1lcmdlIik7CgoJaWYgKGZpbGVfZXhpc3RzKGdpdF9wYXRoKCJNRVJHRV9IRUFEIikpKSB7CgkJLyoKCQkgKiBUaGVyZSBpcyBubyB1bm1lcmdlZCBlbnRyeSwgZG9uJ3QgYWR2aXNlICdnaXQKCQkgKiBhZGQvcm0gPGZpbGU+JywganVzdCAnZ2l0IGNvbW1pdCcuCgkJICovCgkJaWYgKGFkdmljZV9yZXNvbHZlX2NvbmZsaWN0KQoJCQlkaWUoXygiWW91IGhhdmUgbm90IGNvbmNsdWRlZCB5b3VyIG1lcmdlIChNRVJHRV9IRUFEIGV4aXN0cykuXG4iCgkJCQkgICJQbGVhc2UsIGNvbW1pdCB5b3VyIGNoYW5nZXMgYmVmb3JlIHlvdSBjYW4gbWVyZ2UuIikpOwoJCWVsc2UKCQkJZGllKF8oIllvdSBoYXZlIG5vdCBjb25jbHVkZWQgeW91ciBtZXJnZSAoTUVSR0VfSEVBRCBleGlzdHMpLiIpKTsKCX0KCWlmIChmaWxlX2V4aXN0cyhnaXRfcGF0aCgiQ0hFUlJZX1BJQ0tfSEVBRCIpKSkgewoJCWlmIChhZHZpY2VfcmVzb2x2ZV9jb25mbGljdCkKCQkJZGllKF8oIllvdSBoYXZlIG5vdCBjb25jbHVkZWQgeW91ciBjaGVycnktcGljayAoQ0hFUlJZX1BJQ0tfSEVBRCBleGlzdHMpLlxuIgoJCQkgICAgIlBsZWFzZSwgY29tbWl0IHlvdXIgY2hhbmdlcyBiZWZvcmUgeW91IGNhbiBtZXJnZS4iKSk7CgkJZWxzZQoJCQlkaWUoXygiWW91IGhhdmUgbm90IGNvbmNsdWRlZCB5b3VyIGNoZXJyeS1waWNrIChDSEVSUllfUElDS19IRUFEIGV4aXN0cykuIikpOwoJfQoJcmVzb2x2ZV91bmRvX2NsZWFyKCk7CgoJaWYgKHZlcmJvc2l0eSA8IDApCgkJc2hvd19kaWZmc3RhdCA9IDA7CgoJaWYgKHNxdWFzaCkgewoJCWlmICghYWxsb3dfZmFzdF9mb3J3YXJkKQoJCQlkaWUoXygiWW91IGNhbm5vdCBjb21iaW5lIC0tc3F1YXNoIHdpdGggLS1uby1mZi4iKSk7CgkJb3B0aW9uX2NvbW1pdCA9IDA7Cgl9CgoJaWYgKCFhbGxvd19mYXN0X2ZvcndhcmQgJiYgZmFzdF9mb3J3YXJkX29ubHkpCgkJZGllKF8oIllvdSBjYW5ub3QgY29tYmluZSAtLW5vLWZmIHdpdGggLS1mZi1vbmx5LiIpKTsKCglpZiAoIWFib3J0X2N1cnJlbnRfbWVyZ2UpIHsKCQlpZiAoIWFyZ2MgJiYgZGVmYXVsdF90b191cHN0cmVhbSkKCQkJYXJnYyA9IHNldHVwX3dpdGhfdXBzdHJlYW0oJmFyZ3YpOwoJCWVsc2UgaWYgKGFyZ2MgPT0gMSAmJiAhc3RyY21wKGFyZ3ZbMF0sICItIikpCgkJCWFyZ3ZbMF0gPSAiQHstMX0iOwoJfQoJaWYgKCFhcmdjKQoJCXVzYWdlX3dpdGhfb3B0aW9ucyhidWlsdGluX21lcmdlX3VzYWdlLAoJCQlidWlsdGluX21lcmdlX29wdGlvbnMpOwoKCS8qCgkgKiBUaGlzIGNvdWxkIGJlIHRyYWRpdGlvbmFsICJtZXJnZSA8bXNnPiBIRUFEIDxjb21taXQ+Li4uIiAgYW5kCgkgKiB0aGUgd2F5IHdlIGNhbiB0ZWxsIGl0IGlzIHRvIHNlZSBpZiB0aGUgc2Vjb25kIHRva2VuIGlzIEhFQUQsCgkgKiBidXQgc29tZSBwZW9wbGUgbWlnaHQgaGF2ZSBtaXN1c2VkIHRoZSBpbnRlcmZhY2UgYW5kIHVzZWQgYQoJICogY29tbWl0dGlzaCB0aGF0IGlzIHRoZSBzYW1lIGFzIEhFQUQgdGhlcmUgaW5zdGVhZC4KCSAqIFRyYWRpdGlvbmFsIGZvcm1hdCBuZXZlciB3b3VsZCBoYXZlICItbSIgc28gaXQgaXMgYW4KCSAqIGFkZGl0aW9uYWwgc2FmZXR5IG1lYXN1cmUgdG8gY2hlY2sgZm9yIGl0LgoJICovCgoJaWYgKCFoYXZlX21lc3NhZ2UgJiYgaGVhZF9jb21taXQgJiYKCSAgICBpc19vbGRfc3R5bGVfaW52b2NhdGlvbihhcmdjLCBhcmd2LCBoZWFkX2NvbW1pdC0+b2JqZWN0LnNoYTEpKSB7CgkJc3RyYnVmX2FkZHN0cigmbWVyZ2VfbXNnLCBhcmd2WzBdKTsKCQloZWFkX2FyZyA9IGFyZ3ZbMV07CgkJYXJndiArPSAyOwoJCWFyZ2MgLT0gMjsKCX0gZWxzZSBpZiAoIWhlYWRfY29tbWl0KSB7CgkJc3RydWN0IGNvbW1pdCAqcmVtb3RlX2hlYWQ7CgkJLyoKCQkgKiBJZiB0aGUgbWVyZ2VkIGhlYWQgaXMgYSB2YWxpZCBvbmUgdGhlcmUgaXMgbm8gcmVhc29uCgkJICogdG8gZm9yYmlkICJnaXQgbWVyZ2UiIGludG8gYSBicmFuY2ggeWV0IHRvIGJlIGJvcm4uCgkJICogV2UgZG8gdGhlIHNhbWUgZm9yICJnaXQgcHVsbCIuCgkJICovCgkJaWYgKGFyZ2MgIT0gMSkKCQkJZGllKF8oIkNhbiBtZXJnZSBvbmx5IGV4YWN0bHkgb25lIGNvbW1pdCBpbnRvICIKCQkJCSJlbXB0eSBoZWFkIikpOwoJCWlmIChzcXVhc2gpCgkJCWRpZShfKCJTcXVhc2ggY29tbWl0IGludG8gZW1wdHkgaGVhZCBub3Qgc3VwcG9ydGVkIHlldCIpKTsKCQlpZiAoIWFsbG93X2Zhc3RfZm9yd2FyZCkKCQkJZGllKF8oIk5vbi1mYXN0LWZvcndhcmQgY29tbWl0IGRvZXMgbm90IG1ha2Ugc2Vuc2UgaW50byAiCgkJCSAgICAiYW4gZW1wdHkgaGVhZCIpKTsKCQlyZW1vdGVfaGVhZCA9IGdldF9tZXJnZV9wYXJlbnQoYXJndlswXSk7CgkJaWYgKCFyZW1vdGVfaGVhZCkKCQkJZGllKF8oIiVzIC0gbm90IHNvbWV0aGluZyB3ZSBjYW4gbWVyZ2UiKSwgYXJndlswXSk7CgkJcmVhZF9lbXB0eShyZW1vdGVfaGVhZC0+b2JqZWN0LnNoYTEsIDApOwoJCXVwZGF0ZV9yZWYoImluaXRpYWwgcHVsbCIsICJIRUFEIiwgcmVtb3RlX2hlYWQtPm9iamVjdC5zaGExLAoJCQkgICBOVUxMLCAwLCBESUVfT05fRVJSKTsKCQlyZXR1cm4gMDsKCX0gZWxzZSB7CgkJc3RydWN0IHN0cmJ1ZiBtZXJnZV9uYW1lcyA9IFNUUkJVRl9JTklUOwoKCQkvKiBXZSBhcmUgaW52b2tlZCBkaXJlY3RseSBhcyB0aGUgZmlyc3QtY2xhc3MgVUkuICovCgkJaGVhZF9hcmcgPSAiSEVBRCI7CgoJCS8qCgkJICogQWxsIHRoZSByZXN0IGFyZSB0aGUgY29tbWl0cyBiZWluZyBtZXJnZWQ7IHByZXBhcmUKCQkgKiB0aGUgc3RhbmRhcmQgbWVyZ2Ugc3VtbWFyeSBtZXNzYWdlIHRvIGJlIGFwcGVuZGVkCgkJICogdG8gdGhlIGdpdmVuIG1lc3NhZ2UuCgkJICovCgkJZm9yIChpID0gMDsgaSA8IGFyZ2M7IGkrKykKCQkJbWVyZ2VfbmFtZShhcmd2W2ldLCAmbWVyZ2VfbmFtZXMpOwoKCQlpZiAoIWhhdmVfbWVzc2FnZSB8fCBzaG9ydGxvZ19sZW4pIHsKCQkJc3RydWN0IGZtdF9tZXJnZV9tc2dfb3B0cyBvcHRzOwoJCQltZW1zZXQoJm9wdHMsIDAsIHNpemVvZihvcHRzKSk7CgkJCW9wdHMuYWRkX3RpdGxlID0gIWhhdmVfbWVzc2FnZTsKCQkJb3B0cy5zaG9ydGxvZ19sZW4gPSBzaG9ydGxvZ19sZW47CgoJCQlmbXRfbWVyZ2VfbXNnKCZtZXJnZV9uYW1lcywgJm1lcmdlX21zZywgJm9wdHMpOwoJCQlpZiAobWVyZ2VfbXNnLmxlbikKCQkJCXN0cmJ1Zl9zZXRsZW4oJm1lcmdlX21zZywgbWVyZ2VfbXNnLmxlbiAtIDEpOwoJCX0KCX0KCglpZiAoIWhlYWRfY29tbWl0IHx8ICFhcmdjKQoJCXVzYWdlX3dpdGhfb3B0aW9ucyhidWlsdGluX21lcmdlX3VzYWdlLAoJCQlidWlsdGluX21lcmdlX29wdGlvbnMpOwoKCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgIm1lcmdlIik7Cglmb3IgKGkgPSAwOyBpIDwgYXJnYzsgaSsrKQoJCXN0cmJ1Zl9hZGRmKCZidWYsICIgJXMiLCBhcmd2W2ldKTsKCXNldGVudigiR0lUX1JFRkxPR19BQ1RJT04iLCBidWYuYnVmLCAwKTsKCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCglmb3IgKGkgPSAwOyBpIDwgYXJnYzsgaSsrKSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gZ2V0X21lcmdlX3BhcmVudChhcmd2W2ldKTsKCQlpZiAoIWNvbW1pdCkKCQkJZGllKF8oIiVzIC0gbm90IHNvbWV0aGluZyB3ZSBjYW4gbWVyZ2UiKSwgYXJndltpXSk7CgkJcmVtb3RlcyA9ICZjb21taXRfbGlzdF9pbnNlcnQoY29tbWl0LCByZW1vdGVzKS0+bmV4dDsKCQlzdHJidWZfYWRkZigmYnVmLCAiR0lUSEVBRF8lcyIsCgkJCSAgICBzaGExX3RvX2hleChjb21taXQtPm9iamVjdC5zaGExKSk7CgkJc2V0ZW52KGJ1Zi5idWYsIGFyZ3ZbaV0sIDEpOwoJCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCQlpZiAobWVyZ2VfcmVtb3RlX3V0aWwoY29tbWl0KSAmJgoJCSAgICBtZXJnZV9yZW1vdGVfdXRpbChjb21taXQpLT5vYmogJiYKCQkgICAgbWVyZ2VfcmVtb3RlX3V0aWwoY29tbWl0KS0+b2JqLT50eXBlID09IE9CSl9UQUcpIHsKCQkJb3B0aW9uX2VkaXQgPSAxOwoJCQlhbGxvd19mYXN0X2ZvcndhcmQgPSAwOwoJCX0KCX0KCglpZiAob3B0aW9uX2VkaXQgPCAwKQoJCW9wdGlvbl9lZGl0ID0gZGVmYXVsdF9lZGl0X29wdGlvbigpOwoKCWlmICghdXNlX3N0cmF0ZWdpZXMpIHsKCQlpZiAoIXJlbW90ZWhlYWRzLT5uZXh0KQoJCQlhZGRfc3RyYXRlZ2llcyhwdWxsX3R3b2hlYWQsIERFRkFVTFRfVFdPSEVBRCk7CgkJZWxzZQoJCQlhZGRfc3RyYXRlZ2llcyhwdWxsX29jdG9wdXMsIERFRkFVTFRfT0NUT1BVUyk7Cgl9CgoJZm9yIChpID0gMDsgaSA8IHVzZV9zdHJhdGVnaWVzX25yOyBpKyspIHsKCQlpZiAodXNlX3N0cmF0ZWdpZXNbaV0tPmF0dHIgJiBOT19GQVNUX0ZPUldBUkQpCgkJCWFsbG93X2Zhc3RfZm9yd2FyZCA9IDA7CgkJaWYgKHVzZV9zdHJhdGVnaWVzW2ldLT5hdHRyICYgTk9fVFJJVklBTCkKCQkJYWxsb3dfdHJpdmlhbCA9IDA7Cgl9CgoJaWYgKCFyZW1vdGVoZWFkcy0+bmV4dCkKCQljb21tb24gPSBnZXRfbWVyZ2VfYmFzZXMoaGVhZF9jb21taXQsIHJlbW90ZWhlYWRzLT5pdGVtLCAxKTsKCWVsc2UgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCA9IHJlbW90ZWhlYWRzOwoJCWNvbW1pdF9saXN0X2luc2VydChoZWFkX2NvbW1pdCwgJmxpc3QpOwoJCWNvbW1vbiA9IGdldF9vY3RvcHVzX21lcmdlX2Jhc2VzKGxpc3QpOwoJCWZyZWUobGlzdCk7Cgl9CgoJdXBkYXRlX3JlZigidXBkYXRpbmcgT1JJR19IRUFEIiwgIk9SSUdfSEVBRCIsIGhlYWRfY29tbWl0LT5vYmplY3Quc2hhMSwKCQkgICBOVUxMLCAwLCBESUVfT05fRVJSKTsKCglpZiAoIWNvbW1vbikKCQk7IC8qIE5vIGNvbW1vbiBhbmNlc3RvcnMgZm91bmQuIFdlIG5lZWQgYSByZWFsIG1lcmdlLiAqLwoJZWxzZSBpZiAoIXJlbW90ZWhlYWRzLT5uZXh0ICYmICFjb21tb24tPm5leHQgJiYKCQkJY29tbW9uLT5pdGVtID09IHJlbW90ZWhlYWRzLT5pdGVtKSB7CgkJLyoKCQkgKiBJZiBoZWFkIGNhbiByZWFjaCBhbGwgdGhlIG1lcmdlIHRoZW4gd2UgYXJlIHVwIHRvIGRhdGUuCgkJICogYnV0IGZpcnN0IHRoZSBtb3N0IGNvbW1vbiBjYXNlIG9mIG1lcmdpbmcgb25lIHJlbW90ZS4KCQkgKi8KCQlmaW5pc2hfdXBfdG9fZGF0ZSgiQWxyZWFkeSB1cC10by1kYXRlLiIpOwoJCXJldHVybiAwOwoJfSBlbHNlIGlmIChhbGxvd19mYXN0X2ZvcndhcmQgJiYgIXJlbW90ZWhlYWRzLT5uZXh0ICYmCgkJCSFjb21tb24tPm5leHQgJiYKCQkJIWhhc2hjbXAoY29tbW9uLT5pdGVtLT5vYmplY3Quc2hhMSwgaGVhZF9jb21taXQtPm9iamVjdC5zaGExKSkgewoJCS8qIEFnYWluIHRoZSBtb3N0IGNvbW1vbiBjYXNlIG9mIG1lcmdpbmcgb25lIHJlbW90ZS4gKi8KCQlzdHJ1Y3Qgc3RyYnVmIG1zZyA9IFNUUkJVRl9JTklUOwoJCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCQljaGFyIGhleFs0MV07CgoJCXN0cmNweShoZXgsIGZpbmRfdW5pcXVlX2FiYnJldihoZWFkX2NvbW1pdC0+b2JqZWN0LnNoYTEsIERFRkFVTFRfQUJCUkVWKSk7CgoJCWlmICh2ZXJib3NpdHkgPj0gMCkKCQkJcHJpbnRmKF8oIlVwZGF0aW5nICVzLi4lc1xuIiksCgkJCQloZXgsCgkJCQlmaW5kX3VuaXF1ZV9hYmJyZXYocmVtb3RlaGVhZHMtPml0ZW0tPm9iamVjdC5zaGExLAoJCQkJREVGQVVMVF9BQkJSRVYpKTsKCQlzdHJidWZfYWRkc3RyKCZtc2csICJGYXN0LWZvcndhcmQiKTsKCQlpZiAoaGF2ZV9tZXNzYWdlKQoJCQlzdHJidWZfYWRkc3RyKCZtc2csCgkJCQkiIChubyBjb21taXQgY3JlYXRlZDsgLW0gb3B0aW9uIGlnbm9yZWQpIik7CgkJY29tbWl0ID0gcmVtb3RlaGVhZHMtPml0ZW07CgkJaWYgKCFjb21taXQpCgkJCXJldHVybiAxOwoKCQlpZiAoY2hlY2tvdXRfZmFzdF9mb3J3YXJkKGhlYWRfY29tbWl0LT5vYmplY3Quc2hhMSwKCQkJCQkgIGNvbW1pdC0+b2JqZWN0LnNoYTEpKQoJCQlyZXR1cm4gMTsKCgkJZmluaXNoKGhlYWRfY29tbWl0LCBjb21taXQtPm9iamVjdC5zaGExLCBtc2cuYnVmKTsKCQlkcm9wX3NhdmUoKTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXJlbW90ZWhlYWRzLT5uZXh0ICYmIGNvbW1vbi0+bmV4dCkKCQk7CgkJLyoKCQkgKiBXZSBhcmUgbm90IGRvaW5nIG9jdG9wdXMgYW5kIG5vdCBmYXN0LWZvcndhcmQuICBOZWVkCgkJICogYSByZWFsIG1lcmdlLgoJCSAqLwoJZWxzZSBpZiAoIXJlbW90ZWhlYWRzLT5uZXh0ICYmICFjb21tb24tPm5leHQgJiYgb3B0aW9uX2NvbW1pdCkgewoJCS8qCgkJICogV2UgYXJlIG5vdCBkb2luZyBvY3RvcHVzLCBub3QgZmFzdC1mb3J3YXJkLCBhbmQgaGF2ZQoJCSAqIG9ubHkgb25lIGNvbW1vbi4KCQkgKi8KCQlyZWZyZXNoX2NhY2hlKFJFRlJFU0hfUVVJRVQpOwoJCWlmIChhbGxvd190cml2aWFsICYmICFmYXN0X2ZvcndhcmRfb25seSkgewoJCQkvKiBTZWUgaWYgaXQgaXMgcmVhbGx5IHRyaXZpYWwuICovCgkJCWdpdF9jb21taXR0ZXJfaW5mbyhJREVOVF9FUlJPUl9PTl9OT19OQU1FKTsKCQkJcHJpbnRmKF8oIlRyeWluZyByZWFsbHkgdHJpdmlhbCBpbi1pbmRleCBtZXJnZS4uLlxuIikpOwoJCQlpZiAoIXJlYWRfdHJlZV90cml2aWFsKGNvbW1vbi0+aXRlbS0+b2JqZWN0LnNoYTEsCgkJCQkJaGVhZF9jb21taXQtPm9iamVjdC5zaGExLCByZW1vdGVoZWFkcy0+aXRlbS0+b2JqZWN0LnNoYTEpKQoJCQkJcmV0dXJuIG1lcmdlX3RyaXZpYWwoaGVhZF9jb21taXQpOwoJCQlwcmludGYoXygiTm9wZS5cbiIpKTsKCQl9Cgl9IGVsc2UgewoJCS8qCgkJICogQW4gb2N0b3B1cy4gIElmIHdlIGNhbiByZWFjaCBhbGwgdGhlIHJlbW90ZSB3ZSBhcmUgdXAKCQkgKiB0byBkYXRlLgoJCSAqLwoJCWludCB1cF90b19kYXRlID0gMTsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKmo7CgoJCWZvciAoaiA9IHJlbW90ZWhlYWRzOyBqOyBqID0gai0+bmV4dCkgewoJCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKmNvbW1vbl9vbmU7CgoJCQkvKgoJCQkgKiBIZXJlIHdlICpoYXZlKiB0byBjYWxjdWxhdGUgdGhlIGluZGl2aWR1YWwKCQkJICogbWVyZ2VfYmFzZXMgYWdhaW4sIG90aGVyd2lzZSAiZ2l0IG1lcmdlIEhFQUReCgkJCSAqIEhFQUReXiIgd291bGQgYmUgbWlzc2VkLgoJCQkgKi8KCQkJY29tbW9uX29uZSA9IGdldF9tZXJnZV9iYXNlcyhoZWFkX2NvbW1pdCwgai0+aXRlbSwgMSk7CgkJCWlmIChoYXNoY21wKGNvbW1vbl9vbmUtPml0ZW0tPm9iamVjdC5zaGExLAoJCQkJai0+aXRlbS0+b2JqZWN0LnNoYTEpKSB7CgkJCQl1cF90b19kYXRlID0gMDsKCQkJCWJyZWFrOwoJCQl9CgkJfQoJCWlmICh1cF90b19kYXRlKSB7CgkJCWZpbmlzaF91cF90b19kYXRlKCJBbHJlYWR5IHVwLXRvLWRhdGUuIFllZWFoISIpOwoJCQlyZXR1cm4gMDsKCQl9Cgl9CgoJaWYgKGZhc3RfZm9yd2FyZF9vbmx5KQoJCWRpZShfKCJOb3QgcG9zc2libGUgdG8gZmFzdC1mb3J3YXJkLCBhYm9ydGluZy4iKSk7CgoJLyogV2UgYXJlIGdvaW5nIHRvIG1ha2UgYSBuZXcgY29tbWl0LiAqLwoJZ2l0X2NvbW1pdHRlcl9pbmZvKElERU5UX0VSUk9SX09OX05PX05BTUUpOwoKCS8qCgkgKiBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIGEgcmVhbCBtZXJnZS4gIE5vIG1hdHRlciB3aGF0IHN0cmF0ZWd5CgkgKiB3ZSB1c2UsIGl0IHdvdWxkIG9wZXJhdGUgb24gdGhlIGluZGV4LCBwb3NzaWJseSBhZmZlY3RpbmcgdGhlCgkgKiB3b3JraW5nIHRyZWUsIGFuZCB3aGVuIHJlc29sdmVkIGNsZWFubHksIGhhdmUgdGhlIGRlc2lyZWQKCSAqIHRyZWUgaW4gdGhlIGluZGV4IC0tIHRoaXMgbWVhbnMgdGhhdCB0aGUgaW5kZXggbXVzdCBiZSBpbgoJICogc3luYyB3aXRoIHRoZSBoZWFkIGNvbW1pdC4gIFRoZSBzdHJhdGVnaWVzIGFyZSByZXNwb25zaWJsZQoJICogdG8gZW5zdXJlIHRoaXMuCgkgKi8KCWlmICh1c2Vfc3RyYXRlZ2llc19uciA9PSAxIHx8CgkgICAgLyoKCSAgICAgKiBTdGFzaCBhd2F5IHRoZSBsb2NhbCBjaGFuZ2VzIHNvIHRoYXQgd2UgY2FuIHRyeSBtb3JlIHRoYW4gb25lLgoJICAgICAqLwoJICAgIHNhdmVfc3RhdGUoc3Rhc2gpKQoJCWhhc2hjcHkoc3Rhc2gsIG51bGxfc2hhMSk7CgoJZm9yIChpID0gMDsgaSA8IHVzZV9zdHJhdGVnaWVzX25yOyBpKyspIHsKCQlpbnQgcmV0OwoJCWlmIChpKSB7CgkJCXByaW50ZihfKCJSZXdpbmRpbmcgdGhlIHRyZWUgdG8gcHJpc3RpbmUuLi5cbiIpKTsKCQkJcmVzdG9yZV9zdGF0ZShoZWFkX2NvbW1pdC0+b2JqZWN0LnNoYTEsIHN0YXNoKTsKCQl9CgkJaWYgKHVzZV9zdHJhdGVnaWVzX25yICE9IDEpCgkJCXByaW50ZihfKCJUcnlpbmcgbWVyZ2Ugc3RyYXRlZ3kgJXMuLi5cbiIpLAoJCQkJdXNlX3N0cmF0ZWdpZXNbaV0tPm5hbWUpOwoJCS8qCgkJICogUmVtZW1iZXIgd2hpY2ggc3RyYXRlZ3kgbGVmdCB0aGUgc3RhdGUgaW4gdGhlIHdvcmtpbmcKCQkgKiB0cmVlLgoJCSAqLwoJCXd0X3N0cmF0ZWd5ID0gdXNlX3N0cmF0ZWdpZXNbaV0tPm5hbWU7CgoJCXJldCA9IHRyeV9tZXJnZV9zdHJhdGVneSh1c2Vfc3RyYXRlZ2llc1tpXS0+bmFtZSwKCQkJCQkgY29tbW9uLCBoZWFkX2NvbW1pdCwgaGVhZF9hcmcpOwoJCWlmICghb3B0aW9uX2NvbW1pdCAmJiAhcmV0KSB7CgkJCW1lcmdlX3dhc19vayA9IDE7CgkJCS8qCgkJCSAqIFRoaXMgaXMgbmVjZXNzYXJ5IGhlcmUganVzdCB0byBhdm9pZCB3cml0aW5nCgkJCSAqIHRoZSB0cmVlLCBidXQgbGF0ZXIgd2Ugd2lsbCAqbm90KiBleGl0IHdpdGgKCQkJICogc3RhdHVzIGNvZGUgMSBiZWNhdXNlIG1lcmdlX3dhc19vayBpcyBzZXQuCgkJCSAqLwoJCQlyZXQgPSAxOwoJCX0KCgkJaWYgKHJldCkgewoJCQkvKgoJCQkgKiBUaGUgYmFja2VuZCBleGl0cyB3aXRoIDEgd2hlbiBjb25mbGljdHMgYXJlCgkJCSAqIGxlZnQgdG8gYmUgcmVzb2x2ZWQsIHdpdGggMiB3aGVuIGl0IGRvZXMgbm90CgkJCSAqIGhhbmRsZSB0aGUgZ2l2ZW4gbWVyZ2UgYXQgYWxsLgoJCQkgKi8KCQkJaWYgKHJldCA9PSAxKSB7CgkJCQlpbnQgY250ID0gZXZhbHVhdGVfcmVzdWx0KCk7CgoJCQkJaWYgKGJlc3RfY250IDw9IDAgfHwgY250IDw9IGJlc3RfY250KSB7CgkJCQkJYmVzdF9zdHJhdGVneSA9IHVzZV9zdHJhdGVnaWVzW2ldLT5uYW1lOwoJCQkJCWJlc3RfY250ID0gY250OwoJCQkJfQoJCQl9CgkJCWlmIChtZXJnZV93YXNfb2spCgkJCQlicmVhazsKCQkJZWxzZQoJCQkJY29udGludWU7CgkJfQoKCQkvKiBBdXRvbWVyZ2Ugc3VjY2VlZGVkLiAqLwoJCXdyaXRlX3RyZWVfdHJpdmlhbChyZXN1bHRfdHJlZSk7CgkJYXV0b21lcmdlX3dhc19vayA9IDE7CgkJYnJlYWs7Cgl9CgoJLyoKCSAqIElmIHdlIGhhdmUgYSByZXN1bHRpbmcgdHJlZSwgdGhhdCBtZWFucyB0aGUgc3RyYXRlZ3kgbW9kdWxlCgkgKiBhdXRvIHJlc29sdmVkIHRoZSBtZXJnZSBjbGVhbmx5LgoJICovCglpZiAoYXV0b21lcmdlX3dhc19vaykKCQlyZXR1cm4gZmluaXNoX2F1dG9tZXJnZShoZWFkX2NvbW1pdCwgY29tbW9uLCByZXN1bHRfdHJlZSwKCQkJCQl3dF9zdHJhdGVneSk7CgoJLyoKCSAqIFBpY2sgdGhlIHJlc3VsdCBmcm9tIHRoZSBiZXN0IHN0cmF0ZWd5IGFuZCBoYXZlIHRoZSB1c2VyIGZpeAoJICogaXQgdXAuCgkgKi8KCWlmICghYmVzdF9zdHJhdGVneSkgewoJCXJlc3RvcmVfc3RhdGUoaGVhZF9jb21taXQtPm9iamVjdC5zaGExLCBzdGFzaCk7CgkJaWYgKHVzZV9zdHJhdGVnaWVzX25yID4gMSkKCQkJZnByaW50ZihzdGRlcnIsCgkJCQlfKCJObyBtZXJnZSBzdHJhdGVneSBoYW5kbGVkIHRoZSBtZXJnZS5cbiIpKTsKCQllbHNlCgkJCWZwcmludGYoc3RkZXJyLCBfKCJNZXJnZSB3aXRoIHN0cmF0ZWd5ICVzIGZhaWxlZC5cbiIpLAoJCQkJdXNlX3N0cmF0ZWdpZXNbMF0tPm5hbWUpOwoJCXJldHVybiAyOwoJfSBlbHNlIGlmIChiZXN0X3N0cmF0ZWd5ID09IHd0X3N0cmF0ZWd5KQoJCTsgLyogV2UgYWxyZWFkeSBoYXZlIGl0cyByZXN1bHQgaW4gdGhlIHdvcmtpbmcgdHJlZS4gKi8KCWVsc2UgewoJCXByaW50ZihfKCJSZXdpbmRpbmcgdGhlIHRyZWUgdG8gcHJpc3RpbmUuLi5cbiIpKTsKCQlyZXN0b3JlX3N0YXRlKGhlYWRfY29tbWl0LT5vYmplY3Quc2hhMSwgc3Rhc2gpOwoJCXByaW50ZihfKCJVc2luZyB0aGUgJXMgdG8gcHJlcGFyZSByZXNvbHZpbmcgYnkgaGFuZC5cbiIpLAoJCQliZXN0X3N0cmF0ZWd5KTsKCQl0cnlfbWVyZ2Vfc3RyYXRlZ3koYmVzdF9zdHJhdGVneSwgY29tbW9uLCBoZWFkX2NvbW1pdCwgaGVhZF9hcmcpOwoJfQoKCWlmIChzcXVhc2gpCgkJZmluaXNoKGhlYWRfY29tbWl0LCBOVUxMLCBOVUxMKTsKCWVsc2UKCQl3cml0ZV9tZXJnZV9zdGF0ZSgpOwoKCWlmIChtZXJnZV93YXNfb2spIHsKCQlmcHJpbnRmKHN0ZGVyciwgXygiQXV0b21hdGljIG1lcmdlIHdlbnQgd2VsbDsgIgoJCQkic3RvcHBlZCBiZWZvcmUgY29tbWl0dGluZyBhcyByZXF1ZXN0ZWRcbiIpKTsKCQlyZXR1cm4gMDsKCX0gZWxzZQoJCXJldHVybiBzdWdnZXN0X2NvbmZsaWN0cyhvcHRpb25fcmVub3JtYWxpemUpOwp9Cg==",
    "text": "/*\n * Builtin \"git merge\"\n *\n * Copyright (c) 2008 Miklos Vajna <vmiklos@frugalware.org>\n *\n * Based on git-merge.sh by Junio C Hamano.\n */\n\n#include \"cache.h\"\n#include \"parse-options.h\"\n#include \"builtin.h\"\n#include \"run-command.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"commit.h\"\n#include \"diffcore.h\"\n#include \"revision.h\"\n#include \"unpack-trees.h\"\n#include \"cache-tree.h\"\n#include \"dir.h\"\n#include \"utf8.h\"\n#include \"log-tree.h\"\n#include \"color.h\"\n#include \"rerere.h\"\n#include \"help.h\"\n#include \"merge-recursive.h\"\n#include \"resolve-undo.h\"\n#include \"remote.h\"\n\n#define DEFAULT_TWOHEAD (1<<0)\n#define DEFAULT_OCTOPUS (1<<1)\n#define NO_FAST_FORWARD (1<<2)\n#define NO_TRIVIAL      (1<<3)\n\nstruct strategy {\n\tconst char *name;\n\tunsigned attr;\n};\n\nstatic const char * const builtin_merge_usage[] = {\n\t\"git merge [options] [<commit>...]\",\n\t\"git merge [options] <msg> HEAD <commit>\",\n\t\"git merge --abort\",\n\tNULL\n};\n\nstatic int show_diffstat = 1, shortlog_len, squash;\nstatic int option_commit = 1, allow_fast_forward = 1;\nstatic int fast_forward_only, option_edit = -1;\nstatic int allow_trivial = 1, have_message;\nstatic struct strbuf merge_msg;\nstatic struct commit_list *remoteheads;\nstatic struct strategy **use_strategies;\nstatic size_t use_strategies_nr, use_strategies_alloc;\nstatic const char **xopts;\nstatic size_t xopts_nr, xopts_alloc;\nstatic const char *branch;\nstatic char *branch_mergeoptions;\nstatic int option_renormalize;\nstatic int verbosity;\nstatic int allow_rerere_auto;\nstatic int abort_current_merge;\nstatic int show_progress = -1;\nstatic int default_to_upstream;\n\nstatic struct strategy all_strategy[] = {\n\t{ \"recursive\",  DEFAULT_TWOHEAD | NO_TRIVIAL },\n\t{ \"octopus\",    DEFAULT_OCTOPUS },\n\t{ \"resolve\",    0 },\n\t{ \"ours\",       NO_FAST_FORWARD | NO_TRIVIAL },\n\t{ \"subtree\",    NO_FAST_FORWARD | NO_TRIVIAL },\n};\n\nstatic const char *pull_twohead, *pull_octopus;\n\nstatic int option_parse_message(const struct option *opt,\n\t\t\t\tconst char *arg, int unset)\n{\n\tstruct strbuf *buf = opt->value;\n\n\tif (unset)\n\t\tstrbuf_setlen(buf, 0);\n\telse if (arg) {\n\t\tstrbuf_addf(buf, \"%s%s\", buf->len ? \"\\n\\n\" : \"\", arg);\n\t\thave_message = 1;\n\t} else\n\t\treturn error(_(\"switch `m' requires a value\"));\n\treturn 0;\n}\n\nstatic struct strategy *get_strategy(const char *name)\n{\n\tint i;\n\tstruct strategy *ret;\n\tstatic struct cmdnames main_cmds, other_cmds;\n\tstatic int loaded;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(all_strategy); i++)\n\t\tif (!strcmp(name, all_strategy[i].name))\n\t\t\treturn &all_strategy[i];\n\n\tif (!loaded) {\n\t\tstruct cmdnames not_strategies;\n\t\tloaded = 1;\n\n\t\tmemset(&not_strategies, 0, sizeof(struct cmdnames));\n\t\tload_command_list(\"git-merge-\", &main_cmds, &other_cmds);\n\t\tfor (i = 0; i < main_cmds.cnt; i++) {\n\t\t\tint j, found = 0;\n\t\t\tstruct cmdname *ent = main_cmds.names[i];\n\t\t\tfor (j = 0; j < ARRAY_SIZE(all_strategy); j++)\n\t\t\t\tif (!strncmp(ent->name, all_strategy[j].name, ent->len)\n\t\t\t\t\t\t&& !all_strategy[j].name[ent->len])\n\t\t\t\t\tfound = 1;\n\t\t\tif (!found)\n\t\t\t\tadd_cmdname(&not_strategies, ent->name, ent->len);\n\t\t}\n\t\texclude_cmds(&main_cmds, &not_strategies);\n\t}\n\tif (!is_in_cmdlist(&main_cmds, name) && !is_in_cmdlist(&other_cmds, name)) {\n\t\tfprintf(stderr, _(\"Could not find merge strategy '%s'.\\n\"), name);\n\t\tfprintf(stderr, _(\"Available strategies are:\"));\n\t\tfor (i = 0; i < main_cmds.cnt; i++)\n\t\t\tfprintf(stderr, \" %s\", main_cmds.names[i]->name);\n\t\tfprintf(stderr, \".\\n\");\n\t\tif (other_cmds.cnt) {\n\t\t\tfprintf(stderr, _(\"Available custom strategies are:\"));\n\t\t\tfor (i = 0; i < other_cmds.cnt; i++)\n\t\t\t\tfprintf(stderr, \" %s\", other_cmds.names[i]->name);\n\t\t\tfprintf(stderr, \".\\n\");\n\t\t}\n\t\texit(1);\n\t}\n\n\tret = xcalloc(1, sizeof(struct strategy));\n\tret->name = xstrdup(name);\n\tret->attr = NO_TRIVIAL;\n\treturn ret;\n}\n\nstatic void append_strategy(struct strategy *s)\n{\n\tALLOC_GROW(use_strategies, use_strategies_nr + 1, use_strategies_alloc);\n\tuse_strategies[use_strategies_nr++] = s;\n}\n\nstatic int option_parse_strategy(const struct option *opt,\n\t\t\t\t const char *name, int unset)\n{\n\tif (unset)\n\t\treturn 0;\n\n\tappend_strategy(get_strategy(name));\n\treturn 0;\n}\n\nstatic int option_parse_x(const struct option *opt,\n\t\t\t  const char *arg, int unset)\n{\n\tif (unset)\n\t\treturn 0;\n\n\tALLOC_GROW(xopts, xopts_nr + 1, xopts_alloc);\n\txopts[xopts_nr++] = xstrdup(arg);\n\treturn 0;\n}\n\nstatic int option_parse_n(const struct option *opt,\n\t\t\t  const char *arg, int unset)\n{\n\tshow_diffstat = unset;\n\treturn 0;\n}\n\nstatic struct option builtin_merge_options[] = {\n\t{ OPTION_CALLBACK, 'n', NULL, NULL, NULL,\n\t\t\"do not show a diffstat at the end of the merge\",\n\t\tPARSE_OPT_NOARG, option_parse_n },\n\tOPT_BOOLEAN(0, \"stat\", &show_diffstat,\n\t\t\"show a diffstat at the end of the merge\"),\n\tOPT_BOOLEAN(0, \"summary\", &show_diffstat, \"(synonym to --stat)\"),\n\t{ OPTION_INTEGER, 0, \"log\", &shortlog_len, \"n\",\n\t  \"add (at most <n>) entries from shortlog to merge commit message\",\n\t  PARSE_OPT_OPTARG, NULL, DEFAULT_MERGE_LOG_LEN },\n\tOPT_BOOLEAN(0, \"squash\", &squash,\n\t\t\"create a single commit instead of doing a merge\"),\n\tOPT_BOOLEAN(0, \"commit\", &option_commit,\n\t\t\"perform a commit if the merge succeeds (default)\"),\n\tOPT_BOOL('e', \"edit\", &option_edit,\n\t\t\"edit message before committing\"),\n\tOPT_BOOLEAN(0, \"ff\", &allow_fast_forward,\n\t\t\"allow fast-forward (default)\"),\n\tOPT_BOOLEAN(0, \"ff-only\", &fast_forward_only,\n\t\t\"abort if fast-forward is not possible\"),\n\tOPT_RERERE_AUTOUPDATE(&allow_rerere_auto),\n\tOPT_CALLBACK('s', \"strategy\", &use_strategies, \"strategy\",\n\t\t\"merge strategy to use\", option_parse_strategy),\n\tOPT_CALLBACK('X', \"strategy-option\", &xopts, \"option=value\",\n\t\t\"option for selected merge strategy\", option_parse_x),\n\tOPT_CALLBACK('m', \"message\", &merge_msg, \"message\",\n\t\t\"merge commit message (for a non-fast-forward merge)\",\n\t\toption_parse_message),\n\tOPT__VERBOSITY(&verbosity),\n\tOPT_BOOLEAN(0, \"abort\", &abort_current_merge,\n\t\t\"abort the current in-progress merge\"),\n\tOPT_SET_INT(0, \"progress\", &show_progress, \"force progress reporting\", 1),\n\tOPT_END()\n};\n\n/* Cleans up metadata that is uninteresting after a succeeded merge. */\nstatic void drop_save(void)\n{\n\tunlink(git_path(\"MERGE_HEAD\"));\n\tunlink(git_path(\"MERGE_MSG\"));\n\tunlink(git_path(\"MERGE_MODE\"));\n}\n\nstatic int save_state(unsigned char *stash)\n{\n\tint len;\n\tstruct child_process cp;\n\tstruct strbuf buffer = STRBUF_INIT;\n\tconst char *argv[] = {\"stash\", \"create\", NULL};\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.argv = argv;\n\tcp.out = -1;\n\tcp.git_cmd = 1;\n\n\tif (start_command(&cp))\n\t\tdie(_(\"could not run stash.\"));\n\tlen = strbuf_read(&buffer, cp.out, 1024);\n\tclose(cp.out);\n\n\tif (finish_command(&cp) || len < 0)\n\t\tdie(_(\"stash failed\"));\n\telse if (!len)\t\t/* no changes */\n\t\treturn -1;\n\tstrbuf_setlen(&buffer, buffer.len-1);\n\tif (get_sha1(buffer.buf, stash))\n\t\tdie(_(\"not a valid object: %s\"), buffer.buf);\n\treturn 0;\n}\n\nstatic void read_empty(unsigned const char *sha1, int verbose)\n{\n\tint i = 0;\n\tconst char *args[7];\n\n\targs[i++] = \"read-tree\";\n\tif (verbose)\n\t\targs[i++] = \"-v\";\n\targs[i++] = \"-m\";\n\targs[i++] = \"-u\";\n\targs[i++] = EMPTY_TREE_SHA1_HEX;\n\targs[i++] = sha1_to_hex(sha1);\n\targs[i] = NULL;\n\n\tif (run_command_v_opt(args, RUN_GIT_CMD))\n\t\tdie(_(\"read-tree failed\"));\n}\n\nstatic void reset_hard(unsigned const char *sha1, int verbose)\n{\n\tint i = 0;\n\tconst char *args[6];\n\n\targs[i++] = \"read-tree\";\n\tif (verbose)\n\t\targs[i++] = \"-v\";\n\targs[i++] = \"--reset\";\n\targs[i++] = \"-u\";\n\targs[i++] = sha1_to_hex(sha1);\n\targs[i] = NULL;\n\n\tif (run_command_v_opt(args, RUN_GIT_CMD))\n\t\tdie(_(\"read-tree failed\"));\n}\n\nstatic void restore_state(const unsigned char *head,\n\t\t\t  const unsigned char *stash)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *args[] = { \"stash\", \"apply\", NULL, NULL };\n\n\tif (is_null_sha1(stash))\n\t\treturn;\n\n\treset_hard(head, 1);\n\n\targs[2] = sha1_to_hex(stash);\n\n\t/*\n\t * It is OK to ignore error here, for example when there was\n\t * nothing to restore.\n\t */\n\trun_command_v_opt(args, RUN_GIT_CMD);\n\n\tstrbuf_release(&sb);\n\trefresh_cache(REFRESH_QUIET);\n}\n\n/* This is called when no merge was necessary. */\nstatic void finish_up_to_date(const char *msg)\n{\n\tif (verbosity >= 0)\n\t\tprintf(\"%s%s\\n\", squash ? _(\" (nothing to squash)\") : \"\", msg);\n\tdrop_save();\n}\n\nstatic void squash_message(struct commit *commit)\n{\n\tstruct rev_info rev;\n\tstruct strbuf out = STRBUF_INIT;\n\tstruct commit_list *j;\n\tint fd;\n\tstruct pretty_print_context ctx = {0};\n\n\tprintf(_(\"Squash commit -- not updating HEAD\\n\"));\n\tfd = open(git_path(\"SQUASH_MSG\"), O_WRONLY | O_CREAT, 0666);\n\tif (fd < 0)\n\t\tdie_errno(_(\"Could not write to '%s'\"), git_path(\"SQUASH_MSG\"));\n\n\tinit_revisions(&rev, NULL);\n\trev.ignore_merges = 1;\n\trev.commit_format = CMIT_FMT_MEDIUM;\n\n\tcommit->object.flags |= UNINTERESTING;\n\tadd_pending_object(&rev, &commit->object, NULL);\n\n\tfor (j = remoteheads; j; j = j->next)\n\t\tadd_pending_object(&rev, &j->item->object, NULL);\n\n\tsetup_revisions(0, NULL, &rev, NULL);\n\tif (prepare_revision_walk(&rev))\n\t\tdie(_(\"revision walk setup failed\"));\n\n\tctx.abbrev = rev.abbrev;\n\tctx.date_mode = rev.date_mode;\n\tctx.fmt = rev.commit_format;\n\n\tstrbuf_addstr(&out, \"Squashed commit of the following:\\n\");\n\twhile ((commit = get_revision(&rev)) != NULL) {\n\t\tstrbuf_addch(&out, '\\n');\n\t\tstrbuf_addf(&out, \"commit %s\\n\",\n\t\t\tsha1_to_hex(commit->object.sha1));\n\t\tpretty_print_commit(&ctx, commit, &out);\n\t}\n\tif (write(fd, out.buf, out.len) < 0)\n\t\tdie_errno(_(\"Writing SQUASH_MSG\"));\n\tif (close(fd))\n\t\tdie_errno(_(\"Finishing SQUASH_MSG\"));\n\tstrbuf_release(&out);\n}\n\nstatic void finish(struct commit *head_commit,\n\t\t   const unsigned char *new_head, const char *msg)\n{\n\tstruct strbuf reflog_message = STRBUF_INIT;\n\tconst unsigned char *head = head_commit->object.sha1;\n\n\tif (!msg)\n\t\tstrbuf_addstr(&reflog_message, getenv(\"GIT_REFLOG_ACTION\"));\n\telse {\n\t\tif (verbosity >= 0)\n\t\t\tprintf(\"%s\\n\", msg);\n\t\tstrbuf_addf(&reflog_message, \"%s: %s\",\n\t\t\tgetenv(\"GIT_REFLOG_ACTION\"), msg);\n\t}\n\tif (squash) {\n\t\tsquash_message(head_commit);\n\t} else {\n\t\tif (verbosity >= 0 && !merge_msg.len)\n\t\t\tprintf(_(\"No merge message -- not updating HEAD\\n\"));\n\t\telse {\n\t\t\tconst char *argv_gc_auto[] = { \"gc\", \"--auto\", NULL };\n\t\t\tupdate_ref(reflog_message.buf, \"HEAD\",\n\t\t\t\tnew_head, head, 0,\n\t\t\t\tDIE_ON_ERR);\n\t\t\t/*\n\t\t\t * We ignore errors in 'gc --auto', since the\n\t\t\t * user should see them.\n\t\t\t */\n\t\t\trun_command_v_opt(argv_gc_auto, RUN_GIT_CMD);\n\t\t}\n\t}\n\tif (new_head && show_diffstat) {\n\t\tstruct diff_options opts;\n\t\tdiff_setup(&opts);\n\t\topts.output_format |=\n\t\t\tDIFF_FORMAT_SUMMARY | DIFF_FORMAT_DIFFSTAT;\n\t\topts.detect_rename = DIFF_DETECT_RENAME;\n\t\tif (diff_setup_done(&opts) < 0)\n\t\t\tdie(_(\"diff_setup_done failed\"));\n\t\tdiff_tree_sha1(head, new_head, \"\", &opts);\n\t\tdiffcore_std(&opts);\n\t\tdiff_flush(&opts);\n\t}\n\n\t/* Run a post-merge hook */\n\trun_hook(NULL, \"post-merge\", squash ? \"1\" : \"0\", NULL);\n\n\tstrbuf_release(&reflog_message);\n}\n\n/* Get the name for the merge commit's message. */\nstatic void merge_name(const char *remote, struct strbuf *msg)\n{\n\tstruct commit *remote_head;\n\tunsigned char branch_head[20], buf_sha[20];\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf bname = STRBUF_INIT;\n\tconst char *ptr;\n\tchar *found_ref;\n\tint len, early;\n\n\tstrbuf_branchname(&bname, remote);\n\tremote = bname.buf;\n\n\tmemset(branch_head, 0, sizeof(branch_head));\n\tremote_head = get_merge_parent(remote);\n\tif (!remote_head)\n\t\tdie(_(\"'%s' does not point to a commit\"), remote);\n\n\tif (dwim_ref(remote, strlen(remote), branch_head, &found_ref) > 0) {\n\t\tif (!prefixcmp(found_ref, \"refs/heads/\")) {\n\t\t\tstrbuf_addf(msg, \"%s\\t\\tbranch '%s' of .\\n\",\n\t\t\t\t    sha1_to_hex(branch_head), remote);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (!prefixcmp(found_ref, \"refs/tags/\")) {\n\t\t\tstrbuf_addf(msg, \"%s\\t\\ttag '%s' of .\\n\",\n\t\t\t\t    sha1_to_hex(branch_head), remote);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (!prefixcmp(found_ref, \"refs/remotes/\")) {\n\t\t\tstrbuf_addf(msg, \"%s\\t\\tremote-tracking branch '%s' of .\\n\",\n\t\t\t\t    sha1_to_hex(branch_head), remote);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* See if remote matches <name>^^^.. or <name>~<number> */\n\tfor (len = 0, ptr = remote + strlen(remote);\n\t     remote < ptr && ptr[-1] == '^';\n\t     ptr--)\n\t\tlen++;\n\tif (len)\n\t\tearly = 1;\n\telse {\n\t\tearly = 0;\n\t\tptr = strrchr(remote, '~');\n\t\tif (ptr) {\n\t\t\tint seen_nonzero = 0;\n\n\t\t\tlen++; /* count ~ */\n\t\t\twhile (*++ptr && isdigit(*ptr)) {\n\t\t\t\tseen_nonzero |= (*ptr != '0');\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (*ptr)\n\t\t\t\tlen = 0; /* not ...~<number> */\n\t\t\telse if (seen_nonzero)\n\t\t\t\tearly = 1;\n\t\t\telse if (len == 1)\n\t\t\t\tearly = 1; /* \"name~\" is \"name~1\"! */\n\t\t}\n\t}\n\tif (len) {\n\t\tstruct strbuf truname = STRBUF_INIT;\n\t\tstrbuf_addstr(&truname, \"refs/heads/\");\n\t\tstrbuf_addstr(&truname, remote);\n\t\tstrbuf_setlen(&truname, truname.len - len);\n\t\tif (resolve_ref(truname.buf, buf_sha, 1, NULL)) {\n\t\t\tstrbuf_addf(msg,\n\t\t\t\t    \"%s\\t\\tbranch '%s'%s of .\\n\",\n\t\t\t\t    sha1_to_hex(remote_head->object.sha1),\n\t\t\t\t    truname.buf + 11,\n\t\t\t\t    (early ? \" (early part)\" : \"\"));\n\t\t\tstrbuf_release(&truname);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (!strcmp(remote, \"FETCH_HEAD\") &&\n\t\t\t!access(git_path(\"FETCH_HEAD\"), R_OK)) {\n\t\tFILE *fp;\n\t\tstruct strbuf line = STRBUF_INIT;\n\t\tchar *ptr;\n\n\t\tfp = fopen(git_path(\"FETCH_HEAD\"), \"r\");\n\t\tif (!fp)\n\t\t\tdie_errno(_(\"could not open '%s' for reading\"),\n\t\t\t\t  git_path(\"FETCH_HEAD\"));\n\t\tstrbuf_getline(&line, fp, '\\n');\n\t\tfclose(fp);\n\t\tptr = strstr(line.buf, \"\\tnot-for-merge\\t\");\n\t\tif (ptr)\n\t\t\tstrbuf_remove(&line, ptr-line.buf+1, 13);\n\t\tstrbuf_addbuf(msg, &line);\n\t\tstrbuf_release(&line);\n\t\tgoto cleanup;\n\t}\n\tstrbuf_addf(msg, \"%s\\t\\tcommit '%s'\\n\",\n\t\tsha1_to_hex(remote_head->object.sha1), remote);\ncleanup:\n\tstrbuf_release(&buf);\n\tstrbuf_release(&bname);\n}\n\nstatic void parse_branch_merge_options(char *bmo)\n{\n\tconst char **argv;\n\tint argc;\n\n\tif (!bmo)\n\t\treturn;\n\targc = split_cmdline(bmo, &argv);\n\tif (argc < 0)\n\t\tdie(_(\"Bad branch.%s.mergeoptions string: %s\"), branch,\n\t\t    split_cmdline_strerror(argc));\n\targv = xrealloc(argv, sizeof(*argv) * (argc + 2));\n\tmemmove(argv + 1, argv, sizeof(*argv) * (argc + 1));\n\targc++;\n\targv[0] = \"branch.*.mergeoptions\";\n\tparse_options(argc, argv, NULL, builtin_merge_options,\n\t\t      builtin_merge_usage, 0);\n\tfree(argv);\n}\n\nstatic int git_merge_config(const char *k, const char *v, void *cb)\n{\n\tif (branch && !prefixcmp(k, \"branch.\") &&\n\t\t!prefixcmp(k + 7, branch) &&\n\t\t!strcmp(k + 7 + strlen(branch), \".mergeoptions\")) {\n\t\tfree(branch_mergeoptions);\n\t\tbranch_mergeoptions = xstrdup(v);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(k, \"merge.diffstat\") || !strcmp(k, \"merge.stat\"))\n\t\tshow_diffstat = git_config_bool(k, v);\n\telse if (!strcmp(k, \"pull.twohead\"))\n\t\treturn git_config_string(&pull_twohead, k, v);\n\telse if (!strcmp(k, \"pull.octopus\"))\n\t\treturn git_config_string(&pull_octopus, k, v);\n\telse if (!strcmp(k, \"merge.renormalize\"))\n\t\toption_renormalize = git_config_bool(k, v);\n\telse if (!strcmp(k, \"merge.log\") || !strcmp(k, \"merge.summary\")) {\n\t\tint is_bool;\n\t\tshortlog_len = git_config_bool_or_int(k, v, &is_bool);\n\t\tif (!is_bool && shortlog_len < 0)\n\t\t\treturn error(_(\"%s: negative length %s\"), k, v);\n\t\tif (is_bool && shortlog_len)\n\t\t\tshortlog_len = DEFAULT_MERGE_LOG_LEN;\n\t\treturn 0;\n\t} else if (!strcmp(k, \"merge.ff\")) {\n\t\tint boolval = git_config_maybe_bool(k, v);\n\t\tif (0 <= boolval) {\n\t\t\tallow_fast_forward = boolval;\n\t\t} else if (v && !strcmp(v, \"only\")) {\n\t\t\tallow_fast_forward = 1;\n\t\t\tfast_forward_only = 1;\n\t\t} /* do not barf on values from future versions of git */\n\t\treturn 0;\n\t} else if (!strcmp(k, \"merge.defaulttoupstream\")) {\n\t\tdefault_to_upstream = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\treturn git_diff_ui_config(k, v, cb);\n}\n\nstatic int read_tree_trivial(unsigned char *common, unsigned char *head,\n\t\t\t     unsigned char *one)\n{\n\tint i, nr_trees = 0;\n\tstruct tree *trees[MAX_UNPACK_TREES];\n\tstruct tree_desc t[MAX_UNPACK_TREES];\n\tstruct unpack_trees_options opts;\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.head_idx = 2;\n\topts.src_index = &the_index;\n\topts.dst_index = &the_index;\n\topts.update = 1;\n\topts.verbose_update = 1;\n\topts.trivial_merges_only = 1;\n\topts.merge = 1;\n\ttrees[nr_trees] = parse_tree_indirect(common);\n\tif (!trees[nr_trees++])\n\t\treturn -1;\n\ttrees[nr_trees] = parse_tree_indirect(head);\n\tif (!trees[nr_trees++])\n\t\treturn -1;\n\ttrees[nr_trees] = parse_tree_indirect(one);\n\tif (!trees[nr_trees++])\n\t\treturn -1;\n\topts.fn = threeway_merge;\n\tcache_tree_free(&active_cache_tree);\n\tfor (i = 0; i < nr_trees; i++) {\n\t\tparse_tree(trees[i]);\n\t\tinit_tree_desc(t+i, trees[i]->buffer, trees[i]->size);\n\t}\n\tif (unpack_trees(nr_trees, t, &opts))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void write_tree_trivial(unsigned char *sha1)\n{\n\tif (write_cache_as_tree(sha1, 0, NULL))\n\t\tdie(_(\"git write-tree failed to write a tree\"));\n}\n\nstatic const char *merge_argument(struct commit *commit)\n{\n\tif (commit)\n\t\treturn sha1_to_hex(commit->object.sha1);\n\telse\n\t\treturn EMPTY_TREE_SHA1_HEX;\n}\n\nint try_merge_command(const char *strategy, size_t xopts_nr,\n\t\t      const char **xopts, struct commit_list *common,\n\t\t      const char *head_arg, struct commit_list *remotes)\n{\n\tconst char **args;\n\tint i = 0, x = 0, ret;\n\tstruct commit_list *j;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\targs = xmalloc((4 + xopts_nr + commit_list_count(common) +\n\t\t\tcommit_list_count(remotes)) * sizeof(char *));\n\tstrbuf_addf(&buf, \"merge-%s\", strategy);\n\targs[i++] = buf.buf;\n\tfor (x = 0; x < xopts_nr; x++) {\n\t\tchar *s = xmalloc(strlen(xopts[x])+2+1);\n\t\tstrcpy(s, \"--\");\n\t\tstrcpy(s+2, xopts[x]);\n\t\targs[i++] = s;\n\t}\n\tfor (j = common; j; j = j->next)\n\t\targs[i++] = xstrdup(merge_argument(j->item));\n\targs[i++] = \"--\";\n\targs[i++] = head_arg;\n\tfor (j = remotes; j; j = j->next)\n\t\targs[i++] = xstrdup(merge_argument(j->item));\n\targs[i] = NULL;\n\tret = run_command_v_opt(args, RUN_GIT_CMD);\n\tstrbuf_release(&buf);\n\ti = 1;\n\tfor (x = 0; x < xopts_nr; x++)\n\t\tfree((void *)args[i++]);\n\tfor (j = common; j; j = j->next)\n\t\tfree((void *)args[i++]);\n\ti += 2;\n\tfor (j = remotes; j; j = j->next)\n\t\tfree((void *)args[i++]);\n\tfree(args);\n\tdiscard_cache();\n\tif (read_cache() < 0)\n\t\tdie(_(\"failed to read the cache\"));\n\tresolve_undo_clear();\n\n\treturn ret;\n}\n\nstatic int try_merge_strategy(const char *strategy, struct commit_list *common,\n\t\t\t      struct commit *head, const char *head_arg)\n{\n\tint index_fd;\n\tstruct lock_file *lock = xcalloc(1, sizeof(struct lock_file));\n\n\tindex_fd = hold_locked_index(lock, 1);\n\trefresh_cache(REFRESH_QUIET);\n\tif (active_cache_changed &&\n\t\t\t(write_cache(index_fd, active_cache, active_nr) ||\n\t\t\t commit_locked_index(lock)))\n\t\treturn error(_(\"Unable to write index.\"));\n\trollback_lock_file(lock);\n\n\tif (!strcmp(strategy, \"recursive\") || !strcmp(strategy, \"subtree\")) {\n\t\tint clean, x;\n\t\tstruct commit *result;\n\t\tstruct lock_file *lock = xcalloc(1, sizeof(struct lock_file));\n\t\tint index_fd;\n\t\tstruct commit_list *reversed = NULL;\n\t\tstruct merge_options o;\n\t\tstruct commit_list *j;\n\n\t\tif (remoteheads->next) {\n\t\t\terror(_(\"Not handling anything other than two heads merge.\"));\n\t\t\treturn 2;\n\t\t}\n\n\t\tinit_merge_options(&o);\n\t\tif (!strcmp(strategy, \"subtree\"))\n\t\t\to.subtree_shift = \"\";\n\n\t\to.renormalize = option_renormalize;\n\t\to.show_rename_progress =\n\t\t\tshow_progress == -1 ? isatty(2) : show_progress;\n\n\t\tfor (x = 0; x < xopts_nr; x++)\n\t\t\tif (parse_merge_opt(&o, xopts[x]))\n\t\t\t\tdie(_(\"Unknown option for merge-recursive: -X%s\"), xopts[x]);\n\n\t\to.branch1 = head_arg;\n\t\to.branch2 = merge_remote_util(remoteheads->item)->name;\n\n\t\tfor (j = common; j; j = j->next)\n\t\t\tcommit_list_insert(j->item, &reversed);\n\n\t\tindex_fd = hold_locked_index(lock, 1);\n\t\tclean = merge_recursive(&o, head,\n\t\t\t\tremoteheads->item, reversed, &result);\n\t\tif (active_cache_changed &&\n\t\t\t\t(write_cache(index_fd, active_cache, active_nr) ||\n\t\t\t\t commit_locked_index(lock)))\n\t\t\tdie (_(\"unable to write %s\"), get_index_file());\n\t\trollback_lock_file(lock);\n\t\treturn clean ? 0 : 1;\n\t} else {\n\t\treturn try_merge_command(strategy, xopts_nr, xopts,\n\t\t\t\t\t\tcommon, head_arg, remoteheads);\n\t}\n}\n\nstatic void count_diff_files(struct diff_queue_struct *q,\n\t\t\t     struct diff_options *opt, void *data)\n{\n\tint *count = data;\n\n\t(*count) += q->nr;\n}\n\nstatic int count_unmerged_entries(void)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < active_nr; i++)\n\t\tif (ce_stage(active_cache[i]))\n\t\t\tret++;\n\n\treturn ret;\n}\n\nint checkout_fast_forward(const unsigned char *head, const unsigned char *remote)\n{\n\tstruct tree *trees[MAX_UNPACK_TREES];\n\tstruct unpack_trees_options opts;\n\tstruct tree_desc t[MAX_UNPACK_TREES];\n\tint i, fd, nr_trees = 0;\n\tstruct dir_struct dir;\n\tstruct lock_file *lock_file = xcalloc(1, sizeof(struct lock_file));\n\n\trefresh_cache(REFRESH_QUIET);\n\n\tfd = hold_locked_index(lock_file, 1);\n\n\tmemset(&trees, 0, sizeof(trees));\n\tmemset(&opts, 0, sizeof(opts));\n\tmemset(&t, 0, sizeof(t));\n\tmemset(&dir, 0, sizeof(dir));\n\tdir.flags |= DIR_SHOW_IGNORED;\n\tdir.exclude_per_dir = \".gitignore\";\n\topts.dir = &dir;\n\n\topts.head_idx = 1;\n\topts.src_index = &the_index;\n\topts.dst_index = &the_index;\n\topts.update = 1;\n\topts.verbose_update = 1;\n\topts.merge = 1;\n\topts.fn = twoway_merge;\n\tsetup_unpack_trees_porcelain(&opts, \"merge\");\n\n\ttrees[nr_trees] = parse_tree_indirect(head);\n\tif (!trees[nr_trees++])\n\t\treturn -1;\n\ttrees[nr_trees] = parse_tree_indirect(remote);\n\tif (!trees[nr_trees++])\n\t\treturn -1;\n\tfor (i = 0; i < nr_trees; i++) {\n\t\tparse_tree(trees[i]);\n\t\tinit_tree_desc(t+i, trees[i]->buffer, trees[i]->size);\n\t}\n\tif (unpack_trees(nr_trees, t, &opts))\n\t\treturn -1;\n\tif (write_cache(fd, active_cache, active_nr) ||\n\t\tcommit_locked_index(lock_file))\n\t\tdie(_(\"unable to write new index file\"));\n\treturn 0;\n}\n\nstatic void split_merge_strategies(const char *string, struct strategy **list,\n\t\t\t\t   int *nr, int *alloc)\n{\n\tchar *p, *q, *buf;\n\n\tif (!string)\n\t\treturn;\n\n\tbuf = xstrdup(string);\n\tq = buf;\n\tfor (;;) {\n\t\tp = strchr(q, ' ');\n\t\tif (!p) {\n\t\t\tALLOC_GROW(*list, *nr + 1, *alloc);\n\t\t\t(*list)[(*nr)++].name = xstrdup(q);\n\t\t\tfree(buf);\n\t\t\treturn;\n\t\t} else {\n\t\t\t*p = '\\0';\n\t\t\tALLOC_GROW(*list, *nr + 1, *alloc);\n\t\t\t(*list)[(*nr)++].name = xstrdup(q);\n\t\t\tq = ++p;\n\t\t}\n\t}\n}\n\nstatic void add_strategies(const char *string, unsigned attr)\n{\n\tstruct strategy *list = NULL;\n\tint list_alloc = 0, list_nr = 0, i;\n\n\tmemset(&list, 0, sizeof(list));\n\tsplit_merge_strategies(string, &list, &list_nr, &list_alloc);\n\tif (list) {\n\t\tfor (i = 0; i < list_nr; i++)\n\t\t\tappend_strategy(get_strategy(list[i].name));\n\t\treturn;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(all_strategy); i++)\n\t\tif (all_strategy[i].attr & attr)\n\t\t\tappend_strategy(&all_strategy[i]);\n\n}\n\nstatic void write_merge_msg(struct strbuf *msg)\n{\n\tint fd = open(git_path(\"MERGE_MSG\"), O_WRONLY | O_CREAT, 0666);\n\tif (fd < 0)\n\t\tdie_errno(_(\"Could not open '%s' for writing\"),\n\t\t\t  git_path(\"MERGE_MSG\"));\n\tif (write_in_full(fd, msg->buf, msg->len) != msg->len)\n\t\tdie_errno(_(\"Could not write to '%s'\"), git_path(\"MERGE_MSG\"));\n\tclose(fd);\n}\n\nstatic void read_merge_msg(struct strbuf *msg)\n{\n\tstrbuf_reset(msg);\n\tif (strbuf_read_file(msg, git_path(\"MERGE_MSG\"), 0) < 0)\n\t\tdie_errno(_(\"Could not read from '%s'\"), git_path(\"MERGE_MSG\"));\n}\n\nstatic void write_merge_state(void);\nstatic void abort_commit(const char *err_msg)\n{\n\tif (err_msg)\n\t\terror(\"%s\", err_msg);\n\tfprintf(stderr,\n\t\t_(\"Not committing merge; use 'git commit' to complete the merge.\\n\"));\n\twrite_merge_state();\n\texit(1);\n}\n\nstatic void prepare_to_commit(void)\n{\n\tstruct strbuf msg = STRBUF_INIT;\n\tstrbuf_addbuf(&msg, &merge_msg);\n\tstrbuf_addch(&msg, '\\n');\n\twrite_merge_msg(&msg);\n\trun_hook(get_index_file(), \"prepare-commit-msg\",\n\t\t git_path(\"MERGE_MSG\"), \"merge\", NULL, NULL);\n\tif (0 < option_edit) {\n\t\tif (launch_editor(git_path(\"MERGE_MSG\"), NULL, NULL))\n\t\t\tabort_commit(NULL);\n\t}\n\tread_merge_msg(&msg);\n\tstripspace(&msg, 0 < option_edit);\n\tif (!msg.len)\n\t\tabort_commit(_(\"Empty commit message.\"));\n\tstrbuf_release(&merge_msg);\n\tstrbuf_addbuf(&merge_msg, &msg);\n\tstrbuf_release(&msg);\n}\n\nstatic int merge_trivial(struct commit *head)\n{\n\tunsigned char result_tree[20], result_commit[20];\n\tstruct commit_list *parent = xmalloc(sizeof(*parent));\n\n\twrite_tree_trivial(result_tree);\n\tprintf(_(\"Wonderful.\\n\"));\n\tparent->item = head;\n\tparent->next = xmalloc(sizeof(*parent->next));\n\tparent->next->item = remoteheads->item;\n\tparent->next->next = NULL;\n\tprepare_to_commit();\n\tcommit_tree(merge_msg.buf, result_tree, parent, result_commit, NULL);\n\tfinish(head, result_commit, \"In-index merge\");\n\tdrop_save();\n\treturn 0;\n}\n\nstatic int finish_automerge(struct commit *head,\n\t\t\t    struct commit_list *common,\n\t\t\t    unsigned char *result_tree,\n\t\t\t    const char *wt_strategy)\n{\n\tstruct commit_list *parents = NULL, *j;\n\tstruct strbuf buf = STRBUF_INIT;\n\tunsigned char result_commit[20];\n\n\tfree_commit_list(common);\n\tif (allow_fast_forward) {\n\t\tparents = remoteheads;\n\t\tcommit_list_insert(head, &parents);\n\t\tparents = reduce_heads(parents);\n\t} else {\n\t\tstruct commit_list **pptr = &parents;\n\n\t\tpptr = &commit_list_insert(head,\n\t\t\t\tpptr)->next;\n\t\tfor (j = remoteheads; j; j = j->next)\n\t\t\tpptr = &commit_list_insert(j->item, pptr)->next;\n\t}\n\tstrbuf_addch(&merge_msg, '\\n');\n\tprepare_to_commit();\n\tfree_commit_list(remoteheads);\n\tcommit_tree(merge_msg.buf, result_tree, parents, result_commit, NULL);\n\tstrbuf_addf(&buf, \"Merge made by the '%s' strategy.\", wt_strategy);\n\tfinish(head, result_commit, buf.buf);\n\tstrbuf_release(&buf);\n\tdrop_save();\n\treturn 0;\n}\n\nstatic int suggest_conflicts(int renormalizing)\n{\n\tFILE *fp;\n\tint pos;\n\n\tfp = fopen(git_path(\"MERGE_MSG\"), \"a\");\n\tif (!fp)\n\t\tdie_errno(_(\"Could not open '%s' for writing\"),\n\t\t\t  git_path(\"MERGE_MSG\"));\n\tfprintf(fp, \"\\nConflicts:\\n\");\n\tfor (pos = 0; pos < active_nr; pos++) {\n\t\tstruct cache_entry *ce = active_cache[pos];\n\n\t\tif (ce_stage(ce)) {\n\t\t\tfprintf(fp, \"\\t%s\\n\", ce->name);\n\t\t\twhile (pos + 1 < active_nr &&\n\t\t\t\t\t!strcmp(ce->name,\n\t\t\t\t\t\tactive_cache[pos + 1]->name))\n\t\t\t\tpos++;\n\t\t}\n\t}\n\tfclose(fp);\n\trerere(allow_rerere_auto);\n\tprintf(_(\"Automatic merge failed; \"\n\t\t\t\"fix conflicts and then commit the result.\\n\"));\n\treturn 1;\n}\n\nstatic struct commit *is_old_style_invocation(int argc, const char **argv,\n\t\t\t\t\t      const unsigned char *head)\n{\n\tstruct commit *second_token = NULL;\n\tif (argc > 2) {\n\t\tunsigned char second_sha1[20];\n\n\t\tif (get_sha1(argv[1], second_sha1))\n\t\t\treturn NULL;\n\t\tsecond_token = lookup_commit_reference_gently(second_sha1, 0);\n\t\tif (!second_token)\n\t\t\tdie(_(\"'%s' is not a commit\"), argv[1]);\n\t\tif (hashcmp(second_token->object.sha1, head))\n\t\t\treturn NULL;\n\t}\n\treturn second_token;\n}\n\nstatic int evaluate_result(void)\n{\n\tint cnt = 0;\n\tstruct rev_info rev;\n\n\t/* Check how many files differ. */\n\tinit_revisions(&rev, \"\");\n\tsetup_revisions(0, NULL, &rev, NULL);\n\trev.diffopt.output_format |=\n\t\tDIFF_FORMAT_CALLBACK;\n\trev.diffopt.format_callback = count_diff_files;\n\trev.diffopt.format_callback_data = &cnt;\n\trun_diff_files(&rev, 0);\n\n\t/*\n\t * Check how many unmerged entries are\n\t * there.\n\t */\n\tcnt += count_unmerged_entries();\n\n\treturn cnt;\n}\n\n/*\n * Pretend as if the user told us to merge with the tracking\n * branch we have for the upstream of the current branch\n */\nstatic int setup_with_upstream(const char ***argv)\n{\n\tstruct branch *branch = branch_get(NULL);\n\tint i;\n\tconst char **args;\n\n\tif (!branch)\n\t\tdie(_(\"No current branch.\"));\n\tif (!branch->remote)\n\t\tdie(_(\"No remote for the current branch.\"));\n\tif (!branch->merge_nr)\n\t\tdie(_(\"No default upstream defined for the current branch.\"));\n\n\targs = xcalloc(branch->merge_nr + 1, sizeof(char *));\n\tfor (i = 0; i < branch->merge_nr; i++) {\n\t\tif (!branch->merge[i]->dst)\n\t\t\tdie(_(\"No remote tracking branch for %s from %s\"),\n\t\t\t    branch->merge[i]->src, branch->remote_name);\n\t\targs[i] = branch->merge[i]->dst;\n\t}\n\targs[i] = NULL;\n\t*argv = args;\n\treturn i;\n}\n\nstatic void write_merge_state(void)\n{\n\tint fd;\n\tstruct commit_list *j;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tfor (j = remoteheads; j; j = j->next) {\n\t\tunsigned const char *sha1;\n\t\tstruct commit *c = j->item;\n\t\tif (c->util && merge_remote_util(c)->obj) {\n\t\t\tsha1 = merge_remote_util(c)->obj->sha1;\n\t\t} else {\n\t\t\tsha1 = c->object.sha1;\n\t\t}\n\t\tstrbuf_addf(&buf, \"%s\\n\", sha1_to_hex(sha1));\n\t}\n\tfd = open(git_path(\"MERGE_HEAD\"), O_WRONLY | O_CREAT, 0666);\n\tif (fd < 0)\n\t\tdie_errno(_(\"Could not open '%s' for writing\"),\n\t\t\t  git_path(\"MERGE_HEAD\"));\n\tif (write_in_full(fd, buf.buf, buf.len) != buf.len)\n\t\tdie_errno(_(\"Could not write to '%s'\"), git_path(\"MERGE_HEAD\"));\n\tclose(fd);\n\tstrbuf_addch(&merge_msg, '\\n');\n\twrite_merge_msg(&merge_msg);\n\tfd = open(git_path(\"MERGE_MODE\"), O_WRONLY | O_CREAT | O_TRUNC, 0666);\n\tif (fd < 0)\n\t\tdie_errno(_(\"Could not open '%s' for writing\"),\n\t\t\t  git_path(\"MERGE_MODE\"));\n\tstrbuf_reset(&buf);\n\tif (!allow_fast_forward)\n\t\tstrbuf_addf(&buf, \"no-ff\");\n\tif (write_in_full(fd, buf.buf, buf.len) != buf.len)\n\t\tdie_errno(_(\"Could not write to '%s'\"), git_path(\"MERGE_MODE\"));\n\tclose(fd);\n}\n\nstatic int default_edit_option(void)\n{\n\tstatic const char name[] = \"GIT_MERGE_AUTOEDIT\";\n\tconst char *e = getenv(name);\n\tstruct stat st_stdin, st_stdout;\n\n\tif (have_message)\n\t\t/* an explicit -m msg without --[no-]edit */\n\t\treturn 0;\n\n\tif (e) {\n\t\tint v = git_config_maybe_bool(name, e);\n\t\tif (v < 0)\n\t\t\tdie(\"Bad value '%s' in environment '%s'\", e, name);\n\t\treturn v;\n\t}\n\n\t/* Use editor if stdin and stdout are the same and is a tty */\n\treturn (!fstat(0, &st_stdin) &&\n\t\t!fstat(1, &st_stdout) &&\n\t\tisatty(0) &&\n\t\tst_stdin.st_dev == st_stdout.st_dev &&\n\t\tst_stdin.st_ino == st_stdout.st_ino &&\n\t\tst_stdin.st_mode == st_stdout.st_mode);\n}\n\n\nint cmd_merge(int argc, const char **argv, const char *prefix)\n{\n\tunsigned char result_tree[20];\n\tunsigned char stash[20];\n\tunsigned char head_sha1[20];\n\tstruct commit *head_commit;\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *head_arg;\n\tint flag, i;\n\tint best_cnt = -1, merge_was_ok = 0, automerge_was_ok = 0;\n\tstruct commit_list *common = NULL;\n\tconst char *best_strategy = NULL, *wt_strategy = NULL;\n\tstruct commit_list **remotes = &remoteheads;\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_merge_usage, builtin_merge_options);\n\n\t/*\n\t * Check if we are _not_ on a detached HEAD, i.e. if there is a\n\t * current branch.\n\t */\n\tbranch = resolve_ref(\"HEAD\", head_sha1, 0, &flag);\n\tif (branch && !prefixcmp(branch, \"refs/heads/\"))\n\t\tbranch += 11;\n\tif (!branch || is_null_sha1(head_sha1))\n\t\thead_commit = NULL;\n\telse\n\t\thead_commit = lookup_commit_or_die(head_sha1, \"HEAD\");\n\n\tgit_config(git_merge_config, NULL);\n\n\tif (branch_mergeoptions)\n\t\tparse_branch_merge_options(branch_mergeoptions);\n\targc = parse_options(argc, argv, prefix, builtin_merge_options,\n\t\t\tbuiltin_merge_usage, 0);\n\n\tif (verbosity < 0 && show_progress == -1)\n\t\tshow_progress = 0;\n\n\tif (abort_current_merge) {\n\t\tint nargc = 2;\n\t\tconst char *nargv[] = {\"reset\", \"--merge\", NULL};\n\n\t\tif (!file_exists(git_path(\"MERGE_HEAD\")))\n\t\t\tdie(_(\"There is no merge to abort (MERGE_HEAD missing).\"));\n\n\t\t/* Invoke 'git reset --merge' */\n\t\treturn cmd_reset(nargc, nargv, prefix);\n\t}\n\n\tif (read_cache_unmerged())\n\t\tdie_resolve_conflict(\"merge\");\n\n\tif (file_exists(git_path(\"MERGE_HEAD\"))) {\n\t\t/*\n\t\t * There is no unmerged entry, don't advise 'git\n\t\t * add/rm <file>', just 'git commit'.\n\t\t */\n\t\tif (advice_resolve_conflict)\n\t\t\tdie(_(\"You have not concluded your merge (MERGE_HEAD exists).\\n\"\n\t\t\t\t  \"Please, commit your changes before you can merge.\"));\n\t\telse\n\t\t\tdie(_(\"You have not concluded your merge (MERGE_HEAD exists).\"));\n\t}\n\tif (file_exists(git_path(\"CHERRY_PICK_HEAD\"))) {\n\t\tif (advice_resolve_conflict)\n\t\t\tdie(_(\"You have not concluded your cherry-pick (CHERRY_PICK_HEAD exists).\\n\"\n\t\t\t    \"Please, commit your changes before you can merge.\"));\n\t\telse\n\t\t\tdie(_(\"You have not concluded your cherry-pick (CHERRY_PICK_HEAD exists).\"));\n\t}\n\tresolve_undo_clear();\n\n\tif (verbosity < 0)\n\t\tshow_diffstat = 0;\n\n\tif (squash) {\n\t\tif (!allow_fast_forward)\n\t\t\tdie(_(\"You cannot combine --squash with --no-ff.\"));\n\t\toption_commit = 0;\n\t}\n\n\tif (!allow_fast_forward && fast_forward_only)\n\t\tdie(_(\"You cannot combine --no-ff with --ff-only.\"));\n\n\tif (!abort_current_merge) {\n\t\tif (!argc && default_to_upstream)\n\t\t\targc = setup_with_upstream(&argv);\n\t\telse if (argc == 1 && !strcmp(argv[0], \"-\"))\n\t\t\targv[0] = \"@{-1}\";\n\t}\n\tif (!argc)\n\t\tusage_with_options(builtin_merge_usage,\n\t\t\tbuiltin_merge_options);\n\n\t/*\n\t * This could be traditional \"merge <msg> HEAD <commit>...\"  and\n\t * the way we can tell it is to see if the second token is HEAD,\n\t * but some people might have misused the interface and used a\n\t * committish that is the same as HEAD there instead.\n\t * Traditional format never would have \"-m\" so it is an\n\t * additional safety measure to check for it.\n\t */\n\n\tif (!have_message && head_commit &&\n\t    is_old_style_invocation(argc, argv, head_commit->object.sha1)) {\n\t\tstrbuf_addstr(&merge_msg, argv[0]);\n\t\thead_arg = argv[1];\n\t\targv += 2;\n\t\targc -= 2;\n\t} else if (!head_commit) {\n\t\tstruct commit *remote_head;\n\t\t/*\n\t\t * If the merged head is a valid one there is no reason\n\t\t * to forbid \"git merge\" into a branch yet to be born.\n\t\t * We do the same for \"git pull\".\n\t\t */\n\t\tif (argc != 1)\n\t\t\tdie(_(\"Can merge only exactly one commit into \"\n\t\t\t\t\"empty head\"));\n\t\tif (squash)\n\t\t\tdie(_(\"Squash commit into empty head not supported yet\"));\n\t\tif (!allow_fast_forward)\n\t\t\tdie(_(\"Non-fast-forward commit does not make sense into \"\n\t\t\t    \"an empty head\"));\n\t\tremote_head = get_merge_parent(argv[0]);\n\t\tif (!remote_head)\n\t\t\tdie(_(\"%s - not something we can merge\"), argv[0]);\n\t\tread_empty(remote_head->object.sha1, 0);\n\t\tupdate_ref(\"initial pull\", \"HEAD\", remote_head->object.sha1,\n\t\t\t   NULL, 0, DIE_ON_ERR);\n\t\treturn 0;\n\t} else {\n\t\tstruct strbuf merge_names = STRBUF_INIT;\n\n\t\t/* We are invoked directly as the first-class UI. */\n\t\thead_arg = \"HEAD\";\n\n\t\t/*\n\t\t * All the rest are the commits being merged; prepare\n\t\t * the standard merge summary message to be appended\n\t\t * to the given message.\n\t\t */\n\t\tfor (i = 0; i < argc; i++)\n\t\t\tmerge_name(argv[i], &merge_names);\n\n\t\tif (!have_message || shortlog_len) {\n\t\t\tstruct fmt_merge_msg_opts opts;\n\t\t\tmemset(&opts, 0, sizeof(opts));\n\t\t\topts.add_title = !have_message;\n\t\t\topts.shortlog_len = shortlog_len;\n\n\t\t\tfmt_merge_msg(&merge_names, &merge_msg, &opts);\n\t\t\tif (merge_msg.len)\n\t\t\t\tstrbuf_setlen(&merge_msg, merge_msg.len - 1);\n\t\t}\n\t}\n\n\tif (!head_commit || !argc)\n\t\tusage_with_options(builtin_merge_usage,\n\t\t\tbuiltin_merge_options);\n\n\tstrbuf_addstr(&buf, \"merge\");\n\tfor (i = 0; i < argc; i++)\n\t\tstrbuf_addf(&buf, \" %s\", argv[i]);\n\tsetenv(\"GIT_REFLOG_ACTION\", buf.buf, 0);\n\tstrbuf_reset(&buf);\n\n\tfor (i = 0; i < argc; i++) {\n\t\tstruct commit *commit = get_merge_parent(argv[i]);\n\t\tif (!commit)\n\t\t\tdie(_(\"%s - not something we can merge\"), argv[i]);\n\t\tremotes = &commit_list_insert(commit, remotes)->next;\n\t\tstrbuf_addf(&buf, \"GITHEAD_%s\",\n\t\t\t    sha1_to_hex(commit->object.sha1));\n\t\tsetenv(buf.buf, argv[i], 1);\n\t\tstrbuf_reset(&buf);\n\t\tif (merge_remote_util(commit) &&\n\t\t    merge_remote_util(commit)->obj &&\n\t\t    merge_remote_util(commit)->obj->type == OBJ_TAG) {\n\t\t\toption_edit = 1;\n\t\t\tallow_fast_forward = 0;\n\t\t}\n\t}\n\n\tif (option_edit < 0)\n\t\toption_edit = default_edit_option();\n\n\tif (!use_strategies) {\n\t\tif (!remoteheads->next)\n\t\t\tadd_strategies(pull_twohead, DEFAULT_TWOHEAD);\n\t\telse\n\t\t\tadd_strategies(pull_octopus, DEFAULT_OCTOPUS);\n\t}\n\n\tfor (i = 0; i < use_strategies_nr; i++) {\n\t\tif (use_strategies[i]->attr & NO_FAST_FORWARD)\n\t\t\tallow_fast_forward = 0;\n\t\tif (use_strategies[i]->attr & NO_TRIVIAL)\n\t\t\tallow_trivial = 0;\n\t}\n\n\tif (!remoteheads->next)\n\t\tcommon = get_merge_bases(head_commit, remoteheads->item, 1);\n\telse {\n\t\tstruct commit_list *list = remoteheads;\n\t\tcommit_list_insert(head_commit, &list);\n\t\tcommon = get_octopus_merge_bases(list);\n\t\tfree(list);\n\t}\n\n\tupdate_ref(\"updating ORIG_HEAD\", \"ORIG_HEAD\", head_commit->object.sha1,\n\t\t   NULL, 0, DIE_ON_ERR);\n\n\tif (!common)\n\t\t; /* No common ancestors found. We need a real merge. */\n\telse if (!remoteheads->next && !common->next &&\n\t\t\tcommon->item == remoteheads->item) {\n\t\t/*\n\t\t * If head can reach all the merge then we are up to date.\n\t\t * but first the most common case of merging one remote.\n\t\t */\n\t\tfinish_up_to_date(\"Already up-to-date.\");\n\t\treturn 0;\n\t} else if (allow_fast_forward && !remoteheads->next &&\n\t\t\t!common->next &&\n\t\t\t!hashcmp(common->item->object.sha1, head_commit->object.sha1)) {\n\t\t/* Again the most common case of merging one remote. */\n\t\tstruct strbuf msg = STRBUF_INIT;\n\t\tstruct commit *commit;\n\t\tchar hex[41];\n\n\t\tstrcpy(hex, find_unique_abbrev(head_commit->object.sha1, DEFAULT_ABBREV));\n\n\t\tif (verbosity >= 0)\n\t\t\tprintf(_(\"Updating %s..%s\\n\"),\n\t\t\t\thex,\n\t\t\t\tfind_unique_abbrev(remoteheads->item->object.sha1,\n\t\t\t\tDEFAULT_ABBREV));\n\t\tstrbuf_addstr(&msg, \"Fast-forward\");\n\t\tif (have_message)\n\t\t\tstrbuf_addstr(&msg,\n\t\t\t\t\" (no commit created; -m option ignored)\");\n\t\tcommit = remoteheads->item;\n\t\tif (!commit)\n\t\t\treturn 1;\n\n\t\tif (checkout_fast_forward(head_commit->object.sha1,\n\t\t\t\t\t  commit->object.sha1))\n\t\t\treturn 1;\n\n\t\tfinish(head_commit, commit->object.sha1, msg.buf);\n\t\tdrop_save();\n\t\treturn 0;\n\t} else if (!remoteheads->next && common->next)\n\t\t;\n\t\t/*\n\t\t * We are not doing octopus and not fast-forward.  Need\n\t\t * a real merge.\n\t\t */\n\telse if (!remoteheads->next && !common->next && option_commit) {\n\t\t/*\n\t\t * We are not doing octopus, not fast-forward, and have\n\t\t * only one common.\n\t\t */\n\t\trefresh_cache(REFRESH_QUIET);\n\t\tif (allow_trivial && !fast_forward_only) {\n\t\t\t/* See if it is really trivial. */\n\t\t\tgit_committer_info(IDENT_ERROR_ON_NO_NAME);\n\t\t\tprintf(_(\"Trying really trivial in-index merge...\\n\"));\n\t\t\tif (!read_tree_trivial(common->item->object.sha1,\n\t\t\t\t\thead_commit->object.sha1, remoteheads->item->object.sha1))\n\t\t\t\treturn merge_trivial(head_commit);\n\t\t\tprintf(_(\"Nope.\\n\"));\n\t\t}\n\t} else {\n\t\t/*\n\t\t * An octopus.  If we can reach all the remote we are up\n\t\t * to date.\n\t\t */\n\t\tint up_to_date = 1;\n\t\tstruct commit_list *j;\n\n\t\tfor (j = remoteheads; j; j = j->next) {\n\t\t\tstruct commit_list *common_one;\n\n\t\t\t/*\n\t\t\t * Here we *have* to calculate the individual\n\t\t\t * merge_bases again, otherwise \"git merge HEAD^\n\t\t\t * HEAD^^\" would be missed.\n\t\t\t */\n\t\t\tcommon_one = get_merge_bases(head_commit, j->item, 1);\n\t\t\tif (hashcmp(common_one->item->object.sha1,\n\t\t\t\tj->item->object.sha1)) {\n\t\t\t\tup_to_date = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (up_to_date) {\n\t\t\tfinish_up_to_date(\"Already up-to-date. Yeeah!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (fast_forward_only)\n\t\tdie(_(\"Not possible to fast-forward, aborting.\"));\n\n\t/* We are going to make a new commit. */\n\tgit_committer_info(IDENT_ERROR_ON_NO_NAME);\n\n\t/*\n\t * At this point, we need a real merge.  No matter what strategy\n\t * we use, it would operate on the index, possibly affecting the\n\t * working tree, and when resolved cleanly, have the desired\n\t * tree in the index -- this means that the index must be in\n\t * sync with the head commit.  The strategies are responsible\n\t * to ensure this.\n\t */\n\tif (use_strategies_nr == 1 ||\n\t    /*\n\t     * Stash away the local changes so that we can try more than one.\n\t     */\n\t    save_state(stash))\n\t\thashcpy(stash, null_sha1);\n\n\tfor (i = 0; i < use_strategies_nr; i++) {\n\t\tint ret;\n\t\tif (i) {\n\t\t\tprintf(_(\"Rewinding the tree to pristine...\\n\"));\n\t\t\trestore_state(head_commit->object.sha1, stash);\n\t\t}\n\t\tif (use_strategies_nr != 1)\n\t\t\tprintf(_(\"Trying merge strategy %s...\\n\"),\n\t\t\t\tuse_strategies[i]->name);\n\t\t/*\n\t\t * Remember which strategy left the state in the working\n\t\t * tree.\n\t\t */\n\t\twt_strategy = use_strategies[i]->name;\n\n\t\tret = try_merge_strategy(use_strategies[i]->name,\n\t\t\t\t\t common, head_commit, head_arg);\n\t\tif (!option_commit && !ret) {\n\t\t\tmerge_was_ok = 1;\n\t\t\t/*\n\t\t\t * This is necessary here just to avoid writing\n\t\t\t * the tree, but later we will *not* exit with\n\t\t\t * status code 1 because merge_was_ok is set.\n\t\t\t */\n\t\t\tret = 1;\n\t\t}\n\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * The backend exits with 1 when conflicts are\n\t\t\t * left to be resolved, with 2 when it does not\n\t\t\t * handle the given merge at all.\n\t\t\t */\n\t\t\tif (ret == 1) {\n\t\t\t\tint cnt = evaluate_result();\n\n\t\t\t\tif (best_cnt <= 0 || cnt <= best_cnt) {\n\t\t\t\t\tbest_strategy = use_strategies[i]->name;\n\t\t\t\t\tbest_cnt = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (merge_was_ok)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Automerge succeeded. */\n\t\twrite_tree_trivial(result_tree);\n\t\tautomerge_was_ok = 1;\n\t\tbreak;\n\t}\n\n\t/*\n\t * If we have a resulting tree, that means the strategy module\n\t * auto resolved the merge cleanly.\n\t */\n\tif (automerge_was_ok)\n\t\treturn finish_automerge(head_commit, common, result_tree,\n\t\t\t\t\twt_strategy);\n\n\t/*\n\t * Pick the result from the best strategy and have the user fix\n\t * it up.\n\t */\n\tif (!best_strategy) {\n\t\trestore_state(head_commit->object.sha1, stash);\n\t\tif (use_strategies_nr > 1)\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"No merge strategy handled the merge.\\n\"));\n\t\telse\n\t\t\tfprintf(stderr, _(\"Merge with strategy %s failed.\\n\"),\n\t\t\t\tuse_strategies[0]->name);\n\t\treturn 2;\n\t} else if (best_strategy == wt_strategy)\n\t\t; /* We already have its result in the working tree. */\n\telse {\n\t\tprintf(_(\"Rewinding the tree to pristine...\\n\"));\n\t\trestore_state(head_commit->object.sha1, stash);\n\t\tprintf(_(\"Using the %s to prepare resolving by hand.\\n\"),\n\t\t\tbest_strategy);\n\t\ttry_merge_strategy(best_strategy, common, head_commit, head_arg);\n\t}\n\n\tif (squash)\n\t\tfinish(head_commit, NULL, NULL);\n\telse\n\t\twrite_merge_state();\n\n\tif (merge_was_ok) {\n\t\tfprintf(stderr, _(\"Automatic merge went well; \"\n\t\t\t\"stopped before committing as requested\\n\"));\n\t\treturn 0;\n\t} else\n\t\treturn suggest_conflicts(option_renormalize);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0006175d15a341793392296a8097cef905f2fa63",
  "sha1_ok": false,
  "size": 41113
}
