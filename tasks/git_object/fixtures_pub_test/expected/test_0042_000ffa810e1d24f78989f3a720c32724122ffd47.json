{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJkaXIuaCIKI2luY2x1ZGUgInN0cmluZy1saXN0LmgiCgpzdGF0aWMgaW50IGluc2lkZV9naXRfZGlyID0gLTE7CnN0YXRpYyBpbnQgaW5zaWRlX3dvcmtfdHJlZSA9IC0xOwpzdGF0aWMgaW50IHdvcmtfdHJlZV9jb25maWdfaXNfYm9ndXM7CgpzdGF0aWMgc3RydWN0IHN0YXJ0dXBfaW5mbyB0aGVfc3RhcnR1cF9pbmZvOwpzdHJ1Y3Qgc3RhcnR1cF9pbmZvICpzdGFydHVwX2luZm8gPSAmdGhlX3N0YXJ0dXBfaW5mbzsKCi8qCiAqIFRoZSBpbnB1dCBwYXJhbWV0ZXIgbXVzdCBjb250YWluIGFuIGFic29sdXRlIHBhdGgsIGFuZCBpdCBtdXN0IGFscmVhZHkgYmUKICogbm9ybWFsaXplZC4KICoKICogRmluZCB0aGUgcGFydCBvZiBhbiBhYnNvbHV0ZSBwYXRoIHRoYXQgbGllcyBpbnNpZGUgdGhlIHdvcmsgdHJlZSBieQogKiBkZXJlZmVyZW5jaW5nIHN5bWxpbmtzIG91dHNpZGUgdGhlIHdvcmsgdHJlZSwgZm9yIGV4YW1wbGU6CiAqIC9kaXIxL3JlcG8vZGlyMi9maWxlICAgKHdvcmsgdHJlZSBpcyAvZGlyMS9yZXBvKSAgICAgIC0+IGRpcjIvZmlsZQogKiAvZGlyL2ZpbGUgICAgICAgICAgICAgICh3b3JrIHRyZWUgaXMgLykgICAgICAgICAgICAgICAtPiBkaXIvZmlsZQogKiAvZGlyL3N5bWxpbmsxL3N5bWxpbmsyIChzeW1saW5rMSBwb2ludHMgdG8gd29yayB0cmVlKSAtPiBzeW1saW5rMgogKiAvZGlyL3JlcG9saW5rL2ZpbGUgICAgIChyZXBvbGluayBwb2ludHMgdG8gL2Rpci9yZXBvKSAtPiBmaWxlCiAqIC9kaXIvcmVwbyAgICAgICAgICAgICAgKGV4YWN0bHkgZXF1YWwgdG8gd29yayB0cmVlKSAgIC0+IChlbXB0eSBzdHJpbmcpCiAqLwpzdGF0aWMgaW50IGFic3BhdGhfcGFydF9pbnNpZGVfcmVwbyhjaGFyICpwYXRoKQp7CglzaXplX3QgbGVuOwoJc2l6ZV90IHd0bGVuOwoJY2hhciAqcGF0aDA7CglpbnQgb2ZmOwoJY29uc3QgY2hhciAqd29ya190cmVlID0gZ2V0X2dpdF93b3JrX3RyZWUoKTsKCglpZiAoIXdvcmtfdHJlZSkKCQlyZXR1cm4gLTE7Cgl3dGxlbiA9IHN0cmxlbih3b3JrX3RyZWUpOwoJbGVuID0gc3RybGVuKHBhdGgpOwoJb2ZmID0gb2Zmc2V0XzFzdF9jb21wb25lbnQocGF0aCk7CgoJLyogY2hlY2sgaWYgd29yayB0cmVlIGlzIGFscmVhZHkgdGhlIHByZWZpeCAqLwoJaWYgKHd0bGVuIDw9IGxlbiAmJiAhc3RybmNtcChwYXRoLCB3b3JrX3RyZWUsIHd0bGVuKSkgewoJCWlmIChwYXRoW3d0bGVuXSA9PSAnLycpIHsKCQkJbWVtbW92ZShwYXRoLCBwYXRoICsgd3RsZW4gKyAxLCBsZW4gLSB3dGxlbik7CgkJCXJldHVybiAwOwoJCX0gZWxzZSBpZiAocGF0aFt3dGxlbiAtIDFdID09ICcvJyB8fCBwYXRoW3d0bGVuXSA9PSAnXDAnKSB7CgkJCS8qIHdvcmsgdHJlZSBpcyB0aGUgcm9vdCwgb3IgdGhlIHdob2xlIHBhdGggKi8KCQkJbWVtbW92ZShwYXRoLCBwYXRoICsgd3RsZW4sIGxlbiAtIHd0bGVuICsgMSk7CgkJCXJldHVybiAwOwoJCX0KCQkvKiB3b3JrIHRyZWUgbWlnaHQgbWF0Y2ggYmVnaW5uaW5nIG9mIGEgc3ltbGluayB0byB3b3JrIHRyZWUgKi8KCQlvZmYgPSB3dGxlbjsKCX0KCXBhdGgwID0gcGF0aDsKCXBhdGggKz0gb2ZmOwoKCS8qIGNoZWNrIGVhY2ggJy8nLXRlcm1pbmF0ZWQgbGV2ZWwgKi8KCXdoaWxlICgqcGF0aCkgewoJCXBhdGgrKzsKCQlpZiAoKnBhdGggPT0gJy8nKSB7CgkJCSpwYXRoID0gJ1wwJzsKCQkJaWYgKHN0cmNtcChyZWFsX3BhdGgocGF0aDApLCB3b3JrX3RyZWUpID09IDApIHsKCQkJCW1lbW1vdmUocGF0aDAsIHBhdGggKyAxLCBsZW4gLSAocGF0aCAtIHBhdGgwKSk7CgkJCQlyZXR1cm4gMDsKCQkJfQoJCQkqcGF0aCA9ICcvJzsKCQl9Cgl9CgoJLyogY2hlY2sgd2hvbGUgcGF0aCAqLwoJaWYgKHN0cmNtcChyZWFsX3BhdGgocGF0aDApLCB3b3JrX3RyZWUpID09IDApIHsKCQkqcGF0aDAgPSAnXDAnOwoJCXJldHVybiAwOwoJfQoKCXJldHVybiAtMTsKfQoKLyoKICogTm9ybWFsaXplICJwYXRoIiwgcHJlcGVuZGluZyB0aGUgInByZWZpeCIgZm9yIHJlbGF0aXZlIHBhdGhzLiBJZgogKiByZW1haW5pbmdfcHJlZml4IGlzIG5vdCBOVUxMLCByZXR1cm4gdGhlIGFjdHVhbCBwcmVmaXggc3RpbGwKICogcmVtYWlucyBpbiB0aGUgcGF0aC4gRm9yIGV4YW1wbGUsIHByZWZpeCA9IHN1YjEvc3ViMi8gYW5kIHBhdGggaXMKICoKICogIGZvbyAgICAgICAgICAtPiBzdWIxL3N1YjIvZm9vICAoZnVsbCBwcmVmaXgpCiAqICAuLi9mb28gICAgICAgLT4gc3ViMS9mb28gICAgICAgKHJlbWFpbmluZyBwcmVmaXggaXMgc3ViMS8pCiAqICAuLi8uLi9iYXIgICAgLT4gYmFyICAgICAgICAgICAgKG5vIHJlbWFpbmluZyBwcmVmaXgpCiAqICAuLi8uLi9zdWIxL3N1YjIvZm9vIC0+IHN1YjEvc3ViMi9mb28gKGJ1dCBubyByZW1haW5pbmcgcHJlZml4KQogKiAgYHB3ZGAvLi4vYmFyIC0+IHN1YjEvYmFyICAgICAgIChubyByZW1haW5pbmcgcHJlZml4KQogKi8KY2hhciAqcHJlZml4X3BhdGhfZ2VudGx5KGNvbnN0IGNoYXIgKnByZWZpeCwgaW50IGxlbiwKCQkJIGludCAqcmVtYWluaW5nX3ByZWZpeCwgY29uc3QgY2hhciAqcGF0aCkKewoJY29uc3QgY2hhciAqb3JpZyA9IHBhdGg7CgljaGFyICpzYW5pdGl6ZWQ7CglpZiAoaXNfYWJzb2x1dGVfcGF0aChvcmlnKSkgewoJCXNhbml0aXplZCA9IHhtYWxsb2N6KHN0cmxlbihwYXRoKSk7CgkJaWYgKHJlbWFpbmluZ19wcmVmaXgpCgkJCSpyZW1haW5pbmdfcHJlZml4ID0gMDsKCQlpZiAobm9ybWFsaXplX3BhdGhfY29weV9sZW4oc2FuaXRpemVkLCBwYXRoLCByZW1haW5pbmdfcHJlZml4KSkgewoJCQlmcmVlKHNhbml0aXplZCk7CgkJCXJldHVybiBOVUxMOwoJCX0KCQlpZiAoYWJzcGF0aF9wYXJ0X2luc2lkZV9yZXBvKHNhbml0aXplZCkpIHsKCQkJZnJlZShzYW5pdGl6ZWQpOwoJCQlyZXR1cm4gTlVMTDsKCQl9Cgl9IGVsc2UgewoJCXNhbml0aXplZCA9IHhzdHJmbXQoIiUuKnMlcyIsIGxlbiwgbGVuID8gcHJlZml4IDogIiIsIHBhdGgpOwoJCWlmIChyZW1haW5pbmdfcHJlZml4KQoJCQkqcmVtYWluaW5nX3ByZWZpeCA9IGxlbjsKCQlpZiAobm9ybWFsaXplX3BhdGhfY29weV9sZW4oc2FuaXRpemVkLCBzYW5pdGl6ZWQsIHJlbWFpbmluZ19wcmVmaXgpKSB7CgkJCWZyZWUoc2FuaXRpemVkKTsKCQkJcmV0dXJuIE5VTEw7CgkJfQoJfQoJcmV0dXJuIHNhbml0aXplZDsKfQoKY2hhciAqcHJlZml4X3BhdGgoY29uc3QgY2hhciAqcHJlZml4LCBpbnQgbGVuLCBjb25zdCBjaGFyICpwYXRoKQp7CgljaGFyICpyID0gcHJlZml4X3BhdGhfZ2VudGx5KHByZWZpeCwgbGVuLCBOVUxMLCBwYXRoKTsKCWlmICghcikKCQlkaWUoIiclcycgaXMgb3V0c2lkZSByZXBvc2l0b3J5IiwgcGF0aCk7CglyZXR1cm4gcjsKfQoKaW50IHBhdGhfaW5zaWRlX3JlcG8oY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCBjaGFyICpwYXRoKQp7CglpbnQgbGVuID0gcHJlZml4ID8gc3RybGVuKHByZWZpeCkgOiAwOwoJY2hhciAqciA9IHByZWZpeF9wYXRoX2dlbnRseShwcmVmaXgsIGxlbiwgTlVMTCwgcGF0aCk7CglpZiAocikgewoJCWZyZWUocik7CgkJcmV0dXJuIDE7Cgl9CglyZXR1cm4gMDsKfQoKaW50IGNoZWNrX2ZpbGVuYW1lKGNvbnN0IGNoYXIgKnByZWZpeCwgY29uc3QgY2hhciAqYXJnKQp7CgljaGFyICp0b19mcmVlID0gTlVMTDsKCXN0cnVjdCBzdGF0IHN0OwoKCWlmIChzdGFydHNfd2l0aChhcmcsICI6LyIpKSB7CgkJaWYgKGFyZ1syXSA9PSAnXDAnKSAvKiAiOi8iIGlzIHJvb3QgZGlyLCBhbHdheXMgZXhpc3RzICovCgkJCXJldHVybiAxOwoJCWFyZyArPSAyOwoJCXByZWZpeCA9IE5VTEw7Cgl9CgoJaWYgKHByZWZpeCkKCQlhcmcgPSB0b19mcmVlID0gcHJlZml4X2ZpbGVuYW1lKHByZWZpeCwgYXJnKTsKCglpZiAoIWxzdGF0KGFyZywgJnN0KSkgewoJCWZyZWUodG9fZnJlZSk7CgkJcmV0dXJuIDE7IC8qIGZpbGUgZXhpc3RzICovCgl9CglpZiAoZXJybm8gPT0gRU5PRU5UIHx8IGVycm5vID09IEVOT1RESVIpIHsKCQlmcmVlKHRvX2ZyZWUpOwoJCXJldHVybiAwOyAvKiBmaWxlIGRvZXMgbm90IGV4aXN0ICovCgl9CglkaWVfZXJybm8oImZhaWxlZCB0byBzdGF0ICclcyciLCBhcmcpOwp9CgpzdGF0aWMgdm9pZCBOT1JFVFVSTiBkaWVfdmVyaWZ5X2ZpbGVuYW1lKGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJCQkgY29uc3QgY2hhciAqYXJnLAoJCQkJCSBpbnQgZGlhZ25vc2VfbWlzc3BlbHRfcmV2KQp7CglpZiAoIWRpYWdub3NlX21pc3NwZWx0X3JldikKCQlkaWUoXygiJXM6IG5vIHN1Y2ggcGF0aCBpbiB0aGUgd29ya2luZyB0cmVlLlxuIgoJCSAgICAgICJVc2UgJ2dpdCA8Y29tbWFuZD4gLS0gPHBhdGg+Li4uJyB0byBzcGVjaWZ5IHBhdGhzIHRoYXQgZG8gbm90IGV4aXN0IGxvY2FsbHkuIiksCgkJICAgIGFyZyk7CgkvKgoJICogU2F5aW5nICInKGljYXNlKWZvbycgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGluZGV4IiB3aGVuIHRoZQoJICogdXNlciBnYXZlIHVzICI6KGljYXNlKWZvbyIgaXMganVzdCBzdHVwaWQuICBBIG1hZ2ljIHBhdGhzcGVjCgkgKiBiZWdpbnMgd2l0aCBhIGNvbG9uIGFuZCBpcyBmb2xsb3dlZCBieSBhIG5vbi1hbG51bTsgZG8gbm90CgkgKiBsZXQgbWF5YmVfZGllX29uX21pc3NwZWx0X29iamVjdF9uYW1lKCkgZXZlbiB0cmlnZ2VyLgoJICovCglpZiAoIShhcmdbMF0gPT0gJzonICYmICFpc2FsbnVtKGFyZ1sxXSkpKQoJCW1heWJlX2RpZV9vbl9taXNzcGVsdF9vYmplY3RfbmFtZShhcmcsIHByZWZpeCk7CgoJLyogLi4uIG9yIGZhbGwgYmFjayB0aGUgbW9zdCBnZW5lcmFsIG1lc3NhZ2UuICovCglkaWUoXygiYW1iaWd1b3VzIGFyZ3VtZW50ICclcyc6IHVua25vd24gcmV2aXNpb24gb3IgcGF0aCBub3QgaW4gdGhlIHdvcmtpbmcgdHJlZS5cbiIKCSAgICAgICJVc2UgJy0tJyB0byBzZXBhcmF0ZSBwYXRocyBmcm9tIHJldmlzaW9ucywgbGlrZSB0aGlzOlxuIgoJICAgICAgIidnaXQgPGNvbW1hbmQ+IFs8cmV2aXNpb24+Li4uXSAtLSBbPGZpbGU+Li4uXSciKSwgYXJnKTsKCn0KCi8qCiAqIFZlcmlmeSBhIGZpbGVuYW1lIHRoYXQgd2UgZ290IGFzIGFuIGFyZ3VtZW50IGZvciBhIHBhdGhzcGVjCiAqIGVudHJ5LiBOb3RlIHRoYXQgYSBmaWxlbmFtZSB0aGF0IGJlZ2lucyB3aXRoICItIiBuZXZlciB2ZXJpZmllcwogKiBhcyB0cnVlLCBiZWNhdXNlIGV2ZW4gaWYgc3VjaCBhIGZpbGVuYW1lIHdlcmUgdG8gZXhpc3QsIHdlIHdhbnQKICogaXQgdG8gYmUgcHJlY2VkZWQgYnkgdGhlICItLSIgbWFya2VyIChvciB3ZSB3YW50IHRoZSB1c2VyIHRvCiAqIHVzZSBhIGZvcm1hdCBsaWtlICIuLy1maWxlbmFtZSIpCiAqCiAqIFRoZSAiZGlhZ25vc2VfbWlzc3BlbHRfcmV2IiBpcyB1c2VkIHRvIHByb3ZpZGUgYSB1c2VyLWZyaWVuZGx5CiAqIGRpYWdub3NpcyB3aGVuIGR5aW5nIHVwb24gZmluZGluZyB0aGF0ICJuYW1lIiBpcyBub3QgYSBwYXRobmFtZS4KICogSWYgc2V0IHRvIDEsIHRoZSBkaWFnbm9zaXMgd2lsbCB0cnkgdG8gZGlhZ25vc2UgIm5hbWUiIGFzIGFuCiAqIGludmFsaWQgb2JqZWN0IG5hbWUgKGUuZy4gSEVBRDpmb28pLiBJZiBzZXQgdG8gMCwgdGhlIGRpYWdub3NpcwogKiB3aWxsIG9ubHkgY29tcGxhaW4gYWJvdXQgYW4gaW5leGlzdGluZyBmaWxlLgogKgogKiBUaGlzIGZ1bmN0aW9uIGlzIHR5cGljYWxseSBjYWxsZWQgdG8gY2hlY2sgdGhhdCBhICJmaWxlIG9yIHJldiIKICogYXJndW1lbnQgaXMgdW5hbWJpZ3VvdXMuIEluIHRoaXMgY2FzZSwgdGhlIGNhbGxlciB3aWxsIHdhbnQKICogZGlhZ25vc2VfbWlzc3BlbHRfcmV2ID09IDEgd2hlbiB2ZXJpZnlpbmcgdGhlIGZpcnN0IG5vbi1yZXYKICogYXJndW1lbnQgKHdoaWNoIGNvdWxkIGhhdmUgYmVlbiBhIHJldmlzaW9uKSwgYW5kCiAqIGRpYWdub3NlX21pc3NwZWx0X3JldiA9PSAwIGZvciB0aGUgbmV4dCBvbmVzIChiZWNhdXNlIHdlIGFscmVhZHkKICogc2F3IGEgZmlsZW5hbWUsIHRoZXJlJ3Mgbm90IGFtYmlndWl0eSBhbnltb3JlKS4KICovCnZvaWQgdmVyaWZ5X2ZpbGVuYW1lKGNvbnN0IGNoYXIgKnByZWZpeCwKCQkgICAgIGNvbnN0IGNoYXIgKmFyZywKCQkgICAgIGludCBkaWFnbm9zZV9taXNzcGVsdF9yZXYpCnsKCWlmICgqYXJnID09ICctJykKCQlkaWUoImJhZCBmbGFnICclcycgdXNlZCBhZnRlciBmaWxlbmFtZSIsIGFyZyk7CglpZiAoY2hlY2tfZmlsZW5hbWUocHJlZml4LCBhcmcpIHx8ICFub193aWxkY2FyZChhcmcpKQoJCXJldHVybjsKCWRpZV92ZXJpZnlfZmlsZW5hbWUocHJlZml4LCBhcmcsIGRpYWdub3NlX21pc3NwZWx0X3Jldik7Cn0KCi8qCiAqIE9wcG9zaXRlIG9mIHRoZSBhYm92ZTogdGhlIGNvbW1hbmQgbGluZSBkaWQgbm90IGhhdmUgLS0gbWFya2VyCiAqIGFuZCB3ZSBwYXJzZWQgdGhlIGFyZyBhcyBhIHJlZm5hbWUuICBJdCBzaG91bGQgbm90IGJlIGludGVycHJldGFibGUKICogYXMgYSBmaWxlbmFtZS4KICovCnZvaWQgdmVyaWZ5X25vbl9maWxlbmFtZShjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IGNoYXIgKmFyZykKewoJaWYgKCFpc19pbnNpZGVfd29ya190cmVlKCkgfHwgaXNfaW5zaWRlX2dpdF9kaXIoKSkKCQlyZXR1cm47CglpZiAoKmFyZyA9PSAnLScpCgkJcmV0dXJuOyAvKiBmbGFnICovCglpZiAoIWNoZWNrX2ZpbGVuYW1lKHByZWZpeCwgYXJnKSkKCQlyZXR1cm47CglkaWUoXygiYW1iaWd1b3VzIGFyZ3VtZW50ICclcyc6IGJvdGggcmV2aXNpb24gYW5kIGZpbGVuYW1lXG4iCgkgICAgICAiVXNlICctLScgdG8gc2VwYXJhdGUgcGF0aHMgZnJvbSByZXZpc2lvbnMsIGxpa2UgdGhpczpcbiIKCSAgICAgICInZ2l0IDxjb21tYW5kPiBbPHJldmlzaW9uPi4uLl0gLS0gWzxmaWxlPi4uLl0nIiksIGFyZyk7Cn0KCmludCBnZXRfY29tbW9uX2RpcihzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqZ2l0ZGlyKQp7Cgljb25zdCBjaGFyICpnaXRfZW52X2NvbW1vbl9kaXIgPSBnZXRlbnYoR0lUX0NPTU1PTl9ESVJfRU5WSVJPTk1FTlQpOwoJaWYgKGdpdF9lbnZfY29tbW9uX2RpcikgewoJCXN0cmJ1Zl9hZGRzdHIoc2IsIGdpdF9lbnZfY29tbW9uX2Rpcik7CgkJcmV0dXJuIDE7Cgl9IGVsc2UgewoJCXJldHVybiBnZXRfY29tbW9uX2Rpcl9ub2VudihzYiwgZ2l0ZGlyKTsKCX0KfQoKaW50IGdldF9jb21tb25fZGlyX25vZW52KHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpnaXRkaXIpCnsKCXN0cnVjdCBzdHJidWYgZGF0YSA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBwYXRoID0gU1RSQlVGX0lOSVQ7CglpbnQgcmV0ID0gMDsKCglzdHJidWZfYWRkZigmcGF0aCwgIiVzL2NvbW1vbmRpciIsIGdpdGRpcik7CglpZiAoZmlsZV9leGlzdHMocGF0aC5idWYpKSB7CgkJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJmRhdGEsIHBhdGguYnVmLCAwKSA8PSAwKQoJCQlkaWVfZXJybm8oXygiZmFpbGVkIHRvIHJlYWQgJXMiKSwgcGF0aC5idWYpOwoJCXdoaWxlIChkYXRhLmxlbiAmJiAoZGF0YS5idWZbZGF0YS5sZW4gLSAxXSA9PSAnXG4nIHx8CgkJCQkgICAgZGF0YS5idWZbZGF0YS5sZW4gLSAxXSA9PSAnXHInKSkKCQkJZGF0YS5sZW4tLTsKCQlkYXRhLmJ1ZltkYXRhLmxlbl0gPSAnXDAnOwoJCXN0cmJ1Zl9yZXNldCgmcGF0aCk7CgkJaWYgKCFpc19hYnNvbHV0ZV9wYXRoKGRhdGEuYnVmKSkKCQkJc3RyYnVmX2FkZGYoJnBhdGgsICIlcy8iLCBnaXRkaXIpOwoJCXN0cmJ1Zl9hZGRidWYoJnBhdGgsICZkYXRhKTsKCQlzdHJidWZfYWRkX3JlYWxfcGF0aChzYiwgcGF0aC5idWYpOwoJCXJldCA9IDE7Cgl9IGVsc2UgewoJCXN0cmJ1Zl9hZGRzdHIoc2IsIGdpdGRpcik7Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJmRhdGEpOwoJc3RyYnVmX3JlbGVhc2UoJnBhdGgpOwoJcmV0dXJuIHJldDsKfQoKLyoKICogVGVzdCBpZiBpdCBsb29rcyBsaWtlIHdlJ3JlIGF0IGEgZ2l0IGRpcmVjdG9yeS4KICogV2Ugd2FudCB0byBzZWU6CiAqCiAqICAtIGVpdGhlciBhbiBvYmplY3RzLyBkaXJlY3RvcnkgX29yXyB0aGUgcHJvcGVyCiAqICAgIEdJVF9PQkpFQ1RfRElSRUNUT1JZIGVudmlyb25tZW50IHZhcmlhYmxlCiAqICAtIGEgcmVmcy8gZGlyZWN0b3J5CiAqICAtIGVpdGhlciBhIEhFQUQgc3ltbGluayBvciBhIEhFQUQgZmlsZSB0aGF0IGlzIGZvcm1hdHRlZCBhcwogKiAgICBhIHByb3BlciAicmVmOiIsIG9yIGEgcmVndWxhciBmaWxlIEhFQUQgdGhhdCBoYXMgYSBwcm9wZXJseQogKiAgICBmb3JtYXR0ZWQgc2hhMSBvYmplY3QgbmFtZS4KICovCmludCBpc19naXRfZGlyZWN0b3J5KGNvbnN0IGNoYXIgKnN1c3BlY3QpCnsKCXN0cnVjdCBzdHJidWYgcGF0aCA9IFNUUkJVRl9JTklUOwoJaW50IHJldCA9IDA7CglzaXplX3QgbGVuOwoKCS8qIENoZWNrIHdvcmt0cmVlLXJlbGF0ZWQgc2lnbmF0dXJlcyAqLwoJc3RyYnVmX2FkZGYoJnBhdGgsICIlcy9IRUFEIiwgc3VzcGVjdCk7CglpZiAodmFsaWRhdGVfaGVhZHJlZihwYXRoLmJ1ZikpCgkJZ290byBkb25lOwoKCXN0cmJ1Zl9yZXNldCgmcGF0aCk7CglnZXRfY29tbW9uX2RpcigmcGF0aCwgc3VzcGVjdCk7CglsZW4gPSBwYXRoLmxlbjsKCgkvKiBDaGVjayBub24td29ya3RyZWUtcmVsYXRlZCBzaWduYXR1cmVzICovCglpZiAoZ2V0ZW52KERCX0VOVklST05NRU5UKSkgewoJCWlmIChhY2Nlc3MoZ2V0ZW52KERCX0VOVklST05NRU5UKSwgWF9PSykpCgkJCWdvdG8gZG9uZTsKCX0KCWVsc2UgewoJCXN0cmJ1Zl9zZXRsZW4oJnBhdGgsIGxlbik7CgkJc3RyYnVmX2FkZHN0cigmcGF0aCwgIi9vYmplY3RzIik7CgkJaWYgKGFjY2VzcyhwYXRoLmJ1ZiwgWF9PSykpCgkJCWdvdG8gZG9uZTsKCX0KCglzdHJidWZfc2V0bGVuKCZwYXRoLCBsZW4pOwoJc3RyYnVmX2FkZHN0cigmcGF0aCwgIi9yZWZzIik7CglpZiAoYWNjZXNzKHBhdGguYnVmLCBYX09LKSkKCQlnb3RvIGRvbmU7CgoJcmV0ID0gMTsKZG9uZToKCXN0cmJ1Zl9yZWxlYXNlKCZwYXRoKTsKCXJldHVybiByZXQ7Cn0KCmludCBpc19ub25iYXJlX3JlcG9zaXRvcnlfZGlyKHN0cnVjdCBzdHJidWYgKnBhdGgpCnsKCWludCByZXQgPSAwOwoJaW50IGdpdGZpbGVfZXJyb3I7CglzaXplX3Qgb3JpZ19wYXRoX2xlbiA9IHBhdGgtPmxlbjsKCWFzc2VydChvcmlnX3BhdGhfbGVuICE9IDApOwoJc3RyYnVmX2NvbXBsZXRlKHBhdGgsICcvJyk7CglzdHJidWZfYWRkc3RyKHBhdGgsICIuZ2l0Iik7CglpZiAocmVhZF9naXRmaWxlX2dlbnRseShwYXRoLT5idWYsICZnaXRmaWxlX2Vycm9yKSB8fCBpc19naXRfZGlyZWN0b3J5KHBhdGgtPmJ1ZikpCgkJcmV0ID0gMTsKCWlmIChnaXRmaWxlX2Vycm9yID09IFJFQURfR0lURklMRV9FUlJfT1BFTl9GQUlMRUQgfHwKCSAgICBnaXRmaWxlX2Vycm9yID09IFJFQURfR0lURklMRV9FUlJfUkVBRF9GQUlMRUQpCgkJcmV0ID0gMTsKCXN0cmJ1Zl9zZXRsZW4ocGF0aCwgb3JpZ19wYXRoX2xlbik7CglyZXR1cm4gcmV0Owp9CgppbnQgaXNfaW5zaWRlX2dpdF9kaXIodm9pZCkKewoJaWYgKGluc2lkZV9naXRfZGlyIDwgMCkKCQlpbnNpZGVfZ2l0X2RpciA9IGlzX2luc2lkZV9kaXIoZ2V0X2dpdF9kaXIoKSk7CglyZXR1cm4gaW5zaWRlX2dpdF9kaXI7Cn0KCmludCBpc19pbnNpZGVfd29ya190cmVlKHZvaWQpCnsKCWlmIChpbnNpZGVfd29ya190cmVlIDwgMCkKCQlpbnNpZGVfd29ya190cmVlID0gaXNfaW5zaWRlX2RpcihnZXRfZ2l0X3dvcmtfdHJlZSgpKTsKCXJldHVybiBpbnNpZGVfd29ya190cmVlOwp9Cgp2b2lkIHNldHVwX3dvcmtfdHJlZSh2b2lkKQp7Cgljb25zdCBjaGFyICp3b3JrX3RyZWUsICpnaXRfZGlyOwoJc3RhdGljIGludCBpbml0aWFsaXplZCA9IDA7CgoJaWYgKGluaXRpYWxpemVkKQoJCXJldHVybjsKCglpZiAod29ya190cmVlX2NvbmZpZ19pc19ib2d1cykKCQlkaWUoInVuYWJsZSB0byBzZXQgdXAgd29yayB0cmVlIHVzaW5nIGludmFsaWQgY29uZmlnIik7CgoJd29ya190cmVlID0gZ2V0X2dpdF93b3JrX3RyZWUoKTsKCWdpdF9kaXIgPSBnZXRfZ2l0X2RpcigpOwoJaWYgKCFpc19hYnNvbHV0ZV9wYXRoKGdpdF9kaXIpKQoJCWdpdF9kaXIgPSByZWFsX3BhdGgoZ2V0X2dpdF9kaXIoKSk7CglpZiAoIXdvcmtfdHJlZSB8fCBjaGRpcih3b3JrX3RyZWUpKQoJCWRpZSgiVGhpcyBvcGVyYXRpb24gbXVzdCBiZSBydW4gaW4gYSB3b3JrIHRyZWUiKTsKCgkvKgoJICogTWFrZSBzdXJlIHN1YnNlcXVlbnQgZ2l0IHByb2Nlc3NlcyBmaW5kIGNvcnJlY3Qgd29ya3RyZWUKCSAqIGlmICRHSVRfV09SS19UUkVFIGlzIHNldCByZWxhdGl2ZQoJICovCglpZiAoZ2V0ZW52KEdJVF9XT1JLX1RSRUVfRU5WSVJPTk1FTlQpKQoJCXNldGVudihHSVRfV09SS19UUkVFX0VOVklST05NRU5ULCAiLiIsIDEpOwoKCXNldF9naXRfZGlyKHJlbW92ZV9sZWFkaW5nX3BhdGgoZ2l0X2Rpciwgd29ya190cmVlKSk7Cglpbml0aWFsaXplZCA9IDE7Cn0KCnN0YXRpYyBpbnQgY2hlY2tfcmVwb19mb3JtYXQoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSwgdm9pZCAqdmRhdGEpCnsKCXN0cnVjdCByZXBvc2l0b3J5X2Zvcm1hdCAqZGF0YSA9IHZkYXRhOwoJY29uc3QgY2hhciAqZXh0OwoKCWlmIChzdHJjbXAodmFyLCAiY29yZS5yZXBvc2l0b3J5Zm9ybWF0dmVyc2lvbiIpID09IDApCgkJZGF0YS0+dmVyc2lvbiA9IGdpdF9jb25maWdfaW50KHZhciwgdmFsdWUpOwoJZWxzZSBpZiAoc2tpcF9wcmVmaXgodmFyLCAiZXh0ZW5zaW9ucy4iLCAmZXh0KSkgewoJCS8qCgkJICogcmVjb3JkIGFueSBrbm93biBleHRlbnNpb25zIGhlcmU7IG90aGVyd2lzZSwKCQkgKiB3ZSBmYWxsIHRocm91Z2ggdG8gcmVjb3JkaW5nIGl0IGFzIHVua25vd24sIGFuZAoJCSAqIGNoZWNrX3JlcG9zaXRvcnlfZm9ybWF0IHdpbGwgY29tcGxhaW4KCQkgKi8KCQlpZiAoIXN0cmNtcChleHQsICJub29wIikpCgkJCTsKCQllbHNlIGlmICghc3RyY21wKGV4dCwgInByZWNpb3Vzb2JqZWN0cyIpKQoJCQlkYXRhLT5wcmVjaW91c19vYmplY3RzID0gZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpOwoJCWVsc2UKCQkJc3RyaW5nX2xpc3RfYXBwZW5kKCZkYXRhLT51bmtub3duX2V4dGVuc2lvbnMsIGV4dCk7Cgl9IGVsc2UgaWYgKHN0cmNtcCh2YXIsICJjb3JlLmJhcmUiKSA9PSAwKSB7CgkJZGF0YS0+aXNfYmFyZSA9IGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKTsKCX0gZWxzZSBpZiAoc3RyY21wKHZhciwgImNvcmUud29ya3RyZWUiKSA9PSAwKSB7CgkJaWYgKCF2YWx1ZSkKCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKHZhcik7CgkJZGF0YS0+d29ya190cmVlID0geHN0cmR1cCh2YWx1ZSk7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBjaGVja19yZXBvc2l0b3J5X2Zvcm1hdF9nZW50bHkoY29uc3QgY2hhciAqZ2l0ZGlyLCBpbnQgKm5vbmdpdF9vaykKewoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBlcnIgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCByZXBvc2l0b3J5X2Zvcm1hdCBjYW5kaWRhdGU7CglpbnQgaGFzX2NvbW1vbjsKCgloYXNfY29tbW9uID0gZ2V0X2NvbW1vbl9kaXIoJnNiLCBnaXRkaXIpOwoJc3RyYnVmX2FkZHN0cigmc2IsICIvY29uZmlnIik7CglyZWFkX3JlcG9zaXRvcnlfZm9ybWF0KCZjYW5kaWRhdGUsIHNiLmJ1Zik7CglzdHJidWZfcmVsZWFzZSgmc2IpOwoKCS8qCgkgKiBGb3IgaGlzdG9yaWNhbCB1c2Ugb2YgY2hlY2tfcmVwb3NpdG9yeV9mb3JtYXQoKSBpbiBnaXQtaW5pdCwKCSAqIHdlIHRyZWF0IGEgbWlzc2luZyBjb25maWcgYXMgYSBzaWxlbnQgIm9rIiwgZXZlbiB3aGVuIG5vbmdpdF9vawoJICogaXMgdW5zZXQuCgkgKi8KCWlmIChjYW5kaWRhdGUudmVyc2lvbiA8IDApCgkJcmV0dXJuIDA7CgoJaWYgKHZlcmlmeV9yZXBvc2l0b3J5X2Zvcm1hdCgmY2FuZGlkYXRlLCAmZXJyKSA8IDApIHsKCQlpZiAobm9uZ2l0X29rKSB7CgkJCXdhcm5pbmcoIiVzIiwgZXJyLmJ1Zik7CgkJCXN0cmJ1Zl9yZWxlYXNlKCZlcnIpOwoJCQkqbm9uZ2l0X29rID0gLTE7CgkJCXJldHVybiAtMTsKCQl9CgkJZGllKCIlcyIsIGVyci5idWYpOwoJfQoKCXJlcG9zaXRvcnlfZm9ybWF0X3ByZWNpb3VzX29iamVjdHMgPSBjYW5kaWRhdGUucHJlY2lvdXNfb2JqZWN0czsKCXN0cmluZ19saXN0X2NsZWFyKCZjYW5kaWRhdGUudW5rbm93bl9leHRlbnNpb25zLCAwKTsKCWlmICghaGFzX2NvbW1vbikgewoJCWlmIChjYW5kaWRhdGUuaXNfYmFyZSAhPSAtMSkgewoJCQlpc19iYXJlX3JlcG9zaXRvcnlfY2ZnID0gY2FuZGlkYXRlLmlzX2JhcmU7CgkJCWlmIChpc19iYXJlX3JlcG9zaXRvcnlfY2ZnID09IDEpCgkJCQlpbnNpZGVfd29ya190cmVlID0gLTE7CgkJfQoJCWlmIChjYW5kaWRhdGUud29ya190cmVlKSB7CgkJCWZyZWUoZ2l0X3dvcmtfdHJlZV9jZmcpOwoJCQlnaXRfd29ya190cmVlX2NmZyA9IGNhbmRpZGF0ZS53b3JrX3RyZWU7CgkJCWluc2lkZV93b3JrX3RyZWUgPSAtMTsKCQl9Cgl9IGVsc2UgewoJCWZyZWUoY2FuZGlkYXRlLndvcmtfdHJlZSk7Cgl9CgoJcmV0dXJuIDA7Cn0KCmludCByZWFkX3JlcG9zaXRvcnlfZm9ybWF0KHN0cnVjdCByZXBvc2l0b3J5X2Zvcm1hdCAqZm9ybWF0LCBjb25zdCBjaGFyICpwYXRoKQp7CgltZW1zZXQoZm9ybWF0LCAwLCBzaXplb2YoKmZvcm1hdCkpOwoJZm9ybWF0LT52ZXJzaW9uID0gLTE7Cglmb3JtYXQtPmlzX2JhcmUgPSAtMTsKCXN0cmluZ19saXN0X2luaXQoJmZvcm1hdC0+dW5rbm93bl9leHRlbnNpb25zLCAxKTsKCWdpdF9jb25maWdfZnJvbV9maWxlKGNoZWNrX3JlcG9fZm9ybWF0LCBwYXRoLCBmb3JtYXQpOwoJcmV0dXJuIGZvcm1hdC0+dmVyc2lvbjsKfQoKaW50IHZlcmlmeV9yZXBvc2l0b3J5X2Zvcm1hdChjb25zdCBzdHJ1Y3QgcmVwb3NpdG9yeV9mb3JtYXQgKmZvcm1hdCwKCQkJICAgICBzdHJ1Y3Qgc3RyYnVmICplcnIpCnsKCWlmIChHSVRfUkVQT19WRVJTSU9OX1JFQUQgPCBmb3JtYXQtPnZlcnNpb24pIHsKCQlzdHJidWZfYWRkZihlcnIsIF8oIkV4cGVjdGVkIGdpdCByZXBvIHZlcnNpb24gPD0gJWQsIGZvdW5kICVkIiksCgkJCSAgICBHSVRfUkVQT19WRVJTSU9OX1JFQUQsIGZvcm1hdC0+dmVyc2lvbik7CgkJcmV0dXJuIC0xOwoJfQoKCWlmIChmb3JtYXQtPnZlcnNpb24gPj0gMSAmJiBmb3JtYXQtPnVua25vd25fZXh0ZW5zaW9ucy5ucikgewoJCWludCBpOwoKCQlzdHJidWZfYWRkc3RyKGVyciwgXygidW5rbm93biByZXBvc2l0b3J5IGV4dGVuc2lvbnMgZm91bmQ6IikpOwoKCQlmb3IgKGkgPSAwOyBpIDwgZm9ybWF0LT51bmtub3duX2V4dGVuc2lvbnMubnI7IGkrKykKCQkJc3RyYnVmX2FkZGYoZXJyLCAiXG5cdCVzIiwKCQkJCSAgICBmb3JtYXQtPnVua25vd25fZXh0ZW5zaW9ucy5pdGVtc1tpXS5zdHJpbmcpOwoJCXJldHVybiAtMTsKCX0KCglyZXR1cm4gMDsKfQoKdm9pZCByZWFkX2dpdGZpbGVfZXJyb3JfZGllKGludCBlcnJvcl9jb2RlLCBjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFyICpkaXIpCnsKCXN3aXRjaCAoZXJyb3JfY29kZSkgewoJY2FzZSBSRUFEX0dJVEZJTEVfRVJSX1NUQVRfRkFJTEVEOgoJY2FzZSBSRUFEX0dJVEZJTEVfRVJSX05PVF9BX0ZJTEU6CgkJLyogbm9uLWZhdGFsOyBmb2xsb3cgcmV0dXJuIHBhdGggKi8KCQlicmVhazsKCWNhc2UgUkVBRF9HSVRGSUxFX0VSUl9PUEVOX0ZBSUxFRDoKCQlkaWVfZXJybm8oIkVycm9yIG9wZW5pbmcgJyVzJyIsIHBhdGgpOwoJY2FzZSBSRUFEX0dJVEZJTEVfRVJSX1RPT19MQVJHRToKCQlkaWUoIlRvbyBsYXJnZSB0byBiZSBhIC5naXQgZmlsZTogJyVzJyIsIHBhdGgpOwoJY2FzZSBSRUFEX0dJVEZJTEVfRVJSX1JFQURfRkFJTEVEOgoJCWRpZSgiRXJyb3IgcmVhZGluZyAlcyIsIHBhdGgpOwoJY2FzZSBSRUFEX0dJVEZJTEVfRVJSX0lOVkFMSURfRk9STUFUOgoJCWRpZSgiSW52YWxpZCBnaXRmaWxlIGZvcm1hdDogJXMiLCBwYXRoKTsKCWNhc2UgUkVBRF9HSVRGSUxFX0VSUl9OT19QQVRIOgoJCWRpZSgiTm8gcGF0aCBpbiBnaXRmaWxlOiAlcyIsIHBhdGgpOwoJY2FzZSBSRUFEX0dJVEZJTEVfRVJSX05PVF9BX1JFUE86CgkJZGllKCJOb3QgYSBnaXQgcmVwb3NpdG9yeTogJXMiLCBkaXIpOwoJZGVmYXVsdDoKCQlkaWUoIkJVRzogdW5rbm93biBlcnJvciBjb2RlIik7Cgl9Cn0KCi8qCiAqIFRyeSB0byByZWFkIHRoZSBsb2NhdGlvbiBvZiB0aGUgZ2l0IGRpcmVjdG9yeSBmcm9tIHRoZSAuZ2l0IGZpbGUsCiAqIHJldHVybiBwYXRoIHRvIGdpdCBkaXJlY3RvcnkgaWYgZm91bmQuCiAqCiAqIE9uIGZhaWx1cmUsIGlmIHJldHVybl9lcnJvcl9jb2RlIGlzIG5vdCBOVUxMLCByZXR1cm5fZXJyb3JfY29kZQogKiB3aWxsIGJlIHNldCB0byBhbiBlcnJvciBjb2RlIGFuZCBOVUxMIHdpbGwgYmUgcmV0dXJuZWQuIElmCiAqIHJldHVybl9lcnJvcl9jb2RlIGlzIE5VTEwgdGhlIGZ1bmN0aW9uIHdpbGwgZGllIGluc3RlYWQgKGZvciBtb3N0CiAqIGNhc2VzKS4KICovCmNvbnN0IGNoYXIgKnJlYWRfZ2l0ZmlsZV9nZW50bHkoY29uc3QgY2hhciAqcGF0aCwgaW50ICpyZXR1cm5fZXJyb3JfY29kZSkKewoJY29uc3QgaW50IG1heF9maWxlX3NpemUgPSAxIDw8IDIwOyAgLyogMU1CICovCglpbnQgZXJyb3JfY29kZSA9IDA7CgljaGFyICpidWYgPSBOVUxMOwoJY2hhciAqZGlyID0gTlVMTDsKCWNvbnN0IGNoYXIgKnNsYXNoOwoJc3RydWN0IHN0YXQgc3Q7CglpbnQgZmQ7Cglzc2l6ZV90IGxlbjsKCglpZiAoc3RhdChwYXRoLCAmc3QpKSB7CgkJLyogTkVFRFNXT1JLOiBkaXNjZXJuIGJldHdlZW4gRU5PRU5UIHZzIG90aGVyIGVycm9ycyAqLwoJCWVycm9yX2NvZGUgPSBSRUFEX0dJVEZJTEVfRVJSX1NUQVRfRkFJTEVEOwoJCWdvdG8gY2xlYW51cF9yZXR1cm47Cgl9CglpZiAoIVNfSVNSRUcoc3Quc3RfbW9kZSkpIHsKCQllcnJvcl9jb2RlID0gUkVBRF9HSVRGSUxFX0VSUl9OT1RfQV9GSUxFOwoJCWdvdG8gY2xlYW51cF9yZXR1cm47Cgl9CglpZiAoc3Quc3Rfc2l6ZSA+IG1heF9maWxlX3NpemUpIHsKCQllcnJvcl9jb2RlID0gUkVBRF9HSVRGSUxFX0VSUl9UT09fTEFSR0U7CgkJZ290byBjbGVhbnVwX3JldHVybjsKCX0KCWZkID0gb3BlbihwYXRoLCBPX1JET05MWSk7CglpZiAoZmQgPCAwKSB7CgkJZXJyb3JfY29kZSA9IFJFQURfR0lURklMRV9FUlJfT1BFTl9GQUlMRUQ7CgkJZ290byBjbGVhbnVwX3JldHVybjsKCX0KCWJ1ZiA9IHhtYWxsb2N6KHN0LnN0X3NpemUpOwoJbGVuID0gcmVhZF9pbl9mdWxsKGZkLCBidWYsIHN0LnN0X3NpemUpOwoJY2xvc2UoZmQpOwoJaWYgKGxlbiAhPSBzdC5zdF9zaXplKSB7CgkJZXJyb3JfY29kZSA9IFJFQURfR0lURklMRV9FUlJfUkVBRF9GQUlMRUQ7CgkJZ290byBjbGVhbnVwX3JldHVybjsKCX0KCWlmICghc3RhcnRzX3dpdGgoYnVmLCAiZ2l0ZGlyOiAiKSkgewoJCWVycm9yX2NvZGUgPSBSRUFEX0dJVEZJTEVfRVJSX0lOVkFMSURfRk9STUFUOwoJCWdvdG8gY2xlYW51cF9yZXR1cm47Cgl9Cgl3aGlsZSAoYnVmW2xlbiAtIDFdID09ICdcbicgfHwgYnVmW2xlbiAtIDFdID09ICdccicpCgkJbGVuLS07CglpZiAobGVuIDwgOSkgewoJCWVycm9yX2NvZGUgPSBSRUFEX0dJVEZJTEVfRVJSX05PX1BBVEg7CgkJZ290byBjbGVhbnVwX3JldHVybjsKCX0KCWJ1ZltsZW5dID0gJ1wwJzsKCWRpciA9IGJ1ZiArIDg7CgoJaWYgKCFpc19hYnNvbHV0ZV9wYXRoKGRpcikgJiYgKHNsYXNoID0gc3RycmNocihwYXRoLCAnLycpKSkgewoJCXNpemVfdCBwYXRobGVuID0gc2xhc2grMSAtIHBhdGg7CgkJZGlyID0geHN0cmZtdCgiJS4qcyUuKnMiLCAoaW50KXBhdGhsZW4sIHBhdGgsCgkJCSAgICAgIChpbnQpKGxlbiAtIDgpLCBidWYgKyA4KTsKCQlmcmVlKGJ1Zik7CgkJYnVmID0gZGlyOwoJfQoJaWYgKCFpc19naXRfZGlyZWN0b3J5KGRpcikpIHsKCQllcnJvcl9jb2RlID0gUkVBRF9HSVRGSUxFX0VSUl9OT1RfQV9SRVBPOwoJCWdvdG8gY2xlYW51cF9yZXR1cm47Cgl9CglwYXRoID0gcmVhbF9wYXRoKGRpcik7CgpjbGVhbnVwX3JldHVybjoKCWlmIChyZXR1cm5fZXJyb3JfY29kZSkKCQkqcmV0dXJuX2Vycm9yX2NvZGUgPSBlcnJvcl9jb2RlOwoJZWxzZSBpZiAoZXJyb3JfY29kZSkKCQlyZWFkX2dpdGZpbGVfZXJyb3JfZGllKGVycm9yX2NvZGUsIHBhdGgsIGRpcik7CgoJZnJlZShidWYpOwoJcmV0dXJuIGVycm9yX2NvZGUgPyBOVUxMIDogcGF0aDsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnNldHVwX2V4cGxpY2l0X2dpdF9kaXIoY29uc3QgY2hhciAqZ2l0ZGlyZW52LAoJCQkJCSAgc3RydWN0IHN0cmJ1ZiAqY3dkLAoJCQkJCSAgaW50ICpub25naXRfb2spCnsKCWNvbnN0IGNoYXIgKndvcmtfdHJlZV9lbnYgPSBnZXRlbnYoR0lUX1dPUktfVFJFRV9FTlZJUk9OTUVOVCk7Cgljb25zdCBjaGFyICp3b3JrdHJlZTsKCWNoYXIgKmdpdGZpbGU7CglpbnQgb2Zmc2V0OwoKCWlmIChQQVRIX01BWCAtIDQwIDwgc3RybGVuKGdpdGRpcmVudikpCgkJZGllKCInJCVzJyB0b28gYmlnIiwgR0lUX0RJUl9FTlZJUk9OTUVOVCk7CgoJZ2l0ZmlsZSA9IChjaGFyKilyZWFkX2dpdGZpbGUoZ2l0ZGlyZW52KTsKCWlmIChnaXRmaWxlKSB7CgkJZ2l0ZmlsZSA9IHhzdHJkdXAoZ2l0ZmlsZSk7CgkJZ2l0ZGlyZW52ID0gZ2l0ZmlsZTsKCX0KCglpZiAoIWlzX2dpdF9kaXJlY3RvcnkoZ2l0ZGlyZW52KSkgewoJCWlmIChub25naXRfb2spIHsKCQkJKm5vbmdpdF9vayA9IDE7CgkJCWZyZWUoZ2l0ZmlsZSk7CgkJCXJldHVybiBOVUxMOwoJCX0KCQlkaWUoIk5vdCBhIGdpdCByZXBvc2l0b3J5OiAnJXMnIiwgZ2l0ZGlyZW52KTsKCX0KCglpZiAoY2hlY2tfcmVwb3NpdG9yeV9mb3JtYXRfZ2VudGx5KGdpdGRpcmVudiwgbm9uZ2l0X29rKSkgewoJCWZyZWUoZ2l0ZmlsZSk7CgkJcmV0dXJuIE5VTEw7Cgl9CgoJLyogIzMsICM3LCAjMTEsICMxNSwgIzE5LCAjMjMsICMyNywgIzMxIChzZWUgdDE1MTApICovCglpZiAod29ya190cmVlX2VudikKCQlzZXRfZ2l0X3dvcmtfdHJlZSh3b3JrX3RyZWVfZW52KTsKCWVsc2UgaWYgKGlzX2JhcmVfcmVwb3NpdG9yeV9jZmcgPiAwKSB7CgkJaWYgKGdpdF93b3JrX3RyZWVfY2ZnKSB7CgkJCS8qICMyMi4yLCAjMzAgKi8KCQkJd2FybmluZygiY29yZS5iYXJlIGFuZCBjb3JlLndvcmt0cmVlIGRvIG5vdCBtYWtlIHNlbnNlIik7CgkJCXdvcmtfdHJlZV9jb25maWdfaXNfYm9ndXMgPSAxOwoJCX0KCgkJLyogIzE4LCAjMjYgKi8KCQlzZXRfZ2l0X2RpcihnaXRkaXJlbnYpOwoJCWZyZWUoZ2l0ZmlsZSk7CgkJcmV0dXJuIE5VTEw7Cgl9CgllbHNlIGlmIChnaXRfd29ya190cmVlX2NmZykgeyAvKiAjNiwgIzE0ICovCgkJaWYgKGlzX2Fic29sdXRlX3BhdGgoZ2l0X3dvcmtfdHJlZV9jZmcpKQoJCQlzZXRfZ2l0X3dvcmtfdHJlZShnaXRfd29ya190cmVlX2NmZyk7CgkJZWxzZSB7CgkJCWNoYXIgKmNvcmVfd29ya3RyZWU7CgkJCWlmIChjaGRpcihnaXRkaXJlbnYpKQoJCQkJZGllX2Vycm5vKCJDb3VsZCBub3QgY2hkaXIgdG8gJyVzJyIsIGdpdGRpcmVudik7CgkJCWlmIChjaGRpcihnaXRfd29ya190cmVlX2NmZykpCgkJCQlkaWVfZXJybm8oIkNvdWxkIG5vdCBjaGRpciB0byAnJXMnIiwgZ2l0X3dvcmtfdHJlZV9jZmcpOwoJCQljb3JlX3dvcmt0cmVlID0geGdldGN3ZCgpOwoJCQlpZiAoY2hkaXIoY3dkLT5idWYpKQoJCQkJZGllX2Vycm5vKCJDb3VsZCBub3QgY29tZSBiYWNrIHRvIGN3ZCIpOwoJCQlzZXRfZ2l0X3dvcmtfdHJlZShjb3JlX3dvcmt0cmVlKTsKCQkJZnJlZShjb3JlX3dvcmt0cmVlKTsKCQl9Cgl9CgllbHNlIGlmICghZ2l0X2Vudl9ib29sKEdJVF9JTVBMSUNJVF9XT1JLX1RSRUVfRU5WSVJPTk1FTlQsIDEpKSB7CgkJLyogIzE2ZCAqLwoJCXNldF9naXRfZGlyKGdpdGRpcmVudik7CgkJZnJlZShnaXRmaWxlKTsKCQlyZXR1cm4gTlVMTDsKCX0KCWVsc2UgLyogIzIsICMxMCAqLwoJCXNldF9naXRfd29ya190cmVlKCIuIik7CgoJLyogc2V0X2dpdF93b3JrX3RyZWUoKSBtdXN0IGhhdmUgYmVlbiBjYWxsZWQgYnkgbm93ICovCgl3b3JrdHJlZSA9IGdldF9naXRfd29ya190cmVlKCk7CgoJLyogYm90aCBnZXRfZ2l0X3dvcmtfdHJlZSgpIGFuZCBjd2QgYXJlIGFscmVhZHkgbm9ybWFsaXplZCAqLwoJaWYgKCFzdHJjbXAoY3dkLT5idWYsIHdvcmt0cmVlKSkgeyAvKiBjd2QgPT0gd29ya3RyZWUgKi8KCQlzZXRfZ2l0X2RpcihnaXRkaXJlbnYpOwoJCWZyZWUoZ2l0ZmlsZSk7CgkJcmV0dXJuIE5VTEw7Cgl9CgoJb2Zmc2V0ID0gZGlyX2luc2lkZV9vZihjd2QtPmJ1Ziwgd29ya3RyZWUpOwoJaWYgKG9mZnNldCA+PSAwKSB7CS8qIGN3ZCBpbnNpZGUgd29ya3RyZWU/ICovCgkJc2V0X2dpdF9kaXIocmVhbF9wYXRoKGdpdGRpcmVudikpOwoJCWlmIChjaGRpcih3b3JrdHJlZSkpCgkJCWRpZV9lcnJubygiQ291bGQgbm90IGNoZGlyIHRvICclcyciLCB3b3JrdHJlZSk7CgkJc3RyYnVmX2FkZGNoKGN3ZCwgJy8nKTsKCQlmcmVlKGdpdGZpbGUpOwoJCXJldHVybiBjd2QtPmJ1ZiArIG9mZnNldDsKCX0KCgkvKiBjd2Qgb3V0c2lkZSB3b3JrdHJlZSAqLwoJc2V0X2dpdF9kaXIoZ2l0ZGlyZW52KTsKCWZyZWUoZ2l0ZmlsZSk7CglyZXR1cm4gTlVMTDsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnNldHVwX2Rpc2NvdmVyZWRfZ2l0X2Rpcihjb25zdCBjaGFyICpnaXRkaXIsCgkJCQkJICAgIHN0cnVjdCBzdHJidWYgKmN3ZCwgaW50IG9mZnNldCwKCQkJCQkgICAgaW50ICpub25naXRfb2spCnsKCWlmIChjaGVja19yZXBvc2l0b3J5X2Zvcm1hdF9nZW50bHkoZ2l0ZGlyLCBub25naXRfb2spKQoJCXJldHVybiBOVUxMOwoKCS8qIC0td29yay10cmVlIGlzIHNldCB3aXRob3V0IC0tZ2l0LWRpcjsgdXNlIGRpc2NvdmVyZWQgb25lICovCglpZiAoZ2V0ZW52KEdJVF9XT1JLX1RSRUVfRU5WSVJPTk1FTlQpIHx8IGdpdF93b3JrX3RyZWVfY2ZnKSB7CgkJaWYgKG9mZnNldCAhPSBjd2QtPmxlbiAmJiAhaXNfYWJzb2x1dGVfcGF0aChnaXRkaXIpKQoJCQlnaXRkaXIgPSByZWFsX3BhdGhkdXAoZ2l0ZGlyLCAxKTsKCQlpZiAoY2hkaXIoY3dkLT5idWYpKQoJCQlkaWVfZXJybm8oIkNvdWxkIG5vdCBjb21lIGJhY2sgdG8gY3dkIik7CgkJcmV0dXJuIHNldHVwX2V4cGxpY2l0X2dpdF9kaXIoZ2l0ZGlyLCBjd2QsIG5vbmdpdF9vayk7Cgl9CgoJLyogIzE2LjIsICMxNy4yLCAjMjAuMiwgIzIxLjIsICMyNCwgIzI1LCAjMjgsICMyOSAoc2VlIHQxNTEwKSAqLwoJaWYgKGlzX2JhcmVfcmVwb3NpdG9yeV9jZmcgPiAwKSB7CgkJc2V0X2dpdF9kaXIob2Zmc2V0ID09IGN3ZC0+bGVuID8gZ2l0ZGlyIDogcmVhbF9wYXRoKGdpdGRpcikpOwoJCWlmIChjaGRpcihjd2QtPmJ1ZikpCgkJCWRpZV9lcnJubygiQ291bGQgbm90IGNvbWUgYmFjayB0byBjd2QiKTsKCQlyZXR1cm4gTlVMTDsKCX0KCgkvKiAjMCwgIzEsICM1LCAjOCwgIzksICMxMiwgIzEzICovCglzZXRfZ2l0X3dvcmtfdHJlZSgiLiIpOwoJaWYgKHN0cmNtcChnaXRkaXIsIERFRkFVTFRfR0lUX0RJUl9FTlZJUk9OTUVOVCkpCgkJc2V0X2dpdF9kaXIoZ2l0ZGlyKTsKCWluc2lkZV9naXRfZGlyID0gMDsKCWluc2lkZV93b3JrX3RyZWUgPSAxOwoJaWYgKG9mZnNldCA9PSBjd2QtPmxlbikKCQlyZXR1cm4gTlVMTDsKCgkvKiBNYWtlICJvZmZzZXQiIHBvaW50IHBhc3QgdGhlICcvJyAoYWxyZWFkeSB0aGUgY2FzZSBmb3Igcm9vdCBkaXJzKSAqLwoJaWYgKG9mZnNldCAhPSBvZmZzZXRfMXN0X2NvbXBvbmVudChjd2QtPmJ1ZikpCgkJb2Zmc2V0Kys7CgkvKiBBZGQgYSAnLycgYXQgdGhlIGVuZCAqLwoJc3RyYnVmX2FkZGNoKGN3ZCwgJy8nKTsKCXJldHVybiBjd2QtPmJ1ZiArIG9mZnNldDsKfQoKLyogIzE2LjEsICMxNy4xLCAjMjAuMSwgIzIxLjEsICMyMi4xIChzZWUgdDE1MTApICovCnN0YXRpYyBjb25zdCBjaGFyICpzZXR1cF9iYXJlX2dpdF9kaXIoc3RydWN0IHN0cmJ1ZiAqY3dkLCBpbnQgb2Zmc2V0LAoJCQkJICAgICAgaW50ICpub25naXRfb2spCnsKCWludCByb290X2xlbjsKCglpZiAoY2hlY2tfcmVwb3NpdG9yeV9mb3JtYXRfZ2VudGx5KCIuIiwgbm9uZ2l0X29rKSkKCQlyZXR1cm4gTlVMTDsKCglzZXRlbnYoR0lUX0lNUExJQ0lUX1dPUktfVFJFRV9FTlZJUk9OTUVOVCwgIjAiLCAxKTsKCgkvKiAtLXdvcmstdHJlZSBpcyBzZXQgd2l0aG91dCAtLWdpdC1kaXI7IHVzZSBkaXNjb3ZlcmVkIG9uZSAqLwoJaWYgKGdldGVudihHSVRfV09SS19UUkVFX0VOVklST05NRU5UKSB8fCBnaXRfd29ya190cmVlX2NmZykgewoJCWNvbnN0IGNoYXIgKmdpdGRpcjsKCgkJZ2l0ZGlyID0gb2Zmc2V0ID09IGN3ZC0+bGVuID8gIi4iIDogeG1lbWR1cHooY3dkLT5idWYsIG9mZnNldCk7CgkJaWYgKGNoZGlyKGN3ZC0+YnVmKSkKCQkJZGllX2Vycm5vKCJDb3VsZCBub3QgY29tZSBiYWNrIHRvIGN3ZCIpOwoJCXJldHVybiBzZXR1cF9leHBsaWNpdF9naXRfZGlyKGdpdGRpciwgY3dkLCBub25naXRfb2spOwoJfQoKCWluc2lkZV9naXRfZGlyID0gMTsKCWluc2lkZV93b3JrX3RyZWUgPSAwOwoJaWYgKG9mZnNldCAhPSBjd2QtPmxlbikgewoJCWlmIChjaGRpcihjd2QtPmJ1ZikpCgkJCWRpZV9lcnJubygiQ2Fubm90IGNvbWUgYmFjayB0byBjd2QiKTsKCQlyb290X2xlbiA9IG9mZnNldF8xc3RfY29tcG9uZW50KGN3ZC0+YnVmKTsKCQlzdHJidWZfc2V0bGVuKGN3ZCwgb2Zmc2V0ID4gcm9vdF9sZW4gPyBvZmZzZXQgOiByb290X2xlbik7CgkJc2V0X2dpdF9kaXIoY3dkLT5idWYpOwoJfQoJZWxzZQoJCXNldF9naXRfZGlyKCIuIik7CglyZXR1cm4gTlVMTDsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnNldHVwX25vbmdpdChjb25zdCBjaGFyICpjd2QsIGludCAqbm9uZ2l0X29rKQp7CglpZiAoIW5vbmdpdF9vaykKCQlkaWUoXygiTm90IGEgZ2l0IHJlcG9zaXRvcnkgKG9yIGFueSBvZiB0aGUgcGFyZW50IGRpcmVjdG9yaWVzKTogJXMiKSwgREVGQVVMVF9HSVRfRElSX0VOVklST05NRU5UKTsKCWlmIChjaGRpcihjd2QpKQoJCWRpZV9lcnJubyhfKCJDYW5ub3QgY29tZSBiYWNrIHRvIGN3ZCIpKTsKCSpub25naXRfb2sgPSAxOwoJcmV0dXJuIE5VTEw7Cn0KCnN0YXRpYyBkZXZfdCBnZXRfZGV2aWNlX29yX2RpZShjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFyICpwcmVmaXgsIGludCBwcmVmaXhfbGVuKQp7CglzdHJ1Y3Qgc3RhdCBidWY7CglpZiAoc3RhdChwYXRoLCAmYnVmKSkgewoJCWRpZV9lcnJubygiZmFpbGVkIHRvIHN0YXQgJyUqcyVzJXMnIiwKCQkJCXByZWZpeF9sZW4sCgkJCQlwcmVmaXggPyBwcmVmaXggOiAiIiwKCQkJCXByZWZpeCA/ICIvIiA6ICIiLCBwYXRoKTsKCX0KCXJldHVybiBidWYuc3RfZGV2Owp9CgovKgogKiBBICJzdHJpbmdfbGlzdF9lYWNoX2Z1bmNfdCIgZnVuY3Rpb24gdGhhdCBjYW5vbmljYWxpemVzIGFuIGVudHJ5CiAqIGZyb20gR0lUX0NFSUxJTkdfRElSRUNUT1JJRVMgdXNpbmcgcmVhbF9wYXRoX2lmX3ZhbGlkKCksIG9yCiAqIGRpc2NhcmRzIGl0IGlmIHVudXNhYmxlLiAgVGhlIHByZXNlbmNlIG9mIGFuIGVtcHR5IGVudHJ5IGluCiAqIEdJVF9DRUlMSU5HX0RJUkVDVE9SSUVTIHR1cm5zIG9mZiBjYW5vbmljYWxpemF0aW9uIGZvciBhbGwKICogc3Vic2VxdWVudCBlbnRyaWVzLgogKi8Kc3RhdGljIGludCBjYW5vbmljYWxpemVfY2VpbGluZ19lbnRyeShzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbSwKCQkJCSAgICAgIHZvaWQgKmNiX2RhdGEpCnsKCWludCAqZW1wdHlfZW50cnlfZm91bmQgPSBjYl9kYXRhOwoJY2hhciAqY2VpbCA9IGl0ZW0tPnN0cmluZzsKCglpZiAoISpjZWlsKSB7CgkJKmVtcHR5X2VudHJ5X2ZvdW5kID0gMTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIWlzX2Fic29sdXRlX3BhdGgoY2VpbCkpIHsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoKmVtcHR5X2VudHJ5X2ZvdW5kKSB7CgkJLyogS2VlcCBlbnRyeSBidXQgZG8gbm90IGNhbm9uaWNhbGl6ZSBpdCAqLwoJCXJldHVybiAxOwoJfSBlbHNlIHsKCQljaGFyICpyZWFsX3BhdGggPSByZWFsX3BhdGhkdXAoY2VpbCwgMCk7CgkJaWYgKCFyZWFsX3BhdGgpIHsKCQkJcmV0dXJuIDA7CgkJfQoJCWZyZWUoaXRlbS0+c3RyaW5nKTsKCQlpdGVtLT5zdHJpbmcgPSByZWFsX3BhdGg7CgkJcmV0dXJuIDE7Cgl9Cn0KCmVudW0gZGlzY292ZXJ5X3Jlc3VsdCB7CglHSVRfRElSX05PTkUgPSAwLAoJR0lUX0RJUl9FWFBMSUNJVCwKCUdJVF9ESVJfRElTQ09WRVJFRCwKCUdJVF9ESVJfQkFSRSwKCS8qIHRoZXNlIGFyZSBlcnJvcnMgKi8KCUdJVF9ESVJfSElUX0NFSUxJTkcgPSAtMSwKCUdJVF9ESVJfSElUX01PVU5UX1BPSU5UID0gLTIsCglHSVRfRElSX0lOVkFMSURfR0lURklMRSA9IC0zCn07CgovKgogKiBXZSBjYW5ub3QgZGVjaWRlIGluIHRoaXMgZnVuY3Rpb24gd2hldGhlciB3ZSBhcmUgaW4gdGhlIHdvcmsgdHJlZSBvcgogKiBub3QsIHNpbmNlIHRoZSBjb25maWcgY2FuIG9ubHkgYmUgcmVhZCBfYWZ0ZXJfIHRoaXMgZnVuY3Rpb24gd2FzIGNhbGxlZC4KICoKICogQWxzbywgd2UgYXZvaWQgY2hhbmdpbmcgYW55IGdsb2JhbCBzdGF0ZSAoc3VjaCBhcyB0aGUgY3VycmVudCB3b3JraW5nCiAqIGRpcmVjdG9yeSkgdG8gYWxsb3cgZWFybHkgY2FsbGVycy4KICoKICogVGhlIGRpcmVjdG9yeSB3aGVyZSB0aGUgc2VhcmNoIHNob3VsZCBzdGFydCBuZWVkcyB0byBiZSBwYXNzZWQgaW4gdmlhIHRoZQogKiBgZGlyYCBwYXJhbWV0ZXI7IHVwb24gcmV0dXJuLCB0aGUgYGRpcmAgYnVmZmVyIHdpbGwgY29udGFpbiB0aGUgcGF0aCBvZgogKiB0aGUgZGlyZWN0b3J5IHdoZXJlIHRoZSBzZWFyY2ggZW5kZWQsIGFuZCBgZ2l0ZGlyYCB3aWxsIGNvbnRhaW4gdGhlIHBhdGggb2YKICogdGhlIGRpc2NvdmVyZWQgLmdpdC8gZGlyZWN0b3J5LCBpZiBhbnkuIElmIGBnaXRkaXJgIGlzIG5vdCBhYnNvbHV0ZSwgaXQKICogaXMgcmVsYXRpdmUgdG8gYGRpcmAgKGkuZS4gKm5vdCogbmVjZXNzYXJpbHkgdGhlIGN3ZCkuCiAqLwpzdGF0aWMgZW51bSBkaXNjb3ZlcnlfcmVzdWx0IHNldHVwX2dpdF9kaXJlY3RvcnlfZ2VudGx5XzEoc3RydWN0IHN0cmJ1ZiAqZGlyLAoJCQkJCQkJICBzdHJ1Y3Qgc3RyYnVmICpnaXRkaXIsCgkJCQkJCQkgIGludCBkaWVfb25fZXJyb3IpCnsKCWNvbnN0IGNoYXIgKmVudl9jZWlsaW5nX2RpcnMgPSBnZXRlbnYoQ0VJTElOR19ESVJFQ1RPUklFU19FTlZJUk9OTUVOVCk7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgY2VpbGluZ19kaXJzID0gU1RSSU5HX0xJU1RfSU5JVF9EVVA7Cgljb25zdCBjaGFyICpnaXRkaXJlbnY7CglpbnQgY2VpbF9vZmZzZXQgPSAtMSwgbWluX29mZnNldCA9IGhhc19kb3NfZHJpdmVfcHJlZml4KGRpci0+YnVmKSA/IDMgOiAxOwoJZGV2X3QgY3VycmVudF9kZXZpY2UgPSAwOwoJaW50IG9uZV9maWxlc3lzdGVtID0gMTsKCgkvKgoJICogSWYgR0lUX0RJUiBpcyBzZXQgZXhwbGljaXRseSwgd2UncmUgbm90IGdvaW5nCgkgKiB0byBkbyBhbnkgZGlzY292ZXJ5LCBidXQgd2Ugc3RpbGwgZG8gcmVwb3NpdG9yeQoJICogdmFsaWRhdGlvbi4KCSAqLwoJZ2l0ZGlyZW52ID0gZ2V0ZW52KEdJVF9ESVJfRU5WSVJPTk1FTlQpOwoJaWYgKGdpdGRpcmVudikgewoJCXN0cmJ1Zl9hZGRzdHIoZ2l0ZGlyLCBnaXRkaXJlbnYpOwoJCXJldHVybiBHSVRfRElSX0VYUExJQ0lUOwoJfQoKCWlmIChlbnZfY2VpbGluZ19kaXJzKSB7CgkJaW50IGVtcHR5X2VudHJ5X2ZvdW5kID0gMDsKCgkJc3RyaW5nX2xpc3Rfc3BsaXQoJmNlaWxpbmdfZGlycywgZW52X2NlaWxpbmdfZGlycywgUEFUSF9TRVAsIC0xKTsKCQlmaWx0ZXJfc3RyaW5nX2xpc3QoJmNlaWxpbmdfZGlycywgMCwKCQkJCSAgIGNhbm9uaWNhbGl6ZV9jZWlsaW5nX2VudHJ5LCAmZW1wdHlfZW50cnlfZm91bmQpOwoJCWNlaWxfb2Zmc2V0ID0gbG9uZ2VzdF9hbmNlc3Rvcl9sZW5ndGgoZGlyLT5idWYsICZjZWlsaW5nX2RpcnMpOwoJCXN0cmluZ19saXN0X2NsZWFyKCZjZWlsaW5nX2RpcnMsIDApOwoJfQoKCWlmIChjZWlsX29mZnNldCA8IDApCgkJY2VpbF9vZmZzZXQgPSBtaW5fb2Zmc2V0IC0gMjsKCgkvKgoJICogVGVzdCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyIChyZWxhdGl2ZSB0byB0aGUgZGlyKToKCSAqIC0gLmdpdCAoZmlsZSBjb250YWluaW5nICJnaXRkaXI6IDxwYXRoPiIpCgkgKiAtIC5naXQvCgkgKiAtIC4vIChiYXJlKQoJICogLSAuLi8uZ2l0CgkgKiAtIC4uLy5naXQvCgkgKiAtIC4uLyAoYmFyZSkKCSAqIC0gLi4vLi4vLmdpdC8KCSAqICAgZXRjLgoJICovCglvbmVfZmlsZXN5c3RlbSA9ICFnaXRfZW52X2Jvb2woIkdJVF9ESVNDT1ZFUllfQUNST1NTX0ZJTEVTWVNURU0iLCAwKTsKCWlmIChvbmVfZmlsZXN5c3RlbSkKCQljdXJyZW50X2RldmljZSA9IGdldF9kZXZpY2Vfb3JfZGllKGRpci0+YnVmLCBOVUxMLCAwKTsKCWZvciAoOzspIHsKCQlpbnQgb2Zmc2V0ID0gZGlyLT5sZW4sIGVycm9yX2NvZGUgPSAwOwoKCQlpZiAob2Zmc2V0ID4gbWluX29mZnNldCkKCQkJc3RyYnVmX2FkZGNoKGRpciwgJy8nKTsKCQlzdHJidWZfYWRkc3RyKGRpciwgREVGQVVMVF9HSVRfRElSX0VOVklST05NRU5UKTsKCQlnaXRkaXJlbnYgPSByZWFkX2dpdGZpbGVfZ2VudGx5KGRpci0+YnVmLCBkaWVfb25fZXJyb3IgPwoJCQkJCQlOVUxMIDogJmVycm9yX2NvZGUpOwoJCWlmICghZ2l0ZGlyZW52KSB7CgkJCWlmIChkaWVfb25fZXJyb3IgfHwKCQkJICAgIGVycm9yX2NvZGUgPT0gUkVBRF9HSVRGSUxFX0VSUl9OT1RfQV9GSUxFKSB7CgkJCQkvKiBORUVEU1dPUks6IGZhaWwgaWYgLmdpdCBpcyBub3QgZmlsZSBub3IgZGlyICovCgkJCQlpZiAoaXNfZ2l0X2RpcmVjdG9yeShkaXItPmJ1ZikpCgkJCQkJZ2l0ZGlyZW52ID0gREVGQVVMVF9HSVRfRElSX0VOVklST05NRU5UOwoJCQl9IGVsc2UgaWYgKGVycm9yX2NvZGUgIT0gUkVBRF9HSVRGSUxFX0VSUl9TVEFUX0ZBSUxFRCkKCQkJCXJldHVybiBHSVRfRElSX0lOVkFMSURfR0lURklMRTsKCQl9CgkJc3RyYnVmX3NldGxlbihkaXIsIG9mZnNldCk7CgkJaWYgKGdpdGRpcmVudikgewoJCQlzdHJidWZfYWRkc3RyKGdpdGRpciwgZ2l0ZGlyZW52KTsKCQkJcmV0dXJuIEdJVF9ESVJfRElTQ09WRVJFRDsKCQl9CgoJCWlmIChpc19naXRfZGlyZWN0b3J5KGRpci0+YnVmKSkgewoJCQlzdHJidWZfYWRkc3RyKGdpdGRpciwgIi4iKTsKCQkJcmV0dXJuIEdJVF9ESVJfQkFSRTsKCQl9CgoJCWlmIChvZmZzZXQgPD0gbWluX29mZnNldCkKCQkJcmV0dXJuIEdJVF9ESVJfSElUX0NFSUxJTkc7CgoJCXdoaWxlICgtLW9mZnNldCA+IGNlaWxfb2Zmc2V0ICYmICFpc19kaXJfc2VwKGRpci0+YnVmW29mZnNldF0pKQoJCQk7IC8qIGNvbnRpbnVlICovCgkJaWYgKG9mZnNldCA8PSBjZWlsX29mZnNldCkKCQkJcmV0dXJuIEdJVF9ESVJfSElUX0NFSUxJTkc7CgoJCXN0cmJ1Zl9zZXRsZW4oZGlyLCBvZmZzZXQgPiBtaW5fb2Zmc2V0ID8gIG9mZnNldCA6IG1pbl9vZmZzZXQpOwoJCWlmIChvbmVfZmlsZXN5c3RlbSAmJgoJCSAgICBjdXJyZW50X2RldmljZSAhPSBnZXRfZGV2aWNlX29yX2RpZShkaXItPmJ1ZiwgTlVMTCwgb2Zmc2V0KSkKCQkJcmV0dXJuIEdJVF9ESVJfSElUX01PVU5UX1BPSU5UOwoJfQp9Cgpjb25zdCBjaGFyICpkaXNjb3Zlcl9naXRfZGlyZWN0b3J5KHN0cnVjdCBzdHJidWYgKmdpdGRpcikKewoJc3RydWN0IHN0cmJ1ZiBkaXIgPSBTVFJCVUZfSU5JVCwgZXJyID0gU1RSQlVGX0lOSVQ7CglzaXplX3QgZ2l0ZGlyX29mZnNldCA9IGdpdGRpci0+bGVuLCBjd2RfbGVuOwoJc3RydWN0IHJlcG9zaXRvcnlfZm9ybWF0IGNhbmRpZGF0ZTsKCglpZiAoc3RyYnVmX2dldGN3ZCgmZGlyKSkKCQlyZXR1cm4gTlVMTDsKCgljd2RfbGVuID0gZGlyLmxlbjsKCWlmIChzZXR1cF9naXRfZGlyZWN0b3J5X2dlbnRseV8xKCZkaXIsIGdpdGRpciwgMCkgPD0gMCkgewoJCXN0cmJ1Zl9yZWxlYXNlKCZkaXIpOwoJCXJldHVybiBOVUxMOwoJfQoKCS8qCgkgKiBUaGUgcmV0dXJuZWQgZ2l0ZGlyIGlzIHJlbGF0aXZlIHRvIGRpciwgYW5kIGlmIGRpciBkb2VzIG5vdCByZWZsZWN0CgkgKiB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSwgd2Ugc2ltcGx5IG1ha2UgdGhlIGdpdGRpciBhYnNvbHV0ZS4KCSAqLwoJaWYgKGRpci5sZW4gPCBjd2RfbGVuICYmICFpc19hYnNvbHV0ZV9wYXRoKGdpdGRpci0+YnVmICsgZ2l0ZGlyX29mZnNldCkpIHsKCQkvKiBBdm9pZCBhIHRyYWlsaW5nICIvLiIgKi8KCQlpZiAoIXN0cmNtcCgiLiIsIGdpdGRpci0+YnVmICsgZ2l0ZGlyX29mZnNldCkpCgkJCXN0cmJ1Zl9zZXRsZW4oZ2l0ZGlyLCBnaXRkaXJfb2Zmc2V0KTsKCQllbHNlCgkJCXN0cmJ1Zl9hZGRjaCgmZGlyLCAnLycpOwoJCXN0cmJ1Zl9pbnNlcnQoZ2l0ZGlyLCBnaXRkaXJfb2Zmc2V0LCBkaXIuYnVmLCBkaXIubGVuKTsKCX0KCglzdHJidWZfcmVzZXQoJmRpcik7CglzdHJidWZfYWRkZigmZGlyLCAiJXMvY29uZmlnIiwgZ2l0ZGlyLT5idWYgKyBnaXRkaXJfb2Zmc2V0KTsKCXJlYWRfcmVwb3NpdG9yeV9mb3JtYXQoJmNhbmRpZGF0ZSwgZGlyLmJ1Zik7CglzdHJidWZfcmVsZWFzZSgmZGlyKTsKCglpZiAodmVyaWZ5X3JlcG9zaXRvcnlfZm9ybWF0KCZjYW5kaWRhdGUsICZlcnIpIDwgMCkgewoJCXdhcm5pbmcoImlnbm9yaW5nIGdpdCBkaXIgJyVzJzogJXMiLAoJCQlnaXRkaXItPmJ1ZiArIGdpdGRpcl9vZmZzZXQsIGVyci5idWYpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZlcnIpOwoJCXJldHVybiBOVUxMOwoJfQoKCXJldHVybiBnaXRkaXItPmJ1ZiArIGdpdGRpcl9vZmZzZXQ7Cn0KCmNvbnN0IGNoYXIgKnNldHVwX2dpdF9kaXJlY3RvcnlfZ2VudGx5KGludCAqbm9uZ2l0X29rKQp7CglzdGF0aWMgc3RydWN0IHN0cmJ1ZiBjd2QgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgZGlyID0gU1RSQlVGX0lOSVQsIGdpdGRpciA9IFNUUkJVRl9JTklUOwoJY29uc3QgY2hhciAqcHJlZml4LCAqZW52X3ByZWZpeDsKCgkvKgoJICogV2UgbWF5IGhhdmUgcmVhZCBhbiBpbmNvbXBsZXRlIGNvbmZpZ3VyYXRpb24gYmVmb3JlCgkgKiBzZXR0aW5nLXVwIHRoZSBnaXQgZGlyZWN0b3J5LiBJZiBzbywgY2xlYXIgdGhlIGNhY2hlIHNvCgkgKiB0aGF0IHRoZSBuZXh0IHF1ZXJpZXMgdG8gdGhlIGNvbmZpZ3VyYXRpb24gcmVsb2FkIGNvbXBsZXRlCgkgKiBjb25maWd1cmF0aW9uIChpbmNsdWRpbmcgdGhlIHBlci1yZXBvIGNvbmZpZyBmaWxlIHRoYXQgd2UKCSAqIGlnbm9yZWQgcHJldmlvdXNseSkuCgkgKi8KCWdpdF9jb25maWdfY2xlYXIoKTsKCgkvKgoJICogTGV0J3MgYXNzdW1lIHRoYXQgd2UgYXJlIGluIGEgZ2l0IHJlcG9zaXRvcnkuCgkgKiBJZiBpdCB0dXJucyBvdXQgbGF0ZXIgdGhhdCB3ZSBhcmUgc29tZXdoZXJlIGVsc2UsIHRoZSB2YWx1ZSB3aWxsIGJlCgkgKiB1cGRhdGVkIGFjY29yZGluZ2x5LgoJICovCglpZiAobm9uZ2l0X29rKQoJCSpub25naXRfb2sgPSAwOwoKCWlmIChzdHJidWZfZ2V0Y3dkKCZjd2QpKQoJCWRpZV9lcnJubyhfKCJVbmFibGUgdG8gcmVhZCBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5IikpOwoJc3RyYnVmX2FkZGJ1ZigmZGlyLCAmY3dkKTsKCglzd2l0Y2ggKHNldHVwX2dpdF9kaXJlY3RvcnlfZ2VudGx5XzEoJmRpciwgJmdpdGRpciwgMSkpIHsKCWNhc2UgR0lUX0RJUl9OT05FOgoJCXByZWZpeCA9IE5VTEw7CgkJYnJlYWs7CgljYXNlIEdJVF9ESVJfRVhQTElDSVQ6CgkJcHJlZml4ID0gc2V0dXBfZXhwbGljaXRfZ2l0X2RpcihnaXRkaXIuYnVmLCAmY3dkLCBub25naXRfb2spOwoJCWJyZWFrOwoJY2FzZSBHSVRfRElSX0RJU0NPVkVSRUQ6CgkJaWYgKGRpci5sZW4gPCBjd2QubGVuICYmIGNoZGlyKGRpci5idWYpKQoJCQlkaWUoXygiQ2Fubm90IGNoYW5nZSB0byAnJXMnIiksIGRpci5idWYpOwoJCXByZWZpeCA9IHNldHVwX2Rpc2NvdmVyZWRfZ2l0X2RpcihnaXRkaXIuYnVmLCAmY3dkLCBkaXIubGVuLAoJCQkJCQkgIG5vbmdpdF9vayk7CgkJYnJlYWs7CgljYXNlIEdJVF9ESVJfQkFSRToKCQlpZiAoZGlyLmxlbiA8IGN3ZC5sZW4gJiYgY2hkaXIoZGlyLmJ1ZikpCgkJCWRpZShfKCJDYW5ub3QgY2hhbmdlIHRvICclcyciKSwgZGlyLmJ1Zik7CgkJcHJlZml4ID0gc2V0dXBfYmFyZV9naXRfZGlyKCZjd2QsIGRpci5sZW4sIG5vbmdpdF9vayk7CgkJYnJlYWs7CgljYXNlIEdJVF9ESVJfSElUX0NFSUxJTkc6CgkJcHJlZml4ID0gc2V0dXBfbm9uZ2l0KGN3ZC5idWYsIG5vbmdpdF9vayk7CgkJYnJlYWs7CgljYXNlIEdJVF9ESVJfSElUX01PVU5UX1BPSU5UOgoJCWlmIChub25naXRfb2spIHsKCQkJKm5vbmdpdF9vayA9IDE7CgkJCXN0cmJ1Zl9yZWxlYXNlKCZjd2QpOwoJCQlzdHJidWZfcmVsZWFzZSgmZGlyKTsKCQkJcmV0dXJuIE5VTEw7CgkJfQoJCWRpZShfKCJOb3QgYSBnaXQgcmVwb3NpdG9yeSAob3IgYW55IHBhcmVudCB1cCB0byBtb3VudCBwb2ludCAlcylcbiIKCQkgICAgICAiU3RvcHBpbmcgYXQgZmlsZXN5c3RlbSBib3VuZGFyeSAoR0lUX0RJU0NPVkVSWV9BQ1JPU1NfRklMRVNZU1RFTSBub3Qgc2V0KS4iKSwKCQkgICAgZGlyLmJ1Zik7CglkZWZhdWx0OgoJCWRpZSgiQlVHOiB1bmhhbmRsZWQgc2V0dXBfZ2l0X2RpcmVjdG9yeV8xKCkgcmVzdWx0Iik7Cgl9CgoJZW52X3ByZWZpeCA9IGdldGVudihHSVRfVE9QTEVWRUxfUFJFRklYX0VOVklST05NRU5UKTsKCWlmIChlbnZfcHJlZml4KQoJCXByZWZpeCA9IGVudl9wcmVmaXg7CgoJaWYgKHByZWZpeCkKCQlzZXRlbnYoR0lUX1BSRUZJWF9FTlZJUk9OTUVOVCwgcHJlZml4LCAxKTsKCWVsc2UKCQlzZXRlbnYoR0lUX1BSRUZJWF9FTlZJUk9OTUVOVCwgIiIsIDEpOwoKCXN0YXJ0dXBfaW5mby0+aGF2ZV9yZXBvc2l0b3J5ID0gIW5vbmdpdF9vayB8fCAhKm5vbmdpdF9vazsKCXN0YXJ0dXBfaW5mby0+cHJlZml4ID0gcHJlZml4OwoKCXN0cmJ1Zl9yZWxlYXNlKCZkaXIpOwoJc3RyYnVmX3JlbGVhc2UoJmdpdGRpcik7CgoJcmV0dXJuIHByZWZpeDsKfQoKaW50IGdpdF9jb25maWdfcGVybShjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlKQp7CglpbnQgaTsKCWNoYXIgKmVuZHB0cjsKCglpZiAodmFsdWUgPT0gTlVMTCkKCQlyZXR1cm4gUEVSTV9HUk9VUDsKCglpZiAoIXN0cmNtcCh2YWx1ZSwgInVtYXNrIikpCgkJcmV0dXJuIFBFUk1fVU1BU0s7CglpZiAoIXN0cmNtcCh2YWx1ZSwgImdyb3VwIikpCgkJcmV0dXJuIFBFUk1fR1JPVVA7CglpZiAoIXN0cmNtcCh2YWx1ZSwgImFsbCIpIHx8CgkgICAgIXN0cmNtcCh2YWx1ZSwgIndvcmxkIikgfHwKCSAgICAhc3RyY21wKHZhbHVlLCAiZXZlcnlib2R5IikpCgkJcmV0dXJuIFBFUk1fRVZFUllCT0RZOwoKCS8qIFBhcnNlIG9jdGFsIG51bWJlcnMgKi8KCWkgPSBzdHJ0b2wodmFsdWUsICZlbmRwdHIsIDgpOwoKCS8qIElmIG5vdCBhbiBvY3RhbCBudW1iZXIsIG1heWJlIHRydWUvZmFsc2U/ICovCglpZiAoKmVuZHB0ciAhPSAwKQoJCXJldHVybiBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSkgPyBQRVJNX0dST1VQIDogUEVSTV9VTUFTSzsKCgkvKgoJICogVHJlYXQgdmFsdWVzIDAsIDEgYW5kIDIgYXMgY29tcGF0aWJpbGl0eSBjYXNlcywgb3RoZXJ3aXNlIGl0IGlzCgkgKiBhIGNobW9kIHZhbHVlIHRvIHJlc3RyaWN0IHRvLgoJICovCglzd2l0Y2ggKGkpIHsKCWNhc2UgUEVSTV9VTUFTSzogICAgICAgICAgICAgICAvKiAwICovCgkJcmV0dXJuIFBFUk1fVU1BU0s7CgljYXNlIE9MRF9QRVJNX0dST1VQOiAgICAgICAgICAgLyogMSAqLwoJCXJldHVybiBQRVJNX0dST1VQOwoJY2FzZSBPTERfUEVSTV9FVkVSWUJPRFk6ICAgICAgIC8qIDIgKi8KCQlyZXR1cm4gUEVSTV9FVkVSWUJPRFk7Cgl9CgoJLyogQSBmaWxlbW9kZSB2YWx1ZSB3YXMgZ2l2ZW46IDB4eHggKi8KCglpZiAoKGkgJiAwNjAwKSAhPSAwNjAwKQoJCWRpZShfKCJQcm9ibGVtIHdpdGggY29yZS5zaGFyZWRSZXBvc2l0b3J5IGZpbGVtb2RlIHZhbHVlICIKCQkgICAgIigwJS4zbykuXG5UaGUgb3duZXIgb2YgZmlsZXMgbXVzdCBhbHdheXMgaGF2ZSAiCgkJICAgICJyZWFkIGFuZCB3cml0ZSBwZXJtaXNzaW9ucy4iKSwgaSk7CgoJLyoKCSAqIE1hc2sgZmlsZW1vZGUgdmFsdWUuIE90aGVycyBjYW4gbm90IGdldCB3cml0ZSBwZXJtaXNzaW9uLgoJICogeCBmbGFncyBmb3IgZGlyZWN0b3JpZXMgYXJlIGhhbmRsZWQgc2VwYXJhdGVseS4KCSAqLwoJcmV0dXJuIC0oaSAmIDA2NjYpOwp9Cgp2b2lkIGNoZWNrX3JlcG9zaXRvcnlfZm9ybWF0KHZvaWQpCnsKCWNoZWNrX3JlcG9zaXRvcnlfZm9ybWF0X2dlbnRseShnZXRfZ2l0X2RpcigpLCBOVUxMKTsKCXN0YXJ0dXBfaW5mby0+aGF2ZV9yZXBvc2l0b3J5ID0gMTsKfQoKLyoKICogUmV0dXJucyB0aGUgInByZWZpeCIsIGEgcGF0aCB0byB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeQogKiByZWxhdGl2ZSB0byB0aGUgd29yayB0cmVlIHJvb3QsIG9yIE5VTEwsIGlmIHRoZSBjdXJyZW50IHdvcmtpbmcKICogZGlyZWN0b3J5IGlzIG5vdCBhIHN0cmljdCBzdWJkaXJlY3Rvcnkgb2YgdGhlIHdvcmsgdHJlZSByb290LiBUaGUKICogcHJlZml4IGFsd2F5cyBlbmRzIHdpdGggYSAnLycgY2hhcmFjdGVyLgogKi8KY29uc3QgY2hhciAqc2V0dXBfZ2l0X2RpcmVjdG9yeSh2b2lkKQp7CglyZXR1cm4gc2V0dXBfZ2l0X2RpcmVjdG9yeV9nZW50bHkoTlVMTCk7Cn0KCmNvbnN0IGNoYXIgKnJlc29sdmVfZ2l0ZGlyX2dlbnRseShjb25zdCBjaGFyICpzdXNwZWN0LCBpbnQgKnJldHVybl9lcnJvcl9jb2RlKQp7CglpZiAoaXNfZ2l0X2RpcmVjdG9yeShzdXNwZWN0KSkKCQlyZXR1cm4gc3VzcGVjdDsKCXJldHVybiByZWFkX2dpdGZpbGVfZ2VudGx5KHN1c3BlY3QsIHJldHVybl9lcnJvcl9jb2RlKTsKfQoKLyogaWYgYW55IHN0YW5kYXJkIGZpbGUgZGVzY3JpcHRvciBpcyBtaXNzaW5nIG9wZW4gaXQgdG8gL2Rldi9udWxsICovCnZvaWQgc2FuaXRpemVfc3RkZmRzKHZvaWQpCnsKCWludCBmZCA9IG9wZW4oIi9kZXYvbnVsbCIsIE9fUkRXUiwgMCk7Cgl3aGlsZSAoZmQgIT0gLTEgJiYgZmQgPCAyKQoJCWZkID0gZHVwKGZkKTsKCWlmIChmZCA9PSAtMSkKCQlkaWVfZXJybm8oIm9wZW4gL2Rldi9udWxsIG9yIGR1cCBmYWlsZWQiKTsKCWlmIChmZCA+IDIpCgkJY2xvc2UoZmQpOwp9CgppbnQgZGFlbW9uaXplKHZvaWQpCnsKI2lmZGVmIE5PX1BPU0lYX0dPT0RJRVMKCWVycm5vID0gRU5PU1lTOwoJcmV0dXJuIC0xOwojZWxzZQoJc3dpdGNoIChmb3JrKCkpIHsKCQljYXNlIDA6CgkJCWJyZWFrOwoJCWNhc2UgLTE6CgkJCWRpZV9lcnJubygiZm9yayBmYWlsZWQiKTsKCQlkZWZhdWx0OgoJCQlleGl0KDApOwoJfQoJaWYgKHNldHNpZCgpID09IC0xKQoJCWRpZV9lcnJubygic2V0c2lkIGZhaWxlZCIpOwoJY2xvc2UoMCk7CgljbG9zZSgxKTsKCWNsb3NlKDIpOwoJc2FuaXRpemVfc3RkZmRzKCk7CglyZXR1cm4gMDsKI2VuZGlmCn0K",
    "text": "#include \"cache.h\"\n#include \"dir.h\"\n#include \"string-list.h\"\n\nstatic int inside_git_dir = -1;\nstatic int inside_work_tree = -1;\nstatic int work_tree_config_is_bogus;\n\nstatic struct startup_info the_startup_info;\nstruct startup_info *startup_info = &the_startup_info;\n\n/*\n * The input parameter must contain an absolute path, and it must already be\n * normalized.\n *\n * Find the part of an absolute path that lies inside the work tree by\n * dereferencing symlinks outside the work tree, for example:\n * /dir1/repo/dir2/file   (work tree is /dir1/repo)      -> dir2/file\n * /dir/file              (work tree is /)               -> dir/file\n * /dir/symlink1/symlink2 (symlink1 points to work tree) -> symlink2\n * /dir/repolink/file     (repolink points to /dir/repo) -> file\n * /dir/repo              (exactly equal to work tree)   -> (empty string)\n */\nstatic int abspath_part_inside_repo(char *path)\n{\n\tsize_t len;\n\tsize_t wtlen;\n\tchar *path0;\n\tint off;\n\tconst char *work_tree = get_git_work_tree();\n\n\tif (!work_tree)\n\t\treturn -1;\n\twtlen = strlen(work_tree);\n\tlen = strlen(path);\n\toff = offset_1st_component(path);\n\n\t/* check if work tree is already the prefix */\n\tif (wtlen <= len && !strncmp(path, work_tree, wtlen)) {\n\t\tif (path[wtlen] == '/') {\n\t\t\tmemmove(path, path + wtlen + 1, len - wtlen);\n\t\t\treturn 0;\n\t\t} else if (path[wtlen - 1] == '/' || path[wtlen] == '\\0') {\n\t\t\t/* work tree is the root, or the whole path */\n\t\t\tmemmove(path, path + wtlen, len - wtlen + 1);\n\t\t\treturn 0;\n\t\t}\n\t\t/* work tree might match beginning of a symlink to work tree */\n\t\toff = wtlen;\n\t}\n\tpath0 = path;\n\tpath += off;\n\n\t/* check each '/'-terminated level */\n\twhile (*path) {\n\t\tpath++;\n\t\tif (*path == '/') {\n\t\t\t*path = '\\0';\n\t\t\tif (strcmp(real_path(path0), work_tree) == 0) {\n\t\t\t\tmemmove(path0, path + 1, len - (path - path0));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*path = '/';\n\t\t}\n\t}\n\n\t/* check whole path */\n\tif (strcmp(real_path(path0), work_tree) == 0) {\n\t\t*path0 = '\\0';\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\n/*\n * Normalize \"path\", prepending the \"prefix\" for relative paths. If\n * remaining_prefix is not NULL, return the actual prefix still\n * remains in the path. For example, prefix = sub1/sub2/ and path is\n *\n *  foo          -> sub1/sub2/foo  (full prefix)\n *  ../foo       -> sub1/foo       (remaining prefix is sub1/)\n *  ../../bar    -> bar            (no remaining prefix)\n *  ../../sub1/sub2/foo -> sub1/sub2/foo (but no remaining prefix)\n *  `pwd`/../bar -> sub1/bar       (no remaining prefix)\n */\nchar *prefix_path_gently(const char *prefix, int len,\n\t\t\t int *remaining_prefix, const char *path)\n{\n\tconst char *orig = path;\n\tchar *sanitized;\n\tif (is_absolute_path(orig)) {\n\t\tsanitized = xmallocz(strlen(path));\n\t\tif (remaining_prefix)\n\t\t\t*remaining_prefix = 0;\n\t\tif (normalize_path_copy_len(sanitized, path, remaining_prefix)) {\n\t\t\tfree(sanitized);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (abspath_part_inside_repo(sanitized)) {\n\t\t\tfree(sanitized);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tsanitized = xstrfmt(\"%.*s%s\", len, len ? prefix : \"\", path);\n\t\tif (remaining_prefix)\n\t\t\t*remaining_prefix = len;\n\t\tif (normalize_path_copy_len(sanitized, sanitized, remaining_prefix)) {\n\t\t\tfree(sanitized);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn sanitized;\n}\n\nchar *prefix_path(const char *prefix, int len, const char *path)\n{\n\tchar *r = prefix_path_gently(prefix, len, NULL, path);\n\tif (!r)\n\t\tdie(\"'%s' is outside repository\", path);\n\treturn r;\n}\n\nint path_inside_repo(const char *prefix, const char *path)\n{\n\tint len = prefix ? strlen(prefix) : 0;\n\tchar *r = prefix_path_gently(prefix, len, NULL, path);\n\tif (r) {\n\t\tfree(r);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint check_filename(const char *prefix, const char *arg)\n{\n\tchar *to_free = NULL;\n\tstruct stat st;\n\n\tif (starts_with(arg, \":/\")) {\n\t\tif (arg[2] == '\\0') /* \":/\" is root dir, always exists */\n\t\t\treturn 1;\n\t\targ += 2;\n\t\tprefix = NULL;\n\t}\n\n\tif (prefix)\n\t\targ = to_free = prefix_filename(prefix, arg);\n\n\tif (!lstat(arg, &st)) {\n\t\tfree(to_free);\n\t\treturn 1; /* file exists */\n\t}\n\tif (errno == ENOENT || errno == ENOTDIR) {\n\t\tfree(to_free);\n\t\treturn 0; /* file does not exist */\n\t}\n\tdie_errno(\"failed to stat '%s'\", arg);\n}\n\nstatic void NORETURN die_verify_filename(const char *prefix,\n\t\t\t\t\t const char *arg,\n\t\t\t\t\t int diagnose_misspelt_rev)\n{\n\tif (!diagnose_misspelt_rev)\n\t\tdie(_(\"%s: no such path in the working tree.\\n\"\n\t\t      \"Use 'git <command> -- <path>...' to specify paths that do not exist locally.\"),\n\t\t    arg);\n\t/*\n\t * Saying \"'(icase)foo' does not exist in the index\" when the\n\t * user gave us \":(icase)foo\" is just stupid.  A magic pathspec\n\t * begins with a colon and is followed by a non-alnum; do not\n\t * let maybe_die_on_misspelt_object_name() even trigger.\n\t */\n\tif (!(arg[0] == ':' && !isalnum(arg[1])))\n\t\tmaybe_die_on_misspelt_object_name(arg, prefix);\n\n\t/* ... or fall back the most general message. */\n\tdie(_(\"ambiguous argument '%s': unknown revision or path not in the working tree.\\n\"\n\t      \"Use '--' to separate paths from revisions, like this:\\n\"\n\t      \"'git <command> [<revision>...] -- [<file>...]'\"), arg);\n\n}\n\n/*\n * Verify a filename that we got as an argument for a pathspec\n * entry. Note that a filename that begins with \"-\" never verifies\n * as true, because even if such a filename were to exist, we want\n * it to be preceded by the \"--\" marker (or we want the user to\n * use a format like \"./-filename\")\n *\n * The \"diagnose_misspelt_rev\" is used to provide a user-friendly\n * diagnosis when dying upon finding that \"name\" is not a pathname.\n * If set to 1, the diagnosis will try to diagnose \"name\" as an\n * invalid object name (e.g. HEAD:foo). If set to 0, the diagnosis\n * will only complain about an inexisting file.\n *\n * This function is typically called to check that a \"file or rev\"\n * argument is unambiguous. In this case, the caller will want\n * diagnose_misspelt_rev == 1 when verifying the first non-rev\n * argument (which could have been a revision), and\n * diagnose_misspelt_rev == 0 for the next ones (because we already\n * saw a filename, there's not ambiguity anymore).\n */\nvoid verify_filename(const char *prefix,\n\t\t     const char *arg,\n\t\t     int diagnose_misspelt_rev)\n{\n\tif (*arg == '-')\n\t\tdie(\"bad flag '%s' used after filename\", arg);\n\tif (check_filename(prefix, arg) || !no_wildcard(arg))\n\t\treturn;\n\tdie_verify_filename(prefix, arg, diagnose_misspelt_rev);\n}\n\n/*\n * Opposite of the above: the command line did not have -- marker\n * and we parsed the arg as a refname.  It should not be interpretable\n * as a filename.\n */\nvoid verify_non_filename(const char *prefix, const char *arg)\n{\n\tif (!is_inside_work_tree() || is_inside_git_dir())\n\t\treturn;\n\tif (*arg == '-')\n\t\treturn; /* flag */\n\tif (!check_filename(prefix, arg))\n\t\treturn;\n\tdie(_(\"ambiguous argument '%s': both revision and filename\\n\"\n\t      \"Use '--' to separate paths from revisions, like this:\\n\"\n\t      \"'git <command> [<revision>...] -- [<file>...]'\"), arg);\n}\n\nint get_common_dir(struct strbuf *sb, const char *gitdir)\n{\n\tconst char *git_env_common_dir = getenv(GIT_COMMON_DIR_ENVIRONMENT);\n\tif (git_env_common_dir) {\n\t\tstrbuf_addstr(sb, git_env_common_dir);\n\t\treturn 1;\n\t} else {\n\t\treturn get_common_dir_noenv(sb, gitdir);\n\t}\n}\n\nint get_common_dir_noenv(struct strbuf *sb, const char *gitdir)\n{\n\tstruct strbuf data = STRBUF_INIT;\n\tstruct strbuf path = STRBUF_INIT;\n\tint ret = 0;\n\n\tstrbuf_addf(&path, \"%s/commondir\", gitdir);\n\tif (file_exists(path.buf)) {\n\t\tif (strbuf_read_file(&data, path.buf, 0) <= 0)\n\t\t\tdie_errno(_(\"failed to read %s\"), path.buf);\n\t\twhile (data.len && (data.buf[data.len - 1] == '\\n' ||\n\t\t\t\t    data.buf[data.len - 1] == '\\r'))\n\t\t\tdata.len--;\n\t\tdata.buf[data.len] = '\\0';\n\t\tstrbuf_reset(&path);\n\t\tif (!is_absolute_path(data.buf))\n\t\t\tstrbuf_addf(&path, \"%s/\", gitdir);\n\t\tstrbuf_addbuf(&path, &data);\n\t\tstrbuf_add_real_path(sb, path.buf);\n\t\tret = 1;\n\t} else {\n\t\tstrbuf_addstr(sb, gitdir);\n\t}\n\n\tstrbuf_release(&data);\n\tstrbuf_release(&path);\n\treturn ret;\n}\n\n/*\n * Test if it looks like we're at a git directory.\n * We want to see:\n *\n *  - either an objects/ directory _or_ the proper\n *    GIT_OBJECT_DIRECTORY environment variable\n *  - a refs/ directory\n *  - either a HEAD symlink or a HEAD file that is formatted as\n *    a proper \"ref:\", or a regular file HEAD that has a properly\n *    formatted sha1 object name.\n */\nint is_git_directory(const char *suspect)\n{\n\tstruct strbuf path = STRBUF_INIT;\n\tint ret = 0;\n\tsize_t len;\n\n\t/* Check worktree-related signatures */\n\tstrbuf_addf(&path, \"%s/HEAD\", suspect);\n\tif (validate_headref(path.buf))\n\t\tgoto done;\n\n\tstrbuf_reset(&path);\n\tget_common_dir(&path, suspect);\n\tlen = path.len;\n\n\t/* Check non-worktree-related signatures */\n\tif (getenv(DB_ENVIRONMENT)) {\n\t\tif (access(getenv(DB_ENVIRONMENT), X_OK))\n\t\t\tgoto done;\n\t}\n\telse {\n\t\tstrbuf_setlen(&path, len);\n\t\tstrbuf_addstr(&path, \"/objects\");\n\t\tif (access(path.buf, X_OK))\n\t\t\tgoto done;\n\t}\n\n\tstrbuf_setlen(&path, len);\n\tstrbuf_addstr(&path, \"/refs\");\n\tif (access(path.buf, X_OK))\n\t\tgoto done;\n\n\tret = 1;\ndone:\n\tstrbuf_release(&path);\n\treturn ret;\n}\n\nint is_nonbare_repository_dir(struct strbuf *path)\n{\n\tint ret = 0;\n\tint gitfile_error;\n\tsize_t orig_path_len = path->len;\n\tassert(orig_path_len != 0);\n\tstrbuf_complete(path, '/');\n\tstrbuf_addstr(path, \".git\");\n\tif (read_gitfile_gently(path->buf, &gitfile_error) || is_git_directory(path->buf))\n\t\tret = 1;\n\tif (gitfile_error == READ_GITFILE_ERR_OPEN_FAILED ||\n\t    gitfile_error == READ_GITFILE_ERR_READ_FAILED)\n\t\tret = 1;\n\tstrbuf_setlen(path, orig_path_len);\n\treturn ret;\n}\n\nint is_inside_git_dir(void)\n{\n\tif (inside_git_dir < 0)\n\t\tinside_git_dir = is_inside_dir(get_git_dir());\n\treturn inside_git_dir;\n}\n\nint is_inside_work_tree(void)\n{\n\tif (inside_work_tree < 0)\n\t\tinside_work_tree = is_inside_dir(get_git_work_tree());\n\treturn inside_work_tree;\n}\n\nvoid setup_work_tree(void)\n{\n\tconst char *work_tree, *git_dir;\n\tstatic int initialized = 0;\n\n\tif (initialized)\n\t\treturn;\n\n\tif (work_tree_config_is_bogus)\n\t\tdie(\"unable to set up work tree using invalid config\");\n\n\twork_tree = get_git_work_tree();\n\tgit_dir = get_git_dir();\n\tif (!is_absolute_path(git_dir))\n\t\tgit_dir = real_path(get_git_dir());\n\tif (!work_tree || chdir(work_tree))\n\t\tdie(\"This operation must be run in a work tree\");\n\n\t/*\n\t * Make sure subsequent git processes find correct worktree\n\t * if $GIT_WORK_TREE is set relative\n\t */\n\tif (getenv(GIT_WORK_TREE_ENVIRONMENT))\n\t\tsetenv(GIT_WORK_TREE_ENVIRONMENT, \".\", 1);\n\n\tset_git_dir(remove_leading_path(git_dir, work_tree));\n\tinitialized = 1;\n}\n\nstatic int check_repo_format(const char *var, const char *value, void *vdata)\n{\n\tstruct repository_format *data = vdata;\n\tconst char *ext;\n\n\tif (strcmp(var, \"core.repositoryformatversion\") == 0)\n\t\tdata->version = git_config_int(var, value);\n\telse if (skip_prefix(var, \"extensions.\", &ext)) {\n\t\t/*\n\t\t * record any known extensions here; otherwise,\n\t\t * we fall through to recording it as unknown, and\n\t\t * check_repository_format will complain\n\t\t */\n\t\tif (!strcmp(ext, \"noop\"))\n\t\t\t;\n\t\telse if (!strcmp(ext, \"preciousobjects\"))\n\t\t\tdata->precious_objects = git_config_bool(var, value);\n\t\telse\n\t\t\tstring_list_append(&data->unknown_extensions, ext);\n\t} else if (strcmp(var, \"core.bare\") == 0) {\n\t\tdata->is_bare = git_config_bool(var, value);\n\t} else if (strcmp(var, \"core.worktree\") == 0) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tdata->work_tree = xstrdup(value);\n\t}\n\treturn 0;\n}\n\nstatic int check_repository_format_gently(const char *gitdir, int *nongit_ok)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tstruct strbuf err = STRBUF_INIT;\n\tstruct repository_format candidate;\n\tint has_common;\n\n\thas_common = get_common_dir(&sb, gitdir);\n\tstrbuf_addstr(&sb, \"/config\");\n\tread_repository_format(&candidate, sb.buf);\n\tstrbuf_release(&sb);\n\n\t/*\n\t * For historical use of check_repository_format() in git-init,\n\t * we treat a missing config as a silent \"ok\", even when nongit_ok\n\t * is unset.\n\t */\n\tif (candidate.version < 0)\n\t\treturn 0;\n\n\tif (verify_repository_format(&candidate, &err) < 0) {\n\t\tif (nongit_ok) {\n\t\t\twarning(\"%s\", err.buf);\n\t\t\tstrbuf_release(&err);\n\t\t\t*nongit_ok = -1;\n\t\t\treturn -1;\n\t\t}\n\t\tdie(\"%s\", err.buf);\n\t}\n\n\trepository_format_precious_objects = candidate.precious_objects;\n\tstring_list_clear(&candidate.unknown_extensions, 0);\n\tif (!has_common) {\n\t\tif (candidate.is_bare != -1) {\n\t\t\tis_bare_repository_cfg = candidate.is_bare;\n\t\t\tif (is_bare_repository_cfg == 1)\n\t\t\t\tinside_work_tree = -1;\n\t\t}\n\t\tif (candidate.work_tree) {\n\t\t\tfree(git_work_tree_cfg);\n\t\t\tgit_work_tree_cfg = candidate.work_tree;\n\t\t\tinside_work_tree = -1;\n\t\t}\n\t} else {\n\t\tfree(candidate.work_tree);\n\t}\n\n\treturn 0;\n}\n\nint read_repository_format(struct repository_format *format, const char *path)\n{\n\tmemset(format, 0, sizeof(*format));\n\tformat->version = -1;\n\tformat->is_bare = -1;\n\tstring_list_init(&format->unknown_extensions, 1);\n\tgit_config_from_file(check_repo_format, path, format);\n\treturn format->version;\n}\n\nint verify_repository_format(const struct repository_format *format,\n\t\t\t     struct strbuf *err)\n{\n\tif (GIT_REPO_VERSION_READ < format->version) {\n\t\tstrbuf_addf(err, _(\"Expected git repo version <= %d, found %d\"),\n\t\t\t    GIT_REPO_VERSION_READ, format->version);\n\t\treturn -1;\n\t}\n\n\tif (format->version >= 1 && format->unknown_extensions.nr) {\n\t\tint i;\n\n\t\tstrbuf_addstr(err, _(\"unknown repository extensions found:\"));\n\n\t\tfor (i = 0; i < format->unknown_extensions.nr; i++)\n\t\t\tstrbuf_addf(err, \"\\n\\t%s\",\n\t\t\t\t    format->unknown_extensions.items[i].string);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid read_gitfile_error_die(int error_code, const char *path, const char *dir)\n{\n\tswitch (error_code) {\n\tcase READ_GITFILE_ERR_STAT_FAILED:\n\tcase READ_GITFILE_ERR_NOT_A_FILE:\n\t\t/* non-fatal; follow return path */\n\t\tbreak;\n\tcase READ_GITFILE_ERR_OPEN_FAILED:\n\t\tdie_errno(\"Error opening '%s'\", path);\n\tcase READ_GITFILE_ERR_TOO_LARGE:\n\t\tdie(\"Too large to be a .git file: '%s'\", path);\n\tcase READ_GITFILE_ERR_READ_FAILED:\n\t\tdie(\"Error reading %s\", path);\n\tcase READ_GITFILE_ERR_INVALID_FORMAT:\n\t\tdie(\"Invalid gitfile format: %s\", path);\n\tcase READ_GITFILE_ERR_NO_PATH:\n\t\tdie(\"No path in gitfile: %s\", path);\n\tcase READ_GITFILE_ERR_NOT_A_REPO:\n\t\tdie(\"Not a git repository: %s\", dir);\n\tdefault:\n\t\tdie(\"BUG: unknown error code\");\n\t}\n}\n\n/*\n * Try to read the location of the git directory from the .git file,\n * return path to git directory if found.\n *\n * On failure, if return_error_code is not NULL, return_error_code\n * will be set to an error code and NULL will be returned. If\n * return_error_code is NULL the function will die instead (for most\n * cases).\n */\nconst char *read_gitfile_gently(const char *path, int *return_error_code)\n{\n\tconst int max_file_size = 1 << 20;  /* 1MB */\n\tint error_code = 0;\n\tchar *buf = NULL;\n\tchar *dir = NULL;\n\tconst char *slash;\n\tstruct stat st;\n\tint fd;\n\tssize_t len;\n\n\tif (stat(path, &st)) {\n\t\t/* NEEDSWORK: discern between ENOENT vs other errors */\n\t\terror_code = READ_GITFILE_ERR_STAT_FAILED;\n\t\tgoto cleanup_return;\n\t}\n\tif (!S_ISREG(st.st_mode)) {\n\t\terror_code = READ_GITFILE_ERR_NOT_A_FILE;\n\t\tgoto cleanup_return;\n\t}\n\tif (st.st_size > max_file_size) {\n\t\terror_code = READ_GITFILE_ERR_TOO_LARGE;\n\t\tgoto cleanup_return;\n\t}\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0) {\n\t\terror_code = READ_GITFILE_ERR_OPEN_FAILED;\n\t\tgoto cleanup_return;\n\t}\n\tbuf = xmallocz(st.st_size);\n\tlen = read_in_full(fd, buf, st.st_size);\n\tclose(fd);\n\tif (len != st.st_size) {\n\t\terror_code = READ_GITFILE_ERR_READ_FAILED;\n\t\tgoto cleanup_return;\n\t}\n\tif (!starts_with(buf, \"gitdir: \")) {\n\t\terror_code = READ_GITFILE_ERR_INVALID_FORMAT;\n\t\tgoto cleanup_return;\n\t}\n\twhile (buf[len - 1] == '\\n' || buf[len - 1] == '\\r')\n\t\tlen--;\n\tif (len < 9) {\n\t\terror_code = READ_GITFILE_ERR_NO_PATH;\n\t\tgoto cleanup_return;\n\t}\n\tbuf[len] = '\\0';\n\tdir = buf + 8;\n\n\tif (!is_absolute_path(dir) && (slash = strrchr(path, '/'))) {\n\t\tsize_t pathlen = slash+1 - path;\n\t\tdir = xstrfmt(\"%.*s%.*s\", (int)pathlen, path,\n\t\t\t      (int)(len - 8), buf + 8);\n\t\tfree(buf);\n\t\tbuf = dir;\n\t}\n\tif (!is_git_directory(dir)) {\n\t\terror_code = READ_GITFILE_ERR_NOT_A_REPO;\n\t\tgoto cleanup_return;\n\t}\n\tpath = real_path(dir);\n\ncleanup_return:\n\tif (return_error_code)\n\t\t*return_error_code = error_code;\n\telse if (error_code)\n\t\tread_gitfile_error_die(error_code, path, dir);\n\n\tfree(buf);\n\treturn error_code ? NULL : path;\n}\n\nstatic const char *setup_explicit_git_dir(const char *gitdirenv,\n\t\t\t\t\t  struct strbuf *cwd,\n\t\t\t\t\t  int *nongit_ok)\n{\n\tconst char *work_tree_env = getenv(GIT_WORK_TREE_ENVIRONMENT);\n\tconst char *worktree;\n\tchar *gitfile;\n\tint offset;\n\n\tif (PATH_MAX - 40 < strlen(gitdirenv))\n\t\tdie(\"'$%s' too big\", GIT_DIR_ENVIRONMENT);\n\n\tgitfile = (char*)read_gitfile(gitdirenv);\n\tif (gitfile) {\n\t\tgitfile = xstrdup(gitfile);\n\t\tgitdirenv = gitfile;\n\t}\n\n\tif (!is_git_directory(gitdirenv)) {\n\t\tif (nongit_ok) {\n\t\t\t*nongit_ok = 1;\n\t\t\tfree(gitfile);\n\t\t\treturn NULL;\n\t\t}\n\t\tdie(\"Not a git repository: '%s'\", gitdirenv);\n\t}\n\n\tif (check_repository_format_gently(gitdirenv, nongit_ok)) {\n\t\tfree(gitfile);\n\t\treturn NULL;\n\t}\n\n\t/* #3, #7, #11, #15, #19, #23, #27, #31 (see t1510) */\n\tif (work_tree_env)\n\t\tset_git_work_tree(work_tree_env);\n\telse if (is_bare_repository_cfg > 0) {\n\t\tif (git_work_tree_cfg) {\n\t\t\t/* #22.2, #30 */\n\t\t\twarning(\"core.bare and core.worktree do not make sense\");\n\t\t\twork_tree_config_is_bogus = 1;\n\t\t}\n\n\t\t/* #18, #26 */\n\t\tset_git_dir(gitdirenv);\n\t\tfree(gitfile);\n\t\treturn NULL;\n\t}\n\telse if (git_work_tree_cfg) { /* #6, #14 */\n\t\tif (is_absolute_path(git_work_tree_cfg))\n\t\t\tset_git_work_tree(git_work_tree_cfg);\n\t\telse {\n\t\t\tchar *core_worktree;\n\t\t\tif (chdir(gitdirenv))\n\t\t\t\tdie_errno(\"Could not chdir to '%s'\", gitdirenv);\n\t\t\tif (chdir(git_work_tree_cfg))\n\t\t\t\tdie_errno(\"Could not chdir to '%s'\", git_work_tree_cfg);\n\t\t\tcore_worktree = xgetcwd();\n\t\t\tif (chdir(cwd->buf))\n\t\t\t\tdie_errno(\"Could not come back to cwd\");\n\t\t\tset_git_work_tree(core_worktree);\n\t\t\tfree(core_worktree);\n\t\t}\n\t}\n\telse if (!git_env_bool(GIT_IMPLICIT_WORK_TREE_ENVIRONMENT, 1)) {\n\t\t/* #16d */\n\t\tset_git_dir(gitdirenv);\n\t\tfree(gitfile);\n\t\treturn NULL;\n\t}\n\telse /* #2, #10 */\n\t\tset_git_work_tree(\".\");\n\n\t/* set_git_work_tree() must have been called by now */\n\tworktree = get_git_work_tree();\n\n\t/* both get_git_work_tree() and cwd are already normalized */\n\tif (!strcmp(cwd->buf, worktree)) { /* cwd == worktree */\n\t\tset_git_dir(gitdirenv);\n\t\tfree(gitfile);\n\t\treturn NULL;\n\t}\n\n\toffset = dir_inside_of(cwd->buf, worktree);\n\tif (offset >= 0) {\t/* cwd inside worktree? */\n\t\tset_git_dir(real_path(gitdirenv));\n\t\tif (chdir(worktree))\n\t\t\tdie_errno(\"Could not chdir to '%s'\", worktree);\n\t\tstrbuf_addch(cwd, '/');\n\t\tfree(gitfile);\n\t\treturn cwd->buf + offset;\n\t}\n\n\t/* cwd outside worktree */\n\tset_git_dir(gitdirenv);\n\tfree(gitfile);\n\treturn NULL;\n}\n\nstatic const char *setup_discovered_git_dir(const char *gitdir,\n\t\t\t\t\t    struct strbuf *cwd, int offset,\n\t\t\t\t\t    int *nongit_ok)\n{\n\tif (check_repository_format_gently(gitdir, nongit_ok))\n\t\treturn NULL;\n\n\t/* --work-tree is set without --git-dir; use discovered one */\n\tif (getenv(GIT_WORK_TREE_ENVIRONMENT) || git_work_tree_cfg) {\n\t\tif (offset != cwd->len && !is_absolute_path(gitdir))\n\t\t\tgitdir = real_pathdup(gitdir, 1);\n\t\tif (chdir(cwd->buf))\n\t\t\tdie_errno(\"Could not come back to cwd\");\n\t\treturn setup_explicit_git_dir(gitdir, cwd, nongit_ok);\n\t}\n\n\t/* #16.2, #17.2, #20.2, #21.2, #24, #25, #28, #29 (see t1510) */\n\tif (is_bare_repository_cfg > 0) {\n\t\tset_git_dir(offset == cwd->len ? gitdir : real_path(gitdir));\n\t\tif (chdir(cwd->buf))\n\t\t\tdie_errno(\"Could not come back to cwd\");\n\t\treturn NULL;\n\t}\n\n\t/* #0, #1, #5, #8, #9, #12, #13 */\n\tset_git_work_tree(\".\");\n\tif (strcmp(gitdir, DEFAULT_GIT_DIR_ENVIRONMENT))\n\t\tset_git_dir(gitdir);\n\tinside_git_dir = 0;\n\tinside_work_tree = 1;\n\tif (offset == cwd->len)\n\t\treturn NULL;\n\n\t/* Make \"offset\" point past the '/' (already the case for root dirs) */\n\tif (offset != offset_1st_component(cwd->buf))\n\t\toffset++;\n\t/* Add a '/' at the end */\n\tstrbuf_addch(cwd, '/');\n\treturn cwd->buf + offset;\n}\n\n/* #16.1, #17.1, #20.1, #21.1, #22.1 (see t1510) */\nstatic const char *setup_bare_git_dir(struct strbuf *cwd, int offset,\n\t\t\t\t      int *nongit_ok)\n{\n\tint root_len;\n\n\tif (check_repository_format_gently(\".\", nongit_ok))\n\t\treturn NULL;\n\n\tsetenv(GIT_IMPLICIT_WORK_TREE_ENVIRONMENT, \"0\", 1);\n\n\t/* --work-tree is set without --git-dir; use discovered one */\n\tif (getenv(GIT_WORK_TREE_ENVIRONMENT) || git_work_tree_cfg) {\n\t\tconst char *gitdir;\n\n\t\tgitdir = offset == cwd->len ? \".\" : xmemdupz(cwd->buf, offset);\n\t\tif (chdir(cwd->buf))\n\t\t\tdie_errno(\"Could not come back to cwd\");\n\t\treturn setup_explicit_git_dir(gitdir, cwd, nongit_ok);\n\t}\n\n\tinside_git_dir = 1;\n\tinside_work_tree = 0;\n\tif (offset != cwd->len) {\n\t\tif (chdir(cwd->buf))\n\t\t\tdie_errno(\"Cannot come back to cwd\");\n\t\troot_len = offset_1st_component(cwd->buf);\n\t\tstrbuf_setlen(cwd, offset > root_len ? offset : root_len);\n\t\tset_git_dir(cwd->buf);\n\t}\n\telse\n\t\tset_git_dir(\".\");\n\treturn NULL;\n}\n\nstatic const char *setup_nongit(const char *cwd, int *nongit_ok)\n{\n\tif (!nongit_ok)\n\t\tdie(_(\"Not a git repository (or any of the parent directories): %s\"), DEFAULT_GIT_DIR_ENVIRONMENT);\n\tif (chdir(cwd))\n\t\tdie_errno(_(\"Cannot come back to cwd\"));\n\t*nongit_ok = 1;\n\treturn NULL;\n}\n\nstatic dev_t get_device_or_die(const char *path, const char *prefix, int prefix_len)\n{\n\tstruct stat buf;\n\tif (stat(path, &buf)) {\n\t\tdie_errno(\"failed to stat '%*s%s%s'\",\n\t\t\t\tprefix_len,\n\t\t\t\tprefix ? prefix : \"\",\n\t\t\t\tprefix ? \"/\" : \"\", path);\n\t}\n\treturn buf.st_dev;\n}\n\n/*\n * A \"string_list_each_func_t\" function that canonicalizes an entry\n * from GIT_CEILING_DIRECTORIES using real_path_if_valid(), or\n * discards it if unusable.  The presence of an empty entry in\n * GIT_CEILING_DIRECTORIES turns off canonicalization for all\n * subsequent entries.\n */\nstatic int canonicalize_ceiling_entry(struct string_list_item *item,\n\t\t\t\t      void *cb_data)\n{\n\tint *empty_entry_found = cb_data;\n\tchar *ceil = item->string;\n\n\tif (!*ceil) {\n\t\t*empty_entry_found = 1;\n\t\treturn 0;\n\t} else if (!is_absolute_path(ceil)) {\n\t\treturn 0;\n\t} else if (*empty_entry_found) {\n\t\t/* Keep entry but do not canonicalize it */\n\t\treturn 1;\n\t} else {\n\t\tchar *real_path = real_pathdup(ceil, 0);\n\t\tif (!real_path) {\n\t\t\treturn 0;\n\t\t}\n\t\tfree(item->string);\n\t\titem->string = real_path;\n\t\treturn 1;\n\t}\n}\n\nenum discovery_result {\n\tGIT_DIR_NONE = 0,\n\tGIT_DIR_EXPLICIT,\n\tGIT_DIR_DISCOVERED,\n\tGIT_DIR_BARE,\n\t/* these are errors */\n\tGIT_DIR_HIT_CEILING = -1,\n\tGIT_DIR_HIT_MOUNT_POINT = -2,\n\tGIT_DIR_INVALID_GITFILE = -3\n};\n\n/*\n * We cannot decide in this function whether we are in the work tree or\n * not, since the config can only be read _after_ this function was called.\n *\n * Also, we avoid changing any global state (such as the current working\n * directory) to allow early callers.\n *\n * The directory where the search should start needs to be passed in via the\n * `dir` parameter; upon return, the `dir` buffer will contain the path of\n * the directory where the search ended, and `gitdir` will contain the path of\n * the discovered .git/ directory, if any. If `gitdir` is not absolute, it\n * is relative to `dir` (i.e. *not* necessarily the cwd).\n */\nstatic enum discovery_result setup_git_directory_gently_1(struct strbuf *dir,\n\t\t\t\t\t\t\t  struct strbuf *gitdir,\n\t\t\t\t\t\t\t  int die_on_error)\n{\n\tconst char *env_ceiling_dirs = getenv(CEILING_DIRECTORIES_ENVIRONMENT);\n\tstruct string_list ceiling_dirs = STRING_LIST_INIT_DUP;\n\tconst char *gitdirenv;\n\tint ceil_offset = -1, min_offset = has_dos_drive_prefix(dir->buf) ? 3 : 1;\n\tdev_t current_device = 0;\n\tint one_filesystem = 1;\n\n\t/*\n\t * If GIT_DIR is set explicitly, we're not going\n\t * to do any discovery, but we still do repository\n\t * validation.\n\t */\n\tgitdirenv = getenv(GIT_DIR_ENVIRONMENT);\n\tif (gitdirenv) {\n\t\tstrbuf_addstr(gitdir, gitdirenv);\n\t\treturn GIT_DIR_EXPLICIT;\n\t}\n\n\tif (env_ceiling_dirs) {\n\t\tint empty_entry_found = 0;\n\n\t\tstring_list_split(&ceiling_dirs, env_ceiling_dirs, PATH_SEP, -1);\n\t\tfilter_string_list(&ceiling_dirs, 0,\n\t\t\t\t   canonicalize_ceiling_entry, &empty_entry_found);\n\t\tceil_offset = longest_ancestor_length(dir->buf, &ceiling_dirs);\n\t\tstring_list_clear(&ceiling_dirs, 0);\n\t}\n\n\tif (ceil_offset < 0)\n\t\tceil_offset = min_offset - 2;\n\n\t/*\n\t * Test in the following order (relative to the dir):\n\t * - .git (file containing \"gitdir: <path>\")\n\t * - .git/\n\t * - ./ (bare)\n\t * - ../.git\n\t * - ../.git/\n\t * - ../ (bare)\n\t * - ../../.git/\n\t *   etc.\n\t */\n\tone_filesystem = !git_env_bool(\"GIT_DISCOVERY_ACROSS_FILESYSTEM\", 0);\n\tif (one_filesystem)\n\t\tcurrent_device = get_device_or_die(dir->buf, NULL, 0);\n\tfor (;;) {\n\t\tint offset = dir->len, error_code = 0;\n\n\t\tif (offset > min_offset)\n\t\t\tstrbuf_addch(dir, '/');\n\t\tstrbuf_addstr(dir, DEFAULT_GIT_DIR_ENVIRONMENT);\n\t\tgitdirenv = read_gitfile_gently(dir->buf, die_on_error ?\n\t\t\t\t\t\tNULL : &error_code);\n\t\tif (!gitdirenv) {\n\t\t\tif (die_on_error ||\n\t\t\t    error_code == READ_GITFILE_ERR_NOT_A_FILE) {\n\t\t\t\t/* NEEDSWORK: fail if .git is not file nor dir */\n\t\t\t\tif (is_git_directory(dir->buf))\n\t\t\t\t\tgitdirenv = DEFAULT_GIT_DIR_ENVIRONMENT;\n\t\t\t} else if (error_code != READ_GITFILE_ERR_STAT_FAILED)\n\t\t\t\treturn GIT_DIR_INVALID_GITFILE;\n\t\t}\n\t\tstrbuf_setlen(dir, offset);\n\t\tif (gitdirenv) {\n\t\t\tstrbuf_addstr(gitdir, gitdirenv);\n\t\t\treturn GIT_DIR_DISCOVERED;\n\t\t}\n\n\t\tif (is_git_directory(dir->buf)) {\n\t\t\tstrbuf_addstr(gitdir, \".\");\n\t\t\treturn GIT_DIR_BARE;\n\t\t}\n\n\t\tif (offset <= min_offset)\n\t\t\treturn GIT_DIR_HIT_CEILING;\n\n\t\twhile (--offset > ceil_offset && !is_dir_sep(dir->buf[offset]))\n\t\t\t; /* continue */\n\t\tif (offset <= ceil_offset)\n\t\t\treturn GIT_DIR_HIT_CEILING;\n\n\t\tstrbuf_setlen(dir, offset > min_offset ?  offset : min_offset);\n\t\tif (one_filesystem &&\n\t\t    current_device != get_device_or_die(dir->buf, NULL, offset))\n\t\t\treturn GIT_DIR_HIT_MOUNT_POINT;\n\t}\n}\n\nconst char *discover_git_directory(struct strbuf *gitdir)\n{\n\tstruct strbuf dir = STRBUF_INIT, err = STRBUF_INIT;\n\tsize_t gitdir_offset = gitdir->len, cwd_len;\n\tstruct repository_format candidate;\n\n\tif (strbuf_getcwd(&dir))\n\t\treturn NULL;\n\n\tcwd_len = dir.len;\n\tif (setup_git_directory_gently_1(&dir, gitdir, 0) <= 0) {\n\t\tstrbuf_release(&dir);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * The returned gitdir is relative to dir, and if dir does not reflect\n\t * the current working directory, we simply make the gitdir absolute.\n\t */\n\tif (dir.len < cwd_len && !is_absolute_path(gitdir->buf + gitdir_offset)) {\n\t\t/* Avoid a trailing \"/.\" */\n\t\tif (!strcmp(\".\", gitdir->buf + gitdir_offset))\n\t\t\tstrbuf_setlen(gitdir, gitdir_offset);\n\t\telse\n\t\t\tstrbuf_addch(&dir, '/');\n\t\tstrbuf_insert(gitdir, gitdir_offset, dir.buf, dir.len);\n\t}\n\n\tstrbuf_reset(&dir);\n\tstrbuf_addf(&dir, \"%s/config\", gitdir->buf + gitdir_offset);\n\tread_repository_format(&candidate, dir.buf);\n\tstrbuf_release(&dir);\n\n\tif (verify_repository_format(&candidate, &err) < 0) {\n\t\twarning(\"ignoring git dir '%s': %s\",\n\t\t\tgitdir->buf + gitdir_offset, err.buf);\n\t\tstrbuf_release(&err);\n\t\treturn NULL;\n\t}\n\n\treturn gitdir->buf + gitdir_offset;\n}\n\nconst char *setup_git_directory_gently(int *nongit_ok)\n{\n\tstatic struct strbuf cwd = STRBUF_INIT;\n\tstruct strbuf dir = STRBUF_INIT, gitdir = STRBUF_INIT;\n\tconst char *prefix, *env_prefix;\n\n\t/*\n\t * We may have read an incomplete configuration before\n\t * setting-up the git directory. If so, clear the cache so\n\t * that the next queries to the configuration reload complete\n\t * configuration (including the per-repo config file that we\n\t * ignored previously).\n\t */\n\tgit_config_clear();\n\n\t/*\n\t * Let's assume that we are in a git repository.\n\t * If it turns out later that we are somewhere else, the value will be\n\t * updated accordingly.\n\t */\n\tif (nongit_ok)\n\t\t*nongit_ok = 0;\n\n\tif (strbuf_getcwd(&cwd))\n\t\tdie_errno(_(\"Unable to read current working directory\"));\n\tstrbuf_addbuf(&dir, &cwd);\n\n\tswitch (setup_git_directory_gently_1(&dir, &gitdir, 1)) {\n\tcase GIT_DIR_NONE:\n\t\tprefix = NULL;\n\t\tbreak;\n\tcase GIT_DIR_EXPLICIT:\n\t\tprefix = setup_explicit_git_dir(gitdir.buf, &cwd, nongit_ok);\n\t\tbreak;\n\tcase GIT_DIR_DISCOVERED:\n\t\tif (dir.len < cwd.len && chdir(dir.buf))\n\t\t\tdie(_(\"Cannot change to '%s'\"), dir.buf);\n\t\tprefix = setup_discovered_git_dir(gitdir.buf, &cwd, dir.len,\n\t\t\t\t\t\t  nongit_ok);\n\t\tbreak;\n\tcase GIT_DIR_BARE:\n\t\tif (dir.len < cwd.len && chdir(dir.buf))\n\t\t\tdie(_(\"Cannot change to '%s'\"), dir.buf);\n\t\tprefix = setup_bare_git_dir(&cwd, dir.len, nongit_ok);\n\t\tbreak;\n\tcase GIT_DIR_HIT_CEILING:\n\t\tprefix = setup_nongit(cwd.buf, nongit_ok);\n\t\tbreak;\n\tcase GIT_DIR_HIT_MOUNT_POINT:\n\t\tif (nongit_ok) {\n\t\t\t*nongit_ok = 1;\n\t\t\tstrbuf_release(&cwd);\n\t\t\tstrbuf_release(&dir);\n\t\t\treturn NULL;\n\t\t}\n\t\tdie(_(\"Not a git repository (or any parent up to mount point %s)\\n\"\n\t\t      \"Stopping at filesystem boundary (GIT_DISCOVERY_ACROSS_FILESYSTEM not set).\"),\n\t\t    dir.buf);\n\tdefault:\n\t\tdie(\"BUG: unhandled setup_git_directory_1() result\");\n\t}\n\n\tenv_prefix = getenv(GIT_TOPLEVEL_PREFIX_ENVIRONMENT);\n\tif (env_prefix)\n\t\tprefix = env_prefix;\n\n\tif (prefix)\n\t\tsetenv(GIT_PREFIX_ENVIRONMENT, prefix, 1);\n\telse\n\t\tsetenv(GIT_PREFIX_ENVIRONMENT, \"\", 1);\n\n\tstartup_info->have_repository = !nongit_ok || !*nongit_ok;\n\tstartup_info->prefix = prefix;\n\n\tstrbuf_release(&dir);\n\tstrbuf_release(&gitdir);\n\n\treturn prefix;\n}\n\nint git_config_perm(const char *var, const char *value)\n{\n\tint i;\n\tchar *endptr;\n\n\tif (value == NULL)\n\t\treturn PERM_GROUP;\n\n\tif (!strcmp(value, \"umask\"))\n\t\treturn PERM_UMASK;\n\tif (!strcmp(value, \"group\"))\n\t\treturn PERM_GROUP;\n\tif (!strcmp(value, \"all\") ||\n\t    !strcmp(value, \"world\") ||\n\t    !strcmp(value, \"everybody\"))\n\t\treturn PERM_EVERYBODY;\n\n\t/* Parse octal numbers */\n\ti = strtol(value, &endptr, 8);\n\n\t/* If not an octal number, maybe true/false? */\n\tif (*endptr != 0)\n\t\treturn git_config_bool(var, value) ? PERM_GROUP : PERM_UMASK;\n\n\t/*\n\t * Treat values 0, 1 and 2 as compatibility cases, otherwise it is\n\t * a chmod value to restrict to.\n\t */\n\tswitch (i) {\n\tcase PERM_UMASK:               /* 0 */\n\t\treturn PERM_UMASK;\n\tcase OLD_PERM_GROUP:           /* 1 */\n\t\treturn PERM_GROUP;\n\tcase OLD_PERM_EVERYBODY:       /* 2 */\n\t\treturn PERM_EVERYBODY;\n\t}\n\n\t/* A filemode value was given: 0xxx */\n\n\tif ((i & 0600) != 0600)\n\t\tdie(_(\"Problem with core.sharedRepository filemode value \"\n\t\t    \"(0%.3o).\\nThe owner of files must always have \"\n\t\t    \"read and write permissions.\"), i);\n\n\t/*\n\t * Mask filemode value. Others can not get write permission.\n\t * x flags for directories are handled separately.\n\t */\n\treturn -(i & 0666);\n}\n\nvoid check_repository_format(void)\n{\n\tcheck_repository_format_gently(get_git_dir(), NULL);\n\tstartup_info->have_repository = 1;\n}\n\n/*\n * Returns the \"prefix\", a path to the current working directory\n * relative to the work tree root, or NULL, if the current working\n * directory is not a strict subdirectory of the work tree root. The\n * prefix always ends with a '/' character.\n */\nconst char *setup_git_directory(void)\n{\n\treturn setup_git_directory_gently(NULL);\n}\n\nconst char *resolve_gitdir_gently(const char *suspect, int *return_error_code)\n{\n\tif (is_git_directory(suspect))\n\t\treturn suspect;\n\treturn read_gitfile_gently(suspect, return_error_code);\n}\n\n/* if any standard file descriptor is missing open it to /dev/null */\nvoid sanitize_stdfds(void)\n{\n\tint fd = open(\"/dev/null\", O_RDWR, 0);\n\twhile (fd != -1 && fd < 2)\n\t\tfd = dup(fd);\n\tif (fd == -1)\n\t\tdie_errno(\"open /dev/null or dup failed\");\n\tif (fd > 2)\n\t\tclose(fd);\n}\n\nint daemonize(void)\n{\n#ifdef NO_POSIX_GOODIES\n\terrno = ENOSYS;\n\treturn -1;\n#else\n\tswitch (fork()) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tdie_errno(\"fork failed\");\n\t\tdefault:\n\t\t\texit(0);\n\t}\n\tif (setsid() == -1)\n\t\tdie_errno(\"setsid failed\");\n\tclose(0);\n\tclose(1);\n\tclose(2);\n\tsanitize_stdfds();\n\treturn 0;\n#endif\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "000ffa810e1d24f78989f3a720c32724122ffd47",
  "sha1_ok": true,
  "size": 31446
}
