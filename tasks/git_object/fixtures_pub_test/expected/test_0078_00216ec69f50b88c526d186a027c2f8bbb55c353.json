{
  "content": {
    "base64": "LyoKICogYXBwbHkuYwogKgogKiBDb3B5cmlnaHQgKEMpIExpbnVzIFRvcnZhbGRzLCAyMDA1CiAqCiAqIFRoaXMgYXBwbGllcyBwYXRjaGVzIG9uIHRvcCBvZiBzb21lIChhcmJpdHJhcnkpIHZlcnNpb24gb2YgdGhlIFNDTS4KICoKICogTk9URSEgSXQgZG9lcyBhbGwgaXRzIHdvcmsgaW4gdGhlIGluZGV4IGZpbGUsIGFuZCBvbmx5IGNhcmVzIGFib3V0CiAqIHRoZSBmaWxlcyBpbiB0aGUgd29ya2luZyBkaXJlY3RvcnkgaWYgeW91IHRlbGwgaXQgdG8gIm1lcmdlIiB0aGUKICogcGF0Y2ggYXBwbHkuCiAqCiAqIEV2ZW4gd2hlbiBtZXJnaW5nIGl0IGFsd2F5cyB0YWtlcyB0aGUgc291cmNlIGZyb20gdGhlIGluZGV4LCBhbmQKICogdXNlcyB0aGUgd29ya2luZyB0cmVlIGFzIGEgImJyYW5jaCIgZm9yIGEgMy13YXkgbWVyZ2UuCiAqLwojaW5jbHVkZSA8Y3R5cGUuaD4KCiNpbmNsdWRlICJjYWNoZS5oIgoKLy8gV2UgZGVmYXVsdCB0byB0aGUgbWVyZ2UgYmVoYXZpb3VyLCBzaW5jZSB0aGF0J3Mgd2hhdCBtb3N0IHBlb3BsZSB3b3VsZAovLyBleHBlY3QuCi8vCi8vICAtLWNoZWNrIHR1cm5zIG9uIGNoZWNraW5nIHRoYXQgdGhlIHdvcmtpbmcgdHJlZSBtYXRjaGVzIHRoZQovLyAgICBmaWxlcyB0aGF0IGFyZSBiZWluZyBtb2RpZmllZCwgYnV0IGRvZXNuJ3QgYXBwbHkgdGhlIHBhdGNoCi8vICAtLXN0YXQgZG9lcyBqdXN0IGEgZGlmZnN0YXQsIGFuZCBkb2Vzbid0IGFjdHVhbGx5IGFwcGx5Ci8vICAtLXNob3ctZmlsZXMgc2hvd3MgdGhlIGRpcmVjdG9yeSBjaGFuZ2VzCi8vCnN0YXRpYyBpbnQgbWVyZ2VfcGF0Y2ggPSAxOwpzdGF0aWMgaW50IGNoZWNrX2luZGV4ID0gMDsKc3RhdGljIGludCBkaWZmc3RhdCA9IDA7CnN0YXRpYyBpbnQgY2hlY2sgPSAwOwpzdGF0aWMgaW50IGFwcGx5ID0gMTsKc3RhdGljIGludCBzaG93X2ZpbGVzID0gMDsKc3RhdGljIGNvbnN0IGNoYXIgYXBwbHlfdXNhZ2VbXSA9ICJnaXQtYXBwbHkgWy0tc3RhdF0gWy0tY2hlY2tdIFstLXNob3ctZmlsZXNdIDxwYXRjaD4iOwoKLyoKICogRm9yICJkaWZmLXN0YXQiIGxpa2UgYmVoYXZpb3VyLCB3ZSBrZWVwIHRyYWNrIG9mIHRoZSBiaWdnZXN0IGNoYW5nZQogKiB3ZSd2ZSBzZWVuLCBhbmQgdGhlIGxvbmdlc3QgZmlsZW5hbWUuIFRoYXQgYWxsb3dzIHVzIHRvIGRvIHNpbXBsZQogKiBzY2FsaW5nLgogKi8Kc3RhdGljIGludCBtYXhfY2hhbmdlLCBtYXhfbGVuOwoKLyoKICogVmFyaW91cyAiY3VycmVudCBzdGF0ZSIsIG5vdGFibHkgbGluZSBudW1iZXJzIGFuZCB3aGF0CiAqIGZpbGUgKGFuZCBob3cpIHdlJ3JlIHBhdGNoaW5nIHJpZ2h0IG5vdy4uIFRoZSAiaXNfeHh4eCIKICogdGhpbmdzIGFyZSBmbGFncywgd2hlcmUgLTEgbWVhbnMgImRvbid0IGtub3cgeWV0Ii4KICovCnN0YXRpYyBpbnQgbGluZW5yID0gMTsKCnN0cnVjdCBmcmFnbWVudCB7Cgl1bnNpZ25lZCBsb25nIG9sZHBvcywgb2xkbGluZXM7Cgl1bnNpZ25lZCBsb25nIG5ld3BvcywgbmV3bGluZXM7Cgljb25zdCBjaGFyICpwYXRjaDsKCWludCBzaXplOwoJc3RydWN0IGZyYWdtZW50ICpuZXh0Owp9OwoKc3RydWN0IHBhdGNoIHsKCWNoYXIgKm5ld19uYW1lLCAqb2xkX25hbWUsICpkZWZfbmFtZTsKCXVuc2lnbmVkIGludCBvbGRfbW9kZSwgbmV3X21vZGU7CglpbnQgaXNfcmVuYW1lLCBpc19jb3B5LCBpc19uZXcsIGlzX2RlbGV0ZTsKCWludCBsaW5lc19hZGRlZCwgbGluZXNfZGVsZXRlZDsKCXN0cnVjdCBmcmFnbWVudCAqZnJhZ21lbnRzOwoJY29uc3QgY2hhciAqcmVzdWx0OwoJdW5zaWduZWQgbG9uZyByZXN1bHRzaXplOwoJc3RydWN0IHBhdGNoICpuZXh0Owp9OwoKI2RlZmluZSBDSFVOS1NJWkUgKDgxOTIpCiNkZWZpbmUgU0xPUCAoMTYpCgpzdGF0aWMgdm9pZCAqcmVhZF9wYXRjaF9maWxlKGludCBmZCwgdW5zaWduZWQgbG9uZyAqc2l6ZXApCnsKCXVuc2lnbmVkIGxvbmcgc2l6ZSA9IDAsIGFsbG9jID0gQ0hVTktTSVpFOwoJdm9pZCAqYnVmZmVyID0geG1hbGxvYyhhbGxvYyk7CgoJZm9yICg7OykgewoJCWludCBuciA9IGFsbG9jIC0gc2l6ZTsKCQlpZiAobnIgPCAxMDI0KSB7CgkJCWFsbG9jICs9IENIVU5LU0laRTsKCQkJYnVmZmVyID0geHJlYWxsb2MoYnVmZmVyLCBhbGxvYyk7CgkJCW5yID0gYWxsb2MgLSBzaXplOwoJCX0KCQluciA9IHJlYWQoZmQsIGJ1ZmZlciArIHNpemUsIG5yKTsKCQlpZiAoIW5yKQoJCQlicmVhazsKCQlpZiAobnIgPCAwKSB7CgkJCWlmIChlcnJubyA9PSBFQUdBSU4pCgkJCQljb250aW51ZTsKCQkJZGllKCJnaXQtYXBwbHk6IHJlYWQgcmV0dXJuZWQgJXMiLCBzdHJlcnJvcihlcnJubykpOwoJCX0KCQlzaXplICs9IG5yOwoJfQoJKnNpemVwID0gc2l6ZTsKCgkvKgoJICogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBzb21lIHNsb3AgaW4gdGhlIGJ1ZmZlcgoJICogc28gdGhhdCB3ZSBjYW4gZG8gc3BlY3VsYXRpdmUgIm1lbWNtcCIgZXRjLCBhbmQKCSAqIHNlZSB0byBpdCB0aGF0IGl0IGlzIE5VTC1maWxsZWQuCgkgKi8KCWlmIChhbGxvYyA8IHNpemUgKyBTTE9QKQoJCWJ1ZmZlciA9IHhyZWFsbG9jKGJ1ZmZlciwgc2l6ZSArIFNMT1ApOwoJbWVtc2V0KGJ1ZmZlciArIHNpemUsIDAsIFNMT1ApOwoJcmV0dXJuIGJ1ZmZlcjsKfQoKc3RhdGljIHVuc2lnbmVkIGxvbmcgbGluZWxlbihjb25zdCBjaGFyICpidWZmZXIsIHVuc2lnbmVkIGxvbmcgc2l6ZSkKewoJdW5zaWduZWQgbG9uZyBsZW4gPSAwOwoJd2hpbGUgKHNpemUtLSkgewoJCWxlbisrOwoJCWlmICgqYnVmZmVyKysgPT0gJ1xuJykKCQkJYnJlYWs7Cgl9CglyZXR1cm4gbGVuOwp9CgpzdGF0aWMgaW50IGlzX2Rldl9udWxsKGNvbnN0IGNoYXIgKnN0cikKewoJcmV0dXJuICFtZW1jbXAoIi9kZXYvbnVsbCIsIHN0ciwgOSkgJiYgaXNzcGFjZShzdHJbOV0pOwp9CgojZGVmaW5lIFRFUk1fU1BBQ0UJMQojZGVmaW5lIFRFUk1fVEFCCTIKCnN0YXRpYyBpbnQgbmFtZV90ZXJtaW5hdGUoY29uc3QgY2hhciAqbmFtZSwgaW50IG5hbWVsZW4sIGludCBjLCBpbnQgdGVybWluYXRlKQp7CglpZiAoYyA9PSAnICcgJiYgISh0ZXJtaW5hdGUgJiBURVJNX1NQQUNFKSkKCQlyZXR1cm4gMDsKCWlmIChjID09ICdcdCcgJiYgISh0ZXJtaW5hdGUgJiBURVJNX1RBQikpCgkJcmV0dXJuIDA7CgoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBjaGFyICogZmluZF9uYW1lKGNvbnN0IGNoYXIgKmxpbmUsIGNoYXIgKmRlZiwgaW50IHBfdmFsdWUsIGludCB0ZXJtaW5hdGUpCnsKCWludCBsZW47Cgljb25zdCBjaGFyICpzdGFydCA9IGxpbmU7CgljaGFyICpuYW1lOwoKCWZvciAoOzspIHsKCQljaGFyIGMgPSAqbGluZTsKCgkJaWYgKGlzc3BhY2UoYykpIHsKCQkJaWYgKGMgPT0gJ1xuJykKCQkJCWJyZWFrOwoJCQlpZiAobmFtZV90ZXJtaW5hdGUoc3RhcnQsIGxpbmUtc3RhcnQsIGMsIHRlcm1pbmF0ZSkpCgkJCQlicmVhazsKCQl9CgkJbGluZSsrOwoJCWlmIChjID09ICcvJyAmJiAhLS1wX3ZhbHVlKQoJCQlzdGFydCA9IGxpbmU7Cgl9CglpZiAoIXN0YXJ0KQoJCXJldHVybiBkZWY7CglsZW4gPSBsaW5lIC0gc3RhcnQ7CglpZiAoIWxlbikKCQlyZXR1cm4gZGVmOwoKCS8qCgkgKiBHZW5lcmFsbHkgd2UgcHJlZmVyIHRoZSBzaG9ydGVyIG5hbWUsIGVzcGVjaWFsbHkKCSAqIGlmIHRoZSBvdGhlciBvbmUgaXMganVzdCBhIHZhcmlhdGlvbiBvZiB0aGF0IHdpdGgKCSAqIHNvbWV0aGluZyBlbHNlIHRhY2tlZCBvbiB0byB0aGUgZW5kIChpZSAiZmlsZS5vcmlnIgoJICogb3IgImZpbGV+IikuCgkgKi8KCWlmIChkZWYpIHsKCQlpbnQgZGVmbGVuID0gc3RybGVuKGRlZik7CgkJaWYgKGRlZmxlbiA8IGxlbiAmJiAhc3RybmNtcChzdGFydCwgZGVmLCBkZWZsZW4pKQoJCQlyZXR1cm4gZGVmOwoJfQoKCW5hbWUgPSB4bWFsbG9jKGxlbiArIDEpOwoJbWVtY3B5KG5hbWUsIHN0YXJ0LCBsZW4pOwoJbmFtZVtsZW5dID0gMDsKCWZyZWUoZGVmKTsKCXJldHVybiBuYW1lOwp9CgovKgogKiBHZXQgdGhlIG5hbWUgZXRjIGluZm8gZnJvbSB0aGUgLS0vKysrIGxpbmVzIG9mIGEgdHJhZGl0aW9uYWwgcGF0Y2ggaGVhZGVyCiAqCiAqIE5PVEUhIFRoaXMgaGFyZGNvZGVzICItcDEiIGJlaGF2aW91ciBpbiBmaWxlbmFtZSBkZXRlY3Rpb24uCiAqCiAqIEZJWE1FISBUaGUgZW5kLW9mLWZpbGVuYW1lIGhldXJpc3RpY3MgYXJlIGtpbmQgb2Ygc2NyZXd5LiBGb3IgZXhpc3RpbmcKICogZmlsZXMsIHdlIGNhbiBoYXBwaWx5IGNoZWNrIHRoZSBpbmRleCBmb3IgYSBtYXRjaCwgYnV0IGZvciBjcmVhdGluZyBhCiAqIG5ldyBmaWxlIHdlIHNob3VsZCB0cnkgdG8gbWF0Y2ggd2hhdGV2ZXIgInBhdGNoIiBkb2VzLiBJIGhhdmUgbm8gaWRlYS4KICovCnN0YXRpYyB2b2lkIHBhcnNlX3RyYWRpdGlvbmFsX3BhdGNoKGNvbnN0IGNoYXIgKmZpcnN0LCBjb25zdCBjaGFyICpzZWNvbmQsIHN0cnVjdCBwYXRjaCAqcGF0Y2gpCnsKCWludCBwX3ZhbHVlID0gMTsKCWNoYXIgKm5hbWU7CgoJZmlyc3QgKz0gNDsJLy8gc2tpcCAiLS0tICIKCXNlY29uZCArPSA0OwkvLyBza2lwICIrKysgIgoJaWYgKGlzX2Rldl9udWxsKGZpcnN0KSkgewoJCXBhdGNoLT5pc19uZXcgPSAxOwoJCXBhdGNoLT5pc19kZWxldGUgPSAwOwoJCW5hbWUgPSBmaW5kX25hbWUoc2Vjb25kLCBOVUxMLCBwX3ZhbHVlLCBURVJNX1NQQUNFIHwgVEVSTV9UQUIpOwoJCXBhdGNoLT5uZXdfbmFtZSA9IG5hbWU7Cgl9IGVsc2UgaWYgKGlzX2Rldl9udWxsKHNlY29uZCkpIHsKCQlwYXRjaC0+aXNfbmV3ID0gMDsKCQlwYXRjaC0+aXNfZGVsZXRlID0gMTsKCQluYW1lID0gZmluZF9uYW1lKGZpcnN0LCBOVUxMLCBwX3ZhbHVlLCBURVJNX1NQQUNFIHwgVEVSTV9UQUIpOwoJCXBhdGNoLT5vbGRfbmFtZSA9IG5hbWU7Cgl9IGVsc2UgewoJCW5hbWUgPSBmaW5kX25hbWUoZmlyc3QsIE5VTEwsIHBfdmFsdWUsIFRFUk1fU1BBQ0UgfCBURVJNX1RBQik7CgkJbmFtZSA9IGZpbmRfbmFtZShzZWNvbmQsIG5hbWUsIHBfdmFsdWUsIFRFUk1fU1BBQ0UgfCBURVJNX1RBQik7CgkJcGF0Y2gtPm9sZF9uYW1lID0gcGF0Y2gtPm5ld19uYW1lID0gbmFtZTsKCX0KCWlmICghbmFtZSkKCQlkaWUoInVuYWJsZSB0byBmaW5kIGZpbGVuYW1lIGluIHBhdGNoIGF0IGxpbmUgJWQiLCBsaW5lbnIpOwp9CgpzdGF0aWMgaW50IGdpdGRpZmZfaGRyZW5kKGNvbnN0IGNoYXIgKmxpbmUsIHN0cnVjdCBwYXRjaCAqcGF0Y2gpCnsKCXJldHVybiAtMTsKfQoKLyoKICogV2UncmUgYW5hbCBhYm91dCBkaWZmIGhlYWRlciBjb25zaXN0ZW5jeSwgdG8gbWFrZQogKiBzdXJlIHRoYXQgd2UgZG9uJ3QgZW5kIHVwIGhhdmluZyBzdHJhbmdlIGFtYmlndW91cwogKiBwYXRjaGVzIGZsb2F0aW5nIGFyb3VuZC4KICoKICogQXMgYSByZXN1bHQsIGdpdGRpZmZfe29sZHxuZXd9bmFtZSgpIHdpbGwgY2hlY2sKICogdGhlaXIgbmFtZXMgYWdhaW5zdCBhbnkgcHJldmlvdXMgaW5mb3JtYXRpb24sIGp1c3QKICogdG8gbWFrZSBzdXJlLi4KICovCnN0YXRpYyBjaGFyICpnaXRkaWZmX3ZlcmlmeV9uYW1lKGNvbnN0IGNoYXIgKmxpbmUsIGludCBpc251bGwsIGNoYXIgKm9yaWdfbmFtZSwgY29uc3QgY2hhciAqb2xkbmV3KQp7CglpbnQgbGVuOwoJY29uc3QgY2hhciAqbmFtZTsKCglpZiAoIW9yaWdfbmFtZSAmJiAhaXNudWxsKQoJCXJldHVybiBmaW5kX25hbWUobGluZSwgTlVMTCwgMSwgMCk7CgoJbmFtZSA9ICIvZGV2L251bGwiOwoJbGVuID0gOTsKCWlmIChvcmlnX25hbWUpIHsKCQluYW1lID0gb3JpZ19uYW1lOwoJCWxlbiA9IHN0cmxlbihuYW1lKTsKCQlpZiAoaXNudWxsKQoJCQlkaWUoImdpdC1hcHBseTogYmFkIGdpdC1kaWZmIC0gZXhwZWN0ZWQgL2Rldi9udWxsLCBnb3QgJXMgb24gbGluZSAlZCIsIG5hbWUsIGxpbmVucik7Cgl9CgoJaWYgKCpuYW1lID09ICcvJykKCQlnb3RvIGFic29sdXRlX3BhdGg7CgoJZm9yICg7OykgewoJCWNoYXIgYyA9ICpsaW5lKys7CgkJaWYgKGMgPT0gJ1xuJykKCQkJYnJlYWs7CgkJaWYgKGMgIT0gJy8nKQoJCQljb250aW51ZTsKYWJzb2x1dGVfcGF0aDoKCQlpZiAobWVtY21wKGxpbmUsIG5hbWUsIGxlbikgfHwgbGluZVtsZW5dICE9ICdcbicpCgkJCWJyZWFrOwoJCXJldHVybiBvcmlnX25hbWU7Cgl9CglkaWUoImdpdC1hcHBseTogYmFkIGdpdC1kaWZmIC0gaW5jb25zaXN0ZW50ICVzIGZpbGVuYW1lIG9uIGxpbmUgJWQiLCBvbGRuZXcsIGxpbmVucik7CglyZXR1cm4gTlVMTDsKfQoKc3RhdGljIGludCBnaXRkaWZmX29sZG5hbWUoY29uc3QgY2hhciAqbGluZSwgc3RydWN0IHBhdGNoICpwYXRjaCkKewoJcGF0Y2gtPm9sZF9uYW1lID0gZ2l0ZGlmZl92ZXJpZnlfbmFtZShsaW5lLCBwYXRjaC0+aXNfbmV3LCBwYXRjaC0+b2xkX25hbWUsICJvbGQiKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdpdGRpZmZfbmV3bmFtZShjb25zdCBjaGFyICpsaW5lLCBzdHJ1Y3QgcGF0Y2ggKnBhdGNoKQp7CglwYXRjaC0+bmV3X25hbWUgPSBnaXRkaWZmX3ZlcmlmeV9uYW1lKGxpbmUsIHBhdGNoLT5pc19kZWxldGUsIHBhdGNoLT5uZXdfbmFtZSwgIm5ldyIpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZ2l0ZGlmZl9vbGRtb2RlKGNvbnN0IGNoYXIgKmxpbmUsIHN0cnVjdCBwYXRjaCAqcGF0Y2gpCnsKCXBhdGNoLT5vbGRfbW9kZSA9IHN0cnRvdWwobGluZSwgTlVMTCwgOCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBnaXRkaWZmX25ld21vZGUoY29uc3QgY2hhciAqbGluZSwgc3RydWN0IHBhdGNoICpwYXRjaCkKewoJcGF0Y2gtPm5ld19tb2RlID0gc3RydG91bChsaW5lLCBOVUxMLCA4KTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdpdGRpZmZfZGVsZXRlKGNvbnN0IGNoYXIgKmxpbmUsIHN0cnVjdCBwYXRjaCAqcGF0Y2gpCnsKCXBhdGNoLT5pc19kZWxldGUgPSAxOwoJcGF0Y2gtPm9sZF9uYW1lID0gcGF0Y2gtPmRlZl9uYW1lOwoJcmV0dXJuIGdpdGRpZmZfb2xkbW9kZShsaW5lLCBwYXRjaCk7Cn0KCnN0YXRpYyBpbnQgZ2l0ZGlmZl9uZXdmaWxlKGNvbnN0IGNoYXIgKmxpbmUsIHN0cnVjdCBwYXRjaCAqcGF0Y2gpCnsKCXBhdGNoLT5pc19uZXcgPSAxOwoJcGF0Y2gtPm5ld19uYW1lID0gcGF0Y2gtPmRlZl9uYW1lOwoJcmV0dXJuIGdpdGRpZmZfbmV3bW9kZShsaW5lLCBwYXRjaCk7Cn0KCnN0YXRpYyBpbnQgZ2l0ZGlmZl9jb3B5c3JjKGNvbnN0IGNoYXIgKmxpbmUsIHN0cnVjdCBwYXRjaCAqcGF0Y2gpCnsKCXBhdGNoLT5pc19jb3B5ID0gMTsKCXBhdGNoLT5vbGRfbmFtZSA9IGZpbmRfbmFtZShsaW5lLCBOVUxMLCAwLCAwKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdpdGRpZmZfY29weWRzdChjb25zdCBjaGFyICpsaW5lLCBzdHJ1Y3QgcGF0Y2ggKnBhdGNoKQp7CglwYXRjaC0+aXNfY29weSA9IDE7CglwYXRjaC0+bmV3X25hbWUgPSBmaW5kX25hbWUobGluZSwgTlVMTCwgMCwgMCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBnaXRkaWZmX3JlbmFtZXNyYyhjb25zdCBjaGFyICpsaW5lLCBzdHJ1Y3QgcGF0Y2ggKnBhdGNoKQp7CglwYXRjaC0+aXNfcmVuYW1lID0gMTsKCXBhdGNoLT5vbGRfbmFtZSA9IGZpbmRfbmFtZShsaW5lLCBOVUxMLCAwLCAwKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdpdGRpZmZfcmVuYW1lZHN0KGNvbnN0IGNoYXIgKmxpbmUsIHN0cnVjdCBwYXRjaCAqcGF0Y2gpCnsKCXBhdGNoLT5pc19yZW5hbWUgPSAxOwoJcGF0Y2gtPm5ld19uYW1lID0gZmluZF9uYW1lKGxpbmUsIE5VTEwsIDAsIDApOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZ2l0ZGlmZl9zaW1pbGFyaXR5KGNvbnN0IGNoYXIgKmxpbmUsIHN0cnVjdCBwYXRjaCAqcGF0Y2gpCnsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdpdGRpZmZfZGlzc2ltaWxhcml0eShjb25zdCBjaGFyICpsaW5lLCBzdHJ1Y3QgcGF0Y2ggKnBhdGNoKQp7CglyZXR1cm4gMDsKfQoKLyoKICogVGhpcyBpcyBub3JtYWwgZm9yIGEgZGlmZiB0aGF0IGRvZXNuJ3QgY2hhbmdlIGFueXRoaW5nOiB3ZSdsbCBmYWxsIHRocm91Z2gKICogaW50byB0aGUgbmV4dCBkaWZmLiBUZWxsIHRoZSBwYXJzZXIgdG8gYnJlYWsgb3V0LgogKi8Kc3RhdGljIGludCBnaXRkaWZmX3VucmVjb2duaXplZChjb25zdCBjaGFyICpsaW5lLCBzdHJ1Y3QgcGF0Y2ggKnBhdGNoKQp7CglyZXR1cm4gLTE7Cn0KCnN0YXRpYyBjaGFyICpnaXRfaGVhZGVyX25hbWUoY2hhciAqbGluZSkKewoJaW50IGxlbjsKCWNoYXIgKm5hbWUsICpzZWNvbmQ7CgoJLyoKCSAqIEZpbmQgdGhlIGZpcnN0ICcvJwoJICovCgluYW1lID0gbGluZTsKCWZvciAoOzspIHsKCQljaGFyIGMgPSAqbmFtZSsrOwoJCWlmIChjID09ICdcbicpCgkJCXJldHVybiBOVUxMOwoJCWlmIChjID09ICcvJykKCQkJYnJlYWs7Cgl9CgoJLyoKCSAqIFdlIGRvbid0IGFjY2VwdCBhYnNvbHV0ZSBwYXRocyAoL2Rldi9udWxsKSBhcyBwb3NzaWJseSB2YWxpZAoJICovCglpZiAobmFtZSA9PSBsaW5lKzEpCgkJcmV0dXJuIE5VTEw7CgoJLyoKCSAqIEFjY2VwdCBhIG5hbWUgb25seSBpZiBpdCBzaG93cyB1cCB0d2ljZSwgZXhhY3RseSB0aGUgc2FtZQoJICogZm9ybS4KCSAqLwoJZm9yIChsZW4gPSAwIDsgOyBsZW4rKykgewoJCWNoYXIgYyA9IG5hbWVbbGVuXTsKCgkJc3dpdGNoIChjKSB7CgkJZGVmYXVsdDoKCQkJY29udGludWU7CgkJY2FzZSAnXG4nOgoJCQlicmVhazsKCQljYXNlICdcdCc6IGNhc2UgJyAnOgoJCQlzZWNvbmQgPSBuYW1lK2xlbjsKCQkJZm9yICg7OykgewoJCQkJY2hhciBjID0gKnNlY29uZCsrOwoJCQkJaWYgKGMgPT0gJ1xuJykKCQkJCQlyZXR1cm4gTlVMTDsKCQkJCWlmIChjID09ICcvJykKCQkJCQlicmVhazsKCQkJfQoJCQlpZiAoc2Vjb25kW2xlbl0gPT0gJ1xuJyAmJiAhbWVtY21wKG5hbWUsIHNlY29uZCwgbGVuKSkgewoJCQkJY2hhciAqcmV0ID0geG1hbGxvYyhsZW4gKyAxKTsKCQkJCW1lbWNweShyZXQsIG5hbWUsIGxlbik7CgkJCQlyZXRbbGVuXSA9IDA7CgkJCQlyZXR1cm4gcmV0OwoJCQl9CgkJfQoJfQoJcmV0dXJuIE5VTEw7Cn0KCi8qIFZlcmlmeSB0aGF0IHdlIHJlY29nbml6ZSB0aGUgbGluZXMgZm9sbG93aW5nIGEgZ2l0IGhlYWRlciAqLwpzdGF0aWMgaW50IHBhcnNlX2dpdF9oZWFkZXIoY2hhciAqbGluZSwgaW50IGxlbiwgdW5zaWduZWQgaW50IHNpemUsIHN0cnVjdCBwYXRjaCAqcGF0Y2gpCnsKCXVuc2lnbmVkIGxvbmcgb2Zmc2V0OwoKCS8qIEEgZ2l0IGRpZmYgaGFzIGV4cGxpY2l0IG5ldy9kZWxldGUgaW5mb3JtYXRpb24sIHNvIHdlIGRvbid0IGd1ZXNzICovCglwYXRjaC0+aXNfbmV3ID0gMDsKCXBhdGNoLT5pc19kZWxldGUgPSAwOwoKCS8qCgkgKiBTb21lIHRoaW5ncyBtYXkgbm90IGhhdmUgdGhlIG9sZCBuYW1lIGluIHRoZQoJICogcmVzdCBvZiB0aGUgaGVhZGVycyBhbnl3aGVyZSAocHVyZSBtb2RlIGNoYW5nZXMsCgkgKiBvciByZW1vdmluZyBvciBhZGRpbmcgZW1wdHkgZmlsZXMpLCBzbyB3ZSBnZXQKCSAqIHRoZSBkZWZhdWx0IG5hbWUgZnJvbSB0aGUgaGVhZGVyLgoJICovCglwYXRjaC0+ZGVmX25hbWUgPSBnaXRfaGVhZGVyX25hbWUobGluZSArIHN0cmxlbigiZGlmZiAtLWdpdCAiKSk7CgoJbGluZSArPSBsZW47CglzaXplIC09IGxlbjsKCWxpbmVucisrOwoJZm9yIChvZmZzZXQgPSBsZW4gOyBzaXplID4gMCA7IG9mZnNldCArPSBsZW4sIHNpemUgLT0gbGVuLCBsaW5lICs9IGxlbiwgbGluZW5yKyspIHsKCQlzdGF0aWMgY29uc3Qgc3RydWN0IG9wZW50cnkgewoJCQljb25zdCBjaGFyICpzdHI7CgkJCWludCAoKmZuKShjb25zdCBjaGFyICosIHN0cnVjdCBwYXRjaCAqKTsKCQl9IG9wdGFibGVbXSA9IHsKCQkJeyAiQEAgLSIsIGdpdGRpZmZfaGRyZW5kIH0sCgkJCXsgIi0tLSAiLCBnaXRkaWZmX29sZG5hbWUgfSwKCQkJeyAiKysrICIsIGdpdGRpZmZfbmV3bmFtZSB9LAoJCQl7ICJvbGQgbW9kZSAiLCBnaXRkaWZmX29sZG1vZGUgfSwKCQkJeyAibmV3IG1vZGUgIiwgZ2l0ZGlmZl9uZXdtb2RlIH0sCgkJCXsgImRlbGV0ZWQgZmlsZSBtb2RlICIsIGdpdGRpZmZfZGVsZXRlIH0sCgkJCXsgIm5ldyBmaWxlIG1vZGUgIiwgZ2l0ZGlmZl9uZXdmaWxlIH0sCgkJCXsgImNvcHkgZnJvbSAiLCBnaXRkaWZmX2NvcHlzcmMgfSwKCQkJeyAiY29weSB0byAiLCBnaXRkaWZmX2NvcHlkc3QgfSwKCQkJeyAicmVuYW1lIGZyb20gIiwgZ2l0ZGlmZl9yZW5hbWVzcmMgfSwKCQkJeyAicmVuYW1lIHRvICIsIGdpdGRpZmZfcmVuYW1lZHN0IH0sCgkJCXsgInNpbWlsYXJpdHkgaW5kZXggIiwgZ2l0ZGlmZl9zaW1pbGFyaXR5IH0sCgkJCXsgImRpc3NpbWlsYXJpdHkgaW5kZXggIiwgZ2l0ZGlmZl9kaXNzaW1pbGFyaXR5IH0sCgkJCXsgIiIsIGdpdGRpZmZfdW5yZWNvZ25pemVkIH0sCgkJfTsKCQlpbnQgaTsKCgkJbGVuID0gbGluZWxlbihsaW5lLCBzaXplKTsKCQlpZiAoIWxlbiB8fCBsaW5lW2xlbi0xXSAhPSAnXG4nKQoJCQlicmVhazsKCQlmb3IgKGkgPSAwOyBpIDwgc2l6ZW9mKG9wdGFibGUpIC8gc2l6ZW9mKG9wdGFibGVbMF0pOyBpKyspIHsKCQkJY29uc3Qgc3RydWN0IG9wZW50cnkgKnAgPSBvcHRhYmxlICsgaTsKCQkJaW50IG9wbGVuID0gc3RybGVuKHAtPnN0cik7CgkJCWlmIChsZW4gPCBvcGxlbiB8fCBtZW1jbXAocC0+c3RyLCBsaW5lLCBvcGxlbikpCgkJCQljb250aW51ZTsKCQkJaWYgKHAtPmZuKGxpbmUgKyBvcGxlbiwgcGF0Y2gpIDwgMCkKCQkJCXJldHVybiBvZmZzZXQ7CgkJCWJyZWFrOwoJCX0KCX0KCglyZXR1cm4gb2Zmc2V0Owp9CgpzdGF0aWMgaW50IHBhcnNlX251bShjb25zdCBjaGFyICpsaW5lLCB1bnNpZ25lZCBsb25nICpwKQp7CgljaGFyICpwdHI7CgoJaWYgKCFpc2RpZ2l0KCpsaW5lKSkKCQlyZXR1cm4gMDsKCSpwID0gc3RydG91bChsaW5lLCAmcHRyLCAxMCk7CglyZXR1cm4gcHRyIC0gbGluZTsKfQoKc3RhdGljIGludCBwYXJzZV9yYW5nZShjb25zdCBjaGFyICpsaW5lLCBpbnQgbGVuLCBpbnQgb2Zmc2V0LCBjb25zdCBjaGFyICpleHBlY3QsCgkJCXVuc2lnbmVkIGxvbmcgKnAxLCB1bnNpZ25lZCBsb25nICpwMikKewoJaW50IGRpZ2l0cywgZXg7CgoJaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID49IGxlbikKCQlyZXR1cm4gLTE7CglsaW5lICs9IG9mZnNldDsKCWxlbiAtPSBvZmZzZXQ7CgoJZGlnaXRzID0gcGFyc2VfbnVtKGxpbmUsIHAxKTsKCWlmICghZGlnaXRzKQoJCXJldHVybiAtMTsKCglvZmZzZXQgKz0gZGlnaXRzOwoJbGluZSArPSBkaWdpdHM7CglsZW4gLT0gZGlnaXRzOwoKCSpwMiA9ICpwMTsKCWlmICgqbGluZSA9PSAnLCcpIHsKCQlkaWdpdHMgPSBwYXJzZV9udW0obGluZSsxLCBwMik7CgkJaWYgKCFkaWdpdHMpCgkJCXJldHVybiAtMTsKCgkJb2Zmc2V0ICs9IGRpZ2l0cysxOwoJCWxpbmUgKz0gZGlnaXRzKzE7CgkJbGVuIC09IGRpZ2l0cysxOwoJfQoKCWV4ID0gc3RybGVuKGV4cGVjdCk7CglpZiAoZXggPiBsZW4pCgkJcmV0dXJuIC0xOwoJaWYgKG1lbWNtcChsaW5lLCBleHBlY3QsIGV4KSkKCQlyZXR1cm4gLTE7CgoJcmV0dXJuIG9mZnNldCArIGV4Owp9CgovKgogKiBQYXJzZSBhIHVuaWZpZWQgZGlmZiBmcmFnbWVudCBoZWFkZXIgb2YgdGhlCiAqIGZvcm0gIkBAIC1hLGIgK2MsZCBAQCIKICovCnN0YXRpYyBpbnQgcGFyc2VfZnJhZ21lbnRfaGVhZGVyKGNoYXIgKmxpbmUsIGludCBsZW4sIHN0cnVjdCBmcmFnbWVudCAqZnJhZ21lbnQpCnsKCWludCBvZmZzZXQ7CgoJaWYgKCFsZW4gfHwgbGluZVtsZW4tMV0gIT0gJ1xuJykKCQlyZXR1cm4gLTE7CgoJLyogRmlndXJlIG91dCB0aGUgbnVtYmVyIG9mIGxpbmVzIGluIGEgZnJhZ21lbnQgKi8KCW9mZnNldCA9IHBhcnNlX3JhbmdlKGxpbmUsIGxlbiwgNCwgIiArIiwgJmZyYWdtZW50LT5vbGRwb3MsICZmcmFnbWVudC0+b2xkbGluZXMpOwoJb2Zmc2V0ID0gcGFyc2VfcmFuZ2UobGluZSwgbGVuLCBvZmZzZXQsICIgQEAiLCAmZnJhZ21lbnQtPm5ld3BvcywgJmZyYWdtZW50LT5uZXdsaW5lcyk7CgoJcmV0dXJuIG9mZnNldDsKfQoKc3RhdGljIGludCBmaW5kX2hlYWRlcihjaGFyICpsaW5lLCB1bnNpZ25lZCBsb25nIHNpemUsIGludCAqaGRyc2l6ZSwgc3RydWN0IHBhdGNoICpwYXRjaCkKewoJdW5zaWduZWQgbG9uZyBvZmZzZXQsIGxlbjsKCglwYXRjaC0+aXNfcmVuYW1lID0gcGF0Y2gtPmlzX2NvcHkgPSAwOwoJcGF0Y2gtPmlzX25ldyA9IHBhdGNoLT5pc19kZWxldGUgPSAtMTsKCXBhdGNoLT5vbGRfbW9kZSA9IHBhdGNoLT5uZXdfbW9kZSA9IDA7CglwYXRjaC0+b2xkX25hbWUgPSBwYXRjaC0+bmV3X25hbWUgPSBOVUxMOwoJZm9yIChvZmZzZXQgPSAwOyBzaXplID4gMDsgb2Zmc2V0ICs9IGxlbiwgc2l6ZSAtPSBsZW4sIGxpbmUgKz0gbGVuLCBsaW5lbnIrKykgewoJCXVuc2lnbmVkIGxvbmcgbmV4dGxlbjsKCgkJbGVuID0gbGluZWxlbihsaW5lLCBzaXplKTsKCQlpZiAoIWxlbikKCQkJYnJlYWs7CgoJCS8qIFRlc3RpbmcgdGhpcyBlYXJseSBhbGxvd3MgdXMgdG8gdGFrZSBhIGZldyBzaG9ydGN1dHMuLiAqLwoJCWlmIChsZW4gPCA2KQoJCQljb250aW51ZTsKCgkJLyoKCQkgKiBNYWtlIHN1cmUgd2UgZG9uJ3QgZmluZCBhbnkgdW5jb25uZWN0ZWQgcGF0Y2ggZnJhZ21hbnRzLgoJCSAqIFRoYXQncyBhIHNpZ24gdGhhdCB3ZSBkaWRuJ3QgZmluZCBhIGhlYWRlciwgYW5kIHRoYXQgYQoJCSAqIHBhdGNoIGhhcyBiZWNvbWUgY29ycnVwdGVkL2Jyb2tlbiB1cC4KCQkgKi8KCQlpZiAoIW1lbWNtcCgiQEAgLSIsIGxpbmUsIDQpKSB7CgkJCXN0cnVjdCBmcmFnbWVudCBkdW1teTsKCQkJaWYgKHBhcnNlX2ZyYWdtZW50X2hlYWRlcihsaW5lLCBsZW4sICZkdW1teSkgPCAwKQoJCQkJY29udGludWU7CgkJCWVycm9yKCJwYXRjaCBmcmFnbWVudCB3aXRob3V0IGhlYWRlciBhdCBsaW5lICVkOiAlLipzIiwgbGluZW5yLCBsZW4tMSwgbGluZSk7CgkJfQoKCQlpZiAoc2l6ZSA8IGxlbiArIDYpCgkJCWJyZWFrOwoKCQkvKgoJCSAqIEdpdCBwYXRjaD8gSXQgbWlnaHQgbm90IGhhdmUgYSByZWFsIHBhdGNoLCBqdXN0IGEgcmVuYW1lCgkJICogb3IgbW9kZSBjaGFuZ2UsIHNvIHdlIGhhbmRsZSB0aGF0IHNwZWNpYWxseQoJCSAqLwoJCWlmICghbWVtY21wKCJkaWZmIC0tZ2l0ICIsIGxpbmUsIDExKSkgewoJCQlpbnQgZ2l0X2hkcl9sZW4gPSBwYXJzZV9naXRfaGVhZGVyKGxpbmUsIGxlbiwgc2l6ZSwgcGF0Y2gpOwoJCQlpZiAoZ2l0X2hkcl9sZW4gPCAwKQoJCQkJY29udGludWU7CgkJCWlmICghcGF0Y2gtPm9sZF9uYW1lICYmICFwYXRjaC0+bmV3X25hbWUpCgkJCQlkaWUoImdpdCBkaWZmIGhlYWRlciBsYWNrcyBmaWxlbmFtZSBpbmZvcm1hdGlvbiIpOwoJCQkqaGRyc2l6ZSA9IGdpdF9oZHJfbGVuOwoJCQlyZXR1cm4gb2Zmc2V0OwoJCX0KCgkJLyoqIC0tLSBmb2xsb3dlZCBieSArKysgPyAqLwoJCWlmIChtZW1jbXAoIi0tLSAiLCBsaW5lLCAgNCkgfHwgbWVtY21wKCIrKysgIiwgbGluZSArIGxlbiwgNCkpCgkJCWNvbnRpbnVlOwoKCQkvKgoJCSAqIFdlIG9ubHkgYWNjZXB0IHVuaWZpZWQgcGF0Y2hlcywgc28gd2Ugd2FudCBpdCB0bwoJCSAqIGF0IGxlYXN0IGhhdmUgIkBAIC1hLGIgK2MsZCBAQFxuIiwgd2hpY2ggaXMgMTQgY2hhcnMKCQkgKiBtaW5pbXVtCgkJICovCgkJbmV4dGxlbiA9IGxpbmVsZW4obGluZSArIGxlbiwgc2l6ZSAtIGxlbik7CgkJaWYgKHNpemUgPCBuZXh0bGVuICsgMTQgfHwgbWVtY21wKCJAQCAtIiwgbGluZSArIGxlbiArIG5leHRsZW4sIDQpKQoJCQljb250aW51ZTsKCgkJLyogT2ssIHdlJ2xsIGNvbnNpZGVyIGl0IGEgcGF0Y2ggKi8KCQlwYXJzZV90cmFkaXRpb25hbF9wYXRjaChsaW5lLCBsaW5lK2xlbiwgcGF0Y2gpOwoJCSpoZHJzaXplID0gbGVuICsgbmV4dGxlbjsKCQlsaW5lbnIgKz0gMjsKCQlyZXR1cm4gb2Zmc2V0OwoJfQoJcmV0dXJuIC0xOwp9CgovKgogKiBQYXJzZSBhIHVuaWZpZWQgZGlmZi4gTm90ZSB0aGF0IHRoaXMgcmVhbGx5IG5lZWRzCiAqIHRvIHBhcnNlIGVhY2ggZnJhZ21lbnQgc2VwYXJhdGVseSwgc2luY2UgdGhlIG9ubHkKICogd2F5IHRvIGtub3cgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBhICItLS0iIHRoYXQgaXMKICogcGFydCBvZiBhIHBhdGNoLCBhbmQgYSAiLS0tIiB0aGF0IHN0YXJ0cyB0aGUgbmV4dAogKiBwYXRjaCBpcyB0byBsb29rIGF0IHRoZSBsaW5lIGNvdW50cy4uCiAqLwpzdGF0aWMgaW50IHBhcnNlX2ZyYWdtZW50KGNoYXIgKmxpbmUsIHVuc2lnbmVkIGxvbmcgc2l6ZSwgc3RydWN0IHBhdGNoICpwYXRjaCwgc3RydWN0IGZyYWdtZW50ICpmcmFnbWVudCkKewoJaW50IGFkZGVkLCBkZWxldGVkOwoJaW50IGxlbiA9IGxpbmVsZW4obGluZSwgc2l6ZSksIG9mZnNldDsKCXVuc2lnbmVkIGxvbmcgcG9zWzRdLCBvbGRsaW5lcywgbmV3bGluZXM7CgoJb2Zmc2V0ID0gcGFyc2VfZnJhZ21lbnRfaGVhZGVyKGxpbmUsIGxlbiwgZnJhZ21lbnQpOwoJaWYgKG9mZnNldCA8IDApCgkJcmV0dXJuIC0xOwoJb2xkbGluZXMgPSBmcmFnbWVudC0+b2xkbGluZXM7CgluZXdsaW5lcyA9IGZyYWdtZW50LT5uZXdsaW5lczsKCglpZiAocGF0Y2gtPmlzX25ldyA8IDAgJiYgKHBvc1swXSB8fCBvbGRsaW5lcykpCgkJcGF0Y2gtPmlzX25ldyA9IDA7CglpZiAocGF0Y2gtPmlzX2RlbGV0ZSA8IDAgJiYgKHBvc1sxXSB8fCBuZXdsaW5lcykpCgkJcGF0Y2gtPmlzX2RlbGV0ZSA9IDA7CgoJLyogUGFyc2UgdGhlIHRoaW5nLi4gKi8KCWxpbmUgKz0gbGVuOwoJc2l6ZSAtPSBsZW47CglsaW5lbnIrKzsKCWFkZGVkID0gZGVsZXRlZCA9IDA7Cglmb3IgKG9mZnNldCA9IGxlbjsgc2l6ZSA+IDA7IG9mZnNldCArPSBsZW4sIHNpemUgLT0gbGVuLCBsaW5lICs9IGxlbiwgbGluZW5yKyspIHsKCQlpZiAoIW9sZGxpbmVzICYmICFuZXdsaW5lcykKCQkJYnJlYWs7CgkJbGVuID0gbGluZWxlbihsaW5lLCBzaXplKTsKCQlpZiAoIWxlbiB8fCBsaW5lW2xlbi0xXSAhPSAnXG4nKQoJCQlyZXR1cm4gLTE7CgkJc3dpdGNoICgqbGluZSkgewoJCWRlZmF1bHQ6CgkJCXJldHVybiAtMTsKCQljYXNlICcgJzoKCQkJb2xkbGluZXMtLTsKCQkJbmV3bGluZXMtLTsKCQkJYnJlYWs7CgkJY2FzZSAnLSc6CgkJCWRlbGV0ZWQrKzsKCQkJb2xkbGluZXMtLTsKCQkJYnJlYWs7CgkJY2FzZSAnKyc6CgkJCWFkZGVkKys7CgkJCW5ld2xpbmVzLS07CgkJCWJyZWFrOwoJCS8qIFdlIGFsbG93ICJcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUiICovCgkJY2FzZSAnXFwnOgoJCQlpZiAobGVuIDwgMTIgfHwgbWVtY21wKGxpbmUsICJcXCBObyBuZXdsaW5lIiwgMTIpKQoJCQkJcmV0dXJuIC0xOwoJCQlicmVhazsKCQl9Cgl9CglwYXRjaC0+bGluZXNfYWRkZWQgKz0gYWRkZWQ7CglwYXRjaC0+bGluZXNfZGVsZXRlZCArPSBkZWxldGVkOwoJcmV0dXJuIG9mZnNldDsKfQoKc3RhdGljIGludCBwYXJzZV9zaW5nbGVfcGF0Y2goY2hhciAqbGluZSwgdW5zaWduZWQgbG9uZyBzaXplLCBzdHJ1Y3QgcGF0Y2ggKnBhdGNoKQp7Cgl1bnNpZ25lZCBsb25nIG9mZnNldCA9IDA7CglzdHJ1Y3QgZnJhZ21lbnQgKipmcmFncCA9ICZwYXRjaC0+ZnJhZ21lbnRzOwoKCXdoaWxlIChzaXplID4gNCAmJiAhbWVtY21wKGxpbmUsICJAQCAtIiwgNCkpIHsKCQlzdHJ1Y3QgZnJhZ21lbnQgKmZyYWdtZW50OwoJCWludCBsZW47CgoJCWZyYWdtZW50ID0geG1hbGxvYyhzaXplb2YoKmZyYWdtZW50KSk7CgkJbWVtc2V0KGZyYWdtZW50LCAwLCBzaXplb2YoKmZyYWdtZW50KSk7CgkJbGVuID0gcGFyc2VfZnJhZ21lbnQobGluZSwgc2l6ZSwgcGF0Y2gsIGZyYWdtZW50KTsKCQlpZiAobGVuIDw9IDApCgkJCWRpZSgiY29ycnVwdCBwYXRjaCBhdCBsaW5lICVkIiwgbGluZW5yKTsKCgkJZnJhZ21lbnQtPnBhdGNoID0gbGluZTsKCQlmcmFnbWVudC0+c2l6ZSA9IGxlbjsKCgkJKmZyYWdwID0gZnJhZ21lbnQ7CgkJZnJhZ3AgPSAmZnJhZ21lbnQtPm5leHQ7CgoJCW9mZnNldCArPSBsZW47CgkJbGluZSArPSBsZW47CgkJc2l6ZSAtPSBsZW47Cgl9CglyZXR1cm4gb2Zmc2V0Owp9CgpzdGF0aWMgaW50IHBhcnNlX2NodW5rKGNoYXIgKmJ1ZmZlciwgdW5zaWduZWQgbG9uZyBzaXplLCBzdHJ1Y3QgcGF0Y2ggKnBhdGNoKQp7CglpbnQgaGRyc2l6ZSwgcGF0Y2hzaXplOwoJaW50IG9mZnNldCA9IGZpbmRfaGVhZGVyKGJ1ZmZlciwgc2l6ZSwgJmhkcnNpemUsIHBhdGNoKTsKCglpZiAob2Zmc2V0IDwgMCkKCQlyZXR1cm4gb2Zmc2V0OwoKCXBhdGNoc2l6ZSA9IHBhcnNlX3NpbmdsZV9wYXRjaChidWZmZXIgKyBvZmZzZXQgKyBoZHJzaXplLCBzaXplIC0gb2Zmc2V0IC0gaGRyc2l6ZSwgcGF0Y2gpOwoKCXJldHVybiBvZmZzZXQgKyBoZHJzaXplICsgcGF0Y2hzaXplOwp9Cgpjb25zdCBjaGFyIHBsdXNlc1tdID0gIisrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysiOwpjb25zdCBjaGFyIG1pbnVzZXNbXT0gIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0iOwoKc3RhdGljIHZvaWQgc2hvd19zdGF0cyhzdHJ1Y3QgcGF0Y2ggKnBhdGNoKQp7CgljaGFyICpuYW1lID0gcGF0Y2gtPm9sZF9uYW1lOwoJaW50IGxlbiwgbWF4LCBhZGQsIGRlbCwgdG90YWw7CgoJaWYgKCFuYW1lKQoJCW5hbWUgPSBwYXRjaC0+bmV3X25hbWU7CgoJLyoKCSAqICJzY2FsZSIgdGhlIGZpbGVuYW1lCgkgKi8KCWxlbiA9IHN0cmxlbihuYW1lKTsKCW1heCA9IG1heF9sZW47CglpZiAobWF4ID4gNTApCgkJbWF4ID0gNTA7CglpZiAobGVuID4gbWF4KQoJCW5hbWUgKz0gbGVuIC0gbWF4OwoJbGVuID0gbWF4OwoKCS8qCgkgKiBzY2FsZSB0aGUgYWRkL2RlbGV0ZQoJICovCgltYXggPSBtYXhfY2hhbmdlOwoJaWYgKG1heCArIGxlbiA+IDcwKQoJCW1heCA9IDcwIC0gbGVuOwoKCWFkZCA9IHBhdGNoLT5saW5lc19hZGRlZDsKCWRlbCA9IHBhdGNoLT5saW5lc19kZWxldGVkOwoJdG90YWwgPSBhZGQgKyBkZWw7CgoJdG90YWwgPSAodG90YWwgKiBtYXggKyBtYXhfY2hhbmdlIC8gMikgLyBtYXhfY2hhbmdlOwoJYWRkID0gKGFkZCAqIG1heCArIG1heF9jaGFuZ2UgLyAyKSAvIG1heF9jaGFuZ2U7CglkZWwgPSB0b3RhbCAtIGFkZDsKCXByaW50ZigiICUtKnMgfCU1ZCAlLipzJS4qc1xuIiwKCQlsZW4sIG5hbWUsIHBhdGNoLT5saW5lc19hZGRlZCArIHBhdGNoLT5saW5lc19kZWxldGVkLAoJCWFkZCwgcGx1c2VzLCBkZWwsIG1pbnVzZXMpOwp9CgpzdGF0aWMgaW50IHJlYWRfb2xkX2RhdGEoc3RydWN0IHN0YXQgKnN0LCBjb25zdCBjaGFyICpwYXRoLCB2b2lkICpidWYsIHVuc2lnbmVkIGxvbmcgc2l6ZSkKewoJaW50IGZkOwoJdW5zaWduZWQgbG9uZyBnb3Q7CgoJc3dpdGNoIChzdC0+c3RfbW9kZSAmIFNfSUZNVCkgewoJY2FzZSBTX0lGTE5LOgoJCXJldHVybiByZWFkbGluayhwYXRoLCBidWYsIHNpemUpOwoJY2FzZSBTX0lGUkVHOgoJCWZkID0gb3BlbihwYXRoLCBPX1JET05MWSk7CgkJaWYgKGZkIDwgMCkKCQkJcmV0dXJuIGVycm9yKCJ1bmFibGUgdG8gb3BlbiAlcyIsIHBhdGgpOwoJCWdvdCA9IDA7CgkJZm9yICg7OykgewoJCQlpbnQgcmV0ID0gcmVhZChmZCwgYnVmICsgZ290LCBzaXplIC0gZ290KTsKCQkJaWYgKHJldCA8IDApIHsKCQkJCWlmIChlcnJubyA9PSBFQUdBSU4pCgkJCQkJY29udGludWU7CgkJCQlicmVhazsKCQkJfQoJCQlpZiAoIXJldCkKCQkJCWJyZWFrOwoJCQlnb3QgKz0gcmV0OwoJCX0KCQljbG9zZShmZCk7CgkJcmV0dXJuIGdvdDsKCglkZWZhdWx0OgoJCXJldHVybiAtMTsKCX0KfQoKc3RhdGljIGludCBmaW5kX29mZnNldChjb25zdCBjaGFyICpidWYsIHVuc2lnbmVkIGxvbmcgc2l6ZSwgY29uc3QgY2hhciAqZnJhZ21lbnQsIHVuc2lnbmVkIGxvbmcgZnJhZ3NpemUsIGludCBsaW5lKQp7Cgl1bnNpZ25lZCBsb25nIHN0YXJ0OwoKCWlmIChmcmFnc2l6ZSA+IHNpemUpCgkJcmV0dXJuIC0xOwoKCXN0YXJ0ID0gMDsKCWlmIChsaW5lID4gMSkgewoJCWxpbmUtLTsKCQl1bnNpZ25lZCBsb25nIG9mZnNldCA9IDA7CgkJd2hpbGUgKHN0YXJ0ICsgb2Zmc2V0IDw9IHNpemUpIHsKCQkJaWYgKGJ1ZltvZmZzZXQrK10gPT0gJ1xuJykgewoJCQkJc3RhcnQgPSBvZmZzZXQ7CgkJCQlpZiAoIS0tbGluZSkKCQkJCQlicmVhazsKCQkJfQoJCX0KCX0KCgkvKiBFeGFjdCBsaW5lIG51bWJlcj8gKi8KCWlmICghbWVtY21wKGJ1ZiArIHN0YXJ0LCBmcmFnbWVudCwgZnJhZ3NpemUpKQoJCXJldHVybiBzdGFydDsKCgkvKgoJICogV2Ugc2hvdWxkIHN0YXJ0IHNlYXJjaGluZyBmb3J3YXJkIGFuZCBiYWNrd2FyZC4KCSAqLwoJcmV0dXJuIC0xOwp9CgpzdGF0aWMgaW50IGFwcGx5X29uZV9mcmFnbWVudChjaGFyICpidWYsIHVuc2lnbmVkIGxvbmcgKnNpemVwLCB1bnNpZ25lZCBsb25nICpidWZzaXplcCwgc3RydWN0IGZyYWdtZW50ICpmcmFnKQp7Cgljb25zdCBjaGFyICpwYXRjaCA9IGZyYWctPnBhdGNoOwoJaW50IG9mZnNldCwgc2l6ZSA9IGZyYWctPnNpemU7CgljaGFyICpvbGQgPSB4bWFsbG9jKHNpemUpOwoJY2hhciAqbmV3ID0geG1hbGxvYyhzaXplKTsKCWludCBvbGRzaXplID0gMCwgbmV3c2l6ZSA9IDA7CgoJd2hpbGUgKHNpemUgPiAwKSB7CgkJaW50IGxlbiA9IGxpbmVsZW4ocGF0Y2gsIHNpemUpOwoJCWludCBwbGVuOwoKCQlpZiAoIWxlbikKCQkJYnJlYWs7CgoJCS8qCgkJICogInBsZW4iIGlzIGhvdyBtdWNoIG9mIHRoZSBsaW5lIHdlIHNob3VsZCB1c2UgZm9yCgkJICogdGhlIGFjdHVhbCBwYXRjaCBkYXRhLiBOb3JtYWxseSB3ZSBqdXN0IHJlbW92ZSB0aGUKCQkgKiBmaXJzdCBjaGFyYWN0ZXIgb24gdGhlIGxpbmUsIGJ1dCBpZiB0aGUgbGluZSBpcwoJCSAqIGZvbGxvd2VkIGJ5ICJcIE5vIG5ld2xpbmUiLCB0aGVuIHdlIGFsc28gcmVtb3ZlIHRoZQoJCSAqIGxhc3Qgb25lICh3aGljaCBpcyB0aGUgbmV3bGluZSwgb2YgY291cnNlKS4KCQkgKi8KCQlwbGVuID0gbGVuLTE7CgkJaWYgKGxlbiA+IHNpemUgJiYgcGF0Y2hbbGVuXSA9PSAnXFwnKQoJCQlwbGVuLS07CgkJc3dpdGNoICgqcGF0Y2gpIHsKCQljYXNlICcgJzoKCQljYXNlICctJzoKCQkJbWVtY3B5KG9sZCArIG9sZHNpemUsIHBhdGNoICsgMSwgcGxlbik7CgkJCW9sZHNpemUgKz0gcGxlbjsKCQkJaWYgKCpwYXRjaCA9PSAnLScpCgkJCQlicmVhazsKCQkvKiBGYWxsLXRocm91Z2ggZm9yICcgJyAqLwoJCWNhc2UgJysnOgoJCQltZW1jcHkobmV3ICsgbmV3c2l6ZSwgcGF0Y2ggKyAxLCBwbGVuKTsKCQkJbmV3c2l6ZSArPSBwbGVuOwoJCQlicmVhazsKCQljYXNlICdAJzogY2FzZSAnXFwnOgoJCQkvKiBJZ25vcmUgaXQsIHdlIGFscmVhZHkgaGFuZGxlZCBpdCAqLwoJCQlicmVhazsKCQlkZWZhdWx0OgoJCQlyZXR1cm4gLTE7CgkJfQoJCXBhdGNoICs9IGxlbjsKCQlzaXplIC09IGxlbjsKCX0KCglvZmZzZXQgPSBmaW5kX29mZnNldChidWYsICpzaXplcCwgb2xkLCBvbGRzaXplLCBmcmFnLT5uZXdwb3MpOwoJaWYgKG9mZnNldCA+PSAwKSB7CgkJcHJpbnRmKCJmb3VuZCBhdCBvZmZzZXQgJWRcbiIsIG9mZnNldCk7CgkJb2Zmc2V0ID0gMDsKCX0KCglmcmVlKG9sZCk7CglmcmVlKG5ldyk7CglyZXR1cm4gb2Zmc2V0Owp9CgpzdGF0aWMgaW50IGFwcGx5X2ZyYWdtZW50cyhjaGFyICpidWYsIHVuc2lnbmVkIGxvbmcgKnNpemVwLCB1bnNpZ25lZCBsb25nICpidWZzaXplcCwgc3RydWN0IHBhdGNoICpwYXRjaCkKewoJc3RydWN0IGZyYWdtZW50ICpmcmFnID0gcGF0Y2gtPmZyYWdtZW50czsKCgl3aGlsZSAoZnJhZykgewoJCWlmIChhcHBseV9vbmVfZnJhZ21lbnQoYnVmLCBzaXplcCwgYnVmc2l6ZXAsIGZyYWcpIDwgMCkKCQkJcmV0dXJuIGVycm9yKCJwYXRjaCBmYWlsZWQ6ICVzOiVkIiwgcGF0Y2gtPm9sZF9uYW1lLCBmcmFnLT5vbGRwb3MpOwoJCWZyYWcgPSBmcmFnLT5uZXh0OwoJfQp9CgpzdGF0aWMgaW50IGFwcGx5X2RhdGEoc3RydWN0IHBhdGNoICpwYXRjaCwgc3RydWN0IHN0YXQgKnN0KQp7Cgl1bnNpZ25lZCBsb25nIHNpemUsIGJ1ZnNpemU7Cgl2b2lkICpidWY7CgoJaWYgKCFwYXRjaC0+b2xkX25hbWUgfHwgIXBhdGNoLT5mcmFnbWVudHMpCgkJcmV0dXJuIDA7CglzaXplID0gc3QtPnN0X3NpemU7CglidWZzaXplID0gc2l6ZSArIDE2OwoJYnVmID0geG1hbGxvYyhidWZzaXplKTsKCWlmIChyZWFkX29sZF9kYXRhKHN0LCBwYXRjaC0+b2xkX25hbWUsIGJ1ZiwgYnVmc2l6ZSkgIT0gc2l6ZSkKCQlyZXR1cm4gZXJyb3IoInJlYWQgb2YgJXMgZmFpbGVkIiwgcGF0Y2gtPm9sZF9uYW1lKTsKCWlmIChhcHBseV9mcmFnbWVudHMoYnVmLCAmc2l6ZSwgJmJ1ZnNpemUsIHBhdGNoKSA8IDApCgkJcmV0dXJuIC0xOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgY2hlY2tfcGF0Y2goc3RydWN0IHBhdGNoICpwYXRjaCkKewoJc3RydWN0IHN0YXQgc3Q7Cgljb25zdCBjaGFyICpvbGRfbmFtZSA9IHBhdGNoLT5vbGRfbmFtZTsKCWNvbnN0IGNoYXIgKm5ld19uYW1lID0gcGF0Y2gtPm5ld19uYW1lOwoKCWlmIChvbGRfbmFtZSkgewoJCWludCBjaGFuZ2VkOwoKCQlpZiAobHN0YXQob2xkX25hbWUsICZzdCkgPCAwKQoJCQlyZXR1cm4gZXJyb3IoIiVzOiAlc1xuIiwgc3RyZXJyb3IoZXJybm8pKTsKCQlpZiAoY2hlY2tfaW5kZXgpIHsKCQkJaW50IHBvcyA9IGNhY2hlX25hbWVfcG9zKG9sZF9uYW1lLCBzdHJsZW4ob2xkX25hbWUpKTsKCQkJaWYgKHBvcyA8IDApCgkJCQlyZXR1cm4gZXJyb3IoIiVzOiBkb2VzIG5vdCBleGlzdCBpbiBpbmRleCIsIG9sZF9uYW1lKTsKCQkJY2hhbmdlZCA9IGNlX21hdGNoX3N0YXQoYWN0aXZlX2NhY2hlW3Bvc10sICZzdCk7CgkJCWlmIChjaGFuZ2VkKQoJCQkJcmV0dXJuIGVycm9yKCIlczogZG9lcyBub3QgbWF0Y2ggaW5kZXgiLCBvbGRfbmFtZSk7CgkJfQoJCWlmIChwYXRjaC0+aXNfbmV3IDwgMCkKCQkJcGF0Y2gtPmlzX25ldyA9IDA7CgkJaWYgKCFwYXRjaC0+b2xkX21vZGUpCgkJCXBhdGNoLT5vbGRfbW9kZSA9IHN0LnN0X21vZGU7CgkJaWYgKChzdC5zdF9tb2RlIF4gcGF0Y2gtPm9sZF9tb2RlKSAmIFNfSUZNVCkKCQkJcmV0dXJuIGVycm9yKCIlczogd3JvbmcgdHlwZSIsIG9sZF9uYW1lKTsKCQlpZiAoc3Quc3RfbW9kZSAhPSBwYXRjaC0+b2xkX21vZGUpCgkJCWZwcmludGYoc3RkZXJyLCAid2FybmluZzogJXMgaGFzIHR5cGUgJW8sIGV4cGVjdGVkICVvXG4iLAoJCQkJb2xkX25hbWUsIHN0LnN0X21vZGUsIHBhdGNoLT5vbGRfbW9kZSk7Cgl9CgoJaWYgKG5ld19uYW1lICYmIChwYXRjaC0+aXNfbmV3IHwgcGF0Y2gtPmlzX3JlbmFtZSB8IHBhdGNoLT5pc19jb3B5KSkgewoJCWlmIChjaGVja19pbmRleCAmJiBjYWNoZV9uYW1lX3BvcyhuZXdfbmFtZSwgc3RybGVuKG5ld19uYW1lKSkgPj0gMCkKCQkJcmV0dXJuIGVycm9yKCIlczogYWxyZWFkeSBleGlzdHMgaW4gaW5kZXgiLCBuZXdfbmFtZSk7CgkJaWYgKCFsc3RhdChuZXdfbmFtZSwgJnN0KSkKCQkJcmV0dXJuIGVycm9yKCIlczogYWxyZWFkeSBleGlzdHMgaW4gd29ya2luZyBkaXJlY3RvcnkiLCBuZXdfbmFtZSk7CgkJaWYgKGVycm5vICE9IEVOT0VOVCkKCQkJcmV0dXJuIGVycm9yKCIlczogJXMiLCBuZXdfbmFtZSwgc3RyZXJyb3IoZXJybm8pKTsKCX0KCglpZiAobmV3X25hbWUgJiYgb2xkX25hbWUpIHsKCQlpbnQgc2FtZSA9ICFzdHJjbXAob2xkX25hbWUsIG5ld19uYW1lKTsKCQlpZiAoIXBhdGNoLT5uZXdfbW9kZSkKCQkJcGF0Y2gtPm5ld19tb2RlID0gcGF0Y2gtPm9sZF9tb2RlOwoJCWlmICgocGF0Y2gtPm9sZF9tb2RlIF4gcGF0Y2gtPm5ld19tb2RlKSAmIFNfSUZNVCkKCQkJcmV0dXJuIGVycm9yKCJuZXcgbW9kZSAoJW8pIG9mICVzIGRvZXMgbm90IG1hdGNoIG9sZCBtb2RlICglbyklcyVzIiwKCQkJCXBhdGNoLT5uZXdfbW9kZSwgbmV3X25hbWUsIHBhdGNoLT5vbGRfbW9kZSwKCQkJCXNhbWUgPyAiIiA6ICIgb2YgIiwgc2FtZSA/ICIiIDogb2xkX25hbWUpOwoJfQkKCglpZiAoYXBwbHlfZGF0YShwYXRjaCwgJnN0KSA8IDApCgkJcmV0dXJuIGVycm9yKCIlczogcGF0Y2ggZG9lcyBub3QgYXBwbHkiLCBvbGRfbmFtZSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBjaGVja19wYXRjaF9saXN0KHN0cnVjdCBwYXRjaCAqcGF0Y2gpCnsKCWludCBlcnJvciA9IDA7CgoJZm9yICg7cGF0Y2ggOyBwYXRjaCA9IHBhdGNoLT5uZXh0KQoJCWVycm9yIHw9IGNoZWNrX3BhdGNoKHBhdGNoKTsKCXJldHVybiBlcnJvcjsKfQoKc3RhdGljIHZvaWQgc2hvd19maWxlKGludCBjLCB1bnNpZ25lZCBpbnQgbW9kZSwgY29uc3QgY2hhciAqbmFtZSkKewoJcHJpbnRmKCIlYyAlbyAlc1xuIiwgYywgbW9kZSwgbmFtZSk7Cn0KCnN0YXRpYyB2b2lkIHNob3dfZmlsZV9saXN0KHN0cnVjdCBwYXRjaCAqcGF0Y2gpCnsKCWZvciAoO3BhdGNoIDsgcGF0Y2ggPSBwYXRjaC0+bmV4dCkgewoJCWlmIChwYXRjaC0+aXNfcmVuYW1lKSB7CgkJCXNob3dfZmlsZSgnLScsIHBhdGNoLT5vbGRfbW9kZSwgcGF0Y2gtPm9sZF9uYW1lKTsKCQkJc2hvd19maWxlKCcrJywgcGF0Y2gtPm5ld19tb2RlLCBwYXRjaC0+bmV3X25hbWUpOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKHBhdGNoLT5pc19jb3B5IHx8IHBhdGNoLT5pc19uZXcpIHsKCQkJc2hvd19maWxlKCcrJywgcGF0Y2gtPm5ld19tb2RlLCBwYXRjaC0+bmV3X25hbWUpOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKHBhdGNoLT5pc19kZWxldGUpIHsKCQkJc2hvd19maWxlKCctJywgcGF0Y2gtPm9sZF9tb2RlLCBwYXRjaC0+b2xkX25hbWUpOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKHBhdGNoLT5vbGRfbW9kZSAmJiBwYXRjaC0+bmV3X21vZGUgJiYgcGF0Y2gtPm9sZF9tb2RlICE9IHBhdGNoLT5uZXdfbW9kZSkgewoJCQlwcmludGYoIk0gJW86JW8gJXNcbiIsIHBhdGNoLT5vbGRfbW9kZSwgcGF0Y2gtPm5ld19tb2RlLCBwYXRjaC0+b2xkX25hbWUpOwoJCQljb250aW51ZTsKCQl9CgkJcHJpbnRmKCJNICVvICVzXG4iLCBwYXRjaC0+b2xkX21vZGUsIHBhdGNoLT5vbGRfbmFtZSk7Cgl9Cn0KCnN0YXRpYyB2b2lkIHN0YXRfcGF0Y2hfbGlzdChzdHJ1Y3QgcGF0Y2ggKnBhdGNoKQp7CglpbnQgZmlsZXMsIGFkZHMsIGRlbHM7CgoJZm9yIChmaWxlcyA9IGFkZHMgPSBkZWxzID0gMCA7IHBhdGNoIDsgcGF0Y2ggPSBwYXRjaC0+bmV4dCkgewoJCWZpbGVzKys7CgkJYWRkcyArPSBwYXRjaC0+bGluZXNfYWRkZWQ7CgkJZGVscyArPSBwYXRjaC0+bGluZXNfZGVsZXRlZDsKCQlzaG93X3N0YXRzKHBhdGNoKTsKCX0KCglwcmludGYoIiAlZCBmaWxlcyBjaGFuZ2VkLCAlZCBpbnNlcnRpb25zKCspLCAlZCBkZWxldGlvbnMoLSlcbiIsIGZpbGVzLCBhZGRzLCBkZWxzKTsKfQoKc3RhdGljIHZvaWQgcGF0Y2hfc3RhdHMoc3RydWN0IHBhdGNoICpwYXRjaCkKewoJaW50IGxpbmVzID0gcGF0Y2gtPmxpbmVzX2FkZGVkICsgcGF0Y2gtPmxpbmVzX2RlbGV0ZWQ7CgoJaWYgKGxpbmVzID4gbWF4X2NoYW5nZSkKCQltYXhfY2hhbmdlID0gbGluZXM7CglpZiAocGF0Y2gtPm9sZF9uYW1lKSB7CgkJaW50IGxlbiA9IHN0cmxlbihwYXRjaC0+b2xkX25hbWUpOwoJCWlmIChsZW4gPiBtYXhfbGVuKQoJCQltYXhfbGVuID0gbGVuOwoJfQoJaWYgKHBhdGNoLT5uZXdfbmFtZSkgewoJCWludCBsZW4gPSBzdHJsZW4ocGF0Y2gtPm5ld19uYW1lKTsKCQlpZiAobGVuID4gbWF4X2xlbikKCQkJbWF4X2xlbiA9IGxlbjsKCX0KfQoKc3RhdGljIGludCBhcHBseV9wYXRjaChpbnQgZmQpCnsKCXVuc2lnbmVkIGxvbmcgb2Zmc2V0LCBzaXplOwoJY2hhciAqYnVmZmVyID0gcmVhZF9wYXRjaF9maWxlKGZkLCAmc2l6ZSk7CglzdHJ1Y3QgcGF0Y2ggKmxpc3QgPSBOVUxMLCAqKmxpc3RwID0gJmxpc3Q7CgoJaWYgKCFidWZmZXIpCgkJcmV0dXJuIC0xOwoJb2Zmc2V0ID0gMDsKCXdoaWxlIChzaXplID4gMCkgewoJCXN0cnVjdCBwYXRjaCAqcGF0Y2g7CgkJaW50IG5yOwoKCQlwYXRjaCA9IHhtYWxsb2Moc2l6ZW9mKCpwYXRjaCkpOwoJCW1lbXNldChwYXRjaCwgMCwgc2l6ZW9mKCpwYXRjaCkpOwoJCW5yID0gcGFyc2VfY2h1bmsoYnVmZmVyICsgb2Zmc2V0LCBzaXplLCBwYXRjaCk7CgkJaWYgKG5yIDwgMCkKCQkJYnJlYWs7CgkJcGF0Y2hfc3RhdHMocGF0Y2gpOwoJCSpsaXN0cCA9IHBhdGNoOwoJCWxpc3RwID0gJnBhdGNoLT5uZXh0OwoJCW9mZnNldCArPSBucjsKCQlzaXplIC09IG5yOwoJfQoKCWlmICgoY2hlY2sgfHwgYXBwbHkpICYmIGNoZWNrX3BhdGNoX2xpc3QobGlzdCkgPCAwKQoJCWV4aXQoMSk7CgoJaWYgKHNob3dfZmlsZXMpCgkJc2hvd19maWxlX2xpc3QobGlzdCk7CgoJaWYgKGRpZmZzdGF0KQoJCXN0YXRfcGF0Y2hfbGlzdChsaXN0KTsKCglmcmVlKGJ1ZmZlcik7CglyZXR1cm4gMDsKfQoKaW50IG1haW4oaW50IGFyZ2MsIGNoYXIgKiphcmd2KQp7CglpbnQgaTsKCWludCByZWFkX3N0ZGluID0gMTsKCglpZiAocmVhZF9jYWNoZSgpIDwgMCkKCQlkaWUoInVuYWJsZSB0byByZWFkIGluZGV4IGZpbGUiKTsKCglmb3IgKGkgPSAxOyBpIDwgYXJnYzsgaSsrKSB7CgkJY29uc3QgY2hhciAqYXJnID0gYXJndltpXTsKCQlpbnQgZmQ7CgoJCWlmICghc3RyY21wKGFyZywgIi0iKSkgewoJCQlhcHBseV9wYXRjaCgwKTsKCQkJcmVhZF9zdGRpbiA9IDA7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoIXN0cmNtcChhcmcsICItLW5vLW1lcmdlIikpIHsKCQkJbWVyZ2VfcGF0Y2ggPSAwOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKCFzdHJjbXAoYXJnLCAiLS1zdGF0IikpIHsKCQkJYXBwbHkgPSAwOwoJCQlkaWZmc3RhdCA9IDE7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoIXN0cmNtcChhcmcsICItLWNoZWNrIikpIHsKCQkJYXBwbHkgPSAwOwoJCQljaGVjayA9IDE7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoIXN0cmNtcChhcmcsICItLWluZGV4IikpIHsKCQkJY2hlY2tfaW5kZXggPSAxOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKCFzdHJjbXAoYXJnLCAiLS1zaG93LWZpbGVzIikpIHsKCQkJc2hvd19maWxlcyA9IDE7CgkJCWNvbnRpbnVlOwoJCX0KCQlmZCA9IG9wZW4oYXJnLCBPX1JET05MWSk7CgkJaWYgKGZkIDwgMCkKCQkJdXNhZ2UoYXBwbHlfdXNhZ2UpOwoJCXJlYWRfc3RkaW4gPSAwOwoJCWFwcGx5X3BhdGNoKGZkKTsKCQljbG9zZShmZCk7Cgl9CglpZiAocmVhZF9zdGRpbikKCQlhcHBseV9wYXRjaCgwKTsKCXJldHVybiAwOwp9Cg==",
    "text": "/*\n * apply.c\n *\n * Copyright (C) Linus Torvalds, 2005\n *\n * This applies patches on top of some (arbitrary) version of the SCM.\n *\n * NOTE! It does all its work in the index file, and only cares about\n * the files in the working directory if you tell it to \"merge\" the\n * patch apply.\n *\n * Even when merging it always takes the source from the index, and\n * uses the working tree as a \"branch\" for a 3-way merge.\n */\n#include <ctype.h>\n\n#include \"cache.h\"\n\n// We default to the merge behaviour, since that's what most people would\n// expect.\n//\n//  --check turns on checking that the working tree matches the\n//    files that are being modified, but doesn't apply the patch\n//  --stat does just a diffstat, and doesn't actually apply\n//  --show-files shows the directory changes\n//\nstatic int merge_patch = 1;\nstatic int check_index = 0;\nstatic int diffstat = 0;\nstatic int check = 0;\nstatic int apply = 1;\nstatic int show_files = 0;\nstatic const char apply_usage[] = \"git-apply [--stat] [--check] [--show-files] <patch>\";\n\n/*\n * For \"diff-stat\" like behaviour, we keep track of the biggest change\n * we've seen, and the longest filename. That allows us to do simple\n * scaling.\n */\nstatic int max_change, max_len;\n\n/*\n * Various \"current state\", notably line numbers and what\n * file (and how) we're patching right now.. The \"is_xxxx\"\n * things are flags, where -1 means \"don't know yet\".\n */\nstatic int linenr = 1;\n\nstruct fragment {\n\tunsigned long oldpos, oldlines;\n\tunsigned long newpos, newlines;\n\tconst char *patch;\n\tint size;\n\tstruct fragment *next;\n};\n\nstruct patch {\n\tchar *new_name, *old_name, *def_name;\n\tunsigned int old_mode, new_mode;\n\tint is_rename, is_copy, is_new, is_delete;\n\tint lines_added, lines_deleted;\n\tstruct fragment *fragments;\n\tconst char *result;\n\tunsigned long resultsize;\n\tstruct patch *next;\n};\n\n#define CHUNKSIZE (8192)\n#define SLOP (16)\n\nstatic void *read_patch_file(int fd, unsigned long *sizep)\n{\n\tunsigned long size = 0, alloc = CHUNKSIZE;\n\tvoid *buffer = xmalloc(alloc);\n\n\tfor (;;) {\n\t\tint nr = alloc - size;\n\t\tif (nr < 1024) {\n\t\t\talloc += CHUNKSIZE;\n\t\t\tbuffer = xrealloc(buffer, alloc);\n\t\t\tnr = alloc - size;\n\t\t}\n\t\tnr = read(fd, buffer + size, nr);\n\t\tif (!nr)\n\t\t\tbreak;\n\t\tif (nr < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tdie(\"git-apply: read returned %s\", strerror(errno));\n\t\t}\n\t\tsize += nr;\n\t}\n\t*sizep = size;\n\n\t/*\n\t * Make sure that we have some slop in the buffer\n\t * so that we can do speculative \"memcmp\" etc, and\n\t * see to it that it is NUL-filled.\n\t */\n\tif (alloc < size + SLOP)\n\t\tbuffer = xrealloc(buffer, size + SLOP);\n\tmemset(buffer + size, 0, SLOP);\n\treturn buffer;\n}\n\nstatic unsigned long linelen(const char *buffer, unsigned long size)\n{\n\tunsigned long len = 0;\n\twhile (size--) {\n\t\tlen++;\n\t\tif (*buffer++ == '\\n')\n\t\t\tbreak;\n\t}\n\treturn len;\n}\n\nstatic int is_dev_null(const char *str)\n{\n\treturn !memcmp(\"/dev/null\", str, 9) && isspace(str[9]);\n}\n\n#define TERM_SPACE\t1\n#define TERM_TAB\t2\n\nstatic int name_terminate(const char *name, int namelen, int c, int terminate)\n{\n\tif (c == ' ' && !(terminate & TERM_SPACE))\n\t\treturn 0;\n\tif (c == '\\t' && !(terminate & TERM_TAB))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic char * find_name(const char *line, char *def, int p_value, int terminate)\n{\n\tint len;\n\tconst char *start = line;\n\tchar *name;\n\n\tfor (;;) {\n\t\tchar c = *line;\n\n\t\tif (isspace(c)) {\n\t\t\tif (c == '\\n')\n\t\t\t\tbreak;\n\t\t\tif (name_terminate(start, line-start, c, terminate))\n\t\t\t\tbreak;\n\t\t}\n\t\tline++;\n\t\tif (c == '/' && !--p_value)\n\t\t\tstart = line;\n\t}\n\tif (!start)\n\t\treturn def;\n\tlen = line - start;\n\tif (!len)\n\t\treturn def;\n\n\t/*\n\t * Generally we prefer the shorter name, especially\n\t * if the other one is just a variation of that with\n\t * something else tacked on to the end (ie \"file.orig\"\n\t * or \"file~\").\n\t */\n\tif (def) {\n\t\tint deflen = strlen(def);\n\t\tif (deflen < len && !strncmp(start, def, deflen))\n\t\t\treturn def;\n\t}\n\n\tname = xmalloc(len + 1);\n\tmemcpy(name, start, len);\n\tname[len] = 0;\n\tfree(def);\n\treturn name;\n}\n\n/*\n * Get the name etc info from the --/+++ lines of a traditional patch header\n *\n * NOTE! This hardcodes \"-p1\" behaviour in filename detection.\n *\n * FIXME! The end-of-filename heuristics are kind of screwy. For existing\n * files, we can happily check the index for a match, but for creating a\n * new file we should try to match whatever \"patch\" does. I have no idea.\n */\nstatic void parse_traditional_patch(const char *first, const char *second, struct patch *patch)\n{\n\tint p_value = 1;\n\tchar *name;\n\n\tfirst += 4;\t// skip \"--- \"\n\tsecond += 4;\t// skip \"+++ \"\n\tif (is_dev_null(first)) {\n\t\tpatch->is_new = 1;\n\t\tpatch->is_delete = 0;\n\t\tname = find_name(second, NULL, p_value, TERM_SPACE | TERM_TAB);\n\t\tpatch->new_name = name;\n\t} else if (is_dev_null(second)) {\n\t\tpatch->is_new = 0;\n\t\tpatch->is_delete = 1;\n\t\tname = find_name(first, NULL, p_value, TERM_SPACE | TERM_TAB);\n\t\tpatch->old_name = name;\n\t} else {\n\t\tname = find_name(first, NULL, p_value, TERM_SPACE | TERM_TAB);\n\t\tname = find_name(second, name, p_value, TERM_SPACE | TERM_TAB);\n\t\tpatch->old_name = patch->new_name = name;\n\t}\n\tif (!name)\n\t\tdie(\"unable to find filename in patch at line %d\", linenr);\n}\n\nstatic int gitdiff_hdrend(const char *line, struct patch *patch)\n{\n\treturn -1;\n}\n\n/*\n * We're anal about diff header consistency, to make\n * sure that we don't end up having strange ambiguous\n * patches floating around.\n *\n * As a result, gitdiff_{old|new}name() will check\n * their names against any previous information, just\n * to make sure..\n */\nstatic char *gitdiff_verify_name(const char *line, int isnull, char *orig_name, const char *oldnew)\n{\n\tint len;\n\tconst char *name;\n\n\tif (!orig_name && !isnull)\n\t\treturn find_name(line, NULL, 1, 0);\n\n\tname = \"/dev/null\";\n\tlen = 9;\n\tif (orig_name) {\n\t\tname = orig_name;\n\t\tlen = strlen(name);\n\t\tif (isnull)\n\t\t\tdie(\"git-apply: bad git-diff - expected /dev/null, got %s on line %d\", name, linenr);\n\t}\n\n\tif (*name == '/')\n\t\tgoto absolute_path;\n\n\tfor (;;) {\n\t\tchar c = *line++;\n\t\tif (c == '\\n')\n\t\t\tbreak;\n\t\tif (c != '/')\n\t\t\tcontinue;\nabsolute_path:\n\t\tif (memcmp(line, name, len) || line[len] != '\\n')\n\t\t\tbreak;\n\t\treturn orig_name;\n\t}\n\tdie(\"git-apply: bad git-diff - inconsistent %s filename on line %d\", oldnew, linenr);\n\treturn NULL;\n}\n\nstatic int gitdiff_oldname(const char *line, struct patch *patch)\n{\n\tpatch->old_name = gitdiff_verify_name(line, patch->is_new, patch->old_name, \"old\");\n\treturn 0;\n}\n\nstatic int gitdiff_newname(const char *line, struct patch *patch)\n{\n\tpatch->new_name = gitdiff_verify_name(line, patch->is_delete, patch->new_name, \"new\");\n\treturn 0;\n}\n\nstatic int gitdiff_oldmode(const char *line, struct patch *patch)\n{\n\tpatch->old_mode = strtoul(line, NULL, 8);\n\treturn 0;\n}\n\nstatic int gitdiff_newmode(const char *line, struct patch *patch)\n{\n\tpatch->new_mode = strtoul(line, NULL, 8);\n\treturn 0;\n}\n\nstatic int gitdiff_delete(const char *line, struct patch *patch)\n{\n\tpatch->is_delete = 1;\n\tpatch->old_name = patch->def_name;\n\treturn gitdiff_oldmode(line, patch);\n}\n\nstatic int gitdiff_newfile(const char *line, struct patch *patch)\n{\n\tpatch->is_new = 1;\n\tpatch->new_name = patch->def_name;\n\treturn gitdiff_newmode(line, patch);\n}\n\nstatic int gitdiff_copysrc(const char *line, struct patch *patch)\n{\n\tpatch->is_copy = 1;\n\tpatch->old_name = find_name(line, NULL, 0, 0);\n\treturn 0;\n}\n\nstatic int gitdiff_copydst(const char *line, struct patch *patch)\n{\n\tpatch->is_copy = 1;\n\tpatch->new_name = find_name(line, NULL, 0, 0);\n\treturn 0;\n}\n\nstatic int gitdiff_renamesrc(const char *line, struct patch *patch)\n{\n\tpatch->is_rename = 1;\n\tpatch->old_name = find_name(line, NULL, 0, 0);\n\treturn 0;\n}\n\nstatic int gitdiff_renamedst(const char *line, struct patch *patch)\n{\n\tpatch->is_rename = 1;\n\tpatch->new_name = find_name(line, NULL, 0, 0);\n\treturn 0;\n}\n\nstatic int gitdiff_similarity(const char *line, struct patch *patch)\n{\n\treturn 0;\n}\n\nstatic int gitdiff_dissimilarity(const char *line, struct patch *patch)\n{\n\treturn 0;\n}\n\n/*\n * This is normal for a diff that doesn't change anything: we'll fall through\n * into the next diff. Tell the parser to break out.\n */\nstatic int gitdiff_unrecognized(const char *line, struct patch *patch)\n{\n\treturn -1;\n}\n\nstatic char *git_header_name(char *line)\n{\n\tint len;\n\tchar *name, *second;\n\n\t/*\n\t * Find the first '/'\n\t */\n\tname = line;\n\tfor (;;) {\n\t\tchar c = *name++;\n\t\tif (c == '\\n')\n\t\t\treturn NULL;\n\t\tif (c == '/')\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * We don't accept absolute paths (/dev/null) as possibly valid\n\t */\n\tif (name == line+1)\n\t\treturn NULL;\n\n\t/*\n\t * Accept a name only if it shows up twice, exactly the same\n\t * form.\n\t */\n\tfor (len = 0 ; ; len++) {\n\t\tchar c = name[len];\n\n\t\tswitch (c) {\n\t\tdefault:\n\t\t\tcontinue;\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tcase '\\t': case ' ':\n\t\t\tsecond = name+len;\n\t\t\tfor (;;) {\n\t\t\t\tchar c = *second++;\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (c == '/')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (second[len] == '\\n' && !memcmp(name, second, len)) {\n\t\t\t\tchar *ret = xmalloc(len + 1);\n\t\t\t\tmemcpy(ret, name, len);\n\t\t\t\tret[len] = 0;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/* Verify that we recognize the lines following a git header */\nstatic int parse_git_header(char *line, int len, unsigned int size, struct patch *patch)\n{\n\tunsigned long offset;\n\n\t/* A git diff has explicit new/delete information, so we don't guess */\n\tpatch->is_new = 0;\n\tpatch->is_delete = 0;\n\n\t/*\n\t * Some things may not have the old name in the\n\t * rest of the headers anywhere (pure mode changes,\n\t * or removing or adding empty files), so we get\n\t * the default name from the header.\n\t */\n\tpatch->def_name = git_header_name(line + strlen(\"diff --git \"));\n\n\tline += len;\n\tsize -= len;\n\tlinenr++;\n\tfor (offset = len ; size > 0 ; offset += len, size -= len, line += len, linenr++) {\n\t\tstatic const struct opentry {\n\t\t\tconst char *str;\n\t\t\tint (*fn)(const char *, struct patch *);\n\t\t} optable[] = {\n\t\t\t{ \"@@ -\", gitdiff_hdrend },\n\t\t\t{ \"--- \", gitdiff_oldname },\n\t\t\t{ \"+++ \", gitdiff_newname },\n\t\t\t{ \"old mode \", gitdiff_oldmode },\n\t\t\t{ \"new mode \", gitdiff_newmode },\n\t\t\t{ \"deleted file mode \", gitdiff_delete },\n\t\t\t{ \"new file mode \", gitdiff_newfile },\n\t\t\t{ \"copy from \", gitdiff_copysrc },\n\t\t\t{ \"copy to \", gitdiff_copydst },\n\t\t\t{ \"rename from \", gitdiff_renamesrc },\n\t\t\t{ \"rename to \", gitdiff_renamedst },\n\t\t\t{ \"similarity index \", gitdiff_similarity },\n\t\t\t{ \"dissimilarity index \", gitdiff_dissimilarity },\n\t\t\t{ \"\", gitdiff_unrecognized },\n\t\t};\n\t\tint i;\n\n\t\tlen = linelen(line, size);\n\t\tif (!len || line[len-1] != '\\n')\n\t\t\tbreak;\n\t\tfor (i = 0; i < sizeof(optable) / sizeof(optable[0]); i++) {\n\t\t\tconst struct opentry *p = optable + i;\n\t\t\tint oplen = strlen(p->str);\n\t\t\tif (len < oplen || memcmp(p->str, line, oplen))\n\t\t\t\tcontinue;\n\t\t\tif (p->fn(line + oplen, patch) < 0)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn offset;\n}\n\nstatic int parse_num(const char *line, unsigned long *p)\n{\n\tchar *ptr;\n\n\tif (!isdigit(*line))\n\t\treturn 0;\n\t*p = strtoul(line, &ptr, 10);\n\treturn ptr - line;\n}\n\nstatic int parse_range(const char *line, int len, int offset, const char *expect,\n\t\t\tunsigned long *p1, unsigned long *p2)\n{\n\tint digits, ex;\n\n\tif (offset < 0 || offset >= len)\n\t\treturn -1;\n\tline += offset;\n\tlen -= offset;\n\n\tdigits = parse_num(line, p1);\n\tif (!digits)\n\t\treturn -1;\n\n\toffset += digits;\n\tline += digits;\n\tlen -= digits;\n\n\t*p2 = *p1;\n\tif (*line == ',') {\n\t\tdigits = parse_num(line+1, p2);\n\t\tif (!digits)\n\t\t\treturn -1;\n\n\t\toffset += digits+1;\n\t\tline += digits+1;\n\t\tlen -= digits+1;\n\t}\n\n\tex = strlen(expect);\n\tif (ex > len)\n\t\treturn -1;\n\tif (memcmp(line, expect, ex))\n\t\treturn -1;\n\n\treturn offset + ex;\n}\n\n/*\n * Parse a unified diff fragment header of the\n * form \"@@ -a,b +c,d @@\"\n */\nstatic int parse_fragment_header(char *line, int len, struct fragment *fragment)\n{\n\tint offset;\n\n\tif (!len || line[len-1] != '\\n')\n\t\treturn -1;\n\n\t/* Figure out the number of lines in a fragment */\n\toffset = parse_range(line, len, 4, \" +\", &fragment->oldpos, &fragment->oldlines);\n\toffset = parse_range(line, len, offset, \" @@\", &fragment->newpos, &fragment->newlines);\n\n\treturn offset;\n}\n\nstatic int find_header(char *line, unsigned long size, int *hdrsize, struct patch *patch)\n{\n\tunsigned long offset, len;\n\n\tpatch->is_rename = patch->is_copy = 0;\n\tpatch->is_new = patch->is_delete = -1;\n\tpatch->old_mode = patch->new_mode = 0;\n\tpatch->old_name = patch->new_name = NULL;\n\tfor (offset = 0; size > 0; offset += len, size -= len, line += len, linenr++) {\n\t\tunsigned long nextlen;\n\n\t\tlen = linelen(line, size);\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\t/* Testing this early allows us to take a few shortcuts.. */\n\t\tif (len < 6)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Make sure we don't find any unconnected patch fragmants.\n\t\t * That's a sign that we didn't find a header, and that a\n\t\t * patch has become corrupted/broken up.\n\t\t */\n\t\tif (!memcmp(\"@@ -\", line, 4)) {\n\t\t\tstruct fragment dummy;\n\t\t\tif (parse_fragment_header(line, len, &dummy) < 0)\n\t\t\t\tcontinue;\n\t\t\terror(\"patch fragment without header at line %d: %.*s\", linenr, len-1, line);\n\t\t}\n\n\t\tif (size < len + 6)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Git patch? It might not have a real patch, just a rename\n\t\t * or mode change, so we handle that specially\n\t\t */\n\t\tif (!memcmp(\"diff --git \", line, 11)) {\n\t\t\tint git_hdr_len = parse_git_header(line, len, size, patch);\n\t\t\tif (git_hdr_len < 0)\n\t\t\t\tcontinue;\n\t\t\tif (!patch->old_name && !patch->new_name)\n\t\t\t\tdie(\"git diff header lacks filename information\");\n\t\t\t*hdrsize = git_hdr_len;\n\t\t\treturn offset;\n\t\t}\n\n\t\t/** --- followed by +++ ? */\n\t\tif (memcmp(\"--- \", line,  4) || memcmp(\"+++ \", line + len, 4))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We only accept unified patches, so we want it to\n\t\t * at least have \"@@ -a,b +c,d @@\\n\", which is 14 chars\n\t\t * minimum\n\t\t */\n\t\tnextlen = linelen(line + len, size - len);\n\t\tif (size < nextlen + 14 || memcmp(\"@@ -\", line + len + nextlen, 4))\n\t\t\tcontinue;\n\n\t\t/* Ok, we'll consider it a patch */\n\t\tparse_traditional_patch(line, line+len, patch);\n\t\t*hdrsize = len + nextlen;\n\t\tlinenr += 2;\n\t\treturn offset;\n\t}\n\treturn -1;\n}\n\n/*\n * Parse a unified diff. Note that this really needs\n * to parse each fragment separately, since the only\n * way to know the difference between a \"---\" that is\n * part of a patch, and a \"---\" that starts the next\n * patch is to look at the line counts..\n */\nstatic int parse_fragment(char *line, unsigned long size, struct patch *patch, struct fragment *fragment)\n{\n\tint added, deleted;\n\tint len = linelen(line, size), offset;\n\tunsigned long pos[4], oldlines, newlines;\n\n\toffset = parse_fragment_header(line, len, fragment);\n\tif (offset < 0)\n\t\treturn -1;\n\toldlines = fragment->oldlines;\n\tnewlines = fragment->newlines;\n\n\tif (patch->is_new < 0 && (pos[0] || oldlines))\n\t\tpatch->is_new = 0;\n\tif (patch->is_delete < 0 && (pos[1] || newlines))\n\t\tpatch->is_delete = 0;\n\n\t/* Parse the thing.. */\n\tline += len;\n\tsize -= len;\n\tlinenr++;\n\tadded = deleted = 0;\n\tfor (offset = len; size > 0; offset += len, size -= len, line += len, linenr++) {\n\t\tif (!oldlines && !newlines)\n\t\t\tbreak;\n\t\tlen = linelen(line, size);\n\t\tif (!len || line[len-1] != '\\n')\n\t\t\treturn -1;\n\t\tswitch (*line) {\n\t\tdefault:\n\t\t\treturn -1;\n\t\tcase ' ':\n\t\t\toldlines--;\n\t\t\tnewlines--;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tdeleted++;\n\t\t\toldlines--;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\tadded++;\n\t\t\tnewlines--;\n\t\t\tbreak;\n\t\t/* We allow \"\\ No newline at end of file\" */\n\t\tcase '\\\\':\n\t\t\tif (len < 12 || memcmp(line, \"\\\\ No newline\", 12))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpatch->lines_added += added;\n\tpatch->lines_deleted += deleted;\n\treturn offset;\n}\n\nstatic int parse_single_patch(char *line, unsigned long size, struct patch *patch)\n{\n\tunsigned long offset = 0;\n\tstruct fragment **fragp = &patch->fragments;\n\n\twhile (size > 4 && !memcmp(line, \"@@ -\", 4)) {\n\t\tstruct fragment *fragment;\n\t\tint len;\n\n\t\tfragment = xmalloc(sizeof(*fragment));\n\t\tmemset(fragment, 0, sizeof(*fragment));\n\t\tlen = parse_fragment(line, size, patch, fragment);\n\t\tif (len <= 0)\n\t\t\tdie(\"corrupt patch at line %d\", linenr);\n\n\t\tfragment->patch = line;\n\t\tfragment->size = len;\n\n\t\t*fragp = fragment;\n\t\tfragp = &fragment->next;\n\n\t\toffset += len;\n\t\tline += len;\n\t\tsize -= len;\n\t}\n\treturn offset;\n}\n\nstatic int parse_chunk(char *buffer, unsigned long size, struct patch *patch)\n{\n\tint hdrsize, patchsize;\n\tint offset = find_header(buffer, size, &hdrsize, patch);\n\n\tif (offset < 0)\n\t\treturn offset;\n\n\tpatchsize = parse_single_patch(buffer + offset + hdrsize, size - offset - hdrsize, patch);\n\n\treturn offset + hdrsize + patchsize;\n}\n\nconst char pluses[] = \"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\";\nconst char minuses[]= \"----------------------------------------------------------------------\";\n\nstatic void show_stats(struct patch *patch)\n{\n\tchar *name = patch->old_name;\n\tint len, max, add, del, total;\n\n\tif (!name)\n\t\tname = patch->new_name;\n\n\t/*\n\t * \"scale\" the filename\n\t */\n\tlen = strlen(name);\n\tmax = max_len;\n\tif (max > 50)\n\t\tmax = 50;\n\tif (len > max)\n\t\tname += len - max;\n\tlen = max;\n\n\t/*\n\t * scale the add/delete\n\t */\n\tmax = max_change;\n\tif (max + len > 70)\n\t\tmax = 70 - len;\n\n\tadd = patch->lines_added;\n\tdel = patch->lines_deleted;\n\ttotal = add + del;\n\n\ttotal = (total * max + max_change / 2) / max_change;\n\tadd = (add * max + max_change / 2) / max_change;\n\tdel = total - add;\n\tprintf(\" %-*s |%5d %.*s%.*s\\n\",\n\t\tlen, name, patch->lines_added + patch->lines_deleted,\n\t\tadd, pluses, del, minuses);\n}\n\nstatic int read_old_data(struct stat *st, const char *path, void *buf, unsigned long size)\n{\n\tint fd;\n\tunsigned long got;\n\n\tswitch (st->st_mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\treturn readlink(path, buf, size);\n\tcase S_IFREG:\n\t\tfd = open(path, O_RDONLY);\n\t\tif (fd < 0)\n\t\t\treturn error(\"unable to open %s\", path);\n\t\tgot = 0;\n\t\tfor (;;) {\n\t\t\tint ret = read(fd, buf + got, size - got);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (errno == EAGAIN)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\t\t\tgot += ret;\n\t\t}\n\t\tclose(fd);\n\t\treturn got;\n\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic int find_offset(const char *buf, unsigned long size, const char *fragment, unsigned long fragsize, int line)\n{\n\tunsigned long start;\n\n\tif (fragsize > size)\n\t\treturn -1;\n\n\tstart = 0;\n\tif (line > 1) {\n\t\tline--;\n\t\tunsigned long offset = 0;\n\t\twhile (start + offset <= size) {\n\t\t\tif (buf[offset++] == '\\n') {\n\t\t\t\tstart = offset;\n\t\t\t\tif (!--line)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Exact line number? */\n\tif (!memcmp(buf + start, fragment, fragsize))\n\t\treturn start;\n\n\t/*\n\t * We should start searching forward and backward.\n\t */\n\treturn -1;\n}\n\nstatic int apply_one_fragment(char *buf, unsigned long *sizep, unsigned long *bufsizep, struct fragment *frag)\n{\n\tconst char *patch = frag->patch;\n\tint offset, size = frag->size;\n\tchar *old = xmalloc(size);\n\tchar *new = xmalloc(size);\n\tint oldsize = 0, newsize = 0;\n\n\twhile (size > 0) {\n\t\tint len = linelen(patch, size);\n\t\tint plen;\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * \"plen\" is how much of the line we should use for\n\t\t * the actual patch data. Normally we just remove the\n\t\t * first character on the line, but if the line is\n\t\t * followed by \"\\ No newline\", then we also remove the\n\t\t * last one (which is the newline, of course).\n\t\t */\n\t\tplen = len-1;\n\t\tif (len > size && patch[len] == '\\\\')\n\t\t\tplen--;\n\t\tswitch (*patch) {\n\t\tcase ' ':\n\t\tcase '-':\n\t\t\tmemcpy(old + oldsize, patch + 1, plen);\n\t\t\toldsize += plen;\n\t\t\tif (*patch == '-')\n\t\t\t\tbreak;\n\t\t/* Fall-through for ' ' */\n\t\tcase '+':\n\t\t\tmemcpy(new + newsize, patch + 1, plen);\n\t\t\tnewsize += plen;\n\t\t\tbreak;\n\t\tcase '@': case '\\\\':\n\t\t\t/* Ignore it, we already handled it */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tpatch += len;\n\t\tsize -= len;\n\t}\n\n\toffset = find_offset(buf, *sizep, old, oldsize, frag->newpos);\n\tif (offset >= 0) {\n\t\tprintf(\"found at offset %d\\n\", offset);\n\t\toffset = 0;\n\t}\n\n\tfree(old);\n\tfree(new);\n\treturn offset;\n}\n\nstatic int apply_fragments(char *buf, unsigned long *sizep, unsigned long *bufsizep, struct patch *patch)\n{\n\tstruct fragment *frag = patch->fragments;\n\n\twhile (frag) {\n\t\tif (apply_one_fragment(buf, sizep, bufsizep, frag) < 0)\n\t\t\treturn error(\"patch failed: %s:%d\", patch->old_name, frag->oldpos);\n\t\tfrag = frag->next;\n\t}\n}\n\nstatic int apply_data(struct patch *patch, struct stat *st)\n{\n\tunsigned long size, bufsize;\n\tvoid *buf;\n\n\tif (!patch->old_name || !patch->fragments)\n\t\treturn 0;\n\tsize = st->st_size;\n\tbufsize = size + 16;\n\tbuf = xmalloc(bufsize);\n\tif (read_old_data(st, patch->old_name, buf, bufsize) != size)\n\t\treturn error(\"read of %s failed\", patch->old_name);\n\tif (apply_fragments(buf, &size, &bufsize, patch) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int check_patch(struct patch *patch)\n{\n\tstruct stat st;\n\tconst char *old_name = patch->old_name;\n\tconst char *new_name = patch->new_name;\n\n\tif (old_name) {\n\t\tint changed;\n\n\t\tif (lstat(old_name, &st) < 0)\n\t\t\treturn error(\"%s: %s\\n\", strerror(errno));\n\t\tif (check_index) {\n\t\t\tint pos = cache_name_pos(old_name, strlen(old_name));\n\t\t\tif (pos < 0)\n\t\t\t\treturn error(\"%s: does not exist in index\", old_name);\n\t\t\tchanged = ce_match_stat(active_cache[pos], &st);\n\t\t\tif (changed)\n\t\t\t\treturn error(\"%s: does not match index\", old_name);\n\t\t}\n\t\tif (patch->is_new < 0)\n\t\t\tpatch->is_new = 0;\n\t\tif (!patch->old_mode)\n\t\t\tpatch->old_mode = st.st_mode;\n\t\tif ((st.st_mode ^ patch->old_mode) & S_IFMT)\n\t\t\treturn error(\"%s: wrong type\", old_name);\n\t\tif (st.st_mode != patch->old_mode)\n\t\t\tfprintf(stderr, \"warning: %s has type %o, expected %o\\n\",\n\t\t\t\told_name, st.st_mode, patch->old_mode);\n\t}\n\n\tif (new_name && (patch->is_new | patch->is_rename | patch->is_copy)) {\n\t\tif (check_index && cache_name_pos(new_name, strlen(new_name)) >= 0)\n\t\t\treturn error(\"%s: already exists in index\", new_name);\n\t\tif (!lstat(new_name, &st))\n\t\t\treturn error(\"%s: already exists in working directory\", new_name);\n\t\tif (errno != ENOENT)\n\t\t\treturn error(\"%s: %s\", new_name, strerror(errno));\n\t}\n\n\tif (new_name && old_name) {\n\t\tint same = !strcmp(old_name, new_name);\n\t\tif (!patch->new_mode)\n\t\t\tpatch->new_mode = patch->old_mode;\n\t\tif ((patch->old_mode ^ patch->new_mode) & S_IFMT)\n\t\t\treturn error(\"new mode (%o) of %s does not match old mode (%o)%s%s\",\n\t\t\t\tpatch->new_mode, new_name, patch->old_mode,\n\t\t\t\tsame ? \"\" : \" of \", same ? \"\" : old_name);\n\t}\t\n\n\tif (apply_data(patch, &st) < 0)\n\t\treturn error(\"%s: patch does not apply\", old_name);\n\treturn 0;\n}\n\nstatic int check_patch_list(struct patch *patch)\n{\n\tint error = 0;\n\n\tfor (;patch ; patch = patch->next)\n\t\terror |= check_patch(patch);\n\treturn error;\n}\n\nstatic void show_file(int c, unsigned int mode, const char *name)\n{\n\tprintf(\"%c %o %s\\n\", c, mode, name);\n}\n\nstatic void show_file_list(struct patch *patch)\n{\n\tfor (;patch ; patch = patch->next) {\n\t\tif (patch->is_rename) {\n\t\t\tshow_file('-', patch->old_mode, patch->old_name);\n\t\t\tshow_file('+', patch->new_mode, patch->new_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (patch->is_copy || patch->is_new) {\n\t\t\tshow_file('+', patch->new_mode, patch->new_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (patch->is_delete) {\n\t\t\tshow_file('-', patch->old_mode, patch->old_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (patch->old_mode && patch->new_mode && patch->old_mode != patch->new_mode) {\n\t\t\tprintf(\"M %o:%o %s\\n\", patch->old_mode, patch->new_mode, patch->old_name);\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"M %o %s\\n\", patch->old_mode, patch->old_name);\n\t}\n}\n\nstatic void stat_patch_list(struct patch *patch)\n{\n\tint files, adds, dels;\n\n\tfor (files = adds = dels = 0 ; patch ; patch = patch->next) {\n\t\tfiles++;\n\t\tadds += patch->lines_added;\n\t\tdels += patch->lines_deleted;\n\t\tshow_stats(patch);\n\t}\n\n\tprintf(\" %d files changed, %d insertions(+), %d deletions(-)\\n\", files, adds, dels);\n}\n\nstatic void patch_stats(struct patch *patch)\n{\n\tint lines = patch->lines_added + patch->lines_deleted;\n\n\tif (lines > max_change)\n\t\tmax_change = lines;\n\tif (patch->old_name) {\n\t\tint len = strlen(patch->old_name);\n\t\tif (len > max_len)\n\t\t\tmax_len = len;\n\t}\n\tif (patch->new_name) {\n\t\tint len = strlen(patch->new_name);\n\t\tif (len > max_len)\n\t\t\tmax_len = len;\n\t}\n}\n\nstatic int apply_patch(int fd)\n{\n\tunsigned long offset, size;\n\tchar *buffer = read_patch_file(fd, &size);\n\tstruct patch *list = NULL, **listp = &list;\n\n\tif (!buffer)\n\t\treturn -1;\n\toffset = 0;\n\twhile (size > 0) {\n\t\tstruct patch *patch;\n\t\tint nr;\n\n\t\tpatch = xmalloc(sizeof(*patch));\n\t\tmemset(patch, 0, sizeof(*patch));\n\t\tnr = parse_chunk(buffer + offset, size, patch);\n\t\tif (nr < 0)\n\t\t\tbreak;\n\t\tpatch_stats(patch);\n\t\t*listp = patch;\n\t\tlistp = &patch->next;\n\t\toffset += nr;\n\t\tsize -= nr;\n\t}\n\n\tif ((check || apply) && check_patch_list(list) < 0)\n\t\texit(1);\n\n\tif (show_files)\n\t\tshow_file_list(list);\n\n\tif (diffstat)\n\t\tstat_patch_list(list);\n\n\tfree(buffer);\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tint i;\n\tint read_stdin = 1;\n\n\tif (read_cache() < 0)\n\t\tdie(\"unable to read index file\");\n\n\tfor (i = 1; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\t\tint fd;\n\n\t\tif (!strcmp(arg, \"-\")) {\n\t\t\tapply_patch(0);\n\t\t\tread_stdin = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--no-merge\")) {\n\t\t\tmerge_patch = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--stat\")) {\n\t\t\tapply = 0;\n\t\t\tdiffstat = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--check\")) {\n\t\t\tapply = 0;\n\t\t\tcheck = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--index\")) {\n\t\t\tcheck_index = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--show-files\")) {\n\t\t\tshow_files = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tfd = open(arg, O_RDONLY);\n\t\tif (fd < 0)\n\t\t\tusage(apply_usage);\n\t\tread_stdin = 0;\n\t\tapply_patch(fd);\n\t\tclose(fd);\n\t}\n\tif (read_stdin)\n\t\tapply_patch(0);\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00216ec69f50b88c526d186a027c2f8bbb55c353",
  "sha1_ok": true,
  "size": 25189
}
