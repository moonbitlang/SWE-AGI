{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJ0cmFuc3BvcnQuaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJodHRwLmgiCiNpbmNsdWRlICJwa3QtbGluZS5oIgojaW5jbHVkZSAiZmV0Y2gtcGFjay5oIgojaW5jbHVkZSAid2Fsa2VyLmgiCiNpbmNsdWRlICJidW5kbGUuaCIKCi8qIEdlbmVyaWMgZnVuY3Rpb25zIGZvciB1c2luZyBjb21taXQgd2Fsa2VycyAqLwoKc3RhdGljIGludCBmZXRjaF9vYmpzX3ZpYV93YWxrZXIoc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0LAoJCQkJIGludCBucl9vYmpzLCBzdHJ1Y3QgcmVmICoqdG9fZmV0Y2gpCnsKCWNoYXIgKmRlc3QgPSB4c3RyZHVwKHRyYW5zcG9ydC0+dXJsKTsKCXN0cnVjdCB3YWxrZXIgKndhbGtlciA9IHRyYW5zcG9ydC0+ZGF0YTsKCWNoYXIgKipvYmpzID0geG1hbGxvYyhucl9vYmpzICogc2l6ZW9mKCpvYmpzKSk7CglpbnQgaTsKCgl3YWxrZXItPmdldF9hbGwgPSAxOwoJd2Fsa2VyLT5nZXRfdHJlZSA9IDE7Cgl3YWxrZXItPmdldF9oaXN0b3J5ID0gMTsKCXdhbGtlci0+Z2V0X3ZlcmJvc2VseSA9IHRyYW5zcG9ydC0+dmVyYm9zZTsKCXdhbGtlci0+Z2V0X3JlY292ZXIgPSAwOwoKCWZvciAoaSA9IDA7IGkgPCBucl9vYmpzOyBpKyspCgkJb2Jqc1tpXSA9IHhzdHJkdXAoc2hhMV90b19oZXgodG9fZmV0Y2hbaV0tPm9sZF9zaGExKSk7CgoJaWYgKHdhbGtlcl9mZXRjaCh3YWxrZXIsIG5yX29ianMsIG9ianMsIE5VTEwsIE5VTEwpKQoJCWRpZSgiRmV0Y2ggZmFpbGVkLiIpOwoKCWZvciAoaSA9IDA7IGkgPCBucl9vYmpzOyBpKyspCgkJZnJlZShvYmpzW2ldKTsKCWZyZWUob2Jqcyk7CglmcmVlKGRlc3QpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZGlzY29ubmVjdF93YWxrZXIoc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0KQp7CglzdHJ1Y3Qgd2Fsa2VyICp3YWxrZXIgPSB0cmFuc3BvcnQtPmRhdGE7CglpZiAod2Fsa2VyKQoJCXdhbGtlcl9mcmVlKHdhbGtlcik7CglyZXR1cm4gMDsKfQoKc3RhdGljIGNvbnN0IHN0cnVjdCB0cmFuc3BvcnRfb3BzIHJzeW5jX3RyYW5zcG9ydDsKCnN0YXRpYyBpbnQgY3VybF90cmFuc3BvcnRfcHVzaChzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsIGludCByZWZzcGVjX25yLCBjb25zdCBjaGFyICoqcmVmc3BlYywgaW50IGZsYWdzKSB7Cgljb25zdCBjaGFyICoqYXJndjsKCWludCBhcmdjOwoJaW50IGVycjsKCglhcmd2ID0geG1hbGxvYygocmVmc3BlY19uciArIDExKSAqIHNpemVvZihjaGFyICopKTsKCWFyZ3ZbMF0gPSAiaHR0cC1wdXNoIjsKCWFyZ2MgPSAxOwoJaWYgKGZsYWdzICYgVFJBTlNQT1JUX1BVU0hfQUxMKQoJCWFyZ3ZbYXJnYysrXSA9ICItLWFsbCI7CglpZiAoZmxhZ3MgJiBUUkFOU1BPUlRfUFVTSF9GT1JDRSkKCQlhcmd2W2FyZ2MrK10gPSAiLS1mb3JjZSI7Cglhcmd2W2FyZ2MrK10gPSB0cmFuc3BvcnQtPnVybDsKCXdoaWxlIChyZWZzcGVjX25yLS0pCgkJYXJndlthcmdjKytdID0gKnJlZnNwZWMrKzsKCWFyZ3ZbYXJnY10gPSBOVUxMOwoJZXJyID0gcnVuX2NvbW1hbmRfdl9vcHQoYXJndiwgUlVOX0dJVF9DTUQpOwoJc3dpdGNoIChlcnIpIHsKCWNhc2UgLUVSUl9SVU5fQ09NTUFORF9GT1JLOgoJCWVycm9yKCJ1bmFibGUgdG8gZm9yayBmb3IgJXMiLCBhcmd2WzBdKTsKCWNhc2UgLUVSUl9SVU5fQ09NTUFORF9FWEVDOgoJCWVycm9yKCJ1bmFibGUgdG8gZXhlYyAlcyIsIGFyZ3ZbMF0pOwoJCWJyZWFrOwoJY2FzZSAtRVJSX1JVTl9DT01NQU5EX1dBSVRQSUQ6CgljYXNlIC1FUlJfUlVOX0NPTU1BTkRfV0FJVFBJRF9XUk9OR19QSUQ6CgljYXNlIC1FUlJfUlVOX0NPTU1BTkRfV0FJVFBJRF9TSUdOQUw6CgljYXNlIC1FUlJfUlVOX0NPTU1BTkRfV0FJVFBJRF9OT0VYSVQ6CgkJZXJyb3IoIiVzIGRpZWQgd2l0aCBzdHJhbmdlIGVycm9yIiwgYXJndlswXSk7Cgl9CglyZXR1cm4gISFlcnI7Cn0KCiNpZm5kZWYgTk9fQ1VSTApzdGF0aWMgaW50IG1pc3NpbmdfX3RhcmdldChpbnQgY29kZSwgaW50IHJlc3VsdCkKewoJcmV0dXJuCS8qIGZpbGU6Ly8gVVJMIC0tIGRvIHdlIGV2ZXIgdXNlIG9uZT8/PyAqLwoJCShyZXN1bHQgPT0gQ1VSTEVfRklMRV9DT1VMRE5UX1JFQURfRklMRSkgfHwKCQkvKiBodHRwOi8vIGFuZCBodHRwczovLyBVUkwgKi8KCQkoY29kZSA9PSA0MDQgJiYgcmVzdWx0ID09IENVUkxFX0hUVFBfUkVUVVJORURfRVJST1IpIHx8CgkJLyogZnRwOi8vIFVSTCAqLwoJCShjb2RlID09IDU1MCAmJiByZXN1bHQgPT0gQ1VSTEVfRlRQX0NPVUxETlRfUkVUUl9GSUxFKQoJCTsKfQoKI2RlZmluZSBtaXNzaW5nX3RhcmdldChhKSBtaXNzaW5nX190YXJnZXQoKGEpLT5odHRwX2NvZGUsIChhKS0+Y3VybF9yZXN1bHQpCgpzdGF0aWMgc3RydWN0IHJlZiAqZ2V0X3JlZnNfdmlhX2N1cmwoY29uc3Qgc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0KQp7CglzdHJ1Y3QgYnVmZmVyIGJ1ZmZlcjsKCWNoYXIgKmRhdGEsICpzdGFydCwgKm1pZDsKCWNoYXIgKnJlZl9uYW1lOwoJY2hhciAqcmVmc191cmw7CglpbnQgaSA9IDA7CgoJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3Q7CglzdHJ1Y3Qgc2xvdF9yZXN1bHRzIHJlc3VsdHM7CgoJc3RydWN0IHJlZiAqcmVmcyA9IE5VTEw7CglzdHJ1Y3QgcmVmICpyZWYgPSBOVUxMOwoJc3RydWN0IHJlZiAqbGFzdF9yZWYgPSBOVUxMOwoKCWRhdGEgPSB4bWFsbG9jKDQwOTYpOwoJYnVmZmVyLnNpemUgPSA0MDk2OwoJYnVmZmVyLnBvc24gPSAwOwoJYnVmZmVyLmJ1ZmZlciA9IGRhdGE7CgoJcmVmc191cmwgPSB4bWFsbG9jKHN0cmxlbih0cmFuc3BvcnQtPnVybCkgKyAxMSk7CglzcHJpbnRmKHJlZnNfdXJsLCAiJXMvaW5mby9yZWZzIiwgdHJhbnNwb3J0LT51cmwpOwoKCWh0dHBfaW5pdCgpOwoKCXNsb3QgPSBnZXRfYWN0aXZlX3Nsb3QoKTsKCXNsb3QtPnJlc3VsdHMgPSAmcmVzdWx0czsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9GSUxFLCAmYnVmZmVyKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9XUklURUZVTkNUSU9OLCBmd3JpdGVfYnVmZmVyKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9VUkwsIHJlZnNfdXJsKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9IVFRQSEVBREVSLCBOVUxMKTsKCWlmIChzdGFydF9hY3RpdmVfc2xvdChzbG90KSkgewoJCXJ1bl9hY3RpdmVfc2xvdChzbG90KTsKCQlpZiAocmVzdWx0cy5jdXJsX3Jlc3VsdCAhPSBDVVJMRV9PSykgewoJCQlpZiAobWlzc2luZ190YXJnZXQoJnJlc3VsdHMpKSB7CgkJCQlmcmVlKGJ1ZmZlci5idWZmZXIpOwoJCQkJcmV0dXJuIE5VTEw7CgkJCX0gZWxzZSB7CgkJCQlmcmVlKGJ1ZmZlci5idWZmZXIpOwoJCQkJZXJyb3IoIiVzIiwgY3VybF9lcnJvcnN0cik7CgkJCQlyZXR1cm4gTlVMTDsKCQkJfQoJCX0KCX0gZWxzZSB7CgkJZnJlZShidWZmZXIuYnVmZmVyKTsKCQllcnJvcigiVW5hYmxlIHRvIHN0YXJ0IHJlcXVlc3QiKTsKCQlyZXR1cm4gTlVMTDsKCX0KCglodHRwX2NsZWFudXAoKTsKCglkYXRhID0gYnVmZmVyLmJ1ZmZlcjsKCXN0YXJ0ID0gTlVMTDsKCW1pZCA9IGRhdGE7Cgl3aGlsZSAoaSA8IGJ1ZmZlci5wb3NuKSB7CgkJaWYgKCFzdGFydCkKCQkJc3RhcnQgPSAmZGF0YVtpXTsKCQlpZiAoZGF0YVtpXSA9PSAnXHQnKQoJCQltaWQgPSAmZGF0YVtpXTsKCQlpZiAoZGF0YVtpXSA9PSAnXG4nKSB7CgkJCWRhdGFbaV0gPSAwOwoJCQlyZWZfbmFtZSA9IG1pZCArIDE7CgkJCXJlZiA9IHhtYWxsb2Moc2l6ZW9mKHN0cnVjdCByZWYpICsKCQkJCSAgICAgIHN0cmxlbihyZWZfbmFtZSkgKyAxKTsKCQkJbWVtc2V0KHJlZiwgMCwgc2l6ZW9mKHN0cnVjdCByZWYpKTsKCQkJc3RyY3B5KHJlZi0+bmFtZSwgcmVmX25hbWUpOwoJCQlnZXRfc2hhMV9oZXgoc3RhcnQsIHJlZi0+b2xkX3NoYTEpOwoJCQlpZiAoIXJlZnMpCgkJCQlyZWZzID0gcmVmOwoJCQlpZiAobGFzdF9yZWYpCgkJCQlsYXN0X3JlZi0+bmV4dCA9IHJlZjsKCQkJbGFzdF9yZWYgPSByZWY7CgkJCXN0YXJ0ID0gTlVMTDsKCQl9CgkJaSsrOwoJfQoKCWZyZWUoYnVmZmVyLmJ1ZmZlcik7CgoJcmV0dXJuIHJlZnM7Cn0KCiNlbHNlCgpzdGF0aWMgc3RydWN0IHJlZiAqZ2V0X3JlZnNfdmlhX2N1cmwoY29uc3Qgc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0KQp7CglkaWUoIkNhbm5vdCBmZXRjaCBmcm9tICclcycgd2l0aG91dCBjdXJsIC4uLiIsIHRyYW5zcG9ydC0+dXJsKTsKCXJldHVybiBOVUxMOwp9CgojZW5kaWYKCnN0YXRpYyBjb25zdCBzdHJ1Y3QgdHJhbnNwb3J0X29wcyBjdXJsX3RyYW5zcG9ydCA9IHsKCS8qIHNldF9vcHRpb24gKi8JTlVMTCwKCS8qIGdldF9yZWZzX2xpc3QgKi8JZ2V0X3JlZnNfdmlhX2N1cmwsCgkvKiBmZXRjaCAqLwkJZmV0Y2hfb2Jqc192aWFfd2Fsa2VyLAoJLyogcHVzaCAqLwkJY3VybF90cmFuc3BvcnRfcHVzaCwKCS8qIGRpc2Nvbm5lY3QgKi8JZGlzY29ubmVjdF93YWxrZXIKfTsKCnN0cnVjdCBidW5kbGVfdHJhbnNwb3J0X2RhdGEgewoJaW50IGZkOwoJc3RydWN0IGJ1bmRsZV9oZWFkZXIgaGVhZGVyOwp9OwoKc3RhdGljIHN0cnVjdCByZWYgKmdldF9yZWZzX2Zyb21fYnVuZGxlKGNvbnN0IHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCkKewoJc3RydWN0IGJ1bmRsZV90cmFuc3BvcnRfZGF0YSAqZGF0YSA9IHRyYW5zcG9ydC0+ZGF0YTsKCXN0cnVjdCByZWYgKnJlc3VsdCA9IE5VTEw7CglpbnQgaTsKCglpZiAoZGF0YS0+ZmQgPiAwKQoJCWNsb3NlKGRhdGEtPmZkKTsKCWRhdGEtPmZkID0gcmVhZF9idW5kbGVfaGVhZGVyKHRyYW5zcG9ydC0+dXJsLCAmZGF0YS0+aGVhZGVyKTsKCWlmIChkYXRhLT5mZCA8IDApCgkJZGllICgiQ291bGQgbm90IHJlYWQgYnVuZGxlICclcycuIiwgdHJhbnNwb3J0LT51cmwpOwoJZm9yIChpID0gMDsgaSA8IGRhdGEtPmhlYWRlci5yZWZlcmVuY2VzLm5yOyBpKyspIHsKCQlzdHJ1Y3QgcmVmX2xpc3RfZW50cnkgKmUgPSBkYXRhLT5oZWFkZXIucmVmZXJlbmNlcy5saXN0ICsgaTsKCQlzdHJ1Y3QgcmVmICpyZWYgPSBhbGxvY19yZWYoc3RybGVuKGUtPm5hbWUpKTsKCQloYXNoY3B5KHJlZi0+b2xkX3NoYTEsIGUtPnNoYTEpOwoJCXN0cmNweShyZWYtPm5hbWUsIGUtPm5hbWUpOwoJCXJlZi0+bmV4dCA9IHJlc3VsdDsKCQlyZXN1bHQgPSByZWY7Cgl9CglyZXR1cm4gcmVzdWx0Owp9CgpzdGF0aWMgaW50IGZldGNoX3JlZnNfZnJvbV9idW5kbGUoc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0LAoJCQkgICAgICAgaW50IG5yX2hlYWRzLCBzdHJ1Y3QgcmVmICoqdG9fZmV0Y2gpCnsKCXN0cnVjdCBidW5kbGVfdHJhbnNwb3J0X2RhdGEgKmRhdGEgPSB0cmFuc3BvcnQtPmRhdGE7CglyZXR1cm4gdW5idW5kbGUoJmRhdGEtPmhlYWRlciwgZGF0YS0+ZmQpOwp9CgpzdGF0aWMgaW50IGNsb3NlX2J1bmRsZShzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQpCnsKCXN0cnVjdCBidW5kbGVfdHJhbnNwb3J0X2RhdGEgKmRhdGEgPSB0cmFuc3BvcnQtPmRhdGE7CglpZiAoZGF0YS0+ZmQgPiAwKQoJCWNsb3NlKGRhdGEtPmZkKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgY29uc3Qgc3RydWN0IHRyYW5zcG9ydF9vcHMgYnVuZGxlX3RyYW5zcG9ydCA9IHsKCS8qIHNldF9vcHRpb24gKi8JTlVMTCwKCS8qIGdldF9yZWZzX2xpc3QgKi8JZ2V0X3JlZnNfZnJvbV9idW5kbGUsCgkvKiBmZXRjaCAqLwkJZmV0Y2hfcmVmc19mcm9tX2J1bmRsZSwKCS8qIHB1c2ggKi8JCU5VTEwsCgkvKiBkaXNjb25uZWN0ICovCWNsb3NlX2J1bmRsZQp9OwoKc3RydWN0IGdpdF90cmFuc3BvcnRfZGF0YSB7Cgl1bnNpZ25lZCB0aGluIDogMTsKCXVuc2lnbmVkIGtlZXAgOiAxOwoKCWludCB1bnBhY2tsaW1pdDsKCglpbnQgZGVwdGg7CgoJY29uc3QgY2hhciAqdXBsb2FkcGFjazsKCWNvbnN0IGNoYXIgKnJlY2VpdmVwYWNrOwp9OwoKc3RhdGljIGludCBzZXRfZ2l0X29wdGlvbihzdHJ1Y3QgdHJhbnNwb3J0ICpjb25uZWN0aW9uLAoJCQkgIGNvbnN0IGNoYXIgKm5hbWUsIGNvbnN0IGNoYXIgKnZhbHVlKQp7CglzdHJ1Y3QgZ2l0X3RyYW5zcG9ydF9kYXRhICpkYXRhID0gY29ubmVjdGlvbi0+ZGF0YTsKCWlmICghc3RyY21wKG5hbWUsIFRSQU5TX09QVF9VUExPQURQQUNLKSkgewoJCWRhdGEtPnVwbG9hZHBhY2sgPSB2YWx1ZTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCBUUkFOU19PUFRfUkVDRUlWRVBBQ0spKSB7CgkJZGF0YS0+cmVjZWl2ZXBhY2sgPSB2YWx1ZTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCBUUkFOU19PUFRfVEhJTikpIHsKCQlkYXRhLT50aGluID0gISF2YWx1ZTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCBUUkFOU19PUFRfS0VFUCkpIHsKCQlkYXRhLT5rZWVwID0gISF2YWx1ZTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCBUUkFOU19PUFRfVU5QQUNLTElNSVQpKSB7CgkJZGF0YS0+dW5wYWNrbGltaXQgPSBhdG9pKHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCBUUkFOU19PUFRfREVQVEgpKSB7CgkJaWYgKCF2YWx1ZSkKCQkJZGF0YS0+ZGVwdGggPSAwOwoJCWVsc2UKCQkJZGF0YS0+ZGVwdGggPSBhdG9pKHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCXJldHVybiAxOwp9CgpzdGF0aWMgc3RydWN0IHJlZiAqZ2V0X3JlZnNfdmlhX2Nvbm5lY3QoY29uc3Qgc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0KQp7CglzdHJ1Y3QgZ2l0X3RyYW5zcG9ydF9kYXRhICpkYXRhID0gdHJhbnNwb3J0LT5kYXRhOwoJc3RydWN0IHJlZiAqcmVmczsKCWludCBmZFsyXTsKCXBpZF90IHBpZDsKCWNoYXIgKmRlc3QgPSB4c3RyZHVwKHRyYW5zcG9ydC0+dXJsKTsKCglwaWQgPSBnaXRfY29ubmVjdChmZCwgZGVzdCwgZGF0YS0+dXBsb2FkcGFjaywgMCk7CgoJaWYgKHBpZCA8IDApCgkJZGllKCJGYWlsZWQgdG8gY29ubmVjdCB0byBcIiVzXCIiLCB0cmFuc3BvcnQtPnVybCk7CgoJZ2V0X3JlbW90ZV9oZWFkcyhmZFswXSwgJnJlZnMsIDAsIE5VTEwsIDApOwoJcGFja2V0X2ZsdXNoKGZkWzFdKTsKCglmaW5pc2hfY29ubmVjdChwaWQpOwoKCWZyZWUoZGVzdCk7CgoJcmV0dXJuIHJlZnM7Cn0KCnN0YXRpYyBpbnQgZmV0Y2hfcmVmc192aWFfcGFjayhzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsCgkJCSAgICAgICBpbnQgbnJfaGVhZHMsIHN0cnVjdCByZWYgKip0b19mZXRjaCkKewoJc3RydWN0IGdpdF90cmFuc3BvcnRfZGF0YSAqZGF0YSA9IHRyYW5zcG9ydC0+ZGF0YTsKCWNoYXIgKipoZWFkcyA9IHhtYWxsb2MobnJfaGVhZHMgKiBzaXplb2YoKmhlYWRzKSk7CgljaGFyICoqb3JpZ2ggPSB4bWFsbG9jKG5yX2hlYWRzICogc2l6ZW9mKCpvcmlnaCkpOwoJc3RydWN0IHJlZiAqcmVmczsKCWNoYXIgKmRlc3QgPSB4c3RyZHVwKHRyYW5zcG9ydC0+dXJsKTsKCXN0cnVjdCBmZXRjaF9wYWNrX2FyZ3MgYXJnczsKCWludCBpOwoKCWFyZ3MudXBsb2FkcGFjayA9IGRhdGEtPnVwbG9hZHBhY2s7CglhcmdzLnF1aWV0ID0gMDsKCWFyZ3Mua2VlcF9wYWNrID0gZGF0YS0+a2VlcDsKCWFyZ3MudW5wYWNrbGltaXQgPSBkYXRhLT51bnBhY2tsaW1pdDsKCWFyZ3MudXNlX3RoaW5fcGFjayA9IGRhdGEtPnRoaW47CglhcmdzLmZldGNoX2FsbCA9IDA7CglhcmdzLnZlcmJvc2UgPSB0cmFuc3BvcnQtPnZlcmJvc2U7CglhcmdzLmRlcHRoID0gZGF0YS0+ZGVwdGg7CglhcmdzLm5vX3Byb2dyZXNzID0gMDsKCglzZXR1cF9mZXRjaF9wYWNrKCZhcmdzKTsKCglmb3IgKGkgPSAwOyBpIDwgbnJfaGVhZHM7IGkrKykKCQlvcmlnaFtpXSA9IGhlYWRzW2ldID0geHN0cmR1cCh0b19mZXRjaFtpXS0+bmFtZSk7CglyZWZzID0gZmV0Y2hfcGFjayhkZXN0LCBucl9oZWFkcywgaGVhZHMsICZ0cmFuc3BvcnQtPnBhY2tfbG9ja2ZpbGUpOwoKCWZvciAoaSA9IDA7IGkgPCBucl9oZWFkczsgaSsrKQoJCWZyZWUob3JpZ2hbaV0pOwoJZnJlZShvcmlnaCk7CglmcmVlKGhlYWRzKTsKCWZyZWVfcmVmcyhyZWZzKTsKCWZyZWUoZGVzdCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBnaXRfdHJhbnNwb3J0X3B1c2goc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0LCBpbnQgcmVmc3BlY19uciwgY29uc3QgY2hhciAqKnJlZnNwZWMsIGludCBmbGFncykgewoJc3RydWN0IGdpdF90cmFuc3BvcnRfZGF0YSAqZGF0YSA9IHRyYW5zcG9ydC0+ZGF0YTsKCWNvbnN0IGNoYXIgKiphcmd2OwoJY2hhciAqcmVtOwoJaW50IGFyZ2M7CglpbnQgZXJyOwoKCWFyZ3YgPSB4bWFsbG9jKChyZWZzcGVjX25yICsgMTEpICogc2l6ZW9mKGNoYXIgKikpOwoJYXJndlswXSA9ICJzZW5kLXBhY2siOwoJYXJnYyA9IDE7CglpZiAoZmxhZ3MgJiBUUkFOU1BPUlRfUFVTSF9BTEwpCgkJYXJndlthcmdjKytdID0gIi0tYWxsIjsKCWlmIChmbGFncyAmIFRSQU5TUE9SVF9QVVNIX0ZPUkNFKQoJCWFyZ3ZbYXJnYysrXSA9ICItLWZvcmNlIjsKCWlmIChkYXRhLT5yZWNlaXZlcGFjaykgewoJCWNoYXIgKnJwID0geG1hbGxvYyhzdHJsZW4oZGF0YS0+cmVjZWl2ZXBhY2spICsgMTYpOwoJCXNwcmludGYocnAsICItLXJlY2VpdmUtcGFjaz0lcyIsIGRhdGEtPnJlY2VpdmVwYWNrKTsKCQlhcmd2W2FyZ2MrK10gPSBycDsKCX0KCWlmIChkYXRhLT50aGluKQoJCWFyZ3ZbYXJnYysrXSA9ICItLXRoaW4iOwoJcmVtID0geG1hbGxvYyhzdHJsZW4odHJhbnNwb3J0LT5yZW1vdGUtPm5hbWUpICsgMTApOwoJc3ByaW50ZihyZW0sICItLXJlbW90ZT0lcyIsIHRyYW5zcG9ydC0+cmVtb3RlLT5uYW1lKTsKCWFyZ3ZbYXJnYysrXSA9IHJlbTsKCWFyZ3ZbYXJnYysrXSA9IHRyYW5zcG9ydC0+dXJsOwoJd2hpbGUgKHJlZnNwZWNfbnItLSkKCQlhcmd2W2FyZ2MrK10gPSAqcmVmc3BlYysrOwoJYXJndlthcmdjXSA9IE5VTEw7CgllcnIgPSBydW5fY29tbWFuZF92X29wdChhcmd2LCBSVU5fR0lUX0NNRCk7Cglzd2l0Y2ggKGVycikgewoJY2FzZSAtRVJSX1JVTl9DT01NQU5EX0ZPUks6CgkJZXJyb3IoInVuYWJsZSB0byBmb3JrIGZvciAlcyIsIGFyZ3ZbMF0pOwoJY2FzZSAtRVJSX1JVTl9DT01NQU5EX0VYRUM6CgkJZXJyb3IoInVuYWJsZSB0byBleGVjICVzIiwgYXJndlswXSk7CgkJYnJlYWs7CgljYXNlIC1FUlJfUlVOX0NPTU1BTkRfV0FJVFBJRDoKCWNhc2UgLUVSUl9SVU5fQ09NTUFORF9XQUlUUElEX1dST05HX1BJRDoKCWNhc2UgLUVSUl9SVU5fQ09NTUFORF9XQUlUUElEX1NJR05BTDoKCWNhc2UgLUVSUl9SVU5fQ09NTUFORF9XQUlUUElEX05PRVhJVDoKCQllcnJvcigiJXMgZGllZCB3aXRoIHN0cmFuZ2UgZXJyb3IiLCBhcmd2WzBdKTsKCX0KCXJldHVybiAhIWVycjsKfQoKc3RhdGljIGNvbnN0IHN0cnVjdCB0cmFuc3BvcnRfb3BzIGdpdF90cmFuc3BvcnQgPSB7CgkvKiBzZXRfb3B0aW9uICovCXNldF9naXRfb3B0aW9uLAoJLyogZ2V0X3JlZnNfbGlzdCAqLwlnZXRfcmVmc192aWFfY29ubmVjdCwKCS8qIGZldGNoICovCQlmZXRjaF9yZWZzX3ZpYV9wYWNrLAoJLyogcHVzaCAqLwkJZ2l0X3RyYW5zcG9ydF9wdXNoCn07CgpzdGF0aWMgaW50IGlzX2xvY2FsKGNvbnN0IGNoYXIgKnVybCkKewoJY29uc3QgY2hhciAqY29sb24gPSBzdHJjaHIodXJsLCAnOicpOwoJY29uc3QgY2hhciAqc2xhc2ggPSBzdHJjaHIodXJsLCAnLycpOwoJcmV0dXJuICFjb2xvbiB8fCAoc2xhc2ggJiYgc2xhc2ggPCBjb2xvbik7Cn0KCnN0YXRpYyBpbnQgaXNfZmlsZShjb25zdCBjaGFyICp1cmwpCnsKCXN0cnVjdCBzdGF0IGJ1ZjsKCWlmIChzdGF0KHVybCwgJmJ1ZikpCgkJcmV0dXJuIDA7CglyZXR1cm4gU19JU1JFRyhidWYuc3RfbW9kZSk7Cn0KCnN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydF9nZXQoc3RydWN0IHJlbW90ZSAqcmVtb3RlLCBjb25zdCBjaGFyICp1cmwsCgkJCQlpbnQgZmV0Y2gpCnsKCXN0cnVjdCB0cmFuc3BvcnQgKnJldCA9IE5VTEw7CglpZiAoIXByZWZpeGNtcCh1cmwsICJyc3luYzovLyIpKSB7CgkJcmV0ID0geG1hbGxvYyhzaXplb2YoKnJldCkpOwoJCXJldC0+ZGF0YSA9IE5VTEw7CgkJcmV0LT5vcHMgPSAmcnN5bmNfdHJhbnNwb3J0OwoJfSBlbHNlIGlmICghcHJlZml4Y21wKHVybCwgImh0dHA6Ly8iKSB8fCAhcHJlZml4Y21wKHVybCwgImh0dHBzOi8vIikgfHwKCQkgICAhcHJlZml4Y21wKHVybCwgImZ0cDovLyIpKSB7CgkJcmV0ID0geG1hbGxvYyhzaXplb2YoKnJldCkpOwoJCXJldC0+b3BzID0gJmN1cmxfdHJhbnNwb3J0OwoJCWlmIChmZXRjaCkKCQkJcmV0LT5kYXRhID0gZ2V0X2h0dHBfd2Fsa2VyKHVybCk7CgkJZWxzZQoJCQlyZXQtPmRhdGEgPSBOVUxMOwoJfSBlbHNlIGlmIChpc19sb2NhbCh1cmwpICYmIGlzX2ZpbGUodXJsKSkgewoJCXN0cnVjdCBidW5kbGVfdHJhbnNwb3J0X2RhdGEgKmRhdGEgPSB4Y2FsbG9jKDEsIHNpemVvZigqZGF0YSkpOwoJCXJldCA9IHhtYWxsb2Moc2l6ZW9mKCpyZXQpKTsKCQlyZXQtPmRhdGEgPSBkYXRhOwoJCXJldC0+b3BzID0gJmJ1bmRsZV90cmFuc3BvcnQ7Cgl9IGVsc2UgewoJCXN0cnVjdCBnaXRfdHJhbnNwb3J0X2RhdGEgKmRhdGEgPSB4Y2FsbG9jKDEsIHNpemVvZigqZGF0YSkpOwoJCXJldCA9IHhjYWxsb2MoMSwgc2l6ZW9mKCpyZXQpKTsKCQlyZXQtPmRhdGEgPSBkYXRhOwoJCWRhdGEtPnRoaW4gPSAxOwoJCWRhdGEtPnVwbG9hZHBhY2sgPSAiZ2l0LXVwbG9hZC1wYWNrIjsKCQlpZiAocmVtb3RlICYmIHJlbW90ZS0+dXBsb2FkcGFjaykKCQkJZGF0YS0+dXBsb2FkcGFjayA9IHJlbW90ZS0+dXBsb2FkcGFjazsKCQlkYXRhLT5yZWNlaXZlcGFjayA9ICJnaXQtcmVjZWl2ZS1wYWNrIjsKCQlpZiAocmVtb3RlICYmIHJlbW90ZS0+cmVjZWl2ZXBhY2spCgkJCWRhdGEtPnJlY2VpdmVwYWNrID0gcmVtb3RlLT5yZWNlaXZlcGFjazsKCQlkYXRhLT51bnBhY2tsaW1pdCA9IC0xOwoJCXJldC0+b3BzID0gJmdpdF90cmFuc3BvcnQ7Cgl9CglpZiAocmV0KSB7CgkJcmV0LT5yZW1vdGUgPSByZW1vdGU7CgkJcmV0LT51cmwgPSB1cmw7CgkJcmV0LT5yZW1vdGVfcmVmcyA9IE5VTEw7CgkJcmV0LT5mZXRjaCA9ICEhZmV0Y2g7CgkJcmV0LT5wYWNrX2xvY2tmaWxlID0gTlVMTDsKCX0KCXJldHVybiByZXQ7Cn0KCmludCB0cmFuc3BvcnRfc2V0X29wdGlvbihzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsCgkJCSBjb25zdCBjaGFyICpuYW1lLCBjb25zdCBjaGFyICp2YWx1ZSkKewoJaW50IHJldCA9IDE7CglpZiAodHJhbnNwb3J0LT5vcHMtPnNldF9vcHRpb24pCgkJcmV0ID0gdHJhbnNwb3J0LT5vcHMtPnNldF9vcHRpb24odHJhbnNwb3J0LCBuYW1lLCB2YWx1ZSk7CglpZiAocmV0IDwgMCkKCQlmcHJpbnRmKHN0ZGVyciwgIkZvciAnJXMnIG9wdGlvbiAlcyBjYW5ub3QgYmUgc2V0IHRvICclcydcbiIsCgkJCXRyYW5zcG9ydC0+dXJsLCBuYW1lLCB2YWx1ZSk7CglpZiAocmV0ID4gMCkKCQlmcHJpbnRmKHN0ZGVyciwgIkZvciAnJXMnIG9wdGlvbiAlcyBpcyBpZ25vcmVkXG4iLAoJCQl0cmFuc3BvcnQtPnVybCwgbmFtZSk7CglyZXR1cm4gcmV0Owp9CgppbnQgdHJhbnNwb3J0X3B1c2goc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0LAoJCSAgIGludCByZWZzcGVjX25yLCBjb25zdCBjaGFyICoqcmVmc3BlYywgaW50IGZsYWdzKQp7CglpZiAoIXRyYW5zcG9ydC0+b3BzLT5wdXNoKQoJCXJldHVybiAxOwoJcmV0dXJuIHRyYW5zcG9ydC0+b3BzLT5wdXNoKHRyYW5zcG9ydCwgcmVmc3BlY19uciwgcmVmc3BlYywgZmxhZ3MpOwp9CgpzdHJ1Y3QgcmVmICp0cmFuc3BvcnRfZ2V0X3JlbW90ZV9yZWZzKHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCkKewoJaWYgKCF0cmFuc3BvcnQtPnJlbW90ZV9yZWZzKQoJCXRyYW5zcG9ydC0+cmVtb3RlX3JlZnMgPQoJCQl0cmFuc3BvcnQtPm9wcy0+Z2V0X3JlZnNfbGlzdCh0cmFuc3BvcnQpOwoJcmV0dXJuIHRyYW5zcG9ydC0+cmVtb3RlX3JlZnM7Cn0KCmludCB0cmFuc3BvcnRfZmV0Y2hfcmVmcyhzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsIHN0cnVjdCByZWYgKnJlZnMpCnsKCWludCByYzsKCWludCBucl9oZWFkcyA9IDAsIG5yX2FsbG9jID0gMDsKCXN0cnVjdCByZWYgKipoZWFkcyA9IE5VTEw7CglzdHJ1Y3QgcmVmICpybTsKCglmb3IgKHJtID0gcmVmczsgcm07IHJtID0gcm0tPm5leHQpIHsKCQlpZiAocm0tPnBlZXJfcmVmICYmCgkJICAgICFoYXNoY21wKHJtLT5wZWVyX3JlZi0+b2xkX3NoYTEsIHJtLT5vbGRfc2hhMSkpCgkJCWNvbnRpbnVlOwoJCUFMTE9DX0dST1coaGVhZHMsIG5yX2hlYWRzICsgMSwgbnJfYWxsb2MpOwoJCWhlYWRzW25yX2hlYWRzKytdID0gcm07Cgl9CgoJcmMgPSB0cmFuc3BvcnQtPm9wcy0+ZmV0Y2godHJhbnNwb3J0LCBucl9oZWFkcywgaGVhZHMpOwoJZnJlZShoZWFkcyk7CglyZXR1cm4gcmM7Cn0KCnZvaWQgdHJhbnNwb3J0X3VubG9ja19wYWNrKHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCkKewoJaWYgKHRyYW5zcG9ydC0+cGFja19sb2NrZmlsZSkgewoJCXVubGluayh0cmFuc3BvcnQtPnBhY2tfbG9ja2ZpbGUpOwoJCWZyZWUodHJhbnNwb3J0LT5wYWNrX2xvY2tmaWxlKTsKCQl0cmFuc3BvcnQtPnBhY2tfbG9ja2ZpbGUgPSBOVUxMOwoJfQp9CgppbnQgdHJhbnNwb3J0X2Rpc2Nvbm5lY3Qoc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0KQp7CglpbnQgcmV0ID0gMDsKCWlmICh0cmFuc3BvcnQtPm9wcy0+ZGlzY29ubmVjdCkKCQlyZXQgPSB0cmFuc3BvcnQtPm9wcy0+ZGlzY29ubmVjdCh0cmFuc3BvcnQpOwoJZnJlZSh0cmFuc3BvcnQpOwoJcmV0dXJuIHJldDsKfQo=",
    "text": "#include \"cache.h\"\n#include \"transport.h\"\n#include \"run-command.h\"\n#include \"http.h\"\n#include \"pkt-line.h\"\n#include \"fetch-pack.h\"\n#include \"walker.h\"\n#include \"bundle.h\"\n\n/* Generic functions for using commit walkers */\n\nstatic int fetch_objs_via_walker(struct transport *transport,\n\t\t\t\t int nr_objs, struct ref **to_fetch)\n{\n\tchar *dest = xstrdup(transport->url);\n\tstruct walker *walker = transport->data;\n\tchar **objs = xmalloc(nr_objs * sizeof(*objs));\n\tint i;\n\n\twalker->get_all = 1;\n\twalker->get_tree = 1;\n\twalker->get_history = 1;\n\twalker->get_verbosely = transport->verbose;\n\twalker->get_recover = 0;\n\n\tfor (i = 0; i < nr_objs; i++)\n\t\tobjs[i] = xstrdup(sha1_to_hex(to_fetch[i]->old_sha1));\n\n\tif (walker_fetch(walker, nr_objs, objs, NULL, NULL))\n\t\tdie(\"Fetch failed.\");\n\n\tfor (i = 0; i < nr_objs; i++)\n\t\tfree(objs[i]);\n\tfree(objs);\n\tfree(dest);\n\treturn 0;\n}\n\nstatic int disconnect_walker(struct transport *transport)\n{\n\tstruct walker *walker = transport->data;\n\tif (walker)\n\t\twalker_free(walker);\n\treturn 0;\n}\n\nstatic const struct transport_ops rsync_transport;\n\nstatic int curl_transport_push(struct transport *transport, int refspec_nr, const char **refspec, int flags) {\n\tconst char **argv;\n\tint argc;\n\tint err;\n\n\targv = xmalloc((refspec_nr + 11) * sizeof(char *));\n\targv[0] = \"http-push\";\n\targc = 1;\n\tif (flags & TRANSPORT_PUSH_ALL)\n\t\targv[argc++] = \"--all\";\n\tif (flags & TRANSPORT_PUSH_FORCE)\n\t\targv[argc++] = \"--force\";\n\targv[argc++] = transport->url;\n\twhile (refspec_nr--)\n\t\targv[argc++] = *refspec++;\n\targv[argc] = NULL;\n\terr = run_command_v_opt(argv, RUN_GIT_CMD);\n\tswitch (err) {\n\tcase -ERR_RUN_COMMAND_FORK:\n\t\terror(\"unable to fork for %s\", argv[0]);\n\tcase -ERR_RUN_COMMAND_EXEC:\n\t\terror(\"unable to exec %s\", argv[0]);\n\t\tbreak;\n\tcase -ERR_RUN_COMMAND_WAITPID:\n\tcase -ERR_RUN_COMMAND_WAITPID_WRONG_PID:\n\tcase -ERR_RUN_COMMAND_WAITPID_SIGNAL:\n\tcase -ERR_RUN_COMMAND_WAITPID_NOEXIT:\n\t\terror(\"%s died with strange error\", argv[0]);\n\t}\n\treturn !!err;\n}\n\n#ifndef NO_CURL\nstatic int missing__target(int code, int result)\n{\n\treturn\t/* file:// URL -- do we ever use one??? */\n\t\t(result == CURLE_FILE_COULDNT_READ_FILE) ||\n\t\t/* http:// and https:// URL */\n\t\t(code == 404 && result == CURLE_HTTP_RETURNED_ERROR) ||\n\t\t/* ftp:// URL */\n\t\t(code == 550 && result == CURLE_FTP_COULDNT_RETR_FILE)\n\t\t;\n}\n\n#define missing_target(a) missing__target((a)->http_code, (a)->curl_result)\n\nstatic struct ref *get_refs_via_curl(const struct transport *transport)\n{\n\tstruct buffer buffer;\n\tchar *data, *start, *mid;\n\tchar *ref_name;\n\tchar *refs_url;\n\tint i = 0;\n\n\tstruct active_request_slot *slot;\n\tstruct slot_results results;\n\n\tstruct ref *refs = NULL;\n\tstruct ref *ref = NULL;\n\tstruct ref *last_ref = NULL;\n\n\tdata = xmalloc(4096);\n\tbuffer.size = 4096;\n\tbuffer.posn = 0;\n\tbuffer.buffer = data;\n\n\trefs_url = xmalloc(strlen(transport->url) + 11);\n\tsprintf(refs_url, \"%s/info/refs\", transport->url);\n\n\thttp_init();\n\n\tslot = get_active_slot();\n\tslot->results = &results;\n\tcurl_easy_setopt(slot->curl, CURLOPT_FILE, &buffer);\n\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION, fwrite_buffer);\n\tcurl_easy_setopt(slot->curl, CURLOPT_URL, refs_url);\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, NULL);\n\tif (start_active_slot(slot)) {\n\t\trun_active_slot(slot);\n\t\tif (results.curl_result != CURLE_OK) {\n\t\t\tif (missing_target(&results)) {\n\t\t\t\tfree(buffer.buffer);\n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\tfree(buffer.buffer);\n\t\t\t\terror(\"%s\", curl_errorstr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfree(buffer.buffer);\n\t\terror(\"Unable to start request\");\n\t\treturn NULL;\n\t}\n\n\thttp_cleanup();\n\n\tdata = buffer.buffer;\n\tstart = NULL;\n\tmid = data;\n\twhile (i < buffer.posn) {\n\t\tif (!start)\n\t\t\tstart = &data[i];\n\t\tif (data[i] == '\\t')\n\t\t\tmid = &data[i];\n\t\tif (data[i] == '\\n') {\n\t\t\tdata[i] = 0;\n\t\t\tref_name = mid + 1;\n\t\t\tref = xmalloc(sizeof(struct ref) +\n\t\t\t\t      strlen(ref_name) + 1);\n\t\t\tmemset(ref, 0, sizeof(struct ref));\n\t\t\tstrcpy(ref->name, ref_name);\n\t\t\tget_sha1_hex(start, ref->old_sha1);\n\t\t\tif (!refs)\n\t\t\t\trefs = ref;\n\t\t\tif (last_ref)\n\t\t\t\tlast_ref->next = ref;\n\t\t\tlast_ref = ref;\n\t\t\tstart = NULL;\n\t\t}\n\t\ti++;\n\t}\n\n\tfree(buffer.buffer);\n\n\treturn refs;\n}\n\n#else\n\nstatic struct ref *get_refs_via_curl(const struct transport *transport)\n{\n\tdie(\"Cannot fetch from '%s' without curl ...\", transport->url);\n\treturn NULL;\n}\n\n#endif\n\nstatic const struct transport_ops curl_transport = {\n\t/* set_option */\tNULL,\n\t/* get_refs_list */\tget_refs_via_curl,\n\t/* fetch */\t\tfetch_objs_via_walker,\n\t/* push */\t\tcurl_transport_push,\n\t/* disconnect */\tdisconnect_walker\n};\n\nstruct bundle_transport_data {\n\tint fd;\n\tstruct bundle_header header;\n};\n\nstatic struct ref *get_refs_from_bundle(const struct transport *transport)\n{\n\tstruct bundle_transport_data *data = transport->data;\n\tstruct ref *result = NULL;\n\tint i;\n\n\tif (data->fd > 0)\n\t\tclose(data->fd);\n\tdata->fd = read_bundle_header(transport->url, &data->header);\n\tif (data->fd < 0)\n\t\tdie (\"Could not read bundle '%s'.\", transport->url);\n\tfor (i = 0; i < data->header.references.nr; i++) {\n\t\tstruct ref_list_entry *e = data->header.references.list + i;\n\t\tstruct ref *ref = alloc_ref(strlen(e->name));\n\t\thashcpy(ref->old_sha1, e->sha1);\n\t\tstrcpy(ref->name, e->name);\n\t\tref->next = result;\n\t\tresult = ref;\n\t}\n\treturn result;\n}\n\nstatic int fetch_refs_from_bundle(struct transport *transport,\n\t\t\t       int nr_heads, struct ref **to_fetch)\n{\n\tstruct bundle_transport_data *data = transport->data;\n\treturn unbundle(&data->header, data->fd);\n}\n\nstatic int close_bundle(struct transport *transport)\n{\n\tstruct bundle_transport_data *data = transport->data;\n\tif (data->fd > 0)\n\t\tclose(data->fd);\n\treturn 0;\n}\n\nstatic const struct transport_ops bundle_transport = {\n\t/* set_option */\tNULL,\n\t/* get_refs_list */\tget_refs_from_bundle,\n\t/* fetch */\t\tfetch_refs_from_bundle,\n\t/* push */\t\tNULL,\n\t/* disconnect */\tclose_bundle\n};\n\nstruct git_transport_data {\n\tunsigned thin : 1;\n\tunsigned keep : 1;\n\n\tint unpacklimit;\n\n\tint depth;\n\n\tconst char *uploadpack;\n\tconst char *receivepack;\n};\n\nstatic int set_git_option(struct transport *connection,\n\t\t\t  const char *name, const char *value)\n{\n\tstruct git_transport_data *data = connection->data;\n\tif (!strcmp(name, TRANS_OPT_UPLOADPACK)) {\n\t\tdata->uploadpack = value;\n\t\treturn 0;\n\t} else if (!strcmp(name, TRANS_OPT_RECEIVEPACK)) {\n\t\tdata->receivepack = value;\n\t\treturn 0;\n\t} else if (!strcmp(name, TRANS_OPT_THIN)) {\n\t\tdata->thin = !!value;\n\t\treturn 0;\n\t} else if (!strcmp(name, TRANS_OPT_KEEP)) {\n\t\tdata->keep = !!value;\n\t\treturn 0;\n\t} else if (!strcmp(name, TRANS_OPT_UNPACKLIMIT)) {\n\t\tdata->unpacklimit = atoi(value);\n\t\treturn 0;\n\t} else if (!strcmp(name, TRANS_OPT_DEPTH)) {\n\t\tif (!value)\n\t\t\tdata->depth = 0;\n\t\telse\n\t\t\tdata->depth = atoi(value);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic struct ref *get_refs_via_connect(const struct transport *transport)\n{\n\tstruct git_transport_data *data = transport->data;\n\tstruct ref *refs;\n\tint fd[2];\n\tpid_t pid;\n\tchar *dest = xstrdup(transport->url);\n\n\tpid = git_connect(fd, dest, data->uploadpack, 0);\n\n\tif (pid < 0)\n\t\tdie(\"Failed to connect to \\\"%s\\\"\", transport->url);\n\n\tget_remote_heads(fd[0], &refs, 0, NULL, 0);\n\tpacket_flush(fd[1]);\n\n\tfinish_connect(pid);\n\n\tfree(dest);\n\n\treturn refs;\n}\n\nstatic int fetch_refs_via_pack(struct transport *transport,\n\t\t\t       int nr_heads, struct ref **to_fetch)\n{\n\tstruct git_transport_data *data = transport->data;\n\tchar **heads = xmalloc(nr_heads * sizeof(*heads));\n\tchar **origh = xmalloc(nr_heads * sizeof(*origh));\n\tstruct ref *refs;\n\tchar *dest = xstrdup(transport->url);\n\tstruct fetch_pack_args args;\n\tint i;\n\n\targs.uploadpack = data->uploadpack;\n\targs.quiet = 0;\n\targs.keep_pack = data->keep;\n\targs.unpacklimit = data->unpacklimit;\n\targs.use_thin_pack = data->thin;\n\targs.fetch_all = 0;\n\targs.verbose = transport->verbose;\n\targs.depth = data->depth;\n\targs.no_progress = 0;\n\n\tsetup_fetch_pack(&args);\n\n\tfor (i = 0; i < nr_heads; i++)\n\t\torigh[i] = heads[i] = xstrdup(to_fetch[i]->name);\n\trefs = fetch_pack(dest, nr_heads, heads, &transport->pack_lockfile);\n\n\tfor (i = 0; i < nr_heads; i++)\n\t\tfree(origh[i]);\n\tfree(origh);\n\tfree(heads);\n\tfree_refs(refs);\n\tfree(dest);\n\treturn 0;\n}\n\nstatic int git_transport_push(struct transport *transport, int refspec_nr, const char **refspec, int flags) {\n\tstruct git_transport_data *data = transport->data;\n\tconst char **argv;\n\tchar *rem;\n\tint argc;\n\tint err;\n\n\targv = xmalloc((refspec_nr + 11) * sizeof(char *));\n\targv[0] = \"send-pack\";\n\targc = 1;\n\tif (flags & TRANSPORT_PUSH_ALL)\n\t\targv[argc++] = \"--all\";\n\tif (flags & TRANSPORT_PUSH_FORCE)\n\t\targv[argc++] = \"--force\";\n\tif (data->receivepack) {\n\t\tchar *rp = xmalloc(strlen(data->receivepack) + 16);\n\t\tsprintf(rp, \"--receive-pack=%s\", data->receivepack);\n\t\targv[argc++] = rp;\n\t}\n\tif (data->thin)\n\t\targv[argc++] = \"--thin\";\n\trem = xmalloc(strlen(transport->remote->name) + 10);\n\tsprintf(rem, \"--remote=%s\", transport->remote->name);\n\targv[argc++] = rem;\n\targv[argc++] = transport->url;\n\twhile (refspec_nr--)\n\t\targv[argc++] = *refspec++;\n\targv[argc] = NULL;\n\terr = run_command_v_opt(argv, RUN_GIT_CMD);\n\tswitch (err) {\n\tcase -ERR_RUN_COMMAND_FORK:\n\t\terror(\"unable to fork for %s\", argv[0]);\n\tcase -ERR_RUN_COMMAND_EXEC:\n\t\terror(\"unable to exec %s\", argv[0]);\n\t\tbreak;\n\tcase -ERR_RUN_COMMAND_WAITPID:\n\tcase -ERR_RUN_COMMAND_WAITPID_WRONG_PID:\n\tcase -ERR_RUN_COMMAND_WAITPID_SIGNAL:\n\tcase -ERR_RUN_COMMAND_WAITPID_NOEXIT:\n\t\terror(\"%s died with strange error\", argv[0]);\n\t}\n\treturn !!err;\n}\n\nstatic const struct transport_ops git_transport = {\n\t/* set_option */\tset_git_option,\n\t/* get_refs_list */\tget_refs_via_connect,\n\t/* fetch */\t\tfetch_refs_via_pack,\n\t/* push */\t\tgit_transport_push\n};\n\nstatic int is_local(const char *url)\n{\n\tconst char *colon = strchr(url, ':');\n\tconst char *slash = strchr(url, '/');\n\treturn !colon || (slash && slash < colon);\n}\n\nstatic int is_file(const char *url)\n{\n\tstruct stat buf;\n\tif (stat(url, &buf))\n\t\treturn 0;\n\treturn S_ISREG(buf.st_mode);\n}\n\nstruct transport *transport_get(struct remote *remote, const char *url,\n\t\t\t\tint fetch)\n{\n\tstruct transport *ret = NULL;\n\tif (!prefixcmp(url, \"rsync://\")) {\n\t\tret = xmalloc(sizeof(*ret));\n\t\tret->data = NULL;\n\t\tret->ops = &rsync_transport;\n\t} else if (!prefixcmp(url, \"http://\") || !prefixcmp(url, \"https://\") ||\n\t\t   !prefixcmp(url, \"ftp://\")) {\n\t\tret = xmalloc(sizeof(*ret));\n\t\tret->ops = &curl_transport;\n\t\tif (fetch)\n\t\t\tret->data = get_http_walker(url);\n\t\telse\n\t\t\tret->data = NULL;\n\t} else if (is_local(url) && is_file(url)) {\n\t\tstruct bundle_transport_data *data = xcalloc(1, sizeof(*data));\n\t\tret = xmalloc(sizeof(*ret));\n\t\tret->data = data;\n\t\tret->ops = &bundle_transport;\n\t} else {\n\t\tstruct git_transport_data *data = xcalloc(1, sizeof(*data));\n\t\tret = xcalloc(1, sizeof(*ret));\n\t\tret->data = data;\n\t\tdata->thin = 1;\n\t\tdata->uploadpack = \"git-upload-pack\";\n\t\tif (remote && remote->uploadpack)\n\t\t\tdata->uploadpack = remote->uploadpack;\n\t\tdata->receivepack = \"git-receive-pack\";\n\t\tif (remote && remote->receivepack)\n\t\t\tdata->receivepack = remote->receivepack;\n\t\tdata->unpacklimit = -1;\n\t\tret->ops = &git_transport;\n\t}\n\tif (ret) {\n\t\tret->remote = remote;\n\t\tret->url = url;\n\t\tret->remote_refs = NULL;\n\t\tret->fetch = !!fetch;\n\t\tret->pack_lockfile = NULL;\n\t}\n\treturn ret;\n}\n\nint transport_set_option(struct transport *transport,\n\t\t\t const char *name, const char *value)\n{\n\tint ret = 1;\n\tif (transport->ops->set_option)\n\t\tret = transport->ops->set_option(transport, name, value);\n\tif (ret < 0)\n\t\tfprintf(stderr, \"For '%s' option %s cannot be set to '%s'\\n\",\n\t\t\ttransport->url, name, value);\n\tif (ret > 0)\n\t\tfprintf(stderr, \"For '%s' option %s is ignored\\n\",\n\t\t\ttransport->url, name);\n\treturn ret;\n}\n\nint transport_push(struct transport *transport,\n\t\t   int refspec_nr, const char **refspec, int flags)\n{\n\tif (!transport->ops->push)\n\t\treturn 1;\n\treturn transport->ops->push(transport, refspec_nr, refspec, flags);\n}\n\nstruct ref *transport_get_remote_refs(struct transport *transport)\n{\n\tif (!transport->remote_refs)\n\t\ttransport->remote_refs =\n\t\t\ttransport->ops->get_refs_list(transport);\n\treturn transport->remote_refs;\n}\n\nint transport_fetch_refs(struct transport *transport, struct ref *refs)\n{\n\tint rc;\n\tint nr_heads = 0, nr_alloc = 0;\n\tstruct ref **heads = NULL;\n\tstruct ref *rm;\n\n\tfor (rm = refs; rm; rm = rm->next) {\n\t\tif (rm->peer_ref &&\n\t\t    !hashcmp(rm->peer_ref->old_sha1, rm->old_sha1))\n\t\t\tcontinue;\n\t\tALLOC_GROW(heads, nr_heads + 1, nr_alloc);\n\t\theads[nr_heads++] = rm;\n\t}\n\n\trc = transport->ops->fetch(transport, nr_heads, heads);\n\tfree(heads);\n\treturn rc;\n}\n\nvoid transport_unlock_pack(struct transport *transport)\n{\n\tif (transport->pack_lockfile) {\n\t\tunlink(transport->pack_lockfile);\n\t\tfree(transport->pack_lockfile);\n\t\ttransport->pack_lockfile = NULL;\n\t}\n}\n\nint transport_disconnect(struct transport *transport)\n{\n\tint ret = 0;\n\tif (transport->ops->disconnect)\n\t\tret = transport->ops->disconnect(transport);\n\tfree(transport);\n\treturn ret;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "002119061edfbce3cb6a6bdc34cbd0759b87cf25",
  "sha1_ok": true,
  "size": 12842
}
