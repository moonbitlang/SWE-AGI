{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImNyZWRlbnRpYWwuaCIKI2luY2x1ZGUgInN0cmluZy1saXN0LmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAidXJsLmgiCiNpbmNsdWRlICJwcm9tcHQuaCIKI2luY2x1ZGUgInNpZ2NoYWluLmgiCiNpbmNsdWRlICJ1cmxtYXRjaC5oIgoKdm9pZCBjcmVkZW50aWFsX2luaXQoc3RydWN0IGNyZWRlbnRpYWwgKmMpCnsKCXN0cnVjdCBjcmVkZW50aWFsIGJsYW5rID0gQ1JFREVOVElBTF9JTklUOwoJbWVtY3B5KGMsICZibGFuaywgc2l6ZW9mKCpjKSk7Cn0KCnZvaWQgY3JlZGVudGlhbF9jbGVhcihzdHJ1Y3QgY3JlZGVudGlhbCAqYykKewoJZnJlZShjLT5wcm90b2NvbCk7CglmcmVlKGMtPmhvc3QpOwoJZnJlZShjLT5wYXRoKTsKCWZyZWUoYy0+dXNlcm5hbWUpOwoJZnJlZShjLT5wYXNzd29yZCk7CglzdHJpbmdfbGlzdF9jbGVhcigmYy0+aGVscGVycywgMCk7CgoJY3JlZGVudGlhbF9pbml0KGMpOwp9CgppbnQgY3JlZGVudGlhbF9tYXRjaChjb25zdCBzdHJ1Y3QgY3JlZGVudGlhbCAqd2FudCwKCQkgICAgIGNvbnN0IHN0cnVjdCBjcmVkZW50aWFsICpoYXZlKQp7CiNkZWZpbmUgQ0hFQ0soeCkgKCF3YW50LT54IHx8IChoYXZlLT54ICYmICFzdHJjbXAod2FudC0+eCwgaGF2ZS0+eCkpKQoJcmV0dXJuIENIRUNLKHByb3RvY29sKSAmJgoJICAgICAgIENIRUNLKGhvc3QpICYmCgkgICAgICAgQ0hFQ0socGF0aCkgJiYKCSAgICAgICBDSEVDSyh1c2VybmFtZSk7CiN1bmRlZiBDSEVDSwp9CgoKc3RhdGljIGludCBjcmVkZW50aWFsX2Zyb21fcG90ZW50aWFsbHlfcGFydGlhbF91cmwoc3RydWN0IGNyZWRlbnRpYWwgKmMsCgkJCQkJCSAgIGNvbnN0IGNoYXIgKnVybCk7CgpzdGF0aWMgaW50IGNyZWRlbnRpYWxfY29uZmlnX2NhbGxiYWNrKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsCgkJCQkgICAgICB2b2lkICpkYXRhKQp7CglzdHJ1Y3QgY3JlZGVudGlhbCAqYyA9IGRhdGE7Cgljb25zdCBjaGFyICprZXk7CgoJaWYgKCFza2lwX3ByZWZpeCh2YXIsICJjcmVkZW50aWFsLiIsICZrZXkpKQoJCXJldHVybiAwOwoKCWlmICghdmFsdWUpCgkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKHZhcik7CgoJaWYgKCFzdHJjbXAoa2V5LCAiaGVscGVyIikpIHsKCQlpZiAoKnZhbHVlKQoJCQlzdHJpbmdfbGlzdF9hcHBlbmQoJmMtPmhlbHBlcnMsIHZhbHVlKTsKCQllbHNlCgkJCXN0cmluZ19saXN0X2NsZWFyKCZjLT5oZWxwZXJzLCAwKTsKCX0gZWxzZSBpZiAoIXN0cmNtcChrZXksICJ1c2VybmFtZSIpKSB7CgkJaWYgKCFjLT51c2VybmFtZV9mcm9tX3Byb3RvKSB7CgkJCWZyZWUoYy0+dXNlcm5hbWUpOwoJCQljLT51c2VybmFtZSA9IHhzdHJkdXAodmFsdWUpOwoJCX0KCX0KCWVsc2UgaWYgKCFzdHJjbXAoa2V5LCAidXNlaHR0cHBhdGgiKSkKCQljLT51c2VfaHR0cF9wYXRoID0gZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHByb3RvX2lzX2h0dHAoY29uc3QgY2hhciAqcykKewoJaWYgKCFzKQoJCXJldHVybiAwOwoJcmV0dXJuICFzdHJjbXAocywgImh0dHBzIikgfHwgIXN0cmNtcChzLCAiaHR0cCIpOwp9CgpzdGF0aWMgdm9pZCBjcmVkZW50aWFsX2Rlc2NyaWJlKHN0cnVjdCBjcmVkZW50aWFsICpjLCBzdHJ1Y3Qgc3RyYnVmICpvdXQpOwpzdGF0aWMgdm9pZCBjcmVkZW50aWFsX2Zvcm1hdChzdHJ1Y3QgY3JlZGVudGlhbCAqYywgc3RydWN0IHN0cmJ1ZiAqb3V0KTsKCnN0YXRpYyBpbnQgc2VsZWN0X2FsbChjb25zdCBzdHJ1Y3QgdXJsbWF0Y2hfaXRlbSAqYSwKCQkgICAgICBjb25zdCBzdHJ1Y3QgdXJsbWF0Y2hfaXRlbSAqYikKewoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgbWF0Y2hfcGFydGlhbF91cmwoY29uc3QgY2hhciAqdXJsLCB2b2lkICpjYikKewoJc3RydWN0IGNyZWRlbnRpYWwgKmMgPSBjYjsKCXN0cnVjdCBjcmVkZW50aWFsIHdhbnQgPSBDUkVERU5USUFMX0lOSVQ7CglpbnQgbWF0Y2hlcyA9IDA7CgoJaWYgKGNyZWRlbnRpYWxfZnJvbV9wb3RlbnRpYWxseV9wYXJ0aWFsX3VybCgmd2FudCwgdXJsKSA8IDApCgkJd2FybmluZyhfKCJza2lwcGluZyBjcmVkZW50aWFsIGxvb2t1cCBmb3Iga2V5OiBjcmVkZW50aWFsLiVzIiksCgkJCXVybCk7CgllbHNlCgkJbWF0Y2hlcyA9IGNyZWRlbnRpYWxfbWF0Y2goJndhbnQsIGMpOwoJY3JlZGVudGlhbF9jbGVhcigmd2FudCk7CgoJcmV0dXJuIG1hdGNoZXM7Cn0KCnN0YXRpYyB2b2lkIGNyZWRlbnRpYWxfYXBwbHlfY29uZmlnKHN0cnVjdCBjcmVkZW50aWFsICpjKQp7CgljaGFyICpub3JtYWxpemVkX3VybDsKCXN0cnVjdCB1cmxtYXRjaF9jb25maWcgY29uZmlnID0geyBTVFJJTkdfTElTVF9JTklUX0RVUCB9OwoJc3RydWN0IHN0cmJ1ZiB1cmwgPSBTVFJCVUZfSU5JVDsKCglpZiAoIWMtPmhvc3QpCgkJZGllKF8oInJlZnVzaW5nIHRvIHdvcmsgd2l0aCBjcmVkZW50aWFsIG1pc3NpbmcgaG9zdCBmaWVsZCIpKTsKCWlmICghYy0+cHJvdG9jb2wpCgkJZGllKF8oInJlZnVzaW5nIHRvIHdvcmsgd2l0aCBjcmVkZW50aWFsIG1pc3NpbmcgcHJvdG9jb2wgZmllbGQiKSk7CgoJaWYgKGMtPmNvbmZpZ3VyZWQpCgkJcmV0dXJuOwoKCWNvbmZpZy5zZWN0aW9uID0gImNyZWRlbnRpYWwiOwoJY29uZmlnLmtleSA9IE5VTEw7Cgljb25maWcuY29sbGVjdF9mbiA9IGNyZWRlbnRpYWxfY29uZmlnX2NhbGxiYWNrOwoJY29uZmlnLmNhc2NhZGVfZm4gPSBOVUxMOwoJY29uZmlnLnNlbGVjdF9mbiA9IHNlbGVjdF9hbGw7Cgljb25maWcuZmFsbGJhY2tfbWF0Y2hfZm4gPSBtYXRjaF9wYXJ0aWFsX3VybDsKCWNvbmZpZy5jYiA9IGM7CgoJY3JlZGVudGlhbF9mb3JtYXQoYywgJnVybCk7Cglub3JtYWxpemVkX3VybCA9IHVybF9ub3JtYWxpemUodXJsLmJ1ZiwgJmNvbmZpZy51cmwpOwoKCWdpdF9jb25maWcodXJsbWF0Y2hfY29uZmlnX2VudHJ5LCAmY29uZmlnKTsKCXN0cmluZ19saXN0X2NsZWFyKCZjb25maWcudmFycywgMSk7CglmcmVlKG5vcm1hbGl6ZWRfdXJsKTsKCXN0cmJ1Zl9yZWxlYXNlKCZ1cmwpOwoKCWMtPmNvbmZpZ3VyZWQgPSAxOwoKCWlmICghYy0+dXNlX2h0dHBfcGF0aCAmJiBwcm90b19pc19odHRwKGMtPnByb3RvY29sKSkgewoJCUZSRUVfQU5EX05VTEwoYy0+cGF0aCk7Cgl9Cn0KCnN0YXRpYyB2b2lkIGNyZWRlbnRpYWxfZGVzY3JpYmUoc3RydWN0IGNyZWRlbnRpYWwgKmMsIHN0cnVjdCBzdHJidWYgKm91dCkKewoJaWYgKCFjLT5wcm90b2NvbCkKCQlyZXR1cm47CglzdHJidWZfYWRkZihvdXQsICIlczovLyIsIGMtPnByb3RvY29sKTsKCWlmIChjLT51c2VybmFtZSAmJiAqYy0+dXNlcm5hbWUpCgkJc3RyYnVmX2FkZGYob3V0LCAiJXNAIiwgYy0+dXNlcm5hbWUpOwoJaWYgKGMtPmhvc3QpCgkJc3RyYnVmX2FkZHN0cihvdXQsIGMtPmhvc3QpOwoJaWYgKGMtPnBhdGgpCgkJc3RyYnVmX2FkZGYob3V0LCAiLyVzIiwgYy0+cGF0aCk7Cn0KCnN0YXRpYyB2b2lkIGNyZWRlbnRpYWxfZm9ybWF0KHN0cnVjdCBjcmVkZW50aWFsICpjLCBzdHJ1Y3Qgc3RyYnVmICpvdXQpCnsKCWlmICghYy0+cHJvdG9jb2wpCgkJcmV0dXJuOwoJc3RyYnVmX2FkZGYob3V0LCAiJXM6Ly8iLCBjLT5wcm90b2NvbCk7CglpZiAoYy0+dXNlcm5hbWUgJiYgKmMtPnVzZXJuYW1lKSB7CgkJc3RyYnVmX2FkZF9wZXJjZW50ZW5jb2RlKG91dCwgYy0+dXNlcm5hbWUsIFNUUkJVRl9FTkNPREVfU0xBU0gpOwoJCXN0cmJ1Zl9hZGRjaChvdXQsICdAJyk7Cgl9CglpZiAoYy0+aG9zdCkKCQlzdHJidWZfYWRkc3RyKG91dCwgYy0+aG9zdCk7CglpZiAoYy0+cGF0aCkgewoJCXN0cmJ1Zl9hZGRjaChvdXQsICcvJyk7CgkJc3RyYnVmX2FkZF9wZXJjZW50ZW5jb2RlKG91dCwgYy0+cGF0aCwgMCk7Cgl9Cn0KCnN0YXRpYyBjaGFyICpjcmVkZW50aWFsX2Fza19vbmUoY29uc3QgY2hhciAqd2hhdCwgc3RydWN0IGNyZWRlbnRpYWwgKmMsCgkJCQlpbnQgZmxhZ3MpCnsKCXN0cnVjdCBzdHJidWYgZGVzYyA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBwcm9tcHQgPSBTVFJCVUZfSU5JVDsKCWNoYXIgKnI7CgoJY3JlZGVudGlhbF9kZXNjcmliZShjLCAmZGVzYyk7CglpZiAoZGVzYy5sZW4pCgkJc3RyYnVmX2FkZGYoJnByb21wdCwgIiVzIGZvciAnJXMnOiAiLCB3aGF0LCBkZXNjLmJ1Zik7CgllbHNlCgkJc3RyYnVmX2FkZGYoJnByb21wdCwgIiVzOiAiLCB3aGF0KTsKCglyID0gZ2l0X3Byb21wdChwcm9tcHQuYnVmLCBmbGFncyk7CgoJc3RyYnVmX3JlbGVhc2UoJmRlc2MpOwoJc3RyYnVmX3JlbGVhc2UoJnByb21wdCk7CglyZXR1cm4geHN0cmR1cChyKTsKfQoKc3RhdGljIHZvaWQgY3JlZGVudGlhbF9nZXRwYXNzKHN0cnVjdCBjcmVkZW50aWFsICpjKQp7CglpZiAoIWMtPnVzZXJuYW1lKQoJCWMtPnVzZXJuYW1lID0gY3JlZGVudGlhbF9hc2tfb25lKCJVc2VybmFtZSIsIGMsCgkJCQkJCSBQUk9NUFRfQVNLUEFTU3xQUk9NUFRfRUNITyk7CglpZiAoIWMtPnBhc3N3b3JkKQoJCWMtPnBhc3N3b3JkID0gY3JlZGVudGlhbF9hc2tfb25lKCJQYXNzd29yZCIsIGMsCgkJCQkJCSBQUk9NUFRfQVNLUEFTUyk7Cn0KCmludCBjcmVkZW50aWFsX3JlYWQoc3RydWN0IGNyZWRlbnRpYWwgKmMsIEZJTEUgKmZwKQp7CglzdHJ1Y3Qgc3RyYnVmIGxpbmUgPSBTVFJCVUZfSU5JVDsKCgl3aGlsZSAoc3RyYnVmX2dldGxpbmUoJmxpbmUsIGZwKSAhPSBFT0YpIHsKCQljaGFyICprZXkgPSBsaW5lLmJ1ZjsKCQljaGFyICp2YWx1ZSA9IHN0cmNocihrZXksICc9Jyk7CgoJCWlmICghbGluZS5sZW4pCgkJCWJyZWFrOwoKCQlpZiAoIXZhbHVlKSB7CgkJCXdhcm5pbmcoImludmFsaWQgY3JlZGVudGlhbCBsaW5lOiAlcyIsIGtleSk7CgkJCXN0cmJ1Zl9yZWxlYXNlKCZsaW5lKTsKCQkJcmV0dXJuIC0xOwoJCX0KCQkqdmFsdWUrKyA9ICdcMCc7CgoJCWlmICghc3RyY21wKGtleSwgInVzZXJuYW1lIikpIHsKCQkJZnJlZShjLT51c2VybmFtZSk7CgkJCWMtPnVzZXJuYW1lID0geHN0cmR1cCh2YWx1ZSk7CgkJCWMtPnVzZXJuYW1lX2Zyb21fcHJvdG8gPSAxOwoJCX0gZWxzZSBpZiAoIXN0cmNtcChrZXksICJwYXNzd29yZCIpKSB7CgkJCWZyZWUoYy0+cGFzc3dvcmQpOwoJCQljLT5wYXNzd29yZCA9IHhzdHJkdXAodmFsdWUpOwoJCX0gZWxzZSBpZiAoIXN0cmNtcChrZXksICJwcm90b2NvbCIpKSB7CgkJCWZyZWUoYy0+cHJvdG9jb2wpOwoJCQljLT5wcm90b2NvbCA9IHhzdHJkdXAodmFsdWUpOwoJCX0gZWxzZSBpZiAoIXN0cmNtcChrZXksICJob3N0IikpIHsKCQkJZnJlZShjLT5ob3N0KTsKCQkJYy0+aG9zdCA9IHhzdHJkdXAodmFsdWUpOwoJCX0gZWxzZSBpZiAoIXN0cmNtcChrZXksICJwYXRoIikpIHsKCQkJZnJlZShjLT5wYXRoKTsKCQkJYy0+cGF0aCA9IHhzdHJkdXAodmFsdWUpOwoJCX0gZWxzZSBpZiAoIXN0cmNtcChrZXksICJ1cmwiKSkgewoJCQljcmVkZW50aWFsX2Zyb21fdXJsKGMsIHZhbHVlKTsKCQl9IGVsc2UgaWYgKCFzdHJjbXAoa2V5LCAicXVpdCIpKSB7CgkJCWMtPnF1aXQgPSAhIWdpdF9jb25maWdfYm9vbCgicXVpdCIsIHZhbHVlKTsKCQl9CgkJLyoKCQkgKiBJZ25vcmUgb3RoZXIgbGluZXM7IHdlIGRvbid0IGtub3cgd2hhdCB0aGV5IG1lYW4sIGJ1dAoJCSAqIHRoaXMgZnV0dXJlLXByb29mcyB1cyB3aGVuIGxhdGVyIHZlcnNpb25zIG9mIGdpdCBkbwoJCSAqIGxlYXJuIG5ldyBsaW5lcywgYW5kIHRoZSBoZWxwZXJzIGFyZSB1cGRhdGVkIHRvIG1hdGNoLgoJCSAqLwoJfQoKCXN0cmJ1Zl9yZWxlYXNlKCZsaW5lKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBjcmVkZW50aWFsX3dyaXRlX2l0ZW0oRklMRSAqZnAsIGNvbnN0IGNoYXIgKmtleSwgY29uc3QgY2hhciAqdmFsdWUsCgkJCQkgIGludCByZXF1aXJlZCkKewoJaWYgKCF2YWx1ZSAmJiByZXF1aXJlZCkKCQlCVUcoImNyZWRlbnRpYWwgdmFsdWUgZm9yICVzIGlzIG1pc3NpbmciLCBrZXkpOwoJaWYgKCF2YWx1ZSkKCQlyZXR1cm47CglpZiAoc3RyY2hyKHZhbHVlLCAnXG4nKSkKCQlkaWUoImNyZWRlbnRpYWwgdmFsdWUgZm9yICVzIGNvbnRhaW5zIG5ld2xpbmUiLCBrZXkpOwoJZnByaW50ZihmcCwgIiVzPSVzXG4iLCBrZXksIHZhbHVlKTsKfQoKdm9pZCBjcmVkZW50aWFsX3dyaXRlKGNvbnN0IHN0cnVjdCBjcmVkZW50aWFsICpjLCBGSUxFICpmcCkKewoJY3JlZGVudGlhbF93cml0ZV9pdGVtKGZwLCAicHJvdG9jb2wiLCBjLT5wcm90b2NvbCwgMSk7CgljcmVkZW50aWFsX3dyaXRlX2l0ZW0oZnAsICJob3N0IiwgYy0+aG9zdCwgMSk7CgljcmVkZW50aWFsX3dyaXRlX2l0ZW0oZnAsICJwYXRoIiwgYy0+cGF0aCwgMCk7CgljcmVkZW50aWFsX3dyaXRlX2l0ZW0oZnAsICJ1c2VybmFtZSIsIGMtPnVzZXJuYW1lLCAwKTsKCWNyZWRlbnRpYWxfd3JpdGVfaXRlbShmcCwgInBhc3N3b3JkIiwgYy0+cGFzc3dvcmQsIDApOwp9CgpzdGF0aWMgaW50IHJ1bl9jcmVkZW50aWFsX2hlbHBlcihzdHJ1Y3QgY3JlZGVudGlhbCAqYywKCQkJCSBjb25zdCBjaGFyICpjbWQsCgkJCQkgaW50IHdhbnRfb3V0cHV0KQp7CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBoZWxwZXIgPSBDSElMRF9QUk9DRVNTX0lOSVQ7CglGSUxFICpmcDsKCglzdHJ2ZWNfcHVzaCgmaGVscGVyLmFyZ3MsIGNtZCk7CgloZWxwZXIudXNlX3NoZWxsID0gMTsKCWhlbHBlci5pbiA9IC0xOwoJaWYgKHdhbnRfb3V0cHV0KQoJCWhlbHBlci5vdXQgPSAtMTsKCWVsc2UKCQloZWxwZXIubm9fc3Rkb3V0ID0gMTsKCglpZiAoc3RhcnRfY29tbWFuZCgmaGVscGVyKSA8IDApCgkJcmV0dXJuIC0xOwoKCWZwID0geGZkb3BlbihoZWxwZXIuaW4sICJ3Iik7CglzaWdjaGFpbl9wdXNoKFNJR1BJUEUsIFNJR19JR04pOwoJY3JlZGVudGlhbF93cml0ZShjLCBmcCk7CglmY2xvc2UoZnApOwoJc2lnY2hhaW5fcG9wKFNJR1BJUEUpOwoKCWlmICh3YW50X291dHB1dCkgewoJCWludCByOwoJCWZwID0geGZkb3BlbihoZWxwZXIub3V0LCAiciIpOwoJCXIgPSBjcmVkZW50aWFsX3JlYWQoYywgZnApOwoJCWZjbG9zZShmcCk7CgkJaWYgKHIgPCAwKSB7CgkJCWZpbmlzaF9jb21tYW5kKCZoZWxwZXIpOwoJCQlyZXR1cm4gLTE7CgkJfQoJfQoKCWlmIChmaW5pc2hfY29tbWFuZCgmaGVscGVyKSkKCQlyZXR1cm4gLTE7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBjcmVkZW50aWFsX2RvKHN0cnVjdCBjcmVkZW50aWFsICpjLCBjb25zdCBjaGFyICpoZWxwZXIsCgkJCSBjb25zdCBjaGFyICpvcGVyYXRpb24pCnsKCXN0cnVjdCBzdHJidWYgY21kID0gU1RSQlVGX0lOSVQ7CglpbnQgcjsKCglpZiAoaGVscGVyWzBdID09ICchJykKCQlzdHJidWZfYWRkc3RyKCZjbWQsIGhlbHBlciArIDEpOwoJZWxzZSBpZiAoaXNfYWJzb2x1dGVfcGF0aChoZWxwZXIpKQoJCXN0cmJ1Zl9hZGRzdHIoJmNtZCwgaGVscGVyKTsKCWVsc2UKCQlzdHJidWZfYWRkZigmY21kLCAiZ2l0IGNyZWRlbnRpYWwtJXMiLCBoZWxwZXIpOwoKCXN0cmJ1Zl9hZGRmKCZjbWQsICIgJXMiLCBvcGVyYXRpb24pOwoJciA9IHJ1bl9jcmVkZW50aWFsX2hlbHBlcihjLCBjbWQuYnVmLCAhc3RyY21wKG9wZXJhdGlvbiwgImdldCIpKTsKCglzdHJidWZfcmVsZWFzZSgmY21kKTsKCXJldHVybiByOwp9Cgp2b2lkIGNyZWRlbnRpYWxfZmlsbChzdHJ1Y3QgY3JlZGVudGlhbCAqYykKewoJaW50IGk7CgoJaWYgKGMtPnVzZXJuYW1lICYmIGMtPnBhc3N3b3JkKQoJCXJldHVybjsKCgljcmVkZW50aWFsX2FwcGx5X2NvbmZpZyhjKTsKCglmb3IgKGkgPSAwOyBpIDwgYy0+aGVscGVycy5ucjsgaSsrKSB7CgkJY3JlZGVudGlhbF9kbyhjLCBjLT5oZWxwZXJzLml0ZW1zW2ldLnN0cmluZywgImdldCIpOwoJCWlmIChjLT51c2VybmFtZSAmJiBjLT5wYXNzd29yZCkKCQkJcmV0dXJuOwoJCWlmIChjLT5xdWl0KQoJCQlkaWUoImNyZWRlbnRpYWwgaGVscGVyICclcycgdG9sZCB1cyB0byBxdWl0IiwKCQkJICAgIGMtPmhlbHBlcnMuaXRlbXNbaV0uc3RyaW5nKTsKCX0KCgljcmVkZW50aWFsX2dldHBhc3MoYyk7CglpZiAoIWMtPnVzZXJuYW1lICYmICFjLT5wYXNzd29yZCkKCQlkaWUoInVuYWJsZSB0byBnZXQgcGFzc3dvcmQgZnJvbSB1c2VyIik7Cn0KCnZvaWQgY3JlZGVudGlhbF9hcHByb3ZlKHN0cnVjdCBjcmVkZW50aWFsICpjKQp7CglpbnQgaTsKCglpZiAoYy0+YXBwcm92ZWQpCgkJcmV0dXJuOwoJaWYgKCFjLT51c2VybmFtZSB8fCAhYy0+cGFzc3dvcmQpCgkJcmV0dXJuOwoKCWNyZWRlbnRpYWxfYXBwbHlfY29uZmlnKGMpOwoKCWZvciAoaSA9IDA7IGkgPCBjLT5oZWxwZXJzLm5yOyBpKyspCgkJY3JlZGVudGlhbF9kbyhjLCBjLT5oZWxwZXJzLml0ZW1zW2ldLnN0cmluZywgInN0b3JlIik7CgljLT5hcHByb3ZlZCA9IDE7Cn0KCnZvaWQgY3JlZGVudGlhbF9yZWplY3Qoc3RydWN0IGNyZWRlbnRpYWwgKmMpCnsKCWludCBpOwoKCWNyZWRlbnRpYWxfYXBwbHlfY29uZmlnKGMpOwoKCWZvciAoaSA9IDA7IGkgPCBjLT5oZWxwZXJzLm5yOyBpKyspCgkJY3JlZGVudGlhbF9kbyhjLCBjLT5oZWxwZXJzLml0ZW1zW2ldLnN0cmluZywgImVyYXNlIik7CgoJRlJFRV9BTkRfTlVMTChjLT51c2VybmFtZSk7CglGUkVFX0FORF9OVUxMKGMtPnBhc3N3b3JkKTsKCWMtPmFwcHJvdmVkID0gMDsKfQoKc3RhdGljIGludCBjaGVja191cmxfY29tcG9uZW50KGNvbnN0IGNoYXIgKnVybCwgaW50IHF1aWV0LAoJCQkgICAgICAgY29uc3QgY2hhciAqbmFtZSwgY29uc3QgY2hhciAqdmFsdWUpCnsKCWlmICghdmFsdWUpCgkJcmV0dXJuIDA7CglpZiAoIXN0cmNocih2YWx1ZSwgJ1xuJykpCgkJcmV0dXJuIDA7CgoJaWYgKCFxdWlldCkKCQl3YXJuaW5nKF8oInVybCBjb250YWlucyBhIG5ld2xpbmUgaW4gaXRzICVzIGNvbXBvbmVudDogJXMiKSwKCQkJbmFtZSwgdXJsKTsKCXJldHVybiAtMTsKfQoKLyoKICogUG90ZW50aWFsbHktcGFydGlhbCBVUkxzIGNhbiwgYnV0IGRvIG5vdCBoYXZlIHRvLCBjb250YWluCiAqCiAqIC0gYSBwcm90b2NvbCAob3Igc2NoZW1lKSBvZiB0aGUgZm9ybSAiPHByb3RvY29sPjovLyIKICoKICogLSBhIGhvc3QgbmFtZSAodGhlIHBhcnQgYWZ0ZXIgdGhlIHByb3RvY29sIGFuZCBiZWZvcmUgdGhlIGZpcnN0IHNsYXNoIGFmdGVyCiAqICAgdGhhdCwgaWYgYW55KQogKgogKiAtIGEgdXNlciBuYW1lIGFuZCBwb3RlbnRpYWxseSBhIHBhc3N3b3JkIChhcyAiPHVzZXI+Wzo8cGFzc3dvcmQ+XUAiIHBhcnQgb2YKICogICB0aGUgaG9zdCBuYW1lKQogKgogKiAtIGEgcGF0aCAodGhlIHBhcnQgYWZ0ZXIgdGhlIGhvc3QgbmFtZSwgaWYgYW55LCBzdGFydGluZyB3aXRoIHRoZSBzbGFzaCkKICoKICogTWlzc2luZyBwYXJ0cyB3aWxsIGJlIGxlZnQgdW5zZXQgaW4gYHN0cnVjdCBjcmVkZW50aWFsYC4gVGh1cywgYGh0dHBzOi8vYAogKiB3aWxsIGhhdmUgb25seSB0aGUgYHByb3RvY29sYCBzZXQsIGBleGFtcGxlLmNvbWAgb25seSB0aGUgaG9zdCBuYW1lLCBhbmQKICogYC9naXRgIG9ubHkgdGhlIHBhdGguCiAqCiAqIE5vdGUgdGhhdCBhbiBlbXB0eSBob3N0IG5hbWUgaW4gYW4gb3RoZXJ3aXNlIGZ1bGx5LXF1YWxpZmllZCBVUkwgKGUuZy4KICogYGNlcnQ6Ly8vcGF0aC90by9jZXJ0LnBlbWApIHdpbGwgYmUgdHJlYXRlZCBhcyB1bnNldCBpZiB3ZSBleHBlY3QgdGhlIFVSTCB0bwogKiBiZSBwb3RlbnRpYWxseSBwYXJ0aWFsLCBhbmQgb25seSB0aGVuIChvdGhlcndpc2UsIHRoZSBlbXB0eSBzdHJpbmcgaXMgdXNlZCkuCiAqCiAqIFRoZSBjcmVkZW50aWFsX2Zyb21fdXJsKCkgZnVuY3Rpb24gZG9lcyBub3QgYWxsb3cgcGFydGlhbCBVUkxzLgogKi8Kc3RhdGljIGludCBjcmVkZW50aWFsX2Zyb21fdXJsXzEoc3RydWN0IGNyZWRlbnRpYWwgKmMsIGNvbnN0IGNoYXIgKnVybCwKCQkJCSBpbnQgYWxsb3dfcGFydGlhbF91cmwsIGludCBxdWlldCkKewoJY29uc3QgY2hhciAqYXQsICpjb2xvbiwgKmNwLCAqc2xhc2gsICpob3N0LCAqcHJvdG9fZW5kOwoKCWNyZWRlbnRpYWxfY2xlYXIoYyk7CgoJLyoKCSAqIE1hdGNoIG9uZSBvZjoKCSAqICAgKDEpIHByb3RvOi8vPGhvc3Q+Ly4uLgoJICogICAoMikgcHJvdG86Ly88dXNlcj5APGhvc3Q+Ly4uLgoJICogICAoMykgcHJvdG86Ly88dXNlcj46PHBhc3M+QDxob3N0Pi8uLi4KCSAqLwoJcHJvdG9fZW5kID0gc3Ryc3RyKHVybCwgIjovLyIpOwoJaWYgKCFhbGxvd19wYXJ0aWFsX3VybCAmJiAoIXByb3RvX2VuZCB8fCBwcm90b19lbmQgPT0gdXJsKSkgewoJCWlmICghcXVpZXQpCgkJCXdhcm5pbmcoXygidXJsIGhhcyBubyBzY2hlbWU6ICVzIiksIHVybCk7CgkJcmV0dXJuIC0xOwoJfQoJY3AgPSBwcm90b19lbmQgPyBwcm90b19lbmQgKyAzIDogdXJsOwoJYXQgPSBzdHJjaHIoY3AsICdAJyk7Cgljb2xvbiA9IHN0cmNocihjcCwgJzonKTsKCgkvKgoJICogQSBxdWVyeSBvciBmcmFnbWVudCBtYXJrZXIgYmVmb3JlIHRoZSBzbGFzaCBlbmRzIHRoZSBob3N0IHBvcnRpb24uCgkgKiBXZSdsbCBqdXN0IGNvbnRpbnVlIHRvIGNhbGwgdGhpcyAic2xhc2giIGZvciBzaW1wbGljaXR5LiBOb3RhYmx5IG91cgoJICogInRyaW0gbGVhZGluZyBzbGFzaGVzIiBwYXJ0IHdvbid0IHNraXAgb3ZlciB0aGlzIHBhcnQgb2YgdGhlIHBhdGgsCgkgKiBidXQgdGhhdCdzIHdoYXQgd2UnZCB3YW50LgoJICovCglzbGFzaCA9IGNwICsgc3RyY3NwbihjcCwgIi8/IyIpOwoKCWlmICghYXQgfHwgc2xhc2ggPD0gYXQpIHsKCQkvKiBDYXNlICgxKSAqLwoJCWhvc3QgPSBjcDsKCX0KCWVsc2UgaWYgKCFjb2xvbiB8fCBhdCA8PSBjb2xvbikgewoJCS8qIENhc2UgKDIpICovCgkJYy0+dXNlcm5hbWUgPSB1cmxfZGVjb2RlX21lbShjcCwgYXQgLSBjcCk7CgkJaWYgKGMtPnVzZXJuYW1lICYmICpjLT51c2VybmFtZSkKCQkJYy0+dXNlcm5hbWVfZnJvbV9wcm90byA9IDE7CgkJaG9zdCA9IGF0ICsgMTsKCX0gZWxzZSB7CgkJLyogQ2FzZSAoMykgKi8KCQljLT51c2VybmFtZSA9IHVybF9kZWNvZGVfbWVtKGNwLCBjb2xvbiAtIGNwKTsKCQlpZiAoYy0+dXNlcm5hbWUgJiYgKmMtPnVzZXJuYW1lKQoJCQljLT51c2VybmFtZV9mcm9tX3Byb3RvID0gMTsKCQljLT5wYXNzd29yZCA9IHVybF9kZWNvZGVfbWVtKGNvbG9uICsgMSwgYXQgLSAoY29sb24gKyAxKSk7CgkJaG9zdCA9IGF0ICsgMTsKCX0KCglpZiAocHJvdG9fZW5kICYmIHByb3RvX2VuZCAtIHVybCA+IDApCgkJYy0+cHJvdG9jb2wgPSB4bWVtZHVweih1cmwsIHByb3RvX2VuZCAtIHVybCk7CglpZiAoIWFsbG93X3BhcnRpYWxfdXJsIHx8IHNsYXNoIC0gaG9zdCA+IDApCgkJYy0+aG9zdCA9IHVybF9kZWNvZGVfbWVtKGhvc3QsIHNsYXNoIC0gaG9zdCk7CgkvKiBUcmltIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgZnJvbSBwYXRoICovCgl3aGlsZSAoKnNsYXNoID09ICcvJykKCQlzbGFzaCsrOwoJaWYgKCpzbGFzaCkgewoJCWNoYXIgKnA7CgkJYy0+cGF0aCA9IHVybF9kZWNvZGUoc2xhc2gpOwoJCXAgPSBjLT5wYXRoICsgc3RybGVuKGMtPnBhdGgpIC0gMTsKCQl3aGlsZSAocCA+IGMtPnBhdGggJiYgKnAgPT0gJy8nKQoJCQkqcC0tID0gJ1wwJzsKCX0KCglpZiAoY2hlY2tfdXJsX2NvbXBvbmVudCh1cmwsIHF1aWV0LCAidXNlcm5hbWUiLCBjLT51c2VybmFtZSkgPCAwIHx8CgkgICAgY2hlY2tfdXJsX2NvbXBvbmVudCh1cmwsIHF1aWV0LCAicGFzc3dvcmQiLCBjLT5wYXNzd29yZCkgPCAwIHx8CgkgICAgY2hlY2tfdXJsX2NvbXBvbmVudCh1cmwsIHF1aWV0LCAicHJvdG9jb2wiLCBjLT5wcm90b2NvbCkgPCAwIHx8CgkgICAgY2hlY2tfdXJsX2NvbXBvbmVudCh1cmwsIHF1aWV0LCAiaG9zdCIsIGMtPmhvc3QpIDwgMCB8fAoJICAgIGNoZWNrX3VybF9jb21wb25lbnQodXJsLCBxdWlldCwgInBhdGgiLCBjLT5wYXRoKSA8IDApCgkJcmV0dXJuIC0xOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGNyZWRlbnRpYWxfZnJvbV9wb3RlbnRpYWxseV9wYXJ0aWFsX3VybChzdHJ1Y3QgY3JlZGVudGlhbCAqYywKCQkJCQkJICAgY29uc3QgY2hhciAqdXJsKQp7CglyZXR1cm4gY3JlZGVudGlhbF9mcm9tX3VybF8xKGMsIHVybCwgMSwgMCk7Cn0KCmludCBjcmVkZW50aWFsX2Zyb21fdXJsX2dlbnRseShzdHJ1Y3QgY3JlZGVudGlhbCAqYywgY29uc3QgY2hhciAqdXJsLCBpbnQgcXVpZXQpCnsKCXJldHVybiBjcmVkZW50aWFsX2Zyb21fdXJsXzEoYywgdXJsLCAwLCBxdWlldCk7Cn0KCnZvaWQgY3JlZGVudGlhbF9mcm9tX3VybChzdHJ1Y3QgY3JlZGVudGlhbCAqYywgY29uc3QgY2hhciAqdXJsKQp7CglpZiAoY3JlZGVudGlhbF9mcm9tX3VybF9nZW50bHkoYywgdXJsLCAwKSA8IDApCgkJZGllKF8oImNyZWRlbnRpYWwgdXJsIGNhbm5vdCBiZSBwYXJzZWQ6ICVzIiksIHVybCk7Cn0K",
    "text": "#include \"cache.h\"\n#include \"config.h\"\n#include \"credential.h\"\n#include \"string-list.h\"\n#include \"run-command.h\"\n#include \"url.h\"\n#include \"prompt.h\"\n#include \"sigchain.h\"\n#include \"urlmatch.h\"\n\nvoid credential_init(struct credential *c)\n{\n\tstruct credential blank = CREDENTIAL_INIT;\n\tmemcpy(c, &blank, sizeof(*c));\n}\n\nvoid credential_clear(struct credential *c)\n{\n\tfree(c->protocol);\n\tfree(c->host);\n\tfree(c->path);\n\tfree(c->username);\n\tfree(c->password);\n\tstring_list_clear(&c->helpers, 0);\n\n\tcredential_init(c);\n}\n\nint credential_match(const struct credential *want,\n\t\t     const struct credential *have)\n{\n#define CHECK(x) (!want->x || (have->x && !strcmp(want->x, have->x)))\n\treturn CHECK(protocol) &&\n\t       CHECK(host) &&\n\t       CHECK(path) &&\n\t       CHECK(username);\n#undef CHECK\n}\n\n\nstatic int credential_from_potentially_partial_url(struct credential *c,\n\t\t\t\t\t\t   const char *url);\n\nstatic int credential_config_callback(const char *var, const char *value,\n\t\t\t\t      void *data)\n{\n\tstruct credential *c = data;\n\tconst char *key;\n\n\tif (!skip_prefix(var, \"credential.\", &key))\n\t\treturn 0;\n\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\n\tif (!strcmp(key, \"helper\")) {\n\t\tif (*value)\n\t\t\tstring_list_append(&c->helpers, value);\n\t\telse\n\t\t\tstring_list_clear(&c->helpers, 0);\n\t} else if (!strcmp(key, \"username\")) {\n\t\tif (!c->username_from_proto) {\n\t\t\tfree(c->username);\n\t\t\tc->username = xstrdup(value);\n\t\t}\n\t}\n\telse if (!strcmp(key, \"usehttppath\"))\n\t\tc->use_http_path = git_config_bool(var, value);\n\n\treturn 0;\n}\n\nstatic int proto_is_http(const char *s)\n{\n\tif (!s)\n\t\treturn 0;\n\treturn !strcmp(s, \"https\") || !strcmp(s, \"http\");\n}\n\nstatic void credential_describe(struct credential *c, struct strbuf *out);\nstatic void credential_format(struct credential *c, struct strbuf *out);\n\nstatic int select_all(const struct urlmatch_item *a,\n\t\t      const struct urlmatch_item *b)\n{\n\treturn 0;\n}\n\nstatic int match_partial_url(const char *url, void *cb)\n{\n\tstruct credential *c = cb;\n\tstruct credential want = CREDENTIAL_INIT;\n\tint matches = 0;\n\n\tif (credential_from_potentially_partial_url(&want, url) < 0)\n\t\twarning(_(\"skipping credential lookup for key: credential.%s\"),\n\t\t\turl);\n\telse\n\t\tmatches = credential_match(&want, c);\n\tcredential_clear(&want);\n\n\treturn matches;\n}\n\nstatic void credential_apply_config(struct credential *c)\n{\n\tchar *normalized_url;\n\tstruct urlmatch_config config = { STRING_LIST_INIT_DUP };\n\tstruct strbuf url = STRBUF_INIT;\n\n\tif (!c->host)\n\t\tdie(_(\"refusing to work with credential missing host field\"));\n\tif (!c->protocol)\n\t\tdie(_(\"refusing to work with credential missing protocol field\"));\n\n\tif (c->configured)\n\t\treturn;\n\n\tconfig.section = \"credential\";\n\tconfig.key = NULL;\n\tconfig.collect_fn = credential_config_callback;\n\tconfig.cascade_fn = NULL;\n\tconfig.select_fn = select_all;\n\tconfig.fallback_match_fn = match_partial_url;\n\tconfig.cb = c;\n\n\tcredential_format(c, &url);\n\tnormalized_url = url_normalize(url.buf, &config.url);\n\n\tgit_config(urlmatch_config_entry, &config);\n\tstring_list_clear(&config.vars, 1);\n\tfree(normalized_url);\n\tstrbuf_release(&url);\n\n\tc->configured = 1;\n\n\tif (!c->use_http_path && proto_is_http(c->protocol)) {\n\t\tFREE_AND_NULL(c->path);\n\t}\n}\n\nstatic void credential_describe(struct credential *c, struct strbuf *out)\n{\n\tif (!c->protocol)\n\t\treturn;\n\tstrbuf_addf(out, \"%s://\", c->protocol);\n\tif (c->username && *c->username)\n\t\tstrbuf_addf(out, \"%s@\", c->username);\n\tif (c->host)\n\t\tstrbuf_addstr(out, c->host);\n\tif (c->path)\n\t\tstrbuf_addf(out, \"/%s\", c->path);\n}\n\nstatic void credential_format(struct credential *c, struct strbuf *out)\n{\n\tif (!c->protocol)\n\t\treturn;\n\tstrbuf_addf(out, \"%s://\", c->protocol);\n\tif (c->username && *c->username) {\n\t\tstrbuf_add_percentencode(out, c->username, STRBUF_ENCODE_SLASH);\n\t\tstrbuf_addch(out, '@');\n\t}\n\tif (c->host)\n\t\tstrbuf_addstr(out, c->host);\n\tif (c->path) {\n\t\tstrbuf_addch(out, '/');\n\t\tstrbuf_add_percentencode(out, c->path, 0);\n\t}\n}\n\nstatic char *credential_ask_one(const char *what, struct credential *c,\n\t\t\t\tint flags)\n{\n\tstruct strbuf desc = STRBUF_INIT;\n\tstruct strbuf prompt = STRBUF_INIT;\n\tchar *r;\n\n\tcredential_describe(c, &desc);\n\tif (desc.len)\n\t\tstrbuf_addf(&prompt, \"%s for '%s': \", what, desc.buf);\n\telse\n\t\tstrbuf_addf(&prompt, \"%s: \", what);\n\n\tr = git_prompt(prompt.buf, flags);\n\n\tstrbuf_release(&desc);\n\tstrbuf_release(&prompt);\n\treturn xstrdup(r);\n}\n\nstatic void credential_getpass(struct credential *c)\n{\n\tif (!c->username)\n\t\tc->username = credential_ask_one(\"Username\", c,\n\t\t\t\t\t\t PROMPT_ASKPASS|PROMPT_ECHO);\n\tif (!c->password)\n\t\tc->password = credential_ask_one(\"Password\", c,\n\t\t\t\t\t\t PROMPT_ASKPASS);\n}\n\nint credential_read(struct credential *c, FILE *fp)\n{\n\tstruct strbuf line = STRBUF_INIT;\n\n\twhile (strbuf_getline(&line, fp) != EOF) {\n\t\tchar *key = line.buf;\n\t\tchar *value = strchr(key, '=');\n\n\t\tif (!line.len)\n\t\t\tbreak;\n\n\t\tif (!value) {\n\t\t\twarning(\"invalid credential line: %s\", key);\n\t\t\tstrbuf_release(&line);\n\t\t\treturn -1;\n\t\t}\n\t\t*value++ = '\\0';\n\n\t\tif (!strcmp(key, \"username\")) {\n\t\t\tfree(c->username);\n\t\t\tc->username = xstrdup(value);\n\t\t\tc->username_from_proto = 1;\n\t\t} else if (!strcmp(key, \"password\")) {\n\t\t\tfree(c->password);\n\t\t\tc->password = xstrdup(value);\n\t\t} else if (!strcmp(key, \"protocol\")) {\n\t\t\tfree(c->protocol);\n\t\t\tc->protocol = xstrdup(value);\n\t\t} else if (!strcmp(key, \"host\")) {\n\t\t\tfree(c->host);\n\t\t\tc->host = xstrdup(value);\n\t\t} else if (!strcmp(key, \"path\")) {\n\t\t\tfree(c->path);\n\t\t\tc->path = xstrdup(value);\n\t\t} else if (!strcmp(key, \"url\")) {\n\t\t\tcredential_from_url(c, value);\n\t\t} else if (!strcmp(key, \"quit\")) {\n\t\t\tc->quit = !!git_config_bool(\"quit\", value);\n\t\t}\n\t\t/*\n\t\t * Ignore other lines; we don't know what they mean, but\n\t\t * this future-proofs us when later versions of git do\n\t\t * learn new lines, and the helpers are updated to match.\n\t\t */\n\t}\n\n\tstrbuf_release(&line);\n\treturn 0;\n}\n\nstatic void credential_write_item(FILE *fp, const char *key, const char *value,\n\t\t\t\t  int required)\n{\n\tif (!value && required)\n\t\tBUG(\"credential value for %s is missing\", key);\n\tif (!value)\n\t\treturn;\n\tif (strchr(value, '\\n'))\n\t\tdie(\"credential value for %s contains newline\", key);\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}\n\nvoid credential_write(const struct credential *c, FILE *fp)\n{\n\tcredential_write_item(fp, \"protocol\", c->protocol, 1);\n\tcredential_write_item(fp, \"host\", c->host, 1);\n\tcredential_write_item(fp, \"path\", c->path, 0);\n\tcredential_write_item(fp, \"username\", c->username, 0);\n\tcredential_write_item(fp, \"password\", c->password, 0);\n}\n\nstatic int run_credential_helper(struct credential *c,\n\t\t\t\t const char *cmd,\n\t\t\t\t int want_output)\n{\n\tstruct child_process helper = CHILD_PROCESS_INIT;\n\tFILE *fp;\n\n\tstrvec_push(&helper.args, cmd);\n\thelper.use_shell = 1;\n\thelper.in = -1;\n\tif (want_output)\n\t\thelper.out = -1;\n\telse\n\t\thelper.no_stdout = 1;\n\n\tif (start_command(&helper) < 0)\n\t\treturn -1;\n\n\tfp = xfdopen(helper.in, \"w\");\n\tsigchain_push(SIGPIPE, SIG_IGN);\n\tcredential_write(c, fp);\n\tfclose(fp);\n\tsigchain_pop(SIGPIPE);\n\n\tif (want_output) {\n\t\tint r;\n\t\tfp = xfdopen(helper.out, \"r\");\n\t\tr = credential_read(c, fp);\n\t\tfclose(fp);\n\t\tif (r < 0) {\n\t\t\tfinish_command(&helper);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (finish_command(&helper))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int credential_do(struct credential *c, const char *helper,\n\t\t\t const char *operation)\n{\n\tstruct strbuf cmd = STRBUF_INIT;\n\tint r;\n\n\tif (helper[0] == '!')\n\t\tstrbuf_addstr(&cmd, helper + 1);\n\telse if (is_absolute_path(helper))\n\t\tstrbuf_addstr(&cmd, helper);\n\telse\n\t\tstrbuf_addf(&cmd, \"git credential-%s\", helper);\n\n\tstrbuf_addf(&cmd, \" %s\", operation);\n\tr = run_credential_helper(c, cmd.buf, !strcmp(operation, \"get\"));\n\n\tstrbuf_release(&cmd);\n\treturn r;\n}\n\nvoid credential_fill(struct credential *c)\n{\n\tint i;\n\n\tif (c->username && c->password)\n\t\treturn;\n\n\tcredential_apply_config(c);\n\n\tfor (i = 0; i < c->helpers.nr; i++) {\n\t\tcredential_do(c, c->helpers.items[i].string, \"get\");\n\t\tif (c->username && c->password)\n\t\t\treturn;\n\t\tif (c->quit)\n\t\t\tdie(\"credential helper '%s' told us to quit\",\n\t\t\t    c->helpers.items[i].string);\n\t}\n\n\tcredential_getpass(c);\n\tif (!c->username && !c->password)\n\t\tdie(\"unable to get password from user\");\n}\n\nvoid credential_approve(struct credential *c)\n{\n\tint i;\n\n\tif (c->approved)\n\t\treturn;\n\tif (!c->username || !c->password)\n\t\treturn;\n\n\tcredential_apply_config(c);\n\n\tfor (i = 0; i < c->helpers.nr; i++)\n\t\tcredential_do(c, c->helpers.items[i].string, \"store\");\n\tc->approved = 1;\n}\n\nvoid credential_reject(struct credential *c)\n{\n\tint i;\n\n\tcredential_apply_config(c);\n\n\tfor (i = 0; i < c->helpers.nr; i++)\n\t\tcredential_do(c, c->helpers.items[i].string, \"erase\");\n\n\tFREE_AND_NULL(c->username);\n\tFREE_AND_NULL(c->password);\n\tc->approved = 0;\n}\n\nstatic int check_url_component(const char *url, int quiet,\n\t\t\t       const char *name, const char *value)\n{\n\tif (!value)\n\t\treturn 0;\n\tif (!strchr(value, '\\n'))\n\t\treturn 0;\n\n\tif (!quiet)\n\t\twarning(_(\"url contains a newline in its %s component: %s\"),\n\t\t\tname, url);\n\treturn -1;\n}\n\n/*\n * Potentially-partial URLs can, but do not have to, contain\n *\n * - a protocol (or scheme) of the form \"<protocol>://\"\n *\n * - a host name (the part after the protocol and before the first slash after\n *   that, if any)\n *\n * - a user name and potentially a password (as \"<user>[:<password>]@\" part of\n *   the host name)\n *\n * - a path (the part after the host name, if any, starting with the slash)\n *\n * Missing parts will be left unset in `struct credential`. Thus, `https://`\n * will have only the `protocol` set, `example.com` only the host name, and\n * `/git` only the path.\n *\n * Note that an empty host name in an otherwise fully-qualified URL (e.g.\n * `cert:///path/to/cert.pem`) will be treated as unset if we expect the URL to\n * be potentially partial, and only then (otherwise, the empty string is used).\n *\n * The credential_from_url() function does not allow partial URLs.\n */\nstatic int credential_from_url_1(struct credential *c, const char *url,\n\t\t\t\t int allow_partial_url, int quiet)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\n\tcredential_clear(c);\n\n\t/*\n\t * Match one of:\n\t *   (1) proto://<host>/...\n\t *   (2) proto://<user>@<host>/...\n\t *   (3) proto://<user>:<pass>@<host>/...\n\t */\n\tproto_end = strstr(url, \"://\");\n\tif (!allow_partial_url && (!proto_end || proto_end == url)) {\n\t\tif (!quiet)\n\t\t\twarning(_(\"url has no scheme: %s\"), url);\n\t\treturn -1;\n\t}\n\tcp = proto_end ? proto_end + 3 : url;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\n\t/*\n\t * A query or fragment marker before the slash ends the host portion.\n\t * We'll just continue to call this \"slash\" for simplicity. Notably our\n\t * \"trim leading slashes\" part won't skip over this part of the path,\n\t * but that's what we'd want.\n\t */\n\tslash = cp + strcspn(cp, \"/?#\");\n\n\tif (!at || slash <= at) {\n\t\t/* Case (1) */\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\t/* Case (2) */\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\tif (c->username && *c->username)\n\t\t\tc->username_from_proto = 1;\n\t\thost = at + 1;\n\t} else {\n\t\t/* Case (3) */\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tif (c->username && *c->username)\n\t\t\tc->username_from_proto = 1;\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\n\tif (proto_end && proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tif (!allow_partial_url || slash - host > 0)\n\t\tc->host = url_decode_mem(host, slash - host);\n\t/* Trim leading and trailing slashes from path */\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n\n\tif (check_url_component(url, quiet, \"username\", c->username) < 0 ||\n\t    check_url_component(url, quiet, \"password\", c->password) < 0 ||\n\t    check_url_component(url, quiet, \"protocol\", c->protocol) < 0 ||\n\t    check_url_component(url, quiet, \"host\", c->host) < 0 ||\n\t    check_url_component(url, quiet, \"path\", c->path) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int credential_from_potentially_partial_url(struct credential *c,\n\t\t\t\t\t\t   const char *url)\n{\n\treturn credential_from_url_1(c, url, 1, 0);\n}\n\nint credential_from_url_gently(struct credential *c, const char *url, int quiet)\n{\n\treturn credential_from_url_1(c, url, 0, quiet);\n}\n\nvoid credential_from_url(struct credential *c, const char *url)\n{\n\tif (credential_from_url_gently(c, url, 0) < 0)\n\t\tdie(_(\"credential url cannot be parsed: %s\"), url);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "000ac7a8d430e4d14472c068b9817e1fc8ee69bd",
  "sha1_ok": true,
  "size": 12411
}
