{
  "content": {
    "base64": "I2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImFic3BhdGguaCIKI2luY2x1ZGUgImNvbmZpZy5oIgojaW5jbHVkZSAiY29sb3IuaCIKI2luY2x1ZGUgImVkaXRvci5oIgojaW5jbHVkZSAiZW52aXJvbm1lbnQuaCIKI2luY2x1ZGUgInJlcG9zaXRvcnkuaCIKI2luY2x1ZGUgImdldHRleHQuaCIKI2luY2x1ZGUgImlkZW50LmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCiNpbmNsdWRlICJ1cmxtYXRjaC5oIgojaW5jbHVkZSAicGF0aC5oIgojaW5jbHVkZSAicXVvdGUuaCIKI2luY2x1ZGUgInNldHVwLmgiCiNpbmNsdWRlICJzdHJidWYuaCIKI2luY2x1ZGUgIndvcmt0cmVlLmgiCgpzdGF0aWMgY29uc3QgY2hhciAqY29uc3QgYnVpbHRpbl9jb25maWdfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgY29uZmlnIFs8b3B0aW9ucz5dIiksCglOVUxMCn07CgpzdGF0aWMgY2hhciAqa2V5OwpzdGF0aWMgcmVnZXhfdCAqa2V5X3JlZ2V4cDsKc3RhdGljIGNvbnN0IGNoYXIgKnZhbHVlX3BhdHRlcm47CnN0YXRpYyByZWdleF90ICpyZWdleHA7CnN0YXRpYyBpbnQgc2hvd19rZXlzOwpzdGF0aWMgaW50IG9taXRfdmFsdWVzOwpzdGF0aWMgaW50IHVzZV9rZXlfcmVnZXhwOwpzdGF0aWMgaW50IGRvX2FsbDsKc3RhdGljIGludCBkb19ub3RfbWF0Y2g7CnN0YXRpYyBjaGFyIGRlbGltID0gJz0nOwpzdGF0aWMgY2hhciBrZXlfZGVsaW0gPSAnICc7CnN0YXRpYyBjaGFyIHRlcm0gPSAnXG4nOwoKc3RhdGljIGludCB1c2VfZ2xvYmFsX2NvbmZpZywgdXNlX3N5c3RlbV9jb25maWcsIHVzZV9sb2NhbF9jb25maWc7CnN0YXRpYyBpbnQgdXNlX3dvcmt0cmVlX2NvbmZpZzsKc3RhdGljIHN0cnVjdCBnaXRfY29uZmlnX3NvdXJjZSBnaXZlbl9jb25maWdfc291cmNlOwpzdGF0aWMgaW50IGFjdGlvbnMsIHR5cGU7CnN0YXRpYyBjaGFyICpkZWZhdWx0X3ZhbHVlOwpzdGF0aWMgaW50IGVuZF9udWw7CnN0YXRpYyBpbnQgcmVzcGVjdF9pbmNsdWRlc19vcHQgPSAtMTsKc3RhdGljIHN0cnVjdCBjb25maWdfb3B0aW9ucyBjb25maWdfb3B0aW9uczsKc3RhdGljIGludCBzaG93X29yaWdpbjsKc3RhdGljIGludCBzaG93X3Njb3BlOwpzdGF0aWMgaW50IGZpeGVkX3ZhbHVlOwpzdGF0aWMgY29uc3QgY2hhciAqY29tbWVudDsKCiNkZWZpbmUgQUNUSU9OX0dFVCAoMTw8MCkKI2RlZmluZSBBQ1RJT05fR0VUX0FMTCAoMTw8MSkKI2RlZmluZSBBQ1RJT05fR0VUX1JFR0VYUCAoMTw8MikKI2RlZmluZSBBQ1RJT05fUkVQTEFDRV9BTEwgKDE8PDMpCiNkZWZpbmUgQUNUSU9OX0FERCAoMTw8NCkKI2RlZmluZSBBQ1RJT05fVU5TRVQgKDE8PDUpCiNkZWZpbmUgQUNUSU9OX1VOU0VUX0FMTCAoMTw8NikKI2RlZmluZSBBQ1RJT05fUkVOQU1FX1NFQ1RJT04gKDE8PDcpCiNkZWZpbmUgQUNUSU9OX1JFTU9WRV9TRUNUSU9OICgxPDw4KQojZGVmaW5lIEFDVElPTl9MSVNUICgxPDw5KQojZGVmaW5lIEFDVElPTl9FRElUICgxPDwxMCkKI2RlZmluZSBBQ1RJT05fU0VUICgxPDwxMSkKI2RlZmluZSBBQ1RJT05fU0VUX0FMTCAoMTw8MTIpCiNkZWZpbmUgQUNUSU9OX0dFVF9DT0xPUiAoMTw8MTMpCiNkZWZpbmUgQUNUSU9OX0dFVF9DT0xPUkJPT0wgKDE8PDE0KQojZGVmaW5lIEFDVElPTl9HRVRfVVJMTUFUQ0ggKDE8PDE1KQoKLyoKICogVGhlIGFjdGlvbnMgIkFDVElPTl9MSVNUIHwgQUNUSU9OX0dFVF8qIiB3aGljaCBtYXkgcHJvZHVjZSBtb3JlIHRoYW4KICogb25lIGxpbmUgb2Ygb3V0cHV0IGFuZCB3aGljaCBzaG91bGQgdGhlcmVmb3JlIGJlIHBhZ2VkLgogKi8KI2RlZmluZSBQQUdJTkdfQUNUSU9OUyAoQUNUSU9OX0xJU1QgfCBBQ1RJT05fR0VUX0FMTCB8IFwKCQkJQUNUSU9OX0dFVF9SRUdFWFAgfCBBQ1RJT05fR0VUX1VSTE1BVENIKQoKI2RlZmluZSBUWVBFX0JPT0wJCTEKI2RlZmluZSBUWVBFX0lOVAkJMgojZGVmaW5lIFRZUEVfQk9PTF9PUl9JTlQJMwojZGVmaW5lIFRZUEVfUEFUSAkJNAojZGVmaW5lIFRZUEVfRVhQSVJZX0RBVEUJNQojZGVmaW5lIFRZUEVfQ09MT1IJCTYKI2RlZmluZSBUWVBFX0JPT0xfT1JfU1RSCTcKCiNkZWZpbmUgT1BUX0NBTExCQUNLX1ZBTFVFKHMsIGwsIHYsIGgsIGkpIFwKCXsgT1BUSU9OX0NBTExCQUNLLCAocyksIChsKSwgKHYpLCBOVUxMLCAoaCksIFBBUlNFX09QVF9OT0FSRyB8IFwKCVBBUlNFX09QVF9OT05FRywgb3B0aW9uX3BhcnNlX3R5cGUsIChpKSB9CgpzdGF0aWMgTk9SRVRVUk4gdm9pZCB1c2FnZV9idWlsdGluX2NvbmZpZyh2b2lkKTsKCnN0YXRpYyBpbnQgb3B0aW9uX3BhcnNlX3R5cGUoY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsCgkJCSAgICAgaW50IHVuc2V0KQp7CglpbnQgbmV3X3R5cGUsICp0b190eXBlOwoKCWlmICh1bnNldCkgewoJCSooKGludCAqKSBvcHQtPnZhbHVlKSA9IDA7CgkJcmV0dXJuIDA7Cgl9CgoJLyoKCSAqIFRvIHN1cHBvcnQgJy0tPHR5cGU+JyBzdHlsZSBmbGFncywgYmVnaW4gd2l0aCBuZXdfdHlwZSBlcXVhbCB0bwoJICogb3B0LT5kZWZ2YWwuCgkgKi8KCW5ld190eXBlID0gb3B0LT5kZWZ2YWw7CglpZiAoIW5ld190eXBlKSB7CgkJaWYgKCFzdHJjbXAoYXJnLCAiYm9vbCIpKQoJCQluZXdfdHlwZSA9IFRZUEVfQk9PTDsKCQllbHNlIGlmICghc3RyY21wKGFyZywgImludCIpKQoJCQluZXdfdHlwZSA9IFRZUEVfSU5UOwoJCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiYm9vbC1vci1pbnQiKSkKCQkJbmV3X3R5cGUgPSBUWVBFX0JPT0xfT1JfSU5UOwoJCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiYm9vbC1vci1zdHIiKSkKCQkJbmV3X3R5cGUgPSBUWVBFX0JPT0xfT1JfU1RSOwoJCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAicGF0aCIpKQoJCQluZXdfdHlwZSA9IFRZUEVfUEFUSDsKCQllbHNlIGlmICghc3RyY21wKGFyZywgImV4cGlyeS1kYXRlIikpCgkJCW5ld190eXBlID0gVFlQRV9FWFBJUllfREFURTsKCQllbHNlIGlmICghc3RyY21wKGFyZywgImNvbG9yIikpCgkJCW5ld190eXBlID0gVFlQRV9DT0xPUjsKCQllbHNlCgkJCWRpZShfKCJ1bnJlY29nbml6ZWQgLS10eXBlIGFyZ3VtZW50LCAlcyIpLCBhcmcpOwoJfQoKCXRvX3R5cGUgPSBvcHQtPnZhbHVlOwoJaWYgKCp0b190eXBlICYmICp0b190eXBlICE9IG5ld190eXBlKSB7CgkJLyoKCQkgKiBDb21wbGFpbiB3aGVuIHRoZXJlIGlzIGEgbmV3IHR5cGUgbm90IGVxdWFsIHRvIHRoZSBvbGQgdHlwZS4KCQkgKiBUaGlzIGFsbG93cyBmb3IgY29tYmluYXRpb25zIGxpa2UgJy0taW50IC0tdHlwZT1pbnQnIGFuZAoJCSAqICctLXR5cGU9aW50IC0tdHlwZT1pbnQnLCBidXQgZGlzYWxsb3dzIG9uZXMgbGlrZSAnLS10eXBlPWJvb2wKCQkgKiAtLWludCcgYW5kICctLXR5cGU9Ym9vbAoJCSAqIC0tdHlwZT1pbnQnLgoJCSAqLwoJCWVycm9yKF8oIm9ubHkgb25lIHR5cGUgYXQgYSB0aW1lIikpOwoJCXVzYWdlX2J1aWx0aW5fY29uZmlnKCk7Cgl9CgkqdG9fdHlwZSA9IG5ld190eXBlOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgc3RydWN0IG9wdGlvbiBidWlsdGluX2NvbmZpZ19vcHRpb25zW10gPSB7CglPUFRfR1JPVVAoTl8oIkNvbmZpZyBmaWxlIGxvY2F0aW9uIikpLAoJT1BUX0JPT0woMCwgImdsb2JhbCIsICZ1c2VfZ2xvYmFsX2NvbmZpZywgTl8oInVzZSBnbG9iYWwgY29uZmlnIGZpbGUiKSksCglPUFRfQk9PTCgwLCAic3lzdGVtIiwgJnVzZV9zeXN0ZW1fY29uZmlnLCBOXygidXNlIHN5c3RlbSBjb25maWcgZmlsZSIpKSwKCU9QVF9CT09MKDAsICJsb2NhbCIsICZ1c2VfbG9jYWxfY29uZmlnLCBOXygidXNlIHJlcG9zaXRvcnkgY29uZmlnIGZpbGUiKSksCglPUFRfQk9PTCgwLCAid29ya3RyZWUiLCAmdXNlX3dvcmt0cmVlX2NvbmZpZywgTl8oInVzZSBwZXItd29ya3RyZWUgY29uZmlnIGZpbGUiKSksCglPUFRfU1RSSU5HKCdmJywgImZpbGUiLCAmZ2l2ZW5fY29uZmlnX3NvdXJjZS5maWxlLCBOXygiZmlsZSIpLCBOXygidXNlIGdpdmVuIGNvbmZpZyBmaWxlIikpLAoJT1BUX1NUUklORygwLCAiYmxvYiIsICZnaXZlbl9jb25maWdfc291cmNlLmJsb2IsIE5fKCJibG9iLWlkIiksIE5fKCJyZWFkIGNvbmZpZyBmcm9tIGdpdmVuIGJsb2Igb2JqZWN0IikpLAoJT1BUX0dST1VQKE5fKCJBY3Rpb24iKSksCglPUFRfQklUKDAsICJnZXQiLCAmYWN0aW9ucywgTl8oImdldCB2YWx1ZTogbmFtZSBbdmFsdWUtcGF0dGVybl0iKSwgQUNUSU9OX0dFVCksCglPUFRfQklUKDAsICJnZXQtYWxsIiwgJmFjdGlvbnMsIE5fKCJnZXQgYWxsIHZhbHVlczoga2V5IFt2YWx1ZS1wYXR0ZXJuXSIpLCBBQ1RJT05fR0VUX0FMTCksCglPUFRfQklUKDAsICJnZXQtcmVnZXhwIiwgJmFjdGlvbnMsIE5fKCJnZXQgdmFsdWVzIGZvciByZWdleHA6IG5hbWUtcmVnZXggW3ZhbHVlLXBhdHRlcm5dIiksIEFDVElPTl9HRVRfUkVHRVhQKSwKCU9QVF9CSVQoMCwgImdldC11cmxtYXRjaCIsICZhY3Rpb25zLCBOXygiZ2V0IHZhbHVlIHNwZWNpZmljIGZvciB0aGUgVVJMOiBzZWN0aW9uWy52YXJdIFVSTCIpLCBBQ1RJT05fR0VUX1VSTE1BVENIKSwKCU9QVF9CSVQoMCwgInJlcGxhY2UtYWxsIiwgJmFjdGlvbnMsIE5fKCJyZXBsYWNlIGFsbCBtYXRjaGluZyB2YXJpYWJsZXM6IG5hbWUgdmFsdWUgW3ZhbHVlLXBhdHRlcm5dIiksIEFDVElPTl9SRVBMQUNFX0FMTCksCglPUFRfQklUKDAsICJhZGQiLCAmYWN0aW9ucywgTl8oImFkZCBhIG5ldyB2YXJpYWJsZTogbmFtZSB2YWx1ZSIpLCBBQ1RJT05fQUREKSwKCU9QVF9CSVQoMCwgInVuc2V0IiwgJmFjdGlvbnMsIE5fKCJyZW1vdmUgYSB2YXJpYWJsZTogbmFtZSBbdmFsdWUtcGF0dGVybl0iKSwgQUNUSU9OX1VOU0VUKSwKCU9QVF9CSVQoMCwgInVuc2V0LWFsbCIsICZhY3Rpb25zLCBOXygicmVtb3ZlIGFsbCBtYXRjaGVzOiBuYW1lIFt2YWx1ZS1wYXR0ZXJuXSIpLCBBQ1RJT05fVU5TRVRfQUxMKSwKCU9QVF9CSVQoMCwgInJlbmFtZS1zZWN0aW9uIiwgJmFjdGlvbnMsIE5fKCJyZW5hbWUgc2VjdGlvbjogb2xkLW5hbWUgbmV3LW5hbWUiKSwgQUNUSU9OX1JFTkFNRV9TRUNUSU9OKSwKCU9QVF9CSVQoMCwgInJlbW92ZS1zZWN0aW9uIiwgJmFjdGlvbnMsIE5fKCJyZW1vdmUgYSBzZWN0aW9uOiBuYW1lIiksIEFDVElPTl9SRU1PVkVfU0VDVElPTiksCglPUFRfQklUKCdsJywgImxpc3QiLCAmYWN0aW9ucywgTl8oImxpc3QgYWxsIiksIEFDVElPTl9MSVNUKSwKCU9QVF9CT09MKDAsICJmaXhlZC12YWx1ZSIsICZmaXhlZF92YWx1ZSwgTl8oInVzZSBzdHJpbmcgZXF1YWxpdHkgd2hlbiBjb21wYXJpbmcgdmFsdWVzIHRvICd2YWx1ZS1wYXR0ZXJuJyIpKSwKCU9QVF9CSVQoJ2UnLCAiZWRpdCIsICZhY3Rpb25zLCBOXygib3BlbiBhbiBlZGl0b3IiKSwgQUNUSU9OX0VESVQpLAoJT1BUX0JJVCgwLCAiZ2V0LWNvbG9yIiwgJmFjdGlvbnMsIE5fKCJmaW5kIHRoZSBjb2xvciBjb25maWd1cmVkOiBzbG90IFtkZWZhdWx0XSIpLCBBQ1RJT05fR0VUX0NPTE9SKSwKCU9QVF9CSVQoMCwgImdldC1jb2xvcmJvb2wiLCAmYWN0aW9ucywgTl8oImZpbmQgdGhlIGNvbG9yIHNldHRpbmc6IHNsb3QgW3N0ZG91dC1pcy10dHldIiksIEFDVElPTl9HRVRfQ09MT1JCT09MKSwKCU9QVF9HUk9VUChOXygiVHlwZSIpKSwKCU9QVF9DQUxMQkFDSygndCcsICJ0eXBlIiwgJnR5cGUsIE5fKCJ0eXBlIiksIE5fKCJ2YWx1ZSBpcyBnaXZlbiB0aGlzIHR5cGUiKSwgb3B0aW9uX3BhcnNlX3R5cGUpLAoJT1BUX0NBTExCQUNLX1ZBTFVFKDAsICJib29sIiwgJnR5cGUsIE5fKCJ2YWx1ZSBpcyBcInRydWVcIiBvciBcImZhbHNlXCIiKSwgVFlQRV9CT09MKSwKCU9QVF9DQUxMQkFDS19WQUxVRSgwLCAiaW50IiwgJnR5cGUsIE5fKCJ2YWx1ZSBpcyBkZWNpbWFsIG51bWJlciIpLCBUWVBFX0lOVCksCglPUFRfQ0FMTEJBQ0tfVkFMVUUoMCwgImJvb2wtb3ItaW50IiwgJnR5cGUsIE5fKCJ2YWx1ZSBpcyAtLWJvb2wgb3IgLS1pbnQiKSwgVFlQRV9CT09MX09SX0lOVCksCglPUFRfQ0FMTEJBQ0tfVkFMVUUoMCwgImJvb2wtb3Itc3RyIiwgJnR5cGUsIE5fKCJ2YWx1ZSBpcyAtLWJvb2wgb3Igc3RyaW5nIiksIFRZUEVfQk9PTF9PUl9TVFIpLAoJT1BUX0NBTExCQUNLX1ZBTFVFKDAsICJwYXRoIiwgJnR5cGUsIE5fKCJ2YWx1ZSBpcyBhIHBhdGggKGZpbGUgb3IgZGlyZWN0b3J5IG5hbWUpIiksIFRZUEVfUEFUSCksCglPUFRfQ0FMTEJBQ0tfVkFMVUUoMCwgImV4cGlyeS1kYXRlIiwgJnR5cGUsIE5fKCJ2YWx1ZSBpcyBhbiBleHBpcnkgZGF0ZSIpLCBUWVBFX0VYUElSWV9EQVRFKSwKCU9QVF9HUk9VUChOXygiT3RoZXIiKSksCglPUFRfQk9PTCgneicsICJudWxsIiwgJmVuZF9udWwsIE5fKCJ0ZXJtaW5hdGUgdmFsdWVzIHdpdGggTlVMIGJ5dGUiKSksCglPUFRfQk9PTCgwLCAibmFtZS1vbmx5IiwgJm9taXRfdmFsdWVzLCBOXygic2hvdyB2YXJpYWJsZSBuYW1lcyBvbmx5IikpLAoJT1BUX0JPT0woMCwgImluY2x1ZGVzIiwgJnJlc3BlY3RfaW5jbHVkZXNfb3B0LCBOXygicmVzcGVjdCBpbmNsdWRlIGRpcmVjdGl2ZXMgb24gbG9va3VwIikpLAoJT1BUX0JPT0woMCwgInNob3ctb3JpZ2luIiwgJnNob3dfb3JpZ2luLCBOXygic2hvdyBvcmlnaW4gb2YgY29uZmlnIChmaWxlLCBzdGFuZGFyZCBpbnB1dCwgYmxvYiwgY29tbWFuZCBsaW5lKSIpKSwKCU9QVF9CT09MKDAsICJzaG93LXNjb3BlIiwgJnNob3dfc2NvcGUsIE5fKCJzaG93IHNjb3BlIG9mIGNvbmZpZyAod29ya3RyZWUsIGxvY2FsLCBnbG9iYWwsIHN5c3RlbSwgY29tbWFuZCkiKSksCglPUFRfU1RSSU5HKDAsICJkZWZhdWx0IiwgJmRlZmF1bHRfdmFsdWUsIE5fKCJ2YWx1ZSIpLCBOXygid2l0aCAtLWdldCwgdXNlIGRlZmF1bHQgdmFsdWUgd2hlbiBtaXNzaW5nIGVudHJ5IikpLAoJT1BUX1NUUklORygwLCAiY29tbWVudCIsICZjb21tZW50LCBOXygidmFsdWUiKSwgTl8oImh1bWFuLXJlYWRhYmxlIGNvbW1lbnQgc3RyaW5nICgjIHdpbGwgYmUgcHJlcGVuZGVkIGFzIG5lZWRlZCkiKSksCglPUFRfRU5EKCksCn07CgpzdGF0aWMgTk9SRVRVUk4gdm9pZCB1c2FnZV9idWlsdGluX2NvbmZpZyh2b2lkKQp7Cgl1c2FnZV93aXRoX29wdGlvbnMoYnVpbHRpbl9jb25maWdfdXNhZ2UsIGJ1aWx0aW5fY29uZmlnX29wdGlvbnMpOwp9CgpzdGF0aWMgdm9pZCBjaGVja19hcmdjKGludCBhcmdjLCBpbnQgbWluLCBpbnQgbWF4KQp7CglpZiAoYXJnYyA+PSBtaW4gJiYgYXJnYyA8PSBtYXgpCgkJcmV0dXJuOwoJaWYgKG1pbiA9PSBtYXgpCgkJZXJyb3IoXygid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cywgc2hvdWxkIGJlICVkIiksIG1pbik7CgllbHNlCgkJZXJyb3IoXygid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cywgc2hvdWxkIGJlIGZyb20gJWQgdG8gJWQiKSwKCQkgICAgICBtaW4sIG1heCk7Cgl1c2FnZV9idWlsdGluX2NvbmZpZygpOwp9CgpzdGF0aWMgdm9pZCBzaG93X2NvbmZpZ19vcmlnaW4oY29uc3Qgc3RydWN0IGtleV92YWx1ZV9pbmZvICprdmksCgkJCSAgICAgICBzdHJ1Y3Qgc3RyYnVmICpidWYpCnsKCWNvbnN0IGNoYXIgdGVybSA9IGVuZF9udWwgPyAnXDAnIDogJ1x0JzsKCglzdHJidWZfYWRkc3RyKGJ1ZiwgY29uZmlnX29yaWdpbl90eXBlX25hbWUoa3ZpLT5vcmlnaW5fdHlwZSkpOwoJc3RyYnVmX2FkZGNoKGJ1ZiwgJzonKTsKCWlmIChlbmRfbnVsKQoJCXN0cmJ1Zl9hZGRzdHIoYnVmLCBrdmktPmZpbGVuYW1lID8ga3ZpLT5maWxlbmFtZSA6ICIiKTsKCWVsc2UKCQlxdW90ZV9jX3N0eWxlKGt2aS0+ZmlsZW5hbWUgPyBrdmktPmZpbGVuYW1lIDogIiIsIGJ1ZiwgTlVMTCwgMCk7CglzdHJidWZfYWRkY2goYnVmLCB0ZXJtKTsKfQoKc3RhdGljIHZvaWQgc2hvd19jb25maWdfc2NvcGUoY29uc3Qgc3RydWN0IGtleV92YWx1ZV9pbmZvICprdmksCgkJCSAgICAgIHN0cnVjdCBzdHJidWYgKmJ1ZikKewoJY29uc3QgY2hhciB0ZXJtID0gZW5kX251bCA/ICdcMCcgOiAnXHQnOwoJY29uc3QgY2hhciAqc2NvcGUgPSBjb25maWdfc2NvcGVfbmFtZShrdmktPnNjb3BlKTsKCglzdHJidWZfYWRkc3RyKGJ1ZiwgTl8oc2NvcGUpKTsKCXN0cmJ1Zl9hZGRjaChidWYsIHRlcm0pOwp9CgpzdGF0aWMgaW50IHNob3dfYWxsX2NvbmZpZyhjb25zdCBjaGFyICprZXlfLCBjb25zdCBjaGFyICp2YWx1ZV8sCgkJCSAgIGNvbnN0IHN0cnVjdCBjb25maWdfY29udGV4dCAqY3R4LAoJCQkgICB2b2lkICpjYiBVTlVTRUQpCnsKCWNvbnN0IHN0cnVjdCBrZXlfdmFsdWVfaW5mbyAqa3ZpID0gY3R4LT5rdmk7CgoJaWYgKHNob3dfb3JpZ2luIHx8IHNob3dfc2NvcGUpIHsKCQlzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJCWlmIChzaG93X3Njb3BlKQoJCQlzaG93X2NvbmZpZ19zY29wZShrdmksICZidWYpOwoJCWlmIChzaG93X29yaWdpbikKCQkJc2hvd19jb25maWdfb3JpZ2luKGt2aSwgJmJ1Zik7CgkJLyogVXNlIGZ3cml0ZSBhcyAiYnVmIiBjYW4gY29udGFpbiBcMCdzIGlmICJlbmRfbnVsbCIgaXMgc2V0LiAqLwoJCWZ3cml0ZShidWYuYnVmLCAxLCBidWYubGVuLCBzdGRvdXQpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJfQoJaWYgKCFvbWl0X3ZhbHVlcyAmJiB2YWx1ZV8pCgkJcHJpbnRmKCIlcyVjJXMlYyIsIGtleV8sIGRlbGltLCB2YWx1ZV8sIHRlcm0pOwoJZWxzZQoJCXByaW50ZigiJXMlYyIsIGtleV8sIHRlcm0pOwoJcmV0dXJuIDA7Cn0KCnN0cnVjdCBzdHJidWZfbGlzdCB7CglzdHJ1Y3Qgc3RyYnVmICppdGVtczsKCWludCBucjsKCWludCBhbGxvYzsKfTsKCnN0YXRpYyBpbnQgZm9ybWF0X2NvbmZpZyhzdHJ1Y3Qgc3RyYnVmICpidWYsIGNvbnN0IGNoYXIgKmtleV8sCgkJCSBjb25zdCBjaGFyICp2YWx1ZV8sIGNvbnN0IHN0cnVjdCBrZXlfdmFsdWVfaW5mbyAqa3ZpKQp7CglpZiAoc2hvd19zY29wZSkKCQlzaG93X2NvbmZpZ19zY29wZShrdmksIGJ1Zik7CglpZiAoc2hvd19vcmlnaW4pCgkJc2hvd19jb25maWdfb3JpZ2luKGt2aSwgYnVmKTsKCWlmIChzaG93X2tleXMpCgkJc3RyYnVmX2FkZHN0cihidWYsIGtleV8pOwoJaWYgKCFvbWl0X3ZhbHVlcykgewoJCWlmIChzaG93X2tleXMpCgkJCXN0cmJ1Zl9hZGRjaChidWYsIGtleV9kZWxpbSk7CgoJCWlmICh0eXBlID09IFRZUEVfSU5UKQoJCQlzdHJidWZfYWRkZihidWYsICIlIlBSSWQ2NCwKCQkJCSAgICBnaXRfY29uZmlnX2ludDY0KGtleV8sIHZhbHVlXyA/IHZhbHVlXyA6ICIiLCBrdmkpKTsKCQllbHNlIGlmICh0eXBlID09IFRZUEVfQk9PTCkKCQkJc3RyYnVmX2FkZHN0cihidWYsIGdpdF9jb25maWdfYm9vbChrZXlfLCB2YWx1ZV8pID8KCQkJCSAgICAgICJ0cnVlIiA6ICJmYWxzZSIpOwoJCWVsc2UgaWYgKHR5cGUgPT0gVFlQRV9CT09MX09SX0lOVCkgewoJCQlpbnQgaXNfYm9vbCwgdjsKCQkJdiA9IGdpdF9jb25maWdfYm9vbF9vcl9pbnQoa2V5XywgdmFsdWVfLCBrdmksCgkJCQkJCSAgICZpc19ib29sKTsKCQkJaWYgKGlzX2Jvb2wpCgkJCQlzdHJidWZfYWRkc3RyKGJ1ZiwgdiA/ICJ0cnVlIiA6ICJmYWxzZSIpOwoJCQllbHNlCgkJCQlzdHJidWZfYWRkZihidWYsICIlZCIsIHYpOwoJCX0gZWxzZSBpZiAodHlwZSA9PSBUWVBFX0JPT0xfT1JfU1RSKSB7CgkJCWludCB2ID0gZ2l0X3BhcnNlX21heWJlX2Jvb2wodmFsdWVfKTsKCQkJaWYgKHYgPCAwKQoJCQkJc3RyYnVmX2FkZHN0cihidWYsIHZhbHVlXyk7CgkJCWVsc2UKCQkJCXN0cmJ1Zl9hZGRzdHIoYnVmLCB2ID8gInRydWUiIDogImZhbHNlIik7CgkJfSBlbHNlIGlmICh0eXBlID09IFRZUEVfUEFUSCkgewoJCQljb25zdCBjaGFyICp2OwoJCQlpZiAoZ2l0X2NvbmZpZ19wYXRobmFtZSgmdiwga2V5XywgdmFsdWVfKSA8IDApCgkJCQlyZXR1cm4gLTE7CgkJCXN0cmJ1Zl9hZGRzdHIoYnVmLCB2KTsKCQkJZnJlZSgoY2hhciAqKXYpOwoJCX0gZWxzZSBpZiAodHlwZSA9PSBUWVBFX0VYUElSWV9EQVRFKSB7CgkJCXRpbWVzdGFtcF90IHQ7CgkJCWlmIChnaXRfY29uZmlnX2V4cGlyeV9kYXRlKCZ0LCBrZXlfLCB2YWx1ZV8pIDwgMCkKCQkJCXJldHVybiAtMTsKCQkJc3RyYnVmX2FkZGYoYnVmLCAiJSJQUkl0aW1lLCB0KTsKCQl9IGVsc2UgaWYgKHR5cGUgPT0gVFlQRV9DT0xPUikgewoJCQljaGFyIHZbQ09MT1JfTUFYTEVOXTsKCQkJaWYgKGdpdF9jb25maWdfY29sb3Iodiwga2V5XywgdmFsdWVfKSA8IDApCgkJCQlyZXR1cm4gLTE7CgkJCXN0cmJ1Zl9hZGRzdHIoYnVmLCB2KTsKCQl9IGVsc2UgaWYgKHZhbHVlXykgewoJCQlzdHJidWZfYWRkc3RyKGJ1ZiwgdmFsdWVfKTsKCQl9IGVsc2UgewoJCQkvKiBKdXN0IHNob3cgdGhlIGtleSBuYW1lOyBiYWNrIG91dCBkZWxpbWl0ZXIgKi8KCQkJaWYgKHNob3dfa2V5cykKCQkJCXN0cmJ1Zl9zZXRsZW4oYnVmLCBidWYtPmxlbiAtIDEpOwoJCX0KCX0KCXN0cmJ1Zl9hZGRjaChidWYsIHRlcm0pOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgY29sbGVjdF9jb25maWcoY29uc3QgY2hhciAqa2V5XywgY29uc3QgY2hhciAqdmFsdWVfLAoJCQkgIGNvbnN0IHN0cnVjdCBjb25maWdfY29udGV4dCAqY3R4LCB2b2lkICpjYikKewoJc3RydWN0IHN0cmJ1Zl9saXN0ICp2YWx1ZXMgPSBjYjsKCWNvbnN0IHN0cnVjdCBrZXlfdmFsdWVfaW5mbyAqa3ZpID0gY3R4LT5rdmk7CgoJaWYgKCF1c2Vfa2V5X3JlZ2V4cCAmJiBzdHJjbXAoa2V5Xywga2V5KSkKCQlyZXR1cm4gMDsKCWlmICh1c2Vfa2V5X3JlZ2V4cCAmJiByZWdleGVjKGtleV9yZWdleHAsIGtleV8sIDAsIE5VTEwsIDApKQoJCXJldHVybiAwOwoJaWYgKGZpeGVkX3ZhbHVlICYmIHN0cmNtcCh2YWx1ZV9wYXR0ZXJuLCAodmFsdWVfP3ZhbHVlXzoiIikpKQoJCXJldHVybiAwOwoJaWYgKHJlZ2V4cCAhPSBOVUxMICYmCgkgICAgKGRvX25vdF9tYXRjaCBeICEhcmVnZXhlYyhyZWdleHAsICh2YWx1ZV8/dmFsdWVfOiIiKSwgMCwgTlVMTCwgMCkpKQoJCXJldHVybiAwOwoKCUFMTE9DX0dST1codmFsdWVzLT5pdGVtcywgdmFsdWVzLT5uciArIDEsIHZhbHVlcy0+YWxsb2MpOwoJc3RyYnVmX2luaXQoJnZhbHVlcy0+aXRlbXNbdmFsdWVzLT5ucl0sIDApOwoKCXJldHVybiBmb3JtYXRfY29uZmlnKCZ2YWx1ZXMtPml0ZW1zW3ZhbHVlcy0+bnIrK10sIGtleV8sIHZhbHVlXywga3ZpKTsKfQoKc3RhdGljIGludCBnZXRfdmFsdWUoY29uc3QgY2hhciAqa2V5XywgY29uc3QgY2hhciAqcmVnZXhfLCB1bnNpZ25lZCBmbGFncykKewoJaW50IHJldCA9IENPTkZJR19HRU5FUklDX0VSUk9SOwoJc3RydWN0IHN0cmJ1Zl9saXN0IHZhbHVlcyA9IHtOVUxMfTsKCWludCBpOwoKCWlmICh1c2Vfa2V5X3JlZ2V4cCkgewoJCWNoYXIgKnRsOwoKCQkvKgoJCSAqIE5FRURTV09SSzogdGhpcyBuYWl2ZSBwYXR0ZXJuIGxvd2VyY2FzaW5nIG9idmlvdXNseSBkb2VzIG5vdAoJCSAqIHdvcmsgZm9yIG1vcmUgY29tcGxleCBwYXR0ZXJucyBsaWtlICJeW14uXSpGb28uKmJhciIuCgkJICogUGVyaGFwcyB3ZSBzaG91bGQgZGVwcmVjYXRlIHRoaXMgYWx0b2dldGhlciBzb21lZGF5LgoJCSAqLwoKCQlrZXkgPSB4c3RyZHVwKGtleV8pOwoJCWZvciAodGwgPSBrZXkgKyBzdHJsZW4oa2V5KSAtIDE7CgkJICAgICB0bCA+PSBrZXkgJiYgKnRsICE9ICcuJzsKCQkgICAgIHRsLS0pCgkJCSp0bCA9IHRvbG93ZXIoKnRsKTsKCQlmb3IgKHRsID0ga2V5OyAqdGwgJiYgKnRsICE9ICcuJzsgdGwrKykKCQkJKnRsID0gdG9sb3dlcigqdGwpOwoKCQlrZXlfcmVnZXhwID0gKHJlZ2V4X3QqKXhtYWxsb2Moc2l6ZW9mKHJlZ2V4X3QpKTsKCQlpZiAocmVnY29tcChrZXlfcmVnZXhwLCBrZXksIFJFR19FWFRFTkRFRCkpIHsKCQkJZXJyb3IoXygiaW52YWxpZCBrZXkgcGF0dGVybjogJXMiKSwga2V5Xyk7CgkJCUZSRUVfQU5EX05VTEwoa2V5X3JlZ2V4cCk7CgkJCXJldCA9IENPTkZJR19JTlZBTElEX1BBVFRFUk47CgkJCWdvdG8gZnJlZV9zdHJpbmdzOwoJCX0KCX0gZWxzZSB7CgkJaWYgKGdpdF9jb25maWdfcGFyc2Vfa2V5KGtleV8sICZrZXksIE5VTEwpKSB7CgkJCXJldCA9IENPTkZJR19JTlZBTElEX0tFWTsKCQkJZ290byBmcmVlX3N0cmluZ3M7CgkJfQoJfQoKCWlmIChyZWdleF8gJiYgKGZsYWdzICYgQ09ORklHX0ZMQUdTX0ZJWEVEX1ZBTFVFKSkKCQl2YWx1ZV9wYXR0ZXJuID0gcmVnZXhfOwoJZWxzZSBpZiAocmVnZXhfKSB7CgkJaWYgKHJlZ2V4X1swXSA9PSAnIScpIHsKCQkJZG9fbm90X21hdGNoID0gMTsKCQkJcmVnZXhfKys7CgkJfQoKCQlyZWdleHAgPSAocmVnZXhfdCopeG1hbGxvYyhzaXplb2YocmVnZXhfdCkpOwoJCWlmIChyZWdjb21wKHJlZ2V4cCwgcmVnZXhfLCBSRUdfRVhURU5ERUQpKSB7CgkJCWVycm9yKF8oImludmFsaWQgcGF0dGVybjogJXMiKSwgcmVnZXhfKTsKCQkJRlJFRV9BTkRfTlVMTChyZWdleHApOwoJCQlyZXQgPSBDT05GSUdfSU5WQUxJRF9QQVRURVJOOwoJCQlnb3RvIGZyZWVfc3RyaW5nczsKCQl9Cgl9CgoJY29uZmlnX3dpdGhfb3B0aW9ucyhjb2xsZWN0X2NvbmZpZywgJnZhbHVlcywKCQkJICAgICZnaXZlbl9jb25maWdfc291cmNlLCB0aGVfcmVwb3NpdG9yeSwKCQkJICAgICZjb25maWdfb3B0aW9ucyk7CgoJaWYgKCF2YWx1ZXMubnIgJiYgZGVmYXVsdF92YWx1ZSkgewoJCXN0cnVjdCBrZXlfdmFsdWVfaW5mbyBrdmkgPSBLVklfSU5JVDsKCQlzdHJ1Y3Qgc3RyYnVmICppdGVtOwoKCQlrdmlfZnJvbV9wYXJhbSgma3ZpKTsKCQlBTExPQ19HUk9XKHZhbHVlcy5pdGVtcywgdmFsdWVzLm5yICsgMSwgdmFsdWVzLmFsbG9jKTsKCQlpdGVtID0gJnZhbHVlcy5pdGVtc1t2YWx1ZXMubnIrK107CgkJc3RyYnVmX2luaXQoaXRlbSwgMCk7CgkJaWYgKGZvcm1hdF9jb25maWcoaXRlbSwga2V5XywgZGVmYXVsdF92YWx1ZSwgJmt2aSkgPCAwKQoJCQlkaWUoXygiZmFpbGVkIHRvIGZvcm1hdCBkZWZhdWx0IGNvbmZpZyB2YWx1ZTogJXMiKSwKCQkJCWRlZmF1bHRfdmFsdWUpOwoJfQoKCXJldCA9ICF2YWx1ZXMubnI7CgoJZm9yIChpID0gMDsgaSA8IHZhbHVlcy5ucjsgaSsrKSB7CgkJc3RydWN0IHN0cmJ1ZiAqYnVmID0gdmFsdWVzLml0ZW1zICsgaTsKCQlpZiAoZG9fYWxsIHx8IGkgPT0gdmFsdWVzLm5yIC0gMSkKCQkJZndyaXRlKGJ1Zi0+YnVmLCAxLCBidWYtPmxlbiwgc3Rkb3V0KTsKCQlzdHJidWZfcmVsZWFzZShidWYpOwoJfQoJZnJlZSh2YWx1ZXMuaXRlbXMpOwoKZnJlZV9zdHJpbmdzOgoJZnJlZShrZXkpOwoJaWYgKGtleV9yZWdleHApIHsKCQlyZWdmcmVlKGtleV9yZWdleHApOwoJCWZyZWUoa2V5X3JlZ2V4cCk7Cgl9CglpZiAocmVnZXhwKSB7CgkJcmVnZnJlZShyZWdleHApOwoJCWZyZWUocmVnZXhwKTsKCX0KCglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgY2hhciAqbm9ybWFsaXplX3ZhbHVlKGNvbnN0IGNoYXIgKmtleSwgY29uc3QgY2hhciAqdmFsdWUsCgkJCSAgICAgc3RydWN0IGtleV92YWx1ZV9pbmZvICprdmkpCnsKCWlmICghdmFsdWUpCgkJcmV0dXJuIE5VTEw7CgoJaWYgKHR5cGUgPT0gMCB8fCB0eXBlID09IFRZUEVfUEFUSCB8fCB0eXBlID09IFRZUEVfRVhQSVJZX0RBVEUpCgkJLyoKCQkgKiBXZSBkb24ndCBkbyBub3JtYWxpemF0aW9uIGZvciBUWVBFX1BBVEggaGVyZTogSWYKCQkgKiB0aGUgcGF0aCBpcyBsaWtlIH4vZm9vYmFyLywgd2UgcHJlZmVyIHRvIHN0b3JlCgkJICogIn4vZm9vYmFyLyIgaW4gdGhlIGNvbmZpZyBmaWxlLCBhbmQgdG8gZXhwYW5kIHRoZSB+CgkJICogd2hlbiByZXRyaWV2aW5nIHRoZSB2YWx1ZS4KCQkgKiBBbHNvIGRvbid0IGRvIG5vcm1hbGl6YXRpb24gZm9yIGV4cGlyeSBkYXRlcy4KCQkgKi8KCQlyZXR1cm4geHN0cmR1cCh2YWx1ZSk7CglpZiAodHlwZSA9PSBUWVBFX0lOVCkKCQlyZXR1cm4geHN0cmZtdCgiJSJQUklkNjQsIGdpdF9jb25maWdfaW50NjQoa2V5LCB2YWx1ZSwga3ZpKSk7CglpZiAodHlwZSA9PSBUWVBFX0JPT0wpCgkJcmV0dXJuIHhzdHJkdXAoZ2l0X2NvbmZpZ19ib29sKGtleSwgdmFsdWUpID8gICJ0cnVlIiA6ICJmYWxzZSIpOwoJaWYgKHR5cGUgPT0gVFlQRV9CT09MX09SX0lOVCkgewoJCWludCBpc19ib29sLCB2OwoJCXYgPSBnaXRfY29uZmlnX2Jvb2xfb3JfaW50KGtleSwgdmFsdWUsIGt2aSwgJmlzX2Jvb2wpOwoJCWlmICghaXNfYm9vbCkKCQkJcmV0dXJuIHhzdHJmbXQoIiVkIiwgdik7CgkJZWxzZQoJCQlyZXR1cm4geHN0cmR1cCh2ID8gInRydWUiIDogImZhbHNlIik7Cgl9CglpZiAodHlwZSA9PSBUWVBFX0JPT0xfT1JfU1RSKSB7CgkJaW50IHYgPSBnaXRfcGFyc2VfbWF5YmVfYm9vbCh2YWx1ZSk7CgkJaWYgKHYgPCAwKQoJCQlyZXR1cm4geHN0cmR1cCh2YWx1ZSk7CgkJZWxzZQoJCQlyZXR1cm4geHN0cmR1cCh2ID8gInRydWUiIDogImZhbHNlIik7Cgl9CglpZiAodHlwZSA9PSBUWVBFX0NPTE9SKSB7CgkJY2hhciB2W0NPTE9SX01BWExFTl07CgkJaWYgKGdpdF9jb25maWdfY29sb3Iodiwga2V5LCB2YWx1ZSkpCgkJCWRpZShfKCJjYW5ub3QgcGFyc2UgY29sb3IgJyVzJyIpLCB2YWx1ZSk7CgoJCS8qCgkJICogVGhlIGNvbnRlbnRzIG9mIGB2YCBub3cgY29udGFpbiBhbiBBTlNJIGVzY2FwZQoJCSAqIHNlcXVlbmNlLCBub3Qgc3VpdGFibGUgZm9yIGluY2x1ZGluZyB3aXRoaW4gYQoJCSAqIGNvbmZpZ3VyYXRpb24gZmlsZS4gVHJlYXQgdGhlIGFib3ZlIGFzIGEKCQkgKiAic2FuaXR5LWNoZWNrIiwgYW5kIHJldHVybiB0aGUgZ2l2ZW4gdmFsdWUsIHdoaWNoIHdlCgkJICoga25vdyBpcyByZXByZXNlbnRhYmxlIGFzIHZhbGlkIGNvbG9yIGNvZGUuCgkJICovCgkJcmV0dXJuIHhzdHJkdXAodmFsdWUpOwoJfQoKCUJVRygiY2Fubm90IG5vcm1hbGl6ZSB0eXBlICVkIiwgdHlwZSk7Cn0KCnN0YXRpYyBpbnQgZ2V0X2NvbG9yX2ZvdW5kOwpzdGF0aWMgY29uc3QgY2hhciAqZ2V0X2NvbG9yX3Nsb3Q7CnN0YXRpYyBjb25zdCBjaGFyICpnZXRfY29sb3Jib29sX3Nsb3Q7CnN0YXRpYyBjaGFyIHBhcnNlZF9jb2xvcltDT0xPUl9NQVhMRU5dOwoKc3RhdGljIGludCBnaXRfZ2V0X2NvbG9yX2NvbmZpZyhjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlLAoJCQkJY29uc3Qgc3RydWN0IGNvbmZpZ19jb250ZXh0ICpjdHggVU5VU0VELAoJCQkJdm9pZCAqY2IgVU5VU0VEKQp7CglpZiAoIXN0cmNtcCh2YXIsIGdldF9jb2xvcl9zbG90KSkgewoJCWlmICghdmFsdWUpCgkJCWNvbmZpZ19lcnJvcl9ub25ib29sKHZhcik7CgkJaWYgKGNvbG9yX3BhcnNlKHZhbHVlLCBwYXJzZWRfY29sb3IpIDwgMCkKCQkJcmV0dXJuIC0xOwoJCWdldF9jb2xvcl9mb3VuZCA9IDE7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgZ2V0X2NvbG9yKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqZGVmX2NvbG9yKQp7CglnZXRfY29sb3Jfc2xvdCA9IHZhcjsKCWdldF9jb2xvcl9mb3VuZCA9IDA7CglwYXJzZWRfY29sb3JbMF0gPSAnXDAnOwoJY29uZmlnX3dpdGhfb3B0aW9ucyhnaXRfZ2V0X2NvbG9yX2NvbmZpZywgTlVMTCwKCQkJICAgICZnaXZlbl9jb25maWdfc291cmNlLCB0aGVfcmVwb3NpdG9yeSwKCQkJICAgICZjb25maWdfb3B0aW9ucyk7CgoJaWYgKCFnZXRfY29sb3JfZm91bmQgJiYgZGVmX2NvbG9yKSB7CgkJaWYgKGNvbG9yX3BhcnNlKGRlZl9jb2xvciwgcGFyc2VkX2NvbG9yKSA8IDApCgkJCWRpZShfKCJ1bmFibGUgdG8gcGFyc2UgZGVmYXVsdCBjb2xvciB2YWx1ZSIpKTsKCX0KCglmcHV0cyhwYXJzZWRfY29sb3IsIHN0ZG91dCk7Cn0KCnN0YXRpYyBpbnQgZ2V0X2NvbG9yYm9vbF9mb3VuZDsKc3RhdGljIGludCBnZXRfZGlmZl9jb2xvcl9mb3VuZDsKc3RhdGljIGludCBnZXRfY29sb3JfdWlfZm91bmQ7CnN0YXRpYyBpbnQgZ2l0X2dldF9jb2xvcmJvb2xfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsCgkJCQkgICAgY29uc3Qgc3RydWN0IGNvbmZpZ19jb250ZXh0ICpjdHggVU5VU0VELAoJCQkJICAgIHZvaWQgKmRhdGEgVU5VU0VEKQp7CglpZiAoIXN0cmNtcCh2YXIsIGdldF9jb2xvcmJvb2xfc2xvdCkpCgkJZ2V0X2NvbG9yYm9vbF9mb3VuZCA9IGdpdF9jb25maWdfY29sb3Jib29sKHZhciwgdmFsdWUpOwoJZWxzZSBpZiAoIXN0cmNtcCh2YXIsICJkaWZmLmNvbG9yIikpCgkJZ2V0X2RpZmZfY29sb3JfZm91bmQgPSBnaXRfY29uZmlnX2NvbG9yYm9vbCh2YXIsIHZhbHVlKTsKCWVsc2UgaWYgKCFzdHJjbXAodmFyLCAiY29sb3IudWkiKSkKCQlnZXRfY29sb3JfdWlfZm91bmQgPSBnaXRfY29uZmlnX2NvbG9yYm9vbCh2YXIsIHZhbHVlKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdldF9jb2xvcmJvb2woY29uc3QgY2hhciAqdmFyLCBpbnQgcHJpbnQpCnsKCWdldF9jb2xvcmJvb2xfc2xvdCA9IHZhcjsKCWdldF9jb2xvcmJvb2xfZm91bmQgPSAtMTsKCWdldF9kaWZmX2NvbG9yX2ZvdW5kID0gLTE7CglnZXRfY29sb3JfdWlfZm91bmQgPSAtMTsKCWNvbmZpZ193aXRoX29wdGlvbnMoZ2l0X2dldF9jb2xvcmJvb2xfY29uZmlnLCBOVUxMLAoJCQkgICAgJmdpdmVuX2NvbmZpZ19zb3VyY2UsIHRoZV9yZXBvc2l0b3J5LAoJCQkgICAgJmNvbmZpZ19vcHRpb25zKTsKCglpZiAoZ2V0X2NvbG9yYm9vbF9mb3VuZCA8IDApIHsKCQlpZiAoIXN0cmNtcChnZXRfY29sb3Jib29sX3Nsb3QsICJjb2xvci5kaWZmIikpCgkJCWdldF9jb2xvcmJvb2xfZm91bmQgPSBnZXRfZGlmZl9jb2xvcl9mb3VuZDsKCQlpZiAoZ2V0X2NvbG9yYm9vbF9mb3VuZCA8IDApCgkJCWdldF9jb2xvcmJvb2xfZm91bmQgPSBnZXRfY29sb3JfdWlfZm91bmQ7Cgl9CgoJaWYgKGdldF9jb2xvcmJvb2xfZm91bmQgPCAwKQoJCS8qIGRlZmF1bHQgdmFsdWUgaWYgbm9uZSBmb3VuZCBpbiBjb25maWcgKi8KCQlnZXRfY29sb3Jib29sX2ZvdW5kID0gR0lUX0NPTE9SX0FVVE87CgoJZ2V0X2NvbG9yYm9vbF9mb3VuZCA9IHdhbnRfY29sb3IoZ2V0X2NvbG9yYm9vbF9mb3VuZCk7CgoJaWYgKHByaW50KSB7CgkJcHJpbnRmKCIlc1xuIiwgZ2V0X2NvbG9yYm9vbF9mb3VuZCA/ICJ0cnVlIiA6ICJmYWxzZSIpOwoJCXJldHVybiAwOwoJfSBlbHNlCgkJcmV0dXJuIGdldF9jb2xvcmJvb2xfZm91bmQgPyAwIDogMTsKfQoKc3RhdGljIHZvaWQgY2hlY2tfd3JpdGUodm9pZCkKewoJaWYgKCFnaXZlbl9jb25maWdfc291cmNlLmZpbGUgJiYgIXN0YXJ0dXBfaW5mby0+aGF2ZV9yZXBvc2l0b3J5KQoJCWRpZShfKCJub3QgaW4gYSBnaXQgZGlyZWN0b3J5IikpOwoKCWlmIChnaXZlbl9jb25maWdfc291cmNlLnVzZV9zdGRpbikKCQlkaWUoXygid3JpdGluZyB0byBzdGRpbiBpcyBub3Qgc3VwcG9ydGVkIikpOwoKCWlmIChnaXZlbl9jb25maWdfc291cmNlLmJsb2IpCgkJZGllKF8oIndyaXRpbmcgY29uZmlnIGJsb2JzIGlzIG5vdCBzdXBwb3J0ZWQiKSk7Cn0KCnN0cnVjdCB1cmxtYXRjaF9jdXJyZW50X2NhbmRpZGF0ZV92YWx1ZSB7CgljaGFyIHZhbHVlX2lzX251bGw7CglzdHJ1Y3Qgc3RyYnVmIHZhbHVlOwoJc3RydWN0IGtleV92YWx1ZV9pbmZvIGt2aTsKfTsKCnN0YXRpYyBpbnQgdXJsbWF0Y2hfY29sbGVjdF9mbihjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlLAoJCQkgICAgICAgY29uc3Qgc3RydWN0IGNvbmZpZ19jb250ZXh0ICpjdHgsCgkJCSAgICAgICB2b2lkICpjYikKewoJc3RydWN0IHN0cmluZ19saXN0ICp2YWx1ZXMgPSBjYjsKCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtID0gc3RyaW5nX2xpc3RfaW5zZXJ0KHZhbHVlcywgdmFyKTsKCXN0cnVjdCB1cmxtYXRjaF9jdXJyZW50X2NhbmRpZGF0ZV92YWx1ZSAqbWF0Y2hlZCA9IGl0ZW0tPnV0aWw7Cgljb25zdCBzdHJ1Y3Qga2V5X3ZhbHVlX2luZm8gKmt2aSA9IGN0eC0+a3ZpOwoKCWlmICghbWF0Y2hlZCkgewoJCW1hdGNoZWQgPSB4bWFsbG9jKHNpemVvZigqbWF0Y2hlZCkpOwoJCXN0cmJ1Zl9pbml0KCZtYXRjaGVkLT52YWx1ZSwgMCk7CgkJaXRlbS0+dXRpbCA9IG1hdGNoZWQ7Cgl9IGVsc2UgewoJCXN0cmJ1Zl9yZXNldCgmbWF0Y2hlZC0+dmFsdWUpOwoJfQoJbWF0Y2hlZC0+a3ZpID0gKmt2aTsKCglpZiAodmFsdWUpIHsKCQlzdHJidWZfYWRkc3RyKCZtYXRjaGVkLT52YWx1ZSwgdmFsdWUpOwoJCW1hdGNoZWQtPnZhbHVlX2lzX251bGwgPSAwOwoJfSBlbHNlIHsKCQltYXRjaGVkLT52YWx1ZV9pc19udWxsID0gMTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdldF91cmxtYXRjaChjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnVybCkKewoJaW50IHJldDsKCWNoYXIgKnNlY3Rpb25fdGFpbDsKCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoJc3RydWN0IHVybG1hdGNoX2NvbmZpZyBjb25maWcgPSBVUkxNQVRDSF9DT05GSUdfSU5JVDsKCXN0cnVjdCBzdHJpbmdfbGlzdCB2YWx1ZXMgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCgljb25maWcuY29sbGVjdF9mbiA9IHVybG1hdGNoX2NvbGxlY3RfZm47Cgljb25maWcuY2FzY2FkZV9mbiA9IE5VTEw7Cgljb25maWcuY2IgPSAmdmFsdWVzOwoKCWlmICghdXJsX25vcm1hbGl6ZSh1cmwsICZjb25maWcudXJsKSkKCQlkaWUoIiVzIiwgY29uZmlnLnVybC5lcnIpOwoKCWNvbmZpZy5zZWN0aW9uID0geHN0cmR1cF90b2xvd2VyKHZhcik7CglzZWN0aW9uX3RhaWwgPSBzdHJjaHIoY29uZmlnLnNlY3Rpb24sICcuJyk7CglpZiAoc2VjdGlvbl90YWlsKSB7CgkJKnNlY3Rpb25fdGFpbCA9ICdcMCc7CgkJY29uZmlnLmtleSA9IHNlY3Rpb25fdGFpbCArIDE7CgkJc2hvd19rZXlzID0gMDsKCX0gZWxzZSB7CgkJY29uZmlnLmtleSA9IE5VTEw7CgkJc2hvd19rZXlzID0gMTsKCX0KCgljb25maWdfd2l0aF9vcHRpb25zKHVybG1hdGNoX2NvbmZpZ19lbnRyeSwgJmNvbmZpZywKCQkJICAgICZnaXZlbl9jb25maWdfc291cmNlLCB0aGVfcmVwb3NpdG9yeSwKCQkJICAgICZjb25maWdfb3B0aW9ucyk7CgoJcmV0ID0gIXZhbHVlcy5ucjsKCglmb3JfZWFjaF9zdHJpbmdfbGlzdF9pdGVtKGl0ZW0sICZ2YWx1ZXMpIHsKCQlzdHJ1Y3QgdXJsbWF0Y2hfY3VycmVudF9jYW5kaWRhdGVfdmFsdWUgKm1hdGNoZWQgPSBpdGVtLT51dGlsOwoJCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJCWZvcm1hdF9jb25maWcoJmJ1ZiwgaXRlbS0+c3RyaW5nLAoJCQkgICAgICBtYXRjaGVkLT52YWx1ZV9pc19udWxsID8gTlVMTCA6IG1hdGNoZWQtPnZhbHVlLmJ1ZiwKCQkJICAgICAgJm1hdGNoZWQtPmt2aSk7CgkJZndyaXRlKGJ1Zi5idWYsIDEsIGJ1Zi5sZW4sIHN0ZG91dCk7CgkJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CgoJCXN0cmJ1Zl9yZWxlYXNlKCZtYXRjaGVkLT52YWx1ZSk7Cgl9Cgl1cmxtYXRjaF9jb25maWdfcmVsZWFzZSgmY29uZmlnKTsKCXN0cmluZ19saXN0X2NsZWFyKCZ2YWx1ZXMsIDEpOwoJZnJlZShjb25maWcudXJsLnVybCk7CgoJZnJlZSgodm9pZCAqKWNvbmZpZy5zZWN0aW9uKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBjaGFyICpkZWZhdWx0X3VzZXJfY29uZmlnKHZvaWQpCnsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJidWZfYWRkZigmYnVmLAoJCSAgICBfKCIjIFRoaXMgaXMgR2l0J3MgcGVyLXVzZXIgY29uZmlndXJhdGlvbiBmaWxlLlxuIgoJCSAgICAgICJbdXNlcl1cbiIKCQkgICAgICAiIyBQbGVhc2UgYWRhcHQgYW5kIHVuY29tbWVudCB0aGUgZm9sbG93aW5nIGxpbmVzOlxuIgoJCSAgICAgICIjCW5hbWUgPSAlc1xuIgoJCSAgICAgICIjCWVtYWlsID0gJXNcbiIpLAoJCSAgICBpZGVudF9kZWZhdWx0X25hbWUoKSwKCQkgICAgaWRlbnRfZGVmYXVsdF9lbWFpbCgpKTsKCXJldHVybiBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpOwp9CgppbnQgY21kX2NvbmZpZyhpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJaW50IG5vbmdpdCA9ICFzdGFydHVwX2luZm8tPmhhdmVfcmVwb3NpdG9yeTsKCWNoYXIgKnZhbHVlID0gTlVMTDsKCWludCBmbGFncyA9IDA7CglpbnQgcmV0ID0gMDsKCXN0cnVjdCBrZXlfdmFsdWVfaW5mbyBkZWZhdWx0X2t2aSA9IEtWSV9JTklUOwoKCWdpdmVuX2NvbmZpZ19zb3VyY2UuZmlsZSA9IHhzdHJkdXBfb3JfbnVsbChnZXRlbnYoQ09ORklHX0VOVklST05NRU5UKSk7CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBidWlsdGluX2NvbmZpZ19vcHRpb25zLAoJCQkgICAgIGJ1aWx0aW5fY29uZmlnX3VzYWdlLAoJCQkgICAgIFBBUlNFX09QVF9TVE9QX0FUX05PTl9PUFRJT04pOwoKCWlmICh1c2VfZ2xvYmFsX2NvbmZpZyArIHVzZV9zeXN0ZW1fY29uZmlnICsgdXNlX2xvY2FsX2NvbmZpZyArCgkgICAgdXNlX3dvcmt0cmVlX2NvbmZpZyArCgkgICAgISFnaXZlbl9jb25maWdfc291cmNlLmZpbGUgKyAhIWdpdmVuX2NvbmZpZ19zb3VyY2UuYmxvYiA+IDEpIHsKCQllcnJvcihfKCJvbmx5IG9uZSBjb25maWcgZmlsZSBhdCBhIHRpbWUiKSk7CgkJdXNhZ2VfYnVpbHRpbl9jb25maWcoKTsKCX0KCglpZiAobm9uZ2l0KSB7CgkJaWYgKHVzZV9sb2NhbF9jb25maWcpCgkJCWRpZShfKCItLWxvY2FsIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGEgZ2l0IHJlcG9zaXRvcnkiKSk7CgkJaWYgKGdpdmVuX2NvbmZpZ19zb3VyY2UuYmxvYikKCQkJZGllKF8oIi0tYmxvYiBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhIGdpdCByZXBvc2l0b3J5IikpOwoJCWlmICh1c2Vfd29ya3RyZWVfY29uZmlnKQoJCQlkaWUoXygiLS13b3JrdHJlZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhIGdpdCByZXBvc2l0b3J5IikpOwoKCX0KCglpZiAoZ2l2ZW5fY29uZmlnX3NvdXJjZS5maWxlICYmCgkJCSFzdHJjbXAoZ2l2ZW5fY29uZmlnX3NvdXJjZS5maWxlLCAiLSIpKSB7CgkJZ2l2ZW5fY29uZmlnX3NvdXJjZS5maWxlID0gTlVMTDsKCQlnaXZlbl9jb25maWdfc291cmNlLnVzZV9zdGRpbiA9IDE7CgkJZ2l2ZW5fY29uZmlnX3NvdXJjZS5zY29wZSA9IENPTkZJR19TQ09QRV9DT01NQU5EOwoJfQoKCWlmICh1c2VfZ2xvYmFsX2NvbmZpZykgewoJCWdpdmVuX2NvbmZpZ19zb3VyY2UuZmlsZSA9IGdpdF9nbG9iYWxfY29uZmlnKCk7CgkJaWYgKCFnaXZlbl9jb25maWdfc291cmNlLmZpbGUpCgkJCS8qCgkJCSAqIEl0IGlzIHVua25vd24gaWYgSE9NRS8uZ2l0Y29uZmlnIGV4aXN0cywgc28KCQkJICogd2UgZG8gbm90IGtub3cgaWYgd2Ugc2hvdWxkIHdyaXRlIHRvIFhERwoJCQkgKiBsb2NhdGlvbjsgZXJyb3Igb3V0IGV2ZW4gaWYgWERHX0NPTkZJR19IT01FCgkJCSAqIGlzIHNldCBhbmQgcG9pbnRzIGF0IGEgc2FuZSBsb2NhdGlvbi4KCQkJICovCgkJCWRpZShfKCIkSE9NRSBub3Qgc2V0IikpOwoJCWdpdmVuX2NvbmZpZ19zb3VyY2Uuc2NvcGUgPSBDT05GSUdfU0NPUEVfR0xPQkFMOwoJfSBlbHNlIGlmICh1c2Vfc3lzdGVtX2NvbmZpZykgewoJCWdpdmVuX2NvbmZpZ19zb3VyY2UuZmlsZSA9IGdpdF9zeXN0ZW1fY29uZmlnKCk7CgkJZ2l2ZW5fY29uZmlnX3NvdXJjZS5zY29wZSA9IENPTkZJR19TQ09QRV9TWVNURU07Cgl9IGVsc2UgaWYgKHVzZV9sb2NhbF9jb25maWcpIHsKCQlnaXZlbl9jb25maWdfc291cmNlLmZpbGUgPSBnaXRfcGF0aGR1cCgiY29uZmlnIik7CgkJZ2l2ZW5fY29uZmlnX3NvdXJjZS5zY29wZSA9IENPTkZJR19TQ09QRV9MT0NBTDsKCX0gZWxzZSBpZiAodXNlX3dvcmt0cmVlX2NvbmZpZykgewoJCXN0cnVjdCB3b3JrdHJlZSAqKndvcmt0cmVlcyA9IGdldF93b3JrdHJlZXMoKTsKCQlpZiAodGhlX3JlcG9zaXRvcnktPnJlcG9zaXRvcnlfZm9ybWF0X3dvcmt0cmVlX2NvbmZpZykKCQkJZ2l2ZW5fY29uZmlnX3NvdXJjZS5maWxlID0gZ2l0X3BhdGhkdXAoImNvbmZpZy53b3JrdHJlZSIpOwoJCWVsc2UgaWYgKHdvcmt0cmVlc1swXSAmJiB3b3JrdHJlZXNbMV0pCgkJCWRpZShfKCItLXdvcmt0cmVlIGNhbm5vdCBiZSB1c2VkIHdpdGggbXVsdGlwbGUgIgoJCQkgICAgICAid29ya2luZyB0cmVlcyB1bmxlc3MgdGhlIGNvbmZpZ1xuIgoJCQkgICAgICAiZXh0ZW5zaW9uIHdvcmt0cmVlQ29uZmlnIGlzIGVuYWJsZWQuICIKCQkJICAgICAgIlBsZWFzZSByZWFkIFwiQ09ORklHVVJBVElPTiBGSUxFXCJcbiIKCQkJICAgICAgInNlY3Rpb24gaW4gXCJnaXQgaGVscCB3b3JrdHJlZVwiIGZvciBkZXRhaWxzIikpOwoJCWVsc2UKCQkJZ2l2ZW5fY29uZmlnX3NvdXJjZS5maWxlID0gZ2l0X3BhdGhkdXAoImNvbmZpZyIpOwoJCWdpdmVuX2NvbmZpZ19zb3VyY2Uuc2NvcGUgPSBDT05GSUdfU0NPUEVfTE9DQUw7CgkJZnJlZV93b3JrdHJlZXMod29ya3RyZWVzKTsKCX0gZWxzZSBpZiAoZ2l2ZW5fY29uZmlnX3NvdXJjZS5maWxlKSB7CgkJaWYgKCFpc19hYnNvbHV0ZV9wYXRoKGdpdmVuX2NvbmZpZ19zb3VyY2UuZmlsZSkgJiYgcHJlZml4KQoJCQlnaXZlbl9jb25maWdfc291cmNlLmZpbGUgPQoJCQkJcHJlZml4X2ZpbGVuYW1lKHByZWZpeCwgZ2l2ZW5fY29uZmlnX3NvdXJjZS5maWxlKTsKCQlnaXZlbl9jb25maWdfc291cmNlLnNjb3BlID0gQ09ORklHX1NDT1BFX0NPTU1BTkQ7Cgl9IGVsc2UgaWYgKGdpdmVuX2NvbmZpZ19zb3VyY2UuYmxvYikgewoJCWdpdmVuX2NvbmZpZ19zb3VyY2Uuc2NvcGUgPSBDT05GSUdfU0NPUEVfQ09NTUFORDsKCX0KCglpZiAocmVzcGVjdF9pbmNsdWRlc19vcHQgPT0gLTEpCgkJY29uZmlnX29wdGlvbnMucmVzcGVjdF9pbmNsdWRlcyA9ICFnaXZlbl9jb25maWdfc291cmNlLmZpbGU7CgllbHNlCgkJY29uZmlnX29wdGlvbnMucmVzcGVjdF9pbmNsdWRlcyA9IHJlc3BlY3RfaW5jbHVkZXNfb3B0OwoJaWYgKCFub25naXQpIHsKCQljb25maWdfb3B0aW9ucy5jb21tb25kaXIgPSBnZXRfZ2l0X2NvbW1vbl9kaXIoKTsKCQljb25maWdfb3B0aW9ucy5naXRfZGlyID0gZ2V0X2dpdF9kaXIoKTsKCX0KCglpZiAoZW5kX251bCkgewoJCXRlcm0gPSAnXDAnOwoJCWRlbGltID0gJ1xuJzsKCQlrZXlfZGVsaW0gPSAnXG4nOwoJfQoKCWlmICgoYWN0aW9ucyAmIChBQ1RJT05fR0VUX0NPTE9SfEFDVElPTl9HRVRfQ09MT1JCT09MKSkgJiYgdHlwZSkgewoJCWVycm9yKF8oIi0tZ2V0LWNvbG9yIGFuZCB2YXJpYWJsZSB0eXBlIGFyZSBpbmNvaGVyZW50IikpOwoJCXVzYWdlX2J1aWx0aW5fY29uZmlnKCk7Cgl9CgoJaWYgKEhBU19NVUxUSV9CSVRTKGFjdGlvbnMpKSB7CgkJZXJyb3IoXygib25seSBvbmUgYWN0aW9uIGF0IGEgdGltZSIpKTsKCQl1c2FnZV9idWlsdGluX2NvbmZpZygpOwoJfQoJaWYgKGFjdGlvbnMgPT0gMCkKCQlzd2l0Y2ggKGFyZ2MpIHsKCQljYXNlIDE6IGFjdGlvbnMgPSBBQ1RJT05fR0VUOyBicmVhazsKCQljYXNlIDI6IGFjdGlvbnMgPSBBQ1RJT05fU0VUOyBicmVhazsKCQljYXNlIDM6IGFjdGlvbnMgPSBBQ1RJT05fU0VUX0FMTDsgYnJlYWs7CgkJZGVmYXVsdDoKCQkJdXNhZ2VfYnVpbHRpbl9jb25maWcoKTsKCQl9CglpZiAob21pdF92YWx1ZXMgJiYKCSAgICAhKGFjdGlvbnMgPT0gQUNUSU9OX0xJU1QgfHwgYWN0aW9ucyA9PSBBQ1RJT05fR0VUX1JFR0VYUCkpIHsKCQllcnJvcihfKCItLW5hbWUtb25seSBpcyBvbmx5IGFwcGxpY2FibGUgdG8gLS1saXN0IG9yIC0tZ2V0LXJlZ2V4cCIpKTsKCQl1c2FnZV9idWlsdGluX2NvbmZpZygpOwoJfQoKCWlmIChzaG93X29yaWdpbiAmJiAhKGFjdGlvbnMgJgoJCShBQ1RJT05fR0VUfEFDVElPTl9HRVRfQUxMfEFDVElPTl9HRVRfUkVHRVhQfEFDVElPTl9MSVNUKSkpIHsKCQllcnJvcihfKCItLXNob3ctb3JpZ2luIGlzIG9ubHkgYXBwbGljYWJsZSB0byAtLWdldCwgLS1nZXQtYWxsLCAiCgkJCSItLWdldC1yZWdleHAsIGFuZCAtLWxpc3QiKSk7CgkJdXNhZ2VfYnVpbHRpbl9jb25maWcoKTsKCX0KCglpZiAoZGVmYXVsdF92YWx1ZSAmJiAhKGFjdGlvbnMgJiBBQ1RJT05fR0VUKSkgewoJCWVycm9yKF8oIi0tZGVmYXVsdCBpcyBvbmx5IGFwcGxpY2FibGUgdG8gLS1nZXQiKSk7CgkJdXNhZ2VfYnVpbHRpbl9jb25maWcoKTsKCX0KCglpZiAoY29tbWVudCAmJgoJICAgICEoYWN0aW9ucyAmIChBQ1RJT05fQUREfEFDVElPTl9TRVR8QUNUSU9OX1NFVF9BTEx8QUNUSU9OX1JFUExBQ0VfQUxMKSkpIHsKCQllcnJvcihfKCItLWNvbW1lbnQgaXMgb25seSBhcHBsaWNhYmxlIHRvIGFkZC9zZXQvcmVwbGFjZSBvcGVyYXRpb25zIikpOwoJCXVzYWdlX2J1aWx0aW5fY29uZmlnKCk7Cgl9CgoJLyogY2hlY2sgdXNhZ2Ugb2YgLS1maXhlZC12YWx1ZSAqLwoJaWYgKGZpeGVkX3ZhbHVlKSB7CgkJaW50IGFsbG93ZWRfdXNhZ2UgPSAwOwoKCQlzd2l0Y2ggKGFjdGlvbnMpIHsKCQkvKiBnaXQgY29uZmlnIC0tZ2V0IDxuYW1lPiA8dmFsdWUtcGF0dGVybj4gKi8KCQljYXNlIEFDVElPTl9HRVQ6CgkJLyogZ2l0IGNvbmZpZyAtLWdldC1hbGwgPG5hbWU+IDx2YWx1ZS1wYXR0ZXJuPiAqLwoJCWNhc2UgQUNUSU9OX0dFVF9BTEw6CgkJLyogZ2l0IGNvbmZpZyAtLWdldC1yZWdleHAgPG5hbWUtcGF0dGVybj4gPHZhbHVlLXBhdHRlcm4+ICovCgkJY2FzZSBBQ1RJT05fR0VUX1JFR0VYUDoKCQkvKiBnaXQgY29uZmlnIC0tdW5zZXQgPG5hbWU+IDx2YWx1ZS1wYXR0ZXJuPiAqLwoJCWNhc2UgQUNUSU9OX1VOU0VUOgoJCS8qIGdpdCBjb25maWcgLS11bnNldC1hbGwgPG5hbWU+IDx2YWx1ZS1wYXR0ZXJuPiAqLwoJCWNhc2UgQUNUSU9OX1VOU0VUX0FMTDoKCQkJYWxsb3dlZF91c2FnZSA9IGFyZ2MgPiAxICYmICEhYXJndlsxXTsKCQkJYnJlYWs7CgoJCS8qIGdpdCBjb25maWcgPG5hbWU+IDx2YWx1ZT4gPHZhbHVlLXBhdHRlcm4+ICovCgkJY2FzZSBBQ1RJT05fU0VUX0FMTDoKCQkvKiBnaXQgY29uZmlnIC0tcmVwbGFjZS1hbGwgPG5hbWU+IDx2YWx1ZT4gPHZhbHVlLXBhdHRlcm4+ICovCgkJY2FzZSBBQ1RJT05fUkVQTEFDRV9BTEw6CgkJCWFsbG93ZWRfdXNhZ2UgPSBhcmdjID4gMiAmJiAhIWFyZ3ZbMl07CgkJCWJyZWFrOwoKCQkvKiBvdGhlciBvcHRpb25zIGRvbid0IGFsbG93IC0tZml4ZWQtdmFsdWUgKi8KCQl9CgoJCWlmICghYWxsb3dlZF91c2FnZSkgewoJCQllcnJvcihfKCItLWZpeGVkLXZhbHVlIG9ubHkgYXBwbGllcyB3aXRoICd2YWx1ZS1wYXR0ZXJuJyIpKTsKCQkJdXNhZ2VfYnVpbHRpbl9jb25maWcoKTsKCQl9CgoJCWZsYWdzIHw9IENPTkZJR19GTEFHU19GSVhFRF9WQUxVRTsKCX0KCgljb21tZW50ID0gZ2l0X2NvbmZpZ19wcmVwYXJlX2NvbW1lbnRfc3RyaW5nKGNvbW1lbnQpOwoKCWlmIChhY3Rpb25zICYgUEFHSU5HX0FDVElPTlMpCgkJc2V0dXBfYXV0b19wYWdlcigiY29uZmlnIiwgMSk7CgoJaWYgKGFjdGlvbnMgPT0gQUNUSU9OX0xJU1QpIHsKCQljaGVja19hcmdjKGFyZ2MsIDAsIDApOwoJCWlmIChjb25maWdfd2l0aF9vcHRpb25zKHNob3dfYWxsX2NvbmZpZywgTlVMTCwKCQkJCQkmZ2l2ZW5fY29uZmlnX3NvdXJjZSwgdGhlX3JlcG9zaXRvcnksCgkJCQkJJmNvbmZpZ19vcHRpb25zKSA8IDApIHsKCQkJaWYgKGdpdmVuX2NvbmZpZ19zb3VyY2UuZmlsZSkKCQkJCWRpZV9lcnJubyhfKCJ1bmFibGUgdG8gcmVhZCBjb25maWcgZmlsZSAnJXMnIiksCgkJCQkJICBnaXZlbl9jb25maWdfc291cmNlLmZpbGUpOwoJCQllbHNlCgkJCQlkaWUoXygiZXJyb3IgcHJvY2Vzc2luZyBjb25maWcgZmlsZShzKSIpKTsKCQl9Cgl9CgllbHNlIGlmIChhY3Rpb25zID09IEFDVElPTl9FRElUKSB7CgkJY2hhciAqY29uZmlnX2ZpbGU7CgoJCWNoZWNrX2FyZ2MoYXJnYywgMCwgMCk7CgkJaWYgKCFnaXZlbl9jb25maWdfc291cmNlLmZpbGUgJiYgbm9uZ2l0KQoJCQlkaWUoXygibm90IGluIGEgZ2l0IGRpcmVjdG9yeSIpKTsKCQlpZiAoZ2l2ZW5fY29uZmlnX3NvdXJjZS51c2Vfc3RkaW4pCgkJCWRpZShfKCJlZGl0aW5nIHN0ZGluIGlzIG5vdCBzdXBwb3J0ZWQiKSk7CgkJaWYgKGdpdmVuX2NvbmZpZ19zb3VyY2UuYmxvYikKCQkJZGllKF8oImVkaXRpbmcgYmxvYnMgaXMgbm90IHN1cHBvcnRlZCIpKTsKCQlnaXRfY29uZmlnKGdpdF9kZWZhdWx0X2NvbmZpZywgTlVMTCk7CgkJY29uZmlnX2ZpbGUgPSBnaXZlbl9jb25maWdfc291cmNlLmZpbGUgPwoJCQkJeHN0cmR1cChnaXZlbl9jb25maWdfc291cmNlLmZpbGUpIDoKCQkJCWdpdF9wYXRoZHVwKCJjb25maWciKTsKCQlpZiAodXNlX2dsb2JhbF9jb25maWcpIHsKCQkJaW50IGZkID0gb3Blbihjb25maWdfZmlsZSwgT19DUkVBVCB8IE9fRVhDTCB8IE9fV1JPTkxZLCAwNjY2KTsKCQkJaWYgKGZkID49IDApIHsKCQkJCWNoYXIgKmNvbnRlbnQgPSBkZWZhdWx0X3VzZXJfY29uZmlnKCk7CgkJCQl3cml0ZV9zdHJfaW5fZnVsbChmZCwgY29udGVudCk7CgkJCQlmcmVlKGNvbnRlbnQpOwoJCQkJY2xvc2UoZmQpOwoJCQl9CgkJCWVsc2UgaWYgKGVycm5vICE9IEVFWElTVCkKCQkJCWRpZV9lcnJubyhfKCJjYW5ub3QgY3JlYXRlIGNvbmZpZ3VyYXRpb24gZmlsZSAlcyIpLCBjb25maWdfZmlsZSk7CgkJfQoJCWxhdW5jaF9lZGl0b3IoY29uZmlnX2ZpbGUsIE5VTEwsIE5VTEwpOwoJCWZyZWUoY29uZmlnX2ZpbGUpOwoJfQoJZWxzZSBpZiAoYWN0aW9ucyA9PSBBQ1RJT05fU0VUKSB7CgkJY2hlY2tfd3JpdGUoKTsKCQljaGVja19hcmdjKGFyZ2MsIDIsIDIpOwoJCXZhbHVlID0gbm9ybWFsaXplX3ZhbHVlKGFyZ3ZbMF0sIGFyZ3ZbMV0sICZkZWZhdWx0X2t2aSk7CgkJcmV0ID0gZ2l0X2NvbmZpZ19zZXRfaW5fZmlsZV9nZW50bHkoZ2l2ZW5fY29uZmlnX3NvdXJjZS5maWxlLCBhcmd2WzBdLCBjb21tZW50LCB2YWx1ZSk7CgkJaWYgKHJldCA9PSBDT05GSUdfTk9USElOR19TRVQpCgkJCWVycm9yKF8oImNhbm5vdCBvdmVyd3JpdGUgbXVsdGlwbGUgdmFsdWVzIHdpdGggYSBzaW5nbGUgdmFsdWVcbiIKCQkJIiAgICAgICBVc2UgYSByZWdleHAsIC0tYWRkIG9yIC0tcmVwbGFjZS1hbGwgdG8gY2hhbmdlICVzLiIpLCBhcmd2WzBdKTsKCX0KCWVsc2UgaWYgKGFjdGlvbnMgPT0gQUNUSU9OX1NFVF9BTEwpIHsKCQljaGVja193cml0ZSgpOwoJCWNoZWNrX2FyZ2MoYXJnYywgMiwgMyk7CgkJdmFsdWUgPSBub3JtYWxpemVfdmFsdWUoYXJndlswXSwgYXJndlsxXSwgJmRlZmF1bHRfa3ZpKTsKCQlyZXQgPSBnaXRfY29uZmlnX3NldF9tdWx0aXZhcl9pbl9maWxlX2dlbnRseShnaXZlbl9jb25maWdfc291cmNlLmZpbGUsCgkJCQkJCQkgICAgIGFyZ3ZbMF0sIHZhbHVlLCBhcmd2WzJdLAoJCQkJCQkJICAgICBjb21tZW50LCBmbGFncyk7Cgl9CgllbHNlIGlmIChhY3Rpb25zID09IEFDVElPTl9BREQpIHsKCQljaGVja193cml0ZSgpOwoJCWNoZWNrX2FyZ2MoYXJnYywgMiwgMik7CgkJdmFsdWUgPSBub3JtYWxpemVfdmFsdWUoYXJndlswXSwgYXJndlsxXSwgJmRlZmF1bHRfa3ZpKTsKCQlyZXQgPSBnaXRfY29uZmlnX3NldF9tdWx0aXZhcl9pbl9maWxlX2dlbnRseShnaXZlbl9jb25maWdfc291cmNlLmZpbGUsCgkJCQkJCQkgICAgIGFyZ3ZbMF0sIHZhbHVlLAoJCQkJCQkJICAgICBDT05GSUdfUkVHRVhfTk9ORSwKCQkJCQkJCSAgICAgY29tbWVudCwgZmxhZ3MpOwoJfQoJZWxzZSBpZiAoYWN0aW9ucyA9PSBBQ1RJT05fUkVQTEFDRV9BTEwpIHsKCQljaGVja193cml0ZSgpOwoJCWNoZWNrX2FyZ2MoYXJnYywgMiwgMyk7CgkJdmFsdWUgPSBub3JtYWxpemVfdmFsdWUoYXJndlswXSwgYXJndlsxXSwgJmRlZmF1bHRfa3ZpKTsKCQlyZXQgPSBnaXRfY29uZmlnX3NldF9tdWx0aXZhcl9pbl9maWxlX2dlbnRseShnaXZlbl9jb25maWdfc291cmNlLmZpbGUsCgkJCQkJCQkgICAgIGFyZ3ZbMF0sIHZhbHVlLCBhcmd2WzJdLAoJCQkJCQkJICAgICBjb21tZW50LCBmbGFncyB8IENPTkZJR19GTEFHU19NVUxUSV9SRVBMQUNFKTsKCX0KCWVsc2UgaWYgKGFjdGlvbnMgPT0gQUNUSU9OX0dFVCkgewoJCWNoZWNrX2FyZ2MoYXJnYywgMSwgMik7CgkJcmV0dXJuIGdldF92YWx1ZShhcmd2WzBdLCBhcmd2WzFdLCBmbGFncyk7Cgl9CgllbHNlIGlmIChhY3Rpb25zID09IEFDVElPTl9HRVRfQUxMKSB7CgkJZG9fYWxsID0gMTsKCQljaGVja19hcmdjKGFyZ2MsIDEsIDIpOwoJCXJldHVybiBnZXRfdmFsdWUoYXJndlswXSwgYXJndlsxXSwgZmxhZ3MpOwoJfQoJZWxzZSBpZiAoYWN0aW9ucyA9PSBBQ1RJT05fR0VUX1JFR0VYUCkgewoJCXNob3dfa2V5cyA9IDE7CgkJdXNlX2tleV9yZWdleHAgPSAxOwoJCWRvX2FsbCA9IDE7CgkJY2hlY2tfYXJnYyhhcmdjLCAxLCAyKTsKCQlyZXR1cm4gZ2V0X3ZhbHVlKGFyZ3ZbMF0sIGFyZ3ZbMV0sIGZsYWdzKTsKCX0KCWVsc2UgaWYgKGFjdGlvbnMgPT0gQUNUSU9OX0dFVF9VUkxNQVRDSCkgewoJCWNoZWNrX2FyZ2MoYXJnYywgMiwgMik7CgkJcmV0dXJuIGdldF91cmxtYXRjaChhcmd2WzBdLCBhcmd2WzFdKTsKCX0KCWVsc2UgaWYgKGFjdGlvbnMgPT0gQUNUSU9OX1VOU0VUKSB7CgkJY2hlY2tfd3JpdGUoKTsKCQljaGVja19hcmdjKGFyZ2MsIDEsIDIpOwoJCWlmIChhcmdjID09IDIpCgkJCXJldHVybiBnaXRfY29uZmlnX3NldF9tdWx0aXZhcl9pbl9maWxlX2dlbnRseShnaXZlbl9jb25maWdfc291cmNlLmZpbGUsCgkJCQkJCQkJICAgICAgYXJndlswXSwgTlVMTCwgYXJndlsxXSwKCQkJCQkJCQkgICAgICBOVUxMLCBmbGFncyk7CgkJZWxzZQoJCQlyZXR1cm4gZ2l0X2NvbmZpZ19zZXRfaW5fZmlsZV9nZW50bHkoZ2l2ZW5fY29uZmlnX3NvdXJjZS5maWxlLAoJCQkJCQkJICAgICBhcmd2WzBdLCBOVUxMLCBOVUxMKTsKCX0KCWVsc2UgaWYgKGFjdGlvbnMgPT0gQUNUSU9OX1VOU0VUX0FMTCkgewoJCWNoZWNrX3dyaXRlKCk7CgkJY2hlY2tfYXJnYyhhcmdjLCAxLCAyKTsKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zZXRfbXVsdGl2YXJfaW5fZmlsZV9nZW50bHkoZ2l2ZW5fY29uZmlnX3NvdXJjZS5maWxlLAoJCQkJCQkJICAgICAgYXJndlswXSwgTlVMTCwgYXJndlsxXSwKCQkJCQkJCSAgICAgIE5VTEwsIGZsYWdzIHwgQ09ORklHX0ZMQUdTX01VTFRJX1JFUExBQ0UpOwoJfQoJZWxzZSBpZiAoYWN0aW9ucyA9PSBBQ1RJT05fUkVOQU1FX1NFQ1RJT04pIHsKCQljaGVja193cml0ZSgpOwoJCWNoZWNrX2FyZ2MoYXJnYywgMiwgMik7CgkJcmV0ID0gZ2l0X2NvbmZpZ19yZW5hbWVfc2VjdGlvbl9pbl9maWxlKGdpdmVuX2NvbmZpZ19zb3VyY2UuZmlsZSwKCQkJCQkJCWFyZ3ZbMF0sIGFyZ3ZbMV0pOwoJCWlmIChyZXQgPCAwKQoJCQlyZXR1cm4gcmV0OwoJCWVsc2UgaWYgKCFyZXQpCgkJCWRpZShfKCJubyBzdWNoIHNlY3Rpb246ICVzIiksIGFyZ3ZbMF0pOwoJCWVsc2UKCQkJcmV0ID0gMDsKCX0KCWVsc2UgaWYgKGFjdGlvbnMgPT0gQUNUSU9OX1JFTU9WRV9TRUNUSU9OKSB7CgkJY2hlY2tfd3JpdGUoKTsKCQljaGVja19hcmdjKGFyZ2MsIDEsIDEpOwoJCXJldCA9IGdpdF9jb25maWdfcmVuYW1lX3NlY3Rpb25faW5fZmlsZShnaXZlbl9jb25maWdfc291cmNlLmZpbGUsCgkJCQkJCQlhcmd2WzBdLCBOVUxMKTsKCQlpZiAocmV0IDwgMCkKCQkJcmV0dXJuIHJldDsKCQllbHNlIGlmICghcmV0KQoJCQlkaWUoXygibm8gc3VjaCBzZWN0aW9uOiAlcyIpLCBhcmd2WzBdKTsKCQllbHNlCgkJCXJldCA9IDA7Cgl9CgllbHNlIGlmIChhY3Rpb25zID09IEFDVElPTl9HRVRfQ09MT1IpIHsKCQljaGVja19hcmdjKGFyZ2MsIDEsIDIpOwoJCWdldF9jb2xvcihhcmd2WzBdLCBhcmd2WzFdKTsKCX0KCWVsc2UgaWYgKGFjdGlvbnMgPT0gQUNUSU9OX0dFVF9DT0xPUkJPT0wpIHsKCQljaGVja19hcmdjKGFyZ2MsIDEsIDIpOwoJCWlmIChhcmdjID09IDIpCgkJCWNvbG9yX3N0ZG91dF9pc190dHkgPSBnaXRfY29uZmlnX2Jvb2woImNvbW1hbmQgbGluZSIsIGFyZ3ZbMV0pOwoJCXJldHVybiBnZXRfY29sb3Jib29sKGFyZ3ZbMF0sIGFyZ2MgPT0gMik7Cgl9CgoJZnJlZSh2YWx1ZSk7CglyZXR1cm4gcmV0Owp9Cg==",
    "text": "#include \"builtin.h\"\n#include \"abspath.h\"\n#include \"config.h\"\n#include \"color.h\"\n#include \"editor.h\"\n#include \"environment.h\"\n#include \"repository.h\"\n#include \"gettext.h\"\n#include \"ident.h\"\n#include \"parse-options.h\"\n#include \"urlmatch.h\"\n#include \"path.h\"\n#include \"quote.h\"\n#include \"setup.h\"\n#include \"strbuf.h\"\n#include \"worktree.h\"\n\nstatic const char *const builtin_config_usage[] = {\n\tN_(\"git config [<options>]\"),\n\tNULL\n};\n\nstatic char *key;\nstatic regex_t *key_regexp;\nstatic const char *value_pattern;\nstatic regex_t *regexp;\nstatic int show_keys;\nstatic int omit_values;\nstatic int use_key_regexp;\nstatic int do_all;\nstatic int do_not_match;\nstatic char delim = '=';\nstatic char key_delim = ' ';\nstatic char term = '\\n';\n\nstatic int use_global_config, use_system_config, use_local_config;\nstatic int use_worktree_config;\nstatic struct git_config_source given_config_source;\nstatic int actions, type;\nstatic char *default_value;\nstatic int end_nul;\nstatic int respect_includes_opt = -1;\nstatic struct config_options config_options;\nstatic int show_origin;\nstatic int show_scope;\nstatic int fixed_value;\nstatic const char *comment;\n\n#define ACTION_GET (1<<0)\n#define ACTION_GET_ALL (1<<1)\n#define ACTION_GET_REGEXP (1<<2)\n#define ACTION_REPLACE_ALL (1<<3)\n#define ACTION_ADD (1<<4)\n#define ACTION_UNSET (1<<5)\n#define ACTION_UNSET_ALL (1<<6)\n#define ACTION_RENAME_SECTION (1<<7)\n#define ACTION_REMOVE_SECTION (1<<8)\n#define ACTION_LIST (1<<9)\n#define ACTION_EDIT (1<<10)\n#define ACTION_SET (1<<11)\n#define ACTION_SET_ALL (1<<12)\n#define ACTION_GET_COLOR (1<<13)\n#define ACTION_GET_COLORBOOL (1<<14)\n#define ACTION_GET_URLMATCH (1<<15)\n\n/*\n * The actions \"ACTION_LIST | ACTION_GET_*\" which may produce more than\n * one line of output and which should therefore be paged.\n */\n#define PAGING_ACTIONS (ACTION_LIST | ACTION_GET_ALL | \\\n\t\t\tACTION_GET_REGEXP | ACTION_GET_URLMATCH)\n\n#define TYPE_BOOL\t\t1\n#define TYPE_INT\t\t2\n#define TYPE_BOOL_OR_INT\t3\n#define TYPE_PATH\t\t4\n#define TYPE_EXPIRY_DATE\t5\n#define TYPE_COLOR\t\t6\n#define TYPE_BOOL_OR_STR\t7\n\n#define OPT_CALLBACK_VALUE(s, l, v, h, i) \\\n\t{ OPTION_CALLBACK, (s), (l), (v), NULL, (h), PARSE_OPT_NOARG | \\\n\tPARSE_OPT_NONEG, option_parse_type, (i) }\n\nstatic NORETURN void usage_builtin_config(void);\n\nstatic int option_parse_type(const struct option *opt, const char *arg,\n\t\t\t     int unset)\n{\n\tint new_type, *to_type;\n\n\tif (unset) {\n\t\t*((int *) opt->value) = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * To support '--<type>' style flags, begin with new_type equal to\n\t * opt->defval.\n\t */\n\tnew_type = opt->defval;\n\tif (!new_type) {\n\t\tif (!strcmp(arg, \"bool\"))\n\t\t\tnew_type = TYPE_BOOL;\n\t\telse if (!strcmp(arg, \"int\"))\n\t\t\tnew_type = TYPE_INT;\n\t\telse if (!strcmp(arg, \"bool-or-int\"))\n\t\t\tnew_type = TYPE_BOOL_OR_INT;\n\t\telse if (!strcmp(arg, \"bool-or-str\"))\n\t\t\tnew_type = TYPE_BOOL_OR_STR;\n\t\telse if (!strcmp(arg, \"path\"))\n\t\t\tnew_type = TYPE_PATH;\n\t\telse if (!strcmp(arg, \"expiry-date\"))\n\t\t\tnew_type = TYPE_EXPIRY_DATE;\n\t\telse if (!strcmp(arg, \"color\"))\n\t\t\tnew_type = TYPE_COLOR;\n\t\telse\n\t\t\tdie(_(\"unrecognized --type argument, %s\"), arg);\n\t}\n\n\tto_type = opt->value;\n\tif (*to_type && *to_type != new_type) {\n\t\t/*\n\t\t * Complain when there is a new type not equal to the old type.\n\t\t * This allows for combinations like '--int --type=int' and\n\t\t * '--type=int --type=int', but disallows ones like '--type=bool\n\t\t * --int' and '--type=bool\n\t\t * --type=int'.\n\t\t */\n\t\terror(_(\"only one type at a time\"));\n\t\tusage_builtin_config();\n\t}\n\t*to_type = new_type;\n\n\treturn 0;\n}\n\nstatic struct option builtin_config_options[] = {\n\tOPT_GROUP(N_(\"Config file location\")),\n\tOPT_BOOL(0, \"global\", &use_global_config, N_(\"use global config file\")),\n\tOPT_BOOL(0, \"system\", &use_system_config, N_(\"use system config file\")),\n\tOPT_BOOL(0, \"local\", &use_local_config, N_(\"use repository config file\")),\n\tOPT_BOOL(0, \"worktree\", &use_worktree_config, N_(\"use per-worktree config file\")),\n\tOPT_STRING('f', \"file\", &given_config_source.file, N_(\"file\"), N_(\"use given config file\")),\n\tOPT_STRING(0, \"blob\", &given_config_source.blob, N_(\"blob-id\"), N_(\"read config from given blob object\")),\n\tOPT_GROUP(N_(\"Action\")),\n\tOPT_BIT(0, \"get\", &actions, N_(\"get value: name [value-pattern]\"), ACTION_GET),\n\tOPT_BIT(0, \"get-all\", &actions, N_(\"get all values: key [value-pattern]\"), ACTION_GET_ALL),\n\tOPT_BIT(0, \"get-regexp\", &actions, N_(\"get values for regexp: name-regex [value-pattern]\"), ACTION_GET_REGEXP),\n\tOPT_BIT(0, \"get-urlmatch\", &actions, N_(\"get value specific for the URL: section[.var] URL\"), ACTION_GET_URLMATCH),\n\tOPT_BIT(0, \"replace-all\", &actions, N_(\"replace all matching variables: name value [value-pattern]\"), ACTION_REPLACE_ALL),\n\tOPT_BIT(0, \"add\", &actions, N_(\"add a new variable: name value\"), ACTION_ADD),\n\tOPT_BIT(0, \"unset\", &actions, N_(\"remove a variable: name [value-pattern]\"), ACTION_UNSET),\n\tOPT_BIT(0, \"unset-all\", &actions, N_(\"remove all matches: name [value-pattern]\"), ACTION_UNSET_ALL),\n\tOPT_BIT(0, \"rename-section\", &actions, N_(\"rename section: old-name new-name\"), ACTION_RENAME_SECTION),\n\tOPT_BIT(0, \"remove-section\", &actions, N_(\"remove a section: name\"), ACTION_REMOVE_SECTION),\n\tOPT_BIT('l', \"list\", &actions, N_(\"list all\"), ACTION_LIST),\n\tOPT_BOOL(0, \"fixed-value\", &fixed_value, N_(\"use string equality when comparing values to 'value-pattern'\")),\n\tOPT_BIT('e', \"edit\", &actions, N_(\"open an editor\"), ACTION_EDIT),\n\tOPT_BIT(0, \"get-color\", &actions, N_(\"find the color configured: slot [default]\"), ACTION_GET_COLOR),\n\tOPT_BIT(0, \"get-colorbool\", &actions, N_(\"find the color setting: slot [stdout-is-tty]\"), ACTION_GET_COLORBOOL),\n\tOPT_GROUP(N_(\"Type\")),\n\tOPT_CALLBACK('t', \"type\", &type, N_(\"type\"), N_(\"value is given this type\"), option_parse_type),\n\tOPT_CALLBACK_VALUE(0, \"bool\", &type, N_(\"value is \\\"true\\\" or \\\"false\\\"\"), TYPE_BOOL),\n\tOPT_CALLBACK_VALUE(0, \"int\", &type, N_(\"value is decimal number\"), TYPE_INT),\n\tOPT_CALLBACK_VALUE(0, \"bool-or-int\", &type, N_(\"value is --bool or --int\"), TYPE_BOOL_OR_INT),\n\tOPT_CALLBACK_VALUE(0, \"bool-or-str\", &type, N_(\"value is --bool or string\"), TYPE_BOOL_OR_STR),\n\tOPT_CALLBACK_VALUE(0, \"path\", &type, N_(\"value is a path (file or directory name)\"), TYPE_PATH),\n\tOPT_CALLBACK_VALUE(0, \"expiry-date\", &type, N_(\"value is an expiry date\"), TYPE_EXPIRY_DATE),\n\tOPT_GROUP(N_(\"Other\")),\n\tOPT_BOOL('z', \"null\", &end_nul, N_(\"terminate values with NUL byte\")),\n\tOPT_BOOL(0, \"name-only\", &omit_values, N_(\"show variable names only\")),\n\tOPT_BOOL(0, \"includes\", &respect_includes_opt, N_(\"respect include directives on lookup\")),\n\tOPT_BOOL(0, \"show-origin\", &show_origin, N_(\"show origin of config (file, standard input, blob, command line)\")),\n\tOPT_BOOL(0, \"show-scope\", &show_scope, N_(\"show scope of config (worktree, local, global, system, command)\")),\n\tOPT_STRING(0, \"default\", &default_value, N_(\"value\"), N_(\"with --get, use default value when missing entry\")),\n\tOPT_STRING(0, \"comment\", &comment, N_(\"value\"), N_(\"human-readable comment string (# will be prepended as needed)\")),\n\tOPT_END(),\n};\n\nstatic NORETURN void usage_builtin_config(void)\n{\n\tusage_with_options(builtin_config_usage, builtin_config_options);\n}\n\nstatic void check_argc(int argc, int min, int max)\n{\n\tif (argc >= min && argc <= max)\n\t\treturn;\n\tif (min == max)\n\t\terror(_(\"wrong number of arguments, should be %d\"), min);\n\telse\n\t\terror(_(\"wrong number of arguments, should be from %d to %d\"),\n\t\t      min, max);\n\tusage_builtin_config();\n}\n\nstatic void show_config_origin(const struct key_value_info *kvi,\n\t\t\t       struct strbuf *buf)\n{\n\tconst char term = end_nul ? '\\0' : '\\t';\n\n\tstrbuf_addstr(buf, config_origin_type_name(kvi->origin_type));\n\tstrbuf_addch(buf, ':');\n\tif (end_nul)\n\t\tstrbuf_addstr(buf, kvi->filename ? kvi->filename : \"\");\n\telse\n\t\tquote_c_style(kvi->filename ? kvi->filename : \"\", buf, NULL, 0);\n\tstrbuf_addch(buf, term);\n}\n\nstatic void show_config_scope(const struct key_value_info *kvi,\n\t\t\t      struct strbuf *buf)\n{\n\tconst char term = end_nul ? '\\0' : '\\t';\n\tconst char *scope = config_scope_name(kvi->scope);\n\n\tstrbuf_addstr(buf, N_(scope));\n\tstrbuf_addch(buf, term);\n}\n\nstatic int show_all_config(const char *key_, const char *value_,\n\t\t\t   const struct config_context *ctx,\n\t\t\t   void *cb UNUSED)\n{\n\tconst struct key_value_info *kvi = ctx->kvi;\n\n\tif (show_origin || show_scope) {\n\t\tstruct strbuf buf = STRBUF_INIT;\n\t\tif (show_scope)\n\t\t\tshow_config_scope(kvi, &buf);\n\t\tif (show_origin)\n\t\t\tshow_config_origin(kvi, &buf);\n\t\t/* Use fwrite as \"buf\" can contain \\0's if \"end_null\" is set. */\n\t\tfwrite(buf.buf, 1, buf.len, stdout);\n\t\tstrbuf_release(&buf);\n\t}\n\tif (!omit_values && value_)\n\t\tprintf(\"%s%c%s%c\", key_, delim, value_, term);\n\telse\n\t\tprintf(\"%s%c\", key_, term);\n\treturn 0;\n}\n\nstruct strbuf_list {\n\tstruct strbuf *items;\n\tint nr;\n\tint alloc;\n};\n\nstatic int format_config(struct strbuf *buf, const char *key_,\n\t\t\t const char *value_, const struct key_value_info *kvi)\n{\n\tif (show_scope)\n\t\tshow_config_scope(kvi, buf);\n\tif (show_origin)\n\t\tshow_config_origin(kvi, buf);\n\tif (show_keys)\n\t\tstrbuf_addstr(buf, key_);\n\tif (!omit_values) {\n\t\tif (show_keys)\n\t\t\tstrbuf_addch(buf, key_delim);\n\n\t\tif (type == TYPE_INT)\n\t\t\tstrbuf_addf(buf, \"%\"PRId64,\n\t\t\t\t    git_config_int64(key_, value_ ? value_ : \"\", kvi));\n\t\telse if (type == TYPE_BOOL)\n\t\t\tstrbuf_addstr(buf, git_config_bool(key_, value_) ?\n\t\t\t\t      \"true\" : \"false\");\n\t\telse if (type == TYPE_BOOL_OR_INT) {\n\t\t\tint is_bool, v;\n\t\t\tv = git_config_bool_or_int(key_, value_, kvi,\n\t\t\t\t\t\t   &is_bool);\n\t\t\tif (is_bool)\n\t\t\t\tstrbuf_addstr(buf, v ? \"true\" : \"false\");\n\t\t\telse\n\t\t\t\tstrbuf_addf(buf, \"%d\", v);\n\t\t} else if (type == TYPE_BOOL_OR_STR) {\n\t\t\tint v = git_parse_maybe_bool(value_);\n\t\t\tif (v < 0)\n\t\t\t\tstrbuf_addstr(buf, value_);\n\t\t\telse\n\t\t\t\tstrbuf_addstr(buf, v ? \"true\" : \"false\");\n\t\t} else if (type == TYPE_PATH) {\n\t\t\tconst char *v;\n\t\t\tif (git_config_pathname(&v, key_, value_) < 0)\n\t\t\t\treturn -1;\n\t\t\tstrbuf_addstr(buf, v);\n\t\t\tfree((char *)v);\n\t\t} else if (type == TYPE_EXPIRY_DATE) {\n\t\t\ttimestamp_t t;\n\t\t\tif (git_config_expiry_date(&t, key_, value_) < 0)\n\t\t\t\treturn -1;\n\t\t\tstrbuf_addf(buf, \"%\"PRItime, t);\n\t\t} else if (type == TYPE_COLOR) {\n\t\t\tchar v[COLOR_MAXLEN];\n\t\t\tif (git_config_color(v, key_, value_) < 0)\n\t\t\t\treturn -1;\n\t\t\tstrbuf_addstr(buf, v);\n\t\t} else if (value_) {\n\t\t\tstrbuf_addstr(buf, value_);\n\t\t} else {\n\t\t\t/* Just show the key name; back out delimiter */\n\t\t\tif (show_keys)\n\t\t\t\tstrbuf_setlen(buf, buf->len - 1);\n\t\t}\n\t}\n\tstrbuf_addch(buf, term);\n\treturn 0;\n}\n\nstatic int collect_config(const char *key_, const char *value_,\n\t\t\t  const struct config_context *ctx, void *cb)\n{\n\tstruct strbuf_list *values = cb;\n\tconst struct key_value_info *kvi = ctx->kvi;\n\n\tif (!use_key_regexp && strcmp(key_, key))\n\t\treturn 0;\n\tif (use_key_regexp && regexec(key_regexp, key_, 0, NULL, 0))\n\t\treturn 0;\n\tif (fixed_value && strcmp(value_pattern, (value_?value_:\"\")))\n\t\treturn 0;\n\tif (regexp != NULL &&\n\t    (do_not_match ^ !!regexec(regexp, (value_?value_:\"\"), 0, NULL, 0)))\n\t\treturn 0;\n\n\tALLOC_GROW(values->items, values->nr + 1, values->alloc);\n\tstrbuf_init(&values->items[values->nr], 0);\n\n\treturn format_config(&values->items[values->nr++], key_, value_, kvi);\n}\n\nstatic int get_value(const char *key_, const char *regex_, unsigned flags)\n{\n\tint ret = CONFIG_GENERIC_ERROR;\n\tstruct strbuf_list values = {NULL};\n\tint i;\n\n\tif (use_key_regexp) {\n\t\tchar *tl;\n\n\t\t/*\n\t\t * NEEDSWORK: this naive pattern lowercasing obviously does not\n\t\t * work for more complex patterns like \"^[^.]*Foo.*bar\".\n\t\t * Perhaps we should deprecate this altogether someday.\n\t\t */\n\n\t\tkey = xstrdup(key_);\n\t\tfor (tl = key + strlen(key) - 1;\n\t\t     tl >= key && *tl != '.';\n\t\t     tl--)\n\t\t\t*tl = tolower(*tl);\n\t\tfor (tl = key; *tl && *tl != '.'; tl++)\n\t\t\t*tl = tolower(*tl);\n\n\t\tkey_regexp = (regex_t*)xmalloc(sizeof(regex_t));\n\t\tif (regcomp(key_regexp, key, REG_EXTENDED)) {\n\t\t\terror(_(\"invalid key pattern: %s\"), key_);\n\t\t\tFREE_AND_NULL(key_regexp);\n\t\t\tret = CONFIG_INVALID_PATTERN;\n\t\t\tgoto free_strings;\n\t\t}\n\t} else {\n\t\tif (git_config_parse_key(key_, &key, NULL)) {\n\t\t\tret = CONFIG_INVALID_KEY;\n\t\t\tgoto free_strings;\n\t\t}\n\t}\n\n\tif (regex_ && (flags & CONFIG_FLAGS_FIXED_VALUE))\n\t\tvalue_pattern = regex_;\n\telse if (regex_) {\n\t\tif (regex_[0] == '!') {\n\t\t\tdo_not_match = 1;\n\t\t\tregex_++;\n\t\t}\n\n\t\tregexp = (regex_t*)xmalloc(sizeof(regex_t));\n\t\tif (regcomp(regexp, regex_, REG_EXTENDED)) {\n\t\t\terror(_(\"invalid pattern: %s\"), regex_);\n\t\t\tFREE_AND_NULL(regexp);\n\t\t\tret = CONFIG_INVALID_PATTERN;\n\t\t\tgoto free_strings;\n\t\t}\n\t}\n\n\tconfig_with_options(collect_config, &values,\n\t\t\t    &given_config_source, the_repository,\n\t\t\t    &config_options);\n\n\tif (!values.nr && default_value) {\n\t\tstruct key_value_info kvi = KVI_INIT;\n\t\tstruct strbuf *item;\n\n\t\tkvi_from_param(&kvi);\n\t\tALLOC_GROW(values.items, values.nr + 1, values.alloc);\n\t\titem = &values.items[values.nr++];\n\t\tstrbuf_init(item, 0);\n\t\tif (format_config(item, key_, default_value, &kvi) < 0)\n\t\t\tdie(_(\"failed to format default config value: %s\"),\n\t\t\t\tdefault_value);\n\t}\n\n\tret = !values.nr;\n\n\tfor (i = 0; i < values.nr; i++) {\n\t\tstruct strbuf *buf = values.items + i;\n\t\tif (do_all || i == values.nr - 1)\n\t\t\tfwrite(buf->buf, 1, buf->len, stdout);\n\t\tstrbuf_release(buf);\n\t}\n\tfree(values.items);\n\nfree_strings:\n\tfree(key);\n\tif (key_regexp) {\n\t\tregfree(key_regexp);\n\t\tfree(key_regexp);\n\t}\n\tif (regexp) {\n\t\tregfree(regexp);\n\t\tfree(regexp);\n\t}\n\n\treturn ret;\n}\n\nstatic char *normalize_value(const char *key, const char *value,\n\t\t\t     struct key_value_info *kvi)\n{\n\tif (!value)\n\t\treturn NULL;\n\n\tif (type == 0 || type == TYPE_PATH || type == TYPE_EXPIRY_DATE)\n\t\t/*\n\t\t * We don't do normalization for TYPE_PATH here: If\n\t\t * the path is like ~/foobar/, we prefer to store\n\t\t * \"~/foobar/\" in the config file, and to expand the ~\n\t\t * when retrieving the value.\n\t\t * Also don't do normalization for expiry dates.\n\t\t */\n\t\treturn xstrdup(value);\n\tif (type == TYPE_INT)\n\t\treturn xstrfmt(\"%\"PRId64, git_config_int64(key, value, kvi));\n\tif (type == TYPE_BOOL)\n\t\treturn xstrdup(git_config_bool(key, value) ?  \"true\" : \"false\");\n\tif (type == TYPE_BOOL_OR_INT) {\n\t\tint is_bool, v;\n\t\tv = git_config_bool_or_int(key, value, kvi, &is_bool);\n\t\tif (!is_bool)\n\t\t\treturn xstrfmt(\"%d\", v);\n\t\telse\n\t\t\treturn xstrdup(v ? \"true\" : \"false\");\n\t}\n\tif (type == TYPE_BOOL_OR_STR) {\n\t\tint v = git_parse_maybe_bool(value);\n\t\tif (v < 0)\n\t\t\treturn xstrdup(value);\n\t\telse\n\t\t\treturn xstrdup(v ? \"true\" : \"false\");\n\t}\n\tif (type == TYPE_COLOR) {\n\t\tchar v[COLOR_MAXLEN];\n\t\tif (git_config_color(v, key, value))\n\t\t\tdie(_(\"cannot parse color '%s'\"), value);\n\n\t\t/*\n\t\t * The contents of `v` now contain an ANSI escape\n\t\t * sequence, not suitable for including within a\n\t\t * configuration file. Treat the above as a\n\t\t * \"sanity-check\", and return the given value, which we\n\t\t * know is representable as valid color code.\n\t\t */\n\t\treturn xstrdup(value);\n\t}\n\n\tBUG(\"cannot normalize type %d\", type);\n}\n\nstatic int get_color_found;\nstatic const char *get_color_slot;\nstatic const char *get_colorbool_slot;\nstatic char parsed_color[COLOR_MAXLEN];\n\nstatic int git_get_color_config(const char *var, const char *value,\n\t\t\t\tconst struct config_context *ctx UNUSED,\n\t\t\t\tvoid *cb UNUSED)\n{\n\tif (!strcmp(var, get_color_slot)) {\n\t\tif (!value)\n\t\t\tconfig_error_nonbool(var);\n\t\tif (color_parse(value, parsed_color) < 0)\n\t\t\treturn -1;\n\t\tget_color_found = 1;\n\t}\n\treturn 0;\n}\n\nstatic void get_color(const char *var, const char *def_color)\n{\n\tget_color_slot = var;\n\tget_color_found = 0;\n\tparsed_color[0] = '\\0';\n\tconfig_with_options(git_get_color_config, NULL,\n\t\t\t    &given_config_source, the_repository,\n\t\t\t    &config_options);\n\n\tif (!get_color_found && def_color) {\n\t\tif (color_parse(def_color, parsed_color) < 0)\n\t\t\tdie(_(\"unable to parse default color value\"));\n\t}\n\n\tfputs(parsed_color, stdout);\n}\n\nstatic int get_colorbool_found;\nstatic int get_diff_color_found;\nstatic int get_color_ui_found;\nstatic int git_get_colorbool_config(const char *var, const char *value,\n\t\t\t\t    const struct config_context *ctx UNUSED,\n\t\t\t\t    void *data UNUSED)\n{\n\tif (!strcmp(var, get_colorbool_slot))\n\t\tget_colorbool_found = git_config_colorbool(var, value);\n\telse if (!strcmp(var, \"diff.color\"))\n\t\tget_diff_color_found = git_config_colorbool(var, value);\n\telse if (!strcmp(var, \"color.ui\"))\n\t\tget_color_ui_found = git_config_colorbool(var, value);\n\treturn 0;\n}\n\nstatic int get_colorbool(const char *var, int print)\n{\n\tget_colorbool_slot = var;\n\tget_colorbool_found = -1;\n\tget_diff_color_found = -1;\n\tget_color_ui_found = -1;\n\tconfig_with_options(git_get_colorbool_config, NULL,\n\t\t\t    &given_config_source, the_repository,\n\t\t\t    &config_options);\n\n\tif (get_colorbool_found < 0) {\n\t\tif (!strcmp(get_colorbool_slot, \"color.diff\"))\n\t\t\tget_colorbool_found = get_diff_color_found;\n\t\tif (get_colorbool_found < 0)\n\t\t\tget_colorbool_found = get_color_ui_found;\n\t}\n\n\tif (get_colorbool_found < 0)\n\t\t/* default value if none found in config */\n\t\tget_colorbool_found = GIT_COLOR_AUTO;\n\n\tget_colorbool_found = want_color(get_colorbool_found);\n\n\tif (print) {\n\t\tprintf(\"%s\\n\", get_colorbool_found ? \"true\" : \"false\");\n\t\treturn 0;\n\t} else\n\t\treturn get_colorbool_found ? 0 : 1;\n}\n\nstatic void check_write(void)\n{\n\tif (!given_config_source.file && !startup_info->have_repository)\n\t\tdie(_(\"not in a git directory\"));\n\n\tif (given_config_source.use_stdin)\n\t\tdie(_(\"writing to stdin is not supported\"));\n\n\tif (given_config_source.blob)\n\t\tdie(_(\"writing config blobs is not supported\"));\n}\n\nstruct urlmatch_current_candidate_value {\n\tchar value_is_null;\n\tstruct strbuf value;\n\tstruct key_value_info kvi;\n};\n\nstatic int urlmatch_collect_fn(const char *var, const char *value,\n\t\t\t       const struct config_context *ctx,\n\t\t\t       void *cb)\n{\n\tstruct string_list *values = cb;\n\tstruct string_list_item *item = string_list_insert(values, var);\n\tstruct urlmatch_current_candidate_value *matched = item->util;\n\tconst struct key_value_info *kvi = ctx->kvi;\n\n\tif (!matched) {\n\t\tmatched = xmalloc(sizeof(*matched));\n\t\tstrbuf_init(&matched->value, 0);\n\t\titem->util = matched;\n\t} else {\n\t\tstrbuf_reset(&matched->value);\n\t}\n\tmatched->kvi = *kvi;\n\n\tif (value) {\n\t\tstrbuf_addstr(&matched->value, value);\n\t\tmatched->value_is_null = 0;\n\t} else {\n\t\tmatched->value_is_null = 1;\n\t}\n\treturn 0;\n}\n\nstatic int get_urlmatch(const char *var, const char *url)\n{\n\tint ret;\n\tchar *section_tail;\n\tstruct string_list_item *item;\n\tstruct urlmatch_config config = URLMATCH_CONFIG_INIT;\n\tstruct string_list values = STRING_LIST_INIT_DUP;\n\n\tconfig.collect_fn = urlmatch_collect_fn;\n\tconfig.cascade_fn = NULL;\n\tconfig.cb = &values;\n\n\tif (!url_normalize(url, &config.url))\n\t\tdie(\"%s\", config.url.err);\n\n\tconfig.section = xstrdup_tolower(var);\n\tsection_tail = strchr(config.section, '.');\n\tif (section_tail) {\n\t\t*section_tail = '\\0';\n\t\tconfig.key = section_tail + 1;\n\t\tshow_keys = 0;\n\t} else {\n\t\tconfig.key = NULL;\n\t\tshow_keys = 1;\n\t}\n\n\tconfig_with_options(urlmatch_config_entry, &config,\n\t\t\t    &given_config_source, the_repository,\n\t\t\t    &config_options);\n\n\tret = !values.nr;\n\n\tfor_each_string_list_item(item, &values) {\n\t\tstruct urlmatch_current_candidate_value *matched = item->util;\n\t\tstruct strbuf buf = STRBUF_INIT;\n\n\t\tformat_config(&buf, item->string,\n\t\t\t      matched->value_is_null ? NULL : matched->value.buf,\n\t\t\t      &matched->kvi);\n\t\tfwrite(buf.buf, 1, buf.len, stdout);\n\t\tstrbuf_release(&buf);\n\n\t\tstrbuf_release(&matched->value);\n\t}\n\turlmatch_config_release(&config);\n\tstring_list_clear(&values, 1);\n\tfree(config.url.url);\n\n\tfree((void *)config.section);\n\treturn ret;\n}\n\nstatic char *default_user_config(void)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstrbuf_addf(&buf,\n\t\t    _(\"# This is Git's per-user configuration file.\\n\"\n\t\t      \"[user]\\n\"\n\t\t      \"# Please adapt and uncomment the following lines:\\n\"\n\t\t      \"#\tname = %s\\n\"\n\t\t      \"#\temail = %s\\n\"),\n\t\t    ident_default_name(),\n\t\t    ident_default_email());\n\treturn strbuf_detach(&buf, NULL);\n}\n\nint cmd_config(int argc, const char **argv, const char *prefix)\n{\n\tint nongit = !startup_info->have_repository;\n\tchar *value = NULL;\n\tint flags = 0;\n\tint ret = 0;\n\tstruct key_value_info default_kvi = KVI_INIT;\n\n\tgiven_config_source.file = xstrdup_or_null(getenv(CONFIG_ENVIRONMENT));\n\n\targc = parse_options(argc, argv, prefix, builtin_config_options,\n\t\t\t     builtin_config_usage,\n\t\t\t     PARSE_OPT_STOP_AT_NON_OPTION);\n\n\tif (use_global_config + use_system_config + use_local_config +\n\t    use_worktree_config +\n\t    !!given_config_source.file + !!given_config_source.blob > 1) {\n\t\terror(_(\"only one config file at a time\"));\n\t\tusage_builtin_config();\n\t}\n\n\tif (nongit) {\n\t\tif (use_local_config)\n\t\t\tdie(_(\"--local can only be used inside a git repository\"));\n\t\tif (given_config_source.blob)\n\t\t\tdie(_(\"--blob can only be used inside a git repository\"));\n\t\tif (use_worktree_config)\n\t\t\tdie(_(\"--worktree can only be used inside a git repository\"));\n\n\t}\n\n\tif (given_config_source.file &&\n\t\t\t!strcmp(given_config_source.file, \"-\")) {\n\t\tgiven_config_source.file = NULL;\n\t\tgiven_config_source.use_stdin = 1;\n\t\tgiven_config_source.scope = CONFIG_SCOPE_COMMAND;\n\t}\n\n\tif (use_global_config) {\n\t\tgiven_config_source.file = git_global_config();\n\t\tif (!given_config_source.file)\n\t\t\t/*\n\t\t\t * It is unknown if HOME/.gitconfig exists, so\n\t\t\t * we do not know if we should write to XDG\n\t\t\t * location; error out even if XDG_CONFIG_HOME\n\t\t\t * is set and points at a sane location.\n\t\t\t */\n\t\t\tdie(_(\"$HOME not set\"));\n\t\tgiven_config_source.scope = CONFIG_SCOPE_GLOBAL;\n\t} else if (use_system_config) {\n\t\tgiven_config_source.file = git_system_config();\n\t\tgiven_config_source.scope = CONFIG_SCOPE_SYSTEM;\n\t} else if (use_local_config) {\n\t\tgiven_config_source.file = git_pathdup(\"config\");\n\t\tgiven_config_source.scope = CONFIG_SCOPE_LOCAL;\n\t} else if (use_worktree_config) {\n\t\tstruct worktree **worktrees = get_worktrees();\n\t\tif (the_repository->repository_format_worktree_config)\n\t\t\tgiven_config_source.file = git_pathdup(\"config.worktree\");\n\t\telse if (worktrees[0] && worktrees[1])\n\t\t\tdie(_(\"--worktree cannot be used with multiple \"\n\t\t\t      \"working trees unless the config\\n\"\n\t\t\t      \"extension worktreeConfig is enabled. \"\n\t\t\t      \"Please read \\\"CONFIGURATION FILE\\\"\\n\"\n\t\t\t      \"section in \\\"git help worktree\\\" for details\"));\n\t\telse\n\t\t\tgiven_config_source.file = git_pathdup(\"config\");\n\t\tgiven_config_source.scope = CONFIG_SCOPE_LOCAL;\n\t\tfree_worktrees(worktrees);\n\t} else if (given_config_source.file) {\n\t\tif (!is_absolute_path(given_config_source.file) && prefix)\n\t\t\tgiven_config_source.file =\n\t\t\t\tprefix_filename(prefix, given_config_source.file);\n\t\tgiven_config_source.scope = CONFIG_SCOPE_COMMAND;\n\t} else if (given_config_source.blob) {\n\t\tgiven_config_source.scope = CONFIG_SCOPE_COMMAND;\n\t}\n\n\tif (respect_includes_opt == -1)\n\t\tconfig_options.respect_includes = !given_config_source.file;\n\telse\n\t\tconfig_options.respect_includes = respect_includes_opt;\n\tif (!nongit) {\n\t\tconfig_options.commondir = get_git_common_dir();\n\t\tconfig_options.git_dir = get_git_dir();\n\t}\n\n\tif (end_nul) {\n\t\tterm = '\\0';\n\t\tdelim = '\\n';\n\t\tkey_delim = '\\n';\n\t}\n\n\tif ((actions & (ACTION_GET_COLOR|ACTION_GET_COLORBOOL)) && type) {\n\t\terror(_(\"--get-color and variable type are incoherent\"));\n\t\tusage_builtin_config();\n\t}\n\n\tif (HAS_MULTI_BITS(actions)) {\n\t\terror(_(\"only one action at a time\"));\n\t\tusage_builtin_config();\n\t}\n\tif (actions == 0)\n\t\tswitch (argc) {\n\t\tcase 1: actions = ACTION_GET; break;\n\t\tcase 2: actions = ACTION_SET; break;\n\t\tcase 3: actions = ACTION_SET_ALL; break;\n\t\tdefault:\n\t\t\tusage_builtin_config();\n\t\t}\n\tif (omit_values &&\n\t    !(actions == ACTION_LIST || actions == ACTION_GET_REGEXP)) {\n\t\terror(_(\"--name-only is only applicable to --list or --get-regexp\"));\n\t\tusage_builtin_config();\n\t}\n\n\tif (show_origin && !(actions &\n\t\t(ACTION_GET|ACTION_GET_ALL|ACTION_GET_REGEXP|ACTION_LIST))) {\n\t\terror(_(\"--show-origin is only applicable to --get, --get-all, \"\n\t\t\t\"--get-regexp, and --list\"));\n\t\tusage_builtin_config();\n\t}\n\n\tif (default_value && !(actions & ACTION_GET)) {\n\t\terror(_(\"--default is only applicable to --get\"));\n\t\tusage_builtin_config();\n\t}\n\n\tif (comment &&\n\t    !(actions & (ACTION_ADD|ACTION_SET|ACTION_SET_ALL|ACTION_REPLACE_ALL))) {\n\t\terror(_(\"--comment is only applicable to add/set/replace operations\"));\n\t\tusage_builtin_config();\n\t}\n\n\t/* check usage of --fixed-value */\n\tif (fixed_value) {\n\t\tint allowed_usage = 0;\n\n\t\tswitch (actions) {\n\t\t/* git config --get <name> <value-pattern> */\n\t\tcase ACTION_GET:\n\t\t/* git config --get-all <name> <value-pattern> */\n\t\tcase ACTION_GET_ALL:\n\t\t/* git config --get-regexp <name-pattern> <value-pattern> */\n\t\tcase ACTION_GET_REGEXP:\n\t\t/* git config --unset <name> <value-pattern> */\n\t\tcase ACTION_UNSET:\n\t\t/* git config --unset-all <name> <value-pattern> */\n\t\tcase ACTION_UNSET_ALL:\n\t\t\tallowed_usage = argc > 1 && !!argv[1];\n\t\t\tbreak;\n\n\t\t/* git config <name> <value> <value-pattern> */\n\t\tcase ACTION_SET_ALL:\n\t\t/* git config --replace-all <name> <value> <value-pattern> */\n\t\tcase ACTION_REPLACE_ALL:\n\t\t\tallowed_usage = argc > 2 && !!argv[2];\n\t\t\tbreak;\n\n\t\t/* other options don't allow --fixed-value */\n\t\t}\n\n\t\tif (!allowed_usage) {\n\t\t\terror(_(\"--fixed-value only applies with 'value-pattern'\"));\n\t\t\tusage_builtin_config();\n\t\t}\n\n\t\tflags |= CONFIG_FLAGS_FIXED_VALUE;\n\t}\n\n\tcomment = git_config_prepare_comment_string(comment);\n\n\tif (actions & PAGING_ACTIONS)\n\t\tsetup_auto_pager(\"config\", 1);\n\n\tif (actions == ACTION_LIST) {\n\t\tcheck_argc(argc, 0, 0);\n\t\tif (config_with_options(show_all_config, NULL,\n\t\t\t\t\t&given_config_source, the_repository,\n\t\t\t\t\t&config_options) < 0) {\n\t\t\tif (given_config_source.file)\n\t\t\t\tdie_errno(_(\"unable to read config file '%s'\"),\n\t\t\t\t\t  given_config_source.file);\n\t\t\telse\n\t\t\t\tdie(_(\"error processing config file(s)\"));\n\t\t}\n\t}\n\telse if (actions == ACTION_EDIT) {\n\t\tchar *config_file;\n\n\t\tcheck_argc(argc, 0, 0);\n\t\tif (!given_config_source.file && nongit)\n\t\t\tdie(_(\"not in a git directory\"));\n\t\tif (given_config_source.use_stdin)\n\t\t\tdie(_(\"editing stdin is not supported\"));\n\t\tif (given_config_source.blob)\n\t\t\tdie(_(\"editing blobs is not supported\"));\n\t\tgit_config(git_default_config, NULL);\n\t\tconfig_file = given_config_source.file ?\n\t\t\t\txstrdup(given_config_source.file) :\n\t\t\t\tgit_pathdup(\"config\");\n\t\tif (use_global_config) {\n\t\t\tint fd = open(config_file, O_CREAT | O_EXCL | O_WRONLY, 0666);\n\t\t\tif (fd >= 0) {\n\t\t\t\tchar *content = default_user_config();\n\t\t\t\twrite_str_in_full(fd, content);\n\t\t\t\tfree(content);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\telse if (errno != EEXIST)\n\t\t\t\tdie_errno(_(\"cannot create configuration file %s\"), config_file);\n\t\t}\n\t\tlaunch_editor(config_file, NULL, NULL);\n\t\tfree(config_file);\n\t}\n\telse if (actions == ACTION_SET) {\n\t\tcheck_write();\n\t\tcheck_argc(argc, 2, 2);\n\t\tvalue = normalize_value(argv[0], argv[1], &default_kvi);\n\t\tret = git_config_set_in_file_gently(given_config_source.file, argv[0], comment, value);\n\t\tif (ret == CONFIG_NOTHING_SET)\n\t\t\terror(_(\"cannot overwrite multiple values with a single value\\n\"\n\t\t\t\"       Use a regexp, --add or --replace-all to change %s.\"), argv[0]);\n\t}\n\telse if (actions == ACTION_SET_ALL) {\n\t\tcheck_write();\n\t\tcheck_argc(argc, 2, 3);\n\t\tvalue = normalize_value(argv[0], argv[1], &default_kvi);\n\t\tret = git_config_set_multivar_in_file_gently(given_config_source.file,\n\t\t\t\t\t\t\t     argv[0], value, argv[2],\n\t\t\t\t\t\t\t     comment, flags);\n\t}\n\telse if (actions == ACTION_ADD) {\n\t\tcheck_write();\n\t\tcheck_argc(argc, 2, 2);\n\t\tvalue = normalize_value(argv[0], argv[1], &default_kvi);\n\t\tret = git_config_set_multivar_in_file_gently(given_config_source.file,\n\t\t\t\t\t\t\t     argv[0], value,\n\t\t\t\t\t\t\t     CONFIG_REGEX_NONE,\n\t\t\t\t\t\t\t     comment, flags);\n\t}\n\telse if (actions == ACTION_REPLACE_ALL) {\n\t\tcheck_write();\n\t\tcheck_argc(argc, 2, 3);\n\t\tvalue = normalize_value(argv[0], argv[1], &default_kvi);\n\t\tret = git_config_set_multivar_in_file_gently(given_config_source.file,\n\t\t\t\t\t\t\t     argv[0], value, argv[2],\n\t\t\t\t\t\t\t     comment, flags | CONFIG_FLAGS_MULTI_REPLACE);\n\t}\n\telse if (actions == ACTION_GET) {\n\t\tcheck_argc(argc, 1, 2);\n\t\treturn get_value(argv[0], argv[1], flags);\n\t}\n\telse if (actions == ACTION_GET_ALL) {\n\t\tdo_all = 1;\n\t\tcheck_argc(argc, 1, 2);\n\t\treturn get_value(argv[0], argv[1], flags);\n\t}\n\telse if (actions == ACTION_GET_REGEXP) {\n\t\tshow_keys = 1;\n\t\tuse_key_regexp = 1;\n\t\tdo_all = 1;\n\t\tcheck_argc(argc, 1, 2);\n\t\treturn get_value(argv[0], argv[1], flags);\n\t}\n\telse if (actions == ACTION_GET_URLMATCH) {\n\t\tcheck_argc(argc, 2, 2);\n\t\treturn get_urlmatch(argv[0], argv[1]);\n\t}\n\telse if (actions == ACTION_UNSET) {\n\t\tcheck_write();\n\t\tcheck_argc(argc, 1, 2);\n\t\tif (argc == 2)\n\t\t\treturn git_config_set_multivar_in_file_gently(given_config_source.file,\n\t\t\t\t\t\t\t\t      argv[0], NULL, argv[1],\n\t\t\t\t\t\t\t\t      NULL, flags);\n\t\telse\n\t\t\treturn git_config_set_in_file_gently(given_config_source.file,\n\t\t\t\t\t\t\t     argv[0], NULL, NULL);\n\t}\n\telse if (actions == ACTION_UNSET_ALL) {\n\t\tcheck_write();\n\t\tcheck_argc(argc, 1, 2);\n\t\treturn git_config_set_multivar_in_file_gently(given_config_source.file,\n\t\t\t\t\t\t\t      argv[0], NULL, argv[1],\n\t\t\t\t\t\t\t      NULL, flags | CONFIG_FLAGS_MULTI_REPLACE);\n\t}\n\telse if (actions == ACTION_RENAME_SECTION) {\n\t\tcheck_write();\n\t\tcheck_argc(argc, 2, 2);\n\t\tret = git_config_rename_section_in_file(given_config_source.file,\n\t\t\t\t\t\t\targv[0], argv[1]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (!ret)\n\t\t\tdie(_(\"no such section: %s\"), argv[0]);\n\t\telse\n\t\t\tret = 0;\n\t}\n\telse if (actions == ACTION_REMOVE_SECTION) {\n\t\tcheck_write();\n\t\tcheck_argc(argc, 1, 1);\n\t\tret = git_config_rename_section_in_file(given_config_source.file,\n\t\t\t\t\t\t\targv[0], NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (!ret)\n\t\t\tdie(_(\"no such section: %s\"), argv[0]);\n\t\telse\n\t\t\tret = 0;\n\t}\n\telse if (actions == ACTION_GET_COLOR) {\n\t\tcheck_argc(argc, 1, 2);\n\t\tget_color(argv[0], argv[1]);\n\t}\n\telse if (actions == ACTION_GET_COLORBOOL) {\n\t\tcheck_argc(argc, 1, 2);\n\t\tif (argc == 2)\n\t\t\tcolor_stdout_is_tty = git_config_bool(\"command line\", argv[1]);\n\t\treturn get_colorbool(argv[0], argc == 2);\n\t}\n\n\tfree(value);\n\treturn ret;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0015620ddeb2ab31a1bbb41a85eac70c7c548bfb",
  "sha1_ok": true,
  "size": 29770
}
