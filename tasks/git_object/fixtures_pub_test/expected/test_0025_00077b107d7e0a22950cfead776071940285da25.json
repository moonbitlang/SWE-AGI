{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJvYmplY3Qtc3RvcmUuaCIKI2luY2x1ZGUgInJlcG9zaXRvcnkuaCIKI2luY2x1ZGUgIm9iamVjdC5oIgojaW5jbHVkZSAiYmxvYi5oIgojaW5jbHVkZSAidHJlZS5oIgojaW5jbHVkZSAidHJlZS13YWxrLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAiZnNjay5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAidXJsLmgiCiNpbmNsdWRlICJ1dGY4LmgiCiNpbmNsdWRlICJkZWNvcmF0ZS5oIgojaW5jbHVkZSAib2lkc2V0LmgiCiNpbmNsdWRlICJwYWNrZmlsZS5oIgojaW5jbHVkZSAic3VibW9kdWxlLWNvbmZpZy5oIgojaW5jbHVkZSAiY29uZmlnLmgiCiNpbmNsdWRlICJjcmVkZW50aWFsLmgiCiNpbmNsdWRlICJoZWxwLmgiCgpzdGF0aWMgc3RydWN0IG9pZHNldCBnaXRtb2R1bGVzX2ZvdW5kID0gT0lEU0VUX0lOSVQ7CnN0YXRpYyBzdHJ1Y3Qgb2lkc2V0IGdpdG1vZHVsZXNfZG9uZSA9IE9JRFNFVF9JTklUOwoKI2RlZmluZSBGU0NLX0ZBVEFMIC0xCiNkZWZpbmUgRlNDS19JTkZPIC0yCgojZGVmaW5lIEZPUkVBQ0hfTVNHX0lEKEZVTkMpIFwKCS8qIGZhdGFsIGVycm9ycyAqLyBcCglGVU5DKE5VTF9JTl9IRUFERVIsIEZBVEFMKSBcCglGVU5DKFVOVEVSTUlOQVRFRF9IRUFERVIsIEZBVEFMKSBcCgkvKiBlcnJvcnMgKi8gXAoJRlVOQyhCQURfREFURSwgRVJST1IpIFwKCUZVTkMoQkFEX0RBVEVfT1ZFUkZMT1csIEVSUk9SKSBcCglGVU5DKEJBRF9FTUFJTCwgRVJST1IpIFwKCUZVTkMoQkFEX05BTUUsIEVSUk9SKSBcCglGVU5DKEJBRF9PQkpFQ1RfU0hBMSwgRVJST1IpIFwKCUZVTkMoQkFEX1BBUkVOVF9TSEExLCBFUlJPUikgXAoJRlVOQyhCQURfVEFHX09CSkVDVCwgRVJST1IpIFwKCUZVTkMoQkFEX1RJTUVaT05FLCBFUlJPUikgXAoJRlVOQyhCQURfVFJFRSwgRVJST1IpIFwKCUZVTkMoQkFEX1RSRUVfU0hBMSwgRVJST1IpIFwKCUZVTkMoQkFEX1RZUEUsIEVSUk9SKSBcCglGVU5DKERVUExJQ0FURV9FTlRSSUVTLCBFUlJPUikgXAoJRlVOQyhNSVNTSU5HX0FVVEhPUiwgRVJST1IpIFwKCUZVTkMoTUlTU0lOR19DT01NSVRURVIsIEVSUk9SKSBcCglGVU5DKE1JU1NJTkdfRU1BSUwsIEVSUk9SKSBcCglGVU5DKE1JU1NJTkdfR1JBRlQsIEVSUk9SKSBcCglGVU5DKE1JU1NJTkdfTkFNRV9CRUZPUkVfRU1BSUwsIEVSUk9SKSBcCglGVU5DKE1JU1NJTkdfT0JKRUNULCBFUlJPUikgXAoJRlVOQyhNSVNTSU5HX1BBUkVOVCwgRVJST1IpIFwKCUZVTkMoTUlTU0lOR19TUEFDRV9CRUZPUkVfREFURSwgRVJST1IpIFwKCUZVTkMoTUlTU0lOR19TUEFDRV9CRUZPUkVfRU1BSUwsIEVSUk9SKSBcCglGVU5DKE1JU1NJTkdfVEFHLCBFUlJPUikgXAoJRlVOQyhNSVNTSU5HX1RBR19FTlRSWSwgRVJST1IpIFwKCUZVTkMoTUlTU0lOR19UQUdfT0JKRUNULCBFUlJPUikgXAoJRlVOQyhNSVNTSU5HX1RSRUUsIEVSUk9SKSBcCglGVU5DKE1JU1NJTkdfVFJFRV9PQkpFQ1QsIEVSUk9SKSBcCglGVU5DKE1JU1NJTkdfVFlQRSwgRVJST1IpIFwKCUZVTkMoTUlTU0lOR19UWVBFX0VOVFJZLCBFUlJPUikgXAoJRlVOQyhNVUxUSVBMRV9BVVRIT1JTLCBFUlJPUikgXAoJRlVOQyhUQUdfT0JKRUNUX05PVF9UQUcsIEVSUk9SKSBcCglGVU5DKFRSRUVfTk9UX1NPUlRFRCwgRVJST1IpIFwKCUZVTkMoVU5LTk9XTl9UWVBFLCBFUlJPUikgXAoJRlVOQyhaRVJPX1BBRERFRF9EQVRFLCBFUlJPUikgXAoJRlVOQyhHSVRNT0RVTEVTX01JU1NJTkcsIEVSUk9SKSBcCglGVU5DKEdJVE1PRFVMRVNfQkxPQiwgRVJST1IpIFwKCUZVTkMoR0lUTU9EVUxFU19MQVJHRSwgRVJST1IpIFwKCUZVTkMoR0lUTU9EVUxFU19OQU1FLCBFUlJPUikgXAoJRlVOQyhHSVRNT0RVTEVTX1NZTUxJTkssIEVSUk9SKSBcCglGVU5DKEdJVE1PRFVMRVNfVVJMLCBFUlJPUikgXAoJRlVOQyhHSVRNT0RVTEVTX1BBVEgsIEVSUk9SKSBcCglGVU5DKEdJVE1PRFVMRVNfVVBEQVRFLCBFUlJPUikgXAoJLyogd2FybmluZ3MgKi8gXAoJRlVOQyhCQURfRklMRU1PREUsIFdBUk4pIFwKCUZVTkMoRU1QVFlfTkFNRSwgV0FSTikgXAoJRlVOQyhGVUxMX1BBVEhOQU1FLCBXQVJOKSBcCglGVU5DKEhBU19ET1QsIFdBUk4pIFwKCUZVTkMoSEFTX0RPVERPVCwgV0FSTikgXAoJRlVOQyhIQVNfRE9UR0lULCBXQVJOKSBcCglGVU5DKE5VTExfU0hBMSwgV0FSTikgXAoJRlVOQyhaRVJPX1BBRERFRF9GSUxFTU9ERSwgV0FSTikgXAoJRlVOQyhOVUxfSU5fQ09NTUlULCBXQVJOKSBcCgkvKiBpbmZvcyAocmVwb3J0ZWQgYXMgd2FybmluZ3MsIGJ1dCBpZ25vcmVkIGJ5IGRlZmF1bHQpICovIFwKCUZVTkMoR0lUTU9EVUxFU19QQVJTRSwgSU5GTykgXAoJRlVOQyhCQURfVEFHX05BTUUsIElORk8pIFwKCUZVTkMoTUlTU0lOR19UQUdHRVJfRU5UUlksIElORk8pCgojZGVmaW5lIE1TR19JRChpZCwgbXNnX3R5cGUpIEZTQ0tfTVNHXyMjaWQsCmVudW0gZnNja19tc2dfaWQgewoJRk9SRUFDSF9NU0dfSUQoTVNHX0lEKQoJRlNDS19NU0dfTUFYCn07CiN1bmRlZiBNU0dfSUQKCiNkZWZpbmUgU1RSKHgpICN4CiNkZWZpbmUgTVNHX0lEKGlkLCBtc2dfdHlwZSkgeyBTVFIoaWQpLCBOVUxMLCBOVUxMLCBGU0NLXyMjbXNnX3R5cGUgfSwKc3RhdGljIHN0cnVjdCB7Cgljb25zdCBjaGFyICppZF9zdHJpbmc7Cgljb25zdCBjaGFyICpkb3duY2FzZWQ7Cgljb25zdCBjaGFyICpjYW1lbGNhc2VkOwoJaW50IG1zZ190eXBlOwp9IG1zZ19pZF9pbmZvW0ZTQ0tfTVNHX01BWCArIDFdID0gewoJRk9SRUFDSF9NU0dfSUQoTVNHX0lEKQoJeyBOVUxMLCBOVUxMLCBOVUxMLCAtMSB9Cn07CiN1bmRlZiBNU0dfSUQKCnN0YXRpYyB2b2lkIHByZXBhcmVfbXNnX2lkcyh2b2lkKQp7CglpbnQgaTsKCglpZiAobXNnX2lkX2luZm9bMF0uZG93bmNhc2VkKQoJCXJldHVybjsKCgkvKiBjb252ZXJ0IGlkX3N0cmluZyB0byBsb3dlciBjYXNlLCB3aXRob3V0IHVuZGVyc2NvcmVzLiAqLwoJZm9yIChpID0gMDsgaSA8IEZTQ0tfTVNHX01BWDsgaSsrKSB7CgkJY29uc3QgY2hhciAqcCA9IG1zZ19pZF9pbmZvW2ldLmlkX3N0cmluZzsKCQlpbnQgbGVuID0gc3RybGVuKHApOwoJCWNoYXIgKnEgPSB4bWFsbG9jKGxlbik7CgoJCW1zZ19pZF9pbmZvW2ldLmRvd25jYXNlZCA9IHE7CgkJd2hpbGUgKCpwKQoJCQlpZiAoKnAgPT0gJ18nKQoJCQkJcCsrOwoJCQllbHNlCgkJCQkqKHEpKysgPSB0b2xvd2VyKCoocCkrKyk7CgkJKnEgPSAnXDAnOwoKCQlwID0gbXNnX2lkX2luZm9baV0uaWRfc3RyaW5nOwoJCXEgPSB4bWFsbG9jKGxlbik7CgkJbXNnX2lkX2luZm9baV0uY2FtZWxjYXNlZCA9IHE7CgkJd2hpbGUgKCpwKSB7CgkJCWlmICgqcCA9PSAnXycpIHsKCQkJCXArKzsKCQkJCWlmICgqcCkKCQkJCQkqcSsrID0gKnArKzsKCQkJfSBlbHNlIHsKCQkJCSpxKysgPSB0b2xvd2VyKCpwKyspOwoJCQl9CgkJfQoJCSpxID0gJ1wwJzsKCX0KfQoKc3RhdGljIGludCBwYXJzZV9tc2dfaWQoY29uc3QgY2hhciAqdGV4dCkKewoJaW50IGk7CgoJcHJlcGFyZV9tc2dfaWRzKCk7CgoJZm9yIChpID0gMDsgaSA8IEZTQ0tfTVNHX01BWDsgaSsrKQoJCWlmICghc3RyY21wKHRleHQsIG1zZ19pZF9pbmZvW2ldLmRvd25jYXNlZCkpCgkJCXJldHVybiBpOwoKCXJldHVybiAtMTsKfQoKdm9pZCBsaXN0X2NvbmZpZ19mc2NrX21zZ19pZHMoc3RydWN0IHN0cmluZ19saXN0ICpsaXN0LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCWludCBpOwoKCXByZXBhcmVfbXNnX2lkcygpOwoKCWZvciAoaSA9IDA7IGkgPCBGU0NLX01TR19NQVg7IGkrKykKCQlsaXN0X2NvbmZpZ19pdGVtKGxpc3QsIHByZWZpeCwgbXNnX2lkX2luZm9baV0uY2FtZWxjYXNlZCk7Cn0KCnN0YXRpYyBpbnQgZnNja19tc2dfdHlwZShlbnVtIGZzY2tfbXNnX2lkIG1zZ19pZCwKCXN0cnVjdCBmc2NrX29wdGlvbnMgKm9wdGlvbnMpCnsKCWludCBtc2dfdHlwZTsKCglhc3NlcnQobXNnX2lkID49IDAgJiYgbXNnX2lkIDwgRlNDS19NU0dfTUFYKTsKCglpZiAob3B0aW9ucy0+bXNnX3R5cGUpCgkJbXNnX3R5cGUgPSBvcHRpb25zLT5tc2dfdHlwZVttc2dfaWRdOwoJZWxzZSB7CgkJbXNnX3R5cGUgPSBtc2dfaWRfaW5mb1ttc2dfaWRdLm1zZ190eXBlOwoJCWlmIChvcHRpb25zLT5zdHJpY3QgJiYgbXNnX3R5cGUgPT0gRlNDS19XQVJOKQoJCQltc2dfdHlwZSA9IEZTQ0tfRVJST1I7Cgl9CgoJcmV0dXJuIG1zZ190eXBlOwp9CgpzdGF0aWMgaW50IHBhcnNlX21zZ190eXBlKGNvbnN0IGNoYXIgKnN0cikKewoJaWYgKCFzdHJjbXAoc3RyLCAiZXJyb3IiKSkKCQlyZXR1cm4gRlNDS19FUlJPUjsKCWVsc2UgaWYgKCFzdHJjbXAoc3RyLCAid2FybiIpKQoJCXJldHVybiBGU0NLX1dBUk47CgllbHNlIGlmICghc3RyY21wKHN0ciwgImlnbm9yZSIpKQoJCXJldHVybiBGU0NLX0lHTk9SRTsKCWVsc2UKCQlkaWUoIlVua25vd24gZnNjayBtZXNzYWdlIHR5cGU6ICclcyciLCBzdHIpOwp9CgppbnQgaXNfdmFsaWRfbXNnX3R5cGUoY29uc3QgY2hhciAqbXNnX2lkLCBjb25zdCBjaGFyICptc2dfdHlwZSkKewoJaWYgKHBhcnNlX21zZ19pZChtc2dfaWQpIDwgMCkKCQlyZXR1cm4gMDsKCXBhcnNlX21zZ190eXBlKG1zZ190eXBlKTsKCXJldHVybiAxOwp9Cgp2b2lkIGZzY2tfc2V0X21zZ190eXBlKHN0cnVjdCBmc2NrX29wdGlvbnMgKm9wdGlvbnMsCgkJY29uc3QgY2hhciAqbXNnX2lkLCBjb25zdCBjaGFyICptc2dfdHlwZSkKewoJaW50IGlkID0gcGFyc2VfbXNnX2lkKG1zZ19pZCksIHR5cGU7CgoJaWYgKGlkIDwgMCkKCQlkaWUoIlVuaGFuZGxlZCBtZXNzYWdlIGlkOiAlcyIsIG1zZ19pZCk7Cgl0eXBlID0gcGFyc2VfbXNnX3R5cGUobXNnX3R5cGUpOwoKCWlmICh0eXBlICE9IEZTQ0tfRVJST1IgJiYgbXNnX2lkX2luZm9baWRdLm1zZ190eXBlID09IEZTQ0tfRkFUQUwpCgkJZGllKCJDYW5ub3QgZGVtb3RlICVzIHRvICVzIiwgbXNnX2lkLCBtc2dfdHlwZSk7CgoJaWYgKCFvcHRpb25zLT5tc2dfdHlwZSkgewoJCWludCBpOwoJCWludCAqbXNnX3R5cGU7CgkJQUxMT0NfQVJSQVkobXNnX3R5cGUsIEZTQ0tfTVNHX01BWCk7CgkJZm9yIChpID0gMDsgaSA8IEZTQ0tfTVNHX01BWDsgaSsrKQoJCQltc2dfdHlwZVtpXSA9IGZzY2tfbXNnX3R5cGUoaSwgb3B0aW9ucyk7CgkJb3B0aW9ucy0+bXNnX3R5cGUgPSBtc2dfdHlwZTsKCX0KCglvcHRpb25zLT5tc2dfdHlwZVtpZF0gPSB0eXBlOwp9Cgp2b2lkIGZzY2tfc2V0X21zZ190eXBlcyhzdHJ1Y3QgZnNja19vcHRpb25zICpvcHRpb25zLCBjb25zdCBjaGFyICp2YWx1ZXMpCnsKCWNoYXIgKmJ1ZiA9IHhzdHJkdXAodmFsdWVzKSwgKnRvX2ZyZWUgPSBidWY7CglpbnQgZG9uZSA9IDA7CgoJd2hpbGUgKCFkb25lKSB7CgkJaW50IGxlbiA9IHN0cmNzcG4oYnVmLCAiICx8IiksIGVxdWFsOwoKCQlkb25lID0gIWJ1ZltsZW5dOwoJCWlmICghbGVuKSB7CgkJCWJ1ZisrOwoJCQljb250aW51ZTsKCQl9CgkJYnVmW2xlbl0gPSAnXDAnOwoKCQlmb3IgKGVxdWFsID0gMDsKCQkgICAgIGVxdWFsIDwgbGVuICYmIGJ1ZltlcXVhbF0gIT0gJz0nICYmIGJ1ZltlcXVhbF0gIT0gJzonOwoJCSAgICAgZXF1YWwrKykKCQkJYnVmW2VxdWFsXSA9IHRvbG93ZXIoYnVmW2VxdWFsXSk7CgkJYnVmW2VxdWFsXSA9ICdcMCc7CgoJCWlmICghc3RyY21wKGJ1ZiwgInNraXBsaXN0IikpIHsKCQkJaWYgKGVxdWFsID09IGxlbikKCQkJCWRpZSgic2tpcGxpc3QgcmVxdWlyZXMgYSBwYXRoIik7CgkJCW9pZHNldF9wYXJzZV9maWxlKCZvcHRpb25zLT5za2lwbGlzdCwgYnVmICsgZXF1YWwgKyAxKTsKCQkJYnVmICs9IGxlbiArIDE7CgkJCWNvbnRpbnVlOwoJCX0KCgkJaWYgKGVxdWFsID09IGxlbikKCQkJZGllKCJNaXNzaW5nICc9JzogJyVzJyIsIGJ1Zik7CgoJCWZzY2tfc2V0X21zZ190eXBlKG9wdGlvbnMsIGJ1ZiwgYnVmICsgZXF1YWwgKyAxKTsKCQlidWYgKz0gbGVuICsgMTsKCX0KCWZyZWUodG9fZnJlZSk7Cn0KCnN0YXRpYyB2b2lkIGFwcGVuZF9tc2dfaWQoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKm1zZ19pZCkKewoJZm9yICg7OykgewoJCWNoYXIgYyA9ICoobXNnX2lkKSsrOwoKCQlpZiAoIWMpCgkJCWJyZWFrOwoJCWlmIChjICE9ICdfJykKCQkJc3RyYnVmX2FkZGNoKHNiLCB0b2xvd2VyKGMpKTsKCQllbHNlIHsKCQkJYXNzZXJ0KCptc2dfaWQpOwoJCQlzdHJidWZfYWRkY2goc2IsICoobXNnX2lkKSsrKTsKCQl9Cgl9CgoJc3RyYnVmX2FkZHN0cihzYiwgIjogIik7Cn0KCnN0YXRpYyBpbnQgb2JqZWN0X29uX3NraXBsaXN0KHN0cnVjdCBmc2NrX29wdGlvbnMgKm9wdHMsIHN0cnVjdCBvYmplY3QgKm9iaikKewoJcmV0dXJuIG9wdHMgJiYgb2JqICYmIG9pZHNldF9jb250YWlucygmb3B0cy0+c2tpcGxpc3QsICZvYmotPm9pZCk7Cn0KCl9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCA0LCA1KSkpCnN0YXRpYyBpbnQgcmVwb3J0KHN0cnVjdCBmc2NrX29wdGlvbnMgKm9wdGlvbnMsIHN0cnVjdCBvYmplY3QgKm9iamVjdCwKCWVudW0gZnNja19tc2dfaWQgaWQsIGNvbnN0IGNoYXIgKmZtdCwgLi4uKQp7Cgl2YV9saXN0IGFwOwoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJaW50IG1zZ190eXBlID0gZnNja19tc2dfdHlwZShpZCwgb3B0aW9ucyksIHJlc3VsdDsKCglpZiAobXNnX3R5cGUgPT0gRlNDS19JR05PUkUpCgkJcmV0dXJuIDA7CgoJaWYgKG9iamVjdF9vbl9za2lwbGlzdChvcHRpb25zLCBvYmplY3QpKQoJCXJldHVybiAwOwoKCWlmIChtc2dfdHlwZSA9PSBGU0NLX0ZBVEFMKQoJCW1zZ190eXBlID0gRlNDS19FUlJPUjsKCWVsc2UgaWYgKG1zZ190eXBlID09IEZTQ0tfSU5GTykKCQltc2dfdHlwZSA9IEZTQ0tfV0FSTjsKCglhcHBlbmRfbXNnX2lkKCZzYiwgbXNnX2lkX2luZm9baWRdLmlkX3N0cmluZyk7CgoJdmFfc3RhcnQoYXAsIGZtdCk7CglzdHJidWZfdmFkZGYoJnNiLCBmbXQsIGFwKTsKCXJlc3VsdCA9IG9wdGlvbnMtPmVycm9yX2Z1bmMob3B0aW9ucywgb2JqZWN0LCBtc2dfdHlwZSwgc2IuYnVmKTsKCXN0cmJ1Zl9yZWxlYXNlKCZzYik7Cgl2YV9lbmQoYXApOwoKCXJldHVybiByZXN1bHQ7Cn0KCnN0YXRpYyBjaGFyICpnZXRfb2JqZWN0X25hbWUoc3RydWN0IGZzY2tfb3B0aW9ucyAqb3B0aW9ucywgc3RydWN0IG9iamVjdCAqb2JqKQp7CglpZiAoIW9wdGlvbnMtPm9iamVjdF9uYW1lcykKCQlyZXR1cm4gTlVMTDsKCXJldHVybiBsb29rdXBfZGVjb3JhdGlvbihvcHRpb25zLT5vYmplY3RfbmFtZXMsIG9iaik7Cn0KCnN0YXRpYyB2b2lkIHB1dF9vYmplY3RfbmFtZShzdHJ1Y3QgZnNja19vcHRpb25zICpvcHRpb25zLCBzdHJ1Y3Qgb2JqZWN0ICpvYmosCgljb25zdCBjaGFyICpmbXQsIC4uLikKewoJdmFfbGlzdCBhcDsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgljaGFyICpleGlzdGluZzsKCglpZiAoIW9wdGlvbnMtPm9iamVjdF9uYW1lcykKCQlyZXR1cm47CglleGlzdGluZyA9IGxvb2t1cF9kZWNvcmF0aW9uKG9wdGlvbnMtPm9iamVjdF9uYW1lcywgb2JqKTsKCWlmIChleGlzdGluZykKCQlyZXR1cm47Cgl2YV9zdGFydChhcCwgZm10KTsKCXN0cmJ1Zl92YWRkZigmYnVmLCBmbXQsIGFwKTsKCWFkZF9kZWNvcmF0aW9uKG9wdGlvbnMtPm9iamVjdF9uYW1lcywgb2JqLCBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpKTsKCXZhX2VuZChhcCk7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpkZXNjcmliZV9vYmplY3Qoc3RydWN0IGZzY2tfb3B0aW9ucyAqbywgc3RydWN0IG9iamVjdCAqb2JqKQp7CglzdGF0aWMgc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWNoYXIgKm5hbWU7CgoJc3RyYnVmX3Jlc2V0KCZidWYpOwoJc3RyYnVmX2FkZHN0cigmYnVmLCBvaWRfdG9faGV4KCZvYmotPm9pZCkpOwoJaWYgKG8tPm9iamVjdF9uYW1lcyAmJiAobmFtZSA9IGxvb2t1cF9kZWNvcmF0aW9uKG8tPm9iamVjdF9uYW1lcywgb2JqKSkpCgkJc3RyYnVmX2FkZGYoJmJ1ZiwgIiAoJXMpIiwgbmFtZSk7CgoJcmV0dXJuIGJ1Zi5idWY7Cn0KCnN0YXRpYyBpbnQgZnNja193YWxrX3RyZWUoc3RydWN0IHRyZWUgKnRyZWUsIHZvaWQgKmRhdGEsIHN0cnVjdCBmc2NrX29wdGlvbnMgKm9wdGlvbnMpCnsKCXN0cnVjdCB0cmVlX2Rlc2MgZGVzYzsKCXN0cnVjdCBuYW1lX2VudHJ5IGVudHJ5OwoJaW50IHJlcyA9IDA7Cgljb25zdCBjaGFyICpuYW1lOwoKCWlmIChwYXJzZV90cmVlKHRyZWUpKQoJCXJldHVybiAtMTsKCgluYW1lID0gZ2V0X29iamVjdF9uYW1lKG9wdGlvbnMsICZ0cmVlLT5vYmplY3QpOwoJaWYgKGluaXRfdHJlZV9kZXNjX2dlbnRseSgmZGVzYywgdHJlZS0+YnVmZmVyLCB0cmVlLT5zaXplKSkKCQlyZXR1cm4gLTE7Cgl3aGlsZSAodHJlZV9lbnRyeV9nZW50bHkoJmRlc2MsICZlbnRyeSkpIHsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmo7CgkJaW50IHJlc3VsdDsKCgkJaWYgKFNfSVNHSVRMSU5LKGVudHJ5Lm1vZGUpKQoJCQljb250aW51ZTsKCgkJaWYgKFNfSVNESVIoZW50cnkubW9kZSkpIHsKCQkJb2JqID0gKHN0cnVjdCBvYmplY3QgKilsb29rdXBfdHJlZSh0aGVfcmVwb3NpdG9yeSwgJmVudHJ5Lm9pZCk7CgkJCWlmIChuYW1lICYmIG9iaikKCQkJCXB1dF9vYmplY3RfbmFtZShvcHRpb25zLCBvYmosICIlcyVzLyIsIG5hbWUsCgkJCQkJZW50cnkucGF0aCk7CgkJCXJlc3VsdCA9IG9wdGlvbnMtPndhbGsob2JqLCBPQkpfVFJFRSwgZGF0YSwgb3B0aW9ucyk7CgkJfQoJCWVsc2UgaWYgKFNfSVNSRUcoZW50cnkubW9kZSkgfHwgU19JU0xOSyhlbnRyeS5tb2RlKSkgewoJCQlvYmogPSAoc3RydWN0IG9iamVjdCAqKWxvb2t1cF9ibG9iKHRoZV9yZXBvc2l0b3J5LCAmZW50cnkub2lkKTsKCQkJaWYgKG5hbWUgJiYgb2JqKQoJCQkJcHV0X29iamVjdF9uYW1lKG9wdGlvbnMsIG9iaiwgIiVzJXMiLCBuYW1lLAoJCQkJCWVudHJ5LnBhdGgpOwoJCQlyZXN1bHQgPSBvcHRpb25zLT53YWxrKG9iaiwgT0JKX0JMT0IsIGRhdGEsIG9wdGlvbnMpOwoJCX0KCQllbHNlIHsKCQkJcmVzdWx0ID0gZXJyb3IoImluIHRyZWUgJXM6IGVudHJ5ICVzIGhhcyBiYWQgbW9kZSAlLjZvIiwKCQkJCQlkZXNjcmliZV9vYmplY3Qob3B0aW9ucywgJnRyZWUtPm9iamVjdCksIGVudHJ5LnBhdGgsIGVudHJ5Lm1vZGUpOwoJCX0KCQlpZiAocmVzdWx0IDwgMCkKCQkJcmV0dXJuIHJlc3VsdDsKCQlpZiAoIXJlcykKCQkJcmVzID0gcmVzdWx0OwoJfQoJcmV0dXJuIHJlczsKfQoKc3RhdGljIGludCBmc2NrX3dhbGtfY29tbWl0KHN0cnVjdCBjb21taXQgKmNvbW1pdCwgdm9pZCAqZGF0YSwgc3RydWN0IGZzY2tfb3B0aW9ucyAqb3B0aW9ucykKewoJaW50IGNvdW50ZXIgPSAwLCBnZW5lcmF0aW9uID0gMCwgbmFtZV9wcmVmaXhfbGVuID0gMDsKCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50czsKCWludCByZXM7CglpbnQgcmVzdWx0OwoJY29uc3QgY2hhciAqbmFtZTsKCglpZiAocGFyc2VfY29tbWl0KGNvbW1pdCkpCgkJcmV0dXJuIC0xOwoKCW5hbWUgPSBnZXRfb2JqZWN0X25hbWUob3B0aW9ucywgJmNvbW1pdC0+b2JqZWN0KTsKCWlmIChuYW1lKQoJCXB1dF9vYmplY3RfbmFtZShvcHRpb25zLCAmZ2V0X2NvbW1pdF90cmVlKGNvbW1pdCktPm9iamVjdCwKCQkJCSIlczoiLCBuYW1lKTsKCglyZXN1bHQgPSBvcHRpb25zLT53YWxrKChzdHJ1Y3Qgb2JqZWN0ICopZ2V0X2NvbW1pdF90cmVlKGNvbW1pdCksCgkJCSAgICAgICBPQkpfVFJFRSwgZGF0YSwgb3B0aW9ucyk7CglpZiAocmVzdWx0IDwgMCkKCQlyZXR1cm4gcmVzdWx0OwoJcmVzID0gcmVzdWx0OwoKCXBhcmVudHMgPSBjb21taXQtPnBhcmVudHM7CglpZiAobmFtZSAmJiBwYXJlbnRzKSB7CgkJaW50IGxlbiA9IHN0cmxlbihuYW1lKSwgcG93ZXI7CgoJCWlmIChsZW4gJiYgbmFtZVtsZW4gLSAxXSA9PSAnXicpIHsKCQkJZ2VuZXJhdGlvbiA9IDE7CgkJCW5hbWVfcHJlZml4X2xlbiA9IGxlbiAtIDE7CgkJfQoJCWVsc2UgeyAvKiBwYXJzZSB+PGdlbmVyYXRpb24+IHN1ZmZpeCAqLwoJCQlmb3IgKGdlbmVyYXRpb24gPSAwLCBwb3dlciA9IDE7CgkJCSAgICAgbGVuICYmIGlzZGlnaXQobmFtZVtsZW4gLSAxXSk7CgkJCSAgICAgcG93ZXIgKj0gMTApCgkJCQlnZW5lcmF0aW9uICs9IHBvd2VyICogKG5hbWVbLS1sZW5dIC0gJzAnKTsKCQkJaWYgKHBvd2VyID4gMSAmJiBsZW4gJiYgbmFtZVtsZW4gLSAxXSA9PSAnficpCgkJCQluYW1lX3ByZWZpeF9sZW4gPSBsZW4gLSAxOwoJCX0KCX0KCgl3aGlsZSAocGFyZW50cykgewoJCWlmIChuYW1lKSB7CgkJCXN0cnVjdCBvYmplY3QgKm9iaiA9ICZwYXJlbnRzLT5pdGVtLT5vYmplY3Q7CgoJCQlpZiAoY291bnRlcisrKQoJCQkJcHV0X29iamVjdF9uYW1lKG9wdGlvbnMsIG9iaiwgIiVzXiVkIiwKCQkJCQluYW1lLCBjb3VudGVyKTsKCQkJZWxzZSBpZiAoZ2VuZXJhdGlvbiA+IDApCgkJCQlwdXRfb2JqZWN0X25hbWUob3B0aW9ucywgb2JqLCAiJS4qc34lZCIsCgkJCQkJbmFtZV9wcmVmaXhfbGVuLCBuYW1lLCBnZW5lcmF0aW9uICsgMSk7CgkJCWVsc2UKCQkJCXB1dF9vYmplY3RfbmFtZShvcHRpb25zLCBvYmosICIlc14iLCBuYW1lKTsKCQl9CgkJcmVzdWx0ID0gb3B0aW9ucy0+d2Fsaygoc3RydWN0IG9iamVjdCAqKXBhcmVudHMtPml0ZW0sIE9CSl9DT01NSVQsIGRhdGEsIG9wdGlvbnMpOwoJCWlmIChyZXN1bHQgPCAwKQoJCQlyZXR1cm4gcmVzdWx0OwoJCWlmICghcmVzKQoJCQlyZXMgPSByZXN1bHQ7CgkJcGFyZW50cyA9IHBhcmVudHMtPm5leHQ7Cgl9CglyZXR1cm4gcmVzOwp9CgpzdGF0aWMgaW50IGZzY2tfd2Fsa190YWcoc3RydWN0IHRhZyAqdGFnLCB2b2lkICpkYXRhLCBzdHJ1Y3QgZnNja19vcHRpb25zICpvcHRpb25zKQp7CgljaGFyICpuYW1lID0gZ2V0X29iamVjdF9uYW1lKG9wdGlvbnMsICZ0YWctPm9iamVjdCk7CgoJaWYgKHBhcnNlX3RhZyh0YWcpKQoJCXJldHVybiAtMTsKCWlmIChuYW1lKQoJCXB1dF9vYmplY3RfbmFtZShvcHRpb25zLCB0YWctPnRhZ2dlZCwgIiVzIiwgbmFtZSk7CglyZXR1cm4gb3B0aW9ucy0+d2Fsayh0YWctPnRhZ2dlZCwgT0JKX0FOWSwgZGF0YSwgb3B0aW9ucyk7Cn0KCmludCBmc2NrX3dhbGsoc3RydWN0IG9iamVjdCAqb2JqLCB2b2lkICpkYXRhLCBzdHJ1Y3QgZnNja19vcHRpb25zICpvcHRpb25zKQp7CglpZiAoIW9iaikKCQlyZXR1cm4gLTE7CgoJaWYgKG9iai0+dHlwZSA9PSBPQkpfTk9ORSkKCQlwYXJzZV9vYmplY3QodGhlX3JlcG9zaXRvcnksICZvYmotPm9pZCk7CgoJc3dpdGNoIChvYmotPnR5cGUpIHsKCWNhc2UgT0JKX0JMT0I6CgkJcmV0dXJuIDA7CgljYXNlIE9CSl9UUkVFOgoJCXJldHVybiBmc2NrX3dhbGtfdHJlZSgoc3RydWN0IHRyZWUgKilvYmosIGRhdGEsIG9wdGlvbnMpOwoJY2FzZSBPQkpfQ09NTUlUOgoJCXJldHVybiBmc2NrX3dhbGtfY29tbWl0KChzdHJ1Y3QgY29tbWl0ICopb2JqLCBkYXRhLCBvcHRpb25zKTsKCWNhc2UgT0JKX1RBRzoKCQlyZXR1cm4gZnNja193YWxrX3RhZygoc3RydWN0IHRhZyAqKW9iaiwgZGF0YSwgb3B0aW9ucyk7CglkZWZhdWx0OgoJCWVycm9yKCJVbmtub3duIG9iamVjdCB0eXBlIGZvciAlcyIsIGRlc2NyaWJlX29iamVjdChvcHRpb25zLCBvYmopKTsKCQlyZXR1cm4gLTE7Cgl9Cn0KCi8qCiAqIFRoZSBlbnRyaWVzIGluIGEgdHJlZSBhcmUgb3JkZXJlZCBpbiB0aGUgX3BhdGhfIG9yZGVyLAogKiB3aGljaCBtZWFucyB0aGF0IGEgZGlyZWN0b3J5IGVudHJ5IGlzIG9yZGVyZWQgYnkgYWRkaW5nCiAqIGEgc2xhc2ggdG8gdGhlIGVuZCBvZiBpdC4KICoKICogU28gYSBkaXJlY3RvcnkgY2FsbGVkICJhIiBpcyBvcmRlcmVkIF9hZnRlcl8gYSBmaWxlCiAqIGNhbGxlZCAiYS5jIiwgYmVjYXVzZSAiYS8iIHNvcnRzIGFmdGVyICJhLmMiLgogKi8KI2RlZmluZSBUUkVFX1VOT1JERVJFRCAoLTEpCiNkZWZpbmUgVFJFRV9IQVNfRFVQUyAgKC0yKQoKc3RhdGljIGludCB2ZXJpZnlfb3JkZXJlZCh1bnNpZ25lZCBtb2RlMSwgY29uc3QgY2hhciAqbmFtZTEsIHVuc2lnbmVkIG1vZGUyLCBjb25zdCBjaGFyICpuYW1lMikKewoJaW50IGxlbjEgPSBzdHJsZW4obmFtZTEpOwoJaW50IGxlbjIgPSBzdHJsZW4obmFtZTIpOwoJaW50IGxlbiA9IGxlbjEgPCBsZW4yID8gbGVuMSA6IGxlbjI7Cgl1bnNpZ25lZCBjaGFyIGMxLCBjMjsKCWludCBjbXA7CgoJY21wID0gbWVtY21wKG5hbWUxLCBuYW1lMiwgbGVuKTsKCWlmIChjbXAgPCAwKQoJCXJldHVybiAwOwoJaWYgKGNtcCA+IDApCgkJcmV0dXJuIFRSRUVfVU5PUkRFUkVEOwoKCS8qCgkgKiBPaywgdGhlIGZpcnN0IDxsZW4+IGNoYXJhY3RlcnMgYXJlIHRoZSBzYW1lLgoJICogTm93IHdlIG5lZWQgdG8gb3JkZXIgdGhlIG5leHQgb25lLCBidXQgdHVybgoJICogYSAnXDAnIGludG8gYSAnLycgZm9yIGEgZGlyZWN0b3J5IGVudHJ5LgoJICovCgljMSA9IG5hbWUxW2xlbl07CgljMiA9IG5hbWUyW2xlbl07CglpZiAoIWMxICYmICFjMikKCQkvKgoJCSAqIGdpdC13cml0ZS10cmVlIHVzZWQgdG8gd3JpdGUgb3V0IGEgbm9uc2Vuc2UgdHJlZSB0aGF0IGhhcwoJCSAqIGVudHJpZXMgd2l0aCB0aGUgc2FtZSBuYW1lLCBvbmUgYmxvYiBhbmQgb25lIHRyZWUuICBNYWtlCgkJICogc3VyZSB3ZSBkbyBub3QgaGF2ZSBkdXBsaWNhdGUgZW50cmllcy4KCQkgKi8KCQlyZXR1cm4gVFJFRV9IQVNfRFVQUzsKCWlmICghYzEgJiYgU19JU0RJUihtb2RlMSkpCgkJYzEgPSAnLyc7CglpZiAoIWMyICYmIFNfSVNESVIobW9kZTIpKQoJCWMyID0gJy8nOwoJcmV0dXJuIGMxIDwgYzIgPyAwIDogVFJFRV9VTk9SREVSRUQ7Cn0KCnN0YXRpYyBpbnQgZnNja190cmVlKHN0cnVjdCB0cmVlICppdGVtLCBzdHJ1Y3QgZnNja19vcHRpb25zICpvcHRpb25zKQp7CglpbnQgcmV0dmFsID0gMDsKCWludCBoYXNfbnVsbF9zaGExID0gMDsKCWludCBoYXNfZnVsbF9wYXRoID0gMDsKCWludCBoYXNfZW1wdHlfbmFtZSA9IDA7CglpbnQgaGFzX2RvdCA9IDA7CglpbnQgaGFzX2RvdGRvdCA9IDA7CglpbnQgaGFzX2RvdGdpdCA9IDA7CglpbnQgaGFzX3plcm9fcGFkID0gMDsKCWludCBoYXNfYmFkX21vZGVzID0gMDsKCWludCBoYXNfZHVwX2VudHJpZXMgPSAwOwoJaW50IG5vdF9wcm9wZXJseV9zb3J0ZWQgPSAwOwoJc3RydWN0IHRyZWVfZGVzYyBkZXNjOwoJdW5zaWduZWQgb19tb2RlOwoJY29uc3QgY2hhciAqb19uYW1lOwoKCWlmIChpbml0X3RyZWVfZGVzY19nZW50bHkoJmRlc2MsIGl0ZW0tPmJ1ZmZlciwgaXRlbS0+c2l6ZSkpIHsKCQlyZXR2YWwgKz0gcmVwb3J0KG9wdGlvbnMsICZpdGVtLT5vYmplY3QsIEZTQ0tfTVNHX0JBRF9UUkVFLCAiY2Fubm90IGJlIHBhcnNlZCBhcyBhIHRyZWUiKTsKCQlyZXR1cm4gcmV0dmFsOwoJfQoKCW9fbW9kZSA9IDA7CglvX25hbWUgPSBOVUxMOwoKCXdoaWxlIChkZXNjLnNpemUpIHsKCQl1bnNpZ25lZCBzaG9ydCBtb2RlOwoJCWNvbnN0IGNoYXIgKm5hbWUsICpiYWNrc2xhc2g7CgkJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkOwoKCQlvaWQgPSB0cmVlX2VudHJ5X2V4dHJhY3QoJmRlc2MsICZuYW1lLCAmbW9kZSk7CgoJCWhhc19udWxsX3NoYTEgfD0gaXNfbnVsbF9vaWQob2lkKTsKCQloYXNfZnVsbF9wYXRoIHw9ICEhc3RyY2hyKG5hbWUsICcvJyk7CgkJaGFzX2VtcHR5X25hbWUgfD0gISpuYW1lOwoJCWhhc19kb3QgfD0gIXN0cmNtcChuYW1lLCAiLiIpOwoJCWhhc19kb3Rkb3QgfD0gIXN0cmNtcChuYW1lLCAiLi4iKTsKCQloYXNfZG90Z2l0IHw9IGlzX2hmc19kb3RnaXQobmFtZSkgfHwgaXNfbnRmc19kb3RnaXQobmFtZSk7CgkJaGFzX3plcm9fcGFkIHw9ICooY2hhciAqKWRlc2MuYnVmZmVyID09ICcwJzsKCgkJaWYgKGlzX2hmc19kb3RnaXRtb2R1bGVzKG5hbWUpIHx8IGlzX250ZnNfZG90Z2l0bW9kdWxlcyhuYW1lKSkgewoJCQlpZiAoIVNfSVNMTksobW9kZSkpCgkJCQlvaWRzZXRfaW5zZXJ0KCZnaXRtb2R1bGVzX2ZvdW5kLCBvaWQpOwoJCQllbHNlCgkJCQlyZXR2YWwgKz0gcmVwb3J0KG9wdGlvbnMsICZpdGVtLT5vYmplY3QsCgkJCQkJCSBGU0NLX01TR19HSVRNT0RVTEVTX1NZTUxJTkssCgkJCQkJCSAiLmdpdG1vZHVsZXMgaXMgYSBzeW1ib2xpYyBsaW5rIik7CgkJfQoKCQlpZiAoKGJhY2tzbGFzaCA9IHN0cmNocihuYW1lLCAnXFwnKSkpIHsKCQkJd2hpbGUgKGJhY2tzbGFzaCkgewoJCQkJYmFja3NsYXNoKys7CgkJCQloYXNfZG90Z2l0IHw9IGlzX250ZnNfZG90Z2l0KGJhY2tzbGFzaCk7CgkJCQlpZiAoaXNfbnRmc19kb3RnaXRtb2R1bGVzKGJhY2tzbGFzaCkpIHsKCQkJCQlpZiAoIVNfSVNMTksobW9kZSkpCgkJCQkJCW9pZHNldF9pbnNlcnQoJmdpdG1vZHVsZXNfZm91bmQsIG9pZCk7CgkJCQkJZWxzZQoJCQkJCQlyZXR2YWwgKz0gcmVwb3J0KG9wdGlvbnMsICZpdGVtLT5vYmplY3QsCgkJCQkJCQkJIEZTQ0tfTVNHX0dJVE1PRFVMRVNfU1lNTElOSywKCQkJCQkJCQkgIi5naXRtb2R1bGVzIGlzIGEgc3ltYm9saWMgbGluayIpOwoJCQkJfQoJCQkJYmFja3NsYXNoID0gc3RyY2hyKGJhY2tzbGFzaCwgJ1xcJyk7CgkJCX0KCQl9CgoJCWlmICh1cGRhdGVfdHJlZV9lbnRyeV9nZW50bHkoJmRlc2MpKSB7CgkJCXJldHZhbCArPSByZXBvcnQob3B0aW9ucywgJml0ZW0tPm9iamVjdCwgRlNDS19NU0dfQkFEX1RSRUUsICJjYW5ub3QgYmUgcGFyc2VkIGFzIGEgdHJlZSIpOwoJCQlicmVhazsKCQl9CgoJCXN3aXRjaCAobW9kZSkgewoJCS8qCgkJICogU3RhbmRhcmQgbW9kZXMuLgoJCSAqLwoJCWNhc2UgU19JRlJFRyB8IDA3NTU6CgkJY2FzZSBTX0lGUkVHIHwgMDY0NDoKCQljYXNlIFNfSUZMTks6CgkJY2FzZSBTX0lGRElSOgoJCWNhc2UgU19JRkdJVExJTks6CgkJCWJyZWFrOwoJCS8qCgkJICogVGhpcyBpcyBub25zdGFuZGFyZCwgYnV0IHdlIGhhZCBhIGZldyBvZiB0aGVzZQoJCSAqIGVhcmx5IG9uIHdoZW4gd2UgaG9ub3JlZCB0aGUgZnVsbCBzZXQgb2YgbW9kZQoJCSAqIGJpdHMuLgoJCSAqLwoJCWNhc2UgU19JRlJFRyB8IDA2NjQ6CgkJCWlmICghb3B0aW9ucy0+c3RyaWN0KQoJCQkJYnJlYWs7CgkJCS8qIGZhbGx0aHJvdWdoICovCgkJZGVmYXVsdDoKCQkJaGFzX2JhZF9tb2RlcyA9IDE7CgkJfQoKCQlpZiAob19uYW1lKSB7CgkJCXN3aXRjaCAodmVyaWZ5X29yZGVyZWQob19tb2RlLCBvX25hbWUsIG1vZGUsIG5hbWUpKSB7CgkJCWNhc2UgVFJFRV9VTk9SREVSRUQ6CgkJCQlub3RfcHJvcGVybHlfc29ydGVkID0gMTsKCQkJCWJyZWFrOwoJCQljYXNlIFRSRUVfSEFTX0RVUFM6CgkJCQloYXNfZHVwX2VudHJpZXMgPSAxOwoJCQkJYnJlYWs7CgkJCWRlZmF1bHQ6CgkJCQlicmVhazsKCQkJfQoJCX0KCgkJb19tb2RlID0gbW9kZTsKCQlvX25hbWUgPSBuYW1lOwoJfQoKCWlmIChoYXNfbnVsbF9zaGExKQoJCXJldHZhbCArPSByZXBvcnQob3B0aW9ucywgJml0ZW0tPm9iamVjdCwgRlNDS19NU0dfTlVMTF9TSEExLCAiY29udGFpbnMgZW50cmllcyBwb2ludGluZyB0byBudWxsIHNoYTEiKTsKCWlmIChoYXNfZnVsbF9wYXRoKQoJCXJldHZhbCArPSByZXBvcnQob3B0aW9ucywgJml0ZW0tPm9iamVjdCwgRlNDS19NU0dfRlVMTF9QQVRITkFNRSwgImNvbnRhaW5zIGZ1bGwgcGF0aG5hbWVzIik7CglpZiAoaGFzX2VtcHR5X25hbWUpCgkJcmV0dmFsICs9IHJlcG9ydChvcHRpb25zLCAmaXRlbS0+b2JqZWN0LCBGU0NLX01TR19FTVBUWV9OQU1FLCAiY29udGFpbnMgZW1wdHkgcGF0aG5hbWUiKTsKCWlmIChoYXNfZG90KQoJCXJldHZhbCArPSByZXBvcnQob3B0aW9ucywgJml0ZW0tPm9iamVjdCwgRlNDS19NU0dfSEFTX0RPVCwgImNvbnRhaW5zICcuJyIpOwoJaWYgKGhhc19kb3Rkb3QpCgkJcmV0dmFsICs9IHJlcG9ydChvcHRpb25zLCAmaXRlbS0+b2JqZWN0LCBGU0NLX01TR19IQVNfRE9URE9ULCAiY29udGFpbnMgJy4uJyIpOwoJaWYgKGhhc19kb3RnaXQpCgkJcmV0dmFsICs9IHJlcG9ydChvcHRpb25zLCAmaXRlbS0+b2JqZWN0LCBGU0NLX01TR19IQVNfRE9UR0lULCAiY29udGFpbnMgJy5naXQnIik7CglpZiAoaGFzX3plcm9fcGFkKQoJCXJldHZhbCArPSByZXBvcnQob3B0aW9ucywgJml0ZW0tPm9iamVjdCwgRlNDS19NU0dfWkVST19QQURERURfRklMRU1PREUsICJjb250YWlucyB6ZXJvLXBhZGRlZCBmaWxlIG1vZGVzIik7CglpZiAoaGFzX2JhZF9tb2RlcykKCQlyZXR2YWwgKz0gcmVwb3J0KG9wdGlvbnMsICZpdGVtLT5vYmplY3QsIEZTQ0tfTVNHX0JBRF9GSUxFTU9ERSwgImNvbnRhaW5zIGJhZCBmaWxlIG1vZGVzIik7CglpZiAoaGFzX2R1cF9lbnRyaWVzKQoJCXJldHZhbCArPSByZXBvcnQob3B0aW9ucywgJml0ZW0tPm9iamVjdCwgRlNDS19NU0dfRFVQTElDQVRFX0VOVFJJRVMsICJjb250YWlucyBkdXBsaWNhdGUgZmlsZSBlbnRyaWVzIik7CglpZiAobm90X3Byb3Blcmx5X3NvcnRlZCkKCQlyZXR2YWwgKz0gcmVwb3J0KG9wdGlvbnMsICZpdGVtLT5vYmplY3QsIEZTQ0tfTVNHX1RSRUVfTk9UX1NPUlRFRCwgIm5vdCBwcm9wZXJseSBzb3J0ZWQiKTsKCXJldHVybiByZXR2YWw7Cn0KCnN0YXRpYyBpbnQgdmVyaWZ5X2hlYWRlcnMoY29uc3Qgdm9pZCAqZGF0YSwgdW5zaWduZWQgbG9uZyBzaXplLAoJCQkgIHN0cnVjdCBvYmplY3QgKm9iaiwgc3RydWN0IGZzY2tfb3B0aW9ucyAqb3B0aW9ucykKewoJY29uc3QgY2hhciAqYnVmZmVyID0gKGNvbnN0IGNoYXIgKilkYXRhOwoJdW5zaWduZWQgbG9uZyBpOwoKCWZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHsKCQlzd2l0Y2ggKGJ1ZmZlcltpXSkgewoJCWNhc2UgJ1wwJzoKCQkJcmV0dXJuIHJlcG9ydChvcHRpb25zLCBvYmosCgkJCQlGU0NLX01TR19OVUxfSU5fSEVBREVSLAoJCQkJInVudGVybWluYXRlZCBoZWFkZXI6IE5VTCBhdCBvZmZzZXQgJWxkIiwgaSk7CgkJY2FzZSAnXG4nOgoJCQlpZiAoaSArIDEgPCBzaXplICYmIGJ1ZmZlcltpICsgMV0gPT0gJ1xuJykKCQkJCXJldHVybiAwOwoJCX0KCX0KCgkvKgoJICogV2UgZGlkIG5vdCBmaW5kIGRvdWJsZS1MRiB0aGF0IHNlcGFyYXRlcyB0aGUgaGVhZGVyCgkgKiBhbmQgdGhlIGJvZHkuICBOb3QgaGF2aW5nIGEgYm9keSBpcyBub3QgYSBjcmltZSBidXQKCSAqIHdlIGRvIHdhbnQgdG8gc2VlIHRoZSB0ZXJtaW5hdGluZyBMRiBmb3IgdGhlIGxhc3QgaGVhZGVyCgkgKiBsaW5lLgoJICovCglpZiAoc2l6ZSAmJiBidWZmZXJbc2l6ZSAtIDFdID09ICdcbicpCgkJcmV0dXJuIDA7CgoJcmV0dXJuIHJlcG9ydChvcHRpb25zLCBvYmosCgkJRlNDS19NU0dfVU5URVJNSU5BVEVEX0hFQURFUiwgInVudGVybWluYXRlZCBoZWFkZXIiKTsKfQoKc3RhdGljIGludCBmc2NrX2lkZW50KGNvbnN0IGNoYXIgKippZGVudCwgc3RydWN0IG9iamVjdCAqb2JqLCBzdHJ1Y3QgZnNja19vcHRpb25zICpvcHRpb25zKQp7Cgljb25zdCBjaGFyICpwID0gKmlkZW50OwoJY2hhciAqZW5kOwoKCSppZGVudCA9IHN0cmNocm51bCgqaWRlbnQsICdcbicpOwoJaWYgKCoqaWRlbnQgPT0gJ1xuJykKCQkoKmlkZW50KSsrOwoKCWlmICgqcCA9PSAnPCcpCgkJcmV0dXJuIHJlcG9ydChvcHRpb25zLCBvYmosIEZTQ0tfTVNHX01JU1NJTkdfTkFNRV9CRUZPUkVfRU1BSUwsICJpbnZhbGlkIGF1dGhvci9jb21taXR0ZXIgbGluZSAtIG1pc3Npbmcgc3BhY2UgYmVmb3JlIGVtYWlsIik7CglwICs9IHN0cmNzcG4ocCwgIjw+XG4iKTsKCWlmICgqcCA9PSAnPicpCgkJcmV0dXJuIHJlcG9ydChvcHRpb25zLCBvYmosIEZTQ0tfTVNHX0JBRF9OQU1FLCAiaW52YWxpZCBhdXRob3IvY29tbWl0dGVyIGxpbmUgLSBiYWQgbmFtZSIpOwoJaWYgKCpwICE9ICc8JykKCQlyZXR1cm4gcmVwb3J0KG9wdGlvbnMsIG9iaiwgRlNDS19NU0dfTUlTU0lOR19FTUFJTCwgImludmFsaWQgYXV0aG9yL2NvbW1pdHRlciBsaW5lIC0gbWlzc2luZyBlbWFpbCIpOwoJaWYgKHBbLTFdICE9ICcgJykKCQlyZXR1cm4gcmVwb3J0KG9wdGlvbnMsIG9iaiwgRlNDS19NU0dfTUlTU0lOR19TUEFDRV9CRUZPUkVfRU1BSUwsICJpbnZhbGlkIGF1dGhvci9jb21taXR0ZXIgbGluZSAtIG1pc3Npbmcgc3BhY2UgYmVmb3JlIGVtYWlsIik7CglwKys7CglwICs9IHN0cmNzcG4ocCwgIjw+XG4iKTsKCWlmICgqcCAhPSAnPicpCgkJcmV0dXJuIHJlcG9ydChvcHRpb25zLCBvYmosIEZTQ0tfTVNHX0JBRF9FTUFJTCwgImludmFsaWQgYXV0aG9yL2NvbW1pdHRlciBsaW5lIC0gYmFkIGVtYWlsIik7CglwKys7CglpZiAoKnAgIT0gJyAnKQoJCXJldHVybiByZXBvcnQob3B0aW9ucywgb2JqLCBGU0NLX01TR19NSVNTSU5HX1NQQUNFX0JFRk9SRV9EQVRFLCAiaW52YWxpZCBhdXRob3IvY29tbWl0dGVyIGxpbmUgLSBtaXNzaW5nIHNwYWNlIGJlZm9yZSBkYXRlIik7CglwKys7CglpZiAoKnAgPT0gJzAnICYmIHBbMV0gIT0gJyAnKQoJCXJldHVybiByZXBvcnQob3B0aW9ucywgb2JqLCBGU0NLX01TR19aRVJPX1BBRERFRF9EQVRFLCAiaW52YWxpZCBhdXRob3IvY29tbWl0dGVyIGxpbmUgLSB6ZXJvLXBhZGRlZCBkYXRlIik7CglpZiAoZGF0ZV9vdmVyZmxvd3MocGFyc2VfdGltZXN0YW1wKHAsICZlbmQsIDEwKSkpCgkJcmV0dXJuIHJlcG9ydChvcHRpb25zLCBvYmosIEZTQ0tfTVNHX0JBRF9EQVRFX09WRVJGTE9XLCAiaW52YWxpZCBhdXRob3IvY29tbWl0dGVyIGxpbmUgLSBkYXRlIGNhdXNlcyBpbnRlZ2VyIG92ZXJmbG93Iik7CglpZiAoKGVuZCA9PSBwIHx8ICplbmQgIT0gJyAnKSkKCQlyZXR1cm4gcmVwb3J0KG9wdGlvbnMsIG9iaiwgRlNDS19NU0dfQkFEX0RBVEUsICJpbnZhbGlkIGF1dGhvci9jb21taXR0ZXIgbGluZSAtIGJhZCBkYXRlIik7CglwID0gZW5kICsgMTsKCWlmICgoKnAgIT0gJysnICYmICpwICE9ICctJykgfHwKCSAgICAhaXNkaWdpdChwWzFdKSB8fAoJICAgICFpc2RpZ2l0KHBbMl0pIHx8CgkgICAgIWlzZGlnaXQocFszXSkgfHwKCSAgICAhaXNkaWdpdChwWzRdKSB8fAoJICAgIChwWzVdICE9ICdcbicpKQoJCXJldHVybiByZXBvcnQob3B0aW9ucywgb2JqLCBGU0NLX01TR19CQURfVElNRVpPTkUsICJpbnZhbGlkIGF1dGhvci9jb21taXR0ZXIgbGluZSAtIGJhZCB0aW1lIHpvbmUiKTsKCXAgKz0gNjsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGZzY2tfY29tbWl0X2J1ZmZlcihzdHJ1Y3QgY29tbWl0ICpjb21taXQsIGNvbnN0IGNoYXIgKmJ1ZmZlciwKCXVuc2lnbmVkIGxvbmcgc2l6ZSwgc3RydWN0IGZzY2tfb3B0aW9ucyAqb3B0aW9ucykKewoJc3RydWN0IG9iamVjdF9pZCB0cmVlX29pZCwgb2lkOwoJc3RydWN0IGNvbW1pdF9ncmFmdCAqZ3JhZnQ7Cgl1bnNpZ25lZCBwYXJlbnRfY291bnQsIHBhcmVudF9saW5lX2NvdW50ID0gMCwgYXV0aG9yX2NvdW50OwoJaW50IGVycjsKCWNvbnN0IGNoYXIgKmJ1ZmZlcl9iZWdpbiA9IGJ1ZmZlcjsKCWNvbnN0IGNoYXIgKnA7CgoJaWYgKHZlcmlmeV9oZWFkZXJzKGJ1ZmZlciwgc2l6ZSwgJmNvbW1pdC0+b2JqZWN0LCBvcHRpb25zKSkKCQlyZXR1cm4gLTE7CgoJaWYgKCFza2lwX3ByZWZpeChidWZmZXIsICJ0cmVlICIsICZidWZmZXIpKQoJCXJldHVybiByZXBvcnQob3B0aW9ucywgJmNvbW1pdC0+b2JqZWN0LCBGU0NLX01TR19NSVNTSU5HX1RSRUUsICJpbnZhbGlkIGZvcm1hdCAtIGV4cGVjdGVkICd0cmVlJyBsaW5lIik7CglpZiAocGFyc2Vfb2lkX2hleChidWZmZXIsICZ0cmVlX29pZCwgJnApIHx8ICpwICE9ICdcbicpIHsKCQllcnIgPSByZXBvcnQob3B0aW9ucywgJmNvbW1pdC0+b2JqZWN0LCBGU0NLX01TR19CQURfVFJFRV9TSEExLCAiaW52YWxpZCAndHJlZScgbGluZSBmb3JtYXQgLSBiYWQgc2hhMSIpOwoJCWlmIChlcnIpCgkJCXJldHVybiBlcnI7Cgl9CglidWZmZXIgPSBwICsgMTsKCXdoaWxlIChza2lwX3ByZWZpeChidWZmZXIsICJwYXJlbnQgIiwgJmJ1ZmZlcikpIHsKCQlpZiAocGFyc2Vfb2lkX2hleChidWZmZXIsICZvaWQsICZwKSB8fCAqcCAhPSAnXG4nKSB7CgkJCWVyciA9IHJlcG9ydChvcHRpb25zLCAmY29tbWl0LT5vYmplY3QsIEZTQ0tfTVNHX0JBRF9QQVJFTlRfU0hBMSwgImludmFsaWQgJ3BhcmVudCcgbGluZSBmb3JtYXQgLSBiYWQgc2hhMSIpOwoJCQlpZiAoZXJyKQoJCQkJcmV0dXJuIGVycjsKCQl9CgkJYnVmZmVyID0gcCArIDE7CgkJcGFyZW50X2xpbmVfY291bnQrKzsKCX0KCWdyYWZ0ID0gbG9va3VwX2NvbW1pdF9ncmFmdCh0aGVfcmVwb3NpdG9yeSwgJmNvbW1pdC0+b2JqZWN0Lm9pZCk7CglwYXJlbnRfY291bnQgPSBjb21taXRfbGlzdF9jb3VudChjb21taXQtPnBhcmVudHMpOwoJaWYgKGdyYWZ0KSB7CgkJaWYgKGdyYWZ0LT5ucl9wYXJlbnQgPT0gLTEgJiYgIXBhcmVudF9jb3VudCkKCQkJOyAvKiBzaGFsbG93IGNvbW1pdCAqLwoJCWVsc2UgaWYgKGdyYWZ0LT5ucl9wYXJlbnQgIT0gcGFyZW50X2NvdW50KSB7CgkJCWVyciA9IHJlcG9ydChvcHRpb25zLCAmY29tbWl0LT5vYmplY3QsIEZTQ0tfTVNHX01JU1NJTkdfR1JBRlQsICJncmFmdCBvYmplY3RzIG1pc3NpbmciKTsKCQkJaWYgKGVycikKCQkJCXJldHVybiBlcnI7CgkJfQoJfSBlbHNlIHsKCQlpZiAocGFyZW50X2NvdW50ICE9IHBhcmVudF9saW5lX2NvdW50KSB7CgkJCWVyciA9IHJlcG9ydChvcHRpb25zLCAmY29tbWl0LT5vYmplY3QsIEZTQ0tfTVNHX01JU1NJTkdfUEFSRU5ULCAicGFyZW50IG9iamVjdHMgbWlzc2luZyIpOwoJCQlpZiAoZXJyKQoJCQkJcmV0dXJuIGVycjsKCQl9Cgl9CglhdXRob3JfY291bnQgPSAwOwoJd2hpbGUgKHNraXBfcHJlZml4KGJ1ZmZlciwgImF1dGhvciAiLCAmYnVmZmVyKSkgewoJCWF1dGhvcl9jb3VudCsrOwoJCWVyciA9IGZzY2tfaWRlbnQoJmJ1ZmZlciwgJmNvbW1pdC0+b2JqZWN0LCBvcHRpb25zKTsKCQlpZiAoZXJyKQoJCQlyZXR1cm4gZXJyOwoJfQoJaWYgKGF1dGhvcl9jb3VudCA8IDEpCgkJZXJyID0gcmVwb3J0KG9wdGlvbnMsICZjb21taXQtPm9iamVjdCwgRlNDS19NU0dfTUlTU0lOR19BVVRIT1IsICJpbnZhbGlkIGZvcm1hdCAtIGV4cGVjdGVkICdhdXRob3InIGxpbmUiKTsKCWVsc2UgaWYgKGF1dGhvcl9jb3VudCA+IDEpCgkJZXJyID0gcmVwb3J0KG9wdGlvbnMsICZjb21taXQtPm9iamVjdCwgRlNDS19NU0dfTVVMVElQTEVfQVVUSE9SUywgImludmFsaWQgZm9ybWF0IC0gbXVsdGlwbGUgJ2F1dGhvcicgbGluZXMiKTsKCWlmIChlcnIpCgkJcmV0dXJuIGVycjsKCWlmICghc2tpcF9wcmVmaXgoYnVmZmVyLCAiY29tbWl0dGVyICIsICZidWZmZXIpKQoJCXJldHVybiByZXBvcnQob3B0aW9ucywgJmNvbW1pdC0+b2JqZWN0LCBGU0NLX01TR19NSVNTSU5HX0NPTU1JVFRFUiwgImludmFsaWQgZm9ybWF0IC0gZXhwZWN0ZWQgJ2NvbW1pdHRlcicgbGluZSIpOwoJZXJyID0gZnNja19pZGVudCgmYnVmZmVyLCAmY29tbWl0LT5vYmplY3QsIG9wdGlvbnMpOwoJaWYgKGVycikKCQlyZXR1cm4gZXJyOwoJaWYgKCFnZXRfY29tbWl0X3RyZWUoY29tbWl0KSkgewoJCWVyciA9IHJlcG9ydChvcHRpb25zLCAmY29tbWl0LT5vYmplY3QsIEZTQ0tfTVNHX0JBRF9UUkVFLCAiY291bGQgbm90IGxvYWQgY29tbWl0J3MgdHJlZSAlcyIsIG9pZF90b19oZXgoJnRyZWVfb2lkKSk7CgkJaWYgKGVycikKCQkJcmV0dXJuIGVycjsKCX0KCWlmIChtZW1jaHIoYnVmZmVyX2JlZ2luLCAnXDAnLCBzaXplKSkgewoJCWVyciA9IHJlcG9ydChvcHRpb25zLCAmY29tbWl0LT5vYmplY3QsIEZTQ0tfTVNHX05VTF9JTl9DT01NSVQsCgkJCSAgICAgIk5VTCBieXRlIGluIHRoZSBjb21taXQgb2JqZWN0IGJvZHkiKTsKCQlpZiAoZXJyKQoJCQlyZXR1cm4gZXJyOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZnNja19jb21taXQoc3RydWN0IGNvbW1pdCAqY29tbWl0LCBjb25zdCBjaGFyICpkYXRhLAoJdW5zaWduZWQgbG9uZyBzaXplLCBzdHJ1Y3QgZnNja19vcHRpb25zICpvcHRpb25zKQp7Cgljb25zdCBjaGFyICpidWZmZXIgPSBkYXRhID8gIGRhdGEgOiBnZXRfY29tbWl0X2J1ZmZlcihjb21taXQsICZzaXplKTsKCWludCByZXQgPSBmc2NrX2NvbW1pdF9idWZmZXIoY29tbWl0LCBidWZmZXIsIHNpemUsIG9wdGlvbnMpOwoJaWYgKCFkYXRhKQoJCXVudXNlX2NvbW1pdF9idWZmZXIoY29tbWl0LCBidWZmZXIpOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIGludCBmc2NrX3RhZ19idWZmZXIoc3RydWN0IHRhZyAqdGFnLCBjb25zdCBjaGFyICpkYXRhLAoJdW5zaWduZWQgbG9uZyBzaXplLCBzdHJ1Y3QgZnNja19vcHRpb25zICpvcHRpb25zKQp7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCWludCByZXQgPSAwOwoJY29uc3QgY2hhciAqYnVmZmVyOwoJY2hhciAqdG9fZnJlZSA9IE5VTEwsICplb2w7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpwOwoKCWlmIChkYXRhKQoJCWJ1ZmZlciA9IGRhdGE7CgllbHNlIHsKCQllbnVtIG9iamVjdF90eXBlIHR5cGU7CgoJCWJ1ZmZlciA9IHRvX2ZyZWUgPQoJCQlyZWFkX29iamVjdF9maWxlKCZ0YWctPm9iamVjdC5vaWQsICZ0eXBlLCAmc2l6ZSk7CgkJaWYgKCFidWZmZXIpCgkJCXJldHVybiByZXBvcnQob3B0aW9ucywgJnRhZy0+b2JqZWN0LAoJCQkJRlNDS19NU0dfTUlTU0lOR19UQUdfT0JKRUNULAoJCQkJImNhbm5vdCByZWFkIHRhZyBvYmplY3QiKTsKCgkJaWYgKHR5cGUgIT0gT0JKX1RBRykgewoJCQlyZXQgPSByZXBvcnQob3B0aW9ucywgJnRhZy0+b2JqZWN0LAoJCQkJRlNDS19NU0dfVEFHX09CSkVDVF9OT1RfVEFHLAoJCQkJImV4cGVjdGVkIHRhZyBnb3QgJXMiLAoJCQkgICAgdHlwZV9uYW1lKHR5cGUpKTsKCQkJZ290byBkb25lOwoJCX0KCX0KCglyZXQgPSB2ZXJpZnlfaGVhZGVycyhidWZmZXIsIHNpemUsICZ0YWctPm9iamVjdCwgb3B0aW9ucyk7CglpZiAocmV0KQoJCWdvdG8gZG9uZTsKCglpZiAoIXNraXBfcHJlZml4KGJ1ZmZlciwgIm9iamVjdCAiLCAmYnVmZmVyKSkgewoJCXJldCA9IHJlcG9ydChvcHRpb25zLCAmdGFnLT5vYmplY3QsIEZTQ0tfTVNHX01JU1NJTkdfT0JKRUNULCAiaW52YWxpZCBmb3JtYXQgLSBleHBlY3RlZCAnb2JqZWN0JyBsaW5lIik7CgkJZ290byBkb25lOwoJfQoJaWYgKHBhcnNlX29pZF9oZXgoYnVmZmVyLCAmb2lkLCAmcCkgfHwgKnAgIT0gJ1xuJykgewoJCXJldCA9IHJlcG9ydChvcHRpb25zLCAmdGFnLT5vYmplY3QsIEZTQ0tfTVNHX0JBRF9PQkpFQ1RfU0hBMSwgImludmFsaWQgJ29iamVjdCcgbGluZSBmb3JtYXQgLSBiYWQgc2hhMSIpOwoJCWlmIChyZXQpCgkJCWdvdG8gZG9uZTsKCX0KCWJ1ZmZlciA9IHAgKyAxOwoKCWlmICghc2tpcF9wcmVmaXgoYnVmZmVyLCAidHlwZSAiLCAmYnVmZmVyKSkgewoJCXJldCA9IHJlcG9ydChvcHRpb25zLCAmdGFnLT5vYmplY3QsIEZTQ0tfTVNHX01JU1NJTkdfVFlQRV9FTlRSWSwgImludmFsaWQgZm9ybWF0IC0gZXhwZWN0ZWQgJ3R5cGUnIGxpbmUiKTsKCQlnb3RvIGRvbmU7Cgl9Cgllb2wgPSBzdHJjaHIoYnVmZmVyLCAnXG4nKTsKCWlmICghZW9sKSB7CgkJcmV0ID0gcmVwb3J0KG9wdGlvbnMsICZ0YWctPm9iamVjdCwgRlNDS19NU0dfTUlTU0lOR19UWVBFLCAiaW52YWxpZCBmb3JtYXQgLSB1bmV4cGVjdGVkIGVuZCBhZnRlciAndHlwZScgbGluZSIpOwoJCWdvdG8gZG9uZTsKCX0KCWlmICh0eXBlX2Zyb21fc3RyaW5nX2dlbnRseShidWZmZXIsIGVvbCAtIGJ1ZmZlciwgMSkgPCAwKQoJCXJldCA9IHJlcG9ydChvcHRpb25zLCAmdGFnLT5vYmplY3QsIEZTQ0tfTVNHX0JBRF9UWVBFLCAiaW52YWxpZCAndHlwZScgdmFsdWUiKTsKCWlmIChyZXQpCgkJZ290byBkb25lOwoJYnVmZmVyID0gZW9sICsgMTsKCglpZiAoIXNraXBfcHJlZml4KGJ1ZmZlciwgInRhZyAiLCAmYnVmZmVyKSkgewoJCXJldCA9IHJlcG9ydChvcHRpb25zLCAmdGFnLT5vYmplY3QsIEZTQ0tfTVNHX01JU1NJTkdfVEFHX0VOVFJZLCAiaW52YWxpZCBmb3JtYXQgLSBleHBlY3RlZCAndGFnJyBsaW5lIik7CgkJZ290byBkb25lOwoJfQoJZW9sID0gc3RyY2hyKGJ1ZmZlciwgJ1xuJyk7CglpZiAoIWVvbCkgewoJCXJldCA9IHJlcG9ydChvcHRpb25zLCAmdGFnLT5vYmplY3QsIEZTQ0tfTVNHX01JU1NJTkdfVEFHLCAiaW52YWxpZCBmb3JtYXQgLSB1bmV4cGVjdGVkIGVuZCBhZnRlciAndHlwZScgbGluZSIpOwoJCWdvdG8gZG9uZTsKCX0KCXN0cmJ1Zl9hZGRmKCZzYiwgInJlZnMvdGFncy8lLipzIiwgKGludCkoZW9sIC0gYnVmZmVyKSwgYnVmZmVyKTsKCWlmIChjaGVja19yZWZuYW1lX2Zvcm1hdChzYi5idWYsIDApKSB7CgkJcmV0ID0gcmVwb3J0KG9wdGlvbnMsICZ0YWctPm9iamVjdCwgRlNDS19NU0dfQkFEX1RBR19OQU1FLAoJCQkgICAiaW52YWxpZCAndGFnJyBuYW1lOiAlLipzIiwKCQkJICAgKGludCkoZW9sIC0gYnVmZmVyKSwgYnVmZmVyKTsKCQlpZiAocmV0KQoJCQlnb3RvIGRvbmU7Cgl9CglidWZmZXIgPSBlb2wgKyAxOwoKCWlmICghc2tpcF9wcmVmaXgoYnVmZmVyLCAidGFnZ2VyICIsICZidWZmZXIpKSB7CgkJLyogZWFybHkgdGFncyBkbyBub3QgY29udGFpbiAndGFnZ2VyJyBsaW5lczsgd2FybiBvbmx5ICovCgkJcmV0ID0gcmVwb3J0KG9wdGlvbnMsICZ0YWctPm9iamVjdCwgRlNDS19NU0dfTUlTU0lOR19UQUdHRVJfRU5UUlksICJpbnZhbGlkIGZvcm1hdCAtIGV4cGVjdGVkICd0YWdnZXInIGxpbmUiKTsKCQlpZiAocmV0KQoJCQlnb3RvIGRvbmU7Cgl9CgllbHNlCgkJcmV0ID0gZnNja19pZGVudCgmYnVmZmVyLCAmdGFnLT5vYmplY3QsIG9wdGlvbnMpOwoKZG9uZToKCXN0cmJ1Zl9yZWxlYXNlKCZzYik7CglmcmVlKHRvX2ZyZWUpOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIGludCBmc2NrX3RhZyhzdHJ1Y3QgdGFnICp0YWcsIGNvbnN0IGNoYXIgKmRhdGEsCgl1bnNpZ25lZCBsb25nIHNpemUsIHN0cnVjdCBmc2NrX29wdGlvbnMgKm9wdGlvbnMpCnsKCXN0cnVjdCBvYmplY3QgKnRhZ2dlZCA9IHRhZy0+dGFnZ2VkOwoKCWlmICghdGFnZ2VkKQoJCXJldHVybiByZXBvcnQob3B0aW9ucywgJnRhZy0+b2JqZWN0LCBGU0NLX01TR19CQURfVEFHX09CSkVDVCwgImNvdWxkIG5vdCBsb2FkIHRhZ2dlZCBvYmplY3QiKTsKCglyZXR1cm4gZnNja190YWdfYnVmZmVyKHRhZywgZGF0YSwgc2l6ZSwgb3B0aW9ucyk7Cn0KCi8qCiAqIExpa2UgYnVpbHRpbi9zdWJtb2R1bGUtLWhlbHBlci5jJ3Mgc3RhcnRzX3dpdGhfZG90X3NsYXNoLCBidXQgd2l0aG91dAogKiByZWx5aW5nIG9uIHRoZSBwbGF0Zm9ybS1kZXBlbmRlbnQgaXNfZGlyX3NlcCBoZWxwZXIuCiAqCiAqIFRoaXMgaXMgZm9yIHVzZSBpbiBjaGVja2luZyB3aGV0aGVyIGEgc3VibW9kdWxlIFVSTCBpcyBpbnRlcnByZXRlZCBhcwogKiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBkaXJlY3Rvcnkgb24gYW55IHBsYXRmb3JtLCBzaW5jZSBcIGlzIGEKICogZGlyZWN0b3J5IHNlcGFyYXRvciBvbiBXaW5kb3dzIGJ1dCBub3Qgb24gb3RoZXIgcGxhdGZvcm1zLgogKi8Kc3RhdGljIGludCBzdGFydHNfd2l0aF9kb3Rfc2xhc2goY29uc3QgY2hhciAqc3RyKQp7CglyZXR1cm4gc3RyWzBdID09ICcuJyAmJiAoc3RyWzFdID09ICcvJyB8fCBzdHJbMV0gPT0gJ1xcJyk7Cn0KCi8qCiAqIExpa2Ugc3RhcnRzX3dpdGhfZG90X3NsYXNoLCB0aGlzIGlzIGEgdmFyaWFudCBvZiBzdWJtb2R1bGUtLWhlbHBlcidzCiAqIGhlbHBlciBvZiB0aGUgc2FtZSBuYW1lIHdpdGggdGhlIHR3aXN0IHRoYXQgaXQgYWNjZXB0cyBiYWNrc2xhc2ggYXMgYQogKiBkaXJlY3Rvcnkgc2VwYXJhdG9yIGV2ZW4gb24gbm9uLVdpbmRvd3MgcGxhdGZvcm1zLgogKi8Kc3RhdGljIGludCBzdGFydHNfd2l0aF9kb3RfZG90X3NsYXNoKGNvbnN0IGNoYXIgKnN0cikKewoJcmV0dXJuIHN0clswXSA9PSAnLicgJiYgc3RhcnRzX3dpdGhfZG90X3NsYXNoKHN0ciArIDEpOwp9CgpzdGF0aWMgaW50IHN1Ym1vZHVsZV91cmxfaXNfcmVsYXRpdmUoY29uc3QgY2hhciAqdXJsKQp7CglyZXR1cm4gc3RhcnRzX3dpdGhfZG90X3NsYXNoKHVybCkgfHwgc3RhcnRzX3dpdGhfZG90X2RvdF9zbGFzaCh1cmwpOwp9CgovKgogKiBDb3VudCBkaXJlY3RvcnkgY29tcG9uZW50cyB0aGF0IGEgcmVsYXRpdmUgc3VibW9kdWxlIFVSTCBzaG91bGQgY2hvcAogKiBmcm9tIHRoZSByZW1vdGVfdXJsIGl0IGlzIHRvIGJlIHJlc29sdmVkIGFnYWluc3QuCiAqCiAqIEluIG90aGVyIHdvcmRzLCB0aGlzIGNvdW50cyAiLi4vIiBjb21wb25lbnRzIGF0IHRoZSBzdGFydCBvZiBhCiAqIHN1Ym1vZHVsZSBVUkwuCiAqCiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkaXJlY3RvcnkgY29tcG9uZW50cyB0byBjaG9wIGFuZCB3cml0ZXMgYQogKiBwb2ludGVyIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBvZiB1cmwgYWZ0ZXIgYWxsIGxlYWRpbmcgIi4vIiBhbmQKICogIi4uLyIgY29tcG9uZW50cyB0byBvdXQuCiAqLwpzdGF0aWMgaW50IGNvdW50X2xlYWRpbmdfZG90ZG90cyhjb25zdCBjaGFyICp1cmwsIGNvbnN0IGNoYXIgKipvdXQpCnsKCWludCByZXN1bHQgPSAwOwoJd2hpbGUgKDEpIHsKCQlpZiAoc3RhcnRzX3dpdGhfZG90X2RvdF9zbGFzaCh1cmwpKSB7CgkJCXJlc3VsdCsrOwoJCQl1cmwgKz0gc3RybGVuKCIuLi8iKTsKCQkJY29udGludWU7CgkJfQoJCWlmIChzdGFydHNfd2l0aF9kb3Rfc2xhc2godXJsKSkgewoJCQl1cmwgKz0gc3RybGVuKCIuLyIpOwoJCQljb250aW51ZTsKCQl9CgkJKm91dCA9IHVybDsKCQlyZXR1cm4gcmVzdWx0OwoJfQp9Ci8qCiAqIENoZWNrIHdoZXRoZXIgYSB0cmFuc3BvcnQgaXMgaW1wbGVtZW50ZWQgYnkgZ2l0LXJlbW90ZS1jdXJsLgogKgogKiBJZiBpdCBpcywgcmV0dXJucyAxIGFuZCB3cml0ZXMgdGhlIFVSTCB0aGF0IHdvdWxkIGJlIHBhc3NlZCB0bwogKiBnaXQtcmVtb3RlLWN1cmwgdG8gdGhlICJvdXQiIHBhcmFtZXRlci4KICoKICogT3RoZXJ3aXNlLCByZXR1cm5zIDAgYW5kIGxlYXZlcyAib3V0IiB1bnRvdWNoZWQuCiAqCiAqIEV4YW1wbGVzOgogKiAgIGh0dHA6Omh0dHBzOi8vZXhhbXBsZS5jb20vcmVwby5naXQgLT4gMSwgaHR0cHM6Ly9leGFtcGxlLmNvbS9yZXBvLmdpdAogKiAgIGh0dHBzOi8vZXhhbXBsZS5jb20vcmVwby5naXQgLT4gMSwgaHR0cHM6Ly9leGFtcGxlLmNvbS9yZXBvLmdpdAogKiAgIGdpdDovL2V4YW1wbGUuY29tL3JlcG8uZ2l0IC0+IDAKICoKICogVGhpcyBpcyBmb3IgdXNlIGluIGNoZWNraW5nIGZvciBwcmV2aW91c2x5IGV4cGxvaXRhYmxlIGJ1Z3MgdGhhdAogKiByZXF1aXJlZCBhIHN1Ym1vZHVsZSBVUkwgdG8gYmUgcGFzc2VkIHRvIGdpdC1yZW1vdGUtY3VybC4KICovCnN0YXRpYyBpbnQgdXJsX3RvX2N1cmxfdXJsKGNvbnN0IGNoYXIgKnVybCwgY29uc3QgY2hhciAqKm91dCkKewoJLyoKCSAqIFdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZm9yIGNhc2UtYWxpYXNlcywgImh0dHAuZXhlIiwgYW5kIHNvCgkgKiBvbiBiZWNhdXNlIGluIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24sIGlzX3RyYW5zcG9ydF9hbGxvd2VkCgkgKiBwcmV2ZW50cyBVUkxzIHdpdGggdGhvc2Ugc2NoZW1lcyBmcm9tIGJlaW5nIGNsb25lZAoJICogYXV0b21hdGljYWxseS4KCSAqLwoJaWYgKHNraXBfcHJlZml4KHVybCwgImh0dHA6OiIsIG91dCkgfHwKCSAgICBza2lwX3ByZWZpeCh1cmwsICJodHRwczo6Iiwgb3V0KSB8fAoJICAgIHNraXBfcHJlZml4KHVybCwgImZ0cDo6Iiwgb3V0KSB8fAoJICAgIHNraXBfcHJlZml4KHVybCwgImZ0cHM6OiIsIG91dCkpCgkJcmV0dXJuIDE7CglpZiAoc3RhcnRzX3dpdGgodXJsLCAiaHR0cDovLyIpIHx8CgkgICAgc3RhcnRzX3dpdGgodXJsLCAiaHR0cHM6Ly8iKSB8fAoJICAgIHN0YXJ0c193aXRoKHVybCwgImZ0cDovLyIpIHx8CgkgICAgc3RhcnRzX3dpdGgodXJsLCAiZnRwczovLyIpKSB7CgkJKm91dCA9IHVybDsKCQlyZXR1cm4gMTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGNoZWNrX3N1Ym1vZHVsZV91cmwoY29uc3QgY2hhciAqdXJsKQp7Cgljb25zdCBjaGFyICpjdXJsX3VybDsKCglpZiAobG9va3NfbGlrZV9jb21tYW5kX2xpbmVfb3B0aW9uKHVybCkpCgkJcmV0dXJuIC0xOwoKCWlmIChzdWJtb2R1bGVfdXJsX2lzX3JlbGF0aXZlKHVybCkpIHsKCQljaGFyICpkZWNvZGVkOwoJCWNvbnN0IGNoYXIgKm5leHQ7CgkJaW50IGhhc19ubDsKCgkJLyoKCQkgKiBUaGlzIGNvdWxkIGJlIGFwcGVuZGVkIHRvIGFuIGh0dHAgVVJMIGFuZCB1cmwtZGVjb2RlZDsKCQkgKiBjaGVjayBmb3IgbWFsaWNpb3VzIGNoYXJhY3RlcnMuCgkJICovCgkJZGVjb2RlZCA9IHVybF9kZWNvZGUodXJsKTsKCQloYXNfbmwgPSAhIXN0cmNocihkZWNvZGVkLCAnXG4nKTsKCgkJZnJlZShkZWNvZGVkKTsKCQlpZiAoaGFzX25sKQoJCQlyZXR1cm4gLTE7CgoJCS8qCgkJICogVVJMcyB3aGljaCBlc2NhcGUgdGhlaXIgcm9vdCB2aWEgIi4uLyIgY2FuIG92ZXJ3cml0ZQoJCSAqIHRoZSBob3N0IGZpZWxkIGFuZCBwcmV2aW91cyBjb21wb25lbnRzLCByZXNvbHZpbmcgdG8KCQkgKiBVUkxzIGxpa2UgaHR0cHM6OmV4YW1wbGUuY29tL3N1Ym1vZHVsZS5naXQgYW5kCgkJICogaHR0cHM6Ly8vZXhhbXBsZS5jb20vc3VibW9kdWxlLmdpdCB0aGF0IHdlcmUKCQkgKiBzdXNjZXB0aWJsZSB0byBDVkUtMjAyMC0xMTAwOC4KCQkgKi8KCQlpZiAoY291bnRfbGVhZGluZ19kb3Rkb3RzKHVybCwgJm5leHQpID4gMCAmJgoJCSAgICAoKm5leHQgPT0gJzonIHx8ICpuZXh0ID09ICcvJykpCgkJCXJldHVybiAtMTsKCX0KCgllbHNlIGlmICh1cmxfdG9fY3VybF91cmwodXJsLCAmY3VybF91cmwpKSB7CgkJc3RydWN0IGNyZWRlbnRpYWwgYyA9IENSRURFTlRJQUxfSU5JVDsKCQlpbnQgcmV0ID0gMDsKCQlpZiAoY3JlZGVudGlhbF9mcm9tX3VybF9nZW50bHkoJmMsIGN1cmxfdXJsLCAxKSB8fAoJCSAgICAhKmMuaG9zdCkKCQkJcmV0ID0gLTE7CgkJY3JlZGVudGlhbF9jbGVhcigmYyk7CgkJcmV0dXJuIHJldDsKCX0KCglyZXR1cm4gMDsKfQoKc3RydWN0IGZzY2tfZ2l0bW9kdWxlc19kYXRhIHsKCXN0cnVjdCBvYmplY3QgKm9iajsKCXN0cnVjdCBmc2NrX29wdGlvbnMgKm9wdGlvbnM7CglpbnQgcmV0Owp9OwoKc3RhdGljIGludCBmc2NrX2dpdG1vZHVsZXNfZm4oY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSwgdm9pZCAqdmRhdGEpCnsKCXN0cnVjdCBmc2NrX2dpdG1vZHVsZXNfZGF0YSAqZGF0YSA9IHZkYXRhOwoJY29uc3QgY2hhciAqc3Vic2VjdGlvbiwgKmtleTsKCWludCBzdWJzZWN0aW9uX2xlbjsKCWNoYXIgKm5hbWU7CgoJaWYgKHBhcnNlX2NvbmZpZ19rZXkodmFyLCAic3VibW9kdWxlIiwgJnN1YnNlY3Rpb24sICZzdWJzZWN0aW9uX2xlbiwgJmtleSkgPCAwIHx8CgkgICAgIXN1YnNlY3Rpb24pCgkJcmV0dXJuIDA7CgoJbmFtZSA9IHhtZW1kdXB6KHN1YnNlY3Rpb24sIHN1YnNlY3Rpb25fbGVuKTsKCWlmIChjaGVja19zdWJtb2R1bGVfbmFtZShuYW1lKSA8IDApCgkJZGF0YS0+cmV0IHw9IHJlcG9ydChkYXRhLT5vcHRpb25zLCBkYXRhLT5vYmosCgkJCQkgICAgRlNDS19NU0dfR0lUTU9EVUxFU19OQU1FLAoJCQkJICAgICJkaXNhbGxvd2VkIHN1Ym1vZHVsZSBuYW1lOiAlcyIsCgkJCQkgICAgbmFtZSk7CglpZiAoIXN0cmNtcChrZXksICJ1cmwiKSAmJiB2YWx1ZSAmJgoJICAgIGNoZWNrX3N1Ym1vZHVsZV91cmwodmFsdWUpIDwgMCkKCQlkYXRhLT5yZXQgfD0gcmVwb3J0KGRhdGEtPm9wdGlvbnMsIGRhdGEtPm9iaiwKCQkJCSAgICBGU0NLX01TR19HSVRNT0RVTEVTX1VSTCwKCQkJCSAgICAiZGlzYWxsb3dlZCBzdWJtb2R1bGUgdXJsOiAlcyIsCgkJCQkgICAgdmFsdWUpOwoJaWYgKCFzdHJjbXAoa2V5LCAicGF0aCIpICYmIHZhbHVlICYmCgkgICAgbG9va3NfbGlrZV9jb21tYW5kX2xpbmVfb3B0aW9uKHZhbHVlKSkKCQlkYXRhLT5yZXQgfD0gcmVwb3J0KGRhdGEtPm9wdGlvbnMsIGRhdGEtPm9iaiwKCQkJCSAgICBGU0NLX01TR19HSVRNT0RVTEVTX1BBVEgsCgkJCQkgICAgImRpc2FsbG93ZWQgc3VibW9kdWxlIHBhdGg6ICVzIiwKCQkJCSAgICB2YWx1ZSk7CglpZiAoIXN0cmNtcChrZXksICJ1cGRhdGUiKSAmJiB2YWx1ZSAmJgoJICAgIHBhcnNlX3N1Ym1vZHVsZV91cGRhdGVfdHlwZSh2YWx1ZSkgPT0gU01fVVBEQVRFX0NPTU1BTkQpCgkJZGF0YS0+cmV0IHw9IHJlcG9ydChkYXRhLT5vcHRpb25zLCBkYXRhLT5vYmosCgkJCQkgICAgRlNDS19NU0dfR0lUTU9EVUxFU19VUERBVEUsCgkJCQkgICAgImRpc2FsbG93ZWQgc3VibW9kdWxlIHVwZGF0ZSBzZXR0aW5nOiAlcyIsCgkJCQkgICAgdmFsdWUpOwoJZnJlZShuYW1lKTsKCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBmc2NrX2Jsb2Ioc3RydWN0IGJsb2IgKmJsb2IsIGNvbnN0IGNoYXIgKmJ1ZiwKCQkgICAgIHVuc2lnbmVkIGxvbmcgc2l6ZSwgc3RydWN0IGZzY2tfb3B0aW9ucyAqb3B0aW9ucykKewoJc3RydWN0IGZzY2tfZ2l0bW9kdWxlc19kYXRhIGRhdGE7CglzdHJ1Y3QgY29uZmlnX29wdGlvbnMgY29uZmlnX29wdHMgPSB7IDAgfTsKCglpZiAoIW9pZHNldF9jb250YWlucygmZ2l0bW9kdWxlc19mb3VuZCwgJmJsb2ItPm9iamVjdC5vaWQpKQoJCXJldHVybiAwOwoJb2lkc2V0X2luc2VydCgmZ2l0bW9kdWxlc19kb25lLCAmYmxvYi0+b2JqZWN0Lm9pZCk7CgoJaWYgKG9iamVjdF9vbl9za2lwbGlzdChvcHRpb25zLCAmYmxvYi0+b2JqZWN0KSkKCQlyZXR1cm4gMDsKCglpZiAoIWJ1ZikgewoJCS8qCgkJICogQSBtaXNzaW5nIGJ1ZmZlciBoZXJlIGlzIGEgc2lnbiB0aGF0IHRoZSBjYWxsZXIgZm91bmQgdGhlCgkJICogYmxvYiB0b28gZ2lnYW50aWMgdG8gbG9hZCBpbnRvIG1lbW9yeS4gTGV0J3MganVzdCBjb25zaWRlcgoJCSAqIHRoYXQgYW4gZXJyb3IuCgkJICovCgkJcmV0dXJuIHJlcG9ydChvcHRpb25zLCAmYmxvYi0+b2JqZWN0LAoJCQkgICAgICBGU0NLX01TR19HSVRNT0RVTEVTX0xBUkdFLAoJCQkgICAgICAiLmdpdG1vZHVsZXMgdG9vIGxhcmdlIHRvIHBhcnNlIik7Cgl9CgoJZGF0YS5vYmogPSAmYmxvYi0+b2JqZWN0OwoJZGF0YS5vcHRpb25zID0gb3B0aW9uczsKCWRhdGEucmV0ID0gMDsKCWNvbmZpZ19vcHRzLmVycm9yX2FjdGlvbiA9IENPTkZJR19FUlJPUl9TSUxFTlQ7CglpZiAoZ2l0X2NvbmZpZ19mcm9tX21lbShmc2NrX2dpdG1vZHVsZXNfZm4sIENPTkZJR19PUklHSU5fQkxPQiwKCQkJCSIuZ2l0bW9kdWxlcyIsIGJ1Ziwgc2l6ZSwgJmRhdGEsICZjb25maWdfb3B0cykpCgkJZGF0YS5yZXQgfD0gcmVwb3J0KG9wdGlvbnMsICZibG9iLT5vYmplY3QsCgkJCQkgICBGU0NLX01TR19HSVRNT0RVTEVTX1BBUlNFLAoJCQkJICAgImNvdWxkIG5vdCBwYXJzZSBnaXRtb2R1bGVzIGJsb2IiKTsKCglyZXR1cm4gZGF0YS5yZXQ7Cn0KCmludCBmc2NrX29iamVjdChzdHJ1Y3Qgb2JqZWN0ICpvYmosIHZvaWQgKmRhdGEsIHVuc2lnbmVkIGxvbmcgc2l6ZSwKCXN0cnVjdCBmc2NrX29wdGlvbnMgKm9wdGlvbnMpCnsKCWlmICghb2JqKQoJCXJldHVybiByZXBvcnQob3B0aW9ucywgb2JqLCBGU0NLX01TR19CQURfT0JKRUNUX1NIQTEsICJubyB2YWxpZCBvYmplY3QgdG8gZnNjayIpOwoKCWlmIChvYmotPnR5cGUgPT0gT0JKX0JMT0IpCgkJcmV0dXJuIGZzY2tfYmxvYigoc3RydWN0IGJsb2IgKilvYmosIGRhdGEsIHNpemUsIG9wdGlvbnMpOwoJaWYgKG9iai0+dHlwZSA9PSBPQkpfVFJFRSkKCQlyZXR1cm4gZnNja190cmVlKChzdHJ1Y3QgdHJlZSAqKSBvYmosIG9wdGlvbnMpOwoJaWYgKG9iai0+dHlwZSA9PSBPQkpfQ09NTUlUKQoJCXJldHVybiBmc2NrX2NvbW1pdCgoc3RydWN0IGNvbW1pdCAqKSBvYmosIChjb25zdCBjaGFyICopIGRhdGEsCgkJCXNpemUsIG9wdGlvbnMpOwoJaWYgKG9iai0+dHlwZSA9PSBPQkpfVEFHKQoJCXJldHVybiBmc2NrX3RhZygoc3RydWN0IHRhZyAqKSBvYmosIChjb25zdCBjaGFyICopIGRhdGEsCgkJCXNpemUsIG9wdGlvbnMpOwoKCXJldHVybiByZXBvcnQob3B0aW9ucywgb2JqLCBGU0NLX01TR19VTktOT1dOX1RZUEUsICJ1bmtub3duIHR5cGUgJyVkJyAoaW50ZXJuYWwgZnNjayBlcnJvcikiLAoJCQkgIG9iai0+dHlwZSk7Cn0KCmludCBmc2NrX2Vycm9yX2Z1bmN0aW9uKHN0cnVjdCBmc2NrX29wdGlvbnMgKm8sCglzdHJ1Y3Qgb2JqZWN0ICpvYmosIGludCBtc2dfdHlwZSwgY29uc3QgY2hhciAqbWVzc2FnZSkKewoJaWYgKG1zZ190eXBlID09IEZTQ0tfV0FSTikgewoJCXdhcm5pbmcoIm9iamVjdCAlczogJXMiLCBkZXNjcmliZV9vYmplY3Qobywgb2JqKSwgbWVzc2FnZSk7CgkJcmV0dXJuIDA7Cgl9CgllcnJvcigib2JqZWN0ICVzOiAlcyIsIGRlc2NyaWJlX29iamVjdChvLCBvYmopLCBtZXNzYWdlKTsKCXJldHVybiAxOwp9CgppbnQgZnNja19maW5pc2goc3RydWN0IGZzY2tfb3B0aW9ucyAqb3B0aW9ucykKewoJaW50IHJldCA9IDA7CglzdHJ1Y3Qgb2lkc2V0X2l0ZXIgaXRlcjsKCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZDsKCglvaWRzZXRfaXRlcl9pbml0KCZnaXRtb2R1bGVzX2ZvdW5kLCAmaXRlcik7Cgl3aGlsZSAoKG9pZCA9IG9pZHNldF9pdGVyX25leHQoJml0ZXIpKSkgewoJCXN0cnVjdCBibG9iICpibG9iOwoJCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCQl1bnNpZ25lZCBsb25nIHNpemU7CgkJY2hhciAqYnVmOwoKCQlpZiAob2lkc2V0X2NvbnRhaW5zKCZnaXRtb2R1bGVzX2RvbmUsIG9pZCkpCgkJCWNvbnRpbnVlOwoKCQlibG9iID0gbG9va3VwX2Jsb2IodGhlX3JlcG9zaXRvcnksIG9pZCk7CgkJaWYgKCFibG9iKSB7CgkJCXN0cnVjdCBvYmplY3QgKm9iaiA9IGxvb2t1cF91bmtub3duX29iamVjdChvaWQpOwoJCQlyZXQgfD0gcmVwb3J0KG9wdGlvbnMsIG9iaiwKCQkJCSAgICAgIEZTQ0tfTVNHX0dJVE1PRFVMRVNfQkxPQiwKCQkJCSAgICAgICJub24tYmxvYiBmb3VuZCBhdCAuZ2l0bW9kdWxlcyIpOwoJCQljb250aW51ZTsKCQl9CgoJCWJ1ZiA9IHJlYWRfb2JqZWN0X2ZpbGUob2lkLCAmdHlwZSwgJnNpemUpOwoJCWlmICghYnVmKSB7CgkJCWlmIChpc19wcm9taXNvcl9vYmplY3QoJmJsb2ItPm9iamVjdC5vaWQpKQoJCQkJY29udGludWU7CgkJCXJldCB8PSByZXBvcnQob3B0aW9ucywgJmJsb2ItPm9iamVjdCwKCQkJCSAgICAgIEZTQ0tfTVNHX0dJVE1PRFVMRVNfTUlTU0lORywKCQkJCSAgICAgICJ1bmFibGUgdG8gcmVhZCAuZ2l0bW9kdWxlcyBibG9iIik7CgkJCWNvbnRpbnVlOwoJCX0KCgkJaWYgKHR5cGUgPT0gT0JKX0JMT0IpCgkJCXJldCB8PSBmc2NrX2Jsb2IoYmxvYiwgYnVmLCBzaXplLCBvcHRpb25zKTsKCQllbHNlCgkJCXJldCB8PSByZXBvcnQob3B0aW9ucywgJmJsb2ItPm9iamVjdCwKCQkJCSAgICAgIEZTQ0tfTVNHX0dJVE1PRFVMRVNfQkxPQiwKCQkJCSAgICAgICJub24tYmxvYiBmb3VuZCBhdCAuZ2l0bW9kdWxlcyIpOwoJCWZyZWUoYnVmKTsKCX0KCgoJb2lkc2V0X2NsZWFyKCZnaXRtb2R1bGVzX2ZvdW5kKTsKCW9pZHNldF9jbGVhcigmZ2l0bW9kdWxlc19kb25lKTsKCXJldHVybiByZXQ7Cn0K",
    "text": "#include \"cache.h\"\n#include \"object-store.h\"\n#include \"repository.h\"\n#include \"object.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"tree-walk.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"fsck.h\"\n#include \"refs.h\"\n#include \"url.h\"\n#include \"utf8.h\"\n#include \"decorate.h\"\n#include \"oidset.h\"\n#include \"packfile.h\"\n#include \"submodule-config.h\"\n#include \"config.h\"\n#include \"credential.h\"\n#include \"help.h\"\n\nstatic struct oidset gitmodules_found = OIDSET_INIT;\nstatic struct oidset gitmodules_done = OIDSET_INIT;\n\n#define FSCK_FATAL -1\n#define FSCK_INFO -2\n\n#define FOREACH_MSG_ID(FUNC) \\\n\t/* fatal errors */ \\\n\tFUNC(NUL_IN_HEADER, FATAL) \\\n\tFUNC(UNTERMINATED_HEADER, FATAL) \\\n\t/* errors */ \\\n\tFUNC(BAD_DATE, ERROR) \\\n\tFUNC(BAD_DATE_OVERFLOW, ERROR) \\\n\tFUNC(BAD_EMAIL, ERROR) \\\n\tFUNC(BAD_NAME, ERROR) \\\n\tFUNC(BAD_OBJECT_SHA1, ERROR) \\\n\tFUNC(BAD_PARENT_SHA1, ERROR) \\\n\tFUNC(BAD_TAG_OBJECT, ERROR) \\\n\tFUNC(BAD_TIMEZONE, ERROR) \\\n\tFUNC(BAD_TREE, ERROR) \\\n\tFUNC(BAD_TREE_SHA1, ERROR) \\\n\tFUNC(BAD_TYPE, ERROR) \\\n\tFUNC(DUPLICATE_ENTRIES, ERROR) \\\n\tFUNC(MISSING_AUTHOR, ERROR) \\\n\tFUNC(MISSING_COMMITTER, ERROR) \\\n\tFUNC(MISSING_EMAIL, ERROR) \\\n\tFUNC(MISSING_GRAFT, ERROR) \\\n\tFUNC(MISSING_NAME_BEFORE_EMAIL, ERROR) \\\n\tFUNC(MISSING_OBJECT, ERROR) \\\n\tFUNC(MISSING_PARENT, ERROR) \\\n\tFUNC(MISSING_SPACE_BEFORE_DATE, ERROR) \\\n\tFUNC(MISSING_SPACE_BEFORE_EMAIL, ERROR) \\\n\tFUNC(MISSING_TAG, ERROR) \\\n\tFUNC(MISSING_TAG_ENTRY, ERROR) \\\n\tFUNC(MISSING_TAG_OBJECT, ERROR) \\\n\tFUNC(MISSING_TREE, ERROR) \\\n\tFUNC(MISSING_TREE_OBJECT, ERROR) \\\n\tFUNC(MISSING_TYPE, ERROR) \\\n\tFUNC(MISSING_TYPE_ENTRY, ERROR) \\\n\tFUNC(MULTIPLE_AUTHORS, ERROR) \\\n\tFUNC(TAG_OBJECT_NOT_TAG, ERROR) \\\n\tFUNC(TREE_NOT_SORTED, ERROR) \\\n\tFUNC(UNKNOWN_TYPE, ERROR) \\\n\tFUNC(ZERO_PADDED_DATE, ERROR) \\\n\tFUNC(GITMODULES_MISSING, ERROR) \\\n\tFUNC(GITMODULES_BLOB, ERROR) \\\n\tFUNC(GITMODULES_LARGE, ERROR) \\\n\tFUNC(GITMODULES_NAME, ERROR) \\\n\tFUNC(GITMODULES_SYMLINK, ERROR) \\\n\tFUNC(GITMODULES_URL, ERROR) \\\n\tFUNC(GITMODULES_PATH, ERROR) \\\n\tFUNC(GITMODULES_UPDATE, ERROR) \\\n\t/* warnings */ \\\n\tFUNC(BAD_FILEMODE, WARN) \\\n\tFUNC(EMPTY_NAME, WARN) \\\n\tFUNC(FULL_PATHNAME, WARN) \\\n\tFUNC(HAS_DOT, WARN) \\\n\tFUNC(HAS_DOTDOT, WARN) \\\n\tFUNC(HAS_DOTGIT, WARN) \\\n\tFUNC(NULL_SHA1, WARN) \\\n\tFUNC(ZERO_PADDED_FILEMODE, WARN) \\\n\tFUNC(NUL_IN_COMMIT, WARN) \\\n\t/* infos (reported as warnings, but ignored by default) */ \\\n\tFUNC(GITMODULES_PARSE, INFO) \\\n\tFUNC(BAD_TAG_NAME, INFO) \\\n\tFUNC(MISSING_TAGGER_ENTRY, INFO)\n\n#define MSG_ID(id, msg_type) FSCK_MSG_##id,\nenum fsck_msg_id {\n\tFOREACH_MSG_ID(MSG_ID)\n\tFSCK_MSG_MAX\n};\n#undef MSG_ID\n\n#define STR(x) #x\n#define MSG_ID(id, msg_type) { STR(id), NULL, NULL, FSCK_##msg_type },\nstatic struct {\n\tconst char *id_string;\n\tconst char *downcased;\n\tconst char *camelcased;\n\tint msg_type;\n} msg_id_info[FSCK_MSG_MAX + 1] = {\n\tFOREACH_MSG_ID(MSG_ID)\n\t{ NULL, NULL, NULL, -1 }\n};\n#undef MSG_ID\n\nstatic void prepare_msg_ids(void)\n{\n\tint i;\n\n\tif (msg_id_info[0].downcased)\n\t\treturn;\n\n\t/* convert id_string to lower case, without underscores. */\n\tfor (i = 0; i < FSCK_MSG_MAX; i++) {\n\t\tconst char *p = msg_id_info[i].id_string;\n\t\tint len = strlen(p);\n\t\tchar *q = xmalloc(len);\n\n\t\tmsg_id_info[i].downcased = q;\n\t\twhile (*p)\n\t\t\tif (*p == '_')\n\t\t\t\tp++;\n\t\t\telse\n\t\t\t\t*(q)++ = tolower(*(p)++);\n\t\t*q = '\\0';\n\n\t\tp = msg_id_info[i].id_string;\n\t\tq = xmalloc(len);\n\t\tmsg_id_info[i].camelcased = q;\n\t\twhile (*p) {\n\t\t\tif (*p == '_') {\n\t\t\t\tp++;\n\t\t\t\tif (*p)\n\t\t\t\t\t*q++ = *p++;\n\t\t\t} else {\n\t\t\t\t*q++ = tolower(*p++);\n\t\t\t}\n\t\t}\n\t\t*q = '\\0';\n\t}\n}\n\nstatic int parse_msg_id(const char *text)\n{\n\tint i;\n\n\tprepare_msg_ids();\n\n\tfor (i = 0; i < FSCK_MSG_MAX; i++)\n\t\tif (!strcmp(text, msg_id_info[i].downcased))\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nvoid list_config_fsck_msg_ids(struct string_list *list, const char *prefix)\n{\n\tint i;\n\n\tprepare_msg_ids();\n\n\tfor (i = 0; i < FSCK_MSG_MAX; i++)\n\t\tlist_config_item(list, prefix, msg_id_info[i].camelcased);\n}\n\nstatic int fsck_msg_type(enum fsck_msg_id msg_id,\n\tstruct fsck_options *options)\n{\n\tint msg_type;\n\n\tassert(msg_id >= 0 && msg_id < FSCK_MSG_MAX);\n\n\tif (options->msg_type)\n\t\tmsg_type = options->msg_type[msg_id];\n\telse {\n\t\tmsg_type = msg_id_info[msg_id].msg_type;\n\t\tif (options->strict && msg_type == FSCK_WARN)\n\t\t\tmsg_type = FSCK_ERROR;\n\t}\n\n\treturn msg_type;\n}\n\nstatic int parse_msg_type(const char *str)\n{\n\tif (!strcmp(str, \"error\"))\n\t\treturn FSCK_ERROR;\n\telse if (!strcmp(str, \"warn\"))\n\t\treturn FSCK_WARN;\n\telse if (!strcmp(str, \"ignore\"))\n\t\treturn FSCK_IGNORE;\n\telse\n\t\tdie(\"Unknown fsck message type: '%s'\", str);\n}\n\nint is_valid_msg_type(const char *msg_id, const char *msg_type)\n{\n\tif (parse_msg_id(msg_id) < 0)\n\t\treturn 0;\n\tparse_msg_type(msg_type);\n\treturn 1;\n}\n\nvoid fsck_set_msg_type(struct fsck_options *options,\n\t\tconst char *msg_id, const char *msg_type)\n{\n\tint id = parse_msg_id(msg_id), type;\n\n\tif (id < 0)\n\t\tdie(\"Unhandled message id: %s\", msg_id);\n\ttype = parse_msg_type(msg_type);\n\n\tif (type != FSCK_ERROR && msg_id_info[id].msg_type == FSCK_FATAL)\n\t\tdie(\"Cannot demote %s to %s\", msg_id, msg_type);\n\n\tif (!options->msg_type) {\n\t\tint i;\n\t\tint *msg_type;\n\t\tALLOC_ARRAY(msg_type, FSCK_MSG_MAX);\n\t\tfor (i = 0; i < FSCK_MSG_MAX; i++)\n\t\t\tmsg_type[i] = fsck_msg_type(i, options);\n\t\toptions->msg_type = msg_type;\n\t}\n\n\toptions->msg_type[id] = type;\n}\n\nvoid fsck_set_msg_types(struct fsck_options *options, const char *values)\n{\n\tchar *buf = xstrdup(values), *to_free = buf;\n\tint done = 0;\n\n\twhile (!done) {\n\t\tint len = strcspn(buf, \" ,|\"), equal;\n\n\t\tdone = !buf[len];\n\t\tif (!len) {\n\t\t\tbuf++;\n\t\t\tcontinue;\n\t\t}\n\t\tbuf[len] = '\\0';\n\n\t\tfor (equal = 0;\n\t\t     equal < len && buf[equal] != '=' && buf[equal] != ':';\n\t\t     equal++)\n\t\t\tbuf[equal] = tolower(buf[equal]);\n\t\tbuf[equal] = '\\0';\n\n\t\tif (!strcmp(buf, \"skiplist\")) {\n\t\t\tif (equal == len)\n\t\t\t\tdie(\"skiplist requires a path\");\n\t\t\toidset_parse_file(&options->skiplist, buf + equal + 1);\n\t\t\tbuf += len + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (equal == len)\n\t\t\tdie(\"Missing '=': '%s'\", buf);\n\n\t\tfsck_set_msg_type(options, buf, buf + equal + 1);\n\t\tbuf += len + 1;\n\t}\n\tfree(to_free);\n}\n\nstatic void append_msg_id(struct strbuf *sb, const char *msg_id)\n{\n\tfor (;;) {\n\t\tchar c = *(msg_id)++;\n\n\t\tif (!c)\n\t\t\tbreak;\n\t\tif (c != '_')\n\t\t\tstrbuf_addch(sb, tolower(c));\n\t\telse {\n\t\t\tassert(*msg_id);\n\t\t\tstrbuf_addch(sb, *(msg_id)++);\n\t\t}\n\t}\n\n\tstrbuf_addstr(sb, \": \");\n}\n\nstatic int object_on_skiplist(struct fsck_options *opts, struct object *obj)\n{\n\treturn opts && obj && oidset_contains(&opts->skiplist, &obj->oid);\n}\n\n__attribute__((format (printf, 4, 5)))\nstatic int report(struct fsck_options *options, struct object *object,\n\tenum fsck_msg_id id, const char *fmt, ...)\n{\n\tva_list ap;\n\tstruct strbuf sb = STRBUF_INIT;\n\tint msg_type = fsck_msg_type(id, options), result;\n\n\tif (msg_type == FSCK_IGNORE)\n\t\treturn 0;\n\n\tif (object_on_skiplist(options, object))\n\t\treturn 0;\n\n\tif (msg_type == FSCK_FATAL)\n\t\tmsg_type = FSCK_ERROR;\n\telse if (msg_type == FSCK_INFO)\n\t\tmsg_type = FSCK_WARN;\n\n\tappend_msg_id(&sb, msg_id_info[id].id_string);\n\n\tva_start(ap, fmt);\n\tstrbuf_vaddf(&sb, fmt, ap);\n\tresult = options->error_func(options, object, msg_type, sb.buf);\n\tstrbuf_release(&sb);\n\tva_end(ap);\n\n\treturn result;\n}\n\nstatic char *get_object_name(struct fsck_options *options, struct object *obj)\n{\n\tif (!options->object_names)\n\t\treturn NULL;\n\treturn lookup_decoration(options->object_names, obj);\n}\n\nstatic void put_object_name(struct fsck_options *options, struct object *obj,\n\tconst char *fmt, ...)\n{\n\tva_list ap;\n\tstruct strbuf buf = STRBUF_INIT;\n\tchar *existing;\n\n\tif (!options->object_names)\n\t\treturn;\n\texisting = lookup_decoration(options->object_names, obj);\n\tif (existing)\n\t\treturn;\n\tva_start(ap, fmt);\n\tstrbuf_vaddf(&buf, fmt, ap);\n\tadd_decoration(options->object_names, obj, strbuf_detach(&buf, NULL));\n\tva_end(ap);\n}\n\nstatic const char *describe_object(struct fsck_options *o, struct object *obj)\n{\n\tstatic struct strbuf buf = STRBUF_INIT;\n\tchar *name;\n\n\tstrbuf_reset(&buf);\n\tstrbuf_addstr(&buf, oid_to_hex(&obj->oid));\n\tif (o->object_names && (name = lookup_decoration(o->object_names, obj)))\n\t\tstrbuf_addf(&buf, \" (%s)\", name);\n\n\treturn buf.buf;\n}\n\nstatic int fsck_walk_tree(struct tree *tree, void *data, struct fsck_options *options)\n{\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tint res = 0;\n\tconst char *name;\n\n\tif (parse_tree(tree))\n\t\treturn -1;\n\n\tname = get_object_name(options, &tree->object);\n\tif (init_tree_desc_gently(&desc, tree->buffer, tree->size))\n\t\treturn -1;\n\twhile (tree_entry_gently(&desc, &entry)) {\n\t\tstruct object *obj;\n\t\tint result;\n\n\t\tif (S_ISGITLINK(entry.mode))\n\t\t\tcontinue;\n\n\t\tif (S_ISDIR(entry.mode)) {\n\t\t\tobj = (struct object *)lookup_tree(the_repository, &entry.oid);\n\t\t\tif (name && obj)\n\t\t\t\tput_object_name(options, obj, \"%s%s/\", name,\n\t\t\t\t\tentry.path);\n\t\t\tresult = options->walk(obj, OBJ_TREE, data, options);\n\t\t}\n\t\telse if (S_ISREG(entry.mode) || S_ISLNK(entry.mode)) {\n\t\t\tobj = (struct object *)lookup_blob(the_repository, &entry.oid);\n\t\t\tif (name && obj)\n\t\t\t\tput_object_name(options, obj, \"%s%s\", name,\n\t\t\t\t\tentry.path);\n\t\t\tresult = options->walk(obj, OBJ_BLOB, data, options);\n\t\t}\n\t\telse {\n\t\t\tresult = error(\"in tree %s: entry %s has bad mode %.6o\",\n\t\t\t\t\tdescribe_object(options, &tree->object), entry.path, entry.mode);\n\t\t}\n\t\tif (result < 0)\n\t\t\treturn result;\n\t\tif (!res)\n\t\t\tres = result;\n\t}\n\treturn res;\n}\n\nstatic int fsck_walk_commit(struct commit *commit, void *data, struct fsck_options *options)\n{\n\tint counter = 0, generation = 0, name_prefix_len = 0;\n\tstruct commit_list *parents;\n\tint res;\n\tint result;\n\tconst char *name;\n\n\tif (parse_commit(commit))\n\t\treturn -1;\n\n\tname = get_object_name(options, &commit->object);\n\tif (name)\n\t\tput_object_name(options, &get_commit_tree(commit)->object,\n\t\t\t\t\"%s:\", name);\n\n\tresult = options->walk((struct object *)get_commit_tree(commit),\n\t\t\t       OBJ_TREE, data, options);\n\tif (result < 0)\n\t\treturn result;\n\tres = result;\n\n\tparents = commit->parents;\n\tif (name && parents) {\n\t\tint len = strlen(name), power;\n\n\t\tif (len && name[len - 1] == '^') {\n\t\t\tgeneration = 1;\n\t\t\tname_prefix_len = len - 1;\n\t\t}\n\t\telse { /* parse ~<generation> suffix */\n\t\t\tfor (generation = 0, power = 1;\n\t\t\t     len && isdigit(name[len - 1]);\n\t\t\t     power *= 10)\n\t\t\t\tgeneration += power * (name[--len] - '0');\n\t\t\tif (power > 1 && len && name[len - 1] == '~')\n\t\t\t\tname_prefix_len = len - 1;\n\t\t}\n\t}\n\n\twhile (parents) {\n\t\tif (name) {\n\t\t\tstruct object *obj = &parents->item->object;\n\n\t\t\tif (counter++)\n\t\t\t\tput_object_name(options, obj, \"%s^%d\",\n\t\t\t\t\tname, counter);\n\t\t\telse if (generation > 0)\n\t\t\t\tput_object_name(options, obj, \"%.*s~%d\",\n\t\t\t\t\tname_prefix_len, name, generation + 1);\n\t\t\telse\n\t\t\t\tput_object_name(options, obj, \"%s^\", name);\n\t\t}\n\t\tresult = options->walk((struct object *)parents->item, OBJ_COMMIT, data, options);\n\t\tif (result < 0)\n\t\t\treturn result;\n\t\tif (!res)\n\t\t\tres = result;\n\t\tparents = parents->next;\n\t}\n\treturn res;\n}\n\nstatic int fsck_walk_tag(struct tag *tag, void *data, struct fsck_options *options)\n{\n\tchar *name = get_object_name(options, &tag->object);\n\n\tif (parse_tag(tag))\n\t\treturn -1;\n\tif (name)\n\t\tput_object_name(options, tag->tagged, \"%s\", name);\n\treturn options->walk(tag->tagged, OBJ_ANY, data, options);\n}\n\nint fsck_walk(struct object *obj, void *data, struct fsck_options *options)\n{\n\tif (!obj)\n\t\treturn -1;\n\n\tif (obj->type == OBJ_NONE)\n\t\tparse_object(the_repository, &obj->oid);\n\n\tswitch (obj->type) {\n\tcase OBJ_BLOB:\n\t\treturn 0;\n\tcase OBJ_TREE:\n\t\treturn fsck_walk_tree((struct tree *)obj, data, options);\n\tcase OBJ_COMMIT:\n\t\treturn fsck_walk_commit((struct commit *)obj, data, options);\n\tcase OBJ_TAG:\n\t\treturn fsck_walk_tag((struct tag *)obj, data, options);\n\tdefault:\n\t\terror(\"Unknown object type for %s\", describe_object(options, obj));\n\t\treturn -1;\n\t}\n}\n\n/*\n * The entries in a tree are ordered in the _path_ order,\n * which means that a directory entry is ordered by adding\n * a slash to the end of it.\n *\n * So a directory called \"a\" is ordered _after_ a file\n * called \"a.c\", because \"a/\" sorts after \"a.c\".\n */\n#define TREE_UNORDERED (-1)\n#define TREE_HAS_DUPS  (-2)\n\nstatic int verify_ordered(unsigned mode1, const char *name1, unsigned mode2, const char *name2)\n{\n\tint len1 = strlen(name1);\n\tint len2 = strlen(name2);\n\tint len = len1 < len2 ? len1 : len2;\n\tunsigned char c1, c2;\n\tint cmp;\n\n\tcmp = memcmp(name1, name2, len);\n\tif (cmp < 0)\n\t\treturn 0;\n\tif (cmp > 0)\n\t\treturn TREE_UNORDERED;\n\n\t/*\n\t * Ok, the first <len> characters are the same.\n\t * Now we need to order the next one, but turn\n\t * a '\\0' into a '/' for a directory entry.\n\t */\n\tc1 = name1[len];\n\tc2 = name2[len];\n\tif (!c1 && !c2)\n\t\t/*\n\t\t * git-write-tree used to write out a nonsense tree that has\n\t\t * entries with the same name, one blob and one tree.  Make\n\t\t * sure we do not have duplicate entries.\n\t\t */\n\t\treturn TREE_HAS_DUPS;\n\tif (!c1 && S_ISDIR(mode1))\n\t\tc1 = '/';\n\tif (!c2 && S_ISDIR(mode2))\n\t\tc2 = '/';\n\treturn c1 < c2 ? 0 : TREE_UNORDERED;\n}\n\nstatic int fsck_tree(struct tree *item, struct fsck_options *options)\n{\n\tint retval = 0;\n\tint has_null_sha1 = 0;\n\tint has_full_path = 0;\n\tint has_empty_name = 0;\n\tint has_dot = 0;\n\tint has_dotdot = 0;\n\tint has_dotgit = 0;\n\tint has_zero_pad = 0;\n\tint has_bad_modes = 0;\n\tint has_dup_entries = 0;\n\tint not_properly_sorted = 0;\n\tstruct tree_desc desc;\n\tunsigned o_mode;\n\tconst char *o_name;\n\n\tif (init_tree_desc_gently(&desc, item->buffer, item->size)) {\n\t\tretval += report(options, &item->object, FSCK_MSG_BAD_TREE, \"cannot be parsed as a tree\");\n\t\treturn retval;\n\t}\n\n\to_mode = 0;\n\to_name = NULL;\n\n\twhile (desc.size) {\n\t\tunsigned short mode;\n\t\tconst char *name, *backslash;\n\t\tconst struct object_id *oid;\n\n\t\toid = tree_entry_extract(&desc, &name, &mode);\n\n\t\thas_null_sha1 |= is_null_oid(oid);\n\t\thas_full_path |= !!strchr(name, '/');\n\t\thas_empty_name |= !*name;\n\t\thas_dot |= !strcmp(name, \".\");\n\t\thas_dotdot |= !strcmp(name, \"..\");\n\t\thas_dotgit |= is_hfs_dotgit(name) || is_ntfs_dotgit(name);\n\t\thas_zero_pad |= *(char *)desc.buffer == '0';\n\n\t\tif (is_hfs_dotgitmodules(name) || is_ntfs_dotgitmodules(name)) {\n\t\t\tif (!S_ISLNK(mode))\n\t\t\t\toidset_insert(&gitmodules_found, oid);\n\t\t\telse\n\t\t\t\tretval += report(options, &item->object,\n\t\t\t\t\t\t FSCK_MSG_GITMODULES_SYMLINK,\n\t\t\t\t\t\t \".gitmodules is a symbolic link\");\n\t\t}\n\n\t\tif ((backslash = strchr(name, '\\\\'))) {\n\t\t\twhile (backslash) {\n\t\t\t\tbackslash++;\n\t\t\t\thas_dotgit |= is_ntfs_dotgit(backslash);\n\t\t\t\tif (is_ntfs_dotgitmodules(backslash)) {\n\t\t\t\t\tif (!S_ISLNK(mode))\n\t\t\t\t\t\toidset_insert(&gitmodules_found, oid);\n\t\t\t\t\telse\n\t\t\t\t\t\tretval += report(options, &item->object,\n\t\t\t\t\t\t\t\t FSCK_MSG_GITMODULES_SYMLINK,\n\t\t\t\t\t\t\t\t \".gitmodules is a symbolic link\");\n\t\t\t\t}\n\t\t\t\tbackslash = strchr(backslash, '\\\\');\n\t\t\t}\n\t\t}\n\n\t\tif (update_tree_entry_gently(&desc)) {\n\t\t\tretval += report(options, &item->object, FSCK_MSG_BAD_TREE, \"cannot be parsed as a tree\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (mode) {\n\t\t/*\n\t\t * Standard modes..\n\t\t */\n\t\tcase S_IFREG | 0755:\n\t\tcase S_IFREG | 0644:\n\t\tcase S_IFLNK:\n\t\tcase S_IFDIR:\n\t\tcase S_IFGITLINK:\n\t\t\tbreak;\n\t\t/*\n\t\t * This is nonstandard, but we had a few of these\n\t\t * early on when we honored the full set of mode\n\t\t * bits..\n\t\t */\n\t\tcase S_IFREG | 0664:\n\t\t\tif (!options->strict)\n\t\t\t\tbreak;\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\thas_bad_modes = 1;\n\t\t}\n\n\t\tif (o_name) {\n\t\t\tswitch (verify_ordered(o_mode, o_name, mode, name)) {\n\t\t\tcase TREE_UNORDERED:\n\t\t\t\tnot_properly_sorted = 1;\n\t\t\t\tbreak;\n\t\t\tcase TREE_HAS_DUPS:\n\t\t\t\thas_dup_entries = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\to_mode = mode;\n\t\to_name = name;\n\t}\n\n\tif (has_null_sha1)\n\t\tretval += report(options, &item->object, FSCK_MSG_NULL_SHA1, \"contains entries pointing to null sha1\");\n\tif (has_full_path)\n\t\tretval += report(options, &item->object, FSCK_MSG_FULL_PATHNAME, \"contains full pathnames\");\n\tif (has_empty_name)\n\t\tretval += report(options, &item->object, FSCK_MSG_EMPTY_NAME, \"contains empty pathname\");\n\tif (has_dot)\n\t\tretval += report(options, &item->object, FSCK_MSG_HAS_DOT, \"contains '.'\");\n\tif (has_dotdot)\n\t\tretval += report(options, &item->object, FSCK_MSG_HAS_DOTDOT, \"contains '..'\");\n\tif (has_dotgit)\n\t\tretval += report(options, &item->object, FSCK_MSG_HAS_DOTGIT, \"contains '.git'\");\n\tif (has_zero_pad)\n\t\tretval += report(options, &item->object, FSCK_MSG_ZERO_PADDED_FILEMODE, \"contains zero-padded file modes\");\n\tif (has_bad_modes)\n\t\tretval += report(options, &item->object, FSCK_MSG_BAD_FILEMODE, \"contains bad file modes\");\n\tif (has_dup_entries)\n\t\tretval += report(options, &item->object, FSCK_MSG_DUPLICATE_ENTRIES, \"contains duplicate file entries\");\n\tif (not_properly_sorted)\n\t\tretval += report(options, &item->object, FSCK_MSG_TREE_NOT_SORTED, \"not properly sorted\");\n\treturn retval;\n}\n\nstatic int verify_headers(const void *data, unsigned long size,\n\t\t\t  struct object *obj, struct fsck_options *options)\n{\n\tconst char *buffer = (const char *)data;\n\tunsigned long i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tswitch (buffer[i]) {\n\t\tcase '\\0':\n\t\t\treturn report(options, obj,\n\t\t\t\tFSCK_MSG_NUL_IN_HEADER,\n\t\t\t\t\"unterminated header: NUL at offset %ld\", i);\n\t\tcase '\\n':\n\t\t\tif (i + 1 < size && buffer[i + 1] == '\\n')\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * We did not find double-LF that separates the header\n\t * and the body.  Not having a body is not a crime but\n\t * we do want to see the terminating LF for the last header\n\t * line.\n\t */\n\tif (size && buffer[size - 1] == '\\n')\n\t\treturn 0;\n\n\treturn report(options, obj,\n\t\tFSCK_MSG_UNTERMINATED_HEADER, \"unterminated header\");\n}\n\nstatic int fsck_ident(const char **ident, struct object *obj, struct fsck_options *options)\n{\n\tconst char *p = *ident;\n\tchar *end;\n\n\t*ident = strchrnul(*ident, '\\n');\n\tif (**ident == '\\n')\n\t\t(*ident)++;\n\n\tif (*p == '<')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_NAME_BEFORE_EMAIL, \"invalid author/committer line - missing space before email\");\n\tp += strcspn(p, \"<>\\n\");\n\tif (*p == '>')\n\t\treturn report(options, obj, FSCK_MSG_BAD_NAME, \"invalid author/committer line - bad name\");\n\tif (*p != '<')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_EMAIL, \"invalid author/committer line - missing email\");\n\tif (p[-1] != ' ')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_SPACE_BEFORE_EMAIL, \"invalid author/committer line - missing space before email\");\n\tp++;\n\tp += strcspn(p, \"<>\\n\");\n\tif (*p != '>')\n\t\treturn report(options, obj, FSCK_MSG_BAD_EMAIL, \"invalid author/committer line - bad email\");\n\tp++;\n\tif (*p != ' ')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_SPACE_BEFORE_DATE, \"invalid author/committer line - missing space before date\");\n\tp++;\n\tif (*p == '0' && p[1] != ' ')\n\t\treturn report(options, obj, FSCK_MSG_ZERO_PADDED_DATE, \"invalid author/committer line - zero-padded date\");\n\tif (date_overflows(parse_timestamp(p, &end, 10)))\n\t\treturn report(options, obj, FSCK_MSG_BAD_DATE_OVERFLOW, \"invalid author/committer line - date causes integer overflow\");\n\tif ((end == p || *end != ' '))\n\t\treturn report(options, obj, FSCK_MSG_BAD_DATE, \"invalid author/committer line - bad date\");\n\tp = end + 1;\n\tif ((*p != '+' && *p != '-') ||\n\t    !isdigit(p[1]) ||\n\t    !isdigit(p[2]) ||\n\t    !isdigit(p[3]) ||\n\t    !isdigit(p[4]) ||\n\t    (p[5] != '\\n'))\n\t\treturn report(options, obj, FSCK_MSG_BAD_TIMEZONE, \"invalid author/committer line - bad time zone\");\n\tp += 6;\n\treturn 0;\n}\n\nstatic int fsck_commit_buffer(struct commit *commit, const char *buffer,\n\tunsigned long size, struct fsck_options *options)\n{\n\tstruct object_id tree_oid, oid;\n\tstruct commit_graft *graft;\n\tunsigned parent_count, parent_line_count = 0, author_count;\n\tint err;\n\tconst char *buffer_begin = buffer;\n\tconst char *p;\n\n\tif (verify_headers(buffer, size, &commit->object, options))\n\t\treturn -1;\n\n\tif (!skip_prefix(buffer, \"tree \", &buffer))\n\t\treturn report(options, &commit->object, FSCK_MSG_MISSING_TREE, \"invalid format - expected 'tree' line\");\n\tif (parse_oid_hex(buffer, &tree_oid, &p) || *p != '\\n') {\n\t\terr = report(options, &commit->object, FSCK_MSG_BAD_TREE_SHA1, \"invalid 'tree' line format - bad sha1\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tbuffer = p + 1;\n\twhile (skip_prefix(buffer, \"parent \", &buffer)) {\n\t\tif (parse_oid_hex(buffer, &oid, &p) || *p != '\\n') {\n\t\t\terr = report(options, &commit->object, FSCK_MSG_BAD_PARENT_SHA1, \"invalid 'parent' line format - bad sha1\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbuffer = p + 1;\n\t\tparent_line_count++;\n\t}\n\tgraft = lookup_commit_graft(the_repository, &commit->object.oid);\n\tparent_count = commit_list_count(commit->parents);\n\tif (graft) {\n\t\tif (graft->nr_parent == -1 && !parent_count)\n\t\t\t; /* shallow commit */\n\t\telse if (graft->nr_parent != parent_count) {\n\t\t\terr = report(options, &commit->object, FSCK_MSG_MISSING_GRAFT, \"graft objects missing\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tif (parent_count != parent_line_count) {\n\t\t\terr = report(options, &commit->object, FSCK_MSG_MISSING_PARENT, \"parent objects missing\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tauthor_count = 0;\n\twhile (skip_prefix(buffer, \"author \", &buffer)) {\n\t\tauthor_count++;\n\t\terr = fsck_ident(&buffer, &commit->object, options);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (author_count < 1)\n\t\terr = report(options, &commit->object, FSCK_MSG_MISSING_AUTHOR, \"invalid format - expected 'author' line\");\n\telse if (author_count > 1)\n\t\terr = report(options, &commit->object, FSCK_MSG_MULTIPLE_AUTHORS, \"invalid format - multiple 'author' lines\");\n\tif (err)\n\t\treturn err;\n\tif (!skip_prefix(buffer, \"committer \", &buffer))\n\t\treturn report(options, &commit->object, FSCK_MSG_MISSING_COMMITTER, \"invalid format - expected 'committer' line\");\n\terr = fsck_ident(&buffer, &commit->object, options);\n\tif (err)\n\t\treturn err;\n\tif (!get_commit_tree(commit)) {\n\t\terr = report(options, &commit->object, FSCK_MSG_BAD_TREE, \"could not load commit's tree %s\", oid_to_hex(&tree_oid));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (memchr(buffer_begin, '\\0', size)) {\n\t\terr = report(options, &commit->object, FSCK_MSG_NUL_IN_COMMIT,\n\t\t\t     \"NUL byte in the commit object body\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int fsck_commit(struct commit *commit, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tconst char *buffer = data ?  data : get_commit_buffer(commit, &size);\n\tint ret = fsck_commit_buffer(commit, buffer, size, options);\n\tif (!data)\n\t\tunuse_commit_buffer(commit, buffer);\n\treturn ret;\n}\n\nstatic int fsck_tag_buffer(struct tag *tag, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tstruct object_id oid;\n\tint ret = 0;\n\tconst char *buffer;\n\tchar *to_free = NULL, *eol;\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *p;\n\n\tif (data)\n\t\tbuffer = data;\n\telse {\n\t\tenum object_type type;\n\n\t\tbuffer = to_free =\n\t\t\tread_object_file(&tag->object.oid, &type, &size);\n\t\tif (!buffer)\n\t\t\treturn report(options, &tag->object,\n\t\t\t\tFSCK_MSG_MISSING_TAG_OBJECT,\n\t\t\t\t\"cannot read tag object\");\n\n\t\tif (type != OBJ_TAG) {\n\t\t\tret = report(options, &tag->object,\n\t\t\t\tFSCK_MSG_TAG_OBJECT_NOT_TAG,\n\t\t\t\t\"expected tag got %s\",\n\t\t\t    type_name(type));\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = verify_headers(buffer, size, &tag->object, options);\n\tif (ret)\n\t\tgoto done;\n\n\tif (!skip_prefix(buffer, \"object \", &buffer)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_OBJECT, \"invalid format - expected 'object' line\");\n\t\tgoto done;\n\t}\n\tif (parse_oid_hex(buffer, &oid, &p) || *p != '\\n') {\n\t\tret = report(options, &tag->object, FSCK_MSG_BAD_OBJECT_SHA1, \"invalid 'object' line format - bad sha1\");\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\tbuffer = p + 1;\n\n\tif (!skip_prefix(buffer, \"type \", &buffer)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TYPE_ENTRY, \"invalid format - expected 'type' line\");\n\t\tgoto done;\n\t}\n\teol = strchr(buffer, '\\n');\n\tif (!eol) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TYPE, \"invalid format - unexpected end after 'type' line\");\n\t\tgoto done;\n\t}\n\tif (type_from_string_gently(buffer, eol - buffer, 1) < 0)\n\t\tret = report(options, &tag->object, FSCK_MSG_BAD_TYPE, \"invalid 'type' value\");\n\tif (ret)\n\t\tgoto done;\n\tbuffer = eol + 1;\n\n\tif (!skip_prefix(buffer, \"tag \", &buffer)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TAG_ENTRY, \"invalid format - expected 'tag' line\");\n\t\tgoto done;\n\t}\n\teol = strchr(buffer, '\\n');\n\tif (!eol) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TAG, \"invalid format - unexpected end after 'type' line\");\n\t\tgoto done;\n\t}\n\tstrbuf_addf(&sb, \"refs/tags/%.*s\", (int)(eol - buffer), buffer);\n\tif (check_refname_format(sb.buf, 0)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_BAD_TAG_NAME,\n\t\t\t   \"invalid 'tag' name: %.*s\",\n\t\t\t   (int)(eol - buffer), buffer);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\tbuffer = eol + 1;\n\n\tif (!skip_prefix(buffer, \"tagger \", &buffer)) {\n\t\t/* early tags do not contain 'tagger' lines; warn only */\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TAGGER_ENTRY, \"invalid format - expected 'tagger' line\");\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\telse\n\t\tret = fsck_ident(&buffer, &tag->object, options);\n\ndone:\n\tstrbuf_release(&sb);\n\tfree(to_free);\n\treturn ret;\n}\n\nstatic int fsck_tag(struct tag *tag, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tstruct object *tagged = tag->tagged;\n\n\tif (!tagged)\n\t\treturn report(options, &tag->object, FSCK_MSG_BAD_TAG_OBJECT, \"could not load tagged object\");\n\n\treturn fsck_tag_buffer(tag, data, size, options);\n}\n\n/*\n * Like builtin/submodule--helper.c's starts_with_dot_slash, but without\n * relying on the platform-dependent is_dir_sep helper.\n *\n * This is for use in checking whether a submodule URL is interpreted as\n * relative to the current directory on any platform, since \\ is a\n * directory separator on Windows but not on other platforms.\n */\nstatic int starts_with_dot_slash(const char *str)\n{\n\treturn str[0] == '.' && (str[1] == '/' || str[1] == '\\\\');\n}\n\n/*\n * Like starts_with_dot_slash, this is a variant of submodule--helper's\n * helper of the same name with the twist that it accepts backslash as a\n * directory separator even on non-Windows platforms.\n */\nstatic int starts_with_dot_dot_slash(const char *str)\n{\n\treturn str[0] == '.' && starts_with_dot_slash(str + 1);\n}\n\nstatic int submodule_url_is_relative(const char *url)\n{\n\treturn starts_with_dot_slash(url) || starts_with_dot_dot_slash(url);\n}\n\n/*\n * Count directory components that a relative submodule URL should chop\n * from the remote_url it is to be resolved against.\n *\n * In other words, this counts \"../\" components at the start of a\n * submodule URL.\n *\n * Returns the number of directory components to chop and writes a\n * pointer to the next character of url after all leading \"./\" and\n * \"../\" components to out.\n */\nstatic int count_leading_dotdots(const char *url, const char **out)\n{\n\tint result = 0;\n\twhile (1) {\n\t\tif (starts_with_dot_dot_slash(url)) {\n\t\t\tresult++;\n\t\t\turl += strlen(\"../\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (starts_with_dot_slash(url)) {\n\t\t\turl += strlen(\"./\");\n\t\t\tcontinue;\n\t\t}\n\t\t*out = url;\n\t\treturn result;\n\t}\n}\n/*\n * Check whether a transport is implemented by git-remote-curl.\n *\n * If it is, returns 1 and writes the URL that would be passed to\n * git-remote-curl to the \"out\" parameter.\n *\n * Otherwise, returns 0 and leaves \"out\" untouched.\n *\n * Examples:\n *   http::https://example.com/repo.git -> 1, https://example.com/repo.git\n *   https://example.com/repo.git -> 1, https://example.com/repo.git\n *   git://example.com/repo.git -> 0\n *\n * This is for use in checking for previously exploitable bugs that\n * required a submodule URL to be passed to git-remote-curl.\n */\nstatic int url_to_curl_url(const char *url, const char **out)\n{\n\t/*\n\t * We don't need to check for case-aliases, \"http.exe\", and so\n\t * on because in the default configuration, is_transport_allowed\n\t * prevents URLs with those schemes from being cloned\n\t * automatically.\n\t */\n\tif (skip_prefix(url, \"http::\", out) ||\n\t    skip_prefix(url, \"https::\", out) ||\n\t    skip_prefix(url, \"ftp::\", out) ||\n\t    skip_prefix(url, \"ftps::\", out))\n\t\treturn 1;\n\tif (starts_with(url, \"http://\") ||\n\t    starts_with(url, \"https://\") ||\n\t    starts_with(url, \"ftp://\") ||\n\t    starts_with(url, \"ftps://\")) {\n\t\t*out = url;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded;\n\t\tconst char *next;\n\t\tint has_nl;\n\n\t\t/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t */\n\t\tdecoded = url_decode(url);\n\t\thas_nl = !!strchr(decoded, '\\n');\n\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * URLs which escape their root via \"../\" can overwrite\n\t\t * the host field and previous components, resolving to\n\t\t * URLs like https::example.com/submodule.git and\n\t\t * https:///example.com/submodule.git that were\n\t\t * susceptible to CVE-2020-11008.\n\t\t */\n\t\tif (count_leading_dotdots(url, &next) > 0 &&\n\t\t    (*next == ':' || *next == '/'))\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = 0;\n\t\tif (credential_from_url_gently(&c, curl_url, 1) ||\n\t\t    !*c.host)\n\t\t\tret = -1;\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstruct fsck_gitmodules_data {\n\tstruct object *obj;\n\tstruct fsck_options *options;\n\tint ret;\n};\n\nstatic int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    check_submodule_url(value) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \"disallowed submodule url: %s\",\n\t\t\t\t    value);\n\tif (!strcmp(key, \"path\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_PATH,\n\t\t\t\t    \"disallowed submodule path: %s\",\n\t\t\t\t    value);\n\tif (!strcmp(key, \"update\") && value &&\n\t    parse_submodule_update_type(value) == SM_UPDATE_COMMAND)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_UPDATE,\n\t\t\t\t    \"disallowed submodule update setting: %s\",\n\t\t\t\t    value);\n\tfree(name);\n\n\treturn 0;\n}\n\nstatic int fsck_blob(struct blob *blob, const char *buf,\n\t\t     unsigned long size, struct fsck_options *options)\n{\n\tstruct fsck_gitmodules_data data;\n\tstruct config_options config_opts = { 0 };\n\n\tif (!oidset_contains(&gitmodules_found, &blob->object.oid))\n\t\treturn 0;\n\toidset_insert(&gitmodules_done, &blob->object.oid);\n\n\tif (object_on_skiplist(options, &blob->object))\n\t\treturn 0;\n\n\tif (!buf) {\n\t\t/*\n\t\t * A missing buffer here is a sign that the caller found the\n\t\t * blob too gigantic to load into memory. Let's just consider\n\t\t * that an error.\n\t\t */\n\t\treturn report(options, &blob->object,\n\t\t\t      FSCK_MSG_GITMODULES_LARGE,\n\t\t\t      \".gitmodules too large to parse\");\n\t}\n\n\tdata.obj = &blob->object;\n\tdata.options = options;\n\tdata.ret = 0;\n\tconfig_opts.error_action = CONFIG_ERROR_SILENT;\n\tif (git_config_from_mem(fsck_gitmodules_fn, CONFIG_ORIGIN_BLOB,\n\t\t\t\t\".gitmodules\", buf, size, &data, &config_opts))\n\t\tdata.ret |= report(options, &blob->object,\n\t\t\t\t   FSCK_MSG_GITMODULES_PARSE,\n\t\t\t\t   \"could not parse gitmodules blob\");\n\n\treturn data.ret;\n}\n\nint fsck_object(struct object *obj, void *data, unsigned long size,\n\tstruct fsck_options *options)\n{\n\tif (!obj)\n\t\treturn report(options, obj, FSCK_MSG_BAD_OBJECT_SHA1, \"no valid object to fsck\");\n\n\tif (obj->type == OBJ_BLOB)\n\t\treturn fsck_blob((struct blob *)obj, data, size, options);\n\tif (obj->type == OBJ_TREE)\n\t\treturn fsck_tree((struct tree *) obj, options);\n\tif (obj->type == OBJ_COMMIT)\n\t\treturn fsck_commit((struct commit *) obj, (const char *) data,\n\t\t\tsize, options);\n\tif (obj->type == OBJ_TAG)\n\t\treturn fsck_tag((struct tag *) obj, (const char *) data,\n\t\t\tsize, options);\n\n\treturn report(options, obj, FSCK_MSG_UNKNOWN_TYPE, \"unknown type '%d' (internal fsck error)\",\n\t\t\t  obj->type);\n}\n\nint fsck_error_function(struct fsck_options *o,\n\tstruct object *obj, int msg_type, const char *message)\n{\n\tif (msg_type == FSCK_WARN) {\n\t\twarning(\"object %s: %s\", describe_object(o, obj), message);\n\t\treturn 0;\n\t}\n\terror(\"object %s: %s\", describe_object(o, obj), message);\n\treturn 1;\n}\n\nint fsck_finish(struct fsck_options *options)\n{\n\tint ret = 0;\n\tstruct oidset_iter iter;\n\tconst struct object_id *oid;\n\n\toidset_iter_init(&gitmodules_found, &iter);\n\twhile ((oid = oidset_iter_next(&iter))) {\n\t\tstruct blob *blob;\n\t\tenum object_type type;\n\t\tunsigned long size;\n\t\tchar *buf;\n\n\t\tif (oidset_contains(&gitmodules_done, oid))\n\t\t\tcontinue;\n\n\t\tblob = lookup_blob(the_repository, oid);\n\t\tif (!blob) {\n\t\t\tstruct object *obj = lookup_unknown_object(oid);\n\t\t\tret |= report(options, obj,\n\t\t\t\t      FSCK_MSG_GITMODULES_BLOB,\n\t\t\t\t      \"non-blob found at .gitmodules\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tbuf = read_object_file(oid, &type, &size);\n\t\tif (!buf) {\n\t\t\tif (is_promisor_object(&blob->object.oid))\n\t\t\t\tcontinue;\n\t\t\tret |= report(options, &blob->object,\n\t\t\t\t      FSCK_MSG_GITMODULES_MISSING,\n\t\t\t\t      \"unable to read .gitmodules blob\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type == OBJ_BLOB)\n\t\t\tret |= fsck_blob(blob, buf, size, options);\n\t\telse\n\t\t\tret |= report(options, &blob->object,\n\t\t\t\t      FSCK_MSG_GITMODULES_BLOB,\n\t\t\t\t      \"non-blob found at .gitmodules\");\n\t\tfree(buf);\n\t}\n\n\n\toidset_clear(&gitmodules_found);\n\toidset_clear(&gitmodules_done);\n\treturn ret;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00077b107d7e0a22950cfead776071940285da25",
  "sha1_ok": false,
  "size": 33465
}
