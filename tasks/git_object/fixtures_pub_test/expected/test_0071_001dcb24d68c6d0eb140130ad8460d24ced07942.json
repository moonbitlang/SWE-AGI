{
  "content": {
    "base64": "LyoKICogR0lUIC0gVGhlIGluZm9ybWF0aW9uIG1hbmFnZXIgZnJvbSBoZWxsCiAqCiAqIENvcHlyaWdodCAoQykgTGludXMgVG9ydmFsZHMsIDIwMDUKICovCiNkZWZpbmUgVVNFX1RIRV9JTkRFWF9WQVJJQUJMRQojaW5jbHVkZSAiY2FjaGUuaCIKI2luY2x1ZGUgImFsbG9jLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImNvbnZlcnQuaCIKI2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgImVudmlyb25tZW50LmgiCiNpbmNsdWRlICJnZXR0ZXh0LmgiCiNpbmNsdWRlICJoZXguaCIKI2luY2x1ZGUgImlkZW50LmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCiNpbmNsdWRlICJ1c2VyZGlmZi5oIgojaW5jbHVkZSAic3RyZWFtaW5nLmgiCiNpbmNsdWRlICJ0cmVlLXdhbGsuaCIKI2luY2x1ZGUgIm9pZC1hcnJheS5oIgojaW5jbHVkZSAicGFja2ZpbGUuaCIKI2luY2x1ZGUgIm9iamVjdC1maWxlLmgiCiNpbmNsdWRlICJvYmplY3QtbmFtZS5oIgojaW5jbHVkZSAib2JqZWN0LXN0b3JlLmgiCiNpbmNsdWRlICJyZXBsYWNlLW9iamVjdC5oIgojaW5jbHVkZSAicHJvbWlzb3ItcmVtb3RlLmgiCiNpbmNsdWRlICJtYWlsbWFwLmgiCiNpbmNsdWRlICJ3cml0ZS1vci1kaWUuaCIKCmVudW0gYmF0Y2hfbW9kZSB7CglCQVRDSF9NT0RFX0NPTlRFTlRTLAoJQkFUQ0hfTU9ERV9JTkZPLAoJQkFUQ0hfTU9ERV9RVUVVRV9BTkRfRElTUEFUQ0gsCn07CgpzdHJ1Y3QgYmF0Y2hfb3B0aW9ucyB7CglpbnQgZW5hYmxlZDsKCWludCBmb2xsb3dfc3ltbGlua3M7CgllbnVtIGJhdGNoX21vZGUgYmF0Y2hfbW9kZTsKCWludCBidWZmZXJfb3V0cHV0OwoJaW50IGFsbF9vYmplY3RzOwoJaW50IHVub3JkZXJlZDsKCWludCB0cmFuc2Zvcm1fbW9kZTsgLyogbWF5IGJlICd3JyBvciAnYycgZm9yIC0tZmlsdGVycyBvciAtLXRleHRjb252ICovCgljaGFyIGlucHV0X2RlbGltOwoJY29uc3QgY2hhciAqZm9ybWF0Owp9OwoKc3RhdGljIGNvbnN0IGNoYXIgKmZvcmNlX3BhdGg7CgpzdGF0aWMgc3RydWN0IHN0cmluZ19saXN0IG1haWxtYXAgPSBTVFJJTkdfTElTVF9JTklUX05PRFVQOwpzdGF0aWMgaW50IHVzZV9tYWlsbWFwOwoKc3RhdGljIGNoYXIgKnJlcGxhY2VfaWRlbnRzX3VzaW5nX21haWxtYXAoY2hhciAqLCBzaXplX3QgKik7CgpzdGF0aWMgY2hhciAqcmVwbGFjZV9pZGVudHNfdXNpbmdfbWFpbG1hcChjaGFyICpvYmplY3RfYnVmLCBzaXplX3QgKnNpemUpCnsKCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKmhlYWRlcnNbXSA9IHsgImF1dGhvciAiLCAiY29tbWl0dGVyICIsICJ0YWdnZXIgIiwgTlVMTCB9OwoKCXN0cmJ1Zl9hdHRhY2goJnNiLCBvYmplY3RfYnVmLCAqc2l6ZSwgKnNpemUgKyAxKTsKCWFwcGx5X21haWxtYXBfdG9faGVhZGVyKCZzYiwgaGVhZGVycywgJm1haWxtYXApOwoJKnNpemUgPSBzYi5sZW47CglyZXR1cm4gc3RyYnVmX2RldGFjaCgmc2IsIE5VTEwpOwp9CgpzdGF0aWMgaW50IGZpbHRlcl9vYmplY3QoY29uc3QgY2hhciAqcGF0aCwgdW5zaWduZWQgbW9kZSwKCQkJIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJIGNoYXIgKipidWYsIHVuc2lnbmVkIGxvbmcgKnNpemUpCnsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCgkqYnVmID0gcmVwb19yZWFkX29iamVjdF9maWxlKHRoZV9yZXBvc2l0b3J5LCBvaWQsICZ0eXBlLCBzaXplKTsKCWlmICghKmJ1ZikKCQlyZXR1cm4gZXJyb3IoXygiY2Fubm90IHJlYWQgb2JqZWN0ICVzICclcyciKSwKCQkJICAgICBvaWRfdG9faGV4KG9pZCksIHBhdGgpOwoJaWYgKCh0eXBlID09IE9CSl9CTE9CKSAmJiBTX0lTUkVHKG1vZGUpKSB7CgkJc3RydWN0IHN0cmJ1ZiBzdHJidWYgPSBTVFJCVUZfSU5JVDsKCQlzdHJ1Y3QgY2hlY2tvdXRfbWV0YWRhdGEgbWV0YTsKCgkJaW5pdF9jaGVja291dF9tZXRhZGF0YSgmbWV0YSwgTlVMTCwgTlVMTCwgb2lkKTsKCQlpZiAoY29udmVydF90b193b3JraW5nX3RyZWUoJnRoZV9pbmRleCwgcGF0aCwgKmJ1ZiwgKnNpemUsICZzdHJidWYsICZtZXRhKSkgewoJCQlmcmVlKCpidWYpOwoJCQkqc2l6ZSA9IHN0cmJ1Zi5sZW47CgkJCSpidWYgPSBzdHJidWZfZGV0YWNoKCZzdHJidWYsIE5VTEwpOwoJCX0KCX0KCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBzdHJlYW1fYmxvYihjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCWlmIChzdHJlYW1fYmxvYl90b19mZCgxLCBvaWQsIE5VTEwsIDApKQoJCWRpZSgidW5hYmxlIHRvIHN0cmVhbSAlcyB0byBzdGRvdXQiLCBvaWRfdG9faGV4KG9pZCkpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgY2F0X29uZV9maWxlKGludCBvcHQsIGNvbnN0IGNoYXIgKmV4cF90eXBlLCBjb25zdCBjaGFyICpvYmpfbmFtZSwKCQkJaW50IHVua25vd25fdHlwZSkKewoJaW50IHJldDsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJY2hhciAqYnVmOwoJdW5zaWduZWQgbG9uZyBzaXplOwoJc3RydWN0IG9iamVjdF9jb250ZXh0IG9ial9jb250ZXh0OwoJc3RydWN0IG9iamVjdF9pbmZvIG9pID0gT0JKRUNUX0lORk9fSU5JVDsKCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCXVuc2lnbmVkIGZsYWdzID0gT0JKRUNUX0lORk9fTE9PS1VQX1JFUExBQ0U7Cgl1bnNpZ25lZCBnZXRfb2lkX2ZsYWdzID0gR0VUX09JRF9SRUNPUkRfUEFUSCB8IEdFVF9PSURfT05MWV9UT19ESUU7Cgljb25zdCBjaGFyICpwYXRoID0gZm9yY2VfcGF0aDsKCWNvbnN0IGludCBvcHRfY3cgPSAob3B0ID09ICdjJyB8fCBvcHQgPT0gJ3cnKTsKCWlmICghcGF0aCAmJiBvcHRfY3cpCgkJZ2V0X29pZF9mbGFncyB8PSBHRVRfT0lEX1JFUVVJUkVfUEFUSDsKCglpZiAodW5rbm93bl90eXBlKQoJCWZsYWdzIHw9IE9CSkVDVF9JTkZPX0FMTE9XX1VOS05PV05fVFlQRTsKCglpZiAoZ2V0X29pZF93aXRoX2NvbnRleHQodGhlX3JlcG9zaXRvcnksIG9ial9uYW1lLCBnZXRfb2lkX2ZsYWdzLCAmb2lkLAoJCQkJICZvYmpfY29udGV4dCkpCgkJZGllKCJOb3QgYSB2YWxpZCBvYmplY3QgbmFtZSAlcyIsIG9ial9uYW1lKTsKCglpZiAoIXBhdGgpCgkJcGF0aCA9IG9ial9jb250ZXh0LnBhdGg7CglpZiAob2JqX2NvbnRleHQubW9kZSA9PSBTX0lGSU5WQUxJRCkKCQlvYmpfY29udGV4dC5tb2RlID0gMDEwMDY0NDsKCglidWYgPSBOVUxMOwoJc3dpdGNoIChvcHQpIHsKCWNhc2UgJ3QnOgoJCW9pLnR5cGVfbmFtZSA9ICZzYjsKCQlpZiAob2lkX29iamVjdF9pbmZvX2V4dGVuZGVkKHRoZV9yZXBvc2l0b3J5LCAmb2lkLCAmb2ksIGZsYWdzKSA8IDApCgkJCWRpZSgiZ2l0IGNhdC1maWxlOiBjb3VsZCBub3QgZ2V0IG9iamVjdCBpbmZvIik7CgkJaWYgKHNiLmxlbikgewoJCQlwcmludGYoIiVzXG4iLCBzYi5idWYpOwoJCQlzdHJidWZfcmVsZWFzZSgmc2IpOwoJCQlyZXQgPSAwOwoJCQlnb3RvIGNsZWFudXA7CgkJfQoJCWJyZWFrOwoKCWNhc2UgJ3MnOgoJCW9pLnNpemVwID0gJnNpemU7CgoJCWlmICh1c2VfbWFpbG1hcCkgewoJCQlvaS50eXBlcCA9ICZ0eXBlOwoJCQlvaS5jb250ZW50cCA9ICh2b2lkKiopJmJ1ZjsKCQl9CgoJCWlmIChvaWRfb2JqZWN0X2luZm9fZXh0ZW5kZWQodGhlX3JlcG9zaXRvcnksICZvaWQsICZvaSwgZmxhZ3MpIDwgMCkKCQkJZGllKCJnaXQgY2F0LWZpbGU6IGNvdWxkIG5vdCBnZXQgb2JqZWN0IGluZm8iKTsKCgkJaWYgKHVzZV9tYWlsbWFwICYmICh0eXBlID09IE9CSl9DT01NSVQgfHwgdHlwZSA9PSBPQkpfVEFHKSkgewoJCQlzaXplX3QgcyA9IHNpemU7CgkJCWJ1ZiA9IHJlcGxhY2VfaWRlbnRzX3VzaW5nX21haWxtYXAoYnVmLCAmcyk7CgkJCXNpemUgPSBjYXN0X3NpemVfdF90b191bG9uZyhzKTsKCQl9CgoJCXByaW50ZigiJSJQUkl1TUFYIlxuIiwgKHVpbnRtYXhfdClzaXplKTsKCQlyZXQgPSAwOwoJCWdvdG8gY2xlYW51cDsKCgljYXNlICdlJzoKCQlyZXR1cm4gIXJlcG9faGFzX29iamVjdF9maWxlKHRoZV9yZXBvc2l0b3J5LCAmb2lkKTsKCgljYXNlICd3JzoKCgkJaWYgKGZpbHRlcl9vYmplY3QocGF0aCwgb2JqX2NvbnRleHQubW9kZSwKCQkJCSAgJm9pZCwgJmJ1ZiwgJnNpemUpKSB7CgkJCXJldCA9IC0xOwoJCQlnb3RvIGNsZWFudXA7CgkJfQoJCWJyZWFrOwoKCWNhc2UgJ2MnOgoJCWlmICh0ZXh0Y29udl9vYmplY3QodGhlX3JlcG9zaXRvcnksIHBhdGgsIG9ial9jb250ZXh0Lm1vZGUsCgkJCQkgICAgJm9pZCwgMSwgJmJ1ZiwgJnNpemUpKQoJCQlicmVhazsKCQkvKiBlbHNlIGZhbGx0aHJvdWdoICovCgoJY2FzZSAncCc6CgkJdHlwZSA9IG9pZF9vYmplY3RfaW5mbyh0aGVfcmVwb3NpdG9yeSwgJm9pZCwgTlVMTCk7CgkJaWYgKHR5cGUgPCAwKQoJCQlkaWUoIk5vdCBhIHZhbGlkIG9iamVjdCBuYW1lICVzIiwgb2JqX25hbWUpOwoKCQkvKiBjdXN0b20gcHJldHR5LXByaW50IGhlcmUgKi8KCQlpZiAodHlwZSA9PSBPQkpfVFJFRSkgewoJCQljb25zdCBjaGFyICpsc19hcmdzWzNdID0geyBOVUxMIH07CgkJCWxzX2FyZ3NbMF0gPSAgImxzLXRyZWUiOwoJCQlsc19hcmdzWzFdID0gIG9ial9uYW1lOwoJCQlyZXQgPSBjbWRfbHNfdHJlZSgyLCBsc19hcmdzLCBOVUxMKTsKCQkJZ290byBjbGVhbnVwOwoJCX0KCgkJaWYgKHR5cGUgPT0gT0JKX0JMT0IpIHsKCQkJcmV0ID0gc3RyZWFtX2Jsb2IoJm9pZCk7CgkJCWdvdG8gY2xlYW51cDsKCQl9CgkJYnVmID0gcmVwb19yZWFkX29iamVjdF9maWxlKHRoZV9yZXBvc2l0b3J5LCAmb2lkLCAmdHlwZSwKCQkJCQkgICAgJnNpemUpOwoJCWlmICghYnVmKQoJCQlkaWUoIkNhbm5vdCByZWFkIG9iamVjdCAlcyIsIG9ial9uYW1lKTsKCgkJaWYgKHVzZV9tYWlsbWFwKSB7CgkJCXNpemVfdCBzID0gc2l6ZTsKCQkJYnVmID0gcmVwbGFjZV9pZGVudHNfdXNpbmdfbWFpbG1hcChidWYsICZzKTsKCQkJc2l6ZSA9IGNhc3Rfc2l6ZV90X3RvX3Vsb25nKHMpOwoJCX0KCgkJLyogb3RoZXJ3aXNlIGp1c3Qgc3BpdCBvdXQgdGhlIGRhdGEgKi8KCQlicmVhazsKCgljYXNlIDA6Cgl7CgkJZW51bSBvYmplY3RfdHlwZSBleHBfdHlwZV9pZCA9IHR5cGVfZnJvbV9zdHJpbmcoZXhwX3R5cGUpOwoKCQlpZiAoZXhwX3R5cGVfaWQgPT0gT0JKX0JMT0IpIHsKCQkJc3RydWN0IG9iamVjdF9pZCBibG9iX29pZDsKCQkJaWYgKG9pZF9vYmplY3RfaW5mbyh0aGVfcmVwb3NpdG9yeSwgJm9pZCwgTlVMTCkgPT0gT0JKX1RBRykgewoJCQkJY2hhciAqYnVmZmVyID0gcmVwb19yZWFkX29iamVjdF9maWxlKHRoZV9yZXBvc2l0b3J5LAoJCQkJCQkJCSAgICAgJm9pZCwKCQkJCQkJCQkgICAgICZ0eXBlLAoJCQkJCQkJCSAgICAgJnNpemUpOwoJCQkJY29uc3QgY2hhciAqdGFyZ2V0OwoJCQkJaWYgKCFza2lwX3ByZWZpeChidWZmZXIsICJvYmplY3QgIiwgJnRhcmdldCkgfHwKCQkJCSAgICBnZXRfb2lkX2hleCh0YXJnZXQsICZibG9iX29pZCkpCgkJCQkJZGllKCIlcyBub3QgYSB2YWxpZCB0YWciLCBvaWRfdG9faGV4KCZvaWQpKTsKCQkJCWZyZWUoYnVmZmVyKTsKCQkJfSBlbHNlCgkJCQlvaWRjcHkoJmJsb2Jfb2lkLCAmb2lkKTsKCgkJCWlmIChvaWRfb2JqZWN0X2luZm8odGhlX3JlcG9zaXRvcnksICZibG9iX29pZCwgTlVMTCkgPT0gT0JKX0JMT0IpIHsKCQkJCXJldCA9IHN0cmVhbV9ibG9iKCZibG9iX29pZCk7CgkJCQlnb3RvIGNsZWFudXA7CgkJCX0KCQkJLyoKCQkJICogd2UgYXR0ZW1wdGVkIHRvIGRlcmVmZXJlbmNlIGEgdGFnIHRvIGEgYmxvYgoJCQkgKiBhbmQgZmFpbGVkOyB0aGVyZSBtYXkgYmUgbmV3IGRlcmVmZXJlbmNlCgkJCSAqIG1lY2hhbmlzbXMgdGhpcyBjb2RlIGlzIG5vdCBhd2FyZSBvZi4KCQkJICogZmFsbC1iYWNrIHRvIHRoZSB1c3VhbCBjYXNlLgoJCQkgKi8KCQl9CgkJYnVmID0gcmVhZF9vYmplY3Rfd2l0aF9yZWZlcmVuY2UodGhlX3JlcG9zaXRvcnksICZvaWQsCgkJCQkJCSBleHBfdHlwZV9pZCwgJnNpemUsIE5VTEwpOwoKCQlpZiAodXNlX21haWxtYXApIHsKCQkJc2l6ZV90IHMgPSBzaXplOwoJCQlidWYgPSByZXBsYWNlX2lkZW50c191c2luZ19tYWlsbWFwKGJ1ZiwgJnMpOwoJCQlzaXplID0gY2FzdF9zaXplX3RfdG9fdWxvbmcocyk7CgkJfQoJCWJyZWFrOwoJfQoJZGVmYXVsdDoKCQlkaWUoImdpdCBjYXQtZmlsZTogdW5rbm93biBvcHRpb246ICVzIiwgZXhwX3R5cGUpOwoJfQoKCWlmICghYnVmKQoJCWRpZSgiZ2l0IGNhdC1maWxlICVzOiBiYWQgZmlsZSIsIG9ial9uYW1lKTsKCgl3cml0ZV9vcl9kaWUoMSwgYnVmLCBzaXplKTsKCXJldCA9IDA7CmNsZWFudXA6CglmcmVlKGJ1Zik7CglmcmVlKG9ial9jb250ZXh0LnBhdGgpOwoJcmV0dXJuIHJldDsKfQoKc3RydWN0IGV4cGFuZF9kYXRhIHsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJdW5zaWduZWQgbG9uZyBzaXplOwoJb2ZmX3QgZGlza19zaXplOwoJY29uc3QgY2hhciAqcmVzdDsKCXN0cnVjdCBvYmplY3RfaWQgZGVsdGFfYmFzZV9vaWQ7CgoJLyoKCSAqIElmIG1hcmtfcXVlcnkgaXMgdHJ1ZSwgd2UgZG8gbm90IGV4cGFuZCBhbnl0aGluZywgYnV0IHJhdGhlcgoJICoganVzdCBtYXJrIHRoZSBvYmplY3RfaW5mbyB3aXRoIGl0ZW1zIHdlIHdpc2ggdG8gcXVlcnkuCgkgKi8KCWludCBtYXJrX3F1ZXJ5OwoKCS8qCgkgKiBXaGV0aGVyIHRvIHNwbGl0IHRoZSBpbnB1dCBvbiB3aGl0ZXNwYWNlIGJlZm9yZSBmZWVkaW5nIGl0IHRvCgkgKiBnZXRfc2hhMTsgdGhpcyBpcyBkZWNpZGVkIGR1cmluZyB0aGUgbWFya19xdWVyeSBwaGFzZSBiYXNlZCBvbgoJICogd2hldGhlciB3ZSBoYXZlIGEgJShyZXN0KSB0b2tlbiBpbiBvdXIgZm9ybWF0LgoJICovCglpbnQgc3BsaXRfb25fd2hpdGVzcGFjZTsKCgkvKgoJICogQWZ0ZXIgYSBtYXJrX3F1ZXJ5IHJ1biwgdGhpcyBvYmplY3RfaW5mbyBpcyBzZXQgdXAgdG8gYmUKCSAqIHBhc3NlZCB0byBvaWRfb2JqZWN0X2luZm9fZXh0ZW5kZWQuIEl0IHdpbGwgcG9pbnQgdG8gdGhlIGRhdGEKCSAqIGVsZW1lbnRzIGFib3ZlLCBzbyB5b3UgY2FuIHJldHJpZXZlIHRoZSByZXNwb25zZSBmcm9tIHRoZXJlLgoJICovCglzdHJ1Y3Qgb2JqZWN0X2luZm8gaW5mbzsKCgkvKgoJICogVGhpcyBmbGFnIHdpbGwgYmUgdHJ1ZSBpZiB0aGUgcmVxdWVzdGVkIGJhdGNoIGZvcm1hdCBhbmQgb3B0aW9ucwoJICogZG9uJ3QgcmVxdWlyZSB1cyB0byBjYWxsIG9pZF9vYmplY3RfaW5mbywgd2hpY2ggY2FuIHRoZW4gYmUKCSAqIG9wdGltaXplZCBvdXQuCgkgKi8KCXVuc2lnbmVkIHNraXBfb2JqZWN0X2luZm8gOiAxOwp9OwoKc3RhdGljIGludCBpc19hdG9tKGNvbnN0IGNoYXIgKmF0b20sIGNvbnN0IGNoYXIgKnMsIGludCBzbGVuKQp7CglpbnQgYWxlbiA9IHN0cmxlbihhdG9tKTsKCXJldHVybiBhbGVuID09IHNsZW4gJiYgIW1lbWNtcChhdG9tLCBzLCBhbGVuKTsKfQoKc3RhdGljIHZvaWQgZXhwYW5kX2F0b20oc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKmF0b20sIGludCBsZW4sCgkJCXZvaWQgKnZkYXRhKQp7CglzdHJ1Y3QgZXhwYW5kX2RhdGEgKmRhdGEgPSB2ZGF0YTsKCglpZiAoaXNfYXRvbSgib2JqZWN0bmFtZSIsIGF0b20sIGxlbikpIHsKCQlpZiAoIWRhdGEtPm1hcmtfcXVlcnkpCgkJCXN0cmJ1Zl9hZGRzdHIoc2IsIG9pZF90b19oZXgoJmRhdGEtPm9pZCkpOwoJfSBlbHNlIGlmIChpc19hdG9tKCJvYmplY3R0eXBlIiwgYXRvbSwgbGVuKSkgewoJCWlmIChkYXRhLT5tYXJrX3F1ZXJ5KQoJCQlkYXRhLT5pbmZvLnR5cGVwID0gJmRhdGEtPnR5cGU7CgkJZWxzZQoJCQlzdHJidWZfYWRkc3RyKHNiLCB0eXBlX25hbWUoZGF0YS0+dHlwZSkpOwoJfSBlbHNlIGlmIChpc19hdG9tKCJvYmplY3RzaXplIiwgYXRvbSwgbGVuKSkgewoJCWlmIChkYXRhLT5tYXJrX3F1ZXJ5KQoJCQlkYXRhLT5pbmZvLnNpemVwID0gJmRhdGEtPnNpemU7CgkJZWxzZQoJCQlzdHJidWZfYWRkZihzYiwgIiUiUFJJdU1BWCAsICh1aW50bWF4X3QpZGF0YS0+c2l6ZSk7Cgl9IGVsc2UgaWYgKGlzX2F0b20oIm9iamVjdHNpemU6ZGlzayIsIGF0b20sIGxlbikpIHsKCQlpZiAoZGF0YS0+bWFya19xdWVyeSkKCQkJZGF0YS0+aW5mby5kaXNrX3NpemVwID0gJmRhdGEtPmRpc2tfc2l6ZTsKCQllbHNlCgkJCXN0cmJ1Zl9hZGRmKHNiLCAiJSJQUkl1TUFYLCAodWludG1heF90KWRhdGEtPmRpc2tfc2l6ZSk7Cgl9IGVsc2UgaWYgKGlzX2F0b20oInJlc3QiLCBhdG9tLCBsZW4pKSB7CgkJaWYgKGRhdGEtPm1hcmtfcXVlcnkpCgkJCWRhdGEtPnNwbGl0X29uX3doaXRlc3BhY2UgPSAxOwoJCWVsc2UgaWYgKGRhdGEtPnJlc3QpCgkJCXN0cmJ1Zl9hZGRzdHIoc2IsIGRhdGEtPnJlc3QpOwoJfSBlbHNlIGlmIChpc19hdG9tKCJkZWx0YWJhc2UiLCBhdG9tLCBsZW4pKSB7CgkJaWYgKGRhdGEtPm1hcmtfcXVlcnkpCgkJCWRhdGEtPmluZm8uZGVsdGFfYmFzZV9vaWQgPSAmZGF0YS0+ZGVsdGFfYmFzZV9vaWQ7CgkJZWxzZQoJCQlzdHJidWZfYWRkc3RyKHNiLAoJCQkJICAgICAgb2lkX3RvX2hleCgmZGF0YS0+ZGVsdGFfYmFzZV9vaWQpKTsKCX0gZWxzZQoJCWRpZSgidW5rbm93biBmb3JtYXQgZWxlbWVudDogJS4qcyIsIGxlbiwgYXRvbSk7Cn0KCnN0YXRpYyBzaXplX3QgZXhwYW5kX2Zvcm1hdChzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqc3RhcnQsIHZvaWQgKmRhdGEpCnsKCWNvbnN0IGNoYXIgKmVuZDsKCglpZiAoKnN0YXJ0ICE9ICcoJykKCQlyZXR1cm4gMDsKCWVuZCA9IHN0cmNocihzdGFydCArIDEsICcpJyk7CglpZiAoIWVuZCkKCQlkaWUoImZvcm1hdCBlbGVtZW50ICclcycgZG9lcyBub3QgZW5kIGluICcpJyIsIHN0YXJ0KTsKCglleHBhbmRfYXRvbShzYiwgc3RhcnQgKyAxLCBlbmQgLSBzdGFydCAtIDEsIGRhdGEpOwoKCXJldHVybiBlbmQgLSBzdGFydCArIDE7Cn0KCnN0YXRpYyB2b2lkIGJhdGNoX3dyaXRlKHN0cnVjdCBiYXRjaF9vcHRpb25zICpvcHQsIGNvbnN0IHZvaWQgKmRhdGEsIGludCBsZW4pCnsKCWlmIChvcHQtPmJ1ZmZlcl9vdXRwdXQpIHsKCQlpZiAoZndyaXRlKGRhdGEsIDEsIGxlbiwgc3Rkb3V0KSAhPSBsZW4pCgkJCWRpZV9lcnJubygidW5hYmxlIHRvIHdyaXRlIHRvIHN0ZG91dCIpOwoJfSBlbHNlCgkJd3JpdGVfb3JfZGllKDEsIGRhdGEsIGxlbik7Cn0KCnN0YXRpYyB2b2lkIHByaW50X29iamVjdF9vcl9kaWUoc3RydWN0IGJhdGNoX29wdGlvbnMgKm9wdCwgc3RydWN0IGV4cGFuZF9kYXRhICpkYXRhKQp7Cgljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQgPSAmZGF0YS0+b2lkOwoKCWFzc2VydChkYXRhLT5pbmZvLnR5cGVwKTsKCglpZiAoZGF0YS0+dHlwZSA9PSBPQkpfQkxPQikgewoJCWlmIChvcHQtPmJ1ZmZlcl9vdXRwdXQpCgkJCWZmbHVzaChzdGRvdXQpOwoJCWlmIChvcHQtPnRyYW5zZm9ybV9tb2RlKSB7CgkJCWNoYXIgKmNvbnRlbnRzOwoJCQl1bnNpZ25lZCBsb25nIHNpemU7CgoJCQlpZiAoIWRhdGEtPnJlc3QpCgkJCQlkaWUoIm1pc3NpbmcgcGF0aCBmb3IgJyVzJyIsIG9pZF90b19oZXgob2lkKSk7CgoJCQlpZiAob3B0LT50cmFuc2Zvcm1fbW9kZSA9PSAndycpIHsKCQkJCWlmIChmaWx0ZXJfb2JqZWN0KGRhdGEtPnJlc3QsIDAxMDA2NDQsIG9pZCwKCQkJCQkJICAmY29udGVudHMsICZzaXplKSkKCQkJCQlkaWUoImNvdWxkIG5vdCBjb252ZXJ0ICclcycgJXMiLAoJCQkJCSAgICBvaWRfdG9faGV4KG9pZCksIGRhdGEtPnJlc3QpOwoJCQl9IGVsc2UgaWYgKG9wdC0+dHJhbnNmb3JtX21vZGUgPT0gJ2MnKSB7CgkJCQllbnVtIG9iamVjdF90eXBlIHR5cGU7CgkJCQlpZiAoIXRleHRjb252X29iamVjdCh0aGVfcmVwb3NpdG9yeSwKCQkJCQkJICAgICBkYXRhLT5yZXN0LCAwMTAwNjQ0LCBvaWQsCgkJCQkJCSAgICAgMSwgJmNvbnRlbnRzLCAmc2l6ZSkpCgkJCQkJY29udGVudHMgPSByZXBvX3JlYWRfb2JqZWN0X2ZpbGUodGhlX3JlcG9zaXRvcnksCgkJCQkJCQkJCSBvaWQsCgkJCQkJCQkJCSAmdHlwZSwKCQkJCQkJCQkJICZzaXplKTsKCQkJCWlmICghY29udGVudHMpCgkJCQkJZGllKCJjb3VsZCBub3QgY29udmVydCAnJXMnICVzIiwKCQkJCQkgICAgb2lkX3RvX2hleChvaWQpLCBkYXRhLT5yZXN0KTsKCQkJfSBlbHNlCgkJCQlCVUcoImludmFsaWQgdHJhbnNmb3JtX21vZGU6ICVjIiwgb3B0LT50cmFuc2Zvcm1fbW9kZSk7CgkJCWJhdGNoX3dyaXRlKG9wdCwgY29udGVudHMsIHNpemUpOwoJCQlmcmVlKGNvbnRlbnRzKTsKCQl9IGVsc2UgewoJCQlzdHJlYW1fYmxvYihvaWQpOwoJCX0KCX0KCWVsc2UgewoJCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCQl1bnNpZ25lZCBsb25nIHNpemU7CgkJdm9pZCAqY29udGVudHM7CgoJCWNvbnRlbnRzID0gcmVwb19yZWFkX29iamVjdF9maWxlKHRoZV9yZXBvc2l0b3J5LCBvaWQsICZ0eXBlLAoJCQkJCQkgJnNpemUpOwoKCQlpZiAodXNlX21haWxtYXApIHsKCQkJc2l6ZV90IHMgPSBzaXplOwoJCQljb250ZW50cyA9IHJlcGxhY2VfaWRlbnRzX3VzaW5nX21haWxtYXAoY29udGVudHMsICZzKTsKCQkJc2l6ZSA9IGNhc3Rfc2l6ZV90X3RvX3Vsb25nKHMpOwoJCX0KCgkJaWYgKCFjb250ZW50cykKCQkJZGllKCJvYmplY3QgJXMgZGlzYXBwZWFyZWQiLCBvaWRfdG9faGV4KG9pZCkpOwoJCWlmICh0eXBlICE9IGRhdGEtPnR5cGUpCgkJCWRpZSgib2JqZWN0ICVzIGNoYW5nZWQgdHlwZSE/Iiwgb2lkX3RvX2hleChvaWQpKTsKCQlpZiAoZGF0YS0+aW5mby5zaXplcCAmJiBzaXplICE9IGRhdGEtPnNpemUgJiYgIXVzZV9tYWlsbWFwKQoJCQlkaWUoIm9iamVjdCAlcyBjaGFuZ2VkIHNpemUhPyIsIG9pZF90b19oZXgob2lkKSk7CgoJCWJhdGNoX3dyaXRlKG9wdCwgY29udGVudHMsIHNpemUpOwoJCWZyZWUoY29udGVudHMpOwoJfQp9CgpzdGF0aWMgdm9pZCBwcmludF9kZWZhdWx0X2Zvcm1hdChzdHJ1Y3Qgc3RyYnVmICpzY3JhdGNoLCBzdHJ1Y3QgZXhwYW5kX2RhdGEgKmRhdGEpCnsKCXN0cmJ1Zl9hZGRmKHNjcmF0Y2gsICIlcyAlcyAlIlBSSXVNQVgiXG4iLCBvaWRfdG9faGV4KCZkYXRhLT5vaWQpLAoJCSAgICB0eXBlX25hbWUoZGF0YS0+dHlwZSksCgkJICAgICh1aW50bWF4X3QpZGF0YS0+c2l6ZSk7Cn0KCi8qCiAqIElmICJwYWNrIiBpcyBub24tTlVMTCwgdGhlbiAib2Zmc2V0IiBpcyB0aGUgYnl0ZSBvZmZzZXQgd2l0aGluIHRoZSBwYWNrIGZyb20KICogd2hpY2ggdGhlIG9iamVjdCBtYXkgYmUgYWNjZXNzZWQgKHRob3VnaCBub3RlIHRoYXQgd2UgbWF5IGFsc28gcmVseSBvbgogKiBkYXRhLT5vaWQsIHRvbykuIElmICJwYWNrIiBpcyBOVUxMLCB0aGVuIG9mZnNldCBpcyBpZ25vcmVkLgogKi8Kc3RhdGljIHZvaWQgYmF0Y2hfb2JqZWN0X3dyaXRlKGNvbnN0IGNoYXIgKm9ial9uYW1lLAoJCQkgICAgICAgc3RydWN0IHN0cmJ1ZiAqc2NyYXRjaCwKCQkJICAgICAgIHN0cnVjdCBiYXRjaF9vcHRpb25zICpvcHQsCgkJCSAgICAgICBzdHJ1Y3QgZXhwYW5kX2RhdGEgKmRhdGEsCgkJCSAgICAgICBzdHJ1Y3QgcGFja2VkX2dpdCAqcGFjaywKCQkJICAgICAgIG9mZl90IG9mZnNldCkKewoJaWYgKCFkYXRhLT5za2lwX29iamVjdF9pbmZvKSB7CgkJaW50IHJldDsKCgkJaWYgKHVzZV9tYWlsbWFwKQoJCQlkYXRhLT5pbmZvLnR5cGVwID0gJmRhdGEtPnR5cGU7CgoJCWlmIChwYWNrKQoJCQlyZXQgPSBwYWNrZWRfb2JqZWN0X2luZm8odGhlX3JlcG9zaXRvcnksIHBhY2ssIG9mZnNldCwKCQkJCQkJICZkYXRhLT5pbmZvKTsKCQllbHNlCgkJCXJldCA9IG9pZF9vYmplY3RfaW5mb19leHRlbmRlZCh0aGVfcmVwb3NpdG9yeSwKCQkJCQkJICAgICAgICZkYXRhLT5vaWQsICZkYXRhLT5pbmZvLAoJCQkJCQkgICAgICAgT0JKRUNUX0lORk9fTE9PS1VQX1JFUExBQ0UpOwoJCWlmIChyZXQgPCAwKSB7CgkJCXByaW50ZigiJXMgbWlzc2luZ1xuIiwKCQkJICAgICAgIG9ial9uYW1lID8gb2JqX25hbWUgOiBvaWRfdG9faGV4KCZkYXRhLT5vaWQpKTsKCQkJZmZsdXNoKHN0ZG91dCk7CgkJCXJldHVybjsKCQl9CgoJCWlmICh1c2VfbWFpbG1hcCAmJiAoZGF0YS0+dHlwZSA9PSBPQkpfQ09NTUlUIHx8IGRhdGEtPnR5cGUgPT0gT0JKX1RBRykpIHsKCQkJc2l6ZV90IHMgPSBkYXRhLT5zaXplOwoJCQljaGFyICpidWYgPSBOVUxMOwoKCQkJYnVmID0gcmVwb19yZWFkX29iamVjdF9maWxlKHRoZV9yZXBvc2l0b3J5LCAmZGF0YS0+b2lkLCAmZGF0YS0+dHlwZSwKCQkJCQkJICAgICZkYXRhLT5zaXplKTsKCQkJYnVmID0gcmVwbGFjZV9pZGVudHNfdXNpbmdfbWFpbG1hcChidWYsICZzKTsKCQkJZGF0YS0+c2l6ZSA9IGNhc3Rfc2l6ZV90X3RvX3Vsb25nKHMpOwoKCQkJZnJlZShidWYpOwoJCX0KCX0KCglzdHJidWZfcmVzZXQoc2NyYXRjaCk7CgoJaWYgKCFvcHQtPmZvcm1hdCkgewoJCXByaW50X2RlZmF1bHRfZm9ybWF0KHNjcmF0Y2gsIGRhdGEpOwoJfSBlbHNlIHsKCQlzdHJidWZfZXhwYW5kKHNjcmF0Y2gsIG9wdC0+Zm9ybWF0LCBleHBhbmRfZm9ybWF0LCBkYXRhKTsKCQlzdHJidWZfYWRkY2goc2NyYXRjaCwgJ1xuJyk7Cgl9CgoJYmF0Y2hfd3JpdGUob3B0LCBzY3JhdGNoLT5idWYsIHNjcmF0Y2gtPmxlbik7CgoJaWYgKG9wdC0+YmF0Y2hfbW9kZSA9PSBCQVRDSF9NT0RFX0NPTlRFTlRTKSB7CgkJcHJpbnRfb2JqZWN0X29yX2RpZShvcHQsIGRhdGEpOwoJCWJhdGNoX3dyaXRlKG9wdCwgIlxuIiwgMSk7Cgl9Cn0KCnN0YXRpYyB2b2lkIGJhdGNoX29uZV9vYmplY3QoY29uc3QgY2hhciAqb2JqX25hbWUsCgkJCSAgICAgc3RydWN0IHN0cmJ1ZiAqc2NyYXRjaCwKCQkJICAgICBzdHJ1Y3QgYmF0Y2hfb3B0aW9ucyAqb3B0LAoJCQkgICAgIHN0cnVjdCBleHBhbmRfZGF0YSAqZGF0YSkKewoJc3RydWN0IG9iamVjdF9jb250ZXh0IGN0eDsKCWludCBmbGFncyA9IG9wdC0+Zm9sbG93X3N5bWxpbmtzID8gR0VUX09JRF9GT0xMT1dfU1lNTElOS1MgOiAwOwoJZW51bSBnZXRfb2lkX3Jlc3VsdCByZXN1bHQ7CgoJcmVzdWx0ID0gZ2V0X29pZF93aXRoX2NvbnRleHQodGhlX3JlcG9zaXRvcnksIG9ial9uYW1lLAoJCQkJICAgICAgZmxhZ3MsICZkYXRhLT5vaWQsICZjdHgpOwoJaWYgKHJlc3VsdCAhPSBGT1VORCkgewoJCXN3aXRjaCAocmVzdWx0KSB7CgkJY2FzZSBNSVNTSU5HX09CSkVDVDoKCQkJcHJpbnRmKCIlcyBtaXNzaW5nXG4iLCBvYmpfbmFtZSk7CgkJCWJyZWFrOwoJCWNhc2UgU0hPUlRfTkFNRV9BTUJJR1VPVVM6CgkJCXByaW50ZigiJXMgYW1iaWd1b3VzXG4iLCBvYmpfbmFtZSk7CgkJCWJyZWFrOwoJCWNhc2UgREFOR0xJTkdfU1lNTElOSzoKCQkJcHJpbnRmKCJkYW5nbGluZyAlIlBSSXVNQVgiXG4lc1xuIiwKCQkJICAgICAgICh1aW50bWF4X3Qpc3RybGVuKG9ial9uYW1lKSwgb2JqX25hbWUpOwoJCQlicmVhazsKCQljYXNlIFNZTUxJTktfTE9PUDoKCQkJcHJpbnRmKCJsb29wICUiUFJJdU1BWCJcbiVzXG4iLAoJCQkgICAgICAgKHVpbnRtYXhfdClzdHJsZW4ob2JqX25hbWUpLCBvYmpfbmFtZSk7CgkJCWJyZWFrOwoJCWNhc2UgTk9UX0RJUjoKCQkJcHJpbnRmKCJub3RkaXIgJSJQUkl1TUFYIlxuJXNcbiIsCgkJCSAgICAgICAodWludG1heF90KXN0cmxlbihvYmpfbmFtZSksIG9ial9uYW1lKTsKCQkJYnJlYWs7CgkJZGVmYXVsdDoKCQkJQlVHKCJ1bmtub3duIGdldF9zaGExX3dpdGhfY29udGV4dCByZXN1bHQgJWRcbiIsCgkJCSAgICAgICByZXN1bHQpOwoJCQlicmVhazsKCQl9CgkJZmZsdXNoKHN0ZG91dCk7CgkJcmV0dXJuOwoJfQoKCWlmIChjdHgubW9kZSA9PSAwKSB7CgkJcHJpbnRmKCJzeW1saW5rICUiUFJJdU1BWCJcbiVzXG4iLAoJCSAgICAgICAodWludG1heF90KWN0eC5zeW1saW5rX3BhdGgubGVuLAoJCSAgICAgICBjdHguc3ltbGlua19wYXRoLmJ1Zik7CgkJZmZsdXNoKHN0ZG91dCk7CgkJcmV0dXJuOwoJfQoKCWJhdGNoX29iamVjdF93cml0ZShvYmpfbmFtZSwgc2NyYXRjaCwgb3B0LCBkYXRhLCBOVUxMLCAwKTsKfQoKc3RydWN0IG9iamVjdF9jYl9kYXRhIHsKCXN0cnVjdCBiYXRjaF9vcHRpb25zICpvcHQ7CglzdHJ1Y3QgZXhwYW5kX2RhdGEgKmV4cGFuZDsKCXN0cnVjdCBvaWRzZXQgKnNlZW47CglzdHJ1Y3Qgc3RyYnVmICpzY3JhdGNoOwp9OwoKc3RhdGljIGludCBiYXRjaF9vYmplY3RfY2IoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCB2b2lkICp2ZGF0YSkKewoJc3RydWN0IG9iamVjdF9jYl9kYXRhICpkYXRhID0gdmRhdGE7CglvaWRjcHkoJmRhdGEtPmV4cGFuZC0+b2lkLCBvaWQpOwoJYmF0Y2hfb2JqZWN0X3dyaXRlKE5VTEwsIGRhdGEtPnNjcmF0Y2gsIGRhdGEtPm9wdCwgZGF0YS0+ZXhwYW5kLAoJCQkgICBOVUxMLCAwKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGNvbGxlY3RfbG9vc2Vfb2JqZWN0KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCWNvbnN0IGNoYXIgKnBhdGggVU5VU0VELAoJCQkJdm9pZCAqZGF0YSkKewoJb2lkX2FycmF5X2FwcGVuZChkYXRhLCBvaWQpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgY29sbGVjdF9wYWNrZWRfb2JqZWN0KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCSBzdHJ1Y3QgcGFja2VkX2dpdCAqcGFjayBVTlVTRUQsCgkJCQkgdWludDMyX3QgcG9zIFVOVVNFRCwKCQkJCSB2b2lkICpkYXRhKQp7CglvaWRfYXJyYXlfYXBwZW5kKGRhdGEsIG9pZCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBiYXRjaF91bm9yZGVyZWRfb2JqZWN0KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCSAgc3RydWN0IHBhY2tlZF9naXQgKnBhY2ssIG9mZl90IG9mZnNldCwKCQkJCSAgdm9pZCAqdmRhdGEpCnsKCXN0cnVjdCBvYmplY3RfY2JfZGF0YSAqZGF0YSA9IHZkYXRhOwoKCWlmIChvaWRzZXRfaW5zZXJ0KGRhdGEtPnNlZW4sIG9pZCkpCgkJcmV0dXJuIDA7CgoJb2lkY3B5KCZkYXRhLT5leHBhbmQtPm9pZCwgb2lkKTsKCWJhdGNoX29iamVjdF93cml0ZShOVUxMLCBkYXRhLT5zY3JhdGNoLCBkYXRhLT5vcHQsIGRhdGEtPmV4cGFuZCwKCQkJICAgcGFjaywgb2Zmc2V0KTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGJhdGNoX3Vub3JkZXJlZF9sb29zZShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCQkgY29uc3QgY2hhciAqcGF0aCBVTlVTRUQsCgkJCQkgdm9pZCAqZGF0YSkKewoJcmV0dXJuIGJhdGNoX3Vub3JkZXJlZF9vYmplY3Qob2lkLCBOVUxMLCAwLCBkYXRhKTsKfQoKc3RhdGljIGludCBiYXRjaF91bm9yZGVyZWRfcGFja2VkKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCSAgc3RydWN0IHBhY2tlZF9naXQgKnBhY2ssCgkJCQkgIHVpbnQzMl90IHBvcywKCQkJCSAgdm9pZCAqZGF0YSkKewoJcmV0dXJuIGJhdGNoX3Vub3JkZXJlZF9vYmplY3Qob2lkLCBwYWNrLAoJCQkJICAgICAgbnRoX3BhY2tlZF9vYmplY3Rfb2Zmc2V0KHBhY2ssIHBvcyksCgkJCQkgICAgICBkYXRhKTsKfQoKdHlwZWRlZiB2b2lkICgqcGFyc2VfY21kX2ZuX3QpKHN0cnVjdCBiYXRjaF9vcHRpb25zICosIGNvbnN0IGNoYXIgKiwKCQkJICAgICAgIHN0cnVjdCBzdHJidWYgKiwgc3RydWN0IGV4cGFuZF9kYXRhICopOwoKc3RydWN0IHF1ZXVlZF9jbWQgewoJcGFyc2VfY21kX2ZuX3QgZm47CgljaGFyICpsaW5lOwp9OwoKc3RhdGljIHZvaWQgcGFyc2VfY21kX2NvbnRlbnRzKHN0cnVjdCBiYXRjaF9vcHRpb25zICpvcHQsCgkJCSAgICAgY29uc3QgY2hhciAqbGluZSwKCQkJICAgICBzdHJ1Y3Qgc3RyYnVmICpvdXRwdXQsCgkJCSAgICAgc3RydWN0IGV4cGFuZF9kYXRhICpkYXRhKQp7CglvcHQtPmJhdGNoX21vZGUgPSBCQVRDSF9NT0RFX0NPTlRFTlRTOwoJYmF0Y2hfb25lX29iamVjdChsaW5lLCBvdXRwdXQsIG9wdCwgZGF0YSk7Cn0KCnN0YXRpYyB2b2lkIHBhcnNlX2NtZF9pbmZvKHN0cnVjdCBiYXRjaF9vcHRpb25zICpvcHQsCgkJCSAgIGNvbnN0IGNoYXIgKmxpbmUsCgkJCSAgIHN0cnVjdCBzdHJidWYgKm91dHB1dCwKCQkJICAgc3RydWN0IGV4cGFuZF9kYXRhICpkYXRhKQp7CglvcHQtPmJhdGNoX21vZGUgPSBCQVRDSF9NT0RFX0lORk87CgliYXRjaF9vbmVfb2JqZWN0KGxpbmUsIG91dHB1dCwgb3B0LCBkYXRhKTsKfQoKc3RhdGljIHZvaWQgZGlzcGF0Y2hfY2FsbHMoc3RydWN0IGJhdGNoX29wdGlvbnMgKm9wdCwKCQlzdHJ1Y3Qgc3RyYnVmICpvdXRwdXQsCgkJc3RydWN0IGV4cGFuZF9kYXRhICpkYXRhLAoJCXN0cnVjdCBxdWV1ZWRfY21kICpjbWQsCgkJaW50IG5yKQp7CglpbnQgaTsKCglpZiAoIW9wdC0+YnVmZmVyX291dHB1dCkKCQlkaWUoXygiZmx1c2ggaXMgb25seSBmb3IgLS1idWZmZXIgbW9kZSIpKTsKCglmb3IgKGkgPSAwOyBpIDwgbnI7IGkrKykKCQljbWRbaV0uZm4ob3B0LCBjbWRbaV0ubGluZSwgb3V0cHV0LCBkYXRhKTsKCglmZmx1c2goc3Rkb3V0KTsKfQoKc3RhdGljIHZvaWQgZnJlZV9jbWRzKHN0cnVjdCBxdWV1ZWRfY21kICpjbWQsIHNpemVfdCAqbnIpCnsKCXNpemVfdCBpOwoKCWZvciAoaSA9IDA7IGkgPCAqbnI7IGkrKykKCQlGUkVFX0FORF9OVUxMKGNtZFtpXS5saW5lKTsKCgkqbnIgPSAwOwp9CgoKc3RhdGljIGNvbnN0IHN0cnVjdCBwYXJzZV9jbWQgewoJY29uc3QgY2hhciAqbmFtZTsKCXBhcnNlX2NtZF9mbl90IGZuOwoJdW5zaWduZWQgdGFrZXNfYXJnczsKfSBjb21tYW5kc1tdID0gewoJeyAiY29udGVudHMiLCBwYXJzZV9jbWRfY29udGVudHMsIDF9LAoJeyAiaW5mbyIsIHBhcnNlX2NtZF9pbmZvLCAxfSwKCXsgImZsdXNoIiwgTlVMTCwgMH0sCn07CgpzdGF0aWMgdm9pZCBiYXRjaF9vYmplY3RzX2NvbW1hbmQoc3RydWN0IGJhdGNoX29wdGlvbnMgKm9wdCwKCQkJCSAgICBzdHJ1Y3Qgc3RyYnVmICpvdXRwdXQsCgkJCQkgICAgc3RydWN0IGV4cGFuZF9kYXRhICpkYXRhKQp7CglzdHJ1Y3Qgc3RyYnVmIGlucHV0ID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3QgcXVldWVkX2NtZCAqcXVldWVkX2NtZCA9IE5VTEw7CglzaXplX3QgYWxsb2MgPSAwLCBuciA9IDA7CgoJd2hpbGUgKHN0cmJ1Zl9nZXRkZWxpbV9zdHJpcF9jcmxmKCZpbnB1dCwgc3RkaW4sIG9wdC0+aW5wdXRfZGVsaW0pICE9IEVPRikgewoJCWludCBpOwoJCWNvbnN0IHN0cnVjdCBwYXJzZV9jbWQgKmNtZCA9IE5VTEw7CgkJY29uc3QgY2hhciAqcCA9IE5VTEwsICpjbWRfZW5kOwoJCXN0cnVjdCBxdWV1ZWRfY21kIGNhbGwgPSB7MH07CgoJCWlmICghaW5wdXQubGVuKQoJCQlkaWUoXygiZW1wdHkgY29tbWFuZCBpbiBpbnB1dCIpKTsKCQlpZiAoaXNzcGFjZSgqaW5wdXQuYnVmKSkKCQkJZGllKF8oIndoaXRlc3BhY2UgYmVmb3JlIGNvbW1hbmQ6ICclcyciKSwgaW5wdXQuYnVmKTsKCgkJZm9yIChpID0gMDsgaSA8IEFSUkFZX1NJWkUoY29tbWFuZHMpOyBpKyspIHsKCQkJaWYgKCFza2lwX3ByZWZpeChpbnB1dC5idWYsIGNvbW1hbmRzW2ldLm5hbWUsICZjbWRfZW5kKSkKCQkJCWNvbnRpbnVlOwoKCQkJY21kID0gJmNvbW1hbmRzW2ldOwoJCQlpZiAoY21kLT50YWtlc19hcmdzKSB7CgkJCQlpZiAoKmNtZF9lbmQgIT0gJyAnKQoJCQkJCWRpZShfKCIlcyByZXF1aXJlcyBhcmd1bWVudHMiKSwKCQkJCQkgICAgY29tbWFuZHNbaV0ubmFtZSk7CgoJCQkJcCA9IGNtZF9lbmQgKyAxOwoJCQl9IGVsc2UgaWYgKCpjbWRfZW5kKSB7CgkJCQlkaWUoXygiJXMgdGFrZXMgbm8gYXJndW1lbnRzIiksCgkJCQkgICAgY29tbWFuZHNbaV0ubmFtZSk7CgkJCX0KCgkJCWJyZWFrOwoJCX0KCgkJaWYgKCFjbWQpCgkJCWRpZShfKCJ1bmtub3duIGNvbW1hbmQ6ICclcyciKSwgaW5wdXQuYnVmKTsKCgkJaWYgKCFzdHJjbXAoY21kLT5uYW1lLCAiZmx1c2giKSkgewoJCQlkaXNwYXRjaF9jYWxscyhvcHQsIG91dHB1dCwgZGF0YSwgcXVldWVkX2NtZCwgbnIpOwoJCQlmcmVlX2NtZHMocXVldWVkX2NtZCwgJm5yKTsKCQl9IGVsc2UgaWYgKCFvcHQtPmJ1ZmZlcl9vdXRwdXQpIHsKCQkJY21kLT5mbihvcHQsIHAsIG91dHB1dCwgZGF0YSk7CgkJfSBlbHNlIHsKCQkJQUxMT0NfR1JPVyhxdWV1ZWRfY21kLCBuciArIDEsIGFsbG9jKTsKCQkJY2FsbC5mbiA9IGNtZC0+Zm47CgkJCWNhbGwubGluZSA9IHhzdHJkdXBfb3JfbnVsbChwKTsKCQkJcXVldWVkX2NtZFtucisrXSA9IGNhbGw7CgkJfQoJfQoKCWlmIChvcHQtPmJ1ZmZlcl9vdXRwdXQgJiYKCSAgICBuciAmJgoJICAgICFnaXRfZW52X2Jvb2woIkdJVF9URVNUX0NBVF9GSUxFX05PX0ZMVVNIX09OX0VYSVQiLCAwKSkgewoJCWRpc3BhdGNoX2NhbGxzKG9wdCwgb3V0cHV0LCBkYXRhLCBxdWV1ZWRfY21kLCBucik7CgkJZnJlZV9jbWRzKHF1ZXVlZF9jbWQsICZucik7Cgl9CgoJZnJlZV9jbWRzKHF1ZXVlZF9jbWQsICZucik7CglmcmVlKHF1ZXVlZF9jbWQpOwoJc3RyYnVmX3JlbGVhc2UoJmlucHV0KTsKfQoKI2RlZmluZSBERUZBVUxUX0ZPUk1BVCAiJShvYmplY3RuYW1lKSAlKG9iamVjdHR5cGUpICUob2JqZWN0c2l6ZSkiCgpzdGF0aWMgaW50IGJhdGNoX29iamVjdHMoc3RydWN0IGJhdGNoX29wdGlvbnMgKm9wdCkKewoJc3RydWN0IHN0cmJ1ZiBpbnB1dCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBvdXRwdXQgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBleHBhbmRfZGF0YSBkYXRhOwoJaW50IHNhdmVfd2FybmluZzsKCWludCByZXR2YWwgPSAwOwoKCS8qCgkgKiBFeHBhbmQgb25jZSB3aXRoIG91ciBzcGVjaWFsIG1hcmtfcXVlcnkgZmxhZywgd2hpY2ggd2lsbCBwcmltZSB0aGUKCSAqIG9iamVjdF9pbmZvIHRvIGJlIGhhbmRlZCB0byBvaWRfb2JqZWN0X2luZm9fZXh0ZW5kZWQgZm9yIGVhY2gKCSAqIG9iamVjdC4KCSAqLwoJbWVtc2V0KCZkYXRhLCAwLCBzaXplb2YoZGF0YSkpOwoJZGF0YS5tYXJrX3F1ZXJ5ID0gMTsKCXN0cmJ1Zl9leHBhbmQoJm91dHB1dCwKCQkgICAgICBvcHQtPmZvcm1hdCA/IG9wdC0+Zm9ybWF0IDogREVGQVVMVF9GT1JNQVQsCgkJICAgICAgZXhwYW5kX2Zvcm1hdCwKCQkgICAgICAmZGF0YSk7CglkYXRhLm1hcmtfcXVlcnkgPSAwOwoJc3RyYnVmX3JlbGVhc2UoJm91dHB1dCk7CglpZiAob3B0LT50cmFuc2Zvcm1fbW9kZSkKCQlkYXRhLnNwbGl0X29uX3doaXRlc3BhY2UgPSAxOwoKCWlmIChvcHQtPmZvcm1hdCAmJiAhc3RyY21wKG9wdC0+Zm9ybWF0LCBERUZBVUxUX0ZPUk1BVCkpCgkJb3B0LT5mb3JtYXQgPSBOVUxMOwoJLyoKCSAqIElmIHdlIGFyZSBwcmludGluZyBvdXQgdGhlIG9iamVjdCwgdGhlbiBhbHdheXMgZmlsbCBpbiB0aGUgdHlwZSwKCSAqIHNpbmNlIHdlIHdpbGwgd2FudCB0byBkZWNpZGUgd2hldGhlciBvciBub3QgdG8gc3RyZWFtLgoJICovCglpZiAob3B0LT5iYXRjaF9tb2RlID09IEJBVENIX01PREVfQ09OVEVOVFMpCgkJZGF0YS5pbmZvLnR5cGVwID0gJmRhdGEudHlwZTsKCglpZiAob3B0LT5hbGxfb2JqZWN0cykgewoJCXN0cnVjdCBvYmplY3RfY2JfZGF0YSBjYjsKCQlzdHJ1Y3Qgb2JqZWN0X2luZm8gZW1wdHkgPSBPQkpFQ1RfSU5GT19JTklUOwoKCQlpZiAoIW1lbWNtcCgmZGF0YS5pbmZvLCAmZW1wdHksIHNpemVvZihlbXB0eSkpKQoJCQlkYXRhLnNraXBfb2JqZWN0X2luZm8gPSAxOwoKCQlpZiAocmVwb19oYXNfcHJvbWlzb3JfcmVtb3RlKHRoZV9yZXBvc2l0b3J5KSkKCQkJd2FybmluZygiVGhpcyByZXBvc2l0b3J5IHVzZXMgcHJvbWlzb3IgcmVtb3Rlcy4gU29tZSBvYmplY3RzIG1heSBub3QgYmUgbG9hZGVkLiIpOwoKCQlyZWFkX3JlcGxhY2VfcmVmcyA9IDA7CgoJCWNiLm9wdCA9IG9wdDsKCQljYi5leHBhbmQgPSAmZGF0YTsKCQljYi5zY3JhdGNoID0gJm91dHB1dDsKCgkJaWYgKG9wdC0+dW5vcmRlcmVkKSB7CgkJCXN0cnVjdCBvaWRzZXQgc2VlbiA9IE9JRFNFVF9JTklUOwoKCQkJY2Iuc2VlbiA9ICZzZWVuOwoKCQkJZm9yX2VhY2hfbG9vc2Vfb2JqZWN0KGJhdGNoX3Vub3JkZXJlZF9sb29zZSwgJmNiLCAwKTsKCQkJZm9yX2VhY2hfcGFja2VkX29iamVjdChiYXRjaF91bm9yZGVyZWRfcGFja2VkLCAmY2IsCgkJCQkJICAgICAgIEZPUl9FQUNIX09CSkVDVF9QQUNLX09SREVSKTsKCgkJCW9pZHNldF9jbGVhcigmc2Vlbik7CgkJfSBlbHNlIHsKCQkJc3RydWN0IG9pZF9hcnJheSBzYSA9IE9JRF9BUlJBWV9JTklUOwoKCQkJZm9yX2VhY2hfbG9vc2Vfb2JqZWN0KGNvbGxlY3RfbG9vc2Vfb2JqZWN0LCAmc2EsIDApOwoJCQlmb3JfZWFjaF9wYWNrZWRfb2JqZWN0KGNvbGxlY3RfcGFja2VkX29iamVjdCwgJnNhLCAwKTsKCgkJCW9pZF9hcnJheV9mb3JfZWFjaF91bmlxdWUoJnNhLCBiYXRjaF9vYmplY3RfY2IsICZjYik7CgoJCQlvaWRfYXJyYXlfY2xlYXIoJnNhKTsKCQl9CgoJCXN0cmJ1Zl9yZWxlYXNlKCZvdXRwdXQpOwoJCXJldHVybiAwOwoJfQoKCS8qCgkgKiBXZSBhcmUgZ29pbmcgdG8gY2FsbCBnZXRfc2hhMSBvbiBhIHBvdGVudGlhbGx5IHZlcnkgbGFyZ2UgbnVtYmVyIG9mCgkgKiBvYmplY3RzLiBJbiBtb3N0IGxhcmdlIGNhc2VzLCB0aGVzZSB3aWxsIGJlIGFjdHVhbCBvYmplY3Qgc2hhMXMuIFRoZQoJICogY29zdCB0byBkb3VibGUtY2hlY2sgdGhhdCBlYWNoIG9uZSBpcyBub3QgYWxzbyBhIHJlZiAoanVzdCBzbyB3ZSBjYW4KCSAqIHdhcm4pIGVuZHMgdXAgZHdhcmZpbmcgdGhlIGFjdHVhbCBjb3N0IG9mIHRoZSBvYmplY3QgbG9va3VwcwoJICogdGhlbXNlbHZlcy4gV2UgY2FuIHdvcmsgYXJvdW5kIGl0IGJ5IGp1c3QgdHVybmluZyBvZmYgdGhlIHdhcm5pbmcuCgkgKi8KCXNhdmVfd2FybmluZyA9IHdhcm5fb25fb2JqZWN0X3JlZm5hbWVfYW1iaWd1aXR5OwoJd2Fybl9vbl9vYmplY3RfcmVmbmFtZV9hbWJpZ3VpdHkgPSAwOwoKCWlmIChvcHQtPmJhdGNoX21vZGUgPT0gQkFUQ0hfTU9ERV9RVUVVRV9BTkRfRElTUEFUQ0gpIHsKCQliYXRjaF9vYmplY3RzX2NvbW1hbmQob3B0LCAmb3V0cHV0LCAmZGF0YSk7CgkJZ290byBjbGVhbnVwOwoJfQoKCXdoaWxlIChzdHJidWZfZ2V0ZGVsaW1fc3RyaXBfY3JsZigmaW5wdXQsIHN0ZGluLCBvcHQtPmlucHV0X2RlbGltKSAhPSBFT0YpIHsKCQlpZiAoZGF0YS5zcGxpdF9vbl93aGl0ZXNwYWNlKSB7CgkJCS8qCgkJCSAqIFNwbGl0IGF0IGZpcnN0IHdoaXRlc3BhY2UsIHR5aW5nIG9mZiB0aGUgYmVnaW5uaW5nCgkJCSAqIG9mIHRoZSBzdHJpbmcgYW5kIHNhdmluZyB0aGUgcmVtYWluZGVyIChvciBOVUxMKSBpbgoJCQkgKiBkYXRhLnJlc3QuCgkJCSAqLwoJCQljaGFyICpwID0gc3RycGJyayhpbnB1dC5idWYsICIgXHQiKTsKCQkJaWYgKHApIHsKCQkJCXdoaWxlICgqcCAmJiBzdHJjaHIoIiBcdCIsICpwKSkKCQkJCQkqcCsrID0gJ1wwJzsKCQkJfQoJCQlkYXRhLnJlc3QgPSBwOwoJCX0KCgkJYmF0Y2hfb25lX29iamVjdChpbnB1dC5idWYsICZvdXRwdXQsIG9wdCwgJmRhdGEpOwoJfQoKIGNsZWFudXA6CglzdHJidWZfcmVsZWFzZSgmaW5wdXQpOwoJc3RyYnVmX3JlbGVhc2UoJm91dHB1dCk7Cgl3YXJuX29uX29iamVjdF9yZWZuYW1lX2FtYmlndWl0eSA9IHNhdmVfd2FybmluZzsKCXJldHVybiByZXR2YWw7Cn0KCnN0YXRpYyBpbnQgZ2l0X2NhdF9maWxlX2NvbmZpZyhjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlLCB2b2lkICpjYikKewoJaWYgKHVzZXJkaWZmX2NvbmZpZyh2YXIsIHZhbHVlKSA8IDApCgkJcmV0dXJuIC0xOwoKCXJldHVybiBnaXRfZGVmYXVsdF9jb25maWcodmFyLCB2YWx1ZSwgY2IpOwp9CgpzdGF0aWMgaW50IGJhdGNoX29wdGlvbl9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsCgkJCQkgY29uc3QgY2hhciAqYXJnLAoJCQkJIGludCB1bnNldCkKewoJc3RydWN0IGJhdGNoX29wdGlvbnMgKmJvID0gb3B0LT52YWx1ZTsKCglCVUdfT05fT1BUX05FRyh1bnNldCk7CgoJaWYgKGJvLT5lbmFibGVkKSB7CgkJcmV0dXJuIGVycm9yKF8oIm9ubHkgb25lIGJhdGNoIG9wdGlvbiBtYXkgYmUgc3BlY2lmaWVkIikpOwoJfQoKCWJvLT5lbmFibGVkID0gMTsKCglpZiAoIXN0cmNtcChvcHQtPmxvbmdfbmFtZSwgImJhdGNoIikpCgkJYm8tPmJhdGNoX21vZGUgPSBCQVRDSF9NT0RFX0NPTlRFTlRTOwoJZWxzZSBpZiAoIXN0cmNtcChvcHQtPmxvbmdfbmFtZSwgImJhdGNoLWNoZWNrIikpCgkJYm8tPmJhdGNoX21vZGUgPSBCQVRDSF9NT0RFX0lORk87CgllbHNlIGlmICghc3RyY21wKG9wdC0+bG9uZ19uYW1lLCAiYmF0Y2gtY29tbWFuZCIpKQoJCWJvLT5iYXRjaF9tb2RlID0gQkFUQ0hfTU9ERV9RVUVVRV9BTkRfRElTUEFUQ0g7CgllbHNlCgkJQlVHKCIlcyBnaXZlbiB0byBiYXRjaC1vcHRpb24tY2FsbGJhY2siLCBvcHQtPmxvbmdfbmFtZSk7CgoJYm8tPmZvcm1hdCA9IGFyZzsKCglyZXR1cm4gMDsKfQoKaW50IGNtZF9jYXRfZmlsZShpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJaW50IG9wdCA9IDA7CglpbnQgb3B0X2N3ID0gMDsKCWludCBvcHRfZXB0cyA9IDA7Cgljb25zdCBjaGFyICpleHBfdHlwZSA9IE5VTEwsICpvYmpfbmFtZSA9IE5VTEw7CglzdHJ1Y3QgYmF0Y2hfb3B0aW9ucyBiYXRjaCA9IHswfTsKCWludCB1bmtub3duX3R5cGUgPSAwOwoJaW50IGlucHV0X251bF90ZXJtaW5hdGVkID0gMDsKCgljb25zdCBjaGFyICogY29uc3QgdXNhZ2VbXSA9IHsKCQlOXygiZ2l0IGNhdC1maWxlIDx0eXBlPiA8b2JqZWN0PiIpLAoJCU5fKCJnaXQgY2F0LWZpbGUgKC1lIHwgLXApIDxvYmplY3Q+IiksCgkJTl8oImdpdCBjYXQtZmlsZSAoLXQgfCAtcykgWy0tYWxsb3ctdW5rbm93bi10eXBlXSA8b2JqZWN0PiIpLAoJCU5fKCJnaXQgY2F0LWZpbGUgKC0tYmF0Y2ggfCAtLWJhdGNoLWNoZWNrIHwgLS1iYXRjaC1jb21tYW5kKSBbLS1iYXRjaC1hbGwtb2JqZWN0c11cbiIKCQkgICAiICAgICAgICAgICAgIFstLWJ1ZmZlcl0gWy0tZm9sbG93LXN5bWxpbmtzXSBbLS11bm9yZGVyZWRdXG4iCgkJICAgIiAgICAgICAgICAgICBbLS10ZXh0Y29udiB8IC0tZmlsdGVyc10gWy16XSIpLAoJCU5fKCJnaXQgY2F0LWZpbGUgKC0tdGV4dGNvbnYgfCAtLWZpbHRlcnMpXG4iCgkJICAgIiAgICAgICAgICAgICBbPHJldj46PHBhdGh8dHJlZS1pc2g+IHwgLS1wYXRoPTxwYXRofHRyZWUtaXNoPiA8cmV2Pl0iKSwKCQlOVUxMCgl9OwoJY29uc3Qgc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJLyogU2ltcGxlIHF1ZXJpZXMgKi8KCQlPUFRfR1JPVVAoTl8oIkNoZWNrIG9iamVjdCBleGlzdGVuY2Ugb3IgZW1pdCBvYmplY3QgY29udGVudHMiKSksCgkJT1BUX0NNRE1PREUoJ2UnLCBOVUxMLCAmb3B0LAoJCQkgICAgTl8oImNoZWNrIGlmIDxvYmplY3Q+IGV4aXN0cyIpLCAnZScpLAoJCU9QVF9DTURNT0RFKCdwJywgTlVMTCwgJm9wdCwgTl8oInByZXR0eS1wcmludCA8b2JqZWN0PiBjb250ZW50IiksICdwJyksCgoJCU9QVF9HUk9VUChOXygiRW1pdCBbYnJva2VuXSBvYmplY3QgYXR0cmlidXRlcyIpKSwKCQlPUFRfQ01ETU9ERSgndCcsIE5VTEwsICZvcHQsIE5fKCJzaG93IG9iamVjdCB0eXBlIChvbmUgb2YgJ2Jsb2InLCAndHJlZScsICdjb21taXQnLCAndGFnJywgLi4uKSIpLCAndCcpLAoJCU9QVF9DTURNT0RFKCdzJywgTlVMTCwgJm9wdCwgTl8oInNob3cgb2JqZWN0IHNpemUiKSwgJ3MnKSwKCQlPUFRfQk9PTCgwLCAiYWxsb3ctdW5rbm93bi10eXBlIiwgJnVua25vd25fdHlwZSwKCQkJICBOXygiYWxsb3cgLXMgYW5kIC10IHRvIHdvcmsgd2l0aCBicm9rZW4vY29ycnVwdCBvYmplY3RzIikpLAoJCU9QVF9CT09MKDAsICJ1c2UtbWFpbG1hcCIsICZ1c2VfbWFpbG1hcCwgTl8oInVzZSBtYWlsIG1hcCBmaWxlIikpLAoJCU9QVF9BTElBUygwLCAibWFpbG1hcCIsICJ1c2UtbWFpbG1hcCIpLAoJCS8qIEJhdGNoIG1vZGUgKi8KCQlPUFRfR1JPVVAoTl8oIkJhdGNoIG9iamVjdHMgcmVxdWVzdGVkIG9uIHN0ZGluIChvciAtLWJhdGNoLWFsbC1vYmplY3RzKSIpKSwKCQlPUFRfQ0FMTEJBQ0tfRigwLCAiYmF0Y2giLCAmYmF0Y2gsIE5fKCJmb3JtYXQiKSwKCQkJTl8oInNob3cgZnVsbCA8b2JqZWN0PiBvciA8cmV2PiBjb250ZW50cyIpLAoJCQlQQVJTRV9PUFRfT1BUQVJHIHwgUEFSU0VfT1BUX05PTkVHLAoJCQliYXRjaF9vcHRpb25fY2FsbGJhY2spLAoJCU9QVF9DQUxMQkFDS19GKDAsICJiYXRjaC1jaGVjayIsICZiYXRjaCwgTl8oImZvcm1hdCIpLAoJCQlOXygibGlrZSAtLWJhdGNoLCBidXQgZG9uJ3QgZW1pdCA8Y29udGVudHM+IiksCgkJCVBBUlNFX09QVF9PUFRBUkcgfCBQQVJTRV9PUFRfTk9ORUcsCgkJCWJhdGNoX29wdGlvbl9jYWxsYmFjayksCgkJT1BUX0JPT0woJ3onLCBOVUxMLCAmaW5wdXRfbnVsX3Rlcm1pbmF0ZWQsIE5fKCJzdGRpbiBpcyBOVUwtdGVybWluYXRlZCIpKSwKCQlPUFRfQ0FMTEJBQ0tfRigwLCAiYmF0Y2gtY29tbWFuZCIsICZiYXRjaCwgTl8oImZvcm1hdCIpLAoJCQlOXygicmVhZCBjb21tYW5kcyBmcm9tIHN0ZGluIiksCgkJCVBBUlNFX09QVF9PUFRBUkcgfCBQQVJTRV9PUFRfTk9ORUcsCgkJCWJhdGNoX29wdGlvbl9jYWxsYmFjayksCgkJT1BUX0NNRE1PREUoMCwgImJhdGNoLWFsbC1vYmplY3RzIiwgJm9wdCwKCQkJICAgIE5fKCJ3aXRoIC0tYmF0Y2hbLWNoZWNrXTogaWdub3JlcyBzdGRpbiwgYmF0Y2hlcyBhbGwga25vd24gb2JqZWN0cyIpLCAnYicpLAoJCS8qIEJhdGNoLXNwZWNpZmljIG9wdGlvbnMgKi8KCQlPUFRfR1JPVVAoTl8oIkNoYW5nZSBvciBvcHRpbWl6ZSBiYXRjaCBvdXRwdXQiKSksCgkJT1BUX0JPT0woMCwgImJ1ZmZlciIsICZiYXRjaC5idWZmZXJfb3V0cHV0LCBOXygiYnVmZmVyIC0tYmF0Y2ggb3V0cHV0IikpLAoJCU9QVF9CT09MKDAsICJmb2xsb3ctc3ltbGlua3MiLCAmYmF0Y2guZm9sbG93X3N5bWxpbmtzLAoJCQkgTl8oImZvbGxvdyBpbi10cmVlIHN5bWxpbmtzIikpLAoJCU9QVF9CT09MKDAsICJ1bm9yZGVyZWQiLCAmYmF0Y2gudW5vcmRlcmVkLAoJCQkgTl8oImRvIG5vdCBvcmRlciBvYmplY3RzIGJlZm9yZSBlbWl0dGluZyB0aGVtIikpLAoJCS8qIFRleHRjb252IG9wdGlvbnMsIHN0YW5kLW9sZSovCgkJT1BUX0dST1VQKE5fKCJFbWl0IG9iamVjdCAoYmxvYiBvciB0cmVlKSB3aXRoIGNvbnZlcnNpb24gb3IgZmlsdGVyIChzdGFuZC1hbG9uZSwgb3Igd2l0aCBiYXRjaCkiKSksCgkJT1BUX0NNRE1PREUoMCwgInRleHRjb252IiwgJm9wdCwKCQkJICAgIE5fKCJydW4gdGV4dGNvbnYgb24gb2JqZWN0J3MgY29udGVudCIpLCAnYycpLAoJCU9QVF9DTURNT0RFKDAsICJmaWx0ZXJzIiwgJm9wdCwKCQkJICAgIE5fKCJydW4gZmlsdGVycyBvbiBvYmplY3QncyBjb250ZW50IiksICd3JyksCgkJT1BUX1NUUklORygwLCAicGF0aCIsICZmb3JjZV9wYXRoLCBOXygiYmxvYnx0cmVlIiksCgkJCSAgIE5fKCJ1c2UgYSA8cGF0aD4gZm9yICgtLXRleHRjb252IHwgLS1maWx0ZXJzKTsgTm90IHdpdGggJ2JhdGNoJyIpKSwKCQlPUFRfRU5EKCkKCX07CgoJZ2l0X2NvbmZpZyhnaXRfY2F0X2ZpbGVfY29uZmlnLCBOVUxMKTsKCgliYXRjaC5idWZmZXJfb3V0cHV0ID0gLTE7CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBvcHRpb25zLCB1c2FnZSwgMCk7CglvcHRfY3cgPSAob3B0ID09ICdjJyB8fCBvcHQgPT0gJ3cnKTsKCW9wdF9lcHRzID0gKG9wdCA9PSAnZScgfHwgb3B0ID09ICdwJyB8fCBvcHQgPT0gJ3QnIHx8IG9wdCA9PSAncycpOwoKCWlmICh1c2VfbWFpbG1hcCkKCQlyZWFkX21haWxtYXAoJm1haWxtYXApOwoKCS8qIC0tYmF0Y2gtYWxsLW9iamVjdHM/ICovCglpZiAob3B0ID09ICdiJykKCQliYXRjaC5hbGxfb2JqZWN0cyA9IDE7CgoJLyogT3B0aW9uIGNvbXBhdGliaWxpdHkgKi8KCWlmIChmb3JjZV9wYXRoICYmICFvcHRfY3cpCgkJdXNhZ2VfbXNnX29wdGYoXygiJyVzPTwlcz4nIG5lZWRzICclcycgb3IgJyVzJyIpLAoJCQkgICAgICAgdXNhZ2UsIG9wdGlvbnMsCgkJCSAgICAgICAiLS1wYXRoIiwgXygicGF0aHx0cmVlLWlzaCIpLCAiLS1maWx0ZXJzIiwKCQkJICAgICAgICItLXRleHRjb252Iik7CgoJLyogT3B0aW9uIGNvbXBhdGliaWxpdHkgd2l0aCBiYXRjaCBtb2RlICovCglpZiAoYmF0Y2guZW5hYmxlZCkKCQk7CgllbHNlIGlmIChiYXRjaC5mb2xsb3dfc3ltbGlua3MpCgkJdXNhZ2VfbXNnX29wdGYoXygiJyVzJyByZXF1aXJlcyBhIGJhdGNoIG1vZGUiKSwgdXNhZ2UsIG9wdGlvbnMsCgkJCSAgICAgICAiLS1mb2xsb3ctc3ltbGlua3MiKTsKCWVsc2UgaWYgKGJhdGNoLmJ1ZmZlcl9vdXRwdXQgPj0gMCkKCQl1c2FnZV9tc2dfb3B0ZihfKCInJXMnIHJlcXVpcmVzIGEgYmF0Y2ggbW9kZSIpLCB1c2FnZSwgb3B0aW9ucywKCQkJICAgICAgICItLWJ1ZmZlciIpOwoJZWxzZSBpZiAoYmF0Y2guYWxsX29iamVjdHMpCgkJdXNhZ2VfbXNnX29wdGYoXygiJyVzJyByZXF1aXJlcyBhIGJhdGNoIG1vZGUiKSwgdXNhZ2UsIG9wdGlvbnMsCgkJCSAgICAgICAiLS1iYXRjaC1hbGwtb2JqZWN0cyIpOwoJZWxzZSBpZiAoaW5wdXRfbnVsX3Rlcm1pbmF0ZWQpCgkJdXNhZ2VfbXNnX29wdGYoXygiJyVzJyByZXF1aXJlcyBhIGJhdGNoIG1vZGUiKSwgdXNhZ2UsIG9wdGlvbnMsCgkJCSAgICAgICAiLXoiKTsKCgliYXRjaC5pbnB1dF9kZWxpbSA9IGlucHV0X251bF90ZXJtaW5hdGVkID8gJ1wwJyA6ICdcbic7CgoJLyogQmF0Y2ggZGVmYXVsdHMgKi8KCWlmIChiYXRjaC5idWZmZXJfb3V0cHV0IDwgMCkKCQliYXRjaC5idWZmZXJfb3V0cHV0ID0gYmF0Y2guYWxsX29iamVjdHM7CgoJLyogUmV0dXJuIGVhcmx5IGlmIHdlJ3JlIGluIGJhdGNoIG1vZGU/ICovCglpZiAoYmF0Y2guZW5hYmxlZCkgewoJCWlmIChvcHRfY3cpCgkJCWJhdGNoLnRyYW5zZm9ybV9tb2RlID0gb3B0OwoJCWVsc2UgaWYgKG9wdCAmJiBvcHQgIT0gJ2InKQoJCQl1c2FnZV9tc2dfb3B0ZihfKCInLSVjJyBpcyBpbmNvbXBhdGlibGUgd2l0aCBiYXRjaCBtb2RlIiksCgkJCQkgICAgICAgdXNhZ2UsIG9wdGlvbnMsIG9wdCk7CgkJZWxzZSBpZiAoYXJnYykKCQkJdXNhZ2VfbXNnX29wdChfKCJiYXRjaCBtb2RlcyB0YWtlIG5vIGFyZ3VtZW50cyIpLCB1c2FnZSwKCQkJCSAgICAgIG9wdGlvbnMpOwoKCQlyZXR1cm4gYmF0Y2hfb2JqZWN0cygmYmF0Y2gpOwoJfQoKCWlmIChvcHQpIHsKCQlpZiAoIWFyZ2MgJiYgb3B0ID09ICdjJykKCQkJdXNhZ2VfbXNnX29wdGYoXygiPHJldj4gcmVxdWlyZWQgd2l0aCAnJXMnIiksCgkJCQkgICAgICAgdXNhZ2UsIG9wdGlvbnMsICItLXRleHRjb252Iik7CgkJZWxzZSBpZiAoIWFyZ2MgJiYgb3B0ID09ICd3JykKCQkJdXNhZ2VfbXNnX29wdGYoXygiPHJldj4gcmVxdWlyZWQgd2l0aCAnJXMnIiksCgkJCQkgICAgICAgdXNhZ2UsIG9wdGlvbnMsICItLWZpbHRlcnMiKTsKCQllbHNlIGlmICghYXJnYyAmJiBvcHRfZXB0cykKCQkJdXNhZ2VfbXNnX29wdGYoXygiPG9iamVjdD4gcmVxdWlyZWQgd2l0aCAnLSVjJyIpLAoJCQkJICAgICAgIHVzYWdlLCBvcHRpb25zLCBvcHQpOwoJCWVsc2UgaWYgKGFyZ2MgPT0gMSkKCQkJb2JqX25hbWUgPSBhcmd2WzBdOwoJCWVsc2UKCQkJdXNhZ2VfbXNnX29wdChfKCJ0b28gbWFueSBhcmd1bWVudHMiKSwgdXNhZ2UsIG9wdGlvbnMpOwoJfSBlbHNlIGlmICghYXJnYykgewoJCXVzYWdlX3dpdGhfb3B0aW9ucyh1c2FnZSwgb3B0aW9ucyk7Cgl9IGVsc2UgaWYgKGFyZ2MgIT0gMikgewoJCXVzYWdlX21zZ19vcHRmKF8oIm9ubHkgdHdvIGFyZ3VtZW50cyBhbGxvd2VkIGluIDx0eXBlPiA8b2JqZWN0PiBtb2RlLCBub3QgJWQiKSwKCQkJICAgICAgdXNhZ2UsIG9wdGlvbnMsIGFyZ2MpOwoJfSBlbHNlIGlmIChhcmdjKSB7CgkJZXhwX3R5cGUgPSBhcmd2WzBdOwoJCW9ial9uYW1lID0gYXJndlsxXTsKCX0KCglpZiAodW5rbm93bl90eXBlICYmIG9wdCAhPSAndCcgJiYgb3B0ICE9ICdzJykKCQlkaWUoImdpdCBjYXQtZmlsZSAtLWFsbG93LXVua25vd24tdHlwZTogdXNlIHdpdGggLXMgb3IgLXQiKTsKCXJldHVybiBjYXRfb25lX2ZpbGUob3B0LCBleHBfdHlwZSwgb2JqX25hbWUsIHVua25vd25fdHlwZSk7Cn0K",
    "text": "/*\n * GIT - The information manager from hell\n *\n * Copyright (C) Linus Torvalds, 2005\n */\n#define USE_THE_INDEX_VARIABLE\n#include \"cache.h\"\n#include \"alloc.h\"\n#include \"config.h\"\n#include \"convert.h\"\n#include \"builtin.h\"\n#include \"diff.h\"\n#include \"environment.h\"\n#include \"gettext.h\"\n#include \"hex.h\"\n#include \"ident.h\"\n#include \"parse-options.h\"\n#include \"userdiff.h\"\n#include \"streaming.h\"\n#include \"tree-walk.h\"\n#include \"oid-array.h\"\n#include \"packfile.h\"\n#include \"object-file.h\"\n#include \"object-name.h\"\n#include \"object-store.h\"\n#include \"replace-object.h\"\n#include \"promisor-remote.h\"\n#include \"mailmap.h\"\n#include \"write-or-die.h\"\n\nenum batch_mode {\n\tBATCH_MODE_CONTENTS,\n\tBATCH_MODE_INFO,\n\tBATCH_MODE_QUEUE_AND_DISPATCH,\n};\n\nstruct batch_options {\n\tint enabled;\n\tint follow_symlinks;\n\tenum batch_mode batch_mode;\n\tint buffer_output;\n\tint all_objects;\n\tint unordered;\n\tint transform_mode; /* may be 'w' or 'c' for --filters or --textconv */\n\tchar input_delim;\n\tconst char *format;\n};\n\nstatic const char *force_path;\n\nstatic struct string_list mailmap = STRING_LIST_INIT_NODUP;\nstatic int use_mailmap;\n\nstatic char *replace_idents_using_mailmap(char *, size_t *);\n\nstatic char *replace_idents_using_mailmap(char *object_buf, size_t *size)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *headers[] = { \"author \", \"committer \", \"tagger \", NULL };\n\n\tstrbuf_attach(&sb, object_buf, *size, *size + 1);\n\tapply_mailmap_to_header(&sb, headers, &mailmap);\n\t*size = sb.len;\n\treturn strbuf_detach(&sb, NULL);\n}\n\nstatic int filter_object(const char *path, unsigned mode,\n\t\t\t const struct object_id *oid,\n\t\t\t char **buf, unsigned long *size)\n{\n\tenum object_type type;\n\n\t*buf = repo_read_object_file(the_repository, oid, &type, size);\n\tif (!*buf)\n\t\treturn error(_(\"cannot read object %s '%s'\"),\n\t\t\t     oid_to_hex(oid), path);\n\tif ((type == OBJ_BLOB) && S_ISREG(mode)) {\n\t\tstruct strbuf strbuf = STRBUF_INIT;\n\t\tstruct checkout_metadata meta;\n\n\t\tinit_checkout_metadata(&meta, NULL, NULL, oid);\n\t\tif (convert_to_working_tree(&the_index, path, *buf, *size, &strbuf, &meta)) {\n\t\t\tfree(*buf);\n\t\t\t*size = strbuf.len;\n\t\t\t*buf = strbuf_detach(&strbuf, NULL);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int stream_blob(const struct object_id *oid)\n{\n\tif (stream_blob_to_fd(1, oid, NULL, 0))\n\t\tdie(\"unable to stream %s to stdout\", oid_to_hex(oid));\n\treturn 0;\n}\n\nstatic int cat_one_file(int opt, const char *exp_type, const char *obj_name,\n\t\t\tint unknown_type)\n{\n\tint ret;\n\tstruct object_id oid;\n\tenum object_type type;\n\tchar *buf;\n\tunsigned long size;\n\tstruct object_context obj_context;\n\tstruct object_info oi = OBJECT_INFO_INIT;\n\tstruct strbuf sb = STRBUF_INIT;\n\tunsigned flags = OBJECT_INFO_LOOKUP_REPLACE;\n\tunsigned get_oid_flags = GET_OID_RECORD_PATH | GET_OID_ONLY_TO_DIE;\n\tconst char *path = force_path;\n\tconst int opt_cw = (opt == 'c' || opt == 'w');\n\tif (!path && opt_cw)\n\t\tget_oid_flags |= GET_OID_REQUIRE_PATH;\n\n\tif (unknown_type)\n\t\tflags |= OBJECT_INFO_ALLOW_UNKNOWN_TYPE;\n\n\tif (get_oid_with_context(the_repository, obj_name, get_oid_flags, &oid,\n\t\t\t\t &obj_context))\n\t\tdie(\"Not a valid object name %s\", obj_name);\n\n\tif (!path)\n\t\tpath = obj_context.path;\n\tif (obj_context.mode == S_IFINVALID)\n\t\tobj_context.mode = 0100644;\n\n\tbuf = NULL;\n\tswitch (opt) {\n\tcase 't':\n\t\toi.type_name = &sb;\n\t\tif (oid_object_info_extended(the_repository, &oid, &oi, flags) < 0)\n\t\t\tdie(\"git cat-file: could not get object info\");\n\t\tif (sb.len) {\n\t\t\tprintf(\"%s\\n\", sb.buf);\n\t\t\tstrbuf_release(&sb);\n\t\t\tret = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbreak;\n\n\tcase 's':\n\t\toi.sizep = &size;\n\n\t\tif (use_mailmap) {\n\t\t\toi.typep = &type;\n\t\t\toi.contentp = (void**)&buf;\n\t\t}\n\n\t\tif (oid_object_info_extended(the_repository, &oid, &oi, flags) < 0)\n\t\t\tdie(\"git cat-file: could not get object info\");\n\n\t\tif (use_mailmap && (type == OBJ_COMMIT || type == OBJ_TAG)) {\n\t\t\tsize_t s = size;\n\t\t\tbuf = replace_idents_using_mailmap(buf, &s);\n\t\t\tsize = cast_size_t_to_ulong(s);\n\t\t}\n\n\t\tprintf(\"%\"PRIuMAX\"\\n\", (uintmax_t)size);\n\t\tret = 0;\n\t\tgoto cleanup;\n\n\tcase 'e':\n\t\treturn !repo_has_object_file(the_repository, &oid);\n\n\tcase 'w':\n\n\t\tif (filter_object(path, obj_context.mode,\n\t\t\t\t  &oid, &buf, &size)) {\n\t\t\tret = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbreak;\n\n\tcase 'c':\n\t\tif (textconv_object(the_repository, path, obj_context.mode,\n\t\t\t\t    &oid, 1, &buf, &size))\n\t\t\tbreak;\n\t\t/* else fallthrough */\n\n\tcase 'p':\n\t\ttype = oid_object_info(the_repository, &oid, NULL);\n\t\tif (type < 0)\n\t\t\tdie(\"Not a valid object name %s\", obj_name);\n\n\t\t/* custom pretty-print here */\n\t\tif (type == OBJ_TREE) {\n\t\t\tconst char *ls_args[3] = { NULL };\n\t\t\tls_args[0] =  \"ls-tree\";\n\t\t\tls_args[1] =  obj_name;\n\t\t\tret = cmd_ls_tree(2, ls_args, NULL);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (type == OBJ_BLOB) {\n\t\t\tret = stream_blob(&oid);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbuf = repo_read_object_file(the_repository, &oid, &type,\n\t\t\t\t\t    &size);\n\t\tif (!buf)\n\t\t\tdie(\"Cannot read object %s\", obj_name);\n\n\t\tif (use_mailmap) {\n\t\t\tsize_t s = size;\n\t\t\tbuf = replace_idents_using_mailmap(buf, &s);\n\t\t\tsize = cast_size_t_to_ulong(s);\n\t\t}\n\n\t\t/* otherwise just spit out the data */\n\t\tbreak;\n\n\tcase 0:\n\t{\n\t\tenum object_type exp_type_id = type_from_string(exp_type);\n\n\t\tif (exp_type_id == OBJ_BLOB) {\n\t\t\tstruct object_id blob_oid;\n\t\t\tif (oid_object_info(the_repository, &oid, NULL) == OBJ_TAG) {\n\t\t\t\tchar *buffer = repo_read_object_file(the_repository,\n\t\t\t\t\t\t\t\t     &oid,\n\t\t\t\t\t\t\t\t     &type,\n\t\t\t\t\t\t\t\t     &size);\n\t\t\t\tconst char *target;\n\t\t\t\tif (!skip_prefix(buffer, \"object \", &target) ||\n\t\t\t\t    get_oid_hex(target, &blob_oid))\n\t\t\t\t\tdie(\"%s not a valid tag\", oid_to_hex(&oid));\n\t\t\t\tfree(buffer);\n\t\t\t} else\n\t\t\t\toidcpy(&blob_oid, &oid);\n\n\t\t\tif (oid_object_info(the_repository, &blob_oid, NULL) == OBJ_BLOB) {\n\t\t\t\tret = stream_blob(&blob_oid);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t/*\n\t\t\t * we attempted to dereference a tag to a blob\n\t\t\t * and failed; there may be new dereference\n\t\t\t * mechanisms this code is not aware of.\n\t\t\t * fall-back to the usual case.\n\t\t\t */\n\t\t}\n\t\tbuf = read_object_with_reference(the_repository, &oid,\n\t\t\t\t\t\t exp_type_id, &size, NULL);\n\n\t\tif (use_mailmap) {\n\t\t\tsize_t s = size;\n\t\t\tbuf = replace_idents_using_mailmap(buf, &s);\n\t\t\tsize = cast_size_t_to_ulong(s);\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdie(\"git cat-file: unknown option: %s\", exp_type);\n\t}\n\n\tif (!buf)\n\t\tdie(\"git cat-file %s: bad file\", obj_name);\n\n\twrite_or_die(1, buf, size);\n\tret = 0;\ncleanup:\n\tfree(buf);\n\tfree(obj_context.path);\n\treturn ret;\n}\n\nstruct expand_data {\n\tstruct object_id oid;\n\tenum object_type type;\n\tunsigned long size;\n\toff_t disk_size;\n\tconst char *rest;\n\tstruct object_id delta_base_oid;\n\n\t/*\n\t * If mark_query is true, we do not expand anything, but rather\n\t * just mark the object_info with items we wish to query.\n\t */\n\tint mark_query;\n\n\t/*\n\t * Whether to split the input on whitespace before feeding it to\n\t * get_sha1; this is decided during the mark_query phase based on\n\t * whether we have a %(rest) token in our format.\n\t */\n\tint split_on_whitespace;\n\n\t/*\n\t * After a mark_query run, this object_info is set up to be\n\t * passed to oid_object_info_extended. It will point to the data\n\t * elements above, so you can retrieve the response from there.\n\t */\n\tstruct object_info info;\n\n\t/*\n\t * This flag will be true if the requested batch format and options\n\t * don't require us to call oid_object_info, which can then be\n\t * optimized out.\n\t */\n\tunsigned skip_object_info : 1;\n};\n\nstatic int is_atom(const char *atom, const char *s, int slen)\n{\n\tint alen = strlen(atom);\n\treturn alen == slen && !memcmp(atom, s, alen);\n}\n\nstatic void expand_atom(struct strbuf *sb, const char *atom, int len,\n\t\t\tvoid *vdata)\n{\n\tstruct expand_data *data = vdata;\n\n\tif (is_atom(\"objectname\", atom, len)) {\n\t\tif (!data->mark_query)\n\t\t\tstrbuf_addstr(sb, oid_to_hex(&data->oid));\n\t} else if (is_atom(\"objecttype\", atom, len)) {\n\t\tif (data->mark_query)\n\t\t\tdata->info.typep = &data->type;\n\t\telse\n\t\t\tstrbuf_addstr(sb, type_name(data->type));\n\t} else if (is_atom(\"objectsize\", atom, len)) {\n\t\tif (data->mark_query)\n\t\t\tdata->info.sizep = &data->size;\n\t\telse\n\t\t\tstrbuf_addf(sb, \"%\"PRIuMAX , (uintmax_t)data->size);\n\t} else if (is_atom(\"objectsize:disk\", atom, len)) {\n\t\tif (data->mark_query)\n\t\t\tdata->info.disk_sizep = &data->disk_size;\n\t\telse\n\t\t\tstrbuf_addf(sb, \"%\"PRIuMAX, (uintmax_t)data->disk_size);\n\t} else if (is_atom(\"rest\", atom, len)) {\n\t\tif (data->mark_query)\n\t\t\tdata->split_on_whitespace = 1;\n\t\telse if (data->rest)\n\t\t\tstrbuf_addstr(sb, data->rest);\n\t} else if (is_atom(\"deltabase\", atom, len)) {\n\t\tif (data->mark_query)\n\t\t\tdata->info.delta_base_oid = &data->delta_base_oid;\n\t\telse\n\t\t\tstrbuf_addstr(sb,\n\t\t\t\t      oid_to_hex(&data->delta_base_oid));\n\t} else\n\t\tdie(\"unknown format element: %.*s\", len, atom);\n}\n\nstatic size_t expand_format(struct strbuf *sb, const char *start, void *data)\n{\n\tconst char *end;\n\n\tif (*start != '(')\n\t\treturn 0;\n\tend = strchr(start + 1, ')');\n\tif (!end)\n\t\tdie(\"format element '%s' does not end in ')'\", start);\n\n\texpand_atom(sb, start + 1, end - start - 1, data);\n\n\treturn end - start + 1;\n}\n\nstatic void batch_write(struct batch_options *opt, const void *data, int len)\n{\n\tif (opt->buffer_output) {\n\t\tif (fwrite(data, 1, len, stdout) != len)\n\t\t\tdie_errno(\"unable to write to stdout\");\n\t} else\n\t\twrite_or_die(1, data, len);\n}\n\nstatic void print_object_or_die(struct batch_options *opt, struct expand_data *data)\n{\n\tconst struct object_id *oid = &data->oid;\n\n\tassert(data->info.typep);\n\n\tif (data->type == OBJ_BLOB) {\n\t\tif (opt->buffer_output)\n\t\t\tfflush(stdout);\n\t\tif (opt->transform_mode) {\n\t\t\tchar *contents;\n\t\t\tunsigned long size;\n\n\t\t\tif (!data->rest)\n\t\t\t\tdie(\"missing path for '%s'\", oid_to_hex(oid));\n\n\t\t\tif (opt->transform_mode == 'w') {\n\t\t\t\tif (filter_object(data->rest, 0100644, oid,\n\t\t\t\t\t\t  &contents, &size))\n\t\t\t\t\tdie(\"could not convert '%s' %s\",\n\t\t\t\t\t    oid_to_hex(oid), data->rest);\n\t\t\t} else if (opt->transform_mode == 'c') {\n\t\t\t\tenum object_type type;\n\t\t\t\tif (!textconv_object(the_repository,\n\t\t\t\t\t\t     data->rest, 0100644, oid,\n\t\t\t\t\t\t     1, &contents, &size))\n\t\t\t\t\tcontents = repo_read_object_file(the_repository,\n\t\t\t\t\t\t\t\t\t oid,\n\t\t\t\t\t\t\t\t\t &type,\n\t\t\t\t\t\t\t\t\t &size);\n\t\t\t\tif (!contents)\n\t\t\t\t\tdie(\"could not convert '%s' %s\",\n\t\t\t\t\t    oid_to_hex(oid), data->rest);\n\t\t\t} else\n\t\t\t\tBUG(\"invalid transform_mode: %c\", opt->transform_mode);\n\t\t\tbatch_write(opt, contents, size);\n\t\t\tfree(contents);\n\t\t} else {\n\t\t\tstream_blob(oid);\n\t\t}\n\t}\n\telse {\n\t\tenum object_type type;\n\t\tunsigned long size;\n\t\tvoid *contents;\n\n\t\tcontents = repo_read_object_file(the_repository, oid, &type,\n\t\t\t\t\t\t &size);\n\n\t\tif (use_mailmap) {\n\t\t\tsize_t s = size;\n\t\t\tcontents = replace_idents_using_mailmap(contents, &s);\n\t\t\tsize = cast_size_t_to_ulong(s);\n\t\t}\n\n\t\tif (!contents)\n\t\t\tdie(\"object %s disappeared\", oid_to_hex(oid));\n\t\tif (type != data->type)\n\t\t\tdie(\"object %s changed type!?\", oid_to_hex(oid));\n\t\tif (data->info.sizep && size != data->size && !use_mailmap)\n\t\t\tdie(\"object %s changed size!?\", oid_to_hex(oid));\n\n\t\tbatch_write(opt, contents, size);\n\t\tfree(contents);\n\t}\n}\n\nstatic void print_default_format(struct strbuf *scratch, struct expand_data *data)\n{\n\tstrbuf_addf(scratch, \"%s %s %\"PRIuMAX\"\\n\", oid_to_hex(&data->oid),\n\t\t    type_name(data->type),\n\t\t    (uintmax_t)data->size);\n}\n\n/*\n * If \"pack\" is non-NULL, then \"offset\" is the byte offset within the pack from\n * which the object may be accessed (though note that we may also rely on\n * data->oid, too). If \"pack\" is NULL, then offset is ignored.\n */\nstatic void batch_object_write(const char *obj_name,\n\t\t\t       struct strbuf *scratch,\n\t\t\t       struct batch_options *opt,\n\t\t\t       struct expand_data *data,\n\t\t\t       struct packed_git *pack,\n\t\t\t       off_t offset)\n{\n\tif (!data->skip_object_info) {\n\t\tint ret;\n\n\t\tif (use_mailmap)\n\t\t\tdata->info.typep = &data->type;\n\n\t\tif (pack)\n\t\t\tret = packed_object_info(the_repository, pack, offset,\n\t\t\t\t\t\t &data->info);\n\t\telse\n\t\t\tret = oid_object_info_extended(the_repository,\n\t\t\t\t\t\t       &data->oid, &data->info,\n\t\t\t\t\t\t       OBJECT_INFO_LOOKUP_REPLACE);\n\t\tif (ret < 0) {\n\t\t\tprintf(\"%s missing\\n\",\n\t\t\t       obj_name ? obj_name : oid_to_hex(&data->oid));\n\t\t\tfflush(stdout);\n\t\t\treturn;\n\t\t}\n\n\t\tif (use_mailmap && (data->type == OBJ_COMMIT || data->type == OBJ_TAG)) {\n\t\t\tsize_t s = data->size;\n\t\t\tchar *buf = NULL;\n\n\t\t\tbuf = repo_read_object_file(the_repository, &data->oid, &data->type,\n\t\t\t\t\t\t    &data->size);\n\t\t\tbuf = replace_idents_using_mailmap(buf, &s);\n\t\t\tdata->size = cast_size_t_to_ulong(s);\n\n\t\t\tfree(buf);\n\t\t}\n\t}\n\n\tstrbuf_reset(scratch);\n\n\tif (!opt->format) {\n\t\tprint_default_format(scratch, data);\n\t} else {\n\t\tstrbuf_expand(scratch, opt->format, expand_format, data);\n\t\tstrbuf_addch(scratch, '\\n');\n\t}\n\n\tbatch_write(opt, scratch->buf, scratch->len);\n\n\tif (opt->batch_mode == BATCH_MODE_CONTENTS) {\n\t\tprint_object_or_die(opt, data);\n\t\tbatch_write(opt, \"\\n\", 1);\n\t}\n}\n\nstatic void batch_one_object(const char *obj_name,\n\t\t\t     struct strbuf *scratch,\n\t\t\t     struct batch_options *opt,\n\t\t\t     struct expand_data *data)\n{\n\tstruct object_context ctx;\n\tint flags = opt->follow_symlinks ? GET_OID_FOLLOW_SYMLINKS : 0;\n\tenum get_oid_result result;\n\n\tresult = get_oid_with_context(the_repository, obj_name,\n\t\t\t\t      flags, &data->oid, &ctx);\n\tif (result != FOUND) {\n\t\tswitch (result) {\n\t\tcase MISSING_OBJECT:\n\t\t\tprintf(\"%s missing\\n\", obj_name);\n\t\t\tbreak;\n\t\tcase SHORT_NAME_AMBIGUOUS:\n\t\t\tprintf(\"%s ambiguous\\n\", obj_name);\n\t\t\tbreak;\n\t\tcase DANGLING_SYMLINK:\n\t\t\tprintf(\"dangling %\"PRIuMAX\"\\n%s\\n\",\n\t\t\t       (uintmax_t)strlen(obj_name), obj_name);\n\t\t\tbreak;\n\t\tcase SYMLINK_LOOP:\n\t\t\tprintf(\"loop %\"PRIuMAX\"\\n%s\\n\",\n\t\t\t       (uintmax_t)strlen(obj_name), obj_name);\n\t\t\tbreak;\n\t\tcase NOT_DIR:\n\t\t\tprintf(\"notdir %\"PRIuMAX\"\\n%s\\n\",\n\t\t\t       (uintmax_t)strlen(obj_name), obj_name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG(\"unknown get_sha1_with_context result %d\\n\",\n\t\t\t       result);\n\t\t\tbreak;\n\t\t}\n\t\tfflush(stdout);\n\t\treturn;\n\t}\n\n\tif (ctx.mode == 0) {\n\t\tprintf(\"symlink %\"PRIuMAX\"\\n%s\\n\",\n\t\t       (uintmax_t)ctx.symlink_path.len,\n\t\t       ctx.symlink_path.buf);\n\t\tfflush(stdout);\n\t\treturn;\n\t}\n\n\tbatch_object_write(obj_name, scratch, opt, data, NULL, 0);\n}\n\nstruct object_cb_data {\n\tstruct batch_options *opt;\n\tstruct expand_data *expand;\n\tstruct oidset *seen;\n\tstruct strbuf *scratch;\n};\n\nstatic int batch_object_cb(const struct object_id *oid, void *vdata)\n{\n\tstruct object_cb_data *data = vdata;\n\toidcpy(&data->expand->oid, oid);\n\tbatch_object_write(NULL, data->scratch, data->opt, data->expand,\n\t\t\t   NULL, 0);\n\treturn 0;\n}\n\nstatic int collect_loose_object(const struct object_id *oid,\n\t\t\t\tconst char *path UNUSED,\n\t\t\t\tvoid *data)\n{\n\toid_array_append(data, oid);\n\treturn 0;\n}\n\nstatic int collect_packed_object(const struct object_id *oid,\n\t\t\t\t struct packed_git *pack UNUSED,\n\t\t\t\t uint32_t pos UNUSED,\n\t\t\t\t void *data)\n{\n\toid_array_append(data, oid);\n\treturn 0;\n}\n\nstatic int batch_unordered_object(const struct object_id *oid,\n\t\t\t\t  struct packed_git *pack, off_t offset,\n\t\t\t\t  void *vdata)\n{\n\tstruct object_cb_data *data = vdata;\n\n\tif (oidset_insert(data->seen, oid))\n\t\treturn 0;\n\n\toidcpy(&data->expand->oid, oid);\n\tbatch_object_write(NULL, data->scratch, data->opt, data->expand,\n\t\t\t   pack, offset);\n\treturn 0;\n}\n\nstatic int batch_unordered_loose(const struct object_id *oid,\n\t\t\t\t const char *path UNUSED,\n\t\t\t\t void *data)\n{\n\treturn batch_unordered_object(oid, NULL, 0, data);\n}\n\nstatic int batch_unordered_packed(const struct object_id *oid,\n\t\t\t\t  struct packed_git *pack,\n\t\t\t\t  uint32_t pos,\n\t\t\t\t  void *data)\n{\n\treturn batch_unordered_object(oid, pack,\n\t\t\t\t      nth_packed_object_offset(pack, pos),\n\t\t\t\t      data);\n}\n\ntypedef void (*parse_cmd_fn_t)(struct batch_options *, const char *,\n\t\t\t       struct strbuf *, struct expand_data *);\n\nstruct queued_cmd {\n\tparse_cmd_fn_t fn;\n\tchar *line;\n};\n\nstatic void parse_cmd_contents(struct batch_options *opt,\n\t\t\t     const char *line,\n\t\t\t     struct strbuf *output,\n\t\t\t     struct expand_data *data)\n{\n\topt->batch_mode = BATCH_MODE_CONTENTS;\n\tbatch_one_object(line, output, opt, data);\n}\n\nstatic void parse_cmd_info(struct batch_options *opt,\n\t\t\t   const char *line,\n\t\t\t   struct strbuf *output,\n\t\t\t   struct expand_data *data)\n{\n\topt->batch_mode = BATCH_MODE_INFO;\n\tbatch_one_object(line, output, opt, data);\n}\n\nstatic void dispatch_calls(struct batch_options *opt,\n\t\tstruct strbuf *output,\n\t\tstruct expand_data *data,\n\t\tstruct queued_cmd *cmd,\n\t\tint nr)\n{\n\tint i;\n\n\tif (!opt->buffer_output)\n\t\tdie(_(\"flush is only for --buffer mode\"));\n\n\tfor (i = 0; i < nr; i++)\n\t\tcmd[i].fn(opt, cmd[i].line, output, data);\n\n\tfflush(stdout);\n}\n\nstatic void free_cmds(struct queued_cmd *cmd, size_t *nr)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < *nr; i++)\n\t\tFREE_AND_NULL(cmd[i].line);\n\n\t*nr = 0;\n}\n\n\nstatic const struct parse_cmd {\n\tconst char *name;\n\tparse_cmd_fn_t fn;\n\tunsigned takes_args;\n} commands[] = {\n\t{ \"contents\", parse_cmd_contents, 1},\n\t{ \"info\", parse_cmd_info, 1},\n\t{ \"flush\", NULL, 0},\n};\n\nstatic void batch_objects_command(struct batch_options *opt,\n\t\t\t\t    struct strbuf *output,\n\t\t\t\t    struct expand_data *data)\n{\n\tstruct strbuf input = STRBUF_INIT;\n\tstruct queued_cmd *queued_cmd = NULL;\n\tsize_t alloc = 0, nr = 0;\n\n\twhile (strbuf_getdelim_strip_crlf(&input, stdin, opt->input_delim) != EOF) {\n\t\tint i;\n\t\tconst struct parse_cmd *cmd = NULL;\n\t\tconst char *p = NULL, *cmd_end;\n\t\tstruct queued_cmd call = {0};\n\n\t\tif (!input.len)\n\t\t\tdie(_(\"empty command in input\"));\n\t\tif (isspace(*input.buf))\n\t\t\tdie(_(\"whitespace before command: '%s'\"), input.buf);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(commands); i++) {\n\t\t\tif (!skip_prefix(input.buf, commands[i].name, &cmd_end))\n\t\t\t\tcontinue;\n\n\t\t\tcmd = &commands[i];\n\t\t\tif (cmd->takes_args) {\n\t\t\t\tif (*cmd_end != ' ')\n\t\t\t\t\tdie(_(\"%s requires arguments\"),\n\t\t\t\t\t    commands[i].name);\n\n\t\t\t\tp = cmd_end + 1;\n\t\t\t} else if (*cmd_end) {\n\t\t\t\tdie(_(\"%s takes no arguments\"),\n\t\t\t\t    commands[i].name);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!cmd)\n\t\t\tdie(_(\"unknown command: '%s'\"), input.buf);\n\n\t\tif (!strcmp(cmd->name, \"flush\")) {\n\t\t\tdispatch_calls(opt, output, data, queued_cmd, nr);\n\t\t\tfree_cmds(queued_cmd, &nr);\n\t\t} else if (!opt->buffer_output) {\n\t\t\tcmd->fn(opt, p, output, data);\n\t\t} else {\n\t\t\tALLOC_GROW(queued_cmd, nr + 1, alloc);\n\t\t\tcall.fn = cmd->fn;\n\t\t\tcall.line = xstrdup_or_null(p);\n\t\t\tqueued_cmd[nr++] = call;\n\t\t}\n\t}\n\n\tif (opt->buffer_output &&\n\t    nr &&\n\t    !git_env_bool(\"GIT_TEST_CAT_FILE_NO_FLUSH_ON_EXIT\", 0)) {\n\t\tdispatch_calls(opt, output, data, queued_cmd, nr);\n\t\tfree_cmds(queued_cmd, &nr);\n\t}\n\n\tfree_cmds(queued_cmd, &nr);\n\tfree(queued_cmd);\n\tstrbuf_release(&input);\n}\n\n#define DEFAULT_FORMAT \"%(objectname) %(objecttype) %(objectsize)\"\n\nstatic int batch_objects(struct batch_options *opt)\n{\n\tstruct strbuf input = STRBUF_INIT;\n\tstruct strbuf output = STRBUF_INIT;\n\tstruct expand_data data;\n\tint save_warning;\n\tint retval = 0;\n\n\t/*\n\t * Expand once with our special mark_query flag, which will prime the\n\t * object_info to be handed to oid_object_info_extended for each\n\t * object.\n\t */\n\tmemset(&data, 0, sizeof(data));\n\tdata.mark_query = 1;\n\tstrbuf_expand(&output,\n\t\t      opt->format ? opt->format : DEFAULT_FORMAT,\n\t\t      expand_format,\n\t\t      &data);\n\tdata.mark_query = 0;\n\tstrbuf_release(&output);\n\tif (opt->transform_mode)\n\t\tdata.split_on_whitespace = 1;\n\n\tif (opt->format && !strcmp(opt->format, DEFAULT_FORMAT))\n\t\topt->format = NULL;\n\t/*\n\t * If we are printing out the object, then always fill in the type,\n\t * since we will want to decide whether or not to stream.\n\t */\n\tif (opt->batch_mode == BATCH_MODE_CONTENTS)\n\t\tdata.info.typep = &data.type;\n\n\tif (opt->all_objects) {\n\t\tstruct object_cb_data cb;\n\t\tstruct object_info empty = OBJECT_INFO_INIT;\n\n\t\tif (!memcmp(&data.info, &empty, sizeof(empty)))\n\t\t\tdata.skip_object_info = 1;\n\n\t\tif (repo_has_promisor_remote(the_repository))\n\t\t\twarning(\"This repository uses promisor remotes. Some objects may not be loaded.\");\n\n\t\tread_replace_refs = 0;\n\n\t\tcb.opt = opt;\n\t\tcb.expand = &data;\n\t\tcb.scratch = &output;\n\n\t\tif (opt->unordered) {\n\t\t\tstruct oidset seen = OIDSET_INIT;\n\n\t\t\tcb.seen = &seen;\n\n\t\t\tfor_each_loose_object(batch_unordered_loose, &cb, 0);\n\t\t\tfor_each_packed_object(batch_unordered_packed, &cb,\n\t\t\t\t\t       FOR_EACH_OBJECT_PACK_ORDER);\n\n\t\t\toidset_clear(&seen);\n\t\t} else {\n\t\t\tstruct oid_array sa = OID_ARRAY_INIT;\n\n\t\t\tfor_each_loose_object(collect_loose_object, &sa, 0);\n\t\t\tfor_each_packed_object(collect_packed_object, &sa, 0);\n\n\t\t\toid_array_for_each_unique(&sa, batch_object_cb, &cb);\n\n\t\t\toid_array_clear(&sa);\n\t\t}\n\n\t\tstrbuf_release(&output);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We are going to call get_sha1 on a potentially very large number of\n\t * objects. In most large cases, these will be actual object sha1s. The\n\t * cost to double-check that each one is not also a ref (just so we can\n\t * warn) ends up dwarfing the actual cost of the object lookups\n\t * themselves. We can work around it by just turning off the warning.\n\t */\n\tsave_warning = warn_on_object_refname_ambiguity;\n\twarn_on_object_refname_ambiguity = 0;\n\n\tif (opt->batch_mode == BATCH_MODE_QUEUE_AND_DISPATCH) {\n\t\tbatch_objects_command(opt, &output, &data);\n\t\tgoto cleanup;\n\t}\n\n\twhile (strbuf_getdelim_strip_crlf(&input, stdin, opt->input_delim) != EOF) {\n\t\tif (data.split_on_whitespace) {\n\t\t\t/*\n\t\t\t * Split at first whitespace, tying off the beginning\n\t\t\t * of the string and saving the remainder (or NULL) in\n\t\t\t * data.rest.\n\t\t\t */\n\t\t\tchar *p = strpbrk(input.buf, \" \\t\");\n\t\t\tif (p) {\n\t\t\t\twhile (*p && strchr(\" \\t\", *p))\n\t\t\t\t\t*p++ = '\\0';\n\t\t\t}\n\t\t\tdata.rest = p;\n\t\t}\n\n\t\tbatch_one_object(input.buf, &output, opt, &data);\n\t}\n\n cleanup:\n\tstrbuf_release(&input);\n\tstrbuf_release(&output);\n\twarn_on_object_refname_ambiguity = save_warning;\n\treturn retval;\n}\n\nstatic int git_cat_file_config(const char *var, const char *value, void *cb)\n{\n\tif (userdiff_config(var, value) < 0)\n\t\treturn -1;\n\n\treturn git_default_config(var, value, cb);\n}\n\nstatic int batch_option_callback(const struct option *opt,\n\t\t\t\t const char *arg,\n\t\t\t\t int unset)\n{\n\tstruct batch_options *bo = opt->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tif (bo->enabled) {\n\t\treturn error(_(\"only one batch option may be specified\"));\n\t}\n\n\tbo->enabled = 1;\n\n\tif (!strcmp(opt->long_name, \"batch\"))\n\t\tbo->batch_mode = BATCH_MODE_CONTENTS;\n\telse if (!strcmp(opt->long_name, \"batch-check\"))\n\t\tbo->batch_mode = BATCH_MODE_INFO;\n\telse if (!strcmp(opt->long_name, \"batch-command\"))\n\t\tbo->batch_mode = BATCH_MODE_QUEUE_AND_DISPATCH;\n\telse\n\t\tBUG(\"%s given to batch-option-callback\", opt->long_name);\n\n\tbo->format = arg;\n\n\treturn 0;\n}\n\nint cmd_cat_file(int argc, const char **argv, const char *prefix)\n{\n\tint opt = 0;\n\tint opt_cw = 0;\n\tint opt_epts = 0;\n\tconst char *exp_type = NULL, *obj_name = NULL;\n\tstruct batch_options batch = {0};\n\tint unknown_type = 0;\n\tint input_nul_terminated = 0;\n\n\tconst char * const usage[] = {\n\t\tN_(\"git cat-file <type> <object>\"),\n\t\tN_(\"git cat-file (-e | -p) <object>\"),\n\t\tN_(\"git cat-file (-t | -s) [--allow-unknown-type] <object>\"),\n\t\tN_(\"git cat-file (--batch | --batch-check | --batch-command) [--batch-all-objects]\\n\"\n\t\t   \"             [--buffer] [--follow-symlinks] [--unordered]\\n\"\n\t\t   \"             [--textconv | --filters] [-z]\"),\n\t\tN_(\"git cat-file (--textconv | --filters)\\n\"\n\t\t   \"             [<rev>:<path|tree-ish> | --path=<path|tree-ish> <rev>]\"),\n\t\tNULL\n\t};\n\tconst struct option options[] = {\n\t\t/* Simple queries */\n\t\tOPT_GROUP(N_(\"Check object existence or emit object contents\")),\n\t\tOPT_CMDMODE('e', NULL, &opt,\n\t\t\t    N_(\"check if <object> exists\"), 'e'),\n\t\tOPT_CMDMODE('p', NULL, &opt, N_(\"pretty-print <object> content\"), 'p'),\n\n\t\tOPT_GROUP(N_(\"Emit [broken] object attributes\")),\n\t\tOPT_CMDMODE('t', NULL, &opt, N_(\"show object type (one of 'blob', 'tree', 'commit', 'tag', ...)\"), 't'),\n\t\tOPT_CMDMODE('s', NULL, &opt, N_(\"show object size\"), 's'),\n\t\tOPT_BOOL(0, \"allow-unknown-type\", &unknown_type,\n\t\t\t  N_(\"allow -s and -t to work with broken/corrupt objects\")),\n\t\tOPT_BOOL(0, \"use-mailmap\", &use_mailmap, N_(\"use mail map file\")),\n\t\tOPT_ALIAS(0, \"mailmap\", \"use-mailmap\"),\n\t\t/* Batch mode */\n\t\tOPT_GROUP(N_(\"Batch objects requested on stdin (or --batch-all-objects)\")),\n\t\tOPT_CALLBACK_F(0, \"batch\", &batch, N_(\"format\"),\n\t\t\tN_(\"show full <object> or <rev> contents\"),\n\t\t\tPARSE_OPT_OPTARG | PARSE_OPT_NONEG,\n\t\t\tbatch_option_callback),\n\t\tOPT_CALLBACK_F(0, \"batch-check\", &batch, N_(\"format\"),\n\t\t\tN_(\"like --batch, but don't emit <contents>\"),\n\t\t\tPARSE_OPT_OPTARG | PARSE_OPT_NONEG,\n\t\t\tbatch_option_callback),\n\t\tOPT_BOOL('z', NULL, &input_nul_terminated, N_(\"stdin is NUL-terminated\")),\n\t\tOPT_CALLBACK_F(0, \"batch-command\", &batch, N_(\"format\"),\n\t\t\tN_(\"read commands from stdin\"),\n\t\t\tPARSE_OPT_OPTARG | PARSE_OPT_NONEG,\n\t\t\tbatch_option_callback),\n\t\tOPT_CMDMODE(0, \"batch-all-objects\", &opt,\n\t\t\t    N_(\"with --batch[-check]: ignores stdin, batches all known objects\"), 'b'),\n\t\t/* Batch-specific options */\n\t\tOPT_GROUP(N_(\"Change or optimize batch output\")),\n\t\tOPT_BOOL(0, \"buffer\", &batch.buffer_output, N_(\"buffer --batch output\")),\n\t\tOPT_BOOL(0, \"follow-symlinks\", &batch.follow_symlinks,\n\t\t\t N_(\"follow in-tree symlinks\")),\n\t\tOPT_BOOL(0, \"unordered\", &batch.unordered,\n\t\t\t N_(\"do not order objects before emitting them\")),\n\t\t/* Textconv options, stand-ole*/\n\t\tOPT_GROUP(N_(\"Emit object (blob or tree) with conversion or filter (stand-alone, or with batch)\")),\n\t\tOPT_CMDMODE(0, \"textconv\", &opt,\n\t\t\t    N_(\"run textconv on object's content\"), 'c'),\n\t\tOPT_CMDMODE(0, \"filters\", &opt,\n\t\t\t    N_(\"run filters on object's content\"), 'w'),\n\t\tOPT_STRING(0, \"path\", &force_path, N_(\"blob|tree\"),\n\t\t\t   N_(\"use a <path> for (--textconv | --filters); Not with 'batch'\")),\n\t\tOPT_END()\n\t};\n\n\tgit_config(git_cat_file_config, NULL);\n\n\tbatch.buffer_output = -1;\n\n\targc = parse_options(argc, argv, prefix, options, usage, 0);\n\topt_cw = (opt == 'c' || opt == 'w');\n\topt_epts = (opt == 'e' || opt == 'p' || opt == 't' || opt == 's');\n\n\tif (use_mailmap)\n\t\tread_mailmap(&mailmap);\n\n\t/* --batch-all-objects? */\n\tif (opt == 'b')\n\t\tbatch.all_objects = 1;\n\n\t/* Option compatibility */\n\tif (force_path && !opt_cw)\n\t\tusage_msg_optf(_(\"'%s=<%s>' needs '%s' or '%s'\"),\n\t\t\t       usage, options,\n\t\t\t       \"--path\", _(\"path|tree-ish\"), \"--filters\",\n\t\t\t       \"--textconv\");\n\n\t/* Option compatibility with batch mode */\n\tif (batch.enabled)\n\t\t;\n\telse if (batch.follow_symlinks)\n\t\tusage_msg_optf(_(\"'%s' requires a batch mode\"), usage, options,\n\t\t\t       \"--follow-symlinks\");\n\telse if (batch.buffer_output >= 0)\n\t\tusage_msg_optf(_(\"'%s' requires a batch mode\"), usage, options,\n\t\t\t       \"--buffer\");\n\telse if (batch.all_objects)\n\t\tusage_msg_optf(_(\"'%s' requires a batch mode\"), usage, options,\n\t\t\t       \"--batch-all-objects\");\n\telse if (input_nul_terminated)\n\t\tusage_msg_optf(_(\"'%s' requires a batch mode\"), usage, options,\n\t\t\t       \"-z\");\n\n\tbatch.input_delim = input_nul_terminated ? '\\0' : '\\n';\n\n\t/* Batch defaults */\n\tif (batch.buffer_output < 0)\n\t\tbatch.buffer_output = batch.all_objects;\n\n\t/* Return early if we're in batch mode? */\n\tif (batch.enabled) {\n\t\tif (opt_cw)\n\t\t\tbatch.transform_mode = opt;\n\t\telse if (opt && opt != 'b')\n\t\t\tusage_msg_optf(_(\"'-%c' is incompatible with batch mode\"),\n\t\t\t\t       usage, options, opt);\n\t\telse if (argc)\n\t\t\tusage_msg_opt(_(\"batch modes take no arguments\"), usage,\n\t\t\t\t      options);\n\n\t\treturn batch_objects(&batch);\n\t}\n\n\tif (opt) {\n\t\tif (!argc && opt == 'c')\n\t\t\tusage_msg_optf(_(\"<rev> required with '%s'\"),\n\t\t\t\t       usage, options, \"--textconv\");\n\t\telse if (!argc && opt == 'w')\n\t\t\tusage_msg_optf(_(\"<rev> required with '%s'\"),\n\t\t\t\t       usage, options, \"--filters\");\n\t\telse if (!argc && opt_epts)\n\t\t\tusage_msg_optf(_(\"<object> required with '-%c'\"),\n\t\t\t\t       usage, options, opt);\n\t\telse if (argc == 1)\n\t\t\tobj_name = argv[0];\n\t\telse\n\t\t\tusage_msg_opt(_(\"too many arguments\"), usage, options);\n\t} else if (!argc) {\n\t\tusage_with_options(usage, options);\n\t} else if (argc != 2) {\n\t\tusage_msg_optf(_(\"only two arguments allowed in <type> <object> mode, not %d\"),\n\t\t\t      usage, options, argc);\n\t} else if (argc) {\n\t\texp_type = argv[0];\n\t\tobj_name = argv[1];\n\t}\n\n\tif (unknown_type && opt != 't' && opt != 's')\n\t\tdie(\"git cat-file --allow-unknown-type: use with -s or -t\");\n\treturn cat_one_file(opt, exp_type, obj_name, unknown_type);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "001dcb24d68c6d0eb140130ad8460d24ced07942",
  "sha1_ok": true,
  "size": 27984
}
