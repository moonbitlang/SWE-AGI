{
  "content": {
    "base64": "LyoKICogSGVhZGVyIHVzZWQgdG8gYWRhcHQgcHRocmVhZC1iYXNlZCBQT1NJWCBjb2RlIHRvIFdpbmRvd3MgQVBJIHRocmVhZHMuCiAqCiAqIENvcHlyaWdodCAoQykgMjAwOSBBbmRyemVqIEsuIEhhY3pld3NraSA8YWhhY3pld3NraUBnbWFpbC5jb20+CiAqLwoKI2lmbmRlZiBQVEhSRUFEX0gKI2RlZmluZSBQVEhSRUFEX0gKCiNpZm5kZWYgV0lOMzJfTEVBTl9BTkRfTUVBTgojZGVmaW5lIFdJTjMyX0xFQU5fQU5EX01FQU4KI2VuZGlmCgojaW5jbHVkZSA8d2luZG93cy5oPgoKLyoKICogRGVmaW5lcyB0aGF0IGFkYXB0IFdpbmRvd3MgQVBJIHRocmVhZHMgdG8gcHRocmVhZHMgQVBJCiAqLwojZGVmaW5lIHB0aHJlYWRfbXV0ZXhfdCBDUklUSUNBTF9TRUNUSU9OCgpzdGF0aWMgaW5saW5lIGludCByZXR1cm5fMChpbnQgaSBVTlVTRUQpIHsKCXJldHVybiAwOwp9CiNkZWZpbmUgcHRocmVhZF9tdXRleF9pbml0KGEsYikgcmV0dXJuXzAoKEluaXRpYWxpemVDcml0aWNhbFNlY3Rpb24oKGEpKSwgMCkpCiNkZWZpbmUgcHRocmVhZF9tdXRleF9kZXN0cm95KGEpIERlbGV0ZUNyaXRpY2FsU2VjdGlvbigoYSkpCiNkZWZpbmUgcHRocmVhZF9tdXRleF9sb2NrIEVudGVyQ3JpdGljYWxTZWN0aW9uCiNkZWZpbmUgcHRocmVhZF9tdXRleF91bmxvY2sgTGVhdmVDcml0aWNhbFNlY3Rpb24KCnR5cGVkZWYgaW50IHB0aHJlYWRfbXV0ZXhhdHRyX3Q7CiNkZWZpbmUgcHRocmVhZF9tdXRleGF0dHJfaW5pdChhKSAoKihhKSA9IDApCiNkZWZpbmUgcHRocmVhZF9tdXRleGF0dHJfZGVzdHJveShhKSBkbyB7fSB3aGlsZSAoMCkKI2RlZmluZSBwdGhyZWFkX211dGV4YXR0cl9zZXR0eXBlKGEsIHQpIDAKI2RlZmluZSBQVEhSRUFEX01VVEVYX1JFQ1VSU0lWRSAwCgojZGVmaW5lIHB0aHJlYWRfY29uZF90IENPTkRJVElPTl9WQVJJQUJMRQoKI2RlZmluZSBwdGhyZWFkX2NvbmRfaW5pdChhLGIpIHJldHVybl8wKChJbml0aWFsaXplQ29uZGl0aW9uVmFyaWFibGUoKGEpKSwgMCkpCiNkZWZpbmUgcHRocmVhZF9jb25kX2Rlc3Ryb3koYSkgZG8ge30gd2hpbGUgKDApCiNkZWZpbmUgcHRocmVhZF9jb25kX3dhaXQoYSxiKSByZXR1cm5fMChTbGVlcENvbmRpdGlvblZhcmlhYmxlQ1MoKGEpLCAoYiksIElORklOSVRFKSkKI2RlZmluZSBwdGhyZWFkX2NvbmRfc2lnbmFsIFdha2VDb25kaXRpb25WYXJpYWJsZQojZGVmaW5lIHB0aHJlYWRfY29uZF9icm9hZGNhc3QgV2FrZUFsbENvbmRpdGlvblZhcmlhYmxlCgovKgogKiBTaW1wbGUgdGhyZWFkIGNyZWF0aW9uIGltcGxlbWVudGF0aW9uIHVzaW5nIHB0aHJlYWQgQVBJCiAqLwp0eXBlZGVmIHN0cnVjdCB7CglIQU5ETEUgaGFuZGxlOwoJdm9pZCAqKCpzdGFydF9yb3V0aW5lKSh2b2lkKik7Cgl2b2lkICphcmc7CglEV09SRCB0aWQ7Cn0gcHRocmVhZF90OwoKaW50IHB0aHJlYWRfY3JlYXRlKHB0aHJlYWRfdCAqdGhyZWFkLCBjb25zdCB2b2lkICp1bnVzZWQsCgkJICAgdm9pZCAqKCpzdGFydF9yb3V0aW5lKSh2b2lkKiksIHZvaWQgKmFyZyk7CgovKgogKiBUbyBhdm9pZCB0aGUgbmVlZCBvZiBjb3B5aW5nIGEgc3RydWN0LCB3ZSB1c2Ugc21hbGwgbWFjcm8gd3JhcHBlciB0byBwYXNzCiAqIHBvaW50ZXIgdG8gd2luMzJfcHRocmVhZF9qb2luIGluc3RlYWQuCiAqLwojZGVmaW5lIHB0aHJlYWRfam9pbihhLCBiKSB3aW4zMl9wdGhyZWFkX2pvaW4oJihhKSwgKGIpKQoKaW50IHdpbjMyX3B0aHJlYWRfam9pbihwdGhyZWFkX3QgKnRocmVhZCwgdm9pZCAqKnZhbHVlX3B0cik7CgojZGVmaW5lIHB0aHJlYWRfZXF1YWwodDEsIHQyKSAoKHQxKS50aWQgPT0gKHQyKS50aWQpCnB0aHJlYWRfdCBwdGhyZWFkX3NlbGYodm9pZCk7CgpzdGF0aWMgaW5saW5lIHZvaWQgTk9SRVRVUk4gcHRocmVhZF9leGl0KHZvaWQgKnJldCkKewoJX2VuZHRocmVhZGV4KCh1bnNpZ25lZCkodWludHB0cl90KXJldCk7Cn0KCnR5cGVkZWYgRFdPUkQgcHRocmVhZF9rZXlfdDsKc3RhdGljIGlubGluZSBpbnQgcHRocmVhZF9rZXlfY3JlYXRlKHB0aHJlYWRfa2V5X3QgKmtleXAsIHZvaWQgKCpkZXN0cnVjdG9yKSh2b2lkICp2YWx1ZSkgVU5VU0VEKQp7CglyZXR1cm4gKCprZXlwID0gVGxzQWxsb2MoKSkgPT0gVExTX09VVF9PRl9JTkRFWEVTID8gRUFHQUlOIDogMDsKfQoKc3RhdGljIGlubGluZSBpbnQgcHRocmVhZF9rZXlfZGVsZXRlKHB0aHJlYWRfa2V5X3Qga2V5KQp7CglyZXR1cm4gVGxzRnJlZShrZXkpID8gMCA6IEVJTlZBTDsKfQoKc3RhdGljIGlubGluZSBpbnQgcHRocmVhZF9zZXRzcGVjaWZpYyhwdGhyZWFkX2tleV90IGtleSwgY29uc3Qgdm9pZCAqdmFsdWUpCnsKCXJldHVybiBUbHNTZXRWYWx1ZShrZXksICh2b2lkICopdmFsdWUpID8gMCA6IEVJTlZBTDsKfQoKc3RhdGljIGlubGluZSB2b2lkICpwdGhyZWFkX2dldHNwZWNpZmljKHB0aHJlYWRfa2V5X3Qga2V5KQp7CglyZXR1cm4gVGxzR2V0VmFsdWUoa2V5KTsKfQoKI2lmbmRlZiBfX01JTkdXNjRfVkVSU0lPTl9NQUpPUgpzdGF0aWMgaW5saW5lIGludCBwdGhyZWFkX3NpZ21hc2soaW50IGhvdywgY29uc3Qgc2lnc2V0X3QgKnNldCwgc2lnc2V0X3QgKm9zZXQpCnsKCXJldHVybiAwOwp9CiNlbmRpZgoKI2VuZGlmIC8qIFBUSFJFQURfSCAqLwo=",
    "text": "/*\n * Header used to adapt pthread-based POSIX code to Windows API threads.\n *\n * Copyright (C) 2009 Andrzej K. Haczewski <ahaczewski@gmail.com>\n */\n\n#ifndef PTHREAD_H\n#define PTHREAD_H\n\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n\n#include <windows.h>\n\n/*\n * Defines that adapt Windows API threads to pthreads API\n */\n#define pthread_mutex_t CRITICAL_SECTION\n\nstatic inline int return_0(int i UNUSED) {\n\treturn 0;\n}\n#define pthread_mutex_init(a,b) return_0((InitializeCriticalSection((a)), 0))\n#define pthread_mutex_destroy(a) DeleteCriticalSection((a))\n#define pthread_mutex_lock EnterCriticalSection\n#define pthread_mutex_unlock LeaveCriticalSection\n\ntypedef int pthread_mutexattr_t;\n#define pthread_mutexattr_init(a) (*(a) = 0)\n#define pthread_mutexattr_destroy(a) do {} while (0)\n#define pthread_mutexattr_settype(a, t) 0\n#define PTHREAD_MUTEX_RECURSIVE 0\n\n#define pthread_cond_t CONDITION_VARIABLE\n\n#define pthread_cond_init(a,b) return_0((InitializeConditionVariable((a)), 0))\n#define pthread_cond_destroy(a) do {} while (0)\n#define pthread_cond_wait(a,b) return_0(SleepConditionVariableCS((a), (b), INFINITE))\n#define pthread_cond_signal WakeConditionVariable\n#define pthread_cond_broadcast WakeAllConditionVariable\n\n/*\n * Simple thread creation implementation using pthread API\n */\ntypedef struct {\n\tHANDLE handle;\n\tvoid *(*start_routine)(void*);\n\tvoid *arg;\n\tDWORD tid;\n} pthread_t;\n\nint pthread_create(pthread_t *thread, const void *unused,\n\t\t   void *(*start_routine)(void*), void *arg);\n\n/*\n * To avoid the need of copying a struct, we use small macro wrapper to pass\n * pointer to win32_pthread_join instead.\n */\n#define pthread_join(a, b) win32_pthread_join(&(a), (b))\n\nint win32_pthread_join(pthread_t *thread, void **value_ptr);\n\n#define pthread_equal(t1, t2) ((t1).tid == (t2).tid)\npthread_t pthread_self(void);\n\nstatic inline void NORETURN pthread_exit(void *ret)\n{\n\t_endthreadex((unsigned)(uintptr_t)ret);\n}\n\ntypedef DWORD pthread_key_t;\nstatic inline int pthread_key_create(pthread_key_t *keyp, void (*destructor)(void *value) UNUSED)\n{\n\treturn (*keyp = TlsAlloc()) == TLS_OUT_OF_INDEXES ? EAGAIN : 0;\n}\n\nstatic inline int pthread_key_delete(pthread_key_t key)\n{\n\treturn TlsFree(key) ? 0 : EINVAL;\n}\n\nstatic inline int pthread_setspecific(pthread_key_t key, const void *value)\n{\n\treturn TlsSetValue(key, (void *)value) ? 0 : EINVAL;\n}\n\nstatic inline void *pthread_getspecific(pthread_key_t key)\n{\n\treturn TlsGetValue(key);\n}\n\n#ifndef __MINGW64_VERSION_MAJOR\nstatic inline int pthread_sigmask(int how, const sigset_t *set, sigset_t *oset)\n{\n\treturn 0;\n}\n#endif\n\n#endif /* PTHREAD_H */\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "000604cdf69ffcc8efd34a3482970c5b60082b55",
  "sha1_ok": false,
  "size": 2624
}
