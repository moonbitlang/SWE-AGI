{
  "content": {
    "base64": "I2lmbmRlZiBDQUNIRV9ICiNkZWZpbmUgQ0FDSEVfSAoKI2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAic3RyYnVmLmgiCiNpbmNsdWRlICJoYXNoLmgiCiNpbmNsdWRlICJhZHZpY2UuaCIKI2luY2x1ZGUgImdldHRleHQuaCIKI2luY2x1ZGUgImNvbnZlcnQuaCIKCiNpbmNsdWRlIFNIQTFfSEVBREVSCiNpZm5kZWYgZ2l0X1NIQV9DVFgKI2RlZmluZSBnaXRfU0hBX0NUWAlTSEFfQ1RYCiNkZWZpbmUgZ2l0X1NIQTFfSW5pdAlTSEExX0luaXQKI2RlZmluZSBnaXRfU0hBMV9VcGRhdGUJU0hBMV9VcGRhdGUKI2RlZmluZSBnaXRfU0hBMV9GaW5hbAlTSEExX0ZpbmFsCiNlbmRpZgoKI2luY2x1ZGUgPHpsaWIuaD4KdHlwZWRlZiBzdHJ1Y3QgZ2l0X3pzdHJlYW0gewoJel9zdHJlYW0gejsKCXVuc2lnbmVkIGxvbmcgYXZhaWxfaW47Cgl1bnNpZ25lZCBsb25nIGF2YWlsX291dDsKCXVuc2lnbmVkIGxvbmcgdG90YWxfaW47Cgl1bnNpZ25lZCBsb25nIHRvdGFsX291dDsKCXVuc2lnbmVkIGNoYXIgKm5leHRfaW47Cgl1bnNpZ25lZCBjaGFyICpuZXh0X291dDsKfSBnaXRfenN0cmVhbTsKCnZvaWQgZ2l0X2luZmxhdGVfaW5pdChnaXRfenN0cmVhbSAqKTsKdm9pZCBnaXRfaW5mbGF0ZV9pbml0X2d6aXBfb25seShnaXRfenN0cmVhbSAqKTsKdm9pZCBnaXRfaW5mbGF0ZV9lbmQoZ2l0X3pzdHJlYW0gKik7CmludCBnaXRfaW5mbGF0ZShnaXRfenN0cmVhbSAqLCBpbnQgZmx1c2gpOwoKdm9pZCBnaXRfZGVmbGF0ZV9pbml0KGdpdF96c3RyZWFtICosIGludCBsZXZlbCk7CnZvaWQgZ2l0X2RlZmxhdGVfaW5pdF9nemlwKGdpdF96c3RyZWFtICosIGludCBsZXZlbCk7CnZvaWQgZ2l0X2RlZmxhdGVfaW5pdF9yYXcoZ2l0X3pzdHJlYW0gKiwgaW50IGxldmVsKTsKdm9pZCBnaXRfZGVmbGF0ZV9lbmQoZ2l0X3pzdHJlYW0gKik7CmludCBnaXRfZGVmbGF0ZV9hYm9ydChnaXRfenN0cmVhbSAqKTsKaW50IGdpdF9kZWZsYXRlX2VuZF9nZW50bHkoZ2l0X3pzdHJlYW0gKik7CmludCBnaXRfZGVmbGF0ZShnaXRfenN0cmVhbSAqLCBpbnQgZmx1c2gpOwp1bnNpZ25lZCBsb25nIGdpdF9kZWZsYXRlX2JvdW5kKGdpdF96c3RyZWFtICosIHVuc2lnbmVkIGxvbmcpOwoKI2lmIGRlZmluZWQoRFRfVU5LTk9XTikgJiYgIWRlZmluZWQoTk9fRF9UWVBFX0lOX0RJUkVOVCkKI2RlZmluZSBEVFlQRShkZSkJKChkZSktPmRfdHlwZSkKI2Vsc2UKI3VuZGVmIERUX1VOS05PV04KI3VuZGVmIERUX0RJUgojdW5kZWYgRFRfUkVHCiN1bmRlZiBEVF9MTksKI2RlZmluZSBEVF9VTktOT1dOCTAKI2RlZmluZSBEVF9ESVIJCTEKI2RlZmluZSBEVF9SRUcJCTIKI2RlZmluZSBEVF9MTksJCTMKI2RlZmluZSBEVFlQRShkZSkJRFRfVU5LTk9XTgojZW5kaWYKCi8qIHVua25vd24gbW9kZSAoaW1wb3NzaWJsZSBjb21iaW5hdGlvbiBTX0lGSUZPfFNfSUZDSFIpICovCiNkZWZpbmUgU19JRklOVkFMSUQgICAgIDAwMzAwMDAKCi8qCiAqIEEgImRpcmVjdG9yeSBsaW5rIiBpcyBhIGxpbmsgdG8gYW5vdGhlciBnaXQgZGlyZWN0b3J5LgogKgogKiBUaGUgdmFsdWUgMDE2MDAwMCBpcyBub3Qgbm9ybWFsbHkgYSB2YWxpZCBtb2RlLCBhbmQKICogYWxzbyBqdXN0IGhhcHBlbnMgdG8gYmUgU19JRkRJUiArIFNfSUZMTksKICoKICogTk9URSEgV2UgKnJlYWxseSogc2hvdWxkbid0IGRlcGVuZCBvbiB0aGUgU19JRnh4eCBtYWNyb3MKICogYWx3YXlzIGhhdmluZyB0aGUgc2FtZSB2YWx1ZXMgZXZlcnl3aGVyZS4gV2Ugc2hvdWxkIHVzZQogKiBvdXIgaW50ZXJuYWwgZ2l0IHZhbHVlcyBmb3IgdGhlc2UgdGhpbmdzLCBhbmQgdGhlbiB3ZSBjYW4KICogdHJhbnNsYXRlIHRoYXQgdG8gdGhlIE9TLXNwZWNpZmljIHZhbHVlLiBJdCBqdXN0IHNvCiAqIGhhcHBlbnMgdGhhdCBldmVyeWJvZHkgc2hhcmVzIHRoZSBzYW1lIGJpdCByZXByZXNlbnRhdGlvbgogKiBpbiB0aGUgVU5JWCB3b3JsZCAoYW5kIGFwcGFyZW50bHkgd2lkZXIgdG9vLi4pCiAqLwojZGVmaW5lIFNfSUZHSVRMSU5LCTAxNjAwMDAKI2RlZmluZSBTX0lTR0lUTElOSyhtKQkoKChtKSAmIFNfSUZNVCkgPT0gU19JRkdJVExJTkspCgovKgogKiBJbnRlbnNpdmUgcmVzZWFyY2ggb3ZlciB0aGUgY291cnNlIG9mIG1hbnkgeWVhcnMgaGFzIHNob3duIHRoYXQKICogcG9ydCA5NDE4IGlzIHRvdGFsbHkgdW51c2VkIGJ5IGFueXRoaW5nIGVsc2UuIE9yCiAqCiAqCVlvdXIgc2VhcmNoIC0gInBvcnQgOTQxOCIgLSBkaWQgbm90IG1hdGNoIGFueSBkb2N1bWVudHMuCiAqCiAqIGFzIHd3dy5nb29nbGUuY29tIHB1dHMgaXQuCiAqCiAqIFRoaXMgcG9ydCBoYXMgYmVlbiBwcm9wZXJseSBhc3NpZ25lZCBmb3IgZ2l0IHVzZSBieSBJQU5BOgogKiBnaXQgKEFzc2lnbmVkLTk0MTgpIFtJMDYtMDUwNzI4LTAwMDFdLgogKgogKglnaXQgIDk0MTgvdGNwICAgZ2l0IHBhY2sgdHJhbnNmZXIgc2VydmljZQogKglnaXQgIDk0MTgvdWRwICAgZ2l0IHBhY2sgdHJhbnNmZXIgc2VydmljZQogKgogKiB3aXRoIExpbnVzIFRvcnZhbGRzIDx0b3J2YWxkc0Bvc2RsLm9yZz4gYXMgdGhlIHBvaW50IG9mCiAqIGNvbnRhY3QuIFNlcHRlbWJlciAyMDA1LgogKgogKiBTZWUgaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9wb3J0LW51bWJlcnMKICovCiNkZWZpbmUgREVGQVVMVF9HSVRfUE9SVCA5NDE4CgovKgogKiBCYXNpYyBkYXRhIHN0cnVjdHVyZXMgZm9yIHRoZSBkaXJlY3RvcnkgY2FjaGUKICovCgojZGVmaW5lIENBQ0hFX1NJR05BVFVSRSAweDQ0NDk1MjQzCS8qICJESVJDIiAqLwpzdHJ1Y3QgY2FjaGVfaGVhZGVyIHsKCXVpbnQzMl90IGhkcl9zaWduYXR1cmU7Cgl1aW50MzJfdCBoZHJfdmVyc2lvbjsKCXVpbnQzMl90IGhkcl9lbnRyaWVzOwp9OwoKI2RlZmluZSBJTkRFWF9GT1JNQVRfTEIgMgojZGVmaW5lIElOREVYX0ZPUk1BVF9VQiA0CgovKgogKiBUaGUgImNhY2hlX3RpbWUiIGlzIGp1c3QgdGhlIGxvdyAzMiBiaXRzIG9mIHRoZQogKiB0aW1lLiBJdCBkb2Vzbid0IG1hdHRlciBpZiBpdCBvdmVyZmxvd3MgLSB3ZSBvbmx5CiAqIGNoZWNrIGl0IGZvciBlcXVhbGl0eSBpbiB0aGUgMzIgYml0cyB3ZSBzYXZlLgogKi8Kc3RydWN0IGNhY2hlX3RpbWUgewoJdWludDMyX3Qgc2VjOwoJdWludDMyX3QgbnNlYzsKfTsKCnN0cnVjdCBzdGF0X2RhdGEgewoJc3RydWN0IGNhY2hlX3RpbWUgc2RfY3RpbWU7CglzdHJ1Y3QgY2FjaGVfdGltZSBzZF9tdGltZTsKCXVuc2lnbmVkIGludCBzZF9kZXY7Cgl1bnNpZ25lZCBpbnQgc2RfaW5vOwoJdW5zaWduZWQgaW50IHNkX3VpZDsKCXVuc2lnbmVkIGludCBzZF9naWQ7Cgl1bnNpZ25lZCBpbnQgc2Rfc2l6ZTsKfTsKCnN0cnVjdCBjYWNoZV9lbnRyeSB7CglzdHJ1Y3Qgc3RhdF9kYXRhIGNlX3N0YXRfZGF0YTsKCXVuc2lnbmVkIGludCBjZV9tb2RlOwoJdW5zaWduZWQgaW50IGNlX2ZsYWdzOwoJdW5zaWduZWQgaW50IGNlX25hbWVsZW47Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJc3RydWN0IGNhY2hlX2VudHJ5ICpuZXh0OwoJY2hhciBuYW1lW0ZMRVhfQVJSQVldOyAvKiBtb3JlICovCn07CgojZGVmaW5lIENFX1NUQUdFTUFTSyAoMHgzMDAwKQojZGVmaW5lIENFX0VYVEVOREVEICAoMHg0MDAwKQojZGVmaW5lIENFX1ZBTElEICAgICAoMHg4MDAwKQojZGVmaW5lIENFX1NUQUdFU0hJRlQgMTIKCi8qCiAqIFJhbmdlIDB4RkZGRjAwMDAgaW4gY2VfZmxhZ3MgaXMgZGl2aWRlZCBpbnRvCiAqIHR3byBwYXJ0czogaW4tbWVtb3J5IGZsYWdzIGFuZCBvbi1kaXNrIG9uZXMuCiAqIEZsYWdzIGluIENFX0VYVEVOREVEX0ZMQUdTIHdpbGwgZ2V0IHNhdmVkIG9uLWRpc2sKICogaWYgeW91IHdhbnQgdG8gc2F2ZSBhIG5ldyBmbGFnLCBhZGQgaXQgaW4KICogQ0VfRVhURU5ERURfRkxBR1MKICoKICogSW4tbWVtb3J5IG9ubHkgZmxhZ3MKICovCiNkZWZpbmUgQ0VfVVBEQVRFICAgICAgICAgICAgKDEgPDwgMTYpCiNkZWZpbmUgQ0VfUkVNT1ZFICAgICAgICAgICAgKDEgPDwgMTcpCiNkZWZpbmUgQ0VfVVBUT0RBVEUgICAgICAgICAgKDEgPDwgMTgpCiNkZWZpbmUgQ0VfQURERUQgICAgICAgICAgICAgKDEgPDwgMTkpCgojZGVmaW5lIENFX0hBU0hFRCAgICAgICAgICAgICgxIDw8IDIwKQojZGVmaW5lIENFX1VOSEFTSEVEICAgICAgICAgICgxIDw8IDIxKQojZGVmaW5lIENFX1dUX1JFTU9WRSAgICAgICAgICgxIDw8IDIyKSAvKiByZW1vdmUgaW4gd29yayBkaXJlY3RvcnkgKi8KI2RlZmluZSBDRV9DT05GTElDVEVEICAgICAgICAoMSA8PCAyMykKCiNkZWZpbmUgQ0VfVU5QQUNLRUQgICAgICAgICAgKDEgPDwgMjQpCiNkZWZpbmUgQ0VfTkVXX1NLSVBfV09SS1RSRUUgKDEgPDwgMjUpCgovKiB1c2VkIHRvIHRlbXBvcmFyaWx5IG1hcmsgcGF0aHMgbWF0Y2hlZCBieSBwYXRoc3BlY3MgKi8KI2RlZmluZSBDRV9NQVRDSEVEICAgICAgICAgICAoMSA8PCAyNikKCi8qCiAqIEV4dGVuZGVkIG9uLWRpc2sgZmxhZ3MKICovCiNkZWZpbmUgQ0VfSU5URU5UX1RPX0FERCAgICAgKDEgPDwgMjkpCiNkZWZpbmUgQ0VfU0tJUF9XT1JLVFJFRSAgICAgKDEgPDwgMzApCi8qIENFX0VYVEVOREVEMiBpcyBmb3IgZnV0dXJlIGV4dGVuc2lvbiAqLwojZGVmaW5lIENFX0VYVEVOREVEMiAgICAgICAgICgxIDw8IDMxKQoKI2RlZmluZSBDRV9FWFRFTkRFRF9GTEFHUyAoQ0VfSU5URU5UX1RPX0FERCB8IENFX1NLSVBfV09SS1RSRUUpCgovKgogKiBTYWZlZ3VhcmQgdG8gYXZvaWQgc2F2aW5nIHdyb25nIGZsYWdzOgogKiAgLSBDRV9FWFRFTkRFRDIgd29uJ3QgZ2V0IHNhdmVkIHVudGlsIGl0cyBzZW1hbnRpYyBpcyBrbm93bgogKiAgLSBCaXRzIGluIDB4MDAwMEZGRkYgaGF2ZSBiZWVuIHNhdmVkIGluIGNlX2ZsYWdzIGFscmVhZHkKICogIC0gQml0cyBpbiAweDAwM0YwMDAwIGFyZSBjdXJyZW50bHkgaW4tbWVtb3J5IGZsYWdzCiAqLwojaWYgQ0VfRVhURU5ERURfRkxBR1MgJiAweDgwM0ZGRkZGCiNlcnJvciAiQ0VfRVhURU5ERURfRkxBR1Mgb3V0IG9mIHJhbmdlIgojZW5kaWYKCnN0cnVjdCBwYXRoc3BlYzsKCi8qCiAqIENvcHkgdGhlIHNoYTEgYW5kIHN0YXQgc3RhdGUgb2YgYSBjYWNoZSBlbnRyeSBmcm9tIG9uZSB0bwogKiBhbm90aGVyLiBCdXQgd2UgbmV2ZXIgY2hhbmdlIHRoZSBuYW1lLCBvciB0aGUgaGFzaCBzdGF0ZSEKICovCiNkZWZpbmUgQ0VfU1RBVEVfTUFTSyAoQ0VfSEFTSEVEIHwgQ0VfVU5IQVNIRUQpCnN0YXRpYyBpbmxpbmUgdm9pZCBjb3B5X2NhY2hlX2VudHJ5KHN0cnVjdCBjYWNoZV9lbnRyeSAqZHN0LAoJCQkJICAgIGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqc3JjKQp7Cgl1bnNpZ25lZCBpbnQgc3RhdGUgPSBkc3QtPmNlX2ZsYWdzICYgQ0VfU1RBVEVfTUFTSzsKCgkvKiBEb24ndCBjb3B5IGhhc2ggY2hhaW4gYW5kIG5hbWUgKi8KCW1lbWNweShkc3QsIHNyYywgb2Zmc2V0b2Yoc3RydWN0IGNhY2hlX2VudHJ5LCBuZXh0KSk7CgoJLyogUmVzdG9yZSB0aGUgaGFzaCBzdGF0ZSAqLwoJZHN0LT5jZV9mbGFncyA9IChkc3QtPmNlX2ZsYWdzICYgfkNFX1NUQVRFX01BU0spIHwgc3RhdGU7Cn0KCnN0YXRpYyBpbmxpbmUgdW5zaWduZWQgY3JlYXRlX2NlX2ZsYWdzKHVuc2lnbmVkIHN0YWdlKQp7CglyZXR1cm4gKHN0YWdlIDw8IENFX1NUQUdFU0hJRlQpOwp9CgojZGVmaW5lIGNlX25hbWVsZW4oY2UpICgoY2UpLT5jZV9uYW1lbGVuKQojZGVmaW5lIGNlX3NpemUoY2UpIGNhY2hlX2VudHJ5X3NpemUoY2VfbmFtZWxlbihjZSkpCiNkZWZpbmUgY2Vfc3RhZ2UoY2UpICgoQ0VfU1RBR0VNQVNLICYgKGNlKS0+Y2VfZmxhZ3MpID4+IENFX1NUQUdFU0hJRlQpCiNkZWZpbmUgY2VfdXB0b2RhdGUoY2UpICgoY2UpLT5jZV9mbGFncyAmIENFX1VQVE9EQVRFKQojZGVmaW5lIGNlX3NraXBfd29ya3RyZWUoY2UpICgoY2UpLT5jZV9mbGFncyAmIENFX1NLSVBfV09SS1RSRUUpCiNkZWZpbmUgY2VfbWFya191cHRvZGF0ZShjZSkgKChjZSktPmNlX2ZsYWdzIHw9IENFX1VQVE9EQVRFKQoKI2RlZmluZSBjZV9wZXJtaXNzaW9ucyhtb2RlKSAoKChtb2RlKSAmIDAxMDApID8gMDc1NSA6IDA2NDQpCnN0YXRpYyBpbmxpbmUgdW5zaWduZWQgaW50IGNyZWF0ZV9jZV9tb2RlKHVuc2lnbmVkIGludCBtb2RlKQp7CglpZiAoU19JU0xOSyhtb2RlKSkKCQlyZXR1cm4gU19JRkxOSzsKCWlmIChTX0lTRElSKG1vZGUpIHx8IFNfSVNHSVRMSU5LKG1vZGUpKQoJCXJldHVybiBTX0lGR0lUTElOSzsKCXJldHVybiBTX0lGUkVHIHwgY2VfcGVybWlzc2lvbnMobW9kZSk7Cn0Kc3RhdGljIGlubGluZSB1bnNpZ25lZCBpbnQgY2VfbW9kZV9mcm9tX3N0YXQoY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwKCQkJCQkgICAgIHVuc2lnbmVkIGludCBtb2RlKQp7CglleHRlcm4gaW50IHRydXN0X2V4ZWN1dGFibGVfYml0LCBoYXNfc3ltbGlua3M7CglpZiAoIWhhc19zeW1saW5rcyAmJiBTX0lTUkVHKG1vZGUpICYmCgkgICAgY2UgJiYgU19JU0xOSyhjZS0+Y2VfbW9kZSkpCgkJcmV0dXJuIGNlLT5jZV9tb2RlOwoJaWYgKCF0cnVzdF9leGVjdXRhYmxlX2JpdCAmJiBTX0lTUkVHKG1vZGUpKSB7CgkJaWYgKGNlICYmIFNfSVNSRUcoY2UtPmNlX21vZGUpKQoJCQlyZXR1cm4gY2UtPmNlX21vZGU7CgkJcmV0dXJuIGNyZWF0ZV9jZV9tb2RlKDA2NjYpOwoJfQoJcmV0dXJuIGNyZWF0ZV9jZV9tb2RlKG1vZGUpOwp9CnN0YXRpYyBpbmxpbmUgaW50IGNlX3RvX2R0eXBlKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UpCnsKCXVuc2lnbmVkIGNlX21vZGUgPSBudG9obChjZS0+Y2VfbW9kZSk7CglpZiAoU19JU1JFRyhjZV9tb2RlKSkKCQlyZXR1cm4gRFRfUkVHOwoJZWxzZSBpZiAoU19JU0RJUihjZV9tb2RlKSB8fCBTX0lTR0lUTElOSyhjZV9tb2RlKSkKCQlyZXR1cm4gRFRfRElSOwoJZWxzZSBpZiAoU19JU0xOSyhjZV9tb2RlKSkKCQlyZXR1cm4gRFRfTE5LOwoJZWxzZQoJCXJldHVybiBEVF9VTktOT1dOOwp9CnN0YXRpYyBpbmxpbmUgdW5zaWduZWQgaW50IGNhbm9uX21vZGUodW5zaWduZWQgaW50IG1vZGUpCnsKCWlmIChTX0lTUkVHKG1vZGUpKQoJCXJldHVybiBTX0lGUkVHIHwgY2VfcGVybWlzc2lvbnMobW9kZSk7CglpZiAoU19JU0xOSyhtb2RlKSkKCQlyZXR1cm4gU19JRkxOSzsKCWlmIChTX0lTRElSKG1vZGUpKQoJCXJldHVybiBTX0lGRElSOwoJcmV0dXJuIFNfSUZHSVRMSU5LOwp9CgojZGVmaW5lIGNhY2hlX2VudHJ5X3NpemUobGVuKSAob2Zmc2V0b2Yoc3RydWN0IGNhY2hlX2VudHJ5LG5hbWUpICsgKGxlbikgKyAxKQoKc3RydWN0IGluZGV4X3N0YXRlIHsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqKmNhY2hlOwoJdW5zaWduZWQgaW50IHZlcnNpb247Cgl1bnNpZ25lZCBpbnQgY2FjaGVfbnIsIGNhY2hlX2FsbG9jLCBjYWNoZV9jaGFuZ2VkOwoJc3RydWN0IHN0cmluZ19saXN0ICpyZXNvbHZlX3VuZG87CglzdHJ1Y3QgY2FjaGVfdHJlZSAqY2FjaGVfdHJlZTsKCXN0cnVjdCBjYWNoZV90aW1lIHRpbWVzdGFtcDsKCXVuc2lnbmVkIG5hbWVfaGFzaF9pbml0aWFsaXplZCA6IDEsCgkJIGluaXRpYWxpemVkIDogMTsKCXN0cnVjdCBoYXNoX3RhYmxlIG5hbWVfaGFzaDsKCXN0cnVjdCBoYXNoX3RhYmxlIGRpcl9oYXNoOwp9OwoKZXh0ZXJuIHN0cnVjdCBpbmRleF9zdGF0ZSB0aGVfaW5kZXg7CgovKiBOYW1lIGhhc2hpbmcgKi8KZXh0ZXJuIHZvaWQgYWRkX25hbWVfaGFzaChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSk7CmV4dGVybiB2b2lkIHJlbW92ZV9uYW1lX2hhc2goc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UpOwpleHRlcm4gdm9pZCBmcmVlX25hbWVfaGFzaChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSk7CgoKI2lmbmRlZiBOT19USEVfSU5ERVhfQ09NUEFUSUJJTElUWV9NQUNST1MKI2RlZmluZSBhY3RpdmVfY2FjaGUgKHRoZV9pbmRleC5jYWNoZSkKI2RlZmluZSBhY3RpdmVfbnIgKHRoZV9pbmRleC5jYWNoZV9ucikKI2RlZmluZSBhY3RpdmVfYWxsb2MgKHRoZV9pbmRleC5jYWNoZV9hbGxvYykKI2RlZmluZSBhY3RpdmVfY2FjaGVfY2hhbmdlZCAodGhlX2luZGV4LmNhY2hlX2NoYW5nZWQpCiNkZWZpbmUgYWN0aXZlX2NhY2hlX3RyZWUgKHRoZV9pbmRleC5jYWNoZV90cmVlKQoKI2RlZmluZSByZWFkX2NhY2hlKCkgcmVhZF9pbmRleCgmdGhlX2luZGV4KQojZGVmaW5lIHJlYWRfY2FjaGVfZnJvbShwYXRoKSByZWFkX2luZGV4X2Zyb20oJnRoZV9pbmRleCwgKHBhdGgpKQojZGVmaW5lIHJlYWRfY2FjaGVfcHJlbG9hZChwYXRoc3BlYykgcmVhZF9pbmRleF9wcmVsb2FkKCZ0aGVfaW5kZXgsIChwYXRoc3BlYykpCiNkZWZpbmUgaXNfY2FjaGVfdW5ib3JuKCkgaXNfaW5kZXhfdW5ib3JuKCZ0aGVfaW5kZXgpCiNkZWZpbmUgcmVhZF9jYWNoZV91bm1lcmdlZCgpIHJlYWRfaW5kZXhfdW5tZXJnZWQoJnRoZV9pbmRleCkKI2RlZmluZSB3cml0ZV9jYWNoZShuZXdmZCwgY2FjaGUsIGVudHJpZXMpIHdyaXRlX2luZGV4KCZ0aGVfaW5kZXgsIChuZXdmZCkpCiNkZWZpbmUgZGlzY2FyZF9jYWNoZSgpIGRpc2NhcmRfaW5kZXgoJnRoZV9pbmRleCkKI2RlZmluZSB1bm1lcmdlZF9jYWNoZSgpIHVubWVyZ2VkX2luZGV4KCZ0aGVfaW5kZXgpCiNkZWZpbmUgY2FjaGVfbmFtZV9wb3MobmFtZSwgbmFtZWxlbikgaW5kZXhfbmFtZV9wb3MoJnRoZV9pbmRleCwobmFtZSksKG5hbWVsZW4pKQojZGVmaW5lIGFkZF9jYWNoZV9lbnRyeShjZSwgb3B0aW9uKSBhZGRfaW5kZXhfZW50cnkoJnRoZV9pbmRleCwgKGNlKSwgKG9wdGlvbikpCiNkZWZpbmUgcmVuYW1lX2NhY2hlX2VudHJ5X2F0KHBvcywgbmV3X25hbWUpIHJlbmFtZV9pbmRleF9lbnRyeV9hdCgmdGhlX2luZGV4LCAocG9zKSwgKG5ld19uYW1lKSkKI2RlZmluZSByZW1vdmVfY2FjaGVfZW50cnlfYXQocG9zKSByZW1vdmVfaW5kZXhfZW50cnlfYXQoJnRoZV9pbmRleCwgKHBvcykpCiNkZWZpbmUgcmVtb3ZlX2ZpbGVfZnJvbV9jYWNoZShwYXRoKSByZW1vdmVfZmlsZV9mcm9tX2luZGV4KCZ0aGVfaW5kZXgsIChwYXRoKSkKI2RlZmluZSBhZGRfdG9fY2FjaGUocGF0aCwgc3QsIGZsYWdzKSBhZGRfdG9faW5kZXgoJnRoZV9pbmRleCwgKHBhdGgpLCAoc3QpLCAoZmxhZ3MpKQojZGVmaW5lIGFkZF9maWxlX3RvX2NhY2hlKHBhdGgsIGZsYWdzKSBhZGRfZmlsZV90b19pbmRleCgmdGhlX2luZGV4LCAocGF0aCksIChmbGFncykpCiNkZWZpbmUgcmVmcmVzaF9jYWNoZShmbGFncykgcmVmcmVzaF9pbmRleCgmdGhlX2luZGV4LCAoZmxhZ3MpLCBOVUxMLCBOVUxMLCBOVUxMKQojZGVmaW5lIGNlX21hdGNoX3N0YXQoY2UsIHN0LCBvcHRpb25zKSBpZV9tYXRjaF9zdGF0KCZ0aGVfaW5kZXgsIChjZSksIChzdCksIChvcHRpb25zKSkKI2RlZmluZSBjZV9tb2RpZmllZChjZSwgc3QsIG9wdGlvbnMpIGllX21vZGlmaWVkKCZ0aGVfaW5kZXgsIChjZSksIChzdCksIChvcHRpb25zKSkKI2RlZmluZSBjYWNoZV9kaXJfZXhpc3RzKG5hbWUsIG5hbWVsZW4pIGluZGV4X2Rpcl9leGlzdHMoJnRoZV9pbmRleCwgKG5hbWUpLCAobmFtZWxlbikpCiNkZWZpbmUgY2FjaGVfZmlsZV9leGlzdHMobmFtZSwgbmFtZWxlbiwgaWduY2FzZSkgaW5kZXhfZmlsZV9leGlzdHMoJnRoZV9pbmRleCwgKG5hbWUpLCAobmFtZWxlbiksIChpZ25jYXNlKSkKI2RlZmluZSBjYWNoZV9uYW1lX2V4aXN0cyhuYW1lLCBuYW1lbGVuLCBpZ25jYXNlKSBpbmRleF9uYW1lX2V4aXN0cygmdGhlX2luZGV4LCAobmFtZSksIChuYW1lbGVuKSwgKGlnbmNhc2UpKQojZGVmaW5lIGNhY2hlX25hbWVfaXNfb3RoZXIobmFtZSwgbmFtZWxlbikgaW5kZXhfbmFtZV9pc19vdGhlcigmdGhlX2luZGV4LCAobmFtZSksIChuYW1lbGVuKSkKI2RlZmluZSByZXNvbHZlX3VuZG9fY2xlYXIoKSByZXNvbHZlX3VuZG9fY2xlYXJfaW5kZXgoJnRoZV9pbmRleCkKI2RlZmluZSB1bm1lcmdlX2NhY2hlX2VudHJ5X2F0KGF0KSB1bm1lcmdlX2luZGV4X2VudHJ5X2F0KCZ0aGVfaW5kZXgsIGF0KQojZGVmaW5lIHVubWVyZ2VfY2FjaGUocGF0aHNwZWMpIHVubWVyZ2VfaW5kZXgoJnRoZV9pbmRleCwgcGF0aHNwZWMpCiNkZWZpbmUgcmVhZF9ibG9iX2RhdGFfZnJvbV9jYWNoZShwYXRoLCBzeikgcmVhZF9ibG9iX2RhdGFfZnJvbV9pbmRleCgmdGhlX2luZGV4LCAocGF0aCksIChzeikpCiNlbmRpZgoKZW51bSBvYmplY3RfdHlwZSB7CglPQkpfQkFEID0gLTEsCglPQkpfTk9ORSA9IDAsCglPQkpfQ09NTUlUID0gMSwKCU9CSl9UUkVFID0gMiwKCU9CSl9CTE9CID0gMywKCU9CSl9UQUcgPSA0LAoJLyogNSBmb3IgZnV0dXJlIGV4cGFuc2lvbiAqLwoJT0JKX09GU19ERUxUQSA9IDYsCglPQkpfUkVGX0RFTFRBID0gNywKCU9CSl9BTlksCglPQkpfTUFYCn07CgpzdGF0aWMgaW5saW5lIGVudW0gb2JqZWN0X3R5cGUgb2JqZWN0X3R5cGUodW5zaWduZWQgaW50IG1vZGUpCnsKCXJldHVybiBTX0lTRElSKG1vZGUpID8gT0JKX1RSRUUgOgoJCVNfSVNHSVRMSU5LKG1vZGUpID8gT0JKX0NPTU1JVCA6CgkJT0JKX0JMT0I7Cn0KCi8qIERvdWJsZS1jaGVjayBsb2NhbF9yZXBvX2VudiBiZWxvdyBpZiB5b3UgYWRkIHRvIHRoaXMgbGlzdC4gKi8KI2RlZmluZSBHSVRfRElSX0VOVklST05NRU5UICJHSVRfRElSIgojZGVmaW5lIEdJVF9OQU1FU1BBQ0VfRU5WSVJPTk1FTlQgIkdJVF9OQU1FU1BBQ0UiCiNkZWZpbmUgR0lUX1dPUktfVFJFRV9FTlZJUk9OTUVOVCAiR0lUX1dPUktfVFJFRSIKI2RlZmluZSBHSVRfUFJFRklYX0VOVklST05NRU5UICJHSVRfUFJFRklYIgojZGVmaW5lIERFRkFVTFRfR0lUX0RJUl9FTlZJUk9OTUVOVCAiLmdpdCIKI2RlZmluZSBEQl9FTlZJUk9OTUVOVCAiR0lUX09CSkVDVF9ESVJFQ1RPUlkiCiNkZWZpbmUgSU5ERVhfRU5WSVJPTk1FTlQgIkdJVF9JTkRFWF9GSUxFIgojZGVmaW5lIEdSQUZUX0VOVklST05NRU5UICJHSVRfR1JBRlRfRklMRSIKI2RlZmluZSBHSVRfU0hBTExPV19GSUxFX0VOVklST05NRU5UICJHSVRfU0hBTExPV19GSUxFIgojZGVmaW5lIFRFTVBMQVRFX0RJUl9FTlZJUk9OTUVOVCAiR0lUX1RFTVBMQVRFX0RJUiIKI2RlZmluZSBDT05GSUdfRU5WSVJPTk1FTlQgIkdJVF9DT05GSUciCiNkZWZpbmUgQ09ORklHX0RBVEFfRU5WSVJPTk1FTlQgIkdJVF9DT05GSUdfUEFSQU1FVEVSUyIKI2RlZmluZSBFWEVDX1BBVEhfRU5WSVJPTk1FTlQgIkdJVF9FWEVDX1BBVEgiCiNkZWZpbmUgQ0VJTElOR19ESVJFQ1RPUklFU19FTlZJUk9OTUVOVCAiR0lUX0NFSUxJTkdfRElSRUNUT1JJRVMiCiNkZWZpbmUgTk9fUkVQTEFDRV9PQkpFQ1RTX0VOVklST05NRU5UICJHSVRfTk9fUkVQTEFDRV9PQkpFQ1RTIgojZGVmaW5lIEdJVEFUVFJJQlVURVNfRklMRSAiLmdpdGF0dHJpYnV0ZXMiCiNkZWZpbmUgSU5GT0FUVFJJQlVURVNfRklMRSAiaW5mby9hdHRyaWJ1dGVzIgojZGVmaW5lIEFUVFJJQlVURV9NQUNST19QUkVGSVggIlthdHRyXSIKI2RlZmluZSBHSVRfTk9URVNfUkVGX0VOVklST05NRU5UICJHSVRfTk9URVNfUkVGIgojZGVmaW5lIEdJVF9OT1RFU19ERUZBVUxUX1JFRiAicmVmcy9ub3Rlcy9jb21taXRzIgojZGVmaW5lIEdJVF9OT1RFU19ESVNQTEFZX1JFRl9FTlZJUk9OTUVOVCAiR0lUX05PVEVTX0RJU1BMQVlfUkVGIgojZGVmaW5lIEdJVF9OT1RFU19SRVdSSVRFX1JFRl9FTlZJUk9OTUVOVCAiR0lUX05PVEVTX1JFV1JJVEVfUkVGIgojZGVmaW5lIEdJVF9OT1RFU19SRVdSSVRFX01PREVfRU5WSVJPTk1FTlQgIkdJVF9OT1RFU19SRVdSSVRFX01PREUiCiNkZWZpbmUgR0lUX0xJVEVSQUxfUEFUSFNQRUNTX0VOVklST05NRU5UICJHSVRfTElURVJBTF9QQVRIU1BFQ1MiCiNkZWZpbmUgR0lUX0dMT0JfUEFUSFNQRUNTX0VOVklST05NRU5UICJHSVRfR0xPQl9QQVRIU1BFQ1MiCiNkZWZpbmUgR0lUX05PR0xPQl9QQVRIU1BFQ1NfRU5WSVJPTk1FTlQgIkdJVF9OT0dMT0JfUEFUSFNQRUNTIgojZGVmaW5lIEdJVF9JQ0FTRV9QQVRIU1BFQ1NfRU5WSVJPTk1FTlQgIkdJVF9JQ0FTRV9QQVRIU1BFQ1MiCgovKgogKiBUaGlzIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIGV4cGVjdGVkIHRvIGNvbnRhaW4gYSBib29sZWFuIGluZGljYXRpbmcKICogd2hldGhlciB3ZSBzaG91bGQgb3Igc2hvdWxkIG5vdCB0cmVhdDoKICoKICogICBHSVRfRElSPWZvby5naXQgZ2l0IC4uLgogKgogKiBhcyBpZiBHSVRfV09SS19UUkVFPS4gd2FzIGdpdmVuLiBJdCdzIG5vdCBleHBlY3RlZCB0aGF0IHVzZXJzIHdpbGwgbWFrZSB1c2UKICogb2YgdGhpcywgYnV0IHdlIHVzZSBpdCBpbnRlcm5hbGx5IHRvIGNvbW11bmljYXRlIHRvIHN1Yi1wcm9jZXNzZXMgdGhhdCB3ZQogKiBhcmUgaW4gYSBiYXJlIHJlcG8uIElmIG5vdCBzZXQsIGRlZmF1bHRzIHRvIHRydWUuCiAqLwojZGVmaW5lIEdJVF9JTVBMSUNJVF9XT1JLX1RSRUVfRU5WSVJPTk1FTlQgIkdJVF9JTVBMSUNJVF9XT1JLX1RSRUUiCgovKgogKiBSZXBvc2l0b3J5LWxvY2FsIEdJVF8qIGVudmlyb25tZW50IHZhcmlhYmxlczsgdGhlc2Ugd2lsbCBiZSBjbGVhcmVkCiAqIHdoZW4gZ2l0IHNwYXducyBhIHN1Yi1wcm9jZXNzIHRoYXQgcnVucyBpbnNpZGUgYW5vdGhlciByZXBvc2l0b3J5LgogKiBUaGUgYXJyYXkgaXMgTlVMTC10ZXJtaW5hdGVkLCB3aGljaCBtYWtlcyBpdCBlYXN5IHRvIHBhc3MgaW4gdGhlICJlbnYiCiAqIHBhcmFtZXRlciBvZiBhIHJ1bi1jb21tYW5kIGludm9jYXRpb24sIG9yIHRvIGRvIGEgc2ltcGxlIHdhbGsuCiAqLwpleHRlcm4gY29uc3QgY2hhciAqIGNvbnN0IGxvY2FsX3JlcG9fZW52W107CgpleHRlcm4gaW50IGlzX2JhcmVfcmVwb3NpdG9yeV9jZmc7CmV4dGVybiBpbnQgaXNfYmFyZV9yZXBvc2l0b3J5KHZvaWQpOwpleHRlcm4gaW50IGlzX2luc2lkZV9naXRfZGlyKHZvaWQpOwpleHRlcm4gY2hhciAqZ2l0X3dvcmtfdHJlZV9jZmc7CmV4dGVybiBpbnQgaXNfaW5zaWRlX3dvcmtfdHJlZSh2b2lkKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdldF9naXRfZGlyKHZvaWQpOwpleHRlcm4gaW50IGlzX2dpdF9kaXJlY3RvcnkoY29uc3QgY2hhciAqcGF0aCk7CmV4dGVybiBjaGFyICpnZXRfb2JqZWN0X2RpcmVjdG9yeSh2b2lkKTsKZXh0ZXJuIGNoYXIgKmdldF9pbmRleF9maWxlKHZvaWQpOwpleHRlcm4gY2hhciAqZ2V0X2dyYWZ0X2ZpbGUodm9pZCk7CmV4dGVybiBpbnQgc2V0X2dpdF9kaXIoY29uc3QgY2hhciAqcGF0aCk7CmV4dGVybiBjb25zdCBjaGFyICpnZXRfZ2l0X25hbWVzcGFjZSh2b2lkKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKnN0cmlwX25hbWVzcGFjZShjb25zdCBjaGFyICpuYW1lc3BhY2VkX3JlZik7CmV4dGVybiBjb25zdCBjaGFyICpnZXRfZ2l0X3dvcmtfdHJlZSh2b2lkKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKnJlYWRfZ2l0ZmlsZShjb25zdCBjaGFyICpwYXRoKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKnJlc29sdmVfZ2l0ZGlyKGNvbnN0IGNoYXIgKnN1c3BlY3QpOwpleHRlcm4gdm9pZCBzZXRfZ2l0X3dvcmtfdHJlZShjb25zdCBjaGFyICp0cmVlKTsKCiNkZWZpbmUgQUxURVJOQVRFX0RCX0VOVklST05NRU5UICJHSVRfQUxURVJOQVRFX09CSkVDVF9ESVJFQ1RPUklFUyIKCmV4dGVybiBjb25zdCBjaGFyICoqZ2V0X3BhdGhzcGVjKGNvbnN0IGNoYXIgKnByZWZpeCwgY29uc3QgY2hhciAqKnBhdGhzcGVjKTsKZXh0ZXJuIHZvaWQgc2V0dXBfd29ya190cmVlKHZvaWQpOwpleHRlcm4gY29uc3QgY2hhciAqc2V0dXBfZ2l0X2RpcmVjdG9yeV9nZW50bHkoaW50ICopOwpleHRlcm4gY29uc3QgY2hhciAqc2V0dXBfZ2l0X2RpcmVjdG9yeSh2b2lkKTsKZXh0ZXJuIGNoYXIgKnByZWZpeF9wYXRoKGNvbnN0IGNoYXIgKnByZWZpeCwgaW50IGxlbiwgY29uc3QgY2hhciAqcGF0aCk7CmV4dGVybiBjaGFyICpwcmVmaXhfcGF0aF9nZW50bHkoY29uc3QgY2hhciAqcHJlZml4LCBpbnQgbGVuLCBpbnQgKnJlbWFpbmluZywgY29uc3QgY2hhciAqcGF0aCk7CmV4dGVybiBjb25zdCBjaGFyICpwcmVmaXhfZmlsZW5hbWUoY29uc3QgY2hhciAqcHJlZml4LCBpbnQgbGVuLCBjb25zdCBjaGFyICpwYXRoKTsKZXh0ZXJuIGludCBjaGVja19maWxlbmFtZShjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IGNoYXIgKm5hbWUpOwpleHRlcm4gdm9pZCB2ZXJpZnlfZmlsZW5hbWUoY29uc3QgY2hhciAqcHJlZml4LAoJCQkgICAgY29uc3QgY2hhciAqbmFtZSwKCQkJICAgIGludCBkaWFnbm9zZV9taXNzcGVsdF9yZXYpOwpleHRlcm4gdm9pZCB2ZXJpZnlfbm9uX2ZpbGVuYW1lKGNvbnN0IGNoYXIgKnByZWZpeCwgY29uc3QgY2hhciAqbmFtZSk7CmV4dGVybiBpbnQgcGF0aF9pbnNpZGVfcmVwbyhjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IGNoYXIgKnBhdGgpOwoKI2RlZmluZSBJTklUX0RCX1FVSUVUIDB4MDAwMQoKZXh0ZXJuIGludCBzZXRfZ2l0X2Rpcl9pbml0KGNvbnN0IGNoYXIgKmdpdF9kaXIsIGNvbnN0IGNoYXIgKnJlYWxfZ2l0X2RpciwgaW50KTsKZXh0ZXJuIGludCBpbml0X2RiKGNvbnN0IGNoYXIgKnRlbXBsYXRlX2RpciwgdW5zaWduZWQgaW50IGZsYWdzKTsKCmV4dGVybiB2b2lkIHNhbml0aXplX3N0ZGZkcyh2b2lkKTsKCiNkZWZpbmUgYWxsb2NfbnIoeCkgKCgoeCkrMTYpKjMvMikKCi8qCiAqIFJlYWxsb2MgdGhlIGJ1ZmZlciBwb2ludGVkIGF0IGJ5IHZhcmlhYmxlICd4JyBzbyB0aGF0IGl0IGNhbiBob2xkCiAqIGF0IGxlYXN0ICducicgZW50cmllczsgdGhlIG51bWJlciBvZiBlbnRyaWVzIGN1cnJlbnRseSBhbGxvY2F0ZWQKICogaXMgJ2FsbG9jJywgdXNpbmcgdGhlIHN0YW5kYXJkIGdyb3dpbmcgZmFjdG9yIGFsbG9jX25yKCkgbWFjcm8uCiAqCiAqIERPIE5PVCBVU0UgYW55IGV4cHJlc3Npb24gd2l0aCBzaWRlLWVmZmVjdCBmb3IgJ3gnLCAnbnInLCBvciAnYWxsb2MnLgogKi8KI2RlZmluZSBBTExPQ19HUk9XKHgsIG5yLCBhbGxvYykgXAoJZG8geyBcCgkJaWYgKChucikgPiBhbGxvYykgeyBcCgkJCWlmIChhbGxvY19ucihhbGxvYykgPCAobnIpKSBcCgkJCQlhbGxvYyA9IChucik7IFwKCQkJZWxzZSBcCgkJCQlhbGxvYyA9IGFsbG9jX25yKGFsbG9jKTsgXAoJCQl4ID0geHJlYWxsb2MoKHgpLCBhbGxvYyAqIHNpemVvZigqKHgpKSk7IFwKCQl9IFwKCX0gd2hpbGUgKDApCgovKiBJbml0aWFsaXplIGFuZCB1c2UgdGhlIGNhY2hlIGluZm9ybWF0aW9uICovCmV4dGVybiBpbnQgcmVhZF9pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKik7CmV4dGVybiBpbnQgcmVhZF9pbmRleF9wcmVsb2FkKHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBhdGhzcGVjKTsKZXh0ZXJuIGludCByZWFkX2luZGV4X2Zyb20oc3RydWN0IGluZGV4X3N0YXRlICosIGNvbnN0IGNoYXIgKnBhdGgpOwpleHRlcm4gaW50IGlzX2luZGV4X3VuYm9ybihzdHJ1Y3QgaW5kZXhfc3RhdGUgKik7CmV4dGVybiBpbnQgcmVhZF9pbmRleF91bm1lcmdlZChzdHJ1Y3QgaW5kZXhfc3RhdGUgKik7CmV4dGVybiBpbnQgd3JpdGVfaW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICosIGludCBuZXdmZCk7CmV4dGVybiBpbnQgZGlzY2FyZF9pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKik7CmV4dGVybiBpbnQgdW5tZXJnZWRfaW5kZXgoY29uc3Qgc3RydWN0IGluZGV4X3N0YXRlICopOwpleHRlcm4gaW50IHZlcmlmeV9wYXRoKGNvbnN0IGNoYXIgKnBhdGgpOwpleHRlcm4gc3RydWN0IGNhY2hlX2VudHJ5ICppbmRleF9kaXJfZXhpc3RzKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbik7CmV4dGVybiBzdHJ1Y3QgY2FjaGVfZW50cnkgKmluZGV4X2ZpbGVfZXhpc3RzKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbiwgaW50IGlnbmNhc2UpOwpleHRlcm4gc3RydWN0IGNhY2hlX2VudHJ5ICppbmRleF9uYW1lX2V4aXN0cyhzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgY29uc3QgY2hhciAqbmFtZSwgaW50IG5hbWVsZW4sIGludCBpZ25jYXNlKTsKZXh0ZXJuIGludCBpbmRleF9uYW1lX3Bvcyhjb25zdCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgY29uc3QgY2hhciAqbmFtZSwgaW50IG5hbWVsZW4pOwojZGVmaW5lIEFERF9DQUNIRV9PS19UT19BREQgMQkJLyogT2sgdG8gYWRkICovCiNkZWZpbmUgQUREX0NBQ0hFX09LX1RPX1JFUExBQ0UgMgkvKiBPayB0byByZXBsYWNlIGZpbGUvZGlyZWN0b3J5ICovCiNkZWZpbmUgQUREX0NBQ0hFX1NLSVBfREZDSEVDSyA0CS8qIE9rIHRvIHNraXAgREYgY29uZmxpY3QgY2hlY2tzICovCiNkZWZpbmUgQUREX0NBQ0hFX0pVU1RfQVBQRU5EIDgJCS8qIEFwcGVuZCBvbmx5OyB0cmVlLmM6OnJlYWRfdHJlZSgpICovCiNkZWZpbmUgQUREX0NBQ0hFX05FV19PTkxZIDE2CQkvKiBEbyBub3QgcmVwbGFjZSBleGlzdGluZyBvbmVzICovCmV4dGVybiBpbnQgYWRkX2luZGV4X2VudHJ5KHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBpbnQgb3B0aW9uKTsKZXh0ZXJuIHZvaWQgcmVuYW1lX2luZGV4X2VudHJ5X2F0KHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBpbnQgcG9zLCBjb25zdCBjaGFyICpuZXdfbmFtZSk7CmV4dGVybiBpbnQgcmVtb3ZlX2luZGV4X2VudHJ5X2F0KHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBpbnQgcG9zKTsKZXh0ZXJuIHZvaWQgcmVtb3ZlX21hcmtlZF9jYWNoZV9lbnRyaWVzKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlKTsKZXh0ZXJuIGludCByZW1vdmVfZmlsZV9mcm9tX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBjb25zdCBjaGFyICpwYXRoKTsKI2RlZmluZSBBRERfQ0FDSEVfVkVSQk9TRSAxCiNkZWZpbmUgQUREX0NBQ0hFX1BSRVRFTkQgMgojZGVmaW5lIEFERF9DQUNIRV9JR05PUkVfRVJST1JTCTQKI2RlZmluZSBBRERfQ0FDSEVfSUdOT1JFX1JFTU9WQUwgOAojZGVmaW5lIEFERF9DQUNIRV9JTlRFTlQgMTYKI2RlZmluZSBBRERfQ0FDSEVfSU1QTElDSVRfRE9UIDMyCS8qIGludGVybmFsIHRvICJnaXQgYWRkIC11Ly1BIiAqLwpleHRlcm4gaW50IGFkZF90b19pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgY29uc3QgY2hhciAqcGF0aCwgc3RydWN0IHN0YXQgKiwgaW50IGZsYWdzKTsKZXh0ZXJuIGludCBhZGRfZmlsZV90b19pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgY29uc3QgY2hhciAqcGF0aCwgaW50IGZsYWdzKTsKZXh0ZXJuIHN0cnVjdCBjYWNoZV9lbnRyeSAqbWFrZV9jYWNoZV9lbnRyeSh1bnNpZ25lZCBpbnQgbW9kZSwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgY29uc3QgY2hhciAqcGF0aCwgaW50IHN0YWdlLCB1bnNpZ25lZCBpbnQgcmVmcmVzaF9vcHRpb25zKTsKZXh0ZXJuIGludCBjZV9zYW1lX25hbWUoY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICphLCBjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmIpOwpleHRlcm4gaW50IGluZGV4X25hbWVfaXNfb3RoZXIoY29uc3Qgc3RydWN0IGluZGV4X3N0YXRlICosIGNvbnN0IGNoYXIgKiwgaW50KTsKZXh0ZXJuIHZvaWQgKnJlYWRfYmxvYl9kYXRhX2Zyb21faW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICosIGNvbnN0IGNoYXIgKiwgdW5zaWduZWQgbG9uZyAqKTsKCi8qIGRvIHN0YXQgY29tcGFyaXNvbiBldmVuIGlmIENFX1ZBTElEIGlzIHRydWUgKi8KI2RlZmluZSBDRV9NQVRDSF9JR05PUkVfVkFMSUQJCTAxCi8qIGRvIG5vdCBjaGVjayB0aGUgY29udGVudHMgYnV0IHJlcG9ydCBkaXJ0eSBvbiByYWNpbHktY2xlYW4gZW50cmllcyAqLwojZGVmaW5lIENFX01BVENIX1JBQ1lfSVNfRElSVFkJCTAyCi8qIGRvIHN0YXQgY29tcGFyaXNvbiBldmVuIGlmIENFX1NLSVBfV09SS1RSRUUgaXMgdHJ1ZSAqLwojZGVmaW5lIENFX01BVENIX0lHTk9SRV9TS0lQX1dPUktUUkVFCTA0Ci8qIGlnbm9yZSBub24tZXhpc3RlbnQgZmlsZXMgZHVyaW5nIHN0YXQgdXBkYXRlICAqLwojZGVmaW5lIENFX01BVENIX0lHTk9SRV9NSVNTSU5HCQkweDA4Ci8qIGVuYWJsZSBzdGF0IHJlZnJlc2ggKi8KI2RlZmluZSBDRV9NQVRDSF9SRUZSRVNICQkweDEwCmV4dGVybiBpbnQgaWVfbWF0Y2hfc3RhdChjb25zdCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICosIHN0cnVjdCBzdGF0ICosIHVuc2lnbmVkIGludCk7CmV4dGVybiBpbnQgaWVfbW9kaWZpZWQoY29uc3Qgc3RydWN0IGluZGV4X3N0YXRlICosIGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqLCBzdHJ1Y3Qgc3RhdCAqLCB1bnNpZ25lZCBpbnQpOwoKI2RlZmluZSBIQVNIX1dSSVRFX09CSkVDVCAxCiNkZWZpbmUgSEFTSF9GT1JNQVRfQ0hFQ0sgMgpleHRlcm4gaW50IGluZGV4X2ZkKHVuc2lnbmVkIGNoYXIgKnNoYTEsIGludCBmZCwgc3RydWN0IHN0YXQgKnN0LCBlbnVtIG9iamVjdF90eXBlIHR5cGUsIGNvbnN0IGNoYXIgKnBhdGgsIHVuc2lnbmVkIGZsYWdzKTsKZXh0ZXJuIGludCBpbmRleF9wYXRoKHVuc2lnbmVkIGNoYXIgKnNoYTEsIGNvbnN0IGNoYXIgKnBhdGgsIHN0cnVjdCBzdGF0ICpzdCwgdW5zaWduZWQgZmxhZ3MpOwoKLyoKICogUmVjb3JkIHRvIHNkIHRoZSBkYXRhIGZyb20gc3QgdGhhdCB3ZSB1c2UgdG8gY2hlY2sgd2hldGhlciBhIGZpbGUKICogbWlnaHQgaGF2ZSBjaGFuZ2VkLgogKi8KZXh0ZXJuIHZvaWQgZmlsbF9zdGF0X2RhdGEoc3RydWN0IHN0YXRfZGF0YSAqc2QsIHN0cnVjdCBzdGF0ICpzdCk7CgovKgogKiBSZXR1cm4gMCBpZiBzdCBpcyBjb25zaXN0ZW50IHdpdGggYSBmaWxlIG5vdCBoYXZpbmcgYmVlbiBjaGFuZ2VkCiAqIHNpbmNlIHNkIHdhcyBmaWxsZWQuICBJZiB0aGVyZSBhcmUgZGlmZmVyZW5jZXMsIHJldHVybiBhCiAqIGNvbWJpbmF0aW9uIG9mIE1USU1FX0NIQU5HRUQsIENUSU1FX0NIQU5HRUQsIE9XTkVSX0NIQU5HRUQsCiAqIElOT0RFX0NIQU5HRUQsIGFuZCBEQVRBX0NIQU5HRUQuCiAqLwpleHRlcm4gaW50IG1hdGNoX3N0YXRfZGF0YShjb25zdCBzdHJ1Y3Qgc3RhdF9kYXRhICpzZCwgc3RydWN0IHN0YXQgKnN0KTsKCmV4dGVybiB2b2lkIGZpbGxfc3RhdF9jYWNoZV9pbmZvKHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIHN0cnVjdCBzdGF0ICpzdCk7CgojZGVmaW5lIFJFRlJFU0hfUkVBTExZCQkweDAwMDEJLyogaWdub3JlX3ZhbGlkICovCiNkZWZpbmUgUkVGUkVTSF9VTk1FUkdFRAkweDAwMDIJLyogYWxsb3cgdW5tZXJnZWQgKi8KI2RlZmluZSBSRUZSRVNIX1FVSUVUCQkweDAwMDQJLyogYmUgcXVpZXQgYWJvdXQgaXQgKi8KI2RlZmluZSBSRUZSRVNIX0lHTk9SRV9NSVNTSU5HCTB4MDAwOAkvKiBpZ25vcmUgbm9uLWV4aXN0ZW50ICovCiNkZWZpbmUgUkVGUkVTSF9JR05PUkVfU1VCTU9EVUxFUwkweDAwMTAJLyogaWdub3JlIHN1Ym1vZHVsZXMgKi8KI2RlZmluZSBSRUZSRVNIX0lOX1BPUkNFTEFJTgkweDAwMjAJLyogdXNlciBmcmllbmRseSBvdXRwdXQsIG5vdCAibmVlZHMgdXBkYXRlIiAqLwpleHRlcm4gaW50IHJlZnJlc2hfaW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICosIHVuc2lnbmVkIGludCBmbGFncywgY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwYXRoc3BlYywgY2hhciAqc2VlbiwgY29uc3QgY2hhciAqaGVhZGVyX21zZyk7CgpzdHJ1Y3QgbG9ja19maWxlIHsKCXN0cnVjdCBsb2NrX2ZpbGUgKm5leHQ7CglpbnQgZmQ7CglwaWRfdCBvd25lcjsKCWNoYXIgb25fbGlzdDsKCWNoYXIgZmlsZW5hbWVbUEFUSF9NQVhdOwp9OwojZGVmaW5lIExPQ0tfRElFX09OX0VSUk9SIDEKI2RlZmluZSBMT0NLX05PREVSRUYgMgpleHRlcm4gaW50IHVuYWJsZV90b19sb2NrX2Vycm9yKGNvbnN0IGNoYXIgKnBhdGgsIGludCBlcnIpOwpleHRlcm4gTk9SRVRVUk4gdm9pZCB1bmFibGVfdG9fbG9ja19pbmRleF9kaWUoY29uc3QgY2hhciAqcGF0aCwgaW50IGVycik7CmV4dGVybiBpbnQgaG9sZF9sb2NrX2ZpbGVfZm9yX3VwZGF0ZShzdHJ1Y3QgbG9ja19maWxlICosIGNvbnN0IGNoYXIgKnBhdGgsIGludCk7CmV4dGVybiBpbnQgaG9sZF9sb2NrX2ZpbGVfZm9yX2FwcGVuZChzdHJ1Y3QgbG9ja19maWxlICosIGNvbnN0IGNoYXIgKnBhdGgsIGludCk7CmV4dGVybiBpbnQgY29tbWl0X2xvY2tfZmlsZShzdHJ1Y3QgbG9ja19maWxlICopOwpleHRlcm4gdm9pZCB1cGRhdGVfaW5kZXhfaWZfYWJsZShzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgc3RydWN0IGxvY2tfZmlsZSAqKTsKCmV4dGVybiBpbnQgaG9sZF9sb2NrZWRfaW5kZXgoc3RydWN0IGxvY2tfZmlsZSAqLCBpbnQpOwpleHRlcm4gaW50IGNvbW1pdF9sb2NrZWRfaW5kZXgoc3RydWN0IGxvY2tfZmlsZSAqKTsKZXh0ZXJuIHZvaWQgc2V0X2FsdGVybmF0ZV9pbmRleF9vdXRwdXQoY29uc3QgY2hhciAqKTsKZXh0ZXJuIGludCBjbG9zZV9sb2NrX2ZpbGUoc3RydWN0IGxvY2tfZmlsZSAqKTsKZXh0ZXJuIHZvaWQgcm9sbGJhY2tfbG9ja19maWxlKHN0cnVjdCBsb2NrX2ZpbGUgKik7CmV4dGVybiBpbnQgZGVsZXRlX3JlZihjb25zdCBjaGFyICosIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIGludCBkZWxvcHQpOwoKLyogRW52aXJvbm1lbnQgYml0cyBmcm9tIGNvbmZpZ3VyYXRpb24gbWVjaGFuaXNtICovCmV4dGVybiBpbnQgdHJ1c3RfZXhlY3V0YWJsZV9iaXQ7CmV4dGVybiBpbnQgdHJ1c3RfY3RpbWU7CmV4dGVybiBpbnQgY2hlY2tfc3RhdDsKZXh0ZXJuIGludCBxdW90ZV9wYXRoX2Z1bGx5OwpleHRlcm4gaW50IGhhc19zeW1saW5rczsKZXh0ZXJuIGludCBtaW5pbXVtX2FiYnJldiwgZGVmYXVsdF9hYmJyZXY7CmV4dGVybiBpbnQgaWdub3JlX2Nhc2U7CmV4dGVybiBpbnQgYXNzdW1lX3VuY2hhbmdlZDsKZXh0ZXJuIGludCBwcmVmZXJfc3ltbGlua19yZWZzOwpleHRlcm4gaW50IGxvZ19hbGxfcmVmX3VwZGF0ZXM7CmV4dGVybiBpbnQgd2Fybl9hbWJpZ3VvdXNfcmVmczsKZXh0ZXJuIGludCB3YXJuX29uX29iamVjdF9yZWZuYW1lX2FtYmlndWl0eTsKZXh0ZXJuIGludCBzaGFyZWRfcmVwb3NpdG9yeTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmFwcGx5X2RlZmF1bHRfd2hpdGVzcGFjZTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmFwcGx5X2RlZmF1bHRfaWdub3Jld2hpdGVzcGFjZTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdpdF9hdHRyaWJ1dGVzX2ZpbGU7CmV4dGVybiBpbnQgemxpYl9jb21wcmVzc2lvbl9sZXZlbDsKZXh0ZXJuIGludCBjb3JlX2NvbXByZXNzaW9uX2xldmVsOwpleHRlcm4gaW50IGNvcmVfY29tcHJlc3Npb25fc2VlbjsKZXh0ZXJuIHNpemVfdCBwYWNrZWRfZ2l0X3dpbmRvd19zaXplOwpleHRlcm4gc2l6ZV90IHBhY2tlZF9naXRfbGltaXQ7CmV4dGVybiBzaXplX3QgZGVsdGFfYmFzZV9jYWNoZV9saW1pdDsKZXh0ZXJuIHVuc2lnbmVkIGxvbmcgYmlnX2ZpbGVfdGhyZXNob2xkOwpleHRlcm4gdW5zaWduZWQgbG9uZyBwYWNrX3NpemVfbGltaXRfY2ZnOwpleHRlcm4gaW50IHJlYWRfcmVwbGFjZV9yZWZzOwpleHRlcm4gaW50IGZzeW5jX29iamVjdF9maWxlczsKZXh0ZXJuIGludCBjb3JlX3ByZWxvYWRfaW5kZXg7CmV4dGVybiBpbnQgY29yZV9hcHBseV9zcGFyc2VfY2hlY2tvdXQ7CmV4dGVybiBpbnQgcHJlY29tcG9zZWRfdW5pY29kZTsKCi8qCiAqIFRoZSBjaGFyYWN0ZXIgdGhhdCBiZWdpbnMgYSBjb21tZW50ZWQgbGluZSBpbiB1c2VyLWVkaXRhYmxlIGZpbGUKICogdGhhdCBpcyBzdWJqZWN0IHRvIHN0cmlwc3BhY2UuCiAqLwpleHRlcm4gY2hhciBjb21tZW50X2xpbmVfY2hhcjsKCmVudW0gYnJhbmNoX3RyYWNrIHsKCUJSQU5DSF9UUkFDS19VTlNQRUNJRklFRCA9IC0xLAoJQlJBTkNIX1RSQUNLX05FVkVSID0gMCwKCUJSQU5DSF9UUkFDS19SRU1PVEUsCglCUkFOQ0hfVFJBQ0tfQUxXQVlTLAoJQlJBTkNIX1RSQUNLX0VYUExJQ0lULAoJQlJBTkNIX1RSQUNLX09WRVJSSURFCn07CgplbnVtIHJlYmFzZV9zZXR1cF90eXBlIHsKCUFVVE9SRUJBU0VfTkVWRVIgPSAwLAoJQVVUT1JFQkFTRV9MT0NBTCwKCUFVVE9SRUJBU0VfUkVNT1RFLAoJQVVUT1JFQkFTRV9BTFdBWVMKfTsKCmVudW0gcHVzaF9kZWZhdWx0X3R5cGUgewoJUFVTSF9ERUZBVUxUX05PVEhJTkcgPSAwLAoJUFVTSF9ERUZBVUxUX01BVENISU5HLAoJUFVTSF9ERUZBVUxUX1NJTVBMRSwKCVBVU0hfREVGQVVMVF9VUFNUUkVBTSwKCVBVU0hfREVGQVVMVF9DVVJSRU5ULAoJUFVTSF9ERUZBVUxUX1VOU1BFQ0lGSUVECn07CgpleHRlcm4gZW51bSBicmFuY2hfdHJhY2sgZ2l0X2JyYW5jaF90cmFjazsKZXh0ZXJuIGVudW0gcmViYXNlX3NldHVwX3R5cGUgYXV0b3JlYmFzZTsKZXh0ZXJuIGVudW0gcHVzaF9kZWZhdWx0X3R5cGUgcHVzaF9kZWZhdWx0OwoKZW51bSBvYmplY3RfY3JlYXRpb25fbW9kZSB7CglPQkpFQ1RfQ1JFQVRJT05fVVNFU19IQVJETElOS1MgPSAwLAoJT0JKRUNUX0NSRUFUSU9OX1VTRVNfUkVOQU1FUyA9IDEKfTsKCmV4dGVybiBlbnVtIG9iamVjdF9jcmVhdGlvbl9tb2RlIG9iamVjdF9jcmVhdGlvbl9tb2RlOwoKZXh0ZXJuIGNoYXIgKm5vdGVzX3JlZl9uYW1lOwoKZXh0ZXJuIGludCBncmFmdHNfcmVwbGFjZV9wYXJlbnRzOwoKI2RlZmluZSBHSVRfUkVQT19WRVJTSU9OIDAKZXh0ZXJuIGludCByZXBvc2l0b3J5X2Zvcm1hdF92ZXJzaW9uOwpleHRlcm4gaW50IGNoZWNrX3JlcG9zaXRvcnlfZm9ybWF0KHZvaWQpOwoKI2RlZmluZSBNVElNRV9DSEFOR0VECTB4MDAwMQojZGVmaW5lIENUSU1FX0NIQU5HRUQJMHgwMDAyCiNkZWZpbmUgT1dORVJfQ0hBTkdFRAkweDAwMDQKI2RlZmluZSBNT0RFX0NIQU5HRUQgICAgMHgwMDA4CiNkZWZpbmUgSU5PREVfQ0hBTkdFRCAgIDB4MDAxMAojZGVmaW5lIERBVEFfQ0hBTkdFRCAgICAweDAwMjAKI2RlZmluZSBUWVBFX0NIQU5HRUQgICAgMHgwMDQwCgpleHRlcm4gY2hhciAqbWtzbnBhdGgoY2hhciAqYnVmLCBzaXplX3QgbiwgY29uc3QgY2hhciAqZm10LCAuLi4pCglfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMywgNCkpKTsKZXh0ZXJuIGNoYXIgKmdpdF9zbnBhdGgoY2hhciAqYnVmLCBzaXplX3QgbiwgY29uc3QgY2hhciAqZm10LCAuLi4pCglfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMywgNCkpKTsKZXh0ZXJuIGNoYXIgKmdpdF9wYXRoZHVwKGNvbnN0IGNoYXIgKmZtdCwgLi4uKQoJX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsIDEsIDIpKSk7CmV4dGVybiBjaGFyICpta3BhdGhkdXAoY29uc3QgY2hhciAqZm10LCAuLi4pCglfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMSwgMikpKTsKCi8qIFJldHVybiBhIHN0YXRpY2FsbHkgYWxsb2NhdGVkIGZpbGVuYW1lIG1hdGNoaW5nIHRoZSBzaGExIHNpZ25hdHVyZSAqLwpleHRlcm4gY2hhciAqbWtwYXRoKGNvbnN0IGNoYXIgKmZtdCwgLi4uKSBfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMSwgMikpKTsKZXh0ZXJuIGNoYXIgKmdpdF9wYXRoKGNvbnN0IGNoYXIgKmZtdCwgLi4uKSBfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMSwgMikpKTsKZXh0ZXJuIGNoYXIgKmdpdF9wYXRoX3N1Ym1vZHVsZShjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFyICpmbXQsIC4uLikKCV9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAyLCAzKSkpOwoKZXh0ZXJuIGNoYXIgKnNoYTFfZmlsZV9uYW1lKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpleHRlcm4gY2hhciAqc2hhMV9wYWNrX25hbWUoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSk7CmV4dGVybiBjaGFyICpzaGExX3BhY2tfaW5kZXhfbmFtZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmZpbmRfdW5pcXVlX2FiYnJldihjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBpbnQpOwpleHRlcm4gY29uc3QgdW5zaWduZWQgY2hhciBudWxsX3NoYTFbMjBdOwoKc3RhdGljIGlubGluZSBpbnQgaGFzaGNtcChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGEyKQp7CglpbnQgaTsKCglmb3IgKGkgPSAwOyBpIDwgMjA7IGkrKywgc2hhMSsrLCBzaGEyKyspIHsKCQlpZiAoKnNoYTEgIT0gKnNoYTIpCgkJCXJldHVybiAqc2hhMSAtICpzaGEyOwoJfQoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW5saW5lIGludCBpc19udWxsX3NoYTEoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJcmV0dXJuICFoYXNoY21wKHNoYTEsIG51bGxfc2hhMSk7Cn0KCnN0YXRpYyBpbmxpbmUgdm9pZCBoYXNoY3B5KHVuc2lnbmVkIGNoYXIgKnNoYV9kc3QsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYV9zcmMpCnsKCW1lbWNweShzaGFfZHN0LCBzaGFfc3JjLCAyMCk7Cn0Kc3RhdGljIGlubGluZSB2b2lkIGhhc2hjbHIodW5zaWduZWQgY2hhciAqaGFzaCkKewoJbWVtc2V0KGhhc2gsIDAsIDIwKTsKfQoKI2RlZmluZSBFTVBUWV9UUkVFX1NIQTFfSEVYIFwKCSI0YjgyNWRjNjQyY2I2ZWI5YTA2MGU1NGJmOGQ2OTI4OGZiZWU0OTA0IgojZGVmaW5lIEVNUFRZX1RSRUVfU0hBMV9CSU5fTElURVJBTCBcCgkgIlx4NGJceDgyXHg1ZFx4YzZceDQyXHhjYlx4NmVceGI5XHhhMFx4NjAiIFwKCSAiXHhlNVx4NGJceGY4XHhkNlx4OTJceDg4XHhmYlx4ZWVceDQ5XHgwNCIKI2RlZmluZSBFTVBUWV9UUkVFX1NIQTFfQklOIFwKCSAoKGNvbnN0IHVuc2lnbmVkIGNoYXIgKikgRU1QVFlfVFJFRV9TSEExX0JJTl9MSVRFUkFMKQoKI2RlZmluZSBFTVBUWV9CTE9CX1NIQTFfSEVYIFwKCSJlNjlkZTI5YmIyZDFkNjQzNGI4YjI5YWU3NzVhZDhjMmU0OGM1MzkxIgojZGVmaW5lIEVNUFRZX0JMT0JfU0hBMV9CSU5fTElURVJBTCBcCgkiXHhlNlx4OWRceGUyXHg5Ylx4YjJceGQxXHhkNlx4NDNceDRiXHg4YiIgXAoJIlx4MjlceGFlXHg3N1x4NWFceGQ4XHhjMlx4ZTRceDhjXHg1M1x4OTEiCiNkZWZpbmUgRU1QVFlfQkxPQl9TSEExX0JJTiBcCgkoKGNvbnN0IHVuc2lnbmVkIGNoYXIgKikgRU1QVFlfQkxPQl9TSEExX0JJTl9MSVRFUkFMKQoKc3RhdGljIGlubGluZSBpbnQgaXNfZW1wdHlfYmxvYl9zaGExKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXJldHVybiAhaGFzaGNtcChzaGExLCBFTVBUWV9CTE9CX1NIQTFfQklOKTsKfQoKaW50IGdpdF9ta3N0ZW1wKGNoYXIgKnBhdGgsIHNpemVfdCBuLCBjb25zdCBjaGFyICp0ZW1wbGF0ZSk7CgppbnQgZ2l0X21rc3RlbXBzKGNoYXIgKnBhdGgsIHNpemVfdCBuLCBjb25zdCBjaGFyICp0ZW1wbGF0ZSwgaW50IHN1ZmZpeF9sZW4pOwoKLyogc2V0IGRlZmF1bHQgcGVybWlzc2lvbnMgYnkgcGFzc2luZyBtb2RlIGFyZ3VtZW50cyB0byBvcGVuKDIpICovCmludCBnaXRfbWtzdGVtcHNfbW9kZShjaGFyICpwYXR0ZXJuLCBpbnQgc3VmZml4X2xlbiwgaW50IG1vZGUpOwppbnQgZ2l0X21rc3RlbXBfbW9kZShjaGFyICpwYXR0ZXJuLCBpbnQgbW9kZSk7CgovKgogKiBOT1RFIE5PVEUgTk9URSEhCiAqCiAqIFBFUk1fVU1BU0ssIE9MRF9QRVJNX0dST1VQIGFuZCBPTERfUEVSTV9FVkVSWUJPRFkgZW51bWVyYXRpb25zIG11c3QKICogbm90IGJlIGNoYW5nZWQuIE9sZCByZXBvc2l0b3JpZXMgaGF2ZSBjb3JlLnNoYXJlZHJlcG9zaXRvcnkgd3JpdHRlbiBpbgogKiBudW1lcmljIGZvcm1hdCwgYW5kIHRoZXJlZm9yZSB0aGVzZSB2YWx1ZXMgYXJlIHByZXNlcnZlZCBmb3IgY29tcGF0aWJpbGl0eQogKiByZWFzb25zLgogKi8KZW51bSBzaGFyZWRyZXBvIHsKCVBFUk1fVU1BU0sgICAgICAgICAgPSAwLAoJT0xEX1BFUk1fR1JPVVAgICAgICA9IDEsCglPTERfUEVSTV9FVkVSWUJPRFkgID0gMiwKCVBFUk1fR1JPVVAgICAgICAgICAgPSAwNjYwLAoJUEVSTV9FVkVSWUJPRFkgICAgICA9IDA2NjQKfTsKaW50IGdpdF9jb25maWdfcGVybShjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlKTsKaW50IGFkanVzdF9zaGFyZWRfcGVybShjb25zdCBjaGFyICpwYXRoKTsKCi8qCiAqIENyZWF0ZSB0aGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgdGhlIG5hbWVkIHBhdGgsIHVzaW5nIGNhcmUgdG8gYmUKICogc29tZXdoYXQgc2FmZSBhZ2FpbnN0IHJhY2VzLiAgUmV0dXJuIG9uZSBvZiB0aGUgc2NsZF9lcnJvciB2YWx1ZXMKICogdG8gaW5kaWNhdGUgc3VjY2Vzcy9mYWlsdXJlLgogKgogKiBTQ0xEX1ZBTklTSEVEIGluZGljYXRlcyB0aGF0IG9uZSBvZiB0aGUgYW5jZXN0b3IgZGlyZWN0b3JpZXMgb2YgdGhlCiAqIHBhdGggZXhpc3RlZCBhdCBvbmUgcG9pbnQgZHVyaW5nIHRoZSBmdW5jdGlvbiBjYWxsIGFuZCB0aGVuCiAqIHN1ZGRlbmx5IHZhbmlzaGVkLCBwcm9iYWJseSBiZWNhdXNlIGFub3RoZXIgcHJvY2VzcyBwcnVuZWQgdGhlCiAqIGRpcmVjdG9yeSB3aGlsZSB3ZSB3ZXJlIHdvcmtpbmcuICBUbyBiZSByb2J1c3QgYWdhaW5zdCB0aGlzIGtpbmQgb2YKICogcmFjZSwgY2FsbGVycyBtaWdodCB3YW50IHRvIHRyeSBpbnZva2luZyB0aGUgZnVuY3Rpb24gYWdhaW4gd2hlbiBpdAogKiByZXR1cm5zIFNDTERfVkFOSVNIRUQuCiAqLwplbnVtIHNjbGRfZXJyb3IgewoJU0NMRF9PSyA9IDAsCglTQ0xEX0ZBSUxFRCA9IC0xLAoJU0NMRF9QRVJNUyA9IC0yLAoJU0NMRF9FWElTVFMgPSAtMywKCVNDTERfVkFOSVNIRUQgPSAtNAp9OwplbnVtIHNjbGRfZXJyb3Igc2FmZV9jcmVhdGVfbGVhZGluZ19kaXJlY3RvcmllcyhjaGFyICpwYXRoKTsKZW51bSBzY2xkX2Vycm9yIHNhZmVfY3JlYXRlX2xlYWRpbmdfZGlyZWN0b3JpZXNfY29uc3QoY29uc3QgY2hhciAqcGF0aCk7CgppbnQgbWtkaXJfaW5fZ2l0ZGlyKGNvbnN0IGNoYXIgKnBhdGgpOwpleHRlcm4gdm9pZCBob21lX2NvbmZpZ19wYXRocyhjaGFyICoqZ2xvYmFsLCBjaGFyICoqeGRnLCBjaGFyICpmaWxlKTsKZXh0ZXJuIGNoYXIgKmV4cGFuZF91c2VyX3BhdGgoY29uc3QgY2hhciAqcGF0aCk7CmNvbnN0IGNoYXIgKmVudGVyX3JlcG8oY29uc3QgY2hhciAqcGF0aCwgaW50IHN0cmljdCk7CnN0YXRpYyBpbmxpbmUgaW50IGlzX2Fic29sdXRlX3BhdGgoY29uc3QgY2hhciAqcGF0aCkKewoJcmV0dXJuIGlzX2Rpcl9zZXAocGF0aFswXSkgfHwgaGFzX2Rvc19kcml2ZV9wcmVmaXgocGF0aCk7Cn0KaW50IGlzX2RpcmVjdG9yeShjb25zdCBjaGFyICopOwpjb25zdCBjaGFyICpyZWFsX3BhdGgoY29uc3QgY2hhciAqcGF0aCk7CmNvbnN0IGNoYXIgKnJlYWxfcGF0aF9pZl92YWxpZChjb25zdCBjaGFyICpwYXRoKTsKY29uc3QgY2hhciAqYWJzb2x1dGVfcGF0aChjb25zdCBjaGFyICpwYXRoKTsKY29uc3QgY2hhciAqcmVtb3ZlX2xlYWRpbmdfcGF0aChjb25zdCBjaGFyICppbiwgY29uc3QgY2hhciAqcHJlZml4KTsKY29uc3QgY2hhciAqcmVsYXRpdmVfcGF0aChjb25zdCBjaGFyICppbiwgY29uc3QgY2hhciAqcHJlZml4LCBzdHJ1Y3Qgc3RyYnVmICpzYik7CmludCBub3JtYWxpemVfcGF0aF9jb3B5X2xlbihjaGFyICpkc3QsIGNvbnN0IGNoYXIgKnNyYywgaW50ICpwcmVmaXhfbGVuKTsKaW50IG5vcm1hbGl6ZV9wYXRoX2NvcHkoY2hhciAqZHN0LCBjb25zdCBjaGFyICpzcmMpOwppbnQgbG9uZ2VzdF9hbmNlc3Rvcl9sZW5ndGgoY29uc3QgY2hhciAqcGF0aCwgc3RydWN0IHN0cmluZ19saXN0ICpwcmVmaXhlcyk7CmNoYXIgKnN0cmlwX3BhdGhfc3VmZml4KGNvbnN0IGNoYXIgKnBhdGgsIGNvbnN0IGNoYXIgKnN1ZmZpeCk7CmludCBkYWVtb25fYXZvaWRfYWxpYXMoY29uc3QgY2hhciAqcGF0aCk7CmludCBvZmZzZXRfMXN0X2NvbXBvbmVudChjb25zdCBjaGFyICpwYXRoKTsKCi8qIG9iamVjdCByZXBsYWNlbWVudCAqLwojZGVmaW5lIExPT0tVUF9SRVBMQUNFX09CSkVDVCAxCmV4dGVybiB2b2lkICpyZWFkX3NoYTFfZmlsZV9leHRlbmRlZChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBlbnVtIG9iamVjdF90eXBlICp0eXBlLCB1bnNpZ25lZCBsb25nICpzaXplLCB1bnNpZ25lZCBmbGFnKTsKc3RhdGljIGlubGluZSB2b2lkICpyZWFkX3NoYTFfZmlsZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBlbnVtIG9iamVjdF90eXBlICp0eXBlLCB1bnNpZ25lZCBsb25nICpzaXplKQp7CglyZXR1cm4gcmVhZF9zaGExX2ZpbGVfZXh0ZW5kZWQoc2hhMSwgdHlwZSwgc2l6ZSwgTE9PS1VQX1JFUExBQ0VfT0JKRUNUKTsKfQpleHRlcm4gY29uc3QgdW5zaWduZWQgY2hhciAqZG9fbG9va3VwX3JlcGxhY2Vfb2JqZWN0KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpzdGF0aWMgaW5saW5lIGNvbnN0IHVuc2lnbmVkIGNoYXIgKmxvb2t1cF9yZXBsYWNlX29iamVjdChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglpZiAoIXJlYWRfcmVwbGFjZV9yZWZzKQoJCXJldHVybiBzaGExOwoJcmV0dXJuIGRvX2xvb2t1cF9yZXBsYWNlX29iamVjdChzaGExKTsKfQpzdGF0aWMgaW5saW5lIGNvbnN0IHVuc2lnbmVkIGNoYXIgKmxvb2t1cF9yZXBsYWNlX29iamVjdF9leHRlbmRlZChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCB1bnNpZ25lZCBmbGFnKQp7CglpZiAoIShmbGFnICYgTE9PS1VQX1JFUExBQ0VfT0JKRUNUKSkKCQlyZXR1cm4gc2hhMTsKCXJldHVybiBsb29rdXBfcmVwbGFjZV9vYmplY3Qoc2hhMSk7Cn0KCi8qIFJlYWQgYW5kIHVucGFjayBhIHNoYTEgZmlsZSBpbnRvIG1lbW9yeSwgd3JpdGUgbWVtb3J5IHRvIGEgc2hhMSBmaWxlICovCmV4dGVybiBpbnQgc2hhMV9vYmplY3RfaW5mbyhjb25zdCB1bnNpZ25lZCBjaGFyICosIHVuc2lnbmVkIGxvbmcgKik7CmV4dGVybiBpbnQgaGFzaF9zaGExX2ZpbGUoY29uc3Qgdm9pZCAqYnVmLCB1bnNpZ25lZCBsb25nIGxlbiwgY29uc3QgY2hhciAqdHlwZSwgdW5zaWduZWQgY2hhciAqc2hhMSk7CmV4dGVybiBpbnQgd3JpdGVfc2hhMV9maWxlKGNvbnN0IHZvaWQgKmJ1ZiwgdW5zaWduZWQgbG9uZyBsZW4sIGNvbnN0IGNoYXIgKnR5cGUsIHVuc2lnbmVkIGNoYXIgKnJldHVybl9zaGExKTsKZXh0ZXJuIGludCBwcmV0ZW5kX3NoYTFfZmlsZSh2b2lkICosIHVuc2lnbmVkIGxvbmcsIGVudW0gb2JqZWN0X3R5cGUsIHVuc2lnbmVkIGNoYXIgKik7CmV4dGVybiBpbnQgZm9yY2Vfb2JqZWN0X2xvb3NlKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIHRpbWVfdCBtdGltZSk7CmV4dGVybiB2b2lkICptYXBfc2hhMV9maWxlKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIHVuc2lnbmVkIGxvbmcgKnNpemUpOwpleHRlcm4gaW50IHVucGFja19zaGExX2hlYWRlcihnaXRfenN0cmVhbSAqc3RyZWFtLCB1bnNpZ25lZCBjaGFyICptYXAsIHVuc2lnbmVkIGxvbmcgbWFwc2l6ZSwgdm9pZCAqYnVmZmVyLCB1bnNpZ25lZCBsb25nIGJ1ZnNpeik7CmV4dGVybiBpbnQgcGFyc2Vfc2hhMV9oZWFkZXIoY29uc3QgY2hhciAqaGRyLCB1bnNpZ25lZCBsb25nICpzaXplcCk7CgovKiBnbG9iYWwgZmxhZyB0byBlbmFibGUgZXh0cmEgY2hlY2tzIHdoZW4gYWNjZXNzaW5nIHBhY2tlZCBvYmplY3RzICovCmV4dGVybiBpbnQgZG9fY2hlY2tfcGFja2VkX29iamVjdF9jcmM7CgpleHRlcm4gaW50IGNoZWNrX3NoYTFfc2lnbmF0dXJlKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIHZvaWQgKmJ1ZiwgdW5zaWduZWQgbG9uZyBzaXplLCBjb25zdCBjaGFyICp0eXBlKTsKCmV4dGVybiBpbnQgbW92ZV90ZW1wX3RvX2ZpbGUoY29uc3QgY2hhciAqdG1wZmlsZSwgY29uc3QgY2hhciAqZmlsZW5hbWUpOwoKZXh0ZXJuIGludCBoYXNfc2hhMV9wYWNrKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpleHRlcm4gaW50IGhhc19zaGExX2ZpbGUoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSk7CmV4dGVybiBpbnQgaGFzX2xvb3NlX29iamVjdF9ub25sb2NhbChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKTsKCmV4dGVybiBpbnQgaGFzX3BhY2tfaW5kZXgoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSk7CgpleHRlcm4gdm9pZCBhc3NlcnRfc2hhMV90eXBlKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIGVudW0gb2JqZWN0X3R5cGUgZXhwZWN0KTsKCmV4dGVybiBjb25zdCBzaWduZWQgY2hhciBoZXh2YWxfdGFibGVbMjU2XTsKc3RhdGljIGlubGluZSB1bnNpZ25lZCBpbnQgaGV4dmFsKHVuc2lnbmVkIGNoYXIgYykKewoJcmV0dXJuIGhleHZhbF90YWJsZVtjXTsKfQoKLyogQ29udmVydCB0by9mcm9tIGhleC9zaGExIHJlcHJlc2VudGF0aW9uICovCiNkZWZpbmUgTUlOSU1VTV9BQkJSRVYgbWluaW11bV9hYmJyZXYKI2RlZmluZSBERUZBVUxUX0FCQlJFViBkZWZhdWx0X2FiYnJldgoKc3RydWN0IG9iamVjdF9jb250ZXh0IHsKCXVuc2lnbmVkIGNoYXIgdHJlZVsyMF07CgljaGFyIHBhdGhbUEFUSF9NQVhdOwoJdW5zaWduZWQgbW9kZTsKfTsKCiNkZWZpbmUgR0VUX1NIQTFfUVVJRVRMWSAgICAgICAgMDEKI2RlZmluZSBHRVRfU0hBMV9DT01NSVQgICAgICAgICAwMgojZGVmaW5lIEdFVF9TSEExX0NPTU1JVFRJU0ggICAgIDA0CiNkZWZpbmUgR0VUX1NIQTFfVFJFRSAgICAgICAgICAwMTAKI2RlZmluZSBHRVRfU0hBMV9UUkVFSVNIICAgICAgIDAyMAojZGVmaW5lIEdFVF9TSEExX0JMT0IJICAgICAgIDA0MAojZGVmaW5lIEdFVF9TSEExX09OTFlfVE9fRElFIDA0MDAwCgpleHRlcm4gaW50IGdldF9zaGExKGNvbnN0IGNoYXIgKnN0ciwgdW5zaWduZWQgY2hhciAqc2hhMSk7CmV4dGVybiBpbnQgZ2V0X3NoYTFfY29tbWl0KGNvbnN0IGNoYXIgKnN0ciwgdW5zaWduZWQgY2hhciAqc2hhMSk7CmV4dGVybiBpbnQgZ2V0X3NoYTFfY29tbWl0dGlzaChjb25zdCBjaGFyICpzdHIsIHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpleHRlcm4gaW50IGdldF9zaGExX3RyZWUoY29uc3QgY2hhciAqc3RyLCB1bnNpZ25lZCBjaGFyICpzaGExKTsKZXh0ZXJuIGludCBnZXRfc2hhMV90cmVlaXNoKGNvbnN0IGNoYXIgKnN0ciwgdW5zaWduZWQgY2hhciAqc2hhMSk7CmV4dGVybiBpbnQgZ2V0X3NoYTFfYmxvYihjb25zdCBjaGFyICpzdHIsIHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpleHRlcm4gdm9pZCBtYXliZV9kaWVfb25fbWlzc3BlbHRfb2JqZWN0X25hbWUoY29uc3QgY2hhciAqbmFtZSwgY29uc3QgY2hhciAqcHJlZml4KTsKZXh0ZXJuIGludCBnZXRfc2hhMV93aXRoX2NvbnRleHQoY29uc3QgY2hhciAqc3RyLCB1bnNpZ25lZCBmbGFncywgdW5zaWduZWQgY2hhciAqc2hhMSwgc3RydWN0IG9iamVjdF9jb250ZXh0ICpvcmMpOwoKdHlwZWRlZiBpbnQgZWFjaF9hYmJyZXZfZm4oY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgdm9pZCAqKTsKZXh0ZXJuIGludCBmb3JfZWFjaF9hYmJyZXYoY29uc3QgY2hhciAqcHJlZml4LCBlYWNoX2FiYnJldl9mbiwgdm9pZCAqKTsKCi8qCiAqIFRyeSB0byByZWFkIGEgU0hBMSBpbiBoZXhhZGVjaW1hbCBmb3JtYXQgZnJvbSB0aGUgNDAgY2hhcmFjdGVycwogKiBzdGFydGluZyBhdCBoZXguICBXcml0ZSB0aGUgMjAtYnl0ZSByZXN1bHQgdG8gc2hhMSBpbiBiaW5hcnkgZm9ybS4KICogUmV0dXJuIDAgb24gc3VjY2Vzcy4gIFJlYWRpbmcgc3RvcHMgaWYgYSBOVUwgaXMgZW5jb3VudGVyZWQgaW4gdGhlCiAqIGlucHV0LCBzbyBpdCBpcyBzYWZlIHRvIHBhc3MgdGhpcyBmdW5jdGlvbiBhbiBhcmJpdHJhcnkKICogbnVsbC10ZXJtaW5hdGVkIHN0cmluZy4KICovCmV4dGVybiBpbnQgZ2V0X3NoYTFfaGV4KGNvbnN0IGNoYXIgKmhleCwgdW5zaWduZWQgY2hhciAqc2hhMSk7CgpleHRlcm4gY2hhciAqc2hhMV90b19oZXgoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSk7CS8qIHN0YXRpYyBidWZmZXIgcmVzdWx0ISAqLwpleHRlcm4gaW50IHJlYWRfcmVmX2Z1bGwoY29uc3QgY2hhciAqcmVmbmFtZSwgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkJIGludCByZWFkaW5nLCBpbnQgKmZsYWdzKTsKZXh0ZXJuIGludCByZWFkX3JlZihjb25zdCBjaGFyICpyZWZuYW1lLCB1bnNpZ25lZCBjaGFyICpzaGExKTsKCi8qCiAqIFJlc29sdmUgYSByZWZlcmVuY2UsIHJlY3Vyc2l2ZWx5IGZvbGxvd2luZyBzeW1ib2xpYyByZWZlcmVyZW5jZXMuCiAqCiAqIFN0b3JlIHRoZSByZWZlcnJlZC10byBvYmplY3QncyBuYW1lIGluIHNoYTEgYW5kIHJldHVybiB0aGUgbmFtZSBvZgogKiB0aGUgbm9uLXN5bWJvbGljIHJlZmVyZW5jZSB0aGF0IHVsdGltYXRlbHkgcG9pbnRlZCBhdCBpdC4gIFRoZQogKiByZXR1cm4gdmFsdWUsIGlmIG5vdCBOVUxMLCBpcyBhIHBvaW50ZXIgaW50byBlaXRoZXIgYSBzdGF0aWMgYnVmZmVyCiAqIG9yIHRoZSBpbnB1dCByZWYuCiAqCiAqIElmIHRoZSByZWZlcmVuY2UgY2Fubm90IGJlIHJlc29sdmVkIHRvIGFuIG9iamVjdCwgdGhlIGJlaGF2aW9yCiAqIGRlcGVuZHMgb24gdGhlICJyZWFkaW5nIiBhcmd1bWVudDoKICoKICogLSBJZiByZWFkaW5nIGlzIHNldCwgcmV0dXJuIE5VTEwuCiAqCiAqIC0gSWYgcmVhZGluZyBpcyBub3Qgc2V0LCBjbGVhciBzaGExIGFuZCByZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGxhc3QKICogICByZWZlcmVuY2UgbmFtZSBpbiB0aGUgY2hhaW4sIHdoaWNoIHdpbGwgZWl0aGVyIGJlIGEgbm9uLXN5bWJvbGljCiAqICAgcmVmZXJlbmNlIG9yIGFuIHVuZGVmaW5lZCByZWZlcmVuY2UuICBJZiB0aGlzIGlzIGEgcHJlbHVkZSB0bwogKiAgICJ3cml0aW5nIiB0byB0aGUgcmVmLCB0aGUgcmV0dXJuIHZhbHVlIGlzIHRoZSBuYW1lIG9mIHRoZSByZWYKICogICB0aGF0IHdpbGwgYWN0dWFsbHkgYmUgY3JlYXRlZCBvciBjaGFuZ2VkLgogKgogKiBJZiBmbGFnIGlzIG5vbi1OVUxMLCBzZXQgdGhlIHZhbHVlIHRoYXQgaXQgcG9pbnRzIHRvIHRoZQogKiBjb21iaW5hdGlvbiBvZiBSRUZfSVNQQUNLRUQgKGlmIHRoZSByZWZlcmVuY2Ugd2FzIGZvdW5kIGFtb25nIHRoZQogKiBwYWNrZWQgcmVmZXJlbmNlcykgYW5kIFJFRl9JU1NZTVJFRiAoaWYgdGhlIGluaXRpYWwgcmVmZXJlbmNlIHdhcyBhCiAqIHN5bWJvbGljIHJlZmVyZW5jZSkuCiAqCiAqIElmIHJlZiBpcyBub3QgYSBwcm9wZXJseS1mb3JtYXR0ZWQsIG5vcm1hbGl6ZWQgcmVmZXJlbmNlLCByZXR1cm4KICogTlVMTC4gIElmIG1vcmUgdGhhbiBNQVhERVBUSCByZWN1cnNpdmUgc3ltYm9saWMgbG9va3VwcyBhcmUgbmVlZGVkLAogKiBnaXZlIHVwIGFuZCByZXR1cm4gTlVMTC4KICoKICogZXJybm8gaXMgc29tZXRpbWVzIHNldCBvbiBlcnJvcnMsIGJ1dCBub3QgYWx3YXlzLgogKi8KZXh0ZXJuIGNvbnN0IGNoYXIgKnJlc29sdmVfcmVmX3Vuc2FmZShjb25zdCBjaGFyICpyZWYsIHVuc2lnbmVkIGNoYXIgKnNoYTEsIGludCByZWFkaW5nLCBpbnQgKmZsYWcpOwpleHRlcm4gY2hhciAqcmVzb2x2ZV9yZWZkdXAoY29uc3QgY2hhciAqcmVmLCB1bnNpZ25lZCBjaGFyICpzaGExLCBpbnQgcmVhZGluZywgaW50ICpmbGFnKTsKCmV4dGVybiBpbnQgZHdpbV9yZWYoY29uc3QgY2hhciAqc3RyLCBpbnQgbGVuLCB1bnNpZ25lZCBjaGFyICpzaGExLCBjaGFyICoqcmVmKTsKZXh0ZXJuIGludCBkd2ltX2xvZyhjb25zdCBjaGFyICpzdHIsIGludCBsZW4sIHVuc2lnbmVkIGNoYXIgKnNoYTEsIGNoYXIgKipyZWYpOwpleHRlcm4gaW50IGludGVycHJldF9icmFuY2hfbmFtZShjb25zdCBjaGFyICpzdHIsIGludCBsZW4sIHN0cnVjdCBzdHJidWYgKik7CmV4dGVybiBpbnQgZ2V0X3NoYTFfbWIoY29uc3QgY2hhciAqc3RyLCB1bnNpZ25lZCBjaGFyICpzaGExKTsKCi8qCiAqIFJldHVybiB0cnVlIGlmZiBhYmJyZXZfbmFtZSBpcyBhIHBvc3NpYmxlIGFiYnJldmlhdGlvbiBmb3IKICogZnVsbF9uYW1lIGFjY29yZGluZyB0byB0aGUgcnVsZXMgZGVmaW5lZCBieSByZWZfcmV2X3BhcnNlX3J1bGVzIGluCiAqIHJlZnMuYy4KICovCmV4dGVybiBpbnQgcmVmbmFtZV9tYXRjaChjb25zdCBjaGFyICphYmJyZXZfbmFtZSwgY29uc3QgY2hhciAqZnVsbF9uYW1lKTsKCmV4dGVybiBpbnQgY3JlYXRlX3N5bXJlZihjb25zdCBjaGFyICpyZWYsIGNvbnN0IGNoYXIgKnJlZnNfaGVhZHNfbWFzdGVyLCBjb25zdCBjaGFyICpsb2dtc2cpOwpleHRlcm4gaW50IHZhbGlkYXRlX2hlYWRyZWYoY29uc3QgY2hhciAqcmVmKTsKCmV4dGVybiBpbnQgYmFzZV9uYW1lX2NvbXBhcmUoY29uc3QgY2hhciAqbmFtZTEsIGludCBsZW4xLCBpbnQgbW9kZTEsIGNvbnN0IGNoYXIgKm5hbWUyLCBpbnQgbGVuMiwgaW50IG1vZGUyKTsKZXh0ZXJuIGludCBkZl9uYW1lX2NvbXBhcmUoY29uc3QgY2hhciAqbmFtZTEsIGludCBsZW4xLCBpbnQgbW9kZTEsIGNvbnN0IGNoYXIgKm5hbWUyLCBpbnQgbGVuMiwgaW50IG1vZGUyKTsKZXh0ZXJuIGludCBjYWNoZV9uYW1lX2NvbXBhcmUoY29uc3QgY2hhciAqbmFtZTEsIGludCBsZW4xLCBjb25zdCBjaGFyICpuYW1lMiwgaW50IGxlbjIpOwpleHRlcm4gaW50IGNhY2hlX25hbWVfc3RhZ2VfY29tcGFyZShjb25zdCBjaGFyICpuYW1lMSwgaW50IGxlbjEsIGludCBzdGFnZTEsIGNvbnN0IGNoYXIgKm5hbWUyLCBpbnQgbGVuMiwgaW50IHN0YWdlMik7CgpleHRlcm4gdm9pZCAqcmVhZF9vYmplY3Rfd2l0aF9yZWZlcmVuY2UoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkJCQljb25zdCBjaGFyICpyZXF1aXJlZF90eXBlLAoJCQkJCXVuc2lnbmVkIGxvbmcgKnNpemUsCgkJCQkJdW5zaWduZWQgY2hhciAqc2hhMV9yZXQpOwoKZXh0ZXJuIHN0cnVjdCBvYmplY3QgKnBlZWxfdG9fdHlwZShjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbiwKCQkJCSAgIHN0cnVjdCBvYmplY3QgKm8sIGVudW0gb2JqZWN0X3R5cGUpOwoKZW51bSBkYXRlX21vZGUgewoJREFURV9OT1JNQUwgPSAwLAoJREFURV9SRUxBVElWRSwKCURBVEVfU0hPUlQsCglEQVRFX0xPQ0FMLAoJREFURV9JU084NjAxLAoJREFURV9SRkMyODIyLAoJREFURV9SQVcKfTsKCmNvbnN0IGNoYXIgKnNob3dfZGF0ZSh1bnNpZ25lZCBsb25nIHRpbWUsIGludCB0aW1lem9uZSwgZW51bSBkYXRlX21vZGUgbW9kZSk7CnZvaWQgc2hvd19kYXRlX3JlbGF0aXZlKHVuc2lnbmVkIGxvbmcgdGltZSwgaW50IHR6LCBjb25zdCBzdHJ1Y3QgdGltZXZhbCAqbm93LAoJCQlzdHJ1Y3Qgc3RyYnVmICp0aW1lYnVmKTsKaW50IHBhcnNlX2RhdGUoY29uc3QgY2hhciAqZGF0ZSwgY2hhciAqYnVmLCBpbnQgYnVmc2l6ZSk7CmludCBwYXJzZV9kYXRlX2Jhc2ljKGNvbnN0IGNoYXIgKmRhdGUsIHVuc2lnbmVkIGxvbmcgKnRpbWVzdGFtcCwgaW50ICpvZmZzZXQpOwppbnQgcGFyc2VfZXhwaXJ5X2RhdGUoY29uc3QgY2hhciAqZGF0ZSwgdW5zaWduZWQgbG9uZyAqdGltZXN0YW1wKTsKdm9pZCBkYXRlc3RhbXAoY2hhciAqYnVmLCBpbnQgYnVmc2l6ZSk7CiNkZWZpbmUgYXBwcm94aWRhdGUocykgYXBwcm94aWRhdGVfY2FyZWZ1bCgocyksIE5VTEwpCnVuc2lnbmVkIGxvbmcgYXBwcm94aWRhdGVfY2FyZWZ1bChjb25zdCBjaGFyICosIGludCAqKTsKdW5zaWduZWQgbG9uZyBhcHByb3hpZGF0ZV9yZWxhdGl2ZShjb25zdCBjaGFyICpkYXRlLCBjb25zdCBzdHJ1Y3QgdGltZXZhbCAqbm93KTsKZW51bSBkYXRlX21vZGUgcGFyc2VfZGF0ZV9mb3JtYXQoY29uc3QgY2hhciAqZm9ybWF0KTsKaW50IGRhdGVfb3ZlcmZsb3dzKHVuc2lnbmVkIGxvbmcgZGF0ZSk7CgojZGVmaW5lIElERU5UX1NUUklDVAkgICAgICAgMQojZGVmaW5lIElERU5UX05PX0RBVEUJICAgICAgIDIKI2RlZmluZSBJREVOVF9OT19OQU1FCSAgICAgICA0CmV4dGVybiBjb25zdCBjaGFyICpnaXRfYXV0aG9yX2luZm8oaW50KTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdpdF9jb21taXR0ZXJfaW5mbyhpbnQpOwpleHRlcm4gY29uc3QgY2hhciAqZm10X2lkZW50KGNvbnN0IGNoYXIgKm5hbWUsIGNvbnN0IGNoYXIgKmVtYWlsLCBjb25zdCBjaGFyICpkYXRlX3N0ciwgaW50KTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmZtdF9uYW1lKGNvbnN0IGNoYXIgKm5hbWUsIGNvbnN0IGNoYXIgKmVtYWlsKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmlkZW50X2RlZmF1bHRfZW1haWwodm9pZCk7CmV4dGVybiBjb25zdCBjaGFyICpnaXRfZWRpdG9yKHZvaWQpOwpleHRlcm4gY29uc3QgY2hhciAqZ2l0X3BhZ2VyKGludCBzdGRvdXRfaXNfdHR5KTsKZXh0ZXJuIGludCBnaXRfaWRlbnRfY29uZmlnKGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqLCB2b2lkICopOwoKc3RydWN0IGlkZW50X3NwbGl0IHsKCWNvbnN0IGNoYXIgKm5hbWVfYmVnaW47Cgljb25zdCBjaGFyICpuYW1lX2VuZDsKCWNvbnN0IGNoYXIgKm1haWxfYmVnaW47Cgljb25zdCBjaGFyICptYWlsX2VuZDsKCWNvbnN0IGNoYXIgKmRhdGVfYmVnaW47Cgljb25zdCBjaGFyICpkYXRlX2VuZDsKCWNvbnN0IGNoYXIgKnR6X2JlZ2luOwoJY29uc3QgY2hhciAqdHpfZW5kOwp9OwovKgogKiBTaWduYWxzIGFuIHN1Y2Nlc3Mgd2l0aCAwLCBidXQgdGltZSBwYXJ0IG9mIHRoZSByZXN1bHQgbWF5IGJlIE5VTEwKICogaWYgdGhlIGlucHV0IGxhY2tzIHRpbWVzdGFtcCBhbmQgem9uZQogKi8KZXh0ZXJuIGludCBzcGxpdF9pZGVudF9saW5lKHN0cnVjdCBpZGVudF9zcGxpdCAqLCBjb25zdCBjaGFyICosIGludCk7CgovKgogKiBDb21wYXJlIHNwbGl0IGlkZW50cyBmb3IgZXF1YWxpdHkgb3Igc3RyaWN0IG9yZGVyaW5nLiBOb3RlIHRoYXQgd2UKICogY29tcGFyZSBvbmx5IHRoZSBpZGVudCBwYXJ0IG9mIHRoZSBsaW5lLCBpZ25vcmluZyBhbnkgdGltZXN0YW1wLgogKgogKiBCZWNhdXNlIHRoZXJlIGFyZSB0d28gZmllbGRzLCB3ZSBtdXN0IGNob29zZSBvbmUgYXMgdGhlIHByaW1hcnkga2V5OyB3ZQogKiBjdXJyZW50bHkgYXJiaXRyYXJpbHkgcGljayB0aGUgZW1haWwuCiAqLwpleHRlcm4gaW50IGlkZW50X2NtcChjb25zdCBzdHJ1Y3QgaWRlbnRfc3BsaXQgKiwgY29uc3Qgc3RydWN0IGlkZW50X3NwbGl0ICopOwoKc3RydWN0IGNoZWNrb3V0IHsKCWNvbnN0IGNoYXIgKmJhc2VfZGlyOwoJaW50IGJhc2VfZGlyX2xlbjsKCXVuc2lnbmVkIGZvcmNlOjEsCgkJIHF1aWV0OjEsCgkJIG5vdF9uZXc6MSwKCQkgcmVmcmVzaF9jYWNoZToxOwp9OwoKI2RlZmluZSBURU1QT1JBUllfRklMRU5BTUVfTEVOR1RIIDI1CmV4dGVybiBpbnQgY2hlY2tvdXRfZW50cnkoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgY29uc3Qgc3RydWN0IGNoZWNrb3V0ICpzdGF0ZSwgY2hhciAqdG9wYXRoKTsKCnN0cnVjdCBjYWNoZV9kZWYgewoJY2hhciBwYXRoW1BBVEhfTUFYICsgMV07CglpbnQgbGVuOwoJaW50IGZsYWdzOwoJaW50IHRyYWNrX2ZsYWdzOwoJaW50IHByZWZpeF9sZW5fc3RhdF9mdW5jOwp9OwoKZXh0ZXJuIGludCBoYXNfc3ltbGlua19sZWFkaW5nX3BhdGgoY29uc3QgY2hhciAqbmFtZSwgaW50IGxlbik7CmV4dGVybiBpbnQgdGhyZWFkZWRfaGFzX3N5bWxpbmtfbGVhZGluZ19wYXRoKHN0cnVjdCBjYWNoZV9kZWYgKiwgY29uc3QgY2hhciAqLCBpbnQpOwpleHRlcm4gaW50IGNoZWNrX2xlYWRpbmdfcGF0aChjb25zdCBjaGFyICpuYW1lLCBpbnQgbGVuKTsKZXh0ZXJuIGludCBoYXNfZGlyc19vbmx5X3BhdGgoY29uc3QgY2hhciAqbmFtZSwgaW50IGxlbiwgaW50IHByZWZpeF9sZW4pOwpleHRlcm4gdm9pZCBzY2hlZHVsZV9kaXJfZm9yX3JlbW92YWwoY29uc3QgY2hhciAqbmFtZSwgaW50IGxlbik7CmV4dGVybiB2b2lkIHJlbW92ZV9zY2hlZHVsZWRfZGlycyh2b2lkKTsKCmV4dGVybiBzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSB7CglzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSAqbmV4dDsKCWNoYXIgKm5hbWU7CgljaGFyIGJhc2VbRkxFWF9BUlJBWV07IC8qIG1vcmUgKi8KfSAqYWx0X29kYl9saXN0OwpleHRlcm4gdm9pZCBwcmVwYXJlX2FsdF9vZGIodm9pZCk7CmV4dGVybiB2b2lkIHJlYWRfaW5mb19hbHRlcm5hdGVzKGNvbnN0IGNoYXIgKiByZWxhdGl2ZV9iYXNlLCBpbnQgZGVwdGgpOwpleHRlcm4gdm9pZCBhZGRfdG9fYWx0ZXJuYXRlc19maWxlKGNvbnN0IGNoYXIgKnJlZmVyZW5jZSk7CnR5cGVkZWYgaW50IGFsdF9vZGJfZm4oc3RydWN0IGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UgKiwgdm9pZCAqKTsKZXh0ZXJuIHZvaWQgZm9yZWFjaF9hbHRfb2RiKGFsdF9vZGJfZm4sIHZvaWQqKTsKCnN0cnVjdCBwYWNrX3dpbmRvdyB7CglzdHJ1Y3QgcGFja193aW5kb3cgKm5leHQ7Cgl1bnNpZ25lZCBjaGFyICpiYXNlOwoJb2ZmX3Qgb2Zmc2V0OwoJc2l6ZV90IGxlbjsKCXVuc2lnbmVkIGludCBsYXN0X3VzZWQ7Cgl1bnNpZ25lZCBpbnQgaW51c2VfY250Owp9OwoKZXh0ZXJuIHN0cnVjdCBwYWNrZWRfZ2l0IHsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpuZXh0OwoJc3RydWN0IHBhY2tfd2luZG93ICp3aW5kb3dzOwoJb2ZmX3QgcGFja19zaXplOwoJY29uc3Qgdm9pZCAqaW5kZXhfZGF0YTsKCXNpemVfdCBpbmRleF9zaXplOwoJdWludDMyX3QgbnVtX29iamVjdHM7Cgl1aW50MzJfdCBudW1fYmFkX29iamVjdHM7Cgl1bnNpZ25lZCBjaGFyICpiYWRfb2JqZWN0X3NoYTE7CglpbnQgaW5kZXhfdmVyc2lvbjsKCXRpbWVfdCBtdGltZTsKCWludCBwYWNrX2ZkOwoJdW5zaWduZWQgcGFja19sb2NhbDoxLAoJCSBwYWNrX2tlZXA6MSwKCQkgZG9fbm90X2Nsb3NlOjE7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJLyogc29tZXRoaW5nIGxpa2UgIi5naXQvb2JqZWN0cy9wYWNrL3h4eHh4LnBhY2siICovCgljaGFyIHBhY2tfbmFtZVtGTEVYX0FSUkFZXTsgLyogbW9yZSAqLwp9ICpwYWNrZWRfZ2l0OwoKc3RydWN0IHBhY2tfZW50cnkgewoJb2ZmX3Qgb2Zmc2V0OwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwOwp9OwoKZXh0ZXJuIHN0cnVjdCBwYWNrZWRfZ2l0ICpwYXJzZV9wYWNrX2luZGV4KHVuc2lnbmVkIGNoYXIgKnNoYTEsIGNvbnN0IGNoYXIgKmlkeF9wYXRoKTsKCi8qIEEgaG9vayBmb3IgY291bnQtb2JqZWN0cyB0byByZXBvcnQgaW52YWxpZCBmaWxlcyBpbiBwYWNrIGRpcmVjdG9yeSAqLwpleHRlcm4gdm9pZCAoKnJlcG9ydF9nYXJiYWdlKShjb25zdCBjaGFyICpkZXNjLCBjb25zdCBjaGFyICpwYXRoKTsKCmV4dGVybiB2b2lkIHByZXBhcmVfcGFja2VkX2dpdCh2b2lkKTsKZXh0ZXJuIHZvaWQgcmVwcmVwYXJlX3BhY2tlZF9naXQodm9pZCk7CmV4dGVybiB2b2lkIGluc3RhbGxfcGFja2VkX2dpdChzdHJ1Y3QgcGFja2VkX2dpdCAqcGFjayk7CgpleHRlcm4gc3RydWN0IHBhY2tlZF9naXQgKmZpbmRfc2hhMV9wYWNrKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsCgkJCQkJIHN0cnVjdCBwYWNrZWRfZ2l0ICpwYWNrcyk7CgpleHRlcm4gdm9pZCBwYWNrX3JlcG9ydCh2b2lkKTsKZXh0ZXJuIGludCBvcGVuX3BhY2tfaW5kZXgoc3RydWN0IHBhY2tlZF9naXQgKik7CmV4dGVybiB2b2lkIGNsb3NlX3BhY2tfaW5kZXgoc3RydWN0IHBhY2tlZF9naXQgKik7CmV4dGVybiB1bnNpZ25lZCBjaGFyICp1c2VfcGFjayhzdHJ1Y3QgcGFja2VkX2dpdCAqLCBzdHJ1Y3QgcGFja193aW5kb3cgKiosIG9mZl90LCB1bnNpZ25lZCBsb25nICopOwpleHRlcm4gdm9pZCBjbG9zZV9wYWNrX3dpbmRvd3Moc3RydWN0IHBhY2tlZF9naXQgKik7CmV4dGVybiB2b2lkIHVudXNlX3BhY2soc3RydWN0IHBhY2tfd2luZG93ICoqKTsKZXh0ZXJuIHZvaWQgZnJlZV9wYWNrX2J5X25hbWUoY29uc3QgY2hhciAqKTsKZXh0ZXJuIHZvaWQgY2xlYXJfZGVsdGFfYmFzZV9jYWNoZSh2b2lkKTsKZXh0ZXJuIHN0cnVjdCBwYWNrZWRfZ2l0ICphZGRfcGFja2VkX2dpdChjb25zdCBjaGFyICosIGludCwgaW50KTsKZXh0ZXJuIGNvbnN0IHVuc2lnbmVkIGNoYXIgKm50aF9wYWNrZWRfb2JqZWN0X3NoYTEoc3RydWN0IHBhY2tlZF9naXQgKiwgdWludDMyX3QpOwpleHRlcm4gb2ZmX3QgbnRoX3BhY2tlZF9vYmplY3Rfb2Zmc2V0KGNvbnN0IHN0cnVjdCBwYWNrZWRfZ2l0ICosIHVpbnQzMl90KTsKZXh0ZXJuIG9mZl90IGZpbmRfcGFja19lbnRyeV9vbmUoY29uc3QgdW5zaWduZWQgY2hhciAqLCBzdHJ1Y3QgcGFja2VkX2dpdCAqKTsKZXh0ZXJuIGludCBpc19wYWNrX3ZhbGlkKHN0cnVjdCBwYWNrZWRfZ2l0ICopOwpleHRlcm4gdm9pZCAqdW5wYWNrX2VudHJ5KHN0cnVjdCBwYWNrZWRfZ2l0ICosIG9mZl90LCBlbnVtIG9iamVjdF90eXBlICosIHVuc2lnbmVkIGxvbmcgKik7CmV4dGVybiB1bnNpZ25lZCBsb25nIHVucGFja19vYmplY3RfaGVhZGVyX2J1ZmZlcihjb25zdCB1bnNpZ25lZCBjaGFyICpidWYsIHVuc2lnbmVkIGxvbmcgbGVuLCBlbnVtIG9iamVjdF90eXBlICp0eXBlLCB1bnNpZ25lZCBsb25nICpzaXplcCk7CmV4dGVybiB1bnNpZ25lZCBsb25nIGdldF9zaXplX2Zyb21fZGVsdGEoc3RydWN0IHBhY2tlZF9naXQgKiwgc3RydWN0IHBhY2tfd2luZG93ICoqLCBvZmZfdCk7CmV4dGVybiBpbnQgdW5wYWNrX29iamVjdF9oZWFkZXIoc3RydWN0IHBhY2tlZF9naXQgKiwgc3RydWN0IHBhY2tfd2luZG93ICoqLCBvZmZfdCAqLCB1bnNpZ25lZCBsb25nICopOwoKc3RydWN0IG9iamVjdF9pbmZvIHsKCS8qIFJlcXVlc3QgKi8KCWVudW0gb2JqZWN0X3R5cGUgKnR5cGVwOwoJdW5zaWduZWQgbG9uZyAqc2l6ZXA7Cgl1bnNpZ25lZCBsb25nICpkaXNrX3NpemVwOwoJdW5zaWduZWQgY2hhciAqZGVsdGFfYmFzZV9zaGExOwoKCS8qIFJlc3BvbnNlICovCgllbnVtIHsKCQlPSV9DQUNIRUQsCgkJT0lfTE9PU0UsCgkJT0lfUEFDS0VELAoJCU9JX0RCQ0FDSEVECgl9IHdoZW5jZTsKCXVuaW9uIHsKCQkvKgoJCSAqIHN0cnVjdCB7CgkJICogCS4uLiBOb3RoaW5nIHRvIGV4cG9zZSBpbiB0aGlzIGNhc2UKCQkgKiB9IGNhY2hlZDsKCQkgKiBzdHJ1Y3QgewoJCSAqIAkuLi4gTm90aGluZyB0byBleHBvc2UgaW4gdGhpcyBjYXNlCgkJICogfSBsb29zZTsKCQkgKi8KCQlzdHJ1Y3QgewoJCQlzdHJ1Y3QgcGFja2VkX2dpdCAqcGFjazsKCQkJb2ZmX3Qgb2Zmc2V0OwoJCQl1bnNpZ25lZCBpbnQgaXNfZGVsdGE7CgkJfSBwYWNrZWQ7Cgl9IHU7Cn07CmV4dGVybiBpbnQgc2hhMV9vYmplY3RfaW5mb19leHRlbmRlZChjb25zdCB1bnNpZ25lZCBjaGFyICosIHN0cnVjdCBvYmplY3RfaW5mbyAqLCB1bnNpZ25lZCBmbGFncyk7CgovKiBEdW1iIHNlcnZlcnMgc3VwcG9ydCAqLwpleHRlcm4gaW50IHVwZGF0ZV9zZXJ2ZXJfaW5mbyhpbnQpOwoKLyogZ2l0X2NvbmZpZ19wYXJzZV9rZXkoKSByZXR1cm5zIHRoZXNlIG5lZ2F0ZWQ6ICovCiNkZWZpbmUgQ09ORklHX0lOVkFMSURfS0VZIDEKI2RlZmluZSBDT05GSUdfTk9fU0VDVElPTl9PUl9OQU1FIDIKLyogZ2l0X2NvbmZpZ19zZXQoKSwgZ2l0X2NvbmZpZ19zZXRfbXVsdGl2YXIoKSByZXR1cm4gdGhlIGFib3ZlIG9yIHRoZXNlOiAqLwojZGVmaW5lIENPTkZJR19OT19MT0NLIC0xCiNkZWZpbmUgQ09ORklHX0lOVkFMSURfRklMRSAzCiNkZWZpbmUgQ09ORklHX05PX1dSSVRFIDQKI2RlZmluZSBDT05GSUdfTk9USElOR19TRVQgNQojZGVmaW5lIENPTkZJR19JTlZBTElEX1BBVFRFUk4gNgojZGVmaW5lIENPTkZJR19HRU5FUklDX0VSUk9SIDcKCnR5cGVkZWYgaW50ICgqY29uZmlnX2ZuX3QpKGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqLCB2b2lkICopOwpleHRlcm4gaW50IGdpdF9kZWZhdWx0X2NvbmZpZyhjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKiwgdm9pZCAqKTsKZXh0ZXJuIGludCBnaXRfY29uZmlnX2Zyb21fZmlsZShjb25maWdfZm5fdCBmbiwgY29uc3QgY2hhciAqLCB2b2lkICopOwpleHRlcm4gaW50IGdpdF9jb25maWdfZnJvbV9idWYoY29uZmlnX2ZuX3QgZm4sIGNvbnN0IGNoYXIgKm5hbWUsCgkJCSAgICAgICBjb25zdCBjaGFyICpidWYsIHNpemVfdCBsZW4sIHZvaWQgKmRhdGEpOwpleHRlcm4gdm9pZCBnaXRfY29uZmlnX3B1c2hfcGFyYW1ldGVyKGNvbnN0IGNoYXIgKnRleHQpOwpleHRlcm4gaW50IGdpdF9jb25maWdfZnJvbV9wYXJhbWV0ZXJzKGNvbmZpZ19mbl90IGZuLCB2b2lkICpkYXRhKTsKZXh0ZXJuIGludCBnaXRfY29uZmlnKGNvbmZpZ19mbl90IGZuLCB2b2lkICopOwpleHRlcm4gaW50IGdpdF9jb25maWdfd2l0aF9vcHRpb25zKGNvbmZpZ19mbl90IGZuLCB2b2lkICosCgkJCQkgICBjb25zdCBjaGFyICpmaWxlbmFtZSwKCQkJCSAgIGNvbnN0IGNoYXIgKmJsb2JfcmVmLAoJCQkJICAgaW50IHJlc3BlY3RfaW5jbHVkZXMpOwpleHRlcm4gaW50IGdpdF9jb25maWdfZWFybHkoY29uZmlnX2ZuX3QgZm4sIHZvaWQgKiwgY29uc3QgY2hhciAqcmVwb19jb25maWcpOwpleHRlcm4gaW50IGdpdF9wYXJzZV91bG9uZyhjb25zdCBjaGFyICosIHVuc2lnbmVkIGxvbmcgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19pbnQoY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICopOwpleHRlcm4gaW50NjRfdCBnaXRfY29uZmlnX2ludDY0KGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqKTsKZXh0ZXJuIHVuc2lnbmVkIGxvbmcgZ2l0X2NvbmZpZ191bG9uZyhjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19ib29sX29yX2ludChjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKiwgaW50ICopOwpleHRlcm4gaW50IGdpdF9jb25maWdfYm9vbChjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19tYXliZV9ib29sKGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqKTsKZXh0ZXJuIGludCBnaXRfY29uZmlnX3N0cmluZyhjb25zdCBjaGFyICoqLCBjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19wYXRobmFtZShjb25zdCBjaGFyICoqLCBjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19zZXRfaW5fZmlsZShjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqKTsKZXh0ZXJuIGludCBnaXRfY29uZmlnX3NldChjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19wYXJzZV9rZXkoY29uc3QgY2hhciAqLCBjaGFyICoqLCBpbnQgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19zZXRfbXVsdGl2YXIoY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKiwgaW50KTsKZXh0ZXJuIGludCBnaXRfY29uZmlnX3NldF9tdWx0aXZhcl9pbl9maWxlKGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKiwgaW50KTsKZXh0ZXJuIGludCBnaXRfY29uZmlnX3JlbmFtZV9zZWN0aW9uKGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqKTsKZXh0ZXJuIGludCBnaXRfY29uZmlnX3JlbmFtZV9zZWN0aW9uX2luX2ZpbGUoY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKik7CmV4dGVybiBjb25zdCBjaGFyICpnaXRfZXRjX2dpdGNvbmZpZyh2b2lkKTsKZXh0ZXJuIGludCBjaGVja19yZXBvc2l0b3J5X2Zvcm1hdF92ZXJzaW9uKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmNiKTsKZXh0ZXJuIGludCBnaXRfZW52X2Jvb2woY29uc3QgY2hhciAqLCBpbnQpOwpleHRlcm4gaW50IGdpdF9jb25maWdfc3lzdGVtKHZvaWQpOwpleHRlcm4gaW50IGNvbmZpZ19lcnJvcl9ub25ib29sKGNvbnN0IGNoYXIgKik7CiNpZiBkZWZpbmVkKF9fR05VQ19fKSAmJiAhIGRlZmluZWQoX19jbGFuZ19fKQojZGVmaW5lIGNvbmZpZ19lcnJvcl9ub25ib29sKHMpIChjb25maWdfZXJyb3Jfbm9uYm9vbChzKSwgY29uc3RfZXJyb3IoKSkKI2VuZGlmCmV4dGVybiBjb25zdCBjaGFyICpnZXRfbG9nX291dHB1dF9lbmNvZGluZyh2b2lkKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdldF9jb21taXRfb3V0cHV0X2VuY29kaW5nKHZvaWQpOwoKZXh0ZXJuIGludCBnaXRfY29uZmlnX3BhcnNlX3BhcmFtZXRlcihjb25zdCBjaGFyICosIGNvbmZpZ19mbl90IGZuLCB2b2lkICpkYXRhKTsKCnN0cnVjdCBjb25maWdfaW5jbHVkZV9kYXRhIHsKCWludCBkZXB0aDsKCWNvbmZpZ19mbl90IGZuOwoJdm9pZCAqZGF0YTsKfTsKI2RlZmluZSBDT05GSUdfSU5DTFVERV9JTklUIHsgMCB9CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19pbmNsdWRlKGNvbnN0IGNoYXIgKm5hbWUsIGNvbnN0IGNoYXIgKnZhbHVlLCB2b2lkICpkYXRhKTsKCi8qCiAqIE1hdGNoIGFuZCBwYXJzZSBhIGNvbmZpZyBrZXkgb2YgdGhlIGZvcm06CiAqCiAqICAgc2VjdGlvbi4oc3Vic2VjdGlvbi4pP2tleQogKgogKiAoaS5lLiwgd2hhdCBnZXRzIGhhbmRlZCB0byBhIGNvbmZpZ19mbl90KS4gVGhlIGNhbGxlciBwcm92aWRlcyB0aGUgc2VjdGlvbjsKICogd2UgcmV0dXJuIC0xIGlmIGl0IGRvZXMgbm90IG1hdGNoLCAwIG90aGVyd2lzZS4gVGhlIHN1YnNlY3Rpb24gYW5kIGtleQogKiBvdXQtcGFyYW1ldGVycyBhcmUgZmlsbGVkIGJ5IHRoZSBmdW5jdGlvbiAoYW5kIHN1YnNlY3Rpb24gaXMgTlVMTCBpZiBpdCBpcwogKiBtaXNzaW5nKS4KICovCmV4dGVybiBpbnQgcGFyc2VfY29uZmlnX2tleShjb25zdCBjaGFyICp2YXIsCgkJCSAgICBjb25zdCBjaGFyICpzZWN0aW9uLAoJCQkgICAgY29uc3QgY2hhciAqKnN1YnNlY3Rpb24sIGludCAqc3Vic2VjdGlvbl9sZW4sCgkJCSAgICBjb25zdCBjaGFyICoqa2V5KTsKCmV4dGVybiBpbnQgY29tbWl0dGVyX2lkZW50X3N1ZmZpY2llbnRseV9naXZlbih2b2lkKTsKZXh0ZXJuIGludCBhdXRob3JfaWRlbnRfc3VmZmljaWVudGx5X2dpdmVuKHZvaWQpOwoKZXh0ZXJuIGNvbnN0IGNoYXIgKmdpdF9jb21taXRfZW5jb2Rpbmc7CmV4dGVybiBjb25zdCBjaGFyICpnaXRfbG9nX291dHB1dF9lbmNvZGluZzsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdpdF9tYWlsbWFwX2ZpbGU7CmV4dGVybiBjb25zdCBjaGFyICpnaXRfbWFpbG1hcF9ibG9iOwoKLyogSU8gaGVscGVyIGZ1bmN0aW9ucyAqLwpleHRlcm4gdm9pZCBtYXliZV9mbHVzaF9vcl9kaWUoRklMRSAqLCBjb25zdCBjaGFyICopOwpleHRlcm4gaW50IGNvcHlfZmQoaW50IGlmZCwgaW50IG9mZCk7CmV4dGVybiBpbnQgY29weV9maWxlKGNvbnN0IGNoYXIgKmRzdCwgY29uc3QgY2hhciAqc3JjLCBpbnQgbW9kZSk7CmV4dGVybiBpbnQgY29weV9maWxlX3dpdGhfdGltZShjb25zdCBjaGFyICpkc3QsIGNvbnN0IGNoYXIgKnNyYywgaW50IG1vZGUpOwpleHRlcm4gdm9pZCB3cml0ZV9vcl9kaWUoaW50IGZkLCBjb25zdCB2b2lkICpidWYsIHNpemVfdCBjb3VudCk7CmV4dGVybiBpbnQgd3JpdGVfb3Jfd2hpbmUoaW50IGZkLCBjb25zdCB2b2lkICpidWYsIHNpemVfdCBjb3VudCwgY29uc3QgY2hhciAqbXNnKTsKZXh0ZXJuIGludCB3cml0ZV9vcl93aGluZV9waXBlKGludCBmZCwgY29uc3Qgdm9pZCAqYnVmLCBzaXplX3QgY291bnQsIGNvbnN0IGNoYXIgKm1zZyk7CmV4dGVybiB2b2lkIGZzeW5jX29yX2RpZShpbnQgZmQsIGNvbnN0IGNoYXIgKik7CgpleHRlcm4gc3NpemVfdCByZWFkX2luX2Z1bGwoaW50IGZkLCB2b2lkICpidWYsIHNpemVfdCBjb3VudCk7CmV4dGVybiBzc2l6ZV90IHdyaXRlX2luX2Z1bGwoaW50IGZkLCBjb25zdCB2b2lkICpidWYsIHNpemVfdCBjb3VudCk7CnN0YXRpYyBpbmxpbmUgc3NpemVfdCB3cml0ZV9zdHJfaW5fZnVsbChpbnQgZmQsIGNvbnN0IGNoYXIgKnN0cikKewoJcmV0dXJuIHdyaXRlX2luX2Z1bGwoZmQsIHN0ciwgc3RybGVuKHN0cikpOwp9CgovKiBwYWdlci5jICovCmV4dGVybiB2b2lkIHNldHVwX3BhZ2VyKHZvaWQpOwpleHRlcm4gY29uc3QgY2hhciAqcGFnZXJfcHJvZ3JhbTsKZXh0ZXJuIGludCBwYWdlcl9pbl91c2Uodm9pZCk7CmV4dGVybiBpbnQgcGFnZXJfdXNlX2NvbG9yOwpleHRlcm4gaW50IHRlcm1fY29sdW1ucyh2b2lkKTsKZXh0ZXJuIGludCBkZWNpbWFsX3dpZHRoKGludCk7CmV4dGVybiBpbnQgY2hlY2tfcGFnZXJfY29uZmlnKGNvbnN0IGNoYXIgKmNtZCk7CgpleHRlcm4gY29uc3QgY2hhciAqZWRpdG9yX3Byb2dyYW07CmV4dGVybiBjb25zdCBjaGFyICphc2twYXNzX3Byb2dyYW07CmV4dGVybiBjb25zdCBjaGFyICpleGNsdWRlc19maWxlOwoKLyogYmFzZTg1ICovCmludCBkZWNvZGVfODUoY2hhciAqZHN0LCBjb25zdCBjaGFyICpsaW5lLCBpbnQgbGluZWxlbik7CnZvaWQgZW5jb2RlXzg1KGNoYXIgKmJ1ZiwgY29uc3QgdW5zaWduZWQgY2hhciAqZGF0YSwgaW50IGJ5dGVzKTsKCi8qIGFsbG9jLmMgKi8KZXh0ZXJuIHZvaWQgKmFsbG9jX2Jsb2Jfbm9kZSh2b2lkKTsKZXh0ZXJuIHZvaWQgKmFsbG9jX3RyZWVfbm9kZSh2b2lkKTsKZXh0ZXJuIHZvaWQgKmFsbG9jX2NvbW1pdF9ub2RlKHZvaWQpOwpleHRlcm4gdm9pZCAqYWxsb2NfdGFnX25vZGUodm9pZCk7CmV4dGVybiB2b2lkICphbGxvY19vYmplY3Rfbm9kZSh2b2lkKTsKZXh0ZXJuIHZvaWQgYWxsb2NfcmVwb3J0KHZvaWQpOwoKLyogdHJhY2UuYyAqLwpfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMSwgMikpKQpleHRlcm4gdm9pZCB0cmFjZV9wcmludGYoY29uc3QgY2hhciAqZm9ybWF0LCAuLi4pOwpfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMiwgMykpKQpleHRlcm4gdm9pZCB0cmFjZV9hcmd2X3ByaW50Zihjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqZm9ybWF0LCAuLi4pOwpleHRlcm4gdm9pZCB0cmFjZV9yZXBvX3NldHVwKGNvbnN0IGNoYXIgKnByZWZpeCk7CmV4dGVybiBpbnQgdHJhY2Vfd2FudChjb25zdCBjaGFyICprZXkpOwpfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMiwgMykpKQpleHRlcm4gdm9pZCB0cmFjZV9wcmludGZfa2V5KGNvbnN0IGNoYXIgKmtleSwgY29uc3QgY2hhciAqZm10LCAuLi4pOwpleHRlcm4gdm9pZCB0cmFjZV9zdHJidWYoY29uc3QgY2hhciAqa2V5LCBjb25zdCBzdHJ1Y3Qgc3RyYnVmICpidWYpOwoKdm9pZCBwYWNrZXRfdHJhY2VfaWRlbnRpdHkoY29uc3QgY2hhciAqcHJvZyk7CgovKiBhZGQgKi8KLyoKICogcmV0dXJuIDAgaWYgc3VjY2VzcywgMSAtIGlmIGFkZGl0aW9uIG9mIGEgZmlsZSBmYWlsZWQgYW5kCiAqIEFERF9GSUxFU19JR05PUkVfRVJST1JTIHdhcyBzcGVjaWZpZWQgaW4gZmxhZ3MKICovCmludCBhZGRfZmlsZXNfdG9fY2FjaGUoY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBhdGhzcGVjLCBpbnQgZmxhZ3MpOwoKLyogZGlmZi5jICovCmV4dGVybiBpbnQgZGlmZl9hdXRvX3JlZnJlc2hfaW5kZXg7CgovKiBtYXRjaC10cmVlcy5jICovCnZvaWQgc2hpZnRfdHJlZShjb25zdCB1bnNpZ25lZCBjaGFyICosIGNvbnN0IHVuc2lnbmVkIGNoYXIgKiwgdW5zaWduZWQgY2hhciAqLCBpbnQpOwp2b2lkIHNoaWZ0X3RyZWVfYnkoY29uc3QgdW5zaWduZWQgY2hhciAqLCBjb25zdCB1bnNpZ25lZCBjaGFyICosIHVuc2lnbmVkIGNoYXIgKiwgY29uc3QgY2hhciAqKTsKCi8qCiAqIHdoaXRlc3BhY2UgcnVsZXMuCiAqIHVzZWQgYnkgYm90aCBkaWZmIGFuZCBhcHBseQogKiBsYXN0IHR3byBkaWdpdHMgYXJlIHRhYiB3aWR0aAogKi8KI2RlZmluZSBXU19CTEFOS19BVF9FT0wgICAgICAgICAwMTAwCiNkZWZpbmUgV1NfU1BBQ0VfQkVGT1JFX1RBQiAgICAgMDIwMAojZGVmaW5lIFdTX0lOREVOVF9XSVRIX05PTl9UQUIgIDA0MDAKI2RlZmluZSBXU19DUl9BVF9FT0wgICAgICAgICAgIDAxMDAwCiNkZWZpbmUgV1NfQkxBTktfQVRfRU9GICAgICAgICAwMjAwMAojZGVmaW5lIFdTX1RBQl9JTl9JTkRFTlQgICAgICAgMDQwMDAKI2RlZmluZSBXU19UUkFJTElOR19TUEFDRSAgICAgIChXU19CTEFOS19BVF9FT0x8V1NfQkxBTktfQVRfRU9GKQojZGVmaW5lIFdTX0RFRkFVTFRfUlVMRSAoV1NfVFJBSUxJTkdfU1BBQ0V8V1NfU1BBQ0VfQkVGT1JFX1RBQnw4KQojZGVmaW5lIFdTX1RBQl9XSURUSF9NQVNLICAgICAgICAwNzcKZXh0ZXJuIHVuc2lnbmVkIHdoaXRlc3BhY2VfcnVsZV9jZmc7CmV4dGVybiB1bnNpZ25lZCB3aGl0ZXNwYWNlX3J1bGUoY29uc3QgY2hhciAqKTsKZXh0ZXJuIHVuc2lnbmVkIHBhcnNlX3doaXRlc3BhY2VfcnVsZShjb25zdCBjaGFyICopOwpleHRlcm4gdW5zaWduZWQgd3NfY2hlY2soY29uc3QgY2hhciAqbGluZSwgaW50IGxlbiwgdW5zaWduZWQgd3NfcnVsZSk7CmV4dGVybiB2b2lkIHdzX2NoZWNrX2VtaXQoY29uc3QgY2hhciAqbGluZSwgaW50IGxlbiwgdW5zaWduZWQgd3NfcnVsZSwgRklMRSAqc3RyZWFtLCBjb25zdCBjaGFyICpzZXQsIGNvbnN0IGNoYXIgKnJlc2V0LCBjb25zdCBjaGFyICp3cyk7CmV4dGVybiBjaGFyICp3aGl0ZXNwYWNlX2Vycm9yX3N0cmluZyh1bnNpZ25lZCB3cyk7CmV4dGVybiB2b2lkIHdzX2ZpeF9jb3B5KHN0cnVjdCBzdHJidWYgKiwgY29uc3QgY2hhciAqLCBpbnQsIHVuc2lnbmVkLCBpbnQgKik7CmV4dGVybiBpbnQgd3NfYmxhbmtfbGluZShjb25zdCBjaGFyICpsaW5lLCBpbnQgbGVuLCB1bnNpZ25lZCB3c19ydWxlKTsKI2RlZmluZSB3c190YWJfd2lkdGgocnVsZSkgICAgICgocnVsZSkgJiBXU19UQUJfV0lEVEhfTUFTSykKCi8qIGxzLWZpbGVzICovCmludCByZXBvcnRfcGF0aF9lcnJvcihjb25zdCBjaGFyICpwc19tYXRjaGVkLCBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBhdGhzcGVjLCBjb25zdCBjaGFyICpwcmVmaXgpOwp2b2lkIG92ZXJsYXlfdHJlZV9vbl9jYWNoZShjb25zdCBjaGFyICp0cmVlX25hbWUsIGNvbnN0IGNoYXIgKnByZWZpeCk7CgpjaGFyICphbGlhc19sb29rdXAoY29uc3QgY2hhciAqYWxpYXMpOwppbnQgc3BsaXRfY21kbGluZShjaGFyICpjbWRsaW5lLCBjb25zdCBjaGFyICoqKmFyZ3YpOwovKiBUYWtlcyBhIG5lZ2F0aXZlIHZhbHVlIHJldHVybmVkIGJ5IHNwbGl0X2NtZGxpbmUgKi8KY29uc3QgY2hhciAqc3BsaXRfY21kbGluZV9zdHJlcnJvcihpbnQgY21kbGluZV9lcnJubyk7CgovKiBnaXQuYyAqLwpzdHJ1Y3Qgc3RhcnR1cF9pbmZvIHsKCWludCBoYXZlX3JlcG9zaXRvcnk7Cgljb25zdCBjaGFyICpwcmVmaXg7Cn07CmV4dGVybiBzdHJ1Y3Qgc3RhcnR1cF9pbmZvICpzdGFydHVwX2luZm87CgovKiBtZXJnZS5jICovCnN0cnVjdCBjb21taXRfbGlzdDsKaW50IHRyeV9tZXJnZV9jb21tYW5kKGNvbnN0IGNoYXIgKnN0cmF0ZWd5LCBzaXplX3QgeG9wdHNfbnIsCgkJY29uc3QgY2hhciAqKnhvcHRzLCBzdHJ1Y3QgY29tbWl0X2xpc3QgKmNvbW1vbiwKCQljb25zdCBjaGFyICpoZWFkX2FyZywgc3RydWN0IGNvbW1pdF9saXN0ICpyZW1vdGVzKTsKaW50IGNoZWNrb3V0X2Zhc3RfZm9yd2FyZChjb25zdCB1bnNpZ25lZCBjaGFyICpmcm9tLAoJCQkgIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnRvLAoJCQkgIGludCBvdmVyd3JpdGVfaWdub3JlKTsKCgppbnQgc2FuZV9leGVjdnAoY29uc3QgY2hhciAqZmlsZSwgY2hhciAqY29uc3QgYXJndltdKTsKCi8qCiAqIEEgc3RydWN0IHRvIGVuY2Fwc3VsYXRlIHRoZSBjb25jZXB0IG9mIHdoZXRoZXIgYSBmaWxlIGhhcyBjaGFuZ2VkCiAqIHNpbmNlIHdlIGxhc3QgY2hlY2tlZCBpdC4gVGhpcyB1c2VzIGNyaXRlcmlhIHNpbWlsYXIgdG8gdGhvc2UgdXNlZAogKiBmb3IgdGhlIGluZGV4LgogKi8Kc3RydWN0IHN0YXRfdmFsaWRpdHkgewoJc3RydWN0IHN0YXRfZGF0YSAqc2Q7Cn07Cgp2b2lkIHN0YXRfdmFsaWRpdHlfY2xlYXIoc3RydWN0IHN0YXRfdmFsaWRpdHkgKnN2KTsKCi8qCiAqIFJldHVybnMgMSBpZiB0aGUgcGF0aCBpcyBhIHJlZ3VsYXIgZmlsZSAob3IgYSBzeW1saW5rIHRvIGEgcmVndWxhcgogKiBmaWxlKSBhbmQgbWF0Y2hlcyB0aGUgc2F2ZWQgc3RhdF92YWxpZGl0eSwgMCBvdGhlcndpc2UuICBBIG1pc3NpbmcKICogb3IgaW5hY2Nlc3NpYmxlIGZpbGUgaXMgY29uc2lkZXJlZCBhIG1hdGNoIGlmIHRoZSBzdHJ1Y3Qgd2FzIGp1c3QKICogaW5pdGlhbGl6ZWQsIG9yIGlmIHRoZSBwcmV2aW91cyB1cGRhdGUgZm91bmQgYW4gaW5hY2Nlc3NpYmxlIGZpbGUuCiAqLwppbnQgc3RhdF92YWxpZGl0eV9jaGVjayhzdHJ1Y3Qgc3RhdF92YWxpZGl0eSAqc3YsIGNvbnN0IGNoYXIgKnBhdGgpOwoKLyoKICogVXBkYXRlIHRoZSBzdGF0X3ZhbGlkaXR5IGZyb20gYSBmaWxlIG9wZW5lZCBhdCBkZXNjcmlwdG9yIGZkLiBJZgogKiB0aGUgZmlsZSBpcyBtaXNzaW5nLCBpbmFjY2Vzc2libGUsIG9yIG5vdCBhIHJlZ3VsYXIgZmlsZSwgdGhlbgogKiBmdXR1cmUgY2FsbHMgdG8gc3RhdF92YWxpZGl0eV9jaGVjayB3aWxsIG1hdGNoIGlmZiBvbmUgb2YgdGhvc2UKICogY29uZGl0aW9ucyBjb250aW51ZXMgdG8gYmUgdHJ1ZS4KICovCnZvaWQgc3RhdF92YWxpZGl0eV91cGRhdGUoc3RydWN0IHN0YXRfdmFsaWRpdHkgKnN2LCBpbnQgZmQpOwoKI2VuZGlmIC8qIENBQ0hFX0ggKi8K",
    "text": "#ifndef CACHE_H\n#define CACHE_H\n\n#include \"git-compat-util.h\"\n#include \"strbuf.h\"\n#include \"hash.h\"\n#include \"advice.h\"\n#include \"gettext.h\"\n#include \"convert.h\"\n\n#include SHA1_HEADER\n#ifndef git_SHA_CTX\n#define git_SHA_CTX\tSHA_CTX\n#define git_SHA1_Init\tSHA1_Init\n#define git_SHA1_Update\tSHA1_Update\n#define git_SHA1_Final\tSHA1_Final\n#endif\n\n#include <zlib.h>\ntypedef struct git_zstream {\n\tz_stream z;\n\tunsigned long avail_in;\n\tunsigned long avail_out;\n\tunsigned long total_in;\n\tunsigned long total_out;\n\tunsigned char *next_in;\n\tunsigned char *next_out;\n} git_zstream;\n\nvoid git_inflate_init(git_zstream *);\nvoid git_inflate_init_gzip_only(git_zstream *);\nvoid git_inflate_end(git_zstream *);\nint git_inflate(git_zstream *, int flush);\n\nvoid git_deflate_init(git_zstream *, int level);\nvoid git_deflate_init_gzip(git_zstream *, int level);\nvoid git_deflate_init_raw(git_zstream *, int level);\nvoid git_deflate_end(git_zstream *);\nint git_deflate_abort(git_zstream *);\nint git_deflate_end_gently(git_zstream *);\nint git_deflate(git_zstream *, int flush);\nunsigned long git_deflate_bound(git_zstream *, unsigned long);\n\n#if defined(DT_UNKNOWN) && !defined(NO_D_TYPE_IN_DIRENT)\n#define DTYPE(de)\t((de)->d_type)\n#else\n#undef DT_UNKNOWN\n#undef DT_DIR\n#undef DT_REG\n#undef DT_LNK\n#define DT_UNKNOWN\t0\n#define DT_DIR\t\t1\n#define DT_REG\t\t2\n#define DT_LNK\t\t3\n#define DTYPE(de)\tDT_UNKNOWN\n#endif\n\n/* unknown mode (impossible combination S_IFIFO|S_IFCHR) */\n#define S_IFINVALID     0030000\n\n/*\n * A \"directory link\" is a link to another git directory.\n *\n * The value 0160000 is not normally a valid mode, and\n * also just happens to be S_IFDIR + S_IFLNK\n *\n * NOTE! We *really* shouldn't depend on the S_IFxxx macros\n * always having the same values everywhere. We should use\n * our internal git values for these things, and then we can\n * translate that to the OS-specific value. It just so\n * happens that everybody shares the same bit representation\n * in the UNIX world (and apparently wider too..)\n */\n#define S_IFGITLINK\t0160000\n#define S_ISGITLINK(m)\t(((m) & S_IFMT) == S_IFGITLINK)\n\n/*\n * Intensive research over the course of many years has shown that\n * port 9418 is totally unused by anything else. Or\n *\n *\tYour search - \"port 9418\" - did not match any documents.\n *\n * as www.google.com puts it.\n *\n * This port has been properly assigned for git use by IANA:\n * git (Assigned-9418) [I06-050728-0001].\n *\n *\tgit  9418/tcp   git pack transfer service\n *\tgit  9418/udp   git pack transfer service\n *\n * with Linus Torvalds <torvalds@osdl.org> as the point of\n * contact. September 2005.\n *\n * See http://www.iana.org/assignments/port-numbers\n */\n#define DEFAULT_GIT_PORT 9418\n\n/*\n * Basic data structures for the directory cache\n */\n\n#define CACHE_SIGNATURE 0x44495243\t/* \"DIRC\" */\nstruct cache_header {\n\tuint32_t hdr_signature;\n\tuint32_t hdr_version;\n\tuint32_t hdr_entries;\n};\n\n#define INDEX_FORMAT_LB 2\n#define INDEX_FORMAT_UB 4\n\n/*\n * The \"cache_time\" is just the low 32 bits of the\n * time. It doesn't matter if it overflows - we only\n * check it for equality in the 32 bits we save.\n */\nstruct cache_time {\n\tuint32_t sec;\n\tuint32_t nsec;\n};\n\nstruct stat_data {\n\tstruct cache_time sd_ctime;\n\tstruct cache_time sd_mtime;\n\tunsigned int sd_dev;\n\tunsigned int sd_ino;\n\tunsigned int sd_uid;\n\tunsigned int sd_gid;\n\tunsigned int sd_size;\n};\n\nstruct cache_entry {\n\tstruct stat_data ce_stat_data;\n\tunsigned int ce_mode;\n\tunsigned int ce_flags;\n\tunsigned int ce_namelen;\n\tunsigned char sha1[20];\n\tstruct cache_entry *next;\n\tchar name[FLEX_ARRAY]; /* more */\n};\n\n#define CE_STAGEMASK (0x3000)\n#define CE_EXTENDED  (0x4000)\n#define CE_VALID     (0x8000)\n#define CE_STAGESHIFT 12\n\n/*\n * Range 0xFFFF0000 in ce_flags is divided into\n * two parts: in-memory flags and on-disk ones.\n * Flags in CE_EXTENDED_FLAGS will get saved on-disk\n * if you want to save a new flag, add it in\n * CE_EXTENDED_FLAGS\n *\n * In-memory only flags\n */\n#define CE_UPDATE            (1 << 16)\n#define CE_REMOVE            (1 << 17)\n#define CE_UPTODATE          (1 << 18)\n#define CE_ADDED             (1 << 19)\n\n#define CE_HASHED            (1 << 20)\n#define CE_UNHASHED          (1 << 21)\n#define CE_WT_REMOVE         (1 << 22) /* remove in work directory */\n#define CE_CONFLICTED        (1 << 23)\n\n#define CE_UNPACKED          (1 << 24)\n#define CE_NEW_SKIP_WORKTREE (1 << 25)\n\n/* used to temporarily mark paths matched by pathspecs */\n#define CE_MATCHED           (1 << 26)\n\n/*\n * Extended on-disk flags\n */\n#define CE_INTENT_TO_ADD     (1 << 29)\n#define CE_SKIP_WORKTREE     (1 << 30)\n/* CE_EXTENDED2 is for future extension */\n#define CE_EXTENDED2         (1 << 31)\n\n#define CE_EXTENDED_FLAGS (CE_INTENT_TO_ADD | CE_SKIP_WORKTREE)\n\n/*\n * Safeguard to avoid saving wrong flags:\n *  - CE_EXTENDED2 won't get saved until its semantic is known\n *  - Bits in 0x0000FFFF have been saved in ce_flags already\n *  - Bits in 0x003F0000 are currently in-memory flags\n */\n#if CE_EXTENDED_FLAGS & 0x803FFFFF\n#error \"CE_EXTENDED_FLAGS out of range\"\n#endif\n\nstruct pathspec;\n\n/*\n * Copy the sha1 and stat state of a cache entry from one to\n * another. But we never change the name, or the hash state!\n */\n#define CE_STATE_MASK (CE_HASHED | CE_UNHASHED)\nstatic inline void copy_cache_entry(struct cache_entry *dst,\n\t\t\t\t    const struct cache_entry *src)\n{\n\tunsigned int state = dst->ce_flags & CE_STATE_MASK;\n\n\t/* Don't copy hash chain and name */\n\tmemcpy(dst, src, offsetof(struct cache_entry, next));\n\n\t/* Restore the hash state */\n\tdst->ce_flags = (dst->ce_flags & ~CE_STATE_MASK) | state;\n}\n\nstatic inline unsigned create_ce_flags(unsigned stage)\n{\n\treturn (stage << CE_STAGESHIFT);\n}\n\n#define ce_namelen(ce) ((ce)->ce_namelen)\n#define ce_size(ce) cache_entry_size(ce_namelen(ce))\n#define ce_stage(ce) ((CE_STAGEMASK & (ce)->ce_flags) >> CE_STAGESHIFT)\n#define ce_uptodate(ce) ((ce)->ce_flags & CE_UPTODATE)\n#define ce_skip_worktree(ce) ((ce)->ce_flags & CE_SKIP_WORKTREE)\n#define ce_mark_uptodate(ce) ((ce)->ce_flags |= CE_UPTODATE)\n\n#define ce_permissions(mode) (((mode) & 0100) ? 0755 : 0644)\nstatic inline unsigned int create_ce_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\tif (S_ISDIR(mode) || S_ISGITLINK(mode))\n\t\treturn S_IFGITLINK;\n\treturn S_IFREG | ce_permissions(mode);\n}\nstatic inline unsigned int ce_mode_from_stat(const struct cache_entry *ce,\n\t\t\t\t\t     unsigned int mode)\n{\n\textern int trust_executable_bit, has_symlinks;\n\tif (!has_symlinks && S_ISREG(mode) &&\n\t    ce && S_ISLNK(ce->ce_mode))\n\t\treturn ce->ce_mode;\n\tif (!trust_executable_bit && S_ISREG(mode)) {\n\t\tif (ce && S_ISREG(ce->ce_mode))\n\t\t\treturn ce->ce_mode;\n\t\treturn create_ce_mode(0666);\n\t}\n\treturn create_ce_mode(mode);\n}\nstatic inline int ce_to_dtype(const struct cache_entry *ce)\n{\n\tunsigned ce_mode = ntohl(ce->ce_mode);\n\tif (S_ISREG(ce_mode))\n\t\treturn DT_REG;\n\telse if (S_ISDIR(ce_mode) || S_ISGITLINK(ce_mode))\n\t\treturn DT_DIR;\n\telse if (S_ISLNK(ce_mode))\n\t\treturn DT_LNK;\n\telse\n\t\treturn DT_UNKNOWN;\n}\nstatic inline unsigned int canon_mode(unsigned int mode)\n{\n\tif (S_ISREG(mode))\n\t\treturn S_IFREG | ce_permissions(mode);\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\tif (S_ISDIR(mode))\n\t\treturn S_IFDIR;\n\treturn S_IFGITLINK;\n}\n\n#define cache_entry_size(len) (offsetof(struct cache_entry,name) + (len) + 1)\n\nstruct index_state {\n\tstruct cache_entry **cache;\n\tunsigned int version;\n\tunsigned int cache_nr, cache_alloc, cache_changed;\n\tstruct string_list *resolve_undo;\n\tstruct cache_tree *cache_tree;\n\tstruct cache_time timestamp;\n\tunsigned name_hash_initialized : 1,\n\t\t initialized : 1;\n\tstruct hash_table name_hash;\n\tstruct hash_table dir_hash;\n};\n\nextern struct index_state the_index;\n\n/* Name hashing */\nextern void add_name_hash(struct index_state *istate, struct cache_entry *ce);\nextern void remove_name_hash(struct index_state *istate, struct cache_entry *ce);\nextern void free_name_hash(struct index_state *istate);\n\n\n#ifndef NO_THE_INDEX_COMPATIBILITY_MACROS\n#define active_cache (the_index.cache)\n#define active_nr (the_index.cache_nr)\n#define active_alloc (the_index.cache_alloc)\n#define active_cache_changed (the_index.cache_changed)\n#define active_cache_tree (the_index.cache_tree)\n\n#define read_cache() read_index(&the_index)\n#define read_cache_from(path) read_index_from(&the_index, (path))\n#define read_cache_preload(pathspec) read_index_preload(&the_index, (pathspec))\n#define is_cache_unborn() is_index_unborn(&the_index)\n#define read_cache_unmerged() read_index_unmerged(&the_index)\n#define write_cache(newfd, cache, entries) write_index(&the_index, (newfd))\n#define discard_cache() discard_index(&the_index)\n#define unmerged_cache() unmerged_index(&the_index)\n#define cache_name_pos(name, namelen) index_name_pos(&the_index,(name),(namelen))\n#define add_cache_entry(ce, option) add_index_entry(&the_index, (ce), (option))\n#define rename_cache_entry_at(pos, new_name) rename_index_entry_at(&the_index, (pos), (new_name))\n#define remove_cache_entry_at(pos) remove_index_entry_at(&the_index, (pos))\n#define remove_file_from_cache(path) remove_file_from_index(&the_index, (path))\n#define add_to_cache(path, st, flags) add_to_index(&the_index, (path), (st), (flags))\n#define add_file_to_cache(path, flags) add_file_to_index(&the_index, (path), (flags))\n#define refresh_cache(flags) refresh_index(&the_index, (flags), NULL, NULL, NULL)\n#define ce_match_stat(ce, st, options) ie_match_stat(&the_index, (ce), (st), (options))\n#define ce_modified(ce, st, options) ie_modified(&the_index, (ce), (st), (options))\n#define cache_dir_exists(name, namelen) index_dir_exists(&the_index, (name), (namelen))\n#define cache_file_exists(name, namelen, igncase) index_file_exists(&the_index, (name), (namelen), (igncase))\n#define cache_name_exists(name, namelen, igncase) index_name_exists(&the_index, (name), (namelen), (igncase))\n#define cache_name_is_other(name, namelen) index_name_is_other(&the_index, (name), (namelen))\n#define resolve_undo_clear() resolve_undo_clear_index(&the_index)\n#define unmerge_cache_entry_at(at) unmerge_index_entry_at(&the_index, at)\n#define unmerge_cache(pathspec) unmerge_index(&the_index, pathspec)\n#define read_blob_data_from_cache(path, sz) read_blob_data_from_index(&the_index, (path), (sz))\n#endif\n\nenum object_type {\n\tOBJ_BAD = -1,\n\tOBJ_NONE = 0,\n\tOBJ_COMMIT = 1,\n\tOBJ_TREE = 2,\n\tOBJ_BLOB = 3,\n\tOBJ_TAG = 4,\n\t/* 5 for future expansion */\n\tOBJ_OFS_DELTA = 6,\n\tOBJ_REF_DELTA = 7,\n\tOBJ_ANY,\n\tOBJ_MAX\n};\n\nstatic inline enum object_type object_type(unsigned int mode)\n{\n\treturn S_ISDIR(mode) ? OBJ_TREE :\n\t\tS_ISGITLINK(mode) ? OBJ_COMMIT :\n\t\tOBJ_BLOB;\n}\n\n/* Double-check local_repo_env below if you add to this list. */\n#define GIT_DIR_ENVIRONMENT \"GIT_DIR\"\n#define GIT_NAMESPACE_ENVIRONMENT \"GIT_NAMESPACE\"\n#define GIT_WORK_TREE_ENVIRONMENT \"GIT_WORK_TREE\"\n#define GIT_PREFIX_ENVIRONMENT \"GIT_PREFIX\"\n#define DEFAULT_GIT_DIR_ENVIRONMENT \".git\"\n#define DB_ENVIRONMENT \"GIT_OBJECT_DIRECTORY\"\n#define INDEX_ENVIRONMENT \"GIT_INDEX_FILE\"\n#define GRAFT_ENVIRONMENT \"GIT_GRAFT_FILE\"\n#define GIT_SHALLOW_FILE_ENVIRONMENT \"GIT_SHALLOW_FILE\"\n#define TEMPLATE_DIR_ENVIRONMENT \"GIT_TEMPLATE_DIR\"\n#define CONFIG_ENVIRONMENT \"GIT_CONFIG\"\n#define CONFIG_DATA_ENVIRONMENT \"GIT_CONFIG_PARAMETERS\"\n#define EXEC_PATH_ENVIRONMENT \"GIT_EXEC_PATH\"\n#define CEILING_DIRECTORIES_ENVIRONMENT \"GIT_CEILING_DIRECTORIES\"\n#define NO_REPLACE_OBJECTS_ENVIRONMENT \"GIT_NO_REPLACE_OBJECTS\"\n#define GITATTRIBUTES_FILE \".gitattributes\"\n#define INFOATTRIBUTES_FILE \"info/attributes\"\n#define ATTRIBUTE_MACRO_PREFIX \"[attr]\"\n#define GIT_NOTES_REF_ENVIRONMENT \"GIT_NOTES_REF\"\n#define GIT_NOTES_DEFAULT_REF \"refs/notes/commits\"\n#define GIT_NOTES_DISPLAY_REF_ENVIRONMENT \"GIT_NOTES_DISPLAY_REF\"\n#define GIT_NOTES_REWRITE_REF_ENVIRONMENT \"GIT_NOTES_REWRITE_REF\"\n#define GIT_NOTES_REWRITE_MODE_ENVIRONMENT \"GIT_NOTES_REWRITE_MODE\"\n#define GIT_LITERAL_PATHSPECS_ENVIRONMENT \"GIT_LITERAL_PATHSPECS\"\n#define GIT_GLOB_PATHSPECS_ENVIRONMENT \"GIT_GLOB_PATHSPECS\"\n#define GIT_NOGLOB_PATHSPECS_ENVIRONMENT \"GIT_NOGLOB_PATHSPECS\"\n#define GIT_ICASE_PATHSPECS_ENVIRONMENT \"GIT_ICASE_PATHSPECS\"\n\n/*\n * This environment variable is expected to contain a boolean indicating\n * whether we should or should not treat:\n *\n *   GIT_DIR=foo.git git ...\n *\n * as if GIT_WORK_TREE=. was given. It's not expected that users will make use\n * of this, but we use it internally to communicate to sub-processes that we\n * are in a bare repo. If not set, defaults to true.\n */\n#define GIT_IMPLICIT_WORK_TREE_ENVIRONMENT \"GIT_IMPLICIT_WORK_TREE\"\n\n/*\n * Repository-local GIT_* environment variables; these will be cleared\n * when git spawns a sub-process that runs inside another repository.\n * The array is NULL-terminated, which makes it easy to pass in the \"env\"\n * parameter of a run-command invocation, or to do a simple walk.\n */\nextern const char * const local_repo_env[];\n\nextern int is_bare_repository_cfg;\nextern int is_bare_repository(void);\nextern int is_inside_git_dir(void);\nextern char *git_work_tree_cfg;\nextern int is_inside_work_tree(void);\nextern const char *get_git_dir(void);\nextern int is_git_directory(const char *path);\nextern char *get_object_directory(void);\nextern char *get_index_file(void);\nextern char *get_graft_file(void);\nextern int set_git_dir(const char *path);\nextern const char *get_git_namespace(void);\nextern const char *strip_namespace(const char *namespaced_ref);\nextern const char *get_git_work_tree(void);\nextern const char *read_gitfile(const char *path);\nextern const char *resolve_gitdir(const char *suspect);\nextern void set_git_work_tree(const char *tree);\n\n#define ALTERNATE_DB_ENVIRONMENT \"GIT_ALTERNATE_OBJECT_DIRECTORIES\"\n\nextern const char **get_pathspec(const char *prefix, const char **pathspec);\nextern void setup_work_tree(void);\nextern const char *setup_git_directory_gently(int *);\nextern const char *setup_git_directory(void);\nextern char *prefix_path(const char *prefix, int len, const char *path);\nextern char *prefix_path_gently(const char *prefix, int len, int *remaining, const char *path);\nextern const char *prefix_filename(const char *prefix, int len, const char *path);\nextern int check_filename(const char *prefix, const char *name);\nextern void verify_filename(const char *prefix,\n\t\t\t    const char *name,\n\t\t\t    int diagnose_misspelt_rev);\nextern void verify_non_filename(const char *prefix, const char *name);\nextern int path_inside_repo(const char *prefix, const char *path);\n\n#define INIT_DB_QUIET 0x0001\n\nextern int set_git_dir_init(const char *git_dir, const char *real_git_dir, int);\nextern int init_db(const char *template_dir, unsigned int flags);\n\nextern void sanitize_stdfds(void);\n\n#define alloc_nr(x) (((x)+16)*3/2)\n\n/*\n * Realloc the buffer pointed at by variable 'x' so that it can hold\n * at least 'nr' entries; the number of entries currently allocated\n * is 'alloc', using the standard growing factor alloc_nr() macro.\n *\n * DO NOT USE any expression with side-effect for 'x', 'nr', or 'alloc'.\n */\n#define ALLOC_GROW(x, nr, alloc) \\\n\tdo { \\\n\t\tif ((nr) > alloc) { \\\n\t\t\tif (alloc_nr(alloc) < (nr)) \\\n\t\t\t\talloc = (nr); \\\n\t\t\telse \\\n\t\t\t\talloc = alloc_nr(alloc); \\\n\t\t\tx = xrealloc((x), alloc * sizeof(*(x))); \\\n\t\t} \\\n\t} while (0)\n\n/* Initialize and use the cache information */\nextern int read_index(struct index_state *);\nextern int read_index_preload(struct index_state *, const struct pathspec *pathspec);\nextern int read_index_from(struct index_state *, const char *path);\nextern int is_index_unborn(struct index_state *);\nextern int read_index_unmerged(struct index_state *);\nextern int write_index(struct index_state *, int newfd);\nextern int discard_index(struct index_state *);\nextern int unmerged_index(const struct index_state *);\nextern int verify_path(const char *path);\nextern struct cache_entry *index_dir_exists(struct index_state *istate, const char *name, int namelen);\nextern struct cache_entry *index_file_exists(struct index_state *istate, const char *name, int namelen, int igncase);\nextern struct cache_entry *index_name_exists(struct index_state *istate, const char *name, int namelen, int igncase);\nextern int index_name_pos(const struct index_state *, const char *name, int namelen);\n#define ADD_CACHE_OK_TO_ADD 1\t\t/* Ok to add */\n#define ADD_CACHE_OK_TO_REPLACE 2\t/* Ok to replace file/directory */\n#define ADD_CACHE_SKIP_DFCHECK 4\t/* Ok to skip DF conflict checks */\n#define ADD_CACHE_JUST_APPEND 8\t\t/* Append only; tree.c::read_tree() */\n#define ADD_CACHE_NEW_ONLY 16\t\t/* Do not replace existing ones */\nextern int add_index_entry(struct index_state *, struct cache_entry *ce, int option);\nextern void rename_index_entry_at(struct index_state *, int pos, const char *new_name);\nextern int remove_index_entry_at(struct index_state *, int pos);\nextern void remove_marked_cache_entries(struct index_state *istate);\nextern int remove_file_from_index(struct index_state *, const char *path);\n#define ADD_CACHE_VERBOSE 1\n#define ADD_CACHE_PRETEND 2\n#define ADD_CACHE_IGNORE_ERRORS\t4\n#define ADD_CACHE_IGNORE_REMOVAL 8\n#define ADD_CACHE_INTENT 16\n#define ADD_CACHE_IMPLICIT_DOT 32\t/* internal to \"git add -u/-A\" */\nextern int add_to_index(struct index_state *, const char *path, struct stat *, int flags);\nextern int add_file_to_index(struct index_state *, const char *path, int flags);\nextern struct cache_entry *make_cache_entry(unsigned int mode, const unsigned char *sha1, const char *path, int stage, unsigned int refresh_options);\nextern int ce_same_name(const struct cache_entry *a, const struct cache_entry *b);\nextern int index_name_is_other(const struct index_state *, const char *, int);\nextern void *read_blob_data_from_index(struct index_state *, const char *, unsigned long *);\n\n/* do stat comparison even if CE_VALID is true */\n#define CE_MATCH_IGNORE_VALID\t\t01\n/* do not check the contents but report dirty on racily-clean entries */\n#define CE_MATCH_RACY_IS_DIRTY\t\t02\n/* do stat comparison even if CE_SKIP_WORKTREE is true */\n#define CE_MATCH_IGNORE_SKIP_WORKTREE\t04\n/* ignore non-existent files during stat update  */\n#define CE_MATCH_IGNORE_MISSING\t\t0x08\n/* enable stat refresh */\n#define CE_MATCH_REFRESH\t\t0x10\nextern int ie_match_stat(const struct index_state *, const struct cache_entry *, struct stat *, unsigned int);\nextern int ie_modified(const struct index_state *, const struct cache_entry *, struct stat *, unsigned int);\n\n#define HASH_WRITE_OBJECT 1\n#define HASH_FORMAT_CHECK 2\nextern int index_fd(unsigned char *sha1, int fd, struct stat *st, enum object_type type, const char *path, unsigned flags);\nextern int index_path(unsigned char *sha1, const char *path, struct stat *st, unsigned flags);\n\n/*\n * Record to sd the data from st that we use to check whether a file\n * might have changed.\n */\nextern void fill_stat_data(struct stat_data *sd, struct stat *st);\n\n/*\n * Return 0 if st is consistent with a file not having been changed\n * since sd was filled.  If there are differences, return a\n * combination of MTIME_CHANGED, CTIME_CHANGED, OWNER_CHANGED,\n * INODE_CHANGED, and DATA_CHANGED.\n */\nextern int match_stat_data(const struct stat_data *sd, struct stat *st);\n\nextern void fill_stat_cache_info(struct cache_entry *ce, struct stat *st);\n\n#define REFRESH_REALLY\t\t0x0001\t/* ignore_valid */\n#define REFRESH_UNMERGED\t0x0002\t/* allow unmerged */\n#define REFRESH_QUIET\t\t0x0004\t/* be quiet about it */\n#define REFRESH_IGNORE_MISSING\t0x0008\t/* ignore non-existent */\n#define REFRESH_IGNORE_SUBMODULES\t0x0010\t/* ignore submodules */\n#define REFRESH_IN_PORCELAIN\t0x0020\t/* user friendly output, not \"needs update\" */\nextern int refresh_index(struct index_state *, unsigned int flags, const struct pathspec *pathspec, char *seen, const char *header_msg);\n\nstruct lock_file {\n\tstruct lock_file *next;\n\tint fd;\n\tpid_t owner;\n\tchar on_list;\n\tchar filename[PATH_MAX];\n};\n#define LOCK_DIE_ON_ERROR 1\n#define LOCK_NODEREF 2\nextern int unable_to_lock_error(const char *path, int err);\nextern NORETURN void unable_to_lock_index_die(const char *path, int err);\nextern int hold_lock_file_for_update(struct lock_file *, const char *path, int);\nextern int hold_lock_file_for_append(struct lock_file *, const char *path, int);\nextern int commit_lock_file(struct lock_file *);\nextern void update_index_if_able(struct index_state *, struct lock_file *);\n\nextern int hold_locked_index(struct lock_file *, int);\nextern int commit_locked_index(struct lock_file *);\nextern void set_alternate_index_output(const char *);\nextern int close_lock_file(struct lock_file *);\nextern void rollback_lock_file(struct lock_file *);\nextern int delete_ref(const char *, const unsigned char *sha1, int delopt);\n\n/* Environment bits from configuration mechanism */\nextern int trust_executable_bit;\nextern int trust_ctime;\nextern int check_stat;\nextern int quote_path_fully;\nextern int has_symlinks;\nextern int minimum_abbrev, default_abbrev;\nextern int ignore_case;\nextern int assume_unchanged;\nextern int prefer_symlink_refs;\nextern int log_all_ref_updates;\nextern int warn_ambiguous_refs;\nextern int warn_on_object_refname_ambiguity;\nextern int shared_repository;\nextern const char *apply_default_whitespace;\nextern const char *apply_default_ignorewhitespace;\nextern const char *git_attributes_file;\nextern int zlib_compression_level;\nextern int core_compression_level;\nextern int core_compression_seen;\nextern size_t packed_git_window_size;\nextern size_t packed_git_limit;\nextern size_t delta_base_cache_limit;\nextern unsigned long big_file_threshold;\nextern unsigned long pack_size_limit_cfg;\nextern int read_replace_refs;\nextern int fsync_object_files;\nextern int core_preload_index;\nextern int core_apply_sparse_checkout;\nextern int precomposed_unicode;\n\n/*\n * The character that begins a commented line in user-editable file\n * that is subject to stripspace.\n */\nextern char comment_line_char;\n\nenum branch_track {\n\tBRANCH_TRACK_UNSPECIFIED = -1,\n\tBRANCH_TRACK_NEVER = 0,\n\tBRANCH_TRACK_REMOTE,\n\tBRANCH_TRACK_ALWAYS,\n\tBRANCH_TRACK_EXPLICIT,\n\tBRANCH_TRACK_OVERRIDE\n};\n\nenum rebase_setup_type {\n\tAUTOREBASE_NEVER = 0,\n\tAUTOREBASE_LOCAL,\n\tAUTOREBASE_REMOTE,\n\tAUTOREBASE_ALWAYS\n};\n\nenum push_default_type {\n\tPUSH_DEFAULT_NOTHING = 0,\n\tPUSH_DEFAULT_MATCHING,\n\tPUSH_DEFAULT_SIMPLE,\n\tPUSH_DEFAULT_UPSTREAM,\n\tPUSH_DEFAULT_CURRENT,\n\tPUSH_DEFAULT_UNSPECIFIED\n};\n\nextern enum branch_track git_branch_track;\nextern enum rebase_setup_type autorebase;\nextern enum push_default_type push_default;\n\nenum object_creation_mode {\n\tOBJECT_CREATION_USES_HARDLINKS = 0,\n\tOBJECT_CREATION_USES_RENAMES = 1\n};\n\nextern enum object_creation_mode object_creation_mode;\n\nextern char *notes_ref_name;\n\nextern int grafts_replace_parents;\n\n#define GIT_REPO_VERSION 0\nextern int repository_format_version;\nextern int check_repository_format(void);\n\n#define MTIME_CHANGED\t0x0001\n#define CTIME_CHANGED\t0x0002\n#define OWNER_CHANGED\t0x0004\n#define MODE_CHANGED    0x0008\n#define INODE_CHANGED   0x0010\n#define DATA_CHANGED    0x0020\n#define TYPE_CHANGED    0x0040\n\nextern char *mksnpath(char *buf, size_t n, const char *fmt, ...)\n\t__attribute__((format (printf, 3, 4)));\nextern char *git_snpath(char *buf, size_t n, const char *fmt, ...)\n\t__attribute__((format (printf, 3, 4)));\nextern char *git_pathdup(const char *fmt, ...)\n\t__attribute__((format (printf, 1, 2)));\nextern char *mkpathdup(const char *fmt, ...)\n\t__attribute__((format (printf, 1, 2)));\n\n/* Return a statically allocated filename matching the sha1 signature */\nextern char *mkpath(const char *fmt, ...) __attribute__((format (printf, 1, 2)));\nextern char *git_path(const char *fmt, ...) __attribute__((format (printf, 1, 2)));\nextern char *git_path_submodule(const char *path, const char *fmt, ...)\n\t__attribute__((format (printf, 2, 3)));\n\nextern char *sha1_file_name(const unsigned char *sha1);\nextern char *sha1_pack_name(const unsigned char *sha1);\nextern char *sha1_pack_index_name(const unsigned char *sha1);\nextern const char *find_unique_abbrev(const unsigned char *sha1, int);\nextern const unsigned char null_sha1[20];\n\nstatic inline int hashcmp(const unsigned char *sha1, const unsigned char *sha2)\n{\n\tint i;\n\n\tfor (i = 0; i < 20; i++, sha1++, sha2++) {\n\t\tif (*sha1 != *sha2)\n\t\t\treturn *sha1 - *sha2;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int is_null_sha1(const unsigned char *sha1)\n{\n\treturn !hashcmp(sha1, null_sha1);\n}\n\nstatic inline void hashcpy(unsigned char *sha_dst, const unsigned char *sha_src)\n{\n\tmemcpy(sha_dst, sha_src, 20);\n}\nstatic inline void hashclr(unsigned char *hash)\n{\n\tmemset(hash, 0, 20);\n}\n\n#define EMPTY_TREE_SHA1_HEX \\\n\t\"4b825dc642cb6eb9a060e54bf8d69288fbee4904\"\n#define EMPTY_TREE_SHA1_BIN_LITERAL \\\n\t \"\\x4b\\x82\\x5d\\xc6\\x42\\xcb\\x6e\\xb9\\xa0\\x60\" \\\n\t \"\\xe5\\x4b\\xf8\\xd6\\x92\\x88\\xfb\\xee\\x49\\x04\"\n#define EMPTY_TREE_SHA1_BIN \\\n\t ((const unsigned char *) EMPTY_TREE_SHA1_BIN_LITERAL)\n\n#define EMPTY_BLOB_SHA1_HEX \\\n\t\"e69de29bb2d1d6434b8b29ae775ad8c2e48c5391\"\n#define EMPTY_BLOB_SHA1_BIN_LITERAL \\\n\t\"\\xe6\\x9d\\xe2\\x9b\\xb2\\xd1\\xd6\\x43\\x4b\\x8b\" \\\n\t\"\\x29\\xae\\x77\\x5a\\xd8\\xc2\\xe4\\x8c\\x53\\x91\"\n#define EMPTY_BLOB_SHA1_BIN \\\n\t((const unsigned char *) EMPTY_BLOB_SHA1_BIN_LITERAL)\n\nstatic inline int is_empty_blob_sha1(const unsigned char *sha1)\n{\n\treturn !hashcmp(sha1, EMPTY_BLOB_SHA1_BIN);\n}\n\nint git_mkstemp(char *path, size_t n, const char *template);\n\nint git_mkstemps(char *path, size_t n, const char *template, int suffix_len);\n\n/* set default permissions by passing mode arguments to open(2) */\nint git_mkstemps_mode(char *pattern, int suffix_len, int mode);\nint git_mkstemp_mode(char *pattern, int mode);\n\n/*\n * NOTE NOTE NOTE!!\n *\n * PERM_UMASK, OLD_PERM_GROUP and OLD_PERM_EVERYBODY enumerations must\n * not be changed. Old repositories have core.sharedrepository written in\n * numeric format, and therefore these values are preserved for compatibility\n * reasons.\n */\nenum sharedrepo {\n\tPERM_UMASK          = 0,\n\tOLD_PERM_GROUP      = 1,\n\tOLD_PERM_EVERYBODY  = 2,\n\tPERM_GROUP          = 0660,\n\tPERM_EVERYBODY      = 0664\n};\nint git_config_perm(const char *var, const char *value);\nint adjust_shared_perm(const char *path);\n\n/*\n * Create the directory containing the named path, using care to be\n * somewhat safe against races.  Return one of the scld_error values\n * to indicate success/failure.\n *\n * SCLD_VANISHED indicates that one of the ancestor directories of the\n * path existed at one point during the function call and then\n * suddenly vanished, probably because another process pruned the\n * directory while we were working.  To be robust against this kind of\n * race, callers might want to try invoking the function again when it\n * returns SCLD_VANISHED.\n */\nenum scld_error {\n\tSCLD_OK = 0,\n\tSCLD_FAILED = -1,\n\tSCLD_PERMS = -2,\n\tSCLD_EXISTS = -3,\n\tSCLD_VANISHED = -4\n};\nenum scld_error safe_create_leading_directories(char *path);\nenum scld_error safe_create_leading_directories_const(const char *path);\n\nint mkdir_in_gitdir(const char *path);\nextern void home_config_paths(char **global, char **xdg, char *file);\nextern char *expand_user_path(const char *path);\nconst char *enter_repo(const char *path, int strict);\nstatic inline int is_absolute_path(const char *path)\n{\n\treturn is_dir_sep(path[0]) || has_dos_drive_prefix(path);\n}\nint is_directory(const char *);\nconst char *real_path(const char *path);\nconst char *real_path_if_valid(const char *path);\nconst char *absolute_path(const char *path);\nconst char *remove_leading_path(const char *in, const char *prefix);\nconst char *relative_path(const char *in, const char *prefix, struct strbuf *sb);\nint normalize_path_copy_len(char *dst, const char *src, int *prefix_len);\nint normalize_path_copy(char *dst, const char *src);\nint longest_ancestor_length(const char *path, struct string_list *prefixes);\nchar *strip_path_suffix(const char *path, const char *suffix);\nint daemon_avoid_alias(const char *path);\nint offset_1st_component(const char *path);\n\n/* object replacement */\n#define LOOKUP_REPLACE_OBJECT 1\nextern void *read_sha1_file_extended(const unsigned char *sha1, enum object_type *type, unsigned long *size, unsigned flag);\nstatic inline void *read_sha1_file(const unsigned char *sha1, enum object_type *type, unsigned long *size)\n{\n\treturn read_sha1_file_extended(sha1, type, size, LOOKUP_REPLACE_OBJECT);\n}\nextern const unsigned char *do_lookup_replace_object(const unsigned char *sha1);\nstatic inline const unsigned char *lookup_replace_object(const unsigned char *sha1)\n{\n\tif (!read_replace_refs)\n\t\treturn sha1;\n\treturn do_lookup_replace_object(sha1);\n}\nstatic inline const unsigned char *lookup_replace_object_extended(const unsigned char *sha1, unsigned flag)\n{\n\tif (!(flag & LOOKUP_REPLACE_OBJECT))\n\t\treturn sha1;\n\treturn lookup_replace_object(sha1);\n}\n\n/* Read and unpack a sha1 file into memory, write memory to a sha1 file */\nextern int sha1_object_info(const unsigned char *, unsigned long *);\nextern int hash_sha1_file(const void *buf, unsigned long len, const char *type, unsigned char *sha1);\nextern int write_sha1_file(const void *buf, unsigned long len, const char *type, unsigned char *return_sha1);\nextern int pretend_sha1_file(void *, unsigned long, enum object_type, unsigned char *);\nextern int force_object_loose(const unsigned char *sha1, time_t mtime);\nextern void *map_sha1_file(const unsigned char *sha1, unsigned long *size);\nextern int unpack_sha1_header(git_zstream *stream, unsigned char *map, unsigned long mapsize, void *buffer, unsigned long bufsiz);\nextern int parse_sha1_header(const char *hdr, unsigned long *sizep);\n\n/* global flag to enable extra checks when accessing packed objects */\nextern int do_check_packed_object_crc;\n\nextern int check_sha1_signature(const unsigned char *sha1, void *buf, unsigned long size, const char *type);\n\nextern int move_temp_to_file(const char *tmpfile, const char *filename);\n\nextern int has_sha1_pack(const unsigned char *sha1);\nextern int has_sha1_file(const unsigned char *sha1);\nextern int has_loose_object_nonlocal(const unsigned char *sha1);\n\nextern int has_pack_index(const unsigned char *sha1);\n\nextern void assert_sha1_type(const unsigned char *sha1, enum object_type expect);\n\nextern const signed char hexval_table[256];\nstatic inline unsigned int hexval(unsigned char c)\n{\n\treturn hexval_table[c];\n}\n\n/* Convert to/from hex/sha1 representation */\n#define MINIMUM_ABBREV minimum_abbrev\n#define DEFAULT_ABBREV default_abbrev\n\nstruct object_context {\n\tunsigned char tree[20];\n\tchar path[PATH_MAX];\n\tunsigned mode;\n};\n\n#define GET_SHA1_QUIETLY        01\n#define GET_SHA1_COMMIT         02\n#define GET_SHA1_COMMITTISH     04\n#define GET_SHA1_TREE          010\n#define GET_SHA1_TREEISH       020\n#define GET_SHA1_BLOB\t       040\n#define GET_SHA1_ONLY_TO_DIE 04000\n\nextern int get_sha1(const char *str, unsigned char *sha1);\nextern int get_sha1_commit(const char *str, unsigned char *sha1);\nextern int get_sha1_committish(const char *str, unsigned char *sha1);\nextern int get_sha1_tree(const char *str, unsigned char *sha1);\nextern int get_sha1_treeish(const char *str, unsigned char *sha1);\nextern int get_sha1_blob(const char *str, unsigned char *sha1);\nextern void maybe_die_on_misspelt_object_name(const char *name, const char *prefix);\nextern int get_sha1_with_context(const char *str, unsigned flags, unsigned char *sha1, struct object_context *orc);\n\ntypedef int each_abbrev_fn(const unsigned char *sha1, void *);\nextern int for_each_abbrev(const char *prefix, each_abbrev_fn, void *);\n\n/*\n * Try to read a SHA1 in hexadecimal format from the 40 characters\n * starting at hex.  Write the 20-byte result to sha1 in binary form.\n * Return 0 on success.  Reading stops if a NUL is encountered in the\n * input, so it is safe to pass this function an arbitrary\n * null-terminated string.\n */\nextern int get_sha1_hex(const char *hex, unsigned char *sha1);\n\nextern char *sha1_to_hex(const unsigned char *sha1);\t/* static buffer result! */\nextern int read_ref_full(const char *refname, unsigned char *sha1,\n\t\t\t int reading, int *flags);\nextern int read_ref(const char *refname, unsigned char *sha1);\n\n/*\n * Resolve a reference, recursively following symbolic refererences.\n *\n * Store the referred-to object's name in sha1 and return the name of\n * the non-symbolic reference that ultimately pointed at it.  The\n * return value, if not NULL, is a pointer into either a static buffer\n * or the input ref.\n *\n * If the reference cannot be resolved to an object, the behavior\n * depends on the \"reading\" argument:\n *\n * - If reading is set, return NULL.\n *\n * - If reading is not set, clear sha1 and return the name of the last\n *   reference name in the chain, which will either be a non-symbolic\n *   reference or an undefined reference.  If this is a prelude to\n *   \"writing\" to the ref, the return value is the name of the ref\n *   that will actually be created or changed.\n *\n * If flag is non-NULL, set the value that it points to the\n * combination of REF_ISPACKED (if the reference was found among the\n * packed references) and REF_ISSYMREF (if the initial reference was a\n * symbolic reference).\n *\n * If ref is not a properly-formatted, normalized reference, return\n * NULL.  If more than MAXDEPTH recursive symbolic lookups are needed,\n * give up and return NULL.\n *\n * errno is sometimes set on errors, but not always.\n */\nextern const char *resolve_ref_unsafe(const char *ref, unsigned char *sha1, int reading, int *flag);\nextern char *resolve_refdup(const char *ref, unsigned char *sha1, int reading, int *flag);\n\nextern int dwim_ref(const char *str, int len, unsigned char *sha1, char **ref);\nextern int dwim_log(const char *str, int len, unsigned char *sha1, char **ref);\nextern int interpret_branch_name(const char *str, int len, struct strbuf *);\nextern int get_sha1_mb(const char *str, unsigned char *sha1);\n\n/*\n * Return true iff abbrev_name is a possible abbreviation for\n * full_name according to the rules defined by ref_rev_parse_rules in\n * refs.c.\n */\nextern int refname_match(const char *abbrev_name, const char *full_name);\n\nextern int create_symref(const char *ref, const char *refs_heads_master, const char *logmsg);\nextern int validate_headref(const char *ref);\n\nextern int base_name_compare(const char *name1, int len1, int mode1, const char *name2, int len2, int mode2);\nextern int df_name_compare(const char *name1, int len1, int mode1, const char *name2, int len2, int mode2);\nextern int cache_name_compare(const char *name1, int len1, const char *name2, int len2);\nextern int cache_name_stage_compare(const char *name1, int len1, int stage1, const char *name2, int len2, int stage2);\n\nextern void *read_object_with_reference(const unsigned char *sha1,\n\t\t\t\t\tconst char *required_type,\n\t\t\t\t\tunsigned long *size,\n\t\t\t\t\tunsigned char *sha1_ret);\n\nextern struct object *peel_to_type(const char *name, int namelen,\n\t\t\t\t   struct object *o, enum object_type);\n\nenum date_mode {\n\tDATE_NORMAL = 0,\n\tDATE_RELATIVE,\n\tDATE_SHORT,\n\tDATE_LOCAL,\n\tDATE_ISO8601,\n\tDATE_RFC2822,\n\tDATE_RAW\n};\n\nconst char *show_date(unsigned long time, int timezone, enum date_mode mode);\nvoid show_date_relative(unsigned long time, int tz, const struct timeval *now,\n\t\t\tstruct strbuf *timebuf);\nint parse_date(const char *date, char *buf, int bufsize);\nint parse_date_basic(const char *date, unsigned long *timestamp, int *offset);\nint parse_expiry_date(const char *date, unsigned long *timestamp);\nvoid datestamp(char *buf, int bufsize);\n#define approxidate(s) approxidate_careful((s), NULL)\nunsigned long approxidate_careful(const char *, int *);\nunsigned long approxidate_relative(const char *date, const struct timeval *now);\nenum date_mode parse_date_format(const char *format);\nint date_overflows(unsigned long date);\n\n#define IDENT_STRICT\t       1\n#define IDENT_NO_DATE\t       2\n#define IDENT_NO_NAME\t       4\nextern const char *git_author_info(int);\nextern const char *git_committer_info(int);\nextern const char *fmt_ident(const char *name, const char *email, const char *date_str, int);\nextern const char *fmt_name(const char *name, const char *email);\nextern const char *ident_default_email(void);\nextern const char *git_editor(void);\nextern const char *git_pager(int stdout_is_tty);\nextern int git_ident_config(const char *, const char *, void *);\n\nstruct ident_split {\n\tconst char *name_begin;\n\tconst char *name_end;\n\tconst char *mail_begin;\n\tconst char *mail_end;\n\tconst char *date_begin;\n\tconst char *date_end;\n\tconst char *tz_begin;\n\tconst char *tz_end;\n};\n/*\n * Signals an success with 0, but time part of the result may be NULL\n * if the input lacks timestamp and zone\n */\nextern int split_ident_line(struct ident_split *, const char *, int);\n\n/*\n * Compare split idents for equality or strict ordering. Note that we\n * compare only the ident part of the line, ignoring any timestamp.\n *\n * Because there are two fields, we must choose one as the primary key; we\n * currently arbitrarily pick the email.\n */\nextern int ident_cmp(const struct ident_split *, const struct ident_split *);\n\nstruct checkout {\n\tconst char *base_dir;\n\tint base_dir_len;\n\tunsigned force:1,\n\t\t quiet:1,\n\t\t not_new:1,\n\t\t refresh_cache:1;\n};\n\n#define TEMPORARY_FILENAME_LENGTH 25\nextern int checkout_entry(struct cache_entry *ce, const struct checkout *state, char *topath);\n\nstruct cache_def {\n\tchar path[PATH_MAX + 1];\n\tint len;\n\tint flags;\n\tint track_flags;\n\tint prefix_len_stat_func;\n};\n\nextern int has_symlink_leading_path(const char *name, int len);\nextern int threaded_has_symlink_leading_path(struct cache_def *, const char *, int);\nextern int check_leading_path(const char *name, int len);\nextern int has_dirs_only_path(const char *name, int len, int prefix_len);\nextern void schedule_dir_for_removal(const char *name, int len);\nextern void remove_scheduled_dirs(void);\n\nextern struct alternate_object_database {\n\tstruct alternate_object_database *next;\n\tchar *name;\n\tchar base[FLEX_ARRAY]; /* more */\n} *alt_odb_list;\nextern void prepare_alt_odb(void);\nextern void read_info_alternates(const char * relative_base, int depth);\nextern void add_to_alternates_file(const char *reference);\ntypedef int alt_odb_fn(struct alternate_object_database *, void *);\nextern void foreach_alt_odb(alt_odb_fn, void*);\n\nstruct pack_window {\n\tstruct pack_window *next;\n\tunsigned char *base;\n\toff_t offset;\n\tsize_t len;\n\tunsigned int last_used;\n\tunsigned int inuse_cnt;\n};\n\nextern struct packed_git {\n\tstruct packed_git *next;\n\tstruct pack_window *windows;\n\toff_t pack_size;\n\tconst void *index_data;\n\tsize_t index_size;\n\tuint32_t num_objects;\n\tuint32_t num_bad_objects;\n\tunsigned char *bad_object_sha1;\n\tint index_version;\n\ttime_t mtime;\n\tint pack_fd;\n\tunsigned pack_local:1,\n\t\t pack_keep:1,\n\t\t do_not_close:1;\n\tunsigned char sha1[20];\n\t/* something like \".git/objects/pack/xxxxx.pack\" */\n\tchar pack_name[FLEX_ARRAY]; /* more */\n} *packed_git;\n\nstruct pack_entry {\n\toff_t offset;\n\tunsigned char sha1[20];\n\tstruct packed_git *p;\n};\n\nextern struct packed_git *parse_pack_index(unsigned char *sha1, const char *idx_path);\n\n/* A hook for count-objects to report invalid files in pack directory */\nextern void (*report_garbage)(const char *desc, const char *path);\n\nextern void prepare_packed_git(void);\nextern void reprepare_packed_git(void);\nextern void install_packed_git(struct packed_git *pack);\n\nextern struct packed_git *find_sha1_pack(const unsigned char *sha1,\n\t\t\t\t\t struct packed_git *packs);\n\nextern void pack_report(void);\nextern int open_pack_index(struct packed_git *);\nextern void close_pack_index(struct packed_git *);\nextern unsigned char *use_pack(struct packed_git *, struct pack_window **, off_t, unsigned long *);\nextern void close_pack_windows(struct packed_git *);\nextern void unuse_pack(struct pack_window **);\nextern void free_pack_by_name(const char *);\nextern void clear_delta_base_cache(void);\nextern struct packed_git *add_packed_git(const char *, int, int);\nextern const unsigned char *nth_packed_object_sha1(struct packed_git *, uint32_t);\nextern off_t nth_packed_object_offset(const struct packed_git *, uint32_t);\nextern off_t find_pack_entry_one(const unsigned char *, struct packed_git *);\nextern int is_pack_valid(struct packed_git *);\nextern void *unpack_entry(struct packed_git *, off_t, enum object_type *, unsigned long *);\nextern unsigned long unpack_object_header_buffer(const unsigned char *buf, unsigned long len, enum object_type *type, unsigned long *sizep);\nextern unsigned long get_size_from_delta(struct packed_git *, struct pack_window **, off_t);\nextern int unpack_object_header(struct packed_git *, struct pack_window **, off_t *, unsigned long *);\n\nstruct object_info {\n\t/* Request */\n\tenum object_type *typep;\n\tunsigned long *sizep;\n\tunsigned long *disk_sizep;\n\tunsigned char *delta_base_sha1;\n\n\t/* Response */\n\tenum {\n\t\tOI_CACHED,\n\t\tOI_LOOSE,\n\t\tOI_PACKED,\n\t\tOI_DBCACHED\n\t} whence;\n\tunion {\n\t\t/*\n\t\t * struct {\n\t\t * \t... Nothing to expose in this case\n\t\t * } cached;\n\t\t * struct {\n\t\t * \t... Nothing to expose in this case\n\t\t * } loose;\n\t\t */\n\t\tstruct {\n\t\t\tstruct packed_git *pack;\n\t\t\toff_t offset;\n\t\t\tunsigned int is_delta;\n\t\t} packed;\n\t} u;\n};\nextern int sha1_object_info_extended(const unsigned char *, struct object_info *, unsigned flags);\n\n/* Dumb servers support */\nextern int update_server_info(int);\n\n/* git_config_parse_key() returns these negated: */\n#define CONFIG_INVALID_KEY 1\n#define CONFIG_NO_SECTION_OR_NAME 2\n/* git_config_set(), git_config_set_multivar() return the above or these: */\n#define CONFIG_NO_LOCK -1\n#define CONFIG_INVALID_FILE 3\n#define CONFIG_NO_WRITE 4\n#define CONFIG_NOTHING_SET 5\n#define CONFIG_INVALID_PATTERN 6\n#define CONFIG_GENERIC_ERROR 7\n\ntypedef int (*config_fn_t)(const char *, const char *, void *);\nextern int git_default_config(const char *, const char *, void *);\nextern int git_config_from_file(config_fn_t fn, const char *, void *);\nextern int git_config_from_buf(config_fn_t fn, const char *name,\n\t\t\t       const char *buf, size_t len, void *data);\nextern void git_config_push_parameter(const char *text);\nextern int git_config_from_parameters(config_fn_t fn, void *data);\nextern int git_config(config_fn_t fn, void *);\nextern int git_config_with_options(config_fn_t fn, void *,\n\t\t\t\t   const char *filename,\n\t\t\t\t   const char *blob_ref,\n\t\t\t\t   int respect_includes);\nextern int git_config_early(config_fn_t fn, void *, const char *repo_config);\nextern int git_parse_ulong(const char *, unsigned long *);\nextern int git_config_int(const char *, const char *);\nextern int64_t git_config_int64(const char *, const char *);\nextern unsigned long git_config_ulong(const char *, const char *);\nextern int git_config_bool_or_int(const char *, const char *, int *);\nextern int git_config_bool(const char *, const char *);\nextern int git_config_maybe_bool(const char *, const char *);\nextern int git_config_string(const char **, const char *, const char *);\nextern int git_config_pathname(const char **, const char *, const char *);\nextern int git_config_set_in_file(const char *, const char *, const char *);\nextern int git_config_set(const char *, const char *);\nextern int git_config_parse_key(const char *, char **, int *);\nextern int git_config_set_multivar(const char *, const char *, const char *, int);\nextern int git_config_set_multivar_in_file(const char *, const char *, const char *, const char *, int);\nextern int git_config_rename_section(const char *, const char *);\nextern int git_config_rename_section_in_file(const char *, const char *, const char *);\nextern const char *git_etc_gitconfig(void);\nextern int check_repository_format_version(const char *var, const char *value, void *cb);\nextern int git_env_bool(const char *, int);\nextern int git_config_system(void);\nextern int config_error_nonbool(const char *);\n#if defined(__GNUC__) && ! defined(__clang__)\n#define config_error_nonbool(s) (config_error_nonbool(s), const_error())\n#endif\nextern const char *get_log_output_encoding(void);\nextern const char *get_commit_output_encoding(void);\n\nextern int git_config_parse_parameter(const char *, config_fn_t fn, void *data);\n\nstruct config_include_data {\n\tint depth;\n\tconfig_fn_t fn;\n\tvoid *data;\n};\n#define CONFIG_INCLUDE_INIT { 0 }\nextern int git_config_include(const char *name, const char *value, void *data);\n\n/*\n * Match and parse a config key of the form:\n *\n *   section.(subsection.)?key\n *\n * (i.e., what gets handed to a config_fn_t). The caller provides the section;\n * we return -1 if it does not match, 0 otherwise. The subsection and key\n * out-parameters are filled by the function (and subsection is NULL if it is\n * missing).\n */\nextern int parse_config_key(const char *var,\n\t\t\t    const char *section,\n\t\t\t    const char **subsection, int *subsection_len,\n\t\t\t    const char **key);\n\nextern int committer_ident_sufficiently_given(void);\nextern int author_ident_sufficiently_given(void);\n\nextern const char *git_commit_encoding;\nextern const char *git_log_output_encoding;\nextern const char *git_mailmap_file;\nextern const char *git_mailmap_blob;\n\n/* IO helper functions */\nextern void maybe_flush_or_die(FILE *, const char *);\nextern int copy_fd(int ifd, int ofd);\nextern int copy_file(const char *dst, const char *src, int mode);\nextern int copy_file_with_time(const char *dst, const char *src, int mode);\nextern void write_or_die(int fd, const void *buf, size_t count);\nextern int write_or_whine(int fd, const void *buf, size_t count, const char *msg);\nextern int write_or_whine_pipe(int fd, const void *buf, size_t count, const char *msg);\nextern void fsync_or_die(int fd, const char *);\n\nextern ssize_t read_in_full(int fd, void *buf, size_t count);\nextern ssize_t write_in_full(int fd, const void *buf, size_t count);\nstatic inline ssize_t write_str_in_full(int fd, const char *str)\n{\n\treturn write_in_full(fd, str, strlen(str));\n}\n\n/* pager.c */\nextern void setup_pager(void);\nextern const char *pager_program;\nextern int pager_in_use(void);\nextern int pager_use_color;\nextern int term_columns(void);\nextern int decimal_width(int);\nextern int check_pager_config(const char *cmd);\n\nextern const char *editor_program;\nextern const char *askpass_program;\nextern const char *excludes_file;\n\n/* base85 */\nint decode_85(char *dst, const char *line, int linelen);\nvoid encode_85(char *buf, const unsigned char *data, int bytes);\n\n/* alloc.c */\nextern void *alloc_blob_node(void);\nextern void *alloc_tree_node(void);\nextern void *alloc_commit_node(void);\nextern void *alloc_tag_node(void);\nextern void *alloc_object_node(void);\nextern void alloc_report(void);\n\n/* trace.c */\n__attribute__((format (printf, 1, 2)))\nextern void trace_printf(const char *format, ...);\n__attribute__((format (printf, 2, 3)))\nextern void trace_argv_printf(const char **argv, const char *format, ...);\nextern void trace_repo_setup(const char *prefix);\nextern int trace_want(const char *key);\n__attribute__((format (printf, 2, 3)))\nextern void trace_printf_key(const char *key, const char *fmt, ...);\nextern void trace_strbuf(const char *key, const struct strbuf *buf);\n\nvoid packet_trace_identity(const char *prog);\n\n/* add */\n/*\n * return 0 if success, 1 - if addition of a file failed and\n * ADD_FILES_IGNORE_ERRORS was specified in flags\n */\nint add_files_to_cache(const char *prefix, const struct pathspec *pathspec, int flags);\n\n/* diff.c */\nextern int diff_auto_refresh_index;\n\n/* match-trees.c */\nvoid shift_tree(const unsigned char *, const unsigned char *, unsigned char *, int);\nvoid shift_tree_by(const unsigned char *, const unsigned char *, unsigned char *, const char *);\n\n/*\n * whitespace rules.\n * used by both diff and apply\n * last two digits are tab width\n */\n#define WS_BLANK_AT_EOL         0100\n#define WS_SPACE_BEFORE_TAB     0200\n#define WS_INDENT_WITH_NON_TAB  0400\n#define WS_CR_AT_EOL           01000\n#define WS_BLANK_AT_EOF        02000\n#define WS_TAB_IN_INDENT       04000\n#define WS_TRAILING_SPACE      (WS_BLANK_AT_EOL|WS_BLANK_AT_EOF)\n#define WS_DEFAULT_RULE (WS_TRAILING_SPACE|WS_SPACE_BEFORE_TAB|8)\n#define WS_TAB_WIDTH_MASK        077\nextern unsigned whitespace_rule_cfg;\nextern unsigned whitespace_rule(const char *);\nextern unsigned parse_whitespace_rule(const char *);\nextern unsigned ws_check(const char *line, int len, unsigned ws_rule);\nextern void ws_check_emit(const char *line, int len, unsigned ws_rule, FILE *stream, const char *set, const char *reset, const char *ws);\nextern char *whitespace_error_string(unsigned ws);\nextern void ws_fix_copy(struct strbuf *, const char *, int, unsigned, int *);\nextern int ws_blank_line(const char *line, int len, unsigned ws_rule);\n#define ws_tab_width(rule)     ((rule) & WS_TAB_WIDTH_MASK)\n\n/* ls-files */\nint report_path_error(const char *ps_matched, const struct pathspec *pathspec, const char *prefix);\nvoid overlay_tree_on_cache(const char *tree_name, const char *prefix);\n\nchar *alias_lookup(const char *alias);\nint split_cmdline(char *cmdline, const char ***argv);\n/* Takes a negative value returned by split_cmdline */\nconst char *split_cmdline_strerror(int cmdline_errno);\n\n/* git.c */\nstruct startup_info {\n\tint have_repository;\n\tconst char *prefix;\n};\nextern struct startup_info *startup_info;\n\n/* merge.c */\nstruct commit_list;\nint try_merge_command(const char *strategy, size_t xopts_nr,\n\t\tconst char **xopts, struct commit_list *common,\n\t\tconst char *head_arg, struct commit_list *remotes);\nint checkout_fast_forward(const unsigned char *from,\n\t\t\t  const unsigned char *to,\n\t\t\t  int overwrite_ignore);\n\n\nint sane_execvp(const char *file, char *const argv[]);\n\n/*\n * A struct to encapsulate the concept of whether a file has changed\n * since we last checked it. This uses criteria similar to those used\n * for the index.\n */\nstruct stat_validity {\n\tstruct stat_data *sd;\n};\n\nvoid stat_validity_clear(struct stat_validity *sv);\n\n/*\n * Returns 1 if the path is a regular file (or a symlink to a regular\n * file) and matches the saved stat_validity, 0 otherwise.  A missing\n * or inaccessible file is considered a match if the struct was just\n * initialized, or if the previous update found an inaccessible file.\n */\nint stat_validity_check(struct stat_validity *sv, const char *path);\n\n/*\n * Update the stat_validity from a file opened at descriptor fd. If\n * the file is missing, inaccessible, or not a regular file, then\n * future calls to stat_validity_check will match iff one of those\n * conditions continues to be true.\n */\nvoid stat_validity_update(struct stat_validity *sv, int fd);\n\n#endif /* CACHE_H */\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "001b63f5cd0f31658686c566e1261c347ad36fa0",
  "sha1_ok": true,
  "size": 50112
}
