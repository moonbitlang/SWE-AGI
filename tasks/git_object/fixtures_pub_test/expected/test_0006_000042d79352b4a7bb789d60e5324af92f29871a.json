{
  "content": {
    "base64": "I2lmbmRlZiBHSVRfQ09NUEFUX1VUSUxfSAojZGVmaW5lIEdJVF9DT01QQVRfVVRJTF9ICgojZGVmaW5lIF9GSUxFX09GRlNFVF9CSVRTIDY0CgojaWZuZGVmIEZMRVhfQVJSQVkKLyoKICogU2VlIGlmIG91ciBjb21waWxlciBpcyBrbm93biB0byBzdXBwb3J0IGZsZXhpYmxlIGFycmF5IG1lbWJlcnMuCiAqLwojaWYgZGVmaW5lZChfX1NURENfVkVSU0lPTl9fKSAmJiAoX19TVERDX1ZFUlNJT05fXyA+PSAxOTk5MDFMKSAmJiAoIWRlZmluZWQoX19TVU5QUk9fQykgfHwgKF9fU1VOUFJPX0MgPiAweDU4MCkpCiMgZGVmaW5lIEZMRVhfQVJSQVkgLyogZW1wdHkgKi8KI2VsaWYgZGVmaW5lZChfX0dOVUNfXykKIyBpZiAoX19HTlVDX18gPj0gMykKIyAgZGVmaW5lIEZMRVhfQVJSQVkgLyogZW1wdHkgKi8KIyBlbHNlCiMgIGRlZmluZSBGTEVYX0FSUkFZIDAgLyogb2xkZXIgR05VIGV4dGVuc2lvbiAqLwojIGVuZGlmCiNlbmRpZgoKLyoKICogT3RoZXJ3aXNlLCBkZWZhdWx0IHRvIHNhZmVyIGJ1dCBhIGJpdCB3YXN0ZWZ1bCB0cmFkaXRpb25hbCBzdHlsZQogKi8KI2lmbmRlZiBGTEVYX0FSUkFZCiMgZGVmaW5lIEZMRVhfQVJSQVkgMQojZW5kaWYKI2VuZGlmCgojZGVmaW5lIEFSUkFZX1NJWkUoeCkgKHNpemVvZih4KS9zaXplb2YoeFswXSkpCiNkZWZpbmUgYml0c2l6ZW9mKHgpICAoQ0hBUl9CSVQgKiBzaXplb2YoeCkpCgojZGVmaW5lIG1heGltdW1fc2lnbmVkX3ZhbHVlX29mX3R5cGUoYSkgXAogICAgKElOVE1BWF9NQVggPj4gKGJpdHNpemVvZihpbnRtYXhfdCkgLSBiaXRzaXplb2YoYSkpKQoKI2RlZmluZSBtYXhpbXVtX3Vuc2lnbmVkX3ZhbHVlX29mX3R5cGUoYSkgXAogICAgKFVJTlRNQVhfTUFYID4+IChiaXRzaXplb2YodWludG1heF90KSAtIGJpdHNpemVvZihhKSkpCgovKgogKiBTaWduZWQgaW50ZWdlciBvdmVyZmxvdyBpcyB1bmRlZmluZWQgaW4gQywgc28gaGVyZSdzIGEgaGVscGVyIG1hY3JvCiAqIHRvIGRldGVjdCBpZiB0aGUgc3VtIG9mIHR3byBpbnRlZ2VycyB3aWxsIG92ZXJmbG93LgogKgogKiBSZXF1aXJlczogYSA+PSAwLCB0eXBlb2YoYSkgZXF1YWxzIHR5cGVvZihiKQogKi8KI2RlZmluZSBzaWduZWRfYWRkX292ZXJmbG93cyhhLCBiKSBcCiAgICAoKGIpID4gbWF4aW11bV9zaWduZWRfdmFsdWVfb2ZfdHlwZShhKSAtIChhKSkKCiNkZWZpbmUgdW5zaWduZWRfYWRkX292ZXJmbG93cyhhLCBiKSBcCiAgICAoKGIpID4gbWF4aW11bV91bnNpZ25lZF92YWx1ZV9vZl90eXBlKGEpIC0gKGEpKQoKI2lmZGVmIF9fR05VQ19fCiNkZWZpbmUgVFlQRU9GKHgpIChfX3R5cGVvZl9fKHgpKQojZWxzZQojZGVmaW5lIFRZUEVPRih4KQojZW5kaWYKCiNkZWZpbmUgTVNCKHgsIGJpdHMpICgoeCkgJiBUWVBFT0YoeCkofjBVTEwgPDwgKGJpdHNpemVvZih4KSAtIChiaXRzKSkpKQojZGVmaW5lIEhBU19NVUxUSV9CSVRTKGkpICAoKGkpICYgKChpKSAtIDEpKSAgLyogY2hlY2tzIGlmIGFuIGludGVnZXIgaGFzIG1vcmUgdGhhbiAxIGJpdCBzZXQgKi8KCiNkZWZpbmUgRElWX1JPVU5EX1VQKG4sZCkgKCgobikgKyAoZCkgLSAxKSAvIChkKSkKCi8qIEFwcHJveGltYXRpb24gb2YgdGhlIGxlbmd0aCBvZiB0aGUgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHR5cGUuICovCiNkZWZpbmUgZGVjaW1hbF9sZW5ndGgoeCkJKChpbnQpKHNpemVvZih4KSAqIDIuNTYgKyAwLjUpICsgMSkKCiNpZiBkZWZpbmVkKF9fc3VuX18pCiAvKgogICogT24gU29sYXJpcywgd2hlbiBfWE9QRU5fRVhURU5ERUQgaXMgc2V0LCBpdHMgaGVhZGVyIGZpbGUKICAqIGZvcmNlcyB0aGUgcHJvZ3JhbXMgdG8gYmUgWFBHNHYyLCBkZWZlYXRpbmcgYW55IF9YT1BFTl9TT1VSQ0UKICAqIHNldHRpbmcgdG8gc2F5IHdlIGFyZSBYUEc1IG9yIFhQRzYuICBBbHNvIG9uIFNvbGFyaXMsCiAgKiBYUEc2IHByb2dyYW1zIG11c3QgYmUgY29tcGlsZWQgd2l0aCBhIGM5OSBjb21waWxlciwgd2hpbGUKICAqIG5vbiBYUEc2IHByb2dyYW1zIG11c3QgYmUgY29tcGlsZWQgd2l0aCBhIHByZS1jOTkgY29tcGlsZXIuCiAgKi8KIyBpZiBfX1NURENfVkVSU0lPTl9fIC0gMCA+PSAxOTk5MDFMCiMgZGVmaW5lIF9YT1BFTl9TT1VSQ0UgNjAwCiMgZWxzZQojIGRlZmluZSBfWE9QRU5fU09VUkNFIDUwMAojIGVuZGlmCiNlbGlmICFkZWZpbmVkKF9fQVBQTEVfXykgJiYgIWRlZmluZWQoX19GcmVlQlNEX18pICYmICFkZWZpbmVkKF9fVVNMQ19fKSAmJiBcCiAgICAgICFkZWZpbmVkKF9NX1VOSVgpICYmICFkZWZpbmVkKF9fc2dpKSAmJiAhZGVmaW5lZChfX0RyYWdvbkZseV9fKQojZGVmaW5lIF9YT1BFTl9TT1VSQ0UgNjAwIC8qIGdsaWJjMiBhbmQgQUlYIDUuM0wgbmVlZCA1MDAsIE9wZW5CU0QgbmVlZHMgNjAwIGZvciBTX0lTTE5LKCkgKi8KI2RlZmluZSBfWE9QRU5fU09VUkNFX0VYVEVOREVEIDEgLyogQUlYIDUuM0wgbmVlZHMgdGhpcyAqLwojZW5kaWYKI2RlZmluZSBfQUxMX1NPVVJDRSAxCiNkZWZpbmUgX0dOVV9TT1VSQ0UgMQojZGVmaW5lIF9CU0RfU09VUkNFIDEKI2RlZmluZSBfTkVUQlNEX1NPVVJDRSAxCiNkZWZpbmUgX1NHSV9TT1VSQ0UgMQoKI2lmZGVmIFdJTjMyIC8qIEJvdGggTWluR1cgYW5kIE1TVkMgKi8KI2RlZmluZSBXSU4zMl9MRUFOX0FORF9NRUFOICAvKiBzdG9wcyB3aW5kb3dzLmggaW5jbHVkaW5nIHdpbnNvY2suaCAqLwojaW5jbHVkZSA8d2luc29jazIuaD4KI2luY2x1ZGUgPHdpbmRvd3MuaD4KI2VuZGlmCgojaW5jbHVkZSA8dW5pc3RkLmg+CiNpbmNsdWRlIDxzdGRpby5oPgojaW5jbHVkZSA8c3lzL3N0YXQuaD4KI2luY2x1ZGUgPGZjbnRsLmg+CiNpbmNsdWRlIDxzdGRkZWYuaD4KI2luY2x1ZGUgPHN0ZGxpYi5oPgojaW5jbHVkZSA8c3RkYXJnLmg+CiNpbmNsdWRlIDxzdHJpbmcuaD4KI2luY2x1ZGUgPGVycm5vLmg+CiNpbmNsdWRlIDxsaW1pdHMuaD4KI2luY2x1ZGUgPHN5cy9wYXJhbS5oPgojaW5jbHVkZSA8c3lzL3R5cGVzLmg+CiNpbmNsdWRlIDxkaXJlbnQuaD4KI2luY2x1ZGUgPHN5cy90aW1lLmg+CiNpbmNsdWRlIDx0aW1lLmg+CiNpbmNsdWRlIDxzaWduYWwuaD4KI2luY2x1ZGUgPGZubWF0Y2guaD4KI2luY2x1ZGUgPGFzc2VydC5oPgojaW5jbHVkZSA8cmVnZXguaD4KI2luY2x1ZGUgPHV0aW1lLmg+CiNpbmNsdWRlIDxzeXNsb2cuaD4KI2lmbmRlZiBOT19TWVNfUE9MTF9ICiNpbmNsdWRlIDxzeXMvcG9sbC5oPgojZWxzZQojaW5jbHVkZSA8cG9sbC5oPgojZW5kaWYKI2lmIGRlZmluZWQoX19NSU5HVzMyX18pCi8qIHB1bGwgaW4gV2luZG93cyBjb21wYXRpYmlsaXR5IHN0dWZmICovCiNpbmNsdWRlICJjb21wYXQvbWluZ3cuaCIKI2VsaWYgZGVmaW5lZChfTVNDX1ZFUikKI2luY2x1ZGUgImNvbXBhdC9tc3ZjLmgiCiNlbHNlCiNpbmNsdWRlIDxzeXMvd2FpdC5oPgojaW5jbHVkZSA8c3lzL3Jlc291cmNlLmg+CiNpbmNsdWRlIDxzeXMvc29ja2V0Lmg+CiNpbmNsdWRlIDxzeXMvaW9jdGwuaD4KI2luY2x1ZGUgPHRlcm1pb3MuaD4KI2lmbmRlZiBOT19TWVNfU0VMRUNUX0gKI2luY2x1ZGUgPHN5cy9zZWxlY3QuaD4KI2VuZGlmCiNpbmNsdWRlIDxuZXRpbmV0L2luLmg+CiNpbmNsdWRlIDxuZXRpbmV0L3RjcC5oPgojaW5jbHVkZSA8YXJwYS9pbmV0Lmg+CiNpbmNsdWRlIDxuZXRkYi5oPgojaW5jbHVkZSA8cHdkLmg+CiNpbmNsdWRlIDxzeXMvdW4uaD4KI2lmbmRlZiBOT19JTlRUWVBFU19ICiNpbmNsdWRlIDxpbnR0eXBlcy5oPgojZWxzZQojaW5jbHVkZSA8c3RkaW50Lmg+CiNlbmRpZgojaWYgZGVmaW5lZChfX0NZR1dJTl9fKQojdW5kZWYgX1hPUEVOX1NPVVJDRQojaW5jbHVkZSA8Z3JwLmg+CiNkZWZpbmUgX1hPUEVOX1NPVVJDRSA2MDAKI2luY2x1ZGUgImNvbXBhdC9jeWd3aW4uaCIKI2Vsc2UKI3VuZGVmIF9BTExfU09VUkNFIC8qIEFJWCA1LjNMIGRlZmluZXMgYSBzdHJ1Y3QgbGlzdCB3aXRoIF9BTExfU09VUkNFLiAqLwojaW5jbHVkZSA8Z3JwLmg+CiNkZWZpbmUgX0FMTF9TT1VSQ0UgMQojZW5kaWYKI2VuZGlmCgovKiB1c2VkIG9uIE1hYyBPUyBYICovCiNpZmRlZiBQUkVDT01QT1NFX1VOSUNPREUKI2luY2x1ZGUgImNvbXBhdC9wcmVjb21wb3NlX3V0ZjguaCIKI2Vsc2UKI2RlZmluZSBwcmVjb21wb3NlX3N0cihpbixpX25mZDJuZmMpCiNkZWZpbmUgcHJlY29tcG9zZV9hcmd2KGMsdikKI2RlZmluZSBwcm9iZV91dGY4X3BhdGhuYW1lX2NvbXBvc2l0aW9uKGEsYikKI2VuZGlmCgojaWZuZGVmIE5PX0xJQkdFTl9ICiNpbmNsdWRlIDxsaWJnZW4uaD4KI2Vsc2UKI2RlZmluZSBiYXNlbmFtZSBnaXRiYXNlbmFtZQpleHRlcm4gY2hhciAqZ2l0YmFzZW5hbWUoY2hhciAqKTsKI2VuZGlmCgojaWZuZGVmIE5PX0lDT05WCiNpbmNsdWRlIDxpY29udi5oPgojZW5kaWYKCiNpZm5kZWYgTk9fT1BFTlNTTAojaW5jbHVkZSA8b3BlbnNzbC9zc2wuaD4KI2luY2x1ZGUgPG9wZW5zc2wvZXJyLmg+CiNlbmRpZgoKLyogT24gbW9zdCBzeXN0ZW1zIDxsaW1pdHMuaD4gd291bGQgaGF2ZSBnaXZlbiB1cyB0aGlzLCBidXQKICogbm90IG9uIHNvbWUgc3lzdGVtcyAoZS5nLiBHTlUvSHVyZCkuCiAqLwojaWZuZGVmIFBBVEhfTUFYCiNkZWZpbmUgUEFUSF9NQVggNDA5NgojZW5kaWYKCiNpZm5kZWYgUFJJdU1BWAojZGVmaW5lIFBSSXVNQVggImxsdSIKI2VuZGlmCgojaWZuZGVmIFBSSXUzMgojZGVmaW5lIFBSSXUzMiAidSIKI2VuZGlmCgojaWZuZGVmIFBSSXgzMgojZGVmaW5lIFBSSXgzMiAieCIKI2VuZGlmCgojaWZuZGVmIFBSSW8zMgojZGVmaW5lIFBSSW8zMiAibyIKI2VuZGlmCgojaWZuZGVmIFBBVEhfU0VQCiNkZWZpbmUgUEFUSF9TRVAgJzonCiNlbmRpZgoKI2lmZGVmIEhBVkVfUEFUSFNfSAojaW5jbHVkZSA8cGF0aHMuaD4KI2VuZGlmCiNpZm5kZWYgX1BBVEhfREVGUEFUSAojZGVmaW5lIF9QQVRIX0RFRlBBVEggIi91c3IvbG9jYWwvYmluOi91c3IvYmluOi9iaW4iCiNlbmRpZgoKI2lmbmRlZiBTVFJJUF9FWFRFTlNJT04KI2RlZmluZSBTVFJJUF9FWFRFTlNJT04gIiIKI2VuZGlmCgojaWZuZGVmIGhhc19kb3NfZHJpdmVfcHJlZml4CiNkZWZpbmUgaGFzX2Rvc19kcml2ZV9wcmVmaXgocGF0aCkgMAojZW5kaWYKCiNpZm5kZWYgaXNfZGlyX3NlcAojZGVmaW5lIGlzX2Rpcl9zZXAoYykgKChjKSA9PSAnLycpCiNlbmRpZgoKI2lmbmRlZiBmaW5kX2xhc3RfZGlyX3NlcAojZGVmaW5lIGZpbmRfbGFzdF9kaXJfc2VwKHBhdGgpIHN0cnJjaHIocGF0aCwgJy8nKQojZW5kaWYKCiNpZiBkZWZpbmVkKF9fSFBfY2MpICYmIChfX0hQX2NjID49IDYxMDAwKQojZGVmaW5lIE5PUkVUVVJOIF9fYXR0cmlidXRlX18oKG5vcmV0dXJuKSkKI2RlZmluZSBOT1JFVFVSTl9QVFIKI2VsaWYgZGVmaW5lZChfX0dOVUNfXykgJiYgIWRlZmluZWQoTk9fTk9SRVRVUk4pCiNkZWZpbmUgTk9SRVRVUk4gX19hdHRyaWJ1dGVfXygoX19ub3JldHVybl9fKSkKI2RlZmluZSBOT1JFVFVSTl9QVFIgX19hdHRyaWJ1dGVfXygoX19ub3JldHVybl9fKSkKI2VsaWYgZGVmaW5lZChfTVNDX1ZFUikKI2RlZmluZSBOT1JFVFVSTiBfX2RlY2xzcGVjKG5vcmV0dXJuKQojZGVmaW5lIE5PUkVUVVJOX1BUUgojZWxzZQojZGVmaW5lIE5PUkVUVVJOCiNkZWZpbmUgTk9SRVRVUk5fUFRSCiNpZm5kZWYgX19hdHRyaWJ1dGVfXwojZGVmaW5lIF9fYXR0cmlidXRlX18oeCkKI2VuZGlmCiNlbmRpZgoKI2luY2x1ZGUgImNvbXBhdC9ic3dhcC5oIgoKLyogR2VuZXJhbCBoZWxwZXIgZnVuY3Rpb25zICovCmV4dGVybiB2b2lkIHZyZXBvcnRmKGNvbnN0IGNoYXIgKnByZWZpeCwgY29uc3QgY2hhciAqZXJyLCB2YV9saXN0IHBhcmFtcyk7CmV4dGVybiB2b2lkIHZ3cml0ZWYoaW50IGZkLCBjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IGNoYXIgKmVyciwgdmFfbGlzdCBwYXJhbXMpOwpleHRlcm4gTk9SRVRVUk4gdm9pZCB1c2FnZShjb25zdCBjaGFyICplcnIpOwpleHRlcm4gTk9SRVRVUk4gdm9pZCB1c2FnZWYoY29uc3QgY2hhciAqZXJyLCAuLi4pIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwpleHRlcm4gTk9SRVRVUk4gdm9pZCBkaWUoY29uc3QgY2hhciAqZXJyLCAuLi4pIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwpleHRlcm4gTk9SRVRVUk4gdm9pZCBkaWVfZXJybm8oY29uc3QgY2hhciAqZXJyLCAuLi4pIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwpleHRlcm4gaW50IGVycm9yKGNvbnN0IGNoYXIgKmVyciwgLi4uKSBfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMSwgMikpKTsKZXh0ZXJuIHZvaWQgd2FybmluZyhjb25zdCBjaGFyICplcnIsIC4uLikgX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsIDEsIDIpKSk7CgpleHRlcm4gdm9pZCBzZXRfZGllX3JvdXRpbmUoTk9SRVRVUk5fUFRSIHZvaWQgKCpyb3V0aW5lKShjb25zdCBjaGFyICplcnIsIHZhX2xpc3QgcGFyYW1zKSk7CmV4dGVybiB2b2lkIHNldF9lcnJvcl9yb3V0aW5lKHZvaWQgKCpyb3V0aW5lKShjb25zdCBjaGFyICplcnIsIHZhX2xpc3QgcGFyYW1zKSk7CgpleHRlcm4gaW50IHByZWZpeGNtcChjb25zdCBjaGFyICpzdHIsIGNvbnN0IGNoYXIgKnByZWZpeCk7CmV4dGVybiBpbnQgc3VmZml4Y21wKGNvbnN0IGNoYXIgKnN0ciwgY29uc3QgY2hhciAqc3VmZml4KTsKCnN0YXRpYyBpbmxpbmUgY29uc3QgY2hhciAqc2tpcF9wcmVmaXgoY29uc3QgY2hhciAqc3RyLCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXNpemVfdCBsZW4gPSBzdHJsZW4ocHJlZml4KTsKCXJldHVybiBzdHJuY21wKHN0ciwgcHJlZml4LCBsZW4pID8gTlVMTCA6IHN0ciArIGxlbjsKfQoKI2lmIGRlZmluZWQoTk9fTU1BUCkgfHwgZGVmaW5lZChVU0VfV0lOMzJfTU1BUCkKCiNpZm5kZWYgUFJPVF9SRUFECiNkZWZpbmUgUFJPVF9SRUFEIDEKI2RlZmluZSBQUk9UX1dSSVRFIDIKI2RlZmluZSBNQVBfUFJJVkFURSAxCiNlbmRpZgoKI2RlZmluZSBtbWFwIGdpdF9tbWFwCiNkZWZpbmUgbXVubWFwIGdpdF9tdW5tYXAKZXh0ZXJuIHZvaWQgKmdpdF9tbWFwKHZvaWQgKnN0YXJ0LCBzaXplX3QgbGVuZ3RoLCBpbnQgcHJvdCwgaW50IGZsYWdzLCBpbnQgZmQsIG9mZl90IG9mZnNldCk7CmV4dGVybiBpbnQgZ2l0X211bm1hcCh2b2lkICpzdGFydCwgc2l6ZV90IGxlbmd0aCk7CgojZWxzZSAvKiBOT19NTUFQIHx8IFVTRV9XSU4zMl9NTUFQICovCgojaW5jbHVkZSA8c3lzL21tYW4uaD4KCiNlbmRpZiAvKiBOT19NTUFQIHx8IFVTRV9XSU4zMl9NTUFQICovCgojaWZkZWYgTk9fTU1BUAoKLyogVGhpcyB2YWx1ZSBtdXN0IGJlIG11bHRpcGxlIG9mIChwYWdlc2l6ZSAqIDIpICovCiNkZWZpbmUgREVGQVVMVF9QQUNLRURfR0lUX1dJTkRPV19TSVpFICgxICogMTAyNCAqIDEwMjQpCgojZWxzZSAvKiBOT19NTUFQICovCgovKiBUaGlzIHZhbHVlIG11c3QgYmUgbXVsdGlwbGUgb2YgKHBhZ2VzaXplICogMikgKi8KI2RlZmluZSBERUZBVUxUX1BBQ0tFRF9HSVRfV0lORE9XX1NJWkUgXAoJKHNpemVvZih2b2lkKikgPj0gOCBcCgkJPyAgMSAqIDEwMjQgKiAxMDI0ICogMTAyNCBcCgkJOiAzMiAqIDEwMjQgKiAxMDI0KQoKI2VuZGlmIC8qIE5PX01NQVAgKi8KCiNpZm5kZWYgTUFQX0ZBSUxFRAojZGVmaW5lIE1BUF9GQUlMRUQgKCh2b2lkICopLTEpCiNlbmRpZgoKI2lmZGVmIE5PX1NUX0JMT0NLU19JTl9TVFJVQ1RfU1RBVAojZGVmaW5lIG9uX2Rpc2tfYnl0ZXMoc3QpICgoc3QpLnN0X3NpemUpCiNlbHNlCiNkZWZpbmUgb25fZGlza19ieXRlcyhzdCkgKChzdCkuc3RfYmxvY2tzICogNTEyKQojZW5kaWYKCiNkZWZpbmUgREVGQVVMVF9QQUNLRURfR0lUX0xJTUlUIFwKCSgoMTAyNEwgKiAxMDI0TCkgKiAoc2l6ZW9mKHZvaWQqKSA+PSA4ID8gODE5MiA6IDI1NikpCgojaWZkZWYgTk9fUFJFQUQKI2RlZmluZSBwcmVhZCBnaXRfcHJlYWQKZXh0ZXJuIHNzaXplX3QgZ2l0X3ByZWFkKGludCBmZCwgdm9pZCAqYnVmLCBzaXplX3QgY291bnQsIG9mZl90IG9mZnNldCk7CiNlbmRpZgovKgogKiBGb3J3YXJkIGRlY2wgdGhhdCB3aWxsIHJlbWluZCB1cyBpZiBpdHMgdHdpbiBpbiBjYWNoZS5oIGNoYW5nZXMuCiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbiBjb21wYXQvcHJlYWQuYy4gIEJ1dCB3ZSBjYW4ndCBpbmNsdWRlCiAqIGNhY2hlLmggdGhlcmUuCiAqLwpleHRlcm4gc3NpemVfdCByZWFkX2luX2Z1bGwoaW50IGZkLCB2b2lkICpidWYsIHNpemVfdCBjb3VudCk7CgojaWZkZWYgTk9fU0VURU5WCiNkZWZpbmUgc2V0ZW52IGdpdHNldGVudgpleHRlcm4gaW50IGdpdHNldGVudihjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKiwgaW50KTsKI2VuZGlmCgojaWZkZWYgTk9fTUtEVEVNUAojZGVmaW5lIG1rZHRlbXAgZ2l0bWtkdGVtcApleHRlcm4gY2hhciAqZ2l0bWtkdGVtcChjaGFyICopOwojZW5kaWYKCiNpZmRlZiBOT19NS1NURU1QUwojZGVmaW5lIG1rc3RlbXBzIGdpdG1rc3RlbXBzCmV4dGVybiBpbnQgZ2l0bWtzdGVtcHMoY2hhciAqLCBpbnQpOwojZW5kaWYKCiNpZmRlZiBOT19VTlNFVEVOVgojZGVmaW5lIHVuc2V0ZW52IGdpdHVuc2V0ZW52CmV4dGVybiB2b2lkIGdpdHVuc2V0ZW52KGNvbnN0IGNoYXIgKik7CiNlbmRpZgoKI2lmZGVmIE5PX1NUUkNBU0VTVFIKI2RlZmluZSBzdHJjYXNlc3RyIGdpdHN0cmNhc2VzdHIKZXh0ZXJuIGNoYXIgKmdpdHN0cmNhc2VzdHIoY29uc3QgY2hhciAqaGF5c3RhY2ssIGNvbnN0IGNoYXIgKm5lZWRsZSk7CiNlbmRpZgoKI2lmZGVmIE5PX1NUUkxDUFkKI2RlZmluZSBzdHJsY3B5IGdpdHN0cmxjcHkKZXh0ZXJuIHNpemVfdCBnaXRzdHJsY3B5KGNoYXIgKiwgY29uc3QgY2hhciAqLCBzaXplX3QpOwojZW5kaWYKCiNpZmRlZiBOT19TVFJUT1VNQVgKI2RlZmluZSBzdHJ0b3VtYXggZ2l0c3RydG91bWF4CmV4dGVybiB1aW50bWF4X3QgZ2l0c3RydG91bWF4KGNvbnN0IGNoYXIgKiwgY2hhciAqKiwgaW50KTsKI2RlZmluZSBzdHJ0b2ltYXggZ2l0c3RydG9pbWF4CmV4dGVybiBpbnRtYXhfdCBnaXRzdHJ0b2ltYXgoY29uc3QgY2hhciAqLCBjaGFyICoqLCBpbnQpOwojZW5kaWYKCiNpZmRlZiBOT19TVFJUT0tfUgojZGVmaW5lIHN0cnRva19yIGdpdHN0cnRva19yCmV4dGVybiBjaGFyICpnaXRzdHJ0b2tfcihjaGFyICpzLCBjb25zdCBjaGFyICpkZWxpbSwgY2hhciAqKnNhdmVfcHRyKTsKI2VuZGlmCgojaWZkZWYgTk9fSFNUUkVSUk9SCiNkZWZpbmUgaHN0cmVycm9yIGdpdGhzdHJlcnJvcgpleHRlcm4gY29uc3QgY2hhciAqZ2l0aHN0cmVycm9yKGludCBoZXJyb3IpOwojZW5kaWYKCiNpZmRlZiBOT19NRU1NRU0KI2RlZmluZSBtZW1tZW0gZ2l0bWVtbWVtCnZvaWQgKmdpdG1lbW1lbShjb25zdCB2b2lkICpoYXlzdGFjaywgc2l6ZV90IGhheXN0YWNrbGVuLAogICAgICAgICAgICAgICAgY29uc3Qgdm9pZCAqbmVlZGxlLCBzaXplX3QgbmVlZGxlbGVuKTsKI2VuZGlmCgojaWZkZWYgRlJFQURfUkVBRFNfRElSRUNUT1JJRVMKI2lmZGVmIGZvcGVuCiN1bmRlZiBmb3BlbgojZW5kaWYKI2RlZmluZSBmb3BlbihhLGIpIGdpdF9mb3BlbihhLGIpCmV4dGVybiBGSUxFICpnaXRfZm9wZW4oY29uc3QgY2hhciosIGNvbnN0IGNoYXIqKTsKI2VuZGlmCgojaWZkZWYgU05QUklOVEZfUkVUVVJOU19CT0dVUwojZGVmaW5lIHNucHJpbnRmIGdpdF9zbnByaW50ZgpleHRlcm4gaW50IGdpdF9zbnByaW50ZihjaGFyICpzdHIsIHNpemVfdCBtYXhzaXplLAoJCQljb25zdCBjaGFyICpmb3JtYXQsIC4uLik7CiNkZWZpbmUgdnNucHJpbnRmIGdpdF92c25wcmludGYKZXh0ZXJuIGludCBnaXRfdnNucHJpbnRmKGNoYXIgKnN0ciwgc2l6ZV90IG1heHNpemUsCgkJCSBjb25zdCBjaGFyICpmb3JtYXQsIHZhX2xpc3QgYXApOwojZW5kaWYKCiNpZmRlZiBfX0dMSUJDX1BSRVJFUQojaWYgX19HTElCQ19QUkVSRVEoMiwgMSkKI2RlZmluZSBIQVZFX1NUUkNIUk5VTAojZGVmaW5lIEhBVkVfTUVNUENQWQojZW5kaWYKI2VuZGlmCgojaWZuZGVmIEhBVkVfU1RSQ0hSTlVMCiNkZWZpbmUgc3RyY2hybnVsIGdpdHN0cmNocm51bApzdGF0aWMgaW5saW5lIGNoYXIgKmdpdHN0cmNocm51bChjb25zdCBjaGFyICpzLCBpbnQgYykKewoJd2hpbGUgKCpzICYmICpzICE9IGMpCgkJcysrOwoJcmV0dXJuIChjaGFyICopczsKfQojZW5kaWYKCiNpZm5kZWYgSEFWRV9NRU1QQ1BZCiNkZWZpbmUgbWVtcGNweSBnaXRtZW1wY3B5CnN0YXRpYyBpbmxpbmUgdm9pZCAqZ2l0bWVtcGNweSh2b2lkICpkZXN0LCBjb25zdCB2b2lkICpzcmMsIHNpemVfdCBuKQp7CglyZXR1cm4gKGNoYXIgKiltZW1jcHkoZGVzdCwgc3JjLCBuKSArIG47Cn0KI2VuZGlmCgojaWZkZWYgTk9fSU5FVF9QVE9OCmludCBpbmV0X3B0b24oaW50IGFmLCBjb25zdCBjaGFyICpzcmMsIHZvaWQgKmRzdCk7CiNlbmRpZgoKI2lmZGVmIE5PX0lORVRfTlRPUApjb25zdCBjaGFyICppbmV0X250b3AoaW50IGFmLCBjb25zdCB2b2lkICpzcmMsIGNoYXIgKmRzdCwgc2l6ZV90IHNpemUpOwojZW5kaWYKCmV4dGVybiB2b2lkIHJlbGVhc2VfcGFja19tZW1vcnkoc2l6ZV90LCBpbnQpOwoKdHlwZWRlZiB2b2lkICgqdHJ5X3RvX2ZyZWVfdCkoc2l6ZV90KTsKZXh0ZXJuIHRyeV90b19mcmVlX3Qgc2V0X3RyeV90b19mcmVlX3JvdXRpbmUodHJ5X3RvX2ZyZWVfdCk7CgpleHRlcm4gY2hhciAqeHN0cmR1cChjb25zdCBjaGFyICpzdHIpOwpleHRlcm4gdm9pZCAqeG1hbGxvYyhzaXplX3Qgc2l6ZSk7CmV4dGVybiB2b2lkICp4bWFsbG9jeihzaXplX3Qgc2l6ZSk7CmV4dGVybiB2b2lkICp4bWVtZHVweihjb25zdCB2b2lkICpkYXRhLCBzaXplX3QgbGVuKTsKZXh0ZXJuIGNoYXIgKnhzdHJuZHVwKGNvbnN0IGNoYXIgKnN0ciwgc2l6ZV90IGxlbik7CmV4dGVybiB2b2lkICp4cmVhbGxvYyh2b2lkICpwdHIsIHNpemVfdCBzaXplKTsKZXh0ZXJuIHZvaWQgKnhjYWxsb2Moc2l6ZV90IG5tZW1iLCBzaXplX3Qgc2l6ZSk7CmV4dGVybiB2b2lkICp4bW1hcCh2b2lkICpzdGFydCwgc2l6ZV90IGxlbmd0aCwgaW50IHByb3QsIGludCBmbGFncywgaW50IGZkLCBvZmZfdCBvZmZzZXQpOwpleHRlcm4gc3NpemVfdCB4cmVhZChpbnQgZmQsIHZvaWQgKmJ1Ziwgc2l6ZV90IGxlbik7CmV4dGVybiBzc2l6ZV90IHh3cml0ZShpbnQgZmQsIGNvbnN0IHZvaWQgKmJ1Ziwgc2l6ZV90IGxlbik7CmV4dGVybiBpbnQgeGR1cChpbnQgZmQpOwpleHRlcm4gRklMRSAqeGZkb3BlbihpbnQgZmQsIGNvbnN0IGNoYXIgKm1vZGUpOwpleHRlcm4gaW50IHhta3N0ZW1wKGNoYXIgKnRlbXBsYXRlKTsKZXh0ZXJuIGludCB4bWtzdGVtcF9tb2RlKGNoYXIgKnRlbXBsYXRlLCBpbnQgbW9kZSk7CmV4dGVybiBpbnQgb2RiX21rc3RlbXAoY2hhciAqdGVtcGxhdGUsIHNpemVfdCBsaW1pdCwgY29uc3QgY2hhciAqcGF0dGVybik7CmV4dGVybiBpbnQgb2RiX3BhY2tfa2VlcChjaGFyICpuYW1lLCBzaXplX3QgbmFtZXN6LCB1bnNpZ25lZCBjaGFyICpzaGExKTsKCnN0YXRpYyBpbmxpbmUgc2l6ZV90IHhzaXplX3Qob2ZmX3QgbGVuKQp7CglpZiAobGVuID4gKHNpemVfdCkgbGVuKQoJCWRpZSgiQ2Fubm90IGhhbmRsZSBmaWxlcyB0aGlzIGJpZyIpOwoJcmV0dXJuIChzaXplX3QpbGVuOwp9CgpzdGF0aWMgaW5saW5lIGludCBoYXNfZXh0ZW5zaW9uKGNvbnN0IGNoYXIgKmZpbGVuYW1lLCBjb25zdCBjaGFyICpleHQpCnsKCXNpemVfdCBsZW4gPSBzdHJsZW4oZmlsZW5hbWUpOwoJc2l6ZV90IGV4dGxlbiA9IHN0cmxlbihleHQpOwoJcmV0dXJuIGxlbiA+IGV4dGxlbiAmJiAhbWVtY21wKGZpbGVuYW1lICsgbGVuIC0gZXh0bGVuLCBleHQsIGV4dGxlbik7Cn0KCi8qIGluIGN0eXBlLmMsIGZvciBrd3NldCB1c2VycyAqLwpleHRlcm4gY29uc3QgY2hhciB0b2xvd2VyX3RyYW5zX3RibFsyNTZdOwoKLyogU2FuZSBjdHlwZSAtIG5vIGxvY2FsZSwgYW5kIHdvcmtzIHdpdGggc2lnbmVkIGNoYXJzICovCiN1bmRlZiBpc2FzY2lpCiN1bmRlZiBpc3NwYWNlCiN1bmRlZiBpc2RpZ2l0CiN1bmRlZiBpc2FscGhhCiN1bmRlZiBpc2FsbnVtCiN1bmRlZiBpc2xvd2VyCiN1bmRlZiBpc3VwcGVyCiN1bmRlZiB0b2xvd2VyCiN1bmRlZiB0b3VwcGVyCmV4dGVybiB1bnNpZ25lZCBjaGFyIHNhbmVfY3R5cGVbMjU2XTsKI2RlZmluZSBHSVRfU1BBQ0UgMHgwMQojZGVmaW5lIEdJVF9ESUdJVCAweDAyCiNkZWZpbmUgR0lUX0FMUEhBIDB4MDQKI2RlZmluZSBHSVRfR0xPQl9TUEVDSUFMIDB4MDgKI2RlZmluZSBHSVRfUkVHRVhfU1BFQ0lBTCAweDEwCiNkZWZpbmUgR0lUX1BBVEhTUEVDX01BR0lDIDB4MjAKI2RlZmluZSBzYW5lX2lzdGVzdCh4LG1hc2spICgoc2FuZV9jdHlwZVsodW5zaWduZWQgY2hhcikoeCldICYgKG1hc2spKSAhPSAwKQojZGVmaW5lIGlzYXNjaWkoeCkgKCgoeCkgJiB+MHg3ZikgPT0gMCkKI2RlZmluZSBpc3NwYWNlKHgpIHNhbmVfaXN0ZXN0KHgsR0lUX1NQQUNFKQojZGVmaW5lIGlzZGlnaXQoeCkgc2FuZV9pc3Rlc3QoeCxHSVRfRElHSVQpCiNkZWZpbmUgaXNhbHBoYSh4KSBzYW5lX2lzdGVzdCh4LEdJVF9BTFBIQSkKI2RlZmluZSBpc2FsbnVtKHgpIHNhbmVfaXN0ZXN0KHgsR0lUX0FMUEhBIHwgR0lUX0RJR0lUKQojZGVmaW5lIGlzbG93ZXIoeCkgc2FuZV9pc2Nhc2UoeCwgMSkKI2RlZmluZSBpc3VwcGVyKHgpIHNhbmVfaXNjYXNlKHgsIDApCiNkZWZpbmUgaXNfZ2xvYl9zcGVjaWFsKHgpIHNhbmVfaXN0ZXN0KHgsR0lUX0dMT0JfU1BFQ0lBTCkKI2RlZmluZSBpc19yZWdleF9zcGVjaWFsKHgpIHNhbmVfaXN0ZXN0KHgsR0lUX0dMT0JfU1BFQ0lBTCB8IEdJVF9SRUdFWF9TUEVDSUFMKQojZGVmaW5lIHRvbG93ZXIoeCkgc2FuZV9jYXNlKCh1bnNpZ25lZCBjaGFyKSh4KSwgMHgyMCkKI2RlZmluZSB0b3VwcGVyKHgpIHNhbmVfY2FzZSgodW5zaWduZWQgY2hhcikoeCksIDApCiNkZWZpbmUgaXNfcGF0aHNwZWNfbWFnaWMoeCkgc2FuZV9pc3Rlc3QoeCxHSVRfUEFUSFNQRUNfTUFHSUMpCgpzdGF0aWMgaW5saW5lIGludCBzYW5lX2Nhc2UoaW50IHgsIGludCBoaWdoKQp7CglpZiAoc2FuZV9pc3Rlc3QoeCwgR0lUX0FMUEhBKSkKCQl4ID0gKHggJiB+MHgyMCkgfCBoaWdoOwoJcmV0dXJuIHg7Cn0KCnN0YXRpYyBpbmxpbmUgaW50IHNhbmVfaXNjYXNlKGludCB4LCBpbnQgaXNfbG93ZXIpCnsKCWlmICghc2FuZV9pc3Rlc3QoeCwgR0lUX0FMUEhBKSkKCQlyZXR1cm4gMDsKCglpZiAoaXNfbG93ZXIpCgkJcmV0dXJuICh4ICYgMHgyMCkgIT0gMDsKCWVsc2UKCQlyZXR1cm4gKHggJiAweDIwKSA9PSAwOwp9CgpzdGF0aWMgaW5saW5lIGludCBzdHJ0b3VsX3VpKGNoYXIgY29uc3QgKnMsIGludCBiYXNlLCB1bnNpZ25lZCBpbnQgKnJlc3VsdCkKewoJdW5zaWduZWQgbG9uZyB1bDsKCWNoYXIgKnA7CgoJZXJybm8gPSAwOwoJdWwgPSBzdHJ0b3VsKHMsICZwLCBiYXNlKTsKCWlmIChlcnJubyB8fCAqcCB8fCBwID09IHMgfHwgKHVuc2lnbmVkIGludCkgdWwgIT0gdWwpCgkJcmV0dXJuIC0xOwoJKnJlc3VsdCA9IHVsOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbmxpbmUgaW50IHN0cnRvbF9pKGNoYXIgY29uc3QgKnMsIGludCBiYXNlLCBpbnQgKnJlc3VsdCkKewoJbG9uZyB1bDsKCWNoYXIgKnA7CgoJZXJybm8gPSAwOwoJdWwgPSBzdHJ0b2wocywgJnAsIGJhc2UpOwoJaWYgKGVycm5vIHx8ICpwIHx8IHAgPT0gcyB8fCAoaW50KSB1bCAhPSB1bCkKCQlyZXR1cm4gLTE7CgkqcmVzdWx0ID0gdWw7CglyZXR1cm4gMDsKfQoKI2lmZGVmIElOVEVSTkFMX1FTT1JUCnZvaWQgZ2l0X3Fzb3J0KHZvaWQgKmJhc2UsIHNpemVfdCBubWVtYiwgc2l6ZV90IHNpemUsCgkgICAgICAgaW50KCpjb21wYXIpKGNvbnN0IHZvaWQgKiwgY29uc3Qgdm9pZCAqKSk7CiNkZWZpbmUgcXNvcnQgZ2l0X3Fzb3J0CiNlbmRpZgoKI2lmbmRlZiBESVJfSEFTX0JTRF9HUk9VUF9TRU1BTlRJQ1MKIyBkZWZpbmUgRk9SQ0VfRElSX1NFVF9HSUQgU19JU0dJRAojZWxzZQojIGRlZmluZSBGT1JDRV9ESVJfU0VUX0dJRCAwCiNlbmRpZgoKI2lmZGVmIE5PX05TRUMKI3VuZGVmIFVTRV9OU0VDCiNkZWZpbmUgU1RfQ1RJTUVfTlNFQyhzdCkgMAojZGVmaW5lIFNUX01USU1FX05TRUMoc3QpIDAKI2Vsc2UKI2lmZGVmIFVTRV9TVF9USU1FU1BFQwojZGVmaW5lIFNUX0NUSU1FX05TRUMoc3QpICgodW5zaWduZWQgaW50KSgoc3QpLnN0X2N0aW1lc3BlYy50dl9uc2VjKSkKI2RlZmluZSBTVF9NVElNRV9OU0VDKHN0KSAoKHVuc2lnbmVkIGludCkoKHN0KS5zdF9tdGltZXNwZWMudHZfbnNlYykpCiNlbHNlCiNkZWZpbmUgU1RfQ1RJTUVfTlNFQyhzdCkgKCh1bnNpZ25lZCBpbnQpKChzdCkuc3RfY3RpbS50dl9uc2VjKSkKI2RlZmluZSBTVF9NVElNRV9OU0VDKHN0KSAoKHVuc2lnbmVkIGludCkoKHN0KS5zdF9tdGltLnR2X25zZWMpKQojZW5kaWYKI2VuZGlmCgojaWZkZWYgVU5SRUxJQUJMRV9GU1RBVAojZGVmaW5lIGZzdGF0X2lzX3JlbGlhYmxlKCkgMAojZWxzZQojZGVmaW5lIGZzdGF0X2lzX3JlbGlhYmxlKCkgMQojZW5kaWYKCiNpZm5kZWYgdmFfY29weQovKgogKiBTaW5jZSBhbiBvYnZpb3VzIGltcGxlbWVudGF0aW9uIG9mIHZhX2xpc3Qgd291bGQgYmUgdG8gbWFrZSBpdCBhCiAqIHBvaW50ZXIgaW50byB0aGUgc3RhY2sgZnJhbWUsIGEgc2ltcGxlIGFzc2lnbm1lbnQgd2lsbCB3b3JrIG9uCiAqIG1hbnkgc3lzdGVtcy4gIEJ1dCBsZXQncyB0cnkgdG8gYmUgbW9yZSBwb3J0YWJsZS4KICovCiNpZmRlZiBfX3ZhX2NvcHkKI2RlZmluZSB2YV9jb3B5KGRzdCwgc3JjKSBfX3ZhX2NvcHkoZHN0LCBzcmMpCiNlbHNlCiNkZWZpbmUgdmFfY29weShkc3QsIHNyYykgKChkc3QpID0gKHNyYykpCiNlbmRpZgojZW5kaWYKCi8qCiAqIFByZXNlcnZlcyBlcnJubywgcHJpbnRzIGEgbWVzc2FnZSwgYnV0IGdpdmVzIG5vIHdhcm5pbmcgZm9yIEVOT0VOVC4KICogQWx3YXlzIHJldHVybnMgdGhlIHJldHVybiB2YWx1ZSBvZiB1bmxpbmsoMikuCiAqLwppbnQgdW5saW5rX29yX3dhcm4oY29uc3QgY2hhciAqcGF0aCk7Ci8qCiAqIExpa2V3aXNlIGZvciBybWRpcigyKS4KICovCmludCBybWRpcl9vcl93YXJuKGNvbnN0IGNoYXIgKnBhdGgpOwovKgogKiBDYWxscyB0aGUgY29ycmVjdCBmdW5jdGlvbiBvdXQgb2Yge3VubGluayxybWRpcn1fb3Jfd2FybiBiYXNlZCBvbgogKiB0aGUgc3VwcGxpZWQgZmlsZSBtb2RlLgogKi8KaW50IHJlbW92ZV9vcl93YXJuKHVuc2lnbmVkIGludCBtb2RlLCBjb25zdCBjaGFyICpwYXRoKTsKCi8qIENhbGwgYWNjZXNzKDIpLCBidXQgd2FybiBmb3IgYW55IGVycm9yIGJlc2lkZXMgRU5PRU5ULiAqLwppbnQgYWNjZXNzX29yX3dhcm4oY29uc3QgY2hhciAqcGF0aCwgaW50IG1vZGUpOwoKLyogV2FybiBvbiBhbiBpbmFjY2Vzc2libGUgZmlsZSB0aGF0IG91Z2h0IHRvIGJlIGFjY2Vzc2libGUgKi8Kdm9pZCB3YXJuX29uX2luYWNjZXNzaWJsZShjb25zdCBjaGFyICpwYXRoKTsKCi8qIEdldCB0aGUgcGFzc3dkIGVudHJ5IGZvciB0aGUgVUlEIG9mIHRoZSBjdXJyZW50IHByb2Nlc3MuICovCnN0cnVjdCBwYXNzd2QgKnhnZXRwd3VpZF9zZWxmKHZvaWQpOwoKI2VuZGlmCg==",
    "text": "#ifndef GIT_COMPAT_UTIL_H\n#define GIT_COMPAT_UTIL_H\n\n#define _FILE_OFFSET_BITS 64\n\n#ifndef FLEX_ARRAY\n/*\n * See if our compiler is known to support flexible array members.\n */\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && (!defined(__SUNPRO_C) || (__SUNPRO_C > 0x580))\n# define FLEX_ARRAY /* empty */\n#elif defined(__GNUC__)\n# if (__GNUC__ >= 3)\n#  define FLEX_ARRAY /* empty */\n# else\n#  define FLEX_ARRAY 0 /* older GNU extension */\n# endif\n#endif\n\n/*\n * Otherwise, default to safer but a bit wasteful traditional style\n */\n#ifndef FLEX_ARRAY\n# define FLEX_ARRAY 1\n#endif\n#endif\n\n#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))\n#define bitsizeof(x)  (CHAR_BIT * sizeof(x))\n\n#define maximum_signed_value_of_type(a) \\\n    (INTMAX_MAX >> (bitsizeof(intmax_t) - bitsizeof(a)))\n\n#define maximum_unsigned_value_of_type(a) \\\n    (UINTMAX_MAX >> (bitsizeof(uintmax_t) - bitsizeof(a)))\n\n/*\n * Signed integer overflow is undefined in C, so here's a helper macro\n * to detect if the sum of two integers will overflow.\n *\n * Requires: a >= 0, typeof(a) equals typeof(b)\n */\n#define signed_add_overflows(a, b) \\\n    ((b) > maximum_signed_value_of_type(a) - (a))\n\n#define unsigned_add_overflows(a, b) \\\n    ((b) > maximum_unsigned_value_of_type(a) - (a))\n\n#ifdef __GNUC__\n#define TYPEOF(x) (__typeof__(x))\n#else\n#define TYPEOF(x)\n#endif\n\n#define MSB(x, bits) ((x) & TYPEOF(x)(~0ULL << (bitsizeof(x) - (bits))))\n#define HAS_MULTI_BITS(i)  ((i) & ((i) - 1))  /* checks if an integer has more than 1 bit set */\n\n#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))\n\n/* Approximation of the length of the decimal representation of this type. */\n#define decimal_length(x)\t((int)(sizeof(x) * 2.56 + 0.5) + 1)\n\n#if defined(__sun__)\n /*\n  * On Solaris, when _XOPEN_EXTENDED is set, its header file\n  * forces the programs to be XPG4v2, defeating any _XOPEN_SOURCE\n  * setting to say we are XPG5 or XPG6.  Also on Solaris,\n  * XPG6 programs must be compiled with a c99 compiler, while\n  * non XPG6 programs must be compiled with a pre-c99 compiler.\n  */\n# if __STDC_VERSION__ - 0 >= 199901L\n# define _XOPEN_SOURCE 600\n# else\n# define _XOPEN_SOURCE 500\n# endif\n#elif !defined(__APPLE__) && !defined(__FreeBSD__) && !defined(__USLC__) && \\\n      !defined(_M_UNIX) && !defined(__sgi) && !defined(__DragonFly__)\n#define _XOPEN_SOURCE 600 /* glibc2 and AIX 5.3L need 500, OpenBSD needs 600 for S_ISLNK() */\n#define _XOPEN_SOURCE_EXTENDED 1 /* AIX 5.3L needs this */\n#endif\n#define _ALL_SOURCE 1\n#define _GNU_SOURCE 1\n#define _BSD_SOURCE 1\n#define _NETBSD_SOURCE 1\n#define _SGI_SOURCE 1\n\n#ifdef WIN32 /* Both MinGW and MSVC */\n#define WIN32_LEAN_AND_MEAN  /* stops windows.h including winsock.h */\n#include <winsock2.h>\n#include <windows.h>\n#endif\n\n#include <unistd.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <limits.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <time.h>\n#include <signal.h>\n#include <fnmatch.h>\n#include <assert.h>\n#include <regex.h>\n#include <utime.h>\n#include <syslog.h>\n#ifndef NO_SYS_POLL_H\n#include <sys/poll.h>\n#else\n#include <poll.h>\n#endif\n#if defined(__MINGW32__)\n/* pull in Windows compatibility stuff */\n#include \"compat/mingw.h\"\n#elif defined(_MSC_VER)\n#include \"compat/msvc.h\"\n#else\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#ifndef NO_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <pwd.h>\n#include <sys/un.h>\n#ifndef NO_INTTYPES_H\n#include <inttypes.h>\n#else\n#include <stdint.h>\n#endif\n#if defined(__CYGWIN__)\n#undef _XOPEN_SOURCE\n#include <grp.h>\n#define _XOPEN_SOURCE 600\n#include \"compat/cygwin.h\"\n#else\n#undef _ALL_SOURCE /* AIX 5.3L defines a struct list with _ALL_SOURCE. */\n#include <grp.h>\n#define _ALL_SOURCE 1\n#endif\n#endif\n\n/* used on Mac OS X */\n#ifdef PRECOMPOSE_UNICODE\n#include \"compat/precompose_utf8.h\"\n#else\n#define precompose_str(in,i_nfd2nfc)\n#define precompose_argv(c,v)\n#define probe_utf8_pathname_composition(a,b)\n#endif\n\n#ifndef NO_LIBGEN_H\n#include <libgen.h>\n#else\n#define basename gitbasename\nextern char *gitbasename(char *);\n#endif\n\n#ifndef NO_ICONV\n#include <iconv.h>\n#endif\n\n#ifndef NO_OPENSSL\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#endif\n\n/* On most systems <limits.h> would have given us this, but\n * not on some systems (e.g. GNU/Hurd).\n */\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\n#ifndef PRIuMAX\n#define PRIuMAX \"llu\"\n#endif\n\n#ifndef PRIu32\n#define PRIu32 \"u\"\n#endif\n\n#ifndef PRIx32\n#define PRIx32 \"x\"\n#endif\n\n#ifndef PRIo32\n#define PRIo32 \"o\"\n#endif\n\n#ifndef PATH_SEP\n#define PATH_SEP ':'\n#endif\n\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n#ifndef _PATH_DEFPATH\n#define _PATH_DEFPATH \"/usr/local/bin:/usr/bin:/bin\"\n#endif\n\n#ifndef STRIP_EXTENSION\n#define STRIP_EXTENSION \"\"\n#endif\n\n#ifndef has_dos_drive_prefix\n#define has_dos_drive_prefix(path) 0\n#endif\n\n#ifndef is_dir_sep\n#define is_dir_sep(c) ((c) == '/')\n#endif\n\n#ifndef find_last_dir_sep\n#define find_last_dir_sep(path) strrchr(path, '/')\n#endif\n\n#if defined(__HP_cc) && (__HP_cc >= 61000)\n#define NORETURN __attribute__((noreturn))\n#define NORETURN_PTR\n#elif defined(__GNUC__) && !defined(NO_NORETURN)\n#define NORETURN __attribute__((__noreturn__))\n#define NORETURN_PTR __attribute__((__noreturn__))\n#elif defined(_MSC_VER)\n#define NORETURN __declspec(noreturn)\n#define NORETURN_PTR\n#else\n#define NORETURN\n#define NORETURN_PTR\n#ifndef __attribute__\n#define __attribute__(x)\n#endif\n#endif\n\n#include \"compat/bswap.h\"\n\n/* General helper functions */\nextern void vreportf(const char *prefix, const char *err, va_list params);\nextern void vwritef(int fd, const char *prefix, const char *err, va_list params);\nextern NORETURN void usage(const char *err);\nextern NORETURN void usagef(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern NORETURN void die(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern NORETURN void die_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern int error(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern void warning(const char *err, ...) __attribute__((format (printf, 1, 2)));\n\nextern void set_die_routine(NORETURN_PTR void (*routine)(const char *err, va_list params));\nextern void set_error_routine(void (*routine)(const char *err, va_list params));\n\nextern int prefixcmp(const char *str, const char *prefix);\nextern int suffixcmp(const char *str, const char *suffix);\n\nstatic inline const char *skip_prefix(const char *str, const char *prefix)\n{\n\tsize_t len = strlen(prefix);\n\treturn strncmp(str, prefix, len) ? NULL : str + len;\n}\n\n#if defined(NO_MMAP) || defined(USE_WIN32_MMAP)\n\n#ifndef PROT_READ\n#define PROT_READ 1\n#define PROT_WRITE 2\n#define MAP_PRIVATE 1\n#endif\n\n#define mmap git_mmap\n#define munmap git_munmap\nextern void *git_mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nextern int git_munmap(void *start, size_t length);\n\n#else /* NO_MMAP || USE_WIN32_MMAP */\n\n#include <sys/mman.h>\n\n#endif /* NO_MMAP || USE_WIN32_MMAP */\n\n#ifdef NO_MMAP\n\n/* This value must be multiple of (pagesize * 2) */\n#define DEFAULT_PACKED_GIT_WINDOW_SIZE (1 * 1024 * 1024)\n\n#else /* NO_MMAP */\n\n/* This value must be multiple of (pagesize * 2) */\n#define DEFAULT_PACKED_GIT_WINDOW_SIZE \\\n\t(sizeof(void*) >= 8 \\\n\t\t?  1 * 1024 * 1024 * 1024 \\\n\t\t: 32 * 1024 * 1024)\n\n#endif /* NO_MMAP */\n\n#ifndef MAP_FAILED\n#define MAP_FAILED ((void *)-1)\n#endif\n\n#ifdef NO_ST_BLOCKS_IN_STRUCT_STAT\n#define on_disk_bytes(st) ((st).st_size)\n#else\n#define on_disk_bytes(st) ((st).st_blocks * 512)\n#endif\n\n#define DEFAULT_PACKED_GIT_LIMIT \\\n\t((1024L * 1024L) * (sizeof(void*) >= 8 ? 8192 : 256))\n\n#ifdef NO_PREAD\n#define pread git_pread\nextern ssize_t git_pread(int fd, void *buf, size_t count, off_t offset);\n#endif\n/*\n * Forward decl that will remind us if its twin in cache.h changes.\n * This function is used in compat/pread.c.  But we can't include\n * cache.h there.\n */\nextern ssize_t read_in_full(int fd, void *buf, size_t count);\n\n#ifdef NO_SETENV\n#define setenv gitsetenv\nextern int gitsetenv(const char *, const char *, int);\n#endif\n\n#ifdef NO_MKDTEMP\n#define mkdtemp gitmkdtemp\nextern char *gitmkdtemp(char *);\n#endif\n\n#ifdef NO_MKSTEMPS\n#define mkstemps gitmkstemps\nextern int gitmkstemps(char *, int);\n#endif\n\n#ifdef NO_UNSETENV\n#define unsetenv gitunsetenv\nextern void gitunsetenv(const char *);\n#endif\n\n#ifdef NO_STRCASESTR\n#define strcasestr gitstrcasestr\nextern char *gitstrcasestr(const char *haystack, const char *needle);\n#endif\n\n#ifdef NO_STRLCPY\n#define strlcpy gitstrlcpy\nextern size_t gitstrlcpy(char *, const char *, size_t);\n#endif\n\n#ifdef NO_STRTOUMAX\n#define strtoumax gitstrtoumax\nextern uintmax_t gitstrtoumax(const char *, char **, int);\n#define strtoimax gitstrtoimax\nextern intmax_t gitstrtoimax(const char *, char **, int);\n#endif\n\n#ifdef NO_STRTOK_R\n#define strtok_r gitstrtok_r\nextern char *gitstrtok_r(char *s, const char *delim, char **save_ptr);\n#endif\n\n#ifdef NO_HSTRERROR\n#define hstrerror githstrerror\nextern const char *githstrerror(int herror);\n#endif\n\n#ifdef NO_MEMMEM\n#define memmem gitmemmem\nvoid *gitmemmem(const void *haystack, size_t haystacklen,\n                const void *needle, size_t needlelen);\n#endif\n\n#ifdef FREAD_READS_DIRECTORIES\n#ifdef fopen\n#undef fopen\n#endif\n#define fopen(a,b) git_fopen(a,b)\nextern FILE *git_fopen(const char*, const char*);\n#endif\n\n#ifdef SNPRINTF_RETURNS_BOGUS\n#define snprintf git_snprintf\nextern int git_snprintf(char *str, size_t maxsize,\n\t\t\tconst char *format, ...);\n#define vsnprintf git_vsnprintf\nextern int git_vsnprintf(char *str, size_t maxsize,\n\t\t\t const char *format, va_list ap);\n#endif\n\n#ifdef __GLIBC_PREREQ\n#if __GLIBC_PREREQ(2, 1)\n#define HAVE_STRCHRNUL\n#define HAVE_MEMPCPY\n#endif\n#endif\n\n#ifndef HAVE_STRCHRNUL\n#define strchrnul gitstrchrnul\nstatic inline char *gitstrchrnul(const char *s, int c)\n{\n\twhile (*s && *s != c)\n\t\ts++;\n\treturn (char *)s;\n}\n#endif\n\n#ifndef HAVE_MEMPCPY\n#define mempcpy gitmempcpy\nstatic inline void *gitmempcpy(void *dest, const void *src, size_t n)\n{\n\treturn (char *)memcpy(dest, src, n) + n;\n}\n#endif\n\n#ifdef NO_INET_PTON\nint inet_pton(int af, const char *src, void *dst);\n#endif\n\n#ifdef NO_INET_NTOP\nconst char *inet_ntop(int af, const void *src, char *dst, size_t size);\n#endif\n\nextern void release_pack_memory(size_t, int);\n\ntypedef void (*try_to_free_t)(size_t);\nextern try_to_free_t set_try_to_free_routine(try_to_free_t);\n\nextern char *xstrdup(const char *str);\nextern void *xmalloc(size_t size);\nextern void *xmallocz(size_t size);\nextern void *xmemdupz(const void *data, size_t len);\nextern char *xstrndup(const char *str, size_t len);\nextern void *xrealloc(void *ptr, size_t size);\nextern void *xcalloc(size_t nmemb, size_t size);\nextern void *xmmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nextern ssize_t xread(int fd, void *buf, size_t len);\nextern ssize_t xwrite(int fd, const void *buf, size_t len);\nextern int xdup(int fd);\nextern FILE *xfdopen(int fd, const char *mode);\nextern int xmkstemp(char *template);\nextern int xmkstemp_mode(char *template, int mode);\nextern int odb_mkstemp(char *template, size_t limit, const char *pattern);\nextern int odb_pack_keep(char *name, size_t namesz, unsigned char *sha1);\n\nstatic inline size_t xsize_t(off_t len)\n{\n\tif (len > (size_t) len)\n\t\tdie(\"Cannot handle files this big\");\n\treturn (size_t)len;\n}\n\nstatic inline int has_extension(const char *filename, const char *ext)\n{\n\tsize_t len = strlen(filename);\n\tsize_t extlen = strlen(ext);\n\treturn len > extlen && !memcmp(filename + len - extlen, ext, extlen);\n}\n\n/* in ctype.c, for kwset users */\nextern const char tolower_trans_tbl[256];\n\n/* Sane ctype - no locale, and works with signed chars */\n#undef isascii\n#undef isspace\n#undef isdigit\n#undef isalpha\n#undef isalnum\n#undef islower\n#undef isupper\n#undef tolower\n#undef toupper\nextern unsigned char sane_ctype[256];\n#define GIT_SPACE 0x01\n#define GIT_DIGIT 0x02\n#define GIT_ALPHA 0x04\n#define GIT_GLOB_SPECIAL 0x08\n#define GIT_REGEX_SPECIAL 0x10\n#define GIT_PATHSPEC_MAGIC 0x20\n#define sane_istest(x,mask) ((sane_ctype[(unsigned char)(x)] & (mask)) != 0)\n#define isascii(x) (((x) & ~0x7f) == 0)\n#define isspace(x) sane_istest(x,GIT_SPACE)\n#define isdigit(x) sane_istest(x,GIT_DIGIT)\n#define isalpha(x) sane_istest(x,GIT_ALPHA)\n#define isalnum(x) sane_istest(x,GIT_ALPHA | GIT_DIGIT)\n#define islower(x) sane_iscase(x, 1)\n#define isupper(x) sane_iscase(x, 0)\n#define is_glob_special(x) sane_istest(x,GIT_GLOB_SPECIAL)\n#define is_regex_special(x) sane_istest(x,GIT_GLOB_SPECIAL | GIT_REGEX_SPECIAL)\n#define tolower(x) sane_case((unsigned char)(x), 0x20)\n#define toupper(x) sane_case((unsigned char)(x), 0)\n#define is_pathspec_magic(x) sane_istest(x,GIT_PATHSPEC_MAGIC)\n\nstatic inline int sane_case(int x, int high)\n{\n\tif (sane_istest(x, GIT_ALPHA))\n\t\tx = (x & ~0x20) | high;\n\treturn x;\n}\n\nstatic inline int sane_iscase(int x, int is_lower)\n{\n\tif (!sane_istest(x, GIT_ALPHA))\n\t\treturn 0;\n\n\tif (is_lower)\n\t\treturn (x & 0x20) != 0;\n\telse\n\t\treturn (x & 0x20) == 0;\n}\n\nstatic inline int strtoul_ui(char const *s, int base, unsigned int *result)\n{\n\tunsigned long ul;\n\tchar *p;\n\n\terrno = 0;\n\tul = strtoul(s, &p, base);\n\tif (errno || *p || p == s || (unsigned int) ul != ul)\n\t\treturn -1;\n\t*result = ul;\n\treturn 0;\n}\n\nstatic inline int strtol_i(char const *s, int base, int *result)\n{\n\tlong ul;\n\tchar *p;\n\n\terrno = 0;\n\tul = strtol(s, &p, base);\n\tif (errno || *p || p == s || (int) ul != ul)\n\t\treturn -1;\n\t*result = ul;\n\treturn 0;\n}\n\n#ifdef INTERNAL_QSORT\nvoid git_qsort(void *base, size_t nmemb, size_t size,\n\t       int(*compar)(const void *, const void *));\n#define qsort git_qsort\n#endif\n\n#ifndef DIR_HAS_BSD_GROUP_SEMANTICS\n# define FORCE_DIR_SET_GID S_ISGID\n#else\n# define FORCE_DIR_SET_GID 0\n#endif\n\n#ifdef NO_NSEC\n#undef USE_NSEC\n#define ST_CTIME_NSEC(st) 0\n#define ST_MTIME_NSEC(st) 0\n#else\n#ifdef USE_ST_TIMESPEC\n#define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctimespec.tv_nsec))\n#define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtimespec.tv_nsec))\n#else\n#define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctim.tv_nsec))\n#define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtim.tv_nsec))\n#endif\n#endif\n\n#ifdef UNRELIABLE_FSTAT\n#define fstat_is_reliable() 0\n#else\n#define fstat_is_reliable() 1\n#endif\n\n#ifndef va_copy\n/*\n * Since an obvious implementation of va_list would be to make it a\n * pointer into the stack frame, a simple assignment will work on\n * many systems.  But let's try to be more portable.\n */\n#ifdef __va_copy\n#define va_copy(dst, src) __va_copy(dst, src)\n#else\n#define va_copy(dst, src) ((dst) = (src))\n#endif\n#endif\n\n/*\n * Preserves errno, prints a message, but gives no warning for ENOENT.\n * Always returns the return value of unlink(2).\n */\nint unlink_or_warn(const char *path);\n/*\n * Likewise for rmdir(2).\n */\nint rmdir_or_warn(const char *path);\n/*\n * Calls the correct function out of {unlink,rmdir}_or_warn based on\n * the supplied file mode.\n */\nint remove_or_warn(unsigned int mode, const char *path);\n\n/* Call access(2), but warn for any error besides ENOENT. */\nint access_or_warn(const char *path, int mode);\n\n/* Warn on an inaccessible file that ought to be accessible */\nvoid warn_on_inaccessible(const char *path);\n\n/* Get the passwd entry for the UID of the current process. */\nstruct passwd *xgetpwuid_self(void);\n\n#endif\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "000042d79352b4a7bb789d60e5324af92f29871a",
  "sha1_ok": false,
  "size": 15568
}
