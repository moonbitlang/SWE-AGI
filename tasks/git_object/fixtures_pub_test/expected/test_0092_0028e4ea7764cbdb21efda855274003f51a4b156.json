{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJyZXBvc2l0b3J5LmgiCiNpbmNsdWRlICJ0ZW1wZmlsZS5oIgojaW5jbHVkZSAibG9ja2ZpbGUuaCIKI2luY2x1ZGUgIm9iamVjdC1zdG9yZS5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgInBrdC1saW5lLmgiCiNpbmNsdWRlICJyZW1vdGUuaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgInNoYTEtYXJyYXkuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgInJldmlzaW9uLmgiCiNpbmNsdWRlICJjb21taXQtc2xhYi5oIgojaW5jbHVkZSAicmV2aXNpb24uaCIKI2luY2x1ZGUgImxpc3Qtb2JqZWN0cy5oIgoKc3RhdGljIGludCBpc19zaGFsbG93ID0gLTE7CnN0YXRpYyBzdHJ1Y3Qgc3RhdF92YWxpZGl0eSBzaGFsbG93X3N0YXQ7CnN0YXRpYyBjaGFyICphbHRlcm5hdGVfc2hhbGxvd19maWxlOwoKdm9pZCBzZXRfYWx0ZXJuYXRlX3NoYWxsb3dfZmlsZV90aGVfcmVwb3NpdG9yeShjb25zdCBjaGFyICpwYXRoLCBpbnQgb3ZlcnJpZGUpCnsKCWlmIChpc19zaGFsbG93ICE9IC0xKQoJCWRpZSgiQlVHOiBpc19yZXBvc2l0b3J5X3NoYWxsb3cgbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSBzZXRfYWx0ZXJuYXRlX3NoYWxsb3dfZmlsZSIpOwoJaWYgKGFsdGVybmF0ZV9zaGFsbG93X2ZpbGUgJiYgIW92ZXJyaWRlKQoJCXJldHVybjsKCWZyZWUoYWx0ZXJuYXRlX3NoYWxsb3dfZmlsZSk7CglhbHRlcm5hdGVfc2hhbGxvd19maWxlID0geHN0cmR1cF9vcl9udWxsKHBhdGgpOwp9CgppbnQgcmVnaXN0ZXJfc2hhbGxvd190aGVfcmVwb3NpdG9yeShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXN0cnVjdCBjb21taXRfZ3JhZnQgKmdyYWZ0ID0KCQl4bWFsbG9jKHNpemVvZihzdHJ1Y3QgY29tbWl0X2dyYWZ0KSk7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBsb29rdXBfY29tbWl0KG9pZCk7CgoJb2lkY3B5KCZncmFmdC0+b2lkLCBvaWQpOwoJZ3JhZnQtPm5yX3BhcmVudCA9IC0xOwoJaWYgKGNvbW1pdCAmJiBjb21taXQtPm9iamVjdC5wYXJzZWQpCgkJY29tbWl0LT5wYXJlbnRzID0gTlVMTDsKCXJldHVybiByZWdpc3Rlcl9jb21taXRfZ3JhZnQodGhlX3JlcG9zaXRvcnksIGdyYWZ0LCAwKTsKfQoKaW50IGlzX3JlcG9zaXRvcnlfc2hhbGxvdyh2b2lkKQp7CglGSUxFICpmcDsKCWNoYXIgYnVmWzEwMjRdOwoJY29uc3QgY2hhciAqcGF0aCA9IGFsdGVybmF0ZV9zaGFsbG93X2ZpbGU7CgoJaWYgKGlzX3NoYWxsb3cgPj0gMCkKCQlyZXR1cm4gaXNfc2hhbGxvdzsKCglpZiAoIXBhdGgpCgkJcGF0aCA9IGdpdF9wYXRoX3NoYWxsb3coKTsKCS8qCgkgKiBmZXRjaC1wYWNrIHNldHMgJy0tc2hhbGxvdy1maWxlICIiJyBhcyBhbiBpbmRpY2F0b3IgdGhhdCBubwoJICogc2hhbGxvdyBmaWxlIHNob3VsZCBiZSB1c2VkLiBXZSBjb3VsZCBqdXN0IG9wZW4gaXQgYW5kIGl0CgkgKiB3aWxsIGxpa2VseSBmYWlsLiBCdXQgbGV0J3MgZG8gYW4gZXhwbGljaXQgY2hlY2sgaW5zdGVhZC4KCSAqLwoJaWYgKCEqcGF0aCB8fCAoZnAgPSBmb3BlbihwYXRoLCAiciIpKSA9PSBOVUxMKSB7CgkJc3RhdF92YWxpZGl0eV9jbGVhcigmc2hhbGxvd19zdGF0KTsKCQlpc19zaGFsbG93ID0gMDsKCQlyZXR1cm4gaXNfc2hhbGxvdzsKCX0KCXN0YXRfdmFsaWRpdHlfdXBkYXRlKCZzaGFsbG93X3N0YXQsIGZpbGVubyhmcCkpOwoJaXNfc2hhbGxvdyA9IDE7CgoJd2hpbGUgKGZnZXRzKGJ1Ziwgc2l6ZW9mKGJ1ZiksIGZwKSkgewoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCWlmIChnZXRfb2lkX2hleChidWYsICZvaWQpKQoJCQlkaWUoImJhZCBzaGFsbG93IGxpbmU6ICVzIiwgYnVmKTsKCQlyZWdpc3Rlcl9zaGFsbG93KHRoZV9yZXBvc2l0b3J5LCAmb2lkKTsKCX0KCWZjbG9zZShmcCk7CglyZXR1cm4gaXNfc2hhbGxvdzsKfQoKc3RydWN0IGNvbW1pdF9saXN0ICpnZXRfc2hhbGxvd19jb21taXRzKHN0cnVjdCBvYmplY3RfYXJyYXkgKmhlYWRzLCBpbnQgZGVwdGgsCgkJaW50IHNoYWxsb3dfZmxhZywgaW50IG5vdF9zaGFsbG93X2ZsYWcpCnsKCWludCBpID0gMCwgY3VyX2RlcHRoID0gMDsKCXN0cnVjdCBjb21taXRfbGlzdCAqcmVzdWx0ID0gTlVMTDsKCXN0cnVjdCBvYmplY3RfYXJyYXkgc3RhY2sgPSBPQkpFQ1RfQVJSQVlfSU5JVDsKCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IE5VTEw7CglzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpncmFmdDsKCgl3aGlsZSAoY29tbWl0IHx8IGkgPCBoZWFkcy0+bnIgfHwgc3RhY2subnIpIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnA7CgkJaWYgKCFjb21taXQpIHsKCQkJaWYgKGkgPCBoZWFkcy0+bnIpIHsKCQkJCWNvbW1pdCA9IChzdHJ1Y3QgY29tbWl0ICopCgkJCQkJZGVyZWZfdGFnKGhlYWRzLT5vYmplY3RzW2krK10uaXRlbSwgTlVMTCwgMCk7CgkJCQlpZiAoIWNvbW1pdCB8fCBjb21taXQtPm9iamVjdC50eXBlICE9IE9CSl9DT01NSVQpIHsKCQkJCQljb21taXQgPSBOVUxMOwoJCQkJCWNvbnRpbnVlOwoJCQkJfQoJCQkJaWYgKCFjb21taXQtPnV0aWwpCgkJCQkJY29tbWl0LT51dGlsID0geG1hbGxvYyhzaXplb2YoaW50KSk7CgkJCQkqKGludCAqKWNvbW1pdC0+dXRpbCA9IDA7CgkJCQljdXJfZGVwdGggPSAwOwoJCQl9IGVsc2UgewoJCQkJY29tbWl0ID0gKHN0cnVjdCBjb21taXQgKikKCQkJCQlvYmplY3RfYXJyYXlfcG9wKCZzdGFjayk7CgkJCQljdXJfZGVwdGggPSAqKGludCAqKWNvbW1pdC0+dXRpbDsKCQkJfQoJCX0KCQlwYXJzZV9jb21taXRfb3JfZGllKGNvbW1pdCk7CgkJY3VyX2RlcHRoKys7CgkJaWYgKChkZXB0aCAhPSBJTkZJTklURV9ERVBUSCAmJiBjdXJfZGVwdGggPj0gZGVwdGgpIHx8CgkJICAgIChpc19yZXBvc2l0b3J5X3NoYWxsb3coKSAmJiAhY29tbWl0LT5wYXJlbnRzICYmCgkJICAgICAoZ3JhZnQgPSBsb29rdXBfY29tbWl0X2dyYWZ0KHRoZV9yZXBvc2l0b3J5LCAmY29tbWl0LT5vYmplY3Qub2lkKSkgIT0gTlVMTCAmJgoJCSAgICAgZ3JhZnQtPm5yX3BhcmVudCA8IDApKSB7CgkJCWNvbW1pdF9saXN0X2luc2VydChjb21taXQsICZyZXN1bHQpOwoJCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBzaGFsbG93X2ZsYWc7CgkJCWNvbW1pdCA9IE5VTEw7CgkJCWNvbnRpbnVlOwoJCX0KCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBub3Rfc2hhbGxvd19mbGFnOwoJCWZvciAocCA9IGNvbW1pdC0+cGFyZW50cywgY29tbWl0ID0gTlVMTDsgcDsgcCA9IHAtPm5leHQpIHsKCQkJaWYgKCFwLT5pdGVtLT51dGlsKSB7CgkJCQlpbnQgKnBvaW50ZXIgPSB4bWFsbG9jKHNpemVvZihpbnQpKTsKCQkJCXAtPml0ZW0tPnV0aWwgPSBwb2ludGVyOwoJCQkJKnBvaW50ZXIgPSAgY3VyX2RlcHRoOwoJCQl9IGVsc2UgewoJCQkJaW50ICpwb2ludGVyID0gcC0+aXRlbS0+dXRpbDsKCQkJCWlmIChjdXJfZGVwdGggPj0gKnBvaW50ZXIpCgkJCQkJY29udGludWU7CgkJCQkqcG9pbnRlciA9IGN1cl9kZXB0aDsKCQkJfQoJCQlpZiAocC0+bmV4dCkKCQkJCWFkZF9vYmplY3RfYXJyYXkoJnAtPml0ZW0tPm9iamVjdCwKCQkJCQkJTlVMTCwgJnN0YWNrKTsKCQkJZWxzZSB7CgkJCQljb21taXQgPSBwLT5pdGVtOwoJCQkJY3VyX2RlcHRoID0gKihpbnQgKiljb21taXQtPnV0aWw7CgkJCX0KCQl9Cgl9CgoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIHZvaWQgc2hvd19jb21taXQoc3RydWN0IGNvbW1pdCAqY29tbWl0LCB2b2lkICpkYXRhKQp7Cgljb21taXRfbGlzdF9pbnNlcnQoY29tbWl0LCBkYXRhKTsKfQoKLyoKICogR2l2ZW4gcmV2LWxpc3QgYXJndW1lbnRzLCBydW4gcmV2LWxpc3QuIEFsbCByZWFjaGFibGUgY29tbWl0cwogKiBleGNlcHQgYm9yZGVyIG9uZXMgYXJlIG1hcmtlZCB3aXRoIG5vdF9zaGFsbG93X2ZsYWcuIEJvcmRlciBjb21taXRzCiAqIGFyZSBtYXJrZWQgd2l0aCBzaGFsbG93X2ZsYWcuIFRoZSBsaXN0IG9mIGJvcmRlci9zaGFsbG93IGNvbW1pdHMKICogYXJlIGFsc28gcmV0dXJuZWQuCiAqLwpzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9zaGFsbG93X2NvbW1pdHNfYnlfcmV2X2xpc3QoaW50IGFjLCBjb25zdCBjaGFyICoqYXYsCgkJCQkJCSAgICBpbnQgc2hhbGxvd19mbGFnLAoJCQkJCQkgICAgaW50IG5vdF9zaGFsbG93X2ZsYWcpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqcmVzdWx0ID0gTlVMTCwgKnA7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKm5vdF9zaGFsbG93X2xpc3QgPSBOVUxMOwoJc3RydWN0IHJldl9pbmZvIHJldnM7CglpbnQgYm90aF9mbGFncyA9IHNoYWxsb3dfZmxhZyB8IG5vdF9zaGFsbG93X2ZsYWc7CgoJLyoKCSAqIFNIQUxMT1cgKGV4Y2x1ZGVkKSBhbmQgTk9UX1NIQUxMT1cgKGluY2x1ZGVkKSBzaG91bGQgbm90IGJlCgkgKiBzZXQgYXQgdGhpcyBwb2ludC4gQnV0IGJldHRlciBiZSBzYWZlIHRoYW4gc29ycnkuCgkgKi8KCWNsZWFyX29iamVjdF9mbGFncyhib3RoX2ZsYWdzKTsKCglpc19yZXBvc2l0b3J5X3NoYWxsb3coKTsgLyogbWFrZSBzdXJlIHNoYWxsb3dzIGFyZSByZWFkICovCgoJaW5pdF9yZXZpc2lvbnMoJnJldnMsIE5VTEwpOwoJc2F2ZV9jb21taXRfYnVmZmVyID0gMDsKCXNldHVwX3JldmlzaW9ucyhhYywgYXYsICZyZXZzLCBOVUxMKTsKCglpZiAocHJlcGFyZV9yZXZpc2lvbl93YWxrKCZyZXZzKSkKCQlkaWUoInJldmlzaW9uIHdhbGsgc2V0dXAgZmFpbGVkIik7Cgl0cmF2ZXJzZV9jb21taXRfbGlzdCgmcmV2cywgc2hvd19jb21taXQsIE5VTEwsICZub3Rfc2hhbGxvd19saXN0KTsKCgkvKiBNYXJrIGFsbCByZWFjaGFibGUgY29tbWl0cyBhcyBOT1RfU0hBTExPVyAqLwoJZm9yIChwID0gbm90X3NoYWxsb3dfbGlzdDsgcDsgcCA9IHAtPm5leHQpCgkJcC0+aXRlbS0+b2JqZWN0LmZsYWdzIHw9IG5vdF9zaGFsbG93X2ZsYWc7CgoJLyoKCSAqIG1hcmsgYm9yZGVyIGNvbW1pdHMgU0hBTExPVyArIE5PVF9TSEFMTE9XLgoJICogV2UgY2Fubm90IGNsZWFyIE5PVF9TSEFMTE9XIHJpZ2h0IG5vdy4gSW1hZ2luZSBib3JkZXIKCSAqIGNvbW1pdCBBIGlzIHByb2Nlc3NlZCBmaXJzdCwgdGhlbiBjb21taXQgQiwgd2hvc2UgcGFyZW50IGlzCgkgKiBBLCBsYXRlci4gSWYgTk9UX1NIQUxMT1cgb24gQSBpcyBjbGVhcmVkIGF0IHN0ZXAgMSwgQgoJICogaXRzZWxmIGlzIGNvbnNpZGVyZWQgYm9yZGVyIGF0IHN0ZXAgMiwgd2hpY2ggaXMgaW5jb3JyZWN0LgoJICovCglmb3IgKHAgPSBub3Rfc2hhbGxvd19saXN0OyBwOyBwID0gcC0+bmV4dCkgewoJCXN0cnVjdCBjb21taXQgKmMgPSBwLT5pdGVtOwoJCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50OwoKCQlpZiAocGFyc2VfY29tbWl0KGMpKQoJCQlkaWUoInVuYWJsZSB0byBwYXJzZSBjb21taXQgJXMiLAoJCQkgICAgb2lkX3RvX2hleCgmYy0+b2JqZWN0Lm9pZCkpOwoKCQlmb3IgKHBhcmVudCA9IGMtPnBhcmVudHM7IHBhcmVudDsgcGFyZW50ID0gcGFyZW50LT5uZXh0KQoJCQlpZiAoIShwYXJlbnQtPml0ZW0tPm9iamVjdC5mbGFncyAmIG5vdF9zaGFsbG93X2ZsYWcpKSB7CgkJCQljLT5vYmplY3QuZmxhZ3MgfD0gc2hhbGxvd19mbGFnOwoJCQkJY29tbWl0X2xpc3RfaW5zZXJ0KGMsICZyZXN1bHQpOwoJCQkJYnJlYWs7CgkJCX0KCX0KCWZyZWVfY29tbWl0X2xpc3Qobm90X3NoYWxsb3dfbGlzdCk7CgoJLyoKCSAqIE5vdyB3ZSBjYW4gY2xlYW4gdXAgTk9UX1NIQUxMT1cgb24gYm9yZGVyIGNvbW1pdHMuIEhhdmluZwoJICogYm90aCBmbGFncyBzZXQgY2FuIGNvbmZ1c2UgdGhlIGNhbGxlci4KCSAqLwoJZm9yIChwID0gcmVzdWx0OyBwOyBwID0gcC0+bmV4dCkgewoJCXN0cnVjdCBvYmplY3QgKm8gPSAmcC0+aXRlbS0+b2JqZWN0OwoJCWlmICgoby0+ZmxhZ3MgJiBib3RoX2ZsYWdzKSA9PSBib3RoX2ZsYWdzKQoJCQlvLT5mbGFncyAmPSB+bm90X3NoYWxsb3dfZmxhZzsKCX0KCXJldHVybiByZXN1bHQ7Cn0KCiNkZWZpbmUgY2hlY2tfc2hhbGxvd19maWxlX2Zvcl91cGRhdGUocikgY2hlY2tfc2hhbGxvd19maWxlX2Zvcl91cGRhdGVfIyNyKCkKc3RhdGljIHZvaWQgY2hlY2tfc2hhbGxvd19maWxlX2Zvcl91cGRhdGVfdGhlX3JlcG9zaXRvcnkodm9pZCkKewoJaWYgKGlzX3NoYWxsb3cgPT0gLTEpCgkJZGllKCJCVUc6IHNoYWxsb3cgbXVzdCBiZSBpbml0aWFsaXplZCBieSBub3ciKTsKCglpZiAoIXN0YXRfdmFsaWRpdHlfY2hlY2soJnNoYWxsb3dfc3RhdCwgZ2l0X3BhdGhfc2hhbGxvdygpKSkKCQlkaWUoInNoYWxsb3cgZmlsZSBoYXMgY2hhbmdlZCBzaW5jZSB3ZSByZWFkIGl0Iik7Cn0KCiNkZWZpbmUgU0VFTl9PTkxZIDEKI2RlZmluZSBWRVJCT1NFICAgMgoKc3RydWN0IHdyaXRlX3NoYWxsb3dfZGF0YSB7CglzdHJ1Y3Qgc3RyYnVmICpvdXQ7CglpbnQgdXNlX3BhY2tfcHJvdG9jb2w7CglpbnQgY291bnQ7Cgl1bnNpZ25lZCBmbGFnczsKfTsKCnN0YXRpYyBpbnQgd3JpdGVfb25lX3NoYWxsb3coY29uc3Qgc3RydWN0IGNvbW1pdF9ncmFmdCAqZ3JhZnQsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCB3cml0ZV9zaGFsbG93X2RhdGEgKmRhdGEgPSBjYl9kYXRhOwoJY29uc3QgY2hhciAqaGV4ID0gb2lkX3RvX2hleCgmZ3JhZnQtPm9pZCk7CglpZiAoZ3JhZnQtPm5yX3BhcmVudCAhPSAtMSkKCQlyZXR1cm4gMDsKCWlmIChkYXRhLT5mbGFncyAmIFNFRU5fT05MWSkgewoJCXN0cnVjdCBjb21taXQgKmMgPSBsb29rdXBfY29tbWl0KCZncmFmdC0+b2lkKTsKCQlpZiAoIWMgfHwgIShjLT5vYmplY3QuZmxhZ3MgJiBTRUVOKSkgewoJCQlpZiAoZGF0YS0+ZmxhZ3MgJiBWRVJCT1NFKQoJCQkJcHJpbnRmKCJSZW1vdmluZyAlcyBmcm9tIC5naXQvc2hhbGxvd1xuIiwKCQkJCSAgICAgICBvaWRfdG9faGV4KCZjLT5vYmplY3Qub2lkKSk7CgkJCXJldHVybiAwOwoJCX0KCX0KCWRhdGEtPmNvdW50Kys7CglpZiAoZGF0YS0+dXNlX3BhY2tfcHJvdG9jb2wpCgkJcGFja2V0X2J1Zl93cml0ZShkYXRhLT5vdXQsICJzaGFsbG93ICVzIiwgaGV4KTsKCWVsc2UgewoJCXN0cmJ1Zl9hZGRzdHIoZGF0YS0+b3V0LCBoZXgpOwoJCXN0cmJ1Zl9hZGRjaChkYXRhLT5vdXQsICdcbicpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgd3JpdGVfc2hhbGxvd19jb21taXRzXzEoc3RydWN0IHN0cmJ1ZiAqb3V0LCBpbnQgdXNlX3BhY2tfcHJvdG9jb2wsCgkJCQkgICBjb25zdCBzdHJ1Y3Qgb2lkX2FycmF5ICpleHRyYSwKCQkJCSAgIHVuc2lnbmVkIGZsYWdzKQp7CglzdHJ1Y3Qgd3JpdGVfc2hhbGxvd19kYXRhIGRhdGE7CglpbnQgaTsKCWRhdGEub3V0ID0gb3V0OwoJZGF0YS51c2VfcGFja19wcm90b2NvbCA9IHVzZV9wYWNrX3Byb3RvY29sOwoJZGF0YS5jb3VudCA9IDA7CglkYXRhLmZsYWdzID0gZmxhZ3M7Cglmb3JfZWFjaF9jb21taXRfZ3JhZnQod3JpdGVfb25lX3NoYWxsb3csICZkYXRhKTsKCWlmICghZXh0cmEpCgkJcmV0dXJuIGRhdGEuY291bnQ7Cglmb3IgKGkgPSAwOyBpIDwgZXh0cmEtPm5yOyBpKyspIHsKCQlzdHJidWZfYWRkc3RyKG91dCwgb2lkX3RvX2hleChleHRyYS0+b2lkICsgaSkpOwoJCXN0cmJ1Zl9hZGRjaChvdXQsICdcbicpOwoJCWRhdGEuY291bnQrKzsKCX0KCXJldHVybiBkYXRhLmNvdW50Owp9CgppbnQgd3JpdGVfc2hhbGxvd19jb21taXRzKHN0cnVjdCBzdHJidWYgKm91dCwgaW50IHVzZV9wYWNrX3Byb3RvY29sLAoJCQkgIGNvbnN0IHN0cnVjdCBvaWRfYXJyYXkgKmV4dHJhKQp7CglyZXR1cm4gd3JpdGVfc2hhbGxvd19jb21taXRzXzEob3V0LCB1c2VfcGFja19wcm90b2NvbCwgZXh0cmEsIDApOwp9Cgpjb25zdCBjaGFyICpzZXR1cF90ZW1wb3Jhcnlfc2hhbGxvdyhjb25zdCBzdHJ1Y3Qgb2lkX2FycmF5ICpleHRyYSkKewoJc3RydWN0IHRlbXBmaWxlICp0ZW1wOwoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoKCWlmICh3cml0ZV9zaGFsbG93X2NvbW1pdHMoJnNiLCAwLCBleHRyYSkpIHsKCQl0ZW1wID0geG1rc190ZW1wZmlsZShnaXRfcGF0aCgic2hhbGxvd19YWFhYWFgiKSk7CgoJCWlmICh3cml0ZV9pbl9mdWxsKHRlbXAtPmZkLCBzYi5idWYsIHNiLmxlbikgPCAwIHx8CgkJICAgIGNsb3NlX3RlbXBmaWxlX2dlbnRseSh0ZW1wKSA8IDApCgkJCWRpZV9lcnJubygiZmFpbGVkIHRvIHdyaXRlIHRvICVzIiwKCQkJCSAgZ2V0X3RlbXBmaWxlX3BhdGgodGVtcCkpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZzYik7CgkJcmV0dXJuIGdldF90ZW1wZmlsZV9wYXRoKHRlbXApOwoJfQoJLyoKCSAqIGlzX3JlcG9zaXRvcnlfc2hhbGxvdygpIHNlZXMgZW1wdHkgc3RyaW5nIGFzICJubyBzaGFsbG93CgkgKiBmaWxlIi4KCSAqLwoJcmV0dXJuICIiOwp9Cgp2b2lkIHNldHVwX2FsdGVybmF0ZV9zaGFsbG93KHN0cnVjdCBsb2NrX2ZpbGUgKnNoYWxsb3dfbG9jaywKCQkJICAgICBjb25zdCBjaGFyICoqYWx0ZXJuYXRlX3NoYWxsb3dfZmlsZSwKCQkJICAgICBjb25zdCBzdHJ1Y3Qgb2lkX2FycmF5ICpleHRyYSkKewoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJaW50IGZkOwoKCWZkID0gaG9sZF9sb2NrX2ZpbGVfZm9yX3VwZGF0ZShzaGFsbG93X2xvY2ssIGdpdF9wYXRoX3NoYWxsb3coKSwKCQkJCSAgICAgICBMT0NLX0RJRV9PTl9FUlJPUik7CgljaGVja19zaGFsbG93X2ZpbGVfZm9yX3VwZGF0ZSh0aGVfcmVwb3NpdG9yeSk7CglpZiAod3JpdGVfc2hhbGxvd19jb21taXRzKCZzYiwgMCwgZXh0cmEpKSB7CgkJaWYgKHdyaXRlX2luX2Z1bGwoZmQsIHNiLmJ1Ziwgc2IubGVuKSA8IDApCgkJCWRpZV9lcnJubygiZmFpbGVkIHRvIHdyaXRlIHRvICVzIiwKCQkJCSAgZ2V0X2xvY2tfZmlsZV9wYXRoKHNoYWxsb3dfbG9jaykpOwoJCSphbHRlcm5hdGVfc2hhbGxvd19maWxlID0gZ2V0X2xvY2tfZmlsZV9wYXRoKHNoYWxsb3dfbG9jayk7Cgl9IGVsc2UKCQkvKgoJCSAqIGlzX3JlcG9zaXRvcnlfc2hhbGxvdygpIHNlZXMgZW1wdHkgc3RyaW5nIGFzICJubwoJCSAqIHNoYWxsb3cgZmlsZSIuCgkJICovCgkJKmFsdGVybmF0ZV9zaGFsbG93X2ZpbGUgPSAiIjsKCXN0cmJ1Zl9yZWxlYXNlKCZzYik7Cn0KCnN0YXRpYyBpbnQgYWR2ZXJ0aXNlX3NoYWxsb3dfZ3JhZnRzX2NiKGNvbnN0IHN0cnVjdCBjb21taXRfZ3JhZnQgKmdyYWZ0LCB2b2lkICpjYikKewoJaW50IGZkID0gKihpbnQgKiljYjsKCWlmIChncmFmdC0+bnJfcGFyZW50ID09IC0xKQoJCXBhY2tldF93cml0ZV9mbXQoZmQsICJzaGFsbG93ICVzXG4iLCBvaWRfdG9faGV4KCZncmFmdC0+b2lkKSk7CglyZXR1cm4gMDsKfQoKdm9pZCBhZHZlcnRpc2Vfc2hhbGxvd19ncmFmdHMoaW50IGZkKQp7CglpZiAoIWlzX3JlcG9zaXRvcnlfc2hhbGxvdygpKQoJCXJldHVybjsKCWZvcl9lYWNoX2NvbW1pdF9ncmFmdChhZHZlcnRpc2Vfc2hhbGxvd19ncmFmdHNfY2IsICZmZCk7Cn0KCi8qCiAqIG1hcmtfcmVhY2hhYmxlX29iamVjdHMoKSBzaG91bGQgaGF2ZSBiZWVuIHJ1biBwcmlvciB0byB0aGlzIGFuZCBhbGwKICogcmVhY2hhYmxlIGNvbW1pdHMgbWFya2VkIGFzICJTRUVOIi4KICovCnZvaWQgcHJ1bmVfc2hhbGxvdyhpbnQgc2hvd19vbmx5KQp7CglzdGF0aWMgc3RydWN0IGxvY2tfZmlsZSBzaGFsbG93X2xvY2s7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CglpbnQgZmQ7CgoJaWYgKHNob3dfb25seSkgewoJCXdyaXRlX3NoYWxsb3dfY29tbWl0c18xKCZzYiwgMCwgTlVMTCwgU0VFTl9PTkxZIHwgVkVSQk9TRSk7CgkJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCQlyZXR1cm47Cgl9CglmZCA9IGhvbGRfbG9ja19maWxlX2Zvcl91cGRhdGUoJnNoYWxsb3dfbG9jaywgZ2l0X3BhdGhfc2hhbGxvdygpLAoJCQkJICAgICAgIExPQ0tfRElFX09OX0VSUk9SKTsKCWNoZWNrX3NoYWxsb3dfZmlsZV9mb3JfdXBkYXRlKHRoZV9yZXBvc2l0b3J5KTsKCWlmICh3cml0ZV9zaGFsbG93X2NvbW1pdHNfMSgmc2IsIDAsIE5VTEwsIFNFRU5fT05MWSkpIHsKCQlpZiAod3JpdGVfaW5fZnVsbChmZCwgc2IuYnVmLCBzYi5sZW4pIDwgMCkKCQkJZGllX2Vycm5vKCJmYWlsZWQgdG8gd3JpdGUgdG8gJXMiLAoJCQkJICBnZXRfbG9ja19maWxlX3BhdGgoJnNoYWxsb3dfbG9jaykpOwoJCWNvbW1pdF9sb2NrX2ZpbGUoJnNoYWxsb3dfbG9jayk7Cgl9IGVsc2UgewoJCXVubGluayhnaXRfcGF0aF9zaGFsbG93KCkpOwoJCXJvbGxiYWNrX2xvY2tfZmlsZSgmc2hhbGxvd19sb2NrKTsKCX0KCXN0cmJ1Zl9yZWxlYXNlKCZzYik7Cn0KCnN0cnVjdCB0cmFjZV9rZXkgdHJhY2Vfc2hhbGxvdyA9IFRSQUNFX0tFWV9JTklUKFNIQUxMT1cpOwoKLyoKICogU3RlcCAxLCBzcGxpdCBzZW5kZXIgc2hhbGxvdyBjb21taXRzIGludG8gIm91cnMiIGFuZCAidGhlaXJzIgogKiBTdGVwIDIsIGNsZWFuICJvdXJzIiBiYXNlZCBvbiAuZ2l0L3NoYWxsb3cKICovCnZvaWQgcHJlcGFyZV9zaGFsbG93X2luZm8oc3RydWN0IHNoYWxsb3dfaW5mbyAqaW5mbywgc3RydWN0IG9pZF9hcnJheSAqc2EpCnsKCWludCBpOwoJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2Vfc2hhbGxvdywgInNoYWxsb3c6IHByZXBhcmVfc2hhbGxvd19pbmZvXG4iKTsKCW1lbXNldChpbmZvLCAwLCBzaXplb2YoKmluZm8pKTsKCWluZm8tPnNoYWxsb3cgPSBzYTsKCWlmICghc2EpCgkJcmV0dXJuOwoJQUxMT0NfQVJSQVkoaW5mby0+b3Vycywgc2EtPm5yKTsKCUFMTE9DX0FSUkFZKGluZm8tPnRoZWlycywgc2EtPm5yKTsKCWZvciAoaSA9IDA7IGkgPCBzYS0+bnI7IGkrKykgewoJCWlmIChoYXNfb2JqZWN0X2ZpbGUoc2EtPm9pZCArIGkpKSB7CgkJCXN0cnVjdCBjb21taXRfZ3JhZnQgKmdyYWZ0OwoJCQlncmFmdCA9IGxvb2t1cF9jb21taXRfZ3JhZnQodGhlX3JlcG9zaXRvcnksCgkJCQkJCSAgICAmc2EtPm9pZFtpXSk7CgkJCWlmIChncmFmdCAmJiBncmFmdC0+bnJfcGFyZW50IDwgMCkKCQkJCWNvbnRpbnVlOwoJCQlpbmZvLT5vdXJzW2luZm8tPm5yX291cnMrK10gPSBpOwoJCX0gZWxzZQoJCQlpbmZvLT50aGVpcnNbaW5mby0+bnJfdGhlaXJzKytdID0gaTsKCX0KfQoKdm9pZCBjbGVhcl9zaGFsbG93X2luZm8oc3RydWN0IHNoYWxsb3dfaW5mbyAqaW5mbykKewoJZnJlZShpbmZvLT5vdXJzKTsKCWZyZWUoaW5mby0+dGhlaXJzKTsKfQoKLyogU3RlcCA0LCByZW1vdmUgbm9uLWV4aXN0ZW50IG9uZXMgaW4gInRoZWlycyIgYWZ0ZXIgZ2V0dGluZyB0aGUgcGFjayAqLwoKdm9pZCByZW1vdmVfbm9uZXhpc3RlbnRfdGhlaXJzX3NoYWxsb3coc3RydWN0IHNoYWxsb3dfaW5mbyAqaW5mbykKewoJc3RydWN0IG9iamVjdF9pZCAqb2lkID0gaW5mby0+c2hhbGxvdy0+b2lkOwoJaW50IGksIGRzdDsKCXRyYWNlX3ByaW50Zl9rZXkoJnRyYWNlX3NoYWxsb3csICJzaGFsbG93OiByZW1vdmVfbm9uZXhpc3RlbnRfdGhlaXJzX3NoYWxsb3dcbiIpOwoJZm9yIChpID0gZHN0ID0gMDsgaSA8IGluZm8tPm5yX3RoZWlyczsgaSsrKSB7CgkJaWYgKGkgIT0gZHN0KQoJCQlpbmZvLT50aGVpcnNbZHN0XSA9IGluZm8tPnRoZWlyc1tpXTsKCQlpZiAoaGFzX29iamVjdF9maWxlKG9pZCArIGluZm8tPnRoZWlyc1tpXSkpCgkJCWRzdCsrOwoJfQoJaW5mby0+bnJfdGhlaXJzID0gZHN0Owp9CgpkZWZpbmVfY29tbWl0X3NsYWIocmVmX2JpdG1hcCwgdWludDMyX3QgKik7CgojZGVmaW5lIFBPT0xfU0laRSAoNTEyICogMTAyNCkKCnN0cnVjdCBwYWludF9pbmZvIHsKCXN0cnVjdCByZWZfYml0bWFwIHJlZl9iaXRtYXA7Cgl1bnNpZ25lZCBucl9iaXRzOwoJY2hhciAqKnBvb2xzOwoJY2hhciAqZnJlZSwgKmVuZDsKCXVuc2lnbmVkIHBvb2xfY291bnQ7Cn07CgpzdGF0aWMgdWludDMyX3QgKnBhaW50X2FsbG9jKHN0cnVjdCBwYWludF9pbmZvICppbmZvKQp7Cgl1bnNpZ25lZCBuciA9IERJVl9ST1VORF9VUChpbmZvLT5ucl9iaXRzLCAzMik7Cgl1bnNpZ25lZCBzaXplID0gbnIgKiBzaXplb2YodWludDMyX3QpOwoJdm9pZCAqcDsKCWlmICghaW5mby0+cG9vbF9jb3VudCB8fCBzaXplID4gaW5mby0+ZW5kIC0gaW5mby0+ZnJlZSkgewoJCWlmIChzaXplID4gUE9PTF9TSVpFKQoJCQlkaWUoIkJVRzogcG9vbCBzaXplIHRvbyBzbWFsbCBmb3IgJWQgaW4gcGFpbnRfYWxsb2MoKSIsCgkJCSAgICBzaXplKTsKCQlpbmZvLT5wb29sX2NvdW50Kys7CgkJUkVBTExPQ19BUlJBWShpbmZvLT5wb29scywgaW5mby0+cG9vbF9jb3VudCk7CgkJaW5mby0+ZnJlZSA9IHhtYWxsb2MoUE9PTF9TSVpFKTsKCQlpbmZvLT5wb29sc1tpbmZvLT5wb29sX2NvdW50IC0gMV0gPSBpbmZvLT5mcmVlOwoJCWluZm8tPmVuZCA9IGluZm8tPmZyZWUgKyBQT09MX1NJWkU7Cgl9CglwID0gaW5mby0+ZnJlZTsKCWluZm8tPmZyZWUgKz0gc2l6ZTsKCXJldHVybiBwOwp9CgovKgogKiBHaXZlbiBhIGNvbW1pdCBTSEEtMSwgd2FsayBkb3duIHRvIHBhcmVudHMgdW50aWwgZWl0aGVyIFNFRU4sCiAqIFVOSU5URVJFU1RJTkcgb3IgQk9UVE9NIGlzIGhpdC4gU2V0IHRoZSBpZC10aCBiaXQgaW4gcmVmX2JpdG1hcCBmb3IKICogYWxsIHdhbGtlZCBjb21taXRzLgogKi8Kc3RhdGljIHZvaWQgcGFpbnRfZG93bihzdHJ1Y3QgcGFpbnRfaW5mbyAqaW5mbywgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCSAgICAgICB1bnNpZ25lZCBpbnQgaWQpCnsKCXVuc2lnbmVkIGludCBpLCBucjsKCXN0cnVjdCBjb21taXRfbGlzdCAqaGVhZCA9IE5VTEw7CglpbnQgYml0bWFwX25yID0gRElWX1JPVU5EX1VQKGluZm8tPm5yX2JpdHMsIDMyKTsKCXNpemVfdCBiaXRtYXBfc2l6ZSA9IHN0X211bHQoc2l6ZW9mKHVpbnQzMl90KSwgYml0bWFwX25yKTsKCXN0cnVjdCBjb21taXQgKmMgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkob2lkLCAxKTsKCXVpbnQzMl90ICp0bXA7IC8qIHRvIGJlIGZyZWVkIGJlZm9yZSByZXR1cm4gKi8KCXVpbnQzMl90ICpiaXRtYXA7CgoJaWYgKCFjKQoJCXJldHVybjsKCgl0bXAgPSB4bWFsbG9jKGJpdG1hcF9zaXplKTsKCWJpdG1hcCA9IHBhaW50X2FsbG9jKGluZm8pOwoJbWVtc2V0KGJpdG1hcCwgMCwgYml0bWFwX3NpemUpOwoJYml0bWFwW2lkIC8gMzJdIHw9ICgxVSA8PCAoaWQgJSAzMikpOwoJY29tbWl0X2xpc3RfaW5zZXJ0KGMsICZoZWFkKTsKCXdoaWxlIChoZWFkKSB7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpwOwoJCXN0cnVjdCBjb21taXQgKmMgPSBwb3BfY29tbWl0KCZoZWFkKTsKCQl1aW50MzJfdCAqKnJlZnMgPSByZWZfYml0bWFwX2F0KCZpbmZvLT5yZWZfYml0bWFwLCBjKTsKCgkJLyogWFhYIGNoZWNrICJVTklOVEVSRVNUSU5HIiBmcm9tIHBhY2sgYml0bWFwcyBpZiBhdmFpbGFibGUgKi8KCQlpZiAoYy0+b2JqZWN0LmZsYWdzICYgKFNFRU4gfCBVTklOVEVSRVNUSU5HKSkKCQkJY29udGludWU7CgkJZWxzZQoJCQljLT5vYmplY3QuZmxhZ3MgfD0gU0VFTjsKCgkJaWYgKCpyZWZzID09IE5VTEwpCgkJCSpyZWZzID0gYml0bWFwOwoJCWVsc2UgewoJCQltZW1jcHkodG1wLCAqcmVmcywgYml0bWFwX3NpemUpOwoJCQlmb3IgKGkgPSAwOyBpIDwgYml0bWFwX25yOyBpKyspCgkJCQl0bXBbaV0gfD0gYml0bWFwW2ldOwoJCQlpZiAobWVtY21wKHRtcCwgKnJlZnMsIGJpdG1hcF9zaXplKSkgewoJCQkJKnJlZnMgPSBwYWludF9hbGxvYyhpbmZvKTsKCQkJCW1lbWNweSgqcmVmcywgdG1wLCBiaXRtYXBfc2l6ZSk7CgkJCX0KCQl9CgoJCWlmIChjLT5vYmplY3QuZmxhZ3MgJiBCT1RUT00pCgkJCWNvbnRpbnVlOwoKCQlpZiAocGFyc2VfY29tbWl0KGMpKQoJCQlkaWUoInVuYWJsZSB0byBwYXJzZSBjb21taXQgJXMiLAoJCQkgICAgb2lkX3RvX2hleCgmYy0+b2JqZWN0Lm9pZCkpOwoKCQlmb3IgKHAgPSBjLT5wYXJlbnRzOyBwOyBwID0gcC0+bmV4dCkgewoJCQlpZiAocC0+aXRlbS0+b2JqZWN0LmZsYWdzICYgU0VFTikKCQkJCWNvbnRpbnVlOwoJCQljb21taXRfbGlzdF9pbnNlcnQocC0+aXRlbSwgJmhlYWQpOwoJCX0KCX0KCgluciA9IGdldF9tYXhfb2JqZWN0X2luZGV4KCk7Cglmb3IgKGkgPSAwOyBpIDwgbnI7IGkrKykgewoJCXN0cnVjdCBvYmplY3QgKm8gPSBnZXRfaW5kZXhlZF9vYmplY3QoaSk7CgkJaWYgKG8gJiYgby0+dHlwZSA9PSBPQkpfQ09NTUlUKQoJCQlvLT5mbGFncyAmPSB+U0VFTjsKCX0KCglmcmVlKHRtcCk7Cn0KCnN0YXRpYyBpbnQgbWFya191bmludGVyZXN0aW5nKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJICAgICAgaW50IGZsYWdzLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkob2lkLCAxKTsKCWlmICghY29tbWl0KQoJCXJldHVybiAwOwoJY29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gVU5JTlRFUkVTVElORzsKCW1hcmtfcGFyZW50c191bmludGVyZXN0aW5nKGNvbW1pdCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgcG9zdF9hc3NpZ25fc2hhbGxvdyhzdHJ1Y3Qgc2hhbGxvd19pbmZvICppbmZvLAoJCQkJc3RydWN0IHJlZl9iaXRtYXAgKnJlZl9iaXRtYXAsCgkJCQlpbnQgKnJlZl9zdGF0dXMpOwovKgogKiBTdGVwIDYoKzcpLCBhc3NvY2lhdGUgc2hhbGxvdyBjb21taXRzIHdpdGggbmV3IHJlZnMKICoKICogaW5mby0+cmVmIG11c3QgYmUgaW5pdGlhbGl6ZWQgYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi4KICoKICogSWYgdXNlZCBpcyBub3QgTlVMTCwgaXQncyBhbiBhcnJheSBvZiBpbmZvLT5zaGFsbG93LT5ucgogKiBiaXRtYXBzLiBUaGUgbi10aCBiaXQgc2V0IGluIHRoZSBtLXRoIGJpdG1hcCBpZiByZWZbbl0gbmVlZHMgdGhlCiAqIG0tdGggc2hhbGxvdyBjb21taXQgZnJvbSBpbmZvLT5zaGFsbG93LgogKgogKiBJZiB1c2VkIGlzIE5VTEwsICJvdXJzIiBhbmQgInRoZWlycyIgYXJlIHVwZGF0ZWQuIEFuZCBpZiByZWZfc3RhdHVzCiAqIGlzIG5vdCBOVUxMIGl0J3MgYW4gYXJyYXkgb2YgcmVmLT5uciBpbnRzLiByZWZfc3RhdHVzW2ldIGlzIHRydWUgaWYKICogdGhlIHJlZiBuZWVkcyBzb21lIHNoYWxsb3cgY29tbWl0cyBmcm9tIGVpdGhlciBpbmZvLT5vdXJzIG9yCiAqIGluZm8tPnRoZWlycy4KICovCnZvaWQgYXNzaWduX3NoYWxsb3dfY29tbWl0c190b19yZWZzKHN0cnVjdCBzaGFsbG93X2luZm8gKmluZm8sCgkJCQkgICAgdWludDMyX3QgKip1c2VkLCBpbnQgKnJlZl9zdGF0dXMpCnsKCXN0cnVjdCBvYmplY3RfaWQgKm9pZCA9IGluZm8tPnNoYWxsb3ctPm9pZDsKCXN0cnVjdCBvaWRfYXJyYXkgKnJlZiA9IGluZm8tPnJlZjsKCXVuc2lnbmVkIGludCBpLCBucjsKCWludCAqc2hhbGxvdywgbnJfc2hhbGxvdyA9IDA7CglzdHJ1Y3QgcGFpbnRfaW5mbyBwaTsKCgl0cmFjZV9wcmludGZfa2V5KCZ0cmFjZV9zaGFsbG93LCAic2hhbGxvdzogYXNzaWduX3NoYWxsb3dfY29tbWl0c190b19yZWZzXG4iKTsKCUFMTE9DX0FSUkFZKHNoYWxsb3csIGluZm8tPm5yX291cnMgKyBpbmZvLT5ucl90aGVpcnMpOwoJZm9yIChpID0gMDsgaSA8IGluZm8tPm5yX291cnM7IGkrKykKCQlzaGFsbG93W25yX3NoYWxsb3crK10gPSBpbmZvLT5vdXJzW2ldOwoJZm9yIChpID0gMDsgaSA8IGluZm8tPm5yX3RoZWlyczsgaSsrKQoJCXNoYWxsb3dbbnJfc2hhbGxvdysrXSA9IGluZm8tPnRoZWlyc1tpXTsKCgkvKgoJICogUHJlcGFyZSB0aGUgY29tbWl0IGdyYXBoIHRvIHRyYWNrIHdoYXQgcmVmcyBjYW4gcmVhY2ggd2hhdAoJICogKG5ldykgc2hhbGxvdyBjb21taXRzLgoJICovCgluciA9IGdldF9tYXhfb2JqZWN0X2luZGV4KCk7Cglmb3IgKGkgPSAwOyBpIDwgbnI7IGkrKykgewoJCXN0cnVjdCBvYmplY3QgKm8gPSBnZXRfaW5kZXhlZF9vYmplY3QoaSk7CgkJaWYgKCFvIHx8IG8tPnR5cGUgIT0gT0JKX0NPTU1JVCkKCQkJY29udGludWU7CgoJCW8tPmZsYWdzICY9IH4oVU5JTlRFUkVTVElORyB8IEJPVFRPTSB8IFNFRU4pOwoJfQoKCW1lbXNldCgmcGksIDAsIHNpemVvZihwaSkpOwoJaW5pdF9yZWZfYml0bWFwKCZwaS5yZWZfYml0bWFwKTsKCXBpLm5yX2JpdHMgPSByZWYtPm5yOwoKCS8qCgkgKiAiLS1ub3QgLS1hbGwiIHRvIGN1dCBzaG9ydCB0aGUgdHJhdmVyc2FsIGlmIG5ldyByZWZzCgkgKiBjb25uZWN0IHRvIG9sZCByZWZzLiBJZiBub3QgKGUuZy4gZm9yY2UgcmVmIHVwZGF0ZXMpIGl0J2xsCgkgKiBoYXZlIHRvIGdvIGRvd24gdG8gdGhlIGN1cnJlbnQgc2hhbGxvdyBjb21taXRzLgoJICovCgloZWFkX3JlZihtYXJrX3VuaW50ZXJlc3RpbmcsIE5VTEwpOwoJZm9yX2VhY2hfcmVmKG1hcmtfdW5pbnRlcmVzdGluZywgTlVMTCk7CgoJLyogTWFyayBwb3RlbnRpYWwgYm90dG9tcyBzbyB3ZSB3b24ndCBnbyBvdXQgb2YgYm91bmQgKi8KCWZvciAoaSA9IDA7IGkgPCBucl9zaGFsbG93OyBpKyspIHsKCQlzdHJ1Y3QgY29tbWl0ICpjID0gbG9va3VwX2NvbW1pdCgmb2lkW3NoYWxsb3dbaV1dKTsKCQljLT5vYmplY3QuZmxhZ3MgfD0gQk9UVE9NOwoJfQoKCWZvciAoaSA9IDA7IGkgPCByZWYtPm5yOyBpKyspCgkJcGFpbnRfZG93bigmcGksIHJlZi0+b2lkICsgaSwgaSk7CgoJaWYgKHVzZWQpIHsKCQlpbnQgYml0bWFwX3NpemUgPSBESVZfUk9VTkRfVVAocGkubnJfYml0cywgMzIpICogc2l6ZW9mKHVpbnQzMl90KTsKCQltZW1zZXQodXNlZCwgMCwgc2l6ZW9mKCp1c2VkKSAqIGluZm8tPnNoYWxsb3ctPm5yKTsKCQlmb3IgKGkgPSAwOyBpIDwgbnJfc2hhbGxvdzsgaSsrKSB7CgkJCWNvbnN0IHN0cnVjdCBjb21taXQgKmMgPSBsb29rdXBfY29tbWl0KCZvaWRbc2hhbGxvd1tpXV0pOwoJCQl1aW50MzJfdCAqKm1hcCA9IHJlZl9iaXRtYXBfYXQoJnBpLnJlZl9iaXRtYXAsIGMpOwoJCQlpZiAoKm1hcCkKCQkJCXVzZWRbc2hhbGxvd1tpXV0gPSB4bWVtZHVweigqbWFwLCBiaXRtYXBfc2l6ZSk7CgkJfQoJCS8qCgkJICogdW5yZWFjaGFibGUgc2hhbGxvdyBjb21taXRzIGFyZSBub3QgcmVtb3ZlZCBmcm9tCgkJICogIm91cnMiIGFuZCAidGhlaXJzIi4gVGhlIHVzZXIgaXMgc3VwcG9zZWQgdG8gcnVuCgkJICogc3RlcCA3IG9uIGV2ZXJ5IHJlZiBzZXBhcmF0ZWx5IGFuZCBub3QgdHJ1c3QgIm91cnMiCgkJICogYW5kICJ0aGVpcnMiIGFueSBtb3JlLgoJCSAqLwoJfSBlbHNlCgkJcG9zdF9hc3NpZ25fc2hhbGxvdyhpbmZvLCAmcGkucmVmX2JpdG1hcCwgcmVmX3N0YXR1cyk7CgoJY2xlYXJfcmVmX2JpdG1hcCgmcGkucmVmX2JpdG1hcCk7Cglmb3IgKGkgPSAwOyBpIDwgcGkucG9vbF9jb3VudDsgaSsrKQoJCWZyZWUocGkucG9vbHNbaV0pOwoJZnJlZShwaS5wb29scyk7CglmcmVlKHNoYWxsb3cpOwp9CgpzdHJ1Y3QgY29tbWl0X2FycmF5IHsKCXN0cnVjdCBjb21taXQgKipjb21taXRzOwoJaW50IG5yLCBhbGxvYzsKfTsKCnN0YXRpYyBpbnQgYWRkX3JlZihjb25zdCBjaGFyICpyZWZuYW1lLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJICAgaW50IGZsYWdzLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3QgY29tbWl0X2FycmF5ICpjYSA9IGNiX2RhdGE7CglBTExPQ19HUk9XKGNhLT5jb21taXRzLCBjYS0+bnIgKyAxLCBjYS0+YWxsb2MpOwoJY2EtPmNvbW1pdHNbY2EtPm5yXSA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseShvaWQsIDEpOwoJaWYgKGNhLT5jb21taXRzW2NhLT5ucl0pCgkJY2EtPm5yKys7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgdXBkYXRlX3JlZnN0YXR1cyhpbnQgKnJlZl9zdGF0dXMsIGludCBuciwgdWludDMyX3QgKmJpdG1hcCkKewoJdW5zaWduZWQgaW50IGk7CglpZiAoIXJlZl9zdGF0dXMpCgkJcmV0dXJuOwoJZm9yIChpID0gMDsgaSA8IG5yOyBpKyspCgkJaWYgKGJpdG1hcFtpIC8gMzJdICYgKDFVIDw8IChpICUgMzIpKSkKCQkJcmVmX3N0YXR1c1tpXSsrOwp9CgovKgogKiBTdGVwIDcsIHJlYWNoYWJpbGl0eSB0ZXN0IG9uICJvdXJzIiBhdCBjb21taXQgbGV2ZWwKICovCnN0YXRpYyB2b2lkIHBvc3RfYXNzaWduX3NoYWxsb3coc3RydWN0IHNoYWxsb3dfaW5mbyAqaW5mbywKCQkJCXN0cnVjdCByZWZfYml0bWFwICpyZWZfYml0bWFwLAoJCQkJaW50ICpyZWZfc3RhdHVzKQp7CglzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQgPSBpbmZvLT5zaGFsbG93LT5vaWQ7CglzdHJ1Y3QgY29tbWl0ICpjOwoJdWludDMyX3QgKipiaXRtYXA7CglpbnQgZHN0LCBpLCBqOwoJaW50IGJpdG1hcF9uciA9IERJVl9ST1VORF9VUChpbmZvLT5yZWYtPm5yLCAzMik7CglzdHJ1Y3QgY29tbWl0X2FycmF5IGNhOwoKCXRyYWNlX3ByaW50Zl9rZXkoJnRyYWNlX3NoYWxsb3csICJzaGFsbG93OiBwb3N0X2Fzc2lnbl9zaGFsbG93XG4iKTsKCWlmIChyZWZfc3RhdHVzKQoJCW1lbXNldChyZWZfc3RhdHVzLCAwLCBzaXplb2YoKnJlZl9zdGF0dXMpICogaW5mby0+cmVmLT5ucik7CgoJLyogUmVtb3ZlIHVucmVhY2hhYmxlIHNoYWxsb3cgY29tbWl0cyBmcm9tICJ0aGVpcnMiICovCglmb3IgKGkgPSBkc3QgPSAwOyBpIDwgaW5mby0+bnJfdGhlaXJzOyBpKyspIHsKCQlpZiAoaSAhPSBkc3QpCgkJCWluZm8tPnRoZWlyc1tkc3RdID0gaW5mby0+dGhlaXJzW2ldOwoJCWMgPSBsb29rdXBfY29tbWl0KCZvaWRbaW5mby0+dGhlaXJzW2ldXSk7CgkJYml0bWFwID0gcmVmX2JpdG1hcF9hdChyZWZfYml0bWFwLCBjKTsKCQlpZiAoISpiaXRtYXApCgkJCWNvbnRpbnVlOwoJCWZvciAoaiA9IDA7IGogPCBiaXRtYXBfbnI7IGorKykKCQkJaWYgKGJpdG1hcFswXVtqXSkgewoJCQkJdXBkYXRlX3JlZnN0YXR1cyhyZWZfc3RhdHVzLCBpbmZvLT5yZWYtPm5yLCAqYml0bWFwKTsKCQkJCWRzdCsrOwoJCQkJYnJlYWs7CgkJCX0KCX0KCWluZm8tPm5yX3RoZWlycyA9IGRzdDsKCgltZW1zZXQoJmNhLCAwLCBzaXplb2YoY2EpKTsKCWhlYWRfcmVmKGFkZF9yZWYsICZjYSk7Cglmb3JfZWFjaF9yZWYoYWRkX3JlZiwgJmNhKTsKCgkvKiBSZW1vdmUgdW5yZWFjaGFibGUgc2hhbGxvdyBjb21taXRzIGZyb20gIm91cnMiICovCglmb3IgKGkgPSBkc3QgPSAwOyBpIDwgaW5mby0+bnJfb3VyczsgaSsrKSB7CgkJaWYgKGkgIT0gZHN0KQoJCQlpbmZvLT5vdXJzW2RzdF0gPSBpbmZvLT5vdXJzW2ldOwoJCWMgPSBsb29rdXBfY29tbWl0KCZvaWRbaW5mby0+b3Vyc1tpXV0pOwoJCWJpdG1hcCA9IHJlZl9iaXRtYXBfYXQocmVmX2JpdG1hcCwgYyk7CgkJaWYgKCEqYml0bWFwKQoJCQljb250aW51ZTsKCQlmb3IgKGogPSAwOyBqIDwgYml0bWFwX25yOyBqKyspCgkJCWlmIChiaXRtYXBbMF1bal0gJiYKCQkJICAgIC8qIFN0ZXAgNywgcmVhY2hhYmlsaXR5IHRlc3QgYXQgY29tbWl0IGxldmVsICovCgkJCSAgICAhaW5fbWVyZ2VfYmFzZXNfbWFueShjLCBjYS5uciwgY2EuY29tbWl0cykpIHsKCQkJCXVwZGF0ZV9yZWZzdGF0dXMocmVmX3N0YXR1cywgaW5mby0+cmVmLT5uciwgKmJpdG1hcCk7CgkJCQlkc3QrKzsKCQkJCWJyZWFrOwoJCQl9Cgl9CglpbmZvLT5ucl9vdXJzID0gZHN0OwoKCWZyZWUoY2EuY29tbWl0cyk7Cn0KCi8qIChEZWxheWVkKSBzdGVwIDcsIHJlYWNoYWJpbGl0eSB0ZXN0IGF0IGNvbW1pdCBsZXZlbCAqLwppbnQgZGVsYXllZF9yZWFjaGFiaWxpdHlfdGVzdChzdHJ1Y3Qgc2hhbGxvd19pbmZvICpzaSwgaW50IGMpCnsKCWlmIChzaS0+bmVlZF9yZWFjaGFiaWxpdHlfdGVzdFtjXSkgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IGxvb2t1cF9jb21taXQoJnNpLT5zaGFsbG93LT5vaWRbY10pOwoKCQlpZiAoIXNpLT5jb21taXRzKSB7CgkJCXN0cnVjdCBjb21taXRfYXJyYXkgY2E7CgoJCQltZW1zZXQoJmNhLCAwLCBzaXplb2YoY2EpKTsKCQkJaGVhZF9yZWYoYWRkX3JlZiwgJmNhKTsKCQkJZm9yX2VhY2hfcmVmKGFkZF9yZWYsICZjYSk7CgkJCXNpLT5jb21taXRzID0gY2EuY29tbWl0czsKCQkJc2ktPm5yX2NvbW1pdHMgPSBjYS5ucjsKCQl9CgoJCXNpLT5yZWFjaGFibGVbY10gPSBpbl9tZXJnZV9iYXNlc19tYW55KGNvbW1pdCwKCQkJCQkJICAgICAgIHNpLT5ucl9jb21taXRzLAoJCQkJCQkgICAgICAgc2ktPmNvbW1pdHMpOwoJCXNpLT5uZWVkX3JlYWNoYWJpbGl0eV90ZXN0W2NdID0gMDsKCX0KCXJldHVybiBzaS0+cmVhY2hhYmxlW2NdOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"repository.h\"\n#include \"tempfile.h\"\n#include \"lockfile.h\"\n#include \"object-store.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"pkt-line.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"sha1-array.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"commit-slab.h\"\n#include \"revision.h\"\n#include \"list-objects.h\"\n\nstatic int is_shallow = -1;\nstatic struct stat_validity shallow_stat;\nstatic char *alternate_shallow_file;\n\nvoid set_alternate_shallow_file_the_repository(const char *path, int override)\n{\n\tif (is_shallow != -1)\n\t\tdie(\"BUG: is_repository_shallow must not be called before set_alternate_shallow_file\");\n\tif (alternate_shallow_file && !override)\n\t\treturn;\n\tfree(alternate_shallow_file);\n\talternate_shallow_file = xstrdup_or_null(path);\n}\n\nint register_shallow_the_repository(const struct object_id *oid)\n{\n\tstruct commit_graft *graft =\n\t\txmalloc(sizeof(struct commit_graft));\n\tstruct commit *commit = lookup_commit(oid);\n\n\toidcpy(&graft->oid, oid);\n\tgraft->nr_parent = -1;\n\tif (commit && commit->object.parsed)\n\t\tcommit->parents = NULL;\n\treturn register_commit_graft(the_repository, graft, 0);\n}\n\nint is_repository_shallow(void)\n{\n\tFILE *fp;\n\tchar buf[1024];\n\tconst char *path = alternate_shallow_file;\n\n\tif (is_shallow >= 0)\n\t\treturn is_shallow;\n\n\tif (!path)\n\t\tpath = git_path_shallow();\n\t/*\n\t * fetch-pack sets '--shallow-file \"\"' as an indicator that no\n\t * shallow file should be used. We could just open it and it\n\t * will likely fail. But let's do an explicit check instead.\n\t */\n\tif (!*path || (fp = fopen(path, \"r\")) == NULL) {\n\t\tstat_validity_clear(&shallow_stat);\n\t\tis_shallow = 0;\n\t\treturn is_shallow;\n\t}\n\tstat_validity_update(&shallow_stat, fileno(fp));\n\tis_shallow = 1;\n\n\twhile (fgets(buf, sizeof(buf), fp)) {\n\t\tstruct object_id oid;\n\t\tif (get_oid_hex(buf, &oid))\n\t\t\tdie(\"bad shallow line: %s\", buf);\n\t\tregister_shallow(the_repository, &oid);\n\t}\n\tfclose(fp);\n\treturn is_shallow;\n}\n\nstruct commit_list *get_shallow_commits(struct object_array *heads, int depth,\n\t\tint shallow_flag, int not_shallow_flag)\n{\n\tint i = 0, cur_depth = 0;\n\tstruct commit_list *result = NULL;\n\tstruct object_array stack = OBJECT_ARRAY_INIT;\n\tstruct commit *commit = NULL;\n\tstruct commit_graft *graft;\n\n\twhile (commit || i < heads->nr || stack.nr) {\n\t\tstruct commit_list *p;\n\t\tif (!commit) {\n\t\t\tif (i < heads->nr) {\n\t\t\t\tcommit = (struct commit *)\n\t\t\t\t\tderef_tag(heads->objects[i++].item, NULL, 0);\n\t\t\t\tif (!commit || commit->object.type != OBJ_COMMIT) {\n\t\t\t\t\tcommit = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!commit->util)\n\t\t\t\t\tcommit->util = xmalloc(sizeof(int));\n\t\t\t\t*(int *)commit->util = 0;\n\t\t\t\tcur_depth = 0;\n\t\t\t} else {\n\t\t\t\tcommit = (struct commit *)\n\t\t\t\t\tobject_array_pop(&stack);\n\t\t\t\tcur_depth = *(int *)commit->util;\n\t\t\t}\n\t\t}\n\t\tparse_commit_or_die(commit);\n\t\tcur_depth++;\n\t\tif ((depth != INFINITE_DEPTH && cur_depth >= depth) ||\n\t\t    (is_repository_shallow() && !commit->parents &&\n\t\t     (graft = lookup_commit_graft(the_repository, &commit->object.oid)) != NULL &&\n\t\t     graft->nr_parent < 0)) {\n\t\t\tcommit_list_insert(commit, &result);\n\t\t\tcommit->object.flags |= shallow_flag;\n\t\t\tcommit = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tcommit->object.flags |= not_shallow_flag;\n\t\tfor (p = commit->parents, commit = NULL; p; p = p->next) {\n\t\t\tif (!p->item->util) {\n\t\t\t\tint *pointer = xmalloc(sizeof(int));\n\t\t\t\tp->item->util = pointer;\n\t\t\t\t*pointer =  cur_depth;\n\t\t\t} else {\n\t\t\t\tint *pointer = p->item->util;\n\t\t\t\tif (cur_depth >= *pointer)\n\t\t\t\t\tcontinue;\n\t\t\t\t*pointer = cur_depth;\n\t\t\t}\n\t\t\tif (p->next)\n\t\t\t\tadd_object_array(&p->item->object,\n\t\t\t\t\t\tNULL, &stack);\n\t\t\telse {\n\t\t\t\tcommit = p->item;\n\t\t\t\tcur_depth = *(int *)commit->util;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic void show_commit(struct commit *commit, void *data)\n{\n\tcommit_list_insert(commit, data);\n}\n\n/*\n * Given rev-list arguments, run rev-list. All reachable commits\n * except border ones are marked with not_shallow_flag. Border commits\n * are marked with shallow_flag. The list of border/shallow commits\n * are also returned.\n */\nstruct commit_list *get_shallow_commits_by_rev_list(int ac, const char **av,\n\t\t\t\t\t\t    int shallow_flag,\n\t\t\t\t\t\t    int not_shallow_flag)\n{\n\tstruct commit_list *result = NULL, *p;\n\tstruct commit_list *not_shallow_list = NULL;\n\tstruct rev_info revs;\n\tint both_flags = shallow_flag | not_shallow_flag;\n\n\t/*\n\t * SHALLOW (excluded) and NOT_SHALLOW (included) should not be\n\t * set at this point. But better be safe than sorry.\n\t */\n\tclear_object_flags(both_flags);\n\n\tis_repository_shallow(); /* make sure shallows are read */\n\n\tinit_revisions(&revs, NULL);\n\tsave_commit_buffer = 0;\n\tsetup_revisions(ac, av, &revs, NULL);\n\n\tif (prepare_revision_walk(&revs))\n\t\tdie(\"revision walk setup failed\");\n\ttraverse_commit_list(&revs, show_commit, NULL, &not_shallow_list);\n\n\t/* Mark all reachable commits as NOT_SHALLOW */\n\tfor (p = not_shallow_list; p; p = p->next)\n\t\tp->item->object.flags |= not_shallow_flag;\n\n\t/*\n\t * mark border commits SHALLOW + NOT_SHALLOW.\n\t * We cannot clear NOT_SHALLOW right now. Imagine border\n\t * commit A is processed first, then commit B, whose parent is\n\t * A, later. If NOT_SHALLOW on A is cleared at step 1, B\n\t * itself is considered border at step 2, which is incorrect.\n\t */\n\tfor (p = not_shallow_list; p; p = p->next) {\n\t\tstruct commit *c = p->item;\n\t\tstruct commit_list *parent;\n\n\t\tif (parse_commit(c))\n\t\t\tdie(\"unable to parse commit %s\",\n\t\t\t    oid_to_hex(&c->object.oid));\n\n\t\tfor (parent = c->parents; parent; parent = parent->next)\n\t\t\tif (!(parent->item->object.flags & not_shallow_flag)) {\n\t\t\t\tc->object.flags |= shallow_flag;\n\t\t\t\tcommit_list_insert(c, &result);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tfree_commit_list(not_shallow_list);\n\n\t/*\n\t * Now we can clean up NOT_SHALLOW on border commits. Having\n\t * both flags set can confuse the caller.\n\t */\n\tfor (p = result; p; p = p->next) {\n\t\tstruct object *o = &p->item->object;\n\t\tif ((o->flags & both_flags) == both_flags)\n\t\t\to->flags &= ~not_shallow_flag;\n\t}\n\treturn result;\n}\n\n#define check_shallow_file_for_update(r) check_shallow_file_for_update_##r()\nstatic void check_shallow_file_for_update_the_repository(void)\n{\n\tif (is_shallow == -1)\n\t\tdie(\"BUG: shallow must be initialized by now\");\n\n\tif (!stat_validity_check(&shallow_stat, git_path_shallow()))\n\t\tdie(\"shallow file has changed since we read it\");\n}\n\n#define SEEN_ONLY 1\n#define VERBOSE   2\n\nstruct write_shallow_data {\n\tstruct strbuf *out;\n\tint use_pack_protocol;\n\tint count;\n\tunsigned flags;\n};\n\nstatic int write_one_shallow(const struct commit_graft *graft, void *cb_data)\n{\n\tstruct write_shallow_data *data = cb_data;\n\tconst char *hex = oid_to_hex(&graft->oid);\n\tif (graft->nr_parent != -1)\n\t\treturn 0;\n\tif (data->flags & SEEN_ONLY) {\n\t\tstruct commit *c = lookup_commit(&graft->oid);\n\t\tif (!c || !(c->object.flags & SEEN)) {\n\t\t\tif (data->flags & VERBOSE)\n\t\t\t\tprintf(\"Removing %s from .git/shallow\\n\",\n\t\t\t\t       oid_to_hex(&c->object.oid));\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdata->count++;\n\tif (data->use_pack_protocol)\n\t\tpacket_buf_write(data->out, \"shallow %s\", hex);\n\telse {\n\t\tstrbuf_addstr(data->out, hex);\n\t\tstrbuf_addch(data->out, '\\n');\n\t}\n\treturn 0;\n}\n\nstatic int write_shallow_commits_1(struct strbuf *out, int use_pack_protocol,\n\t\t\t\t   const struct oid_array *extra,\n\t\t\t\t   unsigned flags)\n{\n\tstruct write_shallow_data data;\n\tint i;\n\tdata.out = out;\n\tdata.use_pack_protocol = use_pack_protocol;\n\tdata.count = 0;\n\tdata.flags = flags;\n\tfor_each_commit_graft(write_one_shallow, &data);\n\tif (!extra)\n\t\treturn data.count;\n\tfor (i = 0; i < extra->nr; i++) {\n\t\tstrbuf_addstr(out, oid_to_hex(extra->oid + i));\n\t\tstrbuf_addch(out, '\\n');\n\t\tdata.count++;\n\t}\n\treturn data.count;\n}\n\nint write_shallow_commits(struct strbuf *out, int use_pack_protocol,\n\t\t\t  const struct oid_array *extra)\n{\n\treturn write_shallow_commits_1(out, use_pack_protocol, extra, 0);\n}\n\nconst char *setup_temporary_shallow(const struct oid_array *extra)\n{\n\tstruct tempfile *temp;\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tif (write_shallow_commits(&sb, 0, extra)) {\n\t\ttemp = xmks_tempfile(git_path(\"shallow_XXXXXX\"));\n\n\t\tif (write_in_full(temp->fd, sb.buf, sb.len) < 0 ||\n\t\t    close_tempfile_gently(temp) < 0)\n\t\t\tdie_errno(\"failed to write to %s\",\n\t\t\t\t  get_tempfile_path(temp));\n\t\tstrbuf_release(&sb);\n\t\treturn get_tempfile_path(temp);\n\t}\n\t/*\n\t * is_repository_shallow() sees empty string as \"no shallow\n\t * file\".\n\t */\n\treturn \"\";\n}\n\nvoid setup_alternate_shallow(struct lock_file *shallow_lock,\n\t\t\t     const char **alternate_shallow_file,\n\t\t\t     const struct oid_array *extra)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tint fd;\n\n\tfd = hold_lock_file_for_update(shallow_lock, git_path_shallow(),\n\t\t\t\t       LOCK_DIE_ON_ERROR);\n\tcheck_shallow_file_for_update(the_repository);\n\tif (write_shallow_commits(&sb, 0, extra)) {\n\t\tif (write_in_full(fd, sb.buf, sb.len) < 0)\n\t\t\tdie_errno(\"failed to write to %s\",\n\t\t\t\t  get_lock_file_path(shallow_lock));\n\t\t*alternate_shallow_file = get_lock_file_path(shallow_lock);\n\t} else\n\t\t/*\n\t\t * is_repository_shallow() sees empty string as \"no\n\t\t * shallow file\".\n\t\t */\n\t\t*alternate_shallow_file = \"\";\n\tstrbuf_release(&sb);\n}\n\nstatic int advertise_shallow_grafts_cb(const struct commit_graft *graft, void *cb)\n{\n\tint fd = *(int *)cb;\n\tif (graft->nr_parent == -1)\n\t\tpacket_write_fmt(fd, \"shallow %s\\n\", oid_to_hex(&graft->oid));\n\treturn 0;\n}\n\nvoid advertise_shallow_grafts(int fd)\n{\n\tif (!is_repository_shallow())\n\t\treturn;\n\tfor_each_commit_graft(advertise_shallow_grafts_cb, &fd);\n}\n\n/*\n * mark_reachable_objects() should have been run prior to this and all\n * reachable commits marked as \"SEEN\".\n */\nvoid prune_shallow(int show_only)\n{\n\tstatic struct lock_file shallow_lock;\n\tstruct strbuf sb = STRBUF_INIT;\n\tint fd;\n\n\tif (show_only) {\n\t\twrite_shallow_commits_1(&sb, 0, NULL, SEEN_ONLY | VERBOSE);\n\t\tstrbuf_release(&sb);\n\t\treturn;\n\t}\n\tfd = hold_lock_file_for_update(&shallow_lock, git_path_shallow(),\n\t\t\t\t       LOCK_DIE_ON_ERROR);\n\tcheck_shallow_file_for_update(the_repository);\n\tif (write_shallow_commits_1(&sb, 0, NULL, SEEN_ONLY)) {\n\t\tif (write_in_full(fd, sb.buf, sb.len) < 0)\n\t\t\tdie_errno(\"failed to write to %s\",\n\t\t\t\t  get_lock_file_path(&shallow_lock));\n\t\tcommit_lock_file(&shallow_lock);\n\t} else {\n\t\tunlink(git_path_shallow());\n\t\trollback_lock_file(&shallow_lock);\n\t}\n\tstrbuf_release(&sb);\n}\n\nstruct trace_key trace_shallow = TRACE_KEY_INIT(SHALLOW);\n\n/*\n * Step 1, split sender shallow commits into \"ours\" and \"theirs\"\n * Step 2, clean \"ours\" based on .git/shallow\n */\nvoid prepare_shallow_info(struct shallow_info *info, struct oid_array *sa)\n{\n\tint i;\n\ttrace_printf_key(&trace_shallow, \"shallow: prepare_shallow_info\\n\");\n\tmemset(info, 0, sizeof(*info));\n\tinfo->shallow = sa;\n\tif (!sa)\n\t\treturn;\n\tALLOC_ARRAY(info->ours, sa->nr);\n\tALLOC_ARRAY(info->theirs, sa->nr);\n\tfor (i = 0; i < sa->nr; i++) {\n\t\tif (has_object_file(sa->oid + i)) {\n\t\t\tstruct commit_graft *graft;\n\t\t\tgraft = lookup_commit_graft(the_repository,\n\t\t\t\t\t\t    &sa->oid[i]);\n\t\t\tif (graft && graft->nr_parent < 0)\n\t\t\t\tcontinue;\n\t\t\tinfo->ours[info->nr_ours++] = i;\n\t\t} else\n\t\t\tinfo->theirs[info->nr_theirs++] = i;\n\t}\n}\n\nvoid clear_shallow_info(struct shallow_info *info)\n{\n\tfree(info->ours);\n\tfree(info->theirs);\n}\n\n/* Step 4, remove non-existent ones in \"theirs\" after getting the pack */\n\nvoid remove_nonexistent_theirs_shallow(struct shallow_info *info)\n{\n\tstruct object_id *oid = info->shallow->oid;\n\tint i, dst;\n\ttrace_printf_key(&trace_shallow, \"shallow: remove_nonexistent_theirs_shallow\\n\");\n\tfor (i = dst = 0; i < info->nr_theirs; i++) {\n\t\tif (i != dst)\n\t\t\tinfo->theirs[dst] = info->theirs[i];\n\t\tif (has_object_file(oid + info->theirs[i]))\n\t\t\tdst++;\n\t}\n\tinfo->nr_theirs = dst;\n}\n\ndefine_commit_slab(ref_bitmap, uint32_t *);\n\n#define POOL_SIZE (512 * 1024)\n\nstruct paint_info {\n\tstruct ref_bitmap ref_bitmap;\n\tunsigned nr_bits;\n\tchar **pools;\n\tchar *free, *end;\n\tunsigned pool_count;\n};\n\nstatic uint32_t *paint_alloc(struct paint_info *info)\n{\n\tunsigned nr = DIV_ROUND_UP(info->nr_bits, 32);\n\tunsigned size = nr * sizeof(uint32_t);\n\tvoid *p;\n\tif (!info->pool_count || size > info->end - info->free) {\n\t\tif (size > POOL_SIZE)\n\t\t\tdie(\"BUG: pool size too small for %d in paint_alloc()\",\n\t\t\t    size);\n\t\tinfo->pool_count++;\n\t\tREALLOC_ARRAY(info->pools, info->pool_count);\n\t\tinfo->free = xmalloc(POOL_SIZE);\n\t\tinfo->pools[info->pool_count - 1] = info->free;\n\t\tinfo->end = info->free + POOL_SIZE;\n\t}\n\tp = info->free;\n\tinfo->free += size;\n\treturn p;\n}\n\n/*\n * Given a commit SHA-1, walk down to parents until either SEEN,\n * UNINTERESTING or BOTTOM is hit. Set the id-th bit in ref_bitmap for\n * all walked commits.\n */\nstatic void paint_down(struct paint_info *info, const struct object_id *oid,\n\t\t       unsigned int id)\n{\n\tunsigned int i, nr;\n\tstruct commit_list *head = NULL;\n\tint bitmap_nr = DIV_ROUND_UP(info->nr_bits, 32);\n\tsize_t bitmap_size = st_mult(sizeof(uint32_t), bitmap_nr);\n\tstruct commit *c = lookup_commit_reference_gently(oid, 1);\n\tuint32_t *tmp; /* to be freed before return */\n\tuint32_t *bitmap;\n\n\tif (!c)\n\t\treturn;\n\n\ttmp = xmalloc(bitmap_size);\n\tbitmap = paint_alloc(info);\n\tmemset(bitmap, 0, bitmap_size);\n\tbitmap[id / 32] |= (1U << (id % 32));\n\tcommit_list_insert(c, &head);\n\twhile (head) {\n\t\tstruct commit_list *p;\n\t\tstruct commit *c = pop_commit(&head);\n\t\tuint32_t **refs = ref_bitmap_at(&info->ref_bitmap, c);\n\n\t\t/* XXX check \"UNINTERESTING\" from pack bitmaps if available */\n\t\tif (c->object.flags & (SEEN | UNINTERESTING))\n\t\t\tcontinue;\n\t\telse\n\t\t\tc->object.flags |= SEEN;\n\n\t\tif (*refs == NULL)\n\t\t\t*refs = bitmap;\n\t\telse {\n\t\t\tmemcpy(tmp, *refs, bitmap_size);\n\t\t\tfor (i = 0; i < bitmap_nr; i++)\n\t\t\t\ttmp[i] |= bitmap[i];\n\t\t\tif (memcmp(tmp, *refs, bitmap_size)) {\n\t\t\t\t*refs = paint_alloc(info);\n\t\t\t\tmemcpy(*refs, tmp, bitmap_size);\n\t\t\t}\n\t\t}\n\n\t\tif (c->object.flags & BOTTOM)\n\t\t\tcontinue;\n\n\t\tif (parse_commit(c))\n\t\t\tdie(\"unable to parse commit %s\",\n\t\t\t    oid_to_hex(&c->object.oid));\n\n\t\tfor (p = c->parents; p; p = p->next) {\n\t\t\tif (p->item->object.flags & SEEN)\n\t\t\t\tcontinue;\n\t\t\tcommit_list_insert(p->item, &head);\n\t\t}\n\t}\n\n\tnr = get_max_object_index();\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct object *o = get_indexed_object(i);\n\t\tif (o && o->type == OBJ_COMMIT)\n\t\t\to->flags &= ~SEEN;\n\t}\n\n\tfree(tmp);\n}\n\nstatic int mark_uninteresting(const char *refname, const struct object_id *oid,\n\t\t\t      int flags, void *cb_data)\n{\n\tstruct commit *commit = lookup_commit_reference_gently(oid, 1);\n\tif (!commit)\n\t\treturn 0;\n\tcommit->object.flags |= UNINTERESTING;\n\tmark_parents_uninteresting(commit);\n\treturn 0;\n}\n\nstatic void post_assign_shallow(struct shallow_info *info,\n\t\t\t\tstruct ref_bitmap *ref_bitmap,\n\t\t\t\tint *ref_status);\n/*\n * Step 6(+7), associate shallow commits with new refs\n *\n * info->ref must be initialized before calling this function.\n *\n * If used is not NULL, it's an array of info->shallow->nr\n * bitmaps. The n-th bit set in the m-th bitmap if ref[n] needs the\n * m-th shallow commit from info->shallow.\n *\n * If used is NULL, \"ours\" and \"theirs\" are updated. And if ref_status\n * is not NULL it's an array of ref->nr ints. ref_status[i] is true if\n * the ref needs some shallow commits from either info->ours or\n * info->theirs.\n */\nvoid assign_shallow_commits_to_refs(struct shallow_info *info,\n\t\t\t\t    uint32_t **used, int *ref_status)\n{\n\tstruct object_id *oid = info->shallow->oid;\n\tstruct oid_array *ref = info->ref;\n\tunsigned int i, nr;\n\tint *shallow, nr_shallow = 0;\n\tstruct paint_info pi;\n\n\ttrace_printf_key(&trace_shallow, \"shallow: assign_shallow_commits_to_refs\\n\");\n\tALLOC_ARRAY(shallow, info->nr_ours + info->nr_theirs);\n\tfor (i = 0; i < info->nr_ours; i++)\n\t\tshallow[nr_shallow++] = info->ours[i];\n\tfor (i = 0; i < info->nr_theirs; i++)\n\t\tshallow[nr_shallow++] = info->theirs[i];\n\n\t/*\n\t * Prepare the commit graph to track what refs can reach what\n\t * (new) shallow commits.\n\t */\n\tnr = get_max_object_index();\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct object *o = get_indexed_object(i);\n\t\tif (!o || o->type != OBJ_COMMIT)\n\t\t\tcontinue;\n\n\t\to->flags &= ~(UNINTERESTING | BOTTOM | SEEN);\n\t}\n\n\tmemset(&pi, 0, sizeof(pi));\n\tinit_ref_bitmap(&pi.ref_bitmap);\n\tpi.nr_bits = ref->nr;\n\n\t/*\n\t * \"--not --all\" to cut short the traversal if new refs\n\t * connect to old refs. If not (e.g. force ref updates) it'll\n\t * have to go down to the current shallow commits.\n\t */\n\thead_ref(mark_uninteresting, NULL);\n\tfor_each_ref(mark_uninteresting, NULL);\n\n\t/* Mark potential bottoms so we won't go out of bound */\n\tfor (i = 0; i < nr_shallow; i++) {\n\t\tstruct commit *c = lookup_commit(&oid[shallow[i]]);\n\t\tc->object.flags |= BOTTOM;\n\t}\n\n\tfor (i = 0; i < ref->nr; i++)\n\t\tpaint_down(&pi, ref->oid + i, i);\n\n\tif (used) {\n\t\tint bitmap_size = DIV_ROUND_UP(pi.nr_bits, 32) * sizeof(uint32_t);\n\t\tmemset(used, 0, sizeof(*used) * info->shallow->nr);\n\t\tfor (i = 0; i < nr_shallow; i++) {\n\t\t\tconst struct commit *c = lookup_commit(&oid[shallow[i]]);\n\t\t\tuint32_t **map = ref_bitmap_at(&pi.ref_bitmap, c);\n\t\t\tif (*map)\n\t\t\t\tused[shallow[i]] = xmemdupz(*map, bitmap_size);\n\t\t}\n\t\t/*\n\t\t * unreachable shallow commits are not removed from\n\t\t * \"ours\" and \"theirs\". The user is supposed to run\n\t\t * step 7 on every ref separately and not trust \"ours\"\n\t\t * and \"theirs\" any more.\n\t\t */\n\t} else\n\t\tpost_assign_shallow(info, &pi.ref_bitmap, ref_status);\n\n\tclear_ref_bitmap(&pi.ref_bitmap);\n\tfor (i = 0; i < pi.pool_count; i++)\n\t\tfree(pi.pools[i]);\n\tfree(pi.pools);\n\tfree(shallow);\n}\n\nstruct commit_array {\n\tstruct commit **commits;\n\tint nr, alloc;\n};\n\nstatic int add_ref(const char *refname, const struct object_id *oid,\n\t\t   int flags, void *cb_data)\n{\n\tstruct commit_array *ca = cb_data;\n\tALLOC_GROW(ca->commits, ca->nr + 1, ca->alloc);\n\tca->commits[ca->nr] = lookup_commit_reference_gently(oid, 1);\n\tif (ca->commits[ca->nr])\n\t\tca->nr++;\n\treturn 0;\n}\n\nstatic void update_refstatus(int *ref_status, int nr, uint32_t *bitmap)\n{\n\tunsigned int i;\n\tif (!ref_status)\n\t\treturn;\n\tfor (i = 0; i < nr; i++)\n\t\tif (bitmap[i / 32] & (1U << (i % 32)))\n\t\t\tref_status[i]++;\n}\n\n/*\n * Step 7, reachability test on \"ours\" at commit level\n */\nstatic void post_assign_shallow(struct shallow_info *info,\n\t\t\t\tstruct ref_bitmap *ref_bitmap,\n\t\t\t\tint *ref_status)\n{\n\tstruct object_id *oid = info->shallow->oid;\n\tstruct commit *c;\n\tuint32_t **bitmap;\n\tint dst, i, j;\n\tint bitmap_nr = DIV_ROUND_UP(info->ref->nr, 32);\n\tstruct commit_array ca;\n\n\ttrace_printf_key(&trace_shallow, \"shallow: post_assign_shallow\\n\");\n\tif (ref_status)\n\t\tmemset(ref_status, 0, sizeof(*ref_status) * info->ref->nr);\n\n\t/* Remove unreachable shallow commits from \"theirs\" */\n\tfor (i = dst = 0; i < info->nr_theirs; i++) {\n\t\tif (i != dst)\n\t\t\tinfo->theirs[dst] = info->theirs[i];\n\t\tc = lookup_commit(&oid[info->theirs[i]]);\n\t\tbitmap = ref_bitmap_at(ref_bitmap, c);\n\t\tif (!*bitmap)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < bitmap_nr; j++)\n\t\t\tif (bitmap[0][j]) {\n\t\t\t\tupdate_refstatus(ref_status, info->ref->nr, *bitmap);\n\t\t\t\tdst++;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tinfo->nr_theirs = dst;\n\n\tmemset(&ca, 0, sizeof(ca));\n\thead_ref(add_ref, &ca);\n\tfor_each_ref(add_ref, &ca);\n\n\t/* Remove unreachable shallow commits from \"ours\" */\n\tfor (i = dst = 0; i < info->nr_ours; i++) {\n\t\tif (i != dst)\n\t\t\tinfo->ours[dst] = info->ours[i];\n\t\tc = lookup_commit(&oid[info->ours[i]]);\n\t\tbitmap = ref_bitmap_at(ref_bitmap, c);\n\t\tif (!*bitmap)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < bitmap_nr; j++)\n\t\t\tif (bitmap[0][j] &&\n\t\t\t    /* Step 7, reachability test at commit level */\n\t\t\t    !in_merge_bases_many(c, ca.nr, ca.commits)) {\n\t\t\t\tupdate_refstatus(ref_status, info->ref->nr, *bitmap);\n\t\t\t\tdst++;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tinfo->nr_ours = dst;\n\n\tfree(ca.commits);\n}\n\n/* (Delayed) step 7, reachability test at commit level */\nint delayed_reachability_test(struct shallow_info *si, int c)\n{\n\tif (si->need_reachability_test[c]) {\n\t\tstruct commit *commit = lookup_commit(&si->shallow->oid[c]);\n\n\t\tif (!si->commits) {\n\t\t\tstruct commit_array ca;\n\n\t\t\tmemset(&ca, 0, sizeof(ca));\n\t\t\thead_ref(add_ref, &ca);\n\t\t\tfor_each_ref(add_ref, &ca);\n\t\t\tsi->commits = ca.commits;\n\t\t\tsi->nr_commits = ca.nr;\n\t\t}\n\n\t\tsi->reachable[c] = in_merge_bases_many(commit,\n\t\t\t\t\t\t       si->nr_commits,\n\t\t\t\t\t\t       si->commits);\n\t\tsi->need_reachability_test[c] = 0;\n\t}\n\treturn si->reachable[c];\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0028e4ea7764cbdb21efda855274003f51a4b156",
  "sha1_ok": true,
  "size": 20035
}
