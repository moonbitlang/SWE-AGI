{
  "content": {
    "base64": "I2RlZmluZSBOT19USEVfSU5ERVhfQ09NUEFUSUJJTElUWV9NQUNST1MKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImRpci5oIgojaW5jbHVkZSAidHJlZS5oIgojaW5jbHVkZSAidHJlZS13YWxrLmgiCiNpbmNsdWRlICJjYWNoZS10cmVlLmgiCiNpbmNsdWRlICJ1bnBhY2stdHJlZXMuaCIKI2luY2x1ZGUgInByb2dyZXNzLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJhdHRyLmgiCiNpbmNsdWRlICJzcGxpdC1pbmRleC5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJzdWJtb2R1bGUuaCIKI2luY2x1ZGUgInN1Ym1vZHVsZS1jb25maWcuaCIKCi8qCiAqIEVycm9yIG1lc3NhZ2VzIGV4cGVjdGVkIGJ5IHNjcmlwdHMgb3V0IG9mIHBsdW1iaW5nIGNvbW1hbmRzIHN1Y2ggYXMKICogcmVhZC10cmVlLiAgTm9uLXNjcmlwdGVkIFBvcmNlbGFpbiBpcyBub3QgcmVxdWlyZWQgdG8gdXNlIHRoZXNlIG1lc3NhZ2VzCiAqIGFuZCBpbiBmYWN0IGFyZSBlbmNvdXJhZ2VkIHRvIHJld29yZCB0aGVtIHRvIGJldHRlciBzdWl0IHRoZWlyIHBhcnRpY3VsYXIKICogc2l0dWF0aW9uIGJldHRlci4gIFNlZSBob3cgImdpdCBjaGVja291dCIgYW5kICJnaXQgbWVyZ2UiIHJlcGxhY2VzCiAqIHRoZW0gdXNpbmcgc2V0dXBfdW5wYWNrX3RyZWVzX3BvcmNlbGFpbigpLCBmb3IgZXhhbXBsZS4KICovCnN0YXRpYyBjb25zdCBjaGFyICp1bnBhY2tfcGx1bWJpbmdfZXJyb3JzW05CX1VOUEFDS19UUkVFU19FUlJPUl9UWVBFU10gPSB7CgkvKiBFUlJPUl9XT1VMRF9PVkVSV1JJVEUgKi8KCSJFbnRyeSAnJXMnIHdvdWxkIGJlIG92ZXJ3cml0dGVuIGJ5IG1lcmdlLiBDYW5ub3QgbWVyZ2UuIiwKCgkvKiBFUlJPUl9OT1RfVVBUT0RBVEVfRklMRSAqLwoJIkVudHJ5ICclcycgbm90IHVwdG9kYXRlLiBDYW5ub3QgbWVyZ2UuIiwKCgkvKiBFUlJPUl9OT1RfVVBUT0RBVEVfRElSICovCgkiVXBkYXRpbmcgJyVzJyB3b3VsZCBsb3NlIHVudHJhY2tlZCBmaWxlcyBpbiBpdCIsCgoJLyogRVJST1JfV09VTERfTE9TRV9VTlRSQUNLRURfT1ZFUldSSVRURU4gKi8KCSJVbnRyYWNrZWQgd29ya2luZyB0cmVlIGZpbGUgJyVzJyB3b3VsZCBiZSBvdmVyd3JpdHRlbiBieSBtZXJnZS4iLAoKCS8qIEVSUk9SX1dPVUxEX0xPU0VfVU5UUkFDS0VEX1JFTU9WRUQgKi8KCSJVbnRyYWNrZWQgd29ya2luZyB0cmVlIGZpbGUgJyVzJyB3b3VsZCBiZSByZW1vdmVkIGJ5IG1lcmdlLiIsCgoJLyogRVJST1JfQklORF9PVkVSTEFQICovCgkiRW50cnkgJyVzJyBvdmVybGFwcyB3aXRoICclcycuICBDYW5ub3QgYmluZC4iLAoKCS8qIEVSUk9SX1NQQVJTRV9OT1RfVVBUT0RBVEVfRklMRSAqLwoJIkVudHJ5ICclcycgbm90IHVwdG9kYXRlLiBDYW5ub3QgdXBkYXRlIHNwYXJzZSBjaGVja291dC4iLAoKCS8qIEVSUk9SX1dPVUxEX0xPU0VfT1JQSEFORURfT1ZFUldSSVRURU4gKi8KCSJXb3JraW5nIHRyZWUgZmlsZSAnJXMnIHdvdWxkIGJlIG92ZXJ3cml0dGVuIGJ5IHNwYXJzZSBjaGVja291dCB1cGRhdGUuIiwKCgkvKiBFUlJPUl9XT1VMRF9MT1NFX09SUEhBTkVEX1JFTU9WRUQgKi8KCSJXb3JraW5nIHRyZWUgZmlsZSAnJXMnIHdvdWxkIGJlIHJlbW92ZWQgYnkgc3BhcnNlIGNoZWNrb3V0IHVwZGF0ZS4iLAoKCS8qIEVSUk9SX1dPVUxEX0xPU0VfU1VCTU9EVUxFICovCgkiU3VibW9kdWxlICclcycgY2Fubm90IGNoZWNrb3V0IG5ldyBIRUFELiIsCn07CgojZGVmaW5lIEVSUk9STVNHKG8sdHlwZSkgXAoJKCAoKG8pICYmIChvKS0+bXNnc1sodHlwZSldKSBcCgkgID8gKChvKS0+bXNnc1sodHlwZSldKSAgICAgIFwKCSAgOiAodW5wYWNrX3BsdW1iaW5nX2Vycm9yc1sodHlwZSldKSApCgpzdGF0aWMgY29uc3QgY2hhciAqc3VwZXJfcHJlZml4ZWQoY29uc3QgY2hhciAqcGF0aCkKewoJLyoKCSAqIEl0IGlzIG5lY2Vzc2FyeSBhbmQgc3VmZmljaWVudCB0byBoYXZlIHR3byBzdGF0aWMgYnVmZmVycwoJICogaGVyZSwgYXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIGZlZCB0bwoJICogZXJyb3IoKSB1c2luZyB0aGUgdW5wYWNrXypfZXJyb3JzW10gdGVtcGxhdGVzIHdlIHNlZSBhYm92ZS4KCSAqLwoJc3RhdGljIHN0cnVjdCBzdHJidWYgYnVmWzJdID0ge1NUUkJVRl9JTklULCBTVFJCVUZfSU5JVH07CglzdGF0aWMgaW50IHN1cGVyX3ByZWZpeF9sZW4gPSAtMTsKCXN0YXRpYyB1bnNpZ25lZCBpZHggPSBBUlJBWV9TSVpFKGJ1ZikgLSAxOwoKCWlmIChzdXBlcl9wcmVmaXhfbGVuIDwgMCkgewoJCWNvbnN0IGNoYXIgKnN1cGVyX3ByZWZpeCA9IGdldF9zdXBlcl9wcmVmaXgoKTsKCQlpZiAoIXN1cGVyX3ByZWZpeCkgewoJCQlzdXBlcl9wcmVmaXhfbGVuID0gMDsKCQl9IGVsc2UgewoJCQlpbnQgaTsKCQkJZm9yIChpID0gMDsgaSA8IEFSUkFZX1NJWkUoYnVmKTsgaSsrKQoJCQkJc3RyYnVmX2FkZHN0cigmYnVmW2ldLCBzdXBlcl9wcmVmaXgpOwoJCQlzdXBlcl9wcmVmaXhfbGVuID0gYnVmWzBdLmxlbjsKCQl9Cgl9CgoJaWYgKCFzdXBlcl9wcmVmaXhfbGVuKQoJCXJldHVybiBwYXRoOwoKCWlmICgrK2lkeCA+PSBBUlJBWV9TSVpFKGJ1ZikpCgkJaWR4ID0gMDsKCglzdHJidWZfc2V0bGVuKCZidWZbaWR4XSwgc3VwZXJfcHJlZml4X2xlbik7CglzdHJidWZfYWRkc3RyKCZidWZbaWR4XSwgcGF0aCk7CgoJcmV0dXJuIGJ1ZltpZHhdLmJ1ZjsKfQoKdm9pZCBzZXR1cF91bnBhY2tfdHJlZXNfcG9yY2VsYWluKHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqb3B0cywKCQkJCSAgY29uc3QgY2hhciAqY21kKQp7CglpbnQgaTsKCWNvbnN0IGNoYXIgKiptc2dzID0gb3B0cy0+bXNnczsKCWNvbnN0IGNoYXIgKm1zZzsKCglpZiAoIXN0cmNtcChjbWQsICJjaGVja291dCIpKQoJCW1zZyA9IGFkdmljZV9jb21taXRfYmVmb3JlX21lcmdlCgkJICAgICAgPyBfKCJZb3VyIGxvY2FsIGNoYW5nZXMgdG8gdGhlIGZvbGxvd2luZyBmaWxlcyB3b3VsZCBiZSBvdmVyd3JpdHRlbiBieSBjaGVja291dDpcbiUlcyIKCQkJICAiUGxlYXNlIGNvbW1pdCB5b3VyIGNoYW5nZXMgb3Igc3Rhc2ggdGhlbSBiZWZvcmUgeW91IHN3aXRjaCBicmFuY2hlcy4iKQoJCSAgICAgIDogXygiWW91ciBsb2NhbCBjaGFuZ2VzIHRvIHRoZSBmb2xsb3dpbmcgZmlsZXMgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgY2hlY2tvdXQ6XG4lJXMiKTsKCWVsc2UgaWYgKCFzdHJjbXAoY21kLCAibWVyZ2UiKSkKCQltc2cgPSBhZHZpY2VfY29tbWl0X2JlZm9yZV9tZXJnZQoJCSAgICAgID8gXygiWW91ciBsb2NhbCBjaGFuZ2VzIHRvIHRoZSBmb2xsb3dpbmcgZmlsZXMgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgbWVyZ2U6XG4lJXMiCgkJCSAgIlBsZWFzZSBjb21taXQgeW91ciBjaGFuZ2VzIG9yIHN0YXNoIHRoZW0gYmVmb3JlIHlvdSBtZXJnZS4iKQoJCSAgICAgIDogXygiWW91ciBsb2NhbCBjaGFuZ2VzIHRvIHRoZSBmb2xsb3dpbmcgZmlsZXMgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgbWVyZ2U6XG4lJXMiKTsKCWVsc2UKCQltc2cgPSBhZHZpY2VfY29tbWl0X2JlZm9yZV9tZXJnZQoJCSAgICAgID8gXygiWW91ciBsb2NhbCBjaGFuZ2VzIHRvIHRoZSBmb2xsb3dpbmcgZmlsZXMgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgJXM6XG4lJXMiCgkJCSAgIlBsZWFzZSBjb21taXQgeW91ciBjaGFuZ2VzIG9yIHN0YXNoIHRoZW0gYmVmb3JlIHlvdSAlcy4iKQoJCSAgICAgIDogXygiWW91ciBsb2NhbCBjaGFuZ2VzIHRvIHRoZSBmb2xsb3dpbmcgZmlsZXMgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgJXM6XG4lJXMiKTsKCW1zZ3NbRVJST1JfV09VTERfT1ZFUldSSVRFXSA9IG1zZ3NbRVJST1JfTk9UX1VQVE9EQVRFX0ZJTEVdID0KCQl4c3RyZm10KG1zZywgY21kLCBjbWQpOwoKCW1zZ3NbRVJST1JfTk9UX1VQVE9EQVRFX0RJUl0gPQoJCV8oIlVwZGF0aW5nIHRoZSBmb2xsb3dpbmcgZGlyZWN0b3JpZXMgd291bGQgbG9zZSB1bnRyYWNrZWQgZmlsZXMgaW4gdGhlbTpcbiVzIik7CgoJaWYgKCFzdHJjbXAoY21kLCAiY2hlY2tvdXQiKSkKCQltc2cgPSBhZHZpY2VfY29tbWl0X2JlZm9yZV9tZXJnZQoJCSAgICAgID8gXygiVGhlIGZvbGxvd2luZyB1bnRyYWNrZWQgd29ya2luZyB0cmVlIGZpbGVzIHdvdWxkIGJlIHJlbW92ZWQgYnkgY2hlY2tvdXQ6XG4lJXMiCgkJCSAgIlBsZWFzZSBtb3ZlIG9yIHJlbW92ZSB0aGVtIGJlZm9yZSB5b3Ugc3dpdGNoIGJyYW5jaGVzLiIpCgkJICAgICAgOiBfKCJUaGUgZm9sbG93aW5nIHVudHJhY2tlZCB3b3JraW5nIHRyZWUgZmlsZXMgd291bGQgYmUgcmVtb3ZlZCBieSBjaGVja291dDpcbiUlcyIpOwoJZWxzZSBpZiAoIXN0cmNtcChjbWQsICJtZXJnZSIpKQoJCW1zZyA9IGFkdmljZV9jb21taXRfYmVmb3JlX21lcmdlCgkJICAgICAgPyBfKCJUaGUgZm9sbG93aW5nIHVudHJhY2tlZCB3b3JraW5nIHRyZWUgZmlsZXMgd291bGQgYmUgcmVtb3ZlZCBieSBtZXJnZTpcbiUlcyIKCQkJICAiUGxlYXNlIG1vdmUgb3IgcmVtb3ZlIHRoZW0gYmVmb3JlIHlvdSBtZXJnZS4iKQoJCSAgICAgIDogXygiVGhlIGZvbGxvd2luZyB1bnRyYWNrZWQgd29ya2luZyB0cmVlIGZpbGVzIHdvdWxkIGJlIHJlbW92ZWQgYnkgbWVyZ2U6XG4lJXMiKTsKCWVsc2UKCQltc2cgPSBhZHZpY2VfY29tbWl0X2JlZm9yZV9tZXJnZQoJCSAgICAgID8gXygiVGhlIGZvbGxvd2luZyB1bnRyYWNrZWQgd29ya2luZyB0cmVlIGZpbGVzIHdvdWxkIGJlIHJlbW92ZWQgYnkgJXM6XG4lJXMiCgkJCSAgIlBsZWFzZSBtb3ZlIG9yIHJlbW92ZSB0aGVtIGJlZm9yZSB5b3UgJXMuIikKCQkgICAgICA6IF8oIlRoZSBmb2xsb3dpbmcgdW50cmFja2VkIHdvcmtpbmcgdHJlZSBmaWxlcyB3b3VsZCBiZSByZW1vdmVkIGJ5ICVzOlxuJSVzIik7Cgltc2dzW0VSUk9SX1dPVUxEX0xPU0VfVU5UUkFDS0VEX1JFTU9WRURdID0geHN0cmZtdChtc2csIGNtZCwgY21kKTsKCglpZiAoIXN0cmNtcChjbWQsICJjaGVja291dCIpKQoJCW1zZyA9IGFkdmljZV9jb21taXRfYmVmb3JlX21lcmdlCgkJICAgICAgPyBfKCJUaGUgZm9sbG93aW5nIHVudHJhY2tlZCB3b3JraW5nIHRyZWUgZmlsZXMgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgY2hlY2tvdXQ6XG4lJXMiCgkJCSAgIlBsZWFzZSBtb3ZlIG9yIHJlbW92ZSB0aGVtIGJlZm9yZSB5b3Ugc3dpdGNoIGJyYW5jaGVzLiIpCgkJICAgICAgOiBfKCJUaGUgZm9sbG93aW5nIHVudHJhY2tlZCB3b3JraW5nIHRyZWUgZmlsZXMgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgY2hlY2tvdXQ6XG4lJXMiKTsKCWVsc2UgaWYgKCFzdHJjbXAoY21kLCAibWVyZ2UiKSkKCQltc2cgPSBhZHZpY2VfY29tbWl0X2JlZm9yZV9tZXJnZQoJCSAgICAgID8gXygiVGhlIGZvbGxvd2luZyB1bnRyYWNrZWQgd29ya2luZyB0cmVlIGZpbGVzIHdvdWxkIGJlIG92ZXJ3cml0dGVuIGJ5IG1lcmdlOlxuJSVzIgoJCQkgICJQbGVhc2UgbW92ZSBvciByZW1vdmUgdGhlbSBiZWZvcmUgeW91IG1lcmdlLiIpCgkJICAgICAgOiBfKCJUaGUgZm9sbG93aW5nIHVudHJhY2tlZCB3b3JraW5nIHRyZWUgZmlsZXMgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgbWVyZ2U6XG4lJXMiKTsKCWVsc2UKCQltc2cgPSBhZHZpY2VfY29tbWl0X2JlZm9yZV9tZXJnZQoJCSAgICAgID8gXygiVGhlIGZvbGxvd2luZyB1bnRyYWNrZWQgd29ya2luZyB0cmVlIGZpbGVzIHdvdWxkIGJlIG92ZXJ3cml0dGVuIGJ5ICVzOlxuJSVzIgoJCQkgICJQbGVhc2UgbW92ZSBvciByZW1vdmUgdGhlbSBiZWZvcmUgeW91ICVzLiIpCgkJICAgICAgOiBfKCJUaGUgZm9sbG93aW5nIHVudHJhY2tlZCB3b3JraW5nIHRyZWUgZmlsZXMgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgJXM6XG4lJXMiKTsKCW1zZ3NbRVJST1JfV09VTERfTE9TRV9VTlRSQUNLRURfT1ZFUldSSVRURU5dID0geHN0cmZtdChtc2csIGNtZCwgY21kKTsKCgkvKgoJICogU3BlY2lhbCBjYXNlOiBFUlJPUl9CSU5EX09WRVJMQVAgcmVmZXJzIHRvIGEgcGFpciBvZiBwYXRocywgd2UKCSAqIGNhbm5vdCBlYXNpbHkgZGlzcGxheSBpdCBhcyBhIGxpc3QuCgkgKi8KCW1zZ3NbRVJST1JfQklORF9PVkVSTEFQXSA9IF8oIkVudHJ5ICclcycgb3ZlcmxhcHMgd2l0aCAnJXMnLiAgQ2Fubm90IGJpbmQuIik7CgoJbXNnc1tFUlJPUl9TUEFSU0VfTk9UX1VQVE9EQVRFX0ZJTEVdID0KCQlfKCJDYW5ub3QgdXBkYXRlIHNwYXJzZSBjaGVja291dDogdGhlIGZvbGxvd2luZyBlbnRyaWVzIGFyZSBub3QgdXAtdG8tZGF0ZTpcbiVzIik7Cgltc2dzW0VSUk9SX1dPVUxEX0xPU0VfT1JQSEFORURfT1ZFUldSSVRURU5dID0KCQlfKCJUaGUgZm9sbG93aW5nIHdvcmtpbmcgdHJlZSBmaWxlcyB3b3VsZCBiZSBvdmVyd3JpdHRlbiBieSBzcGFyc2UgY2hlY2tvdXQgdXBkYXRlOlxuJXMiKTsKCW1zZ3NbRVJST1JfV09VTERfTE9TRV9PUlBIQU5FRF9SRU1PVkVEXSA9CgkJXygiVGhlIGZvbGxvd2luZyB3b3JraW5nIHRyZWUgZmlsZXMgd291bGQgYmUgcmVtb3ZlZCBieSBzcGFyc2UgY2hlY2tvdXQgdXBkYXRlOlxuJXMiKTsKCW1zZ3NbRVJST1JfV09VTERfTE9TRV9TVUJNT0RVTEVdID0KCQlfKCJDYW5ub3QgdXBkYXRlIHN1Ym1vZHVsZTpcbiVzIik7CgoJb3B0cy0+c2hvd19hbGxfZXJyb3JzID0gMTsKCS8qIHJlamVjdGVkIHBhdGhzIG1heSBub3QgaGF2ZSBhIHN0YXRpYyBidWZmZXIgKi8KCWZvciAoaSA9IDA7IGkgPCBBUlJBWV9TSVpFKG9wdHMtPnVucGFja19yZWplY3RzKTsgaSsrKQoJCW9wdHMtPnVucGFja19yZWplY3RzW2ldLnN0cmR1cF9zdHJpbmdzID0gMTsKfQoKc3RhdGljIGludCBkb19hZGRfZW50cnkoc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvLCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQkgdW5zaWduZWQgaW50IHNldCwgdW5zaWduZWQgaW50IGNsZWFyKQp7CgljbGVhciB8PSBDRV9IQVNIRUQ7CgoJaWYgKHNldCAmIENFX1JFTU9WRSkKCQlzZXQgfD0gQ0VfV1RfUkVNT1ZFOwoKCWNlLT5jZV9mbGFncyA9IChjZS0+Y2VfZmxhZ3MgJiB+Y2xlYXIpIHwgc2V0OwoJcmV0dXJuIGFkZF9pbmRleF9lbnRyeSgmby0+cmVzdWx0LCBjZSwKCQkJICAgICAgIEFERF9DQUNIRV9PS19UT19BREQgfCBBRERfQ0FDSEVfT0tfVE9fUkVQTEFDRSk7Cn0KCnN0YXRpYyBzdHJ1Y3QgY2FjaGVfZW50cnkgKmR1cF9lbnRyeShjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKQp7Cgl1bnNpZ25lZCBpbnQgc2l6ZSA9IGNlX3NpemUoY2UpOwoJc3RydWN0IGNhY2hlX2VudHJ5ICpuZXcgPSB4bWFsbG9jKHNpemUpOwoKCW1lbWNweShuZXcsIGNlLCBzaXplKTsKCXJldHVybiBuZXc7Cn0KCnN0YXRpYyB2b2lkIGFkZF9lbnRyeShzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8sCgkJICAgICAgY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwKCQkgICAgICB1bnNpZ25lZCBpbnQgc2V0LCB1bnNpZ25lZCBpbnQgY2xlYXIpCnsKCWRvX2FkZF9lbnRyeShvLCBkdXBfZW50cnkoY2UpLCBzZXQsIGNsZWFyKTsKfQoKLyoKICogYWRkIGVycm9yIG1lc3NhZ2VzIG9uIHBhdGggPHBhdGg+CiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHR5cGUgPGU+IHdpdGggdGhlIG1lc3NhZ2UgPG1zZz4KICogaW5kaWNhdGluZyBpZiBpdCBzaG91bGQgYmUgZGlzcGxheSBpbiBwb3JjZWxhaW4gb3Igbm90CiAqLwpzdGF0aWMgaW50IGFkZF9yZWplY3RlZF9wYXRoKHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbywKCQkJICAgICBlbnVtIHVucGFja190cmVlc19lcnJvcl90eXBlcyBlLAoJCQkgICAgIGNvbnN0IGNoYXIgKnBhdGgpCnsKCWlmICghby0+c2hvd19hbGxfZXJyb3JzKQoJCXJldHVybiBlcnJvcihFUlJPUk1TRyhvLCBlKSwgc3VwZXJfcHJlZml4ZWQocGF0aCkpOwoKCS8qCgkgKiBPdGhlcndpc2UsIGluc2VydCBpbiBhIGxpc3QgZm9yIGZ1dHVyZSBkaXNwbGF5IGJ5CgkgKiBkaXNwbGF5X2Vycm9yX21zZ3MoKQoJICovCglzdHJpbmdfbGlzdF9hcHBlbmQoJm8tPnVucGFja19yZWplY3RzW2VdLCBwYXRoKTsKCXJldHVybiAtMTsKfQoKLyoKICogZGlzcGxheSBhbGwgdGhlIGVycm9yIG1lc3NhZ2VzIHN0b3JlZCBpbiBhIG5pY2Ugd2F5CiAqLwpzdGF0aWMgdm9pZCBkaXNwbGF5X2Vycm9yX21zZ3Moc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7CglpbnQgZSwgaTsKCWludCBzb21ldGhpbmdfZGlzcGxheWVkID0gMDsKCWZvciAoZSA9IDA7IGUgPCBOQl9VTlBBQ0tfVFJFRVNfRVJST1JfVFlQRVM7IGUrKykgewoJCXN0cnVjdCBzdHJpbmdfbGlzdCAqcmVqZWN0cyA9ICZvLT51bnBhY2tfcmVqZWN0c1tlXTsKCQlpZiAocmVqZWN0cy0+bnIgPiAwKSB7CgkJCXN0cnVjdCBzdHJidWYgcGF0aCA9IFNUUkJVRl9JTklUOwoJCQlzb21ldGhpbmdfZGlzcGxheWVkID0gMTsKCQkJZm9yIChpID0gMDsgaSA8IHJlamVjdHMtPm5yOyBpKyspCgkJCQlzdHJidWZfYWRkZigmcGF0aCwgIlx0JXNcbiIsIHJlamVjdHMtPml0ZW1zW2ldLnN0cmluZyk7CgkJCWVycm9yKEVSUk9STVNHKG8sIGUpLCBzdXBlcl9wcmVmaXhlZChwYXRoLmJ1ZikpOwoJCQlzdHJidWZfcmVsZWFzZSgmcGF0aCk7CgkJfQoJCXN0cmluZ19saXN0X2NsZWFyKHJlamVjdHMsIDApOwoJfQoJaWYgKHNvbWV0aGluZ19kaXNwbGF5ZWQpCgkJZnByaW50ZihzdGRlcnIsIF8oIkFib3J0aW5nXG4iKSk7Cn0KCnN0YXRpYyBpbnQgY2hlY2tfc3VibW9kdWxlX21vdmVfaGVhZChjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQkJICAgICBjb25zdCBjaGFyICpvbGRfaWQsCgkJCQkgICAgIGNvbnN0IGNoYXIgKm5ld19pZCwKCQkJCSAgICAgc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7Cgl1bnNpZ25lZCBmbGFncyA9IFNVQk1PRFVMRV9NT1ZFX0hFQURfRFJZX1JVTjsKCWNvbnN0IHN0cnVjdCBzdWJtb2R1bGUgKnN1YiA9IHN1Ym1vZHVsZV9mcm9tX2NlKGNlKTsKCWlmICghc3ViKQoJCXJldHVybiAwOwoKCWlmIChvLT5yZXNldCkKCQlmbGFncyB8PSBTVUJNT0RVTEVfTU9WRV9IRUFEX0ZPUkNFOwoKCXN3aXRjaCAoc3ViLT51cGRhdGVfc3RyYXRlZ3kudHlwZSkgewoJY2FzZSBTTV9VUERBVEVfVU5TUEVDSUZJRUQ6CgljYXNlIFNNX1VQREFURV9DSEVDS09VVDoKCQlpZiAoc3VibW9kdWxlX21vdmVfaGVhZChjZS0+bmFtZSwgb2xkX2lkLCBuZXdfaWQsIGZsYWdzKSkKCQkJcmV0dXJuIG8tPmdlbnRseSA/IC0xIDoKCQkJCWFkZF9yZWplY3RlZF9wYXRoKG8sIEVSUk9SX1dPVUxEX0xPU0VfU1VCTU9EVUxFLCBjZS0+bmFtZSk7CgkJcmV0dXJuIDA7CgljYXNlIFNNX1VQREFURV9OT05FOgoJCXJldHVybiAwOwoJY2FzZSBTTV9VUERBVEVfUkVCQVNFOgoJY2FzZSBTTV9VUERBVEVfTUVSR0U6CgljYXNlIFNNX1VQREFURV9DT01NQU5EOgoJZGVmYXVsdDoKCQl3YXJuaW5nKF8oInN1Ym1vZHVsZSB1cGRhdGUgc3RyYXRlZ3kgbm90IHN1cHBvcnRlZCBmb3Igc3VibW9kdWxlICclcyciKSwgY2UtPm5hbWUpOwoJCXJldHVybiAtMTsKCX0KfQoKc3RhdGljIHZvaWQgcmVsb2FkX2dpdG1vZHVsZXNfZmlsZShzdHJ1Y3QgaW5kZXhfc3RhdGUgKmluZGV4LAoJCQkJICAgc3RydWN0IGNoZWNrb3V0ICpzdGF0ZSkKewoJaW50IGk7Cglmb3IgKGkgPSAwOyBpIDwgaW5kZXgtPmNhY2hlX25yOyBpKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gaW5kZXgtPmNhY2hlW2ldOwoJCWlmIChjZS0+Y2VfZmxhZ3MgJiBDRV9VUERBVEUpIHsKCQkJaW50IHIgPSBzdHJjbXAoY2UtPm5hbWUsIEdJVE1PRFVMRVNfRklMRSk7CgkJCWlmIChyIDwgMCkKCQkJCWNvbnRpbnVlOwoJCQllbHNlIGlmIChyID09IDApIHsKCQkJCXN1Ym1vZHVsZV9mcmVlKCk7CgkJCQljaGVja291dF9lbnRyeShjZSwgc3RhdGUsIE5VTEwpOwoJCQkJZ2l0bW9kdWxlc19jb25maWcoKTsKCQkJCWdpdF9jb25maWcoc3VibW9kdWxlX2NvbmZpZywgTlVMTCk7CgkJCX0gZWxzZQoJCQkJYnJlYWs7CgkJfQoJfQp9CgovKgogKiBVbmxpbmsgdGhlIGxhc3QgY29tcG9uZW50IGFuZCBzY2hlZHVsZSB0aGUgbGVhZGluZyBkaXJlY3RvcmllcyBmb3IKICogcmVtb3ZhbCwgc3VjaCB0aGF0IGVtcHR5IGRpcmVjdG9yaWVzIGdldCByZW1vdmVkLgogKi8Kc3RhdGljIHZvaWQgdW5saW5rX2VudHJ5KGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UpCnsKCWNvbnN0IHN0cnVjdCBzdWJtb2R1bGUgKnN1YiA9IHN1Ym1vZHVsZV9mcm9tX2NlKGNlKTsKCWlmIChzdWIpIHsKCQlzd2l0Y2ggKHN1Yi0+dXBkYXRlX3N0cmF0ZWd5LnR5cGUpIHsKCQljYXNlIFNNX1VQREFURV9VTlNQRUNJRklFRDoKCQljYXNlIFNNX1VQREFURV9DSEVDS09VVDoKCQljYXNlIFNNX1VQREFURV9SRUJBU0U6CgkJY2FzZSBTTV9VUERBVEVfTUVSR0U6CgkJCS8qIHN0YXRlLmZvcmNlIGlzIHNldCBhdCB0aGUgY2FsbGVyLiAqLwoJCQlzdWJtb2R1bGVfbW92ZV9oZWFkKGNlLT5uYW1lLCAiSEVBRCIsIE5VTEwsCgkJCQkJICAgIFNVQk1PRFVMRV9NT1ZFX0hFQURfRk9SQ0UpOwoJCQlicmVhazsKCQljYXNlIFNNX1VQREFURV9OT05FOgoJCWNhc2UgU01fVVBEQVRFX0NPTU1BTkQ6CgkJCXJldHVybjsgLyogRG8gbm90IHRvdWNoIHRoZSBzdWJtb2R1bGUuICovCgkJfQoJfQoJaWYgKCFjaGVja19sZWFkaW5nX3BhdGgoY2UtPm5hbWUsIGNlX25hbWVsZW4oY2UpKSkKCQlyZXR1cm47CglpZiAocmVtb3ZlX29yX3dhcm4oY2UtPmNlX21vZGUsIGNlLT5uYW1lKSkKCQlyZXR1cm47CglzY2hlZHVsZV9kaXJfZm9yX3JlbW92YWwoY2UtPm5hbWUsIGNlX25hbWVsZW4oY2UpKTsKfQoKc3RhdGljIHN0cnVjdCBwcm9ncmVzcyAqZ2V0X3Byb2dyZXNzKHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJdW5zaWduZWQgY250ID0gMCwgdG90YWwgPSAwOwoJc3RydWN0IGluZGV4X3N0YXRlICppbmRleCA9ICZvLT5yZXN1bHQ7CgoJaWYgKCFvLT51cGRhdGUgfHwgIW8tPnZlcmJvc2VfdXBkYXRlKQoJCXJldHVybiBOVUxMOwoKCWZvciAoOyBjbnQgPCBpbmRleC0+Y2FjaGVfbnI7IGNudCsrKSB7CgkJY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGluZGV4LT5jYWNoZVtjbnRdOwoJCWlmIChjZS0+Y2VfZmxhZ3MgJiAoQ0VfVVBEQVRFIHwgQ0VfV1RfUkVNT1ZFKSkKCQkJdG90YWwrKzsKCX0KCglyZXR1cm4gc3RhcnRfZGVsYXllZF9wcm9ncmVzcyhfKCJDaGVja2luZyBvdXQgZmlsZXMiKSwgdG90YWwpOwp9CgpzdGF0aWMgaW50IGNoZWNrX3VwZGF0ZXMoc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7Cgl1bnNpZ25lZCBjbnQgPSAwOwoJaW50IGVycnMgPSAwOwoJc3RydWN0IHByb2dyZXNzICpwcm9ncmVzcyA9IE5VTEw7CglzdHJ1Y3QgaW5kZXhfc3RhdGUgKmluZGV4ID0gJm8tPnJlc3VsdDsKCXN0cnVjdCBjaGVja291dCBzdGF0ZSA9IENIRUNLT1VUX0lOSVQ7CglpbnQgaTsKCglzdGF0ZS5mb3JjZSA9IDE7CglzdGF0ZS5xdWlldCA9IDE7CglzdGF0ZS5yZWZyZXNoX2NhY2hlID0gMTsKCXN0YXRlLmlzdGF0ZSA9IGluZGV4OwoKCXByb2dyZXNzID0gZ2V0X3Byb2dyZXNzKG8pOwoKCWlmIChvLT51cGRhdGUpCgkJZ2l0X2F0dHJfc2V0X2RpcmVjdGlvbihHSVRfQVRUUl9DSEVDS09VVCwgaW5kZXgpOwoJZm9yIChpID0gMDsgaSA8IGluZGV4LT5jYWNoZV9ucjsgaSsrKSB7CgkJY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGluZGV4LT5jYWNoZVtpXTsKCgkJaWYgKGNlLT5jZV9mbGFncyAmIENFX1dUX1JFTU9WRSkgewoJCQlkaXNwbGF5X3Byb2dyZXNzKHByb2dyZXNzLCArK2NudCk7CgkJCWlmIChvLT51cGRhdGUgJiYgIW8tPmRyeV9ydW4pCgkJCQl1bmxpbmtfZW50cnkoY2UpOwoJCX0KCX0KCXJlbW92ZV9tYXJrZWRfY2FjaGVfZW50cmllcyhpbmRleCk7CglyZW1vdmVfc2NoZWR1bGVkX2RpcnMoKTsKCglpZiAoc2hvdWxkX3VwZGF0ZV9zdWJtb2R1bGVzKCkgJiYgby0+dXBkYXRlICYmICFvLT5kcnlfcnVuKQoJCXJlbG9hZF9naXRtb2R1bGVzX2ZpbGUoaW5kZXgsICZzdGF0ZSk7CgoJZW5hYmxlX2RlbGF5ZWRfY2hlY2tvdXQoJnN0YXRlKTsKCWZvciAoaSA9IDA7IGkgPCBpbmRleC0+Y2FjaGVfbnI7IGkrKykgewoJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBpbmRleC0+Y2FjaGVbaV07CgoJCWlmIChjZS0+Y2VfZmxhZ3MgJiBDRV9VUERBVEUpIHsKCQkJaWYgKGNlLT5jZV9mbGFncyAmIENFX1dUX1JFTU9WRSkKCQkJCWRpZSgiQlVHOiBib3RoIHVwZGF0ZSBhbmQgZGVsZXRlIGZsYWdzIGFyZSBzZXQgb24gJXMiLAoJCQkJICAgIGNlLT5uYW1lKTsKCQkJZGlzcGxheV9wcm9ncmVzcyhwcm9ncmVzcywgKytjbnQpOwoJCQljZS0+Y2VfZmxhZ3MgJj0gfkNFX1VQREFURTsKCQkJaWYgKG8tPnVwZGF0ZSAmJiAhby0+ZHJ5X3J1bikgewoJCQkJZXJycyB8PSBjaGVja291dF9lbnRyeShjZSwgJnN0YXRlLCBOVUxMKTsKCQkJfQoJCX0KCX0KCXN0b3BfcHJvZ3Jlc3MoJnByb2dyZXNzKTsKCWVycnMgfD0gZmluaXNoX2RlbGF5ZWRfY2hlY2tvdXQoJnN0YXRlKTsKCWlmIChvLT51cGRhdGUpCgkJZ2l0X2F0dHJfc2V0X2RpcmVjdGlvbihHSVRfQVRUUl9DSEVDS0lOLCBOVUxMKTsKCXJldHVybiBlcnJzICE9IDA7Cn0KCnN0YXRpYyBpbnQgdmVyaWZ5X3VwdG9kYXRlX3NwYXJzZShjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQkJICBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pOwpzdGF0aWMgaW50IHZlcmlmeV9hYnNlbnRfc3BhcnNlKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCQllbnVtIHVucGFja190cmVlc19lcnJvcl90eXBlcywKCQkJCXN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbyk7CgpzdGF0aWMgaW50IGFwcGx5X3NwYXJzZV9jaGVja291dChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwKCQkJCSBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQkJIHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJaW50IHdhc19za2lwX3dvcmt0cmVlID0gY2Vfc2tpcF93b3JrdHJlZShjZSk7CgoJaWYgKGNlLT5jZV9mbGFncyAmIENFX05FV19TS0lQX1dPUktUUkVFKQoJCWNlLT5jZV9mbGFncyB8PSBDRV9TS0lQX1dPUktUUkVFOwoJZWxzZQoJCWNlLT5jZV9mbGFncyAmPSB+Q0VfU0tJUF9XT1JLVFJFRTsKCWlmICh3YXNfc2tpcF93b3JrdHJlZSAhPSBjZV9za2lwX3dvcmt0cmVlKGNlKSkgewoJCWNlLT5jZV9mbGFncyB8PSBDRV9VUERBVEVfSU5fQkFTRTsKCQlpc3RhdGUtPmNhY2hlX2NoYW5nZWQgfD0gQ0VfRU5UUllfQ0hBTkdFRDsKCX0KCgkvKgoJICogaWYgKCF3YXNfc2tpcF93b3JrdHJlZSAmJiAhY2Vfc2tpcF93b3JrdHJlZSgpKSB7CgkgKglUaGlzIGlzIHBlcmZlY3RseSBub3JtYWwuIE1vdmUgb247CgkgKiB9CgkgKi8KCgkvKgoJICogTWVyZ2Ugc3RyYXRlZ2llcyBtYXkgc2V0IENFX1VQREFURXxDRV9SRU1PVkUgb3V0c2lkZSBjaGVja291dAoJICogYXJlYSBhcyBhIHJlc3VsdCBvZiBjZV9za2lwX3dvcmt0cmVlKCkgc2hvcnRjdXRzIGluCgkgKiB2ZXJpZnlfYWJzZW50KCkgYW5kIHZlcmlmeV91cHRvZGF0ZSgpLgoJICogTWFrZSBzdXJlIHRoZXkgZG9uJ3QgbW9kaWZ5IHdvcmt0cmVlIGlmIHRoZXkgYXJlIGFscmVhZHkKCSAqIG91dHNpZGUgY2hlY2tvdXQgYXJlYQoJICovCglpZiAod2FzX3NraXBfd29ya3RyZWUgJiYgY2Vfc2tpcF93b3JrdHJlZShjZSkpIHsKCQljZS0+Y2VfZmxhZ3MgJj0gfkNFX1VQREFURTsKCgkJLyoKCQkgKiBCeSBkZWZhdWx0LCB3aGVuIENFX1JFTU9WRSBpcyBvbiwgQ0VfV1RfUkVNT1ZFIGlzIGFsc28KCQkgKiBvbiB0byBnZXQgdGhhdCBmaWxlIHJlbW92ZWQgZnJvbSBib3RoIGluZGV4IGFuZCB3b3JrdHJlZS4KCQkgKiBJZiB0aGF0IGZpbGUgaXMgYWxyZWFkeSBvdXRzaWRlIHdvcmt0cmVlIGFyZWEsIGRvbid0CgkJICogYm90aGVyIHJlbW92ZSBpdC4KCQkgKi8KCQlpZiAoY2UtPmNlX2ZsYWdzICYgQ0VfUkVNT1ZFKQoJCQljZS0+Y2VfZmxhZ3MgJj0gfkNFX1dUX1JFTU9WRTsKCX0KCglpZiAoIXdhc19za2lwX3dvcmt0cmVlICYmIGNlX3NraXBfd29ya3RyZWUoY2UpKSB7CgkJLyoKCQkgKiBJZiBDRV9VUERBVEUgaXMgc2V0LCB2ZXJpZnlfdXB0b2RhdGUoKSBtdXN0IGJlIGNhbGxlZCBhbHJlYWR5CgkJICogYWxzbyBzdGF0IGluZm8gbWF5IGhhdmUgbG9zdCBhZnRlciBtZXJnZWRfZW50cnkoKSBzbyBjYWxsaW5nCgkJICogdmVyaWZ5X3VwdG9kYXRlKCkgYWdhaW4gbWF5IGZhaWwKCQkgKi8KCQlpZiAoIShjZS0+Y2VfZmxhZ3MgJiBDRV9VUERBVEUpICYmIHZlcmlmeV91cHRvZGF0ZV9zcGFyc2UoY2UsIG8pKQoJCQlyZXR1cm4gLTE7CgkJY2UtPmNlX2ZsYWdzIHw9IENFX1dUX1JFTU9WRTsKCQljZS0+Y2VfZmxhZ3MgJj0gfkNFX1VQREFURTsKCX0KCWlmICh3YXNfc2tpcF93b3JrdHJlZSAmJiAhY2Vfc2tpcF93b3JrdHJlZShjZSkpIHsKCQlpZiAodmVyaWZ5X2Fic2VudF9zcGFyc2UoY2UsIEVSUk9SX1dPVUxEX0xPU0VfVU5UUkFDS0VEX09WRVJXUklUVEVOLCBvKSkKCQkJcmV0dXJuIC0xOwoJCWNlLT5jZV9mbGFncyB8PSBDRV9VUERBVEU7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGlubGluZSBpbnQgY2FsbF91bnBhY2tfZm4oY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICogY29uc3QgKnNyYywKCQkJCSBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCWludCByZXQgPSBvLT5mbihzcmMsIG8pOwoJaWYgKHJldCA+IDApCgkJcmV0ID0gMDsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyB2b2lkIG1hcmtfY2VfdXNlZChzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCWNlLT5jZV9mbGFncyB8PSBDRV9VTlBBQ0tFRDsKCglpZiAoby0+Y2FjaGVfYm90dG9tIDwgby0+c3JjX2luZGV4LT5jYWNoZV9uciAmJgoJICAgIG8tPnNyY19pbmRleC0+Y2FjaGVbby0+Y2FjaGVfYm90dG9tXSA9PSBjZSkgewoJCWludCBib3R0b20gPSBvLT5jYWNoZV9ib3R0b207CgkJd2hpbGUgKGJvdHRvbSA8IG8tPnNyY19pbmRleC0+Y2FjaGVfbnIgJiYKCQkgICAgICAgby0+c3JjX2luZGV4LT5jYWNoZVtib3R0b21dLT5jZV9mbGFncyAmIENFX1VOUEFDS0VEKQoJCQlib3R0b20rKzsKCQlvLT5jYWNoZV9ib3R0b20gPSBib3R0b207Cgl9Cn0KCnN0YXRpYyB2b2lkIG1hcmtfYWxsX2NlX3VudXNlZChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmluZGV4KQp7CglpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCBpbmRleC0+Y2FjaGVfbnI7IGkrKykKCQlpbmRleC0+Y2FjaGVbaV0tPmNlX2ZsYWdzICY9IH4oQ0VfVU5QQUNLRUQgfCBDRV9BRERFRCB8IENFX05FV19TS0lQX1dPUktUUkVFKTsKfQoKc3RhdGljIGludCBsb2NhdGVfaW5fc3JjX2luZGV4KGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCSAgICAgICBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCXN0cnVjdCBpbmRleF9zdGF0ZSAqaW5kZXggPSBvLT5zcmNfaW5kZXg7CglpbnQgbGVuID0gY2VfbmFtZWxlbihjZSk7CglpbnQgcG9zID0gaW5kZXhfbmFtZV9wb3MoaW5kZXgsIGNlLT5uYW1lLCBsZW4pOwoJaWYgKHBvcyA8IDApCgkJcG9zID0gLTEgLSBwb3M7CglyZXR1cm4gcG9zOwp9CgovKgogKiBXZSBjYWxsIHVucGFja19pbmRleF9lbnRyeSgpIHdpdGggYW4gdW5tZXJnZWQgY2FjaGUgZW50cnkKICogb25seSBpbiBkaWZmLWluZGV4LCBhbmQgaXQgd2FudHMgYSBzaW5nbGUgY2FsbGJhY2suICBTa2lwCiAqIHRoZSBvdGhlciB1bm1lcmdlZCBlbnRyeSB3aXRoIHRoZSBzYW1lIG5hbWUuCiAqLwpzdGF0aWMgdm9pZCBtYXJrX2NlX3VzZWRfc2FtZV9uYW1lKHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCQkgICBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCXN0cnVjdCBpbmRleF9zdGF0ZSAqaW5kZXggPSBvLT5zcmNfaW5kZXg7CglpbnQgbGVuID0gY2VfbmFtZWxlbihjZSk7CglpbnQgcG9zOwoKCWZvciAocG9zID0gbG9jYXRlX2luX3NyY19pbmRleChjZSwgbyk7IHBvcyA8IGluZGV4LT5jYWNoZV9ucjsgcG9zKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKm5leHQgPSBpbmRleC0+Y2FjaGVbcG9zXTsKCQlpZiAobGVuICE9IGNlX25hbWVsZW4obmV4dCkgfHwKCQkgICAgbWVtY21wKGNlLT5uYW1lLCBuZXh0LT5uYW1lLCBsZW4pKQoJCQlicmVhazsKCQltYXJrX2NlX3VzZWQobmV4dCwgbyk7Cgl9Cn0KCnN0YXRpYyBzdHJ1Y3QgY2FjaGVfZW50cnkgKm5leHRfY2FjaGVfZW50cnkoc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7Cgljb25zdCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKmluZGV4ID0gby0+c3JjX2luZGV4OwoJaW50IHBvcyA9IG8tPmNhY2hlX2JvdHRvbTsKCgl3aGlsZSAocG9zIDwgaW5kZXgtPmNhY2hlX25yKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGluZGV4LT5jYWNoZVtwb3NdOwoJCWlmICghKGNlLT5jZV9mbGFncyAmIENFX1VOUEFDS0VEKSkKCQkJcmV0dXJuIGNlOwoJCXBvcysrOwoJfQoJcmV0dXJuIE5VTEw7Cn0KCnN0YXRpYyB2b2lkIGFkZF9zYW1lX3VubWVyZ2VkKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCSAgICAgIHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJc3RydWN0IGluZGV4X3N0YXRlICppbmRleCA9IG8tPnNyY19pbmRleDsKCWludCBsZW4gPSBjZV9uYW1lbGVuKGNlKTsKCWludCBwb3MgPSBpbmRleF9uYW1lX3BvcyhpbmRleCwgY2UtPm5hbWUsIGxlbik7CgoJaWYgKDAgPD0gcG9zKQoJCWRpZSgicHJvZ3JhbW1pbmcgZXJyb3IgaW4gYSBjYWxsZXIgb2YgbWFya19jZV91c2VkX3NhbWVfbmFtZSIpOwoJZm9yIChwb3MgPSAtcG9zIC0gMTsgcG9zIDwgaW5kZXgtPmNhY2hlX25yOyBwb3MrKykgewoJCXN0cnVjdCBjYWNoZV9lbnRyeSAqbmV4dCA9IGluZGV4LT5jYWNoZVtwb3NdOwoJCWlmIChsZW4gIT0gY2VfbmFtZWxlbihuZXh0KSB8fAoJCSAgICBtZW1jbXAoY2UtPm5hbWUsIG5leHQtPm5hbWUsIGxlbikpCgkJCWJyZWFrOwoJCWFkZF9lbnRyeShvLCBuZXh0LCAwLCAwKTsKCQltYXJrX2NlX3VzZWQobmV4dCwgbyk7Cgl9Cn0KCnN0YXRpYyBpbnQgdW5wYWNrX2luZGV4X2VudHJ5KHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCSAgICAgIHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpzcmNbTUFYX1VOUEFDS19UUkVFUyArIDFdID0geyBOVUxMLCB9OwoJaW50IHJldDsKCglzcmNbMF0gPSBjZTsKCgltYXJrX2NlX3VzZWQoY2UsIG8pOwoJaWYgKGNlX3N0YWdlKGNlKSkgewoJCWlmIChvLT5za2lwX3VubWVyZ2VkKSB7CgkJCWFkZF9lbnRyeShvLCBjZSwgMCwgMCk7CgkJCXJldHVybiAwOwoJCX0KCX0KCXJldCA9IGNhbGxfdW5wYWNrX2ZuKHNyYywgbyk7CglpZiAoY2Vfc3RhZ2UoY2UpKQoJCW1hcmtfY2VfdXNlZF9zYW1lX25hbWUoY2UsIG8pOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIGludCBmaW5kX2NhY2hlX3BvcyhzdHJ1Y3QgdHJhdmVyc2VfaW5mbyAqLCBjb25zdCBzdHJ1Y3QgbmFtZV9lbnRyeSAqKTsKCnN0YXRpYyB2b2lkIHJlc3RvcmVfY2FjaGVfYm90dG9tKHN0cnVjdCB0cmF2ZXJzZV9pbmZvICppbmZvLCBpbnQgYm90dG9tKQp7CglzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8gPSBpbmZvLT5kYXRhOwoKCWlmIChvLT5kaWZmX2luZGV4X2NhY2hlZCkKCQlyZXR1cm47CglvLT5jYWNoZV9ib3R0b20gPSBib3R0b207Cn0KCnN0YXRpYyBpbnQgc3dpdGNoX2NhY2hlX2JvdHRvbShzdHJ1Y3QgdHJhdmVyc2VfaW5mbyAqaW5mbykKewoJc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvID0gaW5mby0+ZGF0YTsKCWludCByZXQsIHBvczsKCglpZiAoby0+ZGlmZl9pbmRleF9jYWNoZWQpCgkJcmV0dXJuIDA7CglyZXQgPSBvLT5jYWNoZV9ib3R0b207Cglwb3MgPSBmaW5kX2NhY2hlX3BvcyhpbmZvLT5wcmV2LCAmaW5mby0+bmFtZSk7CgoJaWYgKHBvcyA8IC0xKQoJCW8tPmNhY2hlX2JvdHRvbSA9IC0yIC0gcG9zOwoJZWxzZSBpZiAocG9zIDwgMCkKCQlvLT5jYWNoZV9ib3R0b20gPSBvLT5zcmNfaW5kZXgtPmNhY2hlX25yOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBpbnQgYXJlX3NhbWVfb2lkKHN0cnVjdCBuYW1lX2VudHJ5ICpuYW1lX2osIHN0cnVjdCBuYW1lX2VudHJ5ICpuYW1lX2spCnsKCXJldHVybiBuYW1lX2otPm9pZCAmJiBuYW1lX2stPm9pZCAmJiAhb2lkY21wKG5hbWVfai0+b2lkLCBuYW1lX2stPm9pZCk7Cn0KCnN0YXRpYyBpbnQgdHJhdmVyc2VfdHJlZXNfcmVjdXJzaXZlKGludCBuLCB1bnNpZ25lZCBsb25nIGRpcm1hc2ssCgkJCQkgICAgdW5zaWduZWQgbG9uZyBkZl9jb25mbGljdHMsCgkJCQkgICAgc3RydWN0IG5hbWVfZW50cnkgKm5hbWVzLAoJCQkJICAgIHN0cnVjdCB0cmF2ZXJzZV9pbmZvICppbmZvKQp7CglpbnQgaSwgcmV0LCBib3R0b207CglpbnQgbnJfYnVmID0gMDsKCXN0cnVjdCB0cmVlX2Rlc2MgdFtNQVhfVU5QQUNLX1RSRUVTXTsKCXZvaWQgKmJ1ZltNQVhfVU5QQUNLX1RSRUVTXTsKCXN0cnVjdCB0cmF2ZXJzZV9pbmZvIG5ld2luZm87CglzdHJ1Y3QgbmFtZV9lbnRyeSAqcDsKCglwID0gbmFtZXM7Cgl3aGlsZSAoIXAtPm1vZGUpCgkJcCsrOwoKCW5ld2luZm8gPSAqaW5mbzsKCW5ld2luZm8ucHJldiA9IGluZm87CgluZXdpbmZvLnBhdGhzcGVjID0gaW5mby0+cGF0aHNwZWM7CgluZXdpbmZvLm5hbWUgPSAqcDsKCW5ld2luZm8ucGF0aGxlbiArPSB0cmVlX2VudHJ5X2xlbihwKSArIDE7CgluZXdpbmZvLmRmX2NvbmZsaWN0cyB8PSBkZl9jb25mbGljdHM7CgoJLyoKCSAqIEZldGNoIHRoZSB0cmVlIGZyb20gdGhlIE9EQiBmb3IgZWFjaCBwZWVyIGRpcmVjdG9yeSBpbiB0aGUKCSAqIG4gY29tbWl0cy4KCSAqCgkgKiBGb3IgMi0gYW5kIDMtd2F5IHRyYXZlcnNhbHMsIHdlIHRyeSB0byBhdm9pZCBoaXR0aW5nIHRoZQoJICogT0RCIHR3aWNlIGZvciB0aGUgc2FtZSBPSUQuICBUaGlzIHNob3VsZCB5aWVsZCBhIG5pY2Ugc3BlZWQKCSAqIHVwIGluIGNoZWNrb3V0cyBhbmQgbWVyZ2VzIHdoZW4gdGhlIGNvbW1pdHMgYXJlIHNpbWlsYXIuCgkgKgoJICogV2UgZG9uJ3QgYm90aGVyIGRvaW5nIHRoZSBmdWxsIE8obl4yKSBzZWFyY2ggZm9yIGxhcmdlciBuLAoJICogYmVjYXVzZSB3aWRlciB0cmF2ZXJzYWxzIGRvbid0IGhhcHBlbiB0aGF0IG9mdGVuIGFuZCB3ZQoJICogYXZvaWQgdGhlIHNlYXJjaCBzZXR1cC4KCSAqCgkgKiBXaGVuIDIgcGVlciBPSURzIGFyZSB0aGUgc2FtZSwgd2UganVzdCBjb3B5IHRoZSB0cmVlCgkgKiBkZXNjcmlwdG9yIGRhdGEuICBUaGlzIGltcGxpY2l0bHkgYm9ycm93cyB0aGUgYnVmZmVyCgkgKiBkYXRhIGZyb20gdGhlIGVhcmxpZXIgY2VsbC4KCSAqLwoJZm9yIChpID0gMDsgaSA8IG47IGkrKywgZGlybWFzayA+Pj0gMSkgewoJCWlmIChpID4gMCAmJiBhcmVfc2FtZV9vaWQoJm5hbWVzW2ldLCAmbmFtZXNbaSAtIDFdKSkKCQkJdFtpXSA9IHRbaSAtIDFdOwoJCWVsc2UgaWYgKGkgPiAxICYmIGFyZV9zYW1lX29pZCgmbmFtZXNbaV0sICZuYW1lc1tpIC0gMl0pKQoJCQl0W2ldID0gdFtpIC0gMl07CgkJZWxzZSB7CgkJCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCA9IE5VTEw7CgkJCWlmIChkaXJtYXNrICYgMSkKCQkJCW9pZCA9IG5hbWVzW2ldLm9pZDsKCQkJYnVmW25yX2J1ZisrXSA9IGZpbGxfdHJlZV9kZXNjcmlwdG9yKHQgKyBpLCBvaWQpOwoJCX0KCX0KCglib3R0b20gPSBzd2l0Y2hfY2FjaGVfYm90dG9tKCZuZXdpbmZvKTsKCXJldCA9IHRyYXZlcnNlX3RyZWVzKG4sIHQsICZuZXdpbmZvKTsKCXJlc3RvcmVfY2FjaGVfYm90dG9tKCZuZXdpbmZvLCBib3R0b20pOwoKCWZvciAoaSA9IDA7IGkgPCBucl9idWY7IGkrKykKCQlmcmVlKGJ1ZltpXSk7CgoJcmV0dXJuIHJldDsKfQoKLyoKICogQ29tcGFyZSB0aGUgdHJhdmVyc2UtcGF0aCB0byB0aGUgY2FjaGUgZW50cnkgd2l0aG91dCBhY3R1YWxseQogKiBoYXZpbmcgdG8gZ2VuZXJhdGUgdGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYXZlcnNlCiAqIHBhdGguCiAqCiAqIE5PVEUhIFRoaXMgKm9ubHkqIGNvbXBhcmVzIHVwIHRvIHRoZSBzaXplIG9mIHRoZSB0cmF2ZXJzZSBwYXRoCiAqIGl0c2VsZiAtIHRoZSBjYWxsZXIgbmVlZHMgdG8gZG8gdGhlIGZpbmFsIGNoZWNrIGZvciB0aGUgY2FjaGUKICogZW50cnkgaGF2aW5nIG1vcmUgZGF0YSBhdCB0aGUgZW5kIQogKi8Kc3RhdGljIGludCBkb19jb21wYXJlX2VudHJ5X3BpZWNld2lzZShjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBjb25zdCBzdHJ1Y3QgdHJhdmVyc2VfaW5mbyAqaW5mbywgY29uc3Qgc3RydWN0IG5hbWVfZW50cnkgKm4pCnsKCWludCBsZW4sIHBhdGhsZW4sIGNlX2xlbjsKCWNvbnN0IGNoYXIgKmNlX25hbWU7CgoJaWYgKGluZm8tPnByZXYpIHsKCQlpbnQgY21wID0gZG9fY29tcGFyZV9lbnRyeV9waWVjZXdpc2UoY2UsIGluZm8tPnByZXYsCgkJCQkJCSAgICAgJmluZm8tPm5hbWUpOwoJCWlmIChjbXApCgkJCXJldHVybiBjbXA7Cgl9CglwYXRobGVuID0gaW5mby0+cGF0aGxlbjsKCWNlX2xlbiA9IGNlX25hbWVsZW4oY2UpOwoKCS8qIElmIGNlX2xlbiA8IHBhdGhsZW4gdGhlbiB3ZSBtdXN0IGhhdmUgcHJldmlvdXNseSBoaXQgIm5hbWUgPT0gZGlyZWN0b3J5IiBlbnRyeSAqLwoJaWYgKGNlX2xlbiA8IHBhdGhsZW4pCgkJcmV0dXJuIC0xOwoKCWNlX2xlbiAtPSBwYXRobGVuOwoJY2VfbmFtZSA9IGNlLT5uYW1lICsgcGF0aGxlbjsKCglsZW4gPSB0cmVlX2VudHJ5X2xlbihuKTsKCXJldHVybiBkZl9uYW1lX2NvbXBhcmUoY2VfbmFtZSwgY2VfbGVuLCBTX0lGUkVHLCBuLT5wYXRoLCBsZW4sIG4tPm1vZGUpOwp9CgpzdGF0aWMgaW50IGRvX2NvbXBhcmVfZW50cnkoY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwKCQkJICAgIGNvbnN0IHN0cnVjdCB0cmF2ZXJzZV9pbmZvICppbmZvLAoJCQkgICAgY29uc3Qgc3RydWN0IG5hbWVfZW50cnkgKm4pCnsKCWludCBsZW4sIHBhdGhsZW4sIGNlX2xlbjsKCWNvbnN0IGNoYXIgKmNlX25hbWU7CglpbnQgY21wOwoKCS8qCgkgKiBJZiB3ZSBoYXZlIG5vdCBwcmVjb21wdXRlZCB0aGUgdHJhdmVyc2UgcGF0aCwgaXQgaXMgcXVpY2tlcgoJICogdG8gYXZvaWQgZG9pbmcgc28uICBCdXQgaWYgd2UgaGF2ZSBwcmVjb21wdXRlZCBpdCwKCSAqIGl0IGlzIHF1aWNrZXIgdG8gdXNlIHRoZSBwcmVjb21wdXRlZCB2ZXJzaW9uLgoJICovCglpZiAoIWluZm8tPnRyYXZlcnNlX3BhdGgpCgkJcmV0dXJuIGRvX2NvbXBhcmVfZW50cnlfcGllY2V3aXNlKGNlLCBpbmZvLCBuKTsKCgljbXAgPSBzdHJuY21wKGNlLT5uYW1lLCBpbmZvLT50cmF2ZXJzZV9wYXRoLCBpbmZvLT5wYXRobGVuKTsKCWlmIChjbXApCgkJcmV0dXJuIGNtcDsKCglwYXRobGVuID0gaW5mby0+cGF0aGxlbjsKCWNlX2xlbiA9IGNlX25hbWVsZW4oY2UpOwoKCWlmIChjZV9sZW4gPCBwYXRobGVuKQoJCXJldHVybiAtMTsKCgljZV9sZW4gLT0gcGF0aGxlbjsKCWNlX25hbWUgPSBjZS0+bmFtZSArIHBhdGhsZW47CgoJbGVuID0gdHJlZV9lbnRyeV9sZW4obik7CglyZXR1cm4gZGZfbmFtZV9jb21wYXJlKGNlX25hbWUsIGNlX2xlbiwgU19JRlJFRywgbi0+cGF0aCwgbGVuLCBuLT5tb2RlKTsKfQoKc3RhdGljIGludCBjb21wYXJlX2VudHJ5KGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIGNvbnN0IHN0cnVjdCB0cmF2ZXJzZV9pbmZvICppbmZvLCBjb25zdCBzdHJ1Y3QgbmFtZV9lbnRyeSAqbikKewoJaW50IGNtcCA9IGRvX2NvbXBhcmVfZW50cnkoY2UsIGluZm8sIG4pOwoJaWYgKGNtcCkKCQlyZXR1cm4gY21wOwoKCS8qCgkgKiBFdmVuIGlmIHRoZSBiZWdpbm5pbmcgY29tcGFyZWQgaWRlbnRpY2FsbHksIHRoZSBjZSBzaG91bGQKCSAqIGNvbXBhcmUgYXMgYmlnZ2VyIHRoYW4gYSBkaXJlY3RvcnkgbGVhZGluZyB1cCB0byBpdCEKCSAqLwoJcmV0dXJuIGNlX25hbWVsZW4oY2UpID4gdHJhdmVyc2VfcGF0aF9sZW4oaW5mbywgbik7Cn0KCnN0YXRpYyBpbnQgY2VfaW5fdHJhdmVyc2VfcGF0aChjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQkgICAgICAgY29uc3Qgc3RydWN0IHRyYXZlcnNlX2luZm8gKmluZm8pCnsKCWlmICghaW5mby0+cHJldikKCQlyZXR1cm4gMTsKCWlmIChkb19jb21wYXJlX2VudHJ5KGNlLCBpbmZvLT5wcmV2LCAmaW5mby0+bmFtZSkpCgkJcmV0dXJuIDA7CgkvKgoJICogSWYgY2UgKGJsb2IpIGlzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIHBhdGggKHdoaWNoIGlzIGEgdHJlZQoJICogd2Ugd2lsbCBiZSBkZXNjZW5kaW5nIGludG8pLCBpdCB3b24ndCBiZSBpbnNpZGUgaXQuCgkgKi8KCXJldHVybiAoaW5mby0+cGF0aGxlbiA8IGNlX25hbWVsZW4oY2UpKTsKfQoKc3RhdGljIHN0cnVjdCBjYWNoZV9lbnRyeSAqY3JlYXRlX2NlX2VudHJ5KGNvbnN0IHN0cnVjdCB0cmF2ZXJzZV9pbmZvICppbmZvLCBjb25zdCBzdHJ1Y3QgbmFtZV9lbnRyeSAqbiwgaW50IHN0YWdlKQp7CglpbnQgbGVuID0gdHJhdmVyc2VfcGF0aF9sZW4oaW5mbywgbik7CglzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0geGNhbGxvYygxLCBjYWNoZV9lbnRyeV9zaXplKGxlbikpOwoKCWNlLT5jZV9tb2RlID0gY3JlYXRlX2NlX21vZGUobi0+bW9kZSk7CgljZS0+Y2VfZmxhZ3MgPSBjcmVhdGVfY2VfZmxhZ3Moc3RhZ2UpOwoJY2UtPmNlX25hbWVsZW4gPSBsZW47CglvaWRjcHkoJmNlLT5vaWQsIG4tPm9pZCk7CgltYWtlX3RyYXZlcnNlX3BhdGgoY2UtPm5hbWUsIGluZm8sIG4pOwoKCXJldHVybiBjZTsKfQoKc3RhdGljIGludCB1bnBhY2tfbm9uZGlyZWN0b3JpZXMoaW50IG4sIHVuc2lnbmVkIGxvbmcgbWFzaywKCQkJCSB1bnNpZ25lZCBsb25nIGRpcm1hc2ssCgkJCQkgc3RydWN0IGNhY2hlX2VudHJ5ICoqc3JjLAoJCQkJIGNvbnN0IHN0cnVjdCBuYW1lX2VudHJ5ICpuYW1lcywKCQkJCSBjb25zdCBzdHJ1Y3QgdHJhdmVyc2VfaW5mbyAqaW5mbykKewoJaW50IGk7CglzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8gPSBpbmZvLT5kYXRhOwoJdW5zaWduZWQgbG9uZyBjb25mbGljdHMgPSBpbmZvLT5kZl9jb25mbGljdHMgfCBkaXJtYXNrOwoKCS8qIERvIHdlIGhhdmUgKm9ubHkqIGRpcmVjdG9yaWVzPyBOb3RoaW5nIHRvIGRvICovCglpZiAobWFzayA9PSBkaXJtYXNrICYmICFzcmNbMF0pCgkJcmV0dXJuIDA7CgoJLyoKCSAqIE9rLCB3ZSd2ZSBmaWxsZWQgaW4gdXAgdG8gYW55IHBvdGVudGlhbCBpbmRleCBlbnRyeSBpbiBzcmNbMF0sCgkgKiBub3cgZG8gdGhlIHJlc3QuCgkgKi8KCWZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHsKCQlpbnQgc3RhZ2U7CgkJdW5zaWduZWQgaW50IGJpdCA9IDF1bCA8PCBpOwoJCWlmIChjb25mbGljdHMgJiBiaXQpIHsKCQkJc3JjW2kgKyBvLT5tZXJnZV0gPSBvLT5kZl9jb25mbGljdF9lbnRyeTsKCQkJY29udGludWU7CgkJfQoJCWlmICghKG1hc2sgJiBiaXQpKQoJCQljb250aW51ZTsKCQlpZiAoIW8tPm1lcmdlKQoJCQlzdGFnZSA9IDA7CgkJZWxzZSBpZiAoaSArIDEgPCBvLT5oZWFkX2lkeCkKCQkJc3RhZ2UgPSAxOwoJCWVsc2UgaWYgKGkgKyAxID4gby0+aGVhZF9pZHgpCgkJCXN0YWdlID0gMzsKCQllbHNlCgkJCXN0YWdlID0gMjsKCQlzcmNbaSArIG8tPm1lcmdlXSA9IGNyZWF0ZV9jZV9lbnRyeShpbmZvLCBuYW1lcyArIGksIHN0YWdlKTsKCX0KCglpZiAoby0+bWVyZ2UpIHsKCQlpbnQgcmMgPSBjYWxsX3VucGFja19mbigoY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICogY29uc3QgKilzcmMsCgkJCQkJbyk7CgkJZm9yIChpID0gMDsgaSA8IG47IGkrKykgewoJCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gc3JjW2kgKyBvLT5tZXJnZV07CgkJCWlmIChjZSAhPSBvLT5kZl9jb25mbGljdF9lbnRyeSkKCQkJCWZyZWUoY2UpOwoJCX0KCQlyZXR1cm4gcmM7Cgl9CgoJZm9yIChpID0gMDsgaSA8IG47IGkrKykKCQlpZiAoc3JjW2ldICYmIHNyY1tpXSAhPSBvLT5kZl9jb25mbGljdF9lbnRyeSkKCQkJaWYgKGRvX2FkZF9lbnRyeShvLCBzcmNbaV0sIDAsIDApKQoJCQkJcmV0dXJuIC0xOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHVucGFja19mYWlsZWQoc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvLCBjb25zdCBjaGFyICptZXNzYWdlKQp7CglkaXNjYXJkX2luZGV4KCZvLT5yZXN1bHQpOwoJaWYgKCFvLT5nZW50bHkgJiYgIW8tPmV4aXRpbmdfZWFybHkpIHsKCQlpZiAobWVzc2FnZSkKCQkJcmV0dXJuIGVycm9yKCIlcyIsIG1lc3NhZ2UpOwoJCXJldHVybiAtMTsKCX0KCXJldHVybiAtMTsKfQoKLyoKICogVGhlIHRyZWUgdHJhdmVyc2FsIGlzIGxvb2tpbmcgYXQgbmFtZSBwLiAgSWYgd2UgaGF2ZSBhIG1hdGNoaW5nIGVudHJ5LAogKiByZXR1cm4gaXQuICBJZiBuYW1lIHAgaXMgYSBkaXJlY3RvcnkgaW4gdGhlIGluZGV4LCBkbyBub3QgcmV0dXJuCiAqIGFueXRoaW5nLCBhcyB3ZSB3aWxsIHdhbnQgdG8gbWF0Y2ggaXQgd2hlbiB0aGUgdHJhdmVyc2FsIGRlc2NlbmRzIGludG8KICogdGhlIGRpcmVjdG9yeS4KICovCnN0YXRpYyBpbnQgZmluZF9jYWNoZV9wb3Moc3RydWN0IHRyYXZlcnNlX2luZm8gKmluZm8sCgkJCSAgY29uc3Qgc3RydWN0IG5hbWVfZW50cnkgKnApCnsKCWludCBwb3M7CglzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8gPSBpbmZvLT5kYXRhOwoJc3RydWN0IGluZGV4X3N0YXRlICppbmRleCA9IG8tPnNyY19pbmRleDsKCWludCBwZnhsZW4gPSBpbmZvLT5wYXRobGVuOwoJaW50IHBfbGVuID0gdHJlZV9lbnRyeV9sZW4ocCk7CgoJZm9yIChwb3MgPSBvLT5jYWNoZV9ib3R0b207IHBvcyA8IGluZGV4LT5jYWNoZV9ucjsgcG9zKyspIHsKCQljb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gaW5kZXgtPmNhY2hlW3Bvc107CgkJY29uc3QgY2hhciAqY2VfbmFtZSwgKmNlX3NsYXNoOwoJCWludCBjbXAsIGNlX2xlbjsKCgkJaWYgKGNlLT5jZV9mbGFncyAmIENFX1VOUEFDS0VEKSB7CgkJCS8qCgkJCSAqIGNhY2hlX2JvdHRvbSBlbnRyeSBpcyBhbHJlYWR5IHVucGFja2VkLCBzbwoJCQkgKiB3ZSBjYW4gbmV2ZXIgbWF0Y2ggaXQ7IGRvbid0IGNoZWNrIGl0CgkJCSAqIGFnYWluLgoJCQkgKi8KCQkJaWYgKHBvcyA9PSBvLT5jYWNoZV9ib3R0b20pCgkJCQkrK28tPmNhY2hlX2JvdHRvbTsKCQkJY29udGludWU7CgkJfQoJCWlmICghY2VfaW5fdHJhdmVyc2VfcGF0aChjZSwgaW5mbykpIHsKCQkJLyoKCQkJICogQ2hlY2sgaWYgd2UgY2FuIHNraXAgZnV0dXJlIGNhY2hlIGNoZWNrcwoJCQkgKiAoYmVjYXVzZSB3ZSdyZSBhbHJlYWR5IHBhc3QgYWxsIHBvc3NpYmxlCgkJCSAqIGVudHJpZXMgaW4gdGhlIHRyYXZlcnNlIHBhdGgpLgoJCQkgKi8KCQkJaWYgKGluZm8tPnRyYXZlcnNlX3BhdGgpIHsKCQkJCWlmIChzdHJuY21wKGNlLT5uYW1lLCBpbmZvLT50cmF2ZXJzZV9wYXRoLAoJCQkJCSAgICBpbmZvLT5wYXRobGVuKSA+IDApCgkJCQkJYnJlYWs7CgkJCX0KCQkJY29udGludWU7CgkJfQoJCWNlX25hbWUgPSBjZS0+bmFtZSArIHBmeGxlbjsKCQljZV9zbGFzaCA9IHN0cmNocihjZV9uYW1lLCAnLycpOwoJCWlmIChjZV9zbGFzaCkKCQkJY2VfbGVuID0gY2Vfc2xhc2ggLSBjZV9uYW1lOwoJCWVsc2UKCQkJY2VfbGVuID0gY2VfbmFtZWxlbihjZSkgLSBwZnhsZW47CgkJY21wID0gbmFtZV9jb21wYXJlKHAtPnBhdGgsIHBfbGVuLCBjZV9uYW1lLCBjZV9sZW4pOwoJCS8qCgkJICogRXhhY3QgbWF0Y2g7IGlmIHdlIGhhdmUgYSBkaXJlY3Rvcnkgd2UgbmVlZCB0bwoJCSAqIGRlbGF5IHJldHVybmluZyBpdC4KCQkgKi8KCQlpZiAoIWNtcCkKCQkJcmV0dXJuIGNlX3NsYXNoID8gLTIgLSBwb3MgOiBwb3M7CgkJaWYgKDAgPCBjbXApCgkJCWNvbnRpbnVlOyAvKiBrZWVwIGxvb2tpbmcgKi8KCQkvKgoJCSAqIGNlX25hbWUgc29ydHMgYWZ0ZXIgcC0+cGF0aDsgY291bGQgaXQgYmUgdGhhdCB3ZQoJCSAqIGhhdmUgZmlsZXMgdW5kZXIgcC0+cGF0aCBkaXJlY3RvcnkgaW4gdGhlIGluZGV4PwoJCSAqIEUuZy4gIGNlX25hbWUgPT0gInQtaSIsIGFuZCBwLT5wYXRoID09ICJ0Ijsgd2UgbWF5CgkJICogaGF2ZSAidC9hIiBpbiB0aGUgaW5kZXguCgkJICovCgkJaWYgKHBfbGVuIDwgY2VfbGVuICYmICFtZW1jbXAoY2VfbmFtZSwgcC0+cGF0aCwgcF9sZW4pICYmCgkJICAgIGNlX25hbWVbcF9sZW5dIDwgJy8nKQoJCQljb250aW51ZTsgLyoga2VlcCBsb29raW5nICovCgkJYnJlYWs7Cgl9CglyZXR1cm4gLTE7Cn0KCnN0YXRpYyBzdHJ1Y3QgY2FjaGVfZW50cnkgKmZpbmRfY2FjaGVfZW50cnkoc3RydWN0IHRyYXZlcnNlX2luZm8gKmluZm8sCgkJCQkJICAgIGNvbnN0IHN0cnVjdCBuYW1lX2VudHJ5ICpwKQp7CglpbnQgcG9zID0gZmluZF9jYWNoZV9wb3MoaW5mbywgcCk7CglzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8gPSBpbmZvLT5kYXRhOwoKCWlmICgwIDw9IHBvcykKCQlyZXR1cm4gby0+c3JjX2luZGV4LT5jYWNoZVtwb3NdOwoJZWxzZQoJCXJldHVybiBOVUxMOwp9CgpzdGF0aWMgdm9pZCBkZWJ1Z19wYXRoKHN0cnVjdCB0cmF2ZXJzZV9pbmZvICppbmZvKQp7CglpZiAoaW5mby0+cHJldikgewoJCWRlYnVnX3BhdGgoaW5mby0+cHJldik7CgkJaWYgKCppbmZvLT5wcmV2LT5uYW1lLnBhdGgpCgkJCXB1dGNoYXIoJy8nKTsKCX0KCXByaW50ZigiJXMiLCBpbmZvLT5uYW1lLnBhdGgpOwp9CgpzdGF0aWMgdm9pZCBkZWJ1Z19uYW1lX2VudHJ5KGludCBpLCBzdHJ1Y3QgbmFtZV9lbnRyeSAqbikKewoJcHJpbnRmKCJlbnQjJWQgJTA2byAlc1xuIiwgaSwKCSAgICAgICBuLT5wYXRoID8gbi0+bW9kZSA6IDAsCgkgICAgICAgbi0+cGF0aCA/IG4tPnBhdGggOiAiKG1pc3NpbmcpIik7Cn0KCnN0YXRpYyB2b2lkIGRlYnVnX3VucGFja19jYWxsYmFjayhpbnQgbiwKCQkJCSAgdW5zaWduZWQgbG9uZyBtYXNrLAoJCQkJICB1bnNpZ25lZCBsb25nIGRpcm1hc2ssCgkJCQkgIHN0cnVjdCBuYW1lX2VudHJ5ICpuYW1lcywKCQkJCSAgc3RydWN0IHRyYXZlcnNlX2luZm8gKmluZm8pCnsKCWludCBpOwoJcHJpbnRmKCIqIHVucGFjayBtYXNrICVsdSwgZGlybWFzayAlbHUsIGNudCAlZCAiLAoJICAgICAgIG1hc2ssIGRpcm1hc2ssIG4pOwoJZGVidWdfcGF0aChpbmZvKTsKCXB1dGNoYXIoJ1xuJyk7Cglmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKQoJCWRlYnVnX25hbWVfZW50cnkoaSwgbmFtZXMgKyBpKTsKfQoKc3RhdGljIGludCB1bnBhY2tfY2FsbGJhY2soaW50IG4sIHVuc2lnbmVkIGxvbmcgbWFzaywgdW5zaWduZWQgbG9uZyBkaXJtYXNrLCBzdHJ1Y3QgbmFtZV9lbnRyeSAqbmFtZXMsIHN0cnVjdCB0cmF2ZXJzZV9pbmZvICppbmZvKQp7CglzdHJ1Y3QgY2FjaGVfZW50cnkgKnNyY1tNQVhfVU5QQUNLX1RSRUVTICsgMV0gPSB7IE5VTEwsIH07CglzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8gPSBpbmZvLT5kYXRhOwoJY29uc3Qgc3RydWN0IG5hbWVfZW50cnkgKnAgPSBuYW1lczsKCgkvKiBGaW5kIGZpcnN0IGVudHJ5IHdpdGggYSByZWFsIG5hbWUgKHdlIGNvdWxkIHVzZSAibWFzayIgdG9vKSAqLwoJd2hpbGUgKCFwLT5tb2RlKQoJCXArKzsKCglpZiAoby0+ZGVidWdfdW5wYWNrKQoJCWRlYnVnX3VucGFja19jYWxsYmFjayhuLCBtYXNrLCBkaXJtYXNrLCBuYW1lcywgaW5mbyk7CgoJLyogQXJlIHdlIHN1cHBvc2VkIHRvIGxvb2sgYXQgdGhlIGluZGV4IHRvbz8gKi8KCWlmIChvLT5tZXJnZSkgewoJCXdoaWxlICgxKSB7CgkJCWludCBjbXA7CgkJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2U7CgoJCQlpZiAoby0+ZGlmZl9pbmRleF9jYWNoZWQpCgkJCQljZSA9IG5leHRfY2FjaGVfZW50cnkobyk7CgkJCWVsc2UKCQkJCWNlID0gZmluZF9jYWNoZV9lbnRyeShpbmZvLCBwKTsKCgkJCWlmICghY2UpCgkJCQlicmVhazsKCQkJY21wID0gY29tcGFyZV9lbnRyeShjZSwgaW5mbywgcCk7CgkJCWlmIChjbXAgPCAwKSB7CgkJCQlpZiAodW5wYWNrX2luZGV4X2VudHJ5KGNlLCBvKSA8IDApCgkJCQkJcmV0dXJuIHVucGFja19mYWlsZWQobywgTlVMTCk7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIWNtcCkgewoJCQkJaWYgKGNlX3N0YWdlKGNlKSkgewoJCQkJCS8qCgkJCQkJICogSWYgd2Ugc2tpcCB1bm1lcmdlZCBpbmRleAoJCQkJCSAqIGVudHJpZXMsIHdlJ2xsIHNraXAgdGhpcwoJCQkJCSAqIGVudHJ5ICphbmQqIHRoZSB0cmVlCgkJCQkJICogZW50cmllcyBhc3NvY2lhdGVkIHdpdGggaXQhCgkJCQkJICovCgkJCQkJaWYgKG8tPnNraXBfdW5tZXJnZWQpIHsKCQkJCQkJYWRkX3NhbWVfdW5tZXJnZWQoY2UsIG8pOwoJCQkJCQlyZXR1cm4gbWFzazsKCQkJCQl9CgkJCQl9CgkJCQlzcmNbMF0gPSBjZTsKCQkJfQoJCQlicmVhazsKCQl9Cgl9CgoJaWYgKHVucGFja19ub25kaXJlY3RvcmllcyhuLCBtYXNrLCBkaXJtYXNrLCBzcmMsIG5hbWVzLCBpbmZvKSA8IDApCgkJcmV0dXJuIC0xOwoKCWlmIChvLT5tZXJnZSAmJiBzcmNbMF0pIHsKCQlpZiAoY2Vfc3RhZ2Uoc3JjWzBdKSkKCQkJbWFya19jZV91c2VkX3NhbWVfbmFtZShzcmNbMF0sIG8pOwoJCWVsc2UKCQkJbWFya19jZV91c2VkKHNyY1swXSwgbyk7Cgl9CgoJLyogTm93IGhhbmRsZSBhbnkgZGlyZWN0b3JpZXMuLiAqLwoJaWYgKGRpcm1hc2spIHsKCQkvKiBzcGVjaWFsIGNhc2U6ICJkaWZmLWluZGV4IC0tY2FjaGVkIiBsb29raW5nIGF0IGEgdHJlZSAqLwoJCWlmIChvLT5kaWZmX2luZGV4X2NhY2hlZCAmJgoJCSAgICBuID09IDEgJiYgZGlybWFzayA9PSAxICYmIFNfSVNESVIobmFtZXMtPm1vZGUpKSB7CgkJCWludCBtYXRjaGVzOwoJCQltYXRjaGVzID0gY2FjaGVfdHJlZV9tYXRjaGVzX3RyYXZlcnNhbChvLT5zcmNfaW5kZXgtPmNhY2hlX3RyZWUsCgkJCQkJCQkgICAgICAgbmFtZXMsIGluZm8pOwoJCQkvKgoJCQkgKiBFdmVyeXRoaW5nIHVuZGVyIHRoZSBuYW1lIG1hdGNoZXM7IHNraXAgdGhlCgkJCSAqIGVudGlyZSBoaWVyYXJjaHkuICBkaWZmX2luZGV4X2NhY2hlZCBjb2RlcGF0aAoJCQkgKiBzcGVjaWFsIGNhc2VzIEQvRiBjb25mbGljdHMgaW4gc3VjaCBhIHdheSB0aGF0CgkJCSAqIGl0IGRvZXMgbm90IGRvIGFueSBsb29rLWFoZWFkLCBzbyB0aGlzIGlzIHNhZmUuCgkJCSAqLwoJCQlpZiAobWF0Y2hlcykgewoJCQkJby0+Y2FjaGVfYm90dG9tICs9IG1hdGNoZXM7CgkJCQlyZXR1cm4gbWFzazsKCQkJfQoJCX0KCgkJaWYgKHRyYXZlcnNlX3RyZWVzX3JlY3Vyc2l2ZShuLCBkaXJtYXNrLCBtYXNrICYgfmRpcm1hc2ssCgkJCQkJICAgICBuYW1lcywgaW5mbykgPCAwKQoJCQlyZXR1cm4gLTE7CgkJcmV0dXJuIG1hc2s7Cgl9CgoJcmV0dXJuIG1hc2s7Cn0KCnN0YXRpYyBpbnQgY2xlYXJfY2VfZmxhZ3NfMShzdHJ1Y3QgY2FjaGVfZW50cnkgKipjYWNoZSwgaW50IG5yLAoJCQkgICAgc3RydWN0IHN0cmJ1ZiAqcHJlZml4LAoJCQkgICAgaW50IHNlbGVjdF9tYXNrLCBpbnQgY2xlYXJfbWFzaywKCQkJICAgIHN0cnVjdCBleGNsdWRlX2xpc3QgKmVsLCBpbnQgZGVmdmFsKTsKCi8qIFdob2xlIGRpcmVjdG9yeSBtYXRjaGluZyAqLwpzdGF0aWMgaW50IGNsZWFyX2NlX2ZsYWdzX2RpcihzdHJ1Y3QgY2FjaGVfZW50cnkgKipjYWNoZSwgaW50IG5yLAoJCQkgICAgICBzdHJ1Y3Qgc3RyYnVmICpwcmVmaXgsCgkJCSAgICAgIGNoYXIgKmJhc2VuYW1lLAoJCQkgICAgICBpbnQgc2VsZWN0X21hc2ssIGludCBjbGVhcl9tYXNrLAoJCQkgICAgICBzdHJ1Y3QgZXhjbHVkZV9saXN0ICplbCwgaW50IGRlZnZhbCkKewoJc3RydWN0IGNhY2hlX2VudHJ5ICoqY2FjaGVfZW5kOwoJaW50IGR0eXBlID0gRFRfRElSOwoJaW50IHJldCA9IGlzX2V4Y2x1ZGVkX2Zyb21fbGlzdChwcmVmaXgtPmJ1ZiwgcHJlZml4LT5sZW4sCgkJCQkJYmFzZW5hbWUsICZkdHlwZSwgZWwsICZ0aGVfaW5kZXgpOwoJaW50IHJjOwoKCXN0cmJ1Zl9hZGRjaChwcmVmaXgsICcvJyk7CgoJLyogSWYgdW5kZWNpZGVkLCB1c2UgbWF0Y2hpbmcgcmVzdWx0IG9mIHBhcmVudCBkaXIgaW4gZGVmdmFsICovCglpZiAocmV0IDwgMCkKCQlyZXQgPSBkZWZ2YWw7CgoJZm9yIChjYWNoZV9lbmQgPSBjYWNoZTsgY2FjaGVfZW5kICE9IGNhY2hlICsgbnI7IGNhY2hlX2VuZCsrKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9ICpjYWNoZV9lbmQ7CgkJaWYgKHN0cm5jbXAoY2UtPm5hbWUsIHByZWZpeC0+YnVmLCBwcmVmaXgtPmxlbikpCgkJCWJyZWFrOwoJfQoKCS8qCgkgKiBUT0RPOiBjaGVjayBlbCwgaWYgdGhlcmUgYXJlIG5vIHBhdHRlcm5zIHRoYXQgbWF5IGNvbmZsaWN0CgkgKiB3aXRoIHJldCAoaW93LCB3ZSBrbm93IGluIGFkdmFuY2UgdGhlIGluY2wvZXhjbAoJICogZGVjaXNpb24gZm9yIHRoZSBlbnRpcmUgZGlyZWN0b3J5KSwgY2xlYXIgZmxhZyBoZXJlIHdpdGhvdXQKCSAqIGNhbGxpbmcgY2xlYXJfY2VfZmxhZ3NfMSgpLiBUaGF0IGZ1bmN0aW9uIHdpbGwgY2FsbAoJICogdGhlIGV4cGVuc2l2ZSBpc19leGNsdWRlZF9mcm9tX2xpc3QoKSBvbiBldmVyeSBlbnRyeS4KCSAqLwoJcmMgPSBjbGVhcl9jZV9mbGFnc18xKGNhY2hlLCBjYWNoZV9lbmQgLSBjYWNoZSwKCQkJICAgICAgcHJlZml4LAoJCQkgICAgICBzZWxlY3RfbWFzaywgY2xlYXJfbWFzaywKCQkJICAgICAgZWwsIHJldCk7CglzdHJidWZfc2V0bGVuKHByZWZpeCwgcHJlZml4LT5sZW4gLSAxKTsKCXJldHVybiByYzsKfQoKLyoKICogVHJhdmVyc2UgdGhlIGluZGV4LCBmaW5kIGV2ZXJ5IGVudHJ5IHRoYXQgbWF0Y2hlcyBhY2NvcmRpbmcgdG8KICogby0+ZWwuIERvICJjZV9mbGFncyAmPSB+Y2xlYXJfbWFzayIgb24gdGhvc2UgZW50cmllcy4gUmV0dXJuIHRoZQogKiBudW1iZXIgb2YgdHJhdmVyc2VkIGVudHJpZXMuCiAqCiAqIElmIHNlbGVjdF9tYXNrIGlzIG5vbi16ZXJvLCBvbmx5IGVudHJpZXMgd2hvc2UgY2VfZmxhZ3MgaGFzIG9uIG9mCiAqIHRob3NlIGJpdHMgZW5hYmxlZCBhcmUgdHJhdmVyc2VkLgogKgogKiBjYWNoZQk6IHBvaW50ZXIgdG8gYW4gaW5kZXggZW50cnkKICogcHJlZml4X2xlbgk6IGFuIG9mZnNldCB0byBpdHMgcGF0aAogKgogKiBUaGUgY3VycmVudCBwYXRoICgicHJlZml4IikgaW5jbHVkaW5nIHRoZSB0cmFpbGluZyAnLycgaXMKICogICBjYWNoZVswXS0+bmFtZVswLi4ocHJlZml4X2xlbi0xKV0KICogVG9wIGxldmVsIHBhdGggaGFzIHByZWZpeF9sZW4gemVyby4KICovCnN0YXRpYyBpbnQgY2xlYXJfY2VfZmxhZ3NfMShzdHJ1Y3QgY2FjaGVfZW50cnkgKipjYWNoZSwgaW50IG5yLAoJCQkgICAgc3RydWN0IHN0cmJ1ZiAqcHJlZml4LAoJCQkgICAgaW50IHNlbGVjdF9tYXNrLCBpbnQgY2xlYXJfbWFzaywKCQkJICAgIHN0cnVjdCBleGNsdWRlX2xpc3QgKmVsLCBpbnQgZGVmdmFsKQp7CglzdHJ1Y3QgY2FjaGVfZW50cnkgKipjYWNoZV9lbmQgPSBjYWNoZSArIG5yOwoKCS8qCgkgKiBQcm9jZXNzIGFsbCBlbnRyaWVzIHRoYXQgaGF2ZSB0aGUgZ2l2ZW4gcHJlZml4IGFuZCBtZWV0CgkgKiBzZWxlY3RfbWFzayBjb25kaXRpb24KCSAqLwoJd2hpbGUoY2FjaGUgIT0gY2FjaGVfZW5kKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9ICpjYWNoZTsKCQljb25zdCBjaGFyICpuYW1lLCAqc2xhc2g7CgkJaW50IGxlbiwgZHR5cGUsIHJldDsKCgkJaWYgKHNlbGVjdF9tYXNrICYmICEoY2UtPmNlX2ZsYWdzICYgc2VsZWN0X21hc2spKSB7CgkJCWNhY2hlKys7CgkJCWNvbnRpbnVlOwoJCX0KCgkJaWYgKHByZWZpeC0+bGVuICYmIHN0cm5jbXAoY2UtPm5hbWUsIHByZWZpeC0+YnVmLCBwcmVmaXgtPmxlbikpCgkJCWJyZWFrOwoKCQluYW1lID0gY2UtPm5hbWUgKyBwcmVmaXgtPmxlbjsKCQlzbGFzaCA9IHN0cmNocihuYW1lLCAnLycpOwoKCQkvKiBJZiBpdCdzIGEgZGlyZWN0b3J5LCB0cnkgd2hvbGUgZGlyZWN0b3J5IG1hdGNoIGZpcnN0ICovCgkJaWYgKHNsYXNoKSB7CgkJCWludCBwcm9jZXNzZWQ7CgoJCQlsZW4gPSBzbGFzaCAtIG5hbWU7CgkJCXN0cmJ1Zl9hZGQocHJlZml4LCBuYW1lLCBsZW4pOwoKCQkJcHJvY2Vzc2VkID0gY2xlYXJfY2VfZmxhZ3NfZGlyKGNhY2hlLCBjYWNoZV9lbmQgLSBjYWNoZSwKCQkJCQkJICAgICAgIHByZWZpeCwKCQkJCQkJICAgICAgIHByZWZpeC0+YnVmICsgcHJlZml4LT5sZW4gLSBsZW4sCgkJCQkJCSAgICAgICBzZWxlY3RfbWFzaywgY2xlYXJfbWFzaywKCQkJCQkJICAgICAgIGVsLCBkZWZ2YWwpOwoKCQkJLyogY2xlYXJfY19mX2RpciBlYXRzIGEgd2hvbGUgZGlyIGFscmVhZHk/ICovCgkJCWlmIChwcm9jZXNzZWQpIHsKCQkJCWNhY2hlICs9IHByb2Nlc3NlZDsKCQkJCXN0cmJ1Zl9zZXRsZW4ocHJlZml4LCBwcmVmaXgtPmxlbiAtIGxlbik7CgkJCQljb250aW51ZTsKCQkJfQoKCQkJc3RyYnVmX2FkZGNoKHByZWZpeCwgJy8nKTsKCQkJY2FjaGUgKz0gY2xlYXJfY2VfZmxhZ3NfMShjYWNoZSwgY2FjaGVfZW5kIC0gY2FjaGUsCgkJCQkJCSAgcHJlZml4LAoJCQkJCQkgIHNlbGVjdF9tYXNrLCBjbGVhcl9tYXNrLCBlbCwgZGVmdmFsKTsKCQkJc3RyYnVmX3NldGxlbihwcmVmaXgsIHByZWZpeC0+bGVuIC0gbGVuIC0gMSk7CgkJCWNvbnRpbnVlOwoJCX0KCgkJLyogTm9uLWRpcmVjdG9yeSAqLwoJCWR0eXBlID0gY2VfdG9fZHR5cGUoY2UpOwoJCXJldCA9IGlzX2V4Y2x1ZGVkX2Zyb21fbGlzdChjZS0+bmFtZSwgY2VfbmFtZWxlbihjZSksCgkJCQkJICAgIG5hbWUsICZkdHlwZSwgZWwsICZ0aGVfaW5kZXgpOwoJCWlmIChyZXQgPCAwKQoJCQlyZXQgPSBkZWZ2YWw7CgkJaWYgKHJldCA+IDApCgkJCWNlLT5jZV9mbGFncyAmPSB+Y2xlYXJfbWFzazsKCQljYWNoZSsrOwoJfQoJcmV0dXJuIG5yIC0gKGNhY2hlX2VuZCAtIGNhY2hlKTsKfQoKc3RhdGljIGludCBjbGVhcl9jZV9mbGFncyhzdHJ1Y3QgY2FjaGVfZW50cnkgKipjYWNoZSwgaW50IG5yLAoJCQkgICAgaW50IHNlbGVjdF9tYXNrLCBpbnQgY2xlYXJfbWFzaywKCQkJICAgIHN0cnVjdCBleGNsdWRlX2xpc3QgKmVsKQp7CglzdGF0aWMgc3RydWN0IHN0cmJ1ZiBwcmVmaXggPSBTVFJCVUZfSU5JVDsKCglzdHJidWZfcmVzZXQoJnByZWZpeCk7CgoJcmV0dXJuIGNsZWFyX2NlX2ZsYWdzXzEoY2FjaGUsIG5yLAoJCQkJJnByZWZpeCwKCQkJCXNlbGVjdF9tYXNrLCBjbGVhcl9tYXNrLAoJCQkJZWwsIDApOwp9CgovKgogKiBTZXQvQ2xlYXIgQ0VfTkVXX1NLSVBfV09SS1RSRUUgYWNjb3JkaW5nIHRvICRHSVRfRElSL2luZm8vc3BhcnNlLWNoZWNrb3V0CiAqLwpzdGF0aWMgdm9pZCBtYXJrX25ld19za2lwX3dvcmt0cmVlKHN0cnVjdCBleGNsdWRlX2xpc3QgKmVsLAoJCQkJICAgc3RydWN0IGluZGV4X3N0YXRlICp0aGVfaW5kZXgsCgkJCQkgICBpbnQgc2VsZWN0X2ZsYWcsIGludCBza2lwX3d0X2ZsYWcpCnsKCWludCBpOwoKCS8qCgkgKiAxLiBQcmV0ZW5kIHRoZSBuYXJyb3dlc3Qgd29ya3RyZWU6IG9ubHkgdW5tZXJnZWQgZW50cmllcwoJICogYXJlIGNoZWNrZWQgb3V0CgkgKi8KCWZvciAoaSA9IDA7IGkgPCB0aGVfaW5kZXgtPmNhY2hlX25yOyBpKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gdGhlX2luZGV4LT5jYWNoZVtpXTsKCgkJaWYgKHNlbGVjdF9mbGFnICYmICEoY2UtPmNlX2ZsYWdzICYgc2VsZWN0X2ZsYWcpKQoJCQljb250aW51ZTsKCgkJaWYgKCFjZV9zdGFnZShjZSkpCgkJCWNlLT5jZV9mbGFncyB8PSBza2lwX3d0X2ZsYWc7CgkJZWxzZQoJCQljZS0+Y2VfZmxhZ3MgJj0gfnNraXBfd3RfZmxhZzsKCX0KCgkvKgoJICogMi4gV2lkZW4gd29ya3RyZWUgYWNjb3JkaW5nIHRvIHNwYXJzZS1jaGVja291dCBmaWxlLgoJICogTWF0Y2hlZCBlbnRyaWVzIHdpbGwgaGF2ZSBza2lwX3d0X2ZsYWcgY2xlYXJlZCAoaS5lLiAiaW4iKQoJICovCgljbGVhcl9jZV9mbGFncyh0aGVfaW5kZXgtPmNhY2hlLCB0aGVfaW5kZXgtPmNhY2hlX25yLAoJCSAgICAgICBzZWxlY3RfZmxhZywgc2tpcF93dF9mbGFnLCBlbCk7Cn0KCnN0YXRpYyBpbnQgdmVyaWZ5X2Fic2VudChjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKiwKCQkJIGVudW0gdW5wYWNrX3RyZWVzX2Vycm9yX3R5cGVzLAoJCQkgc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICopOwovKgogKiBOLXdheSBtZXJnZSAibGVuIiB0cmVlcy4gIFJldHVybnMgMCBvbiBzdWNjZXNzLCAtMSBvbiBmYWlsdXJlIHRvIG1hbmlwdWxhdGUgdGhlCiAqIHJlc3VsdGluZyBpbmRleCwgLTIgb24gZmFpbHVyZSB0byByZWZsZWN0IHRoZSBjaGFuZ2VzIHRvIHRoZSB3b3JrIHRyZWUuCiAqCiAqIENFX0FEREVELCBDRV9VTlBBQ0tFRCBhbmQgQ0VfTkVXX1NLSVBfV09SS1RSRUUgYXJlIHVzZWQgaW50ZXJuYWxseQogKi8KaW50IHVucGFja190cmVlcyh1bnNpZ25lZCBsZW4sIHN0cnVjdCB0cmVlX2Rlc2MgKnQsIHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJaW50IGksIHJldDsKCXN0YXRpYyBzdHJ1Y3QgY2FjaGVfZW50cnkgKmRmYzsKCXN0cnVjdCBleGNsdWRlX2xpc3QgZWw7CgoJaWYgKGxlbiA+IE1BWF9VTlBBQ0tfVFJFRVMpCgkJZGllKCJ1bnBhY2tfdHJlZXMgdGFrZXMgYXQgbW9zdCAlZCB0cmVlcyIsIE1BWF9VTlBBQ0tfVFJFRVMpOwoKCW1lbXNldCgmZWwsIDAsIHNpemVvZihlbCkpOwoJaWYgKCFjb3JlX2FwcGx5X3NwYXJzZV9jaGVja291dCB8fCAhby0+dXBkYXRlKQoJCW8tPnNraXBfc3BhcnNlX2NoZWNrb3V0ID0gMTsKCWlmICghby0+c2tpcF9zcGFyc2VfY2hlY2tvdXQpIHsKCQljaGFyICpzcGFyc2UgPSBnaXRfcGF0aGR1cCgiaW5mby9zcGFyc2UtY2hlY2tvdXQiKTsKCQlpZiAoYWRkX2V4Y2x1ZGVzX2Zyb21fZmlsZV90b19saXN0KHNwYXJzZSwgIiIsIDAsICZlbCwgTlVMTCkgPCAwKQoJCQlvLT5za2lwX3NwYXJzZV9jaGVja291dCA9IDE7CgkJZWxzZQoJCQlvLT5lbCA9ICZlbDsKCQlmcmVlKHNwYXJzZSk7Cgl9CgoJbWVtc2V0KCZvLT5yZXN1bHQsIDAsIHNpemVvZihvLT5yZXN1bHQpKTsKCW8tPnJlc3VsdC5pbml0aWFsaXplZCA9IDE7CglvLT5yZXN1bHQudGltZXN0YW1wLnNlYyA9IG8tPnNyY19pbmRleC0+dGltZXN0YW1wLnNlYzsKCW8tPnJlc3VsdC50aW1lc3RhbXAubnNlYyA9IG8tPnNyY19pbmRleC0+dGltZXN0YW1wLm5zZWM7CglvLT5yZXN1bHQudmVyc2lvbiA9IG8tPnNyY19pbmRleC0+dmVyc2lvbjsKCW8tPnJlc3VsdC5zcGxpdF9pbmRleCA9IG8tPnNyY19pbmRleC0+c3BsaXRfaW5kZXg7CglpZiAoby0+cmVzdWx0LnNwbGl0X2luZGV4KQoJCW8tPnJlc3VsdC5zcGxpdF9pbmRleC0+cmVmY291bnQrKzsKCWhhc2hjcHkoby0+cmVzdWx0LnNoYTEsIG8tPnNyY19pbmRleC0+c2hhMSk7CglvLT5tZXJnZV9zaXplID0gbGVuOwoJbWFya19hbGxfY2VfdW51c2VkKG8tPnNyY19pbmRleCk7CgoJLyoKCSAqIFNwYXJzZSBjaGVja291dCBsb29wICMxOiBzZXQgTkVXX1NLSVBfV09SS1RSRUUgb24gZXhpc3RpbmcgZW50cmllcwoJICovCglpZiAoIW8tPnNraXBfc3BhcnNlX2NoZWNrb3V0KQoJCW1hcmtfbmV3X3NraXBfd29ya3RyZWUoby0+ZWwsIG8tPnNyY19pbmRleCwgMCwgQ0VfTkVXX1NLSVBfV09SS1RSRUUpOwoKCWlmICghZGZjKQoJCWRmYyA9IHhjYWxsb2MoMSwgY2FjaGVfZW50cnlfc2l6ZSgwKSk7CglvLT5kZl9jb25mbGljdF9lbnRyeSA9IGRmYzsKCglpZiAobGVuKSB7CgkJY29uc3QgY2hhciAqcHJlZml4ID0gby0+cHJlZml4ID8gby0+cHJlZml4IDogIiI7CgkJc3RydWN0IHRyYXZlcnNlX2luZm8gaW5mbzsKCgkJc2V0dXBfdHJhdmVyc2VfaW5mbygmaW5mbywgcHJlZml4KTsKCQlpbmZvLmZuID0gdW5wYWNrX2NhbGxiYWNrOwoJCWluZm8uZGF0YSA9IG87CgkJaW5mby5zaG93X2FsbF9lcnJvcnMgPSBvLT5zaG93X2FsbF9lcnJvcnM7CgkJaW5mby5wYXRoc3BlYyA9IG8tPnBhdGhzcGVjOwoKCQlpZiAoby0+cHJlZml4KSB7CgkJCS8qCgkJCSAqIFVucGFjayBleGlzdGluZyBpbmRleCBlbnRyaWVzIHRoYXQgc29ydCBiZWZvcmUgdGhlCgkJCSAqIHByZWZpeCB0aGUgdHJlZSBpcyBzcGxpY2VkIGludG8uICBOb3RlIHRoYXQgby0+bWVyZ2UKCQkJICogaXMgYWx3YXlzIHRydWUgaW4gdGhpcyBjYXNlLgoJCQkgKi8KCQkJd2hpbGUgKDEpIHsKCQkJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBuZXh0X2NhY2hlX2VudHJ5KG8pOwoJCQkJaWYgKCFjZSkKCQkJCQlicmVhazsKCQkJCWlmIChjZV9pbl90cmF2ZXJzZV9wYXRoKGNlLCAmaW5mbykpCgkJCQkJYnJlYWs7CgkJCQlpZiAodW5wYWNrX2luZGV4X2VudHJ5KGNlLCBvKSA8IDApCgkJCQkJZ290byByZXR1cm5fZmFpbGVkOwoJCQl9CgkJfQoKCQlpZiAodHJhdmVyc2VfdHJlZXMobGVuLCB0LCAmaW5mbykgPCAwKQoJCQlnb3RvIHJldHVybl9mYWlsZWQ7Cgl9CgoJLyogQW55IGxlZnQtb3ZlciBlbnRyaWVzIGluIHRoZSBpbmRleD8gKi8KCWlmIChvLT5tZXJnZSkgewoJCXdoaWxlICgxKSB7CgkJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBuZXh0X2NhY2hlX2VudHJ5KG8pOwoJCQlpZiAoIWNlKQoJCQkJYnJlYWs7CgkJCWlmICh1bnBhY2tfaW5kZXhfZW50cnkoY2UsIG8pIDwgMCkKCQkJCWdvdG8gcmV0dXJuX2ZhaWxlZDsKCQl9Cgl9CgltYXJrX2FsbF9jZV91bnVzZWQoby0+c3JjX2luZGV4KTsKCglpZiAoby0+dHJpdmlhbF9tZXJnZXNfb25seSAmJiBvLT5ub250cml2aWFsX21lcmdlKSB7CgkJcmV0ID0gdW5wYWNrX2ZhaWxlZChvLCAiTWVyZ2UgcmVxdWlyZXMgZmlsZS1sZXZlbCBtZXJnaW5nIik7CgkJZ290byBkb25lOwoJfQoKCWlmICghby0+c2tpcF9zcGFyc2VfY2hlY2tvdXQpIHsKCQlpbnQgZW1wdHlfd29ya3RyZWUgPSAxOwoKCQkvKgoJCSAqIFNwYXJzZSBjaGVja291dCBsb29wICMyOiBzZXQgTkVXX1NLSVBfV09SS1RSRUUgb24gZW50cmllcyBub3QgaW4gbG9vcCAjMQoJCSAqIElmIHRoZSB3aWxsIGhhdmUgTkVXX1NLSVBfV09SS1RSRUUsIGFsc28gc2V0IENFX1NLSVBfV09SS1RSRUUKCQkgKiBzbyBhcHBseV9zcGFyc2VfY2hlY2tvdXQoKSB3b24ndCBhdHRlbXB0IHRvIHJlbW92ZSBpdCBmcm9tIHdvcmt0cmVlCgkJICovCgkJbWFya19uZXdfc2tpcF93b3JrdHJlZShvLT5lbCwgJm8tPnJlc3VsdCwgQ0VfQURERUQsIENFX1NLSVBfV09SS1RSRUUgfCBDRV9ORVdfU0tJUF9XT1JLVFJFRSk7CgoJCXJldCA9IDA7CgkJZm9yIChpID0gMDsgaSA8IG8tPnJlc3VsdC5jYWNoZV9ucjsgaSsrKSB7CgkJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBvLT5yZXN1bHQuY2FjaGVbaV07CgoJCQkvKgoJCQkgKiBFbnRyaWVzIG1hcmtlZCB3aXRoIENFX0FEREVEIGluIG1lcmdlZF9lbnRyeSgpIGRvIG5vdCBoYXZlCgkJCSAqIHZlcmlmeV9hYnNlbnQoKSBjaGVjayAodGhlIGNoZWNrIGlzIGVmZmVjdGl2ZWx5IGRpc2FibGVkCgkJCSAqIGJlY2F1c2UgQ0VfTkVXX1NLSVBfV09SS1RSRUUgaXMgc2V0IHVuY29uZGl0aW9uYWxseSkuCgkJCSAqCgkJCSAqIERvIHRoZSByZWFsIGNoZWNrIG5vdyBiZWNhdXNlIHdlIGhhdmUgaGFkCgkJCSAqIGNvcnJlY3QgQ0VfTkVXX1NLSVBfV09SS1RSRUUKCQkJICovCgkJCWlmIChjZS0+Y2VfZmxhZ3MgJiBDRV9BRERFRCAmJgoJCQkgICAgdmVyaWZ5X2Fic2VudChjZSwgRVJST1JfV09VTERfTE9TRV9VTlRSQUNLRURfT1ZFUldSSVRURU4sIG8pKSB7CgkJCQlpZiAoIW8tPnNob3dfYWxsX2Vycm9ycykKCQkJCQlnb3RvIHJldHVybl9mYWlsZWQ7CgkJCQlyZXQgPSAtMTsKCQkJfQoKCQkJaWYgKGFwcGx5X3NwYXJzZV9jaGVja291dCgmby0+cmVzdWx0LCBjZSwgbykpIHsKCQkJCWlmICghby0+c2hvd19hbGxfZXJyb3JzKQoJCQkJCWdvdG8gcmV0dXJuX2ZhaWxlZDsKCQkJCXJldCA9IC0xOwoJCQl9CgkJCWlmICghY2Vfc2tpcF93b3JrdHJlZShjZSkpCgkJCQllbXB0eV93b3JrdHJlZSA9IDA7CgoJCX0KCQlpZiAocmV0IDwgMCkKCQkJZ290byByZXR1cm5fZmFpbGVkOwoJCS8qCgkJICogU3BhcnNlIGNoZWNrb3V0IGlzIG1lYW50IHRvIG5hcnJvdyBkb3duIGNoZWNrb3V0IGFyZWEKCQkgKiBidXQgaXQgZG9lcyBub3QgbWFrZSBzZW5zZSB0byBuYXJyb3cgZG93biB0byBlbXB0eSB3b3JraW5nCgkJICogdHJlZS4gVGhpcyBpcyB1c3VhbGx5IGEgbWlzdGFrZSBpbiBzcGFyc2UgY2hlY2tvdXQgcnVsZXMuCgkJICogRG8gbm90IGFsbG93IHVzZXJzIHRvIGRvIHRoYXQuCgkJICovCgkJaWYgKG8tPnJlc3VsdC5jYWNoZV9uciAmJiBlbXB0eV93b3JrdHJlZSkgewoJCQlyZXQgPSB1bnBhY2tfZmFpbGVkKG8sICJTcGFyc2UgY2hlY2tvdXQgbGVhdmVzIG5vIGVudHJ5IG9uIHdvcmtpbmcgZGlyZWN0b3J5Iik7CgkJCWdvdG8gZG9uZTsKCQl9Cgl9CgoJby0+c3JjX2luZGV4ID0gTlVMTDsKCXJldCA9IGNoZWNrX3VwZGF0ZXMobykgPyAoLTIpIDogMDsKCWlmIChvLT5kc3RfaW5kZXgpIHsKCQlpZiAoIXJldCkgewoJCQlpZiAoIW8tPnJlc3VsdC5jYWNoZV90cmVlKQoJCQkJby0+cmVzdWx0LmNhY2hlX3RyZWUgPSBjYWNoZV90cmVlKCk7CgkJCWlmICghY2FjaGVfdHJlZV9mdWxseV92YWxpZChvLT5yZXN1bHQuY2FjaGVfdHJlZSkpCgkJCQljYWNoZV90cmVlX3VwZGF0ZSgmby0+cmVzdWx0LAoJCQkJCQkgIFdSSVRFX1RSRUVfU0lMRU5UIHwKCQkJCQkJICBXUklURV9UUkVFX1JFUEFJUik7CgkJfQoJCW1vdmVfaW5kZXhfZXh0ZW5zaW9ucygmby0+cmVzdWx0LCBvLT5kc3RfaW5kZXgpOwoJCWRpc2NhcmRfaW5kZXgoby0+ZHN0X2luZGV4KTsKCQkqby0+ZHN0X2luZGV4ID0gby0+cmVzdWx0OwoJfSBlbHNlIHsKCQlkaXNjYXJkX2luZGV4KCZvLT5yZXN1bHQpOwoJfQoKZG9uZToKCWNsZWFyX2V4Y2x1ZGVfbGlzdCgmZWwpOwoJcmV0dXJuIHJldDsKCnJldHVybl9mYWlsZWQ6CglpZiAoby0+c2hvd19hbGxfZXJyb3JzKQoJCWRpc3BsYXlfZXJyb3JfbXNncyhvKTsKCW1hcmtfYWxsX2NlX3VudXNlZChvLT5zcmNfaW5kZXgpOwoJcmV0ID0gdW5wYWNrX2ZhaWxlZChvLCBOVUxMKTsKCWlmIChvLT5leGl0aW5nX2Vhcmx5KQoJCXJldCA9IDA7Cglnb3RvIGRvbmU7Cn0KCi8qIEhlcmUgY29tZSB0aGUgbWVyZ2UgZnVuY3Rpb25zICovCgpzdGF0aWMgaW50IHJlamVjdF9tZXJnZShjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQlzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCXJldHVybiBvLT5nZW50bHkgPyAtMSA6CgkJYWRkX3JlamVjdGVkX3BhdGgobywgRVJST1JfV09VTERfT1ZFUldSSVRFLCBjZS0+bmFtZSk7Cn0KCnN0YXRpYyBpbnQgc2FtZShjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmEsIGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqYikKewoJaWYgKCEhYSAhPSAhIWIpCgkJcmV0dXJuIDA7CglpZiAoIWEgJiYgIWIpCgkJcmV0dXJuIDE7CglpZiAoKGEtPmNlX2ZsYWdzIHwgYi0+Y2VfZmxhZ3MpICYgQ0VfQ09ORkxJQ1RFRCkKCQlyZXR1cm4gMDsKCXJldHVybiBhLT5jZV9tb2RlID09IGItPmNlX21vZGUgJiYKCSAgICAgICAhb2lkY21wKCZhLT5vaWQsICZiLT5vaWQpOwp9CgoKLyoKICogV2hlbiBhIENFIGdldHMgdHVybmVkIGludG8gYW4gdW5tZXJnZWQgZW50cnksIHdlCiAqIHdhbnQgaXQgdG8gYmUgdXAtdG8tZGF0ZQogKi8Kc3RhdGljIGludCB2ZXJpZnlfdXB0b2RhdGVfMShjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQkgICAgIHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbywKCQkJICAgICBlbnVtIHVucGFja190cmVlc19lcnJvcl90eXBlcyBlcnJvcl90eXBlKQp7CglzdHJ1Y3Qgc3RhdCBzdDsKCglpZiAoby0+aW5kZXhfb25seSkKCQlyZXR1cm4gMDsKCgkvKgoJICogQ0VfVkFMSUQgYW5kIENFX1NLSVBfV09SS1RSRUUgY2hlYXQsIHdlIGJldHRlciBjaGVjayBhZ2FpbgoJICogaWYgdGhpcyBlbnRyeSBpcyB0cnVseSB1cC10by1kYXRlIGJlY2F1c2UgdGhpcyBmaWxlIG1heSBiZQoJICogb3ZlcndyaXR0ZW4uCgkgKi8KCWlmICgoY2UtPmNlX2ZsYWdzICYgQ0VfVkFMSUQpIHx8IGNlX3NraXBfd29ya3RyZWUoY2UpKQoJCTsgLyoga2VlcCBjaGVja2luZyAqLwoJZWxzZSBpZiAoby0+cmVzZXQgfHwgY2VfdXB0b2RhdGUoY2UpKQoJCXJldHVybiAwOwoKCWlmICghbHN0YXQoY2UtPm5hbWUsICZzdCkpIHsKCQlpbnQgZmxhZ3MgPSBDRV9NQVRDSF9JR05PUkVfVkFMSUR8Q0VfTUFUQ0hfSUdOT1JFX1NLSVBfV09SS1RSRUU7CgkJdW5zaWduZWQgY2hhbmdlZCA9IGllX21hdGNoX3N0YXQoby0+c3JjX2luZGV4LCBjZSwgJnN0LCBmbGFncyk7CgoJCWlmIChzdWJtb2R1bGVfZnJvbV9jZShjZSkpIHsKCQkJaW50IHIgPSBjaGVja19zdWJtb2R1bGVfbW92ZV9oZWFkKGNlLAoJCQkJIkhFQUQiLCBvaWRfdG9faGV4KCZjZS0+b2lkKSwgbyk7CgkJCWlmIChyKQoJCQkJcmV0dXJuIG8tPmdlbnRseSA/IC0xIDoKCQkJCQlhZGRfcmVqZWN0ZWRfcGF0aChvLCBlcnJvcl90eXBlLCBjZS0+bmFtZSk7CgkJCXJldHVybiAwOwoJCX0KCgkJaWYgKCFjaGFuZ2VkKQoJCQlyZXR1cm4gMDsKCQkvKgoJCSAqIEhpc3RvcmljIGRlZmF1bHQgcG9saWN5IHdhcyB0byBhbGxvdyBzdWJtb2R1bGUgdG8gYmUgb3V0CgkJICogb2Ygc3luYyB3cnQgdGhlIHN1cGVycHJvamVjdCBpbmRleC4gSWYgdGhlIHN1Ym1vZHVsZSB3YXMKCQkgKiBub3QgY29uc2lkZXJlZCBpbnRlcmVzdGluZyBhYm92ZSwgd2UgZG9uJ3QgY2FyZSBoZXJlLgoJCSAqLwoJCWlmIChTX0lTR0lUTElOSyhjZS0+Y2VfbW9kZSkpCgkJCXJldHVybiAwOwoKCQllcnJubyA9IDA7Cgl9CglpZiAoZXJybm8gPT0gRU5PRU5UKQoJCXJldHVybiAwOwoJcmV0dXJuIG8tPmdlbnRseSA/IC0xIDoKCQlhZGRfcmVqZWN0ZWRfcGF0aChvLCBlcnJvcl90eXBlLCBjZS0+bmFtZSk7Cn0KCnN0YXRpYyBpbnQgdmVyaWZ5X3VwdG9kYXRlKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCSAgIHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJaWYgKCFvLT5za2lwX3NwYXJzZV9jaGVja291dCAmJiAoY2UtPmNlX2ZsYWdzICYgQ0VfTkVXX1NLSVBfV09SS1RSRUUpKQoJCXJldHVybiAwOwoJcmV0dXJuIHZlcmlmeV91cHRvZGF0ZV8xKGNlLCBvLCBFUlJPUl9OT1RfVVBUT0RBVEVfRklMRSk7Cn0KCnN0YXRpYyBpbnQgdmVyaWZ5X3VwdG9kYXRlX3NwYXJzZShjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQkJICBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCXJldHVybiB2ZXJpZnlfdXB0b2RhdGVfMShjZSwgbywgRVJST1JfU1BBUlNFX05PVF9VUFRPREFURV9GSUxFKTsKfQoKc3RhdGljIHZvaWQgaW52YWxpZGF0ZV9jZV9wYXRoKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCSAgICAgICBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCWlmICghY2UpCgkJcmV0dXJuOwoJY2FjaGVfdHJlZV9pbnZhbGlkYXRlX3BhdGgoby0+c3JjX2luZGV4LCBjZS0+bmFtZSk7Cgl1bnRyYWNrZWRfY2FjaGVfaW52YWxpZGF0ZV9wYXRoKG8tPnNyY19pbmRleCwgY2UtPm5hbWUpOwp9CgovKgogKiBDaGVjayB0aGF0IGNoZWNraW5nIG91dCBjZS0+c2hhMSBpbiBzdWJkaXIgY2UtPm5hbWUgaXMgbm90CiAqIGdvaW5nIHRvIG92ZXJ3cml0ZSBhbnkgd29ya2luZyBmaWxlcy4KICoKICogQ3VycmVudGx5LCBnaXQgZG9lcyBub3QgY2hlY2tvdXQgc3VicHJvamVjdHMgZHVyaW5nIGEgc3VwZXJwcm9qZWN0CiAqIGNoZWNrb3V0LCBzbyBpdCBpcyBub3QgZ29pbmcgdG8gb3ZlcndyaXRlIGFueXRoaW5nLgogKi8Kc3RhdGljIGludCB2ZXJpZnlfY2xlYW5fc3VibW9kdWxlKGNvbnN0IGNoYXIgKm9sZF9zaGExLAoJCQkJICBjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQkJICBlbnVtIHVucGFja190cmVlc19lcnJvcl90eXBlcyBlcnJvcl90eXBlLAoJCQkJICBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCWlmICghc3VibW9kdWxlX2Zyb21fY2UoY2UpKQoJCXJldHVybiAwOwoKCXJldHVybiBjaGVja19zdWJtb2R1bGVfbW92ZV9oZWFkKGNlLCBvbGRfc2hhMSwKCQkJCQkgb2lkX3RvX2hleCgmY2UtPm9pZCksIG8pOwp9CgpzdGF0aWMgaW50IHZlcmlmeV9jbGVhbl9zdWJkaXJlY3RvcnkoY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwKCQkJCSAgICAgZW51bSB1bnBhY2tfdHJlZXNfZXJyb3JfdHlwZXMgZXJyb3JfdHlwZSwKCQkJCSAgICAgc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7CgkvKgoJICogd2UgYXJlIGFib3V0IHRvIGV4dHJhY3QgImNlLT5uYW1lIjsgd2Ugd291bGQgbm90IHdhbnQgdG8gbG9zZQoJICogYW55dGhpbmcgaW4gdGhlIGV4aXN0aW5nIGRpcmVjdG9yeSB0aGVyZS4KCSAqLwoJaW50IG5hbWVsZW47CglpbnQgaTsKCXN0cnVjdCBkaXJfc3RydWN0IGQ7CgljaGFyICpwYXRoYnVmOwoJaW50IGNudCA9IDA7CgoJaWYgKFNfSVNHSVRMSU5LKGNlLT5jZV9tb2RlKSkgewoJCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgkJaW50IHN1Yl9oZWFkID0gcmVzb2x2ZV9naXRsaW5rX3JlZihjZS0+bmFtZSwgIkhFQUQiLCBzaGExKTsKCQkvKgoJCSAqIElmIHdlIGFyZSBub3QgZ29pbmcgdG8gdXBkYXRlIHRoZSBzdWJtb2R1bGUsIHRoZW4KCQkgKiB3ZSBkb24ndCBjYXJlLgoJCSAqLwoJCWlmICghc3ViX2hlYWQgJiYgIWhhc2hjbXAoc2hhMSwgY2UtPm9pZC5oYXNoKSkKCQkJcmV0dXJuIDA7CgkJcmV0dXJuIHZlcmlmeV9jbGVhbl9zdWJtb2R1bGUoc3ViX2hlYWQgPyBOVUxMIDogc2hhMV90b19oZXgoc2hhMSksCgkJCQkJICAgICAgY2UsIGVycm9yX3R5cGUsIG8pOwoJfQoKCS8qCgkgKiBGaXJzdCBsZXQncyBtYWtlIHN1cmUgd2UgZG8gbm90IGhhdmUgYSBsb2NhbCBtb2RpZmljYXRpb24KCSAqIGluIHRoYXQgZGlyZWN0b3J5LgoJICovCgluYW1lbGVuID0gY2VfbmFtZWxlbihjZSk7Cglmb3IgKGkgPSBsb2NhdGVfaW5fc3JjX2luZGV4KGNlLCBvKTsKCSAgICAgaSA8IG8tPnNyY19pbmRleC0+Y2FjaGVfbnI7CgkgICAgIGkrKykgewoJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UyID0gby0+c3JjX2luZGV4LT5jYWNoZVtpXTsKCQlpbnQgbGVuID0gY2VfbmFtZWxlbihjZTIpOwoJCWlmIChsZW4gPCBuYW1lbGVuIHx8CgkJICAgIHN0cm5jbXAoY2UtPm5hbWUsIGNlMi0+bmFtZSwgbmFtZWxlbikgfHwKCQkgICAgY2UyLT5uYW1lW25hbWVsZW5dICE9ICcvJykKCQkJYnJlYWs7CgkJLyoKCQkgKiBjZTItPm5hbWUgaXMgYW4gZW50cnkgaW4gdGhlIHN1YmRpcmVjdG9yeSB0byBiZQoJCSAqIHJlbW92ZWQuCgkJICovCgkJaWYgKCFjZV9zdGFnZShjZTIpKSB7CgkJCWlmICh2ZXJpZnlfdXB0b2RhdGUoY2UyLCBvKSkKCQkJCXJldHVybiAtMTsKCQkJYWRkX2VudHJ5KG8sIGNlMiwgQ0VfUkVNT1ZFLCAwKTsKCQkJbWFya19jZV91c2VkKGNlMiwgbyk7CgkJfQoJCWNudCsrOwoJfQoKCS8qCgkgKiBUaGVuIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgd2UgZG8gbm90IGxvc2UgYSBsb2NhbGx5CgkgKiBwcmVzZW50IGZpbGUgdGhhdCBpcyBub3QgaWdub3JlZC4KCSAqLwoJcGF0aGJ1ZiA9IHhzdHJmbXQoIiUuKnMvIiwgbmFtZWxlbiwgY2UtPm5hbWUpOwoKCW1lbXNldCgmZCwgMCwgc2l6ZW9mKGQpKTsKCWlmIChvLT5kaXIpCgkJZC5leGNsdWRlX3Blcl9kaXIgPSBvLT5kaXItPmV4Y2x1ZGVfcGVyX2RpcjsKCWkgPSByZWFkX2RpcmVjdG9yeSgmZCwgJnRoZV9pbmRleCwgcGF0aGJ1ZiwgbmFtZWxlbisxLCBOVUxMKTsKCWlmIChpKQoJCXJldHVybiBvLT5nZW50bHkgPyAtMSA6CgkJCWFkZF9yZWplY3RlZF9wYXRoKG8sIEVSUk9SX05PVF9VUFRPREFURV9ESVIsIGNlLT5uYW1lKTsKCWZyZWUocGF0aGJ1Zik7CglyZXR1cm4gY250Owp9CgovKgogKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gdGhlcmUgd2FzIG5vIGluZGV4IGVudHJ5IGZvciB0aGUgdHJlZSBlbnRyeSAnZHN0JywKICogYnV0IHdlIGZvdW5kIGEgZmlsZSBpbiB0aGUgd29ya2luZyB0cmVlIHRoYXQgJ2xzdGF0KCknIHNhaWQgd2FzIGZpbmUsCiAqIGFuZCB3ZSdyZSBvbiBhIGNhc2UtaW5zZW5zaXRpdmUgZmlsZXN5c3RlbS4KICoKICogU2VlIGlmIHdlIGNhbiBmaW5kIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBpbiB0aGUgaW5kZXggdGhhdCBhbHNvCiAqIG1hdGNoZXMgdGhlIHN0YXQgaW5mb3JtYXRpb24sIGFuZCBhc3N1bWUgaXQncyB0aGF0IG90aGVyIGZpbGUhCiAqLwpzdGF0aWMgaW50IGljYXNlX2V4aXN0cyhzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8sIGNvbnN0IGNoYXIgKm5hbWUsIGludCBsZW4sIHN0cnVjdCBzdGF0ICpzdCkKewoJY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpzcmM7CgoJc3JjID0gaW5kZXhfZmlsZV9leGlzdHMoby0+c3JjX2luZGV4LCBuYW1lLCBsZW4sIDEpOwoJcmV0dXJuIHNyYyAmJiAhaWVfbWF0Y2hfc3RhdChvLT5zcmNfaW5kZXgsIHNyYywgc3QsIENFX01BVENIX0lHTk9SRV9WQUxJRHxDRV9NQVRDSF9JR05PUkVfU0tJUF9XT1JLVFJFRSk7Cn0KCnN0YXRpYyBpbnQgY2hlY2tfb2tfdG9fcmVtb3ZlKGNvbnN0IGNoYXIgKm5hbWUsIGludCBsZW4sIGludCBkdHlwZSwKCQkJICAgICAgY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgc3RydWN0IHN0YXQgKnN0LAoJCQkgICAgICBlbnVtIHVucGFja190cmVlc19lcnJvcl90eXBlcyBlcnJvcl90eXBlLAoJCQkgICAgICBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqcmVzdWx0OwoKCS8qCgkgKiBJdCBtYXkgYmUgdGhhdCB0aGUgJ2xzdGF0KCknIHN1Y2NlZWRlZCBldmVuIHRob3VnaAoJICogdGFyZ2V0ICdjZScgd2FzIGFic2VudCwgYmVjYXVzZSB0aGVyZSBpcyBhbiBvbGQKCSAqIGVudHJ5IHRoYXQgaXMgZGlmZmVyZW50IG9ubHkgaW4gY2FzZS4uCgkgKgoJICogSWdub3JlIHRoYXQgbHN0YXQoKSBpZiBpdCBtYXRjaGVzLgoJICovCglpZiAoaWdub3JlX2Nhc2UgJiYgaWNhc2VfZXhpc3RzKG8sIG5hbWUsIGxlbiwgc3QpKQoJCXJldHVybiAwOwoKCWlmIChvLT5kaXIgJiYKCSAgICBpc19leGNsdWRlZChvLT5kaXIsICZ0aGVfaW5kZXgsIG5hbWUsICZkdHlwZSkpCgkJLyoKCQkgKiBjZS0+bmFtZSBpcyBleHBsaWNpdGx5IGV4Y2x1ZGVkLCBzbyBpdCBpcyBPayB0bwoJCSAqIG92ZXJ3cml0ZSBpdC4KCQkgKi8KCQlyZXR1cm4gMDsKCWlmIChTX0lTRElSKHN0LT5zdF9tb2RlKSkgewoJCS8qCgkJICogV2UgYXJlIGNoZWNraW5nIG91dCBwYXRoICJmb28iIGFuZAoJCSAqIGZvdW5kICJmb28vLiIgaW4gdGhlIHdvcmtpbmcgdHJlZS4KCQkgKiBUaGlzIGlzIHRyaWNreSAtLSBpZiB3ZSBoYXZlIG1vZGlmaWVkCgkJICogZmlsZXMgdGhhdCBhcmUgaW4gImZvby8iIHdlIHdvdWxkIGxvc2UKCQkgKiB0aGVtLgoJCSAqLwoJCWlmICh2ZXJpZnlfY2xlYW5fc3ViZGlyZWN0b3J5KGNlLCBlcnJvcl90eXBlLCBvKSA8IDApCgkJCXJldHVybiAtMTsKCQlyZXR1cm4gMDsKCX0KCgkvKgoJICogVGhlIHByZXZpb3VzIHJvdW5kIG1heSBhbHJlYWR5IGhhdmUgZGVjaWRlZCB0bwoJICogZGVsZXRlIHRoaXMgcGF0aCwgd2hpY2ggaXMgaW4gYSBzdWJkaXJlY3RvcnkgdGhhdAoJICogaXMgYmVpbmcgcmVwbGFjZWQgd2l0aCBhIGJsb2IuCgkgKi8KCXJlc3VsdCA9IGluZGV4X2ZpbGVfZXhpc3RzKCZvLT5yZXN1bHQsIG5hbWUsIGxlbiwgMCk7CglpZiAocmVzdWx0KSB7CgkJaWYgKHJlc3VsdC0+Y2VfZmxhZ3MgJiBDRV9SRU1PVkUpCgkJCXJldHVybiAwOwoJfQoKCXJldHVybiBvLT5nZW50bHkgPyAtMSA6CgkJYWRkX3JlamVjdGVkX3BhdGgobywgZXJyb3JfdHlwZSwgbmFtZSk7Cn0KCi8qCiAqIFdlIGRvIG5vdCB3YW50IHRvIHJlbW92ZSBvciBvdmVyd3JpdGUgYSB3b3JraW5nIHRyZWUgZmlsZSB0aGF0CiAqIGlzIG5vdCB0cmFja2VkLCB1bmxlc3MgaXQgaXMgaWdub3JlZC4KICovCnN0YXRpYyBpbnQgdmVyaWZ5X2Fic2VudF8xKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCSAgIGVudW0gdW5wYWNrX3RyZWVzX2Vycm9yX3R5cGVzIGVycm9yX3R5cGUsCgkJCSAgIHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJaW50IGxlbjsKCXN0cnVjdCBzdGF0IHN0OwoKCWlmIChvLT5pbmRleF9vbmx5IHx8IG8tPnJlc2V0IHx8ICFvLT51cGRhdGUpCgkJcmV0dXJuIDA7CgoJbGVuID0gY2hlY2tfbGVhZGluZ19wYXRoKGNlLT5uYW1lLCBjZV9uYW1lbGVuKGNlKSk7CglpZiAoIWxlbikKCQlyZXR1cm4gMDsKCWVsc2UgaWYgKGxlbiA+IDApIHsKCQljaGFyICpwYXRoOwoJCWludCByZXQ7CgoJCXBhdGggPSB4bWVtZHVweihjZS0+bmFtZSwgbGVuKTsKCQlpZiAobHN0YXQocGF0aCwgJnN0KSkKCQkJcmV0ID0gZXJyb3JfZXJybm8oImNhbm5vdCBzdGF0ICclcyciLCBwYXRoKTsKCQllbHNlIHsKCQkJaWYgKHN1Ym1vZHVsZV9mcm9tX2NlKGNlKSkKCQkJCXJldCA9IGNoZWNrX3N1Ym1vZHVsZV9tb3ZlX2hlYWQoY2UsCgkJCQkJCQkJb2lkX3RvX2hleCgmY2UtPm9pZCksCgkJCQkJCQkJTlVMTCwgbyk7CgkJCWVsc2UKCQkJCXJldCA9IGNoZWNrX29rX3RvX3JlbW92ZShwYXRoLCBsZW4sIERUX1VOS05PV04sIE5VTEwsCgkJCQkJCQkgJnN0LCBlcnJvcl90eXBlLCBvKTsKCQl9CgkJZnJlZShwYXRoKTsKCQlyZXR1cm4gcmV0OwoJfSBlbHNlIGlmIChsc3RhdChjZS0+bmFtZSwgJnN0KSkgewoJCWlmIChlcnJubyAhPSBFTk9FTlQpCgkJCXJldHVybiBlcnJvcl9lcnJubygiY2Fubm90IHN0YXQgJyVzJyIsIGNlLT5uYW1lKTsKCQlyZXR1cm4gMDsKCX0gZWxzZSB7CgkJaWYgKHN1Ym1vZHVsZV9mcm9tX2NlKGNlKSkKCQkJcmV0dXJuIGNoZWNrX3N1Ym1vZHVsZV9tb3ZlX2hlYWQoY2UsIG9pZF90b19oZXgoJmNlLT5vaWQpLAoJCQkJCQkJIE5VTEwsIG8pOwoKCQlyZXR1cm4gY2hlY2tfb2tfdG9fcmVtb3ZlKGNlLT5uYW1lLCBjZV9uYW1lbGVuKGNlKSwKCQkJCQkgIGNlX3RvX2R0eXBlKGNlKSwgY2UsICZzdCwKCQkJCQkgIGVycm9yX3R5cGUsIG8pOwoJfQp9CgpzdGF0aWMgaW50IHZlcmlmeV9hYnNlbnQoY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwKCQkJIGVudW0gdW5wYWNrX3RyZWVzX2Vycm9yX3R5cGVzIGVycm9yX3R5cGUsCgkJCSBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCWlmICghby0+c2tpcF9zcGFyc2VfY2hlY2tvdXQgJiYgKGNlLT5jZV9mbGFncyAmIENFX05FV19TS0lQX1dPUktUUkVFKSkKCQlyZXR1cm4gMDsKCXJldHVybiB2ZXJpZnlfYWJzZW50XzEoY2UsIGVycm9yX3R5cGUsIG8pOwp9CgpzdGF0aWMgaW50IHZlcmlmeV9hYnNlbnRfc3BhcnNlKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCQllbnVtIHVucGFja190cmVlc19lcnJvcl90eXBlcyBlcnJvcl90eXBlLAoJCQkJc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7CgllbnVtIHVucGFja190cmVlc19lcnJvcl90eXBlcyBvcnBoYW5lZF9lcnJvciA9IGVycm9yX3R5cGU7CglpZiAob3JwaGFuZWRfZXJyb3IgPT0gRVJST1JfV09VTERfTE9TRV9VTlRSQUNLRURfT1ZFUldSSVRURU4pCgkJb3JwaGFuZWRfZXJyb3IgPSBFUlJPUl9XT1VMRF9MT1NFX09SUEhBTkVEX09WRVJXUklUVEVOOwoKCXJldHVybiB2ZXJpZnlfYWJzZW50XzEoY2UsIG9ycGhhbmVkX2Vycm9yLCBvKTsKfQoKc3RhdGljIGludCBtZXJnZWRfZW50cnkoY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwKCQkJY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpvbGQsCgkJCXN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJaW50IHVwZGF0ZSA9IENFX1VQREFURTsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqbWVyZ2UgPSBkdXBfZW50cnkoY2UpOwoKCWlmICghb2xkKSB7CgkJLyoKCQkgKiBOZXcgaW5kZXggZW50cmllcy4gSW4gc3BhcnNlIGNoZWNrb3V0LCB0aGUgZm9sbG93aW5nCgkJICogdmVyaWZ5X2Fic2VudCgpIHdpbGwgYmUgZGVsYXllZCB1bnRpbCBhZnRlcgoJCSAqIHRyYXZlcnNlX3RyZWVzKCkgZmluaXNoZXMgaW4gdW5wYWNrX3RyZWVzKCksIHRoZW46CgkJICoKCQkgKiAgLSBDRV9ORVdfU0tJUF9XT1JLVFJFRSB3aWxsIGJlIGNvbXB1dGVkIGNvcnJlY3RseQoJCSAqICAtIHZlcmlmeV9hYnNlbnQoKSBiZSBjYWxsZWQgYWdhaW4sIHRoaXMgdGltZSB3aXRoCgkJICogICAgY29ycmVjdCBDRV9ORVdfU0tJUF9XT1JLVFJFRQoJCSAqCgkJICogdmVyaWZ5X2Fic2VudCgpIGNhbGwgaGVyZSBkb2VzIG5vdGhpbmcgaW4gc3BhcnNlCgkJICogY2hlY2tvdXQgKGkuZS4gby0+c2tpcF9zcGFyc2VfY2hlY2tvdXQgPT0gMCkKCQkgKi8KCQl1cGRhdGUgfD0gQ0VfQURERUQ7CgkJbWVyZ2UtPmNlX2ZsYWdzIHw9IENFX05FV19TS0lQX1dPUktUUkVFOwoKCQlpZiAodmVyaWZ5X2Fic2VudChtZXJnZSwKCQkJCSAgRVJST1JfV09VTERfTE9TRV9VTlRSQUNLRURfT1ZFUldSSVRURU4sIG8pKSB7CgkJCWZyZWUobWVyZ2UpOwoJCQlyZXR1cm4gLTE7CgkJfQoJCWludmFsaWRhdGVfY2VfcGF0aChtZXJnZSwgbyk7CgoJCWlmIChzdWJtb2R1bGVfZnJvbV9jZShjZSkpIHsKCQkJaW50IHJldCA9IGNoZWNrX3N1Ym1vZHVsZV9tb3ZlX2hlYWQoY2UsIE5VTEwsCgkJCQkJCQkgICAgb2lkX3RvX2hleCgmY2UtPm9pZCksCgkJCQkJCQkgICAgbyk7CgkJCWlmIChyZXQpCgkJCQlyZXR1cm4gcmV0OwoJCX0KCgl9IGVsc2UgaWYgKCEob2xkLT5jZV9mbGFncyAmIENFX0NPTkZMSUNURUQpKSB7CgkJLyoKCQkgKiBTZWUgaWYgd2UgY2FuIHJlLXVzZSB0aGUgb2xkIENFIGRpcmVjdGx5PwoJCSAqIFRoYXQgd2F5IHdlIGdldCB0aGUgdXB0b2RhdGUgc3RhdCBpbmZvLgoJCSAqCgkJICogVGhpcyBhbHNvIHJlbW92ZXMgdGhlIFVQREFURSBmbGFnIG9uIGEgbWF0Y2g7IG90aGVyd2lzZQoJCSAqIHdlIHdpbGwgZW5kIHVwIG92ZXJ3cml0aW5nIGxvY2FsIGNoYW5nZXMgaW4gdGhlIHdvcmsgdHJlZS4KCQkgKi8KCQlpZiAoc2FtZShvbGQsIG1lcmdlKSkgewoJCQljb3B5X2NhY2hlX2VudHJ5KG1lcmdlLCBvbGQpOwoJCQl1cGRhdGUgPSAwOwoJCX0gZWxzZSB7CgkJCWlmICh2ZXJpZnlfdXB0b2RhdGUob2xkLCBvKSkgewoJCQkJZnJlZShtZXJnZSk7CgkJCQlyZXR1cm4gLTE7CgkJCX0KCQkJLyogTWlncmF0ZSBvbGQgZmxhZ3Mgb3ZlciAqLwoJCQl1cGRhdGUgfD0gb2xkLT5jZV9mbGFncyAmIChDRV9TS0lQX1dPUktUUkVFIHwgQ0VfTkVXX1NLSVBfV09SS1RSRUUpOwoJCQlpbnZhbGlkYXRlX2NlX3BhdGgob2xkLCBvKTsKCQl9CgoJCWlmIChzdWJtb2R1bGVfZnJvbV9jZShjZSkpIHsKCQkJaW50IHJldCA9IGNoZWNrX3N1Ym1vZHVsZV9tb3ZlX2hlYWQoY2UsIG9pZF90b19oZXgoJm9sZC0+b2lkKSwKCQkJCQkJCSAgICBvaWRfdG9faGV4KCZjZS0+b2lkKSwKCQkJCQkJCSAgICBvKTsKCQkJaWYgKHJldCkKCQkJCXJldHVybiByZXQ7CgkJfQoJfSBlbHNlIHsKCQkvKgoJCSAqIFByZXZpb3VzbHkgdW5tZXJnZWQgZW50cnkgbGVmdCBhcyBhbiBleGlzdGVuY2UKCQkgKiBtYXJrZXIgYnkgcmVhZF9pbmRleF91bm1lcmdlZCgpOwoJCSAqLwoJCWludmFsaWRhdGVfY2VfcGF0aChvbGQsIG8pOwoJfQoKCWRvX2FkZF9lbnRyeShvLCBtZXJnZSwgdXBkYXRlLCBDRV9TVEFHRU1BU0spOwoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBpbnQgZGVsZXRlZF9lbnRyeShjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQkgY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpvbGQsCgkJCSBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCS8qIERpZCBpdCBleGlzdCBpbiB0aGUgaW5kZXg/ICovCglpZiAoIW9sZCkgewoJCWlmICh2ZXJpZnlfYWJzZW50KGNlLCBFUlJPUl9XT1VMRF9MT1NFX1VOVFJBQ0tFRF9SRU1PVkVELCBvKSkKCQkJcmV0dXJuIC0xOwoJCXJldHVybiAwOwoJfQoJaWYgKCEob2xkLT5jZV9mbGFncyAmIENFX0NPTkZMSUNURUQpICYmIHZlcmlmeV91cHRvZGF0ZShvbGQsIG8pKQoJCXJldHVybiAtMTsKCWFkZF9lbnRyeShvLCBjZSwgQ0VfUkVNT1ZFLCAwKTsKCWludmFsaWRhdGVfY2VfcGF0aChjZSwgbyk7CglyZXR1cm4gMTsKfQoKc3RhdGljIGludCBrZWVwX2VudHJ5KGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJICAgICAgc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7CglhZGRfZW50cnkobywgY2UsIDAsIDApOwoJcmV0dXJuIDE7Cn0KCiNpZiBEQlJUX0RFQlVHCnN0YXRpYyB2b2lkIHNob3dfc3RhZ2VfZW50cnkoRklMRSAqbywKCQkJICAgICBjb25zdCBjaGFyICpsYWJlbCwgY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSkKewoJaWYgKCFjZSkKCQlmcHJpbnRmKG8sICIlcyAobWlzc2luZylcbiIsIGxhYmVsKTsKCWVsc2UKCQlmcHJpbnRmKG8sICIlcyUwNm8gJXMgJWRcdCVzXG4iLAoJCQlsYWJlbCwKCQkJY2UtPmNlX21vZGUsCgkJCW9pZF90b19oZXgoJmNlLT5vaWQpLAoJCQljZV9zdGFnZShjZSksCgkJCWNlLT5uYW1lKTsKfQojZW5kaWYKCmludCB0aHJlZXdheV9tZXJnZShjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKiBjb25zdCAqc3RhZ2VzLAoJCSAgIHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICppbmRleDsKCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqaGVhZDsKCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqcmVtb3RlID0gc3RhZ2VzW28tPmhlYWRfaWR4ICsgMV07CglpbnQgY291bnQ7CglpbnQgaGVhZF9tYXRjaCA9IDA7CglpbnQgcmVtb3RlX21hdGNoID0gMDsKCglpbnQgZGZfY29uZmxpY3RfaGVhZCA9IDA7CglpbnQgZGZfY29uZmxpY3RfcmVtb3RlID0gMDsKCglpbnQgYW55X2FuY19taXNzaW5nID0gMDsKCWludCBub19hbmNfZXhpc3RzID0gMTsKCWludCBpOwoKCWZvciAoaSA9IDE7IGkgPCBvLT5oZWFkX2lkeDsgaSsrKSB7CgkJaWYgKCFzdGFnZXNbaV0gfHwgc3RhZ2VzW2ldID09IG8tPmRmX2NvbmZsaWN0X2VudHJ5KQoJCQlhbnlfYW5jX21pc3NpbmcgPSAxOwoJCWVsc2UKCQkJbm9fYW5jX2V4aXN0cyA9IDA7Cgl9CgoJaW5kZXggPSBzdGFnZXNbMF07CgloZWFkID0gc3RhZ2VzW28tPmhlYWRfaWR4XTsKCglpZiAoaGVhZCA9PSBvLT5kZl9jb25mbGljdF9lbnRyeSkgewoJCWRmX2NvbmZsaWN0X2hlYWQgPSAxOwoJCWhlYWQgPSBOVUxMOwoJfQoKCWlmIChyZW1vdGUgPT0gby0+ZGZfY29uZmxpY3RfZW50cnkpIHsKCQlkZl9jb25mbGljdF9yZW1vdGUgPSAxOwoJCXJlbW90ZSA9IE5VTEw7Cgl9CgoJLyoKCSAqIEZpcnN0LCBpZiB0aGVyZSdzIGEgIzE2IHNpdHVhdGlvbiwgbm90ZSB0aGF0IHRvIHByZXZlbnQgIzEzCgkgKiBhbmQgIzE0LgoJICovCglpZiAoIXNhbWUocmVtb3RlLCBoZWFkKSkgewoJCWZvciAoaSA9IDE7IGkgPCBvLT5oZWFkX2lkeDsgaSsrKSB7CgkJCWlmIChzYW1lKHN0YWdlc1tpXSwgaGVhZCkpIHsKCQkJCWhlYWRfbWF0Y2ggPSBpOwoJCQl9CgkJCWlmIChzYW1lKHN0YWdlc1tpXSwgcmVtb3RlKSkgewoJCQkJcmVtb3RlX21hdGNoID0gaTsKCQkJfQoJCX0KCX0KCgkvKgoJICogV2Ugc3RhcnQgd2l0aCBjYXNlcyB3aGVyZSB0aGUgaW5kZXggaXMgYWxsb3dlZCB0byBtYXRjaAoJICogc29tZXRoaW5nIG90aGVyIHRoYW4gdGhlIGhlYWQ6ICMxNChBTFQpIGFuZCAjMkFMVCwgd2hlcmUgaXQKCSAqIGlzIHBlcm1pdHRlZCB0byBtYXRjaCB0aGUgcmVzdWx0IGluc3RlYWQuCgkgKi8KCS8qICMxNCwgIzE0QUxULCAjMkFMVCAqLwoJaWYgKHJlbW90ZSAmJiAhZGZfY29uZmxpY3RfaGVhZCAmJiBoZWFkX21hdGNoICYmICFyZW1vdGVfbWF0Y2gpIHsKCQlpZiAoaW5kZXggJiYgIXNhbWUoaW5kZXgsIHJlbW90ZSkgJiYgIXNhbWUoaW5kZXgsIGhlYWQpKQoJCQlyZXR1cm4gcmVqZWN0X21lcmdlKGluZGV4LCBvKTsKCQlyZXR1cm4gbWVyZ2VkX2VudHJ5KHJlbW90ZSwgaW5kZXgsIG8pOwoJfQoJLyoKCSAqIElmIHdlIGhhdmUgYW4gZW50cnkgaW4gdGhlIGluZGV4IGNhY2hlLCB0aGVuIHdlIHdhbnQgdG8KCSAqIG1ha2Ugc3VyZSB0aGF0IGl0IG1hdGNoZXMgaGVhZC4KCSAqLwoJaWYgKGluZGV4ICYmICFzYW1lKGluZGV4LCBoZWFkKSkKCQlyZXR1cm4gcmVqZWN0X21lcmdlKGluZGV4LCBvKTsKCglpZiAoaGVhZCkgewoJCS8qICM1QUxULCAjMTUgKi8KCQlpZiAoc2FtZShoZWFkLCByZW1vdGUpKQoJCQlyZXR1cm4gbWVyZ2VkX2VudHJ5KGhlYWQsIGluZGV4LCBvKTsKCQkvKiAjMTMsICMzQUxUICovCgkJaWYgKCFkZl9jb25mbGljdF9yZW1vdGUgJiYgcmVtb3RlX21hdGNoICYmICFoZWFkX21hdGNoKQoJCQlyZXR1cm4gbWVyZ2VkX2VudHJ5KGhlYWQsIGluZGV4LCBvKTsKCX0KCgkvKiAjMSAqLwoJaWYgKCFoZWFkICYmICFyZW1vdGUgJiYgYW55X2FuY19taXNzaW5nKQoJCXJldHVybiAwOwoKCS8qCgkgKiBVbmRlciB0aGUgImFnZ3Jlc3NpdmUiIHJ1bGUsIHdlIHJlc29sdmUgbW9zdGx5IHRyaXZpYWwKCSAqIGNhc2VzIHRoYXQgd2UgaGlzdG9yaWNhbGx5IGhhZCBnaXQtbWVyZ2Utb25lLWZpbGUgcmVzb2x2ZS4KCSAqLwoJaWYgKG8tPmFnZ3Jlc3NpdmUpIHsKCQlpbnQgaGVhZF9kZWxldGVkID0gIWhlYWQ7CgkJaW50IHJlbW90ZV9kZWxldGVkID0gIXJlbW90ZTsKCQljb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gTlVMTDsKCgkJaWYgKGluZGV4KQoJCQljZSA9IGluZGV4OwoJCWVsc2UgaWYgKGhlYWQpCgkJCWNlID0gaGVhZDsKCQllbHNlIGlmIChyZW1vdGUpCgkJCWNlID0gcmVtb3RlOwoJCWVsc2UgewoJCQlmb3IgKGkgPSAxOyBpIDwgby0+aGVhZF9pZHg7IGkrKykgewoJCQkJaWYgKHN0YWdlc1tpXSAmJiBzdGFnZXNbaV0gIT0gby0+ZGZfY29uZmxpY3RfZW50cnkpIHsKCQkJCQljZSA9IHN0YWdlc1tpXTsKCQkJCQlicmVhazsKCQkJCX0KCQkJfQoJCX0KCgkJLyoKCQkgKiBEZWxldGVkIGluIGJvdGguCgkJICogRGVsZXRlZCBpbiBvbmUgYW5kIHVuY2hhbmdlZCBpbiB0aGUgb3RoZXIuCgkJICovCgkJaWYgKChoZWFkX2RlbGV0ZWQgJiYgcmVtb3RlX2RlbGV0ZWQpIHx8CgkJICAgIChoZWFkX2RlbGV0ZWQgJiYgcmVtb3RlICYmIHJlbW90ZV9tYXRjaCkgfHwKCQkgICAgKHJlbW90ZV9kZWxldGVkICYmIGhlYWQgJiYgaGVhZF9tYXRjaCkpIHsKCQkJaWYgKGluZGV4KQoJCQkJcmV0dXJuIGRlbGV0ZWRfZW50cnkoaW5kZXgsIGluZGV4LCBvKTsKCQkJaWYgKGNlICYmICFoZWFkX2RlbGV0ZWQpIHsKCQkJCWlmICh2ZXJpZnlfYWJzZW50KGNlLCBFUlJPUl9XT1VMRF9MT1NFX1VOVFJBQ0tFRF9SRU1PVkVELCBvKSkKCQkJCQlyZXR1cm4gLTE7CgkJCX0KCQkJcmV0dXJuIDA7CgkJfQoJCS8qCgkJICogQWRkZWQgaW4gYm90aCwgaWRlbnRpY2FsbHkuCgkJICovCgkJaWYgKG5vX2FuY19leGlzdHMgJiYgaGVhZCAmJiByZW1vdGUgJiYgc2FtZShoZWFkLCByZW1vdGUpKQoJCQlyZXR1cm4gbWVyZ2VkX2VudHJ5KGhlYWQsIGluZGV4LCBvKTsKCgl9CgoJLyogQmVsb3cgYXJlICJubyBtZXJnZSIgY2FzZXMsIHdoaWNoIHJlcXVpcmUgdGhhdCB0aGUgaW5kZXggYmUKCSAqIHVwLXRvLWRhdGUgdG8gYXZvaWQgdGhlIGZpbGVzIGdldHRpbmcgb3ZlcndyaXR0ZW4gd2l0aAoJICogY29uZmxpY3QgcmVzb2x1dGlvbiBmaWxlcy4KCSAqLwoJaWYgKGluZGV4KSB7CgkJaWYgKHZlcmlmeV91cHRvZGF0ZShpbmRleCwgbykpCgkJCXJldHVybiAtMTsKCX0KCglvLT5ub250cml2aWFsX21lcmdlID0gMTsKCgkvKiAjMiwgIzMsICM0LCAjNiwgIzcsICM5LCAjMTAsICMxMS4gKi8KCWNvdW50ID0gMDsKCWlmICghaGVhZF9tYXRjaCB8fCAhcmVtb3RlX21hdGNoKSB7CgkJZm9yIChpID0gMTsgaSA8IG8tPmhlYWRfaWR4OyBpKyspIHsKCQkJaWYgKHN0YWdlc1tpXSAmJiBzdGFnZXNbaV0gIT0gby0+ZGZfY29uZmxpY3RfZW50cnkpIHsKCQkJCWtlZXBfZW50cnkoc3RhZ2VzW2ldLCBvKTsKCQkJCWNvdW50Kys7CgkJCQlicmVhazsKCQkJfQoJCX0KCX0KI2lmIERCUlRfREVCVUcKCWVsc2UgewoJCWZwcmludGYoc3RkZXJyLCAicmVhZC10cmVlOiB3YXJuaW5nICMxNiBkZXRlY3RlZFxuIik7CgkJc2hvd19zdGFnZV9lbnRyeShzdGRlcnIsICJoZWFkICAgIiwgc3RhZ2VzW2hlYWRfbWF0Y2hdKTsKCQlzaG93X3N0YWdlX2VudHJ5KHN0ZGVyciwgInJlbW90ZSAiLCBzdGFnZXNbcmVtb3RlX21hdGNoXSk7Cgl9CiNlbmRpZgoJaWYgKGhlYWQpIHsgY291bnQgKz0ga2VlcF9lbnRyeShoZWFkLCBvKTsgfQoJaWYgKHJlbW90ZSkgeyBjb3VudCArPSBrZWVwX2VudHJ5KHJlbW90ZSwgbyk7IH0KCXJldHVybiBjb3VudDsKfQoKLyoKICogVHdvLXdheSBtZXJnZS4KICoKICogVGhlIHJ1bGUgaXMgdG8gImNhcnJ5IGZvcndhcmQiIHdoYXQgaXMgaW4gdGhlIGluZGV4IHdpdGhvdXQgbG9zaW5nCiAqIGluZm9ybWF0aW9uIGFjcm9zcyBhICJmYXN0LWZvcndhcmQiLCBmYXZvcmluZyBhIHN1Y2Nlc3NmdWwgbWVyZ2UKICogb3ZlciBhIG1lcmdlIGZhaWx1cmUgd2hlbiBpdCBtYWtlcyBzZW5zZS4gIEZvciBkZXRhaWxzIG9mIHRoZQogKiAiY2FycnkgZm9yd2FyZCIgcnVsZSwgcGxlYXNlIHNlZSA8RG9jdW1lbnRhdGlvbi9naXQtcmVhZC10cmVlLnR4dD4uCiAqCiAqLwppbnQgdHdvd2F5X21lcmdlKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqIGNvbnN0ICpzcmMsCgkJIHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjdXJyZW50ID0gc3JjWzBdOwoJY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpvbGR0cmVlID0gc3JjWzFdOwoJY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpuZXd0cmVlID0gc3JjWzJdOwoKCWlmIChvLT5tZXJnZV9zaXplICE9IDIpCgkJcmV0dXJuIGVycm9yKCJDYW5ub3QgZG8gYSB0d293YXkgbWVyZ2Ugb2YgJWQgdHJlZXMiLAoJCQkgICAgIG8tPm1lcmdlX3NpemUpOwoKCWlmIChvbGR0cmVlID09IG8tPmRmX2NvbmZsaWN0X2VudHJ5KQoJCW9sZHRyZWUgPSBOVUxMOwoJaWYgKG5ld3RyZWUgPT0gby0+ZGZfY29uZmxpY3RfZW50cnkpCgkJbmV3dHJlZSA9IE5VTEw7CgoJaWYgKGN1cnJlbnQpIHsKCQlpZiAoY3VycmVudC0+Y2VfZmxhZ3MgJiBDRV9DT05GTElDVEVEKSB7CgkJCWlmIChzYW1lKG9sZHRyZWUsIG5ld3RyZWUpIHx8IG8tPnJlc2V0KSB7CgkJCQlpZiAoIW5ld3RyZWUpCgkJCQkJcmV0dXJuIGRlbGV0ZWRfZW50cnkoY3VycmVudCwgY3VycmVudCwgbyk7CgkJCQllbHNlCgkJCQkJcmV0dXJuIG1lcmdlZF9lbnRyeShuZXd0cmVlLCBjdXJyZW50LCBvKTsKCQkJfQoJCQlyZXR1cm4gcmVqZWN0X21lcmdlKGN1cnJlbnQsIG8pOwoJCX0gZWxzZSBpZiAoKCFvbGR0cmVlICYmICFuZXd0cmVlKSB8fCAvKiA0IGFuZCA1ICovCgkJCSAoIW9sZHRyZWUgJiYgbmV3dHJlZSAmJgoJCQkgIHNhbWUoY3VycmVudCwgbmV3dHJlZSkpIHx8IC8qIDYgYW5kIDcgKi8KCQkJIChvbGR0cmVlICYmIG5ld3RyZWUgJiYKCQkJICBzYW1lKG9sZHRyZWUsIG5ld3RyZWUpKSB8fCAvKiAxNCBhbmQgMTUgKi8KCQkJIChvbGR0cmVlICYmIG5ld3RyZWUgJiYKCQkJICAhc2FtZShvbGR0cmVlLCBuZXd0cmVlKSAmJiAvKiAxOCBhbmQgMTkgKi8KCQkJICBzYW1lKGN1cnJlbnQsIG5ld3RyZWUpKSkgewoJCQlyZXR1cm4ga2VlcF9lbnRyeShjdXJyZW50LCBvKTsKCQl9IGVsc2UgaWYgKG9sZHRyZWUgJiYgIW5ld3RyZWUgJiYgc2FtZShjdXJyZW50LCBvbGR0cmVlKSkgewoJCQkvKiAxMCBvciAxMSAqLwoJCQlyZXR1cm4gZGVsZXRlZF9lbnRyeShvbGR0cmVlLCBjdXJyZW50LCBvKTsKCQl9IGVsc2UgaWYgKG9sZHRyZWUgJiYgbmV3dHJlZSAmJgoJCQkgc2FtZShjdXJyZW50LCBvbGR0cmVlKSAmJiAhc2FtZShjdXJyZW50LCBuZXd0cmVlKSkgewoJCQkvKiAyMCBvciAyMSAqLwoJCQlyZXR1cm4gbWVyZ2VkX2VudHJ5KG5ld3RyZWUsIGN1cnJlbnQsIG8pOwoJCX0gZWxzZQoJCQlyZXR1cm4gcmVqZWN0X21lcmdlKGN1cnJlbnQsIG8pOwoJfQoJZWxzZSBpZiAobmV3dHJlZSkgewoJCWlmIChvbGR0cmVlICYmICFvLT5pbml0aWFsX2NoZWNrb3V0KSB7CgkJCS8qCgkJCSAqIGRlbGV0aW9uIG9mIHRoZSBwYXRoIHdhcyBzdGFnZWQ7CgkJCSAqLwoJCQlpZiAoc2FtZShvbGR0cmVlLCBuZXd0cmVlKSkKCQkJCXJldHVybiAxOwoJCQlyZXR1cm4gcmVqZWN0X21lcmdlKG9sZHRyZWUsIG8pOwoJCX0KCQlyZXR1cm4gbWVyZ2VkX2VudHJ5KG5ld3RyZWUsIGN1cnJlbnQsIG8pOwoJfQoJcmV0dXJuIGRlbGV0ZWRfZW50cnkob2xkdHJlZSwgY3VycmVudCwgbyk7Cn0KCi8qCiAqIEJpbmQgbWVyZ2UuCiAqCiAqIEtlZXAgdGhlIGluZGV4IGVudHJpZXMgYXQgc3RhZ2UwLCBjb2xsYXBzZSBzdGFnZTEgYnV0IG1ha2Ugc3VyZQogKiBzdGFnZTAgZG9lcyBub3QgaGF2ZSBhbnl0aGluZyB0aGVyZS4KICovCmludCBiaW5kX21lcmdlKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqIGNvbnN0ICpzcmMsCgkgICAgICAgc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7Cgljb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKm9sZCA9IHNyY1swXTsKCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqYSA9IHNyY1sxXTsKCglpZiAoby0+bWVyZ2Vfc2l6ZSAhPSAxKQoJCXJldHVybiBlcnJvcigiQ2Fubm90IGRvIGEgYmluZCBtZXJnZSBvZiAlZCB0cmVlcyIsCgkJCSAgICAgby0+bWVyZ2Vfc2l6ZSk7CglpZiAoYSAmJiBvbGQpCgkJcmV0dXJuIG8tPmdlbnRseSA/IC0xIDoKCQkJZXJyb3IoRVJST1JNU0cobywgRVJST1JfQklORF9PVkVSTEFQKSwKCQkJICAgICAgc3VwZXJfcHJlZml4ZWQoYS0+bmFtZSksCgkJCSAgICAgIHN1cGVyX3ByZWZpeGVkKG9sZC0+bmFtZSkpOwoJaWYgKCFhKQoJCXJldHVybiBrZWVwX2VudHJ5KG9sZCwgbyk7CgllbHNlCgkJcmV0dXJuIG1lcmdlZF9lbnRyeShhLCBOVUxMLCBvKTsKfQoKLyoKICogT25lLXdheSBtZXJnZS4KICoKICogVGhlIHJ1bGUgaXM6CiAqIC0gdGFrZSB0aGUgc3RhdCBpbmZvcm1hdGlvbiBmcm9tIHN0YWdlMCwgdGFrZSB0aGUgZGF0YSBmcm9tIHN0YWdlMQogKi8KaW50IG9uZXdheV9tZXJnZShjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKiBjb25zdCAqc3JjLAoJCSBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqb2xkID0gc3JjWzBdOwoJY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICphID0gc3JjWzFdOwoKCWlmIChvLT5tZXJnZV9zaXplICE9IDEpCgkJcmV0dXJuIGVycm9yKCJDYW5ub3QgZG8gYSBvbmV3YXkgbWVyZ2Ugb2YgJWQgdHJlZXMiLAoJCQkgICAgIG8tPm1lcmdlX3NpemUpOwoKCWlmICghYSB8fCBhID09IG8tPmRmX2NvbmZsaWN0X2VudHJ5KQoJCXJldHVybiBkZWxldGVkX2VudHJ5KG9sZCwgb2xkLCBvKTsKCglpZiAob2xkICYmIHNhbWUob2xkLCBhKSkgewoJCWludCB1cGRhdGUgPSAwOwoJCWlmIChvLT5yZXNldCAmJiBvLT51cGRhdGUgJiYgIWNlX3VwdG9kYXRlKG9sZCkgJiYgIWNlX3NraXBfd29ya3RyZWUob2xkKSkgewoJCQlzdHJ1Y3Qgc3RhdCBzdDsKCQkJaWYgKGxzdGF0KG9sZC0+bmFtZSwgJnN0KSB8fAoJCQkgICAgaWVfbWF0Y2hfc3RhdChvLT5zcmNfaW5kZXgsIG9sZCwgJnN0LCBDRV9NQVRDSF9JR05PUkVfVkFMSUR8Q0VfTUFUQ0hfSUdOT1JFX1NLSVBfV09SS1RSRUUpKQoJCQkJdXBkYXRlIHw9IENFX1VQREFURTsKCQl9CgkJYWRkX2VudHJ5KG8sIG9sZCwgdXBkYXRlLCAwKTsKCQlyZXR1cm4gMDsKCX0KCXJldHVybiBtZXJnZWRfZW50cnkoYSwgb2xkLCBvKTsKfQo=",
    "text": "#define NO_THE_INDEX_COMPATIBILITY_MACROS\n#include \"cache.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"tree.h\"\n#include \"tree-walk.h\"\n#include \"cache-tree.h\"\n#include \"unpack-trees.h\"\n#include \"progress.h\"\n#include \"refs.h\"\n#include \"attr.h\"\n#include \"split-index.h\"\n#include \"dir.h\"\n#include \"submodule.h\"\n#include \"submodule-config.h\"\n\n/*\n * Error messages expected by scripts out of plumbing commands such as\n * read-tree.  Non-scripted Porcelain is not required to use these messages\n * and in fact are encouraged to reword them to better suit their particular\n * situation better.  See how \"git checkout\" and \"git merge\" replaces\n * them using setup_unpack_trees_porcelain(), for example.\n */\nstatic const char *unpack_plumbing_errors[NB_UNPACK_TREES_ERROR_TYPES] = {\n\t/* ERROR_WOULD_OVERWRITE */\n\t\"Entry '%s' would be overwritten by merge. Cannot merge.\",\n\n\t/* ERROR_NOT_UPTODATE_FILE */\n\t\"Entry '%s' not uptodate. Cannot merge.\",\n\n\t/* ERROR_NOT_UPTODATE_DIR */\n\t\"Updating '%s' would lose untracked files in it\",\n\n\t/* ERROR_WOULD_LOSE_UNTRACKED_OVERWRITTEN */\n\t\"Untracked working tree file '%s' would be overwritten by merge.\",\n\n\t/* ERROR_WOULD_LOSE_UNTRACKED_REMOVED */\n\t\"Untracked working tree file '%s' would be removed by merge.\",\n\n\t/* ERROR_BIND_OVERLAP */\n\t\"Entry '%s' overlaps with '%s'.  Cannot bind.\",\n\n\t/* ERROR_SPARSE_NOT_UPTODATE_FILE */\n\t\"Entry '%s' not uptodate. Cannot update sparse checkout.\",\n\n\t/* ERROR_WOULD_LOSE_ORPHANED_OVERWRITTEN */\n\t\"Working tree file '%s' would be overwritten by sparse checkout update.\",\n\n\t/* ERROR_WOULD_LOSE_ORPHANED_REMOVED */\n\t\"Working tree file '%s' would be removed by sparse checkout update.\",\n\n\t/* ERROR_WOULD_LOSE_SUBMODULE */\n\t\"Submodule '%s' cannot checkout new HEAD.\",\n};\n\n#define ERRORMSG(o,type) \\\n\t( ((o) && (o)->msgs[(type)]) \\\n\t  ? ((o)->msgs[(type)])      \\\n\t  : (unpack_plumbing_errors[(type)]) )\n\nstatic const char *super_prefixed(const char *path)\n{\n\t/*\n\t * It is necessary and sufficient to have two static buffers\n\t * here, as the return value of this function is fed to\n\t * error() using the unpack_*_errors[] templates we see above.\n\t */\n\tstatic struct strbuf buf[2] = {STRBUF_INIT, STRBUF_INIT};\n\tstatic int super_prefix_len = -1;\n\tstatic unsigned idx = ARRAY_SIZE(buf) - 1;\n\n\tif (super_prefix_len < 0) {\n\t\tconst char *super_prefix = get_super_prefix();\n\t\tif (!super_prefix) {\n\t\t\tsuper_prefix_len = 0;\n\t\t} else {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < ARRAY_SIZE(buf); i++)\n\t\t\t\tstrbuf_addstr(&buf[i], super_prefix);\n\t\t\tsuper_prefix_len = buf[0].len;\n\t\t}\n\t}\n\n\tif (!super_prefix_len)\n\t\treturn path;\n\n\tif (++idx >= ARRAY_SIZE(buf))\n\t\tidx = 0;\n\n\tstrbuf_setlen(&buf[idx], super_prefix_len);\n\tstrbuf_addstr(&buf[idx], path);\n\n\treturn buf[idx].buf;\n}\n\nvoid setup_unpack_trees_porcelain(struct unpack_trees_options *opts,\n\t\t\t\t  const char *cmd)\n{\n\tint i;\n\tconst char **msgs = opts->msgs;\n\tconst char *msg;\n\n\tif (!strcmp(cmd, \"checkout\"))\n\t\tmsg = advice_commit_before_merge\n\t\t      ? _(\"Your local changes to the following files would be overwritten by checkout:\\n%%s\"\n\t\t\t  \"Please commit your changes or stash them before you switch branches.\")\n\t\t      : _(\"Your local changes to the following files would be overwritten by checkout:\\n%%s\");\n\telse if (!strcmp(cmd, \"merge\"))\n\t\tmsg = advice_commit_before_merge\n\t\t      ? _(\"Your local changes to the following files would be overwritten by merge:\\n%%s\"\n\t\t\t  \"Please commit your changes or stash them before you merge.\")\n\t\t      : _(\"Your local changes to the following files would be overwritten by merge:\\n%%s\");\n\telse\n\t\tmsg = advice_commit_before_merge\n\t\t      ? _(\"Your local changes to the following files would be overwritten by %s:\\n%%s\"\n\t\t\t  \"Please commit your changes or stash them before you %s.\")\n\t\t      : _(\"Your local changes to the following files would be overwritten by %s:\\n%%s\");\n\tmsgs[ERROR_WOULD_OVERWRITE] = msgs[ERROR_NOT_UPTODATE_FILE] =\n\t\txstrfmt(msg, cmd, cmd);\n\n\tmsgs[ERROR_NOT_UPTODATE_DIR] =\n\t\t_(\"Updating the following directories would lose untracked files in them:\\n%s\");\n\n\tif (!strcmp(cmd, \"checkout\"))\n\t\tmsg = advice_commit_before_merge\n\t\t      ? _(\"The following untracked working tree files would be removed by checkout:\\n%%s\"\n\t\t\t  \"Please move or remove them before you switch branches.\")\n\t\t      : _(\"The following untracked working tree files would be removed by checkout:\\n%%s\");\n\telse if (!strcmp(cmd, \"merge\"))\n\t\tmsg = advice_commit_before_merge\n\t\t      ? _(\"The following untracked working tree files would be removed by merge:\\n%%s\"\n\t\t\t  \"Please move or remove them before you merge.\")\n\t\t      : _(\"The following untracked working tree files would be removed by merge:\\n%%s\");\n\telse\n\t\tmsg = advice_commit_before_merge\n\t\t      ? _(\"The following untracked working tree files would be removed by %s:\\n%%s\"\n\t\t\t  \"Please move or remove them before you %s.\")\n\t\t      : _(\"The following untracked working tree files would be removed by %s:\\n%%s\");\n\tmsgs[ERROR_WOULD_LOSE_UNTRACKED_REMOVED] = xstrfmt(msg, cmd, cmd);\n\n\tif (!strcmp(cmd, \"checkout\"))\n\t\tmsg = advice_commit_before_merge\n\t\t      ? _(\"The following untracked working tree files would be overwritten by checkout:\\n%%s\"\n\t\t\t  \"Please move or remove them before you switch branches.\")\n\t\t      : _(\"The following untracked working tree files would be overwritten by checkout:\\n%%s\");\n\telse if (!strcmp(cmd, \"merge\"))\n\t\tmsg = advice_commit_before_merge\n\t\t      ? _(\"The following untracked working tree files would be overwritten by merge:\\n%%s\"\n\t\t\t  \"Please move or remove them before you merge.\")\n\t\t      : _(\"The following untracked working tree files would be overwritten by merge:\\n%%s\");\n\telse\n\t\tmsg = advice_commit_before_merge\n\t\t      ? _(\"The following untracked working tree files would be overwritten by %s:\\n%%s\"\n\t\t\t  \"Please move or remove them before you %s.\")\n\t\t      : _(\"The following untracked working tree files would be overwritten by %s:\\n%%s\");\n\tmsgs[ERROR_WOULD_LOSE_UNTRACKED_OVERWRITTEN] = xstrfmt(msg, cmd, cmd);\n\n\t/*\n\t * Special case: ERROR_BIND_OVERLAP refers to a pair of paths, we\n\t * cannot easily display it as a list.\n\t */\n\tmsgs[ERROR_BIND_OVERLAP] = _(\"Entry '%s' overlaps with '%s'.  Cannot bind.\");\n\n\tmsgs[ERROR_SPARSE_NOT_UPTODATE_FILE] =\n\t\t_(\"Cannot update sparse checkout: the following entries are not up-to-date:\\n%s\");\n\tmsgs[ERROR_WOULD_LOSE_ORPHANED_OVERWRITTEN] =\n\t\t_(\"The following working tree files would be overwritten by sparse checkout update:\\n%s\");\n\tmsgs[ERROR_WOULD_LOSE_ORPHANED_REMOVED] =\n\t\t_(\"The following working tree files would be removed by sparse checkout update:\\n%s\");\n\tmsgs[ERROR_WOULD_LOSE_SUBMODULE] =\n\t\t_(\"Cannot update submodule:\\n%s\");\n\n\topts->show_all_errors = 1;\n\t/* rejected paths may not have a static buffer */\n\tfor (i = 0; i < ARRAY_SIZE(opts->unpack_rejects); i++)\n\t\topts->unpack_rejects[i].strdup_strings = 1;\n}\n\nstatic int do_add_entry(struct unpack_trees_options *o, struct cache_entry *ce,\n\t\t\t unsigned int set, unsigned int clear)\n{\n\tclear |= CE_HASHED;\n\n\tif (set & CE_REMOVE)\n\t\tset |= CE_WT_REMOVE;\n\n\tce->ce_flags = (ce->ce_flags & ~clear) | set;\n\treturn add_index_entry(&o->result, ce,\n\t\t\t       ADD_CACHE_OK_TO_ADD | ADD_CACHE_OK_TO_REPLACE);\n}\n\nstatic struct cache_entry *dup_entry(const struct cache_entry *ce)\n{\n\tunsigned int size = ce_size(ce);\n\tstruct cache_entry *new = xmalloc(size);\n\n\tmemcpy(new, ce, size);\n\treturn new;\n}\n\nstatic void add_entry(struct unpack_trees_options *o,\n\t\t      const struct cache_entry *ce,\n\t\t      unsigned int set, unsigned int clear)\n{\n\tdo_add_entry(o, dup_entry(ce), set, clear);\n}\n\n/*\n * add error messages on path <path>\n * corresponding to the type <e> with the message <msg>\n * indicating if it should be display in porcelain or not\n */\nstatic int add_rejected_path(struct unpack_trees_options *o,\n\t\t\t     enum unpack_trees_error_types e,\n\t\t\t     const char *path)\n{\n\tif (!o->show_all_errors)\n\t\treturn error(ERRORMSG(o, e), super_prefixed(path));\n\n\t/*\n\t * Otherwise, insert in a list for future display by\n\t * display_error_msgs()\n\t */\n\tstring_list_append(&o->unpack_rejects[e], path);\n\treturn -1;\n}\n\n/*\n * display all the error messages stored in a nice way\n */\nstatic void display_error_msgs(struct unpack_trees_options *o)\n{\n\tint e, i;\n\tint something_displayed = 0;\n\tfor (e = 0; e < NB_UNPACK_TREES_ERROR_TYPES; e++) {\n\t\tstruct string_list *rejects = &o->unpack_rejects[e];\n\t\tif (rejects->nr > 0) {\n\t\t\tstruct strbuf path = STRBUF_INIT;\n\t\t\tsomething_displayed = 1;\n\t\t\tfor (i = 0; i < rejects->nr; i++)\n\t\t\t\tstrbuf_addf(&path, \"\\t%s\\n\", rejects->items[i].string);\n\t\t\terror(ERRORMSG(o, e), super_prefixed(path.buf));\n\t\t\tstrbuf_release(&path);\n\t\t}\n\t\tstring_list_clear(rejects, 0);\n\t}\n\tif (something_displayed)\n\t\tfprintf(stderr, _(\"Aborting\\n\"));\n}\n\nstatic int check_submodule_move_head(const struct cache_entry *ce,\n\t\t\t\t     const char *old_id,\n\t\t\t\t     const char *new_id,\n\t\t\t\t     struct unpack_trees_options *o)\n{\n\tunsigned flags = SUBMODULE_MOVE_HEAD_DRY_RUN;\n\tconst struct submodule *sub = submodule_from_ce(ce);\n\tif (!sub)\n\t\treturn 0;\n\n\tif (o->reset)\n\t\tflags |= SUBMODULE_MOVE_HEAD_FORCE;\n\n\tswitch (sub->update_strategy.type) {\n\tcase SM_UPDATE_UNSPECIFIED:\n\tcase SM_UPDATE_CHECKOUT:\n\t\tif (submodule_move_head(ce->name, old_id, new_id, flags))\n\t\t\treturn o->gently ? -1 :\n\t\t\t\tadd_rejected_path(o, ERROR_WOULD_LOSE_SUBMODULE, ce->name);\n\t\treturn 0;\n\tcase SM_UPDATE_NONE:\n\t\treturn 0;\n\tcase SM_UPDATE_REBASE:\n\tcase SM_UPDATE_MERGE:\n\tcase SM_UPDATE_COMMAND:\n\tdefault:\n\t\twarning(_(\"submodule update strategy not supported for submodule '%s'\"), ce->name);\n\t\treturn -1;\n\t}\n}\n\nstatic void reload_gitmodules_file(struct index_state *index,\n\t\t\t\t   struct checkout *state)\n{\n\tint i;\n\tfor (i = 0; i < index->cache_nr; i++) {\n\t\tstruct cache_entry *ce = index->cache[i];\n\t\tif (ce->ce_flags & CE_UPDATE) {\n\t\t\tint r = strcmp(ce->name, GITMODULES_FILE);\n\t\t\tif (r < 0)\n\t\t\t\tcontinue;\n\t\t\telse if (r == 0) {\n\t\t\t\tsubmodule_free();\n\t\t\t\tcheckout_entry(ce, state, NULL);\n\t\t\t\tgitmodules_config();\n\t\t\t\tgit_config(submodule_config, NULL);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*\n * Unlink the last component and schedule the leading directories for\n * removal, such that empty directories get removed.\n */\nstatic void unlink_entry(const struct cache_entry *ce)\n{\n\tconst struct submodule *sub = submodule_from_ce(ce);\n\tif (sub) {\n\t\tswitch (sub->update_strategy.type) {\n\t\tcase SM_UPDATE_UNSPECIFIED:\n\t\tcase SM_UPDATE_CHECKOUT:\n\t\tcase SM_UPDATE_REBASE:\n\t\tcase SM_UPDATE_MERGE:\n\t\t\t/* state.force is set at the caller. */\n\t\t\tsubmodule_move_head(ce->name, \"HEAD\", NULL,\n\t\t\t\t\t    SUBMODULE_MOVE_HEAD_FORCE);\n\t\t\tbreak;\n\t\tcase SM_UPDATE_NONE:\n\t\tcase SM_UPDATE_COMMAND:\n\t\t\treturn; /* Do not touch the submodule. */\n\t\t}\n\t}\n\tif (!check_leading_path(ce->name, ce_namelen(ce)))\n\t\treturn;\n\tif (remove_or_warn(ce->ce_mode, ce->name))\n\t\treturn;\n\tschedule_dir_for_removal(ce->name, ce_namelen(ce));\n}\n\nstatic struct progress *get_progress(struct unpack_trees_options *o)\n{\n\tunsigned cnt = 0, total = 0;\n\tstruct index_state *index = &o->result;\n\n\tif (!o->update || !o->verbose_update)\n\t\treturn NULL;\n\n\tfor (; cnt < index->cache_nr; cnt++) {\n\t\tconst struct cache_entry *ce = index->cache[cnt];\n\t\tif (ce->ce_flags & (CE_UPDATE | CE_WT_REMOVE))\n\t\t\ttotal++;\n\t}\n\n\treturn start_delayed_progress(_(\"Checking out files\"), total);\n}\n\nstatic int check_updates(struct unpack_trees_options *o)\n{\n\tunsigned cnt = 0;\n\tint errs = 0;\n\tstruct progress *progress = NULL;\n\tstruct index_state *index = &o->result;\n\tstruct checkout state = CHECKOUT_INIT;\n\tint i;\n\n\tstate.force = 1;\n\tstate.quiet = 1;\n\tstate.refresh_cache = 1;\n\tstate.istate = index;\n\n\tprogress = get_progress(o);\n\n\tif (o->update)\n\t\tgit_attr_set_direction(GIT_ATTR_CHECKOUT, index);\n\tfor (i = 0; i < index->cache_nr; i++) {\n\t\tconst struct cache_entry *ce = index->cache[i];\n\n\t\tif (ce->ce_flags & CE_WT_REMOVE) {\n\t\t\tdisplay_progress(progress, ++cnt);\n\t\t\tif (o->update && !o->dry_run)\n\t\t\t\tunlink_entry(ce);\n\t\t}\n\t}\n\tremove_marked_cache_entries(index);\n\tremove_scheduled_dirs();\n\n\tif (should_update_submodules() && o->update && !o->dry_run)\n\t\treload_gitmodules_file(index, &state);\n\n\tenable_delayed_checkout(&state);\n\tfor (i = 0; i < index->cache_nr; i++) {\n\t\tstruct cache_entry *ce = index->cache[i];\n\n\t\tif (ce->ce_flags & CE_UPDATE) {\n\t\t\tif (ce->ce_flags & CE_WT_REMOVE)\n\t\t\t\tdie(\"BUG: both update and delete flags are set on %s\",\n\t\t\t\t    ce->name);\n\t\t\tdisplay_progress(progress, ++cnt);\n\t\t\tce->ce_flags &= ~CE_UPDATE;\n\t\t\tif (o->update && !o->dry_run) {\n\t\t\t\terrs |= checkout_entry(ce, &state, NULL);\n\t\t\t}\n\t\t}\n\t}\n\tstop_progress(&progress);\n\terrs |= finish_delayed_checkout(&state);\n\tif (o->update)\n\t\tgit_attr_set_direction(GIT_ATTR_CHECKIN, NULL);\n\treturn errs != 0;\n}\n\nstatic int verify_uptodate_sparse(const struct cache_entry *ce,\n\t\t\t\t  struct unpack_trees_options *o);\nstatic int verify_absent_sparse(const struct cache_entry *ce,\n\t\t\t\tenum unpack_trees_error_types,\n\t\t\t\tstruct unpack_trees_options *o);\n\nstatic int apply_sparse_checkout(struct index_state *istate,\n\t\t\t\t struct cache_entry *ce,\n\t\t\t\t struct unpack_trees_options *o)\n{\n\tint was_skip_worktree = ce_skip_worktree(ce);\n\n\tif (ce->ce_flags & CE_NEW_SKIP_WORKTREE)\n\t\tce->ce_flags |= CE_SKIP_WORKTREE;\n\telse\n\t\tce->ce_flags &= ~CE_SKIP_WORKTREE;\n\tif (was_skip_worktree != ce_skip_worktree(ce)) {\n\t\tce->ce_flags |= CE_UPDATE_IN_BASE;\n\t\tistate->cache_changed |= CE_ENTRY_CHANGED;\n\t}\n\n\t/*\n\t * if (!was_skip_worktree && !ce_skip_worktree()) {\n\t *\tThis is perfectly normal. Move on;\n\t * }\n\t */\n\n\t/*\n\t * Merge strategies may set CE_UPDATE|CE_REMOVE outside checkout\n\t * area as a result of ce_skip_worktree() shortcuts in\n\t * verify_absent() and verify_uptodate().\n\t * Make sure they don't modify worktree if they are already\n\t * outside checkout area\n\t */\n\tif (was_skip_worktree && ce_skip_worktree(ce)) {\n\t\tce->ce_flags &= ~CE_UPDATE;\n\n\t\t/*\n\t\t * By default, when CE_REMOVE is on, CE_WT_REMOVE is also\n\t\t * on to get that file removed from both index and worktree.\n\t\t * If that file is already outside worktree area, don't\n\t\t * bother remove it.\n\t\t */\n\t\tif (ce->ce_flags & CE_REMOVE)\n\t\t\tce->ce_flags &= ~CE_WT_REMOVE;\n\t}\n\n\tif (!was_skip_worktree && ce_skip_worktree(ce)) {\n\t\t/*\n\t\t * If CE_UPDATE is set, verify_uptodate() must be called already\n\t\t * also stat info may have lost after merged_entry() so calling\n\t\t * verify_uptodate() again may fail\n\t\t */\n\t\tif (!(ce->ce_flags & CE_UPDATE) && verify_uptodate_sparse(ce, o))\n\t\t\treturn -1;\n\t\tce->ce_flags |= CE_WT_REMOVE;\n\t\tce->ce_flags &= ~CE_UPDATE;\n\t}\n\tif (was_skip_worktree && !ce_skip_worktree(ce)) {\n\t\tif (verify_absent_sparse(ce, ERROR_WOULD_LOSE_UNTRACKED_OVERWRITTEN, o))\n\t\t\treturn -1;\n\t\tce->ce_flags |= CE_UPDATE;\n\t}\n\treturn 0;\n}\n\nstatic inline int call_unpack_fn(const struct cache_entry * const *src,\n\t\t\t\t struct unpack_trees_options *o)\n{\n\tint ret = o->fn(src, o);\n\tif (ret > 0)\n\t\tret = 0;\n\treturn ret;\n}\n\nstatic void mark_ce_used(struct cache_entry *ce, struct unpack_trees_options *o)\n{\n\tce->ce_flags |= CE_UNPACKED;\n\n\tif (o->cache_bottom < o->src_index->cache_nr &&\n\t    o->src_index->cache[o->cache_bottom] == ce) {\n\t\tint bottom = o->cache_bottom;\n\t\twhile (bottom < o->src_index->cache_nr &&\n\t\t       o->src_index->cache[bottom]->ce_flags & CE_UNPACKED)\n\t\t\tbottom++;\n\t\to->cache_bottom = bottom;\n\t}\n}\n\nstatic void mark_all_ce_unused(struct index_state *index)\n{\n\tint i;\n\tfor (i = 0; i < index->cache_nr; i++)\n\t\tindex->cache[i]->ce_flags &= ~(CE_UNPACKED | CE_ADDED | CE_NEW_SKIP_WORKTREE);\n}\n\nstatic int locate_in_src_index(const struct cache_entry *ce,\n\t\t\t       struct unpack_trees_options *o)\n{\n\tstruct index_state *index = o->src_index;\n\tint len = ce_namelen(ce);\n\tint pos = index_name_pos(index, ce->name, len);\n\tif (pos < 0)\n\t\tpos = -1 - pos;\n\treturn pos;\n}\n\n/*\n * We call unpack_index_entry() with an unmerged cache entry\n * only in diff-index, and it wants a single callback.  Skip\n * the other unmerged entry with the same name.\n */\nstatic void mark_ce_used_same_name(struct cache_entry *ce,\n\t\t\t\t   struct unpack_trees_options *o)\n{\n\tstruct index_state *index = o->src_index;\n\tint len = ce_namelen(ce);\n\tint pos;\n\n\tfor (pos = locate_in_src_index(ce, o); pos < index->cache_nr; pos++) {\n\t\tstruct cache_entry *next = index->cache[pos];\n\t\tif (len != ce_namelen(next) ||\n\t\t    memcmp(ce->name, next->name, len))\n\t\t\tbreak;\n\t\tmark_ce_used(next, o);\n\t}\n}\n\nstatic struct cache_entry *next_cache_entry(struct unpack_trees_options *o)\n{\n\tconst struct index_state *index = o->src_index;\n\tint pos = o->cache_bottom;\n\n\twhile (pos < index->cache_nr) {\n\t\tstruct cache_entry *ce = index->cache[pos];\n\t\tif (!(ce->ce_flags & CE_UNPACKED))\n\t\t\treturn ce;\n\t\tpos++;\n\t}\n\treturn NULL;\n}\n\nstatic void add_same_unmerged(const struct cache_entry *ce,\n\t\t\t      struct unpack_trees_options *o)\n{\n\tstruct index_state *index = o->src_index;\n\tint len = ce_namelen(ce);\n\tint pos = index_name_pos(index, ce->name, len);\n\n\tif (0 <= pos)\n\t\tdie(\"programming error in a caller of mark_ce_used_same_name\");\n\tfor (pos = -pos - 1; pos < index->cache_nr; pos++) {\n\t\tstruct cache_entry *next = index->cache[pos];\n\t\tif (len != ce_namelen(next) ||\n\t\t    memcmp(ce->name, next->name, len))\n\t\t\tbreak;\n\t\tadd_entry(o, next, 0, 0);\n\t\tmark_ce_used(next, o);\n\t}\n}\n\nstatic int unpack_index_entry(struct cache_entry *ce,\n\t\t\t      struct unpack_trees_options *o)\n{\n\tconst struct cache_entry *src[MAX_UNPACK_TREES + 1] = { NULL, };\n\tint ret;\n\n\tsrc[0] = ce;\n\n\tmark_ce_used(ce, o);\n\tif (ce_stage(ce)) {\n\t\tif (o->skip_unmerged) {\n\t\t\tadd_entry(o, ce, 0, 0);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tret = call_unpack_fn(src, o);\n\tif (ce_stage(ce))\n\t\tmark_ce_used_same_name(ce, o);\n\treturn ret;\n}\n\nstatic int find_cache_pos(struct traverse_info *, const struct name_entry *);\n\nstatic void restore_cache_bottom(struct traverse_info *info, int bottom)\n{\n\tstruct unpack_trees_options *o = info->data;\n\n\tif (o->diff_index_cached)\n\t\treturn;\n\to->cache_bottom = bottom;\n}\n\nstatic int switch_cache_bottom(struct traverse_info *info)\n{\n\tstruct unpack_trees_options *o = info->data;\n\tint ret, pos;\n\n\tif (o->diff_index_cached)\n\t\treturn 0;\n\tret = o->cache_bottom;\n\tpos = find_cache_pos(info->prev, &info->name);\n\n\tif (pos < -1)\n\t\to->cache_bottom = -2 - pos;\n\telse if (pos < 0)\n\t\to->cache_bottom = o->src_index->cache_nr;\n\treturn ret;\n}\n\nstatic inline int are_same_oid(struct name_entry *name_j, struct name_entry *name_k)\n{\n\treturn name_j->oid && name_k->oid && !oidcmp(name_j->oid, name_k->oid);\n}\n\nstatic int traverse_trees_recursive(int n, unsigned long dirmask,\n\t\t\t\t    unsigned long df_conflicts,\n\t\t\t\t    struct name_entry *names,\n\t\t\t\t    struct traverse_info *info)\n{\n\tint i, ret, bottom;\n\tint nr_buf = 0;\n\tstruct tree_desc t[MAX_UNPACK_TREES];\n\tvoid *buf[MAX_UNPACK_TREES];\n\tstruct traverse_info newinfo;\n\tstruct name_entry *p;\n\n\tp = names;\n\twhile (!p->mode)\n\t\tp++;\n\n\tnewinfo = *info;\n\tnewinfo.prev = info;\n\tnewinfo.pathspec = info->pathspec;\n\tnewinfo.name = *p;\n\tnewinfo.pathlen += tree_entry_len(p) + 1;\n\tnewinfo.df_conflicts |= df_conflicts;\n\n\t/*\n\t * Fetch the tree from the ODB for each peer directory in the\n\t * n commits.\n\t *\n\t * For 2- and 3-way traversals, we try to avoid hitting the\n\t * ODB twice for the same OID.  This should yield a nice speed\n\t * up in checkouts and merges when the commits are similar.\n\t *\n\t * We don't bother doing the full O(n^2) search for larger n,\n\t * because wider traversals don't happen that often and we\n\t * avoid the search setup.\n\t *\n\t * When 2 peer OIDs are the same, we just copy the tree\n\t * descriptor data.  This implicitly borrows the buffer\n\t * data from the earlier cell.\n\t */\n\tfor (i = 0; i < n; i++, dirmask >>= 1) {\n\t\tif (i > 0 && are_same_oid(&names[i], &names[i - 1]))\n\t\t\tt[i] = t[i - 1];\n\t\telse if (i > 1 && are_same_oid(&names[i], &names[i - 2]))\n\t\t\tt[i] = t[i - 2];\n\t\telse {\n\t\t\tconst struct object_id *oid = NULL;\n\t\t\tif (dirmask & 1)\n\t\t\t\toid = names[i].oid;\n\t\t\tbuf[nr_buf++] = fill_tree_descriptor(t + i, oid);\n\t\t}\n\t}\n\n\tbottom = switch_cache_bottom(&newinfo);\n\tret = traverse_trees(n, t, &newinfo);\n\trestore_cache_bottom(&newinfo, bottom);\n\n\tfor (i = 0; i < nr_buf; i++)\n\t\tfree(buf[i]);\n\n\treturn ret;\n}\n\n/*\n * Compare the traverse-path to the cache entry without actually\n * having to generate the textual representation of the traverse\n * path.\n *\n * NOTE! This *only* compares up to the size of the traverse path\n * itself - the caller needs to do the final check for the cache\n * entry having more data at the end!\n */\nstatic int do_compare_entry_piecewise(const struct cache_entry *ce, const struct traverse_info *info, const struct name_entry *n)\n{\n\tint len, pathlen, ce_len;\n\tconst char *ce_name;\n\n\tif (info->prev) {\n\t\tint cmp = do_compare_entry_piecewise(ce, info->prev,\n\t\t\t\t\t\t     &info->name);\n\t\tif (cmp)\n\t\t\treturn cmp;\n\t}\n\tpathlen = info->pathlen;\n\tce_len = ce_namelen(ce);\n\n\t/* If ce_len < pathlen then we must have previously hit \"name == directory\" entry */\n\tif (ce_len < pathlen)\n\t\treturn -1;\n\n\tce_len -= pathlen;\n\tce_name = ce->name + pathlen;\n\n\tlen = tree_entry_len(n);\n\treturn df_name_compare(ce_name, ce_len, S_IFREG, n->path, len, n->mode);\n}\n\nstatic int do_compare_entry(const struct cache_entry *ce,\n\t\t\t    const struct traverse_info *info,\n\t\t\t    const struct name_entry *n)\n{\n\tint len, pathlen, ce_len;\n\tconst char *ce_name;\n\tint cmp;\n\n\t/*\n\t * If we have not precomputed the traverse path, it is quicker\n\t * to avoid doing so.  But if we have precomputed it,\n\t * it is quicker to use the precomputed version.\n\t */\n\tif (!info->traverse_path)\n\t\treturn do_compare_entry_piecewise(ce, info, n);\n\n\tcmp = strncmp(ce->name, info->traverse_path, info->pathlen);\n\tif (cmp)\n\t\treturn cmp;\n\n\tpathlen = info->pathlen;\n\tce_len = ce_namelen(ce);\n\n\tif (ce_len < pathlen)\n\t\treturn -1;\n\n\tce_len -= pathlen;\n\tce_name = ce->name + pathlen;\n\n\tlen = tree_entry_len(n);\n\treturn df_name_compare(ce_name, ce_len, S_IFREG, n->path, len, n->mode);\n}\n\nstatic int compare_entry(const struct cache_entry *ce, const struct traverse_info *info, const struct name_entry *n)\n{\n\tint cmp = do_compare_entry(ce, info, n);\n\tif (cmp)\n\t\treturn cmp;\n\n\t/*\n\t * Even if the beginning compared identically, the ce should\n\t * compare as bigger than a directory leading up to it!\n\t */\n\treturn ce_namelen(ce) > traverse_path_len(info, n);\n}\n\nstatic int ce_in_traverse_path(const struct cache_entry *ce,\n\t\t\t       const struct traverse_info *info)\n{\n\tif (!info->prev)\n\t\treturn 1;\n\tif (do_compare_entry(ce, info->prev, &info->name))\n\t\treturn 0;\n\t/*\n\t * If ce (blob) is the same name as the path (which is a tree\n\t * we will be descending into), it won't be inside it.\n\t */\n\treturn (info->pathlen < ce_namelen(ce));\n}\n\nstatic struct cache_entry *create_ce_entry(const struct traverse_info *info, const struct name_entry *n, int stage)\n{\n\tint len = traverse_path_len(info, n);\n\tstruct cache_entry *ce = xcalloc(1, cache_entry_size(len));\n\n\tce->ce_mode = create_ce_mode(n->mode);\n\tce->ce_flags = create_ce_flags(stage);\n\tce->ce_namelen = len;\n\toidcpy(&ce->oid, n->oid);\n\tmake_traverse_path(ce->name, info, n);\n\n\treturn ce;\n}\n\nstatic int unpack_nondirectories(int n, unsigned long mask,\n\t\t\t\t unsigned long dirmask,\n\t\t\t\t struct cache_entry **src,\n\t\t\t\t const struct name_entry *names,\n\t\t\t\t const struct traverse_info *info)\n{\n\tint i;\n\tstruct unpack_trees_options *o = info->data;\n\tunsigned long conflicts = info->df_conflicts | dirmask;\n\n\t/* Do we have *only* directories? Nothing to do */\n\tif (mask == dirmask && !src[0])\n\t\treturn 0;\n\n\t/*\n\t * Ok, we've filled in up to any potential index entry in src[0],\n\t * now do the rest.\n\t */\n\tfor (i = 0; i < n; i++) {\n\t\tint stage;\n\t\tunsigned int bit = 1ul << i;\n\t\tif (conflicts & bit) {\n\t\t\tsrc[i + o->merge] = o->df_conflict_entry;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(mask & bit))\n\t\t\tcontinue;\n\t\tif (!o->merge)\n\t\t\tstage = 0;\n\t\telse if (i + 1 < o->head_idx)\n\t\t\tstage = 1;\n\t\telse if (i + 1 > o->head_idx)\n\t\t\tstage = 3;\n\t\telse\n\t\t\tstage = 2;\n\t\tsrc[i + o->merge] = create_ce_entry(info, names + i, stage);\n\t}\n\n\tif (o->merge) {\n\t\tint rc = call_unpack_fn((const struct cache_entry * const *)src,\n\t\t\t\t\to);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tstruct cache_entry *ce = src[i + o->merge];\n\t\t\tif (ce != o->df_conflict_entry)\n\t\t\t\tfree(ce);\n\t\t}\n\t\treturn rc;\n\t}\n\n\tfor (i = 0; i < n; i++)\n\t\tif (src[i] && src[i] != o->df_conflict_entry)\n\t\t\tif (do_add_entry(o, src[i], 0, 0))\n\t\t\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int unpack_failed(struct unpack_trees_options *o, const char *message)\n{\n\tdiscard_index(&o->result);\n\tif (!o->gently && !o->exiting_early) {\n\t\tif (message)\n\t\t\treturn error(\"%s\", message);\n\t\treturn -1;\n\t}\n\treturn -1;\n}\n\n/*\n * The tree traversal is looking at name p.  If we have a matching entry,\n * return it.  If name p is a directory in the index, do not return\n * anything, as we will want to match it when the traversal descends into\n * the directory.\n */\nstatic int find_cache_pos(struct traverse_info *info,\n\t\t\t  const struct name_entry *p)\n{\n\tint pos;\n\tstruct unpack_trees_options *o = info->data;\n\tstruct index_state *index = o->src_index;\n\tint pfxlen = info->pathlen;\n\tint p_len = tree_entry_len(p);\n\n\tfor (pos = o->cache_bottom; pos < index->cache_nr; pos++) {\n\t\tconst struct cache_entry *ce = index->cache[pos];\n\t\tconst char *ce_name, *ce_slash;\n\t\tint cmp, ce_len;\n\n\t\tif (ce->ce_flags & CE_UNPACKED) {\n\t\t\t/*\n\t\t\t * cache_bottom entry is already unpacked, so\n\t\t\t * we can never match it; don't check it\n\t\t\t * again.\n\t\t\t */\n\t\t\tif (pos == o->cache_bottom)\n\t\t\t\t++o->cache_bottom;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ce_in_traverse_path(ce, info)) {\n\t\t\t/*\n\t\t\t * Check if we can skip future cache checks\n\t\t\t * (because we're already past all possible\n\t\t\t * entries in the traverse path).\n\t\t\t */\n\t\t\tif (info->traverse_path) {\n\t\t\t\tif (strncmp(ce->name, info->traverse_path,\n\t\t\t\t\t    info->pathlen) > 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tce_name = ce->name + pfxlen;\n\t\tce_slash = strchr(ce_name, '/');\n\t\tif (ce_slash)\n\t\t\tce_len = ce_slash - ce_name;\n\t\telse\n\t\t\tce_len = ce_namelen(ce) - pfxlen;\n\t\tcmp = name_compare(p->path, p_len, ce_name, ce_len);\n\t\t/*\n\t\t * Exact match; if we have a directory we need to\n\t\t * delay returning it.\n\t\t */\n\t\tif (!cmp)\n\t\t\treturn ce_slash ? -2 - pos : pos;\n\t\tif (0 < cmp)\n\t\t\tcontinue; /* keep looking */\n\t\t/*\n\t\t * ce_name sorts after p->path; could it be that we\n\t\t * have files under p->path directory in the index?\n\t\t * E.g.  ce_name == \"t-i\", and p->path == \"t\"; we may\n\t\t * have \"t/a\" in the index.\n\t\t */\n\t\tif (p_len < ce_len && !memcmp(ce_name, p->path, p_len) &&\n\t\t    ce_name[p_len] < '/')\n\t\t\tcontinue; /* keep looking */\n\t\tbreak;\n\t}\n\treturn -1;\n}\n\nstatic struct cache_entry *find_cache_entry(struct traverse_info *info,\n\t\t\t\t\t    const struct name_entry *p)\n{\n\tint pos = find_cache_pos(info, p);\n\tstruct unpack_trees_options *o = info->data;\n\n\tif (0 <= pos)\n\t\treturn o->src_index->cache[pos];\n\telse\n\t\treturn NULL;\n}\n\nstatic void debug_path(struct traverse_info *info)\n{\n\tif (info->prev) {\n\t\tdebug_path(info->prev);\n\t\tif (*info->prev->name.path)\n\t\t\tputchar('/');\n\t}\n\tprintf(\"%s\", info->name.path);\n}\n\nstatic void debug_name_entry(int i, struct name_entry *n)\n{\n\tprintf(\"ent#%d %06o %s\\n\", i,\n\t       n->path ? n->mode : 0,\n\t       n->path ? n->path : \"(missing)\");\n}\n\nstatic void debug_unpack_callback(int n,\n\t\t\t\t  unsigned long mask,\n\t\t\t\t  unsigned long dirmask,\n\t\t\t\t  struct name_entry *names,\n\t\t\t\t  struct traverse_info *info)\n{\n\tint i;\n\tprintf(\"* unpack mask %lu, dirmask %lu, cnt %d \",\n\t       mask, dirmask, n);\n\tdebug_path(info);\n\tputchar('\\n');\n\tfor (i = 0; i < n; i++)\n\t\tdebug_name_entry(i, names + i);\n}\n\nstatic int unpack_callback(int n, unsigned long mask, unsigned long dirmask, struct name_entry *names, struct traverse_info *info)\n{\n\tstruct cache_entry *src[MAX_UNPACK_TREES + 1] = { NULL, };\n\tstruct unpack_trees_options *o = info->data;\n\tconst struct name_entry *p = names;\n\n\t/* Find first entry with a real name (we could use \"mask\" too) */\n\twhile (!p->mode)\n\t\tp++;\n\n\tif (o->debug_unpack)\n\t\tdebug_unpack_callback(n, mask, dirmask, names, info);\n\n\t/* Are we supposed to look at the index too? */\n\tif (o->merge) {\n\t\twhile (1) {\n\t\t\tint cmp;\n\t\t\tstruct cache_entry *ce;\n\n\t\t\tif (o->diff_index_cached)\n\t\t\t\tce = next_cache_entry(o);\n\t\t\telse\n\t\t\t\tce = find_cache_entry(info, p);\n\n\t\t\tif (!ce)\n\t\t\t\tbreak;\n\t\t\tcmp = compare_entry(ce, info, p);\n\t\t\tif (cmp < 0) {\n\t\t\t\tif (unpack_index_entry(ce, o) < 0)\n\t\t\t\t\treturn unpack_failed(o, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!cmp) {\n\t\t\t\tif (ce_stage(ce)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * If we skip unmerged index\n\t\t\t\t\t * entries, we'll skip this\n\t\t\t\t\t * entry *and* the tree\n\t\t\t\t\t * entries associated with it!\n\t\t\t\t\t */\n\t\t\t\t\tif (o->skip_unmerged) {\n\t\t\t\t\t\tadd_same_unmerged(ce, o);\n\t\t\t\t\t\treturn mask;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsrc[0] = ce;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unpack_nondirectories(n, mask, dirmask, src, names, info) < 0)\n\t\treturn -1;\n\n\tif (o->merge && src[0]) {\n\t\tif (ce_stage(src[0]))\n\t\t\tmark_ce_used_same_name(src[0], o);\n\t\telse\n\t\t\tmark_ce_used(src[0], o);\n\t}\n\n\t/* Now handle any directories.. */\n\tif (dirmask) {\n\t\t/* special case: \"diff-index --cached\" looking at a tree */\n\t\tif (o->diff_index_cached &&\n\t\t    n == 1 && dirmask == 1 && S_ISDIR(names->mode)) {\n\t\t\tint matches;\n\t\t\tmatches = cache_tree_matches_traversal(o->src_index->cache_tree,\n\t\t\t\t\t\t\t       names, info);\n\t\t\t/*\n\t\t\t * Everything under the name matches; skip the\n\t\t\t * entire hierarchy.  diff_index_cached codepath\n\t\t\t * special cases D/F conflicts in such a way that\n\t\t\t * it does not do any look-ahead, so this is safe.\n\t\t\t */\n\t\t\tif (matches) {\n\t\t\t\to->cache_bottom += matches;\n\t\t\t\treturn mask;\n\t\t\t}\n\t\t}\n\n\t\tif (traverse_trees_recursive(n, dirmask, mask & ~dirmask,\n\t\t\t\t\t     names, info) < 0)\n\t\t\treturn -1;\n\t\treturn mask;\n\t}\n\n\treturn mask;\n}\n\nstatic int clear_ce_flags_1(struct cache_entry **cache, int nr,\n\t\t\t    struct strbuf *prefix,\n\t\t\t    int select_mask, int clear_mask,\n\t\t\t    struct exclude_list *el, int defval);\n\n/* Whole directory matching */\nstatic int clear_ce_flags_dir(struct cache_entry **cache, int nr,\n\t\t\t      struct strbuf *prefix,\n\t\t\t      char *basename,\n\t\t\t      int select_mask, int clear_mask,\n\t\t\t      struct exclude_list *el, int defval)\n{\n\tstruct cache_entry **cache_end;\n\tint dtype = DT_DIR;\n\tint ret = is_excluded_from_list(prefix->buf, prefix->len,\n\t\t\t\t\tbasename, &dtype, el, &the_index);\n\tint rc;\n\n\tstrbuf_addch(prefix, '/');\n\n\t/* If undecided, use matching result of parent dir in defval */\n\tif (ret < 0)\n\t\tret = defval;\n\n\tfor (cache_end = cache; cache_end != cache + nr; cache_end++) {\n\t\tstruct cache_entry *ce = *cache_end;\n\t\tif (strncmp(ce->name, prefix->buf, prefix->len))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * TODO: check el, if there are no patterns that may conflict\n\t * with ret (iow, we know in advance the incl/excl\n\t * decision for the entire directory), clear flag here without\n\t * calling clear_ce_flags_1(). That function will call\n\t * the expensive is_excluded_from_list() on every entry.\n\t */\n\trc = clear_ce_flags_1(cache, cache_end - cache,\n\t\t\t      prefix,\n\t\t\t      select_mask, clear_mask,\n\t\t\t      el, ret);\n\tstrbuf_setlen(prefix, prefix->len - 1);\n\treturn rc;\n}\n\n/*\n * Traverse the index, find every entry that matches according to\n * o->el. Do \"ce_flags &= ~clear_mask\" on those entries. Return the\n * number of traversed entries.\n *\n * If select_mask is non-zero, only entries whose ce_flags has on of\n * those bits enabled are traversed.\n *\n * cache\t: pointer to an index entry\n * prefix_len\t: an offset to its path\n *\n * The current path (\"prefix\") including the trailing '/' is\n *   cache[0]->name[0..(prefix_len-1)]\n * Top level path has prefix_len zero.\n */\nstatic int clear_ce_flags_1(struct cache_entry **cache, int nr,\n\t\t\t    struct strbuf *prefix,\n\t\t\t    int select_mask, int clear_mask,\n\t\t\t    struct exclude_list *el, int defval)\n{\n\tstruct cache_entry **cache_end = cache + nr;\n\n\t/*\n\t * Process all entries that have the given prefix and meet\n\t * select_mask condition\n\t */\n\twhile(cache != cache_end) {\n\t\tstruct cache_entry *ce = *cache;\n\t\tconst char *name, *slash;\n\t\tint len, dtype, ret;\n\n\t\tif (select_mask && !(ce->ce_flags & select_mask)) {\n\t\t\tcache++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (prefix->len && strncmp(ce->name, prefix->buf, prefix->len))\n\t\t\tbreak;\n\n\t\tname = ce->name + prefix->len;\n\t\tslash = strchr(name, '/');\n\n\t\t/* If it's a directory, try whole directory match first */\n\t\tif (slash) {\n\t\t\tint processed;\n\n\t\t\tlen = slash - name;\n\t\t\tstrbuf_add(prefix, name, len);\n\n\t\t\tprocessed = clear_ce_flags_dir(cache, cache_end - cache,\n\t\t\t\t\t\t       prefix,\n\t\t\t\t\t\t       prefix->buf + prefix->len - len,\n\t\t\t\t\t\t       select_mask, clear_mask,\n\t\t\t\t\t\t       el, defval);\n\n\t\t\t/* clear_c_f_dir eats a whole dir already? */\n\t\t\tif (processed) {\n\t\t\t\tcache += processed;\n\t\t\t\tstrbuf_setlen(prefix, prefix->len - len);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstrbuf_addch(prefix, '/');\n\t\t\tcache += clear_ce_flags_1(cache, cache_end - cache,\n\t\t\t\t\t\t  prefix,\n\t\t\t\t\t\t  select_mask, clear_mask, el, defval);\n\t\t\tstrbuf_setlen(prefix, prefix->len - len - 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Non-directory */\n\t\tdtype = ce_to_dtype(ce);\n\t\tret = is_excluded_from_list(ce->name, ce_namelen(ce),\n\t\t\t\t\t    name, &dtype, el, &the_index);\n\t\tif (ret < 0)\n\t\t\tret = defval;\n\t\tif (ret > 0)\n\t\t\tce->ce_flags &= ~clear_mask;\n\t\tcache++;\n\t}\n\treturn nr - (cache_end - cache);\n}\n\nstatic int clear_ce_flags(struct cache_entry **cache, int nr,\n\t\t\t    int select_mask, int clear_mask,\n\t\t\t    struct exclude_list *el)\n{\n\tstatic struct strbuf prefix = STRBUF_INIT;\n\n\tstrbuf_reset(&prefix);\n\n\treturn clear_ce_flags_1(cache, nr,\n\t\t\t\t&prefix,\n\t\t\t\tselect_mask, clear_mask,\n\t\t\t\tel, 0);\n}\n\n/*\n * Set/Clear CE_NEW_SKIP_WORKTREE according to $GIT_DIR/info/sparse-checkout\n */\nstatic void mark_new_skip_worktree(struct exclude_list *el,\n\t\t\t\t   struct index_state *the_index,\n\t\t\t\t   int select_flag, int skip_wt_flag)\n{\n\tint i;\n\n\t/*\n\t * 1. Pretend the narrowest worktree: only unmerged entries\n\t * are checked out\n\t */\n\tfor (i = 0; i < the_index->cache_nr; i++) {\n\t\tstruct cache_entry *ce = the_index->cache[i];\n\n\t\tif (select_flag && !(ce->ce_flags & select_flag))\n\t\t\tcontinue;\n\n\t\tif (!ce_stage(ce))\n\t\t\tce->ce_flags |= skip_wt_flag;\n\t\telse\n\t\t\tce->ce_flags &= ~skip_wt_flag;\n\t}\n\n\t/*\n\t * 2. Widen worktree according to sparse-checkout file.\n\t * Matched entries will have skip_wt_flag cleared (i.e. \"in\")\n\t */\n\tclear_ce_flags(the_index->cache, the_index->cache_nr,\n\t\t       select_flag, skip_wt_flag, el);\n}\n\nstatic int verify_absent(const struct cache_entry *,\n\t\t\t enum unpack_trees_error_types,\n\t\t\t struct unpack_trees_options *);\n/*\n * N-way merge \"len\" trees.  Returns 0 on success, -1 on failure to manipulate the\n * resulting index, -2 on failure to reflect the changes to the work tree.\n *\n * CE_ADDED, CE_UNPACKED and CE_NEW_SKIP_WORKTREE are used internally\n */\nint unpack_trees(unsigned len, struct tree_desc *t, struct unpack_trees_options *o)\n{\n\tint i, ret;\n\tstatic struct cache_entry *dfc;\n\tstruct exclude_list el;\n\n\tif (len > MAX_UNPACK_TREES)\n\t\tdie(\"unpack_trees takes at most %d trees\", MAX_UNPACK_TREES);\n\n\tmemset(&el, 0, sizeof(el));\n\tif (!core_apply_sparse_checkout || !o->update)\n\t\to->skip_sparse_checkout = 1;\n\tif (!o->skip_sparse_checkout) {\n\t\tchar *sparse = git_pathdup(\"info/sparse-checkout\");\n\t\tif (add_excludes_from_file_to_list(sparse, \"\", 0, &el, NULL) < 0)\n\t\t\to->skip_sparse_checkout = 1;\n\t\telse\n\t\t\to->el = &el;\n\t\tfree(sparse);\n\t}\n\n\tmemset(&o->result, 0, sizeof(o->result));\n\to->result.initialized = 1;\n\to->result.timestamp.sec = o->src_index->timestamp.sec;\n\to->result.timestamp.nsec = o->src_index->timestamp.nsec;\n\to->result.version = o->src_index->version;\n\to->result.split_index = o->src_index->split_index;\n\tif (o->result.split_index)\n\t\to->result.split_index->refcount++;\n\thashcpy(o->result.sha1, o->src_index->sha1);\n\to->merge_size = len;\n\tmark_all_ce_unused(o->src_index);\n\n\t/*\n\t * Sparse checkout loop #1: set NEW_SKIP_WORKTREE on existing entries\n\t */\n\tif (!o->skip_sparse_checkout)\n\t\tmark_new_skip_worktree(o->el, o->src_index, 0, CE_NEW_SKIP_WORKTREE);\n\n\tif (!dfc)\n\t\tdfc = xcalloc(1, cache_entry_size(0));\n\to->df_conflict_entry = dfc;\n\n\tif (len) {\n\t\tconst char *prefix = o->prefix ? o->prefix : \"\";\n\t\tstruct traverse_info info;\n\n\t\tsetup_traverse_info(&info, prefix);\n\t\tinfo.fn = unpack_callback;\n\t\tinfo.data = o;\n\t\tinfo.show_all_errors = o->show_all_errors;\n\t\tinfo.pathspec = o->pathspec;\n\n\t\tif (o->prefix) {\n\t\t\t/*\n\t\t\t * Unpack existing index entries that sort before the\n\t\t\t * prefix the tree is spliced into.  Note that o->merge\n\t\t\t * is always true in this case.\n\t\t\t */\n\t\t\twhile (1) {\n\t\t\t\tstruct cache_entry *ce = next_cache_entry(o);\n\t\t\t\tif (!ce)\n\t\t\t\t\tbreak;\n\t\t\t\tif (ce_in_traverse_path(ce, &info))\n\t\t\t\t\tbreak;\n\t\t\t\tif (unpack_index_entry(ce, o) < 0)\n\t\t\t\t\tgoto return_failed;\n\t\t\t}\n\t\t}\n\n\t\tif (traverse_trees(len, t, &info) < 0)\n\t\t\tgoto return_failed;\n\t}\n\n\t/* Any left-over entries in the index? */\n\tif (o->merge) {\n\t\twhile (1) {\n\t\t\tstruct cache_entry *ce = next_cache_entry(o);\n\t\t\tif (!ce)\n\t\t\t\tbreak;\n\t\t\tif (unpack_index_entry(ce, o) < 0)\n\t\t\t\tgoto return_failed;\n\t\t}\n\t}\n\tmark_all_ce_unused(o->src_index);\n\n\tif (o->trivial_merges_only && o->nontrivial_merge) {\n\t\tret = unpack_failed(o, \"Merge requires file-level merging\");\n\t\tgoto done;\n\t}\n\n\tif (!o->skip_sparse_checkout) {\n\t\tint empty_worktree = 1;\n\n\t\t/*\n\t\t * Sparse checkout loop #2: set NEW_SKIP_WORKTREE on entries not in loop #1\n\t\t * If the will have NEW_SKIP_WORKTREE, also set CE_SKIP_WORKTREE\n\t\t * so apply_sparse_checkout() won't attempt to remove it from worktree\n\t\t */\n\t\tmark_new_skip_worktree(o->el, &o->result, CE_ADDED, CE_SKIP_WORKTREE | CE_NEW_SKIP_WORKTREE);\n\n\t\tret = 0;\n\t\tfor (i = 0; i < o->result.cache_nr; i++) {\n\t\t\tstruct cache_entry *ce = o->result.cache[i];\n\n\t\t\t/*\n\t\t\t * Entries marked with CE_ADDED in merged_entry() do not have\n\t\t\t * verify_absent() check (the check is effectively disabled\n\t\t\t * because CE_NEW_SKIP_WORKTREE is set unconditionally).\n\t\t\t *\n\t\t\t * Do the real check now because we have had\n\t\t\t * correct CE_NEW_SKIP_WORKTREE\n\t\t\t */\n\t\t\tif (ce->ce_flags & CE_ADDED &&\n\t\t\t    verify_absent(ce, ERROR_WOULD_LOSE_UNTRACKED_OVERWRITTEN, o)) {\n\t\t\t\tif (!o->show_all_errors)\n\t\t\t\t\tgoto return_failed;\n\t\t\t\tret = -1;\n\t\t\t}\n\n\t\t\tif (apply_sparse_checkout(&o->result, ce, o)) {\n\t\t\t\tif (!o->show_all_errors)\n\t\t\t\t\tgoto return_failed;\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t\tif (!ce_skip_worktree(ce))\n\t\t\t\tempty_worktree = 0;\n\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto return_failed;\n\t\t/*\n\t\t * Sparse checkout is meant to narrow down checkout area\n\t\t * but it does not make sense to narrow down to empty working\n\t\t * tree. This is usually a mistake in sparse checkout rules.\n\t\t * Do not allow users to do that.\n\t\t */\n\t\tif (o->result.cache_nr && empty_worktree) {\n\t\t\tret = unpack_failed(o, \"Sparse checkout leaves no entry on working directory\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\to->src_index = NULL;\n\tret = check_updates(o) ? (-2) : 0;\n\tif (o->dst_index) {\n\t\tif (!ret) {\n\t\t\tif (!o->result.cache_tree)\n\t\t\t\to->result.cache_tree = cache_tree();\n\t\t\tif (!cache_tree_fully_valid(o->result.cache_tree))\n\t\t\t\tcache_tree_update(&o->result,\n\t\t\t\t\t\t  WRITE_TREE_SILENT |\n\t\t\t\t\t\t  WRITE_TREE_REPAIR);\n\t\t}\n\t\tmove_index_extensions(&o->result, o->dst_index);\n\t\tdiscard_index(o->dst_index);\n\t\t*o->dst_index = o->result;\n\t} else {\n\t\tdiscard_index(&o->result);\n\t}\n\ndone:\n\tclear_exclude_list(&el);\n\treturn ret;\n\nreturn_failed:\n\tif (o->show_all_errors)\n\t\tdisplay_error_msgs(o);\n\tmark_all_ce_unused(o->src_index);\n\tret = unpack_failed(o, NULL);\n\tif (o->exiting_early)\n\t\tret = 0;\n\tgoto done;\n}\n\n/* Here come the merge functions */\n\nstatic int reject_merge(const struct cache_entry *ce,\n\t\t\tstruct unpack_trees_options *o)\n{\n\treturn o->gently ? -1 :\n\t\tadd_rejected_path(o, ERROR_WOULD_OVERWRITE, ce->name);\n}\n\nstatic int same(const struct cache_entry *a, const struct cache_entry *b)\n{\n\tif (!!a != !!b)\n\t\treturn 0;\n\tif (!a && !b)\n\t\treturn 1;\n\tif ((a->ce_flags | b->ce_flags) & CE_CONFLICTED)\n\t\treturn 0;\n\treturn a->ce_mode == b->ce_mode &&\n\t       !oidcmp(&a->oid, &b->oid);\n}\n\n\n/*\n * When a CE gets turned into an unmerged entry, we\n * want it to be up-to-date\n */\nstatic int verify_uptodate_1(const struct cache_entry *ce,\n\t\t\t     struct unpack_trees_options *o,\n\t\t\t     enum unpack_trees_error_types error_type)\n{\n\tstruct stat st;\n\n\tif (o->index_only)\n\t\treturn 0;\n\n\t/*\n\t * CE_VALID and CE_SKIP_WORKTREE cheat, we better check again\n\t * if this entry is truly up-to-date because this file may be\n\t * overwritten.\n\t */\n\tif ((ce->ce_flags & CE_VALID) || ce_skip_worktree(ce))\n\t\t; /* keep checking */\n\telse if (o->reset || ce_uptodate(ce))\n\t\treturn 0;\n\n\tif (!lstat(ce->name, &st)) {\n\t\tint flags = CE_MATCH_IGNORE_VALID|CE_MATCH_IGNORE_SKIP_WORKTREE;\n\t\tunsigned changed = ie_match_stat(o->src_index, ce, &st, flags);\n\n\t\tif (submodule_from_ce(ce)) {\n\t\t\tint r = check_submodule_move_head(ce,\n\t\t\t\t\"HEAD\", oid_to_hex(&ce->oid), o);\n\t\t\tif (r)\n\t\t\t\treturn o->gently ? -1 :\n\t\t\t\t\tadd_rejected_path(o, error_type, ce->name);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!changed)\n\t\t\treturn 0;\n\t\t/*\n\t\t * Historic default policy was to allow submodule to be out\n\t\t * of sync wrt the superproject index. If the submodule was\n\t\t * not considered interesting above, we don't care here.\n\t\t */\n\t\tif (S_ISGITLINK(ce->ce_mode))\n\t\t\treturn 0;\n\n\t\terrno = 0;\n\t}\n\tif (errno == ENOENT)\n\t\treturn 0;\n\treturn o->gently ? -1 :\n\t\tadd_rejected_path(o, error_type, ce->name);\n}\n\nstatic int verify_uptodate(const struct cache_entry *ce,\n\t\t\t   struct unpack_trees_options *o)\n{\n\tif (!o->skip_sparse_checkout && (ce->ce_flags & CE_NEW_SKIP_WORKTREE))\n\t\treturn 0;\n\treturn verify_uptodate_1(ce, o, ERROR_NOT_UPTODATE_FILE);\n}\n\nstatic int verify_uptodate_sparse(const struct cache_entry *ce,\n\t\t\t\t  struct unpack_trees_options *o)\n{\n\treturn verify_uptodate_1(ce, o, ERROR_SPARSE_NOT_UPTODATE_FILE);\n}\n\nstatic void invalidate_ce_path(const struct cache_entry *ce,\n\t\t\t       struct unpack_trees_options *o)\n{\n\tif (!ce)\n\t\treturn;\n\tcache_tree_invalidate_path(o->src_index, ce->name);\n\tuntracked_cache_invalidate_path(o->src_index, ce->name);\n}\n\n/*\n * Check that checking out ce->sha1 in subdir ce->name is not\n * going to overwrite any working files.\n *\n * Currently, git does not checkout subprojects during a superproject\n * checkout, so it is not going to overwrite anything.\n */\nstatic int verify_clean_submodule(const char *old_sha1,\n\t\t\t\t  const struct cache_entry *ce,\n\t\t\t\t  enum unpack_trees_error_types error_type,\n\t\t\t\t  struct unpack_trees_options *o)\n{\n\tif (!submodule_from_ce(ce))\n\t\treturn 0;\n\n\treturn check_submodule_move_head(ce, old_sha1,\n\t\t\t\t\t oid_to_hex(&ce->oid), o);\n}\n\nstatic int verify_clean_subdirectory(const struct cache_entry *ce,\n\t\t\t\t     enum unpack_trees_error_types error_type,\n\t\t\t\t     struct unpack_trees_options *o)\n{\n\t/*\n\t * we are about to extract \"ce->name\"; we would not want to lose\n\t * anything in the existing directory there.\n\t */\n\tint namelen;\n\tint i;\n\tstruct dir_struct d;\n\tchar *pathbuf;\n\tint cnt = 0;\n\n\tif (S_ISGITLINK(ce->ce_mode)) {\n\t\tunsigned char sha1[20];\n\t\tint sub_head = resolve_gitlink_ref(ce->name, \"HEAD\", sha1);\n\t\t/*\n\t\t * If we are not going to update the submodule, then\n\t\t * we don't care.\n\t\t */\n\t\tif (!sub_head && !hashcmp(sha1, ce->oid.hash))\n\t\t\treturn 0;\n\t\treturn verify_clean_submodule(sub_head ? NULL : sha1_to_hex(sha1),\n\t\t\t\t\t      ce, error_type, o);\n\t}\n\n\t/*\n\t * First let's make sure we do not have a local modification\n\t * in that directory.\n\t */\n\tnamelen = ce_namelen(ce);\n\tfor (i = locate_in_src_index(ce, o);\n\t     i < o->src_index->cache_nr;\n\t     i++) {\n\t\tstruct cache_entry *ce2 = o->src_index->cache[i];\n\t\tint len = ce_namelen(ce2);\n\t\tif (len < namelen ||\n\t\t    strncmp(ce->name, ce2->name, namelen) ||\n\t\t    ce2->name[namelen] != '/')\n\t\t\tbreak;\n\t\t/*\n\t\t * ce2->name is an entry in the subdirectory to be\n\t\t * removed.\n\t\t */\n\t\tif (!ce_stage(ce2)) {\n\t\t\tif (verify_uptodate(ce2, o))\n\t\t\t\treturn -1;\n\t\t\tadd_entry(o, ce2, CE_REMOVE, 0);\n\t\t\tmark_ce_used(ce2, o);\n\t\t}\n\t\tcnt++;\n\t}\n\n\t/*\n\t * Then we need to make sure that we do not lose a locally\n\t * present file that is not ignored.\n\t */\n\tpathbuf = xstrfmt(\"%.*s/\", namelen, ce->name);\n\n\tmemset(&d, 0, sizeof(d));\n\tif (o->dir)\n\t\td.exclude_per_dir = o->dir->exclude_per_dir;\n\ti = read_directory(&d, &the_index, pathbuf, namelen+1, NULL);\n\tif (i)\n\t\treturn o->gently ? -1 :\n\t\t\tadd_rejected_path(o, ERROR_NOT_UPTODATE_DIR, ce->name);\n\tfree(pathbuf);\n\treturn cnt;\n}\n\n/*\n * This gets called when there was no index entry for the tree entry 'dst',\n * but we found a file in the working tree that 'lstat()' said was fine,\n * and we're on a case-insensitive filesystem.\n *\n * See if we can find a case-insensitive match in the index that also\n * matches the stat information, and assume it's that other file!\n */\nstatic int icase_exists(struct unpack_trees_options *o, const char *name, int len, struct stat *st)\n{\n\tconst struct cache_entry *src;\n\n\tsrc = index_file_exists(o->src_index, name, len, 1);\n\treturn src && !ie_match_stat(o->src_index, src, st, CE_MATCH_IGNORE_VALID|CE_MATCH_IGNORE_SKIP_WORKTREE);\n}\n\nstatic int check_ok_to_remove(const char *name, int len, int dtype,\n\t\t\t      const struct cache_entry *ce, struct stat *st,\n\t\t\t      enum unpack_trees_error_types error_type,\n\t\t\t      struct unpack_trees_options *o)\n{\n\tconst struct cache_entry *result;\n\n\t/*\n\t * It may be that the 'lstat()' succeeded even though\n\t * target 'ce' was absent, because there is an old\n\t * entry that is different only in case..\n\t *\n\t * Ignore that lstat() if it matches.\n\t */\n\tif (ignore_case && icase_exists(o, name, len, st))\n\t\treturn 0;\n\n\tif (o->dir &&\n\t    is_excluded(o->dir, &the_index, name, &dtype))\n\t\t/*\n\t\t * ce->name is explicitly excluded, so it is Ok to\n\t\t * overwrite it.\n\t\t */\n\t\treturn 0;\n\tif (S_ISDIR(st->st_mode)) {\n\t\t/*\n\t\t * We are checking out path \"foo\" and\n\t\t * found \"foo/.\" in the working tree.\n\t\t * This is tricky -- if we have modified\n\t\t * files that are in \"foo/\" we would lose\n\t\t * them.\n\t\t */\n\t\tif (verify_clean_subdirectory(ce, error_type, o) < 0)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The previous round may already have decided to\n\t * delete this path, which is in a subdirectory that\n\t * is being replaced with a blob.\n\t */\n\tresult = index_file_exists(&o->result, name, len, 0);\n\tif (result) {\n\t\tif (result->ce_flags & CE_REMOVE)\n\t\t\treturn 0;\n\t}\n\n\treturn o->gently ? -1 :\n\t\tadd_rejected_path(o, error_type, name);\n}\n\n/*\n * We do not want to remove or overwrite a working tree file that\n * is not tracked, unless it is ignored.\n */\nstatic int verify_absent_1(const struct cache_entry *ce,\n\t\t\t   enum unpack_trees_error_types error_type,\n\t\t\t   struct unpack_trees_options *o)\n{\n\tint len;\n\tstruct stat st;\n\n\tif (o->index_only || o->reset || !o->update)\n\t\treturn 0;\n\n\tlen = check_leading_path(ce->name, ce_namelen(ce));\n\tif (!len)\n\t\treturn 0;\n\telse if (len > 0) {\n\t\tchar *path;\n\t\tint ret;\n\n\t\tpath = xmemdupz(ce->name, len);\n\t\tif (lstat(path, &st))\n\t\t\tret = error_errno(\"cannot stat '%s'\", path);\n\t\telse {\n\t\t\tif (submodule_from_ce(ce))\n\t\t\t\tret = check_submodule_move_head(ce,\n\t\t\t\t\t\t\t\toid_to_hex(&ce->oid),\n\t\t\t\t\t\t\t\tNULL, o);\n\t\t\telse\n\t\t\t\tret = check_ok_to_remove(path, len, DT_UNKNOWN, NULL,\n\t\t\t\t\t\t\t &st, error_type, o);\n\t\t}\n\t\tfree(path);\n\t\treturn ret;\n\t} else if (lstat(ce->name, &st)) {\n\t\tif (errno != ENOENT)\n\t\t\treturn error_errno(\"cannot stat '%s'\", ce->name);\n\t\treturn 0;\n\t} else {\n\t\tif (submodule_from_ce(ce))\n\t\t\treturn check_submodule_move_head(ce, oid_to_hex(&ce->oid),\n\t\t\t\t\t\t\t NULL, o);\n\n\t\treturn check_ok_to_remove(ce->name, ce_namelen(ce),\n\t\t\t\t\t  ce_to_dtype(ce), ce, &st,\n\t\t\t\t\t  error_type, o);\n\t}\n}\n\nstatic int verify_absent(const struct cache_entry *ce,\n\t\t\t enum unpack_trees_error_types error_type,\n\t\t\t struct unpack_trees_options *o)\n{\n\tif (!o->skip_sparse_checkout && (ce->ce_flags & CE_NEW_SKIP_WORKTREE))\n\t\treturn 0;\n\treturn verify_absent_1(ce, error_type, o);\n}\n\nstatic int verify_absent_sparse(const struct cache_entry *ce,\n\t\t\t\tenum unpack_trees_error_types error_type,\n\t\t\t\tstruct unpack_trees_options *o)\n{\n\tenum unpack_trees_error_types orphaned_error = error_type;\n\tif (orphaned_error == ERROR_WOULD_LOSE_UNTRACKED_OVERWRITTEN)\n\t\torphaned_error = ERROR_WOULD_LOSE_ORPHANED_OVERWRITTEN;\n\n\treturn verify_absent_1(ce, orphaned_error, o);\n}\n\nstatic int merged_entry(const struct cache_entry *ce,\n\t\t\tconst struct cache_entry *old,\n\t\t\tstruct unpack_trees_options *o)\n{\n\tint update = CE_UPDATE;\n\tstruct cache_entry *merge = dup_entry(ce);\n\n\tif (!old) {\n\t\t/*\n\t\t * New index entries. In sparse checkout, the following\n\t\t * verify_absent() will be delayed until after\n\t\t * traverse_trees() finishes in unpack_trees(), then:\n\t\t *\n\t\t *  - CE_NEW_SKIP_WORKTREE will be computed correctly\n\t\t *  - verify_absent() be called again, this time with\n\t\t *    correct CE_NEW_SKIP_WORKTREE\n\t\t *\n\t\t * verify_absent() call here does nothing in sparse\n\t\t * checkout (i.e. o->skip_sparse_checkout == 0)\n\t\t */\n\t\tupdate |= CE_ADDED;\n\t\tmerge->ce_flags |= CE_NEW_SKIP_WORKTREE;\n\n\t\tif (verify_absent(merge,\n\t\t\t\t  ERROR_WOULD_LOSE_UNTRACKED_OVERWRITTEN, o)) {\n\t\t\tfree(merge);\n\t\t\treturn -1;\n\t\t}\n\t\tinvalidate_ce_path(merge, o);\n\n\t\tif (submodule_from_ce(ce)) {\n\t\t\tint ret = check_submodule_move_head(ce, NULL,\n\t\t\t\t\t\t\t    oid_to_hex(&ce->oid),\n\t\t\t\t\t\t\t    o);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t} else if (!(old->ce_flags & CE_CONFLICTED)) {\n\t\t/*\n\t\t * See if we can re-use the old CE directly?\n\t\t * That way we get the uptodate stat info.\n\t\t *\n\t\t * This also removes the UPDATE flag on a match; otherwise\n\t\t * we will end up overwriting local changes in the work tree.\n\t\t */\n\t\tif (same(old, merge)) {\n\t\t\tcopy_cache_entry(merge, old);\n\t\t\tupdate = 0;\n\t\t} else {\n\t\t\tif (verify_uptodate(old, o)) {\n\t\t\t\tfree(merge);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* Migrate old flags over */\n\t\t\tupdate |= old->ce_flags & (CE_SKIP_WORKTREE | CE_NEW_SKIP_WORKTREE);\n\t\t\tinvalidate_ce_path(old, o);\n\t\t}\n\n\t\tif (submodule_from_ce(ce)) {\n\t\t\tint ret = check_submodule_move_head(ce, oid_to_hex(&old->oid),\n\t\t\t\t\t\t\t    oid_to_hex(&ce->oid),\n\t\t\t\t\t\t\t    o);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Previously unmerged entry left as an existence\n\t\t * marker by read_index_unmerged();\n\t\t */\n\t\tinvalidate_ce_path(old, o);\n\t}\n\n\tdo_add_entry(o, merge, update, CE_STAGEMASK);\n\treturn 1;\n}\n\nstatic int deleted_entry(const struct cache_entry *ce,\n\t\t\t const struct cache_entry *old,\n\t\t\t struct unpack_trees_options *o)\n{\n\t/* Did it exist in the index? */\n\tif (!old) {\n\t\tif (verify_absent(ce, ERROR_WOULD_LOSE_UNTRACKED_REMOVED, o))\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\tif (!(old->ce_flags & CE_CONFLICTED) && verify_uptodate(old, o))\n\t\treturn -1;\n\tadd_entry(o, ce, CE_REMOVE, 0);\n\tinvalidate_ce_path(ce, o);\n\treturn 1;\n}\n\nstatic int keep_entry(const struct cache_entry *ce,\n\t\t      struct unpack_trees_options *o)\n{\n\tadd_entry(o, ce, 0, 0);\n\treturn 1;\n}\n\n#if DBRT_DEBUG\nstatic void show_stage_entry(FILE *o,\n\t\t\t     const char *label, const struct cache_entry *ce)\n{\n\tif (!ce)\n\t\tfprintf(o, \"%s (missing)\\n\", label);\n\telse\n\t\tfprintf(o, \"%s%06o %s %d\\t%s\\n\",\n\t\t\tlabel,\n\t\t\tce->ce_mode,\n\t\t\toid_to_hex(&ce->oid),\n\t\t\tce_stage(ce),\n\t\t\tce->name);\n}\n#endif\n\nint threeway_merge(const struct cache_entry * const *stages,\n\t\t   struct unpack_trees_options *o)\n{\n\tconst struct cache_entry *index;\n\tconst struct cache_entry *head;\n\tconst struct cache_entry *remote = stages[o->head_idx + 1];\n\tint count;\n\tint head_match = 0;\n\tint remote_match = 0;\n\n\tint df_conflict_head = 0;\n\tint df_conflict_remote = 0;\n\n\tint any_anc_missing = 0;\n\tint no_anc_exists = 1;\n\tint i;\n\n\tfor (i = 1; i < o->head_idx; i++) {\n\t\tif (!stages[i] || stages[i] == o->df_conflict_entry)\n\t\t\tany_anc_missing = 1;\n\t\telse\n\t\t\tno_anc_exists = 0;\n\t}\n\n\tindex = stages[0];\n\thead = stages[o->head_idx];\n\n\tif (head == o->df_conflict_entry) {\n\t\tdf_conflict_head = 1;\n\t\thead = NULL;\n\t}\n\n\tif (remote == o->df_conflict_entry) {\n\t\tdf_conflict_remote = 1;\n\t\tremote = NULL;\n\t}\n\n\t/*\n\t * First, if there's a #16 situation, note that to prevent #13\n\t * and #14.\n\t */\n\tif (!same(remote, head)) {\n\t\tfor (i = 1; i < o->head_idx; i++) {\n\t\t\tif (same(stages[i], head)) {\n\t\t\t\thead_match = i;\n\t\t\t}\n\t\t\tif (same(stages[i], remote)) {\n\t\t\t\tremote_match = i;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We start with cases where the index is allowed to match\n\t * something other than the head: #14(ALT) and #2ALT, where it\n\t * is permitted to match the result instead.\n\t */\n\t/* #14, #14ALT, #2ALT */\n\tif (remote && !df_conflict_head && head_match && !remote_match) {\n\t\tif (index && !same(index, remote) && !same(index, head))\n\t\t\treturn reject_merge(index, o);\n\t\treturn merged_entry(remote, index, o);\n\t}\n\t/*\n\t * If we have an entry in the index cache, then we want to\n\t * make sure that it matches head.\n\t */\n\tif (index && !same(index, head))\n\t\treturn reject_merge(index, o);\n\n\tif (head) {\n\t\t/* #5ALT, #15 */\n\t\tif (same(head, remote))\n\t\t\treturn merged_entry(head, index, o);\n\t\t/* #13, #3ALT */\n\t\tif (!df_conflict_remote && remote_match && !head_match)\n\t\t\treturn merged_entry(head, index, o);\n\t}\n\n\t/* #1 */\n\tif (!head && !remote && any_anc_missing)\n\t\treturn 0;\n\n\t/*\n\t * Under the \"aggressive\" rule, we resolve mostly trivial\n\t * cases that we historically had git-merge-one-file resolve.\n\t */\n\tif (o->aggressive) {\n\t\tint head_deleted = !head;\n\t\tint remote_deleted = !remote;\n\t\tconst struct cache_entry *ce = NULL;\n\n\t\tif (index)\n\t\t\tce = index;\n\t\telse if (head)\n\t\t\tce = head;\n\t\telse if (remote)\n\t\t\tce = remote;\n\t\telse {\n\t\t\tfor (i = 1; i < o->head_idx; i++) {\n\t\t\t\tif (stages[i] && stages[i] != o->df_conflict_entry) {\n\t\t\t\t\tce = stages[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Deleted in both.\n\t\t * Deleted in one and unchanged in the other.\n\t\t */\n\t\tif ((head_deleted && remote_deleted) ||\n\t\t    (head_deleted && remote && remote_match) ||\n\t\t    (remote_deleted && head && head_match)) {\n\t\t\tif (index)\n\t\t\t\treturn deleted_entry(index, index, o);\n\t\t\tif (ce && !head_deleted) {\n\t\t\t\tif (verify_absent(ce, ERROR_WOULD_LOSE_UNTRACKED_REMOVED, o))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Added in both, identically.\n\t\t */\n\t\tif (no_anc_exists && head && remote && same(head, remote))\n\t\t\treturn merged_entry(head, index, o);\n\n\t}\n\n\t/* Below are \"no merge\" cases, which require that the index be\n\t * up-to-date to avoid the files getting overwritten with\n\t * conflict resolution files.\n\t */\n\tif (index) {\n\t\tif (verify_uptodate(index, o))\n\t\t\treturn -1;\n\t}\n\n\to->nontrivial_merge = 1;\n\n\t/* #2, #3, #4, #6, #7, #9, #10, #11. */\n\tcount = 0;\n\tif (!head_match || !remote_match) {\n\t\tfor (i = 1; i < o->head_idx; i++) {\n\t\t\tif (stages[i] && stages[i] != o->df_conflict_entry) {\n\t\t\t\tkeep_entry(stages[i], o);\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#if DBRT_DEBUG\n\telse {\n\t\tfprintf(stderr, \"read-tree: warning #16 detected\\n\");\n\t\tshow_stage_entry(stderr, \"head   \", stages[head_match]);\n\t\tshow_stage_entry(stderr, \"remote \", stages[remote_match]);\n\t}\n#endif\n\tif (head) { count += keep_entry(head, o); }\n\tif (remote) { count += keep_entry(remote, o); }\n\treturn count;\n}\n\n/*\n * Two-way merge.\n *\n * The rule is to \"carry forward\" what is in the index without losing\n * information across a \"fast-forward\", favoring a successful merge\n * over a merge failure when it makes sense.  For details of the\n * \"carry forward\" rule, please see <Documentation/git-read-tree.txt>.\n *\n */\nint twoway_merge(const struct cache_entry * const *src,\n\t\t struct unpack_trees_options *o)\n{\n\tconst struct cache_entry *current = src[0];\n\tconst struct cache_entry *oldtree = src[1];\n\tconst struct cache_entry *newtree = src[2];\n\n\tif (o->merge_size != 2)\n\t\treturn error(\"Cannot do a twoway merge of %d trees\",\n\t\t\t     o->merge_size);\n\n\tif (oldtree == o->df_conflict_entry)\n\t\toldtree = NULL;\n\tif (newtree == o->df_conflict_entry)\n\t\tnewtree = NULL;\n\n\tif (current) {\n\t\tif (current->ce_flags & CE_CONFLICTED) {\n\t\t\tif (same(oldtree, newtree) || o->reset) {\n\t\t\t\tif (!newtree)\n\t\t\t\t\treturn deleted_entry(current, current, o);\n\t\t\t\telse\n\t\t\t\t\treturn merged_entry(newtree, current, o);\n\t\t\t}\n\t\t\treturn reject_merge(current, o);\n\t\t} else if ((!oldtree && !newtree) || /* 4 and 5 */\n\t\t\t (!oldtree && newtree &&\n\t\t\t  same(current, newtree)) || /* 6 and 7 */\n\t\t\t (oldtree && newtree &&\n\t\t\t  same(oldtree, newtree)) || /* 14 and 15 */\n\t\t\t (oldtree && newtree &&\n\t\t\t  !same(oldtree, newtree) && /* 18 and 19 */\n\t\t\t  same(current, newtree))) {\n\t\t\treturn keep_entry(current, o);\n\t\t} else if (oldtree && !newtree && same(current, oldtree)) {\n\t\t\t/* 10 or 11 */\n\t\t\treturn deleted_entry(oldtree, current, o);\n\t\t} else if (oldtree && newtree &&\n\t\t\t same(current, oldtree) && !same(current, newtree)) {\n\t\t\t/* 20 or 21 */\n\t\t\treturn merged_entry(newtree, current, o);\n\t\t} else\n\t\t\treturn reject_merge(current, o);\n\t}\n\telse if (newtree) {\n\t\tif (oldtree && !o->initial_checkout) {\n\t\t\t/*\n\t\t\t * deletion of the path was staged;\n\t\t\t */\n\t\t\tif (same(oldtree, newtree))\n\t\t\t\treturn 1;\n\t\t\treturn reject_merge(oldtree, o);\n\t\t}\n\t\treturn merged_entry(newtree, current, o);\n\t}\n\treturn deleted_entry(oldtree, current, o);\n}\n\n/*\n * Bind merge.\n *\n * Keep the index entries at stage0, collapse stage1 but make sure\n * stage0 does not have anything there.\n */\nint bind_merge(const struct cache_entry * const *src,\n\t       struct unpack_trees_options *o)\n{\n\tconst struct cache_entry *old = src[0];\n\tconst struct cache_entry *a = src[1];\n\n\tif (o->merge_size != 1)\n\t\treturn error(\"Cannot do a bind merge of %d trees\",\n\t\t\t     o->merge_size);\n\tif (a && old)\n\t\treturn o->gently ? -1 :\n\t\t\terror(ERRORMSG(o, ERROR_BIND_OVERLAP),\n\t\t\t      super_prefixed(a->name),\n\t\t\t      super_prefixed(old->name));\n\tif (!a)\n\t\treturn keep_entry(old, o);\n\telse\n\t\treturn merged_entry(a, NULL, o);\n}\n\n/*\n * One-way merge.\n *\n * The rule is:\n * - take the stat information from stage0, take the data from stage1\n */\nint oneway_merge(const struct cache_entry * const *src,\n\t\t struct unpack_trees_options *o)\n{\n\tconst struct cache_entry *old = src[0];\n\tconst struct cache_entry *a = src[1];\n\n\tif (o->merge_size != 1)\n\t\treturn error(\"Cannot do a oneway merge of %d trees\",\n\t\t\t     o->merge_size);\n\n\tif (!a || a == o->df_conflict_entry)\n\t\treturn deleted_entry(old, old, o);\n\n\tif (old && same(old, a)) {\n\t\tint update = 0;\n\t\tif (o->reset && o->update && !ce_uptodate(old) && !ce_skip_worktree(old)) {\n\t\t\tstruct stat st;\n\t\t\tif (lstat(old->name, &st) ||\n\t\t\t    ie_match_stat(o->src_index, old, &st, CE_MATCH_IGNORE_VALID|CE_MATCH_IGNORE_SKIP_WORKTREE))\n\t\t\t\tupdate |= CE_UPDATE;\n\t\t}\n\t\tadd_entry(o, old, update, 0);\n\t\treturn 0;\n\t}\n\treturn merged_entry(a, old, o);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0013a1194f15fe23dc8ce4014c885ad7bdb6cdfb",
  "sha1_ok": true,
  "size": 57761
}
