{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJsb2NrZmlsZS5oIgojaW5jbHVkZSAic2VxdWVuY2VyLmgiCiNpbmNsdWRlICJkaXIuaCIKI2luY2x1ZGUgIm9iamVjdC5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJleGVjX2NtZC5oIgojaW5jbHVkZSAidXRmOC5oIgojaW5jbHVkZSAiY2FjaGUtdHJlZS5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAicmV2aXNpb24uaCIKI2luY2x1ZGUgInJlcmVyZS5oIgojaW5jbHVkZSAibWVyZ2UtcmVjdXJzaXZlLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJhcmd2LWFycmF5LmgiCiNpbmNsdWRlICJxdW90ZS5oIgoKI2RlZmluZSBHSVRfUkVGTE9HX0FDVElPTiAiR0lUX1JFRkxPR19BQ1RJT04iCgpjb25zdCBjaGFyIHNpZ25fb2ZmX2hlYWRlcltdID0gIlNpZ25lZC1vZmYtYnk6ICI7CnN0YXRpYyBjb25zdCBjaGFyIGNoZXJyeV9waWNrZWRfcHJlZml4W10gPSAiKGNoZXJyeSBwaWNrZWQgZnJvbSBjb21taXQgIjsKCkdJVF9QQVRIX0ZVTkMoZ2l0X3BhdGhfc2VxX2RpciwgInNlcXVlbmNlciIpCgpzdGF0aWMgR0lUX1BBVEhfRlVOQyhnaXRfcGF0aF90b2RvX2ZpbGUsICJzZXF1ZW5jZXIvdG9kbyIpCnN0YXRpYyBHSVRfUEFUSF9GVU5DKGdpdF9wYXRoX29wdHNfZmlsZSwgInNlcXVlbmNlci9vcHRzIikKc3RhdGljIEdJVF9QQVRIX0ZVTkMoZ2l0X3BhdGhfaGVhZF9maWxlLCAic2VxdWVuY2VyL2hlYWQiKQoKLyoKICogQSBzY3JpcHQgdG8gc2V0IHRoZSBHSVRfQVVUSE9SX05BTUUsIEdJVF9BVVRIT1JfRU1BSUwsIGFuZAogKiBHSVRfQVVUSE9SX0RBVEUgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHRoZSBjb21taXQgdGhhdCBpcyBjdXJyZW50bHkKICogYmVpbmcgcmViYXNlZC4KICovCnN0YXRpYyBHSVRfUEFUSF9GVU5DKHJlYmFzZV9wYXRoX2F1dGhvcl9zY3JpcHQsICJyZWJhc2UtbWVyZ2UvYXV0aG9yLXNjcmlwdCIpCi8qCiAqIFRoZSBmb2xsb3dpbmcgZmlsZXMgYXJlIHdyaXR0ZW4gYnkgZ2l0LXJlYmFzZSBqdXN0IGFmdGVyIHBhcnNpbmcgdGhlCiAqIGNvbW1hbmQtbGluZSAoYW5kIGFyZSBvbmx5IGNvbnN1bWVkLCBub3QgbW9kaWZpZWQsIGJ5IHRoZSBzZXF1ZW5jZXIpLgogKi8Kc3RhdGljIEdJVF9QQVRIX0ZVTkMocmViYXNlX3BhdGhfZ3BnX3NpZ25fb3B0LCAicmViYXNlLW1lcmdlL2dwZ19zaWduX29wdCIpCgovKiBXZSB3aWxsIGludHJvZHVjZSB0aGUgJ2ludGVyYWN0aXZlIHJlYmFzZScgbW9kZSBsYXRlciAqLwpzdGF0aWMgaW5saW5lIGludCBpc19yZWJhc2VfaShjb25zdCBzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMpCnsKCXJldHVybiAwOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqZ2V0X2Rpcihjb25zdCBzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMpCnsKCXJldHVybiBnaXRfcGF0aF9zZXFfZGlyKCk7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpnZXRfdG9kb19wYXRoKGNvbnN0IHN0cnVjdCByZXBsYXlfb3B0cyAqb3B0cykKewoJcmV0dXJuIGdpdF9wYXRoX3RvZG9fZmlsZSgpOwp9CgpzdGF0aWMgaW50IGlzX3JmYzI4MjJfbGluZShjb25zdCBjaGFyICpidWYsIGludCBsZW4pCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykgewoJCWludCBjaCA9IGJ1ZltpXTsKCQlpZiAoY2ggPT0gJzonKQoJCQlyZXR1cm4gMTsKCQlpZiAoIWlzYWxudW0oY2gpICYmIGNoICE9ICctJykKCQkJYnJlYWs7Cgl9CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgaXNfY2hlcnJ5X3BpY2tlZF9mcm9tX2xpbmUoY29uc3QgY2hhciAqYnVmLCBpbnQgbGVuKQp7CgkvKgoJICogV2Ugb25seSBjYXJlIHRoYXQgaXQgbG9va3Mgcm91Z2hseSBsaWtlIChjaGVycnkgcGlja2VkIGZyb20gLi4uKQoJICovCglyZXR1cm4gbGVuID4gc3RybGVuKGNoZXJyeV9waWNrZWRfcHJlZml4KSArIDEgJiYKCQlzdGFydHNfd2l0aChidWYsIGNoZXJyeV9waWNrZWRfcHJlZml4KSAmJiBidWZbbGVuIC0gMV0gPT0gJyknOwp9CgovKgogKiBSZXR1cm5zIDAgZm9yIG5vbi1jb25mb3JtaW5nIGZvb3RlcgogKiBSZXR1cm5zIDEgZm9yIGNvbmZvcm1pbmcgZm9vdGVyCiAqIFJldHVybnMgMiB3aGVuIHNvYiBleGlzdHMgd2l0aGluIGNvbmZvcm1pbmcgZm9vdGVyCiAqIFJldHVybnMgMyB3aGVuIHNvYiBleGlzdHMgd2l0aGluIGNvbmZvcm1pbmcgZm9vdGVyIGFzIGxhc3QgZW50cnkKICovCnN0YXRpYyBpbnQgaGFzX2NvbmZvcm1pbmdfZm9vdGVyKHN0cnVjdCBzdHJidWYgKnNiLCBzdHJ1Y3Qgc3RyYnVmICpzb2IsCglpbnQgaWdub3JlX2Zvb3RlcikKewoJY2hhciBwcmV2OwoJaW50IGksIGs7CglpbnQgbGVuID0gc2ItPmxlbiAtIGlnbm9yZV9mb290ZXI7Cgljb25zdCBjaGFyICpidWYgPSBzYi0+YnVmOwoJaW50IGZvdW5kX3NvYiA9IDA7CgoJLyogZm9vdGVyIG11c3QgZW5kIHdpdGggbmV3bGluZSAqLwoJaWYgKCFsZW4gfHwgYnVmW2xlbiAtIDFdICE9ICdcbicpCgkJcmV0dXJuIDA7CgoJcHJldiA9ICdcMCc7Cglmb3IgKGkgPSBsZW4gLSAxOyBpID4gMDsgaS0tKSB7CgkJY2hhciBjaCA9IGJ1ZltpXTsKCQlpZiAocHJldiA9PSAnXG4nICYmIGNoID09ICdcbicpIC8qIHBhcmFncmFwaCBicmVhayAqLwoJCQlicmVhazsKCQlwcmV2ID0gY2g7Cgl9CgoJLyogcmVxdWlyZSBhdCBsZWFzdCBvbmUgYmxhbmsgbGluZSAqLwoJaWYgKHByZXYgIT0gJ1xuJyB8fCBidWZbaV0gIT0gJ1xuJykKCQlyZXR1cm4gMDsKCgkvKiBhZHZhbmNlIHRvIHN0YXJ0IG9mIGxhc3QgcGFyYWdyYXBoICovCgl3aGlsZSAoaSA8IGxlbiAtIDEgJiYgYnVmW2ldID09ICdcbicpCgkJaSsrOwoKCWZvciAoOyBpIDwgbGVuOyBpID0gaykgewoJCWludCBmb3VuZF9yZmMyODIyOwoKCQlmb3IgKGsgPSBpOyBrIDwgbGVuICYmIGJ1ZltrXSAhPSAnXG4nOyBrKyspCgkJCTsgLyogZG8gbm90aGluZyAqLwoJCWsrKzsKCgkJZm91bmRfcmZjMjgyMiA9IGlzX3JmYzI4MjJfbGluZShidWYgKyBpLCBrIC0gaSAtIDEpOwoJCWlmIChmb3VuZF9yZmMyODIyICYmIHNvYiAmJgoJCSAgICAhc3RybmNtcChidWYgKyBpLCBzb2ItPmJ1Ziwgc29iLT5sZW4pKQoJCQlmb3VuZF9zb2IgPSBrOwoKCQlpZiAoIShmb3VuZF9yZmMyODIyIHx8CgkJICAgICAgaXNfY2hlcnJ5X3BpY2tlZF9mcm9tX2xpbmUoYnVmICsgaSwgayAtIGkgLSAxKSkpCgkJCXJldHVybiAwOwoJfQoJaWYgKGZvdW5kX3NvYiA9PSBpKQoJCXJldHVybiAzOwoJaWYgKGZvdW5kX3NvYikKCQlyZXR1cm4gMjsKCXJldHVybiAxOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqZ3BnX3NpZ25fb3B0X3F1b3RlZChzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMpCnsKCXN0YXRpYyBzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoKCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCWlmIChvcHRzLT5ncGdfc2lnbikKCQlzcV9xdW90ZWYoJmJ1ZiwgIi1TJXMiLCBvcHRzLT5ncGdfc2lnbik7CglyZXR1cm4gYnVmLmJ1ZjsKfQoKaW50IHNlcXVlbmNlcl9yZW1vdmVfc3RhdGUoc3RydWN0IHJlcGxheV9vcHRzICpvcHRzKQp7CglzdHJ1Y3Qgc3RyYnVmIGRpciA9IFNUUkJVRl9JTklUOwoJaW50IGk7CgoJZnJlZShvcHRzLT5ncGdfc2lnbik7CglmcmVlKG9wdHMtPnN0cmF0ZWd5KTsKCWZvciAoaSA9IDA7IGkgPCBvcHRzLT54b3B0c19ucjsgaSsrKQoJCWZyZWUob3B0cy0+eG9wdHNbaV0pOwoJZnJlZShvcHRzLT54b3B0cyk7CgoJc3RyYnVmX2FkZGYoJmRpciwgIiVzIiwgZ2V0X2RpcihvcHRzKSk7CglyZW1vdmVfZGlyX3JlY3Vyc2l2ZWx5KCZkaXIsIDApOwoJc3RyYnVmX3JlbGVhc2UoJmRpcik7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICphY3Rpb25fbmFtZShjb25zdCBzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMpCnsKCXJldHVybiBvcHRzLT5hY3Rpb24gPT0gUkVQTEFZX1JFVkVSVCA/ICJyZXZlcnQiIDogImNoZXJyeS1waWNrIjsKfQoKc3RydWN0IGNvbW1pdF9tZXNzYWdlIHsKCWNoYXIgKnBhcmVudF9sYWJlbDsKCWNoYXIgKmxhYmVsOwoJY2hhciAqc3ViamVjdDsKCWNvbnN0IGNoYXIgKm1lc3NhZ2U7Cn07CgpzdGF0aWMgY29uc3QgY2hhciAqc2hvcnRfY29tbWl0X25hbWUoc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglyZXR1cm4gZmluZF91bmlxdWVfYWJicmV2KGNvbW1pdC0+b2JqZWN0Lm9pZC5oYXNoLCBERUZBVUxUX0FCQlJFVik7Cn0KCnN0YXRpYyBpbnQgZ2V0X21lc3NhZ2Uoc3RydWN0IGNvbW1pdCAqY29tbWl0LCBzdHJ1Y3QgY29tbWl0X21lc3NhZ2UgKm91dCkKewoJY29uc3QgY2hhciAqYWJicmV2LCAqc3ViamVjdDsKCWludCBzdWJqZWN0X2xlbjsKCglvdXQtPm1lc3NhZ2UgPSBsb2dtc2dfcmVlbmNvZGUoY29tbWl0LCBOVUxMLCBnZXRfY29tbWl0X291dHB1dF9lbmNvZGluZygpKTsKCWFiYnJldiA9IHNob3J0X2NvbW1pdF9uYW1lKGNvbW1pdCk7CgoJc3ViamVjdF9sZW4gPSBmaW5kX2NvbW1pdF9zdWJqZWN0KG91dC0+bWVzc2FnZSwgJnN1YmplY3QpOwoKCW91dC0+c3ViamVjdCA9IHhtZW1kdXB6KHN1YmplY3QsIHN1YmplY3RfbGVuKTsKCW91dC0+bGFiZWwgPSB4c3RyZm10KCIlcy4uLiAlcyIsIGFiYnJldiwgb3V0LT5zdWJqZWN0KTsKCW91dC0+cGFyZW50X2xhYmVsID0geHN0cmZtdCgicGFyZW50IG9mICVzIiwgb3V0LT5sYWJlbCk7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGZyZWVfbWVzc2FnZShzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHN0cnVjdCBjb21taXRfbWVzc2FnZSAqbXNnKQp7CglmcmVlKG1zZy0+cGFyZW50X2xhYmVsKTsKCWZyZWUobXNnLT5sYWJlbCk7CglmcmVlKG1zZy0+c3ViamVjdCk7Cgl1bnVzZV9jb21taXRfYnVmZmVyKGNvbW1pdCwgbXNnLT5tZXNzYWdlKTsKfQoKc3RhdGljIHZvaWQgcHJpbnRfYWR2aWNlKGludCBzaG93X2hpbnQsIHN0cnVjdCByZXBsYXlfb3B0cyAqb3B0cykKewoJY2hhciAqbXNnID0gZ2V0ZW52KCJHSVRfQ0hFUlJZX1BJQ0tfSEVMUCIpOwoKCWlmIChtc2cpIHsKCQlmcHJpbnRmKHN0ZGVyciwgIiVzXG4iLCBtc2cpOwoJCS8qCgkJICogQSBjb25mbGljdCBoYXMgb2NjdXJyZWQgYnV0IHRoZSBwb3JjZWxhaW4KCQkgKiAodHlwaWNhbGx5IHJlYmFzZSAtLWludGVyYWN0aXZlKSB3YW50cyB0byB0YWtlIGNhcmUKCQkgKiBvZiB0aGUgY29tbWl0IGl0c2VsZiBzbyByZW1vdmUgQ0hFUlJZX1BJQ0tfSEVBRAoJCSAqLwoJCXVubGluayhnaXRfcGF0aF9jaGVycnlfcGlja19oZWFkKCkpOwoJCXJldHVybjsKCX0KCglpZiAoc2hvd19oaW50KSB7CgkJaWYgKG9wdHMtPm5vX2NvbW1pdCkKCQkJYWR2aXNlKF8oImFmdGVyIHJlc29sdmluZyB0aGUgY29uZmxpY3RzLCBtYXJrIHRoZSBjb3JyZWN0ZWQgcGF0aHNcbiIKCQkJCSAid2l0aCAnZ2l0IGFkZCA8cGF0aHM+JyBvciAnZ2l0IHJtIDxwYXRocz4nIikpOwoJCWVsc2UKCQkJYWR2aXNlKF8oImFmdGVyIHJlc29sdmluZyB0aGUgY29uZmxpY3RzLCBtYXJrIHRoZSBjb3JyZWN0ZWQgcGF0aHNcbiIKCQkJCSAid2l0aCAnZ2l0IGFkZCA8cGF0aHM+JyBvciAnZ2l0IHJtIDxwYXRocz4nXG4iCgkJCQkgImFuZCBjb21taXQgdGhlIHJlc3VsdCB3aXRoICdnaXQgY29tbWl0JyIpKTsKCX0KfQoKc3RhdGljIGludCB3cml0ZV9tZXNzYWdlKGNvbnN0IHZvaWQgKmJ1Ziwgc2l6ZV90IGxlbiwgY29uc3QgY2hhciAqZmlsZW5hbWUsCgkJCSBpbnQgYXBwZW5kX2VvbCkKewoJc3RhdGljIHN0cnVjdCBsb2NrX2ZpbGUgbXNnX2ZpbGU7CgoJaW50IG1zZ19mZCA9IGhvbGRfbG9ja19maWxlX2Zvcl91cGRhdGUoJm1zZ19maWxlLCBmaWxlbmFtZSwgMCk7CglpZiAobXNnX2ZkIDwgMCkKCQlyZXR1cm4gZXJyb3JfZXJybm8oXygiQ291bGQgbm90IGxvY2sgJyVzJyIpLCBmaWxlbmFtZSk7CglpZiAod3JpdGVfaW5fZnVsbChtc2dfZmQsIGJ1ZiwgbGVuKSA8IDApIHsKCQlyb2xsYmFja19sb2NrX2ZpbGUoJm1zZ19maWxlKTsKCQlyZXR1cm4gZXJyb3JfZXJybm8oXygiQ291bGQgbm90IHdyaXRlIHRvICclcyciKSwgZmlsZW5hbWUpOwoJfQoJaWYgKGFwcGVuZF9lb2wgJiYgd3JpdGUobXNnX2ZkLCAiXG4iLCAxKSA8IDApIHsKCQlyb2xsYmFja19sb2NrX2ZpbGUoJm1zZ19maWxlKTsKCQlyZXR1cm4gZXJyb3JfZXJybm8oXygiQ291bGQgbm90IHdyaXRlIGVvbCB0byAnJXMiKSwgZmlsZW5hbWUpOwoJfQoJaWYgKGNvbW1pdF9sb2NrX2ZpbGUoJm1zZ19maWxlKSA8IDApIHsKCQlyb2xsYmFja19sb2NrX2ZpbGUoJm1zZ19maWxlKTsKCQlyZXR1cm4gZXJyb3IoXygiRXJyb3Igd3JhcHBpbmcgdXAgJXMuIiksIGZpbGVuYW1lKTsKCX0KCglyZXR1cm4gMDsKfQoKLyoKICogUmVhZHMgYSBmaWxlIHRoYXQgd2FzIHByZXN1bWFibHkgd3JpdHRlbiBieSBhIHNoZWxsIHNjcmlwdCwgaS5lLiB3aXRoIGFuCiAqIGVuZC1vZi1saW5lIG1hcmtlciB0aGF0IG5lZWRzIHRvIGJlIHN0cmlwcGVkLgogKgogKiBOb3RlIHRoYXQgb25seSB0aGUgbGFzdCBlbmQtb2YtbGluZSBtYXJrZXIgaXMgc3RyaXBwZWQsIGNvbnNpc3RlbnQgd2l0aCB0aGUKICogYmVoYXZpb3Igb2YgIiQoY2F0IHBhdGgpIiBpbiBhIHNoZWxsIHNjcmlwdC4KICoKICogUmV0dXJucyAxIGlmIHRoZSBmaWxlIHdhcyByZWFkLCAwIGlmIGl0IGNvdWxkIG5vdCBiZSByZWFkIG9yIGRvZXMgbm90IGV4aXN0LgogKi8Kc3RhdGljIGludCByZWFkX29uZWxpbmVyKHN0cnVjdCBzdHJidWYgKmJ1ZiwKCWNvbnN0IGNoYXIgKnBhdGgsIGludCBza2lwX2lmX2VtcHR5KQp7CglpbnQgb3JpZ19sZW4gPSBidWYtPmxlbjsKCglpZiAoIWZpbGVfZXhpc3RzKHBhdGgpKQoJCXJldHVybiAwOwoKCWlmIChzdHJidWZfcmVhZF9maWxlKGJ1ZiwgcGF0aCwgMCkgPCAwKSB7CgkJd2FybmluZ19lcnJubyhfKCJjb3VsZCBub3QgcmVhZCAnJXMnIiksIHBhdGgpOwoJCXJldHVybiAwOwoJfQoKCWlmIChidWYtPmxlbiA+IG9yaWdfbGVuICYmIGJ1Zi0+YnVmW2J1Zi0+bGVuIC0gMV0gPT0gJ1xuJykgewoJCWlmICgtLWJ1Zi0+bGVuID4gb3JpZ19sZW4gJiYgYnVmLT5idWZbYnVmLT5sZW4gLSAxXSA9PSAnXHInKQoJCQktLWJ1Zi0+bGVuOwoJCWJ1Zi0+YnVmW2J1Zi0+bGVuXSA9ICdcMCc7Cgl9CgoJaWYgKHNraXBfaWZfZW1wdHkgJiYgYnVmLT5sZW4gPT0gb3JpZ19sZW4pCgkJcmV0dXJuIDA7CgoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBzdHJ1Y3QgdHJlZSAqZW1wdHlfdHJlZSh2b2lkKQp7CglyZXR1cm4gbG9va3VwX3RyZWUoRU1QVFlfVFJFRV9TSEExX0JJTik7Cn0KCnN0YXRpYyBpbnQgZXJyb3JfZGlydHlfaW5kZXgoc3RydWN0IHJlcGxheV9vcHRzICpvcHRzKQp7CglpZiAocmVhZF9jYWNoZV91bm1lcmdlZCgpKQoJCXJldHVybiBlcnJvcl9yZXNvbHZlX2NvbmZsaWN0KGFjdGlvbl9uYW1lKG9wdHMpKTsKCgllcnJvcihfKCJZb3VyIGxvY2FsIGNoYW5nZXMgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgJXMuIiksCgkJYWN0aW9uX25hbWUob3B0cykpOwoKCWlmIChhZHZpY2VfY29tbWl0X2JlZm9yZV9tZXJnZSkKCQlhZHZpc2UoXygiQ29tbWl0IHlvdXIgY2hhbmdlcyBvciBzdGFzaCB0aGVtIHRvIHByb2NlZWQuIikpOwoJcmV0dXJuIC0xOwp9CgpzdGF0aWMgaW50IGZhc3RfZm9yd2FyZF90byhjb25zdCB1bnNpZ25lZCBjaGFyICp0bywgY29uc3QgdW5zaWduZWQgY2hhciAqZnJvbSwKCQkJaW50IHVuYm9ybiwgc3RydWN0IHJlcGxheV9vcHRzICpvcHRzKQp7CglzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0cmFuc2FjdGlvbjsKCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgZXJyID0gU1RSQlVGX0lOSVQ7CgoJcmVhZF9jYWNoZSgpOwoJaWYgKGNoZWNrb3V0X2Zhc3RfZm9yd2FyZChmcm9tLCB0bywgMSkpCgkJcmV0dXJuIC0xOyAvKiB0aGUgY2FsbGVlIHNob3VsZCBoYXZlIGNvbXBsYWluZWQgYWxyZWFkeSAqLwoKCXN0cmJ1Zl9hZGRmKCZzYiwgXygiJXM6IGZhc3QtZm9yd2FyZCIpLCBhY3Rpb25fbmFtZShvcHRzKSk7CgoJdHJhbnNhY3Rpb24gPSByZWZfdHJhbnNhY3Rpb25fYmVnaW4oJmVycik7CglpZiAoIXRyYW5zYWN0aW9uIHx8CgkgICAgcmVmX3RyYW5zYWN0aW9uX3VwZGF0ZSh0cmFuc2FjdGlvbiwgIkhFQUQiLAoJCQkJICAgdG8sIHVuYm9ybiA/IG51bGxfc2hhMSA6IGZyb20sCgkJCQkgICAwLCBzYi5idWYsICZlcnIpIHx8CgkgICAgcmVmX3RyYW5zYWN0aW9uX2NvbW1pdCh0cmFuc2FjdGlvbiwgJmVycikpIHsKCQlyZWZfdHJhbnNhY3Rpb25fZnJlZSh0cmFuc2FjdGlvbik7CgkJZXJyb3IoIiVzIiwgZXJyLmJ1Zik7CgkJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCQlzdHJidWZfcmVsZWFzZSgmZXJyKTsKCQlyZXR1cm4gLTE7Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCXN0cmJ1Zl9yZWxlYXNlKCZlcnIpOwoJcmVmX3RyYW5zYWN0aW9uX2ZyZWUodHJhbnNhY3Rpb24pOwoJcmV0dXJuIDA7Cn0KCnZvaWQgYXBwZW5kX2NvbmZsaWN0c19oaW50KHN0cnVjdCBzdHJidWYgKm1zZ2J1ZikKewoJaW50IGk7CgoJc3RyYnVmX2FkZGNoKG1zZ2J1ZiwgJ1xuJyk7CglzdHJidWZfY29tbWVudGVkX2FkZGYobXNnYnVmLCAiQ29uZmxpY3RzOlxuIik7Cglmb3IgKGkgPSAwOyBpIDwgYWN0aXZlX25yOykgewoJCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBhY3RpdmVfY2FjaGVbaSsrXTsKCQlpZiAoY2Vfc3RhZ2UoY2UpKSB7CgkJCXN0cmJ1Zl9jb21tZW50ZWRfYWRkZihtc2didWYsICJcdCVzXG4iLCBjZS0+bmFtZSk7CgkJCXdoaWxlIChpIDwgYWN0aXZlX25yICYmICFzdHJjbXAoY2UtPm5hbWUsCgkJCQkJCQlhY3RpdmVfY2FjaGVbaV0tPm5hbWUpKQoJCQkJaSsrOwoJCX0KCX0KfQoKc3RhdGljIGludCBkb19yZWN1cnNpdmVfbWVyZ2Uoc3RydWN0IGNvbW1pdCAqYmFzZSwgc3RydWN0IGNvbW1pdCAqbmV4dCwKCQkJICAgICAgY29uc3QgY2hhciAqYmFzZV9sYWJlbCwgY29uc3QgY2hhciAqbmV4dF9sYWJlbCwKCQkJICAgICAgdW5zaWduZWQgY2hhciAqaGVhZCwgc3RydWN0IHN0cmJ1ZiAqbXNnYnVmLAoJCQkgICAgICBzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMpCnsKCXN0cnVjdCBtZXJnZV9vcHRpb25zIG87CglzdHJ1Y3QgdHJlZSAqcmVzdWx0LCAqbmV4dF90cmVlLCAqYmFzZV90cmVlLCAqaGVhZF90cmVlOwoJaW50IGNsZWFuOwoJY2hhciAqKnhvcHQ7CglzdGF0aWMgc3RydWN0IGxvY2tfZmlsZSBpbmRleF9sb2NrOwoKCWhvbGRfbG9ja2VkX2luZGV4KCZpbmRleF9sb2NrLCAxKTsKCglyZWFkX2NhY2hlKCk7CgoJaW5pdF9tZXJnZV9vcHRpb25zKCZvKTsKCW8uYW5jZXN0b3IgPSBiYXNlID8gYmFzZV9sYWJlbCA6ICIoZW1wdHkgdHJlZSkiOwoJby5icmFuY2gxID0gIkhFQUQiOwoJby5icmFuY2gyID0gbmV4dCA/IG5leHRfbGFiZWwgOiAiKGVtcHR5IHRyZWUpIjsKCgloZWFkX3RyZWUgPSBwYXJzZV90cmVlX2luZGlyZWN0KGhlYWQpOwoJbmV4dF90cmVlID0gbmV4dCA/IG5leHQtPnRyZWUgOiBlbXB0eV90cmVlKCk7CgliYXNlX3RyZWUgPSBiYXNlID8gYmFzZS0+dHJlZSA6IGVtcHR5X3RyZWUoKTsKCglmb3IgKHhvcHQgPSBvcHRzLT54b3B0czsgeG9wdCAhPSBvcHRzLT54b3B0cyArIG9wdHMtPnhvcHRzX25yOyB4b3B0KyspCgkJcGFyc2VfbWVyZ2Vfb3B0KCZvLCAqeG9wdCk7CgoJY2xlYW4gPSBtZXJnZV90cmVlcygmbywKCQkJICAgIGhlYWRfdHJlZSwKCQkJICAgIG5leHRfdHJlZSwgYmFzZV90cmVlLCAmcmVzdWx0KTsKCXN0cmJ1Zl9yZWxlYXNlKCZvLm9idWYpOwoJaWYgKGNsZWFuIDwgMCkKCQlyZXR1cm4gY2xlYW47CgoJaWYgKGFjdGl2ZV9jYWNoZV9jaGFuZ2VkICYmCgkgICAgd3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZpbmRleF9sb2NrLCBDT01NSVRfTE9DSykpCgkJLyogVFJBTlNMQVRPUlM6ICVzIHdpbGwgYmUgInJldmVydCIgb3IgImNoZXJyeS1waWNrIiAqLwoJCXJldHVybiBlcnJvcihfKCIlczogVW5hYmxlIHRvIHdyaXRlIG5ldyBpbmRleCBmaWxlIiksCgkJCWFjdGlvbl9uYW1lKG9wdHMpKTsKCXJvbGxiYWNrX2xvY2tfZmlsZSgmaW5kZXhfbG9jayk7CgoJaWYgKG9wdHMtPnNpZ25vZmYpCgkJYXBwZW5kX3NpZ25vZmYobXNnYnVmLCAwLCAwKTsKCglpZiAoIWNsZWFuKQoJCWFwcGVuZF9jb25mbGljdHNfaGludChtc2didWYpOwoKCXJldHVybiAhY2xlYW47Cn0KCnN0YXRpYyBpbnQgaXNfaW5kZXhfdW5jaGFuZ2VkKHZvaWQpCnsKCXVuc2lnbmVkIGNoYXIgaGVhZF9zaGExWzIwXTsKCXN0cnVjdCBjb21taXQgKmhlYWRfY29tbWl0OwoKCWlmICghcmVzb2x2ZV9yZWZfdW5zYWZlKCJIRUFEIiwgUkVTT0xWRV9SRUZfUkVBRElORywgaGVhZF9zaGExLCBOVUxMKSkKCQlyZXR1cm4gZXJyb3IoXygiQ291bGQgbm90IHJlc29sdmUgSEVBRCBjb21taXRcbiIpKTsKCgloZWFkX2NvbW1pdCA9IGxvb2t1cF9jb21taXQoaGVhZF9zaGExKTsKCgkvKgoJICogSWYgaGVhZF9jb21taXQgaXMgTlVMTCwgY2hlY2tfY29tbWl0LCBjYWxsZWQgZnJvbQoJICogbG9va3VwX2NvbW1pdCwgd291bGQgaGF2ZSBpbmRpY2F0ZWQgdGhhdCBoZWFkX2NvbW1pdCBpcyBub3QKCSAqIGEgY29tbWl0IG9iamVjdCBhbHJlYWR5LiAgcGFyc2VfY29tbWl0KCkgd2lsbCByZXR1cm4gZmFpbHVyZQoJICogd2l0aG91dCBmdXJ0aGVyIGNvbXBsYWludHMgaW4gc3VjaCBhIGNhc2UuICBPdGhlcndpc2UsIGlmCgkgKiB0aGUgY29tbWl0IGlzIGludmFsaWQsIHBhcnNlX2NvbW1pdCgpIHdpbGwgY29tcGxhaW4uICBTbwoJICogdGhlcmUgaXMgbm90aGluZyBmb3IgdXMgdG8gc2F5IGhlcmUuICBKdXN0IHJldHVybiBmYWlsdXJlLgoJICovCglpZiAocGFyc2VfY29tbWl0KGhlYWRfY29tbWl0KSkKCQlyZXR1cm4gLTE7CgoJaWYgKCFhY3RpdmVfY2FjaGVfdHJlZSkKCQlhY3RpdmVfY2FjaGVfdHJlZSA9IGNhY2hlX3RyZWUoKTsKCglpZiAoIWNhY2hlX3RyZWVfZnVsbHlfdmFsaWQoYWN0aXZlX2NhY2hlX3RyZWUpKQoJCWlmIChjYWNoZV90cmVlX3VwZGF0ZSgmdGhlX2luZGV4LCAwKSkKCQkJcmV0dXJuIGVycm9yKF8oIlVuYWJsZSB0byB1cGRhdGUgY2FjaGUgdHJlZVxuIikpOwoKCXJldHVybiAhaGFzaGNtcChhY3RpdmVfY2FjaGVfdHJlZS0+c2hhMSwgaGVhZF9jb21taXQtPnRyZWUtPm9iamVjdC5vaWQuaGFzaCk7Cn0KCi8qCiAqIFJlYWQgdGhlIGF1dGhvci1zY3JpcHQgZmlsZSBpbnRvIGFuIGVudmlyb25tZW50IGJsb2NrLCByZWFkeSBmb3IgdXNlIGluCiAqIHJ1bl9jb21tYW5kKCksIHRoYXQgY2FuIGJlIGZyZWUoKWQgYWZ0ZXJ3YXJkcy4KICovCnN0YXRpYyBjaGFyICoqcmVhZF9hdXRob3Jfc2NyaXB0KHZvaWQpCnsKCXN0cnVjdCBzdHJidWYgc2NyaXB0ID0gU1RSQlVGX0lOSVQ7CglpbnQgaSwgY291bnQgPSAwOwoJY2hhciAqcCwgKnAyLCAqKmVudjsKCXNpemVfdCBlbnZfc2l6ZTsKCglpZiAoc3RyYnVmX3JlYWRfZmlsZSgmc2NyaXB0LCByZWJhc2VfcGF0aF9hdXRob3Jfc2NyaXB0KCksIDI1NikgPD0gMCkKCQlyZXR1cm4gTlVMTDsKCglmb3IgKHAgPSBzY3JpcHQuYnVmOyAqcDsgcCsrKQoJCWlmIChza2lwX3ByZWZpeChwLCAiJ1xcXFwnJyIsIChjb25zdCBjaGFyICoqKSZwMikpCgkJCXN0cmJ1Zl9zcGxpY2UoJnNjcmlwdCwgcCAtIHNjcmlwdC5idWYsIHAyIC0gcCwgIiciLCAxKTsKCQllbHNlIGlmICgqcCA9PSAnXCcnKQoJCQlzdHJidWZfc3BsaWNlKCZzY3JpcHQsIHAtLSAtIHNjcmlwdC5idWYsIDEsICIiLCAwKTsKCQllbHNlIGlmICgqcCA9PSAnXG4nKSB7CgkJCSpwID0gJ1wwJzsKCQkJY291bnQrKzsKCQl9CgoJZW52X3NpemUgPSAoY291bnQgKyAxKSAqIHNpemVvZigqZW52KTsKCXN0cmJ1Zl9ncm93KCZzY3JpcHQsIGVudl9zaXplKTsKCW1lbW1vdmUoc2NyaXB0LmJ1ZiArIGVudl9zaXplLCBzY3JpcHQuYnVmLCBzY3JpcHQubGVuKTsKCXAgPSBzY3JpcHQuYnVmICsgZW52X3NpemU7CgllbnYgPSAoY2hhciAqKilzdHJidWZfZGV0YWNoKCZzY3JpcHQsIE5VTEwpOwoKCWZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7CgkJZW52W2ldID0gcDsKCQlwICs9IHN0cmxlbihwKSArIDE7Cgl9CgllbnZbY291bnRdID0gTlVMTDsKCglyZXR1cm4gZW52Owp9CgovKgogKiBJZiB3ZSBhcmUgY2hlcnJ5LXBpY2ssIGFuZCBpZiB0aGUgbWVyZ2UgZGlkIG5vdCByZXN1bHQgaW4KICogaGFuZC1lZGl0aW5nLCB3ZSB3aWxsIGhpdCB0aGlzIGNvbW1pdCBhbmQgaW5oZXJpdCB0aGUgb3JpZ2luYWwKICogYXV0aG9yIGRhdGUgYW5kIG5hbWUuCiAqCiAqIElmIHdlIGFyZSByZXZlcnQsIG9yIGlmIG91ciBjaGVycnktcGljayByZXN1bHRzIGluIGEgaGFuZCBtZXJnZSwKICogd2UgaGFkIGJldHRlciBzYXkgdGhhdCB0aGUgY3VycmVudCB1c2VyIGlzIHJlc3BvbnNpYmxlIGZvciB0aGF0LgogKgogKiBBbiBleGNlcHRpb24gaXMgd2hlbiBydW5fZ2l0X2NvbW1pdCgpIGlzIGNhbGxlZCBkdXJpbmcgYW4KICogaW50ZXJhY3RpdmUgcmViYXNlOiBpbiB0aGF0IGNhc2UsIHdlIHdpbGwgd2FudCB0byByZXRhaW4gdGhlCiAqIGF1dGhvciBtZXRhZGF0YS4KICovCnN0YXRpYyBpbnQgcnVuX2dpdF9jb21taXQoY29uc3QgY2hhciAqZGVmbXNnLCBzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMsCgkJCSAgaW50IGFsbG93X2VtcHR5LCBpbnQgZWRpdCwgaW50IGFtZW5kLAoJCQkgIGludCBjbGVhbnVwX2NvbW1pdF9tZXNzYWdlKQp7CgljaGFyICoqZW52ID0gTlVMTDsKCXN0cnVjdCBhcmd2X2FycmF5IGFycmF5OwoJaW50IHJjOwoJY29uc3QgY2hhciAqdmFsdWU7CgoJaWYgKGlzX3JlYmFzZV9pKG9wdHMpKSB7CgkJZW52ID0gcmVhZF9hdXRob3Jfc2NyaXB0KCk7CgkJaWYgKCFlbnYpIHsKCQkJY29uc3QgY2hhciAqZ3BnX29wdCA9IGdwZ19zaWduX29wdF9xdW90ZWQob3B0cyk7CgoJCQlyZXR1cm4gZXJyb3IoIllvdSBoYXZlIHN0YWdlZCBjaGFuZ2VzIGluIHlvdXIgd29ya2luZyAiCgkJCQkidHJlZS4gSWYgdGhlc2UgY2hhbmdlcyBhcmUgbWVhbnQgdG8gYmVcbiIKCQkJCSJzcXVhc2hlZCBpbnRvIHRoZSBwcmV2aW91cyBjb21taXQsIHJ1bjpcblxuIgoJCQkJIiAgZ2l0IGNvbW1pdCAtLWFtZW5kICVzXG5cbiIKCQkJCSJJZiB0aGV5IGFyZSBtZWFudCB0byBnbyBpbnRvIGEgbmV3IGNvbW1pdCwgIgoJCQkJInJ1bjpcblxuIgoJCQkJIiAgZ2l0IGNvbW1pdCAlc1xuXG4iCgkJCQkiSW4gYm90aCBjYXNlcywgb25jZSB5b3UncmUgZG9uZSwgY29udGludWUgIgoJCQkJIndpdGg6XG5cbiIKCQkJCSIgIGdpdCByZWJhc2UgLS1jb250aW51ZVxuIiwgZ3BnX29wdCwgZ3BnX29wdCk7CgkJfQoJfQoKCWFyZ3ZfYXJyYXlfaW5pdCgmYXJyYXkpOwoJYXJndl9hcnJheV9wdXNoKCZhcnJheSwgImNvbW1pdCIpOwoJYXJndl9hcnJheV9wdXNoKCZhcnJheSwgIi1uIik7CgoJaWYgKGFtZW5kKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJyYXksICItLWFtZW5kIik7CglpZiAob3B0cy0+Z3BnX3NpZ24pCgkJYXJndl9hcnJheV9wdXNoZigmYXJyYXksICItUyVzIiwgb3B0cy0+Z3BnX3NpZ24pOwoJaWYgKG9wdHMtPnNpZ25vZmYpCgkJYXJndl9hcnJheV9wdXNoKCZhcnJheSwgIi1zIik7CglpZiAoZGVmbXNnKQoJCWFyZ3ZfYXJyYXlfcHVzaGwoJmFycmF5LCAiLUYiLCBkZWZtc2csIE5VTEwpOwoJaWYgKGNsZWFudXBfY29tbWl0X21lc3NhZ2UpCgkJYXJndl9hcnJheV9wdXNoKCZhcnJheSwgIi0tY2xlYW51cD1zdHJpcCIpOwoJaWYgKGVkaXQpCgkJYXJndl9hcnJheV9wdXNoKCZhcnJheSwgIi1lIik7CgllbHNlIGlmICghY2xlYW51cF9jb21taXRfbWVzc2FnZSAmJgoJCSAhb3B0cy0+c2lnbm9mZiAmJiAhb3B0cy0+cmVjb3JkX29yaWdpbiAmJgoJCSBnaXRfY29uZmlnX2dldF92YWx1ZSgiY29tbWl0LmNsZWFudXAiLCAmdmFsdWUpKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJyYXksICItLWNsZWFudXA9dmVyYmF0aW0iKTsKCglpZiAoYWxsb3dfZW1wdHkpCgkJYXJndl9hcnJheV9wdXNoKCZhcnJheSwgIi0tYWxsb3ctZW1wdHkiKTsKCglpZiAob3B0cy0+YWxsb3dfZW1wdHlfbWVzc2FnZSkKCQlhcmd2X2FycmF5X3B1c2goJmFycmF5LCAiLS1hbGxvdy1lbXB0eS1tZXNzYWdlIik7CgoJcmMgPSBydW5fY29tbWFuZF92X29wdF9jZF9lbnYoYXJyYXkuYXJndiwgUlVOX0dJVF9DTUQsIE5VTEwsCgkJCShjb25zdCBjaGFyICpjb25zdCAqKWVudik7Cglhcmd2X2FycmF5X2NsZWFyKCZhcnJheSk7CglmcmVlKGVudik7CgoJcmV0dXJuIHJjOwp9CgpzdGF0aWMgaW50IGlzX29yaWdpbmFsX2NvbW1pdF9lbXB0eShzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCWNvbnN0IHVuc2lnbmVkIGNoYXIgKnB0cmVlX3NoYTE7CgoJaWYgKHBhcnNlX2NvbW1pdChjb21taXQpKQoJCXJldHVybiBlcnJvcihfKCJDb3VsZCBub3QgcGFyc2UgY29tbWl0ICVzXG4iKSwKCQkJICAgICBvaWRfdG9faGV4KCZjb21taXQtPm9iamVjdC5vaWQpKTsKCWlmIChjb21taXQtPnBhcmVudHMpIHsKCQlzdHJ1Y3QgY29tbWl0ICpwYXJlbnQgPSBjb21taXQtPnBhcmVudHMtPml0ZW07CgkJaWYgKHBhcnNlX2NvbW1pdChwYXJlbnQpKQoJCQlyZXR1cm4gZXJyb3IoXygiQ291bGQgbm90IHBhcnNlIHBhcmVudCBjb21taXQgJXNcbiIpLAoJCQkJb2lkX3RvX2hleCgmcGFyZW50LT5vYmplY3Qub2lkKSk7CgkJcHRyZWVfc2hhMSA9IHBhcmVudC0+dHJlZS0+b2JqZWN0Lm9pZC5oYXNoOwoJfSBlbHNlIHsKCQlwdHJlZV9zaGExID0gRU1QVFlfVFJFRV9TSEExX0JJTjsgLyogY29tbWl0IGlzIHJvb3QgKi8KCX0KCglyZXR1cm4gIWhhc2hjbXAocHRyZWVfc2hhMSwgY29tbWl0LT50cmVlLT5vYmplY3Qub2lkLmhhc2gpOwp9CgovKgogKiBEbyB3ZSBydW4gImdpdCBjb21taXQiIHdpdGggIi0tYWxsb3ctZW1wdHkiPwogKi8Kc3RhdGljIGludCBhbGxvd19lbXB0eShzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMsIHN0cnVjdCBjb21taXQgKmNvbW1pdCkKewoJaW50IGluZGV4X3VuY2hhbmdlZCwgZW1wdHlfY29tbWl0OwoKCS8qCgkgKiBUaHJlZSBjYXNlczoKCSAqCgkgKiAoMSkgd2UgZG8gbm90IGFsbG93IGVtcHR5IGF0IGFsbCBhbmQgZXJyb3Igb3V0LgoJICoKCSAqICgyKSB3ZSBhbGxvdyBvbmVzIHRoYXQgd2VyZSBpbml0aWFsbHkgZW1wdHksIGJ1dAoJICogZm9yYmlkIHRoZSBvbmVzIHRoYXQgYmVjb21lIGVtcHR5OwoJICoKCSAqICgzKSB3ZSBhbGxvdyBib3RoLgoJICovCglpZiAoIW9wdHMtPmFsbG93X2VtcHR5KQoJCXJldHVybiAwOyAvKiBsZXQgImdpdCBjb21taXQiIGJhcmYgYXMgbmVjZXNzYXJ5ICovCgoJaW5kZXhfdW5jaGFuZ2VkID0gaXNfaW5kZXhfdW5jaGFuZ2VkKCk7CglpZiAoaW5kZXhfdW5jaGFuZ2VkIDwgMCkKCQlyZXR1cm4gaW5kZXhfdW5jaGFuZ2VkOwoJaWYgKCFpbmRleF91bmNoYW5nZWQpCgkJcmV0dXJuIDA7IC8qIHdlIGRvIG5vdCBoYXZlIHRvIHNheSAtLWFsbG93LWVtcHR5ICovCgoJaWYgKG9wdHMtPmtlZXBfcmVkdW5kYW50X2NvbW1pdHMpCgkJcmV0dXJuIDE7CgoJZW1wdHlfY29tbWl0ID0gaXNfb3JpZ2luYWxfY29tbWl0X2VtcHR5KGNvbW1pdCk7CglpZiAoZW1wdHlfY29tbWl0IDwgMCkKCQlyZXR1cm4gZW1wdHlfY29tbWl0OwoJaWYgKCFlbXB0eV9jb21taXQpCgkJcmV0dXJuIDA7CgllbHNlCgkJcmV0dXJuIDE7Cn0KCmVudW0gdG9kb19jb21tYW5kIHsKCVRPRE9fUElDSyA9IDAsCglUT0RPX1JFVkVSVAp9OwoKc3RhdGljIGNvbnN0IGNoYXIgKnRvZG9fY29tbWFuZF9zdHJpbmdzW10gPSB7CgkicGljayIsCgkicmV2ZXJ0Igp9OwoKc3RhdGljIGNvbnN0IGNoYXIgKmNvbW1hbmRfdG9fc3RyaW5nKGNvbnN0IGVudW0gdG9kb19jb21tYW5kIGNvbW1hbmQpCnsKCWlmIChjb21tYW5kIDwgQVJSQVlfU0laRSh0b2RvX2NvbW1hbmRfc3RyaW5ncykpCgkJcmV0dXJuIHRvZG9fY29tbWFuZF9zdHJpbmdzW2NvbW1hbmRdOwoJZGllKCJVbmtub3duIGNvbW1hbmQ6ICVkIiwgY29tbWFuZCk7Cn0KCgpzdGF0aWMgaW50IGRvX3BpY2tfY29tbWl0KGVudW0gdG9kb19jb21tYW5kIGNvbW1hbmQsIHN0cnVjdCBjb21taXQgKmNvbW1pdCwKCQlzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMpCnsKCXVuc2lnbmVkIGNoYXIgaGVhZFsyMF07CglzdHJ1Y3QgY29tbWl0ICpiYXNlLCAqbmV4dCwgKnBhcmVudDsKCWNvbnN0IGNoYXIgKmJhc2VfbGFiZWwsICpuZXh0X2xhYmVsOwoJc3RydWN0IGNvbW1pdF9tZXNzYWdlIG1zZyA9IHsgTlVMTCwgTlVMTCwgTlVMTCwgTlVMTCB9OwoJc3RydWN0IHN0cmJ1ZiBtc2didWYgPSBTVFJCVUZfSU5JVDsKCWludCByZXMsIHVuYm9ybiA9IDAsIGFsbG93OwoKCWlmIChvcHRzLT5ub19jb21taXQpIHsKCQkvKgoJCSAqIFdlIGRvIG5vdCBpbnRlbmQgdG8gY29tbWl0IGltbWVkaWF0ZWx5LiAgV2UganVzdCB3YW50IHRvCgkJICogbWVyZ2UgdGhlIGRpZmZlcmVuY2VzIGluLCBzbyBsZXQncyBjb21wdXRlIHRoZSB0cmVlCgkJICogdGhhdCByZXByZXNlbnRzIHRoZSAiY3VycmVudCIgc3RhdGUgZm9yIG1lcmdlLXJlY3Vyc2l2ZQoJCSAqIHRvIHdvcmsgb24uCgkJICovCgkJaWYgKHdyaXRlX2NhY2hlX2FzX3RyZWUoaGVhZCwgMCwgTlVMTCkpCgkJCXJldHVybiBlcnJvcihfKCJZb3VyIGluZGV4IGZpbGUgaXMgdW5tZXJnZWQuIikpOwoJfSBlbHNlIHsKCQl1bmJvcm4gPSBnZXRfc2hhMSgiSEVBRCIsIGhlYWQpOwoJCWlmICh1bmJvcm4pCgkJCWhhc2hjcHkoaGVhZCwgRU1QVFlfVFJFRV9TSEExX0JJTik7CgkJaWYgKGluZGV4X2RpZmZlcnNfZnJvbSh1bmJvcm4gPyBFTVBUWV9UUkVFX1NIQTFfSEVYIDogIkhFQUQiLCAwKSkKCQkJcmV0dXJuIGVycm9yX2RpcnR5X2luZGV4KG9wdHMpOwoJfQoJZGlzY2FyZF9jYWNoZSgpOwoKCWlmICghY29tbWl0LT5wYXJlbnRzKSB7CgkJcGFyZW50ID0gTlVMTDsKCX0KCWVsc2UgaWYgKGNvbW1pdC0+cGFyZW50cy0+bmV4dCkgewoJCS8qIFJldmVydGluZyBvciBjaGVycnktcGlja2luZyBhIG1lcmdlIGNvbW1pdCAqLwoJCWludCBjbnQ7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpwOwoKCQlpZiAoIW9wdHMtPm1haW5saW5lKQoJCQlyZXR1cm4gZXJyb3IoXygiQ29tbWl0ICVzIGlzIGEgbWVyZ2UgYnV0IG5vIC1tIG9wdGlvbiB3YXMgZ2l2ZW4uIiksCgkJCQlvaWRfdG9faGV4KCZjb21taXQtPm9iamVjdC5vaWQpKTsKCgkJZm9yIChjbnQgPSAxLCBwID0gY29tbWl0LT5wYXJlbnRzOwoJCSAgICAgY250ICE9IG9wdHMtPm1haW5saW5lICYmIHA7CgkJICAgICBjbnQrKykKCQkJcCA9IHAtPm5leHQ7CgkJaWYgKGNudCAhPSBvcHRzLT5tYWlubGluZSB8fCAhcCkKCQkJcmV0dXJuIGVycm9yKF8oIkNvbW1pdCAlcyBkb2VzIG5vdCBoYXZlIHBhcmVudCAlZCIpLAoJCQkJb2lkX3RvX2hleCgmY29tbWl0LT5vYmplY3Qub2lkKSwgb3B0cy0+bWFpbmxpbmUpOwoJCXBhcmVudCA9IHAtPml0ZW07Cgl9IGVsc2UgaWYgKDAgPCBvcHRzLT5tYWlubGluZSkKCQlyZXR1cm4gZXJyb3IoXygiTWFpbmxpbmUgd2FzIHNwZWNpZmllZCBidXQgY29tbWl0ICVzIGlzIG5vdCBhIG1lcmdlLiIpLAoJCQlvaWRfdG9faGV4KCZjb21taXQtPm9iamVjdC5vaWQpKTsKCWVsc2UKCQlwYXJlbnQgPSBjb21taXQtPnBhcmVudHMtPml0ZW07CgoJaWYgKG9wdHMtPmFsbG93X2ZmICYmCgkgICAgKChwYXJlbnQgJiYgIWhhc2hjbXAocGFyZW50LT5vYmplY3Qub2lkLmhhc2gsIGhlYWQpKSB8fAoJICAgICAoIXBhcmVudCAmJiB1bmJvcm4pKSkKCQlyZXR1cm4gZmFzdF9mb3J3YXJkX3RvKGNvbW1pdC0+b2JqZWN0Lm9pZC5oYXNoLCBoZWFkLCB1bmJvcm4sIG9wdHMpOwoKCWlmIChwYXJlbnQgJiYgcGFyc2VfY29tbWl0KHBhcmVudCkgPCAwKQoJCS8qIFRSQU5TTEFUT1JTOiBUaGUgZmlyc3QgJXMgd2lsbCBiZSBhICJ0b2RvIiBjb21tYW5kIGxpa2UKCQkgICAicmV2ZXJ0IiBvciAicGljayIsIHRoZSBzZWNvbmQgJXMgYSBTSEExLiAqLwoJCXJldHVybiBlcnJvcihfKCIlczogY2Fubm90IHBhcnNlIHBhcmVudCBjb21taXQgJXMiKSwKCQkJY29tbWFuZF90b19zdHJpbmcoY29tbWFuZCksCgkJCW9pZF90b19oZXgoJnBhcmVudC0+b2JqZWN0Lm9pZCkpOwoKCWlmIChnZXRfbWVzc2FnZShjb21taXQsICZtc2cpICE9IDApCgkJcmV0dXJuIGVycm9yKF8oIkNhbm5vdCBnZXQgY29tbWl0IG1lc3NhZ2UgZm9yICVzIiksCgkJCW9pZF90b19oZXgoJmNvbW1pdC0+b2JqZWN0Lm9pZCkpOwoKCS8qCgkgKiAiY29tbWl0IiBpcyBhbiBleGlzdGluZyBjb21taXQuICBXZSB3b3VsZCB3YW50IHRvIGFwcGx5CgkgKiB0aGUgZGlmZmVyZW5jZSBpdCBpbnRyb2R1Y2VzIHNpbmNlIGl0cyBmaXJzdCBwYXJlbnQgInByZXYiCgkgKiBvbiB0b3Agb2YgdGhlIGN1cnJlbnQgSEVBRCBpZiB3ZSBhcmUgY2hlcnJ5LXBpY2suICBPciB0aGUKCSAqIHJldmVyc2Ugb2YgaXQgaWYgd2UgYXJlIHJldmVydC4KCSAqLwoKCWlmIChjb21tYW5kID09IFRPRE9fUkVWRVJUKSB7CgkJYmFzZSA9IGNvbW1pdDsKCQliYXNlX2xhYmVsID0gbXNnLmxhYmVsOwoJCW5leHQgPSBwYXJlbnQ7CgkJbmV4dF9sYWJlbCA9IG1zZy5wYXJlbnRfbGFiZWw7CgkJc3RyYnVmX2FkZHN0cigmbXNnYnVmLCAiUmV2ZXJ0IFwiIik7CgkJc3RyYnVmX2FkZHN0cigmbXNnYnVmLCBtc2cuc3ViamVjdCk7CgkJc3RyYnVmX2FkZHN0cigmbXNnYnVmLCAiXCJcblxuVGhpcyByZXZlcnRzIGNvbW1pdCAiKTsKCQlzdHJidWZfYWRkc3RyKCZtc2didWYsIG9pZF90b19oZXgoJmNvbW1pdC0+b2JqZWN0Lm9pZCkpOwoKCQlpZiAoY29tbWl0LT5wYXJlbnRzICYmIGNvbW1pdC0+cGFyZW50cy0+bmV4dCkgewoJCQlzdHJidWZfYWRkc3RyKCZtc2didWYsICIsIHJldmVyc2luZ1xuY2hhbmdlcyBtYWRlIHRvICIpOwoJCQlzdHJidWZfYWRkc3RyKCZtc2didWYsIG9pZF90b19oZXgoJnBhcmVudC0+b2JqZWN0Lm9pZCkpOwoJCX0KCQlzdHJidWZfYWRkc3RyKCZtc2didWYsICIuXG4iKTsKCX0gZWxzZSB7CgkJY29uc3QgY2hhciAqcDsKCgkJYmFzZSA9IHBhcmVudDsKCQliYXNlX2xhYmVsID0gbXNnLnBhcmVudF9sYWJlbDsKCQluZXh0ID0gY29tbWl0OwoJCW5leHRfbGFiZWwgPSBtc2cubGFiZWw7CgoJCS8qCgkJICogQXBwZW5kIHRoZSBjb21taXQgbG9nIG1lc3NhZ2UgdG8gbXNnYnVmOyBpdCBzdGFydHMKCQkgKiBhZnRlciB0aGUgdHJlZSwgcGFyZW50LCBhdXRob3IsIGNvbW1pdHRlcgoJCSAqIGluZm9ybWF0aW9uIGZvbGxvd2VkIGJ5ICJcblxuIi4KCQkgKi8KCQlwID0gc3Ryc3RyKG1zZy5tZXNzYWdlLCAiXG5cbiIpOwoJCWlmIChwKQoJCQlzdHJidWZfYWRkc3RyKCZtc2didWYsIHNraXBfYmxhbmtfbGluZXMocCArIDIpKTsKCgkJaWYgKG9wdHMtPnJlY29yZF9vcmlnaW4pIHsKCQkJaWYgKCFoYXNfY29uZm9ybWluZ19mb290ZXIoJm1zZ2J1ZiwgTlVMTCwgMCkpCgkJCQlzdHJidWZfYWRkY2goJm1zZ2J1ZiwgJ1xuJyk7CgkJCXN0cmJ1Zl9hZGRzdHIoJm1zZ2J1ZiwgY2hlcnJ5X3BpY2tlZF9wcmVmaXgpOwoJCQlzdHJidWZfYWRkc3RyKCZtc2didWYsIG9pZF90b19oZXgoJmNvbW1pdC0+b2JqZWN0Lm9pZCkpOwoJCQlzdHJidWZfYWRkc3RyKCZtc2didWYsICIpXG4iKTsKCQl9Cgl9CgoJaWYgKCFvcHRzLT5zdHJhdGVneSB8fCAhc3RyY21wKG9wdHMtPnN0cmF0ZWd5LCAicmVjdXJzaXZlIikgfHwgY29tbWFuZCA9PSBUT0RPX1JFVkVSVCkgewoJCXJlcyA9IGRvX3JlY3Vyc2l2ZV9tZXJnZShiYXNlLCBuZXh0LCBiYXNlX2xhYmVsLCBuZXh0X2xhYmVsLAoJCQkJCSBoZWFkLCAmbXNnYnVmLCBvcHRzKTsKCQlpZiAocmVzIDwgMCkKCQkJcmV0dXJuIHJlczsKCQlyZXMgfD0gd3JpdGVfbWVzc2FnZShtc2didWYuYnVmLCBtc2didWYubGVuLAoJCQkJICAgICBnaXRfcGF0aF9tZXJnZV9tc2coKSwgMCk7Cgl9IGVsc2UgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqY29tbW9uID0gTlVMTDsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlbW90ZXMgPSBOVUxMOwoKCQlyZXMgPSB3cml0ZV9tZXNzYWdlKG1zZ2J1Zi5idWYsIG1zZ2J1Zi5sZW4sCgkJCQkgICAgZ2l0X3BhdGhfbWVyZ2VfbXNnKCksIDApOwoKCQljb21taXRfbGlzdF9pbnNlcnQoYmFzZSwgJmNvbW1vbik7CgkJY29tbWl0X2xpc3RfaW5zZXJ0KG5leHQsICZyZW1vdGVzKTsKCQlyZXMgfD0gdHJ5X21lcmdlX2NvbW1hbmQob3B0cy0+c3RyYXRlZ3ksCgkJCQkJIG9wdHMtPnhvcHRzX25yLCAoY29uc3QgY2hhciAqKilvcHRzLT54b3B0cywKCQkJCQljb21tb24sIHNoYTFfdG9faGV4KGhlYWQpLCByZW1vdGVzKTsKCQlmcmVlX2NvbW1pdF9saXN0KGNvbW1vbik7CgkJZnJlZV9jb21taXRfbGlzdChyZW1vdGVzKTsKCX0KCXN0cmJ1Zl9yZWxlYXNlKCZtc2didWYpOwoKCS8qCgkgKiBJZiB0aGUgbWVyZ2Ugd2FzIGNsZWFuIG9yIGlmIGl0IGZhaWxlZCBkdWUgdG8gY29uZmxpY3QsIHdlIHdyaXRlCgkgKiBDSEVSUllfUElDS19IRUFEIGZvciB0aGUgc3Vic2VxdWVudCBpbnZvY2F0aW9uIG9mIGNvbW1pdCB0byB1c2UuCgkgKiBIb3dldmVyLCBpZiB0aGUgbWVyZ2UgZGlkIG5vdCBldmVuIHN0YXJ0LCB0aGVuIHdlIGRvbid0IHdhbnQgdG8KCSAqIHdyaXRlIGl0IGF0IGFsbC4KCSAqLwoJaWYgKGNvbW1hbmQgPT0gVE9ET19QSUNLICYmICFvcHRzLT5ub19jb21taXQgJiYgKHJlcyA9PSAwIHx8IHJlcyA9PSAxKSAmJgoJICAgIHVwZGF0ZV9yZWYoTlVMTCwgIkNIRVJSWV9QSUNLX0hFQUQiLCBjb21taXQtPm9iamVjdC5vaWQuaGFzaCwgTlVMTCwKCQkgICAgICAgUkVGX05PREVSRUYsIFVQREFURV9SRUZTX01TR19PTl9FUlIpKQoJCXJlcyA9IC0xOwoJaWYgKGNvbW1hbmQgPT0gVE9ET19SRVZFUlQgJiYgKChvcHRzLT5ub19jb21taXQgJiYgcmVzID09IDApIHx8IHJlcyA9PSAxKSAmJgoJICAgIHVwZGF0ZV9yZWYoTlVMTCwgIlJFVkVSVF9IRUFEIiwgY29tbWl0LT5vYmplY3Qub2lkLmhhc2gsIE5VTEwsCgkJICAgICAgIFJFRl9OT0RFUkVGLCBVUERBVEVfUkVGU19NU0dfT05fRVJSKSkKCQlyZXMgPSAtMTsKCglpZiAocmVzKSB7CgkJZXJyb3IoY29tbWFuZCA9PSBUT0RPX1JFVkVSVAoJCSAgICAgID8gXygiY291bGQgbm90IHJldmVydCAlcy4uLiAlcyIpCgkJICAgICAgOiBfKCJjb3VsZCBub3QgYXBwbHkgJXMuLi4gJXMiKSwKCQkgICAgICBzaG9ydF9jb21taXRfbmFtZShjb21taXQpLCBtc2cuc3ViamVjdCk7CgkJcHJpbnRfYWR2aWNlKHJlcyA9PSAxLCBvcHRzKTsKCQlyZXJlcmUob3B0cy0+YWxsb3dfcmVyZXJlX2F1dG8pOwoJCWdvdG8gbGVhdmU7Cgl9CgoJYWxsb3cgPSBhbGxvd19lbXB0eShvcHRzLCBjb21taXQpOwoJaWYgKGFsbG93IDwgMCkgewoJCXJlcyA9IGFsbG93OwoJCWdvdG8gbGVhdmU7Cgl9CglpZiAoIW9wdHMtPm5vX2NvbW1pdCkKCQlyZXMgPSBydW5fZ2l0X2NvbW1pdChvcHRzLT5lZGl0ID8gTlVMTCA6IGdpdF9wYXRoX21lcmdlX21zZygpLAoJCQkJICAgICBvcHRzLCBhbGxvdywgb3B0cy0+ZWRpdCwgMCwgMCk7CgpsZWF2ZToKCWZyZWVfbWVzc2FnZShjb21taXQsICZtc2cpOwoKCXJldHVybiByZXM7Cn0KCnN0YXRpYyBpbnQgcHJlcGFyZV9yZXZzKHN0cnVjdCByZXBsYXlfb3B0cyAqb3B0cykKewoJLyoKCSAqIHBpY2tpbmcgKGJ1dCBub3QgcmV2ZXJ0aW5nKSByYW5nZXMgKGJ1dCBub3QgaW5kaXZpZHVhbCByZXZpc2lvbnMpCgkgKiBzaG91bGQgYmUgZG9uZSBpbiByZXZlcnNlCgkgKi8KCWlmIChvcHRzLT5hY3Rpb24gPT0gUkVQTEFZX1BJQ0sgJiYgIW9wdHMtPnJldnMtPm5vX3dhbGspCgkJb3B0cy0+cmV2cy0+cmV2ZXJzZSBePSAxOwoKCWlmIChwcmVwYXJlX3JldmlzaW9uX3dhbGsob3B0cy0+cmV2cykpCgkJcmV0dXJuIGVycm9yKF8oInJldmlzaW9uIHdhbGsgc2V0dXAgZmFpbGVkIikpOwoKCWlmICghb3B0cy0+cmV2cy0+Y29tbWl0cykKCQlyZXR1cm4gZXJyb3IoXygiZW1wdHkgY29tbWl0IHNldCBwYXNzZWQiKSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCByZWFkX2FuZF9yZWZyZXNoX2NhY2hlKHN0cnVjdCByZXBsYXlfb3B0cyAqb3B0cykKewoJc3RhdGljIHN0cnVjdCBsb2NrX2ZpbGUgaW5kZXhfbG9jazsKCWludCBpbmRleF9mZCA9IGhvbGRfbG9ja2VkX2luZGV4KCZpbmRleF9sb2NrLCAwKTsKCWlmIChyZWFkX2luZGV4X3ByZWxvYWQoJnRoZV9pbmRleCwgTlVMTCkgPCAwKSB7CgkJcm9sbGJhY2tfbG9ja19maWxlKCZpbmRleF9sb2NrKTsKCQlyZXR1cm4gZXJyb3IoXygiZ2l0ICVzOiBmYWlsZWQgdG8gcmVhZCB0aGUgaW5kZXgiKSwKCQkJYWN0aW9uX25hbWUob3B0cykpOwoJfQoJcmVmcmVzaF9pbmRleCgmdGhlX2luZGV4LCBSRUZSRVNIX1FVSUVUfFJFRlJFU0hfVU5NRVJHRUQsIE5VTEwsIE5VTEwsIE5VTEwpOwoJaWYgKHRoZV9pbmRleC5jYWNoZV9jaGFuZ2VkICYmIGluZGV4X2ZkID49IDApIHsKCQlpZiAod3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZpbmRleF9sb2NrLCBDT01NSVRfTE9DSykpIHsKCQkJcm9sbGJhY2tfbG9ja19maWxlKCZpbmRleF9sb2NrKTsKCQkJcmV0dXJuIGVycm9yKF8oImdpdCAlczogZmFpbGVkIHRvIHJlZnJlc2ggdGhlIGluZGV4IiksCgkJCQlhY3Rpb25fbmFtZShvcHRzKSk7CgkJfQoJfQoJcm9sbGJhY2tfbG9ja19maWxlKCZpbmRleF9sb2NrKTsKCXJldHVybiAwOwp9CgpzdHJ1Y3QgdG9kb19pdGVtIHsKCWVudW0gdG9kb19jb21tYW5kIGNvbW1hbmQ7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7Cgljb25zdCBjaGFyICphcmc7CglpbnQgYXJnX2xlbjsKCXNpemVfdCBvZmZzZXRfaW5fYnVmOwp9OwoKc3RydWN0IHRvZG9fbGlzdCB7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZjsKCXN0cnVjdCB0b2RvX2l0ZW0gKml0ZW1zOwoJaW50IG5yLCBhbGxvYywgY3VycmVudDsKfTsKCiNkZWZpbmUgVE9ET19MSVNUX0lOSVQgeyBTVFJCVUZfSU5JVCB9CgpzdGF0aWMgdm9pZCB0b2RvX2xpc3RfcmVsZWFzZShzdHJ1Y3QgdG9kb19saXN0ICp0b2RvX2xpc3QpCnsKCXN0cmJ1Zl9yZWxlYXNlKCZ0b2RvX2xpc3QtPmJ1Zik7CglmcmVlKHRvZG9fbGlzdC0+aXRlbXMpOwoJdG9kb19saXN0LT5pdGVtcyA9IE5VTEw7Cgl0b2RvX2xpc3QtPm5yID0gdG9kb19saXN0LT5hbGxvYyA9IDA7Cn0KCnN0YXRpYyBzdHJ1Y3QgdG9kb19pdGVtICphcHBlbmRfbmV3X3RvZG8oc3RydWN0IHRvZG9fbGlzdCAqdG9kb19saXN0KQp7CglBTExPQ19HUk9XKHRvZG9fbGlzdC0+aXRlbXMsIHRvZG9fbGlzdC0+bnIgKyAxLCB0b2RvX2xpc3QtPmFsbG9jKTsKCXJldHVybiB0b2RvX2xpc3QtPml0ZW1zICsgdG9kb19saXN0LT5ucisrOwp9CgpzdGF0aWMgaW50IHBhcnNlX2luc25fbGluZShzdHJ1Y3QgdG9kb19pdGVtICppdGVtLCBjb25zdCBjaGFyICpib2wsIGNoYXIgKmVvbCkKewoJdW5zaWduZWQgY2hhciBjb21taXRfc2hhMVsyMF07CgljaGFyICplbmRfb2Zfb2JqZWN0X25hbWU7CglpbnQgaSwgc2F2ZWQsIHN0YXR1cywgcGFkZGluZzsKCgkvKiBsZWZ0LXRyaW0gKi8KCWJvbCArPSBzdHJzcG4oYm9sLCAiIFx0Iik7CgoJZm9yIChpID0gMDsgaSA8IEFSUkFZX1NJWkUodG9kb19jb21tYW5kX3N0cmluZ3MpOyBpKyspCgkJaWYgKHNraXBfcHJlZml4KGJvbCwgdG9kb19jb21tYW5kX3N0cmluZ3NbaV0sICZib2wpKSB7CgkJCWl0ZW0tPmNvbW1hbmQgPSBpOwoJCQlicmVhazsKCQl9CglpZiAoaSA+PSBBUlJBWV9TSVpFKHRvZG9fY29tbWFuZF9zdHJpbmdzKSkKCQlyZXR1cm4gLTE7CgoJLyogRWF0IHVwIGV4dHJhIHNwYWNlcy8gdGFicyBiZWZvcmUgb2JqZWN0IG5hbWUgKi8KCXBhZGRpbmcgPSBzdHJzcG4oYm9sLCAiIFx0Iik7CglpZiAoIXBhZGRpbmcpCgkJcmV0dXJuIC0xOwoJYm9sICs9IHBhZGRpbmc7CgoJZW5kX29mX29iamVjdF9uYW1lID0gKGNoYXIgKikgYm9sICsgc3RyY3Nwbihib2wsICIgXHRcbiIpOwoJc2F2ZWQgPSAqZW5kX29mX29iamVjdF9uYW1lOwoJKmVuZF9vZl9vYmplY3RfbmFtZSA9ICdcMCc7CglzdGF0dXMgPSBnZXRfc2hhMShib2wsIGNvbW1pdF9zaGExKTsKCSplbmRfb2Zfb2JqZWN0X25hbWUgPSBzYXZlZDsKCglpdGVtLT5hcmcgPSBlbmRfb2Zfb2JqZWN0X25hbWUgKyBzdHJzcG4oZW5kX29mX29iamVjdF9uYW1lLCAiIFx0Iik7CglpdGVtLT5hcmdfbGVuID0gKGludCkoZW9sIC0gaXRlbS0+YXJnKTsKCglpZiAoc3RhdHVzIDwgMCkKCQlyZXR1cm4gLTE7CgoJaXRlbS0+Y29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2UoY29tbWl0X3NoYTEpOwoJcmV0dXJuICFpdGVtLT5jb21taXQ7Cn0KCnN0YXRpYyBpbnQgcGFyc2VfaW5zbl9idWZmZXIoY2hhciAqYnVmLCBzdHJ1Y3QgdG9kb19saXN0ICp0b2RvX2xpc3QpCnsKCXN0cnVjdCB0b2RvX2l0ZW0gKml0ZW07CgljaGFyICpwID0gYnVmLCAqbmV4dF9wOwoJaW50IGksIHJlcyA9IDA7CgoJZm9yIChpID0gMTsgKnA7IGkrKywgcCA9IG5leHRfcCkgewoJCWNoYXIgKmVvbCA9IHN0cmNocm51bChwLCAnXG4nKTsKCgkJbmV4dF9wID0gKmVvbCA/IGVvbCArIDEgLyogc2tpcCBMRiAqLyA6IGVvbDsKCgkJaWYgKHAgIT0gZW9sICYmIGVvbFstMV0gPT0gJ1xyJykKCQkJZW9sLS07IC8qIHN0cmlwIENhcnJpYWdlIFJldHVybiAqLwoKCQlpdGVtID0gYXBwZW5kX25ld190b2RvKHRvZG9fbGlzdCk7CgkJaXRlbS0+b2Zmc2V0X2luX2J1ZiA9IHAgLSB0b2RvX2xpc3QtPmJ1Zi5idWY7CgkJaWYgKHBhcnNlX2luc25fbGluZShpdGVtLCBwLCBlb2wpKSB7CgkJCXJlcyA9IGVycm9yKF8oIkludmFsaWQgbGluZSAlZDogJS4qcyIpLAoJCQkJaSwgKGludCkoZW9sIC0gcCksIHApOwoJCQlpdGVtLT5jb21tYW5kID0gLTE7CgkJfQoJfQoJaWYgKCF0b2RvX2xpc3QtPm5yKQoJCXJldHVybiBlcnJvcihfKCJObyBjb21taXRzIHBhcnNlZC4iKSk7CglyZXR1cm4gcmVzOwp9CgpzdGF0aWMgaW50IHJlYWRfcG9wdWxhdGVfdG9kbyhzdHJ1Y3QgdG9kb19saXN0ICp0b2RvX2xpc3QsCgkJCXN0cnVjdCByZXBsYXlfb3B0cyAqb3B0cykKewoJY29uc3QgY2hhciAqdG9kb19maWxlID0gZ2V0X3RvZG9fcGF0aChvcHRzKTsKCWludCBmZCwgcmVzOwoKCXN0cmJ1Zl9yZXNldCgmdG9kb19saXN0LT5idWYpOwoJZmQgPSBvcGVuKHRvZG9fZmlsZSwgT19SRE9OTFkpOwoJaWYgKGZkIDwgMCkKCQlyZXR1cm4gZXJyb3JfZXJybm8oXygiQ291bGQgbm90IG9wZW4gJXMiKSwgdG9kb19maWxlKTsKCWlmIChzdHJidWZfcmVhZCgmdG9kb19saXN0LT5idWYsIGZkLCAwKSA8IDApIHsKCQljbG9zZShmZCk7CgkJcmV0dXJuIGVycm9yKF8oIkNvdWxkIG5vdCByZWFkICVzLiIpLCB0b2RvX2ZpbGUpOwoJfQoJY2xvc2UoZmQpOwoKCXJlcyA9IHBhcnNlX2luc25fYnVmZmVyKHRvZG9fbGlzdC0+YnVmLmJ1ZiwgdG9kb19saXN0KTsKCWlmICghcmVzKSB7CgkJZW51bSB0b2RvX2NvbW1hbmQgdmFsaWQgPQoJCQlvcHRzLT5hY3Rpb24gPT0gUkVQTEFZX1BJQ0sgPyBUT0RPX1BJQ0sgOiBUT0RPX1JFVkVSVDsKCQlpbnQgaTsKCgkJZm9yIChpID0gMDsgaSA8IHRvZG9fbGlzdC0+bnI7IGkrKykKCQkJaWYgKHZhbGlkID09IHRvZG9fbGlzdC0+aXRlbXNbaV0uY29tbWFuZCkKCQkJCWNvbnRpbnVlOwoJCQllbHNlIGlmICh2YWxpZCA9PSBUT0RPX1BJQ0spCgkJCQlyZXR1cm4gZXJyb3IoXygiQ2Fubm90IGNoZXJyeS1waWNrIGR1cmluZyBhIHJldmVydC4iKSk7CgkJCWVsc2UKCQkJCXJldHVybiBlcnJvcihfKCJDYW5ub3QgcmV2ZXJ0IGR1cmluZyBhIGNoZXJyeS1waWNrLiIpKTsKCX0KCglpZiAocmVzKQoJCXJldHVybiBlcnJvcihfKCJVbnVzYWJsZSBpbnN0cnVjdGlvbiBzaGVldDogJXMiKSwgdG9kb19maWxlKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdpdF9jb25maWdfc3RyaW5nX2R1cChjaGFyICoqZGVzdCwKCQkJCSBjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlKQp7CglpZiAoIXZhbHVlKQoJCXJldHVybiBjb25maWdfZXJyb3Jfbm9uYm9vbCh2YXIpOwoJZnJlZSgqZGVzdCk7CgkqZGVzdCA9IHhzdHJkdXAodmFsdWUpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgcG9wdWxhdGVfb3B0c19jYihjb25zdCBjaGFyICprZXksIGNvbnN0IGNoYXIgKnZhbHVlLCB2b2lkICpkYXRhKQp7CglzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMgPSBkYXRhOwoJaW50IGVycm9yX2ZsYWcgPSAxOwoKCWlmICghdmFsdWUpCgkJZXJyb3JfZmxhZyA9IDA7CgllbHNlIGlmICghc3RyY21wKGtleSwgIm9wdGlvbnMubm8tY29tbWl0IikpCgkJb3B0cy0+bm9fY29tbWl0ID0gZ2l0X2NvbmZpZ19ib29sX29yX2ludChrZXksIHZhbHVlLCAmZXJyb3JfZmxhZyk7CgllbHNlIGlmICghc3RyY21wKGtleSwgIm9wdGlvbnMuZWRpdCIpKQoJCW9wdHMtPmVkaXQgPSBnaXRfY29uZmlnX2Jvb2xfb3JfaW50KGtleSwgdmFsdWUsICZlcnJvcl9mbGFnKTsKCWVsc2UgaWYgKCFzdHJjbXAoa2V5LCAib3B0aW9ucy5zaWdub2ZmIikpCgkJb3B0cy0+c2lnbm9mZiA9IGdpdF9jb25maWdfYm9vbF9vcl9pbnQoa2V5LCB2YWx1ZSwgJmVycm9yX2ZsYWcpOwoJZWxzZSBpZiAoIXN0cmNtcChrZXksICJvcHRpb25zLnJlY29yZC1vcmlnaW4iKSkKCQlvcHRzLT5yZWNvcmRfb3JpZ2luID0gZ2l0X2NvbmZpZ19ib29sX29yX2ludChrZXksIHZhbHVlLCAmZXJyb3JfZmxhZyk7CgllbHNlIGlmICghc3RyY21wKGtleSwgIm9wdGlvbnMuYWxsb3ctZmYiKSkKCQlvcHRzLT5hbGxvd19mZiA9IGdpdF9jb25maWdfYm9vbF9vcl9pbnQoa2V5LCB2YWx1ZSwgJmVycm9yX2ZsYWcpOwoJZWxzZSBpZiAoIXN0cmNtcChrZXksICJvcHRpb25zLm1haW5saW5lIikpCgkJb3B0cy0+bWFpbmxpbmUgPSBnaXRfY29uZmlnX2ludChrZXksIHZhbHVlKTsKCWVsc2UgaWYgKCFzdHJjbXAoa2V5LCAib3B0aW9ucy5zdHJhdGVneSIpKQoJCWdpdF9jb25maWdfc3RyaW5nX2R1cCgmb3B0cy0+c3RyYXRlZ3ksIGtleSwgdmFsdWUpOwoJZWxzZSBpZiAoIXN0cmNtcChrZXksICJvcHRpb25zLmdwZy1zaWduIikpCgkJZ2l0X2NvbmZpZ19zdHJpbmdfZHVwKCZvcHRzLT5ncGdfc2lnbiwga2V5LCB2YWx1ZSk7CgllbHNlIGlmICghc3RyY21wKGtleSwgIm9wdGlvbnMuc3RyYXRlZ3ktb3B0aW9uIikpIHsKCQlBTExPQ19HUk9XKG9wdHMtPnhvcHRzLCBvcHRzLT54b3B0c19uciArIDEsIG9wdHMtPnhvcHRzX2FsbG9jKTsKCQlvcHRzLT54b3B0c1tvcHRzLT54b3B0c19ucisrXSA9IHhzdHJkdXAodmFsdWUpOwoJfSBlbHNlCgkJcmV0dXJuIGVycm9yKF8oIkludmFsaWQga2V5OiAlcyIpLCBrZXkpOwoKCWlmICghZXJyb3JfZmxhZykKCQlyZXR1cm4gZXJyb3IoXygiSW52YWxpZCB2YWx1ZSBmb3IgJXM6ICVzIiksIGtleSwgdmFsdWUpOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHJlYWRfcG9wdWxhdGVfb3B0cyhzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMpCnsKCWlmIChpc19yZWJhc2VfaShvcHRzKSkgewoJCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJCWlmIChyZWFkX29uZWxpbmVyKCZidWYsIHJlYmFzZV9wYXRoX2dwZ19zaWduX29wdCgpLCAxKSkgewoJCQlpZiAoIXN0YXJ0c193aXRoKGJ1Zi5idWYsICItUyIpKQoJCQkJc3RyYnVmX3Jlc2V0KCZidWYpOwoJCQllbHNlIHsKCQkJCWZyZWUob3B0cy0+Z3BnX3NpZ24pOwoJCQkJb3B0cy0+Z3BnX3NpZ24gPSB4c3RyZHVwKGJ1Zi5idWYgKyAyKTsKCQkJfQoJCX0KCQlzdHJidWZfcmVsZWFzZSgmYnVmKTsKCgkJcmV0dXJuIDA7Cgl9CgoJaWYgKCFmaWxlX2V4aXN0cyhnaXRfcGF0aF9vcHRzX2ZpbGUoKSkpCgkJcmV0dXJuIDA7CgkvKgoJICogVGhlIGZ1bmN0aW9uIGdpdF9wYXJzZV9zb3VyY2UoKSwgY2FsbGVkIGZyb20gZ2l0X2NvbmZpZ19mcm9tX2ZpbGUoKSwKCSAqIG1heSBkaWUoKSBpbiBjYXNlIG9mIGEgc3ludGFjdGljYWxseSBpbmNvcnJlY3QgZmlsZS4gV2UgZG8gbm90IGNhcmUKCSAqIGFib3V0IHRoaXMgY2FzZSwgdGhvdWdoLCBiZWNhdXNlIHdlIHdyb3RlIHRoYXQgZmlsZSBvdXJzZWx2ZXMsIHNvIHdlCgkgKiBhcmUgcHJldHR5IGNlcnRhaW4gdGhhdCBpdCBpcyBzeW50YWN0aWNhbGx5IGNvcnJlY3QuCgkgKi8KCWlmIChnaXRfY29uZmlnX2Zyb21fZmlsZShwb3B1bGF0ZV9vcHRzX2NiLCBnaXRfcGF0aF9vcHRzX2ZpbGUoKSwgb3B0cykgPCAwKQoJCXJldHVybiBlcnJvcihfKCJNYWxmb3JtZWQgb3B0aW9ucyBzaGVldDogJXMiKSwKCQkJZ2l0X3BhdGhfb3B0c19maWxlKCkpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgd2Fsa19yZXZzX3BvcHVsYXRlX3RvZG8oc3RydWN0IHRvZG9fbGlzdCAqdG9kb19saXN0LAoJCQkJc3RydWN0IHJlcGxheV9vcHRzICpvcHRzKQp7CgllbnVtIHRvZG9fY29tbWFuZCBjb21tYW5kID0gb3B0cy0+YWN0aW9uID09IFJFUExBWV9QSUNLID8KCQlUT0RPX1BJQ0sgOiBUT0RPX1JFVkVSVDsKCWNvbnN0IGNoYXIgKmNvbW1hbmRfc3RyaW5nID0gdG9kb19jb21tYW5kX3N0cmluZ3NbY29tbWFuZF07CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgoJaWYgKHByZXBhcmVfcmV2cyhvcHRzKSkKCQlyZXR1cm4gLTE7CgoJd2hpbGUgKChjb21taXQgPSBnZXRfcmV2aXNpb24ob3B0cy0+cmV2cykpKSB7CgkJc3RydWN0IHRvZG9faXRlbSAqaXRlbSA9IGFwcGVuZF9uZXdfdG9kbyh0b2RvX2xpc3QpOwoJCWNvbnN0IGNoYXIgKmNvbW1pdF9idWZmZXIgPSBnZXRfY29tbWl0X2J1ZmZlcihjb21taXQsIE5VTEwpOwoJCWNvbnN0IGNoYXIgKnN1YmplY3Q7CgkJaW50IHN1YmplY3RfbGVuOwoKCQlpdGVtLT5jb21tYW5kID0gY29tbWFuZDsKCQlpdGVtLT5jb21taXQgPSBjb21taXQ7CgkJaXRlbS0+YXJnID0gTlVMTDsKCQlpdGVtLT5hcmdfbGVuID0gMDsKCQlpdGVtLT5vZmZzZXRfaW5fYnVmID0gdG9kb19saXN0LT5idWYubGVuOwoJCXN1YmplY3RfbGVuID0gZmluZF9jb21taXRfc3ViamVjdChjb21taXRfYnVmZmVyLCAmc3ViamVjdCk7CgkJc3RyYnVmX2FkZGYoJnRvZG9fbGlzdC0+YnVmLCAiJXMgJXMgJS4qc1xuIiwgY29tbWFuZF9zdHJpbmcsCgkJCXNob3J0X2NvbW1pdF9uYW1lKGNvbW1pdCksIHN1YmplY3RfbGVuLCBzdWJqZWN0KTsKCQl1bnVzZV9jb21taXRfYnVmZmVyKGNvbW1pdCwgY29tbWl0X2J1ZmZlcik7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBjcmVhdGVfc2VxX2Rpcih2b2lkKQp7CglpZiAoZmlsZV9leGlzdHMoZ2l0X3BhdGhfc2VxX2RpcigpKSkgewoJCWVycm9yKF8oImEgY2hlcnJ5LXBpY2sgb3IgcmV2ZXJ0IGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MiKSk7CgkJYWR2aXNlKF8oInRyeSBcImdpdCBjaGVycnktcGljayAoLS1jb250aW51ZSB8IC0tcXVpdCB8IC0tYWJvcnQpXCIiKSk7CgkJcmV0dXJuIC0xOwoJfQoJZWxzZSBpZiAobWtkaXIoZ2l0X3BhdGhfc2VxX2RpcigpLCAwNzc3KSA8IDApCgkJcmV0dXJuIGVycm9yX2Vycm5vKF8oIkNvdWxkIG5vdCBjcmVhdGUgc2VxdWVuY2VyIGRpcmVjdG9yeSAlcyIpLAoJCQkJICAgZ2l0X3BhdGhfc2VxX2RpcigpKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHNhdmVfaGVhZChjb25zdCBjaGFyICpoZWFkKQp7CglzdGF0aWMgc3RydWN0IGxvY2tfZmlsZSBoZWFkX2xvY2s7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaW50IGZkOwoKCWZkID0gaG9sZF9sb2NrX2ZpbGVfZm9yX3VwZGF0ZSgmaGVhZF9sb2NrLCBnaXRfcGF0aF9oZWFkX2ZpbGUoKSwgMCk7CglpZiAoZmQgPCAwKSB7CgkJcm9sbGJhY2tfbG9ja19maWxlKCZoZWFkX2xvY2spOwoJCXJldHVybiBlcnJvcl9lcnJubyhfKCJDb3VsZCBub3QgbG9jayBIRUFEIikpOwoJfQoJc3RyYnVmX2FkZGYoJmJ1ZiwgIiVzXG4iLCBoZWFkKTsKCWlmICh3cml0ZV9pbl9mdWxsKGZkLCBidWYuYnVmLCBidWYubGVuKSA8IDApIHsKCQlyb2xsYmFja19sb2NrX2ZpbGUoJmhlYWRfbG9jayk7CgkJcmV0dXJuIGVycm9yX2Vycm5vKF8oIkNvdWxkIG5vdCB3cml0ZSB0byAlcyIpLAoJCQkJICAgZ2l0X3BhdGhfaGVhZF9maWxlKCkpOwoJfQoJaWYgKGNvbW1pdF9sb2NrX2ZpbGUoJmhlYWRfbG9jaykgPCAwKSB7CgkJcm9sbGJhY2tfbG9ja19maWxlKCZoZWFkX2xvY2spOwoJCXJldHVybiBlcnJvcihfKCJFcnJvciB3cmFwcGluZyB1cCAlcy4iKSwgZ2l0X3BhdGhfaGVhZF9maWxlKCkpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgcmVzZXRfZm9yX3JvbGxiYWNrKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCWNvbnN0IGNoYXIgKmFyZ3ZbNF07CS8qIHJlc2V0IC0tbWVyZ2UgPGFyZz4gKyBOVUxMICovCglhcmd2WzBdID0gInJlc2V0IjsKCWFyZ3ZbMV0gPSAiLS1tZXJnZSI7Cglhcmd2WzJdID0gc2hhMV90b19oZXgoc2hhMSk7Cglhcmd2WzNdID0gTlVMTDsKCXJldHVybiBydW5fY29tbWFuZF92X29wdChhcmd2LCBSVU5fR0lUX0NNRCk7Cn0KCnN0YXRpYyBpbnQgcm9sbGJhY2tfc2luZ2xlX3BpY2sodm9pZCkKewoJdW5zaWduZWQgY2hhciBoZWFkX3NoYTFbMjBdOwoKCWlmICghZmlsZV9leGlzdHMoZ2l0X3BhdGhfY2hlcnJ5X3BpY2tfaGVhZCgpKSAmJgoJICAgICFmaWxlX2V4aXN0cyhnaXRfcGF0aF9yZXZlcnRfaGVhZCgpKSkKCQlyZXR1cm4gZXJyb3IoXygibm8gY2hlcnJ5LXBpY2sgb3IgcmV2ZXJ0IGluIHByb2dyZXNzIikpOwoJaWYgKHJlYWRfcmVmX2Z1bGwoIkhFQUQiLCAwLCBoZWFkX3NoYTEsIE5VTEwpKQoJCXJldHVybiBlcnJvcihfKCJjYW5ub3QgcmVzb2x2ZSBIRUFEIikpOwoJaWYgKGlzX251bGxfc2hhMShoZWFkX3NoYTEpKQoJCXJldHVybiBlcnJvcihfKCJjYW5ub3QgYWJvcnQgZnJvbSBhIGJyYW5jaCB5ZXQgdG8gYmUgYm9ybiIpKTsKCXJldHVybiByZXNldF9mb3Jfcm9sbGJhY2soaGVhZF9zaGExKTsKfQoKaW50IHNlcXVlbmNlcl9yb2xsYmFjayhzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMpCnsKCUZJTEUgKmY7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCglmID0gZm9wZW4oZ2l0X3BhdGhfaGVhZF9maWxlKCksICJyIik7CglpZiAoIWYgJiYgZXJybm8gPT0gRU5PRU5UKSB7CgkJLyoKCQkgKiBUaGVyZSBpcyBubyBtdWx0aXBsZS1jaGVycnktcGljayBpbiBwcm9ncmVzcy4KCQkgKiBJZiBDSEVSUllfUElDS19IRUFEIG9yIFJFVkVSVF9IRUFEIGluZGljYXRlcwoJCSAqIGEgc2luZ2xlLWNoZXJyeS1waWNrIGluIHByb2dyZXNzLCBhYm9ydCB0aGF0LgoJCSAqLwoJCXJldHVybiByb2xsYmFja19zaW5nbGVfcGljaygpOwoJfQoJaWYgKCFmKQoJCXJldHVybiBlcnJvcl9lcnJubyhfKCJjYW5ub3Qgb3BlbiAlcyIpLCBnaXRfcGF0aF9oZWFkX2ZpbGUoKSk7CglpZiAoc3RyYnVmX2dldGxpbmVfbGYoJmJ1ZiwgZikpIHsKCQllcnJvcihfKCJjYW5ub3QgcmVhZCAlczogJXMiKSwgZ2l0X3BhdGhfaGVhZF9maWxlKCksCgkJICAgICAgZmVycm9yKGYpID8gIHN0cmVycm9yKGVycm5vKSA6IF8oInVuZXhwZWN0ZWQgZW5kIG9mIGZpbGUiKSk7CgkJZmNsb3NlKGYpOwoJCWdvdG8gZmFpbDsKCX0KCWZjbG9zZShmKTsKCWlmIChnZXRfc2hhMV9oZXgoYnVmLmJ1Ziwgc2hhMSkgfHwgYnVmLmJ1Zls0MF0gIT0gJ1wwJykgewoJCWVycm9yKF8oInN0b3JlZCBwcmUtY2hlcnJ5LXBpY2sgSEVBRCBmaWxlICclcycgaXMgY29ycnVwdCIpLAoJCQlnaXRfcGF0aF9oZWFkX2ZpbGUoKSk7CgkJZ290byBmYWlsOwoJfQoJaWYgKGlzX251bGxfc2hhMShzaGExKSkgewoJCWVycm9yKF8oImNhbm5vdCBhYm9ydCBmcm9tIGEgYnJhbmNoIHlldCB0byBiZSBib3JuIikpOwoJCWdvdG8gZmFpbDsKCX0KCWlmIChyZXNldF9mb3Jfcm9sbGJhY2soc2hhMSkpCgkJZ290byBmYWlsOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CglyZXR1cm4gc2VxdWVuY2VyX3JlbW92ZV9zdGF0ZShvcHRzKTsKZmFpbDoKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJcmV0dXJuIC0xOwp9CgpzdGF0aWMgaW50IHNhdmVfdG9kbyhzdHJ1Y3QgdG9kb19saXN0ICp0b2RvX2xpc3QsIHN0cnVjdCByZXBsYXlfb3B0cyAqb3B0cykKewoJc3RhdGljIHN0cnVjdCBsb2NrX2ZpbGUgdG9kb19sb2NrOwoJY29uc3QgY2hhciAqdG9kb19wYXRoID0gZ2V0X3RvZG9fcGF0aChvcHRzKTsKCWludCBuZXh0ID0gdG9kb19saXN0LT5jdXJyZW50LCBvZmZzZXQsIGZkOwoKCWZkID0gaG9sZF9sb2NrX2ZpbGVfZm9yX3VwZGF0ZSgmdG9kb19sb2NrLCB0b2RvX3BhdGgsIDApOwoJaWYgKGZkIDwgMCkKCQlyZXR1cm4gZXJyb3JfZXJybm8oXygiQ291bGQgbm90IGxvY2sgJyVzJyIpLCB0b2RvX3BhdGgpOwoJb2Zmc2V0ID0gbmV4dCA8IHRvZG9fbGlzdC0+bnIgPwoJCXRvZG9fbGlzdC0+aXRlbXNbbmV4dF0ub2Zmc2V0X2luX2J1ZiA6IHRvZG9fbGlzdC0+YnVmLmxlbjsKCWlmICh3cml0ZV9pbl9mdWxsKGZkLCB0b2RvX2xpc3QtPmJ1Zi5idWYgKyBvZmZzZXQsCgkJCXRvZG9fbGlzdC0+YnVmLmxlbiAtIG9mZnNldCkgPCAwKQoJCXJldHVybiBlcnJvcl9lcnJubyhfKCJDb3VsZCBub3Qgd3JpdGUgdG8gJyVzJyIpLCB0b2RvX3BhdGgpOwoJaWYgKGNvbW1pdF9sb2NrX2ZpbGUoJnRvZG9fbG9jaykgPCAwKQoJCXJldHVybiBlcnJvcihfKCJFcnJvciB3cmFwcGluZyB1cCAlcy4iKSwgdG9kb19wYXRoKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHNhdmVfb3B0cyhzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMpCnsKCWNvbnN0IGNoYXIgKm9wdHNfZmlsZSA9IGdpdF9wYXRoX29wdHNfZmlsZSgpOwoJaW50IHJlcyA9IDA7CgoJaWYgKG9wdHMtPm5vX2NvbW1pdCkKCQlyZXMgfD0gZ2l0X2NvbmZpZ19zZXRfaW5fZmlsZV9nZW50bHkob3B0c19maWxlLCAib3B0aW9ucy5uby1jb21taXQiLCAidHJ1ZSIpOwoJaWYgKG9wdHMtPmVkaXQpCgkJcmVzIHw9IGdpdF9jb25maWdfc2V0X2luX2ZpbGVfZ2VudGx5KG9wdHNfZmlsZSwgIm9wdGlvbnMuZWRpdCIsICJ0cnVlIik7CglpZiAob3B0cy0+c2lnbm9mZikKCQlyZXMgfD0gZ2l0X2NvbmZpZ19zZXRfaW5fZmlsZV9nZW50bHkob3B0c19maWxlLCAib3B0aW9ucy5zaWdub2ZmIiwgInRydWUiKTsKCWlmIChvcHRzLT5yZWNvcmRfb3JpZ2luKQoJCXJlcyB8PSBnaXRfY29uZmlnX3NldF9pbl9maWxlX2dlbnRseShvcHRzX2ZpbGUsICJvcHRpb25zLnJlY29yZC1vcmlnaW4iLCAidHJ1ZSIpOwoJaWYgKG9wdHMtPmFsbG93X2ZmKQoJCXJlcyB8PSBnaXRfY29uZmlnX3NldF9pbl9maWxlX2dlbnRseShvcHRzX2ZpbGUsICJvcHRpb25zLmFsbG93LWZmIiwgInRydWUiKTsKCWlmIChvcHRzLT5tYWlubGluZSkgewoJCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgkJc3RyYnVmX2FkZGYoJmJ1ZiwgIiVkIiwgb3B0cy0+bWFpbmxpbmUpOwoJCXJlcyB8PSBnaXRfY29uZmlnX3NldF9pbl9maWxlX2dlbnRseShvcHRzX2ZpbGUsICJvcHRpb25zLm1haW5saW5lIiwgYnVmLmJ1Zik7CgkJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7Cgl9CglpZiAob3B0cy0+c3RyYXRlZ3kpCgkJcmVzIHw9IGdpdF9jb25maWdfc2V0X2luX2ZpbGVfZ2VudGx5KG9wdHNfZmlsZSwgIm9wdGlvbnMuc3RyYXRlZ3kiLCBvcHRzLT5zdHJhdGVneSk7CglpZiAob3B0cy0+Z3BnX3NpZ24pCgkJcmVzIHw9IGdpdF9jb25maWdfc2V0X2luX2ZpbGVfZ2VudGx5KG9wdHNfZmlsZSwgIm9wdGlvbnMuZ3BnLXNpZ24iLCBvcHRzLT5ncGdfc2lnbik7CglpZiAob3B0cy0+eG9wdHMpIHsKCQlpbnQgaTsKCQlmb3IgKGkgPSAwOyBpIDwgb3B0cy0+eG9wdHNfbnI7IGkrKykKCQkJcmVzIHw9IGdpdF9jb25maWdfc2V0X211bHRpdmFyX2luX2ZpbGVfZ2VudGx5KG9wdHNfZmlsZSwKCQkJCQkJCSJvcHRpb25zLnN0cmF0ZWd5LW9wdGlvbiIsCgkJCQkJCQlvcHRzLT54b3B0c1tpXSwgIl4kIiwgMCk7Cgl9CglyZXR1cm4gcmVzOwp9CgpzdGF0aWMgaW50IHBpY2tfY29tbWl0cyhzdHJ1Y3QgdG9kb19saXN0ICp0b2RvX2xpc3QsIHN0cnVjdCByZXBsYXlfb3B0cyAqb3B0cykKewoJaW50IHJlczsKCglzZXRlbnYoR0lUX1JFRkxPR19BQ1RJT04sIGFjdGlvbl9uYW1lKG9wdHMpLCAwKTsKCWlmIChvcHRzLT5hbGxvd19mZikKCQlhc3NlcnQoIShvcHRzLT5zaWdub2ZmIHx8IG9wdHMtPm5vX2NvbW1pdCB8fAoJCQkJb3B0cy0+cmVjb3JkX29yaWdpbiB8fCBvcHRzLT5lZGl0KSk7CglpZiAocmVhZF9hbmRfcmVmcmVzaF9jYWNoZShvcHRzKSkKCQlyZXR1cm4gLTE7CgoJd2hpbGUgKHRvZG9fbGlzdC0+Y3VycmVudCA8IHRvZG9fbGlzdC0+bnIpIHsKCQlzdHJ1Y3QgdG9kb19pdGVtICppdGVtID0gdG9kb19saXN0LT5pdGVtcyArIHRvZG9fbGlzdC0+Y3VycmVudDsKCQlpZiAoc2F2ZV90b2RvKHRvZG9fbGlzdCwgb3B0cykpCgkJCXJldHVybiAtMTsKCQlyZXMgPSBkb19waWNrX2NvbW1pdChpdGVtLT5jb21tYW5kLCBpdGVtLT5jb21taXQsIG9wdHMpOwoJCXRvZG9fbGlzdC0+Y3VycmVudCsrOwoJCWlmIChyZXMpCgkJCXJldHVybiByZXM7Cgl9CgoJLyoKCSAqIFNlcXVlbmNlIG9mIHBpY2tzIGZpbmlzaGVkIHN1Y2Nlc3NmdWxseTsgY2xlYW51cCBieQoJICogcmVtb3ZpbmcgdGhlIC5naXQvc2VxdWVuY2VyIGRpcmVjdG9yeQoJICovCglyZXR1cm4gc2VxdWVuY2VyX3JlbW92ZV9zdGF0ZShvcHRzKTsKfQoKc3RhdGljIGludCBjb250aW51ZV9zaW5nbGVfcGljayh2b2lkKQp7Cgljb25zdCBjaGFyICphcmd2W10gPSB7ICJjb21taXQiLCBOVUxMIH07CgoJaWYgKCFmaWxlX2V4aXN0cyhnaXRfcGF0aF9jaGVycnlfcGlja19oZWFkKCkpICYmCgkgICAgIWZpbGVfZXhpc3RzKGdpdF9wYXRoX3JldmVydF9oZWFkKCkpKQoJCXJldHVybiBlcnJvcihfKCJubyBjaGVycnktcGljayBvciByZXZlcnQgaW4gcHJvZ3Jlc3MiKSk7CglyZXR1cm4gcnVuX2NvbW1hbmRfdl9vcHQoYXJndiwgUlVOX0dJVF9DTUQpOwp9CgppbnQgc2VxdWVuY2VyX2NvbnRpbnVlKHN0cnVjdCByZXBsYXlfb3B0cyAqb3B0cykKewoJc3RydWN0IHRvZG9fbGlzdCB0b2RvX2xpc3QgPSBUT0RPX0xJU1RfSU5JVDsKCWludCByZXM7CgoJaWYgKHJlYWRfYW5kX3JlZnJlc2hfY2FjaGUob3B0cykpCgkJcmV0dXJuIC0xOwoKCWlmICghZmlsZV9leGlzdHMoZ2V0X3RvZG9fcGF0aChvcHRzKSkpCgkJcmV0dXJuIGNvbnRpbnVlX3NpbmdsZV9waWNrKCk7CglpZiAocmVhZF9wb3B1bGF0ZV9vcHRzKG9wdHMpKQoJCXJldHVybiAtMTsKCWlmICgocmVzID0gcmVhZF9wb3B1bGF0ZV90b2RvKCZ0b2RvX2xpc3QsIG9wdHMpKSkKCQlnb3RvIHJlbGVhc2VfdG9kb19saXN0OwoKCS8qIFZlcmlmeSB0aGF0IHRoZSBjb25mbGljdCBoYXMgYmVlbiByZXNvbHZlZCAqLwoJaWYgKGZpbGVfZXhpc3RzKGdpdF9wYXRoX2NoZXJyeV9waWNrX2hlYWQoKSkgfHwKCSAgICBmaWxlX2V4aXN0cyhnaXRfcGF0aF9yZXZlcnRfaGVhZCgpKSkgewoJCXJlcyA9IGNvbnRpbnVlX3NpbmdsZV9waWNrKCk7CgkJaWYgKHJlcykKCQkJZ290byByZWxlYXNlX3RvZG9fbGlzdDsKCX0KCWlmIChpbmRleF9kaWZmZXJzX2Zyb20oIkhFQUQiLCAwKSkgewoJCXJlcyA9IGVycm9yX2RpcnR5X2luZGV4KG9wdHMpOwoJCWdvdG8gcmVsZWFzZV90b2RvX2xpc3Q7Cgl9Cgl0b2RvX2xpc3QuY3VycmVudCsrOwoJcmVzID0gcGlja19jb21taXRzKCZ0b2RvX2xpc3QsIG9wdHMpOwpyZWxlYXNlX3RvZG9fbGlzdDoKCXRvZG9fbGlzdF9yZWxlYXNlKCZ0b2RvX2xpc3QpOwoJcmV0dXJuIHJlczsKfQoKc3RhdGljIGludCBzaW5nbGVfcGljayhzdHJ1Y3QgY29tbWl0ICpjbWl0LCBzdHJ1Y3QgcmVwbGF5X29wdHMgKm9wdHMpCnsKCXNldGVudihHSVRfUkVGTE9HX0FDVElPTiwgYWN0aW9uX25hbWUob3B0cyksIDApOwoJcmV0dXJuIGRvX3BpY2tfY29tbWl0KG9wdHMtPmFjdGlvbiA9PSBSRVBMQVlfUElDSyA/CgkJVE9ET19QSUNLIDogVE9ET19SRVZFUlQsIGNtaXQsIG9wdHMpOwp9CgppbnQgc2VxdWVuY2VyX3BpY2tfcmV2aXNpb25zKHN0cnVjdCByZXBsYXlfb3B0cyAqb3B0cykKewoJc3RydWN0IHRvZG9fbGlzdCB0b2RvX2xpc3QgPSBUT0RPX0xJU1RfSU5JVDsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CglpbnQgaSwgcmVzOwoKCWFzc2VydChvcHRzLT5yZXZzKTsKCWlmIChyZWFkX2FuZF9yZWZyZXNoX2NhY2hlKG9wdHMpKQoJCXJldHVybiAtMTsKCglmb3IgKGkgPSAwOyBpIDwgb3B0cy0+cmV2cy0+cGVuZGluZy5ucjsgaSsrKSB7CgkJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCQljb25zdCBjaGFyICpuYW1lID0gb3B0cy0+cmV2cy0+cGVuZGluZy5vYmplY3RzW2ldLm5hbWU7CgoJCS8qIFRoaXMgaGFwcGVucyB3aGVuIHVzaW5nIC0tc3RkaW4uICovCgkJaWYgKCFzdHJsZW4obmFtZSkpCgkJCWNvbnRpbnVlOwoKCQlpZiAoIWdldF9zaGExKG5hbWUsIHNoYTEpKSB7CgkJCWlmICghbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfZ2VudGx5KHNoYTEsIDEpKSB7CgkJCQllbnVtIG9iamVjdF90eXBlIHR5cGUgPSBzaGExX29iamVjdF9pbmZvKHNoYTEsIE5VTEwpOwoJCQkJcmV0dXJuIGVycm9yKF8oIiVzOiBjYW4ndCBjaGVycnktcGljayBhICVzIiksCgkJCQkJbmFtZSwgdHlwZW5hbWUodHlwZSkpOwoJCQl9CgkJfSBlbHNlCgkJCXJldHVybiBlcnJvcihfKCIlczogYmFkIHJldmlzaW9uIiksIG5hbWUpOwoJfQoKCS8qCgkgKiBJZiB3ZSB3ZXJlIGNhbGxlZCBhcyAiZ2l0IGNoZXJyeS1waWNrIDxjb21taXQ+IiwganVzdAoJICogY2hlcnJ5LXBpY2svcmV2ZXJ0IGl0LCBzZXQgQ0hFUlJZX1BJQ0tfSEVBRCAvCgkgKiBSRVZFUlRfSEVBRCwgYW5kIGRvbid0IHRvdWNoIHRoZSBzZXF1ZW5jZXIgc3RhdGUuCgkgKiBUaGlzIG1lYW5zIGl0IGlzIHBvc3NpYmxlIHRvIGNoZXJyeS1waWNrIGluIHRoZSBtaWRkbGUKCSAqIG9mIGEgY2hlcnJ5LXBpY2sgc2VxdWVuY2UuCgkgKi8KCWlmIChvcHRzLT5yZXZzLT5jbWRsaW5lLm5yID09IDEgJiYKCSAgICBvcHRzLT5yZXZzLT5jbWRsaW5lLnJldi0+d2hlbmNlID09IFJFVl9DTURfUkVWICYmCgkgICAgb3B0cy0+cmV2cy0+bm9fd2FsayAmJgoJICAgICFvcHRzLT5yZXZzLT5jbWRsaW5lLnJldi0+ZmxhZ3MpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjbWl0OwoJCWlmIChwcmVwYXJlX3JldmlzaW9uX3dhbGsob3B0cy0+cmV2cykpCgkJCXJldHVybiBlcnJvcihfKCJyZXZpc2lvbiB3YWxrIHNldHVwIGZhaWxlZCIpKTsKCQljbWl0ID0gZ2V0X3JldmlzaW9uKG9wdHMtPnJldnMpOwoJCWlmICghY21pdCB8fCBnZXRfcmV2aXNpb24ob3B0cy0+cmV2cykpCgkJCXJldHVybiBlcnJvcigiQlVHOiBleHBlY3RlZCBleGFjdGx5IG9uZSBjb21taXQgZnJvbSB3YWxrIik7CgkJcmV0dXJuIHNpbmdsZV9waWNrKGNtaXQsIG9wdHMpOwoJfQoKCS8qCgkgKiBTdGFydCBhIG5ldyBjaGVycnktcGljay8gcmV2ZXJ0IHNlcXVlbmNlOyBidXQKCSAqIGZpcnN0LCBtYWtlIHN1cmUgdGhhdCBhbiBleGlzdGluZyBvbmUgaXNuJ3QgaW4KCSAqIHByb2dyZXNzCgkgKi8KCglpZiAod2Fsa19yZXZzX3BvcHVsYXRlX3RvZG8oJnRvZG9fbGlzdCwgb3B0cykgfHwKCQkJY3JlYXRlX3NlcV9kaXIoKSA8IDApCgkJcmV0dXJuIC0xOwoJaWYgKGdldF9zaGExKCJIRUFEIiwgc2hhMSkgJiYgKG9wdHMtPmFjdGlvbiA9PSBSRVBMQVlfUkVWRVJUKSkKCQlyZXR1cm4gZXJyb3IoXygiQ2FuJ3QgcmV2ZXJ0IGFzIGluaXRpYWwgY29tbWl0IikpOwoJaWYgKHNhdmVfaGVhZChzaGExX3RvX2hleChzaGExKSkpCgkJcmV0dXJuIC0xOwoJaWYgKHNhdmVfb3B0cyhvcHRzKSkKCQlyZXR1cm4gLTE7CglyZXMgPSBwaWNrX2NvbW1pdHMoJnRvZG9fbGlzdCwgb3B0cyk7Cgl0b2RvX2xpc3RfcmVsZWFzZSgmdG9kb19saXN0KTsKCXJldHVybiByZXM7Cn0KCnZvaWQgYXBwZW5kX3NpZ25vZmYoc3RydWN0IHN0cmJ1ZiAqbXNnYnVmLCBpbnQgaWdub3JlX2Zvb3RlciwgdW5zaWduZWQgZmxhZykKewoJdW5zaWduZWQgbm9fZHVwX3NvYiA9IGZsYWcgJiBBUFBFTkRfU0lHTk9GRl9ERURVUDsKCXN0cnVjdCBzdHJidWYgc29iID0gU1RSQlVGX0lOSVQ7CglpbnQgaGFzX2Zvb3RlcjsKCglzdHJidWZfYWRkc3RyKCZzb2IsIHNpZ25fb2ZmX2hlYWRlcik7CglzdHJidWZfYWRkc3RyKCZzb2IsIGZtdF9uYW1lKGdldGVudigiR0lUX0NPTU1JVFRFUl9OQU1FIiksCgkJCQlnZXRlbnYoIkdJVF9DT01NSVRURVJfRU1BSUwiKSkpOwoJc3RyYnVmX2FkZGNoKCZzb2IsICdcbicpOwoKCS8qCgkgKiBJZiB0aGUgd2hvbGUgbWVzc2FnZSBidWZmZXIgaXMgZXF1YWwgdG8gdGhlIHNvYiwgcHJldGVuZCB0aGF0IHdlCgkgKiBmb3VuZCBhIGNvbmZvcm1pbmcgZm9vdGVyIHdpdGggYSBtYXRjaGluZyBzb2IKCSAqLwoJaWYgKG1zZ2J1Zi0+bGVuIC0gaWdub3JlX2Zvb3RlciA9PSBzb2IubGVuICYmCgkgICAgIXN0cm5jbXAobXNnYnVmLT5idWYsIHNvYi5idWYsIHNvYi5sZW4pKQoJCWhhc19mb290ZXIgPSAzOwoJZWxzZQoJCWhhc19mb290ZXIgPSBoYXNfY29uZm9ybWluZ19mb290ZXIobXNnYnVmLCAmc29iLCBpZ25vcmVfZm9vdGVyKTsKCglpZiAoIWhhc19mb290ZXIpIHsKCQljb25zdCBjaGFyICphcHBlbmRfbmV3bGluZXMgPSBOVUxMOwoJCXNpemVfdCBsZW4gPSBtc2didWYtPmxlbiAtIGlnbm9yZV9mb290ZXI7CgoJCWlmICghbGVuKSB7CgkJCS8qCgkJCSAqIFRoZSBidWZmZXIgaXMgY29tcGxldGVseSBlbXB0eS4gIExlYXZlIGZvb20gZm9yCgkJCSAqIHRoZSB0aXRsZSBhbmQgYm9keSB0byBiZSBmaWxsZWQgaW4gYnkgdGhlIHVzZXIuCgkJCSAqLwoJCQlhcHBlbmRfbmV3bGluZXMgPSAiXG5cbiI7CgkJfSBlbHNlIGlmIChtc2didWYtPmJ1ZltsZW4gLSAxXSAhPSAnXG4nKSB7CgkJCS8qCgkJCSAqIEluY29tcGxldGUgbGluZS4gIENvbXBsZXRlIHRoZSBsaW5lIGFuZCBhZGQgYQoJCQkgKiBibGFuayBvbmUgc28gdGhhdCB0aGVyZSBpcyBhbiBlbXB0eSBsaW5lIGJldHdlZW4KCQkJICogdGhlIG1lc3NhZ2UgYm9keSBhbmQgdGhlIHNvYi4KCQkJICovCgkJCWFwcGVuZF9uZXdsaW5lcyA9ICJcblxuIjsKCQl9IGVsc2UgaWYgKGxlbiA9PSAxKSB7CgkJCS8qCgkJCSAqIEJ1ZmZlciBjb250YWlucyBhIHNpbmdsZSBuZXdsaW5lLiAgQWRkIGFub3RoZXIKCQkJICogc28gdGhhdCB3ZSBsZWF2ZSByb29tIGZvciB0aGUgdGl0bGUgYW5kIGJvZHkuCgkJCSAqLwoJCQlhcHBlbmRfbmV3bGluZXMgPSAiXG4iOwoJCX0gZWxzZSBpZiAobXNnYnVmLT5idWZbbGVuIC0gMl0gIT0gJ1xuJykgewoJCQkvKgoJCQkgKiBCdWZmZXIgZW5kcyB3aXRoIGEgc2luZ2xlIG5ld2xpbmUuICBBZGQgYW5vdGhlcgoJCQkgKiBzbyB0aGF0IHRoZXJlIGlzIGFuIGVtcHR5IGxpbmUgYmV0d2VlbiB0aGUgbWVzc2FnZQoJCQkgKiBib2R5IGFuZCB0aGUgc29iLgoJCQkgKi8KCQkJYXBwZW5kX25ld2xpbmVzID0gIlxuIjsKCQl9IC8qIGVsc2UsIHRoZSBidWZmZXIgYWxyZWFkeSBlbmRzIHdpdGggdHdvIG5ld2xpbmVzLiAqLwoKCQlpZiAoYXBwZW5kX25ld2xpbmVzKQoJCQlzdHJidWZfc3BsaWNlKG1zZ2J1ZiwgbXNnYnVmLT5sZW4gLSBpZ25vcmVfZm9vdGVyLCAwLAoJCQkJYXBwZW5kX25ld2xpbmVzLCBzdHJsZW4oYXBwZW5kX25ld2xpbmVzKSk7Cgl9CgoJaWYgKGhhc19mb290ZXIgIT0gMyAmJiAoIW5vX2R1cF9zb2IgfHwgaGFzX2Zvb3RlciAhPSAyKSkKCQlzdHJidWZfc3BsaWNlKG1zZ2J1ZiwgbXNnYnVmLT5sZW4gLSBpZ25vcmVfZm9vdGVyLCAwLAoJCQkJc29iLmJ1Ziwgc29iLmxlbik7CgoJc3RyYnVmX3JlbGVhc2UoJnNvYik7Cn0K",
    "text": "#include \"cache.h\"\n#include \"lockfile.h\"\n#include \"sequencer.h\"\n#include \"dir.h\"\n#include \"object.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"run-command.h\"\n#include \"exec_cmd.h\"\n#include \"utf8.h\"\n#include \"cache-tree.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"rerere.h\"\n#include \"merge-recursive.h\"\n#include \"refs.h\"\n#include \"argv-array.h\"\n#include \"quote.h\"\n\n#define GIT_REFLOG_ACTION \"GIT_REFLOG_ACTION\"\n\nconst char sign_off_header[] = \"Signed-off-by: \";\nstatic const char cherry_picked_prefix[] = \"(cherry picked from commit \";\n\nGIT_PATH_FUNC(git_path_seq_dir, \"sequencer\")\n\nstatic GIT_PATH_FUNC(git_path_todo_file, \"sequencer/todo\")\nstatic GIT_PATH_FUNC(git_path_opts_file, \"sequencer/opts\")\nstatic GIT_PATH_FUNC(git_path_head_file, \"sequencer/head\")\n\n/*\n * A script to set the GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, and\n * GIT_AUTHOR_DATE that will be used for the commit that is currently\n * being rebased.\n */\nstatic GIT_PATH_FUNC(rebase_path_author_script, \"rebase-merge/author-script\")\n/*\n * The following files are written by git-rebase just after parsing the\n * command-line (and are only consumed, not modified, by the sequencer).\n */\nstatic GIT_PATH_FUNC(rebase_path_gpg_sign_opt, \"rebase-merge/gpg_sign_opt\")\n\n/* We will introduce the 'interactive rebase' mode later */\nstatic inline int is_rebase_i(const struct replay_opts *opts)\n{\n\treturn 0;\n}\n\nstatic const char *get_dir(const struct replay_opts *opts)\n{\n\treturn git_path_seq_dir();\n}\n\nstatic const char *get_todo_path(const struct replay_opts *opts)\n{\n\treturn git_path_todo_file();\n}\n\nstatic int is_rfc2822_line(const char *buf, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tint ch = buf[i];\n\t\tif (ch == ':')\n\t\t\treturn 1;\n\t\tif (!isalnum(ch) && ch != '-')\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int is_cherry_picked_from_line(const char *buf, int len)\n{\n\t/*\n\t * We only care that it looks roughly like (cherry picked from ...)\n\t */\n\treturn len > strlen(cherry_picked_prefix) + 1 &&\n\t\tstarts_with(buf, cherry_picked_prefix) && buf[len - 1] == ')';\n}\n\n/*\n * Returns 0 for non-conforming footer\n * Returns 1 for conforming footer\n * Returns 2 when sob exists within conforming footer\n * Returns 3 when sob exists within conforming footer as last entry\n */\nstatic int has_conforming_footer(struct strbuf *sb, struct strbuf *sob,\n\tint ignore_footer)\n{\n\tchar prev;\n\tint i, k;\n\tint len = sb->len - ignore_footer;\n\tconst char *buf = sb->buf;\n\tint found_sob = 0;\n\n\t/* footer must end with newline */\n\tif (!len || buf[len - 1] != '\\n')\n\t\treturn 0;\n\n\tprev = '\\0';\n\tfor (i = len - 1; i > 0; i--) {\n\t\tchar ch = buf[i];\n\t\tif (prev == '\\n' && ch == '\\n') /* paragraph break */\n\t\t\tbreak;\n\t\tprev = ch;\n\t}\n\n\t/* require at least one blank line */\n\tif (prev != '\\n' || buf[i] != '\\n')\n\t\treturn 0;\n\n\t/* advance to start of last paragraph */\n\twhile (i < len - 1 && buf[i] == '\\n')\n\t\ti++;\n\n\tfor (; i < len; i = k) {\n\t\tint found_rfc2822;\n\n\t\tfor (k = i; k < len && buf[k] != '\\n'; k++)\n\t\t\t; /* do nothing */\n\t\tk++;\n\n\t\tfound_rfc2822 = is_rfc2822_line(buf + i, k - i - 1);\n\t\tif (found_rfc2822 && sob &&\n\t\t    !strncmp(buf + i, sob->buf, sob->len))\n\t\t\tfound_sob = k;\n\n\t\tif (!(found_rfc2822 ||\n\t\t      is_cherry_picked_from_line(buf + i, k - i - 1)))\n\t\t\treturn 0;\n\t}\n\tif (found_sob == i)\n\t\treturn 3;\n\tif (found_sob)\n\t\treturn 2;\n\treturn 1;\n}\n\nstatic const char *gpg_sign_opt_quoted(struct replay_opts *opts)\n{\n\tstatic struct strbuf buf = STRBUF_INIT;\n\n\tstrbuf_reset(&buf);\n\tif (opts->gpg_sign)\n\t\tsq_quotef(&buf, \"-S%s\", opts->gpg_sign);\n\treturn buf.buf;\n}\n\nint sequencer_remove_state(struct replay_opts *opts)\n{\n\tstruct strbuf dir = STRBUF_INIT;\n\tint i;\n\n\tfree(opts->gpg_sign);\n\tfree(opts->strategy);\n\tfor (i = 0; i < opts->xopts_nr; i++)\n\t\tfree(opts->xopts[i]);\n\tfree(opts->xopts);\n\n\tstrbuf_addf(&dir, \"%s\", get_dir(opts));\n\tremove_dir_recursively(&dir, 0);\n\tstrbuf_release(&dir);\n\n\treturn 0;\n}\n\nstatic const char *action_name(const struct replay_opts *opts)\n{\n\treturn opts->action == REPLAY_REVERT ? \"revert\" : \"cherry-pick\";\n}\n\nstruct commit_message {\n\tchar *parent_label;\n\tchar *label;\n\tchar *subject;\n\tconst char *message;\n};\n\nstatic const char *short_commit_name(struct commit *commit)\n{\n\treturn find_unique_abbrev(commit->object.oid.hash, DEFAULT_ABBREV);\n}\n\nstatic int get_message(struct commit *commit, struct commit_message *out)\n{\n\tconst char *abbrev, *subject;\n\tint subject_len;\n\n\tout->message = logmsg_reencode(commit, NULL, get_commit_output_encoding());\n\tabbrev = short_commit_name(commit);\n\n\tsubject_len = find_commit_subject(out->message, &subject);\n\n\tout->subject = xmemdupz(subject, subject_len);\n\tout->label = xstrfmt(\"%s... %s\", abbrev, out->subject);\n\tout->parent_label = xstrfmt(\"parent of %s\", out->label);\n\n\treturn 0;\n}\n\nstatic void free_message(struct commit *commit, struct commit_message *msg)\n{\n\tfree(msg->parent_label);\n\tfree(msg->label);\n\tfree(msg->subject);\n\tunuse_commit_buffer(commit, msg->message);\n}\n\nstatic void print_advice(int show_hint, struct replay_opts *opts)\n{\n\tchar *msg = getenv(\"GIT_CHERRY_PICK_HELP\");\n\n\tif (msg) {\n\t\tfprintf(stderr, \"%s\\n\", msg);\n\t\t/*\n\t\t * A conflict has occurred but the porcelain\n\t\t * (typically rebase --interactive) wants to take care\n\t\t * of the commit itself so remove CHERRY_PICK_HEAD\n\t\t */\n\t\tunlink(git_path_cherry_pick_head());\n\t\treturn;\n\t}\n\n\tif (show_hint) {\n\t\tif (opts->no_commit)\n\t\t\tadvise(_(\"after resolving the conflicts, mark the corrected paths\\n\"\n\t\t\t\t \"with 'git add <paths>' or 'git rm <paths>'\"));\n\t\telse\n\t\t\tadvise(_(\"after resolving the conflicts, mark the corrected paths\\n\"\n\t\t\t\t \"with 'git add <paths>' or 'git rm <paths>'\\n\"\n\t\t\t\t \"and commit the result with 'git commit'\"));\n\t}\n}\n\nstatic int write_message(const void *buf, size_t len, const char *filename,\n\t\t\t int append_eol)\n{\n\tstatic struct lock_file msg_file;\n\n\tint msg_fd = hold_lock_file_for_update(&msg_file, filename, 0);\n\tif (msg_fd < 0)\n\t\treturn error_errno(_(\"Could not lock '%s'\"), filename);\n\tif (write_in_full(msg_fd, buf, len) < 0) {\n\t\trollback_lock_file(&msg_file);\n\t\treturn error_errno(_(\"Could not write to '%s'\"), filename);\n\t}\n\tif (append_eol && write(msg_fd, \"\\n\", 1) < 0) {\n\t\trollback_lock_file(&msg_file);\n\t\treturn error_errno(_(\"Could not write eol to '%s\"), filename);\n\t}\n\tif (commit_lock_file(&msg_file) < 0) {\n\t\trollback_lock_file(&msg_file);\n\t\treturn error(_(\"Error wrapping up %s.\"), filename);\n\t}\n\n\treturn 0;\n}\n\n/*\n * Reads a file that was presumably written by a shell script, i.e. with an\n * end-of-line marker that needs to be stripped.\n *\n * Note that only the last end-of-line marker is stripped, consistent with the\n * behavior of \"$(cat path)\" in a shell script.\n *\n * Returns 1 if the file was read, 0 if it could not be read or does not exist.\n */\nstatic int read_oneliner(struct strbuf *buf,\n\tconst char *path, int skip_if_empty)\n{\n\tint orig_len = buf->len;\n\n\tif (!file_exists(path))\n\t\treturn 0;\n\n\tif (strbuf_read_file(buf, path, 0) < 0) {\n\t\twarning_errno(_(\"could not read '%s'\"), path);\n\t\treturn 0;\n\t}\n\n\tif (buf->len > orig_len && buf->buf[buf->len - 1] == '\\n') {\n\t\tif (--buf->len > orig_len && buf->buf[buf->len - 1] == '\\r')\n\t\t\t--buf->len;\n\t\tbuf->buf[buf->len] = '\\0';\n\t}\n\n\tif (skip_if_empty && buf->len == orig_len)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic struct tree *empty_tree(void)\n{\n\treturn lookup_tree(EMPTY_TREE_SHA1_BIN);\n}\n\nstatic int error_dirty_index(struct replay_opts *opts)\n{\n\tif (read_cache_unmerged())\n\t\treturn error_resolve_conflict(action_name(opts));\n\n\terror(_(\"Your local changes would be overwritten by %s.\"),\n\t\taction_name(opts));\n\n\tif (advice_commit_before_merge)\n\t\tadvise(_(\"Commit your changes or stash them to proceed.\"));\n\treturn -1;\n}\n\nstatic int fast_forward_to(const unsigned char *to, const unsigned char *from,\n\t\t\tint unborn, struct replay_opts *opts)\n{\n\tstruct ref_transaction *transaction;\n\tstruct strbuf sb = STRBUF_INIT;\n\tstruct strbuf err = STRBUF_INIT;\n\n\tread_cache();\n\tif (checkout_fast_forward(from, to, 1))\n\t\treturn -1; /* the callee should have complained already */\n\n\tstrbuf_addf(&sb, _(\"%s: fast-forward\"), action_name(opts));\n\n\ttransaction = ref_transaction_begin(&err);\n\tif (!transaction ||\n\t    ref_transaction_update(transaction, \"HEAD\",\n\t\t\t\t   to, unborn ? null_sha1 : from,\n\t\t\t\t   0, sb.buf, &err) ||\n\t    ref_transaction_commit(transaction, &err)) {\n\t\tref_transaction_free(transaction);\n\t\terror(\"%s\", err.buf);\n\t\tstrbuf_release(&sb);\n\t\tstrbuf_release(&err);\n\t\treturn -1;\n\t}\n\n\tstrbuf_release(&sb);\n\tstrbuf_release(&err);\n\tref_transaction_free(transaction);\n\treturn 0;\n}\n\nvoid append_conflicts_hint(struct strbuf *msgbuf)\n{\n\tint i;\n\n\tstrbuf_addch(msgbuf, '\\n');\n\tstrbuf_commented_addf(msgbuf, \"Conflicts:\\n\");\n\tfor (i = 0; i < active_nr;) {\n\t\tconst struct cache_entry *ce = active_cache[i++];\n\t\tif (ce_stage(ce)) {\n\t\t\tstrbuf_commented_addf(msgbuf, \"\\t%s\\n\", ce->name);\n\t\t\twhile (i < active_nr && !strcmp(ce->name,\n\t\t\t\t\t\t\tactive_cache[i]->name))\n\t\t\t\ti++;\n\t\t}\n\t}\n}\n\nstatic int do_recursive_merge(struct commit *base, struct commit *next,\n\t\t\t      const char *base_label, const char *next_label,\n\t\t\t      unsigned char *head, struct strbuf *msgbuf,\n\t\t\t      struct replay_opts *opts)\n{\n\tstruct merge_options o;\n\tstruct tree *result, *next_tree, *base_tree, *head_tree;\n\tint clean;\n\tchar **xopt;\n\tstatic struct lock_file index_lock;\n\n\thold_locked_index(&index_lock, 1);\n\n\tread_cache();\n\n\tinit_merge_options(&o);\n\to.ancestor = base ? base_label : \"(empty tree)\";\n\to.branch1 = \"HEAD\";\n\to.branch2 = next ? next_label : \"(empty tree)\";\n\n\thead_tree = parse_tree_indirect(head);\n\tnext_tree = next ? next->tree : empty_tree();\n\tbase_tree = base ? base->tree : empty_tree();\n\n\tfor (xopt = opts->xopts; xopt != opts->xopts + opts->xopts_nr; xopt++)\n\t\tparse_merge_opt(&o, *xopt);\n\n\tclean = merge_trees(&o,\n\t\t\t    head_tree,\n\t\t\t    next_tree, base_tree, &result);\n\tstrbuf_release(&o.obuf);\n\tif (clean < 0)\n\t\treturn clean;\n\n\tif (active_cache_changed &&\n\t    write_locked_index(&the_index, &index_lock, COMMIT_LOCK))\n\t\t/* TRANSLATORS: %s will be \"revert\" or \"cherry-pick\" */\n\t\treturn error(_(\"%s: Unable to write new index file\"),\n\t\t\taction_name(opts));\n\trollback_lock_file(&index_lock);\n\n\tif (opts->signoff)\n\t\tappend_signoff(msgbuf, 0, 0);\n\n\tif (!clean)\n\t\tappend_conflicts_hint(msgbuf);\n\n\treturn !clean;\n}\n\nstatic int is_index_unchanged(void)\n{\n\tunsigned char head_sha1[20];\n\tstruct commit *head_commit;\n\n\tif (!resolve_ref_unsafe(\"HEAD\", RESOLVE_REF_READING, head_sha1, NULL))\n\t\treturn error(_(\"Could not resolve HEAD commit\\n\"));\n\n\thead_commit = lookup_commit(head_sha1);\n\n\t/*\n\t * If head_commit is NULL, check_commit, called from\n\t * lookup_commit, would have indicated that head_commit is not\n\t * a commit object already.  parse_commit() will return failure\n\t * without further complaints in such a case.  Otherwise, if\n\t * the commit is invalid, parse_commit() will complain.  So\n\t * there is nothing for us to say here.  Just return failure.\n\t */\n\tif (parse_commit(head_commit))\n\t\treturn -1;\n\n\tif (!active_cache_tree)\n\t\tactive_cache_tree = cache_tree();\n\n\tif (!cache_tree_fully_valid(active_cache_tree))\n\t\tif (cache_tree_update(&the_index, 0))\n\t\t\treturn error(_(\"Unable to update cache tree\\n\"));\n\n\treturn !hashcmp(active_cache_tree->sha1, head_commit->tree->object.oid.hash);\n}\n\n/*\n * Read the author-script file into an environment block, ready for use in\n * run_command(), that can be free()d afterwards.\n */\nstatic char **read_author_script(void)\n{\n\tstruct strbuf script = STRBUF_INIT;\n\tint i, count = 0;\n\tchar *p, *p2, **env;\n\tsize_t env_size;\n\n\tif (strbuf_read_file(&script, rebase_path_author_script(), 256) <= 0)\n\t\treturn NULL;\n\n\tfor (p = script.buf; *p; p++)\n\t\tif (skip_prefix(p, \"'\\\\\\\\''\", (const char **)&p2))\n\t\t\tstrbuf_splice(&script, p - script.buf, p2 - p, \"'\", 1);\n\t\telse if (*p == '\\'')\n\t\t\tstrbuf_splice(&script, p-- - script.buf, 1, \"\", 0);\n\t\telse if (*p == '\\n') {\n\t\t\t*p = '\\0';\n\t\t\tcount++;\n\t\t}\n\n\tenv_size = (count + 1) * sizeof(*env);\n\tstrbuf_grow(&script, env_size);\n\tmemmove(script.buf + env_size, script.buf, script.len);\n\tp = script.buf + env_size;\n\tenv = (char **)strbuf_detach(&script, NULL);\n\n\tfor (i = 0; i < count; i++) {\n\t\tenv[i] = p;\n\t\tp += strlen(p) + 1;\n\t}\n\tenv[count] = NULL;\n\n\treturn env;\n}\n\n/*\n * If we are cherry-pick, and if the merge did not result in\n * hand-editing, we will hit this commit and inherit the original\n * author date and name.\n *\n * If we are revert, or if our cherry-pick results in a hand merge,\n * we had better say that the current user is responsible for that.\n *\n * An exception is when run_git_commit() is called during an\n * interactive rebase: in that case, we will want to retain the\n * author metadata.\n */\nstatic int run_git_commit(const char *defmsg, struct replay_opts *opts,\n\t\t\t  int allow_empty, int edit, int amend,\n\t\t\t  int cleanup_commit_message)\n{\n\tchar **env = NULL;\n\tstruct argv_array array;\n\tint rc;\n\tconst char *value;\n\n\tif (is_rebase_i(opts)) {\n\t\tenv = read_author_script();\n\t\tif (!env) {\n\t\t\tconst char *gpg_opt = gpg_sign_opt_quoted(opts);\n\n\t\t\treturn error(\"You have staged changes in your working \"\n\t\t\t\t\"tree. If these changes are meant to be\\n\"\n\t\t\t\t\"squashed into the previous commit, run:\\n\\n\"\n\t\t\t\t\"  git commit --amend %s\\n\\n\"\n\t\t\t\t\"If they are meant to go into a new commit, \"\n\t\t\t\t\"run:\\n\\n\"\n\t\t\t\t\"  git commit %s\\n\\n\"\n\t\t\t\t\"In both cases, once you're done, continue \"\n\t\t\t\t\"with:\\n\\n\"\n\t\t\t\t\"  git rebase --continue\\n\", gpg_opt, gpg_opt);\n\t\t}\n\t}\n\n\targv_array_init(&array);\n\targv_array_push(&array, \"commit\");\n\targv_array_push(&array, \"-n\");\n\n\tif (amend)\n\t\targv_array_push(&array, \"--amend\");\n\tif (opts->gpg_sign)\n\t\targv_array_pushf(&array, \"-S%s\", opts->gpg_sign);\n\tif (opts->signoff)\n\t\targv_array_push(&array, \"-s\");\n\tif (defmsg)\n\t\targv_array_pushl(&array, \"-F\", defmsg, NULL);\n\tif (cleanup_commit_message)\n\t\targv_array_push(&array, \"--cleanup=strip\");\n\tif (edit)\n\t\targv_array_push(&array, \"-e\");\n\telse if (!cleanup_commit_message &&\n\t\t !opts->signoff && !opts->record_origin &&\n\t\t git_config_get_value(\"commit.cleanup\", &value))\n\t\targv_array_push(&array, \"--cleanup=verbatim\");\n\n\tif (allow_empty)\n\t\targv_array_push(&array, \"--allow-empty\");\n\n\tif (opts->allow_empty_message)\n\t\targv_array_push(&array, \"--allow-empty-message\");\n\n\trc = run_command_v_opt_cd_env(array.argv, RUN_GIT_CMD, NULL,\n\t\t\t(const char *const *)env);\n\targv_array_clear(&array);\n\tfree(env);\n\n\treturn rc;\n}\n\nstatic int is_original_commit_empty(struct commit *commit)\n{\n\tconst unsigned char *ptree_sha1;\n\n\tif (parse_commit(commit))\n\t\treturn error(_(\"Could not parse commit %s\\n\"),\n\t\t\t     oid_to_hex(&commit->object.oid));\n\tif (commit->parents) {\n\t\tstruct commit *parent = commit->parents->item;\n\t\tif (parse_commit(parent))\n\t\t\treturn error(_(\"Could not parse parent commit %s\\n\"),\n\t\t\t\toid_to_hex(&parent->object.oid));\n\t\tptree_sha1 = parent->tree->object.oid.hash;\n\t} else {\n\t\tptree_sha1 = EMPTY_TREE_SHA1_BIN; /* commit is root */\n\t}\n\n\treturn !hashcmp(ptree_sha1, commit->tree->object.oid.hash);\n}\n\n/*\n * Do we run \"git commit\" with \"--allow-empty\"?\n */\nstatic int allow_empty(struct replay_opts *opts, struct commit *commit)\n{\n\tint index_unchanged, empty_commit;\n\n\t/*\n\t * Three cases:\n\t *\n\t * (1) we do not allow empty at all and error out.\n\t *\n\t * (2) we allow ones that were initially empty, but\n\t * forbid the ones that become empty;\n\t *\n\t * (3) we allow both.\n\t */\n\tif (!opts->allow_empty)\n\t\treturn 0; /* let \"git commit\" barf as necessary */\n\n\tindex_unchanged = is_index_unchanged();\n\tif (index_unchanged < 0)\n\t\treturn index_unchanged;\n\tif (!index_unchanged)\n\t\treturn 0; /* we do not have to say --allow-empty */\n\n\tif (opts->keep_redundant_commits)\n\t\treturn 1;\n\n\tempty_commit = is_original_commit_empty(commit);\n\tif (empty_commit < 0)\n\t\treturn empty_commit;\n\tif (!empty_commit)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nenum todo_command {\n\tTODO_PICK = 0,\n\tTODO_REVERT\n};\n\nstatic const char *todo_command_strings[] = {\n\t\"pick\",\n\t\"revert\"\n};\n\nstatic const char *command_to_string(const enum todo_command command)\n{\n\tif (command < ARRAY_SIZE(todo_command_strings))\n\t\treturn todo_command_strings[command];\n\tdie(\"Unknown command: %d\", command);\n}\n\n\nstatic int do_pick_commit(enum todo_command command, struct commit *commit,\n\t\tstruct replay_opts *opts)\n{\n\tunsigned char head[20];\n\tstruct commit *base, *next, *parent;\n\tconst char *base_label, *next_label;\n\tstruct commit_message msg = { NULL, NULL, NULL, NULL };\n\tstruct strbuf msgbuf = STRBUF_INIT;\n\tint res, unborn = 0, allow;\n\n\tif (opts->no_commit) {\n\t\t/*\n\t\t * We do not intend to commit immediately.  We just want to\n\t\t * merge the differences in, so let's compute the tree\n\t\t * that represents the \"current\" state for merge-recursive\n\t\t * to work on.\n\t\t */\n\t\tif (write_cache_as_tree(head, 0, NULL))\n\t\t\treturn error(_(\"Your index file is unmerged.\"));\n\t} else {\n\t\tunborn = get_sha1(\"HEAD\", head);\n\t\tif (unborn)\n\t\t\thashcpy(head, EMPTY_TREE_SHA1_BIN);\n\t\tif (index_differs_from(unborn ? EMPTY_TREE_SHA1_HEX : \"HEAD\", 0))\n\t\t\treturn error_dirty_index(opts);\n\t}\n\tdiscard_cache();\n\n\tif (!commit->parents) {\n\t\tparent = NULL;\n\t}\n\telse if (commit->parents->next) {\n\t\t/* Reverting or cherry-picking a merge commit */\n\t\tint cnt;\n\t\tstruct commit_list *p;\n\n\t\tif (!opts->mainline)\n\t\t\treturn error(_(\"Commit %s is a merge but no -m option was given.\"),\n\t\t\t\toid_to_hex(&commit->object.oid));\n\n\t\tfor (cnt = 1, p = commit->parents;\n\t\t     cnt != opts->mainline && p;\n\t\t     cnt++)\n\t\t\tp = p->next;\n\t\tif (cnt != opts->mainline || !p)\n\t\t\treturn error(_(\"Commit %s does not have parent %d\"),\n\t\t\t\toid_to_hex(&commit->object.oid), opts->mainline);\n\t\tparent = p->item;\n\t} else if (0 < opts->mainline)\n\t\treturn error(_(\"Mainline was specified but commit %s is not a merge.\"),\n\t\t\toid_to_hex(&commit->object.oid));\n\telse\n\t\tparent = commit->parents->item;\n\n\tif (opts->allow_ff &&\n\t    ((parent && !hashcmp(parent->object.oid.hash, head)) ||\n\t     (!parent && unborn)))\n\t\treturn fast_forward_to(commit->object.oid.hash, head, unborn, opts);\n\n\tif (parent && parse_commit(parent) < 0)\n\t\t/* TRANSLATORS: The first %s will be a \"todo\" command like\n\t\t   \"revert\" or \"pick\", the second %s a SHA1. */\n\t\treturn error(_(\"%s: cannot parse parent commit %s\"),\n\t\t\tcommand_to_string(command),\n\t\t\toid_to_hex(&parent->object.oid));\n\n\tif (get_message(commit, &msg) != 0)\n\t\treturn error(_(\"Cannot get commit message for %s\"),\n\t\t\toid_to_hex(&commit->object.oid));\n\n\t/*\n\t * \"commit\" is an existing commit.  We would want to apply\n\t * the difference it introduces since its first parent \"prev\"\n\t * on top of the current HEAD if we are cherry-pick.  Or the\n\t * reverse of it if we are revert.\n\t */\n\n\tif (command == TODO_REVERT) {\n\t\tbase = commit;\n\t\tbase_label = msg.label;\n\t\tnext = parent;\n\t\tnext_label = msg.parent_label;\n\t\tstrbuf_addstr(&msgbuf, \"Revert \\\"\");\n\t\tstrbuf_addstr(&msgbuf, msg.subject);\n\t\tstrbuf_addstr(&msgbuf, \"\\\"\\n\\nThis reverts commit \");\n\t\tstrbuf_addstr(&msgbuf, oid_to_hex(&commit->object.oid));\n\n\t\tif (commit->parents && commit->parents->next) {\n\t\t\tstrbuf_addstr(&msgbuf, \", reversing\\nchanges made to \");\n\t\t\tstrbuf_addstr(&msgbuf, oid_to_hex(&parent->object.oid));\n\t\t}\n\t\tstrbuf_addstr(&msgbuf, \".\\n\");\n\t} else {\n\t\tconst char *p;\n\n\t\tbase = parent;\n\t\tbase_label = msg.parent_label;\n\t\tnext = commit;\n\t\tnext_label = msg.label;\n\n\t\t/*\n\t\t * Append the commit log message to msgbuf; it starts\n\t\t * after the tree, parent, author, committer\n\t\t * information followed by \"\\n\\n\".\n\t\t */\n\t\tp = strstr(msg.message, \"\\n\\n\");\n\t\tif (p)\n\t\t\tstrbuf_addstr(&msgbuf, skip_blank_lines(p + 2));\n\n\t\tif (opts->record_origin) {\n\t\t\tif (!has_conforming_footer(&msgbuf, NULL, 0))\n\t\t\t\tstrbuf_addch(&msgbuf, '\\n');\n\t\t\tstrbuf_addstr(&msgbuf, cherry_picked_prefix);\n\t\t\tstrbuf_addstr(&msgbuf, oid_to_hex(&commit->object.oid));\n\t\t\tstrbuf_addstr(&msgbuf, \")\\n\");\n\t\t}\n\t}\n\n\tif (!opts->strategy || !strcmp(opts->strategy, \"recursive\") || command == TODO_REVERT) {\n\t\tres = do_recursive_merge(base, next, base_label, next_label,\n\t\t\t\t\t head, &msgbuf, opts);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\tres |= write_message(msgbuf.buf, msgbuf.len,\n\t\t\t\t     git_path_merge_msg(), 0);\n\t} else {\n\t\tstruct commit_list *common = NULL;\n\t\tstruct commit_list *remotes = NULL;\n\n\t\tres = write_message(msgbuf.buf, msgbuf.len,\n\t\t\t\t    git_path_merge_msg(), 0);\n\n\t\tcommit_list_insert(base, &common);\n\t\tcommit_list_insert(next, &remotes);\n\t\tres |= try_merge_command(opts->strategy,\n\t\t\t\t\t opts->xopts_nr, (const char **)opts->xopts,\n\t\t\t\t\tcommon, sha1_to_hex(head), remotes);\n\t\tfree_commit_list(common);\n\t\tfree_commit_list(remotes);\n\t}\n\tstrbuf_release(&msgbuf);\n\n\t/*\n\t * If the merge was clean or if it failed due to conflict, we write\n\t * CHERRY_PICK_HEAD for the subsequent invocation of commit to use.\n\t * However, if the merge did not even start, then we don't want to\n\t * write it at all.\n\t */\n\tif (command == TODO_PICK && !opts->no_commit && (res == 0 || res == 1) &&\n\t    update_ref(NULL, \"CHERRY_PICK_HEAD\", commit->object.oid.hash, NULL,\n\t\t       REF_NODEREF, UPDATE_REFS_MSG_ON_ERR))\n\t\tres = -1;\n\tif (command == TODO_REVERT && ((opts->no_commit && res == 0) || res == 1) &&\n\t    update_ref(NULL, \"REVERT_HEAD\", commit->object.oid.hash, NULL,\n\t\t       REF_NODEREF, UPDATE_REFS_MSG_ON_ERR))\n\t\tres = -1;\n\n\tif (res) {\n\t\terror(command == TODO_REVERT\n\t\t      ? _(\"could not revert %s... %s\")\n\t\t      : _(\"could not apply %s... %s\"),\n\t\t      short_commit_name(commit), msg.subject);\n\t\tprint_advice(res == 1, opts);\n\t\trerere(opts->allow_rerere_auto);\n\t\tgoto leave;\n\t}\n\n\tallow = allow_empty(opts, commit);\n\tif (allow < 0) {\n\t\tres = allow;\n\t\tgoto leave;\n\t}\n\tif (!opts->no_commit)\n\t\tres = run_git_commit(opts->edit ? NULL : git_path_merge_msg(),\n\t\t\t\t     opts, allow, opts->edit, 0, 0);\n\nleave:\n\tfree_message(commit, &msg);\n\n\treturn res;\n}\n\nstatic int prepare_revs(struct replay_opts *opts)\n{\n\t/*\n\t * picking (but not reverting) ranges (but not individual revisions)\n\t * should be done in reverse\n\t */\n\tif (opts->action == REPLAY_PICK && !opts->revs->no_walk)\n\t\topts->revs->reverse ^= 1;\n\n\tif (prepare_revision_walk(opts->revs))\n\t\treturn error(_(\"revision walk setup failed\"));\n\n\tif (!opts->revs->commits)\n\t\treturn error(_(\"empty commit set passed\"));\n\treturn 0;\n}\n\nstatic int read_and_refresh_cache(struct replay_opts *opts)\n{\n\tstatic struct lock_file index_lock;\n\tint index_fd = hold_locked_index(&index_lock, 0);\n\tif (read_index_preload(&the_index, NULL) < 0) {\n\t\trollback_lock_file(&index_lock);\n\t\treturn error(_(\"git %s: failed to read the index\"),\n\t\t\taction_name(opts));\n\t}\n\trefresh_index(&the_index, REFRESH_QUIET|REFRESH_UNMERGED, NULL, NULL, NULL);\n\tif (the_index.cache_changed && index_fd >= 0) {\n\t\tif (write_locked_index(&the_index, &index_lock, COMMIT_LOCK)) {\n\t\t\trollback_lock_file(&index_lock);\n\t\t\treturn error(_(\"git %s: failed to refresh the index\"),\n\t\t\t\taction_name(opts));\n\t\t}\n\t}\n\trollback_lock_file(&index_lock);\n\treturn 0;\n}\n\nstruct todo_item {\n\tenum todo_command command;\n\tstruct commit *commit;\n\tconst char *arg;\n\tint arg_len;\n\tsize_t offset_in_buf;\n};\n\nstruct todo_list {\n\tstruct strbuf buf;\n\tstruct todo_item *items;\n\tint nr, alloc, current;\n};\n\n#define TODO_LIST_INIT { STRBUF_INIT }\n\nstatic void todo_list_release(struct todo_list *todo_list)\n{\n\tstrbuf_release(&todo_list->buf);\n\tfree(todo_list->items);\n\ttodo_list->items = NULL;\n\ttodo_list->nr = todo_list->alloc = 0;\n}\n\nstatic struct todo_item *append_new_todo(struct todo_list *todo_list)\n{\n\tALLOC_GROW(todo_list->items, todo_list->nr + 1, todo_list->alloc);\n\treturn todo_list->items + todo_list->nr++;\n}\n\nstatic int parse_insn_line(struct todo_item *item, const char *bol, char *eol)\n{\n\tunsigned char commit_sha1[20];\n\tchar *end_of_object_name;\n\tint i, saved, status, padding;\n\n\t/* left-trim */\n\tbol += strspn(bol, \" \\t\");\n\n\tfor (i = 0; i < ARRAY_SIZE(todo_command_strings); i++)\n\t\tif (skip_prefix(bol, todo_command_strings[i], &bol)) {\n\t\t\titem->command = i;\n\t\t\tbreak;\n\t\t}\n\tif (i >= ARRAY_SIZE(todo_command_strings))\n\t\treturn -1;\n\n\t/* Eat up extra spaces/ tabs before object name */\n\tpadding = strspn(bol, \" \\t\");\n\tif (!padding)\n\t\treturn -1;\n\tbol += padding;\n\n\tend_of_object_name = (char *) bol + strcspn(bol, \" \\t\\n\");\n\tsaved = *end_of_object_name;\n\t*end_of_object_name = '\\0';\n\tstatus = get_sha1(bol, commit_sha1);\n\t*end_of_object_name = saved;\n\n\titem->arg = end_of_object_name + strspn(end_of_object_name, \" \\t\");\n\titem->arg_len = (int)(eol - item->arg);\n\n\tif (status < 0)\n\t\treturn -1;\n\n\titem->commit = lookup_commit_reference(commit_sha1);\n\treturn !item->commit;\n}\n\nstatic int parse_insn_buffer(char *buf, struct todo_list *todo_list)\n{\n\tstruct todo_item *item;\n\tchar *p = buf, *next_p;\n\tint i, res = 0;\n\n\tfor (i = 1; *p; i++, p = next_p) {\n\t\tchar *eol = strchrnul(p, '\\n');\n\n\t\tnext_p = *eol ? eol + 1 /* skip LF */ : eol;\n\n\t\tif (p != eol && eol[-1] == '\\r')\n\t\t\teol--; /* strip Carriage Return */\n\n\t\titem = append_new_todo(todo_list);\n\t\titem->offset_in_buf = p - todo_list->buf.buf;\n\t\tif (parse_insn_line(item, p, eol)) {\n\t\t\tres = error(_(\"Invalid line %d: %.*s\"),\n\t\t\t\ti, (int)(eol - p), p);\n\t\t\titem->command = -1;\n\t\t}\n\t}\n\tif (!todo_list->nr)\n\t\treturn error(_(\"No commits parsed.\"));\n\treturn res;\n}\n\nstatic int read_populate_todo(struct todo_list *todo_list,\n\t\t\tstruct replay_opts *opts)\n{\n\tconst char *todo_file = get_todo_path(opts);\n\tint fd, res;\n\n\tstrbuf_reset(&todo_list->buf);\n\tfd = open(todo_file, O_RDONLY);\n\tif (fd < 0)\n\t\treturn error_errno(_(\"Could not open %s\"), todo_file);\n\tif (strbuf_read(&todo_list->buf, fd, 0) < 0) {\n\t\tclose(fd);\n\t\treturn error(_(\"Could not read %s.\"), todo_file);\n\t}\n\tclose(fd);\n\n\tres = parse_insn_buffer(todo_list->buf.buf, todo_list);\n\tif (!res) {\n\t\tenum todo_command valid =\n\t\t\topts->action == REPLAY_PICK ? TODO_PICK : TODO_REVERT;\n\t\tint i;\n\n\t\tfor (i = 0; i < todo_list->nr; i++)\n\t\t\tif (valid == todo_list->items[i].command)\n\t\t\t\tcontinue;\n\t\t\telse if (valid == TODO_PICK)\n\t\t\t\treturn error(_(\"Cannot cherry-pick during a revert.\"));\n\t\t\telse\n\t\t\t\treturn error(_(\"Cannot revert during a cherry-pick.\"));\n\t}\n\n\tif (res)\n\t\treturn error(_(\"Unusable instruction sheet: %s\"), todo_file);\n\treturn 0;\n}\n\nstatic int git_config_string_dup(char **dest,\n\t\t\t\t const char *var, const char *value)\n{\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\tfree(*dest);\n\t*dest = xstrdup(value);\n\treturn 0;\n}\n\nstatic int populate_opts_cb(const char *key, const char *value, void *data)\n{\n\tstruct replay_opts *opts = data;\n\tint error_flag = 1;\n\n\tif (!value)\n\t\terror_flag = 0;\n\telse if (!strcmp(key, \"options.no-commit\"))\n\t\topts->no_commit = git_config_bool_or_int(key, value, &error_flag);\n\telse if (!strcmp(key, \"options.edit\"))\n\t\topts->edit = git_config_bool_or_int(key, value, &error_flag);\n\telse if (!strcmp(key, \"options.signoff\"))\n\t\topts->signoff = git_config_bool_or_int(key, value, &error_flag);\n\telse if (!strcmp(key, \"options.record-origin\"))\n\t\topts->record_origin = git_config_bool_or_int(key, value, &error_flag);\n\telse if (!strcmp(key, \"options.allow-ff\"))\n\t\topts->allow_ff = git_config_bool_or_int(key, value, &error_flag);\n\telse if (!strcmp(key, \"options.mainline\"))\n\t\topts->mainline = git_config_int(key, value);\n\telse if (!strcmp(key, \"options.strategy\"))\n\t\tgit_config_string_dup(&opts->strategy, key, value);\n\telse if (!strcmp(key, \"options.gpg-sign\"))\n\t\tgit_config_string_dup(&opts->gpg_sign, key, value);\n\telse if (!strcmp(key, \"options.strategy-option\")) {\n\t\tALLOC_GROW(opts->xopts, opts->xopts_nr + 1, opts->xopts_alloc);\n\t\topts->xopts[opts->xopts_nr++] = xstrdup(value);\n\t} else\n\t\treturn error(_(\"Invalid key: %s\"), key);\n\n\tif (!error_flag)\n\t\treturn error(_(\"Invalid value for %s: %s\"), key, value);\n\n\treturn 0;\n}\n\nstatic int read_populate_opts(struct replay_opts *opts)\n{\n\tif (is_rebase_i(opts)) {\n\t\tstruct strbuf buf = STRBUF_INIT;\n\n\t\tif (read_oneliner(&buf, rebase_path_gpg_sign_opt(), 1)) {\n\t\t\tif (!starts_with(buf.buf, \"-S\"))\n\t\t\t\tstrbuf_reset(&buf);\n\t\t\telse {\n\t\t\t\tfree(opts->gpg_sign);\n\t\t\t\topts->gpg_sign = xstrdup(buf.buf + 2);\n\t\t\t}\n\t\t}\n\t\tstrbuf_release(&buf);\n\n\t\treturn 0;\n\t}\n\n\tif (!file_exists(git_path_opts_file()))\n\t\treturn 0;\n\t/*\n\t * The function git_parse_source(), called from git_config_from_file(),\n\t * may die() in case of a syntactically incorrect file. We do not care\n\t * about this case, though, because we wrote that file ourselves, so we\n\t * are pretty certain that it is syntactically correct.\n\t */\n\tif (git_config_from_file(populate_opts_cb, git_path_opts_file(), opts) < 0)\n\t\treturn error(_(\"Malformed options sheet: %s\"),\n\t\t\tgit_path_opts_file());\n\treturn 0;\n}\n\nstatic int walk_revs_populate_todo(struct todo_list *todo_list,\n\t\t\t\tstruct replay_opts *opts)\n{\n\tenum todo_command command = opts->action == REPLAY_PICK ?\n\t\tTODO_PICK : TODO_REVERT;\n\tconst char *command_string = todo_command_strings[command];\n\tstruct commit *commit;\n\n\tif (prepare_revs(opts))\n\t\treturn -1;\n\n\twhile ((commit = get_revision(opts->revs))) {\n\t\tstruct todo_item *item = append_new_todo(todo_list);\n\t\tconst char *commit_buffer = get_commit_buffer(commit, NULL);\n\t\tconst char *subject;\n\t\tint subject_len;\n\n\t\titem->command = command;\n\t\titem->commit = commit;\n\t\titem->arg = NULL;\n\t\titem->arg_len = 0;\n\t\titem->offset_in_buf = todo_list->buf.len;\n\t\tsubject_len = find_commit_subject(commit_buffer, &subject);\n\t\tstrbuf_addf(&todo_list->buf, \"%s %s %.*s\\n\", command_string,\n\t\t\tshort_commit_name(commit), subject_len, subject);\n\t\tunuse_commit_buffer(commit, commit_buffer);\n\t}\n\treturn 0;\n}\n\nstatic int create_seq_dir(void)\n{\n\tif (file_exists(git_path_seq_dir())) {\n\t\terror(_(\"a cherry-pick or revert is already in progress\"));\n\t\tadvise(_(\"try \\\"git cherry-pick (--continue | --quit | --abort)\\\"\"));\n\t\treturn -1;\n\t}\n\telse if (mkdir(git_path_seq_dir(), 0777) < 0)\n\t\treturn error_errno(_(\"Could not create sequencer directory %s\"),\n\t\t\t\t   git_path_seq_dir());\n\treturn 0;\n}\n\nstatic int save_head(const char *head)\n{\n\tstatic struct lock_file head_lock;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint fd;\n\n\tfd = hold_lock_file_for_update(&head_lock, git_path_head_file(), 0);\n\tif (fd < 0) {\n\t\trollback_lock_file(&head_lock);\n\t\treturn error_errno(_(\"Could not lock HEAD\"));\n\t}\n\tstrbuf_addf(&buf, \"%s\\n\", head);\n\tif (write_in_full(fd, buf.buf, buf.len) < 0) {\n\t\trollback_lock_file(&head_lock);\n\t\treturn error_errno(_(\"Could not write to %s\"),\n\t\t\t\t   git_path_head_file());\n\t}\n\tif (commit_lock_file(&head_lock) < 0) {\n\t\trollback_lock_file(&head_lock);\n\t\treturn error(_(\"Error wrapping up %s.\"), git_path_head_file());\n\t}\n\treturn 0;\n}\n\nstatic int reset_for_rollback(const unsigned char *sha1)\n{\n\tconst char *argv[4];\t/* reset --merge <arg> + NULL */\n\targv[0] = \"reset\";\n\targv[1] = \"--merge\";\n\targv[2] = sha1_to_hex(sha1);\n\targv[3] = NULL;\n\treturn run_command_v_opt(argv, RUN_GIT_CMD);\n}\n\nstatic int rollback_single_pick(void)\n{\n\tunsigned char head_sha1[20];\n\n\tif (!file_exists(git_path_cherry_pick_head()) &&\n\t    !file_exists(git_path_revert_head()))\n\t\treturn error(_(\"no cherry-pick or revert in progress\"));\n\tif (read_ref_full(\"HEAD\", 0, head_sha1, NULL))\n\t\treturn error(_(\"cannot resolve HEAD\"));\n\tif (is_null_sha1(head_sha1))\n\t\treturn error(_(\"cannot abort from a branch yet to be born\"));\n\treturn reset_for_rollback(head_sha1);\n}\n\nint sequencer_rollback(struct replay_opts *opts)\n{\n\tFILE *f;\n\tunsigned char sha1[20];\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tf = fopen(git_path_head_file(), \"r\");\n\tif (!f && errno == ENOENT) {\n\t\t/*\n\t\t * There is no multiple-cherry-pick in progress.\n\t\t * If CHERRY_PICK_HEAD or REVERT_HEAD indicates\n\t\t * a single-cherry-pick in progress, abort that.\n\t\t */\n\t\treturn rollback_single_pick();\n\t}\n\tif (!f)\n\t\treturn error_errno(_(\"cannot open %s\"), git_path_head_file());\n\tif (strbuf_getline_lf(&buf, f)) {\n\t\terror(_(\"cannot read %s: %s\"), git_path_head_file(),\n\t\t      ferror(f) ?  strerror(errno) : _(\"unexpected end of file\"));\n\t\tfclose(f);\n\t\tgoto fail;\n\t}\n\tfclose(f);\n\tif (get_sha1_hex(buf.buf, sha1) || buf.buf[40] != '\\0') {\n\t\terror(_(\"stored pre-cherry-pick HEAD file '%s' is corrupt\"),\n\t\t\tgit_path_head_file());\n\t\tgoto fail;\n\t}\n\tif (is_null_sha1(sha1)) {\n\t\terror(_(\"cannot abort from a branch yet to be born\"));\n\t\tgoto fail;\n\t}\n\tif (reset_for_rollback(sha1))\n\t\tgoto fail;\n\tstrbuf_release(&buf);\n\treturn sequencer_remove_state(opts);\nfail:\n\tstrbuf_release(&buf);\n\treturn -1;\n}\n\nstatic int save_todo(struct todo_list *todo_list, struct replay_opts *opts)\n{\n\tstatic struct lock_file todo_lock;\n\tconst char *todo_path = get_todo_path(opts);\n\tint next = todo_list->current, offset, fd;\n\n\tfd = hold_lock_file_for_update(&todo_lock, todo_path, 0);\n\tif (fd < 0)\n\t\treturn error_errno(_(\"Could not lock '%s'\"), todo_path);\n\toffset = next < todo_list->nr ?\n\t\ttodo_list->items[next].offset_in_buf : todo_list->buf.len;\n\tif (write_in_full(fd, todo_list->buf.buf + offset,\n\t\t\ttodo_list->buf.len - offset) < 0)\n\t\treturn error_errno(_(\"Could not write to '%s'\"), todo_path);\n\tif (commit_lock_file(&todo_lock) < 0)\n\t\treturn error(_(\"Error wrapping up %s.\"), todo_path);\n\treturn 0;\n}\n\nstatic int save_opts(struct replay_opts *opts)\n{\n\tconst char *opts_file = git_path_opts_file();\n\tint res = 0;\n\n\tif (opts->no_commit)\n\t\tres |= git_config_set_in_file_gently(opts_file, \"options.no-commit\", \"true\");\n\tif (opts->edit)\n\t\tres |= git_config_set_in_file_gently(opts_file, \"options.edit\", \"true\");\n\tif (opts->signoff)\n\t\tres |= git_config_set_in_file_gently(opts_file, \"options.signoff\", \"true\");\n\tif (opts->record_origin)\n\t\tres |= git_config_set_in_file_gently(opts_file, \"options.record-origin\", \"true\");\n\tif (opts->allow_ff)\n\t\tres |= git_config_set_in_file_gently(opts_file, \"options.allow-ff\", \"true\");\n\tif (opts->mainline) {\n\t\tstruct strbuf buf = STRBUF_INIT;\n\t\tstrbuf_addf(&buf, \"%d\", opts->mainline);\n\t\tres |= git_config_set_in_file_gently(opts_file, \"options.mainline\", buf.buf);\n\t\tstrbuf_release(&buf);\n\t}\n\tif (opts->strategy)\n\t\tres |= git_config_set_in_file_gently(opts_file, \"options.strategy\", opts->strategy);\n\tif (opts->gpg_sign)\n\t\tres |= git_config_set_in_file_gently(opts_file, \"options.gpg-sign\", opts->gpg_sign);\n\tif (opts->xopts) {\n\t\tint i;\n\t\tfor (i = 0; i < opts->xopts_nr; i++)\n\t\t\tres |= git_config_set_multivar_in_file_gently(opts_file,\n\t\t\t\t\t\t\t\"options.strategy-option\",\n\t\t\t\t\t\t\topts->xopts[i], \"^$\", 0);\n\t}\n\treturn res;\n}\n\nstatic int pick_commits(struct todo_list *todo_list, struct replay_opts *opts)\n{\n\tint res;\n\n\tsetenv(GIT_REFLOG_ACTION, action_name(opts), 0);\n\tif (opts->allow_ff)\n\t\tassert(!(opts->signoff || opts->no_commit ||\n\t\t\t\topts->record_origin || opts->edit));\n\tif (read_and_refresh_cache(opts))\n\t\treturn -1;\n\n\twhile (todo_list->current < todo_list->nr) {\n\t\tstruct todo_item *item = todo_list->items + todo_list->current;\n\t\tif (save_todo(todo_list, opts))\n\t\t\treturn -1;\n\t\tres = do_pick_commit(item->command, item->commit, opts);\n\t\ttodo_list->current++;\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\t/*\n\t * Sequence of picks finished successfully; cleanup by\n\t * removing the .git/sequencer directory\n\t */\n\treturn sequencer_remove_state(opts);\n}\n\nstatic int continue_single_pick(void)\n{\n\tconst char *argv[] = { \"commit\", NULL };\n\n\tif (!file_exists(git_path_cherry_pick_head()) &&\n\t    !file_exists(git_path_revert_head()))\n\t\treturn error(_(\"no cherry-pick or revert in progress\"));\n\treturn run_command_v_opt(argv, RUN_GIT_CMD);\n}\n\nint sequencer_continue(struct replay_opts *opts)\n{\n\tstruct todo_list todo_list = TODO_LIST_INIT;\n\tint res;\n\n\tif (read_and_refresh_cache(opts))\n\t\treturn -1;\n\n\tif (!file_exists(get_todo_path(opts)))\n\t\treturn continue_single_pick();\n\tif (read_populate_opts(opts))\n\t\treturn -1;\n\tif ((res = read_populate_todo(&todo_list, opts)))\n\t\tgoto release_todo_list;\n\n\t/* Verify that the conflict has been resolved */\n\tif (file_exists(git_path_cherry_pick_head()) ||\n\t    file_exists(git_path_revert_head())) {\n\t\tres = continue_single_pick();\n\t\tif (res)\n\t\t\tgoto release_todo_list;\n\t}\n\tif (index_differs_from(\"HEAD\", 0)) {\n\t\tres = error_dirty_index(opts);\n\t\tgoto release_todo_list;\n\t}\n\ttodo_list.current++;\n\tres = pick_commits(&todo_list, opts);\nrelease_todo_list:\n\ttodo_list_release(&todo_list);\n\treturn res;\n}\n\nstatic int single_pick(struct commit *cmit, struct replay_opts *opts)\n{\n\tsetenv(GIT_REFLOG_ACTION, action_name(opts), 0);\n\treturn do_pick_commit(opts->action == REPLAY_PICK ?\n\t\tTODO_PICK : TODO_REVERT, cmit, opts);\n}\n\nint sequencer_pick_revisions(struct replay_opts *opts)\n{\n\tstruct todo_list todo_list = TODO_LIST_INIT;\n\tunsigned char sha1[20];\n\tint i, res;\n\n\tassert(opts->revs);\n\tif (read_and_refresh_cache(opts))\n\t\treturn -1;\n\n\tfor (i = 0; i < opts->revs->pending.nr; i++) {\n\t\tunsigned char sha1[20];\n\t\tconst char *name = opts->revs->pending.objects[i].name;\n\n\t\t/* This happens when using --stdin. */\n\t\tif (!strlen(name))\n\t\t\tcontinue;\n\n\t\tif (!get_sha1(name, sha1)) {\n\t\t\tif (!lookup_commit_reference_gently(sha1, 1)) {\n\t\t\t\tenum object_type type = sha1_object_info(sha1, NULL);\n\t\t\t\treturn error(_(\"%s: can't cherry-pick a %s\"),\n\t\t\t\t\tname, typename(type));\n\t\t\t}\n\t\t} else\n\t\t\treturn error(_(\"%s: bad revision\"), name);\n\t}\n\n\t/*\n\t * If we were called as \"git cherry-pick <commit>\", just\n\t * cherry-pick/revert it, set CHERRY_PICK_HEAD /\n\t * REVERT_HEAD, and don't touch the sequencer state.\n\t * This means it is possible to cherry-pick in the middle\n\t * of a cherry-pick sequence.\n\t */\n\tif (opts->revs->cmdline.nr == 1 &&\n\t    opts->revs->cmdline.rev->whence == REV_CMD_REV &&\n\t    opts->revs->no_walk &&\n\t    !opts->revs->cmdline.rev->flags) {\n\t\tstruct commit *cmit;\n\t\tif (prepare_revision_walk(opts->revs))\n\t\t\treturn error(_(\"revision walk setup failed\"));\n\t\tcmit = get_revision(opts->revs);\n\t\tif (!cmit || get_revision(opts->revs))\n\t\t\treturn error(\"BUG: expected exactly one commit from walk\");\n\t\treturn single_pick(cmit, opts);\n\t}\n\n\t/*\n\t * Start a new cherry-pick/ revert sequence; but\n\t * first, make sure that an existing one isn't in\n\t * progress\n\t */\n\n\tif (walk_revs_populate_todo(&todo_list, opts) ||\n\t\t\tcreate_seq_dir() < 0)\n\t\treturn -1;\n\tif (get_sha1(\"HEAD\", sha1) && (opts->action == REPLAY_REVERT))\n\t\treturn error(_(\"Can't revert as initial commit\"));\n\tif (save_head(sha1_to_hex(sha1)))\n\t\treturn -1;\n\tif (save_opts(opts))\n\t\treturn -1;\n\tres = pick_commits(&todo_list, opts);\n\ttodo_list_release(&todo_list);\n\treturn res;\n}\n\nvoid append_signoff(struct strbuf *msgbuf, int ignore_footer, unsigned flag)\n{\n\tunsigned no_dup_sob = flag & APPEND_SIGNOFF_DEDUP;\n\tstruct strbuf sob = STRBUF_INIT;\n\tint has_footer;\n\n\tstrbuf_addstr(&sob, sign_off_header);\n\tstrbuf_addstr(&sob, fmt_name(getenv(\"GIT_COMMITTER_NAME\"),\n\t\t\t\tgetenv(\"GIT_COMMITTER_EMAIL\")));\n\tstrbuf_addch(&sob, '\\n');\n\n\t/*\n\t * If the whole message buffer is equal to the sob, pretend that we\n\t * found a conforming footer with a matching sob\n\t */\n\tif (msgbuf->len - ignore_footer == sob.len &&\n\t    !strncmp(msgbuf->buf, sob.buf, sob.len))\n\t\thas_footer = 3;\n\telse\n\t\thas_footer = has_conforming_footer(msgbuf, &sob, ignore_footer);\n\n\tif (!has_footer) {\n\t\tconst char *append_newlines = NULL;\n\t\tsize_t len = msgbuf->len - ignore_footer;\n\n\t\tif (!len) {\n\t\t\t/*\n\t\t\t * The buffer is completely empty.  Leave foom for\n\t\t\t * the title and body to be filled in by the user.\n\t\t\t */\n\t\t\tappend_newlines = \"\\n\\n\";\n\t\t} else if (msgbuf->buf[len - 1] != '\\n') {\n\t\t\t/*\n\t\t\t * Incomplete line.  Complete the line and add a\n\t\t\t * blank one so that there is an empty line between\n\t\t\t * the message body and the sob.\n\t\t\t */\n\t\t\tappend_newlines = \"\\n\\n\";\n\t\t} else if (len == 1) {\n\t\t\t/*\n\t\t\t * Buffer contains a single newline.  Add another\n\t\t\t * so that we leave room for the title and body.\n\t\t\t */\n\t\t\tappend_newlines = \"\\n\";\n\t\t} else if (msgbuf->buf[len - 2] != '\\n') {\n\t\t\t/*\n\t\t\t * Buffer ends with a single newline.  Add another\n\t\t\t * so that there is an empty line between the message\n\t\t\t * body and the sob.\n\t\t\t */\n\t\t\tappend_newlines = \"\\n\";\n\t\t} /* else, the buffer already ends with two newlines. */\n\n\t\tif (append_newlines)\n\t\t\tstrbuf_splice(msgbuf, msgbuf->len - ignore_footer, 0,\n\t\t\t\tappend_newlines, strlen(append_newlines));\n\t}\n\n\tif (has_footer != 3 && (!no_dup_sob || has_footer != 2))\n\t\tstrbuf_splice(msgbuf, msgbuf->len - ignore_footer, 0,\n\t\t\t\tsob.buf, sob.len);\n\n\tstrbuf_release(&sob);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "000ce3e5418d51e19cdf381639b896a80902fc56",
  "sha1_ok": true,
  "size": 39636
}
