{
  "content": {
    "base64": "I2lmbmRlZiBHSVRfQ09NUEFUX1VUSUxfSAojZGVmaW5lIEdJVF9DT01QQVRfVVRJTF9ICgojZGVmaW5lIF9GSUxFX09GRlNFVF9CSVRTIDY0CgojaWZuZGVmIEZMRVhfQVJSQVkKLyoKICogU2VlIGlmIG91ciBjb21waWxlciBpcyBrbm93biB0byBzdXBwb3J0IGZsZXhpYmxlIGFycmF5IG1lbWJlcnMuCiAqLwojaWYgZGVmaW5lZChfX1NURENfVkVSU0lPTl9fKSAmJiAoX19TVERDX1ZFUlNJT05fXyA+PSAxOTk5MDFMKSAmJiAoIWRlZmluZWQoX19TVU5QUk9fQykgfHwgKF9fU1VOUFJPX0MgPiAweDU4MCkpCiMgZGVmaW5lIEZMRVhfQVJSQVkgLyogZW1wdHkgKi8KI2VsaWYgZGVmaW5lZChfX0dOVUNfXykKIyBpZiAoX19HTlVDX18gPj0gMykKIyAgZGVmaW5lIEZMRVhfQVJSQVkgLyogZW1wdHkgKi8KIyBlbHNlCiMgIGRlZmluZSBGTEVYX0FSUkFZIDAgLyogb2xkZXIgR05VIGV4dGVuc2lvbiAqLwojIGVuZGlmCiNlbmRpZgoKLyoKICogT3RoZXJ3aXNlLCBkZWZhdWx0IHRvIHNhZmVyIGJ1dCBhIGJpdCB3YXN0ZWZ1bCB0cmFkaXRpb25hbCBzdHlsZQogKi8KI2lmbmRlZiBGTEVYX0FSUkFZCiMgZGVmaW5lIEZMRVhfQVJSQVkgMQojZW5kaWYKI2VuZGlmCgojZGVmaW5lIEFSUkFZX1NJWkUoeCkgKHNpemVvZih4KS9zaXplb2YoeFswXSkpCiNkZWZpbmUgYml0c2l6ZW9mKHgpICAoQ0hBUl9CSVQgKiBzaXplb2YoeCkpCgojaWZkZWYgX19HTlVDX18KI2RlZmluZSBUWVBFT0YoeCkgKF9fdHlwZW9mX18oeCkpCiNlbHNlCiNkZWZpbmUgVFlQRU9GKHgpCiNlbmRpZgoKI2RlZmluZSBNU0IoeCwgYml0cykgKCh4KSAmIFRZUEVPRih4KSh+MFVMTCA8PCAoYml0c2l6ZW9mKHgpIC0gKGJpdHMpKSkpCiNkZWZpbmUgSEFTX01VTFRJX0JJVFMoaSkgICgoaSkgJiAoKGkpIC0gMSkpICAvKiBjaGVja3MgaWYgYW4gaW50ZWdlciBoYXMgbW9yZSB0aGFuIDEgYml0IHNldCAqLwoKI2RlZmluZSBESVZfUk9VTkRfVVAobixkKSAoKChuKSArIChkKSAtIDEpIC8gKGQpKQoKLyogQXBwcm94aW1hdGlvbiBvZiB0aGUgbGVuZ3RoIG9mIHRoZSBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS4gKi8KI2RlZmluZSBkZWNpbWFsX2xlbmd0aCh4KQkoKGludCkoc2l6ZW9mKHgpICogMi41NiArIDAuNSkgKyAxKQoKI2lmIGRlZmluZWQoX19zdW5fXykKIC8qCiAgKiBPbiBTb2xhcmlzLCB3aGVuIF9YT1BFTl9FWFRFTkRFRCBpcyBzZXQsIGl0cyBoZWFkZXIgZmlsZQogICogZm9yY2VzIHRoZSBwcm9ncmFtcyB0byBiZSBYUEc0djIsIGRlZmVhdGluZyBhbnkgX1hPUEVOX1NPVVJDRQogICogc2V0dGluZyB0byBzYXkgd2UgYXJlIFhQRzUgb3IgWFBHNi4gIEFsc28gb24gU29sYXJpcywKICAqIFhQRzYgcHJvZ3JhbXMgbXVzdCBiZSBjb21waWxlZCB3aXRoIGEgYzk5IGNvbXBpbGVyLCB3aGlsZQogICogbm9uIFhQRzYgcHJvZ3JhbXMgbXVzdCBiZSBjb21waWxlZCB3aXRoIGEgcHJlLWM5OSBjb21waWxlci4KICAqLwojIGlmIF9fU1REQ19WRVJTSU9OX18gLSAwID49IDE5OTkwMUwKIyBkZWZpbmUgX1hPUEVOX1NPVVJDRSA2MDAKIyBlbHNlCiMgZGVmaW5lIF9YT1BFTl9TT1VSQ0UgNTAwCiMgZW5kaWYKI2VsaWYgIWRlZmluZWQoX19BUFBMRV9fKSAmJiAhZGVmaW5lZChfX0ZyZWVCU0RfXykgJiYgIWRlZmluZWQoX19VU0xDX18pICYmIFwKICAgICAgIWRlZmluZWQoX01fVU5JWCkgJiYgIWRlZmluZWQoc2dpKSAmJiAhZGVmaW5lZChfX0RyYWdvbkZseV9fKQojZGVmaW5lIF9YT1BFTl9TT1VSQ0UgNjAwIC8qIGdsaWJjMiBhbmQgQUlYIDUuM0wgbmVlZCA1MDAsIE9wZW5CU0QgbmVlZHMgNjAwIGZvciBTX0lTTE5LKCkgKi8KI2RlZmluZSBfWE9QRU5fU09VUkNFX0VYVEVOREVEIDEgLyogQUlYIDUuM0wgbmVlZHMgdGhpcyAqLwojZW5kaWYKI2RlZmluZSBfQUxMX1NPVVJDRSAxCiNkZWZpbmUgX0dOVV9TT1VSQ0UgMQojZGVmaW5lIF9CU0RfU09VUkNFIDEKI2RlZmluZSBfTkVUQlNEX1NPVVJDRSAxCiNkZWZpbmUgX1NHSV9TT1VSQ0UgMQoKI2lmZGVmIFdJTjMyIC8qIEJvdGggTWluR1cgYW5kIE1TVkMgKi8KI2RlZmluZSBXSU4zMl9MRUFOX0FORF9NRUFOICAvKiBzdG9wcyB3aW5kb3dzLmggaW5jbHVkaW5nIHdpbnNvY2suaCAqLwojaW5jbHVkZSA8d2luc29jazIuaD4KI2luY2x1ZGUgPHdpbmRvd3MuaD4KI2VuZGlmCgojaW5jbHVkZSA8dW5pc3RkLmg+CiNpbmNsdWRlIDxzdGRpby5oPgojaW5jbHVkZSA8c3lzL3N0YXQuaD4KI2luY2x1ZGUgPGZjbnRsLmg+CiNpbmNsdWRlIDxzdGRkZWYuaD4KI2luY2x1ZGUgPHN0ZGxpYi5oPgojaW5jbHVkZSA8c3RkYXJnLmg+CiNpbmNsdWRlIDxzdHJpbmcuaD4KI2luY2x1ZGUgPGVycm5vLmg+CiNpbmNsdWRlIDxsaW1pdHMuaD4KI2luY2x1ZGUgPHN5cy9wYXJhbS5oPgojaW5jbHVkZSA8c3lzL3R5cGVzLmg+CiNpbmNsdWRlIDxkaXJlbnQuaD4KI2luY2x1ZGUgPHN5cy90aW1lLmg+CiNpbmNsdWRlIDx0aW1lLmg+CiNpbmNsdWRlIDxzaWduYWwuaD4KI2luY2x1ZGUgPGZubWF0Y2guaD4KI2luY2x1ZGUgPGFzc2VydC5oPgojaW5jbHVkZSA8cmVnZXguaD4KI2luY2x1ZGUgPHV0aW1lLmg+CiNpZm5kZWYgX19NSU5HVzMyX18KI2luY2x1ZGUgPHN5cy93YWl0Lmg+CiNpbmNsdWRlIDxzeXMvcG9sbC5oPgojaW5jbHVkZSA8c3lzL3NvY2tldC5oPgojaW5jbHVkZSA8c3lzL2lvY3RsLmg+CiNpbmNsdWRlIDx0ZXJtaW9zLmg+CiNpZm5kZWYgTk9fU1lTX1NFTEVDVF9ICiNpbmNsdWRlIDxzeXMvc2VsZWN0Lmg+CiNlbmRpZgojaW5jbHVkZSA8bmV0aW5ldC9pbi5oPgojaW5jbHVkZSA8bmV0aW5ldC90Y3AuaD4KI2luY2x1ZGUgPGFycGEvaW5ldC5oPgojaW5jbHVkZSA8bmV0ZGIuaD4KI2luY2x1ZGUgPHB3ZC5oPgojaW5jbHVkZSA8aW50dHlwZXMuaD4KI2lmIGRlZmluZWQoX19DWUdXSU5fXykKI3VuZGVmIF9YT1BFTl9TT1VSQ0UKI2luY2x1ZGUgPGdycC5oPgojZGVmaW5lIF9YT1BFTl9TT1VSQ0UgNjAwCiNpbmNsdWRlICJjb21wYXQvY3lnd2luLmgiCiNlbHNlCiN1bmRlZiBfQUxMX1NPVVJDRSAvKiBBSVggNS4zTCBkZWZpbmVzIGEgc3RydWN0IGxpc3Qgd2l0aCBfQUxMX1NPVVJDRS4gKi8KI2luY2x1ZGUgPGdycC5oPgojZGVmaW5lIF9BTExfU09VUkNFIDEKI2VuZGlmCiNlbHNlIAkvKiBfX01JTkdXMzJfXyAqLwovKiBwdWxsIGluIFdpbmRvd3MgY29tcGF0aWJpbGl0eSBzdHVmZiAqLwojaW5jbHVkZSAiY29tcGF0L21pbmd3LmgiCiNlbmRpZgkvKiBfX01JTkdXMzJfXyAqLwojaWZkZWYgX01TQ19WRVIKI2luY2x1ZGUgImNvbXBhdC9tc3ZjLmgiCiNlbmRpZgoKI2lmbmRlZiBOT19MSUJHRU5fSAojaW5jbHVkZSA8bGliZ2VuLmg+CiNlbHNlCiNkZWZpbmUgYmFzZW5hbWUgZ2l0YmFzZW5hbWUKZXh0ZXJuIGNoYXIgKmdpdGJhc2VuYW1lKGNoYXIgKik7CiNlbmRpZgoKI2lmbmRlZiBOT19JQ09OVgojaW5jbHVkZSA8aWNvbnYuaD4KI2VuZGlmCgojaWZuZGVmIE5PX09QRU5TU0wKI2luY2x1ZGUgPG9wZW5zc2wvc3NsLmg+CiNpbmNsdWRlIDxvcGVuc3NsL2Vyci5oPgojZW5kaWYKCi8qIE9uIG1vc3Qgc3lzdGVtcyA8bGltaXRzLmg+IHdvdWxkIGhhdmUgZ2l2ZW4gdXMgdGhpcywgYnV0CiAqIG5vdCBvbiBzb21lIHN5c3RlbXMgKGUuZy4gR05VL0h1cmQpLgogKi8KI2lmbmRlZiBQQVRIX01BWAojZGVmaW5lIFBBVEhfTUFYIDQwOTYKI2VuZGlmCgojaWZuZGVmIFBSSXVNQVgKI2RlZmluZSBQUkl1TUFYICJsbHUiCiNlbmRpZgoKI2lmbmRlZiBQUkl1MzIKI2RlZmluZSBQUkl1MzIgInUiCiNlbmRpZgoKI2lmbmRlZiBQUkl4MzIKI2RlZmluZSBQUkl4MzIgIngiCiNlbmRpZgoKI2lmbmRlZiBQQVRIX1NFUAojZGVmaW5lIFBBVEhfU0VQICc6JwojZW5kaWYKCiNpZm5kZWYgU1RSSVBfRVhURU5TSU9OCiNkZWZpbmUgU1RSSVBfRVhURU5TSU9OICIiCiNlbmRpZgoKI2lmbmRlZiBoYXNfZG9zX2RyaXZlX3ByZWZpeAojZGVmaW5lIGhhc19kb3NfZHJpdmVfcHJlZml4KHBhdGgpIDAKI2VuZGlmCgojaWZuZGVmIGlzX2Rpcl9zZXAKI2RlZmluZSBpc19kaXJfc2VwKGMpICgoYykgPT0gJy8nKQojZW5kaWYKCiNpZmRlZiBfX0dOVUNfXwojZGVmaW5lIE5PUkVUVVJOIF9fYXR0cmlidXRlX18oKF9fbm9yZXR1cm5fXykpCiNkZWZpbmUgTk9SRVRVUk5fUFRSIF9fYXR0cmlidXRlX18oKF9fbm9yZXR1cm5fXykpCiNlbGlmIGRlZmluZWQoX01TQ19WRVIpCiNkZWZpbmUgTk9SRVRVUk4gX19kZWNsc3BlYyhub3JldHVybikKI2RlZmluZSBOT1JFVFVSTl9QVFIKI2Vsc2UKI2RlZmluZSBOT1JFVFVSTgojZGVmaW5lIE5PUkVUVVJOX1BUUgojaWZuZGVmIF9fYXR0cmlidXRlX18KI2RlZmluZSBfX2F0dHJpYnV0ZV9fKHgpCiNlbmRpZgojZW5kaWYKCiNpbmNsdWRlICJjb21wYXQvYnN3YXAuaCIKCi8qIEdlbmVyYWwgaGVscGVyIGZ1bmN0aW9ucyAqLwpleHRlcm4gTk9SRVRVUk4gdm9pZCB1c2FnZShjb25zdCBjaGFyICplcnIpOwpleHRlcm4gTk9SRVRVUk4gdm9pZCB1c2FnZWYoY29uc3QgY2hhciAqZXJyLCAuLi4pIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwpleHRlcm4gTk9SRVRVUk4gdm9pZCBkaWUoY29uc3QgY2hhciAqZXJyLCAuLi4pIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwpleHRlcm4gTk9SRVRVUk4gdm9pZCBkaWVfZXJybm8oY29uc3QgY2hhciAqZXJyLCAuLi4pIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwpleHRlcm4gaW50IGVycm9yKGNvbnN0IGNoYXIgKmVyciwgLi4uKSBfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMSwgMikpKTsKZXh0ZXJuIHZvaWQgd2FybmluZyhjb25zdCBjaGFyICplcnIsIC4uLikgX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsIDEsIDIpKSk7CgpleHRlcm4gdm9pZCBzZXRfZGllX3JvdXRpbmUoTk9SRVRVUk5fUFRSIHZvaWQgKCpyb3V0aW5lKShjb25zdCBjaGFyICplcnIsIHZhX2xpc3QgcGFyYW1zKSk7CgpleHRlcm4gaW50IHByZWZpeGNtcChjb25zdCBjaGFyICpzdHIsIGNvbnN0IGNoYXIgKnByZWZpeCk7CmV4dGVybiBpbnQgc3VmZml4Y21wKGNvbnN0IGNoYXIgKnN0ciwgY29uc3QgY2hhciAqc3VmZml4KTsKCnN0YXRpYyBpbmxpbmUgY29uc3QgY2hhciAqc2tpcF9wcmVmaXgoY29uc3QgY2hhciAqc3RyLCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXNpemVfdCBsZW4gPSBzdHJsZW4ocHJlZml4KTsKCXJldHVybiBzdHJuY21wKHN0ciwgcHJlZml4LCBsZW4pID8gTlVMTCA6IHN0ciArIGxlbjsKfQoKI2lmIGRlZmluZWQoTk9fTU1BUCkgfHwgZGVmaW5lZChVU0VfV0lOMzJfTU1BUCkKCiNpZm5kZWYgUFJPVF9SRUFECiNkZWZpbmUgUFJPVF9SRUFEIDEKI2RlZmluZSBQUk9UX1dSSVRFIDIKI2RlZmluZSBNQVBfUFJJVkFURSAxCiNkZWZpbmUgTUFQX0ZBSUxFRCAoKHZvaWQqKS0xKQojZW5kaWYKCiNkZWZpbmUgbW1hcCBnaXRfbW1hcAojZGVmaW5lIG11bm1hcCBnaXRfbXVubWFwCmV4dGVybiB2b2lkICpnaXRfbW1hcCh2b2lkICpzdGFydCwgc2l6ZV90IGxlbmd0aCwgaW50IHByb3QsIGludCBmbGFncywgaW50IGZkLCBvZmZfdCBvZmZzZXQpOwpleHRlcm4gaW50IGdpdF9tdW5tYXAodm9pZCAqc3RhcnQsIHNpemVfdCBsZW5ndGgpOwoKI2Vsc2UgLyogTk9fTU1BUCB8fCBVU0VfV0lOMzJfTU1BUCAqLwoKI2luY2x1ZGUgPHN5cy9tbWFuLmg+CgojZW5kaWYgLyogTk9fTU1BUCB8fCBVU0VfV0lOMzJfTU1BUCAqLwoKI2lmZGVmIE5PX01NQVAKCi8qIFRoaXMgdmFsdWUgbXVzdCBiZSBtdWx0aXBsZSBvZiAocGFnZXNpemUgKiAyKSAqLwojZGVmaW5lIERFRkFVTFRfUEFDS0VEX0dJVF9XSU5ET1dfU0laRSAoMSAqIDEwMjQgKiAxMDI0KQoKI2Vsc2UgLyogTk9fTU1BUCAqLwoKLyogVGhpcyB2YWx1ZSBtdXN0IGJlIG11bHRpcGxlIG9mIChwYWdlc2l6ZSAqIDIpICovCiNkZWZpbmUgREVGQVVMVF9QQUNLRURfR0lUX1dJTkRPV19TSVpFIFwKCShzaXplb2Yodm9pZCopID49IDggXAoJCT8gIDEgKiAxMDI0ICogMTAyNCAqIDEwMjQgXAoJCTogMzIgKiAxMDI0ICogMTAyNCkKCiNlbmRpZiAvKiBOT19NTUFQICovCgojaWZkZWYgTk9fU1RfQkxPQ0tTX0lOX1NUUlVDVF9TVEFUCiNkZWZpbmUgb25fZGlza19ieXRlcyhzdCkgKChzdCkuc3Rfc2l6ZSkKI2Vsc2UKI2RlZmluZSBvbl9kaXNrX2J5dGVzKHN0KSAoKHN0KS5zdF9ibG9ja3MgKiA1MTIpCiNlbmRpZgoKI2RlZmluZSBERUZBVUxUX1BBQ0tFRF9HSVRfTElNSVQgXAoJKCgxMDI0TCAqIDEwMjRMKSAqIChzaXplb2Yodm9pZCopID49IDggPyA4MTkyIDogMjU2KSkKCiNpZmRlZiBOT19QUkVBRAojZGVmaW5lIHByZWFkIGdpdF9wcmVhZApleHRlcm4gc3NpemVfdCBnaXRfcHJlYWQoaW50IGZkLCB2b2lkICpidWYsIHNpemVfdCBjb3VudCwgb2ZmX3Qgb2Zmc2V0KTsKI2VuZGlmCi8qCiAqIEZvcndhcmQgZGVjbCB0aGF0IHdpbGwgcmVtaW5kIHVzIGlmIGl0cyB0d2luIGluIGNhY2hlLmggY2hhbmdlcy4KICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGluIGNvbXBhdC9wcmVhZC5jLiAgQnV0IHdlIGNhbid0IGluY2x1ZGUKICogY2FjaGUuaCB0aGVyZS4KICovCmV4dGVybiBzc2l6ZV90IHJlYWRfaW5fZnVsbChpbnQgZmQsIHZvaWQgKmJ1Ziwgc2l6ZV90IGNvdW50KTsKCiNpZmRlZiBOT19TRVRFTlYKI2RlZmluZSBzZXRlbnYgZ2l0c2V0ZW52CmV4dGVybiBpbnQgZ2l0c2V0ZW52KGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqLCBpbnQpOwojZW5kaWYKCiNpZmRlZiBOT19NS0RURU1QCiNkZWZpbmUgbWtkdGVtcCBnaXRta2R0ZW1wCmV4dGVybiBjaGFyICpnaXRta2R0ZW1wKGNoYXIgKik7CiNlbmRpZgoKI2lmZGVmIE5PX01LU1RFTVBTCiNkZWZpbmUgbWtzdGVtcHMgZ2l0bWtzdGVtcHMKZXh0ZXJuIGludCBnaXRta3N0ZW1wcyhjaGFyICosIGludCk7CiNlbmRpZgoKI2lmZGVmIE5PX1VOU0VURU5WCiNkZWZpbmUgdW5zZXRlbnYgZ2l0dW5zZXRlbnYKZXh0ZXJuIHZvaWQgZ2l0dW5zZXRlbnYoY29uc3QgY2hhciAqKTsKI2VuZGlmCgojaWZkZWYgTk9fU1RSQ0FTRVNUUgojZGVmaW5lIHN0cmNhc2VzdHIgZ2l0c3RyY2FzZXN0cgpleHRlcm4gY2hhciAqZ2l0c3RyY2FzZXN0cihjb25zdCBjaGFyICpoYXlzdGFjaywgY29uc3QgY2hhciAqbmVlZGxlKTsKI2VuZGlmCgojaWZkZWYgTk9fU1RSTENQWQojZGVmaW5lIHN0cmxjcHkgZ2l0c3RybGNweQpleHRlcm4gc2l6ZV90IGdpdHN0cmxjcHkoY2hhciAqLCBjb25zdCBjaGFyICosIHNpemVfdCk7CiNlbmRpZgoKI2lmZGVmIE5PX1NUUlRPVU1BWAojZGVmaW5lIHN0cnRvdW1heCBnaXRzdHJ0b3VtYXgKZXh0ZXJuIHVpbnRtYXhfdCBnaXRzdHJ0b3VtYXgoY29uc3QgY2hhciAqLCBjaGFyICoqLCBpbnQpOwojZW5kaWYKCiNpZmRlZiBOT19IU1RSRVJST1IKI2RlZmluZSBoc3RyZXJyb3IgZ2l0aHN0cmVycm9yCmV4dGVybiBjb25zdCBjaGFyICpnaXRoc3RyZXJyb3IoaW50IGhlcnJvcik7CiNlbmRpZgoKI2lmZGVmIE5PX01FTU1FTQojZGVmaW5lIG1lbW1lbSBnaXRtZW1tZW0Kdm9pZCAqZ2l0bWVtbWVtKGNvbnN0IHZvaWQgKmhheXN0YWNrLCBzaXplX3QgaGF5c3RhY2tsZW4sCiAgICAgICAgICAgICAgICBjb25zdCB2b2lkICpuZWVkbGUsIHNpemVfdCBuZWVkbGVsZW4pOwojZW5kaWYKCiNpZmRlZiBGUkVBRF9SRUFEU19ESVJFQ1RPUklFUwojaWZkZWYgZm9wZW4KI3VuZGVmIGZvcGVuCiNlbmRpZgojZGVmaW5lIGZvcGVuKGEsYikgZ2l0X2ZvcGVuKGEsYikKZXh0ZXJuIEZJTEUgKmdpdF9mb3Blbihjb25zdCBjaGFyKiwgY29uc3QgY2hhciopOwojZW5kaWYKCiNpZmRlZiBTTlBSSU5URl9SRVRVUk5TX0JPR1VTCiNkZWZpbmUgc25wcmludGYgZ2l0X3NucHJpbnRmCmV4dGVybiBpbnQgZ2l0X3NucHJpbnRmKGNoYXIgKnN0ciwgc2l6ZV90IG1heHNpemUsCgkJCWNvbnN0IGNoYXIgKmZvcm1hdCwgLi4uKTsKI2RlZmluZSB2c25wcmludGYgZ2l0X3ZzbnByaW50ZgpleHRlcm4gaW50IGdpdF92c25wcmludGYoY2hhciAqc3RyLCBzaXplX3QgbWF4c2l6ZSwKCQkJIGNvbnN0IGNoYXIgKmZvcm1hdCwgdmFfbGlzdCBhcCk7CiNlbmRpZgoKI2lmZGVmIF9fR0xJQkNfUFJFUkVRCiNpZiBfX0dMSUJDX1BSRVJFUSgyLCAxKQojZGVmaW5lIEhBVkVfU1RSQ0hSTlVMCiNkZWZpbmUgSEFWRV9NRU1QQ1BZCiNlbmRpZgojZW5kaWYKCiNpZm5kZWYgSEFWRV9TVFJDSFJOVUwKI2RlZmluZSBzdHJjaHJudWwgZ2l0c3RyY2hybnVsCnN0YXRpYyBpbmxpbmUgY2hhciAqZ2l0c3RyY2hybnVsKGNvbnN0IGNoYXIgKnMsIGludCBjKQp7Cgl3aGlsZSAoKnMgJiYgKnMgIT0gYykKCQlzKys7CglyZXR1cm4gKGNoYXIgKilzOwp9CiNlbmRpZgoKI2lmbmRlZiBIQVZFX01FTVBDUFkKI2RlZmluZSBtZW1wY3B5IGdpdG1lbXBjcHkKc3RhdGljIGlubGluZSB2b2lkICpnaXRtZW1wY3B5KHZvaWQgKmRlc3QsIGNvbnN0IHZvaWQgKnNyYywgc2l6ZV90IG4pCnsKCXJldHVybiAoY2hhciAqKW1lbWNweShkZXN0LCBzcmMsIG4pICsgbjsKfQojZW5kaWYKCmV4dGVybiB2b2lkIHJlbGVhc2VfcGFja19tZW1vcnkoc2l6ZV90LCBpbnQpOwoKZXh0ZXJuIHZvaWQgc2V0X3RyeV90b19mcmVlX3JvdXRpbmUodm9pZCAoKnJvdXRpbmUpKHNpemVfdCkpOwoKZXh0ZXJuIGNoYXIgKnhzdHJkdXAoY29uc3QgY2hhciAqc3RyKTsKZXh0ZXJuIHZvaWQgKnhtYWxsb2Moc2l6ZV90IHNpemUpOwpleHRlcm4gdm9pZCAqeG1hbGxvY3ooc2l6ZV90IHNpemUpOwpleHRlcm4gdm9pZCAqeG1lbWR1cHooY29uc3Qgdm9pZCAqZGF0YSwgc2l6ZV90IGxlbik7CmV4dGVybiBjaGFyICp4c3RybmR1cChjb25zdCBjaGFyICpzdHIsIHNpemVfdCBsZW4pOwpleHRlcm4gdm9pZCAqeHJlYWxsb2Modm9pZCAqcHRyLCBzaXplX3Qgc2l6ZSk7CmV4dGVybiB2b2lkICp4Y2FsbG9jKHNpemVfdCBubWVtYiwgc2l6ZV90IHNpemUpOwpleHRlcm4gdm9pZCAqeG1tYXAodm9pZCAqc3RhcnQsIHNpemVfdCBsZW5ndGgsIGludCBwcm90LCBpbnQgZmxhZ3MsIGludCBmZCwgb2ZmX3Qgb2Zmc2V0KTsKZXh0ZXJuIHNzaXplX3QgeHJlYWQoaW50IGZkLCB2b2lkICpidWYsIHNpemVfdCBsZW4pOwpleHRlcm4gc3NpemVfdCB4d3JpdGUoaW50IGZkLCBjb25zdCB2b2lkICpidWYsIHNpemVfdCBsZW4pOwpleHRlcm4gaW50IHhkdXAoaW50IGZkKTsKZXh0ZXJuIEZJTEUgKnhmZG9wZW4oaW50IGZkLCBjb25zdCBjaGFyICptb2RlKTsKZXh0ZXJuIGludCB4bWtzdGVtcChjaGFyICp0ZW1wbGF0ZSk7CmV4dGVybiBpbnQgb2RiX21rc3RlbXAoY2hhciAqdGVtcGxhdGUsIHNpemVfdCBsaW1pdCwgY29uc3QgY2hhciAqcGF0dGVybik7CmV4dGVybiBpbnQgb2RiX3BhY2tfa2VlcChjaGFyICpuYW1lLCBzaXplX3QgbmFtZXN6LCB1bnNpZ25lZCBjaGFyICpzaGExKTsKCnN0YXRpYyBpbmxpbmUgc2l6ZV90IHhzaXplX3Qob2ZmX3QgbGVuKQp7CglyZXR1cm4gKHNpemVfdClsZW47Cn0KCnN0YXRpYyBpbmxpbmUgaW50IGhhc19leHRlbnNpb24oY29uc3QgY2hhciAqZmlsZW5hbWUsIGNvbnN0IGNoYXIgKmV4dCkKewoJc2l6ZV90IGxlbiA9IHN0cmxlbihmaWxlbmFtZSk7CglzaXplX3QgZXh0bGVuID0gc3RybGVuKGV4dCk7CglyZXR1cm4gbGVuID4gZXh0bGVuICYmICFtZW1jbXAoZmlsZW5hbWUgKyBsZW4gLSBleHRsZW4sIGV4dCwgZXh0bGVuKTsKfQoKLyogU2FuZSBjdHlwZSAtIG5vIGxvY2FsZSwgYW5kIHdvcmtzIHdpdGggc2lnbmVkIGNoYXJzICovCiN1bmRlZiBpc2FzY2lpCiN1bmRlZiBpc3NwYWNlCiN1bmRlZiBpc2RpZ2l0CiN1bmRlZiBpc2FscGhhCiN1bmRlZiBpc2FsbnVtCiN1bmRlZiB0b2xvd2VyCiN1bmRlZiB0b3VwcGVyCmV4dGVybiB1bnNpZ25lZCBjaGFyIHNhbmVfY3R5cGVbMjU2XTsKI2RlZmluZSBHSVRfU1BBQ0UgMHgwMQojZGVmaW5lIEdJVF9ESUdJVCAweDAyCiNkZWZpbmUgR0lUX0FMUEhBIDB4MDQKI2RlZmluZSBHSVRfR0xPQl9TUEVDSUFMIDB4MDgKI2RlZmluZSBHSVRfUkVHRVhfU1BFQ0lBTCAweDEwCiNkZWZpbmUgc2FuZV9pc3Rlc3QoeCxtYXNrKSAoKHNhbmVfY3R5cGVbKHVuc2lnbmVkIGNoYXIpKHgpXSAmIChtYXNrKSkgIT0gMCkKI2RlZmluZSBpc2FzY2lpKHgpICgoKHgpICYgfjB4N2YpID09IDApCiNkZWZpbmUgaXNzcGFjZSh4KSBzYW5lX2lzdGVzdCh4LEdJVF9TUEFDRSkKI2RlZmluZSBpc2RpZ2l0KHgpIHNhbmVfaXN0ZXN0KHgsR0lUX0RJR0lUKQojZGVmaW5lIGlzYWxwaGEoeCkgc2FuZV9pc3Rlc3QoeCxHSVRfQUxQSEEpCiNkZWZpbmUgaXNhbG51bSh4KSBzYW5lX2lzdGVzdCh4LEdJVF9BTFBIQSB8IEdJVF9ESUdJVCkKI2RlZmluZSBpc19nbG9iX3NwZWNpYWwoeCkgc2FuZV9pc3Rlc3QoeCxHSVRfR0xPQl9TUEVDSUFMKQojZGVmaW5lIGlzX3JlZ2V4X3NwZWNpYWwoeCkgc2FuZV9pc3Rlc3QoeCxHSVRfR0xPQl9TUEVDSUFMIHwgR0lUX1JFR0VYX1NQRUNJQUwpCiNkZWZpbmUgdG9sb3dlcih4KSBzYW5lX2Nhc2UoKHVuc2lnbmVkIGNoYXIpKHgpLCAweDIwKQojZGVmaW5lIHRvdXBwZXIoeCkgc2FuZV9jYXNlKCh1bnNpZ25lZCBjaGFyKSh4KSwgMCkKCnN0YXRpYyBpbmxpbmUgaW50IHNhbmVfY2FzZShpbnQgeCwgaW50IGhpZ2gpCnsKCWlmIChzYW5lX2lzdGVzdCh4LCBHSVRfQUxQSEEpKQoJCXggPSAoeCAmIH4weDIwKSB8IGhpZ2g7CglyZXR1cm4geDsKfQoKc3RhdGljIGlubGluZSBpbnQgc3RydG91bF91aShjaGFyIGNvbnN0ICpzLCBpbnQgYmFzZSwgdW5zaWduZWQgaW50ICpyZXN1bHQpCnsKCXVuc2lnbmVkIGxvbmcgdWw7CgljaGFyICpwOwoKCWVycm5vID0gMDsKCXVsID0gc3RydG91bChzLCAmcCwgYmFzZSk7CglpZiAoZXJybm8gfHwgKnAgfHwgcCA9PSBzIHx8ICh1bnNpZ25lZCBpbnQpIHVsICE9IHVsKQoJCXJldHVybiAtMTsKCSpyZXN1bHQgPSB1bDsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW5saW5lIGludCBzdHJ0b2xfaShjaGFyIGNvbnN0ICpzLCBpbnQgYmFzZSwgaW50ICpyZXN1bHQpCnsKCWxvbmcgdWw7CgljaGFyICpwOwoKCWVycm5vID0gMDsKCXVsID0gc3RydG9sKHMsICZwLCBiYXNlKTsKCWlmIChlcnJubyB8fCAqcCB8fCBwID09IHMgfHwgKGludCkgdWwgIT0gdWwpCgkJcmV0dXJuIC0xOwoJKnJlc3VsdCA9IHVsOwoJcmV0dXJuIDA7Cn0KCiNpZmRlZiBJTlRFUk5BTF9RU09SVAp2b2lkIGdpdF9xc29ydCh2b2lkICpiYXNlLCBzaXplX3Qgbm1lbWIsIHNpemVfdCBzaXplLAoJICAgICAgIGludCgqY29tcGFyKShjb25zdCB2b2lkICosIGNvbnN0IHZvaWQgKikpOwojZGVmaW5lIHFzb3J0IGdpdF9xc29ydAojZW5kaWYKCiNpZm5kZWYgRElSX0hBU19CU0RfR1JPVVBfU0VNQU5USUNTCiMgZGVmaW5lIEZPUkNFX0RJUl9TRVRfR0lEIFNfSVNHSUQKI2Vsc2UKIyBkZWZpbmUgRk9SQ0VfRElSX1NFVF9HSUQgMAojZW5kaWYKCiNpZmRlZiBOT19OU0VDCiN1bmRlZiBVU0VfTlNFQwojZGVmaW5lIFNUX0NUSU1FX05TRUMoc3QpIDAKI2RlZmluZSBTVF9NVElNRV9OU0VDKHN0KSAwCiNlbHNlCiNpZmRlZiBVU0VfU1RfVElNRVNQRUMKI2RlZmluZSBTVF9DVElNRV9OU0VDKHN0KSAoKHVuc2lnbmVkIGludCkoKHN0KS5zdF9jdGltZXNwZWMudHZfbnNlYykpCiNkZWZpbmUgU1RfTVRJTUVfTlNFQyhzdCkgKCh1bnNpZ25lZCBpbnQpKChzdCkuc3RfbXRpbWVzcGVjLnR2X25zZWMpKQojZWxzZQojZGVmaW5lIFNUX0NUSU1FX05TRUMoc3QpICgodW5zaWduZWQgaW50KSgoc3QpLnN0X2N0aW0udHZfbnNlYykpCiNkZWZpbmUgU1RfTVRJTUVfTlNFQyhzdCkgKCh1bnNpZ25lZCBpbnQpKChzdCkuc3RfbXRpbS50dl9uc2VjKSkKI2VuZGlmCiNlbmRpZgoKI2lmZGVmIFVOUkVMSUFCTEVfRlNUQVQKI2RlZmluZSBmc3RhdF9pc19yZWxpYWJsZSgpIDAKI2Vsc2UKI2RlZmluZSBmc3RhdF9pc19yZWxpYWJsZSgpIDEKI2VuZGlmCgovKgogKiBQcmVzZXJ2ZXMgZXJybm8sIHByaW50cyBhIG1lc3NhZ2UsIGJ1dCBnaXZlcyBubyB3YXJuaW5nIGZvciBFTk9FTlQuCiAqIEFsd2F5cyByZXR1cm5zIHRoZSByZXR1cm4gdmFsdWUgb2YgdW5saW5rKDIpLgogKi8KaW50IHVubGlua19vcl93YXJuKGNvbnN0IGNoYXIgKnBhdGgpOwovKgogKiBMaWtld2lzZSBmb3Igcm1kaXIoMikuCiAqLwppbnQgcm1kaXJfb3Jfd2Fybihjb25zdCBjaGFyICpwYXRoKTsKLyoKICogQ2FsbHMgdGhlIGNvcnJlY3QgZnVuY3Rpb24gb3V0IG9mIHt1bmxpbmsscm1kaXJ9X29yX3dhcm4gYmFzZWQgb24KICogdGhlIHN1cHBsaWVkIGZpbGUgbW9kZS4KICovCmludCByZW1vdmVfb3Jfd2Fybih1bnNpZ25lZCBpbnQgbW9kZSwgY29uc3QgY2hhciAqcGF0aCk7CgojZW5kaWYK",
    "text": "#ifndef GIT_COMPAT_UTIL_H\n#define GIT_COMPAT_UTIL_H\n\n#define _FILE_OFFSET_BITS 64\n\n#ifndef FLEX_ARRAY\n/*\n * See if our compiler is known to support flexible array members.\n */\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && (!defined(__SUNPRO_C) || (__SUNPRO_C > 0x580))\n# define FLEX_ARRAY /* empty */\n#elif defined(__GNUC__)\n# if (__GNUC__ >= 3)\n#  define FLEX_ARRAY /* empty */\n# else\n#  define FLEX_ARRAY 0 /* older GNU extension */\n# endif\n#endif\n\n/*\n * Otherwise, default to safer but a bit wasteful traditional style\n */\n#ifndef FLEX_ARRAY\n# define FLEX_ARRAY 1\n#endif\n#endif\n\n#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))\n#define bitsizeof(x)  (CHAR_BIT * sizeof(x))\n\n#ifdef __GNUC__\n#define TYPEOF(x) (__typeof__(x))\n#else\n#define TYPEOF(x)\n#endif\n\n#define MSB(x, bits) ((x) & TYPEOF(x)(~0ULL << (bitsizeof(x) - (bits))))\n#define HAS_MULTI_BITS(i)  ((i) & ((i) - 1))  /* checks if an integer has more than 1 bit set */\n\n#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))\n\n/* Approximation of the length of the decimal representation of this type. */\n#define decimal_length(x)\t((int)(sizeof(x) * 2.56 + 0.5) + 1)\n\n#if defined(__sun__)\n /*\n  * On Solaris, when _XOPEN_EXTENDED is set, its header file\n  * forces the programs to be XPG4v2, defeating any _XOPEN_SOURCE\n  * setting to say we are XPG5 or XPG6.  Also on Solaris,\n  * XPG6 programs must be compiled with a c99 compiler, while\n  * non XPG6 programs must be compiled with a pre-c99 compiler.\n  */\n# if __STDC_VERSION__ - 0 >= 199901L\n# define _XOPEN_SOURCE 600\n# else\n# define _XOPEN_SOURCE 500\n# endif\n#elif !defined(__APPLE__) && !defined(__FreeBSD__) && !defined(__USLC__) && \\\n      !defined(_M_UNIX) && !defined(sgi) && !defined(__DragonFly__)\n#define _XOPEN_SOURCE 600 /* glibc2 and AIX 5.3L need 500, OpenBSD needs 600 for S_ISLNK() */\n#define _XOPEN_SOURCE_EXTENDED 1 /* AIX 5.3L needs this */\n#endif\n#define _ALL_SOURCE 1\n#define _GNU_SOURCE 1\n#define _BSD_SOURCE 1\n#define _NETBSD_SOURCE 1\n#define _SGI_SOURCE 1\n\n#ifdef WIN32 /* Both MinGW and MSVC */\n#define WIN32_LEAN_AND_MEAN  /* stops windows.h including winsock.h */\n#include <winsock2.h>\n#include <windows.h>\n#endif\n\n#include <unistd.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <limits.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <time.h>\n#include <signal.h>\n#include <fnmatch.h>\n#include <assert.h>\n#include <regex.h>\n#include <utime.h>\n#ifndef __MINGW32__\n#include <sys/wait.h>\n#include <sys/poll.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#ifndef NO_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <pwd.h>\n#include <inttypes.h>\n#if defined(__CYGWIN__)\n#undef _XOPEN_SOURCE\n#include <grp.h>\n#define _XOPEN_SOURCE 600\n#include \"compat/cygwin.h\"\n#else\n#undef _ALL_SOURCE /* AIX 5.3L defines a struct list with _ALL_SOURCE. */\n#include <grp.h>\n#define _ALL_SOURCE 1\n#endif\n#else \t/* __MINGW32__ */\n/* pull in Windows compatibility stuff */\n#include \"compat/mingw.h\"\n#endif\t/* __MINGW32__ */\n#ifdef _MSC_VER\n#include \"compat/msvc.h\"\n#endif\n\n#ifndef NO_LIBGEN_H\n#include <libgen.h>\n#else\n#define basename gitbasename\nextern char *gitbasename(char *);\n#endif\n\n#ifndef NO_ICONV\n#include <iconv.h>\n#endif\n\n#ifndef NO_OPENSSL\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#endif\n\n/* On most systems <limits.h> would have given us this, but\n * not on some systems (e.g. GNU/Hurd).\n */\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\n#ifndef PRIuMAX\n#define PRIuMAX \"llu\"\n#endif\n\n#ifndef PRIu32\n#define PRIu32 \"u\"\n#endif\n\n#ifndef PRIx32\n#define PRIx32 \"x\"\n#endif\n\n#ifndef PATH_SEP\n#define PATH_SEP ':'\n#endif\n\n#ifndef STRIP_EXTENSION\n#define STRIP_EXTENSION \"\"\n#endif\n\n#ifndef has_dos_drive_prefix\n#define has_dos_drive_prefix(path) 0\n#endif\n\n#ifndef is_dir_sep\n#define is_dir_sep(c) ((c) == '/')\n#endif\n\n#ifdef __GNUC__\n#define NORETURN __attribute__((__noreturn__))\n#define NORETURN_PTR __attribute__((__noreturn__))\n#elif defined(_MSC_VER)\n#define NORETURN __declspec(noreturn)\n#define NORETURN_PTR\n#else\n#define NORETURN\n#define NORETURN_PTR\n#ifndef __attribute__\n#define __attribute__(x)\n#endif\n#endif\n\n#include \"compat/bswap.h\"\n\n/* General helper functions */\nextern NORETURN void usage(const char *err);\nextern NORETURN void usagef(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern NORETURN void die(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern NORETURN void die_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern int error(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern void warning(const char *err, ...) __attribute__((format (printf, 1, 2)));\n\nextern void set_die_routine(NORETURN_PTR void (*routine)(const char *err, va_list params));\n\nextern int prefixcmp(const char *str, const char *prefix);\nextern int suffixcmp(const char *str, const char *suffix);\n\nstatic inline const char *skip_prefix(const char *str, const char *prefix)\n{\n\tsize_t len = strlen(prefix);\n\treturn strncmp(str, prefix, len) ? NULL : str + len;\n}\n\n#if defined(NO_MMAP) || defined(USE_WIN32_MMAP)\n\n#ifndef PROT_READ\n#define PROT_READ 1\n#define PROT_WRITE 2\n#define MAP_PRIVATE 1\n#define MAP_FAILED ((void*)-1)\n#endif\n\n#define mmap git_mmap\n#define munmap git_munmap\nextern void *git_mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nextern int git_munmap(void *start, size_t length);\n\n#else /* NO_MMAP || USE_WIN32_MMAP */\n\n#include <sys/mman.h>\n\n#endif /* NO_MMAP || USE_WIN32_MMAP */\n\n#ifdef NO_MMAP\n\n/* This value must be multiple of (pagesize * 2) */\n#define DEFAULT_PACKED_GIT_WINDOW_SIZE (1 * 1024 * 1024)\n\n#else /* NO_MMAP */\n\n/* This value must be multiple of (pagesize * 2) */\n#define DEFAULT_PACKED_GIT_WINDOW_SIZE \\\n\t(sizeof(void*) >= 8 \\\n\t\t?  1 * 1024 * 1024 * 1024 \\\n\t\t: 32 * 1024 * 1024)\n\n#endif /* NO_MMAP */\n\n#ifdef NO_ST_BLOCKS_IN_STRUCT_STAT\n#define on_disk_bytes(st) ((st).st_size)\n#else\n#define on_disk_bytes(st) ((st).st_blocks * 512)\n#endif\n\n#define DEFAULT_PACKED_GIT_LIMIT \\\n\t((1024L * 1024L) * (sizeof(void*) >= 8 ? 8192 : 256))\n\n#ifdef NO_PREAD\n#define pread git_pread\nextern ssize_t git_pread(int fd, void *buf, size_t count, off_t offset);\n#endif\n/*\n * Forward decl that will remind us if its twin in cache.h changes.\n * This function is used in compat/pread.c.  But we can't include\n * cache.h there.\n */\nextern ssize_t read_in_full(int fd, void *buf, size_t count);\n\n#ifdef NO_SETENV\n#define setenv gitsetenv\nextern int gitsetenv(const char *, const char *, int);\n#endif\n\n#ifdef NO_MKDTEMP\n#define mkdtemp gitmkdtemp\nextern char *gitmkdtemp(char *);\n#endif\n\n#ifdef NO_MKSTEMPS\n#define mkstemps gitmkstemps\nextern int gitmkstemps(char *, int);\n#endif\n\n#ifdef NO_UNSETENV\n#define unsetenv gitunsetenv\nextern void gitunsetenv(const char *);\n#endif\n\n#ifdef NO_STRCASESTR\n#define strcasestr gitstrcasestr\nextern char *gitstrcasestr(const char *haystack, const char *needle);\n#endif\n\n#ifdef NO_STRLCPY\n#define strlcpy gitstrlcpy\nextern size_t gitstrlcpy(char *, const char *, size_t);\n#endif\n\n#ifdef NO_STRTOUMAX\n#define strtoumax gitstrtoumax\nextern uintmax_t gitstrtoumax(const char *, char **, int);\n#endif\n\n#ifdef NO_HSTRERROR\n#define hstrerror githstrerror\nextern const char *githstrerror(int herror);\n#endif\n\n#ifdef NO_MEMMEM\n#define memmem gitmemmem\nvoid *gitmemmem(const void *haystack, size_t haystacklen,\n                const void *needle, size_t needlelen);\n#endif\n\n#ifdef FREAD_READS_DIRECTORIES\n#ifdef fopen\n#undef fopen\n#endif\n#define fopen(a,b) git_fopen(a,b)\nextern FILE *git_fopen(const char*, const char*);\n#endif\n\n#ifdef SNPRINTF_RETURNS_BOGUS\n#define snprintf git_snprintf\nextern int git_snprintf(char *str, size_t maxsize,\n\t\t\tconst char *format, ...);\n#define vsnprintf git_vsnprintf\nextern int git_vsnprintf(char *str, size_t maxsize,\n\t\t\t const char *format, va_list ap);\n#endif\n\n#ifdef __GLIBC_PREREQ\n#if __GLIBC_PREREQ(2, 1)\n#define HAVE_STRCHRNUL\n#define HAVE_MEMPCPY\n#endif\n#endif\n\n#ifndef HAVE_STRCHRNUL\n#define strchrnul gitstrchrnul\nstatic inline char *gitstrchrnul(const char *s, int c)\n{\n\twhile (*s && *s != c)\n\t\ts++;\n\treturn (char *)s;\n}\n#endif\n\n#ifndef HAVE_MEMPCPY\n#define mempcpy gitmempcpy\nstatic inline void *gitmempcpy(void *dest, const void *src, size_t n)\n{\n\treturn (char *)memcpy(dest, src, n) + n;\n}\n#endif\n\nextern void release_pack_memory(size_t, int);\n\nextern void set_try_to_free_routine(void (*routine)(size_t));\n\nextern char *xstrdup(const char *str);\nextern void *xmalloc(size_t size);\nextern void *xmallocz(size_t size);\nextern void *xmemdupz(const void *data, size_t len);\nextern char *xstrndup(const char *str, size_t len);\nextern void *xrealloc(void *ptr, size_t size);\nextern void *xcalloc(size_t nmemb, size_t size);\nextern void *xmmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nextern ssize_t xread(int fd, void *buf, size_t len);\nextern ssize_t xwrite(int fd, const void *buf, size_t len);\nextern int xdup(int fd);\nextern FILE *xfdopen(int fd, const char *mode);\nextern int xmkstemp(char *template);\nextern int odb_mkstemp(char *template, size_t limit, const char *pattern);\nextern int odb_pack_keep(char *name, size_t namesz, unsigned char *sha1);\n\nstatic inline size_t xsize_t(off_t len)\n{\n\treturn (size_t)len;\n}\n\nstatic inline int has_extension(const char *filename, const char *ext)\n{\n\tsize_t len = strlen(filename);\n\tsize_t extlen = strlen(ext);\n\treturn len > extlen && !memcmp(filename + len - extlen, ext, extlen);\n}\n\n/* Sane ctype - no locale, and works with signed chars */\n#undef isascii\n#undef isspace\n#undef isdigit\n#undef isalpha\n#undef isalnum\n#undef tolower\n#undef toupper\nextern unsigned char sane_ctype[256];\n#define GIT_SPACE 0x01\n#define GIT_DIGIT 0x02\n#define GIT_ALPHA 0x04\n#define GIT_GLOB_SPECIAL 0x08\n#define GIT_REGEX_SPECIAL 0x10\n#define sane_istest(x,mask) ((sane_ctype[(unsigned char)(x)] & (mask)) != 0)\n#define isascii(x) (((x) & ~0x7f) == 0)\n#define isspace(x) sane_istest(x,GIT_SPACE)\n#define isdigit(x) sane_istest(x,GIT_DIGIT)\n#define isalpha(x) sane_istest(x,GIT_ALPHA)\n#define isalnum(x) sane_istest(x,GIT_ALPHA | GIT_DIGIT)\n#define is_glob_special(x) sane_istest(x,GIT_GLOB_SPECIAL)\n#define is_regex_special(x) sane_istest(x,GIT_GLOB_SPECIAL | GIT_REGEX_SPECIAL)\n#define tolower(x) sane_case((unsigned char)(x), 0x20)\n#define toupper(x) sane_case((unsigned char)(x), 0)\n\nstatic inline int sane_case(int x, int high)\n{\n\tif (sane_istest(x, GIT_ALPHA))\n\t\tx = (x & ~0x20) | high;\n\treturn x;\n}\n\nstatic inline int strtoul_ui(char const *s, int base, unsigned int *result)\n{\n\tunsigned long ul;\n\tchar *p;\n\n\terrno = 0;\n\tul = strtoul(s, &p, base);\n\tif (errno || *p || p == s || (unsigned int) ul != ul)\n\t\treturn -1;\n\t*result = ul;\n\treturn 0;\n}\n\nstatic inline int strtol_i(char const *s, int base, int *result)\n{\n\tlong ul;\n\tchar *p;\n\n\terrno = 0;\n\tul = strtol(s, &p, base);\n\tif (errno || *p || p == s || (int) ul != ul)\n\t\treturn -1;\n\t*result = ul;\n\treturn 0;\n}\n\n#ifdef INTERNAL_QSORT\nvoid git_qsort(void *base, size_t nmemb, size_t size,\n\t       int(*compar)(const void *, const void *));\n#define qsort git_qsort\n#endif\n\n#ifndef DIR_HAS_BSD_GROUP_SEMANTICS\n# define FORCE_DIR_SET_GID S_ISGID\n#else\n# define FORCE_DIR_SET_GID 0\n#endif\n\n#ifdef NO_NSEC\n#undef USE_NSEC\n#define ST_CTIME_NSEC(st) 0\n#define ST_MTIME_NSEC(st) 0\n#else\n#ifdef USE_ST_TIMESPEC\n#define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctimespec.tv_nsec))\n#define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtimespec.tv_nsec))\n#else\n#define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctim.tv_nsec))\n#define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtim.tv_nsec))\n#endif\n#endif\n\n#ifdef UNRELIABLE_FSTAT\n#define fstat_is_reliable() 0\n#else\n#define fstat_is_reliable() 1\n#endif\n\n/*\n * Preserves errno, prints a message, but gives no warning for ENOENT.\n * Always returns the return value of unlink(2).\n */\nint unlink_or_warn(const char *path);\n/*\n * Likewise for rmdir(2).\n */\nint rmdir_or_warn(const char *path);\n/*\n * Calls the correct function out of {unlink,rmdir}_or_warn based on\n * the supplied file mode.\n */\nint remove_or_warn(unsigned int mode, const char *path);\n\n#endif\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "001e5db4bbfb55c954168dd9b35cf3861b7a0c29",
  "sha1_ok": true,
  "size": 12327
}
