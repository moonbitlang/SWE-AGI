{
  "content": {
    "base64": "CiNpbmNsdWRlICJyZWZzLWludGVybmFsLmgiCiNpbmNsdWRlICJ0cmFjZS5oIgoKc3RhdGljIHN0cnVjdCB0cmFjZV9rZXkgdHJhY2VfcmVmcyA9IFRSQUNFX0tFWV9JTklUKFJFRlMpOwoKc3RydWN0IGRlYnVnX3JlZl9zdG9yZSB7CglzdHJ1Y3QgcmVmX3N0b3JlIGJhc2U7CglzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzOwp9OwoKZXh0ZXJuIHN0cnVjdCByZWZfc3RvcmFnZV9iZSByZWZzX2JlX2RlYnVnOwoKc3RydWN0IHJlZl9zdG9yZSAqbWF5YmVfZGVidWdfd3JhcF9yZWZfc3RvcmUoY29uc3QgY2hhciAqZ2l0ZGlyLCBzdHJ1Y3QgcmVmX3N0b3JlICpzdG9yZSkKewoJc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqcmVzOwoJc3RydWN0IHJlZl9zdG9yYWdlX2JlICpiZV9jb3B5OwoKCWlmICghdHJhY2Vfd2FudCgmdHJhY2VfcmVmcykpIHsKCQlyZXR1cm4gc3RvcmU7Cgl9CglyZXMgPSB4bWFsbG9jKHNpemVvZihzdHJ1Y3QgZGVidWdfcmVmX3N0b3JlKSk7CgliZV9jb3B5ID0geG1hbGxvYyhzaXplb2YoKmJlX2NvcHkpKTsKCSpiZV9jb3B5ID0gcmVmc19iZV9kZWJ1ZzsKCS8qIHdlIG5ldmVyIGRlYWxsb2NhdGUgYmFja2VuZHMsIHNvIHNhZmUgdG8gY29weSB0aGUgcG9pbnRlci4gKi8KCWJlX2NvcHktPm5hbWUgPSBzdG9yZS0+YmUtPm5hbWU7Cgl0cmFjZV9wcmludGZfa2V5KCZ0cmFjZV9yZWZzLCAicmVmX3N0b3JlIGZvciAlc1xuIiwgZ2l0ZGlyKTsKCXJlcy0+cmVmcyA9IHN0b3JlOwoJYmFzZV9yZWZfc3RvcmVfaW5pdCgoc3RydWN0IHJlZl9zdG9yZSAqKXJlcywgYmVfY29weSk7CglyZXR1cm4gKHN0cnVjdCByZWZfc3RvcmUgKilyZXM7Cn0KCnN0YXRpYyBpbnQgZGVidWdfaW5pdF9kYihzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLCBzdHJ1Y3Qgc3RyYnVmICplcnIpCnsKCXN0cnVjdCBkZWJ1Z19yZWZfc3RvcmUgKmRyZWZzID0gKHN0cnVjdCBkZWJ1Z19yZWZfc3RvcmUgKilyZWZzOwoJaW50IHJlcyA9IGRyZWZzLT5yZWZzLT5iZS0+aW5pdF9kYihkcmVmcy0+cmVmcywgZXJyKTsKCXRyYWNlX3ByaW50Zl9rZXkoJnRyYWNlX3JlZnMsICJpbml0X2RiOiAlZFxuIiwgcmVzKTsKCXJldHVybiByZXM7Cn0KCnN0YXRpYyBpbnQgZGVidWdfdHJhbnNhY3Rpb25fcHJlcGFyZShzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLAoJCQkJICAgICBzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0cmFuc2FjdGlvbiwKCQkJCSAgICAgc3RydWN0IHN0cmJ1ZiAqZXJyKQp7CglzdHJ1Y3QgZGVidWdfcmVmX3N0b3JlICpkcmVmcyA9IChzdHJ1Y3QgZGVidWdfcmVmX3N0b3JlICopcmVmczsKCWludCByZXM7Cgl0cmFuc2FjdGlvbi0+cmVmX3N0b3JlID0gZHJlZnMtPnJlZnM7CglyZXMgPSBkcmVmcy0+cmVmcy0+YmUtPnRyYW5zYWN0aW9uX3ByZXBhcmUoZHJlZnMtPnJlZnMsIHRyYW5zYWN0aW9uLAoJCQkJCQkgICBlcnIpOwoJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2VfcmVmcywgInRyYW5zYWN0aW9uX3ByZXBhcmU6ICVkXG4iLCByZXMpOwoJcmV0dXJuIHJlczsKfQoKc3RhdGljIHZvaWQgcHJpbnRfdXBkYXRlKGludCBpLCBjb25zdCBjaGFyICpyZWZuYW1lLAoJCQkgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2xkX29pZCwKCQkJIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm5ld19vaWQsIHVuc2lnbmVkIGludCBmbGFncywKCQkJIHVuc2lnbmVkIGludCB0eXBlLCBjb25zdCBjaGFyICptc2cpCnsKCWNoYXIgb1tHSVRfTUFYX0hFWFNaICsgMV0gPSAibnVsbCI7CgljaGFyIG5bR0lUX01BWF9IRVhTWiArIDFdID0gIm51bGwiOwoJaWYgKG9sZF9vaWQpCgkJb2lkX3RvX2hleF9yKG8sIG9sZF9vaWQpOwoJaWYgKG5ld19vaWQpCgkJb2lkX3RvX2hleF9yKG4sIG5ld19vaWQpOwoKCXR5cGUgJj0gMHhmOyAvKiBzZWUgcmVmcy5oIFJFRl8qICovCglmbGFncyAmPSBSRUZfSEFWRV9ORVcgfCBSRUZfSEFWRV9PTEQgfCBSRUZfTk9fREVSRUYgfAoJCVJFRl9GT1JDRV9DUkVBVEVfUkVGTE9HOwoJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2VfcmVmcywgIiVkOiAlcyAlcyAtPiAlcyAoRj0weCV4LCBUPTB4JXgpIFwiJXNcIlxuIiwgaSwgcmVmbmFtZSwKCQlvLCBuLCBmbGFncywgdHlwZSwgbXNnKTsKfQoKc3RhdGljIHZvaWQgcHJpbnRfdHJhbnNhY3Rpb24oc3RydWN0IHJlZl90cmFuc2FjdGlvbiAqdHJhbnNhY3Rpb24pCnsKCWludCBpOwoJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2VfcmVmcywgInRyYW5zYWN0aW9uIHtcbiIpOwoJZm9yIChpID0gMDsgaSA8IHRyYW5zYWN0aW9uLT5ucjsgaSsrKSB7CgkJc3RydWN0IHJlZl91cGRhdGUgKnUgPSB0cmFuc2FjdGlvbi0+dXBkYXRlc1tpXTsKCQlwcmludF91cGRhdGUoaSwgdS0+cmVmbmFtZSwgJnUtPm9sZF9vaWQsICZ1LT5uZXdfb2lkLCB1LT5mbGFncywKCQkJICAgICB1LT50eXBlLCB1LT5tc2cpOwoJfQoJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2VfcmVmcywgIn1cbiIpOwp9CgpzdGF0aWMgaW50IGRlYnVnX3RyYW5zYWN0aW9uX2ZpbmlzaChzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLAoJCQkJICAgIHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyYW5zYWN0aW9uLAoJCQkJICAgIHN0cnVjdCBzdHJidWYgKmVycikKewoJc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqZHJlZnMgPSAoc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqKXJlZnM7CglpbnQgcmVzOwoJdHJhbnNhY3Rpb24tPnJlZl9zdG9yZSA9IGRyZWZzLT5yZWZzOwoJcmVzID0gZHJlZnMtPnJlZnMtPmJlLT50cmFuc2FjdGlvbl9maW5pc2goZHJlZnMtPnJlZnMsIHRyYW5zYWN0aW9uLAoJCQkJCQkgIGVycik7CglwcmludF90cmFuc2FjdGlvbih0cmFuc2FjdGlvbik7Cgl0cmFjZV9wcmludGZfa2V5KCZ0cmFjZV9yZWZzLCAiZmluaXNoOiAlZFxuIiwgcmVzKTsKCXJldHVybiByZXM7Cn0KCnN0YXRpYyBpbnQgZGVidWdfdHJhbnNhY3Rpb25fYWJvcnQoc3RydWN0IHJlZl9zdG9yZSAqcmVmcywKCQkJCSAgIHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyYW5zYWN0aW9uLAoJCQkJICAgc3RydWN0IHN0cmJ1ZiAqZXJyKQp7CglzdHJ1Y3QgZGVidWdfcmVmX3N0b3JlICpkcmVmcyA9IChzdHJ1Y3QgZGVidWdfcmVmX3N0b3JlICopcmVmczsKCWludCByZXM7Cgl0cmFuc2FjdGlvbi0+cmVmX3N0b3JlID0gZHJlZnMtPnJlZnM7CglyZXMgPSBkcmVmcy0+cmVmcy0+YmUtPnRyYW5zYWN0aW9uX2Fib3J0KGRyZWZzLT5yZWZzLCB0cmFuc2FjdGlvbiwgZXJyKTsKCXJldHVybiByZXM7Cn0KCnN0YXRpYyBpbnQgZGVidWdfaW5pdGlhbF90cmFuc2FjdGlvbl9jb21taXQoc3RydWN0IHJlZl9zdG9yZSAqcmVmcywKCQkJCQkgICAgc3RydWN0IHJlZl90cmFuc2FjdGlvbiAqdHJhbnNhY3Rpb24sCgkJCQkJICAgIHN0cnVjdCBzdHJidWYgKmVycikKewoJc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqZHJlZnMgPSAoc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqKXJlZnM7CglpbnQgcmVzOwoJdHJhbnNhY3Rpb24tPnJlZl9zdG9yZSA9IGRyZWZzLT5yZWZzOwoJcmVzID0gZHJlZnMtPnJlZnMtPmJlLT5pbml0aWFsX3RyYW5zYWN0aW9uX2NvbW1pdChkcmVmcy0+cmVmcywKCQkJCQkJCSAgdHJhbnNhY3Rpb24sIGVycik7CglyZXR1cm4gcmVzOwp9CgpzdGF0aWMgaW50IGRlYnVnX3BhY2tfcmVmcyhzdHJ1Y3QgcmVmX3N0b3JlICpyZWZfc3RvcmUsIHVuc2lnbmVkIGludCBmbGFncykKewoJc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqZHJlZnMgPSAoc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqKXJlZl9zdG9yZTsKCWludCByZXMgPSBkcmVmcy0+cmVmcy0+YmUtPnBhY2tfcmVmcyhkcmVmcy0+cmVmcywgZmxhZ3MpOwoJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2VfcmVmcywgInBhY2tfcmVmczogJWRcbiIsIHJlcyk7CglyZXR1cm4gcmVzOwp9CgpzdGF0aWMgaW50IGRlYnVnX2NyZWF0ZV9zeW1yZWYoc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlLAoJCQkgICAgICAgY29uc3QgY2hhciAqcmVmX25hbWUsIGNvbnN0IGNoYXIgKnRhcmdldCwKCQkJICAgICAgIGNvbnN0IGNoYXIgKmxvZ21zZykKewoJc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqZHJlZnMgPSAoc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqKXJlZl9zdG9yZTsKCWludCByZXMgPSBkcmVmcy0+cmVmcy0+YmUtPmNyZWF0ZV9zeW1yZWYoZHJlZnMtPnJlZnMsIHJlZl9uYW1lLCB0YXJnZXQsCgkJCQkJCSBsb2dtc2cpOwoJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2VfcmVmcywgImNyZWF0ZV9zeW1yZWY6ICVzIC0+ICVzIFwiJXNcIjogJWRcbiIsIHJlZl9uYW1lLAoJCXRhcmdldCwgbG9nbXNnLCByZXMpOwoJcmV0dXJuIHJlczsKfQoKc3RhdGljIGludCBkZWJ1Z19kZWxldGVfcmVmcyhzdHJ1Y3QgcmVmX3N0b3JlICpyZWZfc3RvcmUsIGNvbnN0IGNoYXIgKm1zZywKCQkJICAgICBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnJlZm5hbWVzLCB1bnNpZ25lZCBpbnQgZmxhZ3MpCnsKCXN0cnVjdCBkZWJ1Z19yZWZfc3RvcmUgKmRyZWZzID0gKHN0cnVjdCBkZWJ1Z19yZWZfc3RvcmUgKilyZWZfc3RvcmU7CglpbnQgcmVzID0KCQlkcmVmcy0+cmVmcy0+YmUtPmRlbGV0ZV9yZWZzKGRyZWZzLT5yZWZzLCBtc2csIHJlZm5hbWVzLCBmbGFncyk7CglpbnQgaTsKCXRyYWNlX3ByaW50Zl9rZXkoJnRyYWNlX3JlZnMsICJkZWxldGVfcmVmcyB7XG4iKTsKCWZvciAoaSA9IDA7IGkgPCByZWZuYW1lcy0+bnI7IGkrKykKCQl0cmFjZV9wcmludGZfa2V5KCZ0cmFjZV9yZWZzLCAiJXNcbiIsIHJlZm5hbWVzLT5pdGVtc1tpXS5zdHJpbmcpOwoJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2VfcmVmcywgIn06ICVkXG4iLCByZXMpOwoJcmV0dXJuIHJlczsKfQoKc3RhdGljIGludCBkZWJ1Z19yZW5hbWVfcmVmKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSwgY29uc3QgY2hhciAqb2xkcmVmLAoJCQkgICAgY29uc3QgY2hhciAqbmV3cmVmLCBjb25zdCBjaGFyICpsb2dtc2cpCnsKCXN0cnVjdCBkZWJ1Z19yZWZfc3RvcmUgKmRyZWZzID0gKHN0cnVjdCBkZWJ1Z19yZWZfc3RvcmUgKilyZWZfc3RvcmU7CglpbnQgcmVzID0gZHJlZnMtPnJlZnMtPmJlLT5yZW5hbWVfcmVmKGRyZWZzLT5yZWZzLCBvbGRyZWYsIG5ld3JlZiwKCQkJCQkgICAgICBsb2dtc2cpOwoJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2VfcmVmcywgInJlbmFtZV9yZWY6ICVzIC0+ICVzIFwiJXNcIjogJWRcbiIsIG9sZHJlZiwgbmV3cmVmLAoJCWxvZ21zZywgcmVzKTsKCXJldHVybiByZXM7Cn0KCnN0YXRpYyBpbnQgZGVidWdfY29weV9yZWYoc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlLCBjb25zdCBjaGFyICpvbGRyZWYsCgkJCSAgY29uc3QgY2hhciAqbmV3cmVmLCBjb25zdCBjaGFyICpsb2dtc2cpCnsKCXN0cnVjdCBkZWJ1Z19yZWZfc3RvcmUgKmRyZWZzID0gKHN0cnVjdCBkZWJ1Z19yZWZfc3RvcmUgKilyZWZfc3RvcmU7CglpbnQgcmVzID0KCQlkcmVmcy0+cmVmcy0+YmUtPmNvcHlfcmVmKGRyZWZzLT5yZWZzLCBvbGRyZWYsIG5ld3JlZiwgbG9nbXNnKTsKCXRyYWNlX3ByaW50Zl9rZXkoJnRyYWNlX3JlZnMsICJjb3B5X3JlZjogJXMgLT4gJXMgXCIlc1wiOiAlZFxuIiwgb2xkcmVmLCBuZXdyZWYsCgkJbG9nbXNnLCByZXMpOwoJcmV0dXJuIHJlczsKfQoKc3RydWN0IGRlYnVnX3JlZl9pdGVyYXRvciB7CglzdHJ1Y3QgcmVmX2l0ZXJhdG9yIGJhc2U7CglzdHJ1Y3QgcmVmX2l0ZXJhdG9yICppdGVyOwp9OwoKc3RhdGljIGludCBkZWJ1Z19yZWZfaXRlcmF0b3JfYWR2YW5jZShzdHJ1Y3QgcmVmX2l0ZXJhdG9yICpyZWZfaXRlcmF0b3IpCnsKCXN0cnVjdCBkZWJ1Z19yZWZfaXRlcmF0b3IgKmRpdGVyID0KCQkoc3RydWN0IGRlYnVnX3JlZl9pdGVyYXRvciAqKXJlZl9pdGVyYXRvcjsKCWludCByZXMgPSBkaXRlci0+aXRlci0+dnRhYmxlLT5hZHZhbmNlKGRpdGVyLT5pdGVyKTsKCWlmIChyZXMpCgkJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2VfcmVmcywgIml0ZXJhdG9yX2FkdmFuY2U6ICglZClcbiIsIHJlcyk7CgllbHNlCgkJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2VfcmVmcywgIml0ZXJhdG9yX2FkdmFuY2U6ICVzICgwKVxuIiwKCQkJZGl0ZXItPml0ZXItPnJlZm5hbWUpOwoKCWRpdGVyLT5iYXNlLm9yZGVyZWQgPSBkaXRlci0+aXRlci0+b3JkZXJlZDsKCWRpdGVyLT5iYXNlLnJlZm5hbWUgPSBkaXRlci0+aXRlci0+cmVmbmFtZTsKCWRpdGVyLT5iYXNlLm9pZCA9IGRpdGVyLT5pdGVyLT5vaWQ7CglkaXRlci0+YmFzZS5mbGFncyA9IGRpdGVyLT5pdGVyLT5mbGFnczsKCXJldHVybiByZXM7Cn0KCnN0YXRpYyBpbnQgZGVidWdfcmVmX2l0ZXJhdG9yX3BlZWwoc3RydWN0IHJlZl9pdGVyYXRvciAqcmVmX2l0ZXJhdG9yLAoJCQkJICAgc3RydWN0IG9iamVjdF9pZCAqcGVlbGVkKQp7CglzdHJ1Y3QgZGVidWdfcmVmX2l0ZXJhdG9yICpkaXRlciA9CgkJKHN0cnVjdCBkZWJ1Z19yZWZfaXRlcmF0b3IgKilyZWZfaXRlcmF0b3I7CglpbnQgcmVzID0gZGl0ZXItPml0ZXItPnZ0YWJsZS0+cGVlbChkaXRlci0+aXRlciwgcGVlbGVkKTsKCXRyYWNlX3ByaW50Zl9rZXkoJnRyYWNlX3JlZnMsICJpdGVyYXRvcl9wZWVsOiAlczogJWRcbiIsIGRpdGVyLT5pdGVyLT5yZWZuYW1lLCByZXMpOwoJcmV0dXJuIHJlczsKfQoKc3RhdGljIGludCBkZWJ1Z19yZWZfaXRlcmF0b3JfYWJvcnQoc3RydWN0IHJlZl9pdGVyYXRvciAqcmVmX2l0ZXJhdG9yKQp7CglzdHJ1Y3QgZGVidWdfcmVmX2l0ZXJhdG9yICpkaXRlciA9CgkJKHN0cnVjdCBkZWJ1Z19yZWZfaXRlcmF0b3IgKilyZWZfaXRlcmF0b3I7CglpbnQgcmVzID0gZGl0ZXItPml0ZXItPnZ0YWJsZS0+YWJvcnQoZGl0ZXItPml0ZXIpOwoJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2VfcmVmcywgIml0ZXJhdG9yX2Fib3J0OiAlZFxuIiwgcmVzKTsKCXJldHVybiByZXM7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVmX2l0ZXJhdG9yX3Z0YWJsZSBkZWJ1Z19yZWZfaXRlcmF0b3JfdnRhYmxlID0gewoJZGVidWdfcmVmX2l0ZXJhdG9yX2FkdmFuY2UsIGRlYnVnX3JlZl9pdGVyYXRvcl9wZWVsLAoJZGVidWdfcmVmX2l0ZXJhdG9yX2Fib3J0Cn07CgpzdGF0aWMgc3RydWN0IHJlZl9pdGVyYXRvciAqCmRlYnVnX3JlZl9pdGVyYXRvcl9iZWdpbihzdHJ1Y3QgcmVmX3N0b3JlICpyZWZfc3RvcmUsIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJIHVuc2lnbmVkIGludCBmbGFncykKewoJc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqZHJlZnMgPSAoc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqKXJlZl9zdG9yZTsKCXN0cnVjdCByZWZfaXRlcmF0b3IgKnJlcyA9CgkJZHJlZnMtPnJlZnMtPmJlLT5pdGVyYXRvcl9iZWdpbihkcmVmcy0+cmVmcywgcHJlZml4LCBmbGFncyk7CglzdHJ1Y3QgZGVidWdfcmVmX2l0ZXJhdG9yICpkaXRlciA9IHhjYWxsb2MoMSwgc2l6ZW9mKCpkaXRlcikpOwoJYmFzZV9yZWZfaXRlcmF0b3JfaW5pdCgmZGl0ZXItPmJhc2UsICZkZWJ1Z19yZWZfaXRlcmF0b3JfdnRhYmxlLCAxKTsKCWRpdGVyLT5pdGVyID0gcmVzOwoJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2VfcmVmcywgInJlZl9pdGVyYXRvcl9iZWdpbjogJXMgKDB4JXgpXG4iLCBwcmVmaXgsIGZsYWdzKTsKCXJldHVybiAmZGl0ZXItPmJhc2U7Cn0KCnN0YXRpYyBpbnQgZGVidWdfcmVhZF9yYXdfcmVmKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSwgY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJICAgICAgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBzdHJ1Y3Qgc3RyYnVmICpyZWZlcmVudCwKCQkJICAgICAgdW5zaWduZWQgaW50ICp0eXBlKQp7CglzdHJ1Y3QgZGVidWdfcmVmX3N0b3JlICpkcmVmcyA9IChzdHJ1Y3QgZGVidWdfcmVmX3N0b3JlICopcmVmX3N0b3JlOwoJaW50IHJlcyA9IDA7CgoJb2lkY3B5KG9pZCwgJm51bGxfb2lkKTsKCWVycm5vID0gMDsKCXJlcyA9IGRyZWZzLT5yZWZzLT5iZS0+cmVhZF9yYXdfcmVmKGRyZWZzLT5yZWZzLCByZWZuYW1lLCBvaWQsIHJlZmVyZW50LAoJCQkJCSAgICB0eXBlKTsKCglpZiAocmVzID09IDApIHsKCQl0cmFjZV9wcmludGZfa2V5KCZ0cmFjZV9yZWZzLCAicmVhZF9yYXdfcmVmOiAlczogJXMgKD0+ICVzKSB0eXBlICV4OiAlZFxuIiwKCQkJcmVmbmFtZSwgb2lkX3RvX2hleChvaWQpLCByZWZlcmVudC0+YnVmLCAqdHlwZSwgcmVzKTsKCX0gZWxzZSB7CgkJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2VfcmVmcywKCQkJCSAicmVhZF9yYXdfcmVmOiAlczogJWQgKGVycm5vICVkKVxuIiwgcmVmbmFtZSwKCQkJCSByZXMsIGVycm5vKTsKCX0KCXJldHVybiByZXM7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVmX2l0ZXJhdG9yICoKZGVidWdfcmVmbG9nX2l0ZXJhdG9yX2JlZ2luKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSkKewoJc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqZHJlZnMgPSAoc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqKXJlZl9zdG9yZTsKCXN0cnVjdCByZWZfaXRlcmF0b3IgKnJlcyA9CgkJZHJlZnMtPnJlZnMtPmJlLT5yZWZsb2dfaXRlcmF0b3JfYmVnaW4oZHJlZnMtPnJlZnMpOwoJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2VfcmVmcywgImZvcl9lYWNoX3JlZmxvZ19pdGVyYXRvcl9iZWdpblxuIik7CglyZXR1cm4gcmVzOwp9CgpzdHJ1Y3QgZGVidWdfcmVmbG9nIHsKCWNvbnN0IGNoYXIgKnJlZm5hbWU7CgllYWNoX3JlZmxvZ19lbnRfZm4gKmZuOwoJdm9pZCAqY2JfZGF0YTsKfTsKCnN0YXRpYyBpbnQgZGVidWdfcHJpbnRfcmVmbG9nX2VudChzdHJ1Y3Qgb2JqZWN0X2lkICpvbGRfb2lkLAoJCQkJICBzdHJ1Y3Qgb2JqZWN0X2lkICpuZXdfb2lkLAoJCQkJICBjb25zdCBjaGFyICpjb21taXR0ZXIsIHRpbWVzdGFtcF90IHRpbWVzdGFtcCwKCQkJCSAgaW50IHR6LCBjb25zdCBjaGFyICptc2csIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBkZWJ1Z19yZWZsb2cgKmRiZyA9IChzdHJ1Y3QgZGVidWdfcmVmbG9nICopY2JfZGF0YTsKCWludCByZXQ7CgljaGFyIG9bR0lUX01BWF9IRVhTWiArIDFdID0gIm51bGwiOwoJY2hhciBuW0dJVF9NQVhfSEVYU1ogKyAxXSA9ICJudWxsIjsKCWlmIChvbGRfb2lkKQoJCW9pZF90b19oZXhfcihvLCBvbGRfb2lkKTsKCWlmIChuZXdfb2lkKQoJCW9pZF90b19oZXhfcihuLCBuZXdfb2lkKTsKCglyZXQgPSBkYmctPmZuKG9sZF9vaWQsIG5ld19vaWQsIGNvbW1pdHRlciwgdGltZXN0YW1wLCB0eiwgbXNnLAoJCSAgICAgIGRiZy0+Y2JfZGF0YSk7Cgl0cmFjZV9wcmludGZfa2V5KCZ0cmFjZV9yZWZzLCAicmVmbG9nX2VudCAlcyAocmV0ICVkKTogJXMgLT4gJXMsICVzICVsZCBcIiVzXCJcbiIsCgkJZGJnLT5yZWZuYW1lLCByZXQsIG8sIG4sIGNvbW1pdHRlciwgKGxvbmcgaW50KXRpbWVzdGFtcCwgbXNnKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQgZGVidWdfZm9yX2VhY2hfcmVmbG9nX2VudChzdHJ1Y3QgcmVmX3N0b3JlICpyZWZfc3RvcmUsCgkJCQkgICAgIGNvbnN0IGNoYXIgKnJlZm5hbWUsIGVhY2hfcmVmbG9nX2VudF9mbiBmbiwKCQkJCSAgICAgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqZHJlZnMgPSAoc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqKXJlZl9zdG9yZTsKCXN0cnVjdCBkZWJ1Z19yZWZsb2cgZGJnID0gewoJCS5yZWZuYW1lID0gcmVmbmFtZSwKCQkuZm4gPSBmbiwKCQkuY2JfZGF0YSA9IGNiX2RhdGEsCgl9OwoKCWludCByZXMgPSBkcmVmcy0+cmVmcy0+YmUtPmZvcl9lYWNoX3JlZmxvZ19lbnQoCgkJZHJlZnMtPnJlZnMsIHJlZm5hbWUsICZkZWJ1Z19wcmludF9yZWZsb2dfZW50LCAmZGJnKTsKCXRyYWNlX3ByaW50Zl9rZXkoJnRyYWNlX3JlZnMsICJmb3JfZWFjaF9yZWZsb2c6ICVzOiAlZFxuIiwgcmVmbmFtZSwgcmVzKTsKCXJldHVybiByZXM7Cn0KCnN0YXRpYyBpbnQgZGVidWdfZm9yX2VhY2hfcmVmbG9nX2VudF9yZXZlcnNlKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSwKCQkJCQkgICAgIGNvbnN0IGNoYXIgKnJlZm5hbWUsCgkJCQkJICAgICBlYWNoX3JlZmxvZ19lbnRfZm4gZm4sCgkJCQkJICAgICB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3QgZGVidWdfcmVmX3N0b3JlICpkcmVmcyA9IChzdHJ1Y3QgZGVidWdfcmVmX3N0b3JlICopcmVmX3N0b3JlOwoJc3RydWN0IGRlYnVnX3JlZmxvZyBkYmcgPSB7CgkJLnJlZm5hbWUgPSByZWZuYW1lLAoJCS5mbiA9IGZuLAoJCS5jYl9kYXRhID0gY2JfZGF0YSwKCX07CglpbnQgcmVzID0gZHJlZnMtPnJlZnMtPmJlLT5mb3JfZWFjaF9yZWZsb2dfZW50X3JldmVyc2UoCgkJZHJlZnMtPnJlZnMsIHJlZm5hbWUsICZkZWJ1Z19wcmludF9yZWZsb2dfZW50LCAmZGJnKTsKCXRyYWNlX3ByaW50Zl9rZXkoJnRyYWNlX3JlZnMsICJmb3JfZWFjaF9yZWZsb2dfcmV2ZXJzZTogJXM6ICVkXG4iLCByZWZuYW1lLCByZXMpOwoJcmV0dXJuIHJlczsKfQoKc3RhdGljIGludCBkZWJ1Z19yZWZsb2dfZXhpc3RzKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSwgY29uc3QgY2hhciAqcmVmbmFtZSkKewoJc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqZHJlZnMgPSAoc3RydWN0IGRlYnVnX3JlZl9zdG9yZSAqKXJlZl9zdG9yZTsKCWludCByZXMgPSBkcmVmcy0+cmVmcy0+YmUtPnJlZmxvZ19leGlzdHMoZHJlZnMtPnJlZnMsIHJlZm5hbWUpOwoJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2VfcmVmcywgInJlZmxvZ19leGlzdHM6ICVzOiAlZFxuIiwgcmVmbmFtZSwgcmVzKTsKCXJldHVybiByZXM7Cn0KCnN0YXRpYyBpbnQgZGVidWdfY3JlYXRlX3JlZmxvZyhzdHJ1Y3QgcmVmX3N0b3JlICpyZWZfc3RvcmUsIGNvbnN0IGNoYXIgKnJlZm5hbWUsCgkJCSAgICAgICBpbnQgZm9yY2VfY3JlYXRlLCBzdHJ1Y3Qgc3RyYnVmICplcnIpCnsKCXN0cnVjdCBkZWJ1Z19yZWZfc3RvcmUgKmRyZWZzID0gKHN0cnVjdCBkZWJ1Z19yZWZfc3RvcmUgKilyZWZfc3RvcmU7CglpbnQgcmVzID0gZHJlZnMtPnJlZnMtPmJlLT5jcmVhdGVfcmVmbG9nKGRyZWZzLT5yZWZzLCByZWZuYW1lLAoJCQkJCQkgZm9yY2VfY3JlYXRlLCBlcnIpOwoJdHJhY2VfcHJpbnRmX2tleSgmdHJhY2VfcmVmcywgImNyZWF0ZV9yZWZsb2c6ICVzOiAlZFxuIiwgcmVmbmFtZSwgcmVzKTsKCXJldHVybiByZXM7Cn0KCnN0YXRpYyBpbnQgZGVidWdfZGVsZXRlX3JlZmxvZyhzdHJ1Y3QgcmVmX3N0b3JlICpyZWZfc3RvcmUsIGNvbnN0IGNoYXIgKnJlZm5hbWUpCnsKCXN0cnVjdCBkZWJ1Z19yZWZfc3RvcmUgKmRyZWZzID0gKHN0cnVjdCBkZWJ1Z19yZWZfc3RvcmUgKilyZWZfc3RvcmU7CglpbnQgcmVzID0gZHJlZnMtPnJlZnMtPmJlLT5kZWxldGVfcmVmbG9nKGRyZWZzLT5yZWZzLCByZWZuYW1lKTsKCXRyYWNlX3ByaW50Zl9rZXkoJnRyYWNlX3JlZnMsICJkZWxldGVfcmVmbG9nOiAlczogJWRcbiIsIHJlZm5hbWUsIHJlcyk7CglyZXR1cm4gcmVzOwp9CgpzdHJ1Y3QgZGVidWdfcmVmbG9nX2V4cGlyeV9zaG91bGRfcHJ1bmUgewoJcmVmbG9nX2V4cGlyeV9wcmVwYXJlX2ZuICpwcmVwYXJlOwoJcmVmbG9nX2V4cGlyeV9zaG91bGRfcHJ1bmVfZm4gKnNob3VsZF9wcnVuZTsKCXJlZmxvZ19leHBpcnlfY2xlYW51cF9mbiAqY2xlYW51cDsKCXZvaWQgKmNiX2RhdGE7Cn07CgpzdGF0aWMgdm9pZCBkZWJ1Z19yZWZsb2dfZXhwaXJ5X3ByZXBhcmUoY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJCSAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCQkgICAgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IGRlYnVnX3JlZmxvZ19leHBpcnlfc2hvdWxkX3BydW5lICpwcnVuZSA9IGNiX2RhdGE7Cgl0cmFjZV9wcmludGZfa2V5KCZ0cmFjZV9yZWZzLCAicmVmbG9nX2V4cGlyZV9wcmVwYXJlOiAlc1xuIiwgcmVmbmFtZSk7CglwcnVuZS0+cHJlcGFyZShyZWZuYW1lLCBvaWQsIHBydW5lLT5jYl9kYXRhKTsKfQoKc3RhdGljIGludCBkZWJ1Z19yZWZsb2dfZXhwaXJ5X3Nob3VsZF9wcnVuZV9mbihzdHJ1Y3Qgb2JqZWN0X2lkICpvb2lkLAoJCQkJCSAgICAgICBzdHJ1Y3Qgb2JqZWN0X2lkICpub2lkLAoJCQkJCSAgICAgICBjb25zdCBjaGFyICplbWFpbCwKCQkJCQkgICAgICAgdGltZXN0YW1wX3QgdGltZXN0YW1wLCBpbnQgdHosCgkJCQkJICAgICAgIGNvbnN0IGNoYXIgKm1lc3NhZ2UsIHZvaWQgKmNiX2RhdGEpIHsKCXN0cnVjdCBkZWJ1Z19yZWZsb2dfZXhwaXJ5X3Nob3VsZF9wcnVuZSAqcHJ1bmUgPSBjYl9kYXRhOwoKCWludCByZXN1bHQgPSBwcnVuZS0+c2hvdWxkX3BydW5lKG9vaWQsIG5vaWQsIGVtYWlsLCB0aW1lc3RhbXAsIHR6LCBtZXNzYWdlLCBwcnVuZS0+Y2JfZGF0YSk7Cgl0cmFjZV9wcmludGZfa2V5KCZ0cmFjZV9yZWZzLCAicmVmbG9nX2V4cGlyZV9zaG91bGRfcHJ1bmU6ICVzICVsZDogJWRcbiIsIG1lc3NhZ2UsIChsb25nIGludCkgdGltZXN0YW1wLCByZXN1bHQpOwoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIHZvaWQgZGVidWdfcmVmbG9nX2V4cGlyeV9jbGVhbnVwKHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBkZWJ1Z19yZWZsb2dfZXhwaXJ5X3Nob3VsZF9wcnVuZSAqcHJ1bmUgPSBjYl9kYXRhOwoJcHJ1bmUtPmNsZWFudXAocHJ1bmUtPmNiX2RhdGEpOwp9CgpzdGF0aWMgaW50IGRlYnVnX3JlZmxvZ19leHBpcmUoc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlLCBjb25zdCBjaGFyICpyZWZuYW1lLAoJCQkgICAgICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCB1bnNpZ25lZCBpbnQgZmxhZ3MsCgkJCSAgICAgICByZWZsb2dfZXhwaXJ5X3ByZXBhcmVfZm4gcHJlcGFyZV9mbiwKCQkJICAgICAgIHJlZmxvZ19leHBpcnlfc2hvdWxkX3BydW5lX2ZuIHNob3VsZF9wcnVuZV9mbiwKCQkJICAgICAgIHJlZmxvZ19leHBpcnlfY2xlYW51cF9mbiBjbGVhbnVwX2ZuLAoJCQkgICAgICAgdm9pZCAqcG9saWN5X2NiX2RhdGEpCnsKCXN0cnVjdCBkZWJ1Z19yZWZfc3RvcmUgKmRyZWZzID0gKHN0cnVjdCBkZWJ1Z19yZWZfc3RvcmUgKilyZWZfc3RvcmU7CglzdHJ1Y3QgZGVidWdfcmVmbG9nX2V4cGlyeV9zaG91bGRfcHJ1bmUgcHJ1bmUgPSB7CgkJLnByZXBhcmUgPSBwcmVwYXJlX2ZuLAoJCS5jbGVhbnVwID0gY2xlYW51cF9mbiwKCQkuc2hvdWxkX3BydW5lID0gc2hvdWxkX3BydW5lX2ZuLAoJCS5jYl9kYXRhID0gcG9saWN5X2NiX2RhdGEsCgl9OwoJaW50IHJlcyA9IGRyZWZzLT5yZWZzLT5iZS0+cmVmbG9nX2V4cGlyZShkcmVmcy0+cmVmcywgcmVmbmFtZSwgb2lkLAoJCQkJCQkgZmxhZ3MsICZkZWJ1Z19yZWZsb2dfZXhwaXJ5X3ByZXBhcmUsCgkJCQkJCSAmZGVidWdfcmVmbG9nX2V4cGlyeV9zaG91bGRfcHJ1bmVfZm4sCgkJCQkJCSAmZGVidWdfcmVmbG9nX2V4cGlyeV9jbGVhbnVwLAoJCQkJCQkgJnBydW5lKTsKCXRyYWNlX3ByaW50Zl9rZXkoJnRyYWNlX3JlZnMsICJyZWZsb2dfZXhwaXJlOiAlczogJWRcbiIsIHJlZm5hbWUsIHJlcyk7CglyZXR1cm4gcmVzOwp9CgpzdHJ1Y3QgcmVmX3N0b3JhZ2VfYmUgcmVmc19iZV9kZWJ1ZyA9IHsKCU5VTEwsCgkiZGVidWciLAoJTlVMTCwKCWRlYnVnX2luaXRfZGIsCglkZWJ1Z190cmFuc2FjdGlvbl9wcmVwYXJlLAoJZGVidWdfdHJhbnNhY3Rpb25fZmluaXNoLAoJZGVidWdfdHJhbnNhY3Rpb25fYWJvcnQsCglkZWJ1Z19pbml0aWFsX3RyYW5zYWN0aW9uX2NvbW1pdCwKCglkZWJ1Z19wYWNrX3JlZnMsCglkZWJ1Z19jcmVhdGVfc3ltcmVmLAoJZGVidWdfZGVsZXRlX3JlZnMsCglkZWJ1Z19yZW5hbWVfcmVmLAoJZGVidWdfY29weV9yZWYsCgoJZGVidWdfcmVmX2l0ZXJhdG9yX2JlZ2luLAoJZGVidWdfcmVhZF9yYXdfcmVmLAoKCWRlYnVnX3JlZmxvZ19pdGVyYXRvcl9iZWdpbiwKCWRlYnVnX2Zvcl9lYWNoX3JlZmxvZ19lbnQsCglkZWJ1Z19mb3JfZWFjaF9yZWZsb2dfZW50X3JldmVyc2UsCglkZWJ1Z19yZWZsb2dfZXhpc3RzLAoJZGVidWdfY3JlYXRlX3JlZmxvZywKCWRlYnVnX2RlbGV0ZV9yZWZsb2csCglkZWJ1Z19yZWZsb2dfZXhwaXJlLAp9Owo=",
    "text": "\n#include \"refs-internal.h\"\n#include \"trace.h\"\n\nstatic struct trace_key trace_refs = TRACE_KEY_INIT(REFS);\n\nstruct debug_ref_store {\n\tstruct ref_store base;\n\tstruct ref_store *refs;\n};\n\nextern struct ref_storage_be refs_be_debug;\n\nstruct ref_store *maybe_debug_wrap_ref_store(const char *gitdir, struct ref_store *store)\n{\n\tstruct debug_ref_store *res;\n\tstruct ref_storage_be *be_copy;\n\n\tif (!trace_want(&trace_refs)) {\n\t\treturn store;\n\t}\n\tres = xmalloc(sizeof(struct debug_ref_store));\n\tbe_copy = xmalloc(sizeof(*be_copy));\n\t*be_copy = refs_be_debug;\n\t/* we never deallocate backends, so safe to copy the pointer. */\n\tbe_copy->name = store->be->name;\n\ttrace_printf_key(&trace_refs, \"ref_store for %s\\n\", gitdir);\n\tres->refs = store;\n\tbase_ref_store_init((struct ref_store *)res, be_copy);\n\treturn (struct ref_store *)res;\n}\n\nstatic int debug_init_db(struct ref_store *refs, struct strbuf *err)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)refs;\n\tint res = drefs->refs->be->init_db(drefs->refs, err);\n\ttrace_printf_key(&trace_refs, \"init_db: %d\\n\", res);\n\treturn res;\n}\n\nstatic int debug_transaction_prepare(struct ref_store *refs,\n\t\t\t\t     struct ref_transaction *transaction,\n\t\t\t\t     struct strbuf *err)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)refs;\n\tint res;\n\ttransaction->ref_store = drefs->refs;\n\tres = drefs->refs->be->transaction_prepare(drefs->refs, transaction,\n\t\t\t\t\t\t   err);\n\ttrace_printf_key(&trace_refs, \"transaction_prepare: %d\\n\", res);\n\treturn res;\n}\n\nstatic void print_update(int i, const char *refname,\n\t\t\t const struct object_id *old_oid,\n\t\t\t const struct object_id *new_oid, unsigned int flags,\n\t\t\t unsigned int type, const char *msg)\n{\n\tchar o[GIT_MAX_HEXSZ + 1] = \"null\";\n\tchar n[GIT_MAX_HEXSZ + 1] = \"null\";\n\tif (old_oid)\n\t\toid_to_hex_r(o, old_oid);\n\tif (new_oid)\n\t\toid_to_hex_r(n, new_oid);\n\n\ttype &= 0xf; /* see refs.h REF_* */\n\tflags &= REF_HAVE_NEW | REF_HAVE_OLD | REF_NO_DEREF |\n\t\tREF_FORCE_CREATE_REFLOG;\n\ttrace_printf_key(&trace_refs, \"%d: %s %s -> %s (F=0x%x, T=0x%x) \\\"%s\\\"\\n\", i, refname,\n\t\to, n, flags, type, msg);\n}\n\nstatic void print_transaction(struct ref_transaction *transaction)\n{\n\tint i;\n\ttrace_printf_key(&trace_refs, \"transaction {\\n\");\n\tfor (i = 0; i < transaction->nr; i++) {\n\t\tstruct ref_update *u = transaction->updates[i];\n\t\tprint_update(i, u->refname, &u->old_oid, &u->new_oid, u->flags,\n\t\t\t     u->type, u->msg);\n\t}\n\ttrace_printf_key(&trace_refs, \"}\\n\");\n}\n\nstatic int debug_transaction_finish(struct ref_store *refs,\n\t\t\t\t    struct ref_transaction *transaction,\n\t\t\t\t    struct strbuf *err)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)refs;\n\tint res;\n\ttransaction->ref_store = drefs->refs;\n\tres = drefs->refs->be->transaction_finish(drefs->refs, transaction,\n\t\t\t\t\t\t  err);\n\tprint_transaction(transaction);\n\ttrace_printf_key(&trace_refs, \"finish: %d\\n\", res);\n\treturn res;\n}\n\nstatic int debug_transaction_abort(struct ref_store *refs,\n\t\t\t\t   struct ref_transaction *transaction,\n\t\t\t\t   struct strbuf *err)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)refs;\n\tint res;\n\ttransaction->ref_store = drefs->refs;\n\tres = drefs->refs->be->transaction_abort(drefs->refs, transaction, err);\n\treturn res;\n}\n\nstatic int debug_initial_transaction_commit(struct ref_store *refs,\n\t\t\t\t\t    struct ref_transaction *transaction,\n\t\t\t\t\t    struct strbuf *err)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)refs;\n\tint res;\n\ttransaction->ref_store = drefs->refs;\n\tres = drefs->refs->be->initial_transaction_commit(drefs->refs,\n\t\t\t\t\t\t\t  transaction, err);\n\treturn res;\n}\n\nstatic int debug_pack_refs(struct ref_store *ref_store, unsigned int flags)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;\n\tint res = drefs->refs->be->pack_refs(drefs->refs, flags);\n\ttrace_printf_key(&trace_refs, \"pack_refs: %d\\n\", res);\n\treturn res;\n}\n\nstatic int debug_create_symref(struct ref_store *ref_store,\n\t\t\t       const char *ref_name, const char *target,\n\t\t\t       const char *logmsg)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;\n\tint res = drefs->refs->be->create_symref(drefs->refs, ref_name, target,\n\t\t\t\t\t\t logmsg);\n\ttrace_printf_key(&trace_refs, \"create_symref: %s -> %s \\\"%s\\\": %d\\n\", ref_name,\n\t\ttarget, logmsg, res);\n\treturn res;\n}\n\nstatic int debug_delete_refs(struct ref_store *ref_store, const char *msg,\n\t\t\t     struct string_list *refnames, unsigned int flags)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;\n\tint res =\n\t\tdrefs->refs->be->delete_refs(drefs->refs, msg, refnames, flags);\n\tint i;\n\ttrace_printf_key(&trace_refs, \"delete_refs {\\n\");\n\tfor (i = 0; i < refnames->nr; i++)\n\t\ttrace_printf_key(&trace_refs, \"%s\\n\", refnames->items[i].string);\n\ttrace_printf_key(&trace_refs, \"}: %d\\n\", res);\n\treturn res;\n}\n\nstatic int debug_rename_ref(struct ref_store *ref_store, const char *oldref,\n\t\t\t    const char *newref, const char *logmsg)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;\n\tint res = drefs->refs->be->rename_ref(drefs->refs, oldref, newref,\n\t\t\t\t\t      logmsg);\n\ttrace_printf_key(&trace_refs, \"rename_ref: %s -> %s \\\"%s\\\": %d\\n\", oldref, newref,\n\t\tlogmsg, res);\n\treturn res;\n}\n\nstatic int debug_copy_ref(struct ref_store *ref_store, const char *oldref,\n\t\t\t  const char *newref, const char *logmsg)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;\n\tint res =\n\t\tdrefs->refs->be->copy_ref(drefs->refs, oldref, newref, logmsg);\n\ttrace_printf_key(&trace_refs, \"copy_ref: %s -> %s \\\"%s\\\": %d\\n\", oldref, newref,\n\t\tlogmsg, res);\n\treturn res;\n}\n\nstruct debug_ref_iterator {\n\tstruct ref_iterator base;\n\tstruct ref_iterator *iter;\n};\n\nstatic int debug_ref_iterator_advance(struct ref_iterator *ref_iterator)\n{\n\tstruct debug_ref_iterator *diter =\n\t\t(struct debug_ref_iterator *)ref_iterator;\n\tint res = diter->iter->vtable->advance(diter->iter);\n\tif (res)\n\t\ttrace_printf_key(&trace_refs, \"iterator_advance: (%d)\\n\", res);\n\telse\n\t\ttrace_printf_key(&trace_refs, \"iterator_advance: %s (0)\\n\",\n\t\t\tditer->iter->refname);\n\n\tditer->base.ordered = diter->iter->ordered;\n\tditer->base.refname = diter->iter->refname;\n\tditer->base.oid = diter->iter->oid;\n\tditer->base.flags = diter->iter->flags;\n\treturn res;\n}\n\nstatic int debug_ref_iterator_peel(struct ref_iterator *ref_iterator,\n\t\t\t\t   struct object_id *peeled)\n{\n\tstruct debug_ref_iterator *diter =\n\t\t(struct debug_ref_iterator *)ref_iterator;\n\tint res = diter->iter->vtable->peel(diter->iter, peeled);\n\ttrace_printf_key(&trace_refs, \"iterator_peel: %s: %d\\n\", diter->iter->refname, res);\n\treturn res;\n}\n\nstatic int debug_ref_iterator_abort(struct ref_iterator *ref_iterator)\n{\n\tstruct debug_ref_iterator *diter =\n\t\t(struct debug_ref_iterator *)ref_iterator;\n\tint res = diter->iter->vtable->abort(diter->iter);\n\ttrace_printf_key(&trace_refs, \"iterator_abort: %d\\n\", res);\n\treturn res;\n}\n\nstatic struct ref_iterator_vtable debug_ref_iterator_vtable = {\n\tdebug_ref_iterator_advance, debug_ref_iterator_peel,\n\tdebug_ref_iterator_abort\n};\n\nstatic struct ref_iterator *\ndebug_ref_iterator_begin(struct ref_store *ref_store, const char *prefix,\n\t\t\t unsigned int flags)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;\n\tstruct ref_iterator *res =\n\t\tdrefs->refs->be->iterator_begin(drefs->refs, prefix, flags);\n\tstruct debug_ref_iterator *diter = xcalloc(1, sizeof(*diter));\n\tbase_ref_iterator_init(&diter->base, &debug_ref_iterator_vtable, 1);\n\tditer->iter = res;\n\ttrace_printf_key(&trace_refs, \"ref_iterator_begin: %s (0x%x)\\n\", prefix, flags);\n\treturn &diter->base;\n}\n\nstatic int debug_read_raw_ref(struct ref_store *ref_store, const char *refname,\n\t\t\t      struct object_id *oid, struct strbuf *referent,\n\t\t\t      unsigned int *type)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;\n\tint res = 0;\n\n\toidcpy(oid, &null_oid);\n\terrno = 0;\n\tres = drefs->refs->be->read_raw_ref(drefs->refs, refname, oid, referent,\n\t\t\t\t\t    type);\n\n\tif (res == 0) {\n\t\ttrace_printf_key(&trace_refs, \"read_raw_ref: %s: %s (=> %s) type %x: %d\\n\",\n\t\t\trefname, oid_to_hex(oid), referent->buf, *type, res);\n\t} else {\n\t\ttrace_printf_key(&trace_refs,\n\t\t\t\t \"read_raw_ref: %s: %d (errno %d)\\n\", refname,\n\t\t\t\t res, errno);\n\t}\n\treturn res;\n}\n\nstatic struct ref_iterator *\ndebug_reflog_iterator_begin(struct ref_store *ref_store)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;\n\tstruct ref_iterator *res =\n\t\tdrefs->refs->be->reflog_iterator_begin(drefs->refs);\n\ttrace_printf_key(&trace_refs, \"for_each_reflog_iterator_begin\\n\");\n\treturn res;\n}\n\nstruct debug_reflog {\n\tconst char *refname;\n\teach_reflog_ent_fn *fn;\n\tvoid *cb_data;\n};\n\nstatic int debug_print_reflog_ent(struct object_id *old_oid,\n\t\t\t\t  struct object_id *new_oid,\n\t\t\t\t  const char *committer, timestamp_t timestamp,\n\t\t\t\t  int tz, const char *msg, void *cb_data)\n{\n\tstruct debug_reflog *dbg = (struct debug_reflog *)cb_data;\n\tint ret;\n\tchar o[GIT_MAX_HEXSZ + 1] = \"null\";\n\tchar n[GIT_MAX_HEXSZ + 1] = \"null\";\n\tif (old_oid)\n\t\toid_to_hex_r(o, old_oid);\n\tif (new_oid)\n\t\toid_to_hex_r(n, new_oid);\n\n\tret = dbg->fn(old_oid, new_oid, committer, timestamp, tz, msg,\n\t\t      dbg->cb_data);\n\ttrace_printf_key(&trace_refs, \"reflog_ent %s (ret %d): %s -> %s, %s %ld \\\"%s\\\"\\n\",\n\t\tdbg->refname, ret, o, n, committer, (long int)timestamp, msg);\n\treturn ret;\n}\n\nstatic int debug_for_each_reflog_ent(struct ref_store *ref_store,\n\t\t\t\t     const char *refname, each_reflog_ent_fn fn,\n\t\t\t\t     void *cb_data)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;\n\tstruct debug_reflog dbg = {\n\t\t.refname = refname,\n\t\t.fn = fn,\n\t\t.cb_data = cb_data,\n\t};\n\n\tint res = drefs->refs->be->for_each_reflog_ent(\n\t\tdrefs->refs, refname, &debug_print_reflog_ent, &dbg);\n\ttrace_printf_key(&trace_refs, \"for_each_reflog: %s: %d\\n\", refname, res);\n\treturn res;\n}\n\nstatic int debug_for_each_reflog_ent_reverse(struct ref_store *ref_store,\n\t\t\t\t\t     const char *refname,\n\t\t\t\t\t     each_reflog_ent_fn fn,\n\t\t\t\t\t     void *cb_data)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;\n\tstruct debug_reflog dbg = {\n\t\t.refname = refname,\n\t\t.fn = fn,\n\t\t.cb_data = cb_data,\n\t};\n\tint res = drefs->refs->be->for_each_reflog_ent_reverse(\n\t\tdrefs->refs, refname, &debug_print_reflog_ent, &dbg);\n\ttrace_printf_key(&trace_refs, \"for_each_reflog_reverse: %s: %d\\n\", refname, res);\n\treturn res;\n}\n\nstatic int debug_reflog_exists(struct ref_store *ref_store, const char *refname)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;\n\tint res = drefs->refs->be->reflog_exists(drefs->refs, refname);\n\ttrace_printf_key(&trace_refs, \"reflog_exists: %s: %d\\n\", refname, res);\n\treturn res;\n}\n\nstatic int debug_create_reflog(struct ref_store *ref_store, const char *refname,\n\t\t\t       int force_create, struct strbuf *err)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;\n\tint res = drefs->refs->be->create_reflog(drefs->refs, refname,\n\t\t\t\t\t\t force_create, err);\n\ttrace_printf_key(&trace_refs, \"create_reflog: %s: %d\\n\", refname, res);\n\treturn res;\n}\n\nstatic int debug_delete_reflog(struct ref_store *ref_store, const char *refname)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;\n\tint res = drefs->refs->be->delete_reflog(drefs->refs, refname);\n\ttrace_printf_key(&trace_refs, \"delete_reflog: %s: %d\\n\", refname, res);\n\treturn res;\n}\n\nstruct debug_reflog_expiry_should_prune {\n\treflog_expiry_prepare_fn *prepare;\n\treflog_expiry_should_prune_fn *should_prune;\n\treflog_expiry_cleanup_fn *cleanup;\n\tvoid *cb_data;\n};\n\nstatic void debug_reflog_expiry_prepare(const char *refname,\n\t\t\t\t    const struct object_id *oid,\n\t\t\t\t    void *cb_data)\n{\n\tstruct debug_reflog_expiry_should_prune *prune = cb_data;\n\ttrace_printf_key(&trace_refs, \"reflog_expire_prepare: %s\\n\", refname);\n\tprune->prepare(refname, oid, prune->cb_data);\n}\n\nstatic int debug_reflog_expiry_should_prune_fn(struct object_id *ooid,\n\t\t\t\t\t       struct object_id *noid,\n\t\t\t\t\t       const char *email,\n\t\t\t\t\t       timestamp_t timestamp, int tz,\n\t\t\t\t\t       const char *message, void *cb_data) {\n\tstruct debug_reflog_expiry_should_prune *prune = cb_data;\n\n\tint result = prune->should_prune(ooid, noid, email, timestamp, tz, message, prune->cb_data);\n\ttrace_printf_key(&trace_refs, \"reflog_expire_should_prune: %s %ld: %d\\n\", message, (long int) timestamp, result);\n\treturn result;\n}\n\nstatic void debug_reflog_expiry_cleanup(void *cb_data)\n{\n\tstruct debug_reflog_expiry_should_prune *prune = cb_data;\n\tprune->cleanup(prune->cb_data);\n}\n\nstatic int debug_reflog_expire(struct ref_store *ref_store, const char *refname,\n\t\t\t       const struct object_id *oid, unsigned int flags,\n\t\t\t       reflog_expiry_prepare_fn prepare_fn,\n\t\t\t       reflog_expiry_should_prune_fn should_prune_fn,\n\t\t\t       reflog_expiry_cleanup_fn cleanup_fn,\n\t\t\t       void *policy_cb_data)\n{\n\tstruct debug_ref_store *drefs = (struct debug_ref_store *)ref_store;\n\tstruct debug_reflog_expiry_should_prune prune = {\n\t\t.prepare = prepare_fn,\n\t\t.cleanup = cleanup_fn,\n\t\t.should_prune = should_prune_fn,\n\t\t.cb_data = policy_cb_data,\n\t};\n\tint res = drefs->refs->be->reflog_expire(drefs->refs, refname, oid,\n\t\t\t\t\t\t flags, &debug_reflog_expiry_prepare,\n\t\t\t\t\t\t &debug_reflog_expiry_should_prune_fn,\n\t\t\t\t\t\t &debug_reflog_expiry_cleanup,\n\t\t\t\t\t\t &prune);\n\ttrace_printf_key(&trace_refs, \"reflog_expire: %s: %d\\n\", refname, res);\n\treturn res;\n}\n\nstruct ref_storage_be refs_be_debug = {\n\tNULL,\n\t\"debug\",\n\tNULL,\n\tdebug_init_db,\n\tdebug_transaction_prepare,\n\tdebug_transaction_finish,\n\tdebug_transaction_abort,\n\tdebug_initial_transaction_commit,\n\n\tdebug_pack_refs,\n\tdebug_create_symref,\n\tdebug_delete_refs,\n\tdebug_rename_ref,\n\tdebug_copy_ref,\n\n\tdebug_ref_iterator_begin,\n\tdebug_read_raw_ref,\n\n\tdebug_reflog_iterator_begin,\n\tdebug_for_each_reflog_ent,\n\tdebug_for_each_reflog_ent_reverse,\n\tdebug_reflog_exists,\n\tdebug_create_reflog,\n\tdebug_delete_reflog,\n\tdebug_reflog_expire,\n};\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "001e30651c2c3d5313601c53ca3a783ce78d2c28",
  "sha1_ok": true,
  "size": 13892
}
