{
  "content": {
    "base64": "I2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAiYWR2aWNlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImNvbG9yLmgiCiNpbmNsdWRlICJlbnZpcm9ubWVudC5oIgojaW5jbHVkZSAiZ2V0dGV4dC5oIgojaW5jbHVkZSAiaGVscC5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKCnN0YXRpYyBlbnVtIGdpdF9jb2xvcmJvb2wgYWR2aWNlX3VzZV9jb2xvciA9IEdJVF9DT0xPUl9VTktOT1dOOwpzdGF0aWMgY2hhciBhZHZpY2VfY29sb3JzW11bQ09MT1JfTUFYTEVOXSA9IHsKCUdJVF9DT0xPUl9SRVNFVCwKCUdJVF9DT0xPUl9ZRUxMT1csCS8qIEhJTlQgKi8KfTsKCmVudW0gY29sb3JfYWR2aWNlIHsKCUFEVklDRV9DT0xPUl9SRVNFVCA9IDAsCglBRFZJQ0VfQ09MT1JfSElOVCA9IDEsCn07CgpzdGF0aWMgaW50IHBhcnNlX2FkdmlzZV9jb2xvcl9zbG90KGNvbnN0IGNoYXIgKnNsb3QpCnsKCWlmICghc3RyY2FzZWNtcChzbG90LCAicmVzZXQiKSkKCQlyZXR1cm4gQURWSUNFX0NPTE9SX1JFU0VUOwoJaWYgKCFzdHJjYXNlY21wKHNsb3QsICJoaW50IikpCgkJcmV0dXJuIEFEVklDRV9DT0xPUl9ISU5UOwoJcmV0dXJuIC0xOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqYWR2aXNlX2dldF9jb2xvcihlbnVtIGNvbG9yX2FkdmljZSBpeCkKewoJaWYgKHdhbnRfY29sb3Jfc3RkZXJyKGFkdmljZV91c2VfY29sb3IpKQoJCXJldHVybiBhZHZpY2VfY29sb3JzW2l4XTsKCXJldHVybiAiIjsKfQoKZW51bSBhZHZpY2VfbGV2ZWwgewoJQURWSUNFX0xFVkVMX05PTkUgPSAwLAoJQURWSUNFX0xFVkVMX0RJU0FCTEVELAoJQURWSUNFX0xFVkVMX0VOQUJMRUQsCn07CgpzdGF0aWMgc3RydWN0IHsKCWNvbnN0IGNoYXIgKmtleTsKCWVudW0gYWR2aWNlX2xldmVsIGxldmVsOwp9IGFkdmljZV9zZXR0aW5nW10gPSB7CglbQURWSUNFX0FERF9FTUJFRERFRF9SRVBPXQkJCT0geyAiYWRkRW1iZWRkZWRSZXBvIiB9LAoJW0FEVklDRV9BRERfRU1QVFlfUEFUSFNQRUNdCQkJPSB7ICJhZGRFbXB0eVBhdGhzcGVjIiB9LAoJW0FEVklDRV9BRERfSUdOT1JFRF9GSUxFXQkJCT0geyAiYWRkSWdub3JlZEZpbGUiIH0sCglbQURWSUNFX0FNQklHVU9VU19GRVRDSF9SRUZTUEVDXQkJPSB7ICJhbWJpZ3VvdXNGZXRjaFJlZnNwZWMiIH0sCglbQURWSUNFX0FNX1dPUktfRElSXSAJCQkJPSB7ICJhbVdvcmtEaXIiIH0sCglbQURWSUNFX0NIRUNLT1VUX0FNQklHVU9VU19SRU1PVEVfQlJBTkNIX05BTUVdIAk9IHsgImNoZWNrb3V0QW1iaWd1b3VzUmVtb3RlQnJhbmNoTmFtZSIgfSwKCVtBRFZJQ0VfQ09NTUlUX0JFRk9SRV9NRVJHRV0JCQk9IHsgImNvbW1pdEJlZm9yZU1lcmdlIiB9LAoJW0FEVklDRV9ERUZBVUxUX0JSQU5DSF9OQU1FXQkJCT0geyAiZGVmYXVsdEJyYW5jaE5hbWUiIH0sCglbQURWSUNFX0RFVEFDSEVEX0hFQURdCQkJCT0geyAiZGV0YWNoZWRIZWFkIiB9LAoJW0FEVklDRV9ESVZFUkdJTkddCQkJCT0geyAiZGl2ZXJnaW5nIiB9LAoJW0FEVklDRV9GRVRDSF9TRVRfSEVBRF9XQVJOXQkJCT0geyAiZmV0Y2hSZW1vdGVIRUFEV2FybiIgfSwKCVtBRFZJQ0VfRkVUQ0hfU0hPV19GT1JDRURfVVBEQVRFU10JCT0geyAiZmV0Y2hTaG93Rm9yY2VkVXBkYXRlcyIgfSwKCVtBRFZJQ0VfRk9SQ0VfREVMRVRFX0JSQU5DSF0JCQk9IHsgImZvcmNlRGVsZXRlQnJhbmNoIiB9LAoJW0FEVklDRV9HUkFGVF9GSUxFX0RFUFJFQ0FURURdCQkJPSB7ICJncmFmdEZpbGVEZXByZWNhdGVkIiB9LAoJW0FEVklDRV9JR05PUkVEX0hPT0tdCQkJCT0geyAiaWdub3JlZEhvb2siIH0sCglbQURWSUNFX0lNUExJQ0lUX0lERU5USVRZXQkJCT0geyAiaW1wbGljaXRJZGVudGl0eSIgfSwKCVtBRFZJQ0VfTUVSR0VfQ09ORkxJQ1RdCQkJCT0geyAibWVyZ2VDb25mbGljdCIgfSwKCVtBRFZJQ0VfTkVTVEVEX1RBR10JCQkJPSB7ICJuZXN0ZWRUYWciIH0sCglbQURWSUNFX09CSkVDVF9OQU1FX1dBUk5JTkddCQkJPSB7ICJvYmplY3ROYW1lV2FybmluZyIgfSwKCVtBRFZJQ0VfUFVTSF9BTFJFQURZX0VYSVNUU10JCQk9IHsgInB1c2hBbHJlYWR5RXhpc3RzIiB9LAoJW0FEVklDRV9QVVNIX0ZFVENIX0ZJUlNUXQkJCT0geyAicHVzaEZldGNoRmlyc3QiIH0sCglbQURWSUNFX1BVU0hfTkVFRFNfRk9SQ0VdCQkJPSB7ICJwdXNoTmVlZHNGb3JjZSIgfSwKCVtBRFZJQ0VfUFVTSF9OT05fRkZfQ1VSUkVOVF0JCQk9IHsgInB1c2hOb25GRkN1cnJlbnQiIH0sCglbQURWSUNFX1BVU0hfTk9OX0ZGX01BVENISU5HXQkJCT0geyAicHVzaE5vbkZGTWF0Y2hpbmciIH0sCglbQURWSUNFX1BVU0hfUkVGX05FRURTX1VQREFURV0JCQk9IHsgInB1c2hSZWZOZWVkc1VwZGF0ZSIgfSwKCVtBRFZJQ0VfUFVTSF9VTlFVQUxJRklFRF9SRUZfTkFNRV0JCT0geyAicHVzaFVucXVhbGlmaWVkUmVmTmFtZSIgfSwKCVtBRFZJQ0VfUFVTSF9VUERBVEVfUkVKRUNURURdCQkJPSB7ICJwdXNoVXBkYXRlUmVqZWN0ZWQiIH0sCglbQURWSUNFX1BVU0hfVVBEQVRFX1JFSkVDVEVEX0FMSUFTXQkJPSB7ICJwdXNoTm9uRmFzdEZvcndhcmQiIH0sIC8qIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5ICovCglbQURWSUNFX1JFQkFTRV9UT0RPX0VSUk9SXQkJCT0geyAicmViYXNlVG9kb0Vycm9yIiB9LAoJW0FEVklDRV9SRUZfU1lOVEFYXQkJCQk9IHsgInJlZlN5bnRheCIgfSwKCVtBRFZJQ0VfUkVTRVRfTk9fUkVGUkVTSF9XQVJOSU5HXQkJPSB7ICJyZXNldE5vUmVmcmVzaCIgfSwKCVtBRFZJQ0VfUkVTT0xWRV9DT05GTElDVF0JCQk9IHsgInJlc29sdmVDb25mbGljdCIgfSwKCVtBRFZJQ0VfUk1fSElOVFNdCQkJCT0geyAicm1IaW50cyIgfSwKCVtBRFZJQ0VfU0VRVUVOQ0VSX0lOX1VTRV0JCQk9IHsgInNlcXVlbmNlckluVXNlIiB9LAoJW0FEVklDRV9TRVRfVVBTVFJFQU1fRkFJTFVSRV0JCQk9IHsgInNldFVwc3RyZWFtRmFpbHVyZSIgfSwKCVtBRFZJQ0VfU0tJUFBFRF9DSEVSUllfUElDS1NdCQkJPSB7ICJza2lwcGVkQ2hlcnJ5UGlja3MiIH0sCglbQURWSUNFX1NQQVJTRV9JTkRFWF9FWFBBTkRFRF0JCQk9IHsgInNwYXJzZUluZGV4RXhwYW5kZWQiIH0sCglbQURWSUNFX1NUQVRVU19BSEVBRF9CRUhJTkRfV0FSTklOR10JCT0geyAic3RhdHVzQWhlYWRCZWhpbmRXYXJuaW5nIiB9LAoJW0FEVklDRV9TVEFUVVNfSElOVFNdCQkJCT0geyAic3RhdHVzSGludHMiIH0sCglbQURWSUNFX1NUQVRVU19VX09QVElPTl0JCQk9IHsgInN0YXR1c1VvcHRpb24iIH0sCglbQURWSUNFX1NVQk1PRFVMRVNfTk9UX1VQREFURURdIAkJPSB7ICJzdWJtb2R1bGVzTm90VXBkYXRlZCIgfSwKCVtBRFZJQ0VfU1VCTU9EVUxFX0FMVEVSTkFURV9FUlJPUl9TVFJBVEVHWV9ESUVdID0geyAic3VibW9kdWxlQWx0ZXJuYXRlRXJyb3JTdHJhdGVneURpZSIgfSwKCVtBRFZJQ0VfU1VCTU9EVUxFX01FUkdFX0NPTkZMSUNUXSAgICAgICAgICAgICAgID0geyAic3VibW9kdWxlTWVyZ2VDb25mbGljdCIgfSwKCVtBRFZJQ0VfU1VHR0VTVF9ERVRBQ0hJTkdfSEVBRF0JCQk9IHsgInN1Z2dlc3REZXRhY2hpbmdIZWFkIiB9LAoJW0FEVklDRV9VUERBVEVfU1BBUlNFX1BBVEhdCQkJPSB7ICJ1cGRhdGVTcGFyc2VQYXRoIiB9LAoJW0FEVklDRV9XQUlUSU5HX0ZPUl9FRElUT1JdCQkJPSB7ICJ3YWl0aW5nRm9yRWRpdG9yIiB9LAoJW0FEVklDRV9XT1JLVFJFRV9BRERfT1JQSEFOXQkJCT0geyAid29ya3RyZWVBZGRPcnBoYW4iIH0sCn07CgpzdGF0aWMgY29uc3QgY2hhciB0dXJuX29mZl9pbnN0cnVjdGlvbnNbXSA9Ck5fKCJcbiIKICAgIkRpc2FibGUgdGhpcyBtZXNzYWdlIHdpdGggXCJnaXQgY29uZmlnIHNldCBhZHZpY2UuJXMgZmFsc2VcIiIpOwoKc3RhdGljIHZvaWQgdmFkdmlzZShjb25zdCBjaGFyICphZHZpY2UsIGludCBkaXNwbGF5X2luc3RydWN0aW9ucywKCQkgICAgY29uc3QgY2hhciAqa2V5LCB2YV9saXN0IHBhcmFtcykKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKmNwLCAqbnA7CgoJc3RyYnVmX3ZhZGRmKCZidWYsIGFkdmljZSwgcGFyYW1zKTsKCglpZiAoZGlzcGxheV9pbnN0cnVjdGlvbnMpCgkJc3RyYnVmX2FkZGYoJmJ1ZiwgdHVybl9vZmZfaW5zdHJ1Y3Rpb25zLCBrZXkpOwoKCWZvciAoY3AgPSBidWYuYnVmOyAqY3A7IGNwID0gbnApIHsKCQlucCA9IHN0cmNocm51bChjcCwgJ1xuJyk7CgkJZnByaW50ZihzdGRlcnIsCV8oIiVzaGludDolcyUuKnMlc1xuIiksCgkJCWFkdmlzZV9nZXRfY29sb3IoQURWSUNFX0NPTE9SX0hJTlQpLAoJCQkobnAgPT0gY3ApID8gIiIgOiAiICIsCgkJCShpbnQpKG5wIC0gY3ApLCBjcCwKCQkJYWR2aXNlX2dldF9jb2xvcihBRFZJQ0VfQ09MT1JfUkVTRVQpKTsKCQlpZiAoKm5wKQoJCQlucCsrOwoJfQoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7Cn0KCnZvaWQgYWR2aXNlKGNvbnN0IGNoYXIgKmFkdmljZSwgLi4uKQp7Cgl2YV9saXN0IHBhcmFtczsKCXZhX3N0YXJ0KHBhcmFtcywgYWR2aWNlKTsKCXZhZHZpc2UoYWR2aWNlLCAwLCAiIiwgcGFyYW1zKTsKCXZhX2VuZChwYXJhbXMpOwp9CgppbnQgYWR2aWNlX2VuYWJsZWQoZW51bSBhZHZpY2VfdHlwZSB0eXBlKQp7CglpbnQgZW5hYmxlZCA9IGFkdmljZV9zZXR0aW5nW3R5cGVdLmxldmVsICE9IEFEVklDRV9MRVZFTF9ESVNBQkxFRDsKCXN0YXRpYyBpbnQgZ2xvYmFsbHlfZW5hYmxlZCA9IC0xOwoKCWlmIChnbG9iYWxseV9lbmFibGVkIDwgMCkKCQlnbG9iYWxseV9lbmFibGVkID0gZ2l0X2Vudl9ib29sKEdJVF9BRFZJQ0VfRU5WSVJPTk1FTlQsIDEpOwoJaWYgKCFnbG9iYWxseV9lbmFibGVkKQoJCXJldHVybiAwOwoKCWlmICh0eXBlID09IEFEVklDRV9QVVNIX1VQREFURV9SRUpFQ1RFRCkKCQlyZXR1cm4gZW5hYmxlZCAmJgoJCSAgICAgICBhZHZpY2VfZW5hYmxlZChBRFZJQ0VfUFVTSF9VUERBVEVfUkVKRUNURURfQUxJQVMpOwoKCXJldHVybiBlbmFibGVkOwp9Cgp2b2lkIGFkdmlzZV9pZl9lbmFibGVkKGVudW0gYWR2aWNlX3R5cGUgdHlwZSwgY29uc3QgY2hhciAqYWR2aWNlLCAuLi4pCnsKCXZhX2xpc3QgcGFyYW1zOwoKCWlmICghYWR2aWNlX2VuYWJsZWQodHlwZSkpCgkJcmV0dXJuOwoKCXZhX3N0YXJ0KHBhcmFtcywgYWR2aWNlKTsKCXZhZHZpc2UoYWR2aWNlLCAhYWR2aWNlX3NldHRpbmdbdHlwZV0ubGV2ZWwsIGFkdmljZV9zZXR0aW5nW3R5cGVdLmtleSwKCQlwYXJhbXMpOwoJdmFfZW5kKHBhcmFtcyk7Cn0KCmludCBnaXRfZGVmYXVsdF9hZHZpY2VfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUpCnsKCWNvbnN0IGNoYXIgKmssICpzbG90X25hbWU7CgoJaWYgKCFzdHJjbXAodmFyLCAiY29sb3IuYWR2aWNlIikpIHsKCQlhZHZpY2VfdXNlX2NvbG9yID0gZ2l0X2NvbmZpZ19jb2xvcmJvb2wodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKHNraXBfcHJlZml4KHZhciwgImNvbG9yLmFkdmljZS4iLCAmc2xvdF9uYW1lKSkgewoJCWludCBzbG90ID0gcGFyc2VfYWR2aXNlX2NvbG9yX3Nsb3Qoc2xvdF9uYW1lKTsKCQlpZiAoc2xvdCA8IDApCgkJCXJldHVybiAwOwoJCWlmICghdmFsdWUpCgkJCXJldHVybiBjb25maWdfZXJyb3Jfbm9uYm9vbCh2YXIpOwoJCXJldHVybiBjb2xvcl9wYXJzZSh2YWx1ZSwgYWR2aWNlX2NvbG9yc1tzbG90XSk7Cgl9CgoJaWYgKCFza2lwX3ByZWZpeCh2YXIsICJhZHZpY2UuIiwgJmspKQoJCXJldHVybiAwOwoKCWZvciAoc2l6ZV90IGkgPSAwOyBpIDwgQVJSQVlfU0laRShhZHZpY2Vfc2V0dGluZyk7IGkrKykgewoJCWlmIChzdHJjYXNlY21wKGssIGFkdmljZV9zZXR0aW5nW2ldLmtleSkpCgkJCWNvbnRpbnVlOwoJCWFkdmljZV9zZXR0aW5nW2ldLmxldmVsID0gZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpCgkJCQkJICA/IEFEVklDRV9MRVZFTF9FTkFCTEVECgkJCQkJICA6IEFEVklDRV9MRVZFTF9ESVNBQkxFRDsKCQlyZXR1cm4gMDsKCX0KCglyZXR1cm4gMDsKfQoKdm9pZCBsaXN0X2NvbmZpZ19hZHZpY2VzKHN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCwgY29uc3QgY2hhciAqcHJlZml4KQp7Cglmb3IgKHNpemVfdCBpID0gMDsgaSA8IEFSUkFZX1NJWkUoYWR2aWNlX3NldHRpbmcpOyBpKyspCgkJbGlzdF9jb25maWdfaXRlbShsaXN0LCBwcmVmaXgsIGFkdmljZV9zZXR0aW5nW2ldLmtleSk7Cn0KCmludCBlcnJvcl9yZXNvbHZlX2NvbmZsaWN0KGNvbnN0IGNoYXIgKm1lKQp7CglpZiAoIXN0cmNtcChtZSwgImNoZXJyeS1waWNrIikpCgkJZXJyb3IoXygiQ2hlcnJ5LXBpY2tpbmcgaXMgbm90IHBvc3NpYmxlIGJlY2F1c2UgeW91IGhhdmUgdW5tZXJnZWQgZmlsZXMuIikpOwoJZWxzZSBpZiAoIXN0cmNtcChtZSwgImNvbW1pdCIpKQoJCWVycm9yKF8oIkNvbW1pdHRpbmcgaXMgbm90IHBvc3NpYmxlIGJlY2F1c2UgeW91IGhhdmUgdW5tZXJnZWQgZmlsZXMuIikpOwoJZWxzZSBpZiAoIXN0cmNtcChtZSwgIm1lcmdlIikpCgkJZXJyb3IoXygiTWVyZ2luZyBpcyBub3QgcG9zc2libGUgYmVjYXVzZSB5b3UgaGF2ZSB1bm1lcmdlZCBmaWxlcy4iKSk7CgllbHNlIGlmICghc3RyY21wKG1lLCAicHVsbCIpKQoJCWVycm9yKF8oIlB1bGxpbmcgaXMgbm90IHBvc3NpYmxlIGJlY2F1c2UgeW91IGhhdmUgdW5tZXJnZWQgZmlsZXMuIikpOwoJZWxzZSBpZiAoIXN0cmNtcChtZSwgInJldmVydCIpKQoJCWVycm9yKF8oIlJldmVydGluZyBpcyBub3QgcG9zc2libGUgYmVjYXVzZSB5b3UgaGF2ZSB1bm1lcmdlZCBmaWxlcy4iKSk7CgllbHNlIGlmICghc3RyY21wKG1lLCAicmViYXNlIikpCgkJZXJyb3IoXygiUmViYXNpbmcgaXMgbm90IHBvc3NpYmxlIGJlY2F1c2UgeW91IGhhdmUgdW5tZXJnZWQgZmlsZXMuIikpOwoJZWxzZQoJCUJVRygiVW5oYW5kbGVkIGNvbmZsaWN0IHJlYXNvbiAnJXMnIiwgbWUpOwoKCWlmIChhZHZpY2VfZW5hYmxlZChBRFZJQ0VfUkVTT0xWRV9DT05GTElDVCkpCgkJLyoKCQkgKiBNZXNzYWdlIHVzZWQgYm90aCB3aGVuICdnaXQgY29tbWl0JyBmYWlscyBhbmQgd2hlbgoJCSAqIG90aGVyIGNvbW1hbmRzIGRvaW5nIGEgbWVyZ2UgZG8uCgkJICovCgkJYWR2aXNlKF8oIkZpeCB0aGVtIHVwIGluIHRoZSB3b3JrIHRyZWUsIGFuZCB0aGVuIHVzZSAnZ2l0IGFkZC9ybSA8ZmlsZT4nXG4iCgkJCSAiYXMgYXBwcm9wcmlhdGUgdG8gbWFyayByZXNvbHV0aW9uIGFuZCBtYWtlIGEgY29tbWl0LiIpKTsKCXJldHVybiAtMTsKfQoKdm9pZCBOT1JFVFVSTiBkaWVfcmVzb2x2ZV9jb25mbGljdChjb25zdCBjaGFyICptZSkKewoJZXJyb3JfcmVzb2x2ZV9jb25mbGljdChtZSk7CglkaWUoXygiRXhpdGluZyBiZWNhdXNlIG9mIGFuIHVucmVzb2x2ZWQgY29uZmxpY3QuIikpOwp9Cgp2b2lkIE5PUkVUVVJOIGRpZV9jb25jbHVkZV9tZXJnZSh2b2lkKQp7CgllcnJvcihfKCJZb3UgaGF2ZSBub3QgY29uY2x1ZGVkIHlvdXIgbWVyZ2UgKE1FUkdFX0hFQUQgZXhpc3RzKS4iKSk7CglpZiAoYWR2aWNlX2VuYWJsZWQoQURWSUNFX1JFU09MVkVfQ09ORkxJQ1QpKQoJCWFkdmlzZShfKCJQbGVhc2UsIGNvbW1pdCB5b3VyIGNoYW5nZXMgYmVmb3JlIG1lcmdpbmcuIikpOwoJZGllKF8oIkV4aXRpbmcgYmVjYXVzZSBvZiB1bmZpbmlzaGVkIG1lcmdlLiIpKTsKfQoKdm9pZCBOT1JFVFVSTiBkaWVfZmZfaW1wb3NzaWJsZSh2b2lkKQp7CglhZHZpc2VfaWZfZW5hYmxlZChBRFZJQ0VfRElWRVJHSU5HLAoJCV8oIkRpdmVyZ2luZyBicmFuY2hlcyBjYW4ndCBiZSBmYXN0LWZvcndhcmRlZCwgeW91IG5lZWQgdG8gZWl0aGVyOlxuIgoJCSJcbiIKCQkiXHRnaXQgbWVyZ2UgLS1uby1mZlxuIgoJCSJcbiIKCQkib3I6XG4iCgkJIlxuIgoJCSJcdGdpdCByZWJhc2VcbiIpKTsKCWRpZShfKCJOb3QgcG9zc2libGUgdG8gZmFzdC1mb3J3YXJkLCBhYm9ydGluZy4iKSk7Cn0KCnZvaWQgYWR2aXNlX29uX3VwZGF0aW5nX3NwYXJzZV9wYXRocyhzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnBhdGhzcGVjX2xpc3QpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoKCWlmICghcGF0aHNwZWNfbGlzdC0+bnIpCgkJcmV0dXJuOwoKCWZwcmludGYoc3RkZXJyLCBfKCJUaGUgZm9sbG93aW5nIHBhdGhzIGFuZC9vciBwYXRoc3BlY3MgbWF0Y2hlZCBwYXRocyB0aGF0IGV4aXN0XG4iCgkJCSAgIm91dHNpZGUgb2YgeW91ciBzcGFyc2UtY2hlY2tvdXQgZGVmaW5pdGlvbiwgc28gd2lsbCBub3QgYmVcbiIKCQkJICAidXBkYXRlZCBpbiB0aGUgaW5kZXg6XG4iKSk7Cglmb3JfZWFjaF9zdHJpbmdfbGlzdF9pdGVtKGl0ZW0sIHBhdGhzcGVjX2xpc3QpCgkJZnByaW50ZihzdGRlcnIsICIlc1xuIiwgaXRlbS0+c3RyaW5nKTsKCglhZHZpc2VfaWZfZW5hYmxlZChBRFZJQ0VfVVBEQVRFX1NQQVJTRV9QQVRILAoJCQkgIF8oIklmIHlvdSBpbnRlbmQgdG8gdXBkYXRlIHN1Y2ggZW50cmllcywgdHJ5IG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuIgoJCQkgICAgIiogVXNlIHRoZSAtLXNwYXJzZSBvcHRpb24uXG4iCgkJCSAgICAiKiBEaXNhYmxlIG9yIG1vZGlmeSB0aGUgc3BhcnNpdHkgcnVsZXMuIikpOwp9Cgp2b2lkIGRldGFjaF9hZHZpY2UoY29uc3QgY2hhciAqbmV3X25hbWUpCnsKCWNvbnN0IGNoYXIgKmZtdCA9CglfKCJOb3RlOiBzd2l0Y2hpbmcgdG8gJyVzJy5cbiIKCSJcbiIKCSJZb3UgYXJlIGluICdkZXRhY2hlZCBIRUFEJyBzdGF0ZS4gWW91IGNhbiBsb29rIGFyb3VuZCwgbWFrZSBleHBlcmltZW50YWxcbiIKCSJjaGFuZ2VzIGFuZCBjb21taXQgdGhlbSwgYW5kIHlvdSBjYW4gZGlzY2FyZCBhbnkgY29tbWl0cyB5b3UgbWFrZSBpbiB0aGlzXG4iCgkic3RhdGUgd2l0aG91dCBpbXBhY3RpbmcgYW55IGJyYW5jaGVzIGJ5IHN3aXRjaGluZyBiYWNrIHRvIGEgYnJhbmNoLlxuIgoJIlxuIgoJIklmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIG5ldyBicmFuY2ggdG8gcmV0YWluIGNvbW1pdHMgeW91IGNyZWF0ZSwgeW91IG1heVxuIgoJImRvIHNvIChub3cgb3IgbGF0ZXIpIGJ5IHVzaW5nIC1jIHdpdGggdGhlIHN3aXRjaCBjb21tYW5kLiBFeGFtcGxlOlxuIgoJIlxuIgoJIiAgZ2l0IHN3aXRjaCAtYyA8bmV3LWJyYW5jaC1uYW1lPlxuIgoJIlxuIgoJIk9yIHVuZG8gdGhpcyBvcGVyYXRpb24gd2l0aDpcbiIKCSJcbiIKCSIgIGdpdCBzd2l0Y2ggLVxuIgoJIlxuIgoJIlR1cm4gb2ZmIHRoaXMgYWR2aWNlIGJ5IHNldHRpbmcgY29uZmlnIHZhcmlhYmxlIGFkdmljZS5kZXRhY2hlZEhlYWQgdG8gZmFsc2VcblxuIik7CgoJZnByaW50ZihzdGRlcnIsIGZtdCwgbmV3X25hbWUpOwp9Cgp2b2lkIGFkdmlzZV9vbl9tb3ZpbmdfZGlydHlfcGF0aChzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnBhdGhzcGVjX2xpc3QpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoKCWlmICghcGF0aHNwZWNfbGlzdC0+bnIpCgkJcmV0dXJuOwoKCWZwcmludGYoc3RkZXJyLCBfKCJUaGUgZm9sbG93aW5nIHBhdGhzIGhhdmUgYmVlbiBtb3ZlZCBvdXRzaWRlIHRoZVxuIgoJCQkgICJzcGFyc2UtY2hlY2tvdXQgZGVmaW5pdGlvbiBidXQgYXJlIG5vdCBzcGFyc2UgZHVlIHRvIGxvY2FsXG4iCgkJCSAgIm1vZGlmaWNhdGlvbnMuXG4iKSk7Cglmb3JfZWFjaF9zdHJpbmdfbGlzdF9pdGVtKGl0ZW0sIHBhdGhzcGVjX2xpc3QpCgkJZnByaW50ZihzdGRlcnIsICIlc1xuIiwgaXRlbS0+c3RyaW5nKTsKCglhZHZpc2VfaWZfZW5hYmxlZChBRFZJQ0VfVVBEQVRFX1NQQVJTRV9QQVRILAoJCQkgIF8oIlRvIGNvcnJlY3QgdGhlIHNwYXJzaXR5IG9mIHRoZXNlIHBhdGhzLCBkbyB0aGUgZm9sbG93aW5nOlxuIgoJCQkgICAgIiogVXNlIFwiZ2l0IGFkZCAtLXNwYXJzZSA8cGF0aHM+XCIgdG8gdXBkYXRlIHRoZSBpbmRleFxuIgoJCQkgICAgIiogVXNlIFwiZ2l0IHNwYXJzZS1jaGVja291dCByZWFwcGx5XCIgdG8gYXBwbHkgdGhlIHNwYXJzaXR5IHJ1bGVzIikpOwp9Cg==",
    "text": "#include \"git-compat-util.h\"\n#include \"advice.h\"\n#include \"config.h\"\n#include \"color.h\"\n#include \"environment.h\"\n#include \"gettext.h\"\n#include \"help.h\"\n#include \"string-list.h\"\n\nstatic enum git_colorbool advice_use_color = GIT_COLOR_UNKNOWN;\nstatic char advice_colors[][COLOR_MAXLEN] = {\n\tGIT_COLOR_RESET,\n\tGIT_COLOR_YELLOW,\t/* HINT */\n};\n\nenum color_advice {\n\tADVICE_COLOR_RESET = 0,\n\tADVICE_COLOR_HINT = 1,\n};\n\nstatic int parse_advise_color_slot(const char *slot)\n{\n\tif (!strcasecmp(slot, \"reset\"))\n\t\treturn ADVICE_COLOR_RESET;\n\tif (!strcasecmp(slot, \"hint\"))\n\t\treturn ADVICE_COLOR_HINT;\n\treturn -1;\n}\n\nstatic const char *advise_get_color(enum color_advice ix)\n{\n\tif (want_color_stderr(advice_use_color))\n\t\treturn advice_colors[ix];\n\treturn \"\";\n}\n\nenum advice_level {\n\tADVICE_LEVEL_NONE = 0,\n\tADVICE_LEVEL_DISABLED,\n\tADVICE_LEVEL_ENABLED,\n};\n\nstatic struct {\n\tconst char *key;\n\tenum advice_level level;\n} advice_setting[] = {\n\t[ADVICE_ADD_EMBEDDED_REPO]\t\t\t= { \"addEmbeddedRepo\" },\n\t[ADVICE_ADD_EMPTY_PATHSPEC]\t\t\t= { \"addEmptyPathspec\" },\n\t[ADVICE_ADD_IGNORED_FILE]\t\t\t= { \"addIgnoredFile\" },\n\t[ADVICE_AMBIGUOUS_FETCH_REFSPEC]\t\t= { \"ambiguousFetchRefspec\" },\n\t[ADVICE_AM_WORK_DIR] \t\t\t\t= { \"amWorkDir\" },\n\t[ADVICE_CHECKOUT_AMBIGUOUS_REMOTE_BRANCH_NAME] \t= { \"checkoutAmbiguousRemoteBranchName\" },\n\t[ADVICE_COMMIT_BEFORE_MERGE]\t\t\t= { \"commitBeforeMerge\" },\n\t[ADVICE_DEFAULT_BRANCH_NAME]\t\t\t= { \"defaultBranchName\" },\n\t[ADVICE_DETACHED_HEAD]\t\t\t\t= { \"detachedHead\" },\n\t[ADVICE_DIVERGING]\t\t\t\t= { \"diverging\" },\n\t[ADVICE_FETCH_SET_HEAD_WARN]\t\t\t= { \"fetchRemoteHEADWarn\" },\n\t[ADVICE_FETCH_SHOW_FORCED_UPDATES]\t\t= { \"fetchShowForcedUpdates\" },\n\t[ADVICE_FORCE_DELETE_BRANCH]\t\t\t= { \"forceDeleteBranch\" },\n\t[ADVICE_GRAFT_FILE_DEPRECATED]\t\t\t= { \"graftFileDeprecated\" },\n\t[ADVICE_IGNORED_HOOK]\t\t\t\t= { \"ignoredHook\" },\n\t[ADVICE_IMPLICIT_IDENTITY]\t\t\t= { \"implicitIdentity\" },\n\t[ADVICE_MERGE_CONFLICT]\t\t\t\t= { \"mergeConflict\" },\n\t[ADVICE_NESTED_TAG]\t\t\t\t= { \"nestedTag\" },\n\t[ADVICE_OBJECT_NAME_WARNING]\t\t\t= { \"objectNameWarning\" },\n\t[ADVICE_PUSH_ALREADY_EXISTS]\t\t\t= { \"pushAlreadyExists\" },\n\t[ADVICE_PUSH_FETCH_FIRST]\t\t\t= { \"pushFetchFirst\" },\n\t[ADVICE_PUSH_NEEDS_FORCE]\t\t\t= { \"pushNeedsForce\" },\n\t[ADVICE_PUSH_NON_FF_CURRENT]\t\t\t= { \"pushNonFFCurrent\" },\n\t[ADVICE_PUSH_NON_FF_MATCHING]\t\t\t= { \"pushNonFFMatching\" },\n\t[ADVICE_PUSH_REF_NEEDS_UPDATE]\t\t\t= { \"pushRefNeedsUpdate\" },\n\t[ADVICE_PUSH_UNQUALIFIED_REF_NAME]\t\t= { \"pushUnqualifiedRefName\" },\n\t[ADVICE_PUSH_UPDATE_REJECTED]\t\t\t= { \"pushUpdateRejected\" },\n\t[ADVICE_PUSH_UPDATE_REJECTED_ALIAS]\t\t= { \"pushNonFastForward\" }, /* backwards compatibility */\n\t[ADVICE_REBASE_TODO_ERROR]\t\t\t= { \"rebaseTodoError\" },\n\t[ADVICE_REF_SYNTAX]\t\t\t\t= { \"refSyntax\" },\n\t[ADVICE_RESET_NO_REFRESH_WARNING]\t\t= { \"resetNoRefresh\" },\n\t[ADVICE_RESOLVE_CONFLICT]\t\t\t= { \"resolveConflict\" },\n\t[ADVICE_RM_HINTS]\t\t\t\t= { \"rmHints\" },\n\t[ADVICE_SEQUENCER_IN_USE]\t\t\t= { \"sequencerInUse\" },\n\t[ADVICE_SET_UPSTREAM_FAILURE]\t\t\t= { \"setUpstreamFailure\" },\n\t[ADVICE_SKIPPED_CHERRY_PICKS]\t\t\t= { \"skippedCherryPicks\" },\n\t[ADVICE_SPARSE_INDEX_EXPANDED]\t\t\t= { \"sparseIndexExpanded\" },\n\t[ADVICE_STATUS_AHEAD_BEHIND_WARNING]\t\t= { \"statusAheadBehindWarning\" },\n\t[ADVICE_STATUS_HINTS]\t\t\t\t= { \"statusHints\" },\n\t[ADVICE_STATUS_U_OPTION]\t\t\t= { \"statusUoption\" },\n\t[ADVICE_SUBMODULES_NOT_UPDATED] \t\t= { \"submodulesNotUpdated\" },\n\t[ADVICE_SUBMODULE_ALTERNATE_ERROR_STRATEGY_DIE] = { \"submoduleAlternateErrorStrategyDie\" },\n\t[ADVICE_SUBMODULE_MERGE_CONFLICT]               = { \"submoduleMergeConflict\" },\n\t[ADVICE_SUGGEST_DETACHING_HEAD]\t\t\t= { \"suggestDetachingHead\" },\n\t[ADVICE_UPDATE_SPARSE_PATH]\t\t\t= { \"updateSparsePath\" },\n\t[ADVICE_WAITING_FOR_EDITOR]\t\t\t= { \"waitingForEditor\" },\n\t[ADVICE_WORKTREE_ADD_ORPHAN]\t\t\t= { \"worktreeAddOrphan\" },\n};\n\nstatic const char turn_off_instructions[] =\nN_(\"\\n\"\n   \"Disable this message with \\\"git config set advice.%s false\\\"\");\n\nstatic void vadvise(const char *advice, int display_instructions,\n\t\t    const char *key, va_list params)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *cp, *np;\n\n\tstrbuf_vaddf(&buf, advice, params);\n\n\tif (display_instructions)\n\t\tstrbuf_addf(&buf, turn_off_instructions, key);\n\n\tfor (cp = buf.buf; *cp; cp = np) {\n\t\tnp = strchrnul(cp, '\\n');\n\t\tfprintf(stderr,\t_(\"%shint:%s%.*s%s\\n\"),\n\t\t\tadvise_get_color(ADVICE_COLOR_HINT),\n\t\t\t(np == cp) ? \"\" : \" \",\n\t\t\t(int)(np - cp), cp,\n\t\t\tadvise_get_color(ADVICE_COLOR_RESET));\n\t\tif (*np)\n\t\t\tnp++;\n\t}\n\tstrbuf_release(&buf);\n}\n\nvoid advise(const char *advice, ...)\n{\n\tva_list params;\n\tva_start(params, advice);\n\tvadvise(advice, 0, \"\", params);\n\tva_end(params);\n}\n\nint advice_enabled(enum advice_type type)\n{\n\tint enabled = advice_setting[type].level != ADVICE_LEVEL_DISABLED;\n\tstatic int globally_enabled = -1;\n\n\tif (globally_enabled < 0)\n\t\tglobally_enabled = git_env_bool(GIT_ADVICE_ENVIRONMENT, 1);\n\tif (!globally_enabled)\n\t\treturn 0;\n\n\tif (type == ADVICE_PUSH_UPDATE_REJECTED)\n\t\treturn enabled &&\n\t\t       advice_enabled(ADVICE_PUSH_UPDATE_REJECTED_ALIAS);\n\n\treturn enabled;\n}\n\nvoid advise_if_enabled(enum advice_type type, const char *advice, ...)\n{\n\tva_list params;\n\n\tif (!advice_enabled(type))\n\t\treturn;\n\n\tva_start(params, advice);\n\tvadvise(advice, !advice_setting[type].level, advice_setting[type].key,\n\t\tparams);\n\tva_end(params);\n}\n\nint git_default_advice_config(const char *var, const char *value)\n{\n\tconst char *k, *slot_name;\n\n\tif (!strcmp(var, \"color.advice\")) {\n\t\tadvice_use_color = git_config_colorbool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (skip_prefix(var, \"color.advice.\", &slot_name)) {\n\t\tint slot = parse_advise_color_slot(slot_name);\n\t\tif (slot < 0)\n\t\t\treturn 0;\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\treturn color_parse(value, advice_colors[slot]);\n\t}\n\n\tif (!skip_prefix(var, \"advice.\", &k))\n\t\treturn 0;\n\n\tfor (size_t i = 0; i < ARRAY_SIZE(advice_setting); i++) {\n\t\tif (strcasecmp(k, advice_setting[i].key))\n\t\t\tcontinue;\n\t\tadvice_setting[i].level = git_config_bool(var, value)\n\t\t\t\t\t  ? ADVICE_LEVEL_ENABLED\n\t\t\t\t\t  : ADVICE_LEVEL_DISABLED;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nvoid list_config_advices(struct string_list *list, const char *prefix)\n{\n\tfor (size_t i = 0; i < ARRAY_SIZE(advice_setting); i++)\n\t\tlist_config_item(list, prefix, advice_setting[i].key);\n}\n\nint error_resolve_conflict(const char *me)\n{\n\tif (!strcmp(me, \"cherry-pick\"))\n\t\terror(_(\"Cherry-picking is not possible because you have unmerged files.\"));\n\telse if (!strcmp(me, \"commit\"))\n\t\terror(_(\"Committing is not possible because you have unmerged files.\"));\n\telse if (!strcmp(me, \"merge\"))\n\t\terror(_(\"Merging is not possible because you have unmerged files.\"));\n\telse if (!strcmp(me, \"pull\"))\n\t\terror(_(\"Pulling is not possible because you have unmerged files.\"));\n\telse if (!strcmp(me, \"revert\"))\n\t\terror(_(\"Reverting is not possible because you have unmerged files.\"));\n\telse if (!strcmp(me, \"rebase\"))\n\t\terror(_(\"Rebasing is not possible because you have unmerged files.\"));\n\telse\n\t\tBUG(\"Unhandled conflict reason '%s'\", me);\n\n\tif (advice_enabled(ADVICE_RESOLVE_CONFLICT))\n\t\t/*\n\t\t * Message used both when 'git commit' fails and when\n\t\t * other commands doing a merge do.\n\t\t */\n\t\tadvise(_(\"Fix them up in the work tree, and then use 'git add/rm <file>'\\n\"\n\t\t\t \"as appropriate to mark resolution and make a commit.\"));\n\treturn -1;\n}\n\nvoid NORETURN die_resolve_conflict(const char *me)\n{\n\terror_resolve_conflict(me);\n\tdie(_(\"Exiting because of an unresolved conflict.\"));\n}\n\nvoid NORETURN die_conclude_merge(void)\n{\n\terror(_(\"You have not concluded your merge (MERGE_HEAD exists).\"));\n\tif (advice_enabled(ADVICE_RESOLVE_CONFLICT))\n\t\tadvise(_(\"Please, commit your changes before merging.\"));\n\tdie(_(\"Exiting because of unfinished merge.\"));\n}\n\nvoid NORETURN die_ff_impossible(void)\n{\n\tadvise_if_enabled(ADVICE_DIVERGING,\n\t\t_(\"Diverging branches can't be fast-forwarded, you need to either:\\n\"\n\t\t\"\\n\"\n\t\t\"\\tgit merge --no-ff\\n\"\n\t\t\"\\n\"\n\t\t\"or:\\n\"\n\t\t\"\\n\"\n\t\t\"\\tgit rebase\\n\"));\n\tdie(_(\"Not possible to fast-forward, aborting.\"));\n}\n\nvoid advise_on_updating_sparse_paths(struct string_list *pathspec_list)\n{\n\tstruct string_list_item *item;\n\n\tif (!pathspec_list->nr)\n\t\treturn;\n\n\tfprintf(stderr, _(\"The following paths and/or pathspecs matched paths that exist\\n\"\n\t\t\t  \"outside of your sparse-checkout definition, so will not be\\n\"\n\t\t\t  \"updated in the index:\\n\"));\n\tfor_each_string_list_item(item, pathspec_list)\n\t\tfprintf(stderr, \"%s\\n\", item->string);\n\n\tadvise_if_enabled(ADVICE_UPDATE_SPARSE_PATH,\n\t\t\t  _(\"If you intend to update such entries, try one of the following:\\n\"\n\t\t\t    \"* Use the --sparse option.\\n\"\n\t\t\t    \"* Disable or modify the sparsity rules.\"));\n}\n\nvoid detach_advice(const char *new_name)\n{\n\tconst char *fmt =\n\t_(\"Note: switching to '%s'.\\n\"\n\t\"\\n\"\n\t\"You are in 'detached HEAD' state. You can look around, make experimental\\n\"\n\t\"changes and commit them, and you can discard any commits you make in this\\n\"\n\t\"state without impacting any branches by switching back to a branch.\\n\"\n\t\"\\n\"\n\t\"If you want to create a new branch to retain commits you create, you may\\n\"\n\t\"do so (now or later) by using -c with the switch command. Example:\\n\"\n\t\"\\n\"\n\t\"  git switch -c <new-branch-name>\\n\"\n\t\"\\n\"\n\t\"Or undo this operation with:\\n\"\n\t\"\\n\"\n\t\"  git switch -\\n\"\n\t\"\\n\"\n\t\"Turn off this advice by setting config variable advice.detachedHead to false\\n\\n\");\n\n\tfprintf(stderr, fmt, new_name);\n}\n\nvoid advise_on_moving_dirty_path(struct string_list *pathspec_list)\n{\n\tstruct string_list_item *item;\n\n\tif (!pathspec_list->nr)\n\t\treturn;\n\n\tfprintf(stderr, _(\"The following paths have been moved outside the\\n\"\n\t\t\t  \"sparse-checkout definition but are not sparse due to local\\n\"\n\t\t\t  \"modifications.\\n\"));\n\tfor_each_string_list_item(item, pathspec_list)\n\t\tfprintf(stderr, \"%s\\n\", item->string);\n\n\tadvise_if_enabled(ADVICE_UPDATE_SPARSE_PATH,\n\t\t\t  _(\"To correct the sparsity of these paths, do the following:\\n\"\n\t\t\t    \"* Use \\\"git add --sparse <paths>\\\" to update the index\\n\"\n\t\t\t    \"* Use \\\"git sparse-checkout reapply\\\" to apply the sparsity rules\"));\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0018501b7bc103267ac32c94f8869944a921d3de",
  "sha1_ok": true,
  "size": 9922
}
