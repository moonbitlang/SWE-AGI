{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImNvbG9yLmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCgpzdGF0aWMgY29uc3QgY2hhciogc2hvd19icmFuY2hfdXNhZ2VbXSA9IHsKICAgIE5fKCJnaXQgc2hvdy1icmFuY2ggWy1hfC0tYWxsXSBbLXJ8LS1yZW1vdGVzXSBbLS10b3BvLW9yZGVyIHwgLS1kYXRlLW9yZGVyXSBbLS1jdXJyZW50XSBbLS1jb2xvcls9PHdoZW4+XSB8IC0tbm8tY29sb3JdIFstLXNwYXJzZV0gWy0tbW9yZT08bj4gfCAtLWxpc3QgfCAtLWluZGVwZW5kZW50IHwgLS1tZXJnZS1iYXNlXSBbLS1uby1uYW1lIHwgLS1zaGExLW5hbWVdIFstLXRvcGljc10gWyg8cmV2PiB8IDxnbG9iPikuLi5dIiksCiAgICBOXygiZ2l0IHNob3ctYnJhbmNoICgtZ3wtLXJlZmxvZylbPTxuPlssPGJhc2U+XV0gWy0tbGlzdF0gWzxyZWY+XSIpLAogICAgTlVMTAp9OwoKc3RhdGljIGludCBzaG93YnJhbmNoX3VzZV9jb2xvciA9IC0xOwoKc3RhdGljIGludCBkZWZhdWx0X251bTsKc3RhdGljIGludCBkZWZhdWx0X2FsbG9jOwpzdGF0aWMgY29uc3QgY2hhciAqKmRlZmF1bHRfYXJnOwoKI2RlZmluZSBVTklOVEVSRVNUSU5HCTAxCgojZGVmaW5lIFJFVl9TSElGVAkgMgojZGVmaW5lIE1BWF9SRVZTCShGTEFHX0JJVFMgLSBSRVZfU0hJRlQpIC8qIHNob3VsZCBub3QgZXhjZWVkIGJpdHNfcGVyX2ludCAtIFJFVl9TSElGVCAqLwoKI2RlZmluZSBERUZBVUxUX1JFRkxPRwk0CgpzdGF0aWMgY29uc3QgY2hhciAqZ2V0X2NvbG9yX2NvZGUoaW50IGlkeCkKewoJaWYgKHdhbnRfY29sb3Ioc2hvd2JyYW5jaF91c2VfY29sb3IpKQoJCXJldHVybiBjb2x1bW5fY29sb3JzX2Fuc2lbaWR4ICUgY29sdW1uX2NvbG9yc19hbnNpX21heF07CglyZXR1cm4gIiI7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpnZXRfY29sb3JfcmVzZXRfY29kZSh2b2lkKQp7CglpZiAod2FudF9jb2xvcihzaG93YnJhbmNoX3VzZV9jb2xvcikpCgkJcmV0dXJuIEdJVF9DT0xPUl9SRVNFVDsKCXJldHVybiAiIjsKfQoKc3RhdGljIHN0cnVjdCBjb21taXQgKmludGVyZXN0aW5nKHN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCkKewoJd2hpbGUgKGxpc3QpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBsaXN0LT5pdGVtOwoJCWxpc3QgPSBsaXN0LT5uZXh0OwoJCWlmIChjb21taXQtPm9iamVjdC5mbGFncyAmIFVOSU5URVJFU1RJTkcpCgkJCWNvbnRpbnVlOwoJCXJldHVybiBjb21taXQ7Cgl9CglyZXR1cm4gTlVMTDsKfQoKc3RhdGljIHN0cnVjdCBjb21taXQgKnBvcF9vbmVfY29tbWl0KHN0cnVjdCBjb21taXRfbGlzdCAqKmxpc3RfcCkKewoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0OwoJbGlzdCA9ICpsaXN0X3A7Cgljb21taXQgPSBsaXN0LT5pdGVtOwoJKmxpc3RfcCA9IGxpc3QtPm5leHQ7CglmcmVlKGxpc3QpOwoJcmV0dXJuIGNvbW1pdDsKfQoKc3RydWN0IGNvbW1pdF9uYW1lIHsKCWNvbnN0IGNoYXIgKmhlYWRfbmFtZTsgLyogd2hpY2ggaGVhZCdzIGFuY2VzdG9yPyAqLwoJaW50IGdlbmVyYXRpb247IC8qIGhvdyBtYW55IHBhcmVudHMgYXdheSBmcm9tIGhlYWRfbmFtZSAqLwp9OwoKLyogTmFtZSB0aGUgY29tbWl0IGFzIG50aCBnZW5lcmF0aW9uIGFuY2VzdG9yIG9mIGhlYWRfbmFtZTsKICogd2UgY291bnQgb25seSB0aGUgZmlyc3QtcGFyZW50IHJlbGF0aW9uc2hpcCBmb3IgbmFtaW5nIHB1cnBvc2VzLgogKi8Kc3RhdGljIHZvaWQgbmFtZV9jb21taXQoc3RydWN0IGNvbW1pdCAqY29tbWl0LCBjb25zdCBjaGFyICpoZWFkX25hbWUsIGludCBudGgpCnsKCXN0cnVjdCBjb21taXRfbmFtZSAqbmFtZTsKCWlmICghY29tbWl0LT51dGlsKQoJCWNvbW1pdC0+dXRpbCA9IHhtYWxsb2Moc2l6ZW9mKHN0cnVjdCBjb21taXRfbmFtZSkpOwoJbmFtZSA9IGNvbW1pdC0+dXRpbDsKCW5hbWUtPmhlYWRfbmFtZSA9IGhlYWRfbmFtZTsKCW5hbWUtPmdlbmVyYXRpb24gPSBudGg7Cn0KCi8qIFBhcmVudCBpcyB0aGUgZmlyc3QgcGFyZW50IG9mIHRoZSBjb21taXQuICBXZSBtYXkgbmFtZSBpdAogKiBhcyAobisxKXRoIGdlbmVyYXRpb24gYW5jZXN0b3Igb2YgdGhlIHNhbWUgaGVhZF9uYW1lIGFzCiAqIGNvbW1pdCBpcyBudGggZ2VuZXJhdGlvbiBhbmNlc3RvciBvZiwgaWYgdGhhdCBnZW5lcmF0aW9uCiAqIG51bWJlciBpcyBiZXR0ZXIgdGhhbiB0aGUgbmFtZSBpdCBhbHJlYWR5IGhhcy4KICovCnN0YXRpYyB2b2lkIG5hbWVfcGFyZW50KHN0cnVjdCBjb21taXQgKmNvbW1pdCwgc3RydWN0IGNvbW1pdCAqcGFyZW50KQp7CglzdHJ1Y3QgY29tbWl0X25hbWUgKmNvbW1pdF9uYW1lID0gY29tbWl0LT51dGlsOwoJc3RydWN0IGNvbW1pdF9uYW1lICpwYXJlbnRfbmFtZSA9IHBhcmVudC0+dXRpbDsKCWlmICghY29tbWl0X25hbWUpCgkJcmV0dXJuOwoJaWYgKCFwYXJlbnRfbmFtZSB8fAoJICAgIGNvbW1pdF9uYW1lLT5nZW5lcmF0aW9uICsgMSA8IHBhcmVudF9uYW1lLT5nZW5lcmF0aW9uKQoJCW5hbWVfY29tbWl0KHBhcmVudCwgY29tbWl0X25hbWUtPmhlYWRfbmFtZSwKCQkJICAgIGNvbW1pdF9uYW1lLT5nZW5lcmF0aW9uICsgMSk7Cn0KCnN0YXRpYyBpbnQgbmFtZV9maXJzdF9wYXJlbnRfY2hhaW4oc3RydWN0IGNvbW1pdCAqYykKewoJaW50IGkgPSAwOwoJd2hpbGUgKGMpIHsKCQlzdHJ1Y3QgY29tbWl0ICpwOwoJCWlmICghYy0+dXRpbCkKCQkJYnJlYWs7CgkJaWYgKCFjLT5wYXJlbnRzKQoJCQlicmVhazsKCQlwID0gYy0+cGFyZW50cy0+aXRlbTsKCQlpZiAoIXAtPnV0aWwpIHsKCQkJbmFtZV9wYXJlbnQoYywgcCk7CgkJCWkrKzsKCQl9CgkJZWxzZQoJCQlicmVhazsKCQljID0gcDsKCX0KCXJldHVybiBpOwp9CgpzdGF0aWMgdm9pZCBuYW1lX2NvbW1pdHMoc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0LAoJCQkgc3RydWN0IGNvbW1pdCAqKnJldiwKCQkJIGNoYXIgKipyZWZfbmFtZSwKCQkJIGludCBudW1fcmV2KQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKmNsOwoJc3RydWN0IGNvbW1pdCAqYzsKCWludCBpOwoKCS8qIEZpcnN0IGdpdmUgbmFtZXMgdG8gdGhlIGdpdmVuIGhlYWRzICovCglmb3IgKGNsID0gbGlzdDsgY2w7IGNsID0gY2wtPm5leHQpIHsKCQljID0gY2wtPml0ZW07CgkJaWYgKGMtPnV0aWwpCgkJCWNvbnRpbnVlOwoJCWZvciAoaSA9IDA7IGkgPCBudW1fcmV2OyBpKyspIHsKCQkJaWYgKHJldltpXSA9PSBjKSB7CgkJCQluYW1lX2NvbW1pdChjLCByZWZfbmFtZVtpXSwgMCk7CgkJCQlicmVhazsKCQkJfQoJCX0KCX0KCgkvKiBUaGVuIGNvbW1pdHMgb24gdGhlIGZpcnN0IHBhcmVudCBhbmNlc3RyeSBjaGFpbiAqLwoJZG8gewoJCWkgPSAwOwoJCWZvciAoY2wgPSBsaXN0OyBjbDsgY2wgPSBjbC0+bmV4dCkgewoJCQlpICs9IG5hbWVfZmlyc3RfcGFyZW50X2NoYWluKGNsLT5pdGVtKTsKCQl9Cgl9IHdoaWxlIChpKTsKCgkvKiBGaW5hbGx5LCBhbnkgdW5uYW1lZCBjb21taXRzICovCglkbyB7CgkJaSA9IDA7CgkJZm9yIChjbCA9IGxpc3Q7IGNsOyBjbCA9IGNsLT5uZXh0KSB7CgkJCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50czsKCQkJc3RydWN0IGNvbW1pdF9uYW1lICpuOwoJCQlpbnQgbnRoOwoJCQljID0gY2wtPml0ZW07CgkJCWlmICghYy0+dXRpbCkKCQkJCWNvbnRpbnVlOwoJCQluID0gYy0+dXRpbDsKCQkJcGFyZW50cyA9IGMtPnBhcmVudHM7CgkJCW50aCA9IDA7CgkJCXdoaWxlIChwYXJlbnRzKSB7CgkJCQlzdHJ1Y3QgY29tbWl0ICpwID0gcGFyZW50cy0+aXRlbTsKCQkJCXN0cnVjdCBzdHJidWYgbmV3bmFtZSA9IFNUUkJVRl9JTklUOwoJCQkJcGFyZW50cyA9IHBhcmVudHMtPm5leHQ7CgkJCQludGgrKzsKCQkJCWlmIChwLT51dGlsKQoJCQkJCWNvbnRpbnVlOwoJCQkJc3dpdGNoIChuLT5nZW5lcmF0aW9uKSB7CgkJCQljYXNlIDA6CgkJCQkJc3RyYnVmX2FkZHN0cigmbmV3bmFtZSwgbi0+aGVhZF9uYW1lKTsKCQkJCQlicmVhazsKCQkJCWNhc2UgMToKCQkJCQlzdHJidWZfYWRkZigmbmV3bmFtZSwgIiVzXiIsIG4tPmhlYWRfbmFtZSk7CgkJCQkJYnJlYWs7CgkJCQlkZWZhdWx0OgoJCQkJCXN0cmJ1Zl9hZGRmKCZuZXduYW1lLCAiJXN+JWQiLAoJCQkJCQkgICAgbi0+aGVhZF9uYW1lLCBuLT5nZW5lcmF0aW9uKTsKCQkJCQlicmVhazsKCQkJCX0KCQkJCWlmIChudGggPT0gMSkKCQkJCQlzdHJidWZfYWRkY2goJm5ld25hbWUsICdeJyk7CgkJCQllbHNlCgkJCQkJc3RyYnVmX2FkZGYoJm5ld25hbWUsICJeJWQiLCBudGgpOwoJCQkJbmFtZV9jb21taXQocCwgc3RyYnVmX2RldGFjaCgmbmV3bmFtZSwgTlVMTCksIDApOwoJCQkJaSsrOwoJCQkJbmFtZV9maXJzdF9wYXJlbnRfY2hhaW4ocCk7CgkJCX0KCQl9Cgl9IHdoaWxlIChpKTsKfQoKc3RhdGljIGludCBtYXJrX3NlZW4oc3RydWN0IGNvbW1pdCAqY29tbWl0LCBzdHJ1Y3QgY29tbWl0X2xpc3QgKipzZWVuX3ApCnsKCWlmICghY29tbWl0LT5vYmplY3QuZmxhZ3MpIHsKCQljb21taXRfbGlzdF9pbnNlcnQoY29tbWl0LCBzZWVuX3ApOwoJCXJldHVybiAxOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGpvaW5fcmV2cyhzdHJ1Y3QgY29tbWl0X2xpc3QgKipsaXN0X3AsCgkJICAgICAgc3RydWN0IGNvbW1pdF9saXN0ICoqc2Vlbl9wLAoJCSAgICAgIGludCBudW1fcmV2LCBpbnQgZXh0cmEpCnsKCWludCBhbGxfbWFzayA9ICgoMXUgPDwgKFJFVl9TSElGVCArIG51bV9yZXYpKSAtIDEpOwoJaW50IGFsbF9yZXZzID0gYWxsX21hc2sgJiB+KCgxdSA8PCBSRVZfU0hJRlQpIC0gMSk7CgoJd2hpbGUgKCpsaXN0X3ApIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHM7CgkJaW50IHN0aWxsX2ludGVyZXN0aW5nID0gISFpbnRlcmVzdGluZygqbGlzdF9wKTsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBwb3Bfb25lX2NvbW1pdChsaXN0X3ApOwoJCWludCBmbGFncyA9IGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgYWxsX21hc2s7CgoJCWlmICghc3RpbGxfaW50ZXJlc3RpbmcgJiYgZXh0cmEgPD0gMCkKCQkJYnJlYWs7CgoJCW1hcmtfc2Vlbihjb21taXQsIHNlZW5fcCk7CgkJaWYgKChmbGFncyAmIGFsbF9yZXZzKSA9PSBhbGxfcmV2cykKCQkJZmxhZ3MgfD0gVU5JTlRFUkVTVElORzsKCQlwYXJlbnRzID0gY29tbWl0LT5wYXJlbnRzOwoKCQl3aGlsZSAocGFyZW50cykgewoJCQlzdHJ1Y3QgY29tbWl0ICpwID0gcGFyZW50cy0+aXRlbTsKCQkJaW50IHRoaXNfZmxhZyA9IHAtPm9iamVjdC5mbGFnczsKCQkJcGFyZW50cyA9IHBhcmVudHMtPm5leHQ7CgkJCWlmICgodGhpc19mbGFnICYgZmxhZ3MpID09IGZsYWdzKQoJCQkJY29udGludWU7CgkJCWlmICghcC0+b2JqZWN0LnBhcnNlZCkKCQkJCXBhcnNlX2NvbW1pdChwKTsKCQkJaWYgKG1hcmtfc2VlbihwLCBzZWVuX3ApICYmICFzdGlsbF9pbnRlcmVzdGluZykKCQkJCWV4dHJhLS07CgkJCXAtPm9iamVjdC5mbGFncyB8PSBmbGFnczsKCQkJY29tbWl0X2xpc3RfaW5zZXJ0X2J5X2RhdGUocCwgbGlzdF9wKTsKCQl9Cgl9CgoJLyoKCSAqIFBvc3Rwcm9jZXNzIHRvIGNvbXBsZXRlIHdlbGwtcG9pc29uaW5nLgoJICoKCSAqIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbGwgdGhlIGNvbW1pdHMgd2UgaGF2ZSBzZWVuIGluCgkgKiBzZWVuX3AgbGlzdC4gIE1hcmsgYW55dGhpbmcgdGhhdCBjYW4gYmUgcmVhY2hlZCBmcm9tCgkgKiB1bmludGVyZXN0aW5nIGNvbW1pdHMgbm90IGludGVyZXN0aW5nLgoJICovCglmb3IgKDs7KSB7CgkJaW50IGNoYW5nZWQgPSAwOwoJCXN0cnVjdCBjb21taXRfbGlzdCAqczsKCQlmb3IgKHMgPSAqc2Vlbl9wOyBzOyBzID0gcy0+bmV4dCkgewoJCQlzdHJ1Y3QgY29tbWl0ICpjID0gcy0+aXRlbTsKCQkJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzOwoKCQkJaWYgKCgoYy0+b2JqZWN0LmZsYWdzICYgYWxsX3JldnMpICE9IGFsbF9yZXZzKSAmJgoJCQkgICAgIShjLT5vYmplY3QuZmxhZ3MgJiBVTklOVEVSRVNUSU5HKSkKCQkJCWNvbnRpbnVlOwoKCQkJLyogVGhlIGN1cnJlbnQgY29tbWl0IGlzIGVpdGhlciBhIG1lcmdlIGJhc2Ugb3IKCQkJICogYWxyZWFkeSB1bmludGVyZXN0aW5nIG9uZS4gIE1hcmsgaXRzIHBhcmVudHMKCQkJICogYXMgdW5pbnRlcmVzdGluZyBjb21taXRzIF9vbmx5XyBpZiB0aGV5IGFyZQoJCQkgKiBhbHJlYWR5IHBhcnNlZC4gIE5vIHJlYXNvbiB0byBmaW5kIG5ldyBvbmVzCgkJCSAqIGhlcmUuCgkJCSAqLwoJCQlwYXJlbnRzID0gYy0+cGFyZW50czsKCQkJd2hpbGUgKHBhcmVudHMpIHsKCQkJCXN0cnVjdCBjb21taXQgKnAgPSBwYXJlbnRzLT5pdGVtOwoJCQkJcGFyZW50cyA9IHBhcmVudHMtPm5leHQ7CgkJCQlpZiAoIShwLT5vYmplY3QuZmxhZ3MgJiBVTklOVEVSRVNUSU5HKSkgewoJCQkJCXAtPm9iamVjdC5mbGFncyB8PSBVTklOVEVSRVNUSU5HOwoJCQkJCWNoYW5nZWQgPSAxOwoJCQkJfQoJCQl9CgkJfQoJCWlmICghY2hhbmdlZCkKCQkJYnJlYWs7Cgl9Cn0KCnN0YXRpYyB2b2lkIHNob3dfb25lX2NvbW1pdChzdHJ1Y3QgY29tbWl0ICpjb21taXQsIGludCBub19uYW1lKQp7CglzdHJ1Y3Qgc3RyYnVmIHByZXR0eSA9IFNUUkJVRl9JTklUOwoJY29uc3QgY2hhciAqcHJldHR5X3N0ciA9ICIodW5hdmFpbGFibGUpIjsKCXN0cnVjdCBjb21taXRfbmFtZSAqbmFtZSA9IGNvbW1pdC0+dXRpbDsKCglpZiAoY29tbWl0LT5vYmplY3QucGFyc2VkKSB7CgkJcHBfY29tbWl0X2Vhc3koQ01JVF9GTVRfT05FTElORSwgY29tbWl0LCAmcHJldHR5KTsKCQlwcmV0dHlfc3RyID0gcHJldHR5LmJ1ZjsKCX0KCWlmICghcHJlZml4Y21wKHByZXR0eV9zdHIsICJbUEFUQ0hdICIpKQoJCXByZXR0eV9zdHIgKz0gODsKCglpZiAoIW5vX25hbWUpIHsKCQlpZiAobmFtZSAmJiBuYW1lLT5oZWFkX25hbWUpIHsKCQkJcHJpbnRmKCJbJXMiLCBuYW1lLT5oZWFkX25hbWUpOwoJCQlpZiAobmFtZS0+Z2VuZXJhdGlvbikgewoJCQkJaWYgKG5hbWUtPmdlbmVyYXRpb24gPT0gMSkKCQkJCQlwcmludGYoIl4iKTsKCQkJCWVsc2UKCQkJCQlwcmludGYoIn4lZCIsIG5hbWUtPmdlbmVyYXRpb24pOwoJCQl9CgkJCXByaW50ZigiXSAiKTsKCQl9CgkJZWxzZQoJCQlwcmludGYoIlslc10gIiwKCQkJICAgICAgIGZpbmRfdW5pcXVlX2FiYnJldihjb21taXQtPm9iamVjdC5zaGExLAoJCQkJCQkgIERFRkFVTFRfQUJCUkVWKSk7Cgl9CglwdXRzKHByZXR0eV9zdHIpOwoJc3RyYnVmX3JlbGVhc2UoJnByZXR0eSk7Cn0KCnN0YXRpYyBjaGFyICpyZWZfbmFtZVtNQVhfUkVWUyArIDFdOwpzdGF0aWMgaW50IHJlZl9uYW1lX2NudDsKCnN0YXRpYyBjb25zdCBjaGFyICpmaW5kX2RpZ2l0X3ByZWZpeChjb25zdCBjaGFyICpzLCBpbnQgKnYpCnsKCWNvbnN0IGNoYXIgKnA7CglpbnQgdmVyOwoJY2hhciBjaDsKCglmb3IgKHAgPSBzLCB2ZXIgPSAwOwoJICAgICAnMCcgPD0gKGNoID0gKnApICYmIGNoIDw9ICc5JzsKCSAgICAgcCsrKQoJCXZlciA9IHZlciAqIDEwICsgY2ggLSAnMCc7CgkqdiA9IHZlcjsKCXJldHVybiBwOwp9CgoKc3RhdGljIGludCB2ZXJzaW9uX2NtcChjb25zdCBjaGFyICphLCBjb25zdCBjaGFyICpiKQp7Cgl3aGlsZSAoMSkgewoJCWludCB2YSwgdmI7CgoJCWEgPSBmaW5kX2RpZ2l0X3ByZWZpeChhLCAmdmEpOwoJCWIgPSBmaW5kX2RpZ2l0X3ByZWZpeChiLCAmdmIpOwoJCWlmICh2YSAhPSB2YikKCQkJcmV0dXJuIHZhIC0gdmI7CgoJCXdoaWxlICgxKSB7CgkJCWludCBjYSA9ICphOwoJCQlpbnQgY2IgPSAqYjsKCQkJaWYgKCcwJyA8PSBjYSAmJiBjYSA8PSAnOScpCgkJCQljYSA9IDA7CgkJCWlmICgnMCcgPD0gY2IgJiYgY2IgPD0gJzknKQoJCQkJY2IgPSAwOwoJCQlpZiAoY2EgIT0gY2IpCgkJCQlyZXR1cm4gY2EgLSBjYjsKCQkJaWYgKCFjYSkKCQkJCWJyZWFrOwoJCQlhKys7CgkJCWIrKzsKCQl9CgkJaWYgKCEqYSAmJiAhKmIpCgkJCXJldHVybiAwOwoJfQp9CgpzdGF0aWMgaW50IGNvbXBhcmVfcmVmX25hbWUoY29uc3Qgdm9pZCAqYV8sIGNvbnN0IHZvaWQgKmJfKQp7Cgljb25zdCBjaGFyICogY29uc3QqYSA9IGFfLCAqIGNvbnN0KmIgPSBiXzsKCXJldHVybiB2ZXJzaW9uX2NtcCgqYSwgKmIpOwp9CgpzdGF0aWMgdm9pZCBzb3J0X3JlZl9yYW5nZShpbnQgYm90dG9tLCBpbnQgdG9wKQp7Cglxc29ydChyZWZfbmFtZSArIGJvdHRvbSwgdG9wIC0gYm90dG9tLCBzaXplb2YocmVmX25hbWVbMF0pLAoJICAgICAgY29tcGFyZV9yZWZfbmFtZSk7Cn0KCnN0YXRpYyBpbnQgYXBwZW5kX3JlZihjb25zdCBjaGFyICpyZWZuYW1lLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCSAgICAgIGludCBhbGxvd19kdXBzKQp7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkoc2hhMSwgMSk7CglpbnQgaTsKCglpZiAoIWNvbW1pdCkKCQlyZXR1cm4gMDsKCglpZiAoIWFsbG93X2R1cHMpIHsKCQkvKiBBdm9pZCBhZGRpbmcgdGhlIHNhbWUgdGhpbmcgdHdpY2UgKi8KCQlmb3IgKGkgPSAwOyBpIDwgcmVmX25hbWVfY250OyBpKyspCgkJCWlmICghc3RyY21wKHJlZm5hbWUsIHJlZl9uYW1lW2ldKSkKCQkJCXJldHVybiAwOwoJfQoJaWYgKE1BWF9SRVZTIDw9IHJlZl9uYW1lX2NudCkgewoJCXdhcm5pbmcoImlnbm9yaW5nICVzOyBjYW5ub3QgaGFuZGxlIG1vcmUgdGhhbiAlZCByZWZzIiwKCQkJcmVmbmFtZSwgTUFYX1JFVlMpOwoJCXJldHVybiAwOwoJfQoJcmVmX25hbWVbcmVmX25hbWVfY250KytdID0geHN0cmR1cChyZWZuYW1lKTsKCXJlZl9uYW1lW3JlZl9uYW1lX2NudF0gPSBOVUxMOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgYXBwZW5kX2hlYWRfcmVmKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIGludCBmbGFnLCB2b2lkICpjYl9kYXRhKQp7Cgl1bnNpZ25lZCBjaGFyIHRtcFsyMF07CglpbnQgb2ZzID0gMTE7CglpZiAocHJlZml4Y21wKHJlZm5hbWUsICJyZWZzL2hlYWRzLyIpKQoJCXJldHVybiAwOwoJLyogSWYgYm90aCBoZWFkcy9mb28gYW5kIHRhZ3MvZm9vIGV4aXN0cywgZ2V0X3NoYTEgd291bGQKCSAqIGdldCBjb25mdXNlZC4KCSAqLwoJaWYgKGdldF9zaGExKHJlZm5hbWUgKyBvZnMsIHRtcCkgfHwgaGFzaGNtcCh0bXAsIHNoYTEpKQoJCW9mcyA9IDU7CglyZXR1cm4gYXBwZW5kX3JlZihyZWZuYW1lICsgb2ZzLCBzaGExLCAwKTsKfQoKc3RhdGljIGludCBhcHBlbmRfcmVtb3RlX3JlZihjb25zdCBjaGFyICpyZWZuYW1lLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBpbnQgZmxhZywgdm9pZCAqY2JfZGF0YSkKewoJdW5zaWduZWQgY2hhciB0bXBbMjBdOwoJaW50IG9mcyA9IDEzOwoJaWYgKHByZWZpeGNtcChyZWZuYW1lLCAicmVmcy9yZW1vdGVzLyIpKQoJCXJldHVybiAwOwoJLyogSWYgYm90aCBoZWFkcy9mb28gYW5kIHRhZ3MvZm9vIGV4aXN0cywgZ2V0X3NoYTEgd291bGQKCSAqIGdldCBjb25mdXNlZC4KCSAqLwoJaWYgKGdldF9zaGExKHJlZm5hbWUgKyBvZnMsIHRtcCkgfHwgaGFzaGNtcCh0bXAsIHNoYTEpKQoJCW9mcyA9IDU7CglyZXR1cm4gYXBwZW5kX3JlZihyZWZuYW1lICsgb2ZzLCBzaGExLCAwKTsKfQoKc3RhdGljIGludCBhcHBlbmRfdGFnX3JlZihjb25zdCBjaGFyICpyZWZuYW1lLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBpbnQgZmxhZywgdm9pZCAqY2JfZGF0YSkKewoJaWYgKHByZWZpeGNtcChyZWZuYW1lLCAicmVmcy90YWdzLyIpKQoJCXJldHVybiAwOwoJcmV0dXJuIGFwcGVuZF9yZWYocmVmbmFtZSArIDUsIHNoYTEsIDApOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqbWF0Y2hfcmVmX3BhdHRlcm4gPSBOVUxMOwpzdGF0aWMgaW50IG1hdGNoX3JlZl9zbGFzaCA9IDA7CnN0YXRpYyBpbnQgY291bnRfc2xhc2goY29uc3QgY2hhciAqcykKewoJaW50IGNudCA9IDA7Cgl3aGlsZSAoKnMpCgkJaWYgKCpzKysgPT0gJy8nKQoJCQljbnQrKzsKCXJldHVybiBjbnQ7Cn0KCnN0YXRpYyBpbnQgYXBwZW5kX21hdGNoaW5nX3JlZihjb25zdCBjaGFyICpyZWZuYW1lLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBpbnQgZmxhZywgdm9pZCAqY2JfZGF0YSkKewoJLyogd2Ugd2FudCB0byBhbGxvdyBwYXR0ZXJuIGhvbGQvPGFzdGVyaXNrPiB0byBzaG93IGFsbAoJICogYnJhbmNoZXMgdW5kZXIgcmVmcy9oZWFkcy9ob2xkLywgYW5kIHYwLjk5Ljk/IHRvIHNob3cKCSAqIHJlZnMvdGFncy92MC45OS45YSBhbmQgZnJpZW5kcy4KCSAqLwoJY29uc3QgY2hhciAqdGFpbDsKCWludCBzbGFzaCA9IGNvdW50X3NsYXNoKHJlZm5hbWUpOwoJZm9yICh0YWlsID0gcmVmbmFtZTsgKnRhaWwgJiYgbWF0Y2hfcmVmX3NsYXNoIDwgc2xhc2g7ICkKCQlpZiAoKnRhaWwrKyA9PSAnLycpCgkJCXNsYXNoLS07CglpZiAoISp0YWlsKQoJCXJldHVybiAwOwoJaWYgKGZubWF0Y2gobWF0Y2hfcmVmX3BhdHRlcm4sIHRhaWwsIDApKQoJCXJldHVybiAwOwoJaWYgKCFwcmVmaXhjbXAocmVmbmFtZSwgInJlZnMvaGVhZHMvIikpCgkJcmV0dXJuIGFwcGVuZF9oZWFkX3JlZihyZWZuYW1lLCBzaGExLCBmbGFnLCBjYl9kYXRhKTsKCWlmICghcHJlZml4Y21wKHJlZm5hbWUsICJyZWZzL3RhZ3MvIikpCgkJcmV0dXJuIGFwcGVuZF90YWdfcmVmKHJlZm5hbWUsIHNoYTEsIGZsYWcsIGNiX2RhdGEpOwoJcmV0dXJuIGFwcGVuZF9yZWYocmVmbmFtZSwgc2hhMSwgMCk7Cn0KCnN0YXRpYyB2b2lkIHNuYXJmX3JlZnMoaW50IGhlYWQsIGludCByZW1vdGVzKQp7CglpZiAoaGVhZCkgewoJCWludCBvcmlnX2NudCA9IHJlZl9uYW1lX2NudDsKCQlmb3JfZWFjaF9yZWYoYXBwZW5kX2hlYWRfcmVmLCBOVUxMKTsKCQlzb3J0X3JlZl9yYW5nZShvcmlnX2NudCwgcmVmX25hbWVfY250KTsKCX0KCWlmIChyZW1vdGVzKSB7CgkJaW50IG9yaWdfY250ID0gcmVmX25hbWVfY250OwoJCWZvcl9lYWNoX3JlZihhcHBlbmRfcmVtb3RlX3JlZiwgTlVMTCk7CgkJc29ydF9yZWZfcmFuZ2Uob3JpZ19jbnQsIHJlZl9uYW1lX2NudCk7Cgl9Cn0KCnN0YXRpYyBpbnQgcmV2X2lzX2hlYWQoY2hhciAqaGVhZCwgaW50IGhlYWRsZW4sIGNoYXIgKm5hbWUsCgkJICAgICAgIHVuc2lnbmVkIGNoYXIgKmhlYWRfc2hhMSwgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJaWYgKCghaGVhZFswXSkgfHwKCSAgICAoaGVhZF9zaGExICYmIHNoYTEgJiYgaGFzaGNtcChoZWFkX3NoYTEsIHNoYTEpKSkKCQlyZXR1cm4gMDsKCWlmICghcHJlZml4Y21wKGhlYWQsICJyZWZzL2hlYWRzLyIpKQoJCWhlYWQgKz0gMTE7CglpZiAoIXByZWZpeGNtcChuYW1lLCAicmVmcy9oZWFkcy8iKSkKCQluYW1lICs9IDExOwoJZWxzZSBpZiAoIXByZWZpeGNtcChuYW1lLCAiaGVhZHMvIikpCgkJbmFtZSArPSA2OwoJcmV0dXJuICFzdHJjbXAoaGVhZCwgbmFtZSk7Cn0KCnN0YXRpYyBpbnQgc2hvd19tZXJnZV9iYXNlKHN0cnVjdCBjb21taXRfbGlzdCAqc2VlbiwgaW50IG51bV9yZXYpCnsKCWludCBhbGxfbWFzayA9ICgoMXUgPDwgKFJFVl9TSElGVCArIG51bV9yZXYpKSAtIDEpOwoJaW50IGFsbF9yZXZzID0gYWxsX21hc2sgJiB+KCgxdSA8PCBSRVZfU0hJRlQpIC0gMSk7CglpbnQgZXhpdF9zdGF0dXMgPSAxOwoKCXdoaWxlIChzZWVuKSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gcG9wX29uZV9jb21taXQoJnNlZW4pOwoJCWludCBmbGFncyA9IGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgYWxsX21hc2s7CgkJaWYgKCEoZmxhZ3MgJiBVTklOVEVSRVNUSU5HKSAmJgoJCSAgICAoKGZsYWdzICYgYWxsX3JldnMpID09IGFsbF9yZXZzKSkgewoJCQlwdXRzKHNoYTFfdG9faGV4KGNvbW1pdC0+b2JqZWN0LnNoYTEpKTsKCQkJZXhpdF9zdGF0dXMgPSAwOwoJCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBVTklOVEVSRVNUSU5HOwoJCX0KCX0KCXJldHVybiBleGl0X3N0YXR1czsKfQoKc3RhdGljIGludCBzaG93X2luZGVwZW5kZW50KHN0cnVjdCBjb21taXQgKipyZXYsCgkJCSAgICBpbnQgbnVtX3JldiwKCQkJICAgIGNoYXIgKipyZWZfbmFtZSwKCQkJICAgIHVuc2lnbmVkIGludCAqcmV2X21hc2spCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBudW1fcmV2OyBpKyspIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSByZXZbaV07CgkJdW5zaWduZWQgaW50IGZsYWcgPSByZXZfbWFza1tpXTsKCgkJaWYgKGNvbW1pdC0+b2JqZWN0LmZsYWdzID09IGZsYWcpCgkJCXB1dHMoc2hhMV90b19oZXgoY29tbWl0LT5vYmplY3Quc2hhMSkpOwoJCWNvbW1pdC0+b2JqZWN0LmZsYWdzIHw9IFVOSU5URVJFU1RJTkc7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgYXBwZW5kX29uZV9yZXYoY29uc3QgY2hhciAqYXYpCnsKCXVuc2lnbmVkIGNoYXIgcmV2a2V5WzIwXTsKCWlmICghZ2V0X3NoYTEoYXYsIHJldmtleSkpIHsKCQlhcHBlbmRfcmVmKGF2LCByZXZrZXksIDApOwoJCXJldHVybjsKCX0KCWlmIChzdHJjaHIoYXYsICcqJykgfHwgc3RyY2hyKGF2LCAnPycpIHx8IHN0cmNocihhdiwgJ1snKSkgewoJCS8qIGdsb2Igc3R5bGUgbWF0Y2ggKi8KCQlpbnQgc2F2ZWRfbWF0Y2hlcyA9IHJlZl9uYW1lX2NudDsKCQltYXRjaF9yZWZfcGF0dGVybiA9IGF2OwoJCW1hdGNoX3JlZl9zbGFzaCA9IGNvdW50X3NsYXNoKGF2KTsKCQlmb3JfZWFjaF9yZWYoYXBwZW5kX21hdGNoaW5nX3JlZiwgTlVMTCk7CgkJaWYgKHNhdmVkX21hdGNoZXMgPT0gcmVmX25hbWVfY250ICYmCgkJICAgIHJlZl9uYW1lX2NudCA8IE1BWF9SRVZTKQoJCQllcnJvcigibm8gbWF0Y2hpbmcgcmVmcyB3aXRoICVzIiwgYXYpOwoJCWlmIChzYXZlZF9tYXRjaGVzICsgMSA8IHJlZl9uYW1lX2NudCkKCQkJc29ydF9yZWZfcmFuZ2Uoc2F2ZWRfbWF0Y2hlcywgcmVmX25hbWVfY250KTsKCQlyZXR1cm47Cgl9CglkaWUoImJhZCBzaGExIHJlZmVyZW5jZSAlcyIsIGF2KTsKfQoKc3RhdGljIGludCBnaXRfc2hvd19icmFuY2hfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmNiKQp7CglpZiAoIXN0cmNtcCh2YXIsICJzaG93YnJhbmNoLmRlZmF1bHQiKSkgewoJCWlmICghdmFsdWUpCgkJCXJldHVybiBjb25maWdfZXJyb3Jfbm9uYm9vbCh2YXIpOwoJCS8qCgkJICogZGVmYXVsdF9hcmcgaXMgbm93IHBhc3NlZCB0byBwYXJzZV9vcHRpb25zKCksIHNvIHdlIG5lZWQgdG8KCQkgKiBtaW1pYyB0aGUgcmVhbCBhcmd2IGEgYml0IGJldHRlci4KCQkgKi8KCQlpZiAoIWRlZmF1bHRfbnVtKSB7CgkJCWRlZmF1bHRfYWxsb2MgPSAyMDsKCQkJZGVmYXVsdF9hcmcgPSB4Y2FsbG9jKGRlZmF1bHRfYWxsb2MsIHNpemVvZigqZGVmYXVsdF9hcmcpKTsKCQkJZGVmYXVsdF9hcmdbZGVmYXVsdF9udW0rK10gPSAic2hvdy1icmFuY2giOwoJCX0gZWxzZSBpZiAoZGVmYXVsdF9hbGxvYyA8PSBkZWZhdWx0X251bSArIDEpIHsKCQkJZGVmYXVsdF9hbGxvYyA9IGRlZmF1bHRfYWxsb2MgKiAzIC8gMiArIDIwOwoJCQlkZWZhdWx0X2FyZyA9IHhyZWFsbG9jKGRlZmF1bHRfYXJnLCBzaXplb2YgKmRlZmF1bHRfYXJnICogZGVmYXVsdF9hbGxvYyk7CgkJfQoJCWRlZmF1bHRfYXJnW2RlZmF1bHRfbnVtKytdID0geHN0cmR1cCh2YWx1ZSk7CgkJZGVmYXVsdF9hcmdbZGVmYXVsdF9udW1dID0gTlVMTDsKCQlyZXR1cm4gMDsKCX0KCglpZiAoIXN0cmNtcCh2YXIsICJjb2xvci5zaG93YnJhbmNoIikpIHsKCQlzaG93YnJhbmNoX3VzZV9jb2xvciA9IGdpdF9jb25maWdfY29sb3Jib29sKHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoKCXJldHVybiBnaXRfY29sb3JfZGVmYXVsdF9jb25maWcodmFyLCB2YWx1ZSwgY2IpOwp9CgpzdGF0aWMgaW50IG9taXRfaW5fZGVuc2Uoc3RydWN0IGNvbW1pdCAqY29tbWl0LCBzdHJ1Y3QgY29tbWl0ICoqcmV2LCBpbnQgbikKewoJLyogSWYgdGhlIGNvbW1pdCBpcyB0aXAgb2YgdGhlIG5hbWVkIGJyYW5jaGVzLCBkbyBub3QKCSAqIG9taXQgaXQuCgkgKiBPdGhlcndpc2UsIGlmIGl0IGlzIGEgbWVyZ2UgdGhhdCBpcyByZWFjaGFibGUgZnJvbSBvbmx5IG9uZQoJICogdGlwLCBpdCBpcyBub3QgdGhhdCBpbnRlcmVzdGluZy4KCSAqLwoJaW50IGksIGZsYWcsIGNvdW50OwoJZm9yIChpID0gMDsgaSA8IG47IGkrKykKCQlpZiAocmV2W2ldID09IGNvbW1pdCkKCQkJcmV0dXJuIDA7CglmbGFnID0gY29tbWl0LT5vYmplY3QuZmxhZ3M7Cglmb3IgKGkgPSBjb3VudCA9IDA7IGkgPCBuOyBpKyspIHsKCQlpZiAoZmxhZyAmICgxdSA8PCAoaSArIFJFVl9TSElGVCkpKQoJCQljb3VudCsrOwoJfQoJaWYgKGNvdW50ID09IDEpCgkJcmV0dXJuIDE7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCByZWZsb2cgPSAwOwoKc3RhdGljIGludCBwYXJzZV9yZWZsb2dfcGFyYW0oY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsCgkJCSAgICAgIGludCB1bnNldCkKewoJY2hhciAqZXA7Cgljb25zdCBjaGFyICoqYmFzZSA9IChjb25zdCBjaGFyICoqKW9wdC0+dmFsdWU7CglpZiAoIWFyZykKCQlhcmcgPSAiIjsKCXJlZmxvZyA9IHN0cnRvdWwoYXJnLCAmZXAsIDEwKTsKCWlmICgqZXAgPT0gJywnKQoJCSpiYXNlID0gZXAgKyAxOwoJZWxzZSBpZiAoKmVwKQoJCXJldHVybiBlcnJvcigidW5yZWNvZ25pemVkIHJlZmxvZyBwYXJhbSAnJXMnIiwgYXJnKTsKCWVsc2UKCQkqYmFzZSA9IE5VTEw7CglpZiAocmVmbG9nIDw9IDApCgkJcmVmbG9nID0gREVGQVVMVF9SRUZMT0c7CglyZXR1cm4gMDsKfQoKaW50IGNtZF9zaG93X2JyYW5jaChpbnQgYWMsIGNvbnN0IGNoYXIgKiphdiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdHJ1Y3QgY29tbWl0ICpyZXZbTUFYX1JFVlNdLCAqY29tbWl0OwoJY2hhciAqcmVmbG9nX21zZ1tNQVhfUkVWU107CglzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QgPSBOVUxMLCAqc2VlbiA9IE5VTEw7Cgl1bnNpZ25lZCBpbnQgcmV2X21hc2tbTUFYX1JFVlNdOwoJaW50IG51bV9yZXYsIGksIGV4dHJhID0gMDsKCWludCBhbGxfaGVhZHMgPSAwLCBhbGxfcmVtb3RlcyA9IDA7CglpbnQgYWxsX21hc2ssIGFsbF9yZXZzOwoJZW51bSByZXZfc29ydF9vcmRlciBzb3J0X29yZGVyID0gUkVWX1NPUlRfSU5fR1JBUEhfT1JERVI7CgljaGFyIGhlYWRbMTI4XTsKCWNvbnN0IGNoYXIgKmhlYWRfcDsKCWludCBoZWFkX2xlbjsKCXVuc2lnbmVkIGNoYXIgaGVhZF9zaGExWzIwXTsKCWludCBtZXJnZV9iYXNlID0gMDsKCWludCBpbmRlcGVuZGVudCA9IDA7CglpbnQgbm9fbmFtZSA9IDA7CglpbnQgc2hhMV9uYW1lID0gMDsKCWludCBzaG93bl9tZXJnZV9wb2ludCA9IDA7CglpbnQgd2l0aF9jdXJyZW50X2JyYW5jaCA9IDA7CglpbnQgaGVhZF9hdCA9IC0xOwoJaW50IHRvcGljcyA9IDA7CglpbnQgZGVuc2UgPSAxOwoJY29uc3QgY2hhciAqcmVmbG9nX2Jhc2UgPSBOVUxMOwoJc3RydWN0IG9wdGlvbiBidWlsdGluX3Nob3dfYnJhbmNoX29wdGlvbnNbXSA9IHsKCQlPUFRfQk9PTCgnYScsICJhbGwiLCAmYWxsX2hlYWRzLAoJCQkgTl8oInNob3cgcmVtb3RlLXRyYWNraW5nIGFuZCBsb2NhbCBicmFuY2hlcyIpKSwKCQlPUFRfQk9PTCgncicsICJyZW1vdGVzIiwgJmFsbF9yZW1vdGVzLAoJCQkgTl8oInNob3cgcmVtb3RlLXRyYWNraW5nIGJyYW5jaGVzIikpLAoJCU9QVF9fQ09MT1IoJnNob3dicmFuY2hfdXNlX2NvbG9yLAoJCQkgICAgTl8oImNvbG9yICcqISstJyBjb3JyZXNwb25kaW5nIHRvIHRoZSBicmFuY2giKSksCgkJeyBPUFRJT05fSU5URUdFUiwgMCwgIm1vcmUiLCAmZXh0cmEsIE5fKCJuIiksCgkJCSAgICBOXygic2hvdyA8bj4gbW9yZSBjb21taXRzIGFmdGVyIHRoZSBjb21tb24gYW5jZXN0b3IiKSwKCQkJICAgIFBBUlNFX09QVF9PUFRBUkcsIE5VTEwsIChpbnRwdHJfdCkxIH0sCgkJT1BUX1NFVF9JTlQoMCwgImxpc3QiLCAmZXh0cmEsIE5fKCJzeW5vbnltIHRvIG1vcmU9LTEiKSwgLTEpLAoJCU9QVF9CT09MKDAsICJuby1uYW1lIiwgJm5vX25hbWUsIE5fKCJzdXBwcmVzcyBuYW1pbmcgc3RyaW5ncyIpKSwKCQlPUFRfQk9PTCgwLCAiY3VycmVudCIsICZ3aXRoX2N1cnJlbnRfYnJhbmNoLAoJCQkgTl8oImluY2x1ZGUgdGhlIGN1cnJlbnQgYnJhbmNoIikpLAoJCU9QVF9CT09MKDAsICJzaGExLW5hbWUiLCAmc2hhMV9uYW1lLAoJCQkgTl8oIm5hbWUgY29tbWl0cyB3aXRoIHRoZWlyIG9iamVjdCBuYW1lcyIpKSwKCQlPUFRfQk9PTCgwLCAibWVyZ2UtYmFzZSIsICZtZXJnZV9iYXNlLAoJCQkgTl8oInNob3cgcG9zc2libGUgbWVyZ2UgYmFzZXMiKSksCgkJT1BUX0JPT0woMCwgImluZGVwZW5kZW50IiwgJmluZGVwZW5kZW50LAoJCQkgICAgTl8oInNob3cgcmVmcyB1bnJlYWNoYWJsZSBmcm9tIGFueSBvdGhlciByZWYiKSksCgkJT1BUX1NFVF9JTlQoMCwgInRvcG8tb3JkZXIiLCAmc29ydF9vcmRlciwKCQkJICAgIE5fKCJzaG93IGNvbW1pdHMgaW4gdG9wb2xvZ2ljYWwgb3JkZXIiKSwKCQkJICAgIFJFVl9TT1JUX0lOX0dSQVBIX09SREVSKSwKCQlPUFRfQk9PTCgwLCAidG9waWNzIiwgJnRvcGljcywKCQkJIE5fKCJzaG93IG9ubHkgY29tbWl0cyBub3Qgb24gdGhlIGZpcnN0IGJyYW5jaCIpKSwKCQlPUFRfU0VUX0lOVCgwLCAic3BhcnNlIiwgJmRlbnNlLAoJCQkgICAgTl8oInNob3cgbWVyZ2VzIHJlYWNoYWJsZSBmcm9tIG9ubHkgb25lIHRpcCIpLCAwKSwKCQlPUFRfU0VUX0lOVCgwLCAiZGF0ZS1vcmRlciIsICZzb3J0X29yZGVyLAoJCQkgICAgTl8oInRvcG9sb2dpY2FsbHkgc29ydCwgbWFpbnRhaW5pbmcgZGF0ZSBvcmRlciAiCgkJCSAgICAgICAid2hlcmUgcG9zc2libGUiKSwKCQkJICAgIFJFVl9TT1JUX0JZX0NPTU1JVF9EQVRFKSwKCQl7IE9QVElPTl9DQUxMQkFDSywgJ2cnLCAicmVmbG9nIiwgJnJlZmxvZ19iYXNlLCBOXygiPG4+Wyw8YmFzZT5dIiksCgkJCSAgICBOXygic2hvdyA8bj4gbW9zdCByZWNlbnQgcmVmLWxvZyBlbnRyaWVzIHN0YXJ0aW5nIGF0ICIKCQkJICAgICAgICJiYXNlIiksCgkJCSAgICBQQVJTRV9PUFRfT1BUQVJHIHwgUEFSU0VfT1BUX0xJVEVSQUxfQVJHSEVMUCwKCQkJICAgIHBhcnNlX3JlZmxvZ19wYXJhbSB9LAoJCU9QVF9FTkQoKQoJfTsKCglnaXRfY29uZmlnKGdpdF9zaG93X2JyYW5jaF9jb25maWcsIE5VTEwpOwoKCS8qIElmIG5vdGhpbmcgaXMgc3BlY2lmaWVkLCB0cnkgdGhlIGRlZmF1bHQgZmlyc3QgKi8KCWlmIChhYyA9PSAxICYmIGRlZmF1bHRfbnVtKSB7CgkJYWMgPSBkZWZhdWx0X251bTsKCQlhdiA9IGRlZmF1bHRfYXJnOwoJfQoKCWFjID0gcGFyc2Vfb3B0aW9ucyhhYywgYXYsIHByZWZpeCwgYnVpbHRpbl9zaG93X2JyYW5jaF9vcHRpb25zLAoJCQkgICBzaG93X2JyYW5jaF91c2FnZSwgUEFSU0VfT1BUX1NUT1BfQVRfTk9OX09QVElPTik7CglpZiAoYWxsX2hlYWRzKQoJCWFsbF9yZW1vdGVzID0gMTsKCglpZiAoZXh0cmEgfHwgcmVmbG9nKSB7CgkJLyogImxpc3RpbmciIG1vZGUgaXMgaW5jb21wYXRpYmxlIHdpdGgKCQkgKiBpbmRlcGVuZGVudCBub3IgbWVyZ2UtYmFzZSBtb2Rlcy4KCQkgKi8KCQlpZiAoaW5kZXBlbmRlbnQgfHwgbWVyZ2VfYmFzZSkKCQkJdXNhZ2Vfd2l0aF9vcHRpb25zKHNob3dfYnJhbmNoX3VzYWdlLAoJCQkJCSAgIGJ1aWx0aW5fc2hvd19icmFuY2hfb3B0aW9ucyk7CgkJaWYgKHJlZmxvZyAmJiAoKDAgPCBleHRyYSkgfHwgYWxsX2hlYWRzIHx8IGFsbF9yZW1vdGVzKSkKCQkJLyoKCQkJICogQXNraW5nIGZvciAtLW1vcmUgaW4gcmVmbG9nIG1vZGUgZG9lcyBub3QKCQkJICogbWFrZSBzZW5zZS4gIC0tbGlzdCBpcyBPay4KCQkJICoKCQkJICogQWxzbyAtLWFsbCBhbmQgLS1yZW1vdGVzIGRvIG5vdCBtYWtlIHNlbnNlIGVpdGhlci4KCQkJICovCgkJCWRpZSgiLS1yZWZsb2cgaXMgaW5jb21wYXRpYmxlIHdpdGggLS1hbGwsIC0tcmVtb3RlcywgIgoJCQkgICAgIi0taW5kZXBlbmRlbnQgb3IgLS1tZXJnZS1iYXNlIik7Cgl9CgoJLyogSWYgbm90aGluZyBpcyBzcGVjaWZpZWQsIHNob3cgYWxsIGJyYW5jaGVzIGJ5IGRlZmF1bHQgKi8KCWlmIChhYyArIGFsbF9oZWFkcyArIGFsbF9yZW1vdGVzID09IDApCgkJYWxsX2hlYWRzID0gMTsKCglpZiAocmVmbG9nKSB7CgkJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCQljaGFyIG50aF9kZXNjWzI1Nl07CgkJY2hhciAqcmVmOwoJCWludCBiYXNlID0gMDsKCgkJaWYgKGFjID09IDApIHsKCQkJc3RhdGljIGNvbnN0IGNoYXIgKmZha2VfYXZbMl07CgoJCQlmYWtlX2F2WzBdID0gcmVzb2x2ZV9yZWZkdXAoIkhFQUQiLCBzaGExLCAxLCBOVUxMKTsKCQkJZmFrZV9hdlsxXSA9IE5VTEw7CgkJCWF2ID0gZmFrZV9hdjsKCQkJYWMgPSAxOwoJCX0KCQlpZiAoYWMgIT0gMSkKCQkJZGllKCItLXJlZmxvZyBvcHRpb24gbmVlZHMgb25lIGJyYW5jaCBuYW1lIik7CgoJCWlmIChNQVhfUkVWUyA8IHJlZmxvZykKCQkJZGllKCJPbmx5ICVkIGVudHJpZXMgY2FuIGJlIHNob3duIGF0IG9uZSB0aW1lLiIsCgkJCSAgICBNQVhfUkVWUyk7CgkJaWYgKCFkd2ltX3JlZigqYXYsIHN0cmxlbigqYXYpLCBzaGExLCAmcmVmKSkKCQkJZGllKCJObyBzdWNoIHJlZiAlcyIsICphdik7CgoJCS8qIEhhcyB0aGUgYmFzZSBiZWVuIHNwZWNpZmllZD8gKi8KCQlpZiAocmVmbG9nX2Jhc2UpIHsKCQkJY2hhciAqZXA7CgkJCWJhc2UgPSBzdHJ0b3VsKHJlZmxvZ19iYXNlLCAmZXAsIDEwKTsKCQkJaWYgKCplcCkgewoJCQkJLyogQWgsIHRoYXQgaXMgYSBkYXRlIHNwZWMuLi4gKi8KCQkJCXVuc2lnbmVkIGxvbmcgYXQ7CgkJCQlhdCA9IGFwcHJveGlkYXRlKHJlZmxvZ19iYXNlKTsKCQkJCXJlYWRfcmVmX2F0KHJlZiwgYXQsIC0xLCBzaGExLCBOVUxMLAoJCQkJCSAgICBOVUxMLCBOVUxMLCAmYmFzZSk7CgkJCX0KCQl9CgoJCWZvciAoaSA9IDA7IGkgPCByZWZsb2c7IGkrKykgewoJCQljaGFyICpsb2dtc2csICptOwoJCQljb25zdCBjaGFyICptc2c7CgkJCXVuc2lnbmVkIGxvbmcgdGltZXN0YW1wOwoJCQlpbnQgdHo7CgoJCQlpZiAocmVhZF9yZWZfYXQocmVmLCAwLCBiYXNlK2ksIHNoYTEsICZsb2dtc2csCgkJCQkJJnRpbWVzdGFtcCwgJnR6LCBOVUxMKSkgewoJCQkJcmVmbG9nID0gaTsKCQkJCWJyZWFrOwoJCQl9CgkJCW1zZyA9IHN0cmNocihsb2dtc2csICdcdCcpOwoJCQlpZiAoIW1zZykKCQkJCW1zZyA9ICIobm9uZSkiOwoJCQllbHNlCgkJCQltc2crKzsKCQkJbSA9IHhtYWxsb2Moc3RybGVuKG1zZykgKyAyMDApOwoJCQlzcHJpbnRmKG0sICIoJXMpICVzIiwKCQkJCXNob3dfZGF0ZSh0aW1lc3RhbXAsIHR6LCAxKSwKCQkJCW1zZyk7CgkJCXJlZmxvZ19tc2dbaV0gPSBtOwoJCQlmcmVlKGxvZ21zZyk7CgkJCXNwcmludGYobnRoX2Rlc2MsICIlc0B7JWR9IiwgKmF2LCBiYXNlK2kpOwoJCQlhcHBlbmRfcmVmKG50aF9kZXNjLCBzaGExLCAxKTsKCQl9Cgl9CgllbHNlIGlmIChhbGxfaGVhZHMgKyBhbGxfcmVtb3RlcykKCQlzbmFyZl9yZWZzKGFsbF9oZWFkcywgYWxsX3JlbW90ZXMpOwoJZWxzZSB7CgkJd2hpbGUgKDAgPCBhYykgewoJCQlhcHBlbmRfb25lX3JldigqYXYpOwoJCQlhYy0tOyBhdisrOwoJCX0KCX0KCgloZWFkX3AgPSByZXNvbHZlX3JlZl91bnNhZmUoIkhFQUQiLCBoZWFkX3NoYTEsIDEsIE5VTEwpOwoJaWYgKGhlYWRfcCkgewoJCWhlYWRfbGVuID0gc3RybGVuKGhlYWRfcCk7CgkJbWVtY3B5KGhlYWQsIGhlYWRfcCwgaGVhZF9sZW4gKyAxKTsKCX0KCWVsc2UgewoJCWhlYWRfbGVuID0gMDsKCQloZWFkWzBdID0gMDsKCX0KCglpZiAod2l0aF9jdXJyZW50X2JyYW5jaCAmJiBoZWFkX3ApIHsKCQlpbnQgaGFzX2hlYWQgPSAwOwoJCWZvciAoaSA9IDA7ICFoYXNfaGVhZCAmJiBpIDwgcmVmX25hbWVfY250OyBpKyspIHsKCQkJLyogV2UgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiBhZGRpbmcgdGhlIGJyYW5jaAoJCQkgKiBIRUFEIHBvaW50cyBhdC4KCQkJICovCgkJCWlmIChyZXZfaXNfaGVhZChoZWFkLAoJCQkJCWhlYWRfbGVuLAoJCQkJCXJlZl9uYW1lW2ldLAoJCQkJCWhlYWRfc2hhMSwgTlVMTCkpCgkJCQloYXNfaGVhZCsrOwoJCX0KCQlpZiAoIWhhc19oZWFkKSB7CgkJCWludCBvZmZzZXQgPSAhcHJlZml4Y21wKGhlYWQsICJyZWZzL2hlYWRzLyIpID8gMTEgOiAwOwoJCQlhcHBlbmRfb25lX3JldihoZWFkICsgb2Zmc2V0KTsKCQl9Cgl9CgoJaWYgKCFyZWZfbmFtZV9jbnQpIHsKCQlmcHJpbnRmKHN0ZGVyciwgIk5vIHJldnMgdG8gYmUgc2hvd24uXG4iKTsKCQlleGl0KDApOwoJfQoKCWZvciAobnVtX3JldiA9IDA7IHJlZl9uYW1lW251bV9yZXZdOyBudW1fcmV2KyspIHsKCQl1bnNpZ25lZCBjaGFyIHJldmtleVsyMF07CgkJdW5zaWduZWQgaW50IGZsYWcgPSAxdSA8PCAobnVtX3JldiArIFJFVl9TSElGVCk7CgoJCWlmIChNQVhfUkVWUyA8PSBudW1fcmV2KQoJCQlkaWUoImNhbm5vdCBoYW5kbGUgbW9yZSB0aGFuICVkIHJldnMuIiwgTUFYX1JFVlMpOwoJCWlmIChnZXRfc2hhMShyZWZfbmFtZVtudW1fcmV2XSwgcmV2a2V5KSkKCQkJZGllKCInJXMnIGlzIG5vdCBhIHZhbGlkIHJlZi4iLCByZWZfbmFtZVtudW1fcmV2XSk7CgkJY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2UocmV2a2V5KTsKCQlpZiAoIWNvbW1pdCkKCQkJZGllKCJjYW5ub3QgZmluZCBjb21taXQgJXMgKCVzKSIsCgkJCSAgICByZWZfbmFtZVtudW1fcmV2XSwgcmV2a2V5KTsKCQlwYXJzZV9jb21taXQoY29tbWl0KTsKCQltYXJrX3NlZW4oY29tbWl0LCAmc2Vlbik7CgoJCS8qIHJldiMwIHVzZXMgYml0IFJFVl9TSElGVCwgcmV2IzEgdXNlcyBiaXQgUkVWX1NISUZUKzEsCgkJICogYW5kIHNvIG9uLiAgUkVWX1NISUZUIGJpdHMgZnJvbSBiaXQgMCBhcmUgdXNlZCBmb3IKCQkgKiBpbnRlcm5hbCBib29ra2VlcGluZy4KCQkgKi8KCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBmbGFnOwoJCWlmIChjb21taXQtPm9iamVjdC5mbGFncyA9PSBmbGFnKQoJCQljb21taXRfbGlzdF9pbnNlcnRfYnlfZGF0ZShjb21taXQsICZsaXN0KTsKCQlyZXZbbnVtX3Jldl0gPSBjb21taXQ7Cgl9Cglmb3IgKGkgPSAwOyBpIDwgbnVtX3JldjsgaSsrKQoJCXJldl9tYXNrW2ldID0gcmV2W2ldLT5vYmplY3QuZmxhZ3M7CgoJaWYgKDAgPD0gZXh0cmEpCgkJam9pbl9yZXZzKCZsaXN0LCAmc2VlbiwgbnVtX3JldiwgZXh0cmEpOwoKCWNvbW1pdF9saXN0X3NvcnRfYnlfZGF0ZSgmc2Vlbik7CgoJaWYgKG1lcmdlX2Jhc2UpCgkJcmV0dXJuIHNob3dfbWVyZ2VfYmFzZShzZWVuLCBudW1fcmV2KTsKCglpZiAoaW5kZXBlbmRlbnQpCgkJcmV0dXJuIHNob3dfaW5kZXBlbmRlbnQocmV2LCBudW1fcmV2LCByZWZfbmFtZSwgcmV2X21hc2spOwoKCS8qIFNob3cgbGlzdDsgLS1tb3JlPS0xIG1lYW5zIGxpc3Qtb25seSAqLwoJaWYgKDEgPCBudW1fcmV2IHx8IGV4dHJhIDwgMCkgewoJCWZvciAoaSA9IDA7IGkgPCBudW1fcmV2OyBpKyspIHsKCQkJaW50IGo7CgkJCWludCBpc19oZWFkID0gcmV2X2lzX2hlYWQoaGVhZCwKCQkJCQkJICBoZWFkX2xlbiwKCQkJCQkJICByZWZfbmFtZVtpXSwKCQkJCQkJICBoZWFkX3NoYTEsCgkJCQkJCSAgcmV2W2ldLT5vYmplY3Quc2hhMSk7CgkJCWlmIChleHRyYSA8IDApCgkJCQlwcmludGYoIiVjIFslc10gIiwKCQkJCSAgICAgICBpc19oZWFkID8gJyonIDogJyAnLCByZWZfbmFtZVtpXSk7CgkJCWVsc2UgewoJCQkJZm9yIChqID0gMDsgaiA8IGk7IGorKykKCQkJCQlwdXRjaGFyKCcgJyk7CgkJCQlwcmludGYoIiVzJWMlcyBbJXNdICIsCgkJCQkgICAgICAgZ2V0X2NvbG9yX2NvZGUoaSksCgkJCQkgICAgICAgaXNfaGVhZCA/ICcqJyA6ICchJywKCQkJCSAgICAgICBnZXRfY29sb3JfcmVzZXRfY29kZSgpLCByZWZfbmFtZVtpXSk7CgkJCX0KCgkJCWlmICghcmVmbG9nKSB7CgkJCQkvKiBoZWFkZXIgbGluZXMgbmV2ZXIgbmVlZCBuYW1lICovCgkJCQlzaG93X29uZV9jb21taXQocmV2W2ldLCAxKTsKCQkJfQoJCQllbHNlCgkJCQlwdXRzKHJlZmxvZ19tc2dbaV0pOwoKCQkJaWYgKGlzX2hlYWQpCgkJCQloZWFkX2F0ID0gaTsKCQl9CgkJaWYgKDAgPD0gZXh0cmEpIHsKCQkJZm9yIChpID0gMDsgaSA8IG51bV9yZXY7IGkrKykKCQkJCXB1dGNoYXIoJy0nKTsKCQkJcHV0Y2hhcignXG4nKTsKCQl9Cgl9CglpZiAoZXh0cmEgPCAwKQoJCWV4aXQoMCk7CgoJLyogU29ydCB0b3BvbG9naWNhbGx5ICovCglzb3J0X2luX3RvcG9sb2dpY2FsX29yZGVyKCZzZWVuLCBzb3J0X29yZGVyKTsKCgkvKiBHaXZlIG5hbWVzIHRvIGNvbW1pdHMgKi8KCWlmICghc2hhMV9uYW1lICYmICFub19uYW1lKQoJCW5hbWVfY29tbWl0cyhzZWVuLCByZXYsIHJlZl9uYW1lLCBudW1fcmV2KTsKCglhbGxfbWFzayA9ICgoMXUgPDwgKFJFVl9TSElGVCArIG51bV9yZXYpKSAtIDEpOwoJYWxsX3JldnMgPSBhbGxfbWFzayAmIH4oKDF1IDw8IFJFVl9TSElGVCkgLSAxKTsKCgl3aGlsZSAoc2VlbikgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IHBvcF9vbmVfY29tbWl0KCZzZWVuKTsKCQlpbnQgdGhpc19mbGFnID0gY29tbWl0LT5vYmplY3QuZmxhZ3M7CgkJaW50IGlzX21lcmdlX3BvaW50ID0gKCh0aGlzX2ZsYWcgJiBhbGxfcmV2cykgPT0gYWxsX3JldnMpOwoKCQlzaG93bl9tZXJnZV9wb2ludCB8PSBpc19tZXJnZV9wb2ludDsKCgkJaWYgKDEgPCBudW1fcmV2KSB7CgkJCWludCBpc19tZXJnZSA9ICEhKGNvbW1pdC0+cGFyZW50cyAmJgoJCQkJCSAgY29tbWl0LT5wYXJlbnRzLT5uZXh0KTsKCQkJaWYgKHRvcGljcyAmJgoJCQkgICAgIWlzX21lcmdlX3BvaW50ICYmCgkJCSAgICAodGhpc19mbGFnICYgKDF1IDw8IFJFVl9TSElGVCkpKQoJCQkJY29udGludWU7CgkJCWlmIChkZW5zZSAmJiBpc19tZXJnZSAmJgoJCQkgICAgb21pdF9pbl9kZW5zZShjb21taXQsIHJldiwgbnVtX3JldikpCgkJCQljb250aW51ZTsKCQkJZm9yIChpID0gMDsgaSA8IG51bV9yZXY7IGkrKykgewoJCQkJaW50IG1hcms7CgkJCQlpZiAoISh0aGlzX2ZsYWcgJiAoMXUgPDwgKGkgKyBSRVZfU0hJRlQpKSkpCgkJCQkJbWFyayA9ICcgJzsKCQkJCWVsc2UgaWYgKGlzX21lcmdlKQoJCQkJCW1hcmsgPSAnLSc7CgkJCQllbHNlIGlmIChpID09IGhlYWRfYXQpCgkJCQkJbWFyayA9ICcqJzsKCQkJCWVsc2UKCQkJCQltYXJrID0gJysnOwoJCQkJcHJpbnRmKCIlcyVjJXMiLAoJCQkJICAgICAgIGdldF9jb2xvcl9jb2RlKGkpLAoJCQkJICAgICAgIG1hcmssIGdldF9jb2xvcl9yZXNldF9jb2RlKCkpOwoJCQl9CgkJCXB1dGNoYXIoJyAnKTsKCQl9CgkJc2hvd19vbmVfY29tbWl0KGNvbW1pdCwgbm9fbmFtZSk7CgoJCWlmIChzaG93bl9tZXJnZV9wb2ludCAmJiAtLWV4dHJhIDwgMCkKCQkJYnJlYWs7Cgl9CglyZXR1cm4gMDsKfQo=",
    "text": "#include \"cache.h\"\n#include \"commit.h\"\n#include \"refs.h\"\n#include \"builtin.h\"\n#include \"color.h\"\n#include \"parse-options.h\"\n\nstatic const char* show_branch_usage[] = {\n    N_(\"git show-branch [-a|--all] [-r|--remotes] [--topo-order | --date-order] [--current] [--color[=<when>] | --no-color] [--sparse] [--more=<n> | --list | --independent | --merge-base] [--no-name | --sha1-name] [--topics] [(<rev> | <glob>)...]\"),\n    N_(\"git show-branch (-g|--reflog)[=<n>[,<base>]] [--list] [<ref>]\"),\n    NULL\n};\n\nstatic int showbranch_use_color = -1;\n\nstatic int default_num;\nstatic int default_alloc;\nstatic const char **default_arg;\n\n#define UNINTERESTING\t01\n\n#define REV_SHIFT\t 2\n#define MAX_REVS\t(FLAG_BITS - REV_SHIFT) /* should not exceed bits_per_int - REV_SHIFT */\n\n#define DEFAULT_REFLOG\t4\n\nstatic const char *get_color_code(int idx)\n{\n\tif (want_color(showbranch_use_color))\n\t\treturn column_colors_ansi[idx % column_colors_ansi_max];\n\treturn \"\";\n}\n\nstatic const char *get_color_reset_code(void)\n{\n\tif (want_color(showbranch_use_color))\n\t\treturn GIT_COLOR_RESET;\n\treturn \"\";\n}\n\nstatic struct commit *interesting(struct commit_list *list)\n{\n\twhile (list) {\n\t\tstruct commit *commit = list->item;\n\t\tlist = list->next;\n\t\tif (commit->object.flags & UNINTERESTING)\n\t\t\tcontinue;\n\t\treturn commit;\n\t}\n\treturn NULL;\n}\n\nstatic struct commit *pop_one_commit(struct commit_list **list_p)\n{\n\tstruct commit *commit;\n\tstruct commit_list *list;\n\tlist = *list_p;\n\tcommit = list->item;\n\t*list_p = list->next;\n\tfree(list);\n\treturn commit;\n}\n\nstruct commit_name {\n\tconst char *head_name; /* which head's ancestor? */\n\tint generation; /* how many parents away from head_name */\n};\n\n/* Name the commit as nth generation ancestor of head_name;\n * we count only the first-parent relationship for naming purposes.\n */\nstatic void name_commit(struct commit *commit, const char *head_name, int nth)\n{\n\tstruct commit_name *name;\n\tif (!commit->util)\n\t\tcommit->util = xmalloc(sizeof(struct commit_name));\n\tname = commit->util;\n\tname->head_name = head_name;\n\tname->generation = nth;\n}\n\n/* Parent is the first parent of the commit.  We may name it\n * as (n+1)th generation ancestor of the same head_name as\n * commit is nth generation ancestor of, if that generation\n * number is better than the name it already has.\n */\nstatic void name_parent(struct commit *commit, struct commit *parent)\n{\n\tstruct commit_name *commit_name = commit->util;\n\tstruct commit_name *parent_name = parent->util;\n\tif (!commit_name)\n\t\treturn;\n\tif (!parent_name ||\n\t    commit_name->generation + 1 < parent_name->generation)\n\t\tname_commit(parent, commit_name->head_name,\n\t\t\t    commit_name->generation + 1);\n}\n\nstatic int name_first_parent_chain(struct commit *c)\n{\n\tint i = 0;\n\twhile (c) {\n\t\tstruct commit *p;\n\t\tif (!c->util)\n\t\t\tbreak;\n\t\tif (!c->parents)\n\t\t\tbreak;\n\t\tp = c->parents->item;\n\t\tif (!p->util) {\n\t\t\tname_parent(c, p);\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t\tc = p;\n\t}\n\treturn i;\n}\n\nstatic void name_commits(struct commit_list *list,\n\t\t\t struct commit **rev,\n\t\t\t char **ref_name,\n\t\t\t int num_rev)\n{\n\tstruct commit_list *cl;\n\tstruct commit *c;\n\tint i;\n\n\t/* First give names to the given heads */\n\tfor (cl = list; cl; cl = cl->next) {\n\t\tc = cl->item;\n\t\tif (c->util)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < num_rev; i++) {\n\t\t\tif (rev[i] == c) {\n\t\t\t\tname_commit(c, ref_name[i], 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Then commits on the first parent ancestry chain */\n\tdo {\n\t\ti = 0;\n\t\tfor (cl = list; cl; cl = cl->next) {\n\t\t\ti += name_first_parent_chain(cl->item);\n\t\t}\n\t} while (i);\n\n\t/* Finally, any unnamed commits */\n\tdo {\n\t\ti = 0;\n\t\tfor (cl = list; cl; cl = cl->next) {\n\t\t\tstruct commit_list *parents;\n\t\t\tstruct commit_name *n;\n\t\t\tint nth;\n\t\t\tc = cl->item;\n\t\t\tif (!c->util)\n\t\t\t\tcontinue;\n\t\t\tn = c->util;\n\t\t\tparents = c->parents;\n\t\t\tnth = 0;\n\t\t\twhile (parents) {\n\t\t\t\tstruct commit *p = parents->item;\n\t\t\t\tstruct strbuf newname = STRBUF_INIT;\n\t\t\t\tparents = parents->next;\n\t\t\t\tnth++;\n\t\t\t\tif (p->util)\n\t\t\t\t\tcontinue;\n\t\t\t\tswitch (n->generation) {\n\t\t\t\tcase 0:\n\t\t\t\t\tstrbuf_addstr(&newname, n->head_name);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tstrbuf_addf(&newname, \"%s^\", n->head_name);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstrbuf_addf(&newname, \"%s~%d\",\n\t\t\t\t\t\t    n->head_name, n->generation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (nth == 1)\n\t\t\t\t\tstrbuf_addch(&newname, '^');\n\t\t\t\telse\n\t\t\t\t\tstrbuf_addf(&newname, \"^%d\", nth);\n\t\t\t\tname_commit(p, strbuf_detach(&newname, NULL), 0);\n\t\t\t\ti++;\n\t\t\t\tname_first_parent_chain(p);\n\t\t\t}\n\t\t}\n\t} while (i);\n}\n\nstatic int mark_seen(struct commit *commit, struct commit_list **seen_p)\n{\n\tif (!commit->object.flags) {\n\t\tcommit_list_insert(commit, seen_p);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void join_revs(struct commit_list **list_p,\n\t\t      struct commit_list **seen_p,\n\t\t      int num_rev, int extra)\n{\n\tint all_mask = ((1u << (REV_SHIFT + num_rev)) - 1);\n\tint all_revs = all_mask & ~((1u << REV_SHIFT) - 1);\n\n\twhile (*list_p) {\n\t\tstruct commit_list *parents;\n\t\tint still_interesting = !!interesting(*list_p);\n\t\tstruct commit *commit = pop_one_commit(list_p);\n\t\tint flags = commit->object.flags & all_mask;\n\n\t\tif (!still_interesting && extra <= 0)\n\t\t\tbreak;\n\n\t\tmark_seen(commit, seen_p);\n\t\tif ((flags & all_revs) == all_revs)\n\t\t\tflags |= UNINTERESTING;\n\t\tparents = commit->parents;\n\n\t\twhile (parents) {\n\t\t\tstruct commit *p = parents->item;\n\t\t\tint this_flag = p->object.flags;\n\t\t\tparents = parents->next;\n\t\t\tif ((this_flag & flags) == flags)\n\t\t\t\tcontinue;\n\t\t\tif (!p->object.parsed)\n\t\t\t\tparse_commit(p);\n\t\t\tif (mark_seen(p, seen_p) && !still_interesting)\n\t\t\t\textra--;\n\t\t\tp->object.flags |= flags;\n\t\t\tcommit_list_insert_by_date(p, list_p);\n\t\t}\n\t}\n\n\t/*\n\t * Postprocess to complete well-poisoning.\n\t *\n\t * At this point we have all the commits we have seen in\n\t * seen_p list.  Mark anything that can be reached from\n\t * uninteresting commits not interesting.\n\t */\n\tfor (;;) {\n\t\tint changed = 0;\n\t\tstruct commit_list *s;\n\t\tfor (s = *seen_p; s; s = s->next) {\n\t\t\tstruct commit *c = s->item;\n\t\t\tstruct commit_list *parents;\n\n\t\t\tif (((c->object.flags & all_revs) != all_revs) &&\n\t\t\t    !(c->object.flags & UNINTERESTING))\n\t\t\t\tcontinue;\n\n\t\t\t/* The current commit is either a merge base or\n\t\t\t * already uninteresting one.  Mark its parents\n\t\t\t * as uninteresting commits _only_ if they are\n\t\t\t * already parsed.  No reason to find new ones\n\t\t\t * here.\n\t\t\t */\n\t\t\tparents = c->parents;\n\t\t\twhile (parents) {\n\t\t\t\tstruct commit *p = parents->item;\n\t\t\t\tparents = parents->next;\n\t\t\t\tif (!(p->object.flags & UNINTERESTING)) {\n\t\t\t\t\tp->object.flags |= UNINTERESTING;\n\t\t\t\t\tchanged = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!changed)\n\t\t\tbreak;\n\t}\n}\n\nstatic void show_one_commit(struct commit *commit, int no_name)\n{\n\tstruct strbuf pretty = STRBUF_INIT;\n\tconst char *pretty_str = \"(unavailable)\";\n\tstruct commit_name *name = commit->util;\n\n\tif (commit->object.parsed) {\n\t\tpp_commit_easy(CMIT_FMT_ONELINE, commit, &pretty);\n\t\tpretty_str = pretty.buf;\n\t}\n\tif (!prefixcmp(pretty_str, \"[PATCH] \"))\n\t\tpretty_str += 8;\n\n\tif (!no_name) {\n\t\tif (name && name->head_name) {\n\t\t\tprintf(\"[%s\", name->head_name);\n\t\t\tif (name->generation) {\n\t\t\t\tif (name->generation == 1)\n\t\t\t\t\tprintf(\"^\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"~%d\", name->generation);\n\t\t\t}\n\t\t\tprintf(\"] \");\n\t\t}\n\t\telse\n\t\t\tprintf(\"[%s] \",\n\t\t\t       find_unique_abbrev(commit->object.sha1,\n\t\t\t\t\t\t  DEFAULT_ABBREV));\n\t}\n\tputs(pretty_str);\n\tstrbuf_release(&pretty);\n}\n\nstatic char *ref_name[MAX_REVS + 1];\nstatic int ref_name_cnt;\n\nstatic const char *find_digit_prefix(const char *s, int *v)\n{\n\tconst char *p;\n\tint ver;\n\tchar ch;\n\n\tfor (p = s, ver = 0;\n\t     '0' <= (ch = *p) && ch <= '9';\n\t     p++)\n\t\tver = ver * 10 + ch - '0';\n\t*v = ver;\n\treturn p;\n}\n\n\nstatic int version_cmp(const char *a, const char *b)\n{\n\twhile (1) {\n\t\tint va, vb;\n\n\t\ta = find_digit_prefix(a, &va);\n\t\tb = find_digit_prefix(b, &vb);\n\t\tif (va != vb)\n\t\t\treturn va - vb;\n\n\t\twhile (1) {\n\t\t\tint ca = *a;\n\t\t\tint cb = *b;\n\t\t\tif ('0' <= ca && ca <= '9')\n\t\t\t\tca = 0;\n\t\t\tif ('0' <= cb && cb <= '9')\n\t\t\t\tcb = 0;\n\t\t\tif (ca != cb)\n\t\t\t\treturn ca - cb;\n\t\t\tif (!ca)\n\t\t\t\tbreak;\n\t\t\ta++;\n\t\t\tb++;\n\t\t}\n\t\tif (!*a && !*b)\n\t\t\treturn 0;\n\t}\n}\n\nstatic int compare_ref_name(const void *a_, const void *b_)\n{\n\tconst char * const*a = a_, * const*b = b_;\n\treturn version_cmp(*a, *b);\n}\n\nstatic void sort_ref_range(int bottom, int top)\n{\n\tqsort(ref_name + bottom, top - bottom, sizeof(ref_name[0]),\n\t      compare_ref_name);\n}\n\nstatic int append_ref(const char *refname, const unsigned char *sha1,\n\t\t      int allow_dups)\n{\n\tstruct commit *commit = lookup_commit_reference_gently(sha1, 1);\n\tint i;\n\n\tif (!commit)\n\t\treturn 0;\n\n\tif (!allow_dups) {\n\t\t/* Avoid adding the same thing twice */\n\t\tfor (i = 0; i < ref_name_cnt; i++)\n\t\t\tif (!strcmp(refname, ref_name[i]))\n\t\t\t\treturn 0;\n\t}\n\tif (MAX_REVS <= ref_name_cnt) {\n\t\twarning(\"ignoring %s; cannot handle more than %d refs\",\n\t\t\trefname, MAX_REVS);\n\t\treturn 0;\n\t}\n\tref_name[ref_name_cnt++] = xstrdup(refname);\n\tref_name[ref_name_cnt] = NULL;\n\treturn 0;\n}\n\nstatic int append_head_ref(const char *refname, const unsigned char *sha1, int flag, void *cb_data)\n{\n\tunsigned char tmp[20];\n\tint ofs = 11;\n\tif (prefixcmp(refname, \"refs/heads/\"))\n\t\treturn 0;\n\t/* If both heads/foo and tags/foo exists, get_sha1 would\n\t * get confused.\n\t */\n\tif (get_sha1(refname + ofs, tmp) || hashcmp(tmp, sha1))\n\t\tofs = 5;\n\treturn append_ref(refname + ofs, sha1, 0);\n}\n\nstatic int append_remote_ref(const char *refname, const unsigned char *sha1, int flag, void *cb_data)\n{\n\tunsigned char tmp[20];\n\tint ofs = 13;\n\tif (prefixcmp(refname, \"refs/remotes/\"))\n\t\treturn 0;\n\t/* If both heads/foo and tags/foo exists, get_sha1 would\n\t * get confused.\n\t */\n\tif (get_sha1(refname + ofs, tmp) || hashcmp(tmp, sha1))\n\t\tofs = 5;\n\treturn append_ref(refname + ofs, sha1, 0);\n}\n\nstatic int append_tag_ref(const char *refname, const unsigned char *sha1, int flag, void *cb_data)\n{\n\tif (prefixcmp(refname, \"refs/tags/\"))\n\t\treturn 0;\n\treturn append_ref(refname + 5, sha1, 0);\n}\n\nstatic const char *match_ref_pattern = NULL;\nstatic int match_ref_slash = 0;\nstatic int count_slash(const char *s)\n{\n\tint cnt = 0;\n\twhile (*s)\n\t\tif (*s++ == '/')\n\t\t\tcnt++;\n\treturn cnt;\n}\n\nstatic int append_matching_ref(const char *refname, const unsigned char *sha1, int flag, void *cb_data)\n{\n\t/* we want to allow pattern hold/<asterisk> to show all\n\t * branches under refs/heads/hold/, and v0.99.9? to show\n\t * refs/tags/v0.99.9a and friends.\n\t */\n\tconst char *tail;\n\tint slash = count_slash(refname);\n\tfor (tail = refname; *tail && match_ref_slash < slash; )\n\t\tif (*tail++ == '/')\n\t\t\tslash--;\n\tif (!*tail)\n\t\treturn 0;\n\tif (fnmatch(match_ref_pattern, tail, 0))\n\t\treturn 0;\n\tif (!prefixcmp(refname, \"refs/heads/\"))\n\t\treturn append_head_ref(refname, sha1, flag, cb_data);\n\tif (!prefixcmp(refname, \"refs/tags/\"))\n\t\treturn append_tag_ref(refname, sha1, flag, cb_data);\n\treturn append_ref(refname, sha1, 0);\n}\n\nstatic void snarf_refs(int head, int remotes)\n{\n\tif (head) {\n\t\tint orig_cnt = ref_name_cnt;\n\t\tfor_each_ref(append_head_ref, NULL);\n\t\tsort_ref_range(orig_cnt, ref_name_cnt);\n\t}\n\tif (remotes) {\n\t\tint orig_cnt = ref_name_cnt;\n\t\tfor_each_ref(append_remote_ref, NULL);\n\t\tsort_ref_range(orig_cnt, ref_name_cnt);\n\t}\n}\n\nstatic int rev_is_head(char *head, int headlen, char *name,\n\t\t       unsigned char *head_sha1, unsigned char *sha1)\n{\n\tif ((!head[0]) ||\n\t    (head_sha1 && sha1 && hashcmp(head_sha1, sha1)))\n\t\treturn 0;\n\tif (!prefixcmp(head, \"refs/heads/\"))\n\t\thead += 11;\n\tif (!prefixcmp(name, \"refs/heads/\"))\n\t\tname += 11;\n\telse if (!prefixcmp(name, \"heads/\"))\n\t\tname += 6;\n\treturn !strcmp(head, name);\n}\n\nstatic int show_merge_base(struct commit_list *seen, int num_rev)\n{\n\tint all_mask = ((1u << (REV_SHIFT + num_rev)) - 1);\n\tint all_revs = all_mask & ~((1u << REV_SHIFT) - 1);\n\tint exit_status = 1;\n\n\twhile (seen) {\n\t\tstruct commit *commit = pop_one_commit(&seen);\n\t\tint flags = commit->object.flags & all_mask;\n\t\tif (!(flags & UNINTERESTING) &&\n\t\t    ((flags & all_revs) == all_revs)) {\n\t\t\tputs(sha1_to_hex(commit->object.sha1));\n\t\t\texit_status = 0;\n\t\t\tcommit->object.flags |= UNINTERESTING;\n\t\t}\n\t}\n\treturn exit_status;\n}\n\nstatic int show_independent(struct commit **rev,\n\t\t\t    int num_rev,\n\t\t\t    char **ref_name,\n\t\t\t    unsigned int *rev_mask)\n{\n\tint i;\n\n\tfor (i = 0; i < num_rev; i++) {\n\t\tstruct commit *commit = rev[i];\n\t\tunsigned int flag = rev_mask[i];\n\n\t\tif (commit->object.flags == flag)\n\t\t\tputs(sha1_to_hex(commit->object.sha1));\n\t\tcommit->object.flags |= UNINTERESTING;\n\t}\n\treturn 0;\n}\n\nstatic void append_one_rev(const char *av)\n{\n\tunsigned char revkey[20];\n\tif (!get_sha1(av, revkey)) {\n\t\tappend_ref(av, revkey, 0);\n\t\treturn;\n\t}\n\tif (strchr(av, '*') || strchr(av, '?') || strchr(av, '[')) {\n\t\t/* glob style match */\n\t\tint saved_matches = ref_name_cnt;\n\t\tmatch_ref_pattern = av;\n\t\tmatch_ref_slash = count_slash(av);\n\t\tfor_each_ref(append_matching_ref, NULL);\n\t\tif (saved_matches == ref_name_cnt &&\n\t\t    ref_name_cnt < MAX_REVS)\n\t\t\terror(\"no matching refs with %s\", av);\n\t\tif (saved_matches + 1 < ref_name_cnt)\n\t\t\tsort_ref_range(saved_matches, ref_name_cnt);\n\t\treturn;\n\t}\n\tdie(\"bad sha1 reference %s\", av);\n}\n\nstatic int git_show_branch_config(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(var, \"showbranch.default\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\t/*\n\t\t * default_arg is now passed to parse_options(), so we need to\n\t\t * mimic the real argv a bit better.\n\t\t */\n\t\tif (!default_num) {\n\t\t\tdefault_alloc = 20;\n\t\t\tdefault_arg = xcalloc(default_alloc, sizeof(*default_arg));\n\t\t\tdefault_arg[default_num++] = \"show-branch\";\n\t\t} else if (default_alloc <= default_num + 1) {\n\t\t\tdefault_alloc = default_alloc * 3 / 2 + 20;\n\t\t\tdefault_arg = xrealloc(default_arg, sizeof *default_arg * default_alloc);\n\t\t}\n\t\tdefault_arg[default_num++] = xstrdup(value);\n\t\tdefault_arg[default_num] = NULL;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"color.showbranch\")) {\n\t\tshowbranch_use_color = git_config_colorbool(var, value);\n\t\treturn 0;\n\t}\n\n\treturn git_color_default_config(var, value, cb);\n}\n\nstatic int omit_in_dense(struct commit *commit, struct commit **rev, int n)\n{\n\t/* If the commit is tip of the named branches, do not\n\t * omit it.\n\t * Otherwise, if it is a merge that is reachable from only one\n\t * tip, it is not that interesting.\n\t */\n\tint i, flag, count;\n\tfor (i = 0; i < n; i++)\n\t\tif (rev[i] == commit)\n\t\t\treturn 0;\n\tflag = commit->object.flags;\n\tfor (i = count = 0; i < n; i++) {\n\t\tif (flag & (1u << (i + REV_SHIFT)))\n\t\t\tcount++;\n\t}\n\tif (count == 1)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int reflog = 0;\n\nstatic int parse_reflog_param(const struct option *opt, const char *arg,\n\t\t\t      int unset)\n{\n\tchar *ep;\n\tconst char **base = (const char **)opt->value;\n\tif (!arg)\n\t\targ = \"\";\n\treflog = strtoul(arg, &ep, 10);\n\tif (*ep == ',')\n\t\t*base = ep + 1;\n\telse if (*ep)\n\t\treturn error(\"unrecognized reflog param '%s'\", arg);\n\telse\n\t\t*base = NULL;\n\tif (reflog <= 0)\n\t\treflog = DEFAULT_REFLOG;\n\treturn 0;\n}\n\nint cmd_show_branch(int ac, const char **av, const char *prefix)\n{\n\tstruct commit *rev[MAX_REVS], *commit;\n\tchar *reflog_msg[MAX_REVS];\n\tstruct commit_list *list = NULL, *seen = NULL;\n\tunsigned int rev_mask[MAX_REVS];\n\tint num_rev, i, extra = 0;\n\tint all_heads = 0, all_remotes = 0;\n\tint all_mask, all_revs;\n\tenum rev_sort_order sort_order = REV_SORT_IN_GRAPH_ORDER;\n\tchar head[128];\n\tconst char *head_p;\n\tint head_len;\n\tunsigned char head_sha1[20];\n\tint merge_base = 0;\n\tint independent = 0;\n\tint no_name = 0;\n\tint sha1_name = 0;\n\tint shown_merge_point = 0;\n\tint with_current_branch = 0;\n\tint head_at = -1;\n\tint topics = 0;\n\tint dense = 1;\n\tconst char *reflog_base = NULL;\n\tstruct option builtin_show_branch_options[] = {\n\t\tOPT_BOOL('a', \"all\", &all_heads,\n\t\t\t N_(\"show remote-tracking and local branches\")),\n\t\tOPT_BOOL('r', \"remotes\", &all_remotes,\n\t\t\t N_(\"show remote-tracking branches\")),\n\t\tOPT__COLOR(&showbranch_use_color,\n\t\t\t    N_(\"color '*!+-' corresponding to the branch\")),\n\t\t{ OPTION_INTEGER, 0, \"more\", &extra, N_(\"n\"),\n\t\t\t    N_(\"show <n> more commits after the common ancestor\"),\n\t\t\t    PARSE_OPT_OPTARG, NULL, (intptr_t)1 },\n\t\tOPT_SET_INT(0, \"list\", &extra, N_(\"synonym to more=-1\"), -1),\n\t\tOPT_BOOL(0, \"no-name\", &no_name, N_(\"suppress naming strings\")),\n\t\tOPT_BOOL(0, \"current\", &with_current_branch,\n\t\t\t N_(\"include the current branch\")),\n\t\tOPT_BOOL(0, \"sha1-name\", &sha1_name,\n\t\t\t N_(\"name commits with their object names\")),\n\t\tOPT_BOOL(0, \"merge-base\", &merge_base,\n\t\t\t N_(\"show possible merge bases\")),\n\t\tOPT_BOOL(0, \"independent\", &independent,\n\t\t\t    N_(\"show refs unreachable from any other ref\")),\n\t\tOPT_SET_INT(0, \"topo-order\", &sort_order,\n\t\t\t    N_(\"show commits in topological order\"),\n\t\t\t    REV_SORT_IN_GRAPH_ORDER),\n\t\tOPT_BOOL(0, \"topics\", &topics,\n\t\t\t N_(\"show only commits not on the first branch\")),\n\t\tOPT_SET_INT(0, \"sparse\", &dense,\n\t\t\t    N_(\"show merges reachable from only one tip\"), 0),\n\t\tOPT_SET_INT(0, \"date-order\", &sort_order,\n\t\t\t    N_(\"topologically sort, maintaining date order \"\n\t\t\t       \"where possible\"),\n\t\t\t    REV_SORT_BY_COMMIT_DATE),\n\t\t{ OPTION_CALLBACK, 'g', \"reflog\", &reflog_base, N_(\"<n>[,<base>]\"),\n\t\t\t    N_(\"show <n> most recent ref-log entries starting at \"\n\t\t\t       \"base\"),\n\t\t\t    PARSE_OPT_OPTARG | PARSE_OPT_LITERAL_ARGHELP,\n\t\t\t    parse_reflog_param },\n\t\tOPT_END()\n\t};\n\n\tgit_config(git_show_branch_config, NULL);\n\n\t/* If nothing is specified, try the default first */\n\tif (ac == 1 && default_num) {\n\t\tac = default_num;\n\t\tav = default_arg;\n\t}\n\n\tac = parse_options(ac, av, prefix, builtin_show_branch_options,\n\t\t\t   show_branch_usage, PARSE_OPT_STOP_AT_NON_OPTION);\n\tif (all_heads)\n\t\tall_remotes = 1;\n\n\tif (extra || reflog) {\n\t\t/* \"listing\" mode is incompatible with\n\t\t * independent nor merge-base modes.\n\t\t */\n\t\tif (independent || merge_base)\n\t\t\tusage_with_options(show_branch_usage,\n\t\t\t\t\t   builtin_show_branch_options);\n\t\tif (reflog && ((0 < extra) || all_heads || all_remotes))\n\t\t\t/*\n\t\t\t * Asking for --more in reflog mode does not\n\t\t\t * make sense.  --list is Ok.\n\t\t\t *\n\t\t\t * Also --all and --remotes do not make sense either.\n\t\t\t */\n\t\t\tdie(\"--reflog is incompatible with --all, --remotes, \"\n\t\t\t    \"--independent or --merge-base\");\n\t}\n\n\t/* If nothing is specified, show all branches by default */\n\tif (ac + all_heads + all_remotes == 0)\n\t\tall_heads = 1;\n\n\tif (reflog) {\n\t\tunsigned char sha1[20];\n\t\tchar nth_desc[256];\n\t\tchar *ref;\n\t\tint base = 0;\n\n\t\tif (ac == 0) {\n\t\t\tstatic const char *fake_av[2];\n\n\t\t\tfake_av[0] = resolve_refdup(\"HEAD\", sha1, 1, NULL);\n\t\t\tfake_av[1] = NULL;\n\t\t\tav = fake_av;\n\t\t\tac = 1;\n\t\t}\n\t\tif (ac != 1)\n\t\t\tdie(\"--reflog option needs one branch name\");\n\n\t\tif (MAX_REVS < reflog)\n\t\t\tdie(\"Only %d entries can be shown at one time.\",\n\t\t\t    MAX_REVS);\n\t\tif (!dwim_ref(*av, strlen(*av), sha1, &ref))\n\t\t\tdie(\"No such ref %s\", *av);\n\n\t\t/* Has the base been specified? */\n\t\tif (reflog_base) {\n\t\t\tchar *ep;\n\t\t\tbase = strtoul(reflog_base, &ep, 10);\n\t\t\tif (*ep) {\n\t\t\t\t/* Ah, that is a date spec... */\n\t\t\t\tunsigned long at;\n\t\t\t\tat = approxidate(reflog_base);\n\t\t\t\tread_ref_at(ref, at, -1, sha1, NULL,\n\t\t\t\t\t    NULL, NULL, &base);\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < reflog; i++) {\n\t\t\tchar *logmsg, *m;\n\t\t\tconst char *msg;\n\t\t\tunsigned long timestamp;\n\t\t\tint tz;\n\n\t\t\tif (read_ref_at(ref, 0, base+i, sha1, &logmsg,\n\t\t\t\t\t&timestamp, &tz, NULL)) {\n\t\t\t\treflog = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsg = strchr(logmsg, '\\t');\n\t\t\tif (!msg)\n\t\t\t\tmsg = \"(none)\";\n\t\t\telse\n\t\t\t\tmsg++;\n\t\t\tm = xmalloc(strlen(msg) + 200);\n\t\t\tsprintf(m, \"(%s) %s\",\n\t\t\t\tshow_date(timestamp, tz, 1),\n\t\t\t\tmsg);\n\t\t\treflog_msg[i] = m;\n\t\t\tfree(logmsg);\n\t\t\tsprintf(nth_desc, \"%s@{%d}\", *av, base+i);\n\t\t\tappend_ref(nth_desc, sha1, 1);\n\t\t}\n\t}\n\telse if (all_heads + all_remotes)\n\t\tsnarf_refs(all_heads, all_remotes);\n\telse {\n\t\twhile (0 < ac) {\n\t\t\tappend_one_rev(*av);\n\t\t\tac--; av++;\n\t\t}\n\t}\n\n\thead_p = resolve_ref_unsafe(\"HEAD\", head_sha1, 1, NULL);\n\tif (head_p) {\n\t\thead_len = strlen(head_p);\n\t\tmemcpy(head, head_p, head_len + 1);\n\t}\n\telse {\n\t\thead_len = 0;\n\t\thead[0] = 0;\n\t}\n\n\tif (with_current_branch && head_p) {\n\t\tint has_head = 0;\n\t\tfor (i = 0; !has_head && i < ref_name_cnt; i++) {\n\t\t\t/* We are only interested in adding the branch\n\t\t\t * HEAD points at.\n\t\t\t */\n\t\t\tif (rev_is_head(head,\n\t\t\t\t\thead_len,\n\t\t\t\t\tref_name[i],\n\t\t\t\t\thead_sha1, NULL))\n\t\t\t\thas_head++;\n\t\t}\n\t\tif (!has_head) {\n\t\t\tint offset = !prefixcmp(head, \"refs/heads/\") ? 11 : 0;\n\t\t\tappend_one_rev(head + offset);\n\t\t}\n\t}\n\n\tif (!ref_name_cnt) {\n\t\tfprintf(stderr, \"No revs to be shown.\\n\");\n\t\texit(0);\n\t}\n\n\tfor (num_rev = 0; ref_name[num_rev]; num_rev++) {\n\t\tunsigned char revkey[20];\n\t\tunsigned int flag = 1u << (num_rev + REV_SHIFT);\n\n\t\tif (MAX_REVS <= num_rev)\n\t\t\tdie(\"cannot handle more than %d revs.\", MAX_REVS);\n\t\tif (get_sha1(ref_name[num_rev], revkey))\n\t\t\tdie(\"'%s' is not a valid ref.\", ref_name[num_rev]);\n\t\tcommit = lookup_commit_reference(revkey);\n\t\tif (!commit)\n\t\t\tdie(\"cannot find commit %s (%s)\",\n\t\t\t    ref_name[num_rev], revkey);\n\t\tparse_commit(commit);\n\t\tmark_seen(commit, &seen);\n\n\t\t/* rev#0 uses bit REV_SHIFT, rev#1 uses bit REV_SHIFT+1,\n\t\t * and so on.  REV_SHIFT bits from bit 0 are used for\n\t\t * internal bookkeeping.\n\t\t */\n\t\tcommit->object.flags |= flag;\n\t\tif (commit->object.flags == flag)\n\t\t\tcommit_list_insert_by_date(commit, &list);\n\t\trev[num_rev] = commit;\n\t}\n\tfor (i = 0; i < num_rev; i++)\n\t\trev_mask[i] = rev[i]->object.flags;\n\n\tif (0 <= extra)\n\t\tjoin_revs(&list, &seen, num_rev, extra);\n\n\tcommit_list_sort_by_date(&seen);\n\n\tif (merge_base)\n\t\treturn show_merge_base(seen, num_rev);\n\n\tif (independent)\n\t\treturn show_independent(rev, num_rev, ref_name, rev_mask);\n\n\t/* Show list; --more=-1 means list-only */\n\tif (1 < num_rev || extra < 0) {\n\t\tfor (i = 0; i < num_rev; i++) {\n\t\t\tint j;\n\t\t\tint is_head = rev_is_head(head,\n\t\t\t\t\t\t  head_len,\n\t\t\t\t\t\t  ref_name[i],\n\t\t\t\t\t\t  head_sha1,\n\t\t\t\t\t\t  rev[i]->object.sha1);\n\t\t\tif (extra < 0)\n\t\t\t\tprintf(\"%c [%s] \",\n\t\t\t\t       is_head ? '*' : ' ', ref_name[i]);\n\t\t\telse {\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tputchar(' ');\n\t\t\t\tprintf(\"%s%c%s [%s] \",\n\t\t\t\t       get_color_code(i),\n\t\t\t\t       is_head ? '*' : '!',\n\t\t\t\t       get_color_reset_code(), ref_name[i]);\n\t\t\t}\n\n\t\t\tif (!reflog) {\n\t\t\t\t/* header lines never need name */\n\t\t\t\tshow_one_commit(rev[i], 1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tputs(reflog_msg[i]);\n\n\t\t\tif (is_head)\n\t\t\t\thead_at = i;\n\t\t}\n\t\tif (0 <= extra) {\n\t\t\tfor (i = 0; i < num_rev; i++)\n\t\t\t\tputchar('-');\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\tif (extra < 0)\n\t\texit(0);\n\n\t/* Sort topologically */\n\tsort_in_topological_order(&seen, sort_order);\n\n\t/* Give names to commits */\n\tif (!sha1_name && !no_name)\n\t\tname_commits(seen, rev, ref_name, num_rev);\n\n\tall_mask = ((1u << (REV_SHIFT + num_rev)) - 1);\n\tall_revs = all_mask & ~((1u << REV_SHIFT) - 1);\n\n\twhile (seen) {\n\t\tstruct commit *commit = pop_one_commit(&seen);\n\t\tint this_flag = commit->object.flags;\n\t\tint is_merge_point = ((this_flag & all_revs) == all_revs);\n\n\t\tshown_merge_point |= is_merge_point;\n\n\t\tif (1 < num_rev) {\n\t\t\tint is_merge = !!(commit->parents &&\n\t\t\t\t\t  commit->parents->next);\n\t\t\tif (topics &&\n\t\t\t    !is_merge_point &&\n\t\t\t    (this_flag & (1u << REV_SHIFT)))\n\t\t\t\tcontinue;\n\t\t\tif (dense && is_merge &&\n\t\t\t    omit_in_dense(commit, rev, num_rev))\n\t\t\t\tcontinue;\n\t\t\tfor (i = 0; i < num_rev; i++) {\n\t\t\t\tint mark;\n\t\t\t\tif (!(this_flag & (1u << (i + REV_SHIFT))))\n\t\t\t\t\tmark = ' ';\n\t\t\t\telse if (is_merge)\n\t\t\t\t\tmark = '-';\n\t\t\t\telse if (i == head_at)\n\t\t\t\t\tmark = '*';\n\t\t\t\telse\n\t\t\t\t\tmark = '+';\n\t\t\t\tprintf(\"%s%c%s\",\n\t\t\t\t       get_color_code(i),\n\t\t\t\t       mark, get_color_reset_code());\n\t\t\t}\n\t\t\tputchar(' ');\n\t\t}\n\t\tshow_one_commit(commit, no_name);\n\n\t\tif (shown_merge_point && --extra < 0)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "001f29ca1b9ef8bfe2a06cda4d98c704584812fe",
  "sha1_ok": true,
  "size": 23384
}
