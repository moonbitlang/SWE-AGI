{
  "content": {
    "base64": "I2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAiY2FjaGUuaCIKI2luY2x1ZGUgImNvbmZpZy5oIgojaW5jbHVkZSAiaGV4LmgiCiNpbmNsdWRlICJwa3QtbGluZS5oIgojaW5jbHVkZSAicXVvdGUuaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJyZW1vdGUuaCIKI2luY2x1ZGUgImNvbm5lY3QuaCIKI2luY2x1ZGUgInVybC5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgIm9pZC1hcnJheS5oIgojaW5jbHVkZSAidHJhbnNwb3J0LmgiCiNpbmNsdWRlICJzdHJidWYuaCIKI2luY2x1ZGUgInZlcnNpb24uaCIKI2luY2x1ZGUgInByb3RvY29sLmgiCiNpbmNsdWRlICJhbGlhcy5oIgojaW5jbHVkZSAiYnVuZGxlLXVyaS5oIgoKc3RhdGljIGNoYXIgKnNlcnZlcl9jYXBhYmlsaXRpZXNfdjE7CnN0YXRpYyBzdHJ1Y3Qgc3RydmVjIHNlcnZlcl9jYXBhYmlsaXRpZXNfdjIgPSBTVFJWRUNfSU5JVDsKc3RhdGljIGNvbnN0IGNoYXIgKm5leHRfc2VydmVyX2ZlYXR1cmVfdmFsdWUoY29uc3QgY2hhciAqZmVhdHVyZSwgaW50ICpsZW4sIGludCAqb2Zmc2V0KTsKCnN0YXRpYyBpbnQgY2hlY2tfcmVmKGNvbnN0IGNoYXIgKm5hbWUsIHVuc2lnbmVkIGludCBmbGFncykKewoJaWYgKCFmbGFncykKCQlyZXR1cm4gMTsKCglpZiAoIXNraXBfcHJlZml4KG5hbWUsICJyZWZzLyIsICZuYW1lKSkKCQlyZXR1cm4gMDsKCgkvKiBSRUZfTk9STUFMIG1lYW5zIHRoYXQgd2UgZG9uJ3Qgd2FudCB0aGUgbWFnaWMgZmFrZSB0YWcgcmVmcyAqLwoJaWYgKChmbGFncyAmIFJFRl9OT1JNQUwpICYmIGNoZWNrX3JlZm5hbWVfZm9ybWF0KG5hbWUsCgkJCQkJCQkgUkVGTkFNRV9BTExPV19PTkVMRVZFTCkpCgkJcmV0dXJuIDA7CgoJLyogUkVGX0hFQURTIG1lYW5zIHRoYXQgd2Ugd2FudCByZWd1bGFyIGJyYW5jaCBoZWFkcyAqLwoJaWYgKChmbGFncyAmIFJFRl9IRUFEUykgJiYgc3RhcnRzX3dpdGgobmFtZSwgImhlYWRzLyIpKQoJCXJldHVybiAxOwoKCS8qIFJFRl9UQUdTIG1lYW5zIHRoYXQgd2Ugd2FudCB0YWdzICovCglpZiAoKGZsYWdzICYgUkVGX1RBR1MpICYmIHN0YXJ0c193aXRoKG5hbWUsICJ0YWdzLyIpKQoJCXJldHVybiAxOwoKCS8qIEFsbCB0eXBlIGJpdHMgY2xlYXIgbWVhbnMgdGhhdCB3ZSBhcmUgb2sgd2l0aCBhbnl0aGluZyAqLwoJcmV0dXJuICEoZmxhZ3MgJiB+UkVGX05PUk1BTCk7Cn0KCmludCBjaGVja19yZWZfdHlwZShjb25zdCBzdHJ1Y3QgcmVmICpyZWYsIGludCBmbGFncykKewoJcmV0dXJuIGNoZWNrX3JlZihyZWYtPm5hbWUsIGZsYWdzKTsKfQoKc3RhdGljIE5PUkVUVVJOIHZvaWQgZGllX2luaXRpYWxfY29udGFjdChpbnQgdW5leHBlY3RlZCkKewoJLyoKCSAqIEEgaGFuZy11cCBhZnRlciBzZWVpbmcgc29tZSByZXNwb25zZSBmcm9tIHRoZSBvdGhlciBlbmQKCSAqIG1lYW5zIHRoYXQgaXQgaXMgdW5leHBlY3RlZCwgYXMgd2Uga25vdyB0aGUgb3RoZXIgZW5kIGlzCgkgKiB3aWxsaW5nIHRvIHRhbGsgdG8gdXMuICBBIGhhbmctdXAgYmVmb3JlIHNlZWluZyBhbnkKCSAqIHJlc3BvbnNlIGRvZXMgbm90IG5lY2Vzc2FyaWx5IG1lYW4gYW4gQUNMIHByb2JsZW0sIHRob3VnaC4KCSAqLwoJaWYgKHVuZXhwZWN0ZWQpCgkJZGllKF8oInRoZSByZW1vdGUgZW5kIGh1bmcgdXAgdXBvbiBpbml0aWFsIGNvbnRhY3QiKSk7CgllbHNlCgkJZGllKF8oIkNvdWxkIG5vdCByZWFkIGZyb20gcmVtb3RlIHJlcG9zaXRvcnkuXG5cbiIKCQkgICAgICAiUGxlYXNlIG1ha2Ugc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBhY2Nlc3MgcmlnaHRzXG4iCgkJICAgICAgImFuZCB0aGUgcmVwb3NpdG9yeSBleGlzdHMuIikpOwp9CgovKiBDaGVja3MgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyB0aGUgY2FwYWJpbGl0eSAnYycgKi8KaW50IHNlcnZlcl9zdXBwb3J0c192Mihjb25zdCBjaGFyICpjKQp7CglpbnQgaTsKCglmb3IgKGkgPSAwOyBpIDwgc2VydmVyX2NhcGFiaWxpdGllc192Mi5ucjsgaSsrKSB7CgkJY29uc3QgY2hhciAqb3V0OwoJCWlmIChza2lwX3ByZWZpeChzZXJ2ZXJfY2FwYWJpbGl0aWVzX3YyLnZbaV0sIGMsICZvdXQpICYmCgkJICAgICghKm91dCB8fCAqb3V0ID09ICc9JykpCgkJCXJldHVybiAxOwoJfQoJcmV0dXJuIDA7Cn0KCnZvaWQgZW5zdXJlX3NlcnZlcl9zdXBwb3J0c192Mihjb25zdCBjaGFyICpjKQp7CglpZiAoIXNlcnZlcl9zdXBwb3J0c192MihjKSkKCQlkaWUoXygic2VydmVyIGRvZXNuJ3Qgc3VwcG9ydCAnJXMnIiksIGMpOwp9CgppbnQgc2VydmVyX2ZlYXR1cmVfdjIoY29uc3QgY2hhciAqYywgY29uc3QgY2hhciAqKnYpCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBzZXJ2ZXJfY2FwYWJpbGl0aWVzX3YyLm5yOyBpKyspIHsKCQljb25zdCBjaGFyICpvdXQ7CgkJaWYgKHNraXBfcHJlZml4KHNlcnZlcl9jYXBhYmlsaXRpZXNfdjIudltpXSwgYywgJm91dCkgJiYKCQkgICAgKCpvdXQgPT0gJz0nKSkgewoJCQkqdiA9IG91dCArIDE7CgkJCXJldHVybiAxOwoJCX0KCX0KCXJldHVybiAwOwp9CgppbnQgc2VydmVyX3N1cHBvcnRzX2ZlYXR1cmUoY29uc3QgY2hhciAqYywgY29uc3QgY2hhciAqZmVhdHVyZSwKCQkJICAgIGludCBkaWVfb25fZXJyb3IpCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBzZXJ2ZXJfY2FwYWJpbGl0aWVzX3YyLm5yOyBpKyspIHsKCQljb25zdCBjaGFyICpvdXQ7CgkJaWYgKHNraXBfcHJlZml4KHNlcnZlcl9jYXBhYmlsaXRpZXNfdjIudltpXSwgYywgJm91dCkgJiYKCQkgICAgKCEqb3V0IHx8ICoob3V0KyspID09ICc9JykpIHsKCQkJaWYgKHBhcnNlX2ZlYXR1cmVfcmVxdWVzdChvdXQsIGZlYXR1cmUpKQoJCQkJcmV0dXJuIDE7CgkJCWVsc2UKCQkJCWJyZWFrOwoJCX0KCX0KCglpZiAoZGllX29uX2Vycm9yKQoJCWRpZShfKCJzZXJ2ZXIgZG9lc24ndCBzdXBwb3J0IGZlYXR1cmUgJyVzJyIpLCBmZWF0dXJlKTsKCglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgcHJvY2Vzc19jYXBhYmlsaXRpZXNfdjIoc3RydWN0IHBhY2tldF9yZWFkZXIgKnJlYWRlcikKewoJd2hpbGUgKHBhY2tldF9yZWFkZXJfcmVhZChyZWFkZXIpID09IFBBQ0tFVF9SRUFEX05PUk1BTCkKCQlzdHJ2ZWNfcHVzaCgmc2VydmVyX2NhcGFiaWxpdGllc192MiwgcmVhZGVyLT5saW5lKTsKCglpZiAocmVhZGVyLT5zdGF0dXMgIT0gUEFDS0VUX1JFQURfRkxVU0gpCgkJZGllKF8oImV4cGVjdGVkIGZsdXNoIGFmdGVyIGNhcGFiaWxpdGllcyIpKTsKfQoKZW51bSBwcm90b2NvbF92ZXJzaW9uIGRpc2NvdmVyX3ZlcnNpb24oc3RydWN0IHBhY2tldF9yZWFkZXIgKnJlYWRlcikKewoJZW51bSBwcm90b2NvbF92ZXJzaW9uIHZlcnNpb24gPSBwcm90b2NvbF91bmtub3duX3ZlcnNpb247CgoJLyoKCSAqIFBlZWsgdGhlIGZpcnN0IGxpbmUgb2YgdGhlIHNlcnZlcidzIHJlc3BvbnNlIHRvCgkgKiBkZXRlcm1pbmUgdGhlIHByb3RvY29sIHZlcnNpb24gdGhlIHNlcnZlciBpcyBzcGVha2luZy4KCSAqLwoJc3dpdGNoIChwYWNrZXRfcmVhZGVyX3BlZWsocmVhZGVyKSkgewoJY2FzZSBQQUNLRVRfUkVBRF9FT0Y6CgkJZGllX2luaXRpYWxfY29udGFjdCgwKTsKCWNhc2UgUEFDS0VUX1JFQURfRkxVU0g6CgljYXNlIFBBQ0tFVF9SRUFEX0RFTElNOgoJY2FzZSBQQUNLRVRfUkVBRF9SRVNQT05TRV9FTkQ6CgkJdmVyc2lvbiA9IHByb3RvY29sX3YwOwoJCWJyZWFrOwoJY2FzZSBQQUNLRVRfUkVBRF9OT1JNQUw6CgkJdmVyc2lvbiA9IGRldGVybWluZV9wcm90b2NvbF92ZXJzaW9uX2NsaWVudChyZWFkZXItPmxpbmUpOwoJCWJyZWFrOwoJfQoKCXN3aXRjaCAodmVyc2lvbikgewoJY2FzZSBwcm90b2NvbF92MjoKCQlwcm9jZXNzX2NhcGFiaWxpdGllc192MihyZWFkZXIpOwoJCWJyZWFrOwoJY2FzZSBwcm90b2NvbF92MToKCQkvKiBSZWFkIHRoZSBwZWVrZWQgdmVyc2lvbiBsaW5lICovCgkJcGFja2V0X3JlYWRlcl9yZWFkKHJlYWRlcik7CgkJYnJlYWs7CgljYXNlIHByb3RvY29sX3YwOgoJCWJyZWFrOwoJY2FzZSBwcm90b2NvbF91bmtub3duX3ZlcnNpb246CgkJQlVHKCJ1bmtub3duIHByb3RvY29sIHZlcnNpb24iKTsKCX0KCgl0cmFjZTJfZGF0YV9pbnRtYXgoInRyYW5zZmVyIiwgTlVMTCwgIm5lZ290aWF0ZWQtdmVyc2lvbiIsIHZlcnNpb24pOwoKCXJldHVybiB2ZXJzaW9uOwp9CgpzdGF0aWMgdm9pZCBwYXJzZV9vbmVfc3ltcmVmX2luZm8oc3RydWN0IHN0cmluZ19saXN0ICpzeW1yZWYsIGNvbnN0IGNoYXIgKnZhbCwgaW50IGxlbikKewoJY2hhciAqc3ltLCAqdGFyZ2V0OwoJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW07CgoJaWYgKCFsZW4pCgkJcmV0dXJuOyAvKiBqdXN0ICJzeW1yZWYiICovCgkvKiBlLmcuICJzeW1yZWY9SEVBRDpyZWZzL2hlYWRzL21hc3RlciIgKi8KCXN5bSA9IHhtZW1kdXB6KHZhbCwgbGVuKTsKCXRhcmdldCA9IHN0cmNocihzeW0sICc6Jyk7CglpZiAoIXRhcmdldCkKCQkvKiBqdXN0ICJzeW1yZWY9c29tZXRoaW5nIiAqLwoJCWdvdG8gcmVqZWN0OwoJKih0YXJnZXQrKykgPSAnXDAnOwoJaWYgKGNoZWNrX3JlZm5hbWVfZm9ybWF0KHN5bSwgUkVGTkFNRV9BTExPV19PTkVMRVZFTCkgfHwKCSAgICBjaGVja19yZWZuYW1lX2Zvcm1hdCh0YXJnZXQsIFJFRk5BTUVfQUxMT1dfT05FTEVWRUwpKQoJCS8qICJzeW1yZWY9Ym9ndXM6cGFpciAqLwoJCWdvdG8gcmVqZWN0OwoJaXRlbSA9IHN0cmluZ19saXN0X2FwcGVuZF9ub2R1cChzeW1yZWYsIHN5bSk7CglpdGVtLT51dGlsID0gdGFyZ2V0OwoJcmV0dXJuOwpyZWplY3Q6CglmcmVlKHN5bSk7CglyZXR1cm47Cn0KCnN0YXRpYyB2b2lkIGFubm90YXRlX3JlZnNfd2l0aF9zeW1yZWZfaW5mbyhzdHJ1Y3QgcmVmICpyZWYpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdCBzeW1yZWYgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCWludCBvZmZzZXQgPSAwOwoKCXdoaWxlICgxKSB7CgkJaW50IGxlbjsKCQljb25zdCBjaGFyICp2YWw7CgoJCXZhbCA9IG5leHRfc2VydmVyX2ZlYXR1cmVfdmFsdWUoInN5bXJlZiIsICZsZW4sICZvZmZzZXQpOwoJCWlmICghdmFsKQoJCQlicmVhazsKCQlwYXJzZV9vbmVfc3ltcmVmX2luZm8oJnN5bXJlZiwgdmFsLCBsZW4pOwoJfQoJc3RyaW5nX2xpc3Rfc29ydCgmc3ltcmVmKTsKCglmb3IgKDsgcmVmOyByZWYgPSByZWYtPm5leHQpIHsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbTsKCQlpdGVtID0gc3RyaW5nX2xpc3RfbG9va3VwKCZzeW1yZWYsIHJlZi0+bmFtZSk7CgkJaWYgKCFpdGVtKQoJCQljb250aW51ZTsKCQlyZWYtPnN5bXJlZiA9IHhzdHJkdXAoKGNoYXIgKilpdGVtLT51dGlsKTsKCX0KCXN0cmluZ19saXN0X2NsZWFyKCZzeW1yZWYsIDApOwp9CgpzdGF0aWMgdm9pZCBwcm9jZXNzX2NhcGFiaWxpdGllcyhzdHJ1Y3QgcGFja2V0X3JlYWRlciAqcmVhZGVyLCBpbnQgKmxpbmVsZW4pCnsKCWNvbnN0IGNoYXIgKmZlYXRfdmFsOwoJaW50IGZlYXRfbGVuOwoJY29uc3QgY2hhciAqbGluZSA9IHJlYWRlci0+bGluZTsKCWludCBudWxfbG9jYXRpb24gPSBzdHJsZW4obGluZSk7CglpZiAobnVsX2xvY2F0aW9uID09ICpsaW5lbGVuKQoJCXJldHVybjsKCXNlcnZlcl9jYXBhYmlsaXRpZXNfdjEgPSB4c3RyZHVwKGxpbmUgKyBudWxfbG9jYXRpb24gKyAxKTsKCSpsaW5lbGVuID0gbnVsX2xvY2F0aW9uOwoKCWZlYXRfdmFsID0gc2VydmVyX2ZlYXR1cmVfdmFsdWUoIm9iamVjdC1mb3JtYXQiLCAmZmVhdF9sZW4pOwoJaWYgKGZlYXRfdmFsKSB7CgkJY2hhciAqaGFzaF9uYW1lID0geHN0cm5kdXAoZmVhdF92YWwsIGZlYXRfbGVuKTsKCQlpbnQgaGFzaF9hbGdvID0gaGFzaF9hbGdvX2J5X25hbWUoaGFzaF9uYW1lKTsKCQlpZiAoaGFzaF9hbGdvICE9IEdJVF9IQVNIX1VOS05PV04pCgkJCXJlYWRlci0+aGFzaF9hbGdvID0gJmhhc2hfYWxnb3NbaGFzaF9hbGdvXTsKCQlmcmVlKGhhc2hfbmFtZSk7Cgl9IGVsc2UgewoJCXJlYWRlci0+aGFzaF9hbGdvID0gJmhhc2hfYWxnb3NbR0lUX0hBU0hfU0hBMV07Cgl9Cn0KCnN0YXRpYyBpbnQgcHJvY2Vzc19kdW1teV9yZWYoY29uc3Qgc3RydWN0IHBhY2tldF9yZWFkZXIgKnJlYWRlcikKewoJY29uc3QgY2hhciAqbGluZSA9IHJlYWRlci0+bGluZTsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJY29uc3QgY2hhciAqbmFtZTsKCglpZiAocGFyc2Vfb2lkX2hleF9hbGdvcChsaW5lLCAmb2lkLCAmbmFtZSwgcmVhZGVyLT5oYXNoX2FsZ28pKQoJCXJldHVybiAwOwoJaWYgKCpuYW1lICE9ICcgJykKCQlyZXR1cm4gMDsKCW5hbWUrKzsKCglyZXR1cm4gb2lkZXEobnVsbF9vaWQoKSwgJm9pZCkgJiYgIXN0cmNtcChuYW1lLCAiY2FwYWJpbGl0aWVzXnt9Iik7Cn0KCnN0YXRpYyB2b2lkIGNoZWNrX25vX2NhcGFiaWxpdGllcyhjb25zdCBjaGFyICpsaW5lLCBpbnQgbGVuKQp7CglpZiAoc3RybGVuKGxpbmUpICE9IGxlbikKCQl3YXJuaW5nKF8oImlnbm9yaW5nIGNhcGFiaWxpdGllcyBhZnRlciBmaXJzdCBsaW5lICclcyciKSwKCQkJbGluZSArIHN0cmxlbihsaW5lKSk7Cn0KCnN0YXRpYyBpbnQgcHJvY2Vzc19yZWYoY29uc3Qgc3RydWN0IHBhY2tldF9yZWFkZXIgKnJlYWRlciwgaW50IGxlbiwKCQkgICAgICAgc3RydWN0IHJlZiAqKipsaXN0LCB1bnNpZ25lZCBpbnQgZmxhZ3MsCgkJICAgICAgIHN0cnVjdCBvaWRfYXJyYXkgKmV4dHJhX2hhdmUpCnsKCWNvbnN0IGNoYXIgKmxpbmUgPSByZWFkZXItPmxpbmU7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9sZF9vaWQ7Cgljb25zdCBjaGFyICpuYW1lOwoKCWlmIChwYXJzZV9vaWRfaGV4X2FsZ29wKGxpbmUsICZvbGRfb2lkLCAmbmFtZSwgcmVhZGVyLT5oYXNoX2FsZ28pKQoJCXJldHVybiAwOwoJaWYgKCpuYW1lICE9ICcgJykKCQlyZXR1cm4gMDsKCW5hbWUrKzsKCglpZiAoZXh0cmFfaGF2ZSAmJiAhc3RyY21wKG5hbWUsICIuaGF2ZSIpKSB7CgkJb2lkX2FycmF5X2FwcGVuZChleHRyYV9oYXZlLCAmb2xkX29pZCk7Cgl9IGVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImNhcGFiaWxpdGllc157fSIpKSB7CgkJZGllKF8oInByb3RvY29sIGVycm9yOiB1bmV4cGVjdGVkIGNhcGFiaWxpdGllc157fSIpKTsKCX0gZWxzZSBpZiAoY2hlY2tfcmVmKG5hbWUsIGZsYWdzKSkgewoJCXN0cnVjdCByZWYgKnJlZiA9IGFsbG9jX3JlZihuYW1lKTsKCQlvaWRjcHkoJnJlZi0+b2xkX29pZCwgJm9sZF9vaWQpOwoJCSoqbGlzdCA9IHJlZjsKCQkqbGlzdCA9ICZyZWYtPm5leHQ7Cgl9CgljaGVja19ub19jYXBhYmlsaXRpZXMobGluZSwgbGVuKTsKCXJldHVybiAxOwp9CgpzdGF0aWMgaW50IHByb2Nlc3Nfc2hhbGxvdyhjb25zdCBzdHJ1Y3QgcGFja2V0X3JlYWRlciAqcmVhZGVyLCBpbnQgbGVuLAoJCQkgICBzdHJ1Y3Qgb2lkX2FycmF5ICpzaGFsbG93X3BvaW50cykKewoJY29uc3QgY2hhciAqbGluZSA9IHJlYWRlci0+bGluZTsKCWNvbnN0IGNoYXIgKmFyZzsKCXN0cnVjdCBvYmplY3RfaWQgb2xkX29pZDsKCglpZiAoIXNraXBfcHJlZml4KGxpbmUsICJzaGFsbG93ICIsICZhcmcpKQoJCXJldHVybiAwOwoKCWlmIChnZXRfb2lkX2hleF9hbGdvcChhcmcsICZvbGRfb2lkLCByZWFkZXItPmhhc2hfYWxnbykpCgkJZGllKF8oInByb3RvY29sIGVycm9yOiBleHBlY3RlZCBzaGFsbG93IHNoYS0xLCBnb3QgJyVzJyIpLCBhcmcpOwoJaWYgKCFzaGFsbG93X3BvaW50cykKCQlkaWUoXygicmVwb3NpdG9yeSBvbiB0aGUgb3RoZXIgZW5kIGNhbm5vdCBiZSBzaGFsbG93IikpOwoJb2lkX2FycmF5X2FwcGVuZChzaGFsbG93X3BvaW50cywgJm9sZF9vaWQpOwoJY2hlY2tfbm9fY2FwYWJpbGl0aWVzKGxpbmUsIGxlbik7CglyZXR1cm4gMTsKfQoKZW51bSBnZXRfcmVtb3RlX2hlYWRzX3N0YXRlIHsKCUVYUEVDVElOR19GSVJTVF9SRUYgPSAwLAoJRVhQRUNUSU5HX1JFRiwKCUVYUEVDVElOR19TSEFMTE9XLAoJRVhQRUNUSU5HX0RPTkUsCn07CgovKgogKiBSZWFkIGFsbCB0aGUgcmVmcyBmcm9tIHRoZSBvdGhlciBlbmQKICovCnN0cnVjdCByZWYgKipnZXRfcmVtb3RlX2hlYWRzKHN0cnVjdCBwYWNrZXRfcmVhZGVyICpyZWFkZXIsCgkJCSAgICAgIHN0cnVjdCByZWYgKipsaXN0LCB1bnNpZ25lZCBpbnQgZmxhZ3MsCgkJCSAgICAgIHN0cnVjdCBvaWRfYXJyYXkgKmV4dHJhX2hhdmUsCgkJCSAgICAgIHN0cnVjdCBvaWRfYXJyYXkgKnNoYWxsb3dfcG9pbnRzKQp7CglzdHJ1Y3QgcmVmICoqb3JpZ19saXN0ID0gbGlzdDsKCWludCBsZW4gPSAwOwoJZW51bSBnZXRfcmVtb3RlX2hlYWRzX3N0YXRlIHN0YXRlID0gRVhQRUNUSU5HX0ZJUlNUX1JFRjsKCgkqbGlzdCA9IE5VTEw7CgoJd2hpbGUgKHN0YXRlICE9IEVYUEVDVElOR19ET05FKSB7CgkJc3dpdGNoIChwYWNrZXRfcmVhZGVyX3JlYWQocmVhZGVyKSkgewoJCWNhc2UgUEFDS0VUX1JFQURfRU9GOgoJCQlkaWVfaW5pdGlhbF9jb250YWN0KDEpOwoJCWNhc2UgUEFDS0VUX1JFQURfTk9STUFMOgoJCQlsZW4gPSByZWFkZXItPnBrdGxlbjsKCQkJYnJlYWs7CgkJY2FzZSBQQUNLRVRfUkVBRF9GTFVTSDoKCQkJc3RhdGUgPSBFWFBFQ1RJTkdfRE9ORTsKCQkJYnJlYWs7CgkJY2FzZSBQQUNLRVRfUkVBRF9ERUxJTToKCQljYXNlIFBBQ0tFVF9SRUFEX1JFU1BPTlNFX0VORDoKCQkJZGllKF8oImludmFsaWQgcGFja2V0IikpOwoJCX0KCgkJc3dpdGNoIChzdGF0ZSkgewoJCWNhc2UgRVhQRUNUSU5HX0ZJUlNUX1JFRjoKCQkJcHJvY2Vzc19jYXBhYmlsaXRpZXMocmVhZGVyLCAmbGVuKTsKCQkJaWYgKHByb2Nlc3NfZHVtbXlfcmVmKHJlYWRlcikpIHsKCQkJCXN0YXRlID0gRVhQRUNUSU5HX1NIQUxMT1c7CgkJCQlicmVhazsKCQkJfQoJCQlzdGF0ZSA9IEVYUEVDVElOR19SRUY7CgkJCS8qIGZhbGx0aHJvdWdoICovCgkJY2FzZSBFWFBFQ1RJTkdfUkVGOgoJCQlpZiAocHJvY2Vzc19yZWYocmVhZGVyLCBsZW4sICZsaXN0LCBmbGFncywgZXh0cmFfaGF2ZSkpCgkJCQlicmVhazsKCQkJc3RhdGUgPSBFWFBFQ1RJTkdfU0hBTExPVzsKCQkJLyogZmFsbHRocm91Z2ggKi8KCQljYXNlIEVYUEVDVElOR19TSEFMTE9XOgoJCQlpZiAocHJvY2Vzc19zaGFsbG93KHJlYWRlciwgbGVuLCBzaGFsbG93X3BvaW50cykpCgkJCQlicmVhazsKCQkJZGllKF8oInByb3RvY29sIGVycm9yOiB1bmV4cGVjdGVkICclcyciKSwgcmVhZGVyLT5saW5lKTsKCQljYXNlIEVYUEVDVElOR19ET05FOgoJCQlicmVhazsKCQl9Cgl9CgoJYW5ub3RhdGVfcmVmc193aXRoX3N5bXJlZl9pbmZvKCpvcmlnX2xpc3QpOwoKCXJldHVybiBsaXN0Owp9CgovKiBSZXR1cm5zIDEgd2hlbiBhIHZhbGlkIHJlZiBoYXMgYmVlbiBhZGRlZCB0byBgbGlzdGAsIDAgb3RoZXJ3aXNlICovCnN0YXRpYyBpbnQgcHJvY2Vzc19yZWZfdjIoc3RydWN0IHBhY2tldF9yZWFkZXIgKnJlYWRlciwgc3RydWN0IHJlZiAqKipsaXN0LAoJCQkgIGNvbnN0IGNoYXIgKip1bmJvcm5faGVhZF90YXJnZXQpCnsKCWludCByZXQgPSAxOwoJaW50IGkgPSAwOwoJc3RydWN0IG9iamVjdF9pZCBvbGRfb2lkOwoJc3RydWN0IHJlZiAqcmVmOwoJc3RydWN0IHN0cmluZ19saXN0IGxpbmVfc2VjdGlvbnMgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCWNvbnN0IGNoYXIgKmVuZDsKCWNvbnN0IGNoYXIgKmxpbmUgPSByZWFkZXItPmxpbmU7CgoJLyoKCSAqIFJlZiBsaW5lcyBoYXZlIGEgbnVtYmVyIG9mIGZpZWxkcyB3aGljaCBhcmUgc3BhY2UgZGVsaW1pbmF0ZWQuICBUaGUKCSAqIGZpcnN0IGZpZWxkIGlzIHRoZSBPSUQgb2YgdGhlIHJlZi4gIFRoZSBzZWNvbmQgZmllbGQgaXMgdGhlIHJlZgoJICogbmFtZS4gIFN1YnNlcXVlbnQgZmllbGRzIChzeW1yZWYtdGFyZ2V0IGFuZCBwZWVsZWQpIGFyZSBvcHRpb25hbCBhbmQKCSAqIGRvbid0IGhhdmUgYSBwYXJ0aWN1bGFyIG9yZGVyLgoJICovCglpZiAoc3RyaW5nX2xpc3Rfc3BsaXQoJmxpbmVfc2VjdGlvbnMsIGxpbmUsICcgJywgLTEpIDwgMikgewoJCXJldCA9IDA7CgkJZ290byBvdXQ7Cgl9CgoJaWYgKCFzdHJjbXAoInVuYm9ybiIsIGxpbmVfc2VjdGlvbnMuaXRlbXNbaV0uc3RyaW5nKSkgewoJCWkrKzsKCQlpZiAodW5ib3JuX2hlYWRfdGFyZ2V0ICYmCgkJICAgICFzdHJjbXAoIkhFQUQiLCBsaW5lX3NlY3Rpb25zLml0ZW1zW2krK10uc3RyaW5nKSkgewoJCQkvKgoJCQkgKiBMb29rIGZvciB0aGUgc3ltcmVmIHRhcmdldCAoaWYgYW55KS4gSWYgZm91bmQsCgkJCSAqIHJldHVybiBpdCB0byB0aGUgY2FsbGVyLgoJCQkgKi8KCQkJZm9yICg7IGkgPCBsaW5lX3NlY3Rpb25zLm5yOyBpKyspIHsKCQkJCWNvbnN0IGNoYXIgKmFyZyA9IGxpbmVfc2VjdGlvbnMuaXRlbXNbaV0uc3RyaW5nOwoKCQkJCWlmIChza2lwX3ByZWZpeChhcmcsICJzeW1yZWYtdGFyZ2V0OiIsICZhcmcpKSB7CgkJCQkJKnVuYm9ybl9oZWFkX3RhcmdldCA9IHhzdHJkdXAoYXJnKTsKCQkJCQlicmVhazsKCQkJCX0KCQkJfQoJCX0KCQlnb3RvIG91dDsKCX0KCWlmIChwYXJzZV9vaWRfaGV4X2FsZ29wKGxpbmVfc2VjdGlvbnMuaXRlbXNbaSsrXS5zdHJpbmcsICZvbGRfb2lkLCAmZW5kLCByZWFkZXItPmhhc2hfYWxnbykgfHwKCSAgICAqZW5kKSB7CgkJcmV0ID0gMDsKCQlnb3RvIG91dDsKCX0KCglyZWYgPSBhbGxvY19yZWYobGluZV9zZWN0aW9ucy5pdGVtc1tpKytdLnN0cmluZyk7CgoJbWVtY3B5KHJlZi0+b2xkX29pZC5oYXNoLCBvbGRfb2lkLmhhc2gsIHJlYWRlci0+aGFzaF9hbGdvLT5yYXdzeik7CgkqKmxpc3QgPSByZWY7CgkqbGlzdCA9ICZyZWYtPm5leHQ7CgoJZm9yICg7IGkgPCBsaW5lX3NlY3Rpb25zLm5yOyBpKyspIHsKCQljb25zdCBjaGFyICphcmcgPSBsaW5lX3NlY3Rpb25zLml0ZW1zW2ldLnN0cmluZzsKCQlpZiAoc2tpcF9wcmVmaXgoYXJnLCAic3ltcmVmLXRhcmdldDoiLCAmYXJnKSkKCQkJcmVmLT5zeW1yZWYgPSB4c3RyZHVwKGFyZyk7CgoJCWlmIChza2lwX3ByZWZpeChhcmcsICJwZWVsZWQ6IiwgJmFyZykpIHsKCQkJc3RydWN0IG9iamVjdF9pZCBwZWVsZWRfb2lkOwoJCQljaGFyICpwZWVsZWRfbmFtZTsKCQkJc3RydWN0IHJlZiAqcGVlbGVkOwoJCQlpZiAocGFyc2Vfb2lkX2hleF9hbGdvcChhcmcsICZwZWVsZWRfb2lkLCAmZW5kLAoJCQkJCQlyZWFkZXItPmhhc2hfYWxnbykgfHwgKmVuZCkgewoJCQkJcmV0ID0gMDsKCQkJCWdvdG8gb3V0OwoJCQl9CgoJCQlwZWVsZWRfbmFtZSA9IHhzdHJmbXQoIiVzXnt9IiwgcmVmLT5uYW1lKTsKCQkJcGVlbGVkID0gYWxsb2NfcmVmKHBlZWxlZF9uYW1lKTsKCgkJCW1lbWNweShwZWVsZWQtPm9sZF9vaWQuaGFzaCwgcGVlbGVkX29pZC5oYXNoLAoJCQkgICAgICAgcmVhZGVyLT5oYXNoX2FsZ28tPnJhd3N6KTsKCQkJKipsaXN0ID0gcGVlbGVkOwoJCQkqbGlzdCA9ICZwZWVsZWQtPm5leHQ7CgoJCQlmcmVlKHBlZWxlZF9uYW1lKTsKCQl9Cgl9CgpvdXQ6CglzdHJpbmdfbGlzdF9jbGVhcigmbGluZV9zZWN0aW9ucywgMCk7CglyZXR1cm4gcmV0Owp9Cgp2b2lkIGNoZWNrX3N0YXRlbGVzc19kZWxpbWl0ZXIoaW50IHN0YXRlbGVzc19ycGMsCgkJCSAgICAgIHN0cnVjdCBwYWNrZXRfcmVhZGVyICpyZWFkZXIsCgkJCSAgICAgIGNvbnN0IGNoYXIgKmVycm9yKQp7CglpZiAoIXN0YXRlbGVzc19ycGMpCgkJcmV0dXJuOyAvKiBub3QgaW4gc3RhdGVsZXNzIG1vZGUsIG5vIGRlbGltaXRlciBleHBlY3RlZCAqLwoJaWYgKHBhY2tldF9yZWFkZXJfcmVhZChyZWFkZXIpICE9IFBBQ0tFVF9SRUFEX1JFU1BPTlNFX0VORCkKCQlkaWUoIiVzIiwgZXJyb3IpOwp9CgpzdGF0aWMgdm9pZCBzZW5kX2NhcGFiaWxpdGllcyhpbnQgZmRfb3V0LCBzdHJ1Y3QgcGFja2V0X3JlYWRlciAqcmVhZGVyKQp7Cgljb25zdCBjaGFyICpoYXNoX25hbWU7CgoJaWYgKHNlcnZlcl9zdXBwb3J0c192MigiYWdlbnQiKSkKCQlwYWNrZXRfd3JpdGVfZm10KGZkX291dCwgImFnZW50PSVzIiwgZ2l0X3VzZXJfYWdlbnRfc2FuaXRpemVkKCkpOwoKCWlmIChzZXJ2ZXJfZmVhdHVyZV92Migib2JqZWN0LWZvcm1hdCIsICZoYXNoX25hbWUpKSB7CgkJaW50IGhhc2hfYWxnbyA9IGhhc2hfYWxnb19ieV9uYW1lKGhhc2hfbmFtZSk7CgkJaWYgKGhhc2hfYWxnbyA9PSBHSVRfSEFTSF9VTktOT1dOKQoJCQlkaWUoXygidW5rbm93biBvYmplY3QgZm9ybWF0ICclcycgc3BlY2lmaWVkIGJ5IHNlcnZlciIpLCBoYXNoX25hbWUpOwoJCXJlYWRlci0+aGFzaF9hbGdvID0gJmhhc2hfYWxnb3NbaGFzaF9hbGdvXTsKCQlwYWNrZXRfd3JpdGVfZm10KGZkX291dCwgIm9iamVjdC1mb3JtYXQ9JXMiLCByZWFkZXItPmhhc2hfYWxnby0+bmFtZSk7Cgl9IGVsc2UgewoJCXJlYWRlci0+aGFzaF9hbGdvID0gJmhhc2hfYWxnb3NbR0lUX0hBU0hfU0hBMV07Cgl9Cn0KCmludCBnZXRfcmVtb3RlX2J1bmRsZV91cmkoaW50IGZkX291dCwgc3RydWN0IHBhY2tldF9yZWFkZXIgKnJlYWRlciwKCQkJICBzdHJ1Y3QgYnVuZGxlX2xpc3QgKmJ1bmRsZXMsIGludCBzdGF0ZWxlc3NfcnBjKQp7CglpbnQgbGluZV9uciA9IDE7CgoJLyogQXNzZXJ0IGJ1bmRsZS11cmkgc3VwcG9ydCAqLwoJZW5zdXJlX3NlcnZlcl9zdXBwb3J0c192MigiYnVuZGxlLXVyaSIpOwoKCS8qIChSZS0pc2VuZCBjYXBhYmlsaXRpZXMgKi8KCXNlbmRfY2FwYWJpbGl0aWVzKGZkX291dCwgcmVhZGVyKTsKCgkvKiBTZW5kIGNvbW1hbmQgKi8KCXBhY2tldF93cml0ZV9mbXQoZmRfb3V0LCAiY29tbWFuZD1idW5kbGUtdXJpXG4iKTsKCXBhY2tldF9kZWxpbShmZF9vdXQpOwoKCXBhY2tldF9mbHVzaChmZF9vdXQpOwoKCS8qIFByb2Nlc3MgcmVzcG9uc2UgZnJvbSBzZXJ2ZXIgKi8KCXdoaWxlIChwYWNrZXRfcmVhZGVyX3JlYWQocmVhZGVyKSA9PSBQQUNLRVRfUkVBRF9OT1JNQUwpIHsKCQljb25zdCBjaGFyICpsaW5lID0gcmVhZGVyLT5saW5lOwoJCWxpbmVfbnIrKzsKCgkJaWYgKCFidW5kbGVfdXJpX3BhcnNlX2xpbmUoYnVuZGxlcywgbGluZSkpCgkJCWNvbnRpbnVlOwoKCQlyZXR1cm4gZXJyb3IoXygiZXJyb3Igb24gYnVuZGxlLXVyaSByZXNwb25zZSBsaW5lICVkOiAlcyIpLAoJCQkgICAgIGxpbmVfbnIsIGxpbmUpOwoJfQoKCWlmIChyZWFkZXItPnN0YXR1cyAhPSBQQUNLRVRfUkVBRF9GTFVTSCkKCQlyZXR1cm4gZXJyb3IoXygiZXhwZWN0ZWQgZmx1c2ggYWZ0ZXIgYnVuZGxlLXVyaSBsaXN0aW5nIikpOwoKCS8qCgkgKiBNaWdodCBkaWUoKSwgYnV0IG9ic2N1cmUgZW5vdWdoIHRoYXQgdGhhdCdzIE9LLCBlLmcuIGluCgkgKiBzZXJ2ZS5jIHdlJ2xsIGNhbGwgQlVHKCkgb24gaXRzIGVxdWl2YWxlbnQgKHRoZQoJICogUEFDS0VUX1JFQURfUkVTUE9OU0VfRU5EIGNoZWNrKS4KCSAqLwoJY2hlY2tfc3RhdGVsZXNzX2RlbGltaXRlcihzdGF0ZWxlc3NfcnBjLCByZWFkZXIsCgkJCQkgIF8oImV4cGVjdGVkIHJlc3BvbnNlIGVuZCBwYWNrZXQgYWZ0ZXIgcmVmIGxpc3RpbmciKSk7CgoJcmV0dXJuIDA7Cn0KCnN0cnVjdCByZWYgKipnZXRfcmVtb3RlX3JlZnMoaW50IGZkX291dCwgc3RydWN0IHBhY2tldF9yZWFkZXIgKnJlYWRlciwKCQkJICAgICBzdHJ1Y3QgcmVmICoqbGlzdCwgaW50IGZvcl9wdXNoLAoJCQkgICAgIHN0cnVjdCB0cmFuc3BvcnRfbHNfcmVmc19vcHRpb25zICp0cmFuc3BvcnRfb3B0aW9ucywKCQkJICAgICBjb25zdCBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnNlcnZlcl9vcHRpb25zLAoJCQkgICAgIGludCBzdGF0ZWxlc3NfcnBjKQp7CglpbnQgaTsKCXN0cnVjdCBzdHJ2ZWMgKnJlZl9wcmVmaXhlcyA9IHRyYW5zcG9ydF9vcHRpb25zID8KCQkmdHJhbnNwb3J0X29wdGlvbnMtPnJlZl9wcmVmaXhlcyA6IE5VTEw7Cgljb25zdCBjaGFyICoqdW5ib3JuX2hlYWRfdGFyZ2V0ID0gdHJhbnNwb3J0X29wdGlvbnMgPwoJCSZ0cmFuc3BvcnRfb3B0aW9ucy0+dW5ib3JuX2hlYWRfdGFyZ2V0IDogTlVMTDsKCSpsaXN0ID0gTlVMTDsKCgllbnN1cmVfc2VydmVyX3N1cHBvcnRzX3YyKCJscy1yZWZzIik7CglwYWNrZXRfd3JpdGVfZm10KGZkX291dCwgImNvbW1hbmQ9bHMtcmVmc1xuIik7CgoJLyogU2VuZCBjYXBhYmlsaXRpZXMgKi8KCXNlbmRfY2FwYWJpbGl0aWVzKGZkX291dCwgcmVhZGVyKTsKCglpZiAoc2VydmVyX29wdGlvbnMgJiYgc2VydmVyX29wdGlvbnMtPm5yKSB7CgkJZW5zdXJlX3NlcnZlcl9zdXBwb3J0c192Migic2VydmVyLW9wdGlvbiIpOwoJCWZvciAoaSA9IDA7IGkgPCBzZXJ2ZXJfb3B0aW9ucy0+bnI7IGkrKykKCQkJcGFja2V0X3dyaXRlX2ZtdChmZF9vdXQsICJzZXJ2ZXItb3B0aW9uPSVzIiwKCQkJCQkgc2VydmVyX29wdGlvbnMtPml0ZW1zW2ldLnN0cmluZyk7Cgl9CgoJcGFja2V0X2RlbGltKGZkX291dCk7CgkvKiBXaGVuIHB1c2hpbmcgd2UgZG9uJ3Qgd2FudCB0byByZXF1ZXN0IHRoZSBwZWVsZWQgdGFncyAqLwoJaWYgKCFmb3JfcHVzaCkKCQlwYWNrZXRfd3JpdGVfZm10KGZkX291dCwgInBlZWxcbiIpOwoJcGFja2V0X3dyaXRlX2ZtdChmZF9vdXQsICJzeW1yZWZzXG4iKTsKCWlmIChzZXJ2ZXJfc3VwcG9ydHNfZmVhdHVyZSgibHMtcmVmcyIsICJ1bmJvcm4iLCAwKSkKCQlwYWNrZXRfd3JpdGVfZm10KGZkX291dCwgInVuYm9yblxuIik7Cglmb3IgKGkgPSAwOyByZWZfcHJlZml4ZXMgJiYgaSA8IHJlZl9wcmVmaXhlcy0+bnI7IGkrKykgewoJCXBhY2tldF93cml0ZV9mbXQoZmRfb3V0LCAicmVmLXByZWZpeCAlc1xuIiwKCQkJCSByZWZfcHJlZml4ZXMtPnZbaV0pOwoJfQoJcGFja2V0X2ZsdXNoKGZkX291dCk7CgoJLyogUHJvY2VzcyByZXNwb25zZSBmcm9tIHNlcnZlciAqLwoJd2hpbGUgKHBhY2tldF9yZWFkZXJfcmVhZChyZWFkZXIpID09IFBBQ0tFVF9SRUFEX05PUk1BTCkgewoJCWlmICghcHJvY2Vzc19yZWZfdjIocmVhZGVyLCAmbGlzdCwgdW5ib3JuX2hlYWRfdGFyZ2V0KSkKCQkJZGllKF8oImludmFsaWQgbHMtcmVmcyByZXNwb25zZTogJXMiKSwgcmVhZGVyLT5saW5lKTsKCX0KCglpZiAocmVhZGVyLT5zdGF0dXMgIT0gUEFDS0VUX1JFQURfRkxVU0gpCgkJZGllKF8oImV4cGVjdGVkIGZsdXNoIGFmdGVyIHJlZiBsaXN0aW5nIikpOwoKCWNoZWNrX3N0YXRlbGVzc19kZWxpbWl0ZXIoc3RhdGVsZXNzX3JwYywgcmVhZGVyLAoJCQkJICBfKCJleHBlY3RlZCByZXNwb25zZSBlbmQgcGFja2V0IGFmdGVyIHJlZiBsaXN0aW5nIikpOwoKCXJldHVybiBsaXN0Owp9Cgpjb25zdCBjaGFyICpwYXJzZV9mZWF0dXJlX3ZhbHVlKGNvbnN0IGNoYXIgKmZlYXR1cmVfbGlzdCwgY29uc3QgY2hhciAqZmVhdHVyZSwgaW50ICpsZW5wLCBpbnQgKm9mZnNldCkKewoJaW50IGxlbjsKCglpZiAoIWZlYXR1cmVfbGlzdCkKCQlyZXR1cm4gTlVMTDsKCglsZW4gPSBzdHJsZW4oZmVhdHVyZSk7CglpZiAob2Zmc2V0KQoJCWZlYXR1cmVfbGlzdCArPSAqb2Zmc2V0OwoJd2hpbGUgKCpmZWF0dXJlX2xpc3QpIHsKCQljb25zdCBjaGFyICpmb3VuZCA9IHN0cnN0cihmZWF0dXJlX2xpc3QsIGZlYXR1cmUpOwoJCWlmICghZm91bmQpCgkJCXJldHVybiBOVUxMOwoJCWlmIChmZWF0dXJlX2xpc3QgPT0gZm91bmQgfHwgaXNzcGFjZShmb3VuZFstMV0pKSB7CgkJCWNvbnN0IGNoYXIgKnZhbHVlID0gZm91bmQgKyBsZW47CgkJCS8qIGZlYXR1cmUgd2l0aCBubyB2YWx1ZSAoZS5nLiwgInRoaW4tcGFjayIpICovCgkJCWlmICghKnZhbHVlIHx8IGlzc3BhY2UoKnZhbHVlKSkgewoJCQkJaWYgKGxlbnApCgkJCQkJKmxlbnAgPSAwOwoJCQkJaWYgKG9mZnNldCkKCQkJCQkqb2Zmc2V0ID0gZm91bmQgKyBsZW4gLSBmZWF0dXJlX2xpc3Q7CgkJCQlyZXR1cm4gdmFsdWU7CgkJCX0KCQkJLyogZmVhdHVyZSB3aXRoIGEgdmFsdWUgKGUuZy4sICJhZ2VudD1naXQvMS4yLjMiKSAqLwoJCQllbHNlIGlmICgqdmFsdWUgPT0gJz0nKSB7CgkJCQlpbnQgZW5kOwoKCQkJCXZhbHVlKys7CgkJCQllbmQgPSBzdHJjc3BuKHZhbHVlLCAiIFx0XG4iKTsKCQkJCWlmIChsZW5wKQoJCQkJCSpsZW5wID0gZW5kOwoJCQkJaWYgKG9mZnNldCkKCQkJCQkqb2Zmc2V0ID0gdmFsdWUgKyBlbmQgLSBmZWF0dXJlX2xpc3Q7CgkJCQlyZXR1cm4gdmFsdWU7CgkJCX0KCQkJLyoKCQkJICogb3RoZXJ3aXNlIHdlIG1hdGNoZWQgYSBzdWJzdHJpbmcgb2YgYW5vdGhlciBmZWF0dXJlOwoJCQkgKiBrZWVwIGxvb2tpbmcKCQkJICovCgkJfQoJCWZlYXR1cmVfbGlzdCA9IGZvdW5kICsgMTsKCX0KCXJldHVybiBOVUxMOwp9CgppbnQgc2VydmVyX3N1cHBvcnRzX2hhc2goY29uc3QgY2hhciAqZGVzaXJlZCwgaW50ICpmZWF0dXJlX3N1cHBvcnRlZCkKewoJaW50IG9mZnNldCA9IDA7CglpbnQgbGVuOwoJY29uc3QgY2hhciAqaGFzaDsKCgloYXNoID0gbmV4dF9zZXJ2ZXJfZmVhdHVyZV92YWx1ZSgib2JqZWN0LWZvcm1hdCIsICZsZW4sICZvZmZzZXQpOwoJaWYgKGZlYXR1cmVfc3VwcG9ydGVkKQoJCSpmZWF0dXJlX3N1cHBvcnRlZCA9ICEhaGFzaDsKCWlmICghaGFzaCkgewoJCWhhc2ggPSBoYXNoX2FsZ29zW0dJVF9IQVNIX1NIQTFdLm5hbWU7CgkJbGVuID0gc3RybGVuKGhhc2gpOwoJfQoJd2hpbGUgKGhhc2gpIHsKCQlpZiAoIXhzdHJuY21weihkZXNpcmVkLCBoYXNoLCBsZW4pKQoJCQlyZXR1cm4gMTsKCgkJaGFzaCA9IG5leHRfc2VydmVyX2ZlYXR1cmVfdmFsdWUoIm9iamVjdC1mb3JtYXQiLCAmbGVuLCAmb2Zmc2V0KTsKCX0KCXJldHVybiAwOwp9CgppbnQgcGFyc2VfZmVhdHVyZV9yZXF1ZXN0KGNvbnN0IGNoYXIgKmZlYXR1cmVfbGlzdCwgY29uc3QgY2hhciAqZmVhdHVyZSkKewoJcmV0dXJuICEhcGFyc2VfZmVhdHVyZV92YWx1ZShmZWF0dXJlX2xpc3QsIGZlYXR1cmUsIE5VTEwsIE5VTEwpOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqbmV4dF9zZXJ2ZXJfZmVhdHVyZV92YWx1ZShjb25zdCBjaGFyICpmZWF0dXJlLCBpbnQgKmxlbiwgaW50ICpvZmZzZXQpCnsKCXJldHVybiBwYXJzZV9mZWF0dXJlX3ZhbHVlKHNlcnZlcl9jYXBhYmlsaXRpZXNfdjEsIGZlYXR1cmUsIGxlbiwgb2Zmc2V0KTsKfQoKY29uc3QgY2hhciAqc2VydmVyX2ZlYXR1cmVfdmFsdWUoY29uc3QgY2hhciAqZmVhdHVyZSwgaW50ICpsZW4pCnsKCXJldHVybiBwYXJzZV9mZWF0dXJlX3ZhbHVlKHNlcnZlcl9jYXBhYmlsaXRpZXNfdjEsIGZlYXR1cmUsIGxlbiwgTlVMTCk7Cn0KCmludCBzZXJ2ZXJfc3VwcG9ydHMoY29uc3QgY2hhciAqZmVhdHVyZSkKewoJcmV0dXJuICEhc2VydmVyX2ZlYXR1cmVfdmFsdWUoZmVhdHVyZSwgTlVMTCk7Cn0KCmVudW0gcHJvdG9jb2wgewoJUFJPVE9fTE9DQUwgPSAxLAoJUFJPVE9fRklMRSwKCVBST1RPX1NTSCwKCVBST1RPX0dJVAp9OwoKaW50IHVybF9pc19sb2NhbF9ub3Rfc3NoKGNvbnN0IGNoYXIgKnVybCkKewoJY29uc3QgY2hhciAqY29sb24gPSBzdHJjaHIodXJsLCAnOicpOwoJY29uc3QgY2hhciAqc2xhc2ggPSBzdHJjaHIodXJsLCAnLycpOwoJcmV0dXJuICFjb2xvbiB8fCAoc2xhc2ggJiYgc2xhc2ggPCBjb2xvbikgfHwKCQkoaGFzX2Rvc19kcml2ZV9wcmVmaXgodXJsKSAmJiBpc192YWxpZF9wYXRoKHVybCkpOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqcHJvdF9uYW1lKGVudW0gcHJvdG9jb2wgcHJvdG9jb2wpCnsKCXN3aXRjaCAocHJvdG9jb2wpIHsKCQljYXNlIFBST1RPX0xPQ0FMOgoJCWNhc2UgUFJPVE9fRklMRToKCQkJcmV0dXJuICJmaWxlIjsKCQljYXNlIFBST1RPX1NTSDoKCQkJcmV0dXJuICJzc2giOwoJCWNhc2UgUFJPVE9fR0lUOgoJCQlyZXR1cm4gImdpdCI7CgkJZGVmYXVsdDoKCQkJcmV0dXJuICJ1bmtub3duIHByb3RvY29sIjsKCX0KfQoKc3RhdGljIGVudW0gcHJvdG9jb2wgZ2V0X3Byb3RvY29sKGNvbnN0IGNoYXIgKm5hbWUpCnsKCWlmICghc3RyY21wKG5hbWUsICJzc2giKSkKCQlyZXR1cm4gUFJPVE9fU1NIOwoJaWYgKCFzdHJjbXAobmFtZSwgImdpdCIpKQoJCXJldHVybiBQUk9UT19HSVQ7CglpZiAoIXN0cmNtcChuYW1lLCAiZ2l0K3NzaCIpKSAvKiBkZXByZWNhdGVkIC0gZG8gbm90IHVzZSAqLwoJCXJldHVybiBQUk9UT19TU0g7CglpZiAoIXN0cmNtcChuYW1lLCAic3NoK2dpdCIpKSAvKiBkZXByZWNhdGVkIC0gZG8gbm90IHVzZSAqLwoJCXJldHVybiBQUk9UT19TU0g7CglpZiAoIXN0cmNtcChuYW1lLCAiZmlsZSIpKQoJCXJldHVybiBQUk9UT19GSUxFOwoJZGllKF8oInByb3RvY29sICclcycgaXMgbm90IHN1cHBvcnRlZCIpLCBuYW1lKTsKfQoKc3RhdGljIGNoYXIgKmhvc3RfZW5kKGNoYXIgKipob3N0c3RhcnQsIGludCByZW1vdmVicmFja2V0cykKewoJY2hhciAqaG9zdCA9ICpob3N0c3RhcnQ7CgljaGFyICplbmQ7CgljaGFyICpzdGFydCA9IHN0cnN0cihob3N0LCAiQFsiKTsKCWlmIChzdGFydCkKCQlzdGFydCsrOyAvKiBKdW1wIG92ZXIgJ0AnICovCgllbHNlCgkJc3RhcnQgPSBob3N0OwoJaWYgKHN0YXJ0WzBdID09ICdbJykgewoJCWVuZCA9IHN0cmNocihzdGFydCArIDEsICddJyk7CgkJaWYgKGVuZCkgewoJCQlpZiAocmVtb3ZlYnJhY2tldHMpIHsKCQkJCSplbmQgPSAwOwoJCQkJbWVtbW92ZShzdGFydCwgc3RhcnQgKyAxLCBlbmQgLSBzdGFydCk7CgkJCQllbmQrKzsKCQkJfQoJCX0gZWxzZQoJCQllbmQgPSBob3N0OwoJfSBlbHNlCgkJZW5kID0gaG9zdDsKCXJldHVybiBlbmQ7Cn0KCiNkZWZpbmUgU1RSXyhzKQkjIHMKI2RlZmluZSBTVFIocykJU1RSXyhzKQoKc3RhdGljIHZvaWQgZ2V0X2hvc3RfYW5kX3BvcnQoY2hhciAqKmhvc3QsIGNvbnN0IGNoYXIgKipwb3J0KQp7CgljaGFyICpjb2xvbiwgKmVuZDsKCWVuZCA9IGhvc3RfZW5kKGhvc3QsIDEpOwoJY29sb24gPSBzdHJjaHIoZW5kLCAnOicpOwoJaWYgKGNvbG9uKSB7CgkJbG9uZyBwb3J0bnIgPSBzdHJ0b2woY29sb24gKyAxLCAmZW5kLCAxMCk7CgkJaWYgKGVuZCAhPSBjb2xvbiArIDEgJiYgKmVuZCA9PSAnXDAnICYmIDAgPD0gcG9ydG5yICYmIHBvcnRuciA8IDY1NTM2KSB7CgkJCSpjb2xvbiA9IDA7CgkJCSpwb3J0ID0gY29sb24gKyAxOwoJCX0gZWxzZSBpZiAoIWNvbG9uWzFdKSB7CgkJCSpjb2xvbiA9IDA7CgkJfQoJfQp9CgpzdGF0aWMgdm9pZCBlbmFibGVfa2VlcGFsaXZlKGludCBzb2NrZmQpCnsKCWludCBrYSA9IDE7CgoJaWYgKHNldHNvY2tvcHQoc29ja2ZkLCBTT0xfU09DS0VULCBTT19LRUVQQUxJVkUsICZrYSwgc2l6ZW9mKGthKSkgPCAwKQoJCWVycm9yX2Vycm5vKF8oInVuYWJsZSB0byBzZXQgU09fS0VFUEFMSVZFIG9uIHNvY2tldCIpKTsKfQoKI2lmbmRlZiBOT19JUFY2CgpzdGF0aWMgY29uc3QgY2hhciAqYWlfbmFtZShjb25zdCBzdHJ1Y3QgYWRkcmluZm8gKmFpKQp7CglzdGF0aWMgY2hhciBhZGRyW05JX01BWEhPU1RdOwoJaWYgKGdldG5hbWVpbmZvKGFpLT5haV9hZGRyLCBhaS0+YWlfYWRkcmxlbiwgYWRkciwgc2l6ZW9mKGFkZHIpLCBOVUxMLCAwLAoJCQlOSV9OVU1FUklDSE9TVCkgIT0gMCkKCQl4c25wcmludGYoYWRkciwgc2l6ZW9mKGFkZHIpLCAiKHVua25vd24pIik7CgoJcmV0dXJuIGFkZHI7Cn0KCi8qCiAqIFJldHVybnMgYSBjb25uZWN0ZWQgc29ja2V0KCkgZmQsIG9yIGVsc2UgZGllKClzLgogKi8Kc3RhdGljIGludCBnaXRfdGNwX2Nvbm5lY3Rfc29jayhjaGFyICpob3N0LCBpbnQgZmxhZ3MpCnsKCXN0cnVjdCBzdHJidWYgZXJyb3JfbWVzc2FnZSA9IFNUUkJVRl9JTklUOwoJaW50IHNvY2tmZCA9IC0xOwoJY29uc3QgY2hhciAqcG9ydCA9IFNUUihERUZBVUxUX0dJVF9QT1JUKTsKCXN0cnVjdCBhZGRyaW5mbyBoaW50cywgKmFpMCwgKmFpOwoJaW50IGdhaTsKCWludCBjbnQgPSAwOwoKCWdldF9ob3N0X2FuZF9wb3J0KCZob3N0LCAmcG9ydCk7CglpZiAoISpwb3J0KQoJCXBvcnQgPSAiPG5vbmU+IjsKCgltZW1zZXQoJmhpbnRzLCAwLCBzaXplb2YoaGludHMpKTsKCWlmIChmbGFncyAmIENPTk5FQ1RfSVBWNCkKCQloaW50cy5haV9mYW1pbHkgPSBBRl9JTkVUOwoJZWxzZSBpZiAoZmxhZ3MgJiBDT05ORUNUX0lQVjYpCgkJaGludHMuYWlfZmFtaWx5ID0gQUZfSU5FVDY7CgloaW50cy5haV9zb2NrdHlwZSA9IFNPQ0tfU1RSRUFNOwoJaGludHMuYWlfcHJvdG9jb2wgPSBJUFBST1RPX1RDUDsKCglpZiAoZmxhZ3MgJiBDT05ORUNUX1ZFUkJPU0UpCgkJZnByaW50ZihzdGRlcnIsIF8oIkxvb2tpbmcgdXAgJXMgLi4uICIpLCBob3N0KTsKCglnYWkgPSBnZXRhZGRyaW5mbyhob3N0LCBwb3J0LCAmaGludHMsICZhaSk7CglpZiAoZ2FpKQoJCWRpZShfKCJ1bmFibGUgdG8gbG9vayB1cCAlcyAocG9ydCAlcykgKCVzKSIpLCBob3N0LCBwb3J0LCBnYWlfc3RyZXJyb3IoZ2FpKSk7CgoJaWYgKGZsYWdzICYgQ09OTkVDVF9WRVJCT1NFKQoJCS8qIFRSQU5TTEFUT1JTOiB0aGlzIGlzIHRoZSBlbmQgb2YgIkxvb2tpbmcgdXAgJXMgLi4uICIgKi8KCQlmcHJpbnRmKHN0ZGVyciwgXygiZG9uZS5cbkNvbm5lY3RpbmcgdG8gJXMgKHBvcnQgJXMpIC4uLiAiKSwgaG9zdCwgcG9ydCk7CgoJZm9yIChhaTAgPSBhaTsgYWk7IGFpID0gYWktPmFpX25leHQsIGNudCsrKSB7CgkJc29ja2ZkID0gc29ja2V0KGFpLT5haV9mYW1pbHksCgkJCQlhaS0+YWlfc29ja3R5cGUsIGFpLT5haV9wcm90b2NvbCk7CgkJaWYgKChzb2NrZmQgPCAwKSB8fAoJCSAgICAoY29ubmVjdChzb2NrZmQsIGFpLT5haV9hZGRyLCBhaS0+YWlfYWRkcmxlbikgPCAwKSkgewoJCQlzdHJidWZfYWRkZigmZXJyb3JfbWVzc2FnZSwgIiVzWyVkOiAlc106IGVycm5vPSVzXG4iLAoJCQkJICAgIGhvc3QsIGNudCwgYWlfbmFtZShhaSksIHN0cmVycm9yKGVycm5vKSk7CgkJCWlmICgwIDw9IHNvY2tmZCkKCQkJCWNsb3NlKHNvY2tmZCk7CgkJCXNvY2tmZCA9IC0xOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKGZsYWdzICYgQ09OTkVDVF9WRVJCT1NFKQoJCQlmcHJpbnRmKHN0ZGVyciwgIiVzICIsIGFpX25hbWUoYWkpKTsKCQlicmVhazsKCX0KCglmcmVlYWRkcmluZm8oYWkwKTsKCglpZiAoc29ja2ZkIDwgMCkKCQlkaWUoXygidW5hYmxlIHRvIGNvbm5lY3QgdG8gJXM6XG4lcyIpLCBob3N0LCBlcnJvcl9tZXNzYWdlLmJ1Zik7CgoJZW5hYmxlX2tlZXBhbGl2ZShzb2NrZmQpOwoKCWlmIChmbGFncyAmIENPTk5FQ1RfVkVSQk9TRSkKCQkvKiBUUkFOU0xBVE9SUzogdGhpcyBpcyB0aGUgZW5kIG9mICJDb25uZWN0aW5nIHRvICVzIChwb3J0ICVzKSAuLi4gIiAqLwoJCWZwcmludGZfbG4oc3RkZXJyLCBfKCJkb25lLiIpKTsKCglzdHJidWZfcmVsZWFzZSgmZXJyb3JfbWVzc2FnZSk7CgoJcmV0dXJuIHNvY2tmZDsKfQoKI2Vsc2UgLyogTk9fSVBWNiAqLwoKLyoKICogUmV0dXJucyBhIGNvbm5lY3RlZCBzb2NrZXQoKSBmZCwgb3IgZWxzZSBkaWUoKXMuCiAqLwpzdGF0aWMgaW50IGdpdF90Y3BfY29ubmVjdF9zb2NrKGNoYXIgKmhvc3QsIGludCBmbGFncykKewoJc3RydWN0IHN0cmJ1ZiBlcnJvcl9tZXNzYWdlID0gU1RSQlVGX0lOSVQ7CglpbnQgc29ja2ZkID0gLTE7Cgljb25zdCBjaGFyICpwb3J0ID0gU1RSKERFRkFVTFRfR0lUX1BPUlQpOwoJY2hhciAqZXA7CglzdHJ1Y3QgaG9zdGVudCAqaGU7CglzdHJ1Y3Qgc29ja2FkZHJfaW4gc2E7CgljaGFyICoqYXA7Cgl1bnNpZ25lZCBpbnQgbnBvcnQ7CglpbnQgY250OwoKCWdldF9ob3N0X2FuZF9wb3J0KCZob3N0LCAmcG9ydCk7CgoJaWYgKGZsYWdzICYgQ09OTkVDVF9WRVJCT1NFKQoJCWZwcmludGYoc3RkZXJyLCBfKCJMb29raW5nIHVwICVzIC4uLiAiKSwgaG9zdCk7CgoJaGUgPSBnZXRob3N0YnluYW1lKGhvc3QpOwoJaWYgKCFoZSkKCQlkaWUoXygidW5hYmxlIHRvIGxvb2sgdXAgJXMgKCVzKSIpLCBob3N0LCBoc3RyZXJyb3IoaF9lcnJubykpOwoJbnBvcnQgPSBzdHJ0b3VsKHBvcnQsICZlcCwgMTApOwoJaWYgKCBlcCA9PSBwb3J0IHx8ICplcCApIHsKCQkvKiBOb3QgbnVtZXJpYyAqLwoJCXN0cnVjdCBzZXJ2ZW50ICpzZSA9IGdldHNlcnZieW5hbWUocG9ydCwidGNwIik7CgkJaWYgKCAhc2UgKQoJCQlkaWUoXygidW5rbm93biBwb3J0ICVzIiksIHBvcnQpOwoJCW5wb3J0ID0gc2UtPnNfcG9ydDsKCX0KCglpZiAoZmxhZ3MgJiBDT05ORUNUX1ZFUkJPU0UpCgkJLyogVFJBTlNMQVRPUlM6IHRoaXMgaXMgdGhlIGVuZCBvZiAiTG9va2luZyB1cCAlcyAuLi4gIiAqLwoJCWZwcmludGYoc3RkZXJyLCBfKCJkb25lLlxuQ29ubmVjdGluZyB0byAlcyAocG9ydCAlcykgLi4uICIpLCBob3N0LCBwb3J0KTsKCglmb3IgKGNudCA9IDAsIGFwID0gaGUtPmhfYWRkcl9saXN0OyAqYXA7IGFwKyssIGNudCsrKSB7CgkJbWVtc2V0KCZzYSwgMCwgc2l6ZW9mIHNhKTsKCQlzYS5zaW5fZmFtaWx5ID0gaGUtPmhfYWRkcnR5cGU7CgkJc2Euc2luX3BvcnQgPSBodG9ucyhucG9ydCk7CgkJbWVtY3B5KCZzYS5zaW5fYWRkciwgKmFwLCBoZS0+aF9sZW5ndGgpOwoKCQlzb2NrZmQgPSBzb2NrZXQoaGUtPmhfYWRkcnR5cGUsIFNPQ0tfU1RSRUFNLCAwKTsKCQlpZiAoKHNvY2tmZCA8IDApIHx8CgkJICAgIGNvbm5lY3Qoc29ja2ZkLCAoc3RydWN0IHNvY2thZGRyICopJnNhLCBzaXplb2Ygc2EpIDwgMCkgewoJCQlzdHJidWZfYWRkZigmZXJyb3JfbWVzc2FnZSwgIiVzWyVkOiAlc106IGVycm5vPSVzXG4iLAoJCQkJaG9zdCwKCQkJCWNudCwKCQkJCWluZXRfbnRvYSgqKHN0cnVjdCBpbl9hZGRyICopJnNhLnNpbl9hZGRyKSwKCQkJCXN0cmVycm9yKGVycm5vKSk7CgkJCWlmICgwIDw9IHNvY2tmZCkKCQkJCWNsb3NlKHNvY2tmZCk7CgkJCXNvY2tmZCA9IC0xOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKGZsYWdzICYgQ09OTkVDVF9WRVJCT1NFKQoJCQlmcHJpbnRmKHN0ZGVyciwgIiVzICIsCgkJCQlpbmV0X250b2EoKihzdHJ1Y3QgaW5fYWRkciAqKSZzYS5zaW5fYWRkcikpOwoJCWJyZWFrOwoJfQoKCWlmIChzb2NrZmQgPCAwKQoJCWRpZShfKCJ1bmFibGUgdG8gY29ubmVjdCB0byAlczpcbiVzIiksIGhvc3QsIGVycm9yX21lc3NhZ2UuYnVmKTsKCgllbmFibGVfa2VlcGFsaXZlKHNvY2tmZCk7CgoJaWYgKGZsYWdzICYgQ09OTkVDVF9WRVJCT1NFKQoJCS8qIFRSQU5TTEFUT1JTOiB0aGlzIGlzIHRoZSBlbmQgb2YgIkNvbm5lY3RpbmcgdG8gJXMgKHBvcnQgJXMpIC4uLiAiICovCgkJZnByaW50Zl9sbihzdGRlcnIsIF8oImRvbmUuIikpOwoKCXJldHVybiBzb2NrZmQ7Cn0KCiNlbmRpZiAvKiBOT19JUFY2ICovCgoKLyoKICogRHVtbXkgY2hpbGRfcHJvY2VzcyByZXR1cm5lZCBieSBnaXRfY29ubmVjdCgpIGlmIHRoZSB0cmFuc3BvcnQgcHJvdG9jb2wKICogZG9lcyBub3QgbmVlZCBmb3JrKDIpLgogKi8Kc3RhdGljIHN0cnVjdCBjaGlsZF9wcm9jZXNzIG5vX2ZvcmsgPSBDSElMRF9QUk9DRVNTX0lOSVQ7CgppbnQgZ2l0X2Nvbm5lY3Rpb25faXNfc29ja2V0KHN0cnVjdCBjaGlsZF9wcm9jZXNzICpjb25uKQp7CglyZXR1cm4gY29ubiA9PSAmbm9fZm9yazsKfQoKc3RhdGljIHN0cnVjdCBjaGlsZF9wcm9jZXNzICpnaXRfdGNwX2Nvbm5lY3QoaW50IGZkWzJdLCBjaGFyICpob3N0LCBpbnQgZmxhZ3MpCnsKCWludCBzb2NrZmQgPSBnaXRfdGNwX2Nvbm5lY3Rfc29jayhob3N0LCBmbGFncyk7CgoJZmRbMF0gPSBzb2NrZmQ7CglmZFsxXSA9IGR1cChzb2NrZmQpOwoKCXJldHVybiAmbm9fZm9yazsKfQoKCnN0YXRpYyBjaGFyICpnaXRfcHJveHlfY29tbWFuZDsKCnN0YXRpYyBpbnQgZ2l0X3Byb3h5X2NvbW1hbmRfb3B0aW9ucyhjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlLAoJCXZvaWQgKmNiKQp7CglpZiAoIXN0cmNtcCh2YXIsICJjb3JlLmdpdHByb3h5IikpIHsKCQljb25zdCBjaGFyICpmb3JfcG9zOwoJCWludCBtYXRjaGxlbiA9IC0xOwoJCWludCBob3N0bGVuOwoJCWNvbnN0IGNoYXIgKnJob3N0X25hbWUgPSBjYjsKCQlpbnQgcmhvc3RfbGVuID0gc3RybGVuKHJob3N0X25hbWUpOwoKCQlpZiAoZ2l0X3Byb3h5X2NvbW1hbmQpCgkJCXJldHVybiAwOwoJCWlmICghdmFsdWUpCgkJCXJldHVybiBjb25maWdfZXJyb3Jfbm9uYm9vbCh2YXIpOwoJCS8qIFtjb3JlXQoJCSAqIDsjIG1hdGNoZXMgd3d3Lmtlcm5lbC5vcmcgYXMgd2VsbAoJCSAqIGdpdHByb3h5ID0gbmV0Y2F0dGVyLTEgZm9yIGtlcm5lbC5vcmcKCQkgKiBnaXRwcm94eSA9IG5ldGNhdHRlci0yIGZvciBzYW1wbGUueHoKCQkgKiBnaXRwcm94eSA9IG5ldGNhdHRlci1kZWZhdWx0CgkJICovCgkJZm9yX3BvcyA9IHN0cnN0cih2YWx1ZSwgIiBmb3IgIik7CgkJaWYgKCFmb3JfcG9zKQoJCQkvKiBtYXRjaGVzIGV2ZXJ5Ym9keSAqLwoJCQltYXRjaGxlbiA9IHN0cmxlbih2YWx1ZSk7CgkJZWxzZSB7CgkJCWhvc3RsZW4gPSBzdHJsZW4oZm9yX3BvcyArIDUpOwoJCQlpZiAocmhvc3RfbGVuIDwgaG9zdGxlbikKCQkJCW1hdGNobGVuID0gLTE7CgkJCWVsc2UgaWYgKCFzdHJuY21wKGZvcl9wb3MgKyA1LAoJCQkJCSAgcmhvc3RfbmFtZSArIHJob3N0X2xlbiAtIGhvc3RsZW4sCgkJCQkJICBob3N0bGVuKSAmJgoJCQkJICgocmhvc3RfbGVuID09IGhvc3RsZW4pIHx8CgkJCQkgIHJob3N0X25hbWVbcmhvc3RfbGVuIC0gaG9zdGxlbiAtMV0gPT0gJy4nKSkKCQkJCW1hdGNobGVuID0gZm9yX3BvcyAtIHZhbHVlOwoJCQllbHNlCgkJCQltYXRjaGxlbiA9IC0xOwoJCX0KCQlpZiAoMCA8PSBtYXRjaGxlbikgewoJCQkvKiBjb3JlLmdpdHByb3h5ID0gbm9uZSBmb3Iga2VybmVsLm9yZyAqLwoJCQlpZiAobWF0Y2hsZW4gPT0gNCAmJgoJCQkgICAgIW1lbWNtcCh2YWx1ZSwgIm5vbmUiLCA0KSkKCQkJCW1hdGNobGVuID0gMDsKCQkJZ2l0X3Byb3h5X2NvbW1hbmQgPSB4bWVtZHVweih2YWx1ZSwgbWF0Y2hsZW4pOwoJCX0KCQlyZXR1cm4gMDsKCX0KCglyZXR1cm4gZ2l0X2RlZmF1bHRfY29uZmlnKHZhciwgdmFsdWUsIGNiKTsKfQoKc3RhdGljIGludCBnaXRfdXNlX3Byb3h5KGNvbnN0IGNoYXIgKmhvc3QpCnsKCWdpdF9wcm94eV9jb21tYW5kID0gZ2V0ZW52KCJHSVRfUFJPWFlfQ09NTUFORCIpOwoJZ2l0X2NvbmZpZyhnaXRfcHJveHlfY29tbWFuZF9vcHRpb25zLCAodm9pZCopaG9zdCk7CglyZXR1cm4gKGdpdF9wcm94eV9jb21tYW5kICYmICpnaXRfcHJveHlfY29tbWFuZCk7Cn0KCnN0YXRpYyBzdHJ1Y3QgY2hpbGRfcHJvY2VzcyAqZ2l0X3Byb3h5X2Nvbm5lY3QoaW50IGZkWzJdLCBjaGFyICpob3N0KQp7Cgljb25zdCBjaGFyICpwb3J0ID0gU1RSKERFRkFVTFRfR0lUX1BPUlQpOwoJc3RydWN0IGNoaWxkX3Byb2Nlc3MgKnByb3h5OwoKCWdldF9ob3N0X2FuZF9wb3J0KCZob3N0LCAmcG9ydCk7CgoJaWYgKGxvb2tzX2xpa2VfY29tbWFuZF9saW5lX29wdGlvbihob3N0KSkKCQlkaWUoXygic3RyYW5nZSBob3N0bmFtZSAnJXMnIGJsb2NrZWQiKSwgaG9zdCk7CglpZiAobG9va3NfbGlrZV9jb21tYW5kX2xpbmVfb3B0aW9uKHBvcnQpKQoJCWRpZShfKCJzdHJhbmdlIHBvcnQgJyVzJyBibG9ja2VkIiksIHBvcnQpOwoKCXByb3h5ID0geG1hbGxvYyhzaXplb2YoKnByb3h5KSk7CgljaGlsZF9wcm9jZXNzX2luaXQocHJveHkpOwoJc3RydmVjX3B1c2goJnByb3h5LT5hcmdzLCBnaXRfcHJveHlfY29tbWFuZCk7CglzdHJ2ZWNfcHVzaCgmcHJveHktPmFyZ3MsIGhvc3QpOwoJc3RydmVjX3B1c2goJnByb3h5LT5hcmdzLCBwb3J0KTsKCXByb3h5LT5pbiA9IC0xOwoJcHJveHktPm91dCA9IC0xOwoJaWYgKHN0YXJ0X2NvbW1hbmQocHJveHkpKQoJCWRpZShfKCJjYW5ub3Qgc3RhcnQgcHJveHkgJXMiKSwgZ2l0X3Byb3h5X2NvbW1hbmQpOwoJZmRbMF0gPSBwcm94eS0+b3V0OyAvKiByZWFkIGZyb20gcHJveHkgc3Rkb3V0ICovCglmZFsxXSA9IHByb3h5LT5pbjsgIC8qIHdyaXRlIHRvIHByb3h5IHN0ZGluICovCglyZXR1cm4gcHJveHk7Cn0KCnN0YXRpYyBjaGFyICpnZXRfcG9ydChjaGFyICpob3N0KQp7CgljaGFyICplbmQ7CgljaGFyICpwID0gc3RyY2hyKGhvc3QsICc6Jyk7CgoJaWYgKHApIHsKCQlsb25nIHBvcnQgPSBzdHJ0b2wocCArIDEsICZlbmQsIDEwKTsKCQlpZiAoZW5kICE9IHAgKyAxICYmICplbmQgPT0gJ1wwJyAmJiAwIDw9IHBvcnQgJiYgcG9ydCA8IDY1NTM2KSB7CgkJCSpwID0gJ1wwJzsKCQkJcmV0dXJuIHArMTsKCQl9Cgl9CgoJcmV0dXJuIE5VTEw7Cn0KCi8qCiAqIEV4dHJhY3QgcHJvdG9jb2wgYW5kIHJlbGV2YW50IHBhcnRzIGZyb20gdGhlIHNwZWNpZmllZCBjb25uZWN0aW9uIFVSTC4KICogVGhlIGNhbGxlciBtdXN0IGZyZWUoKSB0aGUgcmV0dXJuZWQgc3RyaW5ncy4KICovCnN0YXRpYyBlbnVtIHByb3RvY29sIHBhcnNlX2Nvbm5lY3RfdXJsKGNvbnN0IGNoYXIgKnVybF9vcmlnLCBjaGFyICoqcmV0X2hvc3QsCgkJCQkgICAgICAgY2hhciAqKnJldF9wYXRoKQp7CgljaGFyICp1cmw7CgljaGFyICpob3N0LCAqcGF0aDsKCWNoYXIgKmVuZDsKCWludCBzZXBhcmF0b3IgPSAnLyc7CgllbnVtIHByb3RvY29sIHByb3RvY29sID0gUFJPVE9fTE9DQUw7CgoJaWYgKGlzX3VybCh1cmxfb3JpZykpCgkJdXJsID0gdXJsX2RlY29kZSh1cmxfb3JpZyk7CgllbHNlCgkJdXJsID0geHN0cmR1cCh1cmxfb3JpZyk7CgoJaG9zdCA9IHN0cnN0cih1cmwsICI6Ly8iKTsKCWlmIChob3N0KSB7CgkJKmhvc3QgPSAnXDAnOwoJCXByb3RvY29sID0gZ2V0X3Byb3RvY29sKHVybCk7CgkJaG9zdCArPSAzOwoJfSBlbHNlIHsKCQlob3N0ID0gdXJsOwoJCWlmICghdXJsX2lzX2xvY2FsX25vdF9zc2godXJsKSkgewoJCQlwcm90b2NvbCA9IFBST1RPX1NTSDsKCQkJc2VwYXJhdG9yID0gJzonOwoJCX0KCX0KCgkvKgoJICogRG9uJ3QgZG8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtcyBhcyBwcm90b2NvbCBjb2RlIGRvZXMKCSAqICdbXScgdW53cmFwcGluZyBpbiBnZXRfaG9zdF9hbmRfcG9ydCgpCgkgKi8KCWVuZCA9IGhvc3RfZW5kKCZob3N0LCAwKTsKCglpZiAocHJvdG9jb2wgPT0gUFJPVE9fTE9DQUwpCgkJcGF0aCA9IGVuZDsKCWVsc2UgaWYgKHByb3RvY29sID09IFBST1RPX0ZJTEUgJiYgKmhvc3QgIT0gJy8nICYmCgkJICFoYXNfZG9zX2RyaXZlX3ByZWZpeChob3N0KSAmJgoJCSBvZmZzZXRfMXN0X2NvbXBvbmVudChob3N0IC0gMikgPiAxKQoJCXBhdGggPSBob3N0IC0gMjsgLyogaW5jbHVkZSB0aGUgbGVhZGluZyAiLy8iICovCgllbHNlIGlmIChwcm90b2NvbCA9PSBQUk9UT19GSUxFICYmIGhhc19kb3NfZHJpdmVfcHJlZml4KGVuZCkpCgkJcGF0aCA9IGVuZDsgLyogImZpbGU6Ly8kKHB3ZCkiIG1heSBiZSAiZmlsZTovL0M6L3Byb2plY3RzL3JlcG8iICovCgllbHNlCgkJcGF0aCA9IHN0cmNocihlbmQsIHNlcGFyYXRvcik7CgoJaWYgKCFwYXRoIHx8ICEqcGF0aCkKCQlkaWUoXygibm8gcGF0aCBzcGVjaWZpZWQ7IHNlZSAnZ2l0IGhlbHAgcHVsbCcgZm9yIHZhbGlkIHVybCBzeW50YXgiKSk7CgoJLyoKCSAqIG51bGwtdGVybWluYXRlIGhvc3RuYW1lIGFuZCBwb2ludCBwYXRoIHRvIH4gZm9yIFVSTCdzIGxpa2UgdGhpczoKCSAqICAgIHNzaDovL2hvc3QueHovfnVzZXIvcmVwbwoJICovCgoJZW5kID0gcGF0aDsgLyogTmVlZCB0byBcMCB0ZXJtaW5hdGUgaG9zdCBoZXJlICovCglpZiAoc2VwYXJhdG9yID09ICc6JykKCQlwYXRoKys7IC8qIHBhdGggc3RhcnRzIGFmdGVyICc6JyAqLwoJaWYgKHByb3RvY29sID09IFBST1RPX0dJVCB8fCBwcm90b2NvbCA9PSBQUk9UT19TU0gpIHsKCQlpZiAocGF0aFsxXSA9PSAnficpCgkJCXBhdGgrKzsKCX0KCglwYXRoID0geHN0cmR1cChwYXRoKTsKCSplbmQgPSAnXDAnOwoKCSpyZXRfaG9zdCA9IHhzdHJkdXAoaG9zdCk7CgkqcmV0X3BhdGggPSBwYXRoOwoJZnJlZSh1cmwpOwoJcmV0dXJuIHByb3RvY29sOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqZ2V0X3NzaF9jb21tYW5kKHZvaWQpCnsKCWNvbnN0IGNoYXIgKnNzaDsKCglpZiAoKHNzaCA9IGdldGVudigiR0lUX1NTSF9DT01NQU5EIikpKQoJCXJldHVybiBzc2g7CgoJaWYgKCFnaXRfY29uZmlnX2dldF9zdHJpbmdfdG1wKCJjb3JlLnNzaGNvbW1hbmQiLCAmc3NoKSkKCQlyZXR1cm4gc3NoOwoKCXJldHVybiBOVUxMOwp9CgplbnVtIHNzaF92YXJpYW50IHsKCVZBUklBTlRfQVVUTywKCVZBUklBTlRfU0lNUExFLAoJVkFSSUFOVF9TU0gsCglWQVJJQU5UX1BMSU5LLAoJVkFSSUFOVF9QVVRUWSwKCVZBUklBTlRfVE9SVE9JU0VQTElOSywKfTsKCnN0YXRpYyB2b2lkIG92ZXJyaWRlX3NzaF92YXJpYW50KGVudW0gc3NoX3ZhcmlhbnQgKnNzaF92YXJpYW50KQp7Cgljb25zdCBjaGFyICp2YXJpYW50ID0gZ2V0ZW52KCJHSVRfU1NIX1ZBUklBTlQiKTsKCglpZiAoIXZhcmlhbnQgJiYgZ2l0X2NvbmZpZ19nZXRfc3RyaW5nX3RtcCgic3NoLnZhcmlhbnQiLCAmdmFyaWFudCkpCgkJcmV0dXJuOwoKCWlmICghc3RyY21wKHZhcmlhbnQsICJhdXRvIikpCgkJKnNzaF92YXJpYW50ID0gVkFSSUFOVF9BVVRPOwoJZWxzZSBpZiAoIXN0cmNtcCh2YXJpYW50LCAicGxpbmsiKSkKCQkqc3NoX3ZhcmlhbnQgPSBWQVJJQU5UX1BMSU5LOwoJZWxzZSBpZiAoIXN0cmNtcCh2YXJpYW50LCAicHV0dHkiKSkKCQkqc3NoX3ZhcmlhbnQgPSBWQVJJQU5UX1BVVFRZOwoJZWxzZSBpZiAoIXN0cmNtcCh2YXJpYW50LCAidG9ydG9pc2VwbGluayIpKQoJCSpzc2hfdmFyaWFudCA9IFZBUklBTlRfVE9SVE9JU0VQTElOSzsKCWVsc2UgaWYgKCFzdHJjbXAodmFyaWFudCwgInNpbXBsZSIpKQoJCSpzc2hfdmFyaWFudCA9IFZBUklBTlRfU0lNUExFOwoJZWxzZQoJCSpzc2hfdmFyaWFudCA9IFZBUklBTlRfU1NIOwp9CgpzdGF0aWMgZW51bSBzc2hfdmFyaWFudCBkZXRlcm1pbmVfc3NoX3ZhcmlhbnQoY29uc3QgY2hhciAqc3NoX2NvbW1hbmQsCgkJCQkJICAgICAgaW50IGlzX2NtZGxpbmUpCnsKCWVudW0gc3NoX3ZhcmlhbnQgc3NoX3ZhcmlhbnQgPSBWQVJJQU5UX0FVVE87Cgljb25zdCBjaGFyICp2YXJpYW50OwoJY2hhciAqcCA9IE5VTEw7CgoJb3ZlcnJpZGVfc3NoX3ZhcmlhbnQoJnNzaF92YXJpYW50KTsKCglpZiAoc3NoX3ZhcmlhbnQgIT0gVkFSSUFOVF9BVVRPKQoJCXJldHVybiBzc2hfdmFyaWFudDsKCglpZiAoIWlzX2NtZGxpbmUpIHsKCQlwID0geHN0cmR1cChzc2hfY29tbWFuZCk7CgkJdmFyaWFudCA9IGJhc2VuYW1lKHApOwoJfSBlbHNlIHsKCQljb25zdCBjaGFyICoqc3NoX2FyZ3Y7CgoJCXAgPSB4c3RyZHVwKHNzaF9jb21tYW5kKTsKCQlpZiAoc3BsaXRfY21kbGluZShwLCAmc3NoX2FyZ3YpID4gMCkgewoJCQl2YXJpYW50ID0gYmFzZW5hbWUoKGNoYXIgKilzc2hfYXJndlswXSk7CgkJCS8qCgkJCSAqIEF0IHRoaXMgcG9pbnQsIHZhcmlhbnQgcG9pbnRzIGludG8gdGhlIGJ1ZmZlcgoJCQkgKiByZWZlcmVuY2VkIGJ5IHAsIGhlbmNlIHdlIGRvIG5vdCBuZWVkIHNzaF9hcmd2CgkJCSAqIGFueSBsb25nZXIuCgkJCSAqLwoJCQlmcmVlKHNzaF9hcmd2KTsKCQl9IGVsc2UgewoJCQlmcmVlKHApOwoJCQlyZXR1cm4gc3NoX3ZhcmlhbnQ7CgkJfQoJfQoKCWlmICghc3RyY2FzZWNtcCh2YXJpYW50LCAic3NoIikgfHwKCSAgICAhc3RyY2FzZWNtcCh2YXJpYW50LCAic3NoLmV4ZSIpKQoJCXNzaF92YXJpYW50ID0gVkFSSUFOVF9TU0g7CgllbHNlIGlmICghc3RyY2FzZWNtcCh2YXJpYW50LCAicGxpbmsiKSB8fAoJCSAhc3RyY2FzZWNtcCh2YXJpYW50LCAicGxpbmsuZXhlIikpCgkJc3NoX3ZhcmlhbnQgPSBWQVJJQU5UX1BMSU5LOwoJZWxzZSBpZiAoIXN0cmNhc2VjbXAodmFyaWFudCwgInRvcnRvaXNlcGxpbmsiKSB8fAoJCSAhc3RyY2FzZWNtcCh2YXJpYW50LCAidG9ydG9pc2VwbGluay5leGUiKSkKCQlzc2hfdmFyaWFudCA9IFZBUklBTlRfVE9SVE9JU0VQTElOSzsKCglmcmVlKHApOwoJcmV0dXJuIHNzaF92YXJpYW50Owp9CgovKgogKiBPcGVuIGEgY29ubmVjdGlvbiB1c2luZyBHaXQncyBuYXRpdmUgcHJvdG9jb2wuCiAqCiAqIFRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIGZyZWVpbmcgaG9zdGFuZHBvcnQsIGJ1dCB0aGlzIGZ1bmN0aW9uIG1heQogKiBtb2RpZnkgaXQgKGZvciBleGFtcGxlLCB0byB0cnVuY2F0ZSBpdCB0byByZW1vdmUgdGhlIHBvcnQgcGFydCkuCiAqLwpzdGF0aWMgc3RydWN0IGNoaWxkX3Byb2Nlc3MgKmdpdF9jb25uZWN0X2dpdChpbnQgZmRbMl0sIGNoYXIgKmhvc3RhbmRwb3J0LAoJCQkJCSAgICAgY29uc3QgY2hhciAqcGF0aCwgY29uc3QgY2hhciAqcHJvZywKCQkJCQkgICAgIGVudW0gcHJvdG9jb2xfdmVyc2lvbiB2ZXJzaW9uLAoJCQkJCSAgICAgaW50IGZsYWdzKQp7CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyAqY29ubjsKCXN0cnVjdCBzdHJidWYgcmVxdWVzdCA9IFNUUkJVRl9JTklUOwoJLyoKCSAqIFNldCB1cCB2aXJ0dWFsIGhvc3QgaW5mb3JtYXRpb24gYmFzZWQgb24gd2hlcmUgd2Ugd2lsbAoJICogY29ubmVjdCwgdW5sZXNzIHRoZSB1c2VyIGhhcyBvdmVycmlkZGVuIHVzIGluCgkgKiB0aGUgZW52aXJvbm1lbnQuCgkgKi8KCWNoYXIgKnRhcmdldF9ob3N0ID0gZ2V0ZW52KCJHSVRfT1ZFUlJJREVfVklSVFVBTF9IT1NUIik7CglpZiAodGFyZ2V0X2hvc3QpCgkJdGFyZ2V0X2hvc3QgPSB4c3RyZHVwKHRhcmdldF9ob3N0KTsKCWVsc2UKCQl0YXJnZXRfaG9zdCA9IHhzdHJkdXAoaG9zdGFuZHBvcnQpOwoKCXRyYW5zcG9ydF9jaGVja19hbGxvd2VkKCJnaXQiKTsKCWlmIChzdHJjaHIodGFyZ2V0X2hvc3QsICdcbicpIHx8IHN0cmNocihwYXRoLCAnXG4nKSkKCQlkaWUoXygibmV3bGluZSBpcyBmb3JiaWRkZW4gaW4gZ2l0Oi8vIGhvc3RzIGFuZCByZXBvIHBhdGhzIikpOwoKCS8qCgkgKiBUaGVzZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24gY29tbWFuZHMgZGllKCkgaWYgdGhleQoJICogY2Fubm90IGNvbm5lY3QuCgkgKi8KCWlmIChnaXRfdXNlX3Byb3h5KGhvc3RhbmRwb3J0KSkKCQljb25uID0gZ2l0X3Byb3h5X2Nvbm5lY3QoZmQsIGhvc3RhbmRwb3J0KTsKCWVsc2UKCQljb25uID0gZ2l0X3RjcF9jb25uZWN0KGZkLCBob3N0YW5kcG9ydCwgZmxhZ3MpOwoJLyoKCSAqIFNlcGFyYXRlIG9yaWdpbmFsIHByb3RvY29sIGNvbXBvbmVudHMgcHJvZyBhbmQgcGF0aAoJICogZnJvbSBleHRlbmRlZCBob3N0IGhlYWRlciB3aXRoIGEgTlVMIGJ5dGUuCgkgKgoJICogTm90ZTogRG8gbm90IGFkZCBhbnkgb3RoZXIgaGVhZGVycyBoZXJlISAgRG9pbmcgc28KCSAqIHdpbGwgY2F1c2Ugb2xkZXIgZ2l0LWRhZW1vbiBzZXJ2ZXJzIHRvIGNyYXNoLgoJICovCglzdHJidWZfYWRkZigmcmVxdWVzdCwKCQkgICAgIiVzICVzJWNob3N0PSVzJWMiLAoJCSAgICBwcm9nLCBwYXRoLCAwLAoJCSAgICB0YXJnZXRfaG9zdCwgMCk7CgoJLyogSWYgdXNpbmcgYSBuZXcgdmVyc2lvbiBwdXQgdGhhdCBzdHVmZiBoZXJlIGFmdGVyIGEgc2Vjb25kIG51bGwgYnl0ZSAqLwoJaWYgKHZlcnNpb24gPiAwKSB7CgkJc3RyYnVmX2FkZGNoKCZyZXF1ZXN0LCAnXDAnKTsKCQlzdHJidWZfYWRkZigmcmVxdWVzdCwgInZlcnNpb249JWQlYyIsCgkJCSAgICB2ZXJzaW9uLCAnXDAnKTsKCX0KCglwYWNrZXRfd3JpdGUoZmRbMV0sIHJlcXVlc3QuYnVmLCByZXF1ZXN0Lmxlbik7CgoJZnJlZSh0YXJnZXRfaG9zdCk7CglzdHJidWZfcmVsZWFzZSgmcmVxdWVzdCk7CglyZXR1cm4gY29ubjsKfQoKLyoKICogQXBwZW5kIHRoZSBhcHByb3ByaWF0ZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gYGVudmAgYW5kIG9wdGlvbnMgdG8KICogYGFyZ3NgIGZvciBydW5uaW5nIHNzaCBpbiBHaXQncyBTU0gtdHVubmVsZWQgdHJhbnNwb3J0LgogKi8Kc3RhdGljIHZvaWQgcHVzaF9zc2hfb3B0aW9ucyhzdHJ1Y3Qgc3RydmVjICphcmdzLCBzdHJ1Y3Qgc3RydmVjICplbnYsCgkJCSAgICAgZW51bSBzc2hfdmFyaWFudCB2YXJpYW50LCBjb25zdCBjaGFyICpwb3J0LAoJCQkgICAgIGVudW0gcHJvdG9jb2xfdmVyc2lvbiB2ZXJzaW9uLCBpbnQgZmxhZ3MpCnsKCWlmICh2YXJpYW50ID09IFZBUklBTlRfU1NIICYmCgkgICAgdmVyc2lvbiA+IDApIHsKCQlzdHJ2ZWNfcHVzaChhcmdzLCAiLW8iKTsKCQlzdHJ2ZWNfcHVzaChhcmdzLCAiU2VuZEVudj0iIEdJVF9QUk9UT0NPTF9FTlZJUk9OTUVOVCk7CgkJc3RydmVjX3B1c2hmKGVudiwgR0lUX1BST1RPQ09MX0VOVklST05NRU5UICI9dmVyc2lvbj0lZCIsCgkJCSAgICAgdmVyc2lvbik7Cgl9CgoJaWYgKGZsYWdzICYgQ09OTkVDVF9JUFY0KSB7CgkJc3dpdGNoICh2YXJpYW50KSB7CgkJY2FzZSBWQVJJQU5UX0FVVE86CgkJCUJVRygiVkFSSUFOVF9BVVRPIHBhc3NlZCB0byBwdXNoX3NzaF9vcHRpb25zIik7CgkJY2FzZSBWQVJJQU5UX1NJTVBMRToKCQkJZGllKF8oInNzaCB2YXJpYW50ICdzaW1wbGUnIGRvZXMgbm90IHN1cHBvcnQgLTQiKSk7CgkJY2FzZSBWQVJJQU5UX1NTSDoKCQljYXNlIFZBUklBTlRfUExJTks6CgkJY2FzZSBWQVJJQU5UX1BVVFRZOgoJCWNhc2UgVkFSSUFOVF9UT1JUT0lTRVBMSU5LOgoJCQlzdHJ2ZWNfcHVzaChhcmdzLCAiLTQiKTsKCQl9Cgl9IGVsc2UgaWYgKGZsYWdzICYgQ09OTkVDVF9JUFY2KSB7CgkJc3dpdGNoICh2YXJpYW50KSB7CgkJY2FzZSBWQVJJQU5UX0FVVE86CgkJCUJVRygiVkFSSUFOVF9BVVRPIHBhc3NlZCB0byBwdXNoX3NzaF9vcHRpb25zIik7CgkJY2FzZSBWQVJJQU5UX1NJTVBMRToKCQkJZGllKF8oInNzaCB2YXJpYW50ICdzaW1wbGUnIGRvZXMgbm90IHN1cHBvcnQgLTYiKSk7CgkJY2FzZSBWQVJJQU5UX1NTSDoKCQljYXNlIFZBUklBTlRfUExJTks6CgkJY2FzZSBWQVJJQU5UX1BVVFRZOgoJCWNhc2UgVkFSSUFOVF9UT1JUT0lTRVBMSU5LOgoJCQlzdHJ2ZWNfcHVzaChhcmdzLCAiLTYiKTsKCQl9Cgl9CgoJaWYgKHZhcmlhbnQgPT0gVkFSSUFOVF9UT1JUT0lTRVBMSU5LKQoJCXN0cnZlY19wdXNoKGFyZ3MsICItYmF0Y2giKTsKCglpZiAocG9ydCkgewoJCXN3aXRjaCAodmFyaWFudCkgewoJCWNhc2UgVkFSSUFOVF9BVVRPOgoJCQlCVUcoIlZBUklBTlRfQVVUTyBwYXNzZWQgdG8gcHVzaF9zc2hfb3B0aW9ucyIpOwoJCWNhc2UgVkFSSUFOVF9TSU1QTEU6CgkJCWRpZShfKCJzc2ggdmFyaWFudCAnc2ltcGxlJyBkb2VzIG5vdCBzdXBwb3J0IHNldHRpbmcgcG9ydCIpKTsKCQljYXNlIFZBUklBTlRfU1NIOgoJCQlzdHJ2ZWNfcHVzaChhcmdzLCAiLXAiKTsKCQkJYnJlYWs7CgkJY2FzZSBWQVJJQU5UX1BMSU5LOgoJCWNhc2UgVkFSSUFOVF9QVVRUWToKCQljYXNlIFZBUklBTlRfVE9SVE9JU0VQTElOSzoKCQkJc3RydmVjX3B1c2goYXJncywgIi1QIik7CgkJfQoKCQlzdHJ2ZWNfcHVzaChhcmdzLCBwb3J0KTsKCX0KfQoKLyogUHJlcGFyZSBhIGNoaWxkX3Byb2Nlc3MgZm9yIHVzZSBieSBHaXQncyBTU0gtdHVubmVsZWQgdHJhbnNwb3J0LiAqLwpzdGF0aWMgdm9pZCBmaWxsX3NzaF9hcmdzKHN0cnVjdCBjaGlsZF9wcm9jZXNzICpjb25uLCBjb25zdCBjaGFyICpzc2hfaG9zdCwKCQkJICBjb25zdCBjaGFyICpwb3J0LCBlbnVtIHByb3RvY29sX3ZlcnNpb24gdmVyc2lvbiwKCQkJICBpbnQgZmxhZ3MpCnsKCWNvbnN0IGNoYXIgKnNzaDsKCWVudW0gc3NoX3ZhcmlhbnQgdmFyaWFudDsKCglpZiAobG9va3NfbGlrZV9jb21tYW5kX2xpbmVfb3B0aW9uKHNzaF9ob3N0KSkKCQlkaWUoXygic3RyYW5nZSBob3N0bmFtZSAnJXMnIGJsb2NrZWQiKSwgc3NoX2hvc3QpOwoKCXNzaCA9IGdldF9zc2hfY29tbWFuZCgpOwoJaWYgKHNzaCkgewoJCXZhcmlhbnQgPSBkZXRlcm1pbmVfc3NoX3ZhcmlhbnQoc3NoLCAxKTsKCX0gZWxzZSB7CgkJLyoKCQkgKiBHSVRfU1NIIGlzIHRoZSBuby1zaGVsbCB2ZXJzaW9uIG9mCgkJICogR0lUX1NTSF9DT01NQU5EIChhbmQgbXVzdCByZW1haW4gc28gZm9yCgkJICogaGlzdG9yaWNhbCBjb21wYXRpYmlsaXR5KS4KCQkgKi8KCQljb25uLT51c2Vfc2hlbGwgPSAwOwoKCQlzc2ggPSBnZXRlbnYoIkdJVF9TU0giKTsKCQlpZiAoIXNzaCkKCQkJc3NoID0gInNzaCI7CgkJdmFyaWFudCA9IGRldGVybWluZV9zc2hfdmFyaWFudChzc2gsIDApOwoJfQoKCWlmICh2YXJpYW50ID09IFZBUklBTlRfQVVUTykgewoJCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGRldGVjdCA9IENISUxEX1BST0NFU1NfSU5JVDsKCgkJZGV0ZWN0LnVzZV9zaGVsbCA9IGNvbm4tPnVzZV9zaGVsbDsKCQlkZXRlY3Qubm9fc3RkaW4gPSBkZXRlY3Qubm9fc3Rkb3V0ID0gZGV0ZWN0Lm5vX3N0ZGVyciA9IDE7CgoJCXN0cnZlY19wdXNoKCZkZXRlY3QuYXJncywgc3NoKTsKCQlzdHJ2ZWNfcHVzaCgmZGV0ZWN0LmFyZ3MsICItRyIpOwoJCXB1c2hfc3NoX29wdGlvbnMoJmRldGVjdC5hcmdzLCAmZGV0ZWN0LmVudiwKCQkJCSBWQVJJQU5UX1NTSCwgcG9ydCwgdmVyc2lvbiwgZmxhZ3MpOwoJCXN0cnZlY19wdXNoKCZkZXRlY3QuYXJncywgc3NoX2hvc3QpOwoKCQl2YXJpYW50ID0gcnVuX2NvbW1hbmQoJmRldGVjdCkgPyBWQVJJQU5UX1NJTVBMRSA6IFZBUklBTlRfU1NIOwoJfQoKCXN0cnZlY19wdXNoKCZjb25uLT5hcmdzLCBzc2gpOwoJcHVzaF9zc2hfb3B0aW9ucygmY29ubi0+YXJncywgJmNvbm4tPmVudiwgdmFyaWFudCwgcG9ydCwgdmVyc2lvbiwKCQkJIGZsYWdzKTsKCXN0cnZlY19wdXNoKCZjb25uLT5hcmdzLCBzc2hfaG9zdCk7Cn0KCi8qCiAqIFRoaXMgcmV0dXJucyB0aGUgZHVtbXkgY2hpbGRfcHJvY2VzcyBgbm9fZm9ya2AgaWYgdGhlIHRyYW5zcG9ydCBwcm90b2NvbAogKiBkb2VzIG5vdCBuZWVkIGZvcmsoMiksIG9yIGEgc3RydWN0IGNoaWxkX3Byb2Nlc3Mgb2JqZWN0IGlmIGl0IGRvZXMuICBPbmNlCiAqIGRvbmUsIGZpbmlzaCB0aGUgY29ubmVjdGlvbiB3aXRoIGZpbmlzaF9jb25uZWN0KCkgd2l0aCB0aGUgdmFsdWUgcmV0dXJuZWQKICogZnJvbSB0aGlzIGZ1bmN0aW9uIChpdCBpcyBzYWZlIHRvIGNhbGwgZmluaXNoX2Nvbm5lY3QoKSB3aXRoIE5VTEwgdG8KICogc3VwcG9ydCB0aGUgZm9ybWVyIGNhc2UpLgogKgogKiBJZiBpdCByZXR1cm5zLCB0aGUgY29ubmVjdCBpcyBzdWNjZXNzZnVsOyBpdCBqdXN0IGRpZXMgb24gZXJyb3JzICh0aGlzCiAqIHdpbGwgaG9wZWZ1bGx5IGJlIGNoYW5nZWQgaW4gYSBsaWJpZmljYXRpb24gZWZmb3J0LCB0byByZXR1cm4gTlVMTCB3aGVuCiAqIHRoZSBjb25uZWN0aW9uIGZhaWxlZCkuCiAqLwpzdHJ1Y3QgY2hpbGRfcHJvY2VzcyAqZ2l0X2Nvbm5lY3QoaW50IGZkWzJdLCBjb25zdCBjaGFyICp1cmwsCgkJCQkgIGNvbnN0IGNoYXIgKnByb2csIGludCBmbGFncykKewoJY2hhciAqaG9zdGFuZHBvcnQsICpwYXRoOwoJc3RydWN0IGNoaWxkX3Byb2Nlc3MgKmNvbm47CgllbnVtIHByb3RvY29sIHByb3RvY29sOwoJZW51bSBwcm90b2NvbF92ZXJzaW9uIHZlcnNpb24gPSBnZXRfcHJvdG9jb2xfdmVyc2lvbl9jb25maWcoKTsKCgkvKgoJICogTkVFRFNXT1JLOiBJZiB3ZSBhcmUgdHJ5aW5nIHRvIHVzZSBwcm90b2NvbCB2MiBhbmQgd2UgYXJlIHBsYW5uaW5nCgkgKiB0byBwZXJmb3JtIGEgcHVzaCwgdGhlbiBmYWxsYmFjayB0byB2MCBzaW5jZSB0aGUgY2xpZW50IGRvZXNuJ3Qga25vdwoJICogaG93IHRvIHB1c2ggeWV0IHVzaW5nIHYyLgoJICovCglpZiAodmVyc2lvbiA9PSBwcm90b2NvbF92MiAmJiAhc3RyY21wKCJnaXQtcmVjZWl2ZS1wYWNrIiwgcHJvZykpCgkJdmVyc2lvbiA9IHByb3RvY29sX3YwOwoKCS8qIFdpdGhvdXQgdGhpcyB3ZSBjYW5ub3QgcmVseSBvbiB3YWl0cGlkKCkgdG8gdGVsbAoJICogd2hhdCBoYXBwZW5lZCB0byBvdXIgY2hpbGRyZW4uCgkgKi8KCXNpZ25hbChTSUdDSExELCBTSUdfREZMKTsKCglwcm90b2NvbCA9IHBhcnNlX2Nvbm5lY3RfdXJsKHVybCwgJmhvc3RhbmRwb3J0LCAmcGF0aCk7CglpZiAoKGZsYWdzICYgQ09OTkVDVF9ESUFHX1VSTCkgJiYgKHByb3RvY29sICE9IFBST1RPX1NTSCkpIHsKCQlwcmludGYoIkRpYWc6IHVybD0lc1xuIiwgdXJsID8gdXJsIDogIk5VTEwiKTsKCQlwcmludGYoIkRpYWc6IHByb3RvY29sPSVzXG4iLCBwcm90X25hbWUocHJvdG9jb2wpKTsKCQlwcmludGYoIkRpYWc6IGhvc3RhbmRwb3J0PSVzXG4iLCBob3N0YW5kcG9ydCA/IGhvc3RhbmRwb3J0IDogIk5VTEwiKTsKCQlwcmludGYoIkRpYWc6IHBhdGg9JXNcbiIsIHBhdGggPyBwYXRoIDogIk5VTEwiKTsKCQljb25uID0gTlVMTDsKCX0gZWxzZSBpZiAocHJvdG9jb2wgPT0gUFJPVE9fR0lUKSB7CgkJY29ubiA9IGdpdF9jb25uZWN0X2dpdChmZCwgaG9zdGFuZHBvcnQsIHBhdGgsIHByb2csIHZlcnNpb24sIGZsYWdzKTsKCQljb25uLT50cmFjZTJfY2hpbGRfY2xhc3MgPSAidHJhbnNwb3J0L2dpdCI7Cgl9IGVsc2UgewoJCXN0cnVjdCBzdHJidWYgY21kID0gU1RSQlVGX0lOSVQ7CgkJY29uc3QgY2hhciAqY29uc3QgKnZhcjsKCgkJY29ubiA9IHhtYWxsb2Moc2l6ZW9mKCpjb25uKSk7CgkJY2hpbGRfcHJvY2Vzc19pbml0KGNvbm4pOwoKCQlpZiAobG9va3NfbGlrZV9jb21tYW5kX2xpbmVfb3B0aW9uKHBhdGgpKQoJCQlkaWUoXygic3RyYW5nZSBwYXRobmFtZSAnJXMnIGJsb2NrZWQiKSwgcGF0aCk7CgoJCXN0cmJ1Zl9hZGRzdHIoJmNtZCwgcHJvZyk7CgkJc3RyYnVmX2FkZGNoKCZjbWQsICcgJyk7CgkJc3FfcXVvdGVfYnVmKCZjbWQsIHBhdGgpOwoKCQkvKiByZW1vdmUgcmVwby1sb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgZW52aXJvbm1lbnQgKi8KCQlmb3IgKHZhciA9IGxvY2FsX3JlcG9fZW52OyAqdmFyOyB2YXIrKykKCQkJc3RydmVjX3B1c2goJmNvbm4tPmVudiwgKnZhcik7CgoJCWNvbm4tPnVzZV9zaGVsbCA9IDE7CgkJY29ubi0+aW4gPSBjb25uLT5vdXQgPSAtMTsKCQlpZiAocHJvdG9jb2wgPT0gUFJPVE9fU1NIKSB7CgkJCWNoYXIgKnNzaF9ob3N0ID0gaG9zdGFuZHBvcnQ7CgkJCWNvbnN0IGNoYXIgKnBvcnQgPSBOVUxMOwoJCQl0cmFuc3BvcnRfY2hlY2tfYWxsb3dlZCgic3NoIik7CgkJCWdldF9ob3N0X2FuZF9wb3J0KCZzc2hfaG9zdCwgJnBvcnQpOwoKCQkJaWYgKCFwb3J0KQoJCQkJcG9ydCA9IGdldF9wb3J0KHNzaF9ob3N0KTsKCgkJCWlmIChmbGFncyAmIENPTk5FQ1RfRElBR19VUkwpIHsKCQkJCXByaW50ZigiRGlhZzogdXJsPSVzXG4iLCB1cmwgPyB1cmwgOiAiTlVMTCIpOwoJCQkJcHJpbnRmKCJEaWFnOiBwcm90b2NvbD0lc1xuIiwgcHJvdF9uYW1lKHByb3RvY29sKSk7CgkJCQlwcmludGYoIkRpYWc6IHVzZXJhbmRob3N0PSVzXG4iLCBzc2hfaG9zdCA/IHNzaF9ob3N0IDogIk5VTEwiKTsKCQkJCXByaW50ZigiRGlhZzogcG9ydD0lc1xuIiwgcG9ydCA/IHBvcnQgOiAiTk9ORSIpOwoJCQkJcHJpbnRmKCJEaWFnOiBwYXRoPSVzXG4iLCBwYXRoID8gcGF0aCA6ICJOVUxMIik7CgoJCQkJZnJlZShob3N0YW5kcG9ydCk7CgkJCQlmcmVlKHBhdGgpOwoJCQkJZnJlZShjb25uKTsKCQkJCXN0cmJ1Zl9yZWxlYXNlKCZjbWQpOwoJCQkJcmV0dXJuIE5VTEw7CgkJCX0KCQkJY29ubi0+dHJhY2UyX2NoaWxkX2NsYXNzID0gInRyYW5zcG9ydC9zc2giOwoJCQlmaWxsX3NzaF9hcmdzKGNvbm4sIHNzaF9ob3N0LCBwb3J0LCB2ZXJzaW9uLCBmbGFncyk7CgkJfSBlbHNlIHsKCQkJdHJhbnNwb3J0X2NoZWNrX2FsbG93ZWQoImZpbGUiKTsKCQkJY29ubi0+dHJhY2UyX2NoaWxkX2NsYXNzID0gInRyYW5zcG9ydC9maWxlIjsKCQkJaWYgKHZlcnNpb24gPiAwKSB7CgkJCQlzdHJ2ZWNfcHVzaGYoJmNvbm4tPmVudiwKCQkJCQkgICAgIEdJVF9QUk9UT0NPTF9FTlZJUk9OTUVOVCAiPXZlcnNpb249JWQiLAoJCQkJCSAgICAgdmVyc2lvbik7CgkJCX0KCQl9CgkJc3RydmVjX3B1c2goJmNvbm4tPmFyZ3MsIGNtZC5idWYpOwoKCQlpZiAoc3RhcnRfY29tbWFuZChjb25uKSkKCQkJZGllKF8oInVuYWJsZSB0byBmb3JrIikpOwoKCQlmZFswXSA9IGNvbm4tPm91dDsgLyogcmVhZCBmcm9tIGNoaWxkJ3Mgc3Rkb3V0ICovCgkJZmRbMV0gPSBjb25uLT5pbjsgIC8qIHdyaXRlIHRvIGNoaWxkJ3Mgc3RkaW4gKi8KCQlzdHJidWZfcmVsZWFzZSgmY21kKTsKCX0KCWZyZWUoaG9zdGFuZHBvcnQpOwoJZnJlZShwYXRoKTsKCXJldHVybiBjb25uOwp9CgppbnQgZmluaXNoX2Nvbm5lY3Qoc3RydWN0IGNoaWxkX3Byb2Nlc3MgKmNvbm4pCnsKCWludCBjb2RlOwoJaWYgKCFjb25uIHx8IGdpdF9jb25uZWN0aW9uX2lzX3NvY2tldChjb25uKSkKCQlyZXR1cm4gMDsKCgljb2RlID0gZmluaXNoX2NvbW1hbmQoY29ubik7CglmcmVlKGNvbm4pOwoJcmV0dXJuIGNvZGU7Cn0K",
    "text": "#include \"git-compat-util.h\"\n#include \"cache.h\"\n#include \"config.h\"\n#include \"hex.h\"\n#include \"pkt-line.h\"\n#include \"quote.h\"\n#include \"refs.h\"\n#include \"run-command.h\"\n#include \"remote.h\"\n#include \"connect.h\"\n#include \"url.h\"\n#include \"string-list.h\"\n#include \"oid-array.h\"\n#include \"transport.h\"\n#include \"strbuf.h\"\n#include \"version.h\"\n#include \"protocol.h\"\n#include \"alias.h\"\n#include \"bundle-uri.h\"\n\nstatic char *server_capabilities_v1;\nstatic struct strvec server_capabilities_v2 = STRVEC_INIT;\nstatic const char *next_server_feature_value(const char *feature, int *len, int *offset);\n\nstatic int check_ref(const char *name, unsigned int flags)\n{\n\tif (!flags)\n\t\treturn 1;\n\n\tif (!skip_prefix(name, \"refs/\", &name))\n\t\treturn 0;\n\n\t/* REF_NORMAL means that we don't want the magic fake tag refs */\n\tif ((flags & REF_NORMAL) && check_refname_format(name,\n\t\t\t\t\t\t\t REFNAME_ALLOW_ONELEVEL))\n\t\treturn 0;\n\n\t/* REF_HEADS means that we want regular branch heads */\n\tif ((flags & REF_HEADS) && starts_with(name, \"heads/\"))\n\t\treturn 1;\n\n\t/* REF_TAGS means that we want tags */\n\tif ((flags & REF_TAGS) && starts_with(name, \"tags/\"))\n\t\treturn 1;\n\n\t/* All type bits clear means that we are ok with anything */\n\treturn !(flags & ~REF_NORMAL);\n}\n\nint check_ref_type(const struct ref *ref, int flags)\n{\n\treturn check_ref(ref->name, flags);\n}\n\nstatic NORETURN void die_initial_contact(int unexpected)\n{\n\t/*\n\t * A hang-up after seeing some response from the other end\n\t * means that it is unexpected, as we know the other end is\n\t * willing to talk to us.  A hang-up before seeing any\n\t * response does not necessarily mean an ACL problem, though.\n\t */\n\tif (unexpected)\n\t\tdie(_(\"the remote end hung up upon initial contact\"));\n\telse\n\t\tdie(_(\"Could not read from remote repository.\\n\\n\"\n\t\t      \"Please make sure you have the correct access rights\\n\"\n\t\t      \"and the repository exists.\"));\n}\n\n/* Checks if the server supports the capability 'c' */\nint server_supports_v2(const char *c)\n{\n\tint i;\n\n\tfor (i = 0; i < server_capabilities_v2.nr; i++) {\n\t\tconst char *out;\n\t\tif (skip_prefix(server_capabilities_v2.v[i], c, &out) &&\n\t\t    (!*out || *out == '='))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid ensure_server_supports_v2(const char *c)\n{\n\tif (!server_supports_v2(c))\n\t\tdie(_(\"server doesn't support '%s'\"), c);\n}\n\nint server_feature_v2(const char *c, const char **v)\n{\n\tint i;\n\n\tfor (i = 0; i < server_capabilities_v2.nr; i++) {\n\t\tconst char *out;\n\t\tif (skip_prefix(server_capabilities_v2.v[i], c, &out) &&\n\t\t    (*out == '=')) {\n\t\t\t*v = out + 1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint server_supports_feature(const char *c, const char *feature,\n\t\t\t    int die_on_error)\n{\n\tint i;\n\n\tfor (i = 0; i < server_capabilities_v2.nr; i++) {\n\t\tconst char *out;\n\t\tif (skip_prefix(server_capabilities_v2.v[i], c, &out) &&\n\t\t    (!*out || *(out++) == '=')) {\n\t\t\tif (parse_feature_request(out, feature))\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (die_on_error)\n\t\tdie(_(\"server doesn't support feature '%s'\"), feature);\n\n\treturn 0;\n}\n\nstatic void process_capabilities_v2(struct packet_reader *reader)\n{\n\twhile (packet_reader_read(reader) == PACKET_READ_NORMAL)\n\t\tstrvec_push(&server_capabilities_v2, reader->line);\n\n\tif (reader->status != PACKET_READ_FLUSH)\n\t\tdie(_(\"expected flush after capabilities\"));\n}\n\nenum protocol_version discover_version(struct packet_reader *reader)\n{\n\tenum protocol_version version = protocol_unknown_version;\n\n\t/*\n\t * Peek the first line of the server's response to\n\t * determine the protocol version the server is speaking.\n\t */\n\tswitch (packet_reader_peek(reader)) {\n\tcase PACKET_READ_EOF:\n\t\tdie_initial_contact(0);\n\tcase PACKET_READ_FLUSH:\n\tcase PACKET_READ_DELIM:\n\tcase PACKET_READ_RESPONSE_END:\n\t\tversion = protocol_v0;\n\t\tbreak;\n\tcase PACKET_READ_NORMAL:\n\t\tversion = determine_protocol_version_client(reader->line);\n\t\tbreak;\n\t}\n\n\tswitch (version) {\n\tcase protocol_v2:\n\t\tprocess_capabilities_v2(reader);\n\t\tbreak;\n\tcase protocol_v1:\n\t\t/* Read the peeked version line */\n\t\tpacket_reader_read(reader);\n\t\tbreak;\n\tcase protocol_v0:\n\t\tbreak;\n\tcase protocol_unknown_version:\n\t\tBUG(\"unknown protocol version\");\n\t}\n\n\ttrace2_data_intmax(\"transfer\", NULL, \"negotiated-version\", version);\n\n\treturn version;\n}\n\nstatic void parse_one_symref_info(struct string_list *symref, const char *val, int len)\n{\n\tchar *sym, *target;\n\tstruct string_list_item *item;\n\n\tif (!len)\n\t\treturn; /* just \"symref\" */\n\t/* e.g. \"symref=HEAD:refs/heads/master\" */\n\tsym = xmemdupz(val, len);\n\ttarget = strchr(sym, ':');\n\tif (!target)\n\t\t/* just \"symref=something\" */\n\t\tgoto reject;\n\t*(target++) = '\\0';\n\tif (check_refname_format(sym, REFNAME_ALLOW_ONELEVEL) ||\n\t    check_refname_format(target, REFNAME_ALLOW_ONELEVEL))\n\t\t/* \"symref=bogus:pair */\n\t\tgoto reject;\n\titem = string_list_append_nodup(symref, sym);\n\titem->util = target;\n\treturn;\nreject:\n\tfree(sym);\n\treturn;\n}\n\nstatic void annotate_refs_with_symref_info(struct ref *ref)\n{\n\tstruct string_list symref = STRING_LIST_INIT_DUP;\n\tint offset = 0;\n\n\twhile (1) {\n\t\tint len;\n\t\tconst char *val;\n\n\t\tval = next_server_feature_value(\"symref\", &len, &offset);\n\t\tif (!val)\n\t\t\tbreak;\n\t\tparse_one_symref_info(&symref, val, len);\n\t}\n\tstring_list_sort(&symref);\n\n\tfor (; ref; ref = ref->next) {\n\t\tstruct string_list_item *item;\n\t\titem = string_list_lookup(&symref, ref->name);\n\t\tif (!item)\n\t\t\tcontinue;\n\t\tref->symref = xstrdup((char *)item->util);\n\t}\n\tstring_list_clear(&symref, 0);\n}\n\nstatic void process_capabilities(struct packet_reader *reader, int *linelen)\n{\n\tconst char *feat_val;\n\tint feat_len;\n\tconst char *line = reader->line;\n\tint nul_location = strlen(line);\n\tif (nul_location == *linelen)\n\t\treturn;\n\tserver_capabilities_v1 = xstrdup(line + nul_location + 1);\n\t*linelen = nul_location;\n\n\tfeat_val = server_feature_value(\"object-format\", &feat_len);\n\tif (feat_val) {\n\t\tchar *hash_name = xstrndup(feat_val, feat_len);\n\t\tint hash_algo = hash_algo_by_name(hash_name);\n\t\tif (hash_algo != GIT_HASH_UNKNOWN)\n\t\t\treader->hash_algo = &hash_algos[hash_algo];\n\t\tfree(hash_name);\n\t} else {\n\t\treader->hash_algo = &hash_algos[GIT_HASH_SHA1];\n\t}\n}\n\nstatic int process_dummy_ref(const struct packet_reader *reader)\n{\n\tconst char *line = reader->line;\n\tstruct object_id oid;\n\tconst char *name;\n\n\tif (parse_oid_hex_algop(line, &oid, &name, reader->hash_algo))\n\t\treturn 0;\n\tif (*name != ' ')\n\t\treturn 0;\n\tname++;\n\n\treturn oideq(null_oid(), &oid) && !strcmp(name, \"capabilities^{}\");\n}\n\nstatic void check_no_capabilities(const char *line, int len)\n{\n\tif (strlen(line) != len)\n\t\twarning(_(\"ignoring capabilities after first line '%s'\"),\n\t\t\tline + strlen(line));\n}\n\nstatic int process_ref(const struct packet_reader *reader, int len,\n\t\t       struct ref ***list, unsigned int flags,\n\t\t       struct oid_array *extra_have)\n{\n\tconst char *line = reader->line;\n\tstruct object_id old_oid;\n\tconst char *name;\n\n\tif (parse_oid_hex_algop(line, &old_oid, &name, reader->hash_algo))\n\t\treturn 0;\n\tif (*name != ' ')\n\t\treturn 0;\n\tname++;\n\n\tif (extra_have && !strcmp(name, \".have\")) {\n\t\toid_array_append(extra_have, &old_oid);\n\t} else if (!strcmp(name, \"capabilities^{}\")) {\n\t\tdie(_(\"protocol error: unexpected capabilities^{}\"));\n\t} else if (check_ref(name, flags)) {\n\t\tstruct ref *ref = alloc_ref(name);\n\t\toidcpy(&ref->old_oid, &old_oid);\n\t\t**list = ref;\n\t\t*list = &ref->next;\n\t}\n\tcheck_no_capabilities(line, len);\n\treturn 1;\n}\n\nstatic int process_shallow(const struct packet_reader *reader, int len,\n\t\t\t   struct oid_array *shallow_points)\n{\n\tconst char *line = reader->line;\n\tconst char *arg;\n\tstruct object_id old_oid;\n\n\tif (!skip_prefix(line, \"shallow \", &arg))\n\t\treturn 0;\n\n\tif (get_oid_hex_algop(arg, &old_oid, reader->hash_algo))\n\t\tdie(_(\"protocol error: expected shallow sha-1, got '%s'\"), arg);\n\tif (!shallow_points)\n\t\tdie(_(\"repository on the other end cannot be shallow\"));\n\toid_array_append(shallow_points, &old_oid);\n\tcheck_no_capabilities(line, len);\n\treturn 1;\n}\n\nenum get_remote_heads_state {\n\tEXPECTING_FIRST_REF = 0,\n\tEXPECTING_REF,\n\tEXPECTING_SHALLOW,\n\tEXPECTING_DONE,\n};\n\n/*\n * Read all the refs from the other end\n */\nstruct ref **get_remote_heads(struct packet_reader *reader,\n\t\t\t      struct ref **list, unsigned int flags,\n\t\t\t      struct oid_array *extra_have,\n\t\t\t      struct oid_array *shallow_points)\n{\n\tstruct ref **orig_list = list;\n\tint len = 0;\n\tenum get_remote_heads_state state = EXPECTING_FIRST_REF;\n\n\t*list = NULL;\n\n\twhile (state != EXPECTING_DONE) {\n\t\tswitch (packet_reader_read(reader)) {\n\t\tcase PACKET_READ_EOF:\n\t\t\tdie_initial_contact(1);\n\t\tcase PACKET_READ_NORMAL:\n\t\t\tlen = reader->pktlen;\n\t\t\tbreak;\n\t\tcase PACKET_READ_FLUSH:\n\t\t\tstate = EXPECTING_DONE;\n\t\t\tbreak;\n\t\tcase PACKET_READ_DELIM:\n\t\tcase PACKET_READ_RESPONSE_END:\n\t\t\tdie(_(\"invalid packet\"));\n\t\t}\n\n\t\tswitch (state) {\n\t\tcase EXPECTING_FIRST_REF:\n\t\t\tprocess_capabilities(reader, &len);\n\t\t\tif (process_dummy_ref(reader)) {\n\t\t\t\tstate = EXPECTING_SHALLOW;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstate = EXPECTING_REF;\n\t\t\t/* fallthrough */\n\t\tcase EXPECTING_REF:\n\t\t\tif (process_ref(reader, len, &list, flags, extra_have))\n\t\t\t\tbreak;\n\t\t\tstate = EXPECTING_SHALLOW;\n\t\t\t/* fallthrough */\n\t\tcase EXPECTING_SHALLOW:\n\t\t\tif (process_shallow(reader, len, shallow_points))\n\t\t\t\tbreak;\n\t\t\tdie(_(\"protocol error: unexpected '%s'\"), reader->line);\n\t\tcase EXPECTING_DONE:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tannotate_refs_with_symref_info(*orig_list);\n\n\treturn list;\n}\n\n/* Returns 1 when a valid ref has been added to `list`, 0 otherwise */\nstatic int process_ref_v2(struct packet_reader *reader, struct ref ***list,\n\t\t\t  const char **unborn_head_target)\n{\n\tint ret = 1;\n\tint i = 0;\n\tstruct object_id old_oid;\n\tstruct ref *ref;\n\tstruct string_list line_sections = STRING_LIST_INIT_DUP;\n\tconst char *end;\n\tconst char *line = reader->line;\n\n\t/*\n\t * Ref lines have a number of fields which are space deliminated.  The\n\t * first field is the OID of the ref.  The second field is the ref\n\t * name.  Subsequent fields (symref-target and peeled) are optional and\n\t * don't have a particular order.\n\t */\n\tif (string_list_split(&line_sections, line, ' ', -1) < 2) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (!strcmp(\"unborn\", line_sections.items[i].string)) {\n\t\ti++;\n\t\tif (unborn_head_target &&\n\t\t    !strcmp(\"HEAD\", line_sections.items[i++].string)) {\n\t\t\t/*\n\t\t\t * Look for the symref target (if any). If found,\n\t\t\t * return it to the caller.\n\t\t\t */\n\t\t\tfor (; i < line_sections.nr; i++) {\n\t\t\t\tconst char *arg = line_sections.items[i].string;\n\n\t\t\t\tif (skip_prefix(arg, \"symref-target:\", &arg)) {\n\t\t\t\t\t*unborn_head_target = xstrdup(arg);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\tif (parse_oid_hex_algop(line_sections.items[i++].string, &old_oid, &end, reader->hash_algo) ||\n\t    *end) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tref = alloc_ref(line_sections.items[i++].string);\n\n\tmemcpy(ref->old_oid.hash, old_oid.hash, reader->hash_algo->rawsz);\n\t**list = ref;\n\t*list = &ref->next;\n\n\tfor (; i < line_sections.nr; i++) {\n\t\tconst char *arg = line_sections.items[i].string;\n\t\tif (skip_prefix(arg, \"symref-target:\", &arg))\n\t\t\tref->symref = xstrdup(arg);\n\n\t\tif (skip_prefix(arg, \"peeled:\", &arg)) {\n\t\t\tstruct object_id peeled_oid;\n\t\t\tchar *peeled_name;\n\t\t\tstruct ref *peeled;\n\t\t\tif (parse_oid_hex_algop(arg, &peeled_oid, &end,\n\t\t\t\t\t\treader->hash_algo) || *end) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tpeeled_name = xstrfmt(\"%s^{}\", ref->name);\n\t\t\tpeeled = alloc_ref(peeled_name);\n\n\t\t\tmemcpy(peeled->old_oid.hash, peeled_oid.hash,\n\t\t\t       reader->hash_algo->rawsz);\n\t\t\t**list = peeled;\n\t\t\t*list = &peeled->next;\n\n\t\t\tfree(peeled_name);\n\t\t}\n\t}\n\nout:\n\tstring_list_clear(&line_sections, 0);\n\treturn ret;\n}\n\nvoid check_stateless_delimiter(int stateless_rpc,\n\t\t\t      struct packet_reader *reader,\n\t\t\t      const char *error)\n{\n\tif (!stateless_rpc)\n\t\treturn; /* not in stateless mode, no delimiter expected */\n\tif (packet_reader_read(reader) != PACKET_READ_RESPONSE_END)\n\t\tdie(\"%s\", error);\n}\n\nstatic void send_capabilities(int fd_out, struct packet_reader *reader)\n{\n\tconst char *hash_name;\n\n\tif (server_supports_v2(\"agent\"))\n\t\tpacket_write_fmt(fd_out, \"agent=%s\", git_user_agent_sanitized());\n\n\tif (server_feature_v2(\"object-format\", &hash_name)) {\n\t\tint hash_algo = hash_algo_by_name(hash_name);\n\t\tif (hash_algo == GIT_HASH_UNKNOWN)\n\t\t\tdie(_(\"unknown object format '%s' specified by server\"), hash_name);\n\t\treader->hash_algo = &hash_algos[hash_algo];\n\t\tpacket_write_fmt(fd_out, \"object-format=%s\", reader->hash_algo->name);\n\t} else {\n\t\treader->hash_algo = &hash_algos[GIT_HASH_SHA1];\n\t}\n}\n\nint get_remote_bundle_uri(int fd_out, struct packet_reader *reader,\n\t\t\t  struct bundle_list *bundles, int stateless_rpc)\n{\n\tint line_nr = 1;\n\n\t/* Assert bundle-uri support */\n\tensure_server_supports_v2(\"bundle-uri\");\n\n\t/* (Re-)send capabilities */\n\tsend_capabilities(fd_out, reader);\n\n\t/* Send command */\n\tpacket_write_fmt(fd_out, \"command=bundle-uri\\n\");\n\tpacket_delim(fd_out);\n\n\tpacket_flush(fd_out);\n\n\t/* Process response from server */\n\twhile (packet_reader_read(reader) == PACKET_READ_NORMAL) {\n\t\tconst char *line = reader->line;\n\t\tline_nr++;\n\n\t\tif (!bundle_uri_parse_line(bundles, line))\n\t\t\tcontinue;\n\n\t\treturn error(_(\"error on bundle-uri response line %d: %s\"),\n\t\t\t     line_nr, line);\n\t}\n\n\tif (reader->status != PACKET_READ_FLUSH)\n\t\treturn error(_(\"expected flush after bundle-uri listing\"));\n\n\t/*\n\t * Might die(), but obscure enough that that's OK, e.g. in\n\t * serve.c we'll call BUG() on its equivalent (the\n\t * PACKET_READ_RESPONSE_END check).\n\t */\n\tcheck_stateless_delimiter(stateless_rpc, reader,\n\t\t\t\t  _(\"expected response end packet after ref listing\"));\n\n\treturn 0;\n}\n\nstruct ref **get_remote_refs(int fd_out, struct packet_reader *reader,\n\t\t\t     struct ref **list, int for_push,\n\t\t\t     struct transport_ls_refs_options *transport_options,\n\t\t\t     const struct string_list *server_options,\n\t\t\t     int stateless_rpc)\n{\n\tint i;\n\tstruct strvec *ref_prefixes = transport_options ?\n\t\t&transport_options->ref_prefixes : NULL;\n\tconst char **unborn_head_target = transport_options ?\n\t\t&transport_options->unborn_head_target : NULL;\n\t*list = NULL;\n\n\tensure_server_supports_v2(\"ls-refs\");\n\tpacket_write_fmt(fd_out, \"command=ls-refs\\n\");\n\n\t/* Send capabilities */\n\tsend_capabilities(fd_out, reader);\n\n\tif (server_options && server_options->nr) {\n\t\tensure_server_supports_v2(\"server-option\");\n\t\tfor (i = 0; i < server_options->nr; i++)\n\t\t\tpacket_write_fmt(fd_out, \"server-option=%s\",\n\t\t\t\t\t server_options->items[i].string);\n\t}\n\n\tpacket_delim(fd_out);\n\t/* When pushing we don't want to request the peeled tags */\n\tif (!for_push)\n\t\tpacket_write_fmt(fd_out, \"peel\\n\");\n\tpacket_write_fmt(fd_out, \"symrefs\\n\");\n\tif (server_supports_feature(\"ls-refs\", \"unborn\", 0))\n\t\tpacket_write_fmt(fd_out, \"unborn\\n\");\n\tfor (i = 0; ref_prefixes && i < ref_prefixes->nr; i++) {\n\t\tpacket_write_fmt(fd_out, \"ref-prefix %s\\n\",\n\t\t\t\t ref_prefixes->v[i]);\n\t}\n\tpacket_flush(fd_out);\n\n\t/* Process response from server */\n\twhile (packet_reader_read(reader) == PACKET_READ_NORMAL) {\n\t\tif (!process_ref_v2(reader, &list, unborn_head_target))\n\t\t\tdie(_(\"invalid ls-refs response: %s\"), reader->line);\n\t}\n\n\tif (reader->status != PACKET_READ_FLUSH)\n\t\tdie(_(\"expected flush after ref listing\"));\n\n\tcheck_stateless_delimiter(stateless_rpc, reader,\n\t\t\t\t  _(\"expected response end packet after ref listing\"));\n\n\treturn list;\n}\n\nconst char *parse_feature_value(const char *feature_list, const char *feature, int *lenp, int *offset)\n{\n\tint len;\n\n\tif (!feature_list)\n\t\treturn NULL;\n\n\tlen = strlen(feature);\n\tif (offset)\n\t\tfeature_list += *offset;\n\twhile (*feature_list) {\n\t\tconst char *found = strstr(feature_list, feature);\n\t\tif (!found)\n\t\t\treturn NULL;\n\t\tif (feature_list == found || isspace(found[-1])) {\n\t\t\tconst char *value = found + len;\n\t\t\t/* feature with no value (e.g., \"thin-pack\") */\n\t\t\tif (!*value || isspace(*value)) {\n\t\t\t\tif (lenp)\n\t\t\t\t\t*lenp = 0;\n\t\t\t\tif (offset)\n\t\t\t\t\t*offset = found + len - feature_list;\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\t/* feature with a value (e.g., \"agent=git/1.2.3\") */\n\t\t\telse if (*value == '=') {\n\t\t\t\tint end;\n\n\t\t\t\tvalue++;\n\t\t\t\tend = strcspn(value, \" \\t\\n\");\n\t\t\t\tif (lenp)\n\t\t\t\t\t*lenp = end;\n\t\t\t\tif (offset)\n\t\t\t\t\t*offset = value + end - feature_list;\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\t/*\n\t\t\t * otherwise we matched a substring of another feature;\n\t\t\t * keep looking\n\t\t\t */\n\t\t}\n\t\tfeature_list = found + 1;\n\t}\n\treturn NULL;\n}\n\nint server_supports_hash(const char *desired, int *feature_supported)\n{\n\tint offset = 0;\n\tint len;\n\tconst char *hash;\n\n\thash = next_server_feature_value(\"object-format\", &len, &offset);\n\tif (feature_supported)\n\t\t*feature_supported = !!hash;\n\tif (!hash) {\n\t\thash = hash_algos[GIT_HASH_SHA1].name;\n\t\tlen = strlen(hash);\n\t}\n\twhile (hash) {\n\t\tif (!xstrncmpz(desired, hash, len))\n\t\t\treturn 1;\n\n\t\thash = next_server_feature_value(\"object-format\", &len, &offset);\n\t}\n\treturn 0;\n}\n\nint parse_feature_request(const char *feature_list, const char *feature)\n{\n\treturn !!parse_feature_value(feature_list, feature, NULL, NULL);\n}\n\nstatic const char *next_server_feature_value(const char *feature, int *len, int *offset)\n{\n\treturn parse_feature_value(server_capabilities_v1, feature, len, offset);\n}\n\nconst char *server_feature_value(const char *feature, int *len)\n{\n\treturn parse_feature_value(server_capabilities_v1, feature, len, NULL);\n}\n\nint server_supports(const char *feature)\n{\n\treturn !!server_feature_value(feature, NULL);\n}\n\nenum protocol {\n\tPROTO_LOCAL = 1,\n\tPROTO_FILE,\n\tPROTO_SSH,\n\tPROTO_GIT\n};\n\nint url_is_local_not_ssh(const char *url)\n{\n\tconst char *colon = strchr(url, ':');\n\tconst char *slash = strchr(url, '/');\n\treturn !colon || (slash && slash < colon) ||\n\t\t(has_dos_drive_prefix(url) && is_valid_path(url));\n}\n\nstatic const char *prot_name(enum protocol protocol)\n{\n\tswitch (protocol) {\n\t\tcase PROTO_LOCAL:\n\t\tcase PROTO_FILE:\n\t\t\treturn \"file\";\n\t\tcase PROTO_SSH:\n\t\t\treturn \"ssh\";\n\t\tcase PROTO_GIT:\n\t\t\treturn \"git\";\n\t\tdefault:\n\t\t\treturn \"unknown protocol\";\n\t}\n}\n\nstatic enum protocol get_protocol(const char *name)\n{\n\tif (!strcmp(name, \"ssh\"))\n\t\treturn PROTO_SSH;\n\tif (!strcmp(name, \"git\"))\n\t\treturn PROTO_GIT;\n\tif (!strcmp(name, \"git+ssh\")) /* deprecated - do not use */\n\t\treturn PROTO_SSH;\n\tif (!strcmp(name, \"ssh+git\")) /* deprecated - do not use */\n\t\treturn PROTO_SSH;\n\tif (!strcmp(name, \"file\"))\n\t\treturn PROTO_FILE;\n\tdie(_(\"protocol '%s' is not supported\"), name);\n}\n\nstatic char *host_end(char **hoststart, int removebrackets)\n{\n\tchar *host = *hoststart;\n\tchar *end;\n\tchar *start = strstr(host, \"@[\");\n\tif (start)\n\t\tstart++; /* Jump over '@' */\n\telse\n\t\tstart = host;\n\tif (start[0] == '[') {\n\t\tend = strchr(start + 1, ']');\n\t\tif (end) {\n\t\t\tif (removebrackets) {\n\t\t\t\t*end = 0;\n\t\t\t\tmemmove(start, start + 1, end - start);\n\t\t\t\tend++;\n\t\t\t}\n\t\t} else\n\t\t\tend = host;\n\t} else\n\t\tend = host;\n\treturn end;\n}\n\n#define STR_(s)\t# s\n#define STR(s)\tSTR_(s)\n\nstatic void get_host_and_port(char **host, const char **port)\n{\n\tchar *colon, *end;\n\tend = host_end(host, 1);\n\tcolon = strchr(end, ':');\n\tif (colon) {\n\t\tlong portnr = strtol(colon + 1, &end, 10);\n\t\tif (end != colon + 1 && *end == '\\0' && 0 <= portnr && portnr < 65536) {\n\t\t\t*colon = 0;\n\t\t\t*port = colon + 1;\n\t\t} else if (!colon[1]) {\n\t\t\t*colon = 0;\n\t\t}\n\t}\n}\n\nstatic void enable_keepalive(int sockfd)\n{\n\tint ka = 1;\n\n\tif (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &ka, sizeof(ka)) < 0)\n\t\terror_errno(_(\"unable to set SO_KEEPALIVE on socket\"));\n}\n\n#ifndef NO_IPV6\n\nstatic const char *ai_name(const struct addrinfo *ai)\n{\n\tstatic char addr[NI_MAXHOST];\n\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, addr, sizeof(addr), NULL, 0,\n\t\t\tNI_NUMERICHOST) != 0)\n\t\txsnprintf(addr, sizeof(addr), \"(unknown)\");\n\n\treturn addr;\n}\n\n/*\n * Returns a connected socket() fd, or else die()s.\n */\nstatic int git_tcp_connect_sock(char *host, int flags)\n{\n\tstruct strbuf error_message = STRBUF_INIT;\n\tint sockfd = -1;\n\tconst char *port = STR(DEFAULT_GIT_PORT);\n\tstruct addrinfo hints, *ai0, *ai;\n\tint gai;\n\tint cnt = 0;\n\n\tget_host_and_port(&host, &port);\n\tif (!*port)\n\t\tport = \"<none>\";\n\n\tmemset(&hints, 0, sizeof(hints));\n\tif (flags & CONNECT_IPV4)\n\t\thints.ai_family = AF_INET;\n\telse if (flags & CONNECT_IPV6)\n\t\thints.ai_family = AF_INET6;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_protocol = IPPROTO_TCP;\n\n\tif (flags & CONNECT_VERBOSE)\n\t\tfprintf(stderr, _(\"Looking up %s ... \"), host);\n\n\tgai = getaddrinfo(host, port, &hints, &ai);\n\tif (gai)\n\t\tdie(_(\"unable to look up %s (port %s) (%s)\"), host, port, gai_strerror(gai));\n\n\tif (flags & CONNECT_VERBOSE)\n\t\t/* TRANSLATORS: this is the end of \"Looking up %s ... \" */\n\t\tfprintf(stderr, _(\"done.\\nConnecting to %s (port %s) ... \"), host, port);\n\n\tfor (ai0 = ai; ai; ai = ai->ai_next, cnt++) {\n\t\tsockfd = socket(ai->ai_family,\n\t\t\t\tai->ai_socktype, ai->ai_protocol);\n\t\tif ((sockfd < 0) ||\n\t\t    (connect(sockfd, ai->ai_addr, ai->ai_addrlen) < 0)) {\n\t\t\tstrbuf_addf(&error_message, \"%s[%d: %s]: errno=%s\\n\",\n\t\t\t\t    host, cnt, ai_name(ai), strerror(errno));\n\t\t\tif (0 <= sockfd)\n\t\t\t\tclose(sockfd);\n\t\t\tsockfd = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (flags & CONNECT_VERBOSE)\n\t\t\tfprintf(stderr, \"%s \", ai_name(ai));\n\t\tbreak;\n\t}\n\n\tfreeaddrinfo(ai0);\n\n\tif (sockfd < 0)\n\t\tdie(_(\"unable to connect to %s:\\n%s\"), host, error_message.buf);\n\n\tenable_keepalive(sockfd);\n\n\tif (flags & CONNECT_VERBOSE)\n\t\t/* TRANSLATORS: this is the end of \"Connecting to %s (port %s) ... \" */\n\t\tfprintf_ln(stderr, _(\"done.\"));\n\n\tstrbuf_release(&error_message);\n\n\treturn sockfd;\n}\n\n#else /* NO_IPV6 */\n\n/*\n * Returns a connected socket() fd, or else die()s.\n */\nstatic int git_tcp_connect_sock(char *host, int flags)\n{\n\tstruct strbuf error_message = STRBUF_INIT;\n\tint sockfd = -1;\n\tconst char *port = STR(DEFAULT_GIT_PORT);\n\tchar *ep;\n\tstruct hostent *he;\n\tstruct sockaddr_in sa;\n\tchar **ap;\n\tunsigned int nport;\n\tint cnt;\n\n\tget_host_and_port(&host, &port);\n\n\tif (flags & CONNECT_VERBOSE)\n\t\tfprintf(stderr, _(\"Looking up %s ... \"), host);\n\n\the = gethostbyname(host);\n\tif (!he)\n\t\tdie(_(\"unable to look up %s (%s)\"), host, hstrerror(h_errno));\n\tnport = strtoul(port, &ep, 10);\n\tif ( ep == port || *ep ) {\n\t\t/* Not numeric */\n\t\tstruct servent *se = getservbyname(port,\"tcp\");\n\t\tif ( !se )\n\t\t\tdie(_(\"unknown port %s\"), port);\n\t\tnport = se->s_port;\n\t}\n\n\tif (flags & CONNECT_VERBOSE)\n\t\t/* TRANSLATORS: this is the end of \"Looking up %s ... \" */\n\t\tfprintf(stderr, _(\"done.\\nConnecting to %s (port %s) ... \"), host, port);\n\n\tfor (cnt = 0, ap = he->h_addr_list; *ap; ap++, cnt++) {\n\t\tmemset(&sa, 0, sizeof sa);\n\t\tsa.sin_family = he->h_addrtype;\n\t\tsa.sin_port = htons(nport);\n\t\tmemcpy(&sa.sin_addr, *ap, he->h_length);\n\n\t\tsockfd = socket(he->h_addrtype, SOCK_STREAM, 0);\n\t\tif ((sockfd < 0) ||\n\t\t    connect(sockfd, (struct sockaddr *)&sa, sizeof sa) < 0) {\n\t\t\tstrbuf_addf(&error_message, \"%s[%d: %s]: errno=%s\\n\",\n\t\t\t\thost,\n\t\t\t\tcnt,\n\t\t\t\tinet_ntoa(*(struct in_addr *)&sa.sin_addr),\n\t\t\t\tstrerror(errno));\n\t\t\tif (0 <= sockfd)\n\t\t\t\tclose(sockfd);\n\t\t\tsockfd = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (flags & CONNECT_VERBOSE)\n\t\t\tfprintf(stderr, \"%s \",\n\t\t\t\tinet_ntoa(*(struct in_addr *)&sa.sin_addr));\n\t\tbreak;\n\t}\n\n\tif (sockfd < 0)\n\t\tdie(_(\"unable to connect to %s:\\n%s\"), host, error_message.buf);\n\n\tenable_keepalive(sockfd);\n\n\tif (flags & CONNECT_VERBOSE)\n\t\t/* TRANSLATORS: this is the end of \"Connecting to %s (port %s) ... \" */\n\t\tfprintf_ln(stderr, _(\"done.\"));\n\n\treturn sockfd;\n}\n\n#endif /* NO_IPV6 */\n\n\n/*\n * Dummy child_process returned by git_connect() if the transport protocol\n * does not need fork(2).\n */\nstatic struct child_process no_fork = CHILD_PROCESS_INIT;\n\nint git_connection_is_socket(struct child_process *conn)\n{\n\treturn conn == &no_fork;\n}\n\nstatic struct child_process *git_tcp_connect(int fd[2], char *host, int flags)\n{\n\tint sockfd = git_tcp_connect_sock(host, flags);\n\n\tfd[0] = sockfd;\n\tfd[1] = dup(sockfd);\n\n\treturn &no_fork;\n}\n\n\nstatic char *git_proxy_command;\n\nstatic int git_proxy_command_options(const char *var, const char *value,\n\t\tvoid *cb)\n{\n\tif (!strcmp(var, \"core.gitproxy\")) {\n\t\tconst char *for_pos;\n\t\tint matchlen = -1;\n\t\tint hostlen;\n\t\tconst char *rhost_name = cb;\n\t\tint rhost_len = strlen(rhost_name);\n\n\t\tif (git_proxy_command)\n\t\t\treturn 0;\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\t/* [core]\n\t\t * ;# matches www.kernel.org as well\n\t\t * gitproxy = netcatter-1 for kernel.org\n\t\t * gitproxy = netcatter-2 for sample.xz\n\t\t * gitproxy = netcatter-default\n\t\t */\n\t\tfor_pos = strstr(value, \" for \");\n\t\tif (!for_pos)\n\t\t\t/* matches everybody */\n\t\t\tmatchlen = strlen(value);\n\t\telse {\n\t\t\thostlen = strlen(for_pos + 5);\n\t\t\tif (rhost_len < hostlen)\n\t\t\t\tmatchlen = -1;\n\t\t\telse if (!strncmp(for_pos + 5,\n\t\t\t\t\t  rhost_name + rhost_len - hostlen,\n\t\t\t\t\t  hostlen) &&\n\t\t\t\t ((rhost_len == hostlen) ||\n\t\t\t\t  rhost_name[rhost_len - hostlen -1] == '.'))\n\t\t\t\tmatchlen = for_pos - value;\n\t\t\telse\n\t\t\t\tmatchlen = -1;\n\t\t}\n\t\tif (0 <= matchlen) {\n\t\t\t/* core.gitproxy = none for kernel.org */\n\t\t\tif (matchlen == 4 &&\n\t\t\t    !memcmp(value, \"none\", 4))\n\t\t\t\tmatchlen = 0;\n\t\t\tgit_proxy_command = xmemdupz(value, matchlen);\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn git_default_config(var, value, cb);\n}\n\nstatic int git_use_proxy(const char *host)\n{\n\tgit_proxy_command = getenv(\"GIT_PROXY_COMMAND\");\n\tgit_config(git_proxy_command_options, (void*)host);\n\treturn (git_proxy_command && *git_proxy_command);\n}\n\nstatic struct child_process *git_proxy_connect(int fd[2], char *host)\n{\n\tconst char *port = STR(DEFAULT_GIT_PORT);\n\tstruct child_process *proxy;\n\n\tget_host_and_port(&host, &port);\n\n\tif (looks_like_command_line_option(host))\n\t\tdie(_(\"strange hostname '%s' blocked\"), host);\n\tif (looks_like_command_line_option(port))\n\t\tdie(_(\"strange port '%s' blocked\"), port);\n\n\tproxy = xmalloc(sizeof(*proxy));\n\tchild_process_init(proxy);\n\tstrvec_push(&proxy->args, git_proxy_command);\n\tstrvec_push(&proxy->args, host);\n\tstrvec_push(&proxy->args, port);\n\tproxy->in = -1;\n\tproxy->out = -1;\n\tif (start_command(proxy))\n\t\tdie(_(\"cannot start proxy %s\"), git_proxy_command);\n\tfd[0] = proxy->out; /* read from proxy stdout */\n\tfd[1] = proxy->in;  /* write to proxy stdin */\n\treturn proxy;\n}\n\nstatic char *get_port(char *host)\n{\n\tchar *end;\n\tchar *p = strchr(host, ':');\n\n\tif (p) {\n\t\tlong port = strtol(p + 1, &end, 10);\n\t\tif (end != p + 1 && *end == '\\0' && 0 <= port && port < 65536) {\n\t\t\t*p = '\\0';\n\t\t\treturn p+1;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Extract protocol and relevant parts from the specified connection URL.\n * The caller must free() the returned strings.\n */\nstatic enum protocol parse_connect_url(const char *url_orig, char **ret_host,\n\t\t\t\t       char **ret_path)\n{\n\tchar *url;\n\tchar *host, *path;\n\tchar *end;\n\tint separator = '/';\n\tenum protocol protocol = PROTO_LOCAL;\n\n\tif (is_url(url_orig))\n\t\turl = url_decode(url_orig);\n\telse\n\t\turl = xstrdup(url_orig);\n\n\thost = strstr(url, \"://\");\n\tif (host) {\n\t\t*host = '\\0';\n\t\tprotocol = get_protocol(url);\n\t\thost += 3;\n\t} else {\n\t\thost = url;\n\t\tif (!url_is_local_not_ssh(url)) {\n\t\t\tprotocol = PROTO_SSH;\n\t\t\tseparator = ':';\n\t\t}\n\t}\n\n\t/*\n\t * Don't do destructive transforms as protocol code does\n\t * '[]' unwrapping in get_host_and_port()\n\t */\n\tend = host_end(&host, 0);\n\n\tif (protocol == PROTO_LOCAL)\n\t\tpath = end;\n\telse if (protocol == PROTO_FILE && *host != '/' &&\n\t\t !has_dos_drive_prefix(host) &&\n\t\t offset_1st_component(host - 2) > 1)\n\t\tpath = host - 2; /* include the leading \"//\" */\n\telse if (protocol == PROTO_FILE && has_dos_drive_prefix(end))\n\t\tpath = end; /* \"file://$(pwd)\" may be \"file://C:/projects/repo\" */\n\telse\n\t\tpath = strchr(end, separator);\n\n\tif (!path || !*path)\n\t\tdie(_(\"no path specified; see 'git help pull' for valid url syntax\"));\n\n\t/*\n\t * null-terminate hostname and point path to ~ for URL's like this:\n\t *    ssh://host.xz/~user/repo\n\t */\n\n\tend = path; /* Need to \\0 terminate host here */\n\tif (separator == ':')\n\t\tpath++; /* path starts after ':' */\n\tif (protocol == PROTO_GIT || protocol == PROTO_SSH) {\n\t\tif (path[1] == '~')\n\t\t\tpath++;\n\t}\n\n\tpath = xstrdup(path);\n\t*end = '\\0';\n\n\t*ret_host = xstrdup(host);\n\t*ret_path = path;\n\tfree(url);\n\treturn protocol;\n}\n\nstatic const char *get_ssh_command(void)\n{\n\tconst char *ssh;\n\n\tif ((ssh = getenv(\"GIT_SSH_COMMAND\")))\n\t\treturn ssh;\n\n\tif (!git_config_get_string_tmp(\"core.sshcommand\", &ssh))\n\t\treturn ssh;\n\n\treturn NULL;\n}\n\nenum ssh_variant {\n\tVARIANT_AUTO,\n\tVARIANT_SIMPLE,\n\tVARIANT_SSH,\n\tVARIANT_PLINK,\n\tVARIANT_PUTTY,\n\tVARIANT_TORTOISEPLINK,\n};\n\nstatic void override_ssh_variant(enum ssh_variant *ssh_variant)\n{\n\tconst char *variant = getenv(\"GIT_SSH_VARIANT\");\n\n\tif (!variant && git_config_get_string_tmp(\"ssh.variant\", &variant))\n\t\treturn;\n\n\tif (!strcmp(variant, \"auto\"))\n\t\t*ssh_variant = VARIANT_AUTO;\n\telse if (!strcmp(variant, \"plink\"))\n\t\t*ssh_variant = VARIANT_PLINK;\n\telse if (!strcmp(variant, \"putty\"))\n\t\t*ssh_variant = VARIANT_PUTTY;\n\telse if (!strcmp(variant, \"tortoiseplink\"))\n\t\t*ssh_variant = VARIANT_TORTOISEPLINK;\n\telse if (!strcmp(variant, \"simple\"))\n\t\t*ssh_variant = VARIANT_SIMPLE;\n\telse\n\t\t*ssh_variant = VARIANT_SSH;\n}\n\nstatic enum ssh_variant determine_ssh_variant(const char *ssh_command,\n\t\t\t\t\t      int is_cmdline)\n{\n\tenum ssh_variant ssh_variant = VARIANT_AUTO;\n\tconst char *variant;\n\tchar *p = NULL;\n\n\toverride_ssh_variant(&ssh_variant);\n\n\tif (ssh_variant != VARIANT_AUTO)\n\t\treturn ssh_variant;\n\n\tif (!is_cmdline) {\n\t\tp = xstrdup(ssh_command);\n\t\tvariant = basename(p);\n\t} else {\n\t\tconst char **ssh_argv;\n\n\t\tp = xstrdup(ssh_command);\n\t\tif (split_cmdline(p, &ssh_argv) > 0) {\n\t\t\tvariant = basename((char *)ssh_argv[0]);\n\t\t\t/*\n\t\t\t * At this point, variant points into the buffer\n\t\t\t * referenced by p, hence we do not need ssh_argv\n\t\t\t * any longer.\n\t\t\t */\n\t\t\tfree(ssh_argv);\n\t\t} else {\n\t\t\tfree(p);\n\t\t\treturn ssh_variant;\n\t\t}\n\t}\n\n\tif (!strcasecmp(variant, \"ssh\") ||\n\t    !strcasecmp(variant, \"ssh.exe\"))\n\t\tssh_variant = VARIANT_SSH;\n\telse if (!strcasecmp(variant, \"plink\") ||\n\t\t !strcasecmp(variant, \"plink.exe\"))\n\t\tssh_variant = VARIANT_PLINK;\n\telse if (!strcasecmp(variant, \"tortoiseplink\") ||\n\t\t !strcasecmp(variant, \"tortoiseplink.exe\"))\n\t\tssh_variant = VARIANT_TORTOISEPLINK;\n\n\tfree(p);\n\treturn ssh_variant;\n}\n\n/*\n * Open a connection using Git's native protocol.\n *\n * The caller is responsible for freeing hostandport, but this function may\n * modify it (for example, to truncate it to remove the port part).\n */\nstatic struct child_process *git_connect_git(int fd[2], char *hostandport,\n\t\t\t\t\t     const char *path, const char *prog,\n\t\t\t\t\t     enum protocol_version version,\n\t\t\t\t\t     int flags)\n{\n\tstruct child_process *conn;\n\tstruct strbuf request = STRBUF_INIT;\n\t/*\n\t * Set up virtual host information based on where we will\n\t * connect, unless the user has overridden us in\n\t * the environment.\n\t */\n\tchar *target_host = getenv(\"GIT_OVERRIDE_VIRTUAL_HOST\");\n\tif (target_host)\n\t\ttarget_host = xstrdup(target_host);\n\telse\n\t\ttarget_host = xstrdup(hostandport);\n\n\ttransport_check_allowed(\"git\");\n\tif (strchr(target_host, '\\n') || strchr(path, '\\n'))\n\t\tdie(_(\"newline is forbidden in git:// hosts and repo paths\"));\n\n\t/*\n\t * These underlying connection commands die() if they\n\t * cannot connect.\n\t */\n\tif (git_use_proxy(hostandport))\n\t\tconn = git_proxy_connect(fd, hostandport);\n\telse\n\t\tconn = git_tcp_connect(fd, hostandport, flags);\n\t/*\n\t * Separate original protocol components prog and path\n\t * from extended host header with a NUL byte.\n\t *\n\t * Note: Do not add any other headers here!  Doing so\n\t * will cause older git-daemon servers to crash.\n\t */\n\tstrbuf_addf(&request,\n\t\t    \"%s %s%chost=%s%c\",\n\t\t    prog, path, 0,\n\t\t    target_host, 0);\n\n\t/* If using a new version put that stuff here after a second null byte */\n\tif (version > 0) {\n\t\tstrbuf_addch(&request, '\\0');\n\t\tstrbuf_addf(&request, \"version=%d%c\",\n\t\t\t    version, '\\0');\n\t}\n\n\tpacket_write(fd[1], request.buf, request.len);\n\n\tfree(target_host);\n\tstrbuf_release(&request);\n\treturn conn;\n}\n\n/*\n * Append the appropriate environment variables to `env` and options to\n * `args` for running ssh in Git's SSH-tunneled transport.\n */\nstatic void push_ssh_options(struct strvec *args, struct strvec *env,\n\t\t\t     enum ssh_variant variant, const char *port,\n\t\t\t     enum protocol_version version, int flags)\n{\n\tif (variant == VARIANT_SSH &&\n\t    version > 0) {\n\t\tstrvec_push(args, \"-o\");\n\t\tstrvec_push(args, \"SendEnv=\" GIT_PROTOCOL_ENVIRONMENT);\n\t\tstrvec_pushf(env, GIT_PROTOCOL_ENVIRONMENT \"=version=%d\",\n\t\t\t     version);\n\t}\n\n\tif (flags & CONNECT_IPV4) {\n\t\tswitch (variant) {\n\t\tcase VARIANT_AUTO:\n\t\t\tBUG(\"VARIANT_AUTO passed to push_ssh_options\");\n\t\tcase VARIANT_SIMPLE:\n\t\t\tdie(_(\"ssh variant 'simple' does not support -4\"));\n\t\tcase VARIANT_SSH:\n\t\tcase VARIANT_PLINK:\n\t\tcase VARIANT_PUTTY:\n\t\tcase VARIANT_TORTOISEPLINK:\n\t\t\tstrvec_push(args, \"-4\");\n\t\t}\n\t} else if (flags & CONNECT_IPV6) {\n\t\tswitch (variant) {\n\t\tcase VARIANT_AUTO:\n\t\t\tBUG(\"VARIANT_AUTO passed to push_ssh_options\");\n\t\tcase VARIANT_SIMPLE:\n\t\t\tdie(_(\"ssh variant 'simple' does not support -6\"));\n\t\tcase VARIANT_SSH:\n\t\tcase VARIANT_PLINK:\n\t\tcase VARIANT_PUTTY:\n\t\tcase VARIANT_TORTOISEPLINK:\n\t\t\tstrvec_push(args, \"-6\");\n\t\t}\n\t}\n\n\tif (variant == VARIANT_TORTOISEPLINK)\n\t\tstrvec_push(args, \"-batch\");\n\n\tif (port) {\n\t\tswitch (variant) {\n\t\tcase VARIANT_AUTO:\n\t\t\tBUG(\"VARIANT_AUTO passed to push_ssh_options\");\n\t\tcase VARIANT_SIMPLE:\n\t\t\tdie(_(\"ssh variant 'simple' does not support setting port\"));\n\t\tcase VARIANT_SSH:\n\t\t\tstrvec_push(args, \"-p\");\n\t\t\tbreak;\n\t\tcase VARIANT_PLINK:\n\t\tcase VARIANT_PUTTY:\n\t\tcase VARIANT_TORTOISEPLINK:\n\t\t\tstrvec_push(args, \"-P\");\n\t\t}\n\n\t\tstrvec_push(args, port);\n\t}\n}\n\n/* Prepare a child_process for use by Git's SSH-tunneled transport. */\nstatic void fill_ssh_args(struct child_process *conn, const char *ssh_host,\n\t\t\t  const char *port, enum protocol_version version,\n\t\t\t  int flags)\n{\n\tconst char *ssh;\n\tenum ssh_variant variant;\n\n\tif (looks_like_command_line_option(ssh_host))\n\t\tdie(_(\"strange hostname '%s' blocked\"), ssh_host);\n\n\tssh = get_ssh_command();\n\tif (ssh) {\n\t\tvariant = determine_ssh_variant(ssh, 1);\n\t} else {\n\t\t/*\n\t\t * GIT_SSH is the no-shell version of\n\t\t * GIT_SSH_COMMAND (and must remain so for\n\t\t * historical compatibility).\n\t\t */\n\t\tconn->use_shell = 0;\n\n\t\tssh = getenv(\"GIT_SSH\");\n\t\tif (!ssh)\n\t\t\tssh = \"ssh\";\n\t\tvariant = determine_ssh_variant(ssh, 0);\n\t}\n\n\tif (variant == VARIANT_AUTO) {\n\t\tstruct child_process detect = CHILD_PROCESS_INIT;\n\n\t\tdetect.use_shell = conn->use_shell;\n\t\tdetect.no_stdin = detect.no_stdout = detect.no_stderr = 1;\n\n\t\tstrvec_push(&detect.args, ssh);\n\t\tstrvec_push(&detect.args, \"-G\");\n\t\tpush_ssh_options(&detect.args, &detect.env,\n\t\t\t\t VARIANT_SSH, port, version, flags);\n\t\tstrvec_push(&detect.args, ssh_host);\n\n\t\tvariant = run_command(&detect) ? VARIANT_SIMPLE : VARIANT_SSH;\n\t}\n\n\tstrvec_push(&conn->args, ssh);\n\tpush_ssh_options(&conn->args, &conn->env, variant, port, version,\n\t\t\t flags);\n\tstrvec_push(&conn->args, ssh_host);\n}\n\n/*\n * This returns the dummy child_process `no_fork` if the transport protocol\n * does not need fork(2), or a struct child_process object if it does.  Once\n * done, finish the connection with finish_connect() with the value returned\n * from this function (it is safe to call finish_connect() with NULL to\n * support the former case).\n *\n * If it returns, the connect is successful; it just dies on errors (this\n * will hopefully be changed in a libification effort, to return NULL when\n * the connection failed).\n */\nstruct child_process *git_connect(int fd[2], const char *url,\n\t\t\t\t  const char *prog, int flags)\n{\n\tchar *hostandport, *path;\n\tstruct child_process *conn;\n\tenum protocol protocol;\n\tenum protocol_version version = get_protocol_version_config();\n\n\t/*\n\t * NEEDSWORK: If we are trying to use protocol v2 and we are planning\n\t * to perform a push, then fallback to v0 since the client doesn't know\n\t * how to push yet using v2.\n\t */\n\tif (version == protocol_v2 && !strcmp(\"git-receive-pack\", prog))\n\t\tversion = protocol_v0;\n\n\t/* Without this we cannot rely on waitpid() to tell\n\t * what happened to our children.\n\t */\n\tsignal(SIGCHLD, SIG_DFL);\n\n\tprotocol = parse_connect_url(url, &hostandport, &path);\n\tif ((flags & CONNECT_DIAG_URL) && (protocol != PROTO_SSH)) {\n\t\tprintf(\"Diag: url=%s\\n\", url ? url : \"NULL\");\n\t\tprintf(\"Diag: protocol=%s\\n\", prot_name(protocol));\n\t\tprintf(\"Diag: hostandport=%s\\n\", hostandport ? hostandport : \"NULL\");\n\t\tprintf(\"Diag: path=%s\\n\", path ? path : \"NULL\");\n\t\tconn = NULL;\n\t} else if (protocol == PROTO_GIT) {\n\t\tconn = git_connect_git(fd, hostandport, path, prog, version, flags);\n\t\tconn->trace2_child_class = \"transport/git\";\n\t} else {\n\t\tstruct strbuf cmd = STRBUF_INIT;\n\t\tconst char *const *var;\n\n\t\tconn = xmalloc(sizeof(*conn));\n\t\tchild_process_init(conn);\n\n\t\tif (looks_like_command_line_option(path))\n\t\t\tdie(_(\"strange pathname '%s' blocked\"), path);\n\n\t\tstrbuf_addstr(&cmd, prog);\n\t\tstrbuf_addch(&cmd, ' ');\n\t\tsq_quote_buf(&cmd, path);\n\n\t\t/* remove repo-local variables from the environment */\n\t\tfor (var = local_repo_env; *var; var++)\n\t\t\tstrvec_push(&conn->env, *var);\n\n\t\tconn->use_shell = 1;\n\t\tconn->in = conn->out = -1;\n\t\tif (protocol == PROTO_SSH) {\n\t\t\tchar *ssh_host = hostandport;\n\t\t\tconst char *port = NULL;\n\t\t\ttransport_check_allowed(\"ssh\");\n\t\t\tget_host_and_port(&ssh_host, &port);\n\n\t\t\tif (!port)\n\t\t\t\tport = get_port(ssh_host);\n\n\t\t\tif (flags & CONNECT_DIAG_URL) {\n\t\t\t\tprintf(\"Diag: url=%s\\n\", url ? url : \"NULL\");\n\t\t\t\tprintf(\"Diag: protocol=%s\\n\", prot_name(protocol));\n\t\t\t\tprintf(\"Diag: userandhost=%s\\n\", ssh_host ? ssh_host : \"NULL\");\n\t\t\t\tprintf(\"Diag: port=%s\\n\", port ? port : \"NONE\");\n\t\t\t\tprintf(\"Diag: path=%s\\n\", path ? path : \"NULL\");\n\n\t\t\t\tfree(hostandport);\n\t\t\t\tfree(path);\n\t\t\t\tfree(conn);\n\t\t\t\tstrbuf_release(&cmd);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tconn->trace2_child_class = \"transport/ssh\";\n\t\t\tfill_ssh_args(conn, ssh_host, port, version, flags);\n\t\t} else {\n\t\t\ttransport_check_allowed(\"file\");\n\t\t\tconn->trace2_child_class = \"transport/file\";\n\t\t\tif (version > 0) {\n\t\t\t\tstrvec_pushf(&conn->env,\n\t\t\t\t\t     GIT_PROTOCOL_ENVIRONMENT \"=version=%d\",\n\t\t\t\t\t     version);\n\t\t\t}\n\t\t}\n\t\tstrvec_push(&conn->args, cmd.buf);\n\n\t\tif (start_command(conn))\n\t\t\tdie(_(\"unable to fork\"));\n\n\t\tfd[0] = conn->out; /* read from child's stdout */\n\t\tfd[1] = conn->in;  /* write to child's stdin */\n\t\tstrbuf_release(&cmd);\n\t}\n\tfree(hostandport);\n\tfree(path);\n\treturn conn;\n}\n\nint finish_connect(struct child_process *conn)\n{\n\tint code;\n\tif (!conn || git_connection_is_socket(conn))\n\t\treturn 0;\n\n\tcode = finish_command(conn);\n\tfree(conn);\n\treturn code;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "000865bc33e3177c4e0d442deeaa6913ee87d6d6",
  "sha1_ok": true,
  "size": 38040
}
