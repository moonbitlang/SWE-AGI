{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjaGVja291dC5oIgojaW5jbHVkZSAiY29uZmlnLmgiCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJkaXIuaCIKI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCIKI2luY2x1ZGUgImFyZ3YtYXJyYXkuaCIKI2luY2x1ZGUgImJyYW5jaC5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAicnVuLWNvbW1hbmQuaCIKI2luY2x1ZGUgInNpZ2NoYWluLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJ1dGY4LmgiCiNpbmNsdWRlICJ3b3JrdHJlZS5oIgoKc3RhdGljIGNvbnN0IGNoYXIgKiBjb25zdCB3b3JrdHJlZV91c2FnZVtdID0gewoJTl8oImdpdCB3b3JrdHJlZSBhZGQgWzxvcHRpb25zPl0gPHBhdGg+IFs8YnJhbmNoPl0iKSwKCU5fKCJnaXQgd29ya3RyZWUgbGlzdCBbPG9wdGlvbnM+XSIpLAoJTl8oImdpdCB3b3JrdHJlZSBsb2NrIFs8b3B0aW9ucz5dIDxwYXRoPiIpLAoJTl8oImdpdCB3b3JrdHJlZSBwcnVuZSBbPG9wdGlvbnM+XSIpLAoJTl8oImdpdCB3b3JrdHJlZSB1bmxvY2sgPHBhdGg+IiksCglOVUxMCn07CgpzdHJ1Y3QgYWRkX29wdHMgewoJaW50IGZvcmNlOwoJaW50IGRldGFjaDsKCWludCBjaGVja291dDsKCWludCBrZWVwX2xvY2tlZDsKCWNvbnN0IGNoYXIgKm5ld19icmFuY2g7CglpbnQgZm9yY2VfbmV3X2JyYW5jaDsKfTsKCnN0YXRpYyBpbnQgc2hvd19vbmx5OwpzdGF0aWMgaW50IHZlcmJvc2U7CnN0YXRpYyBpbnQgZ3Vlc3NfcmVtb3RlOwpzdGF0aWMgdGltZXN0YW1wX3QgZXhwaXJlOwoKc3RhdGljIGludCBnaXRfd29ya3RyZWVfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmNiKQp7CglpZiAoIXN0cmNtcCh2YXIsICJ3b3JrdHJlZS5ndWVzc3JlbW90ZSIpKSB7CgkJZ3Vlc3NfcmVtb3RlID0gZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoKCXJldHVybiBnaXRfZGVmYXVsdF9jb25maWcodmFyLCB2YWx1ZSwgY2IpOwp9CgpzdGF0aWMgaW50IHBydW5lX3dvcmt0cmVlKGNvbnN0IGNoYXIgKmlkLCBzdHJ1Y3Qgc3RyYnVmICpyZWFzb24pCnsKCXN0cnVjdCBzdGF0IHN0OwoJY2hhciAqcGF0aDsKCWludCBmZDsKCXNpemVfdCBsZW47Cglzc2l6ZV90IHJlYWRfcmVzdWx0OwoKCWlmICghaXNfZGlyZWN0b3J5KGdpdF9wYXRoKCJ3b3JrdHJlZXMvJXMiLCBpZCkpKSB7CgkJc3RyYnVmX2FkZGYocmVhc29uLCBfKCJSZW1vdmluZyB3b3JrdHJlZXMvJXM6IG5vdCBhIHZhbGlkIGRpcmVjdG9yeSIpLCBpZCk7CgkJcmV0dXJuIDE7Cgl9CglpZiAoZmlsZV9leGlzdHMoZ2l0X3BhdGgoIndvcmt0cmVlcy8lcy9sb2NrZWQiLCBpZCkpKQoJCXJldHVybiAwOwoJaWYgKHN0YXQoZ2l0X3BhdGgoIndvcmt0cmVlcy8lcy9naXRkaXIiLCBpZCksICZzdCkpIHsKCQlzdHJidWZfYWRkZihyZWFzb24sIF8oIlJlbW92aW5nIHdvcmt0cmVlcy8lczogZ2l0ZGlyIGZpbGUgZG9lcyBub3QgZXhpc3QiKSwgaWQpOwoJCXJldHVybiAxOwoJfQoJZmQgPSBvcGVuKGdpdF9wYXRoKCJ3b3JrdHJlZXMvJXMvZ2l0ZGlyIiwgaWQpLCBPX1JET05MWSk7CglpZiAoZmQgPCAwKSB7CgkJc3RyYnVmX2FkZGYocmVhc29uLCBfKCJSZW1vdmluZyB3b3JrdHJlZXMvJXM6IHVuYWJsZSB0byByZWFkIGdpdGRpciBmaWxlICglcykiKSwKCQkJICAgIGlkLCBzdHJlcnJvcihlcnJubykpOwoJCXJldHVybiAxOwoJfQoJbGVuID0geHNpemVfdChzdC5zdF9zaXplKTsKCXBhdGggPSB4bWFsbG9jeihsZW4pOwoKCXJlYWRfcmVzdWx0ID0gcmVhZF9pbl9mdWxsKGZkLCBwYXRoLCBsZW4pOwoJaWYgKHJlYWRfcmVzdWx0IDwgMCkgewoJCXN0cmJ1Zl9hZGRmKHJlYXNvbiwgXygiUmVtb3Zpbmcgd29ya3RyZWVzLyVzOiB1bmFibGUgdG8gcmVhZCBnaXRkaXIgZmlsZSAoJXMpIiksCgkJCSAgICBpZCwgc3RyZXJyb3IoZXJybm8pKTsKCQljbG9zZShmZCk7CgkJZnJlZShwYXRoKTsKCQlyZXR1cm4gMTsKCX0KCWNsb3NlKGZkKTsKCglpZiAocmVhZF9yZXN1bHQgIT0gbGVuKSB7CgkJc3RyYnVmX2FkZGYocmVhc29uLAoJCQkgICAgXygiUmVtb3Zpbmcgd29ya3RyZWVzLyVzOiBzaG9ydCByZWFkIChleHBlY3RlZCAlIlBSSXVNQVgiIGJ5dGVzLCByZWFkICUiUFJJdU1BWCIpIiksCgkJCSAgICBpZCwgKHVpbnRtYXhfdClsZW4sICh1aW50bWF4X3QpcmVhZF9yZXN1bHQpOwoJCWZyZWUocGF0aCk7CgkJcmV0dXJuIDE7Cgl9Cgl3aGlsZSAobGVuICYmIChwYXRoW2xlbiAtIDFdID09ICdcbicgfHwgcGF0aFtsZW4gLSAxXSA9PSAnXHInKSkKCQlsZW4tLTsKCWlmICghbGVuKSB7CgkJc3RyYnVmX2FkZGYocmVhc29uLCBfKCJSZW1vdmluZyB3b3JrdHJlZXMvJXM6IGludmFsaWQgZ2l0ZGlyIGZpbGUiKSwgaWQpOwoJCWZyZWUocGF0aCk7CgkJcmV0dXJuIDE7Cgl9CglwYXRoW2xlbl0gPSAnXDAnOwoJaWYgKCFmaWxlX2V4aXN0cyhwYXRoKSkgewoJCXN0cnVjdCBzdGF0IHN0X2xpbms7CgkJZnJlZShwYXRoKTsKCQkvKgoJCSAqIHRoZSByZXBvIGlzIG1vdmVkIG1hbnVhbGx5IGFuZCBoYXMgbm90IGJlZW4KCQkgKiBhY2Nlc3NlZCBzaW5jZT8KCQkgKi8KCQlpZiAoIXN0YXQoZ2l0X3BhdGgoIndvcmt0cmVlcy8lcy9saW5rIiwgaWQpLCAmc3RfbGluaykgJiYKCQkgICAgc3RfbGluay5zdF9ubGluayA+IDEpCgkJCXJldHVybiAwOwoJCWlmIChzdC5zdF9tdGltZSA8PSBleHBpcmUpIHsKCQkJc3RyYnVmX2FkZGYocmVhc29uLCBfKCJSZW1vdmluZyB3b3JrdHJlZXMvJXM6IGdpdGRpciBmaWxlIHBvaW50cyB0byBub24tZXhpc3RlbnQgbG9jYXRpb24iKSwgaWQpOwoJCQlyZXR1cm4gMTsKCQl9IGVsc2UgewoJCQlyZXR1cm4gMDsKCQl9Cgl9CglmcmVlKHBhdGgpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHBydW5lX3dvcmt0cmVlcyh2b2lkKQp7CglzdHJ1Y3Qgc3RyYnVmIHJlYXNvbiA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBwYXRoID0gU1RSQlVGX0lOSVQ7CglESVIgKmRpciA9IG9wZW5kaXIoZ2l0X3BhdGgoIndvcmt0cmVlcyIpKTsKCXN0cnVjdCBkaXJlbnQgKmQ7CglpbnQgcmV0OwoJaWYgKCFkaXIpCgkJcmV0dXJuOwoJd2hpbGUgKChkID0gcmVhZGRpcihkaXIpKSAhPSBOVUxMKSB7CgkJaWYgKGlzX2RvdF9vcl9kb3Rkb3QoZC0+ZF9uYW1lKSkKCQkJY29udGludWU7CgkJc3RyYnVmX3Jlc2V0KCZyZWFzb24pOwoJCWlmICghcHJ1bmVfd29ya3RyZWUoZC0+ZF9uYW1lLCAmcmVhc29uKSkKCQkJY29udGludWU7CgkJaWYgKHNob3dfb25seSB8fCB2ZXJib3NlKQoJCQlwcmludGYoIiVzXG4iLCByZWFzb24uYnVmKTsKCQlpZiAoc2hvd19vbmx5KQoJCQljb250aW51ZTsKCQlnaXRfcGF0aF9idWYoJnBhdGgsICJ3b3JrdHJlZXMvJXMiLCBkLT5kX25hbWUpOwoJCXJldCA9IHJlbW92ZV9kaXJfcmVjdXJzaXZlbHkoJnBhdGgsIDApOwoJCWlmIChyZXQgPCAwICYmIGVycm5vID09IEVOT1RESVIpCgkJCXJldCA9IHVubGluayhwYXRoLmJ1Zik7CgkJaWYgKHJldCkKCQkJZXJyb3JfZXJybm8oXygiZmFpbGVkIHRvIHJlbW92ZSAnJXMnIiksIHBhdGguYnVmKTsKCX0KCWNsb3NlZGlyKGRpcik7CglpZiAoIXNob3dfb25seSkKCQlybWRpcihnaXRfcGF0aCgid29ya3RyZWVzIikpOwoJc3RyYnVmX3JlbGVhc2UoJnJlYXNvbik7CglzdHJidWZfcmVsZWFzZSgmcGF0aCk7Cn0KCnN0YXRpYyBpbnQgcHJ1bmUoaW50IGFjLCBjb25zdCBjaGFyICoqYXYsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJT1BUX19EUllfUlVOKCZzaG93X29ubHksIE5fKCJkbyBub3QgcmVtb3ZlLCBzaG93IG9ubHkiKSksCgkJT1BUX19WRVJCT1NFKCZ2ZXJib3NlLCBOXygicmVwb3J0IHBydW5lZCB3b3JraW5nIHRyZWVzIikpLAoJCU9QVF9FWFBJUllfREFURSgwLCAiZXhwaXJlIiwgJmV4cGlyZSwKCQkJCU5fKCJleHBpcmUgd29ya2luZyB0cmVlcyBvbGRlciB0aGFuIDx0aW1lPiIpKSwKCQlPUFRfRU5EKCkKCX07CgoJZXhwaXJlID0gVElNRV9NQVg7CglhYyA9IHBhcnNlX29wdGlvbnMoYWMsIGF2LCBwcmVmaXgsIG9wdGlvbnMsIHdvcmt0cmVlX3VzYWdlLCAwKTsKCWlmIChhYykKCQl1c2FnZV93aXRoX29wdGlvbnMod29ya3RyZWVfdXNhZ2UsIG9wdGlvbnMpOwoJcHJ1bmVfd29ya3RyZWVzKCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGNoYXIgKmp1bmtfd29ya190cmVlOwpzdGF0aWMgY2hhciAqanVua19naXRfZGlyOwpzdGF0aWMgaW50IGlzX2p1bms7CnN0YXRpYyBwaWRfdCBqdW5rX3BpZDsKCnN0YXRpYyB2b2lkIHJlbW92ZV9qdW5rKHZvaWQpCnsKCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCWlmICghaXNfanVuayB8fCBnZXRwaWQoKSAhPSBqdW5rX3BpZCkKCQlyZXR1cm47CglpZiAoanVua19naXRfZGlyKSB7CgkJc3RyYnVmX2FkZHN0cigmc2IsIGp1bmtfZ2l0X2Rpcik7CgkJcmVtb3ZlX2Rpcl9yZWN1cnNpdmVseSgmc2IsIDApOwoJCXN0cmJ1Zl9yZXNldCgmc2IpOwoJfQoJaWYgKGp1bmtfd29ya190cmVlKSB7CgkJc3RyYnVmX2FkZHN0cigmc2IsIGp1bmtfd29ya190cmVlKTsKCQlyZW1vdmVfZGlyX3JlY3Vyc2l2ZWx5KCZzYiwgMCk7Cgl9CglzdHJidWZfcmVsZWFzZSgmc2IpOwp9CgpzdGF0aWMgdm9pZCByZW1vdmVfanVua19vbl9zaWduYWwoaW50IHNpZ25vKQp7CglyZW1vdmVfanVuaygpOwoJc2lnY2hhaW5fcG9wKHNpZ25vKTsKCXJhaXNlKHNpZ25vKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKndvcmt0cmVlX2Jhc2VuYW1lKGNvbnN0IGNoYXIgKnBhdGgsIGludCAqb2xlbikKewoJY29uc3QgY2hhciAqbmFtZTsKCWludCBsZW47CgoJbGVuID0gc3RybGVuKHBhdGgpOwoJd2hpbGUgKGxlbiAmJiBpc19kaXJfc2VwKHBhdGhbbGVuIC0gMV0pKQoJCWxlbi0tOwoKCWZvciAobmFtZSA9IHBhdGggKyBsZW4gLSAxOyBuYW1lID4gcGF0aDsgbmFtZS0tKQoJCWlmIChpc19kaXJfc2VwKCpuYW1lKSkgewoJCQluYW1lKys7CgkJCWJyZWFrOwoJCX0KCgkqb2xlbiA9IGxlbjsKCXJldHVybiBuYW1lOwp9CgpzdGF0aWMgaW50IGFkZF93b3JrdHJlZShjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFyICpyZWZuYW1lLAoJCQljb25zdCBzdHJ1Y3QgYWRkX29wdHMgKm9wdHMpCnsKCXN0cnVjdCBzdHJidWYgc2JfZ2l0ID0gU1RSQlVGX0lOSVQsIHNiX3JlcG8gPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKm5hbWU7CglzdHJ1Y3Qgc3RhdCBzdDsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGNwID0gQ0hJTERfUFJPQ0VTU19JTklUOwoJc3RydWN0IGFyZ3ZfYXJyYXkgY2hpbGRfZW52ID0gQVJHVl9BUlJBWV9JTklUOwoJaW50IGNvdW50ZXIgPSAwLCBsZW4sIHJldDsKCXN0cnVjdCBzdHJidWYgc3ltcmVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBOVUxMOwoKCWlmIChmaWxlX2V4aXN0cyhwYXRoKSAmJiAhaXNfZW1wdHlfZGlyKHBhdGgpKQoJCWRpZShfKCInJXMnIGFscmVhZHkgZXhpc3RzIiksIHBhdGgpOwoKCS8qIGlzICdyZWZuYW1lJyBhIGJyYW5jaCBvciBjb21taXQ/ICovCglpZiAoIW9wdHMtPmRldGFjaCAmJiAhc3RyYnVmX2NoZWNrX2JyYW5jaF9yZWYoJnN5bXJlZiwgcmVmbmFtZSkgJiYKCQkgcmVmX2V4aXN0cyhzeW1yZWYuYnVmKSkgeyAvKiBpdCdzIGEgYnJhbmNoICovCgkJaWYgKCFvcHRzLT5mb3JjZSkKCQkJZGllX2lmX2NoZWNrZWRfb3V0KHN5bXJlZi5idWYsIDApOwoJfSBlbHNlIHsgLyogbXVzdCBiZSBhIGNvbW1pdCAqLwoJCWNvbW1pdCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2J5X25hbWUocmVmbmFtZSk7CgkJaWYgKCFjb21taXQpCgkJCWRpZShfKCJpbnZhbGlkIHJlZmVyZW5jZTogJXMiKSwgcmVmbmFtZSk7Cgl9CgoJbmFtZSA9IHdvcmt0cmVlX2Jhc2VuYW1lKHBhdGgsICZsZW4pOwoJZ2l0X3BhdGhfYnVmKCZzYl9yZXBvLCAid29ya3RyZWVzLyUuKnMiLCAoaW50KShwYXRoICsgbGVuIC0gbmFtZSksIG5hbWUpOwoJbGVuID0gc2JfcmVwby5sZW47CglpZiAoc2FmZV9jcmVhdGVfbGVhZGluZ19kaXJlY3Rvcmllc19jb25zdChzYl9yZXBvLmJ1ZikpCgkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCBjcmVhdGUgbGVhZGluZyBkaXJlY3RvcmllcyBvZiAnJXMnIiksCgkJCSAgc2JfcmVwby5idWYpOwoJd2hpbGUgKCFzdGF0KHNiX3JlcG8uYnVmLCAmc3QpKSB7CgkJY291bnRlcisrOwoJCXN0cmJ1Zl9zZXRsZW4oJnNiX3JlcG8sIGxlbik7CgkJc3RyYnVmX2FkZGYoJnNiX3JlcG8sICIlZCIsIGNvdW50ZXIpOwoJfQoJbmFtZSA9IHN0cnJjaHIoc2JfcmVwby5idWYsICcvJykgKyAxOwoKCWp1bmtfcGlkID0gZ2V0cGlkKCk7CglhdGV4aXQocmVtb3ZlX2p1bmspOwoJc2lnY2hhaW5fcHVzaF9jb21tb24ocmVtb3ZlX2p1bmtfb25fc2lnbmFsKTsKCglpZiAobWtkaXIoc2JfcmVwby5idWYsIDA3NzcpKQoJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgY3JlYXRlIGRpcmVjdG9yeSBvZiAnJXMnIiksIHNiX3JlcG8uYnVmKTsKCWp1bmtfZ2l0X2RpciA9IHhzdHJkdXAoc2JfcmVwby5idWYpOwoJaXNfanVuayA9IDE7CgoJLyoKCSAqIGxvY2sgdGhlIGluY29tcGxldGUgcmVwbyBzbyBwcnVuZSB3b24ndCBkZWxldGUgaXQsIHVubG9jawoJICogYWZ0ZXIgdGhlIHByZXBhcmF0aW9uIGlzIG92ZXIuCgkgKi8KCXN0cmJ1Zl9hZGRmKCZzYiwgIiVzL2xvY2tlZCIsIHNiX3JlcG8uYnVmKTsKCWlmICghb3B0cy0+a2VlcF9sb2NrZWQpCgkJd3JpdGVfZmlsZShzYi5idWYsICJpbml0aWFsaXppbmciKTsKCWVsc2UKCQl3cml0ZV9maWxlKHNiLmJ1ZiwgImFkZGVkIHdpdGggLS1sb2NrIik7CgoJc3RyYnVmX2FkZGYoJnNiX2dpdCwgIiVzLy5naXQiLCBwYXRoKTsKCWlmIChzYWZlX2NyZWF0ZV9sZWFkaW5nX2RpcmVjdG9yaWVzX2NvbnN0KHNiX2dpdC5idWYpKQoJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgY3JlYXRlIGxlYWRpbmcgZGlyZWN0b3JpZXMgb2YgJyVzJyIpLAoJCQkgIHNiX2dpdC5idWYpOwoJanVua193b3JrX3RyZWUgPSB4c3RyZHVwKHBhdGgpOwoKCXN0cmJ1Zl9yZXNldCgmc2IpOwoJc3RyYnVmX2FkZGYoJnNiLCAiJXMvZ2l0ZGlyIiwgc2JfcmVwby5idWYpOwoJd3JpdGVfZmlsZShzYi5idWYsICIlcyIsIHJlYWxfcGF0aChzYl9naXQuYnVmKSk7Cgl3cml0ZV9maWxlKHNiX2dpdC5idWYsICJnaXRkaXI6ICVzL3dvcmt0cmVlcy8lcyIsCgkJICAgcmVhbF9wYXRoKGdldF9naXRfY29tbW9uX2RpcigpKSwgbmFtZSk7CgkvKgoJICogVGhpcyBpcyB0byBrZWVwIHJlc29sdmVfcmVmKCkgaGFwcHkuIFdlIG5lZWQgYSB2YWxpZCBIRUFECgkgKiBvciBpc19naXRfZGlyZWN0b3J5KCkgd2lsbCByZWplY3QgdGhlIGRpcmVjdG9yeS4gQW55IHZhbHVlIHdoaWNoCgkgKiBsb29rcyBsaWtlIGFuIG9iamVjdCBJRCB3aWxsIGRvIHNpbmNlIGl0IHdpbGwgYmUgaW1tZWRpYXRlbHkKCSAqIHJlcGxhY2VkIGJ5IHRoZSBzeW1ib2xpYy1yZWYgb3IgdXBkYXRlLXJlZiBpbnZvY2F0aW9uIGluIHRoZSBuZXcKCSAqIHdvcmt0cmVlLgoJICovCglzdHJidWZfcmVzZXQoJnNiKTsKCXN0cmJ1Zl9hZGRmKCZzYiwgIiVzL0hFQUQiLCBzYl9yZXBvLmJ1Zik7Cgl3cml0ZV9maWxlKHNiLmJ1ZiwgIiVzIiwgc2hhMV90b19oZXgobnVsbF9zaGExKSk7CglzdHJidWZfcmVzZXQoJnNiKTsKCXN0cmJ1Zl9hZGRmKCZzYiwgIiVzL2NvbW1vbmRpciIsIHNiX3JlcG8uYnVmKTsKCXdyaXRlX2ZpbGUoc2IuYnVmLCAiLi4vLi4iKTsKCglmcHJpbnRmX2xuKHN0ZGVyciwgXygiUHJlcGFyaW5nICVzIChpZGVudGlmaWVyICVzKSIpLCBwYXRoLCBuYW1lKTsKCglhcmd2X2FycmF5X3B1c2hmKCZjaGlsZF9lbnYsICIlcz0lcyIsIEdJVF9ESVJfRU5WSVJPTk1FTlQsIHNiX2dpdC5idWYpOwoJYXJndl9hcnJheV9wdXNoZigmY2hpbGRfZW52LCAiJXM9JXMiLCBHSVRfV09SS19UUkVFX0VOVklST05NRU5ULCBwYXRoKTsKCWNwLmdpdF9jbWQgPSAxOwoKCWlmIChjb21taXQpCgkJYXJndl9hcnJheV9wdXNobCgmY3AuYXJncywgInVwZGF0ZS1yZWYiLCAiSEVBRCIsCgkJCQkgb2lkX3RvX2hleCgmY29tbWl0LT5vYmplY3Qub2lkKSwgTlVMTCk7CgllbHNlCgkJYXJndl9hcnJheV9wdXNobCgmY3AuYXJncywgInN5bWJvbGljLXJlZiIsICJIRUFEIiwKCQkJCSBzeW1yZWYuYnVmLCBOVUxMKTsKCWNwLmVudiA9IGNoaWxkX2Vudi5hcmd2OwoJcmV0ID0gcnVuX2NvbW1hbmQoJmNwKTsKCWlmIChyZXQpCgkJZ290byBkb25lOwoKCWlmIChvcHRzLT5jaGVja291dCkgewoJCWNwLmFyZ3YgPSBOVUxMOwoJCWFyZ3ZfYXJyYXlfY2xlYXIoJmNwLmFyZ3MpOwoJCWFyZ3ZfYXJyYXlfcHVzaGwoJmNwLmFyZ3MsICJyZXNldCIsICItLWhhcmQiLCBOVUxMKTsKCQljcC5lbnYgPSBjaGlsZF9lbnYuYXJndjsKCQlyZXQgPSBydW5fY29tbWFuZCgmY3ApOwoJCWlmIChyZXQpCgkJCWdvdG8gZG9uZTsKCX0KCglpc19qdW5rID0gMDsKCUZSRUVfQU5EX05VTEwoanVua193b3JrX3RyZWUpOwoJRlJFRV9BTkRfTlVMTChqdW5rX2dpdF9kaXIpOwoKZG9uZToKCWlmIChyZXQgfHwgIW9wdHMtPmtlZXBfbG9ja2VkKSB7CgkJc3RyYnVmX3Jlc2V0KCZzYik7CgkJc3RyYnVmX2FkZGYoJnNiLCAiJXMvbG9ja2VkIiwgc2JfcmVwby5idWYpOwoJCXVubGlua19vcl93YXJuKHNiLmJ1Zik7Cgl9Cglhcmd2X2FycmF5X2NsZWFyKCZjaGlsZF9lbnYpOwoJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCXN0cmJ1Zl9yZWxlYXNlKCZzeW1yZWYpOwoJc3RyYnVmX3JlbGVhc2UoJnNiX3JlcG8pOwoJc3RyYnVmX3JlbGVhc2UoJnNiX2dpdCk7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IGFkZChpbnQgYWMsIGNvbnN0IGNoYXIgKiphdiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdHJ1Y3QgYWRkX29wdHMgb3B0czsKCWNvbnN0IGNoYXIgKm5ld19icmFuY2hfZm9yY2UgPSBOVUxMOwoJY2hhciAqcGF0aDsKCWNvbnN0IGNoYXIgKmJyYW5jaDsKCWNvbnN0IGNoYXIgKm9wdF90cmFjayA9IE5VTEw7CglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfX0ZPUkNFKCZvcHRzLmZvcmNlLCBOXygiY2hlY2tvdXQgPGJyYW5jaD4gZXZlbiBpZiBhbHJlYWR5IGNoZWNrZWQgb3V0IGluIG90aGVyIHdvcmt0cmVlIikpLAoJCU9QVF9TVFJJTkcoJ2InLCBOVUxMLCAmb3B0cy5uZXdfYnJhbmNoLCBOXygiYnJhbmNoIiksCgkJCSAgIE5fKCJjcmVhdGUgYSBuZXcgYnJhbmNoIikpLAoJCU9QVF9TVFJJTkcoJ0InLCBOVUxMLCAmbmV3X2JyYW5jaF9mb3JjZSwgTl8oImJyYW5jaCIpLAoJCQkgICBOXygiY3JlYXRlIG9yIHJlc2V0IGEgYnJhbmNoIikpLAoJCU9QVF9CT09MKDAsICJkZXRhY2giLCAmb3B0cy5kZXRhY2gsIE5fKCJkZXRhY2ggSEVBRCBhdCBuYW1lZCBjb21taXQiKSksCgkJT1BUX0JPT0woMCwgImNoZWNrb3V0IiwgJm9wdHMuY2hlY2tvdXQsIE5fKCJwb3B1bGF0ZSB0aGUgbmV3IHdvcmtpbmcgdHJlZSIpKSwKCQlPUFRfQk9PTCgwLCAibG9jayIsICZvcHRzLmtlZXBfbG9ja2VkLCBOXygia2VlcCB0aGUgbmV3IHdvcmtpbmcgdHJlZSBsb2NrZWQiKSksCgkJT1BUX1BBU1NUSFJVKDAsICJ0cmFjayIsICZvcHRfdHJhY2ssIE5VTEwsCgkJCSAgICAgTl8oInNldCB1cCB0cmFja2luZyBtb2RlIChzZWUgZ2l0LWJyYW5jaCgxKSkiKSwKCQkJICAgICBQQVJTRV9PUFRfTk9BUkcgfCBQQVJTRV9PUFRfT1BUQVJHKSwKCQlPUFRfQk9PTCgwLCAiZ3Vlc3MtcmVtb3RlIiwgJmd1ZXNzX3JlbW90ZSwKCQkJIE5fKCJ0cnkgdG8gbWF0Y2ggdGhlIG5ldyBicmFuY2ggbmFtZSB3aXRoIGEgcmVtb3RlLXRyYWNraW5nIGJyYW5jaCIpKSwKCQlPUFRfRU5EKCkKCX07CgoJbWVtc2V0KCZvcHRzLCAwLCBzaXplb2Yob3B0cykpOwoJb3B0cy5jaGVja291dCA9IDE7CglhYyA9IHBhcnNlX29wdGlvbnMoYWMsIGF2LCBwcmVmaXgsIG9wdGlvbnMsIHdvcmt0cmVlX3VzYWdlLCAwKTsKCWlmICghIW9wdHMuZGV0YWNoICsgISFvcHRzLm5ld19icmFuY2ggKyAhIW5ld19icmFuY2hfZm9yY2UgPiAxKQoJCWRpZShfKCItYiwgLUIsIGFuZCAtLWRldGFjaCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlIikpOwoJaWYgKGFjIDwgMSB8fCBhYyA+IDIpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKHdvcmt0cmVlX3VzYWdlLCBvcHRpb25zKTsKCglwYXRoID0gcHJlZml4X2ZpbGVuYW1lKHByZWZpeCwgYXZbMF0pOwoJYnJhbmNoID0gYWMgPCAyID8gIkhFQUQiIDogYXZbMV07CgoJaWYgKCFzdHJjbXAoYnJhbmNoLCAiLSIpKQoJCWJyYW5jaCA9ICJAey0xfSI7CgoJb3B0cy5mb3JjZV9uZXdfYnJhbmNoID0gISFuZXdfYnJhbmNoX2ZvcmNlOwoJaWYgKG9wdHMuZm9yY2VfbmV3X2JyYW5jaCkgewoJCXN0cnVjdCBzdHJidWYgc3ltcmVmID0gU1RSQlVGX0lOSVQ7CgoJCW9wdHMubmV3X2JyYW5jaCA9IG5ld19icmFuY2hfZm9yY2U7CgoJCWlmICghb3B0cy5mb3JjZSAmJgoJCSAgICAhc3RyYnVmX2NoZWNrX2JyYW5jaF9yZWYoJnN5bXJlZiwgb3B0cy5uZXdfYnJhbmNoKSAmJgoJCSAgICByZWZfZXhpc3RzKHN5bXJlZi5idWYpKQoJCQlkaWVfaWZfY2hlY2tlZF9vdXQoc3ltcmVmLmJ1ZiwgMCk7CgkJc3RyYnVmX3JlbGVhc2UoJnN5bXJlZik7Cgl9CgoJaWYgKGFjIDwgMiAmJiAhb3B0cy5uZXdfYnJhbmNoICYmICFvcHRzLmRldGFjaCkgewoJCWludCBuOwoJCWNvbnN0IGNoYXIgKnMgPSB3b3JrdHJlZV9iYXNlbmFtZShwYXRoLCAmbik7CgkJb3B0cy5uZXdfYnJhbmNoID0geHN0cm5kdXAocywgbik7CgkJaWYgKGd1ZXNzX3JlbW90ZSkgewoJCQlzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCQkJY29uc3QgY2hhciAqcmVtb3RlID0KCQkJCXVuaXF1ZV90cmFja2luZ19uYW1lKG9wdHMubmV3X2JyYW5jaCwgJm9pZCk7CgkJCWlmIChyZW1vdGUpCgkJCQlicmFuY2ggPSByZW1vdGU7CgkJfQoJfQoKCWlmIChhYyA9PSAyICYmICFvcHRzLm5ld19icmFuY2ggJiYgIW9wdHMuZGV0YWNoKSB7CgkJc3RydWN0IG9iamVjdF9pZCBvaWQ7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJCWNvbnN0IGNoYXIgKnJlbW90ZTsKCgkJY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfYnlfbmFtZShicmFuY2gpOwoJCWlmICghY29tbWl0KSB7CgkJCXJlbW90ZSA9IHVuaXF1ZV90cmFja2luZ19uYW1lKGJyYW5jaCwgJm9pZCk7CgkJCWlmIChyZW1vdGUpIHsKCQkJCW9wdHMubmV3X2JyYW5jaCA9IGJyYW5jaDsKCQkJCWJyYW5jaCA9IHJlbW90ZTsKCQkJfQoJCX0KCX0KCglpZiAob3B0cy5uZXdfYnJhbmNoKSB7CgkJc3RydWN0IGNoaWxkX3Byb2Nlc3MgY3AgPSBDSElMRF9QUk9DRVNTX0lOSVQ7CgkJY3AuZ2l0X2NtZCA9IDE7CgkJYXJndl9hcnJheV9wdXNoKCZjcC5hcmdzLCAiYnJhbmNoIik7CgkJaWYgKG9wdHMuZm9yY2VfbmV3X2JyYW5jaCkKCQkJYXJndl9hcnJheV9wdXNoKCZjcC5hcmdzLCAiLS1mb3JjZSIpOwoJCWFyZ3ZfYXJyYXlfcHVzaCgmY3AuYXJncywgb3B0cy5uZXdfYnJhbmNoKTsKCQlhcmd2X2FycmF5X3B1c2goJmNwLmFyZ3MsIGJyYW5jaCk7CgkJaWYgKG9wdF90cmFjaykKCQkJYXJndl9hcnJheV9wdXNoKCZjcC5hcmdzLCBvcHRfdHJhY2spOwoJCWlmIChydW5fY29tbWFuZCgmY3ApKQoJCQlyZXR1cm4gLTE7CgkJYnJhbmNoID0gb3B0cy5uZXdfYnJhbmNoOwoJfSBlbHNlIGlmIChvcHRfdHJhY2spIHsKCQlkaWUoXygiLS1bbm8tXXRyYWNrIGNhbiBvbmx5IGJlIHVzZWQgaWYgYSBuZXcgYnJhbmNoIGlzIGNyZWF0ZWQiKSk7Cgl9CgoJVU5MRUFLKHBhdGgpOwoJVU5MRUFLKG9wdHMpOwoJcmV0dXJuIGFkZF93b3JrdHJlZShwYXRoLCBicmFuY2gsICZvcHRzKTsKfQoKc3RhdGljIHZvaWQgc2hvd193b3JrdHJlZV9wb3JjZWxhaW4oc3RydWN0IHdvcmt0cmVlICp3dCkKewoJcHJpbnRmKCJ3b3JrdHJlZSAlc1xuIiwgd3QtPnBhdGgpOwoJaWYgKHd0LT5pc19iYXJlKQoJCXByaW50ZigiYmFyZVxuIik7CgllbHNlIHsKCQlwcmludGYoIkhFQUQgJXNcbiIsIG9pZF90b19oZXgoJnd0LT5oZWFkX29pZCkpOwoJCWlmICh3dC0+aXNfZGV0YWNoZWQpCgkJCXByaW50ZigiZGV0YWNoZWRcbiIpOwoJCWVsc2UgaWYgKHd0LT5oZWFkX3JlZikKCQkJcHJpbnRmKCJicmFuY2ggJXNcbiIsIHd0LT5oZWFkX3JlZik7Cgl9CglwcmludGYoIlxuIik7Cn0KCnN0YXRpYyB2b2lkIHNob3dfd29ya3RyZWUoc3RydWN0IHdvcmt0cmVlICp3dCwgaW50IHBhdGhfbWF4bGVuLCBpbnQgYWJicmV2X2xlbikKewoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJaW50IGN1cl9wYXRoX2xlbiA9IHN0cmxlbih3dC0+cGF0aCk7CglpbnQgcGF0aF9hZGogPSBjdXJfcGF0aF9sZW4gLSB1dGY4X3N0cndpZHRoKHd0LT5wYXRoKTsKCglzdHJidWZfYWRkZigmc2IsICIlLSpzICIsIDEgKyBwYXRoX21heGxlbiArIHBhdGhfYWRqLCB3dC0+cGF0aCk7CglpZiAod3QtPmlzX2JhcmUpCgkJc3RyYnVmX2FkZHN0cigmc2IsICIoYmFyZSkiKTsKCWVsc2UgewoJCXN0cmJ1Zl9hZGRmKCZzYiwgIiUtKnMgIiwgYWJicmV2X2xlbiwKCQkJCWZpbmRfdW5pcXVlX2FiYnJldih3dC0+aGVhZF9vaWQuaGFzaCwgREVGQVVMVF9BQkJSRVYpKTsKCQlpZiAod3QtPmlzX2RldGFjaGVkKQoJCQlzdHJidWZfYWRkc3RyKCZzYiwgIihkZXRhY2hlZCBIRUFEKSIpOwoJCWVsc2UgaWYgKHd0LT5oZWFkX3JlZikgewoJCQljaGFyICpyZWYgPSBzaG9ydGVuX3VuYW1iaWd1b3VzX3JlZih3dC0+aGVhZF9yZWYsIDApOwoJCQlzdHJidWZfYWRkZigmc2IsICJbJXNdIiwgcmVmKTsKCQkJZnJlZShyZWYpOwoJCX0gZWxzZQoJCQlzdHJidWZfYWRkc3RyKCZzYiwgIihlcnJvcikiKTsKCX0KCXByaW50ZigiJXNcbiIsIHNiLmJ1Zik7CgoJc3RyYnVmX3JlbGVhc2UoJnNiKTsKfQoKc3RhdGljIHZvaWQgbWVhc3VyZV93aWR0aHMoc3RydWN0IHdvcmt0cmVlICoqd3QsIGludCAqYWJicmV2LCBpbnQgKm1heGxlbikKewoJaW50IGk7CgoJZm9yIChpID0gMDsgd3RbaV07IGkrKykgewoJCWludCBzaGExX2xlbjsKCQlpbnQgcGF0aF9sZW4gPSBzdHJsZW4od3RbaV0tPnBhdGgpOwoKCQlpZiAocGF0aF9sZW4gPiAqbWF4bGVuKQoJCQkqbWF4bGVuID0gcGF0aF9sZW47CgkJc2hhMV9sZW4gPSBzdHJsZW4oZmluZF91bmlxdWVfYWJicmV2KHd0W2ldLT5oZWFkX29pZC5oYXNoLCAqYWJicmV2KSk7CgkJaWYgKHNoYTFfbGVuID4gKmFiYnJldikKCQkJKmFiYnJldiA9IHNoYTFfbGVuOwoJfQp9CgpzdGF0aWMgaW50IGxpc3QoaW50IGFjLCBjb25zdCBjaGFyICoqYXYsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJaW50IHBvcmNlbGFpbiA9IDA7CgoJc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJT1BUX0JPT0woMCwgInBvcmNlbGFpbiIsICZwb3JjZWxhaW4sIE5fKCJtYWNoaW5lLXJlYWRhYmxlIG91dHB1dCIpKSwKCQlPUFRfRU5EKCkKCX07CgoJYWMgPSBwYXJzZV9vcHRpb25zKGFjLCBhdiwgcHJlZml4LCBvcHRpb25zLCB3b3JrdHJlZV91c2FnZSwgMCk7CglpZiAoYWMpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKHdvcmt0cmVlX3VzYWdlLCBvcHRpb25zKTsKCWVsc2UgewoJCXN0cnVjdCB3b3JrdHJlZSAqKndvcmt0cmVlcyA9IGdldF93b3JrdHJlZXMoR1dUX1NPUlRfTElOS0VEKTsKCQlpbnQgcGF0aF9tYXhsZW4gPSAwLCBhYmJyZXYgPSBERUZBVUxUX0FCQlJFViwgaTsKCgkJaWYgKCFwb3JjZWxhaW4pCgkJCW1lYXN1cmVfd2lkdGhzKHdvcmt0cmVlcywgJmFiYnJldiwgJnBhdGhfbWF4bGVuKTsKCgkJZm9yIChpID0gMDsgd29ya3RyZWVzW2ldOyBpKyspIHsKCQkJaWYgKHBvcmNlbGFpbikKCQkJCXNob3dfd29ya3RyZWVfcG9yY2VsYWluKHdvcmt0cmVlc1tpXSk7CgkJCWVsc2UKCQkJCXNob3dfd29ya3RyZWUod29ya3RyZWVzW2ldLCBwYXRoX21heGxlbiwgYWJicmV2KTsKCQl9CgkJZnJlZV93b3JrdHJlZXMod29ya3RyZWVzKTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGxvY2tfd29ya3RyZWUoaW50IGFjLCBjb25zdCBjaGFyICoqYXYsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJY29uc3QgY2hhciAqcmVhc29uID0gIiIsICpvbGRfcmVhc29uOwoJc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJT1BUX1NUUklORygwLCAicmVhc29uIiwgJnJlYXNvbiwgTl8oInN0cmluZyIpLAoJCQkgICBOXygicmVhc29uIGZvciBsb2NraW5nIikpLAoJCU9QVF9FTkQoKQoJfTsKCXN0cnVjdCB3b3JrdHJlZSAqKndvcmt0cmVlcywgKnd0OwoKCWFjID0gcGFyc2Vfb3B0aW9ucyhhYywgYXYsIHByZWZpeCwgb3B0aW9ucywgd29ya3RyZWVfdXNhZ2UsIDApOwoJaWYgKGFjICE9IDEpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKHdvcmt0cmVlX3VzYWdlLCBvcHRpb25zKTsKCgl3b3JrdHJlZXMgPSBnZXRfd29ya3RyZWVzKDApOwoJd3QgPSBmaW5kX3dvcmt0cmVlKHdvcmt0cmVlcywgcHJlZml4LCBhdlswXSk7CglpZiAoIXd0KQoJCWRpZShfKCInJXMnIGlzIG5vdCBhIHdvcmtpbmcgdHJlZSIpLCBhdlswXSk7CglpZiAoaXNfbWFpbl93b3JrdHJlZSh3dCkpCgkJZGllKF8oIlRoZSBtYWluIHdvcmtpbmcgdHJlZSBjYW5ub3QgYmUgbG9ja2VkIG9yIHVubG9ja2VkIikpOwoKCW9sZF9yZWFzb24gPSBpc193b3JrdHJlZV9sb2NrZWQod3QpOwoJaWYgKG9sZF9yZWFzb24pIHsKCQlpZiAoKm9sZF9yZWFzb24pCgkJCWRpZShfKCInJXMnIGlzIGFscmVhZHkgbG9ja2VkLCByZWFzb246ICVzIiksCgkJCSAgICBhdlswXSwgb2xkX3JlYXNvbik7CgkJZGllKF8oIiclcycgaXMgYWxyZWFkeSBsb2NrZWQiKSwgYXZbMF0pOwoJfQoKCXdyaXRlX2ZpbGUoZ2l0X2NvbW1vbl9wYXRoKCJ3b3JrdHJlZXMvJXMvbG9ja2VkIiwgd3QtPmlkKSwKCQkgICAiJXMiLCByZWFzb24pOwoJZnJlZV93b3JrdHJlZXMod29ya3RyZWVzKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHVubG9ja193b3JrdHJlZShpbnQgYWMsIGNvbnN0IGNoYXIgKiphdiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfRU5EKCkKCX07CglzdHJ1Y3Qgd29ya3RyZWUgKip3b3JrdHJlZXMsICp3dDsKCWludCByZXQ7CgoJYWMgPSBwYXJzZV9vcHRpb25zKGFjLCBhdiwgcHJlZml4LCBvcHRpb25zLCB3b3JrdHJlZV91c2FnZSwgMCk7CglpZiAoYWMgIT0gMSkKCQl1c2FnZV93aXRoX29wdGlvbnMod29ya3RyZWVfdXNhZ2UsIG9wdGlvbnMpOwoKCXdvcmt0cmVlcyA9IGdldF93b3JrdHJlZXMoMCk7Cgl3dCA9IGZpbmRfd29ya3RyZWUod29ya3RyZWVzLCBwcmVmaXgsIGF2WzBdKTsKCWlmICghd3QpCgkJZGllKF8oIiclcycgaXMgbm90IGEgd29ya2luZyB0cmVlIiksIGF2WzBdKTsKCWlmIChpc19tYWluX3dvcmt0cmVlKHd0KSkKCQlkaWUoXygiVGhlIG1haW4gd29ya2luZyB0cmVlIGNhbm5vdCBiZSBsb2NrZWQgb3IgdW5sb2NrZWQiKSk7CglpZiAoIWlzX3dvcmt0cmVlX2xvY2tlZCh3dCkpCgkJZGllKF8oIiclcycgaXMgbm90IGxvY2tlZCIpLCBhdlswXSk7CglyZXQgPSB1bmxpbmtfb3Jfd2FybihnaXRfY29tbW9uX3BhdGgoIndvcmt0cmVlcy8lcy9sb2NrZWQiLCB3dC0+aWQpKTsKCWZyZWVfd29ya3RyZWVzKHdvcmt0cmVlcyk7CglyZXR1cm4gcmV0Owp9CgppbnQgY21kX3dvcmt0cmVlKGludCBhYywgY29uc3QgY2hhciAqKmF2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0cnVjdCBvcHRpb24gb3B0aW9uc1tdID0gewoJCU9QVF9FTkQoKQoJfTsKCglnaXRfY29uZmlnKGdpdF93b3JrdHJlZV9jb25maWcsIE5VTEwpOwoKCWlmIChhYyA8IDIpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKHdvcmt0cmVlX3VzYWdlLCBvcHRpb25zKTsKCWlmICghcHJlZml4KQoJCXByZWZpeCA9ICIiOwoJaWYgKCFzdHJjbXAoYXZbMV0sICJhZGQiKSkKCQlyZXR1cm4gYWRkKGFjIC0gMSwgYXYgKyAxLCBwcmVmaXgpOwoJaWYgKCFzdHJjbXAoYXZbMV0sICJwcnVuZSIpKQoJCXJldHVybiBwcnVuZShhYyAtIDEsIGF2ICsgMSwgcHJlZml4KTsKCWlmICghc3RyY21wKGF2WzFdLCAibGlzdCIpKQoJCXJldHVybiBsaXN0KGFjIC0gMSwgYXYgKyAxLCBwcmVmaXgpOwoJaWYgKCFzdHJjbXAoYXZbMV0sICJsb2NrIikpCgkJcmV0dXJuIGxvY2tfd29ya3RyZWUoYWMgLSAxLCBhdiArIDEsIHByZWZpeCk7CglpZiAoIXN0cmNtcChhdlsxXSwgInVubG9jayIpKQoJCXJldHVybiB1bmxvY2tfd29ya3RyZWUoYWMgLSAxLCBhdiArIDEsIHByZWZpeCk7Cgl1c2FnZV93aXRoX29wdGlvbnMod29ya3RyZWVfdXNhZ2UsIG9wdGlvbnMpOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"checkout.h\"\n#include \"config.h\"\n#include \"builtin.h\"\n#include \"dir.h\"\n#include \"parse-options.h\"\n#include \"argv-array.h\"\n#include \"branch.h\"\n#include \"refs.h\"\n#include \"run-command.h\"\n#include \"sigchain.h\"\n#include \"refs.h\"\n#include \"utf8.h\"\n#include \"worktree.h\"\n\nstatic const char * const worktree_usage[] = {\n\tN_(\"git worktree add [<options>] <path> [<branch>]\"),\n\tN_(\"git worktree list [<options>]\"),\n\tN_(\"git worktree lock [<options>] <path>\"),\n\tN_(\"git worktree prune [<options>]\"),\n\tN_(\"git worktree unlock <path>\"),\n\tNULL\n};\n\nstruct add_opts {\n\tint force;\n\tint detach;\n\tint checkout;\n\tint keep_locked;\n\tconst char *new_branch;\n\tint force_new_branch;\n};\n\nstatic int show_only;\nstatic int verbose;\nstatic int guess_remote;\nstatic timestamp_t expire;\n\nstatic int git_worktree_config(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(var, \"worktree.guessremote\")) {\n\t\tguess_remote = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\treturn git_default_config(var, value, cb);\n}\n\nstatic int prune_worktree(const char *id, struct strbuf *reason)\n{\n\tstruct stat st;\n\tchar *path;\n\tint fd;\n\tsize_t len;\n\tssize_t read_result;\n\n\tif (!is_directory(git_path(\"worktrees/%s\", id))) {\n\t\tstrbuf_addf(reason, _(\"Removing worktrees/%s: not a valid directory\"), id);\n\t\treturn 1;\n\t}\n\tif (file_exists(git_path(\"worktrees/%s/locked\", id)))\n\t\treturn 0;\n\tif (stat(git_path(\"worktrees/%s/gitdir\", id), &st)) {\n\t\tstrbuf_addf(reason, _(\"Removing worktrees/%s: gitdir file does not exist\"), id);\n\t\treturn 1;\n\t}\n\tfd = open(git_path(\"worktrees/%s/gitdir\", id), O_RDONLY);\n\tif (fd < 0) {\n\t\tstrbuf_addf(reason, _(\"Removing worktrees/%s: unable to read gitdir file (%s)\"),\n\t\t\t    id, strerror(errno));\n\t\treturn 1;\n\t}\n\tlen = xsize_t(st.st_size);\n\tpath = xmallocz(len);\n\n\tread_result = read_in_full(fd, path, len);\n\tif (read_result < 0) {\n\t\tstrbuf_addf(reason, _(\"Removing worktrees/%s: unable to read gitdir file (%s)\"),\n\t\t\t    id, strerror(errno));\n\t\tclose(fd);\n\t\tfree(path);\n\t\treturn 1;\n\t}\n\tclose(fd);\n\n\tif (read_result != len) {\n\t\tstrbuf_addf(reason,\n\t\t\t    _(\"Removing worktrees/%s: short read (expected %\"PRIuMAX\" bytes, read %\"PRIuMAX\")\"),\n\t\t\t    id, (uintmax_t)len, (uintmax_t)read_result);\n\t\tfree(path);\n\t\treturn 1;\n\t}\n\twhile (len && (path[len - 1] == '\\n' || path[len - 1] == '\\r'))\n\t\tlen--;\n\tif (!len) {\n\t\tstrbuf_addf(reason, _(\"Removing worktrees/%s: invalid gitdir file\"), id);\n\t\tfree(path);\n\t\treturn 1;\n\t}\n\tpath[len] = '\\0';\n\tif (!file_exists(path)) {\n\t\tstruct stat st_link;\n\t\tfree(path);\n\t\t/*\n\t\t * the repo is moved manually and has not been\n\t\t * accessed since?\n\t\t */\n\t\tif (!stat(git_path(\"worktrees/%s/link\", id), &st_link) &&\n\t\t    st_link.st_nlink > 1)\n\t\t\treturn 0;\n\t\tif (st.st_mtime <= expire) {\n\t\t\tstrbuf_addf(reason, _(\"Removing worktrees/%s: gitdir file points to non-existent location\"), id);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(path);\n\treturn 0;\n}\n\nstatic void prune_worktrees(void)\n{\n\tstruct strbuf reason = STRBUF_INIT;\n\tstruct strbuf path = STRBUF_INIT;\n\tDIR *dir = opendir(git_path(\"worktrees\"));\n\tstruct dirent *d;\n\tint ret;\n\tif (!dir)\n\t\treturn;\n\twhile ((d = readdir(dir)) != NULL) {\n\t\tif (is_dot_or_dotdot(d->d_name))\n\t\t\tcontinue;\n\t\tstrbuf_reset(&reason);\n\t\tif (!prune_worktree(d->d_name, &reason))\n\t\t\tcontinue;\n\t\tif (show_only || verbose)\n\t\t\tprintf(\"%s\\n\", reason.buf);\n\t\tif (show_only)\n\t\t\tcontinue;\n\t\tgit_path_buf(&path, \"worktrees/%s\", d->d_name);\n\t\tret = remove_dir_recursively(&path, 0);\n\t\tif (ret < 0 && errno == ENOTDIR)\n\t\t\tret = unlink(path.buf);\n\t\tif (ret)\n\t\t\terror_errno(_(\"failed to remove '%s'\"), path.buf);\n\t}\n\tclosedir(dir);\n\tif (!show_only)\n\t\trmdir(git_path(\"worktrees\"));\n\tstrbuf_release(&reason);\n\tstrbuf_release(&path);\n}\n\nstatic int prune(int ac, const char **av, const char *prefix)\n{\n\tstruct option options[] = {\n\t\tOPT__DRY_RUN(&show_only, N_(\"do not remove, show only\")),\n\t\tOPT__VERBOSE(&verbose, N_(\"report pruned working trees\")),\n\t\tOPT_EXPIRY_DATE(0, \"expire\", &expire,\n\t\t\t\tN_(\"expire working trees older than <time>\")),\n\t\tOPT_END()\n\t};\n\n\texpire = TIME_MAX;\n\tac = parse_options(ac, av, prefix, options, worktree_usage, 0);\n\tif (ac)\n\t\tusage_with_options(worktree_usage, options);\n\tprune_worktrees();\n\treturn 0;\n}\n\nstatic char *junk_work_tree;\nstatic char *junk_git_dir;\nstatic int is_junk;\nstatic pid_t junk_pid;\n\nstatic void remove_junk(void)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tif (!is_junk || getpid() != junk_pid)\n\t\treturn;\n\tif (junk_git_dir) {\n\t\tstrbuf_addstr(&sb, junk_git_dir);\n\t\tremove_dir_recursively(&sb, 0);\n\t\tstrbuf_reset(&sb);\n\t}\n\tif (junk_work_tree) {\n\t\tstrbuf_addstr(&sb, junk_work_tree);\n\t\tremove_dir_recursively(&sb, 0);\n\t}\n\tstrbuf_release(&sb);\n}\n\nstatic void remove_junk_on_signal(int signo)\n{\n\tremove_junk();\n\tsigchain_pop(signo);\n\traise(signo);\n}\n\nstatic const char *worktree_basename(const char *path, int *olen)\n{\n\tconst char *name;\n\tint len;\n\n\tlen = strlen(path);\n\twhile (len && is_dir_sep(path[len - 1]))\n\t\tlen--;\n\n\tfor (name = path + len - 1; name > path; name--)\n\t\tif (is_dir_sep(*name)) {\n\t\t\tname++;\n\t\t\tbreak;\n\t\t}\n\n\t*olen = len;\n\treturn name;\n}\n\nstatic int add_worktree(const char *path, const char *refname,\n\t\t\tconst struct add_opts *opts)\n{\n\tstruct strbuf sb_git = STRBUF_INIT, sb_repo = STRBUF_INIT;\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *name;\n\tstruct stat st;\n\tstruct child_process cp = CHILD_PROCESS_INIT;\n\tstruct argv_array child_env = ARGV_ARRAY_INIT;\n\tint counter = 0, len, ret;\n\tstruct strbuf symref = STRBUF_INIT;\n\tstruct commit *commit = NULL;\n\n\tif (file_exists(path) && !is_empty_dir(path))\n\t\tdie(_(\"'%s' already exists\"), path);\n\n\t/* is 'refname' a branch or commit? */\n\tif (!opts->detach && !strbuf_check_branch_ref(&symref, refname) &&\n\t\t ref_exists(symref.buf)) { /* it's a branch */\n\t\tif (!opts->force)\n\t\t\tdie_if_checked_out(symref.buf, 0);\n\t} else { /* must be a commit */\n\t\tcommit = lookup_commit_reference_by_name(refname);\n\t\tif (!commit)\n\t\t\tdie(_(\"invalid reference: %s\"), refname);\n\t}\n\n\tname = worktree_basename(path, &len);\n\tgit_path_buf(&sb_repo, \"worktrees/%.*s\", (int)(path + len - name), name);\n\tlen = sb_repo.len;\n\tif (safe_create_leading_directories_const(sb_repo.buf))\n\t\tdie_errno(_(\"could not create leading directories of '%s'\"),\n\t\t\t  sb_repo.buf);\n\twhile (!stat(sb_repo.buf, &st)) {\n\t\tcounter++;\n\t\tstrbuf_setlen(&sb_repo, len);\n\t\tstrbuf_addf(&sb_repo, \"%d\", counter);\n\t}\n\tname = strrchr(sb_repo.buf, '/') + 1;\n\n\tjunk_pid = getpid();\n\tatexit(remove_junk);\n\tsigchain_push_common(remove_junk_on_signal);\n\n\tif (mkdir(sb_repo.buf, 0777))\n\t\tdie_errno(_(\"could not create directory of '%s'\"), sb_repo.buf);\n\tjunk_git_dir = xstrdup(sb_repo.buf);\n\tis_junk = 1;\n\n\t/*\n\t * lock the incomplete repo so prune won't delete it, unlock\n\t * after the preparation is over.\n\t */\n\tstrbuf_addf(&sb, \"%s/locked\", sb_repo.buf);\n\tif (!opts->keep_locked)\n\t\twrite_file(sb.buf, \"initializing\");\n\telse\n\t\twrite_file(sb.buf, \"added with --lock\");\n\n\tstrbuf_addf(&sb_git, \"%s/.git\", path);\n\tif (safe_create_leading_directories_const(sb_git.buf))\n\t\tdie_errno(_(\"could not create leading directories of '%s'\"),\n\t\t\t  sb_git.buf);\n\tjunk_work_tree = xstrdup(path);\n\n\tstrbuf_reset(&sb);\n\tstrbuf_addf(&sb, \"%s/gitdir\", sb_repo.buf);\n\twrite_file(sb.buf, \"%s\", real_path(sb_git.buf));\n\twrite_file(sb_git.buf, \"gitdir: %s/worktrees/%s\",\n\t\t   real_path(get_git_common_dir()), name);\n\t/*\n\t * This is to keep resolve_ref() happy. We need a valid HEAD\n\t * or is_git_directory() will reject the directory. Any value which\n\t * looks like an object ID will do since it will be immediately\n\t * replaced by the symbolic-ref or update-ref invocation in the new\n\t * worktree.\n\t */\n\tstrbuf_reset(&sb);\n\tstrbuf_addf(&sb, \"%s/HEAD\", sb_repo.buf);\n\twrite_file(sb.buf, \"%s\", sha1_to_hex(null_sha1));\n\tstrbuf_reset(&sb);\n\tstrbuf_addf(&sb, \"%s/commondir\", sb_repo.buf);\n\twrite_file(sb.buf, \"../..\");\n\n\tfprintf_ln(stderr, _(\"Preparing %s (identifier %s)\"), path, name);\n\n\targv_array_pushf(&child_env, \"%s=%s\", GIT_DIR_ENVIRONMENT, sb_git.buf);\n\targv_array_pushf(&child_env, \"%s=%s\", GIT_WORK_TREE_ENVIRONMENT, path);\n\tcp.git_cmd = 1;\n\n\tif (commit)\n\t\targv_array_pushl(&cp.args, \"update-ref\", \"HEAD\",\n\t\t\t\t oid_to_hex(&commit->object.oid), NULL);\n\telse\n\t\targv_array_pushl(&cp.args, \"symbolic-ref\", \"HEAD\",\n\t\t\t\t symref.buf, NULL);\n\tcp.env = child_env.argv;\n\tret = run_command(&cp);\n\tif (ret)\n\t\tgoto done;\n\n\tif (opts->checkout) {\n\t\tcp.argv = NULL;\n\t\targv_array_clear(&cp.args);\n\t\targv_array_pushl(&cp.args, \"reset\", \"--hard\", NULL);\n\t\tcp.env = child_env.argv;\n\t\tret = run_command(&cp);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tis_junk = 0;\n\tFREE_AND_NULL(junk_work_tree);\n\tFREE_AND_NULL(junk_git_dir);\n\ndone:\n\tif (ret || !opts->keep_locked) {\n\t\tstrbuf_reset(&sb);\n\t\tstrbuf_addf(&sb, \"%s/locked\", sb_repo.buf);\n\t\tunlink_or_warn(sb.buf);\n\t}\n\targv_array_clear(&child_env);\n\tstrbuf_release(&sb);\n\tstrbuf_release(&symref);\n\tstrbuf_release(&sb_repo);\n\tstrbuf_release(&sb_git);\n\treturn ret;\n}\n\nstatic int add(int ac, const char **av, const char *prefix)\n{\n\tstruct add_opts opts;\n\tconst char *new_branch_force = NULL;\n\tchar *path;\n\tconst char *branch;\n\tconst char *opt_track = NULL;\n\tstruct option options[] = {\n\t\tOPT__FORCE(&opts.force, N_(\"checkout <branch> even if already checked out in other worktree\")),\n\t\tOPT_STRING('b', NULL, &opts.new_branch, N_(\"branch\"),\n\t\t\t   N_(\"create a new branch\")),\n\t\tOPT_STRING('B', NULL, &new_branch_force, N_(\"branch\"),\n\t\t\t   N_(\"create or reset a branch\")),\n\t\tOPT_BOOL(0, \"detach\", &opts.detach, N_(\"detach HEAD at named commit\")),\n\t\tOPT_BOOL(0, \"checkout\", &opts.checkout, N_(\"populate the new working tree\")),\n\t\tOPT_BOOL(0, \"lock\", &opts.keep_locked, N_(\"keep the new working tree locked\")),\n\t\tOPT_PASSTHRU(0, \"track\", &opt_track, NULL,\n\t\t\t     N_(\"set up tracking mode (see git-branch(1))\"),\n\t\t\t     PARSE_OPT_NOARG | PARSE_OPT_OPTARG),\n\t\tOPT_BOOL(0, \"guess-remote\", &guess_remote,\n\t\t\t N_(\"try to match the new branch name with a remote-tracking branch\")),\n\t\tOPT_END()\n\t};\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.checkout = 1;\n\tac = parse_options(ac, av, prefix, options, worktree_usage, 0);\n\tif (!!opts.detach + !!opts.new_branch + !!new_branch_force > 1)\n\t\tdie(_(\"-b, -B, and --detach are mutually exclusive\"));\n\tif (ac < 1 || ac > 2)\n\t\tusage_with_options(worktree_usage, options);\n\n\tpath = prefix_filename(prefix, av[0]);\n\tbranch = ac < 2 ? \"HEAD\" : av[1];\n\n\tif (!strcmp(branch, \"-\"))\n\t\tbranch = \"@{-1}\";\n\n\topts.force_new_branch = !!new_branch_force;\n\tif (opts.force_new_branch) {\n\t\tstruct strbuf symref = STRBUF_INIT;\n\n\t\topts.new_branch = new_branch_force;\n\n\t\tif (!opts.force &&\n\t\t    !strbuf_check_branch_ref(&symref, opts.new_branch) &&\n\t\t    ref_exists(symref.buf))\n\t\t\tdie_if_checked_out(symref.buf, 0);\n\t\tstrbuf_release(&symref);\n\t}\n\n\tif (ac < 2 && !opts.new_branch && !opts.detach) {\n\t\tint n;\n\t\tconst char *s = worktree_basename(path, &n);\n\t\topts.new_branch = xstrndup(s, n);\n\t\tif (guess_remote) {\n\t\t\tstruct object_id oid;\n\t\t\tconst char *remote =\n\t\t\t\tunique_tracking_name(opts.new_branch, &oid);\n\t\t\tif (remote)\n\t\t\t\tbranch = remote;\n\t\t}\n\t}\n\n\tif (ac == 2 && !opts.new_branch && !opts.detach) {\n\t\tstruct object_id oid;\n\t\tstruct commit *commit;\n\t\tconst char *remote;\n\n\t\tcommit = lookup_commit_reference_by_name(branch);\n\t\tif (!commit) {\n\t\t\tremote = unique_tracking_name(branch, &oid);\n\t\t\tif (remote) {\n\t\t\t\topts.new_branch = branch;\n\t\t\t\tbranch = remote;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (opts.new_branch) {\n\t\tstruct child_process cp = CHILD_PROCESS_INIT;\n\t\tcp.git_cmd = 1;\n\t\targv_array_push(&cp.args, \"branch\");\n\t\tif (opts.force_new_branch)\n\t\t\targv_array_push(&cp.args, \"--force\");\n\t\targv_array_push(&cp.args, opts.new_branch);\n\t\targv_array_push(&cp.args, branch);\n\t\tif (opt_track)\n\t\t\targv_array_push(&cp.args, opt_track);\n\t\tif (run_command(&cp))\n\t\t\treturn -1;\n\t\tbranch = opts.new_branch;\n\t} else if (opt_track) {\n\t\tdie(_(\"--[no-]track can only be used if a new branch is created\"));\n\t}\n\n\tUNLEAK(path);\n\tUNLEAK(opts);\n\treturn add_worktree(path, branch, &opts);\n}\n\nstatic void show_worktree_porcelain(struct worktree *wt)\n{\n\tprintf(\"worktree %s\\n\", wt->path);\n\tif (wt->is_bare)\n\t\tprintf(\"bare\\n\");\n\telse {\n\t\tprintf(\"HEAD %s\\n\", oid_to_hex(&wt->head_oid));\n\t\tif (wt->is_detached)\n\t\t\tprintf(\"detached\\n\");\n\t\telse if (wt->head_ref)\n\t\t\tprintf(\"branch %s\\n\", wt->head_ref);\n\t}\n\tprintf(\"\\n\");\n}\n\nstatic void show_worktree(struct worktree *wt, int path_maxlen, int abbrev_len)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tint cur_path_len = strlen(wt->path);\n\tint path_adj = cur_path_len - utf8_strwidth(wt->path);\n\n\tstrbuf_addf(&sb, \"%-*s \", 1 + path_maxlen + path_adj, wt->path);\n\tif (wt->is_bare)\n\t\tstrbuf_addstr(&sb, \"(bare)\");\n\telse {\n\t\tstrbuf_addf(&sb, \"%-*s \", abbrev_len,\n\t\t\t\tfind_unique_abbrev(wt->head_oid.hash, DEFAULT_ABBREV));\n\t\tif (wt->is_detached)\n\t\t\tstrbuf_addstr(&sb, \"(detached HEAD)\");\n\t\telse if (wt->head_ref) {\n\t\t\tchar *ref = shorten_unambiguous_ref(wt->head_ref, 0);\n\t\t\tstrbuf_addf(&sb, \"[%s]\", ref);\n\t\t\tfree(ref);\n\t\t} else\n\t\t\tstrbuf_addstr(&sb, \"(error)\");\n\t}\n\tprintf(\"%s\\n\", sb.buf);\n\n\tstrbuf_release(&sb);\n}\n\nstatic void measure_widths(struct worktree **wt, int *abbrev, int *maxlen)\n{\n\tint i;\n\n\tfor (i = 0; wt[i]; i++) {\n\t\tint sha1_len;\n\t\tint path_len = strlen(wt[i]->path);\n\n\t\tif (path_len > *maxlen)\n\t\t\t*maxlen = path_len;\n\t\tsha1_len = strlen(find_unique_abbrev(wt[i]->head_oid.hash, *abbrev));\n\t\tif (sha1_len > *abbrev)\n\t\t\t*abbrev = sha1_len;\n\t}\n}\n\nstatic int list(int ac, const char **av, const char *prefix)\n{\n\tint porcelain = 0;\n\n\tstruct option options[] = {\n\t\tOPT_BOOL(0, \"porcelain\", &porcelain, N_(\"machine-readable output\")),\n\t\tOPT_END()\n\t};\n\n\tac = parse_options(ac, av, prefix, options, worktree_usage, 0);\n\tif (ac)\n\t\tusage_with_options(worktree_usage, options);\n\telse {\n\t\tstruct worktree **worktrees = get_worktrees(GWT_SORT_LINKED);\n\t\tint path_maxlen = 0, abbrev = DEFAULT_ABBREV, i;\n\n\t\tif (!porcelain)\n\t\t\tmeasure_widths(worktrees, &abbrev, &path_maxlen);\n\n\t\tfor (i = 0; worktrees[i]; i++) {\n\t\t\tif (porcelain)\n\t\t\t\tshow_worktree_porcelain(worktrees[i]);\n\t\t\telse\n\t\t\t\tshow_worktree(worktrees[i], path_maxlen, abbrev);\n\t\t}\n\t\tfree_worktrees(worktrees);\n\t}\n\treturn 0;\n}\n\nstatic int lock_worktree(int ac, const char **av, const char *prefix)\n{\n\tconst char *reason = \"\", *old_reason;\n\tstruct option options[] = {\n\t\tOPT_STRING(0, \"reason\", &reason, N_(\"string\"),\n\t\t\t   N_(\"reason for locking\")),\n\t\tOPT_END()\n\t};\n\tstruct worktree **worktrees, *wt;\n\n\tac = parse_options(ac, av, prefix, options, worktree_usage, 0);\n\tif (ac != 1)\n\t\tusage_with_options(worktree_usage, options);\n\n\tworktrees = get_worktrees(0);\n\twt = find_worktree(worktrees, prefix, av[0]);\n\tif (!wt)\n\t\tdie(_(\"'%s' is not a working tree\"), av[0]);\n\tif (is_main_worktree(wt))\n\t\tdie(_(\"The main working tree cannot be locked or unlocked\"));\n\n\told_reason = is_worktree_locked(wt);\n\tif (old_reason) {\n\t\tif (*old_reason)\n\t\t\tdie(_(\"'%s' is already locked, reason: %s\"),\n\t\t\t    av[0], old_reason);\n\t\tdie(_(\"'%s' is already locked\"), av[0]);\n\t}\n\n\twrite_file(git_common_path(\"worktrees/%s/locked\", wt->id),\n\t\t   \"%s\", reason);\n\tfree_worktrees(worktrees);\n\treturn 0;\n}\n\nstatic int unlock_worktree(int ac, const char **av, const char *prefix)\n{\n\tstruct option options[] = {\n\t\tOPT_END()\n\t};\n\tstruct worktree **worktrees, *wt;\n\tint ret;\n\n\tac = parse_options(ac, av, prefix, options, worktree_usage, 0);\n\tif (ac != 1)\n\t\tusage_with_options(worktree_usage, options);\n\n\tworktrees = get_worktrees(0);\n\twt = find_worktree(worktrees, prefix, av[0]);\n\tif (!wt)\n\t\tdie(_(\"'%s' is not a working tree\"), av[0]);\n\tif (is_main_worktree(wt))\n\t\tdie(_(\"The main working tree cannot be locked or unlocked\"));\n\tif (!is_worktree_locked(wt))\n\t\tdie(_(\"'%s' is not locked\"), av[0]);\n\tret = unlink_or_warn(git_common_path(\"worktrees/%s/locked\", wt->id));\n\tfree_worktrees(worktrees);\n\treturn ret;\n}\n\nint cmd_worktree(int ac, const char **av, const char *prefix)\n{\n\tstruct option options[] = {\n\t\tOPT_END()\n\t};\n\n\tgit_config(git_worktree_config, NULL);\n\n\tif (ac < 2)\n\t\tusage_with_options(worktree_usage, options);\n\tif (!prefix)\n\t\tprefix = \"\";\n\tif (!strcmp(av[1], \"add\"))\n\t\treturn add(ac - 1, av + 1, prefix);\n\tif (!strcmp(av[1], \"prune\"))\n\t\treturn prune(ac - 1, av + 1, prefix);\n\tif (!strcmp(av[1], \"list\"))\n\t\treturn list(ac - 1, av + 1, prefix);\n\tif (!strcmp(av[1], \"lock\"))\n\t\treturn lock_worktree(ac - 1, av + 1, prefix);\n\tif (!strcmp(av[1], \"unlock\"))\n\t\treturn unlock_worktree(ac - 1, av + 1, prefix);\n\tusage_with_options(worktree_usage, options);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "002a569a11a8d67a7c94f37533c574d496026e7b",
  "sha1_ok": true,
  "size": 16276
}
