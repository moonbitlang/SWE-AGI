{
  "content": {
    "base64": "LyoKICogR0lUIC0gVGhlIGluZm9ybWF0aW9uIG1hbmFnZXIgZnJvbSBoZWxsCiAqCiAqIENvcHlyaWdodCAoQykgTGludXMgVG9ydmFsZHMsIDIwMDUKICovCgojaW5jbHVkZSA8c3RkaW8uaD4KI2luY2x1ZGUgPHN0ZGxpYi5oPgojaW5jbHVkZSA8c3RyaW5nLmg+CiNpbmNsdWRlIDxjdHlwZS5oPgojaW5jbHVkZSA8dGltZS5oPgoKc3RhdGljIHRpbWVfdCBteV9ta3RpbWUoc3RydWN0IHRtICp0bSkKewoJc3RhdGljIGNvbnN0IGludCBtZGF5c1tdID0gewoJICAgIDAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0Cgl9OwoJaW50IHllYXIgPSB0bS0+dG1feWVhciAtIDcwOwoJaW50IG1vbnRoID0gdG0tPnRtX21vbjsKCWludCBkYXkgPSB0bS0+dG1fbWRheTsKCglpZiAoeWVhciA8IDAgfHwgeWVhciA+IDEyOSkgLyogYWxnbyBvbmx5IHdvcmtzIGZvciAxOTcwLTIwOTkgKi8KCQlyZXR1cm4gLTE7CglpZiAobW9udGggPCAwIHx8IG1vbnRoID4gMTEpIC8qIGFycmF5IGJvdW5kcyAqLwoJCXJldHVybiAtMTsKCWlmIChtb250aCA8IDIgfHwgKHllYXIgKyAyKSAlIDQpCgkJZGF5LS07CglyZXR1cm4gKHllYXIgKiAzNjUgKyAoeWVhciArIDEpIC8gNCArIG1kYXlzW21vbnRoXSArIGRheSkgKiAyNCo2MCo2MFVMICsKCQl0bS0+dG1faG91ciAqIDYwKjYwICsgdG0tPnRtX21pbiAqIDYwICsgdG0tPnRtX3NlYzsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKm1vbnRoX25hbWVzW10gPSB7CgkiSmFudWFyeSIsICJGZWJydWFyeSIsICJNYXJjaCIsICJBcHJpbCIsICJNYXkiLCAiSnVuZSIsCgkiSnVseSIsICJBdWd1c3QiLCAiU2VwdGVtYmVyIiwgIk9jdG9iZXIiLCAiTm92ZW1iZXIiLCAiRGVjZW1iZXIiCn07CgpzdGF0aWMgY29uc3QgY2hhciAqd2Vla2RheV9uYW1lc1tdID0gewoJIlN1bmRheSIsICJNb25kYXkiLCAiVHVlc2RheSIsICJXZWRuZXNkYXkiLCAiVGh1cnNkYXkiLCAiRnJpZGF5IiwgIlNhdHVyZGF5Igp9OwoKLyoKICogQ2hlY2sgdGhlc2UuIEFuZCBub3RlIGhvdyBpdCBkb2Vzbid0IGRvIHRoZSBzdW1tZXItdGltZSBjb252ZXJzaW9uLgogKgogKiBJbiBteSB3b3JsZCwgaXQncyBhbHdheXMgc3VtbWVyLCBhbmQgdGhpbmdzIGFyZSBwcm9iYWJseSBhIGJpdCBvZmYKICogaW4gb3RoZXIgd2F5cyB0b28uCiAqLwpzdGF0aWMgY29uc3Qgc3RydWN0IHsKCWNvbnN0IGNoYXIgKm5hbWU7CglpbnQgb2Zmc2V0OwoJaW50IGRzdDsKfSB0aW1lem9uZV9uYW1lc1tdID0gewoJeyAiSURMVyIsIC0xMiwgMCwgfSwJLyogSW50ZXJuYXRpb25hbCBEYXRlIExpbmUgV2VzdCAqLwoJeyAiTlQiLCAgIC0xMSwgMCwgfSwJLyogTm9tZSAqLwoJeyAiQ0FUIiwgIC0xMCwgMCwgfSwJLyogQ2VudHJhbCBBbGFza2EgKi8KCXsgIkhTVCIsICAtMTAsIDAsIH0sCS8qIEhhd2FpaSBTdGFuZGFyZCAqLwoJeyAiSERUIiwgIC0xMCwgMSwgfSwJLyogSGF3YWlpIERheWxpZ2h0ICovCgl7ICJZU1QiLCAgIC05LCAwLCB9LAkvKiBZdWtvbiBTdGFuZGFyZCAqLwoJeyAiWURUIiwgICAtOSwgMSwgfSwJLyogWXVrb24gRGF5bGlnaHQgKi8KCXsgIlBTVCIsICAgLTgsIDAsIH0sCS8qIFBhY2lmaWMgU3RhbmRhcmQgKi8KCXsgIlBEVCIsICAgLTgsIDEsIH0sCS8qIFBhY2lmaWMgRGF5bGlnaHQgKi8KCXsgIk1TVCIsICAgLTcsIDAsIH0sCS8qIE1vdW50YWluIFN0YW5kYXJkICovCgl7ICJNRFQiLCAgIC03LCAxLCB9LAkvKiBNb3VudGFpbiBEYXlsaWdodCAqLwoJeyAiQ1NUIiwgICAtNiwgMCwgfSwJLyogQ2VudHJhbCBTdGFuZGFyZCAqLwoJeyAiQ0RUIiwgICAtNiwgMSwgfSwJLyogQ2VudHJhbCBEYXlsaWdodCAqLwoJeyAiRVNUIiwgICAtNSwgMCwgfSwJLyogRWFzdGVybiBTdGFuZGFyZCAqLwoJeyAiRURUIiwgICAtNSwgMSwgfSwJLyogRWFzdGVybiBEYXlsaWdodCAqLwoJeyAiQVNUIiwgICAtMywgMCwgfSwJLyogQXRsYW50aWMgU3RhbmRhcmQgKi8KCXsgIkFEVCIsICAgLTMsIDEsIH0sCS8qIEF0bGFudGljIERheWxpZ2h0ICovCgl7ICJXQVQiLCAgIC0xLCAwLCB9LAkvKiBXZXN0IEFmcmljYSAqLwoKCXsgIkdNVCIsICAgIDAsIDAsIH0sCS8qIEdyZWVud2ljaCBNZWFuICovCgl7ICJVVEMiLCAgICAwLCAwLCB9LAkvKiBVbml2ZXJzYWwgKENvb3JkaW5hdGVkKSAqLwoKCXsgIldFVCIsICAgIDAsIDAsIH0sCS8qIFdlc3Rlcm4gRXVyb3BlYW4gKi8KCXsgIkJTVCIsICAgIDAsIDEsIH0sCS8qIEJyaXRpc2ggU3VtbWVyICovCgl7ICJDRVQiLCAgICsxLCAwLCB9LAkvKiBDZW50cmFsIEV1cm9wZWFuICovCgl7ICJNRVQiLCAgICsxLCAwLCB9LAkvKiBNaWRkbGUgRXVyb3BlYW4gKi8KCXsgIk1FV1QiLCAgKzEsIDAsIH0sCS8qIE1pZGRsZSBFdXJvcGVhbiBXaW50ZXIgKi8KCXsgIk1FU1QiLCAgKzEsIDEsIH0sCS8qIE1pZGRsZSBFdXJvcGVhbiBTdW1tZXIgKi8KCXsgIkNFU1QiLCAgKzEsIDEsIH0sCS8qIENlbnRyYWwgRXVyb3BlYW4gU3VtbWVyICovCgl7ICJNRVNaIiwgICsxLCAxLCB9LAkvKiBNaWRkbGUgRXVyb3BlYW4gU3VtbWVyICovCgl7ICJGV1QiLCAgICsxLCAwLCB9LAkvKiBGcmVuY2ggV2ludGVyICovCgl7ICJGU1QiLCAgICsxLCAxLCB9LAkvKiBGcmVuY2ggU3VtbWVyICovCgl7ICJFRVQiLCAgICsyLCAwLCB9LAkvKiBFYXN0ZXJuIEV1cm9wZSwgVVNTUiBab25lIDEgKi8KCXsgIldBU1QiLCAgKzcsIDAsIH0sCS8qIFdlc3QgQXVzdHJhbGlhbiBTdGFuZGFyZCAqLwoJeyAiV0FEVCIsICArNywgMSwgfSwJLyogV2VzdCBBdXN0cmFsaWFuIERheWxpZ2h0ICovCgl7ICJDQ1QiLCAgICs4LCAwLCB9LAkvKiBDaGluYSBDb2FzdCwgVVNTUiBab25lIDcgKi8KCXsgIkpTVCIsICAgKzksIDAsIH0sCS8qIEphcGFuIFN0YW5kYXJkLCBVU1NSIFpvbmUgOCAqLwoJeyAiRUFTVCIsICsxMCwgMCwgfSwJLyogRWFzdGVybiBBdXN0cmFsaWFuIFN0YW5kYXJkICovCgl7ICJFQURUIiwgKzEwLCAxLCB9LAkvKiBFYXN0ZXJuIEF1c3RyYWxpYW4gRGF5bGlnaHQgKi8KCXsgIkdTVCIsICArMTAsIDAsIH0sCS8qIEd1YW0gU3RhbmRhcmQsIFVTU1IgWm9uZSA5ICovCgl7ICJOWlQiLCAgKzExLCAwLCB9LAkvKiBOZXcgWmVhbGFuZCAqLwoJeyAiTlpTVCIsICsxMSwgMCwgfSwJLyogTmV3IFplYWxhbmQgU3RhbmRhcmQgKi8KCXsgIk5aRFQiLCArMTEsIDEsIH0sCS8qIE5ldyBaZWFsYW5kIERheWxpZ2h0ICovCgl7ICJJRExFIiwgKzEyLCAwLCB9LAkvKiBJbnRlcm5hdGlvbmFsIERhdGUgTGluZSBFYXN0ICovCn07CgojZGVmaW5lIE5SX1RaIChzaXplb2YodGltZXpvbmVfbmFtZXMpIC8gc2l6ZW9mKHRpbWV6b25lX25hbWVzWzBdKSkKCQpzdGF0aWMgaW50IG1hdGNoX3N0cmluZyhjb25zdCBjaGFyICpkYXRlLCBjb25zdCBjaGFyICpzdHIpCnsKCWludCBpID0gMDsKCglmb3IgKGkgPSAwOyAqZGF0ZTsgZGF0ZSsrLCBzdHIrKywgaSsrKSB7CgkJaWYgKCpkYXRlID09ICpzdHIpCgkJCWNvbnRpbnVlOwoJCWlmICh0b3VwcGVyKCpkYXRlKSA9PSB0b3VwcGVyKCpzdHIpKQoJCQljb250aW51ZTsKCQlpZiAoIWlzYWxudW0oKmRhdGUpKQoJCQlicmVhazsKCQlyZXR1cm4gMDsKCX0KCXJldHVybiBpOwp9CgovKgoqIFBhcnNlIG1vbnRoLCB3ZWVrZGF5LCBvciB0aW1lem9uZSBuYW1lCiovCnN0YXRpYyBpbnQgbWF0Y2hfYWxwaGEoY29uc3QgY2hhciAqZGF0ZSwgc3RydWN0IHRtICp0bSwgaW50ICpvZmZzZXQpCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7CgkJaW50IG1hdGNoID0gbWF0Y2hfc3RyaW5nKGRhdGUsIG1vbnRoX25hbWVzW2ldKTsKCQlpZiAobWF0Y2ggPj0gMykgewoJCQl0bS0+dG1fbW9uID0gaTsKCQkJcmV0dXJuIG1hdGNoOwoJCX0KCX0KCglmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7CgkJaW50IG1hdGNoID0gbWF0Y2hfc3RyaW5nKGRhdGUsIHdlZWtkYXlfbmFtZXNbaV0pOwoJCWlmIChtYXRjaCA+PSAzKSB7CgkJCXRtLT50bV93ZGF5ID0gaTsKCQkJcmV0dXJuIG1hdGNoOwoJCX0KCX0KCglmb3IgKGkgPSAwOyBpIDwgTlJfVFo7IGkrKykgewoJCWludCBtYXRjaCA9IG1hdGNoX3N0cmluZyhkYXRlLCB0aW1lem9uZV9uYW1lc1tpXS5uYW1lKTsKCQlpZiAobWF0Y2ggPj0gMykgewoJCQlpbnQgb2ZmID0gdGltZXpvbmVfbmFtZXNbaV0ub2Zmc2V0OwoKCQkJLyogVGhpcyBpcyBib2d1cywgYnV0IHdlIGxpa2Ugc3VtbWVyICovCgkJCW9mZiArPSB0aW1lem9uZV9uYW1lc1tpXS5kc3Q7CgoJCQkqb2Zmc2V0ID0gNjAqb2ZmOwoJCQlyZXR1cm4gbWF0Y2g7CgkJfQoJfQoKCS8qIEJBRCBDUkFQICovCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBtYXRjaF9kaWdpdChjaGFyICpkYXRlLCBzdHJ1Y3QgdG0gKnRtLCBpbnQgKm9mZnNldCkKewoJY2hhciAqZW5kLCBjOwoJdW5zaWduZWQgbG9uZyBudW0sIG51bTIsIG51bTM7CgoJbnVtID0gc3RydG91bChkYXRlLCAmZW5kLCAxMCk7CgoJLyogVGltZT8gbnVtOm51bVs6bnVtXSAqLwoJaWYgKG51bSA8IDI0ICYmIGVuZFswXSA9PSAnOicgJiYgaXNkaWdpdChlbmRbMV0pKSB7CgkJdG0tPnRtX2hvdXIgPSBudW07CgkJbnVtID0gc3RydG91bChlbmQrMSwgJmVuZCwgMTApOwoJCWlmIChudW0gPCA2MCkgewoJCQl0bS0+dG1fbWluID0gbnVtOwoJCQlpZiAoZW5kWzBdID09ICc6JyAmJiBpc2RpZ2l0KGVuZFsxXSkpIHsKCQkJCW51bSA9IHN0cnRvdWwoZW5kKzEsICZlbmQsIDEwKTsKCQkJCWlmIChudW0gPCA2MSkKCQkJCQl0bS0+dG1fc2VjID0gbnVtOwoJCQl9CgkJfQoJCXJldHVybiBlbmQgLSBkYXRlOwoJfQoKCS8qIFllYXI/IERheSBvZiBtb250aD8gTnVtZXJpYyBkYXRlLXN0cmluZz8qLwoJYyA9ICplbmQ7Cglzd2l0Y2ggKGMpIHsKCWRlZmF1bHQ6CgkJaWYgKG51bSA+IDAgJiYgbnVtIDwgMzIpIHsKCQkJdG0tPnRtX21kYXkgPSBudW07CgkJCWJyZWFrOwoJCX0KCQlpZiAobnVtID4gMTkwMCkgewoJCQl0bS0+dG1feWVhciA9IG51bSAtIDE5MDA7CgkJCWJyZWFrOwoJCX0KCQlpZiAobnVtID4gNzApIHsKCQkJdG0tPnRtX3llYXIgPSBudW07CgkJCWJyZWFrOwoJCX0KCQlicmVhazsKCgljYXNlICctJzoKCWNhc2UgJy8nOgoJCWlmIChudW0gJiYgbnVtIDwgMzIgJiYgaXNkaWdpdChlbmRbMV0pKSB7CgkJCW51bTIgPSBzdHJ0b3VsKGVuZCsxLCAmZW5kLCAxMCk7CgkJCWlmICghbnVtMiB8fCBudW0yID4gMzEpCgkJCQlicmVhazsKCQkJaWYgKG51bSA+IDEyKSB7CgkJCQlpZiAobnVtMiA+IDEyKQoJCQkJCWJyZWFrOwoJCQkJbnVtMyA9IG51bTsKCQkJCW51bSAgPSBudW0yOwoJCQkJbnVtMiA9IG51bTM7CgkJCX0KCQkJdG0tPnRtX21vbiA9IG51bSAtIDE7CgkJCXRtLT50bV9tZGF5ID0gbnVtMjsKCQkJaWYgKCplbmQgPT0gYyAmJiBpc2RpZ2l0KGVuZFsxXSkpIHsKCQkJCW51bTMgPSBzdHJ0b3VsKGVuZCsxLCAmZW5kLCAxMCk7CgkJCQlpZiAobnVtMyA+IDE5MDApCgkJCQkJbnVtMyAtPSAxOTAwOwoJCQkJZWxzZSBpZiAobnVtMyA8IDM4KQoJCQkJCW51bTMgKz0gMTAwOwoJCQkJdG0tPnRtX3llYXIgPSBudW0zOwoJCQl9CgkJCWJyZWFrOwoJCX0KCX0KCQkKCXJldHVybiBlbmQgLSBkYXRlOwoJCQkKfQoKc3RhdGljIGludCBtYXRjaF90eihjaGFyICpkYXRlLCBpbnQgKm9mZnApCnsKCWNoYXIgKmVuZDsKCWludCBvZmZzZXQgPSBzdHJ0b3VsKGRhdGUrMSwgJmVuZCwgMTApOwoJaW50IG1pbiwgaG91cjsKCgltaW4gPSBvZmZzZXQgJSAxMDA7Cglob3VyID0gb2Zmc2V0IC8gMTAwOwoKCW9mZnNldCA9IGhvdXIqNjArbWluOwoJaWYgKCpkYXRlID09ICctJykKCQlvZmZzZXQgPSAtb2Zmc2V0OwoKCSpvZmZwID0gb2Zmc2V0OwoJcmV0dXJuIGVuZCAtIGRhdGU7Cn0KCi8qIEdyLiBzdHJwdGltZSBpcyBjcmFwIGZvciB0aGlzOyBpdCBkb2Vzbid0IGhhdmUgYSB3YXkgdG8gcmVxdWlyZSBSRkMyODIyCiAgIChpLmUuIEVuZ2xpc2gpIGRheS9tb250aCBuYW1lcywgYW5kIGl0IGRvZXNuJ3Qgd29yayBjb3JyZWN0bHkgd2l0aCAlei4gKi8Kdm9pZCBwYXJzZV9kYXRlKGNoYXIgKmRhdGUsIGNoYXIgKnJlc3VsdCwgaW50IG1heGxlbikKewoJc3RydWN0IHRtIHRtOwoJaW50IG9mZnNldDsKCXRpbWVfdCB0aGVuOwoKCW1lbXNldCgmdG0sIDAsIHNpemVvZih0bSkpOwoJdG0udG1feWVhciA9IC0xOwoJdG0udG1fbW9uID0gLTE7Cgl0bS50bV9tZGF5ID0gLTE7Cgl0bS50bV9pc2RzdCA9IC0xOwoJb2Zmc2V0ID0gLTE7CgoJZm9yICg7OykgewoJCWludCBtYXRjaCA9IDA7CgkJdW5zaWduZWQgY2hhciBjID0gKmRhdGU7CgoJCS8qIFN0b3AgYXQgZW5kIG9mIHN0cmluZyBvciBuZXdsaW5lICovCgkJaWYgKCFjIHx8IGMgPT0gJ1xuJykKCQkJYnJlYWs7CgoJCWlmIChpc2FscGhhKGMpKQoJCQltYXRjaCA9IG1hdGNoX2FscGhhKGRhdGUsICZ0bSwgJm9mZnNldCk7CgkJZWxzZSBpZiAoaXNkaWdpdChjKSkKCQkJbWF0Y2ggPSBtYXRjaF9kaWdpdChkYXRlLCAmdG0sICZvZmZzZXQpOwoJCWVsc2UgaWYgKChjID09ICctJyB8fCBjID09ICcrJykgJiYgaXNkaWdpdChkYXRlWzFdKSkKCQkJbWF0Y2ggPSBtYXRjaF90eihkYXRlLCAmb2Zmc2V0KTsKCgkJaWYgKCFtYXRjaCkgewoJCQkvKiBCQUQgQ1JBUCAqLwoJCQltYXRjaCA9IDE7CgkJfQkKCgkJZGF0ZSArPSBtYXRjaDsKCX0KCgkvKiBta3RpbWUgdXNlcyBsb2NhbCB0aW1lem9uZSAqLwoJdGhlbiA9IG15X21rdGltZSgmdG0pOyAKCWlmIChvZmZzZXQgPT0gLTEpCgkJb2Zmc2V0ID0gKHRoZW4gLSBta3RpbWUoJnRtKSkgLyA2MDsKCglpZiAodGhlbiA9PSAtMSkKCQlyZXR1cm47CgoJdGhlbiAtPSBvZmZzZXQgKiA2MDsKCglzbnByaW50ZihyZXN1bHQsIG1heGxlbiwgIiVsdSAlKzAzZCUwMmQiLCB0aGVuLCBvZmZzZXQvNjAsIG9mZnNldCAlIDYwKTsKfQoKdm9pZCBkYXRlc3RhbXAoY2hhciAqYnVmLCBpbnQgYnVmc2l6ZSkKewoJdGltZV90IG5vdzsKCWludCBvZmZzZXQ7CgoJdGltZSgmbm93KTsKCglvZmZzZXQgPSBteV9ta3RpbWUobG9jYWx0aW1lKCZub3cpKSAtIG5vdzsKCW9mZnNldCAvPSA2MDsKCglzbnByaW50ZihidWYsIGJ1ZnNpemUsICIlbHUgJSswNWQiLCBub3csIG9mZnNldC82MCoxMDAgKyBvZmZzZXQlNjApOwp9Cg==",
    "text": "/*\n * GIT - The information manager from hell\n *\n * Copyright (C) Linus Torvalds, 2005\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n\nstatic time_t my_mktime(struct tm *tm)\n{\n\tstatic const int mdays[] = {\n\t    0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334\n\t};\n\tint year = tm->tm_year - 70;\n\tint month = tm->tm_mon;\n\tint day = tm->tm_mday;\n\n\tif (year < 0 || year > 129) /* algo only works for 1970-2099 */\n\t\treturn -1;\n\tif (month < 0 || month > 11) /* array bounds */\n\t\treturn -1;\n\tif (month < 2 || (year + 2) % 4)\n\t\tday--;\n\treturn (year * 365 + (year + 1) / 4 + mdays[month] + day) * 24*60*60UL +\n\t\ttm->tm_hour * 60*60 + tm->tm_min * 60 + tm->tm_sec;\n}\n\nstatic const char *month_names[] = {\n\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n\t\"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n};\n\nstatic const char *weekday_names[] = {\n\t\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"\n};\n\n/*\n * Check these. And note how it doesn't do the summer-time conversion.\n *\n * In my world, it's always summer, and things are probably a bit off\n * in other ways too.\n */\nstatic const struct {\n\tconst char *name;\n\tint offset;\n\tint dst;\n} timezone_names[] = {\n\t{ \"IDLW\", -12, 0, },\t/* International Date Line West */\n\t{ \"NT\",   -11, 0, },\t/* Nome */\n\t{ \"CAT\",  -10, 0, },\t/* Central Alaska */\n\t{ \"HST\",  -10, 0, },\t/* Hawaii Standard */\n\t{ \"HDT\",  -10, 1, },\t/* Hawaii Daylight */\n\t{ \"YST\",   -9, 0, },\t/* Yukon Standard */\n\t{ \"YDT\",   -9, 1, },\t/* Yukon Daylight */\n\t{ \"PST\",   -8, 0, },\t/* Pacific Standard */\n\t{ \"PDT\",   -8, 1, },\t/* Pacific Daylight */\n\t{ \"MST\",   -7, 0, },\t/* Mountain Standard */\n\t{ \"MDT\",   -7, 1, },\t/* Mountain Daylight */\n\t{ \"CST\",   -6, 0, },\t/* Central Standard */\n\t{ \"CDT\",   -6, 1, },\t/* Central Daylight */\n\t{ \"EST\",   -5, 0, },\t/* Eastern Standard */\n\t{ \"EDT\",   -5, 1, },\t/* Eastern Daylight */\n\t{ \"AST\",   -3, 0, },\t/* Atlantic Standard */\n\t{ \"ADT\",   -3, 1, },\t/* Atlantic Daylight */\n\t{ \"WAT\",   -1, 0, },\t/* West Africa */\n\n\t{ \"GMT\",    0, 0, },\t/* Greenwich Mean */\n\t{ \"UTC\",    0, 0, },\t/* Universal (Coordinated) */\n\n\t{ \"WET\",    0, 0, },\t/* Western European */\n\t{ \"BST\",    0, 1, },\t/* British Summer */\n\t{ \"CET\",   +1, 0, },\t/* Central European */\n\t{ \"MET\",   +1, 0, },\t/* Middle European */\n\t{ \"MEWT\",  +1, 0, },\t/* Middle European Winter */\n\t{ \"MEST\",  +1, 1, },\t/* Middle European Summer */\n\t{ \"CEST\",  +1, 1, },\t/* Central European Summer */\n\t{ \"MESZ\",  +1, 1, },\t/* Middle European Summer */\n\t{ \"FWT\",   +1, 0, },\t/* French Winter */\n\t{ \"FST\",   +1, 1, },\t/* French Summer */\n\t{ \"EET\",   +2, 0, },\t/* Eastern Europe, USSR Zone 1 */\n\t{ \"WAST\",  +7, 0, },\t/* West Australian Standard */\n\t{ \"WADT\",  +7, 1, },\t/* West Australian Daylight */\n\t{ \"CCT\",   +8, 0, },\t/* China Coast, USSR Zone 7 */\n\t{ \"JST\",   +9, 0, },\t/* Japan Standard, USSR Zone 8 */\n\t{ \"EAST\", +10, 0, },\t/* Eastern Australian Standard */\n\t{ \"EADT\", +10, 1, },\t/* Eastern Australian Daylight */\n\t{ \"GST\",  +10, 0, },\t/* Guam Standard, USSR Zone 9 */\n\t{ \"NZT\",  +11, 0, },\t/* New Zealand */\n\t{ \"NZST\", +11, 0, },\t/* New Zealand Standard */\n\t{ \"NZDT\", +11, 1, },\t/* New Zealand Daylight */\n\t{ \"IDLE\", +12, 0, },\t/* International Date Line East */\n};\n\n#define NR_TZ (sizeof(timezone_names) / sizeof(timezone_names[0]))\n\t\nstatic int match_string(const char *date, const char *str)\n{\n\tint i = 0;\n\n\tfor (i = 0; *date; date++, str++, i++) {\n\t\tif (*date == *str)\n\t\t\tcontinue;\n\t\tif (toupper(*date) == toupper(*str))\n\t\t\tcontinue;\n\t\tif (!isalnum(*date))\n\t\t\tbreak;\n\t\treturn 0;\n\t}\n\treturn i;\n}\n\n/*\n* Parse month, weekday, or timezone name\n*/\nstatic int match_alpha(const char *date, struct tm *tm, int *offset)\n{\n\tint i;\n\n\tfor (i = 0; i < 12; i++) {\n\t\tint match = match_string(date, month_names[i]);\n\t\tif (match >= 3) {\n\t\t\ttm->tm_mon = i;\n\t\t\treturn match;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 7; i++) {\n\t\tint match = match_string(date, weekday_names[i]);\n\t\tif (match >= 3) {\n\t\t\ttm->tm_wday = i;\n\t\t\treturn match;\n\t\t}\n\t}\n\n\tfor (i = 0; i < NR_TZ; i++) {\n\t\tint match = match_string(date, timezone_names[i].name);\n\t\tif (match >= 3) {\n\t\t\tint off = timezone_names[i].offset;\n\n\t\t\t/* This is bogus, but we like summer */\n\t\t\toff += timezone_names[i].dst;\n\n\t\t\t*offset = 60*off;\n\t\t\treturn match;\n\t\t}\n\t}\n\n\t/* BAD CRAP */\n\treturn 0;\n}\n\nstatic int match_digit(char *date, struct tm *tm, int *offset)\n{\n\tchar *end, c;\n\tunsigned long num, num2, num3;\n\n\tnum = strtoul(date, &end, 10);\n\n\t/* Time? num:num[:num] */\n\tif (num < 24 && end[0] == ':' && isdigit(end[1])) {\n\t\ttm->tm_hour = num;\n\t\tnum = strtoul(end+1, &end, 10);\n\t\tif (num < 60) {\n\t\t\ttm->tm_min = num;\n\t\t\tif (end[0] == ':' && isdigit(end[1])) {\n\t\t\t\tnum = strtoul(end+1, &end, 10);\n\t\t\t\tif (num < 61)\n\t\t\t\t\ttm->tm_sec = num;\n\t\t\t}\n\t\t}\n\t\treturn end - date;\n\t}\n\n\t/* Year? Day of month? Numeric date-string?*/\n\tc = *end;\n\tswitch (c) {\n\tdefault:\n\t\tif (num > 0 && num < 32) {\n\t\t\ttm->tm_mday = num;\n\t\t\tbreak;\n\t\t}\n\t\tif (num > 1900) {\n\t\t\ttm->tm_year = num - 1900;\n\t\t\tbreak;\n\t\t}\n\t\tif (num > 70) {\n\t\t\ttm->tm_year = num;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase '-':\n\tcase '/':\n\t\tif (num && num < 32 && isdigit(end[1])) {\n\t\t\tnum2 = strtoul(end+1, &end, 10);\n\t\t\tif (!num2 || num2 > 31)\n\t\t\t\tbreak;\n\t\t\tif (num > 12) {\n\t\t\t\tif (num2 > 12)\n\t\t\t\t\tbreak;\n\t\t\t\tnum3 = num;\n\t\t\t\tnum  = num2;\n\t\t\t\tnum2 = num3;\n\t\t\t}\n\t\t\ttm->tm_mon = num - 1;\n\t\t\ttm->tm_mday = num2;\n\t\t\tif (*end == c && isdigit(end[1])) {\n\t\t\t\tnum3 = strtoul(end+1, &end, 10);\n\t\t\t\tif (num3 > 1900)\n\t\t\t\t\tnum3 -= 1900;\n\t\t\t\telse if (num3 < 38)\n\t\t\t\t\tnum3 += 100;\n\t\t\t\ttm->tm_year = num3;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\t\n\treturn end - date;\n\t\t\t\n}\n\nstatic int match_tz(char *date, int *offp)\n{\n\tchar *end;\n\tint offset = strtoul(date+1, &end, 10);\n\tint min, hour;\n\n\tmin = offset % 100;\n\thour = offset / 100;\n\n\toffset = hour*60+min;\n\tif (*date == '-')\n\t\toffset = -offset;\n\n\t*offp = offset;\n\treturn end - date;\n}\n\n/* Gr. strptime is crap for this; it doesn't have a way to require RFC2822\n   (i.e. English) day/month names, and it doesn't work correctly with %z. */\nvoid parse_date(char *date, char *result, int maxlen)\n{\n\tstruct tm tm;\n\tint offset;\n\ttime_t then;\n\n\tmemset(&tm, 0, sizeof(tm));\n\ttm.tm_year = -1;\n\ttm.tm_mon = -1;\n\ttm.tm_mday = -1;\n\ttm.tm_isdst = -1;\n\toffset = -1;\n\n\tfor (;;) {\n\t\tint match = 0;\n\t\tunsigned char c = *date;\n\n\t\t/* Stop at end of string or newline */\n\t\tif (!c || c == '\\n')\n\t\t\tbreak;\n\n\t\tif (isalpha(c))\n\t\t\tmatch = match_alpha(date, &tm, &offset);\n\t\telse if (isdigit(c))\n\t\t\tmatch = match_digit(date, &tm, &offset);\n\t\telse if ((c == '-' || c == '+') && isdigit(date[1]))\n\t\t\tmatch = match_tz(date, &offset);\n\n\t\tif (!match) {\n\t\t\t/* BAD CRAP */\n\t\t\tmatch = 1;\n\t\t}\t\n\n\t\tdate += match;\n\t}\n\n\t/* mktime uses local timezone */\n\tthen = my_mktime(&tm); \n\tif (offset == -1)\n\t\toffset = (then - mktime(&tm)) / 60;\n\n\tif (then == -1)\n\t\treturn;\n\n\tthen -= offset * 60;\n\n\tsnprintf(result, maxlen, \"%lu %+03d%02d\", then, offset/60, offset % 60);\n}\n\nvoid datestamp(char *buf, int bufsize)\n{\n\ttime_t now;\n\tint offset;\n\n\ttime(&now);\n\n\toffset = my_mktime(localtime(&now)) - now;\n\toffset /= 60;\n\n\tsnprintf(buf, bufsize, \"%lu %+05d\", now, offset/60*100 + offset%60);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0022bf2179e883929c49054d69aec9f3f6b0ca83",
  "sha1_ok": true,
  "size": 7102
}
