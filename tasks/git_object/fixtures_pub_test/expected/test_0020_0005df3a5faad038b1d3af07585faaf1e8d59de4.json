{
  "content": {
    "base64": "LyoKICogSSdtIHRpcmVkIG9mIGRvaW5nICJ2c25wcmludGYoKSIgZXRjIGp1c3QgdG8gb3BlbiBhCiAqIGZpbGUsIHNvIGhlcmUncyBhICJyZXR1cm4gc3RhdGljIGJ1ZmZlciB3aXRoIHByaW50ZiIKICogaW50ZXJmYWNlIGZvciBwYXRocy4KICoKICogSXQncyBvYnZpb3VzbHkgbm90IHRocmVhZC1zYWZlLiBTdWUgbWUuIEJ1dCBpdCdzIHF1aXRlCiAqIHVzZWZ1bCBmb3IgZG9pbmcgdGhpbmdzIGxpa2UKICoKICogICBmID0gb3Blbihta3BhdGgoIiVzLyVzLmdpdCIsIGJhc2UsIG5hbWUpLCBPX1JET05MWSk7CiAqCiAqIHdoaWNoIGlzIHdoYXQgaXQncyBkZXNpZ25lZCBmb3IuCiAqLwojaW5jbHVkZSAiY2FjaGUuaCIKI2luY2x1ZGUgInN0cmJ1Zi5oIgoKc3RhdGljIGNoYXIgYmFkX3BhdGhbXSA9ICIvYmFkLXBhdGgvIjsKCnN0YXRpYyBjaGFyICpnZXRfcGF0aG5hbWUodm9pZCkKewoJc3RhdGljIGNoYXIgcGF0aG5hbWVfYXJyYXlbNF1bUEFUSF9NQVhdOwoJc3RhdGljIGludCBpbmRleDsKCXJldHVybiBwYXRobmFtZV9hcnJheVszICYgKytpbmRleF07Cn0KCnN0YXRpYyBjaGFyICpjbGVhbnVwX3BhdGgoY2hhciAqcGF0aCkKewoJLyogQ2xlYW4gaXQgdXAgKi8KCWlmICghbWVtY21wKHBhdGgsICIuLyIsIDIpKSB7CgkJcGF0aCArPSAyOwoJCXdoaWxlICgqcGF0aCA9PSAnLycpCgkJCXBhdGgrKzsKCX0KCXJldHVybiBwYXRoOwp9CgpjaGFyICpta3NucGF0aChjaGFyICpidWYsIHNpemVfdCBuLCBjb25zdCBjaGFyICpmbXQsIC4uLikKewoJdmFfbGlzdCBhcmdzOwoJdW5zaWduZWQgbGVuOwoKCXZhX3N0YXJ0KGFyZ3MsIGZtdCk7CglsZW4gPSB2c25wcmludGYoYnVmLCBuLCBmbXQsIGFyZ3MpOwoJdmFfZW5kKGFyZ3MpOwoJaWYgKGxlbiA+PSBuKSB7CgkJc3RybGNweShidWYsIGJhZF9wYXRoLCBuKTsKCQlyZXR1cm4gYnVmOwoJfQoJcmV0dXJuIGNsZWFudXBfcGF0aChidWYpOwp9CgpzdGF0aWMgY2hhciAqZ2l0X3ZzbnBhdGgoY2hhciAqYnVmLCBzaXplX3QgbiwgY29uc3QgY2hhciAqZm10LCB2YV9saXN0IGFyZ3MpCnsKCWNvbnN0IGNoYXIgKmdpdF9kaXIgPSBnZXRfZ2l0X2RpcigpOwoJc2l6ZV90IGxlbjsKCglsZW4gPSBzdHJsZW4oZ2l0X2Rpcik7CglpZiAobiA8IGxlbiArIDEpCgkJZ290byBiYWQ7CgltZW1jcHkoYnVmLCBnaXRfZGlyLCBsZW4pOwoJaWYgKGxlbiAmJiAhaXNfZGlyX3NlcChnaXRfZGlyW2xlbi0xXSkpCgkJYnVmW2xlbisrXSA9ICcvJzsKCWxlbiArPSB2c25wcmludGYoYnVmICsgbGVuLCBuIC0gbGVuLCBmbXQsIGFyZ3MpOwoJaWYgKGxlbiA+PSBuKQoJCWdvdG8gYmFkOwoJcmV0dXJuIGNsZWFudXBfcGF0aChidWYpOwpiYWQ6CglzdHJsY3B5KGJ1ZiwgYmFkX3BhdGgsIG4pOwoJcmV0dXJuIGJ1ZjsKfQoKY2hhciAqZ2l0X3NucGF0aChjaGFyICpidWYsIHNpemVfdCBuLCBjb25zdCBjaGFyICpmbXQsIC4uLikKewoJdmFfbGlzdCBhcmdzOwoJdmFfc3RhcnQoYXJncywgZm10KTsKCSh2b2lkKWdpdF92c25wYXRoKGJ1ZiwgbiwgZm10LCBhcmdzKTsKCXZhX2VuZChhcmdzKTsKCXJldHVybiBidWY7Cn0KCmNoYXIgKmdpdF9wYXRoZHVwKGNvbnN0IGNoYXIgKmZtdCwgLi4uKQp7CgljaGFyIHBhdGhbUEFUSF9NQVhdOwoJdmFfbGlzdCBhcmdzOwoJdmFfc3RhcnQoYXJncywgZm10KTsKCSh2b2lkKWdpdF92c25wYXRoKHBhdGgsIHNpemVvZihwYXRoKSwgZm10LCBhcmdzKTsKCXZhX2VuZChhcmdzKTsKCXJldHVybiB4c3RyZHVwKHBhdGgpOwp9CgpjaGFyICpta3BhdGgoY29uc3QgY2hhciAqZm10LCAuLi4pCnsKCXZhX2xpc3QgYXJnczsKCXVuc2lnbmVkIGxlbjsKCWNoYXIgKnBhdGhuYW1lID0gZ2V0X3BhdGhuYW1lKCk7CgoJdmFfc3RhcnQoYXJncywgZm10KTsKCWxlbiA9IHZzbnByaW50ZihwYXRobmFtZSwgUEFUSF9NQVgsIGZtdCwgYXJncyk7Cgl2YV9lbmQoYXJncyk7CglpZiAobGVuID49IFBBVEhfTUFYKQoJCXJldHVybiBiYWRfcGF0aDsKCXJldHVybiBjbGVhbnVwX3BhdGgocGF0aG5hbWUpOwp9CgpjaGFyICpnaXRfcGF0aChjb25zdCBjaGFyICpmbXQsIC4uLikKewoJY29uc3QgY2hhciAqZ2l0X2RpciA9IGdldF9naXRfZGlyKCk7CgljaGFyICpwYXRobmFtZSA9IGdldF9wYXRobmFtZSgpOwoJdmFfbGlzdCBhcmdzOwoJdW5zaWduZWQgbGVuOwoKCWxlbiA9IHN0cmxlbihnaXRfZGlyKTsKCWlmIChsZW4gPiBQQVRIX01BWC0xMDApCgkJcmV0dXJuIGJhZF9wYXRoOwoJbWVtY3B5KHBhdGhuYW1lLCBnaXRfZGlyLCBsZW4pOwoJaWYgKGxlbiAmJiBnaXRfZGlyW2xlbi0xXSAhPSAnLycpCgkJcGF0aG5hbWVbbGVuKytdID0gJy8nOwoJdmFfc3RhcnQoYXJncywgZm10KTsKCWxlbiArPSB2c25wcmludGYocGF0aG5hbWUgKyBsZW4sIFBBVEhfTUFYIC0gbGVuLCBmbXQsIGFyZ3MpOwoJdmFfZW5kKGFyZ3MpOwoJaWYgKGxlbiA+PSBQQVRIX01BWCkKCQlyZXR1cm4gYmFkX3BhdGg7CglyZXR1cm4gY2xlYW51cF9wYXRoKHBhdGhuYW1lKTsKfQoKCi8qIGdpdF9ta3N0ZW1wKCkgLSBjcmVhdGUgdG1wIGZpbGUgaG9ub3JpbmcgVE1QRElSIHZhcmlhYmxlICovCmludCBnaXRfbWtzdGVtcChjaGFyICpwYXRoLCBzaXplX3QgbGVuLCBjb25zdCBjaGFyICp0ZW1wbGF0ZSkKewoJY29uc3QgY2hhciAqdG1wOwoJc2l6ZV90IG47CgoJdG1wID0gZ2V0ZW52KCJUTVBESVIiKTsKCWlmICghdG1wKQoJCXRtcCA9ICIvdG1wIjsKCW4gPSBzbnByaW50ZihwYXRoLCBsZW4sICIlcy8lcyIsIHRtcCwgdGVtcGxhdGUpOwoJaWYgKGxlbiA8PSBuKSB7CgkJZXJybm8gPSBFTkFNRVRPT0xPTkc7CgkJcmV0dXJuIC0xOwoJfQoJcmV0dXJuIG1rc3RlbXAocGF0aCk7Cn0KCi8qIGdpdF9ta3N0ZW1wcygpIC0gY3JlYXRlIHRtcCBmaWxlIHdpdGggc3VmZml4IGhvbm9yaW5nIFRNUERJUiB2YXJpYWJsZS4gKi8KaW50IGdpdF9ta3N0ZW1wcyhjaGFyICpwYXRoLCBzaXplX3QgbGVuLCBjb25zdCBjaGFyICp0ZW1wbGF0ZSwgaW50IHN1ZmZpeF9sZW4pCnsKCWNvbnN0IGNoYXIgKnRtcDsKCXNpemVfdCBuOwoKCXRtcCA9IGdldGVudigiVE1QRElSIik7CglpZiAoIXRtcCkKCQl0bXAgPSAiL3RtcCI7CgluID0gc25wcmludGYocGF0aCwgbGVuLCAiJXMvJXMiLCB0bXAsIHRlbXBsYXRlKTsKCWlmIChsZW4gPD0gbikgewoJCWVycm5vID0gRU5BTUVUT09MT05HOwoJCXJldHVybiAtMTsKCX0KCXJldHVybiBta3N0ZW1wcyhwYXRoLCBzdWZmaXhfbGVuKTsKfQoKaW50IHZhbGlkYXRlX2hlYWRyZWYoY29uc3QgY2hhciAqcGF0aCkKewoJc3RydWN0IHN0YXQgc3Q7CgljaGFyICpidWYsIGJ1ZmZlclsyNTZdOwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCWludCBmZDsKCXNzaXplX3QgbGVuOwoKCWlmIChsc3RhdChwYXRoLCAmc3QpIDwgMCkKCQlyZXR1cm4gLTE7CgoJLyogTWFrZSBzdXJlIGl0IGlzIGEgInJlZnMvLi4iIHN5bWxpbmsgKi8KCWlmIChTX0lTTE5LKHN0LnN0X21vZGUpKSB7CgkJbGVuID0gcmVhZGxpbmsocGF0aCwgYnVmZmVyLCBzaXplb2YoYnVmZmVyKS0xKTsKCQlpZiAobGVuID49IDUgJiYgIW1lbWNtcCgicmVmcy8iLCBidWZmZXIsIDUpKQoJCQlyZXR1cm4gMDsKCQlyZXR1cm4gLTE7Cgl9CgoJLyoKCSAqIEFueXRoaW5nIGVsc2UsIGp1c3Qgb3BlbiBpdCBhbmQgdHJ5IHRvIHNlZSBpZiBpdCBpcyBhIHN5bWJvbGljIHJlZi4KCSAqLwoJZmQgPSBvcGVuKHBhdGgsIE9fUkRPTkxZKTsKCWlmIChmZCA8IDApCgkJcmV0dXJuIC0xOwoJbGVuID0gcmVhZF9pbl9mdWxsKGZkLCBidWZmZXIsIHNpemVvZihidWZmZXIpLTEpOwoJY2xvc2UoZmQpOwoKCS8qCgkgKiBJcyBpdCBhIHN5bWJvbGljIHJlZj8KCSAqLwoJaWYgKGxlbiA8IDQpCgkJcmV0dXJuIC0xOwoJaWYgKCFtZW1jbXAoInJlZjoiLCBidWZmZXIsIDQpKSB7CgkJYnVmID0gYnVmZmVyICsgNDsKCQlsZW4gLT0gNDsKCQl3aGlsZSAobGVuICYmIGlzc3BhY2UoKmJ1ZikpCgkJCWJ1ZisrLCBsZW4tLTsKCQlpZiAobGVuID49IDUgJiYgIW1lbWNtcCgicmVmcy8iLCBidWYsIDUpKQoJCQlyZXR1cm4gMDsKCX0KCgkvKgoJICogSXMgdGhpcyBhIGRldGFjaGVkIEhFQUQ/CgkgKi8KCWlmICghZ2V0X3NoYTFfaGV4KGJ1ZmZlciwgc2hhMSkpCgkJcmV0dXJuIDA7CgoJcmV0dXJuIC0xOwp9CgpzdGF0aWMgc3RydWN0IHBhc3N3ZCAqZ2V0cHdfc3RyKGNvbnN0IGNoYXIgKnVzZXJuYW1lLCBzaXplX3QgbGVuKQp7CglzdHJ1Y3QgcGFzc3dkICpwdzsKCWNoYXIgKnVzZXJuYW1lX3ogPSB4bWFsbG9jKGxlbiArIDEpOwoJbWVtY3B5KHVzZXJuYW1lX3osIHVzZXJuYW1lLCBsZW4pOwoJdXNlcm5hbWVfeltsZW5dID0gJ1wwJzsKCXB3ID0gZ2V0cHduYW0odXNlcm5hbWVfeik7CglmcmVlKHVzZXJuYW1lX3opOwoJcmV0dXJuIHB3Owp9CgovKgogKiBSZXR1cm4gYSBzdHJpbmcgd2l0aCB+IGFuZCB+dXNlciBleHBhbmRlZCB2aWEgZ2V0cHcqLiAgSWYgYnVmICE9IE5VTEwsCiAqIHRoZW4gaXQgaXMgYSBuZXdseSBhbGxvY2F0ZWQgc3RyaW5nLiBSZXR1cm5zIE5VTEwgb24gZ2V0cHcgZmFpbHVyZSBvcgogKiBpZiBwYXRoIGlzIE5VTEwuCiAqLwpjaGFyICpleHBhbmRfdXNlcl9wYXRoKGNvbnN0IGNoYXIgKnBhdGgpCnsKCXN0cnVjdCBzdHJidWYgdXNlcl9wYXRoID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpmaXJzdF9zbGFzaCA9IHN0cmNocm51bChwYXRoLCAnLycpOwoJY29uc3QgY2hhciAqdG9fY29weSA9IHBhdGg7CgoJaWYgKHBhdGggPT0gTlVMTCkKCQlnb3RvIHJldHVybl9udWxsOwoJaWYgKHBhdGhbMF0gPT0gJ34nKSB7CgkJY29uc3QgY2hhciAqdXNlcm5hbWUgPSBwYXRoICsgMTsKCQlzaXplX3QgdXNlcm5hbWVfbGVuID0gZmlyc3Rfc2xhc2ggLSB1c2VybmFtZTsKCQlpZiAodXNlcm5hbWVfbGVuID09IDApIHsKCQkJY29uc3QgY2hhciAqaG9tZSA9IGdldGVudigiSE9NRSIpOwoJCQlzdHJidWZfYWRkKCZ1c2VyX3BhdGgsIGhvbWUsIHN0cmxlbihob21lKSk7CgkJfSBlbHNlIHsKCQkJc3RydWN0IHBhc3N3ZCAqcHcgPSBnZXRwd19zdHIodXNlcm5hbWUsIHVzZXJuYW1lX2xlbik7CgkJCWlmICghcHcpCgkJCQlnb3RvIHJldHVybl9udWxsOwoJCQlzdHJidWZfYWRkKCZ1c2VyX3BhdGgsIHB3LT5wd19kaXIsIHN0cmxlbihwdy0+cHdfZGlyKSk7CgkJfQoJCXRvX2NvcHkgPSBmaXJzdF9zbGFzaDsKCX0KCXN0cmJ1Zl9hZGQoJnVzZXJfcGF0aCwgdG9fY29weSwgc3RybGVuKHRvX2NvcHkpKTsKCXJldHVybiBzdHJidWZfZGV0YWNoKCZ1c2VyX3BhdGgsIE5VTEwpOwpyZXR1cm5fbnVsbDoKCXN0cmJ1Zl9yZWxlYXNlKCZ1c2VyX3BhdGgpOwoJcmV0dXJuIE5VTEw7Cn0KCi8qCiAqIEZpcnN0LCBvbmUgZGlyZWN0b3J5IHRvIHRyeSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtLgogKgogKiAoMCkgSWYgInN0cmljdCIgaXMgZ2l2ZW4sIHRoZSBwYXRoIGlzIHVzZWQgYXMgZ2l2ZW4gYW5kIG5vIERXSU0gaXMKICogICAgIGRvbmUuIE90aGVyd2lzZToKICogKDEpICJ+L3BhdGgiIHRvIG1lYW4gcGF0aCB1bmRlciB0aGUgcnVubmluZyB1c2VyJ3MgaG9tZSBkaXJlY3Rvcnk7CiAqICgyKSAifnVzZXIvcGF0aCIgdG8gbWVhbiBwYXRoIHVuZGVyIG5hbWVkIHVzZXIncyBob21lIGRpcmVjdG9yeTsKICogKDMpICJyZWxhdGl2ZS9wYXRoIiB0byBtZWFuIGN3ZCByZWxhdGl2ZSBkaXJlY3Rvcnk7IG9yCiAqICg0KSAiL2Fic29sdXRlL3BhdGgiIHRvIG1lYW4gYWJzb2x1dGUgZGlyZWN0b3J5LgogKgogKiBVbmxlc3MgInN0cmljdCIgaXMgZ2l2ZW4sIHdlIHRyeSBhY2Nlc3MoKSBmb3IgZXhpc3RlbmNlIG9mICIlcy5naXQvLmdpdCIsCiAqICIlcy8uZ2l0IiwgIiVzLmdpdCIsICIlcyIgaW4gdGhpcyBvcmRlci4gIFRoZSBmaXJzdCBvbmUgdGhhdCBleGlzdHMgaXMKICogd2hhdCB3ZSB0cnkuCiAqCiAqIFNlY29uZCwgd2UgdHJ5IGNoZGlyKCkgdG8gdGhhdC4gIFVwb24gZmFpbHVyZSwgd2UgcmV0dXJuIE5VTEwuCiAqCiAqIFRoZW4sIHdlIHRyeSBpZiB0aGUgY3VycmVudCBkaXJlY3RvcnkgaXMgYSB2YWxpZCBnaXQgcmVwb3NpdG9yeS4KICogVXBvbiBmYWlsdXJlLCB3ZSByZXR1cm4gTlVMTC4KICoKICogSWYgYWxsIGdvZXMgd2VsbCwgd2UgcmV0dXJuIHRoZSBkaXJlY3Rvcnkgd2UgdXNlZCB0byBjaGRpcigpIChidXQKICogYmVmb3JlIH51c2VyIGlzIGV4cGFuZGVkKSwgYXZvaWRpbmcgZ2V0Y3dkKCkgcmVzb2x2aW5nIHN5bWJvbGljCiAqIGxpbmtzLiAgVXNlciByZWxhdGl2ZSBwYXRocyBhcmUgYWxzbyByZXR1cm5lZCBhcyB0aGV5IGFyZSBnaXZlbiwKICogZXhjZXB0IERXSU0gc3VmZml4aW5nLgogKi8KY2hhciAqZW50ZXJfcmVwbyhjaGFyICpwYXRoLCBpbnQgc3RyaWN0KQp7CglzdGF0aWMgY2hhciB1c2VkX3BhdGhbUEFUSF9NQVhdOwoJc3RhdGljIGNoYXIgdmFsaWRhdGVkX3BhdGhbUEFUSF9NQVhdOwoKCWlmICghcGF0aCkKCQlyZXR1cm4gTlVMTDsKCglpZiAoIXN0cmljdCkgewoJCXN0YXRpYyBjb25zdCBjaGFyICpzdWZmaXhbXSA9IHsKCQkJIi5naXQvLmdpdCIsICIvLmdpdCIsICIuZ2l0IiwgIiIsIE5VTEwsCgkJfTsKCQlpbnQgbGVuID0gc3RybGVuKHBhdGgpOwoJCWludCBpOwoJCXdoaWxlICgoMSA8IGxlbikgJiYgKHBhdGhbbGVuLTFdID09ICcvJykpIHsKCQkJcGF0aFtsZW4tMV0gPSAwOwoJCQlsZW4tLTsKCQl9CgkJaWYgKFBBVEhfTUFYIDw9IGxlbikKCQkJcmV0dXJuIE5VTEw7CgkJaWYgKHBhdGhbMF0gPT0gJ34nKSB7CgkJCWNoYXIgKm5ld3BhdGggPSBleHBhbmRfdXNlcl9wYXRoKHBhdGgpOwoJCQlpZiAoIW5ld3BhdGggfHwgKFBBVEhfTUFYIC0gMTAgPCBzdHJsZW4obmV3cGF0aCkpKSB7CgkJCQlmcmVlKG5ld3BhdGgpOwoJCQkJcmV0dXJuIE5VTEw7CgkJCX0KCQkJLyoKCQkJICogQ29weSBiYWNrIGludG8gdGhlIHN0YXRpYyBidWZmZXIuIEEgcGl0eQoJCQkgKiBzaW5jZSBuZXdwYXRoIHdhcyBub3QgYm91bmRlZCwgYnV0IG90aGVyCgkJCSAqIGJyYW5jaGVzIG9mIHRoZSBpZiBhcmUgbGltaXRlZCBieSBQQVRIX01BWAoJCQkgKiBhbnl3YXkuCgkJCSAqLwoJCQlzdHJjcHkodXNlZF9wYXRoLCBuZXdwYXRoKTsgZnJlZShuZXdwYXRoKTsKCQkJc3RyY3B5KHZhbGlkYXRlZF9wYXRoLCBwYXRoKTsKCQkJcGF0aCA9IHVzZWRfcGF0aDsKCQl9CgkJZWxzZSBpZiAoUEFUSF9NQVggLSAxMCA8IGxlbikKCQkJcmV0dXJuIE5VTEw7CgkJZWxzZSB7CgkJCXBhdGggPSBzdHJjcHkodXNlZF9wYXRoLCBwYXRoKTsKCQkJc3RyY3B5KHZhbGlkYXRlZF9wYXRoLCBwYXRoKTsKCQl9CgkJbGVuID0gc3RybGVuKHBhdGgpOwoJCWZvciAoaSA9IDA7IHN1ZmZpeFtpXTsgaSsrKSB7CgkJCXN0cmNweShwYXRoICsgbGVuLCBzdWZmaXhbaV0pOwoJCQlpZiAoIWFjY2VzcyhwYXRoLCBGX09LKSkgewoJCQkJc3RyY2F0KHZhbGlkYXRlZF9wYXRoLCBzdWZmaXhbaV0pOwoJCQkJYnJlYWs7CgkJCX0KCQl9CgkJaWYgKCFzdWZmaXhbaV0gfHwgY2hkaXIocGF0aCkpCgkJCXJldHVybiBOVUxMOwoJCXBhdGggPSB2YWxpZGF0ZWRfcGF0aDsKCX0KCWVsc2UgaWYgKGNoZGlyKHBhdGgpKQoJCXJldHVybiBOVUxMOwoKCWlmIChhY2Nlc3MoIm9iamVjdHMiLCBYX09LKSA9PSAwICYmIGFjY2VzcygicmVmcyIsIFhfT0spID09IDAgJiYKCSAgICB2YWxpZGF0ZV9oZWFkcmVmKCJIRUFEIikgPT0gMCkgewoJCXNldF9naXRfZGlyKCIuIik7CgkJY2hlY2tfcmVwb3NpdG9yeV9mb3JtYXQoKTsKCQlyZXR1cm4gcGF0aDsKCX0KCglyZXR1cm4gTlVMTDsKfQoKaW50IHNldF9zaGFyZWRfcGVybShjb25zdCBjaGFyICpwYXRoLCBpbnQgbW9kZSkKewoJc3RydWN0IHN0YXQgc3Q7CglpbnQgdHdlYWssIHNoYXJlZCwgb3JpZ19tb2RlOwoKCWlmICghc2hhcmVkX3JlcG9zaXRvcnkpIHsKCQlpZiAobW9kZSkKCQkJcmV0dXJuIGNobW9kKHBhdGgsIG1vZGUgJiB+U19JRk1UKTsKCQlyZXR1cm4gMDsKCX0KCWlmICghbW9kZSkgewoJCWlmIChsc3RhdChwYXRoLCAmc3QpIDwgMCkKCQkJcmV0dXJuIC0xOwoJCW1vZGUgPSBzdC5zdF9tb2RlOwoJCW9yaWdfbW9kZSA9IG1vZGU7Cgl9IGVsc2UKCQlvcmlnX21vZGUgPSAwOwoJaWYgKHNoYXJlZF9yZXBvc2l0b3J5IDwgMCkKCQlzaGFyZWQgPSAtc2hhcmVkX3JlcG9zaXRvcnk7CgllbHNlCgkJc2hhcmVkID0gc2hhcmVkX3JlcG9zaXRvcnk7Cgl0d2VhayA9IHNoYXJlZDsKCglpZiAoIShtb2RlICYgU19JV1VTUikpCgkJdHdlYWsgJj0gfjAyMjI7CglpZiAobW9kZSAmIFNfSVhVU1IpCgkJLyogQ29weSByZWFkIGJpdHMgdG8gZXhlY3V0ZSBiaXRzICovCgkJdHdlYWsgfD0gKHR3ZWFrICYgMDQ0NCkgPj4gMjsKCWlmIChzaGFyZWRfcmVwb3NpdG9yeSA8IDApCgkJbW9kZSA9IChtb2RlICYgfjA3NzcpIHwgdHdlYWs7CgllbHNlCgkJbW9kZSB8PSB0d2VhazsKCglpZiAoU19JU0RJUihtb2RlKSkgewoJCS8qIENvcHkgcmVhZCBiaXRzIHRvIGV4ZWN1dGUgYml0cyAqLwoJCW1vZGUgfD0gKHNoYXJlZCAmIDA0NDQpID4+IDI7CgkJbW9kZSB8PSBGT1JDRV9ESVJfU0VUX0dJRDsKCX0KCglpZiAoKChzaGFyZWRfcmVwb3NpdG9yeSA8IDAKCSAgICAgID8gKG9yaWdfbW9kZSAmIChGT1JDRV9ESVJfU0VUX0dJRCB8IDA3NzcpKQoJICAgICAgOiAob3JpZ19tb2RlICYgbW9kZSkpICE9IG1vZGUpICYmCgkgICAgY2htb2QocGF0aCwgKG1vZGUgJiB+U19JRk1UKSkgPCAwKQoJCXJldHVybiAtMjsKCXJldHVybiAwOwp9Cgpjb25zdCBjaGFyICptYWtlX3JlbGF0aXZlX3BhdGgoY29uc3QgY2hhciAqYWJzLCBjb25zdCBjaGFyICpiYXNlKQp7CglzdGF0aWMgY2hhciBidWZbUEFUSF9NQVggKyAxXTsKCWludCBpID0gMCwgaiA9IDA7CgoJaWYgKCFiYXNlIHx8ICFiYXNlWzBdKQoJCXJldHVybiBhYnM7Cgl3aGlsZSAoYmFzZVtpXSkgewoJCWlmIChpc19kaXJfc2VwKGJhc2VbaV0pKSB7CgkJCWlmICghaXNfZGlyX3NlcChhYnNbal0pKQoJCQkJcmV0dXJuIGFiczsKCQkJd2hpbGUgKGlzX2Rpcl9zZXAoYmFzZVtpXSkpCgkJCQlpKys7CgkJCXdoaWxlIChpc19kaXJfc2VwKGFic1tqXSkpCgkJCQlqKys7CgkJCWNvbnRpbnVlOwoJCX0gZWxzZSBpZiAoYWJzW2pdICE9IGJhc2VbaV0pIHsKCQkJcmV0dXJuIGFiczsKCQl9CgkJaSsrOwoJCWorKzsKCX0KCWlmICgKCSAgICAvKiAiL2ZvbyIgaXMgYSBwcmVmaXggb2YgIi9mb28iICovCgkgICAgYWJzW2pdICYmCgkgICAgLyogIi9mb28iIGlzIG5vdCBhIHByZWZpeCBvZiAiL2Zvb2JhciIgKi8KCSAgICAhaXNfZGlyX3NlcChiYXNlW2ktMV0pICYmICFpc19kaXJfc2VwKGFic1tqXSkKCSAgICkKCQlyZXR1cm4gYWJzOwoJd2hpbGUgKGlzX2Rpcl9zZXAoYWJzW2pdKSkKCQlqKys7CglpZiAoIWFic1tqXSkKCQlzdHJjcHkoYnVmLCAiLiIpOwoJZWxzZQoJCXN0cmNweShidWYsIGFicyArIGopOwoJcmV0dXJuIGJ1ZjsKfQoKLyoKICogSXQgaXMgb2theSBpZiBkc3QgPT0gc3JjLCBidXQgdGhleSBzaG91bGQgbm90IG92ZXJsYXAgb3RoZXJ3aXNlLgogKgogKiBQZXJmb3JtcyB0aGUgZm9sbG93aW5nIG5vcm1hbGl6YXRpb25zIG9uIHNyYywgc3RvcmluZyB0aGUgcmVzdWx0IGluIGRzdDoKICogLSBFbnN1cmVzIHRoYXQgY29tcG9uZW50cyBhcmUgc2VwYXJhdGVkIGJ5ICcvJyAoV2luZG93cyBvbmx5KQogKiAtIFNxdWFzaGVzIHNlcXVlbmNlcyBvZiAnLycuCiAqIC0gUmVtb3ZlcyAiLiIgY29tcG9uZW50cy4KICogLSBSZW1vdmVzICIuLiIgY29tcG9uZW50cywgYW5kIHRoZSBjb21wb25lbnRzIHRoZSBwcmVjZWRlIHRoZW0uCiAqIFJldHVybnMgZmFpbHVyZSAobm9uLXplcm8pIGlmIGEgIi4uIiBjb21wb25lbnQgYXBwZWFycyBhcyBmaXJzdCBwYXRoCiAqIGNvbXBvbmVudCBhbnl0aW1lIGR1cmluZyB0aGUgbm9ybWFsaXphdGlvbi4gT3RoZXJ3aXNlLCByZXR1cm5zIHN1Y2Nlc3MgKDApLgogKgogKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyBwdXJlbHkgdGV4dHVhbC4gIEl0IGRvZXMgbm90IGZvbGxvdyBzeW1saW5rcywKICogdmVyaWZ5IHRoZSBleGlzdGVuY2Ugb2YgdGhlIHBhdGgsIG9yIG1ha2UgYW55IHN5c3RlbSBjYWxscy4KICovCmludCBub3JtYWxpemVfcGF0aF9jb3B5KGNoYXIgKmRzdCwgY29uc3QgY2hhciAqc3JjKQp7CgljaGFyICpkc3QwOwoKCWlmIChoYXNfZG9zX2RyaXZlX3ByZWZpeChzcmMpKSB7CgkJKmRzdCsrID0gKnNyYysrOwoJCSpkc3QrKyA9ICpzcmMrKzsKCX0KCWRzdDAgPSBkc3Q7CgoJaWYgKGlzX2Rpcl9zZXAoKnNyYykpIHsKCQkqZHN0KysgPSAnLyc7CgkJd2hpbGUgKGlzX2Rpcl9zZXAoKnNyYykpCgkJCXNyYysrOwoJfQoKCWZvciAoOzspIHsKCQljaGFyIGMgPSAqc3JjOwoKCQkvKgoJCSAqIEEgcGF0aCBjb21wb25lbnQgdGhhdCBiZWdpbnMgd2l0aCAuIGNvdWxkIGJlCgkJICogc3BlY2lhbDoKCQkgKiAoMSkgIi4iIGFuZCBlbmRzICAgLS0gaWdub3JlIGFuZCB0ZXJtaW5hdGUuCgkJICogKDIpICIuLyIgICAgICAgICAgIC0tIGlnbm9yZSB0aGVtLCBlYXQgc2xhc2ggYW5kIGNvbnRpbnVlLgoJCSAqICgzKSAiLi4iIGFuZCBlbmRzICAtLSBzdHJpcCBvbmUgYW5kIHRlcm1pbmF0ZS4KCQkgKiAoNCkgIi4uLyIgICAgICAgICAgLS0gc3RyaXAgb25lLCBlYXQgc2xhc2ggYW5kIGNvbnRpbnVlLgoJCSAqLwoJCWlmIChjID09ICcuJykgewoJCQlpZiAoIXNyY1sxXSkgewoJCQkJLyogKDEpICovCgkJCQlzcmMrKzsKCQkJfSBlbHNlIGlmIChpc19kaXJfc2VwKHNyY1sxXSkpIHsKCQkJCS8qICgyKSAqLwoJCQkJc3JjICs9IDI7CgkJCQl3aGlsZSAoaXNfZGlyX3NlcCgqc3JjKSkKCQkJCQlzcmMrKzsKCQkJCWNvbnRpbnVlOwoJCQl9IGVsc2UgaWYgKHNyY1sxXSA9PSAnLicpIHsKCQkJCWlmICghc3JjWzJdKSB7CgkJCQkJLyogKDMpICovCgkJCQkJc3JjICs9IDI7CgkJCQkJZ290byB1cF9vbmU7CgkJCQl9IGVsc2UgaWYgKGlzX2Rpcl9zZXAoc3JjWzJdKSkgewoJCQkJCS8qICg0KSAqLwoJCQkJCXNyYyArPSAzOwoJCQkJCXdoaWxlIChpc19kaXJfc2VwKCpzcmMpKQoJCQkJCQlzcmMrKzsKCQkJCQlnb3RvIHVwX29uZTsKCQkJCX0KCQkJfQoJCX0KCgkJLyogY29weSB1cCB0byB0aGUgbmV4dCAnLycsIGFuZCBlYXQgYWxsICcvJyAqLwoJCXdoaWxlICgoYyA9ICpzcmMrKykgIT0gJ1wwJyAmJiAhaXNfZGlyX3NlcChjKSkKCQkJKmRzdCsrID0gYzsKCQlpZiAoaXNfZGlyX3NlcChjKSkgewoJCQkqZHN0KysgPSAnLyc7CgkJCXdoaWxlIChpc19kaXJfc2VwKGMpKQoJCQkJYyA9ICpzcmMrKzsKCQkJc3JjLS07CgkJfSBlbHNlIGlmICghYykKCQkJYnJlYWs7CgkJY29udGludWU7CgoJdXBfb25lOgoJCS8qCgkJICogZHN0MC4uZHN0IGlzIHByZWZpeCBwb3J0aW9uLCBhbmQgZHN0Wy0xXSBpcyAnLyc7CgkJICogZ28gdXAgb25lIGxldmVsLgoJCSAqLwoJCWRzdC0tOwkvKiBnbyB0byB0cmFpbGluZyAnLycgKi8KCQlpZiAoZHN0IDw9IGRzdDApCgkJCXJldHVybiAtMTsKCQkvKiBXaW5kb3dzOiBkc3RbLTFdIGNhbm5vdCBiZSBiYWNrc2xhc2ggYW55bW9yZSAqLwoJCXdoaWxlIChkc3QwIDwgZHN0ICYmIGRzdFstMV0gIT0gJy8nKQoJCQlkc3QtLTsKCX0KCSpkc3QgPSAnXDAnOwoJcmV0dXJuIDA7Cn0KCi8qCiAqIHBhdGggPSBDYW5vbmljYWwgYWJzb2x1dGUgcGF0aAogKiBwcmVmaXhfbGlzdCA9IENvbG9uLXNlcGFyYXRlZCBsaXN0IG9mIGFic29sdXRlIHBhdGhzCiAqCiAqIERldGVybWluZXMsIGZvciBlYWNoIHBhdGggaW4gcHJlZml4X2xpc3QsIHdoZXRoZXIgdGhlICJwcmVmaXgiIHJlYWxseQogKiBpcyBhbiBhbmNlc3RvciBkaXJlY3Rvcnkgb2YgcGF0aC4gIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdAogKiBhbmNlc3RvciBkaXJlY3RvcnksIGV4Y2x1ZGluZyBhbnkgdHJhaWxpbmcgc2xhc2hlcywgb3IgLTEgaWYgbm8gcHJlZml4CiAqIGlzIGFuIGFuY2VzdG9yLiAgKE5vdGUgdGhhdCB0aGlzIG1lYW5zIDAgaXMgcmV0dXJuZWQgaWYgcHJlZml4X2xpc3QgaXMKICogIi8iLikgIi9mb28iIGlzIG5vdCBjb25zaWRlcmVkIGFuIGFuY2VzdG9yIG9mICIvZm9vYmFyIi4gIERpcmVjdG9yaWVzCiAqIGFyZSBub3QgY29uc2lkZXJlZCB0byBiZSB0aGVpciBvd24gYW5jZXN0b3JzLiAgcGF0aCBtdXN0IGJlIGluIGEKICogY2Fub25pY2FsIGZvcm06IGVtcHR5IGNvbXBvbmVudHMsIG9yICIuIiBvciAiLi4iIGNvbXBvbmVudHMgYXJlIG5vdAogKiBhbGxvd2VkLiAgcHJlZml4X2xpc3QgbWF5IGJlIG51bGwsIHdoaWNoIGlzIGxpa2UgIiIuCiAqLwppbnQgbG9uZ2VzdF9hbmNlc3Rvcl9sZW5ndGgoY29uc3QgY2hhciAqcGF0aCwgY29uc3QgY2hhciAqcHJlZml4X2xpc3QpCnsKCWNoYXIgYnVmW1BBVEhfTUFYKzFdOwoJY29uc3QgY2hhciAqY2VpbCwgKmNvbG9uOwoJaW50IGxlbiwgbWF4X2xlbiA9IC0xOwoKCWlmIChwcmVmaXhfbGlzdCA9PSBOVUxMIHx8ICFzdHJjbXAocGF0aCwgIi8iKSkKCQlyZXR1cm4gLTE7CgoJZm9yIChjb2xvbiA9IGNlaWwgPSBwcmVmaXhfbGlzdDsgKmNvbG9uOyBjZWlsID0gY29sb24rMSkgewoJCWZvciAoY29sb24gPSBjZWlsOyAqY29sb24gJiYgKmNvbG9uICE9IFBBVEhfU0VQOyBjb2xvbisrKTsKCQlsZW4gPSBjb2xvbiAtIGNlaWw7CgkJaWYgKGxlbiA9PSAwIHx8IGxlbiA+IFBBVEhfTUFYIHx8ICFpc19hYnNvbHV0ZV9wYXRoKGNlaWwpKQoJCQljb250aW51ZTsKCQlzdHJsY3B5KGJ1ZiwgY2VpbCwgbGVuKzEpOwoJCWlmIChub3JtYWxpemVfcGF0aF9jb3B5KGJ1ZiwgYnVmKSA8IDApCgkJCWNvbnRpbnVlOwoJCWxlbiA9IHN0cmxlbihidWYpOwoJCWlmIChsZW4gPiAwICYmIGJ1ZltsZW4tMV0gPT0gJy8nKQoJCQlidWZbLS1sZW5dID0gJ1wwJzsKCgkJaWYgKCFzdHJuY21wKHBhdGgsIGJ1ZiwgbGVuKSAmJgoJCSAgICBwYXRoW2xlbl0gPT0gJy8nICYmCgkJICAgIGxlbiA+IG1heF9sZW4pIHsKCQkJbWF4X2xlbiA9IGxlbjsKCQl9Cgl9CgoJcmV0dXJuIG1heF9sZW47Cn0KCi8qIHN0cmlwIGFyYml0cmFyeSBhbW91bnQgb2YgZGlyZWN0b3J5IHNlcGFyYXRvcnMgYXQgZW5kIG9mIHBhdGggKi8Kc3RhdGljIGlubGluZSBpbnQgY2hvbXBfdHJhaWxpbmdfZGlyX3NlcChjb25zdCBjaGFyICpwYXRoLCBpbnQgbGVuKQp7Cgl3aGlsZSAobGVuICYmIGlzX2Rpcl9zZXAocGF0aFtsZW4gLSAxXSkpCgkJbGVuLS07CglyZXR1cm4gbGVuOwp9CgovKgogKiBJZiBwYXRoIGVuZHMgd2l0aCBzdWZmaXggKGNvbXBsZXRlIHBhdGggY29tcG9uZW50cyksIHJldHVybnMgdGhlCiAqIHBhcnQgYmVmb3JlIHN1ZmZpeCAoc2FucyB0cmFpbGluZyBkaXJlY3Rvcnkgc2VwYXJhdG9ycykuCiAqIE90aGVyd2lzZSByZXR1cm5zIE5VTEwuCiAqLwpjaGFyICpzdHJpcF9wYXRoX3N1ZmZpeChjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFyICpzdWZmaXgpCnsKCWludCBwYXRoX2xlbiA9IHN0cmxlbihwYXRoKSwgc3VmZml4X2xlbiA9IHN0cmxlbihzdWZmaXgpOwoKCXdoaWxlIChzdWZmaXhfbGVuKSB7CgkJaWYgKCFwYXRoX2xlbikKCQkJcmV0dXJuIE5VTEw7CgoJCWlmIChpc19kaXJfc2VwKHBhdGhbcGF0aF9sZW4gLSAxXSkpIHsKCQkJaWYgKCFpc19kaXJfc2VwKHN1ZmZpeFtzdWZmaXhfbGVuIC0gMV0pKQoJCQkJcmV0dXJuIE5VTEw7CgkJCXBhdGhfbGVuID0gY2hvbXBfdHJhaWxpbmdfZGlyX3NlcChwYXRoLCBwYXRoX2xlbik7CgkJCXN1ZmZpeF9sZW4gPSBjaG9tcF90cmFpbGluZ19kaXJfc2VwKHN1ZmZpeCwgc3VmZml4X2xlbik7CgkJfQoJCWVsc2UgaWYgKHBhdGhbLS1wYXRoX2xlbl0gIT0gc3VmZml4Wy0tc3VmZml4X2xlbl0pCgkJCXJldHVybiBOVUxMOwoJfQoKCWlmIChwYXRoX2xlbiAmJiAhaXNfZGlyX3NlcChwYXRoW3BhdGhfbGVuIC0gMV0pKQoJCXJldHVybiBOVUxMOwoJcmV0dXJuIHhzdHJuZHVwKHBhdGgsIGNob21wX3RyYWlsaW5nX2Rpcl9zZXAocGF0aCwgcGF0aF9sZW4pKTsKfQoKaW50IGRhZW1vbl9hdm9pZF9hbGlhcyhjb25zdCBjaGFyICpwKQp7CglpbnQgc2wsIG5kb3Q7CgoJLyoKCSAqIFRoaXMgcmVzdXJyZWN0cyB0aGUgYmVsdHMgYW5kIHN1c3BlbmRlcnMgcGFyYW5vaWEgY2hlY2sgYnkgSFBBCgkgKiBkb25lIGluIDw0MzU1NjBGNy40MDgwMDA2QHp5dG9yLmNvbT4gdGhyZWFkLCBub3cgZW50ZXJfcmVwbygpCgkgKiBkb2VzIG5vdCBkbyBnZXRjd2QoKSBiYXNlZCBwYXRoIGNhbm9uaWNhbGl6YXRpb25zLgoJICoKCSAqIHNsIGJlY29tZXMgdHJ1ZSBpbW1lZGlhdGVseSBhZnRlciBzZWVpbmcgJy8nIGFuZCBjb250aW51ZXMgdG8KCSAqIGJlIHRydWUgYXMgbG9uZyBhcyBkb3RzIGNvbnRpbnVlIGFmdGVyIHRoYXQgd2l0aG91dCBpbnRlcnZlbmluZwoJICogbm9uLWRvdCBjaGFyYWN0ZXIuCgkgKi8KCWlmICghcCB8fCAoKnAgIT0gJy8nICYmICpwICE9ICd+JykpCgkJcmV0dXJuIC0xOwoJc2wgPSAxOyBuZG90ID0gMDsKCXArKzsKCgl3aGlsZSAoMSkgewoJCWNoYXIgY2ggPSAqcCsrOwoJCWlmIChzbCkgewoJCQlpZiAoY2ggPT0gJy4nKQoJCQkJbmRvdCsrOwoJCQllbHNlIGlmIChjaCA9PSAnLycpIHsKCQkJCWlmIChuZG90IDwgMykKCQkJCQkvKiByZWplY3QgLy8sIC8uLyBhbmQgLy4uLyAqLwoJCQkJCXJldHVybiAtMTsKCQkJCW5kb3QgPSAwOwoJCQl9CgkJCWVsc2UgaWYgKGNoID09IDApIHsKCQkJCWlmICgwIDwgbmRvdCAmJiBuZG90IDwgMykKCQkJCQkvKiByZWplY3QgLy4kIGFuZCAvLi4kICovCgkJCQkJcmV0dXJuIC0xOwoJCQkJcmV0dXJuIDA7CgkJCX0KCQkJZWxzZQoJCQkJc2wgPSBuZG90ID0gMDsKCQl9CgkJZWxzZSBpZiAoY2ggPT0gMCkKCQkJcmV0dXJuIDA7CgkJZWxzZSBpZiAoY2ggPT0gJy8nKSB7CgkJCXNsID0gMTsKCQkJbmRvdCA9IDA7CgkJfQoJfQp9Cg==",
    "text": "/*\n * I'm tired of doing \"vsnprintf()\" etc just to open a\n * file, so here's a \"return static buffer with printf\"\n * interface for paths.\n *\n * It's obviously not thread-safe. Sue me. But it's quite\n * useful for doing things like\n *\n *   f = open(mkpath(\"%s/%s.git\", base, name), O_RDONLY);\n *\n * which is what it's designed for.\n */\n#include \"cache.h\"\n#include \"strbuf.h\"\n\nstatic char bad_path[] = \"/bad-path/\";\n\nstatic char *get_pathname(void)\n{\n\tstatic char pathname_array[4][PATH_MAX];\n\tstatic int index;\n\treturn pathname_array[3 & ++index];\n}\n\nstatic char *cleanup_path(char *path)\n{\n\t/* Clean it up */\n\tif (!memcmp(path, \"./\", 2)) {\n\t\tpath += 2;\n\t\twhile (*path == '/')\n\t\t\tpath++;\n\t}\n\treturn path;\n}\n\nchar *mksnpath(char *buf, size_t n, const char *fmt, ...)\n{\n\tva_list args;\n\tunsigned len;\n\n\tva_start(args, fmt);\n\tlen = vsnprintf(buf, n, fmt, args);\n\tva_end(args);\n\tif (len >= n) {\n\t\tstrlcpy(buf, bad_path, n);\n\t\treturn buf;\n\t}\n\treturn cleanup_path(buf);\n}\n\nstatic char *git_vsnpath(char *buf, size_t n, const char *fmt, va_list args)\n{\n\tconst char *git_dir = get_git_dir();\n\tsize_t len;\n\n\tlen = strlen(git_dir);\n\tif (n < len + 1)\n\t\tgoto bad;\n\tmemcpy(buf, git_dir, len);\n\tif (len && !is_dir_sep(git_dir[len-1]))\n\t\tbuf[len++] = '/';\n\tlen += vsnprintf(buf + len, n - len, fmt, args);\n\tif (len >= n)\n\t\tgoto bad;\n\treturn cleanup_path(buf);\nbad:\n\tstrlcpy(buf, bad_path, n);\n\treturn buf;\n}\n\nchar *git_snpath(char *buf, size_t n, const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\t(void)git_vsnpath(buf, n, fmt, args);\n\tva_end(args);\n\treturn buf;\n}\n\nchar *git_pathdup(const char *fmt, ...)\n{\n\tchar path[PATH_MAX];\n\tva_list args;\n\tva_start(args, fmt);\n\t(void)git_vsnpath(path, sizeof(path), fmt, args);\n\tva_end(args);\n\treturn xstrdup(path);\n}\n\nchar *mkpath(const char *fmt, ...)\n{\n\tva_list args;\n\tunsigned len;\n\tchar *pathname = get_pathname();\n\n\tva_start(args, fmt);\n\tlen = vsnprintf(pathname, PATH_MAX, fmt, args);\n\tva_end(args);\n\tif (len >= PATH_MAX)\n\t\treturn bad_path;\n\treturn cleanup_path(pathname);\n}\n\nchar *git_path(const char *fmt, ...)\n{\n\tconst char *git_dir = get_git_dir();\n\tchar *pathname = get_pathname();\n\tva_list args;\n\tunsigned len;\n\n\tlen = strlen(git_dir);\n\tif (len > PATH_MAX-100)\n\t\treturn bad_path;\n\tmemcpy(pathname, git_dir, len);\n\tif (len && git_dir[len-1] != '/')\n\t\tpathname[len++] = '/';\n\tva_start(args, fmt);\n\tlen += vsnprintf(pathname + len, PATH_MAX - len, fmt, args);\n\tva_end(args);\n\tif (len >= PATH_MAX)\n\t\treturn bad_path;\n\treturn cleanup_path(pathname);\n}\n\n\n/* git_mkstemp() - create tmp file honoring TMPDIR variable */\nint git_mkstemp(char *path, size_t len, const char *template)\n{\n\tconst char *tmp;\n\tsize_t n;\n\n\ttmp = getenv(\"TMPDIR\");\n\tif (!tmp)\n\t\ttmp = \"/tmp\";\n\tn = snprintf(path, len, \"%s/%s\", tmp, template);\n\tif (len <= n) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\treturn mkstemp(path);\n}\n\n/* git_mkstemps() - create tmp file with suffix honoring TMPDIR variable. */\nint git_mkstemps(char *path, size_t len, const char *template, int suffix_len)\n{\n\tconst char *tmp;\n\tsize_t n;\n\n\ttmp = getenv(\"TMPDIR\");\n\tif (!tmp)\n\t\ttmp = \"/tmp\";\n\tn = snprintf(path, len, \"%s/%s\", tmp, template);\n\tif (len <= n) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\treturn mkstemps(path, suffix_len);\n}\n\nint validate_headref(const char *path)\n{\n\tstruct stat st;\n\tchar *buf, buffer[256];\n\tunsigned char sha1[20];\n\tint fd;\n\tssize_t len;\n\n\tif (lstat(path, &st) < 0)\n\t\treturn -1;\n\n\t/* Make sure it is a \"refs/..\" symlink */\n\tif (S_ISLNK(st.st_mode)) {\n\t\tlen = readlink(path, buffer, sizeof(buffer)-1);\n\t\tif (len >= 5 && !memcmp(\"refs/\", buffer, 5))\n\t\t\treturn 0;\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Anything else, just open it and try to see if it is a symbolic ref.\n\t */\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\tlen = read_in_full(fd, buffer, sizeof(buffer)-1);\n\tclose(fd);\n\n\t/*\n\t * Is it a symbolic ref?\n\t */\n\tif (len < 4)\n\t\treturn -1;\n\tif (!memcmp(\"ref:\", buffer, 4)) {\n\t\tbuf = buffer + 4;\n\t\tlen -= 4;\n\t\twhile (len && isspace(*buf))\n\t\t\tbuf++, len--;\n\t\tif (len >= 5 && !memcmp(\"refs/\", buf, 5))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Is this a detached HEAD?\n\t */\n\tif (!get_sha1_hex(buffer, sha1))\n\t\treturn 0;\n\n\treturn -1;\n}\n\nstatic struct passwd *getpw_str(const char *username, size_t len)\n{\n\tstruct passwd *pw;\n\tchar *username_z = xmalloc(len + 1);\n\tmemcpy(username_z, username, len);\n\tusername_z[len] = '\\0';\n\tpw = getpwnam(username_z);\n\tfree(username_z);\n\treturn pw;\n}\n\n/*\n * Return a string with ~ and ~user expanded via getpw*.  If buf != NULL,\n * then it is a newly allocated string. Returns NULL on getpw failure or\n * if path is NULL.\n */\nchar *expand_user_path(const char *path)\n{\n\tstruct strbuf user_path = STRBUF_INIT;\n\tconst char *first_slash = strchrnul(path, '/');\n\tconst char *to_copy = path;\n\n\tif (path == NULL)\n\t\tgoto return_null;\n\tif (path[0] == '~') {\n\t\tconst char *username = path + 1;\n\t\tsize_t username_len = first_slash - username;\n\t\tif (username_len == 0) {\n\t\t\tconst char *home = getenv(\"HOME\");\n\t\t\tstrbuf_add(&user_path, home, strlen(home));\n\t\t} else {\n\t\t\tstruct passwd *pw = getpw_str(username, username_len);\n\t\t\tif (!pw)\n\t\t\t\tgoto return_null;\n\t\t\tstrbuf_add(&user_path, pw->pw_dir, strlen(pw->pw_dir));\n\t\t}\n\t\tto_copy = first_slash;\n\t}\n\tstrbuf_add(&user_path, to_copy, strlen(to_copy));\n\treturn strbuf_detach(&user_path, NULL);\nreturn_null:\n\tstrbuf_release(&user_path);\n\treturn NULL;\n}\n\n/*\n * First, one directory to try is determined by the following algorithm.\n *\n * (0) If \"strict\" is given, the path is used as given and no DWIM is\n *     done. Otherwise:\n * (1) \"~/path\" to mean path under the running user's home directory;\n * (2) \"~user/path\" to mean path under named user's home directory;\n * (3) \"relative/path\" to mean cwd relative directory; or\n * (4) \"/absolute/path\" to mean absolute directory.\n *\n * Unless \"strict\" is given, we try access() for existence of \"%s.git/.git\",\n * \"%s/.git\", \"%s.git\", \"%s\" in this order.  The first one that exists is\n * what we try.\n *\n * Second, we try chdir() to that.  Upon failure, we return NULL.\n *\n * Then, we try if the current directory is a valid git repository.\n * Upon failure, we return NULL.\n *\n * If all goes well, we return the directory we used to chdir() (but\n * before ~user is expanded), avoiding getcwd() resolving symbolic\n * links.  User relative paths are also returned as they are given,\n * except DWIM suffixing.\n */\nchar *enter_repo(char *path, int strict)\n{\n\tstatic char used_path[PATH_MAX];\n\tstatic char validated_path[PATH_MAX];\n\n\tif (!path)\n\t\treturn NULL;\n\n\tif (!strict) {\n\t\tstatic const char *suffix[] = {\n\t\t\t\".git/.git\", \"/.git\", \".git\", \"\", NULL,\n\t\t};\n\t\tint len = strlen(path);\n\t\tint i;\n\t\twhile ((1 < len) && (path[len-1] == '/')) {\n\t\t\tpath[len-1] = 0;\n\t\t\tlen--;\n\t\t}\n\t\tif (PATH_MAX <= len)\n\t\t\treturn NULL;\n\t\tif (path[0] == '~') {\n\t\t\tchar *newpath = expand_user_path(path);\n\t\t\tif (!newpath || (PATH_MAX - 10 < strlen(newpath))) {\n\t\t\t\tfree(newpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Copy back into the static buffer. A pity\n\t\t\t * since newpath was not bounded, but other\n\t\t\t * branches of the if are limited by PATH_MAX\n\t\t\t * anyway.\n\t\t\t */\n\t\t\tstrcpy(used_path, newpath); free(newpath);\n\t\t\tstrcpy(validated_path, path);\n\t\t\tpath = used_path;\n\t\t}\n\t\telse if (PATH_MAX - 10 < len)\n\t\t\treturn NULL;\n\t\telse {\n\t\t\tpath = strcpy(used_path, path);\n\t\t\tstrcpy(validated_path, path);\n\t\t}\n\t\tlen = strlen(path);\n\t\tfor (i = 0; suffix[i]; i++) {\n\t\t\tstrcpy(path + len, suffix[i]);\n\t\t\tif (!access(path, F_OK)) {\n\t\t\t\tstrcat(validated_path, suffix[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!suffix[i] || chdir(path))\n\t\t\treturn NULL;\n\t\tpath = validated_path;\n\t}\n\telse if (chdir(path))\n\t\treturn NULL;\n\n\tif (access(\"objects\", X_OK) == 0 && access(\"refs\", X_OK) == 0 &&\n\t    validate_headref(\"HEAD\") == 0) {\n\t\tset_git_dir(\".\");\n\t\tcheck_repository_format();\n\t\treturn path;\n\t}\n\n\treturn NULL;\n}\n\nint set_shared_perm(const char *path, int mode)\n{\n\tstruct stat st;\n\tint tweak, shared, orig_mode;\n\n\tif (!shared_repository) {\n\t\tif (mode)\n\t\t\treturn chmod(path, mode & ~S_IFMT);\n\t\treturn 0;\n\t}\n\tif (!mode) {\n\t\tif (lstat(path, &st) < 0)\n\t\t\treturn -1;\n\t\tmode = st.st_mode;\n\t\torig_mode = mode;\n\t} else\n\t\torig_mode = 0;\n\tif (shared_repository < 0)\n\t\tshared = -shared_repository;\n\telse\n\t\tshared = shared_repository;\n\ttweak = shared;\n\n\tif (!(mode & S_IWUSR))\n\t\ttweak &= ~0222;\n\tif (mode & S_IXUSR)\n\t\t/* Copy read bits to execute bits */\n\t\ttweak |= (tweak & 0444) >> 2;\n\tif (shared_repository < 0)\n\t\tmode = (mode & ~0777) | tweak;\n\telse\n\t\tmode |= tweak;\n\n\tif (S_ISDIR(mode)) {\n\t\t/* Copy read bits to execute bits */\n\t\tmode |= (shared & 0444) >> 2;\n\t\tmode |= FORCE_DIR_SET_GID;\n\t}\n\n\tif (((shared_repository < 0\n\t      ? (orig_mode & (FORCE_DIR_SET_GID | 0777))\n\t      : (orig_mode & mode)) != mode) &&\n\t    chmod(path, (mode & ~S_IFMT)) < 0)\n\t\treturn -2;\n\treturn 0;\n}\n\nconst char *make_relative_path(const char *abs, const char *base)\n{\n\tstatic char buf[PATH_MAX + 1];\n\tint i = 0, j = 0;\n\n\tif (!base || !base[0])\n\t\treturn abs;\n\twhile (base[i]) {\n\t\tif (is_dir_sep(base[i])) {\n\t\t\tif (!is_dir_sep(abs[j]))\n\t\t\t\treturn abs;\n\t\t\twhile (is_dir_sep(base[i]))\n\t\t\t\ti++;\n\t\t\twhile (is_dir_sep(abs[j]))\n\t\t\t\tj++;\n\t\t\tcontinue;\n\t\t} else if (abs[j] != base[i]) {\n\t\t\treturn abs;\n\t\t}\n\t\ti++;\n\t\tj++;\n\t}\n\tif (\n\t    /* \"/foo\" is a prefix of \"/foo\" */\n\t    abs[j] &&\n\t    /* \"/foo\" is not a prefix of \"/foobar\" */\n\t    !is_dir_sep(base[i-1]) && !is_dir_sep(abs[j])\n\t   )\n\t\treturn abs;\n\twhile (is_dir_sep(abs[j]))\n\t\tj++;\n\tif (!abs[j])\n\t\tstrcpy(buf, \".\");\n\telse\n\t\tstrcpy(buf, abs + j);\n\treturn buf;\n}\n\n/*\n * It is okay if dst == src, but they should not overlap otherwise.\n *\n * Performs the following normalizations on src, storing the result in dst:\n * - Ensures that components are separated by '/' (Windows only)\n * - Squashes sequences of '/'.\n * - Removes \".\" components.\n * - Removes \"..\" components, and the components the precede them.\n * Returns failure (non-zero) if a \"..\" component appears as first path\n * component anytime during the normalization. Otherwise, returns success (0).\n *\n * Note that this function is purely textual.  It does not follow symlinks,\n * verify the existence of the path, or make any system calls.\n */\nint normalize_path_copy(char *dst, const char *src)\n{\n\tchar *dst0;\n\n\tif (has_dos_drive_prefix(src)) {\n\t\t*dst++ = *src++;\n\t\t*dst++ = *src++;\n\t}\n\tdst0 = dst;\n\n\tif (is_dir_sep(*src)) {\n\t\t*dst++ = '/';\n\t\twhile (is_dir_sep(*src))\n\t\t\tsrc++;\n\t}\n\n\tfor (;;) {\n\t\tchar c = *src;\n\n\t\t/*\n\t\t * A path component that begins with . could be\n\t\t * special:\n\t\t * (1) \".\" and ends   -- ignore and terminate.\n\t\t * (2) \"./\"           -- ignore them, eat slash and continue.\n\t\t * (3) \"..\" and ends  -- strip one and terminate.\n\t\t * (4) \"../\"          -- strip one, eat slash and continue.\n\t\t */\n\t\tif (c == '.') {\n\t\t\tif (!src[1]) {\n\t\t\t\t/* (1) */\n\t\t\t\tsrc++;\n\t\t\t} else if (is_dir_sep(src[1])) {\n\t\t\t\t/* (2) */\n\t\t\t\tsrc += 2;\n\t\t\t\twhile (is_dir_sep(*src))\n\t\t\t\t\tsrc++;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (!src[2]) {\n\t\t\t\t\t/* (3) */\n\t\t\t\t\tsrc += 2;\n\t\t\t\t\tgoto up_one;\n\t\t\t\t} else if (is_dir_sep(src[2])) {\n\t\t\t\t\t/* (4) */\n\t\t\t\t\tsrc += 3;\n\t\t\t\t\twhile (is_dir_sep(*src))\n\t\t\t\t\t\tsrc++;\n\t\t\t\t\tgoto up_one;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* copy up to the next '/', and eat all '/' */\n\t\twhile ((c = *src++) != '\\0' && !is_dir_sep(c))\n\t\t\t*dst++ = c;\n\t\tif (is_dir_sep(c)) {\n\t\t\t*dst++ = '/';\n\t\t\twhile (is_dir_sep(c))\n\t\t\t\tc = *src++;\n\t\t\tsrc--;\n\t\t} else if (!c)\n\t\t\tbreak;\n\t\tcontinue;\n\n\tup_one:\n\t\t/*\n\t\t * dst0..dst is prefix portion, and dst[-1] is '/';\n\t\t * go up one level.\n\t\t */\n\t\tdst--;\t/* go to trailing '/' */\n\t\tif (dst <= dst0)\n\t\t\treturn -1;\n\t\t/* Windows: dst[-1] cannot be backslash anymore */\n\t\twhile (dst0 < dst && dst[-1] != '/')\n\t\t\tdst--;\n\t}\n\t*dst = '\\0';\n\treturn 0;\n}\n\n/*\n * path = Canonical absolute path\n * prefix_list = Colon-separated list of absolute paths\n *\n * Determines, for each path in prefix_list, whether the \"prefix\" really\n * is an ancestor directory of path.  Returns the length of the longest\n * ancestor directory, excluding any trailing slashes, or -1 if no prefix\n * is an ancestor.  (Note that this means 0 is returned if prefix_list is\n * \"/\".) \"/foo\" is not considered an ancestor of \"/foobar\".  Directories\n * are not considered to be their own ancestors.  path must be in a\n * canonical form: empty components, or \".\" or \"..\" components are not\n * allowed.  prefix_list may be null, which is like \"\".\n */\nint longest_ancestor_length(const char *path, const char *prefix_list)\n{\n\tchar buf[PATH_MAX+1];\n\tconst char *ceil, *colon;\n\tint len, max_len = -1;\n\n\tif (prefix_list == NULL || !strcmp(path, \"/\"))\n\t\treturn -1;\n\n\tfor (colon = ceil = prefix_list; *colon; ceil = colon+1) {\n\t\tfor (colon = ceil; *colon && *colon != PATH_SEP; colon++);\n\t\tlen = colon - ceil;\n\t\tif (len == 0 || len > PATH_MAX || !is_absolute_path(ceil))\n\t\t\tcontinue;\n\t\tstrlcpy(buf, ceil, len+1);\n\t\tif (normalize_path_copy(buf, buf) < 0)\n\t\t\tcontinue;\n\t\tlen = strlen(buf);\n\t\tif (len > 0 && buf[len-1] == '/')\n\t\t\tbuf[--len] = '\\0';\n\n\t\tif (!strncmp(path, buf, len) &&\n\t\t    path[len] == '/' &&\n\t\t    len > max_len) {\n\t\t\tmax_len = len;\n\t\t}\n\t}\n\n\treturn max_len;\n}\n\n/* strip arbitrary amount of directory separators at end of path */\nstatic inline int chomp_trailing_dir_sep(const char *path, int len)\n{\n\twhile (len && is_dir_sep(path[len - 1]))\n\t\tlen--;\n\treturn len;\n}\n\n/*\n * If path ends with suffix (complete path components), returns the\n * part before suffix (sans trailing directory separators).\n * Otherwise returns NULL.\n */\nchar *strip_path_suffix(const char *path, const char *suffix)\n{\n\tint path_len = strlen(path), suffix_len = strlen(suffix);\n\n\twhile (suffix_len) {\n\t\tif (!path_len)\n\t\t\treturn NULL;\n\n\t\tif (is_dir_sep(path[path_len - 1])) {\n\t\t\tif (!is_dir_sep(suffix[suffix_len - 1]))\n\t\t\t\treturn NULL;\n\t\t\tpath_len = chomp_trailing_dir_sep(path, path_len);\n\t\t\tsuffix_len = chomp_trailing_dir_sep(suffix, suffix_len);\n\t\t}\n\t\telse if (path[--path_len] != suffix[--suffix_len])\n\t\t\treturn NULL;\n\t}\n\n\tif (path_len && !is_dir_sep(path[path_len - 1]))\n\t\treturn NULL;\n\treturn xstrndup(path, chomp_trailing_dir_sep(path, path_len));\n}\n\nint daemon_avoid_alias(const char *p)\n{\n\tint sl, ndot;\n\n\t/*\n\t * This resurrects the belts and suspenders paranoia check by HPA\n\t * done in <435560F7.4080006@zytor.com> thread, now enter_repo()\n\t * does not do getcwd() based path canonicalizations.\n\t *\n\t * sl becomes true immediately after seeing '/' and continues to\n\t * be true as long as dots continue after that without intervening\n\t * non-dot character.\n\t */\n\tif (!p || (*p != '/' && *p != '~'))\n\t\treturn -1;\n\tsl = 1; ndot = 0;\n\tp++;\n\n\twhile (1) {\n\t\tchar ch = *p++;\n\t\tif (sl) {\n\t\t\tif (ch == '.')\n\t\t\t\tndot++;\n\t\t\telse if (ch == '/') {\n\t\t\t\tif (ndot < 3)\n\t\t\t\t\t/* reject //, /./ and /../ */\n\t\t\t\t\treturn -1;\n\t\t\t\tndot = 0;\n\t\t\t}\n\t\t\telse if (ch == 0) {\n\t\t\t\tif (0 < ndot && ndot < 3)\n\t\t\t\t\t/* reject /.$ and /..$ */\n\t\t\t\t\treturn -1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tsl = ndot = 0;\n\t\t}\n\t\telse if (ch == 0)\n\t\t\treturn 0;\n\t\telse if (ch == '/') {\n\t\t\tsl = 1;\n\t\t\tndot = 0;\n\t\t}\n\t}\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0005df3a5faad038b1d3af07585faaf1e8d59de4",
  "sha1_ok": false,
  "size": 14872
}
