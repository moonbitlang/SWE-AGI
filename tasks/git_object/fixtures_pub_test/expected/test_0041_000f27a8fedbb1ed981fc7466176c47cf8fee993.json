{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAidHJlZS5oIgojaW5jbHVkZSAiYmxvYi5oIgojaW5jbHVkZSAidHJlZS13YWxrLmgiCiNpbmNsdWRlICJkaWZmLmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgoKLyogYml0cyAjMC02IGluIHJldmlzaW9uLmggKi8KCiNkZWZpbmUgQ09VTlRFRAkJKDF1PDw3KQoKc3RhdGljIGNvbnN0IGNoYXIgcmV2X2xpc3RfdXNhZ2VbXSA9CiJnaXQtcmV2LWxpc3QgW09QVElPTl0gPGNvbW1pdC1pZD4uLi4gWyAtLSBwYXRocy4uLiBdXG4iCiIgIGxpbWl0aW5nIG91dHB1dDpcbiIKIiAgICAtLW1heC1jb3VudD1uclxuIgoiICAgIC0tbWF4LWFnZT1lcG9jaFxuIgoiICAgIC0tbWluLWFnZT1lcG9jaFxuIgoiICAgIC0tc3BhcnNlXG4iCiIgICAgLS1uby1tZXJnZXNcbiIKIiAgICAtLXJlbW92ZS1lbXB0eVxuIgoiICAgIC0tYWxsXG4iCiIgIG9yZGVyaW5nIG91dHB1dDpcbiIKIiAgICAtLXRvcG8tb3JkZXJcbiIKIiAgICAtLWRhdGUtb3JkZXJcbiIKIiAgZm9ybWF0dGluZyBvdXRwdXQ6XG4iCiIgICAgLS1wYXJlbnRzXG4iCiIgICAgLS1vYmplY3RzIHwgLS1vYmplY3RzLWVkZ2VcbiIKIiAgICAtLXVucGFja2VkXG4iCiIgICAgLS1oZWFkZXIgfCAtLXByZXR0eVxuIgoiICAgIC0tYWJicmV2PW5yIHwgLS1uby1hYmJyZXZcbiIKIiAgICAtLWFiYnJldi1jb21taXRcbiIKIiAgc3BlY2lhbCBwdXJwb3NlOlxuIgoiICAgIC0tYmlzZWN0Igo7CgpzdHJ1Y3QgcmV2X2luZm8gcmV2czsKCnN0YXRpYyBpbnQgYmlzZWN0X2xpc3QgPSAwOwpzdGF0aWMgaW50IHNob3dfdGltZXN0YW1wID0gMDsKc3RhdGljIGludCBoZHJfdGVybWluYXRpb24gPSAwOwoKc3RhdGljIHZvaWQgc2hvd19jb21taXQoc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglpZiAoc2hvd190aW1lc3RhbXApCgkJcHJpbnRmKCIlbHUgIiwgY29tbWl0LT5kYXRlKTsKCWlmICgqcmV2cy5oZWFkZXJfcHJlZml4KQoJCWZwdXRzKHJldnMuaGVhZGVyX3ByZWZpeCwgc3Rkb3V0KTsKCWlmIChjb21taXQtPm9iamVjdC5mbGFncyAmIEJPVU5EQVJZKQoJCXB1dGNoYXIoJy0nKTsKCWlmIChyZXZzLmFiYnJldl9jb21taXQgJiYgcmV2cy5hYmJyZXYpCgkJZnB1dHMoZmluZF91bmlxdWVfYWJicmV2KGNvbW1pdC0+b2JqZWN0LnNoYTEsIHJldnMuYWJicmV2KSwKCQkgICAgICBzdGRvdXQpOwoJZWxzZQoJCWZwdXRzKHNoYTFfdG9faGV4KGNvbW1pdC0+b2JqZWN0LnNoYTEpLCBzdGRvdXQpOwoJaWYgKHJldnMucGFyZW50cykgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50cyA9IGNvbW1pdC0+cGFyZW50czsKCQl3aGlsZSAocGFyZW50cykgewoJCQlzdHJ1Y3Qgb2JqZWN0ICpvID0gJihwYXJlbnRzLT5pdGVtLT5vYmplY3QpOwoJCQlwYXJlbnRzID0gcGFyZW50cy0+bmV4dDsKCQkJaWYgKG8tPmZsYWdzICYgVE1QX01BUkspCgkJCQljb250aW51ZTsKCQkJcHJpbnRmKCIgJXMiLCBzaGExX3RvX2hleChvLT5zaGExKSk7CgkJCW8tPmZsYWdzIHw9IFRNUF9NQVJLOwoJCX0KCQkvKiBUTVBfTUFSSyBpcyBhIGdlbmVyYWwgcHVycG9zZSBmbGFnIHRoYXQgY2FuCgkJICogYmUgdXNlZCBsb2NhbGx5LCBidXQgdGhlIHVzZXIgc2hvdWxkIGNsZWFuCgkJICogdGhpbmdzIHVwIGFmdGVyIGl0IGlzIGRvbmUgd2l0aCB0aGVtLgoJCSAqLwoJCWZvciAocGFyZW50cyA9IGNvbW1pdC0+cGFyZW50czsKCQkgICAgIHBhcmVudHM7CgkJICAgICBwYXJlbnRzID0gcGFyZW50cy0+bmV4dCkKCQkJcGFyZW50cy0+aXRlbS0+b2JqZWN0LmZsYWdzICY9IH5UTVBfTUFSSzsKCX0KCWlmIChyZXZzLmNvbW1pdF9mb3JtYXQgPT0gQ01JVF9GTVRfT05FTElORSkKCQlwdXRjaGFyKCcgJyk7CgllbHNlCgkJcHV0Y2hhcignXG4nKTsKCglpZiAocmV2cy52ZXJib3NlX2hlYWRlcikgewoJCXN0YXRpYyBjaGFyIHByZXR0eV9oZWFkZXJbMTYzODRdOwoJCXByZXR0eV9wcmludF9jb21taXQocmV2cy5jb21taXRfZm9ybWF0LCBjb21taXQsIH4wLAoJCQkJICAgIHByZXR0eV9oZWFkZXIsIHNpemVvZihwcmV0dHlfaGVhZGVyKSwKCQkJCSAgICByZXZzLmFiYnJldik7CgkJcHJpbnRmKCIlcyVjIiwgcHJldHR5X2hlYWRlciwgaGRyX3Rlcm1pbmF0aW9uKTsKCX0KCWZmbHVzaChzdGRvdXQpOwp9CgpzdGF0aWMgc3RydWN0IG9iamVjdF9saXN0ICoqcHJvY2Vzc19ibG9iKHN0cnVjdCBibG9iICpibG9iLAoJCQkJCSBzdHJ1Y3Qgb2JqZWN0X2xpc3QgKipwLAoJCQkJCSBzdHJ1Y3QgbmFtZV9wYXRoICpwYXRoLAoJCQkJCSBjb25zdCBjaGFyICpuYW1lKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmogPSAmYmxvYi0+b2JqZWN0OwoKCWlmICghcmV2cy5ibG9iX29iamVjdHMpCgkJcmV0dXJuIHA7CglpZiAob2JqLT5mbGFncyAmIChVTklOVEVSRVNUSU5HIHwgU0VFTikpCgkJcmV0dXJuIHA7CglvYmotPmZsYWdzIHw9IFNFRU47CglyZXR1cm4gYWRkX29iamVjdChvYmosIHAsIHBhdGgsIG5hbWUpOwp9CgpzdGF0aWMgc3RydWN0IG9iamVjdF9saXN0ICoqcHJvY2Vzc190cmVlKHN0cnVjdCB0cmVlICp0cmVlLAoJCQkJCSBzdHJ1Y3Qgb2JqZWN0X2xpc3QgKipwLAoJCQkJCSBzdHJ1Y3QgbmFtZV9wYXRoICpwYXRoLAoJCQkJCSBjb25zdCBjaGFyICpuYW1lKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmogPSAmdHJlZS0+b2JqZWN0OwoJc3RydWN0IHRyZWVfZW50cnlfbGlzdCAqZW50cnk7CglzdHJ1Y3QgbmFtZV9wYXRoIG1lOwoKCWlmICghcmV2cy50cmVlX29iamVjdHMpCgkJcmV0dXJuIHA7CglpZiAob2JqLT5mbGFncyAmIChVTklOVEVSRVNUSU5HIHwgU0VFTikpCgkJcmV0dXJuIHA7CglpZiAocGFyc2VfdHJlZSh0cmVlKSA8IDApCgkJZGllKCJiYWQgdHJlZSBvYmplY3QgJXMiLCBzaGExX3RvX2hleChvYmotPnNoYTEpKTsKCW9iai0+ZmxhZ3MgfD0gU0VFTjsKCXAgPSBhZGRfb2JqZWN0KG9iaiwgcCwgcGF0aCwgbmFtZSk7CgltZS51cCA9IHBhdGg7CgltZS5lbGVtID0gbmFtZTsKCW1lLmVsZW1fbGVuID0gc3RybGVuKG5hbWUpOwoJZW50cnkgPSB0cmVlLT5lbnRyaWVzOwoJdHJlZS0+ZW50cmllcyA9IE5VTEw7Cgl3aGlsZSAoZW50cnkpIHsKCQlzdHJ1Y3QgdHJlZV9lbnRyeV9saXN0ICpuZXh0ID0gZW50cnktPm5leHQ7CgkJaWYgKGVudHJ5LT5kaXJlY3RvcnkpCgkJCXAgPSBwcm9jZXNzX3RyZWUoZW50cnktPml0ZW0udHJlZSwgcCwgJm1lLCBlbnRyeS0+bmFtZSk7CgkJZWxzZQoJCQlwID0gcHJvY2Vzc19ibG9iKGVudHJ5LT5pdGVtLmJsb2IsIHAsICZtZSwgZW50cnktPm5hbWUpOwoJCWZyZWUoZW50cnkpOwoJCWVudHJ5ID0gbmV4dDsKCX0KCXJldHVybiBwOwp9CgpzdGF0aWMgdm9pZCBzaG93X2NvbW1pdF9saXN0KHN0cnVjdCByZXZfaW5mbyAqcmV2cykKewoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJc3RydWN0IG9iamVjdF9saXN0ICpvYmplY3RzID0gTlVMTCwgKipwID0gJm9iamVjdHMsICpwZW5kaW5nOwoKCXdoaWxlICgoY29tbWl0ID0gZ2V0X3JldmlzaW9uKHJldnMpKSAhPSBOVUxMKSB7CgkJcCA9IHByb2Nlc3NfdHJlZShjb21taXQtPnRyZWUsIHAsIE5VTEwsICIiKTsKCQlzaG93X2NvbW1pdChjb21taXQpOwoJfQoJZm9yIChwZW5kaW5nID0gcmV2cy0+cGVuZGluZ19vYmplY3RzOyBwZW5kaW5nOyBwZW5kaW5nID0gcGVuZGluZy0+bmV4dCkgewoJCXN0cnVjdCBvYmplY3QgKm9iaiA9IHBlbmRpbmctPml0ZW07CgkJY29uc3QgY2hhciAqbmFtZSA9IHBlbmRpbmctPm5hbWU7CgkJaWYgKG9iai0+ZmxhZ3MgJiAoVU5JTlRFUkVTVElORyB8IFNFRU4pKQoJCQljb250aW51ZTsKCQlpZiAob2JqLT50eXBlID09IHRhZ190eXBlKSB7CgkJCW9iai0+ZmxhZ3MgfD0gU0VFTjsKCQkJcCA9IGFkZF9vYmplY3Qob2JqLCBwLCBOVUxMLCBuYW1lKTsKCQkJY29udGludWU7CgkJfQoJCWlmIChvYmotPnR5cGUgPT0gdHJlZV90eXBlKSB7CgkJCXAgPSBwcm9jZXNzX3RyZWUoKHN0cnVjdCB0cmVlICopb2JqLCBwLCBOVUxMLCBuYW1lKTsKCQkJY29udGludWU7CgkJfQoJCWlmIChvYmotPnR5cGUgPT0gYmxvYl90eXBlKSB7CgkJCXAgPSBwcm9jZXNzX2Jsb2IoKHN0cnVjdCBibG9iICopb2JqLCBwLCBOVUxMLCBuYW1lKTsKCQkJY29udGludWU7CgkJfQoJCWRpZSgidW5rbm93biBwZW5kaW5nIG9iamVjdCAlcyAoJXMpIiwgc2hhMV90b19oZXgob2JqLT5zaGExKSwgbmFtZSk7Cgl9Cgl3aGlsZSAob2JqZWN0cykgewoJCS8qIEFuIG9iamVjdCB3aXRoIG5hbWUgImZvb1xuMDAwMDAwMC4uLiIgY2FuIGJlIHVzZWQgdG8KCQkgKiBjb25mdXNlIGRvd25zdHJlYW0gZ2l0LXBhY2stb2JqZWN0cyB2ZXJ5IGJhZGx5LgoJCSAqLwoJCWNvbnN0IGNoYXIgKmVwID0gc3RyY2hyKG9iamVjdHMtPm5hbWUsICdcbicpOwoJCWlmIChlcCkgewoJCQlwcmludGYoIiVzICUuKnNcbiIsIHNoYTFfdG9faGV4KG9iamVjdHMtPml0ZW0tPnNoYTEpLAoJCQkgICAgICAgKGludCkgKGVwIC0gb2JqZWN0cy0+bmFtZSksCgkJCSAgICAgICBvYmplY3RzLT5uYW1lKTsKCQl9CgkJZWxzZQoJCQlwcmludGYoIiVzICVzXG4iLCBzaGExX3RvX2hleChvYmplY3RzLT5pdGVtLT5zaGExKSwgb2JqZWN0cy0+bmFtZSk7CgkJb2JqZWN0cyA9IG9iamVjdHMtPm5leHQ7Cgl9Cn0KCi8qCiAqIFRoaXMgaXMgYSB0cnVseSBzdHVwaWQgYWxnb3JpdGhtLCBidXQgaXQncyBvbmx5CiAqIHVzZWQgZm9yIGJpc2VjdGlvbiwgYW5kIHdlIGp1c3QgZG9uJ3QgY2FyZSBlbm91Z2guCiAqCiAqIFdlIGNhcmUganVzdCBiYXJlbHkgZW5vdWdoIHRvIGF2b2lkIHJlY3Vyc2luZyBmb3IKICogbm9uLW1lcmdlIGVudHJpZXMuCiAqLwpzdGF0aWMgaW50IGNvdW50X2Rpc3RhbmNlKHN0cnVjdCBjb21taXRfbGlzdCAqZW50cnkpCnsKCWludCBuciA9IDA7CgoJd2hpbGUgKGVudHJ5KSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gZW50cnktPml0ZW07CgkJc3RydWN0IGNvbW1pdF9saXN0ICpwOwoKCQlpZiAoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiAoVU5JTlRFUkVTVElORyB8IENPVU5URUQpKQoJCQlicmVhazsKCQlpZiAoIXJldnMucHJ1bmVfZm4gfHwgKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgVFJFRUNIQU5HRSkpCgkJCW5yKys7CgkJY29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gQ09VTlRFRDsKCQlwID0gY29tbWl0LT5wYXJlbnRzOwoJCWVudHJ5ID0gcDsKCQlpZiAocCkgewoJCQlwID0gcC0+bmV4dDsKCQkJd2hpbGUgKHApIHsKCQkJCW5yICs9IGNvdW50X2Rpc3RhbmNlKHApOwoJCQkJcCA9IHAtPm5leHQ7CgkJCX0KCQl9Cgl9CgoJcmV0dXJuIG5yOwp9CgpzdGF0aWMgdm9pZCBjbGVhcl9kaXN0YW5jZShzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QpCnsKCXdoaWxlIChsaXN0KSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gbGlzdC0+aXRlbTsKCQljb21taXQtPm9iamVjdC5mbGFncyAmPSB+Q09VTlRFRDsKCQlsaXN0ID0gbGlzdC0+bmV4dDsKCX0KfQoKc3RhdGljIHN0cnVjdCBjb21taXRfbGlzdCAqZmluZF9iaXNlY3Rpb24oc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0KQp7CglpbnQgbnIsIGNsb3Nlc3Q7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnAsICpiZXN0OwoKCW5yID0gMDsKCXAgPSBsaXN0OwoJd2hpbGUgKHApIHsKCQlpZiAoIXJldnMucHJ1bmVfZm4gfHwgKHAtPml0ZW0tPm9iamVjdC5mbGFncyAmIFRSRUVDSEFOR0UpKQoJCQlucisrOwoJCXAgPSBwLT5uZXh0OwoJfQoJY2xvc2VzdCA9IDA7CgliZXN0ID0gbGlzdDsKCglmb3IgKHAgPSBsaXN0OyBwOyBwID0gcC0+bmV4dCkgewoJCWludCBkaXN0YW5jZTsKCgkJaWYgKHJldnMucHJ1bmVfZm4gJiYgIShwLT5pdGVtLT5vYmplY3QuZmxhZ3MgJiBUUkVFQ0hBTkdFKSkKCQkJY29udGludWU7CgoJCWRpc3RhbmNlID0gY291bnRfZGlzdGFuY2UocCk7CgkJY2xlYXJfZGlzdGFuY2UobGlzdCk7CgkJaWYgKG5yIC0gZGlzdGFuY2UgPCBkaXN0YW5jZSkKCQkJZGlzdGFuY2UgPSBuciAtIGRpc3RhbmNlOwoJCWlmIChkaXN0YW5jZSA+IGNsb3Nlc3QpIHsKCQkJYmVzdCA9IHA7CgkJCWNsb3Nlc3QgPSBkaXN0YW5jZTsKCQl9Cgl9CglpZiAoYmVzdCkKCQliZXN0LT5uZXh0ID0gTlVMTDsKCXJldHVybiBiZXN0Owp9CgpzdGF0aWMgdm9pZCBtYXJrX2VkZ2VfcGFyZW50c191bmludGVyZXN0aW5nKHN0cnVjdCBjb21taXQgKmNvbW1pdCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzOwoKCWZvciAocGFyZW50cyA9IGNvbW1pdC0+cGFyZW50czsgcGFyZW50czsgcGFyZW50cyA9IHBhcmVudHMtPm5leHQpIHsKCQlzdHJ1Y3QgY29tbWl0ICpwYXJlbnQgPSBwYXJlbnRzLT5pdGVtOwoJCWlmICghKHBhcmVudC0+b2JqZWN0LmZsYWdzICYgVU5JTlRFUkVTVElORykpCgkJCWNvbnRpbnVlOwoJCW1hcmtfdHJlZV91bmludGVyZXN0aW5nKHBhcmVudC0+dHJlZSk7CgkJaWYgKHJldnMuZWRnZV9oaW50ICYmICEocGFyZW50LT5vYmplY3QuZmxhZ3MgJiBTSE9XTikpIHsKCQkJcGFyZW50LT5vYmplY3QuZmxhZ3MgfD0gU0hPV047CgkJCXByaW50ZigiLSVzXG4iLCBzaGExX3RvX2hleChwYXJlbnQtPm9iamVjdC5zaGExKSk7CgkJfQoJfQp9CgpzdGF0aWMgdm9pZCBtYXJrX2VkZ2VzX3VuaW50ZXJlc3Rpbmcoc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0KQp7Cglmb3IgKCA7IGxpc3Q7IGxpc3QgPSBsaXN0LT5uZXh0KSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gbGlzdC0+aXRlbTsKCgkJaWYgKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgVU5JTlRFUkVTVElORykgewoJCQltYXJrX3RyZWVfdW5pbnRlcmVzdGluZyhjb21taXQtPnRyZWUpOwoJCQljb250aW51ZTsKCQl9CgkJbWFya19lZGdlX3BhcmVudHNfdW5pbnRlcmVzdGluZyhjb21taXQpOwoJfQp9CgppbnQgbWFpbihpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqbGlzdDsKCWludCBpOwoKCWluaXRfcmV2aXNpb25zKCZyZXZzKTsKCXJldnMuYWJicmV2ID0gMDsKCXJldnMuY29tbWl0X2Zvcm1hdCA9IENNSVRfRk1UX1VOU1BFQ0lGSUVEOwoJYXJnYyA9IHNldHVwX3JldmlzaW9ucyhhcmdjLCBhcmd2LCAmcmV2cywgTlVMTCk7CgoJZm9yIChpID0gMSA7IGkgPCBhcmdjOyBpKyspIHsKCQljb25zdCBjaGFyICphcmcgPSBhcmd2W2ldOwoKCQlpZiAoIXN0cmNtcChhcmcsICItLWhlYWRlciIpKSB7CgkJCXJldnMudmVyYm9zZV9oZWFkZXIgPSAxOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKCFzdHJjbXAoYXJnLCAiLS10aW1lc3RhbXAiKSkgewoJCQlzaG93X3RpbWVzdGFtcCA9IDE7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoIXN0cmNtcChhcmcsICItLWJpc2VjdCIpKSB7CgkJCWJpc2VjdF9saXN0ID0gMTsKCQkJY29udGludWU7CgkJfQoJCXVzYWdlKHJldl9saXN0X3VzYWdlKTsKCgl9CglpZiAocmV2cy5jb21taXRfZm9ybWF0ICE9IENNSVRfRk1UX1VOU1BFQ0lGSUVEKSB7CgkJLyogVGhlIGNvbW1hbmQgbGluZSBoYXMgYSAtLXByZXR0eSAgKi8KCQloZHJfdGVybWluYXRpb24gPSAnXG4nOwoJCWlmIChyZXZzLmNvbW1pdF9mb3JtYXQgPT0gQ01JVF9GTVRfT05FTElORSkKCQkJcmV2cy5oZWFkZXJfcHJlZml4ID0gIiI7CgkJZWxzZQoJCQlyZXZzLmhlYWRlcl9wcmVmaXggPSAiY29tbWl0ICI7Cgl9CgoJbGlzdCA9IHJldnMuY29tbWl0czsKCglpZiAoKCFsaXN0ICYmCgkgICAgICghKHJldnMudGFnX29iamVjdHN8fHJldnMudHJlZV9vYmplY3RzfHxyZXZzLmJsb2Jfb2JqZWN0cykgJiYKCSAgICAgICFyZXZzLnBlbmRpbmdfb2JqZWN0cykpIHx8CgkgICAgcmV2cy5kaWZmKQoJCXVzYWdlKHJldl9saXN0X3VzYWdlKTsKCglzYXZlX2NvbW1pdF9idWZmZXIgPSByZXZzLnZlcmJvc2VfaGVhZGVyOwoJdHJhY2tfb2JqZWN0X3JlZnMgPSAwOwoKCXByZXBhcmVfcmV2aXNpb25fd2FsaygmcmV2cyk7CglpZiAocmV2cy50cmVlX29iamVjdHMpCgkJbWFya19lZGdlc191bmludGVyZXN0aW5nKHJldnMuY29tbWl0cyk7CgoJaWYgKGJpc2VjdF9saXN0KQoJCXJldnMuY29tbWl0cyA9IGZpbmRfYmlzZWN0aW9uKHJldnMuY29tbWl0cyk7CgoJc2hvd19jb21taXRfbGlzdCgmcmV2cyk7CgoJcmV0dXJuIDA7Cn0K",
    "text": "#include \"cache.h\"\n#include \"refs.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"tree.h\"\n#include \"blob.h\"\n#include \"tree-walk.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n\n/* bits #0-6 in revision.h */\n\n#define COUNTED\t\t(1u<<7)\n\nstatic const char rev_list_usage[] =\n\"git-rev-list [OPTION] <commit-id>... [ -- paths... ]\\n\"\n\"  limiting output:\\n\"\n\"    --max-count=nr\\n\"\n\"    --max-age=epoch\\n\"\n\"    --min-age=epoch\\n\"\n\"    --sparse\\n\"\n\"    --no-merges\\n\"\n\"    --remove-empty\\n\"\n\"    --all\\n\"\n\"  ordering output:\\n\"\n\"    --topo-order\\n\"\n\"    --date-order\\n\"\n\"  formatting output:\\n\"\n\"    --parents\\n\"\n\"    --objects | --objects-edge\\n\"\n\"    --unpacked\\n\"\n\"    --header | --pretty\\n\"\n\"    --abbrev=nr | --no-abbrev\\n\"\n\"    --abbrev-commit\\n\"\n\"  special purpose:\\n\"\n\"    --bisect\"\n;\n\nstruct rev_info revs;\n\nstatic int bisect_list = 0;\nstatic int show_timestamp = 0;\nstatic int hdr_termination = 0;\n\nstatic void show_commit(struct commit *commit)\n{\n\tif (show_timestamp)\n\t\tprintf(\"%lu \", commit->date);\n\tif (*revs.header_prefix)\n\t\tfputs(revs.header_prefix, stdout);\n\tif (commit->object.flags & BOUNDARY)\n\t\tputchar('-');\n\tif (revs.abbrev_commit && revs.abbrev)\n\t\tfputs(find_unique_abbrev(commit->object.sha1, revs.abbrev),\n\t\t      stdout);\n\telse\n\t\tfputs(sha1_to_hex(commit->object.sha1), stdout);\n\tif (revs.parents) {\n\t\tstruct commit_list *parents = commit->parents;\n\t\twhile (parents) {\n\t\t\tstruct object *o = &(parents->item->object);\n\t\t\tparents = parents->next;\n\t\t\tif (o->flags & TMP_MARK)\n\t\t\t\tcontinue;\n\t\t\tprintf(\" %s\", sha1_to_hex(o->sha1));\n\t\t\to->flags |= TMP_MARK;\n\t\t}\n\t\t/* TMP_MARK is a general purpose flag that can\n\t\t * be used locally, but the user should clean\n\t\t * things up after it is done with them.\n\t\t */\n\t\tfor (parents = commit->parents;\n\t\t     parents;\n\t\t     parents = parents->next)\n\t\t\tparents->item->object.flags &= ~TMP_MARK;\n\t}\n\tif (revs.commit_format == CMIT_FMT_ONELINE)\n\t\tputchar(' ');\n\telse\n\t\tputchar('\\n');\n\n\tif (revs.verbose_header) {\n\t\tstatic char pretty_header[16384];\n\t\tpretty_print_commit(revs.commit_format, commit, ~0,\n\t\t\t\t    pretty_header, sizeof(pretty_header),\n\t\t\t\t    revs.abbrev);\n\t\tprintf(\"%s%c\", pretty_header, hdr_termination);\n\t}\n\tfflush(stdout);\n}\n\nstatic struct object_list **process_blob(struct blob *blob,\n\t\t\t\t\t struct object_list **p,\n\t\t\t\t\t struct name_path *path,\n\t\t\t\t\t const char *name)\n{\n\tstruct object *obj = &blob->object;\n\n\tif (!revs.blob_objects)\n\t\treturn p;\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn p;\n\tobj->flags |= SEEN;\n\treturn add_object(obj, p, path, name);\n}\n\nstatic struct object_list **process_tree(struct tree *tree,\n\t\t\t\t\t struct object_list **p,\n\t\t\t\t\t struct name_path *path,\n\t\t\t\t\t const char *name)\n{\n\tstruct object *obj = &tree->object;\n\tstruct tree_entry_list *entry;\n\tstruct name_path me;\n\n\tif (!revs.tree_objects)\n\t\treturn p;\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn p;\n\tif (parse_tree(tree) < 0)\n\t\tdie(\"bad tree object %s\", sha1_to_hex(obj->sha1));\n\tobj->flags |= SEEN;\n\tp = add_object(obj, p, path, name);\n\tme.up = path;\n\tme.elem = name;\n\tme.elem_len = strlen(name);\n\tentry = tree->entries;\n\ttree->entries = NULL;\n\twhile (entry) {\n\t\tstruct tree_entry_list *next = entry->next;\n\t\tif (entry->directory)\n\t\t\tp = process_tree(entry->item.tree, p, &me, entry->name);\n\t\telse\n\t\t\tp = process_blob(entry->item.blob, p, &me, entry->name);\n\t\tfree(entry);\n\t\tentry = next;\n\t}\n\treturn p;\n}\n\nstatic void show_commit_list(struct rev_info *revs)\n{\n\tstruct commit *commit;\n\tstruct object_list *objects = NULL, **p = &objects, *pending;\n\n\twhile ((commit = get_revision(revs)) != NULL) {\n\t\tp = process_tree(commit->tree, p, NULL, \"\");\n\t\tshow_commit(commit);\n\t}\n\tfor (pending = revs->pending_objects; pending; pending = pending->next) {\n\t\tstruct object *obj = pending->item;\n\t\tconst char *name = pending->name;\n\t\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\t\tcontinue;\n\t\tif (obj->type == tag_type) {\n\t\t\tobj->flags |= SEEN;\n\t\t\tp = add_object(obj, p, NULL, name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (obj->type == tree_type) {\n\t\t\tp = process_tree((struct tree *)obj, p, NULL, name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (obj->type == blob_type) {\n\t\t\tp = process_blob((struct blob *)obj, p, NULL, name);\n\t\t\tcontinue;\n\t\t}\n\t\tdie(\"unknown pending object %s (%s)\", sha1_to_hex(obj->sha1), name);\n\t}\n\twhile (objects) {\n\t\t/* An object with name \"foo\\n0000000...\" can be used to\n\t\t * confuse downstream git-pack-objects very badly.\n\t\t */\n\t\tconst char *ep = strchr(objects->name, '\\n');\n\t\tif (ep) {\n\t\t\tprintf(\"%s %.*s\\n\", sha1_to_hex(objects->item->sha1),\n\t\t\t       (int) (ep - objects->name),\n\t\t\t       objects->name);\n\t\t}\n\t\telse\n\t\t\tprintf(\"%s %s\\n\", sha1_to_hex(objects->item->sha1), objects->name);\n\t\tobjects = objects->next;\n\t}\n}\n\n/*\n * This is a truly stupid algorithm, but it's only\n * used for bisection, and we just don't care enough.\n *\n * We care just barely enough to avoid recursing for\n * non-merge entries.\n */\nstatic int count_distance(struct commit_list *entry)\n{\n\tint nr = 0;\n\n\twhile (entry) {\n\t\tstruct commit *commit = entry->item;\n\t\tstruct commit_list *p;\n\n\t\tif (commit->object.flags & (UNINTERESTING | COUNTED))\n\t\t\tbreak;\n\t\tif (!revs.prune_fn || (commit->object.flags & TREECHANGE))\n\t\t\tnr++;\n\t\tcommit->object.flags |= COUNTED;\n\t\tp = commit->parents;\n\t\tentry = p;\n\t\tif (p) {\n\t\t\tp = p->next;\n\t\t\twhile (p) {\n\t\t\t\tnr += count_distance(p);\n\t\t\t\tp = p->next;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nr;\n}\n\nstatic void clear_distance(struct commit_list *list)\n{\n\twhile (list) {\n\t\tstruct commit *commit = list->item;\n\t\tcommit->object.flags &= ~COUNTED;\n\t\tlist = list->next;\n\t}\n}\n\nstatic struct commit_list *find_bisection(struct commit_list *list)\n{\n\tint nr, closest;\n\tstruct commit_list *p, *best;\n\n\tnr = 0;\n\tp = list;\n\twhile (p) {\n\t\tif (!revs.prune_fn || (p->item->object.flags & TREECHANGE))\n\t\t\tnr++;\n\t\tp = p->next;\n\t}\n\tclosest = 0;\n\tbest = list;\n\n\tfor (p = list; p; p = p->next) {\n\t\tint distance;\n\n\t\tif (revs.prune_fn && !(p->item->object.flags & TREECHANGE))\n\t\t\tcontinue;\n\n\t\tdistance = count_distance(p);\n\t\tclear_distance(list);\n\t\tif (nr - distance < distance)\n\t\t\tdistance = nr - distance;\n\t\tif (distance > closest) {\n\t\t\tbest = p;\n\t\t\tclosest = distance;\n\t\t}\n\t}\n\tif (best)\n\t\tbest->next = NULL;\n\treturn best;\n}\n\nstatic void mark_edge_parents_uninteresting(struct commit *commit)\n{\n\tstruct commit_list *parents;\n\n\tfor (parents = commit->parents; parents; parents = parents->next) {\n\t\tstruct commit *parent = parents->item;\n\t\tif (!(parent->object.flags & UNINTERESTING))\n\t\t\tcontinue;\n\t\tmark_tree_uninteresting(parent->tree);\n\t\tif (revs.edge_hint && !(parent->object.flags & SHOWN)) {\n\t\t\tparent->object.flags |= SHOWN;\n\t\t\tprintf(\"-%s\\n\", sha1_to_hex(parent->object.sha1));\n\t\t}\n\t}\n}\n\nstatic void mark_edges_uninteresting(struct commit_list *list)\n{\n\tfor ( ; list; list = list->next) {\n\t\tstruct commit *commit = list->item;\n\n\t\tif (commit->object.flags & UNINTERESTING) {\n\t\t\tmark_tree_uninteresting(commit->tree);\n\t\t\tcontinue;\n\t\t}\n\t\tmark_edge_parents_uninteresting(commit);\n\t}\n}\n\nint main(int argc, const char **argv)\n{\n\tstruct commit_list *list;\n\tint i;\n\n\tinit_revisions(&revs);\n\trevs.abbrev = 0;\n\trevs.commit_format = CMIT_FMT_UNSPECIFIED;\n\targc = setup_revisions(argc, argv, &revs, NULL);\n\n\tfor (i = 1 ; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\n\t\tif (!strcmp(arg, \"--header\")) {\n\t\t\trevs.verbose_header = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--timestamp\")) {\n\t\t\tshow_timestamp = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--bisect\")) {\n\t\t\tbisect_list = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tusage(rev_list_usage);\n\n\t}\n\tif (revs.commit_format != CMIT_FMT_UNSPECIFIED) {\n\t\t/* The command line has a --pretty  */\n\t\thdr_termination = '\\n';\n\t\tif (revs.commit_format == CMIT_FMT_ONELINE)\n\t\t\trevs.header_prefix = \"\";\n\t\telse\n\t\t\trevs.header_prefix = \"commit \";\n\t}\n\n\tlist = revs.commits;\n\n\tif ((!list &&\n\t     (!(revs.tag_objects||revs.tree_objects||revs.blob_objects) &&\n\t      !revs.pending_objects)) ||\n\t    revs.diff)\n\t\tusage(rev_list_usage);\n\n\tsave_commit_buffer = revs.verbose_header;\n\ttrack_object_refs = 0;\n\n\tprepare_revision_walk(&revs);\n\tif (revs.tree_objects)\n\t\tmark_edges_uninteresting(revs.commits);\n\n\tif (bisect_list)\n\t\trevs.commits = find_bisection(revs.commits);\n\n\tshow_commit_list(&revs);\n\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "000f27a8fedbb1ed981fc7466176c47cf8fee993",
  "sha1_ok": true,
  "size": 8115
}
