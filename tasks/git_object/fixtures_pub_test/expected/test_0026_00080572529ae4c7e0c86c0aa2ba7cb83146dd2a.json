{
  "content": {
    "base64": "IyBUaGlzIHNoZWxsIHNjcmlwdCBmcmFnbWVudCBpcyBzb3VyY2VkIGJ5IGdpdC1yZWJhc2UgdG8gaW1wbGVtZW50CiMgaXRzIGludGVyYWN0aXZlIG1vZGUuICAiZ2l0IHJlYmFzZSAtLWludGVyYWN0aXZlIiBtYWtlcyBpdCBlYXN5CiMgdG8gZml4IHVwIGNvbW1pdHMgaW4gdGhlIG1pZGRsZSBvZiBhIHNlcmllcyBhbmQgcmVhcnJhbmdlIGNvbW1pdHMuCiMKIyBDb3B5cmlnaHQgKGMpIDIwMDYgSm9oYW5uZXMgRS4gU2NoaW5kZWxpbgojCiMgVGhlIG9yaWdpbmFsIGlkZWEgY29tZXMgZnJvbSBFcmljIFcuIEJpZWRlcm1hbiwgaW4KIyBodHRwOi8vYXJ0aWNsZS5nbWFuZS5vcmcvZ21hbmUuY29tcC52ZXJzaW9uLWNvbnRyb2wuZ2l0LzIyNDA3CiMKIyBUaGUgZmlsZSBjb250YWluaW5nIHJlYmFzZSBjb21tYW5kcywgY29tbWVudHMsIGFuZCBlbXB0eSBsaW5lcy4KIyBUaGlzIGZpbGUgaXMgY3JlYXRlZCBieSAiZ2l0IHJlYmFzZSAtaSIgdGhlbiBlZGl0ZWQgYnkgdGhlIHVzZXIuICBBcwojIHRoZSBsaW5lcyBhcmUgcHJvY2Vzc2VkLCB0aGV5IGFyZSByZW1vdmVkIGZyb20gdGhlIGZyb250IG9mIHRoaXMKIyBmaWxlIGFuZCB3cml0dGVuIHRvIHRoZSB0YWlsIG9mICRkb25lLgp0b2RvPSIkc3RhdGVfZGlyIi9naXQtcmViYXNlLXRvZG8KCiMgVGhlIHJlYmFzZSBjb21tYW5kIGxpbmVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkLiAgQSBsaW5lCiMgaXMgbW92ZWQgaGVyZSB3aGVuIGl0IGlzIGZpcnN0IGhhbmRsZWQsIGJlZm9yZSBhbnkgYXNzb2NpYXRlZCB1c2VyCiMgYWN0aW9ucy4KZG9uZT0iJHN0YXRlX2RpciIvZG9uZQoKIyBUaGUgY29tbWl0IG1lc3NhZ2UgdGhhdCBpcyBwbGFubmVkIHRvIGJlIHVzZWQgZm9yIGFueSBjaGFuZ2VzIHRoYXQKIyBuZWVkIHRvIGJlIGNvbW1pdHRlZCBmb2xsb3dpbmcgYSB1c2VyIGludGVyYWN0aW9uLgptc2c9IiRzdGF0ZV9kaXIiL21lc3NhZ2UKCiMgVGhlIGZpbGUgaW50byB3aGljaCBpcyBhY2N1bXVsYXRlZCB0aGUgc3VnZ2VzdGVkIGNvbW1pdCBtZXNzYWdlIGZvcgojIHNxdWFzaC9maXh1cCBjb21tYW5kcy4gIFdoZW4gdGhlIGZpcnN0IG9mIGEgc2VyaWVzIG9mIHNxdWFzaC9maXh1cHMKIyBpcyBzZWVuLCB0aGUgZmlsZSBpcyBjcmVhdGVkIGFuZCB0aGUgY29tbWl0IG1lc3NhZ2UgZnJvbSB0aGUKIyBwcmV2aW91cyBjb21taXQgYW5kIGZyb20gdGhlIGZpcnN0IHNxdWFzaC9maXh1cCBjb21taXQgYXJlIHdyaXR0ZW4KIyB0byBpdC4gIFRoZSBjb21taXQgbWVzc2FnZSBmb3IgZWFjaCBzdWJzZXF1ZW50IHNxdWFzaC9maXh1cCBjb21taXQKIyBpcyBhcHBlbmRlZCB0byB0aGUgZmlsZSBhcyBpdCBpcyBwcm9jZXNzZWQuCiMKIyBUaGUgZmlyc3QgbGluZSBvZiB0aGUgZmlsZSBpcyBvZiB0aGUgZm9ybQojICAgICAjIFRoaXMgaXMgYSBjb21iaW5hdGlvbiBvZiAkY291bnQgY29tbWl0cy4KIyB3aGVyZSAkY291bnQgaXMgdGhlIG51bWJlciBvZiBjb21taXRzIHdob3NlIG1lc3NhZ2VzIGhhdmUgYmVlbgojIHdyaXR0ZW4gdG8gdGhlIGZpbGUgc28gZmFyIChpbmNsdWRpbmcgdGhlIGluaXRpYWwgInBpY2siIGNvbW1pdCkuCiMgRWFjaCB0aW1lIHRoYXQgYSBjb21taXQgbWVzc2FnZSBpcyBwcm9jZXNzZWQsIHRoaXMgbGluZSBpcyByZWFkIGFuZAojIHVwZGF0ZWQuICBJdCBpcyBkZWxldGVkIGp1c3QgYmVmb3JlIHRoZSBjb21iaW5lZCBjb21taXQgaXMgbWFkZS4Kc3F1YXNoX21zZz0iJHN0YXRlX2RpciIvbWVzc2FnZS1zcXVhc2gKCiMgSWYgdGhlIGN1cnJlbnQgc2VyaWVzIG9mIHNxdWFzaC9maXh1cHMgaGFzIG5vdCB5ZXQgaW5jbHVkZWQgYSBzcXVhc2gKIyBjb21tYW5kLCB0aGVuIHRoaXMgZmlsZSBleGlzdHMgYW5kIGhvbGRzIHRoZSBjb21taXQgbWVzc2FnZSBvZiB0aGUKIyBvcmlnaW5hbCAicGljayIgY29tbWl0LiAgKElmIHRoZSBzZXJpZXMgZW5kcyB3aXRob3V0IGEgInNxdWFzaCIKIyBjb21tYW5kLCB0aGVuIHRoaXMgY2FuIGJlIHVzZWQgYXMgdGhlIGNvbW1pdCBtZXNzYWdlIG9mIHRoZSBjb21iaW5lZAojIGNvbW1pdCB3aXRob3V0IG9wZW5pbmcgdGhlIGVkaXRvci4pCmZpeHVwX21zZz0iJHN0YXRlX2RpciIvbWVzc2FnZS1maXh1cAoKIyAkcmV3cml0dGVuIGlzIHRoZSBuYW1lIG9mIGEgZGlyZWN0b3J5IGNvbnRhaW5pbmcgZmlsZXMgZm9yIGVhY2gKIyBjb21taXQgdGhhdCBpcyByZWFjaGFibGUgYnkgYXQgbGVhc3Qgb25lIG1lcmdlIGJhc2Ugb2YgJGhlYWQgYW5kCiMgJHVwc3RyZWFtLiBUaGV5IGFyZSBub3QgbmVjZXNzYXJpbHkgcmV3cml0dGVuLCBidXQgdGhlaXIgY2hpbGRyZW4KIyBtaWdodCBiZS4gIFRoaXMgZW5zdXJlcyB0aGF0IGNvbW1pdHMgb24gbWVyZ2VkLCBidXQgb3RoZXJ3aXNlCiMgdW5yZWxhdGVkIHNpZGUgYnJhbmNoZXMgYXJlIGxlZnQgYWxvbmUuIChUaGluayAiWCIgaW4gdGhlIG1hbiBwYWdlJ3MKIyBleGFtcGxlLikKcmV3cml0dGVuPSIkc3RhdGVfZGlyIi9yZXdyaXR0ZW4KCmRyb3BwZWQ9IiRzdGF0ZV9kaXIiL2Ryb3BwZWQKCmVuZD0iJHN0YXRlX2RpciIvZW5kCm1zZ251bT0iJHN0YXRlX2RpciIvbXNnbnVtCgojIEEgc2NyaXB0IHRvIHNldCB0aGUgR0lUX0FVVEhPUl9OQU1FLCBHSVRfQVVUSE9SX0VNQUlMLCBhbmQKIyBHSVRfQVVUSE9SX0RBVEUgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHRoZSBjb21taXQgdGhhdCBpcyBjdXJyZW50bHkKIyBiZWluZyByZWJhc2VkLgphdXRob3Jfc2NyaXB0PSIkc3RhdGVfZGlyIi9hdXRob3Itc2NyaXB0CgojIFdoZW4gYW4gImVkaXQiIHJlYmFzZSBjb21tYW5kIGlzIGJlaW5nIHByb2Nlc3NlZCwgdGhlIFNIQTEgb2YgdGhlCiMgY29tbWl0IHRvIGJlIGVkaXRlZCBpcyByZWNvcmRlZCBpbiB0aGlzIGZpbGUuICBXaGVuICJnaXQgcmViYXNlCiMgLS1jb250aW51ZSIgaXMgZXhlY3V0ZWQsIGlmIHRoZXJlIGFyZSBhbnkgc3RhZ2VkIGNoYW5nZXMgdGhlbiB0aGV5CiMgd2lsbCBiZSBhbWVuZGVkIHRvIHRoZSBIRUFEIGNvbW1pdCwgYnV0IG9ubHkgcHJvdmlkZWQgdGhlIEhFQUQKIyBjb21taXQgaXMgc3RpbGwgdGhlIGNvbW1pdCB0byBiZSBlZGl0ZWQuICBXaGVuIGFueSBvdGhlciByZWJhc2UKIyBjb21tYW5kIGlzIHByb2Nlc3NlZCwgdGhpcyBmaWxlIGlzIGRlbGV0ZWQuCmFtZW5kPSIkc3RhdGVfZGlyIi9hbWVuZAoKIyBGb3IgdGhlIHBvc3QtcmV3cml0ZSBob29rLCB3ZSBtYWtlIGEgbGlzdCBvZiByZXdyaXR0ZW4gY29tbWl0cyBhbmQKIyB0aGVpciBuZXcgc2hhMXMuICBUaGUgcmV3cml0dGVuLXBlbmRpbmcgbGlzdCBrZWVwcyB0aGUgc2hhMXMgb2YKIyBjb21taXRzIHRoYXQgaGF2ZSBiZWVuIHByb2Nlc3NlZCwgYnV0IG5vdCBjb21taXR0ZWQgeWV0LAojIGUuZy4gYmVjYXVzZSB0aGV5IGFyZSB3YWl0aW5nIGZvciBhICdzcXVhc2gnIGNvbW1hbmQuCnJld3JpdHRlbl9saXN0PSIkc3RhdGVfZGlyIi9yZXdyaXR0ZW4tbGlzdApyZXdyaXR0ZW5fcGVuZGluZz0iJHN0YXRlX2RpciIvcmV3cml0dGVuLXBlbmRpbmcKCnN0cmF0ZWd5X2FyZ3M9CmlmIHRlc3QgLW4gIiRkb19tZXJnZSIKdGhlbgoJc3RyYXRlZ3lfYXJncz0ke3N0cmF0ZWd5OistLXN0cmF0ZWd5PSRzdHJhdGVneX0KCWV2YWwgJwoJCWZvciBzdHJhdGVneV9vcHQgaW4gJyIkc3RyYXRlZ3lfb3B0cyInCgkJZG8KCQkJc3RyYXRlZ3lfYXJncz0iJHN0cmF0ZWd5X2FyZ3MgLVgkKGdpdCByZXYtcGFyc2UgLS1zcS1xdW90ZSAiJHtzdHJhdGVneV9vcHQjLS19IikiCgkJZG9uZQoJJwpmaQoKR0lUX0NIRVJSWV9QSUNLX0hFTFA9IiRyZXNvbHZlbXNnIgpleHBvcnQgR0lUX0NIRVJSWV9QSUNLX0hFTFAKCmNvbW1lbnRfY2hhcj0kKGdpdCBjb25maWcgLS1nZXQgY29yZS5jb21tZW50Y2hhciAyPi9kZXYvbnVsbCB8IGN1dCAtYzEpCjogJHtjb21tZW50X2NoYXI6PSN9Cgp3YXJuICgpIHsKCXByaW50ZiAnJXNcbicgIiQqIiA+JjIKfQoKIyBPdXRwdXQgdGhlIGNvbW1pdCBtZXNzYWdlIGZvciB0aGUgc3BlY2lmaWVkIGNvbW1pdC4KY29tbWl0X21lc3NhZ2UgKCkgewoJZ2l0IGNhdC1maWxlIGNvbW1pdCAiJDEiIHwgc2VkICIxLC9eJC9kIgp9CgpvcmlnX3JlZmxvZ19hY3Rpb249IiRHSVRfUkVGTE9HX0FDVElPTiIKCmNvbW1lbnRfZm9yX3JlZmxvZyAoKSB7CgljYXNlICIkb3JpZ19yZWZsb2dfYWN0aW9uIiBpbgoJJyd8cmViYXNlKikKCQlHSVRfUkVGTE9HX0FDVElPTj0icmViYXNlIC1pICgkMSkiCgkJZXhwb3J0IEdJVF9SRUZMT0dfQUNUSU9OCgkJOzsKCWVzYWMKfQoKbGFzdF9jb3VudD0KbWFya19hY3Rpb25fZG9uZSAoKSB7CglzZWQgLWUgMXEgPCAiJHRvZG8iID4+ICIkZG9uZSIKCXNlZCAtZSAxZCA8ICIkdG9kbyIgPj4gIiR0b2RvIi5uZXcKCW12IC1mICIkdG9kbyIubmV3ICIkdG9kbyIKCW5ld19jb3VudD0kKGdpdCBzdHJpcHNwYWNlIC0tc3RyaXAtY29tbWVudHMgPCIkZG9uZSIgfCB3YyAtbCkKCWVjaG8gJG5ld19jb3VudCA+IiRtc2dudW0iCgl0b3RhbD0kKCgkbmV3X2NvdW50ICsgJChnaXQgc3RyaXBzcGFjZSAtLXN0cmlwLWNvbW1lbnRzIDwiJHRvZG8iIHwgd2MgLWwpKSkKCWVjaG8gJHRvdGFsID4iJGVuZCIKCWlmIHRlc3QgIiRsYXN0X2NvdW50IiAhPSAiJG5ld19jb3VudCIKCXRoZW4KCQlsYXN0X2NvdW50PSRuZXdfY291bnQKCQlwcmludGYgIlJlYmFzaW5nICglZC8lZClcciIgJG5ld19jb3VudCAkdG90YWwKCQl0ZXN0IC16ICIkdmVyYm9zZSIgfHwgZWNobwoJZmkKfQoKIyBQdXQgdGhlIGxhc3QgYWN0aW9uIG1hcmtlZCBkb25lIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRvZG8gbGlzdAojIGFnYWluLiBJZiB0aGVyZSBoYXMgbm90IGJlZW4gYW4gYWN0aW9uIG1hcmtlZCBkb25lIHlldCwgbGVhdmUgdGhlIGxpc3Qgb2YKIyBpdGVtcyBvbiB0aGUgdG9kbyBsaXN0IHVuY2hhbmdlZC4KcmVzY2hlZHVsZV9sYXN0X2FjdGlvbiAoKSB7Cgl0YWlsIC1uIDEgIiRkb25lIiB8IGNhdCAtICIkdG9kbyIgPiIkdG9kbyIubmV3CglzZWQgLWUgXCRkIDwiJGRvbmUiID4iJGRvbmUiLm5ldwoJbXYgLWYgIiR0b2RvIi5uZXcgIiR0b2RvIgoJbXYgLWYgIiRkb25lIi5uZXcgIiRkb25lIgp9CgphcHBlbmRfdG9kb19oZWxwICgpIHsKCWdpdCBzdHJpcHNwYWNlIC0tY29tbWVudC1saW5lcyA+PiIkdG9kbyIgPDxcRU9GCgpDb21tYW5kczoKIHAsIHBpY2sgPSB1c2UgY29tbWl0CiByLCByZXdvcmQgPSB1c2UgY29tbWl0LCBidXQgZWRpdCB0aGUgY29tbWl0IG1lc3NhZ2UKIGUsIGVkaXQgPSB1c2UgY29tbWl0LCBidXQgc3RvcCBmb3IgYW1lbmRpbmcKIHMsIHNxdWFzaCA9IHVzZSBjb21taXQsIGJ1dCBtZWxkIGludG8gcHJldmlvdXMgY29tbWl0CiBmLCBmaXh1cCA9IGxpa2UgInNxdWFzaCIsIGJ1dCBkaXNjYXJkIHRoaXMgY29tbWl0J3MgbG9nIG1lc3NhZ2UKIHgsIGV4ZWMgPSBydW4gY29tbWFuZCAodGhlIHJlc3Qgb2YgdGhlIGxpbmUpIHVzaW5nIHNoZWxsCgpUaGVzZSBsaW5lcyBjYW4gYmUgcmUtb3JkZXJlZDsgdGhleSBhcmUgZXhlY3V0ZWQgZnJvbSB0b3AgdG8gYm90dG9tLgoKSWYgeW91IHJlbW92ZSBhIGxpbmUgaGVyZSBUSEFUIENPTU1JVCBXSUxMIEJFIExPU1QuCkVPRgp9CgptYWtlX3BhdGNoICgpIHsKCXNoYTFfYW5kX3BhcmVudHM9IiQoZ2l0IHJldi1saXN0IC0tcGFyZW50cyAtMSAiJDEiKSIKCWNhc2UgIiRzaGExX2FuZF9wYXJlbnRzIiBpbgoJPyonICc/KicgJz8qKQoJCWdpdCBkaWZmIC0tY2MgJHNoYTFfYW5kX3BhcmVudHMKCQk7OwoJPyonICc/KikKCQlnaXQgZGlmZi10cmVlIC1wICIkMV4hIgoJCTs7CgkqKQoJCWVjaG8gIlJvb3QgY29tbWl0IgoJCTs7Cgllc2FjID4gIiRzdGF0ZV9kaXIiL3BhdGNoCgl0ZXN0IC1mICIkbXNnIiB8fAoJCWNvbW1pdF9tZXNzYWdlICIkMSIgPiAiJG1zZyIKCXRlc3QgLWYgIiRhdXRob3Jfc2NyaXB0IiB8fAoJCWdldF9hdXRob3JfaWRlbnRfZnJvbV9jb21taXQgIiQxIiA+ICIkYXV0aG9yX3NjcmlwdCIKfQoKZGllX3dpdGhfcGF0Y2ggKCkgewoJZWNobyAiJDEiID4gIiRzdGF0ZV9kaXIiL3N0b3BwZWQtc2hhCgltYWtlX3BhdGNoICIkMSIKCWdpdCByZXJlcmUKCWRpZSAiJDIiCn0KCmV4aXRfd2l0aF9wYXRjaCAoKSB7CgllY2hvICIkMSIgPiAiJHN0YXRlX2RpciIvc3RvcHBlZC1zaGEKCW1ha2VfcGF0Y2ggJDEKCWdpdCByZXYtcGFyc2UgLS12ZXJpZnkgSEVBRCA+ICIkYW1lbmQiCglncGdfc2lnbl9vcHRfcXVvdGVkPSR7Z3BnX3NpZ25fb3B0OiskKGdpdCByZXYtcGFyc2UgLS1zcS1xdW90ZSAiJGdwZ19zaWduX29wdCIpfQoJd2FybiAiWW91IGNhbiBhbWVuZCB0aGUgY29tbWl0IG5vdywgd2l0aCIKCXdhcm4KCXdhcm4gIglnaXQgY29tbWl0IC0tYW1lbmQgJGdwZ19zaWduX29wdF9xdW90ZWQiCgl3YXJuCgl3YXJuICJPbmNlIHlvdSBhcmUgc2F0aXNmaWVkIHdpdGggeW91ciBjaGFuZ2VzLCBydW4iCgl3YXJuCgl3YXJuICIJZ2l0IHJlYmFzZSAtLWNvbnRpbnVlIgoJd2FybgoJZXhpdCAkMgp9CgpkaWVfYWJvcnQgKCkgewoJcm0gLXJmICIkc3RhdGVfZGlyIgoJZGllICIkMSIKfQoKaGFzX2FjdGlvbiAoKSB7Cgl0ZXN0IC1uICIkKGdpdCBzdHJpcHNwYWNlIC0tc3RyaXAtY29tbWVudHMgPCIkMSIpIgp9Cgppc19lbXB0eV9jb21taXQoKSB7Cgl0cmVlPSQoZ2l0IHJldi1wYXJzZSAtcSAtLXZlcmlmeSAiJDEiXnt0cmVlfSAyPi9kZXYvbnVsbCB8fAoJCWRpZSAiJDE6IG5vdCBhIGNvbW1pdCB0aGF0IGNhbiBiZSBwaWNrZWQiKQoJcHRyZWU9JChnaXQgcmV2LXBhcnNlIC1xIC0tdmVyaWZ5ICIkMSJeXnt0cmVlfSAyPi9kZXYvbnVsbCB8fAoJCXB0cmVlPTRiODI1ZGM2NDJjYjZlYjlhMDYwZTU0YmY4ZDY5Mjg4ZmJlZTQ5MDQpCgl0ZXN0ICIkdHJlZSIgPSAiJHB0cmVlIgp9Cgppc19tZXJnZV9jb21taXQoKQp7CglnaXQgcmV2LXBhcnNlIC0tdmVyaWZ5IC0tcXVpZXQgIiQxIl4yID4vZGV2L251bGwgMj4mMQp9CgojIFJ1biBjb21tYW5kIHdpdGggR0lUX0FVVEhPUl9OQU1FLCBHSVRfQVVUSE9SX0VNQUlMLCBhbmQKIyBHSVRfQVVUSE9SX0RBVEUgZXhwb3J0ZWQgZnJvbSB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4KZG9fd2l0aF9hdXRob3IgKCkgewoJKAoJCWV4cG9ydCBHSVRfQVVUSE9SX05BTUUgR0lUX0FVVEhPUl9FTUFJTCBHSVRfQVVUSE9SX0RBVEUKCQkiJEAiCgkpCn0KCmdpdF9zZXF1ZW5jZV9lZGl0b3IgKCkgewoJaWYgdGVzdCAteiAiJEdJVF9TRVFVRU5DRV9FRElUT1IiCgl0aGVuCgkJR0lUX1NFUVVFTkNFX0VESVRPUj0iJChnaXQgY29uZmlnIHNlcXVlbmNlLmVkaXRvcikiCgkJaWYgWyAteiAiJEdJVF9TRVFVRU5DRV9FRElUT1IiIF0KCQl0aGVuCgkJCUdJVF9TRVFVRU5DRV9FRElUT1I9IiQoZ2l0IHZhciBHSVRfRURJVE9SKSIgfHwgcmV0dXJuICQ/CgkJZmkKCWZpCgoJZXZhbCAiJEdJVF9TRVFVRU5DRV9FRElUT1IiICciJEAiJwp9CgpwaWNrX29uZSAoKSB7CglmZj0tLWZmCgoJY2FzZSAiJDEiIGluIC1uKSBzaGExPSQyOyBmZj0gOzsgKikgc2hhMT0kMSA7OyBlc2FjCgljYXNlICIkZm9yY2VfcmViYXNlIiBpbiAnJykgOzsgPyopIGZmPSA7OyBlc2FjCglvdXRwdXQgZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSAkc2hhMSB8fCBkaWUgIkludmFsaWQgY29tbWl0IG5hbWU6ICRzaGExIgoKCWlmIGlzX2VtcHR5X2NvbW1pdCAiJHNoYTEiCgl0aGVuCgkJZW1wdHlfYXJncz0iLS1hbGxvdy1lbXB0eSIKCWZpCgoJdGVzdCAtZCAiJHJld3JpdHRlbiIgJiYKCQlwaWNrX29uZV9wcmVzZXJ2aW5nX21lcmdlcyAiJEAiICYmIHJldHVybgoJb3V0cHV0IGV2YWwgZ2l0IGNoZXJyeS1waWNrIFwKCQkJJHtncGdfc2lnbl9vcHQ6KyQoZ2l0IHJldi1wYXJzZSAtLXNxLXF1b3RlICIkZ3BnX3NpZ25fb3B0Iil9IFwKCQkJIiRzdHJhdGVneV9hcmdzIiAkZW1wdHlfYXJncyAkZmYgIiRAIgoKCSMgSWYgY2hlcnJ5LXBpY2sgZGllcyBpdCBsZWF2ZXMgdGhlIHRvLWJlLXBpY2tlZCBjb21taXQgdW5yZWNvcmRlZC4gUmVzY2hlZHVsZQoJIyBwcmV2aW91cyB0YXNrIHNvIHRoaXMgY29tbWl0IGlzIG5vdCBsb3N0LgoJcmV0PSQ/CgljYXNlICIkcmV0IiBpbiBbMDFdKSA7OyAqKSByZXNjaGVkdWxlX2xhc3RfYWN0aW9uIDs7IGVzYWMKCXJldHVybiAkcmV0Cn0KCnBpY2tfb25lX3ByZXNlcnZpbmdfbWVyZ2VzICgpIHsKCWZhc3RfZm9yd2FyZD10CgljYXNlICIkMSIgaW4KCS1uKQoJCWZhc3RfZm9yd2FyZD1mCgkJc2hhMT0kMgoJCTs7CgkqKQoJCXNoYTE9JDEKCQk7OwoJZXNhYwoJc2hhMT0kKGdpdCByZXYtcGFyc2UgJHNoYTEpCgoJaWYgdGVzdCAtZiAiJHN0YXRlX2RpciIvY3VycmVudC1jb21taXQKCXRoZW4KCQlpZiB0ZXN0ICIkZmFzdF9mb3J3YXJkIiA9IHQKCQl0aGVuCgkJCXdoaWxlIHJlYWQgY3VycmVudF9jb21taXQKCQkJZG8KCQkJCWdpdCByZXYtcGFyc2UgSEVBRCA+ICIkcmV3cml0dGVuIi8kY3VycmVudF9jb21taXQKCQkJZG9uZSA8IiRzdGF0ZV9kaXIiL2N1cnJlbnQtY29tbWl0CgkJCXJtICIkc3RhdGVfZGlyIi9jdXJyZW50LWNvbW1pdCB8fAoJCQlkaWUgIkNhbm5vdCB3cml0ZSBjdXJyZW50IGNvbW1pdCdzIHJlcGxhY2VtZW50IHNoYTEiCgkJZmkKCWZpCgoJZWNobyAkc2hhMSA+PiAiJHN0YXRlX2RpciIvY3VycmVudC1jb21taXQKCgkjIHJld3JpdGUgcGFyZW50czsgaWYgbm9uZSB3ZXJlIHJld3JpdHRlbiwgd2UgY2FuIGZhc3QtZm9yd2FyZC4KCW5ld19wYXJlbnRzPQoJcGVuZD0iICQoZ2l0IHJldi1saXN0IC0tcGFyZW50cyAtMSAkc2hhMSB8IGN1dCAtZCcgJyAtcyAtZjItKSIKCWlmIHRlc3QgIiRwZW5kIiA9ICIgIgoJdGhlbgoJCXBlbmQ9IiByb290IgoJZmkKCXdoaWxlIFsgIiRwZW5kIiAhPSAiIiBdCglkbwoJCXA9JChleHByICIkcGVuZCIgOiAnIFwoW14gXSpcKScpCgkJcGVuZD0iJHtwZW5kIyAkcH0iCgoJCWlmIHRlc3QgLWYgIiRyZXdyaXR0ZW4iLyRwCgkJdGhlbgoJCQluZXdfcD0kKGNhdCAiJHJld3JpdHRlbiIvJHApCgoJCQkjIElmIHRoZSB0b2RvIHJlb3JkZXJlZCBjb21taXRzLCBhbmQgb3VyIHBhcmVudCBpcyBtYXJrZWQgZm9yCgkJCSMgcmV3cml0aW5nLCBidXQgaGFzbid0IGJlZW4gZ290dGVuIHRvIHlldCwgYXNzdW1lIHRoZSB1c2VyIG1lYW50IHRvCgkJCSMgZHJvcCBpdCBvbiB0b3Agb2YgdGhlIGN1cnJlbnQgSEVBRAoJCQlpZiB0ZXN0IC16ICIkbmV3X3AiCgkJCXRoZW4KCQkJCW5ld19wPSQoZ2l0IHJldi1wYXJzZSBIRUFEKQoJCQlmaQoKCQkJdGVzdCAkcCAhPSAkbmV3X3AgJiYgZmFzdF9mb3J3YXJkPWYKCQkJY2FzZSAiJG5ld19wYXJlbnRzIiBpbgoJCQkqJG5ld19wKikKCQkJCTs7ICMgZG8gbm90aGluZzsgdGhhdCBwYXJlbnQgaXMgYWxyZWFkeSB0aGVyZQoJCQkqKQoJCQkJbmV3X3BhcmVudHM9IiRuZXdfcGFyZW50cyAkbmV3X3AiCgkJCQk7OwoJCQllc2FjCgkJZWxzZQoJCQlpZiB0ZXN0IC1mICIkZHJvcHBlZCIvJHAKCQkJdGhlbgoJCQkJZmFzdF9mb3J3YXJkPWYKCQkJCXJlcGxhY2VtZW50PSIkKGNhdCAiJGRyb3BwZWQiLyRwKSIKCQkJCXRlc3QgLXogIiRyZXBsYWNlbWVudCIgJiYgcmVwbGFjZW1lbnQ9cm9vdAoJCQkJcGVuZD0iICRyZXBsYWNlbWVudCRwZW5kIgoJCQllbHNlCgkJCQluZXdfcGFyZW50cz0iJG5ld19wYXJlbnRzICRwIgoJCQlmaQoJCWZpCglkb25lCgljYXNlICRmYXN0X2ZvcndhcmQgaW4KCXQpCgkJb3V0cHV0IHdhcm4gIkZhc3QtZm9yd2FyZCB0byAkc2hhMSIKCQlvdXRwdXQgZ2l0IHJlc2V0IC0taGFyZCAkc2hhMSB8fAoJCQlkaWUgIkNhbm5vdCBmYXN0LWZvcndhcmQgdG8gJHNoYTEiCgkJOzsKCWYpCgkJZmlyc3RfcGFyZW50PSQoZXhwciAiJG5ld19wYXJlbnRzIiA6ICcgXChbXiBdKlwpJykKCgkJaWYgWyAiJDEiICE9ICItbiIgXQoJCXRoZW4KCQkJIyBkZXRhY2ggSEVBRCB0byBjdXJyZW50IHBhcmVudAoJCQlvdXRwdXQgZ2l0IGNoZWNrb3V0ICRmaXJzdF9wYXJlbnQgMj4gL2Rldi9udWxsIHx8CgkJCQlkaWUgIkNhbm5vdCBtb3ZlIEhFQUQgdG8gJGZpcnN0X3BhcmVudCIKCQlmaQoKCQljYXNlICIkbmV3X3BhcmVudHMiIGluCgkJJyAnKicgJyopCgkJCXRlc3QgImEkMSIgPSBhLW4gJiYgZGllICJSZWZ1c2luZyB0byBzcXVhc2ggYSBtZXJnZTogJHNoYTEiCgoJCQkjIHJlZG8gbWVyZ2UKCQkJYXV0aG9yX3NjcmlwdF9jb250ZW50PSQoZ2V0X2F1dGhvcl9pZGVudF9mcm9tX2NvbW1pdCAkc2hhMSkKCQkJZXZhbCAiJGF1dGhvcl9zY3JpcHRfY29udGVudCIKCQkJbXNnX2NvbnRlbnQ9IiQoY29tbWl0X21lc3NhZ2UgJHNoYTEpIgoJCQkjIE5vIHBvaW50IGluIG1lcmdpbmcgdGhlIGZpcnN0IHBhcmVudCwgdGhhdCdzIEhFQUQKCQkJbmV3X3BhcmVudHM9JHtuZXdfcGFyZW50cyMgJGZpcnN0X3BhcmVudH0KCQkJbWVyZ2VfYXJncz0iLS1uby1sb2cgLS1uby1mZiIKCQkJaWYgISBkb193aXRoX2F1dGhvciBvdXRwdXQgZXZhbCBcCgkJCSdnaXQgbWVyZ2UgJHtncGdfc2lnbl9vcHQ6KyIkZ3BnX3NpZ25fb3B0In0gXAoJCQkJJG1lcmdlX2FyZ3MgJHN0cmF0ZWd5X2FyZ3MgLW0gIiRtc2dfY29udGVudCIgJG5ld19wYXJlbnRzJwoJCQl0aGVuCgkJCQlwcmludGYgIiVzXG4iICIkbXNnX2NvbnRlbnQiID4gIiRHSVRfRElSIi9NRVJHRV9NU0cKCQkJCWRpZV93aXRoX3BhdGNoICRzaGExICJFcnJvciByZWRvaW5nIG1lcmdlICRzaGExIgoJCQlmaQoJCQllY2hvICIkc2hhMSAkKGdpdCByZXYtcGFyc2UgSEVBRF4wKSIgPj4gIiRyZXdyaXR0ZW5fbGlzdCIKCQkJOzsKCQkqKQoJCQlvdXRwdXQgZXZhbCBnaXQgY2hlcnJ5LXBpY2sgXAoJCQkJJHtncGdfc2lnbl9vcHQ6KyQoZ2l0IHJldi1wYXJzZSAtLXNxLXF1b3RlICIkZ3BnX3NpZ25fb3B0Iil9IFwKCQkJCSIkc3RyYXRlZ3lfYXJncyIgIiRAIiB8fAoJCQkJZGllX3dpdGhfcGF0Y2ggJHNoYTEgIkNvdWxkIG5vdCBwaWNrICRzaGExIgoJCQk7OwoJCWVzYWMKCQk7OwoJZXNhYwp9CgpudGhfc3RyaW5nICgpIHsKCWNhc2UgIiQxIiBpbgoJKjFbMC05XXwqWzA0LTldKSBlY2hvICIkMSJ0aDs7CgkqMSkgZWNobyAiJDEic3Q7OwoJKjIpIGVjaG8gIiQxIm5kOzsKCSozKSBlY2hvICIkMSJyZDs7Cgllc2FjCn0KCnVwZGF0ZV9zcXVhc2hfbWVzc2FnZXMgKCkgewoJaWYgdGVzdCAtZiAiJHNxdWFzaF9tc2ciOyB0aGVuCgkJbXYgIiRzcXVhc2hfbXNnIiAiJHNxdWFzaF9tc2ciLmJhayB8fCBleGl0CgkJY291bnQ9JCgoJChzZWQgLW4gXAoJCQktZSAiMXMvXi4gVGhpcyBpcyBhIGNvbWJpbmF0aW9uIG9mIFwoLipcKSBjb21taXRzXC4vXDEvcCIgXAoJCQktZSAicSIgPCAiJHNxdWFzaF9tc2ciLmJhaykrMSkpCgkJewoJCQlwcmludGYgJyVzXG4nICIkY29tbWVudF9jaGFyIFRoaXMgaXMgYSBjb21iaW5hdGlvbiBvZiAkY291bnQgY29tbWl0cy4iCgkJCXNlZCAtZSAxZCAtZSAnMiwvXi4vewoJCQkJL14kL2QKCQkJfScgPCIkc3F1YXNoX21zZyIuYmFrCgkJfSA+IiRzcXVhc2hfbXNnIgoJZWxzZQoJCWNvbW1pdF9tZXNzYWdlIEhFQUQgPiAiJGZpeHVwX21zZyIgfHwgZGllICJDYW5ub3Qgd3JpdGUgJGZpeHVwX21zZyIKCQljb3VudD0yCgkJewoJCQlwcmludGYgJyVzXG4nICIkY29tbWVudF9jaGFyIFRoaXMgaXMgYSBjb21iaW5hdGlvbiBvZiAyIGNvbW1pdHMuIgoJCQlwcmludGYgJyVzXG4nICIkY29tbWVudF9jaGFyIFRoZSBmaXJzdCBjb21taXQncyBtZXNzYWdlIGlzOiIKCQkJZWNobwoJCQljYXQgIiRmaXh1cF9tc2ciCgkJfSA+IiRzcXVhc2hfbXNnIgoJZmkKCWNhc2UgJDEgaW4KCXNxdWFzaCkKCQlybSAtZiAiJGZpeHVwX21zZyIKCQllY2hvCgkJcHJpbnRmICclc1xuJyAiJGNvbW1lbnRfY2hhciBUaGlzIGlzIHRoZSAkKG50aF9zdHJpbmcgJGNvdW50KSBjb21taXQgbWVzc2FnZToiCgkJZWNobwoJCWNvbW1pdF9tZXNzYWdlICQyCgkJOzsKCWZpeHVwKQoJCWVjaG8KCQlwcmludGYgJyVzXG4nICIkY29tbWVudF9jaGFyIFRoZSAkKG50aF9zdHJpbmcgJGNvdW50KSBjb21taXQgbWVzc2FnZSB3aWxsIGJlIHNraXBwZWQ6IgoJCWVjaG8KCQkjIENoYW5nZSB0aGUgc3BhY2UgYWZ0ZXIgdGhlIGNvbW1lbnQgY2hhcmFjdGVyIHRvIFRBQjoKCQljb21taXRfbWVzc2FnZSAkMiB8IGdpdCBzdHJpcHNwYWNlIC0tY29tbWVudC1saW5lcyB8IHNlZCAtZSAncy8gLwkvJwoJCTs7Cgllc2FjID4+IiRzcXVhc2hfbXNnIgp9CgpwZWVrX25leHRfY29tbWFuZCAoKSB7CglnaXQgc3RyaXBzcGFjZSAtLXN0cmlwLWNvbW1lbnRzIDwiJHRvZG8iIHwgc2VkIC1uIC1lICdzLyAuKi8vcCcgLWUgcQp9CgojIEEgc3F1YXNoL2ZpeHVwIGhhcyBmYWlsZWQuICBQcmVwYXJlIHRoZSBsb25nIHZlcnNpb24gb2YgdGhlIHNxdWFzaAojIGNvbW1pdCBtZXNzYWdlLCB0aGVuIGRpZV93aXRoX3BhdGNoLiAgVGhpcyBjb2RlIHBhdGggcmVxdWlyZXMgdGhlCiMgdXNlciB0byBlZGl0IHRoZSBjb21iaW5lZCBjb21taXQgbWVzc2FnZSBmb3IgYWxsIGNvbW1pdHMgdGhhdCBoYXZlCiMgYmVlbiBzcXVhc2hlZC9maXhlZHVwIHNvIGZhci4gIFNvIGFsc28gZXJhc2UgdGhlIG9sZCBzcXVhc2gKIyBtZXNzYWdlcywgZWZmZWN0aXZlbHkgY2F1c2luZyB0aGUgY29tYmluZWQgY29tbWl0IHRvIGJlIHVzZWQgYXMgdGhlCiMgbmV3IGJhc2lzIGZvciBhbnkgZnVydGhlciBzcXVhc2gvZml4dXBzLiAgQXJnczogc2hhMSByZXN0CmRpZV9mYWlsZWRfc3F1YXNoKCkgewoJbXYgIiRzcXVhc2hfbXNnIiAiJG1zZyIgfHwgZXhpdAoJcm0gLWYgIiRmaXh1cF9tc2ciCgljcCAiJG1zZyIgIiRHSVRfRElSIi9NRVJHRV9NU0cgfHwgZXhpdAoJd2FybgoJd2FybiAiQ291bGQgbm90IGFwcGx5ICQxLi4uICQyIgoJZGllX3dpdGhfcGF0Y2ggJDEgIiIKfQoKZmx1c2hfcmV3cml0dGVuX3BlbmRpbmcoKSB7Cgl0ZXN0IC1zICIkcmV3cml0dGVuX3BlbmRpbmciIHx8IHJldHVybgoJbmV3c2hhMT0iJChnaXQgcmV2LXBhcnNlIEhFQUReMCkiCglzZWQgInMvJC8gJG5ld3NoYTEvIiA8ICIkcmV3cml0dGVuX3BlbmRpbmciID4+ICIkcmV3cml0dGVuX2xpc3QiCglybSAtZiAiJHJld3JpdHRlbl9wZW5kaW5nIgp9CgpyZWNvcmRfaW5fcmV3cml0dGVuKCkgewoJb2xkc2hhMT0iJChnaXQgcmV2LXBhcnNlICQxKSIKCWVjaG8gIiRvbGRzaGExIiA+PiAiJHJld3JpdHRlbl9wZW5kaW5nIgoKCWNhc2UgIiQocGVla19uZXh0X2NvbW1hbmQpIiBpbgoJc3F1YXNofHN8Zml4dXB8ZikKCQk7OwoJKikKCQlmbHVzaF9yZXdyaXR0ZW5fcGVuZGluZwoJCTs7Cgllc2FjCn0KCmRvX3BpY2sgKCkgewoJaWYgdGVzdCAiJChnaXQgcmV2LXBhcnNlIEhFQUQpIiA9ICIkc3F1YXNoX29udG8iCgl0aGVuCgkJIyBTZXQgdGhlIGNvcnJlY3QgY29tbWl0IG1lc3NhZ2UgYW5kIGF1dGhvciBpbmZvIG9uIHRoZQoJCSMgc2VudGluZWwgcm9vdCBiZWZvcmUgY2hlcnJ5LXBpY2tpbmcgdGhlIG9yaWdpbmFsIGNoYW5nZXMKCQkjIHdpdGhvdXQgY29tbWl0dGluZyAoLW4pLiAgRmluYWxseSwgdXBkYXRlIHRoZSBzZW50aW5lbCBhZ2FpbgoJCSMgdG8gaW5jbHVkZSB0aGVzZSBjaGFuZ2VzLiAgSWYgdGhlIGNoZXJyeS1waWNrIHJlc3VsdHMgaW4gYQoJCSMgY29uZmxpY3QsIHRoaXMgbWVhbnMgb3VyIGJlaGF2aW91ciBpcyBzaW1pbGFyIHRvIGEgc3RhbmRhcmQKCQkjIGZhaWxlZCBjaGVycnktcGljayBkdXJpbmcgcmViYXNlLCB3aXRoIGEgZGlydHkgaW5kZXggdG8KCQkjIHJlc29sdmUgYmVmb3JlIG1hbnVhbGx5IHJ1bm5pbmcgZ2l0IGNvbW1pdCAtLWFtZW5kIHRoZW4gZ2l0CgkJIyByZWJhc2UgLS1jb250aW51ZS4KCQlnaXQgY29tbWl0IC0tYWxsb3ctZW1wdHkgLS1hbGxvdy1lbXB0eS1tZXNzYWdlIC0tYW1lbmQgXAoJCQkgICAtLW5vLXBvc3QtcmV3cml0ZSAtbiAtcSAtQyAkMSAmJgoJCQlwaWNrX29uZSAtbiAkMSAmJgoJCQlnaXQgY29tbWl0IC0tYWxsb3ctZW1wdHkgLS1hbGxvdy1lbXB0eS1tZXNzYWdlIFwKCQkJCSAgIC0tYW1lbmQgLS1uby1wb3N0LXJld3JpdGUgLW4gLXEgLUMgJDEgXAoJCQkJICAgJHtncGdfc2lnbl9vcHQ6KyIkZ3BnX3NpZ25fb3B0In0gfHwKCQkJZGllX3dpdGhfcGF0Y2ggJDEgIkNvdWxkIG5vdCBhcHBseSAkMS4uLiAkMiIKCWVsc2UKCQlwaWNrX29uZSAkMSB8fAoJCQlkaWVfd2l0aF9wYXRjaCAkMSAiQ291bGQgbm90IGFwcGx5ICQxLi4uICQyIgoJZmkKfQoKZG9fbmV4dCAoKSB7CglybSAtZiAiJG1zZyIgIiRhdXRob3Jfc2NyaXB0IiAiJGFtZW5kIiB8fCBleGl0CglyZWFkIC1yIGNvbW1hbmQgc2hhMSByZXN0IDwgIiR0b2RvIgoJY2FzZSAiJGNvbW1hbmQiIGluCgkiJGNvbW1lbnRfY2hhciIqfCcnfG5vb3ApCgkJbWFya19hY3Rpb25fZG9uZQoJCTs7CglwaWNrfHApCgkJY29tbWVudF9mb3JfcmVmbG9nIHBpY2sKCgkJbWFya19hY3Rpb25fZG9uZQoJCWRvX3BpY2sgJHNoYTEgIiRyZXN0IgoJCXJlY29yZF9pbl9yZXdyaXR0ZW4gJHNoYTEKCQk7OwoJcmV3b3JkfHIpCgkJY29tbWVudF9mb3JfcmVmbG9nIHJld29yZAoKCQltYXJrX2FjdGlvbl9kb25lCgkJZG9fcGljayAkc2hhMSAiJHJlc3QiCgkJZ2l0IGNvbW1pdCAtLWFtZW5kIC0tbm8tcG9zdC1yZXdyaXRlICR7Z3BnX3NpZ25fb3B0OisiJGdwZ19zaWduX29wdCJ9IHx8IHsKCQkJd2FybiAiQ291bGQgbm90IGFtZW5kIGNvbW1pdCBhZnRlciBzdWNjZXNzZnVsbHkgcGlja2luZyAkc2hhMS4uLiAkcmVzdCIKCQkJd2FybiAiVGhpcyBpcyBtb3N0IGxpa2VseSBkdWUgdG8gYW4gZW1wdHkgY29tbWl0IG1lc3NhZ2UsIG9yIHRoZSBwcmUtY29tbWl0IGhvb2siCgkJCXdhcm4gImZhaWxlZC4gSWYgdGhlIHByZS1jb21taXQgaG9vayBmYWlsZWQsIHlvdSBtYXkgbmVlZCB0byByZXNvbHZlIHRoZSBpc3N1ZSBiZWZvcmUiCgkJCXdhcm4gInlvdSBhcmUgYWJsZSB0byByZXdvcmQgdGhlIGNvbW1pdC4iCgkJCWV4aXRfd2l0aF9wYXRjaCAkc2hhMSAxCgkJfQoJCXJlY29yZF9pbl9yZXdyaXR0ZW4gJHNoYTEKCQk7OwoJZWRpdHxlKQoJCWNvbW1lbnRfZm9yX3JlZmxvZyBlZGl0CgoJCW1hcmtfYWN0aW9uX2RvbmUKCQlkb19waWNrICRzaGExICIkcmVzdCIKCQl3YXJuICJTdG9wcGVkIGF0ICRzaGExLi4uICRyZXN0IgoJCWV4aXRfd2l0aF9wYXRjaCAkc2hhMSAwCgkJOzsKCXNxdWFzaHxzfGZpeHVwfGYpCgkJY2FzZSAiJGNvbW1hbmQiIGluCgkJc3F1YXNofHMpCgkJCXNxdWFzaF9zdHlsZT1zcXVhc2gKCQkJOzsKCQlmaXh1cHxmKQoJCQlzcXVhc2hfc3R5bGU9Zml4dXAKCQkJOzsKCQllc2FjCgkJY29tbWVudF9mb3JfcmVmbG9nICRzcXVhc2hfc3R5bGUKCgkJdGVzdCAtZiAiJGRvbmUiICYmIGhhc19hY3Rpb24gIiRkb25lIiB8fAoJCQlkaWUgIkNhbm5vdCAnJHNxdWFzaF9zdHlsZScgd2l0aG91dCBhIHByZXZpb3VzIGNvbW1pdCIKCgkJbWFya19hY3Rpb25fZG9uZQoJCXVwZGF0ZV9zcXVhc2hfbWVzc2FnZXMgJHNxdWFzaF9zdHlsZSAkc2hhMQoJCWF1dGhvcl9zY3JpcHRfY29udGVudD0kKGdldF9hdXRob3JfaWRlbnRfZnJvbV9jb21taXQgSEVBRCkKCQllY2hvICIkYXV0aG9yX3NjcmlwdF9jb250ZW50IiA+ICIkYXV0aG9yX3NjcmlwdCIKCQlldmFsICIkYXV0aG9yX3NjcmlwdF9jb250ZW50IgoJCWlmICEgcGlja19vbmUgLW4gJHNoYTEKCQl0aGVuCgkJCWdpdCByZXYtcGFyc2UgLS12ZXJpZnkgSEVBRCA+IiRhbWVuZCIKCQkJZGllX2ZhaWxlZF9zcXVhc2ggJHNoYTEgIiRyZXN0IgoJCWZpCgkJY2FzZSAiJChwZWVrX25leHRfY29tbWFuZCkiIGluCgkJc3F1YXNofHN8Zml4dXB8ZikKCQkJIyBUaGlzIGlzIGFuIGludGVybWVkaWF0ZSBjb21taXQ7IGl0cyBtZXNzYWdlIHdpbGwgb25seSBiZQoJCQkjIHVzZWQgaW4gY2FzZSBvZiB0cm91YmxlLiAgU28gdXNlIHRoZSBsb25nIHZlcnNpb246CgkJCWRvX3dpdGhfYXV0aG9yIG91dHB1dCBnaXQgY29tbWl0IC0tYW1lbmQgLS1uby12ZXJpZnkgLUYgIiRzcXVhc2hfbXNnIiBcCgkJCQkke2dwZ19zaWduX29wdDorIiRncGdfc2lnbl9vcHQifSB8fAoJCQkJZGllX2ZhaWxlZF9zcXVhc2ggJHNoYTEgIiRyZXN0IgoJCQk7OwoJCSopCgkJCSMgVGhpcyBpcyB0aGUgZmluYWwgY29tbWFuZCBvZiB0aGlzIHNxdWFzaC9maXh1cCBncm91cAoJCQlpZiB0ZXN0IC1mICIkZml4dXBfbXNnIgoJCQl0aGVuCgkJCQlkb193aXRoX2F1dGhvciBnaXQgY29tbWl0IC0tYW1lbmQgLS1uby12ZXJpZnkgLUYgIiRmaXh1cF9tc2ciIFwKCQkJCQkke2dwZ19zaWduX29wdDorIiRncGdfc2lnbl9vcHQifSB8fAoJCQkJCWRpZV9mYWlsZWRfc3F1YXNoICRzaGExICIkcmVzdCIKCQkJZWxzZQoJCQkJY3AgIiRzcXVhc2hfbXNnIiAiJEdJVF9ESVIiL1NRVUFTSF9NU0cgfHwgZXhpdAoJCQkJcm0gLWYgIiRHSVRfRElSIi9NRVJHRV9NU0cKCQkJCWRvX3dpdGhfYXV0aG9yIGdpdCBjb21taXQgLS1hbWVuZCAtLW5vLXZlcmlmeSAtRiAiJEdJVF9ESVIiL1NRVUFTSF9NU0cgLWUgXAoJCQkJCSR7Z3BnX3NpZ25fb3B0OisiJGdwZ19zaWduX29wdCJ9IHx8CgkJCQkJZGllX2ZhaWxlZF9zcXVhc2ggJHNoYTEgIiRyZXN0IgoJCQlmaQoJCQlybSAtZiAiJHNxdWFzaF9tc2ciICIkZml4dXBfbXNnIgoJCQk7OwoJCWVzYWMKCQlyZWNvcmRfaW5fcmV3cml0dGVuICRzaGExCgkJOzsKCXh8ImV4ZWMiKQoJCXJlYWQgLXIgY29tbWFuZCByZXN0IDwgIiR0b2RvIgoJCW1hcmtfYWN0aW9uX2RvbmUKCQlwcmludGYgJ0V4ZWN1dGluZzogJXNcbicgIiRyZXN0IgoJCSMgImV4ZWMiIGNvbW1hbmQgZG9lc24ndCB0YWtlIGEgc2hhMSBpbiB0aGUgdG9kby1saXN0LgoJCSMgPT4gY2FuJ3QganVzdCB1c2UgJHNoYTEgaGVyZS4KCQlnaXQgcmV2LXBhcnNlIC0tdmVyaWZ5IEhFQUQgPiAiJHN0YXRlX2RpciIvc3RvcHBlZC1zaGEKCQkke1NIRUxMOi1AU0hFTExfUEFUSEB9IC1jICIkcmVzdCIgIyBBY3R1YWwgZXhlY3V0aW9uCgkJc3RhdHVzPSQ/CgkJIyBSdW4gaW4gc3Vic2hlbGwgYmVjYXVzZSByZXF1aXJlX2NsZWFuX3dvcmtfdHJlZSBjYW4gZGllLgoJCWRpcnR5PWYKCQkocmVxdWlyZV9jbGVhbl93b3JrX3RyZWUgInJlYmFzZSIgMj4vZGV2L251bGwpIHx8IGRpcnR5PXQKCQlpZiB0ZXN0ICIkc3RhdHVzIiAtbmUgMAoJCXRoZW4KCQkJd2FybiAiRXhlY3V0aW9uIGZhaWxlZDogJHJlc3QiCgkJCXRlc3QgIiRkaXJ0eSIgPSBmIHx8CgkJCXdhcm4gImFuZCBtYWRlIGNoYW5nZXMgdG8gdGhlIGluZGV4IGFuZC9vciB0aGUgd29ya2luZyB0cmVlIgoKCQkJd2FybiAiWW91IGNhbiBmaXggdGhlIHByb2JsZW0sIGFuZCB0aGVuIHJ1biIKCQkJd2FybgoJCQl3YXJuICIJZ2l0IHJlYmFzZSAtLWNvbnRpbnVlIgoJCQl3YXJuCgkJCWlmIHRlc3QgJHN0YXR1cyAtZXEgMTI3CQkjIGNvbW1hbmQgbm90IGZvdW5kCgkJCXRoZW4KCQkJCXN0YXR1cz0xCgkJCWZpCgkJCWV4aXQgIiRzdGF0dXMiCgkJZWxpZiB0ZXN0ICIkZGlydHkiID0gdAoJCXRoZW4KCQkJd2FybiAiRXhlY3V0aW9uIHN1Y2NlZWRlZDogJHJlc3QiCgkJCXdhcm4gImJ1dCBsZWZ0IGNoYW5nZXMgdG8gdGhlIGluZGV4IGFuZC9vciB0aGUgd29ya2luZyB0cmVlIgoJCQl3YXJuICJDb21taXQgb3Igc3Rhc2ggeW91ciBjaGFuZ2VzLCBhbmQgdGhlbiBydW4iCgkJCXdhcm4KCQkJd2FybiAiCWdpdCByZWJhc2UgLS1jb250aW51ZSIKCQkJd2FybgoJCQlleGl0IDEKCQlmaQoJCTs7CgkqKQoJCXdhcm4gIlVua25vd24gY29tbWFuZDogJGNvbW1hbmQgJHNoYTEgJHJlc3QiCgkJZml4dG9kbz0iUGxlYXNlIGZpeCB0aGlzIHVzaW5nICdnaXQgcmViYXNlIC0tZWRpdC10b2RvJy4iCgkJaWYgZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSAtcSAiJHNoYTEiID4vZGV2L251bGwKCQl0aGVuCgkJCWRpZV93aXRoX3BhdGNoICRzaGExICIkZml4dG9kbyIKCQllbHNlCgkJCWRpZSAiJGZpeHRvZG8iCgkJZmkKCQk7OwoJZXNhYwoJdGVzdCAtcyAiJHRvZG8iICYmIHJldHVybgoKCWNvbW1lbnRfZm9yX3JlZmxvZyBmaW5pc2ggJiYKCW5ld2hlYWQ9JChnaXQgcmV2LXBhcnNlIEhFQUQpICYmCgljYXNlICRoZWFkX25hbWUgaW4KCXJlZnMvKikKCQltZXNzYWdlPSIkR0lUX1JFRkxPR19BQ1RJT046ICRoZWFkX25hbWUgb250byAkb250byIgJiYKCQlnaXQgdXBkYXRlLXJlZiAtbSAiJG1lc3NhZ2UiICRoZWFkX25hbWUgJG5ld2hlYWQgJG9yaWdfaGVhZCAmJgoJCWdpdCBzeW1ib2xpYy1yZWYgXAoJCSAgLW0gIiRHSVRfUkVGTE9HX0FDVElPTjogcmV0dXJuaW5nIHRvICRoZWFkX25hbWUiIFwKCQkgIEhFQUQgJGhlYWRfbmFtZQoJCTs7Cgllc2FjICYmIHsKCQl0ZXN0ICEgLWYgIiRzdGF0ZV9kaXIiL3ZlcmJvc2UgfHwKCQkJZ2l0IGRpZmYtdHJlZSAtLXN0YXQgJG9yaWdfaGVhZC4uSEVBRAoJfSAmJgoJewoJCXRlc3QgLXMgIiRyZXdyaXR0ZW5fbGlzdCIgJiYKCQlnaXQgbm90ZXMgY29weSAtLWZvci1yZXdyaXRlPXJlYmFzZSA8ICIkcmV3cml0dGVuX2xpc3QiIHx8CgkJdHJ1ZSAjIHdlIGRvbid0IGNhcmUgaWYgdGhpcyBjb3B5aW5nIGZhaWxlZAoJfSAmJgoJaWYgdGVzdCAteCAiJEdJVF9ESVIiL2hvb2tzL3Bvc3QtcmV3cml0ZSAmJgoJCXRlc3QgLXMgIiRyZXdyaXR0ZW5fbGlzdCI7IHRoZW4KCQkiJEdJVF9ESVIiL2hvb2tzL3Bvc3QtcmV3cml0ZSByZWJhc2UgPCAiJHJld3JpdHRlbl9saXN0IgoJCXRydWUgIyB3ZSBkb24ndCBjYXJlIGlmIHRoaXMgaG9vayBmYWlsZWQKCWZpICYmCgl3YXJuICJTdWNjZXNzZnVsbHkgcmViYXNlZCBhbmQgdXBkYXRlZCAkaGVhZF9uYW1lLiIKCglyZXR1cm4gMSAjIG5vdCBmYWlsdXJlOyBqdXN0IHRvIGJyZWFrIHRoZSBkb19yZXN0IGxvb3AKfQoKIyBjYW4gb25seSByZXR1cm4gMCwgd2hlbiB0aGUgaW5maW5pdGUgbG9vcCBicmVha3MKZG9fcmVzdCAoKSB7Cgl3aGlsZSA6CglkbwoJCWRvX25leHQgfHwgYnJlYWsKCWRvbmUKfQoKIyBza2lwIHBpY2tpbmcgY29tbWl0cyB3aG9zZSBwYXJlbnRzIGFyZSB1bmNoYW5nZWQKc2tpcF91bm5lY2Vzc2FyeV9waWNrcyAoKSB7CglmZD0zCgl3aGlsZSByZWFkIC1yIGNvbW1hbmQgcmVzdAoJZG8KCQkjIGZkPTMgbWVhbnMgd2Ugc2tpcCB0aGUgY29tbWFuZAoJCWNhc2UgIiRmZCwkY29tbWFuZCIgaW4KCQkzLHBpY2t8MyxwKQoJCQkjIHBpY2sgYSBjb21taXQgd2hvc2UgcGFyZW50IGlzIGN1cnJlbnQgJG9udG8gLT4gc2tpcAoJCQlzaGExPSR7cmVzdCUlICp9CgkJCWNhc2UgIiQoZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSAtLXF1aWV0ICIkc2hhMSJeKSIgaW4KCQkJIiRvbnRvIiopCgkJCQlvbnRvPSRzaGExCgkJCQk7OwoJCQkqKQoJCQkJZmQ9MQoJCQkJOzsKCQkJZXNhYwoJCQk7OwoJCTMsIiRjb21tZW50X2NoYXIiKnwzLCkKCQkJIyBjb3B5IGNvbW1lbnRzCgkJCTs7CgkJKikKCQkJZmQ9MQoJCQk7OwoJCWVzYWMKCQlwcmludGYgJyVzXG4nICIkY29tbWFuZCR7cmVzdDorIH0kcmVzdCIgPiYkZmQKCWRvbmUgPCIkdG9kbyIgPiIkdG9kby5uZXciIDM+PiIkZG9uZSIgJiYKCW12IC1mICIkdG9kbyIubmV3ICIkdG9kbyIgJiYKCWNhc2UgIiQocGVla19uZXh0X2NvbW1hbmQpIiBpbgoJc3F1YXNofHN8Zml4dXB8ZikKCQlyZWNvcmRfaW5fcmV3cml0dGVuICIkb250byIKCQk7OwoJZXNhYyB8fAoJZGllICJDb3VsZCBub3Qgc2tpcCB1bm5lY2Vzc2FyeSBwaWNrIGNvbW1hbmRzIgp9Cgp0cmFuc2Zvcm1fdG9kb19pZHMgKCkgewoJd2hpbGUgcmVhZCAtciBjb21tYW5kIHJlc3QKCWRvCgkJY2FzZSAiJGNvbW1hbmQiIGluCgkJIiRjb21tZW50X2NoYXIiKiB8IGV4ZWMpCgkJCSMgQmUgY2FyZWZ1bCBmb3Igb2RkYmFsbCBjb21tYW5kcyBsaWtlICdleGVjJwoJCQkjIHRoYXQgZG8gbm90IGhhdmUgYSBTSEEtMSBhdCB0aGUgYmVnaW5uaW5nIG9mICRyZXN0LgoJCQk7OwoJCSopCgkJCXNoYTE9JChnaXQgcmV2LXBhcnNlIC0tdmVyaWZ5IC0tcXVpZXQgIiRAIiAke3Jlc3QlJSAqfSkgJiYKCQkJcmVzdD0iJHNoYTEgJHtyZXN0IyogfSIKCQkJOzsKCQllc2FjCgkJcHJpbnRmICclc1xuJyAiJGNvbW1hbmQke3Jlc3Q6KyB9JHJlc3QiCglkb25lIDwiJHRvZG8iID4iJHRvZG8ubmV3IiAmJgoJbXYgLWYgIiR0b2RvLm5ldyIgIiR0b2RvIgp9CgpleHBhbmRfdG9kb19pZHMoKSB7Cgl0cmFuc2Zvcm1fdG9kb19pZHMKfQoKY29sbGFwc2VfdG9kb19pZHMoKSB7Cgl0cmFuc2Zvcm1fdG9kb19pZHMgLS1zaG9ydAp9CgojIFJlYXJyYW5nZSB0aGUgdG9kbyBsaXN0IHRoYXQgaGFzIGJvdGggInBpY2sgc2hhMSBtc2ciIGFuZAojICJwaWNrIHNoYTEgZml4dXAhL3NxdWFzaCEgbXNnIiBhcHBlYXJzIGluIGl0IHNvIHRoYXQgdGhlIGxhdHRlcgojIGNvbWVzIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBmb3JtZXIsIGFuZCBjaGFuZ2UgInBpY2siIHRvCiMgImZpeHVwIi8ic3F1YXNoIi4KcmVhcnJhbmdlX3NxdWFzaCAoKSB7CgkjIGV4dHJhY3QgZml4dXAhL3NxdWFzaCEgbGluZXMgYW5kIHJlc29sdmUgYW55IHJlZmVyZW5jZWQgc2hhMSdzCgl3aGlsZSByZWFkIC1yIHBpY2sgc2hhMSBtZXNzYWdlCglkbwoJCWNhc2UgIiRtZXNzYWdlIiBpbgoJCSJzcXVhc2ghICIqfCJmaXh1cCEgIiopCgkJCWFjdGlvbj0iJHttZXNzYWdlJSUhKn0iCgkJCXJlc3Q9JG1lc3NhZ2UKCQkJcHJlZml4PQoJCQkjIHNraXAgYWxsIHNxdWFzaCEgb3IgZml4dXAhIChidXQgc2F2ZSBmb3IgbGF0ZXIpCgkJCXdoaWxlIDoKCQkJZG8KCQkJCWNhc2UgIiRyZXN0IiBpbgoJCQkJInNxdWFzaCEgIip8ImZpeHVwISAiKikKCQkJCQlwcmVmaXg9IiRwcmVmaXgke3Jlc3QlJSEqfSwiCgkJCQkJcmVzdD0iJHtyZXN0IyohIH0iCgkJCQkJOzsKCQkJCSopCgkJCQkJYnJlYWsKCQkJCQk7OwoJCQkJZXNhYwoJCQlkb25lCgkJCXByaW50ZiAnJXMgJXMgJXMgJXNcbicgIiRzaGExIiAiJGFjdGlvbiIgIiRwcmVmaXgiICIkcmVzdCIKCQkJIyBpZiBpdCdzIGEgc2luZ2xlIHdvcmQsIHRyeSB0byByZXNvbHZlIHRvIGEgZnVsbCBzaGExIGFuZAoJCQkjIGVtaXQgYSBzZWNvbmQgY29weS4gVGhpcyBhbGxvd3MgdXMgdG8gbWF0Y2ggb24gYm90aCBtZXNzYWdlCgkJCSMgYW5kIG9uIHNoYTEgcHJlZml4CgkJCWlmIHRlc3QgIiR7cmVzdCMqIH0iID0gIiRyZXN0IjsgdGhlbgoJCQkJZnVsbHNoYT0iJChnaXQgcmV2LXBhcnNlIC1xIC0tdmVyaWZ5ICIkcmVzdCIgMj4vZGV2L251bGwpIgoJCQkJaWYgdGVzdCAtbiAiJGZ1bGxzaGEiOyB0aGVuCgkJCQkJIyBwcmVmaXggdGhlIGFjdGlvbiB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGxpbmUgYXMKCQkJCQkjIGludGVuZGVkIGZvciBmdWxsIHNoYTEgbWF0Y2gKCQkJCQllY2hvICIkc2hhMSArJGFjdGlvbiAkcHJlZml4ICRmdWxsc2hhIgoJCQkJZmkKCQkJZmkKCQllc2FjCglkb25lID4iJDEuc3EiIDwiJDEiCgl0ZXN0IC1zICIkMS5zcSIgfHwgcmV0dXJuCgoJdXNlZD0KCXdoaWxlIHJlYWQgLXIgcGljayBzaGExIG1lc3NhZ2UKCWRvCgkJY2FzZSAiICR1c2VkIiBpbgoJCSoiICRzaGExICIqKSBjb250aW51ZSA7OwoJCWVzYWMKCQlwcmludGYgJyVzXG4nICIkcGljayAkc2hhMSAkbWVzc2FnZSIKCQl1c2VkPSIkdXNlZCRzaGExICIKCQl3aGlsZSByZWFkIC1yIHNxdWFzaCBhY3Rpb24gbXNnX3ByZWZpeCBtc2dfY29udGVudAoJCWRvCgkJCWNhc2UgIiAkdXNlZCIgaW4KCQkJKiIgJHNxdWFzaCAiKikgY29udGludWUgOzsKCQkJZXNhYwoJCQllbWl0PTAKCQkJY2FzZSAiJGFjdGlvbiIgaW4KCQkJKyopCgkJCQlhY3Rpb249IiR7YWN0aW9uIyt9IgoJCQkJIyBmdWxsIHNoYTEgcHJlZml4IHRlc3QKCQkJCWNhc2UgIiRtc2dfY29udGVudCIgaW4gIiRzaGExIiopIGVtaXQ9MTs7IGVzYWMgOzsKCQkJKikKCQkJCSMgbWVzc2FnZSBwcmVmaXggdGVzdAoJCQkJY2FzZSAiJG1lc3NhZ2UiIGluICIkbXNnX2NvbnRlbnQiKikgZW1pdD0xOzsgZXNhYyA7OwoJCQllc2FjCgkJCWlmIHRlc3QgJGVtaXQgPSAxOyB0aGVuCgkJCQlyZWFsX3ByZWZpeD0kKGVjaG8gIiRtc2dfcHJlZml4IiB8IHNlZCAicy8sLyEgL2ciKQoJCQkJcHJpbnRmICclc1xuJyAiJGFjdGlvbiAkc3F1YXNoICR7cmVhbF9wcmVmaXh9JG1zZ19jb250ZW50IgoJCQkJdXNlZD0iJHVzZWQkc3F1YXNoICIKCQkJZmkKCQlkb25lIDwiJDEuc3EiCglkb25lID4iJDEucmVhcnJhbmdlZCIgPCIkMSIKCWNhdCAiJDEucmVhcnJhbmdlZCIgPiIkMSIKCXJtIC1mICIkMS5zcSIgIiQxLnJlYXJyYW5nZWQiCn0KCiMgQWRkIGNvbW1hbmRzIGFmdGVyIGEgcGljayBvciBhZnRlciBhIHNxdWFzaC9maXh1cCBzZXJpZQojIGluIHRoZSB0b2RvIGxpc3QuCmFkZF9leGVjX2NvbW1hbmRzICgpIHsKCXsKCQlmaXJzdD10CgkJd2hpbGUgcmVhZCAtciBpbnNuIHJlc3QKCQlkbwoJCQljYXNlICRpbnNuIGluCgkJCXBpY2spCgkJCQl0ZXN0IC1uICIkZmlyc3QiIHx8CgkJCQlwcmludGYgIiVzIiAiJGNtZCIKCQkJCTs7CgkJCWVzYWMKCQkJcHJpbnRmICIlcyAlc1xuIiAiJGluc24iICIkcmVzdCIKCQkJZmlyc3Q9CgkJZG9uZQoJCXByaW50ZiAiJXMiICIkY21kIgoJfSA8IiQxIiA+IiQxLm5ldyIgJiYKCW12ICIkMS5uZXciICIkMSIKfQoKIyBUaGUgd2hvbGUgY29udGVudHMgb2YgdGhpcyBmaWxlIGlzIHJ1biBieSBkb3Qtc291cmNpbmcgaXQgZnJvbQojIGluc2lkZSBhIHNoZWxsIGZ1bmN0aW9uLiAgSXQgdXNlZCB0byBiZSB0aGF0ICJyZXR1cm4icyB3ZSBzZWUKIyBiZWxvdyB3ZXJlIG5vdCBpbnNpZGUgYW55IGZ1bmN0aW9uLCBhbmQgZXhwZWN0ZWQgdG8gcmV0dXJuCiMgdG8gdGhlIGZ1bmN0aW9uIHRoYXQgZG90LXNvdXJjZWQgdXMuCiMKIyBIb3dldmVyLCBGcmVlQlNEIC9iaW4vc2ggbWlzYmVoYXZlcyBvbiBzdWNoIGEgY29uc3RydWN0IGFuZAojIGNvbnRpbnVlcyB0byBydW4gdGhlIHN0YXRlbWVudHMgdGhhdCBmb2xsb3cgc3VjaCBhICJyZXR1cm4iLgojIEFzIGEgd29yay1hcm91bmQsIHdlIGludHJvZHVjZSBhbiBleHRyYSBsYXllciBvZiBhIGZ1bmN0aW9uCiMgaGVyZSwgYW5kIGltbWVkaWF0ZWx5IGNhbGwgaXQgYWZ0ZXIgZGVmaW5pbmcgaXQuCmdpdF9yZWJhc2VfX2ludGVyYWN0aXZlICgpIHsKCmNhc2UgIiRhY3Rpb24iIGluCmNvbnRpbnVlKQoJIyBkbyB3ZSBoYXZlIGFueXRoaW5nIHRvIGNvbW1pdD8KCWlmIGdpdCBkaWZmLWluZGV4IC0tY2FjaGVkIC0tcXVpZXQgSEVBRCAtLQoJdGhlbgoJCTogTm90aGluZyB0byBjb21taXQgLS0gc2tpcCB0aGlzCgllbHNlCgkJaWYgISB0ZXN0IC1mICIkYXV0aG9yX3NjcmlwdCIKCQl0aGVuCgkJCWdwZ19zaWduX29wdF9xdW90ZWQ9JHtncGdfc2lnbl9vcHQ6KyQoZ2l0IHJldi1wYXJzZSAtLXNxLXF1b3RlICIkZ3BnX3NpZ25fb3B0Iil9CgkJCWRpZSAiWW91IGhhdmUgc3RhZ2VkIGNoYW5nZXMgaW4geW91ciB3b3JraW5nIHRyZWUuIElmIHRoZXNlIGNoYW5nZXMgYXJlIG1lYW50IHRvIGJlCnNxdWFzaGVkIGludG8gdGhlIHByZXZpb3VzIGNvbW1pdCwgcnVuOgoKICBnaXQgY29tbWl0IC0tYW1lbmQgJGdwZ19zaWduX29wdF9xdW90ZWQKCklmIHRoZXkgYXJlIG1lYW50IHRvIGdvIGludG8gYSBuZXcgY29tbWl0LCBydW46CgogIGdpdCBjb21taXQgJGdwZ19zaWduX29wdF9xdW90ZWQKCkluIGJvdGggY2FzZSwgb25jZSB5b3UncmUgZG9uZSwgY29udGludWUgd2l0aDoKCiAgZ2l0IHJlYmFzZSAtLWNvbnRpbnVlCiIKCQlmaQoJCS4gIiRhdXRob3Jfc2NyaXB0IiB8fAoJCQlkaWUgIkVycm9yIHRyeWluZyB0byBmaW5kIHRoZSBhdXRob3IgaWRlbnRpdHkgdG8gYW1lbmQgY29tbWl0IgoJCWlmIHRlc3QgLWYgIiRhbWVuZCIKCQl0aGVuCgkJCWN1cnJlbnRfaGVhZD0kKGdpdCByZXYtcGFyc2UgLS12ZXJpZnkgSEVBRCkKCQkJdGVzdCAiJGN1cnJlbnRfaGVhZCIgPSAkKGNhdCAiJGFtZW5kIikgfHwKCQkJZGllICJcCllvdSBoYXZlIHVuY29tbWl0dGVkIGNoYW5nZXMgaW4geW91ciB3b3JraW5nIHRyZWUuIFBsZWFzZSwgY29tbWl0IHRoZW0KZmlyc3QgYW5kIHRoZW4gcnVuICdnaXQgcmViYXNlIC0tY29udGludWUnIGFnYWluLiIKCQkJZG9fd2l0aF9hdXRob3IgZ2l0IGNvbW1pdCAtLWFtZW5kIC0tbm8tdmVyaWZ5IC1GICIkbXNnIiAtZSBcCgkJCQkke2dwZ19zaWduX29wdDorIiRncGdfc2lnbl9vcHQifSB8fAoJCQkJZGllICJDb3VsZCBub3QgY29tbWl0IHN0YWdlZCBjaGFuZ2VzLiIKCQllbHNlCgkJCWRvX3dpdGhfYXV0aG9yIGdpdCBjb21taXQgLS1uby12ZXJpZnkgLUYgIiRtc2ciIC1lIFwKCQkJCSR7Z3BnX3NpZ25fb3B0OisiJGdwZ19zaWduX29wdCJ9IHx8CgkJCQlkaWUgIkNvdWxkIG5vdCBjb21taXQgc3RhZ2VkIGNoYW5nZXMuIgoJCWZpCglmaQoKCXJlY29yZF9pbl9yZXdyaXR0ZW4gIiQoY2F0ICIkc3RhdGVfZGlyIi9zdG9wcGVkLXNoYSkiCgoJcmVxdWlyZV9jbGVhbl93b3JrX3RyZWUgInJlYmFzZSIKCWRvX3Jlc3QKCXJldHVybiAwCgk7Owpza2lwKQoJZ2l0IHJlcmVyZSBjbGVhcgoKCWRvX3Jlc3QKCXJldHVybiAwCgk7OwplZGl0LXRvZG8pCglnaXQgc3RyaXBzcGFjZSAtLXN0cmlwLWNvbW1lbnRzIDwiJHRvZG8iID4iJHRvZG8iLm5ldwoJbXYgLWYgIiR0b2RvIi5uZXcgIiR0b2RvIgoJY29sbGFwc2VfdG9kb19pZHMKCWFwcGVuZF90b2RvX2hlbHAKCWdpdCBzdHJpcHNwYWNlIC0tY29tbWVudC1saW5lcyA+PiIkdG9kbyIgPDxcRU9GCgpZb3UgYXJlIGVkaXRpbmcgdGhlIHRvZG8gZmlsZSBvZiBhbiBvbmdvaW5nIGludGVyYWN0aXZlIHJlYmFzZS4KVG8gY29udGludWUgcmViYXNlIGFmdGVyIGVkaXRpbmcsIHJ1bjoKICAgIGdpdCByZWJhc2UgLS1jb250aW51ZQoKRU9GCgoJZ2l0X3NlcXVlbmNlX2VkaXRvciAiJHRvZG8iIHx8CgkJZGllICJDb3VsZCBub3QgZXhlY3V0ZSBlZGl0b3IiCglleHBhbmRfdG9kb19pZHMKCglleGl0Cgk7Owplc2FjCgpnaXQgdmFyIEdJVF9DT01NSVRURVJfSURFTlQgPi9kZXYvbnVsbCB8fAoJZGllICJZb3UgbmVlZCB0byBzZXQgeW91ciBjb21taXR0ZXIgaW5mbyBmaXJzdCIKCmNvbW1lbnRfZm9yX3JlZmxvZyBzdGFydAoKaWYgdGVzdCAhIC16ICIkc3dpdGNoX3RvIgp0aGVuCglHSVRfUkVGTE9HX0FDVElPTj0iJEdJVF9SRUZMT0dfQUNUSU9OOiBjaGVja291dCAkc3dpdGNoX3RvIgoJb3V0cHV0IGdpdCBjaGVja291dCAiJHN3aXRjaF90byIgLS0gfHwKCWRpZSAiQ291bGQgbm90IGNoZWNrb3V0ICRzd2l0Y2hfdG8iCgoJY29tbWVudF9mb3JfcmVmbG9nIHN0YXJ0CmZpCgpvcmlnX2hlYWQ9JChnaXQgcmV2LXBhcnNlIC0tdmVyaWZ5IEhFQUQpIHx8IGRpZSAiTm8gSEVBRD8iCm1rZGlyIC1wICIkc3RhdGVfZGlyIiB8fCBkaWUgIkNvdWxkIG5vdCBjcmVhdGUgdGVtcG9yYXJ5ICRzdGF0ZV9kaXIiCgo6ID4gIiRzdGF0ZV9kaXIiL2ludGVyYWN0aXZlIHx8IGRpZSAiQ291bGQgbm90IG1hcmsgYXMgaW50ZXJhY3RpdmUiCndyaXRlX2Jhc2ljX3N0YXRlCmlmIHRlc3QgdCA9ICIkcHJlc2VydmVfbWVyZ2VzIgp0aGVuCglpZiB0ZXN0IC16ICIkcmViYXNlX3Jvb3QiCgl0aGVuCgkJbWtkaXIgIiRyZXdyaXR0ZW4iICYmCgkJZm9yIGMgaW4gJChnaXQgbWVyZ2UtYmFzZSAtLWFsbCAkb3JpZ19oZWFkICR1cHN0cmVhbSkKCQlkbwoJCQllY2hvICRvbnRvID4gIiRyZXdyaXR0ZW4iLyRjIHx8CgkJCQlkaWUgIkNvdWxkIG5vdCBpbml0IHJld3JpdHRlbiBjb21taXRzIgoJCWRvbmUKCWVsc2UKCQlta2RpciAiJHJld3JpdHRlbiIgJiYKCQllY2hvICRvbnRvID4gIiRyZXdyaXR0ZW4iL3Jvb3QgfHwKCQkJZGllICJDb3VsZCBub3QgaW5pdCByZXdyaXR0ZW4gY29tbWl0cyIKCWZpCgkjIE5vIGNoZXJyeS1waWNrIGJlY2F1c2Ugb3VyIGZpcnN0IHBhc3MgaXMgdG8gZGV0ZXJtaW5lCgkjIHBhcmVudHMgdG8gcmV3cml0ZSBhbmQgc2tpcHBpbmcgZHJvcHBlZCBjb21taXRzIHdvdWxkCgkjIHByZW1hdHVyZWx5IGVuZCBvdXIgcHJvYmUKCW1lcmdlc19vcHRpb249CmVsc2UKCW1lcmdlc19vcHRpb249Ii0tbm8tbWVyZ2VzIC0tY2hlcnJ5LXBpY2siCmZpCgpzaG9ydGhlYWQ9JChnaXQgcmV2LXBhcnNlIC0tc2hvcnQgJG9yaWdfaGVhZCkKc2hvcnRvbnRvPSQoZ2l0IHJldi1wYXJzZSAtLXNob3J0ICRvbnRvKQppZiB0ZXN0IC16ICIkcmViYXNlX3Jvb3QiCgkjIHRoaXMgaXMgbm93IGVxdWl2YWxlbnQgdG8gISAteiAiJHVwc3RyZWFtIgp0aGVuCglzaG9ydHVwc3RyZWFtPSQoZ2l0IHJldi1wYXJzZSAtLXNob3J0ICR1cHN0cmVhbSkKCXJldmlzaW9ucz0kdXBzdHJlYW0uLi4kb3JpZ19oZWFkCglzaG9ydHJldmlzaW9ucz0kc2hvcnR1cHN0cmVhbS4uJHNob3J0aGVhZAplbHNlCglyZXZpc2lvbnM9JG9udG8uLi4kb3JpZ19oZWFkCglzaG9ydHJldmlzaW9ucz0kc2hvcnRoZWFkCmZpCmdpdCByZXYtbGlzdCAkbWVyZ2VzX29wdGlvbiAtLXByZXR0eT1vbmVsaW5lIC0tcmV2ZXJzZSAtLWxlZnQtcmlnaHQgLS10b3BvLW9yZGVyIFwKCSRyZXZpc2lvbnMgJHtyZXN0cmljdF9yZXZpc2lvbiteJHJlc3RyaWN0X3JldmlzaW9ufSB8IFwKCXNlZCAtbiAicy9ePi8vcCIgfAp3aGlsZSByZWFkIC1yIHNoYTEgcmVzdApkbwoKCWlmIHRlc3QgLXogIiRrZWVwX2VtcHR5IiAmJiBpc19lbXB0eV9jb21taXQgJHNoYTEgJiYgISBpc19tZXJnZV9jb21taXQgJHNoYTEKCXRoZW4KCQljb21tZW50X291dD0iJGNvbW1lbnRfY2hhciAiCgllbHNlCgkJY29tbWVudF9vdXQ9CglmaQoKCWlmIHRlc3QgdCAhPSAiJHByZXNlcnZlX21lcmdlcyIKCXRoZW4KCQlwcmludGYgJyVzXG4nICIke2NvbW1lbnRfb3V0fXBpY2sgJHNoYTEgJHJlc3QiID4+IiR0b2RvIgoJZWxzZQoJCWlmIHRlc3QgLXogIiRyZWJhc2Vfcm9vdCIKCQl0aGVuCgkJCXByZXNlcnZlPXQKCQkJZm9yIHAgaW4gJChnaXQgcmV2LWxpc3QgLS1wYXJlbnRzIC0xICRzaGExIHwgY3V0IC1kJyAnIC1zIC1mMi0pCgkJCWRvCgkJCQlpZiB0ZXN0IC1mICIkcmV3cml0dGVuIi8kcAoJCQkJdGhlbgoJCQkJCXByZXNlcnZlPWYKCQkJCWZpCgkJCWRvbmUKCQllbHNlCgkJCXByZXNlcnZlPWYKCQlmaQoJCWlmIHRlc3QgZiA9ICIkcHJlc2VydmUiCgkJdGhlbgoJCQl0b3VjaCAiJHJld3JpdHRlbiIvJHNoYTEKCQkJcHJpbnRmICclc1xuJyAiJHtjb21tZW50X291dH1waWNrICRzaGExICRyZXN0IiA+PiIkdG9kbyIKCQlmaQoJZmkKZG9uZQoKIyBXYXRjaCBmb3IgY29tbWl0cyB0aGF0IGJlZW4gZHJvcHBlZCBieSAtLWNoZXJyeS1waWNrCmlmIHRlc3QgdCA9ICIkcHJlc2VydmVfbWVyZ2VzIgp0aGVuCglta2RpciAiJGRyb3BwZWQiCgkjIFNhdmUgYWxsIG5vbi1jaGVycnktcGlja2VkIGNoYW5nZXMKCWdpdCByZXYtbGlzdCAkcmV2aXNpb25zIC0tbGVmdC1yaWdodCAtLWNoZXJyeS1waWNrIHwgXAoJCXNlZCAtbiAicy9ePi8vcCIgPiAiJHN0YXRlX2RpciIvbm90LWNoZXJyeS1waWNrcwoJIyBOb3cgYWxsIGNvbW1pdHMgYW5kIG5vdGUgd2hpY2ggb25lcyBhcmUgbWlzc2luZyBpbgoJIyBub3QtY2hlcnJ5LXBpY2tzIGFuZCBoZW5jZSBiZWluZyBkcm9wcGVkCglnaXQgcmV2LWxpc3QgJHJldmlzaW9ucyB8Cgl3aGlsZSByZWFkIHJldgoJZG8KCQlpZiB0ZXN0IC1mICIkcmV3cml0dGVuIi8kcmV2ICYmIHRlc3QgIiQoc2FuZV9ncmVwICIkcmV2IiAiJHN0YXRlX2RpciIvbm90LWNoZXJyeS1waWNrcykiID0gIiIKCQl0aGVuCgkJCSMgVXNlIC1mMiBiZWNhdXNlIGlmIHJldi1saXN0IGlzIHRlbGxpbmcgdXMgdGhpcyBjb21taXQgaXMKCQkJIyBub3Qgd29ydGh3aGlsZSwgd2UgZG9uJ3Qgd2FudCB0byB0cmFjayBpdHMgbXVsdGlwbGUgaGVhZHMsCgkJCSMganVzdCB0aGUgaGlzdG9yeSBvZiBpdHMgZmlyc3QtcGFyZW50IGZvciBvdGhlcnMgdGhhdCB3aWxsCgkJCSMgYmUgcmViYXNpbmcgb24gdG9wIG9mIGl0CgkJCWdpdCByZXYtbGlzdCAtLXBhcmVudHMgLTEgJHJldiB8IGN1dCAtZCcgJyAtcyAtZjIgPiAiJGRyb3BwZWQiLyRyZXYKCQkJc2hhMT0kKGdpdCByZXYtbGlzdCAtMSAkcmV2KQoJCQlzYW5lX2dyZXAgLXYgIl5bYS16XVthLXpdKiAkc2hhMSIgPCIkdG9kbyIgPiAiJHt0b2RvfTIiIDsgbXYgIiR7dG9kb30yIiAiJHRvZG8iCgkJCXJtICIkcmV3cml0dGVuIi8kcmV2CgkJZmkKCWRvbmUKZmkKCnRlc3QgLXMgIiR0b2RvIiB8fCBlY2hvIG5vb3AgPj4gIiR0b2RvIgp0ZXN0IC1uICIkYXV0b3NxdWFzaCIgJiYgcmVhcnJhbmdlX3NxdWFzaCAiJHRvZG8iCnRlc3QgLW4gIiRjbWQiICYmIGFkZF9leGVjX2NvbW1hbmRzICIkdG9kbyIKCnRvZG9jb3VudD0kKGdpdCBzdHJpcHNwYWNlIC0tc3RyaXAtY29tbWVudHMgPCIkdG9kbyIgfCB3YyAtbCkKdG9kb2NvdW50PSR7dG9kb2NvdW50IyMqIH0KCmNhdCA+PiIkdG9kbyIgPDxFT0YKCiRjb21tZW50X2NoYXIgUmViYXNlICRzaG9ydHJldmlzaW9ucyBvbnRvICRzaG9ydG9udG8gKCR0b2RvY291bnQgY29tbWFuZChzKSkKRU9GCmFwcGVuZF90b2RvX2hlbHAKZ2l0IHN0cmlwc3BhY2UgLS1jb21tZW50LWxpbmVzID4+IiR0b2RvIiA8PFxFT0YKCkhvd2V2ZXIsIGlmIHlvdSByZW1vdmUgZXZlcnl0aGluZywgdGhlIHJlYmFzZSB3aWxsIGJlIGFib3J0ZWQuCgpFT0YKCmlmIHRlc3QgLXogIiRrZWVwX2VtcHR5Igp0aGVuCglwcmludGYgJyVzXG4nICIkY29tbWVudF9jaGFyIE5vdGUgdGhhdCBlbXB0eSBjb21taXRzIGFyZSBjb21tZW50ZWQgb3V0IiA+PiIkdG9kbyIKZmkKCgpoYXNfYWN0aW9uICIkdG9kbyIgfHwKCXJldHVybiAyCgpjcCAiJHRvZG8iICIkdG9kbyIuYmFja3VwCmNvbGxhcHNlX3RvZG9faWRzCmdpdF9zZXF1ZW5jZV9lZGl0b3IgIiR0b2RvIiB8fAoJZGllX2Fib3J0ICJDb3VsZCBub3QgZXhlY3V0ZSBlZGl0b3IiCgpoYXNfYWN0aW9uICIkdG9kbyIgfHwKCXJldHVybiAyCgpleHBhbmRfdG9kb19pZHMKCnRlc3QgLWQgIiRyZXdyaXR0ZW4iIHx8IHRlc3QgLW4gIiRmb3JjZV9yZWJhc2UiIHx8IHNraXBfdW5uZWNlc3NhcnlfcGlja3MKCkdJVF9SRUZMT0dfQUNUSU9OPSIkR0lUX1JFRkxPR19BQ1RJT046IGNoZWNrb3V0ICRvbnRvX25hbWUiCm91dHB1dCBnaXQgY2hlY2tvdXQgJG9udG8gfHwgZGllX2Fib3J0ICJjb3VsZCBub3QgZGV0YWNoIEhFQUQiCmdpdCB1cGRhdGUtcmVmIE9SSUdfSEVBRCAkb3JpZ19oZWFkCmRvX3Jlc3QKCn0KIyAuLi4gYW5kIHRoZW4gd2UgY2FsbCB0aGUgd2hvbGUgdGhpbmcuCmdpdF9yZWJhc2VfX2ludGVyYWN0aXZlCg==",
    "text": "# This shell script fragment is sourced by git-rebase to implement\n# its interactive mode.  \"git rebase --interactive\" makes it easy\n# to fix up commits in the middle of a series and rearrange commits.\n#\n# Copyright (c) 2006 Johannes E. Schindelin\n#\n# The original idea comes from Eric W. Biederman, in\n# http://article.gmane.org/gmane.comp.version-control.git/22407\n#\n# The file containing rebase commands, comments, and empty lines.\n# This file is created by \"git rebase -i\" then edited by the user.  As\n# the lines are processed, they are removed from the front of this\n# file and written to the tail of $done.\ntodo=\"$state_dir\"/git-rebase-todo\n\n# The rebase command lines that have already been processed.  A line\n# is moved here when it is first handled, before any associated user\n# actions.\ndone=\"$state_dir\"/done\n\n# The commit message that is planned to be used for any changes that\n# need to be committed following a user interaction.\nmsg=\"$state_dir\"/message\n\n# The file into which is accumulated the suggested commit message for\n# squash/fixup commands.  When the first of a series of squash/fixups\n# is seen, the file is created and the commit message from the\n# previous commit and from the first squash/fixup commit are written\n# to it.  The commit message for each subsequent squash/fixup commit\n# is appended to the file as it is processed.\n#\n# The first line of the file is of the form\n#     # This is a combination of $count commits.\n# where $count is the number of commits whose messages have been\n# written to the file so far (including the initial \"pick\" commit).\n# Each time that a commit message is processed, this line is read and\n# updated.  It is deleted just before the combined commit is made.\nsquash_msg=\"$state_dir\"/message-squash\n\n# If the current series of squash/fixups has not yet included a squash\n# command, then this file exists and holds the commit message of the\n# original \"pick\" commit.  (If the series ends without a \"squash\"\n# command, then this can be used as the commit message of the combined\n# commit without opening the editor.)\nfixup_msg=\"$state_dir\"/message-fixup\n\n# $rewritten is the name of a directory containing files for each\n# commit that is reachable by at least one merge base of $head and\n# $upstream. They are not necessarily rewritten, but their children\n# might be.  This ensures that commits on merged, but otherwise\n# unrelated side branches are left alone. (Think \"X\" in the man page's\n# example.)\nrewritten=\"$state_dir\"/rewritten\n\ndropped=\"$state_dir\"/dropped\n\nend=\"$state_dir\"/end\nmsgnum=\"$state_dir\"/msgnum\n\n# A script to set the GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, and\n# GIT_AUTHOR_DATE that will be used for the commit that is currently\n# being rebased.\nauthor_script=\"$state_dir\"/author-script\n\n# When an \"edit\" rebase command is being processed, the SHA1 of the\n# commit to be edited is recorded in this file.  When \"git rebase\n# --continue\" is executed, if there are any staged changes then they\n# will be amended to the HEAD commit, but only provided the HEAD\n# commit is still the commit to be edited.  When any other rebase\n# command is processed, this file is deleted.\namend=\"$state_dir\"/amend\n\n# For the post-rewrite hook, we make a list of rewritten commits and\n# their new sha1s.  The rewritten-pending list keeps the sha1s of\n# commits that have been processed, but not committed yet,\n# e.g. because they are waiting for a 'squash' command.\nrewritten_list=\"$state_dir\"/rewritten-list\nrewritten_pending=\"$state_dir\"/rewritten-pending\n\nstrategy_args=\nif test -n \"$do_merge\"\nthen\n\tstrategy_args=${strategy:+--strategy=$strategy}\n\teval '\n\t\tfor strategy_opt in '\"$strategy_opts\"'\n\t\tdo\n\t\t\tstrategy_args=\"$strategy_args -X$(git rev-parse --sq-quote \"${strategy_opt#--}\")\"\n\t\tdone\n\t'\nfi\n\nGIT_CHERRY_PICK_HELP=\"$resolvemsg\"\nexport GIT_CHERRY_PICK_HELP\n\ncomment_char=$(git config --get core.commentchar 2>/dev/null | cut -c1)\n: ${comment_char:=#}\n\nwarn () {\n\tprintf '%s\\n' \"$*\" >&2\n}\n\n# Output the commit message for the specified commit.\ncommit_message () {\n\tgit cat-file commit \"$1\" | sed \"1,/^$/d\"\n}\n\norig_reflog_action=\"$GIT_REFLOG_ACTION\"\n\ncomment_for_reflog () {\n\tcase \"$orig_reflog_action\" in\n\t''|rebase*)\n\t\tGIT_REFLOG_ACTION=\"rebase -i ($1)\"\n\t\texport GIT_REFLOG_ACTION\n\t\t;;\n\tesac\n}\n\nlast_count=\nmark_action_done () {\n\tsed -e 1q < \"$todo\" >> \"$done\"\n\tsed -e 1d < \"$todo\" >> \"$todo\".new\n\tmv -f \"$todo\".new \"$todo\"\n\tnew_count=$(git stripspace --strip-comments <\"$done\" | wc -l)\n\techo $new_count >\"$msgnum\"\n\ttotal=$(($new_count + $(git stripspace --strip-comments <\"$todo\" | wc -l)))\n\techo $total >\"$end\"\n\tif test \"$last_count\" != \"$new_count\"\n\tthen\n\t\tlast_count=$new_count\n\t\tprintf \"Rebasing (%d/%d)\\r\" $new_count $total\n\t\ttest -z \"$verbose\" || echo\n\tfi\n}\n\n# Put the last action marked done at the beginning of the todo list\n# again. If there has not been an action marked done yet, leave the list of\n# items on the todo list unchanged.\nreschedule_last_action () {\n\ttail -n 1 \"$done\" | cat - \"$todo\" >\"$todo\".new\n\tsed -e \\$d <\"$done\" >\"$done\".new\n\tmv -f \"$todo\".new \"$todo\"\n\tmv -f \"$done\".new \"$done\"\n}\n\nappend_todo_help () {\n\tgit stripspace --comment-lines >>\"$todo\" <<\\EOF\n\nCommands:\n p, pick = use commit\n r, reword = use commit, but edit the commit message\n e, edit = use commit, but stop for amending\n s, squash = use commit, but meld into previous commit\n f, fixup = like \"squash\", but discard this commit's log message\n x, exec = run command (the rest of the line) using shell\n\nThese lines can be re-ordered; they are executed from top to bottom.\n\nIf you remove a line here THAT COMMIT WILL BE LOST.\nEOF\n}\n\nmake_patch () {\n\tsha1_and_parents=\"$(git rev-list --parents -1 \"$1\")\"\n\tcase \"$sha1_and_parents\" in\n\t?*' '?*' '?*)\n\t\tgit diff --cc $sha1_and_parents\n\t\t;;\n\t?*' '?*)\n\t\tgit diff-tree -p \"$1^!\"\n\t\t;;\n\t*)\n\t\techo \"Root commit\"\n\t\t;;\n\tesac > \"$state_dir\"/patch\n\ttest -f \"$msg\" ||\n\t\tcommit_message \"$1\" > \"$msg\"\n\ttest -f \"$author_script\" ||\n\t\tget_author_ident_from_commit \"$1\" > \"$author_script\"\n}\n\ndie_with_patch () {\n\techo \"$1\" > \"$state_dir\"/stopped-sha\n\tmake_patch \"$1\"\n\tgit rerere\n\tdie \"$2\"\n}\n\nexit_with_patch () {\n\techo \"$1\" > \"$state_dir\"/stopped-sha\n\tmake_patch $1\n\tgit rev-parse --verify HEAD > \"$amend\"\n\tgpg_sign_opt_quoted=${gpg_sign_opt:+$(git rev-parse --sq-quote \"$gpg_sign_opt\")}\n\twarn \"You can amend the commit now, with\"\n\twarn\n\twarn \"\tgit commit --amend $gpg_sign_opt_quoted\"\n\twarn\n\twarn \"Once you are satisfied with your changes, run\"\n\twarn\n\twarn \"\tgit rebase --continue\"\n\twarn\n\texit $2\n}\n\ndie_abort () {\n\trm -rf \"$state_dir\"\n\tdie \"$1\"\n}\n\nhas_action () {\n\ttest -n \"$(git stripspace --strip-comments <\"$1\")\"\n}\n\nis_empty_commit() {\n\ttree=$(git rev-parse -q --verify \"$1\"^{tree} 2>/dev/null ||\n\t\tdie \"$1: not a commit that can be picked\")\n\tptree=$(git rev-parse -q --verify \"$1\"^^{tree} 2>/dev/null ||\n\t\tptree=4b825dc642cb6eb9a060e54bf8d69288fbee4904)\n\ttest \"$tree\" = \"$ptree\"\n}\n\nis_merge_commit()\n{\n\tgit rev-parse --verify --quiet \"$1\"^2 >/dev/null 2>&1\n}\n\n# Run command with GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, and\n# GIT_AUTHOR_DATE exported from the current environment.\ndo_with_author () {\n\t(\n\t\texport GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL GIT_AUTHOR_DATE\n\t\t\"$@\"\n\t)\n}\n\ngit_sequence_editor () {\n\tif test -z \"$GIT_SEQUENCE_EDITOR\"\n\tthen\n\t\tGIT_SEQUENCE_EDITOR=\"$(git config sequence.editor)\"\n\t\tif [ -z \"$GIT_SEQUENCE_EDITOR\" ]\n\t\tthen\n\t\t\tGIT_SEQUENCE_EDITOR=\"$(git var GIT_EDITOR)\" || return $?\n\t\tfi\n\tfi\n\n\teval \"$GIT_SEQUENCE_EDITOR\" '\"$@\"'\n}\n\npick_one () {\n\tff=--ff\n\n\tcase \"$1\" in -n) sha1=$2; ff= ;; *) sha1=$1 ;; esac\n\tcase \"$force_rebase\" in '') ;; ?*) ff= ;; esac\n\toutput git rev-parse --verify $sha1 || die \"Invalid commit name: $sha1\"\n\n\tif is_empty_commit \"$sha1\"\n\tthen\n\t\tempty_args=\"--allow-empty\"\n\tfi\n\n\ttest -d \"$rewritten\" &&\n\t\tpick_one_preserving_merges \"$@\" && return\n\toutput eval git cherry-pick \\\n\t\t\t${gpg_sign_opt:+$(git rev-parse --sq-quote \"$gpg_sign_opt\")} \\\n\t\t\t\"$strategy_args\" $empty_args $ff \"$@\"\n\n\t# If cherry-pick dies it leaves the to-be-picked commit unrecorded. Reschedule\n\t# previous task so this commit is not lost.\n\tret=$?\n\tcase \"$ret\" in [01]) ;; *) reschedule_last_action ;; esac\n\treturn $ret\n}\n\npick_one_preserving_merges () {\n\tfast_forward=t\n\tcase \"$1\" in\n\t-n)\n\t\tfast_forward=f\n\t\tsha1=$2\n\t\t;;\n\t*)\n\t\tsha1=$1\n\t\t;;\n\tesac\n\tsha1=$(git rev-parse $sha1)\n\n\tif test -f \"$state_dir\"/current-commit\n\tthen\n\t\tif test \"$fast_forward\" = t\n\t\tthen\n\t\t\twhile read current_commit\n\t\t\tdo\n\t\t\t\tgit rev-parse HEAD > \"$rewritten\"/$current_commit\n\t\t\tdone <\"$state_dir\"/current-commit\n\t\t\trm \"$state_dir\"/current-commit ||\n\t\t\tdie \"Cannot write current commit's replacement sha1\"\n\t\tfi\n\tfi\n\n\techo $sha1 >> \"$state_dir\"/current-commit\n\n\t# rewrite parents; if none were rewritten, we can fast-forward.\n\tnew_parents=\n\tpend=\" $(git rev-list --parents -1 $sha1 | cut -d' ' -s -f2-)\"\n\tif test \"$pend\" = \" \"\n\tthen\n\t\tpend=\" root\"\n\tfi\n\twhile [ \"$pend\" != \"\" ]\n\tdo\n\t\tp=$(expr \"$pend\" : ' \\([^ ]*\\)')\n\t\tpend=\"${pend# $p}\"\n\n\t\tif test -f \"$rewritten\"/$p\n\t\tthen\n\t\t\tnew_p=$(cat \"$rewritten\"/$p)\n\n\t\t\t# If the todo reordered commits, and our parent is marked for\n\t\t\t# rewriting, but hasn't been gotten to yet, assume the user meant to\n\t\t\t# drop it on top of the current HEAD\n\t\t\tif test -z \"$new_p\"\n\t\t\tthen\n\t\t\t\tnew_p=$(git rev-parse HEAD)\n\t\t\tfi\n\n\t\t\ttest $p != $new_p && fast_forward=f\n\t\t\tcase \"$new_parents\" in\n\t\t\t*$new_p*)\n\t\t\t\t;; # do nothing; that parent is already there\n\t\t\t*)\n\t\t\t\tnew_parents=\"$new_parents $new_p\"\n\t\t\t\t;;\n\t\t\tesac\n\t\telse\n\t\t\tif test -f \"$dropped\"/$p\n\t\t\tthen\n\t\t\t\tfast_forward=f\n\t\t\t\treplacement=\"$(cat \"$dropped\"/$p)\"\n\t\t\t\ttest -z \"$replacement\" && replacement=root\n\t\t\t\tpend=\" $replacement$pend\"\n\t\t\telse\n\t\t\t\tnew_parents=\"$new_parents $p\"\n\t\t\tfi\n\t\tfi\n\tdone\n\tcase $fast_forward in\n\tt)\n\t\toutput warn \"Fast-forward to $sha1\"\n\t\toutput git reset --hard $sha1 ||\n\t\t\tdie \"Cannot fast-forward to $sha1\"\n\t\t;;\n\tf)\n\t\tfirst_parent=$(expr \"$new_parents\" : ' \\([^ ]*\\)')\n\n\t\tif [ \"$1\" != \"-n\" ]\n\t\tthen\n\t\t\t# detach HEAD to current parent\n\t\t\toutput git checkout $first_parent 2> /dev/null ||\n\t\t\t\tdie \"Cannot move HEAD to $first_parent\"\n\t\tfi\n\n\t\tcase \"$new_parents\" in\n\t\t' '*' '*)\n\t\t\ttest \"a$1\" = a-n && die \"Refusing to squash a merge: $sha1\"\n\n\t\t\t# redo merge\n\t\t\tauthor_script_content=$(get_author_ident_from_commit $sha1)\n\t\t\teval \"$author_script_content\"\n\t\t\tmsg_content=\"$(commit_message $sha1)\"\n\t\t\t# No point in merging the first parent, that's HEAD\n\t\t\tnew_parents=${new_parents# $first_parent}\n\t\t\tmerge_args=\"--no-log --no-ff\"\n\t\t\tif ! do_with_author output eval \\\n\t\t\t'git merge ${gpg_sign_opt:+\"$gpg_sign_opt\"} \\\n\t\t\t\t$merge_args $strategy_args -m \"$msg_content\" $new_parents'\n\t\t\tthen\n\t\t\t\tprintf \"%s\\n\" \"$msg_content\" > \"$GIT_DIR\"/MERGE_MSG\n\t\t\t\tdie_with_patch $sha1 \"Error redoing merge $sha1\"\n\t\t\tfi\n\t\t\techo \"$sha1 $(git rev-parse HEAD^0)\" >> \"$rewritten_list\"\n\t\t\t;;\n\t\t*)\n\t\t\toutput eval git cherry-pick \\\n\t\t\t\t${gpg_sign_opt:+$(git rev-parse --sq-quote \"$gpg_sign_opt\")} \\\n\t\t\t\t\"$strategy_args\" \"$@\" ||\n\t\t\t\tdie_with_patch $sha1 \"Could not pick $sha1\"\n\t\t\t;;\n\t\tesac\n\t\t;;\n\tesac\n}\n\nnth_string () {\n\tcase \"$1\" in\n\t*1[0-9]|*[04-9]) echo \"$1\"th;;\n\t*1) echo \"$1\"st;;\n\t*2) echo \"$1\"nd;;\n\t*3) echo \"$1\"rd;;\n\tesac\n}\n\nupdate_squash_messages () {\n\tif test -f \"$squash_msg\"; then\n\t\tmv \"$squash_msg\" \"$squash_msg\".bak || exit\n\t\tcount=$(($(sed -n \\\n\t\t\t-e \"1s/^. This is a combination of \\(.*\\) commits\\./\\1/p\" \\\n\t\t\t-e \"q\" < \"$squash_msg\".bak)+1))\n\t\t{\n\t\t\tprintf '%s\\n' \"$comment_char This is a combination of $count commits.\"\n\t\t\tsed -e 1d -e '2,/^./{\n\t\t\t\t/^$/d\n\t\t\t}' <\"$squash_msg\".bak\n\t\t} >\"$squash_msg\"\n\telse\n\t\tcommit_message HEAD > \"$fixup_msg\" || die \"Cannot write $fixup_msg\"\n\t\tcount=2\n\t\t{\n\t\t\tprintf '%s\\n' \"$comment_char This is a combination of 2 commits.\"\n\t\t\tprintf '%s\\n' \"$comment_char The first commit's message is:\"\n\t\t\techo\n\t\t\tcat \"$fixup_msg\"\n\t\t} >\"$squash_msg\"\n\tfi\n\tcase $1 in\n\tsquash)\n\t\trm -f \"$fixup_msg\"\n\t\techo\n\t\tprintf '%s\\n' \"$comment_char This is the $(nth_string $count) commit message:\"\n\t\techo\n\t\tcommit_message $2\n\t\t;;\n\tfixup)\n\t\techo\n\t\tprintf '%s\\n' \"$comment_char The $(nth_string $count) commit message will be skipped:\"\n\t\techo\n\t\t# Change the space after the comment character to TAB:\n\t\tcommit_message $2 | git stripspace --comment-lines | sed -e 's/ /\t/'\n\t\t;;\n\tesac >>\"$squash_msg\"\n}\n\npeek_next_command () {\n\tgit stripspace --strip-comments <\"$todo\" | sed -n -e 's/ .*//p' -e q\n}\n\n# A squash/fixup has failed.  Prepare the long version of the squash\n# commit message, then die_with_patch.  This code path requires the\n# user to edit the combined commit message for all commits that have\n# been squashed/fixedup so far.  So also erase the old squash\n# messages, effectively causing the combined commit to be used as the\n# new basis for any further squash/fixups.  Args: sha1 rest\ndie_failed_squash() {\n\tmv \"$squash_msg\" \"$msg\" || exit\n\trm -f \"$fixup_msg\"\n\tcp \"$msg\" \"$GIT_DIR\"/MERGE_MSG || exit\n\twarn\n\twarn \"Could not apply $1... $2\"\n\tdie_with_patch $1 \"\"\n}\n\nflush_rewritten_pending() {\n\ttest -s \"$rewritten_pending\" || return\n\tnewsha1=\"$(git rev-parse HEAD^0)\"\n\tsed \"s/$/ $newsha1/\" < \"$rewritten_pending\" >> \"$rewritten_list\"\n\trm -f \"$rewritten_pending\"\n}\n\nrecord_in_rewritten() {\n\toldsha1=\"$(git rev-parse $1)\"\n\techo \"$oldsha1\" >> \"$rewritten_pending\"\n\n\tcase \"$(peek_next_command)\" in\n\tsquash|s|fixup|f)\n\t\t;;\n\t*)\n\t\tflush_rewritten_pending\n\t\t;;\n\tesac\n}\n\ndo_pick () {\n\tif test \"$(git rev-parse HEAD)\" = \"$squash_onto\"\n\tthen\n\t\t# Set the correct commit message and author info on the\n\t\t# sentinel root before cherry-picking the original changes\n\t\t# without committing (-n).  Finally, update the sentinel again\n\t\t# to include these changes.  If the cherry-pick results in a\n\t\t# conflict, this means our behaviour is similar to a standard\n\t\t# failed cherry-pick during rebase, with a dirty index to\n\t\t# resolve before manually running git commit --amend then git\n\t\t# rebase --continue.\n\t\tgit commit --allow-empty --allow-empty-message --amend \\\n\t\t\t   --no-post-rewrite -n -q -C $1 &&\n\t\t\tpick_one -n $1 &&\n\t\t\tgit commit --allow-empty --allow-empty-message \\\n\t\t\t\t   --amend --no-post-rewrite -n -q -C $1 \\\n\t\t\t\t   ${gpg_sign_opt:+\"$gpg_sign_opt\"} ||\n\t\t\tdie_with_patch $1 \"Could not apply $1... $2\"\n\telse\n\t\tpick_one $1 ||\n\t\t\tdie_with_patch $1 \"Could not apply $1... $2\"\n\tfi\n}\n\ndo_next () {\n\trm -f \"$msg\" \"$author_script\" \"$amend\" || exit\n\tread -r command sha1 rest < \"$todo\"\n\tcase \"$command\" in\n\t\"$comment_char\"*|''|noop)\n\t\tmark_action_done\n\t\t;;\n\tpick|p)\n\t\tcomment_for_reflog pick\n\n\t\tmark_action_done\n\t\tdo_pick $sha1 \"$rest\"\n\t\trecord_in_rewritten $sha1\n\t\t;;\n\treword|r)\n\t\tcomment_for_reflog reword\n\n\t\tmark_action_done\n\t\tdo_pick $sha1 \"$rest\"\n\t\tgit commit --amend --no-post-rewrite ${gpg_sign_opt:+\"$gpg_sign_opt\"} || {\n\t\t\twarn \"Could not amend commit after successfully picking $sha1... $rest\"\n\t\t\twarn \"This is most likely due to an empty commit message, or the pre-commit hook\"\n\t\t\twarn \"failed. If the pre-commit hook failed, you may need to resolve the issue before\"\n\t\t\twarn \"you are able to reword the commit.\"\n\t\t\texit_with_patch $sha1 1\n\t\t}\n\t\trecord_in_rewritten $sha1\n\t\t;;\n\tedit|e)\n\t\tcomment_for_reflog edit\n\n\t\tmark_action_done\n\t\tdo_pick $sha1 \"$rest\"\n\t\twarn \"Stopped at $sha1... $rest\"\n\t\texit_with_patch $sha1 0\n\t\t;;\n\tsquash|s|fixup|f)\n\t\tcase \"$command\" in\n\t\tsquash|s)\n\t\t\tsquash_style=squash\n\t\t\t;;\n\t\tfixup|f)\n\t\t\tsquash_style=fixup\n\t\t\t;;\n\t\tesac\n\t\tcomment_for_reflog $squash_style\n\n\t\ttest -f \"$done\" && has_action \"$done\" ||\n\t\t\tdie \"Cannot '$squash_style' without a previous commit\"\n\n\t\tmark_action_done\n\t\tupdate_squash_messages $squash_style $sha1\n\t\tauthor_script_content=$(get_author_ident_from_commit HEAD)\n\t\techo \"$author_script_content\" > \"$author_script\"\n\t\teval \"$author_script_content\"\n\t\tif ! pick_one -n $sha1\n\t\tthen\n\t\t\tgit rev-parse --verify HEAD >\"$amend\"\n\t\t\tdie_failed_squash $sha1 \"$rest\"\n\t\tfi\n\t\tcase \"$(peek_next_command)\" in\n\t\tsquash|s|fixup|f)\n\t\t\t# This is an intermediate commit; its message will only be\n\t\t\t# used in case of trouble.  So use the long version:\n\t\t\tdo_with_author output git commit --amend --no-verify -F \"$squash_msg\" \\\n\t\t\t\t${gpg_sign_opt:+\"$gpg_sign_opt\"} ||\n\t\t\t\tdie_failed_squash $sha1 \"$rest\"\n\t\t\t;;\n\t\t*)\n\t\t\t# This is the final command of this squash/fixup group\n\t\t\tif test -f \"$fixup_msg\"\n\t\t\tthen\n\t\t\t\tdo_with_author git commit --amend --no-verify -F \"$fixup_msg\" \\\n\t\t\t\t\t${gpg_sign_opt:+\"$gpg_sign_opt\"} ||\n\t\t\t\t\tdie_failed_squash $sha1 \"$rest\"\n\t\t\telse\n\t\t\t\tcp \"$squash_msg\" \"$GIT_DIR\"/SQUASH_MSG || exit\n\t\t\t\trm -f \"$GIT_DIR\"/MERGE_MSG\n\t\t\t\tdo_with_author git commit --amend --no-verify -F \"$GIT_DIR\"/SQUASH_MSG -e \\\n\t\t\t\t\t${gpg_sign_opt:+\"$gpg_sign_opt\"} ||\n\t\t\t\t\tdie_failed_squash $sha1 \"$rest\"\n\t\t\tfi\n\t\t\trm -f \"$squash_msg\" \"$fixup_msg\"\n\t\t\t;;\n\t\tesac\n\t\trecord_in_rewritten $sha1\n\t\t;;\n\tx|\"exec\")\n\t\tread -r command rest < \"$todo\"\n\t\tmark_action_done\n\t\tprintf 'Executing: %s\\n' \"$rest\"\n\t\t# \"exec\" command doesn't take a sha1 in the todo-list.\n\t\t# => can't just use $sha1 here.\n\t\tgit rev-parse --verify HEAD > \"$state_dir\"/stopped-sha\n\t\t${SHELL:-@SHELL_PATH@} -c \"$rest\" # Actual execution\n\t\tstatus=$?\n\t\t# Run in subshell because require_clean_work_tree can die.\n\t\tdirty=f\n\t\t(require_clean_work_tree \"rebase\" 2>/dev/null) || dirty=t\n\t\tif test \"$status\" -ne 0\n\t\tthen\n\t\t\twarn \"Execution failed: $rest\"\n\t\t\ttest \"$dirty\" = f ||\n\t\t\twarn \"and made changes to the index and/or the working tree\"\n\n\t\t\twarn \"You can fix the problem, and then run\"\n\t\t\twarn\n\t\t\twarn \"\tgit rebase --continue\"\n\t\t\twarn\n\t\t\tif test $status -eq 127\t\t# command not found\n\t\t\tthen\n\t\t\t\tstatus=1\n\t\t\tfi\n\t\t\texit \"$status\"\n\t\telif test \"$dirty\" = t\n\t\tthen\n\t\t\twarn \"Execution succeeded: $rest\"\n\t\t\twarn \"but left changes to the index and/or the working tree\"\n\t\t\twarn \"Commit or stash your changes, and then run\"\n\t\t\twarn\n\t\t\twarn \"\tgit rebase --continue\"\n\t\t\twarn\n\t\t\texit 1\n\t\tfi\n\t\t;;\n\t*)\n\t\twarn \"Unknown command: $command $sha1 $rest\"\n\t\tfixtodo=\"Please fix this using 'git rebase --edit-todo'.\"\n\t\tif git rev-parse --verify -q \"$sha1\" >/dev/null\n\t\tthen\n\t\t\tdie_with_patch $sha1 \"$fixtodo\"\n\t\telse\n\t\t\tdie \"$fixtodo\"\n\t\tfi\n\t\t;;\n\tesac\n\ttest -s \"$todo\" && return\n\n\tcomment_for_reflog finish &&\n\tnewhead=$(git rev-parse HEAD) &&\n\tcase $head_name in\n\trefs/*)\n\t\tmessage=\"$GIT_REFLOG_ACTION: $head_name onto $onto\" &&\n\t\tgit update-ref -m \"$message\" $head_name $newhead $orig_head &&\n\t\tgit symbolic-ref \\\n\t\t  -m \"$GIT_REFLOG_ACTION: returning to $head_name\" \\\n\t\t  HEAD $head_name\n\t\t;;\n\tesac && {\n\t\ttest ! -f \"$state_dir\"/verbose ||\n\t\t\tgit diff-tree --stat $orig_head..HEAD\n\t} &&\n\t{\n\t\ttest -s \"$rewritten_list\" &&\n\t\tgit notes copy --for-rewrite=rebase < \"$rewritten_list\" ||\n\t\ttrue # we don't care if this copying failed\n\t} &&\n\tif test -x \"$GIT_DIR\"/hooks/post-rewrite &&\n\t\ttest -s \"$rewritten_list\"; then\n\t\t\"$GIT_DIR\"/hooks/post-rewrite rebase < \"$rewritten_list\"\n\t\ttrue # we don't care if this hook failed\n\tfi &&\n\twarn \"Successfully rebased and updated $head_name.\"\n\n\treturn 1 # not failure; just to break the do_rest loop\n}\n\n# can only return 0, when the infinite loop breaks\ndo_rest () {\n\twhile :\n\tdo\n\t\tdo_next || break\n\tdone\n}\n\n# skip picking commits whose parents are unchanged\nskip_unnecessary_picks () {\n\tfd=3\n\twhile read -r command rest\n\tdo\n\t\t# fd=3 means we skip the command\n\t\tcase \"$fd,$command\" in\n\t\t3,pick|3,p)\n\t\t\t# pick a commit whose parent is current $onto -> skip\n\t\t\tsha1=${rest%% *}\n\t\t\tcase \"$(git rev-parse --verify --quiet \"$sha1\"^)\" in\n\t\t\t\"$onto\"*)\n\t\t\t\tonto=$sha1\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tfd=1\n\t\t\t\t;;\n\t\t\tesac\n\t\t\t;;\n\t\t3,\"$comment_char\"*|3,)\n\t\t\t# copy comments\n\t\t\t;;\n\t\t*)\n\t\t\tfd=1\n\t\t\t;;\n\t\tesac\n\t\tprintf '%s\\n' \"$command${rest:+ }$rest\" >&$fd\n\tdone <\"$todo\" >\"$todo.new\" 3>>\"$done\" &&\n\tmv -f \"$todo\".new \"$todo\" &&\n\tcase \"$(peek_next_command)\" in\n\tsquash|s|fixup|f)\n\t\trecord_in_rewritten \"$onto\"\n\t\t;;\n\tesac ||\n\tdie \"Could not skip unnecessary pick commands\"\n}\n\ntransform_todo_ids () {\n\twhile read -r command rest\n\tdo\n\t\tcase \"$command\" in\n\t\t\"$comment_char\"* | exec)\n\t\t\t# Be careful for oddball commands like 'exec'\n\t\t\t# that do not have a SHA-1 at the beginning of $rest.\n\t\t\t;;\n\t\t*)\n\t\t\tsha1=$(git rev-parse --verify --quiet \"$@\" ${rest%% *}) &&\n\t\t\trest=\"$sha1 ${rest#* }\"\n\t\t\t;;\n\t\tesac\n\t\tprintf '%s\\n' \"$command${rest:+ }$rest\"\n\tdone <\"$todo\" >\"$todo.new\" &&\n\tmv -f \"$todo.new\" \"$todo\"\n}\n\nexpand_todo_ids() {\n\ttransform_todo_ids\n}\n\ncollapse_todo_ids() {\n\ttransform_todo_ids --short\n}\n\n# Rearrange the todo list that has both \"pick sha1 msg\" and\n# \"pick sha1 fixup!/squash! msg\" appears in it so that the latter\n# comes immediately after the former, and change \"pick\" to\n# \"fixup\"/\"squash\".\nrearrange_squash () {\n\t# extract fixup!/squash! lines and resolve any referenced sha1's\n\twhile read -r pick sha1 message\n\tdo\n\t\tcase \"$message\" in\n\t\t\"squash! \"*|\"fixup! \"*)\n\t\t\taction=\"${message%%!*}\"\n\t\t\trest=$message\n\t\t\tprefix=\n\t\t\t# skip all squash! or fixup! (but save for later)\n\t\t\twhile :\n\t\t\tdo\n\t\t\t\tcase \"$rest\" in\n\t\t\t\t\"squash! \"*|\"fixup! \"*)\n\t\t\t\t\tprefix=\"$prefix${rest%%!*},\"\n\t\t\t\t\trest=\"${rest#*! }\"\n\t\t\t\t\t;;\n\t\t\t\t*)\n\t\t\t\t\tbreak\n\t\t\t\t\t;;\n\t\t\t\tesac\n\t\t\tdone\n\t\t\tprintf '%s %s %s %s\\n' \"$sha1\" \"$action\" \"$prefix\" \"$rest\"\n\t\t\t# if it's a single word, try to resolve to a full sha1 and\n\t\t\t# emit a second copy. This allows us to match on both message\n\t\t\t# and on sha1 prefix\n\t\t\tif test \"${rest#* }\" = \"$rest\"; then\n\t\t\t\tfullsha=\"$(git rev-parse -q --verify \"$rest\" 2>/dev/null)\"\n\t\t\t\tif test -n \"$fullsha\"; then\n\t\t\t\t\t# prefix the action to uniquely identify this line as\n\t\t\t\t\t# intended for full sha1 match\n\t\t\t\t\techo \"$sha1 +$action $prefix $fullsha\"\n\t\t\t\tfi\n\t\t\tfi\n\t\tesac\n\tdone >\"$1.sq\" <\"$1\"\n\ttest -s \"$1.sq\" || return\n\n\tused=\n\twhile read -r pick sha1 message\n\tdo\n\t\tcase \" $used\" in\n\t\t*\" $sha1 \"*) continue ;;\n\t\tesac\n\t\tprintf '%s\\n' \"$pick $sha1 $message\"\n\t\tused=\"$used$sha1 \"\n\t\twhile read -r squash action msg_prefix msg_content\n\t\tdo\n\t\t\tcase \" $used\" in\n\t\t\t*\" $squash \"*) continue ;;\n\t\t\tesac\n\t\t\temit=0\n\t\t\tcase \"$action\" in\n\t\t\t+*)\n\t\t\t\taction=\"${action#+}\"\n\t\t\t\t# full sha1 prefix test\n\t\t\t\tcase \"$msg_content\" in \"$sha1\"*) emit=1;; esac ;;\n\t\t\t*)\n\t\t\t\t# message prefix test\n\t\t\t\tcase \"$message\" in \"$msg_content\"*) emit=1;; esac ;;\n\t\t\tesac\n\t\t\tif test $emit = 1; then\n\t\t\t\treal_prefix=$(echo \"$msg_prefix\" | sed \"s/,/! /g\")\n\t\t\t\tprintf '%s\\n' \"$action $squash ${real_prefix}$msg_content\"\n\t\t\t\tused=\"$used$squash \"\n\t\t\tfi\n\t\tdone <\"$1.sq\"\n\tdone >\"$1.rearranged\" <\"$1\"\n\tcat \"$1.rearranged\" >\"$1\"\n\trm -f \"$1.sq\" \"$1.rearranged\"\n}\n\n# Add commands after a pick or after a squash/fixup serie\n# in the todo list.\nadd_exec_commands () {\n\t{\n\t\tfirst=t\n\t\twhile read -r insn rest\n\t\tdo\n\t\t\tcase $insn in\n\t\t\tpick)\n\t\t\t\ttest -n \"$first\" ||\n\t\t\t\tprintf \"%s\" \"$cmd\"\n\t\t\t\t;;\n\t\t\tesac\n\t\t\tprintf \"%s %s\\n\" \"$insn\" \"$rest\"\n\t\t\tfirst=\n\t\tdone\n\t\tprintf \"%s\" \"$cmd\"\n\t} <\"$1\" >\"$1.new\" &&\n\tmv \"$1.new\" \"$1\"\n}\n\n# The whole contents of this file is run by dot-sourcing it from\n# inside a shell function.  It used to be that \"return\"s we see\n# below were not inside any function, and expected to return\n# to the function that dot-sourced us.\n#\n# However, FreeBSD /bin/sh misbehaves on such a construct and\n# continues to run the statements that follow such a \"return\".\n# As a work-around, we introduce an extra layer of a function\n# here, and immediately call it after defining it.\ngit_rebase__interactive () {\n\ncase \"$action\" in\ncontinue)\n\t# do we have anything to commit?\n\tif git diff-index --cached --quiet HEAD --\n\tthen\n\t\t: Nothing to commit -- skip this\n\telse\n\t\tif ! test -f \"$author_script\"\n\t\tthen\n\t\t\tgpg_sign_opt_quoted=${gpg_sign_opt:+$(git rev-parse --sq-quote \"$gpg_sign_opt\")}\n\t\t\tdie \"You have staged changes in your working tree. If these changes are meant to be\nsquashed into the previous commit, run:\n\n  git commit --amend $gpg_sign_opt_quoted\n\nIf they are meant to go into a new commit, run:\n\n  git commit $gpg_sign_opt_quoted\n\nIn both case, once you're done, continue with:\n\n  git rebase --continue\n\"\n\t\tfi\n\t\t. \"$author_script\" ||\n\t\t\tdie \"Error trying to find the author identity to amend commit\"\n\t\tif test -f \"$amend\"\n\t\tthen\n\t\t\tcurrent_head=$(git rev-parse --verify HEAD)\n\t\t\ttest \"$current_head\" = $(cat \"$amend\") ||\n\t\t\tdie \"\\\nYou have uncommitted changes in your working tree. Please, commit them\nfirst and then run 'git rebase --continue' again.\"\n\t\t\tdo_with_author git commit --amend --no-verify -F \"$msg\" -e \\\n\t\t\t\t${gpg_sign_opt:+\"$gpg_sign_opt\"} ||\n\t\t\t\tdie \"Could not commit staged changes.\"\n\t\telse\n\t\t\tdo_with_author git commit --no-verify -F \"$msg\" -e \\\n\t\t\t\t${gpg_sign_opt:+\"$gpg_sign_opt\"} ||\n\t\t\t\tdie \"Could not commit staged changes.\"\n\t\tfi\n\tfi\n\n\trecord_in_rewritten \"$(cat \"$state_dir\"/stopped-sha)\"\n\n\trequire_clean_work_tree \"rebase\"\n\tdo_rest\n\treturn 0\n\t;;\nskip)\n\tgit rerere clear\n\n\tdo_rest\n\treturn 0\n\t;;\nedit-todo)\n\tgit stripspace --strip-comments <\"$todo\" >\"$todo\".new\n\tmv -f \"$todo\".new \"$todo\"\n\tcollapse_todo_ids\n\tappend_todo_help\n\tgit stripspace --comment-lines >>\"$todo\" <<\\EOF\n\nYou are editing the todo file of an ongoing interactive rebase.\nTo continue rebase after editing, run:\n    git rebase --continue\n\nEOF\n\n\tgit_sequence_editor \"$todo\" ||\n\t\tdie \"Could not execute editor\"\n\texpand_todo_ids\n\n\texit\n\t;;\nesac\n\ngit var GIT_COMMITTER_IDENT >/dev/null ||\n\tdie \"You need to set your committer info first\"\n\ncomment_for_reflog start\n\nif test ! -z \"$switch_to\"\nthen\n\tGIT_REFLOG_ACTION=\"$GIT_REFLOG_ACTION: checkout $switch_to\"\n\toutput git checkout \"$switch_to\" -- ||\n\tdie \"Could not checkout $switch_to\"\n\n\tcomment_for_reflog start\nfi\n\norig_head=$(git rev-parse --verify HEAD) || die \"No HEAD?\"\nmkdir -p \"$state_dir\" || die \"Could not create temporary $state_dir\"\n\n: > \"$state_dir\"/interactive || die \"Could not mark as interactive\"\nwrite_basic_state\nif test t = \"$preserve_merges\"\nthen\n\tif test -z \"$rebase_root\"\n\tthen\n\t\tmkdir \"$rewritten\" &&\n\t\tfor c in $(git merge-base --all $orig_head $upstream)\n\t\tdo\n\t\t\techo $onto > \"$rewritten\"/$c ||\n\t\t\t\tdie \"Could not init rewritten commits\"\n\t\tdone\n\telse\n\t\tmkdir \"$rewritten\" &&\n\t\techo $onto > \"$rewritten\"/root ||\n\t\t\tdie \"Could not init rewritten commits\"\n\tfi\n\t# No cherry-pick because our first pass is to determine\n\t# parents to rewrite and skipping dropped commits would\n\t# prematurely end our probe\n\tmerges_option=\nelse\n\tmerges_option=\"--no-merges --cherry-pick\"\nfi\n\nshorthead=$(git rev-parse --short $orig_head)\nshortonto=$(git rev-parse --short $onto)\nif test -z \"$rebase_root\"\n\t# this is now equivalent to ! -z \"$upstream\"\nthen\n\tshortupstream=$(git rev-parse --short $upstream)\n\trevisions=$upstream...$orig_head\n\tshortrevisions=$shortupstream..$shorthead\nelse\n\trevisions=$onto...$orig_head\n\tshortrevisions=$shorthead\nfi\ngit rev-list $merges_option --pretty=oneline --reverse --left-right --topo-order \\\n\t$revisions ${restrict_revision+^$restrict_revision} | \\\n\tsed -n \"s/^>//p\" |\nwhile read -r sha1 rest\ndo\n\n\tif test -z \"$keep_empty\" && is_empty_commit $sha1 && ! is_merge_commit $sha1\n\tthen\n\t\tcomment_out=\"$comment_char \"\n\telse\n\t\tcomment_out=\n\tfi\n\n\tif test t != \"$preserve_merges\"\n\tthen\n\t\tprintf '%s\\n' \"${comment_out}pick $sha1 $rest\" >>\"$todo\"\n\telse\n\t\tif test -z \"$rebase_root\"\n\t\tthen\n\t\t\tpreserve=t\n\t\t\tfor p in $(git rev-list --parents -1 $sha1 | cut -d' ' -s -f2-)\n\t\t\tdo\n\t\t\t\tif test -f \"$rewritten\"/$p\n\t\t\t\tthen\n\t\t\t\t\tpreserve=f\n\t\t\t\tfi\n\t\t\tdone\n\t\telse\n\t\t\tpreserve=f\n\t\tfi\n\t\tif test f = \"$preserve\"\n\t\tthen\n\t\t\ttouch \"$rewritten\"/$sha1\n\t\t\tprintf '%s\\n' \"${comment_out}pick $sha1 $rest\" >>\"$todo\"\n\t\tfi\n\tfi\ndone\n\n# Watch for commits that been dropped by --cherry-pick\nif test t = \"$preserve_merges\"\nthen\n\tmkdir \"$dropped\"\n\t# Save all non-cherry-picked changes\n\tgit rev-list $revisions --left-right --cherry-pick | \\\n\t\tsed -n \"s/^>//p\" > \"$state_dir\"/not-cherry-picks\n\t# Now all commits and note which ones are missing in\n\t# not-cherry-picks and hence being dropped\n\tgit rev-list $revisions |\n\twhile read rev\n\tdo\n\t\tif test -f \"$rewritten\"/$rev && test \"$(sane_grep \"$rev\" \"$state_dir\"/not-cherry-picks)\" = \"\"\n\t\tthen\n\t\t\t# Use -f2 because if rev-list is telling us this commit is\n\t\t\t# not worthwhile, we don't want to track its multiple heads,\n\t\t\t# just the history of its first-parent for others that will\n\t\t\t# be rebasing on top of it\n\t\t\tgit rev-list --parents -1 $rev | cut -d' ' -s -f2 > \"$dropped\"/$rev\n\t\t\tsha1=$(git rev-list -1 $rev)\n\t\t\tsane_grep -v \"^[a-z][a-z]* $sha1\" <\"$todo\" > \"${todo}2\" ; mv \"${todo}2\" \"$todo\"\n\t\t\trm \"$rewritten\"/$rev\n\t\tfi\n\tdone\nfi\n\ntest -s \"$todo\" || echo noop >> \"$todo\"\ntest -n \"$autosquash\" && rearrange_squash \"$todo\"\ntest -n \"$cmd\" && add_exec_commands \"$todo\"\n\ntodocount=$(git stripspace --strip-comments <\"$todo\" | wc -l)\ntodocount=${todocount##* }\n\ncat >>\"$todo\" <<EOF\n\n$comment_char Rebase $shortrevisions onto $shortonto ($todocount command(s))\nEOF\nappend_todo_help\ngit stripspace --comment-lines >>\"$todo\" <<\\EOF\n\nHowever, if you remove everything, the rebase will be aborted.\n\nEOF\n\nif test -z \"$keep_empty\"\nthen\n\tprintf '%s\\n' \"$comment_char Note that empty commits are commented out\" >>\"$todo\"\nfi\n\n\nhas_action \"$todo\" ||\n\treturn 2\n\ncp \"$todo\" \"$todo\".backup\ncollapse_todo_ids\ngit_sequence_editor \"$todo\" ||\n\tdie_abort \"Could not execute editor\"\n\nhas_action \"$todo\" ||\n\treturn 2\n\nexpand_todo_ids\n\ntest -d \"$rewritten\" || test -n \"$force_rebase\" || skip_unnecessary_picks\n\nGIT_REFLOG_ACTION=\"$GIT_REFLOG_ACTION: checkout $onto_name\"\noutput git checkout $onto || die_abort \"could not detach HEAD\"\ngit update-ref ORIG_HEAD $orig_head\ndo_rest\n\n}\n# ... and then we call the whole thing.\ngit_rebase__interactive\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00080572529ae4c7e0c86c0aa2ba7cb83146dd2a",
  "sha1_ok": true,
  "size": 29083
}
