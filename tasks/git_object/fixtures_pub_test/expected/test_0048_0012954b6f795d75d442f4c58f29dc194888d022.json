{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJyZW1vdGUuaCIKI2luY2x1ZGUgInJlZnMuaCIKCnN0cnVjdCByZXdyaXRlIHsKCWNvbnN0IGNoYXIgKmJhc2U7Cgljb25zdCBjaGFyICoqaW5zdGVhZF9vZjsKCWludCBpbnN0ZWFkX29mX25yOwoJaW50IGluc3RlYWRfb2ZfYWxsb2M7Cn07CgpzdGF0aWMgc3RydWN0IHJlbW90ZSAqKnJlbW90ZXM7CnN0YXRpYyBpbnQgcmVtb3Rlc19hbGxvYzsKc3RhdGljIGludCByZW1vdGVzX25yOwoKc3RhdGljIHN0cnVjdCBicmFuY2ggKipicmFuY2hlczsKc3RhdGljIGludCBicmFuY2hlc19hbGxvYzsKc3RhdGljIGludCBicmFuY2hlc19ucjsKCnN0YXRpYyBzdHJ1Y3QgYnJhbmNoICpjdXJyZW50X2JyYW5jaDsKc3RhdGljIGNvbnN0IGNoYXIgKmRlZmF1bHRfcmVtb3RlX25hbWU7CgpzdGF0aWMgc3RydWN0IHJld3JpdGUgKipyZXdyaXRlOwpzdGF0aWMgaW50IHJld3JpdGVfYWxsb2M7CnN0YXRpYyBpbnQgcmV3cml0ZV9ucjsKCiNkZWZpbmUgQlVGX1NJWkUgKDIwNDgpCnN0YXRpYyBjaGFyIGJ1ZmZlcltCVUZfU0laRV07CgpzdGF0aWMgY29uc3QgY2hhciAqYWxpYXNfdXJsKGNvbnN0IGNoYXIgKnVybCkKewoJaW50IGksIGo7Cglmb3IgKGkgPSAwOyBpIDwgcmV3cml0ZV9ucjsgaSsrKSB7CgkJaWYgKCFyZXdyaXRlW2ldKQoJCQljb250aW51ZTsKCQlmb3IgKGogPSAwOyBqIDwgcmV3cml0ZVtpXS0+aW5zdGVhZF9vZl9ucjsgaisrKSB7CgkJCWlmICghcHJlZml4Y21wKHVybCwgcmV3cml0ZVtpXS0+aW5zdGVhZF9vZltqXSkpIHsKCQkJCWNoYXIgKnJldCA9IG1hbGxvYyhzdHJsZW4ocmV3cml0ZVtpXS0+YmFzZSkgLQoJCQkJCQkgICBzdHJsZW4ocmV3cml0ZVtpXS0+aW5zdGVhZF9vZltqXSkgKwoJCQkJCQkgICBzdHJsZW4odXJsKSArIDEpOwoJCQkJc3RyY3B5KHJldCwgcmV3cml0ZVtpXS0+YmFzZSk7CgkJCQlzdHJjYXQocmV0LCB1cmwgKyBzdHJsZW4ocmV3cml0ZVtpXS0+aW5zdGVhZF9vZltqXSkpOwoJCQkJcmV0dXJuIHJldDsKCQkJfQoJCX0KCX0KCXJldHVybiB1cmw7Cn0KCnN0YXRpYyB2b2lkIGFkZF9wdXNoX3JlZnNwZWMoc3RydWN0IHJlbW90ZSAqcmVtb3RlLCBjb25zdCBjaGFyICpyZWYpCnsKCUFMTE9DX0dST1cocmVtb3RlLT5wdXNoX3JlZnNwZWMsCgkJICAgcmVtb3RlLT5wdXNoX3JlZnNwZWNfbnIgKyAxLAoJCSAgIHJlbW90ZS0+cHVzaF9yZWZzcGVjX2FsbG9jKTsKCXJlbW90ZS0+cHVzaF9yZWZzcGVjW3JlbW90ZS0+cHVzaF9yZWZzcGVjX25yKytdID0gcmVmOwp9CgpzdGF0aWMgdm9pZCBhZGRfZmV0Y2hfcmVmc3BlYyhzdHJ1Y3QgcmVtb3RlICpyZW1vdGUsIGNvbnN0IGNoYXIgKnJlZikKewoJQUxMT0NfR1JPVyhyZW1vdGUtPmZldGNoX3JlZnNwZWMsCgkJICAgcmVtb3RlLT5mZXRjaF9yZWZzcGVjX25yICsgMSwKCQkgICByZW1vdGUtPmZldGNoX3JlZnNwZWNfYWxsb2MpOwoJcmVtb3RlLT5mZXRjaF9yZWZzcGVjW3JlbW90ZS0+ZmV0Y2hfcmVmc3BlY19ucisrXSA9IHJlZjsKfQoKc3RhdGljIHZvaWQgYWRkX3VybChzdHJ1Y3QgcmVtb3RlICpyZW1vdGUsIGNvbnN0IGNoYXIgKnVybCkKewoJQUxMT0NfR1JPVyhyZW1vdGUtPnVybCwgcmVtb3RlLT51cmxfbnIgKyAxLCByZW1vdGUtPnVybF9hbGxvYyk7CglyZW1vdGUtPnVybFtyZW1vdGUtPnVybF9ucisrXSA9IHVybDsKfQoKc3RhdGljIHZvaWQgYWRkX3VybF9hbGlhcyhzdHJ1Y3QgcmVtb3RlICpyZW1vdGUsIGNvbnN0IGNoYXIgKnVybCkKewoJYWRkX3VybChyZW1vdGUsIGFsaWFzX3VybCh1cmwpKTsKfQoKc3RhdGljIHN0cnVjdCByZW1vdGUgKm1ha2VfcmVtb3RlKGNvbnN0IGNoYXIgKm5hbWUsIGludCBsZW4pCnsKCXN0cnVjdCByZW1vdGUgKnJldDsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCByZW1vdGVzX25yOyBpKyspIHsKCQlpZiAobGVuID8gKCFzdHJuY21wKG5hbWUsIHJlbW90ZXNbaV0tPm5hbWUsIGxlbikgJiYKCQkJICAgIXJlbW90ZXNbaV0tPm5hbWVbbGVuXSkgOgoJCSAgICAhc3RyY21wKG5hbWUsIHJlbW90ZXNbaV0tPm5hbWUpKQoJCQlyZXR1cm4gcmVtb3Rlc1tpXTsKCX0KCglyZXQgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3QgcmVtb3RlKSk7CglBTExPQ19HUk9XKHJlbW90ZXMsIHJlbW90ZXNfbnIgKyAxLCByZW1vdGVzX2FsbG9jKTsKCXJlbW90ZXNbcmVtb3Rlc19ucisrXSA9IHJldDsKCWlmIChsZW4pCgkJcmV0LT5uYW1lID0geHN0cm5kdXAobmFtZSwgbGVuKTsKCWVsc2UKCQlyZXQtPm5hbWUgPSB4c3RyZHVwKG5hbWUpOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIHZvaWQgYWRkX21lcmdlKHN0cnVjdCBicmFuY2ggKmJyYW5jaCwgY29uc3QgY2hhciAqbmFtZSkKewoJQUxMT0NfR1JPVyhicmFuY2gtPm1lcmdlX25hbWUsIGJyYW5jaC0+bWVyZ2VfbnIgKyAxLAoJCSAgIGJyYW5jaC0+bWVyZ2VfYWxsb2MpOwoJYnJhbmNoLT5tZXJnZV9uYW1lW2JyYW5jaC0+bWVyZ2VfbnIrK10gPSBuYW1lOwp9CgpzdGF0aWMgc3RydWN0IGJyYW5jaCAqbWFrZV9icmFuY2goY29uc3QgY2hhciAqbmFtZSwgaW50IGxlbikKewoJc3RydWN0IGJyYW5jaCAqcmV0OwoJaW50IGk7CgljaGFyICpyZWZuYW1lOwoKCWZvciAoaSA9IDA7IGkgPCBicmFuY2hlc19ucjsgaSsrKSB7CgkJaWYgKGxlbiA/ICghc3RybmNtcChuYW1lLCBicmFuY2hlc1tpXS0+bmFtZSwgbGVuKSAmJgoJCQkgICAhYnJhbmNoZXNbaV0tPm5hbWVbbGVuXSkgOgoJCSAgICAhc3RyY21wKG5hbWUsIGJyYW5jaGVzW2ldLT5uYW1lKSkKCQkJcmV0dXJuIGJyYW5jaGVzW2ldOwoJfQoKCUFMTE9DX0dST1coYnJhbmNoZXMsIGJyYW5jaGVzX25yICsgMSwgYnJhbmNoZXNfYWxsb2MpOwoJcmV0ID0geGNhbGxvYygxLCBzaXplb2Yoc3RydWN0IGJyYW5jaCkpOwoJYnJhbmNoZXNbYnJhbmNoZXNfbnIrK10gPSByZXQ7CglpZiAobGVuKQoJCXJldC0+bmFtZSA9IHhzdHJuZHVwKG5hbWUsIGxlbik7CgllbHNlCgkJcmV0LT5uYW1lID0geHN0cmR1cChuYW1lKTsKCXJlZm5hbWUgPSBtYWxsb2Moc3RybGVuKG5hbWUpICsgc3RybGVuKCJyZWZzL2hlYWRzLyIpICsgMSk7CglzdHJjcHkocmVmbmFtZSwgInJlZnMvaGVhZHMvIik7CglzdHJjcHkocmVmbmFtZSArIHN0cmxlbigicmVmcy9oZWFkcy8iKSwgcmV0LT5uYW1lKTsKCXJldC0+cmVmbmFtZSA9IHJlZm5hbWU7CgoJcmV0dXJuIHJldDsKfQoKc3RhdGljIHN0cnVjdCByZXdyaXRlICptYWtlX3Jld3JpdGUoY29uc3QgY2hhciAqYmFzZSwgaW50IGxlbikKewoJc3RydWN0IHJld3JpdGUgKnJldDsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCByZXdyaXRlX25yOyBpKyspIHsKCQlpZiAobGVuID8gKCFzdHJuY21wKGJhc2UsIHJld3JpdGVbaV0tPmJhc2UsIGxlbikgJiYKCQkJICAgIXJld3JpdGVbaV0tPmJhc2VbbGVuXSkgOgoJCSAgICAhc3RyY21wKGJhc2UsIHJld3JpdGVbaV0tPmJhc2UpKQoJCQlyZXR1cm4gcmV3cml0ZVtpXTsKCX0KCglBTExPQ19HUk9XKHJld3JpdGUsIHJld3JpdGVfbnIgKyAxLCByZXdyaXRlX2FsbG9jKTsKCXJldCA9IHhjYWxsb2MoMSwgc2l6ZW9mKHN0cnVjdCByZXdyaXRlKSk7CglyZXdyaXRlW3Jld3JpdGVfbnIrK10gPSByZXQ7CglpZiAobGVuKQoJCXJldC0+YmFzZSA9IHhzdHJuZHVwKGJhc2UsIGxlbik7CgllbHNlCgkJcmV0LT5iYXNlID0geHN0cmR1cChiYXNlKTsKCglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgdm9pZCBhZGRfaW5zdGVhZF9vZihzdHJ1Y3QgcmV3cml0ZSAqcmV3cml0ZSwgY29uc3QgY2hhciAqaW5zdGVhZF9vZikKewoJQUxMT0NfR1JPVyhyZXdyaXRlLT5pbnN0ZWFkX29mLCByZXdyaXRlLT5pbnN0ZWFkX29mX25yICsgMSwgcmV3cml0ZS0+aW5zdGVhZF9vZl9hbGxvYyk7CglyZXdyaXRlLT5pbnN0ZWFkX29mW3Jld3JpdGUtPmluc3RlYWRfb2ZfbnIrK10gPSBpbnN0ZWFkX29mOwp9CgpzdGF0aWMgdm9pZCByZWFkX3JlbW90ZXNfZmlsZShzdHJ1Y3QgcmVtb3RlICpyZW1vdGUpCnsKCUZJTEUgKmYgPSBmb3BlbihnaXRfcGF0aCgicmVtb3Rlcy8lcyIsIHJlbW90ZS0+bmFtZSksICJyIik7CgoJaWYgKCFmKQoJCXJldHVybjsKCXdoaWxlIChmZ2V0cyhidWZmZXIsIEJVRl9TSVpFLCBmKSkgewoJCWludCB2YWx1ZV9saXN0OwoJCWNoYXIgKnMsICpwOwoKCQlpZiAoIXByZWZpeGNtcChidWZmZXIsICJVUkw6IikpIHsKCQkJdmFsdWVfbGlzdCA9IDA7CgkJCXMgPSBidWZmZXIgKyA0OwoJCX0gZWxzZSBpZiAoIXByZWZpeGNtcChidWZmZXIsICJQdXNoOiIpKSB7CgkJCXZhbHVlX2xpc3QgPSAxOwoJCQlzID0gYnVmZmVyICsgNTsKCQl9IGVsc2UgaWYgKCFwcmVmaXhjbXAoYnVmZmVyLCAiUHVsbDoiKSkgewoJCQl2YWx1ZV9saXN0ID0gMjsKCQkJcyA9IGJ1ZmZlciArIDU7CgkJfSBlbHNlCgkJCWNvbnRpbnVlOwoKCQl3aGlsZSAoaXNzcGFjZSgqcykpCgkJCXMrKzsKCQlpZiAoISpzKQoJCQljb250aW51ZTsKCgkJcCA9IHMgKyBzdHJsZW4ocyk7CgkJd2hpbGUgKGlzc3BhY2UocFstMV0pKQoJCQkqLS1wID0gMDsKCgkJc3dpdGNoICh2YWx1ZV9saXN0KSB7CgkJY2FzZSAwOgoJCQlhZGRfdXJsX2FsaWFzKHJlbW90ZSwgeHN0cmR1cChzKSk7CgkJCWJyZWFrOwoJCWNhc2UgMToKCQkJYWRkX3B1c2hfcmVmc3BlYyhyZW1vdGUsIHhzdHJkdXAocykpOwoJCQlicmVhazsKCQljYXNlIDI6CgkJCWFkZF9mZXRjaF9yZWZzcGVjKHJlbW90ZSwgeHN0cmR1cChzKSk7CgkJCWJyZWFrOwoJCX0KCX0KCWZjbG9zZShmKTsKfQoKc3RhdGljIHZvaWQgcmVhZF9icmFuY2hlc19maWxlKHN0cnVjdCByZW1vdGUgKnJlbW90ZSkKewoJY29uc3QgY2hhciAqc2xhc2ggPSBzdHJjaHIocmVtb3RlLT5uYW1lLCAnLycpOwoJY2hhciAqZnJhZzsKCWNoYXIgKmJyYW5jaDsKCWludCBuID0gc2xhc2ggPyBzbGFzaCAtIHJlbW90ZS0+bmFtZSA6IDEwMDA7CglGSUxFICpmID0gZm9wZW4oZ2l0X3BhdGgoImJyYW5jaGVzLyUuKnMiLCBuLCByZW1vdGUtPm5hbWUpLCAiciIpOwoJY2hhciAqcywgKnA7CglpbnQgbGVuOwoKCWlmICghZikKCQlyZXR1cm47CglzID0gZmdldHMoYnVmZmVyLCBCVUZfU0laRSwgZik7CglmY2xvc2UoZik7CglpZiAoIXMpCgkJcmV0dXJuOwoJd2hpbGUgKGlzc3BhY2UoKnMpKQoJCXMrKzsKCWlmICghKnMpCgkJcmV0dXJuOwoJcCA9IHMgKyBzdHJsZW4ocyk7Cgl3aGlsZSAoaXNzcGFjZShwWy0xXSkpCgkJKi0tcCA9IDA7CglsZW4gPSBwIC0gczsKCWlmIChzbGFzaCkKCQlsZW4gKz0gc3RybGVuKHNsYXNoKTsKCXAgPSB4bWFsbG9jKGxlbiArIDEpOwoJc3RyY3B5KHAsIHMpOwoJaWYgKHNsYXNoKQoJCXN0cmNhdChwLCBzbGFzaCk7CglmcmFnID0gc3RyY2hyKHAsICcjJyk7CglpZiAoZnJhZykgewoJCSooZnJhZysrKSA9ICdcMCc7CgkJYnJhbmNoID0geG1hbGxvYyhzdHJsZW4oZnJhZykgKyAxMik7CgkJc3RyY3B5KGJyYW5jaCwgInJlZnMvaGVhZHMvIik7CgkJc3RyY2F0KGJyYW5jaCwgZnJhZyk7Cgl9IGVsc2UgewoJCWJyYW5jaCA9ICJyZWZzL2hlYWRzL21hc3RlciI7Cgl9CglhZGRfdXJsX2FsaWFzKHJlbW90ZSwgcCk7CglhZGRfZmV0Y2hfcmVmc3BlYyhyZW1vdGUsIGJyYW5jaCk7CglyZW1vdGUtPmZldGNoX3RhZ3MgPSAxOyAvKiBhbHdheXMgYXV0by1mb2xsb3cgKi8KfQoKc3RhdGljIGludCBoYW5kbGVfY29uZmlnKGNvbnN0IGNoYXIgKmtleSwgY29uc3QgY2hhciAqdmFsdWUpCnsKCWNvbnN0IGNoYXIgKm5hbWU7Cgljb25zdCBjaGFyICpzdWJrZXk7CglzdHJ1Y3QgcmVtb3RlICpyZW1vdGU7CglzdHJ1Y3QgYnJhbmNoICpicmFuY2g7CglpZiAoIXByZWZpeGNtcChrZXksICJicmFuY2guIikpIHsKCQluYW1lID0ga2V5ICsgNzsKCQlzdWJrZXkgPSBzdHJyY2hyKG5hbWUsICcuJyk7CgkJaWYgKCFzdWJrZXkpCgkJCXJldHVybiAwOwoJCWJyYW5jaCA9IG1ha2VfYnJhbmNoKG5hbWUsIHN1YmtleSAtIG5hbWUpOwoJCWlmICghc3RyY21wKHN1YmtleSwgIi5yZW1vdGUiKSkgewoJCQlpZiAoIXZhbHVlKQoJCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKGtleSk7CgkJCWJyYW5jaC0+cmVtb3RlX25hbWUgPSB4c3RyZHVwKHZhbHVlKTsKCQkJaWYgKGJyYW5jaCA9PSBjdXJyZW50X2JyYW5jaCkKCQkJCWRlZmF1bHRfcmVtb3RlX25hbWUgPSBicmFuY2gtPnJlbW90ZV9uYW1lOwoJCX0gZWxzZSBpZiAoIXN0cmNtcChzdWJrZXksICIubWVyZ2UiKSkgewoJCQlpZiAoIXZhbHVlKQoJCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKGtleSk7CgkJCWFkZF9tZXJnZShicmFuY2gsIHhzdHJkdXAodmFsdWUpKTsKCQl9CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXByZWZpeGNtcChrZXksICJ1cmwuIikpIHsKCQlzdHJ1Y3QgcmV3cml0ZSAqcmV3cml0ZTsKCQluYW1lID0ga2V5ICsgNTsKCQlzdWJrZXkgPSBzdHJyY2hyKG5hbWUsICcuJyk7CgkJaWYgKCFzdWJrZXkpCgkJCXJldHVybiAwOwoJCXJld3JpdGUgPSBtYWtlX3Jld3JpdGUobmFtZSwgc3Via2V5IC0gbmFtZSk7CgkJaWYgKCFzdHJjbXAoc3Via2V5LCAiLmluc3RlYWRvZiIpKSB7CgkJCWlmICghdmFsdWUpCgkJCQlyZXR1cm4gY29uZmlnX2Vycm9yX25vbmJvb2woa2V5KTsKCQkJYWRkX2luc3RlYWRfb2YocmV3cml0ZSwgeHN0cmR1cCh2YWx1ZSkpOwoJCX0KCX0KCWlmIChwcmVmaXhjbXAoa2V5LCAgInJlbW90ZS4iKSkKCQlyZXR1cm4gMDsKCW5hbWUgPSBrZXkgKyA3OwoJc3Via2V5ID0gc3RycmNocihuYW1lLCAnLicpOwoJaWYgKCFzdWJrZXkpCgkJcmV0dXJuIGVycm9yKCJDb25maWcgd2l0aCBubyBrZXkgZm9yIHJlbW90ZSAlcyIsIG5hbWUpOwoJaWYgKCpzdWJrZXkgPT0gJy8nKSB7CgkJd2FybmluZygiQ29uZmlnIHJlbW90ZSBzaG9ydGhhbmQgY2Fubm90IGJlZ2luIHdpdGggJy8nOiAlcyIsIG5hbWUpOwoJCXJldHVybiAwOwoJfQoJcmVtb3RlID0gbWFrZV9yZW1vdGUobmFtZSwgc3Via2V5IC0gbmFtZSk7CglpZiAoIXZhbHVlKSB7CgkJLyogaWYgd2UgZXZlciBoYXZlIGEgYm9vbGVhbiB2YXJpYWJsZSwgZS5nLiAicmVtb3RlLiouZGlzYWJsZWQiCgkJICogW3JlbW90ZSAiZnJvdHoiXQoJCSAqICAgICAgZGlzYWJsZWQKCQkgKiBpcyBhIHZhbGlkIHdheSB0byBzZXQgaXQgdG8gdHJ1ZTsgd2UgZ2V0IE5VTEwgaW4gdmFsdWUgc28KCQkgKiB3ZSBuZWVkIHRvIGhhbmRsZSBpdCBoZXJlLgoJCSAqCgkJICogaWYgKCFzdHJjbXAoc3Via2V5LCAiLmRpc2FibGVkIikpIHsKCQkgKiAgICAgIHZhbCA9IGdpdF9jb25maWdfYm9vbChrZXksIHZhbHVlKTsKCQkgKiAgICAgIHJldHVybiAwOwoJCSAqIH0gZWxzZQoJCSAqCgkJICovCgkJcmV0dXJuIDA7IC8qIGlnbm9yZSB1bmtub3duIGJvb2xlYW5zICovCgl9CglpZiAoIXN0cmNtcChzdWJrZXksICIudXJsIikpIHsKCQlhZGRfdXJsKHJlbW90ZSwgeHN0cmR1cCh2YWx1ZSkpOwoJfSBlbHNlIGlmICghc3RyY21wKHN1YmtleSwgIi5wdXNoIikpIHsKCQlhZGRfcHVzaF9yZWZzcGVjKHJlbW90ZSwgeHN0cmR1cCh2YWx1ZSkpOwoJfSBlbHNlIGlmICghc3RyY21wKHN1YmtleSwgIi5mZXRjaCIpKSB7CgkJYWRkX2ZldGNoX3JlZnNwZWMocmVtb3RlLCB4c3RyZHVwKHZhbHVlKSk7Cgl9IGVsc2UgaWYgKCFzdHJjbXAoc3Via2V5LCAiLnJlY2VpdmVwYWNrIikpIHsKCQlpZiAoIXJlbW90ZS0+cmVjZWl2ZXBhY2spCgkJCXJlbW90ZS0+cmVjZWl2ZXBhY2sgPSB4c3RyZHVwKHZhbHVlKTsKCQllbHNlCgkJCWVycm9yKCJtb3JlIHRoYW4gb25lIHJlY2VpdmVwYWNrIGdpdmVuLCB1c2luZyB0aGUgZmlyc3QiKTsKCX0gZWxzZSBpZiAoIXN0cmNtcChzdWJrZXksICIudXBsb2FkcGFjayIpKSB7CgkJaWYgKCFyZW1vdGUtPnVwbG9hZHBhY2spCgkJCXJlbW90ZS0+dXBsb2FkcGFjayA9IHhzdHJkdXAodmFsdWUpOwoJCWVsc2UKCQkJZXJyb3IoIm1vcmUgdGhhbiBvbmUgdXBsb2FkcGFjayBnaXZlbiwgdXNpbmcgdGhlIGZpcnN0Iik7Cgl9IGVsc2UgaWYgKCFzdHJjbXAoc3Via2V5LCAiLnRhZ29wdCIpKSB7CgkJaWYgKCFzdHJjbXAodmFsdWUsICItLW5vLXRhZ3MiKSkKCQkJcmVtb3RlLT5mZXRjaF90YWdzID0gLTE7Cgl9IGVsc2UgaWYgKCFzdHJjbXAoc3Via2V5LCAiLnByb3h5IikpIHsKCQlyZW1vdGUtPmh0dHBfcHJveHkgPSB4c3RyZHVwKHZhbHVlKTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBhbGlhc19hbGxfdXJscyh2b2lkKQp7CglpbnQgaSwgajsKCWZvciAoaSA9IDA7IGkgPCByZW1vdGVzX25yOyBpKyspIHsKCQlpZiAoIXJlbW90ZXNbaV0pCgkJCWNvbnRpbnVlOwoJCWZvciAoaiA9IDA7IGogPCByZW1vdGVzW2ldLT51cmxfbnI7IGorKykgewoJCQlyZW1vdGVzW2ldLT51cmxbal0gPSBhbGlhc191cmwocmVtb3Rlc1tpXS0+dXJsW2pdKTsKCQl9Cgl9Cn0KCnN0YXRpYyB2b2lkIHJlYWRfY29uZmlnKHZvaWQpCnsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07Cgljb25zdCBjaGFyICpoZWFkX3JlZjsKCWludCBmbGFnOwoJaWYgKGRlZmF1bHRfcmVtb3RlX25hbWUpIC8vIGRpZCB0aGlzIGFscmVhZHkKCQlyZXR1cm47CglkZWZhdWx0X3JlbW90ZV9uYW1lID0geHN0cmR1cCgib3JpZ2luIik7CgljdXJyZW50X2JyYW5jaCA9IE5VTEw7CgloZWFkX3JlZiA9IHJlc29sdmVfcmVmKCJIRUFEIiwgc2hhMSwgMCwgJmZsYWcpOwoJaWYgKGhlYWRfcmVmICYmIChmbGFnICYgUkVGX0lTU1lNUkVGKSAmJgoJICAgICFwcmVmaXhjbXAoaGVhZF9yZWYsICJyZWZzL2hlYWRzLyIpKSB7CgkJY3VycmVudF9icmFuY2ggPQoJCQltYWtlX2JyYW5jaChoZWFkX3JlZiArIHN0cmxlbigicmVmcy9oZWFkcy8iKSwgMCk7Cgl9CglnaXRfY29uZmlnKGhhbmRsZV9jb25maWcpOwoJYWxpYXNfYWxsX3VybHMoKTsKfQoKc3RydWN0IHJlZnNwZWMgKnBhcnNlX3JlZl9zcGVjKGludCBucl9yZWZzcGVjLCBjb25zdCBjaGFyICoqcmVmc3BlYykKewoJaW50IGk7CglzdHJ1Y3QgcmVmc3BlYyAqcnMgPSB4Y2FsbG9jKHNpemVvZigqcnMpLCBucl9yZWZzcGVjKTsKCWZvciAoaSA9IDA7IGkgPCBucl9yZWZzcGVjOyBpKyspIHsKCQljb25zdCBjaGFyICpzcCwgKmVwLCAqZ3A7CgkJc3AgPSByZWZzcGVjW2ldOwoJCWlmICgqc3AgPT0gJysnKSB7CgkJCXJzW2ldLmZvcmNlID0gMTsKCQkJc3ArKzsKCQl9CgkJZ3AgPSBzdHJjaHIoc3AsICcqJyk7CgkJZXAgPSBzdHJjaHIoc3AsICc6Jyk7CgkJaWYgKGdwICYmIGVwICYmIGdwID4gZXApCgkJCWdwID0gTlVMTDsKCQlpZiAoZXApIHsKCQkJaWYgKGVwWzFdKSB7CgkJCQljb25zdCBjaGFyICpnbG9iID0gc3RyY2hyKGVwICsgMSwgJyonKTsKCQkJCWlmICghZ2xvYikKCQkJCQlncCA9IE5VTEw7CgkJCQlpZiAoZ3ApCgkJCQkJcnNbaV0uZHN0ID0geHN0cm5kdXAoZXAgKyAxLAoJCQkJCQkJICAgICBnbG9iIC0gZXAgLSAxKTsKCQkJCWVsc2UKCQkJCQlyc1tpXS5kc3QgPSB4c3RyZHVwKGVwICsgMSk7CgkJCX0KCQl9IGVsc2UgewoJCQllcCA9IHNwICsgc3RybGVuKHNwKTsKCQl9CgkJaWYgKGdwKSB7CgkJCXJzW2ldLnBhdHRlcm4gPSAxOwoJCQllcCA9IGdwOwoJCX0KCQlyc1tpXS5zcmMgPSB4c3RybmR1cChzcCwgZXAgLSBzcCk7Cgl9CglyZXR1cm4gcnM7Cn0KCnN0YXRpYyBpbnQgdmFsaWRfcmVtb3RlX25pY2soY29uc3QgY2hhciAqbmFtZSkKewoJaWYgKCFuYW1lWzBdIHx8IC8qIG5vdCBlbXB0eSAqLwoJICAgIChuYW1lWzBdID09ICcuJyAmJiAvKiBub3QgIi4iICovCgkgICAgICghbmFtZVsxXSB8fCAvKiBub3QgIi4uIiAqLwoJICAgICAgKG5hbWVbMV0gPT0gJy4nICYmICFuYW1lWzJdKSkpKQoJCXJldHVybiAwOwoJcmV0dXJuICFzdHJjaHIobmFtZSwgJy8nKTsgLyogbm8gc2xhc2ggKi8KfQoKc3RydWN0IHJlbW90ZSAqcmVtb3RlX2dldChjb25zdCBjaGFyICpuYW1lKQp7CglzdHJ1Y3QgcmVtb3RlICpyZXQ7CgoJcmVhZF9jb25maWcoKTsKCWlmICghbmFtZSkKCQluYW1lID0gZGVmYXVsdF9yZW1vdGVfbmFtZTsKCXJldCA9IG1ha2VfcmVtb3RlKG5hbWUsIDApOwoJaWYgKHZhbGlkX3JlbW90ZV9uaWNrKG5hbWUpKSB7CgkJaWYgKCFyZXQtPnVybCkKCQkJcmVhZF9yZW1vdGVzX2ZpbGUocmV0KTsKCQlpZiAoIXJldC0+dXJsKQoJCQlyZWFkX2JyYW5jaGVzX2ZpbGUocmV0KTsKCX0KCWlmICghcmV0LT51cmwpCgkJYWRkX3VybF9hbGlhcyhyZXQsIG5hbWUpOwoJaWYgKCFyZXQtPnVybCkKCQlyZXR1cm4gTlVMTDsKCXJldC0+ZmV0Y2ggPSBwYXJzZV9yZWZfc3BlYyhyZXQtPmZldGNoX3JlZnNwZWNfbnIsIHJldC0+ZmV0Y2hfcmVmc3BlYyk7CglyZXQtPnB1c2ggPSBwYXJzZV9yZWZfc3BlYyhyZXQtPnB1c2hfcmVmc3BlY19uciwgcmV0LT5wdXNoX3JlZnNwZWMpOwoJcmV0dXJuIHJldDsKfQoKaW50IGZvcl9lYWNoX3JlbW90ZShlYWNoX3JlbW90ZV9mbiBmbiwgdm9pZCAqcHJpdikKewoJaW50IGksIHJlc3VsdCA9IDA7CglyZWFkX2NvbmZpZygpOwoJZm9yIChpID0gMDsgaSA8IHJlbW90ZXNfbnIgJiYgIXJlc3VsdDsgaSsrKSB7CgkJc3RydWN0IHJlbW90ZSAqciA9IHJlbW90ZXNbaV07CgkJaWYgKCFyKQoJCQljb250aW51ZTsKCQlpZiAoIXItPmZldGNoKQoJCQlyLT5mZXRjaCA9IHBhcnNlX3JlZl9zcGVjKHItPmZldGNoX3JlZnNwZWNfbnIsCgkJCQkJci0+ZmV0Y2hfcmVmc3BlYyk7CgkJaWYgKCFyLT5wdXNoKQoJCQlyLT5wdXNoID0gcGFyc2VfcmVmX3NwZWMoci0+cHVzaF9yZWZzcGVjX25yLAoJCQkJCXItPnB1c2hfcmVmc3BlYyk7CgkJcmVzdWx0ID0gZm4ociwgcHJpdik7Cgl9CglyZXR1cm4gcmVzdWx0Owp9Cgp2b2lkIHJlZl9yZW1vdmVfZHVwbGljYXRlcyhzdHJ1Y3QgcmVmICpyZWZfbWFwKQp7CglzdHJ1Y3QgcmVmICoqcG9zbjsKCXN0cnVjdCByZWYgKm5leHQ7Cglmb3IgKDsgcmVmX21hcDsgcmVmX21hcCA9IHJlZl9tYXAtPm5leHQpIHsKCQlpZiAoIXJlZl9tYXAtPnBlZXJfcmVmKQoJCQljb250aW51ZTsKCQlwb3NuID0gJnJlZl9tYXAtPm5leHQ7CgkJd2hpbGUgKCpwb3NuKSB7CgkJCWlmICgoKnBvc24pLT5wZWVyX3JlZiAmJgoJCQkgICAgIXN0cmNtcCgoKnBvc24pLT5wZWVyX3JlZi0+bmFtZSwKCQkJCSAgICByZWZfbWFwLT5wZWVyX3JlZi0+bmFtZSkpIHsKCQkJCWlmIChzdHJjbXAoKCpwb3NuKS0+bmFtZSwgcmVmX21hcC0+bmFtZSkpCgkJCQkJZGllKCIlcyB0cmFja3MgYm90aCAlcyBhbmQgJXMiLAoJCQkJCSAgICByZWZfbWFwLT5wZWVyX3JlZi0+bmFtZSwKCQkJCQkgICAgKCpwb3NuKS0+bmFtZSwgcmVmX21hcC0+bmFtZSk7CgkJCQluZXh0ID0gKCpwb3NuKS0+bmV4dDsKCQkJCWZyZWUoKCpwb3NuKS0+cGVlcl9yZWYpOwoJCQkJZnJlZSgqcG9zbik7CgkJCQkqcG9zbiA9IG5leHQ7CgkJCX0gZWxzZSB7CgkJCQlwb3NuID0gJigqcG9zbiktPm5leHQ7CgkJCX0KCQl9Cgl9Cn0KCmludCByZW1vdGVfaGFzX3VybChzdHJ1Y3QgcmVtb3RlICpyZW1vdGUsIGNvbnN0IGNoYXIgKnVybCkKewoJaW50IGk7Cglmb3IgKGkgPSAwOyBpIDwgcmVtb3RlLT51cmxfbnI7IGkrKykgewoJCWlmICghc3RyY21wKHJlbW90ZS0+dXJsW2ldLCB1cmwpKQoJCQlyZXR1cm4gMTsKCX0KCXJldHVybiAwOwp9CgppbnQgcmVtb3RlX2ZpbmRfdHJhY2tpbmcoc3RydWN0IHJlbW90ZSAqcmVtb3RlLCBzdHJ1Y3QgcmVmc3BlYyAqcmVmc3BlYykKewoJaW50IGZpbmRfc3JjID0gcmVmc3BlYy0+c3JjID09IE5VTEw7CgljaGFyICpuZWVkbGUsICoqcmVzdWx0OwoJaW50IGk7CgoJaWYgKGZpbmRfc3JjKSB7CgkJaWYgKCFyZWZzcGVjLT5kc3QpCgkJCXJldHVybiBlcnJvcigiZmluZF90cmFja2luZzogbmVlZCBlaXRoZXIgc3JjIG9yIGRzdCIpOwoJCW5lZWRsZSA9IHJlZnNwZWMtPmRzdDsKCQlyZXN1bHQgPSAmcmVmc3BlYy0+c3JjOwoJfSBlbHNlIHsKCQluZWVkbGUgPSByZWZzcGVjLT5zcmM7CgkJcmVzdWx0ID0gJnJlZnNwZWMtPmRzdDsKCX0KCglmb3IgKGkgPSAwOyBpIDwgcmVtb3RlLT5mZXRjaF9yZWZzcGVjX25yOyBpKyspIHsKCQlzdHJ1Y3QgcmVmc3BlYyAqZmV0Y2ggPSAmcmVtb3RlLT5mZXRjaFtpXTsKCQljb25zdCBjaGFyICprZXkgPSBmaW5kX3NyYyA/IGZldGNoLT5kc3QgOiBmZXRjaC0+c3JjOwoJCWNvbnN0IGNoYXIgKnZhbHVlID0gZmluZF9zcmMgPyBmZXRjaC0+c3JjIDogZmV0Y2gtPmRzdDsKCQlpZiAoIWZldGNoLT5kc3QpCgkJCWNvbnRpbnVlOwoJCWlmIChmZXRjaC0+cGF0dGVybikgewoJCQlpZiAoIXByZWZpeGNtcChuZWVkbGUsIGtleSkpIHsKCQkJCSpyZXN1bHQgPSB4bWFsbG9jKHN0cmxlbih2YWx1ZSkgKwoJCQkJCQkgIHN0cmxlbihuZWVkbGUpIC0KCQkJCQkJICBzdHJsZW4oa2V5KSArIDEpOwoJCQkJc3RyY3B5KCpyZXN1bHQsIHZhbHVlKTsKCQkJCXN0cmNweSgqcmVzdWx0ICsgc3RybGVuKHZhbHVlKSwKCQkJCSAgICAgICBuZWVkbGUgKyBzdHJsZW4oa2V5KSk7CgkJCQlyZWZzcGVjLT5mb3JjZSA9IGZldGNoLT5mb3JjZTsKCQkJCXJldHVybiAwOwoJCQl9CgkJfSBlbHNlIGlmICghc3RyY21wKG5lZWRsZSwga2V5KSkgewoJCQkqcmVzdWx0ID0geHN0cmR1cCh2YWx1ZSk7CgkJCXJlZnNwZWMtPmZvcmNlID0gZmV0Y2gtPmZvcmNlOwoJCQlyZXR1cm4gMDsKCQl9Cgl9CglyZXR1cm4gLTE7Cn0KCnN0cnVjdCByZWYgKmFsbG9jX3JlZih1bnNpZ25lZCBuYW1lbGVuKQp7CglzdHJ1Y3QgcmVmICpyZXQgPSB4bWFsbG9jKHNpemVvZihzdHJ1Y3QgcmVmKSArIG5hbWVsZW4pOwoJbWVtc2V0KHJldCwgMCwgc2l6ZW9mKHN0cnVjdCByZWYpICsgbmFtZWxlbik7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgc3RydWN0IHJlZiAqY29weV9yZWYoY29uc3Qgc3RydWN0IHJlZiAqcmVmKQp7CglzdHJ1Y3QgcmVmICpyZXQgPSB4bWFsbG9jKHNpemVvZihzdHJ1Y3QgcmVmKSArIHN0cmxlbihyZWYtPm5hbWUpICsgMSk7CgltZW1jcHkocmV0LCByZWYsIHNpemVvZihzdHJ1Y3QgcmVmKSArIHN0cmxlbihyZWYtPm5hbWUpICsgMSk7CglyZXQtPm5leHQgPSBOVUxMOwoJcmV0dXJuIHJldDsKfQoKc3RydWN0IHJlZiAqY29weV9yZWZfbGlzdChjb25zdCBzdHJ1Y3QgcmVmICpyZWYpCnsKCXN0cnVjdCByZWYgKnJldCA9IE5VTEw7CglzdHJ1Y3QgcmVmICoqdGFpbCA9ICZyZXQ7Cgl3aGlsZSAocmVmKSB7CgkJKnRhaWwgPSBjb3B5X3JlZihyZWYpOwoJCXJlZiA9IHJlZi0+bmV4dDsKCQl0YWlsID0gJigoKnRhaWwpLT5uZXh0KTsKCX0KCXJldHVybiByZXQ7Cn0KCnZvaWQgZnJlZV9yZWZzKHN0cnVjdCByZWYgKnJlZikKewoJc3RydWN0IHJlZiAqbmV4dDsKCXdoaWxlIChyZWYpIHsKCQluZXh0ID0gcmVmLT5uZXh0OwoJCWlmIChyZWYtPnBlZXJfcmVmKQoJCQlmcmVlKHJlZi0+cGVlcl9yZWYpOwoJCWZyZWUocmVmKTsKCQlyZWYgPSBuZXh0OwoJfQp9CgpzdGF0aWMgaW50IGNvdW50X3JlZnNwZWNfbWF0Y2goY29uc3QgY2hhciAqcGF0dGVybiwKCQkJICAgICAgIHN0cnVjdCByZWYgKnJlZnMsCgkJCSAgICAgICBzdHJ1Y3QgcmVmICoqbWF0Y2hlZF9yZWYpCnsKCWludCBwYXRsZW4gPSBzdHJsZW4ocGF0dGVybik7CglzdHJ1Y3QgcmVmICptYXRjaGVkX3dlYWsgPSBOVUxMOwoJc3RydWN0IHJlZiAqbWF0Y2hlZCA9IE5VTEw7CglpbnQgd2Vha19tYXRjaCA9IDA7CglpbnQgbWF0Y2ggPSAwOwoKCWZvciAod2Vha19tYXRjaCA9IG1hdGNoID0gMDsgcmVmczsgcmVmcyA9IHJlZnMtPm5leHQpIHsKCQljaGFyICpuYW1lID0gcmVmcy0+bmFtZTsKCQlpbnQgbmFtZWxlbiA9IHN0cmxlbihuYW1lKTsKCgkJaWYgKCFyZWZuYW1lX21hdGNoKHBhdHRlcm4sIG5hbWUsIHJlZl9yZXZfcGFyc2VfcnVsZXMpKQoJCQljb250aW51ZTsKCgkJLyogQSBtYXRjaCBpcyAid2VhayIgaWYgaXQgaXMgd2l0aCByZWZzIG91dHNpZGUKCQkgKiBoZWFkcyBvciB0YWdzLCBhbmQgZGlkIG5vdCBzcGVjaWZ5IHRoZSBwYXR0ZXJuCgkJICogaW4gZnVsbCAoZS5nLiAicmVmcy9yZW1vdGVzL29yaWdpbi9tYXN0ZXIiKSBvciBhdAoJCSAqIGxlYXN0IGZyb20gdGhlIHRvcGxldmVsIChlLmcuICJyZW1vdGVzL29yaWdpbi9tYXN0ZXIiKTsKCQkgKiBvdGhlcndpc2UgImdpdCBwdXNoICRVUkwgbWFzdGVyIiB3b3VsZCByZXN1bHQgaW4KCQkgKiBhbWJpZ3VpdHkgYmV0d2VlbiByZW1vdGVzL29yaWdpbi9tYXN0ZXIgYW5kIGhlYWRzL21hc3RlcgoJCSAqIGF0IHRoZSByZW1vdGUgc2l0ZS4KCQkgKi8KCQlpZiAobmFtZWxlbiAhPSBwYXRsZW4gJiYKCQkgICAgcGF0bGVuICE9IG5hbWVsZW4gLSA1ICYmCgkJICAgIHByZWZpeGNtcChuYW1lLCAicmVmcy9oZWFkcy8iKSAmJgoJCSAgICBwcmVmaXhjbXAobmFtZSwgInJlZnMvdGFncy8iKSkgewoJCQkvKiBXZSB3YW50IHRvIGNhdGNoIHRoZSBjYXNlIHdoZXJlIG9ubHkgd2VhawoJCQkgKiBtYXRjaGVzIGFyZSBmb3VuZCBhbmQgdGhlcmUgYXJlIG11bHRpcGxlCgkJCSAqIG1hdGNoZXMsIGFuZCB3aGVyZSBtb3JlIHRoYW4gb25lIHN0cm9uZwoJCQkgKiBtYXRjaGVzIGFyZSBmb3VuZCwgYXMgYW1iaWd1b3VzLiAgT25lCgkJCSAqIHN0cm9uZyBtYXRjaCB3aXRoIHplcm8gb3IgbW9yZSB3ZWFrIG1hdGNoZXMKCQkJICogYXJlIGFjY2VwdGFibGUgYXMgYSB1bmlxdWUgbWF0Y2guCgkJCSAqLwoJCQltYXRjaGVkX3dlYWsgPSByZWZzOwoJCQl3ZWFrX21hdGNoKys7CgkJfQoJCWVsc2UgewoJCQltYXRjaGVkID0gcmVmczsKCQkJbWF0Y2grKzsKCQl9Cgl9CglpZiAoIW1hdGNoZWQpIHsKCQkqbWF0Y2hlZF9yZWYgPSBtYXRjaGVkX3dlYWs7CgkJcmV0dXJuIHdlYWtfbWF0Y2g7Cgl9CgllbHNlIHsKCQkqbWF0Y2hlZF9yZWYgPSBtYXRjaGVkOwoJCXJldHVybiBtYXRjaDsKCX0KfQoKc3RhdGljIHZvaWQgdGFpbF9saW5rX3JlZihzdHJ1Y3QgcmVmICpyZWYsIHN0cnVjdCByZWYgKioqdGFpbCkKewoJKip0YWlsID0gcmVmOwoJd2hpbGUgKHJlZi0+bmV4dCkKCQlyZWYgPSByZWYtPm5leHQ7CgkqdGFpbCA9ICZyZWYtPm5leHQ7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVmICp0cnlfZXhwbGljaXRfb2JqZWN0X25hbWUoY29uc3QgY2hhciAqbmFtZSkKewoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCXN0cnVjdCByZWYgKnJlZjsKCWludCBsZW47CgoJaWYgKCEqbmFtZSkgewoJCXJlZiA9IGFsbG9jX3JlZigyMCk7CgkJc3RyY3B5KHJlZi0+bmFtZSwgIihkZWxldGUpIik7CgkJaGFzaGNscihyZWYtPm5ld19zaGExKTsKCQlyZXR1cm4gcmVmOwoJfQoJaWYgKGdldF9zaGExKG5hbWUsIHNoYTEpKQoJCXJldHVybiBOVUxMOwoJbGVuID0gc3RybGVuKG5hbWUpICsgMTsKCXJlZiA9IGFsbG9jX3JlZihsZW4pOwoJbWVtY3B5KHJlZi0+bmFtZSwgbmFtZSwgbGVuKTsKCWhhc2hjcHkocmVmLT5uZXdfc2hhMSwgc2hhMSk7CglyZXR1cm4gcmVmOwp9CgpzdGF0aWMgc3RydWN0IHJlZiAqbWFrZV9saW5rZWRfcmVmKGNvbnN0IGNoYXIgKm5hbWUsIHN0cnVjdCByZWYgKioqdGFpbCkKewoJc3RydWN0IHJlZiAqcmV0OwoJc2l6ZV90IGxlbjsKCglsZW4gPSBzdHJsZW4obmFtZSkgKyAxOwoJcmV0ID0gYWxsb2NfcmVmKGxlbik7CgltZW1jcHkocmV0LT5uYW1lLCBuYW1lLCBsZW4pOwoJdGFpbF9saW5rX3JlZihyZXQsIHRhaWwpOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIGludCBtYXRjaF9leHBsaWNpdChzdHJ1Y3QgcmVmICpzcmMsIHN0cnVjdCByZWYgKmRzdCwKCQkJICBzdHJ1Y3QgcmVmICoqKmRzdF90YWlsLAoJCQkgIHN0cnVjdCByZWZzcGVjICpycywKCQkJICBpbnQgZXJycykKewoJc3RydWN0IHJlZiAqbWF0Y2hlZF9zcmMsICptYXRjaGVkX2RzdDsKCgljb25zdCBjaGFyICpkc3RfdmFsdWUgPSBycy0+ZHN0OwoKCWlmIChycy0+cGF0dGVybikKCQlyZXR1cm4gZXJyczsKCgltYXRjaGVkX3NyYyA9IG1hdGNoZWRfZHN0ID0gTlVMTDsKCXN3aXRjaCAoY291bnRfcmVmc3BlY19tYXRjaChycy0+c3JjLCBzcmMsICZtYXRjaGVkX3NyYykpIHsKCWNhc2UgMToKCQlicmVhazsKCWNhc2UgMDoKCQkvKiBUaGUgc291cmNlIGNvdWxkIGJlIGluIHRoZSBnZXRfc2hhMSgpIGZvcm1hdAoJCSAqIG5vdCBhIHJlZmVyZW5jZSBuYW1lLiAgOnJlZnMvb3RoZXIgaXMgYQoJCSAqIHdheSB0byBkZWxldGUgJ290aGVyJyByZWYgYXQgdGhlIHJlbW90ZSBlbmQuCgkJICovCgkJbWF0Y2hlZF9zcmMgPSB0cnlfZXhwbGljaXRfb2JqZWN0X25hbWUocnMtPnNyYyk7CgkJaWYgKCFtYXRjaGVkX3NyYykKCQkJZXJyb3IoInNyYyByZWZzcGVjICVzIGRvZXMgbm90IG1hdGNoIGFueS4iLCBycy0+c3JjKTsKCQlicmVhazsKCWRlZmF1bHQ6CgkJbWF0Y2hlZF9zcmMgPSBOVUxMOwoJCWVycm9yKCJzcmMgcmVmc3BlYyAlcyBtYXRjaGVzIG1vcmUgdGhhbiBvbmUuIiwgcnMtPnNyYyk7CgkJYnJlYWs7Cgl9CgoJaWYgKCFtYXRjaGVkX3NyYykKCQllcnJzID0gMTsKCglpZiAoIWRzdF92YWx1ZSkgewoJCWlmICghbWF0Y2hlZF9zcmMpCgkJCXJldHVybiBlcnJzOwoJCWRzdF92YWx1ZSA9IG1hdGNoZWRfc3JjLT5uYW1lOwoJfQoKCXN3aXRjaCAoY291bnRfcmVmc3BlY19tYXRjaChkc3RfdmFsdWUsIGRzdCwgJm1hdGNoZWRfZHN0KSkgewoJY2FzZSAxOgoJCWJyZWFrOwoJY2FzZSAwOgoJCWlmICghbWVtY21wKGRzdF92YWx1ZSwgInJlZnMvIiwgNSkpCgkJCW1hdGNoZWRfZHN0ID0gbWFrZV9saW5rZWRfcmVmKGRzdF92YWx1ZSwgZHN0X3RhaWwpOwoJCWVsc2UKCQkJZXJyb3IoImRzdCByZWZzcGVjICVzIGRvZXMgbm90IG1hdGNoIGFueSAiCgkJCSAgICAgICJleGlzdGluZyByZWYgb24gdGhlIHJlbW90ZSBhbmQgZG9lcyAiCgkJCSAgICAgICJub3Qgc3RhcnQgd2l0aCByZWZzLy4iLCBkc3RfdmFsdWUpOwoJCWJyZWFrOwoJZGVmYXVsdDoKCQltYXRjaGVkX2RzdCA9IE5VTEw7CgkJZXJyb3IoImRzdCByZWZzcGVjICVzIG1hdGNoZXMgbW9yZSB0aGFuIG9uZS4iLAoJCSAgICAgIGRzdF92YWx1ZSk7CgkJYnJlYWs7Cgl9CglpZiAoZXJycyB8fCAhbWF0Y2hlZF9kc3QpCgkJcmV0dXJuIDE7CglpZiAobWF0Y2hlZF9kc3QtPnBlZXJfcmVmKSB7CgkJZXJycyA9IDE7CgkJZXJyb3IoImRzdCByZWYgJXMgcmVjZWl2ZXMgZnJvbSBtb3JlIHRoYW4gb25lIHNyYy4iLAoJCSAgICAgIG1hdGNoZWRfZHN0LT5uYW1lKTsKCX0KCWVsc2UgewoJCW1hdGNoZWRfZHN0LT5wZWVyX3JlZiA9IG1hdGNoZWRfc3JjOwoJCW1hdGNoZWRfZHN0LT5mb3JjZSA9IHJzLT5mb3JjZTsKCX0KCXJldHVybiBlcnJzOwp9CgpzdGF0aWMgaW50IG1hdGNoX2V4cGxpY2l0X3JlZnMoc3RydWN0IHJlZiAqc3JjLCBzdHJ1Y3QgcmVmICpkc3QsCgkJCSAgICAgICBzdHJ1Y3QgcmVmICoqKmRzdF90YWlsLCBzdHJ1Y3QgcmVmc3BlYyAqcnMsCgkJCSAgICAgICBpbnQgcnNfbnIpCnsKCWludCBpLCBlcnJzOwoJZm9yIChpID0gZXJycyA9IDA7IGkgPCByc19ucjsgaSsrKQoJCWVycnMgfD0gbWF0Y2hfZXhwbGljaXQoc3JjLCBkc3QsIGRzdF90YWlsLCAmcnNbaV0sIGVycnMpOwoJcmV0dXJuIC1lcnJzOwp9CgpzdGF0aWMgY29uc3Qgc3RydWN0IHJlZnNwZWMgKmNoZWNrX3BhdHRlcm5fbWF0Y2goY29uc3Qgc3RydWN0IHJlZnNwZWMgKnJzLAoJCQkJCQkgaW50IHJzX25yLAoJCQkJCQkgY29uc3Qgc3RydWN0IHJlZiAqc3JjKQp7CglpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCByc19ucjsgaSsrKSB7CgkJaWYgKHJzW2ldLnBhdHRlcm4gJiYgIXByZWZpeGNtcChzcmMtPm5hbWUsIHJzW2ldLnNyYykpCgkJCXJldHVybiBycyArIGk7Cgl9CglyZXR1cm4gTlVMTDsKfQoKLyoKICogTm90ZS4gVGhpcyBpcyB1c2VkIG9ubHkgYnkgInB1c2giOyByZWZzcGVjIG1hdGNoaW5nIHJ1bGVzIGZvcgogKiBwdXNoIGFuZCBmZXRjaCBhcmUgc3VidGx5IGRpZmZlcmVudCwgc28gZG8gbm90IHRyeSB0byByZXVzZSBpdAogKiB3aXRob3V0IHRoaW5raW5nLgogKi8KaW50IG1hdGNoX3JlZnMoc3RydWN0IHJlZiAqc3JjLCBzdHJ1Y3QgcmVmICpkc3QsIHN0cnVjdCByZWYgKioqZHN0X3RhaWwsCgkgICAgICAgaW50IG5yX3JlZnNwZWMsIGNvbnN0IGNoYXIgKipyZWZzcGVjLCBpbnQgZmxhZ3MpCnsKCXN0cnVjdCByZWZzcGVjICpycyA9CgkJcGFyc2VfcmVmX3NwZWMobnJfcmVmc3BlYywgKGNvbnN0IGNoYXIgKiopIHJlZnNwZWMpOwoJaW50IHNlbmRfYWxsID0gZmxhZ3MgJiBNQVRDSF9SRUZTX0FMTDsKCWludCBzZW5kX21pcnJvciA9IGZsYWdzICYgTUFUQ0hfUkVGU19NSVJST1I7CgoJaWYgKG1hdGNoX2V4cGxpY2l0X3JlZnMoc3JjLCBkc3QsIGRzdF90YWlsLCBycywgbnJfcmVmc3BlYykpCgkJcmV0dXJuIC0xOwoKCS8qIHBpY2sgdGhlIHJlbWFpbmRlciAqLwoJZm9yICggOyBzcmM7IHNyYyA9IHNyYy0+bmV4dCkgewoJCXN0cnVjdCByZWYgKmRzdF9wZWVyOwoJCWNvbnN0IHN0cnVjdCByZWZzcGVjICpwYXQgPSBOVUxMOwoJCWNoYXIgKmRzdF9uYW1lOwoJCWlmIChzcmMtPnBlZXJfcmVmKQoJCQljb250aW51ZTsKCQlpZiAobnJfcmVmc3BlYykgewoJCQlwYXQgPSBjaGVja19wYXR0ZXJuX21hdGNoKHJzLCBucl9yZWZzcGVjLCBzcmMpOwoJCQlpZiAoIXBhdCkKCQkJCWNvbnRpbnVlOwoJCX0KCQllbHNlIGlmICghc2VuZF9taXJyb3IgJiYgcHJlZml4Y21wKHNyYy0+bmFtZSwgInJlZnMvaGVhZHMvIikpCgkJCS8qCgkJCSAqICJtYXRjaGluZyByZWZzIjsgdHJhZGl0aW9uYWxseSB3ZSBwdXNoZWQgZXZlcnl0aGluZwoJCQkgKiBpbmNsdWRpbmcgcmVmcyBvdXRzaWRlIHJlZnMvaGVhZHMvIGhpZXJhcmNoeSwgYnV0CgkJCSAqIHRoYXQgZG9lcyBub3QgbWFrZSBtdWNoIHNlbnNlIHRoZXNlIGRheXMuCgkJCSAqLwoJCQljb250aW51ZTsKCgkJaWYgKHBhdCkgewoJCQljb25zdCBjaGFyICpkc3Rfc2lkZSA9IHBhdC0+ZHN0ID8gcGF0LT5kc3QgOiBwYXQtPnNyYzsKCQkJZHN0X25hbWUgPSB4bWFsbG9jKHN0cmxlbihkc3Rfc2lkZSkgKwoJCQkJCSAgIHN0cmxlbihzcmMtPm5hbWUpIC0KCQkJCQkgICBzdHJsZW4ocGF0LT5zcmMpICsgMik7CgkJCXN0cmNweShkc3RfbmFtZSwgZHN0X3NpZGUpOwoJCQlzdHJjYXQoZHN0X25hbWUsIHNyYy0+bmFtZSArIHN0cmxlbihwYXQtPnNyYykpOwoJCX0gZWxzZQoJCQlkc3RfbmFtZSA9IHhzdHJkdXAoc3JjLT5uYW1lKTsKCQlkc3RfcGVlciA9IGZpbmRfcmVmX2J5X25hbWUoZHN0LCBkc3RfbmFtZSk7CgkJaWYgKGRzdF9wZWVyICYmIGRzdF9wZWVyLT5wZWVyX3JlZikKCQkJLyogV2UncmUgYWxyZWFkeSBzZW5kaW5nIHNvbWV0aGluZyB0byB0aGlzIHJlZi4gKi8KCQkJZ290byBmcmVlX25hbWU7CgoJCWlmICghZHN0X3BlZXIgJiYgIW5yX3JlZnNwZWMgJiYgIShzZW5kX2FsbCB8fCBzZW5kX21pcnJvcikpCgkJCS8qCgkJCSAqIFJlbW90ZSBkb2Vzbid0IGhhdmUgaXQsIGFuZCB3ZSBoYXZlIG5vCgkJCSAqIGV4cGxpY2l0IHBhdHRlcm4sIGFuZCB3ZSBkb24ndCBoYXZlCgkJCSAqIC0tYWxsIG5vciAtLW1pcnJvci4KCQkJICovCgkJCWdvdG8gZnJlZV9uYW1lOwoJCWlmICghZHN0X3BlZXIpIHsKCQkJLyogQ3JlYXRlIGEgbmV3IG9uZSBhbmQgbGluayBpdCAqLwoJCQlkc3RfcGVlciA9IG1ha2VfbGlua2VkX3JlZihkc3RfbmFtZSwgZHN0X3RhaWwpOwoJCQloYXNoY3B5KGRzdF9wZWVyLT5uZXdfc2hhMSwgc3JjLT5uZXdfc2hhMSk7CgkJfQoJCWRzdF9wZWVyLT5wZWVyX3JlZiA9IHNyYzsKCQlpZiAocGF0KQoJCQlkc3RfcGVlci0+Zm9yY2UgPSBwYXQtPmZvcmNlOwoJZnJlZV9uYW1lOgoJCWZyZWUoZHN0X25hbWUpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0cnVjdCBicmFuY2ggKmJyYW5jaF9nZXQoY29uc3QgY2hhciAqbmFtZSkKewoJc3RydWN0IGJyYW5jaCAqcmV0OwoKCXJlYWRfY29uZmlnKCk7CglpZiAoIW5hbWUgfHwgISpuYW1lIHx8ICFzdHJjbXAobmFtZSwgIkhFQUQiKSkKCQlyZXQgPSBjdXJyZW50X2JyYW5jaDsKCWVsc2UKCQlyZXQgPSBtYWtlX2JyYW5jaChuYW1lLCAwKTsKCWlmIChyZXQgJiYgcmV0LT5yZW1vdGVfbmFtZSkgewoJCXJldC0+cmVtb3RlID0gcmVtb3RlX2dldChyZXQtPnJlbW90ZV9uYW1lKTsKCQlpZiAocmV0LT5tZXJnZV9ucikgewoJCQlpbnQgaTsKCQkJcmV0LT5tZXJnZSA9IHhjYWxsb2Moc2l6ZW9mKCpyZXQtPm1lcmdlKSwKCQkJCQkgICAgIHJldC0+bWVyZ2VfbnIpOwoJCQlmb3IgKGkgPSAwOyBpIDwgcmV0LT5tZXJnZV9ucjsgaSsrKSB7CgkJCQlyZXQtPm1lcmdlW2ldID0geGNhbGxvYygxLCBzaXplb2YoKipyZXQtPm1lcmdlKSk7CgkJCQlyZXQtPm1lcmdlW2ldLT5zcmMgPSB4c3RyZHVwKHJldC0+bWVyZ2VfbmFtZVtpXSk7CgkJCQlyZW1vdGVfZmluZF90cmFja2luZyhyZXQtPnJlbW90ZSwKCQkJCQkJICAgICByZXQtPm1lcmdlW2ldKTsKCQkJfQoJCX0KCX0KCXJldHVybiByZXQ7Cn0KCmludCBicmFuY2hfaGFzX21lcmdlX2NvbmZpZyhzdHJ1Y3QgYnJhbmNoICpicmFuY2gpCnsKCXJldHVybiBicmFuY2ggJiYgISFicmFuY2gtPm1lcmdlOwp9CgppbnQgYnJhbmNoX21lcmdlX21hdGNoZXMoc3RydWN0IGJyYW5jaCAqYnJhbmNoLAoJCSAgICAgICAgICAgICAgICAgaW50IGksCgkJICAgICAgICAgICAgICAgICBjb25zdCBjaGFyICpyZWZuYW1lKQp7CglpZiAoIWJyYW5jaCB8fCBpIDwgMCB8fCBpID49IGJyYW5jaC0+bWVyZ2VfbnIpCgkJcmV0dXJuIDA7CglyZXR1cm4gcmVmbmFtZV9tYXRjaChicmFuY2gtPm1lcmdlW2ldLT5zcmMsIHJlZm5hbWUsIHJlZl9mZXRjaF9ydWxlcyk7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVmICpnZXRfZXhwYW5kZWRfbWFwKGNvbnN0IHN0cnVjdCByZWYgKnJlbW90ZV9yZWZzLAoJCQkJICAgIGNvbnN0IHN0cnVjdCByZWZzcGVjICpyZWZzcGVjKQp7Cgljb25zdCBzdHJ1Y3QgcmVmICpyZWY7CglzdHJ1Y3QgcmVmICpyZXQgPSBOVUxMOwoJc3RydWN0IHJlZiAqKnRhaWwgPSAmcmV0OwoKCWludCByZW1vdGVfcHJlZml4X2xlbiA9IHN0cmxlbihyZWZzcGVjLT5zcmMpOwoJaW50IGxvY2FsX3ByZWZpeF9sZW4gPSBzdHJsZW4ocmVmc3BlYy0+ZHN0KTsKCglmb3IgKHJlZiA9IHJlbW90ZV9yZWZzOyByZWY7IHJlZiA9IHJlZi0+bmV4dCkgewoJCWlmIChzdHJjaHIocmVmLT5uYW1lLCAnXicpKQoJCQljb250aW51ZTsgLyogYSBkZXJlZmVyZW5jZSBpdGVtICovCgkJaWYgKCFwcmVmaXhjbXAocmVmLT5uYW1lLCByZWZzcGVjLT5zcmMpKSB7CgkJCWNvbnN0IGNoYXIgKm1hdGNoOwoJCQlzdHJ1Y3QgcmVmICpjcHkgPSBjb3B5X3JlZihyZWYpOwoJCQltYXRjaCA9IHJlZi0+bmFtZSArIHJlbW90ZV9wcmVmaXhfbGVuOwoKCQkJY3B5LT5wZWVyX3JlZiA9IGFsbG9jX3JlZihsb2NhbF9wcmVmaXhfbGVuICsKCQkJCQkJICBzdHJsZW4obWF0Y2gpICsgMSk7CgkJCXNwcmludGYoY3B5LT5wZWVyX3JlZi0+bmFtZSwgIiVzJXMiLAoJCQkJcmVmc3BlYy0+ZHN0LCBtYXRjaCk7CgkJCWlmIChyZWZzcGVjLT5mb3JjZSkKCQkJCWNweS0+cGVlcl9yZWYtPmZvcmNlID0gMTsKCQkJKnRhaWwgPSBjcHk7CgkJCXRhaWwgPSAmY3B5LT5uZXh0OwoJCX0KCX0KCglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgY29uc3Qgc3RydWN0IHJlZiAqZmluZF9yZWZfYnlfbmFtZV9hYmJyZXYoY29uc3Qgc3RydWN0IHJlZiAqcmVmcywgY29uc3QgY2hhciAqbmFtZSkKewoJY29uc3Qgc3RydWN0IHJlZiAqcmVmOwoJZm9yIChyZWYgPSByZWZzOyByZWY7IHJlZiA9IHJlZi0+bmV4dCkgewoJCWlmIChyZWZuYW1lX21hdGNoKG5hbWUsIHJlZi0+bmFtZSwgcmVmX2ZldGNoX3J1bGVzKSkKCQkJcmV0dXJuIHJlZjsKCX0KCXJldHVybiBOVUxMOwp9CgpzdHJ1Y3QgcmVmICpnZXRfcmVtb3RlX3JlZihjb25zdCBzdHJ1Y3QgcmVmICpyZW1vdGVfcmVmcywgY29uc3QgY2hhciAqbmFtZSkKewoJY29uc3Qgc3RydWN0IHJlZiAqcmVmID0gZmluZF9yZWZfYnlfbmFtZV9hYmJyZXYocmVtb3RlX3JlZnMsIG5hbWUpOwoKCWlmICghcmVmKQoJCXJldHVybiBOVUxMOwoKCXJldHVybiBjb3B5X3JlZihyZWYpOwp9CgpzdGF0aWMgc3RydWN0IHJlZiAqZ2V0X2xvY2FsX3JlZihjb25zdCBjaGFyICpuYW1lKQp7CglzdHJ1Y3QgcmVmICpyZXQ7CglpZiAoIW5hbWUpCgkJcmV0dXJuIE5VTEw7CgoJaWYgKCFwcmVmaXhjbXAobmFtZSwgInJlZnMvIikpIHsKCQlyZXQgPSBhbGxvY19yZWYoc3RybGVuKG5hbWUpICsgMSk7CgkJc3RyY3B5KHJldC0+bmFtZSwgbmFtZSk7CgkJcmV0dXJuIHJldDsKCX0KCglpZiAoIXByZWZpeGNtcChuYW1lLCAiaGVhZHMvIikgfHwKCSAgICAhcHJlZml4Y21wKG5hbWUsICJ0YWdzLyIpIHx8CgkgICAgIXByZWZpeGNtcChuYW1lLCAicmVtb3Rlcy8iKSkgewoJCXJldCA9IGFsbG9jX3JlZihzdHJsZW4obmFtZSkgKyA2KTsKCQlzcHJpbnRmKHJldC0+bmFtZSwgInJlZnMvJXMiLCBuYW1lKTsKCQlyZXR1cm4gcmV0OwoJfQoKCXJldCA9IGFsbG9jX3JlZihzdHJsZW4obmFtZSkgKyAxMik7CglzcHJpbnRmKHJldC0+bmFtZSwgInJlZnMvaGVhZHMvJXMiLCBuYW1lKTsKCXJldHVybiByZXQ7Cn0KCmludCBnZXRfZmV0Y2hfbWFwKGNvbnN0IHN0cnVjdCByZWYgKnJlbW90ZV9yZWZzLAoJCSAgY29uc3Qgc3RydWN0IHJlZnNwZWMgKnJlZnNwZWMsCgkJICBzdHJ1Y3QgcmVmICoqKnRhaWwsCgkJICBpbnQgbWlzc2luZ19vaykKewoJc3RydWN0IHJlZiAqcmVmX21hcCwgKnJtOwoKCWlmIChyZWZzcGVjLT5wYXR0ZXJuKSB7CgkJcmVmX21hcCA9IGdldF9leHBhbmRlZF9tYXAocmVtb3RlX3JlZnMsIHJlZnNwZWMpOwoJfSBlbHNlIHsKCQljb25zdCBjaGFyICpuYW1lID0gcmVmc3BlYy0+c3JjWzBdID8gcmVmc3BlYy0+c3JjIDogIkhFQUQiOwoKCQlyZWZfbWFwID0gZ2V0X3JlbW90ZV9yZWYocmVtb3RlX3JlZnMsIG5hbWUpOwoJCWlmICghbWlzc2luZ19vayAmJiAhcmVmX21hcCkKCQkJZGllKCJDb3VsZG4ndCBmaW5kIHJlbW90ZSByZWYgJXMiLCBuYW1lKTsKCQlpZiAocmVmX21hcCkgewoJCQlyZWZfbWFwLT5wZWVyX3JlZiA9IGdldF9sb2NhbF9yZWYocmVmc3BlYy0+ZHN0KTsKCQkJaWYgKHJlZl9tYXAtPnBlZXJfcmVmICYmIHJlZnNwZWMtPmZvcmNlKQoJCQkJcmVmX21hcC0+cGVlcl9yZWYtPmZvcmNlID0gMTsKCQl9Cgl9CgoJZm9yIChybSA9IHJlZl9tYXA7IHJtOyBybSA9IHJtLT5uZXh0KSB7CgkJaWYgKHJtLT5wZWVyX3JlZiAmJiBjaGVja19yZWZfZm9ybWF0KHJtLT5wZWVyX3JlZi0+bmFtZSArIDUpKQoJCQlkaWUoIiogcmVmdXNpbmcgdG8gY3JlYXRlIGZ1bm55IHJlZiAnJXMnIGxvY2FsbHkiLAoJCQkgICAgcm0tPnBlZXJfcmVmLT5uYW1lKTsKCX0KCglpZiAocmVmX21hcCkKCQl0YWlsX2xpbmtfcmVmKHJlZl9tYXAsIHRhaWwpOwoKCXJldHVybiAwOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n\nstruct rewrite {\n\tconst char *base;\n\tconst char **instead_of;\n\tint instead_of_nr;\n\tint instead_of_alloc;\n};\n\nstatic struct remote **remotes;\nstatic int remotes_alloc;\nstatic int remotes_nr;\n\nstatic struct branch **branches;\nstatic int branches_alloc;\nstatic int branches_nr;\n\nstatic struct branch *current_branch;\nstatic const char *default_remote_name;\n\nstatic struct rewrite **rewrite;\nstatic int rewrite_alloc;\nstatic int rewrite_nr;\n\n#define BUF_SIZE (2048)\nstatic char buffer[BUF_SIZE];\n\nstatic const char *alias_url(const char *url)\n{\n\tint i, j;\n\tfor (i = 0; i < rewrite_nr; i++) {\n\t\tif (!rewrite[i])\n\t\t\tcontinue;\n\t\tfor (j = 0; j < rewrite[i]->instead_of_nr; j++) {\n\t\t\tif (!prefixcmp(url, rewrite[i]->instead_of[j])) {\n\t\t\t\tchar *ret = malloc(strlen(rewrite[i]->base) -\n\t\t\t\t\t\t   strlen(rewrite[i]->instead_of[j]) +\n\t\t\t\t\t\t   strlen(url) + 1);\n\t\t\t\tstrcpy(ret, rewrite[i]->base);\n\t\t\t\tstrcat(ret, url + strlen(rewrite[i]->instead_of[j]));\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn url;\n}\n\nstatic void add_push_refspec(struct remote *remote, const char *ref)\n{\n\tALLOC_GROW(remote->push_refspec,\n\t\t   remote->push_refspec_nr + 1,\n\t\t   remote->push_refspec_alloc);\n\tremote->push_refspec[remote->push_refspec_nr++] = ref;\n}\n\nstatic void add_fetch_refspec(struct remote *remote, const char *ref)\n{\n\tALLOC_GROW(remote->fetch_refspec,\n\t\t   remote->fetch_refspec_nr + 1,\n\t\t   remote->fetch_refspec_alloc);\n\tremote->fetch_refspec[remote->fetch_refspec_nr++] = ref;\n}\n\nstatic void add_url(struct remote *remote, const char *url)\n{\n\tALLOC_GROW(remote->url, remote->url_nr + 1, remote->url_alloc);\n\tremote->url[remote->url_nr++] = url;\n}\n\nstatic void add_url_alias(struct remote *remote, const char *url)\n{\n\tadd_url(remote, alias_url(url));\n}\n\nstatic struct remote *make_remote(const char *name, int len)\n{\n\tstruct remote *ret;\n\tint i;\n\n\tfor (i = 0; i < remotes_nr; i++) {\n\t\tif (len ? (!strncmp(name, remotes[i]->name, len) &&\n\t\t\t   !remotes[i]->name[len]) :\n\t\t    !strcmp(name, remotes[i]->name))\n\t\t\treturn remotes[i];\n\t}\n\n\tret = xcalloc(1, sizeof(struct remote));\n\tALLOC_GROW(remotes, remotes_nr + 1, remotes_alloc);\n\tremotes[remotes_nr++] = ret;\n\tif (len)\n\t\tret->name = xstrndup(name, len);\n\telse\n\t\tret->name = xstrdup(name);\n\treturn ret;\n}\n\nstatic void add_merge(struct branch *branch, const char *name)\n{\n\tALLOC_GROW(branch->merge_name, branch->merge_nr + 1,\n\t\t   branch->merge_alloc);\n\tbranch->merge_name[branch->merge_nr++] = name;\n}\n\nstatic struct branch *make_branch(const char *name, int len)\n{\n\tstruct branch *ret;\n\tint i;\n\tchar *refname;\n\n\tfor (i = 0; i < branches_nr; i++) {\n\t\tif (len ? (!strncmp(name, branches[i]->name, len) &&\n\t\t\t   !branches[i]->name[len]) :\n\t\t    !strcmp(name, branches[i]->name))\n\t\t\treturn branches[i];\n\t}\n\n\tALLOC_GROW(branches, branches_nr + 1, branches_alloc);\n\tret = xcalloc(1, sizeof(struct branch));\n\tbranches[branches_nr++] = ret;\n\tif (len)\n\t\tret->name = xstrndup(name, len);\n\telse\n\t\tret->name = xstrdup(name);\n\trefname = malloc(strlen(name) + strlen(\"refs/heads/\") + 1);\n\tstrcpy(refname, \"refs/heads/\");\n\tstrcpy(refname + strlen(\"refs/heads/\"), ret->name);\n\tret->refname = refname;\n\n\treturn ret;\n}\n\nstatic struct rewrite *make_rewrite(const char *base, int len)\n{\n\tstruct rewrite *ret;\n\tint i;\n\n\tfor (i = 0; i < rewrite_nr; i++) {\n\t\tif (len ? (!strncmp(base, rewrite[i]->base, len) &&\n\t\t\t   !rewrite[i]->base[len]) :\n\t\t    !strcmp(base, rewrite[i]->base))\n\t\t\treturn rewrite[i];\n\t}\n\n\tALLOC_GROW(rewrite, rewrite_nr + 1, rewrite_alloc);\n\tret = xcalloc(1, sizeof(struct rewrite));\n\trewrite[rewrite_nr++] = ret;\n\tif (len)\n\t\tret->base = xstrndup(base, len);\n\telse\n\t\tret->base = xstrdup(base);\n\n\treturn ret;\n}\n\nstatic void add_instead_of(struct rewrite *rewrite, const char *instead_of)\n{\n\tALLOC_GROW(rewrite->instead_of, rewrite->instead_of_nr + 1, rewrite->instead_of_alloc);\n\trewrite->instead_of[rewrite->instead_of_nr++] = instead_of;\n}\n\nstatic void read_remotes_file(struct remote *remote)\n{\n\tFILE *f = fopen(git_path(\"remotes/%s\", remote->name), \"r\");\n\n\tif (!f)\n\t\treturn;\n\twhile (fgets(buffer, BUF_SIZE, f)) {\n\t\tint value_list;\n\t\tchar *s, *p;\n\n\t\tif (!prefixcmp(buffer, \"URL:\")) {\n\t\t\tvalue_list = 0;\n\t\t\ts = buffer + 4;\n\t\t} else if (!prefixcmp(buffer, \"Push:\")) {\n\t\t\tvalue_list = 1;\n\t\t\ts = buffer + 5;\n\t\t} else if (!prefixcmp(buffer, \"Pull:\")) {\n\t\t\tvalue_list = 2;\n\t\t\ts = buffer + 5;\n\t\t} else\n\t\t\tcontinue;\n\n\t\twhile (isspace(*s))\n\t\t\ts++;\n\t\tif (!*s)\n\t\t\tcontinue;\n\n\t\tp = s + strlen(s);\n\t\twhile (isspace(p[-1]))\n\t\t\t*--p = 0;\n\n\t\tswitch (value_list) {\n\t\tcase 0:\n\t\t\tadd_url_alias(remote, xstrdup(s));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tadd_push_refspec(remote, xstrdup(s));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tadd_fetch_refspec(remote, xstrdup(s));\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(f);\n}\n\nstatic void read_branches_file(struct remote *remote)\n{\n\tconst char *slash = strchr(remote->name, '/');\n\tchar *frag;\n\tchar *branch;\n\tint n = slash ? slash - remote->name : 1000;\n\tFILE *f = fopen(git_path(\"branches/%.*s\", n, remote->name), \"r\");\n\tchar *s, *p;\n\tint len;\n\n\tif (!f)\n\t\treturn;\n\ts = fgets(buffer, BUF_SIZE, f);\n\tfclose(f);\n\tif (!s)\n\t\treturn;\n\twhile (isspace(*s))\n\t\ts++;\n\tif (!*s)\n\t\treturn;\n\tp = s + strlen(s);\n\twhile (isspace(p[-1]))\n\t\t*--p = 0;\n\tlen = p - s;\n\tif (slash)\n\t\tlen += strlen(slash);\n\tp = xmalloc(len + 1);\n\tstrcpy(p, s);\n\tif (slash)\n\t\tstrcat(p, slash);\n\tfrag = strchr(p, '#');\n\tif (frag) {\n\t\t*(frag++) = '\\0';\n\t\tbranch = xmalloc(strlen(frag) + 12);\n\t\tstrcpy(branch, \"refs/heads/\");\n\t\tstrcat(branch, frag);\n\t} else {\n\t\tbranch = \"refs/heads/master\";\n\t}\n\tadd_url_alias(remote, p);\n\tadd_fetch_refspec(remote, branch);\n\tremote->fetch_tags = 1; /* always auto-follow */\n}\n\nstatic int handle_config(const char *key, const char *value)\n{\n\tconst char *name;\n\tconst char *subkey;\n\tstruct remote *remote;\n\tstruct branch *branch;\n\tif (!prefixcmp(key, \"branch.\")) {\n\t\tname = key + 7;\n\t\tsubkey = strrchr(name, '.');\n\t\tif (!subkey)\n\t\t\treturn 0;\n\t\tbranch = make_branch(name, subkey - name);\n\t\tif (!strcmp(subkey, \".remote\")) {\n\t\t\tif (!value)\n\t\t\t\treturn config_error_nonbool(key);\n\t\t\tbranch->remote_name = xstrdup(value);\n\t\t\tif (branch == current_branch)\n\t\t\t\tdefault_remote_name = branch->remote_name;\n\t\t} else if (!strcmp(subkey, \".merge\")) {\n\t\t\tif (!value)\n\t\t\t\treturn config_error_nonbool(key);\n\t\t\tadd_merge(branch, xstrdup(value));\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!prefixcmp(key, \"url.\")) {\n\t\tstruct rewrite *rewrite;\n\t\tname = key + 5;\n\t\tsubkey = strrchr(name, '.');\n\t\tif (!subkey)\n\t\t\treturn 0;\n\t\trewrite = make_rewrite(name, subkey - name);\n\t\tif (!strcmp(subkey, \".insteadof\")) {\n\t\t\tif (!value)\n\t\t\t\treturn config_error_nonbool(key);\n\t\t\tadd_instead_of(rewrite, xstrdup(value));\n\t\t}\n\t}\n\tif (prefixcmp(key,  \"remote.\"))\n\t\treturn 0;\n\tname = key + 7;\n\tsubkey = strrchr(name, '.');\n\tif (!subkey)\n\t\treturn error(\"Config with no key for remote %s\", name);\n\tif (*subkey == '/') {\n\t\twarning(\"Config remote shorthand cannot begin with '/': %s\", name);\n\t\treturn 0;\n\t}\n\tremote = make_remote(name, subkey - name);\n\tif (!value) {\n\t\t/* if we ever have a boolean variable, e.g. \"remote.*.disabled\"\n\t\t * [remote \"frotz\"]\n\t\t *      disabled\n\t\t * is a valid way to set it to true; we get NULL in value so\n\t\t * we need to handle it here.\n\t\t *\n\t\t * if (!strcmp(subkey, \".disabled\")) {\n\t\t *      val = git_config_bool(key, value);\n\t\t *      return 0;\n\t\t * } else\n\t\t *\n\t\t */\n\t\treturn 0; /* ignore unknown booleans */\n\t}\n\tif (!strcmp(subkey, \".url\")) {\n\t\tadd_url(remote, xstrdup(value));\n\t} else if (!strcmp(subkey, \".push\")) {\n\t\tadd_push_refspec(remote, xstrdup(value));\n\t} else if (!strcmp(subkey, \".fetch\")) {\n\t\tadd_fetch_refspec(remote, xstrdup(value));\n\t} else if (!strcmp(subkey, \".receivepack\")) {\n\t\tif (!remote->receivepack)\n\t\t\tremote->receivepack = xstrdup(value);\n\t\telse\n\t\t\terror(\"more than one receivepack given, using the first\");\n\t} else if (!strcmp(subkey, \".uploadpack\")) {\n\t\tif (!remote->uploadpack)\n\t\t\tremote->uploadpack = xstrdup(value);\n\t\telse\n\t\t\terror(\"more than one uploadpack given, using the first\");\n\t} else if (!strcmp(subkey, \".tagopt\")) {\n\t\tif (!strcmp(value, \"--no-tags\"))\n\t\t\tremote->fetch_tags = -1;\n\t} else if (!strcmp(subkey, \".proxy\")) {\n\t\tremote->http_proxy = xstrdup(value);\n\t}\n\treturn 0;\n}\n\nstatic void alias_all_urls(void)\n{\n\tint i, j;\n\tfor (i = 0; i < remotes_nr; i++) {\n\t\tif (!remotes[i])\n\t\t\tcontinue;\n\t\tfor (j = 0; j < remotes[i]->url_nr; j++) {\n\t\t\tremotes[i]->url[j] = alias_url(remotes[i]->url[j]);\n\t\t}\n\t}\n}\n\nstatic void read_config(void)\n{\n\tunsigned char sha1[20];\n\tconst char *head_ref;\n\tint flag;\n\tif (default_remote_name) // did this already\n\t\treturn;\n\tdefault_remote_name = xstrdup(\"origin\");\n\tcurrent_branch = NULL;\n\thead_ref = resolve_ref(\"HEAD\", sha1, 0, &flag);\n\tif (head_ref && (flag & REF_ISSYMREF) &&\n\t    !prefixcmp(head_ref, \"refs/heads/\")) {\n\t\tcurrent_branch =\n\t\t\tmake_branch(head_ref + strlen(\"refs/heads/\"), 0);\n\t}\n\tgit_config(handle_config);\n\talias_all_urls();\n}\n\nstruct refspec *parse_ref_spec(int nr_refspec, const char **refspec)\n{\n\tint i;\n\tstruct refspec *rs = xcalloc(sizeof(*rs), nr_refspec);\n\tfor (i = 0; i < nr_refspec; i++) {\n\t\tconst char *sp, *ep, *gp;\n\t\tsp = refspec[i];\n\t\tif (*sp == '+') {\n\t\t\trs[i].force = 1;\n\t\t\tsp++;\n\t\t}\n\t\tgp = strchr(sp, '*');\n\t\tep = strchr(sp, ':');\n\t\tif (gp && ep && gp > ep)\n\t\t\tgp = NULL;\n\t\tif (ep) {\n\t\t\tif (ep[1]) {\n\t\t\t\tconst char *glob = strchr(ep + 1, '*');\n\t\t\t\tif (!glob)\n\t\t\t\t\tgp = NULL;\n\t\t\t\tif (gp)\n\t\t\t\t\trs[i].dst = xstrndup(ep + 1,\n\t\t\t\t\t\t\t     glob - ep - 1);\n\t\t\t\telse\n\t\t\t\t\trs[i].dst = xstrdup(ep + 1);\n\t\t\t}\n\t\t} else {\n\t\t\tep = sp + strlen(sp);\n\t\t}\n\t\tif (gp) {\n\t\t\trs[i].pattern = 1;\n\t\t\tep = gp;\n\t\t}\n\t\trs[i].src = xstrndup(sp, ep - sp);\n\t}\n\treturn rs;\n}\n\nstatic int valid_remote_nick(const char *name)\n{\n\tif (!name[0] || /* not empty */\n\t    (name[0] == '.' && /* not \".\" */\n\t     (!name[1] || /* not \"..\" */\n\t      (name[1] == '.' && !name[2]))))\n\t\treturn 0;\n\treturn !strchr(name, '/'); /* no slash */\n}\n\nstruct remote *remote_get(const char *name)\n{\n\tstruct remote *ret;\n\n\tread_config();\n\tif (!name)\n\t\tname = default_remote_name;\n\tret = make_remote(name, 0);\n\tif (valid_remote_nick(name)) {\n\t\tif (!ret->url)\n\t\t\tread_remotes_file(ret);\n\t\tif (!ret->url)\n\t\t\tread_branches_file(ret);\n\t}\n\tif (!ret->url)\n\t\tadd_url_alias(ret, name);\n\tif (!ret->url)\n\t\treturn NULL;\n\tret->fetch = parse_ref_spec(ret->fetch_refspec_nr, ret->fetch_refspec);\n\tret->push = parse_ref_spec(ret->push_refspec_nr, ret->push_refspec);\n\treturn ret;\n}\n\nint for_each_remote(each_remote_fn fn, void *priv)\n{\n\tint i, result = 0;\n\tread_config();\n\tfor (i = 0; i < remotes_nr && !result; i++) {\n\t\tstruct remote *r = remotes[i];\n\t\tif (!r)\n\t\t\tcontinue;\n\t\tif (!r->fetch)\n\t\t\tr->fetch = parse_ref_spec(r->fetch_refspec_nr,\n\t\t\t\t\tr->fetch_refspec);\n\t\tif (!r->push)\n\t\t\tr->push = parse_ref_spec(r->push_refspec_nr,\n\t\t\t\t\tr->push_refspec);\n\t\tresult = fn(r, priv);\n\t}\n\treturn result;\n}\n\nvoid ref_remove_duplicates(struct ref *ref_map)\n{\n\tstruct ref **posn;\n\tstruct ref *next;\n\tfor (; ref_map; ref_map = ref_map->next) {\n\t\tif (!ref_map->peer_ref)\n\t\t\tcontinue;\n\t\tposn = &ref_map->next;\n\t\twhile (*posn) {\n\t\t\tif ((*posn)->peer_ref &&\n\t\t\t    !strcmp((*posn)->peer_ref->name,\n\t\t\t\t    ref_map->peer_ref->name)) {\n\t\t\t\tif (strcmp((*posn)->name, ref_map->name))\n\t\t\t\t\tdie(\"%s tracks both %s and %s\",\n\t\t\t\t\t    ref_map->peer_ref->name,\n\t\t\t\t\t    (*posn)->name, ref_map->name);\n\t\t\t\tnext = (*posn)->next;\n\t\t\t\tfree((*posn)->peer_ref);\n\t\t\t\tfree(*posn);\n\t\t\t\t*posn = next;\n\t\t\t} else {\n\t\t\t\tposn = &(*posn)->next;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint remote_has_url(struct remote *remote, const char *url)\n{\n\tint i;\n\tfor (i = 0; i < remote->url_nr; i++) {\n\t\tif (!strcmp(remote->url[i], url))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint remote_find_tracking(struct remote *remote, struct refspec *refspec)\n{\n\tint find_src = refspec->src == NULL;\n\tchar *needle, **result;\n\tint i;\n\n\tif (find_src) {\n\t\tif (!refspec->dst)\n\t\t\treturn error(\"find_tracking: need either src or dst\");\n\t\tneedle = refspec->dst;\n\t\tresult = &refspec->src;\n\t} else {\n\t\tneedle = refspec->src;\n\t\tresult = &refspec->dst;\n\t}\n\n\tfor (i = 0; i < remote->fetch_refspec_nr; i++) {\n\t\tstruct refspec *fetch = &remote->fetch[i];\n\t\tconst char *key = find_src ? fetch->dst : fetch->src;\n\t\tconst char *value = find_src ? fetch->src : fetch->dst;\n\t\tif (!fetch->dst)\n\t\t\tcontinue;\n\t\tif (fetch->pattern) {\n\t\t\tif (!prefixcmp(needle, key)) {\n\t\t\t\t*result = xmalloc(strlen(value) +\n\t\t\t\t\t\t  strlen(needle) -\n\t\t\t\t\t\t  strlen(key) + 1);\n\t\t\t\tstrcpy(*result, value);\n\t\t\t\tstrcpy(*result + strlen(value),\n\t\t\t\t       needle + strlen(key));\n\t\t\t\trefspec->force = fetch->force;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if (!strcmp(needle, key)) {\n\t\t\t*result = xstrdup(value);\n\t\t\trefspec->force = fetch->force;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstruct ref *alloc_ref(unsigned namelen)\n{\n\tstruct ref *ret = xmalloc(sizeof(struct ref) + namelen);\n\tmemset(ret, 0, sizeof(struct ref) + namelen);\n\treturn ret;\n}\n\nstatic struct ref *copy_ref(const struct ref *ref)\n{\n\tstruct ref *ret = xmalloc(sizeof(struct ref) + strlen(ref->name) + 1);\n\tmemcpy(ret, ref, sizeof(struct ref) + strlen(ref->name) + 1);\n\tret->next = NULL;\n\treturn ret;\n}\n\nstruct ref *copy_ref_list(const struct ref *ref)\n{\n\tstruct ref *ret = NULL;\n\tstruct ref **tail = &ret;\n\twhile (ref) {\n\t\t*tail = copy_ref(ref);\n\t\tref = ref->next;\n\t\ttail = &((*tail)->next);\n\t}\n\treturn ret;\n}\n\nvoid free_refs(struct ref *ref)\n{\n\tstruct ref *next;\n\twhile (ref) {\n\t\tnext = ref->next;\n\t\tif (ref->peer_ref)\n\t\t\tfree(ref->peer_ref);\n\t\tfree(ref);\n\t\tref = next;\n\t}\n}\n\nstatic int count_refspec_match(const char *pattern,\n\t\t\t       struct ref *refs,\n\t\t\t       struct ref **matched_ref)\n{\n\tint patlen = strlen(pattern);\n\tstruct ref *matched_weak = NULL;\n\tstruct ref *matched = NULL;\n\tint weak_match = 0;\n\tint match = 0;\n\n\tfor (weak_match = match = 0; refs; refs = refs->next) {\n\t\tchar *name = refs->name;\n\t\tint namelen = strlen(name);\n\n\t\tif (!refname_match(pattern, name, ref_rev_parse_rules))\n\t\t\tcontinue;\n\n\t\t/* A match is \"weak\" if it is with refs outside\n\t\t * heads or tags, and did not specify the pattern\n\t\t * in full (e.g. \"refs/remotes/origin/master\") or at\n\t\t * least from the toplevel (e.g. \"remotes/origin/master\");\n\t\t * otherwise \"git push $URL master\" would result in\n\t\t * ambiguity between remotes/origin/master and heads/master\n\t\t * at the remote site.\n\t\t */\n\t\tif (namelen != patlen &&\n\t\t    patlen != namelen - 5 &&\n\t\t    prefixcmp(name, \"refs/heads/\") &&\n\t\t    prefixcmp(name, \"refs/tags/\")) {\n\t\t\t/* We want to catch the case where only weak\n\t\t\t * matches are found and there are multiple\n\t\t\t * matches, and where more than one strong\n\t\t\t * matches are found, as ambiguous.  One\n\t\t\t * strong match with zero or more weak matches\n\t\t\t * are acceptable as a unique match.\n\t\t\t */\n\t\t\tmatched_weak = refs;\n\t\t\tweak_match++;\n\t\t}\n\t\telse {\n\t\t\tmatched = refs;\n\t\t\tmatch++;\n\t\t}\n\t}\n\tif (!matched) {\n\t\t*matched_ref = matched_weak;\n\t\treturn weak_match;\n\t}\n\telse {\n\t\t*matched_ref = matched;\n\t\treturn match;\n\t}\n}\n\nstatic void tail_link_ref(struct ref *ref, struct ref ***tail)\n{\n\t**tail = ref;\n\twhile (ref->next)\n\t\tref = ref->next;\n\t*tail = &ref->next;\n}\n\nstatic struct ref *try_explicit_object_name(const char *name)\n{\n\tunsigned char sha1[20];\n\tstruct ref *ref;\n\tint len;\n\n\tif (!*name) {\n\t\tref = alloc_ref(20);\n\t\tstrcpy(ref->name, \"(delete)\");\n\t\thashclr(ref->new_sha1);\n\t\treturn ref;\n\t}\n\tif (get_sha1(name, sha1))\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\tref = alloc_ref(len);\n\tmemcpy(ref->name, name, len);\n\thashcpy(ref->new_sha1, sha1);\n\treturn ref;\n}\n\nstatic struct ref *make_linked_ref(const char *name, struct ref ***tail)\n{\n\tstruct ref *ret;\n\tsize_t len;\n\n\tlen = strlen(name) + 1;\n\tret = alloc_ref(len);\n\tmemcpy(ret->name, name, len);\n\ttail_link_ref(ret, tail);\n\treturn ret;\n}\n\nstatic int match_explicit(struct ref *src, struct ref *dst,\n\t\t\t  struct ref ***dst_tail,\n\t\t\t  struct refspec *rs,\n\t\t\t  int errs)\n{\n\tstruct ref *matched_src, *matched_dst;\n\n\tconst char *dst_value = rs->dst;\n\n\tif (rs->pattern)\n\t\treturn errs;\n\n\tmatched_src = matched_dst = NULL;\n\tswitch (count_refspec_match(rs->src, src, &matched_src)) {\n\tcase 1:\n\t\tbreak;\n\tcase 0:\n\t\t/* The source could be in the get_sha1() format\n\t\t * not a reference name.  :refs/other is a\n\t\t * way to delete 'other' ref at the remote end.\n\t\t */\n\t\tmatched_src = try_explicit_object_name(rs->src);\n\t\tif (!matched_src)\n\t\t\terror(\"src refspec %s does not match any.\", rs->src);\n\t\tbreak;\n\tdefault:\n\t\tmatched_src = NULL;\n\t\terror(\"src refspec %s matches more than one.\", rs->src);\n\t\tbreak;\n\t}\n\n\tif (!matched_src)\n\t\terrs = 1;\n\n\tif (!dst_value) {\n\t\tif (!matched_src)\n\t\t\treturn errs;\n\t\tdst_value = matched_src->name;\n\t}\n\n\tswitch (count_refspec_match(dst_value, dst, &matched_dst)) {\n\tcase 1:\n\t\tbreak;\n\tcase 0:\n\t\tif (!memcmp(dst_value, \"refs/\", 5))\n\t\t\tmatched_dst = make_linked_ref(dst_value, dst_tail);\n\t\telse\n\t\t\terror(\"dst refspec %s does not match any \"\n\t\t\t      \"existing ref on the remote and does \"\n\t\t\t      \"not start with refs/.\", dst_value);\n\t\tbreak;\n\tdefault:\n\t\tmatched_dst = NULL;\n\t\terror(\"dst refspec %s matches more than one.\",\n\t\t      dst_value);\n\t\tbreak;\n\t}\n\tif (errs || !matched_dst)\n\t\treturn 1;\n\tif (matched_dst->peer_ref) {\n\t\terrs = 1;\n\t\terror(\"dst ref %s receives from more than one src.\",\n\t\t      matched_dst->name);\n\t}\n\telse {\n\t\tmatched_dst->peer_ref = matched_src;\n\t\tmatched_dst->force = rs->force;\n\t}\n\treturn errs;\n}\n\nstatic int match_explicit_refs(struct ref *src, struct ref *dst,\n\t\t\t       struct ref ***dst_tail, struct refspec *rs,\n\t\t\t       int rs_nr)\n{\n\tint i, errs;\n\tfor (i = errs = 0; i < rs_nr; i++)\n\t\terrs |= match_explicit(src, dst, dst_tail, &rs[i], errs);\n\treturn -errs;\n}\n\nstatic const struct refspec *check_pattern_match(const struct refspec *rs,\n\t\t\t\t\t\t int rs_nr,\n\t\t\t\t\t\t const struct ref *src)\n{\n\tint i;\n\tfor (i = 0; i < rs_nr; i++) {\n\t\tif (rs[i].pattern && !prefixcmp(src->name, rs[i].src))\n\t\t\treturn rs + i;\n\t}\n\treturn NULL;\n}\n\n/*\n * Note. This is used only by \"push\"; refspec matching rules for\n * push and fetch are subtly different, so do not try to reuse it\n * without thinking.\n */\nint match_refs(struct ref *src, struct ref *dst, struct ref ***dst_tail,\n\t       int nr_refspec, const char **refspec, int flags)\n{\n\tstruct refspec *rs =\n\t\tparse_ref_spec(nr_refspec, (const char **) refspec);\n\tint send_all = flags & MATCH_REFS_ALL;\n\tint send_mirror = flags & MATCH_REFS_MIRROR;\n\n\tif (match_explicit_refs(src, dst, dst_tail, rs, nr_refspec))\n\t\treturn -1;\n\n\t/* pick the remainder */\n\tfor ( ; src; src = src->next) {\n\t\tstruct ref *dst_peer;\n\t\tconst struct refspec *pat = NULL;\n\t\tchar *dst_name;\n\t\tif (src->peer_ref)\n\t\t\tcontinue;\n\t\tif (nr_refspec) {\n\t\t\tpat = check_pattern_match(rs, nr_refspec, src);\n\t\t\tif (!pat)\n\t\t\t\tcontinue;\n\t\t}\n\t\telse if (!send_mirror && prefixcmp(src->name, \"refs/heads/\"))\n\t\t\t/*\n\t\t\t * \"matching refs\"; traditionally we pushed everything\n\t\t\t * including refs outside refs/heads/ hierarchy, but\n\t\t\t * that does not make much sense these days.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tif (pat) {\n\t\t\tconst char *dst_side = pat->dst ? pat->dst : pat->src;\n\t\t\tdst_name = xmalloc(strlen(dst_side) +\n\t\t\t\t\t   strlen(src->name) -\n\t\t\t\t\t   strlen(pat->src) + 2);\n\t\t\tstrcpy(dst_name, dst_side);\n\t\t\tstrcat(dst_name, src->name + strlen(pat->src));\n\t\t} else\n\t\t\tdst_name = xstrdup(src->name);\n\t\tdst_peer = find_ref_by_name(dst, dst_name);\n\t\tif (dst_peer && dst_peer->peer_ref)\n\t\t\t/* We're already sending something to this ref. */\n\t\t\tgoto free_name;\n\n\t\tif (!dst_peer && !nr_refspec && !(send_all || send_mirror))\n\t\t\t/*\n\t\t\t * Remote doesn't have it, and we have no\n\t\t\t * explicit pattern, and we don't have\n\t\t\t * --all nor --mirror.\n\t\t\t */\n\t\t\tgoto free_name;\n\t\tif (!dst_peer) {\n\t\t\t/* Create a new one and link it */\n\t\t\tdst_peer = make_linked_ref(dst_name, dst_tail);\n\t\t\thashcpy(dst_peer->new_sha1, src->new_sha1);\n\t\t}\n\t\tdst_peer->peer_ref = src;\n\t\tif (pat)\n\t\t\tdst_peer->force = pat->force;\n\tfree_name:\n\t\tfree(dst_name);\n\t}\n\treturn 0;\n}\n\nstruct branch *branch_get(const char *name)\n{\n\tstruct branch *ret;\n\n\tread_config();\n\tif (!name || !*name || !strcmp(name, \"HEAD\"))\n\t\tret = current_branch;\n\telse\n\t\tret = make_branch(name, 0);\n\tif (ret && ret->remote_name) {\n\t\tret->remote = remote_get(ret->remote_name);\n\t\tif (ret->merge_nr) {\n\t\t\tint i;\n\t\t\tret->merge = xcalloc(sizeof(*ret->merge),\n\t\t\t\t\t     ret->merge_nr);\n\t\t\tfor (i = 0; i < ret->merge_nr; i++) {\n\t\t\t\tret->merge[i] = xcalloc(1, sizeof(**ret->merge));\n\t\t\t\tret->merge[i]->src = xstrdup(ret->merge_name[i]);\n\t\t\t\tremote_find_tracking(ret->remote,\n\t\t\t\t\t\t     ret->merge[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint branch_has_merge_config(struct branch *branch)\n{\n\treturn branch && !!branch->merge;\n}\n\nint branch_merge_matches(struct branch *branch,\n\t\t                 int i,\n\t\t                 const char *refname)\n{\n\tif (!branch || i < 0 || i >= branch->merge_nr)\n\t\treturn 0;\n\treturn refname_match(branch->merge[i]->src, refname, ref_fetch_rules);\n}\n\nstatic struct ref *get_expanded_map(const struct ref *remote_refs,\n\t\t\t\t    const struct refspec *refspec)\n{\n\tconst struct ref *ref;\n\tstruct ref *ret = NULL;\n\tstruct ref **tail = &ret;\n\n\tint remote_prefix_len = strlen(refspec->src);\n\tint local_prefix_len = strlen(refspec->dst);\n\n\tfor (ref = remote_refs; ref; ref = ref->next) {\n\t\tif (strchr(ref->name, '^'))\n\t\t\tcontinue; /* a dereference item */\n\t\tif (!prefixcmp(ref->name, refspec->src)) {\n\t\t\tconst char *match;\n\t\t\tstruct ref *cpy = copy_ref(ref);\n\t\t\tmatch = ref->name + remote_prefix_len;\n\n\t\t\tcpy->peer_ref = alloc_ref(local_prefix_len +\n\t\t\t\t\t\t  strlen(match) + 1);\n\t\t\tsprintf(cpy->peer_ref->name, \"%s%s\",\n\t\t\t\trefspec->dst, match);\n\t\t\tif (refspec->force)\n\t\t\t\tcpy->peer_ref->force = 1;\n\t\t\t*tail = cpy;\n\t\t\ttail = &cpy->next;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic const struct ref *find_ref_by_name_abbrev(const struct ref *refs, const char *name)\n{\n\tconst struct ref *ref;\n\tfor (ref = refs; ref; ref = ref->next) {\n\t\tif (refname_match(name, ref->name, ref_fetch_rules))\n\t\t\treturn ref;\n\t}\n\treturn NULL;\n}\n\nstruct ref *get_remote_ref(const struct ref *remote_refs, const char *name)\n{\n\tconst struct ref *ref = find_ref_by_name_abbrev(remote_refs, name);\n\n\tif (!ref)\n\t\treturn NULL;\n\n\treturn copy_ref(ref);\n}\n\nstatic struct ref *get_local_ref(const char *name)\n{\n\tstruct ref *ret;\n\tif (!name)\n\t\treturn NULL;\n\n\tif (!prefixcmp(name, \"refs/\")) {\n\t\tret = alloc_ref(strlen(name) + 1);\n\t\tstrcpy(ret->name, name);\n\t\treturn ret;\n\t}\n\n\tif (!prefixcmp(name, \"heads/\") ||\n\t    !prefixcmp(name, \"tags/\") ||\n\t    !prefixcmp(name, \"remotes/\")) {\n\t\tret = alloc_ref(strlen(name) + 6);\n\t\tsprintf(ret->name, \"refs/%s\", name);\n\t\treturn ret;\n\t}\n\n\tret = alloc_ref(strlen(name) + 12);\n\tsprintf(ret->name, \"refs/heads/%s\", name);\n\treturn ret;\n}\n\nint get_fetch_map(const struct ref *remote_refs,\n\t\t  const struct refspec *refspec,\n\t\t  struct ref ***tail,\n\t\t  int missing_ok)\n{\n\tstruct ref *ref_map, *rm;\n\n\tif (refspec->pattern) {\n\t\tref_map = get_expanded_map(remote_refs, refspec);\n\t} else {\n\t\tconst char *name = refspec->src[0] ? refspec->src : \"HEAD\";\n\n\t\tref_map = get_remote_ref(remote_refs, name);\n\t\tif (!missing_ok && !ref_map)\n\t\t\tdie(\"Couldn't find remote ref %s\", name);\n\t\tif (ref_map) {\n\t\t\tref_map->peer_ref = get_local_ref(refspec->dst);\n\t\t\tif (ref_map->peer_ref && refspec->force)\n\t\t\t\tref_map->peer_ref->force = 1;\n\t\t}\n\t}\n\n\tfor (rm = ref_map; rm; rm = rm->next) {\n\t\tif (rm->peer_ref && check_ref_format(rm->peer_ref->name + 5))\n\t\t\tdie(\"* refusing to create funny ref '%s' locally\",\n\t\t\t    rm->peer_ref->name);\n\t}\n\n\tif (ref_map)\n\t\ttail_link_ref(ref_map, tail);\n\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0012954b6f795d75d442f4c58f29dc194888d022",
  "sha1_ok": true,
  "size": 23221
}
