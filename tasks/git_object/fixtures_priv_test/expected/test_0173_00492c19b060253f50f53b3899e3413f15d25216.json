{
  "content": {
    "base64": "LyoKICogImdpdCByZXNldCIgYnVpbHRpbiBjb21tYW5kCiAqCiAqIENvcHlyaWdodCAoYykgMjAwNyBDYXJsb3MgUmljYQogKgogKiBCYXNlZCBvbiBnaXQtcmVzZXQuc2gsIHdoaWNoIGlzCiAqCiAqIENvcHlyaWdodCAoYykgMjAwNSwgMjAwNiBMaW51cyBUb3J2YWxkcyBhbmQgSnVuaW8gQyBIYW1hbm8KICovCgojZGVmaW5lIFVTRV9USEVfUkVQT1NJVE9SWV9WQVJJQUJMRQoKI2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImFkdmljZS5oIgojaW5jbHVkZSAiY29uZmlnLmgiCiNpbmNsdWRlICJlbnZpcm9ubWVudC5oIgojaW5jbHVkZSAiZ2V0dGV4dC5oIgojaW5jbHVkZSAiaGFzaC5oIgojaW5jbHVkZSAiaGV4LmgiCiNpbmNsdWRlICJsb2NrZmlsZS5oIgojaW5jbHVkZSAib2JqZWN0LmgiCiNpbmNsdWRlICJwcmV0dHkuaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgImRpZmZjb3JlLmgiCiNpbmNsdWRlICJ0cmVlLmgiCiNpbmNsdWRlICJicmFuY2guaCIKI2luY2x1ZGUgIm9iamVjdC1uYW1lLmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCiNpbmNsdWRlICJwYXRoLmgiCiNpbmNsdWRlICJyZXBvc2l0b3J5LmgiCiNpbmNsdWRlICJ1bnBhY2stdHJlZXMuaCIKI2luY2x1ZGUgImNhY2hlLXRyZWUuaCIKI2luY2x1ZGUgInNldHVwLmgiCiNpbmNsdWRlICJzcGFyc2UtaW5kZXguaCIKI2luY2x1ZGUgInN1Ym1vZHVsZS5oIgojaW5jbHVkZSAidHJhY2UuaCIKI2luY2x1ZGUgInRyYWNlMi5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJhZGQtaW50ZXJhY3RpdmUuaCIKCiNkZWZpbmUgUkVGUkVTSF9JTkRFWF9ERUxBWV9XQVJOSU5HX0lOX01TICgyICogMTAwMCkKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgZ2l0X3Jlc2V0X3VzYWdlW10gPSB7CglOXygiZ2l0IHJlc2V0IFstLW1peGVkIHwgLS1zb2Z0IHwgLS1oYXJkIHwgLS1tZXJnZSB8IC0ta2VlcF0gWy1xXSBbPGNvbW1pdD5dIiksCglOXygiZ2l0IHJlc2V0IFstcV0gWzx0cmVlLWlzaD5dIFstLV0gPHBhdGhzcGVjPi4uLiIpLAoJTl8oImdpdCByZXNldCBbLXFdIFstLXBhdGhzcGVjLWZyb20tZmlsZSBbLS1wYXRoc3BlYy1maWxlLW51bF1dIFs8dHJlZS1pc2g+XSIpLAoJTl8oImdpdCByZXNldCAtLXBhdGNoIFs8dHJlZS1pc2g+XSBbLS1dIFs8cGF0aHNwZWM+Li4uXSIpLAoJTlVMTAp9OwoKZW51bSByZXNldF90eXBlIHsgTUlYRUQsIFNPRlQsIEhBUkQsIE1FUkdFLCBLRUVQLCBOT05FIH07CnN0YXRpYyBjb25zdCBjaGFyICpyZXNldF90eXBlX25hbWVzW10gPSB7CglOXygibWl4ZWQiKSwgTl8oInNvZnQiKSwgTl8oImhhcmQiKSwgTl8oIm1lcmdlIiksIE5fKCJrZWVwIiksIE5VTEwKfTsKCnN0YXRpYyBpbmxpbmUgaW50IGlzX21lcmdlKHZvaWQpCnsKCXJldHVybiAhYWNjZXNzKGdpdF9wYXRoX21lcmdlX2hlYWQodGhlX3JlcG9zaXRvcnkpLCBGX09LKTsKfQoKc3RhdGljIGludCByZXNldF9pbmRleChjb25zdCBjaGFyICpyZWYsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgaW50IHJlc2V0X3R5cGUsIGludCBxdWlldCkKewoJaW50IGksIG5yID0gMDsKCXN0cnVjdCB0cmVlX2Rlc2MgZGVzY1syXTsKCXN0cnVjdCB0cmVlICp0cmVlOwoJc3RydWN0IHVucGFja190cmVlc19vcHRpb25zIG9wdHM7CglpbnQgcmV0ID0gLTE7CgoJbWVtc2V0KCZvcHRzLCAwLCBzaXplb2Yob3B0cykpOwoJb3B0cy5oZWFkX2lkeCA9IDE7CglvcHRzLnNyY19pbmRleCA9IHRoZV9yZXBvc2l0b3J5LT5pbmRleDsKCW9wdHMuZHN0X2luZGV4ID0gdGhlX3JlcG9zaXRvcnktPmluZGV4OwoJb3B0cy5mbiA9IG9uZXdheV9tZXJnZTsKCW9wdHMubWVyZ2UgPSAxOwoJaW5pdF9jaGVja291dF9tZXRhZGF0YSgmb3B0cy5tZXRhLCByZWYsIG9pZCwgTlVMTCk7CglpZiAoIXF1aWV0KQoJCW9wdHMudmVyYm9zZV91cGRhdGUgPSAxOwoJc3dpdGNoIChyZXNldF90eXBlKSB7CgljYXNlIEtFRVA6CgljYXNlIE1FUkdFOgoJCW9wdHMudXBkYXRlID0gMTsKCQlvcHRzLnByZXNlcnZlX2lnbm9yZWQgPSAwOyAvKiBGSVhNRTogIW92ZXJ3cml0ZV9pZ25vcmUgKi8KCQlicmVhazsKCWNhc2UgSEFSRDoKCQlvcHRzLnVwZGF0ZSA9IDE7CgkJb3B0cy5yZXNldCA9IFVOUEFDS19SRVNFVF9PVkVSV1JJVEVfVU5UUkFDS0VEOwoJCW9wdHMuc2tpcF9jYWNoZV90cmVlX3VwZGF0ZSA9IDE7CgkJYnJlYWs7CgljYXNlIE1JWEVEOgoJCW9wdHMucmVzZXQgPSBVTlBBQ0tfUkVTRVRfUFJPVEVDVF9VTlRSQUNLRUQ7CgkJb3B0cy5za2lwX2NhY2hlX3RyZWVfdXBkYXRlID0gMTsKCQkvKiBidXQgb3B0cy51cGRhdGU9MCwgc28gd29ya2luZyB0cmVlIG5vdCB1cGRhdGVkICovCgkJYnJlYWs7CglkZWZhdWx0OgoJCUJVRygiaW52YWxpZCByZXNldF90eXBlIHBhc3NlZCB0byByZXNldF9pbmRleCIpOwoJfQoKCXJlcG9fcmVhZF9pbmRleF91bm1lcmdlZCh0aGVfcmVwb3NpdG9yeSk7CgoJaWYgKHJlc2V0X3R5cGUgPT0gS0VFUCkgewoJCXN0cnVjdCBvYmplY3RfaWQgaGVhZF9vaWQ7CgkJaWYgKHJlcG9fZ2V0X29pZCh0aGVfcmVwb3NpdG9yeSwgIkhFQUQiLCAmaGVhZF9vaWQpKQoJCQlyZXR1cm4gZXJyb3IoXygiWW91IGRvIG5vdCBoYXZlIGEgdmFsaWQgSEVBRC4iKSk7CgkJaWYgKCFmaWxsX3RyZWVfZGVzY3JpcHRvcih0aGVfcmVwb3NpdG9yeSwgZGVzYyArIG5yLCAmaGVhZF9vaWQpKQoJCQlyZXR1cm4gZXJyb3IoXygiRmFpbGVkIHRvIGZpbmQgdHJlZSBvZiBIRUFELiIpKTsKCQlucisrOwoJCW9wdHMuZm4gPSB0d293YXlfbWVyZ2U7Cgl9CgoJaWYgKCFmaWxsX3RyZWVfZGVzY3JpcHRvcih0aGVfcmVwb3NpdG9yeSwgZGVzYyArIG5yLCBvaWQpKSB7CgkJZXJyb3IoXygiRmFpbGVkIHRvIGZpbmQgdHJlZSBvZiAlcy4iKSwgb2lkX3RvX2hleChvaWQpKTsKCQlnb3RvIG91dDsKCX0KCW5yKys7CgoJaWYgKHVucGFja190cmVlcyhuciwgZGVzYywgJm9wdHMpKQoJCWdvdG8gb3V0OwoKCWlmIChyZXNldF90eXBlID09IE1JWEVEIHx8IHJlc2V0X3R5cGUgPT0gSEFSRCkgewoJCXRyZWUgPSBwYXJzZV90cmVlX2luZGlyZWN0KG9pZCk7CgkJaWYgKCF0cmVlKSB7CgkJCWVycm9yKF8oInVuYWJsZSB0byByZWFkIHRyZWUgKCVzKSIpLCBvaWRfdG9faGV4KG9pZCkpOwoJCQlnb3RvIG91dDsKCQl9CgkJcHJpbWVfY2FjaGVfdHJlZSh0aGVfcmVwb3NpdG9yeSwgdGhlX3JlcG9zaXRvcnktPmluZGV4LCB0cmVlKTsKCX0KCglyZXQgPSAwOwoKb3V0OgoJZm9yIChpID0gMDsgaSA8IG5yOyBpKyspCgkJZnJlZSgodm9pZCAqKWRlc2NbaV0uYnVmZmVyKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyB2b2lkIHByaW50X25ld19oZWFkX2xpbmUoc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoKCXByaW50ZihfKCJIRUFEIGlzIG5vdyBhdCAlcyIpLAoJCXJlcG9fZmluZF91bmlxdWVfYWJicmV2KHRoZV9yZXBvc2l0b3J5LCAmY29tbWl0LT5vYmplY3Qub2lkLCBERUZBVUxUX0FCQlJFVikpOwoKCXBwX2NvbW1pdF9lYXN5KENNSVRfRk1UX09ORUxJTkUsIGNvbW1pdCwgJmJ1Zik7CglpZiAoYnVmLmxlbiA+IDApCgkJcHJpbnRmKCIgJXMiLCBidWYuYnVmKTsKCXB1dGNoYXIoJ1xuJyk7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKfQoKc3RhdGljIHZvaWQgdXBkYXRlX2luZGV4X2Zyb21fZGlmZihzdHJ1Y3QgZGlmZl9xdWV1ZV9zdHJ1Y3QgKnEsCgkJCQkgICBzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHQgVU5VU0VELAoJCQkJICAgdm9pZCAqZGF0YSkKewoJaW50IGk7CglpbnQgaW50ZW50X3RvX2FkZCA9ICooaW50ICopZGF0YTsKCglmb3IgKGkgPSAwOyBpIDwgcS0+bnI7IGkrKykgewoJCWludCBwb3M7CgkJc3RydWN0IGRpZmZfZmlsZXNwZWMgKm9uZSA9IHEtPnF1ZXVlW2ldLT5vbmU7CgkJaW50IGlzX2luX3Jlc2V0X3RyZWUgPSBvbmUtPm1vZGUgJiYgIWlzX251bGxfb2lkKCZvbmUtPm9pZCk7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZTsKCgkJaWYgKCFpc19pbl9yZXNldF90cmVlICYmICFpbnRlbnRfdG9fYWRkKSB7CgkJCXJlbW92ZV9maWxlX2Zyb21faW5kZXgodGhlX3JlcG9zaXRvcnktPmluZGV4LCBvbmUtPnBhdGgpOwoJCQljb250aW51ZTsKCQl9CgoJCWNlID0gbWFrZV9jYWNoZV9lbnRyeSh0aGVfcmVwb3NpdG9yeS0+aW5kZXgsIG9uZS0+bW9kZSwgJm9uZS0+b2lkLCBvbmUtPnBhdGgsCgkJCQkgICAgICAwLCAwKTsKCgkJLyoKCQkgKiBJZiB0aGUgZmlsZSAxKSBjb3JyZXNwb25kcyB0byBhbiBleGlzdGluZyBpbmRleCBlbnRyeSB3aXRoCgkJICogc2tpcC13b3JrdHJlZSBzZXQsIG9yIDIpIGRvZXMgbm90IGV4aXN0IGluIHRoZSBpbmRleCBidXQgaXMKCQkgKiBvdXRzaWRlIHRoZSBzcGFyc2UgY2hlY2tvdXQgZGVmaW5pdGlvbiwgYWRkIGEgc2tpcC13b3JrdHJlZSBiaXQKCQkgKiB0byB0aGUgbmV3IGluZGV4IGVudHJ5LiBOb3RlIHRoYXQgYSBzcGFyc2UgaW5kZXggd2lsbCBiZSBleHBhbmRlZAoJCSAqIGlmIHRoaXMgZW50cnkgaXMgb3V0c2lkZSB0aGUgc3BhcnNlIGNvbmUgLSB0aGlzIGlzIG5lY2Vzc2FyeQoJCSAqIHRvIHByb3Blcmx5IGNvbnN0cnVjdCB0aGUgcmVzZXQgc3BhcnNlIGRpcmVjdG9yeS4KCQkgKi8KCQlwb3MgPSBpbmRleF9uYW1lX3Bvcyh0aGVfcmVwb3NpdG9yeS0+aW5kZXgsIG9uZS0+cGF0aCwgc3RybGVuKG9uZS0+cGF0aCkpOwoJCWlmICgocG9zID49IDAgJiYgY2Vfc2tpcF93b3JrdHJlZSh0aGVfcmVwb3NpdG9yeS0+aW5kZXgtPmNhY2hlW3Bvc10pKSB8fAoJCSAgICAocG9zIDwgMCAmJiAhcGF0aF9pbl9zcGFyc2VfY2hlY2tvdXQob25lLT5wYXRoLCB0aGVfcmVwb3NpdG9yeS0+aW5kZXgpKSkKCQkJY2UtPmNlX2ZsYWdzIHw9IENFX1NLSVBfV09SS1RSRUU7CgoJCWlmICghY2UpCgkJCWRpZShfKCJtYWtlX2NhY2hlX2VudHJ5IGZhaWxlZCBmb3IgcGF0aCAnJXMnIiksCgkJCSAgICBvbmUtPnBhdGgpOwoJCWlmICghaXNfaW5fcmVzZXRfdHJlZSkgewoJCQljZS0+Y2VfZmxhZ3MgfD0gQ0VfSU5URU5UX1RPX0FERDsKCQkJc2V0X29iamVjdF9uYW1lX2Zvcl9pbnRlbnRfdG9fYWRkX2VudHJ5KGNlKTsKCQl9CgkJYWRkX2luZGV4X2VudHJ5KHRoZV9yZXBvc2l0b3J5LT5pbmRleCwgY2UsCgkJCQlBRERfQ0FDSEVfT0tfVE9fQUREIHwgQUREX0NBQ0hFX09LX1RPX1JFUExBQ0UpOwoJfQp9CgpzdGF0aWMgaW50IHJlYWRfZnJvbV90cmVlKGNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcGF0aHNwZWMsCgkJCSAgc3RydWN0IG9iamVjdF9pZCAqdHJlZV9vaWQsCgkJCSAgaW50IGludGVudF90b19hZGQpCnsKCXN0cnVjdCBkaWZmX29wdGlvbnMgb3B0OwoKCW1lbXNldCgmb3B0LCAwLCBzaXplb2Yob3B0KSk7Cgljb3B5X3BhdGhzcGVjKCZvcHQucGF0aHNwZWMsIHBhdGhzcGVjKTsKCW9wdC5vdXRwdXRfZm9ybWF0ID0gRElGRl9GT1JNQVRfQ0FMTEJBQ0s7CglvcHQuZm9ybWF0X2NhbGxiYWNrID0gdXBkYXRlX2luZGV4X2Zyb21fZGlmZjsKCW9wdC5mb3JtYXRfY2FsbGJhY2tfZGF0YSA9ICZpbnRlbnRfdG9fYWRkOwoJb3B0LmZsYWdzLm92ZXJyaWRlX3N1Ym1vZHVsZV9jb25maWcgPSAxOwoJb3B0LmZsYWdzLnJlY3Vyc2l2ZSA9IDE7CglvcHQucmVwbyA9IHRoZV9yZXBvc2l0b3J5OwoJb3B0LmNoYW5nZSA9IGRpZmZfY2hhbmdlOwoJb3B0LmFkZF9yZW1vdmUgPSBkaWZmX2FkZHJlbW92ZTsKCglpZiAocGF0aHNwZWMtPm5yICYmIHBhdGhzcGVjX25lZWRzX2V4cGFuZGVkX2luZGV4KHRoZV9yZXBvc2l0b3J5LT5pbmRleCwgcGF0aHNwZWMpKQoJCWVuc3VyZV9mdWxsX2luZGV4KHRoZV9yZXBvc2l0b3J5LT5pbmRleCk7CgoJaWYgKGRvX2RpZmZfY2FjaGUodHJlZV9vaWQsICZvcHQpKQoJCXJldHVybiAxOwoJZGlmZmNvcmVfc3RkKCZvcHQpOwoJZGlmZl9mbHVzaCgmb3B0KTsKCglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgc2V0X3JlZmxvZ19tZXNzYWdlKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICphY3Rpb24sCgkJCSAgICAgICBjb25zdCBjaGFyICpyZXYpCnsKCWNvbnN0IGNoYXIgKnJsYSA9IGdldGVudigiR0lUX1JFRkxPR19BQ1RJT04iKTsKCglzdHJidWZfcmVzZXQoc2IpOwoJaWYgKHJsYSkKCQlzdHJidWZfYWRkZihzYiwgIiVzOiAlcyIsIHJsYSwgYWN0aW9uKTsKCWVsc2UgaWYgKHJldikKCQlzdHJidWZfYWRkZihzYiwgInJlc2V0OiBtb3ZpbmcgdG8gJXMiLCByZXYpOwoJZWxzZQoJCXN0cmJ1Zl9hZGRmKHNiLCAicmVzZXQ6ICVzIiwgYWN0aW9uKTsKfQoKc3RhdGljIHZvaWQgZGllX2lmX3VubWVyZ2VkX2NhY2hlKGludCByZXNldF90eXBlKQp7CglpZiAoaXNfbWVyZ2UoKSB8fCB1bm1lcmdlZF9pbmRleCh0aGVfcmVwb3NpdG9yeS0+aW5kZXgpKQoJCWRpZShfKCJDYW5ub3QgZG8gYSAlcyByZXNldCBpbiB0aGUgbWlkZGxlIG9mIGEgbWVyZ2UuIiksCgkJICAgIF8ocmVzZXRfdHlwZV9uYW1lc1tyZXNldF90eXBlXSkpOwoKfQoKc3RhdGljIHZvaWQgcGFyc2VfYXJncyhzdHJ1Y3QgcGF0aHNwZWMgKnBhdGhzcGVjLAoJCSAgICAgICBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4LAoJCSAgICAgICBpbnQgcGF0Y2hfbW9kZSwKCQkgICAgICAgY29uc3QgY2hhciAqKnJldl9yZXQpCnsKCWNvbnN0IGNoYXIgKnJldiA9ICJIRUFEIjsKCXN0cnVjdCBvYmplY3RfaWQgdW51c2VkOwoJLyoKCSAqIFBvc3NpYmxlIGFyZ3VtZW50cyBhcmU6CgkgKgoJICogZ2l0IHJlc2V0IFstb3B0c10gWzxyZXY+XQoJICogZ2l0IHJlc2V0IFstb3B0c10gPHRyZWU+IFs8cGF0aHM+Li4uXQoJICogZ2l0IHJlc2V0IFstb3B0c10gPHRyZWU+IC0tIFs8cGF0aHM+Li4uXQoJICogZ2l0IHJlc2V0IFstb3B0c10gLS0gWzxwYXRocz4uLi5dCgkgKiBnaXQgcmVzZXQgWy1vcHRzXSA8cGF0aHM+Li4uCgkgKgoJICogQXQgdGhpcyBwb2ludCwgYXJndiBwb2ludHMgaW1tZWRpYXRlbHkgYWZ0ZXIgWy1vcHRzXS4KCSAqLwoKCWlmIChhcmd2WzBdKSB7CgkJaWYgKCFzdHJjbXAoYXJndlswXSwgIi0tIikpIHsKCQkJYXJndisrOyAvKiByZXNldCB0byBIRUFELCBwb3NzaWJseSB3aXRoIHBhdGhzICovCgkJfSBlbHNlIGlmIChhcmd2WzFdICYmICFzdHJjbXAoYXJndlsxXSwgIi0tIikpIHsKCQkJcmV2ID0gYXJndlswXTsKCQkJYXJndiArPSAyOwoJCX0KCQkvKgoJCSAqIE90aGVyd2lzZSwgYXJndlswXSBjb3VsZCBiZSBlaXRoZXIgPHJldj4gb3IgPHBhdGhzPiBhbmQKCQkgKiBoYXMgdG8gYmUgdW5hbWJpZ3VvdXMuIElmIHRoZXJlIGlzIGEgc2luZ2xlIGFyZ3VtZW50LCBpdAoJCSAqIGNhbiBub3QgYmUgYSB0cmVlCgkJICovCgkJZWxzZSBpZiAoKCFhcmd2WzFdICYmICFyZXBvX2dldF9vaWRfY29tbWl0dGlzaCh0aGVfcmVwb3NpdG9yeSwgYXJndlswXSwgJnVudXNlZCkpIHx8CgkJCSAoYXJndlsxXSAmJiAhcmVwb19nZXRfb2lkX3RyZWVpc2godGhlX3JlcG9zaXRvcnksIGFyZ3ZbMF0sICZ1bnVzZWQpKSkgewoJCQkvKgoJCQkgKiBPaywgYXJndlswXSBsb29rcyBsaWtlIGEgY29tbWl0L3RyZWU7IGl0IHNob3VsZCBub3QKCQkJICogYmUgYSBmaWxlbmFtZS4KCQkJICovCgkJCXZlcmlmeV9ub25fZmlsZW5hbWUocHJlZml4LCBhcmd2WzBdKTsKCQkJcmV2ID0gKmFyZ3YrKzsKCQl9IGVsc2UgewoJCQkvKiBPdGhlcndpc2Ugd2UgdHJlYXQgdGhpcyBhcyBhIGZpbGVuYW1lICovCgkJCXZlcmlmeV9maWxlbmFtZShwcmVmaXgsIGFyZ3ZbMF0sIDEpOwoJCX0KCX0KCgkvKiB0cmVhdCAnQCcgYXMgYSBzaG9ydGN1dCBmb3IgJ0hFQUQnICovCgkqcmV2X3JldCA9ICFzdHJjbXAoIkAiLCByZXYpID8gIkhFQUQiIDogcmV2OwoKCXBhcnNlX3BhdGhzcGVjKHBhdGhzcGVjLCAwLAoJCSAgICAgICBQQVRIU1BFQ19QUkVGRVJfRlVMTCB8CgkJICAgICAgIChwYXRjaF9tb2RlID8gUEFUSFNQRUNfUFJFRklYX09SSUdJTiA6IDApLAoJCSAgICAgICBwcmVmaXgsIGFyZ3YpOwp9CgpzdGF0aWMgaW50IHJlc2V0X3JlZnMoY29uc3QgY2hhciAqcmV2LCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCWludCB1cGRhdGVfcmVmX3N0YXR1czsKCXN0cnVjdCBzdHJidWYgbXNnID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgb2JqZWN0X2lkICpvcmlnID0gTlVMTCwgb2lkX29yaWcsCgkJKm9sZF9vcmlnID0gTlVMTCwgb2lkX29sZF9vcmlnOwoKCWlmICghcmVwb19nZXRfb2lkKHRoZV9yZXBvc2l0b3J5LCAiT1JJR19IRUFEIiwgJm9pZF9vbGRfb3JpZykpCgkJb2xkX29yaWcgPSAmb2lkX29sZF9vcmlnOwoJaWYgKCFyZXBvX2dldF9vaWQodGhlX3JlcG9zaXRvcnksICJIRUFEIiwgJm9pZF9vcmlnKSkgewoJCW9yaWcgPSAmb2lkX29yaWc7CgkJc2V0X3JlZmxvZ19tZXNzYWdlKCZtc2csICJ1cGRhdGluZyBPUklHX0hFQUQiLCBOVUxMKTsKCQlyZWZzX3VwZGF0ZV9yZWYoZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KSwgbXNnLmJ1ZiwKCQkJCSJPUklHX0hFQUQiLCBvcmlnLCBvbGRfb3JpZywgMCwKCQkJCVVQREFURV9SRUZTX01TR19PTl9FUlIpOwoJfSBlbHNlIGlmIChvbGRfb3JpZykKCQlyZWZzX2RlbGV0ZV9yZWYoZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KSwgTlVMTCwKCQkJCSJPUklHX0hFQUQiLCBvbGRfb3JpZywgMCk7CglzZXRfcmVmbG9nX21lc3NhZ2UoJm1zZywgInVwZGF0aW5nIEhFQUQiLCByZXYpOwoJdXBkYXRlX3JlZl9zdGF0dXMgPSByZWZzX3VwZGF0ZV9yZWYoZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KSwKCQkJCQkgICAgbXNnLmJ1ZiwgIkhFQUQiLCBvaWQsIG9yaWcsIDAsCgkJCQkJICAgIFVQREFURV9SRUZTX01TR19PTl9FUlIpOwoJc3RyYnVmX3JlbGVhc2UoJm1zZyk7CglyZXR1cm4gdXBkYXRlX3JlZl9zdGF0dXM7Cn0KCnN0YXRpYyBpbnQgZ2l0X3Jlc2V0X2NvbmZpZyhjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlLAoJCQkgICAgY29uc3Qgc3RydWN0IGNvbmZpZ19jb250ZXh0ICpjdHgsIHZvaWQgKmNiKQp7CglpZiAoIXN0cmNtcCh2YXIsICJzdWJtb2R1bGUucmVjdXJzZSIpKQoJCXJldHVybiBnaXRfZGVmYXVsdF9zdWJtb2R1bGVfY29uZmlnKHZhciwgdmFsdWUsIGNiKTsKCglyZXR1cm4gZ2l0X2RlZmF1bHRfY29uZmlnKHZhciwgdmFsdWUsIGN0eCwgY2IpOwp9CgppbnQgY21kX3Jlc2V0KGludCBhcmdjLAoJICAgICAgY29uc3QgY2hhciAqKmFyZ3YsCgkgICAgICBjb25zdCBjaGFyICpwcmVmaXgsCgkgICAgICBzdHJ1Y3QgcmVwb3NpdG9yeSAqcmVwbyBVTlVTRUQpCnsKCWludCByZXNldF90eXBlID0gTk9ORSwgdXBkYXRlX3JlZl9zdGF0dXMgPSAwLCBxdWlldCA9IDA7CglpbnQgbm9fcmVmcmVzaCA9IDA7CglpbnQgcGF0Y2hfbW9kZSA9IDAsIHBhdGhzcGVjX2ZpbGVfbnVsID0gMCwgdW5ib3JuOwoJY29uc3QgY2hhciAqcmV2OwoJY2hhciAqcGF0aHNwZWNfZnJvbV9maWxlID0gTlVMTDsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJc3RydWN0IHBhdGhzcGVjIHBhdGhzcGVjOwoJaW50IGludGVudF90b19hZGQgPSAwOwoJY29uc3Qgc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJT1BUX19RVUlFVCgmcXVpZXQsIE5fKCJiZSBxdWlldCwgb25seSByZXBvcnQgZXJyb3JzIikpLAoJCU9QVF9CT09MKDAsICJuby1yZWZyZXNoIiwgJm5vX3JlZnJlc2gsCgkJCQlOXygic2tpcCByZWZyZXNoaW5nIHRoZSBpbmRleCBhZnRlciByZXNldCIpKSwKCQlPUFRfU0VUX0lOVF9GKDAsICJtaXhlZCIsICZyZXNldF90eXBlLAoJCQkgICAgICBOXygicmVzZXQgSEVBRCBhbmQgaW5kZXgiKSwKCQkJICAgICAgTUlYRUQsIFBBUlNFX09QVF9OT05FRyksCgkJT1BUX1NFVF9JTlRfRigwLCAic29mdCIsICZyZXNldF90eXBlLAoJCQkgICAgICBOXygicmVzZXQgb25seSBIRUFEIiksCgkJCSAgICAgIFNPRlQsIFBBUlNFX09QVF9OT05FRyksCgkJT1BUX1NFVF9JTlRfRigwLCAiaGFyZCIsICZyZXNldF90eXBlLAoJCQkgICAgICBOXygicmVzZXQgSEVBRCwgaW5kZXggYW5kIHdvcmtpbmcgdHJlZSIpLAoJCQkgICAgICBIQVJELCBQQVJTRV9PUFRfTk9ORUcpLAoJCU9QVF9TRVRfSU5UX0YoMCwgIm1lcmdlIiwgJnJlc2V0X3R5cGUsCgkJCSAgICAgIE5fKCJyZXNldCBIRUFELCBpbmRleCBhbmQgd29ya2luZyB0cmVlIiksCgkJCSAgICAgIE1FUkdFLCBQQVJTRV9PUFRfTk9ORUcpLAoJCU9QVF9TRVRfSU5UX0YoMCwgImtlZXAiLCAmcmVzZXRfdHlwZSwKCQkJICAgICAgTl8oInJlc2V0IEhFQUQgYnV0IGtlZXAgbG9jYWwgY2hhbmdlcyIpLAoJCQkgICAgICBLRUVQLCBQQVJTRV9PUFRfTk9ORUcpLAoJCU9QVF9DQUxMQkFDS19GKDAsICJyZWN1cnNlLXN1Ym1vZHVsZXMiLCBOVUxMLAoJCQkgICAgICAgInJlc2V0IiwgImNvbnRyb2wgcmVjdXJzaXZlIHVwZGF0aW5nIG9mIHN1Ym1vZHVsZXMiLAoJCQkgICAgICAgUEFSU0VfT1BUX09QVEFSRywKCQkJICAgICAgIG9wdGlvbl9wYXJzZV9yZWN1cnNlX3N1Ym1vZHVsZXNfd29ya3RyZWVfdXBkYXRlciksCgkJT1BUX0JPT0woJ3AnLCAicGF0Y2giLCAmcGF0Y2hfbW9kZSwgTl8oInNlbGVjdCBodW5rcyBpbnRlcmFjdGl2ZWx5IikpLAoJCU9QVF9CT09MKCdOJywgImludGVudC10by1hZGQiLCAmaW50ZW50X3RvX2FkZCwKCQkJCU5fKCJyZWNvcmQgb25seSB0aGUgZmFjdCB0aGF0IHJlbW92ZWQgcGF0aHMgd2lsbCBiZSBhZGRlZCBsYXRlciIpKSwKCQlPUFRfUEFUSFNQRUNfRlJPTV9GSUxFKCZwYXRoc3BlY19mcm9tX2ZpbGUpLAoJCU9QVF9QQVRIU1BFQ19GSUxFX05VTCgmcGF0aHNwZWNfZmlsZV9udWwpLAoJCU9QVF9FTkQoKQoJfTsKCglyZXBvX2NvbmZpZyh0aGVfcmVwb3NpdG9yeSwgZ2l0X3Jlc2V0X2NvbmZpZywgTlVMTCk7CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBvcHRpb25zLCBnaXRfcmVzZXRfdXNhZ2UsCgkJCQkJCVBBUlNFX09QVF9LRUVQX0RBU0hEQVNIKTsKCXBhcnNlX2FyZ3MoJnBhdGhzcGVjLCBhcmd2LCBwcmVmaXgsIHBhdGNoX21vZGUsICZyZXYpOwoKCWlmIChwYXRoc3BlY19mcm9tX2ZpbGUpIHsKCQlpZiAocGF0Y2hfbW9kZSkKCQkJZGllKF8oIm9wdGlvbnMgJyVzJyBhbmQgJyVzJyBjYW5ub3QgYmUgdXNlZCB0b2dldGhlciIpLCAiLS1wYXRoc3BlYy1mcm9tLWZpbGUiLCAiLS1wYXRjaCIpOwoKCQlpZiAocGF0aHNwZWMubnIpCgkJCWRpZShfKCInJXMnIGFuZCBwYXRoc3BlYyBhcmd1bWVudHMgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIiKSwgIi0tcGF0aHNwZWMtZnJvbS1maWxlIik7CgoJCXBhcnNlX3BhdGhzcGVjX2ZpbGUoJnBhdGhzcGVjLCAwLAoJCQkJICAgIFBBVEhTUEVDX1BSRUZFUl9GVUxMLAoJCQkJICAgIHByZWZpeCwgcGF0aHNwZWNfZnJvbV9maWxlLCBwYXRoc3BlY19maWxlX251bCk7Cgl9IGVsc2UgaWYgKHBhdGhzcGVjX2ZpbGVfbnVsKSB7CgkJZGllKF8oInRoZSBvcHRpb24gJyVzJyByZXF1aXJlcyAnJXMnIiksICItLXBhdGhzcGVjLWZpbGUtbnVsIiwgIi0tcGF0aHNwZWMtZnJvbS1maWxlIik7Cgl9CgoJdW5ib3JuID0gIXN0cmNtcChyZXYsICJIRUFEIikgJiYgcmVwb19nZXRfb2lkKHRoZV9yZXBvc2l0b3J5LCAiSEVBRCIsCgkJCQkJCSAgICAgICZvaWQpOwoJaWYgKHVuYm9ybikgewoJCS8qIHJlc2V0IG9uIHVuYm9ybiBicmFuY2g6IHRyZWF0IGFzIHJlc2V0IHRvIGVtcHR5IHRyZWUgKi8KCQlvaWRjcHkoJm9pZCwgdGhlX2hhc2hfYWxnby0+ZW1wdHlfdHJlZSk7Cgl9IGVsc2UgaWYgKCFwYXRoc3BlYy5uciAmJiAhcGF0Y2hfbW9kZSkgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCQlpZiAocmVwb19nZXRfb2lkX2NvbW1pdHRpc2godGhlX3JlcG9zaXRvcnksIHJldiwgJm9pZCkpCgkJCWRpZShfKCJGYWlsZWQgdG8gcmVzb2x2ZSAnJXMnIGFzIGEgdmFsaWQgcmV2aXNpb24uIiksIHJldik7CgkJY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2UodGhlX3JlcG9zaXRvcnksICZvaWQpOwoJCWlmICghY29tbWl0KQoJCQlkaWUoXygiQ291bGQgbm90IHBhcnNlIG9iamVjdCAnJXMnLiIpLCByZXYpOwoJCW9pZGNweSgmb2lkLCAmY29tbWl0LT5vYmplY3Qub2lkKTsKCX0gZWxzZSB7CgkJc3RydWN0IHRyZWUgKnRyZWU7CgkJaWYgKHJlcG9fZ2V0X29pZF90cmVlaXNoKHRoZV9yZXBvc2l0b3J5LCByZXYsICZvaWQpKQoJCQlkaWUoXygiRmFpbGVkIHRvIHJlc29sdmUgJyVzJyBhcyBhIHZhbGlkIHRyZWUuIiksIHJldik7CgkJdHJlZSA9IHBhcnNlX3RyZWVfaW5kaXJlY3QoJm9pZCk7CgkJaWYgKCF0cmVlKQoJCQlkaWUoXygiQ291bGQgbm90IHBhcnNlIG9iamVjdCAnJXMnLiIpLCByZXYpOwoJCW9pZGNweSgmb2lkLCAmdHJlZS0+b2JqZWN0Lm9pZCk7Cgl9CgoJcHJlcGFyZV9yZXBvX3NldHRpbmdzKHRoZV9yZXBvc2l0b3J5KTsKCXRoZV9yZXBvc2l0b3J5LT5zZXR0aW5ncy5jb21tYW5kX3JlcXVpcmVzX2Z1bGxfaW5kZXggPSAwOwoKCWlmIChwYXRjaF9tb2RlKSB7CgkJaWYgKHJlc2V0X3R5cGUgIT0gTk9ORSkKCQkJZGllKF8oIm9wdGlvbnMgJyVzJyBhbmQgJyVzJyBjYW5ub3QgYmUgdXNlZCB0b2dldGhlciIpLCAiLS1wYXRjaCIsICItLXtoYXJkLG1peGVkLHNvZnR9Iik7CgkJdHJhY2UyX2NtZF9tb2RlKCJwYXRjaC1pbnRlcmFjdGl2ZSIpOwoJCXVwZGF0ZV9yZWZfc3RhdHVzID0gISFydW5fYWRkX3AodGhlX3JlcG9zaXRvcnksIEFERF9QX1JFU0VULCByZXYsCgkJCQkgICAmcGF0aHNwZWMpOwoJCWdvdG8gY2xlYW51cDsKCX0KCgkvKiBnaXQgcmVzZXQgdHJlZSBbLS1dIHBhdGhzLi4uIGNhbiBiZSB1c2VkIHRvCgkgKiBsb2FkIGNob3NlbiBwYXRocyBmcm9tIHRoZSB0cmVlIGludG8gdGhlIGluZGV4IHdpdGhvdXQKCSAqIGFmZmVjdGluZyB0aGUgd29ya2luZyB0cmVlIG5vciBIRUFELiAqLwoJaWYgKHBhdGhzcGVjLm5yKSB7CgkJaWYgKHJlc2V0X3R5cGUgPT0gTUlYRUQpCgkJCXdhcm5pbmcoXygiLS1taXhlZCB3aXRoIHBhdGhzIGlzIGRlcHJlY2F0ZWQ7IHVzZSAnZ2l0IHJlc2V0IC0tIDxwYXRocz4nIGluc3RlYWQuIikpOwoJCWVsc2UgaWYgKHJlc2V0X3R5cGUgIT0gTk9ORSkKCQkJZGllKF8oIkNhbm5vdCBkbyAlcyByZXNldCB3aXRoIHBhdGhzLiIpLAoJCQkJCV8ocmVzZXRfdHlwZV9uYW1lc1tyZXNldF90eXBlXSkpOwoJfQoJaWYgKHJlc2V0X3R5cGUgPT0gTk9ORSkKCQlyZXNldF90eXBlID0gTUlYRUQ7IC8qIGJ5IGRlZmF1bHQgKi8KCglpZiAocGF0aHNwZWMubnIpCgkJdHJhY2UyX2NtZF9tb2RlKCJwYXRoIik7CgllbHNlCgkJdHJhY2UyX2NtZF9tb2RlKHJlc2V0X3R5cGVfbmFtZXNbcmVzZXRfdHlwZV0pOwoKCWlmIChyZXNldF90eXBlICE9IFNPRlQgJiYgKHJlc2V0X3R5cGUgIT0gTUlYRUQgfHwgcmVwb19nZXRfd29ya190cmVlKHRoZV9yZXBvc2l0b3J5KSkpCgkJc2V0dXBfd29ya190cmVlKCk7CgoJaWYgKHJlc2V0X3R5cGUgPT0gTUlYRUQgJiYgaXNfYmFyZV9yZXBvc2l0b3J5KCkpCgkJZGllKF8oIiVzIHJlc2V0IGlzIG5vdCBhbGxvd2VkIGluIGEgYmFyZSByZXBvc2l0b3J5IiksCgkJICAgIF8ocmVzZXRfdHlwZV9uYW1lc1tyZXNldF90eXBlXSkpOwoKCWlmIChpbnRlbnRfdG9fYWRkICYmIHJlc2V0X3R5cGUgIT0gTUlYRUQpCgkJZGllKF8oInRoZSBvcHRpb24gJyVzJyByZXF1aXJlcyAnJXMnIiksICItTiIsICItLW1peGVkIik7CgoJaWYgKHJlcG9fcmVhZF9pbmRleCh0aGVfcmVwb3NpdG9yeSkgPCAwKQoJCWRpZShfKCJpbmRleCBmaWxlIGNvcnJ1cHQiKSk7CgoJLyogU29mdCByZXNldCBkb2VzIG5vdCB0b3VjaCB0aGUgaW5kZXggZmlsZSBub3IgdGhlIHdvcmtpbmcgdHJlZQoJICogYXQgYWxsLCBidXQgcmVxdWlyZXMgdGhlbSBpbiBhIGdvb2Qgb3JkZXIuICBPdGhlciByZXNldHMgcmVzZXQKCSAqIHRoZSBpbmRleCBmaWxlIHRvIHRoZSB0cmVlIG9iamVjdCB3ZSBhcmUgc3dpdGNoaW5nIHRvLiAqLwoJaWYgKHJlc2V0X3R5cGUgPT0gU09GVCB8fCByZXNldF90eXBlID09IEtFRVApCgkJZGllX2lmX3VubWVyZ2VkX2NhY2hlKHJlc2V0X3R5cGUpOwoKCWlmIChyZXNldF90eXBlICE9IFNPRlQpIHsKCQlzdHJ1Y3QgbG9ja19maWxlIGxvY2sgPSBMT0NLX0lOSVQ7CgkJcmVwb19ob2xkX2xvY2tlZF9pbmRleCh0aGVfcmVwb3NpdG9yeSwgJmxvY2ssCgkJCQkgICAgICAgTE9DS19ESUVfT05fRVJST1IpOwoJCWlmIChyZXNldF90eXBlID09IE1JWEVEKSB7CgkJCWludCBmbGFncyA9IHF1aWV0ID8gUkVGUkVTSF9RVUlFVCA6IFJFRlJFU0hfSU5fUE9SQ0VMQUlOOwoJCQlpZiAocmVhZF9mcm9tX3RyZWUoJnBhdGhzcGVjLCAmb2lkLCBpbnRlbnRfdG9fYWRkKSkgewoJCQkJdXBkYXRlX3JlZl9zdGF0dXMgPSAxOwoJCQkJZ290byBjbGVhbnVwOwoJCQl9CgkJCXRoZV9yZXBvc2l0b3J5LT5pbmRleC0+dXBkYXRlZF9za2lwd29ya3RyZWUgPSAxOwoJCQlpZiAoIW5vX3JlZnJlc2ggJiYgcmVwb19nZXRfd29ya190cmVlKHRoZV9yZXBvc2l0b3J5KSkgewoJCQkJdWludDY0X3QgdF9iZWdpbiwgdF9kZWx0YV9pbl9tczsKCgkJCQl0X2JlZ2luID0gZ2V0bmFub3RpbWUoKTsKCQkJCXJlZnJlc2hfaW5kZXgodGhlX3JlcG9zaXRvcnktPmluZGV4LCBmbGFncywgTlVMTCwgTlVMTCwKCQkJCQkgICAgICBfKCJVbnN0YWdlZCBjaGFuZ2VzIGFmdGVyIHJlc2V0OiIpKTsKCQkJCXRfZGVsdGFfaW5fbXMgPSAoZ2V0bmFub3RpbWUoKSAtIHRfYmVnaW4pIC8gMTAwMDAwMDsKCQkJCWlmICghcXVpZXQgJiYgYWR2aWNlX2VuYWJsZWQoQURWSUNFX1JFU0VUX05PX1JFRlJFU0hfV0FSTklORykgJiYgdF9kZWx0YV9pbl9tcyA+IFJFRlJFU0hfSU5ERVhfREVMQVlfV0FSTklOR19JTl9NUykgewoJCQkJCWFkdmlzZShfKCJJdCB0b29rICUuMmYgc2Vjb25kcyB0byByZWZyZXNoIHRoZSBpbmRleCBhZnRlciByZXNldC4gIFlvdSBjYW4gdXNlXG4iCgkJCQkJCSAiJy0tbm8tcmVmcmVzaCcgdG8gYXZvaWQgdGhpcy4iKSwgdF9kZWx0YV9pbl9tcyAvIDEwMDAuMCk7CgkJCQl9CgkJCX0KCQl9IGVsc2UgewoJCQlzdHJ1Y3Qgb2JqZWN0X2lkIGR1bW15OwoJCQljaGFyICpyZWYgPSBOVUxMOwoJCQlpbnQgZXJyOwoKCQkJcmVwb19kd2ltX3JlZih0aGVfcmVwb3NpdG9yeSwgcmV2LCBzdHJsZW4ocmV2KSwKCQkJCSAgICAgICZkdW1teSwgJnJlZiwgMCk7CgkJCWlmIChyZWYgJiYgIXN0YXJ0c193aXRoKHJlZiwgInJlZnMvIikpCgkJCQlGUkVFX0FORF9OVUxMKHJlZik7CgoJCQllcnIgPSByZXNldF9pbmRleChyZWYsICZvaWQsIHJlc2V0X3R5cGUsIHF1aWV0KTsKCQkJaWYgKHJlc2V0X3R5cGUgPT0gS0VFUCAmJiAhZXJyKQoJCQkJZXJyID0gcmVzZXRfaW5kZXgocmVmLCAmb2lkLCBNSVhFRCwgcXVpZXQpOwoJCQlpZiAoZXJyKQoJCQkJZGllKF8oIkNvdWxkIG5vdCByZXNldCBpbmRleCBmaWxlIHRvIHJldmlzaW9uICclcycuIiksIHJldik7CgkJCWZyZWUocmVmKTsKCQl9CgoJCWlmICh3cml0ZV9sb2NrZWRfaW5kZXgodGhlX3JlcG9zaXRvcnktPmluZGV4LCAmbG9jaywgQ09NTUlUX0xPQ0spKQoJCQlkaWUoXygiQ291bGQgbm90IHdyaXRlIG5ldyBpbmRleCBmaWxlLiIpKTsKCX0KCglpZiAoIXBhdGhzcGVjLm5yICYmICF1bmJvcm4pIHsKCQkvKiBBbnkgcmVzZXRzIHdpdGhvdXQgcGF0aHMgdXBkYXRlIEhFQUQgdG8gdGhlIGhlYWQgYmVpbmcKCQkgKiBzd2l0Y2hlZCB0bywgc2F2aW5nIHRoZSBwcmV2aW91cyBoZWFkIGluIE9SSUdfSEVBRCBiZWZvcmUuICovCgkJdXBkYXRlX3JlZl9zdGF0dXMgPSByZXNldF9yZWZzKHJldiwgJm9pZCk7CgoJCWlmIChyZXNldF90eXBlID09IEhBUkQgJiYgIXVwZGF0ZV9yZWZfc3RhdHVzICYmICFxdWlldCkKCQkJcHJpbnRfbmV3X2hlYWRfbGluZShsb29rdXBfY29tbWl0X3JlZmVyZW5jZSh0aGVfcmVwb3NpdG9yeSwgJm9pZCkpOwoJfQoJaWYgKCFwYXRoc3BlYy5ucikKCQlyZW1vdmVfYnJhbmNoX3N0YXRlKHRoZV9yZXBvc2l0b3J5LCAwKTsKCglkaXNjYXJkX2luZGV4KHRoZV9yZXBvc2l0b3J5LT5pbmRleCk7CgpjbGVhbnVwOgoJY2xlYXJfcGF0aHNwZWMoJnBhdGhzcGVjKTsKCWZyZWUocGF0aHNwZWNfZnJvbV9maWxlKTsKCXJldHVybiB1cGRhdGVfcmVmX3N0YXR1czsKfQo=",
    "text": "/*\n * \"git reset\" builtin command\n *\n * Copyright (c) 2007 Carlos Rica\n *\n * Based on git-reset.sh, which is\n *\n * Copyright (c) 2005, 2006 Linus Torvalds and Junio C Hamano\n */\n\n#define USE_THE_REPOSITORY_VARIABLE\n\n#include \"builtin.h\"\n#include \"advice.h\"\n#include \"config.h\"\n#include \"environment.h\"\n#include \"gettext.h\"\n#include \"hash.h\"\n#include \"hex.h\"\n#include \"lockfile.h\"\n#include \"object.h\"\n#include \"pretty.h\"\n#include \"refs.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"tree.h\"\n#include \"branch.h\"\n#include \"object-name.h\"\n#include \"parse-options.h\"\n#include \"path.h\"\n#include \"repository.h\"\n#include \"unpack-trees.h\"\n#include \"cache-tree.h\"\n#include \"setup.h\"\n#include \"sparse-index.h\"\n#include \"submodule.h\"\n#include \"trace.h\"\n#include \"trace2.h\"\n#include \"dir.h\"\n#include \"add-interactive.h\"\n\n#define REFRESH_INDEX_DELAY_WARNING_IN_MS (2 * 1000)\n\nstatic const char * const git_reset_usage[] = {\n\tN_(\"git reset [--mixed | --soft | --hard | --merge | --keep] [-q] [<commit>]\"),\n\tN_(\"git reset [-q] [<tree-ish>] [--] <pathspec>...\"),\n\tN_(\"git reset [-q] [--pathspec-from-file [--pathspec-file-nul]] [<tree-ish>]\"),\n\tN_(\"git reset --patch [<tree-ish>] [--] [<pathspec>...]\"),\n\tNULL\n};\n\nenum reset_type { MIXED, SOFT, HARD, MERGE, KEEP, NONE };\nstatic const char *reset_type_names[] = {\n\tN_(\"mixed\"), N_(\"soft\"), N_(\"hard\"), N_(\"merge\"), N_(\"keep\"), NULL\n};\n\nstatic inline int is_merge(void)\n{\n\treturn !access(git_path_merge_head(the_repository), F_OK);\n}\n\nstatic int reset_index(const char *ref, const struct object_id *oid, int reset_type, int quiet)\n{\n\tint i, nr = 0;\n\tstruct tree_desc desc[2];\n\tstruct tree *tree;\n\tstruct unpack_trees_options opts;\n\tint ret = -1;\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.head_idx = 1;\n\topts.src_index = the_repository->index;\n\topts.dst_index = the_repository->index;\n\topts.fn = oneway_merge;\n\topts.merge = 1;\n\tinit_checkout_metadata(&opts.meta, ref, oid, NULL);\n\tif (!quiet)\n\t\topts.verbose_update = 1;\n\tswitch (reset_type) {\n\tcase KEEP:\n\tcase MERGE:\n\t\topts.update = 1;\n\t\topts.preserve_ignored = 0; /* FIXME: !overwrite_ignore */\n\t\tbreak;\n\tcase HARD:\n\t\topts.update = 1;\n\t\topts.reset = UNPACK_RESET_OVERWRITE_UNTRACKED;\n\t\topts.skip_cache_tree_update = 1;\n\t\tbreak;\n\tcase MIXED:\n\t\topts.reset = UNPACK_RESET_PROTECT_UNTRACKED;\n\t\topts.skip_cache_tree_update = 1;\n\t\t/* but opts.update=0, so working tree not updated */\n\t\tbreak;\n\tdefault:\n\t\tBUG(\"invalid reset_type passed to reset_index\");\n\t}\n\n\trepo_read_index_unmerged(the_repository);\n\n\tif (reset_type == KEEP) {\n\t\tstruct object_id head_oid;\n\t\tif (repo_get_oid(the_repository, \"HEAD\", &head_oid))\n\t\t\treturn error(_(\"You do not have a valid HEAD.\"));\n\t\tif (!fill_tree_descriptor(the_repository, desc + nr, &head_oid))\n\t\t\treturn error(_(\"Failed to find tree of HEAD.\"));\n\t\tnr++;\n\t\topts.fn = twoway_merge;\n\t}\n\n\tif (!fill_tree_descriptor(the_repository, desc + nr, oid)) {\n\t\terror(_(\"Failed to find tree of %s.\"), oid_to_hex(oid));\n\t\tgoto out;\n\t}\n\tnr++;\n\n\tif (unpack_trees(nr, desc, &opts))\n\t\tgoto out;\n\n\tif (reset_type == MIXED || reset_type == HARD) {\n\t\ttree = parse_tree_indirect(oid);\n\t\tif (!tree) {\n\t\t\terror(_(\"unable to read tree (%s)\"), oid_to_hex(oid));\n\t\t\tgoto out;\n\t\t}\n\t\tprime_cache_tree(the_repository, the_repository->index, tree);\n\t}\n\n\tret = 0;\n\nout:\n\tfor (i = 0; i < nr; i++)\n\t\tfree((void *)desc[i].buffer);\n\treturn ret;\n}\n\nstatic void print_new_head_line(struct commit *commit)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tprintf(_(\"HEAD is now at %s\"),\n\t\trepo_find_unique_abbrev(the_repository, &commit->object.oid, DEFAULT_ABBREV));\n\n\tpp_commit_easy(CMIT_FMT_ONELINE, commit, &buf);\n\tif (buf.len > 0)\n\t\tprintf(\" %s\", buf.buf);\n\tputchar('\\n');\n\tstrbuf_release(&buf);\n}\n\nstatic void update_index_from_diff(struct diff_queue_struct *q,\n\t\t\t\t   struct diff_options *opt UNUSED,\n\t\t\t\t   void *data)\n{\n\tint i;\n\tint intent_to_add = *(int *)data;\n\n\tfor (i = 0; i < q->nr; i++) {\n\t\tint pos;\n\t\tstruct diff_filespec *one = q->queue[i]->one;\n\t\tint is_in_reset_tree = one->mode && !is_null_oid(&one->oid);\n\t\tstruct cache_entry *ce;\n\n\t\tif (!is_in_reset_tree && !intent_to_add) {\n\t\t\tremove_file_from_index(the_repository->index, one->path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tce = make_cache_entry(the_repository->index, one->mode, &one->oid, one->path,\n\t\t\t\t      0, 0);\n\n\t\t/*\n\t\t * If the file 1) corresponds to an existing index entry with\n\t\t * skip-worktree set, or 2) does not exist in the index but is\n\t\t * outside the sparse checkout definition, add a skip-worktree bit\n\t\t * to the new index entry. Note that a sparse index will be expanded\n\t\t * if this entry is outside the sparse cone - this is necessary\n\t\t * to properly construct the reset sparse directory.\n\t\t */\n\t\tpos = index_name_pos(the_repository->index, one->path, strlen(one->path));\n\t\tif ((pos >= 0 && ce_skip_worktree(the_repository->index->cache[pos])) ||\n\t\t    (pos < 0 && !path_in_sparse_checkout(one->path, the_repository->index)))\n\t\t\tce->ce_flags |= CE_SKIP_WORKTREE;\n\n\t\tif (!ce)\n\t\t\tdie(_(\"make_cache_entry failed for path '%s'\"),\n\t\t\t    one->path);\n\t\tif (!is_in_reset_tree) {\n\t\t\tce->ce_flags |= CE_INTENT_TO_ADD;\n\t\t\tset_object_name_for_intent_to_add_entry(ce);\n\t\t}\n\t\tadd_index_entry(the_repository->index, ce,\n\t\t\t\tADD_CACHE_OK_TO_ADD | ADD_CACHE_OK_TO_REPLACE);\n\t}\n}\n\nstatic int read_from_tree(const struct pathspec *pathspec,\n\t\t\t  struct object_id *tree_oid,\n\t\t\t  int intent_to_add)\n{\n\tstruct diff_options opt;\n\n\tmemset(&opt, 0, sizeof(opt));\n\tcopy_pathspec(&opt.pathspec, pathspec);\n\topt.output_format = DIFF_FORMAT_CALLBACK;\n\topt.format_callback = update_index_from_diff;\n\topt.format_callback_data = &intent_to_add;\n\topt.flags.override_submodule_config = 1;\n\topt.flags.recursive = 1;\n\topt.repo = the_repository;\n\topt.change = diff_change;\n\topt.add_remove = diff_addremove;\n\n\tif (pathspec->nr && pathspec_needs_expanded_index(the_repository->index, pathspec))\n\t\tensure_full_index(the_repository->index);\n\n\tif (do_diff_cache(tree_oid, &opt))\n\t\treturn 1;\n\tdiffcore_std(&opt);\n\tdiff_flush(&opt);\n\n\treturn 0;\n}\n\nstatic void set_reflog_message(struct strbuf *sb, const char *action,\n\t\t\t       const char *rev)\n{\n\tconst char *rla = getenv(\"GIT_REFLOG_ACTION\");\n\n\tstrbuf_reset(sb);\n\tif (rla)\n\t\tstrbuf_addf(sb, \"%s: %s\", rla, action);\n\telse if (rev)\n\t\tstrbuf_addf(sb, \"reset: moving to %s\", rev);\n\telse\n\t\tstrbuf_addf(sb, \"reset: %s\", action);\n}\n\nstatic void die_if_unmerged_cache(int reset_type)\n{\n\tif (is_merge() || unmerged_index(the_repository->index))\n\t\tdie(_(\"Cannot do a %s reset in the middle of a merge.\"),\n\t\t    _(reset_type_names[reset_type]));\n\n}\n\nstatic void parse_args(struct pathspec *pathspec,\n\t\t       const char **argv, const char *prefix,\n\t\t       int patch_mode,\n\t\t       const char **rev_ret)\n{\n\tconst char *rev = \"HEAD\";\n\tstruct object_id unused;\n\t/*\n\t * Possible arguments are:\n\t *\n\t * git reset [-opts] [<rev>]\n\t * git reset [-opts] <tree> [<paths>...]\n\t * git reset [-opts] <tree> -- [<paths>...]\n\t * git reset [-opts] -- [<paths>...]\n\t * git reset [-opts] <paths>...\n\t *\n\t * At this point, argv points immediately after [-opts].\n\t */\n\n\tif (argv[0]) {\n\t\tif (!strcmp(argv[0], \"--\")) {\n\t\t\targv++; /* reset to HEAD, possibly with paths */\n\t\t} else if (argv[1] && !strcmp(argv[1], \"--\")) {\n\t\t\trev = argv[0];\n\t\t\targv += 2;\n\t\t}\n\t\t/*\n\t\t * Otherwise, argv[0] could be either <rev> or <paths> and\n\t\t * has to be unambiguous. If there is a single argument, it\n\t\t * can not be a tree\n\t\t */\n\t\telse if ((!argv[1] && !repo_get_oid_committish(the_repository, argv[0], &unused)) ||\n\t\t\t (argv[1] && !repo_get_oid_treeish(the_repository, argv[0], &unused))) {\n\t\t\t/*\n\t\t\t * Ok, argv[0] looks like a commit/tree; it should not\n\t\t\t * be a filename.\n\t\t\t */\n\t\t\tverify_non_filename(prefix, argv[0]);\n\t\t\trev = *argv++;\n\t\t} else {\n\t\t\t/* Otherwise we treat this as a filename */\n\t\t\tverify_filename(prefix, argv[0], 1);\n\t\t}\n\t}\n\n\t/* treat '@' as a shortcut for 'HEAD' */\n\t*rev_ret = !strcmp(\"@\", rev) ? \"HEAD\" : rev;\n\n\tparse_pathspec(pathspec, 0,\n\t\t       PATHSPEC_PREFER_FULL |\n\t\t       (patch_mode ? PATHSPEC_PREFIX_ORIGIN : 0),\n\t\t       prefix, argv);\n}\n\nstatic int reset_refs(const char *rev, const struct object_id *oid)\n{\n\tint update_ref_status;\n\tstruct strbuf msg = STRBUF_INIT;\n\tstruct object_id *orig = NULL, oid_orig,\n\t\t*old_orig = NULL, oid_old_orig;\n\n\tif (!repo_get_oid(the_repository, \"ORIG_HEAD\", &oid_old_orig))\n\t\told_orig = &oid_old_orig;\n\tif (!repo_get_oid(the_repository, \"HEAD\", &oid_orig)) {\n\t\torig = &oid_orig;\n\t\tset_reflog_message(&msg, \"updating ORIG_HEAD\", NULL);\n\t\trefs_update_ref(get_main_ref_store(the_repository), msg.buf,\n\t\t\t\t\"ORIG_HEAD\", orig, old_orig, 0,\n\t\t\t\tUPDATE_REFS_MSG_ON_ERR);\n\t} else if (old_orig)\n\t\trefs_delete_ref(get_main_ref_store(the_repository), NULL,\n\t\t\t\t\"ORIG_HEAD\", old_orig, 0);\n\tset_reflog_message(&msg, \"updating HEAD\", rev);\n\tupdate_ref_status = refs_update_ref(get_main_ref_store(the_repository),\n\t\t\t\t\t    msg.buf, \"HEAD\", oid, orig, 0,\n\t\t\t\t\t    UPDATE_REFS_MSG_ON_ERR);\n\tstrbuf_release(&msg);\n\treturn update_ref_status;\n}\n\nstatic int git_reset_config(const char *var, const char *value,\n\t\t\t    const struct config_context *ctx, void *cb)\n{\n\tif (!strcmp(var, \"submodule.recurse\"))\n\t\treturn git_default_submodule_config(var, value, cb);\n\n\treturn git_default_config(var, value, ctx, cb);\n}\n\nint cmd_reset(int argc,\n\t      const char **argv,\n\t      const char *prefix,\n\t      struct repository *repo UNUSED)\n{\n\tint reset_type = NONE, update_ref_status = 0, quiet = 0;\n\tint no_refresh = 0;\n\tint patch_mode = 0, pathspec_file_nul = 0, unborn;\n\tconst char *rev;\n\tchar *pathspec_from_file = NULL;\n\tstruct object_id oid;\n\tstruct pathspec pathspec;\n\tint intent_to_add = 0;\n\tconst struct option options[] = {\n\t\tOPT__QUIET(&quiet, N_(\"be quiet, only report errors\")),\n\t\tOPT_BOOL(0, \"no-refresh\", &no_refresh,\n\t\t\t\tN_(\"skip refreshing the index after reset\")),\n\t\tOPT_SET_INT_F(0, \"mixed\", &reset_type,\n\t\t\t      N_(\"reset HEAD and index\"),\n\t\t\t      MIXED, PARSE_OPT_NONEG),\n\t\tOPT_SET_INT_F(0, \"soft\", &reset_type,\n\t\t\t      N_(\"reset only HEAD\"),\n\t\t\t      SOFT, PARSE_OPT_NONEG),\n\t\tOPT_SET_INT_F(0, \"hard\", &reset_type,\n\t\t\t      N_(\"reset HEAD, index and working tree\"),\n\t\t\t      HARD, PARSE_OPT_NONEG),\n\t\tOPT_SET_INT_F(0, \"merge\", &reset_type,\n\t\t\t      N_(\"reset HEAD, index and working tree\"),\n\t\t\t      MERGE, PARSE_OPT_NONEG),\n\t\tOPT_SET_INT_F(0, \"keep\", &reset_type,\n\t\t\t      N_(\"reset HEAD but keep local changes\"),\n\t\t\t      KEEP, PARSE_OPT_NONEG),\n\t\tOPT_CALLBACK_F(0, \"recurse-submodules\", NULL,\n\t\t\t       \"reset\", \"control recursive updating of submodules\",\n\t\t\t       PARSE_OPT_OPTARG,\n\t\t\t       option_parse_recurse_submodules_worktree_updater),\n\t\tOPT_BOOL('p', \"patch\", &patch_mode, N_(\"select hunks interactively\")),\n\t\tOPT_BOOL('N', \"intent-to-add\", &intent_to_add,\n\t\t\t\tN_(\"record only the fact that removed paths will be added later\")),\n\t\tOPT_PATHSPEC_FROM_FILE(&pathspec_from_file),\n\t\tOPT_PATHSPEC_FILE_NUL(&pathspec_file_nul),\n\t\tOPT_END()\n\t};\n\n\trepo_config(the_repository, git_reset_config, NULL);\n\n\targc = parse_options(argc, argv, prefix, options, git_reset_usage,\n\t\t\t\t\t\tPARSE_OPT_KEEP_DASHDASH);\n\tparse_args(&pathspec, argv, prefix, patch_mode, &rev);\n\n\tif (pathspec_from_file) {\n\t\tif (patch_mode)\n\t\t\tdie(_(\"options '%s' and '%s' cannot be used together\"), \"--pathspec-from-file\", \"--patch\");\n\n\t\tif (pathspec.nr)\n\t\t\tdie(_(\"'%s' and pathspec arguments cannot be used together\"), \"--pathspec-from-file\");\n\n\t\tparse_pathspec_file(&pathspec, 0,\n\t\t\t\t    PATHSPEC_PREFER_FULL,\n\t\t\t\t    prefix, pathspec_from_file, pathspec_file_nul);\n\t} else if (pathspec_file_nul) {\n\t\tdie(_(\"the option '%s' requires '%s'\"), \"--pathspec-file-nul\", \"--pathspec-from-file\");\n\t}\n\n\tunborn = !strcmp(rev, \"HEAD\") && repo_get_oid(the_repository, \"HEAD\",\n\t\t\t\t\t\t      &oid);\n\tif (unborn) {\n\t\t/* reset on unborn branch: treat as reset to empty tree */\n\t\toidcpy(&oid, the_hash_algo->empty_tree);\n\t} else if (!pathspec.nr && !patch_mode) {\n\t\tstruct commit *commit;\n\t\tif (repo_get_oid_committish(the_repository, rev, &oid))\n\t\t\tdie(_(\"Failed to resolve '%s' as a valid revision.\"), rev);\n\t\tcommit = lookup_commit_reference(the_repository, &oid);\n\t\tif (!commit)\n\t\t\tdie(_(\"Could not parse object '%s'.\"), rev);\n\t\toidcpy(&oid, &commit->object.oid);\n\t} else {\n\t\tstruct tree *tree;\n\t\tif (repo_get_oid_treeish(the_repository, rev, &oid))\n\t\t\tdie(_(\"Failed to resolve '%s' as a valid tree.\"), rev);\n\t\ttree = parse_tree_indirect(&oid);\n\t\tif (!tree)\n\t\t\tdie(_(\"Could not parse object '%s'.\"), rev);\n\t\toidcpy(&oid, &tree->object.oid);\n\t}\n\n\tprepare_repo_settings(the_repository);\n\tthe_repository->settings.command_requires_full_index = 0;\n\n\tif (patch_mode) {\n\t\tif (reset_type != NONE)\n\t\t\tdie(_(\"options '%s' and '%s' cannot be used together\"), \"--patch\", \"--{hard,mixed,soft}\");\n\t\ttrace2_cmd_mode(\"patch-interactive\");\n\t\tupdate_ref_status = !!run_add_p(the_repository, ADD_P_RESET, rev,\n\t\t\t\t   &pathspec);\n\t\tgoto cleanup;\n\t}\n\n\t/* git reset tree [--] paths... can be used to\n\t * load chosen paths from the tree into the index without\n\t * affecting the working tree nor HEAD. */\n\tif (pathspec.nr) {\n\t\tif (reset_type == MIXED)\n\t\t\twarning(_(\"--mixed with paths is deprecated; use 'git reset -- <paths>' instead.\"));\n\t\telse if (reset_type != NONE)\n\t\t\tdie(_(\"Cannot do %s reset with paths.\"),\n\t\t\t\t\t_(reset_type_names[reset_type]));\n\t}\n\tif (reset_type == NONE)\n\t\treset_type = MIXED; /* by default */\n\n\tif (pathspec.nr)\n\t\ttrace2_cmd_mode(\"path\");\n\telse\n\t\ttrace2_cmd_mode(reset_type_names[reset_type]);\n\n\tif (reset_type != SOFT && (reset_type != MIXED || repo_get_work_tree(the_repository)))\n\t\tsetup_work_tree();\n\n\tif (reset_type == MIXED && is_bare_repository())\n\t\tdie(_(\"%s reset is not allowed in a bare repository\"),\n\t\t    _(reset_type_names[reset_type]));\n\n\tif (intent_to_add && reset_type != MIXED)\n\t\tdie(_(\"the option '%s' requires '%s'\"), \"-N\", \"--mixed\");\n\n\tif (repo_read_index(the_repository) < 0)\n\t\tdie(_(\"index file corrupt\"));\n\n\t/* Soft reset does not touch the index file nor the working tree\n\t * at all, but requires them in a good order.  Other resets reset\n\t * the index file to the tree object we are switching to. */\n\tif (reset_type == SOFT || reset_type == KEEP)\n\t\tdie_if_unmerged_cache(reset_type);\n\n\tif (reset_type != SOFT) {\n\t\tstruct lock_file lock = LOCK_INIT;\n\t\trepo_hold_locked_index(the_repository, &lock,\n\t\t\t\t       LOCK_DIE_ON_ERROR);\n\t\tif (reset_type == MIXED) {\n\t\t\tint flags = quiet ? REFRESH_QUIET : REFRESH_IN_PORCELAIN;\n\t\t\tif (read_from_tree(&pathspec, &oid, intent_to_add)) {\n\t\t\t\tupdate_ref_status = 1;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tthe_repository->index->updated_skipworktree = 1;\n\t\t\tif (!no_refresh && repo_get_work_tree(the_repository)) {\n\t\t\t\tuint64_t t_begin, t_delta_in_ms;\n\n\t\t\t\tt_begin = getnanotime();\n\t\t\t\trefresh_index(the_repository->index, flags, NULL, NULL,\n\t\t\t\t\t      _(\"Unstaged changes after reset:\"));\n\t\t\t\tt_delta_in_ms = (getnanotime() - t_begin) / 1000000;\n\t\t\t\tif (!quiet && advice_enabled(ADVICE_RESET_NO_REFRESH_WARNING) && t_delta_in_ms > REFRESH_INDEX_DELAY_WARNING_IN_MS) {\n\t\t\t\t\tadvise(_(\"It took %.2f seconds to refresh the index after reset.  You can use\\n\"\n\t\t\t\t\t\t \"'--no-refresh' to avoid this.\"), t_delta_in_ms / 1000.0);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstruct object_id dummy;\n\t\t\tchar *ref = NULL;\n\t\t\tint err;\n\n\t\t\trepo_dwim_ref(the_repository, rev, strlen(rev),\n\t\t\t\t      &dummy, &ref, 0);\n\t\t\tif (ref && !starts_with(ref, \"refs/\"))\n\t\t\t\tFREE_AND_NULL(ref);\n\n\t\t\terr = reset_index(ref, &oid, reset_type, quiet);\n\t\t\tif (reset_type == KEEP && !err)\n\t\t\t\terr = reset_index(ref, &oid, MIXED, quiet);\n\t\t\tif (err)\n\t\t\t\tdie(_(\"Could not reset index file to revision '%s'.\"), rev);\n\t\t\tfree(ref);\n\t\t}\n\n\t\tif (write_locked_index(the_repository->index, &lock, COMMIT_LOCK))\n\t\t\tdie(_(\"Could not write new index file.\"));\n\t}\n\n\tif (!pathspec.nr && !unborn) {\n\t\t/* Any resets without paths update HEAD to the head being\n\t\t * switched to, saving the previous head in ORIG_HEAD before. */\n\t\tupdate_ref_status = reset_refs(rev, &oid);\n\n\t\tif (reset_type == HARD && !update_ref_status && !quiet)\n\t\t\tprint_new_head_line(lookup_commit_reference(the_repository, &oid));\n\t}\n\tif (!pathspec.nr)\n\t\tremove_branch_state(the_repository, 0);\n\n\tdiscard_index(the_repository->index);\n\ncleanup:\n\tclear_pathspec(&pathspec);\n\tfree(pathspec_from_file);\n\treturn update_ref_status;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00492c19b060253f50f53b3899e3413f15d25216",
  "sha1_ok": true,
  "size": 16118
}
