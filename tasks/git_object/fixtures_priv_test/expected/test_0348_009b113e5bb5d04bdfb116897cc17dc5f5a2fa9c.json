{
  "content": {
    "base64": "I2lmbmRlZiBDT01NSVRfSAojZGVmaW5lIENPTU1JVF9ICgojaW5jbHVkZSAib2JqZWN0LmgiCiNpbmNsdWRlICJ0cmVlLmgiCiNpbmNsdWRlICJzdHJidWYuaCIKI2luY2x1ZGUgImRlY29yYXRlLmgiCgpzdHJ1Y3QgY29tbWl0X2xpc3QgewoJc3RydWN0IGNvbW1pdCAqaXRlbTsKCXN0cnVjdCBjb21taXRfbGlzdCAqbmV4dDsKfTsKCnN0cnVjdCBjb21taXQgewoJc3RydWN0IG9iamVjdCBvYmplY3Q7Cgl2b2lkICp1dGlsOwoJdW5zaWduZWQgaW50IGluZGVncmVlOwoJdW5zaWduZWQgbG9uZyBkYXRlOwoJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzOwoJc3RydWN0IHRyZWUgKnRyZWU7CgljaGFyICpidWZmZXI7Cn07CgpleHRlcm4gaW50IHNhdmVfY29tbWl0X2J1ZmZlcjsKZXh0ZXJuIGNvbnN0IGNoYXIgKmNvbW1pdF90eXBlOwoKLyogV2hpbGUgd2UgY2FuIGRlY29yYXRlIGFueSBvYmplY3Qgd2l0aCBhIG5hbWUsIGl0J3Mgb25seSB1c2VkIGZvciBjb21taXRzLi4gKi8KZXh0ZXJuIHN0cnVjdCBkZWNvcmF0aW9uIG5hbWVfZGVjb3JhdGlvbjsKc3RydWN0IG5hbWVfZGVjb3JhdGlvbiB7CglzdHJ1Y3QgbmFtZV9kZWNvcmF0aW9uICpuZXh0OwoJaW50IHR5cGU7CgljaGFyIG5hbWVbMV07Cn07CgpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0X3JlZmVyZW5jZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKTsKc3RydWN0IGNvbW1pdCAqbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfZ2VudGx5KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsCgkJCQkJICAgICAgaW50IHF1aWV0KTsKc3RydWN0IGNvbW1pdCAqbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfYnlfbmFtZShjb25zdCBjaGFyICpuYW1lKTsKCi8qCiAqIExvb2sgdXAgb2JqZWN0IG5hbWVkIGJ5ICJzaGExIiwgZGVyZWZlcmVuY2UgdGFnIGFzIG5lY2Vzc2FyeSwKICogZ2V0IGEgY29tbWl0IGFuZCByZXR1cm4gaXQuIElmICJzaGExIiBkb2VzIG5vdCBkZXJlZmVyZW5jZSB0bwogKiBhIGNvbW1pdCwgdXNlIHJlZl9uYW1lIHRvIHJlcG9ydCBhbiBlcnJvciBhbmQgZGllLgogKi8Kc3RydWN0IGNvbW1pdCAqbG9va3VwX2NvbW1pdF9vcl9kaWUoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgY29uc3QgY2hhciAqcmVmX25hbWUpOwoKaW50IHBhcnNlX2NvbW1pdF9idWZmZXIoc3RydWN0IGNvbW1pdCAqaXRlbSwgY29uc3Qgdm9pZCAqYnVmZmVyLCB1bnNpZ25lZCBsb25nIHNpemUpOwppbnQgcGFyc2VfY29tbWl0KHN0cnVjdCBjb21taXQgKml0ZW0pOwoKLyogRmluZCBiZWdpbm5pbmcgYW5kIGxlbmd0aCBvZiBjb21taXQgc3ViamVjdC4gKi8KaW50IGZpbmRfY29tbWl0X3N1YmplY3QoY29uc3QgY2hhciAqY29tbWl0X2J1ZmZlciwgY29uc3QgY2hhciAqKnN1YmplY3QpOwoKc3RydWN0IGNvbW1pdF9saXN0ICpjb21taXRfbGlzdF9pbnNlcnQoc3RydWN0IGNvbW1pdCAqaXRlbSwKCQkJCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKipsaXN0KTsKdW5zaWduZWQgY29tbWl0X2xpc3RfY291bnQoY29uc3Qgc3RydWN0IGNvbW1pdF9saXN0ICpsKTsKc3RydWN0IGNvbW1pdF9saXN0ICpjb21taXRfbGlzdF9pbnNlcnRfYnlfZGF0ZShzdHJ1Y3QgY29tbWl0ICppdGVtLAoJCQkJICAgIHN0cnVjdCBjb21taXRfbGlzdCAqKmxpc3QpOwp2b2lkIGNvbW1pdF9saXN0X3NvcnRfYnlfZGF0ZShzdHJ1Y3QgY29tbWl0X2xpc3QgKipsaXN0KTsKCnZvaWQgZnJlZV9jb21taXRfbGlzdChzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QpOwoKLyogQ29tbWl0IGZvcm1hdHMgKi8KZW51bSBjbWl0X2ZtdCB7CglDTUlUX0ZNVF9SQVcsCglDTUlUX0ZNVF9NRURJVU0sCglDTUlUX0ZNVF9ERUZBVUxUID0gQ01JVF9GTVRfTUVESVVNLAoJQ01JVF9GTVRfU0hPUlQsCglDTUlUX0ZNVF9GVUxMLAoJQ01JVF9GTVRfRlVMTEVSLAoJQ01JVF9GTVRfT05FTElORSwKCUNNSVRfRk1UX0VNQUlMLAoJQ01JVF9GTVRfVVNFUkZPUk1BVCwKCglDTUlUX0ZNVF9VTlNQRUNJRklFRAp9OwoKc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0IHsKCWVudW0gY21pdF9mbXQgZm10OwoJaW50IGFiYnJldjsKCWNvbnN0IGNoYXIgKnN1YmplY3Q7Cgljb25zdCBjaGFyICphZnRlcl9zdWJqZWN0OwoJaW50IHByZXNlcnZlX3N1YmplY3Q7CgllbnVtIGRhdGVfbW9kZSBkYXRlX21vZGU7CglpbnQgbmVlZF84Yml0X2N0ZTsKCWludCBzaG93X25vdGVzOwoJc3RydWN0IHJlZmxvZ193YWxrX2luZm8gKnJlZmxvZ19pbmZvOwoJY29uc3QgY2hhciAqb3V0cHV0X2VuY29kaW5nOwp9OwoKc3RydWN0IHVzZXJmb3JtYXRfd2FudCB7Cgl1bnNpZ25lZCBub3RlczoxOwp9OwoKZXh0ZXJuIGludCBoYXNfbm9uX2FzY2lpKGNvbnN0IGNoYXIgKnRleHQpOwpzdHJ1Y3QgcmV2X2luZm87IC8qIGluIHJldmlzaW9uLmgsIGl0IGNpcmN1bGFybHkgdXNlcyBlbnVtIGNtaXRfZm10ICovCmV4dGVybiBjaGFyICpsb2dtc2dfcmVlbmNvZGUoY29uc3Qgc3RydWN0IGNvbW1pdCAqY29tbWl0LAoJCQkgICAgIGNvbnN0IGNoYXIgKm91dHB1dF9lbmNvZGluZyk7CmV4dGVybiBjaGFyICpyZWVuY29kZV9jb21taXRfbWVzc2FnZShjb25zdCBzdHJ1Y3QgY29tbWl0ICpjb21taXQsCgkJCQkgICAgIGNvbnN0IGNoYXIgKiplbmNvZGluZ19wKTsKZXh0ZXJuIHZvaWQgZ2V0X2NvbW1pdF9mb3JtYXQoY29uc3QgY2hhciAqYXJnLCBzdHJ1Y3QgcmV2X2luZm8gKik7CmV4dGVybiBjb25zdCBjaGFyICpmb3JtYXRfc3ViamVjdChzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqbXNnLAoJCQkJICBjb25zdCBjaGFyICpsaW5lX3NlcGFyYXRvcik7CmV4dGVybiB2b2lkIHVzZXJmb3JtYXRfZmluZF9yZXF1aXJlbWVudHMoY29uc3QgY2hhciAqZm10LCBzdHJ1Y3QgdXNlcmZvcm1hdF93YW50ICp3KTsKZXh0ZXJuIHZvaWQgZm9ybWF0X2NvbW1pdF9tZXNzYWdlKGNvbnN0IHN0cnVjdCBjb21taXQgKmNvbW1pdCwKCQkJCSAgY29uc3QgY2hhciAqZm9ybWF0LCBzdHJ1Y3Qgc3RyYnVmICpzYiwKCQkJCSAgY29uc3Qgc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0ICpjb250ZXh0KTsKZXh0ZXJuIHZvaWQgcHJldHR5X3ByaW50X2NvbW1pdChjb25zdCBzdHJ1Y3QgcHJldHR5X3ByaW50X2NvbnRleHQgKnBwLAoJCQkJY29uc3Qgc3RydWN0IGNvbW1pdCAqY29tbWl0LAoJCQkJc3RydWN0IHN0cmJ1ZiAqc2IpOwpleHRlcm4gdm9pZCBwcF9jb21taXRfZWFzeShlbnVtIGNtaXRfZm10IGZtdCwgY29uc3Qgc3RydWN0IGNvbW1pdCAqY29tbWl0LAoJCQkgICBzdHJ1Y3Qgc3RyYnVmICpzYik7CnZvaWQgcHBfdXNlcl9pbmZvKGNvbnN0IHN0cnVjdCBwcmV0dHlfcHJpbnRfY29udGV4dCAqcHAsCgkJICBjb25zdCBjaGFyICp3aGF0LCBzdHJ1Y3Qgc3RyYnVmICpzYiwKCQkgIGNvbnN0IGNoYXIgKmxpbmUsIGNvbnN0IGNoYXIgKmVuY29kaW5nKTsKdm9pZCBwcF90aXRsZV9saW5lKGNvbnN0IHN0cnVjdCBwcmV0dHlfcHJpbnRfY29udGV4dCAqcHAsCgkJICAgY29uc3QgY2hhciAqKm1zZ19wLAoJCSAgIHN0cnVjdCBzdHJidWYgKnNiLAoJCSAgIGNvbnN0IGNoYXIgKmVuY29kaW5nLAoJCSAgIGludCBuZWVkXzhiaXRfY3RlKTsKdm9pZCBwcF9yZW1haW5kZXIoY29uc3Qgc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0ICpwcCwKCQkgIGNvbnN0IGNoYXIgKiptc2dfcCwKCQkgIHN0cnVjdCBzdHJidWYgKnNiLAoJCSAgaW50IGluZGVudCk7CgoKLyoqIFJlbW92ZXMgdGhlIGZpcnN0IGNvbW1pdCBmcm9tIGEgbGlzdCBzb3J0ZWQgYnkgZGF0ZSwgYW5kIGFkZHMgYWxsCiAqIG9mIGl0cyBwYXJlbnRzLgogKiovCnN0cnVjdCBjb21taXQgKnBvcF9tb3N0X3JlY2VudF9jb21taXQoc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCwKCQkJCSAgICAgIHVuc2lnbmVkIGludCBtYXJrKTsKCnN0cnVjdCBjb21taXQgKnBvcF9jb21taXQoc3RydWN0IGNvbW1pdF9saXN0ICoqc3RhY2spOwoKdm9pZCBjbGVhcl9jb21taXRfbWFya3Moc3RydWN0IGNvbW1pdCAqY29tbWl0LCB1bnNpZ25lZCBpbnQgbWFyayk7CnZvaWQgY2xlYXJfY29tbWl0X21hcmtzX2Zvcl9vYmplY3RfYXJyYXkoc3RydWN0IG9iamVjdF9hcnJheSAqYSwgdW5zaWduZWQgbWFyayk7CgovKgogKiBQZXJmb3JtcyBhbiBpbi1wbGFjZSB0b3BvbG9naWNhbCBzb3J0IG9mIGxpc3Qgc3VwcGxpZWQuCiAqCiAqICAgaW52YXJpYW50IG9mIHJlc3VsdGluZyBsaXN0IGlzOgogKiAgICAgIGEgcmVhY2hhYmxlIGZyb20gYiA9PiBvcmQoYikgPCBvcmQoYSkKICogICBpbiBhZGRpdGlvbiwgd2hlbiBsaWZvID09IDAsIGNvbW1pdHMgb24gcGFyYWxsZWwgdHJhY2tzIGFyZQogKiAgIHNvcnRlZCBpbiB0aGUgZGF0ZXMgb3JkZXIuCiAqLwp2b2lkIHNvcnRfaW5fdG9wb2xvZ2ljYWxfb3JkZXIoc3RydWN0IGNvbW1pdF9saXN0ICoqIGxpc3QsIGludCBsaWZvKTsKCnN0cnVjdCBjb21taXRfZ3JhZnQgewoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCWludCBucl9wYXJlbnQ7IC8qIDwgMCBpZiBzaGFsbG93IGNvbW1pdCAqLwoJdW5zaWduZWQgY2hhciBwYXJlbnRbRkxFWF9BUlJBWV1bMjBdOyAvKiBtb3JlICovCn07CnR5cGVkZWYgaW50ICgqZWFjaF9jb21taXRfZ3JhZnRfZm4pKGNvbnN0IHN0cnVjdCBjb21taXRfZ3JhZnQgKiwgdm9pZCAqKTsKCnN0cnVjdCBjb21taXRfZ3JhZnQgKnJlYWRfZ3JhZnRfbGluZShjaGFyICpidWYsIGludCBsZW4pOwppbnQgcmVnaXN0ZXJfY29tbWl0X2dyYWZ0KHN0cnVjdCBjb21taXRfZ3JhZnQgKiwgaW50KTsKc3RydWN0IGNvbW1pdF9ncmFmdCAqbG9va3VwX2NvbW1pdF9ncmFmdChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKTsKCmV4dGVybiBzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9tZXJnZV9iYXNlcyhzdHJ1Y3QgY29tbWl0ICpyZXYxLCBzdHJ1Y3QgY29tbWl0ICpyZXYyLCBpbnQgY2xlYW51cCk7CmV4dGVybiBzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9tZXJnZV9iYXNlc19tYW55KHN0cnVjdCBjb21taXQgKm9uZSwgaW50IG4sIHN0cnVjdCBjb21taXQgKip0d29zLCBpbnQgY2xlYW51cCk7CmV4dGVybiBzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9vY3RvcHVzX21lcmdlX2Jhc2VzKHN0cnVjdCBjb21taXRfbGlzdCAqaW4pOwoKZXh0ZXJuIGludCByZWdpc3Rlcl9zaGFsbG93KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpleHRlcm4gaW50IHVucmVnaXN0ZXJfc2hhbGxvdyhjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKTsKZXh0ZXJuIGludCBmb3JfZWFjaF9jb21taXRfZ3JhZnQoZWFjaF9jb21taXRfZ3JhZnRfZm4sIHZvaWQgKik7CmV4dGVybiBpbnQgaXNfcmVwb3NpdG9yeV9zaGFsbG93KHZvaWQpOwpleHRlcm4gc3RydWN0IGNvbW1pdF9saXN0ICpnZXRfc2hhbGxvd19jb21taXRzKHN0cnVjdCBvYmplY3RfYXJyYXkgKmhlYWRzLAoJCWludCBkZXB0aCwgaW50IHNoYWxsb3dfZmxhZywgaW50IG5vdF9zaGFsbG93X2ZsYWcpOwoKaW50IGlzX2Rlc2NlbmRhbnRfb2Yoc3RydWN0IGNvbW1pdCAqLCBzdHJ1Y3QgY29tbWl0X2xpc3QgKik7CmludCBpbl9tZXJnZV9iYXNlcyhzdHJ1Y3QgY29tbWl0ICosIHN0cnVjdCBjb21taXQgKiosIGludCk7CgpleHRlcm4gaW50IGludGVyYWN0aXZlX2FkZChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCwgaW50IHBhdGNoKTsKZXh0ZXJuIGludCBydW5fYWRkX2ludGVyYWN0aXZlKGNvbnN0IGNoYXIgKnJldmlzaW9uLCBjb25zdCBjaGFyICpwYXRjaF9tb2RlLAoJCQkgICAgICAgY29uc3QgY2hhciAqKnBhdGhzcGVjKTsKCnN0YXRpYyBpbmxpbmUgaW50IHNpbmdsZV9wYXJlbnQoc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglyZXR1cm4gY29tbWl0LT5wYXJlbnRzICYmICFjb21taXQtPnBhcmVudHMtPm5leHQ7Cn0KCnN0cnVjdCBjb21taXRfbGlzdCAqcmVkdWNlX2hlYWRzKHN0cnVjdCBjb21taXRfbGlzdCAqaGVhZHMpOwoKZXh0ZXJuIGludCBjb21taXRfdHJlZShjb25zdCBjaGFyICptc2csIHVuc2lnbmVkIGNoYXIgKnRyZWUsCgkJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzLCB1bnNpZ25lZCBjaGFyICpyZXQsCgkJY29uc3QgY2hhciAqYXV0aG9yKTsKCiNlbmRpZiAvKiBDT01NSVRfSCAqLwo=",
    "text": "#ifndef COMMIT_H\n#define COMMIT_H\n\n#include \"object.h\"\n#include \"tree.h\"\n#include \"strbuf.h\"\n#include \"decorate.h\"\n\nstruct commit_list {\n\tstruct commit *item;\n\tstruct commit_list *next;\n};\n\nstruct commit {\n\tstruct object object;\n\tvoid *util;\n\tunsigned int indegree;\n\tunsigned long date;\n\tstruct commit_list *parents;\n\tstruct tree *tree;\n\tchar *buffer;\n};\n\nextern int save_commit_buffer;\nextern const char *commit_type;\n\n/* While we can decorate any object with a name, it's only used for commits.. */\nextern struct decoration name_decoration;\nstruct name_decoration {\n\tstruct name_decoration *next;\n\tint type;\n\tchar name[1];\n};\n\nstruct commit *lookup_commit(const unsigned char *sha1);\nstruct commit *lookup_commit_reference(const unsigned char *sha1);\nstruct commit *lookup_commit_reference_gently(const unsigned char *sha1,\n\t\t\t\t\t      int quiet);\nstruct commit *lookup_commit_reference_by_name(const char *name);\n\n/*\n * Look up object named by \"sha1\", dereference tag as necessary,\n * get a commit and return it. If \"sha1\" does not dereference to\n * a commit, use ref_name to report an error and die.\n */\nstruct commit *lookup_commit_or_die(const unsigned char *sha1, const char *ref_name);\n\nint parse_commit_buffer(struct commit *item, const void *buffer, unsigned long size);\nint parse_commit(struct commit *item);\n\n/* Find beginning and length of commit subject. */\nint find_commit_subject(const char *commit_buffer, const char **subject);\n\nstruct commit_list *commit_list_insert(struct commit *item,\n\t\t\t\t\tstruct commit_list **list);\nunsigned commit_list_count(const struct commit_list *l);\nstruct commit_list *commit_list_insert_by_date(struct commit *item,\n\t\t\t\t    struct commit_list **list);\nvoid commit_list_sort_by_date(struct commit_list **list);\n\nvoid free_commit_list(struct commit_list *list);\n\n/* Commit formats */\nenum cmit_fmt {\n\tCMIT_FMT_RAW,\n\tCMIT_FMT_MEDIUM,\n\tCMIT_FMT_DEFAULT = CMIT_FMT_MEDIUM,\n\tCMIT_FMT_SHORT,\n\tCMIT_FMT_FULL,\n\tCMIT_FMT_FULLER,\n\tCMIT_FMT_ONELINE,\n\tCMIT_FMT_EMAIL,\n\tCMIT_FMT_USERFORMAT,\n\n\tCMIT_FMT_UNSPECIFIED\n};\n\nstruct pretty_print_context {\n\tenum cmit_fmt fmt;\n\tint abbrev;\n\tconst char *subject;\n\tconst char *after_subject;\n\tint preserve_subject;\n\tenum date_mode date_mode;\n\tint need_8bit_cte;\n\tint show_notes;\n\tstruct reflog_walk_info *reflog_info;\n\tconst char *output_encoding;\n};\n\nstruct userformat_want {\n\tunsigned notes:1;\n};\n\nextern int has_non_ascii(const char *text);\nstruct rev_info; /* in revision.h, it circularly uses enum cmit_fmt */\nextern char *logmsg_reencode(const struct commit *commit,\n\t\t\t     const char *output_encoding);\nextern char *reencode_commit_message(const struct commit *commit,\n\t\t\t\t     const char **encoding_p);\nextern void get_commit_format(const char *arg, struct rev_info *);\nextern const char *format_subject(struct strbuf *sb, const char *msg,\n\t\t\t\t  const char *line_separator);\nextern void userformat_find_requirements(const char *fmt, struct userformat_want *w);\nextern void format_commit_message(const struct commit *commit,\n\t\t\t\t  const char *format, struct strbuf *sb,\n\t\t\t\t  const struct pretty_print_context *context);\nextern void pretty_print_commit(const struct pretty_print_context *pp,\n\t\t\t\tconst struct commit *commit,\n\t\t\t\tstruct strbuf *sb);\nextern void pp_commit_easy(enum cmit_fmt fmt, const struct commit *commit,\n\t\t\t   struct strbuf *sb);\nvoid pp_user_info(const struct pretty_print_context *pp,\n\t\t  const char *what, struct strbuf *sb,\n\t\t  const char *line, const char *encoding);\nvoid pp_title_line(const struct pretty_print_context *pp,\n\t\t   const char **msg_p,\n\t\t   struct strbuf *sb,\n\t\t   const char *encoding,\n\t\t   int need_8bit_cte);\nvoid pp_remainder(const struct pretty_print_context *pp,\n\t\t  const char **msg_p,\n\t\t  struct strbuf *sb,\n\t\t  int indent);\n\n\n/** Removes the first commit from a list sorted by date, and adds all\n * of its parents.\n **/\nstruct commit *pop_most_recent_commit(struct commit_list **list,\n\t\t\t\t      unsigned int mark);\n\nstruct commit *pop_commit(struct commit_list **stack);\n\nvoid clear_commit_marks(struct commit *commit, unsigned int mark);\nvoid clear_commit_marks_for_object_array(struct object_array *a, unsigned mark);\n\n/*\n * Performs an in-place topological sort of list supplied.\n *\n *   invariant of resulting list is:\n *      a reachable from b => ord(b) < ord(a)\n *   in addition, when lifo == 0, commits on parallel tracks are\n *   sorted in the dates order.\n */\nvoid sort_in_topological_order(struct commit_list ** list, int lifo);\n\nstruct commit_graft {\n\tunsigned char sha1[20];\n\tint nr_parent; /* < 0 if shallow commit */\n\tunsigned char parent[FLEX_ARRAY][20]; /* more */\n};\ntypedef int (*each_commit_graft_fn)(const struct commit_graft *, void *);\n\nstruct commit_graft *read_graft_line(char *buf, int len);\nint register_commit_graft(struct commit_graft *, int);\nstruct commit_graft *lookup_commit_graft(const unsigned char *sha1);\n\nextern struct commit_list *get_merge_bases(struct commit *rev1, struct commit *rev2, int cleanup);\nextern struct commit_list *get_merge_bases_many(struct commit *one, int n, struct commit **twos, int cleanup);\nextern struct commit_list *get_octopus_merge_bases(struct commit_list *in);\n\nextern int register_shallow(const unsigned char *sha1);\nextern int unregister_shallow(const unsigned char *sha1);\nextern int for_each_commit_graft(each_commit_graft_fn, void *);\nextern int is_repository_shallow(void);\nextern struct commit_list *get_shallow_commits(struct object_array *heads,\n\t\tint depth, int shallow_flag, int not_shallow_flag);\n\nint is_descendant_of(struct commit *, struct commit_list *);\nint in_merge_bases(struct commit *, struct commit **, int);\n\nextern int interactive_add(int argc, const char **argv, const char *prefix, int patch);\nextern int run_add_interactive(const char *revision, const char *patch_mode,\n\t\t\t       const char **pathspec);\n\nstatic inline int single_parent(struct commit *commit)\n{\n\treturn commit->parents && !commit->parents->next;\n}\n\nstruct commit_list *reduce_heads(struct commit_list *heads);\n\nextern int commit_tree(const char *msg, unsigned char *tree,\n\t\tstruct commit_list *parents, unsigned char *ret,\n\t\tconst char *author);\n\n#endif /* COMMIT_H */\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "009b113e5bb5d04bdfb116897cc17dc5f5a2fa9c",
  "sha1_ok": true,
  "size": 6161
}
