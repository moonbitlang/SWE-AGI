{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJzdHJpbmctbGlzdC5oIgoKLyoKICogQSAic3RyaW5nX2xpc3RfZWFjaF9mdW5jX3QiIGZ1bmN0aW9uIHRoYXQgbm9ybWFsaXplcyBhbiBlbnRyeSBmcm9tCiAqIEdJVF9DRUlMSU5HX0RJUkVDVE9SSUVTLiAgSWYgdGhlIHBhdGggaXMgdW51c2FibGUgZm9yIHNvbWUgcmVhc29uLAogKiBkaWUgd2l0aCBhbiBleHBsYW5hdGlvbi4KICovCnN0YXRpYyBpbnQgbm9ybWFsaXplX2NlaWxpbmdfZW50cnkoc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW0sIHZvaWQgKnVudXNlZCkKewoJY29uc3QgY2hhciAqY2VpbCA9IGl0ZW0tPnN0cmluZzsKCWludCBsZW4gPSBzdHJsZW4oY2VpbCk7CgljaGFyIGJ1ZltQQVRIX01BWCsxXTsKCglpZiAobGVuID09IDApCgkJZGllKCJFbXB0eSBwYXRoIGlzIG5vdCBzdXBwb3J0ZWQiKTsKCWlmIChsZW4gPiBQQVRIX01BWCkKCQlkaWUoIlBhdGggXCIlc1wiIGlzIHRvbyBsb25nIiwgY2VpbCk7CglpZiAoIWlzX2Fic29sdXRlX3BhdGgoY2VpbCkpCgkJZGllKCJQYXRoIFwiJXNcIiBpcyBub3QgYWJzb2x1dGUiLCBjZWlsKTsKCWlmIChub3JtYWxpemVfcGF0aF9jb3B5KGJ1ZiwgY2VpbCkgPCAwKQoJCWRpZSgiUGF0aCBcIiVzXCIgY291bGQgbm90IGJlIG5vcm1hbGl6ZWQiLCBjZWlsKTsKCWxlbiA9IHN0cmxlbihidWYpOwoJaWYgKGxlbiA+IDEgJiYgYnVmW2xlbi0xXSA9PSAnLycpCgkJZGllKCJOb3JtYWxpemVkIHBhdGggXCIlc1wiIGVuZGVkIHdpdGggc2xhc2giLCBidWYpOwoJZnJlZShpdGVtLT5zdHJpbmcpOwoJaXRlbS0+c3RyaW5nID0geHN0cmR1cChidWYpOwoJcmV0dXJuIDE7Cn0KCmludCBtYWluKGludCBhcmdjLCBjaGFyICoqYXJndikKewoJaWYgKGFyZ2MgPT0gMyAmJiAhc3RyY21wKGFyZ3ZbMV0sICJub3JtYWxpemVfcGF0aF9jb3B5IikpIHsKCQljaGFyICpidWYgPSB4bWFsbG9jKFBBVEhfTUFYICsgMSk7CgkJaW50IHJ2ID0gbm9ybWFsaXplX3BhdGhfY29weShidWYsIGFyZ3ZbMl0pOwoJCWlmIChydikKCQkJYnVmID0gIisrZmFpbGVkKysiOwoJCXB1dHMoYnVmKTsKCQlyZXR1cm4gMDsKCX0KCglpZiAoYXJnYyA+PSAyICYmICFzdHJjbXAoYXJndlsxXSwgInJlYWxfcGF0aCIpKSB7CgkJd2hpbGUgKGFyZ2MgPiAyKSB7CgkJCXB1dHMocmVhbF9wYXRoKGFyZ3ZbMl0pKTsKCQkJYXJnYy0tOwoJCQlhcmd2Kys7CgkJfQoJCXJldHVybiAwOwoJfQoKCWlmIChhcmdjID49IDIgJiYgIXN0cmNtcChhcmd2WzFdLCAiYWJzb2x1dGVfcGF0aCIpKSB7CgkJd2hpbGUgKGFyZ2MgPiAyKSB7CgkJCXB1dHMoYWJzb2x1dGVfcGF0aChhcmd2WzJdKSk7CgkJCWFyZ2MtLTsKCQkJYXJndisrOwoJCX0KCQlyZXR1cm4gMDsKCX0KCglpZiAoYXJnYyA9PSA0ICYmICFzdHJjbXAoYXJndlsxXSwgImxvbmdlc3RfYW5jZXN0b3JfbGVuZ3RoIikpIHsKCQlpbnQgbGVuOwoJCXN0cnVjdCBzdHJpbmdfbGlzdCBjZWlsaW5nX2RpcnMgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCQljaGFyICpwYXRoID0geHN0cmR1cChhcmd2WzJdKTsKCgkJLyoKCQkgKiBXZSBoYXZlIHRvIG5vcm1hbGl6ZSB0aGUgYXJndW1lbnRzIGJlY2F1c2UgdW5kZXIKCQkgKiBXaW5kb3dzLCBiYXNoIG1hbmdsZXMgYXJndW1lbnRzIHRoYXQgbG9vayBsaWtlCgkJICogYWJzb2x1dGUgUE9TSVggcGF0aHMgb3IgY29sb24tc2VwYXJhdGUgbGlzdHMgb2YKCQkgKiBhYnNvbHV0ZSBQT1NJWCBwYXRocyBpbnRvIERPUyBwYXRocyAoZS5nLiwKCQkgKiAiL2ZvbzovZm9vL2JhciIgbWlnaHQgYmUgY29udmVydGVkIHRvCgkJICogIkQ6XFNyY1xtc3lzZ2l0XGZvbztEOlxTcmNcbXN5c2dpdFxmb29cYmFyIiksCgkJICogd2hlcmVhcyBsb25nZXN0X2FuY2VzdG9yX2xlbmd0aCgpIHJlcXVpcmVzIHBhdGhzCgkJICogdGhhdCB1c2UgZm9yd2FyZCBzbGFzaGVzLgoJCSAqLwoJCWlmIChub3JtYWxpemVfcGF0aF9jb3B5KHBhdGgsIHBhdGgpKQoJCQlkaWUoIlBhdGggXCIlc1wiIGNvdWxkIG5vdCBiZSBub3JtYWxpemVkIiwgYXJndlsyXSk7CgkJc3RyaW5nX2xpc3Rfc3BsaXQoJmNlaWxpbmdfZGlycywgYXJndlszXSwgUEFUSF9TRVAsIC0xKTsKCQlmaWx0ZXJfc3RyaW5nX2xpc3QoJmNlaWxpbmdfZGlycywgMCwKCQkJCSAgIG5vcm1hbGl6ZV9jZWlsaW5nX2VudHJ5LCBOVUxMKTsKCQlsZW4gPSBsb25nZXN0X2FuY2VzdG9yX2xlbmd0aChwYXRoLCAmY2VpbGluZ19kaXJzKTsKCQlzdHJpbmdfbGlzdF9jbGVhcigmY2VpbGluZ19kaXJzLCAwKTsKCQlmcmVlKHBhdGgpOwoJCXByaW50ZigiJWRcbiIsIGxlbik7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKGFyZ2MgPj0gNCAmJiAhc3RyY21wKGFyZ3ZbMV0sICJwcmVmaXhfcGF0aCIpKSB7CgkJY2hhciAqcHJlZml4ID0gYXJndlsyXTsKCQlpbnQgcHJlZml4X2xlbiA9IHN0cmxlbihwcmVmaXgpOwoJCWludCBub25naXRfb2s7CgkJc2V0dXBfZ2l0X2RpcmVjdG9yeV9nZW50bHkoJm5vbmdpdF9vayk7CgkJd2hpbGUgKGFyZ2MgPiAzKSB7CgkJCXB1dHMocHJlZml4X3BhdGgocHJlZml4LCBwcmVmaXhfbGVuLCBhcmd2WzNdKSk7CgkJCWFyZ2MtLTsKCQkJYXJndisrOwoJCX0KCQlyZXR1cm4gMDsKCX0KCglpZiAoYXJnYyA9PSA0ICYmICFzdHJjbXAoYXJndlsxXSwgInN0cmlwX3BhdGhfc3VmZml4IikpIHsKCQljaGFyICpwcmVmaXggPSBzdHJpcF9wYXRoX3N1ZmZpeChhcmd2WzJdLCBhcmd2WzNdKTsKCQlwcmludGYoIiVzXG4iLCBwcmVmaXggPyBwcmVmaXggOiAiKG51bGwpIik7CgkJcmV0dXJuIDA7Cgl9CgoJZnByaW50ZihzdGRlcnIsICIlczogdW5rbm93biBmdW5jdGlvbiBuYW1lOiAlc1xuIiwgYXJndlswXSwKCQlhcmd2WzFdID8gYXJndlsxXSA6ICIodGhlcmUgd2FzIG5vbmUpIik7CglyZXR1cm4gMTsKfQo=",
    "text": "#include \"cache.h\"\n#include \"string-list.h\"\n\n/*\n * A \"string_list_each_func_t\" function that normalizes an entry from\n * GIT_CEILING_DIRECTORIES.  If the path is unusable for some reason,\n * die with an explanation.\n */\nstatic int normalize_ceiling_entry(struct string_list_item *item, void *unused)\n{\n\tconst char *ceil = item->string;\n\tint len = strlen(ceil);\n\tchar buf[PATH_MAX+1];\n\n\tif (len == 0)\n\t\tdie(\"Empty path is not supported\");\n\tif (len > PATH_MAX)\n\t\tdie(\"Path \\\"%s\\\" is too long\", ceil);\n\tif (!is_absolute_path(ceil))\n\t\tdie(\"Path \\\"%s\\\" is not absolute\", ceil);\n\tif (normalize_path_copy(buf, ceil) < 0)\n\t\tdie(\"Path \\\"%s\\\" could not be normalized\", ceil);\n\tlen = strlen(buf);\n\tif (len > 1 && buf[len-1] == '/')\n\t\tdie(\"Normalized path \\\"%s\\\" ended with slash\", buf);\n\tfree(item->string);\n\titem->string = xstrdup(buf);\n\treturn 1;\n}\n\nint main(int argc, char **argv)\n{\n\tif (argc == 3 && !strcmp(argv[1], \"normalize_path_copy\")) {\n\t\tchar *buf = xmalloc(PATH_MAX + 1);\n\t\tint rv = normalize_path_copy(buf, argv[2]);\n\t\tif (rv)\n\t\t\tbuf = \"++failed++\";\n\t\tputs(buf);\n\t\treturn 0;\n\t}\n\n\tif (argc >= 2 && !strcmp(argv[1], \"real_path\")) {\n\t\twhile (argc > 2) {\n\t\t\tputs(real_path(argv[2]));\n\t\t\targc--;\n\t\t\targv++;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (argc >= 2 && !strcmp(argv[1], \"absolute_path\")) {\n\t\twhile (argc > 2) {\n\t\t\tputs(absolute_path(argv[2]));\n\t\t\targc--;\n\t\t\targv++;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (argc == 4 && !strcmp(argv[1], \"longest_ancestor_length\")) {\n\t\tint len;\n\t\tstruct string_list ceiling_dirs = STRING_LIST_INIT_DUP;\n\t\tchar *path = xstrdup(argv[2]);\n\n\t\t/*\n\t\t * We have to normalize the arguments because under\n\t\t * Windows, bash mangles arguments that look like\n\t\t * absolute POSIX paths or colon-separate lists of\n\t\t * absolute POSIX paths into DOS paths (e.g.,\n\t\t * \"/foo:/foo/bar\" might be converted to\n\t\t * \"D:\\Src\\msysgit\\foo;D:\\Src\\msysgit\\foo\\bar\"),\n\t\t * whereas longest_ancestor_length() requires paths\n\t\t * that use forward slashes.\n\t\t */\n\t\tif (normalize_path_copy(path, path))\n\t\t\tdie(\"Path \\\"%s\\\" could not be normalized\", argv[2]);\n\t\tstring_list_split(&ceiling_dirs, argv[3], PATH_SEP, -1);\n\t\tfilter_string_list(&ceiling_dirs, 0,\n\t\t\t\t   normalize_ceiling_entry, NULL);\n\t\tlen = longest_ancestor_length(path, &ceiling_dirs);\n\t\tstring_list_clear(&ceiling_dirs, 0);\n\t\tfree(path);\n\t\tprintf(\"%d\\n\", len);\n\t\treturn 0;\n\t}\n\n\tif (argc >= 4 && !strcmp(argv[1], \"prefix_path\")) {\n\t\tchar *prefix = argv[2];\n\t\tint prefix_len = strlen(prefix);\n\t\tint nongit_ok;\n\t\tsetup_git_directory_gently(&nongit_ok);\n\t\twhile (argc > 3) {\n\t\t\tputs(prefix_path(prefix, prefix_len, argv[3]));\n\t\t\targc--;\n\t\t\targv++;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (argc == 4 && !strcmp(argv[1], \"strip_path_suffix\")) {\n\t\tchar *prefix = strip_path_suffix(argv[2], argv[3]);\n\t\tprintf(\"%s\\n\", prefix ? prefix : \"(null)\");\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr, \"%s: unknown function name: %s\\n\", argv[0],\n\t\targv[1] ? argv[1] : \"(there was none)\");\n\treturn 1;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0092cbf3540e2fdfd2e882461ba39ba2a833b672",
  "sha1_ok": true,
  "size": 2897
}
