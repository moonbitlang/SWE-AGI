{
  "content": {
    "base64": "I2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAic2hhMS1sb29rdXAuaCIKCiNkZWZpbmUgQ1VUT0ZGX0RBVEVfU0xPUCA4NjQwMCAvKiBvbmUgZGF5ICovCgp0eXBlZGVmIHN0cnVjdCByZXZfbmFtZSB7Cgljb25zdCBjaGFyICp0aXBfbmFtZTsKCXVuc2lnbmVkIGxvbmcgdGFnZ2VyZGF0ZTsKCWludCBnZW5lcmF0aW9uOwoJaW50IGRpc3RhbmNlOwp9IHJldl9uYW1lOwoKc3RhdGljIGxvbmcgY3V0b2ZmID0gTE9OR19NQVg7CgovKiBIb3cgbWFueSBnZW5lcmF0aW9ucyBhcmUgbWF4aW1hbGx5IHByZWZlcnJlZCBvdmVyIF9vbmVfIG1lcmdlIHRyYXZlcnNhbD8gKi8KI2RlZmluZSBNRVJHRV9UUkFWRVJTQUxfV0VJR0hUIDY1NTM1CgpzdGF0aWMgdm9pZCBuYW1lX3JldihzdHJ1Y3QgY29tbWl0ICpjb21taXQsCgkJY29uc3QgY2hhciAqdGlwX25hbWUsIHVuc2lnbmVkIGxvbmcgdGFnZ2VyZGF0ZSwKCQlpbnQgZ2VuZXJhdGlvbiwgaW50IGRpc3RhbmNlLAoJCWludCBkZXJlZikKewoJc3RydWN0IHJldl9uYW1lICpuYW1lID0gKHN0cnVjdCByZXZfbmFtZSAqKWNvbW1pdC0+dXRpbDsKCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50czsKCWludCBwYXJlbnRfbnVtYmVyID0gMTsKCglwYXJzZV9jb21taXQoY29tbWl0KTsKCglpZiAoY29tbWl0LT5kYXRlIDwgY3V0b2ZmKQoJCXJldHVybjsKCglpZiAoZGVyZWYpIHsKCQl0aXBfbmFtZSA9IHhzdHJmbXQoIiVzXjAiLCB0aXBfbmFtZSk7CgoJCWlmIChnZW5lcmF0aW9uKQoJCQlkaWUoImdlbmVyYXRpb246ICVkLCBidXQgZGVyZWY/IiwgZ2VuZXJhdGlvbik7Cgl9CgoJaWYgKG5hbWUgPT0gTlVMTCkgewoJCW5hbWUgPSB4bWFsbG9jKHNpemVvZihyZXZfbmFtZSkpOwoJCWNvbW1pdC0+dXRpbCA9IG5hbWU7CgkJZ290byBjb3B5X2RhdGE7Cgl9IGVsc2UgaWYgKG5hbWUtPnRhZ2dlcmRhdGUgPiB0YWdnZXJkYXRlIHx8CgkJCShuYW1lLT50YWdnZXJkYXRlID09IHRhZ2dlcmRhdGUgJiYKCQkJIG5hbWUtPmRpc3RhbmNlID4gZGlzdGFuY2UpKSB7CmNvcHlfZGF0YToKCQluYW1lLT50aXBfbmFtZSA9IHRpcF9uYW1lOwoJCW5hbWUtPnRhZ2dlcmRhdGUgPSB0YWdnZXJkYXRlOwoJCW5hbWUtPmdlbmVyYXRpb24gPSBnZW5lcmF0aW9uOwoJCW5hbWUtPmRpc3RhbmNlID0gZGlzdGFuY2U7Cgl9IGVsc2UKCQlyZXR1cm47CgoJZm9yIChwYXJlbnRzID0gY29tbWl0LT5wYXJlbnRzOwoJCQlwYXJlbnRzOwoJCQlwYXJlbnRzID0gcGFyZW50cy0+bmV4dCwgcGFyZW50X251bWJlcisrKSB7CgkJaWYgKHBhcmVudF9udW1iZXIgPiAxKSB7CgkJCXNpemVfdCBsZW47CgkJCWNoYXIgKm5ld19uYW1lOwoKCQkJc3RyaXBfc3VmZml4KHRpcF9uYW1lLCAiXjAiLCAmbGVuKTsKCQkJaWYgKGdlbmVyYXRpb24gPiAwKQoJCQkJbmV3X25hbWUgPSB4c3RyZm10KCIlLipzfiVkXiVkIiwgKGludClsZW4sIHRpcF9uYW1lLAoJCQkJCQkgICBnZW5lcmF0aW9uLCBwYXJlbnRfbnVtYmVyKTsKCQkJZWxzZQoJCQkJbmV3X25hbWUgPSB4c3RyZm10KCIlLipzXiVkIiwgKGludClsZW4sIHRpcF9uYW1lLAoJCQkJCQkgICBwYXJlbnRfbnVtYmVyKTsKCgkJCW5hbWVfcmV2KHBhcmVudHMtPml0ZW0sIG5ld19uYW1lLCB0YWdnZXJkYXRlLCAwLAoJCQkJZGlzdGFuY2UgKyBNRVJHRV9UUkFWRVJTQUxfV0VJR0hULCAwKTsKCQl9IGVsc2UgewoJCQluYW1lX3JldihwYXJlbnRzLT5pdGVtLCB0aXBfbmFtZSwgdGFnZ2VyZGF0ZSwKCQkJCWdlbmVyYXRpb24gKyAxLCBkaXN0YW5jZSArIDEsIDApOwoJCX0KCX0KfQoKc3RhdGljIGludCBzdWJwYXRoX21hdGNoZXMoY29uc3QgY2hhciAqcGF0aCwgY29uc3QgY2hhciAqZmlsdGVyKQp7Cgljb25zdCBjaGFyICpzdWJwYXRoID0gcGF0aDsKCgl3aGlsZSAoc3VicGF0aCkgewoJCWlmICghd2lsZG1hdGNoKGZpbHRlciwgc3VicGF0aCwgMCwgTlVMTCkpCgkJCXJldHVybiBzdWJwYXRoIC0gcGF0aDsKCQlzdWJwYXRoID0gc3RyY2hyKHN1YnBhdGgsICcvJyk7CgkJaWYgKHN1YnBhdGgpCgkJCXN1YnBhdGgrKzsKCX0KCXJldHVybiAtMTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKm5hbWVfcmVmX2FiYnJldihjb25zdCBjaGFyICpyZWZuYW1lLCBpbnQgc2hvcnRlbl91bmFtYmlndW91cykKewoJaWYgKHNob3J0ZW5fdW5hbWJpZ3VvdXMpCgkJcmVmbmFtZSA9IHNob3J0ZW5fdW5hbWJpZ3VvdXNfcmVmKHJlZm5hbWUsIDApOwoJZWxzZSBpZiAoc3RhcnRzX3dpdGgocmVmbmFtZSwgInJlZnMvaGVhZHMvIikpCgkJcmVmbmFtZSA9IHJlZm5hbWUgKyAxMTsKCWVsc2UgaWYgKHN0YXJ0c193aXRoKHJlZm5hbWUsICJyZWZzLyIpKQoJCXJlZm5hbWUgPSByZWZuYW1lICsgNTsKCXJldHVybiByZWZuYW1lOwp9CgpzdHJ1Y3QgbmFtZV9yZWZfZGF0YSB7CglpbnQgdGFnc19vbmx5OwoJaW50IG5hbWVfb25seTsKCXN0cnVjdCBzdHJpbmdfbGlzdCByZWZfZmlsdGVyczsKCXN0cnVjdCBzdHJpbmdfbGlzdCBleGNsdWRlX2ZpbHRlcnM7Cn07CgpzdGF0aWMgc3RydWN0IHRpcF90YWJsZSB7CglzdHJ1Y3QgdGlwX3RhYmxlX2VudHJ5IHsKCQlzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCQljb25zdCBjaGFyICpyZWZuYW1lOwoJfSAqdGFibGU7CglpbnQgbnI7CglpbnQgYWxsb2M7CglpbnQgc29ydGVkOwp9IHRpcF90YWJsZTsKCnN0YXRpYyB2b2lkIGFkZF90b190aXBfdGFibGUoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBjb25zdCBjaGFyICpyZWZuYW1lLAoJCQkgICAgIGludCBzaG9ydGVuX3VuYW1iaWd1b3VzKQp7CglyZWZuYW1lID0gbmFtZV9yZWZfYWJicmV2KHJlZm5hbWUsIHNob3J0ZW5fdW5hbWJpZ3VvdXMpOwoKCUFMTE9DX0dST1codGlwX3RhYmxlLnRhYmxlLCB0aXBfdGFibGUubnIgKyAxLCB0aXBfdGFibGUuYWxsb2MpOwoJb2lkY3B5KCZ0aXBfdGFibGUudGFibGVbdGlwX3RhYmxlLm5yXS5vaWQsIG9pZCk7Cgl0aXBfdGFibGUudGFibGVbdGlwX3RhYmxlLm5yXS5yZWZuYW1lID0geHN0cmR1cChyZWZuYW1lKTsKCXRpcF90YWJsZS5ucisrOwoJdGlwX3RhYmxlLnNvcnRlZCA9IDA7Cn0KCnN0YXRpYyBpbnQgdGlwY21wKGNvbnN0IHZvaWQgKmFfLCBjb25zdCB2b2lkICpiXykKewoJY29uc3Qgc3RydWN0IHRpcF90YWJsZV9lbnRyeSAqYSA9IGFfLCAqYiA9IGJfOwoJcmV0dXJuIG9pZGNtcCgmYS0+b2lkLCAmYi0+b2lkKTsKfQoKc3RhdGljIGludCBuYW1lX3JlZihjb25zdCBjaGFyICpwYXRoLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGludCBmbGFncywgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IG9iamVjdCAqbyA9IHBhcnNlX29iamVjdChvaWQtPmhhc2gpOwoJc3RydWN0IG5hbWVfcmVmX2RhdGEgKmRhdGEgPSBjYl9kYXRhOwoJaW50IGNhbl9hYmJyZXZpYXRlX291dHB1dCA9IGRhdGEtPnRhZ3Nfb25seSAmJiBkYXRhLT5uYW1lX29ubHk7CglpbnQgZGVyZWYgPSAwOwoJdW5zaWduZWQgbG9uZyB0YWdnZXJkYXRlID0gVUxPTkdfTUFYOwoKCWlmIChkYXRhLT50YWdzX29ubHkgJiYgIXN0YXJ0c193aXRoKHBhdGgsICJyZWZzL3RhZ3MvIikpCgkJcmV0dXJuIDA7CgoJaWYgKGRhdGEtPmV4Y2x1ZGVfZmlsdGVycy5ucikgewoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoKCQlmb3JfZWFjaF9zdHJpbmdfbGlzdF9pdGVtKGl0ZW0sICZkYXRhLT5leGNsdWRlX2ZpbHRlcnMpIHsKCQkJaWYgKHN1YnBhdGhfbWF0Y2hlcyhwYXRoLCBpdGVtLT5zdHJpbmcpID49IDApCgkJCQlyZXR1cm4gMDsKCQl9Cgl9CgoJaWYgKGRhdGEtPnJlZl9maWx0ZXJzLm5yKSB7CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW07CgkJaW50IG1hdGNoZWQgPSAwOwoKCQkvKiBTZWUgaWYgYW55IG9mIHRoZSBwYXR0ZXJucyBtYXRjaC4gKi8KCQlmb3JfZWFjaF9zdHJpbmdfbGlzdF9pdGVtKGl0ZW0sICZkYXRhLT5yZWZfZmlsdGVycykgewoJCQkvKgoJCQkgKiBDaGVjayBhbGwgcGF0dGVybnMgZXZlbiBhZnRlciBmaW5kaW5nIGEgbWF0Y2gsIHNvCgkJCSAqIHRoYXQgd2UgY2FuIHNlZSBpZiBhIG1hdGNoIHdpdGggYSBzdWJwYXRoIGV4aXN0cy4KCQkJICogV2hlbiBhIHVzZXIgYXNrZWQgZm9yICdyZWZzL3RhZ3MvdionIGFuZCAndjEuKicsCgkJCSAqIGJvdGggb2Ygd2hpY2ggbWF0Y2gsIHRoZSB1c2VyIGlzIHNob3dpbmcgaGVyCgkJCSAqIHdpbGxpbmduZXNzIHRvIGFjY2VwdCBhIHNob3J0ZW5lZCBvdXRwdXQgYnkgaGF2aW5nCgkJCSAqIHRoZSAndjEuKicgaW4gdGhlIGFjY2VwdGFibGUgcmVmbmFtZXMsIHNvIHdlCgkJCSAqIHNob3VsZG4ndCBzdG9wIHdoZW4gc2VlaW5nICdyZWZzL3RhZ3MvdjEuNCcgbWF0Y2hlcwoJCQkgKiAncmVmcy90YWdzL3YqJy4gIFdlIHNob3VsZCBzaG93IGl0IGFzICd2MS40Jy4KCQkJICovCgkJCXN3aXRjaCAoc3VicGF0aF9tYXRjaGVzKHBhdGgsIGl0ZW0tPnN0cmluZykpIHsKCQkJY2FzZSAtMTogLyogZGlkIG5vdCBtYXRjaCAqLwoJCQkJYnJlYWs7CgkJCWNhc2UgMDogLyogbWF0Y2hlZCBmdWxseSAqLwoJCQkJbWF0Y2hlZCA9IDE7CgkJCQlicmVhazsKCQkJZGVmYXVsdDogLyogbWF0Y2hlZCBzdWJwYXRoICovCgkJCQltYXRjaGVkID0gMTsKCQkJCWNhbl9hYmJyZXZpYXRlX291dHB1dCA9IDE7CgkJCQlicmVhazsKCQkJfQoJCX0KCgkJLyogSWYgbm9uZSBvZiB0aGUgcGF0dGVybnMgbWF0Y2hlZCwgc3RvcCBub3cgKi8KCQlpZiAoIW1hdGNoZWQpCgkJCXJldHVybiAwOwoJfQoKCWFkZF90b190aXBfdGFibGUob2lkLCBwYXRoLCBjYW5fYWJicmV2aWF0ZV9vdXRwdXQpOwoKCXdoaWxlIChvICYmIG8tPnR5cGUgPT0gT0JKX1RBRykgewoJCXN0cnVjdCB0YWcgKnQgPSAoc3RydWN0IHRhZyAqKSBvOwoJCWlmICghdC0+dGFnZ2VkKQoJCQlicmVhazsgLyogYnJva2VuIHJlcG9zaXRvcnkgKi8KCQlvID0gcGFyc2Vfb2JqZWN0KHQtPnRhZ2dlZC0+b2lkLmhhc2gpOwoJCWRlcmVmID0gMTsKCQl0YWdnZXJkYXRlID0gdC0+ZGF0ZTsKCX0KCWlmIChvICYmIG8tPnR5cGUgPT0gT0JKX0NPTU1JVCkgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IChzdHJ1Y3QgY29tbWl0ICopbzsKCgkJcGF0aCA9IG5hbWVfcmVmX2FiYnJldihwYXRoLCBjYW5fYWJicmV2aWF0ZV9vdXRwdXQpOwoJCW5hbWVfcmV2KGNvbW1pdCwgeHN0cmR1cChwYXRoKSwgdGFnZ2VyZGF0ZSwgMCwgMCwgZGVyZWYpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBjb25zdCB1bnNpZ25lZCBjaGFyICpudGhfdGlwX3RhYmxlX2VudChzaXplX3QgaXgsIHZvaWQgKnRhYmxlXykKewoJc3RydWN0IHRpcF90YWJsZV9lbnRyeSAqdGFibGUgPSB0YWJsZV87CglyZXR1cm4gdGFibGVbaXhdLm9pZC5oYXNoOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqZ2V0X2V4YWN0X3JlZl9tYXRjaChjb25zdCBzdHJ1Y3Qgb2JqZWN0ICpvKQp7CglpbnQgZm91bmQ7CgoJaWYgKCF0aXBfdGFibGUudGFibGUgfHwgIXRpcF90YWJsZS5ucikKCQlyZXR1cm4gTlVMTDsKCglpZiAoIXRpcF90YWJsZS5zb3J0ZWQpIHsKCQlRU09SVCh0aXBfdGFibGUudGFibGUsIHRpcF90YWJsZS5uciwgdGlwY21wKTsKCQl0aXBfdGFibGUuc29ydGVkID0gMTsKCX0KCglmb3VuZCA9IHNoYTFfcG9zKG8tPm9pZC5oYXNoLCB0aXBfdGFibGUudGFibGUsIHRpcF90YWJsZS5uciwKCQkJIG50aF90aXBfdGFibGVfZW50KTsKCWlmICgwIDw9IGZvdW5kKQoJCXJldHVybiB0aXBfdGFibGUudGFibGVbZm91bmRdLnJlZm5hbWU7CglyZXR1cm4gTlVMTDsKfQoKLyogbWF5IHJldHVybiBhIGNvbnN0YW50IHN0cmluZyBvciB1c2UgImJ1ZiIgYXMgc2NyYXRjaCBzcGFjZSAqLwpzdGF0aWMgY29uc3QgY2hhciAqZ2V0X3Jldl9uYW1lKGNvbnN0IHN0cnVjdCBvYmplY3QgKm8sIHN0cnVjdCBzdHJidWYgKmJ1ZikKewoJc3RydWN0IHJldl9uYW1lICpuOwoJc3RydWN0IGNvbW1pdCAqYzsKCglpZiAoby0+dHlwZSAhPSBPQkpfQ09NTUlUKQoJCXJldHVybiBnZXRfZXhhY3RfcmVmX21hdGNoKG8pOwoJYyA9IChzdHJ1Y3QgY29tbWl0ICopIG87CgluID0gYy0+dXRpbDsKCWlmICghbikKCQlyZXR1cm4gTlVMTDsKCglpZiAoIW4tPmdlbmVyYXRpb24pCgkJcmV0dXJuIG4tPnRpcF9uYW1lOwoJZWxzZSB7CgkJaW50IGxlbiA9IHN0cmxlbihuLT50aXBfbmFtZSk7CgkJaWYgKGxlbiA+IDIgJiYgIXN0cmNtcChuLT50aXBfbmFtZSArIGxlbiAtIDIsICJeMCIpKQoJCQlsZW4gLT0gMjsKCQlzdHJidWZfcmVzZXQoYnVmKTsKCQlzdHJidWZfYWRkZihidWYsICIlLipzfiVkIiwgbGVuLCBuLT50aXBfbmFtZSwgbi0+Z2VuZXJhdGlvbik7CgkJcmV0dXJuIGJ1Zi0+YnVmOwoJfQp9CgpzdGF0aWMgdm9pZCBzaG93X25hbWUoY29uc3Qgc3RydWN0IG9iamVjdCAqb2JqLAoJCSAgICAgIGNvbnN0IGNoYXIgKmNhbGxlcl9uYW1lLAoJCSAgICAgIGludCBhbHdheXMsIGludCBhbGxvd191bmRlZmluZWQsIGludCBuYW1lX29ubHkpCnsKCWNvbnN0IGNoYXIgKm5hbWU7Cgljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQgPSAmb2JqLT5vaWQ7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoKCWlmICghbmFtZV9vbmx5KQoJCXByaW50ZigiJXMgIiwgY2FsbGVyX25hbWUgPyBjYWxsZXJfbmFtZSA6IG9pZF90b19oZXgob2lkKSk7CgluYW1lID0gZ2V0X3Jldl9uYW1lKG9iaiwgJmJ1Zik7CglpZiAobmFtZSkKCQlwcmludGYoIiVzXG4iLCBuYW1lKTsKCWVsc2UgaWYgKGFsbG93X3VuZGVmaW5lZCkKCQlwcmludGYoInVuZGVmaW5lZFxuIik7CgllbHNlIGlmIChhbHdheXMpCgkJcHJpbnRmKCIlc1xuIiwgZmluZF91bmlxdWVfYWJicmV2KG9pZC0+aGFzaCwgREVGQVVMVF9BQkJSRVYpKTsKCWVsc2UKCQlkaWUoImNhbm5vdCBkZXNjcmliZSAnJXMnIiwgb2lkX3RvX2hleChvaWQpKTsKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwp9CgpzdGF0aWMgY2hhciBjb25zdCAqIGNvbnN0IG5hbWVfcmV2X3VzYWdlW10gPSB7CglOXygiZ2l0IG5hbWUtcmV2IFs8b3B0aW9ucz5dIDxjb21taXQ+Li4uIiksCglOXygiZ2l0IG5hbWUtcmV2IFs8b3B0aW9ucz5dIC0tYWxsIiksCglOXygiZ2l0IG5hbWUtcmV2IFs8b3B0aW9ucz5dIC0tc3RkaW4iKSwKCU5VTEwKfTsKCnN0YXRpYyB2b2lkIG5hbWVfcmV2X2xpbmUoY2hhciAqcCwgc3RydWN0IG5hbWVfcmVmX2RhdGEgKmRhdGEpCnsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglpbnQgZm9ydHkgPSAwOwoJY2hhciAqcF9zdGFydDsKCWZvciAocF9zdGFydCA9IHA7ICpwOyBwKyspIHsKI2RlZmluZSBpc2hleCh4KSAoaXNkaWdpdCgoeCkpIHx8ICgoeCkgPj0gJ2EnICYmICh4KSA8PSAnZicpKQoJCWlmICghaXNoZXgoKnApKQoJCQlmb3J0eSA9IDA7CgkJZWxzZSBpZiAoKytmb3J0eSA9PSBHSVRfU0hBMV9IRVhTWiAmJgoJCQkgIWlzaGV4KCoocCsxKSkpIHsKCQkJc3RydWN0IG9iamVjdF9pZCBvaWQ7CgkJCWNvbnN0IGNoYXIgKm5hbWUgPSBOVUxMOwoJCQljaGFyIGMgPSAqKHArMSk7CgkJCWludCBwX2xlbiA9IHAgLSBwX3N0YXJ0ICsgMTsKCgkJCWZvcnR5ID0gMDsKCgkJCSoocCsxKSA9IDA7CgkJCWlmICghZ2V0X29pZChwIC0gKEdJVF9TSEExX0hFWFNaIC0gMSksICZvaWQpKSB7CgkJCQlzdHJ1Y3Qgb2JqZWN0ICpvID0KCQkJCQlsb29rdXBfb2JqZWN0KG9pZC5oYXNoKTsKCQkJCWlmIChvKQoJCQkJCW5hbWUgPSBnZXRfcmV2X25hbWUobywgJmJ1Zik7CgkJCX0KCQkJKihwKzEpID0gYzsKCgkJCWlmICghbmFtZSkKCQkJCWNvbnRpbnVlOwoKCQkJaWYgKGRhdGEtPm5hbWVfb25seSkKCQkJCXByaW50ZigiJS4qcyVzIiwgcF9sZW4gLSBHSVRfU0hBMV9IRVhTWiwgcF9zdGFydCwgbmFtZSk7CgkJCWVsc2UKCQkJCXByaW50ZigiJS4qcyAoJXMpIiwgcF9sZW4sIHBfc3RhcnQsIG5hbWUpOwoJCQlwX3N0YXJ0ID0gcCArIDE7CgkJfQoJfQoKCS8qIGZsdXNoICovCglpZiAocF9zdGFydCAhPSBwKQoJCWZ3cml0ZShwX3N0YXJ0LCBwIC0gcF9zdGFydCwgMSwgc3Rkb3V0KTsKCglzdHJidWZfcmVsZWFzZSgmYnVmKTsKfQoKaW50IGNtZF9uYW1lX3JldihpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IG9iamVjdF9hcnJheSByZXZzID0gT0JKRUNUX0FSUkFZX0lOSVQ7CglpbnQgYWxsID0gMCwgdHJhbnNmb3JtX3N0ZGluID0gMCwgYWxsb3dfdW5kZWZpbmVkID0gMSwgYWx3YXlzID0gMCwgcGVlbF90YWcgPSAwOwoJc3RydWN0IG5hbWVfcmVmX2RhdGEgZGF0YSA9IHsgMCwgMCwgU1RSSU5HX0xJU1RfSU5JVF9OT0RVUCwgU1RSSU5HX0xJU1RfSU5JVF9OT0RVUCB9OwoJc3RydWN0IG9wdGlvbiBvcHRzW10gPSB7CgkJT1BUX0JPT0woMCwgIm5hbWUtb25seSIsICZkYXRhLm5hbWVfb25seSwgTl8oInByaW50IG9ubHkgbmFtZXMgKG5vIFNIQS0xKSIpKSwKCQlPUFRfQk9PTCgwLCAidGFncyIsICZkYXRhLnRhZ3Nfb25seSwgTl8oIm9ubHkgdXNlIHRhZ3MgdG8gbmFtZSB0aGUgY29tbWl0cyIpKSwKCQlPUFRfU1RSSU5HX0xJU1QoMCwgInJlZnMiLCAmZGF0YS5yZWZfZmlsdGVycywgTl8oInBhdHRlcm4iKSwKCQkJCSAgIE5fKCJvbmx5IHVzZSByZWZzIG1hdGNoaW5nIDxwYXR0ZXJuPiIpKSwKCQlPUFRfU1RSSU5HX0xJU1QoMCwgImV4Y2x1ZGUiLCAmZGF0YS5leGNsdWRlX2ZpbHRlcnMsIE5fKCJwYXR0ZXJuIiksCgkJCQkgICBOXygiaWdub3JlIHJlZnMgbWF0Y2hpbmcgPHBhdHRlcm4+IikpLAoJCU9QVF9HUk9VUCgiIiksCgkJT1BUX0JPT0woMCwgImFsbCIsICZhbGwsIE5fKCJsaXN0IGFsbCBjb21taXRzIHJlYWNoYWJsZSBmcm9tIGFsbCByZWZzIikpLAoJCU9QVF9CT09MKDAsICJzdGRpbiIsICZ0cmFuc2Zvcm1fc3RkaW4sIE5fKCJyZWFkIGZyb20gc3RkaW4iKSksCgkJT1BUX0JPT0woMCwgInVuZGVmaW5lZCIsICZhbGxvd191bmRlZmluZWQsIE5fKCJhbGxvdyB0byBwcmludCBgdW5kZWZpbmVkYCBuYW1lcyAoZGVmYXVsdCkiKSksCgkJT1BUX0JPT0woMCwgImFsd2F5cyIsICAgICAmYWx3YXlzLAoJCQkgICBOXygic2hvdyBhYmJyZXZpYXRlZCBjb21taXQgb2JqZWN0IGFzIGZhbGxiYWNrIikpLAoJCXsKCQkJLyogQSBIaWRkZW4gT1BUX0JPT0wgKi8KCQkJT1BUSU9OX1NFVF9JTlQsIDAsICJwZWVsLXRhZyIsICZwZWVsX3RhZywgTlVMTCwKCQkJTl8oImRlcmVmZXJlbmNlIHRhZ3MgaW4gdGhlIGlucHV0IChpbnRlcm5hbCB1c2UpIiksCgkJCVBBUlNFX09QVF9OT0FSRyB8IFBBUlNFX09QVF9ISURERU4sIE5VTEwsIDEsCgkJfSwKCQlPUFRfRU5EKCksCgl9OwoKCWdpdF9jb25maWcoZ2l0X2RlZmF1bHRfY29uZmlnLCBOVUxMKTsKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgb3B0cywgbmFtZV9yZXZfdXNhZ2UsIDApOwoJaWYgKGFsbCArIHRyYW5zZm9ybV9zdGRpbiArICEhYXJnYyA+IDEpIHsKCQllcnJvcigiU3BlY2lmeSBlaXRoZXIgYSBsaXN0LCBvciAtLWFsbCwgbm90IGJvdGghIik7CgkJdXNhZ2Vfd2l0aF9vcHRpb25zKG5hbWVfcmV2X3VzYWdlLCBvcHRzKTsKCX0KCWlmIChhbGwgfHwgdHJhbnNmb3JtX3N0ZGluKQoJCWN1dG9mZiA9IDA7CgoJZm9yICg7IGFyZ2M7IGFyZ2MtLSwgYXJndisrKSB7CgkJc3RydWN0IG9iamVjdF9pZCBvaWQ7CgkJc3RydWN0IG9iamVjdCAqb2JqZWN0OwoJCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCgkJaWYgKGdldF9vaWQoKmFyZ3YsICZvaWQpKSB7CgkJCWZwcmludGYoc3RkZXJyLCAiQ291bGQgbm90IGdldCBzaGExIGZvciAlcy4gU2tpcHBpbmcuXG4iLAoJCQkJCSphcmd2KTsKCQkJY29udGludWU7CgkJfQoKCQljb21taXQgPSBOVUxMOwoJCW9iamVjdCA9IHBhcnNlX29iamVjdChvaWQuaGFzaCk7CgkJaWYgKG9iamVjdCkgewoJCQlzdHJ1Y3Qgb2JqZWN0ICpwZWVsZWQgPSBkZXJlZl90YWcob2JqZWN0LCAqYXJndiwgMCk7CgkJCWlmIChwZWVsZWQgJiYgcGVlbGVkLT50eXBlID09IE9CSl9DT01NSVQpCgkJCQljb21taXQgPSAoc3RydWN0IGNvbW1pdCAqKXBlZWxlZDsKCQl9CgoJCWlmICghb2JqZWN0KSB7CgkJCWZwcmludGYoc3RkZXJyLCAiQ291bGQgbm90IGdldCBvYmplY3QgZm9yICVzLiBTa2lwcGluZy5cbiIsCgkJCQkJKmFyZ3YpOwoJCQljb250aW51ZTsKCQl9CgoJCWlmIChjb21taXQpIHsKCQkJaWYgKGN1dG9mZiA+IGNvbW1pdC0+ZGF0ZSkKCQkJCWN1dG9mZiA9IGNvbW1pdC0+ZGF0ZTsKCQl9CgoJCWlmIChwZWVsX3RhZykgewoJCQlpZiAoIWNvbW1pdCkgewoJCQkJZnByaW50ZihzdGRlcnIsICJDb3VsZCBub3QgZ2V0IGNvbW1pdCBmb3IgJXMuIFNraXBwaW5nLlxuIiwKCQkJCQkqYXJndik7CgkJCQljb250aW51ZTsKCQkJfQoJCQlvYmplY3QgPSAoc3RydWN0IG9iamVjdCAqKWNvbW1pdDsKCQl9CgkJYWRkX29iamVjdF9hcnJheShvYmplY3QsICphcmd2LCAmcmV2cyk7Cgl9CgoJaWYgKGN1dG9mZikKCQljdXRvZmYgPSBjdXRvZmYgLSBDVVRPRkZfREFURV9TTE9QOwoJZm9yX2VhY2hfcmVmKG5hbWVfcmVmLCAmZGF0YSk7CgoJaWYgKHRyYW5zZm9ybV9zdGRpbikgewoJCWNoYXIgYnVmZmVyWzIwNDhdOwoKCQl3aGlsZSAoIWZlb2Yoc3RkaW4pKSB7CgkJCWNoYXIgKnAgPSBmZ2V0cyhidWZmZXIsIHNpemVvZihidWZmZXIpLCBzdGRpbik7CgkJCWlmICghcCkKCQkJCWJyZWFrOwoJCQluYW1lX3Jldl9saW5lKHAsICZkYXRhKTsKCQl9Cgl9IGVsc2UgaWYgKGFsbCkgewoJCWludCBpLCBtYXg7CgoJCW1heCA9IGdldF9tYXhfb2JqZWN0X2luZGV4KCk7CgkJZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7CgkJCXN0cnVjdCBvYmplY3QgKm9iaiA9IGdldF9pbmRleGVkX29iamVjdChpKTsKCQkJaWYgKCFvYmogfHwgb2JqLT50eXBlICE9IE9CSl9DT01NSVQpCgkJCQljb250aW51ZTsKCQkJc2hvd19uYW1lKG9iaiwgTlVMTCwKCQkJCSAgYWx3YXlzLCBhbGxvd191bmRlZmluZWQsIGRhdGEubmFtZV9vbmx5KTsKCQl9Cgl9IGVsc2UgewoJCWludCBpOwoJCWZvciAoaSA9IDA7IGkgPCByZXZzLm5yOyBpKyspCgkJCXNob3dfbmFtZShyZXZzLm9iamVjdHNbaV0uaXRlbSwgcmV2cy5vYmplY3RzW2ldLm5hbWUsCgkJCQkgIGFsd2F5cywgYWxsb3dfdW5kZWZpbmVkLCBkYXRhLm5hbWVfb25seSk7Cgl9CgoJcmV0dXJuIDA7Cn0K",
    "text": "#include \"builtin.h\"\n#include \"cache.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"refs.h\"\n#include \"parse-options.h\"\n#include \"sha1-lookup.h\"\n\n#define CUTOFF_DATE_SLOP 86400 /* one day */\n\ntypedef struct rev_name {\n\tconst char *tip_name;\n\tunsigned long taggerdate;\n\tint generation;\n\tint distance;\n} rev_name;\n\nstatic long cutoff = LONG_MAX;\n\n/* How many generations are maximally preferred over _one_ merge traversal? */\n#define MERGE_TRAVERSAL_WEIGHT 65535\n\nstatic void name_rev(struct commit *commit,\n\t\tconst char *tip_name, unsigned long taggerdate,\n\t\tint generation, int distance,\n\t\tint deref)\n{\n\tstruct rev_name *name = (struct rev_name *)commit->util;\n\tstruct commit_list *parents;\n\tint parent_number = 1;\n\n\tparse_commit(commit);\n\n\tif (commit->date < cutoff)\n\t\treturn;\n\n\tif (deref) {\n\t\ttip_name = xstrfmt(\"%s^0\", tip_name);\n\n\t\tif (generation)\n\t\t\tdie(\"generation: %d, but deref?\", generation);\n\t}\n\n\tif (name == NULL) {\n\t\tname = xmalloc(sizeof(rev_name));\n\t\tcommit->util = name;\n\t\tgoto copy_data;\n\t} else if (name->taggerdate > taggerdate ||\n\t\t\t(name->taggerdate == taggerdate &&\n\t\t\t name->distance > distance)) {\ncopy_data:\n\t\tname->tip_name = tip_name;\n\t\tname->taggerdate = taggerdate;\n\t\tname->generation = generation;\n\t\tname->distance = distance;\n\t} else\n\t\treturn;\n\n\tfor (parents = commit->parents;\n\t\t\tparents;\n\t\t\tparents = parents->next, parent_number++) {\n\t\tif (parent_number > 1) {\n\t\t\tsize_t len;\n\t\t\tchar *new_name;\n\n\t\t\tstrip_suffix(tip_name, \"^0\", &len);\n\t\t\tif (generation > 0)\n\t\t\t\tnew_name = xstrfmt(\"%.*s~%d^%d\", (int)len, tip_name,\n\t\t\t\t\t\t   generation, parent_number);\n\t\t\telse\n\t\t\t\tnew_name = xstrfmt(\"%.*s^%d\", (int)len, tip_name,\n\t\t\t\t\t\t   parent_number);\n\n\t\t\tname_rev(parents->item, new_name, taggerdate, 0,\n\t\t\t\tdistance + MERGE_TRAVERSAL_WEIGHT, 0);\n\t\t} else {\n\t\t\tname_rev(parents->item, tip_name, taggerdate,\n\t\t\t\tgeneration + 1, distance + 1, 0);\n\t\t}\n\t}\n}\n\nstatic int subpath_matches(const char *path, const char *filter)\n{\n\tconst char *subpath = path;\n\n\twhile (subpath) {\n\t\tif (!wildmatch(filter, subpath, 0, NULL))\n\t\t\treturn subpath - path;\n\t\tsubpath = strchr(subpath, '/');\n\t\tif (subpath)\n\t\t\tsubpath++;\n\t}\n\treturn -1;\n}\n\nstatic const char *name_ref_abbrev(const char *refname, int shorten_unambiguous)\n{\n\tif (shorten_unambiguous)\n\t\trefname = shorten_unambiguous_ref(refname, 0);\n\telse if (starts_with(refname, \"refs/heads/\"))\n\t\trefname = refname + 11;\n\telse if (starts_with(refname, \"refs/\"))\n\t\trefname = refname + 5;\n\treturn refname;\n}\n\nstruct name_ref_data {\n\tint tags_only;\n\tint name_only;\n\tstruct string_list ref_filters;\n\tstruct string_list exclude_filters;\n};\n\nstatic struct tip_table {\n\tstruct tip_table_entry {\n\t\tstruct object_id oid;\n\t\tconst char *refname;\n\t} *table;\n\tint nr;\n\tint alloc;\n\tint sorted;\n} tip_table;\n\nstatic void add_to_tip_table(const struct object_id *oid, const char *refname,\n\t\t\t     int shorten_unambiguous)\n{\n\trefname = name_ref_abbrev(refname, shorten_unambiguous);\n\n\tALLOC_GROW(tip_table.table, tip_table.nr + 1, tip_table.alloc);\n\toidcpy(&tip_table.table[tip_table.nr].oid, oid);\n\ttip_table.table[tip_table.nr].refname = xstrdup(refname);\n\ttip_table.nr++;\n\ttip_table.sorted = 0;\n}\n\nstatic int tipcmp(const void *a_, const void *b_)\n{\n\tconst struct tip_table_entry *a = a_, *b = b_;\n\treturn oidcmp(&a->oid, &b->oid);\n}\n\nstatic int name_ref(const char *path, const struct object_id *oid, int flags, void *cb_data)\n{\n\tstruct object *o = parse_object(oid->hash);\n\tstruct name_ref_data *data = cb_data;\n\tint can_abbreviate_output = data->tags_only && data->name_only;\n\tint deref = 0;\n\tunsigned long taggerdate = ULONG_MAX;\n\n\tif (data->tags_only && !starts_with(path, \"refs/tags/\"))\n\t\treturn 0;\n\n\tif (data->exclude_filters.nr) {\n\t\tstruct string_list_item *item;\n\n\t\tfor_each_string_list_item(item, &data->exclude_filters) {\n\t\t\tif (subpath_matches(path, item->string) >= 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (data->ref_filters.nr) {\n\t\tstruct string_list_item *item;\n\t\tint matched = 0;\n\n\t\t/* See if any of the patterns match. */\n\t\tfor_each_string_list_item(item, &data->ref_filters) {\n\t\t\t/*\n\t\t\t * Check all patterns even after finding a match, so\n\t\t\t * that we can see if a match with a subpath exists.\n\t\t\t * When a user asked for 'refs/tags/v*' and 'v1.*',\n\t\t\t * both of which match, the user is showing her\n\t\t\t * willingness to accept a shortened output by having\n\t\t\t * the 'v1.*' in the acceptable refnames, so we\n\t\t\t * shouldn't stop when seeing 'refs/tags/v1.4' matches\n\t\t\t * 'refs/tags/v*'.  We should show it as 'v1.4'.\n\t\t\t */\n\t\t\tswitch (subpath_matches(path, item->string)) {\n\t\t\tcase -1: /* did not match */\n\t\t\t\tbreak;\n\t\t\tcase 0: /* matched fully */\n\t\t\t\tmatched = 1;\n\t\t\t\tbreak;\n\t\t\tdefault: /* matched subpath */\n\t\t\t\tmatched = 1;\n\t\t\t\tcan_abbreviate_output = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* If none of the patterns matched, stop now */\n\t\tif (!matched)\n\t\t\treturn 0;\n\t}\n\n\tadd_to_tip_table(oid, path, can_abbreviate_output);\n\n\twhile (o && o->type == OBJ_TAG) {\n\t\tstruct tag *t = (struct tag *) o;\n\t\tif (!t->tagged)\n\t\t\tbreak; /* broken repository */\n\t\to = parse_object(t->tagged->oid.hash);\n\t\tderef = 1;\n\t\ttaggerdate = t->date;\n\t}\n\tif (o && o->type == OBJ_COMMIT) {\n\t\tstruct commit *commit = (struct commit *)o;\n\n\t\tpath = name_ref_abbrev(path, can_abbreviate_output);\n\t\tname_rev(commit, xstrdup(path), taggerdate, 0, 0, deref);\n\t}\n\treturn 0;\n}\n\nstatic const unsigned char *nth_tip_table_ent(size_t ix, void *table_)\n{\n\tstruct tip_table_entry *table = table_;\n\treturn table[ix].oid.hash;\n}\n\nstatic const char *get_exact_ref_match(const struct object *o)\n{\n\tint found;\n\n\tif (!tip_table.table || !tip_table.nr)\n\t\treturn NULL;\n\n\tif (!tip_table.sorted) {\n\t\tQSORT(tip_table.table, tip_table.nr, tipcmp);\n\t\ttip_table.sorted = 1;\n\t}\n\n\tfound = sha1_pos(o->oid.hash, tip_table.table, tip_table.nr,\n\t\t\t nth_tip_table_ent);\n\tif (0 <= found)\n\t\treturn tip_table.table[found].refname;\n\treturn NULL;\n}\n\n/* may return a constant string or use \"buf\" as scratch space */\nstatic const char *get_rev_name(const struct object *o, struct strbuf *buf)\n{\n\tstruct rev_name *n;\n\tstruct commit *c;\n\n\tif (o->type != OBJ_COMMIT)\n\t\treturn get_exact_ref_match(o);\n\tc = (struct commit *) o;\n\tn = c->util;\n\tif (!n)\n\t\treturn NULL;\n\n\tif (!n->generation)\n\t\treturn n->tip_name;\n\telse {\n\t\tint len = strlen(n->tip_name);\n\t\tif (len > 2 && !strcmp(n->tip_name + len - 2, \"^0\"))\n\t\t\tlen -= 2;\n\t\tstrbuf_reset(buf);\n\t\tstrbuf_addf(buf, \"%.*s~%d\", len, n->tip_name, n->generation);\n\t\treturn buf->buf;\n\t}\n}\n\nstatic void show_name(const struct object *obj,\n\t\t      const char *caller_name,\n\t\t      int always, int allow_undefined, int name_only)\n{\n\tconst char *name;\n\tconst struct object_id *oid = &obj->oid;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tif (!name_only)\n\t\tprintf(\"%s \", caller_name ? caller_name : oid_to_hex(oid));\n\tname = get_rev_name(obj, &buf);\n\tif (name)\n\t\tprintf(\"%s\\n\", name);\n\telse if (allow_undefined)\n\t\tprintf(\"undefined\\n\");\n\telse if (always)\n\t\tprintf(\"%s\\n\", find_unique_abbrev(oid->hash, DEFAULT_ABBREV));\n\telse\n\t\tdie(\"cannot describe '%s'\", oid_to_hex(oid));\n\tstrbuf_release(&buf);\n}\n\nstatic char const * const name_rev_usage[] = {\n\tN_(\"git name-rev [<options>] <commit>...\"),\n\tN_(\"git name-rev [<options>] --all\"),\n\tN_(\"git name-rev [<options>] --stdin\"),\n\tNULL\n};\n\nstatic void name_rev_line(char *p, struct name_ref_data *data)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tint forty = 0;\n\tchar *p_start;\n\tfor (p_start = p; *p; p++) {\n#define ishex(x) (isdigit((x)) || ((x) >= 'a' && (x) <= 'f'))\n\t\tif (!ishex(*p))\n\t\t\tforty = 0;\n\t\telse if (++forty == GIT_SHA1_HEXSZ &&\n\t\t\t !ishex(*(p+1))) {\n\t\t\tstruct object_id oid;\n\t\t\tconst char *name = NULL;\n\t\t\tchar c = *(p+1);\n\t\t\tint p_len = p - p_start + 1;\n\n\t\t\tforty = 0;\n\n\t\t\t*(p+1) = 0;\n\t\t\tif (!get_oid(p - (GIT_SHA1_HEXSZ - 1), &oid)) {\n\t\t\t\tstruct object *o =\n\t\t\t\t\tlookup_object(oid.hash);\n\t\t\t\tif (o)\n\t\t\t\t\tname = get_rev_name(o, &buf);\n\t\t\t}\n\t\t\t*(p+1) = c;\n\n\t\t\tif (!name)\n\t\t\t\tcontinue;\n\n\t\t\tif (data->name_only)\n\t\t\t\tprintf(\"%.*s%s\", p_len - GIT_SHA1_HEXSZ, p_start, name);\n\t\t\telse\n\t\t\t\tprintf(\"%.*s (%s)\", p_len, p_start, name);\n\t\t\tp_start = p + 1;\n\t\t}\n\t}\n\n\t/* flush */\n\tif (p_start != p)\n\t\tfwrite(p_start, p - p_start, 1, stdout);\n\n\tstrbuf_release(&buf);\n}\n\nint cmd_name_rev(int argc, const char **argv, const char *prefix)\n{\n\tstruct object_array revs = OBJECT_ARRAY_INIT;\n\tint all = 0, transform_stdin = 0, allow_undefined = 1, always = 0, peel_tag = 0;\n\tstruct name_ref_data data = { 0, 0, STRING_LIST_INIT_NODUP, STRING_LIST_INIT_NODUP };\n\tstruct option opts[] = {\n\t\tOPT_BOOL(0, \"name-only\", &data.name_only, N_(\"print only names (no SHA-1)\")),\n\t\tOPT_BOOL(0, \"tags\", &data.tags_only, N_(\"only use tags to name the commits\")),\n\t\tOPT_STRING_LIST(0, \"refs\", &data.ref_filters, N_(\"pattern\"),\n\t\t\t\t   N_(\"only use refs matching <pattern>\")),\n\t\tOPT_STRING_LIST(0, \"exclude\", &data.exclude_filters, N_(\"pattern\"),\n\t\t\t\t   N_(\"ignore refs matching <pattern>\")),\n\t\tOPT_GROUP(\"\"),\n\t\tOPT_BOOL(0, \"all\", &all, N_(\"list all commits reachable from all refs\")),\n\t\tOPT_BOOL(0, \"stdin\", &transform_stdin, N_(\"read from stdin\")),\n\t\tOPT_BOOL(0, \"undefined\", &allow_undefined, N_(\"allow to print `undefined` names (default)\")),\n\t\tOPT_BOOL(0, \"always\",     &always,\n\t\t\t   N_(\"show abbreviated commit object as fallback\")),\n\t\t{\n\t\t\t/* A Hidden OPT_BOOL */\n\t\t\tOPTION_SET_INT, 0, \"peel-tag\", &peel_tag, NULL,\n\t\t\tN_(\"dereference tags in the input (internal use)\"),\n\t\t\tPARSE_OPT_NOARG | PARSE_OPT_HIDDEN, NULL, 1,\n\t\t},\n\t\tOPT_END(),\n\t};\n\n\tgit_config(git_default_config, NULL);\n\targc = parse_options(argc, argv, prefix, opts, name_rev_usage, 0);\n\tif (all + transform_stdin + !!argc > 1) {\n\t\terror(\"Specify either a list, or --all, not both!\");\n\t\tusage_with_options(name_rev_usage, opts);\n\t}\n\tif (all || transform_stdin)\n\t\tcutoff = 0;\n\n\tfor (; argc; argc--, argv++) {\n\t\tstruct object_id oid;\n\t\tstruct object *object;\n\t\tstruct commit *commit;\n\n\t\tif (get_oid(*argv, &oid)) {\n\t\t\tfprintf(stderr, \"Could not get sha1 for %s. Skipping.\\n\",\n\t\t\t\t\t*argv);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcommit = NULL;\n\t\tobject = parse_object(oid.hash);\n\t\tif (object) {\n\t\t\tstruct object *peeled = deref_tag(object, *argv, 0);\n\t\t\tif (peeled && peeled->type == OBJ_COMMIT)\n\t\t\t\tcommit = (struct commit *)peeled;\n\t\t}\n\n\t\tif (!object) {\n\t\t\tfprintf(stderr, \"Could not get object for %s. Skipping.\\n\",\n\t\t\t\t\t*argv);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (commit) {\n\t\t\tif (cutoff > commit->date)\n\t\t\t\tcutoff = commit->date;\n\t\t}\n\n\t\tif (peel_tag) {\n\t\t\tif (!commit) {\n\t\t\t\tfprintf(stderr, \"Could not get commit for %s. Skipping.\\n\",\n\t\t\t\t\t*argv);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tobject = (struct object *)commit;\n\t\t}\n\t\tadd_object_array(object, *argv, &revs);\n\t}\n\n\tif (cutoff)\n\t\tcutoff = cutoff - CUTOFF_DATE_SLOP;\n\tfor_each_ref(name_ref, &data);\n\n\tif (transform_stdin) {\n\t\tchar buffer[2048];\n\n\t\twhile (!feof(stdin)) {\n\t\t\tchar *p = fgets(buffer, sizeof(buffer), stdin);\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\t\t\tname_rev_line(p, &data);\n\t\t}\n\t} else if (all) {\n\t\tint i, max;\n\n\t\tmax = get_max_object_index();\n\t\tfor (i = 0; i < max; i++) {\n\t\t\tstruct object *obj = get_indexed_object(i);\n\t\t\tif (!obj || obj->type != OBJ_COMMIT)\n\t\t\t\tcontinue;\n\t\t\tshow_name(obj, NULL,\n\t\t\t\t  always, allow_undefined, data.name_only);\n\t\t}\n\t} else {\n\t\tint i;\n\t\tfor (i = 0; i < revs.nr; i++)\n\t\t\tshow_name(revs.objects[i].item, revs.objects[i].name,\n\t\t\t\t  always, allow_undefined, data.name_only);\n\t}\n\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00760ecc6532825c97eb22381edc88e7fb01432d",
  "sha1_ok": true,
  "size": 11205
}
