{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgInN0cmJ1Zi5oIgojaW5jbHVkZSAic3RydmVjLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAic2lnY2hhaW4uaCIKCiNpZm5kZWYgREVGQVVMVF9FRElUT1IKI2RlZmluZSBERUZBVUxUX0VESVRPUiAidmkiCiNlbmRpZgoKaW50IGlzX3Rlcm1pbmFsX2R1bWIodm9pZCkKewoJY29uc3QgY2hhciAqdGVybWluYWwgPSBnZXRlbnYoIlRFUk0iKTsKCXJldHVybiAhdGVybWluYWwgfHwgIXN0cmNtcCh0ZXJtaW5hbCwgImR1bWIiKTsKfQoKY29uc3QgY2hhciAqZ2l0X2VkaXRvcih2b2lkKQp7Cgljb25zdCBjaGFyICplZGl0b3IgPSBnZXRlbnYoIkdJVF9FRElUT1IiKTsKCWludCB0ZXJtaW5hbF9pc19kdW1iID0gaXNfdGVybWluYWxfZHVtYigpOwoKCWlmICghZWRpdG9yICYmIGVkaXRvcl9wcm9ncmFtKQoJCWVkaXRvciA9IGVkaXRvcl9wcm9ncmFtOwoJaWYgKCFlZGl0b3IgJiYgIXRlcm1pbmFsX2lzX2R1bWIpCgkJZWRpdG9yID0gZ2V0ZW52KCJWSVNVQUwiKTsKCWlmICghZWRpdG9yKQoJCWVkaXRvciA9IGdldGVudigiRURJVE9SIik7CgoJaWYgKCFlZGl0b3IgJiYgdGVybWluYWxfaXNfZHVtYikKCQlyZXR1cm4gTlVMTDsKCglpZiAoIWVkaXRvcikKCQllZGl0b3IgPSBERUZBVUxUX0VESVRPUjsKCglyZXR1cm4gZWRpdG9yOwp9Cgpjb25zdCBjaGFyICpnaXRfc2VxdWVuY2VfZWRpdG9yKHZvaWQpCnsKCWNvbnN0IGNoYXIgKmVkaXRvciA9IGdldGVudigiR0lUX1NFUVVFTkNFX0VESVRPUiIpOwoKCWlmICghZWRpdG9yKQoJCWdpdF9jb25maWdfZ2V0X3N0cmluZ190bXAoInNlcXVlbmNlLmVkaXRvciIsICZlZGl0b3IpOwoJaWYgKCFlZGl0b3IpCgkJZWRpdG9yID0gZ2l0X2VkaXRvcigpOwoKCXJldHVybiBlZGl0b3I7Cn0KCnN0YXRpYyBpbnQgbGF1bmNoX3NwZWNpZmllZF9lZGl0b3IoY29uc3QgY2hhciAqZWRpdG9yLCBjb25zdCBjaGFyICpwYXRoLAoJCQkJICAgc3RydWN0IHN0cmJ1ZiAqYnVmZmVyLCBjb25zdCBjaGFyICpjb25zdCAqZW52KQp7CglpZiAoIWVkaXRvcikKCQlyZXR1cm4gZXJyb3IoIlRlcm1pbmFsIGlzIGR1bWIsIGJ1dCBFRElUT1IgdW5zZXQiKTsKCglpZiAoc3RyY21wKGVkaXRvciwgIjoiKSkgewoJCXN0cnVjdCBzdHJidWYgcmVhbHBhdGggPSBTVFJCVUZfSU5JVDsKCQlzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBwID0gQ0hJTERfUFJPQ0VTU19JTklUOwoJCWludCByZXQsIHNpZzsKCQlpbnQgcHJpbnRfd2FpdGluZ19mb3JfZWRpdG9yID0gYWR2aWNlX2VuYWJsZWQoQURWSUNFX1dBSVRJTkdfRk9SX0VESVRPUikgJiYgaXNhdHR5KDIpOwoKCQlpZiAocHJpbnRfd2FpdGluZ19mb3JfZWRpdG9yKSB7CgkJCS8qCgkJCSAqIEEgZHVtYiB0ZXJtaW5hbCBjYW5ub3QgZXJhc2UgdGhlIGxpbmUgbGF0ZXIgb24uIEFkZCBhCgkJCSAqIG5ld2xpbmUgdG8gc2VwYXJhdGUgdGhlIGhpbnQgZnJvbSBzdWJzZXF1ZW50IG91dHB1dC4KCQkJICoKCQkJICogTWFrZSBzdXJlIHRoYXQgb3VyIG1lc3NhZ2UgaXMgc2VwYXJhdGVkIHdpdGggYSB3aGl0ZXNwYWNlCgkJCSAqIGZyb20gZnVydGhlciBjcnVmdCB0aGF0IG1heSBiZSB3cml0dGVuIGJ5IHRoZSBlZGl0b3IuCgkJCSAqLwoJCQljb25zdCBjaGFyIHRlcm0gPSBpc190ZXJtaW5hbF9kdW1iKCkgPyAnXG4nIDogJyAnOwoKCQkJZnByaW50ZihzdGRlcnIsCgkJCQlfKCJoaW50OiBXYWl0aW5nIGZvciB5b3VyIGVkaXRvciB0byBjbG9zZSB0aGUgZmlsZS4uLiVjIiksCgkJCQl0ZXJtKTsKCQkJZmZsdXNoKHN0ZGVycik7CgkJfQoKCQlzdHJidWZfcmVhbHBhdGgoJnJlYWxwYXRoLCBwYXRoLCAxKTsKCgkJc3RydmVjX3B1c2hsKCZwLmFyZ3MsIGVkaXRvciwgcmVhbHBhdGguYnVmLCBOVUxMKTsKCQlpZiAoZW52KQoJCQlzdHJ2ZWNfcHVzaHYoJnAuZW52LCAoY29uc3QgY2hhciAqKillbnYpOwoJCXAudXNlX3NoZWxsID0gMTsKCQlwLnRyYWNlMl9jaGlsZF9jbGFzcyA9ICJlZGl0b3IiOwoJCWlmIChzdGFydF9jb21tYW5kKCZwKSA8IDApIHsKCQkJc3RyYnVmX3JlbGVhc2UoJnJlYWxwYXRoKTsKCQkJcmV0dXJuIGVycm9yKCJ1bmFibGUgdG8gc3RhcnQgZWRpdG9yICclcyciLCBlZGl0b3IpOwoJCX0KCgkJc2lnY2hhaW5fcHVzaChTSUdJTlQsIFNJR19JR04pOwoJCXNpZ2NoYWluX3B1c2goU0lHUVVJVCwgU0lHX0lHTik7CgkJcmV0ID0gZmluaXNoX2NvbW1hbmQoJnApOwoJCXN0cmJ1Zl9yZWxlYXNlKCZyZWFscGF0aCk7CgkJc2lnID0gcmV0IC0gMTI4OwoJCXNpZ2NoYWluX3BvcChTSUdJTlQpOwoJCXNpZ2NoYWluX3BvcChTSUdRVUlUKTsKCQlpZiAoc2lnID09IFNJR0lOVCB8fCBzaWcgPT0gU0lHUVVJVCkKCQkJcmFpc2Uoc2lnKTsKCQlpZiAocmV0KQoJCQlyZXR1cm4gZXJyb3IoIlRoZXJlIHdhcyBhIHByb2JsZW0gd2l0aCB0aGUgZWRpdG9yICclcycuIiwKCQkJCQllZGl0b3IpOwoKCQlpZiAocHJpbnRfd2FpdGluZ19mb3JfZWRpdG9yICYmICFpc190ZXJtaW5hbF9kdW1iKCkpCgkJCS8qCgkJCSAqIEVyYXNlIHRoZSBlbnRpcmUgbGluZSB0byBhdm9pZCB3YXN0aW5nIHRoZQoJCQkgKiB2ZXJ0aWNhbCBzcGFjZS4KCQkJICovCgkJCXRlcm1fY2xlYXJfbGluZSgpOwoJfQoKCWlmICghYnVmZmVyKQoJCXJldHVybiAwOwoJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoYnVmZmVyLCBwYXRoLCAwKSA8IDApCgkJcmV0dXJuIGVycm9yX2Vycm5vKCJjb3VsZCBub3QgcmVhZCBmaWxlICclcyciLCBwYXRoKTsKCXJldHVybiAwOwp9CgppbnQgbGF1bmNoX2VkaXRvcihjb25zdCBjaGFyICpwYXRoLCBzdHJ1Y3Qgc3RyYnVmICpidWZmZXIsIGNvbnN0IGNoYXIgKmNvbnN0ICplbnYpCnsKCXJldHVybiBsYXVuY2hfc3BlY2lmaWVkX2VkaXRvcihnaXRfZWRpdG9yKCksIHBhdGgsIGJ1ZmZlciwgZW52KTsKfQoKaW50IGxhdW5jaF9zZXF1ZW5jZV9lZGl0b3IoY29uc3QgY2hhciAqcGF0aCwgc3RydWN0IHN0cmJ1ZiAqYnVmZmVyLAoJCQkgICBjb25zdCBjaGFyICpjb25zdCAqZW52KQp7CglyZXR1cm4gbGF1bmNoX3NwZWNpZmllZF9lZGl0b3IoZ2l0X3NlcXVlbmNlX2VkaXRvcigpLCBwYXRoLCBidWZmZXIsIGVudik7Cn0K",
    "text": "#include \"cache.h\"\n#include \"config.h\"\n#include \"strbuf.h\"\n#include \"strvec.h\"\n#include \"run-command.h\"\n#include \"sigchain.h\"\n\n#ifndef DEFAULT_EDITOR\n#define DEFAULT_EDITOR \"vi\"\n#endif\n\nint is_terminal_dumb(void)\n{\n\tconst char *terminal = getenv(\"TERM\");\n\treturn !terminal || !strcmp(terminal, \"dumb\");\n}\n\nconst char *git_editor(void)\n{\n\tconst char *editor = getenv(\"GIT_EDITOR\");\n\tint terminal_is_dumb = is_terminal_dumb();\n\n\tif (!editor && editor_program)\n\t\teditor = editor_program;\n\tif (!editor && !terminal_is_dumb)\n\t\teditor = getenv(\"VISUAL\");\n\tif (!editor)\n\t\teditor = getenv(\"EDITOR\");\n\n\tif (!editor && terminal_is_dumb)\n\t\treturn NULL;\n\n\tif (!editor)\n\t\teditor = DEFAULT_EDITOR;\n\n\treturn editor;\n}\n\nconst char *git_sequence_editor(void)\n{\n\tconst char *editor = getenv(\"GIT_SEQUENCE_EDITOR\");\n\n\tif (!editor)\n\t\tgit_config_get_string_tmp(\"sequence.editor\", &editor);\n\tif (!editor)\n\t\teditor = git_editor();\n\n\treturn editor;\n}\n\nstatic int launch_specified_editor(const char *editor, const char *path,\n\t\t\t\t   struct strbuf *buffer, const char *const *env)\n{\n\tif (!editor)\n\t\treturn error(\"Terminal is dumb, but EDITOR unset\");\n\n\tif (strcmp(editor, \":\")) {\n\t\tstruct strbuf realpath = STRBUF_INIT;\n\t\tstruct child_process p = CHILD_PROCESS_INIT;\n\t\tint ret, sig;\n\t\tint print_waiting_for_editor = advice_enabled(ADVICE_WAITING_FOR_EDITOR) && isatty(2);\n\n\t\tif (print_waiting_for_editor) {\n\t\t\t/*\n\t\t\t * A dumb terminal cannot erase the line later on. Add a\n\t\t\t * newline to separate the hint from subsequent output.\n\t\t\t *\n\t\t\t * Make sure that our message is separated with a whitespace\n\t\t\t * from further cruft that may be written by the editor.\n\t\t\t */\n\t\t\tconst char term = is_terminal_dumb() ? '\\n' : ' ';\n\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"hint: Waiting for your editor to close the file...%c\"),\n\t\t\t\tterm);\n\t\t\tfflush(stderr);\n\t\t}\n\n\t\tstrbuf_realpath(&realpath, path, 1);\n\n\t\tstrvec_pushl(&p.args, editor, realpath.buf, NULL);\n\t\tif (env)\n\t\t\tstrvec_pushv(&p.env, (const char **)env);\n\t\tp.use_shell = 1;\n\t\tp.trace2_child_class = \"editor\";\n\t\tif (start_command(&p) < 0) {\n\t\t\tstrbuf_release(&realpath);\n\t\t\treturn error(\"unable to start editor '%s'\", editor);\n\t\t}\n\n\t\tsigchain_push(SIGINT, SIG_IGN);\n\t\tsigchain_push(SIGQUIT, SIG_IGN);\n\t\tret = finish_command(&p);\n\t\tstrbuf_release(&realpath);\n\t\tsig = ret - 128;\n\t\tsigchain_pop(SIGINT);\n\t\tsigchain_pop(SIGQUIT);\n\t\tif (sig == SIGINT || sig == SIGQUIT)\n\t\t\traise(sig);\n\t\tif (ret)\n\t\t\treturn error(\"There was a problem with the editor '%s'.\",\n\t\t\t\t\teditor);\n\n\t\tif (print_waiting_for_editor && !is_terminal_dumb())\n\t\t\t/*\n\t\t\t * Erase the entire line to avoid wasting the\n\t\t\t * vertical space.\n\t\t\t */\n\t\t\tterm_clear_line();\n\t}\n\n\tif (!buffer)\n\t\treturn 0;\n\tif (strbuf_read_file(buffer, path, 0) < 0)\n\t\treturn error_errno(\"could not read file '%s'\", path);\n\treturn 0;\n}\n\nint launch_editor(const char *path, struct strbuf *buffer, const char *const *env)\n{\n\treturn launch_specified_editor(git_editor(), path, buffer, env);\n}\n\nint launch_sequence_editor(const char *path, struct strbuf *buffer,\n\t\t\t   const char *const *env)\n{\n\treturn launch_specified_editor(git_sequence_editor(), path, buffer, env);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "008c04fe2f6e0a8b39bc02005f0a576d92784bae",
  "sha1_ok": true,
  "size": 3111
}
