{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGNvbW1pdCIKICoKICogQ29weXJpZ2h0IChjKSAyMDA3IEtyaXN0aWFuIEjDuGdzYmVyZyA8a3JoQHJlZGhhdC5jb20+CiAqIEJhc2VkIG9uIGdpdC1jb21taXQuc2ggYnkgSnVuaW8gQyBIYW1hbm8gYW5kIExpbnVzIFRvcnZhbGRzCiAqLwoKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjYWNoZS10cmVlLmgiCiNpbmNsdWRlICJjb2xvci5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJkaWZmLmgiCiNpbmNsdWRlICJkaWZmY29yZS5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAid3Qtc3RhdHVzLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAibG9nLXRyZWUuaCIKI2luY2x1ZGUgInN0cmJ1Zi5oIgojaW5jbHVkZSAidXRmOC5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgInJlcmVyZS5oIgojaW5jbHVkZSAidW5wYWNrLXRyZWVzLmgiCiNpbmNsdWRlICJxdW90ZS5oIgojaW5jbHVkZSAic3VibW9kdWxlLmgiCiNpbmNsdWRlICJncGctaW50ZXJmYWNlLmgiCiNpbmNsdWRlICJjb2x1bW4uaCIKI2luY2x1ZGUgInNlcXVlbmNlci5oIgojaW5jbHVkZSAibm90ZXMtdXRpbHMuaCIKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgYnVpbHRpbl9jb21taXRfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgY29tbWl0IFtvcHRpb25zXSBbLS1dIDxwYXRoc3BlYz4uLi4iKSwKCU5VTEwKfTsKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgYnVpbHRpbl9zdGF0dXNfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgc3RhdHVzIFtvcHRpb25zXSBbLS1dIDxwYXRoc3BlYz4uLi4iKSwKCU5VTEwKfTsKCnN0YXRpYyBjb25zdCBjaGFyIGltcGxpY2l0X2lkZW50X2FkdmljZVtdID0KTl8oIllvdXIgbmFtZSBhbmQgZW1haWwgYWRkcmVzcyB3ZXJlIGNvbmZpZ3VyZWQgYXV0b21hdGljYWxseSBiYXNlZFxuIgoib24geW91ciB1c2VybmFtZSBhbmQgaG9zdG5hbWUuIFBsZWFzZSBjaGVjayB0aGF0IHRoZXkgYXJlIGFjY3VyYXRlLlxuIgoiWW91IGNhbiBzdXBwcmVzcyB0aGlzIG1lc3NhZ2UgYnkgc2V0dGluZyB0aGVtIGV4cGxpY2l0bHk6XG4iCiJcbiIKIiAgICBnaXQgY29uZmlnIC0tZ2xvYmFsIHVzZXIubmFtZSBcIllvdXIgTmFtZVwiXG4iCiIgICAgZ2l0IGNvbmZpZyAtLWdsb2JhbCB1c2VyLmVtYWlsIHlvdUBleGFtcGxlLmNvbVxuIgoiXG4iCiJBZnRlciBkb2luZyB0aGlzLCB5b3UgbWF5IGZpeCB0aGUgaWRlbnRpdHkgdXNlZCBmb3IgdGhpcyBjb21taXQgd2l0aDpcbiIKIlxuIgoiICAgIGdpdCBjb21taXQgLS1hbWVuZCAtLXJlc2V0LWF1dGhvclxuIik7CgpzdGF0aWMgY29uc3QgY2hhciBlbXB0eV9hbWVuZF9hZHZpY2VbXSA9Ck5fKCJZb3UgYXNrZWQgdG8gYW1lbmQgdGhlIG1vc3QgcmVjZW50IGNvbW1pdCwgYnV0IGRvaW5nIHNvIHdvdWxkIG1ha2VcbiIKIml0IGVtcHR5LiBZb3UgY2FuIHJlcGVhdCB5b3VyIGNvbW1hbmQgd2l0aCAtLWFsbG93LWVtcHR5LCBvciB5b3UgY2FuXG4iCiJyZW1vdmUgdGhlIGNvbW1pdCBlbnRpcmVseSB3aXRoIFwiZ2l0IHJlc2V0IEhFQUReXCIuXG4iKTsKCnN0YXRpYyBjb25zdCBjaGFyIGVtcHR5X2NoZXJyeV9waWNrX2FkdmljZVtdID0KTl8oIlRoZSBwcmV2aW91cyBjaGVycnktcGljayBpcyBub3cgZW1wdHksIHBvc3NpYmx5IGR1ZSB0byBjb25mbGljdCByZXNvbHV0aW9uLlxuIgoiSWYgeW91IHdpc2ggdG8gY29tbWl0IGl0IGFueXdheSwgdXNlOlxuIgoiXG4iCiIgICAgZ2l0IGNvbW1pdCAtLWFsbG93LWVtcHR5XG4iCiJcbiIKIk90aGVyd2lzZSwgcGxlYXNlIHVzZSAnZ2l0IHJlc2V0J1xuIik7CgpzdGF0aWMgY29uc3QgY2hhciAqdXNlX21lc3NhZ2VfYnVmZmVyOwpzdGF0aWMgY29uc3QgY2hhciBjb21taXRfZWRpdG1zZ1tdID0gIkNPTU1JVF9FRElUTVNHIjsKc3RhdGljIHN0cnVjdCBsb2NrX2ZpbGUgaW5kZXhfbG9jazsgLyogcmVhbCBpbmRleCAqLwpzdGF0aWMgc3RydWN0IGxvY2tfZmlsZSBmYWxzZV9sb2NrOyAvKiB1c2VkIG9ubHkgZm9yIHBhcnRpYWwgY29tbWl0cyAqLwpzdGF0aWMgZW51bSB7CglDT01NSVRfQVNfSVMgPSAxLAoJQ09NTUlUX05PUk1BTCwKCUNPTU1JVF9QQVJUSUFMCn0gY29tbWl0X3N0eWxlOwoKc3RhdGljIGNvbnN0IGNoYXIgKmxvZ2ZpbGUsICpmb3JjZV9hdXRob3I7CnN0YXRpYyBjb25zdCBjaGFyICp0ZW1wbGF0ZV9maWxlOwovKgogKiBUaGUgX21lc3NhZ2UgdmFyaWFibGVzIGFyZSBjb21taXQgbmFtZXMgZnJvbSB3aGljaCB0byB0YWtlCiAqIHRoZSBjb21taXQgbWVzc2FnZSBhbmQvb3IgYXV0aG9yc2hpcC4KICovCnN0YXRpYyBjb25zdCBjaGFyICphdXRob3JfbWVzc2FnZSwgKmF1dGhvcl9tZXNzYWdlX2J1ZmZlcjsKc3RhdGljIGNoYXIgKmVkaXRfbWVzc2FnZSwgKnVzZV9tZXNzYWdlOwpzdGF0aWMgY2hhciAqZml4dXBfbWVzc2FnZSwgKnNxdWFzaF9tZXNzYWdlOwpzdGF0aWMgaW50IGFsbCwgYWxzbywgaW50ZXJhY3RpdmUsIHBhdGNoX2ludGVyYWN0aXZlLCBvbmx5LCBhbWVuZCwgc2lnbm9mZjsKc3RhdGljIGludCBlZGl0X2ZsYWcgPSAtMTsgLyogdW5zcGVjaWZpZWQgKi8Kc3RhdGljIGludCBxdWlldCwgdmVyYm9zZSwgbm9fdmVyaWZ5LCBhbGxvd19lbXB0eSwgZHJ5X3J1biwgcmVuZXdfYXV0aG9yc2hpcDsKc3RhdGljIGludCBub19wb3N0X3Jld3JpdGUsIGFsbG93X2VtcHR5X21lc3NhZ2U7CnN0YXRpYyBjaGFyICp1bnRyYWNrZWRfZmlsZXNfYXJnLCAqZm9yY2VfZGF0ZSwgKmlnbm9yZV9zdWJtb2R1bGVfYXJnOwpzdGF0aWMgY2hhciAqc2lnbl9jb21taXQ7CgovKgogKiBUaGUgZGVmYXVsdCBjb21taXQgbWVzc2FnZSBjbGVhbnVwIG1vZGUgd2lsbCByZW1vdmUgdGhlIGxpbmVzCiAqIGJlZ2lubmluZyB3aXRoICMgKHNoZWxsIGNvbW1lbnRzKSBhbmQgbGVhZGluZyBhbmQgdHJhaWxpbmcKICogd2hpdGVzcGFjZXMgKGVtcHR5IGxpbmVzIG9yIGNvbnRhaW5pbmcgb25seSB3aGl0ZXNwYWNlcykKICogaWYgZWRpdG9yIGlzIHVzZWQsIGFuZCBvbmx5IHRoZSB3aGl0ZXNwYWNlcyBpZiB0aGUgbWVzc2FnZQogKiBpcyBzcGVjaWZpZWQgZXhwbGljaXRseS4KICovCnN0YXRpYyBlbnVtIHsKCUNMRUFOVVBfU1BBQ0UsCglDTEVBTlVQX05PTkUsCglDTEVBTlVQX0FMTAp9IGNsZWFudXBfbW9kZTsKc3RhdGljIGNvbnN0IGNoYXIgKmNsZWFudXBfYXJnOwoKc3RhdGljIGVudW0gY29tbWl0X3doZW5jZSB3aGVuY2U7CnN0YXRpYyBpbnQgdXNlX2VkaXRvciA9IDEsIGluY2x1ZGVfc3RhdHVzID0gMTsKc3RhdGljIGludCBzaG93X2lnbm9yZWRfaW5fc3RhdHVzLCBoYXZlX29wdGlvbl9tOwpzdGF0aWMgY29uc3QgY2hhciAqb25seV9pbmNsdWRlX2Fzc3VtZWQ7CnN0YXRpYyBzdHJ1Y3Qgc3RyYnVmIG1lc3NhZ2UgPSBTVFJCVUZfSU5JVDsKCnN0YXRpYyBlbnVtIHN0YXR1c19mb3JtYXQgewoJU1RBVFVTX0ZPUk1BVF9OT05FID0gMCwKCVNUQVRVU19GT1JNQVRfTE9ORywKCVNUQVRVU19GT1JNQVRfU0hPUlQsCglTVEFUVVNfRk9STUFUX1BPUkNFTEFJTiwKCglTVEFUVVNfRk9STUFUX1VOU1BFQ0lGSUVECn0gc3RhdHVzX2Zvcm1hdCA9IFNUQVRVU19GT1JNQVRfVU5TUEVDSUZJRUQ7CgpzdGF0aWMgaW50IG9wdF9wYXJzZV9tKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCXN0cnVjdCBzdHJidWYgKmJ1ZiA9IG9wdC0+dmFsdWU7CglpZiAodW5zZXQpIHsKCQloYXZlX29wdGlvbl9tID0gMDsKCQlzdHJidWZfc2V0bGVuKGJ1ZiwgMCk7Cgl9IGVsc2UgewoJCWhhdmVfb3B0aW9uX20gPSAxOwoJCWlmIChidWYtPmxlbikKCQkJc3RyYnVmX2FkZGNoKGJ1ZiwgJ1xuJyk7CgkJc3RyYnVmX2FkZHN0cihidWYsIGFyZyk7CgkJc3RyYnVmX2NvbXBsZXRlX2xpbmUoYnVmKTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBkZXRlcm1pbmVfd2hlbmNlKHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWlmIChmaWxlX2V4aXN0cyhnaXRfcGF0aCgiTUVSR0VfSEVBRCIpKSkKCQl3aGVuY2UgPSBGUk9NX01FUkdFOwoJZWxzZSBpZiAoZmlsZV9leGlzdHMoZ2l0X3BhdGgoIkNIRVJSWV9QSUNLX0hFQUQiKSkpCgkJd2hlbmNlID0gRlJPTV9DSEVSUllfUElDSzsKCWVsc2UKCQl3aGVuY2UgPSBGUk9NX0NPTU1JVDsKCWlmIChzKQoJCXMtPndoZW5jZSA9IHdoZW5jZTsKfQoKc3RhdGljIHZvaWQgcm9sbGJhY2tfaW5kZXhfZmlsZXModm9pZCkKewoJc3dpdGNoIChjb21taXRfc3R5bGUpIHsKCWNhc2UgQ09NTUlUX0FTX0lTOgoJCWJyZWFrOyAvKiBub3RoaW5nIHRvIGRvICovCgljYXNlIENPTU1JVF9OT1JNQUw6CgkJcm9sbGJhY2tfbG9ja19maWxlKCZpbmRleF9sb2NrKTsKCQlicmVhazsKCWNhc2UgQ09NTUlUX1BBUlRJQUw6CgkJcm9sbGJhY2tfbG9ja19maWxlKCZpbmRleF9sb2NrKTsKCQlyb2xsYmFja19sb2NrX2ZpbGUoJmZhbHNlX2xvY2spOwoJCWJyZWFrOwoJfQp9CgpzdGF0aWMgaW50IGNvbW1pdF9pbmRleF9maWxlcyh2b2lkKQp7CglpbnQgZXJyID0gMDsKCglzd2l0Y2ggKGNvbW1pdF9zdHlsZSkgewoJY2FzZSBDT01NSVRfQVNfSVM6CgkJYnJlYWs7IC8qIG5vdGhpbmcgdG8gZG8gKi8KCWNhc2UgQ09NTUlUX05PUk1BTDoKCQllcnIgPSBjb21taXRfbG9ja19maWxlKCZpbmRleF9sb2NrKTsKCQlicmVhazsKCWNhc2UgQ09NTUlUX1BBUlRJQUw6CgkJZXJyID0gY29tbWl0X2xvY2tfZmlsZSgmaW5kZXhfbG9jayk7CgkJcm9sbGJhY2tfbG9ja19maWxlKCZmYWxzZV9sb2NrKTsKCQlicmVhazsKCX0KCglyZXR1cm4gZXJyOwp9CgovKgogKiBUYWtlIGEgdW5pb24gb2YgcGF0aHMgaW4gdGhlIGluZGV4IGFuZCB0aGUgbmFtZWQgdHJlZSAodHlwaWNhbGx5LCAiSEVBRCIpLAogKiBhbmQgcmV0dXJuIHRoZSBwYXRocyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBwYXR0ZXJuIGluIGxpc3QuCiAqLwpzdGF0aWMgaW50IGxpc3RfcGF0aHMoc3RydWN0IHN0cmluZ19saXN0ICpsaXN0LCBjb25zdCBjaGFyICp3aXRoX3RyZWUsCgkJICAgICAgY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCBjaGFyICoqcGF0dGVybikKewoJaW50IGk7CgljaGFyICptOwoKCWlmICghcGF0dGVybikKCQlyZXR1cm4gMDsKCglmb3IgKGkgPSAwOyBwYXR0ZXJuW2ldOyBpKyspCgkJOwoJbSA9IHhjYWxsb2MoMSwgaSk7CgoJaWYgKHdpdGhfdHJlZSkgewoJCWNoYXIgKm1heF9wcmVmaXggPSBjb21tb25fcHJlZml4KHBhdHRlcm4pOwoJCW92ZXJsYXlfdHJlZV9vbl9jYWNoZSh3aXRoX3RyZWUsIG1heF9wcmVmaXggPyBtYXhfcHJlZml4IDogcHJlZml4KTsKCQlmcmVlKG1heF9wcmVmaXgpOwoJfQoKCWZvciAoaSA9IDA7IGkgPCBhY3RpdmVfbnI7IGkrKykgewoJCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBhY3RpdmVfY2FjaGVbaV07CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW07CgoJCWlmIChjZS0+Y2VfZmxhZ3MgJiBDRV9VUERBVEUpCgkJCWNvbnRpbnVlOwoJCWlmICghbWF0Y2hfcGF0aHNwZWMocGF0dGVybiwgY2UtPm5hbWUsIGNlX25hbWVsZW4oY2UpLCAwLCBtKSkKCQkJY29udGludWU7CgkJaXRlbSA9IHN0cmluZ19saXN0X2luc2VydChsaXN0LCBjZS0+bmFtZSk7CgkJaWYgKGNlX3NraXBfd29ya3RyZWUoY2UpKQoJCQlpdGVtLT51dGlsID0gaXRlbTsgLyogYmV0dGVyIGEgdmFsaWQgcG9pbnRlciB0aGFuIGEgZmFrZSBvbmUgKi8KCX0KCglyZXR1cm4gcmVwb3J0X3BhdGhfZXJyb3IobSwgcGF0dGVybiwgcHJlZml4KTsKfQoKc3RhdGljIHZvaWQgYWRkX3JlbW92ZV9maWxlcyhzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QpCnsKCWludCBpOwoJZm9yIChpID0gMDsgaSA8IGxpc3QtPm5yOyBpKyspIHsKCQlzdHJ1Y3Qgc3RhdCBzdDsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqcCA9ICYobGlzdC0+aXRlbXNbaV0pOwoKCQkvKiBwLT51dGlsIGlzIHNraXAtd29ya3RyZWUgKi8KCQlpZiAocC0+dXRpbCkKCQkJY29udGludWU7CgoJCWlmICghbHN0YXQocC0+c3RyaW5nLCAmc3QpKSB7CgkJCWlmIChhZGRfdG9fY2FjaGUocC0+c3RyaW5nLCAmc3QsIDApKQoJCQkJZGllKF8oInVwZGF0aW5nIGZpbGVzIGZhaWxlZCIpKTsKCQl9IGVsc2UKCQkJcmVtb3ZlX2ZpbGVfZnJvbV9jYWNoZShwLT5zdHJpbmcpOwoJfQp9CgpzdGF0aWMgdm9pZCBjcmVhdGVfYmFzZV9pbmRleChjb25zdCBzdHJ1Y3QgY29tbWl0ICpjdXJyZW50X2hlYWQpCnsKCXN0cnVjdCB0cmVlICp0cmVlOwoJc3RydWN0IHVucGFja190cmVlc19vcHRpb25zIG9wdHM7CglzdHJ1Y3QgdHJlZV9kZXNjIHQ7CgoJaWYgKCFjdXJyZW50X2hlYWQpIHsKCQlkaXNjYXJkX2NhY2hlKCk7CgkJcmV0dXJuOwoJfQoKCW1lbXNldCgmb3B0cywgMCwgc2l6ZW9mKG9wdHMpKTsKCW9wdHMuaGVhZF9pZHggPSAxOwoJb3B0cy5pbmRleF9vbmx5ID0gMTsKCW9wdHMubWVyZ2UgPSAxOwoJb3B0cy5zcmNfaW5kZXggPSAmdGhlX2luZGV4OwoJb3B0cy5kc3RfaW5kZXggPSAmdGhlX2luZGV4OwoKCW9wdHMuZm4gPSBvbmV3YXlfbWVyZ2U7Cgl0cmVlID0gcGFyc2VfdHJlZV9pbmRpcmVjdChjdXJyZW50X2hlYWQtPm9iamVjdC5zaGExKTsKCWlmICghdHJlZSkKCQlkaWUoXygiZmFpbGVkIHRvIHVucGFjayBIRUFEIHRyZWUgb2JqZWN0IikpOwoJcGFyc2VfdHJlZSh0cmVlKTsKCWluaXRfdHJlZV9kZXNjKCZ0LCB0cmVlLT5idWZmZXIsIHRyZWUtPnNpemUpOwoJaWYgKHVucGFja190cmVlcygxLCAmdCwgJm9wdHMpKQoJCWV4aXQoMTI4KTsgLyogV2UndmUgYWxyZWFkeSByZXBvcnRlZCB0aGUgZXJyb3IsIGZpbmlzaCBkeWluZyAqLwp9CgpzdGF0aWMgdm9pZCByZWZyZXNoX2NhY2hlX29yX2RpZShpbnQgcmVmcmVzaF9mbGFncykKewoJLyoKCSAqIHJlZnJlc2hfZmxhZ3MgY29udGFpbnMgUkVGUkVTSF9RVUlFVCwgc28gdGhlIG9ubHkgZXJyb3JzCgkgKiBhcmUgZm9yIHVubWVyZ2VkIGVudHJpZXMuCgkgKi8KCWlmIChyZWZyZXNoX2NhY2hlKHJlZnJlc2hfZmxhZ3MgfCBSRUZSRVNIX0lOX1BPUkNFTEFJTikpCgkJZGllX3Jlc29sdmVfY29uZmxpY3QoImNvbW1pdCIpOwp9CgpzdGF0aWMgY2hhciAqcHJlcGFyZV9pbmRleChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJICAgY29uc3Qgc3RydWN0IGNvbW1pdCAqY3VycmVudF9oZWFkLCBpbnQgaXNfc3RhdHVzKQp7CglpbnQgZmQ7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgcGFydGlhbDsKCWNvbnN0IGNoYXIgKipwYXRoc3BlYyA9IE5VTEw7CgljaGFyICpvbGRfaW5kZXhfZW52ID0gTlVMTDsKCWludCByZWZyZXNoX2ZsYWdzID0gUkVGUkVTSF9RVUlFVDsKCglpZiAoaXNfc3RhdHVzKQoJCXJlZnJlc2hfZmxhZ3MgfD0gUkVGUkVTSF9VTk1FUkdFRDsKCglpZiAoKmFyZ3YpCgkJcGF0aHNwZWMgPSBnZXRfcGF0aHNwZWMocHJlZml4LCBhcmd2KTsKCglpZiAocmVhZF9jYWNoZV9wcmVsb2FkKHBhdGhzcGVjKSA8IDApCgkJZGllKF8oImluZGV4IGZpbGUgY29ycnVwdCIpKTsKCglpZiAoaW50ZXJhY3RpdmUpIHsKCQlmZCA9IGhvbGRfbG9ja2VkX2luZGV4KCZpbmRleF9sb2NrLCAxKTsKCgkJcmVmcmVzaF9jYWNoZV9vcl9kaWUocmVmcmVzaF9mbGFncyk7CgoJCWlmICh3cml0ZV9jYWNoZShmZCwgYWN0aXZlX2NhY2hlLCBhY3RpdmVfbnIpIHx8CgkJICAgIGNsb3NlX2xvY2tfZmlsZSgmaW5kZXhfbG9jaykpCgkJCWRpZShfKCJ1bmFibGUgdG8gY3JlYXRlIHRlbXBvcmFyeSBpbmRleCIpKTsKCgkJb2xkX2luZGV4X2VudiA9IGdldGVudihJTkRFWF9FTlZJUk9OTUVOVCk7CgkJc2V0ZW52KElOREVYX0VOVklST05NRU5ULCBpbmRleF9sb2NrLmZpbGVuYW1lLCAxKTsKCgkJaWYgKGludGVyYWN0aXZlX2FkZChhcmdjLCBhcmd2LCBwcmVmaXgsIHBhdGNoX2ludGVyYWN0aXZlKSAhPSAwKQoJCQlkaWUoXygiaW50ZXJhY3RpdmUgYWRkIGZhaWxlZCIpKTsKCgkJaWYgKG9sZF9pbmRleF9lbnYgJiYgKm9sZF9pbmRleF9lbnYpCgkJCXNldGVudihJTkRFWF9FTlZJUk9OTUVOVCwgb2xkX2luZGV4X2VudiwgMSk7CgkJZWxzZQoJCQl1bnNldGVudihJTkRFWF9FTlZJUk9OTUVOVCk7CgoJCWRpc2NhcmRfY2FjaGUoKTsKCQlyZWFkX2NhY2hlX2Zyb20oaW5kZXhfbG9jay5maWxlbmFtZSk7CgoJCWNvbW1pdF9zdHlsZSA9IENPTU1JVF9OT1JNQUw7CgkJcmV0dXJuIGluZGV4X2xvY2suZmlsZW5hbWU7Cgl9CgoJLyoKCSAqIE5vbiBwYXJ0aWFsLCBub24gYXMtaXMgY29tbWl0LgoJICoKCSAqICgxKSBnZXQgdGhlIHJlYWwgaW5kZXg7CgkgKiAoMikgdXBkYXRlIHRoZV9pbmRleCBhcyBuZWNlc3Nhcnk7CgkgKiAoMykgd3JpdGUgdGhlX2luZGV4IG91dCB0byB0aGUgcmVhbCBpbmRleCAoc3RpbGwgbG9ja2VkKTsKCSAqICg0KSByZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGxvY2tlZCBpbmRleCBmaWxlLgoJICoKCSAqIFRoZSBjYWxsZXIgc2hvdWxkIHJ1biBob29rcyBvbiB0aGUgbG9ja2VkIHJlYWwgaW5kZXgsIGFuZAoJICogKEEpIGlmIGFsbCBnb2VzIHdlbGwsIGNvbW1pdCB0aGUgcmVhbCBpbmRleDsKCSAqIChCKSBvbiBmYWlsdXJlLCByb2xsYmFjayB0aGUgcmVhbCBpbmRleC4KCSAqLwoJaWYgKGFsbCB8fCAoYWxzbyAmJiBwYXRoc3BlYyAmJiAqcGF0aHNwZWMpKSB7CgkJZmQgPSBob2xkX2xvY2tlZF9pbmRleCgmaW5kZXhfbG9jaywgMSk7CgkJYWRkX2ZpbGVzX3RvX2NhY2hlKGFsc28gPyBwcmVmaXggOiBOVUxMLCBwYXRoc3BlYywgMCk7CgkJcmVmcmVzaF9jYWNoZV9vcl9kaWUocmVmcmVzaF9mbGFncyk7CgkJdXBkYXRlX21haW5fY2FjaGVfdHJlZShXUklURV9UUkVFX1NJTEVOVCk7CgkJaWYgKHdyaXRlX2NhY2hlKGZkLCBhY3RpdmVfY2FjaGUsIGFjdGl2ZV9ucikgfHwKCQkgICAgY2xvc2VfbG9ja19maWxlKCZpbmRleF9sb2NrKSkKCQkJZGllKF8oInVuYWJsZSB0byB3cml0ZSBuZXdfaW5kZXggZmlsZSIpKTsKCQljb21taXRfc3R5bGUgPSBDT01NSVRfTk9STUFMOwoJCXJldHVybiBpbmRleF9sb2NrLmZpbGVuYW1lOwoJfQoKCS8qCgkgKiBBcy1pcyBjb21taXQuCgkgKgoJICogKDEpIHJldHVybiB0aGUgbmFtZSBvZiB0aGUgcmVhbCBpbmRleCBmaWxlLgoJICoKCSAqIFRoZSBjYWxsZXIgc2hvdWxkIHJ1biBob29rcyBvbiB0aGUgcmVhbCBpbmRleCwKCSAqIGFuZCBjcmVhdGUgY29tbWl0IGZyb20gdGhlX2luZGV4LgoJICogV2Ugc3RpbGwgbmVlZCB0byByZWZyZXNoIHRoZSBpbmRleCBoZXJlLgoJICovCglpZiAoIW9ubHkgJiYgKCFwYXRoc3BlYyB8fCAhKnBhdGhzcGVjKSkgewoJCWZkID0gaG9sZF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2ssIDEpOwoJCXJlZnJlc2hfY2FjaGVfb3JfZGllKHJlZnJlc2hfZmxhZ3MpOwoJCWlmIChhY3RpdmVfY2FjaGVfY2hhbmdlZCkgewoJCQl1cGRhdGVfbWFpbl9jYWNoZV90cmVlKFdSSVRFX1RSRUVfU0lMRU5UKTsKCQkJaWYgKHdyaXRlX2NhY2hlKGZkLCBhY3RpdmVfY2FjaGUsIGFjdGl2ZV9ucikgfHwKCQkJICAgIGNvbW1pdF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2spKQoJCQkJZGllKF8oInVuYWJsZSB0byB3cml0ZSBuZXdfaW5kZXggZmlsZSIpKTsKCQl9IGVsc2UgewoJCQlyb2xsYmFja19sb2NrX2ZpbGUoJmluZGV4X2xvY2spOwoJCX0KCQljb21taXRfc3R5bGUgPSBDT01NSVRfQVNfSVM7CgkJcmV0dXJuIGdldF9pbmRleF9maWxlKCk7Cgl9CgoJLyoKCSAqIEEgcGFydGlhbCBjb21taXQuCgkgKgoJICogKDApIGZpbmQgdGhlIHNldCBvZiBhZmZlY3RlZCBwYXRoczsKCSAqICgxKSBnZXQgbG9jayBvbiB0aGUgcmVhbCBpbmRleCBmaWxlOwoJICogKDIpIHVwZGF0ZSB0aGVfaW5kZXggd2l0aCB0aGUgZ2l2ZW4gcGF0aHM7CgkgKiAoMykgd3JpdGUgdGhlX2luZGV4IG91dCB0byB0aGUgcmVhbCBpbmRleCAoc3RpbGwgbG9ja2VkKTsKCSAqICg0KSBnZXQgbG9jayBvbiB0aGUgZmFsc2UgaW5kZXggZmlsZTsKCSAqICg1KSByZXNldCB0aGVfaW5kZXggZnJvbSBIRUFEOwoJICogKDYpIHVwZGF0ZSB0aGVfaW5kZXggdGhlIHNhbWUgd2F5IGFzICgyKTsKCSAqICg3KSB3cml0ZSB0aGVfaW5kZXggb3V0IHRvIHRoZSBmYWxzZSBpbmRleCBmaWxlOwoJICogKDgpIHJldHVybiB0aGUgbmFtZSBvZiB0aGUgZmFsc2UgaW5kZXggZmlsZSAoc3RpbGwgbG9ja2VkKTsKCSAqCgkgKiBUaGUgY2FsbGVyIHNob3VsZCBydW4gaG9va3Mgb24gdGhlIGxvY2tlZCBmYWxzZSBpbmRleCwgYW5kCgkgKiBjcmVhdGUgY29tbWl0IGZyb20gaXQuICBUaGVuCgkgKiAoQSkgaWYgYWxsIGdvZXMgd2VsbCwgY29tbWl0IHRoZSByZWFsIGluZGV4OwoJICogKEIpIG9uIGZhaWx1cmUsIHJvbGxiYWNrIHRoZSByZWFsIGluZGV4OwoJICogSW4gZWl0aGVyIGNhc2UsIHJvbGxiYWNrIHRoZSBmYWxzZSBpbmRleC4KCSAqLwoJY29tbWl0X3N0eWxlID0gQ09NTUlUX1BBUlRJQUw7CgoJaWYgKHdoZW5jZSAhPSBGUk9NX0NPTU1JVCkgewoJCWlmICh3aGVuY2UgPT0gRlJPTV9NRVJHRSkKCQkJZGllKF8oImNhbm5vdCBkbyBhIHBhcnRpYWwgY29tbWl0IGR1cmluZyBhIG1lcmdlLiIpKTsKCQllbHNlIGlmICh3aGVuY2UgPT0gRlJPTV9DSEVSUllfUElDSykKCQkJZGllKF8oImNhbm5vdCBkbyBhIHBhcnRpYWwgY29tbWl0IGR1cmluZyBhIGNoZXJyeS1waWNrLiIpKTsKCX0KCgltZW1zZXQoJnBhcnRpYWwsIDAsIHNpemVvZihwYXJ0aWFsKSk7CglwYXJ0aWFsLnN0cmR1cF9zdHJpbmdzID0gMTsKCWlmIChsaXN0X3BhdGhzKCZwYXJ0aWFsLCAhY3VycmVudF9oZWFkID8gTlVMTCA6ICJIRUFEIiwgcHJlZml4LCBwYXRoc3BlYykpCgkJZXhpdCgxKTsKCglkaXNjYXJkX2NhY2hlKCk7CglpZiAocmVhZF9jYWNoZSgpIDwgMCkKCQlkaWUoXygiY2Fubm90IHJlYWQgdGhlIGluZGV4IikpOwoKCWZkID0gaG9sZF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2ssIDEpOwoJYWRkX3JlbW92ZV9maWxlcygmcGFydGlhbCk7CglyZWZyZXNoX2NhY2hlKFJFRlJFU0hfUVVJRVQpOwoJaWYgKHdyaXRlX2NhY2hlKGZkLCBhY3RpdmVfY2FjaGUsIGFjdGl2ZV9ucikgfHwKCSAgICBjbG9zZV9sb2NrX2ZpbGUoJmluZGV4X2xvY2spKQoJCWRpZShfKCJ1bmFibGUgdG8gd3JpdGUgbmV3X2luZGV4IGZpbGUiKSk7CgoJZmQgPSBob2xkX2xvY2tfZmlsZV9mb3JfdXBkYXRlKCZmYWxzZV9sb2NrLAoJCQkJICAgICAgIGdpdF9wYXRoKCJuZXh0LWluZGV4LSUiUFJJdU1BWCwKCQkJCQkJKHVpbnRtYXhfdCkgZ2V0cGlkKCkpLAoJCQkJICAgICAgIExPQ0tfRElFX09OX0VSUk9SKTsKCgljcmVhdGVfYmFzZV9pbmRleChjdXJyZW50X2hlYWQpOwoJYWRkX3JlbW92ZV9maWxlcygmcGFydGlhbCk7CglyZWZyZXNoX2NhY2hlKFJFRlJFU0hfUVVJRVQpOwoKCWlmICh3cml0ZV9jYWNoZShmZCwgYWN0aXZlX2NhY2hlLCBhY3RpdmVfbnIpIHx8CgkgICAgY2xvc2VfbG9ja19maWxlKCZmYWxzZV9sb2NrKSkKCQlkaWUoXygidW5hYmxlIHRvIHdyaXRlIHRlbXBvcmFyeSBpbmRleCBmaWxlIikpOwoKCWRpc2NhcmRfY2FjaGUoKTsKCXJlYWRfY2FjaGVfZnJvbShmYWxzZV9sb2NrLmZpbGVuYW1lKTsKCglyZXR1cm4gZmFsc2VfbG9jay5maWxlbmFtZTsKfQoKc3RhdGljIGludCBydW5fc3RhdHVzKEZJTEUgKmZwLCBjb25zdCBjaGFyICppbmRleF9maWxlLCBjb25zdCBjaGFyICpwcmVmaXgsIGludCBub3dhcm4sCgkJICAgICAgc3RydWN0IHd0X3N0YXR1cyAqcykKewoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCglpZiAocy0+cmVsYXRpdmVfcGF0aHMpCgkJcy0+cHJlZml4ID0gcHJlZml4OwoKCWlmIChhbWVuZCkgewoJCXMtPmFtZW5kID0gMTsKCQlzLT5yZWZlcmVuY2UgPSAiSEVBRF4xIjsKCX0KCXMtPnZlcmJvc2UgPSB2ZXJib3NlOwoJcy0+aW5kZXhfZmlsZSA9IGluZGV4X2ZpbGU7CglzLT5mcCA9IGZwOwoJcy0+bm93YXJuID0gbm93YXJuOwoJcy0+aXNfaW5pdGlhbCA9IGdldF9zaGExKHMtPnJlZmVyZW5jZSwgc2hhMSkgPyAxIDogMDsKCgl3dF9zdGF0dXNfY29sbGVjdChzKTsKCglzd2l0Y2ggKHN0YXR1c19mb3JtYXQpIHsKCWNhc2UgU1RBVFVTX0ZPUk1BVF9TSE9SVDoKCQl3dF9zaG9ydHN0YXR1c19wcmludChzKTsKCQlicmVhazsKCWNhc2UgU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU46CgkJd3RfcG9yY2VsYWluX3ByaW50KHMpOwoJCWJyZWFrOwoJY2FzZSBTVEFUVVNfRk9STUFUX1VOU1BFQ0lGSUVEOgoJCWRpZSgiQlVHOiBmaW5hbGl6ZV9kZWZlcnJlZF9jb25maWcoKSBzaG91bGQgaGF2ZSBiZWVuIGNhbGxlZCIpOwoJCWJyZWFrOwoJY2FzZSBTVEFUVVNfRk9STUFUX05PTkU6CgljYXNlIFNUQVRVU19GT1JNQVRfTE9ORzoKCQl3dF9zdGF0dXNfcHJpbnQocyk7CgkJYnJlYWs7Cgl9CgoJcmV0dXJuIHMtPmNvbW1pdGFibGU7Cn0KCnN0YXRpYyBpbnQgaXNfYV9tZXJnZShjb25zdCBzdHJ1Y3QgY29tbWl0ICpjdXJyZW50X2hlYWQpCnsKCXJldHVybiAhIShjdXJyZW50X2hlYWQtPnBhcmVudHMgJiYgY3VycmVudF9oZWFkLT5wYXJlbnRzLT5uZXh0KTsKfQoKc3RhdGljIHZvaWQgZXhwb3J0X29uZShjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnMsIGNvbnN0IGNoYXIgKmUsIGludCBoYWNrKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaWYgKGhhY2spCgkJc3RyYnVmX2FkZGNoKCZidWYsIGhhY2spOwoJc3RyYnVmX2FkZGYoJmJ1ZiwgIiUuKnMiLCAoaW50KShlIC0gcyksIHMpOwoJc2V0ZW52KHZhciwgYnVmLmJ1ZiwgMSk7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKfQoKc3RhdGljIGludCBzYW5lX2lkZW50X3NwbGl0KHN0cnVjdCBpZGVudF9zcGxpdCAqcGVyc29uKQp7CglpZiAoIXBlcnNvbi0+bmFtZV9iZWdpbiB8fCAhcGVyc29uLT5uYW1lX2VuZCB8fAoJICAgIHBlcnNvbi0+bmFtZV9iZWdpbiA9PSBwZXJzb24tPm5hbWVfZW5kKQoJCXJldHVybiAwOyAvKiBubyBodW1hbiByZWFkYWJsZSBuYW1lICovCglpZiAoIXBlcnNvbi0+bWFpbF9iZWdpbiB8fCAhcGVyc29uLT5tYWlsX2VuZCB8fAoJICAgIHBlcnNvbi0+bWFpbF9iZWdpbiA9PSBwZXJzb24tPm1haWxfZW5kKQoJCXJldHVybiAwOyAvKiBubyB1c2FibGUgbWFpbCAqLwoJaWYgKCFwZXJzb24tPmRhdGVfYmVnaW4gfHwgIXBlcnNvbi0+ZGF0ZV9lbmQgfHwKCSAgICAhcGVyc29uLT50el9iZWdpbiB8fCAhcGVyc29uLT50el9lbmQpCgkJcmV0dXJuIDA7CglyZXR1cm4gMTsKfQoKc3RhdGljIHZvaWQgZGV0ZXJtaW5lX2F1dGhvcl9pbmZvKHN0cnVjdCBzdHJidWYgKmF1dGhvcl9pZGVudCkKewoJY2hhciAqbmFtZSwgKmVtYWlsLCAqZGF0ZTsKCXN0cnVjdCBpZGVudF9zcGxpdCBhdXRob3I7CgoJbmFtZSA9IGdldGVudigiR0lUX0FVVEhPUl9OQU1FIik7CgllbWFpbCA9IGdldGVudigiR0lUX0FVVEhPUl9FTUFJTCIpOwoJZGF0ZSA9IGdldGVudigiR0lUX0FVVEhPUl9EQVRFIik7CgoJaWYgKGF1dGhvcl9tZXNzYWdlKSB7CgkJY29uc3QgY2hhciAqYSwgKmxiLCAqcmIsICplb2w7CgkJc2l6ZV90IGxlbjsKCgkJYSA9IHN0cnN0cihhdXRob3JfbWVzc2FnZV9idWZmZXIsICJcbmF1dGhvciAiKTsKCQlpZiAoIWEpCgkJCWRpZShfKCJpbnZhbGlkIGNvbW1pdDogJXMiKSwgYXV0aG9yX21lc3NhZ2UpOwoKCQlsYiA9IHN0cmNocm51bChhICsgc3RybGVuKCJcbmF1dGhvciAiKSwgJzwnKTsKCQlyYiA9IHN0cmNocm51bChsYiwgJz4nKTsKCQllb2wgPSBzdHJjaHJudWwocmIsICdcbicpOwoJCWlmICghKmxiIHx8ICEqcmIgfHwgISplb2wpCgkJCWRpZShfKCJpbnZhbGlkIGNvbW1pdDogJXMiKSwgYXV0aG9yX21lc3NhZ2UpOwoKCQlpZiAobGIgPT0gYSArIHN0cmxlbigiXG5hdXRob3IgIikpCgkJCS8qIFxuYXV0aG9yIDxmb29AZXhhbXBsZS5jb20+ICovCgkJCW5hbWUgPSB4Y2FsbG9jKDEsIDEpOwoJCWVsc2UKCQkJbmFtZSA9IHhtZW1kdXB6KGEgKyBzdHJsZW4oIlxuYXV0aG9yICIpLAoJCQkJCShsYiAtIHN0cmxlbigiICIpIC0KCQkJCQkgKGEgKyBzdHJsZW4oIlxuYXV0aG9yICIpKSkpOwoJCWVtYWlsID0geG1lbWR1cHoobGIgKyBzdHJsZW4oIjwiKSwgcmIgLSAobGIgKyBzdHJsZW4oIjwiKSkpOwoJCWxlbiA9IGVvbCAtIChyYiArIHN0cmxlbigiPiAiKSk7CgkJZGF0ZSA9IHhtYWxsb2MobGVuICsgMik7CgkJKmRhdGUgPSAnQCc7CgkJbWVtY3B5KGRhdGUgKyAxLCByYiArIHN0cmxlbigiPiAiKSwgbGVuKTsKCQlkYXRlW2xlbiArIDFdID0gJ1wwJzsKCX0KCglpZiAoZm9yY2VfYXV0aG9yKSB7CgkJY29uc3QgY2hhciAqbGIgPSBzdHJzdHIoZm9yY2VfYXV0aG9yLCAiIDwiKTsKCQljb25zdCBjaGFyICpyYiA9IHN0cmNocihmb3JjZV9hdXRob3IsICc+Jyk7CgoJCWlmICghbGIgfHwgIXJiKQoJCQlkaWUoXygibWFsZm9ybWVkIC0tYXV0aG9yIHBhcmFtZXRlciIpKTsKCQluYW1lID0geHN0cm5kdXAoZm9yY2VfYXV0aG9yLCBsYiAtIGZvcmNlX2F1dGhvcik7CgkJZW1haWwgPSB4c3RybmR1cChsYiArIDIsIHJiIC0gKGxiICsgMikpOwoJfQoKCWlmIChmb3JjZV9kYXRlKQoJCWRhdGUgPSBmb3JjZV9kYXRlOwoJc3RyYnVmX2FkZHN0cihhdXRob3JfaWRlbnQsIGZtdF9pZGVudChuYW1lLCBlbWFpbCwgZGF0ZSwgSURFTlRfU1RSSUNUKSk7CglpZiAoIXNwbGl0X2lkZW50X2xpbmUoJmF1dGhvciwgYXV0aG9yX2lkZW50LT5idWYsIGF1dGhvcl9pZGVudC0+bGVuKSAmJgoJICAgIHNhbmVfaWRlbnRfc3BsaXQoJmF1dGhvcikpIHsKCQlleHBvcnRfb25lKCJHSVRfQVVUSE9SX05BTUUiLCBhdXRob3IubmFtZV9iZWdpbiwgYXV0aG9yLm5hbWVfZW5kLCAwKTsKCQlleHBvcnRfb25lKCJHSVRfQVVUSE9SX0VNQUlMIiwgYXV0aG9yLm1haWxfYmVnaW4sIGF1dGhvci5tYWlsX2VuZCwgMCk7CgkJZXhwb3J0X29uZSgiR0lUX0FVVEhPUl9EQVRFIiwgYXV0aG9yLmRhdGVfYmVnaW4sIGF1dGhvci50el9lbmQsICdAJyk7Cgl9Cn0KCnN0YXRpYyBjaGFyICpjdXRfaWRlbnRfdGltZXN0YW1wX3BhcnQoY2hhciAqc3RyaW5nKQp7CgljaGFyICprZXQgPSBzdHJyY2hyKHN0cmluZywgJz4nKTsKCWlmICgha2V0IHx8IGtldFsxXSAhPSAnICcpCgkJZGllKF8oIk1hbGZvcm1lZCBpZGVudCBzdHJpbmc6ICclcyciKSwgc3RyaW5nKTsKCSorK2tldCA9ICdcMCc7CglyZXR1cm4ga2V0Owp9CgpzdGF0aWMgaW50IHByZXBhcmVfdG9fY29tbWl0KGNvbnN0IGNoYXIgKmluZGV4X2ZpbGUsIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJICAgICBzdHJ1Y3QgY29tbWl0ICpjdXJyZW50X2hlYWQsCgkJCSAgICAgc3RydWN0IHd0X3N0YXR1cyAqcywKCQkJICAgICBzdHJ1Y3Qgc3RyYnVmICphdXRob3JfaWRlbnQpCnsKCXN0cnVjdCBzdGF0IHN0YXRidWY7CglzdHJ1Y3Qgc3RyYnVmIGNvbW1pdHRlcl9pZGVudCA9IFNUUkJVRl9JTklUOwoJaW50IGNvbW1pdGFibGUsIHNhdmVkX2NvbG9yX3NldHRpbmc7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CgljaGFyICpidWZmZXI7Cgljb25zdCBjaGFyICpob29rX2FyZzEgPSBOVUxMOwoJY29uc3QgY2hhciAqaG9va19hcmcyID0gTlVMTDsKCWludCBpZGVudF9zaG93biA9IDA7CglpbnQgY2xlYW5fbWVzc2FnZV9jb250ZW50cyA9IChjbGVhbnVwX21vZGUgIT0gQ0xFQU5VUF9OT05FKTsKCgkvKiBUaGlzIGNoZWNrcyBhbmQgYmFyZnMgaWYgYXV0aG9yIGlzIGJhZGx5IHNwZWNpZmllZCAqLwoJZGV0ZXJtaW5lX2F1dGhvcl9pbmZvKGF1dGhvcl9pZGVudCk7CgoJaWYgKCFub192ZXJpZnkgJiYgcnVuX2hvb2soaW5kZXhfZmlsZSwgInByZS1jb21taXQiLCBOVUxMKSkKCQlyZXR1cm4gMDsKCglpZiAoc3F1YXNoX21lc3NhZ2UpIHsKCQkvKgoJCSAqIEluc2VydCB0aGUgcHJvcGVyIHN1YmplY3QgbGluZSBiZWZvcmUgb3RoZXIgY29tbWl0CgkJICogbWVzc2FnZSBvcHRpb25zIGFkZCB0aGVpciBjb250ZW50LgoJCSAqLwoJCWlmICh1c2VfbWVzc2FnZSAmJiAhc3RyY21wKHVzZV9tZXNzYWdlLCBzcXVhc2hfbWVzc2FnZSkpCgkJCXN0cmJ1Zl9hZGRzdHIoJnNiLCAic3F1YXNoISAiKTsKCQllbHNlIHsKCQkJc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0IGN0eCA9IHswfTsKCQkJc3RydWN0IGNvbW1pdCAqYzsKCQkJYyA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2J5X25hbWUoc3F1YXNoX21lc3NhZ2UpOwoJCQlpZiAoIWMpCgkJCQlkaWUoXygiY291bGQgbm90IGxvb2t1cCBjb21taXQgJXMiKSwgc3F1YXNoX21lc3NhZ2UpOwoJCQljdHgub3V0cHV0X2VuY29kaW5nID0gZ2V0X2NvbW1pdF9vdXRwdXRfZW5jb2RpbmcoKTsKCQkJZm9ybWF0X2NvbW1pdF9tZXNzYWdlKGMsICJzcXVhc2ghICVzXG5cbiIsICZzYiwKCQkJCQkgICAgICAmY3R4KTsKCQl9Cgl9CgoJaWYgKG1lc3NhZ2UubGVuKSB7CgkJc3RyYnVmX2FkZGJ1Zigmc2IsICZtZXNzYWdlKTsKCQlob29rX2FyZzEgPSAibWVzc2FnZSI7Cgl9IGVsc2UgaWYgKGxvZ2ZpbGUgJiYgIXN0cmNtcChsb2dmaWxlLCAiLSIpKSB7CgkJaWYgKGlzYXR0eSgwKSkKCQkJZnByaW50ZihzdGRlcnIsIF8oIihyZWFkaW5nIGxvZyBtZXNzYWdlIGZyb20gc3RhbmRhcmQgaW5wdXQpXG4iKSk7CgkJaWYgKHN0cmJ1Zl9yZWFkKCZzYiwgMCwgMCkgPCAwKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlYWQgbG9nIGZyb20gc3RhbmRhcmQgaW5wdXQiKSk7CgkJaG9va19hcmcxID0gIm1lc3NhZ2UiOwoJfSBlbHNlIGlmIChsb2dmaWxlKSB7CgkJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJnNiLCBsb2dmaWxlLCAwKSA8IDApCgkJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgcmVhZCBsb2cgZmlsZSAnJXMnIiksCgkJCQkgIGxvZ2ZpbGUpOwoJCWhvb2tfYXJnMSA9ICJtZXNzYWdlIjsKCX0gZWxzZSBpZiAodXNlX21lc3NhZ2UpIHsKCQlidWZmZXIgPSBzdHJzdHIodXNlX21lc3NhZ2VfYnVmZmVyLCAiXG5cbiIpOwoJCWlmICghdXNlX2VkaXRvciAmJiAoIWJ1ZmZlciB8fCBidWZmZXJbMl0gPT0gJ1wwJykpCgkJCWRpZShfKCJjb21taXQgaGFzIGVtcHR5IG1lc3NhZ2UiKSk7CgkJc3RyYnVmX2FkZCgmc2IsIGJ1ZmZlciArIDIsIHN0cmxlbihidWZmZXIgKyAyKSk7CgkJaG9va19hcmcxID0gImNvbW1pdCI7CgkJaG9va19hcmcyID0gdXNlX21lc3NhZ2U7Cgl9IGVsc2UgaWYgKGZpeHVwX21lc3NhZ2UpIHsKCQlzdHJ1Y3QgcHJldHR5X3ByaW50X2NvbnRleHQgY3R4ID0gezB9OwoJCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCQljb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9ieV9uYW1lKGZpeHVwX21lc3NhZ2UpOwoJCWlmICghY29tbWl0KQoJCQlkaWUoXygiY291bGQgbm90IGxvb2t1cCBjb21taXQgJXMiKSwgZml4dXBfbWVzc2FnZSk7CgkJY3R4Lm91dHB1dF9lbmNvZGluZyA9IGdldF9jb21taXRfb3V0cHV0X2VuY29kaW5nKCk7CgkJZm9ybWF0X2NvbW1pdF9tZXNzYWdlKGNvbW1pdCwgImZpeHVwISAlc1xuXG4iLAoJCQkJICAgICAgJnNiLCAmY3R4KTsKCQlob29rX2FyZzEgPSAibWVzc2FnZSI7Cgl9IGVsc2UgaWYgKCFzdGF0KGdpdF9wYXRoKCJNRVJHRV9NU0ciKSwgJnN0YXRidWYpKSB7CgkJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJnNiLCBnaXRfcGF0aCgiTUVSR0VfTVNHIiksIDApIDwgMCkKCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkIE1FUkdFX01TRyIpKTsKCQlob29rX2FyZzEgPSAibWVyZ2UiOwoJfSBlbHNlIGlmICghc3RhdChnaXRfcGF0aCgiU1FVQVNIX01TRyIpLCAmc3RhdGJ1ZikpIHsKCQlpZiAoc3RyYnVmX3JlYWRfZmlsZSgmc2IsIGdpdF9wYXRoKCJTUVVBU0hfTVNHIiksIDApIDwgMCkKCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkIFNRVUFTSF9NU0ciKSk7CgkJaG9va19hcmcxID0gInNxdWFzaCI7Cgl9IGVsc2UgaWYgKHRlbXBsYXRlX2ZpbGUpIHsKCQlpZiAoc3RyYnVmX3JlYWRfZmlsZSgmc2IsIHRlbXBsYXRlX2ZpbGUsIDApIDwgMCkKCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkICclcyciKSwgdGVtcGxhdGVfZmlsZSk7CgkJaG9va19hcmcxID0gInRlbXBsYXRlIjsKCQljbGVhbl9tZXNzYWdlX2NvbnRlbnRzID0gMDsKCX0KCgkvKgoJICogVGhlIHJlbWFpbmluZyBjYXNlcyBkb24ndCBtb2RpZnkgdGhlIHRlbXBsYXRlIG1lc3NhZ2UsIGJ1dAoJICoganVzdCBzZXQgdGhlIGFyZ3VtZW50KHMpIHRvIHRoZSBwcmVwYXJlLWNvbW1pdC1tc2cgaG9vay4KCSAqLwoJZWxzZSBpZiAod2hlbmNlID09IEZST01fTUVSR0UpCgkJaG9va19hcmcxID0gIm1lcmdlIjsKCWVsc2UgaWYgKHdoZW5jZSA9PSBGUk9NX0NIRVJSWV9QSUNLKSB7CgkJaG9va19hcmcxID0gImNvbW1pdCI7CgkJaG9va19hcmcyID0gIkNIRVJSWV9QSUNLX0hFQUQiOwoJfQoKCWlmIChzcXVhc2hfbWVzc2FnZSkgewoJCS8qCgkJICogSWYgc3F1YXNoX2NvbW1pdCB3YXMgdXNlZCBmb3IgdGhlIGNvbW1pdCBzdWJqZWN0LAoJCSAqIHRoZW4gd2UncmUgcG9zc2libHkgaGlqYWNraW5nIG90aGVyIGNvbW1pdCBsb2cgb3B0aW9ucy4KCQkgKiBSZXNldCB0aGUgaG9vayBhcmdzIHRvIHRlbGwgdGhlIHJlYWwgc3RvcnkuCgkJICovCgkJaG9va19hcmcxID0gIm1lc3NhZ2UiOwoJCWhvb2tfYXJnMiA9ICIiOwoJfQoKCXMtPmZwID0gZm9wZW4oZ2l0X3BhdGgoY29tbWl0X2VkaXRtc2cpLCAidyIpOwoJaWYgKHMtPmZwID09IE5VTEwpCgkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCBvcGVuICclcyciKSwgZ2l0X3BhdGgoY29tbWl0X2VkaXRtc2cpKTsKCglpZiAoY2xlYW5fbWVzc2FnZV9jb250ZW50cykKCQlzdHJpcHNwYWNlKCZzYiwgMCk7CgoJaWYgKHNpZ25vZmYpIHsKCQkvKgoJCSAqIFNlZSBpZiB3ZSBoYXZlIGEgQ29uZmxpY3RzOiBibG9jayBhdCB0aGUgZW5kLiBJZiB5ZXMsIGNvdW50CgkJICogaXRzIHNpemUsIHNvIHdlIGNhbiBpZ25vcmUgaXQuCgkJICovCgkJaW50IGlnbm9yZV9mb290ZXIgPSAwOwoJCWludCBpLCBlb2wsIHByZXZpb3VzID0gMDsKCQljb25zdCBjaGFyICpubDsKCgkJZm9yIChpID0gMDsgaSA8IHNiLmxlbjsgaSsrKSB7CgkJCW5sID0gbWVtY2hyKHNiLmJ1ZiArIGksICdcbicsIHNiLmxlbiAtIGkpOwoJCQlpZiAobmwpCgkJCQllb2wgPSBubCAtIHNiLmJ1ZjsKCQkJZWxzZQoJCQkJZW9sID0gc2IubGVuOwoJCQlpZiAoIXByZWZpeGNtcChzYi5idWYgKyBwcmV2aW91cywgIlxuQ29uZmxpY3RzOlxuIikpIHsKCQkJCWlnbm9yZV9mb290ZXIgPSBzYi5sZW4gLSBwcmV2aW91czsKCQkJCWJyZWFrOwoJCQl9CgkJCXdoaWxlIChpIDwgZW9sKQoJCQkJaSsrOwoJCQlwcmV2aW91cyA9IGVvbDsKCQl9CgoJCWFwcGVuZF9zaWdub2ZmKCZzYiwgaWdub3JlX2Zvb3RlciwgMCk7Cgl9CgoJaWYgKGZ3cml0ZShzYi5idWYsIDEsIHNiLmxlbiwgcy0+ZnApIDwgc2IubGVuKQoJCWRpZV9lcnJubyhfKCJjb3VsZCBub3Qgd3JpdGUgY29tbWl0IHRlbXBsYXRlIikpOwoKCXN0cmJ1Zl9yZWxlYXNlKCZzYik7CgoJLyogVGhpcyBjaGVja3MgaWYgY29tbWl0dGVyIGlkZW50IGlzIGV4cGxpY2l0bHkgZ2l2ZW4gKi8KCXN0cmJ1Zl9hZGRzdHIoJmNvbW1pdHRlcl9pZGVudCwgZ2l0X2NvbW1pdHRlcl9pbmZvKElERU5UX1NUUklDVCkpOwoJaWYgKHVzZV9lZGl0b3IgJiYgaW5jbHVkZV9zdGF0dXMpIHsKCQljaGFyICphaV90bXAsICpjaV90bXA7CgkJaWYgKHdoZW5jZSAhPSBGUk9NX0NPTU1JVCkKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkgICAgd2hlbmNlID09IEZST01fTUVSR0UKCQkJCT8gXygiXG4iCgkJCQkJIkl0IGxvb2tzIGxpa2UgeW91IG1heSBiZSBjb21taXR0aW5nIGEgbWVyZ2UuXG4iCgkJCQkJIklmIHRoaXMgaXMgbm90IGNvcnJlY3QsIHBsZWFzZSByZW1vdmUgdGhlIGZpbGVcbiIKCQkJCQkiCSVzXG4iCgkJCQkJImFuZCB0cnkgYWdhaW4uXG4iKQoJCQkJOiBfKCJcbiIKCQkJCQkiSXQgbG9va3MgbGlrZSB5b3UgbWF5IGJlIGNvbW1pdHRpbmcgYSBjaGVycnktcGljay5cbiIKCQkJCQkiSWYgdGhpcyBpcyBub3QgY29ycmVjdCwgcGxlYXNlIHJlbW92ZSB0aGUgZmlsZVxuIgoJCQkJCSIJJXNcbiIKCQkJCQkiYW5kIHRyeSBhZ2Fpbi5cbiIpLAoJCQkJZ2l0X3BhdGgod2hlbmNlID09IEZST01fTUVSR0UKCQkJCQkgPyAiTUVSR0VfSEVBRCIKCQkJCQkgOiAiQ0hFUlJZX1BJQ0tfSEVBRCIpKTsKCgkJZnByaW50ZihzLT5mcCwgIlxuIik7CgkJaWYgKGNsZWFudXBfbW9kZSA9PSBDTEVBTlVQX0FMTCkKCQkJc3RhdHVzX3ByaW50ZihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJXygiUGxlYXNlIGVudGVyIHRoZSBjb21taXQgbWVzc2FnZSBmb3IgeW91ciBjaGFuZ2VzLiIKCQkJCSAgIiBMaW5lcyBzdGFydGluZ1xud2l0aCAnJWMnIHdpbGwgYmUgaWdub3JlZCwgYW5kIGFuIGVtcHR5IgoJCQkJICAiIG1lc3NhZ2UgYWJvcnRzIHRoZSBjb21taXQuXG4iKSwgY29tbWVudF9saW5lX2NoYXIpOwoJCWVsc2UgLyogQ0xFQU5VUF9TUEFDRSwgdGhhdCBpcy4gKi8KCQkJc3RhdHVzX3ByaW50ZihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJXygiUGxlYXNlIGVudGVyIHRoZSBjb21taXQgbWVzc2FnZSBmb3IgeW91ciBjaGFuZ2VzLiIKCQkJCSAgIiBMaW5lcyBzdGFydGluZ1xuIgoJCQkJICAid2l0aCAnJWMnIHdpbGwgYmUga2VwdDsgeW91IG1heSByZW1vdmUgdGhlbSIKCQkJCSAgIiB5b3Vyc2VsZiBpZiB5b3Ugd2FudCB0by5cbiIKCQkJCSAgIkFuIGVtcHR5IG1lc3NhZ2UgYWJvcnRzIHRoZSBjb21taXQuXG4iKSwgY29tbWVudF9saW5lX2NoYXIpOwoJCWlmIChvbmx5X2luY2x1ZGVfYXNzdW1lZCkKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJCSIlcyIsIG9ubHlfaW5jbHVkZV9hc3N1bWVkKTsKCgkJYWlfdG1wID0gY3V0X2lkZW50X3RpbWVzdGFtcF9wYXJ0KGF1dGhvcl9pZGVudC0+YnVmKTsKCQljaV90bXAgPSBjdXRfaWRlbnRfdGltZXN0YW1wX3BhcnQoY29tbWl0dGVyX2lkZW50LmJ1Zik7CgkJaWYgKHN0cmNtcChhdXRob3JfaWRlbnQtPmJ1ZiwgY29tbWl0dGVyX2lkZW50LmJ1ZikpCgkJCXN0YXR1c19wcmludGZfbG4ocywgR0lUX0NPTE9SX05PUk1BTCwKCQkJCV8oIiVzIgoJCQkJIkF1dGhvcjogICAgJXMiKSwKCQkJCWlkZW50X3Nob3duKysgPyAiIiA6ICJcbiIsCgkJCQlhdXRob3JfaWRlbnQtPmJ1Zik7CgoJCWlmICghY29tbWl0dGVyX2lkZW50X3N1ZmZpY2llbnRseV9naXZlbigpKQoJCQlzdGF0dXNfcHJpbnRmX2xuKHMsIEdJVF9DT0xPUl9OT1JNQUwsCgkJCQlfKCIlcyIKCQkJCSJDb21taXR0ZXI6ICVzIiksCgkJCQlpZGVudF9zaG93bisrID8gIiIgOiAiXG4iLAoJCQkJY29tbWl0dGVyX2lkZW50LmJ1Zik7CgoJCWlmIChpZGVudF9zaG93bikKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLCAiIik7CgoJCXNhdmVkX2NvbG9yX3NldHRpbmcgPSBzLT51c2VfY29sb3I7CgkJcy0+dXNlX2NvbG9yID0gMDsKCQljb21taXRhYmxlID0gcnVuX3N0YXR1cyhzLT5mcCwgaW5kZXhfZmlsZSwgcHJlZml4LCAxLCBzKTsKCQlzLT51c2VfY29sb3IgPSBzYXZlZF9jb2xvcl9zZXR0aW5nOwoKCQkqYWlfdG1wID0gJyAnOwoJCSpjaV90bXAgPSAnICc7Cgl9IGVsc2UgewoJCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgkJY29uc3QgY2hhciAqcGFyZW50ID0gIkhFQUQiOwoKCQlpZiAoIWFjdGl2ZV9uciAmJiByZWFkX2NhY2hlKCkgPCAwKQoJCQlkaWUoXygiQ2Fubm90IHJlYWQgaW5kZXgiKSk7CgoJCWlmIChhbWVuZCkKCQkJcGFyZW50ID0gIkhFQUReMSI7CgoJCWlmIChnZXRfc2hhMShwYXJlbnQsIHNoYTEpKQoJCQljb21taXRhYmxlID0gISFhY3RpdmVfbnI7CgkJZWxzZQoJCQljb21taXRhYmxlID0gaW5kZXhfZGlmZmVyc19mcm9tKHBhcmVudCwgMCk7Cgl9CglzdHJidWZfcmVsZWFzZSgmY29tbWl0dGVyX2lkZW50KTsKCglmY2xvc2Uocy0+ZnApOwoKCS8qCgkgKiBSZWplY3QgYW4gYXR0ZW1wdCB0byByZWNvcmQgYSBub24tbWVyZ2UgZW1wdHkgY29tbWl0IHdpdGhvdXQKCSAqIGV4cGxpY2l0IC0tYWxsb3ctZW1wdHkuIEluIHRoZSBjaGVycnktcGljayBjYXNlLCBpdCBtYXkgYmUKCSAqIGVtcHR5IGR1ZSB0byBjb25mbGljdCByZXNvbHV0aW9uLCB3aGljaCB0aGUgdXNlciBzaG91bGQgb2theS4KCSAqLwoJaWYgKCFjb21taXRhYmxlICYmIHdoZW5jZSAhPSBGUk9NX01FUkdFICYmICFhbGxvd19lbXB0eSAmJgoJICAgICEoYW1lbmQgJiYgaXNfYV9tZXJnZShjdXJyZW50X2hlYWQpKSkgewoJCXJ1bl9zdGF0dXMoc3Rkb3V0LCBpbmRleF9maWxlLCBwcmVmaXgsIDAsIHMpOwoJCWlmIChhbWVuZCkKCQkJZnB1dHMoXyhlbXB0eV9hbWVuZF9hZHZpY2UpLCBzdGRlcnIpOwoJCWVsc2UgaWYgKHdoZW5jZSA9PSBGUk9NX0NIRVJSWV9QSUNLKQoJCQlmcHV0cyhfKGVtcHR5X2NoZXJyeV9waWNrX2FkdmljZSksIHN0ZGVycik7CgkJcmV0dXJuIDA7Cgl9CgoJLyoKCSAqIFJlLXJlYWQgdGhlIGluZGV4IGFzIHByZS1jb21taXQgaG9vayBjb3VsZCBoYXZlIHVwZGF0ZWQgaXQsCgkgKiBhbmQgd3JpdGUgaXQgb3V0IGFzIGEgdHJlZS4gIFdlIG11c3QgZG8gdGhpcyBiZWZvcmUgd2UgaW52b2tlCgkgKiB0aGUgZWRpdG9yIGFuZCBhZnRlciB3ZSBpbnZva2UgcnVuX3N0YXR1cyBhYm92ZS4KCSAqLwoJZGlzY2FyZF9jYWNoZSgpOwoJcmVhZF9jYWNoZV9mcm9tKGluZGV4X2ZpbGUpOwoJaWYgKHVwZGF0ZV9tYWluX2NhY2hlX3RyZWUoMCkpIHsKCQllcnJvcihfKCJFcnJvciBidWlsZGluZyB0cmVlcyIpKTsKCQlyZXR1cm4gMDsKCX0KCglpZiAocnVuX2hvb2soaW5kZXhfZmlsZSwgInByZXBhcmUtY29tbWl0LW1zZyIsCgkJICAgICBnaXRfcGF0aChjb21taXRfZWRpdG1zZyksIGhvb2tfYXJnMSwgaG9va19hcmcyLCBOVUxMKSkKCQlyZXR1cm4gMDsKCglpZiAodXNlX2VkaXRvcikgewoJCWNoYXIgaW5kZXhbUEFUSF9NQVhdOwoJCWNvbnN0IGNoYXIgKmVudlsyXSA9IHsgTlVMTCB9OwoJCWVudlswXSA9ICBpbmRleDsKCQlzbnByaW50ZihpbmRleCwgc2l6ZW9mKGluZGV4KSwgIkdJVF9JTkRFWF9GSUxFPSVzIiwgaW5kZXhfZmlsZSk7CgkJaWYgKGxhdW5jaF9lZGl0b3IoZ2l0X3BhdGgoY29tbWl0X2VkaXRtc2cpLCBOVUxMLCBlbnYpKSB7CgkJCWZwcmludGYoc3RkZXJyLAoJCQlfKCJQbGVhc2Ugc3VwcGx5IHRoZSBtZXNzYWdlIHVzaW5nIGVpdGhlciAtbSBvciAtRiBvcHRpb24uXG4iKSk7CgkJCWV4aXQoMSk7CgkJfQoJfQoKCWlmICghbm9fdmVyaWZ5ICYmCgkgICAgcnVuX2hvb2soaW5kZXhfZmlsZSwgImNvbW1pdC1tc2ciLCBnaXRfcGF0aChjb21taXRfZWRpdG1zZyksIE5VTEwpKSB7CgkJcmV0dXJuIDA7Cgl9CgoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBpbnQgcmVzdF9pc19lbXB0eShzdHJ1Y3Qgc3RyYnVmICpzYiwgaW50IHN0YXJ0KQp7CglpbnQgaSwgZW9sOwoJY29uc3QgY2hhciAqbmw7CgoJLyogQ2hlY2sgaWYgdGhlIHJlc3QgaXMganVzdCB3aGl0ZXNwYWNlIGFuZCBTaWduZWQtb2YtYnkncy4gKi8KCWZvciAoaSA9IHN0YXJ0OyBpIDwgc2ItPmxlbjsgaSsrKSB7CgkJbmwgPSBtZW1jaHIoc2ItPmJ1ZiArIGksICdcbicsIHNiLT5sZW4gLSBpKTsKCQlpZiAobmwpCgkJCWVvbCA9IG5sIC0gc2ItPmJ1ZjsKCQllbHNlCgkJCWVvbCA9IHNiLT5sZW47CgoJCWlmIChzdHJsZW4oc2lnbl9vZmZfaGVhZGVyKSA8PSBlb2wgLSBpICYmCgkJICAgICFwcmVmaXhjbXAoc2ItPmJ1ZiArIGksIHNpZ25fb2ZmX2hlYWRlcikpIHsKCQkJaSA9IGVvbDsKCQkJY29udGludWU7CgkJfQoJCXdoaWxlIChpIDwgZW9sKQoJCQlpZiAoIWlzc3BhY2Uoc2ItPmJ1ZltpKytdKSkKCQkJCXJldHVybiAwOwoJfQoKCXJldHVybiAxOwp9CgovKgogKiBGaW5kIG91dCBpZiB0aGUgbWVzc2FnZSBpbiB0aGUgc3RyYnVmIGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZSBhbmQKICogU2lnbmVkLW9mZi1ieSBsaW5lcy4KICovCnN0YXRpYyBpbnQgbWVzc2FnZV9pc19lbXB0eShzdHJ1Y3Qgc3RyYnVmICpzYikKewoJaWYgKGNsZWFudXBfbW9kZSA9PSBDTEVBTlVQX05PTkUgJiYgc2ItPmxlbikKCQlyZXR1cm4gMDsKCXJldHVybiByZXN0X2lzX2VtcHR5KHNiLCAwKTsKfQoKLyoKICogU2VlIGlmIHRoZSB1c2VyIGVkaXRlZCB0aGUgbWVzc2FnZSBpbiB0aGUgZWRpdG9yIG9yIGxlZnQgd2hhdAogKiB3YXMgaW4gdGhlIHRlbXBsYXRlIGludGFjdAogKi8Kc3RhdGljIGludCB0ZW1wbGF0ZV91bnRvdWNoZWQoc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCXN0cnVjdCBzdHJidWYgdG1wbCA9IFNUUkJVRl9JTklUOwoJY2hhciAqc3RhcnQ7CgoJaWYgKGNsZWFudXBfbW9kZSA9PSBDTEVBTlVQX05PTkUgJiYgc2ItPmxlbikKCQlyZXR1cm4gMDsKCglpZiAoIXRlbXBsYXRlX2ZpbGUgfHwgc3RyYnVmX3JlYWRfZmlsZSgmdG1wbCwgdGVtcGxhdGVfZmlsZSwgMCkgPD0gMCkKCQlyZXR1cm4gMDsKCglzdHJpcHNwYWNlKCZ0bXBsLCBjbGVhbnVwX21vZGUgPT0gQ0xFQU5VUF9BTEwpOwoJc3RhcnQgPSAoY2hhciAqKXNraXBfcHJlZml4KHNiLT5idWYsIHRtcGwuYnVmKTsKCWlmICghc3RhcnQpCgkJc3RhcnQgPSBzYi0+YnVmOwoJc3RyYnVmX3JlbGVhc2UoJnRtcGwpOwoJcmV0dXJuIHJlc3RfaXNfZW1wdHkoc2IsIHN0YXJ0IC0gc2ItPmJ1Zik7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpmaW5kX2F1dGhvcl9ieV9uaWNrbmFtZShjb25zdCBjaGFyICpuYW1lKQp7CglzdHJ1Y3QgcmV2X2luZm8gcmV2czsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICphdlsyMF07CglpbnQgYWMgPSAwOwoKCWluaXRfcmV2aXNpb25zKCZyZXZzLCBOVUxMKTsKCXN0cmJ1Zl9hZGRmKCZidWYsICItLWF1dGhvcj0lcyIsIG5hbWUpOwoJYXZbKythY10gPSAiLS1hbGwiOwoJYXZbKythY10gPSAiLWkiOwoJYXZbKythY10gPSBidWYuYnVmOwoJYXZbKythY10gPSBOVUxMOwoJc2V0dXBfcmV2aXNpb25zKGFjLCBhdiwgJnJldnMsIE5VTEwpOwoJcHJlcGFyZV9yZXZpc2lvbl93YWxrKCZyZXZzKTsKCWNvbW1pdCA9IGdldF9yZXZpc2lvbigmcmV2cyk7CglpZiAoY29tbWl0KSB7CgkJc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0IGN0eCA9IHswfTsKCQljdHguZGF0ZV9tb2RlID0gREFURV9OT1JNQUw7CgkJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CgkJZm9ybWF0X2NvbW1pdF9tZXNzYWdlKGNvbW1pdCwgIiVhbiA8JWFlPiIsICZidWYsICZjdHgpOwoJCXJldHVybiBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpOwoJfQoJZGllKF8oIk5vIGV4aXN0aW5nIGF1dGhvciBmb3VuZCB3aXRoICclcyciKSwgbmFtZSk7Cn0KCgpzdGF0aWMgdm9pZCBoYW5kbGVfdW50cmFja2VkX2ZpbGVzX2FyZyhzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglpZiAoIXVudHJhY2tlZF9maWxlc19hcmcpCgkJOyAvKiBkZWZhdWx0IGFscmVhZHkgaW5pdGlhbGl6ZWQgKi8KCWVsc2UgaWYgKCFzdHJjbXAodW50cmFja2VkX2ZpbGVzX2FyZywgIm5vIikpCgkJcy0+c2hvd191bnRyYWNrZWRfZmlsZXMgPSBTSE9XX05PX1VOVFJBQ0tFRF9GSUxFUzsKCWVsc2UgaWYgKCFzdHJjbXAodW50cmFja2VkX2ZpbGVzX2FyZywgIm5vcm1hbCIpKQoJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19OT1JNQUxfVU5UUkFDS0VEX0ZJTEVTOwoJZWxzZSBpZiAoIXN0cmNtcCh1bnRyYWNrZWRfZmlsZXNfYXJnLCAiYWxsIikpCgkJcy0+c2hvd191bnRyYWNrZWRfZmlsZXMgPSBTSE9XX0FMTF9VTlRSQUNLRURfRklMRVM7CgllbHNlCgkJZGllKF8oIkludmFsaWQgdW50cmFja2VkIGZpbGVzIG1vZGUgJyVzJyIpLCB1bnRyYWNrZWRfZmlsZXNfYXJnKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnJlYWRfY29tbWl0X21lc3NhZ2UoY29uc3QgY2hhciAqbmFtZSkKewoJY29uc3QgY2hhciAqb3V0X2VuYzsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCgljb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9ieV9uYW1lKG5hbWUpOwoJaWYgKCFjb21taXQpCgkJZGllKF8oImNvdWxkIG5vdCBsb29rdXAgY29tbWl0ICVzIiksIG5hbWUpOwoJb3V0X2VuYyA9IGdldF9jb21taXRfb3V0cHV0X2VuY29kaW5nKCk7CglyZXR1cm4gbG9nbXNnX3JlZW5jb2RlKGNvbW1pdCwgTlVMTCwgb3V0X2VuYyk7Cn0KCi8qCiAqIEVudW1lcmF0ZSB3aGF0IG5lZWRzIHRvIGJlIHByb3BhZ2F0ZWQgd2hlbiAtLXBvcmNlbGFpbgogKiBpcyBub3QgaW4gZWZmZWN0IGhlcmUuCiAqLwpzdGF0aWMgc3RydWN0IHN0YXR1c19kZWZlcnJlZF9jb25maWcgewoJZW51bSBzdGF0dXNfZm9ybWF0IHN0YXR1c19mb3JtYXQ7CglpbnQgc2hvd19icmFuY2g7Cn0gc3RhdHVzX2RlZmVycmVkX2NvbmZpZyA9IHsKCVNUQVRVU19GT1JNQVRfVU5TUEVDSUZJRUQsCgktMSAvKiB1bnNwZWNpZmllZCAqLwp9OwoKc3RhdGljIHZvaWQgZmluYWxpemVfZGVmZXJyZWRfY29uZmlnKHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWludCB1c2VfZGVmZXJyZWRfY29uZmlnID0gKHN0YXR1c19mb3JtYXQgIT0gU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU4gJiYKCQkJCSAgICFzLT5udWxsX3Rlcm1pbmF0aW9uKTsKCglpZiAocy0+bnVsbF90ZXJtaW5hdGlvbikgewoJCWlmIChzdGF0dXNfZm9ybWF0ID09IFNUQVRVU19GT1JNQVRfTk9ORSB8fAoJCSAgICBzdGF0dXNfZm9ybWF0ID09IFNUQVRVU19GT1JNQVRfVU5TUEVDSUZJRUQpCgkJCXN0YXR1c19mb3JtYXQgPSBTVEFUVVNfRk9STUFUX1BPUkNFTEFJTjsKCQllbHNlIGlmIChzdGF0dXNfZm9ybWF0ID09IFNUQVRVU19GT1JNQVRfTE9ORykKCQkJZGllKF8oIi0tbG9uZyBhbmQgLXogYXJlIGluY29tcGF0aWJsZSIpKTsKCX0KCglpZiAodXNlX2RlZmVycmVkX2NvbmZpZyAmJiBzdGF0dXNfZm9ybWF0ID09IFNUQVRVU19GT1JNQVRfVU5TUEVDSUZJRUQpCgkJc3RhdHVzX2Zvcm1hdCA9IHN0YXR1c19kZWZlcnJlZF9jb25maWcuc3RhdHVzX2Zvcm1hdDsKCWlmIChzdGF0dXNfZm9ybWF0ID09IFNUQVRVU19GT1JNQVRfVU5TUEVDSUZJRUQpCgkJc3RhdHVzX2Zvcm1hdCA9IFNUQVRVU19GT1JNQVRfTk9ORTsKCglpZiAodXNlX2RlZmVycmVkX2NvbmZpZyAmJiBzLT5zaG93X2JyYW5jaCA8IDApCgkJcy0+c2hvd19icmFuY2ggPSBzdGF0dXNfZGVmZXJyZWRfY29uZmlnLnNob3dfYnJhbmNoOwoJaWYgKHMtPnNob3dfYnJhbmNoIDwgMCkKCQlzLT5zaG93X2JyYW5jaCA9IDA7Cn0KCnN0YXRpYyBpbnQgcGFyc2VfYW5kX3ZhbGlkYXRlX29wdGlvbnMoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKmFyZ3ZbXSwKCQkJCSAgICAgIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdGlvbnMsCgkJCQkgICAgICBjb25zdCBjaGFyICogY29uc3QgdXNhZ2VbXSwKCQkJCSAgICAgIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJCSAgICAgIHN0cnVjdCBjb21taXQgKmN1cnJlbnRfaGVhZCwKCQkJCSAgICAgIHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWludCBmID0gMDsKCglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIG9wdGlvbnMsIHVzYWdlLCAwKTsKCWZpbmFsaXplX2RlZmVycmVkX2NvbmZpZyhzKTsKCglpZiAoZm9yY2VfYXV0aG9yICYmICFzdHJjaHIoZm9yY2VfYXV0aG9yLCAnPicpKQoJCWZvcmNlX2F1dGhvciA9IGZpbmRfYXV0aG9yX2J5X25pY2tuYW1lKGZvcmNlX2F1dGhvcik7CgoJaWYgKGZvcmNlX2F1dGhvciAmJiByZW5ld19hdXRob3JzaGlwKQoJCWRpZShfKCJVc2luZyBib3RoIC0tcmVzZXQtYXV0aG9yIGFuZCAtLWF1dGhvciBkb2VzIG5vdCBtYWtlIHNlbnNlIikpOwoKCWlmIChsb2dmaWxlIHx8IGhhdmVfb3B0aW9uX20gfHwgdXNlX21lc3NhZ2UgfHwgZml4dXBfbWVzc2FnZSkKCQl1c2VfZWRpdG9yID0gMDsKCWlmICgwIDw9IGVkaXRfZmxhZykKCQl1c2VfZWRpdG9yID0gZWRpdF9mbGFnOwoJaWYgKCF1c2VfZWRpdG9yKQoJCXNldGVudigiR0lUX0VESVRPUiIsICI6IiwgMSk7CgoJLyogU2FuaXR5IGNoZWNrIG9wdGlvbnMgKi8KCWlmIChhbWVuZCAmJiAhY3VycmVudF9oZWFkKQoJCWRpZShfKCJZb3UgaGF2ZSBub3RoaW5nIHRvIGFtZW5kLiIpKTsKCWlmIChhbWVuZCAmJiB3aGVuY2UgIT0gRlJPTV9DT01NSVQpIHsKCQlpZiAod2hlbmNlID09IEZST01fTUVSR0UpCgkJCWRpZShfKCJZb3UgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSBtZXJnZSAtLSBjYW5ub3QgYW1lbmQuIikpOwoJCWVsc2UgaWYgKHdoZW5jZSA9PSBGUk9NX0NIRVJSWV9QSUNLKQoJCQlkaWUoXygiWW91IGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgY2hlcnJ5LXBpY2sgLS0gY2Fubm90IGFtZW5kLiIpKTsKCX0KCWlmIChmaXh1cF9tZXNzYWdlICYmIHNxdWFzaF9tZXNzYWdlKQoJCWRpZShfKCJPcHRpb25zIC0tc3F1YXNoIGFuZCAtLWZpeHVwIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIikpOwoJaWYgKHVzZV9tZXNzYWdlKQoJCWYrKzsKCWlmIChlZGl0X21lc3NhZ2UpCgkJZisrOwoJaWYgKGZpeHVwX21lc3NhZ2UpCgkJZisrOwoJaWYgKGxvZ2ZpbGUpCgkJZisrOwoJaWYgKGYgPiAxKQoJCWRpZShfKCJPbmx5IG9uZSBvZiAtYy8tQy8tRi8tLWZpeHVwIGNhbiBiZSB1c2VkLiIpKTsKCWlmIChtZXNzYWdlLmxlbiAmJiBmID4gMCkKCQlkaWUoKF8oIk9wdGlvbiAtbSBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCAtYy8tQy8tRi8tLWZpeHVwLiIpKSk7CglpZiAoZiB8fCBtZXNzYWdlLmxlbikKCQl0ZW1wbGF0ZV9maWxlID0gTlVMTDsKCWlmIChlZGl0X21lc3NhZ2UpCgkJdXNlX21lc3NhZ2UgPSBlZGl0X21lc3NhZ2U7CglpZiAoYW1lbmQgJiYgIXVzZV9tZXNzYWdlICYmICFmaXh1cF9tZXNzYWdlKQoJCXVzZV9tZXNzYWdlID0gIkhFQUQiOwoJaWYgKCF1c2VfbWVzc2FnZSAmJiB3aGVuY2UgIT0gRlJPTV9DSEVSUllfUElDSyAmJiByZW5ld19hdXRob3JzaGlwKQoJCWRpZShfKCItLXJlc2V0LWF1dGhvciBjYW4gYmUgdXNlZCBvbmx5IHdpdGggLUMsIC1jIG9yIC0tYW1lbmQuIikpOwoJaWYgKHVzZV9tZXNzYWdlKSB7CgkJdXNlX21lc3NhZ2VfYnVmZmVyID0gcmVhZF9jb21taXRfbWVzc2FnZSh1c2VfbWVzc2FnZSk7CgkJaWYgKCFyZW5ld19hdXRob3JzaGlwKSB7CgkJCWF1dGhvcl9tZXNzYWdlID0gdXNlX21lc3NhZ2U7CgkJCWF1dGhvcl9tZXNzYWdlX2J1ZmZlciA9IHVzZV9tZXNzYWdlX2J1ZmZlcjsKCQl9Cgl9CglpZiAod2hlbmNlID09IEZST01fQ0hFUlJZX1BJQ0sgJiYgIXJlbmV3X2F1dGhvcnNoaXApIHsKCQlhdXRob3JfbWVzc2FnZSA9ICJDSEVSUllfUElDS19IRUFEIjsKCQlhdXRob3JfbWVzc2FnZV9idWZmZXIgPSByZWFkX2NvbW1pdF9tZXNzYWdlKGF1dGhvcl9tZXNzYWdlKTsKCX0KCglpZiAocGF0Y2hfaW50ZXJhY3RpdmUpCgkJaW50ZXJhY3RpdmUgPSAxOwoKCWlmICghIWFsc28gKyAhIW9ubHkgKyAhIWFsbCArICEhaW50ZXJhY3RpdmUgPiAxKQoJCWRpZShfKCJPbmx5IG9uZSBvZiAtLWluY2x1ZGUvLS1vbmx5Ly0tYWxsLy0taW50ZXJhY3RpdmUvLS1wYXRjaCBjYW4gYmUgdXNlZC4iKSk7CglpZiAoYXJnYyA9PSAwICYmIChhbHNvIHx8IChvbmx5ICYmICFhbWVuZCkpKQoJCWRpZShfKCJObyBwYXRocyB3aXRoIC0taW5jbHVkZS8tLW9ubHkgZG9lcyBub3QgbWFrZSBzZW5zZS4iKSk7CglpZiAoYXJnYyA9PSAwICYmIG9ubHkgJiYgYW1lbmQpCgkJb25seV9pbmNsdWRlX2Fzc3VtZWQgPSBfKCJDbGV2ZXIuLi4gYW1lbmRpbmcgdGhlIGxhc3Qgb25lIHdpdGggZGlydHkgaW5kZXguIik7CglpZiAoYXJnYyA+IDAgJiYgIWFsc28gJiYgIW9ubHkpCgkJb25seV9pbmNsdWRlX2Fzc3VtZWQgPSBfKCJFeHBsaWNpdCBwYXRocyBzcGVjaWZpZWQgd2l0aG91dCAtaSBub3IgLW87IGFzc3VtaW5nIC0tb25seSBwYXRocy4uLiIpOwoJaWYgKCFjbGVhbnVwX2FyZyB8fCAhc3RyY21wKGNsZWFudXBfYXJnLCAiZGVmYXVsdCIpKQoJCWNsZWFudXBfbW9kZSA9IHVzZV9lZGl0b3IgPyBDTEVBTlVQX0FMTCA6IENMRUFOVVBfU1BBQ0U7CgllbHNlIGlmICghc3RyY21wKGNsZWFudXBfYXJnLCAidmVyYmF0aW0iKSkKCQljbGVhbnVwX21vZGUgPSBDTEVBTlVQX05PTkU7CgllbHNlIGlmICghc3RyY21wKGNsZWFudXBfYXJnLCAid2hpdGVzcGFjZSIpKQoJCWNsZWFudXBfbW9kZSA9IENMRUFOVVBfU1BBQ0U7CgllbHNlIGlmICghc3RyY21wKGNsZWFudXBfYXJnLCAic3RyaXAiKSkKCQljbGVhbnVwX21vZGUgPSBDTEVBTlVQX0FMTDsKCWVsc2UKCQlkaWUoXygiSW52YWxpZCBjbGVhbnVwIG1vZGUgJXMiKSwgY2xlYW51cF9hcmcpOwoKCWhhbmRsZV91bnRyYWNrZWRfZmlsZXNfYXJnKHMpOwoKCWlmIChhbGwgJiYgYXJnYyA+IDApCgkJZGllKF8oIlBhdGhzIHdpdGggLWEgZG9lcyBub3QgbWFrZSBzZW5zZS4iKSk7CgoJaWYgKHN0YXR1c19mb3JtYXQgIT0gU1RBVFVTX0ZPUk1BVF9OT05FKQoJCWRyeV9ydW4gPSAxOwoKCXJldHVybiBhcmdjOwp9CgpzdGF0aWMgaW50IGRyeV9ydW5fY29tbWl0KGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4LAoJCQkgIGNvbnN0IHN0cnVjdCBjb21taXQgKmN1cnJlbnRfaGVhZCwgc3RydWN0IHd0X3N0YXR1cyAqcykKewoJaW50IGNvbW1pdGFibGU7Cgljb25zdCBjaGFyICppbmRleF9maWxlOwoKCWluZGV4X2ZpbGUgPSBwcmVwYXJlX2luZGV4KGFyZ2MsIGFyZ3YsIHByZWZpeCwgY3VycmVudF9oZWFkLCAxKTsKCWNvbW1pdGFibGUgPSBydW5fc3RhdHVzKHN0ZG91dCwgaW5kZXhfZmlsZSwgcHJlZml4LCAwLCBzKTsKCXJvbGxiYWNrX2luZGV4X2ZpbGVzKCk7CgoJcmV0dXJuIGNvbW1pdGFibGUgPyAwIDogMTsKfQoKc3RhdGljIGludCBwYXJzZV9zdGF0dXNfc2xvdChjb25zdCBjaGFyICp2YXIsIGludCBvZmZzZXQpCnsKCWlmICghc3RyY2FzZWNtcCh2YXIrb2Zmc2V0LCAiaGVhZGVyIikpCgkJcmV0dXJuIFdUX1NUQVRVU19IRUFERVI7CglpZiAoIXN0cmNhc2VjbXAodmFyK29mZnNldCwgImJyYW5jaCIpKQoJCXJldHVybiBXVF9TVEFUVVNfT05CUkFOQ0g7CglpZiAoIXN0cmNhc2VjbXAodmFyK29mZnNldCwgInVwZGF0ZWQiKQoJCXx8ICFzdHJjYXNlY21wKHZhcitvZmZzZXQsICJhZGRlZCIpKQoJCXJldHVybiBXVF9TVEFUVVNfVVBEQVRFRDsKCWlmICghc3RyY2FzZWNtcCh2YXIrb2Zmc2V0LCAiY2hhbmdlZCIpKQoJCXJldHVybiBXVF9TVEFUVVNfQ0hBTkdFRDsKCWlmICghc3RyY2FzZWNtcCh2YXIrb2Zmc2V0LCAidW50cmFja2VkIikpCgkJcmV0dXJuIFdUX1NUQVRVU19VTlRSQUNLRUQ7CglpZiAoIXN0cmNhc2VjbXAodmFyK29mZnNldCwgIm5vYnJhbmNoIikpCgkJcmV0dXJuIFdUX1NUQVRVU19OT0JSQU5DSDsKCWlmICghc3RyY2FzZWNtcCh2YXIrb2Zmc2V0LCAidW5tZXJnZWQiKSkKCQlyZXR1cm4gV1RfU1RBVFVTX1VOTUVSR0VEOwoJcmV0dXJuIC0xOwp9CgpzdGF0aWMgaW50IGdpdF9zdGF0dXNfY29uZmlnKGNvbnN0IGNoYXIgKmssIGNvbnN0IGNoYXIgKnYsIHZvaWQgKmNiKQp7CglzdHJ1Y3Qgd3Rfc3RhdHVzICpzID0gY2I7CgoJaWYgKCFwcmVmaXhjbXAoaywgImNvbHVtbi4iKSkKCQlyZXR1cm4gZ2l0X2NvbHVtbl9jb25maWcoaywgdiwgInN0YXR1cyIsICZzLT5jb2xvcHRzKTsKCWlmICghc3RyY21wKGssICJzdGF0dXMuc3VibW9kdWxlc3VtbWFyeSIpKSB7CgkJaW50IGlzX2Jvb2w7CgkJcy0+c3VibW9kdWxlX3N1bW1hcnkgPSBnaXRfY29uZmlnX2Jvb2xfb3JfaW50KGssIHYsICZpc19ib29sKTsKCQlpZiAoaXNfYm9vbCAmJiBzLT5zdWJtb2R1bGVfc3VtbWFyeSkKCQkJcy0+c3VibW9kdWxlX3N1bW1hcnkgPSAtMTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMuc2hvcnQiKSkgewoJCWlmIChnaXRfY29uZmlnX2Jvb2woaywgdikpCgkJCXN0YXR1c19kZWZlcnJlZF9jb25maWcuc3RhdHVzX2Zvcm1hdCA9IFNUQVRVU19GT1JNQVRfU0hPUlQ7CgkJZWxzZQoJCQlzdGF0dXNfZGVmZXJyZWRfY29uZmlnLnN0YXR1c19mb3JtYXQgPSBTVEFUVVNfRk9STUFUX05PTkU7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAic3RhdHVzLmJyYW5jaCIpKSB7CgkJc3RhdHVzX2RlZmVycmVkX2NvbmZpZy5zaG93X2JyYW5jaCA9IGdpdF9jb25maWdfYm9vbChrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMuY29sb3IiKSB8fCAhc3RyY21wKGssICJjb2xvci5zdGF0dXMiKSkgewoJCXMtPnVzZV9jb2xvciA9IGdpdF9jb25maWdfY29sb3Jib29sKGssIHYpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFwcmVmaXhjbXAoaywgInN0YXR1cy5jb2xvci4iKSB8fCAhcHJlZml4Y21wKGssICJjb2xvci5zdGF0dXMuIikpIHsKCQlpbnQgc2xvdCA9IHBhcnNlX3N0YXR1c19zbG90KGssIDEzKTsKCQlpZiAoc2xvdCA8IDApCgkJCXJldHVybiAwOwoJCWlmICghdikKCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKGspOwoJCWNvbG9yX3BhcnNlKHYsIGssIHMtPmNvbG9yX3BhbGV0dGVbc2xvdF0pOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaywgInN0YXR1cy5yZWxhdGl2ZXBhdGhzIikpIHsKCQlzLT5yZWxhdGl2ZV9wYXRocyA9IGdpdF9jb25maWdfYm9vbChrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMuc2hvd3VudHJhY2tlZGZpbGVzIikpIHsKCQlpZiAoIXYpCgkJCXJldHVybiBjb25maWdfZXJyb3Jfbm9uYm9vbChrKTsKCQllbHNlIGlmICghc3RyY21wKHYsICJubyIpKQoJCQlzLT5zaG93X3VudHJhY2tlZF9maWxlcyA9IFNIT1dfTk9fVU5UUkFDS0VEX0ZJTEVTOwoJCWVsc2UgaWYgKCFzdHJjbXAodiwgIm5vcm1hbCIpKQoJCQlzLT5zaG93X3VudHJhY2tlZF9maWxlcyA9IFNIT1dfTk9STUFMX1VOVFJBQ0tFRF9GSUxFUzsKCQllbHNlIGlmICghc3RyY21wKHYsICJhbGwiKSkKCQkJcy0+c2hvd191bnRyYWNrZWRfZmlsZXMgPSBTSE9XX0FMTF9VTlRSQUNLRURfRklMRVM7CgkJZWxzZQoJCQlyZXR1cm4gZXJyb3IoXygiSW52YWxpZCB1bnRyYWNrZWQgZmlsZXMgbW9kZSAnJXMnIiksIHYpOwoJCXJldHVybiAwOwoJfQoJcmV0dXJuIGdpdF9kaWZmX3VpX2NvbmZpZyhrLCB2LCBOVUxMKTsKfQoKaW50IGNtZF9zdGF0dXMoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0YXRpYyBzdHJ1Y3Qgd3Rfc3RhdHVzIHM7CglpbnQgZmQ7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJc3RhdGljIHN0cnVjdCBvcHRpb24gYnVpbHRpbl9zdGF0dXNfb3B0aW9uc1tdID0gewoJCU9QVF9fVkVSQk9TRSgmdmVyYm9zZSwgTl8oImJlIHZlcmJvc2UiKSksCgkJT1BUX1NFVF9JTlQoJ3MnLCAic2hvcnQiLCAmc3RhdHVzX2Zvcm1hdCwKCQkJICAgIE5fKCJzaG93IHN0YXR1cyBjb25jaXNlbHkiKSwgU1RBVFVTX0ZPUk1BVF9TSE9SVCksCgkJT1BUX0JPT0woJ2InLCAiYnJhbmNoIiwgJnMuc2hvd19icmFuY2gsCgkJCSBOXygic2hvdyBicmFuY2ggaW5mb3JtYXRpb24iKSksCgkJT1BUX1NFVF9JTlQoMCwgInBvcmNlbGFpbiIsICZzdGF0dXNfZm9ybWF0LAoJCQkgICAgTl8oIm1hY2hpbmUtcmVhZGFibGUgb3V0cHV0IiksCgkJCSAgICBTVEFUVVNfRk9STUFUX1BPUkNFTEFJTiksCgkJT1BUX1NFVF9JTlQoMCwgImxvbmciLCAmc3RhdHVzX2Zvcm1hdCwKCQkJICAgIE5fKCJzaG93IHN0YXR1cyBpbiBsb25nIGZvcm1hdCAoZGVmYXVsdCkiKSwKCQkJICAgIFNUQVRVU19GT1JNQVRfTE9ORyksCgkJT1BUX0JPT0xFQU4oJ3onLCAibnVsbCIsICZzLm51bGxfdGVybWluYXRpb24sCgkJCSAgICBOXygidGVybWluYXRlIGVudHJpZXMgd2l0aCBOVUwiKSksCgkJeyBPUFRJT05fU1RSSU5HLCAndScsICJ1bnRyYWNrZWQtZmlsZXMiLCAmdW50cmFja2VkX2ZpbGVzX2FyZywKCQkgIE5fKCJtb2RlIiksCgkJICBOXygic2hvdyB1bnRyYWNrZWQgZmlsZXMsIG9wdGlvbmFsIG1vZGVzOiBhbGwsIG5vcm1hbCwgbm8uIChEZWZhdWx0OiBhbGwpIiksCgkJICBQQVJTRV9PUFRfT1BUQVJHLCBOVUxMLCAoaW50cHRyX3QpImFsbCIgfSwKCQlPUFRfQk9PTEVBTigwLCAiaWdub3JlZCIsICZzaG93X2lnbm9yZWRfaW5fc3RhdHVzLAoJCQkgICAgTl8oInNob3cgaWdub3JlZCBmaWxlcyIpKSwKCQl7IE9QVElPTl9TVFJJTkcsIDAsICJpZ25vcmUtc3VibW9kdWxlcyIsICZpZ25vcmVfc3VibW9kdWxlX2FyZywgTl8oIndoZW4iKSwKCQkgIE5fKCJpZ25vcmUgY2hhbmdlcyB0byBzdWJtb2R1bGVzLCBvcHRpb25hbCB3aGVuOiBhbGwsIGRpcnR5LCB1bnRyYWNrZWQuIChEZWZhdWx0OiBhbGwpIiksCgkJICBQQVJTRV9PUFRfT1BUQVJHLCBOVUxMLCAoaW50cHRyX3QpImFsbCIgfSwKCQlPUFRfQ09MVU1OKDAsICJjb2x1bW4iLCAmcy5jb2xvcHRzLCBOXygibGlzdCB1bnRyYWNrZWQgZmlsZXMgaW4gY29sdW1ucyIpKSwKCQlPUFRfRU5EKCksCgl9OwoKCWlmIChhcmdjID09IDIgJiYgIXN0cmNtcChhcmd2WzFdLCAiLWgiKSkKCQl1c2FnZV93aXRoX29wdGlvbnMoYnVpbHRpbl9zdGF0dXNfdXNhZ2UsIGJ1aWx0aW5fc3RhdHVzX29wdGlvbnMpOwoKCXd0X3N0YXR1c19wcmVwYXJlKCZzKTsKCWdpdG1vZHVsZXNfY29uZmlnKCk7CglnaXRfY29uZmlnKGdpdF9zdGF0dXNfY29uZmlnLCAmcyk7CglkZXRlcm1pbmVfd2hlbmNlKCZzKTsKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwKCQkJICAgICBidWlsdGluX3N0YXR1c19vcHRpb25zLAoJCQkgICAgIGJ1aWx0aW5fc3RhdHVzX3VzYWdlLCAwKTsKCWZpbmFsaXplX2NvbG9wdHMoJnMuY29sb3B0cywgLTEpOwoJZmluYWxpemVfZGVmZXJyZWRfY29uZmlnKCZzKTsKCgloYW5kbGVfdW50cmFja2VkX2ZpbGVzX2FyZygmcyk7CglpZiAoc2hvd19pZ25vcmVkX2luX3N0YXR1cykKCQlzLnNob3dfaWdub3JlZF9maWxlcyA9IDE7CglpZiAoKmFyZ3YpCgkJcy5wYXRoc3BlYyA9IGdldF9wYXRoc3BlYyhwcmVmaXgsIGFyZ3YpOwoKCXJlYWRfY2FjaGVfcHJlbG9hZChzLnBhdGhzcGVjKTsKCXJlZnJlc2hfaW5kZXgoJnRoZV9pbmRleCwgUkVGUkVTSF9RVUlFVHxSRUZSRVNIX1VOTUVSR0VELCBzLnBhdGhzcGVjLCBOVUxMLCBOVUxMKTsKCglmZCA9IGhvbGRfbG9ja2VkX2luZGV4KCZpbmRleF9sb2NrLCAwKTsKCWlmICgwIDw9IGZkKQoJCXVwZGF0ZV9pbmRleF9pZl9hYmxlKCZ0aGVfaW5kZXgsICZpbmRleF9sb2NrKTsKCglzLmlzX2luaXRpYWwgPSBnZXRfc2hhMShzLnJlZmVyZW5jZSwgc2hhMSkgPyAxIDogMDsKCXMuaWdub3JlX3N1Ym1vZHVsZV9hcmcgPSBpZ25vcmVfc3VibW9kdWxlX2FyZzsKCXd0X3N0YXR1c19jb2xsZWN0KCZzKTsKCglpZiAocy5yZWxhdGl2ZV9wYXRocykKCQlzLnByZWZpeCA9IHByZWZpeDsKCglzd2l0Y2ggKHN0YXR1c19mb3JtYXQpIHsKCWNhc2UgU1RBVFVTX0ZPUk1BVF9TSE9SVDoKCQl3dF9zaG9ydHN0YXR1c19wcmludCgmcyk7CgkJYnJlYWs7CgljYXNlIFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOOgoJCXd0X3BvcmNlbGFpbl9wcmludCgmcyk7CgkJYnJlYWs7CgljYXNlIFNUQVRVU19GT1JNQVRfVU5TUEVDSUZJRUQ6CgkJZGllKCJCVUc6IGZpbmFsaXplX2RlZmVycmVkX2NvbmZpZygpIHNob3VsZCBoYXZlIGJlZW4gY2FsbGVkIik7CgkJYnJlYWs7CgljYXNlIFNUQVRVU19GT1JNQVRfTk9ORToKCWNhc2UgU1RBVFVTX0ZPUk1BVF9MT05HOgoJCXMudmVyYm9zZSA9IHZlcmJvc2U7CgkJcy5pZ25vcmVfc3VibW9kdWxlX2FyZyA9IGlnbm9yZV9zdWJtb2R1bGVfYXJnOwoJCXd0X3N0YXR1c19wcmludCgmcyk7CgkJYnJlYWs7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgcHJpbnRfc3VtbWFyeShjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsCgkJCSAgaW50IGluaXRpYWxfY29tbWl0KQp7CglzdHJ1Y3QgcmV2X2luZm8gcmV2OwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJc3RydWN0IHN0cmJ1ZiBmb3JtYXQgPSBTVFJCVUZfSU5JVDsKCXVuc2lnbmVkIGNoYXIganVua19zaGExWzIwXTsKCWNvbnN0IGNoYXIgKmhlYWQ7CglzdHJ1Y3QgcHJldHR5X3ByaW50X2NvbnRleHQgcGN0eCA9IHswfTsKCXN0cnVjdCBzdHJidWYgYXV0aG9yX2lkZW50ID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGNvbW1pdHRlcl9pZGVudCA9IFNUUkJVRl9JTklUOwoKCWNvbW1pdCA9IGxvb2t1cF9jb21taXQoc2hhMSk7CglpZiAoIWNvbW1pdCkKCQlkaWUoXygiY291bGRuJ3QgbG9vayB1cCBuZXdseSBjcmVhdGVkIGNvbW1pdCIpKTsKCWlmICghY29tbWl0IHx8IHBhcnNlX2NvbW1pdChjb21taXQpKQoJCWRpZShfKCJjb3VsZCBub3QgcGFyc2UgbmV3bHkgY3JlYXRlZCBjb21taXQiKSk7CgoJc3RyYnVmX2FkZHN0cigmZm9ybWF0LCAiZm9ybWF0OiVoXSAlcyIpOwoKCWZvcm1hdF9jb21taXRfbWVzc2FnZShjb21taXQsICIlYW4gPCVhZT4iLCAmYXV0aG9yX2lkZW50LCAmcGN0eCk7Cglmb3JtYXRfY29tbWl0X21lc3NhZ2UoY29tbWl0LCAiJWNuIDwlY2U+IiwgJmNvbW1pdHRlcl9pZGVudCwgJnBjdHgpOwoJaWYgKHN0cmJ1Zl9jbXAoJmF1dGhvcl9pZGVudCwgJmNvbW1pdHRlcl9pZGVudCkpIHsKCQlzdHJidWZfYWRkc3RyKCZmb3JtYXQsICJcbiBBdXRob3I6ICIpOwoJCXN0cmJ1Zl9hZGRidWZfcGVyY2VudHF1b3RlKCZmb3JtYXQsICZhdXRob3JfaWRlbnQpOwoJfQoJaWYgKCFjb21taXR0ZXJfaWRlbnRfc3VmZmljaWVudGx5X2dpdmVuKCkpIHsKCQlzdHJidWZfYWRkc3RyKCZmb3JtYXQsICJcbiBDb21taXR0ZXI6ICIpOwoJCXN0cmJ1Zl9hZGRidWZfcGVyY2VudHF1b3RlKCZmb3JtYXQsICZjb21taXR0ZXJfaWRlbnQpOwoJCWlmIChhZHZpY2VfaW1wbGljaXRfaWRlbnRpdHkpIHsKCQkJc3RyYnVmX2FkZGNoKCZmb3JtYXQsICdcbicpOwoJCQlzdHJidWZfYWRkc3RyKCZmb3JtYXQsIF8oaW1wbGljaXRfaWRlbnRfYWR2aWNlKSk7CgkJfQoJfQoJc3RyYnVmX3JlbGVhc2UoJmF1dGhvcl9pZGVudCk7CglzdHJidWZfcmVsZWFzZSgmY29tbWl0dGVyX2lkZW50KTsKCglpbml0X3JldmlzaW9ucygmcmV2LCBwcmVmaXgpOwoJc2V0dXBfcmV2aXNpb25zKDAsIE5VTEwsICZyZXYsIE5VTEwpOwoKCXJldi5kaWZmID0gMTsKCXJldi5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgPQoJCURJRkZfRk9STUFUX1NIT1JUU1RBVCB8IERJRkZfRk9STUFUX1NVTU1BUlk7CgoJcmV2LnZlcmJvc2VfaGVhZGVyID0gMTsKCXJldi5zaG93X3Jvb3RfZGlmZiA9IDE7CglnZXRfY29tbWl0X2Zvcm1hdChmb3JtYXQuYnVmLCAmcmV2KTsKCXJldi5hbHdheXNfc2hvd19oZWFkZXIgPSAwOwoJcmV2LmRpZmZvcHQuZGV0ZWN0X3JlbmFtZSA9IDE7CglyZXYuZGlmZm9wdC5icmVha19vcHQgPSAwOwoJZGlmZl9zZXR1cF9kb25lKCZyZXYuZGlmZm9wdCk7CgoJaGVhZCA9IHJlc29sdmVfcmVmX3Vuc2FmZSgiSEVBRCIsIGp1bmtfc2hhMSwgMCwgTlVMTCk7CglwcmludGYoIlslcyVzICIsCgkJIXByZWZpeGNtcChoZWFkLCAicmVmcy9oZWFkcy8iKSA/CgkJCWhlYWQgKyAxMSA6CgkJCSFzdHJjbXAoaGVhZCwgIkhFQUQiKSA/CgkJCQlfKCJkZXRhY2hlZCBIRUFEIikgOgoJCQkJaGVhZCwKCQlpbml0aWFsX2NvbW1pdCA/IF8oIiAocm9vdC1jb21taXQpIikgOiAiIik7CgoJaWYgKCFsb2dfdHJlZV9jb21taXQoJnJldiwgY29tbWl0KSkgewoJCXJldi5hbHdheXNfc2hvd19oZWFkZXIgPSAxOwoJCXJldi51c2VfdGVybWluYXRvciA9IDE7CgkJbG9nX3RyZWVfY29tbWl0KCZyZXYsIGNvbW1pdCk7Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJmZvcm1hdCk7Cn0KCnN0YXRpYyBpbnQgZ2l0X2NvbW1pdF9jb25maWcoY29uc3QgY2hhciAqaywgY29uc3QgY2hhciAqdiwgdm9pZCAqY2IpCnsKCXN0cnVjdCB3dF9zdGF0dXMgKnMgPSBjYjsKCWludCBzdGF0dXM7CgoJaWYgKCFzdHJjbXAoaywgImNvbW1pdC50ZW1wbGF0ZSIpKQoJCXJldHVybiBnaXRfY29uZmlnX3BhdGhuYW1lKCZ0ZW1wbGF0ZV9maWxlLCBrLCB2KTsKCWlmICghc3RyY21wKGssICJjb21taXQuc3RhdHVzIikpIHsKCQlpbmNsdWRlX3N0YXR1cyA9IGdpdF9jb25maWdfYm9vbChrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJjb21taXQuY2xlYW51cCIpKQoJCXJldHVybiBnaXRfY29uZmlnX3N0cmluZygmY2xlYW51cF9hcmcsIGssIHYpOwoKCXN0YXR1cyA9IGdpdF9ncGdfY29uZmlnKGssIHYsIE5VTEwpOwoJaWYgKHN0YXR1cykKCQlyZXR1cm4gc3RhdHVzOwoJcmV0dXJuIGdpdF9zdGF0dXNfY29uZmlnKGssIHYsIHMpOwp9CgpzdGF0aWMgaW50IHJ1bl9yZXdyaXRlX2hvb2soY29uc3QgdW5zaWduZWQgY2hhciAqb2xkc2hhMSwKCQkJICAgIGNvbnN0IHVuc2lnbmVkIGNoYXIgKm5ld3NoYTEpCnsKCS8qIG9sZHNoYTEgU1AgbmV3c2hhMSBMRiBOVUwgKi8KCXN0YXRpYyBjaGFyIGJ1ZlsyKjQwICsgM107CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBwcm9jOwoJY29uc3QgY2hhciAqYXJndlszXTsKCWludCBjb2RlOwoJc2l6ZV90IG47CgoJYXJndlswXSA9IGZpbmRfaG9vaygicG9zdC1yZXdyaXRlIik7CglpZiAoIWFyZ3ZbMF0pCgkJcmV0dXJuIDA7CgoJYXJndlsxXSA9ICJhbWVuZCI7Cglhcmd2WzJdID0gTlVMTDsKCgltZW1zZXQoJnByb2MsIDAsIHNpemVvZihwcm9jKSk7Cglwcm9jLmFyZ3YgPSBhcmd2OwoJcHJvYy5pbiA9IC0xOwoJcHJvYy5zdGRvdXRfdG9fc3RkZXJyID0gMTsKCgljb2RlID0gc3RhcnRfY29tbWFuZCgmcHJvYyk7CglpZiAoY29kZSkKCQlyZXR1cm4gY29kZTsKCW4gPSBzbnByaW50ZihidWYsIHNpemVvZihidWYpLCAiJXMgJXNcbiIsCgkJICAgICBzaGExX3RvX2hleChvbGRzaGExKSwgc2hhMV90b19oZXgobmV3c2hhMSkpOwoJd3JpdGVfaW5fZnVsbChwcm9jLmluLCBidWYsIG4pOwoJY2xvc2UocHJvYy5pbik7CglyZXR1cm4gZmluaXNoX2NvbW1hbmQoJnByb2MpOwp9CgppbnQgY21kX2NvbW1pdChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RhdGljIHN0cnVjdCB3dF9zdGF0dXMgczsKCXN0YXRpYyBzdHJ1Y3Qgb3B0aW9uIGJ1aWx0aW5fY29tbWl0X29wdGlvbnNbXSA9IHsKCQlPUFRfX1FVSUVUKCZxdWlldCwgTl8oInN1cHByZXNzIHN1bW1hcnkgYWZ0ZXIgc3VjY2Vzc2Z1bCBjb21taXQiKSksCgkJT1BUX19WRVJCT1NFKCZ2ZXJib3NlLCBOXygic2hvdyBkaWZmIGluIGNvbW1pdCBtZXNzYWdlIHRlbXBsYXRlIikpLAoKCQlPUFRfR1JPVVAoTl8oIkNvbW1pdCBtZXNzYWdlIG9wdGlvbnMiKSksCgkJT1BUX0ZJTEVOQU1FKCdGJywgImZpbGUiLCAmbG9nZmlsZSwgTl8oInJlYWQgbWVzc2FnZSBmcm9tIGZpbGUiKSksCgkJT1BUX1NUUklORygwLCAiYXV0aG9yIiwgJmZvcmNlX2F1dGhvciwgTl8oImF1dGhvciIpLCBOXygib3ZlcnJpZGUgYXV0aG9yIGZvciBjb21taXQiKSksCgkJT1BUX1NUUklORygwLCAiZGF0ZSIsICZmb3JjZV9kYXRlLCBOXygiZGF0ZSIpLCBOXygib3ZlcnJpZGUgZGF0ZSBmb3IgY29tbWl0IikpLAoJCU9QVF9DQUxMQkFDSygnbScsICJtZXNzYWdlIiwgJm1lc3NhZ2UsIE5fKCJtZXNzYWdlIiksIE5fKCJjb21taXQgbWVzc2FnZSIpLCBvcHRfcGFyc2VfbSksCgkJT1BUX1NUUklORygnYycsICJyZWVkaXQtbWVzc2FnZSIsICZlZGl0X21lc3NhZ2UsIE5fKCJjb21taXQiKSwgTl8oInJldXNlIGFuZCBlZGl0IG1lc3NhZ2UgZnJvbSBzcGVjaWZpZWQgY29tbWl0IikpLAoJCU9QVF9TVFJJTkcoJ0MnLCAicmV1c2UtbWVzc2FnZSIsICZ1c2VfbWVzc2FnZSwgTl8oImNvbW1pdCIpLCBOXygicmV1c2UgbWVzc2FnZSBmcm9tIHNwZWNpZmllZCBjb21taXQiKSksCgkJT1BUX1NUUklORygwLCAiZml4dXAiLCAmZml4dXBfbWVzc2FnZSwgTl8oImNvbW1pdCIpLCBOXygidXNlIGF1dG9zcXVhc2ggZm9ybWF0dGVkIG1lc3NhZ2UgdG8gZml4dXAgc3BlY2lmaWVkIGNvbW1pdCIpKSwKCQlPUFRfU1RSSU5HKDAsICJzcXVhc2giLCAmc3F1YXNoX21lc3NhZ2UsIE5fKCJjb21taXQiKSwgTl8oInVzZSBhdXRvc3F1YXNoIGZvcm1hdHRlZCBtZXNzYWdlIHRvIHNxdWFzaCBzcGVjaWZpZWQgY29tbWl0IikpLAoJCU9QVF9CT09MRUFOKDAsICJyZXNldC1hdXRob3IiLCAmcmVuZXdfYXV0aG9yc2hpcCwgTl8oInRoZSBjb21taXQgaXMgYXV0aG9yZWQgYnkgbWUgbm93ICh1c2VkIHdpdGggLUMvLWMvLS1hbWVuZCkiKSksCgkJT1BUX0JPT0xFQU4oJ3MnLCAic2lnbm9mZiIsICZzaWdub2ZmLCBOXygiYWRkIFNpZ25lZC1vZmYtYnk6IikpLAoJCU9QVF9GSUxFTkFNRSgndCcsICJ0ZW1wbGF0ZSIsICZ0ZW1wbGF0ZV9maWxlLCBOXygidXNlIHNwZWNpZmllZCB0ZW1wbGF0ZSBmaWxlIikpLAoJCU9QVF9CT09MKCdlJywgImVkaXQiLCAmZWRpdF9mbGFnLCBOXygiZm9yY2UgZWRpdCBvZiBjb21taXQiKSksCgkJT1BUX1NUUklORygwLCAiY2xlYW51cCIsICZjbGVhbnVwX2FyZywgTl8oImRlZmF1bHQiKSwgTl8oImhvdyB0byBzdHJpcCBzcGFjZXMgYW5kICNjb21tZW50cyBmcm9tIG1lc3NhZ2UiKSksCgkJT1BUX0JPT0xFQU4oMCwgInN0YXR1cyIsICZpbmNsdWRlX3N0YXR1cywgTl8oImluY2x1ZGUgc3RhdHVzIGluIGNvbW1pdCBtZXNzYWdlIHRlbXBsYXRlIikpLAoJCXsgT1BUSU9OX1NUUklORywgJ1MnLCAiZ3BnLXNpZ24iLCAmc2lnbl9jb21taXQsIE5fKCJrZXkgaWQiKSwKCQkgIE5fKCJHUEcgc2lnbiBjb21taXQiKSwgUEFSU0VfT1BUX09QVEFSRywgTlVMTCwgKGludHB0cl90KSAiIiB9LAoJCS8qIGVuZCBjb21taXQgbWVzc2FnZSBvcHRpb25zICovCgoJCU9QVF9HUk9VUChOXygiQ29tbWl0IGNvbnRlbnRzIG9wdGlvbnMiKSksCgkJT1BUX0JPT0xFQU4oJ2EnLCAiYWxsIiwgJmFsbCwgTl8oImNvbW1pdCBhbGwgY2hhbmdlZCBmaWxlcyIpKSwKCQlPUFRfQk9PTEVBTignaScsICJpbmNsdWRlIiwgJmFsc28sIE5fKCJhZGQgc3BlY2lmaWVkIGZpbGVzIHRvIGluZGV4IGZvciBjb21taXQiKSksCgkJT1BUX0JPT0xFQU4oMCwgImludGVyYWN0aXZlIiwgJmludGVyYWN0aXZlLCBOXygiaW50ZXJhY3RpdmVseSBhZGQgZmlsZXMiKSksCgkJT1BUX0JPT0xFQU4oJ3AnLCAicGF0Y2giLCAmcGF0Y2hfaW50ZXJhY3RpdmUsIE5fKCJpbnRlcmFjdGl2ZWx5IGFkZCBjaGFuZ2VzIikpLAoJCU9QVF9CT09MRUFOKCdvJywgIm9ubHkiLCAmb25seSwgTl8oImNvbW1pdCBvbmx5IHNwZWNpZmllZCBmaWxlcyIpKSwKCQlPUFRfQk9PTEVBTignbicsICJuby12ZXJpZnkiLCAmbm9fdmVyaWZ5LCBOXygiYnlwYXNzIHByZS1jb21taXQgaG9vayIpKSwKCQlPUFRfQk9PTEVBTigwLCAiZHJ5LXJ1biIsICZkcnlfcnVuLCBOXygic2hvdyB3aGF0IHdvdWxkIGJlIGNvbW1pdHRlZCIpKSwKCQlPUFRfU0VUX0lOVCgwLCAic2hvcnQiLCAmc3RhdHVzX2Zvcm1hdCwgTl8oInNob3cgc3RhdHVzIGNvbmNpc2VseSIpLAoJCQkgICAgU1RBVFVTX0ZPUk1BVF9TSE9SVCksCgkJT1BUX0JPT0woMCwgImJyYW5jaCIsICZzLnNob3dfYnJhbmNoLCBOXygic2hvdyBicmFuY2ggaW5mb3JtYXRpb24iKSksCgkJT1BUX1NFVF9JTlQoMCwgInBvcmNlbGFpbiIsICZzdGF0dXNfZm9ybWF0LAoJCQkgICAgTl8oIm1hY2hpbmUtcmVhZGFibGUgb3V0cHV0IiksIFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOKSwKCQlPUFRfU0VUX0lOVCgwLCAibG9uZyIsICZzdGF0dXNfZm9ybWF0LAoJCQkgICAgTl8oInNob3cgc3RhdHVzIGluIGxvbmcgZm9ybWF0IChkZWZhdWx0KSIpLAoJCQkgICAgU1RBVFVTX0ZPUk1BVF9MT05HKSwKCQlPUFRfQk9PTEVBTigneicsICJudWxsIiwgJnMubnVsbF90ZXJtaW5hdGlvbiwKCQkJICAgIE5fKCJ0ZXJtaW5hdGUgZW50cmllcyB3aXRoIE5VTCIpKSwKCQlPUFRfQk9PTEVBTigwLCAiYW1lbmQiLCAmYW1lbmQsIE5fKCJhbWVuZCBwcmV2aW91cyBjb21taXQiKSksCgkJT1BUX0JPT0xFQU4oMCwgIm5vLXBvc3QtcmV3cml0ZSIsICZub19wb3N0X3Jld3JpdGUsIE5fKCJieXBhc3MgcG9zdC1yZXdyaXRlIGhvb2siKSksCgkJeyBPUFRJT05fU1RSSU5HLCAndScsICJ1bnRyYWNrZWQtZmlsZXMiLCAmdW50cmFja2VkX2ZpbGVzX2FyZywgTl8oIm1vZGUiKSwgTl8oInNob3cgdW50cmFja2VkIGZpbGVzLCBvcHRpb25hbCBtb2RlczogYWxsLCBub3JtYWwsIG5vLiAoRGVmYXVsdDogYWxsKSIpLCBQQVJTRV9PUFRfT1BUQVJHLCBOVUxMLCAoaW50cHRyX3QpImFsbCIgfSwKCQkvKiBlbmQgY29tbWl0IGNvbnRlbnRzIG9wdGlvbnMgKi8KCgkJeyBPUFRJT05fQk9PTEVBTiwgMCwgImFsbG93LWVtcHR5IiwgJmFsbG93X2VtcHR5LCBOVUxMLAoJCSAgTl8oIm9rIHRvIHJlY29yZCBhbiBlbXB0eSBjaGFuZ2UiKSwKCQkgIFBBUlNFX09QVF9OT0FSRyB8IFBBUlNFX09QVF9ISURERU4gfSwKCQl7IE9QVElPTl9CT09MRUFOLCAwLCAiYWxsb3ctZW1wdHktbWVzc2FnZSIsICZhbGxvd19lbXB0eV9tZXNzYWdlLCBOVUxMLAoJCSAgTl8oIm9rIHRvIHJlY29yZCBhIGNoYW5nZSB3aXRoIGFuIGVtcHR5IG1lc3NhZ2UiKSwKCQkgIFBBUlNFX09QVF9OT0FSRyB8IFBBUlNFX09QVF9ISURERU4gfSwKCgkJT1BUX0VORCgpCgl9OwoKCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgYXV0aG9yX2lkZW50ID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICppbmRleF9maWxlLCAqcmVmbG9nX21zZzsKCWNoYXIgKm5sLCAqcDsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CglzdHJ1Y3QgcmVmX2xvY2sgKnJlZl9sb2NrOwoJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzID0gTlVMTCwgKipwcHRyID0gJnBhcmVudHM7CglzdHJ1Y3Qgc3RhdCBzdGF0YnVmOwoJaW50IGFsbG93X2Zhc3RfZm9yd2FyZCA9IDE7CglzdHJ1Y3QgY29tbWl0ICpjdXJyZW50X2hlYWQgPSBOVUxMOwoJc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKmV4dHJhID0gTlVMTDsKCglpZiAoYXJnYyA9PSAyICYmICFzdHJjbXAoYXJndlsxXSwgIi1oIikpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGJ1aWx0aW5fY29tbWl0X3VzYWdlLCBidWlsdGluX2NvbW1pdF9vcHRpb25zKTsKCgl3dF9zdGF0dXNfcHJlcGFyZSgmcyk7CglnaXRtb2R1bGVzX2NvbmZpZygpOwoJZ2l0X2NvbmZpZyhnaXRfY29tbWl0X2NvbmZpZywgJnMpOwoJc3RhdHVzX2Zvcm1hdCA9IFNUQVRVU19GT1JNQVRfTk9ORTsgLyogSWdub3JlIHN0YXR1cy5zaG9ydCAqLwoJZGV0ZXJtaW5lX3doZW5jZSgmcyk7CglzLmNvbG9wdHMgPSAwOwoKCWlmIChnZXRfc2hhMSgiSEVBRCIsIHNoYTEpKQoJCWN1cnJlbnRfaGVhZCA9IE5VTEw7CgllbHNlIHsKCQljdXJyZW50X2hlYWQgPSBsb29rdXBfY29tbWl0X29yX2RpZShzaGExLCAiSEVBRCIpOwoJCWlmICghY3VycmVudF9oZWFkIHx8IHBhcnNlX2NvbW1pdChjdXJyZW50X2hlYWQpKQoJCQlkaWUoXygiY291bGQgbm90IHBhcnNlIEhFQUQgY29tbWl0IikpOwoJfQoJYXJnYyA9IHBhcnNlX2FuZF92YWxpZGF0ZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIGJ1aWx0aW5fY29tbWl0X29wdGlvbnMsCgkJCQkJICBidWlsdGluX2NvbW1pdF91c2FnZSwKCQkJCQkgIHByZWZpeCwgY3VycmVudF9oZWFkLCAmcyk7CglpZiAoZHJ5X3J1bikKCQlyZXR1cm4gZHJ5X3J1bl9jb21taXQoYXJnYywgYXJndiwgcHJlZml4LCBjdXJyZW50X2hlYWQsICZzKTsKCWluZGV4X2ZpbGUgPSBwcmVwYXJlX2luZGV4KGFyZ2MsIGFyZ3YsIHByZWZpeCwgY3VycmVudF9oZWFkLCAwKTsKCgkvKiBTZXQgdXAgZXZlcnl0aGluZyBmb3Igd3JpdGluZyB0aGUgY29tbWl0IG9iamVjdC4gIFRoaXMgaW5jbHVkZXMKCSAgIHJ1bm5pbmcgaG9va3MsIHdyaXRpbmcgdGhlIHRyZWVzLCBhbmQgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdXNlci4gICovCglpZiAoIXByZXBhcmVfdG9fY29tbWl0KGluZGV4X2ZpbGUsIHByZWZpeCwKCQkJICAgICAgIGN1cnJlbnRfaGVhZCwgJnMsICZhdXRob3JfaWRlbnQpKSB7CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlyZXR1cm4gMTsKCX0KCgkvKiBEZXRlcm1pbmUgcGFyZW50cyAqLwoJcmVmbG9nX21zZyA9IGdldGVudigiR0lUX1JFRkxPR19BQ1RJT04iKTsKCWlmICghY3VycmVudF9oZWFkKSB7CgkJaWYgKCFyZWZsb2dfbXNnKQoJCQlyZWZsb2dfbXNnID0gImNvbW1pdCAoaW5pdGlhbCkiOwoJfSBlbHNlIGlmIChhbWVuZCkgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqYzsKCgkJaWYgKCFyZWZsb2dfbXNnKQoJCQlyZWZsb2dfbXNnID0gImNvbW1pdCAoYW1lbmQpIjsKCQlmb3IgKGMgPSBjdXJyZW50X2hlYWQtPnBhcmVudHM7IGM7IGMgPSBjLT5uZXh0KQoJCQlwcHRyID0gJmNvbW1pdF9saXN0X2luc2VydChjLT5pdGVtLCBwcHRyKS0+bmV4dDsKCX0gZWxzZSBpZiAod2hlbmNlID09IEZST01fTUVSR0UpIHsKCQlzdHJ1Y3Qgc3RyYnVmIG0gPSBTVFJCVUZfSU5JVDsKCQlGSUxFICpmcDsKCgkJaWYgKCFyZWZsb2dfbXNnKQoJCQlyZWZsb2dfbXNnID0gImNvbW1pdCAobWVyZ2UpIjsKCQlwcHRyID0gJmNvbW1pdF9saXN0X2luc2VydChjdXJyZW50X2hlYWQsIHBwdHIpLT5uZXh0OwoJCWZwID0gZm9wZW4oZ2l0X3BhdGgoIk1FUkdFX0hFQUQiKSwgInIiKTsKCQlpZiAoZnAgPT0gTlVMTCkKCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCBvcGVuICclcycgZm9yIHJlYWRpbmciKSwKCQkJCSAgZ2l0X3BhdGgoIk1FUkdFX0hFQUQiKSk7CgkJd2hpbGUgKHN0cmJ1Zl9nZXRsaW5lKCZtLCBmcCwgJ1xuJykgIT0gRU9GKSB7CgkJCXN0cnVjdCBjb21taXQgKnBhcmVudDsKCgkJCXBhcmVudCA9IGdldF9tZXJnZV9wYXJlbnQobS5idWYpOwoJCQlpZiAoIXBhcmVudCkKCQkJCWRpZShfKCJDb3JydXB0IE1FUkdFX0hFQUQgZmlsZSAoJXMpIiksIG0uYnVmKTsKCQkJcHB0ciA9ICZjb21taXRfbGlzdF9pbnNlcnQocGFyZW50LCBwcHRyKS0+bmV4dDsKCQl9CgkJZmNsb3NlKGZwKTsKCQlzdHJidWZfcmVsZWFzZSgmbSk7CgkJaWYgKCFzdGF0KGdpdF9wYXRoKCJNRVJHRV9NT0RFIiksICZzdGF0YnVmKSkgewoJCQlpZiAoc3RyYnVmX3JlYWRfZmlsZSgmc2IsIGdpdF9wYXRoKCJNRVJHRV9NT0RFIiksIDApIDwgMCkKCQkJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgcmVhZCBNRVJHRV9NT0RFIikpOwoJCQlpZiAoIXN0cmNtcChzYi5idWYsICJuby1mZiIpKQoJCQkJYWxsb3dfZmFzdF9mb3J3YXJkID0gMDsKCQl9CgkJaWYgKGFsbG93X2Zhc3RfZm9yd2FyZCkKCQkJcGFyZW50cyA9IHJlZHVjZV9oZWFkcyhwYXJlbnRzKTsKCX0gZWxzZSB7CgkJaWYgKCFyZWZsb2dfbXNnKQoJCQlyZWZsb2dfbXNnID0gKHdoZW5jZSA9PSBGUk9NX0NIRVJSWV9QSUNLKQoJCQkJCT8gImNvbW1pdCAoY2hlcnJ5LXBpY2spIgoJCQkJCTogImNvbW1pdCI7CgkJcHB0ciA9ICZjb21taXRfbGlzdF9pbnNlcnQoY3VycmVudF9oZWFkLCBwcHRyKS0+bmV4dDsKCX0KCgkvKiBGaW5hbGx5LCBnZXQgdGhlIGNvbW1pdCBtZXNzYWdlICovCglzdHJidWZfcmVzZXQoJnNiKTsKCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgZ2l0X3BhdGgoY29tbWl0X2VkaXRtc2cpLCAwKSA8IDApIHsKCQlpbnQgc2F2ZWRfZXJybm8gPSBlcnJubzsKCQlyb2xsYmFja19pbmRleF9maWxlcygpOwoJCWRpZShfKCJjb3VsZCBub3QgcmVhZCBjb21taXQgbWVzc2FnZTogJXMiKSwgc3RyZXJyb3Ioc2F2ZWRfZXJybm8pKTsKCX0KCgkvKiBUcnVuY2F0ZSB0aGUgbWVzc2FnZSBqdXN0IGJlZm9yZSB0aGUgZGlmZiwgaWYgYW55LiAqLwoJaWYgKHZlcmJvc2UpIHsKCQlwID0gc3Ryc3RyKHNiLmJ1ZiwgIlxuZGlmZiAtLWdpdCAiKTsKCQlpZiAocCAhPSBOVUxMKQoJCQlzdHJidWZfc2V0bGVuKCZzYiwgcCAtIHNiLmJ1ZiArIDEpOwoJfQoKCWlmIChjbGVhbnVwX21vZGUgIT0gQ0xFQU5VUF9OT05FKQoJCXN0cmlwc3BhY2UoJnNiLCBjbGVhbnVwX21vZGUgPT0gQ0xFQU5VUF9BTEwpOwoJaWYgKHRlbXBsYXRlX3VudG91Y2hlZCgmc2IpICYmICFhbGxvd19lbXB0eV9tZXNzYWdlKSB7CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlmcHJpbnRmKHN0ZGVyciwgXygiQWJvcnRpbmcgY29tbWl0OyB5b3UgZGlkIG5vdCBlZGl0IHRoZSBtZXNzYWdlLlxuIikpOwoJCWV4aXQoMSk7Cgl9CglpZiAobWVzc2FnZV9pc19lbXB0eSgmc2IpICYmICFhbGxvd19lbXB0eV9tZXNzYWdlKSB7CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlmcHJpbnRmKHN0ZGVyciwgXygiQWJvcnRpbmcgY29tbWl0IGR1ZSB0byBlbXB0eSBjb21taXQgbWVzc2FnZS5cbiIpKTsKCQlleGl0KDEpOwoJfQoKCWlmIChhbWVuZCkgewoJCWNvbnN0IGNoYXIgKmV4Y2x1ZGVfZ3Bnc2lnWzJdID0geyAiZ3Bnc2lnIiwgTlVMTCB9OwoJCWV4dHJhID0gcmVhZF9jb21taXRfZXh0cmFfaGVhZGVycyhjdXJyZW50X2hlYWQsIGV4Y2x1ZGVfZ3Bnc2lnKTsKCX0gZWxzZSB7CgkJc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKip0YWlsID0gJmV4dHJhOwoJCWFwcGVuZF9tZXJnZV90YWdfaGVhZGVycyhwYXJlbnRzLCAmdGFpbCk7Cgl9CgoJaWYgKGNvbW1pdF90cmVlX2V4dGVuZGVkKCZzYiwgYWN0aXZlX2NhY2hlX3RyZWUtPnNoYTEsIHBhcmVudHMsIHNoYTEsCgkJCQkgYXV0aG9yX2lkZW50LmJ1Ziwgc2lnbl9jb21taXQsIGV4dHJhKSkgewoJCXJvbGxiYWNrX2luZGV4X2ZpbGVzKCk7CgkJZGllKF8oImZhaWxlZCB0byB3cml0ZSBjb21taXQgb2JqZWN0IikpOwoJfQoJc3RyYnVmX3JlbGVhc2UoJmF1dGhvcl9pZGVudCk7CglmcmVlX2NvbW1pdF9leHRyYV9oZWFkZXJzKGV4dHJhKTsKCglyZWZfbG9jayA9IGxvY2tfYW55X3JlZl9mb3JfdXBkYXRlKCJIRUFEIiwKCQkJCQkgICAhY3VycmVudF9oZWFkCgkJCQkJICAgPyBOVUxMCgkJCQkJICAgOiBjdXJyZW50X2hlYWQtPm9iamVjdC5zaGExLAoJCQkJCSAgIDApOwoKCW5sID0gc3RyY2hyKHNiLmJ1ZiwgJ1xuJyk7CglpZiAobmwpCgkJc3RyYnVmX3NldGxlbigmc2IsIG5sICsgMSAtIHNiLmJ1Zik7CgllbHNlCgkJc3RyYnVmX2FkZGNoKCZzYiwgJ1xuJyk7CglzdHJidWZfaW5zZXJ0KCZzYiwgMCwgcmVmbG9nX21zZywgc3RybGVuKHJlZmxvZ19tc2cpKTsKCXN0cmJ1Zl9pbnNlcnQoJnNiLCBzdHJsZW4ocmVmbG9nX21zZyksICI6ICIsIDIpOwoKCWlmICghcmVmX2xvY2spIHsKCQlyb2xsYmFja19pbmRleF9maWxlcygpOwoJCWRpZShfKCJjYW5ub3QgbG9jayBIRUFEIHJlZiIpKTsKCX0KCWlmICh3cml0ZV9yZWZfc2hhMShyZWZfbG9jaywgc2hhMSwgc2IuYnVmKSA8IDApIHsKCQlyb2xsYmFja19pbmRleF9maWxlcygpOwoJCWRpZShfKCJjYW5ub3QgdXBkYXRlIEhFQUQgcmVmIikpOwoJfQoKCXVubGluayhnaXRfcGF0aCgiQ0hFUlJZX1BJQ0tfSEVBRCIpKTsKCXVubGluayhnaXRfcGF0aCgiUkVWRVJUX0hFQUQiKSk7Cgl1bmxpbmsoZ2l0X3BhdGgoIk1FUkdFX0hFQUQiKSk7Cgl1bmxpbmsoZ2l0X3BhdGgoIk1FUkdFX01TRyIpKTsKCXVubGluayhnaXRfcGF0aCgiTUVSR0VfTU9ERSIpKTsKCXVubGluayhnaXRfcGF0aCgiU1FVQVNIX01TRyIpKTsKCglpZiAoY29tbWl0X2luZGV4X2ZpbGVzKCkpCgkJZGllIChfKCJSZXBvc2l0b3J5IGhhcyBiZWVuIHVwZGF0ZWQsIGJ1dCB1bmFibGUgdG8gd3JpdGVcbiIKCQkgICAgICJuZXdfaW5kZXggZmlsZS4gQ2hlY2sgdGhhdCBkaXNrIGlzIG5vdCBmdWxsIG9yIHF1b3RhIGlzXG4iCgkJICAgICAibm90IGV4Y2VlZGVkLCBhbmQgdGhlbiBcImdpdCByZXNldCBIRUFEXCIgdG8gcmVjb3Zlci4iKSk7CgoJcmVyZXJlKDApOwoJcnVuX2hvb2soZ2V0X2luZGV4X2ZpbGUoKSwgInBvc3QtY29tbWl0IiwgTlVMTCk7CglpZiAoYW1lbmQgJiYgIW5vX3Bvc3RfcmV3cml0ZSkgewoJCXN0cnVjdCBub3Rlc19yZXdyaXRlX2NmZyAqY2ZnOwoJCWNmZyA9IGluaXRfY29weV9ub3Rlc19mb3JfcmV3cml0ZSgiYW1lbmQiKTsKCQlpZiAoY2ZnKSB7CgkJCS8qIHdlIGFyZSBhbWVuZGluZywgc28gY3VycmVudF9oZWFkIGlzIG5vdCBOVUxMICovCgkJCWNvcHlfbm90ZV9mb3JfcmV3cml0ZShjZmcsIGN1cnJlbnRfaGVhZC0+b2JqZWN0LnNoYTEsIHNoYTEpOwoJCQlmaW5pc2hfY29weV9ub3Rlc19mb3JfcmV3cml0ZShjZmcsICJOb3RlcyBhZGRlZCBieSAnZ2l0IGNvbW1pdCAtLWFtZW5kJyIpOwoJCX0KCQlydW5fcmV3cml0ZV9ob29rKGN1cnJlbnRfaGVhZC0+b2JqZWN0LnNoYTEsIHNoYTEpOwoJfQoJaWYgKCFxdWlldCkKCQlwcmludF9zdW1tYXJ5KHByZWZpeCwgc2hhMSwgIWN1cnJlbnRfaGVhZCk7CgoJcmV0dXJuIDA7Cn0K",
    "text": "/*\n * Builtin \"git commit\"\n *\n * Copyright (c) 2007 Kristian H\u00f8gsberg <krh@redhat.com>\n * Based on git-commit.sh by Junio C Hamano and Linus Torvalds\n */\n\n#include \"cache.h\"\n#include \"cache-tree.h\"\n#include \"color.h\"\n#include \"dir.h\"\n#include \"builtin.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"commit.h\"\n#include \"revision.h\"\n#include \"wt-status.h\"\n#include \"run-command.h\"\n#include \"refs.h\"\n#include \"log-tree.h\"\n#include \"strbuf.h\"\n#include \"utf8.h\"\n#include \"parse-options.h\"\n#include \"string-list.h\"\n#include \"rerere.h\"\n#include \"unpack-trees.h\"\n#include \"quote.h\"\n#include \"submodule.h\"\n#include \"gpg-interface.h\"\n#include \"column.h\"\n#include \"sequencer.h\"\n#include \"notes-utils.h\"\n\nstatic const char * const builtin_commit_usage[] = {\n\tN_(\"git commit [options] [--] <pathspec>...\"),\n\tNULL\n};\n\nstatic const char * const builtin_status_usage[] = {\n\tN_(\"git status [options] [--] <pathspec>...\"),\n\tNULL\n};\n\nstatic const char implicit_ident_advice[] =\nN_(\"Your name and email address were configured automatically based\\n\"\n\"on your username and hostname. Please check that they are accurate.\\n\"\n\"You can suppress this message by setting them explicitly:\\n\"\n\"\\n\"\n\"    git config --global user.name \\\"Your Name\\\"\\n\"\n\"    git config --global user.email you@example.com\\n\"\n\"\\n\"\n\"After doing this, you may fix the identity used for this commit with:\\n\"\n\"\\n\"\n\"    git commit --amend --reset-author\\n\");\n\nstatic const char empty_amend_advice[] =\nN_(\"You asked to amend the most recent commit, but doing so would make\\n\"\n\"it empty. You can repeat your command with --allow-empty, or you can\\n\"\n\"remove the commit entirely with \\\"git reset HEAD^\\\".\\n\");\n\nstatic const char empty_cherry_pick_advice[] =\nN_(\"The previous cherry-pick is now empty, possibly due to conflict resolution.\\n\"\n\"If you wish to commit it anyway, use:\\n\"\n\"\\n\"\n\"    git commit --allow-empty\\n\"\n\"\\n\"\n\"Otherwise, please use 'git reset'\\n\");\n\nstatic const char *use_message_buffer;\nstatic const char commit_editmsg[] = \"COMMIT_EDITMSG\";\nstatic struct lock_file index_lock; /* real index */\nstatic struct lock_file false_lock; /* used only for partial commits */\nstatic enum {\n\tCOMMIT_AS_IS = 1,\n\tCOMMIT_NORMAL,\n\tCOMMIT_PARTIAL\n} commit_style;\n\nstatic const char *logfile, *force_author;\nstatic const char *template_file;\n/*\n * The _message variables are commit names from which to take\n * the commit message and/or authorship.\n */\nstatic const char *author_message, *author_message_buffer;\nstatic char *edit_message, *use_message;\nstatic char *fixup_message, *squash_message;\nstatic int all, also, interactive, patch_interactive, only, amend, signoff;\nstatic int edit_flag = -1; /* unspecified */\nstatic int quiet, verbose, no_verify, allow_empty, dry_run, renew_authorship;\nstatic int no_post_rewrite, allow_empty_message;\nstatic char *untracked_files_arg, *force_date, *ignore_submodule_arg;\nstatic char *sign_commit;\n\n/*\n * The default commit message cleanup mode will remove the lines\n * beginning with # (shell comments) and leading and trailing\n * whitespaces (empty lines or containing only whitespaces)\n * if editor is used, and only the whitespaces if the message\n * is specified explicitly.\n */\nstatic enum {\n\tCLEANUP_SPACE,\n\tCLEANUP_NONE,\n\tCLEANUP_ALL\n} cleanup_mode;\nstatic const char *cleanup_arg;\n\nstatic enum commit_whence whence;\nstatic int use_editor = 1, include_status = 1;\nstatic int show_ignored_in_status, have_option_m;\nstatic const char *only_include_assumed;\nstatic struct strbuf message = STRBUF_INIT;\n\nstatic enum status_format {\n\tSTATUS_FORMAT_NONE = 0,\n\tSTATUS_FORMAT_LONG,\n\tSTATUS_FORMAT_SHORT,\n\tSTATUS_FORMAT_PORCELAIN,\n\n\tSTATUS_FORMAT_UNSPECIFIED\n} status_format = STATUS_FORMAT_UNSPECIFIED;\n\nstatic int opt_parse_m(const struct option *opt, const char *arg, int unset)\n{\n\tstruct strbuf *buf = opt->value;\n\tif (unset) {\n\t\thave_option_m = 0;\n\t\tstrbuf_setlen(buf, 0);\n\t} else {\n\t\thave_option_m = 1;\n\t\tif (buf->len)\n\t\t\tstrbuf_addch(buf, '\\n');\n\t\tstrbuf_addstr(buf, arg);\n\t\tstrbuf_complete_line(buf);\n\t}\n\treturn 0;\n}\n\nstatic void determine_whence(struct wt_status *s)\n{\n\tif (file_exists(git_path(\"MERGE_HEAD\")))\n\t\twhence = FROM_MERGE;\n\telse if (file_exists(git_path(\"CHERRY_PICK_HEAD\")))\n\t\twhence = FROM_CHERRY_PICK;\n\telse\n\t\twhence = FROM_COMMIT;\n\tif (s)\n\t\ts->whence = whence;\n}\n\nstatic void rollback_index_files(void)\n{\n\tswitch (commit_style) {\n\tcase COMMIT_AS_IS:\n\t\tbreak; /* nothing to do */\n\tcase COMMIT_NORMAL:\n\t\trollback_lock_file(&index_lock);\n\t\tbreak;\n\tcase COMMIT_PARTIAL:\n\t\trollback_lock_file(&index_lock);\n\t\trollback_lock_file(&false_lock);\n\t\tbreak;\n\t}\n}\n\nstatic int commit_index_files(void)\n{\n\tint err = 0;\n\n\tswitch (commit_style) {\n\tcase COMMIT_AS_IS:\n\t\tbreak; /* nothing to do */\n\tcase COMMIT_NORMAL:\n\t\terr = commit_lock_file(&index_lock);\n\t\tbreak;\n\tcase COMMIT_PARTIAL:\n\t\terr = commit_lock_file(&index_lock);\n\t\trollback_lock_file(&false_lock);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/*\n * Take a union of paths in the index and the named tree (typically, \"HEAD\"),\n * and return the paths that match the given pattern in list.\n */\nstatic int list_paths(struct string_list *list, const char *with_tree,\n\t\t      const char *prefix, const char **pattern)\n{\n\tint i;\n\tchar *m;\n\n\tif (!pattern)\n\t\treturn 0;\n\n\tfor (i = 0; pattern[i]; i++)\n\t\t;\n\tm = xcalloc(1, i);\n\n\tif (with_tree) {\n\t\tchar *max_prefix = common_prefix(pattern);\n\t\toverlay_tree_on_cache(with_tree, max_prefix ? max_prefix : prefix);\n\t\tfree(max_prefix);\n\t}\n\n\tfor (i = 0; i < active_nr; i++) {\n\t\tconst struct cache_entry *ce = active_cache[i];\n\t\tstruct string_list_item *item;\n\n\t\tif (ce->ce_flags & CE_UPDATE)\n\t\t\tcontinue;\n\t\tif (!match_pathspec(pattern, ce->name, ce_namelen(ce), 0, m))\n\t\t\tcontinue;\n\t\titem = string_list_insert(list, ce->name);\n\t\tif (ce_skip_worktree(ce))\n\t\t\titem->util = item; /* better a valid pointer than a fake one */\n\t}\n\n\treturn report_path_error(m, pattern, prefix);\n}\n\nstatic void add_remove_files(struct string_list *list)\n{\n\tint i;\n\tfor (i = 0; i < list->nr; i++) {\n\t\tstruct stat st;\n\t\tstruct string_list_item *p = &(list->items[i]);\n\n\t\t/* p->util is skip-worktree */\n\t\tif (p->util)\n\t\t\tcontinue;\n\n\t\tif (!lstat(p->string, &st)) {\n\t\t\tif (add_to_cache(p->string, &st, 0))\n\t\t\t\tdie(_(\"updating files failed\"));\n\t\t} else\n\t\t\tremove_file_from_cache(p->string);\n\t}\n}\n\nstatic void create_base_index(const struct commit *current_head)\n{\n\tstruct tree *tree;\n\tstruct unpack_trees_options opts;\n\tstruct tree_desc t;\n\n\tif (!current_head) {\n\t\tdiscard_cache();\n\t\treturn;\n\t}\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.head_idx = 1;\n\topts.index_only = 1;\n\topts.merge = 1;\n\topts.src_index = &the_index;\n\topts.dst_index = &the_index;\n\n\topts.fn = oneway_merge;\n\ttree = parse_tree_indirect(current_head->object.sha1);\n\tif (!tree)\n\t\tdie(_(\"failed to unpack HEAD tree object\"));\n\tparse_tree(tree);\n\tinit_tree_desc(&t, tree->buffer, tree->size);\n\tif (unpack_trees(1, &t, &opts))\n\t\texit(128); /* We've already reported the error, finish dying */\n}\n\nstatic void refresh_cache_or_die(int refresh_flags)\n{\n\t/*\n\t * refresh_flags contains REFRESH_QUIET, so the only errors\n\t * are for unmerged entries.\n\t */\n\tif (refresh_cache(refresh_flags | REFRESH_IN_PORCELAIN))\n\t\tdie_resolve_conflict(\"commit\");\n}\n\nstatic char *prepare_index(int argc, const char **argv, const char *prefix,\n\t\t\t   const struct commit *current_head, int is_status)\n{\n\tint fd;\n\tstruct string_list partial;\n\tconst char **pathspec = NULL;\n\tchar *old_index_env = NULL;\n\tint refresh_flags = REFRESH_QUIET;\n\n\tif (is_status)\n\t\trefresh_flags |= REFRESH_UNMERGED;\n\n\tif (*argv)\n\t\tpathspec = get_pathspec(prefix, argv);\n\n\tif (read_cache_preload(pathspec) < 0)\n\t\tdie(_(\"index file corrupt\"));\n\n\tif (interactive) {\n\t\tfd = hold_locked_index(&index_lock, 1);\n\n\t\trefresh_cache_or_die(refresh_flags);\n\n\t\tif (write_cache(fd, active_cache, active_nr) ||\n\t\t    close_lock_file(&index_lock))\n\t\t\tdie(_(\"unable to create temporary index\"));\n\n\t\told_index_env = getenv(INDEX_ENVIRONMENT);\n\t\tsetenv(INDEX_ENVIRONMENT, index_lock.filename, 1);\n\n\t\tif (interactive_add(argc, argv, prefix, patch_interactive) != 0)\n\t\t\tdie(_(\"interactive add failed\"));\n\n\t\tif (old_index_env && *old_index_env)\n\t\t\tsetenv(INDEX_ENVIRONMENT, old_index_env, 1);\n\t\telse\n\t\t\tunsetenv(INDEX_ENVIRONMENT);\n\n\t\tdiscard_cache();\n\t\tread_cache_from(index_lock.filename);\n\n\t\tcommit_style = COMMIT_NORMAL;\n\t\treturn index_lock.filename;\n\t}\n\n\t/*\n\t * Non partial, non as-is commit.\n\t *\n\t * (1) get the real index;\n\t * (2) update the_index as necessary;\n\t * (3) write the_index out to the real index (still locked);\n\t * (4) return the name of the locked index file.\n\t *\n\t * The caller should run hooks on the locked real index, and\n\t * (A) if all goes well, commit the real index;\n\t * (B) on failure, rollback the real index.\n\t */\n\tif (all || (also && pathspec && *pathspec)) {\n\t\tfd = hold_locked_index(&index_lock, 1);\n\t\tadd_files_to_cache(also ? prefix : NULL, pathspec, 0);\n\t\trefresh_cache_or_die(refresh_flags);\n\t\tupdate_main_cache_tree(WRITE_TREE_SILENT);\n\t\tif (write_cache(fd, active_cache, active_nr) ||\n\t\t    close_lock_file(&index_lock))\n\t\t\tdie(_(\"unable to write new_index file\"));\n\t\tcommit_style = COMMIT_NORMAL;\n\t\treturn index_lock.filename;\n\t}\n\n\t/*\n\t * As-is commit.\n\t *\n\t * (1) return the name of the real index file.\n\t *\n\t * The caller should run hooks on the real index,\n\t * and create commit from the_index.\n\t * We still need to refresh the index here.\n\t */\n\tif (!only && (!pathspec || !*pathspec)) {\n\t\tfd = hold_locked_index(&index_lock, 1);\n\t\trefresh_cache_or_die(refresh_flags);\n\t\tif (active_cache_changed) {\n\t\t\tupdate_main_cache_tree(WRITE_TREE_SILENT);\n\t\t\tif (write_cache(fd, active_cache, active_nr) ||\n\t\t\t    commit_locked_index(&index_lock))\n\t\t\t\tdie(_(\"unable to write new_index file\"));\n\t\t} else {\n\t\t\trollback_lock_file(&index_lock);\n\t\t}\n\t\tcommit_style = COMMIT_AS_IS;\n\t\treturn get_index_file();\n\t}\n\n\t/*\n\t * A partial commit.\n\t *\n\t * (0) find the set of affected paths;\n\t * (1) get lock on the real index file;\n\t * (2) update the_index with the given paths;\n\t * (3) write the_index out to the real index (still locked);\n\t * (4) get lock on the false index file;\n\t * (5) reset the_index from HEAD;\n\t * (6) update the_index the same way as (2);\n\t * (7) write the_index out to the false index file;\n\t * (8) return the name of the false index file (still locked);\n\t *\n\t * The caller should run hooks on the locked false index, and\n\t * create commit from it.  Then\n\t * (A) if all goes well, commit the real index;\n\t * (B) on failure, rollback the real index;\n\t * In either case, rollback the false index.\n\t */\n\tcommit_style = COMMIT_PARTIAL;\n\n\tif (whence != FROM_COMMIT) {\n\t\tif (whence == FROM_MERGE)\n\t\t\tdie(_(\"cannot do a partial commit during a merge.\"));\n\t\telse if (whence == FROM_CHERRY_PICK)\n\t\t\tdie(_(\"cannot do a partial commit during a cherry-pick.\"));\n\t}\n\n\tmemset(&partial, 0, sizeof(partial));\n\tpartial.strdup_strings = 1;\n\tif (list_paths(&partial, !current_head ? NULL : \"HEAD\", prefix, pathspec))\n\t\texit(1);\n\n\tdiscard_cache();\n\tif (read_cache() < 0)\n\t\tdie(_(\"cannot read the index\"));\n\n\tfd = hold_locked_index(&index_lock, 1);\n\tadd_remove_files(&partial);\n\trefresh_cache(REFRESH_QUIET);\n\tif (write_cache(fd, active_cache, active_nr) ||\n\t    close_lock_file(&index_lock))\n\t\tdie(_(\"unable to write new_index file\"));\n\n\tfd = hold_lock_file_for_update(&false_lock,\n\t\t\t\t       git_path(\"next-index-%\"PRIuMAX,\n\t\t\t\t\t\t(uintmax_t) getpid()),\n\t\t\t\t       LOCK_DIE_ON_ERROR);\n\n\tcreate_base_index(current_head);\n\tadd_remove_files(&partial);\n\trefresh_cache(REFRESH_QUIET);\n\n\tif (write_cache(fd, active_cache, active_nr) ||\n\t    close_lock_file(&false_lock))\n\t\tdie(_(\"unable to write temporary index file\"));\n\n\tdiscard_cache();\n\tread_cache_from(false_lock.filename);\n\n\treturn false_lock.filename;\n}\n\nstatic int run_status(FILE *fp, const char *index_file, const char *prefix, int nowarn,\n\t\t      struct wt_status *s)\n{\n\tunsigned char sha1[20];\n\n\tif (s->relative_paths)\n\t\ts->prefix = prefix;\n\n\tif (amend) {\n\t\ts->amend = 1;\n\t\ts->reference = \"HEAD^1\";\n\t}\n\ts->verbose = verbose;\n\ts->index_file = index_file;\n\ts->fp = fp;\n\ts->nowarn = nowarn;\n\ts->is_initial = get_sha1(s->reference, sha1) ? 1 : 0;\n\n\twt_status_collect(s);\n\n\tswitch (status_format) {\n\tcase STATUS_FORMAT_SHORT:\n\t\twt_shortstatus_print(s);\n\t\tbreak;\n\tcase STATUS_FORMAT_PORCELAIN:\n\t\twt_porcelain_print(s);\n\t\tbreak;\n\tcase STATUS_FORMAT_UNSPECIFIED:\n\t\tdie(\"BUG: finalize_deferred_config() should have been called\");\n\t\tbreak;\n\tcase STATUS_FORMAT_NONE:\n\tcase STATUS_FORMAT_LONG:\n\t\twt_status_print(s);\n\t\tbreak;\n\t}\n\n\treturn s->commitable;\n}\n\nstatic int is_a_merge(const struct commit *current_head)\n{\n\treturn !!(current_head->parents && current_head->parents->next);\n}\n\nstatic void export_one(const char *var, const char *s, const char *e, int hack)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tif (hack)\n\t\tstrbuf_addch(&buf, hack);\n\tstrbuf_addf(&buf, \"%.*s\", (int)(e - s), s);\n\tsetenv(var, buf.buf, 1);\n\tstrbuf_release(&buf);\n}\n\nstatic int sane_ident_split(struct ident_split *person)\n{\n\tif (!person->name_begin || !person->name_end ||\n\t    person->name_begin == person->name_end)\n\t\treturn 0; /* no human readable name */\n\tif (!person->mail_begin || !person->mail_end ||\n\t    person->mail_begin == person->mail_end)\n\t\treturn 0; /* no usable mail */\n\tif (!person->date_begin || !person->date_end ||\n\t    !person->tz_begin || !person->tz_end)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic void determine_author_info(struct strbuf *author_ident)\n{\n\tchar *name, *email, *date;\n\tstruct ident_split author;\n\n\tname = getenv(\"GIT_AUTHOR_NAME\");\n\temail = getenv(\"GIT_AUTHOR_EMAIL\");\n\tdate = getenv(\"GIT_AUTHOR_DATE\");\n\n\tif (author_message) {\n\t\tconst char *a, *lb, *rb, *eol;\n\t\tsize_t len;\n\n\t\ta = strstr(author_message_buffer, \"\\nauthor \");\n\t\tif (!a)\n\t\t\tdie(_(\"invalid commit: %s\"), author_message);\n\n\t\tlb = strchrnul(a + strlen(\"\\nauthor \"), '<');\n\t\trb = strchrnul(lb, '>');\n\t\teol = strchrnul(rb, '\\n');\n\t\tif (!*lb || !*rb || !*eol)\n\t\t\tdie(_(\"invalid commit: %s\"), author_message);\n\n\t\tif (lb == a + strlen(\"\\nauthor \"))\n\t\t\t/* \\nauthor <foo@example.com> */\n\t\t\tname = xcalloc(1, 1);\n\t\telse\n\t\t\tname = xmemdupz(a + strlen(\"\\nauthor \"),\n\t\t\t\t\t(lb - strlen(\" \") -\n\t\t\t\t\t (a + strlen(\"\\nauthor \"))));\n\t\temail = xmemdupz(lb + strlen(\"<\"), rb - (lb + strlen(\"<\")));\n\t\tlen = eol - (rb + strlen(\"> \"));\n\t\tdate = xmalloc(len + 2);\n\t\t*date = '@';\n\t\tmemcpy(date + 1, rb + strlen(\"> \"), len);\n\t\tdate[len + 1] = '\\0';\n\t}\n\n\tif (force_author) {\n\t\tconst char *lb = strstr(force_author, \" <\");\n\t\tconst char *rb = strchr(force_author, '>');\n\n\t\tif (!lb || !rb)\n\t\t\tdie(_(\"malformed --author parameter\"));\n\t\tname = xstrndup(force_author, lb - force_author);\n\t\temail = xstrndup(lb + 2, rb - (lb + 2));\n\t}\n\n\tif (force_date)\n\t\tdate = force_date;\n\tstrbuf_addstr(author_ident, fmt_ident(name, email, date, IDENT_STRICT));\n\tif (!split_ident_line(&author, author_ident->buf, author_ident->len) &&\n\t    sane_ident_split(&author)) {\n\t\texport_one(\"GIT_AUTHOR_NAME\", author.name_begin, author.name_end, 0);\n\t\texport_one(\"GIT_AUTHOR_EMAIL\", author.mail_begin, author.mail_end, 0);\n\t\texport_one(\"GIT_AUTHOR_DATE\", author.date_begin, author.tz_end, '@');\n\t}\n}\n\nstatic char *cut_ident_timestamp_part(char *string)\n{\n\tchar *ket = strrchr(string, '>');\n\tif (!ket || ket[1] != ' ')\n\t\tdie(_(\"Malformed ident string: '%s'\"), string);\n\t*++ket = '\\0';\n\treturn ket;\n}\n\nstatic int prepare_to_commit(const char *index_file, const char *prefix,\n\t\t\t     struct commit *current_head,\n\t\t\t     struct wt_status *s,\n\t\t\t     struct strbuf *author_ident)\n{\n\tstruct stat statbuf;\n\tstruct strbuf committer_ident = STRBUF_INIT;\n\tint commitable, saved_color_setting;\n\tstruct strbuf sb = STRBUF_INIT;\n\tchar *buffer;\n\tconst char *hook_arg1 = NULL;\n\tconst char *hook_arg2 = NULL;\n\tint ident_shown = 0;\n\tint clean_message_contents = (cleanup_mode != CLEANUP_NONE);\n\n\t/* This checks and barfs if author is badly specified */\n\tdetermine_author_info(author_ident);\n\n\tif (!no_verify && run_hook(index_file, \"pre-commit\", NULL))\n\t\treturn 0;\n\n\tif (squash_message) {\n\t\t/*\n\t\t * Insert the proper subject line before other commit\n\t\t * message options add their content.\n\t\t */\n\t\tif (use_message && !strcmp(use_message, squash_message))\n\t\t\tstrbuf_addstr(&sb, \"squash! \");\n\t\telse {\n\t\t\tstruct pretty_print_context ctx = {0};\n\t\t\tstruct commit *c;\n\t\t\tc = lookup_commit_reference_by_name(squash_message);\n\t\t\tif (!c)\n\t\t\t\tdie(_(\"could not lookup commit %s\"), squash_message);\n\t\t\tctx.output_encoding = get_commit_output_encoding();\n\t\t\tformat_commit_message(c, \"squash! %s\\n\\n\", &sb,\n\t\t\t\t\t      &ctx);\n\t\t}\n\t}\n\n\tif (message.len) {\n\t\tstrbuf_addbuf(&sb, &message);\n\t\thook_arg1 = \"message\";\n\t} else if (logfile && !strcmp(logfile, \"-\")) {\n\t\tif (isatty(0))\n\t\t\tfprintf(stderr, _(\"(reading log message from standard input)\\n\"));\n\t\tif (strbuf_read(&sb, 0, 0) < 0)\n\t\t\tdie_errno(_(\"could not read log from standard input\"));\n\t\thook_arg1 = \"message\";\n\t} else if (logfile) {\n\t\tif (strbuf_read_file(&sb, logfile, 0) < 0)\n\t\t\tdie_errno(_(\"could not read log file '%s'\"),\n\t\t\t\t  logfile);\n\t\thook_arg1 = \"message\";\n\t} else if (use_message) {\n\t\tbuffer = strstr(use_message_buffer, \"\\n\\n\");\n\t\tif (!use_editor && (!buffer || buffer[2] == '\\0'))\n\t\t\tdie(_(\"commit has empty message\"));\n\t\tstrbuf_add(&sb, buffer + 2, strlen(buffer + 2));\n\t\thook_arg1 = \"commit\";\n\t\thook_arg2 = use_message;\n\t} else if (fixup_message) {\n\t\tstruct pretty_print_context ctx = {0};\n\t\tstruct commit *commit;\n\t\tcommit = lookup_commit_reference_by_name(fixup_message);\n\t\tif (!commit)\n\t\t\tdie(_(\"could not lookup commit %s\"), fixup_message);\n\t\tctx.output_encoding = get_commit_output_encoding();\n\t\tformat_commit_message(commit, \"fixup! %s\\n\\n\",\n\t\t\t\t      &sb, &ctx);\n\t\thook_arg1 = \"message\";\n\t} else if (!stat(git_path(\"MERGE_MSG\"), &statbuf)) {\n\t\tif (strbuf_read_file(&sb, git_path(\"MERGE_MSG\"), 0) < 0)\n\t\t\tdie_errno(_(\"could not read MERGE_MSG\"));\n\t\thook_arg1 = \"merge\";\n\t} else if (!stat(git_path(\"SQUASH_MSG\"), &statbuf)) {\n\t\tif (strbuf_read_file(&sb, git_path(\"SQUASH_MSG\"), 0) < 0)\n\t\t\tdie_errno(_(\"could not read SQUASH_MSG\"));\n\t\thook_arg1 = \"squash\";\n\t} else if (template_file) {\n\t\tif (strbuf_read_file(&sb, template_file, 0) < 0)\n\t\t\tdie_errno(_(\"could not read '%s'\"), template_file);\n\t\thook_arg1 = \"template\";\n\t\tclean_message_contents = 0;\n\t}\n\n\t/*\n\t * The remaining cases don't modify the template message, but\n\t * just set the argument(s) to the prepare-commit-msg hook.\n\t */\n\telse if (whence == FROM_MERGE)\n\t\thook_arg1 = \"merge\";\n\telse if (whence == FROM_CHERRY_PICK) {\n\t\thook_arg1 = \"commit\";\n\t\thook_arg2 = \"CHERRY_PICK_HEAD\";\n\t}\n\n\tif (squash_message) {\n\t\t/*\n\t\t * If squash_commit was used for the commit subject,\n\t\t * then we're possibly hijacking other commit log options.\n\t\t * Reset the hook args to tell the real story.\n\t\t */\n\t\thook_arg1 = \"message\";\n\t\thook_arg2 = \"\";\n\t}\n\n\ts->fp = fopen(git_path(commit_editmsg), \"w\");\n\tif (s->fp == NULL)\n\t\tdie_errno(_(\"could not open '%s'\"), git_path(commit_editmsg));\n\n\tif (clean_message_contents)\n\t\tstripspace(&sb, 0);\n\n\tif (signoff) {\n\t\t/*\n\t\t * See if we have a Conflicts: block at the end. If yes, count\n\t\t * its size, so we can ignore it.\n\t\t */\n\t\tint ignore_footer = 0;\n\t\tint i, eol, previous = 0;\n\t\tconst char *nl;\n\n\t\tfor (i = 0; i < sb.len; i++) {\n\t\t\tnl = memchr(sb.buf + i, '\\n', sb.len - i);\n\t\t\tif (nl)\n\t\t\t\teol = nl - sb.buf;\n\t\t\telse\n\t\t\t\teol = sb.len;\n\t\t\tif (!prefixcmp(sb.buf + previous, \"\\nConflicts:\\n\")) {\n\t\t\t\tignore_footer = sb.len - previous;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (i < eol)\n\t\t\t\ti++;\n\t\t\tprevious = eol;\n\t\t}\n\n\t\tappend_signoff(&sb, ignore_footer, 0);\n\t}\n\n\tif (fwrite(sb.buf, 1, sb.len, s->fp) < sb.len)\n\t\tdie_errno(_(\"could not write commit template\"));\n\n\tstrbuf_release(&sb);\n\n\t/* This checks if committer ident is explicitly given */\n\tstrbuf_addstr(&committer_ident, git_committer_info(IDENT_STRICT));\n\tif (use_editor && include_status) {\n\t\tchar *ai_tmp, *ci_tmp;\n\t\tif (whence != FROM_COMMIT)\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t    whence == FROM_MERGE\n\t\t\t\t? _(\"\\n\"\n\t\t\t\t\t\"It looks like you may be committing a merge.\\n\"\n\t\t\t\t\t\"If this is not correct, please remove the file\\n\"\n\t\t\t\t\t\"\t%s\\n\"\n\t\t\t\t\t\"and try again.\\n\")\n\t\t\t\t: _(\"\\n\"\n\t\t\t\t\t\"It looks like you may be committing a cherry-pick.\\n\"\n\t\t\t\t\t\"If this is not correct, please remove the file\\n\"\n\t\t\t\t\t\"\t%s\\n\"\n\t\t\t\t\t\"and try again.\\n\"),\n\t\t\t\tgit_path(whence == FROM_MERGE\n\t\t\t\t\t ? \"MERGE_HEAD\"\n\t\t\t\t\t : \"CHERRY_PICK_HEAD\"));\n\n\t\tfprintf(s->fp, \"\\n\");\n\t\tif (cleanup_mode == CLEANUP_ALL)\n\t\t\tstatus_printf(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"Please enter the commit message for your changes.\"\n\t\t\t\t  \" Lines starting\\nwith '%c' will be ignored, and an empty\"\n\t\t\t\t  \" message aborts the commit.\\n\"), comment_line_char);\n\t\telse /* CLEANUP_SPACE, that is. */\n\t\t\tstatus_printf(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"Please enter the commit message for your changes.\"\n\t\t\t\t  \" Lines starting\\n\"\n\t\t\t\t  \"with '%c' will be kept; you may remove them\"\n\t\t\t\t  \" yourself if you want to.\\n\"\n\t\t\t\t  \"An empty message aborts the commit.\\n\"), comment_line_char);\n\t\tif (only_include_assumed)\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t\t\"%s\", only_include_assumed);\n\n\t\tai_tmp = cut_ident_timestamp_part(author_ident->buf);\n\t\tci_tmp = cut_ident_timestamp_part(committer_ident.buf);\n\t\tif (strcmp(author_ident->buf, committer_ident.buf))\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"%s\"\n\t\t\t\t\"Author:    %s\"),\n\t\t\t\tident_shown++ ? \"\" : \"\\n\",\n\t\t\t\tauthor_ident->buf);\n\n\t\tif (!committer_ident_sufficiently_given())\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"%s\"\n\t\t\t\t\"Committer: %s\"),\n\t\t\t\tident_shown++ ? \"\" : \"\\n\",\n\t\t\t\tcommitter_ident.buf);\n\n\t\tif (ident_shown)\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL, \"\");\n\n\t\tsaved_color_setting = s->use_color;\n\t\ts->use_color = 0;\n\t\tcommitable = run_status(s->fp, index_file, prefix, 1, s);\n\t\ts->use_color = saved_color_setting;\n\n\t\t*ai_tmp = ' ';\n\t\t*ci_tmp = ' ';\n\t} else {\n\t\tunsigned char sha1[20];\n\t\tconst char *parent = \"HEAD\";\n\n\t\tif (!active_nr && read_cache() < 0)\n\t\t\tdie(_(\"Cannot read index\"));\n\n\t\tif (amend)\n\t\t\tparent = \"HEAD^1\";\n\n\t\tif (get_sha1(parent, sha1))\n\t\t\tcommitable = !!active_nr;\n\t\telse\n\t\t\tcommitable = index_differs_from(parent, 0);\n\t}\n\tstrbuf_release(&committer_ident);\n\n\tfclose(s->fp);\n\n\t/*\n\t * Reject an attempt to record a non-merge empty commit without\n\t * explicit --allow-empty. In the cherry-pick case, it may be\n\t * empty due to conflict resolution, which the user should okay.\n\t */\n\tif (!commitable && whence != FROM_MERGE && !allow_empty &&\n\t    !(amend && is_a_merge(current_head))) {\n\t\trun_status(stdout, index_file, prefix, 0, s);\n\t\tif (amend)\n\t\t\tfputs(_(empty_amend_advice), stderr);\n\t\telse if (whence == FROM_CHERRY_PICK)\n\t\t\tfputs(_(empty_cherry_pick_advice), stderr);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Re-read the index as pre-commit hook could have updated it,\n\t * and write it out as a tree.  We must do this before we invoke\n\t * the editor and after we invoke run_status above.\n\t */\n\tdiscard_cache();\n\tread_cache_from(index_file);\n\tif (update_main_cache_tree(0)) {\n\t\terror(_(\"Error building trees\"));\n\t\treturn 0;\n\t}\n\n\tif (run_hook(index_file, \"prepare-commit-msg\",\n\t\t     git_path(commit_editmsg), hook_arg1, hook_arg2, NULL))\n\t\treturn 0;\n\n\tif (use_editor) {\n\t\tchar index[PATH_MAX];\n\t\tconst char *env[2] = { NULL };\n\t\tenv[0] =  index;\n\t\tsnprintf(index, sizeof(index), \"GIT_INDEX_FILE=%s\", index_file);\n\t\tif (launch_editor(git_path(commit_editmsg), NULL, env)) {\n\t\t\tfprintf(stderr,\n\t\t\t_(\"Please supply the message using either -m or -F option.\\n\"));\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (!no_verify &&\n\t    run_hook(index_file, \"commit-msg\", git_path(commit_editmsg), NULL)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int rest_is_empty(struct strbuf *sb, int start)\n{\n\tint i, eol;\n\tconst char *nl;\n\n\t/* Check if the rest is just whitespace and Signed-of-by's. */\n\tfor (i = start; i < sb->len; i++) {\n\t\tnl = memchr(sb->buf + i, '\\n', sb->len - i);\n\t\tif (nl)\n\t\t\teol = nl - sb->buf;\n\t\telse\n\t\t\teol = sb->len;\n\n\t\tif (strlen(sign_off_header) <= eol - i &&\n\t\t    !prefixcmp(sb->buf + i, sign_off_header)) {\n\t\t\ti = eol;\n\t\t\tcontinue;\n\t\t}\n\t\twhile (i < eol)\n\t\t\tif (!isspace(sb->buf[i++]))\n\t\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/*\n * Find out if the message in the strbuf contains only whitespace and\n * Signed-off-by lines.\n */\nstatic int message_is_empty(struct strbuf *sb)\n{\n\tif (cleanup_mode == CLEANUP_NONE && sb->len)\n\t\treturn 0;\n\treturn rest_is_empty(sb, 0);\n}\n\n/*\n * See if the user edited the message in the editor or left what\n * was in the template intact\n */\nstatic int template_untouched(struct strbuf *sb)\n{\n\tstruct strbuf tmpl = STRBUF_INIT;\n\tchar *start;\n\n\tif (cleanup_mode == CLEANUP_NONE && sb->len)\n\t\treturn 0;\n\n\tif (!template_file || strbuf_read_file(&tmpl, template_file, 0) <= 0)\n\t\treturn 0;\n\n\tstripspace(&tmpl, cleanup_mode == CLEANUP_ALL);\n\tstart = (char *)skip_prefix(sb->buf, tmpl.buf);\n\tif (!start)\n\t\tstart = sb->buf;\n\tstrbuf_release(&tmpl);\n\treturn rest_is_empty(sb, start - sb->buf);\n}\n\nstatic const char *find_author_by_nickname(const char *name)\n{\n\tstruct rev_info revs;\n\tstruct commit *commit;\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *av[20];\n\tint ac = 0;\n\n\tinit_revisions(&revs, NULL);\n\tstrbuf_addf(&buf, \"--author=%s\", name);\n\tav[++ac] = \"--all\";\n\tav[++ac] = \"-i\";\n\tav[++ac] = buf.buf;\n\tav[++ac] = NULL;\n\tsetup_revisions(ac, av, &revs, NULL);\n\tprepare_revision_walk(&revs);\n\tcommit = get_revision(&revs);\n\tif (commit) {\n\t\tstruct pretty_print_context ctx = {0};\n\t\tctx.date_mode = DATE_NORMAL;\n\t\tstrbuf_release(&buf);\n\t\tformat_commit_message(commit, \"%an <%ae>\", &buf, &ctx);\n\t\treturn strbuf_detach(&buf, NULL);\n\t}\n\tdie(_(\"No existing author found with '%s'\"), name);\n}\n\n\nstatic void handle_untracked_files_arg(struct wt_status *s)\n{\n\tif (!untracked_files_arg)\n\t\t; /* default already initialized */\n\telse if (!strcmp(untracked_files_arg, \"no\"))\n\t\ts->show_untracked_files = SHOW_NO_UNTRACKED_FILES;\n\telse if (!strcmp(untracked_files_arg, \"normal\"))\n\t\ts->show_untracked_files = SHOW_NORMAL_UNTRACKED_FILES;\n\telse if (!strcmp(untracked_files_arg, \"all\"))\n\t\ts->show_untracked_files = SHOW_ALL_UNTRACKED_FILES;\n\telse\n\t\tdie(_(\"Invalid untracked files mode '%s'\"), untracked_files_arg);\n}\n\nstatic const char *read_commit_message(const char *name)\n{\n\tconst char *out_enc;\n\tstruct commit *commit;\n\n\tcommit = lookup_commit_reference_by_name(name);\n\tif (!commit)\n\t\tdie(_(\"could not lookup commit %s\"), name);\n\tout_enc = get_commit_output_encoding();\n\treturn logmsg_reencode(commit, NULL, out_enc);\n}\n\n/*\n * Enumerate what needs to be propagated when --porcelain\n * is not in effect here.\n */\nstatic struct status_deferred_config {\n\tenum status_format status_format;\n\tint show_branch;\n} status_deferred_config = {\n\tSTATUS_FORMAT_UNSPECIFIED,\n\t-1 /* unspecified */\n};\n\nstatic void finalize_deferred_config(struct wt_status *s)\n{\n\tint use_deferred_config = (status_format != STATUS_FORMAT_PORCELAIN &&\n\t\t\t\t   !s->null_termination);\n\n\tif (s->null_termination) {\n\t\tif (status_format == STATUS_FORMAT_NONE ||\n\t\t    status_format == STATUS_FORMAT_UNSPECIFIED)\n\t\t\tstatus_format = STATUS_FORMAT_PORCELAIN;\n\t\telse if (status_format == STATUS_FORMAT_LONG)\n\t\t\tdie(_(\"--long and -z are incompatible\"));\n\t}\n\n\tif (use_deferred_config && status_format == STATUS_FORMAT_UNSPECIFIED)\n\t\tstatus_format = status_deferred_config.status_format;\n\tif (status_format == STATUS_FORMAT_UNSPECIFIED)\n\t\tstatus_format = STATUS_FORMAT_NONE;\n\n\tif (use_deferred_config && s->show_branch < 0)\n\t\ts->show_branch = status_deferred_config.show_branch;\n\tif (s->show_branch < 0)\n\t\ts->show_branch = 0;\n}\n\nstatic int parse_and_validate_options(int argc, const char *argv[],\n\t\t\t\t      const struct option *options,\n\t\t\t\t      const char * const usage[],\n\t\t\t\t      const char *prefix,\n\t\t\t\t      struct commit *current_head,\n\t\t\t\t      struct wt_status *s)\n{\n\tint f = 0;\n\n\targc = parse_options(argc, argv, prefix, options, usage, 0);\n\tfinalize_deferred_config(s);\n\n\tif (force_author && !strchr(force_author, '>'))\n\t\tforce_author = find_author_by_nickname(force_author);\n\n\tif (force_author && renew_authorship)\n\t\tdie(_(\"Using both --reset-author and --author does not make sense\"));\n\n\tif (logfile || have_option_m || use_message || fixup_message)\n\t\tuse_editor = 0;\n\tif (0 <= edit_flag)\n\t\tuse_editor = edit_flag;\n\tif (!use_editor)\n\t\tsetenv(\"GIT_EDITOR\", \":\", 1);\n\n\t/* Sanity check options */\n\tif (amend && !current_head)\n\t\tdie(_(\"You have nothing to amend.\"));\n\tif (amend && whence != FROM_COMMIT) {\n\t\tif (whence == FROM_MERGE)\n\t\t\tdie(_(\"You are in the middle of a merge -- cannot amend.\"));\n\t\telse if (whence == FROM_CHERRY_PICK)\n\t\t\tdie(_(\"You are in the middle of a cherry-pick -- cannot amend.\"));\n\t}\n\tif (fixup_message && squash_message)\n\t\tdie(_(\"Options --squash and --fixup cannot be used together\"));\n\tif (use_message)\n\t\tf++;\n\tif (edit_message)\n\t\tf++;\n\tif (fixup_message)\n\t\tf++;\n\tif (logfile)\n\t\tf++;\n\tif (f > 1)\n\t\tdie(_(\"Only one of -c/-C/-F/--fixup can be used.\"));\n\tif (message.len && f > 0)\n\t\tdie((_(\"Option -m cannot be combined with -c/-C/-F/--fixup.\")));\n\tif (f || message.len)\n\t\ttemplate_file = NULL;\n\tif (edit_message)\n\t\tuse_message = edit_message;\n\tif (amend && !use_message && !fixup_message)\n\t\tuse_message = \"HEAD\";\n\tif (!use_message && whence != FROM_CHERRY_PICK && renew_authorship)\n\t\tdie(_(\"--reset-author can be used only with -C, -c or --amend.\"));\n\tif (use_message) {\n\t\tuse_message_buffer = read_commit_message(use_message);\n\t\tif (!renew_authorship) {\n\t\t\tauthor_message = use_message;\n\t\t\tauthor_message_buffer = use_message_buffer;\n\t\t}\n\t}\n\tif (whence == FROM_CHERRY_PICK && !renew_authorship) {\n\t\tauthor_message = \"CHERRY_PICK_HEAD\";\n\t\tauthor_message_buffer = read_commit_message(author_message);\n\t}\n\n\tif (patch_interactive)\n\t\tinteractive = 1;\n\n\tif (!!also + !!only + !!all + !!interactive > 1)\n\t\tdie(_(\"Only one of --include/--only/--all/--interactive/--patch can be used.\"));\n\tif (argc == 0 && (also || (only && !amend)))\n\t\tdie(_(\"No paths with --include/--only does not make sense.\"));\n\tif (argc == 0 && only && amend)\n\t\tonly_include_assumed = _(\"Clever... amending the last one with dirty index.\");\n\tif (argc > 0 && !also && !only)\n\t\tonly_include_assumed = _(\"Explicit paths specified without -i nor -o; assuming --only paths...\");\n\tif (!cleanup_arg || !strcmp(cleanup_arg, \"default\"))\n\t\tcleanup_mode = use_editor ? CLEANUP_ALL : CLEANUP_SPACE;\n\telse if (!strcmp(cleanup_arg, \"verbatim\"))\n\t\tcleanup_mode = CLEANUP_NONE;\n\telse if (!strcmp(cleanup_arg, \"whitespace\"))\n\t\tcleanup_mode = CLEANUP_SPACE;\n\telse if (!strcmp(cleanup_arg, \"strip\"))\n\t\tcleanup_mode = CLEANUP_ALL;\n\telse\n\t\tdie(_(\"Invalid cleanup mode %s\"), cleanup_arg);\n\n\thandle_untracked_files_arg(s);\n\n\tif (all && argc > 0)\n\t\tdie(_(\"Paths with -a does not make sense.\"));\n\n\tif (status_format != STATUS_FORMAT_NONE)\n\t\tdry_run = 1;\n\n\treturn argc;\n}\n\nstatic int dry_run_commit(int argc, const char **argv, const char *prefix,\n\t\t\t  const struct commit *current_head, struct wt_status *s)\n{\n\tint commitable;\n\tconst char *index_file;\n\n\tindex_file = prepare_index(argc, argv, prefix, current_head, 1);\n\tcommitable = run_status(stdout, index_file, prefix, 0, s);\n\trollback_index_files();\n\n\treturn commitable ? 0 : 1;\n}\n\nstatic int parse_status_slot(const char *var, int offset)\n{\n\tif (!strcasecmp(var+offset, \"header\"))\n\t\treturn WT_STATUS_HEADER;\n\tif (!strcasecmp(var+offset, \"branch\"))\n\t\treturn WT_STATUS_ONBRANCH;\n\tif (!strcasecmp(var+offset, \"updated\")\n\t\t|| !strcasecmp(var+offset, \"added\"))\n\t\treturn WT_STATUS_UPDATED;\n\tif (!strcasecmp(var+offset, \"changed\"))\n\t\treturn WT_STATUS_CHANGED;\n\tif (!strcasecmp(var+offset, \"untracked\"))\n\t\treturn WT_STATUS_UNTRACKED;\n\tif (!strcasecmp(var+offset, \"nobranch\"))\n\t\treturn WT_STATUS_NOBRANCH;\n\tif (!strcasecmp(var+offset, \"unmerged\"))\n\t\treturn WT_STATUS_UNMERGED;\n\treturn -1;\n}\n\nstatic int git_status_config(const char *k, const char *v, void *cb)\n{\n\tstruct wt_status *s = cb;\n\n\tif (!prefixcmp(k, \"column.\"))\n\t\treturn git_column_config(k, v, \"status\", &s->colopts);\n\tif (!strcmp(k, \"status.submodulesummary\")) {\n\t\tint is_bool;\n\t\ts->submodule_summary = git_config_bool_or_int(k, v, &is_bool);\n\t\tif (is_bool && s->submodule_summary)\n\t\t\ts->submodule_summary = -1;\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.short\")) {\n\t\tif (git_config_bool(k, v))\n\t\t\tstatus_deferred_config.status_format = STATUS_FORMAT_SHORT;\n\t\telse\n\t\t\tstatus_deferred_config.status_format = STATUS_FORMAT_NONE;\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.branch\")) {\n\t\tstatus_deferred_config.show_branch = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.color\") || !strcmp(k, \"color.status\")) {\n\t\ts->use_color = git_config_colorbool(k, v);\n\t\treturn 0;\n\t}\n\tif (!prefixcmp(k, \"status.color.\") || !prefixcmp(k, \"color.status.\")) {\n\t\tint slot = parse_status_slot(k, 13);\n\t\tif (slot < 0)\n\t\t\treturn 0;\n\t\tif (!v)\n\t\t\treturn config_error_nonbool(k);\n\t\tcolor_parse(v, k, s->color_palette[slot]);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.relativepaths\")) {\n\t\ts->relative_paths = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.showuntrackedfiles\")) {\n\t\tif (!v)\n\t\t\treturn config_error_nonbool(k);\n\t\telse if (!strcmp(v, \"no\"))\n\t\t\ts->show_untracked_files = SHOW_NO_UNTRACKED_FILES;\n\t\telse if (!strcmp(v, \"normal\"))\n\t\t\ts->show_untracked_files = SHOW_NORMAL_UNTRACKED_FILES;\n\t\telse if (!strcmp(v, \"all\"))\n\t\t\ts->show_untracked_files = SHOW_ALL_UNTRACKED_FILES;\n\t\telse\n\t\t\treturn error(_(\"Invalid untracked files mode '%s'\"), v);\n\t\treturn 0;\n\t}\n\treturn git_diff_ui_config(k, v, NULL);\n}\n\nint cmd_status(int argc, const char **argv, const char *prefix)\n{\n\tstatic struct wt_status s;\n\tint fd;\n\tunsigned char sha1[20];\n\tstatic struct option builtin_status_options[] = {\n\t\tOPT__VERBOSE(&verbose, N_(\"be verbose\")),\n\t\tOPT_SET_INT('s', \"short\", &status_format,\n\t\t\t    N_(\"show status concisely\"), STATUS_FORMAT_SHORT),\n\t\tOPT_BOOL('b', \"branch\", &s.show_branch,\n\t\t\t N_(\"show branch information\")),\n\t\tOPT_SET_INT(0, \"porcelain\", &status_format,\n\t\t\t    N_(\"machine-readable output\"),\n\t\t\t    STATUS_FORMAT_PORCELAIN),\n\t\tOPT_SET_INT(0, \"long\", &status_format,\n\t\t\t    N_(\"show status in long format (default)\"),\n\t\t\t    STATUS_FORMAT_LONG),\n\t\tOPT_BOOLEAN('z', \"null\", &s.null_termination,\n\t\t\t    N_(\"terminate entries with NUL\")),\n\t\t{ OPTION_STRING, 'u', \"untracked-files\", &untracked_files_arg,\n\t\t  N_(\"mode\"),\n\t\t  N_(\"show untracked files, optional modes: all, normal, no. (Default: all)\"),\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\tOPT_BOOLEAN(0, \"ignored\", &show_ignored_in_status,\n\t\t\t    N_(\"show ignored files\")),\n\t\t{ OPTION_STRING, 0, \"ignore-submodules\", &ignore_submodule_arg, N_(\"when\"),\n\t\t  N_(\"ignore changes to submodules, optional when: all, dirty, untracked. (Default: all)\"),\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\tOPT_COLUMN(0, \"column\", &s.colopts, N_(\"list untracked files in columns\")),\n\t\tOPT_END(),\n\t};\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_status_usage, builtin_status_options);\n\n\twt_status_prepare(&s);\n\tgitmodules_config();\n\tgit_config(git_status_config, &s);\n\tdetermine_whence(&s);\n\targc = parse_options(argc, argv, prefix,\n\t\t\t     builtin_status_options,\n\t\t\t     builtin_status_usage, 0);\n\tfinalize_colopts(&s.colopts, -1);\n\tfinalize_deferred_config(&s);\n\n\thandle_untracked_files_arg(&s);\n\tif (show_ignored_in_status)\n\t\ts.show_ignored_files = 1;\n\tif (*argv)\n\t\ts.pathspec = get_pathspec(prefix, argv);\n\n\tread_cache_preload(s.pathspec);\n\trefresh_index(&the_index, REFRESH_QUIET|REFRESH_UNMERGED, s.pathspec, NULL, NULL);\n\n\tfd = hold_locked_index(&index_lock, 0);\n\tif (0 <= fd)\n\t\tupdate_index_if_able(&the_index, &index_lock);\n\n\ts.is_initial = get_sha1(s.reference, sha1) ? 1 : 0;\n\ts.ignore_submodule_arg = ignore_submodule_arg;\n\twt_status_collect(&s);\n\n\tif (s.relative_paths)\n\t\ts.prefix = prefix;\n\n\tswitch (status_format) {\n\tcase STATUS_FORMAT_SHORT:\n\t\twt_shortstatus_print(&s);\n\t\tbreak;\n\tcase STATUS_FORMAT_PORCELAIN:\n\t\twt_porcelain_print(&s);\n\t\tbreak;\n\tcase STATUS_FORMAT_UNSPECIFIED:\n\t\tdie(\"BUG: finalize_deferred_config() should have been called\");\n\t\tbreak;\n\tcase STATUS_FORMAT_NONE:\n\tcase STATUS_FORMAT_LONG:\n\t\ts.verbose = verbose;\n\t\ts.ignore_submodule_arg = ignore_submodule_arg;\n\t\twt_status_print(&s);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void print_summary(const char *prefix, const unsigned char *sha1,\n\t\t\t  int initial_commit)\n{\n\tstruct rev_info rev;\n\tstruct commit *commit;\n\tstruct strbuf format = STRBUF_INIT;\n\tunsigned char junk_sha1[20];\n\tconst char *head;\n\tstruct pretty_print_context pctx = {0};\n\tstruct strbuf author_ident = STRBUF_INIT;\n\tstruct strbuf committer_ident = STRBUF_INIT;\n\n\tcommit = lookup_commit(sha1);\n\tif (!commit)\n\t\tdie(_(\"couldn't look up newly created commit\"));\n\tif (!commit || parse_commit(commit))\n\t\tdie(_(\"could not parse newly created commit\"));\n\n\tstrbuf_addstr(&format, \"format:%h] %s\");\n\n\tformat_commit_message(commit, \"%an <%ae>\", &author_ident, &pctx);\n\tformat_commit_message(commit, \"%cn <%ce>\", &committer_ident, &pctx);\n\tif (strbuf_cmp(&author_ident, &committer_ident)) {\n\t\tstrbuf_addstr(&format, \"\\n Author: \");\n\t\tstrbuf_addbuf_percentquote(&format, &author_ident);\n\t}\n\tif (!committer_ident_sufficiently_given()) {\n\t\tstrbuf_addstr(&format, \"\\n Committer: \");\n\t\tstrbuf_addbuf_percentquote(&format, &committer_ident);\n\t\tif (advice_implicit_identity) {\n\t\t\tstrbuf_addch(&format, '\\n');\n\t\t\tstrbuf_addstr(&format, _(implicit_ident_advice));\n\t\t}\n\t}\n\tstrbuf_release(&author_ident);\n\tstrbuf_release(&committer_ident);\n\n\tinit_revisions(&rev, prefix);\n\tsetup_revisions(0, NULL, &rev, NULL);\n\n\trev.diff = 1;\n\trev.diffopt.output_format =\n\t\tDIFF_FORMAT_SHORTSTAT | DIFF_FORMAT_SUMMARY;\n\n\trev.verbose_header = 1;\n\trev.show_root_diff = 1;\n\tget_commit_format(format.buf, &rev);\n\trev.always_show_header = 0;\n\trev.diffopt.detect_rename = 1;\n\trev.diffopt.break_opt = 0;\n\tdiff_setup_done(&rev.diffopt);\n\n\thead = resolve_ref_unsafe(\"HEAD\", junk_sha1, 0, NULL);\n\tprintf(\"[%s%s \",\n\t\t!prefixcmp(head, \"refs/heads/\") ?\n\t\t\thead + 11 :\n\t\t\t!strcmp(head, \"HEAD\") ?\n\t\t\t\t_(\"detached HEAD\") :\n\t\t\t\thead,\n\t\tinitial_commit ? _(\" (root-commit)\") : \"\");\n\n\tif (!log_tree_commit(&rev, commit)) {\n\t\trev.always_show_header = 1;\n\t\trev.use_terminator = 1;\n\t\tlog_tree_commit(&rev, commit);\n\t}\n\n\tstrbuf_release(&format);\n}\n\nstatic int git_commit_config(const char *k, const char *v, void *cb)\n{\n\tstruct wt_status *s = cb;\n\tint status;\n\n\tif (!strcmp(k, \"commit.template\"))\n\t\treturn git_config_pathname(&template_file, k, v);\n\tif (!strcmp(k, \"commit.status\")) {\n\t\tinclude_status = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"commit.cleanup\"))\n\t\treturn git_config_string(&cleanup_arg, k, v);\n\n\tstatus = git_gpg_config(k, v, NULL);\n\tif (status)\n\t\treturn status;\n\treturn git_status_config(k, v, s);\n}\n\nstatic int run_rewrite_hook(const unsigned char *oldsha1,\n\t\t\t    const unsigned char *newsha1)\n{\n\t/* oldsha1 SP newsha1 LF NUL */\n\tstatic char buf[2*40 + 3];\n\tstruct child_process proc;\n\tconst char *argv[3];\n\tint code;\n\tsize_t n;\n\n\targv[0] = find_hook(\"post-rewrite\");\n\tif (!argv[0])\n\t\treturn 0;\n\n\targv[1] = \"amend\";\n\targv[2] = NULL;\n\n\tmemset(&proc, 0, sizeof(proc));\n\tproc.argv = argv;\n\tproc.in = -1;\n\tproc.stdout_to_stderr = 1;\n\n\tcode = start_command(&proc);\n\tif (code)\n\t\treturn code;\n\tn = snprintf(buf, sizeof(buf), \"%s %s\\n\",\n\t\t     sha1_to_hex(oldsha1), sha1_to_hex(newsha1));\n\twrite_in_full(proc.in, buf, n);\n\tclose(proc.in);\n\treturn finish_command(&proc);\n}\n\nint cmd_commit(int argc, const char **argv, const char *prefix)\n{\n\tstatic struct wt_status s;\n\tstatic struct option builtin_commit_options[] = {\n\t\tOPT__QUIET(&quiet, N_(\"suppress summary after successful commit\")),\n\t\tOPT__VERBOSE(&verbose, N_(\"show diff in commit message template\")),\n\n\t\tOPT_GROUP(N_(\"Commit message options\")),\n\t\tOPT_FILENAME('F', \"file\", &logfile, N_(\"read message from file\")),\n\t\tOPT_STRING(0, \"author\", &force_author, N_(\"author\"), N_(\"override author for commit\")),\n\t\tOPT_STRING(0, \"date\", &force_date, N_(\"date\"), N_(\"override date for commit\")),\n\t\tOPT_CALLBACK('m', \"message\", &message, N_(\"message\"), N_(\"commit message\"), opt_parse_m),\n\t\tOPT_STRING('c', \"reedit-message\", &edit_message, N_(\"commit\"), N_(\"reuse and edit message from specified commit\")),\n\t\tOPT_STRING('C', \"reuse-message\", &use_message, N_(\"commit\"), N_(\"reuse message from specified commit\")),\n\t\tOPT_STRING(0, \"fixup\", &fixup_message, N_(\"commit\"), N_(\"use autosquash formatted message to fixup specified commit\")),\n\t\tOPT_STRING(0, \"squash\", &squash_message, N_(\"commit\"), N_(\"use autosquash formatted message to squash specified commit\")),\n\t\tOPT_BOOLEAN(0, \"reset-author\", &renew_authorship, N_(\"the commit is authored by me now (used with -C/-c/--amend)\")),\n\t\tOPT_BOOLEAN('s', \"signoff\", &signoff, N_(\"add Signed-off-by:\")),\n\t\tOPT_FILENAME('t', \"template\", &template_file, N_(\"use specified template file\")),\n\t\tOPT_BOOL('e', \"edit\", &edit_flag, N_(\"force edit of commit\")),\n\t\tOPT_STRING(0, \"cleanup\", &cleanup_arg, N_(\"default\"), N_(\"how to strip spaces and #comments from message\")),\n\t\tOPT_BOOLEAN(0, \"status\", &include_status, N_(\"include status in commit message template\")),\n\t\t{ OPTION_STRING, 'S', \"gpg-sign\", &sign_commit, N_(\"key id\"),\n\t\t  N_(\"GPG sign commit\"), PARSE_OPT_OPTARG, NULL, (intptr_t) \"\" },\n\t\t/* end commit message options */\n\n\t\tOPT_GROUP(N_(\"Commit contents options\")),\n\t\tOPT_BOOLEAN('a', \"all\", &all, N_(\"commit all changed files\")),\n\t\tOPT_BOOLEAN('i', \"include\", &also, N_(\"add specified files to index for commit\")),\n\t\tOPT_BOOLEAN(0, \"interactive\", &interactive, N_(\"interactively add files\")),\n\t\tOPT_BOOLEAN('p', \"patch\", &patch_interactive, N_(\"interactively add changes\")),\n\t\tOPT_BOOLEAN('o', \"only\", &only, N_(\"commit only specified files\")),\n\t\tOPT_BOOLEAN('n', \"no-verify\", &no_verify, N_(\"bypass pre-commit hook\")),\n\t\tOPT_BOOLEAN(0, \"dry-run\", &dry_run, N_(\"show what would be committed\")),\n\t\tOPT_SET_INT(0, \"short\", &status_format, N_(\"show status concisely\"),\n\t\t\t    STATUS_FORMAT_SHORT),\n\t\tOPT_BOOL(0, \"branch\", &s.show_branch, N_(\"show branch information\")),\n\t\tOPT_SET_INT(0, \"porcelain\", &status_format,\n\t\t\t    N_(\"machine-readable output\"), STATUS_FORMAT_PORCELAIN),\n\t\tOPT_SET_INT(0, \"long\", &status_format,\n\t\t\t    N_(\"show status in long format (default)\"),\n\t\t\t    STATUS_FORMAT_LONG),\n\t\tOPT_BOOLEAN('z', \"null\", &s.null_termination,\n\t\t\t    N_(\"terminate entries with NUL\")),\n\t\tOPT_BOOLEAN(0, \"amend\", &amend, N_(\"amend previous commit\")),\n\t\tOPT_BOOLEAN(0, \"no-post-rewrite\", &no_post_rewrite, N_(\"bypass post-rewrite hook\")),\n\t\t{ OPTION_STRING, 'u', \"untracked-files\", &untracked_files_arg, N_(\"mode\"), N_(\"show untracked files, optional modes: all, normal, no. (Default: all)\"), PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\t/* end commit contents options */\n\n\t\t{ OPTION_BOOLEAN, 0, \"allow-empty\", &allow_empty, NULL,\n\t\t  N_(\"ok to record an empty change\"),\n\t\t  PARSE_OPT_NOARG | PARSE_OPT_HIDDEN },\n\t\t{ OPTION_BOOLEAN, 0, \"allow-empty-message\", &allow_empty_message, NULL,\n\t\t  N_(\"ok to record a change with an empty message\"),\n\t\t  PARSE_OPT_NOARG | PARSE_OPT_HIDDEN },\n\n\t\tOPT_END()\n\t};\n\n\tstruct strbuf sb = STRBUF_INIT;\n\tstruct strbuf author_ident = STRBUF_INIT;\n\tconst char *index_file, *reflog_msg;\n\tchar *nl, *p;\n\tunsigned char sha1[20];\n\tstruct ref_lock *ref_lock;\n\tstruct commit_list *parents = NULL, **pptr = &parents;\n\tstruct stat statbuf;\n\tint allow_fast_forward = 1;\n\tstruct commit *current_head = NULL;\n\tstruct commit_extra_header *extra = NULL;\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_commit_usage, builtin_commit_options);\n\n\twt_status_prepare(&s);\n\tgitmodules_config();\n\tgit_config(git_commit_config, &s);\n\tstatus_format = STATUS_FORMAT_NONE; /* Ignore status.short */\n\tdetermine_whence(&s);\n\ts.colopts = 0;\n\n\tif (get_sha1(\"HEAD\", sha1))\n\t\tcurrent_head = NULL;\n\telse {\n\t\tcurrent_head = lookup_commit_or_die(sha1, \"HEAD\");\n\t\tif (!current_head || parse_commit(current_head))\n\t\t\tdie(_(\"could not parse HEAD commit\"));\n\t}\n\targc = parse_and_validate_options(argc, argv, builtin_commit_options,\n\t\t\t\t\t  builtin_commit_usage,\n\t\t\t\t\t  prefix, current_head, &s);\n\tif (dry_run)\n\t\treturn dry_run_commit(argc, argv, prefix, current_head, &s);\n\tindex_file = prepare_index(argc, argv, prefix, current_head, 0);\n\n\t/* Set up everything for writing the commit object.  This includes\n\t   running hooks, writing the trees, and interacting with the user.  */\n\tif (!prepare_to_commit(index_file, prefix,\n\t\t\t       current_head, &s, &author_ident)) {\n\t\trollback_index_files();\n\t\treturn 1;\n\t}\n\n\t/* Determine parents */\n\treflog_msg = getenv(\"GIT_REFLOG_ACTION\");\n\tif (!current_head) {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (initial)\";\n\t} else if (amend) {\n\t\tstruct commit_list *c;\n\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (amend)\";\n\t\tfor (c = current_head->parents; c; c = c->next)\n\t\t\tpptr = &commit_list_insert(c->item, pptr)->next;\n\t} else if (whence == FROM_MERGE) {\n\t\tstruct strbuf m = STRBUF_INIT;\n\t\tFILE *fp;\n\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (merge)\";\n\t\tpptr = &commit_list_insert(current_head, pptr)->next;\n\t\tfp = fopen(git_path(\"MERGE_HEAD\"), \"r\");\n\t\tif (fp == NULL)\n\t\t\tdie_errno(_(\"could not open '%s' for reading\"),\n\t\t\t\t  git_path(\"MERGE_HEAD\"));\n\t\twhile (strbuf_getline(&m, fp, '\\n') != EOF) {\n\t\t\tstruct commit *parent;\n\n\t\t\tparent = get_merge_parent(m.buf);\n\t\t\tif (!parent)\n\t\t\t\tdie(_(\"Corrupt MERGE_HEAD file (%s)\"), m.buf);\n\t\t\tpptr = &commit_list_insert(parent, pptr)->next;\n\t\t}\n\t\tfclose(fp);\n\t\tstrbuf_release(&m);\n\t\tif (!stat(git_path(\"MERGE_MODE\"), &statbuf)) {\n\t\t\tif (strbuf_read_file(&sb, git_path(\"MERGE_MODE\"), 0) < 0)\n\t\t\t\tdie_errno(_(\"could not read MERGE_MODE\"));\n\t\t\tif (!strcmp(sb.buf, \"no-ff\"))\n\t\t\t\tallow_fast_forward = 0;\n\t\t}\n\t\tif (allow_fast_forward)\n\t\t\tparents = reduce_heads(parents);\n\t} else {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = (whence == FROM_CHERRY_PICK)\n\t\t\t\t\t? \"commit (cherry-pick)\"\n\t\t\t\t\t: \"commit\";\n\t\tpptr = &commit_list_insert(current_head, pptr)->next;\n\t}\n\n\t/* Finally, get the commit message */\n\tstrbuf_reset(&sb);\n\tif (strbuf_read_file(&sb, git_path(commit_editmsg), 0) < 0) {\n\t\tint saved_errno = errno;\n\t\trollback_index_files();\n\t\tdie(_(\"could not read commit message: %s\"), strerror(saved_errno));\n\t}\n\n\t/* Truncate the message just before the diff, if any. */\n\tif (verbose) {\n\t\tp = strstr(sb.buf, \"\\ndiff --git \");\n\t\tif (p != NULL)\n\t\t\tstrbuf_setlen(&sb, p - sb.buf + 1);\n\t}\n\n\tif (cleanup_mode != CLEANUP_NONE)\n\t\tstripspace(&sb, cleanup_mode == CLEANUP_ALL);\n\tif (template_untouched(&sb) && !allow_empty_message) {\n\t\trollback_index_files();\n\t\tfprintf(stderr, _(\"Aborting commit; you did not edit the message.\\n\"));\n\t\texit(1);\n\t}\n\tif (message_is_empty(&sb) && !allow_empty_message) {\n\t\trollback_index_files();\n\t\tfprintf(stderr, _(\"Aborting commit due to empty commit message.\\n\"));\n\t\texit(1);\n\t}\n\n\tif (amend) {\n\t\tconst char *exclude_gpgsig[2] = { \"gpgsig\", NULL };\n\t\textra = read_commit_extra_headers(current_head, exclude_gpgsig);\n\t} else {\n\t\tstruct commit_extra_header **tail = &extra;\n\t\tappend_merge_tag_headers(parents, &tail);\n\t}\n\n\tif (commit_tree_extended(&sb, active_cache_tree->sha1, parents, sha1,\n\t\t\t\t author_ident.buf, sign_commit, extra)) {\n\t\trollback_index_files();\n\t\tdie(_(\"failed to write commit object\"));\n\t}\n\tstrbuf_release(&author_ident);\n\tfree_commit_extra_headers(extra);\n\n\tref_lock = lock_any_ref_for_update(\"HEAD\",\n\t\t\t\t\t   !current_head\n\t\t\t\t\t   ? NULL\n\t\t\t\t\t   : current_head->object.sha1,\n\t\t\t\t\t   0);\n\n\tnl = strchr(sb.buf, '\\n');\n\tif (nl)\n\t\tstrbuf_setlen(&sb, nl + 1 - sb.buf);\n\telse\n\t\tstrbuf_addch(&sb, '\\n');\n\tstrbuf_insert(&sb, 0, reflog_msg, strlen(reflog_msg));\n\tstrbuf_insert(&sb, strlen(reflog_msg), \": \", 2);\n\n\tif (!ref_lock) {\n\t\trollback_index_files();\n\t\tdie(_(\"cannot lock HEAD ref\"));\n\t}\n\tif (write_ref_sha1(ref_lock, sha1, sb.buf) < 0) {\n\t\trollback_index_files();\n\t\tdie(_(\"cannot update HEAD ref\"));\n\t}\n\n\tunlink(git_path(\"CHERRY_PICK_HEAD\"));\n\tunlink(git_path(\"REVERT_HEAD\"));\n\tunlink(git_path(\"MERGE_HEAD\"));\n\tunlink(git_path(\"MERGE_MSG\"));\n\tunlink(git_path(\"MERGE_MODE\"));\n\tunlink(git_path(\"SQUASH_MSG\"));\n\n\tif (commit_index_files())\n\t\tdie (_(\"Repository has been updated, but unable to write\\n\"\n\t\t     \"new_index file. Check that disk is not full or quota is\\n\"\n\t\t     \"not exceeded, and then \\\"git reset HEAD\\\" to recover.\"));\n\n\trerere(0);\n\trun_hook(get_index_file(), \"post-commit\", NULL);\n\tif (amend && !no_post_rewrite) {\n\t\tstruct notes_rewrite_cfg *cfg;\n\t\tcfg = init_copy_notes_for_rewrite(\"amend\");\n\t\tif (cfg) {\n\t\t\t/* we are amending, so current_head is not NULL */\n\t\t\tcopy_note_for_rewrite(cfg, current_head->object.sha1, sha1);\n\t\t\tfinish_copy_notes_for_rewrite(cfg, \"Notes added by 'git commit --amend'\");\n\t\t}\n\t\trun_rewrite_hook(current_head->object.sha1, sha1);\n\t}\n\tif (!quiet)\n\t\tprint_summary(prefix, sha1, !current_head);\n\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "003bd7dbec1acfda36f4d4bc5e9fb64a276ad049",
  "sha1_ok": true,
  "size": 48246
}
