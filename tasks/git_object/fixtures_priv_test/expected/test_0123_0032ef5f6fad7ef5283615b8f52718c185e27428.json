{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJ3dC1zdGF0dXMuaCIKI2luY2x1ZGUgIm9iamVjdC5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgInJldmlzaW9uLmgiCiNpbmNsdWRlICJkaWZmY29yZS5oIgojaW5jbHVkZSAicXVvdGUuaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJhcmd2LWFycmF5LmgiCiNpbmNsdWRlICJyZW1vdGUuaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgInN1Ym1vZHVsZS5oIgojaW5jbHVkZSAiY29sdW1uLmgiCiNpbmNsdWRlICJzdHJidWYuaCIKI2luY2x1ZGUgInV0ZjguaCIKI2luY2x1ZGUgIndvcmt0cmVlLmgiCgpzdGF0aWMgY29uc3QgY2hhciBjdXRfbGluZVtdID0KIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSA+OCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiI7CgpzdGF0aWMgY2hhciBkZWZhdWx0X3d0X3N0YXR1c19jb2xvcnNbXVtDT0xPUl9NQVhMRU5dID0gewoJR0lUX0NPTE9SX05PUk1BTCwgLyogV1RfU1RBVFVTX0hFQURFUiAqLwoJR0lUX0NPTE9SX0dSRUVOLCAgLyogV1RfU1RBVFVTX1VQREFURUQgKi8KCUdJVF9DT0xPUl9SRUQsICAgIC8qIFdUX1NUQVRVU19DSEFOR0VEICovCglHSVRfQ09MT1JfUkVELCAgICAvKiBXVF9TVEFUVVNfVU5UUkFDS0VEICovCglHSVRfQ09MT1JfUkVELCAgICAvKiBXVF9TVEFUVVNfTk9CUkFOQ0ggKi8KCUdJVF9DT0xPUl9SRUQsICAgIC8qIFdUX1NUQVRVU19VTk1FUkdFRCAqLwoJR0lUX0NPTE9SX0dSRUVOLCAgLyogV1RfU1RBVFVTX0xPQ0FMX0JSQU5DSCAqLwoJR0lUX0NPTE9SX1JFRCwgICAgLyogV1RfU1RBVFVTX1JFTU9URV9CUkFOQ0ggKi8KCUdJVF9DT0xPUl9OSUwsICAgIC8qIFdUX1NUQVRVU19PTkJSQU5DSCAqLwp9OwoKc3RhdGljIGNvbnN0IGNoYXIgKmNvbG9yKGludCBzbG90LCBzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7Cgljb25zdCBjaGFyICpjID0gIiI7CglpZiAod2FudF9jb2xvcihzLT51c2VfY29sb3IpKQoJCWMgPSBzLT5jb2xvcl9wYWxldHRlW3Nsb3RdOwoJaWYgKHNsb3QgPT0gV1RfU1RBVFVTX09OQlJBTkNIICYmIGNvbG9yX2lzX25pbChjKSkKCQljID0gcy0+Y29sb3JfcGFsZXR0ZVtXVF9TVEFUVVNfSEVBREVSXTsKCXJldHVybiBjOwp9CgpzdGF0aWMgdm9pZCBzdGF0dXNfdnByaW50ZihzdHJ1Y3Qgd3Rfc3RhdHVzICpzLCBpbnQgYXRfYm9sLCBjb25zdCBjaGFyICpjb2xvciwKCQljb25zdCBjaGFyICpmbXQsIHZhX2xpc3QgYXAsIGNvbnN0IGNoYXIgKnRyYWlsKQp7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGxpbmVidWYgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKmxpbmUsICplb2w7CgoJc3RyYnVmX3ZhZGRmKCZzYiwgZm10LCBhcCk7CglpZiAoIXNiLmxlbikgewoJCWlmIChzLT5kaXNwbGF5X2NvbW1lbnRfcHJlZml4KSB7CgkJCXN0cmJ1Zl9hZGRjaCgmc2IsIGNvbW1lbnRfbGluZV9jaGFyKTsKCQkJaWYgKCF0cmFpbCkKCQkJCXN0cmJ1Zl9hZGRjaCgmc2IsICcgJyk7CgkJfQoJCWNvbG9yX3ByaW50X3N0cmJ1ZihzLT5mcCwgY29sb3IsICZzYik7CgkJaWYgKHRyYWlsKQoJCQlmcHJpbnRmKHMtPmZwLCAiJXMiLCB0cmFpbCk7CgkJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCQlyZXR1cm47Cgl9Cglmb3IgKGxpbmUgPSBzYi5idWY7ICpsaW5lOyBsaW5lID0gZW9sICsgMSkgewoJCWVvbCA9IHN0cmNocihsaW5lLCAnXG4nKTsKCgkJc3RyYnVmX3Jlc2V0KCZsaW5lYnVmKTsKCQlpZiAoYXRfYm9sICYmIHMtPmRpc3BsYXlfY29tbWVudF9wcmVmaXgpIHsKCQkJc3RyYnVmX2FkZGNoKCZsaW5lYnVmLCBjb21tZW50X2xpbmVfY2hhcik7CgkJCWlmICgqbGluZSAhPSAnXG4nICYmICpsaW5lICE9ICdcdCcpCgkJCQlzdHJidWZfYWRkY2goJmxpbmVidWYsICcgJyk7CgkJfQoJCWlmIChlb2wpCgkJCXN0cmJ1Zl9hZGQoJmxpbmVidWYsIGxpbmUsIGVvbCAtIGxpbmUpOwoJCWVsc2UKCQkJc3RyYnVmX2FkZHN0cigmbGluZWJ1ZiwgbGluZSk7CgkJY29sb3JfcHJpbnRfc3RyYnVmKHMtPmZwLCBjb2xvciwgJmxpbmVidWYpOwoJCWlmIChlb2wpCgkJCWZwcmludGYocy0+ZnAsICJcbiIpOwoJCWVsc2UKCQkJYnJlYWs7CgkJYXRfYm9sID0gMTsKCX0KCWlmICh0cmFpbCkKCQlmcHJpbnRmKHMtPmZwLCAiJXMiLCB0cmFpbCk7CglzdHJidWZfcmVsZWFzZSgmbGluZWJ1Zik7CglzdHJidWZfcmVsZWFzZSgmc2IpOwp9Cgp2b2lkIHN0YXR1c19wcmludGZfbG4oc3RydWN0IHd0X3N0YXR1cyAqcywgY29uc3QgY2hhciAqY29sb3IsCgkJCWNvbnN0IGNoYXIgKmZtdCwgLi4uKQp7Cgl2YV9saXN0IGFwOwoKCXZhX3N0YXJ0KGFwLCBmbXQpOwoJc3RhdHVzX3ZwcmludGYocywgMSwgY29sb3IsIGZtdCwgYXAsICJcbiIpOwoJdmFfZW5kKGFwKTsKfQoKdm9pZCBzdGF0dXNfcHJpbnRmKHN0cnVjdCB3dF9zdGF0dXMgKnMsIGNvbnN0IGNoYXIgKmNvbG9yLAoJCQljb25zdCBjaGFyICpmbXQsIC4uLikKewoJdmFfbGlzdCBhcDsKCgl2YV9zdGFydChhcCwgZm10KTsKCXN0YXR1c192cHJpbnRmKHMsIDEsIGNvbG9yLCBmbXQsIGFwLCBOVUxMKTsKCXZhX2VuZChhcCk7Cn0KCnN0YXRpYyB2b2lkIHN0YXR1c19wcmludGZfbW9yZShzdHJ1Y3Qgd3Rfc3RhdHVzICpzLCBjb25zdCBjaGFyICpjb2xvciwKCQkJICAgICAgIGNvbnN0IGNoYXIgKmZtdCwgLi4uKQp7Cgl2YV9saXN0IGFwOwoKCXZhX3N0YXJ0KGFwLCBmbXQpOwoJc3RhdHVzX3ZwcmludGYocywgMCwgY29sb3IsIGZtdCwgYXAsIE5VTEwpOwoJdmFfZW5kKGFwKTsKfQoKdm9pZCB3dF9zdGF0dXNfcHJlcGFyZShzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoKCW1lbXNldChzLCAwLCBzaXplb2YoKnMpKTsKCW1lbWNweShzLT5jb2xvcl9wYWxldHRlLCBkZWZhdWx0X3d0X3N0YXR1c19jb2xvcnMsCgkgICAgICAgc2l6ZW9mKGRlZmF1bHRfd3Rfc3RhdHVzX2NvbG9ycykpOwoJcy0+c2hvd191bnRyYWNrZWRfZmlsZXMgPSBTSE9XX05PUk1BTF9VTlRSQUNLRURfRklMRVM7CglzLT51c2VfY29sb3IgPSAtMTsKCXMtPnJlbGF0aXZlX3BhdGhzID0gMTsKCXMtPmJyYW5jaCA9IHJlc29sdmVfcmVmZHVwKCJIRUFEIiwgMCwgc2hhMSwgTlVMTCk7CglzLT5yZWZlcmVuY2UgPSAiSEVBRCI7CglzLT5mcCA9IHN0ZG91dDsKCXMtPmluZGV4X2ZpbGUgPSBnZXRfaW5kZXhfZmlsZSgpOwoJcy0+Y2hhbmdlLnN0cmR1cF9zdHJpbmdzID0gMTsKCXMtPnVudHJhY2tlZC5zdHJkdXBfc3RyaW5ncyA9IDE7CglzLT5pZ25vcmVkLnN0cmR1cF9zdHJpbmdzID0gMTsKCXMtPnNob3dfYnJhbmNoID0gLTE7ICAvKiB1bnNwZWNpZmllZCAqLwoJcy0+ZGlzcGxheV9jb21tZW50X3ByZWZpeCA9IDA7Cn0KCnN0YXRpYyB2b2lkIHd0X3N0YXR1c19wcmludF91bm1lcmdlZF9oZWFkZXIoc3RydWN0IHd0X3N0YXR1cyAqcykKewoJaW50IGk7CglpbnQgZGVsX21vZF9jb25mbGljdCA9IDA7CglpbnQgYm90aF9kZWxldGVkID0gMDsKCWludCBub3RfZGVsZXRlZCA9IDA7Cgljb25zdCBjaGFyICpjID0gY29sb3IoV1RfU1RBVFVTX0hFQURFUiwgcyk7CgoJc3RhdHVzX3ByaW50Zl9sbihzLCBjLCBfKCJVbm1lcmdlZCBwYXRoczoiKSk7CgoJZm9yIChpID0gMDsgaSA8IHMtPmNoYW5nZS5ucjsgaSsrKSB7CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ID0gJihzLT5jaGFuZ2UuaXRlbXNbaV0pOwoJCXN0cnVjdCB3dF9zdGF0dXNfY2hhbmdlX2RhdGEgKmQgPSBpdC0+dXRpbDsKCgkJc3dpdGNoIChkLT5zdGFnZW1hc2spIHsKCQljYXNlIDA6CgkJCWJyZWFrOwoJCWNhc2UgMToKCQkJYm90aF9kZWxldGVkID0gMTsKCQkJYnJlYWs7CgkJY2FzZSAzOgoJCWNhc2UgNToKCQkJZGVsX21vZF9jb25mbGljdCA9IDE7CgkJCWJyZWFrOwoJCWRlZmF1bHQ6CgkJCW5vdF9kZWxldGVkID0gMTsKCQkJYnJlYWs7CgkJfQoJfQoKCWlmICghcy0+aGludHMpCgkJcmV0dXJuOwoJaWYgKHMtPndoZW5jZSAhPSBGUk9NX0NPTU1JVCkKCQk7CgllbHNlIGlmICghcy0+aXNfaW5pdGlhbCkKCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGMsIF8oIiAgKHVzZSBcImdpdCByZXNldCAlcyA8ZmlsZT4uLi5cIiB0byB1bnN0YWdlKSIpLCBzLT5yZWZlcmVuY2UpOwoJZWxzZQoJCXN0YXR1c19wcmludGZfbG4ocywgYywgXygiICAodXNlIFwiZ2l0IHJtIC0tY2FjaGVkIDxmaWxlPi4uLlwiIHRvIHVuc3RhZ2UpIikpOwoKCWlmICghYm90aF9kZWxldGVkKSB7CgkJaWYgKCFkZWxfbW9kX2NvbmZsaWN0KQoJCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGMsIF8oIiAgKHVzZSBcImdpdCBhZGQgPGZpbGU+Li4uXCIgdG8gbWFyayByZXNvbHV0aW9uKSIpKTsKCQllbHNlCgkJCXN0YXR1c19wcmludGZfbG4ocywgYywgXygiICAodXNlIFwiZ2l0IGFkZC9ybSA8ZmlsZT4uLi5cIiBhcyBhcHByb3ByaWF0ZSB0byBtYXJrIHJlc29sdXRpb24pIikpOwoJfSBlbHNlIGlmICghZGVsX21vZF9jb25mbGljdCAmJiAhbm90X2RlbGV0ZWQpIHsKCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGMsIF8oIiAgKHVzZSBcImdpdCBybSA8ZmlsZT4uLi5cIiB0byBtYXJrIHJlc29sdXRpb24pIikpOwoJfSBlbHNlIHsKCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGMsIF8oIiAgKHVzZSBcImdpdCBhZGQvcm0gPGZpbGU+Li4uXCIgYXMgYXBwcm9wcmlhdGUgdG8gbWFyayByZXNvbHV0aW9uKSIpKTsKCX0KCXN0YXR1c19wcmludGZfbG4ocywgYywgIiVzIiwgIiIpOwp9CgpzdGF0aWMgdm9pZCB3dF9zdGF0dXNfcHJpbnRfY2FjaGVkX2hlYWRlcihzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7Cgljb25zdCBjaGFyICpjID0gY29sb3IoV1RfU1RBVFVTX0hFQURFUiwgcyk7CgoJc3RhdHVzX3ByaW50Zl9sbihzLCBjLCBfKCJDaGFuZ2VzIHRvIGJlIGNvbW1pdHRlZDoiKSk7CglpZiAoIXMtPmhpbnRzKQoJCXJldHVybjsKCWlmIChzLT53aGVuY2UgIT0gRlJPTV9DT01NSVQpCgkJOyAvKiBORUVEU1dPUks6IHVzZSAiZ2l0IHJlc2V0IC0tdW5yZXNvbHZlIj8/PyAqLwoJZWxzZSBpZiAoIXMtPmlzX2luaXRpYWwpCgkJc3RhdHVzX3ByaW50Zl9sbihzLCBjLCBfKCIgICh1c2UgXCJnaXQgcmVzZXQgJXMgPGZpbGU+Li4uXCIgdG8gdW5zdGFnZSkiKSwgcy0+cmVmZXJlbmNlKTsKCWVsc2UKCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGMsIF8oIiAgKHVzZSBcImdpdCBybSAtLWNhY2hlZCA8ZmlsZT4uLi5cIiB0byB1bnN0YWdlKSIpKTsKCXN0YXR1c19wcmludGZfbG4ocywgYywgIiVzIiwgIiIpOwp9CgpzdGF0aWMgdm9pZCB3dF9zdGF0dXNfcHJpbnRfZGlydHlfaGVhZGVyKHN0cnVjdCB3dF9zdGF0dXMgKnMsCgkJCQkJIGludCBoYXNfZGVsZXRlZCwKCQkJCQkgaW50IGhhc19kaXJ0eV9zdWJtb2R1bGVzKQp7Cgljb25zdCBjaGFyICpjID0gY29sb3IoV1RfU1RBVFVTX0hFQURFUiwgcyk7CgoJc3RhdHVzX3ByaW50Zl9sbihzLCBjLCBfKCJDaGFuZ2VzIG5vdCBzdGFnZWQgZm9yIGNvbW1pdDoiKSk7CglpZiAoIXMtPmhpbnRzKQoJCXJldHVybjsKCWlmICghaGFzX2RlbGV0ZWQpCgkJc3RhdHVzX3ByaW50Zl9sbihzLCBjLCBfKCIgICh1c2UgXCJnaXQgYWRkIDxmaWxlPi4uLlwiIHRvIHVwZGF0ZSB3aGF0IHdpbGwgYmUgY29tbWl0dGVkKSIpKTsKCWVsc2UKCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGMsIF8oIiAgKHVzZSBcImdpdCBhZGQvcm0gPGZpbGU+Li4uXCIgdG8gdXBkYXRlIHdoYXQgd2lsbCBiZSBjb21taXR0ZWQpIikpOwoJc3RhdHVzX3ByaW50Zl9sbihzLCBjLCBfKCIgICh1c2UgXCJnaXQgY2hlY2tvdXQgLS0gPGZpbGU+Li4uXCIgdG8gZGlzY2FyZCBjaGFuZ2VzIGluIHdvcmtpbmcgZGlyZWN0b3J5KSIpKTsKCWlmIChoYXNfZGlydHlfc3VibW9kdWxlcykKCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGMsIF8oIiAgKGNvbW1pdCBvciBkaXNjYXJkIHRoZSB1bnRyYWNrZWQgb3IgbW9kaWZpZWQgY29udGVudCBpbiBzdWJtb2R1bGVzKSIpKTsKCXN0YXR1c19wcmludGZfbG4ocywgYywgIiVzIiwgIiIpOwp9CgpzdGF0aWMgdm9pZCB3dF9zdGF0dXNfcHJpbnRfb3RoZXJfaGVhZGVyKHN0cnVjdCB3dF9zdGF0dXMgKnMsCgkJCQkJIGNvbnN0IGNoYXIgKndoYXQsCgkJCQkJIGNvbnN0IGNoYXIgKmhvdykKewoJY29uc3QgY2hhciAqYyA9IGNvbG9yKFdUX1NUQVRVU19IRUFERVIsIHMpOwoJc3RhdHVzX3ByaW50Zl9sbihzLCBjLCAiJXM6Iiwgd2hhdCk7CglpZiAoIXMtPmhpbnRzKQoJCXJldHVybjsKCXN0YXR1c19wcmludGZfbG4ocywgYywgXygiICAodXNlIFwiZ2l0ICVzIDxmaWxlPi4uLlwiIHRvIGluY2x1ZGUgaW4gd2hhdCB3aWxsIGJlIGNvbW1pdHRlZCkiKSwgaG93KTsKCXN0YXR1c19wcmludGZfbG4ocywgYywgIiVzIiwgIiIpOwp9CgpzdGF0aWMgdm9pZCB3dF9zdGF0dXNfcHJpbnRfdHJhaWxlcihzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglzdGF0dXNfcHJpbnRmX2xuKHMsIGNvbG9yKFdUX1NUQVRVU19IRUFERVIsIHMpLCAiJXMiLCAiIik7Cn0KCiNkZWZpbmUgcXVvdGVfcGF0aCBxdW90ZV9wYXRoX3JlbGF0aXZlCgpzdGF0aWMgY29uc3QgY2hhciAqd3Rfc3RhdHVzX3VubWVyZ2VkX3N0YXR1c19zdHJpbmcoaW50IHN0YWdlbWFzaykKewoJc3dpdGNoIChzdGFnZW1hc2spIHsKCWNhc2UgMToKCQlyZXR1cm4gXygiYm90aCBkZWxldGVkOiIpOwoJY2FzZSAyOgoJCXJldHVybiBfKCJhZGRlZCBieSB1czoiKTsKCWNhc2UgMzoKCQlyZXR1cm4gXygiZGVsZXRlZCBieSB0aGVtOiIpOwoJY2FzZSA0OgoJCXJldHVybiBfKCJhZGRlZCBieSB0aGVtOiIpOwoJY2FzZSA1OgoJCXJldHVybiBfKCJkZWxldGVkIGJ5IHVzOiIpOwoJY2FzZSA2OgoJCXJldHVybiBfKCJib3RoIGFkZGVkOiIpOwoJY2FzZSA3OgoJCXJldHVybiBfKCJib3RoIG1vZGlmaWVkOiIpOwoJZGVmYXVsdDoKCQlkaWUoXygiYnVnOiB1bmhhbmRsZWQgdW5tZXJnZWQgc3RhdHVzICV4IiksIHN0YWdlbWFzayk7Cgl9Cn0KCnN0YXRpYyBjb25zdCBjaGFyICp3dF9zdGF0dXNfZGlmZl9zdGF0dXNfc3RyaW5nKGludCBzdGF0dXMpCnsKCXN3aXRjaCAoc3RhdHVzKSB7CgljYXNlIERJRkZfU1RBVFVTX0FEREVEOgoJCXJldHVybiBfKCJuZXcgZmlsZToiKTsKCWNhc2UgRElGRl9TVEFUVVNfQ09QSUVEOgoJCXJldHVybiBfKCJjb3BpZWQ6Iik7CgljYXNlIERJRkZfU1RBVFVTX0RFTEVURUQ6CgkJcmV0dXJuIF8oImRlbGV0ZWQ6Iik7CgljYXNlIERJRkZfU1RBVFVTX01PRElGSUVEOgoJCXJldHVybiBfKCJtb2RpZmllZDoiKTsKCWNhc2UgRElGRl9TVEFUVVNfUkVOQU1FRDoKCQlyZXR1cm4gXygicmVuYW1lZDoiKTsKCWNhc2UgRElGRl9TVEFUVVNfVFlQRV9DSEFOR0VEOgoJCXJldHVybiBfKCJ0eXBlY2hhbmdlOiIpOwoJY2FzZSBESUZGX1NUQVRVU19VTktOT1dOOgoJCXJldHVybiBfKCJ1bmtub3duOiIpOwoJY2FzZSBESUZGX1NUQVRVU19VTk1FUkdFRDoKCQlyZXR1cm4gXygidW5tZXJnZWQ6Iik7CglkZWZhdWx0OgoJCXJldHVybiBOVUxMOwoJfQp9CgpzdGF0aWMgaW50IG1heHdpZHRoKGNvbnN0IGNoYXIgKigqbGFiZWwpKGludCksIGludCBtaW52YWwsIGludCBtYXh2YWwpCnsKCWludCByZXN1bHQgPSAwLCBpOwoKCWZvciAoaSA9IG1pbnZhbDsgaSA8PSBtYXh2YWw7IGkrKykgewoJCWNvbnN0IGNoYXIgKnMgPSBsYWJlbChpKTsKCQlpbnQgbGVuID0gcyA/IHV0Zjhfc3Ryd2lkdGgocykgOiAwOwoJCWlmIChsZW4gPiByZXN1bHQpCgkJCXJlc3VsdCA9IGxlbjsKCX0KCXJldHVybiByZXN1bHQ7Cn0KCnN0YXRpYyB2b2lkIHd0X3N0YXR1c19wcmludF91bm1lcmdlZF9kYXRhKHN0cnVjdCB3dF9zdGF0dXMgKnMsCgkJCQkJICBzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXQpCnsKCWNvbnN0IGNoYXIgKmMgPSBjb2xvcihXVF9TVEFUVVNfVU5NRVJHRUQsIHMpOwoJc3RydWN0IHd0X3N0YXR1c19jaGFuZ2VfZGF0YSAqZCA9IGl0LT51dGlsOwoJc3RydWN0IHN0cmJ1ZiBvbmVidWYgPSBTVFJCVUZfSU5JVDsKCXN0YXRpYyBjaGFyICpwYWRkaW5nOwoJc3RhdGljIGludCBsYWJlbF93aWR0aDsKCWNvbnN0IGNoYXIgKm9uZSwgKmhvdzsKCWludCBsZW47CgoJaWYgKCFwYWRkaW5nKSB7CgkJbGFiZWxfd2lkdGggPSBtYXh3aWR0aCh3dF9zdGF0dXNfdW5tZXJnZWRfc3RhdHVzX3N0cmluZywgMSwgNyk7CgkJbGFiZWxfd2lkdGggKz0gc3RybGVuKCIgIik7CgkJcGFkZGluZyA9IHhtYWxsb2N6KGxhYmVsX3dpZHRoKTsKCQltZW1zZXQocGFkZGluZywgJyAnLCBsYWJlbF93aWR0aCk7Cgl9CgoJb25lID0gcXVvdGVfcGF0aChpdC0+c3RyaW5nLCBzLT5wcmVmaXgsICZvbmVidWYpOwoJc3RhdHVzX3ByaW50ZihzLCBjb2xvcihXVF9TVEFUVVNfSEVBREVSLCBzKSwgIlx0Iik7CgoJaG93ID0gd3Rfc3RhdHVzX3VubWVyZ2VkX3N0YXR1c19zdHJpbmcoZC0+c3RhZ2VtYXNrKTsKCWxlbiA9IGxhYmVsX3dpZHRoIC0gdXRmOF9zdHJ3aWR0aChob3cpOwoJc3RhdHVzX3ByaW50Zl9tb3JlKHMsIGMsICIlcyUuKnMlc1xuIiwgaG93LCBsZW4sIHBhZGRpbmcsIG9uZSk7CglzdHJidWZfcmVsZWFzZSgmb25lYnVmKTsKfQoKc3RhdGljIHZvaWQgd3Rfc3RhdHVzX3ByaW50X2NoYW5nZV9kYXRhKHN0cnVjdCB3dF9zdGF0dXMgKnMsCgkJCQkJaW50IGNoYW5nZV90eXBlLAoJCQkJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdCkKewoJc3RydWN0IHd0X3N0YXR1c19jaGFuZ2VfZGF0YSAqZCA9IGl0LT51dGlsOwoJY29uc3QgY2hhciAqYyA9IGNvbG9yKGNoYW5nZV90eXBlLCBzKTsKCWludCBzdGF0dXM7CgljaGFyICpvbmVfbmFtZTsKCWNoYXIgKnR3b19uYW1lOwoJY29uc3QgY2hhciAqb25lLCAqdHdvOwoJc3RydWN0IHN0cmJ1ZiBvbmVidWYgPSBTVFJCVUZfSU5JVCwgdHdvYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGV4dHJhID0gU1RSQlVGX0lOSVQ7CglzdGF0aWMgY2hhciAqcGFkZGluZzsKCXN0YXRpYyBpbnQgbGFiZWxfd2lkdGg7Cgljb25zdCBjaGFyICp3aGF0OwoJaW50IGxlbjsKCglpZiAoIXBhZGRpbmcpIHsKCQkvKiBJZiBESUZGX1NUQVRVU18qIHVzZXMgb3V0c2lkZSB0aGUgcmFuZ2UgW0EuLlpdLCB3ZSdyZSBpbiB0cm91YmxlICovCgkJbGFiZWxfd2lkdGggPSBtYXh3aWR0aCh3dF9zdGF0dXNfZGlmZl9zdGF0dXNfc3RyaW5nLCAnQScsICdaJyk7CgkJbGFiZWxfd2lkdGggKz0gc3RybGVuKCIgIik7CgkJcGFkZGluZyA9IHhtYWxsb2N6KGxhYmVsX3dpZHRoKTsKCQltZW1zZXQocGFkZGluZywgJyAnLCBsYWJlbF93aWR0aCk7Cgl9CgoJb25lX25hbWUgPSB0d29fbmFtZSA9IGl0LT5zdHJpbmc7Cglzd2l0Y2ggKGNoYW5nZV90eXBlKSB7CgljYXNlIFdUX1NUQVRVU19VUERBVEVEOgoJCXN0YXR1cyA9IGQtPmluZGV4X3N0YXR1czsKCQlpZiAoZC0+aGVhZF9wYXRoKQoJCQlvbmVfbmFtZSA9IGQtPmhlYWRfcGF0aDsKCQlicmVhazsKCWNhc2UgV1RfU1RBVFVTX0NIQU5HRUQ6CgkJaWYgKGQtPm5ld19zdWJtb2R1bGVfY29tbWl0cyB8fCBkLT5kaXJ0eV9zdWJtb2R1bGUpIHsKCQkJc3RyYnVmX2FkZHN0cigmZXh0cmEsICIgKCIpOwoJCQlpZiAoZC0+bmV3X3N1Ym1vZHVsZV9jb21taXRzKQoJCQkJc3RyYnVmX2FkZGYoJmV4dHJhLCBfKCJuZXcgY29tbWl0cywgIikpOwoJCQlpZiAoZC0+ZGlydHlfc3VibW9kdWxlICYgRElSVFlfU1VCTU9EVUxFX01PRElGSUVEKQoJCQkJc3RyYnVmX2FkZGYoJmV4dHJhLCBfKCJtb2RpZmllZCBjb250ZW50LCAiKSk7CgkJCWlmIChkLT5kaXJ0eV9zdWJtb2R1bGUgJiBESVJUWV9TVUJNT0RVTEVfVU5UUkFDS0VEKQoJCQkJc3RyYnVmX2FkZGYoJmV4dHJhLCBfKCJ1bnRyYWNrZWQgY29udGVudCwgIikpOwoJCQlzdHJidWZfc2V0bGVuKCZleHRyYSwgZXh0cmEubGVuIC0gMik7CgkJCXN0cmJ1Zl9hZGRjaCgmZXh0cmEsICcpJyk7CgkJfQoJCXN0YXR1cyA9IGQtPndvcmt0cmVlX3N0YXR1czsKCQlicmVhazsKCWRlZmF1bHQ6CgkJZGllKCJCVUc6IHVuaGFuZGxlZCBjaGFuZ2VfdHlwZSAlZCBpbiB3dF9zdGF0dXNfcHJpbnRfY2hhbmdlX2RhdGEiLAoJCSAgICBjaGFuZ2VfdHlwZSk7Cgl9CgoJb25lID0gcXVvdGVfcGF0aChvbmVfbmFtZSwgcy0+cHJlZml4LCAmb25lYnVmKTsKCXR3byA9IHF1b3RlX3BhdGgodHdvX25hbWUsIHMtPnByZWZpeCwgJnR3b2J1Zik7CgoJc3RhdHVzX3ByaW50ZihzLCBjb2xvcihXVF9TVEFUVVNfSEVBREVSLCBzKSwgIlx0Iik7Cgl3aGF0ID0gd3Rfc3RhdHVzX2RpZmZfc3RhdHVzX3N0cmluZyhzdGF0dXMpOwoJaWYgKCF3aGF0KQoJCWRpZShfKCJidWc6IHVuaGFuZGxlZCBkaWZmIHN0YXR1cyAlYyIpLCBzdGF0dXMpOwoJbGVuID0gbGFiZWxfd2lkdGggLSB1dGY4X3N0cndpZHRoKHdoYXQpOwoJYXNzZXJ0KGxlbiA+PSAwKTsKCWlmIChzdGF0dXMgPT0gRElGRl9TVEFUVVNfQ09QSUVEIHx8IHN0YXR1cyA9PSBESUZGX1NUQVRVU19SRU5BTUVEKQoJCXN0YXR1c19wcmludGZfbW9yZShzLCBjLCAiJXMlLipzJXMgLT4gJXMiLAoJCQkJICAgd2hhdCwgbGVuLCBwYWRkaW5nLCBvbmUsIHR3byk7CgllbHNlCgkJc3RhdHVzX3ByaW50Zl9tb3JlKHMsIGMsICIlcyUuKnMlcyIsCgkJCQkgICB3aGF0LCBsZW4sIHBhZGRpbmcsIG9uZSk7CglpZiAoZXh0cmEubGVuKSB7CgkJc3RhdHVzX3ByaW50Zl9tb3JlKHMsIGNvbG9yKFdUX1NUQVRVU19IRUFERVIsIHMpLCAiJXMiLCBleHRyYS5idWYpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZleHRyYSk7Cgl9CglzdGF0dXNfcHJpbnRmX21vcmUocywgR0lUX0NPTE9SX05PUk1BTCwgIlxuIik7CglzdHJidWZfcmVsZWFzZSgmb25lYnVmKTsKCXN0cmJ1Zl9yZWxlYXNlKCZ0d29idWYpOwp9CgpzdGF0aWMgdm9pZCB3dF9zdGF0dXNfY29sbGVjdF9jaGFuZ2VkX2NiKHN0cnVjdCBkaWZmX3F1ZXVlX3N0cnVjdCAqcSwKCQkJCQkgc3RydWN0IGRpZmZfb3B0aW9ucyAqb3B0aW9ucywKCQkJCQkgdm9pZCAqZGF0YSkKewoJc3RydWN0IHd0X3N0YXR1cyAqcyA9IGRhdGE7CglpbnQgaTsKCglpZiAoIXEtPm5yKQoJCXJldHVybjsKCXMtPndvcmtkaXJfZGlydHkgPSAxOwoJZm9yIChpID0gMDsgaSA8IHEtPm5yOyBpKyspIHsKCQlzdHJ1Y3QgZGlmZl9maWxlcGFpciAqcDsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXQ7CgkJc3RydWN0IHd0X3N0YXR1c19jaGFuZ2VfZGF0YSAqZDsKCgkJcCA9IHEtPnF1ZXVlW2ldOwoJCWl0ID0gc3RyaW5nX2xpc3RfaW5zZXJ0KCZzLT5jaGFuZ2UsIHAtPm9uZS0+cGF0aCk7CgkJZCA9IGl0LT51dGlsOwoJCWlmICghZCkgewoJCQlkID0geGNhbGxvYygxLCBzaXplb2YoKmQpKTsKCQkJaXQtPnV0aWwgPSBkOwoJCX0KCQlpZiAoIWQtPndvcmt0cmVlX3N0YXR1cykKCQkJZC0+d29ya3RyZWVfc3RhdHVzID0gcC0+c3RhdHVzOwoJCWQtPmRpcnR5X3N1Ym1vZHVsZSA9IHAtPnR3by0+ZGlydHlfc3VibW9kdWxlOwoJCWlmIChTX0lTR0lUTElOSyhwLT50d28tPm1vZGUpKQoJCQlkLT5uZXdfc3VibW9kdWxlX2NvbW1pdHMgPSAhIWhhc2hjbXAocC0+b25lLT5zaGExLCBwLT50d28tPnNoYTEpOwoJfQp9CgpzdGF0aWMgaW50IHVubWVyZ2VkX21hc2soY29uc3QgY2hhciAqcGF0aCkKewoJaW50IHBvcywgbWFzazsKCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2U7CgoJcG9zID0gY2FjaGVfbmFtZV9wb3MocGF0aCwgc3RybGVuKHBhdGgpKTsKCWlmICgwIDw9IHBvcykKCQlyZXR1cm4gMDsKCgltYXNrID0gMDsKCXBvcyA9IC1wb3MtMTsKCXdoaWxlIChwb3MgPCBhY3RpdmVfbnIpIHsKCQljZSA9IGFjdGl2ZV9jYWNoZVtwb3MrK107CgkJaWYgKHN0cmNtcChjZS0+bmFtZSwgcGF0aCkgfHwgIWNlX3N0YWdlKGNlKSkKCQkJYnJlYWs7CgkJbWFzayB8PSAoMSA8PCAoY2Vfc3RhZ2UoY2UpIC0gMSkpOwoJfQoJcmV0dXJuIG1hc2s7Cn0KCnN0YXRpYyB2b2lkIHd0X3N0YXR1c19jb2xsZWN0X3VwZGF0ZWRfY2Ioc3RydWN0IGRpZmZfcXVldWVfc3RydWN0ICpxLAoJCQkJCSBzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHRpb25zLAoJCQkJCSB2b2lkICpkYXRhKQp7CglzdHJ1Y3Qgd3Rfc3RhdHVzICpzID0gZGF0YTsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBxLT5ucjsgaSsrKSB7CgkJc3RydWN0IGRpZmZfZmlsZXBhaXIgKnA7CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0OwoJCXN0cnVjdCB3dF9zdGF0dXNfY2hhbmdlX2RhdGEgKmQ7CgoJCXAgPSBxLT5xdWV1ZVtpXTsKCQlpdCA9IHN0cmluZ19saXN0X2luc2VydCgmcy0+Y2hhbmdlLCBwLT50d28tPnBhdGgpOwoJCWQgPSBpdC0+dXRpbDsKCQlpZiAoIWQpIHsKCQkJZCA9IHhjYWxsb2MoMSwgc2l6ZW9mKCpkKSk7CgkJCWl0LT51dGlsID0gZDsKCQl9CgkJaWYgKCFkLT5pbmRleF9zdGF0dXMpCgkJCWQtPmluZGV4X3N0YXR1cyA9IHAtPnN0YXR1czsKCQlzd2l0Y2ggKHAtPnN0YXR1cykgewoJCWNhc2UgRElGRl9TVEFUVVNfQ09QSUVEOgoJCWNhc2UgRElGRl9TVEFUVVNfUkVOQU1FRDoKCQkJZC0+aGVhZF9wYXRoID0geHN0cmR1cChwLT5vbmUtPnBhdGgpOwoJCQlicmVhazsKCQljYXNlIERJRkZfU1RBVFVTX1VOTUVSR0VEOgoJCQlkLT5zdGFnZW1hc2sgPSB1bm1lcmdlZF9tYXNrKHAtPnR3by0+cGF0aCk7CgkJCWJyZWFrOwoJCX0KCX0KfQoKc3RhdGljIHZvaWQgd3Rfc3RhdHVzX2NvbGxlY3RfY2hhbmdlc193b3JrdHJlZShzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglzdHJ1Y3QgcmV2X2luZm8gcmV2OwoKCWluaXRfcmV2aXNpb25zKCZyZXYsIE5VTEwpOwoJc2V0dXBfcmV2aXNpb25zKDAsIE5VTEwsICZyZXYsIE5VTEwpOwoJcmV2LmRpZmZvcHQub3V0cHV0X2Zvcm1hdCB8PSBESUZGX0ZPUk1BVF9DQUxMQkFDSzsKCURJRkZfT1BUX1NFVCgmcmV2LmRpZmZvcHQsIERJUlRZX1NVQk1PRFVMRVMpOwoJaWYgKCFzLT5zaG93X3VudHJhY2tlZF9maWxlcykKCQlESUZGX09QVF9TRVQoJnJldi5kaWZmb3B0LCBJR05PUkVfVU5UUkFDS0VEX0lOX1NVQk1PRFVMRVMpOwoJaWYgKHMtPmlnbm9yZV9zdWJtb2R1bGVfYXJnKSB7CgkJRElGRl9PUFRfU0VUKCZyZXYuZGlmZm9wdCwgT1ZFUlJJREVfU1VCTU9EVUxFX0NPTkZJRyk7CgkJaGFuZGxlX2lnbm9yZV9zdWJtb2R1bGVzX2FyZygmcmV2LmRpZmZvcHQsIHMtPmlnbm9yZV9zdWJtb2R1bGVfYXJnKTsKCX0KCXJldi5kaWZmb3B0LmZvcm1hdF9jYWxsYmFjayA9IHd0X3N0YXR1c19jb2xsZWN0X2NoYW5nZWRfY2I7CglyZXYuZGlmZm9wdC5mb3JtYXRfY2FsbGJhY2tfZGF0YSA9IHM7Cgljb3B5X3BhdGhzcGVjKCZyZXYucHJ1bmVfZGF0YSwgJnMtPnBhdGhzcGVjKTsKCXJ1bl9kaWZmX2ZpbGVzKCZyZXYsIDApOwp9CgpzdGF0aWMgdm9pZCB3dF9zdGF0dXNfY29sbGVjdF9jaGFuZ2VzX2luZGV4KHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCXN0cnVjdCByZXZfaW5mbyByZXY7CglzdHJ1Y3Qgc2V0dXBfcmV2aXNpb25fb3B0IG9wdDsKCglpbml0X3JldmlzaW9ucygmcmV2LCBOVUxMKTsKCW1lbXNldCgmb3B0LCAwLCBzaXplb2Yob3B0KSk7CglvcHQuZGVmID0gcy0+aXNfaW5pdGlhbCA/IEVNUFRZX1RSRUVfU0hBMV9IRVggOiBzLT5yZWZlcmVuY2U7CglzZXR1cF9yZXZpc2lvbnMoMCwgTlVMTCwgJnJldiwgJm9wdCk7CgoJRElGRl9PUFRfU0VUKCZyZXYuZGlmZm9wdCwgT1ZFUlJJREVfU1VCTU9EVUxFX0NPTkZJRyk7CglpZiAocy0+aWdub3JlX3N1Ym1vZHVsZV9hcmcpIHsKCQloYW5kbGVfaWdub3JlX3N1Ym1vZHVsZXNfYXJnKCZyZXYuZGlmZm9wdCwgcy0+aWdub3JlX3N1Ym1vZHVsZV9hcmcpOwoJfSBlbHNlIHsKCQkvKgoJCSAqIFVubGVzcyB0aGUgdXNlciBkaWQgZXhwbGljaXRseSByZXF1ZXN0IGEgc3VibW9kdWxlIGlnbm9yZQoJCSAqIG1vZGUgYnkgcGFzc2luZyBhIGNvbW1hbmQgbGluZSBvcHRpb24gd2UgZG8gbm90IGlnbm9yZSBhbnkKCQkgKiBjaGFuZ2VkIHN1Ym1vZHVsZSBTSEEtMXMgd2hlbiBjb21wYXJpbmcgaW5kZXggYW5kIEhFQUQsIG5vCgkJICogbWF0dGVyIHdoYXQgaXMgY29uZmlndXJlZC4gT3RoZXJ3aXNlIHRoZSB1c2VyIHdvbid0IGJlCgkJICogc2hvd24gYW55IHN1Ym1vZHVsZXMgc2hlIG1hbnVhbGx5IGFkZGVkIChhbmQgd2hpY2ggYXJlCgkJICogc3RhZ2VkIHRvIGJlIGNvbW1pdHRlZCksIHdoaWNoIHdvdWxkIGJlIHJlYWxseSBjb25mdXNpbmcuCgkJICovCgkJaGFuZGxlX2lnbm9yZV9zdWJtb2R1bGVzX2FyZygmcmV2LmRpZmZvcHQsICJkaXJ0eSIpOwoJfQoKCXJldi5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgfD0gRElGRl9GT1JNQVRfQ0FMTEJBQ0s7CglyZXYuZGlmZm9wdC5mb3JtYXRfY2FsbGJhY2sgPSB3dF9zdGF0dXNfY29sbGVjdF91cGRhdGVkX2NiOwoJcmV2LmRpZmZvcHQuZm9ybWF0X2NhbGxiYWNrX2RhdGEgPSBzOwoJcmV2LmRpZmZvcHQuZGV0ZWN0X3JlbmFtZSA9IDE7CglyZXYuZGlmZm9wdC5yZW5hbWVfbGltaXQgPSAyMDA7CglyZXYuZGlmZm9wdC5icmVha19vcHQgPSAwOwoJY29weV9wYXRoc3BlYygmcmV2LnBydW5lX2RhdGEsICZzLT5wYXRoc3BlYyk7CglydW5fZGlmZl9pbmRleCgmcmV2LCAxKTsKfQoKc3RhdGljIHZvaWQgd3Rfc3RhdHVzX2NvbGxlY3RfY2hhbmdlc19pbml0aWFsKHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBhY3RpdmVfbnI7IGkrKykgewoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdDsKCQlzdHJ1Y3Qgd3Rfc3RhdHVzX2NoYW5nZV9kYXRhICpkOwoJCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBhY3RpdmVfY2FjaGVbaV07CgoJCWlmICghY2VfcGF0aF9tYXRjaChjZSwgJnMtPnBhdGhzcGVjLCBOVUxMKSkKCQkJY29udGludWU7CgkJaXQgPSBzdHJpbmdfbGlzdF9pbnNlcnQoJnMtPmNoYW5nZSwgY2UtPm5hbWUpOwoJCWQgPSBpdC0+dXRpbDsKCQlpZiAoIWQpIHsKCQkJZCA9IHhjYWxsb2MoMSwgc2l6ZW9mKCpkKSk7CgkJCWl0LT51dGlsID0gZDsKCQl9CgkJaWYgKGNlX3N0YWdlKGNlKSkgewoJCQlkLT5pbmRleF9zdGF0dXMgPSBESUZGX1NUQVRVU19VTk1FUkdFRDsKCQkJZC0+c3RhZ2VtYXNrIHw9ICgxIDw8IChjZV9zdGFnZShjZSkgLSAxKSk7CgkJfQoJCWVsc2UKCQkJZC0+aW5kZXhfc3RhdHVzID0gRElGRl9TVEFUVVNfQURERUQ7Cgl9Cn0KCnN0YXRpYyB2b2lkIHd0X3N0YXR1c19jb2xsZWN0X3VudHJhY2tlZChzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglpbnQgaTsKCXN0cnVjdCBkaXJfc3RydWN0IGRpcjsKCXVpbnQ2NF90IHRfYmVnaW4gPSBnZXRuYW5vdGltZSgpOwoKCWlmICghcy0+c2hvd191bnRyYWNrZWRfZmlsZXMpCgkJcmV0dXJuOwoKCW1lbXNldCgmZGlyLCAwLCBzaXplb2YoZGlyKSk7CglpZiAocy0+c2hvd191bnRyYWNrZWRfZmlsZXMgIT0gU0hPV19BTExfVU5UUkFDS0VEX0ZJTEVTKQoJCWRpci5mbGFncyB8PQoJCQlESVJfU0hPV19PVEhFUl9ESVJFQ1RPUklFUyB8IERJUl9ISURFX0VNUFRZX0RJUkVDVE9SSUVTOwoJaWYgKHMtPnNob3dfaWdub3JlZF9maWxlcykKCQlkaXIuZmxhZ3MgfD0gRElSX1NIT1dfSUdOT1JFRF9UT087CgllbHNlCgkJZGlyLnVudHJhY2tlZCA9IHRoZV9pbmRleC51bnRyYWNrZWQ7CglzZXR1cF9zdGFuZGFyZF9leGNsdWRlcygmZGlyKTsKCglmaWxsX2RpcmVjdG9yeSgmZGlyLCAmcy0+cGF0aHNwZWMpOwoKCWZvciAoaSA9IDA7IGkgPCBkaXIubnI7IGkrKykgewoJCXN0cnVjdCBkaXJfZW50cnkgKmVudCA9IGRpci5lbnRyaWVzW2ldOwoJCWlmIChjYWNoZV9uYW1lX2lzX290aGVyKGVudC0+bmFtZSwgZW50LT5sZW4pICYmCgkJICAgIGRpcl9wYXRoX21hdGNoKGVudCwgJnMtPnBhdGhzcGVjLCAwLCBOVUxMKSkKCQkJc3RyaW5nX2xpc3RfaW5zZXJ0KCZzLT51bnRyYWNrZWQsIGVudC0+bmFtZSk7CgkJZnJlZShlbnQpOwoJfQoKCWZvciAoaSA9IDA7IGkgPCBkaXIuaWdub3JlZF9ucjsgaSsrKSB7CgkJc3RydWN0IGRpcl9lbnRyeSAqZW50ID0gZGlyLmlnbm9yZWRbaV07CgkJaWYgKGNhY2hlX25hbWVfaXNfb3RoZXIoZW50LT5uYW1lLCBlbnQtPmxlbikgJiYKCQkgICAgZGlyX3BhdGhfbWF0Y2goZW50LCAmcy0+cGF0aHNwZWMsIDAsIE5VTEwpKQoJCQlzdHJpbmdfbGlzdF9pbnNlcnQoJnMtPmlnbm9yZWQsIGVudC0+bmFtZSk7CgkJZnJlZShlbnQpOwoJfQoKCWZyZWUoZGlyLmVudHJpZXMpOwoJZnJlZShkaXIuaWdub3JlZCk7CgljbGVhcl9kaXJlY3RvcnkoJmRpcik7CgoJaWYgKGFkdmljZV9zdGF0dXNfdV9vcHRpb24pCgkJcy0+dW50cmFja2VkX2luX21zID0gKGdldG5hbm90aW1lKCkgLSB0X2JlZ2luKSAvIDEwMDAwMDA7Cn0KCnZvaWQgd3Rfc3RhdHVzX2NvbGxlY3Qoc3RydWN0IHd0X3N0YXR1cyAqcykKewoJd3Rfc3RhdHVzX2NvbGxlY3RfY2hhbmdlc193b3JrdHJlZShzKTsKCglpZiAocy0+aXNfaW5pdGlhbCkKCQl3dF9zdGF0dXNfY29sbGVjdF9jaGFuZ2VzX2luaXRpYWwocyk7CgllbHNlCgkJd3Rfc3RhdHVzX2NvbGxlY3RfY2hhbmdlc19pbmRleChzKTsKCXd0X3N0YXR1c19jb2xsZWN0X3VudHJhY2tlZChzKTsKfQoKc3RhdGljIHZvaWQgd3Rfc3RhdHVzX3ByaW50X3VubWVyZ2VkKHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWludCBzaG93bl9oZWFkZXIgPSAwOwoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IHMtPmNoYW5nZS5ucjsgaSsrKSB7CgkJc3RydWN0IHd0X3N0YXR1c19jaGFuZ2VfZGF0YSAqZDsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXQ7CgkJaXQgPSAmKHMtPmNoYW5nZS5pdGVtc1tpXSk7CgkJZCA9IGl0LT51dGlsOwoJCWlmICghZC0+c3RhZ2VtYXNrKQoJCQljb250aW51ZTsKCQlpZiAoIXNob3duX2hlYWRlcikgewoJCQl3dF9zdGF0dXNfcHJpbnRfdW5tZXJnZWRfaGVhZGVyKHMpOwoJCQlzaG93bl9oZWFkZXIgPSAxOwoJCX0KCQl3dF9zdGF0dXNfcHJpbnRfdW5tZXJnZWRfZGF0YShzLCBpdCk7Cgl9CglpZiAoc2hvd25faGVhZGVyKQoJCXd0X3N0YXR1c19wcmludF90cmFpbGVyKHMpOwoKfQoKc3RhdGljIHZvaWQgd3Rfc3RhdHVzX3ByaW50X3VwZGF0ZWQoc3RydWN0IHd0X3N0YXR1cyAqcykKewoJaW50IHNob3duX2hlYWRlciA9IDA7CglpbnQgaTsKCglmb3IgKGkgPSAwOyBpIDwgcy0+Y2hhbmdlLm5yOyBpKyspIHsKCQlzdHJ1Y3Qgd3Rfc3RhdHVzX2NoYW5nZV9kYXRhICpkOwoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdDsKCQlpdCA9ICYocy0+Y2hhbmdlLml0ZW1zW2ldKTsKCQlkID0gaXQtPnV0aWw7CgkJaWYgKCFkLT5pbmRleF9zdGF0dXMgfHwKCQkgICAgZC0+aW5kZXhfc3RhdHVzID09IERJRkZfU1RBVFVTX1VOTUVSR0VEKQoJCQljb250aW51ZTsKCQlpZiAoIXNob3duX2hlYWRlcikgewoJCQl3dF9zdGF0dXNfcHJpbnRfY2FjaGVkX2hlYWRlcihzKTsKCQkJcy0+Y29tbWl0YWJsZSA9IDE7CgkJCXNob3duX2hlYWRlciA9IDE7CgkJfQoJCXd0X3N0YXR1c19wcmludF9jaGFuZ2VfZGF0YShzLCBXVF9TVEFUVVNfVVBEQVRFRCwgaXQpOwoJfQoJaWYgKHNob3duX2hlYWRlcikKCQl3dF9zdGF0dXNfcHJpbnRfdHJhaWxlcihzKTsKfQoKLyoKICogLTEgOiBoYXMgZGVsZXRlCiAqICAwIDogbm8gY2hhbmdlCiAqICAxIDogc29tZSBjaGFuZ2UgYnV0IG5vIGRlbGV0ZQogKi8Kc3RhdGljIGludCB3dF9zdGF0dXNfY2hlY2tfd29ya3RyZWVfY2hhbmdlcyhzdHJ1Y3Qgd3Rfc3RhdHVzICpzLAoJCQkJCSAgICAgaW50ICpkaXJ0eV9zdWJtb2R1bGVzKQp7CglpbnQgaTsKCWludCBjaGFuZ2VzID0gMDsKCgkqZGlydHlfc3VibW9kdWxlcyA9IDA7CgoJZm9yIChpID0gMDsgaSA8IHMtPmNoYW5nZS5ucjsgaSsrKSB7CgkJc3RydWN0IHd0X3N0YXR1c19jaGFuZ2VfZGF0YSAqZDsKCQlkID0gcy0+Y2hhbmdlLml0ZW1zW2ldLnV0aWw7CgkJaWYgKCFkLT53b3JrdHJlZV9zdGF0dXMgfHwKCQkgICAgZC0+d29ya3RyZWVfc3RhdHVzID09IERJRkZfU1RBVFVTX1VOTUVSR0VEKQoJCQljb250aW51ZTsKCQlpZiAoIWNoYW5nZXMpCgkJCWNoYW5nZXMgPSAxOwoJCWlmIChkLT5kaXJ0eV9zdWJtb2R1bGUpCgkJCSpkaXJ0eV9zdWJtb2R1bGVzID0gMTsKCQlpZiAoZC0+d29ya3RyZWVfc3RhdHVzID09IERJRkZfU1RBVFVTX0RFTEVURUQpCgkJCWNoYW5nZXMgPSAtMTsKCX0KCXJldHVybiBjaGFuZ2VzOwp9CgpzdGF0aWMgdm9pZCB3dF9zdGF0dXNfcHJpbnRfY2hhbmdlZChzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglpbnQgaSwgZGlydHlfc3VibW9kdWxlczsKCWludCB3b3JrdHJlZV9jaGFuZ2VzID0gd3Rfc3RhdHVzX2NoZWNrX3dvcmt0cmVlX2NoYW5nZXMocywgJmRpcnR5X3N1Ym1vZHVsZXMpOwoKCWlmICghd29ya3RyZWVfY2hhbmdlcykKCQlyZXR1cm47CgoJd3Rfc3RhdHVzX3ByaW50X2RpcnR5X2hlYWRlcihzLCB3b3JrdHJlZV9jaGFuZ2VzIDwgMCwgZGlydHlfc3VibW9kdWxlcyk7CgoJZm9yIChpID0gMDsgaSA8IHMtPmNoYW5nZS5ucjsgaSsrKSB7CgkJc3RydWN0IHd0X3N0YXR1c19jaGFuZ2VfZGF0YSAqZDsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXQ7CgkJaXQgPSAmKHMtPmNoYW5nZS5pdGVtc1tpXSk7CgkJZCA9IGl0LT51dGlsOwoJCWlmICghZC0+d29ya3RyZWVfc3RhdHVzIHx8CgkJICAgIGQtPndvcmt0cmVlX3N0YXR1cyA9PSBESUZGX1NUQVRVU19VTk1FUkdFRCkKCQkJY29udGludWU7CgkJd3Rfc3RhdHVzX3ByaW50X2NoYW5nZV9kYXRhKHMsIFdUX1NUQVRVU19DSEFOR0VELCBpdCk7Cgl9Cgl3dF9zdGF0dXNfcHJpbnRfdHJhaWxlcihzKTsKfQoKc3RhdGljIHZvaWQgd3Rfc3RhdHVzX3ByaW50X3N1Ym1vZHVsZV9zdW1tYXJ5KHN0cnVjdCB3dF9zdGF0dXMgKnMsIGludCB1bmNvbW1pdHRlZCkKewoJc3RydWN0IGNoaWxkX3Byb2Nlc3Mgc21fc3VtbWFyeSA9IENISUxEX1BST0NFU1NfSU5JVDsKCXN0cnVjdCBzdHJidWYgY21kX3N0ZG91dCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBzdW1tYXJ5ID0gU1RSQlVGX0lOSVQ7CgljaGFyICpzdW1tYXJ5X2NvbnRlbnQ7CgoJYXJndl9hcnJheV9wdXNoZigmc21fc3VtbWFyeS5lbnZfYXJyYXksICJHSVRfSU5ERVhfRklMRT0lcyIsCgkJCSBzLT5pbmRleF9maWxlKTsKCglhcmd2X2FycmF5X3B1c2goJnNtX3N1bW1hcnkuYXJncywgInN1Ym1vZHVsZSIpOwoJYXJndl9hcnJheV9wdXNoKCZzbV9zdW1tYXJ5LmFyZ3MsICJzdW1tYXJ5Iik7Cglhcmd2X2FycmF5X3B1c2goJnNtX3N1bW1hcnkuYXJncywgdW5jb21taXR0ZWQgPyAiLS1maWxlcyIgOiAiLS1jYWNoZWQiKTsKCWFyZ3ZfYXJyYXlfcHVzaCgmc21fc3VtbWFyeS5hcmdzLCAiLS1mb3Itc3RhdHVzIik7Cglhcmd2X2FycmF5X3B1c2goJnNtX3N1bW1hcnkuYXJncywgIi0tc3VtbWFyeS1saW1pdCIpOwoJYXJndl9hcnJheV9wdXNoZigmc21fc3VtbWFyeS5hcmdzLCAiJWQiLCBzLT5zdWJtb2R1bGVfc3VtbWFyeSk7CglpZiAoIXVuY29tbWl0dGVkKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmc21fc3VtbWFyeS5hcmdzLCBzLT5hbWVuZCA/ICJIRUFEXiIgOiAiSEVBRCIpOwoKCXNtX3N1bW1hcnkuZ2l0X2NtZCA9IDE7CglzbV9zdW1tYXJ5Lm5vX3N0ZGluID0gMTsKCgljYXB0dXJlX2NvbW1hbmQoJnNtX3N1bW1hcnksICZjbWRfc3Rkb3V0LCAxMDI0KTsKCgkvKiBwcmVwZW5kIGhlYWRlciwgb25seSBpZiB0aGVyZSdzIGFuIGFjdHVhbCBvdXRwdXQgKi8KCWlmIChjbWRfc3Rkb3V0LmxlbikgewoJCWlmICh1bmNvbW1pdHRlZCkKCQkJc3RyYnVmX2FkZHN0cigmc3VtbWFyeSwgXygiU3VibW9kdWxlcyBjaGFuZ2VkIGJ1dCBub3QgdXBkYXRlZDoiKSk7CgkJZWxzZQoJCQlzdHJidWZfYWRkc3RyKCZzdW1tYXJ5LCBfKCJTdWJtb2R1bGUgY2hhbmdlcyB0byBiZSBjb21taXR0ZWQ6IikpOwoJCXN0cmJ1Zl9hZGRzdHIoJnN1bW1hcnksICJcblxuIik7Cgl9CglzdHJidWZfYWRkYnVmKCZzdW1tYXJ5LCAmY21kX3N0ZG91dCk7CglzdHJidWZfcmVsZWFzZSgmY21kX3N0ZG91dCk7CgoJaWYgKHMtPmRpc3BsYXlfY29tbWVudF9wcmVmaXgpIHsKCQlzaXplX3QgbGVuOwoJCXN1bW1hcnlfY29udGVudCA9IHN0cmJ1Zl9kZXRhY2goJnN1bW1hcnksICZsZW4pOwoJCXN0cmJ1Zl9hZGRfY29tbWVudGVkX2xpbmVzKCZzdW1tYXJ5LCBzdW1tYXJ5X2NvbnRlbnQsIGxlbik7CgkJZnJlZShzdW1tYXJ5X2NvbnRlbnQpOwoJfQoKCWZwdXRzKHN1bW1hcnkuYnVmLCBzLT5mcCk7CglzdHJidWZfcmVsZWFzZSgmc3VtbWFyeSk7Cn0KCnN0YXRpYyB2b2lkIHd0X3N0YXR1c19wcmludF9vdGhlcihzdHJ1Y3Qgd3Rfc3RhdHVzICpzLAoJCQkJICBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmwsCgkJCQkgIGNvbnN0IGNoYXIgKndoYXQsCgkJCQkgIGNvbnN0IGNoYXIgKmhvdykKewoJaW50IGk7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJc3RhdGljIHN0cnVjdCBzdHJpbmdfbGlzdCBvdXRwdXQgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCXN0cnVjdCBjb2x1bW5fb3B0aW9ucyBjb3B0czsKCglpZiAoIWwtPm5yKQoJCXJldHVybjsKCgl3dF9zdGF0dXNfcHJpbnRfb3RoZXJfaGVhZGVyKHMsIHdoYXQsIGhvdyk7CgoJZm9yIChpID0gMDsgaSA8IGwtPm5yOyBpKyspIHsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXQ7CgkJY29uc3QgY2hhciAqcGF0aDsKCQlpdCA9ICYobC0+aXRlbXNbaV0pOwoJCXBhdGggPSBxdW90ZV9wYXRoKGl0LT5zdHJpbmcsIHMtPnByZWZpeCwgJmJ1Zik7CgkJaWYgKGNvbHVtbl9hY3RpdmUocy0+Y29sb3B0cykpIHsKCQkJc3RyaW5nX2xpc3RfYXBwZW5kKCZvdXRwdXQsIHBhdGgpOwoJCQljb250aW51ZTsKCQl9CgkJc3RhdHVzX3ByaW50ZihzLCBjb2xvcihXVF9TVEFUVVNfSEVBREVSLCBzKSwgIlx0Iik7CgkJc3RhdHVzX3ByaW50Zl9tb3JlKHMsIGNvbG9yKFdUX1NUQVRVU19VTlRSQUNLRUQsIHMpLAoJCQkJICAgIiVzXG4iLCBwYXRoKTsKCX0KCglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCWlmICghY29sdW1uX2FjdGl2ZShzLT5jb2xvcHRzKSkKCQlnb3RvIGNvbmNsdWRlOwoKCXN0cmJ1Zl9hZGRmKCZidWYsICIlcyVzXHQlcyIsCgkJICAgIGNvbG9yKFdUX1NUQVRVU19IRUFERVIsIHMpLAoJCSAgICBzLT5kaXNwbGF5X2NvbW1lbnRfcHJlZml4ID8gIiMiIDogIiIsCgkJICAgIGNvbG9yKFdUX1NUQVRVU19VTlRSQUNLRUQsIHMpKTsKCW1lbXNldCgmY29wdHMsIDAsIHNpemVvZihjb3B0cykpOwoJY29wdHMucGFkZGluZyA9IDE7Cgljb3B0cy5pbmRlbnQgPSBidWYuYnVmOwoJaWYgKHdhbnRfY29sb3Iocy0+dXNlX2NvbG9yKSkKCQljb3B0cy5ubCA9IEdJVF9DT0xPUl9SRVNFVCAiXG4iOwoJcHJpbnRfY29sdW1ucygmb3V0cHV0LCBzLT5jb2xvcHRzLCAmY29wdHMpOwoJc3RyaW5nX2xpc3RfY2xlYXIoJm91dHB1dCwgMCk7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKY29uY2x1ZGU6CglzdGF0dXNfcHJpbnRmX2xuKHMsIEdJVF9DT0xPUl9OT1JNQUwsICIlcyIsICIiKTsKfQoKdm9pZCB3dF9zdGF0dXNfdHJ1bmNhdGVfbWVzc2FnZV9hdF9jdXRfbGluZShzdHJ1Y3Qgc3RyYnVmICpidWYpCnsKCWNvbnN0IGNoYXIgKnA7CglzdHJ1Y3Qgc3RyYnVmIHBhdHRlcm4gPSBTVFJCVUZfSU5JVDsKCglzdHJidWZfYWRkZigmcGF0dGVybiwgIlxuJWMgJXMiLCBjb21tZW50X2xpbmVfY2hhciwgY3V0X2xpbmUpOwoJaWYgKHN0YXJ0c193aXRoKGJ1Zi0+YnVmLCBwYXR0ZXJuLmJ1ZiArIDEpKQoJCXN0cmJ1Zl9zZXRsZW4oYnVmLCAwKTsKCWVsc2UgaWYgKChwID0gc3Ryc3RyKGJ1Zi0+YnVmLCBwYXR0ZXJuLmJ1ZikpKQoJCXN0cmJ1Zl9zZXRsZW4oYnVmLCBwIC0gYnVmLT5idWYgKyAxKTsKCXN0cmJ1Zl9yZWxlYXNlKCZwYXR0ZXJuKTsKfQoKdm9pZCB3dF9zdGF0dXNfYWRkX2N1dF9saW5lKEZJTEUgKmZwKQp7Cgljb25zdCBjaGFyICpleHBsYW5hdGlvbiA9IF8oIkRvIG5vdCB0b3VjaCB0aGUgbGluZSBhYm92ZS5cbkV2ZXJ5dGhpbmcgYmVsb3cgd2lsbCBiZSByZW1vdmVkLiIpOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCglmcHJpbnRmKGZwLCAiJWMgJXMiLCBjb21tZW50X2xpbmVfY2hhciwgY3V0X2xpbmUpOwoJc3RyYnVmX2FkZF9jb21tZW50ZWRfbGluZXMoJmJ1ZiwgZXhwbGFuYXRpb24sIHN0cmxlbihleHBsYW5hdGlvbikpOwoJZnB1dHMoYnVmLmJ1ZiwgZnApOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7Cn0KCnN0YXRpYyB2b2lkIHd0X3N0YXR1c19wcmludF92ZXJib3NlKHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCXN0cnVjdCByZXZfaW5mbyByZXY7CglzdHJ1Y3Qgc2V0dXBfcmV2aXNpb25fb3B0IG9wdDsKCWludCBkaXJ0eV9zdWJtb2R1bGVzOwoJY29uc3QgY2hhciAqYyA9IGNvbG9yKFdUX1NUQVRVU19IRUFERVIsIHMpOwoKCWluaXRfcmV2aXNpb25zKCZyZXYsIE5VTEwpOwoJRElGRl9PUFRfU0VUKCZyZXYuZGlmZm9wdCwgQUxMT1dfVEVYVENPTlYpOwoKCW1lbXNldCgmb3B0LCAwLCBzaXplb2Yob3B0KSk7CglvcHQuZGVmID0gcy0+aXNfaW5pdGlhbCA/IEVNUFRZX1RSRUVfU0hBMV9IRVggOiBzLT5yZWZlcmVuY2U7CglzZXR1cF9yZXZpc2lvbnMoMCwgTlVMTCwgJnJldiwgJm9wdCk7CgoJcmV2LmRpZmZvcHQub3V0cHV0X2Zvcm1hdCB8PSBESUZGX0ZPUk1BVF9QQVRDSDsKCXJldi5kaWZmb3B0LmRldGVjdF9yZW5hbWUgPSAxOwoJcmV2LmRpZmZvcHQuZmlsZSA9IHMtPmZwOwoJcmV2LmRpZmZvcHQuY2xvc2VfZmlsZSA9IDA7CgkvKgoJICogSWYgd2UncmUgbm90IGdvaW5nIHRvIHN0ZG91dCwgdGhlbiB3ZSBkZWZpbml0ZWx5IGRvbid0CgkgKiB3YW50IGNvbG9yLCBzaW5jZSB3ZSBhcmUgZ29pbmcgdG8gdGhlIGNvbW1pdCBtZXNzYWdlCgkgKiBmaWxlIChhbmQgZXZlbiB0aGUgImF1dG8iIHNldHRpbmcgd29uJ3Qgd29yaywgc2luY2UgaXQKCSAqIHdpbGwgaGF2ZSBjaGVja2VkIGlzYXR0eSBvbiBzdGRvdXQpLiBCdXQgd2UgdGhlbiBkbyB3YW50CgkgKiB0byBpbnNlcnQgdGhlIHNjaXNzb3IgbGluZSBoZXJlIHRvIHJlbGlhYmx5IHJlbW92ZSB0aGUKCSAqIGRpZmYgYmVmb3JlIGNvbW1pdHRpbmcuCgkgKi8KCWlmIChzLT5mcCAhPSBzdGRvdXQpIHsKCQlyZXYuZGlmZm9wdC51c2VfY29sb3IgPSAwOwoJCXd0X3N0YXR1c19hZGRfY3V0X2xpbmUocy0+ZnApOwoJfQoJaWYgKHMtPnZlcmJvc2UgPiAxICYmIHMtPmNvbW1pdGFibGUpIHsKCQkvKiBwcmludF91cGRhdGVkKCkgcHJpbnRlZCBhIGhlYWRlciwgc28gZG8gd2UgKi8KCQlpZiAocy0+ZnAgIT0gc3Rkb3V0KQoJCQl3dF9zdGF0dXNfcHJpbnRfdHJhaWxlcihzKTsKCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGMsIF8oIkNoYW5nZXMgdG8gYmUgY29tbWl0dGVkOiIpKTsKCQlyZXYuZGlmZm9wdC5hX3ByZWZpeCA9ICJjLyI7CgkJcmV2LmRpZmZvcHQuYl9wcmVmaXggPSAiaS8iOwoJfSAvKiBlbHNlIHVzZSBwcmVmaXggYXMgcGVyIHVzZXIgY29uZmlnICovCglydW5fZGlmZl9pbmRleCgmcmV2LCAxKTsKCWlmIChzLT52ZXJib3NlID4gMSAmJgoJICAgIHd0X3N0YXR1c19jaGVja193b3JrdHJlZV9jaGFuZ2VzKHMsICZkaXJ0eV9zdWJtb2R1bGVzKSkgewoJCXN0YXR1c19wcmludGZfbG4ocywgYywKCQkJIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIik7CgkJc3RhdHVzX3ByaW50Zl9sbihzLCBjLCBfKCJDaGFuZ2VzIG5vdCBzdGFnZWQgZm9yIGNvbW1pdDoiKSk7CgkJc2V0dXBfd29ya190cmVlKCk7CgkJcmV2LmRpZmZvcHQuYV9wcmVmaXggPSAiaS8iOwoJCXJldi5kaWZmb3B0LmJfcHJlZml4ID0gIncvIjsKCQlydW5fZGlmZl9maWxlcygmcmV2LCAwKTsKCX0KfQoKc3RhdGljIHZvaWQgd3Rfc3RhdHVzX3ByaW50X3RyYWNraW5nKHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKmNwLCAqZXAsICpicmFuY2hfbmFtZTsKCXN0cnVjdCBicmFuY2ggKmJyYW5jaDsKCWNoYXIgY29tbWVudF9saW5lX3N0cmluZ1szXTsKCWludCBpOwoKCWFzc2VydChzLT5icmFuY2ggJiYgIXMtPmlzX2luaXRpYWwpOwoJaWYgKCFza2lwX3ByZWZpeChzLT5icmFuY2gsICJyZWZzL2hlYWRzLyIsICZicmFuY2hfbmFtZSkpCgkJcmV0dXJuOwoJYnJhbmNoID0gYnJhbmNoX2dldChicmFuY2hfbmFtZSk7CglpZiAoIWZvcm1hdF90cmFja2luZ19pbmZvKGJyYW5jaCwgJnNiKSkKCQlyZXR1cm47CgoJaSA9IDA7CglpZiAocy0+ZGlzcGxheV9jb21tZW50X3ByZWZpeCkgewoJCWNvbW1lbnRfbGluZV9zdHJpbmdbaSsrXSA9IGNvbW1lbnRfbGluZV9jaGFyOwoJCWNvbW1lbnRfbGluZV9zdHJpbmdbaSsrXSA9ICcgJzsKCX0KCWNvbW1lbnRfbGluZV9zdHJpbmdbaV0gPSAnXDAnOwoKCWZvciAoY3AgPSBzYi5idWY7IChlcCA9IHN0cmNocihjcCwgJ1xuJykpICE9IE5VTEw7IGNwID0gZXAgKyAxKQoJCWNvbG9yX2ZwcmludGZfbG4ocy0+ZnAsIGNvbG9yKFdUX1NUQVRVU19IRUFERVIsIHMpLAoJCQkJICIlcyUuKnMiLCBjb21tZW50X2xpbmVfc3RyaW5nLAoJCQkJIChpbnQpKGVwIC0gY3ApLCBjcCk7CglpZiAocy0+ZGlzcGxheV9jb21tZW50X3ByZWZpeCkKCQljb2xvcl9mcHJpbnRmX2xuKHMtPmZwLCBjb2xvcihXVF9TVEFUVVNfSEVBREVSLCBzKSwgIiVjIiwKCQkJCSBjb21tZW50X2xpbmVfY2hhcik7CgllbHNlCgkJZnB1dHMoIiIsIHMtPmZwKTsKfQoKc3RhdGljIGludCBoYXNfdW5tZXJnZWQoc3RydWN0IHd0X3N0YXR1cyAqcykKewoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IHMtPmNoYW5nZS5ucjsgaSsrKSB7CgkJc3RydWN0IHd0X3N0YXR1c19jaGFuZ2VfZGF0YSAqZDsKCQlkID0gcy0+Y2hhbmdlLml0ZW1zW2ldLnV0aWw7CgkJaWYgKGQtPnN0YWdlbWFzaykKCQkJcmV0dXJuIDE7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgc2hvd19tZXJnZV9pbl9wcm9ncmVzcyhzdHJ1Y3Qgd3Rfc3RhdHVzICpzLAoJCQkJc3RydWN0IHd0X3N0YXR1c19zdGF0ZSAqc3RhdGUsCgkJCQljb25zdCBjaGFyICpjb2xvcikKewoJaWYgKGhhc191bm1lcmdlZChzKSkgewoJCXN0YXR1c19wcmludGZfbG4ocywgY29sb3IsIF8oIllvdSBoYXZlIHVubWVyZ2VkIHBhdGhzLiIpKTsKCQlpZiAocy0+aGludHMpCgkJCXN0YXR1c19wcmludGZfbG4ocywgY29sb3IsCgkJCQlfKCIgIChmaXggY29uZmxpY3RzIGFuZCBydW4gXCJnaXQgY29tbWl0XCIpIikpOwoJfSBlbHNlIHsKCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGNvbG9yLAoJCQlfKCJBbGwgY29uZmxpY3RzIGZpeGVkIGJ1dCB5b3UgYXJlIHN0aWxsIG1lcmdpbmcuIikpOwoJCWlmIChzLT5oaW50cykKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBjb2xvciwKCQkJCV8oIiAgKHVzZSBcImdpdCBjb21taXRcIiB0byBjb25jbHVkZSBtZXJnZSkiKSk7Cgl9Cgl3dF9zdGF0dXNfcHJpbnRfdHJhaWxlcihzKTsKfQoKc3RhdGljIHZvaWQgc2hvd19hbV9pbl9wcm9ncmVzcyhzdHJ1Y3Qgd3Rfc3RhdHVzICpzLAoJCQkJc3RydWN0IHd0X3N0YXR1c19zdGF0ZSAqc3RhdGUsCgkJCQljb25zdCBjaGFyICpjb2xvcikKewoJc3RhdHVzX3ByaW50Zl9sbihzLCBjb2xvciwKCQlfKCJZb3UgYXJlIGluIHRoZSBtaWRkbGUgb2YgYW4gYW0gc2Vzc2lvbi4iKSk7CglpZiAoc3RhdGUtPmFtX2VtcHR5X3BhdGNoKQoJCXN0YXR1c19wcmludGZfbG4ocywgY29sb3IsCgkJCV8oIlRoZSBjdXJyZW50IHBhdGNoIGlzIGVtcHR5LiIpKTsKCWlmIChzLT5oaW50cykgewoJCWlmICghc3RhdGUtPmFtX2VtcHR5X3BhdGNoKQoJCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGNvbG9yLAoJCQkJXygiICAoZml4IGNvbmZsaWN0cyBhbmQgdGhlbiBydW4gXCJnaXQgYW0gLS1jb250aW51ZVwiKSIpKTsKCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGNvbG9yLAoJCQlfKCIgICh1c2UgXCJnaXQgYW0gLS1za2lwXCIgdG8gc2tpcCB0aGlzIHBhdGNoKSIpKTsKCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGNvbG9yLAoJCQlfKCIgICh1c2UgXCJnaXQgYW0gLS1hYm9ydFwiIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGJyYW5jaCkiKSk7Cgl9Cgl3dF9zdGF0dXNfcHJpbnRfdHJhaWxlcihzKTsKfQoKc3RhdGljIGNoYXIgKnJlYWRfbGluZV9mcm9tX2dpdF9wYXRoKGNvbnN0IGNoYXIgKmZpbGVuYW1lKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJRklMRSAqZnAgPSBmb3BlbihnaXRfcGF0aCgiJXMiLCBmaWxlbmFtZSksICJyIik7CglpZiAoIWZwKSB7CgkJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CgkJcmV0dXJuIE5VTEw7Cgl9CglzdHJidWZfZ2V0bGluZV9sZigmYnVmLCBmcCk7CglpZiAoIWZjbG9zZShmcCkpIHsKCQlyZXR1cm4gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCX0gZWxzZSB7CgkJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CgkJcmV0dXJuIE5VTEw7Cgl9Cn0KCnN0YXRpYyBpbnQgc3BsaXRfY29tbWl0X2luX3Byb2dyZXNzKHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWludCBzcGxpdF9pbl9wcm9ncmVzcyA9IDA7CgljaGFyICpoZWFkID0gcmVhZF9saW5lX2Zyb21fZ2l0X3BhdGgoIkhFQUQiKTsKCWNoYXIgKm9yaWdfaGVhZCA9IHJlYWRfbGluZV9mcm9tX2dpdF9wYXRoKCJPUklHX0hFQUQiKTsKCWNoYXIgKnJlYmFzZV9hbWVuZCA9IHJlYWRfbGluZV9mcm9tX2dpdF9wYXRoKCJyZWJhc2UtbWVyZ2UvYW1lbmQiKTsKCWNoYXIgKnJlYmFzZV9vcmlnX2hlYWQgPSByZWFkX2xpbmVfZnJvbV9naXRfcGF0aCgicmViYXNlLW1lcmdlL29yaWctaGVhZCIpOwoKCWlmICghaGVhZCB8fCAhb3JpZ19oZWFkIHx8ICFyZWJhc2VfYW1lbmQgfHwgIXJlYmFzZV9vcmlnX2hlYWQgfHwKCSAgICAhcy0+YnJhbmNoIHx8IHN0cmNtcChzLT5icmFuY2gsICJIRUFEIikpCgkJcmV0dXJuIHNwbGl0X2luX3Byb2dyZXNzOwoKCWlmICghc3RyY21wKHJlYmFzZV9hbWVuZCwgcmViYXNlX29yaWdfaGVhZCkpIHsKCQlpZiAoc3RyY21wKGhlYWQsIHJlYmFzZV9hbWVuZCkpCgkJCXNwbGl0X2luX3Byb2dyZXNzID0gMTsKCX0gZWxzZSBpZiAoc3RyY21wKG9yaWdfaGVhZCwgcmViYXNlX29yaWdfaGVhZCkpIHsKCQlzcGxpdF9pbl9wcm9ncmVzcyA9IDE7Cgl9CgoJaWYgKCFzLT5hbWVuZCAmJiAhcy0+bm93YXJuICYmICFzLT53b3JrZGlyX2RpcnR5KQoJCXNwbGl0X2luX3Byb2dyZXNzID0gMDsKCglmcmVlKGhlYWQpOwoJZnJlZShvcmlnX2hlYWQpOwoJZnJlZShyZWJhc2VfYW1lbmQpOwoJZnJlZShyZWJhc2Vfb3JpZ19oZWFkKTsKCXJldHVybiBzcGxpdF9pbl9wcm9ncmVzczsKfQoKLyoKICogVHVybgogKiAicGljayBkNmEyZjAzMDNlODk3ZWMyNTdkZDBlMGEzOWE1Y2NiNzA5YmMyMDQ3IHNvbWUgbWVzc2FnZSIKICogaW50bwogKiAicGljayBkNmEyZjAzIHNvbWUgbWVzc2FnZSIKICoKICogVGhlIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGUgbGluZSBkb2VzIG5vdCBjb250YWluIHVzZWxlc3Mgc3BhY2VzCiAqIGJlZm9yZSBvciBhZnRlciB0aGUgY29tbWFuZC4KICovCnN0YXRpYyB2b2lkIGFiYnJldl9zaGExX2luX2xpbmUoc3RydWN0IHN0cmJ1ZiAqbGluZSkKewoJc3RydWN0IHN0cmJ1ZiAqKnNwbGl0OwoJaW50IGk7CgoJaWYgKHN0YXJ0c193aXRoKGxpbmUtPmJ1ZiwgImV4ZWMgIikgfHwKCSAgICBzdGFydHNfd2l0aChsaW5lLT5idWYsICJ4ICIpKQoJCXJldHVybjsKCglzcGxpdCA9IHN0cmJ1Zl9zcGxpdF9tYXgobGluZSwgJyAnLCAzKTsKCWlmIChzcGxpdFswXSAmJiBzcGxpdFsxXSkgewoJCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgkJY29uc3QgY2hhciAqYWJicmV2OwoKCQkvKgoJCSAqIHN0cmJ1Zl9zcGxpdF9tYXggbGVmdCBhIHNwYWNlLiBUcmltIGl0IGFuZCByZS1hZGQKCQkgKiBpdCBhZnRlciBhYmJyZXZpYXRpb24uCgkJICovCgkJc3RyYnVmX3RyaW0oc3BsaXRbMV0pOwoJCWlmICghZ2V0X3NoYTEoc3BsaXRbMV0tPmJ1Ziwgc2hhMSkpIHsKCQkJYWJicmV2ID0gZmluZF91bmlxdWVfYWJicmV2KHNoYTEsIERFRkFVTFRfQUJCUkVWKTsKCQkJc3RyYnVmX3Jlc2V0KHNwbGl0WzFdKTsKCQkJc3RyYnVmX2FkZGYoc3BsaXRbMV0sICIlcyAiLCBhYmJyZXYpOwoJCQlzdHJidWZfcmVzZXQobGluZSk7CgkJCWZvciAoaSA9IDA7IHNwbGl0W2ldOyBpKyspCgkJCQlzdHJidWZfYWRkZihsaW5lLCAiJXMiLCBzcGxpdFtpXS0+YnVmKTsKCQl9Cgl9CglzdHJidWZfbGlzdF9mcmVlKHNwbGl0KTsKfQoKc3RhdGljIHZvaWQgcmVhZF9yZWJhc2VfdG9kb2xpc3QoY29uc3QgY2hhciAqZm5hbWUsIHN0cnVjdCBzdHJpbmdfbGlzdCAqbGluZXMpCnsKCXN0cnVjdCBzdHJidWYgbGluZSA9IFNUUkJVRl9JTklUOwoJRklMRSAqZiA9IGZvcGVuKGdpdF9wYXRoKCIlcyIsIGZuYW1lKSwgInIiKTsKCglpZiAoIWYpCgkJZGllX2Vycm5vKCJDb3VsZCBub3Qgb3BlbiBmaWxlICVzIGZvciByZWFkaW5nIiwKCQkJICBnaXRfcGF0aCgiJXMiLCBmbmFtZSkpOwoJd2hpbGUgKCFzdHJidWZfZ2V0bGluZV9sZigmbGluZSwgZikpIHsKCQlpZiAobGluZS5sZW4gJiYgbGluZS5idWZbMF0gPT0gY29tbWVudF9saW5lX2NoYXIpCgkJCWNvbnRpbnVlOwoJCXN0cmJ1Zl90cmltKCZsaW5lKTsKCQlpZiAoIWxpbmUubGVuKQoJCQljb250aW51ZTsKCQlhYmJyZXZfc2hhMV9pbl9saW5lKCZsaW5lKTsKCQlzdHJpbmdfbGlzdF9hcHBlbmQobGluZXMsIGxpbmUuYnVmKTsKCX0KfQoKc3RhdGljIHZvaWQgc2hvd19yZWJhc2VfaW5mb3JtYXRpb24oc3RydWN0IHd0X3N0YXR1cyAqcywKCQkJCQlzdHJ1Y3Qgd3Rfc3RhdHVzX3N0YXRlICpzdGF0ZSwKCQkJCQljb25zdCBjaGFyICpjb2xvcikKewoJaWYgKHN0YXRlLT5yZWJhc2VfaW50ZXJhY3RpdmVfaW5fcHJvZ3Jlc3MpIHsKCQlpbnQgaTsKCQlpbnQgbnJfbGluZXNfdG9fc2hvdyA9IDI7CgoJCXN0cnVjdCBzdHJpbmdfbGlzdCBoYXZlX2RvbmUgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3QgeWV0X3RvX2RvID0gU1RSSU5HX0xJU1RfSU5JVF9EVVA7CgoJCXJlYWRfcmViYXNlX3RvZG9saXN0KCJyZWJhc2UtbWVyZ2UvZG9uZSIsICZoYXZlX2RvbmUpOwoJCXJlYWRfcmViYXNlX3RvZG9saXN0KCJyZWJhc2UtbWVyZ2UvZ2l0LXJlYmFzZS10b2RvIiwgJnlldF90b19kbyk7CgoJCWlmIChoYXZlX2RvbmUubnIgPT0gMCkKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBjb2xvciwgXygiTm8gY29tbWFuZHMgZG9uZS4iKSk7CgkJZWxzZSB7CgkJCXN0YXR1c19wcmludGZfbG4ocywgY29sb3IsCgkJCQlRXygiTGFzdCBjb21tYW5kIGRvbmUgKCVkIGNvbW1hbmQgZG9uZSk6IiwKCQkJCQkiTGFzdCBjb21tYW5kcyBkb25lICglZCBjb21tYW5kcyBkb25lKToiLAoJCQkJCWhhdmVfZG9uZS5uciksCgkJCQloYXZlX2RvbmUubnIpOwoJCQlmb3IgKGkgPSAoaGF2ZV9kb25lLm5yID4gbnJfbGluZXNfdG9fc2hvdykKCQkJCT8gaGF2ZV9kb25lLm5yIC0gbnJfbGluZXNfdG9fc2hvdyA6IDA7CgkJCQlpIDwgaGF2ZV9kb25lLm5yOwoJCQkJaSsrKQoJCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBjb2xvciwgIiAgICVzIiwgaGF2ZV9kb25lLml0ZW1zW2ldLnN0cmluZyk7CgkJCWlmIChoYXZlX2RvbmUubnIgPiBucl9saW5lc190b19zaG93ICYmIHMtPmhpbnRzKQoJCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBjb2xvciwKCQkJCQlfKCIgIChzZWUgbW9yZSBpbiBmaWxlICVzKSIpLCBnaXRfcGF0aCgicmViYXNlLW1lcmdlL2RvbmUiKSk7CgkJfQoKCQlpZiAoeWV0X3RvX2RvLm5yID09IDApCgkJCXN0YXR1c19wcmludGZfbG4ocywgY29sb3IsCgkJCQkJIF8oIk5vIGNvbW1hbmRzIHJlbWFpbmluZy4iKSk7CgkJZWxzZSB7CgkJCXN0YXR1c19wcmludGZfbG4ocywgY29sb3IsCgkJCQlRXygiTmV4dCBjb21tYW5kIHRvIGRvICglZCByZW1haW5pbmcgY29tbWFuZCk6IiwKCQkJCQkiTmV4dCBjb21tYW5kcyB0byBkbyAoJWQgcmVtYWluaW5nIGNvbW1hbmRzKToiLAoJCQkJCXlldF90b19kby5uciksCgkJCQl5ZXRfdG9fZG8ubnIpOwoJCQlmb3IgKGkgPSAwOyBpIDwgbnJfbGluZXNfdG9fc2hvdyAmJiBpIDwgeWV0X3RvX2RvLm5yOyBpKyspCgkJCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGNvbG9yLCAiICAgJXMiLCB5ZXRfdG9fZG8uaXRlbXNbaV0uc3RyaW5nKTsKCQkJaWYgKHMtPmhpbnRzKQoJCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBjb2xvciwKCQkJCQlfKCIgICh1c2UgXCJnaXQgcmViYXNlIC0tZWRpdC10b2RvXCIgdG8gdmlldyBhbmQgZWRpdCkiKSk7CgkJfQoJCXN0cmluZ19saXN0X2NsZWFyKCZ5ZXRfdG9fZG8sIDApOwoJCXN0cmluZ19saXN0X2NsZWFyKCZoYXZlX2RvbmUsIDApOwoJfQp9CgpzdGF0aWMgdm9pZCBwcmludF9yZWJhc2Vfc3RhdGUoc3RydWN0IHd0X3N0YXR1cyAqcywKCQkJCXN0cnVjdCB3dF9zdGF0dXNfc3RhdGUgKnN0YXRlLAoJCQkJY29uc3QgY2hhciAqY29sb3IpCnsKCWlmIChzdGF0ZS0+YnJhbmNoKQoJCXN0YXR1c19wcmludGZfbG4ocywgY29sb3IsCgkJCQkgXygiWW91IGFyZSBjdXJyZW50bHkgcmViYXNpbmcgYnJhbmNoICclcycgb24gJyVzJy4iKSwKCQkJCSBzdGF0ZS0+YnJhbmNoLAoJCQkJIHN0YXRlLT5vbnRvKTsKCWVsc2UKCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGNvbG9yLAoJCQkJIF8oIllvdSBhcmUgY3VycmVudGx5IHJlYmFzaW5nLiIpKTsKfQoKc3RhdGljIHZvaWQgc2hvd19yZWJhc2VfaW5fcHJvZ3Jlc3Moc3RydWN0IHd0X3N0YXR1cyAqcywKCQkJCXN0cnVjdCB3dF9zdGF0dXNfc3RhdGUgKnN0YXRlLAoJCQkJY29uc3QgY2hhciAqY29sb3IpCnsKCXN0cnVjdCBzdGF0IHN0OwoKCXNob3dfcmViYXNlX2luZm9ybWF0aW9uKHMsIHN0YXRlLCBjb2xvcik7CglpZiAoaGFzX3VubWVyZ2VkKHMpKSB7CgkJcHJpbnRfcmViYXNlX3N0YXRlKHMsIHN0YXRlLCBjb2xvcik7CgkJaWYgKHMtPmhpbnRzKSB7CgkJCXN0YXR1c19wcmludGZfbG4ocywgY29sb3IsCgkJCQlfKCIgIChmaXggY29uZmxpY3RzIGFuZCB0aGVuIHJ1biBcImdpdCByZWJhc2UgLS1jb250aW51ZVwiKSIpKTsKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBjb2xvciwKCQkJCV8oIiAgKHVzZSBcImdpdCByZWJhc2UgLS1za2lwXCIgdG8gc2tpcCB0aGlzIHBhdGNoKSIpKTsKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBjb2xvciwKCQkJCV8oIiAgKHVzZSBcImdpdCByZWJhc2UgLS1hYm9ydFwiIHRvIGNoZWNrIG91dCB0aGUgb3JpZ2luYWwgYnJhbmNoKSIpKTsKCQl9Cgl9IGVsc2UgaWYgKHN0YXRlLT5yZWJhc2VfaW5fcHJvZ3Jlc3MgfHwgIXN0YXQoZ2l0X3BhdGhfbWVyZ2VfbXNnKCksICZzdCkpIHsKCQlwcmludF9yZWJhc2Vfc3RhdGUocywgc3RhdGUsIGNvbG9yKTsKCQlpZiAocy0+aGludHMpCgkJCXN0YXR1c19wcmludGZfbG4ocywgY29sb3IsCgkJCQlfKCIgIChhbGwgY29uZmxpY3RzIGZpeGVkOiBydW4gXCJnaXQgcmViYXNlIC0tY29udGludWVcIikiKSk7Cgl9IGVsc2UgaWYgKHNwbGl0X2NvbW1pdF9pbl9wcm9ncmVzcyhzKSkgewoJCWlmIChzdGF0ZS0+YnJhbmNoKQoJCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGNvbG9yLAoJCQkJCSBfKCJZb3UgYXJlIGN1cnJlbnRseSBzcGxpdHRpbmcgYSBjb21taXQgd2hpbGUgcmViYXNpbmcgYnJhbmNoICclcycgb24gJyVzJy4iKSwKCQkJCQkgc3RhdGUtPmJyYW5jaCwKCQkJCQkgc3RhdGUtPm9udG8pOwoJCWVsc2UKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBjb2xvciwKCQkJCQkgXygiWW91IGFyZSBjdXJyZW50bHkgc3BsaXR0aW5nIGEgY29tbWl0IGR1cmluZyBhIHJlYmFzZS4iKSk7CgkJaWYgKHMtPmhpbnRzKQoJCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGNvbG9yLAoJCQkJXygiICAoT25jZSB5b3VyIHdvcmtpbmcgZGlyZWN0b3J5IGlzIGNsZWFuLCBydW4gXCJnaXQgcmViYXNlIC0tY29udGludWVcIikiKSk7Cgl9IGVsc2UgewoJCWlmIChzdGF0ZS0+YnJhbmNoKQoJCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGNvbG9yLAoJCQkJCSBfKCJZb3UgYXJlIGN1cnJlbnRseSBlZGl0aW5nIGEgY29tbWl0IHdoaWxlIHJlYmFzaW5nIGJyYW5jaCAnJXMnIG9uICclcycuIiksCgkJCQkJIHN0YXRlLT5icmFuY2gsCgkJCQkJIHN0YXRlLT5vbnRvKTsKCQllbHNlCgkJCXN0YXR1c19wcmludGZfbG4ocywgY29sb3IsCgkJCQkJIF8oIllvdSBhcmUgY3VycmVudGx5IGVkaXRpbmcgYSBjb21taXQgZHVyaW5nIGEgcmViYXNlLiIpKTsKCQlpZiAocy0+aGludHMgJiYgIXMtPmFtZW5kKSB7CgkJCXN0YXR1c19wcmludGZfbG4ocywgY29sb3IsCgkJCQlfKCIgICh1c2UgXCJnaXQgY29tbWl0IC0tYW1lbmRcIiB0byBhbWVuZCB0aGUgY3VycmVudCBjb21taXQpIikpOwoJCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGNvbG9yLAoJCQkJXygiICAodXNlIFwiZ2l0IHJlYmFzZSAtLWNvbnRpbnVlXCIgb25jZSB5b3UgYXJlIHNhdGlzZmllZCB3aXRoIHlvdXIgY2hhbmdlcykiKSk7CgkJfQoJfQoJd3Rfc3RhdHVzX3ByaW50X3RyYWlsZXIocyk7Cn0KCnN0YXRpYyB2b2lkIHNob3dfY2hlcnJ5X3BpY2tfaW5fcHJvZ3Jlc3Moc3RydWN0IHd0X3N0YXR1cyAqcywKCQkJCQlzdHJ1Y3Qgd3Rfc3RhdHVzX3N0YXRlICpzdGF0ZSwKCQkJCQljb25zdCBjaGFyICpjb2xvcikKewoJc3RhdHVzX3ByaW50Zl9sbihzLCBjb2xvciwgXygiWW91IGFyZSBjdXJyZW50bHkgY2hlcnJ5LXBpY2tpbmcgY29tbWl0ICVzLiIpLAoJCQlmaW5kX3VuaXF1ZV9hYmJyZXYoc3RhdGUtPmNoZXJyeV9waWNrX2hlYWRfc2hhMSwgREVGQVVMVF9BQkJSRVYpKTsKCWlmIChzLT5oaW50cykgewoJCWlmIChoYXNfdW5tZXJnZWQocykpCgkJCXN0YXR1c19wcmludGZfbG4ocywgY29sb3IsCgkJCQlfKCIgIChmaXggY29uZmxpY3RzIGFuZCBydW4gXCJnaXQgY2hlcnJ5LXBpY2sgLS1jb250aW51ZVwiKSIpKTsKCQllbHNlCgkJCXN0YXR1c19wcmludGZfbG4ocywgY29sb3IsCgkJCQlfKCIgIChhbGwgY29uZmxpY3RzIGZpeGVkOiBydW4gXCJnaXQgY2hlcnJ5LXBpY2sgLS1jb250aW51ZVwiKSIpKTsKCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGNvbG9yLAoJCQlfKCIgICh1c2UgXCJnaXQgY2hlcnJ5LXBpY2sgLS1hYm9ydFwiIHRvIGNhbmNlbCB0aGUgY2hlcnJ5LXBpY2sgb3BlcmF0aW9uKSIpKTsKCX0KCXd0X3N0YXR1c19wcmludF90cmFpbGVyKHMpOwp9CgpzdGF0aWMgdm9pZCBzaG93X3JldmVydF9pbl9wcm9ncmVzcyhzdHJ1Y3Qgd3Rfc3RhdHVzICpzLAoJCQkJCXN0cnVjdCB3dF9zdGF0dXNfc3RhdGUgKnN0YXRlLAoJCQkJCWNvbnN0IGNoYXIgKmNvbG9yKQp7CglzdGF0dXNfcHJpbnRmX2xuKHMsIGNvbG9yLCBfKCJZb3UgYXJlIGN1cnJlbnRseSByZXZlcnRpbmcgY29tbWl0ICVzLiIpLAoJCQkgZmluZF91bmlxdWVfYWJicmV2KHN0YXRlLT5yZXZlcnRfaGVhZF9zaGExLCBERUZBVUxUX0FCQlJFVikpOwoJaWYgKHMtPmhpbnRzKSB7CgkJaWYgKGhhc191bm1lcmdlZChzKSkKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBjb2xvciwKCQkJCV8oIiAgKGZpeCBjb25mbGljdHMgYW5kIHJ1biBcImdpdCByZXZlcnQgLS1jb250aW51ZVwiKSIpKTsKCQllbHNlCgkJCXN0YXR1c19wcmludGZfbG4ocywgY29sb3IsCgkJCQlfKCIgIChhbGwgY29uZmxpY3RzIGZpeGVkOiBydW4gXCJnaXQgcmV2ZXJ0IC0tY29udGludWVcIikiKSk7CgkJc3RhdHVzX3ByaW50Zl9sbihzLCBjb2xvciwKCQkJXygiICAodXNlIFwiZ2l0IHJldmVydCAtLWFib3J0XCIgdG8gY2FuY2VsIHRoZSByZXZlcnQgb3BlcmF0aW9uKSIpKTsKCX0KCXd0X3N0YXR1c19wcmludF90cmFpbGVyKHMpOwp9CgpzdGF0aWMgdm9pZCBzaG93X2Jpc2VjdF9pbl9wcm9ncmVzcyhzdHJ1Y3Qgd3Rfc3RhdHVzICpzLAoJCQkJc3RydWN0IHd0X3N0YXR1c19zdGF0ZSAqc3RhdGUsCgkJCQljb25zdCBjaGFyICpjb2xvcikKewoJaWYgKHN0YXRlLT5icmFuY2gpCgkJc3RhdHVzX3ByaW50Zl9sbihzLCBjb2xvciwKCQkJCSBfKCJZb3UgYXJlIGN1cnJlbnRseSBiaXNlY3RpbmcsIHN0YXJ0ZWQgZnJvbSBicmFuY2ggJyVzJy4iKSwKCQkJCSBzdGF0ZS0+YnJhbmNoKTsKCWVsc2UKCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGNvbG9yLAoJCQkJIF8oIllvdSBhcmUgY3VycmVudGx5IGJpc2VjdGluZy4iKSk7CglpZiAocy0+aGludHMpCgkJc3RhdHVzX3ByaW50Zl9sbihzLCBjb2xvciwKCQkJXygiICAodXNlIFwiZ2l0IGJpc2VjdCByZXNldFwiIHRvIGdldCBiYWNrIHRvIHRoZSBvcmlnaW5hbCBicmFuY2gpIikpOwoJd3Rfc3RhdHVzX3ByaW50X3RyYWlsZXIocyk7Cn0KCi8qCiAqIEV4dHJhY3QgYnJhbmNoIGluZm9ybWF0aW9uIGZyb20gcmViYXNlL2Jpc2VjdAogKi8Kc3RhdGljIGNoYXIgKmdldF9icmFuY2goY29uc3Qgc3RydWN0IHdvcmt0cmVlICp3dCwgY29uc3QgY2hhciAqcGF0aCkKewoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCWNvbnN0IGNoYXIgKmJyYW5jaF9uYW1lOwoKCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgd29ya3RyZWVfZ2l0X3BhdGgod3QsICIlcyIsIHBhdGgpLCAwKSA8PSAwKQoJCWdvdG8gZ290X25vdGhpbmc7CgoJd2hpbGUgKHNiLmxlbiAmJiBzYi5idWZbc2IubGVuIC0gMV0gPT0gJ1xuJykKCQlzdHJidWZfc2V0bGVuKCZzYiwgc2IubGVuIC0gMSk7CglpZiAoIXNiLmxlbikKCQlnb3RvIGdvdF9ub3RoaW5nOwoJaWYgKHNraXBfcHJlZml4KHNiLmJ1ZiwgInJlZnMvaGVhZHMvIiwgJmJyYW5jaF9uYW1lKSkKCQlzdHJidWZfcmVtb3ZlKCZzYiwgMCwgYnJhbmNoX25hbWUgLSBzYi5idWYpOwoJZWxzZSBpZiAoc3RhcnRzX3dpdGgoc2IuYnVmLCAicmVmcy8iKSkKCQk7CgllbHNlIGlmICghZ2V0X3NoYTFfaGV4KHNiLmJ1Ziwgc2hhMSkpIHsKCQljb25zdCBjaGFyICphYmJyZXY7CgkJYWJicmV2ID0gZmluZF91bmlxdWVfYWJicmV2KHNoYTEsIERFRkFVTFRfQUJCUkVWKTsKCQlzdHJidWZfcmVzZXQoJnNiKTsKCQlzdHJidWZfYWRkc3RyKCZzYiwgYWJicmV2KTsKCX0gZWxzZSBpZiAoIXN0cmNtcChzYi5idWYsICJkZXRhY2hlZCBIRUFEIikpIC8qIHJlYmFzZSAqLwoJCWdvdG8gZ290X25vdGhpbmc7CgllbHNlCQkJLyogYmlzZWN0ICovCgkJOwoJcmV0dXJuIHN0cmJ1Zl9kZXRhY2goJnNiLCBOVUxMKTsKCmdvdF9ub3RoaW5nOgoJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCXJldHVybiBOVUxMOwp9CgpzdHJ1Y3QgZ3JhYl8xc3Rfc3dpdGNoX2NiZGF0YSB7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZjsKCXVuc2lnbmVkIGNoYXIgbnNoYTFbMjBdOwp9OwoKc3RhdGljIGludCBncmFiXzFzdF9zd2l0Y2godW5zaWduZWQgY2hhciAqb3NoYTEsIHVuc2lnbmVkIGNoYXIgKm5zaGExLAoJCQkgICBjb25zdCBjaGFyICplbWFpbCwgdW5zaWduZWQgbG9uZyB0aW1lc3RhbXAsIGludCB0eiwKCQkJICAgY29uc3QgY2hhciAqbWVzc2FnZSwgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IGdyYWJfMXN0X3N3aXRjaF9jYmRhdGEgKmNiID0gY2JfZGF0YTsKCWNvbnN0IGNoYXIgKnRhcmdldCA9IE5VTEwsICplbmQ7CgoJaWYgKCFza2lwX3ByZWZpeChtZXNzYWdlLCAiY2hlY2tvdXQ6IG1vdmluZyBmcm9tICIsICZtZXNzYWdlKSkKCQlyZXR1cm4gMDsKCXRhcmdldCA9IHN0cnN0cihtZXNzYWdlLCAiIHRvICIpOwoJaWYgKCF0YXJnZXQpCgkJcmV0dXJuIDA7Cgl0YXJnZXQgKz0gc3RybGVuKCIgdG8gIik7CglzdHJidWZfcmVzZXQoJmNiLT5idWYpOwoJaGFzaGNweShjYi0+bnNoYTEsIG5zaGExKTsKCWVuZCA9IHN0cmNocm51bCh0YXJnZXQsICdcbicpOwoJc3RyYnVmX2FkZCgmY2ItPmJ1ZiwgdGFyZ2V0LCBlbmQgLSB0YXJnZXQpOwoJaWYgKCFzdHJjbXAoY2ItPmJ1Zi5idWYsICJIRUFEIikpIHsKCQkvKiBIRUFEIGlzIHJlbGF0aXZlLiBSZXNvbHZlIGl0IHRvIHRoZSByaWdodCByZWZsb2cgZW50cnkuICovCgkJc3RyYnVmX3Jlc2V0KCZjYi0+YnVmKTsKCQlzdHJidWZfYWRkc3RyKCZjYi0+YnVmLAoJCQkgICAgICBmaW5kX3VuaXF1ZV9hYmJyZXYobnNoYTEsIERFRkFVTFRfQUJCUkVWKSk7Cgl9CglyZXR1cm4gMTsKfQoKc3RhdGljIHZvaWQgd3Rfc3RhdHVzX2dldF9kZXRhY2hlZF9mcm9tKHN0cnVjdCB3dF9zdGF0dXNfc3RhdGUgKnN0YXRlKQp7CglzdHJ1Y3QgZ3JhYl8xc3Rfc3dpdGNoX2NiZGF0YSBjYjsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgljaGFyICpyZWYgPSBOVUxMOwoKCXN0cmJ1Zl9pbml0KCZjYi5idWYsIDApOwoJaWYgKGZvcl9lYWNoX3JlZmxvZ19lbnRfcmV2ZXJzZSgiSEVBRCIsIGdyYWJfMXN0X3N3aXRjaCwgJmNiKSA8PSAwKSB7CgkJc3RyYnVmX3JlbGVhc2UoJmNiLmJ1Zik7CgkJcmV0dXJuOwoJfQoKCWlmIChkd2ltX3JlZihjYi5idWYuYnVmLCBjYi5idWYubGVuLCBzaGExLCAmcmVmKSA9PSAxICYmCgkgICAgLyogc2hhMSBpcyBhIGNvbW1pdD8gbWF0Y2ggd2l0aG91dCBmdXJ0aGVyIGxvb2t1cCAqLwoJICAgICghaGFzaGNtcChjYi5uc2hhMSwgc2hhMSkgfHwKCSAgICAgLyogcGVyaGFwcyBzaGExIGlzIGEgdGFnLCB0cnkgdG8gZGVyZWZlcmVuY2UgdG8gYSBjb21taXQgKi8KCSAgICAgKChjb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkoc2hhMSwgMSkpICE9IE5VTEwgJiYKCSAgICAgICFoYXNoY21wKGNiLm5zaGExLCBjb21taXQtPm9iamVjdC5vaWQuaGFzaCkpKSkgewoJCWNvbnN0IGNoYXIgKmZyb20gPSByZWY7CgkJaWYgKCFza2lwX3ByZWZpeChmcm9tLCAicmVmcy90YWdzLyIsICZmcm9tKSkKCQkJc2tpcF9wcmVmaXgoZnJvbSwgInJlZnMvcmVtb3Rlcy8iLCAmZnJvbSk7CgkJc3RhdGUtPmRldGFjaGVkX2Zyb20gPSB4c3RyZHVwKGZyb20pOwoJfSBlbHNlCgkJc3RhdGUtPmRldGFjaGVkX2Zyb20gPQoJCQl4c3RyZHVwKGZpbmRfdW5pcXVlX2FiYnJldihjYi5uc2hhMSwgREVGQVVMVF9BQkJSRVYpKTsKCWhhc2hjcHkoc3RhdGUtPmRldGFjaGVkX3NoYTEsIGNiLm5zaGExKTsKCXN0YXRlLT5kZXRhY2hlZF9hdCA9ICFnZXRfc2hhMSgiSEVBRCIsIHNoYTEpICYmCgkJCSAgICAgIWhhc2hjbXAoc2hhMSwgc3RhdGUtPmRldGFjaGVkX3NoYTEpOwoKCWZyZWUocmVmKTsKCXN0cmJ1Zl9yZWxlYXNlKCZjYi5idWYpOwp9CgppbnQgd3Rfc3RhdHVzX2NoZWNrX3JlYmFzZShjb25zdCBzdHJ1Y3Qgd29ya3RyZWUgKnd0LAoJCQkgICBzdHJ1Y3Qgd3Rfc3RhdHVzX3N0YXRlICpzdGF0ZSkKewoJc3RydWN0IHN0YXQgc3Q7CgoJaWYgKCFzdGF0KHdvcmt0cmVlX2dpdF9wYXRoKHd0LCAicmViYXNlLWFwcGx5IiksICZzdCkpIHsKCQlpZiAoIXN0YXQod29ya3RyZWVfZ2l0X3BhdGgod3QsICJyZWJhc2UtYXBwbHkvYXBwbHlpbmciKSwgJnN0KSkgewoJCQlzdGF0ZS0+YW1faW5fcHJvZ3Jlc3MgPSAxOwoJCQlpZiAoIXN0YXQod29ya3RyZWVfZ2l0X3BhdGgod3QsICJyZWJhc2UtYXBwbHkvcGF0Y2giKSwgJnN0KSAmJiAhc3Quc3Rfc2l6ZSkKCQkJCXN0YXRlLT5hbV9lbXB0eV9wYXRjaCA9IDE7CgkJfSBlbHNlIHsKCQkJc3RhdGUtPnJlYmFzZV9pbl9wcm9ncmVzcyA9IDE7CgkJCXN0YXRlLT5icmFuY2ggPSBnZXRfYnJhbmNoKHd0LCAicmViYXNlLWFwcGx5L2hlYWQtbmFtZSIpOwoJCQlzdGF0ZS0+b250byA9IGdldF9icmFuY2god3QsICJyZWJhc2UtYXBwbHkvb250byIpOwoJCX0KCX0gZWxzZSBpZiAoIXN0YXQod29ya3RyZWVfZ2l0X3BhdGgod3QsICJyZWJhc2UtbWVyZ2UiKSwgJnN0KSkgewoJCWlmICghc3RhdCh3b3JrdHJlZV9naXRfcGF0aCh3dCwgInJlYmFzZS1tZXJnZS9pbnRlcmFjdGl2ZSIpLCAmc3QpKQoJCQlzdGF0ZS0+cmViYXNlX2ludGVyYWN0aXZlX2luX3Byb2dyZXNzID0gMTsKCQllbHNlCgkJCXN0YXRlLT5yZWJhc2VfaW5fcHJvZ3Jlc3MgPSAxOwoJCXN0YXRlLT5icmFuY2ggPSBnZXRfYnJhbmNoKHd0LCAicmViYXNlLW1lcmdlL2hlYWQtbmFtZSIpOwoJCXN0YXRlLT5vbnRvID0gZ2V0X2JyYW5jaCh3dCwgInJlYmFzZS1tZXJnZS9vbnRvIik7Cgl9IGVsc2UKCQlyZXR1cm4gMDsKCXJldHVybiAxOwp9CgppbnQgd3Rfc3RhdHVzX2NoZWNrX2Jpc2VjdChjb25zdCBzdHJ1Y3Qgd29ya3RyZWUgKnd0LAoJCQkgICBzdHJ1Y3Qgd3Rfc3RhdHVzX3N0YXRlICpzdGF0ZSkKewoJc3RydWN0IHN0YXQgc3Q7CgoJaWYgKCFzdGF0KHdvcmt0cmVlX2dpdF9wYXRoKHd0LCAiQklTRUNUX0xPRyIpLCAmc3QpKSB7CgkJc3RhdGUtPmJpc2VjdF9pbl9wcm9ncmVzcyA9IDE7CgkJc3RhdGUtPmJyYW5jaCA9IGdldF9icmFuY2god3QsICJCSVNFQ1RfU1RBUlQiKTsKCQlyZXR1cm4gMTsKCX0KCXJldHVybiAwOwp9Cgp2b2lkIHd0X3N0YXR1c19nZXRfc3RhdGUoc3RydWN0IHd0X3N0YXR1c19zdGF0ZSAqc3RhdGUsCgkJCSBpbnQgZ2V0X2RldGFjaGVkX2Zyb20pCnsKCXN0cnVjdCBzdGF0IHN0OwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCglpZiAoIXN0YXQoZ2l0X3BhdGhfbWVyZ2VfaGVhZCgpLCAmc3QpKSB7CgkJc3RhdGUtPm1lcmdlX2luX3Byb2dyZXNzID0gMTsKCX0gZWxzZSBpZiAod3Rfc3RhdHVzX2NoZWNrX3JlYmFzZShOVUxMLCBzdGF0ZSkpIHsKCQk7CQkvKiBhbGwgc2V0ICovCgl9IGVsc2UgaWYgKCFzdGF0KGdpdF9wYXRoX2NoZXJyeV9waWNrX2hlYWQoKSwgJnN0KSAmJgoJCQkhZ2V0X3NoYTEoIkNIRVJSWV9QSUNLX0hFQUQiLCBzaGExKSkgewoJCXN0YXRlLT5jaGVycnlfcGlja19pbl9wcm9ncmVzcyA9IDE7CgkJaGFzaGNweShzdGF0ZS0+Y2hlcnJ5X3BpY2tfaGVhZF9zaGExLCBzaGExKTsKCX0KCXd0X3N0YXR1c19jaGVja19iaXNlY3QoTlVMTCwgc3RhdGUpOwoJaWYgKCFzdGF0KGdpdF9wYXRoX3JldmVydF9oZWFkKCksICZzdCkgJiYKCSAgICAhZ2V0X3NoYTEoIlJFVkVSVF9IRUFEIiwgc2hhMSkpIHsKCQlzdGF0ZS0+cmV2ZXJ0X2luX3Byb2dyZXNzID0gMTsKCQloYXNoY3B5KHN0YXRlLT5yZXZlcnRfaGVhZF9zaGExLCBzaGExKTsKCX0KCglpZiAoZ2V0X2RldGFjaGVkX2Zyb20pCgkJd3Rfc3RhdHVzX2dldF9kZXRhY2hlZF9mcm9tKHN0YXRlKTsKfQoKc3RhdGljIHZvaWQgd3Rfc3RhdHVzX3ByaW50X3N0YXRlKHN0cnVjdCB3dF9zdGF0dXMgKnMsCgkJCQkgIHN0cnVjdCB3dF9zdGF0dXNfc3RhdGUgKnN0YXRlKQp7Cgljb25zdCBjaGFyICpzdGF0ZV9jb2xvciA9IGNvbG9yKFdUX1NUQVRVU19IRUFERVIsIHMpOwoJaWYgKHN0YXRlLT5tZXJnZV9pbl9wcm9ncmVzcykKCQlzaG93X21lcmdlX2luX3Byb2dyZXNzKHMsIHN0YXRlLCBzdGF0ZV9jb2xvcik7CgllbHNlIGlmIChzdGF0ZS0+YW1faW5fcHJvZ3Jlc3MpCgkJc2hvd19hbV9pbl9wcm9ncmVzcyhzLCBzdGF0ZSwgc3RhdGVfY29sb3IpOwoJZWxzZSBpZiAoc3RhdGUtPnJlYmFzZV9pbl9wcm9ncmVzcyB8fCBzdGF0ZS0+cmViYXNlX2ludGVyYWN0aXZlX2luX3Byb2dyZXNzKQoJCXNob3dfcmViYXNlX2luX3Byb2dyZXNzKHMsIHN0YXRlLCBzdGF0ZV9jb2xvcik7CgllbHNlIGlmIChzdGF0ZS0+Y2hlcnJ5X3BpY2tfaW5fcHJvZ3Jlc3MpCgkJc2hvd19jaGVycnlfcGlja19pbl9wcm9ncmVzcyhzLCBzdGF0ZSwgc3RhdGVfY29sb3IpOwoJZWxzZSBpZiAoc3RhdGUtPnJldmVydF9pbl9wcm9ncmVzcykKCQlzaG93X3JldmVydF9pbl9wcm9ncmVzcyhzLCBzdGF0ZSwgc3RhdGVfY29sb3IpOwoJaWYgKHN0YXRlLT5iaXNlY3RfaW5fcHJvZ3Jlc3MpCgkJc2hvd19iaXNlY3RfaW5fcHJvZ3Jlc3Mocywgc3RhdGUsIHN0YXRlX2NvbG9yKTsKfQoKdm9pZCB3dF9zdGF0dXNfcHJpbnQoc3RydWN0IHd0X3N0YXR1cyAqcykKewoJY29uc3QgY2hhciAqYnJhbmNoX2NvbG9yID0gY29sb3IoV1RfU1RBVFVTX09OQlJBTkNILCBzKTsKCWNvbnN0IGNoYXIgKmJyYW5jaF9zdGF0dXNfY29sb3IgPSBjb2xvcihXVF9TVEFUVVNfSEVBREVSLCBzKTsKCXN0cnVjdCB3dF9zdGF0dXNfc3RhdGUgc3RhdGU7CgoJbWVtc2V0KCZzdGF0ZSwgMCwgc2l6ZW9mKHN0YXRlKSk7Cgl3dF9zdGF0dXNfZ2V0X3N0YXRlKCZzdGF0ZSwKCQkJICAgIHMtPmJyYW5jaCAmJiAhc3RyY21wKHMtPmJyYW5jaCwgIkhFQUQiKSk7CgoJaWYgKHMtPmJyYW5jaCkgewoJCWNvbnN0IGNoYXIgKm9uX3doYXQgPSBfKCJPbiBicmFuY2ggIik7CgkJY29uc3QgY2hhciAqYnJhbmNoX25hbWUgPSBzLT5icmFuY2g7CgkJaWYgKCFzdHJjbXAoYnJhbmNoX25hbWUsICJIRUFEIikpIHsKCQkJYnJhbmNoX3N0YXR1c19jb2xvciA9IGNvbG9yKFdUX1NUQVRVU19OT0JSQU5DSCwgcyk7CgkJCWlmIChzdGF0ZS5yZWJhc2VfaW5fcHJvZ3Jlc3MgfHwgc3RhdGUucmViYXNlX2ludGVyYWN0aXZlX2luX3Byb2dyZXNzKSB7CgkJCQlpZiAoc3RhdGUucmViYXNlX2ludGVyYWN0aXZlX2luX3Byb2dyZXNzKQoJCQkJCW9uX3doYXQgPSBfKCJpbnRlcmFjdGl2ZSByZWJhc2UgaW4gcHJvZ3Jlc3M7IG9udG8gIik7CgkJCQllbHNlCgkJCQkJb25fd2hhdCA9IF8oInJlYmFzZSBpbiBwcm9ncmVzczsgb250byAiKTsKCQkJCWJyYW5jaF9uYW1lID0gc3RhdGUub250bzsKCQkJfSBlbHNlIGlmIChzdGF0ZS5kZXRhY2hlZF9mcm9tKSB7CgkJCQlicmFuY2hfbmFtZSA9IHN0YXRlLmRldGFjaGVkX2Zyb207CgkJCQlpZiAoc3RhdGUuZGV0YWNoZWRfYXQpCgkJCQkJb25fd2hhdCA9IF8oIkhFQUQgZGV0YWNoZWQgYXQgIik7CgkJCQllbHNlCgkJCQkJb25fd2hhdCA9IF8oIkhFQUQgZGV0YWNoZWQgZnJvbSAiKTsKCQkJfSBlbHNlIHsKCQkJCWJyYW5jaF9uYW1lID0gIiI7CgkJCQlvbl93aGF0ID0gXygiTm90IGN1cnJlbnRseSBvbiBhbnkgYnJhbmNoLiIpOwoJCQl9CgkJfSBlbHNlCgkJCXNraXBfcHJlZml4KGJyYW5jaF9uYW1lLCAicmVmcy9oZWFkcy8iLCAmYnJhbmNoX25hbWUpOwoJCXN0YXR1c19wcmludGYocywgY29sb3IoV1RfU1RBVFVTX0hFQURFUiwgcyksICIlcyIsICIiKTsKCQlzdGF0dXNfcHJpbnRmX21vcmUocywgYnJhbmNoX3N0YXR1c19jb2xvciwgIiVzIiwgb25fd2hhdCk7CgkJc3RhdHVzX3ByaW50Zl9tb3JlKHMsIGJyYW5jaF9jb2xvciwgIiVzXG4iLCBicmFuY2hfbmFtZSk7CgkJaWYgKCFzLT5pc19pbml0aWFsKQoJCQl3dF9zdGF0dXNfcHJpbnRfdHJhY2tpbmcocyk7Cgl9CgoJd3Rfc3RhdHVzX3ByaW50X3N0YXRlKHMsICZzdGF0ZSk7CglmcmVlKHN0YXRlLmJyYW5jaCk7CglmcmVlKHN0YXRlLm9udG8pOwoJZnJlZShzdGF0ZS5kZXRhY2hlZF9mcm9tKTsKCglpZiAocy0+aXNfaW5pdGlhbCkgewoJCXN0YXR1c19wcmludGZfbG4ocywgY29sb3IoV1RfU1RBVFVTX0hFQURFUiwgcyksICIlcyIsICIiKTsKCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGNvbG9yKFdUX1NUQVRVU19IRUFERVIsIHMpLCBfKCJJbml0aWFsIGNvbW1pdCIpKTsKCQlzdGF0dXNfcHJpbnRmX2xuKHMsIGNvbG9yKFdUX1NUQVRVU19IRUFERVIsIHMpLCAiJXMiLCAiIik7Cgl9CgoJd3Rfc3RhdHVzX3ByaW50X3VwZGF0ZWQocyk7Cgl3dF9zdGF0dXNfcHJpbnRfdW5tZXJnZWQocyk7Cgl3dF9zdGF0dXNfcHJpbnRfY2hhbmdlZChzKTsKCWlmIChzLT5zdWJtb2R1bGVfc3VtbWFyeSAmJgoJICAgICghcy0+aWdub3JlX3N1Ym1vZHVsZV9hcmcgfHwKCSAgICAgc3RyY21wKHMtPmlnbm9yZV9zdWJtb2R1bGVfYXJnLCAiYWxsIikpKSB7CgkJd3Rfc3RhdHVzX3ByaW50X3N1Ym1vZHVsZV9zdW1tYXJ5KHMsIDApOyAgLyogc3RhZ2VkICovCgkJd3Rfc3RhdHVzX3ByaW50X3N1Ym1vZHVsZV9zdW1tYXJ5KHMsIDEpOyAgLyogdW5zdGFnZWQgKi8KCX0KCWlmIChzLT5zaG93X3VudHJhY2tlZF9maWxlcykgewoJCXd0X3N0YXR1c19wcmludF9vdGhlcihzLCAmcy0+dW50cmFja2VkLCBfKCJVbnRyYWNrZWQgZmlsZXMiKSwgImFkZCIpOwoJCWlmIChzLT5zaG93X2lnbm9yZWRfZmlsZXMpCgkJCXd0X3N0YXR1c19wcmludF9vdGhlcihzLCAmcy0+aWdub3JlZCwgXygiSWdub3JlZCBmaWxlcyIpLCAiYWRkIC1mIik7CgkJaWYgKGFkdmljZV9zdGF0dXNfdV9vcHRpb24gJiYgMjAwMCA8IHMtPnVudHJhY2tlZF9pbl9tcykgewoJCQlzdGF0dXNfcHJpbnRmX2xuKHMsIEdJVF9DT0xPUl9OT1JNQUwsICIlcyIsICIiKTsKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJCSBfKCJJdCB0b29rICUuMmYgc2Vjb25kcyB0byBlbnVtZXJhdGUgdW50cmFja2VkIGZpbGVzLiAnc3RhdHVzIC11bm8nXG4iCgkJCQkJICAgIm1heSBzcGVlZCBpdCB1cCwgYnV0IHlvdSBoYXZlIHRvIGJlIGNhcmVmdWwgbm90IHRvIGZvcmdldCB0byBhZGRcbiIKCQkJCQkgICAibmV3IGZpbGVzIHlvdXJzZWxmIChzZWUgJ2dpdCBoZWxwIHN0YXR1cycpLiIpLAoJCQkJCSBzLT51bnRyYWNrZWRfaW5fbXMgLyAxMDAwLjApOwoJCX0KCX0gZWxzZSBpZiAocy0+Y29tbWl0YWJsZSkKCQlzdGF0dXNfcHJpbnRmX2xuKHMsIEdJVF9DT0xPUl9OT1JNQUwsIF8oIlVudHJhY2tlZCBmaWxlcyBub3QgbGlzdGVkJXMiKSwKCQkJcy0+aGludHMKCQkJPyBfKCIgKHVzZSAtdSBvcHRpb24gdG8gc2hvdyB1bnRyYWNrZWQgZmlsZXMpIikgOiAiIik7CgoJaWYgKHMtPnZlcmJvc2UpCgkJd3Rfc3RhdHVzX3ByaW50X3ZlcmJvc2Uocyk7CglpZiAoIXMtPmNvbW1pdGFibGUpIHsKCQlpZiAocy0+YW1lbmQpCgkJCXN0YXR1c19wcmludGZfbG4ocywgR0lUX0NPTE9SX05PUk1BTCwgXygiTm8gY2hhbmdlcyIpKTsKCQllbHNlIGlmIChzLT5ub3dhcm4pCgkJCTsgLyogbm90aGluZyAqLwoJCWVsc2UgaWYgKHMtPndvcmtkaXJfZGlydHkpIHsKCQkJaWYgKHMtPmhpbnRzKQoJCQkJcHJpbnRmKF8oIm5vIGNoYW5nZXMgYWRkZWQgdG8gY29tbWl0ICIKCQkJCQkgIih1c2UgXCJnaXQgYWRkXCIgYW5kL29yIFwiZ2l0IGNvbW1pdCAtYVwiKVxuIikpOwoJCQllbHNlCgkJCQlwcmludGYoXygibm8gY2hhbmdlcyBhZGRlZCB0byBjb21taXRcbiIpKTsKCQl9IGVsc2UgaWYgKHMtPnVudHJhY2tlZC5ucikgewoJCQlpZiAocy0+aGludHMpCgkJCQlwcmludGYoXygibm90aGluZyBhZGRlZCB0byBjb21taXQgYnV0IHVudHJhY2tlZCBmaWxlcyAiCgkJCQkJICJwcmVzZW50ICh1c2UgXCJnaXQgYWRkXCIgdG8gdHJhY2spXG4iKSk7CgkJCWVsc2UKCQkJCXByaW50ZihfKCJub3RoaW5nIGFkZGVkIHRvIGNvbW1pdCBidXQgdW50cmFja2VkIGZpbGVzIHByZXNlbnRcbiIpKTsKCQl9IGVsc2UgaWYgKHMtPmlzX2luaXRpYWwpIHsKCQkJaWYgKHMtPmhpbnRzKQoJCQkJcHJpbnRmKF8oIm5vdGhpbmcgdG8gY29tbWl0IChjcmVhdGUvY29weSBmaWxlcyAiCgkJCQkJICJhbmQgdXNlIFwiZ2l0IGFkZFwiIHRvIHRyYWNrKVxuIikpOwoJCQllbHNlCgkJCQlwcmludGYoXygibm90aGluZyB0byBjb21taXRcbiIpKTsKCQl9IGVsc2UgaWYgKCFzLT5zaG93X3VudHJhY2tlZF9maWxlcykgewoJCQlpZiAocy0+aGludHMpCgkJCQlwcmludGYoXygibm90aGluZyB0byBjb21taXQgKHVzZSAtdSB0byBzaG93IHVudHJhY2tlZCBmaWxlcylcbiIpKTsKCQkJZWxzZQoJCQkJcHJpbnRmKF8oIm5vdGhpbmcgdG8gY29tbWl0XG4iKSk7CgkJfSBlbHNlCgkJCXByaW50ZihfKCJub3RoaW5nIHRvIGNvbW1pdCwgd29ya2luZyBkaXJlY3RvcnkgY2xlYW5cbiIpKTsKCX0KfQoKc3RhdGljIHZvaWQgd3Rfc2hvcnRzdGF0dXNfdW5tZXJnZWQoc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0LAoJCQkgICBzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglzdHJ1Y3Qgd3Rfc3RhdHVzX2NoYW5nZV9kYXRhICpkID0gaXQtPnV0aWw7Cgljb25zdCBjaGFyICpob3cgPSAiPz8iOwoKCXN3aXRjaCAoZC0+c3RhZ2VtYXNrKSB7CgljYXNlIDE6IGhvdyA9ICJERCI7IGJyZWFrOyAvKiBib3RoIGRlbGV0ZWQgKi8KCWNhc2UgMjogaG93ID0gIkFVIjsgYnJlYWs7IC8qIGFkZGVkIGJ5IHVzICovCgljYXNlIDM6IGhvdyA9ICJVRCI7IGJyZWFrOyAvKiBkZWxldGVkIGJ5IHRoZW0gKi8KCWNhc2UgNDogaG93ID0gIlVBIjsgYnJlYWs7IC8qIGFkZGVkIGJ5IHRoZW0gKi8KCWNhc2UgNTogaG93ID0gIkRVIjsgYnJlYWs7IC8qIGRlbGV0ZWQgYnkgdXMgKi8KCWNhc2UgNjogaG93ID0gIkFBIjsgYnJlYWs7IC8qIGJvdGggYWRkZWQgKi8KCWNhc2UgNzogaG93ID0gIlVVIjsgYnJlYWs7IC8qIGJvdGggbW9kaWZpZWQgKi8KCX0KCWNvbG9yX2ZwcmludGYocy0+ZnAsIGNvbG9yKFdUX1NUQVRVU19VTk1FUkdFRCwgcyksICIlcyIsIGhvdyk7CglpZiAocy0+bnVsbF90ZXJtaW5hdGlvbikgewoJCWZwcmludGYoc3Rkb3V0LCAiICVzJWMiLCBpdC0+c3RyaW5nLCAwKTsKCX0gZWxzZSB7CgkJc3RydWN0IHN0cmJ1ZiBvbmVidWYgPSBTVFJCVUZfSU5JVDsKCQljb25zdCBjaGFyICpvbmU7CgkJb25lID0gcXVvdGVfcGF0aChpdC0+c3RyaW5nLCBzLT5wcmVmaXgsICZvbmVidWYpOwoJCXByaW50ZigiICVzXG4iLCBvbmUpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZvbmVidWYpOwoJfQp9CgpzdGF0aWMgdm9pZCB3dF9zaG9ydHN0YXR1c19zdGF0dXMoc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0LAoJCQkgc3RydWN0IHd0X3N0YXR1cyAqcykKewoJc3RydWN0IHd0X3N0YXR1c19jaGFuZ2VfZGF0YSAqZCA9IGl0LT51dGlsOwoKCWlmIChkLT5pbmRleF9zdGF0dXMpCgkJY29sb3JfZnByaW50ZihzLT5mcCwgY29sb3IoV1RfU1RBVFVTX1VQREFURUQsIHMpLCAiJWMiLCBkLT5pbmRleF9zdGF0dXMpOwoJZWxzZQoJCXB1dGNoYXIoJyAnKTsKCWlmIChkLT53b3JrdHJlZV9zdGF0dXMpCgkJY29sb3JfZnByaW50ZihzLT5mcCwgY29sb3IoV1RfU1RBVFVTX0NIQU5HRUQsIHMpLCAiJWMiLCBkLT53b3JrdHJlZV9zdGF0dXMpOwoJZWxzZQoJCXB1dGNoYXIoJyAnKTsKCXB1dGNoYXIoJyAnKTsKCWlmIChzLT5udWxsX3Rlcm1pbmF0aW9uKSB7CgkJZnByaW50ZihzdGRvdXQsICIlcyVjIiwgaXQtPnN0cmluZywgMCk7CgkJaWYgKGQtPmhlYWRfcGF0aCkKCQkJZnByaW50ZihzdGRvdXQsICIlcyVjIiwgZC0+aGVhZF9wYXRoLCAwKTsKCX0gZWxzZSB7CgkJc3RydWN0IHN0cmJ1ZiBvbmVidWYgPSBTVFJCVUZfSU5JVDsKCQljb25zdCBjaGFyICpvbmU7CgkJaWYgKGQtPmhlYWRfcGF0aCkgewoJCQlvbmUgPSBxdW90ZV9wYXRoKGQtPmhlYWRfcGF0aCwgcy0+cHJlZml4LCAmb25lYnVmKTsKCQkJaWYgKCpvbmUgIT0gJyInICYmIHN0cmNocihvbmUsICcgJykgIT0gTlVMTCkgewoJCQkJcHV0Y2hhcignIicpOwoJCQkJc3RyYnVmX2FkZGNoKCZvbmVidWYsICciJyk7CgkJCQlvbmUgPSBvbmVidWYuYnVmOwoJCQl9CgkJCXByaW50ZigiJXMgLT4gIiwgb25lKTsKCQkJc3RyYnVmX3JlbGVhc2UoJm9uZWJ1Zik7CgkJfQoJCW9uZSA9IHF1b3RlX3BhdGgoaXQtPnN0cmluZywgcy0+cHJlZml4LCAmb25lYnVmKTsKCQlpZiAoKm9uZSAhPSAnIicgJiYgc3RyY2hyKG9uZSwgJyAnKSAhPSBOVUxMKSB7CgkJCXB1dGNoYXIoJyInKTsKCQkJc3RyYnVmX2FkZGNoKCZvbmVidWYsICciJyk7CgkJCW9uZSA9IG9uZWJ1Zi5idWY7CgkJfQoJCXByaW50ZigiJXNcbiIsIG9uZSk7CgkJc3RyYnVmX3JlbGVhc2UoJm9uZWJ1Zik7Cgl9Cn0KCnN0YXRpYyB2b2lkIHd0X3Nob3J0c3RhdHVzX290aGVyKHN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdCwKCQkJCSBzdHJ1Y3Qgd3Rfc3RhdHVzICpzLCBjb25zdCBjaGFyICpzaWduKQp7CglpZiAocy0+bnVsbF90ZXJtaW5hdGlvbikgewoJCWZwcmludGYoc3Rkb3V0LCAiJXMgJXMlYyIsIHNpZ24sIGl0LT5zdHJpbmcsIDApOwoJfSBlbHNlIHsKCQlzdHJ1Y3Qgc3RyYnVmIG9uZWJ1ZiA9IFNUUkJVRl9JTklUOwoJCWNvbnN0IGNoYXIgKm9uZTsKCQlvbmUgPSBxdW90ZV9wYXRoKGl0LT5zdHJpbmcsIHMtPnByZWZpeCwgJm9uZWJ1Zik7CgkJY29sb3JfZnByaW50ZihzLT5mcCwgY29sb3IoV1RfU1RBVFVTX1VOVFJBQ0tFRCwgcyksICIlcyIsIHNpZ24pOwoJCXByaW50ZigiICVzXG4iLCBvbmUpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZvbmVidWYpOwoJfQp9CgpzdGF0aWMgdm9pZCB3dF9zaG9ydHN0YXR1c19wcmludF90cmFja2luZyhzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglzdHJ1Y3QgYnJhbmNoICpicmFuY2g7Cgljb25zdCBjaGFyICpoZWFkZXJfY29sb3IgPSBjb2xvcihXVF9TVEFUVVNfSEVBREVSLCBzKTsKCWNvbnN0IGNoYXIgKmJyYW5jaF9jb2xvcl9sb2NhbCA9IGNvbG9yKFdUX1NUQVRVU19MT0NBTF9CUkFOQ0gsIHMpOwoJY29uc3QgY2hhciAqYnJhbmNoX2NvbG9yX3JlbW90ZSA9IGNvbG9yKFdUX1NUQVRVU19SRU1PVEVfQlJBTkNILCBzKTsKCgljb25zdCBjaGFyICpiYXNlOwoJY29uc3QgY2hhciAqYnJhbmNoX25hbWU7CglpbnQgbnVtX291cnMsIG51bV90aGVpcnM7CglpbnQgdXBzdHJlYW1faXNfZ29uZSA9IDA7CgoJY29sb3JfZnByaW50ZihzLT5mcCwgY29sb3IoV1RfU1RBVFVTX0hFQURFUiwgcyksICIjIyAiKTsKCglpZiAoIXMtPmJyYW5jaCkKCQlyZXR1cm47CglicmFuY2hfbmFtZSA9IHMtPmJyYW5jaDsKCglpZiAocy0+aXNfaW5pdGlhbCkKCQljb2xvcl9mcHJpbnRmKHMtPmZwLCBoZWFkZXJfY29sb3IsIF8oIkluaXRpYWwgY29tbWl0IG9uICIpKTsKCglpZiAoIXN0cmNtcChzLT5icmFuY2gsICJIRUFEIikpIHsKCQljb2xvcl9mcHJpbnRmKHMtPmZwLCBjb2xvcihXVF9TVEFUVVNfTk9CUkFOQ0gsIHMpLCAiJXMiLAoJCQkgICAgICBfKCJIRUFEIChubyBicmFuY2gpIikpOwoJCWdvdG8gY29uY2x1ZGU7Cgl9CgoJc2tpcF9wcmVmaXgoYnJhbmNoX25hbWUsICJyZWZzL2hlYWRzLyIsICZicmFuY2hfbmFtZSk7CgoJYnJhbmNoID0gYnJhbmNoX2dldChicmFuY2hfbmFtZSk7CgoJY29sb3JfZnByaW50ZihzLT5mcCwgYnJhbmNoX2NvbG9yX2xvY2FsLCAiJXMiLCBicmFuY2hfbmFtZSk7CgoJaWYgKHN0YXRfdHJhY2tpbmdfaW5mbyhicmFuY2gsICZudW1fb3VycywgJm51bV90aGVpcnMsICZiYXNlKSA8IDApIHsKCQlpZiAoIWJhc2UpCgkJCWdvdG8gY29uY2x1ZGU7CgoJCXVwc3RyZWFtX2lzX2dvbmUgPSAxOwoJfQoKCWJhc2UgPSBzaG9ydGVuX3VuYW1iaWd1b3VzX3JlZihiYXNlLCAwKTsKCWNvbG9yX2ZwcmludGYocy0+ZnAsIGhlYWRlcl9jb2xvciwgIi4uLiIpOwoJY29sb3JfZnByaW50ZihzLT5mcCwgYnJhbmNoX2NvbG9yX3JlbW90ZSwgIiVzIiwgYmFzZSk7CglmcmVlKChjaGFyICopYmFzZSk7CgoJaWYgKCF1cHN0cmVhbV9pc19nb25lICYmICFudW1fb3VycyAmJiAhbnVtX3RoZWlycykKCQlnb3RvIGNvbmNsdWRlOwoKI2RlZmluZSBMQUJFTChzdHJpbmcpIChzLT5ub19nZXR0ZXh0ID8gKHN0cmluZykgOiBfKHN0cmluZykpCgoJY29sb3JfZnByaW50ZihzLT5mcCwgaGVhZGVyX2NvbG9yLCAiIFsiKTsKCWlmICh1cHN0cmVhbV9pc19nb25lKSB7CgkJY29sb3JfZnByaW50ZihzLT5mcCwgaGVhZGVyX2NvbG9yLCBMQUJFTChOXygiZ29uZSIpKSk7Cgl9IGVsc2UgaWYgKCFudW1fb3VycykgewoJCWNvbG9yX2ZwcmludGYocy0+ZnAsIGhlYWRlcl9jb2xvciwgTEFCRUwoTl8oImJlaGluZCAiKSkpOwoJCWNvbG9yX2ZwcmludGYocy0+ZnAsIGJyYW5jaF9jb2xvcl9yZW1vdGUsICIlZCIsIG51bV90aGVpcnMpOwoJfSBlbHNlIGlmICghbnVtX3RoZWlycykgewoJCWNvbG9yX2ZwcmludGYocy0+ZnAsIGhlYWRlcl9jb2xvciwgTEFCRUwoTl8oImFoZWFkICIpKSk7CgkJY29sb3JfZnByaW50ZihzLT5mcCwgYnJhbmNoX2NvbG9yX2xvY2FsLCAiJWQiLCBudW1fb3Vycyk7Cgl9IGVsc2UgewoJCWNvbG9yX2ZwcmludGYocy0+ZnAsIGhlYWRlcl9jb2xvciwgTEFCRUwoTl8oImFoZWFkICIpKSk7CgkJY29sb3JfZnByaW50ZihzLT5mcCwgYnJhbmNoX2NvbG9yX2xvY2FsLCAiJWQiLCBudW1fb3Vycyk7CgkJY29sb3JfZnByaW50ZihzLT5mcCwgaGVhZGVyX2NvbG9yLCAiLCAlcyIsIExBQkVMKE5fKCJiZWhpbmQgIikpKTsKCQljb2xvcl9mcHJpbnRmKHMtPmZwLCBicmFuY2hfY29sb3JfcmVtb3RlLCAiJWQiLCBudW1fdGhlaXJzKTsKCX0KCgljb2xvcl9mcHJpbnRmKHMtPmZwLCBoZWFkZXJfY29sb3IsICJdIik7CiBjb25jbHVkZToKCWZwdXRjKHMtPm51bGxfdGVybWluYXRpb24gPyAnXDAnIDogJ1xuJywgcy0+ZnApOwp9Cgp2b2lkIHd0X3Nob3J0c3RhdHVzX3ByaW50KHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWludCBpOwoKCWlmIChzLT5zaG93X2JyYW5jaCkKCQl3dF9zaG9ydHN0YXR1c19wcmludF90cmFja2luZyhzKTsKCglmb3IgKGkgPSAwOyBpIDwgcy0+Y2hhbmdlLm5yOyBpKyspIHsKCQlzdHJ1Y3Qgd3Rfc3RhdHVzX2NoYW5nZV9kYXRhICpkOwoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdDsKCgkJaXQgPSAmKHMtPmNoYW5nZS5pdGVtc1tpXSk7CgkJZCA9IGl0LT51dGlsOwoJCWlmIChkLT5zdGFnZW1hc2spCgkJCXd0X3Nob3J0c3RhdHVzX3VubWVyZ2VkKGl0LCBzKTsKCQllbHNlCgkJCXd0X3Nob3J0c3RhdHVzX3N0YXR1cyhpdCwgcyk7Cgl9Cglmb3IgKGkgPSAwOyBpIDwgcy0+dW50cmFja2VkLm5yOyBpKyspIHsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXQ7CgoJCWl0ID0gJihzLT51bnRyYWNrZWQuaXRlbXNbaV0pOwoJCXd0X3Nob3J0c3RhdHVzX290aGVyKGl0LCBzLCAiPz8iKTsKCX0KCWZvciAoaSA9IDA7IGkgPCBzLT5pZ25vcmVkLm5yOyBpKyspIHsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXQ7CgoJCWl0ID0gJihzLT5pZ25vcmVkLml0ZW1zW2ldKTsKCQl3dF9zaG9ydHN0YXR1c19vdGhlcihpdCwgcywgIiEhIik7Cgl9Cn0KCnZvaWQgd3RfcG9yY2VsYWluX3ByaW50KHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCXMtPnVzZV9jb2xvciA9IDA7CglzLT5yZWxhdGl2ZV9wYXRocyA9IDA7CglzLT5wcmVmaXggPSBOVUxMOwoJcy0+bm9fZ2V0dGV4dCA9IDE7Cgl3dF9zaG9ydHN0YXR1c19wcmludChzKTsKfQo=",
    "text": "#include \"cache.h\"\n#include \"wt-status.h\"\n#include \"object.h\"\n#include \"dir.h\"\n#include \"commit.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"diffcore.h\"\n#include \"quote.h\"\n#include \"run-command.h\"\n#include \"argv-array.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"submodule.h\"\n#include \"column.h\"\n#include \"strbuf.h\"\n#include \"utf8.h\"\n#include \"worktree.h\"\n\nstatic const char cut_line[] =\n\"------------------------ >8 ------------------------\\n\";\n\nstatic char default_wt_status_colors[][COLOR_MAXLEN] = {\n\tGIT_COLOR_NORMAL, /* WT_STATUS_HEADER */\n\tGIT_COLOR_GREEN,  /* WT_STATUS_UPDATED */\n\tGIT_COLOR_RED,    /* WT_STATUS_CHANGED */\n\tGIT_COLOR_RED,    /* WT_STATUS_UNTRACKED */\n\tGIT_COLOR_RED,    /* WT_STATUS_NOBRANCH */\n\tGIT_COLOR_RED,    /* WT_STATUS_UNMERGED */\n\tGIT_COLOR_GREEN,  /* WT_STATUS_LOCAL_BRANCH */\n\tGIT_COLOR_RED,    /* WT_STATUS_REMOTE_BRANCH */\n\tGIT_COLOR_NIL,    /* WT_STATUS_ONBRANCH */\n};\n\nstatic const char *color(int slot, struct wt_status *s)\n{\n\tconst char *c = \"\";\n\tif (want_color(s->use_color))\n\t\tc = s->color_palette[slot];\n\tif (slot == WT_STATUS_ONBRANCH && color_is_nil(c))\n\t\tc = s->color_palette[WT_STATUS_HEADER];\n\treturn c;\n}\n\nstatic void status_vprintf(struct wt_status *s, int at_bol, const char *color,\n\t\tconst char *fmt, va_list ap, const char *trail)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tstruct strbuf linebuf = STRBUF_INIT;\n\tconst char *line, *eol;\n\n\tstrbuf_vaddf(&sb, fmt, ap);\n\tif (!sb.len) {\n\t\tif (s->display_comment_prefix) {\n\t\t\tstrbuf_addch(&sb, comment_line_char);\n\t\t\tif (!trail)\n\t\t\t\tstrbuf_addch(&sb, ' ');\n\t\t}\n\t\tcolor_print_strbuf(s->fp, color, &sb);\n\t\tif (trail)\n\t\t\tfprintf(s->fp, \"%s\", trail);\n\t\tstrbuf_release(&sb);\n\t\treturn;\n\t}\n\tfor (line = sb.buf; *line; line = eol + 1) {\n\t\teol = strchr(line, '\\n');\n\n\t\tstrbuf_reset(&linebuf);\n\t\tif (at_bol && s->display_comment_prefix) {\n\t\t\tstrbuf_addch(&linebuf, comment_line_char);\n\t\t\tif (*line != '\\n' && *line != '\\t')\n\t\t\t\tstrbuf_addch(&linebuf, ' ');\n\t\t}\n\t\tif (eol)\n\t\t\tstrbuf_add(&linebuf, line, eol - line);\n\t\telse\n\t\t\tstrbuf_addstr(&linebuf, line);\n\t\tcolor_print_strbuf(s->fp, color, &linebuf);\n\t\tif (eol)\n\t\t\tfprintf(s->fp, \"\\n\");\n\t\telse\n\t\t\tbreak;\n\t\tat_bol = 1;\n\t}\n\tif (trail)\n\t\tfprintf(s->fp, \"%s\", trail);\n\tstrbuf_release(&linebuf);\n\tstrbuf_release(&sb);\n}\n\nvoid status_printf_ln(struct wt_status *s, const char *color,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tstatus_vprintf(s, 1, color, fmt, ap, \"\\n\");\n\tva_end(ap);\n}\n\nvoid status_printf(struct wt_status *s, const char *color,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tstatus_vprintf(s, 1, color, fmt, ap, NULL);\n\tva_end(ap);\n}\n\nstatic void status_printf_more(struct wt_status *s, const char *color,\n\t\t\t       const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tstatus_vprintf(s, 0, color, fmt, ap, NULL);\n\tva_end(ap);\n}\n\nvoid wt_status_prepare(struct wt_status *s)\n{\n\tunsigned char sha1[20];\n\n\tmemset(s, 0, sizeof(*s));\n\tmemcpy(s->color_palette, default_wt_status_colors,\n\t       sizeof(default_wt_status_colors));\n\ts->show_untracked_files = SHOW_NORMAL_UNTRACKED_FILES;\n\ts->use_color = -1;\n\ts->relative_paths = 1;\n\ts->branch = resolve_refdup(\"HEAD\", 0, sha1, NULL);\n\ts->reference = \"HEAD\";\n\ts->fp = stdout;\n\ts->index_file = get_index_file();\n\ts->change.strdup_strings = 1;\n\ts->untracked.strdup_strings = 1;\n\ts->ignored.strdup_strings = 1;\n\ts->show_branch = -1;  /* unspecified */\n\ts->display_comment_prefix = 0;\n}\n\nstatic void wt_status_print_unmerged_header(struct wt_status *s)\n{\n\tint i;\n\tint del_mod_conflict = 0;\n\tint both_deleted = 0;\n\tint not_deleted = 0;\n\tconst char *c = color(WT_STATUS_HEADER, s);\n\n\tstatus_printf_ln(s, c, _(\"Unmerged paths:\"));\n\n\tfor (i = 0; i < s->change.nr; i++) {\n\t\tstruct string_list_item *it = &(s->change.items[i]);\n\t\tstruct wt_status_change_data *d = it->util;\n\n\t\tswitch (d->stagemask) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tboth_deleted = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\tcase 5:\n\t\t\tdel_mod_conflict = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnot_deleted = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!s->hints)\n\t\treturn;\n\tif (s->whence != FROM_COMMIT)\n\t\t;\n\telse if (!s->is_initial)\n\t\tstatus_printf_ln(s, c, _(\"  (use \\\"git reset %s <file>...\\\" to unstage)\"), s->reference);\n\telse\n\t\tstatus_printf_ln(s, c, _(\"  (use \\\"git rm --cached <file>...\\\" to unstage)\"));\n\n\tif (!both_deleted) {\n\t\tif (!del_mod_conflict)\n\t\t\tstatus_printf_ln(s, c, _(\"  (use \\\"git add <file>...\\\" to mark resolution)\"));\n\t\telse\n\t\t\tstatus_printf_ln(s, c, _(\"  (use \\\"git add/rm <file>...\\\" as appropriate to mark resolution)\"));\n\t} else if (!del_mod_conflict && !not_deleted) {\n\t\tstatus_printf_ln(s, c, _(\"  (use \\\"git rm <file>...\\\" to mark resolution)\"));\n\t} else {\n\t\tstatus_printf_ln(s, c, _(\"  (use \\\"git add/rm <file>...\\\" as appropriate to mark resolution)\"));\n\t}\n\tstatus_printf_ln(s, c, \"%s\", \"\");\n}\n\nstatic void wt_status_print_cached_header(struct wt_status *s)\n{\n\tconst char *c = color(WT_STATUS_HEADER, s);\n\n\tstatus_printf_ln(s, c, _(\"Changes to be committed:\"));\n\tif (!s->hints)\n\t\treturn;\n\tif (s->whence != FROM_COMMIT)\n\t\t; /* NEEDSWORK: use \"git reset --unresolve\"??? */\n\telse if (!s->is_initial)\n\t\tstatus_printf_ln(s, c, _(\"  (use \\\"git reset %s <file>...\\\" to unstage)\"), s->reference);\n\telse\n\t\tstatus_printf_ln(s, c, _(\"  (use \\\"git rm --cached <file>...\\\" to unstage)\"));\n\tstatus_printf_ln(s, c, \"%s\", \"\");\n}\n\nstatic void wt_status_print_dirty_header(struct wt_status *s,\n\t\t\t\t\t int has_deleted,\n\t\t\t\t\t int has_dirty_submodules)\n{\n\tconst char *c = color(WT_STATUS_HEADER, s);\n\n\tstatus_printf_ln(s, c, _(\"Changes not staged for commit:\"));\n\tif (!s->hints)\n\t\treturn;\n\tif (!has_deleted)\n\t\tstatus_printf_ln(s, c, _(\"  (use \\\"git add <file>...\\\" to update what will be committed)\"));\n\telse\n\t\tstatus_printf_ln(s, c, _(\"  (use \\\"git add/rm <file>...\\\" to update what will be committed)\"));\n\tstatus_printf_ln(s, c, _(\"  (use \\\"git checkout -- <file>...\\\" to discard changes in working directory)\"));\n\tif (has_dirty_submodules)\n\t\tstatus_printf_ln(s, c, _(\"  (commit or discard the untracked or modified content in submodules)\"));\n\tstatus_printf_ln(s, c, \"%s\", \"\");\n}\n\nstatic void wt_status_print_other_header(struct wt_status *s,\n\t\t\t\t\t const char *what,\n\t\t\t\t\t const char *how)\n{\n\tconst char *c = color(WT_STATUS_HEADER, s);\n\tstatus_printf_ln(s, c, \"%s:\", what);\n\tif (!s->hints)\n\t\treturn;\n\tstatus_printf_ln(s, c, _(\"  (use \\\"git %s <file>...\\\" to include in what will be committed)\"), how);\n\tstatus_printf_ln(s, c, \"%s\", \"\");\n}\n\nstatic void wt_status_print_trailer(struct wt_status *s)\n{\n\tstatus_printf_ln(s, color(WT_STATUS_HEADER, s), \"%s\", \"\");\n}\n\n#define quote_path quote_path_relative\n\nstatic const char *wt_status_unmerged_status_string(int stagemask)\n{\n\tswitch (stagemask) {\n\tcase 1:\n\t\treturn _(\"both deleted:\");\n\tcase 2:\n\t\treturn _(\"added by us:\");\n\tcase 3:\n\t\treturn _(\"deleted by them:\");\n\tcase 4:\n\t\treturn _(\"added by them:\");\n\tcase 5:\n\t\treturn _(\"deleted by us:\");\n\tcase 6:\n\t\treturn _(\"both added:\");\n\tcase 7:\n\t\treturn _(\"both modified:\");\n\tdefault:\n\t\tdie(_(\"bug: unhandled unmerged status %x\"), stagemask);\n\t}\n}\n\nstatic const char *wt_status_diff_status_string(int status)\n{\n\tswitch (status) {\n\tcase DIFF_STATUS_ADDED:\n\t\treturn _(\"new file:\");\n\tcase DIFF_STATUS_COPIED:\n\t\treturn _(\"copied:\");\n\tcase DIFF_STATUS_DELETED:\n\t\treturn _(\"deleted:\");\n\tcase DIFF_STATUS_MODIFIED:\n\t\treturn _(\"modified:\");\n\tcase DIFF_STATUS_RENAMED:\n\t\treturn _(\"renamed:\");\n\tcase DIFF_STATUS_TYPE_CHANGED:\n\t\treturn _(\"typechange:\");\n\tcase DIFF_STATUS_UNKNOWN:\n\t\treturn _(\"unknown:\");\n\tcase DIFF_STATUS_UNMERGED:\n\t\treturn _(\"unmerged:\");\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int maxwidth(const char *(*label)(int), int minval, int maxval)\n{\n\tint result = 0, i;\n\n\tfor (i = minval; i <= maxval; i++) {\n\t\tconst char *s = label(i);\n\t\tint len = s ? utf8_strwidth(s) : 0;\n\t\tif (len > result)\n\t\t\tresult = len;\n\t}\n\treturn result;\n}\n\nstatic void wt_status_print_unmerged_data(struct wt_status *s,\n\t\t\t\t\t  struct string_list_item *it)\n{\n\tconst char *c = color(WT_STATUS_UNMERGED, s);\n\tstruct wt_status_change_data *d = it->util;\n\tstruct strbuf onebuf = STRBUF_INIT;\n\tstatic char *padding;\n\tstatic int label_width;\n\tconst char *one, *how;\n\tint len;\n\n\tif (!padding) {\n\t\tlabel_width = maxwidth(wt_status_unmerged_status_string, 1, 7);\n\t\tlabel_width += strlen(\" \");\n\t\tpadding = xmallocz(label_width);\n\t\tmemset(padding, ' ', label_width);\n\t}\n\n\tone = quote_path(it->string, s->prefix, &onebuf);\n\tstatus_printf(s, color(WT_STATUS_HEADER, s), \"\\t\");\n\n\thow = wt_status_unmerged_status_string(d->stagemask);\n\tlen = label_width - utf8_strwidth(how);\n\tstatus_printf_more(s, c, \"%s%.*s%s\\n\", how, len, padding, one);\n\tstrbuf_release(&onebuf);\n}\n\nstatic void wt_status_print_change_data(struct wt_status *s,\n\t\t\t\t\tint change_type,\n\t\t\t\t\tstruct string_list_item *it)\n{\n\tstruct wt_status_change_data *d = it->util;\n\tconst char *c = color(change_type, s);\n\tint status;\n\tchar *one_name;\n\tchar *two_name;\n\tconst char *one, *two;\n\tstruct strbuf onebuf = STRBUF_INIT, twobuf = STRBUF_INIT;\n\tstruct strbuf extra = STRBUF_INIT;\n\tstatic char *padding;\n\tstatic int label_width;\n\tconst char *what;\n\tint len;\n\n\tif (!padding) {\n\t\t/* If DIFF_STATUS_* uses outside the range [A..Z], we're in trouble */\n\t\tlabel_width = maxwidth(wt_status_diff_status_string, 'A', 'Z');\n\t\tlabel_width += strlen(\" \");\n\t\tpadding = xmallocz(label_width);\n\t\tmemset(padding, ' ', label_width);\n\t}\n\n\tone_name = two_name = it->string;\n\tswitch (change_type) {\n\tcase WT_STATUS_UPDATED:\n\t\tstatus = d->index_status;\n\t\tif (d->head_path)\n\t\t\tone_name = d->head_path;\n\t\tbreak;\n\tcase WT_STATUS_CHANGED:\n\t\tif (d->new_submodule_commits || d->dirty_submodule) {\n\t\t\tstrbuf_addstr(&extra, \" (\");\n\t\t\tif (d->new_submodule_commits)\n\t\t\t\tstrbuf_addf(&extra, _(\"new commits, \"));\n\t\t\tif (d->dirty_submodule & DIRTY_SUBMODULE_MODIFIED)\n\t\t\t\tstrbuf_addf(&extra, _(\"modified content, \"));\n\t\t\tif (d->dirty_submodule & DIRTY_SUBMODULE_UNTRACKED)\n\t\t\t\tstrbuf_addf(&extra, _(\"untracked content, \"));\n\t\t\tstrbuf_setlen(&extra, extra.len - 2);\n\t\t\tstrbuf_addch(&extra, ')');\n\t\t}\n\t\tstatus = d->worktree_status;\n\t\tbreak;\n\tdefault:\n\t\tdie(\"BUG: unhandled change_type %d in wt_status_print_change_data\",\n\t\t    change_type);\n\t}\n\n\tone = quote_path(one_name, s->prefix, &onebuf);\n\ttwo = quote_path(two_name, s->prefix, &twobuf);\n\n\tstatus_printf(s, color(WT_STATUS_HEADER, s), \"\\t\");\n\twhat = wt_status_diff_status_string(status);\n\tif (!what)\n\t\tdie(_(\"bug: unhandled diff status %c\"), status);\n\tlen = label_width - utf8_strwidth(what);\n\tassert(len >= 0);\n\tif (status == DIFF_STATUS_COPIED || status == DIFF_STATUS_RENAMED)\n\t\tstatus_printf_more(s, c, \"%s%.*s%s -> %s\",\n\t\t\t\t   what, len, padding, one, two);\n\telse\n\t\tstatus_printf_more(s, c, \"%s%.*s%s\",\n\t\t\t\t   what, len, padding, one);\n\tif (extra.len) {\n\t\tstatus_printf_more(s, color(WT_STATUS_HEADER, s), \"%s\", extra.buf);\n\t\tstrbuf_release(&extra);\n\t}\n\tstatus_printf_more(s, GIT_COLOR_NORMAL, \"\\n\");\n\tstrbuf_release(&onebuf);\n\tstrbuf_release(&twobuf);\n}\n\nstatic void wt_status_collect_changed_cb(struct diff_queue_struct *q,\n\t\t\t\t\t struct diff_options *options,\n\t\t\t\t\t void *data)\n{\n\tstruct wt_status *s = data;\n\tint i;\n\n\tif (!q->nr)\n\t\treturn;\n\ts->workdir_dirty = 1;\n\tfor (i = 0; i < q->nr; i++) {\n\t\tstruct diff_filepair *p;\n\t\tstruct string_list_item *it;\n\t\tstruct wt_status_change_data *d;\n\n\t\tp = q->queue[i];\n\t\tit = string_list_insert(&s->change, p->one->path);\n\t\td = it->util;\n\t\tif (!d) {\n\t\t\td = xcalloc(1, sizeof(*d));\n\t\t\tit->util = d;\n\t\t}\n\t\tif (!d->worktree_status)\n\t\t\td->worktree_status = p->status;\n\t\td->dirty_submodule = p->two->dirty_submodule;\n\t\tif (S_ISGITLINK(p->two->mode))\n\t\t\td->new_submodule_commits = !!hashcmp(p->one->sha1, p->two->sha1);\n\t}\n}\n\nstatic int unmerged_mask(const char *path)\n{\n\tint pos, mask;\n\tconst struct cache_entry *ce;\n\n\tpos = cache_name_pos(path, strlen(path));\n\tif (0 <= pos)\n\t\treturn 0;\n\n\tmask = 0;\n\tpos = -pos-1;\n\twhile (pos < active_nr) {\n\t\tce = active_cache[pos++];\n\t\tif (strcmp(ce->name, path) || !ce_stage(ce))\n\t\t\tbreak;\n\t\tmask |= (1 << (ce_stage(ce) - 1));\n\t}\n\treturn mask;\n}\n\nstatic void wt_status_collect_updated_cb(struct diff_queue_struct *q,\n\t\t\t\t\t struct diff_options *options,\n\t\t\t\t\t void *data)\n{\n\tstruct wt_status *s = data;\n\tint i;\n\n\tfor (i = 0; i < q->nr; i++) {\n\t\tstruct diff_filepair *p;\n\t\tstruct string_list_item *it;\n\t\tstruct wt_status_change_data *d;\n\n\t\tp = q->queue[i];\n\t\tit = string_list_insert(&s->change, p->two->path);\n\t\td = it->util;\n\t\tif (!d) {\n\t\t\td = xcalloc(1, sizeof(*d));\n\t\t\tit->util = d;\n\t\t}\n\t\tif (!d->index_status)\n\t\t\td->index_status = p->status;\n\t\tswitch (p->status) {\n\t\tcase DIFF_STATUS_COPIED:\n\t\tcase DIFF_STATUS_RENAMED:\n\t\t\td->head_path = xstrdup(p->one->path);\n\t\t\tbreak;\n\t\tcase DIFF_STATUS_UNMERGED:\n\t\t\td->stagemask = unmerged_mask(p->two->path);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void wt_status_collect_changes_worktree(struct wt_status *s)\n{\n\tstruct rev_info rev;\n\n\tinit_revisions(&rev, NULL);\n\tsetup_revisions(0, NULL, &rev, NULL);\n\trev.diffopt.output_format |= DIFF_FORMAT_CALLBACK;\n\tDIFF_OPT_SET(&rev.diffopt, DIRTY_SUBMODULES);\n\tif (!s->show_untracked_files)\n\t\tDIFF_OPT_SET(&rev.diffopt, IGNORE_UNTRACKED_IN_SUBMODULES);\n\tif (s->ignore_submodule_arg) {\n\t\tDIFF_OPT_SET(&rev.diffopt, OVERRIDE_SUBMODULE_CONFIG);\n\t\thandle_ignore_submodules_arg(&rev.diffopt, s->ignore_submodule_arg);\n\t}\n\trev.diffopt.format_callback = wt_status_collect_changed_cb;\n\trev.diffopt.format_callback_data = s;\n\tcopy_pathspec(&rev.prune_data, &s->pathspec);\n\trun_diff_files(&rev, 0);\n}\n\nstatic void wt_status_collect_changes_index(struct wt_status *s)\n{\n\tstruct rev_info rev;\n\tstruct setup_revision_opt opt;\n\n\tinit_revisions(&rev, NULL);\n\tmemset(&opt, 0, sizeof(opt));\n\topt.def = s->is_initial ? EMPTY_TREE_SHA1_HEX : s->reference;\n\tsetup_revisions(0, NULL, &rev, &opt);\n\n\tDIFF_OPT_SET(&rev.diffopt, OVERRIDE_SUBMODULE_CONFIG);\n\tif (s->ignore_submodule_arg) {\n\t\thandle_ignore_submodules_arg(&rev.diffopt, s->ignore_submodule_arg);\n\t} else {\n\t\t/*\n\t\t * Unless the user did explicitly request a submodule ignore\n\t\t * mode by passing a command line option we do not ignore any\n\t\t * changed submodule SHA-1s when comparing index and HEAD, no\n\t\t * matter what is configured. Otherwise the user won't be\n\t\t * shown any submodules she manually added (and which are\n\t\t * staged to be committed), which would be really confusing.\n\t\t */\n\t\thandle_ignore_submodules_arg(&rev.diffopt, \"dirty\");\n\t}\n\n\trev.diffopt.output_format |= DIFF_FORMAT_CALLBACK;\n\trev.diffopt.format_callback = wt_status_collect_updated_cb;\n\trev.diffopt.format_callback_data = s;\n\trev.diffopt.detect_rename = 1;\n\trev.diffopt.rename_limit = 200;\n\trev.diffopt.break_opt = 0;\n\tcopy_pathspec(&rev.prune_data, &s->pathspec);\n\trun_diff_index(&rev, 1);\n}\n\nstatic void wt_status_collect_changes_initial(struct wt_status *s)\n{\n\tint i;\n\n\tfor (i = 0; i < active_nr; i++) {\n\t\tstruct string_list_item *it;\n\t\tstruct wt_status_change_data *d;\n\t\tconst struct cache_entry *ce = active_cache[i];\n\n\t\tif (!ce_path_match(ce, &s->pathspec, NULL))\n\t\t\tcontinue;\n\t\tit = string_list_insert(&s->change, ce->name);\n\t\td = it->util;\n\t\tif (!d) {\n\t\t\td = xcalloc(1, sizeof(*d));\n\t\t\tit->util = d;\n\t\t}\n\t\tif (ce_stage(ce)) {\n\t\t\td->index_status = DIFF_STATUS_UNMERGED;\n\t\t\td->stagemask |= (1 << (ce_stage(ce) - 1));\n\t\t}\n\t\telse\n\t\t\td->index_status = DIFF_STATUS_ADDED;\n\t}\n}\n\nstatic void wt_status_collect_untracked(struct wt_status *s)\n{\n\tint i;\n\tstruct dir_struct dir;\n\tuint64_t t_begin = getnanotime();\n\n\tif (!s->show_untracked_files)\n\t\treturn;\n\n\tmemset(&dir, 0, sizeof(dir));\n\tif (s->show_untracked_files != SHOW_ALL_UNTRACKED_FILES)\n\t\tdir.flags |=\n\t\t\tDIR_SHOW_OTHER_DIRECTORIES | DIR_HIDE_EMPTY_DIRECTORIES;\n\tif (s->show_ignored_files)\n\t\tdir.flags |= DIR_SHOW_IGNORED_TOO;\n\telse\n\t\tdir.untracked = the_index.untracked;\n\tsetup_standard_excludes(&dir);\n\n\tfill_directory(&dir, &s->pathspec);\n\n\tfor (i = 0; i < dir.nr; i++) {\n\t\tstruct dir_entry *ent = dir.entries[i];\n\t\tif (cache_name_is_other(ent->name, ent->len) &&\n\t\t    dir_path_match(ent, &s->pathspec, 0, NULL))\n\t\t\tstring_list_insert(&s->untracked, ent->name);\n\t\tfree(ent);\n\t}\n\n\tfor (i = 0; i < dir.ignored_nr; i++) {\n\t\tstruct dir_entry *ent = dir.ignored[i];\n\t\tif (cache_name_is_other(ent->name, ent->len) &&\n\t\t    dir_path_match(ent, &s->pathspec, 0, NULL))\n\t\t\tstring_list_insert(&s->ignored, ent->name);\n\t\tfree(ent);\n\t}\n\n\tfree(dir.entries);\n\tfree(dir.ignored);\n\tclear_directory(&dir);\n\n\tif (advice_status_u_option)\n\t\ts->untracked_in_ms = (getnanotime() - t_begin) / 1000000;\n}\n\nvoid wt_status_collect(struct wt_status *s)\n{\n\twt_status_collect_changes_worktree(s);\n\n\tif (s->is_initial)\n\t\twt_status_collect_changes_initial(s);\n\telse\n\t\twt_status_collect_changes_index(s);\n\twt_status_collect_untracked(s);\n}\n\nstatic void wt_status_print_unmerged(struct wt_status *s)\n{\n\tint shown_header = 0;\n\tint i;\n\n\tfor (i = 0; i < s->change.nr; i++) {\n\t\tstruct wt_status_change_data *d;\n\t\tstruct string_list_item *it;\n\t\tit = &(s->change.items[i]);\n\t\td = it->util;\n\t\tif (!d->stagemask)\n\t\t\tcontinue;\n\t\tif (!shown_header) {\n\t\t\twt_status_print_unmerged_header(s);\n\t\t\tshown_header = 1;\n\t\t}\n\t\twt_status_print_unmerged_data(s, it);\n\t}\n\tif (shown_header)\n\t\twt_status_print_trailer(s);\n\n}\n\nstatic void wt_status_print_updated(struct wt_status *s)\n{\n\tint shown_header = 0;\n\tint i;\n\n\tfor (i = 0; i < s->change.nr; i++) {\n\t\tstruct wt_status_change_data *d;\n\t\tstruct string_list_item *it;\n\t\tit = &(s->change.items[i]);\n\t\td = it->util;\n\t\tif (!d->index_status ||\n\t\t    d->index_status == DIFF_STATUS_UNMERGED)\n\t\t\tcontinue;\n\t\tif (!shown_header) {\n\t\t\twt_status_print_cached_header(s);\n\t\t\ts->commitable = 1;\n\t\t\tshown_header = 1;\n\t\t}\n\t\twt_status_print_change_data(s, WT_STATUS_UPDATED, it);\n\t}\n\tif (shown_header)\n\t\twt_status_print_trailer(s);\n}\n\n/*\n * -1 : has delete\n *  0 : no change\n *  1 : some change but no delete\n */\nstatic int wt_status_check_worktree_changes(struct wt_status *s,\n\t\t\t\t\t     int *dirty_submodules)\n{\n\tint i;\n\tint changes = 0;\n\n\t*dirty_submodules = 0;\n\n\tfor (i = 0; i < s->change.nr; i++) {\n\t\tstruct wt_status_change_data *d;\n\t\td = s->change.items[i].util;\n\t\tif (!d->worktree_status ||\n\t\t    d->worktree_status == DIFF_STATUS_UNMERGED)\n\t\t\tcontinue;\n\t\tif (!changes)\n\t\t\tchanges = 1;\n\t\tif (d->dirty_submodule)\n\t\t\t*dirty_submodules = 1;\n\t\tif (d->worktree_status == DIFF_STATUS_DELETED)\n\t\t\tchanges = -1;\n\t}\n\treturn changes;\n}\n\nstatic void wt_status_print_changed(struct wt_status *s)\n{\n\tint i, dirty_submodules;\n\tint worktree_changes = wt_status_check_worktree_changes(s, &dirty_submodules);\n\n\tif (!worktree_changes)\n\t\treturn;\n\n\twt_status_print_dirty_header(s, worktree_changes < 0, dirty_submodules);\n\n\tfor (i = 0; i < s->change.nr; i++) {\n\t\tstruct wt_status_change_data *d;\n\t\tstruct string_list_item *it;\n\t\tit = &(s->change.items[i]);\n\t\td = it->util;\n\t\tif (!d->worktree_status ||\n\t\t    d->worktree_status == DIFF_STATUS_UNMERGED)\n\t\t\tcontinue;\n\t\twt_status_print_change_data(s, WT_STATUS_CHANGED, it);\n\t}\n\twt_status_print_trailer(s);\n}\n\nstatic void wt_status_print_submodule_summary(struct wt_status *s, int uncommitted)\n{\n\tstruct child_process sm_summary = CHILD_PROCESS_INIT;\n\tstruct strbuf cmd_stdout = STRBUF_INIT;\n\tstruct strbuf summary = STRBUF_INIT;\n\tchar *summary_content;\n\n\targv_array_pushf(&sm_summary.env_array, \"GIT_INDEX_FILE=%s\",\n\t\t\t s->index_file);\n\n\targv_array_push(&sm_summary.args, \"submodule\");\n\targv_array_push(&sm_summary.args, \"summary\");\n\targv_array_push(&sm_summary.args, uncommitted ? \"--files\" : \"--cached\");\n\targv_array_push(&sm_summary.args, \"--for-status\");\n\targv_array_push(&sm_summary.args, \"--summary-limit\");\n\targv_array_pushf(&sm_summary.args, \"%d\", s->submodule_summary);\n\tif (!uncommitted)\n\t\targv_array_push(&sm_summary.args, s->amend ? \"HEAD^\" : \"HEAD\");\n\n\tsm_summary.git_cmd = 1;\n\tsm_summary.no_stdin = 1;\n\n\tcapture_command(&sm_summary, &cmd_stdout, 1024);\n\n\t/* prepend header, only if there's an actual output */\n\tif (cmd_stdout.len) {\n\t\tif (uncommitted)\n\t\t\tstrbuf_addstr(&summary, _(\"Submodules changed but not updated:\"));\n\t\telse\n\t\t\tstrbuf_addstr(&summary, _(\"Submodule changes to be committed:\"));\n\t\tstrbuf_addstr(&summary, \"\\n\\n\");\n\t}\n\tstrbuf_addbuf(&summary, &cmd_stdout);\n\tstrbuf_release(&cmd_stdout);\n\n\tif (s->display_comment_prefix) {\n\t\tsize_t len;\n\t\tsummary_content = strbuf_detach(&summary, &len);\n\t\tstrbuf_add_commented_lines(&summary, summary_content, len);\n\t\tfree(summary_content);\n\t}\n\n\tfputs(summary.buf, s->fp);\n\tstrbuf_release(&summary);\n}\n\nstatic void wt_status_print_other(struct wt_status *s,\n\t\t\t\t  struct string_list *l,\n\t\t\t\t  const char *what,\n\t\t\t\t  const char *how)\n{\n\tint i;\n\tstruct strbuf buf = STRBUF_INIT;\n\tstatic struct string_list output = STRING_LIST_INIT_DUP;\n\tstruct column_options copts;\n\n\tif (!l->nr)\n\t\treturn;\n\n\twt_status_print_other_header(s, what, how);\n\n\tfor (i = 0; i < l->nr; i++) {\n\t\tstruct string_list_item *it;\n\t\tconst char *path;\n\t\tit = &(l->items[i]);\n\t\tpath = quote_path(it->string, s->prefix, &buf);\n\t\tif (column_active(s->colopts)) {\n\t\t\tstring_list_append(&output, path);\n\t\t\tcontinue;\n\t\t}\n\t\tstatus_printf(s, color(WT_STATUS_HEADER, s), \"\\t\");\n\t\tstatus_printf_more(s, color(WT_STATUS_UNTRACKED, s),\n\t\t\t\t   \"%s\\n\", path);\n\t}\n\n\tstrbuf_release(&buf);\n\tif (!column_active(s->colopts))\n\t\tgoto conclude;\n\n\tstrbuf_addf(&buf, \"%s%s\\t%s\",\n\t\t    color(WT_STATUS_HEADER, s),\n\t\t    s->display_comment_prefix ? \"#\" : \"\",\n\t\t    color(WT_STATUS_UNTRACKED, s));\n\tmemset(&copts, 0, sizeof(copts));\n\tcopts.padding = 1;\n\tcopts.indent = buf.buf;\n\tif (want_color(s->use_color))\n\t\tcopts.nl = GIT_COLOR_RESET \"\\n\";\n\tprint_columns(&output, s->colopts, &copts);\n\tstring_list_clear(&output, 0);\n\tstrbuf_release(&buf);\nconclude:\n\tstatus_printf_ln(s, GIT_COLOR_NORMAL, \"%s\", \"\");\n}\n\nvoid wt_status_truncate_message_at_cut_line(struct strbuf *buf)\n{\n\tconst char *p;\n\tstruct strbuf pattern = STRBUF_INIT;\n\n\tstrbuf_addf(&pattern, \"\\n%c %s\", comment_line_char, cut_line);\n\tif (starts_with(buf->buf, pattern.buf + 1))\n\t\tstrbuf_setlen(buf, 0);\n\telse if ((p = strstr(buf->buf, pattern.buf)))\n\t\tstrbuf_setlen(buf, p - buf->buf + 1);\n\tstrbuf_release(&pattern);\n}\n\nvoid wt_status_add_cut_line(FILE *fp)\n{\n\tconst char *explanation = _(\"Do not touch the line above.\\nEverything below will be removed.\");\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tfprintf(fp, \"%c %s\", comment_line_char, cut_line);\n\tstrbuf_add_commented_lines(&buf, explanation, strlen(explanation));\n\tfputs(buf.buf, fp);\n\tstrbuf_release(&buf);\n}\n\nstatic void wt_status_print_verbose(struct wt_status *s)\n{\n\tstruct rev_info rev;\n\tstruct setup_revision_opt opt;\n\tint dirty_submodules;\n\tconst char *c = color(WT_STATUS_HEADER, s);\n\n\tinit_revisions(&rev, NULL);\n\tDIFF_OPT_SET(&rev.diffopt, ALLOW_TEXTCONV);\n\n\tmemset(&opt, 0, sizeof(opt));\n\topt.def = s->is_initial ? EMPTY_TREE_SHA1_HEX : s->reference;\n\tsetup_revisions(0, NULL, &rev, &opt);\n\n\trev.diffopt.output_format |= DIFF_FORMAT_PATCH;\n\trev.diffopt.detect_rename = 1;\n\trev.diffopt.file = s->fp;\n\trev.diffopt.close_file = 0;\n\t/*\n\t * If we're not going to stdout, then we definitely don't\n\t * want color, since we are going to the commit message\n\t * file (and even the \"auto\" setting won't work, since it\n\t * will have checked isatty on stdout). But we then do want\n\t * to insert the scissor line here to reliably remove the\n\t * diff before committing.\n\t */\n\tif (s->fp != stdout) {\n\t\trev.diffopt.use_color = 0;\n\t\twt_status_add_cut_line(s->fp);\n\t}\n\tif (s->verbose > 1 && s->commitable) {\n\t\t/* print_updated() printed a header, so do we */\n\t\tif (s->fp != stdout)\n\t\t\twt_status_print_trailer(s);\n\t\tstatus_printf_ln(s, c, _(\"Changes to be committed:\"));\n\t\trev.diffopt.a_prefix = \"c/\";\n\t\trev.diffopt.b_prefix = \"i/\";\n\t} /* else use prefix as per user config */\n\trun_diff_index(&rev, 1);\n\tif (s->verbose > 1 &&\n\t    wt_status_check_worktree_changes(s, &dirty_submodules)) {\n\t\tstatus_printf_ln(s, c,\n\t\t\t\"--------------------------------------------------\");\n\t\tstatus_printf_ln(s, c, _(\"Changes not staged for commit:\"));\n\t\tsetup_work_tree();\n\t\trev.diffopt.a_prefix = \"i/\";\n\t\trev.diffopt.b_prefix = \"w/\";\n\t\trun_diff_files(&rev, 0);\n\t}\n}\n\nstatic void wt_status_print_tracking(struct wt_status *s)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *cp, *ep, *branch_name;\n\tstruct branch *branch;\n\tchar comment_line_string[3];\n\tint i;\n\n\tassert(s->branch && !s->is_initial);\n\tif (!skip_prefix(s->branch, \"refs/heads/\", &branch_name))\n\t\treturn;\n\tbranch = branch_get(branch_name);\n\tif (!format_tracking_info(branch, &sb))\n\t\treturn;\n\n\ti = 0;\n\tif (s->display_comment_prefix) {\n\t\tcomment_line_string[i++] = comment_line_char;\n\t\tcomment_line_string[i++] = ' ';\n\t}\n\tcomment_line_string[i] = '\\0';\n\n\tfor (cp = sb.buf; (ep = strchr(cp, '\\n')) != NULL; cp = ep + 1)\n\t\tcolor_fprintf_ln(s->fp, color(WT_STATUS_HEADER, s),\n\t\t\t\t \"%s%.*s\", comment_line_string,\n\t\t\t\t (int)(ep - cp), cp);\n\tif (s->display_comment_prefix)\n\t\tcolor_fprintf_ln(s->fp, color(WT_STATUS_HEADER, s), \"%c\",\n\t\t\t\t comment_line_char);\n\telse\n\t\tfputs(\"\", s->fp);\n}\n\nstatic int has_unmerged(struct wt_status *s)\n{\n\tint i;\n\n\tfor (i = 0; i < s->change.nr; i++) {\n\t\tstruct wt_status_change_data *d;\n\t\td = s->change.items[i].util;\n\t\tif (d->stagemask)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void show_merge_in_progress(struct wt_status *s,\n\t\t\t\tstruct wt_status_state *state,\n\t\t\t\tconst char *color)\n{\n\tif (has_unmerged(s)) {\n\t\tstatus_printf_ln(s, color, _(\"You have unmerged paths.\"));\n\t\tif (s->hints)\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t_(\"  (fix conflicts and run \\\"git commit\\\")\"));\n\t} else {\n\t\tstatus_printf_ln(s, color,\n\t\t\t_(\"All conflicts fixed but you are still merging.\"));\n\t\tif (s->hints)\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t_(\"  (use \\\"git commit\\\" to conclude merge)\"));\n\t}\n\twt_status_print_trailer(s);\n}\n\nstatic void show_am_in_progress(struct wt_status *s,\n\t\t\t\tstruct wt_status_state *state,\n\t\t\t\tconst char *color)\n{\n\tstatus_printf_ln(s, color,\n\t\t_(\"You are in the middle of an am session.\"));\n\tif (state->am_empty_patch)\n\t\tstatus_printf_ln(s, color,\n\t\t\t_(\"The current patch is empty.\"));\n\tif (s->hints) {\n\t\tif (!state->am_empty_patch)\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t_(\"  (fix conflicts and then run \\\"git am --continue\\\")\"));\n\t\tstatus_printf_ln(s, color,\n\t\t\t_(\"  (use \\\"git am --skip\\\" to skip this patch)\"));\n\t\tstatus_printf_ln(s, color,\n\t\t\t_(\"  (use \\\"git am --abort\\\" to restore the original branch)\"));\n\t}\n\twt_status_print_trailer(s);\n}\n\nstatic char *read_line_from_git_path(const char *filename)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tFILE *fp = fopen(git_path(\"%s\", filename), \"r\");\n\tif (!fp) {\n\t\tstrbuf_release(&buf);\n\t\treturn NULL;\n\t}\n\tstrbuf_getline_lf(&buf, fp);\n\tif (!fclose(fp)) {\n\t\treturn strbuf_detach(&buf, NULL);\n\t} else {\n\t\tstrbuf_release(&buf);\n\t\treturn NULL;\n\t}\n}\n\nstatic int split_commit_in_progress(struct wt_status *s)\n{\n\tint split_in_progress = 0;\n\tchar *head = read_line_from_git_path(\"HEAD\");\n\tchar *orig_head = read_line_from_git_path(\"ORIG_HEAD\");\n\tchar *rebase_amend = read_line_from_git_path(\"rebase-merge/amend\");\n\tchar *rebase_orig_head = read_line_from_git_path(\"rebase-merge/orig-head\");\n\n\tif (!head || !orig_head || !rebase_amend || !rebase_orig_head ||\n\t    !s->branch || strcmp(s->branch, \"HEAD\"))\n\t\treturn split_in_progress;\n\n\tif (!strcmp(rebase_amend, rebase_orig_head)) {\n\t\tif (strcmp(head, rebase_amend))\n\t\t\tsplit_in_progress = 1;\n\t} else if (strcmp(orig_head, rebase_orig_head)) {\n\t\tsplit_in_progress = 1;\n\t}\n\n\tif (!s->amend && !s->nowarn && !s->workdir_dirty)\n\t\tsplit_in_progress = 0;\n\n\tfree(head);\n\tfree(orig_head);\n\tfree(rebase_amend);\n\tfree(rebase_orig_head);\n\treturn split_in_progress;\n}\n\n/*\n * Turn\n * \"pick d6a2f0303e897ec257dd0e0a39a5ccb709bc2047 some message\"\n * into\n * \"pick d6a2f03 some message\"\n *\n * The function assumes that the line does not contain useless spaces\n * before or after the command.\n */\nstatic void abbrev_sha1_in_line(struct strbuf *line)\n{\n\tstruct strbuf **split;\n\tint i;\n\n\tif (starts_with(line->buf, \"exec \") ||\n\t    starts_with(line->buf, \"x \"))\n\t\treturn;\n\n\tsplit = strbuf_split_max(line, ' ', 3);\n\tif (split[0] && split[1]) {\n\t\tunsigned char sha1[20];\n\t\tconst char *abbrev;\n\n\t\t/*\n\t\t * strbuf_split_max left a space. Trim it and re-add\n\t\t * it after abbreviation.\n\t\t */\n\t\tstrbuf_trim(split[1]);\n\t\tif (!get_sha1(split[1]->buf, sha1)) {\n\t\t\tabbrev = find_unique_abbrev(sha1, DEFAULT_ABBREV);\n\t\t\tstrbuf_reset(split[1]);\n\t\t\tstrbuf_addf(split[1], \"%s \", abbrev);\n\t\t\tstrbuf_reset(line);\n\t\t\tfor (i = 0; split[i]; i++)\n\t\t\t\tstrbuf_addf(line, \"%s\", split[i]->buf);\n\t\t}\n\t}\n\tstrbuf_list_free(split);\n}\n\nstatic void read_rebase_todolist(const char *fname, struct string_list *lines)\n{\n\tstruct strbuf line = STRBUF_INIT;\n\tFILE *f = fopen(git_path(\"%s\", fname), \"r\");\n\n\tif (!f)\n\t\tdie_errno(\"Could not open file %s for reading\",\n\t\t\t  git_path(\"%s\", fname));\n\twhile (!strbuf_getline_lf(&line, f)) {\n\t\tif (line.len && line.buf[0] == comment_line_char)\n\t\t\tcontinue;\n\t\tstrbuf_trim(&line);\n\t\tif (!line.len)\n\t\t\tcontinue;\n\t\tabbrev_sha1_in_line(&line);\n\t\tstring_list_append(lines, line.buf);\n\t}\n}\n\nstatic void show_rebase_information(struct wt_status *s,\n\t\t\t\t\tstruct wt_status_state *state,\n\t\t\t\t\tconst char *color)\n{\n\tif (state->rebase_interactive_in_progress) {\n\t\tint i;\n\t\tint nr_lines_to_show = 2;\n\n\t\tstruct string_list have_done = STRING_LIST_INIT_DUP;\n\t\tstruct string_list yet_to_do = STRING_LIST_INIT_DUP;\n\n\t\tread_rebase_todolist(\"rebase-merge/done\", &have_done);\n\t\tread_rebase_todolist(\"rebase-merge/git-rebase-todo\", &yet_to_do);\n\n\t\tif (have_done.nr == 0)\n\t\t\tstatus_printf_ln(s, color, _(\"No commands done.\"));\n\t\telse {\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\tQ_(\"Last command done (%d command done):\",\n\t\t\t\t\t\"Last commands done (%d commands done):\",\n\t\t\t\t\thave_done.nr),\n\t\t\t\thave_done.nr);\n\t\t\tfor (i = (have_done.nr > nr_lines_to_show)\n\t\t\t\t? have_done.nr - nr_lines_to_show : 0;\n\t\t\t\ti < have_done.nr;\n\t\t\t\ti++)\n\t\t\t\tstatus_printf_ln(s, color, \"   %s\", have_done.items[i].string);\n\t\t\tif (have_done.nr > nr_lines_to_show && s->hints)\n\t\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t\t_(\"  (see more in file %s)\"), git_path(\"rebase-merge/done\"));\n\t\t}\n\n\t\tif (yet_to_do.nr == 0)\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t\t _(\"No commands remaining.\"));\n\t\telse {\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\tQ_(\"Next command to do (%d remaining command):\",\n\t\t\t\t\t\"Next commands to do (%d remaining commands):\",\n\t\t\t\t\tyet_to_do.nr),\n\t\t\t\tyet_to_do.nr);\n\t\t\tfor (i = 0; i < nr_lines_to_show && i < yet_to_do.nr; i++)\n\t\t\t\tstatus_printf_ln(s, color, \"   %s\", yet_to_do.items[i].string);\n\t\t\tif (s->hints)\n\t\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t\t_(\"  (use \\\"git rebase --edit-todo\\\" to view and edit)\"));\n\t\t}\n\t\tstring_list_clear(&yet_to_do, 0);\n\t\tstring_list_clear(&have_done, 0);\n\t}\n}\n\nstatic void print_rebase_state(struct wt_status *s,\n\t\t\t\tstruct wt_status_state *state,\n\t\t\t\tconst char *color)\n{\n\tif (state->branch)\n\t\tstatus_printf_ln(s, color,\n\t\t\t\t _(\"You are currently rebasing branch '%s' on '%s'.\"),\n\t\t\t\t state->branch,\n\t\t\t\t state->onto);\n\telse\n\t\tstatus_printf_ln(s, color,\n\t\t\t\t _(\"You are currently rebasing.\"));\n}\n\nstatic void show_rebase_in_progress(struct wt_status *s,\n\t\t\t\tstruct wt_status_state *state,\n\t\t\t\tconst char *color)\n{\n\tstruct stat st;\n\n\tshow_rebase_information(s, state, color);\n\tif (has_unmerged(s)) {\n\t\tprint_rebase_state(s, state, color);\n\t\tif (s->hints) {\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t_(\"  (fix conflicts and then run \\\"git rebase --continue\\\")\"));\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t_(\"  (use \\\"git rebase --skip\\\" to skip this patch)\"));\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t_(\"  (use \\\"git rebase --abort\\\" to check out the original branch)\"));\n\t\t}\n\t} else if (state->rebase_in_progress || !stat(git_path_merge_msg(), &st)) {\n\t\tprint_rebase_state(s, state, color);\n\t\tif (s->hints)\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t_(\"  (all conflicts fixed: run \\\"git rebase --continue\\\")\"));\n\t} else if (split_commit_in_progress(s)) {\n\t\tif (state->branch)\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t\t _(\"You are currently splitting a commit while rebasing branch '%s' on '%s'.\"),\n\t\t\t\t\t state->branch,\n\t\t\t\t\t state->onto);\n\t\telse\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t\t _(\"You are currently splitting a commit during a rebase.\"));\n\t\tif (s->hints)\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t_(\"  (Once your working directory is clean, run \\\"git rebase --continue\\\")\"));\n\t} else {\n\t\tif (state->branch)\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t\t _(\"You are currently editing a commit while rebasing branch '%s' on '%s'.\"),\n\t\t\t\t\t state->branch,\n\t\t\t\t\t state->onto);\n\t\telse\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t\t _(\"You are currently editing a commit during a rebase.\"));\n\t\tif (s->hints && !s->amend) {\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t_(\"  (use \\\"git commit --amend\\\" to amend the current commit)\"));\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t_(\"  (use \\\"git rebase --continue\\\" once you are satisfied with your changes)\"));\n\t\t}\n\t}\n\twt_status_print_trailer(s);\n}\n\nstatic void show_cherry_pick_in_progress(struct wt_status *s,\n\t\t\t\t\tstruct wt_status_state *state,\n\t\t\t\t\tconst char *color)\n{\n\tstatus_printf_ln(s, color, _(\"You are currently cherry-picking commit %s.\"),\n\t\t\tfind_unique_abbrev(state->cherry_pick_head_sha1, DEFAULT_ABBREV));\n\tif (s->hints) {\n\t\tif (has_unmerged(s))\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t_(\"  (fix conflicts and run \\\"git cherry-pick --continue\\\")\"));\n\t\telse\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t_(\"  (all conflicts fixed: run \\\"git cherry-pick --continue\\\")\"));\n\t\tstatus_printf_ln(s, color,\n\t\t\t_(\"  (use \\\"git cherry-pick --abort\\\" to cancel the cherry-pick operation)\"));\n\t}\n\twt_status_print_trailer(s);\n}\n\nstatic void show_revert_in_progress(struct wt_status *s,\n\t\t\t\t\tstruct wt_status_state *state,\n\t\t\t\t\tconst char *color)\n{\n\tstatus_printf_ln(s, color, _(\"You are currently reverting commit %s.\"),\n\t\t\t find_unique_abbrev(state->revert_head_sha1, DEFAULT_ABBREV));\n\tif (s->hints) {\n\t\tif (has_unmerged(s))\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t_(\"  (fix conflicts and run \\\"git revert --continue\\\")\"));\n\t\telse\n\t\t\tstatus_printf_ln(s, color,\n\t\t\t\t_(\"  (all conflicts fixed: run \\\"git revert --continue\\\")\"));\n\t\tstatus_printf_ln(s, color,\n\t\t\t_(\"  (use \\\"git revert --abort\\\" to cancel the revert operation)\"));\n\t}\n\twt_status_print_trailer(s);\n}\n\nstatic void show_bisect_in_progress(struct wt_status *s,\n\t\t\t\tstruct wt_status_state *state,\n\t\t\t\tconst char *color)\n{\n\tif (state->branch)\n\t\tstatus_printf_ln(s, color,\n\t\t\t\t _(\"You are currently bisecting, started from branch '%s'.\"),\n\t\t\t\t state->branch);\n\telse\n\t\tstatus_printf_ln(s, color,\n\t\t\t\t _(\"You are currently bisecting.\"));\n\tif (s->hints)\n\t\tstatus_printf_ln(s, color,\n\t\t\t_(\"  (use \\\"git bisect reset\\\" to get back to the original branch)\"));\n\twt_status_print_trailer(s);\n}\n\n/*\n * Extract branch information from rebase/bisect\n */\nstatic char *get_branch(const struct worktree *wt, const char *path)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tunsigned char sha1[20];\n\tconst char *branch_name;\n\n\tif (strbuf_read_file(&sb, worktree_git_path(wt, \"%s\", path), 0) <= 0)\n\t\tgoto got_nothing;\n\n\twhile (sb.len && sb.buf[sb.len - 1] == '\\n')\n\t\tstrbuf_setlen(&sb, sb.len - 1);\n\tif (!sb.len)\n\t\tgoto got_nothing;\n\tif (skip_prefix(sb.buf, \"refs/heads/\", &branch_name))\n\t\tstrbuf_remove(&sb, 0, branch_name - sb.buf);\n\telse if (starts_with(sb.buf, \"refs/\"))\n\t\t;\n\telse if (!get_sha1_hex(sb.buf, sha1)) {\n\t\tconst char *abbrev;\n\t\tabbrev = find_unique_abbrev(sha1, DEFAULT_ABBREV);\n\t\tstrbuf_reset(&sb);\n\t\tstrbuf_addstr(&sb, abbrev);\n\t} else if (!strcmp(sb.buf, \"detached HEAD\")) /* rebase */\n\t\tgoto got_nothing;\n\telse\t\t\t/* bisect */\n\t\t;\n\treturn strbuf_detach(&sb, NULL);\n\ngot_nothing:\n\tstrbuf_release(&sb);\n\treturn NULL;\n}\n\nstruct grab_1st_switch_cbdata {\n\tstruct strbuf buf;\n\tunsigned char nsha1[20];\n};\n\nstatic int grab_1st_switch(unsigned char *osha1, unsigned char *nsha1,\n\t\t\t   const char *email, unsigned long timestamp, int tz,\n\t\t\t   const char *message, void *cb_data)\n{\n\tstruct grab_1st_switch_cbdata *cb = cb_data;\n\tconst char *target = NULL, *end;\n\n\tif (!skip_prefix(message, \"checkout: moving from \", &message))\n\t\treturn 0;\n\ttarget = strstr(message, \" to \");\n\tif (!target)\n\t\treturn 0;\n\ttarget += strlen(\" to \");\n\tstrbuf_reset(&cb->buf);\n\thashcpy(cb->nsha1, nsha1);\n\tend = strchrnul(target, '\\n');\n\tstrbuf_add(&cb->buf, target, end - target);\n\tif (!strcmp(cb->buf.buf, \"HEAD\")) {\n\t\t/* HEAD is relative. Resolve it to the right reflog entry. */\n\t\tstrbuf_reset(&cb->buf);\n\t\tstrbuf_addstr(&cb->buf,\n\t\t\t      find_unique_abbrev(nsha1, DEFAULT_ABBREV));\n\t}\n\treturn 1;\n}\n\nstatic void wt_status_get_detached_from(struct wt_status_state *state)\n{\n\tstruct grab_1st_switch_cbdata cb;\n\tstruct commit *commit;\n\tunsigned char sha1[20];\n\tchar *ref = NULL;\n\n\tstrbuf_init(&cb.buf, 0);\n\tif (for_each_reflog_ent_reverse(\"HEAD\", grab_1st_switch, &cb) <= 0) {\n\t\tstrbuf_release(&cb.buf);\n\t\treturn;\n\t}\n\n\tif (dwim_ref(cb.buf.buf, cb.buf.len, sha1, &ref) == 1 &&\n\t    /* sha1 is a commit? match without further lookup */\n\t    (!hashcmp(cb.nsha1, sha1) ||\n\t     /* perhaps sha1 is a tag, try to dereference to a commit */\n\t     ((commit = lookup_commit_reference_gently(sha1, 1)) != NULL &&\n\t      !hashcmp(cb.nsha1, commit->object.oid.hash)))) {\n\t\tconst char *from = ref;\n\t\tif (!skip_prefix(from, \"refs/tags/\", &from))\n\t\t\tskip_prefix(from, \"refs/remotes/\", &from);\n\t\tstate->detached_from = xstrdup(from);\n\t} else\n\t\tstate->detached_from =\n\t\t\txstrdup(find_unique_abbrev(cb.nsha1, DEFAULT_ABBREV));\n\thashcpy(state->detached_sha1, cb.nsha1);\n\tstate->detached_at = !get_sha1(\"HEAD\", sha1) &&\n\t\t\t     !hashcmp(sha1, state->detached_sha1);\n\n\tfree(ref);\n\tstrbuf_release(&cb.buf);\n}\n\nint wt_status_check_rebase(const struct worktree *wt,\n\t\t\t   struct wt_status_state *state)\n{\n\tstruct stat st;\n\n\tif (!stat(worktree_git_path(wt, \"rebase-apply\"), &st)) {\n\t\tif (!stat(worktree_git_path(wt, \"rebase-apply/applying\"), &st)) {\n\t\t\tstate->am_in_progress = 1;\n\t\t\tif (!stat(worktree_git_path(wt, \"rebase-apply/patch\"), &st) && !st.st_size)\n\t\t\t\tstate->am_empty_patch = 1;\n\t\t} else {\n\t\t\tstate->rebase_in_progress = 1;\n\t\t\tstate->branch = get_branch(wt, \"rebase-apply/head-name\");\n\t\t\tstate->onto = get_branch(wt, \"rebase-apply/onto\");\n\t\t}\n\t} else if (!stat(worktree_git_path(wt, \"rebase-merge\"), &st)) {\n\t\tif (!stat(worktree_git_path(wt, \"rebase-merge/interactive\"), &st))\n\t\t\tstate->rebase_interactive_in_progress = 1;\n\t\telse\n\t\t\tstate->rebase_in_progress = 1;\n\t\tstate->branch = get_branch(wt, \"rebase-merge/head-name\");\n\t\tstate->onto = get_branch(wt, \"rebase-merge/onto\");\n\t} else\n\t\treturn 0;\n\treturn 1;\n}\n\nint wt_status_check_bisect(const struct worktree *wt,\n\t\t\t   struct wt_status_state *state)\n{\n\tstruct stat st;\n\n\tif (!stat(worktree_git_path(wt, \"BISECT_LOG\"), &st)) {\n\t\tstate->bisect_in_progress = 1;\n\t\tstate->branch = get_branch(wt, \"BISECT_START\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid wt_status_get_state(struct wt_status_state *state,\n\t\t\t int get_detached_from)\n{\n\tstruct stat st;\n\tunsigned char sha1[20];\n\n\tif (!stat(git_path_merge_head(), &st)) {\n\t\tstate->merge_in_progress = 1;\n\t} else if (wt_status_check_rebase(NULL, state)) {\n\t\t;\t\t/* all set */\n\t} else if (!stat(git_path_cherry_pick_head(), &st) &&\n\t\t\t!get_sha1(\"CHERRY_PICK_HEAD\", sha1)) {\n\t\tstate->cherry_pick_in_progress = 1;\n\t\thashcpy(state->cherry_pick_head_sha1, sha1);\n\t}\n\twt_status_check_bisect(NULL, state);\n\tif (!stat(git_path_revert_head(), &st) &&\n\t    !get_sha1(\"REVERT_HEAD\", sha1)) {\n\t\tstate->revert_in_progress = 1;\n\t\thashcpy(state->revert_head_sha1, sha1);\n\t}\n\n\tif (get_detached_from)\n\t\twt_status_get_detached_from(state);\n}\n\nstatic void wt_status_print_state(struct wt_status *s,\n\t\t\t\t  struct wt_status_state *state)\n{\n\tconst char *state_color = color(WT_STATUS_HEADER, s);\n\tif (state->merge_in_progress)\n\t\tshow_merge_in_progress(s, state, state_color);\n\telse if (state->am_in_progress)\n\t\tshow_am_in_progress(s, state, state_color);\n\telse if (state->rebase_in_progress || state->rebase_interactive_in_progress)\n\t\tshow_rebase_in_progress(s, state, state_color);\n\telse if (state->cherry_pick_in_progress)\n\t\tshow_cherry_pick_in_progress(s, state, state_color);\n\telse if (state->revert_in_progress)\n\t\tshow_revert_in_progress(s, state, state_color);\n\tif (state->bisect_in_progress)\n\t\tshow_bisect_in_progress(s, state, state_color);\n}\n\nvoid wt_status_print(struct wt_status *s)\n{\n\tconst char *branch_color = color(WT_STATUS_ONBRANCH, s);\n\tconst char *branch_status_color = color(WT_STATUS_HEADER, s);\n\tstruct wt_status_state state;\n\n\tmemset(&state, 0, sizeof(state));\n\twt_status_get_state(&state,\n\t\t\t    s->branch && !strcmp(s->branch, \"HEAD\"));\n\n\tif (s->branch) {\n\t\tconst char *on_what = _(\"On branch \");\n\t\tconst char *branch_name = s->branch;\n\t\tif (!strcmp(branch_name, \"HEAD\")) {\n\t\t\tbranch_status_color = color(WT_STATUS_NOBRANCH, s);\n\t\t\tif (state.rebase_in_progress || state.rebase_interactive_in_progress) {\n\t\t\t\tif (state.rebase_interactive_in_progress)\n\t\t\t\t\ton_what = _(\"interactive rebase in progress; onto \");\n\t\t\t\telse\n\t\t\t\t\ton_what = _(\"rebase in progress; onto \");\n\t\t\t\tbranch_name = state.onto;\n\t\t\t} else if (state.detached_from) {\n\t\t\t\tbranch_name = state.detached_from;\n\t\t\t\tif (state.detached_at)\n\t\t\t\t\ton_what = _(\"HEAD detached at \");\n\t\t\t\telse\n\t\t\t\t\ton_what = _(\"HEAD detached from \");\n\t\t\t} else {\n\t\t\t\tbranch_name = \"\";\n\t\t\t\ton_what = _(\"Not currently on any branch.\");\n\t\t\t}\n\t\t} else\n\t\t\tskip_prefix(branch_name, \"refs/heads/\", &branch_name);\n\t\tstatus_printf(s, color(WT_STATUS_HEADER, s), \"%s\", \"\");\n\t\tstatus_printf_more(s, branch_status_color, \"%s\", on_what);\n\t\tstatus_printf_more(s, branch_color, \"%s\\n\", branch_name);\n\t\tif (!s->is_initial)\n\t\t\twt_status_print_tracking(s);\n\t}\n\n\twt_status_print_state(s, &state);\n\tfree(state.branch);\n\tfree(state.onto);\n\tfree(state.detached_from);\n\n\tif (s->is_initial) {\n\t\tstatus_printf_ln(s, color(WT_STATUS_HEADER, s), \"%s\", \"\");\n\t\tstatus_printf_ln(s, color(WT_STATUS_HEADER, s), _(\"Initial commit\"));\n\t\tstatus_printf_ln(s, color(WT_STATUS_HEADER, s), \"%s\", \"\");\n\t}\n\n\twt_status_print_updated(s);\n\twt_status_print_unmerged(s);\n\twt_status_print_changed(s);\n\tif (s->submodule_summary &&\n\t    (!s->ignore_submodule_arg ||\n\t     strcmp(s->ignore_submodule_arg, \"all\"))) {\n\t\twt_status_print_submodule_summary(s, 0);  /* staged */\n\t\twt_status_print_submodule_summary(s, 1);  /* unstaged */\n\t}\n\tif (s->show_untracked_files) {\n\t\twt_status_print_other(s, &s->untracked, _(\"Untracked files\"), \"add\");\n\t\tif (s->show_ignored_files)\n\t\t\twt_status_print_other(s, &s->ignored, _(\"Ignored files\"), \"add -f\");\n\t\tif (advice_status_u_option && 2000 < s->untracked_in_ms) {\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL, \"%s\", \"\");\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t\t _(\"It took %.2f seconds to enumerate untracked files. 'status -uno'\\n\"\n\t\t\t\t\t   \"may speed it up, but you have to be careful not to forget to add\\n\"\n\t\t\t\t\t   \"new files yourself (see 'git help status').\"),\n\t\t\t\t\t s->untracked_in_ms / 1000.0);\n\t\t}\n\t} else if (s->commitable)\n\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL, _(\"Untracked files not listed%s\"),\n\t\t\ts->hints\n\t\t\t? _(\" (use -u option to show untracked files)\") : \"\");\n\n\tif (s->verbose)\n\t\twt_status_print_verbose(s);\n\tif (!s->commitable) {\n\t\tif (s->amend)\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL, _(\"No changes\"));\n\t\telse if (s->nowarn)\n\t\t\t; /* nothing */\n\t\telse if (s->workdir_dirty) {\n\t\t\tif (s->hints)\n\t\t\t\tprintf(_(\"no changes added to commit \"\n\t\t\t\t\t \"(use \\\"git add\\\" and/or \\\"git commit -a\\\")\\n\"));\n\t\t\telse\n\t\t\t\tprintf(_(\"no changes added to commit\\n\"));\n\t\t} else if (s->untracked.nr) {\n\t\t\tif (s->hints)\n\t\t\t\tprintf(_(\"nothing added to commit but untracked files \"\n\t\t\t\t\t \"present (use \\\"git add\\\" to track)\\n\"));\n\t\t\telse\n\t\t\t\tprintf(_(\"nothing added to commit but untracked files present\\n\"));\n\t\t} else if (s->is_initial) {\n\t\t\tif (s->hints)\n\t\t\t\tprintf(_(\"nothing to commit (create/copy files \"\n\t\t\t\t\t \"and use \\\"git add\\\" to track)\\n\"));\n\t\t\telse\n\t\t\t\tprintf(_(\"nothing to commit\\n\"));\n\t\t} else if (!s->show_untracked_files) {\n\t\t\tif (s->hints)\n\t\t\t\tprintf(_(\"nothing to commit (use -u to show untracked files)\\n\"));\n\t\t\telse\n\t\t\t\tprintf(_(\"nothing to commit\\n\"));\n\t\t} else\n\t\t\tprintf(_(\"nothing to commit, working directory clean\\n\"));\n\t}\n}\n\nstatic void wt_shortstatus_unmerged(struct string_list_item *it,\n\t\t\t   struct wt_status *s)\n{\n\tstruct wt_status_change_data *d = it->util;\n\tconst char *how = \"??\";\n\n\tswitch (d->stagemask) {\n\tcase 1: how = \"DD\"; break; /* both deleted */\n\tcase 2: how = \"AU\"; break; /* added by us */\n\tcase 3: how = \"UD\"; break; /* deleted by them */\n\tcase 4: how = \"UA\"; break; /* added by them */\n\tcase 5: how = \"DU\"; break; /* deleted by us */\n\tcase 6: how = \"AA\"; break; /* both added */\n\tcase 7: how = \"UU\"; break; /* both modified */\n\t}\n\tcolor_fprintf(s->fp, color(WT_STATUS_UNMERGED, s), \"%s\", how);\n\tif (s->null_termination) {\n\t\tfprintf(stdout, \" %s%c\", it->string, 0);\n\t} else {\n\t\tstruct strbuf onebuf = STRBUF_INIT;\n\t\tconst char *one;\n\t\tone = quote_path(it->string, s->prefix, &onebuf);\n\t\tprintf(\" %s\\n\", one);\n\t\tstrbuf_release(&onebuf);\n\t}\n}\n\nstatic void wt_shortstatus_status(struct string_list_item *it,\n\t\t\t struct wt_status *s)\n{\n\tstruct wt_status_change_data *d = it->util;\n\n\tif (d->index_status)\n\t\tcolor_fprintf(s->fp, color(WT_STATUS_UPDATED, s), \"%c\", d->index_status);\n\telse\n\t\tputchar(' ');\n\tif (d->worktree_status)\n\t\tcolor_fprintf(s->fp, color(WT_STATUS_CHANGED, s), \"%c\", d->worktree_status);\n\telse\n\t\tputchar(' ');\n\tputchar(' ');\n\tif (s->null_termination) {\n\t\tfprintf(stdout, \"%s%c\", it->string, 0);\n\t\tif (d->head_path)\n\t\t\tfprintf(stdout, \"%s%c\", d->head_path, 0);\n\t} else {\n\t\tstruct strbuf onebuf = STRBUF_INIT;\n\t\tconst char *one;\n\t\tif (d->head_path) {\n\t\t\tone = quote_path(d->head_path, s->prefix, &onebuf);\n\t\t\tif (*one != '\"' && strchr(one, ' ') != NULL) {\n\t\t\t\tputchar('\"');\n\t\t\t\tstrbuf_addch(&onebuf, '\"');\n\t\t\t\tone = onebuf.buf;\n\t\t\t}\n\t\t\tprintf(\"%s -> \", one);\n\t\t\tstrbuf_release(&onebuf);\n\t\t}\n\t\tone = quote_path(it->string, s->prefix, &onebuf);\n\t\tif (*one != '\"' && strchr(one, ' ') != NULL) {\n\t\t\tputchar('\"');\n\t\t\tstrbuf_addch(&onebuf, '\"');\n\t\t\tone = onebuf.buf;\n\t\t}\n\t\tprintf(\"%s\\n\", one);\n\t\tstrbuf_release(&onebuf);\n\t}\n}\n\nstatic void wt_shortstatus_other(struct string_list_item *it,\n\t\t\t\t struct wt_status *s, const char *sign)\n{\n\tif (s->null_termination) {\n\t\tfprintf(stdout, \"%s %s%c\", sign, it->string, 0);\n\t} else {\n\t\tstruct strbuf onebuf = STRBUF_INIT;\n\t\tconst char *one;\n\t\tone = quote_path(it->string, s->prefix, &onebuf);\n\t\tcolor_fprintf(s->fp, color(WT_STATUS_UNTRACKED, s), \"%s\", sign);\n\t\tprintf(\" %s\\n\", one);\n\t\tstrbuf_release(&onebuf);\n\t}\n}\n\nstatic void wt_shortstatus_print_tracking(struct wt_status *s)\n{\n\tstruct branch *branch;\n\tconst char *header_color = color(WT_STATUS_HEADER, s);\n\tconst char *branch_color_local = color(WT_STATUS_LOCAL_BRANCH, s);\n\tconst char *branch_color_remote = color(WT_STATUS_REMOTE_BRANCH, s);\n\n\tconst char *base;\n\tconst char *branch_name;\n\tint num_ours, num_theirs;\n\tint upstream_is_gone = 0;\n\n\tcolor_fprintf(s->fp, color(WT_STATUS_HEADER, s), \"## \");\n\n\tif (!s->branch)\n\t\treturn;\n\tbranch_name = s->branch;\n\n\tif (s->is_initial)\n\t\tcolor_fprintf(s->fp, header_color, _(\"Initial commit on \"));\n\n\tif (!strcmp(s->branch, \"HEAD\")) {\n\t\tcolor_fprintf(s->fp, color(WT_STATUS_NOBRANCH, s), \"%s\",\n\t\t\t      _(\"HEAD (no branch)\"));\n\t\tgoto conclude;\n\t}\n\n\tskip_prefix(branch_name, \"refs/heads/\", &branch_name);\n\n\tbranch = branch_get(branch_name);\n\n\tcolor_fprintf(s->fp, branch_color_local, \"%s\", branch_name);\n\n\tif (stat_tracking_info(branch, &num_ours, &num_theirs, &base) < 0) {\n\t\tif (!base)\n\t\t\tgoto conclude;\n\n\t\tupstream_is_gone = 1;\n\t}\n\n\tbase = shorten_unambiguous_ref(base, 0);\n\tcolor_fprintf(s->fp, header_color, \"...\");\n\tcolor_fprintf(s->fp, branch_color_remote, \"%s\", base);\n\tfree((char *)base);\n\n\tif (!upstream_is_gone && !num_ours && !num_theirs)\n\t\tgoto conclude;\n\n#define LABEL(string) (s->no_gettext ? (string) : _(string))\n\n\tcolor_fprintf(s->fp, header_color, \" [\");\n\tif (upstream_is_gone) {\n\t\tcolor_fprintf(s->fp, header_color, LABEL(N_(\"gone\")));\n\t} else if (!num_ours) {\n\t\tcolor_fprintf(s->fp, header_color, LABEL(N_(\"behind \")));\n\t\tcolor_fprintf(s->fp, branch_color_remote, \"%d\", num_theirs);\n\t} else if (!num_theirs) {\n\t\tcolor_fprintf(s->fp, header_color, LABEL(N_(\"ahead \")));\n\t\tcolor_fprintf(s->fp, branch_color_local, \"%d\", num_ours);\n\t} else {\n\t\tcolor_fprintf(s->fp, header_color, LABEL(N_(\"ahead \")));\n\t\tcolor_fprintf(s->fp, branch_color_local, \"%d\", num_ours);\n\t\tcolor_fprintf(s->fp, header_color, \", %s\", LABEL(N_(\"behind \")));\n\t\tcolor_fprintf(s->fp, branch_color_remote, \"%d\", num_theirs);\n\t}\n\n\tcolor_fprintf(s->fp, header_color, \"]\");\n conclude:\n\tfputc(s->null_termination ? '\\0' : '\\n', s->fp);\n}\n\nvoid wt_shortstatus_print(struct wt_status *s)\n{\n\tint i;\n\n\tif (s->show_branch)\n\t\twt_shortstatus_print_tracking(s);\n\n\tfor (i = 0; i < s->change.nr; i++) {\n\t\tstruct wt_status_change_data *d;\n\t\tstruct string_list_item *it;\n\n\t\tit = &(s->change.items[i]);\n\t\td = it->util;\n\t\tif (d->stagemask)\n\t\t\twt_shortstatus_unmerged(it, s);\n\t\telse\n\t\t\twt_shortstatus_status(it, s);\n\t}\n\tfor (i = 0; i < s->untracked.nr; i++) {\n\t\tstruct string_list_item *it;\n\n\t\tit = &(s->untracked.items[i]);\n\t\twt_shortstatus_other(it, s, \"??\");\n\t}\n\tfor (i = 0; i < s->ignored.nr; i++) {\n\t\tstruct string_list_item *it;\n\n\t\tit = &(s->ignored.items[i]);\n\t\twt_shortstatus_other(it, s, \"!!\");\n\t}\n}\n\nvoid wt_porcelain_print(struct wt_status *s)\n{\n\ts->use_color = 0;\n\ts->relative_paths = 0;\n\ts->prefix = NULL;\n\ts->no_gettext = 1;\n\twt_shortstatus_print(s);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0032ef5f6fad7ef5283615b8f52718c185e27428",
  "sha1_ok": true,
  "size": 48782
}
