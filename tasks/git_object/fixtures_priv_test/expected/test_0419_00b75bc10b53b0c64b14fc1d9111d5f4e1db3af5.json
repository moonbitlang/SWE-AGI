{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgImJsb2IuaCIKI2luY2x1ZGUgInRyZWUuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAicmV2aXNpb24uaCIKI2luY2x1ZGUgImdyZXAuaCIKI2luY2x1ZGUgInJlZmxvZy13YWxrLmgiCiNpbmNsdWRlICJwYXRjaC1pZHMuaCIKCnN0YXRpYyBjaGFyICpwYXRoX25hbWUoc3RydWN0IG5hbWVfcGF0aCAqcGF0aCwgY29uc3QgY2hhciAqbmFtZSkKewoJc3RydWN0IG5hbWVfcGF0aCAqcDsKCWNoYXIgKm4sICptOwoJaW50IG5sZW4gPSBzdHJsZW4obmFtZSk7CglpbnQgbGVuID0gbmxlbiArIDE7CgoJZm9yIChwID0gcGF0aDsgcDsgcCA9IHAtPnVwKSB7CgkJaWYgKHAtPmVsZW1fbGVuKQoJCQlsZW4gKz0gcC0+ZWxlbV9sZW4gKyAxOwoJfQoJbiA9IHhtYWxsb2MobGVuKTsKCW0gPSBuICsgbGVuIC0gKG5sZW4gKyAxKTsKCXN0cmNweShtLCBuYW1lKTsKCWZvciAocCA9IHBhdGg7IHA7IHAgPSBwLT51cCkgewoJCWlmIChwLT5lbGVtX2xlbikgewoJCQltIC09IHAtPmVsZW1fbGVuICsgMTsKCQkJbWVtY3B5KG0sIHAtPmVsZW0sIHAtPmVsZW1fbGVuKTsKCQkJbVtwLT5lbGVtX2xlbl0gPSAnLyc7CgkJfQoJfQoJcmV0dXJuIG47Cn0KCnZvaWQgYWRkX29iamVjdChzdHJ1Y3Qgb2JqZWN0ICpvYmosCgkJc3RydWN0IG9iamVjdF9hcnJheSAqcCwKCQlzdHJ1Y3QgbmFtZV9wYXRoICpwYXRoLAoJCWNvbnN0IGNoYXIgKm5hbWUpCnsKCWFkZF9vYmplY3RfYXJyYXkob2JqLCBwYXRoX25hbWUocGF0aCwgbmFtZSksIHApOwp9CgpzdGF0aWMgdm9pZCBtYXJrX2Jsb2JfdW5pbnRlcmVzdGluZyhzdHJ1Y3QgYmxvYiAqYmxvYikKewoJaWYgKGJsb2ItPm9iamVjdC5mbGFncyAmIFVOSU5URVJFU1RJTkcpCgkJcmV0dXJuOwoJYmxvYi0+b2JqZWN0LmZsYWdzIHw9IFVOSU5URVJFU1RJTkc7Cn0KCnZvaWQgbWFya190cmVlX3VuaW50ZXJlc3Rpbmcoc3RydWN0IHRyZWUgKnRyZWUpCnsKCXN0cnVjdCB0cmVlX2Rlc2MgZGVzYzsKCXN0cnVjdCBuYW1lX2VudHJ5IGVudHJ5OwoJc3RydWN0IG9iamVjdCAqb2JqID0gJnRyZWUtPm9iamVjdDsKCglpZiAob2JqLT5mbGFncyAmIFVOSU5URVJFU1RJTkcpCgkJcmV0dXJuOwoJb2JqLT5mbGFncyB8PSBVTklOVEVSRVNUSU5HOwoJaWYgKCFoYXNfc2hhMV9maWxlKG9iai0+c2hhMSkpCgkJcmV0dXJuOwoJaWYgKHBhcnNlX3RyZWUodHJlZSkgPCAwKQoJCWRpZSgiYmFkIHRyZWUgJXMiLCBzaGExX3RvX2hleChvYmotPnNoYTEpKTsKCglpbml0X3RyZWVfZGVzYygmZGVzYywgdHJlZS0+YnVmZmVyLCB0cmVlLT5zaXplKTsKCXdoaWxlICh0cmVlX2VudHJ5KCZkZXNjLCAmZW50cnkpKSB7CgkJaWYgKFNfSVNESVIoZW50cnkubW9kZSkpCgkJCW1hcmtfdHJlZV91bmludGVyZXN0aW5nKGxvb2t1cF90cmVlKGVudHJ5LnNoYTEpKTsKCQllbHNlCgkJCW1hcmtfYmxvYl91bmludGVyZXN0aW5nKGxvb2t1cF9ibG9iKGVudHJ5LnNoYTEpKTsKCX0KCgkvKgoJICogV2UgZG9uJ3QgY2FyZSBhYm91dCB0aGUgdHJlZSBhbnkgbW9yZQoJICogYWZ0ZXIgaXQgaGFzIGJlZW4gbWFya2VkIHVuaW50ZXJlc3RpbmcuCgkgKi8KCWZyZWUodHJlZS0+YnVmZmVyKTsKCXRyZWUtPmJ1ZmZlciA9IE5VTEw7Cn0KCnZvaWQgbWFya19wYXJlbnRzX3VuaW50ZXJlc3Rpbmcoc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMgPSBjb21taXQtPnBhcmVudHM7CgoJd2hpbGUgKHBhcmVudHMpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBwYXJlbnRzLT5pdGVtOwoJCWlmICghKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgVU5JTlRFUkVTVElORykpIHsKCQkJY29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gVU5JTlRFUkVTVElORzsKCgkJCS8qCgkJCSAqIE5vcm1hbGx5IHdlIGhhdmVuJ3QgcGFyc2VkIHRoZSBwYXJlbnQKCQkJICogeWV0LCBzbyB3ZSB3b24ndCBoYXZlIGEgcGFyZW50IG9mIGEgcGFyZW50CgkJCSAqIGhlcmUuIEhvd2V2ZXIsIGl0IG1heSB0dXJuIG91dCB0aGF0IHdlJ3ZlCgkJCSAqIHJlYWNoZWQgdGhpcyBjb21taXQgc29tZSBvdGhlciB3YXkgKHdoZXJlIGl0CgkJCSAqIHdhc24ndCB1bmludGVyZXN0aW5nKSwgaW4gd2hpY2ggY2FzZSB3ZSBuZWVkCgkJCSAqIHRvIG1hcmsgaXRzIHBhcmVudHMgcmVjdXJzaXZlbHkgdG9vLi4KCQkJICovCgkJCWlmIChjb21taXQtPnBhcmVudHMpCgkJCQltYXJrX3BhcmVudHNfdW5pbnRlcmVzdGluZyhjb21taXQpOwoJCX0KCgkJLyoKCQkgKiBBIG1pc3NpbmcgY29tbWl0IGlzIG9rIGlmZiBpdHMgcGFyZW50IGlzIG1hcmtlZAoJCSAqIHVuaW50ZXJlc3RpbmcuCgkJICoKCQkgKiBXZSBqdXN0IG1hcmsgc3VjaCBhIHRoaW5nIHBhcnNlZCwgc28gdGhhdCB3aGVuCgkJICogaXQgaXMgcG9wcGVkIG5leHQgdGltZSBhcm91bmQsIHdlIHdvbid0IGJlIHRyeWluZwoJCSAqIHRvIHBhcnNlIGl0IGFuZCBnZXQgYW4gZXJyb3IuCgkJICovCgkJaWYgKCFoYXNfc2hhMV9maWxlKGNvbW1pdC0+b2JqZWN0LnNoYTEpKQoJCQljb21taXQtPm9iamVjdC5wYXJzZWQgPSAxOwoJCXBhcmVudHMgPSBwYXJlbnRzLT5uZXh0OwoJfQp9CgpzdGF0aWMgdm9pZCBhZGRfcGVuZGluZ19vYmplY3Rfd2l0aF9tb2RlKHN0cnVjdCByZXZfaW5mbyAqcmV2cywgc3RydWN0IG9iamVjdCAqb2JqLCBjb25zdCBjaGFyICpuYW1lLCB1bnNpZ25lZCBtb2RlKQp7CglpZiAocmV2cy0+bm9fd2FsayAmJiAob2JqLT5mbGFncyAmIFVOSU5URVJFU1RJTkcpKQoJCWRpZSgib2JqZWN0IHJhbmdlcyBkbyBub3QgbWFrZSBzZW5zZSB3aGVuIG5vdCB3YWxraW5nIHJldmlzaW9ucyIpOwoJYWRkX29iamVjdF9hcnJheV93aXRoX21vZGUob2JqLCBuYW1lLCAmcmV2cy0+cGVuZGluZywgbW9kZSk7CglpZiAocmV2cy0+cmVmbG9nX2luZm8gJiYgb2JqLT50eXBlID09IE9CSl9DT01NSVQpCgkJYWRkX3JlZmxvZ19mb3Jfd2FsayhyZXZzLT5yZWZsb2dfaW5mbywKCQkJCShzdHJ1Y3QgY29tbWl0ICopb2JqLCBuYW1lKTsKfQoKdm9pZCBhZGRfcGVuZGluZ19vYmplY3Qoc3RydWN0IHJldl9pbmZvICpyZXZzLCBzdHJ1Y3Qgb2JqZWN0ICpvYmosIGNvbnN0IGNoYXIgKm5hbWUpCnsKCWFkZF9wZW5kaW5nX29iamVjdF93aXRoX21vZGUocmV2cywgb2JqLCBuYW1lLCBTX0lGSU5WQUxJRCk7Cn0KCnN0YXRpYyBzdHJ1Y3Qgb2JqZWN0ICpnZXRfcmVmZXJlbmNlKHN0cnVjdCByZXZfaW5mbyAqcmV2cywgY29uc3QgY2hhciAqbmFtZSwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgdW5zaWduZWQgaW50IGZsYWdzKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmplY3Q7CgoJb2JqZWN0ID0gcGFyc2Vfb2JqZWN0KHNoYTEpOwoJaWYgKCFvYmplY3QpCgkJZGllKCJiYWQgb2JqZWN0ICVzIiwgbmFtZSk7CglvYmplY3QtPmZsYWdzIHw9IGZsYWdzOwoJcmV0dXJuIG9iamVjdDsKfQoKc3RhdGljIHN0cnVjdCBjb21taXQgKmhhbmRsZV9jb21taXQoc3RydWN0IHJldl9pbmZvICpyZXZzLCBzdHJ1Y3Qgb2JqZWN0ICpvYmplY3QsIGNvbnN0IGNoYXIgKm5hbWUpCnsKCXVuc2lnbmVkIGxvbmcgZmxhZ3MgPSBvYmplY3QtPmZsYWdzOwoKCS8qCgkgKiBUYWcgb2JqZWN0PyBMb29rIHdoYXQgaXQgcG9pbnRzIHRvLi4KCSAqLwoJd2hpbGUgKG9iamVjdC0+dHlwZSA9PSBPQkpfVEFHKSB7CgkJc3RydWN0IHRhZyAqdGFnID0gKHN0cnVjdCB0YWcgKikgb2JqZWN0OwoJCWlmIChyZXZzLT50YWdfb2JqZWN0cyAmJiAhKGZsYWdzICYgVU5JTlRFUkVTVElORykpCgkJCWFkZF9wZW5kaW5nX29iamVjdChyZXZzLCBvYmplY3QsIHRhZy0+dGFnKTsKCQlvYmplY3QgPSBwYXJzZV9vYmplY3QodGFnLT50YWdnZWQtPnNoYTEpOwoJCWlmICghb2JqZWN0KQoJCQlkaWUoImJhZCBvYmplY3QgJXMiLCBzaGExX3RvX2hleCh0YWctPnRhZ2dlZC0+c2hhMSkpOwoJfQoKCS8qCgkgKiBDb21taXQgb2JqZWN0PyBKdXN0IHJldHVybiBpdCwgd2UnbGwgZG8gYWxsIHRoZSBjb21wbGV4CgkgKiByZWFjaGFiaWxpdHkgY3J1ZC4KCSAqLwoJaWYgKG9iamVjdC0+dHlwZSA9PSBPQkpfQ09NTUlUKSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gKHN0cnVjdCBjb21taXQgKilvYmplY3Q7CgkJaWYgKHBhcnNlX2NvbW1pdChjb21taXQpIDwgMCkKCQkJZGllKCJ1bmFibGUgdG8gcGFyc2UgY29tbWl0ICVzIiwgbmFtZSk7CgkJaWYgKGZsYWdzICYgVU5JTlRFUkVTVElORykgewoJCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBVTklOVEVSRVNUSU5HOwoJCQltYXJrX3BhcmVudHNfdW5pbnRlcmVzdGluZyhjb21taXQpOwoJCQlyZXZzLT5saW1pdGVkID0gMTsKCQl9CgkJcmV0dXJuIGNvbW1pdDsKCX0KCgkvKgoJICogVHJlZSBvYmplY3Q/IEVpdGhlciBtYXJrIGl0IHVuaW5pdGVyZXN0aW5nLCBvciBhZGQgaXQKCSAqIHRvIHRoZSBsaXN0IG9mIG9iamVjdHMgdG8gbG9vayBhdCBsYXRlci4uCgkgKi8KCWlmIChvYmplY3QtPnR5cGUgPT0gT0JKX1RSRUUpIHsKCQlzdHJ1Y3QgdHJlZSAqdHJlZSA9IChzdHJ1Y3QgdHJlZSAqKW9iamVjdDsKCQlpZiAoIXJldnMtPnRyZWVfb2JqZWN0cykKCQkJcmV0dXJuIE5VTEw7CgkJaWYgKGZsYWdzICYgVU5JTlRFUkVTVElORykgewoJCQltYXJrX3RyZWVfdW5pbnRlcmVzdGluZyh0cmVlKTsKCQkJcmV0dXJuIE5VTEw7CgkJfQoJCWFkZF9wZW5kaW5nX29iamVjdChyZXZzLCBvYmplY3QsICIiKTsKCQlyZXR1cm4gTlVMTDsKCX0KCgkvKgoJICogQmxvYiBvYmplY3Q/IFlvdSBrbm93IHRoZSBkcmlsbCBieSBub3cuLgoJICovCglpZiAob2JqZWN0LT50eXBlID09IE9CSl9CTE9CKSB7CgkJc3RydWN0IGJsb2IgKmJsb2IgPSAoc3RydWN0IGJsb2IgKilvYmplY3Q7CgkJaWYgKCFyZXZzLT5ibG9iX29iamVjdHMpCgkJCXJldHVybiBOVUxMOwoJCWlmIChmbGFncyAmIFVOSU5URVJFU1RJTkcpIHsKCQkJbWFya19ibG9iX3VuaW50ZXJlc3RpbmcoYmxvYik7CgkJCXJldHVybiBOVUxMOwoJCX0KCQlhZGRfcGVuZGluZ19vYmplY3QocmV2cywgb2JqZWN0LCAiIik7CgkJcmV0dXJuIE5VTEw7Cgl9CglkaWUoIiVzIGlzIHVua25vd24gb2JqZWN0IiwgbmFtZSk7Cn0KCnN0YXRpYyBpbnQgZXZlcnlib2R5X3VuaW50ZXJlc3Rpbmcoc3RydWN0IGNvbW1pdF9saXN0ICpvcmlnKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QgPSBvcmlnOwoJd2hpbGUgKGxpc3QpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBsaXN0LT5pdGVtOwoJCWxpc3QgPSBsaXN0LT5uZXh0OwoJCWlmIChjb21taXQtPm9iamVjdC5mbGFncyAmIFVOSU5URVJFU1RJTkcpCgkJCWNvbnRpbnVlOwoJCXJldHVybiAwOwoJfQoJcmV0dXJuIDE7Cn0KCi8qCiAqIFRoZSBnb2FsIGlzIHRvIGdldCBSRVZfVFJFRV9ORVcgYXMgdGhlIHJlc3VsdCBvbmx5IGlmIHRoZQogKiBkaWZmIGNvbnNpc3RzIG9mIGFsbCAnKycgKGFuZCBubyBvdGhlciBjaGFuZ2VzKSwgYW5kCiAqIFJFVl9UUkVFX0RJRkZFUkVOVCBvdGhlcndpc2UgKG9mIGNvdXJzZSBpZiB0aGUgdHJlZXMgYXJlCiAqIHRoZSBzYW1lIHdlIHdhbnQgUkVWX1RSRUVfU0FNRSkuICBUaGF0IG1lYW5zIHRoYXQgb25jZSB3ZQogKiBnZXQgdG8gUkVWX1RSRUVfRElGRkVSRU5ULCB3ZSBkbyBub3QgaGF2ZSB0byBsb29rIGFueSBmdXJ0aGVyLgogKi8Kc3RhdGljIGludCB0cmVlX2RpZmZlcmVuY2UgPSBSRVZfVFJFRV9TQU1FOwoKc3RhdGljIHZvaWQgZmlsZV9hZGRfcmVtb3ZlKHN0cnVjdCBkaWZmX29wdGlvbnMgKm9wdGlvbnMsCgkJICAgIGludCBhZGRyZW1vdmUsIHVuc2lnbmVkIG1vZGUsCgkJICAgIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsCgkJICAgIGNvbnN0IGNoYXIgKmJhc2UsIGNvbnN0IGNoYXIgKnBhdGgpCnsKCWludCBkaWZmID0gUkVWX1RSRUVfRElGRkVSRU5UOwoKCS8qCgkgKiBJcyBpdCBhbiBhZGQgb2YgYSBuZXcgZmlsZT8gSXQgbWVhbnMgdGhhdCB0aGUgb2xkIHRyZWUKCSAqIGRpZG4ndCBoYXZlIGl0IGF0IGFsbCwgc28gd2Ugd2lsbCB0dXJuICJSRVZfVFJFRV9TQU1FIiAtPgoJICogIlJFVl9UUkVFX05FVyIsIGJ1dCBsZWF2ZSBhbnkgIlJFVl9UUkVFX0RJRkZFUkVOVCIgYWxvbmUKCSAqIChhbmQgaWYgaXQgYWxyZWFkeSB3YXMgIlJFVl9UUkVFX05FVyIsIHdlJ2xsIGtlZXAgaXQKCSAqICJSRVZfVFJFRV9ORVciIG9mIGNvdXJzZSkuCgkgKi8KCWlmIChhZGRyZW1vdmUgPT0gJysnKSB7CgkJZGlmZiA9IHRyZWVfZGlmZmVyZW5jZTsKCQlpZiAoZGlmZiAhPSBSRVZfVFJFRV9TQU1FKQoJCQlyZXR1cm47CgkJZGlmZiA9IFJFVl9UUkVFX05FVzsKCX0KCXRyZWVfZGlmZmVyZW5jZSA9IGRpZmY7CglpZiAodHJlZV9kaWZmZXJlbmNlID09IFJFVl9UUkVFX0RJRkZFUkVOVCkKCQlvcHRpb25zLT5oYXNfY2hhbmdlcyA9IDE7Cn0KCnN0YXRpYyB2b2lkIGZpbGVfY2hhbmdlKHN0cnVjdCBkaWZmX29wdGlvbnMgKm9wdGlvbnMsCgkJIHVuc2lnbmVkIG9sZF9tb2RlLCB1bnNpZ25lZCBuZXdfbW9kZSwKCQkgY29uc3QgdW5zaWduZWQgY2hhciAqb2xkX3NoYTEsCgkJIGNvbnN0IHVuc2lnbmVkIGNoYXIgKm5ld19zaGExLAoJCSBjb25zdCBjaGFyICpiYXNlLCBjb25zdCBjaGFyICpwYXRoKQp7Cgl0cmVlX2RpZmZlcmVuY2UgPSBSRVZfVFJFRV9ESUZGRVJFTlQ7CglvcHRpb25zLT5oYXNfY2hhbmdlcyA9IDE7Cn0KCnN0YXRpYyBpbnQgcmV2X2NvbXBhcmVfdHJlZShzdHJ1Y3QgcmV2X2luZm8gKnJldnMsIHN0cnVjdCB0cmVlICp0MSwgc3RydWN0IHRyZWUgKnQyKQp7CglpZiAoIXQxKQoJCXJldHVybiBSRVZfVFJFRV9ORVc7CglpZiAoIXQyKQoJCXJldHVybiBSRVZfVFJFRV9ESUZGRVJFTlQ7Cgl0cmVlX2RpZmZlcmVuY2UgPSBSRVZfVFJFRV9TQU1FOwoJcmV2cy0+cHJ1bmluZy5oYXNfY2hhbmdlcyA9IDA7CglpZiAoZGlmZl90cmVlX3NoYTEodDEtPm9iamVjdC5zaGExLCB0Mi0+b2JqZWN0LnNoYTEsICIiLAoJCQkgICAmcmV2cy0+cHJ1bmluZykgPCAwKQoJCXJldHVybiBSRVZfVFJFRV9ESUZGRVJFTlQ7CglyZXR1cm4gdHJlZV9kaWZmZXJlbmNlOwp9CgpzdGF0aWMgaW50IHJldl9zYW1lX3RyZWVfYXNfZW1wdHkoc3RydWN0IHJldl9pbmZvICpyZXZzLCBzdHJ1Y3QgdHJlZSAqdDEpCnsKCWludCByZXR2YWw7Cgl2b2lkICp0cmVlOwoJdW5zaWduZWQgbG9uZyBzaXplOwoJc3RydWN0IHRyZWVfZGVzYyBlbXB0eSwgcmVhbDsKCglpZiAoIXQxKQoJCXJldHVybiAwOwoKCXRyZWUgPSByZWFkX29iamVjdF93aXRoX3JlZmVyZW5jZSh0MS0+b2JqZWN0LnNoYTEsIHRyZWVfdHlwZSwgJnNpemUsIE5VTEwpOwoJaWYgKCF0cmVlKQoJCXJldHVybiAwOwoJaW5pdF90cmVlX2Rlc2MoJnJlYWwsIHRyZWUsIHNpemUpOwoJaW5pdF90cmVlX2Rlc2MoJmVtcHR5LCAiIiwgMCk7CgoJdHJlZV9kaWZmZXJlbmNlID0gUkVWX1RSRUVfU0FNRTsKCXJldnMtPnBydW5pbmcuaGFzX2NoYW5nZXMgPSAwOwoJcmV0dmFsID0gZGlmZl90cmVlKCZlbXB0eSwgJnJlYWwsICIiLCAmcmV2cy0+cHJ1bmluZyk7CglmcmVlKHRyZWUpOwoKCXJldHVybiByZXR2YWwgPj0gMCAmJiAodHJlZV9kaWZmZXJlbmNlID09IFJFVl9UUkVFX1NBTUUpOwp9CgpzdGF0aWMgdm9pZCB0cnlfdG9fc2ltcGxpZnlfY29tbWl0KHN0cnVjdCByZXZfaW5mbyAqcmV2cywgc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKipwcCwgKnBhcmVudDsKCWludCB0cmVlX2NoYW5nZWQgPSAwLCB0cmVlX3NhbWUgPSAwOwoKCWlmICghY29tbWl0LT50cmVlKQoJCXJldHVybjsKCglpZiAoIWNvbW1pdC0+cGFyZW50cykgewoJCWlmICghcmV2X3NhbWVfdHJlZV9hc19lbXB0eShyZXZzLCBjb21taXQtPnRyZWUpKQoJCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBUUkVFQ0hBTkdFOwoJCXJldHVybjsKCX0KCglwcCA9ICZjb21taXQtPnBhcmVudHM7Cgl3aGlsZSAoKHBhcmVudCA9ICpwcCkgIT0gTlVMTCkgewoJCXN0cnVjdCBjb21taXQgKnAgPSBwYXJlbnQtPml0ZW07CgoJCWlmIChwYXJzZV9jb21taXQocCkgPCAwKQoJCQlkaWUoImNhbm5vdCBzaW1wbGlmeSBjb21taXQgJXMgKGJlY2F1c2Ugb2YgJXMpIiwKCQkJICAgIHNoYTFfdG9faGV4KGNvbW1pdC0+b2JqZWN0LnNoYTEpLAoJCQkgICAgc2hhMV90b19oZXgocC0+b2JqZWN0LnNoYTEpKTsKCQlzd2l0Y2ggKHJldl9jb21wYXJlX3RyZWUocmV2cywgcC0+dHJlZSwgY29tbWl0LT50cmVlKSkgewoJCWNhc2UgUkVWX1RSRUVfU0FNRToKCQkJdHJlZV9zYW1lID0gMTsKCQkJaWYgKCFyZXZzLT5zaW1wbGlmeV9oaXN0b3J5IHx8IChwLT5vYmplY3QuZmxhZ3MgJiBVTklOVEVSRVNUSU5HKSkgewoJCQkJLyogRXZlbiBpZiBhIG1lcmdlIHdpdGggYW4gdW5pbnRlcmVzdGluZwoJCQkJICogc2lkZSBicmFuY2ggYnJvdWdodCB0aGUgZW50aXJlIGNoYW5nZQoJCQkJICogd2UgYXJlIGludGVyZXN0ZWQgaW4sIHdlIGRvIG5vdCB3YW50CgkJCQkgKiB0byBsb3NlIHRoZSBvdGhlciBicmFuY2hlcyBvZiB0aGlzCgkJCQkgKiBtZXJnZSwgc28gd2UganVzdCBrZWVwIGdvaW5nLgoJCQkJICovCgkJCQlwcCA9ICZwYXJlbnQtPm5leHQ7CgkJCQljb250aW51ZTsKCQkJfQoJCQlwYXJlbnQtPm5leHQgPSBOVUxMOwoJCQljb21taXQtPnBhcmVudHMgPSBwYXJlbnQ7CgkJCXJldHVybjsKCgkJY2FzZSBSRVZfVFJFRV9ORVc6CgkJCWlmIChyZXZzLT5yZW1vdmVfZW1wdHlfdHJlZXMgJiYKCQkJICAgIHJldl9zYW1lX3RyZWVfYXNfZW1wdHkocmV2cywgcC0+dHJlZSkpIHsKCQkJCS8qIFdlIGFyZSBhZGRpbmcgYWxsIHRoZSBzcGVjaWZpZWQKCQkJCSAqIHBhdGhzIGZyb20gdGhpcyBwYXJlbnQsIHNvIHRoZQoJCQkJICogaGlzdG9yeSBiZXlvbmQgdGhpcyBwYXJlbnQgaXMgbm90CgkJCQkgKiBpbnRlcmVzdGluZy4gIFJlbW92ZSBpdHMgcGFyZW50cwoJCQkJICogKHRoZXkgYXJlIGdyYW5kcGFyZW50cyBmb3IgdXMpLgoJCQkJICogSU9XLCB3ZSBwcmV0ZW5kIHRoaXMgcGFyZW50IGlzIGEKCQkJCSAqICJyb290IiBjb21taXQuCgkJCQkgKi8KCQkJCWlmIChwYXJzZV9jb21taXQocCkgPCAwKQoJCQkJCWRpZSgiY2Fubm90IHNpbXBsaWZ5IGNvbW1pdCAlcyAoaW52YWxpZCAlcykiLAoJCQkJCSAgICBzaGExX3RvX2hleChjb21taXQtPm9iamVjdC5zaGExKSwKCQkJCQkgICAgc2hhMV90b19oZXgocC0+b2JqZWN0LnNoYTEpKTsKCQkJCXAtPnBhcmVudHMgPSBOVUxMOwoJCQl9CgkJLyogZmFsbHRocm91Z2ggKi8KCQljYXNlIFJFVl9UUkVFX0RJRkZFUkVOVDoKCQkJdHJlZV9jaGFuZ2VkID0gMTsKCQkJcHAgPSAmcGFyZW50LT5uZXh0OwoJCQljb250aW51ZTsKCQl9CgkJZGllKCJiYWQgdHJlZSBjb21wYXJlIGZvciBjb21taXQgJXMiLCBzaGExX3RvX2hleChjb21taXQtPm9iamVjdC5zaGExKSk7Cgl9CglpZiAodHJlZV9jaGFuZ2VkICYmICF0cmVlX3NhbWUpCgkJY29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gVFJFRUNIQU5HRTsKfQoKc3RhdGljIGludCBhZGRfcGFyZW50c190b19saXN0KHN0cnVjdCByZXZfaW5mbyAqcmV2cywgc3RydWN0IGNvbW1pdCAqY29tbWl0LCBzdHJ1Y3QgY29tbWl0X2xpc3QgKipsaXN0KQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudCA9IGNvbW1pdC0+cGFyZW50czsKCXVuc2lnbmVkIGxlZnRfZmxhZzsKCWludCBhZGQsIHJlc3Q7CgoJaWYgKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgQURERUQpCgkJcmV0dXJuIDA7Cgljb21taXQtPm9iamVjdC5mbGFncyB8PSBBRERFRDsKCgkvKgoJICogSWYgdGhlIGNvbW1pdCBpcyB1bmludGVyZXN0aW5nLCBkb24ndCB0cnkgdG8KCSAqIHBydW5lIHBhcmVudHMgLSB3ZSB3YW50IHRoZSBtYXhpbWFsIHVuaW50ZXJlc3RpbmcKCSAqIHNldC4KCSAqCgkgKiBOb3JtYWxseSB3ZSBoYXZlbid0IHBhcnNlZCB0aGUgcGFyZW50CgkgKiB5ZXQsIHNvIHdlIHdvbid0IGhhdmUgYSBwYXJlbnQgb2YgYSBwYXJlbnQKCSAqIGhlcmUuIEhvd2V2ZXIsIGl0IG1heSB0dXJuIG91dCB0aGF0IHdlJ3ZlCgkgKiByZWFjaGVkIHRoaXMgY29tbWl0IHNvbWUgb3RoZXIgd2F5ICh3aGVyZSBpdAoJICogd2Fzbid0IHVuaW50ZXJlc3RpbmcpLCBpbiB3aGljaCBjYXNlIHdlIG5lZWQKCSAqIHRvIG1hcmsgaXRzIHBhcmVudHMgcmVjdXJzaXZlbHkgdG9vLi4KCSAqLwoJaWYgKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgVU5JTlRFUkVTVElORykgewoJCXdoaWxlIChwYXJlbnQpIHsKCQkJc3RydWN0IGNvbW1pdCAqcCA9IHBhcmVudC0+aXRlbTsKCQkJcGFyZW50ID0gcGFyZW50LT5uZXh0OwoJCQlpZiAocGFyc2VfY29tbWl0KHApIDwgMCkKCQkJCXJldHVybiAtMTsKCQkJcC0+b2JqZWN0LmZsYWdzIHw9IFVOSU5URVJFU1RJTkc7CgkJCWlmIChwLT5wYXJlbnRzKQoJCQkJbWFya19wYXJlbnRzX3VuaW50ZXJlc3RpbmcocCk7CgkJCWlmIChwLT5vYmplY3QuZmxhZ3MgJiBTRUVOKQoJCQkJY29udGludWU7CgkJCXAtPm9iamVjdC5mbGFncyB8PSBTRUVOOwoJCQlpbnNlcnRfYnlfZGF0ZShwLCBsaXN0KTsKCQl9CgkJcmV0dXJuIDA7Cgl9CgoJLyoKCSAqIE9rLCB0aGUgY29tbWl0IHdhc24ndCB1bmludGVyZXN0aW5nLiBUcnkgdG8KCSAqIHNpbXBsaWZ5IHRoZSBjb21taXQgaGlzdG9yeSBhbmQgZmluZCB0aGUgcGFyZW50CgkgKiB0aGF0IGhhcyBubyBkaWZmZXJlbmNlcyBpbiB0aGUgcGF0aCBzZXQgaWYgb25lIGV4aXN0cy4KCSAqLwoJaWYgKHJldnMtPnBydW5lX2ZuKQoJCXJldnMtPnBydW5lX2ZuKHJldnMsIGNvbW1pdCk7CgoJaWYgKHJldnMtPm5vX3dhbGspCgkJcmV0dXJuIDA7CgoJbGVmdF9mbGFnID0gKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgU1lNTUVUUklDX0xFRlQpOwoKCXJlc3QgPSAhcmV2cy0+Zmlyc3RfcGFyZW50X29ubHk7Cglmb3IgKHBhcmVudCA9IGNvbW1pdC0+cGFyZW50cywgYWRkID0gMTsgcGFyZW50OyBhZGQgPSByZXN0KSB7CgkJc3RydWN0IGNvbW1pdCAqcCA9IHBhcmVudC0+aXRlbTsKCgkJcGFyZW50ID0gcGFyZW50LT5uZXh0OwoJCWlmIChwYXJzZV9jb21taXQocCkgPCAwKQoJCQlyZXR1cm4gLTE7CgkJcC0+b2JqZWN0LmZsYWdzIHw9IGxlZnRfZmxhZzsKCQlpZiAocC0+b2JqZWN0LmZsYWdzICYgU0VFTikKCQkJY29udGludWU7CgkJcC0+b2JqZWN0LmZsYWdzIHw9IFNFRU47CgkJaWYgKGFkZCkKCQkJaW5zZXJ0X2J5X2RhdGUocCwgbGlzdCk7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgY2hlcnJ5X3BpY2tfbGlzdChzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QsIHN0cnVjdCByZXZfaW5mbyAqcmV2cykKewoJc3RydWN0IGNvbW1pdF9saXN0ICpwOwoJaW50IGxlZnRfY291bnQgPSAwLCByaWdodF9jb3VudCA9IDA7CglpbnQgbGVmdF9maXJzdDsKCXN0cnVjdCBwYXRjaF9pZHMgaWRzOwoKCS8qIEZpcnN0IGNvdW50IHRoZSBjb21taXRzIG9uIHRoZSBsZWZ0IGFuZCBvbiB0aGUgcmlnaHQgKi8KCWZvciAocCA9IGxpc3Q7IHA7IHAgPSBwLT5uZXh0KSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gcC0+aXRlbTsKCQl1bnNpZ25lZCBmbGFncyA9IGNvbW1pdC0+b2JqZWN0LmZsYWdzOwoJCWlmIChmbGFncyAmIEJPVU5EQVJZKQoJCQk7CgkJZWxzZSBpZiAoZmxhZ3MgJiBTWU1NRVRSSUNfTEVGVCkKCQkJbGVmdF9jb3VudCsrOwoJCWVsc2UKCQkJcmlnaHRfY291bnQrKzsKCX0KCglsZWZ0X2ZpcnN0ID0gbGVmdF9jb3VudCA8IHJpZ2h0X2NvdW50OwoJaW5pdF9wYXRjaF9pZHMoJmlkcyk7CglpZiAocmV2cy0+ZGlmZm9wdC5ucl9wYXRocykgewoJCWlkcy5kaWZmb3B0cy5ucl9wYXRocyA9IHJldnMtPmRpZmZvcHQubnJfcGF0aHM7CgkJaWRzLmRpZmZvcHRzLnBhdGhzID0gcmV2cy0+ZGlmZm9wdC5wYXRoczsKCQlpZHMuZGlmZm9wdHMucGF0aGxlbnMgPSByZXZzLT5kaWZmb3B0LnBhdGhsZW5zOwoJfQoKCS8qIENvbXB1dGUgcGF0Y2gtaWRzIGZvciBvbmUgc2lkZSAqLwoJZm9yIChwID0gbGlzdDsgcDsgcCA9IHAtPm5leHQpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBwLT5pdGVtOwoJCXVuc2lnbmVkIGZsYWdzID0gY29tbWl0LT5vYmplY3QuZmxhZ3M7CgoJCWlmIChmbGFncyAmIEJPVU5EQVJZKQoJCQljb250aW51ZTsKCQkvKgoJCSAqIElmIHdlIGhhdmUgZmV3ZXIgbGVmdCwgbGVmdF9maXJzdCBpcyBzZXQgYW5kIHdlIG9taXQKCQkgKiBjb21taXRzIG9uIHRoZSByaWdodCBicmFuY2ggaW4gdGhpcyBsb29wLiAgSWYgd2UgaGF2ZQoJCSAqIGZld2VyIHJpZ2h0LCB3ZSBza2lwIHRoZSBsZWZ0IG9uZXMuCgkJICovCgkJaWYgKGxlZnRfZmlyc3QgIT0gISEoZmxhZ3MgJiBTWU1NRVRSSUNfTEVGVCkpCgkJCWNvbnRpbnVlOwoJCWNvbW1pdC0+dXRpbCA9IGFkZF9jb21taXRfcGF0Y2hfaWQoY29tbWl0LCAmaWRzKTsKCX0KCgkvKiBDaGVjayB0aGUgb3RoZXIgc2lkZSAqLwoJZm9yIChwID0gbGlzdDsgcDsgcCA9IHAtPm5leHQpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBwLT5pdGVtOwoJCXN0cnVjdCBwYXRjaF9pZCAqaWQ7CgkJdW5zaWduZWQgZmxhZ3MgPSBjb21taXQtPm9iamVjdC5mbGFnczsKCgkJaWYgKGZsYWdzICYgQk9VTkRBUlkpCgkJCWNvbnRpbnVlOwoJCS8qCgkJICogSWYgd2UgaGF2ZSBmZXdlciBsZWZ0LCBsZWZ0X2ZpcnN0IGlzIHNldCBhbmQgd2Ugb21pdAoJCSAqIGNvbW1pdHMgb24gdGhlIGxlZnQgYnJhbmNoIGluIHRoaXMgbG9vcC4KCQkgKi8KCQlpZiAobGVmdF9maXJzdCA9PSAhIShmbGFncyAmIFNZTU1FVFJJQ19MRUZUKSkKCQkJY29udGludWU7CgoJCS8qCgkJICogSGF2ZSB3ZSBzZWVuIHRoZSBzYW1lIHBhdGNoIGlkPwoJCSAqLwoJCWlkID0gaGFzX2NvbW1pdF9wYXRjaF9pZChjb21taXQsICZpZHMpOwoJCWlmICghaWQpCgkJCWNvbnRpbnVlOwoJCWlkLT5zZWVuID0gMTsKCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBTSE9XTjsKCX0KCgkvKiBOb3cgY2hlY2sgdGhlIG9yaWdpbmFsIHNpZGUgZm9yIHNlZW4gb25lcyAqLwoJZm9yIChwID0gbGlzdDsgcDsgcCA9IHAtPm5leHQpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBwLT5pdGVtOwoJCXN0cnVjdCBwYXRjaF9pZCAqZW50OwoKCQllbnQgPSBjb21taXQtPnV0aWw7CgkJaWYgKCFlbnQpCgkJCWNvbnRpbnVlOwoJCWlmIChlbnQtPnNlZW4pCgkJCWNvbW1pdC0+b2JqZWN0LmZsYWdzIHw9IFNIT1dOOwoJCWNvbW1pdC0+dXRpbCA9IE5VTEw7Cgl9CgoJZnJlZV9wYXRjaF9pZHMoJmlkcyk7Cn0KCnN0YXRpYyBpbnQgbGltaXRfbGlzdChzdHJ1Y3QgcmV2X2luZm8gKnJldnMpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCA9IHJldnMtPmNvbW1pdHM7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKm5ld2xpc3QgPSBOVUxMOwoJc3RydWN0IGNvbW1pdF9saXN0ICoqcCA9ICZuZXdsaXN0OwoKCXdoaWxlIChsaXN0KSB7CgkJc3RydWN0IGNvbW1pdF9saXN0ICplbnRyeSA9IGxpc3Q7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gbGlzdC0+aXRlbTsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmogPSAmY29tbWl0LT5vYmplY3Q7CgoJCWxpc3QgPSBsaXN0LT5uZXh0OwoJCWZyZWUoZW50cnkpOwoKCQlpZiAocmV2cy0+bWF4X2FnZSAhPSAtMSAmJiAoY29tbWl0LT5kYXRlIDwgcmV2cy0+bWF4X2FnZSkpCgkJCW9iai0+ZmxhZ3MgfD0gVU5JTlRFUkVTVElORzsKCQlpZiAoYWRkX3BhcmVudHNfdG9fbGlzdChyZXZzLCBjb21taXQsICZsaXN0KSA8IDApCgkJCXJldHVybiAtMTsKCQlpZiAob2JqLT5mbGFncyAmIFVOSU5URVJFU1RJTkcpIHsKCQkJbWFya19wYXJlbnRzX3VuaW50ZXJlc3RpbmcoY29tbWl0KTsKCQkJaWYgKGV2ZXJ5Ym9keV91bmludGVyZXN0aW5nKGxpc3QpKQoJCQkJYnJlYWs7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAocmV2cy0+bWluX2FnZSAhPSAtMSAmJiAoY29tbWl0LT5kYXRlID4gcmV2cy0+bWluX2FnZSkpCgkJCWNvbnRpbnVlOwoJCXAgPSAmY29tbWl0X2xpc3RfaW5zZXJ0KGNvbW1pdCwgcCktPm5leHQ7Cgl9CglpZiAocmV2cy0+Y2hlcnJ5X3BpY2spCgkJY2hlcnJ5X3BpY2tfbGlzdChuZXdsaXN0LCByZXZzKTsKCglyZXZzLT5jb21taXRzID0gbmV3bGlzdDsKCXJldHVybiAwOwp9CgpzdHJ1Y3QgYWxsX3JlZnNfY2IgewoJaW50IGFsbF9mbGFnczsKCWludCB3YXJuZWRfYmFkX3JlZmxvZzsKCXN0cnVjdCByZXZfaW5mbyAqYWxsX3JldnM7Cgljb25zdCBjaGFyICpuYW1lX2Zvcl9lcnJvcm1zZzsKfTsKCnN0YXRpYyBpbnQgaGFuZGxlX29uZV9yZWYoY29uc3QgY2hhciAqcGF0aCwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgaW50IGZsYWcsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBhbGxfcmVmc19jYiAqY2IgPSBjYl9kYXRhOwoJc3RydWN0IG9iamVjdCAqb2JqZWN0ID0gZ2V0X3JlZmVyZW5jZShjYi0+YWxsX3JldnMsIHBhdGgsIHNoYTEsCgkJCQkJICAgICAgY2ItPmFsbF9mbGFncyk7CglhZGRfcGVuZGluZ19vYmplY3QoY2ItPmFsbF9yZXZzLCBvYmplY3QsIHBhdGgpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGhhbmRsZV9hbGwoc3RydWN0IHJldl9pbmZvICpyZXZzLCB1bnNpZ25lZCBmbGFncykKewoJc3RydWN0IGFsbF9yZWZzX2NiIGNiOwoJY2IuYWxsX3JldnMgPSByZXZzOwoJY2IuYWxsX2ZsYWdzID0gZmxhZ3M7Cglmb3JfZWFjaF9yZWYoaGFuZGxlX29uZV9yZWYsICZjYik7Cn0KCnN0YXRpYyB2b2lkIGhhbmRsZV9vbmVfcmVmbG9nX2NvbW1pdCh1bnNpZ25lZCBjaGFyICpzaGExLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3QgYWxsX3JlZnNfY2IgKmNiID0gY2JfZGF0YTsKCWlmICghaXNfbnVsbF9zaGExKHNoYTEpKSB7CgkJc3RydWN0IG9iamVjdCAqbyA9IHBhcnNlX29iamVjdChzaGExKTsKCQlpZiAobykgewoJCQlvLT5mbGFncyB8PSBjYi0+YWxsX2ZsYWdzOwoJCQlhZGRfcGVuZGluZ19vYmplY3QoY2ItPmFsbF9yZXZzLCBvLCAiIik7CgkJfQoJCWVsc2UgaWYgKCFjYi0+d2FybmVkX2JhZF9yZWZsb2cpIHsKCQkJd2FybmluZygicmVmbG9nIG9mICclcycgcmVmZXJlbmNlcyBwcnVuZWQgY29tbWl0cyIsCgkJCQljYi0+bmFtZV9mb3JfZXJyb3Jtc2cpOwoJCQljYi0+d2FybmVkX2JhZF9yZWZsb2cgPSAxOwoJCX0KCX0KfQoKc3RhdGljIGludCBoYW5kbGVfb25lX3JlZmxvZ19lbnQodW5zaWduZWQgY2hhciAqb3NoYTEsIHVuc2lnbmVkIGNoYXIgKm5zaGExLAoJCWNvbnN0IGNoYXIgKmVtYWlsLCB1bnNpZ25lZCBsb25nIHRpbWVzdGFtcCwgaW50IHR6LAoJCWNvbnN0IGNoYXIgKm1lc3NhZ2UsIHZvaWQgKmNiX2RhdGEpCnsKCWhhbmRsZV9vbmVfcmVmbG9nX2NvbW1pdChvc2hhMSwgY2JfZGF0YSk7CgloYW5kbGVfb25lX3JlZmxvZ19jb21taXQobnNoYTEsIGNiX2RhdGEpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgaGFuZGxlX29uZV9yZWZsb2coY29uc3QgY2hhciAqcGF0aCwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgaW50IGZsYWcsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBhbGxfcmVmc19jYiAqY2IgPSBjYl9kYXRhOwoJY2ItPndhcm5lZF9iYWRfcmVmbG9nID0gMDsKCWNiLT5uYW1lX2Zvcl9lcnJvcm1zZyA9IHBhdGg7Cglmb3JfZWFjaF9yZWZsb2dfZW50KHBhdGgsIGhhbmRsZV9vbmVfcmVmbG9nX2VudCwgY2JfZGF0YSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgaGFuZGxlX3JlZmxvZyhzdHJ1Y3QgcmV2X2luZm8gKnJldnMsIHVuc2lnbmVkIGZsYWdzKQp7CglzdHJ1Y3QgYWxsX3JlZnNfY2IgY2I7CgljYi5hbGxfcmV2cyA9IHJldnM7CgljYi5hbGxfZmxhZ3MgPSBmbGFnczsKCWZvcl9lYWNoX3JlZmxvZyhoYW5kbGVfb25lX3JlZmxvZywgJmNiKTsKfQoKc3RhdGljIGludCBhZGRfcGFyZW50c19vbmx5KHN0cnVjdCByZXZfaW5mbyAqcmV2cywgY29uc3QgY2hhciAqYXJnLCBpbnQgZmxhZ3MpCnsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CglzdHJ1Y3Qgb2JqZWN0ICppdDsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50czsKCglpZiAoKmFyZyA9PSAnXicpIHsKCQlmbGFncyBePSBVTklOVEVSRVNUSU5HOwoJCWFyZysrOwoJfQoJaWYgKGdldF9zaGExKGFyZywgc2hhMSkpCgkJcmV0dXJuIDA7Cgl3aGlsZSAoMSkgewoJCWl0ID0gZ2V0X3JlZmVyZW5jZShyZXZzLCBhcmcsIHNoYTEsIDApOwoJCWlmIChpdC0+dHlwZSAhPSBPQkpfVEFHKQoJCQlicmVhazsKCQloYXNoY3B5KHNoYTEsICgoc3RydWN0IHRhZyopaXQpLT50YWdnZWQtPnNoYTEpOwoJfQoJaWYgKGl0LT50eXBlICE9IE9CSl9DT01NSVQpCgkJcmV0dXJuIDA7Cgljb21taXQgPSAoc3RydWN0IGNvbW1pdCAqKWl0OwoJZm9yIChwYXJlbnRzID0gY29tbWl0LT5wYXJlbnRzOyBwYXJlbnRzOyBwYXJlbnRzID0gcGFyZW50cy0+bmV4dCkgewoJCWl0ID0gJnBhcmVudHMtPml0ZW0tPm9iamVjdDsKCQlpdC0+ZmxhZ3MgfD0gZmxhZ3M7CgkJYWRkX3BlbmRpbmdfb2JqZWN0KHJldnMsIGl0LCBhcmcpOwoJfQoJcmV0dXJuIDE7Cn0KCnZvaWQgaW5pdF9yZXZpc2lvbnMoc3RydWN0IHJldl9pbmZvICpyZXZzLCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCW1lbXNldChyZXZzLCAwLCBzaXplb2YoKnJldnMpKTsKCglyZXZzLT5hYmJyZXYgPSBERUZBVUxUX0FCQlJFVjsKCXJldnMtPmlnbm9yZV9tZXJnZXMgPSAxOwoJcmV2cy0+c2ltcGxpZnlfaGlzdG9yeSA9IDE7CglyZXZzLT5wcnVuaW5nLnJlY3Vyc2l2ZSA9IDE7CglyZXZzLT5wcnVuaW5nLnF1aWV0ID0gMTsKCXJldnMtPnBydW5pbmcuYWRkX3JlbW92ZSA9IGZpbGVfYWRkX3JlbW92ZTsKCXJldnMtPnBydW5pbmcuY2hhbmdlID0gZmlsZV9jaGFuZ2U7CglyZXZzLT5saWZvID0gMTsKCXJldnMtPmRlbnNlID0gMTsKCXJldnMtPnByZWZpeCA9IHByZWZpeDsKCXJldnMtPm1heF9hZ2UgPSAtMTsKCXJldnMtPm1pbl9hZ2UgPSAtMTsKCXJldnMtPnNraXBfY291bnQgPSAtMTsKCXJldnMtPm1heF9jb3VudCA9IC0xOwoKCXJldnMtPnBydW5lX2ZuID0gTlVMTDsKCXJldnMtPnBydW5lX2RhdGEgPSBOVUxMOwoKCXJldnMtPnRvcG9fc2V0dGVyID0gdG9wb19zb3J0X2RlZmF1bHRfc2V0dGVyOwoJcmV2cy0+dG9wb19nZXR0ZXIgPSB0b3BvX3NvcnRfZGVmYXVsdF9nZXR0ZXI7CgoJcmV2cy0+Y29tbWl0X2Zvcm1hdCA9IENNSVRfRk1UX0RFRkFVTFQ7CgoJZGlmZl9zZXR1cCgmcmV2cy0+ZGlmZm9wdCk7Cn0KCnN0YXRpYyB2b2lkIGFkZF9wZW5kaW5nX2NvbW1pdF9saXN0KHN0cnVjdCByZXZfaW5mbyAqcmV2cywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0IGNvbW1pdF9saXN0ICpjb21taXRfbGlzdCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5zaWduZWQgaW50IGZsYWdzKQp7Cgl3aGlsZSAoY29tbWl0X2xpc3QpIHsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmplY3QgPSAmY29tbWl0X2xpc3QtPml0ZW0tPm9iamVjdDsKCQlvYmplY3QtPmZsYWdzIHw9IGZsYWdzOwoJCWFkZF9wZW5kaW5nX29iamVjdChyZXZzLCBvYmplY3QsIHNoYTFfdG9faGV4KG9iamVjdC0+c2hhMSkpOwoJCWNvbW1pdF9saXN0ID0gY29tbWl0X2xpc3QtPm5leHQ7Cgl9Cn0KCnN0YXRpYyB2b2lkIHByZXBhcmVfc2hvd19tZXJnZShzdHJ1Y3QgcmV2X2luZm8gKnJldnMpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqYmFzZXM7CglzdHJ1Y3QgY29tbWl0ICpoZWFkLCAqb3RoZXI7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJY29uc3QgY2hhciAqKnBydW5lID0gTlVMTDsKCWludCBpLCBwcnVuZV9udW0gPSAxOyAvKiBjb3VudGluZyB0ZXJtaW5hdGluZyBOVUxMICovCgoJaWYgKGdldF9zaGExKCJIRUFEIiwgc2hhMSkgfHwgIShoZWFkID0gbG9va3VwX2NvbW1pdChzaGExKSkpCgkJZGllKCItLW1lcmdlIHdpdGhvdXQgSEVBRD8iKTsKCWlmIChnZXRfc2hhMSgiTUVSR0VfSEVBRCIsIHNoYTEpIHx8ICEob3RoZXIgPSBsb29rdXBfY29tbWl0KHNoYTEpKSkKCQlkaWUoIi0tbWVyZ2Ugd2l0aG91dCBNRVJHRV9IRUFEPyIpOwoJYWRkX3BlbmRpbmdfb2JqZWN0KHJldnMsICZoZWFkLT5vYmplY3QsICJIRUFEIik7CglhZGRfcGVuZGluZ19vYmplY3QocmV2cywgJm90aGVyLT5vYmplY3QsICJNRVJHRV9IRUFEIik7CgliYXNlcyA9IGdldF9tZXJnZV9iYXNlcyhoZWFkLCBvdGhlciwgMSk7Cgl3aGlsZSAoYmFzZXMpIHsKCQlzdHJ1Y3QgY29tbWl0ICppdCA9IGJhc2VzLT5pdGVtOwoJCXN0cnVjdCBjb21taXRfbGlzdCAqbiA9IGJhc2VzLT5uZXh0OwoJCWZyZWUoYmFzZXMpOwoJCWJhc2VzID0gbjsKCQlpdC0+b2JqZWN0LmZsYWdzIHw9IFVOSU5URVJFU1RJTkc7CgkJYWRkX3BlbmRpbmdfb2JqZWN0KHJldnMsICZpdC0+b2JqZWN0LCAiKG1lcmdlLWJhc2UpIik7Cgl9CgoJaWYgKCFhY3RpdmVfbnIpCgkJcmVhZF9jYWNoZSgpOwoJZm9yIChpID0gMDsgaSA8IGFjdGl2ZV9ucjsgaSsrKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGFjdGl2ZV9jYWNoZVtpXTsKCQlpZiAoIWNlX3N0YWdlKGNlKSkKCQkJY29udGludWU7CgkJaWYgKGNlX3BhdGhfbWF0Y2goY2UsIHJldnMtPnBydW5lX2RhdGEpKSB7CgkJCXBydW5lX251bSsrOwoJCQlwcnVuZSA9IHhyZWFsbG9jKHBydW5lLCBzaXplb2YoKnBydW5lKSAqIHBydW5lX251bSk7CgkJCXBydW5lW3BydW5lX251bS0yXSA9IGNlLT5uYW1lOwoJCQlwcnVuZVtwcnVuZV9udW0tMV0gPSBOVUxMOwoJCX0KCQl3aGlsZSAoKGkrMSA8IGFjdGl2ZV9ucikgJiYKCQkgICAgICAgY2Vfc2FtZV9uYW1lKGNlLCBhY3RpdmVfY2FjaGVbaSsxXSkpCgkJCWkrKzsKCX0KCXJldnMtPnBydW5lX2RhdGEgPSBwcnVuZTsKfQoKaW50IGhhbmRsZV9yZXZpc2lvbl9hcmcoY29uc3QgY2hhciAqYXJnLCBzdHJ1Y3QgcmV2X2luZm8gKnJldnMsCgkJCWludCBmbGFncywKCQkJaW50IGNhbnRfYmVfZmlsZW5hbWUpCnsKCXVuc2lnbmVkIG1vZGU7CgljaGFyICpkb3Rkb3Q7CglzdHJ1Y3Qgb2JqZWN0ICpvYmplY3Q7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJaW50IGxvY2FsX2ZsYWdzOwoKCWRvdGRvdCA9IHN0cnN0cihhcmcsICIuLiIpOwoJaWYgKGRvdGRvdCkgewoJCXVuc2lnbmVkIGNoYXIgZnJvbV9zaGExWzIwXTsKCQljb25zdCBjaGFyICpuZXh0ID0gZG90ZG90ICsgMjsKCQljb25zdCBjaGFyICp0aGlzID0gYXJnOwoJCWludCBzeW1tZXRyaWMgPSAqbmV4dCA9PSAnLic7CgkJdW5zaWduZWQgaW50IGZsYWdzX2V4Y2x1ZGUgPSBmbGFncyBeIFVOSU5URVJFU1RJTkc7CgoJCSpkb3Rkb3QgPSAwOwoJCW5leHQgKz0gc3ltbWV0cmljOwoKCQlpZiAoISpuZXh0KQoJCQluZXh0ID0gIkhFQUQiOwoJCWlmIChkb3Rkb3QgPT0gYXJnKQoJCQl0aGlzID0gIkhFQUQiOwoJCWlmICghZ2V0X3NoYTEodGhpcywgZnJvbV9zaGExKSAmJgoJCSAgICAhZ2V0X3NoYTEobmV4dCwgc2hhMSkpIHsKCQkJc3RydWN0IGNvbW1pdCAqYSwgKmI7CgkJCXN0cnVjdCBjb21taXRfbGlzdCAqZXhjbHVkZTsKCgkJCWEgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZShmcm9tX3NoYTEpOwoJCQliID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2Uoc2hhMSk7CgkJCWlmICghYSB8fCAhYikgewoJCQkJZGllKHN5bW1ldHJpYyA/CgkJCQkgICAgIkludmFsaWQgc3ltbWV0cmljIGRpZmZlcmVuY2UgZXhwcmVzc2lvbiAlcy4uLiVzIiA6CgkJCQkgICAgIkludmFsaWQgcmV2aXNpb24gcmFuZ2UgJXMuLiVzIiwKCQkJCSAgICBhcmcsIG5leHQpOwoJCQl9CgoJCQlpZiAoIWNhbnRfYmVfZmlsZW5hbWUpIHsKCQkJCSpkb3Rkb3QgPSAnLic7CgkJCQl2ZXJpZnlfbm9uX2ZpbGVuYW1lKHJldnMtPnByZWZpeCwgYXJnKTsKCQkJfQoKCQkJaWYgKHN5bW1ldHJpYykgewoJCQkJZXhjbHVkZSA9IGdldF9tZXJnZV9iYXNlcyhhLCBiLCAxKTsKCQkJCWFkZF9wZW5kaW5nX2NvbW1pdF9saXN0KHJldnMsIGV4Y2x1ZGUsCgkJCQkJCQlmbGFnc19leGNsdWRlKTsKCQkJCWZyZWVfY29tbWl0X2xpc3QoZXhjbHVkZSk7CgkJCQlhLT5vYmplY3QuZmxhZ3MgfD0gZmxhZ3MgfCBTWU1NRVRSSUNfTEVGVDsKCQkJfSBlbHNlCgkJCQlhLT5vYmplY3QuZmxhZ3MgfD0gZmxhZ3NfZXhjbHVkZTsKCQkJYi0+b2JqZWN0LmZsYWdzIHw9IGZsYWdzOwoJCQlhZGRfcGVuZGluZ19vYmplY3QocmV2cywgJmEtPm9iamVjdCwgdGhpcyk7CgkJCWFkZF9wZW5kaW5nX29iamVjdChyZXZzLCAmYi0+b2JqZWN0LCBuZXh0KTsKCQkJcmV0dXJuIDA7CgkJfQoJCSpkb3Rkb3QgPSAnLic7Cgl9Cglkb3Rkb3QgPSBzdHJzdHIoYXJnLCAiXkAiKTsKCWlmIChkb3Rkb3QgJiYgIWRvdGRvdFsyXSkgewoJCSpkb3Rkb3QgPSAwOwoJCWlmIChhZGRfcGFyZW50c19vbmx5KHJldnMsIGFyZywgZmxhZ3MpKQoJCQlyZXR1cm4gMDsKCQkqZG90ZG90ID0gJ14nOwoJfQoJZG90ZG90ID0gc3Ryc3RyKGFyZywgIl4hIik7CglpZiAoZG90ZG90ICYmICFkb3Rkb3RbMl0pIHsKCQkqZG90ZG90ID0gMDsKCQlpZiAoIWFkZF9wYXJlbnRzX29ubHkocmV2cywgYXJnLCBmbGFncyBeIFVOSU5URVJFU1RJTkcpKQoJCQkqZG90ZG90ID0gJ14nOwoJfQoKCWxvY2FsX2ZsYWdzID0gMDsKCWlmICgqYXJnID09ICdeJykgewoJCWxvY2FsX2ZsYWdzID0gVU5JTlRFUkVTVElORzsKCQlhcmcrKzsKCX0KCWlmIChnZXRfc2hhMV93aXRoX21vZGUoYXJnLCBzaGExLCAmbW9kZSkpCgkJcmV0dXJuIC0xOwoJaWYgKCFjYW50X2JlX2ZpbGVuYW1lKQoJCXZlcmlmeV9ub25fZmlsZW5hbWUocmV2cy0+cHJlZml4LCBhcmcpOwoJb2JqZWN0ID0gZ2V0X3JlZmVyZW5jZShyZXZzLCBhcmcsIHNoYTEsIGZsYWdzIF4gbG9jYWxfZmxhZ3MpOwoJYWRkX3BlbmRpbmdfb2JqZWN0X3dpdGhfbW9kZShyZXZzLCBvYmplY3QsIGFyZywgbW9kZSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgYWRkX2dyZXAoc3RydWN0IHJldl9pbmZvICpyZXZzLCBjb25zdCBjaGFyICpwdG4sIGVudW0gZ3JlcF9wYXRfdG9rZW4gd2hhdCkKewoJaWYgKCFyZXZzLT5ncmVwX2ZpbHRlcikgewoJCXN0cnVjdCBncmVwX29wdCAqb3B0ID0geGNhbGxvYygxLCBzaXplb2YoKm9wdCkpOwoJCW9wdC0+c3RhdHVzX29ubHkgPSAxOwoJCW9wdC0+cGF0dGVybl90YWlsID0gJihvcHQtPnBhdHRlcm5fbGlzdCk7CgkJb3B0LT5yZWdmbGFncyA9IFJFR19ORVdMSU5FOwoJCXJldnMtPmdyZXBfZmlsdGVyID0gb3B0OwoJfQoJYXBwZW5kX2dyZXBfcGF0dGVybihyZXZzLT5ncmVwX2ZpbHRlciwgcHRuLAoJCQkgICAgImNvbW1hbmQgbGluZSIsIDAsIHdoYXQpOwp9CgpzdGF0aWMgdm9pZCBhZGRfaGVhZGVyX2dyZXAoc3RydWN0IHJldl9pbmZvICpyZXZzLCBjb25zdCBjaGFyICpmaWVsZCwgY29uc3QgY2hhciAqcGF0dGVybikKewoJY2hhciAqcGF0OwoJY29uc3QgY2hhciAqcHJlZml4OwoJaW50IHBhdGxlbiwgZmxkbGVuOwoKCWZsZGxlbiA9IHN0cmxlbihmaWVsZCk7CglwYXRsZW4gPSBzdHJsZW4ocGF0dGVybik7CglwYXQgPSB4bWFsbG9jKHBhdGxlbiArIGZsZGxlbiArIDEwKTsKCXByZWZpeCA9ICIuKiI7CglpZiAoKnBhdHRlcm4gPT0gJ14nKSB7CgkJcHJlZml4ID0gIiI7CgkJcGF0dGVybisrOwoJfQoJc3ByaW50ZihwYXQsICJeJXMgJXMlcyIsIGZpZWxkLCBwcmVmaXgsIHBhdHRlcm4pOwoJYWRkX2dyZXAocmV2cywgcGF0LCBHUkVQX1BBVFRFUk5fSEVBRCk7Cn0KCnN0YXRpYyB2b2lkIGFkZF9tZXNzYWdlX2dyZXAoc3RydWN0IHJldl9pbmZvICpyZXZzLCBjb25zdCBjaGFyICpwYXR0ZXJuKQp7CglhZGRfZ3JlcChyZXZzLCBwYXR0ZXJuLCBHUkVQX1BBVFRFUk5fQk9EWSk7Cn0KCnN0YXRpYyB2b2lkIGFkZF9pZ25vcmVfcGFja2VkKHN0cnVjdCByZXZfaW5mbyAqcmV2cywgY29uc3QgY2hhciAqbmFtZSkKewoJaW50IG51bSA9ICsrcmV2cy0+bnVtX2lnbm9yZV9wYWNrZWQ7CgoJcmV2cy0+aWdub3JlX3BhY2tlZCA9IHhyZWFsbG9jKHJldnMtPmlnbm9yZV9wYWNrZWQsCgkJCQkgICAgICAgc2l6ZW9mKGNvbnN0IGNoYXIgKiopICogKG51bSArIDEpKTsKCXJldnMtPmlnbm9yZV9wYWNrZWRbbnVtLTFdID0gbmFtZTsKCXJldnMtPmlnbm9yZV9wYWNrZWRbbnVtXSA9IE5VTEw7Cn0KCi8qCiAqIFBhcnNlIHJldmlzaW9uIGluZm9ybWF0aW9uLCBmaWxsaW5nIGluIHRoZSAicmV2X2luZm8iIHN0cnVjdHVyZSwKICogYW5kIHJlbW92aW5nIHRoZSB1c2VkIGFyZ3VtZW50cyBmcm9tIHRoZSBhcmd1bWVudCBsaXN0LgogKgogKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGxlZnQgdGhhdCB3ZXJlbid0IHJlY29nbml6ZWQKICogKHdoaWNoIGFyZSBhbHNvIG1vdmVkIHRvIHRoZSBoZWFkIG9mIHRoZSBhcmd1bWVudCBsaXN0KQogKi8KaW50IHNldHVwX3JldmlzaW9ucyhpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIHN0cnVjdCByZXZfaW5mbyAqcmV2cywgY29uc3QgY2hhciAqZGVmKQp7CglpbnQgaSwgZmxhZ3MsIHNlZW5fZGFzaGRhc2gsIHNob3dfbWVyZ2U7Cgljb25zdCBjaGFyICoqdW5yZWNvZ25pemVkID0gYXJndiArIDE7CglpbnQgbGVmdCA9IDE7CglpbnQgYWxsX21hdGNoID0gMDsKCWludCByZWdmbGFncyA9IDA7CgoJLyogRmlyc3QsIHNlYXJjaCBmb3IgIi0tIiAqLwoJc2Vlbl9kYXNoZGFzaCA9IDA7Cglmb3IgKGkgPSAxOyBpIDwgYXJnYzsgaSsrKSB7CgkJY29uc3QgY2hhciAqYXJnID0gYXJndltpXTsKCQlpZiAoc3RyY21wKGFyZywgIi0tIikpCgkJCWNvbnRpbnVlOwoJCWFyZ3ZbaV0gPSBOVUxMOwoJCWFyZ2MgPSBpOwoJCXJldnMtPnBydW5lX2RhdGEgPSBnZXRfcGF0aHNwZWMocmV2cy0+cHJlZml4LCBhcmd2ICsgaSArIDEpOwoJCXNlZW5fZGFzaGRhc2ggPSAxOwoJCWJyZWFrOwoJfQoKCWZsYWdzID0gc2hvd19tZXJnZSA9IDA7Cglmb3IgKGkgPSAxOyBpIDwgYXJnYzsgaSsrKSB7CgkJY29uc3QgY2hhciAqYXJnID0gYXJndltpXTsKCQlpZiAoKmFyZyA9PSAnLScpIHsKCQkJaW50IG9wdHM7CgkJCWlmICghcHJlZml4Y21wKGFyZywgIi0tbWF4LWNvdW50PSIpKSB7CgkJCQlyZXZzLT5tYXhfY291bnQgPSBhdG9pKGFyZyArIDEyKTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghcHJlZml4Y21wKGFyZywgIi0tc2tpcD0iKSkgewoJCQkJcmV2cy0+c2tpcF9jb3VudCA9IGF0b2koYXJnICsgNyk7CgkJCQljb250aW51ZTsKCQkJfQoJCQkvKiBhY2NlcHQgLTxkaWdpdD4sIGxpa2UgdHJhZGl0aW9uYWwgImhlYWQiICovCgkJCWlmICgoKmFyZyA9PSAnLScpICYmIGlzZGlnaXQoYXJnWzFdKSkgewoJCQkJcmV2cy0+bWF4X2NvdW50ID0gYXRvaShhcmcgKyAxKTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi1uIikpIHsKCQkJCWlmIChhcmdjIDw9IGkgKyAxKQoJCQkJCWRpZSgiLW4gcmVxdWlyZXMgYW4gYXJndW1lbnQiKTsKCQkJCXJldnMtPm1heF9jb3VudCA9IGF0b2koYXJndlsrK2ldKTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghcHJlZml4Y21wKGFyZywgIi1uIikpIHsKCQkJCXJldnMtPm1heF9jb3VudCA9IGF0b2koYXJnICsgMik7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXByZWZpeGNtcChhcmcsICItLW1heC1hZ2U9IikpIHsKCQkJCXJldnMtPm1heF9hZ2UgPSBhdG9pKGFyZyArIDEwKTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghcHJlZml4Y21wKGFyZywgIi0tc2luY2U9IikpIHsKCQkJCXJldnMtPm1heF9hZ2UgPSBhcHByb3hpZGF0ZShhcmcgKyA4KTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghcHJlZml4Y21wKGFyZywgIi0tYWZ0ZXI9IikpIHsKCQkJCXJldnMtPm1heF9hZ2UgPSBhcHByb3hpZGF0ZShhcmcgKyA4KTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghcHJlZml4Y21wKGFyZywgIi0tbWluLWFnZT0iKSkgewoJCQkJcmV2cy0+bWluX2FnZSA9IGF0b2koYXJnICsgMTApOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFwcmVmaXhjbXAoYXJnLCAiLS1iZWZvcmU9IikpIHsKCQkJCXJldnMtPm1pbl9hZ2UgPSBhcHByb3hpZGF0ZShhcmcgKyA5KTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghcHJlZml4Y21wKGFyZywgIi0tdW50aWw9IikpIHsKCQkJCXJldnMtPm1pbl9hZ2UgPSBhcHByb3hpZGF0ZShhcmcgKyA4KTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi0tYWxsIikpIHsKCQkJCWhhbmRsZV9hbGwocmV2cywgZmxhZ3MpOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1maXJzdC1wYXJlbnQiKSkgewoJCQkJcmV2cy0+Zmlyc3RfcGFyZW50X29ubHkgPSAxOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1yZWZsb2ciKSkgewoJCQkJaGFuZGxlX3JlZmxvZyhyZXZzLCBmbGFncyk7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItZyIpIHx8CgkJCQkJIXN0cmNtcChhcmcsICItLXdhbGstcmVmbG9ncyIpKSB7CgkJCQlpbml0X3JlZmxvZ193YWxrKCZyZXZzLT5yZWZsb2dfaW5mbyk7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLW5vdCIpKSB7CgkJCQlmbGFncyBePSBVTklOVEVSRVNUSU5HOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1kZWZhdWx0IikpIHsKCQkJCWlmICgrK2kgPj0gYXJnYykKCQkJCQlkaWUoImJhZCAtLWRlZmF1bHQgYXJndW1lbnQiKTsKCQkJCWRlZiA9IGFyZ3ZbaV07CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLW1lcmdlIikpIHsKCQkJCXNob3dfbWVyZ2UgPSAxOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS10b3BvLW9yZGVyIikpIHsKCQkJCXJldnMtPnRvcG9fb3JkZXIgPSAxOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1kYXRlLW9yZGVyIikpIHsKCQkJCXJldnMtPmxpZm8gPSAwOwoJCQkJcmV2cy0+dG9wb19vcmRlciA9IDE7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLXBhcmVudHMiKSkgewoJCQkJcmV2cy0+cGFyZW50cyA9IDE7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLWRlbnNlIikpIHsKCQkJCXJldnMtPmRlbnNlID0gMTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi0tc3BhcnNlIikpIHsKCQkJCXJldnMtPmRlbnNlID0gMDsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi0tcmVtb3ZlLWVtcHR5IikpIHsKCQkJCXJldnMtPnJlbW92ZV9lbXB0eV90cmVlcyA9IDE7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLW5vLW1lcmdlcyIpKSB7CgkJCQlyZXZzLT5ub19tZXJnZXMgPSAxOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1ib3VuZGFyeSIpKSB7CgkJCQlyZXZzLT5ib3VuZGFyeSA9IDE7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLWxlZnQtcmlnaHQiKSkgewoJCQkJcmV2cy0+bGVmdF9yaWdodCA9IDE7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLWNoZXJyeS1waWNrIikpIHsKCQkJCXJldnMtPmNoZXJyeV9waWNrID0gMTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi0tb2JqZWN0cyIpKSB7CgkJCQlyZXZzLT50YWdfb2JqZWN0cyA9IDE7CgkJCQlyZXZzLT50cmVlX29iamVjdHMgPSAxOwoJCQkJcmV2cy0+YmxvYl9vYmplY3RzID0gMTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi0tb2JqZWN0cy1lZGdlIikpIHsKCQkJCXJldnMtPnRhZ19vYmplY3RzID0gMTsKCQkJCXJldnMtPnRyZWVfb2JqZWN0cyA9IDE7CgkJCQlyZXZzLT5ibG9iX29iamVjdHMgPSAxOwoJCQkJcmV2cy0+ZWRnZV9oaW50ID0gMTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi0tdW5wYWNrZWQiKSkgewoJCQkJcmV2cy0+dW5wYWNrZWQgPSAxOwoJCQkJZnJlZShyZXZzLT5pZ25vcmVfcGFja2VkKTsKCQkJCXJldnMtPmlnbm9yZV9wYWNrZWQgPSBOVUxMOwoJCQkJcmV2cy0+bnVtX2lnbm9yZV9wYWNrZWQgPSAwOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFwcmVmaXhjbXAoYXJnLCAiLS11bnBhY2tlZD0iKSkgewoJCQkJcmV2cy0+dW5wYWNrZWQgPSAxOwoJCQkJYWRkX2lnbm9yZV9wYWNrZWQocmV2cywgYXJnKzExKTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi1yIikpIHsKCQkJCXJldnMtPmRpZmYgPSAxOwoJCQkJcmV2cy0+ZGlmZm9wdC5yZWN1cnNpdmUgPSAxOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLXQiKSkgewoJCQkJcmV2cy0+ZGlmZiA9IDE7CgkJCQlyZXZzLT5kaWZmb3B0LnJlY3Vyc2l2ZSA9IDE7CgkJCQlyZXZzLT5kaWZmb3B0LnRyZWVfaW5fcmVjdXJzaXZlID0gMTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi1tIikpIHsKCQkJCXJldnMtPmlnbm9yZV9tZXJnZXMgPSAwOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLWMiKSkgewoJCQkJcmV2cy0+ZGlmZiA9IDE7CgkJCQlyZXZzLT5kZW5zZV9jb21iaW5lZF9tZXJnZXMgPSAwOwoJCQkJcmV2cy0+Y29tYmluZV9tZXJnZXMgPSAxOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1jYyIpKSB7CgkJCQlyZXZzLT5kaWZmID0gMTsKCQkJCXJldnMtPmRlbnNlX2NvbWJpbmVkX21lcmdlcyA9IDE7CgkJCQlyZXZzLT5jb21iaW5lX21lcmdlcyA9IDE7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItdiIpKSB7CgkJCQlyZXZzLT52ZXJib3NlX2hlYWRlciA9IDE7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXByZWZpeGNtcChhcmcsICItLXByZXR0eSIpKSB7CgkJCQlyZXZzLT52ZXJib3NlX2hlYWRlciA9IDE7CgkJCQlyZXZzLT5jb21taXRfZm9ybWF0ID0gZ2V0X2NvbW1pdF9mb3JtYXQoYXJnKzgpOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1yb290IikpIHsKCQkJCXJldnMtPnNob3dfcm9vdF9kaWZmID0gMTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi0tbm8tY29tbWl0LWlkIikpIHsKCQkJCXJldnMtPm5vX2NvbW1pdF9pZCA9IDE7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLWFsd2F5cyIpKSB7CgkJCQlyZXZzLT5hbHdheXNfc2hvd19oZWFkZXIgPSAxOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1uby1hYmJyZXYiKSkgewoJCQkJcmV2cy0+YWJicmV2ID0gMDsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi0tYWJicmV2IikpIHsKCQkJCXJldnMtPmFiYnJldiA9IERFRkFVTFRfQUJCUkVWOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFwcmVmaXhjbXAoYXJnLCAiLS1hYmJyZXY9IikpIHsKCQkJCXJldnMtPmFiYnJldiA9IHN0cnRvdWwoYXJnICsgOSwgTlVMTCwgMTApOwoJCQkJaWYgKHJldnMtPmFiYnJldiA8IE1JTklNVU1fQUJCUkVWKQoJCQkJCXJldnMtPmFiYnJldiA9IE1JTklNVU1fQUJCUkVWOwoJCQkJZWxzZSBpZiAocmV2cy0+YWJicmV2ID4gNDApCgkJCQkJcmV2cy0+YWJicmV2ID0gNDA7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLWFiYnJldi1jb21taXQiKSkgewoJCQkJcmV2cy0+YWJicmV2X2NvbW1pdCA9IDE7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLWZ1bGwtZGlmZiIpKSB7CgkJCQlyZXZzLT5kaWZmID0gMTsKCQkJCXJldnMtPmZ1bGxfZGlmZiA9IDE7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLWZ1bGwtaGlzdG9yeSIpKSB7CgkJCQlyZXZzLT5zaW1wbGlmeV9oaXN0b3J5ID0gMDsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi0tcmVsYXRpdmUtZGF0ZSIpKSB7CgkJCQlyZXZzLT5kYXRlX21vZGUgPSBEQVRFX1JFTEFUSVZFOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJuY21wKGFyZywgIi0tZGF0ZT0iLCA3KSkgewoJCQkJaWYgKCFzdHJjbXAoYXJnICsgNywgInJlbGF0aXZlIikpCgkJCQkJcmV2cy0+ZGF0ZV9tb2RlID0gREFURV9SRUxBVElWRTsKCQkJCWVsc2UgaWYgKCFzdHJjbXAoYXJnICsgNywgImlzbzg2MDEiKSB8fAoJCQkJCSAhc3RyY21wKGFyZyArIDcsICJpc28iKSkKCQkJCQlyZXZzLT5kYXRlX21vZGUgPSBEQVRFX0lTTzg2MDE7CgkJCQllbHNlIGlmICghc3RyY21wKGFyZyArIDcsICJyZmMyODIyIikgfHwKCQkJCQkgIXN0cmNtcChhcmcgKyA3LCAicmZjIikpCgkJCQkJcmV2cy0+ZGF0ZV9tb2RlID0gREFURV9SRkMyODIyOwoJCQkJZWxzZSBpZiAoIXN0cmNtcChhcmcgKyA3LCAic2hvcnQiKSkKCQkJCQlyZXZzLT5kYXRlX21vZGUgPSBEQVRFX1NIT1JUOwoJCQkJZWxzZSBpZiAoIXN0cmNtcChhcmcgKyA3LCAibG9jYWwiKSkKCQkJCQlyZXZzLT5kYXRlX21vZGUgPSBEQVRFX0xPQ0FMOwoJCQkJZWxzZSBpZiAoIXN0cmNtcChhcmcgKyA3LCAiZGVmYXVsdCIpKQoJCQkJCXJldnMtPmRhdGVfbW9kZSA9IERBVEVfTk9STUFMOwoJCQkJZWxzZQoJCQkJCWRpZSgidW5rbm93biBkYXRlIGZvcm1hdCAlcyIsIGFyZyk7CgkJCQljb250aW51ZTsKCQkJfQoKCQkJLyoKCQkJICogR3JlcHBpbmcgdGhlIGNvbW1pdCBsb2cKCQkJICovCgkJCWlmICghcHJlZml4Y21wKGFyZywgIi0tYXV0aG9yPSIpKSB7CgkJCQlhZGRfaGVhZGVyX2dyZXAocmV2cywgImF1dGhvciIsIGFyZys5KTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghcHJlZml4Y21wKGFyZywgIi0tY29tbWl0dGVyPSIpKSB7CgkJCQlhZGRfaGVhZGVyX2dyZXAocmV2cywgImNvbW1pdHRlciIsIGFyZysxMik7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXByZWZpeGNtcChhcmcsICItLWdyZXA9IikpIHsKCQkJCWFkZF9tZXNzYWdlX2dyZXAocmV2cywgYXJnKzcpOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1leHRlbmRlZC1yZWdleHAiKSB8fAoJCQkgICAgIXN0cmNtcChhcmcsICItRSIpKSB7CgkJCQlyZWdmbGFncyB8PSBSRUdfRVhURU5ERUQ7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLXJlZ2V4cC1pZ25vcmUtY2FzZSIpIHx8CgkJCSAgICAhc3RyY21wKGFyZywgIi1pIikpIHsKCQkJCXJlZ2ZsYWdzIHw9IFJFR19JQ0FTRTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi0tYWxsLW1hdGNoIikpIHsKCQkJCWFsbF9tYXRjaCA9IDE7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXByZWZpeGNtcChhcmcsICItLWVuY29kaW5nPSIpKSB7CgkJCQlhcmcgKz0gMTE7CgkJCQlpZiAoc3RyY21wKGFyZywgIm5vbmUiKSkKCQkJCQlnaXRfbG9nX291dHB1dF9lbmNvZGluZyA9IHhzdHJkdXAoYXJnKTsKCQkJCWVsc2UKCQkJCQlnaXRfbG9nX291dHB1dF9lbmNvZGluZyA9ICIiOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1yZXZlcnNlIikpIHsKCQkJCXJldnMtPnJldmVyc2UgXj0gMTsKCQkJCWNvbnRpbnVlOwoJCQl9CgoJCQlvcHRzID0gZGlmZl9vcHRfcGFyc2UoJnJldnMtPmRpZmZvcHQsIGFyZ3YraSwgYXJnYy1pKTsKCQkJaWYgKG9wdHMgPiAwKSB7CgkJCQlpZiAoc3RyY21wKGFyZ3ZbaV0sICIteiIpKQoJCQkJCXJldnMtPmRpZmYgPSAxOwoJCQkJaSArPSBvcHRzIC0gMTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCSp1bnJlY29nbml6ZWQrKyA9IGFyZzsKCQkJbGVmdCsrOwoJCQljb250aW51ZTsKCQl9CgoJCWlmIChoYW5kbGVfcmV2aXNpb25fYXJnKGFyZywgcmV2cywgZmxhZ3MsIHNlZW5fZGFzaGRhc2gpKSB7CgkJCWludCBqOwoJCQlpZiAoc2Vlbl9kYXNoZGFzaCB8fCAqYXJnID09ICdeJykKCQkJCWRpZSgiYmFkIHJldmlzaW9uICclcyciLCBhcmcpOwoKCQkJLyogSWYgd2UgZGlkbid0IGhhdmUgYSAiLS0iOgoJCQkgKiAoMSkgYWxsIGZpbGVuYW1lcyBtdXN0IGV4aXN0OwoJCQkgKiAoMikgYWxsIHJldi1hcmdzIG11c3Qgbm90IGJlIGludGVycHJldGFibGUKCQkJICogICAgIGFzIGEgdmFsaWQgZmlsZW5hbWUuCgkJCSAqIGJ1dCB0aGUgbGF0dGVyIHdlIGhhdmUgY2hlY2tlZCBpbiB0aGUgbWFpbiBsb29wLgoJCQkgKi8KCQkJZm9yIChqID0gaTsgaiA8IGFyZ2M7IGorKykKCQkJCXZlcmlmeV9maWxlbmFtZShyZXZzLT5wcmVmaXgsIGFyZ3Zbal0pOwoKCQkJcmV2cy0+cHJ1bmVfZGF0YSA9IGdldF9wYXRoc3BlYyhyZXZzLT5wcmVmaXgsCgkJCQkJCQlhcmd2ICsgaSk7CgkJCWJyZWFrOwoJCX0KCX0KCglpZiAocmV2cy0+Z3JlcF9maWx0ZXIpCgkJcmV2cy0+Z3JlcF9maWx0ZXItPnJlZ2ZsYWdzIHw9IHJlZ2ZsYWdzOwoKCWlmIChzaG93X21lcmdlKQoJCXByZXBhcmVfc2hvd19tZXJnZShyZXZzKTsKCWlmIChkZWYgJiYgIXJldnMtPnBlbmRpbmcubnIpIHsKCQl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJCXN0cnVjdCBvYmplY3QgKm9iamVjdDsKCQl1bnNpZ25lZCBtb2RlOwoJCWlmIChnZXRfc2hhMV93aXRoX21vZGUoZGVmLCBzaGExLCAmbW9kZSkpCgkJCWRpZSgiYmFkIGRlZmF1bHQgcmV2aXNpb24gJyVzJyIsIGRlZik7CgkJb2JqZWN0ID0gZ2V0X3JlZmVyZW5jZShyZXZzLCBkZWYsIHNoYTEsIDApOwoJCWFkZF9wZW5kaW5nX29iamVjdF93aXRoX21vZGUocmV2cywgb2JqZWN0LCBkZWYsIG1vZGUpOwoJfQoKCWlmIChyZXZzLT50b3BvX29yZGVyKQoJCXJldnMtPmxpbWl0ZWQgPSAxOwoKCWlmIChyZXZzLT5wcnVuZV9kYXRhKSB7CgkJZGlmZl90cmVlX3NldHVwX3BhdGhzKHJldnMtPnBydW5lX2RhdGEsICZyZXZzLT5wcnVuaW5nKTsKCQkvKiBDYW4ndCBwcnVuZSBjb21taXRzIHdpdGggcmVuYW1lIGZvbGxvd2luZzogdGhlIHBhdGhzIGNoYW5nZS4uICovCgkJaWYgKCFyZXZzLT5kaWZmb3B0LmZvbGxvd19yZW5hbWVzKQoJCQlyZXZzLT5wcnVuZV9mbiA9IHRyeV90b19zaW1wbGlmeV9jb21taXQ7CgkJaWYgKCFyZXZzLT5mdWxsX2RpZmYpCgkJCWRpZmZfdHJlZV9zZXR1cF9wYXRocyhyZXZzLT5wcnVuZV9kYXRhLCAmcmV2cy0+ZGlmZm9wdCk7Cgl9CglpZiAocmV2cy0+Y29tYmluZV9tZXJnZXMpIHsKCQlyZXZzLT5pZ25vcmVfbWVyZ2VzID0gMDsKCQlpZiAocmV2cy0+ZGVuc2VfY29tYmluZWRfbWVyZ2VzICYmICFyZXZzLT5kaWZmb3B0Lm91dHB1dF9mb3JtYXQpCgkJCXJldnMtPmRpZmZvcHQub3V0cHV0X2Zvcm1hdCA9IERJRkZfRk9STUFUX1BBVENIOwoJfQoJcmV2cy0+ZGlmZm9wdC5hYmJyZXYgPSByZXZzLT5hYmJyZXY7CglpZiAoZGlmZl9zZXR1cF9kb25lKCZyZXZzLT5kaWZmb3B0KSA8IDApCgkJZGllKCJkaWZmX3NldHVwX2RvbmUgZmFpbGVkIik7CgoJaWYgKHJldnMtPmdyZXBfZmlsdGVyKSB7CgkJcmV2cy0+Z3JlcF9maWx0ZXItPmFsbF9tYXRjaCA9IGFsbF9tYXRjaDsKCQljb21waWxlX2dyZXBfcGF0dGVybnMocmV2cy0+Z3JlcF9maWx0ZXIpOwoJfQoKCXJldHVybiBsZWZ0Owp9CgppbnQgcHJlcGFyZV9yZXZpc2lvbl93YWxrKHN0cnVjdCByZXZfaW5mbyAqcmV2cykKewoJaW50IG5yID0gcmV2cy0+cGVuZGluZy5ucjsKCXN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKmUsICpsaXN0OwoKCWUgPSBsaXN0ID0gcmV2cy0+cGVuZGluZy5vYmplY3RzOwoJcmV2cy0+cGVuZGluZy5uciA9IDA7CglyZXZzLT5wZW5kaW5nLmFsbG9jID0gMDsKCXJldnMtPnBlbmRpbmcub2JqZWN0cyA9IE5VTEw7Cgl3aGlsZSAoLS1uciA+PSAwKSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gaGFuZGxlX2NvbW1pdChyZXZzLCBlLT5pdGVtLCBlLT5uYW1lKTsKCQlpZiAoY29tbWl0KSB7CgkJCWlmICghKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgU0VFTikpIHsKCQkJCWNvbW1pdC0+b2JqZWN0LmZsYWdzIHw9IFNFRU47CgkJCQlpbnNlcnRfYnlfZGF0ZShjb21taXQsICZyZXZzLT5jb21taXRzKTsKCQkJfQoJCX0KCQllKys7Cgl9CglmcmVlKGxpc3QpOwoKCWlmIChyZXZzLT5ub193YWxrKQoJCXJldHVybiAwOwoJaWYgKHJldnMtPmxpbWl0ZWQpCgkJaWYgKGxpbWl0X2xpc3QocmV2cykgPCAwKQoJCQlyZXR1cm4gLTE7CglpZiAocmV2cy0+dG9wb19vcmRlcikKCQlzb3J0X2luX3RvcG9sb2dpY2FsX29yZGVyX2ZuKCZyZXZzLT5jb21taXRzLCByZXZzLT5saWZvLAoJCQkJCSAgICAgcmV2cy0+dG9wb19zZXR0ZXIsCgkJCQkJICAgICByZXZzLT50b3BvX2dldHRlcik7CglyZXR1cm4gMDsKfQoKZW51bSByZXdyaXRlX3Jlc3VsdCB7CglyZXdyaXRlX29uZV9vaywKCXJld3JpdGVfb25lX25vcGFyZW50cywKCXJld3JpdGVfb25lX2Vycm9yLAp9OwoKc3RhdGljIGVudW0gcmV3cml0ZV9yZXN1bHQgcmV3cml0ZV9vbmUoc3RydWN0IHJldl9pbmZvICpyZXZzLCBzdHJ1Y3QgY29tbWl0ICoqcHApCnsKCWZvciAoOzspIHsKCQlzdHJ1Y3QgY29tbWl0ICpwID0gKnBwOwoJCWlmICghcmV2cy0+bGltaXRlZCkKCQkJaWYgKGFkZF9wYXJlbnRzX3RvX2xpc3QocmV2cywgcCwgJnJldnMtPmNvbW1pdHMpIDwgMCkKCQkJCXJldHVybiByZXdyaXRlX29uZV9lcnJvcjsKCQlpZiAocC0+cGFyZW50cyAmJiBwLT5wYXJlbnRzLT5uZXh0KQoJCQlyZXR1cm4gcmV3cml0ZV9vbmVfb2s7CgkJaWYgKHAtPm9iamVjdC5mbGFncyAmIChUUkVFQ0hBTkdFIHwgVU5JTlRFUkVTVElORykpCgkJCXJldHVybiByZXdyaXRlX29uZV9vazsKCQlpZiAoIXAtPnBhcmVudHMpCgkJCXJldHVybiByZXdyaXRlX29uZV9ub3BhcmVudHM7CgkJKnBwID0gcC0+cGFyZW50cy0+aXRlbTsKCX0KfQoKc3RhdGljIHZvaWQgcmVtb3ZlX2R1cGxpY2F0ZV9wYXJlbnRzKHN0cnVjdCBjb21taXQgKmNvbW1pdCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICoqcHAsICpwOwoKCS8qIEV4YW1pbmUgZXhpc3RpbmcgcGFyZW50cyB3aGlsZSBtYXJraW5nIG9uZXMgd2UgaGF2ZSBzZWVuLi4uICovCglwcCA9ICZjb21taXQtPnBhcmVudHM7Cgl3aGlsZSAoKHAgPSAqcHApICE9IE5VTEwpIHsKCQlzdHJ1Y3QgY29tbWl0ICpwYXJlbnQgPSBwLT5pdGVtOwoJCWlmIChwYXJlbnQtPm9iamVjdC5mbGFncyAmIFRNUF9NQVJLKSB7CgkJCSpwcCA9IHAtPm5leHQ7CgkJCWNvbnRpbnVlOwoJCX0KCQlwYXJlbnQtPm9iamVjdC5mbGFncyB8PSBUTVBfTUFSSzsKCQlwcCA9ICZwLT5uZXh0OwoJfQoJLyogLi4uIGFuZCBjbGVhciB0aGUgdGVtcG9yYXJ5IG1hcmsgKi8KCWZvciAocCA9IGNvbW1pdC0+cGFyZW50czsgcDsgcCA9IHAtPm5leHQpCgkJcC0+aXRlbS0+b2JqZWN0LmZsYWdzICY9IH5UTVBfTUFSSzsKfQoKc3RhdGljIGludCByZXdyaXRlX3BhcmVudHMoc3RydWN0IHJldl9pbmZvICpyZXZzLCBzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqKnBwID0gJmNvbW1pdC0+cGFyZW50czsKCXdoaWxlICgqcHApIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudCA9ICpwcDsKCQlzd2l0Y2ggKHJld3JpdGVfb25lKHJldnMsICZwYXJlbnQtPml0ZW0pKSB7CgkJY2FzZSByZXdyaXRlX29uZV9vazoKCQkJYnJlYWs7CgkJY2FzZSByZXdyaXRlX29uZV9ub3BhcmVudHM6CgkJCSpwcCA9IHBhcmVudC0+bmV4dDsKCQkJY29udGludWU7CgkJY2FzZSByZXdyaXRlX29uZV9lcnJvcjoKCQkJcmV0dXJuIC0xOwoJCX0KCQlwcCA9ICZwYXJlbnQtPm5leHQ7Cgl9CglyZW1vdmVfZHVwbGljYXRlX3BhcmVudHMoY29tbWl0KTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGNvbW1pdF9tYXRjaChzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHN0cnVjdCByZXZfaW5mbyAqb3B0KQp7CglpZiAoIW9wdC0+Z3JlcF9maWx0ZXIpCgkJcmV0dXJuIDE7CglyZXR1cm4gZ3JlcF9idWZmZXIob3B0LT5ncmVwX2ZpbHRlciwKCQkJICAgTlVMTCwgLyogd2Ugc2F5IG5vdGhpbmcsIG5vdCBldmVuIGZpbGVuYW1lICovCgkJCSAgIGNvbW1pdC0+YnVmZmVyLCBzdHJsZW4oY29tbWl0LT5idWZmZXIpKTsKfQoKc3RhdGljIHN0cnVjdCBjb21taXQgKmdldF9yZXZpc2lvbl8xKHN0cnVjdCByZXZfaW5mbyAqcmV2cykKewoJaWYgKCFyZXZzLT5jb21taXRzKQoJCXJldHVybiBOVUxMOwoKCWRvIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKmVudHJ5ID0gcmV2cy0+Y29tbWl0czsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBlbnRyeS0+aXRlbTsKCgkJcmV2cy0+Y29tbWl0cyA9IGVudHJ5LT5uZXh0OwoJCWZyZWUoZW50cnkpOwoKCQlpZiAocmV2cy0+cmVmbG9nX2luZm8pCgkJCWZha2VfcmVmbG9nX3BhcmVudChyZXZzLT5yZWZsb2dfaW5mbywgY29tbWl0KTsKCgkJLyoKCQkgKiBJZiB3ZSBoYXZlbid0IGRvbmUgdGhlIGxpc3QgbGltaXRpbmcsIHdlIG5lZWQgdG8gbG9vayBhdAoJCSAqIHRoZSBwYXJlbnRzIGhlcmUuIFdlIGFsc28gbmVlZCB0byBkbyB0aGUgZGF0ZS1iYXNlZCBsaW1pdGluZwoJCSAqIHRoYXQgd2UnZCBvdGhlcndpc2UgaGF2ZSBkb25lIGluIGxpbWl0X2xpc3QoKS4KCQkgKi8KCQlpZiAoIXJldnMtPmxpbWl0ZWQpIHsKCQkJaWYgKHJldnMtPm1heF9hZ2UgIT0gLTEgJiYKCQkJICAgIChjb21taXQtPmRhdGUgPCByZXZzLT5tYXhfYWdlKSkKCQkJCWNvbnRpbnVlOwoJCQlpZiAoYWRkX3BhcmVudHNfdG9fbGlzdChyZXZzLCBjb21taXQsICZyZXZzLT5jb21taXRzKSA8IDApCgkJCQlyZXR1cm4gTlVMTDsKCQl9CgkJaWYgKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgU0hPV04pCgkJCWNvbnRpbnVlOwoKCQlpZiAocmV2cy0+dW5wYWNrZWQgJiYgaGFzX3NoYTFfcGFjayhjb21taXQtPm9iamVjdC5zaGExLAoJCQkJCQkgICAgcmV2cy0+aWdub3JlX3BhY2tlZCkpCgkJICAgIGNvbnRpbnVlOwoKCQlpZiAoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBVTklOVEVSRVNUSU5HKQoJCQljb250aW51ZTsKCQlpZiAocmV2cy0+bWluX2FnZSAhPSAtMSAmJiAoY29tbWl0LT5kYXRlID4gcmV2cy0+bWluX2FnZSkpCgkJCWNvbnRpbnVlOwoJCWlmIChyZXZzLT5ub19tZXJnZXMgJiYKCQkgICAgY29tbWl0LT5wYXJlbnRzICYmIGNvbW1pdC0+cGFyZW50cy0+bmV4dCkKCQkJY29udGludWU7CgkJaWYgKCFjb21taXRfbWF0Y2goY29tbWl0LCByZXZzKSkKCQkJY29udGludWU7CgkJaWYgKHJldnMtPnBydW5lX2ZuICYmIHJldnMtPmRlbnNlKSB7CgkJCS8qIENvbW1pdCB3aXRob3V0IGNoYW5nZXM/ICovCgkJCWlmICghKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgVFJFRUNIQU5HRSkpIHsKCQkJCS8qIGRyb3AgbWVyZ2VzIHVubGVzcyB3ZSB3YW50IHBhcmVudGhvb2QgKi8KCQkJCWlmICghcmV2cy0+cGFyZW50cykKCQkJCQljb250aW51ZTsKCQkJCS8qIG5vbi1tZXJnZSAtIGFsd2F5cyBpZ25vcmUgaXQgKi8KCQkJCWlmICghY29tbWl0LT5wYXJlbnRzIHx8ICFjb21taXQtPnBhcmVudHMtPm5leHQpCgkJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKHJldnMtPnBhcmVudHMgJiYgcmV3cml0ZV9wYXJlbnRzKHJldnMsIGNvbW1pdCkgPCAwKQoJCQkJcmV0dXJuIE5VTEw7CgkJfQoJCXJldHVybiBjb21taXQ7Cgl9IHdoaWxlIChyZXZzLT5jb21taXRzKTsKCXJldHVybiBOVUxMOwp9CgpzdGF0aWMgdm9pZCBnY19ib3VuZGFyeShzdHJ1Y3Qgb2JqZWN0X2FycmF5ICphcnJheSkKewoJdW5zaWduZWQgbnIgPSBhcnJheS0+bnI7Cgl1bnNpZ25lZCBhbGxvYyA9IGFycmF5LT5hbGxvYzsKCXN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKm9iamVjdHMgPSBhcnJheS0+b2JqZWN0czsKCglpZiAoYWxsb2MgPD0gbnIpIHsKCQl1bnNpZ25lZCBpLCBqOwoJCWZvciAoaSA9IGogPSAwOyBpIDwgbnI7IGkrKykgewoJCQlpZiAob2JqZWN0c1tpXS5pdGVtLT5mbGFncyAmIFNIT1dOKQoJCQkJY29udGludWU7CgkJCWlmIChpICE9IGopCgkJCQlvYmplY3RzW2pdID0gb2JqZWN0c1tpXTsKCQkJaisrOwoJCX0KCQlmb3IgKGkgPSBqOyBpIDwgbnI7IGkrKykKCQkJb2JqZWN0c1tpXS5pdGVtID0gTlVMTDsKCQlhcnJheS0+bnIgPSBqOwoJfQp9CgpzdHJ1Y3QgY29tbWl0ICpnZXRfcmV2aXNpb24oc3RydWN0IHJldl9pbmZvICpyZXZzKQp7CglzdHJ1Y3QgY29tbWl0ICpjID0gTlVMTDsKCXN0cnVjdCBjb21taXRfbGlzdCAqbDsKCglpZiAocmV2cy0+Ym91bmRhcnkgPT0gMikgewoJCXVuc2lnbmVkIGk7CgkJc3RydWN0IG9iamVjdF9hcnJheSAqYXJyYXkgPSAmcmV2cy0+Ym91bmRhcnlfY29tbWl0czsKCQlzdHJ1Y3Qgb2JqZWN0X2FycmF5X2VudHJ5ICpvYmplY3RzID0gYXJyYXktPm9iamVjdHM7CgkJZm9yIChpID0gMDsgaSA8IGFycmF5LT5ucjsgaSsrKSB7CgkJCWMgPSAoc3RydWN0IGNvbW1pdCAqKShvYmplY3RzW2ldLml0ZW0pOwoJCQlpZiAoIWMpCgkJCQljb250aW51ZTsKCQkJaWYgKCEoYy0+b2JqZWN0LmZsYWdzICYgQ0hJTERfU0hPV04pKQoJCQkJY29udGludWU7CgkJCWlmICghKGMtPm9iamVjdC5mbGFncyAmIFNIT1dOKSkKCQkJCWJyZWFrOwoJCX0KCQlpZiAoYXJyYXktPm5yIDw9IGkpCgkJCXJldHVybiBOVUxMOwoKCQljLT5vYmplY3QuZmxhZ3MgfD0gU0hPV04gfCBCT1VOREFSWTsKCQlyZXR1cm4gYzsKCX0KCglpZiAocmV2cy0+cmV2ZXJzZSkgewoJCWludCBsaW1pdCA9IC0xOwoKCQlpZiAoMCA8PSByZXZzLT5tYXhfY291bnQpIHsKCQkJbGltaXQgPSByZXZzLT5tYXhfY291bnQ7CgkJCWlmICgwIDwgcmV2cy0+c2tpcF9jb3VudCkKCQkJCWxpbWl0ICs9IHJldnMtPnNraXBfY291bnQ7CgkJfQoJCWwgPSBOVUxMOwoJCXdoaWxlICgoYyA9IGdldF9yZXZpc2lvbl8xKHJldnMpKSkgewoJCQljb21taXRfbGlzdF9pbnNlcnQoYywgJmwpOwoJCQlpZiAoKDAgPCBsaW1pdCkgJiYgIS0tbGltaXQpCgkJCQlicmVhazsKCQl9CgkJcmV2cy0+Y29tbWl0cyA9IGw7CgkJcmV2cy0+cmV2ZXJzZSA9IDA7CgkJcmV2cy0+bWF4X2NvdW50ID0gLTE7CgkJYyA9IE5VTEw7Cgl9CgoJLyoKCSAqIE5vdyBwaWNrIHVwIHdoYXQgdGhleSB3YW50IHRvIGdpdmUgdXMKCSAqLwoJYyA9IGdldF9yZXZpc2lvbl8xKHJldnMpOwoJaWYgKGMpIHsKCQl3aGlsZSAoMCA8IHJldnMtPnNraXBfY291bnQpIHsKCQkJcmV2cy0+c2tpcF9jb3VudC0tOwoJCQljID0gZ2V0X3JldmlzaW9uXzEocmV2cyk7CgkJCWlmICghYykKCQkJCWJyZWFrOwoJCX0KCX0KCgkvKgoJICogQ2hlY2sgdGhlIG1heF9jb3VudC4KCSAqLwoJc3dpdGNoIChyZXZzLT5tYXhfY291bnQpIHsKCWNhc2UgLTE6CgkJYnJlYWs7CgljYXNlIDA6CgkJYyA9IE5VTEw7CgkJYnJlYWs7CglkZWZhdWx0OgoJCXJldnMtPm1heF9jb3VudC0tOwoJfQoKCWlmIChjKQoJCWMtPm9iamVjdC5mbGFncyB8PSBTSE9XTjsKCglpZiAoIXJldnMtPmJvdW5kYXJ5KSB7CgkJcmV0dXJuIGM7Cgl9CgoJaWYgKCFjKSB7CgkJLyoKCQkgKiBnZXRfcmV2aXNpb25fMSgpIHJ1bnMgb3V0IHRoZSBjb21taXRzLCBhbmQKCQkgKiB3ZSBhcmUgZG9uZSBjb21wdXRpbmcgdGhlIGJvdW5kYXJpZXMuCgkJICogc3dpdGNoIHRvIGJvdW5kYXJ5IGNvbW1pdHMgb3V0cHV0IG1vZGUuCgkJICovCgkJcmV2cy0+Ym91bmRhcnkgPSAyOwoJCXJldHVybiBnZXRfcmV2aXNpb24ocmV2cyk7Cgl9CgoJLyoKCSAqIGJvdW5kYXJ5IGNvbW1pdHMgYXJlIHRoZSBjb21taXRzIHRoYXQgYXJlIHBhcmVudHMgb2YgdGhlCgkgKiBvbmVzIHdlIGdvdCBmcm9tIGdldF9yZXZpc2lvbl8xKCkgYnV0IHRoZXkgdGhlbXNlbHZlcyBhcmUKCSAqIG5vdCByZXR1cm5lZCBmcm9tIGdldF9yZXZpc2lvbl8xKCkuICBCZWZvcmUgcmV0dXJuaW5nCgkgKiAnYycsIHdlIG5lZWQgdG8gbWFyayBpdHMgcGFyZW50cyB0aGF0IHRoZXkgY291bGQgYmUgYm91bmRhcmllcy4KCSAqLwoKCWZvciAobCA9IGMtPnBhcmVudHM7IGw7IGwgPSBsLT5uZXh0KSB7CgkJc3RydWN0IG9iamVjdCAqcDsKCQlwID0gJihsLT5pdGVtLT5vYmplY3QpOwoJCWlmIChwLT5mbGFncyAmIChDSElMRF9TSE9XTiB8IFNIT1dOKSkKCQkJY29udGludWU7CgkJcC0+ZmxhZ3MgfD0gQ0hJTERfU0hPV047CgkJZ2NfYm91bmRhcnkoJnJldnMtPmJvdW5kYXJ5X2NvbW1pdHMpOwoJCWFkZF9vYmplY3RfYXJyYXkocCwgTlVMTCwgJnJldnMtPmJvdW5kYXJ5X2NvbW1pdHMpOwoJfQoKCXJldHVybiBjOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"revision.h\"\n#include \"grep.h\"\n#include \"reflog-walk.h\"\n#include \"patch-ids.h\"\n\nstatic char *path_name(struct name_path *path, const char *name)\n{\n\tstruct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n\t}\n\tn = xmalloc(len);\n\tm = n + len - (nlen + 1);\n\tstrcpy(m, name);\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len) {\n\t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}\n\nvoid add_object(struct object *obj,\n\t\tstruct object_array *p,\n\t\tstruct name_path *path,\n\t\tconst char *name)\n{\n\tadd_object_array(obj, path_name(path, name), p);\n}\n\nstatic void mark_blob_uninteresting(struct blob *blob)\n{\n\tif (blob->object.flags & UNINTERESTING)\n\t\treturn;\n\tblob->object.flags |= UNINTERESTING;\n}\n\nvoid mark_tree_uninteresting(struct tree *tree)\n{\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tstruct object *obj = &tree->object;\n\n\tif (obj->flags & UNINTERESTING)\n\t\treturn;\n\tobj->flags |= UNINTERESTING;\n\tif (!has_sha1_file(obj->sha1))\n\t\treturn;\n\tif (parse_tree(tree) < 0)\n\t\tdie(\"bad tree %s\", sha1_to_hex(obj->sha1));\n\n\tinit_tree_desc(&desc, tree->buffer, tree->size);\n\twhile (tree_entry(&desc, &entry)) {\n\t\tif (S_ISDIR(entry.mode))\n\t\t\tmark_tree_uninteresting(lookup_tree(entry.sha1));\n\t\telse\n\t\t\tmark_blob_uninteresting(lookup_blob(entry.sha1));\n\t}\n\n\t/*\n\t * We don't care about the tree any more\n\t * after it has been marked uninteresting.\n\t */\n\tfree(tree->buffer);\n\ttree->buffer = NULL;\n}\n\nvoid mark_parents_uninteresting(struct commit *commit)\n{\n\tstruct commit_list *parents = commit->parents;\n\n\twhile (parents) {\n\t\tstruct commit *commit = parents->item;\n\t\tif (!(commit->object.flags & UNINTERESTING)) {\n\t\t\tcommit->object.flags |= UNINTERESTING;\n\n\t\t\t/*\n\t\t\t * Normally we haven't parsed the parent\n\t\t\t * yet, so we won't have a parent of a parent\n\t\t\t * here. However, it may turn out that we've\n\t\t\t * reached this commit some other way (where it\n\t\t\t * wasn't uninteresting), in which case we need\n\t\t\t * to mark its parents recursively too..\n\t\t\t */\n\t\t\tif (commit->parents)\n\t\t\t\tmark_parents_uninteresting(commit);\n\t\t}\n\n\t\t/*\n\t\t * A missing commit is ok iff its parent is marked\n\t\t * uninteresting.\n\t\t *\n\t\t * We just mark such a thing parsed, so that when\n\t\t * it is popped next time around, we won't be trying\n\t\t * to parse it and get an error.\n\t\t */\n\t\tif (!has_sha1_file(commit->object.sha1))\n\t\t\tcommit->object.parsed = 1;\n\t\tparents = parents->next;\n\t}\n}\n\nstatic void add_pending_object_with_mode(struct rev_info *revs, struct object *obj, const char *name, unsigned mode)\n{\n\tif (revs->no_walk && (obj->flags & UNINTERESTING))\n\t\tdie(\"object ranges do not make sense when not walking revisions\");\n\tadd_object_array_with_mode(obj, name, &revs->pending, mode);\n\tif (revs->reflog_info && obj->type == OBJ_COMMIT)\n\t\tadd_reflog_for_walk(revs->reflog_info,\n\t\t\t\t(struct commit *)obj, name);\n}\n\nvoid add_pending_object(struct rev_info *revs, struct object *obj, const char *name)\n{\n\tadd_pending_object_with_mode(revs, obj, name, S_IFINVALID);\n}\n\nstatic struct object *get_reference(struct rev_info *revs, const char *name, const unsigned char *sha1, unsigned int flags)\n{\n\tstruct object *object;\n\n\tobject = parse_object(sha1);\n\tif (!object)\n\t\tdie(\"bad object %s\", name);\n\tobject->flags |= flags;\n\treturn object;\n}\n\nstatic struct commit *handle_commit(struct rev_info *revs, struct object *object, const char *name)\n{\n\tunsigned long flags = object->flags;\n\n\t/*\n\t * Tag object? Look what it points to..\n\t */\n\twhile (object->type == OBJ_TAG) {\n\t\tstruct tag *tag = (struct tag *) object;\n\t\tif (revs->tag_objects && !(flags & UNINTERESTING))\n\t\t\tadd_pending_object(revs, object, tag->tag);\n\t\tobject = parse_object(tag->tagged->sha1);\n\t\tif (!object)\n\t\t\tdie(\"bad object %s\", sha1_to_hex(tag->tagged->sha1));\n\t}\n\n\t/*\n\t * Commit object? Just return it, we'll do all the complex\n\t * reachability crud.\n\t */\n\tif (object->type == OBJ_COMMIT) {\n\t\tstruct commit *commit = (struct commit *)object;\n\t\tif (parse_commit(commit) < 0)\n\t\t\tdie(\"unable to parse commit %s\", name);\n\t\tif (flags & UNINTERESTING) {\n\t\t\tcommit->object.flags |= UNINTERESTING;\n\t\t\tmark_parents_uninteresting(commit);\n\t\t\trevs->limited = 1;\n\t\t}\n\t\treturn commit;\n\t}\n\n\t/*\n\t * Tree object? Either mark it uniniteresting, or add it\n\t * to the list of objects to look at later..\n\t */\n\tif (object->type == OBJ_TREE) {\n\t\tstruct tree *tree = (struct tree *)object;\n\t\tif (!revs->tree_objects)\n\t\t\treturn NULL;\n\t\tif (flags & UNINTERESTING) {\n\t\t\tmark_tree_uninteresting(tree);\n\t\t\treturn NULL;\n\t\t}\n\t\tadd_pending_object(revs, object, \"\");\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Blob object? You know the drill by now..\n\t */\n\tif (object->type == OBJ_BLOB) {\n\t\tstruct blob *blob = (struct blob *)object;\n\t\tif (!revs->blob_objects)\n\t\t\treturn NULL;\n\t\tif (flags & UNINTERESTING) {\n\t\t\tmark_blob_uninteresting(blob);\n\t\t\treturn NULL;\n\t\t}\n\t\tadd_pending_object(revs, object, \"\");\n\t\treturn NULL;\n\t}\n\tdie(\"%s is unknown object\", name);\n}\n\nstatic int everybody_uninteresting(struct commit_list *orig)\n{\n\tstruct commit_list *list = orig;\n\twhile (list) {\n\t\tstruct commit *commit = list->item;\n\t\tlist = list->next;\n\t\tif (commit->object.flags & UNINTERESTING)\n\t\t\tcontinue;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/*\n * The goal is to get REV_TREE_NEW as the result only if the\n * diff consists of all '+' (and no other changes), and\n * REV_TREE_DIFFERENT otherwise (of course if the trees are\n * the same we want REV_TREE_SAME).  That means that once we\n * get to REV_TREE_DIFFERENT, we do not have to look any further.\n */\nstatic int tree_difference = REV_TREE_SAME;\n\nstatic void file_add_remove(struct diff_options *options,\n\t\t    int addremove, unsigned mode,\n\t\t    const unsigned char *sha1,\n\t\t    const char *base, const char *path)\n{\n\tint diff = REV_TREE_DIFFERENT;\n\n\t/*\n\t * Is it an add of a new file? It means that the old tree\n\t * didn't have it at all, so we will turn \"REV_TREE_SAME\" ->\n\t * \"REV_TREE_NEW\", but leave any \"REV_TREE_DIFFERENT\" alone\n\t * (and if it already was \"REV_TREE_NEW\", we'll keep it\n\t * \"REV_TREE_NEW\" of course).\n\t */\n\tif (addremove == '+') {\n\t\tdiff = tree_difference;\n\t\tif (diff != REV_TREE_SAME)\n\t\t\treturn;\n\t\tdiff = REV_TREE_NEW;\n\t}\n\ttree_difference = diff;\n\tif (tree_difference == REV_TREE_DIFFERENT)\n\t\toptions->has_changes = 1;\n}\n\nstatic void file_change(struct diff_options *options,\n\t\t unsigned old_mode, unsigned new_mode,\n\t\t const unsigned char *old_sha1,\n\t\t const unsigned char *new_sha1,\n\t\t const char *base, const char *path)\n{\n\ttree_difference = REV_TREE_DIFFERENT;\n\toptions->has_changes = 1;\n}\n\nstatic int rev_compare_tree(struct rev_info *revs, struct tree *t1, struct tree *t2)\n{\n\tif (!t1)\n\t\treturn REV_TREE_NEW;\n\tif (!t2)\n\t\treturn REV_TREE_DIFFERENT;\n\ttree_difference = REV_TREE_SAME;\n\trevs->pruning.has_changes = 0;\n\tif (diff_tree_sha1(t1->object.sha1, t2->object.sha1, \"\",\n\t\t\t   &revs->pruning) < 0)\n\t\treturn REV_TREE_DIFFERENT;\n\treturn tree_difference;\n}\n\nstatic int rev_same_tree_as_empty(struct rev_info *revs, struct tree *t1)\n{\n\tint retval;\n\tvoid *tree;\n\tunsigned long size;\n\tstruct tree_desc empty, real;\n\n\tif (!t1)\n\t\treturn 0;\n\n\ttree = read_object_with_reference(t1->object.sha1, tree_type, &size, NULL);\n\tif (!tree)\n\t\treturn 0;\n\tinit_tree_desc(&real, tree, size);\n\tinit_tree_desc(&empty, \"\", 0);\n\n\ttree_difference = REV_TREE_SAME;\n\trevs->pruning.has_changes = 0;\n\tretval = diff_tree(&empty, &real, \"\", &revs->pruning);\n\tfree(tree);\n\n\treturn retval >= 0 && (tree_difference == REV_TREE_SAME);\n}\n\nstatic void try_to_simplify_commit(struct rev_info *revs, struct commit *commit)\n{\n\tstruct commit_list **pp, *parent;\n\tint tree_changed = 0, tree_same = 0;\n\n\tif (!commit->tree)\n\t\treturn;\n\n\tif (!commit->parents) {\n\t\tif (!rev_same_tree_as_empty(revs, commit->tree))\n\t\t\tcommit->object.flags |= TREECHANGE;\n\t\treturn;\n\t}\n\n\tpp = &commit->parents;\n\twhile ((parent = *pp) != NULL) {\n\t\tstruct commit *p = parent->item;\n\n\t\tif (parse_commit(p) < 0)\n\t\t\tdie(\"cannot simplify commit %s (because of %s)\",\n\t\t\t    sha1_to_hex(commit->object.sha1),\n\t\t\t    sha1_to_hex(p->object.sha1));\n\t\tswitch (rev_compare_tree(revs, p->tree, commit->tree)) {\n\t\tcase REV_TREE_SAME:\n\t\t\ttree_same = 1;\n\t\t\tif (!revs->simplify_history || (p->object.flags & UNINTERESTING)) {\n\t\t\t\t/* Even if a merge with an uninteresting\n\t\t\t\t * side branch brought the entire change\n\t\t\t\t * we are interested in, we do not want\n\t\t\t\t * to lose the other branches of this\n\t\t\t\t * merge, so we just keep going.\n\t\t\t\t */\n\t\t\t\tpp = &parent->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparent->next = NULL;\n\t\t\tcommit->parents = parent;\n\t\t\treturn;\n\n\t\tcase REV_TREE_NEW:\n\t\t\tif (revs->remove_empty_trees &&\n\t\t\t    rev_same_tree_as_empty(revs, p->tree)) {\n\t\t\t\t/* We are adding all the specified\n\t\t\t\t * paths from this parent, so the\n\t\t\t\t * history beyond this parent is not\n\t\t\t\t * interesting.  Remove its parents\n\t\t\t\t * (they are grandparents for us).\n\t\t\t\t * IOW, we pretend this parent is a\n\t\t\t\t * \"root\" commit.\n\t\t\t\t */\n\t\t\t\tif (parse_commit(p) < 0)\n\t\t\t\t\tdie(\"cannot simplify commit %s (invalid %s)\",\n\t\t\t\t\t    sha1_to_hex(commit->object.sha1),\n\t\t\t\t\t    sha1_to_hex(p->object.sha1));\n\t\t\t\tp->parents = NULL;\n\t\t\t}\n\t\t/* fallthrough */\n\t\tcase REV_TREE_DIFFERENT:\n\t\t\ttree_changed = 1;\n\t\t\tpp = &parent->next;\n\t\t\tcontinue;\n\t\t}\n\t\tdie(\"bad tree compare for commit %s\", sha1_to_hex(commit->object.sha1));\n\t}\n\tif (tree_changed && !tree_same)\n\t\tcommit->object.flags |= TREECHANGE;\n}\n\nstatic int add_parents_to_list(struct rev_info *revs, struct commit *commit, struct commit_list **list)\n{\n\tstruct commit_list *parent = commit->parents;\n\tunsigned left_flag;\n\tint add, rest;\n\n\tif (commit->object.flags & ADDED)\n\t\treturn 0;\n\tcommit->object.flags |= ADDED;\n\n\t/*\n\t * If the commit is uninteresting, don't try to\n\t * prune parents - we want the maximal uninteresting\n\t * set.\n\t *\n\t * Normally we haven't parsed the parent\n\t * yet, so we won't have a parent of a parent\n\t * here. However, it may turn out that we've\n\t * reached this commit some other way (where it\n\t * wasn't uninteresting), in which case we need\n\t * to mark its parents recursively too..\n\t */\n\tif (commit->object.flags & UNINTERESTING) {\n\t\twhile (parent) {\n\t\t\tstruct commit *p = parent->item;\n\t\t\tparent = parent->next;\n\t\t\tif (parse_commit(p) < 0)\n\t\t\t\treturn -1;\n\t\t\tp->object.flags |= UNINTERESTING;\n\t\t\tif (p->parents)\n\t\t\t\tmark_parents_uninteresting(p);\n\t\t\tif (p->object.flags & SEEN)\n\t\t\t\tcontinue;\n\t\t\tp->object.flags |= SEEN;\n\t\t\tinsert_by_date(p, list);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Ok, the commit wasn't uninteresting. Try to\n\t * simplify the commit history and find the parent\n\t * that has no differences in the path set if one exists.\n\t */\n\tif (revs->prune_fn)\n\t\trevs->prune_fn(revs, commit);\n\n\tif (revs->no_walk)\n\t\treturn 0;\n\n\tleft_flag = (commit->object.flags & SYMMETRIC_LEFT);\n\n\trest = !revs->first_parent_only;\n\tfor (parent = commit->parents, add = 1; parent; add = rest) {\n\t\tstruct commit *p = parent->item;\n\n\t\tparent = parent->next;\n\t\tif (parse_commit(p) < 0)\n\t\t\treturn -1;\n\t\tp->object.flags |= left_flag;\n\t\tif (p->object.flags & SEEN)\n\t\t\tcontinue;\n\t\tp->object.flags |= SEEN;\n\t\tif (add)\n\t\t\tinsert_by_date(p, list);\n\t}\n\treturn 0;\n}\n\nstatic void cherry_pick_list(struct commit_list *list, struct rev_info *revs)\n{\n\tstruct commit_list *p;\n\tint left_count = 0, right_count = 0;\n\tint left_first;\n\tstruct patch_ids ids;\n\n\t/* First count the commits on the left and on the right */\n\tfor (p = list; p; p = p->next) {\n\t\tstruct commit *commit = p->item;\n\t\tunsigned flags = commit->object.flags;\n\t\tif (flags & BOUNDARY)\n\t\t\t;\n\t\telse if (flags & SYMMETRIC_LEFT)\n\t\t\tleft_count++;\n\t\telse\n\t\t\tright_count++;\n\t}\n\n\tleft_first = left_count < right_count;\n\tinit_patch_ids(&ids);\n\tif (revs->diffopt.nr_paths) {\n\t\tids.diffopts.nr_paths = revs->diffopt.nr_paths;\n\t\tids.diffopts.paths = revs->diffopt.paths;\n\t\tids.diffopts.pathlens = revs->diffopt.pathlens;\n\t}\n\n\t/* Compute patch-ids for one side */\n\tfor (p = list; p; p = p->next) {\n\t\tstruct commit *commit = p->item;\n\t\tunsigned flags = commit->object.flags;\n\n\t\tif (flags & BOUNDARY)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If we have fewer left, left_first is set and we omit\n\t\t * commits on the right branch in this loop.  If we have\n\t\t * fewer right, we skip the left ones.\n\t\t */\n\t\tif (left_first != !!(flags & SYMMETRIC_LEFT))\n\t\t\tcontinue;\n\t\tcommit->util = add_commit_patch_id(commit, &ids);\n\t}\n\n\t/* Check the other side */\n\tfor (p = list; p; p = p->next) {\n\t\tstruct commit *commit = p->item;\n\t\tstruct patch_id *id;\n\t\tunsigned flags = commit->object.flags;\n\n\t\tif (flags & BOUNDARY)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If we have fewer left, left_first is set and we omit\n\t\t * commits on the left branch in this loop.\n\t\t */\n\t\tif (left_first == !!(flags & SYMMETRIC_LEFT))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Have we seen the same patch id?\n\t\t */\n\t\tid = has_commit_patch_id(commit, &ids);\n\t\tif (!id)\n\t\t\tcontinue;\n\t\tid->seen = 1;\n\t\tcommit->object.flags |= SHOWN;\n\t}\n\n\t/* Now check the original side for seen ones */\n\tfor (p = list; p; p = p->next) {\n\t\tstruct commit *commit = p->item;\n\t\tstruct patch_id *ent;\n\n\t\tent = commit->util;\n\t\tif (!ent)\n\t\t\tcontinue;\n\t\tif (ent->seen)\n\t\t\tcommit->object.flags |= SHOWN;\n\t\tcommit->util = NULL;\n\t}\n\n\tfree_patch_ids(&ids);\n}\n\nstatic int limit_list(struct rev_info *revs)\n{\n\tstruct commit_list *list = revs->commits;\n\tstruct commit_list *newlist = NULL;\n\tstruct commit_list **p = &newlist;\n\n\twhile (list) {\n\t\tstruct commit_list *entry = list;\n\t\tstruct commit *commit = list->item;\n\t\tstruct object *obj = &commit->object;\n\n\t\tlist = list->next;\n\t\tfree(entry);\n\n\t\tif (revs->max_age != -1 && (commit->date < revs->max_age))\n\t\t\tobj->flags |= UNINTERESTING;\n\t\tif (add_parents_to_list(revs, commit, &list) < 0)\n\t\t\treturn -1;\n\t\tif (obj->flags & UNINTERESTING) {\n\t\t\tmark_parents_uninteresting(commit);\n\t\t\tif (everybody_uninteresting(list))\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (revs->min_age != -1 && (commit->date > revs->min_age))\n\t\t\tcontinue;\n\t\tp = &commit_list_insert(commit, p)->next;\n\t}\n\tif (revs->cherry_pick)\n\t\tcherry_pick_list(newlist, revs);\n\n\trevs->commits = newlist;\n\treturn 0;\n}\n\nstruct all_refs_cb {\n\tint all_flags;\n\tint warned_bad_reflog;\n\tstruct rev_info *all_revs;\n\tconst char *name_for_errormsg;\n};\n\nstatic int handle_one_ref(const char *path, const unsigned char *sha1, int flag, void *cb_data)\n{\n\tstruct all_refs_cb *cb = cb_data;\n\tstruct object *object = get_reference(cb->all_revs, path, sha1,\n\t\t\t\t\t      cb->all_flags);\n\tadd_pending_object(cb->all_revs, object, path);\n\treturn 0;\n}\n\nstatic void handle_all(struct rev_info *revs, unsigned flags)\n{\n\tstruct all_refs_cb cb;\n\tcb.all_revs = revs;\n\tcb.all_flags = flags;\n\tfor_each_ref(handle_one_ref, &cb);\n}\n\nstatic void handle_one_reflog_commit(unsigned char *sha1, void *cb_data)\n{\n\tstruct all_refs_cb *cb = cb_data;\n\tif (!is_null_sha1(sha1)) {\n\t\tstruct object *o = parse_object(sha1);\n\t\tif (o) {\n\t\t\to->flags |= cb->all_flags;\n\t\t\tadd_pending_object(cb->all_revs, o, \"\");\n\t\t}\n\t\telse if (!cb->warned_bad_reflog) {\n\t\t\twarning(\"reflog of '%s' references pruned commits\",\n\t\t\t\tcb->name_for_errormsg);\n\t\t\tcb->warned_bad_reflog = 1;\n\t\t}\n\t}\n}\n\nstatic int handle_one_reflog_ent(unsigned char *osha1, unsigned char *nsha1,\n\t\tconst char *email, unsigned long timestamp, int tz,\n\t\tconst char *message, void *cb_data)\n{\n\thandle_one_reflog_commit(osha1, cb_data);\n\thandle_one_reflog_commit(nsha1, cb_data);\n\treturn 0;\n}\n\nstatic int handle_one_reflog(const char *path, const unsigned char *sha1, int flag, void *cb_data)\n{\n\tstruct all_refs_cb *cb = cb_data;\n\tcb->warned_bad_reflog = 0;\n\tcb->name_for_errormsg = path;\n\tfor_each_reflog_ent(path, handle_one_reflog_ent, cb_data);\n\treturn 0;\n}\n\nstatic void handle_reflog(struct rev_info *revs, unsigned flags)\n{\n\tstruct all_refs_cb cb;\n\tcb.all_revs = revs;\n\tcb.all_flags = flags;\n\tfor_each_reflog(handle_one_reflog, &cb);\n}\n\nstatic int add_parents_only(struct rev_info *revs, const char *arg, int flags)\n{\n\tunsigned char sha1[20];\n\tstruct object *it;\n\tstruct commit *commit;\n\tstruct commit_list *parents;\n\n\tif (*arg == '^') {\n\t\tflags ^= UNINTERESTING;\n\t\targ++;\n\t}\n\tif (get_sha1(arg, sha1))\n\t\treturn 0;\n\twhile (1) {\n\t\tit = get_reference(revs, arg, sha1, 0);\n\t\tif (it->type != OBJ_TAG)\n\t\t\tbreak;\n\t\thashcpy(sha1, ((struct tag*)it)->tagged->sha1);\n\t}\n\tif (it->type != OBJ_COMMIT)\n\t\treturn 0;\n\tcommit = (struct commit *)it;\n\tfor (parents = commit->parents; parents; parents = parents->next) {\n\t\tit = &parents->item->object;\n\t\tit->flags |= flags;\n\t\tadd_pending_object(revs, it, arg);\n\t}\n\treturn 1;\n}\n\nvoid init_revisions(struct rev_info *revs, const char *prefix)\n{\n\tmemset(revs, 0, sizeof(*revs));\n\n\trevs->abbrev = DEFAULT_ABBREV;\n\trevs->ignore_merges = 1;\n\trevs->simplify_history = 1;\n\trevs->pruning.recursive = 1;\n\trevs->pruning.quiet = 1;\n\trevs->pruning.add_remove = file_add_remove;\n\trevs->pruning.change = file_change;\n\trevs->lifo = 1;\n\trevs->dense = 1;\n\trevs->prefix = prefix;\n\trevs->max_age = -1;\n\trevs->min_age = -1;\n\trevs->skip_count = -1;\n\trevs->max_count = -1;\n\n\trevs->prune_fn = NULL;\n\trevs->prune_data = NULL;\n\n\trevs->topo_setter = topo_sort_default_setter;\n\trevs->topo_getter = topo_sort_default_getter;\n\n\trevs->commit_format = CMIT_FMT_DEFAULT;\n\n\tdiff_setup(&revs->diffopt);\n}\n\nstatic void add_pending_commit_list(struct rev_info *revs,\n                                    struct commit_list *commit_list,\n                                    unsigned int flags)\n{\n\twhile (commit_list) {\n\t\tstruct object *object = &commit_list->item->object;\n\t\tobject->flags |= flags;\n\t\tadd_pending_object(revs, object, sha1_to_hex(object->sha1));\n\t\tcommit_list = commit_list->next;\n\t}\n}\n\nstatic void prepare_show_merge(struct rev_info *revs)\n{\n\tstruct commit_list *bases;\n\tstruct commit *head, *other;\n\tunsigned char sha1[20];\n\tconst char **prune = NULL;\n\tint i, prune_num = 1; /* counting terminating NULL */\n\n\tif (get_sha1(\"HEAD\", sha1) || !(head = lookup_commit(sha1)))\n\t\tdie(\"--merge without HEAD?\");\n\tif (get_sha1(\"MERGE_HEAD\", sha1) || !(other = lookup_commit(sha1)))\n\t\tdie(\"--merge without MERGE_HEAD?\");\n\tadd_pending_object(revs, &head->object, \"HEAD\");\n\tadd_pending_object(revs, &other->object, \"MERGE_HEAD\");\n\tbases = get_merge_bases(head, other, 1);\n\twhile (bases) {\n\t\tstruct commit *it = bases->item;\n\t\tstruct commit_list *n = bases->next;\n\t\tfree(bases);\n\t\tbases = n;\n\t\tit->object.flags |= UNINTERESTING;\n\t\tadd_pending_object(revs, &it->object, \"(merge-base)\");\n\t}\n\n\tif (!active_nr)\n\t\tread_cache();\n\tfor (i = 0; i < active_nr; i++) {\n\t\tstruct cache_entry *ce = active_cache[i];\n\t\tif (!ce_stage(ce))\n\t\t\tcontinue;\n\t\tif (ce_path_match(ce, revs->prune_data)) {\n\t\t\tprune_num++;\n\t\t\tprune = xrealloc(prune, sizeof(*prune) * prune_num);\n\t\t\tprune[prune_num-2] = ce->name;\n\t\t\tprune[prune_num-1] = NULL;\n\t\t}\n\t\twhile ((i+1 < active_nr) &&\n\t\t       ce_same_name(ce, active_cache[i+1]))\n\t\t\ti++;\n\t}\n\trevs->prune_data = prune;\n}\n\nint handle_revision_arg(const char *arg, struct rev_info *revs,\n\t\t\tint flags,\n\t\t\tint cant_be_filename)\n{\n\tunsigned mode;\n\tchar *dotdot;\n\tstruct object *object;\n\tunsigned char sha1[20];\n\tint local_flags;\n\n\tdotdot = strstr(arg, \"..\");\n\tif (dotdot) {\n\t\tunsigned char from_sha1[20];\n\t\tconst char *next = dotdot + 2;\n\t\tconst char *this = arg;\n\t\tint symmetric = *next == '.';\n\t\tunsigned int flags_exclude = flags ^ UNINTERESTING;\n\n\t\t*dotdot = 0;\n\t\tnext += symmetric;\n\n\t\tif (!*next)\n\t\t\tnext = \"HEAD\";\n\t\tif (dotdot == arg)\n\t\t\tthis = \"HEAD\";\n\t\tif (!get_sha1(this, from_sha1) &&\n\t\t    !get_sha1(next, sha1)) {\n\t\t\tstruct commit *a, *b;\n\t\t\tstruct commit_list *exclude;\n\n\t\t\ta = lookup_commit_reference(from_sha1);\n\t\t\tb = lookup_commit_reference(sha1);\n\t\t\tif (!a || !b) {\n\t\t\t\tdie(symmetric ?\n\t\t\t\t    \"Invalid symmetric difference expression %s...%s\" :\n\t\t\t\t    \"Invalid revision range %s..%s\",\n\t\t\t\t    arg, next);\n\t\t\t}\n\n\t\t\tif (!cant_be_filename) {\n\t\t\t\t*dotdot = '.';\n\t\t\t\tverify_non_filename(revs->prefix, arg);\n\t\t\t}\n\n\t\t\tif (symmetric) {\n\t\t\t\texclude = get_merge_bases(a, b, 1);\n\t\t\t\tadd_pending_commit_list(revs, exclude,\n\t\t\t\t\t\t\tflags_exclude);\n\t\t\t\tfree_commit_list(exclude);\n\t\t\t\ta->object.flags |= flags | SYMMETRIC_LEFT;\n\t\t\t} else\n\t\t\t\ta->object.flags |= flags_exclude;\n\t\t\tb->object.flags |= flags;\n\t\t\tadd_pending_object(revs, &a->object, this);\n\t\t\tadd_pending_object(revs, &b->object, next);\n\t\t\treturn 0;\n\t\t}\n\t\t*dotdot = '.';\n\t}\n\tdotdot = strstr(arg, \"^@\");\n\tif (dotdot && !dotdot[2]) {\n\t\t*dotdot = 0;\n\t\tif (add_parents_only(revs, arg, flags))\n\t\t\treturn 0;\n\t\t*dotdot = '^';\n\t}\n\tdotdot = strstr(arg, \"^!\");\n\tif (dotdot && !dotdot[2]) {\n\t\t*dotdot = 0;\n\t\tif (!add_parents_only(revs, arg, flags ^ UNINTERESTING))\n\t\t\t*dotdot = '^';\n\t}\n\n\tlocal_flags = 0;\n\tif (*arg == '^') {\n\t\tlocal_flags = UNINTERESTING;\n\t\targ++;\n\t}\n\tif (get_sha1_with_mode(arg, sha1, &mode))\n\t\treturn -1;\n\tif (!cant_be_filename)\n\t\tverify_non_filename(revs->prefix, arg);\n\tobject = get_reference(revs, arg, sha1, flags ^ local_flags);\n\tadd_pending_object_with_mode(revs, object, arg, mode);\n\treturn 0;\n}\n\nstatic void add_grep(struct rev_info *revs, const char *ptn, enum grep_pat_token what)\n{\n\tif (!revs->grep_filter) {\n\t\tstruct grep_opt *opt = xcalloc(1, sizeof(*opt));\n\t\topt->status_only = 1;\n\t\topt->pattern_tail = &(opt->pattern_list);\n\t\topt->regflags = REG_NEWLINE;\n\t\trevs->grep_filter = opt;\n\t}\n\tappend_grep_pattern(revs->grep_filter, ptn,\n\t\t\t    \"command line\", 0, what);\n}\n\nstatic void add_header_grep(struct rev_info *revs, const char *field, const char *pattern)\n{\n\tchar *pat;\n\tconst char *prefix;\n\tint patlen, fldlen;\n\n\tfldlen = strlen(field);\n\tpatlen = strlen(pattern);\n\tpat = xmalloc(patlen + fldlen + 10);\n\tprefix = \".*\";\n\tif (*pattern == '^') {\n\t\tprefix = \"\";\n\t\tpattern++;\n\t}\n\tsprintf(pat, \"^%s %s%s\", field, prefix, pattern);\n\tadd_grep(revs, pat, GREP_PATTERN_HEAD);\n}\n\nstatic void add_message_grep(struct rev_info *revs, const char *pattern)\n{\n\tadd_grep(revs, pattern, GREP_PATTERN_BODY);\n}\n\nstatic void add_ignore_packed(struct rev_info *revs, const char *name)\n{\n\tint num = ++revs->num_ignore_packed;\n\n\trevs->ignore_packed = xrealloc(revs->ignore_packed,\n\t\t\t\t       sizeof(const char **) * (num + 1));\n\trevs->ignore_packed[num-1] = name;\n\trevs->ignore_packed[num] = NULL;\n}\n\n/*\n * Parse revision information, filling in the \"rev_info\" structure,\n * and removing the used arguments from the argument list.\n *\n * Returns the number of arguments left that weren't recognized\n * (which are also moved to the head of the argument list)\n */\nint setup_revisions(int argc, const char **argv, struct rev_info *revs, const char *def)\n{\n\tint i, flags, seen_dashdash, show_merge;\n\tconst char **unrecognized = argv + 1;\n\tint left = 1;\n\tint all_match = 0;\n\tint regflags = 0;\n\n\t/* First, search for \"--\" */\n\tseen_dashdash = 0;\n\tfor (i = 1; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\t\tif (strcmp(arg, \"--\"))\n\t\t\tcontinue;\n\t\targv[i] = NULL;\n\t\targc = i;\n\t\trevs->prune_data = get_pathspec(revs->prefix, argv + i + 1);\n\t\tseen_dashdash = 1;\n\t\tbreak;\n\t}\n\n\tflags = show_merge = 0;\n\tfor (i = 1; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\t\tif (*arg == '-') {\n\t\t\tint opts;\n\t\t\tif (!prefixcmp(arg, \"--max-count=\")) {\n\t\t\t\trevs->max_count = atoi(arg + 12);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--skip=\")) {\n\t\t\t\trevs->skip_count = atoi(arg + 7);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* accept -<digit>, like traditional \"head\" */\n\t\t\tif ((*arg == '-') && isdigit(arg[1])) {\n\t\t\t\trevs->max_count = atoi(arg + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-n\")) {\n\t\t\t\tif (argc <= i + 1)\n\t\t\t\t\tdie(\"-n requires an argument\");\n\t\t\t\trevs->max_count = atoi(argv[++i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"-n\")) {\n\t\t\t\trevs->max_count = atoi(arg + 2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--max-age=\")) {\n\t\t\t\trevs->max_age = atoi(arg + 10);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--since=\")) {\n\t\t\t\trevs->max_age = approxidate(arg + 8);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--after=\")) {\n\t\t\t\trevs->max_age = approxidate(arg + 8);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--min-age=\")) {\n\t\t\t\trevs->min_age = atoi(arg + 10);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--before=\")) {\n\t\t\t\trevs->min_age = approxidate(arg + 9);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--until=\")) {\n\t\t\t\trevs->min_age = approxidate(arg + 8);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--all\")) {\n\t\t\t\thandle_all(revs, flags);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--first-parent\")) {\n\t\t\t\trevs->first_parent_only = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--reflog\")) {\n\t\t\t\thandle_reflog(revs, flags);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-g\") ||\n\t\t\t\t\t!strcmp(arg, \"--walk-reflogs\")) {\n\t\t\t\tinit_reflog_walk(&revs->reflog_info);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--not\")) {\n\t\t\t\tflags ^= UNINTERESTING;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--default\")) {\n\t\t\t\tif (++i >= argc)\n\t\t\t\t\tdie(\"bad --default argument\");\n\t\t\t\tdef = argv[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--merge\")) {\n\t\t\t\tshow_merge = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--topo-order\")) {\n\t\t\t\trevs->topo_order = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--date-order\")) {\n\t\t\t\trevs->lifo = 0;\n\t\t\t\trevs->topo_order = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--parents\")) {\n\t\t\t\trevs->parents = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--dense\")) {\n\t\t\t\trevs->dense = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--sparse\")) {\n\t\t\t\trevs->dense = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--remove-empty\")) {\n\t\t\t\trevs->remove_empty_trees = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--no-merges\")) {\n\t\t\t\trevs->no_merges = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--boundary\")) {\n\t\t\t\trevs->boundary = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--left-right\")) {\n\t\t\t\trevs->left_right = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--cherry-pick\")) {\n\t\t\t\trevs->cherry_pick = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--objects\")) {\n\t\t\t\trevs->tag_objects = 1;\n\t\t\t\trevs->tree_objects = 1;\n\t\t\t\trevs->blob_objects = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--objects-edge\")) {\n\t\t\t\trevs->tag_objects = 1;\n\t\t\t\trevs->tree_objects = 1;\n\t\t\t\trevs->blob_objects = 1;\n\t\t\t\trevs->edge_hint = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--unpacked\")) {\n\t\t\t\trevs->unpacked = 1;\n\t\t\t\tfree(revs->ignore_packed);\n\t\t\t\trevs->ignore_packed = NULL;\n\t\t\t\trevs->num_ignore_packed = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--unpacked=\")) {\n\t\t\t\trevs->unpacked = 1;\n\t\t\t\tadd_ignore_packed(revs, arg+11);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-r\")) {\n\t\t\t\trevs->diff = 1;\n\t\t\t\trevs->diffopt.recursive = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-t\")) {\n\t\t\t\trevs->diff = 1;\n\t\t\t\trevs->diffopt.recursive = 1;\n\t\t\t\trevs->diffopt.tree_in_recursive = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-m\")) {\n\t\t\t\trevs->ignore_merges = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-c\")) {\n\t\t\t\trevs->diff = 1;\n\t\t\t\trevs->dense_combined_merges = 0;\n\t\t\t\trevs->combine_merges = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--cc\")) {\n\t\t\t\trevs->diff = 1;\n\t\t\t\trevs->dense_combined_merges = 1;\n\t\t\t\trevs->combine_merges = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"-v\")) {\n\t\t\t\trevs->verbose_header = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--pretty\")) {\n\t\t\t\trevs->verbose_header = 1;\n\t\t\t\trevs->commit_format = get_commit_format(arg+8);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--root\")) {\n\t\t\t\trevs->show_root_diff = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--no-commit-id\")) {\n\t\t\t\trevs->no_commit_id = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--always\")) {\n\t\t\t\trevs->always_show_header = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--no-abbrev\")) {\n\t\t\t\trevs->abbrev = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--abbrev\")) {\n\t\t\t\trevs->abbrev = DEFAULT_ABBREV;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--abbrev=\")) {\n\t\t\t\trevs->abbrev = strtoul(arg + 9, NULL, 10);\n\t\t\t\tif (revs->abbrev < MINIMUM_ABBREV)\n\t\t\t\t\trevs->abbrev = MINIMUM_ABBREV;\n\t\t\t\telse if (revs->abbrev > 40)\n\t\t\t\t\trevs->abbrev = 40;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--abbrev-commit\")) {\n\t\t\t\trevs->abbrev_commit = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--full-diff\")) {\n\t\t\t\trevs->diff = 1;\n\t\t\t\trevs->full_diff = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--full-history\")) {\n\t\t\t\trevs->simplify_history = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--relative-date\")) {\n\t\t\t\trevs->date_mode = DATE_RELATIVE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strncmp(arg, \"--date=\", 7)) {\n\t\t\t\tif (!strcmp(arg + 7, \"relative\"))\n\t\t\t\t\trevs->date_mode = DATE_RELATIVE;\n\t\t\t\telse if (!strcmp(arg + 7, \"iso8601\") ||\n\t\t\t\t\t !strcmp(arg + 7, \"iso\"))\n\t\t\t\t\trevs->date_mode = DATE_ISO8601;\n\t\t\t\telse if (!strcmp(arg + 7, \"rfc2822\") ||\n\t\t\t\t\t !strcmp(arg + 7, \"rfc\"))\n\t\t\t\t\trevs->date_mode = DATE_RFC2822;\n\t\t\t\telse if (!strcmp(arg + 7, \"short\"))\n\t\t\t\t\trevs->date_mode = DATE_SHORT;\n\t\t\t\telse if (!strcmp(arg + 7, \"local\"))\n\t\t\t\t\trevs->date_mode = DATE_LOCAL;\n\t\t\t\telse if (!strcmp(arg + 7, \"default\"))\n\t\t\t\t\trevs->date_mode = DATE_NORMAL;\n\t\t\t\telse\n\t\t\t\t\tdie(\"unknown date format %s\", arg);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grepping the commit log\n\t\t\t */\n\t\t\tif (!prefixcmp(arg, \"--author=\")) {\n\t\t\t\tadd_header_grep(revs, \"author\", arg+9);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--committer=\")) {\n\t\t\t\tadd_header_grep(revs, \"committer\", arg+12);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--grep=\")) {\n\t\t\t\tadd_message_grep(revs, arg+7);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--extended-regexp\") ||\n\t\t\t    !strcmp(arg, \"-E\")) {\n\t\t\t\tregflags |= REG_EXTENDED;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--regexp-ignore-case\") ||\n\t\t\t    !strcmp(arg, \"-i\")) {\n\t\t\t\tregflags |= REG_ICASE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--all-match\")) {\n\t\t\t\tall_match = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--encoding=\")) {\n\t\t\t\targ += 11;\n\t\t\t\tif (strcmp(arg, \"none\"))\n\t\t\t\t\tgit_log_output_encoding = xstrdup(arg);\n\t\t\t\telse\n\t\t\t\t\tgit_log_output_encoding = \"\";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--reverse\")) {\n\t\t\t\trevs->reverse ^= 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\topts = diff_opt_parse(&revs->diffopt, argv+i, argc-i);\n\t\t\tif (opts > 0) {\n\t\t\t\tif (strcmp(argv[i], \"-z\"))\n\t\t\t\t\trevs->diff = 1;\n\t\t\t\ti += opts - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*unrecognized++ = arg;\n\t\t\tleft++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (handle_revision_arg(arg, revs, flags, seen_dashdash)) {\n\t\t\tint j;\n\t\t\tif (seen_dashdash || *arg == '^')\n\t\t\t\tdie(\"bad revision '%s'\", arg);\n\n\t\t\t/* If we didn't have a \"--\":\n\t\t\t * (1) all filenames must exist;\n\t\t\t * (2) all rev-args must not be interpretable\n\t\t\t *     as a valid filename.\n\t\t\t * but the latter we have checked in the main loop.\n\t\t\t */\n\t\t\tfor (j = i; j < argc; j++)\n\t\t\t\tverify_filename(revs->prefix, argv[j]);\n\n\t\t\trevs->prune_data = get_pathspec(revs->prefix,\n\t\t\t\t\t\t\targv + i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (revs->grep_filter)\n\t\trevs->grep_filter->regflags |= regflags;\n\n\tif (show_merge)\n\t\tprepare_show_merge(revs);\n\tif (def && !revs->pending.nr) {\n\t\tunsigned char sha1[20];\n\t\tstruct object *object;\n\t\tunsigned mode;\n\t\tif (get_sha1_with_mode(def, sha1, &mode))\n\t\t\tdie(\"bad default revision '%s'\", def);\n\t\tobject = get_reference(revs, def, sha1, 0);\n\t\tadd_pending_object_with_mode(revs, object, def, mode);\n\t}\n\n\tif (revs->topo_order)\n\t\trevs->limited = 1;\n\n\tif (revs->prune_data) {\n\t\tdiff_tree_setup_paths(revs->prune_data, &revs->pruning);\n\t\t/* Can't prune commits with rename following: the paths change.. */\n\t\tif (!revs->diffopt.follow_renames)\n\t\t\trevs->prune_fn = try_to_simplify_commit;\n\t\tif (!revs->full_diff)\n\t\t\tdiff_tree_setup_paths(revs->prune_data, &revs->diffopt);\n\t}\n\tif (revs->combine_merges) {\n\t\trevs->ignore_merges = 0;\n\t\tif (revs->dense_combined_merges && !revs->diffopt.output_format)\n\t\t\trevs->diffopt.output_format = DIFF_FORMAT_PATCH;\n\t}\n\trevs->diffopt.abbrev = revs->abbrev;\n\tif (diff_setup_done(&revs->diffopt) < 0)\n\t\tdie(\"diff_setup_done failed\");\n\n\tif (revs->grep_filter) {\n\t\trevs->grep_filter->all_match = all_match;\n\t\tcompile_grep_patterns(revs->grep_filter);\n\t}\n\n\treturn left;\n}\n\nint prepare_revision_walk(struct rev_info *revs)\n{\n\tint nr = revs->pending.nr;\n\tstruct object_array_entry *e, *list;\n\n\te = list = revs->pending.objects;\n\trevs->pending.nr = 0;\n\trevs->pending.alloc = 0;\n\trevs->pending.objects = NULL;\n\twhile (--nr >= 0) {\n\t\tstruct commit *commit = handle_commit(revs, e->item, e->name);\n\t\tif (commit) {\n\t\t\tif (!(commit->object.flags & SEEN)) {\n\t\t\t\tcommit->object.flags |= SEEN;\n\t\t\t\tinsert_by_date(commit, &revs->commits);\n\t\t\t}\n\t\t}\n\t\te++;\n\t}\n\tfree(list);\n\n\tif (revs->no_walk)\n\t\treturn 0;\n\tif (revs->limited)\n\t\tif (limit_list(revs) < 0)\n\t\t\treturn -1;\n\tif (revs->topo_order)\n\t\tsort_in_topological_order_fn(&revs->commits, revs->lifo,\n\t\t\t\t\t     revs->topo_setter,\n\t\t\t\t\t     revs->topo_getter);\n\treturn 0;\n}\n\nenum rewrite_result {\n\trewrite_one_ok,\n\trewrite_one_noparents,\n\trewrite_one_error,\n};\n\nstatic enum rewrite_result rewrite_one(struct rev_info *revs, struct commit **pp)\n{\n\tfor (;;) {\n\t\tstruct commit *p = *pp;\n\t\tif (!revs->limited)\n\t\t\tif (add_parents_to_list(revs, p, &revs->commits) < 0)\n\t\t\t\treturn rewrite_one_error;\n\t\tif (p->parents && p->parents->next)\n\t\t\treturn rewrite_one_ok;\n\t\tif (p->object.flags & (TREECHANGE | UNINTERESTING))\n\t\t\treturn rewrite_one_ok;\n\t\tif (!p->parents)\n\t\t\treturn rewrite_one_noparents;\n\t\t*pp = p->parents->item;\n\t}\n}\n\nstatic void remove_duplicate_parents(struct commit *commit)\n{\n\tstruct commit_list **pp, *p;\n\n\t/* Examine existing parents while marking ones we have seen... */\n\tpp = &commit->parents;\n\twhile ((p = *pp) != NULL) {\n\t\tstruct commit *parent = p->item;\n\t\tif (parent->object.flags & TMP_MARK) {\n\t\t\t*pp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tparent->object.flags |= TMP_MARK;\n\t\tpp = &p->next;\n\t}\n\t/* ... and clear the temporary mark */\n\tfor (p = commit->parents; p; p = p->next)\n\t\tp->item->object.flags &= ~TMP_MARK;\n}\n\nstatic int rewrite_parents(struct rev_info *revs, struct commit *commit)\n{\n\tstruct commit_list **pp = &commit->parents;\n\twhile (*pp) {\n\t\tstruct commit_list *parent = *pp;\n\t\tswitch (rewrite_one(revs, &parent->item)) {\n\t\tcase rewrite_one_ok:\n\t\t\tbreak;\n\t\tcase rewrite_one_noparents:\n\t\t\t*pp = parent->next;\n\t\t\tcontinue;\n\t\tcase rewrite_one_error:\n\t\t\treturn -1;\n\t\t}\n\t\tpp = &parent->next;\n\t}\n\tremove_duplicate_parents(commit);\n\treturn 0;\n}\n\nstatic int commit_match(struct commit *commit, struct rev_info *opt)\n{\n\tif (!opt->grep_filter)\n\t\treturn 1;\n\treturn grep_buffer(opt->grep_filter,\n\t\t\t   NULL, /* we say nothing, not even filename */\n\t\t\t   commit->buffer, strlen(commit->buffer));\n}\n\nstatic struct commit *get_revision_1(struct rev_info *revs)\n{\n\tif (!revs->commits)\n\t\treturn NULL;\n\n\tdo {\n\t\tstruct commit_list *entry = revs->commits;\n\t\tstruct commit *commit = entry->item;\n\n\t\trevs->commits = entry->next;\n\t\tfree(entry);\n\n\t\tif (revs->reflog_info)\n\t\t\tfake_reflog_parent(revs->reflog_info, commit);\n\n\t\t/*\n\t\t * If we haven't done the list limiting, we need to look at\n\t\t * the parents here. We also need to do the date-based limiting\n\t\t * that we'd otherwise have done in limit_list().\n\t\t */\n\t\tif (!revs->limited) {\n\t\t\tif (revs->max_age != -1 &&\n\t\t\t    (commit->date < revs->max_age))\n\t\t\t\tcontinue;\n\t\t\tif (add_parents_to_list(revs, commit, &revs->commits) < 0)\n\t\t\t\treturn NULL;\n\t\t}\n\t\tif (commit->object.flags & SHOWN)\n\t\t\tcontinue;\n\n\t\tif (revs->unpacked && has_sha1_pack(commit->object.sha1,\n\t\t\t\t\t\t    revs->ignore_packed))\n\t\t    continue;\n\n\t\tif (commit->object.flags & UNINTERESTING)\n\t\t\tcontinue;\n\t\tif (revs->min_age != -1 && (commit->date > revs->min_age))\n\t\t\tcontinue;\n\t\tif (revs->no_merges &&\n\t\t    commit->parents && commit->parents->next)\n\t\t\tcontinue;\n\t\tif (!commit_match(commit, revs))\n\t\t\tcontinue;\n\t\tif (revs->prune_fn && revs->dense) {\n\t\t\t/* Commit without changes? */\n\t\t\tif (!(commit->object.flags & TREECHANGE)) {\n\t\t\t\t/* drop merges unless we want parenthood */\n\t\t\t\tif (!revs->parents)\n\t\t\t\t\tcontinue;\n\t\t\t\t/* non-merge - always ignore it */\n\t\t\t\tif (!commit->parents || !commit->parents->next)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (revs->parents && rewrite_parents(revs, commit) < 0)\n\t\t\t\treturn NULL;\n\t\t}\n\t\treturn commit;\n\t} while (revs->commits);\n\treturn NULL;\n}\n\nstatic void gc_boundary(struct object_array *array)\n{\n\tunsigned nr = array->nr;\n\tunsigned alloc = array->alloc;\n\tstruct object_array_entry *objects = array->objects;\n\n\tif (alloc <= nr) {\n\t\tunsigned i, j;\n\t\tfor (i = j = 0; i < nr; i++) {\n\t\t\tif (objects[i].item->flags & SHOWN)\n\t\t\t\tcontinue;\n\t\t\tif (i != j)\n\t\t\t\tobjects[j] = objects[i];\n\t\t\tj++;\n\t\t}\n\t\tfor (i = j; i < nr; i++)\n\t\t\tobjects[i].item = NULL;\n\t\tarray->nr = j;\n\t}\n}\n\nstruct commit *get_revision(struct rev_info *revs)\n{\n\tstruct commit *c = NULL;\n\tstruct commit_list *l;\n\n\tif (revs->boundary == 2) {\n\t\tunsigned i;\n\t\tstruct object_array *array = &revs->boundary_commits;\n\t\tstruct object_array_entry *objects = array->objects;\n\t\tfor (i = 0; i < array->nr; i++) {\n\t\t\tc = (struct commit *)(objects[i].item);\n\t\t\tif (!c)\n\t\t\t\tcontinue;\n\t\t\tif (!(c->object.flags & CHILD_SHOWN))\n\t\t\t\tcontinue;\n\t\t\tif (!(c->object.flags & SHOWN))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (array->nr <= i)\n\t\t\treturn NULL;\n\n\t\tc->object.flags |= SHOWN | BOUNDARY;\n\t\treturn c;\n\t}\n\n\tif (revs->reverse) {\n\t\tint limit = -1;\n\n\t\tif (0 <= revs->max_count) {\n\t\t\tlimit = revs->max_count;\n\t\t\tif (0 < revs->skip_count)\n\t\t\t\tlimit += revs->skip_count;\n\t\t}\n\t\tl = NULL;\n\t\twhile ((c = get_revision_1(revs))) {\n\t\t\tcommit_list_insert(c, &l);\n\t\t\tif ((0 < limit) && !--limit)\n\t\t\t\tbreak;\n\t\t}\n\t\trevs->commits = l;\n\t\trevs->reverse = 0;\n\t\trevs->max_count = -1;\n\t\tc = NULL;\n\t}\n\n\t/*\n\t * Now pick up what they want to give us\n\t */\n\tc = get_revision_1(revs);\n\tif (c) {\n\t\twhile (0 < revs->skip_count) {\n\t\t\trevs->skip_count--;\n\t\t\tc = get_revision_1(revs);\n\t\t\tif (!c)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Check the max_count.\n\t */\n\tswitch (revs->max_count) {\n\tcase -1:\n\t\tbreak;\n\tcase 0:\n\t\tc = NULL;\n\t\tbreak;\n\tdefault:\n\t\trevs->max_count--;\n\t}\n\n\tif (c)\n\t\tc->object.flags |= SHOWN;\n\n\tif (!revs->boundary) {\n\t\treturn c;\n\t}\n\n\tif (!c) {\n\t\t/*\n\t\t * get_revision_1() runs out the commits, and\n\t\t * we are done computing the boundaries.\n\t\t * switch to boundary commits output mode.\n\t\t */\n\t\trevs->boundary = 2;\n\t\treturn get_revision(revs);\n\t}\n\n\t/*\n\t * boundary commits are the commits that are parents of the\n\t * ones we got from get_revision_1() but they themselves are\n\t * not returned from get_revision_1().  Before returning\n\t * 'c', we need to mark its parents that they could be boundaries.\n\t */\n\n\tfor (l = c->parents; l; l = l->next) {\n\t\tstruct object *p;\n\t\tp = &(l->item->object);\n\t\tif (p->flags & (CHILD_SHOWN | SHOWN))\n\t\t\tcontinue;\n\t\tp->flags |= CHILD_SHOWN;\n\t\tgc_boundary(&revs->boundary_commits);\n\t\tadd_object_array(p, NULL, &revs->boundary_commits);\n\t}\n\n\treturn c;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00b75bc10b53b0c64b14fc1d9111d5f4e1db3af5",
  "sha1_ok": true,
  "size": 38170
}
