{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGJyYW5jaCIKICoKICogQ29weXJpZ2h0IChjKSAyMDA2IEtyaXN0aWFuIEjDuGdzYmVyZyA8a3JoQHJlZGhhdC5jb20+CiAqIEJhc2VkIG9uIGdpdC1icmFuY2guc2ggYnkgSnVuaW8gQyBIYW1hbm8uCiAqLwoKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb2xvci5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJyZW1vdGUuaCIKI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCIKI2luY2x1ZGUgImJyYW5jaC5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAicmV2aXNpb24uaCIKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgYnVpbHRpbl9icmFuY2hfdXNhZ2VbXSA9IHsKCSJnaXQgYnJhbmNoIFtvcHRpb25zXSBbLXIgfCAtYV0gWy0tbWVyZ2VkIHwgLS1uby1tZXJnZWRdIiwKCSJnaXQgYnJhbmNoIFtvcHRpb25zXSBbLWxdIFstZl0gPGJyYW5jaG5hbWU+IFs8c3RhcnQtcG9pbnQ+XSIsCgkiZ2l0IGJyYW5jaCBbb3B0aW9uc10gWy1yXSAoLWQgfCAtRCkgPGJyYW5jaG5hbWU+Li4uIiwKCSJnaXQgYnJhbmNoIFtvcHRpb25zXSAoLW0gfCAtTSkgWzxvbGRicmFuY2g+XSA8bmV3YnJhbmNoPiIsCglOVUxMCn07CgojZGVmaW5lIFJFRl9MT0NBTF9CUkFOQ0ggICAgMHgwMQojZGVmaW5lIFJFRl9SRU1PVEVfQlJBTkNIICAgMHgwMgoKc3RhdGljIGNvbnN0IGNoYXIgKmhlYWQ7CnN0YXRpYyB1bnNpZ25lZCBjaGFyIGhlYWRfc2hhMVsyMF07CgpzdGF0aWMgaW50IGJyYW5jaF91c2VfY29sb3IgPSAtMTsKc3RhdGljIGNoYXIgYnJhbmNoX2NvbG9yc1tdW0NPTE9SX01BWExFTl0gPSB7CglHSVRfQ09MT1JfUkVTRVQsCglHSVRfQ09MT1JfTk9STUFMLAkvKiBQTEFJTiAqLwoJR0lUX0NPTE9SX1JFRCwJCS8qIFJFTU9URSAqLwoJR0lUX0NPTE9SX05PUk1BTCwJLyogTE9DQUwgKi8KCUdJVF9DT0xPUl9HUkVFTiwJLyogQ1VSUkVOVCAqLwp9OwplbnVtIGNvbG9yX2JyYW5jaCB7CglCUkFOQ0hfQ09MT1JfUkVTRVQgPSAwLAoJQlJBTkNIX0NPTE9SX1BMQUlOID0gMSwKCUJSQU5DSF9DT0xPUl9SRU1PVEUgPSAyLAoJQlJBTkNIX0NPTE9SX0xPQ0FMID0gMywKCUJSQU5DSF9DT0xPUl9DVVJSRU5UID0gNAp9OwoKc3RhdGljIGVudW0gbWVyZ2VfZmlsdGVyIHsKCU5PX0ZJTFRFUiA9IDAsCglTSE9XX05PVF9NRVJHRUQsCglTSE9XX01FUkdFRAp9IG1lcmdlX2ZpbHRlcjsKc3RhdGljIHVuc2lnbmVkIGNoYXIgbWVyZ2VfZmlsdGVyX3JlZlsyMF07CgpzdGF0aWMgaW50IHBhcnNlX2JyYW5jaF9jb2xvcl9zbG90KGNvbnN0IGNoYXIgKnZhciwgaW50IG9mcykKewoJaWYgKCFzdHJjYXNlY21wKHZhcitvZnMsICJwbGFpbiIpKQoJCXJldHVybiBCUkFOQ0hfQ09MT1JfUExBSU47CglpZiAoIXN0cmNhc2VjbXAodmFyK29mcywgInJlc2V0IikpCgkJcmV0dXJuIEJSQU5DSF9DT0xPUl9SRVNFVDsKCWlmICghc3RyY2FzZWNtcCh2YXIrb2ZzLCAicmVtb3RlIikpCgkJcmV0dXJuIEJSQU5DSF9DT0xPUl9SRU1PVEU7CglpZiAoIXN0cmNhc2VjbXAodmFyK29mcywgImxvY2FsIikpCgkJcmV0dXJuIEJSQU5DSF9DT0xPUl9MT0NBTDsKCWlmICghc3RyY2FzZWNtcCh2YXIrb2ZzLCAiY3VycmVudCIpKQoJCXJldHVybiBCUkFOQ0hfQ09MT1JfQ1VSUkVOVDsKCXJldHVybiAtMTsKfQoKc3RhdGljIGludCBnaXRfYnJhbmNoX2NvbmZpZyhjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlLCB2b2lkICpjYikKewoJaWYgKCFzdHJjbXAodmFyLCAiY29sb3IuYnJhbmNoIikpIHsKCQlicmFuY2hfdXNlX2NvbG9yID0gZ2l0X2NvbmZpZ19jb2xvcmJvb2wodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXByZWZpeGNtcCh2YXIsICJjb2xvci5icmFuY2guIikpIHsKCQlpbnQgc2xvdCA9IHBhcnNlX2JyYW5jaF9jb2xvcl9zbG90KHZhciwgMTMpOwoJCWlmIChzbG90IDwgMCkKCQkJcmV0dXJuIDA7CgkJaWYgKCF2YWx1ZSkKCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKHZhcik7CgkJY29sb3JfcGFyc2UodmFsdWUsIHZhciwgYnJhbmNoX2NvbG9yc1tzbG90XSk7CgkJcmV0dXJuIDA7Cgl9CglyZXR1cm4gZ2l0X2NvbG9yX2RlZmF1bHRfY29uZmlnKHZhciwgdmFsdWUsIGNiKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKmJyYW5jaF9nZXRfY29sb3IoZW51bSBjb2xvcl9icmFuY2ggaXgpCnsKCWlmICh3YW50X2NvbG9yKGJyYW5jaF91c2VfY29sb3IpKQoJCXJldHVybiBicmFuY2hfY29sb3JzW2l4XTsKCXJldHVybiAiIjsKfQoKc3RhdGljIGludCBicmFuY2hfbWVyZ2VkKGludCBraW5kLCBjb25zdCBjaGFyICpuYW1lLAoJCQkgc3RydWN0IGNvbW1pdCAqcmV2LCBzdHJ1Y3QgY29tbWl0ICpoZWFkX3JldikKewoJLyoKCSAqIFRoaXMgY2hlY2tzIHdoZXRoZXIgdGhlIG1lcmdlIGJhc2VzIG9mIGJyYW5jaCBhbmQgSEVBRCAob3IKCSAqIHRoZSBvdGhlciBicmFuY2ggdGhpcyBicmFuY2ggYnVpbGRzIHVwb24pIGNvbnRhaW5zIHRoZQoJICogYnJhbmNoLCB3aGljaCBtZWFucyB0aGF0IHRoZSBicmFuY2ggaGFzIGFscmVhZHkgYmVlbiBtZXJnZWQKCSAqIHNhZmVseSB0byBIRUFEIChvciB0aGUgb3RoZXIgYnJhbmNoKS4KCSAqLwoJc3RydWN0IGNvbW1pdCAqcmVmZXJlbmNlX3JldiA9IE5VTEw7Cgljb25zdCBjaGFyICpyZWZlcmVuY2VfbmFtZSA9IE5VTEw7CglpbnQgbWVyZ2VkOwoKCWlmIChraW5kID09IFJFRl9MT0NBTF9CUkFOQ0gpIHsKCQlzdHJ1Y3QgYnJhbmNoICpicmFuY2ggPSBicmFuY2hfZ2V0KG5hbWUpOwoJCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgoJCWlmIChicmFuY2ggJiYKCQkgICAgYnJhbmNoLT5tZXJnZSAmJgoJCSAgICBicmFuY2gtPm1lcmdlWzBdICYmCgkJICAgIGJyYW5jaC0+bWVyZ2VbMF0tPmRzdCAmJgoJCSAgICAocmVmZXJlbmNlX25hbWUgPQoJCSAgICAgcmVzb2x2ZV9yZWYoYnJhbmNoLT5tZXJnZVswXS0+ZHN0LCBzaGExLCAxLCBOVUxMKSkgIT0gTlVMTCkKCQkJcmVmZXJlbmNlX3JldiA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlKHNoYTEpOwoJfQoJaWYgKCFyZWZlcmVuY2VfcmV2KQoJCXJlZmVyZW5jZV9yZXYgPSBoZWFkX3JldjsKCgltZXJnZWQgPSBpbl9tZXJnZV9iYXNlcyhyZXYsICZyZWZlcmVuY2VfcmV2LCAxKTsKCgkvKgoJICogQWZ0ZXIgdGhlIHNhZmV0eSB2YWx2ZSBpcyBmdWxseSByZWRlZmluZWQgdG8gImNoZWNrIHdpdGgKCSAqIHVwc3RyZWFtLCBpZiBhbnksIG90aGVyd2lzZSB3aXRoIEhFQUQiLCB3ZSBzaG91bGQganVzdAoJICogcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGluX21lcmdlX2Jhc2VzKCkgYWJvdmUgd2l0aG91dAoJICogYW55IG9mIHRoZSBmb2xsb3dpbmcgY29kZSwgYnV0IGR1cmluZyB0aGUgdHJhbnNpdGlvbiBwZXJpb2QsCgkgKiBhIGdlbnRsZSByZW1pbmRlciBpcyBpbiBvcmRlci4KCSAqLwoJaWYgKChoZWFkX3JldiAhPSByZWZlcmVuY2VfcmV2KSAmJgoJICAgIGluX21lcmdlX2Jhc2VzKHJldiwgJmhlYWRfcmV2LCAxKSAhPSBtZXJnZWQpIHsKCQlpZiAobWVyZ2VkKQoJCQl3YXJuaW5nKF8oImRlbGV0aW5nIGJyYW5jaCAnJXMnIHRoYXQgaGFzIGJlZW4gbWVyZ2VkIHRvXG4iCgkJCQkiICAgICAgICAgJyVzJywgYnV0IG5vdCB5ZXQgbWVyZ2VkIHRvIEhFQUQuIiksCgkJCQluYW1lLCByZWZlcmVuY2VfbmFtZSk7CgkJZWxzZQoJCQl3YXJuaW5nKF8oIm5vdCBkZWxldGluZyBicmFuY2ggJyVzJyB0aGF0IGlzIG5vdCB5ZXQgbWVyZ2VkIHRvXG4iCgkJCQkiICAgICAgICAgJyVzJywgZXZlbiB0aG91Z2ggaXQgaXMgbWVyZ2VkIHRvIEhFQUQuIiksCgkJCQluYW1lLCByZWZlcmVuY2VfbmFtZSk7Cgl9CglyZXR1cm4gbWVyZ2VkOwp9CgpzdGF0aWMgaW50IGRlbGV0ZV9icmFuY2hlcyhpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGludCBmb3JjZSwgaW50IGtpbmRzKQp7CglzdHJ1Y3QgY29tbWl0ICpyZXYsICpoZWFkX3JldiA9IE5VTEw7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJY2hhciAqbmFtZSA9IE5VTEw7Cgljb25zdCBjaGFyICpmbXQsICpyZW1vdGU7CglpbnQgaTsKCWludCByZXQgPSAwOwoJc3RydWN0IHN0cmJ1ZiBibmFtZSA9IFNUUkJVRl9JTklUOwoKCXN3aXRjaCAoa2luZHMpIHsKCWNhc2UgUkVGX1JFTU9URV9CUkFOQ0g6CgkJZm10ID0gInJlZnMvcmVtb3Rlcy8lcyI7CgkJLyogVFJBTlNMQVRPUlM6IFRoaXMgaXMgInJlbW90ZSAiIGluICJyZW1vdGUgYnJhbmNoICclcycgbm90IGZvdW5kIiAqLwoJCXJlbW90ZSA9IF8oInJlbW90ZSAiKTsKCQlmb3JjZSA9IDE7CgkJYnJlYWs7CgljYXNlIFJFRl9MT0NBTF9CUkFOQ0g6CgkJZm10ID0gInJlZnMvaGVhZHMvJXMiOwoJCXJlbW90ZSA9ICIiOwoJCWJyZWFrOwoJZGVmYXVsdDoKCQlkaWUoXygiY2Fubm90IHVzZSAtYSB3aXRoIC1kIikpOwoJfQoKCWlmICghZm9yY2UpIHsKCQloZWFkX3JldiA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlKGhlYWRfc2hhMSk7CgkJaWYgKCFoZWFkX3JldikKCQkJZGllKF8oIkNvdWxkbid0IGxvb2sgdXAgY29tbWl0IG9iamVjdCBmb3IgSEVBRCIpKTsKCX0KCWZvciAoaSA9IDA7IGkgPCBhcmdjOyBpKyssIHN0cmJ1Zl9yZWxlYXNlKCZibmFtZSkpIHsKCQlzdHJidWZfYnJhbmNobmFtZSgmYm5hbWUsIGFyZ3ZbaV0pOwoJCWlmIChraW5kcyA9PSBSRUZfTE9DQUxfQlJBTkNIICYmICFzdHJjbXAoaGVhZCwgYm5hbWUuYnVmKSkgewoJCQllcnJvcihfKCJDYW5ub3QgZGVsZXRlIHRoZSBicmFuY2ggJyVzJyAiCgkJCSAgICAgICJ3aGljaCB5b3UgYXJlIGN1cnJlbnRseSBvbi4iKSwgYm5hbWUuYnVmKTsKCQkJcmV0ID0gMTsKCQkJY29udGludWU7CgkJfQoKCQlmcmVlKG5hbWUpOwoKCQluYW1lID0geHN0cmR1cChta3BhdGgoZm10LCBibmFtZS5idWYpKTsKCQlpZiAoIXJlc29sdmVfcmVmKG5hbWUsIHNoYTEsIDEsIE5VTEwpKSB7CgkJCWVycm9yKF8oIiVzYnJhbmNoICclcycgbm90IGZvdW5kLiIpLAoJCQkJCXJlbW90ZSwgYm5hbWUuYnVmKTsKCQkJcmV0ID0gMTsKCQkJY29udGludWU7CgkJfQoKCQlyZXYgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZShzaGExKTsKCQlpZiAoIXJldikgewoJCQllcnJvcihfKCJDb3VsZG4ndCBsb29rIHVwIGNvbW1pdCBvYmplY3QgZm9yICclcyciKSwgbmFtZSk7CgkJCXJldCA9IDE7CgkJCWNvbnRpbnVlOwoJCX0KCgkJaWYgKCFmb3JjZSAmJiAhYnJhbmNoX21lcmdlZChraW5kcywgYm5hbWUuYnVmLCByZXYsIGhlYWRfcmV2KSkgewoJCQllcnJvcihfKCJUaGUgYnJhbmNoICclcycgaXMgbm90IGZ1bGx5IG1lcmdlZC5cbiIKCQkJICAgICAgIklmIHlvdSBhcmUgc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgaXQsICIKCQkJICAgICAgInJ1biAnZ2l0IGJyYW5jaCAtRCAlcycuIiksIGJuYW1lLmJ1ZiwgYm5hbWUuYnVmKTsKCQkJcmV0ID0gMTsKCQkJY29udGludWU7CgkJfQoKCQlpZiAoZGVsZXRlX3JlZihuYW1lLCBzaGExLCAwKSkgewoJCQllcnJvcihfKCJFcnJvciBkZWxldGluZyAlc2JyYW5jaCAnJXMnIiksIHJlbW90ZSwKCQkJICAgICAgYm5hbWUuYnVmKTsKCQkJcmV0ID0gMTsKCQl9IGVsc2UgewoJCQlzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJCQlwcmludGYoXygiRGVsZXRlZCAlc2JyYW5jaCAlcyAod2FzICVzKS5cbiIpLCByZW1vdGUsCgkJCSAgICAgICBibmFtZS5idWYsCgkJCSAgICAgICBmaW5kX3VuaXF1ZV9hYmJyZXYoc2hhMSwgREVGQVVMVF9BQkJSRVYpKTsKCQkJc3RyYnVmX2FkZGYoJmJ1ZiwgImJyYW5jaC4lcyIsIGJuYW1lLmJ1Zik7CgkJCWlmIChnaXRfY29uZmlnX3JlbmFtZV9zZWN0aW9uKGJ1Zi5idWYsIE5VTEwpIDwgMCkKCQkJCXdhcm5pbmcoXygiVXBkYXRlIG9mIGNvbmZpZy1maWxlIGZhaWxlZCIpKTsKCQkJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CgkJfQoJfQoKCWZyZWUobmFtZSk7CgoJcmV0dXJuKHJldCk7Cn0KCnN0cnVjdCByZWZfaXRlbSB7CgljaGFyICpuYW1lOwoJY2hhciAqZGVzdDsKCXVuc2lnbmVkIGludCBraW5kLCBsZW47CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7Cn07CgpzdHJ1Y3QgcmVmX2xpc3QgewoJc3RydWN0IHJldl9pbmZvIHJldnM7CglpbnQgaW5kZXgsIGFsbG9jLCBtYXh3aWR0aCwgdmVyYm9zZSwgYWJicmV2OwoJc3RydWN0IHJlZl9pdGVtICpsaXN0OwoJc3RydWN0IGNvbW1pdF9saXN0ICp3aXRoX2NvbW1pdDsKCWludCBraW5kczsKfTsKCnN0YXRpYyBjaGFyICpyZXNvbHZlX3N5bXJlZihjb25zdCBjaGFyICpzcmMsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCWludCBmbGFnOwoJY29uc3QgY2hhciAqZHN0LCAqY3A7CgoJZHN0ID0gcmVzb2x2ZV9yZWYoc3JjLCBzaGExLCAwLCAmZmxhZyk7CglpZiAoIShkc3QgJiYgKGZsYWcgJiBSRUZfSVNTWU1SRUYpKSkKCQlyZXR1cm4gTlVMTDsKCWlmIChwcmVmaXggJiYgKGNwID0gc2tpcF9wcmVmaXgoZHN0LCBwcmVmaXgpKSkKCQlkc3QgPSBjcDsKCXJldHVybiB4c3RyZHVwKGRzdCk7Cn0KCnN0cnVjdCBhcHBlbmRfcmVmX2NiIHsKCXN0cnVjdCByZWZfbGlzdCAqcmVmX2xpc3Q7Cgljb25zdCBjaGFyICoqcGF0dGVybjsKCWludCByZXQ7Cn07CgpzdGF0aWMgaW50IG1hdGNoX3BhdHRlcm5zKGNvbnN0IGNoYXIgKipwYXR0ZXJuLCBjb25zdCBjaGFyICpyZWZuYW1lKQp7CglpZiAoISpwYXR0ZXJuKQoJCXJldHVybiAxOyAvKiBubyBwYXR0ZXJuIGFsd2F5cyBtYXRjaGVzICovCgl3aGlsZSAoKnBhdHRlcm4pIHsKCQlpZiAoIWZubWF0Y2goKnBhdHRlcm4sIHJlZm5hbWUsIDApKQoJCQlyZXR1cm4gMTsKCQlwYXR0ZXJuKys7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBhcHBlbmRfcmVmKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIGludCBmbGFncywgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IGFwcGVuZF9yZWZfY2IgKmNiID0gKHN0cnVjdCBhcHBlbmRfcmVmX2NiICopKGNiX2RhdGEpOwoJc3RydWN0IHJlZl9saXN0ICpyZWZfbGlzdCA9IGNiLT5yZWZfbGlzdDsKCXN0cnVjdCByZWZfaXRlbSAqbmV3aXRlbTsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCWludCBraW5kLCBpOwoJY29uc3QgY2hhciAqcHJlZml4LCAqb3JpZ19yZWZuYW1lID0gcmVmbmFtZTsKCglzdGF0aWMgc3RydWN0IHsKCQlpbnQga2luZDsKCQljb25zdCBjaGFyICpwcmVmaXg7CgkJaW50IHBmeGxlbjsKCX0gcmVmX2tpbmRbXSA9IHsKCQl7IFJFRl9MT0NBTF9CUkFOQ0gsICJyZWZzL2hlYWRzLyIsIDExIH0sCgkJeyBSRUZfUkVNT1RFX0JSQU5DSCwgInJlZnMvcmVtb3Rlcy8iLCAxMyB9LAoJfTsKCgkvKiBEZXRlY3Qga2luZCAqLwoJZm9yIChpID0gMDsgaSA8IEFSUkFZX1NJWkUocmVmX2tpbmQpOyBpKyspIHsKCQlwcmVmaXggPSByZWZfa2luZFtpXS5wcmVmaXg7CgkJaWYgKHN0cm5jbXAocmVmbmFtZSwgcHJlZml4LCByZWZfa2luZFtpXS5wZnhsZW4pKQoJCQljb250aW51ZTsKCQlraW5kID0gcmVmX2tpbmRbaV0ua2luZDsKCQlyZWZuYW1lICs9IHJlZl9raW5kW2ldLnBmeGxlbjsKCQlicmVhazsKCX0KCWlmIChBUlJBWV9TSVpFKHJlZl9raW5kKSA8PSBpKQoJCXJldHVybiAwOwoKCS8qIERvbid0IGFkZCB0eXBlcyB0aGUgY2FsbGVyIGRvZXNuJ3Qgd2FudCAqLwoJaWYgKChraW5kICYgcmVmX2xpc3QtPmtpbmRzKSA9PSAwKQoJCXJldHVybiAwOwoKCWlmICghbWF0Y2hfcGF0dGVybnMoY2ItPnBhdHRlcm4sIHJlZm5hbWUpKQoJCXJldHVybiAwOwoKCWNvbW1pdCA9IE5VTEw7CglpZiAocmVmX2xpc3QtPnZlcmJvc2UgfHwgcmVmX2xpc3QtPndpdGhfY29tbWl0IHx8IG1lcmdlX2ZpbHRlciAhPSBOT19GSUxURVIpIHsKCQljb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkoc2hhMSwgMSk7CgkJaWYgKCFjb21taXQpIHsKCQkJY2ItPnJldCA9IGVycm9yKF8oImJyYW5jaCAnJXMnIGRvZXMgbm90IHBvaW50IGF0IGEgY29tbWl0IiksIHJlZm5hbWUpOwoJCQlyZXR1cm4gMDsKCQl9CgoJCS8qIEZpbHRlciB3aXRoIHdpdGhfY29tbWl0IGlmIHNwZWNpZmllZCAqLwoJCWlmICghaXNfZGVzY2VuZGFudF9vZihjb21taXQsIHJlZl9saXN0LT53aXRoX2NvbW1pdCkpCgkJCXJldHVybiAwOwoKCQlpZiAobWVyZ2VfZmlsdGVyICE9IE5PX0ZJTFRFUikKCQkJYWRkX3BlbmRpbmdfb2JqZWN0KCZyZWZfbGlzdC0+cmV2cywKCQkJCQkgICAoc3RydWN0IG9iamVjdCAqKWNvbW1pdCwgcmVmbmFtZSk7Cgl9CgoJQUxMT0NfR1JPVyhyZWZfbGlzdC0+bGlzdCwgcmVmX2xpc3QtPmluZGV4ICsgMSwgcmVmX2xpc3QtPmFsbG9jKTsKCgkvKiBSZWNvcmQgdGhlIG5ldyBpdGVtICovCgluZXdpdGVtID0gJihyZWZfbGlzdC0+bGlzdFtyZWZfbGlzdC0+aW5kZXgrK10pOwoJbmV3aXRlbS0+bmFtZSA9IHhzdHJkdXAocmVmbmFtZSk7CgluZXdpdGVtLT5raW5kID0ga2luZDsKCW5ld2l0ZW0tPmNvbW1pdCA9IGNvbW1pdDsKCW5ld2l0ZW0tPmxlbiA9IHN0cmxlbihyZWZuYW1lKTsKCW5ld2l0ZW0tPmRlc3QgPSByZXNvbHZlX3N5bXJlZihvcmlnX3JlZm5hbWUsIHByZWZpeCk7CgkvKiBhZGp1c3QgZm9yICJyZW1vdGVzLyIgKi8KCWlmIChuZXdpdGVtLT5raW5kID09IFJFRl9SRU1PVEVfQlJBTkNIICYmCgkgICAgcmVmX2xpc3QtPmtpbmRzICE9IFJFRl9SRU1PVEVfQlJBTkNIKQoJCW5ld2l0ZW0tPmxlbiArPSA4OwoJaWYgKG5ld2l0ZW0tPmxlbiA+IHJlZl9saXN0LT5tYXh3aWR0aCkKCQlyZWZfbGlzdC0+bWF4d2lkdGggPSBuZXdpdGVtLT5sZW47CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGZyZWVfcmVmX2xpc3Qoc3RydWN0IHJlZl9saXN0ICpyZWZfbGlzdCkKewoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IHJlZl9saXN0LT5pbmRleDsgaSsrKSB7CgkJZnJlZShyZWZfbGlzdC0+bGlzdFtpXS5uYW1lKTsKCQlmcmVlKHJlZl9saXN0LT5saXN0W2ldLmRlc3QpOwoJfQoJZnJlZShyZWZfbGlzdC0+bGlzdCk7Cn0KCnN0YXRpYyBpbnQgcmVmX2NtcChjb25zdCB2b2lkICpyMSwgY29uc3Qgdm9pZCAqcjIpCnsKCXN0cnVjdCByZWZfaXRlbSAqYzEgPSAoc3RydWN0IHJlZl9pdGVtICopKHIxKTsKCXN0cnVjdCByZWZfaXRlbSAqYzIgPSAoc3RydWN0IHJlZl9pdGVtICopKHIyKTsKCglpZiAoYzEtPmtpbmQgIT0gYzItPmtpbmQpCgkJcmV0dXJuIGMxLT5raW5kIC0gYzItPmtpbmQ7CglyZXR1cm4gc3RyY21wKGMxLT5uYW1lLCBjMi0+bmFtZSk7Cn0KCnN0YXRpYyB2b2lkIGZpbGxfdHJhY2tpbmdfaW5mbyhzdHJ1Y3Qgc3RyYnVmICpzdGF0LCBjb25zdCBjaGFyICpicmFuY2hfbmFtZSwKCQlpbnQgc2hvd191cHN0cmVhbV9yZWYpCnsKCWludCBvdXJzLCB0aGVpcnM7CglzdHJ1Y3QgYnJhbmNoICpicmFuY2ggPSBicmFuY2hfZ2V0KGJyYW5jaF9uYW1lKTsKCglpZiAoIXN0YXRfdHJhY2tpbmdfaW5mbyhicmFuY2gsICZvdXJzLCAmdGhlaXJzKSkgewoJCWlmIChicmFuY2ggJiYgYnJhbmNoLT5tZXJnZSAmJiBicmFuY2gtPm1lcmdlWzBdLT5kc3QgJiYKCQkgICAgc2hvd191cHN0cmVhbV9yZWYpCgkJCXN0cmJ1Zl9hZGRmKHN0YXQsICJbJXNdICIsCgkJCSAgICBzaG9ydGVuX3VuYW1iaWd1b3VzX3JlZihicmFuY2gtPm1lcmdlWzBdLT5kc3QsIDApKTsKCQlyZXR1cm47Cgl9CgoJc3RyYnVmX2FkZGNoKHN0YXQsICdbJyk7CglpZiAoc2hvd191cHN0cmVhbV9yZWYpCgkJc3RyYnVmX2FkZGYoc3RhdCwgIiVzOiAiLAoJCQlzaG9ydGVuX3VuYW1iaWd1b3VzX3JlZihicmFuY2gtPm1lcmdlWzBdLT5kc3QsIDApKTsKCWlmICghb3VycykKCQlzdHJidWZfYWRkZihzdGF0LCBfKCJiZWhpbmQgJWRdICIpLCB0aGVpcnMpOwoJZWxzZSBpZiAoIXRoZWlycykKCQlzdHJidWZfYWRkZihzdGF0LCBfKCJhaGVhZCAlZF0gIiksIG91cnMpOwoJZWxzZQoJCXN0cmJ1Zl9hZGRmKHN0YXQsIF8oImFoZWFkICVkLCBiZWhpbmQgJWRdICIpLCBvdXJzLCB0aGVpcnMpOwp9CgpzdGF0aWMgaW50IG1hdGNoZXNfbWVyZ2VfZmlsdGVyKHN0cnVjdCBjb21taXQgKmNvbW1pdCkKewoJaW50IGlzX21lcmdlZDsKCglpZiAobWVyZ2VfZmlsdGVyID09IE5PX0ZJTFRFUikKCQlyZXR1cm4gMTsKCglpc19tZXJnZWQgPSAhIShjb21taXQtPm9iamVjdC5mbGFncyAmIFVOSU5URVJFU1RJTkcpOwoJcmV0dXJuIChpc19tZXJnZWQgPT0gKG1lcmdlX2ZpbHRlciA9PSBTSE9XX01FUkdFRCkpOwp9CgpzdGF0aWMgdm9pZCBhZGRfdmVyYm9zZV9pbmZvKHN0cnVjdCBzdHJidWYgKm91dCwgc3RydWN0IHJlZl9pdGVtICppdGVtLAoJCQkgICAgIGludCB2ZXJib3NlLCBpbnQgYWJicmV2KQp7CglzdHJ1Y3Qgc3RyYnVmIHN1YmplY3QgPSBTVFJCVUZfSU5JVCwgc3RhdCA9IFNUUkJVRl9JTklUOwoJY29uc3QgY2hhciAqc3ViID0gIiAqKioqIGludmFsaWQgcmVmICoqKioiOwoJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gaXRlbS0+Y29tbWl0OwoKCWlmIChjb21taXQgJiYgIXBhcnNlX2NvbW1pdChjb21taXQpKSB7CgkJcHBfY29tbWl0X2Vhc3koQ01JVF9GTVRfT05FTElORSwgY29tbWl0LCAmc3ViamVjdCk7CgkJc3ViID0gc3ViamVjdC5idWY7Cgl9CgoJaWYgKGl0ZW0tPmtpbmQgPT0gUkVGX0xPQ0FMX0JSQU5DSCkKCQlmaWxsX3RyYWNraW5nX2luZm8oJnN0YXQsIGl0ZW0tPm5hbWUsIHZlcmJvc2UgPiAxKTsKCglzdHJidWZfYWRkZihvdXQsICIgJXMgJXMlcyIsCgkJZmluZF91bmlxdWVfYWJicmV2KGl0ZW0tPmNvbW1pdC0+b2JqZWN0LnNoYTEsIGFiYnJldiksCgkJc3RhdC5idWYsIHN1Yik7CglzdHJidWZfcmVsZWFzZSgmc3RhdCk7CglzdHJidWZfcmVsZWFzZSgmc3ViamVjdCk7Cn0KCnN0YXRpYyB2b2lkIHByaW50X3JlZl9pdGVtKHN0cnVjdCByZWZfaXRlbSAqaXRlbSwgaW50IG1heHdpZHRoLCBpbnQgdmVyYm9zZSwKCQkJICAgaW50IGFiYnJldiwgaW50IGN1cnJlbnQsIGNoYXIgKnByZWZpeCkKewoJY2hhciBjOwoJaW50IGNvbG9yOwoJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gaXRlbS0+Y29tbWl0OwoJc3RydWN0IHN0cmJ1ZiBvdXQgPSBTVFJCVUZfSU5JVCwgbmFtZSA9IFNUUkJVRl9JTklUOwoKCWlmICghbWF0Y2hlc19tZXJnZV9maWx0ZXIoY29tbWl0KSkKCQlyZXR1cm47CgoJc3dpdGNoIChpdGVtLT5raW5kKSB7CgljYXNlIFJFRl9MT0NBTF9CUkFOQ0g6CgkJY29sb3IgPSBCUkFOQ0hfQ09MT1JfTE9DQUw7CgkJYnJlYWs7CgljYXNlIFJFRl9SRU1PVEVfQlJBTkNIOgoJCWNvbG9yID0gQlJBTkNIX0NPTE9SX1JFTU9URTsKCQlicmVhazsKCWRlZmF1bHQ6CgkJY29sb3IgPSBCUkFOQ0hfQ09MT1JfUExBSU47CgkJYnJlYWs7Cgl9CgoJYyA9ICcgJzsKCWlmIChjdXJyZW50KSB7CgkJYyA9ICcqJzsKCQljb2xvciA9IEJSQU5DSF9DT0xPUl9DVVJSRU5UOwoJfQoKCXN0cmJ1Zl9hZGRmKCZuYW1lLCAiJXMlcyIsIHByZWZpeCwgaXRlbS0+bmFtZSk7CglpZiAodmVyYm9zZSkKCQlzdHJidWZfYWRkZigmb3V0LCAiJWMgJXMlLSpzJXMiLCBjLCBicmFuY2hfZ2V0X2NvbG9yKGNvbG9yKSwKCQkJICAgIG1heHdpZHRoLCBuYW1lLmJ1ZiwKCQkJICAgIGJyYW5jaF9nZXRfY29sb3IoQlJBTkNIX0NPTE9SX1JFU0VUKSk7CgllbHNlCgkJc3RyYnVmX2FkZGYoJm91dCwgIiVjICVzJXMlcyIsIGMsIGJyYW5jaF9nZXRfY29sb3IoY29sb3IpLAoJCQkgICAgbmFtZS5idWYsIGJyYW5jaF9nZXRfY29sb3IoQlJBTkNIX0NPTE9SX1JFU0VUKSk7CgoJaWYgKGl0ZW0tPmRlc3QpCgkJc3RyYnVmX2FkZGYoJm91dCwgIiAtPiAlcyIsIGl0ZW0tPmRlc3QpOwoJZWxzZSBpZiAodmVyYm9zZSkKCQkvKiAiIGY3YzBjMDAgW2FoZWFkIDU4LCBiZWhpbmQgMTk3XSB2Y3Mtc3ZuOiBkcm9wIG9ial9wb29sLmgiICovCgkJYWRkX3ZlcmJvc2VfaW5mbygmb3V0LCBpdGVtLCB2ZXJib3NlLCBhYmJyZXYpOwoJcHJpbnRmKCIlc1xuIiwgb3V0LmJ1Zik7CglzdHJidWZfcmVsZWFzZSgmbmFtZSk7CglzdHJidWZfcmVsZWFzZSgmb3V0KTsKfQoKc3RhdGljIGludCBjYWxjX21heHdpZHRoKHN0cnVjdCByZWZfbGlzdCAqcmVmcykKewoJaW50IGksIHcgPSAwOwoJZm9yIChpID0gMDsgaSA8IHJlZnMtPmluZGV4OyBpKyspIHsKCQlpZiAoIW1hdGNoZXNfbWVyZ2VfZmlsdGVyKHJlZnMtPmxpc3RbaV0uY29tbWl0KSkKCQkJY29udGludWU7CgkJaWYgKHJlZnMtPmxpc3RbaV0ubGVuID4gdykKCQkJdyA9IHJlZnMtPmxpc3RbaV0ubGVuOwoJfQoJcmV0dXJuIHc7Cn0KCgpzdGF0aWMgdm9pZCBzaG93X2RldGFjaGVkKHN0cnVjdCByZWZfbGlzdCAqcmVmX2xpc3QpCnsKCXN0cnVjdCBjb21taXQgKmhlYWRfY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfZ2VudGx5KGhlYWRfc2hhMSwgMSk7CgoJaWYgKGhlYWRfY29tbWl0ICYmIGlzX2Rlc2NlbmRhbnRfb2YoaGVhZF9jb21taXQsIHJlZl9saXN0LT53aXRoX2NvbW1pdCkpIHsKCQlzdHJ1Y3QgcmVmX2l0ZW0gaXRlbTsKCQlpdGVtLm5hbWUgPSB4c3RyZHVwKF8oIihubyBicmFuY2gpIikpOwoJCWl0ZW0ubGVuID0gc3RybGVuKGl0ZW0ubmFtZSk7CgkJaXRlbS5raW5kID0gUkVGX0xPQ0FMX0JSQU5DSDsKCQlpdGVtLmRlc3QgPSBOVUxMOwoJCWl0ZW0uY29tbWl0ID0gaGVhZF9jb21taXQ7CgkJaWYgKGl0ZW0ubGVuID4gcmVmX2xpc3QtPm1heHdpZHRoKQoJCQlyZWZfbGlzdC0+bWF4d2lkdGggPSBpdGVtLmxlbjsKCQlwcmludF9yZWZfaXRlbSgmaXRlbSwgcmVmX2xpc3QtPm1heHdpZHRoLCByZWZfbGlzdC0+dmVyYm9zZSwgcmVmX2xpc3QtPmFiYnJldiwgMSwgIiIpOwoJCWZyZWUoaXRlbS5uYW1lKTsKCX0KfQoKc3RhdGljIGludCBwcmludF9yZWZfbGlzdChpbnQga2luZHMsIGludCBkZXRhY2hlZCwgaW50IHZlcmJvc2UsIGludCBhYmJyZXYsIHN0cnVjdCBjb21taXRfbGlzdCAqd2l0aF9jb21taXQsIGNvbnN0IGNoYXIgKipwYXR0ZXJuKQp7CglpbnQgaTsKCXN0cnVjdCBhcHBlbmRfcmVmX2NiIGNiOwoJc3RydWN0IHJlZl9saXN0IHJlZl9saXN0OwoKCW1lbXNldCgmcmVmX2xpc3QsIDAsIHNpemVvZihyZWZfbGlzdCkpOwoJcmVmX2xpc3Qua2luZHMgPSBraW5kczsKCXJlZl9saXN0LnZlcmJvc2UgPSB2ZXJib3NlOwoJcmVmX2xpc3QuYWJicmV2ID0gYWJicmV2OwoJcmVmX2xpc3Qud2l0aF9jb21taXQgPSB3aXRoX2NvbW1pdDsKCWlmIChtZXJnZV9maWx0ZXIgIT0gTk9fRklMVEVSKQoJCWluaXRfcmV2aXNpb25zKCZyZWZfbGlzdC5yZXZzLCBOVUxMKTsKCWNiLnJlZl9saXN0ID0gJnJlZl9saXN0OwoJY2IucGF0dGVybiA9IHBhdHRlcm47CgljYi5yZXQgPSAwOwoJZm9yX2VhY2hfcmF3cmVmKGFwcGVuZF9yZWYsICZjYik7CglpZiAobWVyZ2VfZmlsdGVyICE9IE5PX0ZJTFRFUikgewoJCXN0cnVjdCBjb21taXQgKmZpbHRlcjsKCQlmaWx0ZXIgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkobWVyZ2VfZmlsdGVyX3JlZiwgMCk7CgkJZmlsdGVyLT5vYmplY3QuZmxhZ3MgfD0gVU5JTlRFUkVTVElORzsKCQlhZGRfcGVuZGluZ19vYmplY3QoJnJlZl9saXN0LnJldnMsCgkJCQkgICAoc3RydWN0IG9iamVjdCAqKSBmaWx0ZXIsICIiKTsKCQlyZWZfbGlzdC5yZXZzLmxpbWl0ZWQgPSAxOwoJCXByZXBhcmVfcmV2aXNpb25fd2FsaygmcmVmX2xpc3QucmV2cyk7CgkJaWYgKHZlcmJvc2UpCgkJCXJlZl9saXN0Lm1heHdpZHRoID0gY2FsY19tYXh3aWR0aCgmcmVmX2xpc3QpOwoJfQoKCXFzb3J0KHJlZl9saXN0Lmxpc3QsIHJlZl9saXN0LmluZGV4LCBzaXplb2Yoc3RydWN0IHJlZl9pdGVtKSwgcmVmX2NtcCk7CgoJZGV0YWNoZWQgPSAoZGV0YWNoZWQgJiYgKGtpbmRzICYgUkVGX0xPQ0FMX0JSQU5DSCkpOwoJaWYgKGRldGFjaGVkICYmIG1hdGNoX3BhdHRlcm5zKHBhdHRlcm4sICJIRUFEIikpCgkJc2hvd19kZXRhY2hlZCgmcmVmX2xpc3QpOwoKCWZvciAoaSA9IDA7IGkgPCByZWZfbGlzdC5pbmRleDsgaSsrKSB7CgkJaW50IGN1cnJlbnQgPSAhZGV0YWNoZWQgJiYKCQkJKHJlZl9saXN0Lmxpc3RbaV0ua2luZCA9PSBSRUZfTE9DQUxfQlJBTkNIKSAmJgoJCQkhc3RyY21wKHJlZl9saXN0Lmxpc3RbaV0ubmFtZSwgaGVhZCk7CgkJY2hhciAqcHJlZml4ID0gKGtpbmRzICE9IFJFRl9SRU1PVEVfQlJBTkNIICYmCgkJCQlyZWZfbGlzdC5saXN0W2ldLmtpbmQgPT0gUkVGX1JFTU9URV9CUkFOQ0gpCgkJCQk/ICJyZW1vdGVzLyIgOiAiIjsKCQlwcmludF9yZWZfaXRlbSgmcmVmX2xpc3QubGlzdFtpXSwgcmVmX2xpc3QubWF4d2lkdGgsIHZlcmJvc2UsCgkJCSAgICAgICBhYmJyZXYsIGN1cnJlbnQsIHByZWZpeCk7Cgl9CgoJZnJlZV9yZWZfbGlzdCgmcmVmX2xpc3QpOwoKCWlmIChjYi5yZXQpCgkJZXJyb3IoXygic29tZSByZWZzIGNvdWxkIG5vdCBiZSByZWFkIikpOwoKCXJldHVybiBjYi5yZXQ7Cn0KCnN0YXRpYyB2b2lkIHJlbmFtZV9icmFuY2goY29uc3QgY2hhciAqb2xkbmFtZSwgY29uc3QgY2hhciAqbmV3bmFtZSwgaW50IGZvcmNlKQp7CglzdHJ1Y3Qgc3RyYnVmIG9sZHJlZiA9IFNUUkJVRl9JTklULCBuZXdyZWYgPSBTVFJCVUZfSU5JVCwgbG9nbXNnID0gU1RSQlVGX0lOSVQ7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJc3RydWN0IHN0cmJ1ZiBvbGRzZWN0aW9uID0gU1RSQlVGX0lOSVQsIG5ld3NlY3Rpb24gPSBTVFJCVUZfSU5JVDsKCWludCByZWNvdmVyeSA9IDA7CgoJaWYgKCFvbGRuYW1lKQoJCWRpZShfKCJjYW5ub3QgcmVuYW1lIHRoZSBjdXJyZW50IGJyYW5jaCB3aGlsZSBub3Qgb24gYW55LiIpKTsKCglpZiAoc3RyYnVmX2NoZWNrX2JyYW5jaF9yZWYoJm9sZHJlZiwgb2xkbmFtZSkpIHsKCQkvKgoJCSAqIEJhZCBuYW1lIC0tLSB0aGlzIGNvdWxkIGJlIGFuIGF0dGVtcHQgdG8gcmVuYW1lIGEKCQkgKiByZWYgdGhhdCB3ZSB1c2VkIHRvIGFsbG93IHRvIGJlIGNyZWF0ZWQgYnkgYWNjaWRlbnQuCgkJICovCgkJaWYgKHJlc29sdmVfcmVmKG9sZHJlZi5idWYsIHNoYTEsIDEsIE5VTEwpKQoJCQlyZWNvdmVyeSA9IDE7CgkJZWxzZQoJCQlkaWUoXygiSW52YWxpZCBicmFuY2ggbmFtZTogJyVzJyIpLCBvbGRuYW1lKTsKCX0KCgl2YWxpZGF0ZV9uZXdfYnJhbmNobmFtZShuZXduYW1lLCAmbmV3cmVmLCBmb3JjZSwgMCk7CgoJc3RyYnVmX2FkZGYoJmxvZ21zZywgIkJyYW5jaDogcmVuYW1lZCAlcyB0byAlcyIsCgkJIG9sZHJlZi5idWYsIG5ld3JlZi5idWYpOwoKCWlmIChyZW5hbWVfcmVmKG9sZHJlZi5idWYsIG5ld3JlZi5idWYsIGxvZ21zZy5idWYpKQoJCWRpZShfKCJCcmFuY2ggcmVuYW1lIGZhaWxlZCIpKTsKCXN0cmJ1Zl9yZWxlYXNlKCZsb2dtc2cpOwoKCWlmIChyZWNvdmVyeSkKCQl3YXJuaW5nKF8oIlJlbmFtZWQgYSBtaXNuYW1lZCBicmFuY2ggJyVzJyBhd2F5IiksIG9sZHJlZi5idWYgKyAxMSk7CgoJLyogbm8gbmVlZCB0byBwYXNzIGxvZ21zZyBoZXJlIGFzIEhFQUQgZGlkbid0IHJlYWxseSBtb3ZlICovCglpZiAoIXN0cmNtcChvbGRuYW1lLCBoZWFkKSAmJiBjcmVhdGVfc3ltcmVmKCJIRUFEIiwgbmV3cmVmLmJ1ZiwgTlVMTCkpCgkJZGllKF8oIkJyYW5jaCByZW5hbWVkIHRvICVzLCBidXQgSEVBRCBpcyBub3QgdXBkYXRlZCEiKSwgbmV3bmFtZSk7CgoJc3RyYnVmX2FkZGYoJm9sZHNlY3Rpb24sICJicmFuY2guJXMiLCBvbGRyZWYuYnVmICsgMTEpOwoJc3RyYnVmX3JlbGVhc2UoJm9sZHJlZik7CglzdHJidWZfYWRkZigmbmV3c2VjdGlvbiwgImJyYW5jaC4lcyIsIG5ld3JlZi5idWYgKyAxMSk7CglzdHJidWZfcmVsZWFzZSgmbmV3cmVmKTsKCWlmIChnaXRfY29uZmlnX3JlbmFtZV9zZWN0aW9uKG9sZHNlY3Rpb24uYnVmLCBuZXdzZWN0aW9uLmJ1ZikgPCAwKQoJCWRpZShfKCJCcmFuY2ggaXMgcmVuYW1lZCwgYnV0IHVwZGF0ZSBvZiBjb25maWctZmlsZSBmYWlsZWQiKSk7CglzdHJidWZfcmVsZWFzZSgmb2xkc2VjdGlvbik7CglzdHJidWZfcmVsZWFzZSgmbmV3c2VjdGlvbik7Cn0KCnN0YXRpYyBpbnQgb3B0X3BhcnNlX21lcmdlX2ZpbHRlcihjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CgltZXJnZV9maWx0ZXIgPSAoKG9wdC0+bG9uZ19uYW1lWzBdID09ICduJykKCQkJPyBTSE9XX05PVF9NRVJHRUQKCQkJOiBTSE9XX01FUkdFRCk7CglpZiAodW5zZXQpCgkJbWVyZ2VfZmlsdGVyID0gU0hPV19OT1RfTUVSR0VEOyAvKiBiL2MgZm9yIC0tbm8tbWVyZ2VkICovCglpZiAoIWFyZykKCQlhcmcgPSAiSEVBRCI7CglpZiAoZ2V0X3NoYTEoYXJnLCBtZXJnZV9maWx0ZXJfcmVmKSkKCQlkaWUoXygibWFsZm9ybWVkIG9iamVjdCBuYW1lICVzIiksIGFyZyk7CglyZXR1cm4gMDsKfQoKaW50IGNtZF9icmFuY2goaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCWludCBkZWxldGUgPSAwLCByZW5hbWUgPSAwLCBmb3JjZV9jcmVhdGUgPSAwLCBsaXN0ID0gMDsKCWludCB2ZXJib3NlID0gMCwgYWJicmV2ID0gLTEsIGRldGFjaGVkID0gMDsKCWludCByZWZsb2cgPSAwOwoJZW51bSBicmFuY2hfdHJhY2sgdHJhY2s7CglpbnQga2luZHMgPSBSRUZfTE9DQUxfQlJBTkNIOwoJc3RydWN0IGNvbW1pdF9saXN0ICp3aXRoX2NvbW1pdCA9IE5VTEw7CgoJc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJT1BUX0dST1VQKCJHZW5lcmljIG9wdGlvbnMiKSwKCQlPUFRfX1ZFUkJPU0UoJnZlcmJvc2UsCgkJCSJzaG93IGhhc2ggYW5kIHN1YmplY3QsIGdpdmUgdHdpY2UgZm9yIHVwc3RyZWFtIGJyYW5jaCIpLAoJCU9QVF9TRVRfSU5UKCd0JywgInRyYWNrIiwgICZ0cmFjaywgInNldCB1cCB0cmFja2luZyBtb2RlIChzZWUgZ2l0LXB1bGwoMSkpIiwKCQkJQlJBTkNIX1RSQUNLX0VYUExJQ0lUKSwKCQlPUFRfU0VUX0lOVCggMCwgInNldC11cHN0cmVhbSIsICAmdHJhY2ssICJjaGFuZ2UgdXBzdHJlYW0gaW5mbyIsCgkJCUJSQU5DSF9UUkFDS19PVkVSUklERSksCgkJT1BUX19DT0xPUigmYnJhbmNoX3VzZV9jb2xvciwgInVzZSBjb2xvcmVkIG91dHB1dCIpLAoJCU9QVF9TRVRfSU5UKCdyJywgInJlbW90ZXMiLCAgICAgJmtpbmRzLCAiYWN0IG9uIHJlbW90ZS10cmFja2luZyBicmFuY2hlcyIsCgkJCVJFRl9SRU1PVEVfQlJBTkNIKSwKCQl7CgkJCU9QVElPTl9DQUxMQkFDSywgMCwgImNvbnRhaW5zIiwgJndpdGhfY29tbWl0LCAiY29tbWl0IiwKCQkJInByaW50IG9ubHkgYnJhbmNoZXMgdGhhdCBjb250YWluIHRoZSBjb21taXQiLAoJCQlQQVJTRV9PUFRfTEFTVEFSR19ERUZBVUxULAoJCQlwYXJzZV9vcHRfd2l0aF9jb21taXQsIChpbnRwdHJfdCkiSEVBRCIsCgkJfSwKCQl7CgkJCU9QVElPTl9DQUxMQkFDSywgMCwgIndpdGgiLCAmd2l0aF9jb21taXQsICJjb21taXQiLAoJCQkicHJpbnQgb25seSBicmFuY2hlcyB0aGF0IGNvbnRhaW4gdGhlIGNvbW1pdCIsCgkJCVBBUlNFX09QVF9ISURERU4gfCBQQVJTRV9PUFRfTEFTVEFSR19ERUZBVUxULAoJCQlwYXJzZV9vcHRfd2l0aF9jb21taXQsIChpbnRwdHJfdCkgIkhFQUQiLAoJCX0sCgkJT1BUX19BQkJSRVYoJmFiYnJldiksCgoJCU9QVF9HUk9VUCgiU3BlY2lmaWMgZ2l0LWJyYW5jaCBhY3Rpb25zOiIpLAoJCU9QVF9TRVRfSU5UKCdhJywgImFsbCIsICZraW5kcywgImxpc3QgYm90aCByZW1vdGUtdHJhY2tpbmcgYW5kIGxvY2FsIGJyYW5jaGVzIiwKCQkJUkVGX1JFTU9URV9CUkFOQ0ggfCBSRUZfTE9DQUxfQlJBTkNIKSwKCQlPUFRfQklUKCdkJywgImRlbGV0ZSIsICZkZWxldGUsICJkZWxldGUgZnVsbHkgbWVyZ2VkIGJyYW5jaCIsIDEpLAoJCU9QVF9CSVQoJ0QnLCBOVUxMLCAmZGVsZXRlLCAiZGVsZXRlIGJyYW5jaCAoZXZlbiBpZiBub3QgbWVyZ2VkKSIsIDIpLAoJCU9QVF9CSVQoJ20nLCAibW92ZSIsICZyZW5hbWUsICJtb3ZlL3JlbmFtZSBhIGJyYW5jaCBhbmQgaXRzIHJlZmxvZyIsIDEpLAoJCU9QVF9CSVQoJ00nLCBOVUxMLCAmcmVuYW1lLCAibW92ZS9yZW5hbWUgYSBicmFuY2gsIGV2ZW4gaWYgdGFyZ2V0IGV4aXN0cyIsIDIpLAoJCU9QVF9CT09MRUFOKDAsICJsaXN0IiwgJmxpc3QsICJsaXN0IGJyYW5jaCBuYW1lcyIpLAoJCU9QVF9CT09MRUFOKCdsJywgImNyZWF0ZS1yZWZsb2ciLCAmcmVmbG9nLCAiY3JlYXRlIHRoZSBicmFuY2gncyByZWZsb2ciKSwKCQlPUFRfX0ZPUkNFKCZmb3JjZV9jcmVhdGUsICJmb3JjZSBjcmVhdGlvbiAod2hlbiBhbHJlYWR5IGV4aXN0cykiKSwKCQl7CgkJCU9QVElPTl9DQUxMQkFDSywgMCwgIm5vLW1lcmdlZCIsICZtZXJnZV9maWx0ZXJfcmVmLAoJCQkiY29tbWl0IiwgInByaW50IG9ubHkgbm90IG1lcmdlZCBicmFuY2hlcyIsCgkJCVBBUlNFX09QVF9MQVNUQVJHX0RFRkFVTFQgfCBQQVJTRV9PUFRfTk9ORUcsCgkJCW9wdF9wYXJzZV9tZXJnZV9maWx0ZXIsIChpbnRwdHJfdCkgIkhFQUQiLAoJCX0sCgkJewoJCQlPUFRJT05fQ0FMTEJBQ0ssIDAsICJtZXJnZWQiLCAmbWVyZ2VfZmlsdGVyX3JlZiwKCQkJImNvbW1pdCIsICJwcmludCBvbmx5IG1lcmdlZCBicmFuY2hlcyIsCgkJCVBBUlNFX09QVF9MQVNUQVJHX0RFRkFVTFQgfCBQQVJTRV9PUFRfTk9ORUcsCgkJCW9wdF9wYXJzZV9tZXJnZV9maWx0ZXIsIChpbnRwdHJfdCkgIkhFQUQiLAoJCX0sCgkJT1BUX0VORCgpLAoJfTsKCglpZiAoYXJnYyA9PSAyICYmICFzdHJjbXAoYXJndlsxXSwgIi1oIikpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGJ1aWx0aW5fYnJhbmNoX3VzYWdlLCBvcHRpb25zKTsKCglnaXRfY29uZmlnKGdpdF9icmFuY2hfY29uZmlnLCBOVUxMKTsKCgl0cmFjayA9IGdpdF9icmFuY2hfdHJhY2s7CgoJaGVhZCA9IHJlc29sdmVfcmVmKCJIRUFEIiwgaGVhZF9zaGExLCAwLCBOVUxMKTsKCWlmICghaGVhZCkKCQlkaWUoXygiRmFpbGVkIHRvIHJlc29sdmUgSEVBRCBhcyBhIHZhbGlkIHJlZi4iKSk7CgloZWFkID0geHN0cmR1cChoZWFkKTsKCWlmICghc3RyY21wKGhlYWQsICJIRUFEIikpIHsKCQlkZXRhY2hlZCA9IDE7Cgl9IGVsc2UgewoJCWlmIChwcmVmaXhjbXAoaGVhZCwgInJlZnMvaGVhZHMvIikpCgkJCWRpZShfKCJIRUFEIG5vdCBmb3VuZCBiZWxvdyByZWZzL2hlYWRzISIpKTsKCQloZWFkICs9IDExOwoJfQoJaGFzaGNweShtZXJnZV9maWx0ZXJfcmVmLCBoZWFkX3NoYTEpOwoKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgb3B0aW9ucywgYnVpbHRpbl9icmFuY2hfdXNhZ2UsCgkJCSAgICAgMCk7CgoJaWYgKCFkZWxldGUgJiYgIXJlbmFtZSAmJiAhZm9yY2VfY3JlYXRlICYmIGFyZ2MgPT0gMCkKCQlsaXN0ID0gMTsKCglpZiAoISFkZWxldGUgKyAhIXJlbmFtZSArICEhZm9yY2VfY3JlYXRlICsgISFsaXN0ID4gMSkKCQl1c2FnZV93aXRoX29wdGlvbnMoYnVpbHRpbl9icmFuY2hfdXNhZ2UsIG9wdGlvbnMpOwoKCWlmIChhYmJyZXYgPT0gLTEpCgkJYWJicmV2ID0gREVGQVVMVF9BQkJSRVY7CgoJaWYgKGRlbGV0ZSkKCQlyZXR1cm4gZGVsZXRlX2JyYW5jaGVzKGFyZ2MsIGFyZ3YsIGRlbGV0ZSA+IDEsIGtpbmRzKTsKCWVsc2UgaWYgKGxpc3QpCgkJcmV0dXJuIHByaW50X3JlZl9saXN0KGtpbmRzLCBkZXRhY2hlZCwgdmVyYm9zZSwgYWJicmV2LAoJCQkJICAgICAgd2l0aF9jb21taXQsIGFyZ3YpOwoJZWxzZSBpZiAocmVuYW1lICYmIChhcmdjID09IDEpKQoJCXJlbmFtZV9icmFuY2goaGVhZCwgYXJndlswXSwgcmVuYW1lID4gMSk7CgllbHNlIGlmIChyZW5hbWUgJiYgKGFyZ2MgPT0gMikpCgkJcmVuYW1lX2JyYW5jaChhcmd2WzBdLCBhcmd2WzFdLCByZW5hbWUgPiAxKTsKCWVsc2UgaWYgKGFyZ2MgPD0gMikgewoJCWlmIChraW5kcyAhPSBSRUZfTE9DQUxfQlJBTkNIKQoJCQlkaWUoXygiLWEgYW5kIC1yIG9wdGlvbnMgdG8gJ2dpdCBicmFuY2gnIGRvIG5vdCBtYWtlIHNlbnNlIHdpdGggYSBicmFuY2ggbmFtZSIpKTsKCQljcmVhdGVfYnJhbmNoKGhlYWQsIGFyZ3ZbMF0sIChhcmdjID09IDIpID8gYXJndlsxXSA6IGhlYWQsCgkJCSAgICAgIGZvcmNlX2NyZWF0ZSwgcmVmbG9nLCB0cmFjayk7Cgl9IGVsc2UKCQl1c2FnZV93aXRoX29wdGlvbnMoYnVpbHRpbl9icmFuY2hfdXNhZ2UsIG9wdGlvbnMpOwoKCXJldHVybiAwOwp9Cg==",
    "text": "/*\n * Builtin \"git branch\"\n *\n * Copyright (c) 2006 Kristian H\u00f8gsberg <krh@redhat.com>\n * Based on git-branch.sh by Junio C Hamano.\n */\n\n#include \"cache.h\"\n#include \"color.h\"\n#include \"refs.h\"\n#include \"commit.h\"\n#include \"builtin.h\"\n#include \"remote.h\"\n#include \"parse-options.h\"\n#include \"branch.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n\nstatic const char * const builtin_branch_usage[] = {\n\t\"git branch [options] [-r | -a] [--merged | --no-merged]\",\n\t\"git branch [options] [-l] [-f] <branchname> [<start-point>]\",\n\t\"git branch [options] [-r] (-d | -D) <branchname>...\",\n\t\"git branch [options] (-m | -M) [<oldbranch>] <newbranch>\",\n\tNULL\n};\n\n#define REF_LOCAL_BRANCH    0x01\n#define REF_REMOTE_BRANCH   0x02\n\nstatic const char *head;\nstatic unsigned char head_sha1[20];\n\nstatic int branch_use_color = -1;\nstatic char branch_colors[][COLOR_MAXLEN] = {\n\tGIT_COLOR_RESET,\n\tGIT_COLOR_NORMAL,\t/* PLAIN */\n\tGIT_COLOR_RED,\t\t/* REMOTE */\n\tGIT_COLOR_NORMAL,\t/* LOCAL */\n\tGIT_COLOR_GREEN,\t/* CURRENT */\n};\nenum color_branch {\n\tBRANCH_COLOR_RESET = 0,\n\tBRANCH_COLOR_PLAIN = 1,\n\tBRANCH_COLOR_REMOTE = 2,\n\tBRANCH_COLOR_LOCAL = 3,\n\tBRANCH_COLOR_CURRENT = 4\n};\n\nstatic enum merge_filter {\n\tNO_FILTER = 0,\n\tSHOW_NOT_MERGED,\n\tSHOW_MERGED\n} merge_filter;\nstatic unsigned char merge_filter_ref[20];\n\nstatic int parse_branch_color_slot(const char *var, int ofs)\n{\n\tif (!strcasecmp(var+ofs, \"plain\"))\n\t\treturn BRANCH_COLOR_PLAIN;\n\tif (!strcasecmp(var+ofs, \"reset\"))\n\t\treturn BRANCH_COLOR_RESET;\n\tif (!strcasecmp(var+ofs, \"remote\"))\n\t\treturn BRANCH_COLOR_REMOTE;\n\tif (!strcasecmp(var+ofs, \"local\"))\n\t\treturn BRANCH_COLOR_LOCAL;\n\tif (!strcasecmp(var+ofs, \"current\"))\n\t\treturn BRANCH_COLOR_CURRENT;\n\treturn -1;\n}\n\nstatic int git_branch_config(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(var, \"color.branch\")) {\n\t\tbranch_use_color = git_config_colorbool(var, value);\n\t\treturn 0;\n\t}\n\tif (!prefixcmp(var, \"color.branch.\")) {\n\t\tint slot = parse_branch_color_slot(var, 13);\n\t\tif (slot < 0)\n\t\t\treturn 0;\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tcolor_parse(value, var, branch_colors[slot]);\n\t\treturn 0;\n\t}\n\treturn git_color_default_config(var, value, cb);\n}\n\nstatic const char *branch_get_color(enum color_branch ix)\n{\n\tif (want_color(branch_use_color))\n\t\treturn branch_colors[ix];\n\treturn \"\";\n}\n\nstatic int branch_merged(int kind, const char *name,\n\t\t\t struct commit *rev, struct commit *head_rev)\n{\n\t/*\n\t * This checks whether the merge bases of branch and HEAD (or\n\t * the other branch this branch builds upon) contains the\n\t * branch, which means that the branch has already been merged\n\t * safely to HEAD (or the other branch).\n\t */\n\tstruct commit *reference_rev = NULL;\n\tconst char *reference_name = NULL;\n\tint merged;\n\n\tif (kind == REF_LOCAL_BRANCH) {\n\t\tstruct branch *branch = branch_get(name);\n\t\tunsigned char sha1[20];\n\n\t\tif (branch &&\n\t\t    branch->merge &&\n\t\t    branch->merge[0] &&\n\t\t    branch->merge[0]->dst &&\n\t\t    (reference_name =\n\t\t     resolve_ref(branch->merge[0]->dst, sha1, 1, NULL)) != NULL)\n\t\t\treference_rev = lookup_commit_reference(sha1);\n\t}\n\tif (!reference_rev)\n\t\treference_rev = head_rev;\n\n\tmerged = in_merge_bases(rev, &reference_rev, 1);\n\n\t/*\n\t * After the safety valve is fully redefined to \"check with\n\t * upstream, if any, otherwise with HEAD\", we should just\n\t * return the result of the in_merge_bases() above without\n\t * any of the following code, but during the transition period,\n\t * a gentle reminder is in order.\n\t */\n\tif ((head_rev != reference_rev) &&\n\t    in_merge_bases(rev, &head_rev, 1) != merged) {\n\t\tif (merged)\n\t\t\twarning(_(\"deleting branch '%s' that has been merged to\\n\"\n\t\t\t\t\"         '%s', but not yet merged to HEAD.\"),\n\t\t\t\tname, reference_name);\n\t\telse\n\t\t\twarning(_(\"not deleting branch '%s' that is not yet merged to\\n\"\n\t\t\t\t\"         '%s', even though it is merged to HEAD.\"),\n\t\t\t\tname, reference_name);\n\t}\n\treturn merged;\n}\n\nstatic int delete_branches(int argc, const char **argv, int force, int kinds)\n{\n\tstruct commit *rev, *head_rev = NULL;\n\tunsigned char sha1[20];\n\tchar *name = NULL;\n\tconst char *fmt, *remote;\n\tint i;\n\tint ret = 0;\n\tstruct strbuf bname = STRBUF_INIT;\n\n\tswitch (kinds) {\n\tcase REF_REMOTE_BRANCH:\n\t\tfmt = \"refs/remotes/%s\";\n\t\t/* TRANSLATORS: This is \"remote \" in \"remote branch '%s' not found\" */\n\t\tremote = _(\"remote \");\n\t\tforce = 1;\n\t\tbreak;\n\tcase REF_LOCAL_BRANCH:\n\t\tfmt = \"refs/heads/%s\";\n\t\tremote = \"\";\n\t\tbreak;\n\tdefault:\n\t\tdie(_(\"cannot use -a with -d\"));\n\t}\n\n\tif (!force) {\n\t\thead_rev = lookup_commit_reference(head_sha1);\n\t\tif (!head_rev)\n\t\t\tdie(_(\"Couldn't look up commit object for HEAD\"));\n\t}\n\tfor (i = 0; i < argc; i++, strbuf_release(&bname)) {\n\t\tstrbuf_branchname(&bname, argv[i]);\n\t\tif (kinds == REF_LOCAL_BRANCH && !strcmp(head, bname.buf)) {\n\t\t\terror(_(\"Cannot delete the branch '%s' \"\n\t\t\t      \"which you are currently on.\"), bname.buf);\n\t\t\tret = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfree(name);\n\n\t\tname = xstrdup(mkpath(fmt, bname.buf));\n\t\tif (!resolve_ref(name, sha1, 1, NULL)) {\n\t\t\terror(_(\"%sbranch '%s' not found.\"),\n\t\t\t\t\tremote, bname.buf);\n\t\t\tret = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\trev = lookup_commit_reference(sha1);\n\t\tif (!rev) {\n\t\t\terror(_(\"Couldn't look up commit object for '%s'\"), name);\n\t\t\tret = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!force && !branch_merged(kinds, bname.buf, rev, head_rev)) {\n\t\t\terror(_(\"The branch '%s' is not fully merged.\\n\"\n\t\t\t      \"If you are sure you want to delete it, \"\n\t\t\t      \"run 'git branch -D %s'.\"), bname.buf, bname.buf);\n\t\t\tret = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (delete_ref(name, sha1, 0)) {\n\t\t\terror(_(\"Error deleting %sbranch '%s'\"), remote,\n\t\t\t      bname.buf);\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tstruct strbuf buf = STRBUF_INIT;\n\t\t\tprintf(_(\"Deleted %sbranch %s (was %s).\\n\"), remote,\n\t\t\t       bname.buf,\n\t\t\t       find_unique_abbrev(sha1, DEFAULT_ABBREV));\n\t\t\tstrbuf_addf(&buf, \"branch.%s\", bname.buf);\n\t\t\tif (git_config_rename_section(buf.buf, NULL) < 0)\n\t\t\t\twarning(_(\"Update of config-file failed\"));\n\t\t\tstrbuf_release(&buf);\n\t\t}\n\t}\n\n\tfree(name);\n\n\treturn(ret);\n}\n\nstruct ref_item {\n\tchar *name;\n\tchar *dest;\n\tunsigned int kind, len;\n\tstruct commit *commit;\n};\n\nstruct ref_list {\n\tstruct rev_info revs;\n\tint index, alloc, maxwidth, verbose, abbrev;\n\tstruct ref_item *list;\n\tstruct commit_list *with_commit;\n\tint kinds;\n};\n\nstatic char *resolve_symref(const char *src, const char *prefix)\n{\n\tunsigned char sha1[20];\n\tint flag;\n\tconst char *dst, *cp;\n\n\tdst = resolve_ref(src, sha1, 0, &flag);\n\tif (!(dst && (flag & REF_ISSYMREF)))\n\t\treturn NULL;\n\tif (prefix && (cp = skip_prefix(dst, prefix)))\n\t\tdst = cp;\n\treturn xstrdup(dst);\n}\n\nstruct append_ref_cb {\n\tstruct ref_list *ref_list;\n\tconst char **pattern;\n\tint ret;\n};\n\nstatic int match_patterns(const char **pattern, const char *refname)\n{\n\tif (!*pattern)\n\t\treturn 1; /* no pattern always matches */\n\twhile (*pattern) {\n\t\tif (!fnmatch(*pattern, refname, 0))\n\t\t\treturn 1;\n\t\tpattern++;\n\t}\n\treturn 0;\n}\n\nstatic int append_ref(const char *refname, const unsigned char *sha1, int flags, void *cb_data)\n{\n\tstruct append_ref_cb *cb = (struct append_ref_cb *)(cb_data);\n\tstruct ref_list *ref_list = cb->ref_list;\n\tstruct ref_item *newitem;\n\tstruct commit *commit;\n\tint kind, i;\n\tconst char *prefix, *orig_refname = refname;\n\n\tstatic struct {\n\t\tint kind;\n\t\tconst char *prefix;\n\t\tint pfxlen;\n\t} ref_kind[] = {\n\t\t{ REF_LOCAL_BRANCH, \"refs/heads/\", 11 },\n\t\t{ REF_REMOTE_BRANCH, \"refs/remotes/\", 13 },\n\t};\n\n\t/* Detect kind */\n\tfor (i = 0; i < ARRAY_SIZE(ref_kind); i++) {\n\t\tprefix = ref_kind[i].prefix;\n\t\tif (strncmp(refname, prefix, ref_kind[i].pfxlen))\n\t\t\tcontinue;\n\t\tkind = ref_kind[i].kind;\n\t\trefname += ref_kind[i].pfxlen;\n\t\tbreak;\n\t}\n\tif (ARRAY_SIZE(ref_kind) <= i)\n\t\treturn 0;\n\n\t/* Don't add types the caller doesn't want */\n\tif ((kind & ref_list->kinds) == 0)\n\t\treturn 0;\n\n\tif (!match_patterns(cb->pattern, refname))\n\t\treturn 0;\n\n\tcommit = NULL;\n\tif (ref_list->verbose || ref_list->with_commit || merge_filter != NO_FILTER) {\n\t\tcommit = lookup_commit_reference_gently(sha1, 1);\n\t\tif (!commit) {\n\t\t\tcb->ret = error(_(\"branch '%s' does not point at a commit\"), refname);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Filter with with_commit if specified */\n\t\tif (!is_descendant_of(commit, ref_list->with_commit))\n\t\t\treturn 0;\n\n\t\tif (merge_filter != NO_FILTER)\n\t\t\tadd_pending_object(&ref_list->revs,\n\t\t\t\t\t   (struct object *)commit, refname);\n\t}\n\n\tALLOC_GROW(ref_list->list, ref_list->index + 1, ref_list->alloc);\n\n\t/* Record the new item */\n\tnewitem = &(ref_list->list[ref_list->index++]);\n\tnewitem->name = xstrdup(refname);\n\tnewitem->kind = kind;\n\tnewitem->commit = commit;\n\tnewitem->len = strlen(refname);\n\tnewitem->dest = resolve_symref(orig_refname, prefix);\n\t/* adjust for \"remotes/\" */\n\tif (newitem->kind == REF_REMOTE_BRANCH &&\n\t    ref_list->kinds != REF_REMOTE_BRANCH)\n\t\tnewitem->len += 8;\n\tif (newitem->len > ref_list->maxwidth)\n\t\tref_list->maxwidth = newitem->len;\n\n\treturn 0;\n}\n\nstatic void free_ref_list(struct ref_list *ref_list)\n{\n\tint i;\n\n\tfor (i = 0; i < ref_list->index; i++) {\n\t\tfree(ref_list->list[i].name);\n\t\tfree(ref_list->list[i].dest);\n\t}\n\tfree(ref_list->list);\n}\n\nstatic int ref_cmp(const void *r1, const void *r2)\n{\n\tstruct ref_item *c1 = (struct ref_item *)(r1);\n\tstruct ref_item *c2 = (struct ref_item *)(r2);\n\n\tif (c1->kind != c2->kind)\n\t\treturn c1->kind - c2->kind;\n\treturn strcmp(c1->name, c2->name);\n}\n\nstatic void fill_tracking_info(struct strbuf *stat, const char *branch_name,\n\t\tint show_upstream_ref)\n{\n\tint ours, theirs;\n\tstruct branch *branch = branch_get(branch_name);\n\n\tif (!stat_tracking_info(branch, &ours, &theirs)) {\n\t\tif (branch && branch->merge && branch->merge[0]->dst &&\n\t\t    show_upstream_ref)\n\t\t\tstrbuf_addf(stat, \"[%s] \",\n\t\t\t    shorten_unambiguous_ref(branch->merge[0]->dst, 0));\n\t\treturn;\n\t}\n\n\tstrbuf_addch(stat, '[');\n\tif (show_upstream_ref)\n\t\tstrbuf_addf(stat, \"%s: \",\n\t\t\tshorten_unambiguous_ref(branch->merge[0]->dst, 0));\n\tif (!ours)\n\t\tstrbuf_addf(stat, _(\"behind %d] \"), theirs);\n\telse if (!theirs)\n\t\tstrbuf_addf(stat, _(\"ahead %d] \"), ours);\n\telse\n\t\tstrbuf_addf(stat, _(\"ahead %d, behind %d] \"), ours, theirs);\n}\n\nstatic int matches_merge_filter(struct commit *commit)\n{\n\tint is_merged;\n\n\tif (merge_filter == NO_FILTER)\n\t\treturn 1;\n\n\tis_merged = !!(commit->object.flags & UNINTERESTING);\n\treturn (is_merged == (merge_filter == SHOW_MERGED));\n}\n\nstatic void add_verbose_info(struct strbuf *out, struct ref_item *item,\n\t\t\t     int verbose, int abbrev)\n{\n\tstruct strbuf subject = STRBUF_INIT, stat = STRBUF_INIT;\n\tconst char *sub = \" **** invalid ref ****\";\n\tstruct commit *commit = item->commit;\n\n\tif (commit && !parse_commit(commit)) {\n\t\tpp_commit_easy(CMIT_FMT_ONELINE, commit, &subject);\n\t\tsub = subject.buf;\n\t}\n\n\tif (item->kind == REF_LOCAL_BRANCH)\n\t\tfill_tracking_info(&stat, item->name, verbose > 1);\n\n\tstrbuf_addf(out, \" %s %s%s\",\n\t\tfind_unique_abbrev(item->commit->object.sha1, abbrev),\n\t\tstat.buf, sub);\n\tstrbuf_release(&stat);\n\tstrbuf_release(&subject);\n}\n\nstatic void print_ref_item(struct ref_item *item, int maxwidth, int verbose,\n\t\t\t   int abbrev, int current, char *prefix)\n{\n\tchar c;\n\tint color;\n\tstruct commit *commit = item->commit;\n\tstruct strbuf out = STRBUF_INIT, name = STRBUF_INIT;\n\n\tif (!matches_merge_filter(commit))\n\t\treturn;\n\n\tswitch (item->kind) {\n\tcase REF_LOCAL_BRANCH:\n\t\tcolor = BRANCH_COLOR_LOCAL;\n\t\tbreak;\n\tcase REF_REMOTE_BRANCH:\n\t\tcolor = BRANCH_COLOR_REMOTE;\n\t\tbreak;\n\tdefault:\n\t\tcolor = BRANCH_COLOR_PLAIN;\n\t\tbreak;\n\t}\n\n\tc = ' ';\n\tif (current) {\n\t\tc = '*';\n\t\tcolor = BRANCH_COLOR_CURRENT;\n\t}\n\n\tstrbuf_addf(&name, \"%s%s\", prefix, item->name);\n\tif (verbose)\n\t\tstrbuf_addf(&out, \"%c %s%-*s%s\", c, branch_get_color(color),\n\t\t\t    maxwidth, name.buf,\n\t\t\t    branch_get_color(BRANCH_COLOR_RESET));\n\telse\n\t\tstrbuf_addf(&out, \"%c %s%s%s\", c, branch_get_color(color),\n\t\t\t    name.buf, branch_get_color(BRANCH_COLOR_RESET));\n\n\tif (item->dest)\n\t\tstrbuf_addf(&out, \" -> %s\", item->dest);\n\telse if (verbose)\n\t\t/* \" f7c0c00 [ahead 58, behind 197] vcs-svn: drop obj_pool.h\" */\n\t\tadd_verbose_info(&out, item, verbose, abbrev);\n\tprintf(\"%s\\n\", out.buf);\n\tstrbuf_release(&name);\n\tstrbuf_release(&out);\n}\n\nstatic int calc_maxwidth(struct ref_list *refs)\n{\n\tint i, w = 0;\n\tfor (i = 0; i < refs->index; i++) {\n\t\tif (!matches_merge_filter(refs->list[i].commit))\n\t\t\tcontinue;\n\t\tif (refs->list[i].len > w)\n\t\t\tw = refs->list[i].len;\n\t}\n\treturn w;\n}\n\n\nstatic void show_detached(struct ref_list *ref_list)\n{\n\tstruct commit *head_commit = lookup_commit_reference_gently(head_sha1, 1);\n\n\tif (head_commit && is_descendant_of(head_commit, ref_list->with_commit)) {\n\t\tstruct ref_item item;\n\t\titem.name = xstrdup(_(\"(no branch)\"));\n\t\titem.len = strlen(item.name);\n\t\titem.kind = REF_LOCAL_BRANCH;\n\t\titem.dest = NULL;\n\t\titem.commit = head_commit;\n\t\tif (item.len > ref_list->maxwidth)\n\t\t\tref_list->maxwidth = item.len;\n\t\tprint_ref_item(&item, ref_list->maxwidth, ref_list->verbose, ref_list->abbrev, 1, \"\");\n\t\tfree(item.name);\n\t}\n}\n\nstatic int print_ref_list(int kinds, int detached, int verbose, int abbrev, struct commit_list *with_commit, const char **pattern)\n{\n\tint i;\n\tstruct append_ref_cb cb;\n\tstruct ref_list ref_list;\n\n\tmemset(&ref_list, 0, sizeof(ref_list));\n\tref_list.kinds = kinds;\n\tref_list.verbose = verbose;\n\tref_list.abbrev = abbrev;\n\tref_list.with_commit = with_commit;\n\tif (merge_filter != NO_FILTER)\n\t\tinit_revisions(&ref_list.revs, NULL);\n\tcb.ref_list = &ref_list;\n\tcb.pattern = pattern;\n\tcb.ret = 0;\n\tfor_each_rawref(append_ref, &cb);\n\tif (merge_filter != NO_FILTER) {\n\t\tstruct commit *filter;\n\t\tfilter = lookup_commit_reference_gently(merge_filter_ref, 0);\n\t\tfilter->object.flags |= UNINTERESTING;\n\t\tadd_pending_object(&ref_list.revs,\n\t\t\t\t   (struct object *) filter, \"\");\n\t\tref_list.revs.limited = 1;\n\t\tprepare_revision_walk(&ref_list.revs);\n\t\tif (verbose)\n\t\t\tref_list.maxwidth = calc_maxwidth(&ref_list);\n\t}\n\n\tqsort(ref_list.list, ref_list.index, sizeof(struct ref_item), ref_cmp);\n\n\tdetached = (detached && (kinds & REF_LOCAL_BRANCH));\n\tif (detached && match_patterns(pattern, \"HEAD\"))\n\t\tshow_detached(&ref_list);\n\n\tfor (i = 0; i < ref_list.index; i++) {\n\t\tint current = !detached &&\n\t\t\t(ref_list.list[i].kind == REF_LOCAL_BRANCH) &&\n\t\t\t!strcmp(ref_list.list[i].name, head);\n\t\tchar *prefix = (kinds != REF_REMOTE_BRANCH &&\n\t\t\t\tref_list.list[i].kind == REF_REMOTE_BRANCH)\n\t\t\t\t? \"remotes/\" : \"\";\n\t\tprint_ref_item(&ref_list.list[i], ref_list.maxwidth, verbose,\n\t\t\t       abbrev, current, prefix);\n\t}\n\n\tfree_ref_list(&ref_list);\n\n\tif (cb.ret)\n\t\terror(_(\"some refs could not be read\"));\n\n\treturn cb.ret;\n}\n\nstatic void rename_branch(const char *oldname, const char *newname, int force)\n{\n\tstruct strbuf oldref = STRBUF_INIT, newref = STRBUF_INIT, logmsg = STRBUF_INIT;\n\tunsigned char sha1[20];\n\tstruct strbuf oldsection = STRBUF_INIT, newsection = STRBUF_INIT;\n\tint recovery = 0;\n\n\tif (!oldname)\n\t\tdie(_(\"cannot rename the current branch while not on any.\"));\n\n\tif (strbuf_check_branch_ref(&oldref, oldname)) {\n\t\t/*\n\t\t * Bad name --- this could be an attempt to rename a\n\t\t * ref that we used to allow to be created by accident.\n\t\t */\n\t\tif (resolve_ref(oldref.buf, sha1, 1, NULL))\n\t\t\trecovery = 1;\n\t\telse\n\t\t\tdie(_(\"Invalid branch name: '%s'\"), oldname);\n\t}\n\n\tvalidate_new_branchname(newname, &newref, force, 0);\n\n\tstrbuf_addf(&logmsg, \"Branch: renamed %s to %s\",\n\t\t oldref.buf, newref.buf);\n\n\tif (rename_ref(oldref.buf, newref.buf, logmsg.buf))\n\t\tdie(_(\"Branch rename failed\"));\n\tstrbuf_release(&logmsg);\n\n\tif (recovery)\n\t\twarning(_(\"Renamed a misnamed branch '%s' away\"), oldref.buf + 11);\n\n\t/* no need to pass logmsg here as HEAD didn't really move */\n\tif (!strcmp(oldname, head) && create_symref(\"HEAD\", newref.buf, NULL))\n\t\tdie(_(\"Branch renamed to %s, but HEAD is not updated!\"), newname);\n\n\tstrbuf_addf(&oldsection, \"branch.%s\", oldref.buf + 11);\n\tstrbuf_release(&oldref);\n\tstrbuf_addf(&newsection, \"branch.%s\", newref.buf + 11);\n\tstrbuf_release(&newref);\n\tif (git_config_rename_section(oldsection.buf, newsection.buf) < 0)\n\t\tdie(_(\"Branch is renamed, but update of config-file failed\"));\n\tstrbuf_release(&oldsection);\n\tstrbuf_release(&newsection);\n}\n\nstatic int opt_parse_merge_filter(const struct option *opt, const char *arg, int unset)\n{\n\tmerge_filter = ((opt->long_name[0] == 'n')\n\t\t\t? SHOW_NOT_MERGED\n\t\t\t: SHOW_MERGED);\n\tif (unset)\n\t\tmerge_filter = SHOW_NOT_MERGED; /* b/c for --no-merged */\n\tif (!arg)\n\t\targ = \"HEAD\";\n\tif (get_sha1(arg, merge_filter_ref))\n\t\tdie(_(\"malformed object name %s\"), arg);\n\treturn 0;\n}\n\nint cmd_branch(int argc, const char **argv, const char *prefix)\n{\n\tint delete = 0, rename = 0, force_create = 0, list = 0;\n\tint verbose = 0, abbrev = -1, detached = 0;\n\tint reflog = 0;\n\tenum branch_track track;\n\tint kinds = REF_LOCAL_BRANCH;\n\tstruct commit_list *with_commit = NULL;\n\n\tstruct option options[] = {\n\t\tOPT_GROUP(\"Generic options\"),\n\t\tOPT__VERBOSE(&verbose,\n\t\t\t\"show hash and subject, give twice for upstream branch\"),\n\t\tOPT_SET_INT('t', \"track\",  &track, \"set up tracking mode (see git-pull(1))\",\n\t\t\tBRANCH_TRACK_EXPLICIT),\n\t\tOPT_SET_INT( 0, \"set-upstream\",  &track, \"change upstream info\",\n\t\t\tBRANCH_TRACK_OVERRIDE),\n\t\tOPT__COLOR(&branch_use_color, \"use colored output\"),\n\t\tOPT_SET_INT('r', \"remotes\",     &kinds, \"act on remote-tracking branches\",\n\t\t\tREF_REMOTE_BRANCH),\n\t\t{\n\t\t\tOPTION_CALLBACK, 0, \"contains\", &with_commit, \"commit\",\n\t\t\t\"print only branches that contain the commit\",\n\t\t\tPARSE_OPT_LASTARG_DEFAULT,\n\t\t\tparse_opt_with_commit, (intptr_t)\"HEAD\",\n\t\t},\n\t\t{\n\t\t\tOPTION_CALLBACK, 0, \"with\", &with_commit, \"commit\",\n\t\t\t\"print only branches that contain the commit\",\n\t\t\tPARSE_OPT_HIDDEN | PARSE_OPT_LASTARG_DEFAULT,\n\t\t\tparse_opt_with_commit, (intptr_t) \"HEAD\",\n\t\t},\n\t\tOPT__ABBREV(&abbrev),\n\n\t\tOPT_GROUP(\"Specific git-branch actions:\"),\n\t\tOPT_SET_INT('a', \"all\", &kinds, \"list both remote-tracking and local branches\",\n\t\t\tREF_REMOTE_BRANCH | REF_LOCAL_BRANCH),\n\t\tOPT_BIT('d', \"delete\", &delete, \"delete fully merged branch\", 1),\n\t\tOPT_BIT('D', NULL, &delete, \"delete branch (even if not merged)\", 2),\n\t\tOPT_BIT('m', \"move\", &rename, \"move/rename a branch and its reflog\", 1),\n\t\tOPT_BIT('M', NULL, &rename, \"move/rename a branch, even if target exists\", 2),\n\t\tOPT_BOOLEAN(0, \"list\", &list, \"list branch names\"),\n\t\tOPT_BOOLEAN('l', \"create-reflog\", &reflog, \"create the branch's reflog\"),\n\t\tOPT__FORCE(&force_create, \"force creation (when already exists)\"),\n\t\t{\n\t\t\tOPTION_CALLBACK, 0, \"no-merged\", &merge_filter_ref,\n\t\t\t\"commit\", \"print only not merged branches\",\n\t\t\tPARSE_OPT_LASTARG_DEFAULT | PARSE_OPT_NONEG,\n\t\t\topt_parse_merge_filter, (intptr_t) \"HEAD\",\n\t\t},\n\t\t{\n\t\t\tOPTION_CALLBACK, 0, \"merged\", &merge_filter_ref,\n\t\t\t\"commit\", \"print only merged branches\",\n\t\t\tPARSE_OPT_LASTARG_DEFAULT | PARSE_OPT_NONEG,\n\t\t\topt_parse_merge_filter, (intptr_t) \"HEAD\",\n\t\t},\n\t\tOPT_END(),\n\t};\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_branch_usage, options);\n\n\tgit_config(git_branch_config, NULL);\n\n\ttrack = git_branch_track;\n\n\thead = resolve_ref(\"HEAD\", head_sha1, 0, NULL);\n\tif (!head)\n\t\tdie(_(\"Failed to resolve HEAD as a valid ref.\"));\n\thead = xstrdup(head);\n\tif (!strcmp(head, \"HEAD\")) {\n\t\tdetached = 1;\n\t} else {\n\t\tif (prefixcmp(head, \"refs/heads/\"))\n\t\t\tdie(_(\"HEAD not found below refs/heads!\"));\n\t\thead += 11;\n\t}\n\thashcpy(merge_filter_ref, head_sha1);\n\n\targc = parse_options(argc, argv, prefix, options, builtin_branch_usage,\n\t\t\t     0);\n\n\tif (!delete && !rename && !force_create && argc == 0)\n\t\tlist = 1;\n\n\tif (!!delete + !!rename + !!force_create + !!list > 1)\n\t\tusage_with_options(builtin_branch_usage, options);\n\n\tif (abbrev == -1)\n\t\tabbrev = DEFAULT_ABBREV;\n\n\tif (delete)\n\t\treturn delete_branches(argc, argv, delete > 1, kinds);\n\telse if (list)\n\t\treturn print_ref_list(kinds, detached, verbose, abbrev,\n\t\t\t\t      with_commit, argv);\n\telse if (rename && (argc == 1))\n\t\trename_branch(head, argv[0], rename > 1);\n\telse if (rename && (argc == 2))\n\t\trename_branch(argv[0], argv[1], rename > 1);\n\telse if (argc <= 2) {\n\t\tif (kinds != REF_LOCAL_BRANCH)\n\t\t\tdie(_(\"-a and -r options to 'git branch' do not make sense with a branch name\"));\n\t\tcreate_branch(head, argv[0], (argc == 2) ? argv[1] : head,\n\t\t\t      force_create, reflog, track);\n\t} else\n\t\tusage_with_options(builtin_branch_usage, options);\n\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "009b7138ac72c5845225ce1f801be908ede4e3b4",
  "sha1_ok": true,
  "size": 20086
}
