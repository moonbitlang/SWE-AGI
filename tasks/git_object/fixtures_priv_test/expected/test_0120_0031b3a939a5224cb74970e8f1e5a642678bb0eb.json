{
  "content": {
    "base64": "I2luY2x1ZGUgImh0dHAuaCIKI2luY2x1ZGUgInBhY2suaCIKI2luY2x1ZGUgInNpZGViYW5kLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAidXJsLmgiCiNpbmNsdWRlICJ1cmxtYXRjaC5oIgojaW5jbHVkZSAiY3JlZGVudGlhbC5oIgojaW5jbHVkZSAidmVyc2lvbi5oIgojaW5jbHVkZSAicGt0LWxpbmUuaCIKCmludCBhY3RpdmVfcmVxdWVzdHM7CmludCBodHRwX2lzX3ZlcmJvc2U7CnNpemVfdCBodHRwX3Bvc3RfYnVmZmVyID0gMTYgKiBMQVJHRV9QQUNLRVRfTUFYOwoKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzBhMDYKI2RlZmluZSBMSUJDVVJMX0NBTl9IQU5ETEVfQVVUSF9BTlkKI2VuZGlmCgpzdGF0aWMgaW50IG1pbl9jdXJsX3Nlc3Npb25zID0gMTsKc3RhdGljIGludCBjdXJsX3Nlc3Npb25fY291bnQ7CiNpZmRlZiBVU0VfQ1VSTF9NVUxUSQpzdGF0aWMgaW50IG1heF9yZXF1ZXN0cyA9IC0xOwpzdGF0aWMgQ1VSTE0gKmN1cmxtOwojZW5kaWYKI2lmbmRlZiBOT19DVVJMX0VBU1lfRFVQSEFORExFCnN0YXRpYyBDVVJMICpjdXJsX2RlZmF1bHQ7CiNlbmRpZgoKI2RlZmluZSBQUkVWX0JVRl9TSVpFIDQwOTYKI2RlZmluZSBSQU5HRV9IRUFERVJfU0laRSAzMAoKY2hhciBjdXJsX2Vycm9yc3RyW0NVUkxfRVJST1JfU0laRV07CgpzdGF0aWMgaW50IGN1cmxfc3NsX3ZlcmlmeSA9IC0xOwpzdGF0aWMgaW50IGN1cmxfc3NsX3RyeTsKc3RhdGljIGNvbnN0IGNoYXIgKnNzbF9jZXJ0OwojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MDkwMwpzdGF0aWMgY29uc3QgY2hhciAqc3NsX2tleTsKI2VuZGlmCiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwOTA4CnN0YXRpYyBjb25zdCBjaGFyICpzc2xfY2FwYXRoOwojZW5kaWYKc3RhdGljIGNvbnN0IGNoYXIgKnNzbF9jYWluZm87CnN0YXRpYyBsb25nIGN1cmxfbG93X3NwZWVkX2xpbWl0ID0gLTE7CnN0YXRpYyBsb25nIGN1cmxfbG93X3NwZWVkX3RpbWUgPSAtMTsKc3RhdGljIGludCBjdXJsX2Z0cF9ub19lcHN2OwpzdGF0aWMgY29uc3QgY2hhciAqY3VybF9odHRwX3Byb3h5OwpzdGF0aWMgY29uc3QgY2hhciAqY3VybF9jb29raWVfZmlsZTsKc3RhdGljIGludCBjdXJsX3NhdmVfY29va2llczsKc3RydWN0IGNyZWRlbnRpYWwgaHR0cF9hdXRoID0gQ1JFREVOVElBTF9JTklUOwpzdGF0aWMgaW50IGh0dHBfcHJvYWN0aXZlX2F1dGg7CnN0YXRpYyBjb25zdCBjaGFyICp1c2VyX2FnZW50OwoKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzE3MDAKLyogVXNlIENVUkxPUFRfS0VZUEFTU1dEIGFzIGlzICovCiNlbGlmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzA5MDMKI2RlZmluZSBDVVJMT1BUX0tFWVBBU1NXRCBDVVJMT1BUX1NTTEtFWVBBU1NXRAojZWxzZQojZGVmaW5lIENVUkxPUFRfS0VZUEFTU1dEIENVUkxPUFRfU1NMQ0VSVFBBU1NXRAojZW5kaWYKCnN0YXRpYyBzdHJ1Y3QgY3JlZGVudGlhbCBjZXJ0X2F1dGggPSBDUkVERU5USUFMX0lOSVQ7CnN0YXRpYyBpbnQgc3NsX2NlcnRfcGFzc3dvcmRfcmVxdWlyZWQ7CgpzdGF0aWMgc3RydWN0IGN1cmxfc2xpc3QgKnByYWdtYV9oZWFkZXI7CnN0YXRpYyBzdHJ1Y3QgY3VybF9zbGlzdCAqbm9fcHJhZ21hX2hlYWRlcjsKCnN0YXRpYyBzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqYWN0aXZlX3F1ZXVlX2hlYWQ7CgpzaXplX3QgZnJlYWRfYnVmZmVyKGNoYXIgKnB0ciwgc2l6ZV90IGVsdHNpemUsIHNpemVfdCBubWVtYiwgdm9pZCAqYnVmZmVyXykKewoJc2l6ZV90IHNpemUgPSBlbHRzaXplICogbm1lbWI7CglzdHJ1Y3QgYnVmZmVyICpidWZmZXIgPSBidWZmZXJfOwoKCWlmIChzaXplID4gYnVmZmVyLT5idWYubGVuIC0gYnVmZmVyLT5wb3NuKQoJCXNpemUgPSBidWZmZXItPmJ1Zi5sZW4gLSBidWZmZXItPnBvc247CgltZW1jcHkocHRyLCBidWZmZXItPmJ1Zi5idWYgKyBidWZmZXItPnBvc24sIHNpemUpOwoJYnVmZmVyLT5wb3NuICs9IHNpemU7CgoJcmV0dXJuIHNpemU7Cn0KCiNpZm5kZWYgTk9fQ1VSTF9JT0NUTApjdXJsaW9lcnIgaW9jdGxfYnVmZmVyKENVUkwgKmhhbmRsZSwgaW50IGNtZCwgdm9pZCAqY2xpZW50cCkKewoJc3RydWN0IGJ1ZmZlciAqYnVmZmVyID0gY2xpZW50cDsKCglzd2l0Y2ggKGNtZCkgewoJY2FzZSBDVVJMSU9DTURfTk9QOgoJCXJldHVybiBDVVJMSU9FX09LOwoKCWNhc2UgQ1VSTElPQ01EX1JFU1RBUlRSRUFEOgoJCWJ1ZmZlci0+cG9zbiA9IDA7CgkJcmV0dXJuIENVUkxJT0VfT0s7CgoJZGVmYXVsdDoKCQlyZXR1cm4gQ1VSTElPRV9VTktOT1dOQ01EOwoJfQp9CiNlbmRpZgoKc2l6ZV90IGZ3cml0ZV9idWZmZXIoY2hhciAqcHRyLCBzaXplX3QgZWx0c2l6ZSwgc2l6ZV90IG5tZW1iLCB2b2lkICpidWZmZXJfKQp7CglzaXplX3Qgc2l6ZSA9IGVsdHNpemUgKiBubWVtYjsKCXN0cnVjdCBzdHJidWYgKmJ1ZmZlciA9IGJ1ZmZlcl87CgoJc3RyYnVmX2FkZChidWZmZXIsIHB0ciwgc2l6ZSk7CglyZXR1cm4gc2l6ZTsKfQoKc2l6ZV90IGZ3cml0ZV9udWxsKGNoYXIgKnB0ciwgc2l6ZV90IGVsdHNpemUsIHNpemVfdCBubWVtYiwgdm9pZCAqc3RyYnVmKQp7CglyZXR1cm4gZWx0c2l6ZSAqIG5tZW1iOwp9CgojaWZkZWYgVVNFX0NVUkxfTVVMVEkKc3RhdGljIHZvaWQgcHJvY2Vzc19jdXJsX21lc3NhZ2VzKHZvaWQpCnsKCWludCBudW1fbWVzc2FnZXM7CglzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdDsKCUNVUkxNc2cgKmN1cmxfbWVzc2FnZSA9IGN1cmxfbXVsdGlfaW5mb19yZWFkKGN1cmxtLCAmbnVtX21lc3NhZ2VzKTsKCgl3aGlsZSAoY3VybF9tZXNzYWdlICE9IE5VTEwpIHsKCQlpZiAoY3VybF9tZXNzYWdlLT5tc2cgPT0gQ1VSTE1TR19ET05FKSB7CgkJCWludCBjdXJsX3Jlc3VsdCA9IGN1cmxfbWVzc2FnZS0+ZGF0YS5yZXN1bHQ7CgkJCXNsb3QgPSBhY3RpdmVfcXVldWVfaGVhZDsKCQkJd2hpbGUgKHNsb3QgIT0gTlVMTCAmJgoJCQkgICAgICAgc2xvdC0+Y3VybCAhPSBjdXJsX21lc3NhZ2UtPmVhc3lfaGFuZGxlKQoJCQkJc2xvdCA9IHNsb3QtPm5leHQ7CgkJCWlmIChzbG90ICE9IE5VTEwpIHsKCQkJCWN1cmxfbXVsdGlfcmVtb3ZlX2hhbmRsZShjdXJsbSwgc2xvdC0+Y3VybCk7CgkJCQlzbG90LT5jdXJsX3Jlc3VsdCA9IGN1cmxfcmVzdWx0OwoJCQkJZmluaXNoX2FjdGl2ZV9zbG90KHNsb3QpOwoJCQl9IGVsc2UgewoJCQkJZnByaW50ZihzdGRlcnIsICJSZWNlaXZlZCBET05FIG1lc3NhZ2UgZm9yIHVua25vd24gcmVxdWVzdCFcbiIpOwoJCQl9CgkJfSBlbHNlIHsKCQkJZnByaW50ZihzdGRlcnIsICJVbmtub3duIENVUkwgbWVzc2FnZSByZWNlaXZlZDogJWRcbiIsCgkJCQkoaW50KWN1cmxfbWVzc2FnZS0+bXNnKTsKCQl9CgkJY3VybF9tZXNzYWdlID0gY3VybF9tdWx0aV9pbmZvX3JlYWQoY3VybG0sICZudW1fbWVzc2FnZXMpOwoJfQp9CiNlbmRpZgoKc3RhdGljIGludCBodHRwX29wdGlvbnMoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSwgdm9pZCAqY2IpCnsKCWlmICghc3RyY21wKCJodHRwLnNzbHZlcmlmeSIsIHZhcikpIHsKCQljdXJsX3NzbF92ZXJpZnkgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCgiaHR0cC5zc2xjZXJ0IiwgdmFyKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJnNzbF9jZXJ0LCB2YXIsIHZhbHVlKTsKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzA5MDMKCWlmICghc3RyY21wKCJodHRwLnNzbGtleSIsIHZhcikpCgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZzc2xfa2V5LCB2YXIsIHZhbHVlKTsKI2VuZGlmCiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwOTA4CglpZiAoIXN0cmNtcCgiaHR0cC5zc2xjYXBhdGgiLCB2YXIpKQoJCXJldHVybiBnaXRfY29uZmlnX3N0cmluZygmc3NsX2NhcGF0aCwgdmFyLCB2YWx1ZSk7CiNlbmRpZgoJaWYgKCFzdHJjbXAoImh0dHAuc3NsY2FpbmZvIiwgdmFyKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJnNzbF9jYWluZm8sIHZhciwgdmFsdWUpOwoJaWYgKCFzdHJjbXAoImh0dHAuc3NsY2VydHBhc3N3b3JkcHJvdGVjdGVkIiwgdmFyKSkgewoJCXNzbF9jZXJ0X3Bhc3N3b3JkX3JlcXVpcmVkID0gZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoImh0dHAuc3NsdHJ5IiwgdmFyKSkgewoJCWN1cmxfc3NsX3RyeSA9IGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKCJodHRwLm1pbnNlc3Npb25zIiwgdmFyKSkgewoJCW1pbl9jdXJsX3Nlc3Npb25zID0gZ2l0X2NvbmZpZ19pbnQodmFyLCB2YWx1ZSk7CiNpZm5kZWYgVVNFX0NVUkxfTVVMVEkKCQlpZiAobWluX2N1cmxfc2Vzc2lvbnMgPiAxKQoJCQltaW5fY3VybF9zZXNzaW9ucyA9IDE7CiNlbmRpZgoJCXJldHVybiAwOwoJfQojaWZkZWYgVVNFX0NVUkxfTVVMVEkKCWlmICghc3RyY21wKCJodHRwLm1heHJlcXVlc3RzIiwgdmFyKSkgewoJCW1heF9yZXF1ZXN0cyA9IGdpdF9jb25maWdfaW50KHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQojZW5kaWYKCWlmICghc3RyY21wKCJodHRwLmxvd3NwZWVkbGltaXQiLCB2YXIpKSB7CgkJY3VybF9sb3dfc3BlZWRfbGltaXQgPSAobG9uZylnaXRfY29uZmlnX2ludCh2YXIsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKCJodHRwLmxvd3NwZWVkdGltZSIsIHZhcikpIHsKCQljdXJsX2xvd19zcGVlZF90aW1lID0gKGxvbmcpZ2l0X2NvbmZpZ19pbnQodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKCFzdHJjbXAoImh0dHAubm9lcHN2IiwgdmFyKSkgewoJCWN1cmxfZnRwX25vX2Vwc3YgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCgiaHR0cC5wcm94eSIsIHZhcikpCgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZjdXJsX2h0dHBfcHJveHksIHZhciwgdmFsdWUpOwoKCWlmICghc3RyY21wKCJodHRwLmNvb2tpZWZpbGUiLCB2YXIpKQoJCXJldHVybiBnaXRfY29uZmlnX3N0cmluZygmY3VybF9jb29raWVfZmlsZSwgdmFyLCB2YWx1ZSk7CglpZiAoIXN0cmNtcCgiaHR0cC5zYXZlY29va2llcyIsIHZhcikpIHsKCQljdXJsX3NhdmVfY29va2llcyA9IGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCglpZiAoIXN0cmNtcCgiaHR0cC5wb3N0YnVmZmVyIiwgdmFyKSkgewoJCWh0dHBfcG9zdF9idWZmZXIgPSBnaXRfY29uZmlnX2ludCh2YXIsIHZhbHVlKTsKCQlpZiAoaHR0cF9wb3N0X2J1ZmZlciA8IExBUkdFX1BBQ0tFVF9NQVgpCgkJCWh0dHBfcG9zdF9idWZmZXIgPSBMQVJHRV9QQUNLRVRfTUFYOwoJCXJldHVybiAwOwoJfQoKCWlmICghc3RyY21wKCJodHRwLnVzZXJhZ2VudCIsIHZhcikpCgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZ1c2VyX2FnZW50LCB2YXIsIHZhbHVlKTsKCgkvKiBGYWxsIGJhY2sgb24gdGhlIGRlZmF1bHQgb25lcyAqLwoJcmV0dXJuIGdpdF9kZWZhdWx0X2NvbmZpZyh2YXIsIHZhbHVlLCBjYik7Cn0KCnN0YXRpYyB2b2lkIGluaXRfY3VybF9odHRwX2F1dGgoQ1VSTCAqcmVzdWx0KQp7CglpZiAoIWh0dHBfYXV0aC51c2VybmFtZSkKCQlyZXR1cm47CgoJY3JlZGVudGlhbF9maWxsKCZodHRwX2F1dGgpOwoKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzEzMDEKCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX1VTRVJOQU1FLCBodHRwX2F1dGgudXNlcm5hbWUpOwoJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfUEFTU1dPUkQsIGh0dHBfYXV0aC5wYXNzd29yZCk7CiNlbHNlCgl7CgkJc3RhdGljIHN0cnVjdCBzdHJidWYgdXAgPSBTVFJCVUZfSU5JVDsKCQkvKgoJCSAqIE5vdGUgdGhhdCB3ZSBhc3N1bWUgd2Ugb25seSBldmVyIGhhdmUgYSBzaW5nbGUgc2V0IG9mCgkJICogY3JlZGVudGlhbHMgaW4gYSBnaXZlbiBwcm9ncmFtIHJ1biwgc28gd2UgZG8gbm90IGhhdmUKCQkgKiB0byB3b3JyeSBhYm91dCB1cGRhdGluZyB0aGlzIGJ1ZmZlciwgb25seSBzZXR0aW5nIGl0cwoJCSAqIGluaXRpYWwgdmFsdWUuCgkJICovCgkJaWYgKCF1cC5sZW4pCgkJCXN0cmJ1Zl9hZGRmKCZ1cCwgIiVzOiVzIiwKCQkJCWh0dHBfYXV0aC51c2VybmFtZSwgaHR0cF9hdXRoLnBhc3N3b3JkKTsKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9VU0VSUFdELCB1cC5idWYpOwoJfQojZW5kaWYKfQoKc3RhdGljIGludCBoYXNfY2VydF9wYXNzd29yZCh2b2lkKQp7CglpZiAoc3NsX2NlcnQgPT0gTlVMTCB8fCBzc2xfY2VydF9wYXNzd29yZF9yZXF1aXJlZCAhPSAxKQoJCXJldHVybiAwOwoJaWYgKCFjZXJ0X2F1dGgucGFzc3dvcmQpIHsKCQljZXJ0X2F1dGgucHJvdG9jb2wgPSB4c3RyZHVwKCJjZXJ0Iik7CgkJY2VydF9hdXRoLnVzZXJuYW1lID0geHN0cmR1cCgiIik7CgkJY2VydF9hdXRoLnBhdGggPSB4c3RyZHVwKHNzbF9jZXJ0KTsKCQljcmVkZW50aWFsX2ZpbGwoJmNlcnRfYXV0aCk7Cgl9CglyZXR1cm4gMTsKfQoKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzE5MDAKc3RhdGljIHZvaWQgc2V0X2N1cmxfa2VlcGFsaXZlKENVUkwgKmMpCnsKCWN1cmxfZWFzeV9zZXRvcHQoYywgQ1VSTE9QVF9UQ1BfS0VFUEFMSVZFLCAxKTsKfQoKI2VsaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MTAwMApzdGF0aWMgaW50IHNvY2tvcHRfY2FsbGJhY2sodm9pZCAqY2xpZW50LCBjdXJsX3NvY2tldF90IGZkLCBjdXJsc29ja3R5cGUgdHlwZSkKewoJaW50IGthID0gMTsKCWludCByYzsKCXNvY2tsZW5fdCBsZW4gPSAoc29ja2xlbl90KXNpemVvZihrYSk7CgoJaWYgKHR5cGUgIT0gQ1VSTFNPQ0tUWVBFX0lQQ1hOKQoJCXJldHVybiAwOwoKCXJjID0gc2V0c29ja29wdChmZCwgU09MX1NPQ0tFVCwgU09fS0VFUEFMSVZFLCAodm9pZCAqKSZrYSwgbGVuKTsKCWlmIChyYyA8IDApCgkJd2FybmluZygidW5hYmxlIHRvIHNldCBTT19LRUVQQUxJVkUgb24gc29ja2V0ICVzIiwKCQkJc3RyZXJyb3IoZXJybm8pKTsKCglyZXR1cm4gMDsgLyogQ1VSTF9TT0NLT1BUX09LIG9ubHkgZXhpc3RzIHNpbmNlIGN1cmwgNy4yMS41ICovCn0KCnN0YXRpYyB2b2lkIHNldF9jdXJsX2tlZXBhbGl2ZShDVVJMICpjKQp7CgljdXJsX2Vhc3lfc2V0b3B0KGMsIENVUkxPUFRfU09DS09QVEZVTkNUSU9OLCBzb2Nrb3B0X2NhbGxiYWNrKTsKfQoKI2Vsc2UKc3RhdGljIHZvaWQgc2V0X2N1cmxfa2VlcGFsaXZlKENVUkwgKmMpCnsKCS8qIG5vdCBzdXBwb3J0ZWQgb24gb2xkZXIgY3VybCB2ZXJzaW9ucyAqLwp9CiNlbmRpZgoKc3RhdGljIENVUkwgKmdldF9jdXJsX2hhbmRsZSh2b2lkKQp7CglDVVJMICpyZXN1bHQgPSBjdXJsX2Vhc3lfaW5pdCgpOwoKCWlmICghY3VybF9zc2xfdmVyaWZ5KSB7CgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfU1NMX1ZFUklGWVBFRVIsIDApOwoJCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX1NTTF9WRVJJRllIT1NULCAwKTsKCX0gZWxzZSB7CgkJLyogVmVyaWZ5IGF1dGhlbnRpY2l0eSBvZiB0aGUgcGVlcidzIGNlcnRpZmljYXRlICovCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfU1NMX1ZFUklGWVBFRVIsIDEpOwoJCS8qIFRoZSBuYW1lIGluIHRoZSBjZXJ0IG11c3QgbWF0Y2ggd2hvbSB3ZSB0cmllZCB0byBjb25uZWN0ICovCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfU1NMX1ZFUklGWUhPU1QsIDIpOwoJfQoKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzA5MDcKCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX05FVFJDLCBDVVJMX05FVFJDX09QVElPTkFMKTsKI2VuZGlmCiNpZmRlZiBMSUJDVVJMX0NBTl9IQU5ETEVfQVVUSF9BTlkKCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX0hUVFBBVVRILCBDVVJMQVVUSF9BTlkpOwojZW5kaWYKCglpZiAoaHR0cF9wcm9hY3RpdmVfYXV0aCkKCQlpbml0X2N1cmxfaHR0cF9hdXRoKHJlc3VsdCk7CgoJaWYgKHNzbF9jZXJ0ICE9IE5VTEwpCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfU1NMQ0VSVCwgc3NsX2NlcnQpOwoJaWYgKGhhc19jZXJ0X3Bhc3N3b3JkKCkpCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfS0VZUEFTU1dELCBjZXJ0X2F1dGgucGFzc3dvcmQpOwojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MDkwMwoJaWYgKHNzbF9rZXkgIT0gTlVMTCkKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9TU0xLRVksIHNzbF9rZXkpOwojZW5kaWYKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzA5MDgKCWlmIChzc2xfY2FwYXRoICE9IE5VTEwpCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfQ0FQQVRILCBzc2xfY2FwYXRoKTsKI2VuZGlmCglpZiAoc3NsX2NhaW5mbyAhPSBOVUxMKQoJCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX0NBSU5GTywgc3NsX2NhaW5mbyk7CgoJaWYgKGN1cmxfbG93X3NwZWVkX2xpbWl0ID4gMCAmJiBjdXJsX2xvd19zcGVlZF90aW1lID4gMCkgewoJCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX0xPV19TUEVFRF9MSU1JVCwKCQkJCSBjdXJsX2xvd19zcGVlZF9saW1pdCk7CgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfTE9XX1NQRUVEX1RJTUUsCgkJCQkgY3VybF9sb3dfc3BlZWRfdGltZSk7Cgl9CgoJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfRk9MTE9XTE9DQVRJT04sIDEpOwojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MTMwMQoJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfUE9TVFJFRElSLCBDVVJMX1JFRElSX1BPU1RfQUxMKTsKI2VsaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MTEwMQoJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfUE9TVDMwMSwgMSk7CiNlbmRpZgoKCWlmIChnZXRlbnYoIkdJVF9DVVJMX1ZFUkJPU0UiKSkKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9WRVJCT1NFLCAxKTsKCgljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9VU0VSQUdFTlQsCgkJdXNlcl9hZ2VudCA/IHVzZXJfYWdlbnQgOiBnaXRfdXNlcl9hZ2VudCgpKTsKCglpZiAoY3VybF9mdHBfbm9fZXBzdikKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9GVFBfVVNFX0VQU1YsIDApOwoKI2lmZGVmIENVUkxPUFRfVVNFX1NTTAoJaWYgKGN1cmxfc3NsX3RyeSkKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9VU0VfU1NMLCBDVVJMVVNFU1NMX1RSWSk7CiNlbmRpZgoKCWlmIChjdXJsX2h0dHBfcHJveHkpIHsKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9QUk9YWSwgY3VybF9odHRwX3Byb3h5KTsKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9QUk9YWUFVVEgsIENVUkxBVVRIX0FOWSk7Cgl9CgoJc2V0X2N1cmxfa2VlcGFsaXZlKHJlc3VsdCk7CgoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIHZvaWQgc2V0X2Zyb21fZW52KGNvbnN0IGNoYXIgKip2YXIsIGNvbnN0IGNoYXIgKmVudm5hbWUpCnsKCWNvbnN0IGNoYXIgKnZhbCA9IGdldGVudihlbnZuYW1lKTsKCWlmICh2YWwpCgkJKnZhciA9IHZhbDsKfQoKdm9pZCBodHRwX2luaXQoc3RydWN0IHJlbW90ZSAqcmVtb3RlLCBjb25zdCBjaGFyICp1cmwsIGludCBwcm9hY3RpdmVfYXV0aCkKewoJY2hhciAqbG93X3NwZWVkX2xpbWl0OwoJY2hhciAqbG93X3NwZWVkX3RpbWU7CgljaGFyICpub3JtYWxpemVkX3VybDsKCXN0cnVjdCB1cmxtYXRjaF9jb25maWcgY29uZmlnID0geyBTVFJJTkdfTElTVF9JTklUX0RVUCB9OwoKCWNvbmZpZy5zZWN0aW9uID0gImh0dHAiOwoJY29uZmlnLmtleSA9IE5VTEw7Cgljb25maWcuY29sbGVjdF9mbiA9IGh0dHBfb3B0aW9uczsKCWNvbmZpZy5jYXNjYWRlX2ZuID0gZ2l0X2RlZmF1bHRfY29uZmlnOwoJY29uZmlnLmNiID0gTlVMTDsKCglodHRwX2lzX3ZlcmJvc2UgPSAwOwoJbm9ybWFsaXplZF91cmwgPSB1cmxfbm9ybWFsaXplKHVybCwgJmNvbmZpZy51cmwpOwoKCWdpdF9jb25maWcodXJsbWF0Y2hfY29uZmlnX2VudHJ5LCAmY29uZmlnKTsKCWZyZWUobm9ybWFsaXplZF91cmwpOwoKCWN1cmxfZ2xvYmFsX2luaXQoQ1VSTF9HTE9CQUxfQUxMKTsKCglodHRwX3Byb2FjdGl2ZV9hdXRoID0gcHJvYWN0aXZlX2F1dGg7CgoJaWYgKHJlbW90ZSAmJiByZW1vdGUtPmh0dHBfcHJveHkpCgkJY3VybF9odHRwX3Byb3h5ID0geHN0cmR1cChyZW1vdGUtPmh0dHBfcHJveHkpOwoKCXByYWdtYV9oZWFkZXIgPSBjdXJsX3NsaXN0X2FwcGVuZChwcmFnbWFfaGVhZGVyLCAiUHJhZ21hOiBuby1jYWNoZSIpOwoJbm9fcHJhZ21hX2hlYWRlciA9IGN1cmxfc2xpc3RfYXBwZW5kKG5vX3ByYWdtYV9oZWFkZXIsICJQcmFnbWE6Iik7CgojaWZkZWYgVVNFX0NVUkxfTVVMVEkKCXsKCQljaGFyICpodHRwX21heF9yZXF1ZXN0cyA9IGdldGVudigiR0lUX0hUVFBfTUFYX1JFUVVFU1RTIik7CgkJaWYgKGh0dHBfbWF4X3JlcXVlc3RzICE9IE5VTEwpCgkJCW1heF9yZXF1ZXN0cyA9IGF0b2koaHR0cF9tYXhfcmVxdWVzdHMpOwoJfQoKCWN1cmxtID0gY3VybF9tdWx0aV9pbml0KCk7CglpZiAoY3VybG0gPT0gTlVMTCkgewoJCWZwcmludGYoc3RkZXJyLCAiRXJyb3IgY3JlYXRpbmcgY3VybCBtdWx0aSBoYW5kbGUuXG4iKTsKCQlleGl0KDEpOwoJfQojZW5kaWYKCglpZiAoZ2V0ZW52KCJHSVRfU1NMX05PX1ZFUklGWSIpKQoJCWN1cmxfc3NsX3ZlcmlmeSA9IDA7CgoJc2V0X2Zyb21fZW52KCZzc2xfY2VydCwgIkdJVF9TU0xfQ0VSVCIpOwojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MDkwMwoJc2V0X2Zyb21fZW52KCZzc2xfa2V5LCAiR0lUX1NTTF9LRVkiKTsKI2VuZGlmCiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwOTA4CglzZXRfZnJvbV9lbnYoJnNzbF9jYXBhdGgsICJHSVRfU1NMX0NBUEFUSCIpOwojZW5kaWYKCXNldF9mcm9tX2Vudigmc3NsX2NhaW5mbywgIkdJVF9TU0xfQ0FJTkZPIik7CgoJc2V0X2Zyb21fZW52KCZ1c2VyX2FnZW50LCAiR0lUX0hUVFBfVVNFUl9BR0VOVCIpOwoKCWxvd19zcGVlZF9saW1pdCA9IGdldGVudigiR0lUX0hUVFBfTE9XX1NQRUVEX0xJTUlUIik7CglpZiAobG93X3NwZWVkX2xpbWl0ICE9IE5VTEwpCgkJY3VybF9sb3dfc3BlZWRfbGltaXQgPSBzdHJ0b2wobG93X3NwZWVkX2xpbWl0LCBOVUxMLCAxMCk7Cglsb3dfc3BlZWRfdGltZSA9IGdldGVudigiR0lUX0hUVFBfTE9XX1NQRUVEX1RJTUUiKTsKCWlmIChsb3dfc3BlZWRfdGltZSAhPSBOVUxMKQoJCWN1cmxfbG93X3NwZWVkX3RpbWUgPSBzdHJ0b2wobG93X3NwZWVkX3RpbWUsIE5VTEwsIDEwKTsKCglpZiAoY3VybF9zc2xfdmVyaWZ5ID09IC0xKQoJCWN1cmxfc3NsX3ZlcmlmeSA9IDE7CgoJY3VybF9zZXNzaW9uX2NvdW50ID0gMDsKI2lmZGVmIFVTRV9DVVJMX01VTFRJCglpZiAobWF4X3JlcXVlc3RzIDwgMSkKCQltYXhfcmVxdWVzdHMgPSBERUZBVUxUX01BWF9SRVFVRVNUUzsKI2VuZGlmCgoJaWYgKGdldGVudigiR0lUX0NVUkxfRlRQX05PX0VQU1YiKSkKCQljdXJsX2Z0cF9ub19lcHN2ID0gMTsKCglpZiAodXJsKSB7CgkJY3JlZGVudGlhbF9mcm9tX3VybCgmaHR0cF9hdXRoLCB1cmwpOwoJCWlmICghc3NsX2NlcnRfcGFzc3dvcmRfcmVxdWlyZWQgJiYKCQkgICAgZ2V0ZW52KCJHSVRfU1NMX0NFUlRfUEFTU1dPUkRfUFJPVEVDVEVEIikgJiYKCQkgICAgc3RhcnRzX3dpdGgodXJsLCAiaHR0cHM6Ly8iKSkKCQkJc3NsX2NlcnRfcGFzc3dvcmRfcmVxdWlyZWQgPSAxOwoJfQoKI2lmbmRlZiBOT19DVVJMX0VBU1lfRFVQSEFORExFCgljdXJsX2RlZmF1bHQgPSBnZXRfY3VybF9oYW5kbGUoKTsKI2VuZGlmCn0KCnZvaWQgaHR0cF9jbGVhbnVwKHZvaWQpCnsKCXN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90ID0gYWN0aXZlX3F1ZXVlX2hlYWQ7CgoJd2hpbGUgKHNsb3QgIT0gTlVMTCkgewoJCXN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpuZXh0ID0gc2xvdC0+bmV4dDsKCQlpZiAoc2xvdC0+Y3VybCAhPSBOVUxMKSB7CiNpZmRlZiBVU0VfQ1VSTF9NVUxUSQoJCQljdXJsX211bHRpX3JlbW92ZV9oYW5kbGUoY3VybG0sIHNsb3QtPmN1cmwpOwojZW5kaWYKCQkJY3VybF9lYXN5X2NsZWFudXAoc2xvdC0+Y3VybCk7CgkJfQoJCWZyZWUoc2xvdCk7CgkJc2xvdCA9IG5leHQ7Cgl9CglhY3RpdmVfcXVldWVfaGVhZCA9IE5VTEw7CgojaWZuZGVmIE5PX0NVUkxfRUFTWV9EVVBIQU5ETEUKCWN1cmxfZWFzeV9jbGVhbnVwKGN1cmxfZGVmYXVsdCk7CiNlbmRpZgoKI2lmZGVmIFVTRV9DVVJMX01VTFRJCgljdXJsX211bHRpX2NsZWFudXAoY3VybG0pOwojZW5kaWYKCWN1cmxfZ2xvYmFsX2NsZWFudXAoKTsKCgljdXJsX3NsaXN0X2ZyZWVfYWxsKHByYWdtYV9oZWFkZXIpOwoJcHJhZ21hX2hlYWRlciA9IE5VTEw7CgoJY3VybF9zbGlzdF9mcmVlX2FsbChub19wcmFnbWFfaGVhZGVyKTsKCW5vX3ByYWdtYV9oZWFkZXIgPSBOVUxMOwoKCWlmIChjdXJsX2h0dHBfcHJveHkpIHsKCQlmcmVlKCh2b2lkICopY3VybF9odHRwX3Byb3h5KTsKCQljdXJsX2h0dHBfcHJveHkgPSBOVUxMOwoJfQoKCWlmIChjZXJ0X2F1dGgucGFzc3dvcmQgIT0gTlVMTCkgewoJCW1lbXNldChjZXJ0X2F1dGgucGFzc3dvcmQsIDAsIHN0cmxlbihjZXJ0X2F1dGgucGFzc3dvcmQpKTsKCQlmcmVlKGNlcnRfYXV0aC5wYXNzd29yZCk7CgkJY2VydF9hdXRoLnBhc3N3b3JkID0gTlVMTDsKCX0KCXNzbF9jZXJ0X3Bhc3N3b3JkX3JlcXVpcmVkID0gMDsKfQoKc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKmdldF9hY3RpdmVfc2xvdCh2b2lkKQp7CglzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdCA9IGFjdGl2ZV9xdWV1ZV9oZWFkOwoJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKm5ld3Nsb3Q7CgojaWZkZWYgVVNFX0NVUkxfTVVMVEkKCWludCBudW1fdHJhbnNmZXJzOwoKCS8qIFdhaXQgZm9yIGEgc2xvdCB0byBvcGVuIHVwIGlmIHRoZSBxdWV1ZSBpcyBmdWxsICovCgl3aGlsZSAoYWN0aXZlX3JlcXVlc3RzID49IG1heF9yZXF1ZXN0cykgewoJCWN1cmxfbXVsdGlfcGVyZm9ybShjdXJsbSwgJm51bV90cmFuc2ZlcnMpOwoJCWlmIChudW1fdHJhbnNmZXJzIDwgYWN0aXZlX3JlcXVlc3RzKQoJCQlwcm9jZXNzX2N1cmxfbWVzc2FnZXMoKTsKCX0KI2VuZGlmCgoJd2hpbGUgKHNsb3QgIT0gTlVMTCAmJiBzbG90LT5pbl91c2UpCgkJc2xvdCA9IHNsb3QtPm5leHQ7CgoJaWYgKHNsb3QgPT0gTlVMTCkgewoJCW5ld3Nsb3QgPSB4bWFsbG9jKHNpemVvZigqbmV3c2xvdCkpOwoJCW5ld3Nsb3QtPmN1cmwgPSBOVUxMOwoJCW5ld3Nsb3QtPmluX3VzZSA9IDA7CgkJbmV3c2xvdC0+bmV4dCA9IE5VTEw7CgoJCXNsb3QgPSBhY3RpdmVfcXVldWVfaGVhZDsKCQlpZiAoc2xvdCA9PSBOVUxMKSB7CgkJCWFjdGl2ZV9xdWV1ZV9oZWFkID0gbmV3c2xvdDsKCQl9IGVsc2UgewoJCQl3aGlsZSAoc2xvdC0+bmV4dCAhPSBOVUxMKQoJCQkJc2xvdCA9IHNsb3QtPm5leHQ7CgkJCXNsb3QtPm5leHQgPSBuZXdzbG90OwoJCX0KCQlzbG90ID0gbmV3c2xvdDsKCX0KCglpZiAoc2xvdC0+Y3VybCA9PSBOVUxMKSB7CiNpZmRlZiBOT19DVVJMX0VBU1lfRFVQSEFORExFCgkJc2xvdC0+Y3VybCA9IGdldF9jdXJsX2hhbmRsZSgpOwojZWxzZQoJCXNsb3QtPmN1cmwgPSBjdXJsX2Vhc3lfZHVwaGFuZGxlKGN1cmxfZGVmYXVsdCk7CiNlbmRpZgoJCWN1cmxfc2Vzc2lvbl9jb3VudCsrOwoJfQoKCWFjdGl2ZV9yZXF1ZXN0cysrOwoJc2xvdC0+aW5fdXNlID0gMTsKCXNsb3QtPnJlc3VsdHMgPSBOVUxMOwoJc2xvdC0+ZmluaXNoZWQgPSBOVUxMOwoJc2xvdC0+Y2FsbGJhY2tfZGF0YSA9IE5VTEw7CglzbG90LT5jYWxsYmFja19mdW5jID0gTlVMTDsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9DT09LSUVGSUxFLCBjdXJsX2Nvb2tpZV9maWxlKTsKCWlmIChjdXJsX3NhdmVfY29va2llcykKCQljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfQ09PS0lFSkFSLCBjdXJsX2Nvb2tpZV9maWxlKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9IVFRQSEVBREVSLCBwcmFnbWFfaGVhZGVyKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9FUlJPUkJVRkZFUiwgY3VybF9lcnJvcnN0cik7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfQ1VTVE9NUkVRVUVTVCwgTlVMTCk7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfUkVBREZVTkNUSU9OLCBOVUxMKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9XUklURUZVTkNUSU9OLCBOVUxMKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NURklFTERTLCBOVUxMKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9VUExPQUQsIDApOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0hUVFBHRVQsIDEpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0ZBSUxPTkVSUk9SLCAxKTsKCWlmIChodHRwX2F1dGgucGFzc3dvcmQpCgkJaW5pdF9jdXJsX2h0dHBfYXV0aChzbG90LT5jdXJsKTsKCglyZXR1cm4gc2xvdDsKfQoKaW50IHN0YXJ0X2FjdGl2ZV9zbG90KHN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90KQp7CiNpZmRlZiBVU0VfQ1VSTF9NVUxUSQoJQ1VSTE1jb2RlIGN1cmxtX3Jlc3VsdCA9IGN1cmxfbXVsdGlfYWRkX2hhbmRsZShjdXJsbSwgc2xvdC0+Y3VybCk7CglpbnQgbnVtX3RyYW5zZmVyczsKCglpZiAoY3VybG1fcmVzdWx0ICE9IENVUkxNX09LICYmCgkgICAgY3VybG1fcmVzdWx0ICE9IENVUkxNX0NBTExfTVVMVElfUEVSRk9STSkgewoJCWFjdGl2ZV9yZXF1ZXN0cy0tOwoJCXNsb3QtPmluX3VzZSA9IDA7CgkJcmV0dXJuIDA7Cgl9CgoJLyoKCSAqIFdlIGtub3cgdGhlcmUgbXVzdCBiZSBzb21ldGhpbmcgdG8gZG8sIHNpbmNlIHdlIGp1c3QgYWRkZWQKCSAqIHNvbWV0aGluZy4KCSAqLwoJY3VybF9tdWx0aV9wZXJmb3JtKGN1cmxtLCAmbnVtX3RyYW5zZmVycyk7CiNlbmRpZgoJcmV0dXJuIDE7Cn0KCiNpZmRlZiBVU0VfQ1VSTF9NVUxUSQpzdHJ1Y3QgZmlsbF9jaGFpbiB7Cgl2b2lkICpkYXRhOwoJaW50ICgqZmlsbCkodm9pZCAqKTsKCXN0cnVjdCBmaWxsX2NoYWluICpuZXh0Owp9OwoKc3RhdGljIHN0cnVjdCBmaWxsX2NoYWluICpmaWxsX2NmZzsKCnZvaWQgYWRkX2ZpbGxfZnVuY3Rpb24odm9pZCAqZGF0YSwgaW50ICgqZmlsbCkodm9pZCAqKSkKewoJc3RydWN0IGZpbGxfY2hhaW4gKm5ldyA9IHhtYWxsb2Moc2l6ZW9mKCpuZXcpKTsKCXN0cnVjdCBmaWxsX2NoYWluICoqbGlua3AgPSAmZmlsbF9jZmc7CgluZXctPmRhdGEgPSBkYXRhOwoJbmV3LT5maWxsID0gZmlsbDsKCW5ldy0+bmV4dCA9IE5VTEw7Cgl3aGlsZSAoKmxpbmtwKQoJCWxpbmtwID0gJigqbGlua3ApLT5uZXh0OwoJKmxpbmtwID0gbmV3Owp9Cgp2b2lkIGZpbGxfYWN0aXZlX3Nsb3RzKHZvaWQpCnsKCXN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90ID0gYWN0aXZlX3F1ZXVlX2hlYWQ7CgoJd2hpbGUgKGFjdGl2ZV9yZXF1ZXN0cyA8IG1heF9yZXF1ZXN0cykgewoJCXN0cnVjdCBmaWxsX2NoYWluICpmaWxsOwoJCWZvciAoZmlsbCA9IGZpbGxfY2ZnOyBmaWxsOyBmaWxsID0gZmlsbC0+bmV4dCkKCQkJaWYgKGZpbGwtPmZpbGwoZmlsbC0+ZGF0YSkpCgkJCQlicmVhazsKCgkJaWYgKCFmaWxsKQoJCQlicmVhazsKCX0KCgl3aGlsZSAoc2xvdCAhPSBOVUxMKSB7CgkJaWYgKCFzbG90LT5pbl91c2UgJiYgc2xvdC0+Y3VybCAhPSBOVUxMCgkJCSYmIGN1cmxfc2Vzc2lvbl9jb3VudCA+IG1pbl9jdXJsX3Nlc3Npb25zKSB7CgkJCWN1cmxfZWFzeV9jbGVhbnVwKHNsb3QtPmN1cmwpOwoJCQlzbG90LT5jdXJsID0gTlVMTDsKCQkJY3VybF9zZXNzaW9uX2NvdW50LS07CgkJfQoJCXNsb3QgPSBzbG90LT5uZXh0OwoJfQp9Cgp2b2lkIHN0ZXBfYWN0aXZlX3Nsb3RzKHZvaWQpCnsKCWludCBudW1fdHJhbnNmZXJzOwoJQ1VSTE1jb2RlIGN1cmxtX3Jlc3VsdDsKCglkbyB7CgkJY3VybG1fcmVzdWx0ID0gY3VybF9tdWx0aV9wZXJmb3JtKGN1cmxtLCAmbnVtX3RyYW5zZmVycyk7Cgl9IHdoaWxlIChjdXJsbV9yZXN1bHQgPT0gQ1VSTE1fQ0FMTF9NVUxUSV9QRVJGT1JNKTsKCWlmIChudW1fdHJhbnNmZXJzIDwgYWN0aXZlX3JlcXVlc3RzKSB7CgkJcHJvY2Vzc19jdXJsX21lc3NhZ2VzKCk7CgkJZmlsbF9hY3RpdmVfc2xvdHMoKTsKCX0KfQojZW5kaWYKCnZvaWQgcnVuX2FjdGl2ZV9zbG90KHN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90KQp7CiNpZmRlZiBVU0VfQ1VSTF9NVUxUSQoJZmRfc2V0IHJlYWRmZHM7CglmZF9zZXQgd3JpdGVmZHM7CglmZF9zZXQgZXhjZmRzOwoJaW50IG1heF9mZDsKCXN0cnVjdCB0aW1ldmFsIHNlbGVjdF90aW1lb3V0OwoJaW50IGZpbmlzaGVkID0gMDsKCglzbG90LT5maW5pc2hlZCA9ICZmaW5pc2hlZDsKCXdoaWxlICghZmluaXNoZWQpIHsKCQlzdGVwX2FjdGl2ZV9zbG90cygpOwoKCQlpZiAoc2xvdC0+aW5fdXNlKSB7CiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwZjA0CgkJCWxvbmcgY3VybF90aW1lb3V0OwoJCQljdXJsX211bHRpX3RpbWVvdXQoY3VybG0sICZjdXJsX3RpbWVvdXQpOwoJCQlpZiAoY3VybF90aW1lb3V0ID09IDApIHsKCQkJCWNvbnRpbnVlOwoJCQl9IGVsc2UgaWYgKGN1cmxfdGltZW91dCA9PSAtMSkgewoJCQkJc2VsZWN0X3RpbWVvdXQudHZfc2VjICA9IDA7CgkJCQlzZWxlY3RfdGltZW91dC50dl91c2VjID0gNTAwMDA7CgkJCX0gZWxzZSB7CgkJCQlzZWxlY3RfdGltZW91dC50dl9zZWMgID0gIGN1cmxfdGltZW91dCAvIDEwMDA7CgkJCQlzZWxlY3RfdGltZW91dC50dl91c2VjID0gKGN1cmxfdGltZW91dCAlIDEwMDApICogMTAwMDsKCQkJfQojZWxzZQoJCQlzZWxlY3RfdGltZW91dC50dl9zZWMgID0gMDsKCQkJc2VsZWN0X3RpbWVvdXQudHZfdXNlYyA9IDUwMDAwOwojZW5kaWYKCgkJCW1heF9mZCA9IC0xOwoJCQlGRF9aRVJPKCZyZWFkZmRzKTsKCQkJRkRfWkVSTygmd3JpdGVmZHMpOwoJCQlGRF9aRVJPKCZleGNmZHMpOwoJCQljdXJsX211bHRpX2Zkc2V0KGN1cmxtLCAmcmVhZGZkcywgJndyaXRlZmRzLCAmZXhjZmRzLCAmbWF4X2ZkKTsKCgkJCS8qCgkJCSAqIEl0IGNhbiBoYXBwZW4gdGhhdCBjdXJsX211bHRpX3RpbWVvdXQgcmV0dXJucyBhIHBhdGhvbG9naWNhbGx5CgkJCSAqIGxvbmcgdGltZW91dCB3aGVuIGN1cmxfbXVsdGlfZmRzZXQgcmV0dXJucyBubyBmaWxlIGRlc2NyaXB0b3JzCgkJCSAqIHRvIHJlYWQuICBTZWUgY29tbWl0IG1lc3NhZ2UgZm9yIG1vcmUgZGV0YWlscy4KCQkJICovCgkJCWlmIChtYXhfZmQgPCAwICYmCgkJCSAgICAoc2VsZWN0X3RpbWVvdXQudHZfc2VjID4gMCB8fAoJCQkgICAgIHNlbGVjdF90aW1lb3V0LnR2X3VzZWMgPiA1MDAwMCkpIHsKCQkJCXNlbGVjdF90aW1lb3V0LnR2X3NlYyAgPSAwOwoJCQkJc2VsZWN0X3RpbWVvdXQudHZfdXNlYyA9IDUwMDAwOwoJCQl9CgoJCQlzZWxlY3QobWF4X2ZkKzEsICZyZWFkZmRzLCAmd3JpdGVmZHMsICZleGNmZHMsICZzZWxlY3RfdGltZW91dCk7CgkJfQoJfQojZWxzZQoJd2hpbGUgKHNsb3QtPmluX3VzZSkgewoJCXNsb3QtPmN1cmxfcmVzdWx0ID0gY3VybF9lYXN5X3BlcmZvcm0oc2xvdC0+Y3VybCk7CgkJZmluaXNoX2FjdGl2ZV9zbG90KHNsb3QpOwoJfQojZW5kaWYKfQoKc3RhdGljIHZvaWQgY2xvc2Vkb3duX2FjdGl2ZV9zbG90KHN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90KQp7CglhY3RpdmVfcmVxdWVzdHMtLTsKCXNsb3QtPmluX3VzZSA9IDA7Cn0KCnN0YXRpYyB2b2lkIHJlbGVhc2VfYWN0aXZlX3Nsb3Qoc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3QpCnsKCWNsb3NlZG93bl9hY3RpdmVfc2xvdChzbG90KTsKCWlmIChzbG90LT5jdXJsICYmIGN1cmxfc2Vzc2lvbl9jb3VudCA+IG1pbl9jdXJsX3Nlc3Npb25zKSB7CiNpZmRlZiBVU0VfQ1VSTF9NVUxUSQoJCWN1cmxfbXVsdGlfcmVtb3ZlX2hhbmRsZShjdXJsbSwgc2xvdC0+Y3VybCk7CiNlbmRpZgoJCWN1cmxfZWFzeV9jbGVhbnVwKHNsb3QtPmN1cmwpOwoJCXNsb3QtPmN1cmwgPSBOVUxMOwoJCWN1cmxfc2Vzc2lvbl9jb3VudC0tOwoJfQojaWZkZWYgVVNFX0NVUkxfTVVMVEkKCWZpbGxfYWN0aXZlX3Nsb3RzKCk7CiNlbmRpZgp9Cgp2b2lkIGZpbmlzaF9hY3RpdmVfc2xvdChzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdCkKewoJY2xvc2Vkb3duX2FjdGl2ZV9zbG90KHNsb3QpOwoJY3VybF9lYXN5X2dldGluZm8oc2xvdC0+Y3VybCwgQ1VSTElORk9fSFRUUF9DT0RFLCAmc2xvdC0+aHR0cF9jb2RlKTsKCglpZiAoc2xvdC0+ZmluaXNoZWQgIT0gTlVMTCkKCQkoKnNsb3QtPmZpbmlzaGVkKSA9IDE7CgoJLyogU3RvcmUgc2xvdCByZXN1bHRzIHNvIHRoZXkgY2FuIGJlIHJlYWQgYWZ0ZXIgdGhlIHNsb3QgaXMgcmV1c2VkICovCglpZiAoc2xvdC0+cmVzdWx0cyAhPSBOVUxMKSB7CgkJc2xvdC0+cmVzdWx0cy0+Y3VybF9yZXN1bHQgPSBzbG90LT5jdXJsX3Jlc3VsdDsKCQlzbG90LT5yZXN1bHRzLT5odHRwX2NvZGUgPSBzbG90LT5odHRwX2NvZGU7CiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwYTA4CgkJY3VybF9lYXN5X2dldGluZm8oc2xvdC0+Y3VybCwgQ1VSTElORk9fSFRUUEFVVEhfQVZBSUwsCgkJCQkgICZzbG90LT5yZXN1bHRzLT5hdXRoX2F2YWlsKTsKI2Vsc2UKCQlzbG90LT5yZXN1bHRzLT5hdXRoX2F2YWlsID0gMDsKI2VuZGlmCgl9CgoJLyogUnVuIGNhbGxiYWNrIGlmIGFwcHJvcHJpYXRlICovCglpZiAoc2xvdC0+Y2FsbGJhY2tfZnVuYyAhPSBOVUxMKQoJCXNsb3QtPmNhbGxiYWNrX2Z1bmMoc2xvdC0+Y2FsbGJhY2tfZGF0YSk7Cn0KCnZvaWQgZmluaXNoX2FsbF9hY3RpdmVfc2xvdHModm9pZCkKewoJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3QgPSBhY3RpdmVfcXVldWVfaGVhZDsKCgl3aGlsZSAoc2xvdCAhPSBOVUxMKQoJCWlmIChzbG90LT5pbl91c2UpIHsKCQkJcnVuX2FjdGl2ZV9zbG90KHNsb3QpOwoJCQlzbG90ID0gYWN0aXZlX3F1ZXVlX2hlYWQ7CgkJfSBlbHNlIHsKCQkJc2xvdCA9IHNsb3QtPm5leHQ7CgkJfQp9CgovKiBIZWxwZXJzIGZvciBtb2RpZnlpbmcgYW5kIGNyZWF0aW5nIFVSTHMgKi8Kc3RhdGljIGlubGluZSBpbnQgbmVlZHNfcXVvdGUoaW50IGNoKQp7CglpZiAoKChjaCA+PSAnQScpICYmIChjaCA8PSAnWicpKQoJCQl8fCAoKGNoID49ICdhJykgJiYgKGNoIDw9ICd6JykpCgkJCXx8ICgoY2ggPj0gJzAnKSAmJiAoY2ggPD0gJzknKSkKCQkJfHwgKGNoID09ICcvJykKCQkJfHwgKGNoID09ICctJykKCQkJfHwgKGNoID09ICcuJykpCgkJcmV0dXJuIDA7CglyZXR1cm4gMTsKfQoKc3RhdGljIGNoYXIgKnF1b3RlX3JlZl91cmwoY29uc3QgY2hhciAqYmFzZSwgY29uc3QgY2hhciAqcmVmKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJY29uc3QgY2hhciAqY3A7CglpbnQgY2g7CgoJZW5kX3VybF93aXRoX3NsYXNoKCZidWYsIGJhc2UpOwoKCWZvciAoY3AgPSByZWY7IChjaCA9ICpjcCkgIT0gMDsgY3ArKykKCQlpZiAobmVlZHNfcXVvdGUoY2gpKQoJCQlzdHJidWZfYWRkZigmYnVmLCAiJSUlMDJ4IiwgY2gpOwoJCWVsc2UKCQkJc3RyYnVmX2FkZGNoKCZidWYsICpjcCk7CgoJcmV0dXJuIHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7Cn0KCnZvaWQgYXBwZW5kX3JlbW90ZV9vYmplY3RfdXJsKHN0cnVjdCBzdHJidWYgKmJ1ZiwgY29uc3QgY2hhciAqdXJsLAoJCQkgICAgICBjb25zdCBjaGFyICpoZXgsCgkJCSAgICAgIGludCBvbmx5X3R3b19kaWdpdF9wcmVmaXgpCnsKCWVuZF91cmxfd2l0aF9zbGFzaChidWYsIHVybCk7CgoJc3RyYnVmX2FkZGYoYnVmLCAib2JqZWN0cy8lLipzLyIsIDIsIGhleCk7CglpZiAoIW9ubHlfdHdvX2RpZ2l0X3ByZWZpeCkKCQlzdHJidWZfYWRkZihidWYsICIlcyIsIGhleCsyKTsKfQoKY2hhciAqZ2V0X3JlbW90ZV9vYmplY3RfdXJsKGNvbnN0IGNoYXIgKnVybCwgY29uc3QgY2hhciAqaGV4LAoJCQkgICAgaW50IG9ubHlfdHdvX2RpZ2l0X3ByZWZpeCkKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWFwcGVuZF9yZW1vdGVfb2JqZWN0X3VybCgmYnVmLCB1cmwsIGhleCwgb25seV90d29fZGlnaXRfcHJlZml4KTsKCXJldHVybiBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpOwp9CgppbnQgaGFuZGxlX2N1cmxfcmVzdWx0KHN0cnVjdCBzbG90X3Jlc3VsdHMgKnJlc3VsdHMpCnsKCS8qCgkgKiBJZiB3ZSBzZWUgYSBmYWlsaW5nIGh0dHAgY29kZSB3aXRoIENVUkxFX09LLCB3ZSBoYXZlIHR1cm5lZCBvZmYKCSAqIEZBSUxPTkVSUk9SICh0byBrZWVwIHRoZSBzZXJ2ZXIncyBjdXN0b20gZXJyb3IgcmVzcG9uc2UpLCBhbmQgc2hvdWxkCgkgKiB0cmFuc2xhdGUgdGhlIGNvZGUgaW50byBmYWlsdXJlIGhlcmUuCgkgKi8KCWlmIChyZXN1bHRzLT5jdXJsX3Jlc3VsdCA9PSBDVVJMRV9PSyAmJgoJICAgIHJlc3VsdHMtPmh0dHBfY29kZSA+PSA0MDApIHsKCQlyZXN1bHRzLT5jdXJsX3Jlc3VsdCA9IENVUkxFX0hUVFBfUkVUVVJORURfRVJST1I7CgkJLyoKCQkgKiBOb3JtYWxseSBjdXJsIHdpbGwgYWxyZWFkeSBoYXZlIHB1dCB0aGUgInJlYXNvbiBwaHJhc2UiCgkJICogZnJvbSB0aGUgc2VydmVyIGludG8gY3VybF9lcnJvcnN0cjsgdW5mb3J0dW5hdGVseSB3aXRob3V0CgkJICogRkFJTE9ORVJST1IgaXQgaXMgbG9zdCwgc28gd2UgY2FuIGdpdmUgb25seSB0aGUgbnVtZXJpYwoJCSAqIHN0YXR1cyBjb2RlLgoJCSAqLwoJCXNucHJpbnRmKGN1cmxfZXJyb3JzdHIsIHNpemVvZihjdXJsX2Vycm9yc3RyKSwKCQkJICJUaGUgcmVxdWVzdGVkIFVSTCByZXR1cm5lZCBlcnJvcjogJWxkIiwKCQkJIHJlc3VsdHMtPmh0dHBfY29kZSk7Cgl9CgoJaWYgKHJlc3VsdHMtPmN1cmxfcmVzdWx0ID09IENVUkxFX09LKSB7CgkJY3JlZGVudGlhbF9hcHByb3ZlKCZodHRwX2F1dGgpOwoJCXJldHVybiBIVFRQX09LOwoJfSBlbHNlIGlmIChtaXNzaW5nX3RhcmdldChyZXN1bHRzKSkKCQlyZXR1cm4gSFRUUF9NSVNTSU5HX1RBUkdFVDsKCWVsc2UgaWYgKHJlc3VsdHMtPmh0dHBfY29kZSA9PSA0MDEpIHsKCQlpZiAoaHR0cF9hdXRoLnVzZXJuYW1lICYmIGh0dHBfYXV0aC5wYXNzd29yZCkgewoJCQljcmVkZW50aWFsX3JlamVjdCgmaHR0cF9hdXRoKTsKCQkJcmV0dXJuIEhUVFBfTk9BVVRIOwoJCX0gZWxzZSB7CgkJCXJldHVybiBIVFRQX1JFQVVUSDsKCQl9Cgl9IGVsc2UgewojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MGMwMAoJCWlmICghY3VybF9lcnJvcnN0clswXSkKCQkJc3RybGNweShjdXJsX2Vycm9yc3RyLAoJCQkJY3VybF9lYXN5X3N0cmVycm9yKHJlc3VsdHMtPmN1cmxfcmVzdWx0KSwKCQkJCXNpemVvZihjdXJsX2Vycm9yc3RyKSk7CiNlbmRpZgoJCXJldHVybiBIVFRQX0VSUk9SOwoJfQp9CgppbnQgcnVuX29uZV9zbG90KHN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90LAoJCSBzdHJ1Y3Qgc2xvdF9yZXN1bHRzICpyZXN1bHRzKQp7CglzbG90LT5yZXN1bHRzID0gcmVzdWx0czsKCWlmICghc3RhcnRfYWN0aXZlX3Nsb3Qoc2xvdCkpIHsKCQlzbnByaW50ZihjdXJsX2Vycm9yc3RyLCBzaXplb2YoY3VybF9lcnJvcnN0ciksCgkJCSAiZmFpbGVkIHRvIHN0YXJ0IEhUVFAgcmVxdWVzdCIpOwoJCXJldHVybiBIVFRQX1NUQVJUX0ZBSUxFRDsKCX0KCglydW5fYWN0aXZlX3Nsb3Qoc2xvdCk7CglyZXR1cm4gaGFuZGxlX2N1cmxfcmVzdWx0KHJlc3VsdHMpOwp9CgpzdGF0aWMgQ1VSTGNvZGUgY3VybGluZm9fc3RyYnVmKENVUkwgKmN1cmwsIENVUkxJTkZPIGluZm8sIHN0cnVjdCBzdHJidWYgKmJ1ZikKewoJY2hhciAqcHRyOwoJQ1VSTGNvZGUgcmV0OwoKCXN0cmJ1Zl9yZXNldChidWYpOwoJcmV0ID0gY3VybF9lYXN5X2dldGluZm8oY3VybCwgaW5mbywgJnB0cik7CglpZiAoIXJldCAmJiBwdHIpCgkJc3RyYnVmX2FkZHN0cihidWYsIHB0cik7CglyZXR1cm4gcmV0Owp9CgovKiBodHRwX3JlcXVlc3QoKSB0YXJnZXRzICovCiNkZWZpbmUgSFRUUF9SRVFVRVNUX1NUUkJVRgkwCiNkZWZpbmUgSFRUUF9SRVFVRVNUX0ZJTEUJMQoKc3RhdGljIGludCBodHRwX3JlcXVlc3QoY29uc3QgY2hhciAqdXJsLAoJCQl2b2lkICpyZXN1bHQsIGludCB0YXJnZXQsCgkJCWNvbnN0IHN0cnVjdCBodHRwX2dldF9vcHRpb25zICpvcHRpb25zKQp7CglzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdDsKCXN0cnVjdCBzbG90X3Jlc3VsdHMgcmVzdWx0czsKCXN0cnVjdCBjdXJsX3NsaXN0ICpoZWFkZXJzID0gTlVMTDsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglpbnQgcmV0OwoKCXNsb3QgPSBnZXRfYWN0aXZlX3Nsb3QoKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9IVFRQR0VULCAxKTsKCglpZiAocmVzdWx0ID09IE5VTEwpIHsKCQljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfTk9CT0RZLCAxKTsKCX0gZWxzZSB7CgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX05PQk9EWSwgMCk7CgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0ZJTEUsIHJlc3VsdCk7CgoJCWlmICh0YXJnZXQgPT0gSFRUUF9SRVFVRVNUX0ZJTEUpIHsKCQkJbG9uZyBwb3NuID0gZnRlbGwocmVzdWx0KTsKCQkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1dSSVRFRlVOQ1RJT04sCgkJCQkJIGZ3cml0ZSk7CgkJCWlmIChwb3NuID4gMCkgewoJCQkJc3RyYnVmX2FkZGYoJmJ1ZiwgIlJhbmdlOiBieXRlcz0lbGQtIiwgcG9zbik7CgkJCQloZWFkZXJzID0gY3VybF9zbGlzdF9hcHBlbmQoaGVhZGVycywgYnVmLmJ1Zik7CgkJCQlzdHJidWZfcmVzZXQoJmJ1Zik7CgkJCX0KCQl9IGVsc2UKCQkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1dSSVRFRlVOQ1RJT04sCgkJCQkJIGZ3cml0ZV9idWZmZXIpOwoJfQoKCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgIlByYWdtYToiKTsKCWlmIChvcHRpb25zICYmIG9wdGlvbnMtPm5vX2NhY2hlKQoJCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgIiBuby1jYWNoZSIpOwoJaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy0+a2VlcF9lcnJvcikKCQljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfRkFJTE9ORVJST1IsIDApOwoKCWhlYWRlcnMgPSBjdXJsX3NsaXN0X2FwcGVuZChoZWFkZXJzLCBidWYuYnVmKTsKCgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfVVJMLCB1cmwpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0hUVFBIRUFERVIsIGhlYWRlcnMpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0VOQ09ESU5HLCAiZ3ppcCIpOwoKCXJldCA9IHJ1bl9vbmVfc2xvdChzbG90LCAmcmVzdWx0cyk7CgoJaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy0+Y29udGVudF90eXBlKQoJCWN1cmxpbmZvX3N0cmJ1ZihzbG90LT5jdXJsLCBDVVJMSU5GT19DT05URU5UX1RZUEUsCgkJCQlvcHRpb25zLT5jb250ZW50X3R5cGUpOwoKCWlmIChvcHRpb25zICYmIG9wdGlvbnMtPmVmZmVjdGl2ZV91cmwpCgkJY3VybGluZm9fc3RyYnVmKHNsb3QtPmN1cmwsIENVUkxJTkZPX0VGRkVDVElWRV9VUkwsCgkJCQlvcHRpb25zLT5lZmZlY3RpdmVfdXJsKTsKCgljdXJsX3NsaXN0X2ZyZWVfYWxsKGhlYWRlcnMpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CgoJcmV0dXJuIHJldDsKfQoKLyoKICogVXBkYXRlIHRoZSAiYmFzZSIgdXJsIHRvIGEgbW9yZSBhcHByb3ByaWF0ZSB2YWx1ZSwgYXMgZGVkdWNlZCBieQogKiByZWRpcmVjdHMgc2VlbiB3aGVuIHJlcXVlc3RpbmcgYSBVUkwgc3RhcnRpbmcgd2l0aCAidXJsIi4KICoKICogVGhlICJhc2tlZCIgcGFyYW1ldGVyIGlzIGEgVVJMIHRoYXQgd2UgYXNrZWQgY3VybCB0byBhY2Nlc3MsIGFuZCBtdXN0IGJlZ2luCiAqIHdpdGggImJhc2UiLgogKgogKiBUaGUgImdvdCIgcGFyYW1ldGVyIGlzIHRoZSBVUkwgdGhhdCBjdXJsIHJlcG9ydGVkIHRvIHVzIGFzIHdoZXJlIHdlIGVuZGVkCiAqIHVwLgogKgogKiBSZXR1cm5zIDEgaWYgd2UgdXBkYXRlZCB0aGUgYmFzZSB1cmwsIDAgb3RoZXJ3aXNlLgogKgogKiBPdXIgYmFzaWMgc3RyYXRlZ3kgaXMgdG8gY29tcGFyZSAiYmFzZSIgYW5kICJhc2tlZCIgdG8gZmluZCB0aGUgYml0cwogKiBzcGVjaWZpYyB0byBvdXIgcmVxdWVzdC4gV2UgdGhlbiBzdHJpcCB0aG9zZSBiaXRzIG9mZiBvZiAiZ290IiB0byB5aWVsZCB0aGUKICogbmV3IGJhc2UuIFNvIGZvciBleGFtcGxlLCBpZiBvdXIgYmFzZSBpcyAiaHR0cDovL2V4YW1wbGUuY29tL2Zvby5naXQiLAogKiBhbmQgd2UgYXNrIGZvciAiaHR0cDovL2V4YW1wbGUuY29tL2Zvby5naXQvaW5mby9yZWZzIiwgd2UgbWlnaHQgZW5kIHVwCiAqIHdpdGggImh0dHBzOi8vb3RoZXIuZXhhbXBsZS5jb20vZm9vLmdpdC9pbmZvL3JlZnMiLiBXZSB3b3VsZCB3YW50IHRoZQogKiBuZXcgVVJMIHRvIGJlY29tZSAiaHR0cHM6Ly9vdGhlci5leGFtcGxlLmNvbS9mb28uZ2l0Ii4KICoKICogTm90ZSB0aGF0IHRoaXMgYXNzdW1lcyBhIHNhbmUgcmVkaXJlY3Qgc2NoZW1lLiBJdCdzIGVudGlyZWx5IHBvc3NpYmxlCiAqIGluIHRoZSBleGFtcGxlIGFib3ZlIHRvIGVuZCB1cCBhdCBhIFVSTCB0aGF0IGRvZXMgbm90IGV2ZW4gZW5kIGluCiAqICJpbmZvL3JlZnMiLiAgSW4gc3VjaCBhIGNhc2Ugd2Ugc2ltcGx5IHB1bnQsIGFzIHRoZXJlIGlzIG5vdCBtdWNoIHdlIGNhbgogKiBkbyAoYW5kIHN1Y2ggYSBzY2hlbWUgaXMgdW5saWtlbHkgdG8gcmVwcmVzZW50IGEgcmVhbCBnaXQgcmVwb3NpdG9yeSwKICogd2hpY2ggbWVhbnMgd2UgYXJlIGxpa2VseSBhYm91dCB0byBhYm9ydCBhbnl3YXkpLgogKi8Kc3RhdGljIGludCB1cGRhdGVfdXJsX2Zyb21fcmVkaXJlY3Qoc3RydWN0IHN0cmJ1ZiAqYmFzZSwKCQkJCSAgICBjb25zdCBjaGFyICphc2tlZCwKCQkJCSAgICBjb25zdCBzdHJ1Y3Qgc3RyYnVmICpnb3QpCnsKCWNvbnN0IGNoYXIgKnRhaWw7CglzaXplX3QgdGFpbF9sZW47CgoJaWYgKCFzdHJjbXAoYXNrZWQsIGdvdC0+YnVmKSkKCQlyZXR1cm4gMDsKCglpZiAoIXN0YXJ0c193aXRoKGFza2VkLCBiYXNlLT5idWYpKQoJCWRpZSgiQlVHOiB1cGRhdGVfdXJsX2Zyb21fcmVkaXJlY3Q6ICVzIGlzIG5vdCBhIHN1cGVyc2V0IG9mICVzIiwKCQkgICAgYXNrZWQsIGJhc2UtPmJ1Zik7CgoJdGFpbCA9IGFza2VkICsgYmFzZS0+bGVuOwoJdGFpbF9sZW4gPSBzdHJsZW4odGFpbCk7CgoJaWYgKGdvdC0+bGVuIDwgdGFpbF9sZW4gfHwKCSAgICBzdHJjbXAodGFpbCwgZ290LT5idWYgKyBnb3QtPmxlbiAtIHRhaWxfbGVuKSkKCQlyZXR1cm4gMDsgLyogaW5zYW5lIHJlZGlyZWN0IHNjaGVtZSAqLwoKCXN0cmJ1Zl9yZXNldChiYXNlKTsKCXN0cmJ1Zl9hZGQoYmFzZSwgZ290LT5idWYsIGdvdC0+bGVuIC0gdGFpbF9sZW4pOwoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBpbnQgaHR0cF9yZXF1ZXN0X3JlYXV0aChjb25zdCBjaGFyICp1cmwsCgkJCSAgICAgICB2b2lkICpyZXN1bHQsIGludCB0YXJnZXQsCgkJCSAgICAgICBzdHJ1Y3QgaHR0cF9nZXRfb3B0aW9ucyAqb3B0aW9ucykKewoJaW50IHJldCA9IGh0dHBfcmVxdWVzdCh1cmwsIHJlc3VsdCwgdGFyZ2V0LCBvcHRpb25zKTsKCglpZiAob3B0aW9ucyAmJiBvcHRpb25zLT5lZmZlY3RpdmVfdXJsICYmIG9wdGlvbnMtPmJhc2VfdXJsKSB7CgkJaWYgKHVwZGF0ZV91cmxfZnJvbV9yZWRpcmVjdChvcHRpb25zLT5iYXNlX3VybCwKCQkJCQkgICAgIHVybCwgb3B0aW9ucy0+ZWZmZWN0aXZlX3VybCkpIHsKCQkJY3JlZGVudGlhbF9mcm9tX3VybCgmaHR0cF9hdXRoLCBvcHRpb25zLT5iYXNlX3VybC0+YnVmKTsKCQkJdXJsID0gb3B0aW9ucy0+ZWZmZWN0aXZlX3VybC0+YnVmOwoJCX0KCX0KCglpZiAocmV0ICE9IEhUVFBfUkVBVVRIKQoJCXJldHVybiByZXQ7CgoJLyoKCSAqIElmIHdlIGFyZSB1c2luZyBLRUVQX0VSUk9SLCB0aGUgcHJldmlvdXMgcmVxdWVzdCBtYXkgaGF2ZQoJICogcHV0IGNydWZ0IGludG8gb3VyIG91dHB1dCBzdHJlYW07IHdlIHNob3VsZCBjbGVhciBpdCBvdXQgYmVmb3JlCgkgKiBtYWtpbmcgb3VyIG5leHQgcmVxdWVzdC4gV2Ugb25seSBrbm93IGhvdyB0byBkbyB0aGlzIGZvcgoJICogdGhlIHN0cmJ1ZiBjYXNlLCBidXQgdGhhdCBpcyBlbm91Z2ggdG8gc2F0aXNmeSBjdXJyZW50IGNhbGxlcnMuCgkgKi8KCWlmIChvcHRpb25zICYmIG9wdGlvbnMtPmtlZXBfZXJyb3IpIHsKCQlzd2l0Y2ggKHRhcmdldCkgewoJCWNhc2UgSFRUUF9SRVFVRVNUX1NUUkJVRjoKCQkJc3RyYnVmX3Jlc2V0KHJlc3VsdCk7CgkJCWJyZWFrOwoJCWRlZmF1bHQ6CgkJCWRpZSgiQlVHOiBIVFRQX0tFRVBfRVJST1IgaXMgb25seSBzdXBwb3J0ZWQgd2l0aCBzdHJidWZzIik7CgkJfQoJfQoKCWNyZWRlbnRpYWxfZmlsbCgmaHR0cF9hdXRoKTsKCglyZXR1cm4gaHR0cF9yZXF1ZXN0KHVybCwgcmVzdWx0LCB0YXJnZXQsIG9wdGlvbnMpOwp9CgppbnQgaHR0cF9nZXRfc3RyYnVmKGNvbnN0IGNoYXIgKnVybCwKCQkgICAgc3RydWN0IHN0cmJ1ZiAqcmVzdWx0LAoJCSAgICBzdHJ1Y3QgaHR0cF9nZXRfb3B0aW9ucyAqb3B0aW9ucykKewoJcmV0dXJuIGh0dHBfcmVxdWVzdF9yZWF1dGgodXJsLCByZXN1bHQsIEhUVFBfUkVRVUVTVF9TVFJCVUYsIG9wdGlvbnMpOwp9CgovKgogKiBEb3dubG9hZHMgYSBVUkwgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSBnaXZlbiBmaWxlLgogKgogKiBJZiBhIHByZXZpb3VzIGludGVycnVwdGVkIGRvd25sb2FkIGlzIGRldGVjdGVkIChpLmUuIGEgcHJldmlvdXMgdGVtcG9yYXJ5CiAqIGZpbGUgaXMgc3RpbGwgYXJvdW5kKSB0aGUgZG93bmxvYWQgaXMgcmVzdW1lZC4KICovCnN0YXRpYyBpbnQgaHR0cF9nZXRfZmlsZShjb25zdCBjaGFyICp1cmwsIGNvbnN0IGNoYXIgKmZpbGVuYW1lLAoJCQkgc3RydWN0IGh0dHBfZ2V0X29wdGlvbnMgKm9wdGlvbnMpCnsKCWludCByZXQ7CglzdHJ1Y3Qgc3RyYnVmIHRtcGZpbGUgPSBTVFJCVUZfSU5JVDsKCUZJTEUgKnJlc3VsdDsKCglzdHJidWZfYWRkZigmdG1wZmlsZSwgIiVzLnRlbXAiLCBmaWxlbmFtZSk7CglyZXN1bHQgPSBmb3Blbih0bXBmaWxlLmJ1ZiwgImEiKTsKCWlmICghcmVzdWx0KSB7CgkJZXJyb3IoIlVuYWJsZSB0byBvcGVuIGxvY2FsIGZpbGUgJXMiLCB0bXBmaWxlLmJ1Zik7CgkJcmV0ID0gSFRUUF9FUlJPUjsKCQlnb3RvIGNsZWFudXA7Cgl9CgoJcmV0ID0gaHR0cF9yZXF1ZXN0X3JlYXV0aCh1cmwsIHJlc3VsdCwgSFRUUF9SRVFVRVNUX0ZJTEUsIG9wdGlvbnMpOwoJZmNsb3NlKHJlc3VsdCk7CgoJaWYgKHJldCA9PSBIVFRQX09LICYmIG1vdmVfdGVtcF90b19maWxlKHRtcGZpbGUuYnVmLCBmaWxlbmFtZSkpCgkJcmV0ID0gSFRUUF9FUlJPUjsKY2xlYW51cDoKCXN0cmJ1Zl9yZWxlYXNlKCZ0bXBmaWxlKTsKCXJldHVybiByZXQ7Cn0KCmludCBodHRwX2ZldGNoX3JlZihjb25zdCBjaGFyICpiYXNlLCBzdHJ1Y3QgcmVmICpyZWYpCnsKCXN0cnVjdCBodHRwX2dldF9vcHRpb25zIG9wdGlvbnMgPSB7MH07CgljaGFyICp1cmw7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZmZlciA9IFNUUkJVRl9JTklUOwoJaW50IHJldCA9IC0xOwoKCW9wdGlvbnMubm9fY2FjaGUgPSAxOwoKCXVybCA9IHF1b3RlX3JlZl91cmwoYmFzZSwgcmVmLT5uYW1lKTsKCWlmIChodHRwX2dldF9zdHJidWYodXJsLCAmYnVmZmVyLCAmb3B0aW9ucykgPT0gSFRUUF9PSykgewoJCXN0cmJ1Zl9ydHJpbSgmYnVmZmVyKTsKCQlpZiAoYnVmZmVyLmxlbiA9PSA0MCkKCQkJcmV0ID0gZ2V0X3NoYTFfaGV4KGJ1ZmZlci5idWYsIHJlZi0+b2xkX3NoYTEpOwoJCWVsc2UgaWYgKHN0YXJ0c193aXRoKGJ1ZmZlci5idWYsICJyZWY6ICIpKSB7CgkJCXJlZi0+c3ltcmVmID0geHN0cmR1cChidWZmZXIuYnVmICsgNSk7CgkJCXJldCA9IDA7CgkJfQoJfQoKCXN0cmJ1Zl9yZWxlYXNlKCZidWZmZXIpOwoJZnJlZSh1cmwpOwoJcmV0dXJuIHJldDsKfQoKLyogSGVscGVycyBmb3IgZmV0Y2hpbmcgcGFja3MgKi8Kc3RhdGljIGNoYXIgKmZldGNoX3BhY2tfaW5kZXgodW5zaWduZWQgY2hhciAqc2hhMSwgY29uc3QgY2hhciAqYmFzZV91cmwpCnsKCWNoYXIgKnVybCwgKnRtcDsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJaWYgKGh0dHBfaXNfdmVyYm9zZSkKCQlmcHJpbnRmKHN0ZGVyciwgIkdldHRpbmcgaW5kZXggZm9yIHBhY2sgJXNcbiIsIHNoYTFfdG9faGV4KHNoYTEpKTsKCgllbmRfdXJsX3dpdGhfc2xhc2goJmJ1ZiwgYmFzZV91cmwpOwoJc3RyYnVmX2FkZGYoJmJ1ZiwgIm9iamVjdHMvcGFjay9wYWNrLSVzLmlkeCIsIHNoYTFfdG9faGV4KHNoYTEpKTsKCXVybCA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7CgoJc3RyYnVmX2FkZGYoJmJ1ZiwgIiVzLnRlbXAiLCBzaGExX3BhY2tfaW5kZXhfbmFtZShzaGExKSk7Cgl0bXAgPSBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpOwoKCWlmIChodHRwX2dldF9maWxlKHVybCwgdG1wLCBOVUxMKSAhPSBIVFRQX09LKSB7CgkJZXJyb3IoIlVuYWJsZSB0byBnZXQgcGFjayBpbmRleCAlcyIsIHVybCk7CgkJZnJlZSh0bXApOwoJCXRtcCA9IE5VTEw7Cgl9CgoJZnJlZSh1cmwpOwoJcmV0dXJuIHRtcDsKfQoKc3RhdGljIGludCBmZXRjaF9hbmRfc2V0dXBfcGFja19pbmRleChzdHJ1Y3QgcGFja2VkX2dpdCAqKnBhY2tzX2hlYWQsCgl1bnNpZ25lZCBjaGFyICpzaGExLCBjb25zdCBjaGFyICpiYXNlX3VybCkKewoJc3RydWN0IHBhY2tlZF9naXQgKm5ld19wYWNrOwoJY2hhciAqdG1wX2lkeCA9IE5VTEw7CglpbnQgcmV0OwoKCWlmIChoYXNfcGFja19pbmRleChzaGExKSkgewoJCW5ld19wYWNrID0gcGFyc2VfcGFja19pbmRleChzaGExLCBzaGExX3BhY2tfaW5kZXhfbmFtZShzaGExKSk7CgkJaWYgKCFuZXdfcGFjaykKCQkJcmV0dXJuIC0xOyAvKiBwYXJzZV9wYWNrX2luZGV4KCkgYWxyZWFkeSBpc3N1ZWQgZXJyb3IgbWVzc2FnZSAqLwoJCWdvdG8gYWRkX3BhY2s7Cgl9CgoJdG1wX2lkeCA9IGZldGNoX3BhY2tfaW5kZXgoc2hhMSwgYmFzZV91cmwpOwoJaWYgKCF0bXBfaWR4KQoJCXJldHVybiAtMTsKCgluZXdfcGFjayA9IHBhcnNlX3BhY2tfaW5kZXgoc2hhMSwgdG1wX2lkeCk7CglpZiAoIW5ld19wYWNrKSB7CgkJdW5saW5rKHRtcF9pZHgpOwoJCWZyZWUodG1wX2lkeCk7CgoJCXJldHVybiAtMTsgLyogcGFyc2VfcGFja19pbmRleCgpIGFscmVhZHkgaXNzdWVkIGVycm9yIG1lc3NhZ2UgKi8KCX0KCglyZXQgPSB2ZXJpZnlfcGFja19pbmRleChuZXdfcGFjayk7CglpZiAoIXJldCkgewoJCWNsb3NlX3BhY2tfaW5kZXgobmV3X3BhY2spOwoJCXJldCA9IG1vdmVfdGVtcF90b19maWxlKHRtcF9pZHgsIHNoYTFfcGFja19pbmRleF9uYW1lKHNoYTEpKTsKCX0KCWZyZWUodG1wX2lkeCk7CglpZiAocmV0KQoJCXJldHVybiAtMTsKCmFkZF9wYWNrOgoJbmV3X3BhY2stPm5leHQgPSAqcGFja3NfaGVhZDsKCSpwYWNrc19oZWFkID0gbmV3X3BhY2s7CglyZXR1cm4gMDsKfQoKaW50IGh0dHBfZ2V0X2luZm9fcGFja3MoY29uc3QgY2hhciAqYmFzZV91cmwsIHN0cnVjdCBwYWNrZWRfZ2l0ICoqcGFja3NfaGVhZCkKewoJc3RydWN0IGh0dHBfZ2V0X29wdGlvbnMgb3B0aW9ucyA9IHswfTsKCWludCByZXQgPSAwLCBpID0gMDsKCWNoYXIgKnVybCwgKmRhdGE7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCgllbmRfdXJsX3dpdGhfc2xhc2goJmJ1ZiwgYmFzZV91cmwpOwoJc3RyYnVmX2FkZHN0cigmYnVmLCAib2JqZWN0cy9pbmZvL3BhY2tzIik7Cgl1cmwgPSBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpOwoKCW9wdGlvbnMubm9fY2FjaGUgPSAxOwoJcmV0ID0gaHR0cF9nZXRfc3RyYnVmKHVybCwgJmJ1ZiwgJm9wdGlvbnMpOwoJaWYgKHJldCAhPSBIVFRQX09LKQoJCWdvdG8gY2xlYW51cDsKCglkYXRhID0gYnVmLmJ1ZjsKCXdoaWxlIChpIDwgYnVmLmxlbikgewoJCXN3aXRjaCAoZGF0YVtpXSkgewoJCWNhc2UgJ1AnOgoJCQlpKys7CgkJCWlmIChpICsgNTIgPD0gYnVmLmxlbiAmJgoJCQkgICAgc3RhcnRzX3dpdGgoZGF0YSArIGksICIgcGFjay0iKSAmJgoJCQkgICAgc3RhcnRzX3dpdGgoZGF0YSArIGkgKyA0NiwgIi5wYWNrXG4iKSkgewoJCQkJZ2V0X3NoYTFfaGV4KGRhdGEgKyBpICsgNiwgc2hhMSk7CgkJCQlmZXRjaF9hbmRfc2V0dXBfcGFja19pbmRleChwYWNrc19oZWFkLCBzaGExLAoJCQkJCQkgICAgICBiYXNlX3VybCk7CgkJCQlpICs9IDUxOwoJCQkJYnJlYWs7CgkJCX0KCQlkZWZhdWx0OgoJCQl3aGlsZSAoaSA8IGJ1Zi5sZW4gJiYgZGF0YVtpXSAhPSAnXG4nKQoJCQkJaSsrOwoJCX0KCQlpKys7Cgl9CgpjbGVhbnVwOgoJZnJlZSh1cmwpOwoJcmV0dXJuIHJldDsKfQoKdm9pZCByZWxlYXNlX2h0dHBfcGFja19yZXF1ZXN0KHN0cnVjdCBodHRwX3BhY2tfcmVxdWVzdCAqcHJlcSkKewoJaWYgKHByZXEtPnBhY2tmaWxlICE9IE5VTEwpIHsKCQlmY2xvc2UocHJlcS0+cGFja2ZpbGUpOwoJCXByZXEtPnBhY2tmaWxlID0gTlVMTDsKCX0KCWlmIChwcmVxLT5yYW5nZV9oZWFkZXIgIT0gTlVMTCkgewoJCWN1cmxfc2xpc3RfZnJlZV9hbGwocHJlcS0+cmFuZ2VfaGVhZGVyKTsKCQlwcmVxLT5yYW5nZV9oZWFkZXIgPSBOVUxMOwoJfQoJcHJlcS0+c2xvdCA9IE5VTEw7CglmcmVlKHByZXEtPnVybCk7Cn0KCmludCBmaW5pc2hfaHR0cF9wYWNrX3JlcXVlc3Qoc3RydWN0IGh0dHBfcGFja19yZXF1ZXN0ICpwcmVxKQp7CglzdHJ1Y3QgcGFja2VkX2dpdCAqKmxzdDsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwID0gcHJlcS0+dGFyZ2V0OwoJY2hhciAqdG1wX2lkeDsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGlwOwoJY29uc3QgY2hhciAqaXBfYXJndls4XTsKCgljbG9zZV9wYWNrX2luZGV4KHApOwoKCWZjbG9zZShwcmVxLT5wYWNrZmlsZSk7CglwcmVxLT5wYWNrZmlsZSA9IE5VTEw7CgoJbHN0ID0gcHJlcS0+bHN0OwoJd2hpbGUgKCpsc3QgIT0gcCkKCQlsc3QgPSAmKCgqbHN0KS0+bmV4dCk7CgkqbHN0ID0gKCpsc3QpLT5uZXh0OwoKCXRtcF9pZHggPSB4c3RyZHVwKHByZXEtPnRtcGZpbGUpOwoJc3RyY3B5KHRtcF9pZHggKyBzdHJsZW4odG1wX2lkeCkgLSBzdHJsZW4oIi5wYWNrLnRlbXAiKSwKCSAgICAgICAiLmlkeC50ZW1wIik7CgoJaXBfYXJndlswXSA9ICJpbmRleC1wYWNrIjsKCWlwX2FyZ3ZbMV0gPSAiLW8iOwoJaXBfYXJndlsyXSA9IHRtcF9pZHg7CglpcF9hcmd2WzNdID0gcHJlcS0+dG1wZmlsZTsKCWlwX2FyZ3ZbNF0gPSBOVUxMOwoKCW1lbXNldCgmaXAsIDAsIHNpemVvZihpcCkpOwoJaXAuYXJndiA9IGlwX2FyZ3Y7CglpcC5naXRfY21kID0gMTsKCWlwLm5vX3N0ZGluID0gMTsKCWlwLm5vX3N0ZG91dCA9IDE7CgoJaWYgKHJ1bl9jb21tYW5kKCZpcCkpIHsKCQl1bmxpbmsocHJlcS0+dG1wZmlsZSk7CgkJdW5saW5rKHRtcF9pZHgpOwoJCWZyZWUodG1wX2lkeCk7CgkJcmV0dXJuIC0xOwoJfQoKCXVubGluayhzaGExX3BhY2tfaW5kZXhfbmFtZShwLT5zaGExKSk7CgoJaWYgKG1vdmVfdGVtcF90b19maWxlKHByZXEtPnRtcGZpbGUsIHNoYTFfcGFja19uYW1lKHAtPnNoYTEpKQoJIHx8IG1vdmVfdGVtcF90b19maWxlKHRtcF9pZHgsIHNoYTFfcGFja19pbmRleF9uYW1lKHAtPnNoYTEpKSkgewoJCWZyZWUodG1wX2lkeCk7CgkJcmV0dXJuIC0xOwoJfQoKCWluc3RhbGxfcGFja2VkX2dpdChwKTsKCWZyZWUodG1wX2lkeCk7CglyZXR1cm4gMDsKfQoKc3RydWN0IGh0dHBfcGFja19yZXF1ZXN0ICpuZXdfaHR0cF9wYWNrX3JlcXVlc3QoCglzdHJ1Y3QgcGFja2VkX2dpdCAqdGFyZ2V0LCBjb25zdCBjaGFyICpiYXNlX3VybCkKewoJbG9uZyBwcmV2X3Bvc24gPSAwOwoJY2hhciByYW5nZVtSQU5HRV9IRUFERVJfU0laRV07CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJc3RydWN0IGh0dHBfcGFja19yZXF1ZXN0ICpwcmVxOwoKCXByZXEgPSB4Y2FsbG9jKDEsIHNpemVvZigqcHJlcSkpOwoJcHJlcS0+dGFyZ2V0ID0gdGFyZ2V0OwoKCWVuZF91cmxfd2l0aF9zbGFzaCgmYnVmLCBiYXNlX3VybCk7CglzdHJidWZfYWRkZigmYnVmLCAib2JqZWN0cy9wYWNrL3BhY2stJXMucGFjayIsCgkJc2hhMV90b19oZXgodGFyZ2V0LT5zaGExKSk7CglwcmVxLT51cmwgPSBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpOwoKCXNucHJpbnRmKHByZXEtPnRtcGZpbGUsIHNpemVvZihwcmVxLT50bXBmaWxlKSwgIiVzLnRlbXAiLAoJCXNoYTFfcGFja19uYW1lKHRhcmdldC0+c2hhMSkpOwoJcHJlcS0+cGFja2ZpbGUgPSBmb3BlbihwcmVxLT50bXBmaWxlLCAiYSIpOwoJaWYgKCFwcmVxLT5wYWNrZmlsZSkgewoJCWVycm9yKCJVbmFibGUgdG8gb3BlbiBsb2NhbCBmaWxlICVzIGZvciBwYWNrIiwKCQkgICAgICBwcmVxLT50bXBmaWxlKTsKCQlnb3RvIGFib3J0OwoJfQoKCXByZXEtPnNsb3QgPSBnZXRfYWN0aXZlX3Nsb3QoKTsKCWN1cmxfZWFzeV9zZXRvcHQocHJlcS0+c2xvdC0+Y3VybCwgQ1VSTE9QVF9GSUxFLCBwcmVxLT5wYWNrZmlsZSk7CgljdXJsX2Vhc3lfc2V0b3B0KHByZXEtPnNsb3QtPmN1cmwsIENVUkxPUFRfV1JJVEVGVU5DVElPTiwgZndyaXRlKTsKCWN1cmxfZWFzeV9zZXRvcHQocHJlcS0+c2xvdC0+Y3VybCwgQ1VSTE9QVF9VUkwsIHByZXEtPnVybCk7CgljdXJsX2Vhc3lfc2V0b3B0KHByZXEtPnNsb3QtPmN1cmwsIENVUkxPUFRfSFRUUEhFQURFUiwKCQlub19wcmFnbWFfaGVhZGVyKTsKCgkvKgoJICogSWYgdGhlcmUgaXMgZGF0YSBwcmVzZW50IGZyb20gYSBwcmV2aW91cyB0cmFuc2ZlciBhdHRlbXB0LAoJICogcmVzdW1lIHdoZXJlIGl0IGxlZnQgb2ZmCgkgKi8KCXByZXZfcG9zbiA9IGZ0ZWxsKHByZXEtPnBhY2tmaWxlKTsKCWlmIChwcmV2X3Bvc24+MCkgewoJCWlmIChodHRwX2lzX3ZlcmJvc2UpCgkJCWZwcmludGYoc3RkZXJyLAoJCQkJIlJlc3VtaW5nIGZldGNoIG9mIHBhY2sgJXMgYXQgYnl0ZSAlbGRcbiIsCgkJCQlzaGExX3RvX2hleCh0YXJnZXQtPnNoYTEpLCBwcmV2X3Bvc24pOwoJCXNwcmludGYocmFuZ2UsICJSYW5nZTogYnl0ZXM9JWxkLSIsIHByZXZfcG9zbik7CgkJcHJlcS0+cmFuZ2VfaGVhZGVyID0gY3VybF9zbGlzdF9hcHBlbmQoTlVMTCwgcmFuZ2UpOwoJCWN1cmxfZWFzeV9zZXRvcHQocHJlcS0+c2xvdC0+Y3VybCwgQ1VSTE9QVF9IVFRQSEVBREVSLAoJCQlwcmVxLT5yYW5nZV9oZWFkZXIpOwoJfQoKCXJldHVybiBwcmVxOwoKYWJvcnQ6CglmcmVlKHByZXEtPnVybCk7CglmcmVlKHByZXEpOwoJcmV0dXJuIE5VTEw7Cn0KCi8qIEhlbHBlcnMgZm9yIGZldGNoaW5nIG9iamVjdHMgKGxvb3NlKSAqLwpzdGF0aWMgc2l6ZV90IGZ3cml0ZV9zaGExX2ZpbGUoY2hhciAqcHRyLCBzaXplX3QgZWx0c2l6ZSwgc2l6ZV90IG5tZW1iLAoJCQkgICAgICAgdm9pZCAqZGF0YSkKewoJdW5zaWduZWQgY2hhciBleHBuWzQwOTZdOwoJc2l6ZV90IHNpemUgPSBlbHRzaXplICogbm1lbWI7CglpbnQgcG9zbiA9IDA7CglzdHJ1Y3QgaHR0cF9vYmplY3RfcmVxdWVzdCAqZnJlcSA9CgkJKHN0cnVjdCBodHRwX29iamVjdF9yZXF1ZXN0ICopZGF0YTsKCWRvIHsKCQlzc2l6ZV90IHJldHZhbCA9IHh3cml0ZShmcmVxLT5sb2NhbGZpbGUsCgkJCQkJKGNoYXIgKikgcHRyICsgcG9zbiwgc2l6ZSAtIHBvc24pOwoJCWlmIChyZXR2YWwgPCAwKQoJCQlyZXR1cm4gcG9zbjsKCQlwb3NuICs9IHJldHZhbDsKCX0gd2hpbGUgKHBvc24gPCBzaXplKTsKCglmcmVxLT5zdHJlYW0uYXZhaWxfaW4gPSBzaXplOwoJZnJlcS0+c3RyZWFtLm5leHRfaW4gPSAodm9pZCAqKXB0cjsKCWRvIHsKCQlmcmVxLT5zdHJlYW0ubmV4dF9vdXQgPSBleHBuOwoJCWZyZXEtPnN0cmVhbS5hdmFpbF9vdXQgPSBzaXplb2YoZXhwbik7CgkJZnJlcS0+enJldCA9IGdpdF9pbmZsYXRlKCZmcmVxLT5zdHJlYW0sIFpfU1lOQ19GTFVTSCk7CgkJZ2l0X1NIQTFfVXBkYXRlKCZmcmVxLT5jLCBleHBuLAoJCQkJc2l6ZW9mKGV4cG4pIC0gZnJlcS0+c3RyZWFtLmF2YWlsX291dCk7Cgl9IHdoaWxlIChmcmVxLT5zdHJlYW0uYXZhaWxfaW4gJiYgZnJlcS0+enJldCA9PSBaX09LKTsKCXJldHVybiBzaXplOwp9CgpzdHJ1Y3QgaHR0cF9vYmplY3RfcmVxdWVzdCAqbmV3X2h0dHBfb2JqZWN0X3JlcXVlc3QoY29uc3QgY2hhciAqYmFzZV91cmwsCgl1bnNpZ25lZCBjaGFyICpzaGExKQp7CgljaGFyICpoZXggPSBzaGExX3RvX2hleChzaGExKTsKCWNvbnN0IGNoYXIgKmZpbGVuYW1lOwoJY2hhciBwcmV2ZmlsZVtQQVRIX01BWF07CglpbnQgcHJldmxvY2FsOwoJY2hhciBwcmV2X2J1ZltQUkVWX0JVRl9TSVpFXTsKCXNzaXplX3QgcHJldl9yZWFkID0gMDsKCWxvbmcgcHJldl9wb3NuID0gMDsKCWNoYXIgcmFuZ2VbUkFOR0VfSEVBREVSX1NJWkVdOwoJc3RydWN0IGN1cmxfc2xpc3QgKnJhbmdlX2hlYWRlciA9IE5VTEw7CglzdHJ1Y3QgaHR0cF9vYmplY3RfcmVxdWVzdCAqZnJlcTsKCglmcmVxID0geGNhbGxvYygxLCBzaXplb2YoKmZyZXEpKTsKCWhhc2hjcHkoZnJlcS0+c2hhMSwgc2hhMSk7CglmcmVxLT5sb2NhbGZpbGUgPSAtMTsKCglmaWxlbmFtZSA9IHNoYTFfZmlsZV9uYW1lKHNoYTEpOwoJc25wcmludGYoZnJlcS0+dG1wZmlsZSwgc2l6ZW9mKGZyZXEtPnRtcGZpbGUpLAoJCSAiJXMudGVtcCIsIGZpbGVuYW1lKTsKCglzbnByaW50ZihwcmV2ZmlsZSwgc2l6ZW9mKHByZXZmaWxlKSwgIiVzLnByZXYiLCBmaWxlbmFtZSk7Cgl1bmxpbmtfb3Jfd2FybihwcmV2ZmlsZSk7CglyZW5hbWUoZnJlcS0+dG1wZmlsZSwgcHJldmZpbGUpOwoJdW5saW5rX29yX3dhcm4oZnJlcS0+dG1wZmlsZSk7CgoJaWYgKGZyZXEtPmxvY2FsZmlsZSAhPSAtMSkKCQllcnJvcigiZmQgbGVha2FnZSBpbiBzdGFydDogJWQiLCBmcmVxLT5sb2NhbGZpbGUpOwoJZnJlcS0+bG9jYWxmaWxlID0gb3BlbihmcmVxLT50bXBmaWxlLAoJCQkgICAgICAgT19XUk9OTFkgfCBPX0NSRUFUIHwgT19FWENMLCAwNjY2KTsKCS8qCgkgKiBUaGlzIGNvdWxkIGhhdmUgZmFpbGVkIGR1ZSB0byB0aGUgImxhenkgZGlyZWN0b3J5IGNyZWF0aW9uIjsKCSAqIHRyeSB0byBta2RpciB0aGUgbGFzdCBwYXRoIGNvbXBvbmVudC4KCSAqLwoJaWYgKGZyZXEtPmxvY2FsZmlsZSA8IDAgJiYgZXJybm8gPT0gRU5PRU5UKSB7CgkJY2hhciAqZGlyID0gc3RycmNocihmcmVxLT50bXBmaWxlLCAnLycpOwoJCWlmIChkaXIpIHsKCQkJKmRpciA9IDA7CgkJCW1rZGlyKGZyZXEtPnRtcGZpbGUsIDA3NzcpOwoJCQkqZGlyID0gJy8nOwoJCX0KCQlmcmVxLT5sb2NhbGZpbGUgPSBvcGVuKGZyZXEtPnRtcGZpbGUsCgkJCQkgICAgICAgT19XUk9OTFkgfCBPX0NSRUFUIHwgT19FWENMLCAwNjY2KTsKCX0KCglpZiAoZnJlcS0+bG9jYWxmaWxlIDwgMCkgewoJCWVycm9yKCJDb3VsZG4ndCBjcmVhdGUgdGVtcG9yYXJ5IGZpbGUgJXM6ICVzIiwKCQkgICAgICBmcmVxLT50bXBmaWxlLCBzdHJlcnJvcihlcnJubykpOwoJCWdvdG8gYWJvcnQ7Cgl9CgoJZ2l0X2luZmxhdGVfaW5pdCgmZnJlcS0+c3RyZWFtKTsKCglnaXRfU0hBMV9Jbml0KCZmcmVxLT5jKTsKCglmcmVxLT51cmwgPSBnZXRfcmVtb3RlX29iamVjdF91cmwoYmFzZV91cmwsIGhleCwgMCk7CgoJLyoKCSAqIElmIGEgcHJldmlvdXMgdGVtcCBmaWxlIGlzIHByZXNlbnQsIHByb2Nlc3Mgd2hhdCB3YXMgYWxyZWFkeQoJICogZmV0Y2hlZC4KCSAqLwoJcHJldmxvY2FsID0gb3BlbihwcmV2ZmlsZSwgT19SRE9OTFkpOwoJaWYgKHByZXZsb2NhbCAhPSAtMSkgewoJCWRvIHsKCQkJcHJldl9yZWFkID0geHJlYWQocHJldmxvY2FsLCBwcmV2X2J1ZiwgUFJFVl9CVUZfU0laRSk7CgkJCWlmIChwcmV2X3JlYWQ+MCkgewoJCQkJaWYgKGZ3cml0ZV9zaGExX2ZpbGUocHJldl9idWYsCgkJCQkJCSAgICAgMSwKCQkJCQkJICAgICBwcmV2X3JlYWQsCgkJCQkJCSAgICAgZnJlcSkgPT0gcHJldl9yZWFkKSB7CgkJCQkJcHJldl9wb3NuICs9IHByZXZfcmVhZDsKCQkJCX0gZWxzZSB7CgkJCQkJcHJldl9yZWFkID0gLTE7CgkJCQl9CgkJCX0KCQl9IHdoaWxlIChwcmV2X3JlYWQgPiAwKTsKCQljbG9zZShwcmV2bG9jYWwpOwoJfQoJdW5saW5rX29yX3dhcm4ocHJldmZpbGUpOwoKCS8qCgkgKiBSZXNldCBpbmZsYXRlL1NIQTEgaWYgdGhlcmUgd2FzIGFuIGVycm9yIHJlYWRpbmcgdGhlIHByZXZpb3VzIHRlbXAKCSAqIGZpbGU7IGFsc28gcmV3aW5kIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxvY2FsIGZpbGUuCgkgKi8KCWlmIChwcmV2X3JlYWQgPT0gLTEpIHsKCQltZW1zZXQoJmZyZXEtPnN0cmVhbSwgMCwgc2l6ZW9mKGZyZXEtPnN0cmVhbSkpOwoJCWdpdF9pbmZsYXRlX2luaXQoJmZyZXEtPnN0cmVhbSk7CgkJZ2l0X1NIQTFfSW5pdCgmZnJlcS0+Yyk7CgkJaWYgKHByZXZfcG9zbj4wKSB7CgkJCXByZXZfcG9zbiA9IDA7CgkJCWxzZWVrKGZyZXEtPmxvY2FsZmlsZSwgMCwgU0VFS19TRVQpOwoJCQlpZiAoZnRydW5jYXRlKGZyZXEtPmxvY2FsZmlsZSwgMCkgPCAwKSB7CgkJCQllcnJvcigiQ291bGRuJ3QgdHJ1bmNhdGUgdGVtcG9yYXJ5IGZpbGUgJXM6ICVzIiwKCQkJCQkgIGZyZXEtPnRtcGZpbGUsIHN0cmVycm9yKGVycm5vKSk7CgkJCQlnb3RvIGFib3J0OwoJCQl9CgkJfQoJfQoKCWZyZXEtPnNsb3QgPSBnZXRfYWN0aXZlX3Nsb3QoKTsKCgljdXJsX2Vhc3lfc2V0b3B0KGZyZXEtPnNsb3QtPmN1cmwsIENVUkxPUFRfRklMRSwgZnJlcSk7CgljdXJsX2Vhc3lfc2V0b3B0KGZyZXEtPnNsb3QtPmN1cmwsIENVUkxPUFRfV1JJVEVGVU5DVElPTiwgZndyaXRlX3NoYTFfZmlsZSk7CgljdXJsX2Vhc3lfc2V0b3B0KGZyZXEtPnNsb3QtPmN1cmwsIENVUkxPUFRfRVJST1JCVUZGRVIsIGZyZXEtPmVycm9yc3RyKTsKCWN1cmxfZWFzeV9zZXRvcHQoZnJlcS0+c2xvdC0+Y3VybCwgQ1VSTE9QVF9VUkwsIGZyZXEtPnVybCk7CgljdXJsX2Vhc3lfc2V0b3B0KGZyZXEtPnNsb3QtPmN1cmwsIENVUkxPUFRfSFRUUEhFQURFUiwgbm9fcHJhZ21hX2hlYWRlcik7CgoJLyoKCSAqIElmIHdlIGhhdmUgc3VjY2Vzc2Z1bGx5IHByb2Nlc3NlZCBkYXRhIGZyb20gYSBwcmV2aW91cyBmZXRjaAoJICogYXR0ZW1wdCwgb25seSBmZXRjaCB0aGUgZGF0YSB3ZSBkb24ndCBhbHJlYWR5IGhhdmUuCgkgKi8KCWlmIChwcmV2X3Bvc24+MCkgewoJCWlmIChodHRwX2lzX3ZlcmJvc2UpCgkJCWZwcmludGYoc3RkZXJyLAoJCQkJIlJlc3VtaW5nIGZldGNoIG9mIG9iamVjdCAlcyBhdCBieXRlICVsZFxuIiwKCQkJCWhleCwgcHJldl9wb3NuKTsKCQlzcHJpbnRmKHJhbmdlLCAiUmFuZ2U6IGJ5dGVzPSVsZC0iLCBwcmV2X3Bvc24pOwoJCXJhbmdlX2hlYWRlciA9IGN1cmxfc2xpc3RfYXBwZW5kKHJhbmdlX2hlYWRlciwgcmFuZ2UpOwoJCWN1cmxfZWFzeV9zZXRvcHQoZnJlcS0+c2xvdC0+Y3VybCwKCQkJCSBDVVJMT1BUX0hUVFBIRUFERVIsIHJhbmdlX2hlYWRlcik7Cgl9CgoJcmV0dXJuIGZyZXE7CgphYm9ydDoKCWZyZWUoZnJlcS0+dXJsKTsKCWZyZWUoZnJlcSk7CglyZXR1cm4gTlVMTDsKfQoKdm9pZCBwcm9jZXNzX2h0dHBfb2JqZWN0X3JlcXVlc3Qoc3RydWN0IGh0dHBfb2JqZWN0X3JlcXVlc3QgKmZyZXEpCnsKCWlmIChmcmVxLT5zbG90ID09IE5VTEwpCgkJcmV0dXJuOwoJZnJlcS0+Y3VybF9yZXN1bHQgPSBmcmVxLT5zbG90LT5jdXJsX3Jlc3VsdDsKCWZyZXEtPmh0dHBfY29kZSA9IGZyZXEtPnNsb3QtPmh0dHBfY29kZTsKCWZyZXEtPnNsb3QgPSBOVUxMOwp9CgppbnQgZmluaXNoX2h0dHBfb2JqZWN0X3JlcXVlc3Qoc3RydWN0IGh0dHBfb2JqZWN0X3JlcXVlc3QgKmZyZXEpCnsKCXN0cnVjdCBzdGF0IHN0OwoKCWNsb3NlKGZyZXEtPmxvY2FsZmlsZSk7CglmcmVxLT5sb2NhbGZpbGUgPSAtMTsKCglwcm9jZXNzX2h0dHBfb2JqZWN0X3JlcXVlc3QoZnJlcSk7CgoJaWYgKGZyZXEtPmh0dHBfY29kZSA9PSA0MTYpIHsKCQl3YXJuaW5nKCJyZXF1ZXN0ZWQgcmFuZ2UgaW52YWxpZDsgd2UgbWF5IGFscmVhZHkgaGF2ZSBhbGwgdGhlIGRhdGEuIik7Cgl9IGVsc2UgaWYgKGZyZXEtPmN1cmxfcmVzdWx0ICE9IENVUkxFX09LKSB7CgkJaWYgKHN0YXQoZnJlcS0+dG1wZmlsZSwgJnN0KSA9PSAwKQoJCQlpZiAoc3Quc3Rfc2l6ZSA9PSAwKQoJCQkJdW5saW5rX29yX3dhcm4oZnJlcS0+dG1wZmlsZSk7CgkJcmV0dXJuIC0xOwoJfQoKCWdpdF9pbmZsYXRlX2VuZCgmZnJlcS0+c3RyZWFtKTsKCWdpdF9TSEExX0ZpbmFsKGZyZXEtPnJlYWxfc2hhMSwgJmZyZXEtPmMpOwoJaWYgKGZyZXEtPnpyZXQgIT0gWl9TVFJFQU1fRU5EKSB7CgkJdW5saW5rX29yX3dhcm4oZnJlcS0+dG1wZmlsZSk7CgkJcmV0dXJuIC0xOwoJfQoJaWYgKGhhc2hjbXAoZnJlcS0+c2hhMSwgZnJlcS0+cmVhbF9zaGExKSkgewoJCXVubGlua19vcl93YXJuKGZyZXEtPnRtcGZpbGUpOwoJCXJldHVybiAtMTsKCX0KCWZyZXEtPnJlbmFtZSA9CgkJbW92ZV90ZW1wX3RvX2ZpbGUoZnJlcS0+dG1wZmlsZSwgc2hhMV9maWxlX25hbWUoZnJlcS0+c2hhMSkpOwoKCXJldHVybiBmcmVxLT5yZW5hbWU7Cn0KCnZvaWQgYWJvcnRfaHR0cF9vYmplY3RfcmVxdWVzdChzdHJ1Y3QgaHR0cF9vYmplY3RfcmVxdWVzdCAqZnJlcSkKewoJdW5saW5rX29yX3dhcm4oZnJlcS0+dG1wZmlsZSk7CgoJcmVsZWFzZV9odHRwX29iamVjdF9yZXF1ZXN0KGZyZXEpOwp9Cgp2b2lkIHJlbGVhc2VfaHR0cF9vYmplY3RfcmVxdWVzdChzdHJ1Y3QgaHR0cF9vYmplY3RfcmVxdWVzdCAqZnJlcSkKewoJaWYgKGZyZXEtPmxvY2FsZmlsZSAhPSAtMSkgewoJCWNsb3NlKGZyZXEtPmxvY2FsZmlsZSk7CgkJZnJlcS0+bG9jYWxmaWxlID0gLTE7Cgl9CglpZiAoZnJlcS0+dXJsICE9IE5VTEwpIHsKCQlmcmVlKGZyZXEtPnVybCk7CgkJZnJlcS0+dXJsID0gTlVMTDsKCX0KCWlmIChmcmVxLT5zbG90ICE9IE5VTEwpIHsKCQlmcmVxLT5zbG90LT5jYWxsYmFja19mdW5jID0gTlVMTDsKCQlmcmVxLT5zbG90LT5jYWxsYmFja19kYXRhID0gTlVMTDsKCQlyZWxlYXNlX2FjdGl2ZV9zbG90KGZyZXEtPnNsb3QpOwoJCWZyZXEtPnNsb3QgPSBOVUxMOwoJfQp9Cg==",
    "text": "#include \"http.h\"\n#include \"pack.h\"\n#include \"sideband.h\"\n#include \"run-command.h\"\n#include \"url.h\"\n#include \"urlmatch.h\"\n#include \"credential.h\"\n#include \"version.h\"\n#include \"pkt-line.h\"\n\nint active_requests;\nint http_is_verbose;\nsize_t http_post_buffer = 16 * LARGE_PACKET_MAX;\n\n#if LIBCURL_VERSION_NUM >= 0x070a06\n#define LIBCURL_CAN_HANDLE_AUTH_ANY\n#endif\n\nstatic int min_curl_sessions = 1;\nstatic int curl_session_count;\n#ifdef USE_CURL_MULTI\nstatic int max_requests = -1;\nstatic CURLM *curlm;\n#endif\n#ifndef NO_CURL_EASY_DUPHANDLE\nstatic CURL *curl_default;\n#endif\n\n#define PREV_BUF_SIZE 4096\n#define RANGE_HEADER_SIZE 30\n\nchar curl_errorstr[CURL_ERROR_SIZE];\n\nstatic int curl_ssl_verify = -1;\nstatic int curl_ssl_try;\nstatic const char *ssl_cert;\n#if LIBCURL_VERSION_NUM >= 0x070903\nstatic const char *ssl_key;\n#endif\n#if LIBCURL_VERSION_NUM >= 0x070908\nstatic const char *ssl_capath;\n#endif\nstatic const char *ssl_cainfo;\nstatic long curl_low_speed_limit = -1;\nstatic long curl_low_speed_time = -1;\nstatic int curl_ftp_no_epsv;\nstatic const char *curl_http_proxy;\nstatic const char *curl_cookie_file;\nstatic int curl_save_cookies;\nstruct credential http_auth = CREDENTIAL_INIT;\nstatic int http_proactive_auth;\nstatic const char *user_agent;\n\n#if LIBCURL_VERSION_NUM >= 0x071700\n/* Use CURLOPT_KEYPASSWD as is */\n#elif LIBCURL_VERSION_NUM >= 0x070903\n#define CURLOPT_KEYPASSWD CURLOPT_SSLKEYPASSWD\n#else\n#define CURLOPT_KEYPASSWD CURLOPT_SSLCERTPASSWD\n#endif\n\nstatic struct credential cert_auth = CREDENTIAL_INIT;\nstatic int ssl_cert_password_required;\n\nstatic struct curl_slist *pragma_header;\nstatic struct curl_slist *no_pragma_header;\n\nstatic struct active_request_slot *active_queue_head;\n\nsize_t fread_buffer(char *ptr, size_t eltsize, size_t nmemb, void *buffer_)\n{\n\tsize_t size = eltsize * nmemb;\n\tstruct buffer *buffer = buffer_;\n\n\tif (size > buffer->buf.len - buffer->posn)\n\t\tsize = buffer->buf.len - buffer->posn;\n\tmemcpy(ptr, buffer->buf.buf + buffer->posn, size);\n\tbuffer->posn += size;\n\n\treturn size;\n}\n\n#ifndef NO_CURL_IOCTL\ncurlioerr ioctl_buffer(CURL *handle, int cmd, void *clientp)\n{\n\tstruct buffer *buffer = clientp;\n\n\tswitch (cmd) {\n\tcase CURLIOCMD_NOP:\n\t\treturn CURLIOE_OK;\n\n\tcase CURLIOCMD_RESTARTREAD:\n\t\tbuffer->posn = 0;\n\t\treturn CURLIOE_OK;\n\n\tdefault:\n\t\treturn CURLIOE_UNKNOWNCMD;\n\t}\n}\n#endif\n\nsize_t fwrite_buffer(char *ptr, size_t eltsize, size_t nmemb, void *buffer_)\n{\n\tsize_t size = eltsize * nmemb;\n\tstruct strbuf *buffer = buffer_;\n\n\tstrbuf_add(buffer, ptr, size);\n\treturn size;\n}\n\nsize_t fwrite_null(char *ptr, size_t eltsize, size_t nmemb, void *strbuf)\n{\n\treturn eltsize * nmemb;\n}\n\n#ifdef USE_CURL_MULTI\nstatic void process_curl_messages(void)\n{\n\tint num_messages;\n\tstruct active_request_slot *slot;\n\tCURLMsg *curl_message = curl_multi_info_read(curlm, &num_messages);\n\n\twhile (curl_message != NULL) {\n\t\tif (curl_message->msg == CURLMSG_DONE) {\n\t\t\tint curl_result = curl_message->data.result;\n\t\t\tslot = active_queue_head;\n\t\t\twhile (slot != NULL &&\n\t\t\t       slot->curl != curl_message->easy_handle)\n\t\t\t\tslot = slot->next;\n\t\t\tif (slot != NULL) {\n\t\t\t\tcurl_multi_remove_handle(curlm, slot->curl);\n\t\t\t\tslot->curl_result = curl_result;\n\t\t\t\tfinish_active_slot(slot);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Received DONE message for unknown request!\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown CURL message received: %d\\n\",\n\t\t\t\t(int)curl_message->msg);\n\t\t}\n\t\tcurl_message = curl_multi_info_read(curlm, &num_messages);\n\t}\n}\n#endif\n\nstatic int http_options(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(\"http.sslverify\", var)) {\n\t\tcurl_ssl_verify = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.sslcert\", var))\n\t\treturn git_config_string(&ssl_cert, var, value);\n#if LIBCURL_VERSION_NUM >= 0x070903\n\tif (!strcmp(\"http.sslkey\", var))\n\t\treturn git_config_string(&ssl_key, var, value);\n#endif\n#if LIBCURL_VERSION_NUM >= 0x070908\n\tif (!strcmp(\"http.sslcapath\", var))\n\t\treturn git_config_string(&ssl_capath, var, value);\n#endif\n\tif (!strcmp(\"http.sslcainfo\", var))\n\t\treturn git_config_string(&ssl_cainfo, var, value);\n\tif (!strcmp(\"http.sslcertpasswordprotected\", var)) {\n\t\tssl_cert_password_required = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.ssltry\", var)) {\n\t\tcurl_ssl_try = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.minsessions\", var)) {\n\t\tmin_curl_sessions = git_config_int(var, value);\n#ifndef USE_CURL_MULTI\n\t\tif (min_curl_sessions > 1)\n\t\t\tmin_curl_sessions = 1;\n#endif\n\t\treturn 0;\n\t}\n#ifdef USE_CURL_MULTI\n\tif (!strcmp(\"http.maxrequests\", var)) {\n\t\tmax_requests = git_config_int(var, value);\n\t\treturn 0;\n\t}\n#endif\n\tif (!strcmp(\"http.lowspeedlimit\", var)) {\n\t\tcurl_low_speed_limit = (long)git_config_int(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.lowspeedtime\", var)) {\n\t\tcurl_low_speed_time = (long)git_config_int(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(\"http.noepsv\", var)) {\n\t\tcurl_ftp_no_epsv = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.proxy\", var))\n\t\treturn git_config_string(&curl_http_proxy, var, value);\n\n\tif (!strcmp(\"http.cookiefile\", var))\n\t\treturn git_config_string(&curl_cookie_file, var, value);\n\tif (!strcmp(\"http.savecookies\", var)) {\n\t\tcurl_save_cookies = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(\"http.postbuffer\", var)) {\n\t\thttp_post_buffer = git_config_int(var, value);\n\t\tif (http_post_buffer < LARGE_PACKET_MAX)\n\t\t\thttp_post_buffer = LARGE_PACKET_MAX;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(\"http.useragent\", var))\n\t\treturn git_config_string(&user_agent, var, value);\n\n\t/* Fall back on the default ones */\n\treturn git_default_config(var, value, cb);\n}\n\nstatic void init_curl_http_auth(CURL *result)\n{\n\tif (!http_auth.username)\n\t\treturn;\n\n\tcredential_fill(&http_auth);\n\n#if LIBCURL_VERSION_NUM >= 0x071301\n\tcurl_easy_setopt(result, CURLOPT_USERNAME, http_auth.username);\n\tcurl_easy_setopt(result, CURLOPT_PASSWORD, http_auth.password);\n#else\n\t{\n\t\tstatic struct strbuf up = STRBUF_INIT;\n\t\t/*\n\t\t * Note that we assume we only ever have a single set of\n\t\t * credentials in a given program run, so we do not have\n\t\t * to worry about updating this buffer, only setting its\n\t\t * initial value.\n\t\t */\n\t\tif (!up.len)\n\t\t\tstrbuf_addf(&up, \"%s:%s\",\n\t\t\t\thttp_auth.username, http_auth.password);\n\t\tcurl_easy_setopt(result, CURLOPT_USERPWD, up.buf);\n\t}\n#endif\n}\n\nstatic int has_cert_password(void)\n{\n\tif (ssl_cert == NULL || ssl_cert_password_required != 1)\n\t\treturn 0;\n\tif (!cert_auth.password) {\n\t\tcert_auth.protocol = xstrdup(\"cert\");\n\t\tcert_auth.username = xstrdup(\"\");\n\t\tcert_auth.path = xstrdup(ssl_cert);\n\t\tcredential_fill(&cert_auth);\n\t}\n\treturn 1;\n}\n\n#if LIBCURL_VERSION_NUM >= 0x071900\nstatic void set_curl_keepalive(CURL *c)\n{\n\tcurl_easy_setopt(c, CURLOPT_TCP_KEEPALIVE, 1);\n}\n\n#elif LIBCURL_VERSION_NUM >= 0x071000\nstatic int sockopt_callback(void *client, curl_socket_t fd, curlsocktype type)\n{\n\tint ka = 1;\n\tint rc;\n\tsocklen_t len = (socklen_t)sizeof(ka);\n\n\tif (type != CURLSOCKTYPE_IPCXN)\n\t\treturn 0;\n\n\trc = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void *)&ka, len);\n\tif (rc < 0)\n\t\twarning(\"unable to set SO_KEEPALIVE on socket %s\",\n\t\t\tstrerror(errno));\n\n\treturn 0; /* CURL_SOCKOPT_OK only exists since curl 7.21.5 */\n}\n\nstatic void set_curl_keepalive(CURL *c)\n{\n\tcurl_easy_setopt(c, CURLOPT_SOCKOPTFUNCTION, sockopt_callback);\n}\n\n#else\nstatic void set_curl_keepalive(CURL *c)\n{\n\t/* not supported on older curl versions */\n}\n#endif\n\nstatic CURL *get_curl_handle(void)\n{\n\tCURL *result = curl_easy_init();\n\n\tif (!curl_ssl_verify) {\n\t\tcurl_easy_setopt(result, CURLOPT_SSL_VERIFYPEER, 0);\n\t\tcurl_easy_setopt(result, CURLOPT_SSL_VERIFYHOST, 0);\n\t} else {\n\t\t/* Verify authenticity of the peer's certificate */\n\t\tcurl_easy_setopt(result, CURLOPT_SSL_VERIFYPEER, 1);\n\t\t/* The name in the cert must match whom we tried to connect */\n\t\tcurl_easy_setopt(result, CURLOPT_SSL_VERIFYHOST, 2);\n\t}\n\n#if LIBCURL_VERSION_NUM >= 0x070907\n\tcurl_easy_setopt(result, CURLOPT_NETRC, CURL_NETRC_OPTIONAL);\n#endif\n#ifdef LIBCURL_CAN_HANDLE_AUTH_ANY\n\tcurl_easy_setopt(result, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n#endif\n\n\tif (http_proactive_auth)\n\t\tinit_curl_http_auth(result);\n\n\tif (ssl_cert != NULL)\n\t\tcurl_easy_setopt(result, CURLOPT_SSLCERT, ssl_cert);\n\tif (has_cert_password())\n\t\tcurl_easy_setopt(result, CURLOPT_KEYPASSWD, cert_auth.password);\n#if LIBCURL_VERSION_NUM >= 0x070903\n\tif (ssl_key != NULL)\n\t\tcurl_easy_setopt(result, CURLOPT_SSLKEY, ssl_key);\n#endif\n#if LIBCURL_VERSION_NUM >= 0x070908\n\tif (ssl_capath != NULL)\n\t\tcurl_easy_setopt(result, CURLOPT_CAPATH, ssl_capath);\n#endif\n\tif (ssl_cainfo != NULL)\n\t\tcurl_easy_setopt(result, CURLOPT_CAINFO, ssl_cainfo);\n\n\tif (curl_low_speed_limit > 0 && curl_low_speed_time > 0) {\n\t\tcurl_easy_setopt(result, CURLOPT_LOW_SPEED_LIMIT,\n\t\t\t\t curl_low_speed_limit);\n\t\tcurl_easy_setopt(result, CURLOPT_LOW_SPEED_TIME,\n\t\t\t\t curl_low_speed_time);\n\t}\n\n\tcurl_easy_setopt(result, CURLOPT_FOLLOWLOCATION, 1);\n#if LIBCURL_VERSION_NUM >= 0x071301\n\tcurl_easy_setopt(result, CURLOPT_POSTREDIR, CURL_REDIR_POST_ALL);\n#elif LIBCURL_VERSION_NUM >= 0x071101\n\tcurl_easy_setopt(result, CURLOPT_POST301, 1);\n#endif\n\n\tif (getenv(\"GIT_CURL_VERBOSE\"))\n\t\tcurl_easy_setopt(result, CURLOPT_VERBOSE, 1);\n\n\tcurl_easy_setopt(result, CURLOPT_USERAGENT,\n\t\tuser_agent ? user_agent : git_user_agent());\n\n\tif (curl_ftp_no_epsv)\n\t\tcurl_easy_setopt(result, CURLOPT_FTP_USE_EPSV, 0);\n\n#ifdef CURLOPT_USE_SSL\n\tif (curl_ssl_try)\n\t\tcurl_easy_setopt(result, CURLOPT_USE_SSL, CURLUSESSL_TRY);\n#endif\n\n\tif (curl_http_proxy) {\n\t\tcurl_easy_setopt(result, CURLOPT_PROXY, curl_http_proxy);\n\t\tcurl_easy_setopt(result, CURLOPT_PROXYAUTH, CURLAUTH_ANY);\n\t}\n\n\tset_curl_keepalive(result);\n\n\treturn result;\n}\n\nstatic void set_from_env(const char **var, const char *envname)\n{\n\tconst char *val = getenv(envname);\n\tif (val)\n\t\t*var = val;\n}\n\nvoid http_init(struct remote *remote, const char *url, int proactive_auth)\n{\n\tchar *low_speed_limit;\n\tchar *low_speed_time;\n\tchar *normalized_url;\n\tstruct urlmatch_config config = { STRING_LIST_INIT_DUP };\n\n\tconfig.section = \"http\";\n\tconfig.key = NULL;\n\tconfig.collect_fn = http_options;\n\tconfig.cascade_fn = git_default_config;\n\tconfig.cb = NULL;\n\n\thttp_is_verbose = 0;\n\tnormalized_url = url_normalize(url, &config.url);\n\n\tgit_config(urlmatch_config_entry, &config);\n\tfree(normalized_url);\n\n\tcurl_global_init(CURL_GLOBAL_ALL);\n\n\thttp_proactive_auth = proactive_auth;\n\n\tif (remote && remote->http_proxy)\n\t\tcurl_http_proxy = xstrdup(remote->http_proxy);\n\n\tpragma_header = curl_slist_append(pragma_header, \"Pragma: no-cache\");\n\tno_pragma_header = curl_slist_append(no_pragma_header, \"Pragma:\");\n\n#ifdef USE_CURL_MULTI\n\t{\n\t\tchar *http_max_requests = getenv(\"GIT_HTTP_MAX_REQUESTS\");\n\t\tif (http_max_requests != NULL)\n\t\t\tmax_requests = atoi(http_max_requests);\n\t}\n\n\tcurlm = curl_multi_init();\n\tif (curlm == NULL) {\n\t\tfprintf(stderr, \"Error creating curl multi handle.\\n\");\n\t\texit(1);\n\t}\n#endif\n\n\tif (getenv(\"GIT_SSL_NO_VERIFY\"))\n\t\tcurl_ssl_verify = 0;\n\n\tset_from_env(&ssl_cert, \"GIT_SSL_CERT\");\n#if LIBCURL_VERSION_NUM >= 0x070903\n\tset_from_env(&ssl_key, \"GIT_SSL_KEY\");\n#endif\n#if LIBCURL_VERSION_NUM >= 0x070908\n\tset_from_env(&ssl_capath, \"GIT_SSL_CAPATH\");\n#endif\n\tset_from_env(&ssl_cainfo, \"GIT_SSL_CAINFO\");\n\n\tset_from_env(&user_agent, \"GIT_HTTP_USER_AGENT\");\n\n\tlow_speed_limit = getenv(\"GIT_HTTP_LOW_SPEED_LIMIT\");\n\tif (low_speed_limit != NULL)\n\t\tcurl_low_speed_limit = strtol(low_speed_limit, NULL, 10);\n\tlow_speed_time = getenv(\"GIT_HTTP_LOW_SPEED_TIME\");\n\tif (low_speed_time != NULL)\n\t\tcurl_low_speed_time = strtol(low_speed_time, NULL, 10);\n\n\tif (curl_ssl_verify == -1)\n\t\tcurl_ssl_verify = 1;\n\n\tcurl_session_count = 0;\n#ifdef USE_CURL_MULTI\n\tif (max_requests < 1)\n\t\tmax_requests = DEFAULT_MAX_REQUESTS;\n#endif\n\n\tif (getenv(\"GIT_CURL_FTP_NO_EPSV\"))\n\t\tcurl_ftp_no_epsv = 1;\n\n\tif (url) {\n\t\tcredential_from_url(&http_auth, url);\n\t\tif (!ssl_cert_password_required &&\n\t\t    getenv(\"GIT_SSL_CERT_PASSWORD_PROTECTED\") &&\n\t\t    starts_with(url, \"https://\"))\n\t\t\tssl_cert_password_required = 1;\n\t}\n\n#ifndef NO_CURL_EASY_DUPHANDLE\n\tcurl_default = get_curl_handle();\n#endif\n}\n\nvoid http_cleanup(void)\n{\n\tstruct active_request_slot *slot = active_queue_head;\n\n\twhile (slot != NULL) {\n\t\tstruct active_request_slot *next = slot->next;\n\t\tif (slot->curl != NULL) {\n#ifdef USE_CURL_MULTI\n\t\t\tcurl_multi_remove_handle(curlm, slot->curl);\n#endif\n\t\t\tcurl_easy_cleanup(slot->curl);\n\t\t}\n\t\tfree(slot);\n\t\tslot = next;\n\t}\n\tactive_queue_head = NULL;\n\n#ifndef NO_CURL_EASY_DUPHANDLE\n\tcurl_easy_cleanup(curl_default);\n#endif\n\n#ifdef USE_CURL_MULTI\n\tcurl_multi_cleanup(curlm);\n#endif\n\tcurl_global_cleanup();\n\n\tcurl_slist_free_all(pragma_header);\n\tpragma_header = NULL;\n\n\tcurl_slist_free_all(no_pragma_header);\n\tno_pragma_header = NULL;\n\n\tif (curl_http_proxy) {\n\t\tfree((void *)curl_http_proxy);\n\t\tcurl_http_proxy = NULL;\n\t}\n\n\tif (cert_auth.password != NULL) {\n\t\tmemset(cert_auth.password, 0, strlen(cert_auth.password));\n\t\tfree(cert_auth.password);\n\t\tcert_auth.password = NULL;\n\t}\n\tssl_cert_password_required = 0;\n}\n\nstruct active_request_slot *get_active_slot(void)\n{\n\tstruct active_request_slot *slot = active_queue_head;\n\tstruct active_request_slot *newslot;\n\n#ifdef USE_CURL_MULTI\n\tint num_transfers;\n\n\t/* Wait for a slot to open up if the queue is full */\n\twhile (active_requests >= max_requests) {\n\t\tcurl_multi_perform(curlm, &num_transfers);\n\t\tif (num_transfers < active_requests)\n\t\t\tprocess_curl_messages();\n\t}\n#endif\n\n\twhile (slot != NULL && slot->in_use)\n\t\tslot = slot->next;\n\n\tif (slot == NULL) {\n\t\tnewslot = xmalloc(sizeof(*newslot));\n\t\tnewslot->curl = NULL;\n\t\tnewslot->in_use = 0;\n\t\tnewslot->next = NULL;\n\n\t\tslot = active_queue_head;\n\t\tif (slot == NULL) {\n\t\t\tactive_queue_head = newslot;\n\t\t} else {\n\t\t\twhile (slot->next != NULL)\n\t\t\t\tslot = slot->next;\n\t\t\tslot->next = newslot;\n\t\t}\n\t\tslot = newslot;\n\t}\n\n\tif (slot->curl == NULL) {\n#ifdef NO_CURL_EASY_DUPHANDLE\n\t\tslot->curl = get_curl_handle();\n#else\n\t\tslot->curl = curl_easy_duphandle(curl_default);\n#endif\n\t\tcurl_session_count++;\n\t}\n\n\tactive_requests++;\n\tslot->in_use = 1;\n\tslot->results = NULL;\n\tslot->finished = NULL;\n\tslot->callback_data = NULL;\n\tslot->callback_func = NULL;\n\tcurl_easy_setopt(slot->curl, CURLOPT_COOKIEFILE, curl_cookie_file);\n\tif (curl_save_cookies)\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_COOKIEJAR, curl_cookie_file);\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, pragma_header);\n\tcurl_easy_setopt(slot->curl, CURLOPT_ERRORBUFFER, curl_errorstr);\n\tcurl_easy_setopt(slot->curl, CURLOPT_CUSTOMREQUEST, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_READFUNCTION, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_UPLOAD, 0);\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPGET, 1);\n\tcurl_easy_setopt(slot->curl, CURLOPT_FAILONERROR, 1);\n\tif (http_auth.password)\n\t\tinit_curl_http_auth(slot->curl);\n\n\treturn slot;\n}\n\nint start_active_slot(struct active_request_slot *slot)\n{\n#ifdef USE_CURL_MULTI\n\tCURLMcode curlm_result = curl_multi_add_handle(curlm, slot->curl);\n\tint num_transfers;\n\n\tif (curlm_result != CURLM_OK &&\n\t    curlm_result != CURLM_CALL_MULTI_PERFORM) {\n\t\tactive_requests--;\n\t\tslot->in_use = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We know there must be something to do, since we just added\n\t * something.\n\t */\n\tcurl_multi_perform(curlm, &num_transfers);\n#endif\n\treturn 1;\n}\n\n#ifdef USE_CURL_MULTI\nstruct fill_chain {\n\tvoid *data;\n\tint (*fill)(void *);\n\tstruct fill_chain *next;\n};\n\nstatic struct fill_chain *fill_cfg;\n\nvoid add_fill_function(void *data, int (*fill)(void *))\n{\n\tstruct fill_chain *new = xmalloc(sizeof(*new));\n\tstruct fill_chain **linkp = &fill_cfg;\n\tnew->data = data;\n\tnew->fill = fill;\n\tnew->next = NULL;\n\twhile (*linkp)\n\t\tlinkp = &(*linkp)->next;\n\t*linkp = new;\n}\n\nvoid fill_active_slots(void)\n{\n\tstruct active_request_slot *slot = active_queue_head;\n\n\twhile (active_requests < max_requests) {\n\t\tstruct fill_chain *fill;\n\t\tfor (fill = fill_cfg; fill; fill = fill->next)\n\t\t\tif (fill->fill(fill->data))\n\t\t\t\tbreak;\n\n\t\tif (!fill)\n\t\t\tbreak;\n\t}\n\n\twhile (slot != NULL) {\n\t\tif (!slot->in_use && slot->curl != NULL\n\t\t\t&& curl_session_count > min_curl_sessions) {\n\t\t\tcurl_easy_cleanup(slot->curl);\n\t\t\tslot->curl = NULL;\n\t\t\tcurl_session_count--;\n\t\t}\n\t\tslot = slot->next;\n\t}\n}\n\nvoid step_active_slots(void)\n{\n\tint num_transfers;\n\tCURLMcode curlm_result;\n\n\tdo {\n\t\tcurlm_result = curl_multi_perform(curlm, &num_transfers);\n\t} while (curlm_result == CURLM_CALL_MULTI_PERFORM);\n\tif (num_transfers < active_requests) {\n\t\tprocess_curl_messages();\n\t\tfill_active_slots();\n\t}\n}\n#endif\n\nvoid run_active_slot(struct active_request_slot *slot)\n{\n#ifdef USE_CURL_MULTI\n\tfd_set readfds;\n\tfd_set writefds;\n\tfd_set excfds;\n\tint max_fd;\n\tstruct timeval select_timeout;\n\tint finished = 0;\n\n\tslot->finished = &finished;\n\twhile (!finished) {\n\t\tstep_active_slots();\n\n\t\tif (slot->in_use) {\n#if LIBCURL_VERSION_NUM >= 0x070f04\n\t\t\tlong curl_timeout;\n\t\t\tcurl_multi_timeout(curlm, &curl_timeout);\n\t\t\tif (curl_timeout == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (curl_timeout == -1) {\n\t\t\t\tselect_timeout.tv_sec  = 0;\n\t\t\t\tselect_timeout.tv_usec = 50000;\n\t\t\t} else {\n\t\t\t\tselect_timeout.tv_sec  =  curl_timeout / 1000;\n\t\t\t\tselect_timeout.tv_usec = (curl_timeout % 1000) * 1000;\n\t\t\t}\n#else\n\t\t\tselect_timeout.tv_sec  = 0;\n\t\t\tselect_timeout.tv_usec = 50000;\n#endif\n\n\t\t\tmax_fd = -1;\n\t\t\tFD_ZERO(&readfds);\n\t\t\tFD_ZERO(&writefds);\n\t\t\tFD_ZERO(&excfds);\n\t\t\tcurl_multi_fdset(curlm, &readfds, &writefds, &excfds, &max_fd);\n\n\t\t\t/*\n\t\t\t * It can happen that curl_multi_timeout returns a pathologically\n\t\t\t * long timeout when curl_multi_fdset returns no file descriptors\n\t\t\t * to read.  See commit message for more details.\n\t\t\t */\n\t\t\tif (max_fd < 0 &&\n\t\t\t    (select_timeout.tv_sec > 0 ||\n\t\t\t     select_timeout.tv_usec > 50000)) {\n\t\t\t\tselect_timeout.tv_sec  = 0;\n\t\t\t\tselect_timeout.tv_usec = 50000;\n\t\t\t}\n\n\t\t\tselect(max_fd+1, &readfds, &writefds, &excfds, &select_timeout);\n\t\t}\n\t}\n#else\n\twhile (slot->in_use) {\n\t\tslot->curl_result = curl_easy_perform(slot->curl);\n\t\tfinish_active_slot(slot);\n\t}\n#endif\n}\n\nstatic void closedown_active_slot(struct active_request_slot *slot)\n{\n\tactive_requests--;\n\tslot->in_use = 0;\n}\n\nstatic void release_active_slot(struct active_request_slot *slot)\n{\n\tclosedown_active_slot(slot);\n\tif (slot->curl && curl_session_count > min_curl_sessions) {\n#ifdef USE_CURL_MULTI\n\t\tcurl_multi_remove_handle(curlm, slot->curl);\n#endif\n\t\tcurl_easy_cleanup(slot->curl);\n\t\tslot->curl = NULL;\n\t\tcurl_session_count--;\n\t}\n#ifdef USE_CURL_MULTI\n\tfill_active_slots();\n#endif\n}\n\nvoid finish_active_slot(struct active_request_slot *slot)\n{\n\tclosedown_active_slot(slot);\n\tcurl_easy_getinfo(slot->curl, CURLINFO_HTTP_CODE, &slot->http_code);\n\n\tif (slot->finished != NULL)\n\t\t(*slot->finished) = 1;\n\n\t/* Store slot results so they can be read after the slot is reused */\n\tif (slot->results != NULL) {\n\t\tslot->results->curl_result = slot->curl_result;\n\t\tslot->results->http_code = slot->http_code;\n#if LIBCURL_VERSION_NUM >= 0x070a08\n\t\tcurl_easy_getinfo(slot->curl, CURLINFO_HTTPAUTH_AVAIL,\n\t\t\t\t  &slot->results->auth_avail);\n#else\n\t\tslot->results->auth_avail = 0;\n#endif\n\t}\n\n\t/* Run callback if appropriate */\n\tif (slot->callback_func != NULL)\n\t\tslot->callback_func(slot->callback_data);\n}\n\nvoid finish_all_active_slots(void)\n{\n\tstruct active_request_slot *slot = active_queue_head;\n\n\twhile (slot != NULL)\n\t\tif (slot->in_use) {\n\t\t\trun_active_slot(slot);\n\t\t\tslot = active_queue_head;\n\t\t} else {\n\t\t\tslot = slot->next;\n\t\t}\n}\n\n/* Helpers for modifying and creating URLs */\nstatic inline int needs_quote(int ch)\n{\n\tif (((ch >= 'A') && (ch <= 'Z'))\n\t\t\t|| ((ch >= 'a') && (ch <= 'z'))\n\t\t\t|| ((ch >= '0') && (ch <= '9'))\n\t\t\t|| (ch == '/')\n\t\t\t|| (ch == '-')\n\t\t\t|| (ch == '.'))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic char *quote_ref_url(const char *base, const char *ref)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *cp;\n\tint ch;\n\n\tend_url_with_slash(&buf, base);\n\n\tfor (cp = ref; (ch = *cp) != 0; cp++)\n\t\tif (needs_quote(ch))\n\t\t\tstrbuf_addf(&buf, \"%%%02x\", ch);\n\t\telse\n\t\t\tstrbuf_addch(&buf, *cp);\n\n\treturn strbuf_detach(&buf, NULL);\n}\n\nvoid append_remote_object_url(struct strbuf *buf, const char *url,\n\t\t\t      const char *hex,\n\t\t\t      int only_two_digit_prefix)\n{\n\tend_url_with_slash(buf, url);\n\n\tstrbuf_addf(buf, \"objects/%.*s/\", 2, hex);\n\tif (!only_two_digit_prefix)\n\t\tstrbuf_addf(buf, \"%s\", hex+2);\n}\n\nchar *get_remote_object_url(const char *url, const char *hex,\n\t\t\t    int only_two_digit_prefix)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tappend_remote_object_url(&buf, url, hex, only_two_digit_prefix);\n\treturn strbuf_detach(&buf, NULL);\n}\n\nint handle_curl_result(struct slot_results *results)\n{\n\t/*\n\t * If we see a failing http code with CURLE_OK, we have turned off\n\t * FAILONERROR (to keep the server's custom error response), and should\n\t * translate the code into failure here.\n\t */\n\tif (results->curl_result == CURLE_OK &&\n\t    results->http_code >= 400) {\n\t\tresults->curl_result = CURLE_HTTP_RETURNED_ERROR;\n\t\t/*\n\t\t * Normally curl will already have put the \"reason phrase\"\n\t\t * from the server into curl_errorstr; unfortunately without\n\t\t * FAILONERROR it is lost, so we can give only the numeric\n\t\t * status code.\n\t\t */\n\t\tsnprintf(curl_errorstr, sizeof(curl_errorstr),\n\t\t\t \"The requested URL returned error: %ld\",\n\t\t\t results->http_code);\n\t}\n\n\tif (results->curl_result == CURLE_OK) {\n\t\tcredential_approve(&http_auth);\n\t\treturn HTTP_OK;\n\t} else if (missing_target(results))\n\t\treturn HTTP_MISSING_TARGET;\n\telse if (results->http_code == 401) {\n\t\tif (http_auth.username && http_auth.password) {\n\t\t\tcredential_reject(&http_auth);\n\t\t\treturn HTTP_NOAUTH;\n\t\t} else {\n\t\t\treturn HTTP_REAUTH;\n\t\t}\n\t} else {\n#if LIBCURL_VERSION_NUM >= 0x070c00\n\t\tif (!curl_errorstr[0])\n\t\t\tstrlcpy(curl_errorstr,\n\t\t\t\tcurl_easy_strerror(results->curl_result),\n\t\t\t\tsizeof(curl_errorstr));\n#endif\n\t\treturn HTTP_ERROR;\n\t}\n}\n\nint run_one_slot(struct active_request_slot *slot,\n\t\t struct slot_results *results)\n{\n\tslot->results = results;\n\tif (!start_active_slot(slot)) {\n\t\tsnprintf(curl_errorstr, sizeof(curl_errorstr),\n\t\t\t \"failed to start HTTP request\");\n\t\treturn HTTP_START_FAILED;\n\t}\n\n\trun_active_slot(slot);\n\treturn handle_curl_result(results);\n}\n\nstatic CURLcode curlinfo_strbuf(CURL *curl, CURLINFO info, struct strbuf *buf)\n{\n\tchar *ptr;\n\tCURLcode ret;\n\n\tstrbuf_reset(buf);\n\tret = curl_easy_getinfo(curl, info, &ptr);\n\tif (!ret && ptr)\n\t\tstrbuf_addstr(buf, ptr);\n\treturn ret;\n}\n\n/* http_request() targets */\n#define HTTP_REQUEST_STRBUF\t0\n#define HTTP_REQUEST_FILE\t1\n\nstatic int http_request(const char *url,\n\t\t\tvoid *result, int target,\n\t\t\tconst struct http_get_options *options)\n{\n\tstruct active_request_slot *slot;\n\tstruct slot_results results;\n\tstruct curl_slist *headers = NULL;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint ret;\n\n\tslot = get_active_slot();\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPGET, 1);\n\n\tif (result == NULL) {\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_NOBODY, 1);\n\t} else {\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_NOBODY, 0);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_FILE, result);\n\n\t\tif (target == HTTP_REQUEST_FILE) {\n\t\t\tlong posn = ftell(result);\n\t\t\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION,\n\t\t\t\t\t fwrite);\n\t\t\tif (posn > 0) {\n\t\t\t\tstrbuf_addf(&buf, \"Range: bytes=%ld-\", posn);\n\t\t\t\theaders = curl_slist_append(headers, buf.buf);\n\t\t\t\tstrbuf_reset(&buf);\n\t\t\t}\n\t\t} else\n\t\t\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION,\n\t\t\t\t\t fwrite_buffer);\n\t}\n\n\tstrbuf_addstr(&buf, \"Pragma:\");\n\tif (options && options->no_cache)\n\t\tstrbuf_addstr(&buf, \" no-cache\");\n\tif (options && options->keep_error)\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_FAILONERROR, 0);\n\n\theaders = curl_slist_append(headers, buf.buf);\n\n\tcurl_easy_setopt(slot->curl, CURLOPT_URL, url);\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, headers);\n\tcurl_easy_setopt(slot->curl, CURLOPT_ENCODING, \"gzip\");\n\n\tret = run_one_slot(slot, &results);\n\n\tif (options && options->content_type)\n\t\tcurlinfo_strbuf(slot->curl, CURLINFO_CONTENT_TYPE,\n\t\t\t\toptions->content_type);\n\n\tif (options && options->effective_url)\n\t\tcurlinfo_strbuf(slot->curl, CURLINFO_EFFECTIVE_URL,\n\t\t\t\toptions->effective_url);\n\n\tcurl_slist_free_all(headers);\n\tstrbuf_release(&buf);\n\n\treturn ret;\n}\n\n/*\n * Update the \"base\" url to a more appropriate value, as deduced by\n * redirects seen when requesting a URL starting with \"url\".\n *\n * The \"asked\" parameter is a URL that we asked curl to access, and must begin\n * with \"base\".\n *\n * The \"got\" parameter is the URL that curl reported to us as where we ended\n * up.\n *\n * Returns 1 if we updated the base url, 0 otherwise.\n *\n * Our basic strategy is to compare \"base\" and \"asked\" to find the bits\n * specific to our request. We then strip those bits off of \"got\" to yield the\n * new base. So for example, if our base is \"http://example.com/foo.git\",\n * and we ask for \"http://example.com/foo.git/info/refs\", we might end up\n * with \"https://other.example.com/foo.git/info/refs\". We would want the\n * new URL to become \"https://other.example.com/foo.git\".\n *\n * Note that this assumes a sane redirect scheme. It's entirely possible\n * in the example above to end up at a URL that does not even end in\n * \"info/refs\".  In such a case we simply punt, as there is not much we can\n * do (and such a scheme is unlikely to represent a real git repository,\n * which means we are likely about to abort anyway).\n */\nstatic int update_url_from_redirect(struct strbuf *base,\n\t\t\t\t    const char *asked,\n\t\t\t\t    const struct strbuf *got)\n{\n\tconst char *tail;\n\tsize_t tail_len;\n\n\tif (!strcmp(asked, got->buf))\n\t\treturn 0;\n\n\tif (!starts_with(asked, base->buf))\n\t\tdie(\"BUG: update_url_from_redirect: %s is not a superset of %s\",\n\t\t    asked, base->buf);\n\n\ttail = asked + base->len;\n\ttail_len = strlen(tail);\n\n\tif (got->len < tail_len ||\n\t    strcmp(tail, got->buf + got->len - tail_len))\n\t\treturn 0; /* insane redirect scheme */\n\n\tstrbuf_reset(base);\n\tstrbuf_add(base, got->buf, got->len - tail_len);\n\treturn 1;\n}\n\nstatic int http_request_reauth(const char *url,\n\t\t\t       void *result, int target,\n\t\t\t       struct http_get_options *options)\n{\n\tint ret = http_request(url, result, target, options);\n\n\tif (options && options->effective_url && options->base_url) {\n\t\tif (update_url_from_redirect(options->base_url,\n\t\t\t\t\t     url, options->effective_url)) {\n\t\t\tcredential_from_url(&http_auth, options->base_url->buf);\n\t\t\turl = options->effective_url->buf;\n\t\t}\n\t}\n\n\tif (ret != HTTP_REAUTH)\n\t\treturn ret;\n\n\t/*\n\t * If we are using KEEP_ERROR, the previous request may have\n\t * put cruft into our output stream; we should clear it out before\n\t * making our next request. We only know how to do this for\n\t * the strbuf case, but that is enough to satisfy current callers.\n\t */\n\tif (options && options->keep_error) {\n\t\tswitch (target) {\n\t\tcase HTTP_REQUEST_STRBUF:\n\t\t\tstrbuf_reset(result);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdie(\"BUG: HTTP_KEEP_ERROR is only supported with strbufs\");\n\t\t}\n\t}\n\n\tcredential_fill(&http_auth);\n\n\treturn http_request(url, result, target, options);\n}\n\nint http_get_strbuf(const char *url,\n\t\t    struct strbuf *result,\n\t\t    struct http_get_options *options)\n{\n\treturn http_request_reauth(url, result, HTTP_REQUEST_STRBUF, options);\n}\n\n/*\n * Downloads a URL and stores the result in the given file.\n *\n * If a previous interrupted download is detected (i.e. a previous temporary\n * file is still around) the download is resumed.\n */\nstatic int http_get_file(const char *url, const char *filename,\n\t\t\t struct http_get_options *options)\n{\n\tint ret;\n\tstruct strbuf tmpfile = STRBUF_INIT;\n\tFILE *result;\n\n\tstrbuf_addf(&tmpfile, \"%s.temp\", filename);\n\tresult = fopen(tmpfile.buf, \"a\");\n\tif (!result) {\n\t\terror(\"Unable to open local file %s\", tmpfile.buf);\n\t\tret = HTTP_ERROR;\n\t\tgoto cleanup;\n\t}\n\n\tret = http_request_reauth(url, result, HTTP_REQUEST_FILE, options);\n\tfclose(result);\n\n\tif (ret == HTTP_OK && move_temp_to_file(tmpfile.buf, filename))\n\t\tret = HTTP_ERROR;\ncleanup:\n\tstrbuf_release(&tmpfile);\n\treturn ret;\n}\n\nint http_fetch_ref(const char *base, struct ref *ref)\n{\n\tstruct http_get_options options = {0};\n\tchar *url;\n\tstruct strbuf buffer = STRBUF_INIT;\n\tint ret = -1;\n\n\toptions.no_cache = 1;\n\n\turl = quote_ref_url(base, ref->name);\n\tif (http_get_strbuf(url, &buffer, &options) == HTTP_OK) {\n\t\tstrbuf_rtrim(&buffer);\n\t\tif (buffer.len == 40)\n\t\t\tret = get_sha1_hex(buffer.buf, ref->old_sha1);\n\t\telse if (starts_with(buffer.buf, \"ref: \")) {\n\t\t\tref->symref = xstrdup(buffer.buf + 5);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tstrbuf_release(&buffer);\n\tfree(url);\n\treturn ret;\n}\n\n/* Helpers for fetching packs */\nstatic char *fetch_pack_index(unsigned char *sha1, const char *base_url)\n{\n\tchar *url, *tmp;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tif (http_is_verbose)\n\t\tfprintf(stderr, \"Getting index for pack %s\\n\", sha1_to_hex(sha1));\n\n\tend_url_with_slash(&buf, base_url);\n\tstrbuf_addf(&buf, \"objects/pack/pack-%s.idx\", sha1_to_hex(sha1));\n\turl = strbuf_detach(&buf, NULL);\n\n\tstrbuf_addf(&buf, \"%s.temp\", sha1_pack_index_name(sha1));\n\ttmp = strbuf_detach(&buf, NULL);\n\n\tif (http_get_file(url, tmp, NULL) != HTTP_OK) {\n\t\terror(\"Unable to get pack index %s\", url);\n\t\tfree(tmp);\n\t\ttmp = NULL;\n\t}\n\n\tfree(url);\n\treturn tmp;\n}\n\nstatic int fetch_and_setup_pack_index(struct packed_git **packs_head,\n\tunsigned char *sha1, const char *base_url)\n{\n\tstruct packed_git *new_pack;\n\tchar *tmp_idx = NULL;\n\tint ret;\n\n\tif (has_pack_index(sha1)) {\n\t\tnew_pack = parse_pack_index(sha1, sha1_pack_index_name(sha1));\n\t\tif (!new_pack)\n\t\t\treturn -1; /* parse_pack_index() already issued error message */\n\t\tgoto add_pack;\n\t}\n\n\ttmp_idx = fetch_pack_index(sha1, base_url);\n\tif (!tmp_idx)\n\t\treturn -1;\n\n\tnew_pack = parse_pack_index(sha1, tmp_idx);\n\tif (!new_pack) {\n\t\tunlink(tmp_idx);\n\t\tfree(tmp_idx);\n\n\t\treturn -1; /* parse_pack_index() already issued error message */\n\t}\n\n\tret = verify_pack_index(new_pack);\n\tif (!ret) {\n\t\tclose_pack_index(new_pack);\n\t\tret = move_temp_to_file(tmp_idx, sha1_pack_index_name(sha1));\n\t}\n\tfree(tmp_idx);\n\tif (ret)\n\t\treturn -1;\n\nadd_pack:\n\tnew_pack->next = *packs_head;\n\t*packs_head = new_pack;\n\treturn 0;\n}\n\nint http_get_info_packs(const char *base_url, struct packed_git **packs_head)\n{\n\tstruct http_get_options options = {0};\n\tint ret = 0, i = 0;\n\tchar *url, *data;\n\tstruct strbuf buf = STRBUF_INIT;\n\tunsigned char sha1[20];\n\n\tend_url_with_slash(&buf, base_url);\n\tstrbuf_addstr(&buf, \"objects/info/packs\");\n\turl = strbuf_detach(&buf, NULL);\n\n\toptions.no_cache = 1;\n\tret = http_get_strbuf(url, &buf, &options);\n\tif (ret != HTTP_OK)\n\t\tgoto cleanup;\n\n\tdata = buf.buf;\n\twhile (i < buf.len) {\n\t\tswitch (data[i]) {\n\t\tcase 'P':\n\t\t\ti++;\n\t\t\tif (i + 52 <= buf.len &&\n\t\t\t    starts_with(data + i, \" pack-\") &&\n\t\t\t    starts_with(data + i + 46, \".pack\\n\")) {\n\t\t\t\tget_sha1_hex(data + i + 6, sha1);\n\t\t\t\tfetch_and_setup_pack_index(packs_head, sha1,\n\t\t\t\t\t\t      base_url);\n\t\t\t\ti += 51;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\twhile (i < buf.len && data[i] != '\\n')\n\t\t\t\ti++;\n\t\t}\n\t\ti++;\n\t}\n\ncleanup:\n\tfree(url);\n\treturn ret;\n}\n\nvoid release_http_pack_request(struct http_pack_request *preq)\n{\n\tif (preq->packfile != NULL) {\n\t\tfclose(preq->packfile);\n\t\tpreq->packfile = NULL;\n\t}\n\tif (preq->range_header != NULL) {\n\t\tcurl_slist_free_all(preq->range_header);\n\t\tpreq->range_header = NULL;\n\t}\n\tpreq->slot = NULL;\n\tfree(preq->url);\n}\n\nint finish_http_pack_request(struct http_pack_request *preq)\n{\n\tstruct packed_git **lst;\n\tstruct packed_git *p = preq->target;\n\tchar *tmp_idx;\n\tstruct child_process ip;\n\tconst char *ip_argv[8];\n\n\tclose_pack_index(p);\n\n\tfclose(preq->packfile);\n\tpreq->packfile = NULL;\n\n\tlst = preq->lst;\n\twhile (*lst != p)\n\t\tlst = &((*lst)->next);\n\t*lst = (*lst)->next;\n\n\ttmp_idx = xstrdup(preq->tmpfile);\n\tstrcpy(tmp_idx + strlen(tmp_idx) - strlen(\".pack.temp\"),\n\t       \".idx.temp\");\n\n\tip_argv[0] = \"index-pack\";\n\tip_argv[1] = \"-o\";\n\tip_argv[2] = tmp_idx;\n\tip_argv[3] = preq->tmpfile;\n\tip_argv[4] = NULL;\n\n\tmemset(&ip, 0, sizeof(ip));\n\tip.argv = ip_argv;\n\tip.git_cmd = 1;\n\tip.no_stdin = 1;\n\tip.no_stdout = 1;\n\n\tif (run_command(&ip)) {\n\t\tunlink(preq->tmpfile);\n\t\tunlink(tmp_idx);\n\t\tfree(tmp_idx);\n\t\treturn -1;\n\t}\n\n\tunlink(sha1_pack_index_name(p->sha1));\n\n\tif (move_temp_to_file(preq->tmpfile, sha1_pack_name(p->sha1))\n\t || move_temp_to_file(tmp_idx, sha1_pack_index_name(p->sha1))) {\n\t\tfree(tmp_idx);\n\t\treturn -1;\n\t}\n\n\tinstall_packed_git(p);\n\tfree(tmp_idx);\n\treturn 0;\n}\n\nstruct http_pack_request *new_http_pack_request(\n\tstruct packed_git *target, const char *base_url)\n{\n\tlong prev_posn = 0;\n\tchar range[RANGE_HEADER_SIZE];\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct http_pack_request *preq;\n\n\tpreq = xcalloc(1, sizeof(*preq));\n\tpreq->target = target;\n\n\tend_url_with_slash(&buf, base_url);\n\tstrbuf_addf(&buf, \"objects/pack/pack-%s.pack\",\n\t\tsha1_to_hex(target->sha1));\n\tpreq->url = strbuf_detach(&buf, NULL);\n\n\tsnprintf(preq->tmpfile, sizeof(preq->tmpfile), \"%s.temp\",\n\t\tsha1_pack_name(target->sha1));\n\tpreq->packfile = fopen(preq->tmpfile, \"a\");\n\tif (!preq->packfile) {\n\t\terror(\"Unable to open local file %s for pack\",\n\t\t      preq->tmpfile);\n\t\tgoto abort;\n\t}\n\n\tpreq->slot = get_active_slot();\n\tcurl_easy_setopt(preq->slot->curl, CURLOPT_FILE, preq->packfile);\n\tcurl_easy_setopt(preq->slot->curl, CURLOPT_WRITEFUNCTION, fwrite);\n\tcurl_easy_setopt(preq->slot->curl, CURLOPT_URL, preq->url);\n\tcurl_easy_setopt(preq->slot->curl, CURLOPT_HTTPHEADER,\n\t\tno_pragma_header);\n\n\t/*\n\t * If there is data present from a previous transfer attempt,\n\t * resume where it left off\n\t */\n\tprev_posn = ftell(preq->packfile);\n\tif (prev_posn>0) {\n\t\tif (http_is_verbose)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Resuming fetch of pack %s at byte %ld\\n\",\n\t\t\t\tsha1_to_hex(target->sha1), prev_posn);\n\t\tsprintf(range, \"Range: bytes=%ld-\", prev_posn);\n\t\tpreq->range_header = curl_slist_append(NULL, range);\n\t\tcurl_easy_setopt(preq->slot->curl, CURLOPT_HTTPHEADER,\n\t\t\tpreq->range_header);\n\t}\n\n\treturn preq;\n\nabort:\n\tfree(preq->url);\n\tfree(preq);\n\treturn NULL;\n}\n\n/* Helpers for fetching objects (loose) */\nstatic size_t fwrite_sha1_file(char *ptr, size_t eltsize, size_t nmemb,\n\t\t\t       void *data)\n{\n\tunsigned char expn[4096];\n\tsize_t size = eltsize * nmemb;\n\tint posn = 0;\n\tstruct http_object_request *freq =\n\t\t(struct http_object_request *)data;\n\tdo {\n\t\tssize_t retval = xwrite(freq->localfile,\n\t\t\t\t\t(char *) ptr + posn, size - posn);\n\t\tif (retval < 0)\n\t\t\treturn posn;\n\t\tposn += retval;\n\t} while (posn < size);\n\n\tfreq->stream.avail_in = size;\n\tfreq->stream.next_in = (void *)ptr;\n\tdo {\n\t\tfreq->stream.next_out = expn;\n\t\tfreq->stream.avail_out = sizeof(expn);\n\t\tfreq->zret = git_inflate(&freq->stream, Z_SYNC_FLUSH);\n\t\tgit_SHA1_Update(&freq->c, expn,\n\t\t\t\tsizeof(expn) - freq->stream.avail_out);\n\t} while (freq->stream.avail_in && freq->zret == Z_OK);\n\treturn size;\n}\n\nstruct http_object_request *new_http_object_request(const char *base_url,\n\tunsigned char *sha1)\n{\n\tchar *hex = sha1_to_hex(sha1);\n\tconst char *filename;\n\tchar prevfile[PATH_MAX];\n\tint prevlocal;\n\tchar prev_buf[PREV_BUF_SIZE];\n\tssize_t prev_read = 0;\n\tlong prev_posn = 0;\n\tchar range[RANGE_HEADER_SIZE];\n\tstruct curl_slist *range_header = NULL;\n\tstruct http_object_request *freq;\n\n\tfreq = xcalloc(1, sizeof(*freq));\n\thashcpy(freq->sha1, sha1);\n\tfreq->localfile = -1;\n\n\tfilename = sha1_file_name(sha1);\n\tsnprintf(freq->tmpfile, sizeof(freq->tmpfile),\n\t\t \"%s.temp\", filename);\n\n\tsnprintf(prevfile, sizeof(prevfile), \"%s.prev\", filename);\n\tunlink_or_warn(prevfile);\n\trename(freq->tmpfile, prevfile);\n\tunlink_or_warn(freq->tmpfile);\n\n\tif (freq->localfile != -1)\n\t\terror(\"fd leakage in start: %d\", freq->localfile);\n\tfreq->localfile = open(freq->tmpfile,\n\t\t\t       O_WRONLY | O_CREAT | O_EXCL, 0666);\n\t/*\n\t * This could have failed due to the \"lazy directory creation\";\n\t * try to mkdir the last path component.\n\t */\n\tif (freq->localfile < 0 && errno == ENOENT) {\n\t\tchar *dir = strrchr(freq->tmpfile, '/');\n\t\tif (dir) {\n\t\t\t*dir = 0;\n\t\t\tmkdir(freq->tmpfile, 0777);\n\t\t\t*dir = '/';\n\t\t}\n\t\tfreq->localfile = open(freq->tmpfile,\n\t\t\t\t       O_WRONLY | O_CREAT | O_EXCL, 0666);\n\t}\n\n\tif (freq->localfile < 0) {\n\t\terror(\"Couldn't create temporary file %s: %s\",\n\t\t      freq->tmpfile, strerror(errno));\n\t\tgoto abort;\n\t}\n\n\tgit_inflate_init(&freq->stream);\n\n\tgit_SHA1_Init(&freq->c);\n\n\tfreq->url = get_remote_object_url(base_url, hex, 0);\n\n\t/*\n\t * If a previous temp file is present, process what was already\n\t * fetched.\n\t */\n\tprevlocal = open(prevfile, O_RDONLY);\n\tif (prevlocal != -1) {\n\t\tdo {\n\t\t\tprev_read = xread(prevlocal, prev_buf, PREV_BUF_SIZE);\n\t\t\tif (prev_read>0) {\n\t\t\t\tif (fwrite_sha1_file(prev_buf,\n\t\t\t\t\t\t     1,\n\t\t\t\t\t\t     prev_read,\n\t\t\t\t\t\t     freq) == prev_read) {\n\t\t\t\t\tprev_posn += prev_read;\n\t\t\t\t} else {\n\t\t\t\t\tprev_read = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (prev_read > 0);\n\t\tclose(prevlocal);\n\t}\n\tunlink_or_warn(prevfile);\n\n\t/*\n\t * Reset inflate/SHA1 if there was an error reading the previous temp\n\t * file; also rewind to the beginning of the local file.\n\t */\n\tif (prev_read == -1) {\n\t\tmemset(&freq->stream, 0, sizeof(freq->stream));\n\t\tgit_inflate_init(&freq->stream);\n\t\tgit_SHA1_Init(&freq->c);\n\t\tif (prev_posn>0) {\n\t\t\tprev_posn = 0;\n\t\t\tlseek(freq->localfile, 0, SEEK_SET);\n\t\t\tif (ftruncate(freq->localfile, 0) < 0) {\n\t\t\t\terror(\"Couldn't truncate temporary file %s: %s\",\n\t\t\t\t\t  freq->tmpfile, strerror(errno));\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\t}\n\n\tfreq->slot = get_active_slot();\n\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_FILE, freq);\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_WRITEFUNCTION, fwrite_sha1_file);\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_ERRORBUFFER, freq->errorstr);\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_URL, freq->url);\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_HTTPHEADER, no_pragma_header);\n\n\t/*\n\t * If we have successfully processed data from a previous fetch\n\t * attempt, only fetch the data we don't already have.\n\t */\n\tif (prev_posn>0) {\n\t\tif (http_is_verbose)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Resuming fetch of object %s at byte %ld\\n\",\n\t\t\t\thex, prev_posn);\n\t\tsprintf(range, \"Range: bytes=%ld-\", prev_posn);\n\t\trange_header = curl_slist_append(range_header, range);\n\t\tcurl_easy_setopt(freq->slot->curl,\n\t\t\t\t CURLOPT_HTTPHEADER, range_header);\n\t}\n\n\treturn freq;\n\nabort:\n\tfree(freq->url);\n\tfree(freq);\n\treturn NULL;\n}\n\nvoid process_http_object_request(struct http_object_request *freq)\n{\n\tif (freq->slot == NULL)\n\t\treturn;\n\tfreq->curl_result = freq->slot->curl_result;\n\tfreq->http_code = freq->slot->http_code;\n\tfreq->slot = NULL;\n}\n\nint finish_http_object_request(struct http_object_request *freq)\n{\n\tstruct stat st;\n\n\tclose(freq->localfile);\n\tfreq->localfile = -1;\n\n\tprocess_http_object_request(freq);\n\n\tif (freq->http_code == 416) {\n\t\twarning(\"requested range invalid; we may already have all the data.\");\n\t} else if (freq->curl_result != CURLE_OK) {\n\t\tif (stat(freq->tmpfile, &st) == 0)\n\t\t\tif (st.st_size == 0)\n\t\t\t\tunlink_or_warn(freq->tmpfile);\n\t\treturn -1;\n\t}\n\n\tgit_inflate_end(&freq->stream);\n\tgit_SHA1_Final(freq->real_sha1, &freq->c);\n\tif (freq->zret != Z_STREAM_END) {\n\t\tunlink_or_warn(freq->tmpfile);\n\t\treturn -1;\n\t}\n\tif (hashcmp(freq->sha1, freq->real_sha1)) {\n\t\tunlink_or_warn(freq->tmpfile);\n\t\treturn -1;\n\t}\n\tfreq->rename =\n\t\tmove_temp_to_file(freq->tmpfile, sha1_file_name(freq->sha1));\n\n\treturn freq->rename;\n}\n\nvoid abort_http_object_request(struct http_object_request *freq)\n{\n\tunlink_or_warn(freq->tmpfile);\n\n\trelease_http_object_request(freq);\n}\n\nvoid release_http_object_request(struct http_object_request *freq)\n{\n\tif (freq->localfile != -1) {\n\t\tclose(freq->localfile);\n\t\tfreq->localfile = -1;\n\t}\n\tif (freq->url != NULL) {\n\t\tfree(freq->url);\n\t\tfreq->url = NULL;\n\t}\n\tif (freq->slot != NULL) {\n\t\tfreq->slot->callback_func = NULL;\n\t\tfreq->slot->callback_data = NULL;\n\t\trelease_active_slot(freq->slot);\n\t\tfreq->slot = NULL;\n\t}\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0031b3a939a5224cb74970e8f1e5a642678bb0eb",
  "sha1_ok": true,
  "size": 39508
}
