{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImV4ZWMtY21kLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAibGV2ZW5zaHRlaW4uaCIKI2luY2x1ZGUgImhlbHAuaCIKI2luY2x1ZGUgImNvbW1hbmQtbGlzdC5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgImNvbHVtbi5oIgojaW5jbHVkZSAidmVyc2lvbi5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAicHJvbXB0LmgiCgpzdHJ1Y3QgY2F0ZWdvcnlfZGVzY3JpcHRpb24gewoJdWludDMyX3QgY2F0ZWdvcnk7Cgljb25zdCBjaGFyICpkZXNjOwp9OwpzdGF0aWMgdWludDMyX3QgY29tbW9uX21hc2sgPQoJQ0FUX2luaXQgfCBDQVRfd29ya3RyZWUgfCBDQVRfaW5mbyB8CglDQVRfaGlzdG9yeSB8IENBVF9yZW1vdGU7CnN0YXRpYyBzdHJ1Y3QgY2F0ZWdvcnlfZGVzY3JpcHRpb24gY29tbW9uX2NhdGVnb3JpZXNbXSA9IHsKCXsgQ0FUX2luaXQsIE5fKCJzdGFydCBhIHdvcmtpbmcgYXJlYSAoc2VlIGFsc286IGdpdCBoZWxwIHR1dG9yaWFsKSIpIH0sCgl7IENBVF93b3JrdHJlZSwgTl8oIndvcmsgb24gdGhlIGN1cnJlbnQgY2hhbmdlIChzZWUgYWxzbzogZ2l0IGhlbHAgZXZlcnlkYXkpIikgfSwKCXsgQ0FUX2luZm8sIE5fKCJleGFtaW5lIHRoZSBoaXN0b3J5IGFuZCBzdGF0ZSAoc2VlIGFsc286IGdpdCBoZWxwIHJldmlzaW9ucykiKSB9LAoJeyBDQVRfaGlzdG9yeSwgTl8oImdyb3csIG1hcmsgYW5kIHR3ZWFrIHlvdXIgY29tbW9uIGhpc3RvcnkiKSB9LAoJeyBDQVRfcmVtb3RlLCBOXygiY29sbGFib3JhdGUgKHNlZSBhbHNvOiBnaXQgaGVscCB3b3JrZmxvd3MpIikgfSwKCXsgMCwgTlVMTCB9Cn07CnN0YXRpYyBzdHJ1Y3QgY2F0ZWdvcnlfZGVzY3JpcHRpb24gbWFpbl9jYXRlZ29yaWVzW10gPSB7Cgl7IENBVF9tYWlucG9yY2VsYWluLCBOXygiTWFpbiBQb3JjZWxhaW4gQ29tbWFuZHMiKSB9LAoJeyBDQVRfYW5jaWxsYXJ5bWFuaXB1bGF0b3JzLCBOXygiQW5jaWxsYXJ5IENvbW1hbmRzIC8gTWFuaXB1bGF0b3JzIikgfSwKCXsgQ0FUX2FuY2lsbGFyeWludGVycm9nYXRvcnMsIE5fKCJBbmNpbGxhcnkgQ29tbWFuZHMgLyBJbnRlcnJvZ2F0b3JzIikgfSwKCXsgQ0FUX2ZvcmVpZ25zY21pbnRlcmZhY2UsIE5fKCJJbnRlcmFjdGluZyB3aXRoIE90aGVycyIpIH0sCgl7IENBVF9wbHVtYmluZ21hbmlwdWxhdG9ycywgTl8oIkxvdy1sZXZlbCBDb21tYW5kcyAvIE1hbmlwdWxhdG9ycyIpIH0sCgl7IENBVF9wbHVtYmluZ2ludGVycm9nYXRvcnMsIE5fKCJMb3ctbGV2ZWwgQ29tbWFuZHMgLyBJbnRlcnJvZ2F0b3JzIikgfSwKCXsgQ0FUX3N5bmNoaW5ncmVwb3NpdG9yaWVzLCBOXygiTG93LWxldmVsIENvbW1hbmRzIC8gU3luY2luZyBSZXBvc2l0b3JpZXMiKSB9LAoJeyBDQVRfcHVyZWhlbHBlcnMsIE5fKCJMb3ctbGV2ZWwgQ29tbWFuZHMgLyBJbnRlcm5hbCBIZWxwZXJzIikgfSwKCXsgMCwgTlVMTCB9Cn07CgpzdGF0aWMgY29uc3QgY2hhciAqZHJvcF9wcmVmaXgoY29uc3QgY2hhciAqbmFtZSwgdWludDMyX3QgY2F0ZWdvcnkpCnsKCWNvbnN0IGNoYXIgKm5ld19uYW1lOwoKCWlmIChza2lwX3ByZWZpeChuYW1lLCAiZ2l0LSIsICZuZXdfbmFtZSkpCgkJcmV0dXJuIG5ld19uYW1lOwoJaWYgKGNhdGVnb3J5ID09IENBVF9ndWlkZSAmJiBza2lwX3ByZWZpeChuYW1lLCAiZ2l0IiwgJm5ld19uYW1lKSkKCQlyZXR1cm4gbmV3X25hbWU7CglyZXR1cm4gbmFtZTsKCn0KCnN0YXRpYyB2b2lkIGV4dHJhY3RfY21kcyhzdHJ1Y3QgY21kbmFtZV9oZWxwICoqcF9jbWRzLCB1aW50MzJfdCBtYXNrKQp7CglpbnQgaSwgbnIgPSAwOwoJc3RydWN0IGNtZG5hbWVfaGVscCAqY21kczsKCglpZiAoQVJSQVlfU0laRShjb21tYW5kX2xpc3QpID09IDApCgkJQlVHKCJlbXB0eSBjb21tYW5kX2xpc3RbXSBpcyBhIHNpZ24gb2YgYnJva2VuIGdlbmVyYXRlLWNtZGxpc3Quc2giKTsKCglBTExPQ19BUlJBWShjbWRzLCBBUlJBWV9TSVpFKGNvbW1hbmRfbGlzdCkgKyAxKTsKCglmb3IgKGkgPSAwOyBpIDwgQVJSQVlfU0laRShjb21tYW5kX2xpc3QpOyBpKyspIHsKCQljb25zdCBzdHJ1Y3QgY21kbmFtZV9oZWxwICpjbWQgPSBjb21tYW5kX2xpc3QgKyBpOwoKCQlpZiAoIShjbWQtPmNhdGVnb3J5ICYgbWFzaykpCgkJCWNvbnRpbnVlOwoKCQljbWRzW25yXSA9ICpjbWQ7CgkJY21kc1tucl0ubmFtZSA9IGRyb3BfcHJlZml4KGNtZC0+bmFtZSwgY21kLT5jYXRlZ29yeSk7CgoJCW5yKys7Cgl9CgljbWRzW25yXS5uYW1lID0gTlVMTDsKCSpwX2NtZHMgPSBjbWRzOwp9CgpzdGF0aWMgdm9pZCBwcmludF9jb21tYW5kX2xpc3QoY29uc3Qgc3RydWN0IGNtZG5hbWVfaGVscCAqY21kcywKCQkJICAgICAgIHVpbnQzMl90IG1hc2ssIGludCBsb25nZXN0KQp7CglpbnQgaTsKCglmb3IgKGkgPSAwOyBjbWRzW2ldLm5hbWU7IGkrKykgewoJCWlmIChjbWRzW2ldLmNhdGVnb3J5ICYgbWFzaykgewoJCQlzaXplX3QgbGVuID0gc3RybGVuKGNtZHNbaV0ubmFtZSk7CgkJCXByaW50ZigiICAgJXMgICAiLCBjbWRzW2ldLm5hbWUpOwoJCQlpZiAobG9uZ2VzdCA+IGxlbikKCQkJCW1wdXRfY2hhcignICcsIGxvbmdlc3QgLSBsZW4pOwoJCQlwdXRzKF8oY21kc1tpXS5oZWxwKSk7CgkJfQoJfQp9CgpzdGF0aWMgaW50IGNtZF9uYW1lX2NtcChjb25zdCB2b2lkICplbGVtMSwgY29uc3Qgdm9pZCAqZWxlbTIpCnsKCWNvbnN0IHN0cnVjdCBjbWRuYW1lX2hlbHAgKmUxID0gZWxlbTE7Cgljb25zdCBzdHJ1Y3QgY21kbmFtZV9oZWxwICplMiA9IGVsZW0yOwoKCXJldHVybiBzdHJjbXAoZTEtPm5hbWUsIGUyLT5uYW1lKTsKfQoKc3RhdGljIHZvaWQgcHJpbnRfY21kX2J5X2NhdGVnb3J5KGNvbnN0IHN0cnVjdCBjYXRlZ29yeV9kZXNjcmlwdGlvbiAqY2F0ZGVzYywKCQkJCSAgaW50ICpsb25nZXN0X3ApCnsKCXN0cnVjdCBjbWRuYW1lX2hlbHAgKmNtZHM7CglpbnQgbG9uZ2VzdCA9IDA7CglpbnQgaSwgbnIgPSAwOwoJdWludDMyX3QgbWFzayA9IDA7CgoJZm9yIChpID0gMDsgY2F0ZGVzY1tpXS5kZXNjOyBpKyspCgkJbWFzayB8PSBjYXRkZXNjW2ldLmNhdGVnb3J5OwoKCWV4dHJhY3RfY21kcygmY21kcywgbWFzayk7CgoJZm9yIChpID0gMDsgY21kc1tpXS5uYW1lOyBpKyssIG5yKyspIHsKCQlpZiAobG9uZ2VzdCA8IHN0cmxlbihjbWRzW2ldLm5hbWUpKQoJCQlsb25nZXN0ID0gc3RybGVuKGNtZHNbaV0ubmFtZSk7Cgl9CglRU09SVChjbWRzLCBuciwgY21kX25hbWVfY21wKTsKCglmb3IgKGkgPSAwOyBjYXRkZXNjW2ldLmRlc2M7IGkrKykgewoJCXVpbnQzMl90IG1hc2sgPSBjYXRkZXNjW2ldLmNhdGVnb3J5OwoJCWNvbnN0IGNoYXIgKmRlc2MgPSBjYXRkZXNjW2ldLmRlc2M7CgoJCXB1dGNoYXIoJ1xuJyk7CgkJcHV0cyhfKGRlc2MpKTsKCQlwcmludF9jb21tYW5kX2xpc3QoY21kcywgbWFzaywgbG9uZ2VzdCk7Cgl9CglmcmVlKGNtZHMpOwoJaWYgKGxvbmdlc3RfcCkKCQkqbG9uZ2VzdF9wID0gbG9uZ2VzdDsKfQoKdm9pZCBhZGRfY21kbmFtZShzdHJ1Y3QgY21kbmFtZXMgKmNtZHMsIGNvbnN0IGNoYXIgKm5hbWUsIGludCBsZW4pCnsKCXN0cnVjdCBjbWRuYW1lICplbnQ7CglGTEVYX0FMTE9DX01FTShlbnQsIG5hbWUsIG5hbWUsIGxlbik7CgllbnQtPmxlbiA9IGxlbjsKCglBTExPQ19HUk9XKGNtZHMtPm5hbWVzLCBjbWRzLT5jbnQgKyAxLCBjbWRzLT5hbGxvYyk7CgljbWRzLT5uYW1lc1tjbWRzLT5jbnQrK10gPSBlbnQ7Cn0KCnN0YXRpYyB2b2lkIGNsZWFuX2NtZG5hbWVzKHN0cnVjdCBjbWRuYW1lcyAqY21kcykKewoJaW50IGk7Cglmb3IgKGkgPSAwOyBpIDwgY21kcy0+Y250OyArK2kpCgkJZnJlZShjbWRzLT5uYW1lc1tpXSk7CglmcmVlKGNtZHMtPm5hbWVzKTsKCWNtZHMtPmNudCA9IDA7CgljbWRzLT5hbGxvYyA9IDA7Cn0KCnN0YXRpYyBpbnQgY21kbmFtZV9jb21wYXJlKGNvbnN0IHZvaWQgKmFfLCBjb25zdCB2b2lkICpiXykKewoJc3RydWN0IGNtZG5hbWUgKmEgPSAqKHN0cnVjdCBjbWRuYW1lICoqKWFfOwoJc3RydWN0IGNtZG5hbWUgKmIgPSAqKHN0cnVjdCBjbWRuYW1lICoqKWJfOwoJcmV0dXJuIHN0cmNtcChhLT5uYW1lLCBiLT5uYW1lKTsKfQoKc3RhdGljIHZvaWQgdW5pcShzdHJ1Y3QgY21kbmFtZXMgKmNtZHMpCnsKCWludCBpLCBqOwoKCWlmICghY21kcy0+Y250KQoJCXJldHVybjsKCglmb3IgKGkgPSBqID0gMTsgaSA8IGNtZHMtPmNudDsgaSsrKSB7CgkJaWYgKCFzdHJjbXAoY21kcy0+bmFtZXNbaV0tPm5hbWUsIGNtZHMtPm5hbWVzW2otMV0tPm5hbWUpKQoJCQlmcmVlKGNtZHMtPm5hbWVzW2ldKTsKCQllbHNlCgkJCWNtZHMtPm5hbWVzW2orK10gPSBjbWRzLT5uYW1lc1tpXTsKCX0KCgljbWRzLT5jbnQgPSBqOwp9Cgp2b2lkIGV4Y2x1ZGVfY21kcyhzdHJ1Y3QgY21kbmFtZXMgKmNtZHMsIHN0cnVjdCBjbWRuYW1lcyAqZXhjbHVkZXMpCnsKCWludCBjaSwgY2osIGVpOwoJaW50IGNtcDsKCgljaSA9IGNqID0gZWkgPSAwOwoJd2hpbGUgKGNpIDwgY21kcy0+Y250ICYmIGVpIDwgZXhjbHVkZXMtPmNudCkgewoJCWNtcCA9IHN0cmNtcChjbWRzLT5uYW1lc1tjaV0tPm5hbWUsIGV4Y2x1ZGVzLT5uYW1lc1tlaV0tPm5hbWUpOwoJCWlmIChjbXAgPCAwKQoJCQljbWRzLT5uYW1lc1tjaisrXSA9IGNtZHMtPm5hbWVzW2NpKytdOwoJCWVsc2UgaWYgKGNtcCA9PSAwKSB7CgkJCWVpKys7CgkJCWZyZWUoY21kcy0+bmFtZXNbY2krK10pOwoJCX0gZWxzZSBpZiAoY21wID4gMCkKCQkJZWkrKzsKCX0KCgl3aGlsZSAoY2kgPCBjbWRzLT5jbnQpCgkJY21kcy0+bmFtZXNbY2orK10gPSBjbWRzLT5uYW1lc1tjaSsrXTsKCgljbWRzLT5jbnQgPSBjajsKfQoKc3RhdGljIHZvaWQgcHJldHR5X3ByaW50X2NtZG5hbWVzKHN0cnVjdCBjbWRuYW1lcyAqY21kcywgdW5zaWduZWQgaW50IGNvbG9wdHMpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdCBsaXN0ID0gU1RSSU5HX0xJU1RfSU5JVF9OT0RVUDsKCXN0cnVjdCBjb2x1bW5fb3B0aW9ucyBjb3B0czsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBjbWRzLT5jbnQ7IGkrKykKCQlzdHJpbmdfbGlzdF9hcHBlbmQoJmxpc3QsIGNtZHMtPm5hbWVzW2ldLT5uYW1lKTsKCS8qCgkgKiBhbHdheXMgZW5hYmxlIGNvbHVtbiBkaXNwbGF5LCB3ZSBvbmx5IGNvbnN1bHQgY29sdW1uLioKCSAqIGFib3V0IGxheW91dCBzdHJhdGVneSBhbmQgc3R1ZmYKCSAqLwoJY29sb3B0cyA9IChjb2xvcHRzICYgfkNPTF9FTkFCTEVfTUFTSykgfCBDT0xfRU5BQkxFRDsKCW1lbXNldCgmY29wdHMsIDAsIHNpemVvZihjb3B0cykpOwoJY29wdHMuaW5kZW50ID0gIiAgIjsKCWNvcHRzLnBhZGRpbmcgPSAyOwoJcHJpbnRfY29sdW1ucygmbGlzdCwgY29sb3B0cywgJmNvcHRzKTsKCXN0cmluZ19saXN0X2NsZWFyKCZsaXN0LCAwKTsKfQoKc3RhdGljIHZvaWQgbGlzdF9jb21tYW5kc19pbl9kaXIoc3RydWN0IGNtZG5hbWVzICpjbWRzLAoJCQkJCSBjb25zdCBjaGFyICpwYXRoLAoJCQkJCSBjb25zdCBjaGFyICpwcmVmaXgpCnsKCURJUiAqZGlyID0gb3BlbmRpcihwYXRoKTsKCXN0cnVjdCBkaXJlbnQgKmRlOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWludCBsZW47CgoJaWYgKCFkaXIpCgkJcmV0dXJuOwoJaWYgKCFwcmVmaXgpCgkJcHJlZml4ID0gImdpdC0iOwoKCXN0cmJ1Zl9hZGRmKCZidWYsICIlcy8iLCBwYXRoKTsKCWxlbiA9IGJ1Zi5sZW47CgoJd2hpbGUgKChkZSA9IHJlYWRkaXIoZGlyKSkgIT0gTlVMTCkgewoJCWNvbnN0IGNoYXIgKmVudDsKCQlzaXplX3QgZW50bGVuOwoKCQlpZiAoIXNraXBfcHJlZml4KGRlLT5kX25hbWUsIHByZWZpeCwgJmVudCkpCgkJCWNvbnRpbnVlOwoKCQlzdHJidWZfc2V0bGVuKCZidWYsIGxlbik7CgkJc3RyYnVmX2FkZHN0cigmYnVmLCBkZS0+ZF9uYW1lKTsKCQlpZiAoIWlzX2V4ZWN1dGFibGUoYnVmLmJ1ZikpCgkJCWNvbnRpbnVlOwoKCQllbnRsZW4gPSBzdHJsZW4oZW50KTsKCQlzdHJpcF9zdWZmaXgoZW50LCAiLmV4ZSIsICZlbnRsZW4pOwoKCQlhZGRfY21kbmFtZShjbWRzLCBlbnQsIGVudGxlbik7Cgl9CgljbG9zZWRpcihkaXIpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7Cn0KCnZvaWQgbG9hZF9jb21tYW5kX2xpc3QoY29uc3QgY2hhciAqcHJlZml4LAoJCXN0cnVjdCBjbWRuYW1lcyAqbWFpbl9jbWRzLAoJCXN0cnVjdCBjbWRuYW1lcyAqb3RoZXJfY21kcykKewoJY29uc3QgY2hhciAqZW52X3BhdGggPSBnZXRlbnYoIlBBVEgiKTsKCWNvbnN0IGNoYXIgKmV4ZWNfcGF0aCA9IGdpdF9leGVjX3BhdGgoKTsKCglsb2FkX2J1aWx0aW5fY29tbWFuZHMocHJlZml4LCBtYWluX2NtZHMpOwoKCWlmIChleGVjX3BhdGgpIHsKCQlsaXN0X2NvbW1hbmRzX2luX2RpcihtYWluX2NtZHMsIGV4ZWNfcGF0aCwgcHJlZml4KTsKCQlRU09SVChtYWluX2NtZHMtPm5hbWVzLCBtYWluX2NtZHMtPmNudCwgY21kbmFtZV9jb21wYXJlKTsKCQl1bmlxKG1haW5fY21kcyk7Cgl9CgoJaWYgKGVudl9wYXRoKSB7CgkJY2hhciAqcGF0aHMsICpwYXRoLCAqY29sb247CgkJcGF0aCA9IHBhdGhzID0geHN0cmR1cChlbnZfcGF0aCk7CgkJd2hpbGUgKDEpIHsKCQkJaWYgKChjb2xvbiA9IHN0cmNocihwYXRoLCBQQVRIX1NFUCkpKQoJCQkJKmNvbG9uID0gMDsKCQkJaWYgKCFleGVjX3BhdGggfHwgc3RyY21wKHBhdGgsIGV4ZWNfcGF0aCkpCgkJCQlsaXN0X2NvbW1hbmRzX2luX2RpcihvdGhlcl9jbWRzLCBwYXRoLCBwcmVmaXgpOwoKCQkJaWYgKCFjb2xvbikKCQkJCWJyZWFrOwoJCQlwYXRoID0gY29sb24gKyAxOwoJCX0KCQlmcmVlKHBhdGhzKTsKCgkJUVNPUlQob3RoZXJfY21kcy0+bmFtZXMsIG90aGVyX2NtZHMtPmNudCwgY21kbmFtZV9jb21wYXJlKTsKCQl1bmlxKG90aGVyX2NtZHMpOwoJfQoJZXhjbHVkZV9jbWRzKG90aGVyX2NtZHMsIG1haW5fY21kcyk7Cn0KCnN0YXRpYyBpbnQgZ2V0X2NvbG9wdHMoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSwgdm9pZCAqZGF0YSkKewoJdW5zaWduZWQgaW50ICpjb2xvcHRzID0gZGF0YTsKCglpZiAoc3RhcnRzX3dpdGgodmFyLCAiY29sdW1uLiIpKQoJCXJldHVybiBnaXRfY29sdW1uX2NvbmZpZyh2YXIsIHZhbHVlLCAiaGVscCIsIGNvbG9wdHMpOwoKCXJldHVybiAwOwp9Cgp2b2lkIGxpc3RfY29tbWFuZHMoc3RydWN0IGNtZG5hbWVzICptYWluX2NtZHMsIHN0cnVjdCBjbWRuYW1lcyAqb3RoZXJfY21kcykKewoJdW5zaWduZWQgaW50IGNvbG9wdHMgPSAwOwoJZ2l0X2NvbmZpZyhnZXRfY29sb3B0cywgJmNvbG9wdHMpOwoKCWlmIChtYWluX2NtZHMtPmNudCkgewoJCWNvbnN0IGNoYXIgKmV4ZWNfcGF0aCA9IGdpdF9leGVjX3BhdGgoKTsKCQlwcmludGZfbG4oXygiYXZhaWxhYmxlIGdpdCBjb21tYW5kcyBpbiAnJXMnIiksIGV4ZWNfcGF0aCk7CgkJcHV0Y2hhcignXG4nKTsKCQlwcmV0dHlfcHJpbnRfY21kbmFtZXMobWFpbl9jbWRzLCBjb2xvcHRzKTsKCQlwdXRjaGFyKCdcbicpOwoJfQoKCWlmIChvdGhlcl9jbWRzLT5jbnQpIHsKCQlwdXRzKF8oImdpdCBjb21tYW5kcyBhdmFpbGFibGUgZnJvbSBlbHNld2hlcmUgb24geW91ciAkUEFUSCIpKTsKCQlwdXRjaGFyKCdcbicpOwoJCXByZXR0eV9wcmludF9jbWRuYW1lcyhvdGhlcl9jbWRzLCBjb2xvcHRzKTsKCQlwdXRjaGFyKCdcbicpOwoJfQp9Cgp2b2lkIGxpc3RfY29tbW9uX2NtZHNfaGVscCh2b2lkKQp7CglwdXRzKF8oIlRoZXNlIGFyZSBjb21tb24gR2l0IGNvbW1hbmRzIHVzZWQgaW4gdmFyaW91cyBzaXR1YXRpb25zOiIpKTsKCXByaW50X2NtZF9ieV9jYXRlZ29yeShjb21tb25fY2F0ZWdvcmllcywgTlVMTCk7Cn0KCnZvaWQgbGlzdF9hbGxfbWFpbl9jbWRzKHN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCkKewoJc3RydWN0IGNtZG5hbWVzIG1haW5fY21kcywgb3RoZXJfY21kczsKCWludCBpOwoKCW1lbXNldCgmbWFpbl9jbWRzLCAwLCBzaXplb2YobWFpbl9jbWRzKSk7CgltZW1zZXQoJm90aGVyX2NtZHMsIDAsIHNpemVvZihvdGhlcl9jbWRzKSk7Cglsb2FkX2NvbW1hbmRfbGlzdCgiZ2l0LSIsICZtYWluX2NtZHMsICZvdGhlcl9jbWRzKTsKCglmb3IgKGkgPSAwOyBpIDwgbWFpbl9jbWRzLmNudDsgaSsrKQoJCXN0cmluZ19saXN0X2FwcGVuZChsaXN0LCBtYWluX2NtZHMubmFtZXNbaV0tPm5hbWUpOwoKCWNsZWFuX2NtZG5hbWVzKCZtYWluX2NtZHMpOwoJY2xlYW5fY21kbmFtZXMoJm90aGVyX2NtZHMpOwp9Cgp2b2lkIGxpc3RfYWxsX290aGVyX2NtZHMoc3RydWN0IHN0cmluZ19saXN0ICpsaXN0KQp7CglzdHJ1Y3QgY21kbmFtZXMgbWFpbl9jbWRzLCBvdGhlcl9jbWRzOwoJaW50IGk7CgoJbWVtc2V0KCZtYWluX2NtZHMsIDAsIHNpemVvZihtYWluX2NtZHMpKTsKCW1lbXNldCgmb3RoZXJfY21kcywgMCwgc2l6ZW9mKG90aGVyX2NtZHMpKTsKCWxvYWRfY29tbWFuZF9saXN0KCJnaXQtIiwgJm1haW5fY21kcywgJm90aGVyX2NtZHMpOwoKCWZvciAoaSA9IDA7IGkgPCBvdGhlcl9jbWRzLmNudDsgaSsrKQoJCXN0cmluZ19saXN0X2FwcGVuZChsaXN0LCBvdGhlcl9jbWRzLm5hbWVzW2ldLT5uYW1lKTsKCgljbGVhbl9jbWRuYW1lcygmbWFpbl9jbWRzKTsKCWNsZWFuX2NtZG5hbWVzKCZvdGhlcl9jbWRzKTsKfQoKdm9pZCBsaXN0X2NtZHNfYnlfY2F0ZWdvcnkoc3RydWN0IHN0cmluZ19saXN0ICpsaXN0LAoJCQkgICBjb25zdCBjaGFyICpjYXQpCnsKCWludCBpLCBuID0gQVJSQVlfU0laRShjb21tYW5kX2xpc3QpOwoJdWludDMyX3QgY2F0X2lkID0gMDsKCglmb3IgKGkgPSAwOyBjYXRlZ29yeV9uYW1lc1tpXTsgaSsrKSB7CgkJaWYgKCFzdHJjbXAoY2F0LCBjYXRlZ29yeV9uYW1lc1tpXSkpIHsKCQkJY2F0X2lkID0gMVVMIDw8IGk7CgkJCWJyZWFrOwoJCX0KCX0KCWlmICghY2F0X2lkKQoJCWRpZShfKCJ1bnN1cHBvcnRlZCBjb21tYW5kIGxpc3RpbmcgdHlwZSAnJXMnIiksIGNhdCk7CgoJZm9yIChpID0gMDsgaSA8IG47IGkrKykgewoJCXN0cnVjdCBjbWRuYW1lX2hlbHAgKmNtZCA9IGNvbW1hbmRfbGlzdCArIGk7CgoJCWlmICghKGNtZC0+Y2F0ZWdvcnkgJiBjYXRfaWQpKQoJCQljb250aW51ZTsKCQlzdHJpbmdfbGlzdF9hcHBlbmQobGlzdCwgZHJvcF9wcmVmaXgoY21kLT5uYW1lLCBjbWQtPmNhdGVnb3J5KSk7Cgl9Cn0KCnZvaWQgbGlzdF9jbWRzX2J5X2NvbmZpZyhzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QpCnsKCWNvbnN0IGNoYXIgKmNtZF9saXN0OwoKCWlmIChnaXRfY29uZmlnX2dldF9zdHJpbmdfdG1wKCJjb21wbGV0aW9uLmNvbW1hbmRzIiwgJmNtZF9saXN0KSkKCQlyZXR1cm47CgoJc3RyaW5nX2xpc3Rfc29ydChsaXN0KTsKCXN0cmluZ19saXN0X3JlbW92ZV9kdXBsaWNhdGVzKGxpc3QsIDApOwoKCXdoaWxlICgqY21kX2xpc3QpIHsKCQlzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CgkJY29uc3QgY2hhciAqcCA9IHN0cmNocm51bChjbWRfbGlzdCwgJyAnKTsKCgkJc3RyYnVmX2FkZCgmc2IsIGNtZF9saXN0LCBwIC0gY21kX2xpc3QpOwoJCWlmIChzYi5idWZbMF0gPT0gJy0nKQoJCQlzdHJpbmdfbGlzdF9yZW1vdmUobGlzdCwgc2IuYnVmICsgMSwgMCk7CgkJZWxzZQoJCQlzdHJpbmdfbGlzdF9pbnNlcnQobGlzdCwgc2IuYnVmKTsKCQlzdHJidWZfcmVsZWFzZSgmc2IpOwoJCXdoaWxlICgqcCA9PSAnICcpCgkJCXArKzsKCQljbWRfbGlzdCA9IHA7Cgl9Cn0KCnZvaWQgbGlzdF9ndWlkZXNfaGVscCh2b2lkKQp7CglzdHJ1Y3QgY2F0ZWdvcnlfZGVzY3JpcHRpb24gY2F0ZGVzY1tdID0gewoJCXsgQ0FUX2d1aWRlLCBOXygiVGhlIEdpdCBjb25jZXB0IGd1aWRlcyBhcmU6IikgfSwKCQl7IDAsIE5VTEwgfQoJfTsKCXByaW50X2NtZF9ieV9jYXRlZ29yeShjYXRkZXNjLCBOVUxMKTsKCXB1dGNoYXIoJ1xuJyk7Cn0KCnN0YXRpYyBpbnQgZ2V0X2FsaWFzKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmRhdGEpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCA9IGRhdGE7CgoJaWYgKHNraXBfcHJlZml4KHZhciwgImFsaWFzLiIsICZ2YXIpKQoJCXN0cmluZ19saXN0X2FwcGVuZChsaXN0LCB2YXIpLT51dGlsID0geHN0cmR1cCh2YWx1ZSk7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGxpc3RfYWxsX2NtZHNfaGVscF9leHRlcm5hbF9jb21tYW5kcyh2b2lkKQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3Qgb3RoZXJzID0gU1RSSU5HX0xJU1RfSU5JVF9EVVA7CglpbnQgaTsKCglsaXN0X2FsbF9vdGhlcl9jbWRzKCZvdGhlcnMpOwoJaWYgKG90aGVycy5ucikKCQlwcmludGYoIlxuJXNcbiIsIF8oIkV4dGVybmFsIGNvbW1hbmRzIikpOwoJZm9yIChpID0gMDsgaSA8IG90aGVycy5ucjsgaSsrKQoJCXByaW50ZigiICAgJXNcbiIsIG90aGVycy5pdGVtc1tpXS5zdHJpbmcpOwoJc3RyaW5nX2xpc3RfY2xlYXIoJm90aGVycywgMCk7Cn0KCnN0YXRpYyB2b2lkIGxpc3RfYWxsX2NtZHNfaGVscF9hbGlhc2VzKGludCBsb25nZXN0KQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgYWxpYXNfbGlzdCA9IFNUUklOR19MSVNUX0lOSVRfRFVQOwoJc3RydWN0IGNtZG5hbWVfaGVscCAqYWxpYXNlczsKCWludCBpOwoKCWdpdF9jb25maWcoZ2V0X2FsaWFzLCAmYWxpYXNfbGlzdCk7CglzdHJpbmdfbGlzdF9zb3J0KCZhbGlhc19saXN0KTsKCglmb3IgKGkgPSAwOyBpIDwgYWxpYXNfbGlzdC5ucjsgaSsrKSB7CgkJc2l6ZV90IGxlbiA9IHN0cmxlbihhbGlhc19saXN0Lml0ZW1zW2ldLnN0cmluZyk7CgkJaWYgKGxvbmdlc3QgPCBsZW4pCgkJCWxvbmdlc3QgPSBsZW47Cgl9CgoJaWYgKGFsaWFzX2xpc3QubnIpIHsKCQlwcmludGYoIlxuJXNcbiIsIF8oIkNvbW1hbmQgYWxpYXNlcyIpKTsKCQlBTExPQ19BUlJBWShhbGlhc2VzLCBhbGlhc19saXN0Lm5yICsgMSk7CgkJZm9yIChpID0gMDsgaSA8IGFsaWFzX2xpc3QubnI7IGkrKykgewoJCQlhbGlhc2VzW2ldLm5hbWUgPSBhbGlhc19saXN0Lml0ZW1zW2ldLnN0cmluZzsKCQkJYWxpYXNlc1tpXS5oZWxwID0gYWxpYXNfbGlzdC5pdGVtc1tpXS51dGlsOwoJCQlhbGlhc2VzW2ldLmNhdGVnb3J5ID0gMTsKCQl9CgkJYWxpYXNlc1thbGlhc19saXN0Lm5yXS5uYW1lID0gTlVMTDsKCQlwcmludF9jb21tYW5kX2xpc3QoYWxpYXNlcywgMSwgbG9uZ2VzdCk7CgkJZnJlZShhbGlhc2VzKTsKCX0KCXN0cmluZ19saXN0X2NsZWFyKCZhbGlhc19saXN0LCAxKTsKfQoKdm9pZCBsaXN0X2FsbF9jbWRzX2hlbHAodm9pZCkKewoJaW50IGxvbmdlc3Q7CgoJcHV0cyhfKCJTZWUgJ2dpdCBoZWxwIDxjb21tYW5kPicgdG8gcmVhZCBhYm91dCBhIHNwZWNpZmljIHN1YmNvbW1hbmQiKSk7CglwcmludF9jbWRfYnlfY2F0ZWdvcnkobWFpbl9jYXRlZ29yaWVzLCAmbG9uZ2VzdCk7CgoJbGlzdF9hbGxfY21kc19oZWxwX2V4dGVybmFsX2NvbW1hbmRzKCk7CglsaXN0X2FsbF9jbWRzX2hlbHBfYWxpYXNlcyhsb25nZXN0KTsKfQoKaW50IGlzX2luX2NtZGxpc3Qoc3RydWN0IGNtZG5hbWVzICpjLCBjb25zdCBjaGFyICpzKQp7CglpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCBjLT5jbnQ7IGkrKykKCQlpZiAoIXN0cmNtcChzLCBjLT5uYW1lc1tpXS0+bmFtZSkpCgkJCXJldHVybiAxOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgYXV0b2NvcnJlY3Q7CnN0YXRpYyBzdHJ1Y3QgY21kbmFtZXMgYWxpYXNlczsKCiNkZWZpbmUgQVVUT0NPUlJFQ1RfUFJPTVBUICgtMykKI2RlZmluZSBBVVRPQ09SUkVDVF9ORVZFUiAoLTIpCiNkZWZpbmUgQVVUT0NPUlJFQ1RfSU1NRURJQVRFTFkgKC0xKQoKc3RhdGljIGludCBnaXRfdW5rbm93bl9jbWRfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmNiKQp7Cgljb25zdCBjaGFyICpwOwoKCWlmICghc3RyY21wKHZhciwgImhlbHAuYXV0b2NvcnJlY3QiKSkgewoJCWlmICghdmFsdWUpCgkJCXJldHVybiBjb25maWdfZXJyb3Jfbm9uYm9vbCh2YXIpOwoJCWlmICghc3RyY21wKHZhbHVlLCAibmV2ZXIiKSkgewoJCQlhdXRvY29ycmVjdCA9IEFVVE9DT1JSRUNUX05FVkVSOwoJCX0gZWxzZSBpZiAoIXN0cmNtcCh2YWx1ZSwgImltbWVkaWF0ZSIpKSB7CgkJCWF1dG9jb3JyZWN0ID0gQVVUT0NPUlJFQ1RfSU1NRURJQVRFTFk7CgkJfSBlbHNlIGlmICghc3RyY21wKHZhbHVlLCAicHJvbXB0IikpIHsKCQkJYXV0b2NvcnJlY3QgPSBBVVRPQ09SUkVDVF9QUk9NUFQ7CgkJfSBlbHNlIHsKCQkJaW50IHYgPSBnaXRfY29uZmlnX2ludCh2YXIsIHZhbHVlKTsKCQkJYXV0b2NvcnJlY3QgPSAodiA8IDApCgkJCQk/IEFVVE9DT1JSRUNUX0lNTUVESUFURUxZIDogdjsKCQl9Cgl9CgkvKiBBbHNvIHVzZSBhbGlhc2VzIGZvciBjb21tYW5kIGxvb2t1cCAqLwoJaWYgKHNraXBfcHJlZml4KHZhciwgImFsaWFzLiIsICZwKSkKCQlhZGRfY21kbmFtZSgmYWxpYXNlcywgcCwgc3RybGVuKHApKTsKCglyZXR1cm4gZ2l0X2RlZmF1bHRfY29uZmlnKHZhciwgdmFsdWUsIGNiKTsKfQoKc3RhdGljIGludCBsZXZlbnNodGVpbl9jb21wYXJlKGNvbnN0IHZvaWQgKnAxLCBjb25zdCB2b2lkICpwMikKewoJY29uc3Qgc3RydWN0IGNtZG5hbWUgKmNvbnN0ICpjMSA9IHAxLCAqY29uc3QgKmMyID0gcDI7Cgljb25zdCBjaGFyICpzMSA9ICgqYzEpLT5uYW1lLCAqczIgPSAoKmMyKS0+bmFtZTsKCWludCBsMSA9ICgqYzEpLT5sZW47CglpbnQgbDIgPSAoKmMyKS0+bGVuOwoJcmV0dXJuIGwxICE9IGwyID8gbDEgLSBsMiA6IHN0cmNtcChzMSwgczIpOwp9CgpzdGF0aWMgdm9pZCBhZGRfY21kX2xpc3Qoc3RydWN0IGNtZG5hbWVzICpjbWRzLCBzdHJ1Y3QgY21kbmFtZXMgKm9sZCkKewoJaW50IGk7CglBTExPQ19HUk9XKGNtZHMtPm5hbWVzLCBjbWRzLT5jbnQgKyBvbGQtPmNudCwgY21kcy0+YWxsb2MpOwoKCWZvciAoaSA9IDA7IGkgPCBvbGQtPmNudDsgaSsrKQoJCWNtZHMtPm5hbWVzW2NtZHMtPmNudCsrXSA9IG9sZC0+bmFtZXNbaV07CglGUkVFX0FORF9OVUxMKG9sZC0+bmFtZXMpOwoJb2xkLT5jbnQgPSAwOwp9CgovKiBBbiBlbXBpcmljYWxseSBkZXJpdmVkIG1hZ2ljIG51bWJlciAqLwojZGVmaW5lIFNJTUlMQVJJVFlfRkxPT1IgNwojZGVmaW5lIFNJTUlMQVJfRU5PVUdIKHgpICgoeCkgPCBTSU1JTEFSSVRZX0ZMT09SKQoKc3RhdGljIGNvbnN0IGNoYXIgYmFkX2ludGVycHJldGVyX2FkdmljZVtdID0KCU5fKCInJXMnIGFwcGVhcnMgdG8gYmUgYSBnaXQgY29tbWFuZCwgYnV0IHdlIHdlcmUgbm90XG4iCgkiYWJsZSB0byBleGVjdXRlIGl0LiBNYXliZSBnaXQtJXMgaXMgYnJva2VuPyIpOwoKY29uc3QgY2hhciAqaGVscF91bmtub3duX2NtZChjb25zdCBjaGFyICpjbWQpCnsKCWludCBpLCBuLCBiZXN0X3NpbWlsYXJpdHkgPSAwOwoJc3RydWN0IGNtZG5hbWVzIG1haW5fY21kcywgb3RoZXJfY21kczsKCXN0cnVjdCBjbWRuYW1lX2hlbHAgKmNvbW1vbl9jbWRzOwoKCW1lbXNldCgmbWFpbl9jbWRzLCAwLCBzaXplb2YobWFpbl9jbWRzKSk7CgltZW1zZXQoJm90aGVyX2NtZHMsIDAsIHNpemVvZihvdGhlcl9jbWRzKSk7CgltZW1zZXQoJmFsaWFzZXMsIDAsIHNpemVvZihhbGlhc2VzKSk7CgoJcmVhZF9lYXJseV9jb25maWcoZ2l0X3Vua25vd25fY21kX2NvbmZpZywgTlVMTCk7CgoJLyoKCSAqIERpc2FibGUgYXV0b2NvcnJlY3Rpb24gcHJvbXB0IGluIGEgbm9uLWludGVyYWN0aXZlIHNlc3Npb24KCSAqLwoJaWYgKChhdXRvY29ycmVjdCA9PSBBVVRPQ09SUkVDVF9QUk9NUFQpICYmICghaXNhdHR5KDApIHx8ICFpc2F0dHkoMikpKQoJCWF1dG9jb3JyZWN0ID0gQVVUT0NPUlJFQ1RfTkVWRVI7CgoJaWYgKGF1dG9jb3JyZWN0ID09IEFVVE9DT1JSRUNUX05FVkVSKSB7CgkJZnByaW50Zl9sbihzdGRlcnIsIF8oImdpdDogJyVzJyBpcyBub3QgYSBnaXQgY29tbWFuZC4gU2VlICdnaXQgLS1oZWxwJy4iKSwgY21kKTsKCQlleGl0KDEpOwoJfQoKCWxvYWRfY29tbWFuZF9saXN0KCJnaXQtIiwgJm1haW5fY21kcywgJm90aGVyX2NtZHMpOwoKCWFkZF9jbWRfbGlzdCgmbWFpbl9jbWRzLCAmYWxpYXNlcyk7CglhZGRfY21kX2xpc3QoJm1haW5fY21kcywgJm90aGVyX2NtZHMpOwoJUVNPUlQobWFpbl9jbWRzLm5hbWVzLCBtYWluX2NtZHMuY250LCBjbWRuYW1lX2NvbXBhcmUpOwoJdW5pcSgmbWFpbl9jbWRzKTsKCglleHRyYWN0X2NtZHMoJmNvbW1vbl9jbWRzLCBjb21tb25fbWFzayk7CgoJLyogVGhpcyBhYnVzZXMgY21kbmFtZS0+bGVuIGZvciBsZXZlbnNodGVpbiBkaXN0YW5jZSAqLwoJZm9yIChpID0gMCwgbiA9IDA7IGkgPCBtYWluX2NtZHMuY250OyBpKyspIHsKCQlpbnQgY21wID0gMDsgLyogYXZvaWQgY29tcGlsZXIgc3R1cGlkaXR5ICovCgkJY29uc3QgY2hhciAqY2FuZGlkYXRlID0gbWFpbl9jbWRzLm5hbWVzW2ldLT5uYW1lOwoKCQkvKgoJCSAqIEFuIGV4YWN0IG1hdGNoIG1lYW5zIHdlIGhhdmUgdGhlIGNvbW1hbmQsIGJ1dAoJCSAqIGZvciBzb21lIHJlYXNvbiBleGVjJ2luZyBpdCBnYXZlIHVzIEVOT0VOVDsgcHJvYmFibHkKCQkgKiBpdCdzIGEgYmFkIGludGVycHJldGVyIGluIHRoZSAjISBsaW5lLgoJCSAqLwoJCWlmICghc3RyY21wKGNhbmRpZGF0ZSwgY21kKSkKCQkJZGllKF8oYmFkX2ludGVycHJldGVyX2FkdmljZSksIGNtZCwgY21kKTsKCgkJLyogRG9lcyB0aGUgY2FuZGlkYXRlIGFwcGVhciBpbiBjb21tb25fY21kcyBsaXN0PyAqLwoJCXdoaWxlIChjb21tb25fY21kc1tuXS5uYW1lICYmCgkJICAgICAgIChjbXAgPSBzdHJjbXAoY29tbW9uX2NtZHNbbl0ubmFtZSwgY2FuZGlkYXRlKSkgPCAwKQoJCQluKys7CgkJaWYgKGNvbW1vbl9jbWRzW25dLm5hbWUgJiYgIWNtcCkgewoJCQkvKiBZZXMsIHRoaXMgaXMgb25lIG9mIHRoZSBjb21tb24gY29tbWFuZHMgKi8KCQkJbisrOyAvKiB1c2UgdGhlIGVudHJ5IGZyb20gY29tbW9uX2NtZHNbXSAqLwoJCQlpZiAoc3RhcnRzX3dpdGgoY2FuZGlkYXRlLCBjbWQpKSB7CgkJCQkvKiBHaXZlIHByZWZpeCBtYXRjaCBhIHZlcnkgZ29vZCBzY29yZSAqLwoJCQkJbWFpbl9jbWRzLm5hbWVzW2ldLT5sZW4gPSAwOwoJCQkJY29udGludWU7CgkJCX0KCQl9CgoJCW1haW5fY21kcy5uYW1lc1tpXS0+bGVuID0KCQkJbGV2ZW5zaHRlaW4oY21kLCBjYW5kaWRhdGUsIDAsIDIsIDEsIDMpICsgMTsKCX0KCUZSRUVfQU5EX05VTEwoY29tbW9uX2NtZHMpOwoKCVFTT1JUKG1haW5fY21kcy5uYW1lcywgbWFpbl9jbWRzLmNudCwgbGV2ZW5zaHRlaW5fY29tcGFyZSk7CgoJaWYgKCFtYWluX2NtZHMuY250KQoJCWRpZShfKCJVaCBvaC4gWW91ciBzeXN0ZW0gcmVwb3J0cyBubyBHaXQgY29tbWFuZHMgYXQgYWxsLiIpKTsKCgkvKiBza2lwIGFuZCBjb3VudCBwcmVmaXggbWF0Y2hlcyAqLwoJZm9yIChuID0gMDsgbiA8IG1haW5fY21kcy5jbnQgJiYgIW1haW5fY21kcy5uYW1lc1tuXS0+bGVuOyBuKyspCgkJOyAvKiBzdGlsbCBjb3VudGluZyAqLwoKCWlmIChtYWluX2NtZHMuY250IDw9IG4pIHsKCQkvKiBwcmVmaXggbWF0Y2hlcyB3aXRoIGV2ZXJ5dGhpbmc/IHRoYXQgaXMgdG9vIGFtYmlndW91cyAqLwoJCWJlc3Rfc2ltaWxhcml0eSA9IFNJTUlMQVJJVFlfRkxPT1IgKyAxOwoJfSBlbHNlIHsKCQkvKiBjb3VudCBhbGwgdGhlIG1vc3Qgc2ltaWxhciBvbmVzICovCgkJZm9yIChiZXN0X3NpbWlsYXJpdHkgPSBtYWluX2NtZHMubmFtZXNbbisrXS0+bGVuOwoJCSAgICAgKG4gPCBtYWluX2NtZHMuY250ICYmCgkJICAgICAgYmVzdF9zaW1pbGFyaXR5ID09IG1haW5fY21kcy5uYW1lc1tuXS0+bGVuKTsKCQkgICAgIG4rKykKCQkJOyAvKiBzdGlsbCBjb3VudGluZyAqLwoJfQoJaWYgKGF1dG9jb3JyZWN0ICYmIG4gPT0gMSAmJiBTSU1JTEFSX0VOT1VHSChiZXN0X3NpbWlsYXJpdHkpKSB7CgkJY29uc3QgY2hhciAqYXNzdW1lZCA9IG1haW5fY21kcy5uYW1lc1swXS0+bmFtZTsKCQltYWluX2NtZHMubmFtZXNbMF0gPSBOVUxMOwoJCWNsZWFuX2NtZG5hbWVzKCZtYWluX2NtZHMpOwoJCWZwcmludGZfbG4oc3RkZXJyLAoJCQkgICBfKCJXQVJOSU5HOiBZb3UgY2FsbGVkIGEgR2l0IGNvbW1hbmQgbmFtZWQgJyVzJywgIgoJCQkgICAgICJ3aGljaCBkb2VzIG5vdCBleGlzdC4iKSwKCQkJICAgY21kKTsKCQlpZiAoYXV0b2NvcnJlY3QgPT0gQVVUT0NPUlJFQ1RfSU1NRURJQVRFTFkpCgkJCWZwcmludGZfbG4oc3RkZXJyLAoJCQkJICAgXygiQ29udGludWluZyB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0ICIKCQkJCSAgICAgInlvdSBtZWFudCAnJXMnLiIpLAoJCQkJICAgYXNzdW1lZCk7CgkJZWxzZSBpZiAoYXV0b2NvcnJlY3QgPT0gQVVUT0NPUlJFQ1RfUFJPTVBUKSB7CgkJCWNoYXIgKmFuc3dlcjsKCQkJc3RydWN0IHN0cmJ1ZiBtc2cgPSBTVFJCVUZfSU5JVDsKCQkJc3RyYnVmX2FkZGYoJm1zZywgXygiUnVuICclcycgaW5zdGVhZCBbeS9OXT8gIiksIGFzc3VtZWQpOwoJCQlhbnN3ZXIgPSBnaXRfcHJvbXB0KG1zZy5idWYsIFBST01QVF9FQ0hPKTsKCQkJc3RyYnVmX3JlbGVhc2UoJm1zZyk7CgkJCWlmICghKHN0YXJ0c193aXRoKGFuc3dlciwgInkiKSB8fAoJCQkgICAgICBzdGFydHNfd2l0aChhbnN3ZXIsICJZIikpKQoJCQkJZXhpdCgxKTsKCQl9IGVsc2UgewoJCQlmcHJpbnRmX2xuKHN0ZGVyciwKCQkJCSAgIF8oIkNvbnRpbnVpbmcgaW4gJTAuMWYgc2Vjb25kcywgIgoJCQkJICAgICAiYXNzdW1pbmcgdGhhdCB5b3UgbWVhbnQgJyVzJy4iKSwKCQkJCSAgIChmbG9hdClhdXRvY29ycmVjdC8xMC4wLCBhc3N1bWVkKTsKCQkJc2xlZXBfbWlsbGlzZWMoYXV0b2NvcnJlY3QgKiAxMDApOwoJCX0KCQlyZXR1cm4gYXNzdW1lZDsKCX0KCglmcHJpbnRmX2xuKHN0ZGVyciwgXygiZ2l0OiAnJXMnIGlzIG5vdCBhIGdpdCBjb21tYW5kLiBTZWUgJ2dpdCAtLWhlbHAnLiIpLCBjbWQpOwoKCWlmIChTSU1JTEFSX0VOT1VHSChiZXN0X3NpbWlsYXJpdHkpKSB7CgkJZnByaW50Zl9sbihzdGRlcnIsCgkJCSAgIFFfKCJcblRoZSBtb3N0IHNpbWlsYXIgY29tbWFuZCBpcyIsCgkJCSAgICAgICJcblRoZSBtb3N0IHNpbWlsYXIgY29tbWFuZHMgYXJlIiwKCQkJICAgbikpOwoKCQlmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKQoJCQlmcHJpbnRmKHN0ZGVyciwgIlx0JXNcbiIsIG1haW5fY21kcy5uYW1lc1tpXS0+bmFtZSk7Cgl9CgoJZXhpdCgxKTsKfQoKdm9pZCBnZXRfdmVyc2lvbl9pbmZvKHN0cnVjdCBzdHJidWYgKmJ1ZiwgaW50IHNob3dfYnVpbGRfb3B0aW9ucykKewoJLyoKCSAqIFRoZSBmb3JtYXQgb2YgdGhpcyBzdHJpbmcgc2hvdWxkIGJlIGtlcHQgc3RhYmxlIGZvciBjb21wYXRpYmlsaXR5CgkgKiB3aXRoIGV4dGVybmFsIHByb2plY3RzIHRoYXQgcmVseSBvbiB0aGUgb3V0cHV0IG9mICJnaXQgdmVyc2lvbiIuCgkgKgoJICogQWx3YXlzIHNob3cgdGhlIHZlcnNpb24sIGV2ZW4gaWYgb3RoZXIgb3B0aW9ucyBhcmUgZ2l2ZW4uCgkgKi8KCXN0cmJ1Zl9hZGRmKGJ1ZiwgImdpdCB2ZXJzaW9uICVzXG4iLCBnaXRfdmVyc2lvbl9zdHJpbmcpOwoKCWlmIChzaG93X2J1aWxkX29wdGlvbnMpIHsKCQlzdHJidWZfYWRkZihidWYsICJjcHU6ICVzXG4iLCBHSVRfSE9TVF9DUFUpOwoJCWlmIChnaXRfYnVpbHRfZnJvbV9jb21taXRfc3RyaW5nWzBdKQoJCQlzdHJidWZfYWRkZihidWYsICJidWlsdCBmcm9tIGNvbW1pdDogJXNcbiIsCgkJCSAgICAgICBnaXRfYnVpbHRfZnJvbV9jb21taXRfc3RyaW5nKTsKCQllbHNlCgkJCXN0cmJ1Zl9hZGRzdHIoYnVmLCAibm8gY29tbWl0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGJ1aWxkXG4iKTsKCQlzdHJidWZfYWRkZihidWYsICJzaXplb2YtbG9uZzogJWRcbiIsIChpbnQpc2l6ZW9mKGxvbmcpKTsKCQlzdHJidWZfYWRkZihidWYsICJzaXplb2Ytc2l6ZV90OiAlZFxuIiwgKGludClzaXplb2Yoc2l6ZV90KSk7CgkJc3RyYnVmX2FkZGYoYnVmLCAic2hlbGwtcGF0aDogJXNcbiIsIFNIRUxMX1BBVEgpOwoJCS8qIE5FRURTV09SSzogYWxzbyBzYXZlIGFuZCBvdXRwdXQgR0lULUJVSUxEX09QVElPTlM/ICovCgl9Cn0KCmludCBjbWRfdmVyc2lvbihpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWludCBidWlsZF9vcHRpb25zID0gMDsKCWNvbnN0IGNoYXIgKiBjb25zdCB1c2FnZVtdID0gewoJCU5fKCJnaXQgdmVyc2lvbiBbPG9wdGlvbnM+XSIpLAoJCU5VTEwKCX07CglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfQk9PTCgwLCAiYnVpbGQtb3B0aW9ucyIsICZidWlsZF9vcHRpb25zLAoJCQkgImFsc28gcHJpbnQgYnVpbGQgb3B0aW9ucyIpLAoJCU9QVF9FTkQoKQoJfTsKCglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIG9wdGlvbnMsIHVzYWdlLCAwKTsKCglnZXRfdmVyc2lvbl9pbmZvKCZidWYsIGJ1aWxkX29wdGlvbnMpOwoJcHJpbnRmKCIlcyIsIGJ1Zi5idWYpOwoKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoKCXJldHVybiAwOwp9CgpzdHJ1Y3Qgc2ltaWxhcl9yZWZfY2IgewoJY29uc3QgY2hhciAqYmFzZV9yZWY7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnNpbWlsYXJfcmVmczsKfTsKCnN0YXRpYyBpbnQgYXBwZW5kX3NpbWlsYXJfcmVmKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJICAgICAgaW50IGZsYWdzLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3Qgc2ltaWxhcl9yZWZfY2IgKmNiID0gKHN0cnVjdCBzaW1pbGFyX3JlZl9jYiAqKShjYl9kYXRhKTsKCWNoYXIgKmJyYW5jaCA9IHN0cnJjaHIocmVmbmFtZSwgJy8nKSArIDE7CgoJLyogQSByZW1vdGUgYnJhbmNoIG9mIHRoZSBzYW1lIG5hbWUgaXMgZGVlbWVkIHNpbWlsYXIgKi8KCWlmIChzdGFydHNfd2l0aChyZWZuYW1lLCAicmVmcy9yZW1vdGVzLyIpICYmCgkgICAgIXN0cmNtcChicmFuY2gsIGNiLT5iYXNlX3JlZikpCgkJc3RyaW5nX2xpc3RfYXBwZW5kX25vZHVwKGNiLT5zaW1pbGFyX3JlZnMsCgkJCQkJIHNob3J0ZW5fdW5hbWJpZ3VvdXNfcmVmKHJlZm5hbWUsIDEpKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgc3RydWN0IHN0cmluZ19saXN0IGd1ZXNzX3JlZnMoY29uc3QgY2hhciAqcmVmKQp7CglzdHJ1Y3Qgc2ltaWxhcl9yZWZfY2IgcmVmX2NiOwoJc3RydWN0IHN0cmluZ19saXN0IHNpbWlsYXJfcmVmcyA9IFNUUklOR19MSVNUX0lOSVRfRFVQOwoKCXJlZl9jYi5iYXNlX3JlZiA9IHJlZjsKCXJlZl9jYi5zaW1pbGFyX3JlZnMgPSAmc2ltaWxhcl9yZWZzOwoJZm9yX2VhY2hfcmVmKGFwcGVuZF9zaW1pbGFyX3JlZiwgJnJlZl9jYik7CglyZXR1cm4gc2ltaWxhcl9yZWZzOwp9CgpOT1JFVFVSTiB2b2lkIGhlbHBfdW5rbm93bl9yZWYoY29uc3QgY2hhciAqcmVmLCBjb25zdCBjaGFyICpjbWQsCgkJCSAgICAgICBjb25zdCBjaGFyICplcnJvcikKewoJaW50IGk7CglzdHJ1Y3Qgc3RyaW5nX2xpc3Qgc3VnZ2VzdGVkX3JlZnMgPSBndWVzc19yZWZzKHJlZik7CgoJZnByaW50Zl9sbihzdGRlcnIsIF8oIiVzOiAlcyAtICVzIiksIGNtZCwgcmVmLCBlcnJvcik7CgoJaWYgKHN1Z2dlc3RlZF9yZWZzLm5yID4gMCkgewoJCWZwcmludGZfbG4oc3RkZXJyLAoJCQkgICBRXygiXG5EaWQgeW91IG1lYW4gdGhpcz8iLAoJCQkgICAgICAiXG5EaWQgeW91IG1lYW4gb25lIG9mIHRoZXNlPyIsCgkJCSAgICAgIHN1Z2dlc3RlZF9yZWZzLm5yKSk7CgkJZm9yIChpID0gMDsgaSA8IHN1Z2dlc3RlZF9yZWZzLm5yOyBpKyspCgkJCWZwcmludGYoc3RkZXJyLCAiXHQlc1xuIiwgc3VnZ2VzdGVkX3JlZnMuaXRlbXNbaV0uc3RyaW5nKTsKCX0KCglzdHJpbmdfbGlzdF9jbGVhcigmc3VnZ2VzdGVkX3JlZnMsIDApOwoJZXhpdCgxKTsKfQo=",
    "text": "#include \"cache.h\"\n#include \"config.h\"\n#include \"builtin.h\"\n#include \"exec-cmd.h\"\n#include \"run-command.h\"\n#include \"levenshtein.h\"\n#include \"help.h\"\n#include \"command-list.h\"\n#include \"string-list.h\"\n#include \"column.h\"\n#include \"version.h\"\n#include \"refs.h\"\n#include \"parse-options.h\"\n#include \"prompt.h\"\n\nstruct category_description {\n\tuint32_t category;\n\tconst char *desc;\n};\nstatic uint32_t common_mask =\n\tCAT_init | CAT_worktree | CAT_info |\n\tCAT_history | CAT_remote;\nstatic struct category_description common_categories[] = {\n\t{ CAT_init, N_(\"start a working area (see also: git help tutorial)\") },\n\t{ CAT_worktree, N_(\"work on the current change (see also: git help everyday)\") },\n\t{ CAT_info, N_(\"examine the history and state (see also: git help revisions)\") },\n\t{ CAT_history, N_(\"grow, mark and tweak your common history\") },\n\t{ CAT_remote, N_(\"collaborate (see also: git help workflows)\") },\n\t{ 0, NULL }\n};\nstatic struct category_description main_categories[] = {\n\t{ CAT_mainporcelain, N_(\"Main Porcelain Commands\") },\n\t{ CAT_ancillarymanipulators, N_(\"Ancillary Commands / Manipulators\") },\n\t{ CAT_ancillaryinterrogators, N_(\"Ancillary Commands / Interrogators\") },\n\t{ CAT_foreignscminterface, N_(\"Interacting with Others\") },\n\t{ CAT_plumbingmanipulators, N_(\"Low-level Commands / Manipulators\") },\n\t{ CAT_plumbinginterrogators, N_(\"Low-level Commands / Interrogators\") },\n\t{ CAT_synchingrepositories, N_(\"Low-level Commands / Syncing Repositories\") },\n\t{ CAT_purehelpers, N_(\"Low-level Commands / Internal Helpers\") },\n\t{ 0, NULL }\n};\n\nstatic const char *drop_prefix(const char *name, uint32_t category)\n{\n\tconst char *new_name;\n\n\tif (skip_prefix(name, \"git-\", &new_name))\n\t\treturn new_name;\n\tif (category == CAT_guide && skip_prefix(name, \"git\", &new_name))\n\t\treturn new_name;\n\treturn name;\n\n}\n\nstatic void extract_cmds(struct cmdname_help **p_cmds, uint32_t mask)\n{\n\tint i, nr = 0;\n\tstruct cmdname_help *cmds;\n\n\tif (ARRAY_SIZE(command_list) == 0)\n\t\tBUG(\"empty command_list[] is a sign of broken generate-cmdlist.sh\");\n\n\tALLOC_ARRAY(cmds, ARRAY_SIZE(command_list) + 1);\n\n\tfor (i = 0; i < ARRAY_SIZE(command_list); i++) {\n\t\tconst struct cmdname_help *cmd = command_list + i;\n\n\t\tif (!(cmd->category & mask))\n\t\t\tcontinue;\n\n\t\tcmds[nr] = *cmd;\n\t\tcmds[nr].name = drop_prefix(cmd->name, cmd->category);\n\n\t\tnr++;\n\t}\n\tcmds[nr].name = NULL;\n\t*p_cmds = cmds;\n}\n\nstatic void print_command_list(const struct cmdname_help *cmds,\n\t\t\t       uint32_t mask, int longest)\n{\n\tint i;\n\n\tfor (i = 0; cmds[i].name; i++) {\n\t\tif (cmds[i].category & mask) {\n\t\t\tsize_t len = strlen(cmds[i].name);\n\t\t\tprintf(\"   %s   \", cmds[i].name);\n\t\t\tif (longest > len)\n\t\t\t\tmput_char(' ', longest - len);\n\t\t\tputs(_(cmds[i].help));\n\t\t}\n\t}\n}\n\nstatic int cmd_name_cmp(const void *elem1, const void *elem2)\n{\n\tconst struct cmdname_help *e1 = elem1;\n\tconst struct cmdname_help *e2 = elem2;\n\n\treturn strcmp(e1->name, e2->name);\n}\n\nstatic void print_cmd_by_category(const struct category_description *catdesc,\n\t\t\t\t  int *longest_p)\n{\n\tstruct cmdname_help *cmds;\n\tint longest = 0;\n\tint i, nr = 0;\n\tuint32_t mask = 0;\n\n\tfor (i = 0; catdesc[i].desc; i++)\n\t\tmask |= catdesc[i].category;\n\n\textract_cmds(&cmds, mask);\n\n\tfor (i = 0; cmds[i].name; i++, nr++) {\n\t\tif (longest < strlen(cmds[i].name))\n\t\t\tlongest = strlen(cmds[i].name);\n\t}\n\tQSORT(cmds, nr, cmd_name_cmp);\n\n\tfor (i = 0; catdesc[i].desc; i++) {\n\t\tuint32_t mask = catdesc[i].category;\n\t\tconst char *desc = catdesc[i].desc;\n\n\t\tputchar('\\n');\n\t\tputs(_(desc));\n\t\tprint_command_list(cmds, mask, longest);\n\t}\n\tfree(cmds);\n\tif (longest_p)\n\t\t*longest_p = longest;\n}\n\nvoid add_cmdname(struct cmdnames *cmds, const char *name, int len)\n{\n\tstruct cmdname *ent;\n\tFLEX_ALLOC_MEM(ent, name, name, len);\n\tent->len = len;\n\n\tALLOC_GROW(cmds->names, cmds->cnt + 1, cmds->alloc);\n\tcmds->names[cmds->cnt++] = ent;\n}\n\nstatic void clean_cmdnames(struct cmdnames *cmds)\n{\n\tint i;\n\tfor (i = 0; i < cmds->cnt; ++i)\n\t\tfree(cmds->names[i]);\n\tfree(cmds->names);\n\tcmds->cnt = 0;\n\tcmds->alloc = 0;\n}\n\nstatic int cmdname_compare(const void *a_, const void *b_)\n{\n\tstruct cmdname *a = *(struct cmdname **)a_;\n\tstruct cmdname *b = *(struct cmdname **)b_;\n\treturn strcmp(a->name, b->name);\n}\n\nstatic void uniq(struct cmdnames *cmds)\n{\n\tint i, j;\n\n\tif (!cmds->cnt)\n\t\treturn;\n\n\tfor (i = j = 1; i < cmds->cnt; i++) {\n\t\tif (!strcmp(cmds->names[i]->name, cmds->names[j-1]->name))\n\t\t\tfree(cmds->names[i]);\n\t\telse\n\t\t\tcmds->names[j++] = cmds->names[i];\n\t}\n\n\tcmds->cnt = j;\n}\n\nvoid exclude_cmds(struct cmdnames *cmds, struct cmdnames *excludes)\n{\n\tint ci, cj, ei;\n\tint cmp;\n\n\tci = cj = ei = 0;\n\twhile (ci < cmds->cnt && ei < excludes->cnt) {\n\t\tcmp = strcmp(cmds->names[ci]->name, excludes->names[ei]->name);\n\t\tif (cmp < 0)\n\t\t\tcmds->names[cj++] = cmds->names[ci++];\n\t\telse if (cmp == 0) {\n\t\t\tei++;\n\t\t\tfree(cmds->names[ci++]);\n\t\t} else if (cmp > 0)\n\t\t\tei++;\n\t}\n\n\twhile (ci < cmds->cnt)\n\t\tcmds->names[cj++] = cmds->names[ci++];\n\n\tcmds->cnt = cj;\n}\n\nstatic void pretty_print_cmdnames(struct cmdnames *cmds, unsigned int colopts)\n{\n\tstruct string_list list = STRING_LIST_INIT_NODUP;\n\tstruct column_options copts;\n\tint i;\n\n\tfor (i = 0; i < cmds->cnt; i++)\n\t\tstring_list_append(&list, cmds->names[i]->name);\n\t/*\n\t * always enable column display, we only consult column.*\n\t * about layout strategy and stuff\n\t */\n\tcolopts = (colopts & ~COL_ENABLE_MASK) | COL_ENABLED;\n\tmemset(&copts, 0, sizeof(copts));\n\tcopts.indent = \"  \";\n\tcopts.padding = 2;\n\tprint_columns(&list, colopts, &copts);\n\tstring_list_clear(&list, 0);\n}\n\nstatic void list_commands_in_dir(struct cmdnames *cmds,\n\t\t\t\t\t const char *path,\n\t\t\t\t\t const char *prefix)\n{\n\tDIR *dir = opendir(path);\n\tstruct dirent *de;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint len;\n\n\tif (!dir)\n\t\treturn;\n\tif (!prefix)\n\t\tprefix = \"git-\";\n\n\tstrbuf_addf(&buf, \"%s/\", path);\n\tlen = buf.len;\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *ent;\n\t\tsize_t entlen;\n\n\t\tif (!skip_prefix(de->d_name, prefix, &ent))\n\t\t\tcontinue;\n\n\t\tstrbuf_setlen(&buf, len);\n\t\tstrbuf_addstr(&buf, de->d_name);\n\t\tif (!is_executable(buf.buf))\n\t\t\tcontinue;\n\n\t\tentlen = strlen(ent);\n\t\tstrip_suffix(ent, \".exe\", &entlen);\n\n\t\tadd_cmdname(cmds, ent, entlen);\n\t}\n\tclosedir(dir);\n\tstrbuf_release(&buf);\n}\n\nvoid load_command_list(const char *prefix,\n\t\tstruct cmdnames *main_cmds,\n\t\tstruct cmdnames *other_cmds)\n{\n\tconst char *env_path = getenv(\"PATH\");\n\tconst char *exec_path = git_exec_path();\n\n\tload_builtin_commands(prefix, main_cmds);\n\n\tif (exec_path) {\n\t\tlist_commands_in_dir(main_cmds, exec_path, prefix);\n\t\tQSORT(main_cmds->names, main_cmds->cnt, cmdname_compare);\n\t\tuniq(main_cmds);\n\t}\n\n\tif (env_path) {\n\t\tchar *paths, *path, *colon;\n\t\tpath = paths = xstrdup(env_path);\n\t\twhile (1) {\n\t\t\tif ((colon = strchr(path, PATH_SEP)))\n\t\t\t\t*colon = 0;\n\t\t\tif (!exec_path || strcmp(path, exec_path))\n\t\t\t\tlist_commands_in_dir(other_cmds, path, prefix);\n\n\t\t\tif (!colon)\n\t\t\t\tbreak;\n\t\t\tpath = colon + 1;\n\t\t}\n\t\tfree(paths);\n\n\t\tQSORT(other_cmds->names, other_cmds->cnt, cmdname_compare);\n\t\tuniq(other_cmds);\n\t}\n\texclude_cmds(other_cmds, main_cmds);\n}\n\nstatic int get_colopts(const char *var, const char *value, void *data)\n{\n\tunsigned int *colopts = data;\n\n\tif (starts_with(var, \"column.\"))\n\t\treturn git_column_config(var, value, \"help\", colopts);\n\n\treturn 0;\n}\n\nvoid list_commands(struct cmdnames *main_cmds, struct cmdnames *other_cmds)\n{\n\tunsigned int colopts = 0;\n\tgit_config(get_colopts, &colopts);\n\n\tif (main_cmds->cnt) {\n\t\tconst char *exec_path = git_exec_path();\n\t\tprintf_ln(_(\"available git commands in '%s'\"), exec_path);\n\t\tputchar('\\n');\n\t\tpretty_print_cmdnames(main_cmds, colopts);\n\t\tputchar('\\n');\n\t}\n\n\tif (other_cmds->cnt) {\n\t\tputs(_(\"git commands available from elsewhere on your $PATH\"));\n\t\tputchar('\\n');\n\t\tpretty_print_cmdnames(other_cmds, colopts);\n\t\tputchar('\\n');\n\t}\n}\n\nvoid list_common_cmds_help(void)\n{\n\tputs(_(\"These are common Git commands used in various situations:\"));\n\tprint_cmd_by_category(common_categories, NULL);\n}\n\nvoid list_all_main_cmds(struct string_list *list)\n{\n\tstruct cmdnames main_cmds, other_cmds;\n\tint i;\n\n\tmemset(&main_cmds, 0, sizeof(main_cmds));\n\tmemset(&other_cmds, 0, sizeof(other_cmds));\n\tload_command_list(\"git-\", &main_cmds, &other_cmds);\n\n\tfor (i = 0; i < main_cmds.cnt; i++)\n\t\tstring_list_append(list, main_cmds.names[i]->name);\n\n\tclean_cmdnames(&main_cmds);\n\tclean_cmdnames(&other_cmds);\n}\n\nvoid list_all_other_cmds(struct string_list *list)\n{\n\tstruct cmdnames main_cmds, other_cmds;\n\tint i;\n\n\tmemset(&main_cmds, 0, sizeof(main_cmds));\n\tmemset(&other_cmds, 0, sizeof(other_cmds));\n\tload_command_list(\"git-\", &main_cmds, &other_cmds);\n\n\tfor (i = 0; i < other_cmds.cnt; i++)\n\t\tstring_list_append(list, other_cmds.names[i]->name);\n\n\tclean_cmdnames(&main_cmds);\n\tclean_cmdnames(&other_cmds);\n}\n\nvoid list_cmds_by_category(struct string_list *list,\n\t\t\t   const char *cat)\n{\n\tint i, n = ARRAY_SIZE(command_list);\n\tuint32_t cat_id = 0;\n\n\tfor (i = 0; category_names[i]; i++) {\n\t\tif (!strcmp(cat, category_names[i])) {\n\t\t\tcat_id = 1UL << i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!cat_id)\n\t\tdie(_(\"unsupported command listing type '%s'\"), cat);\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct cmdname_help *cmd = command_list + i;\n\n\t\tif (!(cmd->category & cat_id))\n\t\t\tcontinue;\n\t\tstring_list_append(list, drop_prefix(cmd->name, cmd->category));\n\t}\n}\n\nvoid list_cmds_by_config(struct string_list *list)\n{\n\tconst char *cmd_list;\n\n\tif (git_config_get_string_tmp(\"completion.commands\", &cmd_list))\n\t\treturn;\n\n\tstring_list_sort(list);\n\tstring_list_remove_duplicates(list, 0);\n\n\twhile (*cmd_list) {\n\t\tstruct strbuf sb = STRBUF_INIT;\n\t\tconst char *p = strchrnul(cmd_list, ' ');\n\n\t\tstrbuf_add(&sb, cmd_list, p - cmd_list);\n\t\tif (sb.buf[0] == '-')\n\t\t\tstring_list_remove(list, sb.buf + 1, 0);\n\t\telse\n\t\t\tstring_list_insert(list, sb.buf);\n\t\tstrbuf_release(&sb);\n\t\twhile (*p == ' ')\n\t\t\tp++;\n\t\tcmd_list = p;\n\t}\n}\n\nvoid list_guides_help(void)\n{\n\tstruct category_description catdesc[] = {\n\t\t{ CAT_guide, N_(\"The Git concept guides are:\") },\n\t\t{ 0, NULL }\n\t};\n\tprint_cmd_by_category(catdesc, NULL);\n\tputchar('\\n');\n}\n\nstatic int get_alias(const char *var, const char *value, void *data)\n{\n\tstruct string_list *list = data;\n\n\tif (skip_prefix(var, \"alias.\", &var))\n\t\tstring_list_append(list, var)->util = xstrdup(value);\n\n\treturn 0;\n}\n\nstatic void list_all_cmds_help_external_commands(void)\n{\n\tstruct string_list others = STRING_LIST_INIT_DUP;\n\tint i;\n\n\tlist_all_other_cmds(&others);\n\tif (others.nr)\n\t\tprintf(\"\\n%s\\n\", _(\"External commands\"));\n\tfor (i = 0; i < others.nr; i++)\n\t\tprintf(\"   %s\\n\", others.items[i].string);\n\tstring_list_clear(&others, 0);\n}\n\nstatic void list_all_cmds_help_aliases(int longest)\n{\n\tstruct string_list alias_list = STRING_LIST_INIT_DUP;\n\tstruct cmdname_help *aliases;\n\tint i;\n\n\tgit_config(get_alias, &alias_list);\n\tstring_list_sort(&alias_list);\n\n\tfor (i = 0; i < alias_list.nr; i++) {\n\t\tsize_t len = strlen(alias_list.items[i].string);\n\t\tif (longest < len)\n\t\t\tlongest = len;\n\t}\n\n\tif (alias_list.nr) {\n\t\tprintf(\"\\n%s\\n\", _(\"Command aliases\"));\n\t\tALLOC_ARRAY(aliases, alias_list.nr + 1);\n\t\tfor (i = 0; i < alias_list.nr; i++) {\n\t\t\taliases[i].name = alias_list.items[i].string;\n\t\t\taliases[i].help = alias_list.items[i].util;\n\t\t\taliases[i].category = 1;\n\t\t}\n\t\taliases[alias_list.nr].name = NULL;\n\t\tprint_command_list(aliases, 1, longest);\n\t\tfree(aliases);\n\t}\n\tstring_list_clear(&alias_list, 1);\n}\n\nvoid list_all_cmds_help(void)\n{\n\tint longest;\n\n\tputs(_(\"See 'git help <command>' to read about a specific subcommand\"));\n\tprint_cmd_by_category(main_categories, &longest);\n\n\tlist_all_cmds_help_external_commands();\n\tlist_all_cmds_help_aliases(longest);\n}\n\nint is_in_cmdlist(struct cmdnames *c, const char *s)\n{\n\tint i;\n\tfor (i = 0; i < c->cnt; i++)\n\t\tif (!strcmp(s, c->names[i]->name))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic int autocorrect;\nstatic struct cmdnames aliases;\n\n#define AUTOCORRECT_PROMPT (-3)\n#define AUTOCORRECT_NEVER (-2)\n#define AUTOCORRECT_IMMEDIATELY (-1)\n\nstatic int git_unknown_cmd_config(const char *var, const char *value, void *cb)\n{\n\tconst char *p;\n\n\tif (!strcmp(var, \"help.autocorrect\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tif (!strcmp(value, \"never\")) {\n\t\t\tautocorrect = AUTOCORRECT_NEVER;\n\t\t} else if (!strcmp(value, \"immediate\")) {\n\t\t\tautocorrect = AUTOCORRECT_IMMEDIATELY;\n\t\t} else if (!strcmp(value, \"prompt\")) {\n\t\t\tautocorrect = AUTOCORRECT_PROMPT;\n\t\t} else {\n\t\t\tint v = git_config_int(var, value);\n\t\t\tautocorrect = (v < 0)\n\t\t\t\t? AUTOCORRECT_IMMEDIATELY : v;\n\t\t}\n\t}\n\t/* Also use aliases for command lookup */\n\tif (skip_prefix(var, \"alias.\", &p))\n\t\tadd_cmdname(&aliases, p, strlen(p));\n\n\treturn git_default_config(var, value, cb);\n}\n\nstatic int levenshtein_compare(const void *p1, const void *p2)\n{\n\tconst struct cmdname *const *c1 = p1, *const *c2 = p2;\n\tconst char *s1 = (*c1)->name, *s2 = (*c2)->name;\n\tint l1 = (*c1)->len;\n\tint l2 = (*c2)->len;\n\treturn l1 != l2 ? l1 - l2 : strcmp(s1, s2);\n}\n\nstatic void add_cmd_list(struct cmdnames *cmds, struct cmdnames *old)\n{\n\tint i;\n\tALLOC_GROW(cmds->names, cmds->cnt + old->cnt, cmds->alloc);\n\n\tfor (i = 0; i < old->cnt; i++)\n\t\tcmds->names[cmds->cnt++] = old->names[i];\n\tFREE_AND_NULL(old->names);\n\told->cnt = 0;\n}\n\n/* An empirically derived magic number */\n#define SIMILARITY_FLOOR 7\n#define SIMILAR_ENOUGH(x) ((x) < SIMILARITY_FLOOR)\n\nstatic const char bad_interpreter_advice[] =\n\tN_(\"'%s' appears to be a git command, but we were not\\n\"\n\t\"able to execute it. Maybe git-%s is broken?\");\n\nconst char *help_unknown_cmd(const char *cmd)\n{\n\tint i, n, best_similarity = 0;\n\tstruct cmdnames main_cmds, other_cmds;\n\tstruct cmdname_help *common_cmds;\n\n\tmemset(&main_cmds, 0, sizeof(main_cmds));\n\tmemset(&other_cmds, 0, sizeof(other_cmds));\n\tmemset(&aliases, 0, sizeof(aliases));\n\n\tread_early_config(git_unknown_cmd_config, NULL);\n\n\t/*\n\t * Disable autocorrection prompt in a non-interactive session\n\t */\n\tif ((autocorrect == AUTOCORRECT_PROMPT) && (!isatty(0) || !isatty(2)))\n\t\tautocorrect = AUTOCORRECT_NEVER;\n\n\tif (autocorrect == AUTOCORRECT_NEVER) {\n\t\tfprintf_ln(stderr, _(\"git: '%s' is not a git command. See 'git --help'.\"), cmd);\n\t\texit(1);\n\t}\n\n\tload_command_list(\"git-\", &main_cmds, &other_cmds);\n\n\tadd_cmd_list(&main_cmds, &aliases);\n\tadd_cmd_list(&main_cmds, &other_cmds);\n\tQSORT(main_cmds.names, main_cmds.cnt, cmdname_compare);\n\tuniq(&main_cmds);\n\n\textract_cmds(&common_cmds, common_mask);\n\n\t/* This abuses cmdname->len for levenshtein distance */\n\tfor (i = 0, n = 0; i < main_cmds.cnt; i++) {\n\t\tint cmp = 0; /* avoid compiler stupidity */\n\t\tconst char *candidate = main_cmds.names[i]->name;\n\n\t\t/*\n\t\t * An exact match means we have the command, but\n\t\t * for some reason exec'ing it gave us ENOENT; probably\n\t\t * it's a bad interpreter in the #! line.\n\t\t */\n\t\tif (!strcmp(candidate, cmd))\n\t\t\tdie(_(bad_interpreter_advice), cmd, cmd);\n\n\t\t/* Does the candidate appear in common_cmds list? */\n\t\twhile (common_cmds[n].name &&\n\t\t       (cmp = strcmp(common_cmds[n].name, candidate)) < 0)\n\t\t\tn++;\n\t\tif (common_cmds[n].name && !cmp) {\n\t\t\t/* Yes, this is one of the common commands */\n\t\t\tn++; /* use the entry from common_cmds[] */\n\t\t\tif (starts_with(candidate, cmd)) {\n\t\t\t\t/* Give prefix match a very good score */\n\t\t\t\tmain_cmds.names[i]->len = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmain_cmds.names[i]->len =\n\t\t\tlevenshtein(cmd, candidate, 0, 2, 1, 3) + 1;\n\t}\n\tFREE_AND_NULL(common_cmds);\n\n\tQSORT(main_cmds.names, main_cmds.cnt, levenshtein_compare);\n\n\tif (!main_cmds.cnt)\n\t\tdie(_(\"Uh oh. Your system reports no Git commands at all.\"));\n\n\t/* skip and count prefix matches */\n\tfor (n = 0; n < main_cmds.cnt && !main_cmds.names[n]->len; n++)\n\t\t; /* still counting */\n\n\tif (main_cmds.cnt <= n) {\n\t\t/* prefix matches with everything? that is too ambiguous */\n\t\tbest_similarity = SIMILARITY_FLOOR + 1;\n\t} else {\n\t\t/* count all the most similar ones */\n\t\tfor (best_similarity = main_cmds.names[n++]->len;\n\t\t     (n < main_cmds.cnt &&\n\t\t      best_similarity == main_cmds.names[n]->len);\n\t\t     n++)\n\t\t\t; /* still counting */\n\t}\n\tif (autocorrect && n == 1 && SIMILAR_ENOUGH(best_similarity)) {\n\t\tconst char *assumed = main_cmds.names[0]->name;\n\t\tmain_cmds.names[0] = NULL;\n\t\tclean_cmdnames(&main_cmds);\n\t\tfprintf_ln(stderr,\n\t\t\t   _(\"WARNING: You called a Git command named '%s', \"\n\t\t\t     \"which does not exist.\"),\n\t\t\t   cmd);\n\t\tif (autocorrect == AUTOCORRECT_IMMEDIATELY)\n\t\t\tfprintf_ln(stderr,\n\t\t\t\t   _(\"Continuing under the assumption that \"\n\t\t\t\t     \"you meant '%s'.\"),\n\t\t\t\t   assumed);\n\t\telse if (autocorrect == AUTOCORRECT_PROMPT) {\n\t\t\tchar *answer;\n\t\t\tstruct strbuf msg = STRBUF_INIT;\n\t\t\tstrbuf_addf(&msg, _(\"Run '%s' instead [y/N]? \"), assumed);\n\t\t\tanswer = git_prompt(msg.buf, PROMPT_ECHO);\n\t\t\tstrbuf_release(&msg);\n\t\t\tif (!(starts_with(answer, \"y\") ||\n\t\t\t      starts_with(answer, \"Y\")))\n\t\t\t\texit(1);\n\t\t} else {\n\t\t\tfprintf_ln(stderr,\n\t\t\t\t   _(\"Continuing in %0.1f seconds, \"\n\t\t\t\t     \"assuming that you meant '%s'.\"),\n\t\t\t\t   (float)autocorrect/10.0, assumed);\n\t\t\tsleep_millisec(autocorrect * 100);\n\t\t}\n\t\treturn assumed;\n\t}\n\n\tfprintf_ln(stderr, _(\"git: '%s' is not a git command. See 'git --help'.\"), cmd);\n\n\tif (SIMILAR_ENOUGH(best_similarity)) {\n\t\tfprintf_ln(stderr,\n\t\t\t   Q_(\"\\nThe most similar command is\",\n\t\t\t      \"\\nThe most similar commands are\",\n\t\t\t   n));\n\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfprintf(stderr, \"\\t%s\\n\", main_cmds.names[i]->name);\n\t}\n\n\texit(1);\n}\n\nvoid get_version_info(struct strbuf *buf, int show_build_options)\n{\n\t/*\n\t * The format of this string should be kept stable for compatibility\n\t * with external projects that rely on the output of \"git version\".\n\t *\n\t * Always show the version, even if other options are given.\n\t */\n\tstrbuf_addf(buf, \"git version %s\\n\", git_version_string);\n\n\tif (show_build_options) {\n\t\tstrbuf_addf(buf, \"cpu: %s\\n\", GIT_HOST_CPU);\n\t\tif (git_built_from_commit_string[0])\n\t\t\tstrbuf_addf(buf, \"built from commit: %s\\n\",\n\t\t\t       git_built_from_commit_string);\n\t\telse\n\t\t\tstrbuf_addstr(buf, \"no commit associated with this build\\n\");\n\t\tstrbuf_addf(buf, \"sizeof-long: %d\\n\", (int)sizeof(long));\n\t\tstrbuf_addf(buf, \"sizeof-size_t: %d\\n\", (int)sizeof(size_t));\n\t\tstrbuf_addf(buf, \"shell-path: %s\\n\", SHELL_PATH);\n\t\t/* NEEDSWORK: also save and output GIT-BUILD_OPTIONS? */\n\t}\n}\n\nint cmd_version(int argc, const char **argv, const char *prefix)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tint build_options = 0;\n\tconst char * const usage[] = {\n\t\tN_(\"git version [<options>]\"),\n\t\tNULL\n\t};\n\tstruct option options[] = {\n\t\tOPT_BOOL(0, \"build-options\", &build_options,\n\t\t\t \"also print build options\"),\n\t\tOPT_END()\n\t};\n\n\targc = parse_options(argc, argv, prefix, options, usage, 0);\n\n\tget_version_info(&buf, build_options);\n\tprintf(\"%s\", buf.buf);\n\n\tstrbuf_release(&buf);\n\n\treturn 0;\n}\n\nstruct similar_ref_cb {\n\tconst char *base_ref;\n\tstruct string_list *similar_refs;\n};\n\nstatic int append_similar_ref(const char *refname, const struct object_id *oid,\n\t\t\t      int flags, void *cb_data)\n{\n\tstruct similar_ref_cb *cb = (struct similar_ref_cb *)(cb_data);\n\tchar *branch = strrchr(refname, '/') + 1;\n\n\t/* A remote branch of the same name is deemed similar */\n\tif (starts_with(refname, \"refs/remotes/\") &&\n\t    !strcmp(branch, cb->base_ref))\n\t\tstring_list_append_nodup(cb->similar_refs,\n\t\t\t\t\t shorten_unambiguous_ref(refname, 1));\n\treturn 0;\n}\n\nstatic struct string_list guess_refs(const char *ref)\n{\n\tstruct similar_ref_cb ref_cb;\n\tstruct string_list similar_refs = STRING_LIST_INIT_DUP;\n\n\tref_cb.base_ref = ref;\n\tref_cb.similar_refs = &similar_refs;\n\tfor_each_ref(append_similar_ref, &ref_cb);\n\treturn similar_refs;\n}\n\nNORETURN void help_unknown_ref(const char *ref, const char *cmd,\n\t\t\t       const char *error)\n{\n\tint i;\n\tstruct string_list suggested_refs = guess_refs(ref);\n\n\tfprintf_ln(stderr, _(\"%s: %s - %s\"), cmd, ref, error);\n\n\tif (suggested_refs.nr > 0) {\n\t\tfprintf_ln(stderr,\n\t\t\t   Q_(\"\\nDid you mean this?\",\n\t\t\t      \"\\nDid you mean one of these?\",\n\t\t\t      suggested_refs.nr));\n\t\tfor (i = 0; i < suggested_refs.nr; i++)\n\t\t\tfprintf(stderr, \"\\t%s\\n\", suggested_refs.items[i].string);\n\t}\n\n\tstring_list_clear(&suggested_refs, 0);\n\texit(1);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "004117347eedf1d8ccee5375f4670ecb45c36b43",
  "sha1_ok": true,
  "size": 19940
}
