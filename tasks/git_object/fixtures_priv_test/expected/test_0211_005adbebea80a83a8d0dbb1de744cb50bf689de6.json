{
  "content": {
    "base64": "LyoKICogZ2l0IGdjIGJ1aWx0aW4gY29tbWFuZAogKgogKiBDbGVhbnVwIHVucmVhY2hhYmxlIGZpbGVzIGFuZCBvcHRpbWl6ZSB0aGUgcmVwb3NpdG9yeS4KICoKICogQ29weXJpZ2h0IChjKSAyMDA3IEphbWVzIEJvd2VzCiAqCiAqIEJhc2VkIG9uIGdpdC1nYy5zaCwgd2hpY2ggaXMKICoKICogQ29weXJpZ2h0IChjKSAyMDA2IFNoYXduIE8uIFBlYXJjZQogKi8KCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJsb2NrZmlsZS5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAicnVuLWNvbW1hbmQuaCIKI2luY2x1ZGUgInNpZ2NoYWluLmgiCiNpbmNsdWRlICJhcmd2LWFycmF5LmgiCiNpbmNsdWRlICJjb21taXQuaCIKCiNkZWZpbmUgRkFJTEVEX1JVTiAiZmFpbGVkIHRvIHJ1biAlcyIKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgYnVpbHRpbl9nY191c2FnZVtdID0gewoJTl8oImdpdCBnYyBbb3B0aW9uc10iKSwKCU5VTEwKfTsKCnN0YXRpYyBpbnQgcGFja19yZWZzID0gMTsKc3RhdGljIGludCBwcnVuZV9yZWZsb2dzID0gMTsKc3RhdGljIGludCBhZ2dyZXNzaXZlX2RlcHRoID0gMjUwOwpzdGF0aWMgaW50IGFnZ3Jlc3NpdmVfd2luZG93ID0gMjUwOwpzdGF0aWMgaW50IGdjX2F1dG9fdGhyZXNob2xkID0gNjcwMDsKc3RhdGljIGludCBnY19hdXRvX3BhY2tfbGltaXQgPSA1MDsKc3RhdGljIGludCBkZXRhY2hfYXV0byA9IDE7CnN0YXRpYyBjb25zdCBjaGFyICpwcnVuZV9leHBpcmUgPSAiMi53ZWVrcy5hZ28iOwoKc3RhdGljIHN0cnVjdCBhcmd2X2FycmF5IHBhY2tfcmVmc19jbWQgPSBBUkdWX0FSUkFZX0lOSVQ7CnN0YXRpYyBzdHJ1Y3QgYXJndl9hcnJheSByZWZsb2cgPSBBUkdWX0FSUkFZX0lOSVQ7CnN0YXRpYyBzdHJ1Y3QgYXJndl9hcnJheSByZXBhY2sgPSBBUkdWX0FSUkFZX0lOSVQ7CnN0YXRpYyBzdHJ1Y3QgYXJndl9hcnJheSBwcnVuZSA9IEFSR1ZfQVJSQVlfSU5JVDsKc3RhdGljIHN0cnVjdCBhcmd2X2FycmF5IHJlcmVyZSA9IEFSR1ZfQVJSQVlfSU5JVDsKCnN0YXRpYyBjaGFyICpwaWRmaWxlOwoKc3RhdGljIHZvaWQgcmVtb3ZlX3BpZGZpbGUodm9pZCkKewoJaWYgKHBpZGZpbGUpCgkJdW5saW5rKHBpZGZpbGUpOwp9CgpzdGF0aWMgdm9pZCByZW1vdmVfcGlkZmlsZV9vbl9zaWduYWwoaW50IHNpZ25vKQp7CglyZW1vdmVfcGlkZmlsZSgpOwoJc2lnY2hhaW5fcG9wKHNpZ25vKTsKCXJhaXNlKHNpZ25vKTsKfQoKc3RhdGljIHZvaWQgZ2NfY29uZmlnKHZvaWQpCnsKCWNvbnN0IGNoYXIgKnZhbHVlOwoKCWlmICghZ2l0X2NvbmZpZ19nZXRfdmFsdWUoImdjLnBhY2tyZWZzIiwgJnZhbHVlKSkgewoJCWlmICh2YWx1ZSAmJiAhc3RyY21wKHZhbHVlLCAibm90YmFyZSIpKQoJCQlwYWNrX3JlZnMgPSAtMTsKCQllbHNlCgkJCXBhY2tfcmVmcyA9IGdpdF9jb25maWdfYm9vbCgiZ2MucGFja3JlZnMiLCB2YWx1ZSk7Cgl9CgoJZ2l0X2NvbmZpZ19nZXRfaW50KCJnYy5hZ2dyZXNzaXZld2luZG93IiwgJmFnZ3Jlc3NpdmVfd2luZG93KTsKCWdpdF9jb25maWdfZ2V0X2ludCgiZ2MuYWdncmVzc2l2ZWRlcHRoIiwgJmFnZ3Jlc3NpdmVfZGVwdGgpOwoJZ2l0X2NvbmZpZ19nZXRfaW50KCJnYy5hdXRvIiwgJmdjX2F1dG9fdGhyZXNob2xkKTsKCWdpdF9jb25maWdfZ2V0X2ludCgiZ2MuYXV0b3BhY2tsaW1pdCIsICZnY19hdXRvX3BhY2tfbGltaXQpOwoJZ2l0X2NvbmZpZ19nZXRfYm9vbCgiZ2MuYXV0b2RldGFjaCIsICZkZXRhY2hfYXV0byk7CgoJaWYgKCFnaXRfY29uZmlnX2dldF9zdHJpbmdfY29uc3QoImdjLnBydW5lZXhwaXJlIiwgJnBydW5lX2V4cGlyZSkpIHsKCQlpZiAoc3RyY21wKHBydW5lX2V4cGlyZSwgIm5vdyIpKSB7CgkJCXVuc2lnbmVkIGxvbmcgbm93ID0gYXBwcm94aWRhdGUoIm5vdyIpOwoJCQlpZiAoYXBwcm94aWRhdGUocHJ1bmVfZXhwaXJlKSA+PSBub3cpIHsKCQkJCWdpdF9kaWVfY29uZmlnKCJnYy5wcnVuZWV4cGlyZSIsIF8oIkludmFsaWQgZ2MucHJ1bmVleHBpcmU6ICclcyciKSwKCQkJCQkJcHJ1bmVfZXhwaXJlKTsKCQkJfQoJCX0KCX0KCWdpdF9jb25maWcoZ2l0X2RlZmF1bHRfY29uZmlnLCBOVUxMKTsKfQoKc3RhdGljIGludCB0b29fbWFueV9sb29zZV9vYmplY3RzKHZvaWQpCnsKCS8qCgkgKiBRdWlja2x5IGNoZWNrIGlmIGEgImdjIiBpcyBuZWVkZWQsIGJ5IGVzdGltYXRpbmcgaG93CgkgKiBtYW55IGxvb3NlIG9iamVjdHMgdGhlcmUgYXJlLiAgQmVjYXVzZSBTSEEtMSBpcyBldmVubHkKCSAqIGRpc3RyaWJ1dGVkLCB3ZSBjYW4gY2hlY2sgb25seSBvbmUgYW5kIGdldCBhIHJlYXNvbmFibGUKCSAqIGVzdGltYXRlLgoJICovCgljaGFyIHBhdGhbUEFUSF9NQVhdOwoJY29uc3QgY2hhciAqb2JqZGlyID0gZ2V0X29iamVjdF9kaXJlY3RvcnkoKTsKCURJUiAqZGlyOwoJc3RydWN0IGRpcmVudCAqZW50OwoJaW50IGF1dG9fdGhyZXNob2xkOwoJaW50IG51bV9sb29zZSA9IDA7CglpbnQgbmVlZGVkID0gMDsKCglpZiAoZ2NfYXV0b190aHJlc2hvbGQgPD0gMCkKCQlyZXR1cm4gMDsKCglpZiAoc2l6ZW9mKHBhdGgpIDw9IHNucHJpbnRmKHBhdGgsIHNpemVvZihwYXRoKSwgIiVzLzE3Iiwgb2JqZGlyKSkgewoJCXdhcm5pbmcoXygiaW5zYW5lbHkgbG9uZyBvYmplY3QgZGlyZWN0b3J5ICUuKnMiKSwgNTAsIG9iamRpcik7CgkJcmV0dXJuIDA7Cgl9CglkaXIgPSBvcGVuZGlyKHBhdGgpOwoJaWYgKCFkaXIpCgkJcmV0dXJuIDA7CgoJYXV0b190aHJlc2hvbGQgPSAoZ2NfYXV0b190aHJlc2hvbGQgKyAyNTUpIC8gMjU2OwoJd2hpbGUgKChlbnQgPSByZWFkZGlyKGRpcikpICE9IE5VTEwpIHsKCQlpZiAoc3Ryc3BuKGVudC0+ZF9uYW1lLCAiMDEyMzQ1Njc4OWFiY2RlZiIpICE9IDM4IHx8CgkJICAgIGVudC0+ZF9uYW1lWzM4XSAhPSAnXDAnKQoJCQljb250aW51ZTsKCQlpZiAoKytudW1fbG9vc2UgPiBhdXRvX3RocmVzaG9sZCkgewoJCQluZWVkZWQgPSAxOwoJCQlicmVhazsKCQl9Cgl9CgljbG9zZWRpcihkaXIpOwoJcmV0dXJuIG5lZWRlZDsKfQoKc3RhdGljIGludCB0b29fbWFueV9wYWNrcyh2b2lkKQp7CglzdHJ1Y3QgcGFja2VkX2dpdCAqcDsKCWludCBjbnQ7CgoJaWYgKGdjX2F1dG9fcGFja19saW1pdCA8PSAwKQoJCXJldHVybiAwOwoKCXByZXBhcmVfcGFja2VkX2dpdCgpOwoJZm9yIChjbnQgPSAwLCBwID0gcGFja2VkX2dpdDsgcDsgcCA9IHAtPm5leHQpIHsKCQlpZiAoIXAtPnBhY2tfbG9jYWwpCgkJCWNvbnRpbnVlOwoJCWlmIChwLT5wYWNrX2tlZXApCgkJCWNvbnRpbnVlOwoJCS8qCgkJICogUGVyaGFwcyBjaGVjayB0aGUgc2l6ZSBvZiB0aGUgcGFjayBhbmQgY291bnQgb25seQoJCSAqIHZlcnkgc21hbGwgb25lcyBoZXJlPwoJCSAqLwoJCWNudCsrOwoJfQoJcmV0dXJuIGdjX2F1dG9fcGFja19saW1pdCA8PSBjbnQ7Cn0KCnN0YXRpYyB2b2lkIGFkZF9yZXBhY2tfYWxsX29wdGlvbih2b2lkKQp7CglpZiAocHJ1bmVfZXhwaXJlICYmICFzdHJjbXAocHJ1bmVfZXhwaXJlLCAibm93IikpCgkJYXJndl9hcnJheV9wdXNoKCZyZXBhY2ssICItYSIpOwoJZWxzZSB7CgkJYXJndl9hcnJheV9wdXNoKCZyZXBhY2ssICItQSIpOwoJCWlmIChwcnVuZV9leHBpcmUpCgkJCWFyZ3ZfYXJyYXlfcHVzaGYoJnJlcGFjaywgIi0tdW5wYWNrLXVucmVhY2hhYmxlPSVzIiwgcHJ1bmVfZXhwaXJlKTsKCX0KfQoKc3RhdGljIGludCBuZWVkX3RvX2djKHZvaWQpCnsKCS8qCgkgKiBTZXR0aW5nIGdjLmF1dG8gdG8gMCBvciBuZWdhdGl2ZSBjYW4gZGlzYWJsZSB0aGUKCSAqIGF1dG9tYXRpYyBnYy4KCSAqLwoJaWYgKGdjX2F1dG9fdGhyZXNob2xkIDw9IDApCgkJcmV0dXJuIDA7CgoJLyoKCSAqIElmIHRoZXJlIGFyZSB0b28gbWFueSBsb29zZSBvYmplY3RzLCBidXQgbm90IHRvbyBtYW55CgkgKiBwYWNrcywgd2UgcnVuICJyZXBhY2sgLWQgLWwiLiAgSWYgdGhlcmUgYXJlIHRvbyBtYW55IHBhY2tzLAoJICogd2UgcnVuICJyZXBhY2sgLUEgLWQgLWwiLiAgT3RoZXJ3aXNlIHdlIHRlbGwgdGhlIGNhbGxlcgoJICogdGhlcmUgaXMgbm8gbmVlZC4KCSAqLwoJaWYgKHRvb19tYW55X3BhY2tzKCkpCgkJYWRkX3JlcGFja19hbGxfb3B0aW9uKCk7CgllbHNlIGlmICghdG9vX21hbnlfbG9vc2Vfb2JqZWN0cygpKQoJCXJldHVybiAwOwoKCWlmIChydW5faG9va19sZShOVUxMLCAicHJlLWF1dG8tZ2MiLCBOVUxMKSkKCQlyZXR1cm4gMDsKCXJldHVybiAxOwp9CgovKiByZXR1cm4gTlVMTCBvbiBzdWNjZXNzLCBlbHNlIGhvc3RuYW1lIHJ1bm5pbmcgdGhlIGdjICovCnN0YXRpYyBjb25zdCBjaGFyICpsb2NrX3JlcG9fZm9yX2djKGludCBmb3JjZSwgcGlkX3QqIHJldF9waWQpCnsKCXN0YXRpYyBzdHJ1Y3QgbG9ja19maWxlIGxvY2s7CgljaGFyIG15X2hvc3RbMTI4XTsKCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdGF0IHN0OwoJdWludG1heF90IHBpZDsKCUZJTEUgKmZwOwoJaW50IGZkOwoKCWlmIChwaWRmaWxlKQoJCS8qIGFscmVhZHkgbG9ja2VkICovCgkJcmV0dXJuIE5VTEw7CgoJaWYgKGdldGhvc3RuYW1lKG15X2hvc3QsIHNpemVvZihteV9ob3N0KSkpCgkJc3RyY3B5KG15X2hvc3QsICJ1bmtub3duIik7CgoJZmQgPSBob2xkX2xvY2tfZmlsZV9mb3JfdXBkYXRlKCZsb2NrLCBnaXRfcGF0aCgiZ2MucGlkIiksCgkJCQkgICAgICAgTE9DS19ESUVfT05fRVJST1IpOwoJaWYgKCFmb3JjZSkgewoJCXN0YXRpYyBjaGFyIGxvY2tpbmdfaG9zdFsxMjhdOwoJCWludCBzaG91bGRfZXhpdDsKCQlmcCA9IGZvcGVuKGdpdF9wYXRoKCJnYy5waWQiKSwgInIiKTsKCQltZW1zZXQobG9ja2luZ19ob3N0LCAwLCBzaXplb2YobG9ja2luZ19ob3N0KSk7CgkJc2hvdWxkX2V4aXQgPQoJCQlmcCAhPSBOVUxMICYmCgkJCSFmc3RhdChmaWxlbm8oZnApLCAmc3QpICYmCgkJCS8qCgkJCSAqIDEyIGhvdXIgbGltaXQgaXMgdmVyeSBnZW5lcm91cyBhcyBnYyBzaG91bGQKCQkJICogbmV2ZXIgdGFrZSB0aGF0IGxvbmcuIE9uIHRoZSBvdGhlciBoYW5kIHdlCgkJCSAqIGRvbid0IHJlYWxseSBuZWVkIGEgc3RyaWN0IGxpbWl0IGhlcmUsCgkJCSAqIHJ1bm5pbmcgZ2MgLS1hdXRvIG9uZSBkYXkgbGF0ZSBpcyBub3QgYSBiaWcKCQkJICogcHJvYmxlbS4gLS1mb3JjZSBjYW4gYmUgdXNlZCBpbiBtYW51YWwgZ2MKCQkJICogYWZ0ZXIgdGhlIHVzZXIgdmVyaWZpZXMgdGhhdCBubyBnYyBpcwoJCQkgKiBydW5uaW5nLgoJCQkgKi8KCQkJdGltZShOVUxMKSAtIHN0LnN0X210aW1lIDw9IDEyICogMzYwMCAmJgoJCQlmc2NhbmYoZnAsICIlIlBSSXVNQVgiICUxMjdjIiwgJnBpZCwgbG9ja2luZ19ob3N0KSA9PSAyICYmCgkJCS8qIGJlIGdlbnRsZSB0byBjb25jdXJyZW50ICJnYyIgb24gcmVtb3RlIGhvc3RzICovCgkJCShzdHJjbXAobG9ja2luZ19ob3N0LCBteV9ob3N0KSB8fCAha2lsbChwaWQsIDApIHx8IGVycm5vID09IEVQRVJNKTsKCQlpZiAoZnAgIT0gTlVMTCkKCQkJZmNsb3NlKGZwKTsKCQlpZiAoc2hvdWxkX2V4aXQpIHsKCQkJaWYgKGZkID49IDApCgkJCQlyb2xsYmFja19sb2NrX2ZpbGUoJmxvY2spOwoJCQkqcmV0X3BpZCA9IHBpZDsKCQkJcmV0dXJuIGxvY2tpbmdfaG9zdDsKCQl9Cgl9CgoJc3RyYnVmX2FkZGYoJnNiLCAiJSJQUkl1TUFYIiAlcyIsCgkJICAgICh1aW50bWF4X3QpIGdldHBpZCgpLCBteV9ob3N0KTsKCXdyaXRlX2luX2Z1bGwoZmQsIHNiLmJ1Ziwgc2IubGVuKTsKCXN0cmJ1Zl9yZWxlYXNlKCZzYik7Cgljb21taXRfbG9ja19maWxlKCZsb2NrKTsKCglwaWRmaWxlID0gZ2l0X3BhdGhkdXAoImdjLnBpZCIpOwoJc2lnY2hhaW5fcHVzaF9jb21tb24ocmVtb3ZlX3BpZGZpbGVfb25fc2lnbmFsKTsKCWF0ZXhpdChyZW1vdmVfcGlkZmlsZSk7CgoJcmV0dXJuIE5VTEw7Cn0KCnN0YXRpYyBpbnQgZ2NfYmVmb3JlX3JlcGFjayh2b2lkKQp7CglpZiAocGFja19yZWZzICYmIHJ1bl9jb21tYW5kX3Zfb3B0KHBhY2tfcmVmc19jbWQuYXJndiwgUlVOX0dJVF9DTUQpKQoJCXJldHVybiBlcnJvcihGQUlMRURfUlVOLCBwYWNrX3JlZnNfY21kLmFyZ3ZbMF0pOwoKCWlmIChwcnVuZV9yZWZsb2dzICYmIHJ1bl9jb21tYW5kX3Zfb3B0KHJlZmxvZy5hcmd2LCBSVU5fR0lUX0NNRCkpCgkJcmV0dXJuIGVycm9yKEZBSUxFRF9SVU4sIHJlZmxvZy5hcmd2WzBdKTsKCglwYWNrX3JlZnMgPSAwOwoJcHJ1bmVfcmVmbG9ncyA9IDA7CglyZXR1cm4gMDsKfQoKaW50IGNtZF9nYyhpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJaW50IGFnZ3Jlc3NpdmUgPSAwOwoJaW50IGF1dG9fZ2MgPSAwOwoJaW50IHF1aWV0ID0gMDsKCWludCBmb3JjZSA9IDA7Cgljb25zdCBjaGFyICpuYW1lOwoJcGlkX3QgcGlkOwoKCXN0cnVjdCBvcHRpb24gYnVpbHRpbl9nY19vcHRpb25zW10gPSB7CgkJT1BUX19RVUlFVCgmcXVpZXQsIE5fKCJzdXBwcmVzcyBwcm9ncmVzcyByZXBvcnRpbmciKSksCgkJeyBPUFRJT05fU1RSSU5HLCAwLCAicHJ1bmUiLCAmcHJ1bmVfZXhwaXJlLCBOXygiZGF0ZSIpLAoJCQlOXygicHJ1bmUgdW5yZWZlcmVuY2VkIG9iamVjdHMiKSwKCQkJUEFSU0VfT1BUX09QVEFSRywgTlVMTCwgKGludHB0cl90KXBydW5lX2V4cGlyZSB9LAoJCU9QVF9CT09MKDAsICJhZ2dyZXNzaXZlIiwgJmFnZ3Jlc3NpdmUsIE5fKCJiZSBtb3JlIHRob3JvdWdoIChpbmNyZWFzZWQgcnVudGltZSkiKSksCgkJT1BUX0JPT0woMCwgImF1dG8iLCAmYXV0b19nYywgTl8oImVuYWJsZSBhdXRvLWdjIG1vZGUiKSksCgkJT1BUX0JPT0woMCwgImZvcmNlIiwgJmZvcmNlLCBOXygiZm9yY2UgcnVubmluZyBnYyBldmVuIGlmIHRoZXJlIG1heSBiZSBhbm90aGVyIGdjIHJ1bm5pbmciKSksCgkJT1BUX0VORCgpCgl9OwoKCWlmIChhcmdjID09IDIgJiYgIXN0cmNtcChhcmd2WzFdLCAiLWgiKSkKCQl1c2FnZV93aXRoX29wdGlvbnMoYnVpbHRpbl9nY191c2FnZSwgYnVpbHRpbl9nY19vcHRpb25zKTsKCglhcmd2X2FycmF5X3B1c2hsKCZwYWNrX3JlZnNfY21kLCAicGFjay1yZWZzIiwgIi0tYWxsIiwgIi0tcHJ1bmUiLCBOVUxMKTsKCWFyZ3ZfYXJyYXlfcHVzaGwoJnJlZmxvZywgInJlZmxvZyIsICJleHBpcmUiLCAiLS1hbGwiLCBOVUxMKTsKCWFyZ3ZfYXJyYXlfcHVzaGwoJnJlcGFjaywgInJlcGFjayIsICItZCIsICItbCIsIE5VTEwpOwoJYXJndl9hcnJheV9wdXNobCgmcHJ1bmUsICJwcnVuZSIsICItLWV4cGlyZSIsIE5VTEwgKTsKCWFyZ3ZfYXJyYXlfcHVzaGwoJnJlcmVyZSwgInJlcmVyZSIsICJnYyIsIE5VTEwpOwoKCWdjX2NvbmZpZygpOwoKCWlmIChwYWNrX3JlZnMgPCAwKQoJCXBhY2tfcmVmcyA9ICFpc19iYXJlX3JlcG9zaXRvcnkoKTsKCglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIGJ1aWx0aW5fZ2Nfb3B0aW9ucywKCQkJICAgICBidWlsdGluX2djX3VzYWdlLCAwKTsKCWlmIChhcmdjID4gMCkKCQl1c2FnZV93aXRoX29wdGlvbnMoYnVpbHRpbl9nY191c2FnZSwgYnVpbHRpbl9nY19vcHRpb25zKTsKCglpZiAoYWdncmVzc2l2ZSkgewoJCWFyZ3ZfYXJyYXlfcHVzaCgmcmVwYWNrLCAiLWYiKTsKCQlpZiAoYWdncmVzc2l2ZV9kZXB0aCA+IDApCgkJCWFyZ3ZfYXJyYXlfcHVzaGYoJnJlcGFjaywgIi0tZGVwdGg9JWQiLCBhZ2dyZXNzaXZlX2RlcHRoKTsKCQlpZiAoYWdncmVzc2l2ZV93aW5kb3cgPiAwKQoJCQlhcmd2X2FycmF5X3B1c2hmKCZyZXBhY2ssICItLXdpbmRvdz0lZCIsIGFnZ3Jlc3NpdmVfd2luZG93KTsKCX0KCWlmIChxdWlldCkKCQlhcmd2X2FycmF5X3B1c2goJnJlcGFjaywgIi1xIik7CgoJaWYgKGF1dG9fZ2MpIHsKCQkvKgoJCSAqIEF1dG8tZ2Mgc2hvdWxkIGJlIGxlYXN0IGludHJ1c2l2ZSBhcyBwb3NzaWJsZS4KCQkgKi8KCQlpZiAoIW5lZWRfdG9fZ2MoKSkKCQkJcmV0dXJuIDA7CgkJaWYgKCFxdWlldCkgewoJCQlpZiAoZGV0YWNoX2F1dG8pCgkJCQlmcHJpbnRmKHN0ZGVyciwgXygiQXV0byBwYWNraW5nIHRoZSByZXBvc2l0b3J5IGluIGJhY2tncm91bmQgZm9yIG9wdGltdW0gcGVyZm9ybWFuY2UuXG4iKSk7CgkJCWVsc2UKCQkJCWZwcmludGYoc3RkZXJyLCBfKCJBdXRvIHBhY2tpbmcgdGhlIHJlcG9zaXRvcnkgZm9yIG9wdGltdW0gcGVyZm9ybWFuY2UuXG4iKSk7CgkJCWZwcmludGYoc3RkZXJyLCBfKCJTZWUgXCJnaXQgaGVscCBnY1wiIGZvciBtYW51YWwgaG91c2VrZWVwaW5nLlxuIikpOwoJCX0KCQlpZiAoZGV0YWNoX2F1dG8pIHsKCQkJaWYgKGdjX2JlZm9yZV9yZXBhY2soKSkKCQkJCXJldHVybiAtMTsKCQkJLyoKCQkJICogZmFpbHVyZSB0byBkYWVtb25pemUgaXMgb2ssIHdlJ2xsIGNvbnRpbnVlCgkJCSAqIGluIGZvcmVncm91bmQKCQkJICovCgkJCWRhZW1vbml6ZSgpOwoJCX0KCX0gZWxzZQoJCWFkZF9yZXBhY2tfYWxsX29wdGlvbigpOwoKCW5hbWUgPSBsb2NrX3JlcG9fZm9yX2djKGZvcmNlLCAmcGlkKTsKCWlmIChuYW1lKSB7CgkJaWYgKGF1dG9fZ2MpCgkJCXJldHVybiAwOyAvKiBiZSBxdWlldCBvbiAtLWF1dG8gKi8KCQlkaWUoXygiZ2MgaXMgYWxyZWFkeSBydW5uaW5nIG9uIG1hY2hpbmUgJyVzJyBwaWQgJSJQUkl1TUFYIiAodXNlIC0tZm9yY2UgaWYgbm90KSIpLAoJCSAgICBuYW1lLCAodWludG1heF90KXBpZCk7Cgl9CgoJaWYgKGdjX2JlZm9yZV9yZXBhY2soKSkKCQlyZXR1cm4gLTE7CgoJaWYgKHJ1bl9jb21tYW5kX3Zfb3B0KHJlcGFjay5hcmd2LCBSVU5fR0lUX0NNRCkpCgkJcmV0dXJuIGVycm9yKEZBSUxFRF9SVU4sIHJlcGFjay5hcmd2WzBdKTsKCglpZiAocHJ1bmVfZXhwaXJlKSB7CgkJYXJndl9hcnJheV9wdXNoKCZwcnVuZSwgcHJ1bmVfZXhwaXJlKTsKCQlpZiAocXVpZXQpCgkJCWFyZ3ZfYXJyYXlfcHVzaCgmcHJ1bmUsICItLW5vLXByb2dyZXNzIik7CgkJaWYgKHJ1bl9jb21tYW5kX3Zfb3B0KHBydW5lLmFyZ3YsIFJVTl9HSVRfQ01EKSkKCQkJcmV0dXJuIGVycm9yKEZBSUxFRF9SVU4sIHBydW5lLmFyZ3ZbMF0pOwoJfQoKCWlmIChydW5fY29tbWFuZF92X29wdChyZXJlcmUuYXJndiwgUlVOX0dJVF9DTUQpKQoJCXJldHVybiBlcnJvcihGQUlMRURfUlVOLCByZXJlcmUuYXJndlswXSk7CgoJaWYgKGF1dG9fZ2MgJiYgdG9vX21hbnlfbG9vc2Vfb2JqZWN0cygpKQoJCXdhcm5pbmcoXygiVGhlcmUgYXJlIHRvbyBtYW55IHVucmVhY2hhYmxlIGxvb3NlIG9iamVjdHM7ICIKCQkJInJ1biAnZ2l0IHBydW5lJyB0byByZW1vdmUgdGhlbS4iKSk7CgoJcmV0dXJuIDA7Cn0K",
    "text": "/*\n * git gc builtin command\n *\n * Cleanup unreachable files and optimize the repository.\n *\n * Copyright (c) 2007 James Bowes\n *\n * Based on git-gc.sh, which is\n *\n * Copyright (c) 2006 Shawn O. Pearce\n */\n\n#include \"builtin.h\"\n#include \"lockfile.h\"\n#include \"parse-options.h\"\n#include \"run-command.h\"\n#include \"sigchain.h\"\n#include \"argv-array.h\"\n#include \"commit.h\"\n\n#define FAILED_RUN \"failed to run %s\"\n\nstatic const char * const builtin_gc_usage[] = {\n\tN_(\"git gc [options]\"),\n\tNULL\n};\n\nstatic int pack_refs = 1;\nstatic int prune_reflogs = 1;\nstatic int aggressive_depth = 250;\nstatic int aggressive_window = 250;\nstatic int gc_auto_threshold = 6700;\nstatic int gc_auto_pack_limit = 50;\nstatic int detach_auto = 1;\nstatic const char *prune_expire = \"2.weeks.ago\";\n\nstatic struct argv_array pack_refs_cmd = ARGV_ARRAY_INIT;\nstatic struct argv_array reflog = ARGV_ARRAY_INIT;\nstatic struct argv_array repack = ARGV_ARRAY_INIT;\nstatic struct argv_array prune = ARGV_ARRAY_INIT;\nstatic struct argv_array rerere = ARGV_ARRAY_INIT;\n\nstatic char *pidfile;\n\nstatic void remove_pidfile(void)\n{\n\tif (pidfile)\n\t\tunlink(pidfile);\n}\n\nstatic void remove_pidfile_on_signal(int signo)\n{\n\tremove_pidfile();\n\tsigchain_pop(signo);\n\traise(signo);\n}\n\nstatic void gc_config(void)\n{\n\tconst char *value;\n\n\tif (!git_config_get_value(\"gc.packrefs\", &value)) {\n\t\tif (value && !strcmp(value, \"notbare\"))\n\t\t\tpack_refs = -1;\n\t\telse\n\t\t\tpack_refs = git_config_bool(\"gc.packrefs\", value);\n\t}\n\n\tgit_config_get_int(\"gc.aggressivewindow\", &aggressive_window);\n\tgit_config_get_int(\"gc.aggressivedepth\", &aggressive_depth);\n\tgit_config_get_int(\"gc.auto\", &gc_auto_threshold);\n\tgit_config_get_int(\"gc.autopacklimit\", &gc_auto_pack_limit);\n\tgit_config_get_bool(\"gc.autodetach\", &detach_auto);\n\n\tif (!git_config_get_string_const(\"gc.pruneexpire\", &prune_expire)) {\n\t\tif (strcmp(prune_expire, \"now\")) {\n\t\t\tunsigned long now = approxidate(\"now\");\n\t\t\tif (approxidate(prune_expire) >= now) {\n\t\t\t\tgit_die_config(\"gc.pruneexpire\", _(\"Invalid gc.pruneexpire: '%s'\"),\n\t\t\t\t\t\tprune_expire);\n\t\t\t}\n\t\t}\n\t}\n\tgit_config(git_default_config, NULL);\n}\n\nstatic int too_many_loose_objects(void)\n{\n\t/*\n\t * Quickly check if a \"gc\" is needed, by estimating how\n\t * many loose objects there are.  Because SHA-1 is evenly\n\t * distributed, we can check only one and get a reasonable\n\t * estimate.\n\t */\n\tchar path[PATH_MAX];\n\tconst char *objdir = get_object_directory();\n\tDIR *dir;\n\tstruct dirent *ent;\n\tint auto_threshold;\n\tint num_loose = 0;\n\tint needed = 0;\n\n\tif (gc_auto_threshold <= 0)\n\t\treturn 0;\n\n\tif (sizeof(path) <= snprintf(path, sizeof(path), \"%s/17\", objdir)) {\n\t\twarning(_(\"insanely long object directory %.*s\"), 50, objdir);\n\t\treturn 0;\n\t}\n\tdir = opendir(path);\n\tif (!dir)\n\t\treturn 0;\n\n\tauto_threshold = (gc_auto_threshold + 255) / 256;\n\twhile ((ent = readdir(dir)) != NULL) {\n\t\tif (strspn(ent->d_name, \"0123456789abcdef\") != 38 ||\n\t\t    ent->d_name[38] != '\\0')\n\t\t\tcontinue;\n\t\tif (++num_loose > auto_threshold) {\n\t\t\tneeded = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tclosedir(dir);\n\treturn needed;\n}\n\nstatic int too_many_packs(void)\n{\n\tstruct packed_git *p;\n\tint cnt;\n\n\tif (gc_auto_pack_limit <= 0)\n\t\treturn 0;\n\n\tprepare_packed_git();\n\tfor (cnt = 0, p = packed_git; p; p = p->next) {\n\t\tif (!p->pack_local)\n\t\t\tcontinue;\n\t\tif (p->pack_keep)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perhaps check the size of the pack and count only\n\t\t * very small ones here?\n\t\t */\n\t\tcnt++;\n\t}\n\treturn gc_auto_pack_limit <= cnt;\n}\n\nstatic void add_repack_all_option(void)\n{\n\tif (prune_expire && !strcmp(prune_expire, \"now\"))\n\t\targv_array_push(&repack, \"-a\");\n\telse {\n\t\targv_array_push(&repack, \"-A\");\n\t\tif (prune_expire)\n\t\t\targv_array_pushf(&repack, \"--unpack-unreachable=%s\", prune_expire);\n\t}\n}\n\nstatic int need_to_gc(void)\n{\n\t/*\n\t * Setting gc.auto to 0 or negative can disable the\n\t * automatic gc.\n\t */\n\tif (gc_auto_threshold <= 0)\n\t\treturn 0;\n\n\t/*\n\t * If there are too many loose objects, but not too many\n\t * packs, we run \"repack -d -l\".  If there are too many packs,\n\t * we run \"repack -A -d -l\".  Otherwise we tell the caller\n\t * there is no need.\n\t */\n\tif (too_many_packs())\n\t\tadd_repack_all_option();\n\telse if (!too_many_loose_objects())\n\t\treturn 0;\n\n\tif (run_hook_le(NULL, \"pre-auto-gc\", NULL))\n\t\treturn 0;\n\treturn 1;\n}\n\n/* return NULL on success, else hostname running the gc */\nstatic const char *lock_repo_for_gc(int force, pid_t* ret_pid)\n{\n\tstatic struct lock_file lock;\n\tchar my_host[128];\n\tstruct strbuf sb = STRBUF_INIT;\n\tstruct stat st;\n\tuintmax_t pid;\n\tFILE *fp;\n\tint fd;\n\n\tif (pidfile)\n\t\t/* already locked */\n\t\treturn NULL;\n\n\tif (gethostname(my_host, sizeof(my_host)))\n\t\tstrcpy(my_host, \"unknown\");\n\n\tfd = hold_lock_file_for_update(&lock, git_path(\"gc.pid\"),\n\t\t\t\t       LOCK_DIE_ON_ERROR);\n\tif (!force) {\n\t\tstatic char locking_host[128];\n\t\tint should_exit;\n\t\tfp = fopen(git_path(\"gc.pid\"), \"r\");\n\t\tmemset(locking_host, 0, sizeof(locking_host));\n\t\tshould_exit =\n\t\t\tfp != NULL &&\n\t\t\t!fstat(fileno(fp), &st) &&\n\t\t\t/*\n\t\t\t * 12 hour limit is very generous as gc should\n\t\t\t * never take that long. On the other hand we\n\t\t\t * don't really need a strict limit here,\n\t\t\t * running gc --auto one day late is not a big\n\t\t\t * problem. --force can be used in manual gc\n\t\t\t * after the user verifies that no gc is\n\t\t\t * running.\n\t\t\t */\n\t\t\ttime(NULL) - st.st_mtime <= 12 * 3600 &&\n\t\t\tfscanf(fp, \"%\"PRIuMAX\" %127c\", &pid, locking_host) == 2 &&\n\t\t\t/* be gentle to concurrent \"gc\" on remote hosts */\n\t\t\t(strcmp(locking_host, my_host) || !kill(pid, 0) || errno == EPERM);\n\t\tif (fp != NULL)\n\t\t\tfclose(fp);\n\t\tif (should_exit) {\n\t\t\tif (fd >= 0)\n\t\t\t\trollback_lock_file(&lock);\n\t\t\t*ret_pid = pid;\n\t\t\treturn locking_host;\n\t\t}\n\t}\n\n\tstrbuf_addf(&sb, \"%\"PRIuMAX\" %s\",\n\t\t    (uintmax_t) getpid(), my_host);\n\twrite_in_full(fd, sb.buf, sb.len);\n\tstrbuf_release(&sb);\n\tcommit_lock_file(&lock);\n\n\tpidfile = git_pathdup(\"gc.pid\");\n\tsigchain_push_common(remove_pidfile_on_signal);\n\tatexit(remove_pidfile);\n\n\treturn NULL;\n}\n\nstatic int gc_before_repack(void)\n{\n\tif (pack_refs && run_command_v_opt(pack_refs_cmd.argv, RUN_GIT_CMD))\n\t\treturn error(FAILED_RUN, pack_refs_cmd.argv[0]);\n\n\tif (prune_reflogs && run_command_v_opt(reflog.argv, RUN_GIT_CMD))\n\t\treturn error(FAILED_RUN, reflog.argv[0]);\n\n\tpack_refs = 0;\n\tprune_reflogs = 0;\n\treturn 0;\n}\n\nint cmd_gc(int argc, const char **argv, const char *prefix)\n{\n\tint aggressive = 0;\n\tint auto_gc = 0;\n\tint quiet = 0;\n\tint force = 0;\n\tconst char *name;\n\tpid_t pid;\n\n\tstruct option builtin_gc_options[] = {\n\t\tOPT__QUIET(&quiet, N_(\"suppress progress reporting\")),\n\t\t{ OPTION_STRING, 0, \"prune\", &prune_expire, N_(\"date\"),\n\t\t\tN_(\"prune unreferenced objects\"),\n\t\t\tPARSE_OPT_OPTARG, NULL, (intptr_t)prune_expire },\n\t\tOPT_BOOL(0, \"aggressive\", &aggressive, N_(\"be more thorough (increased runtime)\")),\n\t\tOPT_BOOL(0, \"auto\", &auto_gc, N_(\"enable auto-gc mode\")),\n\t\tOPT_BOOL(0, \"force\", &force, N_(\"force running gc even if there may be another gc running\")),\n\t\tOPT_END()\n\t};\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_gc_usage, builtin_gc_options);\n\n\targv_array_pushl(&pack_refs_cmd, \"pack-refs\", \"--all\", \"--prune\", NULL);\n\targv_array_pushl(&reflog, \"reflog\", \"expire\", \"--all\", NULL);\n\targv_array_pushl(&repack, \"repack\", \"-d\", \"-l\", NULL);\n\targv_array_pushl(&prune, \"prune\", \"--expire\", NULL );\n\targv_array_pushl(&rerere, \"rerere\", \"gc\", NULL);\n\n\tgc_config();\n\n\tif (pack_refs < 0)\n\t\tpack_refs = !is_bare_repository();\n\n\targc = parse_options(argc, argv, prefix, builtin_gc_options,\n\t\t\t     builtin_gc_usage, 0);\n\tif (argc > 0)\n\t\tusage_with_options(builtin_gc_usage, builtin_gc_options);\n\n\tif (aggressive) {\n\t\targv_array_push(&repack, \"-f\");\n\t\tif (aggressive_depth > 0)\n\t\t\targv_array_pushf(&repack, \"--depth=%d\", aggressive_depth);\n\t\tif (aggressive_window > 0)\n\t\t\targv_array_pushf(&repack, \"--window=%d\", aggressive_window);\n\t}\n\tif (quiet)\n\t\targv_array_push(&repack, \"-q\");\n\n\tif (auto_gc) {\n\t\t/*\n\t\t * Auto-gc should be least intrusive as possible.\n\t\t */\n\t\tif (!need_to_gc())\n\t\t\treturn 0;\n\t\tif (!quiet) {\n\t\t\tif (detach_auto)\n\t\t\t\tfprintf(stderr, _(\"Auto packing the repository in background for optimum performance.\\n\"));\n\t\t\telse\n\t\t\t\tfprintf(stderr, _(\"Auto packing the repository for optimum performance.\\n\"));\n\t\t\tfprintf(stderr, _(\"See \\\"git help gc\\\" for manual housekeeping.\\n\"));\n\t\t}\n\t\tif (detach_auto) {\n\t\t\tif (gc_before_repack())\n\t\t\t\treturn -1;\n\t\t\t/*\n\t\t\t * failure to daemonize is ok, we'll continue\n\t\t\t * in foreground\n\t\t\t */\n\t\t\tdaemonize();\n\t\t}\n\t} else\n\t\tadd_repack_all_option();\n\n\tname = lock_repo_for_gc(force, &pid);\n\tif (name) {\n\t\tif (auto_gc)\n\t\t\treturn 0; /* be quiet on --auto */\n\t\tdie(_(\"gc is already running on machine '%s' pid %\"PRIuMAX\" (use --force if not)\"),\n\t\t    name, (uintmax_t)pid);\n\t}\n\n\tif (gc_before_repack())\n\t\treturn -1;\n\n\tif (run_command_v_opt(repack.argv, RUN_GIT_CMD))\n\t\treturn error(FAILED_RUN, repack.argv[0]);\n\n\tif (prune_expire) {\n\t\targv_array_push(&prune, prune_expire);\n\t\tif (quiet)\n\t\t\targv_array_push(&prune, \"--no-progress\");\n\t\tif (run_command_v_opt(prune.argv, RUN_GIT_CMD))\n\t\t\treturn error(FAILED_RUN, prune.argv[0]);\n\t}\n\n\tif (run_command_v_opt(rerere.argv, RUN_GIT_CMD))\n\t\treturn error(FAILED_RUN, rerere.argv[0]);\n\n\tif (auto_gc && too_many_loose_objects())\n\t\twarning(_(\"There are too many unreachable loose objects; \"\n\t\t\t\"run 'git prune' to remove them.\"));\n\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "005adbebea80a83a8d0dbb1de744cb50bf689de6",
  "sha1_ok": true,
  "size": 9267
}
