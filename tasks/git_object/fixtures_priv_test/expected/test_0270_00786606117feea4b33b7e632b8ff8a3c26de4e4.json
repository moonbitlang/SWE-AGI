{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJ0cmFuc3BvcnQuaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJwa3QtbGluZS5oIgojaW5jbHVkZSAiZmV0Y2gtcGFjay5oIgojaW5jbHVkZSAic2VuZC1wYWNrLmgiCiNpbmNsdWRlICJ3YWxrZXIuaCIKI2luY2x1ZGUgImJ1bmRsZS5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJicmFuY2guaCIKI2luY2x1ZGUgInVybC5oIgoKLyogcnN5bmMgc3VwcG9ydCAqLwoKLyoKICogV2UgY29weSBwYWNrZWQtcmVmcyBhbmQgcmVmcy8gaW50byBhIHRlbXBvcmFyeSBmaWxlLCB0aGVuIHJlYWQgdGhlCiAqIGxvb3NlIHJlZnMgcmVjdXJzaXZlbHkgKHNvcnRpbmcgd2hlbmV2ZXIgcG9zc2libGUpLCBhbmQgdGhlbiBpbnNlcnRpbmcKICogdGhvc2UgcGFja2VkIHJlZnMgdGhhdCBhcmUgbm90IHlldCBpbiB0aGUgbGlzdCAobm90IHZhbGlkYXRpbmcsIGJ1dAogKiBhc3N1bWluZyB0aGF0IHRoZSBmaWxlIGlzIHNvcnRlZCkuCiAqCiAqIEFwcGVhcnMgcmVmYWN0b3JpbmcgdGhpcyBmcm9tIHJlZnMuYyBpcyB0b28gY3VtYmVyc29tZS4KICovCgpzdGF0aWMgaW50IHN0cl9jbXAoY29uc3Qgdm9pZCAqYSwgY29uc3Qgdm9pZCAqYikKewoJY29uc3QgY2hhciAqczEgPSBhOwoJY29uc3QgY2hhciAqczIgPSBiOwoKCXJldHVybiBzdHJjbXAoczEsIHMyKTsKfQoKLyogcGF0aC0+YnVmICsgbmFtZV9vZmZzZXQgaXMgZXhwZWN0ZWQgdG8gcG9pbnQgdG8gInJlZnMvIiAqLwoKc3RhdGljIGludCByZWFkX2xvb3NlX3JlZnMoc3RydWN0IHN0cmJ1ZiAqcGF0aCwgaW50IG5hbWVfb2Zmc2V0LAoJCXN0cnVjdCByZWYgKip0YWlsKQp7CglESVIgKmRpciA9IG9wZW5kaXIocGF0aC0+YnVmKTsKCXN0cnVjdCBkaXJlbnQgKmRlOwoJc3RydWN0IHsKCQljaGFyICoqZW50cmllczsKCQlpbnQgbnIsIGFsbG9jOwoJfSBsaXN0OwoJaW50IGksIHBhdGhsZW47CgoJaWYgKCFkaXIpCgkJcmV0dXJuIC0xOwoKCW1lbXNldCAoJmxpc3QsIDAsIHNpemVvZihsaXN0KSk7CgoJd2hpbGUgKChkZSA9IHJlYWRkaXIoZGlyKSkpIHsKCQlpZiAoaXNfZG90X29yX2RvdGRvdChkZS0+ZF9uYW1lKSkKCQkJY29udGludWU7CgkJQUxMT0NfR1JPVyhsaXN0LmVudHJpZXMsIGxpc3QubnIgKyAxLCBsaXN0LmFsbG9jKTsKCQlsaXN0LmVudHJpZXNbbGlzdC5ucisrXSA9IHhzdHJkdXAoZGUtPmRfbmFtZSk7Cgl9CgljbG9zZWRpcihkaXIpOwoKCS8qIHNvcnQgdGhlIGxpc3QgKi8KCglxc29ydChsaXN0LmVudHJpZXMsIGxpc3QubnIsIHNpemVvZihjaGFyICopLCBzdHJfY21wKTsKCglwYXRobGVuID0gcGF0aC0+bGVuOwoJc3RyYnVmX2FkZGNoKHBhdGgsICcvJyk7CgoJZm9yIChpID0gMDsgaSA8IGxpc3QubnI7IGkrKywgc3RyYnVmX3NldGxlbihwYXRoLCBwYXRobGVuICsgMSkpIHsKCQlzdHJidWZfYWRkc3RyKHBhdGgsIGxpc3QuZW50cmllc1tpXSk7CgkJaWYgKHJlYWRfbG9vc2VfcmVmcyhwYXRoLCBuYW1lX29mZnNldCwgdGFpbCkpIHsKCQkJaW50IGZkID0gb3BlbihwYXRoLT5idWYsIE9fUkRPTkxZKTsKCQkJY2hhciBidWZmZXJbNDBdOwoJCQlzdHJ1Y3QgcmVmICpuZXh0OwoKCQkJaWYgKGZkIDwgMCkKCQkJCWNvbnRpbnVlOwoJCQluZXh0ID0gYWxsb2NfcmVmKHBhdGgtPmJ1ZiArIG5hbWVfb2Zmc2V0KTsKCQkJaWYgKHJlYWRfaW5fZnVsbChmZCwgYnVmZmVyLCA0MCkgIT0gNDAgfHwKCQkJCQlnZXRfc2hhMV9oZXgoYnVmZmVyLCBuZXh0LT5vbGRfc2hhMSkpIHsKCQkJCWNsb3NlKGZkKTsKCQkJCWZyZWUobmV4dCk7CgkJCQljb250aW51ZTsKCQkJfQoJCQljbG9zZShmZCk7CgkJCSgqdGFpbCktPm5leHQgPSBuZXh0OwoJCQkqdGFpbCA9IG5leHQ7CgkJfQoJfQoJc3RyYnVmX3NldGxlbihwYXRoLCBwYXRobGVuKTsKCglmb3IgKGkgPSAwOyBpIDwgbGlzdC5ucjsgaSsrKQoJCWZyZWUobGlzdC5lbnRyaWVzW2ldKTsKCWZyZWUobGlzdC5lbnRyaWVzKTsKCglyZXR1cm4gMDsKfQoKLyogaW5zZXJ0IHRoZSBwYWNrZWQgcmVmcyBmb3Igd2hpY2ggbm8gbG9vc2UgcmVmcyB3ZXJlIGZvdW5kICovCgpzdGF0aWMgdm9pZCBpbnNlcnRfcGFja2VkX3JlZnMoY29uc3QgY2hhciAqcGFja2VkX3JlZnMsIHN0cnVjdCByZWYgKipsaXN0KQp7CglGSUxFICpmID0gZm9wZW4ocGFja2VkX3JlZnMsICJyIik7CglzdGF0aWMgY2hhciBidWZmZXJbUEFUSF9NQVhdOwoKCWlmICghZikKCQlyZXR1cm47CgoJZm9yICg7OykgewoJCWludCBjbXAgPSBjbXAsIGxlbjsKCgkJaWYgKCFmZ2V0cyhidWZmZXIsIHNpemVvZihidWZmZXIpLCBmKSkgewoJCQlmY2xvc2UoZik7CgkJCXJldHVybjsKCQl9CgoJCWlmIChoZXh2YWwoYnVmZmVyWzBdKSA+IDB4ZikKCQkJY29udGludWU7CgkJbGVuID0gc3RybGVuKGJ1ZmZlcik7CgkJaWYgKGxlbiAmJiBidWZmZXJbbGVuIC0gMV0gPT0gJ1xuJykKCQkJYnVmZmVyWy0tbGVuXSA9ICdcMCc7CgkJaWYgKGxlbiA8IDQxKQoJCQljb250aW51ZTsKCQl3aGlsZSAoKCpsaXN0KS0+bmV4dCAmJgoJCQkJKGNtcCA9IHN0cmNtcChidWZmZXIgKyA0MSwKCQkJCSAgICAgICgqbGlzdCktPm5leHQtPm5hbWUpKSA+IDApCgkJCWxpc3QgPSAmKCpsaXN0KS0+bmV4dDsKCQlpZiAoISgqbGlzdCktPm5leHQgfHwgY21wIDwgMCkgewoJCQlzdHJ1Y3QgcmVmICpuZXh0ID0gYWxsb2NfcmVmKGJ1ZmZlciArIDQxKTsKCQkJYnVmZmVyWzQwXSA9ICdcMCc7CgkJCWlmIChnZXRfc2hhMV9oZXgoYnVmZmVyLCBuZXh0LT5vbGRfc2hhMSkpIHsKCQkJCXdhcm5pbmcgKCJpbnZhbGlkIFNIQS0xOiAlcyIsIGJ1ZmZlcik7CgkJCQlmcmVlKG5leHQpOwoJCQkJY29udGludWU7CgkJCX0KCQkJbmV4dC0+bmV4dCA9ICgqbGlzdCktPm5leHQ7CgkJCSgqbGlzdCktPm5leHQgPSBuZXh0OwoJCQlsaXN0ID0gJigqbGlzdCktPm5leHQ7CgkJfQoJfQp9CgpzdGF0aWMgdm9pZCBzZXRfdXBzdHJlYW1zKHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCwgc3RydWN0IHJlZiAqcmVmcywKCWludCBwcmV0ZW5kKQp7CglzdHJ1Y3QgcmVmICpyZWY7Cglmb3IgKHJlZiA9IHJlZnM7IHJlZjsgcmVmID0gcmVmLT5uZXh0KSB7CgkJY29uc3QgY2hhciAqbG9jYWxuYW1lOwoJCWNvbnN0IGNoYXIgKnRtcDsKCQljb25zdCBjaGFyICpyZW1vdGVuYW1lOwoJCXVuc2lnbmVkIGNoYXIgc2hhWzIwXTsKCQlpbnQgZmxhZyA9IDA7CgkJLyoKCQkgKiBDaGVjayBzdWl0YWJpbGl0eSBmb3IgdHJhY2tpbmcuIE11c3QgYmUgc3VjY2Vzc2Z1bCAvCgkJICogYWxyZWFkeSB1cC10by1kYXRlIHJlZiBjcmVhdGUvbW9kaWZ5IChub3QgZGVsZXRlKS4KCQkgKi8KCQlpZiAocmVmLT5zdGF0dXMgIT0gUkVGX1NUQVRVU19PSyAmJgoJCQlyZWYtPnN0YXR1cyAhPSBSRUZfU1RBVFVTX1VQVE9EQVRFKQoJCQljb250aW51ZTsKCQlpZiAoIXJlZi0+cGVlcl9yZWYpCgkJCWNvbnRpbnVlOwoJCWlmICghcmVmLT5uZXdfc2hhMSB8fCBpc19udWxsX3NoYTEocmVmLT5uZXdfc2hhMSkpCgkJCWNvbnRpbnVlOwoKCQkvKiBGb2xsb3cgc3ltYm9saWMgcmVmcyAobWFpbmx5IGZvciBIRUFEKS4gKi8KCQlsb2NhbG5hbWUgPSByZWYtPnBlZXJfcmVmLT5uYW1lOwoJCXJlbW90ZW5hbWUgPSByZWYtPm5hbWU7CgkJdG1wID0gcmVzb2x2ZV9yZWYobG9jYWxuYW1lLCBzaGEsIDEsICZmbGFnKTsKCQlpZiAodG1wICYmIGZsYWcgJiBSRUZfSVNTWU1SRUYgJiYKCQkJIXByZWZpeGNtcCh0bXAsICJyZWZzL2hlYWRzLyIpKQoJCQlsb2NhbG5hbWUgPSB0bXA7CgoJCS8qIEJvdGggc291cmNlIGFuZCBkZXN0aW5hdGlvbiBtdXN0IGJlIGxvY2FsIGJyYW5jaGVzLiAqLwoJCWlmICghbG9jYWxuYW1lIHx8IHByZWZpeGNtcChsb2NhbG5hbWUsICJyZWZzL2hlYWRzLyIpKQoJCQljb250aW51ZTsKCQlpZiAoIXJlbW90ZW5hbWUgfHwgcHJlZml4Y21wKHJlbW90ZW5hbWUsICJyZWZzL2hlYWRzLyIpKQoJCQljb250aW51ZTsKCgkJaWYgKCFwcmV0ZW5kKQoJCQlpbnN0YWxsX2JyYW5jaF9jb25maWcoQlJBTkNIX0NPTkZJR19WRVJCT1NFLAoJCQkJbG9jYWxuYW1lICsgMTEsIHRyYW5zcG9ydC0+cmVtb3RlLT5uYW1lLAoJCQkJcmVtb3RlbmFtZSk7CgkJZWxzZQoJCQlwcmludGYoIldvdWxkIHNldCB1cHN0cmVhbSBvZiAnJXMnIHRvICclcycgb2YgJyVzJ1xuIiwKCQkJCWxvY2FsbmFtZSArIDExLCByZW1vdGVuYW1lICsgMTEsCgkJCQl0cmFuc3BvcnQtPnJlbW90ZS0+bmFtZSk7Cgl9Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpyc3luY191cmwoY29uc3QgY2hhciAqdXJsKQp7CglyZXR1cm4gcHJlZml4Y21wKHVybCwgInJzeW5jOi8vIikgPyBza2lwX3ByZWZpeCh1cmwsICJyc3luYzoiKSA6IHVybDsKfQoKc3RhdGljIHN0cnVjdCByZWYgKmdldF9yZWZzX3ZpYV9yc3luYyhzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsIGludCBmb3JfcHVzaCkKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVCwgdGVtcF9kaXIgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCByZWYgZHVtbXkgPSB7MH0sICp0YWlsID0gJmR1bW15OwoJc3RydWN0IGNoaWxkX3Byb2Nlc3MgcnN5bmM7Cgljb25zdCBjaGFyICphcmdzWzVdOwoJaW50IHRlbXBfZGlyX2xlbjsKCglpZiAoZm9yX3B1c2gpCgkJcmV0dXJuIE5VTEw7CgoJLyogY29weSB0aGUgcmVmcyB0byB0aGUgdGVtcG9yYXJ5IGRpcmVjdG9yeSAqLwoKCXN0cmJ1Zl9hZGRzdHIoJnRlbXBfZGlyLCBnaXRfcGF0aCgicnN5bmMtcmVmcy1YWFhYWFgiKSk7CglpZiAoIW1rZHRlbXAodGVtcF9kaXIuYnVmKSkKCQlkaWVfZXJybm8gKCJDb3VsZCBub3QgbWFrZSB0ZW1wb3JhcnkgZGlyZWN0b3J5Iik7Cgl0ZW1wX2Rpcl9sZW4gPSB0ZW1wX2Rpci5sZW47CgoJc3RyYnVmX2FkZHN0cigmYnVmLCByc3luY191cmwodHJhbnNwb3J0LT51cmwpKTsKCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgIi9yZWZzIik7CgoJbWVtc2V0KCZyc3luYywgMCwgc2l6ZW9mKHJzeW5jKSk7Cglyc3luYy5hcmd2ID0gYXJnczsKCXJzeW5jLnN0ZG91dF90b19zdGRlcnIgPSAxOwoJYXJnc1swXSA9ICJyc3luYyI7CglhcmdzWzFdID0gKHRyYW5zcG9ydC0+dmVyYm9zZSA+IDApID8gIi1ydiIgOiAiLXIiOwoJYXJnc1syXSA9IGJ1Zi5idWY7CglhcmdzWzNdID0gdGVtcF9kaXIuYnVmOwoJYXJnc1s0XSA9IE5VTEw7CgoJaWYgKHJ1bl9jb21tYW5kKCZyc3luYykpCgkJZGllICgiQ291bGQgbm90IHJ1biByc3luYyB0byBnZXQgcmVmcyIpOwoKCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgcnN5bmNfdXJsKHRyYW5zcG9ydC0+dXJsKSk7CglzdHJidWZfYWRkc3RyKCZidWYsICIvcGFja2VkLXJlZnMiKTsKCglhcmdzWzJdID0gYnVmLmJ1ZjsKCglpZiAocnVuX2NvbW1hbmQoJnJzeW5jKSkKCQlkaWUgKCJDb3VsZCBub3QgcnVuIHJzeW5jIHRvIGdldCByZWZzIik7CgoJLyogcmVhZCB0aGUgY29waWVkIHJlZnMgKi8KCglzdHJidWZfYWRkc3RyKCZ0ZW1wX2RpciwgIi9yZWZzIik7CglyZWFkX2xvb3NlX3JlZnMoJnRlbXBfZGlyLCB0ZW1wX2Rpcl9sZW4gKyAxLCAmdGFpbCk7CglzdHJidWZfc2V0bGVuKCZ0ZW1wX2RpciwgdGVtcF9kaXJfbGVuKTsKCgl0YWlsID0gJmR1bW15OwoJc3RyYnVmX2FkZHN0cigmdGVtcF9kaXIsICIvcGFja2VkLXJlZnMiKTsKCWluc2VydF9wYWNrZWRfcmVmcyh0ZW1wX2Rpci5idWYsICZ0YWlsKTsKCXN0cmJ1Zl9zZXRsZW4oJnRlbXBfZGlyLCB0ZW1wX2Rpcl9sZW4pOwoKCWlmIChyZW1vdmVfZGlyX3JlY3Vyc2l2ZWx5KCZ0ZW1wX2RpciwgMCkpCgkJd2FybmluZyAoIkVycm9yIHJlbW92aW5nIHRlbXBvcmFyeSBkaXJlY3RvcnkgJXMuIiwKCQkJCXRlbXBfZGlyLmJ1Zik7CgoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CglzdHJidWZfcmVsZWFzZSgmdGVtcF9kaXIpOwoKCXJldHVybiBkdW1teS5uZXh0Owp9CgpzdGF0aWMgaW50IGZldGNoX29ianNfdmlhX3JzeW5jKHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCwKCQkJCWludCBucl9vYmpzLCBzdHJ1Y3QgcmVmICoqdG9fZmV0Y2gpCnsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyByc3luYzsKCWNvbnN0IGNoYXIgKmFyZ3NbOF07CglpbnQgcmVzdWx0OwoKCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgcnN5bmNfdXJsKHRyYW5zcG9ydC0+dXJsKSk7CglzdHJidWZfYWRkc3RyKCZidWYsICIvb2JqZWN0cy8iKTsKCgltZW1zZXQoJnJzeW5jLCAwLCBzaXplb2YocnN5bmMpKTsKCXJzeW5jLmFyZ3YgPSBhcmdzOwoJcnN5bmMuc3Rkb3V0X3RvX3N0ZGVyciA9IDE7CglhcmdzWzBdID0gInJzeW5jIjsKCWFyZ3NbMV0gPSAodHJhbnNwb3J0LT52ZXJib3NlID4gMCkgPyAiLXJ2IiA6ICItciI7CglhcmdzWzJdID0gIi0taWdub3JlLWV4aXN0aW5nIjsKCWFyZ3NbM10gPSAiLS1leGNsdWRlIjsKCWFyZ3NbNF0gPSAiaW5mbyI7CglhcmdzWzVdID0gYnVmLmJ1ZjsKCWFyZ3NbNl0gPSBnZXRfb2JqZWN0X2RpcmVjdG9yeSgpOwoJYXJnc1s3XSA9IE5VTEw7CgoJLyogTkVFRFNXT1JLOiBoYW5kbGUgb25lIGxldmVsIG9mIGFsdGVybmF0ZXMgKi8KCXJlc3VsdCA9IHJ1bl9jb21tYW5kKCZyc3luYyk7CgoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CgoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIGludCB3cml0ZV9vbmVfcmVmKGNvbnN0IGNoYXIgKm5hbWUsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsCgkJaW50IGZsYWdzLCB2b2lkICpkYXRhKQp7CglzdHJ1Y3Qgc3RyYnVmICpidWYgPSBkYXRhOwoJaW50IGxlbiA9IGJ1Zi0+bGVuOwoJRklMRSAqZjsKCgkvKiB3aGVuIGNhbGxlZCB2aWEgZm9yX2VhY2hfcmVmKCksIGZsYWdzIGlzIG5vbi16ZXJvICovCglpZiAoZmxhZ3MgJiYgcHJlZml4Y21wKG5hbWUsICJyZWZzL2hlYWRzLyIpICYmCgkJCXByZWZpeGNtcChuYW1lLCAicmVmcy90YWdzLyIpKQoJCXJldHVybiAwOwoKCXN0cmJ1Zl9hZGRzdHIoYnVmLCBuYW1lKTsKCWlmIChzYWZlX2NyZWF0ZV9sZWFkaW5nX2RpcmVjdG9yaWVzKGJ1Zi0+YnVmKSB8fAoJCQkhKGYgPSBmb3BlbihidWYtPmJ1ZiwgInciKSkgfHwKCQkJZnByaW50ZihmLCAiJXNcbiIsIHNoYTFfdG9faGV4KHNoYTEpKSA8IDAgfHwKCQkJZmNsb3NlKGYpKQoJCXJldHVybiBlcnJvcigicHJvYmxlbXMgd3JpdGluZyB0ZW1wb3JhcnkgZmlsZSAlcyIsIGJ1Zi0+YnVmKTsKCXN0cmJ1Zl9zZXRsZW4oYnVmLCBsZW4pOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgd3JpdGVfcmVmc190b190ZW1wX2RpcihzdHJ1Y3Qgc3RyYnVmICp0ZW1wX2RpciwKCQlpbnQgcmVmc3BlY19uciwgY29uc3QgY2hhciAqKnJlZnNwZWMpCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCByZWZzcGVjX25yOyBpKyspIHsKCQl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJCWNoYXIgKnJlZjsKCgkJaWYgKGR3aW1fcmVmKHJlZnNwZWNbaV0sIHN0cmxlbihyZWZzcGVjW2ldKSwgc2hhMSwgJnJlZikgIT0gMSkKCQkJcmV0dXJuIGVycm9yKCJDb3VsZCBub3QgZ2V0IHJlZiAlcyIsIHJlZnNwZWNbaV0pOwoKCQlpZiAod3JpdGVfb25lX3JlZihyZWYsIHNoYTEsIDAsIHRlbXBfZGlyKSkgewoJCQlmcmVlKHJlZik7CgkJCXJldHVybiAtMTsKCQl9CgkJZnJlZShyZWYpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgcnN5bmNfdHJhbnNwb3J0X3B1c2goc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0LAoJCWludCByZWZzcGVjX25yLCBjb25zdCBjaGFyICoqcmVmc3BlYywgaW50IGZsYWdzKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklULCB0ZW1wX2RpciA9IFNUUkJVRl9JTklUOwoJaW50IHJlc3VsdCA9IDAsIGk7CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyByc3luYzsKCWNvbnN0IGNoYXIgKmFyZ3NbMTBdOwoKCWlmIChmbGFncyAmIFRSQU5TUE9SVF9QVVNIX01JUlJPUikKCQlyZXR1cm4gZXJyb3IoInJzeW5jIHRyYW5zcG9ydCBkb2VzIG5vdCBzdXBwb3J0IG1pcnJvciBtb2RlIik7CgoJLyogZmlyc3QgcHVzaCB0aGUgb2JqZWN0cyAqLwoKCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgcnN5bmNfdXJsKHRyYW5zcG9ydC0+dXJsKSk7CglzdHJidWZfYWRkY2goJmJ1ZiwgJy8nKTsKCgltZW1zZXQoJnJzeW5jLCAwLCBzaXplb2YocnN5bmMpKTsKCXJzeW5jLmFyZ3YgPSBhcmdzOwoJcnN5bmMuc3Rkb3V0X3RvX3N0ZGVyciA9IDE7CglpID0gMDsKCWFyZ3NbaSsrXSA9ICJyc3luYyI7CglhcmdzW2krK10gPSAiLWEiOwoJaWYgKGZsYWdzICYgVFJBTlNQT1JUX1BVU0hfRFJZX1JVTikKCQlhcmdzW2krK10gPSAiLS1kcnktcnVuIjsKCWlmICh0cmFuc3BvcnQtPnZlcmJvc2UgPiAwKQoJCWFyZ3NbaSsrXSA9ICItdiI7CglhcmdzW2krK10gPSAiLS1pZ25vcmUtZXhpc3RpbmciOwoJYXJnc1tpKytdID0gIi0tZXhjbHVkZSI7CglhcmdzW2krK10gPSAiaW5mbyI7CglhcmdzW2krK10gPSBnZXRfb2JqZWN0X2RpcmVjdG9yeSgpOwoJYXJnc1tpKytdID0gYnVmLmJ1ZjsKCWFyZ3NbaSsrXSA9IE5VTEw7CgoJaWYgKHJ1bl9jb21tYW5kKCZyc3luYykpCgkJcmV0dXJuIGVycm9yKCJDb3VsZCBub3QgcHVzaCBvYmplY3RzIHRvICVzIiwKCQkJCXJzeW5jX3VybCh0cmFuc3BvcnQtPnVybCkpOwoKCS8qIGNvcHkgdGhlIHJlZnMgdG8gdGhlIHRlbXBvcmFyeSBkaXJlY3Rvcnk7IHRoZXkgY291bGQgYmUgcGFja2VkLiAqLwoKCXN0cmJ1Zl9hZGRzdHIoJnRlbXBfZGlyLCBnaXRfcGF0aCgicnN5bmMtcmVmcy1YWFhYWFgiKSk7CglpZiAoIW1rZHRlbXAodGVtcF9kaXIuYnVmKSkKCQlkaWVfZXJybm8gKCJDb3VsZCBub3QgbWFrZSB0ZW1wb3JhcnkgZGlyZWN0b3J5Iik7CglzdHJidWZfYWRkY2goJnRlbXBfZGlyLCAnLycpOwoKCWlmIChmbGFncyAmIFRSQU5TUE9SVF9QVVNIX0FMTCkgewoJCWlmIChmb3JfZWFjaF9yZWYod3JpdGVfb25lX3JlZiwgJnRlbXBfZGlyKSkKCQkJcmV0dXJuIC0xOwoJfSBlbHNlIGlmICh3cml0ZV9yZWZzX3RvX3RlbXBfZGlyKCZ0ZW1wX2RpciwgcmVmc3BlY19uciwgcmVmc3BlYykpCgkJcmV0dXJuIC0xOwoKCWkgPSAyOwoJaWYgKGZsYWdzICYgVFJBTlNQT1JUX1BVU0hfRFJZX1JVTikKCQlhcmdzW2krK10gPSAiLS1kcnktcnVuIjsKCWlmICghKGZsYWdzICYgVFJBTlNQT1JUX1BVU0hfRk9SQ0UpKQoJCWFyZ3NbaSsrXSA9ICItLWlnbm9yZS1leGlzdGluZyI7CglhcmdzW2krK10gPSB0ZW1wX2Rpci5idWY7CglhcmdzW2krK10gPSByc3luY191cmwodHJhbnNwb3J0LT51cmwpOwoJYXJnc1tpKytdID0gTlVMTDsKCWlmIChydW5fY29tbWFuZCgmcnN5bmMpKQoJCXJlc3VsdCA9IGVycm9yKCJDb3VsZCBub3QgcHVzaCB0byAlcyIsCgkJCQlyc3luY191cmwodHJhbnNwb3J0LT51cmwpKTsKCglpZiAocmVtb3ZlX2Rpcl9yZWN1cnNpdmVseSgmdGVtcF9kaXIsIDApKQoJCXdhcm5pbmcgKCJDb3VsZCBub3QgcmVtb3ZlIHRlbXBvcmFyeSBkaXJlY3RvcnkgJXMuIiwKCQkJCXRlbXBfZGlyLmJ1Zik7CgoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CglzdHJidWZfcmVsZWFzZSgmdGVtcF9kaXIpOwoKCXJldHVybiByZXN1bHQ7Cn0KCnN0cnVjdCBidW5kbGVfdHJhbnNwb3J0X2RhdGEgewoJaW50IGZkOwoJc3RydWN0IGJ1bmRsZV9oZWFkZXIgaGVhZGVyOwp9OwoKc3RhdGljIHN0cnVjdCByZWYgKmdldF9yZWZzX2Zyb21fYnVuZGxlKHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCwgaW50IGZvcl9wdXNoKQp7CglzdHJ1Y3QgYnVuZGxlX3RyYW5zcG9ydF9kYXRhICpkYXRhID0gdHJhbnNwb3J0LT5kYXRhOwoJc3RydWN0IHJlZiAqcmVzdWx0ID0gTlVMTDsKCWludCBpOwoKCWlmIChmb3JfcHVzaCkKCQlyZXR1cm4gTlVMTDsKCglpZiAoZGF0YS0+ZmQgPiAwKQoJCWNsb3NlKGRhdGEtPmZkKTsKCWRhdGEtPmZkID0gcmVhZF9idW5kbGVfaGVhZGVyKHRyYW5zcG9ydC0+dXJsLCAmZGF0YS0+aGVhZGVyKTsKCWlmIChkYXRhLT5mZCA8IDApCgkJZGllICgiQ291bGQgbm90IHJlYWQgYnVuZGxlICclcycuIiwgdHJhbnNwb3J0LT51cmwpOwoJZm9yIChpID0gMDsgaSA8IGRhdGEtPmhlYWRlci5yZWZlcmVuY2VzLm5yOyBpKyspIHsKCQlzdHJ1Y3QgcmVmX2xpc3RfZW50cnkgKmUgPSBkYXRhLT5oZWFkZXIucmVmZXJlbmNlcy5saXN0ICsgaTsKCQlzdHJ1Y3QgcmVmICpyZWYgPSBhbGxvY19yZWYoZS0+bmFtZSk7CgkJaGFzaGNweShyZWYtPm9sZF9zaGExLCBlLT5zaGExKTsKCQlyZWYtPm5leHQgPSByZXN1bHQ7CgkJcmVzdWx0ID0gcmVmOwoJfQoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIGludCBmZXRjaF9yZWZzX2Zyb21fYnVuZGxlKHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCwKCQkJICAgICAgIGludCBucl9oZWFkcywgc3RydWN0IHJlZiAqKnRvX2ZldGNoKQp7CglzdHJ1Y3QgYnVuZGxlX3RyYW5zcG9ydF9kYXRhICpkYXRhID0gdHJhbnNwb3J0LT5kYXRhOwoJcmV0dXJuIHVuYnVuZGxlKCZkYXRhLT5oZWFkZXIsIGRhdGEtPmZkKTsKfQoKc3RhdGljIGludCBjbG9zZV9idW5kbGUoc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0KQp7CglzdHJ1Y3QgYnVuZGxlX3RyYW5zcG9ydF9kYXRhICpkYXRhID0gdHJhbnNwb3J0LT5kYXRhOwoJaWYgKGRhdGEtPmZkID4gMCkKCQljbG9zZShkYXRhLT5mZCk7CglmcmVlKGRhdGEpOwoJcmV0dXJuIDA7Cn0KCnN0cnVjdCBnaXRfdHJhbnNwb3J0X2RhdGEgewoJc3RydWN0IGdpdF90cmFuc3BvcnRfb3B0aW9ucyBvcHRpb25zOwoJc3RydWN0IGNoaWxkX3Byb2Nlc3MgKmNvbm47CglpbnQgZmRbMl07Cgl1bnNpZ25lZCBnb3RfcmVtb3RlX2hlYWRzIDogMTsKCXN0cnVjdCBleHRyYV9oYXZlX29iamVjdHMgZXh0cmFfaGF2ZTsKfTsKCnN0YXRpYyBpbnQgc2V0X2dpdF9vcHRpb24oc3RydWN0IGdpdF90cmFuc3BvcnRfb3B0aW9ucyAqb3B0cywKCQkJICBjb25zdCBjaGFyICpuYW1lLCBjb25zdCBjaGFyICp2YWx1ZSkKewoJaWYgKCFzdHJjbXAobmFtZSwgVFJBTlNfT1BUX1VQTE9BRFBBQ0spKSB7CgkJb3B0cy0+dXBsb2FkcGFjayA9IHZhbHVlOwoJCXJldHVybiAwOwoJfSBlbHNlIGlmICghc3RyY21wKG5hbWUsIFRSQU5TX09QVF9SRUNFSVZFUEFDSykpIHsKCQlvcHRzLT5yZWNlaXZlcGFjayA9IHZhbHVlOwoJCXJldHVybiAwOwoJfSBlbHNlIGlmICghc3RyY21wKG5hbWUsIFRSQU5TX09QVF9USElOKSkgewoJCW9wdHMtPnRoaW4gPSAhIXZhbHVlOwoJCXJldHVybiAwOwoJfSBlbHNlIGlmICghc3RyY21wKG5hbWUsIFRSQU5TX09QVF9GT0xMT1dUQUdTKSkgewoJCW9wdHMtPmZvbGxvd3RhZ3MgPSAhIXZhbHVlOwoJCXJldHVybiAwOwoJfSBlbHNlIGlmICghc3RyY21wKG5hbWUsIFRSQU5TX09QVF9LRUVQKSkgewoJCW9wdHMtPmtlZXAgPSAhIXZhbHVlOwoJCXJldHVybiAwOwoJfSBlbHNlIGlmICghc3RyY21wKG5hbWUsIFRSQU5TX09QVF9ERVBUSCkpIHsKCQlpZiAoIXZhbHVlKQoJCQlvcHRzLT5kZXB0aCA9IDA7CgkJZWxzZQoJCQlvcHRzLT5kZXB0aCA9IGF0b2kodmFsdWUpOwoJCXJldHVybiAwOwoJfQoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBpbnQgY29ubmVjdF9zZXR1cChzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsIGludCBmb3JfcHVzaCwgaW50IHZlcmJvc2UpCnsKCXN0cnVjdCBnaXRfdHJhbnNwb3J0X2RhdGEgKmRhdGEgPSB0cmFuc3BvcnQtPmRhdGE7CgoJaWYgKGRhdGEtPmNvbm4pCgkJcmV0dXJuIDA7CgoJZGF0YS0+Y29ubiA9IGdpdF9jb25uZWN0KGRhdGEtPmZkLCB0cmFuc3BvcnQtPnVybCwKCQkJCSBmb3JfcHVzaCA/IGRhdGEtPm9wdGlvbnMucmVjZWl2ZXBhY2sgOgoJCQkJIGRhdGEtPm9wdGlvbnMudXBsb2FkcGFjaywKCQkJCSB2ZXJib3NlID8gQ09OTkVDVF9WRVJCT1NFIDogMCk7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVmICpnZXRfcmVmc192aWFfY29ubmVjdChzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsIGludCBmb3JfcHVzaCkKewoJc3RydWN0IGdpdF90cmFuc3BvcnRfZGF0YSAqZGF0YSA9IHRyYW5zcG9ydC0+ZGF0YTsKCXN0cnVjdCByZWYgKnJlZnM7CgoJY29ubmVjdF9zZXR1cCh0cmFuc3BvcnQsIGZvcl9wdXNoLCAwKTsKCWdldF9yZW1vdGVfaGVhZHMoZGF0YS0+ZmRbMF0sICZyZWZzLCAwLCBOVUxMLAoJCQkgZm9yX3B1c2ggPyBSRUZfTk9STUFMIDogMCwgJmRhdGEtPmV4dHJhX2hhdmUpOwoJZGF0YS0+Z290X3JlbW90ZV9oZWFkcyA9IDE7CgoJcmV0dXJuIHJlZnM7Cn0KCnN0YXRpYyBpbnQgZmV0Y2hfcmVmc192aWFfcGFjayhzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsCgkJCSAgICAgICBpbnQgbnJfaGVhZHMsIHN0cnVjdCByZWYgKip0b19mZXRjaCkKewoJc3RydWN0IGdpdF90cmFuc3BvcnRfZGF0YSAqZGF0YSA9IHRyYW5zcG9ydC0+ZGF0YTsKCWNoYXIgKipoZWFkcyA9IHhtYWxsb2MobnJfaGVhZHMgKiBzaXplb2YoKmhlYWRzKSk7CgljaGFyICoqb3JpZ2ggPSB4bWFsbG9jKG5yX2hlYWRzICogc2l6ZW9mKCpvcmlnaCkpOwoJY29uc3Qgc3RydWN0IHJlZiAqcmVmczsKCWNoYXIgKmRlc3QgPSB4c3RyZHVwKHRyYW5zcG9ydC0+dXJsKTsKCXN0cnVjdCBmZXRjaF9wYWNrX2FyZ3MgYXJnczsKCWludCBpOwoJc3RydWN0IHJlZiAqcmVmc190bXAgPSBOVUxMOwoKCW1lbXNldCgmYXJncywgMCwgc2l6ZW9mKGFyZ3MpKTsKCWFyZ3MudXBsb2FkcGFjayA9IGRhdGEtPm9wdGlvbnMudXBsb2FkcGFjazsKCWFyZ3Mua2VlcF9wYWNrID0gZGF0YS0+b3B0aW9ucy5rZWVwOwoJYXJncy5sb2NrX3BhY2sgPSAxOwoJYXJncy51c2VfdGhpbl9wYWNrID0gZGF0YS0+b3B0aW9ucy50aGluOwoJYXJncy5pbmNsdWRlX3RhZyA9IGRhdGEtPm9wdGlvbnMuZm9sbG93dGFnczsKCWFyZ3MudmVyYm9zZSA9ICh0cmFuc3BvcnQtPnZlcmJvc2UgPiAwKTsKCWFyZ3MucXVpZXQgPSAodHJhbnNwb3J0LT52ZXJib3NlIDwgMCk7CglhcmdzLm5vX3Byb2dyZXNzID0gIXRyYW5zcG9ydC0+cHJvZ3Jlc3M7CglhcmdzLmRlcHRoID0gZGF0YS0+b3B0aW9ucy5kZXB0aDsKCglmb3IgKGkgPSAwOyBpIDwgbnJfaGVhZHM7IGkrKykKCQlvcmlnaFtpXSA9IGhlYWRzW2ldID0geHN0cmR1cCh0b19mZXRjaFtpXS0+bmFtZSk7CgoJaWYgKCFkYXRhLT5nb3RfcmVtb3RlX2hlYWRzKSB7CgkJY29ubmVjdF9zZXR1cCh0cmFuc3BvcnQsIDAsIDApOwoJCWdldF9yZW1vdGVfaGVhZHMoZGF0YS0+ZmRbMF0sICZyZWZzX3RtcCwgMCwgTlVMTCwgMCwgTlVMTCk7CgkJZGF0YS0+Z290X3JlbW90ZV9oZWFkcyA9IDE7Cgl9CgoJcmVmcyA9IGZldGNoX3BhY2soJmFyZ3MsIGRhdGEtPmZkLCBkYXRhLT5jb25uLAoJCQkgIHJlZnNfdG1wID8gcmVmc190bXAgOiB0cmFuc3BvcnQtPnJlbW90ZV9yZWZzLAoJCQkgIGRlc3QsIG5yX2hlYWRzLCBoZWFkcywgJnRyYW5zcG9ydC0+cGFja19sb2NrZmlsZSk7CgljbG9zZShkYXRhLT5mZFswXSk7CgljbG9zZShkYXRhLT5mZFsxXSk7CglpZiAoZmluaXNoX2Nvbm5lY3QoZGF0YS0+Y29ubikpCgkJcmVmcyA9IE5VTEw7CglkYXRhLT5jb25uID0gTlVMTDsKCWRhdGEtPmdvdF9yZW1vdGVfaGVhZHMgPSAwOwoKCWZyZWVfcmVmcyhyZWZzX3RtcCk7CgoJZm9yIChpID0gMDsgaSA8IG5yX2hlYWRzOyBpKyspCgkJZnJlZShvcmlnaFtpXSk7CglmcmVlKG9yaWdoKTsKCWZyZWUoaGVhZHMpOwoJZnJlZShkZXN0KTsKCXJldHVybiAocmVmcyA/IDAgOiAtMSk7Cn0KCnN0YXRpYyBpbnQgcHVzaF9oYWRfZXJyb3JzKHN0cnVjdCByZWYgKnJlZikKewoJZm9yICg7IHJlZjsgcmVmID0gcmVmLT5uZXh0KSB7CgkJc3dpdGNoIChyZWYtPnN0YXR1cykgewoJCWNhc2UgUkVGX1NUQVRVU19OT05FOgoJCWNhc2UgUkVGX1NUQVRVU19VUFRPREFURToKCQljYXNlIFJFRl9TVEFUVVNfT0s6CgkJCWJyZWFrOwoJCWRlZmF1bHQ6CgkJCXJldHVybiAxOwoJCX0KCX0KCXJldHVybiAwOwp9CgppbnQgdHJhbnNwb3J0X3JlZnNfcHVzaGVkKHN0cnVjdCByZWYgKnJlZikKewoJZm9yICg7IHJlZjsgcmVmID0gcmVmLT5uZXh0KSB7CgkJc3dpdGNoKHJlZi0+c3RhdHVzKSB7CgkJY2FzZSBSRUZfU1RBVFVTX05PTkU6CgkJY2FzZSBSRUZfU1RBVFVTX1VQVE9EQVRFOgoJCQlicmVhazsKCQlkZWZhdWx0OgoJCQlyZXR1cm4gMTsKCQl9Cgl9CglyZXR1cm4gMDsKfQoKdm9pZCB0cmFuc3BvcnRfdXBkYXRlX3RyYWNraW5nX3JlZihzdHJ1Y3QgcmVtb3RlICpyZW1vdGUsIHN0cnVjdCByZWYgKnJlZiwgaW50IHZlcmJvc2UpCnsKCXN0cnVjdCByZWZzcGVjIHJzOwoKCWlmIChyZWYtPnN0YXR1cyAhPSBSRUZfU1RBVFVTX09LICYmIHJlZi0+c3RhdHVzICE9IFJFRl9TVEFUVVNfVVBUT0RBVEUpCgkJcmV0dXJuOwoKCXJzLnNyYyA9IHJlZi0+bmFtZTsKCXJzLmRzdCA9IE5VTEw7CgoJaWYgKCFyZW1vdGVfZmluZF90cmFja2luZyhyZW1vdGUsICZycykpIHsKCQlpZiAodmVyYm9zZSkKCQkJZnByaW50ZihzdGRlcnIsICJ1cGRhdGluZyBsb2NhbCB0cmFja2luZyByZWYgJyVzJ1xuIiwgcnMuZHN0KTsKCQlpZiAocmVmLT5kZWxldGlvbikgewoJCQlkZWxldGVfcmVmKHJzLmRzdCwgTlVMTCwgMCk7CgkJfSBlbHNlCgkJCXVwZGF0ZV9yZWYoInVwZGF0ZSBieSBwdXNoIiwgcnMuZHN0LAoJCQkJCXJlZi0+bmV3X3NoYTEsIE5VTEwsIDAsIDApOwoJCWZyZWUocnMuZHN0KTsKCX0KfQoKc3RhdGljIHZvaWQgcHJpbnRfcmVmX3N0YXR1cyhjaGFyIGZsYWcsIGNvbnN0IGNoYXIgKnN1bW1hcnksIHN0cnVjdCByZWYgKnRvLCBzdHJ1Y3QgcmVmICpmcm9tLCBjb25zdCBjaGFyICptc2csIGludCBwb3JjZWxhaW4pCnsKCWlmIChwb3JjZWxhaW4pIHsKCQlpZiAoZnJvbSkKCQkJZnByaW50ZihzdGRvdXQsICIlY1x0JXM6JXNcdCIsIGZsYWcsIGZyb20tPm5hbWUsIHRvLT5uYW1lKTsKCQllbHNlCgkJCWZwcmludGYoc3Rkb3V0LCAiJWNcdDolc1x0IiwgZmxhZywgdG8tPm5hbWUpOwoJCWlmIChtc2cpCgkJCWZwcmludGYoc3Rkb3V0LCAiJXMgKCVzKVxuIiwgc3VtbWFyeSwgbXNnKTsKCQllbHNlCgkJCWZwcmludGYoc3Rkb3V0LCAiJXNcbiIsIHN1bW1hcnkpOwoJfSBlbHNlIHsKCQlmcHJpbnRmKHN0ZGVyciwgIiAlYyAlLSpzICIsIGZsYWcsIFRSQU5TUE9SVF9TVU1NQVJZX1dJRFRILCBzdW1tYXJ5KTsKCQlpZiAoZnJvbSkKCQkJZnByaW50ZihzdGRlcnIsICIlcyAtPiAlcyIsIHByZXR0aWZ5X3JlZm5hbWUoZnJvbS0+bmFtZSksIHByZXR0aWZ5X3JlZm5hbWUodG8tPm5hbWUpKTsKCQllbHNlCgkJCWZwdXRzKHByZXR0aWZ5X3JlZm5hbWUodG8tPm5hbWUpLCBzdGRlcnIpOwoJCWlmIChtc2cpIHsKCQkJZnB1dHMoIiAoIiwgc3RkZXJyKTsKCQkJZnB1dHMobXNnLCBzdGRlcnIpOwoJCQlmcHV0YygnKScsIHN0ZGVycik7CgkJfQoJCWZwdXRjKCdcbicsIHN0ZGVycik7Cgl9Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpzdGF0dXNfYWJicmV2KHVuc2lnbmVkIGNoYXIgc2hhMVsyMF0pCnsKCXJldHVybiBmaW5kX3VuaXF1ZV9hYmJyZXYoc2hhMSwgREVGQVVMVF9BQkJSRVYpOwp9CgpzdGF0aWMgdm9pZCBwcmludF9va19yZWZfc3RhdHVzKHN0cnVjdCByZWYgKnJlZiwgaW50IHBvcmNlbGFpbikKewoJaWYgKHJlZi0+ZGVsZXRpb24pCgkJcHJpbnRfcmVmX3N0YXR1cygnLScsICJbZGVsZXRlZF0iLCByZWYsIE5VTEwsIE5VTEwsIHBvcmNlbGFpbik7CgllbHNlIGlmIChpc19udWxsX3NoYTEocmVmLT5vbGRfc2hhMSkpCgkJcHJpbnRfcmVmX3N0YXR1cygnKicsCgkJCSghcHJlZml4Y21wKHJlZi0+bmFtZSwgInJlZnMvdGFncy8iKSA/ICJbbmV3IHRhZ10iIDoKCQkJIltuZXcgYnJhbmNoXSIpLAoJCQlyZWYsIHJlZi0+cGVlcl9yZWYsIE5VTEwsIHBvcmNlbGFpbik7CgllbHNlIHsKCQljaGFyIHF1aWNrcmVmWzg0XTsKCQljaGFyIHR5cGU7CgkJY29uc3QgY2hhciAqbXNnOwoKCQlzdHJjcHkocXVpY2tyZWYsIHN0YXR1c19hYmJyZXYocmVmLT5vbGRfc2hhMSkpOwoJCWlmIChyZWYtPm5vbmZhc3Rmb3J3YXJkKSB7CgkJCXN0cmNhdChxdWlja3JlZiwgIi4uLiIpOwoJCQl0eXBlID0gJysnOwoJCQltc2cgPSAiZm9yY2VkIHVwZGF0ZSI7CgkJfSBlbHNlIHsKCQkJc3RyY2F0KHF1aWNrcmVmLCAiLi4iKTsKCQkJdHlwZSA9ICcgJzsKCQkJbXNnID0gTlVMTDsKCQl9CgkJc3RyY2F0KHF1aWNrcmVmLCBzdGF0dXNfYWJicmV2KHJlZi0+bmV3X3NoYTEpKTsKCgkJcHJpbnRfcmVmX3N0YXR1cyh0eXBlLCBxdWlja3JlZiwgcmVmLCByZWYtPnBlZXJfcmVmLCBtc2csIHBvcmNlbGFpbik7Cgl9Cn0KCnN0YXRpYyBpbnQgcHJpbnRfb25lX3B1c2hfc3RhdHVzKHN0cnVjdCByZWYgKnJlZiwgY29uc3QgY2hhciAqZGVzdCwgaW50IGNvdW50LCBpbnQgcG9yY2VsYWluKQp7CglpZiAoIWNvdW50KQoJCWZwcmludGYocG9yY2VsYWluID8gc3Rkb3V0IDogc3RkZXJyLCAiVG8gJXNcbiIsIGRlc3QpOwoKCXN3aXRjaChyZWYtPnN0YXR1cykgewoJY2FzZSBSRUZfU1RBVFVTX05PTkU6CgkJcHJpbnRfcmVmX3N0YXR1cygnWCcsICJbbm8gbWF0Y2hdIiwgcmVmLCBOVUxMLCBOVUxMLCBwb3JjZWxhaW4pOwoJCWJyZWFrOwoJY2FzZSBSRUZfU1RBVFVTX1JFSkVDVF9OT0RFTEVURToKCQlwcmludF9yZWZfc3RhdHVzKCchJywgIltyZWplY3RlZF0iLCByZWYsIE5VTEwsCgkJCQkJCSAicmVtb3RlIGRvZXMgbm90IHN1cHBvcnQgZGVsZXRpbmcgcmVmcyIsIHBvcmNlbGFpbik7CgkJYnJlYWs7CgljYXNlIFJFRl9TVEFUVVNfVVBUT0RBVEU6CgkJcHJpbnRfcmVmX3N0YXR1cygnPScsICJbdXAgdG8gZGF0ZV0iLCByZWYsCgkJCQkJCSByZWYtPnBlZXJfcmVmLCBOVUxMLCBwb3JjZWxhaW4pOwoJCWJyZWFrOwoJY2FzZSBSRUZfU1RBVFVTX1JFSkVDVF9OT05GQVNURk9SV0FSRDoKCQlwcmludF9yZWZfc3RhdHVzKCchJywgIltyZWplY3RlZF0iLCByZWYsIHJlZi0+cGVlcl9yZWYsCgkJCQkJCSAibm9uLWZhc3QtZm9yd2FyZCIsIHBvcmNlbGFpbik7CgkJYnJlYWs7CgljYXNlIFJFRl9TVEFUVVNfUkVNT1RFX1JFSkVDVDoKCQlwcmludF9yZWZfc3RhdHVzKCchJywgIltyZW1vdGUgcmVqZWN0ZWRdIiwgcmVmLAoJCQkJCQkgcmVmLT5kZWxldGlvbiA/IE5VTEwgOiByZWYtPnBlZXJfcmVmLAoJCQkJCQkgcmVmLT5yZW1vdGVfc3RhdHVzLCBwb3JjZWxhaW4pOwoJCWJyZWFrOwoJY2FzZSBSRUZfU1RBVFVTX0VYUEVDVElOR19SRVBPUlQ6CgkJcHJpbnRfcmVmX3N0YXR1cygnIScsICJbcmVtb3RlIGZhaWx1cmVdIiwgcmVmLAoJCQkJCQkgcmVmLT5kZWxldGlvbiA/IE5VTEwgOiByZWYtPnBlZXJfcmVmLAoJCQkJCQkgInJlbW90ZSBmYWlsZWQgdG8gcmVwb3J0IHN0YXR1cyIsIHBvcmNlbGFpbik7CgkJYnJlYWs7CgljYXNlIFJFRl9TVEFUVVNfT0s6CgkJcHJpbnRfb2tfcmVmX3N0YXR1cyhyZWYsIHBvcmNlbGFpbik7CgkJYnJlYWs7Cgl9CgoJcmV0dXJuIDE7Cn0KCnZvaWQgdHJhbnNwb3J0X3ByaW50X3B1c2hfc3RhdHVzKGNvbnN0IGNoYXIgKmRlc3QsIHN0cnVjdCByZWYgKnJlZnMsCgkJCQkgIGludCB2ZXJib3NlLCBpbnQgcG9yY2VsYWluLCBpbnQgKm5vbmZhc3Rmb3J3YXJkKQp7CglzdHJ1Y3QgcmVmICpyZWY7CglpbnQgbiA9IDA7CgoJaWYgKHZlcmJvc2UpIHsKCQlmb3IgKHJlZiA9IHJlZnM7IHJlZjsgcmVmID0gcmVmLT5uZXh0KQoJCQlpZiAocmVmLT5zdGF0dXMgPT0gUkVGX1NUQVRVU19VUFRPREFURSkKCQkJCW4gKz0gcHJpbnRfb25lX3B1c2hfc3RhdHVzKHJlZiwgZGVzdCwgbiwgcG9yY2VsYWluKTsKCX0KCglmb3IgKHJlZiA9IHJlZnM7IHJlZjsgcmVmID0gcmVmLT5uZXh0KQoJCWlmIChyZWYtPnN0YXR1cyA9PSBSRUZfU1RBVFVTX09LKQoJCQluICs9IHByaW50X29uZV9wdXNoX3N0YXR1cyhyZWYsIGRlc3QsIG4sIHBvcmNlbGFpbik7CgoJKm5vbmZhc3Rmb3J3YXJkID0gMDsKCWZvciAocmVmID0gcmVmczsgcmVmOyByZWYgPSByZWYtPm5leHQpIHsKCQlpZiAocmVmLT5zdGF0dXMgIT0gUkVGX1NUQVRVU19OT05FICYmCgkJICAgIHJlZi0+c3RhdHVzICE9IFJFRl9TVEFUVVNfVVBUT0RBVEUgJiYKCQkgICAgcmVmLT5zdGF0dXMgIT0gUkVGX1NUQVRVU19PSykKCQkJbiArPSBwcmludF9vbmVfcHVzaF9zdGF0dXMocmVmLCBkZXN0LCBuLCBwb3JjZWxhaW4pOwoJCWlmIChyZWYtPnN0YXR1cyA9PSBSRUZfU1RBVFVTX1JFSkVDVF9OT05GQVNURk9SV0FSRCkKCQkJKm5vbmZhc3Rmb3J3YXJkID0gMTsKCX0KfQoKdm9pZCB0cmFuc3BvcnRfdmVyaWZ5X3JlbW90ZV9uYW1lcyhpbnQgbnJfaGVhZHMsIGNvbnN0IGNoYXIgKipoZWFkcykKewoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IG5yX2hlYWRzOyBpKyspIHsKCQljb25zdCBjaGFyICpsb2NhbCA9IGhlYWRzW2ldOwoJCWNvbnN0IGNoYXIgKnJlbW90ZSA9IHN0cnJjaHIoaGVhZHNbaV0sICc6Jyk7CgoJCWlmICgqbG9jYWwgPT0gJysnKQoJCQlsb2NhbCsrOwoKCQkvKiBBIG1hdGNoaW5nIHJlZnNwZWMgaXMgb2theS4gICovCgkJaWYgKHJlbW90ZSA9PSBsb2NhbCAmJiByZW1vdGVbMV0gPT0gJ1wwJykKCQkJY29udGludWU7CgoJCXJlbW90ZSA9IHJlbW90ZSA/IChyZW1vdGUgKyAxKSA6IGxvY2FsOwoJCXN3aXRjaCAoY2hlY2tfcmVmX2Zvcm1hdChyZW1vdGUpKSB7CgkJY2FzZSAwOiAvKiBvayAqLwoJCWNhc2UgQ0hFQ0tfUkVGX0ZPUk1BVF9PTkVMRVZFTDoKCQkJLyogb2sgYnV0IGEgc2luZ2xlIGxldmVsIC0tIHRoYXQgaXMgZmluZSBmb3IKCQkJICogYSBtYXRjaCBwYXR0ZXJuLgoJCQkgKi8KCQljYXNlIENIRUNLX1JFRl9GT1JNQVRfV0lMRENBUkQ6CgkJCS8qIG9rIGJ1dCBlbmRzIHdpdGggYSBwYXR0ZXJuLW1hdGNoIGNoYXJhY3RlciAqLwoJCQljb250aW51ZTsKCQl9CgkJZGllKCJyZW1vdGUgcGFydCBvZiByZWZzcGVjIGlzIG5vdCBhIHZhbGlkIG5hbWUgaW4gJXMiLAoJCSAgICBoZWFkc1tpXSk7Cgl9Cn0KCnN0YXRpYyBpbnQgZ2l0X3RyYW5zcG9ydF9wdXNoKHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCwgc3RydWN0IHJlZiAqcmVtb3RlX3JlZnMsIGludCBmbGFncykKewoJc3RydWN0IGdpdF90cmFuc3BvcnRfZGF0YSAqZGF0YSA9IHRyYW5zcG9ydC0+ZGF0YTsKCXN0cnVjdCBzZW5kX3BhY2tfYXJncyBhcmdzOwoJaW50IHJldDsKCglpZiAoIWRhdGEtPmdvdF9yZW1vdGVfaGVhZHMpIHsKCQlzdHJ1Y3QgcmVmICp0bXBfcmVmczsKCQljb25uZWN0X3NldHVwKHRyYW5zcG9ydCwgMSwgMCk7CgoJCWdldF9yZW1vdGVfaGVhZHMoZGF0YS0+ZmRbMF0sICZ0bXBfcmVmcywgMCwgTlVMTCwgUkVGX05PUk1BTCwKCQkJCSBOVUxMKTsKCQlkYXRhLT5nb3RfcmVtb3RlX2hlYWRzID0gMTsKCX0KCgltZW1zZXQoJmFyZ3MsIDAsIHNpemVvZihhcmdzKSk7CglhcmdzLnNlbmRfbWlycm9yID0gISEoZmxhZ3MgJiBUUkFOU1BPUlRfUFVTSF9NSVJST1IpOwoJYXJncy5mb3JjZV91cGRhdGUgPSAhIShmbGFncyAmIFRSQU5TUE9SVF9QVVNIX0ZPUkNFKTsKCWFyZ3MudXNlX3RoaW5fcGFjayA9IGRhdGEtPm9wdGlvbnMudGhpbjsKCWFyZ3MudmVyYm9zZSA9ICh0cmFuc3BvcnQtPnZlcmJvc2UgPiAwKTsKCWFyZ3MucXVpZXQgPSAodHJhbnNwb3J0LT52ZXJib3NlIDwgMCk7CglhcmdzLnByb2dyZXNzID0gdHJhbnNwb3J0LT5wcm9ncmVzczsKCWFyZ3MuZHJ5X3J1biA9ICEhKGZsYWdzICYgVFJBTlNQT1JUX1BVU0hfRFJZX1JVTik7CglhcmdzLnBvcmNlbGFpbiA9ICEhKGZsYWdzICYgVFJBTlNQT1JUX1BVU0hfUE9SQ0VMQUlOKTsKCglyZXQgPSBzZW5kX3BhY2soJmFyZ3MsIGRhdGEtPmZkLCBkYXRhLT5jb25uLCByZW1vdGVfcmVmcywKCQkJJmRhdGEtPmV4dHJhX2hhdmUpOwoKCWNsb3NlKGRhdGEtPmZkWzFdKTsKCWNsb3NlKGRhdGEtPmZkWzBdKTsKCXJldCB8PSBmaW5pc2hfY29ubmVjdChkYXRhLT5jb25uKTsKCWRhdGEtPmNvbm4gPSBOVUxMOwoJZGF0YS0+Z290X3JlbW90ZV9oZWFkcyA9IDA7CgoJcmV0dXJuIHJldDsKfQoKc3RhdGljIGludCBjb25uZWN0X2dpdChzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsIGNvbnN0IGNoYXIgKm5hbWUsCgkJICAgICAgIGNvbnN0IGNoYXIgKmV4ZWN1dGFibGUsIGludCBmZFsyXSkKewoJc3RydWN0IGdpdF90cmFuc3BvcnRfZGF0YSAqZGF0YSA9IHRyYW5zcG9ydC0+ZGF0YTsKCWRhdGEtPmNvbm4gPSBnaXRfY29ubmVjdChkYXRhLT5mZCwgdHJhbnNwb3J0LT51cmwsCgkJCQkgZXhlY3V0YWJsZSwgMCk7CglmZFswXSA9IGRhdGEtPmZkWzBdOwoJZmRbMV0gPSBkYXRhLT5mZFsxXTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGRpc2Nvbm5lY3RfZ2l0KHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCkKewoJc3RydWN0IGdpdF90cmFuc3BvcnRfZGF0YSAqZGF0YSA9IHRyYW5zcG9ydC0+ZGF0YTsKCWlmIChkYXRhLT5jb25uKSB7CgkJaWYgKGRhdGEtPmdvdF9yZW1vdGVfaGVhZHMpCgkJCXBhY2tldF9mbHVzaChkYXRhLT5mZFsxXSk7CgkJY2xvc2UoZGF0YS0+ZmRbMF0pOwoJCWNsb3NlKGRhdGEtPmZkWzFdKTsKCQlmaW5pc2hfY29ubmVjdChkYXRhLT5jb25uKTsKCX0KCglmcmVlKGRhdGEpOwoJcmV0dXJuIDA7Cn0KCnZvaWQgdHJhbnNwb3J0X3Rha2Vfb3ZlcihzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsCgkJCSBzdHJ1Y3QgY2hpbGRfcHJvY2VzcyAqY2hpbGQpCnsKCXN0cnVjdCBnaXRfdHJhbnNwb3J0X2RhdGEgKmRhdGE7CgoJaWYgKCF0cmFuc3BvcnQtPnNtYXJ0X29wdGlvbnMpCgkJZGllKCJCdWcgZGV0ZWN0ZWQ6IFRha2luZyBvdmVyIHRyYW5zcG9ydCByZXF1aXJlcyBub24tTlVMTCAiCgkJICAgICJzbWFydF9vcHRpb25zIGZpZWxkLiIpOwoKCWRhdGEgPSB4Y2FsbG9jKDEsIHNpemVvZigqZGF0YSkpOwoJZGF0YS0+b3B0aW9ucyA9ICp0cmFuc3BvcnQtPnNtYXJ0X29wdGlvbnM7CglkYXRhLT5jb25uID0gY2hpbGQ7CglkYXRhLT5mZFswXSA9IGRhdGEtPmNvbm4tPm91dDsKCWRhdGEtPmZkWzFdID0gZGF0YS0+Y29ubi0+aW47CglkYXRhLT5nb3RfcmVtb3RlX2hlYWRzID0gMDsKCXRyYW5zcG9ydC0+ZGF0YSA9IGRhdGE7CgoJdHJhbnNwb3J0LT5zZXRfb3B0aW9uID0gTlVMTDsKCXRyYW5zcG9ydC0+Z2V0X3JlZnNfbGlzdCA9IGdldF9yZWZzX3ZpYV9jb25uZWN0OwoJdHJhbnNwb3J0LT5mZXRjaCA9IGZldGNoX3JlZnNfdmlhX3BhY2s7Cgl0cmFuc3BvcnQtPnB1c2ggPSBOVUxMOwoJdHJhbnNwb3J0LT5wdXNoX3JlZnMgPSBnaXRfdHJhbnNwb3J0X3B1c2g7Cgl0cmFuc3BvcnQtPmRpc2Nvbm5lY3QgPSBkaXNjb25uZWN0X2dpdDsKCXRyYW5zcG9ydC0+c21hcnRfb3B0aW9ucyA9ICYoZGF0YS0+b3B0aW9ucyk7Cn0KCnN0YXRpYyBpbnQgaXNfbG9jYWwoY29uc3QgY2hhciAqdXJsKQp7Cgljb25zdCBjaGFyICpjb2xvbiA9IHN0cmNocih1cmwsICc6Jyk7Cgljb25zdCBjaGFyICpzbGFzaCA9IHN0cmNocih1cmwsICcvJyk7CglyZXR1cm4gIWNvbG9uIHx8IChzbGFzaCAmJiBzbGFzaCA8IGNvbG9uKSB8fAoJCWhhc19kb3NfZHJpdmVfcHJlZml4KHVybCk7Cn0KCnN0YXRpYyBpbnQgaXNfZmlsZShjb25zdCBjaGFyICp1cmwpCnsKCXN0cnVjdCBzdGF0IGJ1ZjsKCWlmIChzdGF0KHVybCwgJmJ1ZikpCgkJcmV0dXJuIDA7CglyZXR1cm4gU19JU1JFRyhidWYuc3RfbW9kZSk7Cn0KCnN0YXRpYyBpbnQgZXh0ZXJuYWxfc3BlY2lmaWNhdGlvbl9sZW4oY29uc3QgY2hhciAqdXJsKQp7CglyZXR1cm4gc3RyY2hyKHVybCwgJzonKSAtIHVybDsKfQoKc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0X2dldChzdHJ1Y3QgcmVtb3RlICpyZW1vdGUsIGNvbnN0IGNoYXIgKnVybCkKewoJY29uc3QgY2hhciAqaGVscGVyOwoJc3RydWN0IHRyYW5zcG9ydCAqcmV0ID0geGNhbGxvYygxLCBzaXplb2YoKnJldCkpOwoKCXJldC0+cHJvZ3Jlc3MgPSBpc2F0dHkoMik7CgoJaWYgKCFyZW1vdGUpCgkJZGllKCJObyByZW1vdGUgcHJvdmlkZWQgdG8gdHJhbnNwb3J0X2dldCgpIik7CgoJcmV0LT5nb3RfcmVtb3RlX3JlZnMgPSAwOwoJcmV0LT5yZW1vdGUgPSByZW1vdGU7CgloZWxwZXIgPSByZW1vdGUtPmZvcmVpZ25fdmNzOwoKCWlmICghdXJsICYmIHJlbW90ZS0+dXJsKQoJCXVybCA9IHJlbW90ZS0+dXJsWzBdOwoJcmV0LT51cmwgPSB1cmw7CgoJLyogbWF5YmUgaXQgaXMgYSBmb3JlaWduIFVSTD8gKi8KCWlmICh1cmwpIHsKCQljb25zdCBjaGFyICpwID0gdXJsOwoKCQl3aGlsZSAoaXNfdXJsc2NoZW1lY2hhcihwID09IHVybCwgKnApKQoJCQlwKys7CgkJaWYgKCFwcmVmaXhjbXAocCwgIjo6IikpCgkJCWhlbHBlciA9IHhzdHJuZHVwKHVybCwgcCAtIHVybCk7Cgl9CgoJaWYgKGhlbHBlcikgewoJCXRyYW5zcG9ydF9oZWxwZXJfaW5pdChyZXQsIGhlbHBlcik7Cgl9IGVsc2UgaWYgKCFwcmVmaXhjbXAodXJsLCAicnN5bmM6IikpIHsKCQlyZXQtPmdldF9yZWZzX2xpc3QgPSBnZXRfcmVmc192aWFfcnN5bmM7CgkJcmV0LT5mZXRjaCA9IGZldGNoX29ianNfdmlhX3JzeW5jOwoJCXJldC0+cHVzaCA9IHJzeW5jX3RyYW5zcG9ydF9wdXNoOwoJCXJldC0+c21hcnRfb3B0aW9ucyA9IE5VTEw7Cgl9IGVsc2UgaWYgKGlzX2xvY2FsKHVybCkgJiYgaXNfZmlsZSh1cmwpKSB7CgkJc3RydWN0IGJ1bmRsZV90cmFuc3BvcnRfZGF0YSAqZGF0YSA9IHhjYWxsb2MoMSwgc2l6ZW9mKCpkYXRhKSk7CgkJcmV0LT5kYXRhID0gZGF0YTsKCQlyZXQtPmdldF9yZWZzX2xpc3QgPSBnZXRfcmVmc19mcm9tX2J1bmRsZTsKCQlyZXQtPmZldGNoID0gZmV0Y2hfcmVmc19mcm9tX2J1bmRsZTsKCQlyZXQtPmRpc2Nvbm5lY3QgPSBjbG9zZV9idW5kbGU7CgkJcmV0LT5zbWFydF9vcHRpb25zID0gTlVMTDsKCX0gZWxzZSBpZiAoIWlzX3VybCh1cmwpCgkJfHwgIXByZWZpeGNtcCh1cmwsICJmaWxlOi8vIikKCQl8fCAhcHJlZml4Y21wKHVybCwgImdpdDovLyIpCgkJfHwgIXByZWZpeGNtcCh1cmwsICJzc2g6Ly8iKQoJCXx8ICFwcmVmaXhjbXAodXJsLCAiZ2l0K3NzaDovLyIpCgkJfHwgIXByZWZpeGNtcCh1cmwsICJzc2grZ2l0Oi8vIikpIHsKCQkvKiBUaGVzZSBhcmUgYnVpbHRpbiBzbWFydCB0cmFuc3BvcnRzLiAqLwoJCXN0cnVjdCBnaXRfdHJhbnNwb3J0X2RhdGEgKmRhdGEgPSB4Y2FsbG9jKDEsIHNpemVvZigqZGF0YSkpOwoJCXJldC0+ZGF0YSA9IGRhdGE7CgkJcmV0LT5zZXRfb3B0aW9uID0gTlVMTDsKCQlyZXQtPmdldF9yZWZzX2xpc3QgPSBnZXRfcmVmc192aWFfY29ubmVjdDsKCQlyZXQtPmZldGNoID0gZmV0Y2hfcmVmc192aWFfcGFjazsKCQlyZXQtPnB1c2hfcmVmcyA9IGdpdF90cmFuc3BvcnRfcHVzaDsKCQlyZXQtPmNvbm5lY3QgPSBjb25uZWN0X2dpdDsKCQlyZXQtPmRpc2Nvbm5lY3QgPSBkaXNjb25uZWN0X2dpdDsKCQlyZXQtPnNtYXJ0X29wdGlvbnMgPSAmKGRhdGEtPm9wdGlvbnMpOwoKCQlkYXRhLT5jb25uID0gTlVMTDsKCQlkYXRhLT5nb3RfcmVtb3RlX2hlYWRzID0gMDsKCX0gZWxzZSB7CgkJLyogVW5rbm93biBwcm90b2NvbCBpbiBVUkwuIFBhc3MgdG8gZXh0ZXJuYWwgaGFuZGxlci4gKi8KCQlpbnQgbGVuID0gZXh0ZXJuYWxfc3BlY2lmaWNhdGlvbl9sZW4odXJsKTsKCQljaGFyICpoYW5kbGVyID0geG1hbGxvYyhsZW4gKyAxKTsKCQloYW5kbGVyW2xlbl0gPSAwOwoJCXN0cm5jcHkoaGFuZGxlciwgdXJsLCBsZW4pOwoJCXRyYW5zcG9ydF9oZWxwZXJfaW5pdChyZXQsIGhhbmRsZXIpOwoJfQoKCWlmIChyZXQtPnNtYXJ0X29wdGlvbnMpIHsKCQlyZXQtPnNtYXJ0X29wdGlvbnMtPnRoaW4gPSAxOwoJCXJldC0+c21hcnRfb3B0aW9ucy0+dXBsb2FkcGFjayA9ICJnaXQtdXBsb2FkLXBhY2siOwoJCWlmIChyZW1vdGUtPnVwbG9hZHBhY2spCgkJCXJldC0+c21hcnRfb3B0aW9ucy0+dXBsb2FkcGFjayA9IHJlbW90ZS0+dXBsb2FkcGFjazsKCQlyZXQtPnNtYXJ0X29wdGlvbnMtPnJlY2VpdmVwYWNrID0gImdpdC1yZWNlaXZlLXBhY2siOwoJCWlmIChyZW1vdGUtPnJlY2VpdmVwYWNrKQoJCQlyZXQtPnNtYXJ0X29wdGlvbnMtPnJlY2VpdmVwYWNrID0gcmVtb3RlLT5yZWNlaXZlcGFjazsKCX0KCglyZXR1cm4gcmV0Owp9CgppbnQgdHJhbnNwb3J0X3NldF9vcHRpb24oc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0LAoJCQkgY29uc3QgY2hhciAqbmFtZSwgY29uc3QgY2hhciAqdmFsdWUpCnsKCWludCBnaXRfcmVwb3J0cyA9IDEsIHByb3RvY29sX3JlcG9ydHMgPSAxOwoKCWlmICh0cmFuc3BvcnQtPnNtYXJ0X29wdGlvbnMpCgkJZ2l0X3JlcG9ydHMgPSBzZXRfZ2l0X29wdGlvbih0cmFuc3BvcnQtPnNtYXJ0X29wdGlvbnMsCgkJCQkJICAgICBuYW1lLCB2YWx1ZSk7CgoJaWYgKHRyYW5zcG9ydC0+c2V0X29wdGlvbikKCQlwcm90b2NvbF9yZXBvcnRzID0gdHJhbnNwb3J0LT5zZXRfb3B0aW9uKHRyYW5zcG9ydCwgbmFtZSwKCQkJCQkJCXZhbHVlKTsKCgkvKiBJZiBlaXRoZXIgcmVwb3J0IGlzIDAsIHJlcG9ydCAwIChzdWNjZXNzKS4gKi8KCWlmICghZ2l0X3JlcG9ydHMgfHwgIXByb3RvY29sX3JlcG9ydHMpCgkJcmV0dXJuIDA7CgkvKiBJZiBlaXRoZXIgcmVwb3J0cyAtMSAoaW52YWxpZCB2YWx1ZSksIHJlcG9ydCAtMS4gKi8KCWlmICgoZ2l0X3JlcG9ydHMgPT0gLTEpIHx8IChwcm90b2NvbF9yZXBvcnRzID09IC0xKSkKCQlyZXR1cm4gLTE7CgkvKiBPdGhlcndpc2UgaWYgYm90aCByZXBvcnQgdW5rbm93biwgcmVwb3J0IHVua25vd24uICovCglyZXR1cm4gMTsKfQoKdm9pZCB0cmFuc3BvcnRfc2V0X3ZlcmJvc2l0eShzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsIGludCB2ZXJib3NpdHksCglpbnQgZm9yY2VfcHJvZ3Jlc3MpCnsKCWlmICh2ZXJib3NpdHkgPj0gMikKCQl0cmFuc3BvcnQtPnZlcmJvc2UgPSB2ZXJib3NpdHkgPD0gMyA/IHZlcmJvc2l0eSA6IDM7CglpZiAodmVyYm9zaXR5IDwgMCkKCQl0cmFuc3BvcnQtPnZlcmJvc2UgPSAtMTsKCgkvKioKCSAqIFJ1bGVzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVwb3J0IHByb2dyZXNzIChwcm9jZXNzaW5nIGFib3J0cwoJICogd2hlbiBhIHJ1bGUgaXMgc2F0aXNmaWVkKToKCSAqCgkgKiAgIDEuIFJlcG9ydCBwcm9ncmVzcywgaWYgZm9yY2VfcHJvZ3Jlc3MgaXMgMSAoaWUuIC0tcHJvZ3Jlc3MpLgoJICogICAyLiBEb24ndCByZXBvcnQgcHJvZ3Jlc3MsIGlmIHZlcmJvc2l0eSA8IDAgKGllLiAtcS8tLXF1aWV0ICkuCgkgKiAgIDMuIFJlcG9ydCBwcm9ncmVzcyBpZiBpc2F0dHkoMikgaXMgMS4KCSAqKi8KCXRyYW5zcG9ydC0+cHJvZ3Jlc3MgPSBmb3JjZV9wcm9ncmVzcyB8fCAodmVyYm9zaXR5ID49IDAgJiYgaXNhdHR5KDIpKTsKfQoKaW50IHRyYW5zcG9ydF9wdXNoKHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCwKCQkgICBpbnQgcmVmc3BlY19uciwgY29uc3QgY2hhciAqKnJlZnNwZWMsIGludCBmbGFncywKCQkgICBpbnQgKm5vbmZhc3Rmb3J3YXJkKQp7Cgkqbm9uZmFzdGZvcndhcmQgPSAwOwoJdHJhbnNwb3J0X3ZlcmlmeV9yZW1vdGVfbmFtZXMocmVmc3BlY19uciwgcmVmc3BlYyk7CgoJaWYgKHRyYW5zcG9ydC0+cHVzaCkgewoJCS8qIE1heWJlIEZJWE1FLiBCdXQgbm8gaW1wb3J0YW50IHRyYW5zcG9ydCB1c2VzIHRoaXMgY2FzZS4gKi8KCQlpZiAoZmxhZ3MgJiBUUkFOU1BPUlRfUFVTSF9TRVRfVVBTVFJFQU0pCgkJCWRpZSgiVGhpcyB0cmFuc3BvcnQgZG9lcyBub3Qgc3VwcG9ydCB1c2luZyAtLXNldC11cHN0cmVhbSIpOwoKCQlyZXR1cm4gdHJhbnNwb3J0LT5wdXNoKHRyYW5zcG9ydCwgcmVmc3BlY19uciwgcmVmc3BlYywgZmxhZ3MpOwoJfSBlbHNlIGlmICh0cmFuc3BvcnQtPnB1c2hfcmVmcykgewoJCXN0cnVjdCByZWYgKnJlbW90ZV9yZWZzID0KCQkJdHJhbnNwb3J0LT5nZXRfcmVmc19saXN0KHRyYW5zcG9ydCwgMSk7CgkJc3RydWN0IHJlZiAqbG9jYWxfcmVmcyA9IGdldF9sb2NhbF9oZWFkcygpOwoJCWludCBtYXRjaF9mbGFncyA9IE1BVENIX1JFRlNfTk9ORTsKCQlpbnQgdmVyYm9zZSA9ICh0cmFuc3BvcnQtPnZlcmJvc2UgPiAwKTsKCQlpbnQgcXVpZXQgPSAodHJhbnNwb3J0LT52ZXJib3NlIDwgMCk7CgkJaW50IHBvcmNlbGFpbiA9IGZsYWdzICYgVFJBTlNQT1JUX1BVU0hfUE9SQ0VMQUlOOwoJCWludCBwcmV0ZW5kID0gZmxhZ3MgJiBUUkFOU1BPUlRfUFVTSF9EUllfUlVOOwoJCWludCBwdXNoX3JldCwgcmV0LCBlcnI7CgoJCWlmIChmbGFncyAmIFRSQU5TUE9SVF9QVVNIX0FMTCkKCQkJbWF0Y2hfZmxhZ3MgfD0gTUFUQ0hfUkVGU19BTEw7CgkJaWYgKGZsYWdzICYgVFJBTlNQT1JUX1BVU0hfTUlSUk9SKQoJCQltYXRjaF9mbGFncyB8PSBNQVRDSF9SRUZTX01JUlJPUjsKCgkJaWYgKG1hdGNoX3JlZnMobG9jYWxfcmVmcywgJnJlbW90ZV9yZWZzLAoJCQkgICAgICAgcmVmc3BlY19uciwgcmVmc3BlYywgbWF0Y2hfZmxhZ3MpKSB7CgkJCXJldHVybiAtMTsKCQl9CgoJCXNldF9yZWZfc3RhdHVzX2Zvcl9wdXNoKHJlbW90ZV9yZWZzLAoJCQlmbGFncyAmIFRSQU5TUE9SVF9QVVNIX01JUlJPUiwKCQkJZmxhZ3MgJiBUUkFOU1BPUlRfUFVTSF9GT1JDRSk7CgoJCXB1c2hfcmV0ID0gdHJhbnNwb3J0LT5wdXNoX3JlZnModHJhbnNwb3J0LCByZW1vdGVfcmVmcywgZmxhZ3MpOwoJCWVyciA9IHB1c2hfaGFkX2Vycm9ycyhyZW1vdGVfcmVmcyk7CgkJcmV0ID0gcHVzaF9yZXQgfCBlcnI7CgoJCWlmICghcXVpZXQgfHwgZXJyKQoJCQl0cmFuc3BvcnRfcHJpbnRfcHVzaF9zdGF0dXModHJhbnNwb3J0LT51cmwsIHJlbW90ZV9yZWZzLAoJCQkJCXZlcmJvc2UgfCBwb3JjZWxhaW4sIHBvcmNlbGFpbiwKCQkJCQlub25mYXN0Zm9yd2FyZCk7CgoJCWlmIChmbGFncyAmIFRSQU5TUE9SVF9QVVNIX1NFVF9VUFNUUkVBTSkKCQkJc2V0X3Vwc3RyZWFtcyh0cmFuc3BvcnQsIHJlbW90ZV9yZWZzLCBwcmV0ZW5kKTsKCgkJaWYgKCEoZmxhZ3MgJiBUUkFOU1BPUlRfUFVTSF9EUllfUlVOKSkgewoJCQlzdHJ1Y3QgcmVmICpyZWY7CgkJCWZvciAocmVmID0gcmVtb3RlX3JlZnM7IHJlZjsgcmVmID0gcmVmLT5uZXh0KQoJCQkJdHJhbnNwb3J0X3VwZGF0ZV90cmFja2luZ19yZWYodHJhbnNwb3J0LT5yZW1vdGUsIHJlZiwgdmVyYm9zZSk7CgkJfQoKCQlpZiAocG9yY2VsYWluICYmICFwdXNoX3JldCkKCQkJcHV0cygiRG9uZSIpOwoJCWVsc2UgaWYgKCFxdWlldCAmJiAhcmV0ICYmICF0cmFuc3BvcnRfcmVmc19wdXNoZWQocmVtb3RlX3JlZnMpKQoJCQlmcHJpbnRmKHN0ZGVyciwgIkV2ZXJ5dGhpbmcgdXAtdG8tZGF0ZVxuIik7CgoJCXJldHVybiByZXQ7Cgl9CglyZXR1cm4gMTsKfQoKY29uc3Qgc3RydWN0IHJlZiAqdHJhbnNwb3J0X2dldF9yZW1vdGVfcmVmcyhzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQpCnsKCWlmICghdHJhbnNwb3J0LT5nb3RfcmVtb3RlX3JlZnMpIHsKCQl0cmFuc3BvcnQtPnJlbW90ZV9yZWZzID0gdHJhbnNwb3J0LT5nZXRfcmVmc19saXN0KHRyYW5zcG9ydCwgMCk7CgkJdHJhbnNwb3J0LT5nb3RfcmVtb3RlX3JlZnMgPSAxOwoJfQoKCXJldHVybiB0cmFuc3BvcnQtPnJlbW90ZV9yZWZzOwp9CgppbnQgdHJhbnNwb3J0X2ZldGNoX3JlZnMoc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0LCBzdHJ1Y3QgcmVmICpyZWZzKQp7CglpbnQgcmM7CglpbnQgbnJfaGVhZHMgPSAwLCBucl9hbGxvYyA9IDAsIG5yX3JlZnMgPSAwOwoJc3RydWN0IHJlZiAqKmhlYWRzID0gTlVMTDsKCXN0cnVjdCByZWYgKnJtOwoKCWZvciAocm0gPSByZWZzOyBybTsgcm0gPSBybS0+bmV4dCkgewoJCW5yX3JlZnMrKzsKCQlpZiAocm0tPnBlZXJfcmVmICYmCgkJICAgICFpc19udWxsX3NoYTEocm0tPm9sZF9zaGExKSAmJgoJCSAgICAhaGFzaGNtcChybS0+cGVlcl9yZWYtPm9sZF9zaGExLCBybS0+b2xkX3NoYTEpKQoJCQljb250aW51ZTsKCQlBTExPQ19HUk9XKGhlYWRzLCBucl9oZWFkcyArIDEsIG5yX2FsbG9jKTsKCQloZWFkc1tucl9oZWFkcysrXSA9IHJtOwoJfQoKCWlmICghbnJfaGVhZHMpIHsKCQkvKgoJCSAqIFdoZW4gZGVlcGVuaW5nIG9mIGEgc2hhbGxvdyByZXBvc2l0b3J5IGlzIHJlcXVlc3RlZCwKCQkgKiB0aGVuIGxvY2FsIGFuZCByZW1vdGUgcmVmcyBhcmUgbGlrZWx5IHRvIHN0aWxsIGJlIGVxdWFsLgoJCSAqIEp1c3QgZmVlZCB0aGVtIGFsbCB0byB0aGUgZmV0Y2ggbWV0aG9kIGluIHRoYXQgY2FzZS4KCQkgKiBUaGlzIGNvbmRpdGlvbiBzaG91bGRuJ3QgYmUgbWV0IGluIGEgbm9uLWRlZXBlbmluZyBmZXRjaAoJCSAqIChzZWUgYnVpbHRpbi1mZXRjaC5jOnF1aWNrZmV0Y2goKSkuCgkJICovCgkJaGVhZHMgPSB4bWFsbG9jKG5yX3JlZnMgKiBzaXplb2YoKmhlYWRzKSk7CgkJZm9yIChybSA9IHJlZnM7IHJtOyBybSA9IHJtLT5uZXh0KQoJCQloZWFkc1tucl9oZWFkcysrXSA9IHJtOwoJfQoKCXJjID0gdHJhbnNwb3J0LT5mZXRjaCh0cmFuc3BvcnQsIG5yX2hlYWRzLCBoZWFkcyk7CgoJZnJlZShoZWFkcyk7CglyZXR1cm4gcmM7Cn0KCnZvaWQgdHJhbnNwb3J0X3VubG9ja19wYWNrKHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCkKewoJaWYgKHRyYW5zcG9ydC0+cGFja19sb2NrZmlsZSkgewoJCXVubGlua19vcl93YXJuKHRyYW5zcG9ydC0+cGFja19sb2NrZmlsZSk7CgkJZnJlZSh0cmFuc3BvcnQtPnBhY2tfbG9ja2ZpbGUpOwoJCXRyYW5zcG9ydC0+cGFja19sb2NrZmlsZSA9IE5VTEw7Cgl9Cn0KCmludCB0cmFuc3BvcnRfY29ubmVjdChzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsIGNvbnN0IGNoYXIgKm5hbWUsCgkJICAgICAgY29uc3QgY2hhciAqZXhlYywgaW50IGZkWzJdKQp7CglpZiAodHJhbnNwb3J0LT5jb25uZWN0KQoJCXJldHVybiB0cmFuc3BvcnQtPmNvbm5lY3QodHJhbnNwb3J0LCBuYW1lLCBleGVjLCBmZCk7CgllbHNlCgkJZGllKCJPcGVyYXRpb24gbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbCIpOwp9CgppbnQgdHJhbnNwb3J0X2Rpc2Nvbm5lY3Qoc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0KQp7CglpbnQgcmV0ID0gMDsKCWlmICh0cmFuc3BvcnQtPmRpc2Nvbm5lY3QpCgkJcmV0ID0gdHJhbnNwb3J0LT5kaXNjb25uZWN0KHRyYW5zcG9ydCk7CglmcmVlKHRyYW5zcG9ydCk7CglyZXR1cm4gcmV0Owp9CgovKgogKiBTdHJpcCB1c2VybmFtZSAoYW5kIHBhc3N3b3JkKSBmcm9tIGFuIHVybCBhbmQgcmV0dXJuCiAqIGl0IGluIGEgbmV3bHkgYWxsb2NhdGVkIHN0cmluZy4KICovCmNoYXIgKnRyYW5zcG9ydF9hbm9ueW1pemVfdXJsKGNvbnN0IGNoYXIgKnVybCkKewoJY2hhciAqYW5vbl91cmwsICpzY2hlbWVfcHJlZml4LCAqYW5vbl9wYXJ0OwoJc2l6ZV90IGFub25fbGVuLCBwcmVmaXhfbGVuID0gMDsKCglhbm9uX3BhcnQgPSBzdHJjaHIodXJsLCAnQCcpOwoJaWYgKGlzX2xvY2FsKHVybCkgfHwgIWFub25fcGFydCkKCQlnb3RvIGxpdGVyYWxfY29weTsKCglhbm9uX2xlbiA9IHN0cmxlbigrK2Fub25fcGFydCk7CglzY2hlbWVfcHJlZml4ID0gc3Ryc3RyKHVybCwgIjovLyIpOwoJaWYgKCFzY2hlbWVfcHJlZml4KSB7CgkJaWYgKCFzdHJjaHIoYW5vbl9wYXJ0LCAnOicpKQoJCQkvKiBjYW5ub3QgYmUgIm1lQHRoZXJlOi9wYXRoL25hbWUiICovCgkJCWdvdG8gbGl0ZXJhbF9jb3B5OwoJfSBlbHNlIHsKCQljb25zdCBjaGFyICpjcDsKCQkvKiBtYWtlIHN1cmUgc2NoZW1lIGlzIHJlYXNvbmFibGUgKi8KCQlmb3IgKGNwID0gdXJsOyBjcCA8IHNjaGVtZV9wcmVmaXg7IGNwKyspIHsKCQkJc3dpdGNoICgqY3ApIHsKCQkJCS8qIFJGQyAxNzM4IDIuMSAqLwoJCQljYXNlICcrJzogY2FzZSAnLic6IGNhc2UgJy0nOgoJCQkJYnJlYWs7IC8qIG9rICovCgkJCWRlZmF1bHQ6CgkJCQlpZiAoaXNhbG51bSgqY3ApKQoJCQkJCWJyZWFrOwoJCQkJLyogaXQgaXNuJ3QgKi8KCQkJCWdvdG8gbGl0ZXJhbF9jb3B5OwoJCQl9CgkJfQoJCS8qIEAgcGFzdCB0aGUgZmlyc3Qgc2xhc2ggZG9lcyBub3QgY291bnQgKi8KCQljcCA9IHN0cmNocihzY2hlbWVfcHJlZml4ICsgMywgJy8nKTsKCQlpZiAoY3AgJiYgY3AgPCBhbm9uX3BhcnQpCgkJCWdvdG8gbGl0ZXJhbF9jb3B5OwoJCXByZWZpeF9sZW4gPSBzY2hlbWVfcHJlZml4IC0gdXJsICsgMzsKCX0KCWFub25fdXJsID0geGNhbGxvYygxLCAxICsgcHJlZml4X2xlbiArIGFub25fbGVuKTsKCW1lbWNweShhbm9uX3VybCwgdXJsLCBwcmVmaXhfbGVuKTsKCW1lbWNweShhbm9uX3VybCArIHByZWZpeF9sZW4sIGFub25fcGFydCwgYW5vbl9sZW4pOwoJcmV0dXJuIGFub25fdXJsOwpsaXRlcmFsX2NvcHk6CglyZXR1cm4geHN0cmR1cCh1cmwpOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"transport.h\"\n#include \"run-command.h\"\n#include \"pkt-line.h\"\n#include \"fetch-pack.h\"\n#include \"send-pack.h\"\n#include \"walker.h\"\n#include \"bundle.h\"\n#include \"dir.h\"\n#include \"refs.h\"\n#include \"branch.h\"\n#include \"url.h\"\n\n/* rsync support */\n\n/*\n * We copy packed-refs and refs/ into a temporary file, then read the\n * loose refs recursively (sorting whenever possible), and then inserting\n * those packed refs that are not yet in the list (not validating, but\n * assuming that the file is sorted).\n *\n * Appears refactoring this from refs.c is too cumbersome.\n */\n\nstatic int str_cmp(const void *a, const void *b)\n{\n\tconst char *s1 = a;\n\tconst char *s2 = b;\n\n\treturn strcmp(s1, s2);\n}\n\n/* path->buf + name_offset is expected to point to \"refs/\" */\n\nstatic int read_loose_refs(struct strbuf *path, int name_offset,\n\t\tstruct ref **tail)\n{\n\tDIR *dir = opendir(path->buf);\n\tstruct dirent *de;\n\tstruct {\n\t\tchar **entries;\n\t\tint nr, alloc;\n\t} list;\n\tint i, pathlen;\n\n\tif (!dir)\n\t\treturn -1;\n\n\tmemset (&list, 0, sizeof(list));\n\n\twhile ((de = readdir(dir))) {\n\t\tif (is_dot_or_dotdot(de->d_name))\n\t\t\tcontinue;\n\t\tALLOC_GROW(list.entries, list.nr + 1, list.alloc);\n\t\tlist.entries[list.nr++] = xstrdup(de->d_name);\n\t}\n\tclosedir(dir);\n\n\t/* sort the list */\n\n\tqsort(list.entries, list.nr, sizeof(char *), str_cmp);\n\n\tpathlen = path->len;\n\tstrbuf_addch(path, '/');\n\n\tfor (i = 0; i < list.nr; i++, strbuf_setlen(path, pathlen + 1)) {\n\t\tstrbuf_addstr(path, list.entries[i]);\n\t\tif (read_loose_refs(path, name_offset, tail)) {\n\t\t\tint fd = open(path->buf, O_RDONLY);\n\t\t\tchar buffer[40];\n\t\t\tstruct ref *next;\n\n\t\t\tif (fd < 0)\n\t\t\t\tcontinue;\n\t\t\tnext = alloc_ref(path->buf + name_offset);\n\t\t\tif (read_in_full(fd, buffer, 40) != 40 ||\n\t\t\t\t\tget_sha1_hex(buffer, next->old_sha1)) {\n\t\t\t\tclose(fd);\n\t\t\t\tfree(next);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(fd);\n\t\t\t(*tail)->next = next;\n\t\t\t*tail = next;\n\t\t}\n\t}\n\tstrbuf_setlen(path, pathlen);\n\n\tfor (i = 0; i < list.nr; i++)\n\t\tfree(list.entries[i]);\n\tfree(list.entries);\n\n\treturn 0;\n}\n\n/* insert the packed refs for which no loose refs were found */\n\nstatic void insert_packed_refs(const char *packed_refs, struct ref **list)\n{\n\tFILE *f = fopen(packed_refs, \"r\");\n\tstatic char buffer[PATH_MAX];\n\n\tif (!f)\n\t\treturn;\n\n\tfor (;;) {\n\t\tint cmp = cmp, len;\n\n\t\tif (!fgets(buffer, sizeof(buffer), f)) {\n\t\t\tfclose(f);\n\t\t\treturn;\n\t\t}\n\n\t\tif (hexval(buffer[0]) > 0xf)\n\t\t\tcontinue;\n\t\tlen = strlen(buffer);\n\t\tif (len && buffer[len - 1] == '\\n')\n\t\t\tbuffer[--len] = '\\0';\n\t\tif (len < 41)\n\t\t\tcontinue;\n\t\twhile ((*list)->next &&\n\t\t\t\t(cmp = strcmp(buffer + 41,\n\t\t\t\t      (*list)->next->name)) > 0)\n\t\t\tlist = &(*list)->next;\n\t\tif (!(*list)->next || cmp < 0) {\n\t\t\tstruct ref *next = alloc_ref(buffer + 41);\n\t\t\tbuffer[40] = '\\0';\n\t\t\tif (get_sha1_hex(buffer, next->old_sha1)) {\n\t\t\t\twarning (\"invalid SHA-1: %s\", buffer);\n\t\t\t\tfree(next);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnext->next = (*list)->next;\n\t\t\t(*list)->next = next;\n\t\t\tlist = &(*list)->next;\n\t\t}\n\t}\n}\n\nstatic void set_upstreams(struct transport *transport, struct ref *refs,\n\tint pretend)\n{\n\tstruct ref *ref;\n\tfor (ref = refs; ref; ref = ref->next) {\n\t\tconst char *localname;\n\t\tconst char *tmp;\n\t\tconst char *remotename;\n\t\tunsigned char sha[20];\n\t\tint flag = 0;\n\t\t/*\n\t\t * Check suitability for tracking. Must be successful /\n\t\t * already up-to-date ref create/modify (not delete).\n\t\t */\n\t\tif (ref->status != REF_STATUS_OK &&\n\t\t\tref->status != REF_STATUS_UPTODATE)\n\t\t\tcontinue;\n\t\tif (!ref->peer_ref)\n\t\t\tcontinue;\n\t\tif (!ref->new_sha1 || is_null_sha1(ref->new_sha1))\n\t\t\tcontinue;\n\n\t\t/* Follow symbolic refs (mainly for HEAD). */\n\t\tlocalname = ref->peer_ref->name;\n\t\tremotename = ref->name;\n\t\ttmp = resolve_ref(localname, sha, 1, &flag);\n\t\tif (tmp && flag & REF_ISSYMREF &&\n\t\t\t!prefixcmp(tmp, \"refs/heads/\"))\n\t\t\tlocalname = tmp;\n\n\t\t/* Both source and destination must be local branches. */\n\t\tif (!localname || prefixcmp(localname, \"refs/heads/\"))\n\t\t\tcontinue;\n\t\tif (!remotename || prefixcmp(remotename, \"refs/heads/\"))\n\t\t\tcontinue;\n\n\t\tif (!pretend)\n\t\t\tinstall_branch_config(BRANCH_CONFIG_VERBOSE,\n\t\t\t\tlocalname + 11, transport->remote->name,\n\t\t\t\tremotename);\n\t\telse\n\t\t\tprintf(\"Would set upstream of '%s' to '%s' of '%s'\\n\",\n\t\t\t\tlocalname + 11, remotename + 11,\n\t\t\t\ttransport->remote->name);\n\t}\n}\n\nstatic const char *rsync_url(const char *url)\n{\n\treturn prefixcmp(url, \"rsync://\") ? skip_prefix(url, \"rsync:\") : url;\n}\n\nstatic struct ref *get_refs_via_rsync(struct transport *transport, int for_push)\n{\n\tstruct strbuf buf = STRBUF_INIT, temp_dir = STRBUF_INIT;\n\tstruct ref dummy = {0}, *tail = &dummy;\n\tstruct child_process rsync;\n\tconst char *args[5];\n\tint temp_dir_len;\n\n\tif (for_push)\n\t\treturn NULL;\n\n\t/* copy the refs to the temporary directory */\n\n\tstrbuf_addstr(&temp_dir, git_path(\"rsync-refs-XXXXXX\"));\n\tif (!mkdtemp(temp_dir.buf))\n\t\tdie_errno (\"Could not make temporary directory\");\n\ttemp_dir_len = temp_dir.len;\n\n\tstrbuf_addstr(&buf, rsync_url(transport->url));\n\tstrbuf_addstr(&buf, \"/refs\");\n\n\tmemset(&rsync, 0, sizeof(rsync));\n\trsync.argv = args;\n\trsync.stdout_to_stderr = 1;\n\targs[0] = \"rsync\";\n\targs[1] = (transport->verbose > 0) ? \"-rv\" : \"-r\";\n\targs[2] = buf.buf;\n\targs[3] = temp_dir.buf;\n\targs[4] = NULL;\n\n\tif (run_command(&rsync))\n\t\tdie (\"Could not run rsync to get refs\");\n\n\tstrbuf_reset(&buf);\n\tstrbuf_addstr(&buf, rsync_url(transport->url));\n\tstrbuf_addstr(&buf, \"/packed-refs\");\n\n\targs[2] = buf.buf;\n\n\tif (run_command(&rsync))\n\t\tdie (\"Could not run rsync to get refs\");\n\n\t/* read the copied refs */\n\n\tstrbuf_addstr(&temp_dir, \"/refs\");\n\tread_loose_refs(&temp_dir, temp_dir_len + 1, &tail);\n\tstrbuf_setlen(&temp_dir, temp_dir_len);\n\n\ttail = &dummy;\n\tstrbuf_addstr(&temp_dir, \"/packed-refs\");\n\tinsert_packed_refs(temp_dir.buf, &tail);\n\tstrbuf_setlen(&temp_dir, temp_dir_len);\n\n\tif (remove_dir_recursively(&temp_dir, 0))\n\t\twarning (\"Error removing temporary directory %s.\",\n\t\t\t\ttemp_dir.buf);\n\n\tstrbuf_release(&buf);\n\tstrbuf_release(&temp_dir);\n\n\treturn dummy.next;\n}\n\nstatic int fetch_objs_via_rsync(struct transport *transport,\n\t\t\t\tint nr_objs, struct ref **to_fetch)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct child_process rsync;\n\tconst char *args[8];\n\tint result;\n\n\tstrbuf_addstr(&buf, rsync_url(transport->url));\n\tstrbuf_addstr(&buf, \"/objects/\");\n\n\tmemset(&rsync, 0, sizeof(rsync));\n\trsync.argv = args;\n\trsync.stdout_to_stderr = 1;\n\targs[0] = \"rsync\";\n\targs[1] = (transport->verbose > 0) ? \"-rv\" : \"-r\";\n\targs[2] = \"--ignore-existing\";\n\targs[3] = \"--exclude\";\n\targs[4] = \"info\";\n\targs[5] = buf.buf;\n\targs[6] = get_object_directory();\n\targs[7] = NULL;\n\n\t/* NEEDSWORK: handle one level of alternates */\n\tresult = run_command(&rsync);\n\n\tstrbuf_release(&buf);\n\n\treturn result;\n}\n\nstatic int write_one_ref(const char *name, const unsigned char *sha1,\n\t\tint flags, void *data)\n{\n\tstruct strbuf *buf = data;\n\tint len = buf->len;\n\tFILE *f;\n\n\t/* when called via for_each_ref(), flags is non-zero */\n\tif (flags && prefixcmp(name, \"refs/heads/\") &&\n\t\t\tprefixcmp(name, \"refs/tags/\"))\n\t\treturn 0;\n\n\tstrbuf_addstr(buf, name);\n\tif (safe_create_leading_directories(buf->buf) ||\n\t\t\t!(f = fopen(buf->buf, \"w\")) ||\n\t\t\tfprintf(f, \"%s\\n\", sha1_to_hex(sha1)) < 0 ||\n\t\t\tfclose(f))\n\t\treturn error(\"problems writing temporary file %s\", buf->buf);\n\tstrbuf_setlen(buf, len);\n\treturn 0;\n}\n\nstatic int write_refs_to_temp_dir(struct strbuf *temp_dir,\n\t\tint refspec_nr, const char **refspec)\n{\n\tint i;\n\n\tfor (i = 0; i < refspec_nr; i++) {\n\t\tunsigned char sha1[20];\n\t\tchar *ref;\n\n\t\tif (dwim_ref(refspec[i], strlen(refspec[i]), sha1, &ref) != 1)\n\t\t\treturn error(\"Could not get ref %s\", refspec[i]);\n\n\t\tif (write_one_ref(ref, sha1, 0, temp_dir)) {\n\t\t\tfree(ref);\n\t\t\treturn -1;\n\t\t}\n\t\tfree(ref);\n\t}\n\treturn 0;\n}\n\nstatic int rsync_transport_push(struct transport *transport,\n\t\tint refspec_nr, const char **refspec, int flags)\n{\n\tstruct strbuf buf = STRBUF_INIT, temp_dir = STRBUF_INIT;\n\tint result = 0, i;\n\tstruct child_process rsync;\n\tconst char *args[10];\n\n\tif (flags & TRANSPORT_PUSH_MIRROR)\n\t\treturn error(\"rsync transport does not support mirror mode\");\n\n\t/* first push the objects */\n\n\tstrbuf_addstr(&buf, rsync_url(transport->url));\n\tstrbuf_addch(&buf, '/');\n\n\tmemset(&rsync, 0, sizeof(rsync));\n\trsync.argv = args;\n\trsync.stdout_to_stderr = 1;\n\ti = 0;\n\targs[i++] = \"rsync\";\n\targs[i++] = \"-a\";\n\tif (flags & TRANSPORT_PUSH_DRY_RUN)\n\t\targs[i++] = \"--dry-run\";\n\tif (transport->verbose > 0)\n\t\targs[i++] = \"-v\";\n\targs[i++] = \"--ignore-existing\";\n\targs[i++] = \"--exclude\";\n\targs[i++] = \"info\";\n\targs[i++] = get_object_directory();\n\targs[i++] = buf.buf;\n\targs[i++] = NULL;\n\n\tif (run_command(&rsync))\n\t\treturn error(\"Could not push objects to %s\",\n\t\t\t\trsync_url(transport->url));\n\n\t/* copy the refs to the temporary directory; they could be packed. */\n\n\tstrbuf_addstr(&temp_dir, git_path(\"rsync-refs-XXXXXX\"));\n\tif (!mkdtemp(temp_dir.buf))\n\t\tdie_errno (\"Could not make temporary directory\");\n\tstrbuf_addch(&temp_dir, '/');\n\n\tif (flags & TRANSPORT_PUSH_ALL) {\n\t\tif (for_each_ref(write_one_ref, &temp_dir))\n\t\t\treturn -1;\n\t} else if (write_refs_to_temp_dir(&temp_dir, refspec_nr, refspec))\n\t\treturn -1;\n\n\ti = 2;\n\tif (flags & TRANSPORT_PUSH_DRY_RUN)\n\t\targs[i++] = \"--dry-run\";\n\tif (!(flags & TRANSPORT_PUSH_FORCE))\n\t\targs[i++] = \"--ignore-existing\";\n\targs[i++] = temp_dir.buf;\n\targs[i++] = rsync_url(transport->url);\n\targs[i++] = NULL;\n\tif (run_command(&rsync))\n\t\tresult = error(\"Could not push to %s\",\n\t\t\t\trsync_url(transport->url));\n\n\tif (remove_dir_recursively(&temp_dir, 0))\n\t\twarning (\"Could not remove temporary directory %s.\",\n\t\t\t\ttemp_dir.buf);\n\n\tstrbuf_release(&buf);\n\tstrbuf_release(&temp_dir);\n\n\treturn result;\n}\n\nstruct bundle_transport_data {\n\tint fd;\n\tstruct bundle_header header;\n};\n\nstatic struct ref *get_refs_from_bundle(struct transport *transport, int for_push)\n{\n\tstruct bundle_transport_data *data = transport->data;\n\tstruct ref *result = NULL;\n\tint i;\n\n\tif (for_push)\n\t\treturn NULL;\n\n\tif (data->fd > 0)\n\t\tclose(data->fd);\n\tdata->fd = read_bundle_header(transport->url, &data->header);\n\tif (data->fd < 0)\n\t\tdie (\"Could not read bundle '%s'.\", transport->url);\n\tfor (i = 0; i < data->header.references.nr; i++) {\n\t\tstruct ref_list_entry *e = data->header.references.list + i;\n\t\tstruct ref *ref = alloc_ref(e->name);\n\t\thashcpy(ref->old_sha1, e->sha1);\n\t\tref->next = result;\n\t\tresult = ref;\n\t}\n\treturn result;\n}\n\nstatic int fetch_refs_from_bundle(struct transport *transport,\n\t\t\t       int nr_heads, struct ref **to_fetch)\n{\n\tstruct bundle_transport_data *data = transport->data;\n\treturn unbundle(&data->header, data->fd);\n}\n\nstatic int close_bundle(struct transport *transport)\n{\n\tstruct bundle_transport_data *data = transport->data;\n\tif (data->fd > 0)\n\t\tclose(data->fd);\n\tfree(data);\n\treturn 0;\n}\n\nstruct git_transport_data {\n\tstruct git_transport_options options;\n\tstruct child_process *conn;\n\tint fd[2];\n\tunsigned got_remote_heads : 1;\n\tstruct extra_have_objects extra_have;\n};\n\nstatic int set_git_option(struct git_transport_options *opts,\n\t\t\t  const char *name, const char *value)\n{\n\tif (!strcmp(name, TRANS_OPT_UPLOADPACK)) {\n\t\topts->uploadpack = value;\n\t\treturn 0;\n\t} else if (!strcmp(name, TRANS_OPT_RECEIVEPACK)) {\n\t\topts->receivepack = value;\n\t\treturn 0;\n\t} else if (!strcmp(name, TRANS_OPT_THIN)) {\n\t\topts->thin = !!value;\n\t\treturn 0;\n\t} else if (!strcmp(name, TRANS_OPT_FOLLOWTAGS)) {\n\t\topts->followtags = !!value;\n\t\treturn 0;\n\t} else if (!strcmp(name, TRANS_OPT_KEEP)) {\n\t\topts->keep = !!value;\n\t\treturn 0;\n\t} else if (!strcmp(name, TRANS_OPT_DEPTH)) {\n\t\tif (!value)\n\t\t\topts->depth = 0;\n\t\telse\n\t\t\topts->depth = atoi(value);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int connect_setup(struct transport *transport, int for_push, int verbose)\n{\n\tstruct git_transport_data *data = transport->data;\n\n\tif (data->conn)\n\t\treturn 0;\n\n\tdata->conn = git_connect(data->fd, transport->url,\n\t\t\t\t for_push ? data->options.receivepack :\n\t\t\t\t data->options.uploadpack,\n\t\t\t\t verbose ? CONNECT_VERBOSE : 0);\n\n\treturn 0;\n}\n\nstatic struct ref *get_refs_via_connect(struct transport *transport, int for_push)\n{\n\tstruct git_transport_data *data = transport->data;\n\tstruct ref *refs;\n\n\tconnect_setup(transport, for_push, 0);\n\tget_remote_heads(data->fd[0], &refs, 0, NULL,\n\t\t\t for_push ? REF_NORMAL : 0, &data->extra_have);\n\tdata->got_remote_heads = 1;\n\n\treturn refs;\n}\n\nstatic int fetch_refs_via_pack(struct transport *transport,\n\t\t\t       int nr_heads, struct ref **to_fetch)\n{\n\tstruct git_transport_data *data = transport->data;\n\tchar **heads = xmalloc(nr_heads * sizeof(*heads));\n\tchar **origh = xmalloc(nr_heads * sizeof(*origh));\n\tconst struct ref *refs;\n\tchar *dest = xstrdup(transport->url);\n\tstruct fetch_pack_args args;\n\tint i;\n\tstruct ref *refs_tmp = NULL;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.uploadpack = data->options.uploadpack;\n\targs.keep_pack = data->options.keep;\n\targs.lock_pack = 1;\n\targs.use_thin_pack = data->options.thin;\n\targs.include_tag = data->options.followtags;\n\targs.verbose = (transport->verbose > 0);\n\targs.quiet = (transport->verbose < 0);\n\targs.no_progress = !transport->progress;\n\targs.depth = data->options.depth;\n\n\tfor (i = 0; i < nr_heads; i++)\n\t\torigh[i] = heads[i] = xstrdup(to_fetch[i]->name);\n\n\tif (!data->got_remote_heads) {\n\t\tconnect_setup(transport, 0, 0);\n\t\tget_remote_heads(data->fd[0], &refs_tmp, 0, NULL, 0, NULL);\n\t\tdata->got_remote_heads = 1;\n\t}\n\n\trefs = fetch_pack(&args, data->fd, data->conn,\n\t\t\t  refs_tmp ? refs_tmp : transport->remote_refs,\n\t\t\t  dest, nr_heads, heads, &transport->pack_lockfile);\n\tclose(data->fd[0]);\n\tclose(data->fd[1]);\n\tif (finish_connect(data->conn))\n\t\trefs = NULL;\n\tdata->conn = NULL;\n\tdata->got_remote_heads = 0;\n\n\tfree_refs(refs_tmp);\n\n\tfor (i = 0; i < nr_heads; i++)\n\t\tfree(origh[i]);\n\tfree(origh);\n\tfree(heads);\n\tfree(dest);\n\treturn (refs ? 0 : -1);\n}\n\nstatic int push_had_errors(struct ref *ref)\n{\n\tfor (; ref; ref = ref->next) {\n\t\tswitch (ref->status) {\n\t\tcase REF_STATUS_NONE:\n\t\tcase REF_STATUS_UPTODATE:\n\t\tcase REF_STATUS_OK:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint transport_refs_pushed(struct ref *ref)\n{\n\tfor (; ref; ref = ref->next) {\n\t\tswitch(ref->status) {\n\t\tcase REF_STATUS_NONE:\n\t\tcase REF_STATUS_UPTODATE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid transport_update_tracking_ref(struct remote *remote, struct ref *ref, int verbose)\n{\n\tstruct refspec rs;\n\n\tif (ref->status != REF_STATUS_OK && ref->status != REF_STATUS_UPTODATE)\n\t\treturn;\n\n\trs.src = ref->name;\n\trs.dst = NULL;\n\n\tif (!remote_find_tracking(remote, &rs)) {\n\t\tif (verbose)\n\t\t\tfprintf(stderr, \"updating local tracking ref '%s'\\n\", rs.dst);\n\t\tif (ref->deletion) {\n\t\t\tdelete_ref(rs.dst, NULL, 0);\n\t\t} else\n\t\t\tupdate_ref(\"update by push\", rs.dst,\n\t\t\t\t\tref->new_sha1, NULL, 0, 0);\n\t\tfree(rs.dst);\n\t}\n}\n\nstatic void print_ref_status(char flag, const char *summary, struct ref *to, struct ref *from, const char *msg, int porcelain)\n{\n\tif (porcelain) {\n\t\tif (from)\n\t\t\tfprintf(stdout, \"%c\\t%s:%s\\t\", flag, from->name, to->name);\n\t\telse\n\t\t\tfprintf(stdout, \"%c\\t:%s\\t\", flag, to->name);\n\t\tif (msg)\n\t\t\tfprintf(stdout, \"%s (%s)\\n\", summary, msg);\n\t\telse\n\t\t\tfprintf(stdout, \"%s\\n\", summary);\n\t} else {\n\t\tfprintf(stderr, \" %c %-*s \", flag, TRANSPORT_SUMMARY_WIDTH, summary);\n\t\tif (from)\n\t\t\tfprintf(stderr, \"%s -> %s\", prettify_refname(from->name), prettify_refname(to->name));\n\t\telse\n\t\t\tfputs(prettify_refname(to->name), stderr);\n\t\tif (msg) {\n\t\t\tfputs(\" (\", stderr);\n\t\t\tfputs(msg, stderr);\n\t\t\tfputc(')', stderr);\n\t\t}\n\t\tfputc('\\n', stderr);\n\t}\n}\n\nstatic const char *status_abbrev(unsigned char sha1[20])\n{\n\treturn find_unique_abbrev(sha1, DEFAULT_ABBREV);\n}\n\nstatic void print_ok_ref_status(struct ref *ref, int porcelain)\n{\n\tif (ref->deletion)\n\t\tprint_ref_status('-', \"[deleted]\", ref, NULL, NULL, porcelain);\n\telse if (is_null_sha1(ref->old_sha1))\n\t\tprint_ref_status('*',\n\t\t\t(!prefixcmp(ref->name, \"refs/tags/\") ? \"[new tag]\" :\n\t\t\t\"[new branch]\"),\n\t\t\tref, ref->peer_ref, NULL, porcelain);\n\telse {\n\t\tchar quickref[84];\n\t\tchar type;\n\t\tconst char *msg;\n\n\t\tstrcpy(quickref, status_abbrev(ref->old_sha1));\n\t\tif (ref->nonfastforward) {\n\t\t\tstrcat(quickref, \"...\");\n\t\t\ttype = '+';\n\t\t\tmsg = \"forced update\";\n\t\t} else {\n\t\t\tstrcat(quickref, \"..\");\n\t\t\ttype = ' ';\n\t\t\tmsg = NULL;\n\t\t}\n\t\tstrcat(quickref, status_abbrev(ref->new_sha1));\n\n\t\tprint_ref_status(type, quickref, ref, ref->peer_ref, msg, porcelain);\n\t}\n}\n\nstatic int print_one_push_status(struct ref *ref, const char *dest, int count, int porcelain)\n{\n\tif (!count)\n\t\tfprintf(porcelain ? stdout : stderr, \"To %s\\n\", dest);\n\n\tswitch(ref->status) {\n\tcase REF_STATUS_NONE:\n\t\tprint_ref_status('X', \"[no match]\", ref, NULL, NULL, porcelain);\n\t\tbreak;\n\tcase REF_STATUS_REJECT_NODELETE:\n\t\tprint_ref_status('!', \"[rejected]\", ref, NULL,\n\t\t\t\t\t\t \"remote does not support deleting refs\", porcelain);\n\t\tbreak;\n\tcase REF_STATUS_UPTODATE:\n\t\tprint_ref_status('=', \"[up to date]\", ref,\n\t\t\t\t\t\t ref->peer_ref, NULL, porcelain);\n\t\tbreak;\n\tcase REF_STATUS_REJECT_NONFASTFORWARD:\n\t\tprint_ref_status('!', \"[rejected]\", ref, ref->peer_ref,\n\t\t\t\t\t\t \"non-fast-forward\", porcelain);\n\t\tbreak;\n\tcase REF_STATUS_REMOTE_REJECT:\n\t\tprint_ref_status('!', \"[remote rejected]\", ref,\n\t\t\t\t\t\t ref->deletion ? NULL : ref->peer_ref,\n\t\t\t\t\t\t ref->remote_status, porcelain);\n\t\tbreak;\n\tcase REF_STATUS_EXPECTING_REPORT:\n\t\tprint_ref_status('!', \"[remote failure]\", ref,\n\t\t\t\t\t\t ref->deletion ? NULL : ref->peer_ref,\n\t\t\t\t\t\t \"remote failed to report status\", porcelain);\n\t\tbreak;\n\tcase REF_STATUS_OK:\n\t\tprint_ok_ref_status(ref, porcelain);\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\nvoid transport_print_push_status(const char *dest, struct ref *refs,\n\t\t\t\t  int verbose, int porcelain, int *nonfastforward)\n{\n\tstruct ref *ref;\n\tint n = 0;\n\n\tif (verbose) {\n\t\tfor (ref = refs; ref; ref = ref->next)\n\t\t\tif (ref->status == REF_STATUS_UPTODATE)\n\t\t\t\tn += print_one_push_status(ref, dest, n, porcelain);\n\t}\n\n\tfor (ref = refs; ref; ref = ref->next)\n\t\tif (ref->status == REF_STATUS_OK)\n\t\t\tn += print_one_push_status(ref, dest, n, porcelain);\n\n\t*nonfastforward = 0;\n\tfor (ref = refs; ref; ref = ref->next) {\n\t\tif (ref->status != REF_STATUS_NONE &&\n\t\t    ref->status != REF_STATUS_UPTODATE &&\n\t\t    ref->status != REF_STATUS_OK)\n\t\t\tn += print_one_push_status(ref, dest, n, porcelain);\n\t\tif (ref->status == REF_STATUS_REJECT_NONFASTFORWARD)\n\t\t\t*nonfastforward = 1;\n\t}\n}\n\nvoid transport_verify_remote_names(int nr_heads, const char **heads)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_heads; i++) {\n\t\tconst char *local = heads[i];\n\t\tconst char *remote = strrchr(heads[i], ':');\n\n\t\tif (*local == '+')\n\t\t\tlocal++;\n\n\t\t/* A matching refspec is okay.  */\n\t\tif (remote == local && remote[1] == '\\0')\n\t\t\tcontinue;\n\n\t\tremote = remote ? (remote + 1) : local;\n\t\tswitch (check_ref_format(remote)) {\n\t\tcase 0: /* ok */\n\t\tcase CHECK_REF_FORMAT_ONELEVEL:\n\t\t\t/* ok but a single level -- that is fine for\n\t\t\t * a match pattern.\n\t\t\t */\n\t\tcase CHECK_REF_FORMAT_WILDCARD:\n\t\t\t/* ok but ends with a pattern-match character */\n\t\t\tcontinue;\n\t\t}\n\t\tdie(\"remote part of refspec is not a valid name in %s\",\n\t\t    heads[i]);\n\t}\n}\n\nstatic int git_transport_push(struct transport *transport, struct ref *remote_refs, int flags)\n{\n\tstruct git_transport_data *data = transport->data;\n\tstruct send_pack_args args;\n\tint ret;\n\n\tif (!data->got_remote_heads) {\n\t\tstruct ref *tmp_refs;\n\t\tconnect_setup(transport, 1, 0);\n\n\t\tget_remote_heads(data->fd[0], &tmp_refs, 0, NULL, REF_NORMAL,\n\t\t\t\t NULL);\n\t\tdata->got_remote_heads = 1;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\targs.send_mirror = !!(flags & TRANSPORT_PUSH_MIRROR);\n\targs.force_update = !!(flags & TRANSPORT_PUSH_FORCE);\n\targs.use_thin_pack = data->options.thin;\n\targs.verbose = (transport->verbose > 0);\n\targs.quiet = (transport->verbose < 0);\n\targs.progress = transport->progress;\n\targs.dry_run = !!(flags & TRANSPORT_PUSH_DRY_RUN);\n\targs.porcelain = !!(flags & TRANSPORT_PUSH_PORCELAIN);\n\n\tret = send_pack(&args, data->fd, data->conn, remote_refs,\n\t\t\t&data->extra_have);\n\n\tclose(data->fd[1]);\n\tclose(data->fd[0]);\n\tret |= finish_connect(data->conn);\n\tdata->conn = NULL;\n\tdata->got_remote_heads = 0;\n\n\treturn ret;\n}\n\nstatic int connect_git(struct transport *transport, const char *name,\n\t\t       const char *executable, int fd[2])\n{\n\tstruct git_transport_data *data = transport->data;\n\tdata->conn = git_connect(data->fd, transport->url,\n\t\t\t\t executable, 0);\n\tfd[0] = data->fd[0];\n\tfd[1] = data->fd[1];\n\treturn 0;\n}\n\nstatic int disconnect_git(struct transport *transport)\n{\n\tstruct git_transport_data *data = transport->data;\n\tif (data->conn) {\n\t\tif (data->got_remote_heads)\n\t\t\tpacket_flush(data->fd[1]);\n\t\tclose(data->fd[0]);\n\t\tclose(data->fd[1]);\n\t\tfinish_connect(data->conn);\n\t}\n\n\tfree(data);\n\treturn 0;\n}\n\nvoid transport_take_over(struct transport *transport,\n\t\t\t struct child_process *child)\n{\n\tstruct git_transport_data *data;\n\n\tif (!transport->smart_options)\n\t\tdie(\"Bug detected: Taking over transport requires non-NULL \"\n\t\t    \"smart_options field.\");\n\n\tdata = xcalloc(1, sizeof(*data));\n\tdata->options = *transport->smart_options;\n\tdata->conn = child;\n\tdata->fd[0] = data->conn->out;\n\tdata->fd[1] = data->conn->in;\n\tdata->got_remote_heads = 0;\n\ttransport->data = data;\n\n\ttransport->set_option = NULL;\n\ttransport->get_refs_list = get_refs_via_connect;\n\ttransport->fetch = fetch_refs_via_pack;\n\ttransport->push = NULL;\n\ttransport->push_refs = git_transport_push;\n\ttransport->disconnect = disconnect_git;\n\ttransport->smart_options = &(data->options);\n}\n\nstatic int is_local(const char *url)\n{\n\tconst char *colon = strchr(url, ':');\n\tconst char *slash = strchr(url, '/');\n\treturn !colon || (slash && slash < colon) ||\n\t\thas_dos_drive_prefix(url);\n}\n\nstatic int is_file(const char *url)\n{\n\tstruct stat buf;\n\tif (stat(url, &buf))\n\t\treturn 0;\n\treturn S_ISREG(buf.st_mode);\n}\n\nstatic int external_specification_len(const char *url)\n{\n\treturn strchr(url, ':') - url;\n}\n\nstruct transport *transport_get(struct remote *remote, const char *url)\n{\n\tconst char *helper;\n\tstruct transport *ret = xcalloc(1, sizeof(*ret));\n\n\tret->progress = isatty(2);\n\n\tif (!remote)\n\t\tdie(\"No remote provided to transport_get()\");\n\n\tret->got_remote_refs = 0;\n\tret->remote = remote;\n\thelper = remote->foreign_vcs;\n\n\tif (!url && remote->url)\n\t\turl = remote->url[0];\n\tret->url = url;\n\n\t/* maybe it is a foreign URL? */\n\tif (url) {\n\t\tconst char *p = url;\n\n\t\twhile (is_urlschemechar(p == url, *p))\n\t\t\tp++;\n\t\tif (!prefixcmp(p, \"::\"))\n\t\t\thelper = xstrndup(url, p - url);\n\t}\n\n\tif (helper) {\n\t\ttransport_helper_init(ret, helper);\n\t} else if (!prefixcmp(url, \"rsync:\")) {\n\t\tret->get_refs_list = get_refs_via_rsync;\n\t\tret->fetch = fetch_objs_via_rsync;\n\t\tret->push = rsync_transport_push;\n\t\tret->smart_options = NULL;\n\t} else if (is_local(url) && is_file(url)) {\n\t\tstruct bundle_transport_data *data = xcalloc(1, sizeof(*data));\n\t\tret->data = data;\n\t\tret->get_refs_list = get_refs_from_bundle;\n\t\tret->fetch = fetch_refs_from_bundle;\n\t\tret->disconnect = close_bundle;\n\t\tret->smart_options = NULL;\n\t} else if (!is_url(url)\n\t\t|| !prefixcmp(url, \"file://\")\n\t\t|| !prefixcmp(url, \"git://\")\n\t\t|| !prefixcmp(url, \"ssh://\")\n\t\t|| !prefixcmp(url, \"git+ssh://\")\n\t\t|| !prefixcmp(url, \"ssh+git://\")) {\n\t\t/* These are builtin smart transports. */\n\t\tstruct git_transport_data *data = xcalloc(1, sizeof(*data));\n\t\tret->data = data;\n\t\tret->set_option = NULL;\n\t\tret->get_refs_list = get_refs_via_connect;\n\t\tret->fetch = fetch_refs_via_pack;\n\t\tret->push_refs = git_transport_push;\n\t\tret->connect = connect_git;\n\t\tret->disconnect = disconnect_git;\n\t\tret->smart_options = &(data->options);\n\n\t\tdata->conn = NULL;\n\t\tdata->got_remote_heads = 0;\n\t} else {\n\t\t/* Unknown protocol in URL. Pass to external handler. */\n\t\tint len = external_specification_len(url);\n\t\tchar *handler = xmalloc(len + 1);\n\t\thandler[len] = 0;\n\t\tstrncpy(handler, url, len);\n\t\ttransport_helper_init(ret, handler);\n\t}\n\n\tif (ret->smart_options) {\n\t\tret->smart_options->thin = 1;\n\t\tret->smart_options->uploadpack = \"git-upload-pack\";\n\t\tif (remote->uploadpack)\n\t\t\tret->smart_options->uploadpack = remote->uploadpack;\n\t\tret->smart_options->receivepack = \"git-receive-pack\";\n\t\tif (remote->receivepack)\n\t\t\tret->smart_options->receivepack = remote->receivepack;\n\t}\n\n\treturn ret;\n}\n\nint transport_set_option(struct transport *transport,\n\t\t\t const char *name, const char *value)\n{\n\tint git_reports = 1, protocol_reports = 1;\n\n\tif (transport->smart_options)\n\t\tgit_reports = set_git_option(transport->smart_options,\n\t\t\t\t\t     name, value);\n\n\tif (transport->set_option)\n\t\tprotocol_reports = transport->set_option(transport, name,\n\t\t\t\t\t\t\tvalue);\n\n\t/* If either report is 0, report 0 (success). */\n\tif (!git_reports || !protocol_reports)\n\t\treturn 0;\n\t/* If either reports -1 (invalid value), report -1. */\n\tif ((git_reports == -1) || (protocol_reports == -1))\n\t\treturn -1;\n\t/* Otherwise if both report unknown, report unknown. */\n\treturn 1;\n}\n\nvoid transport_set_verbosity(struct transport *transport, int verbosity,\n\tint force_progress)\n{\n\tif (verbosity >= 2)\n\t\ttransport->verbose = verbosity <= 3 ? verbosity : 3;\n\tif (verbosity < 0)\n\t\ttransport->verbose = -1;\n\n\t/**\n\t * Rules used to determine whether to report progress (processing aborts\n\t * when a rule is satisfied):\n\t *\n\t *   1. Report progress, if force_progress is 1 (ie. --progress).\n\t *   2. Don't report progress, if verbosity < 0 (ie. -q/--quiet ).\n\t *   3. Report progress if isatty(2) is 1.\n\t **/\n\ttransport->progress = force_progress || (verbosity >= 0 && isatty(2));\n}\n\nint transport_push(struct transport *transport,\n\t\t   int refspec_nr, const char **refspec, int flags,\n\t\t   int *nonfastforward)\n{\n\t*nonfastforward = 0;\n\ttransport_verify_remote_names(refspec_nr, refspec);\n\n\tif (transport->push) {\n\t\t/* Maybe FIXME. But no important transport uses this case. */\n\t\tif (flags & TRANSPORT_PUSH_SET_UPSTREAM)\n\t\t\tdie(\"This transport does not support using --set-upstream\");\n\n\t\treturn transport->push(transport, refspec_nr, refspec, flags);\n\t} else if (transport->push_refs) {\n\t\tstruct ref *remote_refs =\n\t\t\ttransport->get_refs_list(transport, 1);\n\t\tstruct ref *local_refs = get_local_heads();\n\t\tint match_flags = MATCH_REFS_NONE;\n\t\tint verbose = (transport->verbose > 0);\n\t\tint quiet = (transport->verbose < 0);\n\t\tint porcelain = flags & TRANSPORT_PUSH_PORCELAIN;\n\t\tint pretend = flags & TRANSPORT_PUSH_DRY_RUN;\n\t\tint push_ret, ret, err;\n\n\t\tif (flags & TRANSPORT_PUSH_ALL)\n\t\t\tmatch_flags |= MATCH_REFS_ALL;\n\t\tif (flags & TRANSPORT_PUSH_MIRROR)\n\t\t\tmatch_flags |= MATCH_REFS_MIRROR;\n\n\t\tif (match_refs(local_refs, &remote_refs,\n\t\t\t       refspec_nr, refspec, match_flags)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tset_ref_status_for_push(remote_refs,\n\t\t\tflags & TRANSPORT_PUSH_MIRROR,\n\t\t\tflags & TRANSPORT_PUSH_FORCE);\n\n\t\tpush_ret = transport->push_refs(transport, remote_refs, flags);\n\t\terr = push_had_errors(remote_refs);\n\t\tret = push_ret | err;\n\n\t\tif (!quiet || err)\n\t\t\ttransport_print_push_status(transport->url, remote_refs,\n\t\t\t\t\tverbose | porcelain, porcelain,\n\t\t\t\t\tnonfastforward);\n\n\t\tif (flags & TRANSPORT_PUSH_SET_UPSTREAM)\n\t\t\tset_upstreams(transport, remote_refs, pretend);\n\n\t\tif (!(flags & TRANSPORT_PUSH_DRY_RUN)) {\n\t\t\tstruct ref *ref;\n\t\t\tfor (ref = remote_refs; ref; ref = ref->next)\n\t\t\t\ttransport_update_tracking_ref(transport->remote, ref, verbose);\n\t\t}\n\n\t\tif (porcelain && !push_ret)\n\t\t\tputs(\"Done\");\n\t\telse if (!quiet && !ret && !transport_refs_pushed(remote_refs))\n\t\t\tfprintf(stderr, \"Everything up-to-date\\n\");\n\n\t\treturn ret;\n\t}\n\treturn 1;\n}\n\nconst struct ref *transport_get_remote_refs(struct transport *transport)\n{\n\tif (!transport->got_remote_refs) {\n\t\ttransport->remote_refs = transport->get_refs_list(transport, 0);\n\t\ttransport->got_remote_refs = 1;\n\t}\n\n\treturn transport->remote_refs;\n}\n\nint transport_fetch_refs(struct transport *transport, struct ref *refs)\n{\n\tint rc;\n\tint nr_heads = 0, nr_alloc = 0, nr_refs = 0;\n\tstruct ref **heads = NULL;\n\tstruct ref *rm;\n\n\tfor (rm = refs; rm; rm = rm->next) {\n\t\tnr_refs++;\n\t\tif (rm->peer_ref &&\n\t\t    !is_null_sha1(rm->old_sha1) &&\n\t\t    !hashcmp(rm->peer_ref->old_sha1, rm->old_sha1))\n\t\t\tcontinue;\n\t\tALLOC_GROW(heads, nr_heads + 1, nr_alloc);\n\t\theads[nr_heads++] = rm;\n\t}\n\n\tif (!nr_heads) {\n\t\t/*\n\t\t * When deepening of a shallow repository is requested,\n\t\t * then local and remote refs are likely to still be equal.\n\t\t * Just feed them all to the fetch method in that case.\n\t\t * This condition shouldn't be met in a non-deepening fetch\n\t\t * (see builtin-fetch.c:quickfetch()).\n\t\t */\n\t\theads = xmalloc(nr_refs * sizeof(*heads));\n\t\tfor (rm = refs; rm; rm = rm->next)\n\t\t\theads[nr_heads++] = rm;\n\t}\n\n\trc = transport->fetch(transport, nr_heads, heads);\n\n\tfree(heads);\n\treturn rc;\n}\n\nvoid transport_unlock_pack(struct transport *transport)\n{\n\tif (transport->pack_lockfile) {\n\t\tunlink_or_warn(transport->pack_lockfile);\n\t\tfree(transport->pack_lockfile);\n\t\ttransport->pack_lockfile = NULL;\n\t}\n}\n\nint transport_connect(struct transport *transport, const char *name,\n\t\t      const char *exec, int fd[2])\n{\n\tif (transport->connect)\n\t\treturn transport->connect(transport, name, exec, fd);\n\telse\n\t\tdie(\"Operation not supported by protocol\");\n}\n\nint transport_disconnect(struct transport *transport)\n{\n\tint ret = 0;\n\tif (transport->disconnect)\n\t\tret = transport->disconnect(transport);\n\tfree(transport);\n\treturn ret;\n}\n\n/*\n * Strip username (and password) from an url and return\n * it in a newly allocated string.\n */\nchar *transport_anonymize_url(const char *url)\n{\n\tchar *anon_url, *scheme_prefix, *anon_part;\n\tsize_t anon_len, prefix_len = 0;\n\n\tanon_part = strchr(url, '@');\n\tif (is_local(url) || !anon_part)\n\t\tgoto literal_copy;\n\n\tanon_len = strlen(++anon_part);\n\tscheme_prefix = strstr(url, \"://\");\n\tif (!scheme_prefix) {\n\t\tif (!strchr(anon_part, ':'))\n\t\t\t/* cannot be \"me@there:/path/name\" */\n\t\t\tgoto literal_copy;\n\t} else {\n\t\tconst char *cp;\n\t\t/* make sure scheme is reasonable */\n\t\tfor (cp = url; cp < scheme_prefix; cp++) {\n\t\t\tswitch (*cp) {\n\t\t\t\t/* RFC 1738 2.1 */\n\t\t\tcase '+': case '.': case '-':\n\t\t\t\tbreak; /* ok */\n\t\t\tdefault:\n\t\t\t\tif (isalnum(*cp))\n\t\t\t\t\tbreak;\n\t\t\t\t/* it isn't */\n\t\t\t\tgoto literal_copy;\n\t\t\t}\n\t\t}\n\t\t/* @ past the first slash does not count */\n\t\tcp = strchr(scheme_prefix + 3, '/');\n\t\tif (cp && cp < anon_part)\n\t\t\tgoto literal_copy;\n\t\tprefix_len = scheme_prefix - url + 3;\n\t}\n\tanon_url = xcalloc(1, 1 + prefix_len + anon_len);\n\tmemcpy(anon_url, url, prefix_len);\n\tmemcpy(anon_url + prefix_len, anon_part, anon_len);\n\treturn anon_url;\nliteral_copy:\n\treturn xstrdup(url);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00786606117feea4b33b7e632b8ff8a3c26de4e4",
  "sha1_ok": true,
  "size": 30178
}
