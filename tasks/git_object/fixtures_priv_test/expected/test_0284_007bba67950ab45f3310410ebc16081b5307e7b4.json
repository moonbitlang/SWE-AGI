{
  "content": {
    "base64": "LyoKICogImdpdCBmYXN0LWV4cG9ydCIgYnVpbHRpbiBjb21tYW5kCiAqCiAqIENvcHlyaWdodCAoQykgMjAwNyBKb2hhbm5lcyBFLiBTY2hpbmRlbGluCiAqLwojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAiY2FjaGUuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAib2JqZWN0LmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgImRpZmZjb3JlLmgiCiNpbmNsdWRlICJsb2ctdHJlZS5oIgojaW5jbHVkZSAicmV2aXNpb24uaCIKI2luY2x1ZGUgImRlY29yYXRlLmgiCiNpbmNsdWRlICJzdHJpbmctbGlzdC5oIgojaW5jbHVkZSAidXRmOC5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgoKc3RhdGljIGNvbnN0IGNoYXIgKmZhc3RfZXhwb3J0X3VzYWdlW10gPSB7CgkiZ2l0IGZhc3QtZXhwb3J0IFtyZXYtbGlzdC1vcHRzXSIsCglOVUxMCn07CgpzdGF0aWMgaW50IHByb2dyZXNzOwpzdGF0aWMgZW51bSB7IEFCT1JULCBWRVJCQVRJTSwgV0FSTiwgU1RSSVAgfSBzaWduZWRfdGFnX21vZGUgPSBBQk9SVDsKc3RhdGljIGVudW0geyBFUlJPUiwgRFJPUCwgUkVXUklURSB9IHRhZ19vZl9maWx0ZXJlZF9tb2RlID0gQUJPUlQ7CnN0YXRpYyBpbnQgZmFrZV9taXNzaW5nX3RhZ2dlcjsKc3RhdGljIGludCBub19kYXRhOwoKc3RhdGljIGludCBwYXJzZV9vcHRfc2lnbmVkX3RhZ19tb2RlKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwKCQkJCSAgICAgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCWlmICh1bnNldCB8fCAhc3RyY21wKGFyZywgImFib3J0IikpCgkJc2lnbmVkX3RhZ19tb2RlID0gQUJPUlQ7CgllbHNlIGlmICghc3RyY21wKGFyZywgInZlcmJhdGltIikgfHwgIXN0cmNtcChhcmcsICJpZ25vcmUiKSkKCQlzaWduZWRfdGFnX21vZGUgPSBWRVJCQVRJTTsKCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAid2FybiIpKQoJCXNpZ25lZF90YWdfbW9kZSA9IFdBUk47CgllbHNlIGlmICghc3RyY21wKGFyZywgInN0cmlwIikpCgkJc2lnbmVkX3RhZ19tb2RlID0gU1RSSVA7CgllbHNlCgkJcmV0dXJuIGVycm9yKCJVbmtub3duIHNpZ25lZC10YWcgbW9kZTogJXMiLCBhcmcpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgcGFyc2Vfb3B0X3RhZ19vZl9maWx0ZXJlZF9tb2RlKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwKCQkJCQkgIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglpZiAodW5zZXQgfHwgIXN0cmNtcChhcmcsICJhYm9ydCIpKQoJCXRhZ19vZl9maWx0ZXJlZF9tb2RlID0gQUJPUlQ7CgllbHNlIGlmICghc3RyY21wKGFyZywgImRyb3AiKSkKCQl0YWdfb2ZfZmlsdGVyZWRfbW9kZSA9IERST1A7CgllbHNlIGlmICghc3RyY21wKGFyZywgInJld3JpdGUiKSkKCQl0YWdfb2ZfZmlsdGVyZWRfbW9kZSA9IFJFV1JJVEU7CgllbHNlCgkJcmV0dXJuIGVycm9yKCJVbmtub3duIHRhZy1vZi1maWx0ZXJlZCBtb2RlOiAlcyIsIGFyZyk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHN0cnVjdCBkZWNvcmF0aW9uIGlkbnVtczsKc3RhdGljIHVpbnQzMl90IGxhc3RfaWRudW07CgpzdGF0aWMgaW50IGhhc191bnNob3duX3BhcmVudChzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50OwoKCWZvciAocGFyZW50ID0gY29tbWl0LT5wYXJlbnRzOyBwYXJlbnQ7IHBhcmVudCA9IHBhcmVudC0+bmV4dCkKCQlpZiAoIShwYXJlbnQtPml0ZW0tPm9iamVjdC5mbGFncyAmIFNIT1dOKSAmJgoJCSAgICAhKHBhcmVudC0+aXRlbS0+b2JqZWN0LmZsYWdzICYgVU5JTlRFUkVTVElORykpCgkJCXJldHVybiAxOwoJcmV0dXJuIDA7Cn0KCi8qIFNpbmNlIGludHB0cl90IGlzIEM5OSwgd2UgZG8gbm90IHVzZSBpdCBoZXJlICovCnN0YXRpYyBpbmxpbmUgdWludDMyX3QgKm1hcmtfdG9fcHRyKHVpbnQzMl90IG1hcmspCnsKCXJldHVybiAoKHVpbnQzMl90ICopTlVMTCkgKyBtYXJrOwp9CgpzdGF0aWMgaW5saW5lIHVpbnQzMl90IHB0cl90b19tYXJrKHZvaWQgKiBtYXJrKQp7CglyZXR1cm4gKHVpbnQzMl90ICopbWFyayAtICh1aW50MzJfdCAqKU5VTEw7Cn0KCnN0YXRpYyBpbmxpbmUgdm9pZCBtYXJrX29iamVjdChzdHJ1Y3Qgb2JqZWN0ICpvYmplY3QsIHVpbnQzMl90IG1hcmspCnsKCWFkZF9kZWNvcmF0aW9uKCZpZG51bXMsIG9iamVjdCwgbWFya190b19wdHIobWFyaykpOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQgbWFya19uZXh0X29iamVjdChzdHJ1Y3Qgb2JqZWN0ICpvYmplY3QpCnsKCW1hcmtfb2JqZWN0KG9iamVjdCwgKytsYXN0X2lkbnVtKTsKfQoKc3RhdGljIGludCBnZXRfb2JqZWN0X21hcmsoc3RydWN0IG9iamVjdCAqb2JqZWN0KQp7Cgl2b2lkICpkZWNvcmF0aW9uID0gbG9va3VwX2RlY29yYXRpb24oJmlkbnVtcywgb2JqZWN0KTsKCWlmICghZGVjb3JhdGlvbikKCQlyZXR1cm4gMDsKCXJldHVybiBwdHJfdG9fbWFyayhkZWNvcmF0aW9uKTsKfQoKc3RhdGljIHZvaWQgc2hvd19wcm9ncmVzcyh2b2lkKQp7CglzdGF0aWMgaW50IGNvdW50ZXIgPSAwOwoJaWYgKCFwcm9ncmVzcykKCQlyZXR1cm47CglpZiAoKCsrY291bnRlciAlIHByb2dyZXNzKSA9PSAwKQoJCXByaW50ZigicHJvZ3Jlc3MgJWQgb2JqZWN0c1xuIiwgY291bnRlcik7Cn0KCnN0YXRpYyB2b2lkIGhhbmRsZV9vYmplY3QoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJdW5zaWduZWQgbG9uZyBzaXplOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJY2hhciAqYnVmOwoJc3RydWN0IG9iamVjdCAqb2JqZWN0OwoKCWlmIChub19kYXRhKQoJCXJldHVybjsKCglpZiAoaXNfbnVsbF9zaGExKHNoYTEpKQoJCXJldHVybjsKCglvYmplY3QgPSBwYXJzZV9vYmplY3Qoc2hhMSk7CglpZiAoIW9iamVjdCkKCQlkaWUgKCJDb3VsZCBub3QgcmVhZCBibG9iICVzIiwgc2hhMV90b19oZXgoc2hhMSkpOwoKCWlmIChvYmplY3QtPmZsYWdzICYgU0hPV04pCgkJcmV0dXJuOwoKCWJ1ZiA9IHJlYWRfc2hhMV9maWxlKHNoYTEsICZ0eXBlLCAmc2l6ZSk7CglpZiAoIWJ1ZikKCQlkaWUgKCJDb3VsZCBub3QgcmVhZCBibG9iICVzIiwgc2hhMV90b19oZXgoc2hhMSkpOwoKCW1hcmtfbmV4dF9vYmplY3Qob2JqZWN0KTsKCglwcmludGYoImJsb2Jcbm1hcmsgOiUiUFJJdTMyIlxuZGF0YSAlbHVcbiIsIGxhc3RfaWRudW0sIHNpemUpOwoJaWYgKHNpemUgJiYgZndyaXRlKGJ1Ziwgc2l6ZSwgMSwgc3Rkb3V0KSAhPSAxKQoJCWRpZV9lcnJubyAoIkNvdWxkIG5vdCB3cml0ZSBibG9iICclcyciLCBzaGExX3RvX2hleChzaGExKSk7CglwcmludGYoIlxuIik7CgoJc2hvd19wcm9ncmVzcygpOwoKCW9iamVjdC0+ZmxhZ3MgfD0gU0hPV047CglmcmVlKGJ1Zik7Cn0KCnN0YXRpYyBpbnQgZGVwdGhfZmlyc3QoY29uc3Qgdm9pZCAqYV8sIGNvbnN0IHZvaWQgKmJfKQp7Cgljb25zdCBzdHJ1Y3QgZGlmZl9maWxlcGFpciAqYSA9ICooKGNvbnN0IHN0cnVjdCBkaWZmX2ZpbGVwYWlyICoqKWFfKTsKCWNvbnN0IHN0cnVjdCBkaWZmX2ZpbGVwYWlyICpiID0gKigoY29uc3Qgc3RydWN0IGRpZmZfZmlsZXBhaXIgKiopYl8pOwoJY29uc3QgY2hhciAqbmFtZV9hLCAqbmFtZV9iOwoJaW50IGxlbl9hLCBsZW5fYiwgbGVuOwoJaW50IGNtcDsKCgluYW1lX2EgPSBhLT5vbmUgPyBhLT5vbmUtPnBhdGggOiBhLT50d28tPnBhdGg7CgluYW1lX2IgPSBiLT5vbmUgPyBiLT5vbmUtPnBhdGggOiBiLT50d28tPnBhdGg7CgoJbGVuX2EgPSBzdHJsZW4obmFtZV9hKTsKCWxlbl9iID0gc3RybGVuKG5hbWVfYik7CglsZW4gPSAobGVuX2EgPCBsZW5fYikgPyBsZW5fYSA6IGxlbl9iOwoKCS8qIHN0cmNtcCB3aWxsIHNvcnQgJ2QnIGJlZm9yZSAnZC9lJywgd2Ugd2FudCAnZC9lJyBiZWZvcmUgJ2QnICovCgljbXAgPSBtZW1jbXAobmFtZV9hLCBuYW1lX2IsIGxlbik7CglpZiAoY21wKQoJCXJldHVybiBjbXA7CgljbXAgPSBsZW5fYiAtIGxlbl9hOwoJaWYgKGNtcCkKCQlyZXR1cm4gY21wOwoJLyoKCSAqIE1vdmUgJ1InZW5hbWUgZW50cmllcyBsYXN0IHNvIHRoYXQgYWxsIHJlZmVyZW5jZXMgb2YgdGhlIGZpbGUKCSAqIGFwcGVhciBpbiB0aGUgb3V0cHV0IGJlZm9yZSBpdCBpcyByZW5hbWVkIChlLmcuLCB3aGVuIGEgZmlsZQoJICogd2FzIGNvcGllZCBhbmQgcmVuYW1lZCBpbiB0aGUgc2FtZSBjb21taXQpLgoJICovCglyZXR1cm4gKGEtPnN0YXR1cyA9PSAnUicpIC0gKGItPnN0YXR1cyA9PSAnUicpOwp9CgpzdGF0aWMgdm9pZCBzaG93X2ZpbGVtb2RpZnkoc3RydWN0IGRpZmZfcXVldWVfc3RydWN0ICpxLAoJCQkgICAgc3RydWN0IGRpZmZfb3B0aW9ucyAqb3B0aW9ucywgdm9pZCAqZGF0YSkKewoJaW50IGk7CgoJLyoKCSAqIEhhbmRsZSBmaWxlcyBiZWxvdyBhIGRpcmVjdG9yeSBmaXJzdCwgaW4gY2FzZSB0aGV5IGFyZSBhbGwgZGVsZXRlZAoJICogYW5kIHRoZSBkaXJlY3RvcnkgY2hhbmdlcyB0byBhIGZpbGUgb3Igc3ltbGluay4KCSAqLwoJcXNvcnQocS0+cXVldWUsIHEtPm5yLCBzaXplb2YocS0+cXVldWVbMF0pLCBkZXB0aF9maXJzdCk7CgoJZm9yIChpID0gMDsgaSA8IHEtPm5yOyBpKyspIHsKCQlzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqb3NwZWMgPSBxLT5xdWV1ZVtpXS0+b25lOwoJCXN0cnVjdCBkaWZmX2ZpbGVzcGVjICpzcGVjID0gcS0+cXVldWVbaV0tPnR3bzsKCgkJc3dpdGNoIChxLT5xdWV1ZVtpXS0+c3RhdHVzKSB7CgkJY2FzZSBESUZGX1NUQVRVU19ERUxFVEVEOgoJCQlwcmludGYoIkQgJXNcbiIsIHNwZWMtPnBhdGgpOwoJCQlicmVhazsKCgkJY2FzZSBESUZGX1NUQVRVU19DT1BJRUQ6CgkJY2FzZSBESUZGX1NUQVRVU19SRU5BTUVEOgoJCQlwcmludGYoIiVjIFwiJXNcIiBcIiVzXCJcbiIsIHEtPnF1ZXVlW2ldLT5zdGF0dXMsCgkJCSAgICAgICBvc3BlYy0+cGF0aCwgc3BlYy0+cGF0aCk7CgoJCQlpZiAoIWhhc2hjbXAob3NwZWMtPnNoYTEsIHNwZWMtPnNoYTEpICYmCgkJCSAgICBvc3BlYy0+bW9kZSA9PSBzcGVjLT5tb2RlKQoJCQkJYnJlYWs7CgkJCS8qIGZhbGx0aHJvdWdoICovCgoJCWNhc2UgRElGRl9TVEFUVVNfVFlQRV9DSEFOR0VEOgoJCWNhc2UgRElGRl9TVEFUVVNfTU9ESUZJRUQ6CgkJY2FzZSBESUZGX1NUQVRVU19BRERFRDoKCQkJLyoKCQkJICogTGlua3MgcmVmZXIgdG8gb2JqZWN0cyBpbiBhbm90aGVyIHJlcG9zaXRvcmllczsKCQkJICogb3V0cHV0IHRoZSBTSEEtMSB2ZXJiYXRpbS4KCQkJICovCgkJCWlmIChub19kYXRhIHx8IFNfSVNHSVRMSU5LKHNwZWMtPm1vZGUpKQoJCQkJcHJpbnRmKCJNICUwNm8gJXMgJXNcbiIsIHNwZWMtPm1vZGUsCgkJCQkgICAgICAgc2hhMV90b19oZXgoc3BlYy0+c2hhMSksIHNwZWMtPnBhdGgpOwoJCQllbHNlIHsKCQkJCXN0cnVjdCBvYmplY3QgKm9iamVjdCA9IGxvb2t1cF9vYmplY3Qoc3BlYy0+c2hhMSk7CgkJCQlwcmludGYoIk0gJTA2byA6JWQgJXNcbiIsIHNwZWMtPm1vZGUsCgkJCQkgICAgICAgZ2V0X29iamVjdF9tYXJrKG9iamVjdCksIHNwZWMtPnBhdGgpOwoJCQl9CgkJCWJyZWFrOwoKCQlkZWZhdWx0OgoJCQlkaWUoIlVuZXhwZWN0ZWQgY29tcGFyaXNvbiBzdGF0dXMgJyVjJyBmb3IgJXMsICVzIiwKCQkJCXEtPnF1ZXVlW2ldLT5zdGF0dXMsCgkJCQlvc3BlYy0+cGF0aCA/IG9zcGVjLT5wYXRoIDogIm5vbmUiLAoJCQkJc3BlYy0+cGF0aCA/IHNwZWMtPnBhdGggOiAibm9uZSIpOwoJCX0KCX0KfQoKc3RhdGljIGNvbnN0IGNoYXIgKmZpbmRfZW5jb2RpbmcoY29uc3QgY2hhciAqYmVnaW4sIGNvbnN0IGNoYXIgKmVuZCkKewoJY29uc3QgY2hhciAqbmVlZGxlID0gIlxuZW5jb2RpbmcgIjsKCWNoYXIgKmJvbCwgKmVvbDsKCglib2wgPSBtZW1tZW0oYmVnaW4sIGVuZCA/IGVuZCAtIGJlZ2luIDogc3RybGVuKGJlZ2luKSwKCQkgICAgIG5lZWRsZSwgc3RybGVuKG5lZWRsZSkpOwoJaWYgKCFib2wpCgkJcmV0dXJuIGdpdF9jb21taXRfZW5jb2Rpbmc7Cglib2wgKz0gc3RybGVuKG5lZWRsZSk7Cgllb2wgPSBzdHJjaHJudWwoYm9sLCAnXG4nKTsKCSplb2wgPSAnXDAnOwoJcmV0dXJuIGJvbDsKfQoKc3RhdGljIHZvaWQgaGFuZGxlX2NvbW1pdChzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHN0cnVjdCByZXZfaW5mbyAqcmV2KQp7CglpbnQgc2F2ZWRfb3V0cHV0X2Zvcm1hdCA9IHJldi0+ZGlmZm9wdC5vdXRwdXRfZm9ybWF0OwoJY29uc3QgY2hhciAqYXV0aG9yLCAqYXV0aG9yX2VuZCwgKmNvbW1pdHRlciwgKmNvbW1pdHRlcl9lbmQ7Cgljb25zdCBjaGFyICplbmNvZGluZywgKm1lc3NhZ2U7CgljaGFyICpyZWVuY29kZWQgPSBOVUxMOwoJc3RydWN0IGNvbW1pdF9saXN0ICpwOwoJaW50IGk7CgoJcmV2LT5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9DQUxMQkFDSzsKCglwYXJzZV9jb21taXQoY29tbWl0KTsKCWF1dGhvciA9IHN0cnN0cihjb21taXQtPmJ1ZmZlciwgIlxuYXV0aG9yICIpOwoJaWYgKCFhdXRob3IpCgkJZGllICgiQ291bGQgbm90IGZpbmQgYXV0aG9yIGluIGNvbW1pdCAlcyIsCgkJICAgICBzaGExX3RvX2hleChjb21taXQtPm9iamVjdC5zaGExKSk7CglhdXRob3IrKzsKCWF1dGhvcl9lbmQgPSBzdHJjaHJudWwoYXV0aG9yLCAnXG4nKTsKCWNvbW1pdHRlciA9IHN0cnN0cihhdXRob3JfZW5kLCAiXG5jb21taXR0ZXIgIik7CglpZiAoIWNvbW1pdHRlcikKCQlkaWUgKCJDb3VsZCBub3QgZmluZCBjb21taXR0ZXIgaW4gY29tbWl0ICVzIiwKCQkgICAgIHNoYTFfdG9faGV4KGNvbW1pdC0+b2JqZWN0LnNoYTEpKTsKCWNvbW1pdHRlcisrOwoJY29tbWl0dGVyX2VuZCA9IHN0cmNocm51bChjb21taXR0ZXIsICdcbicpOwoJbWVzc2FnZSA9IHN0cnN0cihjb21taXR0ZXJfZW5kLCAiXG5cbiIpOwoJZW5jb2RpbmcgPSBmaW5kX2VuY29kaW5nKGNvbW1pdHRlcl9lbmQsIG1lc3NhZ2UpOwoJaWYgKG1lc3NhZ2UpCgkJbWVzc2FnZSArPSAyOwoKCWlmIChjb21taXQtPnBhcmVudHMgJiYKCSAgICBnZXRfb2JqZWN0X21hcmsoJmNvbW1pdC0+cGFyZW50cy0+aXRlbS0+b2JqZWN0KSAhPSAwKSB7CgkJcGFyc2VfY29tbWl0KGNvbW1pdC0+cGFyZW50cy0+aXRlbSk7CgkJZGlmZl90cmVlX3NoYTEoY29tbWl0LT5wYXJlbnRzLT5pdGVtLT50cmVlLT5vYmplY3Quc2hhMSwKCQkJICAgICAgIGNvbW1pdC0+dHJlZS0+b2JqZWN0LnNoYTEsICIiLCAmcmV2LT5kaWZmb3B0KTsKCX0KCWVsc2UKCQlkaWZmX3Jvb3RfdHJlZV9zaGExKGNvbW1pdC0+dHJlZS0+b2JqZWN0LnNoYTEsCgkJCQkgICAgIiIsICZyZXYtPmRpZmZvcHQpOwoKCS8qIEV4cG9ydCB0aGUgcmVmZXJlbmNlZCBibG9icywgYW5kIHJlbWVtYmVyIHRoZSBtYXJrcy4gKi8KCWZvciAoaSA9IDA7IGkgPCBkaWZmX3F1ZXVlZF9kaWZmLm5yOyBpKyspCgkJaWYgKCFTX0lTR0lUTElOSyhkaWZmX3F1ZXVlZF9kaWZmLnF1ZXVlW2ldLT50d28tPm1vZGUpKQoJCQloYW5kbGVfb2JqZWN0KGRpZmZfcXVldWVkX2RpZmYucXVldWVbaV0tPnR3by0+c2hhMSk7CgoJbWFya19uZXh0X29iamVjdCgmY29tbWl0LT5vYmplY3QpOwoJaWYgKCFpc19lbmNvZGluZ191dGY4KGVuY29kaW5nKSkKCQlyZWVuY29kZWQgPSByZWVuY29kZV9zdHJpbmcobWVzc2FnZSwgIlVURi04IiwgZW5jb2RpbmcpOwoJaWYgKCFjb21taXQtPnBhcmVudHMpCgkJcHJpbnRmKCJyZXNldCAlc1xuIiwgKGNvbnN0IGNoYXIqKWNvbW1pdC0+dXRpbCk7CglwcmludGYoImNvbW1pdCAlc1xubWFyayA6JSJQUkl1MzIiXG4lLipzXG4lLipzXG5kYXRhICV1XG4lcyIsCgkgICAgICAgKGNvbnN0IGNoYXIgKiljb21taXQtPnV0aWwsIGxhc3RfaWRudW0sCgkgICAgICAgKGludCkoYXV0aG9yX2VuZCAtIGF1dGhvciksIGF1dGhvciwKCSAgICAgICAoaW50KShjb21taXR0ZXJfZW5kIC0gY29tbWl0dGVyKSwgY29tbWl0dGVyLAoJICAgICAgICh1bnNpZ25lZCkocmVlbmNvZGVkCgkJCSAgPyBzdHJsZW4ocmVlbmNvZGVkKSA6IG1lc3NhZ2UKCQkJICA/IHN0cmxlbihtZXNzYWdlKSA6IDApLAoJICAgICAgIHJlZW5jb2RlZCA/IHJlZW5jb2RlZCA6IG1lc3NhZ2UgPyBtZXNzYWdlIDogIiIpOwoJZnJlZShyZWVuY29kZWQpOwoKCWZvciAoaSA9IDAsIHAgPSBjb21taXQtPnBhcmVudHM7IHA7IHAgPSBwLT5uZXh0KSB7CgkJaW50IG1hcmsgPSBnZXRfb2JqZWN0X21hcmsoJnAtPml0ZW0tPm9iamVjdCk7CgkJaWYgKCFtYXJrKQoJCQljb250aW51ZTsKCQlpZiAoaSA9PSAwKQoJCQlwcmludGYoImZyb20gOiVkXG4iLCBtYXJrKTsKCQllbHNlCgkJCXByaW50ZigibWVyZ2UgOiVkXG4iLCBtYXJrKTsKCQlpKys7Cgl9CgoJbG9nX3RyZWVfZGlmZl9mbHVzaChyZXYpOwoJcmV2LT5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgPSBzYXZlZF9vdXRwdXRfZm9ybWF0OwoKCXByaW50ZigiXG4iKTsKCglzaG93X3Byb2dyZXNzKCk7Cn0KCnN0YXRpYyB2b2lkIGhhbmRsZV90YWlsKHN0cnVjdCBvYmplY3RfYXJyYXkgKmNvbW1pdHMsIHN0cnVjdCByZXZfaW5mbyAqcmV2cykKewoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJd2hpbGUgKGNvbW1pdHMtPm5yKSB7CgkJY29tbWl0ID0gKHN0cnVjdCBjb21taXQgKiljb21taXRzLT5vYmplY3RzW2NvbW1pdHMtPm5yIC0gMV0uaXRlbTsKCQlpZiAoaGFzX3Vuc2hvd25fcGFyZW50KGNvbW1pdCkpCgkJCXJldHVybjsKCQloYW5kbGVfY29tbWl0KGNvbW1pdCwgcmV2cyk7CgkJY29tbWl0cy0+bnItLTsKCX0KfQoKc3RhdGljIHZvaWQgaGFuZGxlX3RhZyhjb25zdCBjaGFyICpuYW1lLCBzdHJ1Y3QgdGFnICp0YWcpCnsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCWNoYXIgKmJ1ZjsKCWNvbnN0IGNoYXIgKnRhZ2dlciwgKnRhZ2dlcl9lbmQsICptZXNzYWdlOwoJc2l6ZV90IG1lc3NhZ2Vfc2l6ZSA9IDA7CglzdHJ1Y3Qgb2JqZWN0ICp0YWdnZWQ7CglpbnQgdGFnZ2VkX21hcms7CglzdHJ1Y3QgY29tbWl0ICpwOwoKCS8qIFRyZWVzIGhhdmUgbm8gaWRlbnRpZmVyIGluIGZhc3QtZXhwb3J0IG91dHB1dCwgdGh1cyB3ZSBoYXZlIG5vIHdheQoJICogdG8gb3V0cHV0IHRhZ3Mgb2YgdHJlZXMsIHRhZ3Mgb2YgdGFncyBvZiB0cmVlcywgZXRjLiAgU2ltcGx5IG9taXQKCSAqIHN1Y2ggdGFncy4KCSAqLwoJdGFnZ2VkID0gdGFnLT50YWdnZWQ7Cgl3aGlsZSAodGFnZ2VkLT50eXBlID09IE9CSl9UQUcpIHsKCQl0YWdnZWQgPSAoKHN0cnVjdCB0YWcgKil0YWdnZWQpLT50YWdnZWQ7Cgl9CglpZiAodGFnZ2VkLT50eXBlID09IE9CSl9UUkVFKSB7CgkJd2FybmluZygiT21pdHRpbmcgdGFnICVzLFxuc2luY2UgdGFncyBvZiB0cmVlcyAob3IgdGFncyBvZiB0YWdzIG9mIHRyZWVzLCBldGMuKSBhcmUgbm90IHN1cHBvcnRlZC4iLAoJCQlzaGExX3RvX2hleCh0YWctPm9iamVjdC5zaGExKSk7CgkJcmV0dXJuOwoJfQoKCWJ1ZiA9IHJlYWRfc2hhMV9maWxlKHRhZy0+b2JqZWN0LnNoYTEsICZ0eXBlLCAmc2l6ZSk7CglpZiAoIWJ1ZikKCQlkaWUgKCJDb3VsZCBub3QgcmVhZCB0YWcgJXMiLCBzaGExX3RvX2hleCh0YWctPm9iamVjdC5zaGExKSk7CgltZXNzYWdlID0gbWVtbWVtKGJ1Ziwgc2l6ZSwgIlxuXG4iLCAyKTsKCWlmIChtZXNzYWdlKSB7CgkJbWVzc2FnZSArPSAyOwoJCW1lc3NhZ2Vfc2l6ZSA9IHN0cmxlbihtZXNzYWdlKTsKCX0KCXRhZ2dlciA9IG1lbW1lbShidWYsIG1lc3NhZ2UgPyBtZXNzYWdlIC0gYnVmIDogc2l6ZSwgIlxudGFnZ2VyICIsIDgpOwoJaWYgKCF0YWdnZXIpIHsKCQlpZiAoZmFrZV9taXNzaW5nX3RhZ2dlcikKCQkJdGFnZ2VyID0gInRhZ2dlciBVbnNwZWNpZmllZCBUYWdnZXIgIgoJCQkJIjx1bnNwZWNpZmllZC10YWdnZXI+IDAgKzAwMDAiOwoJCWVsc2UKCQkJdGFnZ2VyID0gIiI7CgkJdGFnZ2VyX2VuZCA9IHRhZ2dlciArIHN0cmxlbih0YWdnZXIpOwoJfSBlbHNlIHsKCQl0YWdnZXIrKzsKCQl0YWdnZXJfZW5kID0gc3RyY2hybnVsKHRhZ2dlciwgJ1xuJyk7Cgl9CgoJLyogaGFuZGxlIHNpZ25lZCB0YWdzICovCglpZiAobWVzc2FnZSkgewoJCWNvbnN0IGNoYXIgKnNpZ25hdHVyZSA9IHN0cnN0cihtZXNzYWdlLAoJCQkJCSAgICAgICAiXG4tLS0tLUJFR0lOIFBHUCBTSUdOQVRVUkUtLS0tLVxuIik7CgkJaWYgKHNpZ25hdHVyZSkKCQkJc3dpdGNoKHNpZ25lZF90YWdfbW9kZSkgewoJCQljYXNlIEFCT1JUOgoJCQkJZGllICgiRW5jb3VudGVyZWQgc2lnbmVkIHRhZyAlczsgdXNlICIKCQkJCSAgICAgIi0tc2lnbmVkLXRhZz08bW9kZT4gdG8gaGFuZGxlIGl0LiIsCgkJCQkgICAgIHNoYTFfdG9faGV4KHRhZy0+b2JqZWN0LnNoYTEpKTsKCQkJY2FzZSBXQVJOOgoJCQkJd2FybmluZyAoIkV4cG9ydGluZyBzaWduZWQgdGFnICVzIiwKCQkJCQkgc2hhMV90b19oZXgodGFnLT5vYmplY3Quc2hhMSkpOwoJCQkJLyogZmFsbHRocnUgKi8KCQkJY2FzZSBWRVJCQVRJTToKCQkJCWJyZWFrOwoJCQljYXNlIFNUUklQOgoJCQkJbWVzc2FnZV9zaXplID0gc2lnbmF0dXJlICsgMSAtIG1lc3NhZ2U7CgkJCQlicmVhazsKCQkJfQoJfQoKCS8qIGhhbmRsZSB0YWctPnRhZ2dlZCBoYXZpbmcgYmVlbiBmaWx0ZXJlZCBvdXQgZHVlIHRvIHBhdGhzIHNwZWNpZmllZCAqLwoJdGFnZ2VkID0gdGFnLT50YWdnZWQ7Cgl0YWdnZWRfbWFyayA9IGdldF9vYmplY3RfbWFyayh0YWdnZWQpOwoJaWYgKCF0YWdnZWRfbWFyaykgewoJCXN3aXRjaCh0YWdfb2ZfZmlsdGVyZWRfbW9kZSkgewoJCWNhc2UgQUJPUlQ6CgkJCWRpZSAoIlRhZyAlcyB0YWdzIHVuZXhwb3J0ZWQgb2JqZWN0OyB1c2UgIgoJCQkgICAgICItLXRhZy1vZi1maWx0ZXJlZC1vYmplY3Q9PG1vZGU+IHRvIGhhbmRsZSBpdC4iLAoJCQkgICAgIHNoYTFfdG9faGV4KHRhZy0+b2JqZWN0LnNoYTEpKTsKCQljYXNlIERST1A6CgkJCS8qIElnbm9yZSB0aGlzIHRhZyBhbHRvZ2V0aGVyICovCgkJCXJldHVybjsKCQljYXNlIFJFV1JJVEU6CgkJCWlmICh0YWdnZWQtPnR5cGUgIT0gT0JKX0NPTU1JVCkgewoJCQkJZGllICgiVGFnICVzIHRhZ3MgdW5leHBvcnRlZCAlcyEiLAoJCQkJICAgICBzaGExX3RvX2hleCh0YWctPm9iamVjdC5zaGExKSwKCQkJCSAgICAgdHlwZW5hbWUodGFnZ2VkLT50eXBlKSk7CgkJCX0KCQkJcCA9IChzdHJ1Y3QgY29tbWl0ICopdGFnZ2VkOwoJCQlmb3IgKDs7KSB7CgkJCQlpZiAocC0+cGFyZW50cyAmJiBwLT5wYXJlbnRzLT5uZXh0KQoJCQkJCWJyZWFrOwoJCQkJaWYgKHAtPm9iamVjdC5mbGFncyAmIFVOSU5URVJFU1RJTkcpCgkJCQkJYnJlYWs7CgkJCQlpZiAoIShwLT5vYmplY3QuZmxhZ3MgJiBUUkVFU0FNRSkpCgkJCQkJYnJlYWs7CgkJCQlpZiAoIXAtPnBhcmVudHMpCgkJCQkJZGllICgiQ2FuJ3QgZmluZCByZXBsYWNlbWVudCBjb21taXQgZm9yIHRhZyAlc1xuIiwKCQkJCQkgICAgIHNoYTFfdG9faGV4KHRhZy0+b2JqZWN0LnNoYTEpKTsKCQkJCXAgPSBwLT5wYXJlbnRzLT5pdGVtOwoJCQl9CgkJCXRhZ2dlZF9tYXJrID0gZ2V0X29iamVjdF9tYXJrKCZwLT5vYmplY3QpOwoJCX0KCX0KCglpZiAoIXByZWZpeGNtcChuYW1lLCAicmVmcy90YWdzLyIpKQoJCW5hbWUgKz0gMTA7CglwcmludGYoInRhZyAlc1xuZnJvbSA6JWRcbiUuKnMlc2RhdGEgJWRcbiUuKnNcbiIsCgkgICAgICAgbmFtZSwgdGFnZ2VkX21hcmssCgkgICAgICAgKGludCkodGFnZ2VyX2VuZCAtIHRhZ2dlciksIHRhZ2dlciwKCSAgICAgICB0YWdnZXIgPT0gdGFnZ2VyX2VuZCA/ICIiIDogIlxuIiwKCSAgICAgICAoaW50KW1lc3NhZ2Vfc2l6ZSwgKGludCltZXNzYWdlX3NpemUsIG1lc3NhZ2UgPyBtZXNzYWdlIDogIiIpOwp9CgpzdGF0aWMgdm9pZCBnZXRfdGFnc19hbmRfZHVwbGljYXRlcyhzdHJ1Y3Qgb2JqZWN0X2FycmF5ICpwZW5kaW5nLAoJCQkJICAgIHN0cnVjdCBzdHJpbmdfbGlzdCAqZXh0cmFfcmVmcykKewoJc3RydWN0IHRhZyAqdGFnOwoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IHBlbmRpbmctPm5yOyBpKyspIHsKCQlzdHJ1Y3Qgb2JqZWN0X2FycmF5X2VudHJ5ICplID0gcGVuZGluZy0+b2JqZWN0cyArIGk7CgkJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBjb21taXQ7CgkJY2hhciAqZnVsbF9uYW1lOwoKCQlpZiAoZHdpbV9yZWYoZS0+bmFtZSwgc3RybGVuKGUtPm5hbWUpLCBzaGExLCAmZnVsbF9uYW1lKSAhPSAxKQoJCQljb250aW51ZTsKCgkJc3dpdGNoIChlLT5pdGVtLT50eXBlKSB7CgkJY2FzZSBPQkpfQ09NTUlUOgoJCQljb21taXQgPSAoc3RydWN0IGNvbW1pdCAqKWUtPml0ZW07CgkJCWJyZWFrOwoJCWNhc2UgT0JKX1RBRzoKCQkJdGFnID0gKHN0cnVjdCB0YWcgKillLT5pdGVtOwoKCQkJLyogaGFuZGxlIG5lc3RlZCB0YWdzICovCgkJCXdoaWxlICh0YWcgJiYgdGFnLT5vYmplY3QudHlwZSA9PSBPQkpfVEFHKSB7CgkJCQlwYXJzZV9vYmplY3QodGFnLT5vYmplY3Quc2hhMSk7CgkJCQlzdHJpbmdfbGlzdF9hcHBlbmQoZnVsbF9uYW1lLCBleHRyYV9yZWZzKS0+dXRpbCA9IHRhZzsKCQkJCXRhZyA9IChzdHJ1Y3QgdGFnICopdGFnLT50YWdnZWQ7CgkJCX0KCQkJaWYgKCF0YWcpCgkJCQlkaWUgKCJUYWcgJXMgcG9pbnRzIG5vd2hlcmU/IiwgZS0+bmFtZSk7CgkJCXN3aXRjaCh0YWctPm9iamVjdC50eXBlKSB7CgkJCWNhc2UgT0JKX0NPTU1JVDoKCQkJCWNvbW1pdCA9IChzdHJ1Y3QgY29tbWl0ICopdGFnOwoJCQkJYnJlYWs7CgkJCWNhc2UgT0JKX0JMT0I6CgkJCQloYW5kbGVfb2JqZWN0KHRhZy0+b2JqZWN0LnNoYTEpOwoJCQkJY29udGludWU7CgkJCWRlZmF1bHQ6IC8qIE9CSl9UQUcgKG5lc3RlZCB0YWdzKSBpcyBhbHJlYWR5IGhhbmRsZWQgKi8KCQkJCXdhcm5pbmcoIlRhZyBwb2ludHMgdG8gb2JqZWN0IG9mIHVuZXhwZWN0ZWQgdHlwZSAlcywgc2tpcHBpbmcuIiwKCQkJCQl0eXBlbmFtZSh0YWctPm9iamVjdC50eXBlKSk7CgkJCQljb250aW51ZTsKCQkJfQoJCQlicmVhazsKCQlkZWZhdWx0OgoJCQl3YXJuaW5nKCIlczogVW5leHBlY3RlZCBvYmplY3Qgb2YgdHlwZSAlcywgc2tpcHBpbmcuIiwKCQkJCWUtPm5hbWUsCgkJCQl0eXBlbmFtZShlLT5pdGVtLT50eXBlKSk7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoY29tbWl0LT51dGlsKQoJCQkvKiBtb3JlIHRoYW4gb25lIG5hbWUgZm9yIHRoZSBzYW1lIG9iamVjdCAqLwoJCQlzdHJpbmdfbGlzdF9hcHBlbmQoZnVsbF9uYW1lLCBleHRyYV9yZWZzKS0+dXRpbCA9IGNvbW1pdDsKCQllbHNlCgkJCWNvbW1pdC0+dXRpbCA9IGZ1bGxfbmFtZTsKCX0KfQoKc3RhdGljIHZvaWQgaGFuZGxlX3RhZ3NfYW5kX2R1cGxpY2F0ZXMoc3RydWN0IHN0cmluZ19saXN0ICpleHRyYV9yZWZzKQp7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CglpbnQgaTsKCglmb3IgKGkgPSBleHRyYV9yZWZzLT5uciAtIDE7IGkgPj0gMDsgaS0tKSB7CgkJY29uc3QgY2hhciAqbmFtZSA9IGV4dHJhX3JlZnMtPml0ZW1zW2ldLnN0cmluZzsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmplY3QgPSBleHRyYV9yZWZzLT5pdGVtc1tpXS51dGlsOwoJCXN3aXRjaCAob2JqZWN0LT50eXBlKSB7CgkJY2FzZSBPQkpfVEFHOgoJCQloYW5kbGVfdGFnKG5hbWUsIChzdHJ1Y3QgdGFnICopb2JqZWN0KTsKCQkJYnJlYWs7CgkJY2FzZSBPQkpfQ09NTUlUOgoJCQkvKiBjcmVhdGUgcmVmcyBwb2ludGluZyB0byBhbHJlYWR5IHNlZW4gY29tbWl0cyAqLwoJCQljb21taXQgPSAoc3RydWN0IGNvbW1pdCAqKW9iamVjdDsKCQkJcHJpbnRmKCJyZXNldCAlc1xuZnJvbSA6JWRcblxuIiwgbmFtZSwKCQkJICAgICAgIGdldF9vYmplY3RfbWFyaygmY29tbWl0LT5vYmplY3QpKTsKCQkJc2hvd19wcm9ncmVzcygpOwoJCQlicmVhazsKCQl9Cgl9Cn0KCnN0YXRpYyB2b2lkIGV4cG9ydF9tYXJrcyhjaGFyICpmaWxlKQp7Cgl1bnNpZ25lZCBpbnQgaTsKCXVpbnQzMl90IG1hcms7CglzdHJ1Y3Qgb2JqZWN0X2RlY29yYXRpb24gKmRlY28gPSBpZG51bXMuaGFzaDsKCUZJTEUgKmY7CglpbnQgZSA9IDA7CgoJZiA9IGZvcGVuKGZpbGUsICJ3Iik7CglpZiAoIWYpCgkJZGllX2Vycm5vKCJVbmFibGUgdG8gb3BlbiBtYXJrcyBmaWxlICVzIGZvciB3cml0aW5nLiIsIGZpbGUpOwoKCWZvciAoaSA9IDA7IGkgPCBpZG51bXMuc2l6ZTsgaSsrKSB7CgkJaWYgKGRlY28tPmJhc2UgJiYgZGVjby0+YmFzZS0+dHlwZSA9PSAxKSB7CgkJCW1hcmsgPSBwdHJfdG9fbWFyayhkZWNvLT5kZWNvcmF0aW9uKTsKCQkJaWYgKGZwcmludGYoZiwgIjolIlBSSXUzMiIgJXNcbiIsIG1hcmssCgkJCQlzaGExX3RvX2hleChkZWNvLT5iYXNlLT5zaGExKSkgPCAwKSB7CgkJCSAgICBlID0gMTsKCQkJICAgIGJyZWFrOwoJCQl9CgkJfQoJCWRlY28rKzsKCX0KCgllIHw9IGZlcnJvcihmKTsKCWUgfD0gZmNsb3NlKGYpOwoJaWYgKGUpCgkJZXJyb3IoIlVuYWJsZSB0byB3cml0ZSBtYXJrcyBmaWxlICVzLiIsIGZpbGUpOwp9CgpzdGF0aWMgdm9pZCBpbXBvcnRfbWFya3MoY2hhciAqaW5wdXRfZmlsZSkKewoJY2hhciBsaW5lWzUxMl07CglGSUxFICpmID0gZm9wZW4oaW5wdXRfZmlsZSwgInIiKTsKCWlmICghZikKCQlkaWVfZXJybm8oImNhbm5vdCByZWFkICclcyciLCBpbnB1dF9maWxlKTsKCgl3aGlsZSAoZmdldHMobGluZSwgc2l6ZW9mKGxpbmUpLCBmKSkgewoJCXVpbnQzMl90IG1hcms7CgkJY2hhciAqbGluZV9lbmQsICptYXJrX2VuZDsKCQl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJCXN0cnVjdCBvYmplY3QgKm9iamVjdDsKCgkJbGluZV9lbmQgPSBzdHJjaHIobGluZSwgJ1xuJyk7CgkJaWYgKGxpbmVbMF0gIT0gJzonIHx8ICFsaW5lX2VuZCkKCQkJZGllKCJjb3JydXB0IG1hcmsgbGluZTogJXMiLCBsaW5lKTsKCQkqbGluZV9lbmQgPSAnXDAnOwoKCQltYXJrID0gc3RydG91bWF4KGxpbmUgKyAxLCAmbWFya19lbmQsIDEwKTsKCQlpZiAoIW1hcmsgfHwgbWFya19lbmQgPT0gbGluZSArIDEKCQkJfHwgKm1hcmtfZW5kICE9ICcgJyB8fCBnZXRfc2hhMShtYXJrX2VuZCArIDEsIHNoYTEpKQoJCQlkaWUoImNvcnJ1cHQgbWFyayBsaW5lOiAlcyIsIGxpbmUpOwoKCQlvYmplY3QgPSBwYXJzZV9vYmplY3Qoc2hhMSk7CgkJaWYgKCFvYmplY3QpCgkJCWRpZSAoIkNvdWxkIG5vdCByZWFkIGJsb2IgJXMiLCBzaGExX3RvX2hleChzaGExKSk7CgoJCWlmIChvYmplY3QtPmZsYWdzICYgU0hPV04pCgkJCWVycm9yKCJPYmplY3QgJXMgYWxyZWFkeSBoYXMgYSBtYXJrIiwgc2hhMSk7CgoJCW1hcmtfb2JqZWN0KG9iamVjdCwgbWFyayk7CgkJaWYgKGxhc3RfaWRudW0gPCBtYXJrKQoJCQlsYXN0X2lkbnVtID0gbWFyazsKCgkJb2JqZWN0LT5mbGFncyB8PSBTSE9XTjsKCX0KCWZjbG9zZShmKTsKfQoKaW50IGNtZF9mYXN0X2V4cG9ydChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IHJldl9pbmZvIHJldnM7CglzdHJ1Y3Qgb2JqZWN0X2FycmF5IGNvbW1pdHMgPSB7IDAsIDAsIE5VTEwgfTsKCXN0cnVjdCBzdHJpbmdfbGlzdCBleHRyYV9yZWZzID0geyBOVUxMLCAwLCAwLCAwIH07CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgljaGFyICpleHBvcnRfZmlsZW5hbWUgPSBOVUxMLCAqaW1wb3J0X2ZpbGVuYW1lID0gTlVMTDsKCXN0cnVjdCBvcHRpb24gb3B0aW9uc1tdID0gewoJCU9QVF9JTlRFR0VSKDAsICJwcm9ncmVzcyIsICZwcm9ncmVzcywKCQkJICAgICJzaG93IHByb2dyZXNzIGFmdGVyIDxuPiBvYmplY3RzIiksCgkJT1BUX0NBTExCQUNLKDAsICJzaWduZWQtdGFncyIsICZzaWduZWRfdGFnX21vZGUsICJtb2RlIiwKCQkJICAgICAic2VsZWN0IGhhbmRsaW5nIG9mIHNpZ25lZCB0YWdzIiwKCQkJICAgICBwYXJzZV9vcHRfc2lnbmVkX3RhZ19tb2RlKSwKCQlPUFRfQ0FMTEJBQ0soMCwgInRhZy1vZi1maWx0ZXJlZC1vYmplY3QiLCAmdGFnX29mX2ZpbHRlcmVkX21vZGUsICJtb2RlIiwKCQkJICAgICAic2VsZWN0IGhhbmRsaW5nIG9mIHRhZ3MgdGhhdCB0YWcgZmlsdGVyZWQgb2JqZWN0cyIsCgkJCSAgICAgcGFyc2Vfb3B0X3RhZ19vZl9maWx0ZXJlZF9tb2RlKSwKCQlPUFRfU1RSSU5HKDAsICJleHBvcnQtbWFya3MiLCAmZXhwb3J0X2ZpbGVuYW1lLCAiRklMRSIsCgkJCSAgICAgIkR1bXAgbWFya3MgdG8gdGhpcyBmaWxlIiksCgkJT1BUX1NUUklORygwLCAiaW1wb3J0LW1hcmtzIiwgJmltcG9ydF9maWxlbmFtZSwgIkZJTEUiLAoJCQkgICAgICJJbXBvcnQgbWFya3MgZnJvbSB0aGlzIGZpbGUiKSwKCQlPUFRfQk9PTEVBTigwLCAiZmFrZS1taXNzaW5nLXRhZ2dlciIsICZmYWtlX21pc3NpbmdfdGFnZ2VyLAoJCQkgICAgICJGYWtlIGEgdGFnZ2VyIHdoZW4gdGFncyBsYWNrIG9uZSIpLAoJCXsgT1BUSU9OX05FR0JJVCwgMCwgImRhdGEiLCAmbm9fZGF0YSwgTlVMTCwKCQkJIlNraXAgb3V0cHV0IG9mIGJsb2IgZGF0YSIsCgkJCVBBUlNFX09QVF9OT0FSRyB8IFBBUlNFX09QVF9ORUdIRUxQLCBOVUxMLCAxIH0sCgkJT1BUX0VORCgpCgl9OwoKCWlmIChhcmdjID09IDEpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zIChmYXN0X2V4cG9ydF91c2FnZSwgb3B0aW9ucyk7CgoJLyogd2UgaGFuZGxlIGVuY29kaW5ncyAqLwoJZ2l0X2NvbmZpZyhnaXRfZGVmYXVsdF9jb25maWcsIE5VTEwpOwoKCWluaXRfcmV2aXNpb25zKCZyZXZzLCBwcmVmaXgpOwoJcmV2cy50b3BvX29yZGVyID0gMTsKCXJldnMuc2hvd19zb3VyY2UgPSAxOwoJcmV2cy5yZXdyaXRlX3BhcmVudHMgPSAxOwoJYXJnYyA9IHNldHVwX3JldmlzaW9ucyhhcmdjLCBhcmd2LCAmcmV2cywgTlVMTCk7CglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIG9wdGlvbnMsIGZhc3RfZXhwb3J0X3VzYWdlLCAwKTsKCWlmIChhcmdjID4gMSkKCQl1c2FnZV93aXRoX29wdGlvbnMgKGZhc3RfZXhwb3J0X3VzYWdlLCBvcHRpb25zKTsKCglpZiAoaW1wb3J0X2ZpbGVuYW1lKQoJCWltcG9ydF9tYXJrcyhpbXBvcnRfZmlsZW5hbWUpOwoKCWdldF90YWdzX2FuZF9kdXBsaWNhdGVzKCZyZXZzLnBlbmRpbmcsICZleHRyYV9yZWZzKTsKCglpZiAocHJlcGFyZV9yZXZpc2lvbl93YWxrKCZyZXZzKSkKCQlkaWUoInJldmlzaW9uIHdhbGsgc2V0dXAgZmFpbGVkIik7CglyZXZzLmRpZmZvcHQuZm9ybWF0X2NhbGxiYWNrID0gc2hvd19maWxlbW9kaWZ5OwoJRElGRl9PUFRfU0VUKCZyZXZzLmRpZmZvcHQsIFJFQ1VSU0lWRSk7Cgl3aGlsZSAoKGNvbW1pdCA9IGdldF9yZXZpc2lvbigmcmV2cykpKSB7CgkJaWYgKGhhc191bnNob3duX3BhcmVudChjb21taXQpKSB7CgkJCWFkZF9vYmplY3RfYXJyYXkoJmNvbW1pdC0+b2JqZWN0LCBOVUxMLCAmY29tbWl0cyk7CgkJfQoJCWVsc2UgewoJCQloYW5kbGVfY29tbWl0KGNvbW1pdCwgJnJldnMpOwoJCQloYW5kbGVfdGFpbCgmY29tbWl0cywgJnJldnMpOwoJCX0KCX0KCgloYW5kbGVfdGFnc19hbmRfZHVwbGljYXRlcygmZXh0cmFfcmVmcyk7CgoJaWYgKGV4cG9ydF9maWxlbmFtZSkKCQlleHBvcnRfbWFya3MoZXhwb3J0X2ZpbGVuYW1lKTsKCglyZXR1cm4gMDsKfQo=",
    "text": "/*\n * \"git fast-export\" builtin command\n *\n * Copyright (C) 2007 Johannes E. Schindelin\n */\n#include \"builtin.h\"\n#include \"cache.h\"\n#include \"commit.h\"\n#include \"object.h\"\n#include \"tag.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"log-tree.h\"\n#include \"revision.h\"\n#include \"decorate.h\"\n#include \"string-list.h\"\n#include \"utf8.h\"\n#include \"parse-options.h\"\n\nstatic const char *fast_export_usage[] = {\n\t\"git fast-export [rev-list-opts]\",\n\tNULL\n};\n\nstatic int progress;\nstatic enum { ABORT, VERBATIM, WARN, STRIP } signed_tag_mode = ABORT;\nstatic enum { ERROR, DROP, REWRITE } tag_of_filtered_mode = ABORT;\nstatic int fake_missing_tagger;\nstatic int no_data;\n\nstatic int parse_opt_signed_tag_mode(const struct option *opt,\n\t\t\t\t     const char *arg, int unset)\n{\n\tif (unset || !strcmp(arg, \"abort\"))\n\t\tsigned_tag_mode = ABORT;\n\telse if (!strcmp(arg, \"verbatim\") || !strcmp(arg, \"ignore\"))\n\t\tsigned_tag_mode = VERBATIM;\n\telse if (!strcmp(arg, \"warn\"))\n\t\tsigned_tag_mode = WARN;\n\telse if (!strcmp(arg, \"strip\"))\n\t\tsigned_tag_mode = STRIP;\n\telse\n\t\treturn error(\"Unknown signed-tag mode: %s\", arg);\n\treturn 0;\n}\n\nstatic int parse_opt_tag_of_filtered_mode(const struct option *opt,\n\t\t\t\t\t  const char *arg, int unset)\n{\n\tif (unset || !strcmp(arg, \"abort\"))\n\t\ttag_of_filtered_mode = ABORT;\n\telse if (!strcmp(arg, \"drop\"))\n\t\ttag_of_filtered_mode = DROP;\n\telse if (!strcmp(arg, \"rewrite\"))\n\t\ttag_of_filtered_mode = REWRITE;\n\telse\n\t\treturn error(\"Unknown tag-of-filtered mode: %s\", arg);\n\treturn 0;\n}\n\nstatic struct decoration idnums;\nstatic uint32_t last_idnum;\n\nstatic int has_unshown_parent(struct commit *commit)\n{\n\tstruct commit_list *parent;\n\n\tfor (parent = commit->parents; parent; parent = parent->next)\n\t\tif (!(parent->item->object.flags & SHOWN) &&\n\t\t    !(parent->item->object.flags & UNINTERESTING))\n\t\t\treturn 1;\n\treturn 0;\n}\n\n/* Since intptr_t is C99, we do not use it here */\nstatic inline uint32_t *mark_to_ptr(uint32_t mark)\n{\n\treturn ((uint32_t *)NULL) + mark;\n}\n\nstatic inline uint32_t ptr_to_mark(void * mark)\n{\n\treturn (uint32_t *)mark - (uint32_t *)NULL;\n}\n\nstatic inline void mark_object(struct object *object, uint32_t mark)\n{\n\tadd_decoration(&idnums, object, mark_to_ptr(mark));\n}\n\nstatic inline void mark_next_object(struct object *object)\n{\n\tmark_object(object, ++last_idnum);\n}\n\nstatic int get_object_mark(struct object *object)\n{\n\tvoid *decoration = lookup_decoration(&idnums, object);\n\tif (!decoration)\n\t\treturn 0;\n\treturn ptr_to_mark(decoration);\n}\n\nstatic void show_progress(void)\n{\n\tstatic int counter = 0;\n\tif (!progress)\n\t\treturn;\n\tif ((++counter % progress) == 0)\n\t\tprintf(\"progress %d objects\\n\", counter);\n}\n\nstatic void handle_object(const unsigned char *sha1)\n{\n\tunsigned long size;\n\tenum object_type type;\n\tchar *buf;\n\tstruct object *object;\n\n\tif (no_data)\n\t\treturn;\n\n\tif (is_null_sha1(sha1))\n\t\treturn;\n\n\tobject = parse_object(sha1);\n\tif (!object)\n\t\tdie (\"Could not read blob %s\", sha1_to_hex(sha1));\n\n\tif (object->flags & SHOWN)\n\t\treturn;\n\n\tbuf = read_sha1_file(sha1, &type, &size);\n\tif (!buf)\n\t\tdie (\"Could not read blob %s\", sha1_to_hex(sha1));\n\n\tmark_next_object(object);\n\n\tprintf(\"blob\\nmark :%\"PRIu32\"\\ndata %lu\\n\", last_idnum, size);\n\tif (size && fwrite(buf, size, 1, stdout) != 1)\n\t\tdie_errno (\"Could not write blob '%s'\", sha1_to_hex(sha1));\n\tprintf(\"\\n\");\n\n\tshow_progress();\n\n\tobject->flags |= SHOWN;\n\tfree(buf);\n}\n\nstatic int depth_first(const void *a_, const void *b_)\n{\n\tconst struct diff_filepair *a = *((const struct diff_filepair **)a_);\n\tconst struct diff_filepair *b = *((const struct diff_filepair **)b_);\n\tconst char *name_a, *name_b;\n\tint len_a, len_b, len;\n\tint cmp;\n\n\tname_a = a->one ? a->one->path : a->two->path;\n\tname_b = b->one ? b->one->path : b->two->path;\n\n\tlen_a = strlen(name_a);\n\tlen_b = strlen(name_b);\n\tlen = (len_a < len_b) ? len_a : len_b;\n\n\t/* strcmp will sort 'd' before 'd/e', we want 'd/e' before 'd' */\n\tcmp = memcmp(name_a, name_b, len);\n\tif (cmp)\n\t\treturn cmp;\n\tcmp = len_b - len_a;\n\tif (cmp)\n\t\treturn cmp;\n\t/*\n\t * Move 'R'ename entries last so that all references of the file\n\t * appear in the output before it is renamed (e.g., when a file\n\t * was copied and renamed in the same commit).\n\t */\n\treturn (a->status == 'R') - (b->status == 'R');\n}\n\nstatic void show_filemodify(struct diff_queue_struct *q,\n\t\t\t    struct diff_options *options, void *data)\n{\n\tint i;\n\n\t/*\n\t * Handle files below a directory first, in case they are all deleted\n\t * and the directory changes to a file or symlink.\n\t */\n\tqsort(q->queue, q->nr, sizeof(q->queue[0]), depth_first);\n\n\tfor (i = 0; i < q->nr; i++) {\n\t\tstruct diff_filespec *ospec = q->queue[i]->one;\n\t\tstruct diff_filespec *spec = q->queue[i]->two;\n\n\t\tswitch (q->queue[i]->status) {\n\t\tcase DIFF_STATUS_DELETED:\n\t\t\tprintf(\"D %s\\n\", spec->path);\n\t\t\tbreak;\n\n\t\tcase DIFF_STATUS_COPIED:\n\t\tcase DIFF_STATUS_RENAMED:\n\t\t\tprintf(\"%c \\\"%s\\\" \\\"%s\\\"\\n\", q->queue[i]->status,\n\t\t\t       ospec->path, spec->path);\n\n\t\t\tif (!hashcmp(ospec->sha1, spec->sha1) &&\n\t\t\t    ospec->mode == spec->mode)\n\t\t\t\tbreak;\n\t\t\t/* fallthrough */\n\n\t\tcase DIFF_STATUS_TYPE_CHANGED:\n\t\tcase DIFF_STATUS_MODIFIED:\n\t\tcase DIFF_STATUS_ADDED:\n\t\t\t/*\n\t\t\t * Links refer to objects in another repositories;\n\t\t\t * output the SHA-1 verbatim.\n\t\t\t */\n\t\t\tif (no_data || S_ISGITLINK(spec->mode))\n\t\t\t\tprintf(\"M %06o %s %s\\n\", spec->mode,\n\t\t\t\t       sha1_to_hex(spec->sha1), spec->path);\n\t\t\telse {\n\t\t\t\tstruct object *object = lookup_object(spec->sha1);\n\t\t\t\tprintf(\"M %06o :%d %s\\n\", spec->mode,\n\t\t\t\t       get_object_mark(object), spec->path);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdie(\"Unexpected comparison status '%c' for %s, %s\",\n\t\t\t\tq->queue[i]->status,\n\t\t\t\tospec->path ? ospec->path : \"none\",\n\t\t\t\tspec->path ? spec->path : \"none\");\n\t\t}\n\t}\n}\n\nstatic const char *find_encoding(const char *begin, const char *end)\n{\n\tconst char *needle = \"\\nencoding \";\n\tchar *bol, *eol;\n\n\tbol = memmem(begin, end ? end - begin : strlen(begin),\n\t\t     needle, strlen(needle));\n\tif (!bol)\n\t\treturn git_commit_encoding;\n\tbol += strlen(needle);\n\teol = strchrnul(bol, '\\n');\n\t*eol = '\\0';\n\treturn bol;\n}\n\nstatic void handle_commit(struct commit *commit, struct rev_info *rev)\n{\n\tint saved_output_format = rev->diffopt.output_format;\n\tconst char *author, *author_end, *committer, *committer_end;\n\tconst char *encoding, *message;\n\tchar *reencoded = NULL;\n\tstruct commit_list *p;\n\tint i;\n\n\trev->diffopt.output_format = DIFF_FORMAT_CALLBACK;\n\n\tparse_commit(commit);\n\tauthor = strstr(commit->buffer, \"\\nauthor \");\n\tif (!author)\n\t\tdie (\"Could not find author in commit %s\",\n\t\t     sha1_to_hex(commit->object.sha1));\n\tauthor++;\n\tauthor_end = strchrnul(author, '\\n');\n\tcommitter = strstr(author_end, \"\\ncommitter \");\n\tif (!committer)\n\t\tdie (\"Could not find committer in commit %s\",\n\t\t     sha1_to_hex(commit->object.sha1));\n\tcommitter++;\n\tcommitter_end = strchrnul(committer, '\\n');\n\tmessage = strstr(committer_end, \"\\n\\n\");\n\tencoding = find_encoding(committer_end, message);\n\tif (message)\n\t\tmessage += 2;\n\n\tif (commit->parents &&\n\t    get_object_mark(&commit->parents->item->object) != 0) {\n\t\tparse_commit(commit->parents->item);\n\t\tdiff_tree_sha1(commit->parents->item->tree->object.sha1,\n\t\t\t       commit->tree->object.sha1, \"\", &rev->diffopt);\n\t}\n\telse\n\t\tdiff_root_tree_sha1(commit->tree->object.sha1,\n\t\t\t\t    \"\", &rev->diffopt);\n\n\t/* Export the referenced blobs, and remember the marks. */\n\tfor (i = 0; i < diff_queued_diff.nr; i++)\n\t\tif (!S_ISGITLINK(diff_queued_diff.queue[i]->two->mode))\n\t\t\thandle_object(diff_queued_diff.queue[i]->two->sha1);\n\n\tmark_next_object(&commit->object);\n\tif (!is_encoding_utf8(encoding))\n\t\treencoded = reencode_string(message, \"UTF-8\", encoding);\n\tif (!commit->parents)\n\t\tprintf(\"reset %s\\n\", (const char*)commit->util);\n\tprintf(\"commit %s\\nmark :%\"PRIu32\"\\n%.*s\\n%.*s\\ndata %u\\n%s\",\n\t       (const char *)commit->util, last_idnum,\n\t       (int)(author_end - author), author,\n\t       (int)(committer_end - committer), committer,\n\t       (unsigned)(reencoded\n\t\t\t  ? strlen(reencoded) : message\n\t\t\t  ? strlen(message) : 0),\n\t       reencoded ? reencoded : message ? message : \"\");\n\tfree(reencoded);\n\n\tfor (i = 0, p = commit->parents; p; p = p->next) {\n\t\tint mark = get_object_mark(&p->item->object);\n\t\tif (!mark)\n\t\t\tcontinue;\n\t\tif (i == 0)\n\t\t\tprintf(\"from :%d\\n\", mark);\n\t\telse\n\t\t\tprintf(\"merge :%d\\n\", mark);\n\t\ti++;\n\t}\n\n\tlog_tree_diff_flush(rev);\n\trev->diffopt.output_format = saved_output_format;\n\n\tprintf(\"\\n\");\n\n\tshow_progress();\n}\n\nstatic void handle_tail(struct object_array *commits, struct rev_info *revs)\n{\n\tstruct commit *commit;\n\twhile (commits->nr) {\n\t\tcommit = (struct commit *)commits->objects[commits->nr - 1].item;\n\t\tif (has_unshown_parent(commit))\n\t\t\treturn;\n\t\thandle_commit(commit, revs);\n\t\tcommits->nr--;\n\t}\n}\n\nstatic void handle_tag(const char *name, struct tag *tag)\n{\n\tunsigned long size;\n\tenum object_type type;\n\tchar *buf;\n\tconst char *tagger, *tagger_end, *message;\n\tsize_t message_size = 0;\n\tstruct object *tagged;\n\tint tagged_mark;\n\tstruct commit *p;\n\n\t/* Trees have no identifer in fast-export output, thus we have no way\n\t * to output tags of trees, tags of tags of trees, etc.  Simply omit\n\t * such tags.\n\t */\n\ttagged = tag->tagged;\n\twhile (tagged->type == OBJ_TAG) {\n\t\ttagged = ((struct tag *)tagged)->tagged;\n\t}\n\tif (tagged->type == OBJ_TREE) {\n\t\twarning(\"Omitting tag %s,\\nsince tags of trees (or tags of tags of trees, etc.) are not supported.\",\n\t\t\tsha1_to_hex(tag->object.sha1));\n\t\treturn;\n\t}\n\n\tbuf = read_sha1_file(tag->object.sha1, &type, &size);\n\tif (!buf)\n\t\tdie (\"Could not read tag %s\", sha1_to_hex(tag->object.sha1));\n\tmessage = memmem(buf, size, \"\\n\\n\", 2);\n\tif (message) {\n\t\tmessage += 2;\n\t\tmessage_size = strlen(message);\n\t}\n\ttagger = memmem(buf, message ? message - buf : size, \"\\ntagger \", 8);\n\tif (!tagger) {\n\t\tif (fake_missing_tagger)\n\t\t\ttagger = \"tagger Unspecified Tagger \"\n\t\t\t\t\"<unspecified-tagger> 0 +0000\";\n\t\telse\n\t\t\ttagger = \"\";\n\t\ttagger_end = tagger + strlen(tagger);\n\t} else {\n\t\ttagger++;\n\t\ttagger_end = strchrnul(tagger, '\\n');\n\t}\n\n\t/* handle signed tags */\n\tif (message) {\n\t\tconst char *signature = strstr(message,\n\t\t\t\t\t       \"\\n-----BEGIN PGP SIGNATURE-----\\n\");\n\t\tif (signature)\n\t\t\tswitch(signed_tag_mode) {\n\t\t\tcase ABORT:\n\t\t\t\tdie (\"Encountered signed tag %s; use \"\n\t\t\t\t     \"--signed-tag=<mode> to handle it.\",\n\t\t\t\t     sha1_to_hex(tag->object.sha1));\n\t\t\tcase WARN:\n\t\t\t\twarning (\"Exporting signed tag %s\",\n\t\t\t\t\t sha1_to_hex(tag->object.sha1));\n\t\t\t\t/* fallthru */\n\t\t\tcase VERBATIM:\n\t\t\t\tbreak;\n\t\t\tcase STRIP:\n\t\t\t\tmessage_size = signature + 1 - message;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/* handle tag->tagged having been filtered out due to paths specified */\n\ttagged = tag->tagged;\n\ttagged_mark = get_object_mark(tagged);\n\tif (!tagged_mark) {\n\t\tswitch(tag_of_filtered_mode) {\n\t\tcase ABORT:\n\t\t\tdie (\"Tag %s tags unexported object; use \"\n\t\t\t     \"--tag-of-filtered-object=<mode> to handle it.\",\n\t\t\t     sha1_to_hex(tag->object.sha1));\n\t\tcase DROP:\n\t\t\t/* Ignore this tag altogether */\n\t\t\treturn;\n\t\tcase REWRITE:\n\t\t\tif (tagged->type != OBJ_COMMIT) {\n\t\t\t\tdie (\"Tag %s tags unexported %s!\",\n\t\t\t\t     sha1_to_hex(tag->object.sha1),\n\t\t\t\t     typename(tagged->type));\n\t\t\t}\n\t\t\tp = (struct commit *)tagged;\n\t\t\tfor (;;) {\n\t\t\t\tif (p->parents && p->parents->next)\n\t\t\t\t\tbreak;\n\t\t\t\tif (p->object.flags & UNINTERESTING)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(p->object.flags & TREESAME))\n\t\t\t\t\tbreak;\n\t\t\t\tif (!p->parents)\n\t\t\t\t\tdie (\"Can't find replacement commit for tag %s\\n\",\n\t\t\t\t\t     sha1_to_hex(tag->object.sha1));\n\t\t\t\tp = p->parents->item;\n\t\t\t}\n\t\t\ttagged_mark = get_object_mark(&p->object);\n\t\t}\n\t}\n\n\tif (!prefixcmp(name, \"refs/tags/\"))\n\t\tname += 10;\n\tprintf(\"tag %s\\nfrom :%d\\n%.*s%sdata %d\\n%.*s\\n\",\n\t       name, tagged_mark,\n\t       (int)(tagger_end - tagger), tagger,\n\t       tagger == tagger_end ? \"\" : \"\\n\",\n\t       (int)message_size, (int)message_size, message ? message : \"\");\n}\n\nstatic void get_tags_and_duplicates(struct object_array *pending,\n\t\t\t\t    struct string_list *extra_refs)\n{\n\tstruct tag *tag;\n\tint i;\n\n\tfor (i = 0; i < pending->nr; i++) {\n\t\tstruct object_array_entry *e = pending->objects + i;\n\t\tunsigned char sha1[20];\n\t\tstruct commit *commit = commit;\n\t\tchar *full_name;\n\n\t\tif (dwim_ref(e->name, strlen(e->name), sha1, &full_name) != 1)\n\t\t\tcontinue;\n\n\t\tswitch (e->item->type) {\n\t\tcase OBJ_COMMIT:\n\t\t\tcommit = (struct commit *)e->item;\n\t\t\tbreak;\n\t\tcase OBJ_TAG:\n\t\t\ttag = (struct tag *)e->item;\n\n\t\t\t/* handle nested tags */\n\t\t\twhile (tag && tag->object.type == OBJ_TAG) {\n\t\t\t\tparse_object(tag->object.sha1);\n\t\t\t\tstring_list_append(full_name, extra_refs)->util = tag;\n\t\t\t\ttag = (struct tag *)tag->tagged;\n\t\t\t}\n\t\t\tif (!tag)\n\t\t\t\tdie (\"Tag %s points nowhere?\", e->name);\n\t\t\tswitch(tag->object.type) {\n\t\t\tcase OBJ_COMMIT:\n\t\t\t\tcommit = (struct commit *)tag;\n\t\t\t\tbreak;\n\t\t\tcase OBJ_BLOB:\n\t\t\t\thandle_object(tag->object.sha1);\n\t\t\t\tcontinue;\n\t\t\tdefault: /* OBJ_TAG (nested tags) is already handled */\n\t\t\t\twarning(\"Tag points to object of unexpected type %s, skipping.\",\n\t\t\t\t\ttypename(tag->object.type));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twarning(\"%s: Unexpected object of type %s, skipping.\",\n\t\t\t\te->name,\n\t\t\t\ttypename(e->item->type));\n\t\t\tcontinue;\n\t\t}\n\t\tif (commit->util)\n\t\t\t/* more than one name for the same object */\n\t\t\tstring_list_append(full_name, extra_refs)->util = commit;\n\t\telse\n\t\t\tcommit->util = full_name;\n\t}\n}\n\nstatic void handle_tags_and_duplicates(struct string_list *extra_refs)\n{\n\tstruct commit *commit;\n\tint i;\n\n\tfor (i = extra_refs->nr - 1; i >= 0; i--) {\n\t\tconst char *name = extra_refs->items[i].string;\n\t\tstruct object *object = extra_refs->items[i].util;\n\t\tswitch (object->type) {\n\t\tcase OBJ_TAG:\n\t\t\thandle_tag(name, (struct tag *)object);\n\t\t\tbreak;\n\t\tcase OBJ_COMMIT:\n\t\t\t/* create refs pointing to already seen commits */\n\t\t\tcommit = (struct commit *)object;\n\t\t\tprintf(\"reset %s\\nfrom :%d\\n\\n\", name,\n\t\t\t       get_object_mark(&commit->object));\n\t\t\tshow_progress();\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void export_marks(char *file)\n{\n\tunsigned int i;\n\tuint32_t mark;\n\tstruct object_decoration *deco = idnums.hash;\n\tFILE *f;\n\tint e = 0;\n\n\tf = fopen(file, \"w\");\n\tif (!f)\n\t\tdie_errno(\"Unable to open marks file %s for writing.\", file);\n\n\tfor (i = 0; i < idnums.size; i++) {\n\t\tif (deco->base && deco->base->type == 1) {\n\t\t\tmark = ptr_to_mark(deco->decoration);\n\t\t\tif (fprintf(f, \":%\"PRIu32\" %s\\n\", mark,\n\t\t\t\tsha1_to_hex(deco->base->sha1)) < 0) {\n\t\t\t    e = 1;\n\t\t\t    break;\n\t\t\t}\n\t\t}\n\t\tdeco++;\n\t}\n\n\te |= ferror(f);\n\te |= fclose(f);\n\tif (e)\n\t\terror(\"Unable to write marks file %s.\", file);\n}\n\nstatic void import_marks(char *input_file)\n{\n\tchar line[512];\n\tFILE *f = fopen(input_file, \"r\");\n\tif (!f)\n\t\tdie_errno(\"cannot read '%s'\", input_file);\n\n\twhile (fgets(line, sizeof(line), f)) {\n\t\tuint32_t mark;\n\t\tchar *line_end, *mark_end;\n\t\tunsigned char sha1[20];\n\t\tstruct object *object;\n\n\t\tline_end = strchr(line, '\\n');\n\t\tif (line[0] != ':' || !line_end)\n\t\t\tdie(\"corrupt mark line: %s\", line);\n\t\t*line_end = '\\0';\n\n\t\tmark = strtoumax(line + 1, &mark_end, 10);\n\t\tif (!mark || mark_end == line + 1\n\t\t\t|| *mark_end != ' ' || get_sha1(mark_end + 1, sha1))\n\t\t\tdie(\"corrupt mark line: %s\", line);\n\n\t\tobject = parse_object(sha1);\n\t\tif (!object)\n\t\t\tdie (\"Could not read blob %s\", sha1_to_hex(sha1));\n\n\t\tif (object->flags & SHOWN)\n\t\t\terror(\"Object %s already has a mark\", sha1);\n\n\t\tmark_object(object, mark);\n\t\tif (last_idnum < mark)\n\t\t\tlast_idnum = mark;\n\n\t\tobject->flags |= SHOWN;\n\t}\n\tfclose(f);\n}\n\nint cmd_fast_export(int argc, const char **argv, const char *prefix)\n{\n\tstruct rev_info revs;\n\tstruct object_array commits = { 0, 0, NULL };\n\tstruct string_list extra_refs = { NULL, 0, 0, 0 };\n\tstruct commit *commit;\n\tchar *export_filename = NULL, *import_filename = NULL;\n\tstruct option options[] = {\n\t\tOPT_INTEGER(0, \"progress\", &progress,\n\t\t\t    \"show progress after <n> objects\"),\n\t\tOPT_CALLBACK(0, \"signed-tags\", &signed_tag_mode, \"mode\",\n\t\t\t     \"select handling of signed tags\",\n\t\t\t     parse_opt_signed_tag_mode),\n\t\tOPT_CALLBACK(0, \"tag-of-filtered-object\", &tag_of_filtered_mode, \"mode\",\n\t\t\t     \"select handling of tags that tag filtered objects\",\n\t\t\t     parse_opt_tag_of_filtered_mode),\n\t\tOPT_STRING(0, \"export-marks\", &export_filename, \"FILE\",\n\t\t\t     \"Dump marks to this file\"),\n\t\tOPT_STRING(0, \"import-marks\", &import_filename, \"FILE\",\n\t\t\t     \"Import marks from this file\"),\n\t\tOPT_BOOLEAN(0, \"fake-missing-tagger\", &fake_missing_tagger,\n\t\t\t     \"Fake a tagger when tags lack one\"),\n\t\t{ OPTION_NEGBIT, 0, \"data\", &no_data, NULL,\n\t\t\t\"Skip output of blob data\",\n\t\t\tPARSE_OPT_NOARG | PARSE_OPT_NEGHELP, NULL, 1 },\n\t\tOPT_END()\n\t};\n\n\tif (argc == 1)\n\t\tusage_with_options (fast_export_usage, options);\n\n\t/* we handle encodings */\n\tgit_config(git_default_config, NULL);\n\n\tinit_revisions(&revs, prefix);\n\trevs.topo_order = 1;\n\trevs.show_source = 1;\n\trevs.rewrite_parents = 1;\n\targc = setup_revisions(argc, argv, &revs, NULL);\n\targc = parse_options(argc, argv, prefix, options, fast_export_usage, 0);\n\tif (argc > 1)\n\t\tusage_with_options (fast_export_usage, options);\n\n\tif (import_filename)\n\t\timport_marks(import_filename);\n\n\tget_tags_and_duplicates(&revs.pending, &extra_refs);\n\n\tif (prepare_revision_walk(&revs))\n\t\tdie(\"revision walk setup failed\");\n\trevs.diffopt.format_callback = show_filemodify;\n\tDIFF_OPT_SET(&revs.diffopt, RECURSIVE);\n\twhile ((commit = get_revision(&revs))) {\n\t\tif (has_unshown_parent(commit)) {\n\t\t\tadd_object_array(&commit->object, NULL, &commits);\n\t\t}\n\t\telse {\n\t\t\thandle_commit(commit, &revs);\n\t\t\thandle_tail(&commits, &revs);\n\t\t}\n\t}\n\n\thandle_tags_and_duplicates(&extra_refs);\n\n\tif (export_filename)\n\t\texport_marks(export_filename);\n\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "007bba67950ab45f3310410ebc16081b5307e7b4",
  "sha1_ok": true,
  "size": 17471
}
