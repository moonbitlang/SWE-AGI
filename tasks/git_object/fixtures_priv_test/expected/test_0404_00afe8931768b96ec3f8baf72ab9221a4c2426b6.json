{
  "content": {
    "base64": "I2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJvYmplY3QuaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJ0cmVlLmgiCiNpbmNsdWRlICJibG9iLmgiCiNpbmNsdWRlICJxdW90ZS5oIgoKLyogUXVvdGluZyBzdHlsZXMgKi8KI2RlZmluZSBRVU9URV9OT05FIDAKI2RlZmluZSBRVU9URV9TSEVMTCAxCiNkZWZpbmUgUVVPVEVfUEVSTCAyCiNkZWZpbmUgUVVPVEVfUFlUSE9OIDMKI2RlZmluZSBRVU9URV9UQ0wgNAoKdHlwZWRlZiBlbnVtIHsgRklFTERfU1RSLCBGSUVMRF9VTE9ORywgRklFTERfVElNRSB9IGNtcF90eXBlOwoKc3RydWN0IGF0b21fdmFsdWUgewoJY29uc3QgY2hhciAqczsKCXVuc2lnbmVkIGxvbmcgdWw7IC8qIHVzZWQgZm9yIHNvcnRpbmcgd2hlbiBub3QgRklFTERfU1RSICovCn07CgpzdHJ1Y3QgcmVmX3NvcnQgewoJc3RydWN0IHJlZl9zb3J0ICpuZXh0OwoJaW50IGF0b207IC8qIGluZGV4IGludG8gdXNlZF9hdG9tIGFycmF5ICovCgl1bnNpZ25lZCByZXZlcnNlIDogMTsKfTsKCnN0cnVjdCByZWZpbmZvIHsKCWNoYXIgKnJlZm5hbWU7Cgl1bnNpZ25lZCBjaGFyIG9iamVjdG5hbWVbMjBdOwoJc3RydWN0IGF0b21fdmFsdWUgKnZhbHVlOwp9OwoKc3RhdGljIHN0cnVjdCB7Cgljb25zdCBjaGFyICpuYW1lOwoJY21wX3R5cGUgY21wX3R5cGU7Cn0gdmFsaWRfYXRvbVtdID0gewoJeyAicmVmbmFtZSIgfSwKCXsgIm9iamVjdHR5cGUiIH0sCgl7ICJvYmplY3RzaXplIiwgRklFTERfVUxPTkcgfSwKCXsgIm9iamVjdG5hbWUiIH0sCgl7ICJ0cmVlIiB9LAoJeyAicGFyZW50IiB9LCAvKiBORUVEU1dPUks6IGhvdyB0byBhZGRyZXNzIDJuZCBhbmQgbGF0ZXIgcGFyZW50cz8gKi8KCXsgIm51bXBhcmVudCIsIEZJRUxEX1VMT05HIH0sCgl7ICJvYmplY3QiIH0sCgl7ICJ0eXBlIiB9LAoJeyAidGFnIiB9LAoJeyAiYXV0aG9yIiB9LAoJeyAiYXV0aG9ybmFtZSIgfSwKCXsgImF1dGhvcmVtYWlsIiB9LAoJeyAiYXV0aG9yZGF0ZSIsIEZJRUxEX1RJTUUgfSwKCXsgImNvbW1pdHRlciIgfSwKCXsgImNvbW1pdHRlcm5hbWUiIH0sCgl7ICJjb21taXR0ZXJlbWFpbCIgfSwKCXsgImNvbW1pdHRlcmRhdGUiLCBGSUVMRF9USU1FIH0sCgl7ICJ0YWdnZXIiIH0sCgl7ICJ0YWdnZXJuYW1lIiB9LAoJeyAidGFnZ2VyZW1haWwiIH0sCgl7ICJ0YWdnZXJkYXRlIiwgRklFTERfVElNRSB9LAoJeyAiY3JlYXRvciIgfSwKCXsgImNyZWF0b3JkYXRlIiwgRklFTERfVElNRSB9LAoJeyAic3ViamVjdCIgfSwKCXsgImJvZHkiIH0sCgl7ICJjb250ZW50cyIgfSwKfTsKCi8qCiAqIEFuIGF0b20gaXMgYSB2YWxpZCBmaWVsZCBhdG9tIGxpc3RlZCBhYm92ZSwgcG9zc2libHkgcHJlZml4ZWQgd2l0aAogKiBhICIqIiB0byBkZW5vdGUgZGVyZWZfdGFnKCkuCiAqCiAqIFdlIHBhcnNlIGdpdmVuIGZvcm1hdCBzdHJpbmcgYW5kIHNvcnQgc3BlY2lmaWVycywgYW5kIG1ha2UgYSBsaXN0CiAqIG9mIHByb3BlcnRpZXMgdGhhdCB3ZSBuZWVkIHRvIGV4dHJhY3Qgb3V0IG9mIG9iamVjdHMuICByZWZpbmZvCiAqIHN0cnVjdHVyZSB3aWxsIGhvbGQgYW4gYXJyYXkgb2YgdmFsdWVzIGV4dHJhY3RlZCB0aGF0IGNhbiBiZQogKiBpbmRleGVkIHdpdGggdGhlICJhdG9tIG51bWJlciIsIHdoaWNoIGlzIGFuIGluZGV4IGludG8gdGhpcwogKiBhcnJheS4KICovCnN0YXRpYyBjb25zdCBjaGFyICoqdXNlZF9hdG9tOwpzdGF0aWMgY21wX3R5cGUgKnVzZWRfYXRvbV90eXBlOwpzdGF0aWMgaW50IHVzZWRfYXRvbV9jbnQsIHNvcnRfYXRvbV9saW1pdCwgbmVlZF90YWdnZWQ7CgovKgogKiBVc2VkIHRvIHBhcnNlIGZvcm1hdCBzdHJpbmcgYW5kIHNvcnQgc3BlY2lmaWVycwogKi8Kc3RhdGljIGludCBwYXJzZV9hdG9tKGNvbnN0IGNoYXIgKmF0b20sIGNvbnN0IGNoYXIgKmVwKQp7Cgljb25zdCBjaGFyICpzcDsKCWNoYXIgKm47CglpbnQgaSwgYXQ7CgoJc3AgPSBhdG9tOwoJaWYgKCpzcCA9PSAnKicgJiYgc3AgPCBlcCkKCQlzcCsrOyAvKiBkZXJlZiAqLwoJaWYgKGVwIDw9IHNwKQoJCWRpZSgibWFsZm9ybWVkIGZpZWxkIG5hbWU6ICUuKnMiLCAoaW50KShlcC1hdG9tKSwgYXRvbSk7CgoJLyogRG8gd2UgaGF2ZSB0aGUgYXRvbSBhbHJlYWR5IHVzZWQgZWxzZXdoZXJlPyAqLwoJZm9yIChpID0gMDsgaSA8IHVzZWRfYXRvbV9jbnQ7IGkrKykgewoJCWludCBsZW4gPSBzdHJsZW4odXNlZF9hdG9tW2ldKTsKCQlpZiAobGVuID09IGVwIC0gYXRvbSAmJiAhbWVtY21wKHVzZWRfYXRvbVtpXSwgYXRvbSwgbGVuKSkKCQkJcmV0dXJuIGk7Cgl9CgoJLyogSXMgdGhlIGF0b20gYSB2YWxpZCBvbmU/ICovCglmb3IgKGkgPSAwOyBpIDwgQVJSQVlfU0laRSh2YWxpZF9hdG9tKTsgaSsrKSB7CgkJaW50IGxlbiA9IHN0cmxlbih2YWxpZF9hdG9tW2ldLm5hbWUpOwoJCS8qCgkJICogSWYgdGhlIGF0b20gbmFtZSBoYXMgYSBjb2xvbiwgc3RyaXAgaXQgYW5kIGV2ZXJ5dGhpbmcgYWZ0ZXIKCQkgKiBpdCBvZmYgLSBpdCBzcGVjaWZpZXMgdGhlIGZvcm1hdCBmb3IgdGhpcyBlbnRyeSwgYW5kCgkJICogc2hvdWxkbid0IGJlIHVzZWQgZm9yIGNoZWNraW5nIGFnYWluc3QgdGhlIHZhbGlkX2F0b20KCQkgKiB0YWJsZS4KCQkgKi8KCQljb25zdCBjaGFyICpmb3JtYXRwID0gc3RyY2hyKHNwLCAnOicpOwoJCWlmICghZm9ybWF0cCB8fCBlcCA8IGZvcm1hdHApCgkJCWZvcm1hdHAgPSBlcDsKCQlpZiAobGVuID09IGZvcm1hdHAgLSBzcCAmJiAhbWVtY21wKHZhbGlkX2F0b21baV0ubmFtZSwgc3AsIGxlbikpCgkJCWJyZWFrOwoJfQoKCWlmIChBUlJBWV9TSVpFKHZhbGlkX2F0b20pIDw9IGkpCgkJZGllKCJ1bmtub3duIGZpZWxkIG5hbWU6ICUuKnMiLCAoaW50KShlcC1hdG9tKSwgYXRvbSk7CgoJLyogQWRkIGl0IGluLCBpbmNsdWRpbmcgdGhlIGRlcmVmIHByZWZpeCAqLwoJYXQgPSB1c2VkX2F0b21fY250OwoJdXNlZF9hdG9tX2NudCsrOwoJdXNlZF9hdG9tID0geHJlYWxsb2ModXNlZF9hdG9tLAoJCQkgICAgIChzaXplb2YgKnVzZWRfYXRvbSkgKiB1c2VkX2F0b21fY250KTsKCXVzZWRfYXRvbV90eXBlID0geHJlYWxsb2ModXNlZF9hdG9tX3R5cGUsCgkJCQkgIChzaXplb2YoKnVzZWRfYXRvbV90eXBlKSAqIHVzZWRfYXRvbV9jbnQpKTsKCW4gPSB4bWFsbG9jKGVwIC0gYXRvbSArIDEpOwoJbWVtY3B5KG4sIGF0b20sIGVwIC0gYXRvbSk7CgluW2VwLWF0b21dID0gMDsKCXVzZWRfYXRvbVthdF0gPSBuOwoJdXNlZF9hdG9tX3R5cGVbYXRdID0gdmFsaWRfYXRvbVtpXS5jbXBfdHlwZTsKCXJldHVybiBhdDsKfQoKLyoKICogSW4gYSBmb3JtYXQgc3RyaW5nLCBmaW5kIHRoZSBuZXh0IG9jY3VycmVuY2Ugb2YgJShhdG9tKS4KICovCnN0YXRpYyBjb25zdCBjaGFyICpmaW5kX25leHQoY29uc3QgY2hhciAqY3ApCnsKCXdoaWxlICgqY3ApIHsKCQlpZiAoKmNwID09ICclJykgewoJCQkvKiAlKCBpcyB0aGUgc3RhcnQgb2YgYW4gYXRvbTsKCQkJICogJSUgaXMgYSBxdW90ZWQgcGVyLWNlbnQuCgkJCSAqLwoJCQlpZiAoY3BbMV0gPT0gJygnKQoJCQkJcmV0dXJuIGNwOwoJCQllbHNlIGlmIChjcFsxXSA9PSAnJScpCgkJCQljcCsrOyAvKiBza2lwIG92ZXIgdHdvICUgKi8KCQkJLyogb3RoZXJ3aXNlIHRoaXMgaXMgYSBzaW5nbGV0b24sIGxpdGVyYWwgJSAqLwoJCX0KCQljcCsrOwoJfQoJcmV0dXJuIE5VTEw7Cn0KCi8qCiAqIE1ha2Ugc3VyZSB0aGUgZm9ybWF0IHN0cmluZyBpcyB3ZWxsIGZvcm1lZCwgYW5kIHBhcnNlIG91dAogKiB0aGUgdXNlZCBhdG9tcy4KICovCnN0YXRpYyB2b2lkIHZlcmlmeV9mb3JtYXQoY29uc3QgY2hhciAqZm9ybWF0KQp7Cgljb25zdCBjaGFyICpjcCwgKnNwOwoJZm9yIChjcCA9IGZvcm1hdDsgKmNwICYmIChzcCA9IGZpbmRfbmV4dChjcCkpOyApIHsKCQljb25zdCBjaGFyICplcCA9IHN0cmNocihzcCwgJyknKTsKCQlpZiAoIWVwKQoJCQlkaWUoIm1hbGZvcm1hdHRlZCBmb3JtYXQgc3RyaW5nICVzIiwgc3ApOwoJCS8qIHNwIHBvaW50cyBhdCAiJSgiIGFuZCBlcCBwb2ludHMgYXQgdGhlIGNsb3NpbmcgIikiICovCgkJcGFyc2VfYXRvbShzcCArIDIsIGVwKTsKCQljcCA9IGVwICsgMTsKCX0KfQoKLyoKICogR2l2ZW4gYW4gb2JqZWN0IG5hbWUsIHJlYWQgdGhlIG9iamVjdCBkYXRhIGFuZCBzaXplLCBhbmQgcmV0dXJuIGEKICogInN0cnVjdCBvYmplY3QiLiAgSWYgdGhlIG9iamVjdCBkYXRhIHdlIGFyZSByZXR1cm5pbmcgaXMgYWxzbyBib3Jyb3dlZAogKiBieSB0aGUgInN0cnVjdCBvYmplY3QiIHJlcHJlc2VudGF0aW9uLCBzZXQgKmVhdGVuIGFzIHdlbGwtLS1pdCBpcyBhCiAqIHNpZ25hbCBmcm9tIHBhcnNlX29iamVjdF9idWZmZXIgdG8gdXMgbm90IHRvIGZyZWUgdGhlIGJ1ZmZlci4KICovCnN0YXRpYyB2b2lkICpnZXRfb2JqKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIHN0cnVjdCBvYmplY3QgKipvYmosIHVuc2lnbmVkIGxvbmcgKnN6LCBpbnQgKmVhdGVuKQp7CgllbnVtIG9iamVjdF90eXBlIHR5cGU7Cgl2b2lkICpidWYgPSByZWFkX3NoYTFfZmlsZShzaGExLCAmdHlwZSwgc3opOwoKCWlmIChidWYpCgkJKm9iaiA9IHBhcnNlX29iamVjdF9idWZmZXIoc2hhMSwgdHlwZSwgKnN6LCBidWYsIGVhdGVuKTsKCWVsc2UKCQkqb2JqID0gTlVMTDsKCXJldHVybiBidWY7Cn0KCi8qIFNlZSBncmFiX3ZhbHVlcyAqLwpzdGF0aWMgdm9pZCBncmFiX2NvbW1vbl92YWx1ZXMoc3RydWN0IGF0b21fdmFsdWUgKnZhbCwgaW50IGRlcmVmLCBzdHJ1Y3Qgb2JqZWN0ICpvYmosIHZvaWQgKmJ1ZiwgdW5zaWduZWQgbG9uZyBzeikKewoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IHVzZWRfYXRvbV9jbnQ7IGkrKykgewoJCWNvbnN0IGNoYXIgKm5hbWUgPSB1c2VkX2F0b21baV07CgkJc3RydWN0IGF0b21fdmFsdWUgKnYgPSAmdmFsW2ldOwoJCWlmICghIWRlcmVmICE9ICgqbmFtZSA9PSAnKicpKQoJCQljb250aW51ZTsKCQlpZiAoZGVyZWYpCgkJCW5hbWUrKzsKCQlpZiAoIXN0cmNtcChuYW1lLCAib2JqZWN0dHlwZSIpKQoJCQl2LT5zID0gdHlwZW5hbWUob2JqLT50eXBlKTsKCQllbHNlIGlmICghc3RyY21wKG5hbWUsICJvYmplY3RzaXplIikpIHsKCQkJY2hhciAqcyA9IHhtYWxsb2MoNDApOwoJCQlzcHJpbnRmKHMsICIlbHUiLCBzeik7CgkJCXYtPnVsID0gc3o7CgkJCXYtPnMgPSBzOwoJCX0KCQllbHNlIGlmICghc3RyY21wKG5hbWUsICJvYmplY3RuYW1lIikpIHsKCQkJY2hhciAqcyA9IHhtYWxsb2MoNDEpOwoJCQlzdHJjcHkocywgc2hhMV90b19oZXgob2JqLT5zaGExKSk7CgkJCXYtPnMgPSBzOwoJCX0KCX0KfQoKLyogU2VlIGdyYWJfdmFsdWVzICovCnN0YXRpYyB2b2lkIGdyYWJfdGFnX3ZhbHVlcyhzdHJ1Y3QgYXRvbV92YWx1ZSAqdmFsLCBpbnQgZGVyZWYsIHN0cnVjdCBvYmplY3QgKm9iaiwgdm9pZCAqYnVmLCB1bnNpZ25lZCBsb25nIHN6KQp7CglpbnQgaTsKCXN0cnVjdCB0YWcgKnRhZyA9IChzdHJ1Y3QgdGFnICopIG9iajsKCglmb3IgKGkgPSAwOyBpIDwgdXNlZF9hdG9tX2NudDsgaSsrKSB7CgkJY29uc3QgY2hhciAqbmFtZSA9IHVzZWRfYXRvbVtpXTsKCQlzdHJ1Y3QgYXRvbV92YWx1ZSAqdiA9ICZ2YWxbaV07CgkJaWYgKCEhZGVyZWYgIT0gKCpuYW1lID09ICcqJykpCgkJCWNvbnRpbnVlOwoJCWlmIChkZXJlZikKCQkJbmFtZSsrOwoJCWlmICghc3RyY21wKG5hbWUsICJ0YWciKSkKCQkJdi0+cyA9IHRhZy0+dGFnOwoJfQp9CgpzdGF0aWMgaW50IG51bV9wYXJlbnRzKHN0cnVjdCBjb21taXQgKmNvbW1pdCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzOwoJaW50IGk7CgoJZm9yIChpID0gMCwgcGFyZW50cyA9IGNvbW1pdC0+cGFyZW50czsKCSAgICAgcGFyZW50czsKCSAgICAgcGFyZW50cyA9IHBhcmVudHMtPm5leHQpCgkJaSsrOwoJcmV0dXJuIGk7Cn0KCi8qIFNlZSBncmFiX3ZhbHVlcyAqLwpzdGF0aWMgdm9pZCBncmFiX2NvbW1pdF92YWx1ZXMoc3RydWN0IGF0b21fdmFsdWUgKnZhbCwgaW50IGRlcmVmLCBzdHJ1Y3Qgb2JqZWN0ICpvYmosIHZvaWQgKmJ1ZiwgdW5zaWduZWQgbG9uZyBzeikKewoJaW50IGk7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSAoc3RydWN0IGNvbW1pdCAqKSBvYmo7CgoJZm9yIChpID0gMDsgaSA8IHVzZWRfYXRvbV9jbnQ7IGkrKykgewoJCWNvbnN0IGNoYXIgKm5hbWUgPSB1c2VkX2F0b21baV07CgkJc3RydWN0IGF0b21fdmFsdWUgKnYgPSAmdmFsW2ldOwoJCWlmICghIWRlcmVmICE9ICgqbmFtZSA9PSAnKicpKQoJCQljb250aW51ZTsKCQlpZiAoZGVyZWYpCgkJCW5hbWUrKzsKCQlpZiAoIXN0cmNtcChuYW1lLCAidHJlZSIpKSB7CgkJCWNoYXIgKnMgPSB4bWFsbG9jKDQxKTsKCQkJc3RyY3B5KHMsIHNoYTFfdG9faGV4KGNvbW1pdC0+dHJlZS0+b2JqZWN0LnNoYTEpKTsKCQkJdi0+cyA9IHM7CgkJfQoJCWlmICghc3RyY21wKG5hbWUsICJudW1wYXJlbnQiKSkgewoJCQljaGFyICpzID0geG1hbGxvYyg0MCk7CgkJCXNwcmludGYocywgIiVsdSIsIHYtPnVsKTsKCQkJdi0+cyA9IHM7CgkJCXYtPnVsID0gbnVtX3BhcmVudHMoY29tbWl0KTsKCQl9CgkJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAicGFyZW50IikpIHsKCQkJaW50IG51bSA9IG51bV9wYXJlbnRzKGNvbW1pdCk7CgkJCWludCBpOwoJCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHM7CgkJCWNoYXIgKnMgPSB4bWFsbG9jKDQyICogbnVtKTsKCQkJdi0+cyA9IHM7CgkJCWZvciAoaSA9IDAsIHBhcmVudHMgPSBjb21taXQtPnBhcmVudHM7CgkJCSAgICAgcGFyZW50czsKCQkJICAgICBwYXJlbnRzID0gcGFyZW50cy0+bmV4dCwgaSA9IGkgKyA0MikgewoJCQkJc3RydWN0IGNvbW1pdCAqcGFyZW50ID0gcGFyZW50cy0+aXRlbTsKCQkJCXN0cmNweShzK2ksIHNoYTFfdG9faGV4KHBhcmVudC0+b2JqZWN0LnNoYTEpKTsKCQkJCWlmIChwYXJlbnRzLT5uZXh0KQoJCQkJCXNbaSs0MF0gPSAnICc7CgkJCX0KCQl9Cgl9Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpmaW5kX3dob2xpbmUoY29uc3QgY2hhciAqd2hvLCBpbnQgd2hvbGVuLCBjb25zdCBjaGFyICpidWYsIHVuc2lnbmVkIGxvbmcgc3opCnsKCWNvbnN0IGNoYXIgKmVvbDsKCXdoaWxlICgqYnVmKSB7CgkJaWYgKCFzdHJuY21wKGJ1Ziwgd2hvLCB3aG9sZW4pICYmCgkJICAgIGJ1Zlt3aG9sZW5dID09ICcgJykKCQkJcmV0dXJuIGJ1ZiArIHdob2xlbiArIDE7CgkJZW9sID0gc3RyY2hyKGJ1ZiwgJ1xuJyk7CgkJaWYgKCFlb2wpCgkJCXJldHVybiAiIjsKCQllb2wrKzsKCQlpZiAoZW9sWzFdID09ICdcbicpCgkJCXJldHVybiAiIjsgLyogZW5kIG9mIGhlYWRlciAqLwoJCWJ1ZiA9IGVvbDsKCX0KCXJldHVybiAiIjsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKmNvcHlfbGluZShjb25zdCBjaGFyICpidWYpCnsKCWNvbnN0IGNoYXIgKmVvbCA9IHN0cmNocihidWYsICdcbicpOwoJY2hhciAqbGluZTsKCWludCBsZW47CglpZiAoIWVvbCkKCQlyZXR1cm4gIiI7CglsZW4gPSBlb2wgLSBidWY7CglsaW5lID0geG1hbGxvYyhsZW4gKyAxKTsKCW1lbWNweShsaW5lLCBidWYsIGxlbik7CglsaW5lW2xlbl0gPSAwOwoJcmV0dXJuIGxpbmU7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpjb3B5X25hbWUoY29uc3QgY2hhciAqYnVmKQp7Cgljb25zdCBjaGFyICplb2wgPSBzdHJjaHIoYnVmLCAnXG4nKTsKCWNvbnN0IGNoYXIgKmVvbmFtZSA9IHN0cnN0cihidWYsICIgPCIpOwoJY2hhciAqbGluZTsKCWludCBsZW47CglpZiAoIShlb25hbWUgJiYgZW9sICYmIGVvbmFtZSA8IGVvbCkpCgkJcmV0dXJuICIiOwoJbGVuID0gZW9uYW1lIC0gYnVmOwoJbGluZSA9IHhtYWxsb2MobGVuICsgMSk7CgltZW1jcHkobGluZSwgYnVmLCBsZW4pOwoJbGluZVtsZW5dID0gMDsKCXJldHVybiBsaW5lOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqY29weV9lbWFpbChjb25zdCBjaGFyICpidWYpCnsKCWNvbnN0IGNoYXIgKmVtYWlsID0gc3RyY2hyKGJ1ZiwgJzwnKTsKCWNvbnN0IGNoYXIgKmVvZW1haWwgPSBzdHJjaHIoZW1haWwsICc+Jyk7CgljaGFyICpsaW5lOwoJaW50IGxlbjsKCWlmICghZW1haWwgfHwgIWVvZW1haWwpCgkJcmV0dXJuICIiOwoJZW9lbWFpbCsrOwoJbGVuID0gZW9lbWFpbCAtIGVtYWlsOwoJbGluZSA9IHhtYWxsb2MobGVuICsgMSk7CgltZW1jcHkobGluZSwgZW1haWwsIGxlbik7CglsaW5lW2xlbl0gPSAwOwoJcmV0dXJuIGxpbmU7Cn0KCnN0YXRpYyB2b2lkIGdyYWJfZGF0ZShjb25zdCBjaGFyICpidWYsIHN0cnVjdCBhdG9tX3ZhbHVlICp2LCBjb25zdCBjaGFyICphdG9tbmFtZSkKewoJY29uc3QgY2hhciAqZW9lbWFpbCA9IHN0cnN0cihidWYsICI+ICIpOwoJY2hhciAqem9uZTsKCXVuc2lnbmVkIGxvbmcgdGltZXN0YW1wOwoJbG9uZyB0ejsKCWVudW0gZGF0ZV9tb2RlIGRhdGVfbW9kZSA9IERBVEVfTk9STUFMOwoJY29uc3QgY2hhciAqZm9ybWF0cDsKCgkvKgoJICogV2UgZ290IGhlcmUgYmVjYXVzZSBhdG9tbmFtZSBlbmRzIGluICJkYXRlIiBvciAiZGF0ZTxzb21ldGhpbmc+IjsKCSAqIGl0J3Mgbm90IHBvc3NpYmxlIHRoYXQgPHNvbWV0aGluZz4gaXMgbm90ICI6PGZvcm1hdD4iIGJlY2F1c2UKCSAqIHBhcnNlX2F0b20oKSB3b3VsZG4ndCBoYXZlIGFsbG93ZWQgaXQsIHNvIHdlIGNhbiBhc3N1bWUgdGhhdCBubwoJICogIjoiIG1lYW5zIG5vIGZvcm1hdCBpcyBzcGVjaWZpZWQsIGFuZCB1c2UgdGhlIGRlZmF1bHQuCgkgKi8KCWZvcm1hdHAgPSBzdHJjaHIoYXRvbW5hbWUsICc6Jyk7CglpZiAoZm9ybWF0cCAhPSBOVUxMKSB7CgkJZm9ybWF0cCsrOwoJCWRhdGVfbW9kZSA9IHBhcnNlX2RhdGVfZm9ybWF0KGZvcm1hdHApOwoJfQoKCWlmICghZW9lbWFpbCkKCQlnb3RvIGJhZDsKCXRpbWVzdGFtcCA9IHN0cnRvdWwoZW9lbWFpbCArIDIsICZ6b25lLCAxMCk7CglpZiAodGltZXN0YW1wID09IFVMT05HX01BWCkKCQlnb3RvIGJhZDsKCXR6ID0gc3RydG9sKHpvbmUsIE5VTEwsIDEwKTsKCWlmICgodHogPT0gTE9OR19NSU4gfHwgdHogPT0gTE9OR19NQVgpICYmIGVycm5vID09IEVSQU5HRSkKCQlnb3RvIGJhZDsKCXYtPnMgPSB4c3RyZHVwKHNob3dfZGF0ZSh0aW1lc3RhbXAsIHR6LCBkYXRlX21vZGUpKTsKCXYtPnVsID0gdGltZXN0YW1wOwoJcmV0dXJuOwogYmFkOgoJdi0+cyA9ICIiOwoJdi0+dWwgPSAwOwp9CgovKiBTZWUgZ3JhYl92YWx1ZXMgKi8Kc3RhdGljIHZvaWQgZ3JhYl9wZXJzb24oY29uc3QgY2hhciAqd2hvLCBzdHJ1Y3QgYXRvbV92YWx1ZSAqdmFsLCBpbnQgZGVyZWYsIHN0cnVjdCBvYmplY3QgKm9iaiwgdm9pZCAqYnVmLCB1bnNpZ25lZCBsb25nIHN6KQp7CglpbnQgaTsKCWludCB3aG9sZW4gPSBzdHJsZW4od2hvKTsKCWNvbnN0IGNoYXIgKndob2xpbmUgPSBOVUxMOwoKCWZvciAoaSA9IDA7IGkgPCB1c2VkX2F0b21fY250OyBpKyspIHsKCQljb25zdCBjaGFyICpuYW1lID0gdXNlZF9hdG9tW2ldOwoJCXN0cnVjdCBhdG9tX3ZhbHVlICp2ID0gJnZhbFtpXTsKCQlpZiAoISFkZXJlZiAhPSAoKm5hbWUgPT0gJyonKSkKCQkJY29udGludWU7CgkJaWYgKGRlcmVmKQoJCQluYW1lKys7CgkJaWYgKHN0cm5jbXAod2hvLCBuYW1lLCB3aG9sZW4pKQoJCQljb250aW51ZTsKCQlpZiAobmFtZVt3aG9sZW5dICE9IDAgJiYKCQkgICAgc3RyY21wKG5hbWUgKyB3aG9sZW4sICJuYW1lIikgJiYKCQkgICAgc3RyY21wKG5hbWUgKyB3aG9sZW4sICJlbWFpbCIpICYmCgkJICAgIHByZWZpeGNtcChuYW1lICsgd2hvbGVuLCAiZGF0ZSIpKQoJCQljb250aW51ZTsKCQlpZiAoIXdob2xpbmUpCgkJCXdob2xpbmUgPSBmaW5kX3dob2xpbmUod2hvLCB3aG9sZW4sIGJ1Ziwgc3opOwoJCWlmICghd2hvbGluZSkKCQkJcmV0dXJuOyAvKiBubyBwb2ludCBsb29raW5nIGZvciBpdCAqLwoJCWlmIChuYW1lW3dob2xlbl0gPT0gMCkKCQkJdi0+cyA9IGNvcHlfbGluZSh3aG9saW5lKTsKCQllbHNlIGlmICghc3RyY21wKG5hbWUgKyB3aG9sZW4sICJuYW1lIikpCgkJCXYtPnMgPSBjb3B5X25hbWUod2hvbGluZSk7CgkJZWxzZSBpZiAoIXN0cmNtcChuYW1lICsgd2hvbGVuLCAiZW1haWwiKSkKCQkJdi0+cyA9IGNvcHlfZW1haWwod2hvbGluZSk7CgkJZWxzZSBpZiAoIXByZWZpeGNtcChuYW1lICsgd2hvbGVuLCAiZGF0ZSIpKQoJCQlncmFiX2RhdGUod2hvbGluZSwgdiwgbmFtZSk7Cgl9CgoJLyogRm9yIGEgdGFnIG9yIGEgY29tbWl0IG9iamVjdCwgaWYgImNyZWF0b3IiIG9yICJjcmVhdG9yZGF0ZSIgaXMKCSAqIHJlcXVlc3RlZCwgZG8gc29tZXRoaW5nIHNwZWNpYWwuCgkgKi8KCWlmIChzdHJjbXAod2hvLCAidGFnZ2VyIikgJiYgc3RyY21wKHdobywgImNvbW1pdHRlciIpKQoJCXJldHVybjsgLyogImF1dGhvciIgZm9yIGNvbW1pdCBvYmplY3QgaXMgbm90IHdhbnRlZCAqLwoJaWYgKCF3aG9saW5lKQoJCXdob2xpbmUgPSBmaW5kX3dob2xpbmUod2hvLCB3aG9sZW4sIGJ1Ziwgc3opOwoJaWYgKCF3aG9saW5lKQoJCXJldHVybjsKCWZvciAoaSA9IDA7IGkgPCB1c2VkX2F0b21fY250OyBpKyspIHsKCQljb25zdCBjaGFyICpuYW1lID0gdXNlZF9hdG9tW2ldOwoJCXN0cnVjdCBhdG9tX3ZhbHVlICp2ID0gJnZhbFtpXTsKCQlpZiAoISFkZXJlZiAhPSAoKm5hbWUgPT0gJyonKSkKCQkJY29udGludWU7CgkJaWYgKGRlcmVmKQoJCQluYW1lKys7CgoJCWlmICghcHJlZml4Y21wKG5hbWUsICJjcmVhdG9yZGF0ZSIpKQoJCQlncmFiX2RhdGUod2hvbGluZSwgdiwgbmFtZSk7CgkJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiY3JlYXRvciIpKQoJCQl2LT5zID0gY29weV9saW5lKHdob2xpbmUpOwoJfQp9CgpzdGF0aWMgdm9pZCBmaW5kX3N1YnBvcyhjb25zdCBjaGFyICpidWYsIHVuc2lnbmVkIGxvbmcgc3osIGNvbnN0IGNoYXIgKipzdWIsIGNvbnN0IGNoYXIgKipib2R5KQp7Cgl3aGlsZSAoKmJ1ZikgewoJCWNvbnN0IGNoYXIgKmVvbCA9IHN0cmNocihidWYsICdcbicpOwoJCWlmICghZW9sKQoJCQlyZXR1cm47CgkJaWYgKGVvbFsxXSA9PSAnXG4nKSB7CgkJCWJ1ZiA9IGVvbCArIDE7CgkJCWJyZWFrOyAvKiBmb3VuZCBlbmQgb2YgaGVhZGVyICovCgkJfQoJCWJ1ZiA9IGVvbCArIDE7Cgl9Cgl3aGlsZSAoKmJ1ZiA9PSAnXG4nKQoJCWJ1ZisrOwoJaWYgKCEqYnVmKQoJCXJldHVybjsKCSpzdWIgPSBidWY7IC8qIGZpcnN0IG5vbi1lbXB0eSBsaW5lICovCglidWYgPSBzdHJjaHIoYnVmLCAnXG4nKTsKCWlmICghYnVmKQoJCXJldHVybjsgLyogbm8gYm9keSAqLwoJd2hpbGUgKCpidWYgPT0gJ1xuJykKCQlidWYrKzsgLyogc2tpcCBibGFuayBiZXR3ZWVuIHN1YmplY3QgYW5kIGJvZHkgKi8KCSpib2R5ID0gYnVmOwp9CgovKiBTZWUgZ3JhYl92YWx1ZXMgKi8Kc3RhdGljIHZvaWQgZ3JhYl9zdWJfYm9keV9jb250ZW50cyhzdHJ1Y3QgYXRvbV92YWx1ZSAqdmFsLCBpbnQgZGVyZWYsIHN0cnVjdCBvYmplY3QgKm9iaiwgdm9pZCAqYnVmLCB1bnNpZ25lZCBsb25nIHN6KQp7CglpbnQgaTsKCWNvbnN0IGNoYXIgKnN1YnBvcyA9IE5VTEwsICpib2R5cG9zID0gTlVMTDsKCglmb3IgKGkgPSAwOyBpIDwgdXNlZF9hdG9tX2NudDsgaSsrKSB7CgkJY29uc3QgY2hhciAqbmFtZSA9IHVzZWRfYXRvbVtpXTsKCQlzdHJ1Y3QgYXRvbV92YWx1ZSAqdiA9ICZ2YWxbaV07CgkJaWYgKCEhZGVyZWYgIT0gKCpuYW1lID09ICcqJykpCgkJCWNvbnRpbnVlOwoJCWlmIChkZXJlZikKCQkJbmFtZSsrOwoJCWlmIChzdHJjbXAobmFtZSwgInN1YmplY3QiKSAmJgoJCSAgICBzdHJjbXAobmFtZSwgImJvZHkiKSAmJgoJCSAgICBzdHJjbXAobmFtZSwgImNvbnRlbnRzIikpCgkJCWNvbnRpbnVlOwoJCWlmICghc3VicG9zKQoJCQlmaW5kX3N1YnBvcyhidWYsIHN6LCAmc3VicG9zLCAmYm9keXBvcyk7CgkJaWYgKCFzdWJwb3MpCgkJCXJldHVybjsKCgkJaWYgKCFzdHJjbXAobmFtZSwgInN1YmplY3QiKSkKCQkJdi0+cyA9IGNvcHlfbGluZShzdWJwb3MpOwoJCWVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImJvZHkiKSkKCQkJdi0+cyA9IHhzdHJkdXAoYm9keXBvcyk7CgkJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiY29udGVudHMiKSkKCQkJdi0+cyA9IHhzdHJkdXAoc3VicG9zKTsKCX0KfQoKLyogV2Ugd2FudCB0byBoYXZlIGVtcHR5IHByaW50LXN0cmluZyBmb3IgZmllbGQgcmVxdWVzdHMKICogdGhhdCBkbyBub3QgYXBwbHkgKGUuZy4gImF1dGhvcmRhdGUiIGZvciBhIHRhZyBvYmplY3QpCiAqLwpzdGF0aWMgdm9pZCBmaWxsX21pc3NpbmdfdmFsdWVzKHN0cnVjdCBhdG9tX3ZhbHVlICp2YWwpCnsKCWludCBpOwoJZm9yIChpID0gMDsgaSA8IHVzZWRfYXRvbV9jbnQ7IGkrKykgewoJCXN0cnVjdCBhdG9tX3ZhbHVlICp2ID0gJnZhbFtpXTsKCQlpZiAodi0+cyA9PSBOVUxMKQoJCQl2LT5zID0gIiI7Cgl9Cn0KCi8qCiAqIHZhbCBpcyBhIGxpc3Qgb2YgYXRvbV92YWx1ZSB0byBob2xkIHJldHVybmVkIHZhbHVlcy4gIEV4dHJhY3QKICogdGhlIHZhbHVlcyBmb3IgYXRvbXMgaW4gdXNlZF9hdG9tIGFycmF5IG91dCBvZiAob2JqLCBidWYsIHN6KS4KICogd2hlbiBkZXJlZiBpcyBmYWxzZSwgKG9iaiwgYnVmLCBzeikgaXMgdGhlIG9iamVjdCB0aGF0IGlzCiAqIHBvaW50ZWQgYXQgYnkgdGhlIHJlZiBpdHNlbGY7IG90aGVyd2lzZSBpdCBpcyB0aGUgb2JqZWN0IHRoZQogKiByZWYgKHdoaWNoIGlzIGEgdGFnKSByZWZlcnMgdG8uCiAqLwpzdGF0aWMgdm9pZCBncmFiX3ZhbHVlcyhzdHJ1Y3QgYXRvbV92YWx1ZSAqdmFsLCBpbnQgZGVyZWYsIHN0cnVjdCBvYmplY3QgKm9iaiwgdm9pZCAqYnVmLCB1bnNpZ25lZCBsb25nIHN6KQp7CglncmFiX2NvbW1vbl92YWx1ZXModmFsLCBkZXJlZiwgb2JqLCBidWYsIHN6KTsKCXN3aXRjaCAob2JqLT50eXBlKSB7CgljYXNlIE9CSl9UQUc6CgkJZ3JhYl90YWdfdmFsdWVzKHZhbCwgZGVyZWYsIG9iaiwgYnVmLCBzeik7CgkJZ3JhYl9zdWJfYm9keV9jb250ZW50cyh2YWwsIGRlcmVmLCBvYmosIGJ1Ziwgc3opOwoJCWdyYWJfcGVyc29uKCJ0YWdnZXIiLCB2YWwsIGRlcmVmLCBvYmosIGJ1Ziwgc3opOwoJCWJyZWFrOwoJY2FzZSBPQkpfQ09NTUlUOgoJCWdyYWJfY29tbWl0X3ZhbHVlcyh2YWwsIGRlcmVmLCBvYmosIGJ1Ziwgc3opOwoJCWdyYWJfc3ViX2JvZHlfY29udGVudHModmFsLCBkZXJlZiwgb2JqLCBidWYsIHN6KTsKCQlncmFiX3BlcnNvbigiYXV0aG9yIiwgdmFsLCBkZXJlZiwgb2JqLCBidWYsIHN6KTsKCQlncmFiX3BlcnNvbigiY29tbWl0dGVyIiwgdmFsLCBkZXJlZiwgb2JqLCBidWYsIHN6KTsKCQlicmVhazsKCWNhc2UgT0JKX1RSRUU6CgkJLy8gZ3JhYl90cmVlX3ZhbHVlcyh2YWwsIGRlcmVmLCBvYmosIGJ1Ziwgc3opOwoJCWJyZWFrOwoJY2FzZSBPQkpfQkxPQjoKCQkvLyBncmFiX2Jsb2JfdmFsdWVzKHZhbCwgZGVyZWYsIG9iaiwgYnVmLCBzeik7CgkJYnJlYWs7CglkZWZhdWx0OgoJCWRpZSgiRWg/ICBPYmplY3Qgb2YgdHlwZSAlZD8iLCBvYmotPnR5cGUpOwoJfQp9CgovKgogKiBQYXJzZSB0aGUgb2JqZWN0IHJlZmVycmVkIGJ5IHJlZiwgYW5kIGdyYWIgbmVlZGVkIHZhbHVlLgogKi8Kc3RhdGljIHZvaWQgcG9wdWxhdGVfdmFsdWUoc3RydWN0IHJlZmluZm8gKnJlZikKewoJdm9pZCAqYnVmOwoJc3RydWN0IG9iamVjdCAqb2JqOwoJaW50IGVhdGVuLCBpOwoJdW5zaWduZWQgbG9uZyBzaXplOwoJY29uc3QgdW5zaWduZWQgY2hhciAqdGFnZ2VkOwoKCXJlZi0+dmFsdWUgPSB4Y2FsbG9jKHNpemVvZihzdHJ1Y3QgYXRvbV92YWx1ZSksIHVzZWRfYXRvbV9jbnQpOwoKCWJ1ZiA9IGdldF9vYmoocmVmLT5vYmplY3RuYW1lLCAmb2JqLCAmc2l6ZSwgJmVhdGVuKTsKCWlmICghYnVmKQoJCWRpZSgibWlzc2luZyBvYmplY3QgJXMgZm9yICVzIiwKCQkgICAgc2hhMV90b19oZXgocmVmLT5vYmplY3RuYW1lKSwgcmVmLT5yZWZuYW1lKTsKCWlmICghb2JqKQoJCWRpZSgicGFyc2Vfb2JqZWN0X2J1ZmZlciBmYWlsZWQgb24gJXMgZm9yICVzIiwKCQkgICAgc2hhMV90b19oZXgocmVmLT5vYmplY3RuYW1lKSwgcmVmLT5yZWZuYW1lKTsKCgkvKiBGaWxsIGluIHNwZWNpYWxzIGZpcnN0ICovCglmb3IgKGkgPSAwOyBpIDwgdXNlZF9hdG9tX2NudDsgaSsrKSB7CgkJY29uc3QgY2hhciAqbmFtZSA9IHVzZWRfYXRvbVtpXTsKCQlzdHJ1Y3QgYXRvbV92YWx1ZSAqdiA9ICZyZWYtPnZhbHVlW2ldOwoJCWlmICghc3RyY21wKG5hbWUsICJyZWZuYW1lIikpCgkJCXYtPnMgPSByZWYtPnJlZm5hbWU7CgkJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiKnJlZm5hbWUiKSkgewoJCQlpbnQgbGVuID0gc3RybGVuKHJlZi0+cmVmbmFtZSk7CgkJCWNoYXIgKnMgPSB4bWFsbG9jKGxlbiArIDQpOwoJCQlzcHJpbnRmKHMsICIlc157fSIsIHJlZi0+cmVmbmFtZSk7CgkJCXYtPnMgPSBzOwoJCX0KCX0KCglncmFiX3ZhbHVlcyhyZWYtPnZhbHVlLCAwLCBvYmosIGJ1Ziwgc2l6ZSk7CglpZiAoIWVhdGVuKQoJCWZyZWUoYnVmKTsKCgkvKiBJZiB0aGVyZSBpcyBubyBhdG9tIHRoYXQgd2FudHMgdG8ga25vdyBhYm91dCB0YWdnZWQKCSAqIG9iamVjdCwgd2UgYXJlIGRvbmUuCgkgKi8KCWlmICghbmVlZF90YWdnZWQgfHwgKG9iai0+dHlwZSAhPSBPQkpfVEFHKSkKCQlyZXR1cm47CgoJLyogSWYgaXQgaXMgYSB0YWcgb2JqZWN0LCBzZWUgaWYgd2UgdXNlIGEgdmFsdWUgdGhhdCBkZXJlZnMKCSAqIHRoZSBvYmplY3QsIGFuZCBpZiB3ZSBkbyBncmFiIHRoZSBvYmplY3QgaXQgcmVmZXJzIHRvLgoJICovCgl0YWdnZWQgPSAoKHN0cnVjdCB0YWcgKilvYmopLT50YWdnZWQtPnNoYTE7CgoJLyogTkVFRFNXT1JLOiBUaGlzIGRlcmVmcyB0YWcgb25seSBvbmNlLCB3aGljaAoJICogaXMgZ29vZCB0byBkZWFsIHdpdGggY2hhaW5zIG9mIHRydXN0LCBidXQKCSAqIGlzIG5vdCBjb25zaXN0ZW50IHdpdGggd2hhdCBkZXJlZl90YWcoKSBkb2VzCgkgKiB3aGljaCBwZWVscyB0aGUgb25pb24gdG8gdGhlIGNvcmUuCgkgKi8KCWJ1ZiA9IGdldF9vYmoodGFnZ2VkLCAmb2JqLCAmc2l6ZSwgJmVhdGVuKTsKCWlmICghYnVmKQoJCWRpZSgibWlzc2luZyBvYmplY3QgJXMgZm9yICVzIiwKCQkgICAgc2hhMV90b19oZXgodGFnZ2VkKSwgcmVmLT5yZWZuYW1lKTsKCWlmICghb2JqKQoJCWRpZSgicGFyc2Vfb2JqZWN0X2J1ZmZlciBmYWlsZWQgb24gJXMgZm9yICVzIiwKCQkgICAgc2hhMV90b19oZXgodGFnZ2VkKSwgcmVmLT5yZWZuYW1lKTsKCWdyYWJfdmFsdWVzKHJlZi0+dmFsdWUsIDEsIG9iaiwgYnVmLCBzaXplKTsKCWlmICghZWF0ZW4pCgkJZnJlZShidWYpOwp9CgovKgogKiBHaXZlbiBhIHJlZiwgcmV0dXJuIHRoZSB2YWx1ZSBmb3IgdGhlIGF0b20uICBUaGlzIGxhemlseSBnZXRzIHZhbHVlCiAqIG91dCBvZiB0aGUgb2JqZWN0IGJ5IGNhbGxpbmcgcG9wdWxhdGUgdmFsdWUuCiAqLwpzdGF0aWMgdm9pZCBnZXRfdmFsdWUoc3RydWN0IHJlZmluZm8gKnJlZiwgaW50IGF0b20sIHN0cnVjdCBhdG9tX3ZhbHVlICoqdikKewoJaWYgKCFyZWYtPnZhbHVlKSB7CgkJcG9wdWxhdGVfdmFsdWUocmVmKTsKCQlmaWxsX21pc3NpbmdfdmFsdWVzKHJlZi0+dmFsdWUpOwoJfQoJKnYgPSAmcmVmLT52YWx1ZVthdG9tXTsKfQoKc3RydWN0IGdyYWJfcmVmX2NiZGF0YSB7CglzdHJ1Y3QgcmVmaW5mbyAqKmdyYWJfYXJyYXk7Cgljb25zdCBjaGFyICoqZ3JhYl9wYXR0ZXJuOwoJaW50IGdyYWJfY250Owp9OwoKLyoKICogQSBjYWxsLWJhY2sgZ2l2ZW4gdG8gZm9yX2VhY2hfcmVmKCkuICBJdCBpcyB1bmZvcnR1bmF0ZSB0aGF0IHdlCiAqIG5lZWQgdG8gdXNlIGdsb2JhbCB2YXJpYWJsZXMgdG8gcGFzcyBleHRyYSBpbmZvcm1hdGlvbiB0byB0aGlzCiAqIGZ1bmN0aW9uLgogKi8Kc3RhdGljIGludCBncmFiX3NpbmdsZV9yZWYoY29uc3QgY2hhciAqcmVmbmFtZSwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgaW50IGZsYWcsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBncmFiX3JlZl9jYmRhdGEgKmNiID0gY2JfZGF0YTsKCXN0cnVjdCByZWZpbmZvICpyZWY7CglpbnQgY250OwoKCWlmICgqY2ItPmdyYWJfcGF0dGVybikgewoJCWNvbnN0IGNoYXIgKipwYXR0ZXJuOwoJCWludCBuYW1lbGVuID0gc3RybGVuKHJlZm5hbWUpOwoJCWZvciAocGF0dGVybiA9IGNiLT5ncmFiX3BhdHRlcm47ICpwYXR0ZXJuOyBwYXR0ZXJuKyspIHsKCQkJY29uc3QgY2hhciAqcCA9ICpwYXR0ZXJuOwoJCQlpbnQgcGxlbiA9IHN0cmxlbihwKTsKCgkJCWlmICgocGxlbiA8PSBuYW1lbGVuKSAmJgoJCQkgICAgIXN0cm5jbXAocmVmbmFtZSwgcCwgcGxlbikgJiYKCQkJICAgIChyZWZuYW1lW3BsZW5dID09ICdcMCcgfHwKCQkJICAgICByZWZuYW1lW3BsZW5dID09ICcvJykpCgkJCQlicmVhazsKCQkJaWYgKCFmbm1hdGNoKHAsIHJlZm5hbWUsIEZOTV9QQVRITkFNRSkpCgkJCQlicmVhazsKCQl9CgkJaWYgKCEqcGF0dGVybikKCQkJcmV0dXJuIDA7Cgl9CgoJLyogV2UgZG8gbm90IG9wZW4gdGhlIG9iamVjdCB5ZXQ7IHNvcnQgbWF5IG9ubHkgbmVlZCByZWZuYW1lCgkgKiB0byBkbyBpdHMgam9iIGFuZCB0aGUgcmVzdWx0aW5nIGxpc3QgbWF5IHlldCB0byBiZSBwcnVuZWQKCSAqIGJ5IG1heGNvdW50IGxvZ2ljLgoJICovCglyZWYgPSB4Y2FsbG9jKDEsIHNpemVvZigqcmVmKSk7CglyZWYtPnJlZm5hbWUgPSB4c3RyZHVwKHJlZm5hbWUpOwoJaGFzaGNweShyZWYtPm9iamVjdG5hbWUsIHNoYTEpOwoKCWNudCA9IGNiLT5ncmFiX2NudDsKCWNiLT5ncmFiX2FycmF5ID0geHJlYWxsb2MoY2ItPmdyYWJfYXJyYXksCgkJCQkgIHNpemVvZigqY2ItPmdyYWJfYXJyYXkpICogKGNudCArIDEpKTsKCWNiLT5ncmFiX2FycmF5W2NudCsrXSA9IHJlZjsKCWNiLT5ncmFiX2NudCA9IGNudDsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGNtcF9yZWZfc29ydChzdHJ1Y3QgcmVmX3NvcnQgKnMsIHN0cnVjdCByZWZpbmZvICphLCBzdHJ1Y3QgcmVmaW5mbyAqYikKewoJc3RydWN0IGF0b21fdmFsdWUgKnZhLCAqdmI7CglpbnQgY21wOwoJY21wX3R5cGUgY21wX3R5cGUgPSB1c2VkX2F0b21fdHlwZVtzLT5hdG9tXTsKCglnZXRfdmFsdWUoYSwgcy0+YXRvbSwgJnZhKTsKCWdldF92YWx1ZShiLCBzLT5hdG9tLCAmdmIpOwoJc3dpdGNoIChjbXBfdHlwZSkgewoJY2FzZSBGSUVMRF9TVFI6CgkJY21wID0gc3RyY21wKHZhLT5zLCB2Yi0+cyk7CgkJYnJlYWs7CglkZWZhdWx0OgoJCWlmICh2YS0+dWwgPCB2Yi0+dWwpCgkJCWNtcCA9IC0xOwoJCWVsc2UgaWYgKHZhLT51bCA9PSB2Yi0+dWwpCgkJCWNtcCA9IDA7CgkJZWxzZQoJCQljbXAgPSAxOwoJCWJyZWFrOwoJfQoJcmV0dXJuIChzLT5yZXZlcnNlKSA/IC1jbXAgOiBjbXA7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVmX3NvcnQgKnJlZl9zb3J0OwpzdGF0aWMgaW50IGNvbXBhcmVfcmVmcyhjb25zdCB2b2lkICphXywgY29uc3Qgdm9pZCAqYl8pCnsKCXN0cnVjdCByZWZpbmZvICphID0gKigoc3RydWN0IHJlZmluZm8gKiopYV8pOwoJc3RydWN0IHJlZmluZm8gKmIgPSAqKChzdHJ1Y3QgcmVmaW5mbyAqKiliXyk7CglzdHJ1Y3QgcmVmX3NvcnQgKnM7CgoJZm9yIChzID0gcmVmX3NvcnQ7IHM7IHMgPSBzLT5uZXh0KSB7CgkJaW50IGNtcCA9IGNtcF9yZWZfc29ydChzLCBhLCBiKTsKCQlpZiAoY21wKQoJCQlyZXR1cm4gY21wOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHNvcnRfcmVmcyhzdHJ1Y3QgcmVmX3NvcnQgKnNvcnQsIHN0cnVjdCByZWZpbmZvICoqcmVmcywgaW50IG51bV9yZWZzKQp7CglyZWZfc29ydCA9IHNvcnQ7Cglxc29ydChyZWZzLCBudW1fcmVmcywgc2l6ZW9mKHN0cnVjdCByZWZpbmZvICopLCBjb21wYXJlX3JlZnMpOwp9CgpzdGF0aWMgdm9pZCBwcmludF92YWx1ZShzdHJ1Y3QgcmVmaW5mbyAqcmVmLCBpbnQgYXRvbSwgaW50IHF1b3RlX3N0eWxlKQp7CglzdHJ1Y3QgYXRvbV92YWx1ZSAqdjsKCWdldF92YWx1ZShyZWYsIGF0b20sICZ2KTsKCXN3aXRjaCAocXVvdGVfc3R5bGUpIHsKCWNhc2UgUVVPVEVfTk9ORToKCQlmcHV0cyh2LT5zLCBzdGRvdXQpOwoJCWJyZWFrOwoJY2FzZSBRVU9URV9TSEVMTDoKCQlzcV9xdW90ZV9wcmludChzdGRvdXQsIHYtPnMpOwoJCWJyZWFrOwoJY2FzZSBRVU9URV9QRVJMOgoJCXBlcmxfcXVvdGVfcHJpbnQoc3Rkb3V0LCB2LT5zKTsKCQlicmVhazsKCWNhc2UgUVVPVEVfUFlUSE9OOgoJCXB5dGhvbl9xdW90ZV9wcmludChzdGRvdXQsIHYtPnMpOwoJCWJyZWFrOwoJY2FzZSBRVU9URV9UQ0w6CgkJdGNsX3F1b3RlX3ByaW50KHN0ZG91dCwgdi0+cyk7CgkJYnJlYWs7Cgl9Cn0KCnN0YXRpYyBpbnQgaGV4MShjaGFyIGNoKQp7CglpZiAoJzAnIDw9IGNoICYmIGNoIDw9ICc5JykKCQlyZXR1cm4gY2ggLSAnMCc7CgllbHNlIGlmICgnYScgPD0gY2ggJiYgY2ggPD0gJ2YnKQoJCXJldHVybiBjaCAtICdhJyArIDEwOwoJZWxzZSBpZiAoJ0EnIDw9IGNoICYmIGNoIDw9ICdGJykKCQlyZXR1cm4gY2ggLSAnQScgKyAxMDsKCXJldHVybiAtMTsKfQpzdGF0aWMgaW50IGhleDIoY29uc3QgY2hhciAqY3ApCnsKCWlmIChjcFswXSAmJiBjcFsxXSkKCQlyZXR1cm4gKGhleDEoY3BbMF0pIDw8IDQpIHwgaGV4MShjcFsxXSk7CgllbHNlCgkJcmV0dXJuIC0xOwp9CgpzdGF0aWMgdm9pZCBlbWl0KGNvbnN0IGNoYXIgKmNwLCBjb25zdCBjaGFyICplcCkKewoJd2hpbGUgKCpjcCAmJiAoIWVwIHx8IGNwIDwgZXApKSB7CgkJaWYgKCpjcCA9PSAnJScpIHsKCQkJaWYgKGNwWzFdID09ICclJykKCQkJCWNwKys7CgkJCWVsc2UgewoJCQkJaW50IGNoID0gaGV4MihjcCArIDEpOwoJCQkJaWYgKDAgPD0gY2gpIHsKCQkJCQlwdXRjaGFyKGNoKTsKCQkJCQljcCArPSAzOwoJCQkJCWNvbnRpbnVlOwoJCQkJfQoJCQl9CgkJfQoJCXB1dGNoYXIoKmNwKTsKCQljcCsrOwoJfQp9CgpzdGF0aWMgdm9pZCBzaG93X3JlZihzdHJ1Y3QgcmVmaW5mbyAqaW5mbywgY29uc3QgY2hhciAqZm9ybWF0LCBpbnQgcXVvdGVfc3R5bGUpCnsKCWNvbnN0IGNoYXIgKmNwLCAqc3AsICplcDsKCglmb3IgKGNwID0gZm9ybWF0OyAqY3AgJiYgKHNwID0gZmluZF9uZXh0KGNwKSk7IGNwID0gZXAgKyAxKSB7CgkJZXAgPSBzdHJjaHIoc3AsICcpJyk7CgkJaWYgKGNwIDwgc3ApCgkJCWVtaXQoY3AsIHNwKTsKCQlwcmludF92YWx1ZShpbmZvLCBwYXJzZV9hdG9tKHNwICsgMiwgZXApLCBxdW90ZV9zdHlsZSk7Cgl9CglpZiAoKmNwKSB7CgkJc3AgPSBjcCArIHN0cmxlbihjcCk7CgkJZW1pdChjcCwgc3ApOwoJfQoJcHV0Y2hhcignXG4nKTsKfQoKc3RhdGljIHN0cnVjdCByZWZfc29ydCAqZGVmYXVsdF9zb3J0KHZvaWQpCnsKCXN0YXRpYyBjb25zdCBjaGFyIGNzdHJfbmFtZVtdID0gInJlZm5hbWUiOwoKCXN0cnVjdCByZWZfc29ydCAqc29ydCA9IHhjYWxsb2MoMSwgc2l6ZW9mKCpzb3J0KSk7CgoJc29ydC0+bmV4dCA9IE5VTEw7Cglzb3J0LT5hdG9tID0gcGFyc2VfYXRvbShjc3RyX25hbWUsIGNzdHJfbmFtZSArIHN0cmxlbihjc3RyX25hbWUpKTsKCXJldHVybiBzb3J0Owp9CgppbnQgY21kX2Zvcl9lYWNoX3JlZihpbnQgYWMsIGNvbnN0IGNoYXIgKiphdiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglpbnQgaSwgbnVtX3JlZnM7Cgljb25zdCBjaGFyICpmb3JtYXQgPSBOVUxMOwoJc3RydWN0IHJlZl9zb3J0ICpzb3J0ID0gTlVMTCwgKipzb3J0X3RhaWwgPSAmc29ydDsKCWludCBtYXhjb3VudCA9IDA7CglpbnQgcXVvdGVfc3R5bGUgPSAtMTsgLyogdW5zcGVjaWZpZWQgeWV0ICovCglzdHJ1Y3QgcmVmaW5mbyAqKnJlZnM7CglzdHJ1Y3QgZ3JhYl9yZWZfY2JkYXRhIGNiZGF0YTsKCglmb3IgKGkgPSAxOyBpIDwgYWM7IGkrKykgewoJCWNvbnN0IGNoYXIgKmFyZyA9IGF2W2ldOwoJCWlmIChhcmdbMF0gIT0gJy0nKQoJCQlicmVhazsKCQlpZiAoIXN0cmNtcChhcmcsICItLSIpKSB7CgkJCWkrKzsKCQkJYnJlYWs7CgkJfQoJCWlmICghcHJlZml4Y21wKGFyZywgIi0tZm9ybWF0PSIpKSB7CgkJCWlmIChmb3JtYXQpCgkJCQlkaWUoIm1vcmUgdGhhbiBvbmUgLS1mb3JtYXQ/Iik7CgkJCWZvcm1hdCA9IGFyZyArIDk7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoIXN0cmNtcChhcmcsICItcyIpIHx8ICFzdHJjbXAoYXJnLCAiLS1zaGVsbCIpICkgewoJCQlpZiAoMCA8PSBxdW90ZV9zdHlsZSkKCQkJCWRpZSgibW9yZSB0aGFuIG9uZSBxdW90aW5nIHN0eWxlPyIpOwoJCQlxdW90ZV9zdHlsZSA9IFFVT1RFX1NIRUxMOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKCFzdHJjbXAoYXJnLCAiLXAiKSB8fCAhc3RyY21wKGFyZywgIi0tcGVybCIpICkgewoJCQlpZiAoMCA8PSBxdW90ZV9zdHlsZSkKCQkJCWRpZSgibW9yZSB0aGFuIG9uZSBxdW90aW5nIHN0eWxlPyIpOwoJCQlxdW90ZV9zdHlsZSA9IFFVT1RFX1BFUkw7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoIXN0cmNtcChhcmcsICItLXB5dGhvbiIpICkgewoJCQlpZiAoMCA8PSBxdW90ZV9zdHlsZSkKCQkJCWRpZSgibW9yZSB0aGFuIG9uZSBxdW90aW5nIHN0eWxlPyIpOwoJCQlxdW90ZV9zdHlsZSA9IFFVT1RFX1BZVEhPTjsKCQkJY29udGludWU7CgkJfQoJCWlmICghc3RyY21wKGFyZywgIi0tdGNsIikgKSB7CgkJCWlmICgwIDw9IHF1b3RlX3N0eWxlKQoJCQkJZGllKCJtb3JlIHRoYW4gb25lIHF1b3Rpbmcgc3R5bGU/Iik7CgkJCXF1b3RlX3N0eWxlID0gUVVPVEVfVENMOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKCFwcmVmaXhjbXAoYXJnLCAiLS1jb3VudD0iKSkgewoJCQlpZiAobWF4Y291bnQpCgkJCQlkaWUoIm1vcmUgdGhhbiBvbmUgLS1jb3VudD8iKTsKCQkJbWF4Y291bnQgPSBhdG9pKGFyZyArIDgpOwoJCQlpZiAobWF4Y291bnQgPD0gMCkKCQkJCWRpZSgiVGhlIG51bWJlciAlcyBkaWQgbm90IHBhcnNlIiwgYXJnKTsKCQkJY29udGludWU7CgkJfQoJCWlmICghcHJlZml4Y21wKGFyZywgIi0tc29ydD0iKSkgewoJCQlzdHJ1Y3QgcmVmX3NvcnQgKnMgPSB4Y2FsbG9jKDEsIHNpemVvZigqcykpOwoJCQlpbnQgbGVuOwoKCQkJcy0+bmV4dCA9IE5VTEw7CgkJCSpzb3J0X3RhaWwgPSBzOwoJCQlzb3J0X3RhaWwgPSAmcy0+bmV4dDsKCgkJCWFyZyArPSA3OwoJCQlpZiAoKmFyZyA9PSAnLScpIHsKCQkJCXMtPnJldmVyc2UgPSAxOwoJCQkJYXJnKys7CgkJCX0KCQkJbGVuID0gc3RybGVuKGFyZyk7CgkJCXNvcnQtPmF0b20gPSBwYXJzZV9hdG9tKGFyZywgYXJnK2xlbik7CgkJCWNvbnRpbnVlOwoJCX0KCQlicmVhazsKCX0KCWlmIChxdW90ZV9zdHlsZSA8IDApCgkJcXVvdGVfc3R5bGUgPSBRVU9URV9OT05FOwoKCWlmICghc29ydCkKCQlzb3J0ID0gZGVmYXVsdF9zb3J0KCk7Cglzb3J0X2F0b21fbGltaXQgPSB1c2VkX2F0b21fY250OwoJaWYgKCFmb3JtYXQpCgkJZm9ybWF0ID0gIiUob2JqZWN0bmFtZSkgJShvYmplY3R0eXBlKVx0JShyZWZuYW1lKSI7CgoJdmVyaWZ5X2Zvcm1hdChmb3JtYXQpOwoKCW1lbXNldCgmY2JkYXRhLCAwLCBzaXplb2YoY2JkYXRhKSk7CgljYmRhdGEuZ3JhYl9wYXR0ZXJuID0gYXYgKyBpOwoJZm9yX2VhY2hfcmVmKGdyYWJfc2luZ2xlX3JlZiwgJmNiZGF0YSk7CglyZWZzID0gY2JkYXRhLmdyYWJfYXJyYXk7CgludW1fcmVmcyA9IGNiZGF0YS5ncmFiX2NudDsKCglmb3IgKGkgPSAwOyBpIDwgdXNlZF9hdG9tX2NudDsgaSsrKSB7CgkJaWYgKHVzZWRfYXRvbVtpXVswXSA9PSAnKicpIHsKCQkJbmVlZF90YWdnZWQgPSAxOwoJCQlicmVhazsKCQl9Cgl9CgoJc29ydF9yZWZzKHNvcnQsIHJlZnMsIG51bV9yZWZzKTsKCglpZiAoIW1heGNvdW50IHx8IG51bV9yZWZzIDwgbWF4Y291bnQpCgkJbWF4Y291bnQgPSBudW1fcmVmczsKCWZvciAoaSA9IDA7IGkgPCBtYXhjb3VudDsgaSsrKQoJCXNob3dfcmVmKHJlZnNbaV0sIGZvcm1hdCwgcXVvdGVfc3R5bGUpOwoJcmV0dXJuIDA7Cn0K",
    "text": "#include \"builtin.h\"\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"object.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"tree.h\"\n#include \"blob.h\"\n#include \"quote.h\"\n\n/* Quoting styles */\n#define QUOTE_NONE 0\n#define QUOTE_SHELL 1\n#define QUOTE_PERL 2\n#define QUOTE_PYTHON 3\n#define QUOTE_TCL 4\n\ntypedef enum { FIELD_STR, FIELD_ULONG, FIELD_TIME } cmp_type;\n\nstruct atom_value {\n\tconst char *s;\n\tunsigned long ul; /* used for sorting when not FIELD_STR */\n};\n\nstruct ref_sort {\n\tstruct ref_sort *next;\n\tint atom; /* index into used_atom array */\n\tunsigned reverse : 1;\n};\n\nstruct refinfo {\n\tchar *refname;\n\tunsigned char objectname[20];\n\tstruct atom_value *value;\n};\n\nstatic struct {\n\tconst char *name;\n\tcmp_type cmp_type;\n} valid_atom[] = {\n\t{ \"refname\" },\n\t{ \"objecttype\" },\n\t{ \"objectsize\", FIELD_ULONG },\n\t{ \"objectname\" },\n\t{ \"tree\" },\n\t{ \"parent\" }, /* NEEDSWORK: how to address 2nd and later parents? */\n\t{ \"numparent\", FIELD_ULONG },\n\t{ \"object\" },\n\t{ \"type\" },\n\t{ \"tag\" },\n\t{ \"author\" },\n\t{ \"authorname\" },\n\t{ \"authoremail\" },\n\t{ \"authordate\", FIELD_TIME },\n\t{ \"committer\" },\n\t{ \"committername\" },\n\t{ \"committeremail\" },\n\t{ \"committerdate\", FIELD_TIME },\n\t{ \"tagger\" },\n\t{ \"taggername\" },\n\t{ \"taggeremail\" },\n\t{ \"taggerdate\", FIELD_TIME },\n\t{ \"creator\" },\n\t{ \"creatordate\", FIELD_TIME },\n\t{ \"subject\" },\n\t{ \"body\" },\n\t{ \"contents\" },\n};\n\n/*\n * An atom is a valid field atom listed above, possibly prefixed with\n * a \"*\" to denote deref_tag().\n *\n * We parse given format string and sort specifiers, and make a list\n * of properties that we need to extract out of objects.  refinfo\n * structure will hold an array of values extracted that can be\n * indexed with the \"atom number\", which is an index into this\n * array.\n */\nstatic const char **used_atom;\nstatic cmp_type *used_atom_type;\nstatic int used_atom_cnt, sort_atom_limit, need_tagged;\n\n/*\n * Used to parse format string and sort specifiers\n */\nstatic int parse_atom(const char *atom, const char *ep)\n{\n\tconst char *sp;\n\tchar *n;\n\tint i, at;\n\n\tsp = atom;\n\tif (*sp == '*' && sp < ep)\n\t\tsp++; /* deref */\n\tif (ep <= sp)\n\t\tdie(\"malformed field name: %.*s\", (int)(ep-atom), atom);\n\n\t/* Do we have the atom already used elsewhere? */\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tint len = strlen(used_atom[i]);\n\t\tif (len == ep - atom && !memcmp(used_atom[i], atom, len))\n\t\t\treturn i;\n\t}\n\n\t/* Is the atom a valid one? */\n\tfor (i = 0; i < ARRAY_SIZE(valid_atom); i++) {\n\t\tint len = strlen(valid_atom[i].name);\n\t\t/*\n\t\t * If the atom name has a colon, strip it and everything after\n\t\t * it off - it specifies the format for this entry, and\n\t\t * shouldn't be used for checking against the valid_atom\n\t\t * table.\n\t\t */\n\t\tconst char *formatp = strchr(sp, ':');\n\t\tif (!formatp || ep < formatp)\n\t\t\tformatp = ep;\n\t\tif (len == formatp - sp && !memcmp(valid_atom[i].name, sp, len))\n\t\t\tbreak;\n\t}\n\n\tif (ARRAY_SIZE(valid_atom) <= i)\n\t\tdie(\"unknown field name: %.*s\", (int)(ep-atom), atom);\n\n\t/* Add it in, including the deref prefix */\n\tat = used_atom_cnt;\n\tused_atom_cnt++;\n\tused_atom = xrealloc(used_atom,\n\t\t\t     (sizeof *used_atom) * used_atom_cnt);\n\tused_atom_type = xrealloc(used_atom_type,\n\t\t\t\t  (sizeof(*used_atom_type) * used_atom_cnt));\n\tn = xmalloc(ep - atom + 1);\n\tmemcpy(n, atom, ep - atom);\n\tn[ep-atom] = 0;\n\tused_atom[at] = n;\n\tused_atom_type[at] = valid_atom[i].cmp_type;\n\treturn at;\n}\n\n/*\n * In a format string, find the next occurrence of %(atom).\n */\nstatic const char *find_next(const char *cp)\n{\n\twhile (*cp) {\n\t\tif (*cp == '%') {\n\t\t\t/* %( is the start of an atom;\n\t\t\t * %% is a quoted per-cent.\n\t\t\t */\n\t\t\tif (cp[1] == '(')\n\t\t\t\treturn cp;\n\t\t\telse if (cp[1] == '%')\n\t\t\t\tcp++; /* skip over two % */\n\t\t\t/* otherwise this is a singleton, literal % */\n\t\t}\n\t\tcp++;\n\t}\n\treturn NULL;\n}\n\n/*\n * Make sure the format string is well formed, and parse out\n * the used atoms.\n */\nstatic void verify_format(const char *format)\n{\n\tconst char *cp, *sp;\n\tfor (cp = format; *cp && (sp = find_next(cp)); ) {\n\t\tconst char *ep = strchr(sp, ')');\n\t\tif (!ep)\n\t\t\tdie(\"malformatted format string %s\", sp);\n\t\t/* sp points at \"%(\" and ep points at the closing \")\" */\n\t\tparse_atom(sp + 2, ep);\n\t\tcp = ep + 1;\n\t}\n}\n\n/*\n * Given an object name, read the object data and size, and return a\n * \"struct object\".  If the object data we are returning is also borrowed\n * by the \"struct object\" representation, set *eaten as well---it is a\n * signal from parse_object_buffer to us not to free the buffer.\n */\nstatic void *get_obj(const unsigned char *sha1, struct object **obj, unsigned long *sz, int *eaten)\n{\n\tenum object_type type;\n\tvoid *buf = read_sha1_file(sha1, &type, sz);\n\n\tif (buf)\n\t\t*obj = parse_object_buffer(sha1, type, *sz, buf, eaten);\n\telse\n\t\t*obj = NULL;\n\treturn buf;\n}\n\n/* See grab_values */\nstatic void grab_common_values(struct atom_value *val, int deref, struct object *obj, void *buf, unsigned long sz)\n{\n\tint i;\n\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tconst char *name = used_atom[i];\n\t\tstruct atom_value *v = &val[i];\n\t\tif (!!deref != (*name == '*'))\n\t\t\tcontinue;\n\t\tif (deref)\n\t\t\tname++;\n\t\tif (!strcmp(name, \"objecttype\"))\n\t\t\tv->s = typename(obj->type);\n\t\telse if (!strcmp(name, \"objectsize\")) {\n\t\t\tchar *s = xmalloc(40);\n\t\t\tsprintf(s, \"%lu\", sz);\n\t\t\tv->ul = sz;\n\t\t\tv->s = s;\n\t\t}\n\t\telse if (!strcmp(name, \"objectname\")) {\n\t\t\tchar *s = xmalloc(41);\n\t\t\tstrcpy(s, sha1_to_hex(obj->sha1));\n\t\t\tv->s = s;\n\t\t}\n\t}\n}\n\n/* See grab_values */\nstatic void grab_tag_values(struct atom_value *val, int deref, struct object *obj, void *buf, unsigned long sz)\n{\n\tint i;\n\tstruct tag *tag = (struct tag *) obj;\n\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tconst char *name = used_atom[i];\n\t\tstruct atom_value *v = &val[i];\n\t\tif (!!deref != (*name == '*'))\n\t\t\tcontinue;\n\t\tif (deref)\n\t\t\tname++;\n\t\tif (!strcmp(name, \"tag\"))\n\t\t\tv->s = tag->tag;\n\t}\n}\n\nstatic int num_parents(struct commit *commit)\n{\n\tstruct commit_list *parents;\n\tint i;\n\n\tfor (i = 0, parents = commit->parents;\n\t     parents;\n\t     parents = parents->next)\n\t\ti++;\n\treturn i;\n}\n\n/* See grab_values */\nstatic void grab_commit_values(struct atom_value *val, int deref, struct object *obj, void *buf, unsigned long sz)\n{\n\tint i;\n\tstruct commit *commit = (struct commit *) obj;\n\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tconst char *name = used_atom[i];\n\t\tstruct atom_value *v = &val[i];\n\t\tif (!!deref != (*name == '*'))\n\t\t\tcontinue;\n\t\tif (deref)\n\t\t\tname++;\n\t\tif (!strcmp(name, \"tree\")) {\n\t\t\tchar *s = xmalloc(41);\n\t\t\tstrcpy(s, sha1_to_hex(commit->tree->object.sha1));\n\t\t\tv->s = s;\n\t\t}\n\t\tif (!strcmp(name, \"numparent\")) {\n\t\t\tchar *s = xmalloc(40);\n\t\t\tsprintf(s, \"%lu\", v->ul);\n\t\t\tv->s = s;\n\t\t\tv->ul = num_parents(commit);\n\t\t}\n\t\telse if (!strcmp(name, \"parent\")) {\n\t\t\tint num = num_parents(commit);\n\t\t\tint i;\n\t\t\tstruct commit_list *parents;\n\t\t\tchar *s = xmalloc(42 * num);\n\t\t\tv->s = s;\n\t\t\tfor (i = 0, parents = commit->parents;\n\t\t\t     parents;\n\t\t\t     parents = parents->next, i = i + 42) {\n\t\t\t\tstruct commit *parent = parents->item;\n\t\t\t\tstrcpy(s+i, sha1_to_hex(parent->object.sha1));\n\t\t\t\tif (parents->next)\n\t\t\t\t\ts[i+40] = ' ';\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic const char *find_wholine(const char *who, int wholen, const char *buf, unsigned long sz)\n{\n\tconst char *eol;\n\twhile (*buf) {\n\t\tif (!strncmp(buf, who, wholen) &&\n\t\t    buf[wholen] == ' ')\n\t\t\treturn buf + wholen + 1;\n\t\teol = strchr(buf, '\\n');\n\t\tif (!eol)\n\t\t\treturn \"\";\n\t\teol++;\n\t\tif (eol[1] == '\\n')\n\t\t\treturn \"\"; /* end of header */\n\t\tbuf = eol;\n\t}\n\treturn \"\";\n}\n\nstatic const char *copy_line(const char *buf)\n{\n\tconst char *eol = strchr(buf, '\\n');\n\tchar *line;\n\tint len;\n\tif (!eol)\n\t\treturn \"\";\n\tlen = eol - buf;\n\tline = xmalloc(len + 1);\n\tmemcpy(line, buf, len);\n\tline[len] = 0;\n\treturn line;\n}\n\nstatic const char *copy_name(const char *buf)\n{\n\tconst char *eol = strchr(buf, '\\n');\n\tconst char *eoname = strstr(buf, \" <\");\n\tchar *line;\n\tint len;\n\tif (!(eoname && eol && eoname < eol))\n\t\treturn \"\";\n\tlen = eoname - buf;\n\tline = xmalloc(len + 1);\n\tmemcpy(line, buf, len);\n\tline[len] = 0;\n\treturn line;\n}\n\nstatic const char *copy_email(const char *buf)\n{\n\tconst char *email = strchr(buf, '<');\n\tconst char *eoemail = strchr(email, '>');\n\tchar *line;\n\tint len;\n\tif (!email || !eoemail)\n\t\treturn \"\";\n\teoemail++;\n\tlen = eoemail - email;\n\tline = xmalloc(len + 1);\n\tmemcpy(line, email, len);\n\tline[len] = 0;\n\treturn line;\n}\n\nstatic void grab_date(const char *buf, struct atom_value *v, const char *atomname)\n{\n\tconst char *eoemail = strstr(buf, \"> \");\n\tchar *zone;\n\tunsigned long timestamp;\n\tlong tz;\n\tenum date_mode date_mode = DATE_NORMAL;\n\tconst char *formatp;\n\n\t/*\n\t * We got here because atomname ends in \"date\" or \"date<something>\";\n\t * it's not possible that <something> is not \":<format>\" because\n\t * parse_atom() wouldn't have allowed it, so we can assume that no\n\t * \":\" means no format is specified, and use the default.\n\t */\n\tformatp = strchr(atomname, ':');\n\tif (formatp != NULL) {\n\t\tformatp++;\n\t\tdate_mode = parse_date_format(formatp);\n\t}\n\n\tif (!eoemail)\n\t\tgoto bad;\n\ttimestamp = strtoul(eoemail + 2, &zone, 10);\n\tif (timestamp == ULONG_MAX)\n\t\tgoto bad;\n\ttz = strtol(zone, NULL, 10);\n\tif ((tz == LONG_MIN || tz == LONG_MAX) && errno == ERANGE)\n\t\tgoto bad;\n\tv->s = xstrdup(show_date(timestamp, tz, date_mode));\n\tv->ul = timestamp;\n\treturn;\n bad:\n\tv->s = \"\";\n\tv->ul = 0;\n}\n\n/* See grab_values */\nstatic void grab_person(const char *who, struct atom_value *val, int deref, struct object *obj, void *buf, unsigned long sz)\n{\n\tint i;\n\tint wholen = strlen(who);\n\tconst char *wholine = NULL;\n\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tconst char *name = used_atom[i];\n\t\tstruct atom_value *v = &val[i];\n\t\tif (!!deref != (*name == '*'))\n\t\t\tcontinue;\n\t\tif (deref)\n\t\t\tname++;\n\t\tif (strncmp(who, name, wholen))\n\t\t\tcontinue;\n\t\tif (name[wholen] != 0 &&\n\t\t    strcmp(name + wholen, \"name\") &&\n\t\t    strcmp(name + wholen, \"email\") &&\n\t\t    prefixcmp(name + wholen, \"date\"))\n\t\t\tcontinue;\n\t\tif (!wholine)\n\t\t\twholine = find_wholine(who, wholen, buf, sz);\n\t\tif (!wholine)\n\t\t\treturn; /* no point looking for it */\n\t\tif (name[wholen] == 0)\n\t\t\tv->s = copy_line(wholine);\n\t\telse if (!strcmp(name + wholen, \"name\"))\n\t\t\tv->s = copy_name(wholine);\n\t\telse if (!strcmp(name + wholen, \"email\"))\n\t\t\tv->s = copy_email(wholine);\n\t\telse if (!prefixcmp(name + wholen, \"date\"))\n\t\t\tgrab_date(wholine, v, name);\n\t}\n\n\t/* For a tag or a commit object, if \"creator\" or \"creatordate\" is\n\t * requested, do something special.\n\t */\n\tif (strcmp(who, \"tagger\") && strcmp(who, \"committer\"))\n\t\treturn; /* \"author\" for commit object is not wanted */\n\tif (!wholine)\n\t\twholine = find_wholine(who, wholen, buf, sz);\n\tif (!wholine)\n\t\treturn;\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tconst char *name = used_atom[i];\n\t\tstruct atom_value *v = &val[i];\n\t\tif (!!deref != (*name == '*'))\n\t\t\tcontinue;\n\t\tif (deref)\n\t\t\tname++;\n\n\t\tif (!prefixcmp(name, \"creatordate\"))\n\t\t\tgrab_date(wholine, v, name);\n\t\telse if (!strcmp(name, \"creator\"))\n\t\t\tv->s = copy_line(wholine);\n\t}\n}\n\nstatic void find_subpos(const char *buf, unsigned long sz, const char **sub, const char **body)\n{\n\twhile (*buf) {\n\t\tconst char *eol = strchr(buf, '\\n');\n\t\tif (!eol)\n\t\t\treturn;\n\t\tif (eol[1] == '\\n') {\n\t\t\tbuf = eol + 1;\n\t\t\tbreak; /* found end of header */\n\t\t}\n\t\tbuf = eol + 1;\n\t}\n\twhile (*buf == '\\n')\n\t\tbuf++;\n\tif (!*buf)\n\t\treturn;\n\t*sub = buf; /* first non-empty line */\n\tbuf = strchr(buf, '\\n');\n\tif (!buf)\n\t\treturn; /* no body */\n\twhile (*buf == '\\n')\n\t\tbuf++; /* skip blank between subject and body */\n\t*body = buf;\n}\n\n/* See grab_values */\nstatic void grab_sub_body_contents(struct atom_value *val, int deref, struct object *obj, void *buf, unsigned long sz)\n{\n\tint i;\n\tconst char *subpos = NULL, *bodypos = NULL;\n\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tconst char *name = used_atom[i];\n\t\tstruct atom_value *v = &val[i];\n\t\tif (!!deref != (*name == '*'))\n\t\t\tcontinue;\n\t\tif (deref)\n\t\t\tname++;\n\t\tif (strcmp(name, \"subject\") &&\n\t\t    strcmp(name, \"body\") &&\n\t\t    strcmp(name, \"contents\"))\n\t\t\tcontinue;\n\t\tif (!subpos)\n\t\t\tfind_subpos(buf, sz, &subpos, &bodypos);\n\t\tif (!subpos)\n\t\t\treturn;\n\n\t\tif (!strcmp(name, \"subject\"))\n\t\t\tv->s = copy_line(subpos);\n\t\telse if (!strcmp(name, \"body\"))\n\t\t\tv->s = xstrdup(bodypos);\n\t\telse if (!strcmp(name, \"contents\"))\n\t\t\tv->s = xstrdup(subpos);\n\t}\n}\n\n/* We want to have empty print-string for field requests\n * that do not apply (e.g. \"authordate\" for a tag object)\n */\nstatic void fill_missing_values(struct atom_value *val)\n{\n\tint i;\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tstruct atom_value *v = &val[i];\n\t\tif (v->s == NULL)\n\t\t\tv->s = \"\";\n\t}\n}\n\n/*\n * val is a list of atom_value to hold returned values.  Extract\n * the values for atoms in used_atom array out of (obj, buf, sz).\n * when deref is false, (obj, buf, sz) is the object that is\n * pointed at by the ref itself; otherwise it is the object the\n * ref (which is a tag) refers to.\n */\nstatic void grab_values(struct atom_value *val, int deref, struct object *obj, void *buf, unsigned long sz)\n{\n\tgrab_common_values(val, deref, obj, buf, sz);\n\tswitch (obj->type) {\n\tcase OBJ_TAG:\n\t\tgrab_tag_values(val, deref, obj, buf, sz);\n\t\tgrab_sub_body_contents(val, deref, obj, buf, sz);\n\t\tgrab_person(\"tagger\", val, deref, obj, buf, sz);\n\t\tbreak;\n\tcase OBJ_COMMIT:\n\t\tgrab_commit_values(val, deref, obj, buf, sz);\n\t\tgrab_sub_body_contents(val, deref, obj, buf, sz);\n\t\tgrab_person(\"author\", val, deref, obj, buf, sz);\n\t\tgrab_person(\"committer\", val, deref, obj, buf, sz);\n\t\tbreak;\n\tcase OBJ_TREE:\n\t\t// grab_tree_values(val, deref, obj, buf, sz);\n\t\tbreak;\n\tcase OBJ_BLOB:\n\t\t// grab_blob_values(val, deref, obj, buf, sz);\n\t\tbreak;\n\tdefault:\n\t\tdie(\"Eh?  Object of type %d?\", obj->type);\n\t}\n}\n\n/*\n * Parse the object referred by ref, and grab needed value.\n */\nstatic void populate_value(struct refinfo *ref)\n{\n\tvoid *buf;\n\tstruct object *obj;\n\tint eaten, i;\n\tunsigned long size;\n\tconst unsigned char *tagged;\n\n\tref->value = xcalloc(sizeof(struct atom_value), used_atom_cnt);\n\n\tbuf = get_obj(ref->objectname, &obj, &size, &eaten);\n\tif (!buf)\n\t\tdie(\"missing object %s for %s\",\n\t\t    sha1_to_hex(ref->objectname), ref->refname);\n\tif (!obj)\n\t\tdie(\"parse_object_buffer failed on %s for %s\",\n\t\t    sha1_to_hex(ref->objectname), ref->refname);\n\n\t/* Fill in specials first */\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tconst char *name = used_atom[i];\n\t\tstruct atom_value *v = &ref->value[i];\n\t\tif (!strcmp(name, \"refname\"))\n\t\t\tv->s = ref->refname;\n\t\telse if (!strcmp(name, \"*refname\")) {\n\t\t\tint len = strlen(ref->refname);\n\t\t\tchar *s = xmalloc(len + 4);\n\t\t\tsprintf(s, \"%s^{}\", ref->refname);\n\t\t\tv->s = s;\n\t\t}\n\t}\n\n\tgrab_values(ref->value, 0, obj, buf, size);\n\tif (!eaten)\n\t\tfree(buf);\n\n\t/* If there is no atom that wants to know about tagged\n\t * object, we are done.\n\t */\n\tif (!need_tagged || (obj->type != OBJ_TAG))\n\t\treturn;\n\n\t/* If it is a tag object, see if we use a value that derefs\n\t * the object, and if we do grab the object it refers to.\n\t */\n\ttagged = ((struct tag *)obj)->tagged->sha1;\n\n\t/* NEEDSWORK: This derefs tag only once, which\n\t * is good to deal with chains of trust, but\n\t * is not consistent with what deref_tag() does\n\t * which peels the onion to the core.\n\t */\n\tbuf = get_obj(tagged, &obj, &size, &eaten);\n\tif (!buf)\n\t\tdie(\"missing object %s for %s\",\n\t\t    sha1_to_hex(tagged), ref->refname);\n\tif (!obj)\n\t\tdie(\"parse_object_buffer failed on %s for %s\",\n\t\t    sha1_to_hex(tagged), ref->refname);\n\tgrab_values(ref->value, 1, obj, buf, size);\n\tif (!eaten)\n\t\tfree(buf);\n}\n\n/*\n * Given a ref, return the value for the atom.  This lazily gets value\n * out of the object by calling populate value.\n */\nstatic void get_value(struct refinfo *ref, int atom, struct atom_value **v)\n{\n\tif (!ref->value) {\n\t\tpopulate_value(ref);\n\t\tfill_missing_values(ref->value);\n\t}\n\t*v = &ref->value[atom];\n}\n\nstruct grab_ref_cbdata {\n\tstruct refinfo **grab_array;\n\tconst char **grab_pattern;\n\tint grab_cnt;\n};\n\n/*\n * A call-back given to for_each_ref().  It is unfortunate that we\n * need to use global variables to pass extra information to this\n * function.\n */\nstatic int grab_single_ref(const char *refname, const unsigned char *sha1, int flag, void *cb_data)\n{\n\tstruct grab_ref_cbdata *cb = cb_data;\n\tstruct refinfo *ref;\n\tint cnt;\n\n\tif (*cb->grab_pattern) {\n\t\tconst char **pattern;\n\t\tint namelen = strlen(refname);\n\t\tfor (pattern = cb->grab_pattern; *pattern; pattern++) {\n\t\t\tconst char *p = *pattern;\n\t\t\tint plen = strlen(p);\n\n\t\t\tif ((plen <= namelen) &&\n\t\t\t    !strncmp(refname, p, plen) &&\n\t\t\t    (refname[plen] == '\\0' ||\n\t\t\t     refname[plen] == '/'))\n\t\t\t\tbreak;\n\t\t\tif (!fnmatch(p, refname, FNM_PATHNAME))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!*pattern)\n\t\t\treturn 0;\n\t}\n\n\t/* We do not open the object yet; sort may only need refname\n\t * to do its job and the resulting list may yet to be pruned\n\t * by maxcount logic.\n\t */\n\tref = xcalloc(1, sizeof(*ref));\n\tref->refname = xstrdup(refname);\n\thashcpy(ref->objectname, sha1);\n\n\tcnt = cb->grab_cnt;\n\tcb->grab_array = xrealloc(cb->grab_array,\n\t\t\t\t  sizeof(*cb->grab_array) * (cnt + 1));\n\tcb->grab_array[cnt++] = ref;\n\tcb->grab_cnt = cnt;\n\treturn 0;\n}\n\nstatic int cmp_ref_sort(struct ref_sort *s, struct refinfo *a, struct refinfo *b)\n{\n\tstruct atom_value *va, *vb;\n\tint cmp;\n\tcmp_type cmp_type = used_atom_type[s->atom];\n\n\tget_value(a, s->atom, &va);\n\tget_value(b, s->atom, &vb);\n\tswitch (cmp_type) {\n\tcase FIELD_STR:\n\t\tcmp = strcmp(va->s, vb->s);\n\t\tbreak;\n\tdefault:\n\t\tif (va->ul < vb->ul)\n\t\t\tcmp = -1;\n\t\telse if (va->ul == vb->ul)\n\t\t\tcmp = 0;\n\t\telse\n\t\t\tcmp = 1;\n\t\tbreak;\n\t}\n\treturn (s->reverse) ? -cmp : cmp;\n}\n\nstatic struct ref_sort *ref_sort;\nstatic int compare_refs(const void *a_, const void *b_)\n{\n\tstruct refinfo *a = *((struct refinfo **)a_);\n\tstruct refinfo *b = *((struct refinfo **)b_);\n\tstruct ref_sort *s;\n\n\tfor (s = ref_sort; s; s = s->next) {\n\t\tint cmp = cmp_ref_sort(s, a, b);\n\t\tif (cmp)\n\t\t\treturn cmp;\n\t}\n\treturn 0;\n}\n\nstatic void sort_refs(struct ref_sort *sort, struct refinfo **refs, int num_refs)\n{\n\tref_sort = sort;\n\tqsort(refs, num_refs, sizeof(struct refinfo *), compare_refs);\n}\n\nstatic void print_value(struct refinfo *ref, int atom, int quote_style)\n{\n\tstruct atom_value *v;\n\tget_value(ref, atom, &v);\n\tswitch (quote_style) {\n\tcase QUOTE_NONE:\n\t\tfputs(v->s, stdout);\n\t\tbreak;\n\tcase QUOTE_SHELL:\n\t\tsq_quote_print(stdout, v->s);\n\t\tbreak;\n\tcase QUOTE_PERL:\n\t\tperl_quote_print(stdout, v->s);\n\t\tbreak;\n\tcase QUOTE_PYTHON:\n\t\tpython_quote_print(stdout, v->s);\n\t\tbreak;\n\tcase QUOTE_TCL:\n\t\ttcl_quote_print(stdout, v->s);\n\t\tbreak;\n\t}\n}\n\nstatic int hex1(char ch)\n{\n\tif ('0' <= ch && ch <= '9')\n\t\treturn ch - '0';\n\telse if ('a' <= ch && ch <= 'f')\n\t\treturn ch - 'a' + 10;\n\telse if ('A' <= ch && ch <= 'F')\n\t\treturn ch - 'A' + 10;\n\treturn -1;\n}\nstatic int hex2(const char *cp)\n{\n\tif (cp[0] && cp[1])\n\t\treturn (hex1(cp[0]) << 4) | hex1(cp[1]);\n\telse\n\t\treturn -1;\n}\n\nstatic void emit(const char *cp, const char *ep)\n{\n\twhile (*cp && (!ep || cp < ep)) {\n\t\tif (*cp == '%') {\n\t\t\tif (cp[1] == '%')\n\t\t\t\tcp++;\n\t\t\telse {\n\t\t\t\tint ch = hex2(cp + 1);\n\t\t\t\tif (0 <= ch) {\n\t\t\t\t\tputchar(ch);\n\t\t\t\t\tcp += 3;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputchar(*cp);\n\t\tcp++;\n\t}\n}\n\nstatic void show_ref(struct refinfo *info, const char *format, int quote_style)\n{\n\tconst char *cp, *sp, *ep;\n\n\tfor (cp = format; *cp && (sp = find_next(cp)); cp = ep + 1) {\n\t\tep = strchr(sp, ')');\n\t\tif (cp < sp)\n\t\t\temit(cp, sp);\n\t\tprint_value(info, parse_atom(sp + 2, ep), quote_style);\n\t}\n\tif (*cp) {\n\t\tsp = cp + strlen(cp);\n\t\temit(cp, sp);\n\t}\n\tputchar('\\n');\n}\n\nstatic struct ref_sort *default_sort(void)\n{\n\tstatic const char cstr_name[] = \"refname\";\n\n\tstruct ref_sort *sort = xcalloc(1, sizeof(*sort));\n\n\tsort->next = NULL;\n\tsort->atom = parse_atom(cstr_name, cstr_name + strlen(cstr_name));\n\treturn sort;\n}\n\nint cmd_for_each_ref(int ac, const char **av, const char *prefix)\n{\n\tint i, num_refs;\n\tconst char *format = NULL;\n\tstruct ref_sort *sort = NULL, **sort_tail = &sort;\n\tint maxcount = 0;\n\tint quote_style = -1; /* unspecified yet */\n\tstruct refinfo **refs;\n\tstruct grab_ref_cbdata cbdata;\n\n\tfor (i = 1; i < ac; i++) {\n\t\tconst char *arg = av[i];\n\t\tif (arg[0] != '-')\n\t\t\tbreak;\n\t\tif (!strcmp(arg, \"--\")) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\tif (!prefixcmp(arg, \"--format=\")) {\n\t\t\tif (format)\n\t\t\t\tdie(\"more than one --format?\");\n\t\t\tformat = arg + 9;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-s\") || !strcmp(arg, \"--shell\") ) {\n\t\t\tif (0 <= quote_style)\n\t\t\t\tdie(\"more than one quoting style?\");\n\t\t\tquote_style = QUOTE_SHELL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-p\") || !strcmp(arg, \"--perl\") ) {\n\t\t\tif (0 <= quote_style)\n\t\t\t\tdie(\"more than one quoting style?\");\n\t\t\tquote_style = QUOTE_PERL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--python\") ) {\n\t\t\tif (0 <= quote_style)\n\t\t\t\tdie(\"more than one quoting style?\");\n\t\t\tquote_style = QUOTE_PYTHON;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--tcl\") ) {\n\t\t\tif (0 <= quote_style)\n\t\t\t\tdie(\"more than one quoting style?\");\n\t\t\tquote_style = QUOTE_TCL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!prefixcmp(arg, \"--count=\")) {\n\t\t\tif (maxcount)\n\t\t\t\tdie(\"more than one --count?\");\n\t\t\tmaxcount = atoi(arg + 8);\n\t\t\tif (maxcount <= 0)\n\t\t\t\tdie(\"The number %s did not parse\", arg);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!prefixcmp(arg, \"--sort=\")) {\n\t\t\tstruct ref_sort *s = xcalloc(1, sizeof(*s));\n\t\t\tint len;\n\n\t\t\ts->next = NULL;\n\t\t\t*sort_tail = s;\n\t\t\tsort_tail = &s->next;\n\n\t\t\targ += 7;\n\t\t\tif (*arg == '-') {\n\t\t\t\ts->reverse = 1;\n\t\t\t\targ++;\n\t\t\t}\n\t\t\tlen = strlen(arg);\n\t\t\tsort->atom = parse_atom(arg, arg+len);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (quote_style < 0)\n\t\tquote_style = QUOTE_NONE;\n\n\tif (!sort)\n\t\tsort = default_sort();\n\tsort_atom_limit = used_atom_cnt;\n\tif (!format)\n\t\tformat = \"%(objectname) %(objecttype)\\t%(refname)\";\n\n\tverify_format(format);\n\n\tmemset(&cbdata, 0, sizeof(cbdata));\n\tcbdata.grab_pattern = av + i;\n\tfor_each_ref(grab_single_ref, &cbdata);\n\trefs = cbdata.grab_array;\n\tnum_refs = cbdata.grab_cnt;\n\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tif (used_atom[i][0] == '*') {\n\t\t\tneed_tagged = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsort_refs(sort, refs, num_refs);\n\n\tif (!maxcount || num_refs < maxcount)\n\t\tmaxcount = num_refs;\n\tfor (i = 0; i < maxcount; i++)\n\t\tshow_ref(refs[i], format, quote_style);\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00afe8931768b96ec3f8baf72ab9221a4c2426b6",
  "sha1_ok": true,
  "size": 21924
}
