{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgIm5vdGVzLmgiCiNpbmNsdWRlICJvYmplY3Qtc3RvcmUuaCIKI2luY2x1ZGUgImJsb2IuaCIKI2luY2x1ZGUgInRyZWUuaCIKI2luY2x1ZGUgInV0ZjguaCIKI2luY2x1ZGUgInN0cmJ1Zi5oIgojaW5jbHVkZSAidHJlZS13YWxrLmgiCiNpbmNsdWRlICJzdHJpbmctbGlzdC5oIgojaW5jbHVkZSAicmVmcy5oIgoKLyoKICogVXNlIGEgbm9uLWJhbGFuY2luZyBzaW1wbGUgMTYtdHJlZSBzdHJ1Y3R1cmUgd2l0aCBzdHJ1Y3QgaW50X25vZGUgYXMKICogaW50ZXJuYWwgbm9kZXMsIGFuZCBzdHJ1Y3QgbGVhZl9ub2RlIGFzIGxlYWYgbm9kZXMuIEVhY2ggaW50X25vZGUgaGFzIGEKICogMTYtYXJyYXkgb2YgcG9pbnRlcnMgdG8gaXRzIGNoaWxkcmVuLgogKiBUaGUgYm90dG9tIDIgYml0cyBvZiBlYWNoIHBvaW50ZXIgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgcG9pbnRlciB0eXBlCiAqIC0gcHRyICYgMyA9PSAwIC0gTlVMTCBwb2ludGVyLCBhc3NlcnQocHRyID09IE5VTEwpCiAqIC0gcHRyICYgMyA9PSAxIC0gcG9pbnRlciB0byBuZXh0IGludGVybmFsIG5vZGUgLSBjYXN0IHRvIHN0cnVjdCBpbnRfbm9kZSAqCiAqIC0gcHRyICYgMyA9PSAyIC0gcG9pbnRlciB0byBub3RlIGVudHJ5IC0gY2FzdCB0byBzdHJ1Y3QgbGVhZl9ub2RlICoKICogLSBwdHIgJiAzID09IDMgLSBwb2ludGVyIHRvIHN1YnRyZWUgZW50cnkgLSBjYXN0IHRvIHN0cnVjdCBsZWFmX25vZGUgKgogKgogKiBUaGUgcm9vdCBub2RlIGlzIGEgc3RhdGljYWxseSBhbGxvY2F0ZWQgc3RydWN0IGludF9ub2RlLgogKi8Kc3RydWN0IGludF9ub2RlIHsKCXZvaWQgKmFbMTZdOwp9OwoKLyoKICogTGVhZiBub2RlcyBjb21lIGluIHR3byB2YXJpYW50cywgbm90ZSBlbnRyaWVzIGFuZCBzdWJ0cmVlIGVudHJpZXMsCiAqIGRpc3Rpbmd1aXNoZWQgYnkgdGhlIExTYiBvZiB0aGUgbGVhZiBub2RlIHBvaW50ZXIgKHNlZSBhYm92ZSkuCiAqIEFzIGEgbm90ZSBlbnRyeSwgdGhlIGtleSBpcyB0aGUgU0hBMSBvZiB0aGUgcmVmZXJlbmNlZCBvYmplY3QsIGFuZCB0aGUKICogdmFsdWUgaXMgdGhlIFNIQTEgb2YgdGhlIG5vdGUgb2JqZWN0LgogKiBBcyBhIHN1YnRyZWUgZW50cnksIHRoZSBrZXkgaXMgdGhlIHByZWZpeCBTSEExICh3L3RyYWlsaW5nIE5VTHMpIG9mIHRoZQogKiByZWZlcmVuY2VkIG9iamVjdCwgdXNpbmcgdGhlIGxhc3QgYnl0ZSBvZiB0aGUga2V5IHRvIHN0b3JlIHRoZSBsZW5ndGggb2YKICogdGhlIHByZWZpeC4gVGhlIHZhbHVlIGlzIHRoZSBTSEExIG9mIHRoZSB0cmVlIG9iamVjdCBjb250YWluaW5nIHRoZSBub3RlcwogKiBzdWJ0cmVlLgogKi8Kc3RydWN0IGxlYWZfbm9kZSB7CglzdHJ1Y3Qgb2JqZWN0X2lkIGtleV9vaWQ7CglzdHJ1Y3Qgb2JqZWN0X2lkIHZhbF9vaWQ7Cn07CgovKgogKiBBIG5vdGVzIHRyZWUgbWF5IGNvbnRhaW4gZW50cmllcyB0aGF0IGFyZSBub3Qgbm90ZXMsIGFuZCB0aGF0IGRvIG5vdCBmb2xsb3cKICogdGhlIG5hbWluZyBjb252ZW50aW9ucyBvZiBub3Rlcy4gVGhlcmUgYXJlIHR5cGljYWxseSBub25lL2ZldyBvZiB0aGVzZSwgYnV0CiAqIHdlIHN0aWxsIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB0aGVtLiBLZWVwIGEgc2ltcGxlIGxpbmtlZCBsaXN0IHNvcnRlZCBhbHBoYS0KICogYmV0aWNhbGx5IG9uIHRoZSBub24tbm90ZSBwYXRoLiBUaGUgbGlzdCBpcyBwb3B1bGF0ZWQgd2hlbiBwYXJzaW5nIHRyZWUKICogb2JqZWN0cyBpbiBsb2FkX3N1YnRyZWUoKSwgYW5kIHRoZSBub24tbm90ZXMgYXJlIGNvcnJlY3RseSB3cml0dGVuIGJhY2sgaW50bwogKiB0aGUgdHJlZSBvYmplY3RzIHByb2R1Y2VkIGJ5IHdyaXRlX25vdGVzX3RyZWUoKS4KICovCnN0cnVjdCBub25fbm90ZSB7CglzdHJ1Y3Qgbm9uX25vdGUgKm5leHQ7IC8qIGdyb3VuZGVkIChsYXN0LT5uZXh0ID09IE5VTEwpICovCgljaGFyICpwYXRoOwoJdW5zaWduZWQgaW50IG1vZGU7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKfTsKCiNkZWZpbmUgUFRSX1RZUEVfTlVMTCAgICAgMAojZGVmaW5lIFBUUl9UWVBFX0lOVEVSTkFMIDEKI2RlZmluZSBQVFJfVFlQRV9OT1RFICAgICAyCiNkZWZpbmUgUFRSX1RZUEVfU1VCVFJFRSAgMwoKI2RlZmluZSBHRVRfUFRSX1RZUEUocHRyKSAgICAgICAoKHVpbnRwdHJfdCkgKHB0cikgJiAzKQojZGVmaW5lIENMUl9QVFJfVFlQRShwdHIpICAgICAgICgodm9pZCAqKSAoKHVpbnRwdHJfdCkgKHB0cikgJiB+MykpCiNkZWZpbmUgU0VUX1BUUl9UWVBFKHB0ciwgdHlwZSkgKCh2b2lkICopICgodWludHB0cl90KSAocHRyKSB8ICh0eXBlKSkpCgojZGVmaW5lIEdFVF9OSUJCTEUobiwgc2hhMSkgKCgoKHNoYTEpWyhuKSA+PiAxXSkgPj4gKCh+KG4pICYgMHgwMSkgPDwgMikpICYgMHgwZikKCiNkZWZpbmUgS0VZX0lOREVYICh0aGVfaGFzaF9hbGdvLT5yYXdzeiAtIDEpCiNkZWZpbmUgRkFOT1VUX1BBVEhfU0VQQVJBVE9SUyAodGhlX2hhc2hfYWxnby0+cmF3c3ogLSAxKQojZGVmaW5lIEZBTk9VVF9QQVRIX1NFUEFSQVRPUlNfTUFYICgoR0lUX01BWF9IRVhTWiAvIDIpIC0gMSkKI2RlZmluZSBTVUJUUkVFX1NIQTFfUFJFRklYQ01QKGtleV9zaGExLCBzdWJ0cmVlX3NoYTEpIFwKCShtZW1jbXAoa2V5X3NoYTEsIHN1YnRyZWVfc2hhMSwgc3VidHJlZV9zaGExW0tFWV9JTkRFWF0pKQoKc3RydWN0IG5vdGVzX3RyZWUgZGVmYXVsdF9ub3Rlc190cmVlOwoKc3RhdGljIHN0cnVjdCBzdHJpbmdfbGlzdCBkaXNwbGF5X25vdGVzX3JlZnMgPSBTVFJJTkdfTElTVF9JTklUX05PRFVQOwpzdGF0aWMgc3RydWN0IG5vdGVzX3RyZWUgKipkaXNwbGF5X25vdGVzX3RyZWVzOwoKc3RhdGljIHZvaWQgbG9hZF9zdWJ0cmVlKHN0cnVjdCBub3Rlc190cmVlICp0LCBzdHJ1Y3QgbGVhZl9ub2RlICpzdWJ0cmVlLAoJCXN0cnVjdCBpbnRfbm9kZSAqbm9kZSwgdW5zaWduZWQgaW50IG4pOwoKLyoKICogU2VhcmNoIHRoZSB0cmVlIHVudGlsIHRoZSBhcHByb3ByaWF0ZSBsb2NhdGlvbiBmb3IgdGhlIGdpdmVuIGtleSBpcyBmb3VuZDoKICogMS4gU3RhcnQgYXQgdGhlIHJvb3Qgbm9kZSwgd2l0aCBuID0gMAogKiAyLiBJZiBhWzBdIGF0IHRoZSBjdXJyZW50IGxldmVsIGlzIGEgbWF0Y2hpbmcgc3VidHJlZSBlbnRyeSwgdW5wYWNrIHRoYXQKICogICAgc3VidHJlZSBlbnRyeSBhbmQgcmVtb3ZlIGl0OyByZXN0YXJ0IHNlYXJjaCBhdCB0aGUgY3VycmVudCBsZXZlbC4KICogMy4gVXNlIHRoZSBudGggbmliYmxlIG9mIHRoZSBrZXkgYXMgYW4gaW5kZXggaW50byBhOgogKiAgICAtIElmIGFbbl0gaXMgYW4gaW50X25vZGUsIHJlY3Vyc2UgZnJvbSAjMiBpbnRvIHRoYXQgbm9kZSBhbmQgaW5jcmVtZW50IG4KICogICAgLSBJZiBhIG1hdGNoaW5nIHN1YnRyZWUgZW50cnksIHVucGFjayB0aGF0IHN1YnRyZWUgZW50cnkgKGFuZCByZW1vdmUgaXQpOwogKiAgICAgIHJlc3RhcnQgc2VhcmNoIGF0IHRoZSBjdXJyZW50IGxldmVsLgogKiAgICAtIE90aGVyd2lzZSwgd2UgaGF2ZSBmb3VuZCBvbmUgb2YgdGhlIGZvbGxvd2luZzoKICogICAgICAtIGEgc3VidHJlZSBlbnRyeSB3aGljaCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5CiAqICAgICAgLSBhIG5vdGUgZW50cnkgd2hpY2ggbWF5IG9yIG1heSBub3QgbWF0Y2ggdGhlIGtleQogKiAgICAgIC0gYW4gdW51c2VkIGxlYWYgbm9kZSAoTlVMTCkKICogICAgICBJbiBhbnkgY2FzZSwgc2V0ICp0cmVlIGFuZCAqbiwgYW5kIHJldHVybiBwb2ludGVyIHRvIHRoZSB0cmVlIGxvY2F0aW9uLgogKi8Kc3RhdGljIHZvaWQgKipub3RlX3RyZWVfc2VhcmNoKHN0cnVjdCBub3Rlc190cmVlICp0LCBzdHJ1Y3QgaW50X25vZGUgKip0cmVlLAoJCXVuc2lnbmVkIGNoYXIgKm4sIGNvbnN0IHVuc2lnbmVkIGNoYXIgKmtleV9zaGExKQp7CglzdHJ1Y3QgbGVhZl9ub2RlICpsOwoJdW5zaWduZWQgY2hhciBpOwoJdm9pZCAqcCA9ICgqdHJlZSktPmFbMF07CgoJaWYgKEdFVF9QVFJfVFlQRShwKSA9PSBQVFJfVFlQRV9TVUJUUkVFKSB7CgkJbCA9IChzdHJ1Y3QgbGVhZl9ub2RlICopIENMUl9QVFJfVFlQRShwKTsKCQlpZiAoIVNVQlRSRUVfU0hBMV9QUkVGSVhDTVAoa2V5X3NoYTEsIGwtPmtleV9vaWQuaGFzaCkpIHsKCQkJLyogdW5wYWNrIHRyZWUgYW5kIHJlc3VtZSBzZWFyY2ggKi8KCQkJKCp0cmVlKS0+YVswXSA9IE5VTEw7CgkJCWxvYWRfc3VidHJlZSh0LCBsLCAqdHJlZSwgKm4pOwoJCQlmcmVlKGwpOwoJCQlyZXR1cm4gbm90ZV90cmVlX3NlYXJjaCh0LCB0cmVlLCBuLCBrZXlfc2hhMSk7CgkJfQoJfQoKCWkgPSBHRVRfTklCQkxFKCpuLCBrZXlfc2hhMSk7CglwID0gKCp0cmVlKS0+YVtpXTsKCXN3aXRjaCAoR0VUX1BUUl9UWVBFKHApKSB7CgljYXNlIFBUUl9UWVBFX0lOVEVSTkFMOgoJCSp0cmVlID0gQ0xSX1BUUl9UWVBFKHApOwoJCSgqbikrKzsKCQlyZXR1cm4gbm90ZV90cmVlX3NlYXJjaCh0LCB0cmVlLCBuLCBrZXlfc2hhMSk7CgljYXNlIFBUUl9UWVBFX1NVQlRSRUU6CgkJbCA9IChzdHJ1Y3QgbGVhZl9ub2RlICopIENMUl9QVFJfVFlQRShwKTsKCQlpZiAoIVNVQlRSRUVfU0hBMV9QUkVGSVhDTVAoa2V5X3NoYTEsIGwtPmtleV9vaWQuaGFzaCkpIHsKCQkJLyogdW5wYWNrIHRyZWUgYW5kIHJlc3VtZSBzZWFyY2ggKi8KCQkJKCp0cmVlKS0+YVtpXSA9IE5VTEw7CgkJCWxvYWRfc3VidHJlZSh0LCBsLCAqdHJlZSwgKm4pOwoJCQlmcmVlKGwpOwoJCQlyZXR1cm4gbm90ZV90cmVlX3NlYXJjaCh0LCB0cmVlLCBuLCBrZXlfc2hhMSk7CgkJfQoJCS8qIGZhbGwgdGhyb3VnaCAqLwoJZGVmYXVsdDoKCQlyZXR1cm4gJigoKnRyZWUpLT5hW2ldKTsKCX0KfQoKLyoKICogVG8gZmluZCBhIGxlYWZfbm9kZToKICogU2VhcmNoIHRvIHRoZSB0cmVlIGxvY2F0aW9uIGFwcHJvcHJpYXRlIGZvciB0aGUgZ2l2ZW4ga2V5OgogKiBJZiBhIG5vdGUgZW50cnkgd2l0aCBtYXRjaGluZyBrZXksIHJldHVybiB0aGUgbm90ZSBlbnRyeSwgZWxzZSByZXR1cm4gTlVMTC4KICovCnN0YXRpYyBzdHJ1Y3QgbGVhZl9ub2RlICpub3RlX3RyZWVfZmluZChzdHJ1Y3Qgbm90ZXNfdHJlZSAqdCwKCQlzdHJ1Y3QgaW50X25vZGUgKnRyZWUsIHVuc2lnbmVkIGNoYXIgbiwKCQljb25zdCB1bnNpZ25lZCBjaGFyICprZXlfc2hhMSkKewoJdm9pZCAqKnAgPSBub3RlX3RyZWVfc2VhcmNoKHQsICZ0cmVlLCAmbiwga2V5X3NoYTEpOwoJaWYgKEdFVF9QVFJfVFlQRSgqcCkgPT0gUFRSX1RZUEVfTk9URSkgewoJCXN0cnVjdCBsZWFmX25vZGUgKmwgPSAoc3RydWN0IGxlYWZfbm9kZSAqKSBDTFJfUFRSX1RZUEUoKnApOwoJCWlmIChoYXNoZXEoa2V5X3NoYTEsIGwtPmtleV9vaWQuaGFzaCkpCgkJCXJldHVybiBsOwoJfQoJcmV0dXJuIE5VTEw7Cn0KCi8qCiAqIEhvdyB0byBjb25zb2xpZGF0ZSBhbiBpbnRfbm9kZToKICogSWYgdGhlcmUgYXJlID4gMSBub24tTlVMTCBlbnRyaWVzLCBnaXZlIHVwIGFuZCByZXR1cm4gbm9uLXplcm8uCiAqIE90aGVyd2lzZSByZXBsYWNlIHRoZSBpbnRfbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXggaW4gdGhlIGdpdmVuIHBhcmVudCBub2RlCiAqIHdpdGggdGhlIG9ubHkgTk9URSBlbnRyeSAob3IgYSBOVUxMIGVudHJ5IGlmIG5vIGVudHJpZXMpIGZyb20gdGhlIGdpdmVuCiAqIHRyZWUsIGFuZCByZXR1cm4gMC4KICovCnN0YXRpYyBpbnQgbm90ZV90cmVlX2NvbnNvbGlkYXRlKHN0cnVjdCBpbnRfbm9kZSAqdHJlZSwKCXN0cnVjdCBpbnRfbm9kZSAqcGFyZW50LCB1bnNpZ25lZCBjaGFyIGluZGV4KQp7Cgl1bnNpZ25lZCBpbnQgaTsKCXZvaWQgKnAgPSBOVUxMOwoKCWFzc2VydCh0cmVlICYmIHBhcmVudCk7Cglhc3NlcnQoQ0xSX1BUUl9UWVBFKHBhcmVudC0+YVtpbmRleF0pID09IHRyZWUpOwoKCWZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7CgkJaWYgKEdFVF9QVFJfVFlQRSh0cmVlLT5hW2ldKSAhPSBQVFJfVFlQRV9OVUxMKSB7CgkJCWlmIChwKSAvKiBtb3JlIHRoYW4gb25lIGVudHJ5ICovCgkJCQlyZXR1cm4gLTI7CgkJCXAgPSB0cmVlLT5hW2ldOwoJCX0KCX0KCglpZiAocCAmJiAoR0VUX1BUUl9UWVBFKHApICE9IFBUUl9UWVBFX05PVEUpKQoJCXJldHVybiAtMjsKCS8qIHJlcGxhY2UgdHJlZSB3aXRoIHAgaW4gcGFyZW50W2luZGV4XSAqLwoJcGFyZW50LT5hW2luZGV4XSA9IHA7CglmcmVlKHRyZWUpOwoJcmV0dXJuIDA7Cn0KCi8qCiAqIFRvIHJlbW92ZSBhIGxlYWZfbm9kZToKICogU2VhcmNoIHRvIHRoZSB0cmVlIGxvY2F0aW9uIGFwcHJvcHJpYXRlIGZvciB0aGUgZ2l2ZW4gbGVhZl9ub2RlJ3Mga2V5OgogKiAtIElmIGxvY2F0aW9uIGRvZXMgbm90IGhvbGQgYSBtYXRjaGluZyBlbnRyeSwgYWJvcnQgYW5kIGRvIG5vdGhpbmcuCiAqIC0gQ29weSB0aGUgbWF0Y2hpbmcgZW50cnkncyB2YWx1ZSBpbnRvIHRoZSBnaXZlbiBlbnRyeS4KICogLSBSZXBsYWNlIHRoZSBtYXRjaGluZyBsZWFmX25vZGUgd2l0aCBhIE5VTEwgZW50cnkgKGFuZCBmcmVlIHRoZSBsZWFmX25vZGUpLgogKiAtIENvbnNvbGlkYXRlIGludF9ub2RlcyByZXBlYXRlZGx5LCB3aGlsZSB3YWxraW5nIHVwIHRoZSB0cmVlIHRvd2FyZHMgcm9vdC4KICovCnN0YXRpYyB2b2lkIG5vdGVfdHJlZV9yZW1vdmUoc3RydWN0IG5vdGVzX3RyZWUgKnQsCgkJc3RydWN0IGludF9ub2RlICp0cmVlLCB1bnNpZ25lZCBjaGFyIG4sCgkJc3RydWN0IGxlYWZfbm9kZSAqZW50cnkpCnsKCXN0cnVjdCBsZWFmX25vZGUgKmw7CglzdHJ1Y3QgaW50X25vZGUgKnBhcmVudF9zdGFja1tHSVRfTUFYX1JBV1NaXTsKCXVuc2lnbmVkIGNoYXIgaSwgajsKCXZvaWQgKipwID0gbm90ZV90cmVlX3NlYXJjaCh0LCAmdHJlZSwgJm4sIGVudHJ5LT5rZXlfb2lkLmhhc2gpOwoKCWFzc2VydChHRVRfUFRSX1RZUEUoZW50cnkpID09IDApOyAvKiBubyB0eXBlIGJpdHMgc2V0ICovCglpZiAoR0VUX1BUUl9UWVBFKCpwKSAhPSBQVFJfVFlQRV9OT1RFKQoJCXJldHVybjsgLyogdHlwZSBtaXNtYXRjaCwgbm90aGluZyB0byByZW1vdmUgKi8KCWwgPSAoc3RydWN0IGxlYWZfbm9kZSAqKSBDTFJfUFRSX1RZUEUoKnApOwoJaWYgKCFvaWRlcSgmbC0+a2V5X29pZCwgJmVudHJ5LT5rZXlfb2lkKSkKCQlyZXR1cm47IC8qIGtleSBtaXNtYXRjaCwgbm90aGluZyB0byByZW1vdmUgKi8KCgkvKiB3ZSBoYXZlIGZvdW5kIGEgbWF0Y2hpbmcgZW50cnkgKi8KCW9pZGNweSgmZW50cnktPnZhbF9vaWQsICZsLT52YWxfb2lkKTsKCWZyZWUobCk7CgkqcCA9IFNFVF9QVFJfVFlQRShOVUxMLCBQVFJfVFlQRV9OVUxMKTsKCgkvKiBjb25zb2xpZGF0ZSB0aGlzIHRyZWUgbGV2ZWwsIGFuZCBwYXJlbnQgbGV2ZWxzLCBpZiBwb3NzaWJsZSAqLwoJaWYgKCFuKQoJCXJldHVybjsgLyogY2Fubm90IGNvbnNvbGlkYXRlIHRvcCBsZXZlbCAqLwoJLyogZmlyc3QsIGJ1aWxkIHN0YWNrIG9mIGFuY2VzdG9ycyBiZXR3ZWVuIHJvb3QgYW5kIGN1cnJlbnQgbm9kZSAqLwoJcGFyZW50X3N0YWNrWzBdID0gdC0+cm9vdDsKCWZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHsKCQlqID0gR0VUX05JQkJMRShpLCBlbnRyeS0+a2V5X29pZC5oYXNoKTsKCQlwYXJlbnRfc3RhY2tbaSArIDFdID0gQ0xSX1BUUl9UWVBFKHBhcmVudF9zdGFja1tpXS0+YVtqXSk7Cgl9Cglhc3NlcnQoaSA9PSBuICYmIHBhcmVudF9zdGFja1tpXSA9PSB0cmVlKTsKCS8qIG5leHQsIHVud2luZCBzdGFjayB1bnRpbCBub3RlX3RyZWVfY29uc29saWRhdGUoKSBpcyBkb25lICovCgl3aGlsZSAoaSA+IDAgJiYKCSAgICAgICAhbm90ZV90cmVlX2NvbnNvbGlkYXRlKHBhcmVudF9zdGFja1tpXSwgcGFyZW50X3N0YWNrW2kgLSAxXSwKCQkJCSAgICAgIEdFVF9OSUJCTEUoaSAtIDEsIGVudHJ5LT5rZXlfb2lkLmhhc2gpKSkKCQlpLS07Cn0KCi8qCiAqIFRvIGluc2VydCBhIGxlYWZfbm9kZToKICogU2VhcmNoIHRvIHRoZSB0cmVlIGxvY2F0aW9uIGFwcHJvcHJpYXRlIGZvciB0aGUgZ2l2ZW4gbGVhZl9ub2RlJ3Mga2V5OgogKiAtIElmIGxvY2F0aW9uIGlzIHVudXNlZCAoTlVMTCksIHN0b3JlIHRoZSB0d2Vha2VkIHBvaW50ZXIgZGlyZWN0bHkgdGhlcmUKICogLSBJZiBsb2NhdGlvbiBob2xkcyBhIG5vdGUgZW50cnkgdGhhdCBtYXRjaGVzIHRoZSBub3RlLXRvLWJlLWluc2VydGVkLCB0aGVuCiAqICAgY29tYmluZSB0aGUgdHdvIG5vdGVzIChieSBjYWxsaW5nIHRoZSBnaXZlbiBjb21iaW5lX25vdGVzIGZ1bmN0aW9uKS4KICogLSBJZiBsb2NhdGlvbiBob2xkcyBhIG5vdGUgZW50cnkgdGhhdCBtYXRjaGVzIHRoZSBzdWJ0cmVlLXRvLWJlLWluc2VydGVkLAogKiAgIHRoZW4gdW5wYWNrIHRoZSBzdWJ0cmVlLXRvLWJlLWluc2VydGVkIGludG8gdGhlIGxvY2F0aW9uLgogKiAtIElmIGxvY2F0aW9uIGhvbGRzIGEgbWF0Y2hpbmcgc3VidHJlZSBlbnRyeSwgdW5wYWNrIHRoZSBzdWJ0cmVlIGF0IHRoYXQKICogICBsb2NhdGlvbiwgYW5kIHJlc3RhcnQgdGhlIGluc2VydCBvcGVyYXRpb24gZnJvbSB0aGF0IGxldmVsLgogKiAtIEVsc2UsIGNyZWF0ZSBhIG5ldyBpbnRfbm9kZSwgaG9sZGluZyBib3RoIHRoZSBub2RlLWF0LWxvY2F0aW9uIGFuZCB0aGUKICogICBub2RlLXRvLWJlLWluc2VydGVkLCBhbmQgc3RvcmUgdGhlIG5ldyBpbnRfbm9kZSBpbnRvIHRoZSBsb2NhdGlvbi4KICovCnN0YXRpYyBpbnQgbm90ZV90cmVlX2luc2VydChzdHJ1Y3Qgbm90ZXNfdHJlZSAqdCwgc3RydWN0IGludF9ub2RlICp0cmVlLAoJCXVuc2lnbmVkIGNoYXIgbiwgc3RydWN0IGxlYWZfbm9kZSAqZW50cnksIHVuc2lnbmVkIGNoYXIgdHlwZSwKCQljb21iaW5lX25vdGVzX2ZuIGNvbWJpbmVfbm90ZXMpCnsKCXN0cnVjdCBpbnRfbm9kZSAqbmV3X25vZGU7CglzdHJ1Y3QgbGVhZl9ub2RlICpsOwoJdm9pZCAqKnAgPSBub3RlX3RyZWVfc2VhcmNoKHQsICZ0cmVlLCAmbiwgZW50cnktPmtleV9vaWQuaGFzaCk7CglpbnQgcmV0ID0gMDsKCglhc3NlcnQoR0VUX1BUUl9UWVBFKGVudHJ5KSA9PSAwKTsgLyogbm8gdHlwZSBiaXRzIHNldCAqLwoJbCA9IChzdHJ1Y3QgbGVhZl9ub2RlICopIENMUl9QVFJfVFlQRSgqcCk7Cglzd2l0Y2ggKEdFVF9QVFJfVFlQRSgqcCkpIHsKCWNhc2UgUFRSX1RZUEVfTlVMTDoKCQlhc3NlcnQoISpwKTsKCQlpZiAoaXNfbnVsbF9vaWQoJmVudHJ5LT52YWxfb2lkKSkKCQkJZnJlZShlbnRyeSk7CgkJZWxzZQoJCQkqcCA9IFNFVF9QVFJfVFlQRShlbnRyeSwgdHlwZSk7CgkJcmV0dXJuIDA7CgljYXNlIFBUUl9UWVBFX05PVEU6CgkJc3dpdGNoICh0eXBlKSB7CgkJY2FzZSBQVFJfVFlQRV9OT1RFOgoJCQlpZiAob2lkZXEoJmwtPmtleV9vaWQsICZlbnRyeS0+a2V5X29pZCkpIHsKCQkJCS8qIHNraXAgY29uY2F0ZW5hdGlvbiBpZiBsID09IGVudHJ5ICovCgkJCQlpZiAob2lkZXEoJmwtPnZhbF9vaWQsICZlbnRyeS0+dmFsX29pZCkpIHsKCQkJCQlmcmVlKGVudHJ5KTsKCQkJCQlyZXR1cm4gMDsKCQkJCX0KCgkJCQlyZXQgPSBjb21iaW5lX25vdGVzKCZsLT52YWxfb2lkLAoJCQkJCQkgICAgJmVudHJ5LT52YWxfb2lkKTsKCQkJCWlmICghcmV0ICYmIGlzX251bGxfb2lkKCZsLT52YWxfb2lkKSkKCQkJCQlub3RlX3RyZWVfcmVtb3ZlKHQsIHRyZWUsIG4sIGVudHJ5KTsKCQkJCWZyZWUoZW50cnkpOwoJCQkJcmV0dXJuIHJldDsKCQkJfQoJCQlicmVhazsKCQljYXNlIFBUUl9UWVBFX1NVQlRSRUU6CgkJCWlmICghU1VCVFJFRV9TSEExX1BSRUZJWENNUChsLT5rZXlfb2lkLmhhc2gsCgkJCQkJCSAgICBlbnRyeS0+a2V5X29pZC5oYXNoKSkgewoJCQkJLyogdW5wYWNrICdlbnRyeScgKi8KCQkJCWxvYWRfc3VidHJlZSh0LCBlbnRyeSwgdHJlZSwgbik7CgkJCQlmcmVlKGVudHJ5KTsKCQkJCXJldHVybiAwOwoJCQl9CgkJCWJyZWFrOwoJCX0KCQlicmVhazsKCWNhc2UgUFRSX1RZUEVfU1VCVFJFRToKCQlpZiAoIVNVQlRSRUVfU0hBMV9QUkVGSVhDTVAoZW50cnktPmtleV9vaWQuaGFzaCwgbC0+a2V5X29pZC5oYXNoKSkgewoJCQkvKiB1bnBhY2sgJ2wnIGFuZCByZXN0YXJ0IGluc2VydCAqLwoJCQkqcCA9IE5VTEw7CgkJCWxvYWRfc3VidHJlZSh0LCBsLCB0cmVlLCBuKTsKCQkJZnJlZShsKTsKCQkJcmV0dXJuIG5vdGVfdHJlZV9pbnNlcnQodCwgdHJlZSwgbiwgZW50cnksIHR5cGUsCgkJCQkJCWNvbWJpbmVfbm90ZXMpOwoJCX0KCQlicmVhazsKCX0KCgkvKiBub24tbWF0Y2hpbmcgbGVhZl9ub2RlICovCglhc3NlcnQoR0VUX1BUUl9UWVBFKCpwKSA9PSBQVFJfVFlQRV9OT1RFIHx8CgkgICAgICAgR0VUX1BUUl9UWVBFKCpwKSA9PSBQVFJfVFlQRV9TVUJUUkVFKTsKCWlmIChpc19udWxsX29pZCgmZW50cnktPnZhbF9vaWQpKSB7IC8qIHNraXAgaW5zZXJ0aW9uIG9mIGVtcHR5IG5vdGUgKi8KCQlmcmVlKGVudHJ5KTsKCQlyZXR1cm4gMDsKCX0KCW5ld19ub2RlID0gKHN0cnVjdCBpbnRfbm9kZSAqKSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3QgaW50X25vZGUpKTsKCXJldCA9IG5vdGVfdHJlZV9pbnNlcnQodCwgbmV3X25vZGUsIG4gKyAxLCBsLCBHRVRfUFRSX1RZUEUoKnApLAoJCQkgICAgICAgY29tYmluZV9ub3Rlcyk7CglpZiAocmV0KQoJCXJldHVybiByZXQ7CgkqcCA9IFNFVF9QVFJfVFlQRShuZXdfbm9kZSwgUFRSX1RZUEVfSU5URVJOQUwpOwoJcmV0dXJuIG5vdGVfdHJlZV9pbnNlcnQodCwgbmV3X25vZGUsIG4gKyAxLCBlbnRyeSwgdHlwZSwgY29tYmluZV9ub3Rlcyk7Cn0KCi8qIEZyZWUgdGhlIGVudGlyZSBub3RlcyBkYXRhIGNvbnRhaW5lZCBpbiB0aGUgZ2l2ZW4gdHJlZSAqLwpzdGF0aWMgdm9pZCBub3RlX3RyZWVfZnJlZShzdHJ1Y3QgaW50X25vZGUgKnRyZWUpCnsKCXVuc2lnbmVkIGludCBpOwoJZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHsKCQl2b2lkICpwID0gdHJlZS0+YVtpXTsKCQlzd2l0Y2ggKEdFVF9QVFJfVFlQRShwKSkgewoJCWNhc2UgUFRSX1RZUEVfSU5URVJOQUw6CgkJCW5vdGVfdHJlZV9mcmVlKENMUl9QVFJfVFlQRShwKSk7CgkJCS8qIGZhbGwgdGhyb3VnaCAqLwoJCWNhc2UgUFRSX1RZUEVfTk9URToKCQljYXNlIFBUUl9UWVBFX1NVQlRSRUU6CgkJCWZyZWUoQ0xSX1BUUl9UWVBFKHApKTsKCQl9Cgl9Cn0KCnN0YXRpYyBpbnQgbm9uX25vdGVfY21wKGNvbnN0IHN0cnVjdCBub25fbm90ZSAqYSwgY29uc3Qgc3RydWN0IG5vbl9ub3RlICpiKQp7CglyZXR1cm4gc3RyY21wKGEtPnBhdGgsIGItPnBhdGgpOwp9CgovKiBub3RlOiB0YWtlcyBvd25lcnNoaXAgb2YgcGF0aCBzdHJpbmcgKi8Kc3RhdGljIHZvaWQgYWRkX25vbl9ub3RlKHN0cnVjdCBub3Rlc190cmVlICp0LCBjaGFyICpwYXRoLAoJCXVuc2lnbmVkIGludCBtb2RlLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglzdHJ1Y3Qgbm9uX25vdGUgKnAgPSB0LT5wcmV2X25vbl9ub3RlLCAqbjsKCW4gPSAoc3RydWN0IG5vbl9ub3RlICopIHhtYWxsb2Moc2l6ZW9mKHN0cnVjdCBub25fbm90ZSkpOwoJbi0+bmV4dCA9IE5VTEw7CgluLT5wYXRoID0gcGF0aDsKCW4tPm1vZGUgPSBtb2RlOwoJaGFzaGNweShuLT5vaWQuaGFzaCwgc2hhMSk7Cgl0LT5wcmV2X25vbl9ub3RlID0gbjsKCglpZiAoIXQtPmZpcnN0X25vbl9ub3RlKSB7CgkJdC0+Zmlyc3Rfbm9uX25vdGUgPSBuOwoJCXJldHVybjsKCX0KCglpZiAobm9uX25vdGVfY21wKHAsIG4pIDwgMCkKCQk7IC8qIGRvIG5vdGhpbmcgICovCgllbHNlIGlmIChub25fbm90ZV9jbXAodC0+Zmlyc3Rfbm9uX25vdGUsIG4pIDw9IDApCgkJcCA9IHQtPmZpcnN0X25vbl9ub3RlOwoJZWxzZSB7CgkJLyogbiBzb3J0cyBiZWZvcmUgdC0+Zmlyc3Rfbm9uX25vdGUgKi8KCQluLT5uZXh0ID0gdC0+Zmlyc3Rfbm9uX25vdGU7CgkJdC0+Zmlyc3Rfbm9uX25vdGUgPSBuOwoJCXJldHVybjsKCX0KCgkvKiBuIHNvcnRzIGVxdWFsIG9yIGFmdGVyIHAgKi8KCXdoaWxlIChwLT5uZXh0ICYmIG5vbl9ub3RlX2NtcChwLT5uZXh0LCBuKSA8PSAwKQoJCXAgPSBwLT5uZXh0OwoKCWlmIChub25fbm90ZV9jbXAocCwgbikgPT0gMCkgeyAvKiBuIH49IHA7IG92ZXJ3cml0ZSBwIHdpdGggbiAqLwoJCWFzc2VydChzdHJjbXAocC0+cGF0aCwgbi0+cGF0aCkgPT0gMCk7CgkJcC0+bW9kZSA9IG4tPm1vZGU7CgkJb2lkY3B5KCZwLT5vaWQsICZuLT5vaWQpOwoJCWZyZWUobik7CgkJdC0+cHJldl9ub25fbm90ZSA9IHA7CgkJcmV0dXJuOwoJfQoKCS8qIG4gc29ydHMgYmV0d2VlbiBwIGFuZCBwLT5uZXh0ICovCgluLT5uZXh0ID0gcC0+bmV4dDsKCXAtPm5leHQgPSBuOwp9CgpzdGF0aWMgdm9pZCBsb2FkX3N1YnRyZWUoc3RydWN0IG5vdGVzX3RyZWUgKnQsIHN0cnVjdCBsZWFmX25vZGUgKnN1YnRyZWUsCgkJc3RydWN0IGludF9ub2RlICpub2RlLCB1bnNpZ25lZCBpbnQgbikKewoJc3RydWN0IG9iamVjdF9pZCBvYmplY3Rfb2lkOwoJc2l6ZV90IHByZWZpeF9sZW47Cgl2b2lkICpidWY7CglzdHJ1Y3QgdHJlZV9kZXNjIGRlc2M7CglzdHJ1Y3QgbmFtZV9lbnRyeSBlbnRyeTsKCWNvbnN0IHVuc2lnbmVkIGhhc2hzeiA9IHRoZV9oYXNoX2FsZ28tPnJhd3N6OwoKCWJ1ZiA9IGZpbGxfdHJlZV9kZXNjcmlwdG9yKHRoZV9yZXBvc2l0b3J5LCAmZGVzYywgJnN1YnRyZWUtPnZhbF9vaWQpOwoJaWYgKCFidWYpCgkJZGllKCJDb3VsZCBub3QgcmVhZCAlcyBmb3Igbm90ZXMtaW5kZXgiLAoJCSAgICAgb2lkX3RvX2hleCgmc3VidHJlZS0+dmFsX29pZCkpOwoKCXByZWZpeF9sZW4gPSBzdWJ0cmVlLT5rZXlfb2lkLmhhc2hbS0VZX0lOREVYXTsKCWlmIChwcmVmaXhfbGVuID49IGhhc2hzeikKCQlCVUcoInByZWZpeF9sZW4gKCUiUFJJdU1BWCIpIGlzIG91dCBvZiByYW5nZSIsICh1aW50bWF4X3QpcHJlZml4X2xlbik7CglpZiAocHJlZml4X2xlbiAqIDIgPCBuKQoJCUJVRygicHJlZml4X2xlbiAoJSJQUkl1TUFYIikgaXMgdG9vIHNtYWxsIiwgKHVpbnRtYXhfdClwcmVmaXhfbGVuKTsKCW1lbWNweShvYmplY3Rfb2lkLmhhc2gsIHN1YnRyZWUtPmtleV9vaWQuaGFzaCwgcHJlZml4X2xlbik7Cgl3aGlsZSAodHJlZV9lbnRyeSgmZGVzYywgJmVudHJ5KSkgewoJCXVuc2lnbmVkIGNoYXIgdHlwZTsKCQlzdHJ1Y3QgbGVhZl9ub2RlICpsOwoJCXNpemVfdCBwYXRoX2xlbiA9IHN0cmxlbihlbnRyeS5wYXRoKTsKCgkJaWYgKHBhdGhfbGVuID09IDIgKiAoaGFzaHN6IC0gcHJlZml4X2xlbikpIHsKCQkJLyogVGhpcyBpcyBwb3RlbnRpYWxseSB0aGUgcmVtYWluZGVyIG9mIHRoZSBTSEEtMSAqLwoKCQkJaWYgKCFTX0lTUkVHKGVudHJ5Lm1vZGUpKQoJCQkJLyogbm90ZXMgbXVzdCBiZSBibG9icyAqLwoJCQkJZ290byBoYW5kbGVfbm9uX25vdGU7CgoJCQlpZiAoaGV4X3RvX2J5dGVzKG9iamVjdF9vaWQuaGFzaCArIHByZWZpeF9sZW4sIGVudHJ5LnBhdGgsCgkJCQkJIGhhc2hzeiAtIHByZWZpeF9sZW4pKQoJCQkJZ290byBoYW5kbGVfbm9uX25vdGU7IC8qIGVudHJ5LnBhdGggaXMgbm90IGEgU0hBMSAqLwoKCQkJdHlwZSA9IFBUUl9UWVBFX05PVEU7CgkJfSBlbHNlIGlmIChwYXRoX2xlbiA9PSAyKSB7CgkJCS8qIFRoaXMgaXMgcG90ZW50aWFsbHkgYW4gaW50ZXJuYWwgbm9kZSAqLwoJCQlzaXplX3QgbGVuID0gcHJlZml4X2xlbjsKCgkJCWlmICghU19JU0RJUihlbnRyeS5tb2RlKSkKCQkJCS8qIGludGVybmFsIG5vZGVzIG11c3QgYmUgdHJlZXMgKi8KCQkJCWdvdG8gaGFuZGxlX25vbl9ub3RlOwoKCQkJaWYgKGhleF90b19ieXRlcyhvYmplY3Rfb2lkLmhhc2ggKyBsZW4rKywgZW50cnkucGF0aCwgMSkpCgkJCQlnb3RvIGhhbmRsZV9ub25fbm90ZTsgLyogZW50cnkucGF0aCBpcyBub3QgYSBTSEExICovCgoJCQkvKgoJCQkgKiBQYWQgdGhlIHJlc3Qgb2YgdGhlIFNIQS0xIHdpdGggemVyb3MsCgkJCSAqIGV4Y2VwdCBmb3IgdGhlIGxhc3QgYnl0ZSwgd2hlcmUgd2Ugd3JpdGUKCQkJICogdGhlIGxlbmd0aDoKCQkJICovCgkJCW1lbXNldChvYmplY3Rfb2lkLmhhc2ggKyBsZW4sIDAsIGhhc2hzeiAtIGxlbiAtIDEpOwoJCQlvYmplY3Rfb2lkLmhhc2hbS0VZX0lOREVYXSA9ICh1bnNpZ25lZCBjaGFyKWxlbjsKCgkJCXR5cGUgPSBQVFJfVFlQRV9TVUJUUkVFOwoJCX0gZWxzZSB7CgkJCS8qIFRoaXMgY2FuJ3QgYmUgcGFydCBvZiBhIG5vdGUgKi8KCQkJZ290byBoYW5kbGVfbm9uX25vdGU7CgkJfQoKCQlsID0geGNhbGxvYygxLCBzaXplb2YoKmwpKTsKCQlvaWRjcHkoJmwtPmtleV9vaWQsICZvYmplY3Rfb2lkKTsKCQlvaWRjcHkoJmwtPnZhbF9vaWQsICZlbnRyeS5vaWQpOwoJCWlmIChub3RlX3RyZWVfaW5zZXJ0KHQsIG5vZGUsIG4sIGwsIHR5cGUsCgkJCQkgICAgIGNvbWJpbmVfbm90ZXNfY29uY2F0ZW5hdGUpKQoJCQlkaWUoIkZhaWxlZCB0byBsb2FkICVzICVzIGludG8gbm90ZXMgdHJlZSAiCgkJCSAgICAiZnJvbSAlcyIsCgkJCSAgICB0eXBlID09IFBUUl9UWVBFX05PVEUgPyAibm90ZSIgOiAic3VidHJlZSIsCgkJCSAgICBvaWRfdG9faGV4KCZvYmplY3Rfb2lkKSwgdC0+cmVmKTsKCgkJY29udGludWU7CgpoYW5kbGVfbm9uX25vdGU6CgkJLyoKCQkgKiBEZXRlcm1pbmUgZnVsbCBwYXRoIGZvciB0aGlzIG5vbi1ub3RlIGVudHJ5LiBUaGUKCQkgKiBmaWxlbmFtZSBpcyBhbHJlYWR5IGZvdW5kIGluIGVudHJ5LnBhdGgsIGJ1dCB0aGUKCQkgKiBkaXJlY3RvcnkgcGFydCBvZiB0aGUgcGF0aCBtdXN0IGJlIGRlZHVjZWQgZnJvbSB0aGUKCQkgKiBzdWJ0cmVlIGNvbnRhaW5pbmcgdGhpcyBlbnRyeSBiYXNlZCBvbiBvdXIKCQkgKiBrbm93bGVkZ2UgdGhhdCB0aGUgb3ZlcmFsbCBub3RlcyB0cmVlIGZvbGxvd3MgYQoJCSAqIHN0cmljdCBieXRlLWJhc2VkIHByb2dyZXNzaXZlIGZhbm91dCBzdHJ1Y3R1cmUKCQkgKiAoaS5lLiB1c2luZyAyLzM4LCAyLzIvMzYsIGV0Yy4gZmFub3V0cykuCgkJICovCgkJewoJCQlzdHJ1Y3Qgc3RyYnVmIG5vbl9ub3RlX3BhdGggPSBTVFJCVUZfSU5JVDsKCQkJY29uc3QgY2hhciAqcSA9IG9pZF90b19oZXgoJnN1YnRyZWUtPmtleV9vaWQpOwoJCQlzaXplX3QgaTsKCQkJZm9yIChpID0gMDsgaSA8IHByZWZpeF9sZW47IGkrKykgewoJCQkJc3RyYnVmX2FkZGNoKCZub25fbm90ZV9wYXRoLCAqcSsrKTsKCQkJCXN0cmJ1Zl9hZGRjaCgmbm9uX25vdGVfcGF0aCwgKnErKyk7CgkJCQlzdHJidWZfYWRkY2goJm5vbl9ub3RlX3BhdGgsICcvJyk7CgkJCX0KCQkJc3RyYnVmX2FkZHN0cigmbm9uX25vdGVfcGF0aCwgZW50cnkucGF0aCk7CgkJCWFkZF9ub25fbm90ZSh0LCBzdHJidWZfZGV0YWNoKCZub25fbm90ZV9wYXRoLCBOVUxMKSwKCQkJCSAgICAgZW50cnkubW9kZSwgZW50cnkub2lkLmhhc2gpOwoJCX0KCX0KCWZyZWUoYnVmKTsKfQoKLyoKICogRGV0ZXJtaW5lIG9wdGltYWwgb24tZGlzayBmYW5vdXQgZm9yIHRoaXMgcGFydCBvZiB0aGUgbm90ZXMgdHJlZQogKgogKiBHaXZlbiBhIChzdWIpdHJlZSBhbmQgdGhlIGxldmVsIGluIHRoZSBpbnRlcm5hbCB0cmVlIHN0cnVjdHVyZSwgZGV0ZXJtaW5lCiAqIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBleGlzdGluZyBmYW5vdXQgc2hvdWxkIGJlIGV4cGFuZGVkIGZvciB0aGlzCiAqIChzdWIpdHJlZS4KICoKICogVmFsdWVzIG9mIHRoZSAnZmFub3V0JyB2YXJpYWJsZToKICogLSAwOiBObyBmYW5vdXQgKGFsbCBub3RlcyBhcmUgc3RvcmVkIGRpcmVjdGx5IGluIHRoZSByb290IG5vdGVzIHRyZWUpCiAqIC0gMTogMi8zOCBmYW5vdXQKICogLSAyOiAyLzIvMzYgZmFub3V0CiAqIC0gMzogMi8yLzIvMzQgZmFub3V0CiAqIGV0Yy4KICovCnN0YXRpYyB1bnNpZ25lZCBjaGFyIGRldGVybWluZV9mYW5vdXQoc3RydWN0IGludF9ub2RlICp0cmVlLCB1bnNpZ25lZCBjaGFyIG4sCgkJdW5zaWduZWQgY2hhciBmYW5vdXQpCnsKCS8qCgkgKiBUaGUgZm9sbG93aW5nIGlzIGEgc2ltcGxlIGhldXJpc3RpYyB0aGF0IHdvcmtzIHdlbGwgaW4gcHJhY3RpY2U6CgkgKiBGb3IgZWFjaCBldmVuLW51bWJlcmVkIDE2LXRyZWUgbGV2ZWwgKHJlbWVtYmVyIHRoYXQgZWFjaCBvbi1kaXNrCgkgKiBmYW5vdXQgbGV2ZWwgY29ycmVzcG9uZHMgdG8gX3R3b18gMTYtdHJlZSBsZXZlbHMpLCBwZWVrIGF0IGFsbCAxNgoJICogZW50cmllcyBhdCB0aGF0IHRyZWUgbGV2ZWwuIElmIGFsbCBvZiB0aGVtIGFyZSBlaXRoZXIgaW50X25vZGVzIG9yCgkgKiBzdWJ0cmVlIGVudHJpZXMsIHRoZW4gdGhlcmUgYXJlIGxpa2VseSBwbGVudHkgb2Ygbm90ZXMgYmVsb3cgdGhpcwoJICogbGV2ZWwsIHNvIHdlIHJldHVybiBhbiBpbmNyZW1lbnRlZCBmYW5vdXQuCgkgKi8KCXVuc2lnbmVkIGludCBpOwoJaWYgKChuICUgMikgfHwgKG4gPiAyICogZmFub3V0KSkKCQlyZXR1cm4gZmFub3V0OwoJZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHsKCQlzd2l0Y2ggKEdFVF9QVFJfVFlQRSh0cmVlLT5hW2ldKSkgewoJCWNhc2UgUFRSX1RZUEVfU1VCVFJFRToKCQljYXNlIFBUUl9UWVBFX0lOVEVSTkFMOgoJCQljb250aW51ZTsKCQlkZWZhdWx0OgoJCQlyZXR1cm4gZmFub3V0OwoJCX0KCX0KCXJldHVybiBmYW5vdXQgKyAxOwp9CgovKiBoZXggb2lkICsgJy8nIGJldHdlZW4gZWFjaCBwYWlyIG9mIGhleCBkaWdpdHMgKyBOVUwgKi8KI2RlZmluZSBGQU5PVVRfUEFUSF9NQVggR0lUX01BWF9IRVhTWiArIEZBTk9VVF9QQVRIX1NFUEFSQVRPUlNfTUFYICsgMQoKc3RhdGljIHZvaWQgY29uc3RydWN0X3BhdGhfd2l0aF9mYW5vdXQoY29uc3QgdW5zaWduZWQgY2hhciAqaGFzaCwKCQl1bnNpZ25lZCBjaGFyIGZhbm91dCwgY2hhciAqcGF0aCkKewoJdW5zaWduZWQgaW50IGkgPSAwLCBqID0gMDsKCWNvbnN0IGNoYXIgKmhleF9oYXNoID0gaGFzaF90b19oZXgoaGFzaCk7Cglhc3NlcnQoZmFub3V0IDwgdGhlX2hhc2hfYWxnby0+cmF3c3opOwoJd2hpbGUgKGZhbm91dCkgewoJCXBhdGhbaSsrXSA9IGhleF9oYXNoW2orK107CgkJcGF0aFtpKytdID0gaGV4X2hhc2hbaisrXTsKCQlwYXRoW2krK10gPSAnLyc7CgkJZmFub3V0LS07Cgl9Cgl4c25wcmludGYocGF0aCArIGksIEZBTk9VVF9QQVRIX01BWCAtIGksICIlcyIsIGhleF9oYXNoICsgaik7Cn0KCnN0YXRpYyBpbnQgZm9yX2VhY2hfbm90ZV9oZWxwZXIoc3RydWN0IG5vdGVzX3RyZWUgKnQsIHN0cnVjdCBpbnRfbm9kZSAqdHJlZSwKCQl1bnNpZ25lZCBjaGFyIG4sIHVuc2lnbmVkIGNoYXIgZmFub3V0LCBpbnQgZmxhZ3MsCgkJZWFjaF9ub3RlX2ZuIGZuLCB2b2lkICpjYl9kYXRhKQp7Cgl1bnNpZ25lZCBpbnQgaTsKCXZvaWQgKnA7CglpbnQgcmV0ID0gMDsKCXN0cnVjdCBsZWFmX25vZGUgKmw7CglzdGF0aWMgY2hhciBwYXRoW0ZBTk9VVF9QQVRIX01BWF07CgoJZmFub3V0ID0gZGV0ZXJtaW5lX2Zhbm91dCh0cmVlLCBuLCBmYW5vdXQpOwoJZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHsKcmVkbzoKCQlwID0gdHJlZS0+YVtpXTsKCQlzd2l0Y2ggKEdFVF9QVFJfVFlQRShwKSkgewoJCWNhc2UgUFRSX1RZUEVfSU5URVJOQUw6CgkJCS8qIHJlY3Vyc2UgaW50byBpbnRfbm9kZSAqLwoJCQlyZXQgPSBmb3JfZWFjaF9ub3RlX2hlbHBlcih0LCBDTFJfUFRSX1RZUEUocCksIG4gKyAxLAoJCQkJZmFub3V0LCBmbGFncywgZm4sIGNiX2RhdGEpOwoJCQlicmVhazsKCQljYXNlIFBUUl9UWVBFX1NVQlRSRUU6CgkJCWwgPSAoc3RydWN0IGxlYWZfbm9kZSAqKSBDTFJfUFRSX1RZUEUocCk7CgkJCS8qCgkJCSAqIFN1YnRyZWUgZW50cmllcyBpbiB0aGUgbm90ZSB0cmVlIHJlcHJlc2VudCBwYXJ0cyBvZgoJCQkgKiB0aGUgbm90ZSB0cmVlIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW4gZXhwbG9yZWQuIFRoZXJlCgkJCSAqIGlzIGEgZGlyZWN0IHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHN1YnRyZWUgZW50cmllcyBhdAoJCQkgKiBsZXZlbCAnbicgaW4gdGhlIHRyZWUsIGFuZCB0aGUgJ2Zhbm91dCcgdmFyaWFibGU6CgkJCSAqIFN1YnRyZWUgZW50cmllcyBhdCBsZXZlbCAnbiA8IDIgKiBmYW5vdXQnIHNob3VsZCBiZQoJCQkgKiBwcmVzZXJ2ZWQsIHNpbmNlIHRoZXkgY29ycmVzcG9uZCBleGFjdGx5IHRvIGEgZmFub3V0CgkJCSAqIGRpcmVjdG9yeSBpbiB0aGUgb24tZGlzayBzdHJ1Y3R1cmUuIEhvd2V2ZXIsIHN1YnRyZWUKCQkJICogZW50cmllcyBhdCBsZXZlbCAnbiA+PSAyICogZmFub3V0JyBzaG91bGQgTk9UIGJlCgkJCSAqIHByZXNlcnZlZCwgYnV0IHJhdGhlciBjb25zb2xpZGF0ZWQgaW50byB0aGUgYWJvdmUKCQkJICogbm90ZXMgdHJlZSBsZXZlbC4gV2UgYWNoaWV2ZSB0aGlzIGJ5IHVuY29uZGl0aW9uYWxseQoJCQkgKiB1bnBhY2tpbmcgc3VidHJlZSBlbnRyaWVzIHRoYXQgZXhpc3QgYmVsb3cgdGhlCgkJCSAqIHRocmVzaG9sZCBsZXZlbCBhdCAnbiA9IDIgKiBmYW5vdXQnLgoJCQkgKi8KCQkJaWYgKG4gPCAyICogZmFub3V0ICYmCgkJCSAgICBmbGFncyAmIEZPUl9FQUNIX05PVEVfWUlFTERfU1VCVFJFRVMpIHsKCQkJCS8qIGludm9rZSBjYWxsYmFjayB3aXRoIHN1YnRyZWUgKi8KCQkJCXVuc2lnbmVkIGludCBwYXRoX2xlbiA9CgkJCQkJbC0+a2V5X29pZC5oYXNoW0tFWV9JTkRFWF0gKiAyICsgZmFub3V0OwoJCQkJYXNzZXJ0KHBhdGhfbGVuIDwgRkFOT1VUX1BBVEhfTUFYIC0gMSk7CgkJCQljb25zdHJ1Y3RfcGF0aF93aXRoX2Zhbm91dChsLT5rZXlfb2lkLmhhc2gsCgkJCQkJCQkgICBmYW5vdXQsCgkJCQkJCQkgICBwYXRoKTsKCQkJCS8qIENyZWF0ZSB0cmFpbGluZyBzbGFzaCwgaWYgbmVlZGVkICovCgkJCQlpZiAocGF0aFtwYXRoX2xlbiAtIDFdICE9ICcvJykKCQkJCQlwYXRoW3BhdGhfbGVuKytdID0gJy8nOwoJCQkJcGF0aFtwYXRoX2xlbl0gPSAnXDAnOwoJCQkJcmV0ID0gZm4oJmwtPmtleV9vaWQsICZsLT52YWxfb2lkLAoJCQkJCSBwYXRoLAoJCQkJCSBjYl9kYXRhKTsKCQkJfQoJCQlpZiAobiA+PSAyICogZmFub3V0IHx8CgkJCSAgICAhKGZsYWdzICYgRk9SX0VBQ0hfTk9URV9ET05UX1VOUEFDS19TVUJUUkVFUykpIHsKCQkJCS8qIHVucGFjayBzdWJ0cmVlIGFuZCByZXN1bWUgdHJhdmVyc2FsICovCgkJCQl0cmVlLT5hW2ldID0gTlVMTDsKCQkJCWxvYWRfc3VidHJlZSh0LCBsLCB0cmVlLCBuKTsKCQkJCWZyZWUobCk7CgkJCQlnb3RvIHJlZG87CgkJCX0KCQkJYnJlYWs7CgkJY2FzZSBQVFJfVFlQRV9OT1RFOgoJCQlsID0gKHN0cnVjdCBsZWFmX25vZGUgKikgQ0xSX1BUUl9UWVBFKHApOwoJCQljb25zdHJ1Y3RfcGF0aF93aXRoX2Zhbm91dChsLT5rZXlfb2lkLmhhc2gsIGZhbm91dCwKCQkJCQkJICAgcGF0aCk7CgkJCXJldCA9IGZuKCZsLT5rZXlfb2lkLCAmbC0+dmFsX29pZCwgcGF0aCwKCQkJCSBjYl9kYXRhKTsKCQkJYnJlYWs7CgkJfQoJCWlmIChyZXQpCgkJCXJldHVybiByZXQ7Cgl9CglyZXR1cm4gMDsKfQoKc3RydWN0IHRyZWVfd3JpdGVfc3RhY2sgewoJc3RydWN0IHRyZWVfd3JpdGVfc3RhY2sgKm5leHQ7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZjsKCWNoYXIgcGF0aFsyXTsgLyogcGF0aCB0byBzdWJ0cmVlIGluIG5leHQsIGlmIGFueSAqLwp9OwoKc3RhdGljIGlubGluZSBpbnQgbWF0Y2hlc190cmVlX3dyaXRlX3N0YWNrKHN0cnVjdCB0cmVlX3dyaXRlX3N0YWNrICp0d3MsCgkJY29uc3QgY2hhciAqZnVsbF9wYXRoKQp7CglyZXR1cm4gIGZ1bGxfcGF0aFswXSA9PSB0d3MtPnBhdGhbMF0gJiYKCQlmdWxsX3BhdGhbMV0gPT0gdHdzLT5wYXRoWzFdICYmCgkJZnVsbF9wYXRoWzJdID09ICcvJzsKfQoKc3RhdGljIHZvaWQgd3JpdGVfdHJlZV9lbnRyeShzdHJ1Y3Qgc3RyYnVmICpidWYsIHVuc2lnbmVkIGludCBtb2RlLAoJCWNvbnN0IGNoYXIgKnBhdGgsIHVuc2lnbmVkIGludCBwYXRoX2xlbiwgY29uc3QKCQl1bnNpZ25lZCBjaGFyICpoYXNoKQp7CglzdHJidWZfYWRkZihidWYsICIlbyAlLipzJWMiLCBtb2RlLCBwYXRoX2xlbiwgcGF0aCwgJ1wwJyk7CglzdHJidWZfYWRkKGJ1ZiwgaGFzaCwgdGhlX2hhc2hfYWxnby0+cmF3c3opOwp9CgpzdGF0aWMgdm9pZCB0cmVlX3dyaXRlX3N0YWNrX2luaXRfc3VidHJlZShzdHJ1Y3QgdHJlZV93cml0ZV9zdGFjayAqdHdzLAoJCWNvbnN0IGNoYXIgKnBhdGgpCnsKCXN0cnVjdCB0cmVlX3dyaXRlX3N0YWNrICpuOwoJYXNzZXJ0KCF0d3MtPm5leHQpOwoJYXNzZXJ0KHR3cy0+cGF0aFswXSA9PSAnXDAnICYmIHR3cy0+cGF0aFsxXSA9PSAnXDAnKTsKCW4gPSAoc3RydWN0IHRyZWVfd3JpdGVfc3RhY2sgKikKCQl4bWFsbG9jKHNpemVvZihzdHJ1Y3QgdHJlZV93cml0ZV9zdGFjaykpOwoJbi0+bmV4dCA9IE5VTEw7CglzdHJidWZfaW5pdCgmbi0+YnVmLCAyNTYgKiAoMzIgKyB0aGVfaGFzaF9hbGdvLT5oZXhzeikpOyAvKiBhc3N1bWUgMjU2IGVudHJpZXMgcGVyIHRyZWUgKi8KCW4tPnBhdGhbMF0gPSBuLT5wYXRoWzFdID0gJ1wwJzsKCXR3cy0+bmV4dCA9IG47Cgl0d3MtPnBhdGhbMF0gPSBwYXRoWzBdOwoJdHdzLT5wYXRoWzFdID0gcGF0aFsxXTsKfQoKc3RhdGljIGludCB0cmVlX3dyaXRlX3N0YWNrX2ZpbmlzaF9zdWJ0cmVlKHN0cnVjdCB0cmVlX3dyaXRlX3N0YWNrICp0d3MpCnsKCWludCByZXQ7CglzdHJ1Y3QgdHJlZV93cml0ZV9zdGFjayAqbiA9IHR3cy0+bmV4dDsKCXN0cnVjdCBvYmplY3RfaWQgczsKCWlmIChuKSB7CgkJcmV0ID0gdHJlZV93cml0ZV9zdGFja19maW5pc2hfc3VidHJlZShuKTsKCQlpZiAocmV0KQoJCQlyZXR1cm4gcmV0OwoJCXJldCA9IHdyaXRlX29iamVjdF9maWxlKG4tPmJ1Zi5idWYsIG4tPmJ1Zi5sZW4sIHRyZWVfdHlwZSwgJnMpOwoJCWlmIChyZXQpCgkJCXJldHVybiByZXQ7CgkJc3RyYnVmX3JlbGVhc2UoJm4tPmJ1Zik7CgkJZnJlZShuKTsKCQl0d3MtPm5leHQgPSBOVUxMOwoJCXdyaXRlX3RyZWVfZW50cnkoJnR3cy0+YnVmLCAwNDAwMDAsIHR3cy0+cGF0aCwgMiwgcy5oYXNoKTsKCQl0d3MtPnBhdGhbMF0gPSB0d3MtPnBhdGhbMV0gPSAnXDAnOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgd3JpdGVfZWFjaF9ub3RlX2hlbHBlcihzdHJ1Y3QgdHJlZV93cml0ZV9zdGFjayAqdHdzLAoJCWNvbnN0IGNoYXIgKnBhdGgsIHVuc2lnbmVkIGludCBtb2RlLAoJCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJc2l6ZV90IHBhdGhfbGVuID0gc3RybGVuKHBhdGgpOwoJdW5zaWduZWQgaW50IG4gPSAwOwoJaW50IHJldDsKCgkvKiBEZXRlcm1pbmUgY29tbW9uIHBhcnQgb2YgdHJlZSB3cml0ZSBzdGFjayAqLwoJd2hpbGUgKHR3cyAmJiAzICogbiA8IHBhdGhfbGVuICYmCgkgICAgICAgbWF0Y2hlc190cmVlX3dyaXRlX3N0YWNrKHR3cywgcGF0aCArIDMgKiBuKSkgewoJCW4rKzsKCQl0d3MgPSB0d3MtPm5leHQ7Cgl9CgoJLyogdHdzIHBvaW50IHRvIGxhc3QgbWF0Y2hpbmcgdHJlZV93cml0ZV9zdGFjayBlbnRyeSAqLwoJcmV0ID0gdHJlZV93cml0ZV9zdGFja19maW5pc2hfc3VidHJlZSh0d3MpOwoJaWYgKHJldCkKCQlyZXR1cm4gcmV0OwoKCS8qIFN0YXJ0IHN1YnRyZWVzIG5lZWRlZCB0byBzYXRpc2Z5IHBhdGggKi8KCXdoaWxlICgzICogbiArIDIgPCBwYXRoX2xlbiAmJiBwYXRoWzMgKiBuICsgMl0gPT0gJy8nKSB7CgkJdHJlZV93cml0ZV9zdGFja19pbml0X3N1YnRyZWUodHdzLCBwYXRoICsgMyAqIG4pOwoJCW4rKzsKCQl0d3MgPSB0d3MtPm5leHQ7Cgl9CgoJLyogVGhlcmUgc2hvdWxkIGJlIG5vIG1vcmUgZGlyZWN0b3J5IGNvbXBvbmVudHMgaW4gdGhlIGdpdmVuIHBhdGggKi8KCWFzc2VydChtZW1jaHIocGF0aCArIDMgKiBuLCAnLycsIHBhdGhfbGVuIC0gKDMgKiBuKSkgPT0gTlVMTCk7CgoJLyogRmluYWxseSBhZGQgZ2l2ZW4gZW50cnkgdG8gdGhlIGN1cnJlbnQgdHJlZSBvYmplY3QgKi8KCXdyaXRlX3RyZWVfZW50cnkoJnR3cy0+YnVmLCBtb2RlLCBwYXRoICsgMyAqIG4sIHBhdGhfbGVuIC0gKDMgKiBuKSwKCQkJIG9pZC0+aGFzaCk7CgoJcmV0dXJuIDA7Cn0KCnN0cnVjdCB3cml0ZV9lYWNoX25vdGVfZGF0YSB7CglzdHJ1Y3QgdHJlZV93cml0ZV9zdGFjayAqcm9vdDsKCXN0cnVjdCBub25fbm90ZSAqKm5uX2xpc3Q7CglzdHJ1Y3Qgbm9uX25vdGUgKm5uX3ByZXY7Cn07CgpzdGF0aWMgaW50IHdyaXRlX2VhY2hfbm9uX25vdGVfdW50aWwoY29uc3QgY2hhciAqbm90ZV9wYXRoLAoJCXN0cnVjdCB3cml0ZV9lYWNoX25vdGVfZGF0YSAqZCkKewoJc3RydWN0IG5vbl9ub3RlICpwID0gZC0+bm5fcHJldjsKCXN0cnVjdCBub25fbm90ZSAqbiA9IHAgPyBwLT5uZXh0IDogKmQtPm5uX2xpc3Q7CglpbnQgY21wID0gMCwgcmV0OwoJd2hpbGUgKG4gJiYgKCFub3RlX3BhdGggfHwgKGNtcCA9IHN0cmNtcChuLT5wYXRoLCBub3RlX3BhdGgpKSA8PSAwKSkgewoJCWlmIChub3RlX3BhdGggJiYgY21wID09IDApCgkJCTsgLyogZG8gbm90aGluZywgcHJlZmVyIG5vdGUgdG8gbm9uLW5vdGUgKi8KCQllbHNlIHsKCQkJcmV0ID0gd3JpdGVfZWFjaF9ub3RlX2hlbHBlcihkLT5yb290LCBuLT5wYXRoLCBuLT5tb2RlLAoJCQkJCQkgICAgICZuLT5vaWQpOwoJCQlpZiAocmV0KQoJCQkJcmV0dXJuIHJldDsKCQl9CgkJcCA9IG47CgkJbiA9IG4tPm5leHQ7Cgl9CglkLT5ubl9wcmV2ID0gcDsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHdyaXRlX2VhY2hfbm90ZShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvYmplY3Rfb2lkLAoJCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm5vdGVfb2lkLCBjaGFyICpub3RlX3BhdGgsCgkJdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IHdyaXRlX2VhY2hfbm90ZV9kYXRhICpkID0KCQkoc3RydWN0IHdyaXRlX2VhY2hfbm90ZV9kYXRhICopIGNiX2RhdGE7CglzaXplX3Qgbm90ZV9wYXRoX2xlbiA9IHN0cmxlbihub3RlX3BhdGgpOwoJdW5zaWduZWQgaW50IG1vZGUgPSAwMTAwNjQ0OwoKCWlmIChub3RlX3BhdGhbbm90ZV9wYXRoX2xlbiAtIDFdID09ICcvJykgewoJCS8qIHN1YnRyZWUgZW50cnkgKi8KCQlub3RlX3BhdGhfbGVuLS07CgkJbm90ZV9wYXRoW25vdGVfcGF0aF9sZW5dID0gJ1wwJzsKCQltb2RlID0gMDQwMDAwOwoJfQoJYXNzZXJ0KG5vdGVfcGF0aF9sZW4gPD0gR0lUX01BWF9IRVhTWiArIEZBTk9VVF9QQVRIX1NFUEFSQVRPUlMpOwoKCS8qIFdlYXZlIG5vbi1ub3RlIGVudHJpZXMgaW50byBub3RlIGVudHJpZXMgKi8KCXJldHVybiAgd3JpdGVfZWFjaF9ub25fbm90ZV91bnRpbChub3RlX3BhdGgsIGQpIHx8CgkJd3JpdGVfZWFjaF9ub3RlX2hlbHBlcihkLT5yb290LCBub3RlX3BhdGgsIG1vZGUsIG5vdGVfb2lkKTsKfQoKc3RydWN0IG5vdGVfZGVsZXRlX2xpc3QgewoJc3RydWN0IG5vdGVfZGVsZXRlX2xpc3QgKm5leHQ7Cgljb25zdCB1bnNpZ25lZCBjaGFyICpzaGExOwp9OwoKc3RhdGljIGludCBwcnVuZV9ub3Rlc19oZWxwZXIoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2JqZWN0X29pZCwKCQljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpub3RlX29pZCwgY2hhciAqbm90ZV9wYXRoLAoJCXZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBub3RlX2RlbGV0ZV9saXN0ICoqbCA9IChzdHJ1Y3Qgbm90ZV9kZWxldGVfbGlzdCAqKikgY2JfZGF0YTsKCXN0cnVjdCBub3RlX2RlbGV0ZV9saXN0ICpuOwoKCWlmIChoYXNfb2JqZWN0X2ZpbGUob2JqZWN0X29pZCkpCgkJcmV0dXJuIDA7IC8qIG5vdGhpbmcgdG8gZG8gZm9yIHRoaXMgbm90ZSAqLwoKCS8qIGZhaWxlZCB0byBmaW5kIG9iamVjdCA9PiBwcnVuZSB0aGlzIG5vdGUgKi8KCW4gPSAoc3RydWN0IG5vdGVfZGVsZXRlX2xpc3QgKikgeG1hbGxvYyhzaXplb2YoKm4pKTsKCW4tPm5leHQgPSAqbDsKCW4tPnNoYTEgPSBvYmplY3Rfb2lkLT5oYXNoOwoJKmwgPSBuOwoJcmV0dXJuIDA7Cn0KCmludCBjb21iaW5lX25vdGVzX2NvbmNhdGVuYXRlKHN0cnVjdCBvYmplY3RfaWQgKmN1cl9vaWQsCgkJCSAgICAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm5ld19vaWQpCnsKCWNoYXIgKmN1cl9tc2cgPSBOVUxMLCAqbmV3X21zZyA9IE5VTEwsICpidWY7Cgl1bnNpZ25lZCBsb25nIGN1cl9sZW4sIG5ld19sZW4sIGJ1Zl9sZW47CgllbnVtIG9iamVjdF90eXBlIGN1cl90eXBlLCBuZXdfdHlwZTsKCWludCByZXQ7CgoJLyogcmVhZCBpbiBib3RoIG5vdGUgYmxvYiBvYmplY3RzICovCglpZiAoIWlzX251bGxfb2lkKG5ld19vaWQpKQoJCW5ld19tc2cgPSByZWFkX29iamVjdF9maWxlKG5ld19vaWQsICZuZXdfdHlwZSwgJm5ld19sZW4pOwoJaWYgKCFuZXdfbXNnIHx8ICFuZXdfbGVuIHx8IG5ld190eXBlICE9IE9CSl9CTE9CKSB7CgkJZnJlZShuZXdfbXNnKTsKCQlyZXR1cm4gMDsKCX0KCWlmICghaXNfbnVsbF9vaWQoY3VyX29pZCkpCgkJY3VyX21zZyA9IHJlYWRfb2JqZWN0X2ZpbGUoY3VyX29pZCwgJmN1cl90eXBlLCAmY3VyX2xlbik7CglpZiAoIWN1cl9tc2cgfHwgIWN1cl9sZW4gfHwgY3VyX3R5cGUgIT0gT0JKX0JMT0IpIHsKCQlmcmVlKGN1cl9tc2cpOwoJCWZyZWUobmV3X21zZyk7CgkJb2lkY3B5KGN1cl9vaWQsIG5ld19vaWQpOwoJCXJldHVybiAwOwoJfQoKCS8qIHdlIHdpbGwgc2VwYXJhdGUgdGhlIG5vdGVzIGJ5IHR3byBuZXdsaW5lcyBhbnl3YXkgKi8KCWlmIChjdXJfbXNnW2N1cl9sZW4gLSAxXSA9PSAnXG4nKQoJCWN1cl9sZW4tLTsKCgkvKiBjb25jYXRlbmF0ZSBjdXJfbXNnIGFuZCBuZXdfbXNnIGludG8gYnVmICovCglidWZfbGVuID0gY3VyX2xlbiArIDIgKyBuZXdfbGVuOwoJYnVmID0gKGNoYXIgKikgeG1hbGxvYyhidWZfbGVuKTsKCW1lbWNweShidWYsIGN1cl9tc2csIGN1cl9sZW4pOwoJYnVmW2N1cl9sZW5dID0gJ1xuJzsKCWJ1ZltjdXJfbGVuICsgMV0gPSAnXG4nOwoJbWVtY3B5KGJ1ZiArIGN1cl9sZW4gKyAyLCBuZXdfbXNnLCBuZXdfbGVuKTsKCWZyZWUoY3VyX21zZyk7CglmcmVlKG5ld19tc2cpOwoKCS8qIGNyZWF0ZSBhIG5ldyBibG9iIG9iamVjdCBmcm9tIGJ1ZiAqLwoJcmV0ID0gd3JpdGVfb2JqZWN0X2ZpbGUoYnVmLCBidWZfbGVuLCBibG9iX3R5cGUsIGN1cl9vaWQpOwoJZnJlZShidWYpOwoJcmV0dXJuIHJldDsKfQoKaW50IGNvbWJpbmVfbm90ZXNfb3ZlcndyaXRlKHN0cnVjdCBvYmplY3RfaWQgKmN1cl9vaWQsCgkJCSAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpuZXdfb2lkKQp7CglvaWRjcHkoY3VyX29pZCwgbmV3X29pZCk7CglyZXR1cm4gMDsKfQoKaW50IGNvbWJpbmVfbm90ZXNfaWdub3JlKHN0cnVjdCBvYmplY3RfaWQgKmN1cl9vaWQsCgkJCSBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpuZXdfb2lkKQp7CglyZXR1cm4gMDsKfQoKLyoKICogQWRkIHRoZSBsaW5lcyBmcm9tIHRoZSBuYW1lZCBvYmplY3QgdG8gbGlzdCwgd2l0aCB0cmFpbGluZwogKiBuZXdsaW5lcyByZW1vdmVkLgogKi8Kc3RhdGljIGludCBzdHJpbmdfbGlzdF9hZGRfbm90ZV9saW5lcyhzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QsCgkJCQkgICAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCWNoYXIgKmRhdGE7Cgl1bnNpZ25lZCBsb25nIGxlbjsKCWVudW0gb2JqZWN0X3R5cGUgdDsKCglpZiAoaXNfbnVsbF9vaWQob2lkKSkKCQlyZXR1cm4gMDsKCgkvKiByZWFkX3NoYTFfZmlsZSBOVUwtdGVybWluYXRlcyAqLwoJZGF0YSA9IHJlYWRfb2JqZWN0X2ZpbGUob2lkLCAmdCwgJmxlbik7CglpZiAodCAhPSBPQkpfQkxPQiB8fCAhZGF0YSB8fCAhbGVuKSB7CgkJZnJlZShkYXRhKTsKCQlyZXR1cm4gdCAhPSBPQkpfQkxPQiB8fCAhZGF0YTsKCX0KCgkvKgoJICogSWYgdGhlIGxhc3QgbGluZSBvZiB0aGUgZmlsZSBpcyBFT0wtdGVybWluYXRlZCwgdGhpcyB3aWxsCgkgKiBhZGQgYW4gZW1wdHkgc3RyaW5nIHRvIHRoZSBsaXN0LiAgQnV0IGl0IHdpbGwgYmUgcmVtb3ZlZAoJICogbGF0ZXIsIGFsb25nIHdpdGggYW55IGVtcHR5IHN0cmluZ3MgdGhhdCBjYW1lIGZyb20gZW1wdHkKCSAqIGxpbmVzIHdpdGhpbiB0aGUgZmlsZS4KCSAqLwoJc3RyaW5nX2xpc3Rfc3BsaXQobGlzdCwgZGF0YSwgJ1xuJywgLTEpOwoJZnJlZShkYXRhKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHN0cmluZ19saXN0X2pvaW5fbGluZXNfaGVscGVyKHN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtLAoJCQkJCSB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3Qgc3RyYnVmICpidWYgPSBjYl9kYXRhOwoJc3RyYnVmX2FkZHN0cihidWYsIGl0ZW0tPnN0cmluZyk7CglzdHJidWZfYWRkY2goYnVmLCAnXG4nKTsKCXJldHVybiAwOwp9CgppbnQgY29tYmluZV9ub3Rlc19jYXRfc29ydF91bmlxKHN0cnVjdCBvYmplY3RfaWQgKmN1cl9vaWQsCgkJCQljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpuZXdfb2lkKQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3Qgc29ydF91bmlxX2xpc3QgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglpbnQgcmV0ID0gMTsKCgkvKiByZWFkIGJvdGggbm90ZSBibG9iIG9iamVjdHMgaW50byB1bmlxdWVfbGluZXMgKi8KCWlmIChzdHJpbmdfbGlzdF9hZGRfbm90ZV9saW5lcygmc29ydF91bmlxX2xpc3QsIGN1cl9vaWQpKQoJCWdvdG8gb3V0OwoJaWYgKHN0cmluZ19saXN0X2FkZF9ub3RlX2xpbmVzKCZzb3J0X3VuaXFfbGlzdCwgbmV3X29pZCkpCgkJZ290byBvdXQ7CglzdHJpbmdfbGlzdF9yZW1vdmVfZW1wdHlfaXRlbXMoJnNvcnRfdW5pcV9saXN0LCAwKTsKCXN0cmluZ19saXN0X3NvcnQoJnNvcnRfdW5pcV9saXN0KTsKCXN0cmluZ19saXN0X3JlbW92ZV9kdXBsaWNhdGVzKCZzb3J0X3VuaXFfbGlzdCwgMCk7CgoJLyogY3JlYXRlIGEgbmV3IGJsb2Igb2JqZWN0IGZyb20gc29ydF91bmlxX2xpc3QgKi8KCWlmIChmb3JfZWFjaF9zdHJpbmdfbGlzdCgmc29ydF91bmlxX2xpc3QsCgkJCQkgc3RyaW5nX2xpc3Rfam9pbl9saW5lc19oZWxwZXIsICZidWYpKQoJCWdvdG8gb3V0OwoKCXJldCA9IHdyaXRlX29iamVjdF9maWxlKGJ1Zi5idWYsIGJ1Zi5sZW4sIGJsb2JfdHlwZSwgY3VyX29pZCk7CgpvdXQ6CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCXN0cmluZ19saXN0X2NsZWFyKCZzb3J0X3VuaXFfbGlzdCwgMCk7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IHN0cmluZ19saXN0X2FkZF9vbmVfcmVmKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCSAgIGludCBmbGFnLCB2b2lkICpjYikKewoJc3RydWN0IHN0cmluZ19saXN0ICpyZWZzID0gY2I7CglpZiAoIXVuc29ydGVkX3N0cmluZ19saXN0X2hhc19zdHJpbmcocmVmcywgcmVmbmFtZSkpCgkJc3RyaW5nX2xpc3RfYXBwZW5kKHJlZnMsIHJlZm5hbWUpOwoJcmV0dXJuIDA7Cn0KCi8qCiAqIFRoZSBsaXN0IGFyZ3VtZW50IG11c3QgaGF2ZSBzdHJkdXBfc3RyaW5ncyBzZXQgb24gaXQuCiAqLwp2b2lkIHN0cmluZ19saXN0X2FkZF9yZWZzX2J5X2dsb2Ioc3RydWN0IHN0cmluZ19saXN0ICpsaXN0LCBjb25zdCBjaGFyICpnbG9iKQp7Cglhc3NlcnQobGlzdC0+c3RyZHVwX3N0cmluZ3MpOwoJaWYgKGhhc19nbG9iX3NwZWNpYWxzKGdsb2IpKSB7CgkJZm9yX2VhY2hfZ2xvYl9yZWYoc3RyaW5nX2xpc3RfYWRkX29uZV9yZWYsIGdsb2IsIGxpc3QpOwoJfSBlbHNlIHsKCQlzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCQlpZiAoZ2V0X29pZChnbG9iLCAmb2lkKSkKCQkJd2FybmluZygibm90ZXMgcmVmICVzIGlzIGludmFsaWQiLCBnbG9iKTsKCQlpZiAoIXVuc29ydGVkX3N0cmluZ19saXN0X2hhc19zdHJpbmcobGlzdCwgZ2xvYikpCgkJCXN0cmluZ19saXN0X2FwcGVuZChsaXN0LCBnbG9iKTsKCX0KfQoKdm9pZCBzdHJpbmdfbGlzdF9hZGRfcmVmc19mcm9tX2NvbG9uX3NlcChzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QsCgkJCQkJIGNvbnN0IGNoYXIgKmdsb2JzKQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3Qgc3BsaXQgPSBTVFJJTkdfTElTVF9JTklUX05PRFVQOwoJY2hhciAqZ2xvYnNfY29weSA9IHhzdHJkdXAoZ2xvYnMpOwoJaW50IGk7CgoJc3RyaW5nX2xpc3Rfc3BsaXRfaW5fcGxhY2UoJnNwbGl0LCBnbG9ic19jb3B5LCAnOicsIC0xKTsKCXN0cmluZ19saXN0X3JlbW92ZV9lbXB0eV9pdGVtcygmc3BsaXQsIDApOwoKCWZvciAoaSA9IDA7IGkgPCBzcGxpdC5ucjsgaSsrKQoJCXN0cmluZ19saXN0X2FkZF9yZWZzX2J5X2dsb2IobGlzdCwgc3BsaXQuaXRlbXNbaV0uc3RyaW5nKTsKCglzdHJpbmdfbGlzdF9jbGVhcigmc3BsaXQsIDApOwoJZnJlZShnbG9ic19jb3B5KTsKfQoKc3RhdGljIGludCBub3Rlc19kaXNwbGF5X2NvbmZpZyhjb25zdCBjaGFyICprLCBjb25zdCBjaGFyICp2LCB2b2lkICpjYikKewoJaW50ICpsb2FkX3JlZnMgPSBjYjsKCglpZiAoKmxvYWRfcmVmcyAmJiAhc3RyY21wKGssICJub3Rlcy5kaXNwbGF5cmVmIikpIHsKCQlpZiAoIXYpCgkJCWNvbmZpZ19lcnJvcl9ub25ib29sKGspOwoJCXN0cmluZ19saXN0X2FkZF9yZWZzX2J5X2dsb2IoJmRpc3BsYXlfbm90ZXNfcmVmcywgdik7Cgl9CgoJcmV0dXJuIDA7Cn0KCmNvbnN0IGNoYXIgKmRlZmF1bHRfbm90ZXNfcmVmKHZvaWQpCnsKCWNvbnN0IGNoYXIgKm5vdGVzX3JlZiA9IE5VTEw7CglpZiAoIW5vdGVzX3JlZikKCQlub3Rlc19yZWYgPSBnZXRlbnYoR0lUX05PVEVTX1JFRl9FTlZJUk9OTUVOVCk7CglpZiAoIW5vdGVzX3JlZikKCQlub3Rlc19yZWYgPSBub3Rlc19yZWZfbmFtZTsgLyogdmFsdWUgb2YgY29yZS5ub3Rlc1JlZiBjb25maWcgKi8KCWlmICghbm90ZXNfcmVmKQoJCW5vdGVzX3JlZiA9IEdJVF9OT1RFU19ERUZBVUxUX1JFRjsKCXJldHVybiBub3Rlc19yZWY7Cn0KCnZvaWQgaW5pdF9ub3RlcyhzdHJ1Y3Qgbm90ZXNfdHJlZSAqdCwgY29uc3QgY2hhciAqbm90ZXNfcmVmLAoJCWNvbWJpbmVfbm90ZXNfZm4gY29tYmluZV9ub3RlcywgaW50IGZsYWdzKQp7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZCwgb2JqZWN0X29pZDsKCXVuc2lnbmVkIHNob3J0IG1vZGU7CglzdHJ1Y3QgbGVhZl9ub2RlIHJvb3RfdHJlZTsKCglpZiAoIXQpCgkJdCA9ICZkZWZhdWx0X25vdGVzX3RyZWU7Cglhc3NlcnQoIXQtPmluaXRpYWxpemVkKTsKCglpZiAoIW5vdGVzX3JlZikKCQlub3Rlc19yZWYgPSBkZWZhdWx0X25vdGVzX3JlZigpOwoKCWlmICghY29tYmluZV9ub3RlcykKCQljb21iaW5lX25vdGVzID0gY29tYmluZV9ub3Rlc19jb25jYXRlbmF0ZTsKCgl0LT5yb290ID0gKHN0cnVjdCBpbnRfbm9kZSAqKSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3QgaW50X25vZGUpKTsKCXQtPmZpcnN0X25vbl9ub3RlID0gTlVMTDsKCXQtPnByZXZfbm9uX25vdGUgPSBOVUxMOwoJdC0+cmVmID0geHN0cmR1cF9vcl9udWxsKG5vdGVzX3JlZik7Cgl0LT51cGRhdGVfcmVmID0gKGZsYWdzICYgTk9URVNfSU5JVF9XUklUQUJMRSkgPyB0LT5yZWYgOiBOVUxMOwoJdC0+Y29tYmluZV9ub3RlcyA9IGNvbWJpbmVfbm90ZXM7Cgl0LT5pbml0aWFsaXplZCA9IDE7Cgl0LT5kaXJ0eSA9IDA7CgoJaWYgKGZsYWdzICYgTk9URVNfSU5JVF9FTVBUWSB8fCAhbm90ZXNfcmVmIHx8CgkgICAgZ2V0X29pZF90cmVlaXNoKG5vdGVzX3JlZiwgJm9iamVjdF9vaWQpKQoJCXJldHVybjsKCWlmIChmbGFncyAmIE5PVEVTX0lOSVRfV1JJVEFCTEUgJiYgcmVhZF9yZWYobm90ZXNfcmVmLCAmb2JqZWN0X29pZCkpCgkJZGllKCJDYW5ub3QgdXNlIG5vdGVzIHJlZiAlcyIsIG5vdGVzX3JlZik7CglpZiAoZ2V0X3RyZWVfZW50cnkodGhlX3JlcG9zaXRvcnksICZvYmplY3Rfb2lkLCAiIiwgJm9pZCwgJm1vZGUpKQoJCWRpZSgiRmFpbGVkIHRvIHJlYWQgbm90ZXMgdHJlZSByZWZlcmVuY2VkIGJ5ICVzICglcykiLAoJCSAgICBub3Rlc19yZWYsIG9pZF90b19oZXgoJm9iamVjdF9vaWQpKTsKCglvaWRjbHIoJnJvb3RfdHJlZS5rZXlfb2lkKTsKCW9pZGNweSgmcm9vdF90cmVlLnZhbF9vaWQsICZvaWQpOwoJbG9hZF9zdWJ0cmVlKHQsICZyb290X3RyZWUsIHQtPnJvb3QsIDApOwp9CgpzdHJ1Y3Qgbm90ZXNfdHJlZSAqKmxvYWRfbm90ZXNfdHJlZXMoc3RydWN0IHN0cmluZ19saXN0ICpyZWZzLCBpbnQgZmxhZ3MpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoJaW50IGNvdW50ZXIgPSAwOwoJc3RydWN0IG5vdGVzX3RyZWUgKip0cmVlczsKCUFMTE9DX0FSUkFZKHRyZWVzLCByZWZzLT5uciArIDEpOwoJZm9yX2VhY2hfc3RyaW5nX2xpc3RfaXRlbShpdGVtLCByZWZzKSB7CgkJc3RydWN0IG5vdGVzX3RyZWUgKnQgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3Qgbm90ZXNfdHJlZSkpOwoJCWluaXRfbm90ZXModCwgaXRlbS0+c3RyaW5nLCBjb21iaW5lX25vdGVzX2lnbm9yZSwgZmxhZ3MpOwoJCXRyZWVzW2NvdW50ZXIrK10gPSB0OwoJfQoJdHJlZXNbY291bnRlcl0gPSBOVUxMOwoJcmV0dXJuIHRyZWVzOwp9Cgp2b2lkIGluaXRfZGlzcGxheV9ub3RlcyhzdHJ1Y3QgZGlzcGxheV9ub3Rlc19vcHQgKm9wdCkKewoJY2hhciAqZGlzcGxheV9yZWZfZW52OwoJaW50IGxvYWRfY29uZmlnX3JlZnMgPSAwOwoJZGlzcGxheV9ub3Rlc19yZWZzLnN0cmR1cF9zdHJpbmdzID0gMTsKCglhc3NlcnQoIWRpc3BsYXlfbm90ZXNfdHJlZXMpOwoKCWlmICghb3B0IHx8IG9wdC0+dXNlX2RlZmF1bHRfbm90ZXMgPiAwIHx8CgkgICAgKG9wdC0+dXNlX2RlZmF1bHRfbm90ZXMgPT0gLTEgJiYgIW9wdC0+ZXh0cmFfbm90ZXNfcmVmcy5ucikpIHsKCQlzdHJpbmdfbGlzdF9hcHBlbmQoJmRpc3BsYXlfbm90ZXNfcmVmcywgZGVmYXVsdF9ub3Rlc19yZWYoKSk7CgkJZGlzcGxheV9yZWZfZW52ID0gZ2V0ZW52KEdJVF9OT1RFU19ESVNQTEFZX1JFRl9FTlZJUk9OTUVOVCk7CgkJaWYgKGRpc3BsYXlfcmVmX2VudikgewoJCQlzdHJpbmdfbGlzdF9hZGRfcmVmc19mcm9tX2NvbG9uX3NlcCgmZGlzcGxheV9ub3Rlc19yZWZzLAoJCQkJCQkJICAgIGRpc3BsYXlfcmVmX2Vudik7CgkJCWxvYWRfY29uZmlnX3JlZnMgPSAwOwoJCX0gZWxzZQoJCQlsb2FkX2NvbmZpZ19yZWZzID0gMTsKCX0KCglnaXRfY29uZmlnKG5vdGVzX2Rpc3BsYXlfY29uZmlnLCAmbG9hZF9jb25maWdfcmVmcyk7CgoJaWYgKG9wdCkgewoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoJCWZvcl9lYWNoX3N0cmluZ19saXN0X2l0ZW0oaXRlbSwgJm9wdC0+ZXh0cmFfbm90ZXNfcmVmcykKCQkJc3RyaW5nX2xpc3RfYWRkX3JlZnNfYnlfZ2xvYigmZGlzcGxheV9ub3Rlc19yZWZzLAoJCQkJCQkgICAgIGl0ZW0tPnN0cmluZyk7Cgl9CgoJZGlzcGxheV9ub3Rlc190cmVlcyA9IGxvYWRfbm90ZXNfdHJlZXMoJmRpc3BsYXlfbm90ZXNfcmVmcywgMCk7CglzdHJpbmdfbGlzdF9jbGVhcigmZGlzcGxheV9ub3Rlc19yZWZzLCAwKTsKfQoKaW50IGFkZF9ub3RlKHN0cnVjdCBub3Rlc190cmVlICp0LCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvYmplY3Rfb2lkLAoJCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm5vdGVfb2lkLCBjb21iaW5lX25vdGVzX2ZuIGNvbWJpbmVfbm90ZXMpCnsKCXN0cnVjdCBsZWFmX25vZGUgKmw7CgoJaWYgKCF0KQoJCXQgPSAmZGVmYXVsdF9ub3Rlc190cmVlOwoJYXNzZXJ0KHQtPmluaXRpYWxpemVkKTsKCXQtPmRpcnR5ID0gMTsKCWlmICghY29tYmluZV9ub3RlcykKCQljb21iaW5lX25vdGVzID0gdC0+Y29tYmluZV9ub3RlczsKCWwgPSAoc3RydWN0IGxlYWZfbm9kZSAqKSB4bWFsbG9jKHNpemVvZihzdHJ1Y3QgbGVhZl9ub2RlKSk7CglvaWRjcHkoJmwtPmtleV9vaWQsIG9iamVjdF9vaWQpOwoJb2lkY3B5KCZsLT52YWxfb2lkLCBub3RlX29pZCk7CglyZXR1cm4gbm90ZV90cmVlX2luc2VydCh0LCB0LT5yb290LCAwLCBsLCBQVFJfVFlQRV9OT1RFLCBjb21iaW5lX25vdGVzKTsKfQoKaW50IHJlbW92ZV9ub3RlKHN0cnVjdCBub3Rlc190cmVlICp0LCBjb25zdCB1bnNpZ25lZCBjaGFyICpvYmplY3Rfc2hhMSkKewoJc3RydWN0IGxlYWZfbm9kZSBsOwoKCWlmICghdCkKCQl0ID0gJmRlZmF1bHRfbm90ZXNfdHJlZTsKCWFzc2VydCh0LT5pbml0aWFsaXplZCk7CgloYXNoY3B5KGwua2V5X29pZC5oYXNoLCBvYmplY3Rfc2hhMSk7CglvaWRjbHIoJmwudmFsX29pZCk7Cglub3RlX3RyZWVfcmVtb3ZlKHQsIHQtPnJvb3QsIDAsICZsKTsKCWlmIChpc19udWxsX29pZCgmbC52YWxfb2lkKSkgLyogbm8gbm90ZSB3YXMgcmVtb3ZlZCAqLwoJCXJldHVybiAxOwoJdC0+ZGlydHkgPSAxOwoJcmV0dXJuIDA7Cn0KCmNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKmdldF9ub3RlKHN0cnVjdCBub3Rlc190cmVlICp0LAoJCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJc3RydWN0IGxlYWZfbm9kZSAqZm91bmQ7CgoJaWYgKCF0KQoJCXQgPSAmZGVmYXVsdF9ub3Rlc190cmVlOwoJYXNzZXJ0KHQtPmluaXRpYWxpemVkKTsKCWZvdW5kID0gbm90ZV90cmVlX2ZpbmQodCwgdC0+cm9vdCwgMCwgb2lkLT5oYXNoKTsKCXJldHVybiBmb3VuZCA/ICZmb3VuZC0+dmFsX29pZCA6IE5VTEw7Cn0KCmludCBmb3JfZWFjaF9ub3RlKHN0cnVjdCBub3Rlc190cmVlICp0LCBpbnQgZmxhZ3MsIGVhY2hfbm90ZV9mbiBmbiwKCQl2b2lkICpjYl9kYXRhKQp7CglpZiAoIXQpCgkJdCA9ICZkZWZhdWx0X25vdGVzX3RyZWU7Cglhc3NlcnQodC0+aW5pdGlhbGl6ZWQpOwoJcmV0dXJuIGZvcl9lYWNoX25vdGVfaGVscGVyKHQsIHQtPnJvb3QsIDAsIDAsIGZsYWdzLCBmbiwgY2JfZGF0YSk7Cn0KCmludCB3cml0ZV9ub3Rlc190cmVlKHN0cnVjdCBub3Rlc190cmVlICp0LCBzdHJ1Y3Qgb2JqZWN0X2lkICpyZXN1bHQpCnsKCXN0cnVjdCB0cmVlX3dyaXRlX3N0YWNrIHJvb3Q7CglzdHJ1Y3Qgd3JpdGVfZWFjaF9ub3RlX2RhdGEgY2JfZGF0YTsKCWludCByZXQ7CglpbnQgZmxhZ3M7CgoJaWYgKCF0KQoJCXQgPSAmZGVmYXVsdF9ub3Rlc190cmVlOwoJYXNzZXJ0KHQtPmluaXRpYWxpemVkKTsKCgkvKiBQcmVwYXJlIGZvciB0cmF2ZXJzYWwgb2YgY3VycmVudCBub3RlcyB0cmVlICovCglyb290Lm5leHQgPSBOVUxMOyAvKiBsYXN0IGZvcndhcmQgZW50cnkgaW4gbGlzdCBpcyBncm91bmRlZCAqLwoJc3RyYnVmX2luaXQoJnJvb3QuYnVmLCAyNTYgKiAoMzIgKyB0aGVfaGFzaF9hbGdvLT5oZXhzeikpOyAvKiBhc3N1bWUgMjU2IGVudHJpZXMgKi8KCXJvb3QucGF0aFswXSA9IHJvb3QucGF0aFsxXSA9ICdcMCc7CgljYl9kYXRhLnJvb3QgPSAmcm9vdDsKCWNiX2RhdGEubm5fbGlzdCA9ICYodC0+Zmlyc3Rfbm9uX25vdGUpOwoJY2JfZGF0YS5ubl9wcmV2ID0gTlVMTDsKCgkvKiBXcml0ZSB0cmVlIG9iamVjdHMgcmVwcmVzZW50aW5nIGN1cnJlbnQgbm90ZXMgdHJlZSAqLwoJZmxhZ3MgPSBGT1JfRUFDSF9OT1RFX0RPTlRfVU5QQUNLX1NVQlRSRUVTIHwKCQlGT1JfRUFDSF9OT1RFX1lJRUxEX1NVQlRSRUVTOwoJcmV0ID0gZm9yX2VhY2hfbm90ZSh0LCBmbGFncywgd3JpdGVfZWFjaF9ub3RlLCAmY2JfZGF0YSkgfHwKCSAgICAgIHdyaXRlX2VhY2hfbm9uX25vdGVfdW50aWwoTlVMTCwgJmNiX2RhdGEpIHx8CgkgICAgICB0cmVlX3dyaXRlX3N0YWNrX2ZpbmlzaF9zdWJ0cmVlKCZyb290KSB8fAoJICAgICAgd3JpdGVfb2JqZWN0X2ZpbGUocm9vdC5idWYuYnVmLCByb290LmJ1Zi5sZW4sIHRyZWVfdHlwZSwgcmVzdWx0KTsKCXN0cmJ1Zl9yZWxlYXNlKCZyb290LmJ1Zik7CglyZXR1cm4gcmV0Owp9Cgp2b2lkIHBydW5lX25vdGVzKHN0cnVjdCBub3Rlc190cmVlICp0LCBpbnQgZmxhZ3MpCnsKCXN0cnVjdCBub3RlX2RlbGV0ZV9saXN0ICpsID0gTlVMTDsKCglpZiAoIXQpCgkJdCA9ICZkZWZhdWx0X25vdGVzX3RyZWU7Cglhc3NlcnQodC0+aW5pdGlhbGl6ZWQpOwoKCWZvcl9lYWNoX25vdGUodCwgMCwgcHJ1bmVfbm90ZXNfaGVscGVyLCAmbCk7CgoJd2hpbGUgKGwpIHsKCQlpZiAoZmxhZ3MgJiBOT1RFU19QUlVORV9WRVJCT1NFKQoJCQlwcmludGYoIiVzXG4iLCBoYXNoX3RvX2hleChsLT5zaGExKSk7CgkJaWYgKCEoZmxhZ3MgJiBOT1RFU19QUlVORV9EUllSVU4pKQoJCQlyZW1vdmVfbm90ZSh0LCBsLT5zaGExKTsKCQlsID0gbC0+bmV4dDsKCX0KfQoKdm9pZCBmcmVlX25vdGVzKHN0cnVjdCBub3Rlc190cmVlICp0KQp7CglpZiAoIXQpCgkJdCA9ICZkZWZhdWx0X25vdGVzX3RyZWU7CglpZiAodC0+cm9vdCkKCQlub3RlX3RyZWVfZnJlZSh0LT5yb290KTsKCWZyZWUodC0+cm9vdCk7Cgl3aGlsZSAodC0+Zmlyc3Rfbm9uX25vdGUpIHsKCQl0LT5wcmV2X25vbl9ub3RlID0gdC0+Zmlyc3Rfbm9uX25vdGUtPm5leHQ7CgkJZnJlZSh0LT5maXJzdF9ub25fbm90ZS0+cGF0aCk7CgkJZnJlZSh0LT5maXJzdF9ub25fbm90ZSk7CgkJdC0+Zmlyc3Rfbm9uX25vdGUgPSB0LT5wcmV2X25vbl9ub3RlOwoJfQoJZnJlZSh0LT5yZWYpOwoJbWVtc2V0KHQsIDAsIHNpemVvZihzdHJ1Y3Qgbm90ZXNfdHJlZSkpOwp9CgovKgogKiBGaWxsIHRoZSBnaXZlbiBzdHJidWYgd2l0aCB0aGUgbm90ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBvYmplY3QuCiAqCiAqIElmIHRoZSBnaXZlbiBub3Rlc190cmVlIHN0cnVjdHVyZSBpcyBub3QgaW5pdGlhbGl6ZWQsIGl0IHdpbGwgYmUgYXV0by0KICogaW5pdGlhbGl6ZWQgdG8gdGhlIGRlZmF1bHQgdmFsdWUgKHNlZSBkb2N1bWVudGF0aW9uIGZvciBpbml0X25vdGVzKCkgYWJvdmUpLgogKiBJZiB0aGUgZ2l2ZW4gbm90ZXNfdHJlZSBpcyBOVUxMLCB0aGUgaW50ZXJuYWwvZGVmYXVsdCBub3Rlc190cmVlIHdpbGwgYmUKICogdXNlZCBpbnN0ZWFkLgogKgogKiAocmF3ICE9IDApIGdpdmVzIHRoZSAlTiB1c2VyZm9ybWF0OyBvdGhlcndpc2UsIHRoZSBub3RlIG1lc3NhZ2UgaXMgZ2l2ZW4KICogZm9yIGh1bWFuIGNvbnN1bXB0aW9uLgogKi8Kc3RhdGljIHZvaWQgZm9ybWF0X25vdGUoc3RydWN0IG5vdGVzX3RyZWUgKnQsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9iamVjdF9vaWQsCgkJCXN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpvdXRwdXRfZW5jb2RpbmcsIGludCByYXcpCnsKCXN0YXRpYyBjb25zdCBjaGFyIHV0ZjhbXSA9ICJ1dGYtOCI7Cgljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQ7CgljaGFyICptc2csICptc2dfcDsKCXVuc2lnbmVkIGxvbmcgbGluZWxlbiwgbXNnbGVuOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoKCWlmICghdCkKCQl0ID0gJmRlZmF1bHRfbm90ZXNfdHJlZTsKCWlmICghdC0+aW5pdGlhbGl6ZWQpCgkJaW5pdF9ub3Rlcyh0LCBOVUxMLCBOVUxMLCAwKTsKCglvaWQgPSBnZXRfbm90ZSh0LCBvYmplY3Rfb2lkKTsKCWlmICghb2lkKQoJCXJldHVybjsKCglpZiAoIShtc2cgPSByZWFkX29iamVjdF9maWxlKG9pZCwgJnR5cGUsICZtc2dsZW4pKSB8fCB0eXBlICE9IE9CSl9CTE9CKSB7CgkJZnJlZShtc2cpOwoJCXJldHVybjsKCX0KCglpZiAob3V0cHV0X2VuY29kaW5nICYmICpvdXRwdXRfZW5jb2RpbmcgJiYKCSAgICAhaXNfZW5jb2RpbmdfdXRmOChvdXRwdXRfZW5jb2RpbmcpKSB7CgkJY2hhciAqcmVlbmNvZGVkID0gcmVlbmNvZGVfc3RyaW5nKG1zZywgb3V0cHV0X2VuY29kaW5nLCB1dGY4KTsKCQlpZiAocmVlbmNvZGVkKSB7CgkJCWZyZWUobXNnKTsKCQkJbXNnID0gcmVlbmNvZGVkOwoJCQltc2dsZW4gPSBzdHJsZW4obXNnKTsKCQl9Cgl9CgoJLyogd2Ugd2lsbCBlbmQgdGhlIGFubm90YXRpb24gYnkgYSBuZXdsaW5lIGFueXdheSAqLwoJaWYgKG1zZ2xlbiAmJiBtc2dbbXNnbGVuIC0gMV0gPT0gJ1xuJykKCQltc2dsZW4tLTsKCglpZiAoIXJhdykgewoJCWNvbnN0IGNoYXIgKnJlZiA9IHQtPnJlZjsKCQlpZiAoIXJlZiB8fCAhc3RyY21wKHJlZiwgR0lUX05PVEVTX0RFRkFVTFRfUkVGKSkgewoJCQlzdHJidWZfYWRkc3RyKHNiLCAiXG5Ob3RlczpcbiIpOwoJCX0gZWxzZSB7CgkJCWlmIChzdGFydHNfd2l0aChyZWYsICJyZWZzLyIpKQoJCQkJcmVmICs9IDU7CgkJCWlmIChzdGFydHNfd2l0aChyZWYsICJub3Rlcy8iKSkKCQkJCXJlZiArPSA2OwoJCQlzdHJidWZfYWRkZihzYiwgIlxuTm90ZXMgKCVzKTpcbiIsIHJlZik7CgkJfQoJfQoKCWZvciAobXNnX3AgPSBtc2c7IG1zZ19wIDwgbXNnICsgbXNnbGVuOyBtc2dfcCArPSBsaW5lbGVuICsgMSkgewoJCWxpbmVsZW4gPSBzdHJjaHJudWwobXNnX3AsICdcbicpIC0gbXNnX3A7CgoJCWlmICghcmF3KQoJCQlzdHJidWZfYWRkc3RyKHNiLCAiICAgICIpOwoJCXN0cmJ1Zl9hZGQoc2IsIG1zZ19wLCBsaW5lbGVuKTsKCQlzdHJidWZfYWRkY2goc2IsICdcbicpOwoJfQoKCWZyZWUobXNnKTsKfQoKdm9pZCBmb3JtYXRfZGlzcGxheV9ub3Rlcyhjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvYmplY3Rfb2lkLAoJCQkgIHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpvdXRwdXRfZW5jb2RpbmcsIGludCByYXcpCnsKCWludCBpOwoJYXNzZXJ0KGRpc3BsYXlfbm90ZXNfdHJlZXMpOwoJZm9yIChpID0gMDsgZGlzcGxheV9ub3Rlc190cmVlc1tpXTsgaSsrKQoJCWZvcm1hdF9ub3RlKGRpc3BsYXlfbm90ZXNfdHJlZXNbaV0sIG9iamVjdF9vaWQsIHNiLAoJCQkgICAgb3V0cHV0X2VuY29kaW5nLCByYXcpOwp9CgppbnQgY29weV9ub3RlKHN0cnVjdCBub3Rlc190cmVlICp0LAoJICAgICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqZnJvbV9vYmosIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKnRvX29iaiwKCSAgICAgIGludCBmb3JjZSwgY29tYmluZV9ub3Rlc19mbiBjb21iaW5lX25vdGVzKQp7Cgljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpub3RlID0gZ2V0X25vdGUodCwgZnJvbV9vYmopOwoJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqZXhpc3Rpbmdfbm90ZSA9IGdldF9ub3RlKHQsIHRvX29iaik7CgoJaWYgKCFmb3JjZSAmJiBleGlzdGluZ19ub3RlKQoJCXJldHVybiAxOwoKCWlmIChub3RlKQoJCXJldHVybiBhZGRfbm90ZSh0LCB0b19vYmosIG5vdGUsIGNvbWJpbmVfbm90ZXMpOwoJZWxzZSBpZiAoZXhpc3Rpbmdfbm90ZSkKCQlyZXR1cm4gYWRkX25vdGUodCwgdG9fb2JqLCAmbnVsbF9vaWQsIGNvbWJpbmVfbm90ZXMpOwoKCXJldHVybiAwOwp9Cgp2b2lkIGV4cGFuZF9ub3Rlc19yZWYoc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCWlmIChzdGFydHNfd2l0aChzYi0+YnVmLCAicmVmcy9ub3Rlcy8iKSkKCQlyZXR1cm47IC8qIHdlJ3JlIGhhcHB5ICovCgllbHNlIGlmIChzdGFydHNfd2l0aChzYi0+YnVmLCAibm90ZXMvIikpCgkJc3RyYnVmX2luc2VydChzYiwgMCwgInJlZnMvIiwgNSk7CgllbHNlCgkJc3RyYnVmX2luc2VydChzYiwgMCwgInJlZnMvbm90ZXMvIiwgMTEpOwp9Cgp2b2lkIGV4cGFuZF9sb29zZV9ub3Rlc19yZWYoc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCXN0cnVjdCBvYmplY3RfaWQgb2JqZWN0OwoKCWlmIChnZXRfb2lkKHNiLT5idWYsICZvYmplY3QpKSB7CgkJLyogZmFsbGJhY2sgdG8gZXhwYW5kX25vdGVzX3JlZiAqLwoJCWV4cGFuZF9ub3Rlc19yZWYoc2IpOwoJfQp9Cg==",
    "text": "#include \"cache.h\"\n#include \"config.h\"\n#include \"notes.h\"\n#include \"object-store.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"utf8.h\"\n#include \"strbuf.h\"\n#include \"tree-walk.h\"\n#include \"string-list.h\"\n#include \"refs.h\"\n\n/*\n * Use a non-balancing simple 16-tree structure with struct int_node as\n * internal nodes, and struct leaf_node as leaf nodes. Each int_node has a\n * 16-array of pointers to its children.\n * The bottom 2 bits of each pointer is used to identify the pointer type\n * - ptr & 3 == 0 - NULL pointer, assert(ptr == NULL)\n * - ptr & 3 == 1 - pointer to next internal node - cast to struct int_node *\n * - ptr & 3 == 2 - pointer to note entry - cast to struct leaf_node *\n * - ptr & 3 == 3 - pointer to subtree entry - cast to struct leaf_node *\n *\n * The root node is a statically allocated struct int_node.\n */\nstruct int_node {\n\tvoid *a[16];\n};\n\n/*\n * Leaf nodes come in two variants, note entries and subtree entries,\n * distinguished by the LSb of the leaf node pointer (see above).\n * As a note entry, the key is the SHA1 of the referenced object, and the\n * value is the SHA1 of the note object.\n * As a subtree entry, the key is the prefix SHA1 (w/trailing NULs) of the\n * referenced object, using the last byte of the key to store the length of\n * the prefix. The value is the SHA1 of the tree object containing the notes\n * subtree.\n */\nstruct leaf_node {\n\tstruct object_id key_oid;\n\tstruct object_id val_oid;\n};\n\n/*\n * A notes tree may contain entries that are not notes, and that do not follow\n * the naming conventions of notes. There are typically none/few of these, but\n * we still need to keep track of them. Keep a simple linked list sorted alpha-\n * betically on the non-note path. The list is populated when parsing tree\n * objects in load_subtree(), and the non-notes are correctly written back into\n * the tree objects produced by write_notes_tree().\n */\nstruct non_note {\n\tstruct non_note *next; /* grounded (last->next == NULL) */\n\tchar *path;\n\tunsigned int mode;\n\tstruct object_id oid;\n};\n\n#define PTR_TYPE_NULL     0\n#define PTR_TYPE_INTERNAL 1\n#define PTR_TYPE_NOTE     2\n#define PTR_TYPE_SUBTREE  3\n\n#define GET_PTR_TYPE(ptr)       ((uintptr_t) (ptr) & 3)\n#define CLR_PTR_TYPE(ptr)       ((void *) ((uintptr_t) (ptr) & ~3))\n#define SET_PTR_TYPE(ptr, type) ((void *) ((uintptr_t) (ptr) | (type)))\n\n#define GET_NIBBLE(n, sha1) ((((sha1)[(n) >> 1]) >> ((~(n) & 0x01) << 2)) & 0x0f)\n\n#define KEY_INDEX (the_hash_algo->rawsz - 1)\n#define FANOUT_PATH_SEPARATORS (the_hash_algo->rawsz - 1)\n#define FANOUT_PATH_SEPARATORS_MAX ((GIT_MAX_HEXSZ / 2) - 1)\n#define SUBTREE_SHA1_PREFIXCMP(key_sha1, subtree_sha1) \\\n\t(memcmp(key_sha1, subtree_sha1, subtree_sha1[KEY_INDEX]))\n\nstruct notes_tree default_notes_tree;\n\nstatic struct string_list display_notes_refs = STRING_LIST_INIT_NODUP;\nstatic struct notes_tree **display_notes_trees;\n\nstatic void load_subtree(struct notes_tree *t, struct leaf_node *subtree,\n\t\tstruct int_node *node, unsigned int n);\n\n/*\n * Search the tree until the appropriate location for the given key is found:\n * 1. Start at the root node, with n = 0\n * 2. If a[0] at the current level is a matching subtree entry, unpack that\n *    subtree entry and remove it; restart search at the current level.\n * 3. Use the nth nibble of the key as an index into a:\n *    - If a[n] is an int_node, recurse from #2 into that node and increment n\n *    - If a matching subtree entry, unpack that subtree entry (and remove it);\n *      restart search at the current level.\n *    - Otherwise, we have found one of the following:\n *      - a subtree entry which does not match the key\n *      - a note entry which may or may not match the key\n *      - an unused leaf node (NULL)\n *      In any case, set *tree and *n, and return pointer to the tree location.\n */\nstatic void **note_tree_search(struct notes_tree *t, struct int_node **tree,\n\t\tunsigned char *n, const unsigned char *key_sha1)\n{\n\tstruct leaf_node *l;\n\tunsigned char i;\n\tvoid *p = (*tree)->a[0];\n\n\tif (GET_PTR_TYPE(p) == PTR_TYPE_SUBTREE) {\n\t\tl = (struct leaf_node *) CLR_PTR_TYPE(p);\n\t\tif (!SUBTREE_SHA1_PREFIXCMP(key_sha1, l->key_oid.hash)) {\n\t\t\t/* unpack tree and resume search */\n\t\t\t(*tree)->a[0] = NULL;\n\t\t\tload_subtree(t, l, *tree, *n);\n\t\t\tfree(l);\n\t\t\treturn note_tree_search(t, tree, n, key_sha1);\n\t\t}\n\t}\n\n\ti = GET_NIBBLE(*n, key_sha1);\n\tp = (*tree)->a[i];\n\tswitch (GET_PTR_TYPE(p)) {\n\tcase PTR_TYPE_INTERNAL:\n\t\t*tree = CLR_PTR_TYPE(p);\n\t\t(*n)++;\n\t\treturn note_tree_search(t, tree, n, key_sha1);\n\tcase PTR_TYPE_SUBTREE:\n\t\tl = (struct leaf_node *) CLR_PTR_TYPE(p);\n\t\tif (!SUBTREE_SHA1_PREFIXCMP(key_sha1, l->key_oid.hash)) {\n\t\t\t/* unpack tree and resume search */\n\t\t\t(*tree)->a[i] = NULL;\n\t\t\tload_subtree(t, l, *tree, *n);\n\t\t\tfree(l);\n\t\t\treturn note_tree_search(t, tree, n, key_sha1);\n\t\t}\n\t\t/* fall through */\n\tdefault:\n\t\treturn &((*tree)->a[i]);\n\t}\n}\n\n/*\n * To find a leaf_node:\n * Search to the tree location appropriate for the given key:\n * If a note entry with matching key, return the note entry, else return NULL.\n */\nstatic struct leaf_node *note_tree_find(struct notes_tree *t,\n\t\tstruct int_node *tree, unsigned char n,\n\t\tconst unsigned char *key_sha1)\n{\n\tvoid **p = note_tree_search(t, &tree, &n, key_sha1);\n\tif (GET_PTR_TYPE(*p) == PTR_TYPE_NOTE) {\n\t\tstruct leaf_node *l = (struct leaf_node *) CLR_PTR_TYPE(*p);\n\t\tif (hasheq(key_sha1, l->key_oid.hash))\n\t\t\treturn l;\n\t}\n\treturn NULL;\n}\n\n/*\n * How to consolidate an int_node:\n * If there are > 1 non-NULL entries, give up and return non-zero.\n * Otherwise replace the int_node at the given index in the given parent node\n * with the only NOTE entry (or a NULL entry if no entries) from the given\n * tree, and return 0.\n */\nstatic int note_tree_consolidate(struct int_node *tree,\n\tstruct int_node *parent, unsigned char index)\n{\n\tunsigned int i;\n\tvoid *p = NULL;\n\n\tassert(tree && parent);\n\tassert(CLR_PTR_TYPE(parent->a[index]) == tree);\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (GET_PTR_TYPE(tree->a[i]) != PTR_TYPE_NULL) {\n\t\t\tif (p) /* more than one entry */\n\t\t\t\treturn -2;\n\t\t\tp = tree->a[i];\n\t\t}\n\t}\n\n\tif (p && (GET_PTR_TYPE(p) != PTR_TYPE_NOTE))\n\t\treturn -2;\n\t/* replace tree with p in parent[index] */\n\tparent->a[index] = p;\n\tfree(tree);\n\treturn 0;\n}\n\n/*\n * To remove a leaf_node:\n * Search to the tree location appropriate for the given leaf_node's key:\n * - If location does not hold a matching entry, abort and do nothing.\n * - Copy the matching entry's value into the given entry.\n * - Replace the matching leaf_node with a NULL entry (and free the leaf_node).\n * - Consolidate int_nodes repeatedly, while walking up the tree towards root.\n */\nstatic void note_tree_remove(struct notes_tree *t,\n\t\tstruct int_node *tree, unsigned char n,\n\t\tstruct leaf_node *entry)\n{\n\tstruct leaf_node *l;\n\tstruct int_node *parent_stack[GIT_MAX_RAWSZ];\n\tunsigned char i, j;\n\tvoid **p = note_tree_search(t, &tree, &n, entry->key_oid.hash);\n\n\tassert(GET_PTR_TYPE(entry) == 0); /* no type bits set */\n\tif (GET_PTR_TYPE(*p) != PTR_TYPE_NOTE)\n\t\treturn; /* type mismatch, nothing to remove */\n\tl = (struct leaf_node *) CLR_PTR_TYPE(*p);\n\tif (!oideq(&l->key_oid, &entry->key_oid))\n\t\treturn; /* key mismatch, nothing to remove */\n\n\t/* we have found a matching entry */\n\toidcpy(&entry->val_oid, &l->val_oid);\n\tfree(l);\n\t*p = SET_PTR_TYPE(NULL, PTR_TYPE_NULL);\n\n\t/* consolidate this tree level, and parent levels, if possible */\n\tif (!n)\n\t\treturn; /* cannot consolidate top level */\n\t/* first, build stack of ancestors between root and current node */\n\tparent_stack[0] = t->root;\n\tfor (i = 0; i < n; i++) {\n\t\tj = GET_NIBBLE(i, entry->key_oid.hash);\n\t\tparent_stack[i + 1] = CLR_PTR_TYPE(parent_stack[i]->a[j]);\n\t}\n\tassert(i == n && parent_stack[i] == tree);\n\t/* next, unwind stack until note_tree_consolidate() is done */\n\twhile (i > 0 &&\n\t       !note_tree_consolidate(parent_stack[i], parent_stack[i - 1],\n\t\t\t\t      GET_NIBBLE(i - 1, entry->key_oid.hash)))\n\t\ti--;\n}\n\n/*\n * To insert a leaf_node:\n * Search to the tree location appropriate for the given leaf_node's key:\n * - If location is unused (NULL), store the tweaked pointer directly there\n * - If location holds a note entry that matches the note-to-be-inserted, then\n *   combine the two notes (by calling the given combine_notes function).\n * - If location holds a note entry that matches the subtree-to-be-inserted,\n *   then unpack the subtree-to-be-inserted into the location.\n * - If location holds a matching subtree entry, unpack the subtree at that\n *   location, and restart the insert operation from that level.\n * - Else, create a new int_node, holding both the node-at-location and the\n *   node-to-be-inserted, and store the new int_node into the location.\n */\nstatic int note_tree_insert(struct notes_tree *t, struct int_node *tree,\n\t\tunsigned char n, struct leaf_node *entry, unsigned char type,\n\t\tcombine_notes_fn combine_notes)\n{\n\tstruct int_node *new_node;\n\tstruct leaf_node *l;\n\tvoid **p = note_tree_search(t, &tree, &n, entry->key_oid.hash);\n\tint ret = 0;\n\n\tassert(GET_PTR_TYPE(entry) == 0); /* no type bits set */\n\tl = (struct leaf_node *) CLR_PTR_TYPE(*p);\n\tswitch (GET_PTR_TYPE(*p)) {\n\tcase PTR_TYPE_NULL:\n\t\tassert(!*p);\n\t\tif (is_null_oid(&entry->val_oid))\n\t\t\tfree(entry);\n\t\telse\n\t\t\t*p = SET_PTR_TYPE(entry, type);\n\t\treturn 0;\n\tcase PTR_TYPE_NOTE:\n\t\tswitch (type) {\n\t\tcase PTR_TYPE_NOTE:\n\t\t\tif (oideq(&l->key_oid, &entry->key_oid)) {\n\t\t\t\t/* skip concatenation if l == entry */\n\t\t\t\tif (oideq(&l->val_oid, &entry->val_oid)) {\n\t\t\t\t\tfree(entry);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tret = combine_notes(&l->val_oid,\n\t\t\t\t\t\t    &entry->val_oid);\n\t\t\t\tif (!ret && is_null_oid(&l->val_oid))\n\t\t\t\t\tnote_tree_remove(t, tree, n, entry);\n\t\t\t\tfree(entry);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PTR_TYPE_SUBTREE:\n\t\t\tif (!SUBTREE_SHA1_PREFIXCMP(l->key_oid.hash,\n\t\t\t\t\t\t    entry->key_oid.hash)) {\n\t\t\t\t/* unpack 'entry' */\n\t\t\t\tload_subtree(t, entry, tree, n);\n\t\t\t\tfree(entry);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PTR_TYPE_SUBTREE:\n\t\tif (!SUBTREE_SHA1_PREFIXCMP(entry->key_oid.hash, l->key_oid.hash)) {\n\t\t\t/* unpack 'l' and restart insert */\n\t\t\t*p = NULL;\n\t\t\tload_subtree(t, l, tree, n);\n\t\t\tfree(l);\n\t\t\treturn note_tree_insert(t, tree, n, entry, type,\n\t\t\t\t\t\tcombine_notes);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* non-matching leaf_node */\n\tassert(GET_PTR_TYPE(*p) == PTR_TYPE_NOTE ||\n\t       GET_PTR_TYPE(*p) == PTR_TYPE_SUBTREE);\n\tif (is_null_oid(&entry->val_oid)) { /* skip insertion of empty note */\n\t\tfree(entry);\n\t\treturn 0;\n\t}\n\tnew_node = (struct int_node *) xcalloc(1, sizeof(struct int_node));\n\tret = note_tree_insert(t, new_node, n + 1, l, GET_PTR_TYPE(*p),\n\t\t\t       combine_notes);\n\tif (ret)\n\t\treturn ret;\n\t*p = SET_PTR_TYPE(new_node, PTR_TYPE_INTERNAL);\n\treturn note_tree_insert(t, new_node, n + 1, entry, type, combine_notes);\n}\n\n/* Free the entire notes data contained in the given tree */\nstatic void note_tree_free(struct int_node *tree)\n{\n\tunsigned int i;\n\tfor (i = 0; i < 16; i++) {\n\t\tvoid *p = tree->a[i];\n\t\tswitch (GET_PTR_TYPE(p)) {\n\t\tcase PTR_TYPE_INTERNAL:\n\t\t\tnote_tree_free(CLR_PTR_TYPE(p));\n\t\t\t/* fall through */\n\t\tcase PTR_TYPE_NOTE:\n\t\tcase PTR_TYPE_SUBTREE:\n\t\t\tfree(CLR_PTR_TYPE(p));\n\t\t}\n\t}\n}\n\nstatic int non_note_cmp(const struct non_note *a, const struct non_note *b)\n{\n\treturn strcmp(a->path, b->path);\n}\n\n/* note: takes ownership of path string */\nstatic void add_non_note(struct notes_tree *t, char *path,\n\t\tunsigned int mode, const unsigned char *sha1)\n{\n\tstruct non_note *p = t->prev_non_note, *n;\n\tn = (struct non_note *) xmalloc(sizeof(struct non_note));\n\tn->next = NULL;\n\tn->path = path;\n\tn->mode = mode;\n\thashcpy(n->oid.hash, sha1);\n\tt->prev_non_note = n;\n\n\tif (!t->first_non_note) {\n\t\tt->first_non_note = n;\n\t\treturn;\n\t}\n\n\tif (non_note_cmp(p, n) < 0)\n\t\t; /* do nothing  */\n\telse if (non_note_cmp(t->first_non_note, n) <= 0)\n\t\tp = t->first_non_note;\n\telse {\n\t\t/* n sorts before t->first_non_note */\n\t\tn->next = t->first_non_note;\n\t\tt->first_non_note = n;\n\t\treturn;\n\t}\n\n\t/* n sorts equal or after p */\n\twhile (p->next && non_note_cmp(p->next, n) <= 0)\n\t\tp = p->next;\n\n\tif (non_note_cmp(p, n) == 0) { /* n ~= p; overwrite p with n */\n\t\tassert(strcmp(p->path, n->path) == 0);\n\t\tp->mode = n->mode;\n\t\toidcpy(&p->oid, &n->oid);\n\t\tfree(n);\n\t\tt->prev_non_note = p;\n\t\treturn;\n\t}\n\n\t/* n sorts between p and p->next */\n\tn->next = p->next;\n\tp->next = n;\n}\n\nstatic void load_subtree(struct notes_tree *t, struct leaf_node *subtree,\n\t\tstruct int_node *node, unsigned int n)\n{\n\tstruct object_id object_oid;\n\tsize_t prefix_len;\n\tvoid *buf;\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tconst unsigned hashsz = the_hash_algo->rawsz;\n\n\tbuf = fill_tree_descriptor(the_repository, &desc, &subtree->val_oid);\n\tif (!buf)\n\t\tdie(\"Could not read %s for notes-index\",\n\t\t     oid_to_hex(&subtree->val_oid));\n\n\tprefix_len = subtree->key_oid.hash[KEY_INDEX];\n\tif (prefix_len >= hashsz)\n\t\tBUG(\"prefix_len (%\"PRIuMAX\") is out of range\", (uintmax_t)prefix_len);\n\tif (prefix_len * 2 < n)\n\t\tBUG(\"prefix_len (%\"PRIuMAX\") is too small\", (uintmax_t)prefix_len);\n\tmemcpy(object_oid.hash, subtree->key_oid.hash, prefix_len);\n\twhile (tree_entry(&desc, &entry)) {\n\t\tunsigned char type;\n\t\tstruct leaf_node *l;\n\t\tsize_t path_len = strlen(entry.path);\n\n\t\tif (path_len == 2 * (hashsz - prefix_len)) {\n\t\t\t/* This is potentially the remainder of the SHA-1 */\n\n\t\t\tif (!S_ISREG(entry.mode))\n\t\t\t\t/* notes must be blobs */\n\t\t\t\tgoto handle_non_note;\n\n\t\t\tif (hex_to_bytes(object_oid.hash + prefix_len, entry.path,\n\t\t\t\t\t hashsz - prefix_len))\n\t\t\t\tgoto handle_non_note; /* entry.path is not a SHA1 */\n\n\t\t\ttype = PTR_TYPE_NOTE;\n\t\t} else if (path_len == 2) {\n\t\t\t/* This is potentially an internal node */\n\t\t\tsize_t len = prefix_len;\n\n\t\t\tif (!S_ISDIR(entry.mode))\n\t\t\t\t/* internal nodes must be trees */\n\t\t\t\tgoto handle_non_note;\n\n\t\t\tif (hex_to_bytes(object_oid.hash + len++, entry.path, 1))\n\t\t\t\tgoto handle_non_note; /* entry.path is not a SHA1 */\n\n\t\t\t/*\n\t\t\t * Pad the rest of the SHA-1 with zeros,\n\t\t\t * except for the last byte, where we write\n\t\t\t * the length:\n\t\t\t */\n\t\t\tmemset(object_oid.hash + len, 0, hashsz - len - 1);\n\t\t\tobject_oid.hash[KEY_INDEX] = (unsigned char)len;\n\n\t\t\ttype = PTR_TYPE_SUBTREE;\n\t\t} else {\n\t\t\t/* This can't be part of a note */\n\t\t\tgoto handle_non_note;\n\t\t}\n\n\t\tl = xcalloc(1, sizeof(*l));\n\t\toidcpy(&l->key_oid, &object_oid);\n\t\toidcpy(&l->val_oid, &entry.oid);\n\t\tif (note_tree_insert(t, node, n, l, type,\n\t\t\t\t     combine_notes_concatenate))\n\t\t\tdie(\"Failed to load %s %s into notes tree \"\n\t\t\t    \"from %s\",\n\t\t\t    type == PTR_TYPE_NOTE ? \"note\" : \"subtree\",\n\t\t\t    oid_to_hex(&object_oid), t->ref);\n\n\t\tcontinue;\n\nhandle_non_note:\n\t\t/*\n\t\t * Determine full path for this non-note entry. The\n\t\t * filename is already found in entry.path, but the\n\t\t * directory part of the path must be deduced from the\n\t\t * subtree containing this entry based on our\n\t\t * knowledge that the overall notes tree follows a\n\t\t * strict byte-based progressive fanout structure\n\t\t * (i.e. using 2/38, 2/2/36, etc. fanouts).\n\t\t */\n\t\t{\n\t\t\tstruct strbuf non_note_path = STRBUF_INIT;\n\t\t\tconst char *q = oid_to_hex(&subtree->key_oid);\n\t\t\tsize_t i;\n\t\t\tfor (i = 0; i < prefix_len; i++) {\n\t\t\t\tstrbuf_addch(&non_note_path, *q++);\n\t\t\t\tstrbuf_addch(&non_note_path, *q++);\n\t\t\t\tstrbuf_addch(&non_note_path, '/');\n\t\t\t}\n\t\t\tstrbuf_addstr(&non_note_path, entry.path);\n\t\t\tadd_non_note(t, strbuf_detach(&non_note_path, NULL),\n\t\t\t\t     entry.mode, entry.oid.hash);\n\t\t}\n\t}\n\tfree(buf);\n}\n\n/*\n * Determine optimal on-disk fanout for this part of the notes tree\n *\n * Given a (sub)tree and the level in the internal tree structure, determine\n * whether or not the given existing fanout should be expanded for this\n * (sub)tree.\n *\n * Values of the 'fanout' variable:\n * - 0: No fanout (all notes are stored directly in the root notes tree)\n * - 1: 2/38 fanout\n * - 2: 2/2/36 fanout\n * - 3: 2/2/2/34 fanout\n * etc.\n */\nstatic unsigned char determine_fanout(struct int_node *tree, unsigned char n,\n\t\tunsigned char fanout)\n{\n\t/*\n\t * The following is a simple heuristic that works well in practice:\n\t * For each even-numbered 16-tree level (remember that each on-disk\n\t * fanout level corresponds to _two_ 16-tree levels), peek at all 16\n\t * entries at that tree level. If all of them are either int_nodes or\n\t * subtree entries, then there are likely plenty of notes below this\n\t * level, so we return an incremented fanout.\n\t */\n\tunsigned int i;\n\tif ((n % 2) || (n > 2 * fanout))\n\t\treturn fanout;\n\tfor (i = 0; i < 16; i++) {\n\t\tswitch (GET_PTR_TYPE(tree->a[i])) {\n\t\tcase PTR_TYPE_SUBTREE:\n\t\tcase PTR_TYPE_INTERNAL:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\treturn fanout;\n\t\t}\n\t}\n\treturn fanout + 1;\n}\n\n/* hex oid + '/' between each pair of hex digits + NUL */\n#define FANOUT_PATH_MAX GIT_MAX_HEXSZ + FANOUT_PATH_SEPARATORS_MAX + 1\n\nstatic void construct_path_with_fanout(const unsigned char *hash,\n\t\tunsigned char fanout, char *path)\n{\n\tunsigned int i = 0, j = 0;\n\tconst char *hex_hash = hash_to_hex(hash);\n\tassert(fanout < the_hash_algo->rawsz);\n\twhile (fanout) {\n\t\tpath[i++] = hex_hash[j++];\n\t\tpath[i++] = hex_hash[j++];\n\t\tpath[i++] = '/';\n\t\tfanout--;\n\t}\n\txsnprintf(path + i, FANOUT_PATH_MAX - i, \"%s\", hex_hash + j);\n}\n\nstatic int for_each_note_helper(struct notes_tree *t, struct int_node *tree,\n\t\tunsigned char n, unsigned char fanout, int flags,\n\t\teach_note_fn fn, void *cb_data)\n{\n\tunsigned int i;\n\tvoid *p;\n\tint ret = 0;\n\tstruct leaf_node *l;\n\tstatic char path[FANOUT_PATH_MAX];\n\n\tfanout = determine_fanout(tree, n, fanout);\n\tfor (i = 0; i < 16; i++) {\nredo:\n\t\tp = tree->a[i];\n\t\tswitch (GET_PTR_TYPE(p)) {\n\t\tcase PTR_TYPE_INTERNAL:\n\t\t\t/* recurse into int_node */\n\t\t\tret = for_each_note_helper(t, CLR_PTR_TYPE(p), n + 1,\n\t\t\t\tfanout, flags, fn, cb_data);\n\t\t\tbreak;\n\t\tcase PTR_TYPE_SUBTREE:\n\t\t\tl = (struct leaf_node *) CLR_PTR_TYPE(p);\n\t\t\t/*\n\t\t\t * Subtree entries in the note tree represent parts of\n\t\t\t * the note tree that have not yet been explored. There\n\t\t\t * is a direct relationship between subtree entries at\n\t\t\t * level 'n' in the tree, and the 'fanout' variable:\n\t\t\t * Subtree entries at level 'n < 2 * fanout' should be\n\t\t\t * preserved, since they correspond exactly to a fanout\n\t\t\t * directory in the on-disk structure. However, subtree\n\t\t\t * entries at level 'n >= 2 * fanout' should NOT be\n\t\t\t * preserved, but rather consolidated into the above\n\t\t\t * notes tree level. We achieve this by unconditionally\n\t\t\t * unpacking subtree entries that exist below the\n\t\t\t * threshold level at 'n = 2 * fanout'.\n\t\t\t */\n\t\t\tif (n < 2 * fanout &&\n\t\t\t    flags & FOR_EACH_NOTE_YIELD_SUBTREES) {\n\t\t\t\t/* invoke callback with subtree */\n\t\t\t\tunsigned int path_len =\n\t\t\t\t\tl->key_oid.hash[KEY_INDEX] * 2 + fanout;\n\t\t\t\tassert(path_len < FANOUT_PATH_MAX - 1);\n\t\t\t\tconstruct_path_with_fanout(l->key_oid.hash,\n\t\t\t\t\t\t\t   fanout,\n\t\t\t\t\t\t\t   path);\n\t\t\t\t/* Create trailing slash, if needed */\n\t\t\t\tif (path[path_len - 1] != '/')\n\t\t\t\t\tpath[path_len++] = '/';\n\t\t\t\tpath[path_len] = '\\0';\n\t\t\t\tret = fn(&l->key_oid, &l->val_oid,\n\t\t\t\t\t path,\n\t\t\t\t\t cb_data);\n\t\t\t}\n\t\t\tif (n >= 2 * fanout ||\n\t\t\t    !(flags & FOR_EACH_NOTE_DONT_UNPACK_SUBTREES)) {\n\t\t\t\t/* unpack subtree and resume traversal */\n\t\t\t\ttree->a[i] = NULL;\n\t\t\t\tload_subtree(t, l, tree, n);\n\t\t\t\tfree(l);\n\t\t\t\tgoto redo;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PTR_TYPE_NOTE:\n\t\t\tl = (struct leaf_node *) CLR_PTR_TYPE(p);\n\t\t\tconstruct_path_with_fanout(l->key_oid.hash, fanout,\n\t\t\t\t\t\t   path);\n\t\t\tret = fn(&l->key_oid, &l->val_oid, path,\n\t\t\t\t cb_data);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstruct tree_write_stack {\n\tstruct tree_write_stack *next;\n\tstruct strbuf buf;\n\tchar path[2]; /* path to subtree in next, if any */\n};\n\nstatic inline int matches_tree_write_stack(struct tree_write_stack *tws,\n\t\tconst char *full_path)\n{\n\treturn  full_path[0] == tws->path[0] &&\n\t\tfull_path[1] == tws->path[1] &&\n\t\tfull_path[2] == '/';\n}\n\nstatic void write_tree_entry(struct strbuf *buf, unsigned int mode,\n\t\tconst char *path, unsigned int path_len, const\n\t\tunsigned char *hash)\n{\n\tstrbuf_addf(buf, \"%o %.*s%c\", mode, path_len, path, '\\0');\n\tstrbuf_add(buf, hash, the_hash_algo->rawsz);\n}\n\nstatic void tree_write_stack_init_subtree(struct tree_write_stack *tws,\n\t\tconst char *path)\n{\n\tstruct tree_write_stack *n;\n\tassert(!tws->next);\n\tassert(tws->path[0] == '\\0' && tws->path[1] == '\\0');\n\tn = (struct tree_write_stack *)\n\t\txmalloc(sizeof(struct tree_write_stack));\n\tn->next = NULL;\n\tstrbuf_init(&n->buf, 256 * (32 + the_hash_algo->hexsz)); /* assume 256 entries per tree */\n\tn->path[0] = n->path[1] = '\\0';\n\ttws->next = n;\n\ttws->path[0] = path[0];\n\ttws->path[1] = path[1];\n}\n\nstatic int tree_write_stack_finish_subtree(struct tree_write_stack *tws)\n{\n\tint ret;\n\tstruct tree_write_stack *n = tws->next;\n\tstruct object_id s;\n\tif (n) {\n\t\tret = tree_write_stack_finish_subtree(n);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = write_object_file(n->buf.buf, n->buf.len, tree_type, &s);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tstrbuf_release(&n->buf);\n\t\tfree(n);\n\t\ttws->next = NULL;\n\t\twrite_tree_entry(&tws->buf, 040000, tws->path, 2, s.hash);\n\t\ttws->path[0] = tws->path[1] = '\\0';\n\t}\n\treturn 0;\n}\n\nstatic int write_each_note_helper(struct tree_write_stack *tws,\n\t\tconst char *path, unsigned int mode,\n\t\tconst struct object_id *oid)\n{\n\tsize_t path_len = strlen(path);\n\tunsigned int n = 0;\n\tint ret;\n\n\t/* Determine common part of tree write stack */\n\twhile (tws && 3 * n < path_len &&\n\t       matches_tree_write_stack(tws, path + 3 * n)) {\n\t\tn++;\n\t\ttws = tws->next;\n\t}\n\n\t/* tws point to last matching tree_write_stack entry */\n\tret = tree_write_stack_finish_subtree(tws);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Start subtrees needed to satisfy path */\n\twhile (3 * n + 2 < path_len && path[3 * n + 2] == '/') {\n\t\ttree_write_stack_init_subtree(tws, path + 3 * n);\n\t\tn++;\n\t\ttws = tws->next;\n\t}\n\n\t/* There should be no more directory components in the given path */\n\tassert(memchr(path + 3 * n, '/', path_len - (3 * n)) == NULL);\n\n\t/* Finally add given entry to the current tree object */\n\twrite_tree_entry(&tws->buf, mode, path + 3 * n, path_len - (3 * n),\n\t\t\t oid->hash);\n\n\treturn 0;\n}\n\nstruct write_each_note_data {\n\tstruct tree_write_stack *root;\n\tstruct non_note **nn_list;\n\tstruct non_note *nn_prev;\n};\n\nstatic int write_each_non_note_until(const char *note_path,\n\t\tstruct write_each_note_data *d)\n{\n\tstruct non_note *p = d->nn_prev;\n\tstruct non_note *n = p ? p->next : *d->nn_list;\n\tint cmp = 0, ret;\n\twhile (n && (!note_path || (cmp = strcmp(n->path, note_path)) <= 0)) {\n\t\tif (note_path && cmp == 0)\n\t\t\t; /* do nothing, prefer note to non-note */\n\t\telse {\n\t\t\tret = write_each_note_helper(d->root, n->path, n->mode,\n\t\t\t\t\t\t     &n->oid);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tp = n;\n\t\tn = n->next;\n\t}\n\td->nn_prev = p;\n\treturn 0;\n}\n\nstatic int write_each_note(const struct object_id *object_oid,\n\t\tconst struct object_id *note_oid, char *note_path,\n\t\tvoid *cb_data)\n{\n\tstruct write_each_note_data *d =\n\t\t(struct write_each_note_data *) cb_data;\n\tsize_t note_path_len = strlen(note_path);\n\tunsigned int mode = 0100644;\n\n\tif (note_path[note_path_len - 1] == '/') {\n\t\t/* subtree entry */\n\t\tnote_path_len--;\n\t\tnote_path[note_path_len] = '\\0';\n\t\tmode = 040000;\n\t}\n\tassert(note_path_len <= GIT_MAX_HEXSZ + FANOUT_PATH_SEPARATORS);\n\n\t/* Weave non-note entries into note entries */\n\treturn  write_each_non_note_until(note_path, d) ||\n\t\twrite_each_note_helper(d->root, note_path, mode, note_oid);\n}\n\nstruct note_delete_list {\n\tstruct note_delete_list *next;\n\tconst unsigned char *sha1;\n};\n\nstatic int prune_notes_helper(const struct object_id *object_oid,\n\t\tconst struct object_id *note_oid, char *note_path,\n\t\tvoid *cb_data)\n{\n\tstruct note_delete_list **l = (struct note_delete_list **) cb_data;\n\tstruct note_delete_list *n;\n\n\tif (has_object_file(object_oid))\n\t\treturn 0; /* nothing to do for this note */\n\n\t/* failed to find object => prune this note */\n\tn = (struct note_delete_list *) xmalloc(sizeof(*n));\n\tn->next = *l;\n\tn->sha1 = object_oid->hash;\n\t*l = n;\n\treturn 0;\n}\n\nint combine_notes_concatenate(struct object_id *cur_oid,\n\t\t\t      const struct object_id *new_oid)\n{\n\tchar *cur_msg = NULL, *new_msg = NULL, *buf;\n\tunsigned long cur_len, new_len, buf_len;\n\tenum object_type cur_type, new_type;\n\tint ret;\n\n\t/* read in both note blob objects */\n\tif (!is_null_oid(new_oid))\n\t\tnew_msg = read_object_file(new_oid, &new_type, &new_len);\n\tif (!new_msg || !new_len || new_type != OBJ_BLOB) {\n\t\tfree(new_msg);\n\t\treturn 0;\n\t}\n\tif (!is_null_oid(cur_oid))\n\t\tcur_msg = read_object_file(cur_oid, &cur_type, &cur_len);\n\tif (!cur_msg || !cur_len || cur_type != OBJ_BLOB) {\n\t\tfree(cur_msg);\n\t\tfree(new_msg);\n\t\toidcpy(cur_oid, new_oid);\n\t\treturn 0;\n\t}\n\n\t/* we will separate the notes by two newlines anyway */\n\tif (cur_msg[cur_len - 1] == '\\n')\n\t\tcur_len--;\n\n\t/* concatenate cur_msg and new_msg into buf */\n\tbuf_len = cur_len + 2 + new_len;\n\tbuf = (char *) xmalloc(buf_len);\n\tmemcpy(buf, cur_msg, cur_len);\n\tbuf[cur_len] = '\\n';\n\tbuf[cur_len + 1] = '\\n';\n\tmemcpy(buf + cur_len + 2, new_msg, new_len);\n\tfree(cur_msg);\n\tfree(new_msg);\n\n\t/* create a new blob object from buf */\n\tret = write_object_file(buf, buf_len, blob_type, cur_oid);\n\tfree(buf);\n\treturn ret;\n}\n\nint combine_notes_overwrite(struct object_id *cur_oid,\n\t\t\t    const struct object_id *new_oid)\n{\n\toidcpy(cur_oid, new_oid);\n\treturn 0;\n}\n\nint combine_notes_ignore(struct object_id *cur_oid,\n\t\t\t const struct object_id *new_oid)\n{\n\treturn 0;\n}\n\n/*\n * Add the lines from the named object to list, with trailing\n * newlines removed.\n */\nstatic int string_list_add_note_lines(struct string_list *list,\n\t\t\t\t      const struct object_id *oid)\n{\n\tchar *data;\n\tunsigned long len;\n\tenum object_type t;\n\n\tif (is_null_oid(oid))\n\t\treturn 0;\n\n\t/* read_sha1_file NUL-terminates */\n\tdata = read_object_file(oid, &t, &len);\n\tif (t != OBJ_BLOB || !data || !len) {\n\t\tfree(data);\n\t\treturn t != OBJ_BLOB || !data;\n\t}\n\n\t/*\n\t * If the last line of the file is EOL-terminated, this will\n\t * add an empty string to the list.  But it will be removed\n\t * later, along with any empty strings that came from empty\n\t * lines within the file.\n\t */\n\tstring_list_split(list, data, '\\n', -1);\n\tfree(data);\n\treturn 0;\n}\n\nstatic int string_list_join_lines_helper(struct string_list_item *item,\n\t\t\t\t\t void *cb_data)\n{\n\tstruct strbuf *buf = cb_data;\n\tstrbuf_addstr(buf, item->string);\n\tstrbuf_addch(buf, '\\n');\n\treturn 0;\n}\n\nint combine_notes_cat_sort_uniq(struct object_id *cur_oid,\n\t\t\t\tconst struct object_id *new_oid)\n{\n\tstruct string_list sort_uniq_list = STRING_LIST_INIT_DUP;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint ret = 1;\n\n\t/* read both note blob objects into unique_lines */\n\tif (string_list_add_note_lines(&sort_uniq_list, cur_oid))\n\t\tgoto out;\n\tif (string_list_add_note_lines(&sort_uniq_list, new_oid))\n\t\tgoto out;\n\tstring_list_remove_empty_items(&sort_uniq_list, 0);\n\tstring_list_sort(&sort_uniq_list);\n\tstring_list_remove_duplicates(&sort_uniq_list, 0);\n\n\t/* create a new blob object from sort_uniq_list */\n\tif (for_each_string_list(&sort_uniq_list,\n\t\t\t\t string_list_join_lines_helper, &buf))\n\t\tgoto out;\n\n\tret = write_object_file(buf.buf, buf.len, blob_type, cur_oid);\n\nout:\n\tstrbuf_release(&buf);\n\tstring_list_clear(&sort_uniq_list, 0);\n\treturn ret;\n}\n\nstatic int string_list_add_one_ref(const char *refname, const struct object_id *oid,\n\t\t\t\t   int flag, void *cb)\n{\n\tstruct string_list *refs = cb;\n\tif (!unsorted_string_list_has_string(refs, refname))\n\t\tstring_list_append(refs, refname);\n\treturn 0;\n}\n\n/*\n * The list argument must have strdup_strings set on it.\n */\nvoid string_list_add_refs_by_glob(struct string_list *list, const char *glob)\n{\n\tassert(list->strdup_strings);\n\tif (has_glob_specials(glob)) {\n\t\tfor_each_glob_ref(string_list_add_one_ref, glob, list);\n\t} else {\n\t\tstruct object_id oid;\n\t\tif (get_oid(glob, &oid))\n\t\t\twarning(\"notes ref %s is invalid\", glob);\n\t\tif (!unsorted_string_list_has_string(list, glob))\n\t\t\tstring_list_append(list, glob);\n\t}\n}\n\nvoid string_list_add_refs_from_colon_sep(struct string_list *list,\n\t\t\t\t\t const char *globs)\n{\n\tstruct string_list split = STRING_LIST_INIT_NODUP;\n\tchar *globs_copy = xstrdup(globs);\n\tint i;\n\n\tstring_list_split_in_place(&split, globs_copy, ':', -1);\n\tstring_list_remove_empty_items(&split, 0);\n\n\tfor (i = 0; i < split.nr; i++)\n\t\tstring_list_add_refs_by_glob(list, split.items[i].string);\n\n\tstring_list_clear(&split, 0);\n\tfree(globs_copy);\n}\n\nstatic int notes_display_config(const char *k, const char *v, void *cb)\n{\n\tint *load_refs = cb;\n\n\tif (*load_refs && !strcmp(k, \"notes.displayref\")) {\n\t\tif (!v)\n\t\t\tconfig_error_nonbool(k);\n\t\tstring_list_add_refs_by_glob(&display_notes_refs, v);\n\t}\n\n\treturn 0;\n}\n\nconst char *default_notes_ref(void)\n{\n\tconst char *notes_ref = NULL;\n\tif (!notes_ref)\n\t\tnotes_ref = getenv(GIT_NOTES_REF_ENVIRONMENT);\n\tif (!notes_ref)\n\t\tnotes_ref = notes_ref_name; /* value of core.notesRef config */\n\tif (!notes_ref)\n\t\tnotes_ref = GIT_NOTES_DEFAULT_REF;\n\treturn notes_ref;\n}\n\nvoid init_notes(struct notes_tree *t, const char *notes_ref,\n\t\tcombine_notes_fn combine_notes, int flags)\n{\n\tstruct object_id oid, object_oid;\n\tunsigned short mode;\n\tstruct leaf_node root_tree;\n\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tassert(!t->initialized);\n\n\tif (!notes_ref)\n\t\tnotes_ref = default_notes_ref();\n\n\tif (!combine_notes)\n\t\tcombine_notes = combine_notes_concatenate;\n\n\tt->root = (struct int_node *) xcalloc(1, sizeof(struct int_node));\n\tt->first_non_note = NULL;\n\tt->prev_non_note = NULL;\n\tt->ref = xstrdup_or_null(notes_ref);\n\tt->update_ref = (flags & NOTES_INIT_WRITABLE) ? t->ref : NULL;\n\tt->combine_notes = combine_notes;\n\tt->initialized = 1;\n\tt->dirty = 0;\n\n\tif (flags & NOTES_INIT_EMPTY || !notes_ref ||\n\t    get_oid_treeish(notes_ref, &object_oid))\n\t\treturn;\n\tif (flags & NOTES_INIT_WRITABLE && read_ref(notes_ref, &object_oid))\n\t\tdie(\"Cannot use notes ref %s\", notes_ref);\n\tif (get_tree_entry(the_repository, &object_oid, \"\", &oid, &mode))\n\t\tdie(\"Failed to read notes tree referenced by %s (%s)\",\n\t\t    notes_ref, oid_to_hex(&object_oid));\n\n\toidclr(&root_tree.key_oid);\n\toidcpy(&root_tree.val_oid, &oid);\n\tload_subtree(t, &root_tree, t->root, 0);\n}\n\nstruct notes_tree **load_notes_trees(struct string_list *refs, int flags)\n{\n\tstruct string_list_item *item;\n\tint counter = 0;\n\tstruct notes_tree **trees;\n\tALLOC_ARRAY(trees, refs->nr + 1);\n\tfor_each_string_list_item(item, refs) {\n\t\tstruct notes_tree *t = xcalloc(1, sizeof(struct notes_tree));\n\t\tinit_notes(t, item->string, combine_notes_ignore, flags);\n\t\ttrees[counter++] = t;\n\t}\n\ttrees[counter] = NULL;\n\treturn trees;\n}\n\nvoid init_display_notes(struct display_notes_opt *opt)\n{\n\tchar *display_ref_env;\n\tint load_config_refs = 0;\n\tdisplay_notes_refs.strdup_strings = 1;\n\n\tassert(!display_notes_trees);\n\n\tif (!opt || opt->use_default_notes > 0 ||\n\t    (opt->use_default_notes == -1 && !opt->extra_notes_refs.nr)) {\n\t\tstring_list_append(&display_notes_refs, default_notes_ref());\n\t\tdisplay_ref_env = getenv(GIT_NOTES_DISPLAY_REF_ENVIRONMENT);\n\t\tif (display_ref_env) {\n\t\t\tstring_list_add_refs_from_colon_sep(&display_notes_refs,\n\t\t\t\t\t\t\t    display_ref_env);\n\t\t\tload_config_refs = 0;\n\t\t} else\n\t\t\tload_config_refs = 1;\n\t}\n\n\tgit_config(notes_display_config, &load_config_refs);\n\n\tif (opt) {\n\t\tstruct string_list_item *item;\n\t\tfor_each_string_list_item(item, &opt->extra_notes_refs)\n\t\t\tstring_list_add_refs_by_glob(&display_notes_refs,\n\t\t\t\t\t\t     item->string);\n\t}\n\n\tdisplay_notes_trees = load_notes_trees(&display_notes_refs, 0);\n\tstring_list_clear(&display_notes_refs, 0);\n}\n\nint add_note(struct notes_tree *t, const struct object_id *object_oid,\n\t\tconst struct object_id *note_oid, combine_notes_fn combine_notes)\n{\n\tstruct leaf_node *l;\n\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tassert(t->initialized);\n\tt->dirty = 1;\n\tif (!combine_notes)\n\t\tcombine_notes = t->combine_notes;\n\tl = (struct leaf_node *) xmalloc(sizeof(struct leaf_node));\n\toidcpy(&l->key_oid, object_oid);\n\toidcpy(&l->val_oid, note_oid);\n\treturn note_tree_insert(t, t->root, 0, l, PTR_TYPE_NOTE, combine_notes);\n}\n\nint remove_note(struct notes_tree *t, const unsigned char *object_sha1)\n{\n\tstruct leaf_node l;\n\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tassert(t->initialized);\n\thashcpy(l.key_oid.hash, object_sha1);\n\toidclr(&l.val_oid);\n\tnote_tree_remove(t, t->root, 0, &l);\n\tif (is_null_oid(&l.val_oid)) /* no note was removed */\n\t\treturn 1;\n\tt->dirty = 1;\n\treturn 0;\n}\n\nconst struct object_id *get_note(struct notes_tree *t,\n\t\tconst struct object_id *oid)\n{\n\tstruct leaf_node *found;\n\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tassert(t->initialized);\n\tfound = note_tree_find(t, t->root, 0, oid->hash);\n\treturn found ? &found->val_oid : NULL;\n}\n\nint for_each_note(struct notes_tree *t, int flags, each_note_fn fn,\n\t\tvoid *cb_data)\n{\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tassert(t->initialized);\n\treturn for_each_note_helper(t, t->root, 0, 0, flags, fn, cb_data);\n}\n\nint write_notes_tree(struct notes_tree *t, struct object_id *result)\n{\n\tstruct tree_write_stack root;\n\tstruct write_each_note_data cb_data;\n\tint ret;\n\tint flags;\n\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tassert(t->initialized);\n\n\t/* Prepare for traversal of current notes tree */\n\troot.next = NULL; /* last forward entry in list is grounded */\n\tstrbuf_init(&root.buf, 256 * (32 + the_hash_algo->hexsz)); /* assume 256 entries */\n\troot.path[0] = root.path[1] = '\\0';\n\tcb_data.root = &root;\n\tcb_data.nn_list = &(t->first_non_note);\n\tcb_data.nn_prev = NULL;\n\n\t/* Write tree objects representing current notes tree */\n\tflags = FOR_EACH_NOTE_DONT_UNPACK_SUBTREES |\n\t\tFOR_EACH_NOTE_YIELD_SUBTREES;\n\tret = for_each_note(t, flags, write_each_note, &cb_data) ||\n\t      write_each_non_note_until(NULL, &cb_data) ||\n\t      tree_write_stack_finish_subtree(&root) ||\n\t      write_object_file(root.buf.buf, root.buf.len, tree_type, result);\n\tstrbuf_release(&root.buf);\n\treturn ret;\n}\n\nvoid prune_notes(struct notes_tree *t, int flags)\n{\n\tstruct note_delete_list *l = NULL;\n\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tassert(t->initialized);\n\n\tfor_each_note(t, 0, prune_notes_helper, &l);\n\n\twhile (l) {\n\t\tif (flags & NOTES_PRUNE_VERBOSE)\n\t\t\tprintf(\"%s\\n\", hash_to_hex(l->sha1));\n\t\tif (!(flags & NOTES_PRUNE_DRYRUN))\n\t\t\tremove_note(t, l->sha1);\n\t\tl = l->next;\n\t}\n}\n\nvoid free_notes(struct notes_tree *t)\n{\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tif (t->root)\n\t\tnote_tree_free(t->root);\n\tfree(t->root);\n\twhile (t->first_non_note) {\n\t\tt->prev_non_note = t->first_non_note->next;\n\t\tfree(t->first_non_note->path);\n\t\tfree(t->first_non_note);\n\t\tt->first_non_note = t->prev_non_note;\n\t}\n\tfree(t->ref);\n\tmemset(t, 0, sizeof(struct notes_tree));\n}\n\n/*\n * Fill the given strbuf with the notes associated with the given object.\n *\n * If the given notes_tree structure is not initialized, it will be auto-\n * initialized to the default value (see documentation for init_notes() above).\n * If the given notes_tree is NULL, the internal/default notes_tree will be\n * used instead.\n *\n * (raw != 0) gives the %N userformat; otherwise, the note message is given\n * for human consumption.\n */\nstatic void format_note(struct notes_tree *t, const struct object_id *object_oid,\n\t\t\tstruct strbuf *sb, const char *output_encoding, int raw)\n{\n\tstatic const char utf8[] = \"utf-8\";\n\tconst struct object_id *oid;\n\tchar *msg, *msg_p;\n\tunsigned long linelen, msglen;\n\tenum object_type type;\n\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tif (!t->initialized)\n\t\tinit_notes(t, NULL, NULL, 0);\n\n\toid = get_note(t, object_oid);\n\tif (!oid)\n\t\treturn;\n\n\tif (!(msg = read_object_file(oid, &type, &msglen)) || type != OBJ_BLOB) {\n\t\tfree(msg);\n\t\treturn;\n\t}\n\n\tif (output_encoding && *output_encoding &&\n\t    !is_encoding_utf8(output_encoding)) {\n\t\tchar *reencoded = reencode_string(msg, output_encoding, utf8);\n\t\tif (reencoded) {\n\t\t\tfree(msg);\n\t\t\tmsg = reencoded;\n\t\t\tmsglen = strlen(msg);\n\t\t}\n\t}\n\n\t/* we will end the annotation by a newline anyway */\n\tif (msglen && msg[msglen - 1] == '\\n')\n\t\tmsglen--;\n\n\tif (!raw) {\n\t\tconst char *ref = t->ref;\n\t\tif (!ref || !strcmp(ref, GIT_NOTES_DEFAULT_REF)) {\n\t\t\tstrbuf_addstr(sb, \"\\nNotes:\\n\");\n\t\t} else {\n\t\t\tif (starts_with(ref, \"refs/\"))\n\t\t\t\tref += 5;\n\t\t\tif (starts_with(ref, \"notes/\"))\n\t\t\t\tref += 6;\n\t\t\tstrbuf_addf(sb, \"\\nNotes (%s):\\n\", ref);\n\t\t}\n\t}\n\n\tfor (msg_p = msg; msg_p < msg + msglen; msg_p += linelen + 1) {\n\t\tlinelen = strchrnul(msg_p, '\\n') - msg_p;\n\n\t\tif (!raw)\n\t\t\tstrbuf_addstr(sb, \"    \");\n\t\tstrbuf_add(sb, msg_p, linelen);\n\t\tstrbuf_addch(sb, '\\n');\n\t}\n\n\tfree(msg);\n}\n\nvoid format_display_notes(const struct object_id *object_oid,\n\t\t\t  struct strbuf *sb, const char *output_encoding, int raw)\n{\n\tint i;\n\tassert(display_notes_trees);\n\tfor (i = 0; display_notes_trees[i]; i++)\n\t\tformat_note(display_notes_trees[i], object_oid, sb,\n\t\t\t    output_encoding, raw);\n}\n\nint copy_note(struct notes_tree *t,\n\t      const struct object_id *from_obj, const struct object_id *to_obj,\n\t      int force, combine_notes_fn combine_notes)\n{\n\tconst struct object_id *note = get_note(t, from_obj);\n\tconst struct object_id *existing_note = get_note(t, to_obj);\n\n\tif (!force && existing_note)\n\t\treturn 1;\n\n\tif (note)\n\t\treturn add_note(t, to_obj, note, combine_notes);\n\telse if (existing_note)\n\t\treturn add_note(t, to_obj, &null_oid, combine_notes);\n\n\treturn 0;\n}\n\nvoid expand_notes_ref(struct strbuf *sb)\n{\n\tif (starts_with(sb->buf, \"refs/notes/\"))\n\t\treturn; /* we're happy */\n\telse if (starts_with(sb->buf, \"notes/\"))\n\t\tstrbuf_insert(sb, 0, \"refs/\", 5);\n\telse\n\t\tstrbuf_insert(sb, 0, \"refs/notes/\", 11);\n}\n\nvoid expand_loose_notes_ref(struct strbuf *sb)\n{\n\tstruct object_id object;\n\n\tif (get_oid(sb->buf, &object)) {\n\t\t/* fallback to expand_notes_ref */\n\t\texpand_notes_ref(sb);\n\t}\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "009fa8ae3a29b7e9eda17fc39934be33d296840a",
  "sha1_ok": true,
  "size": 37321
}
