{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJkaWZmLmgiCgpzdGF0aWMgaW50IGNhY2hlZF9vbmx5ID0gMDsKc3RhdGljIGludCBtYXRjaF9ub25leGlzdGluZyA9IDA7CnN0YXRpYyBzdHJ1Y3QgZGlmZl9vcHRpb25zIGRpZmZfb3B0aW9uczsKCi8qIEEgZmlsZSBlbnRyeSB3ZW50IGF3YXkgb3IgYXBwZWFyZWQgKi8Kc3RhdGljIHZvaWQgc2hvd19maWxlKGNvbnN0IGNoYXIgKnByZWZpeCwKCQkgICAgICBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCSAgICAgIHVuc2lnbmVkIGNoYXIgKnNoYTEsIHVuc2lnbmVkIGludCBtb2RlKQp7CglkaWZmX2FkZHJlbW92ZSgmZGlmZl9vcHRpb25zLCBwcmVmaXhbMF0sIG50b2hsKG1vZGUpLAoJCSAgICAgICBzaGExLCBjZS0+bmFtZSwgTlVMTCk7Cn0KCnN0YXRpYyBpbnQgZ2V0X3N0YXRfZGF0YShzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQkgdW5zaWduZWQgY2hhciAqKiBzaGExcCwgdW5zaWduZWQgaW50ICptb2RlcCkKewoJdW5zaWduZWQgY2hhciAqc2hhMSA9IGNlLT5zaGExOwoJdW5zaWduZWQgaW50IG1vZGUgPSBjZS0+Y2VfbW9kZTsKCglpZiAoIWNhY2hlZF9vbmx5KSB7CgkJc3RhdGljIHVuc2lnbmVkIGNoYXIgbm9fc2hhMVsyMF07CgkJaW50IGNoYW5nZWQ7CgkJc3RydWN0IHN0YXQgc3Q7CgkJaWYgKGxzdGF0KGNlLT5uYW1lLCAmc3QpIDwgMCkgewoJCQlpZiAoZXJybm8gPT0gRU5PRU5UICYmIG1hdGNoX25vbmV4aXN0aW5nKSB7CgkJCQkqc2hhMXAgPSBzaGExOwoJCQkJKm1vZGVwID0gbW9kZTsKCQkJCXJldHVybiAwOwoJCQl9CgkJCXJldHVybiAtMTsKCQl9CgkJY2hhbmdlZCA9IGNlX21hdGNoX3N0YXQoY2UsICZzdCk7CgkJaWYgKGNoYW5nZWQpIHsKCQkJbW9kZSA9IGNyZWF0ZV9jZV9tb2RlKHN0LnN0X21vZGUpOwoJCQlpZiAoIXRydXN0X2V4ZWN1dGFibGVfYml0ICYmCgkJCSAgICBTX0lTUkVHKG1vZGUpICYmIFNfSVNSRUcoY2UtPmNlX21vZGUpICYmCgkJCSAgICAoKG1vZGUgXiBjZS0+Y2VfbW9kZSkgPT0gMDExMSkpCgkJCQltb2RlID0gY2UtPmNlX21vZGU7CgkJCXNoYTEgPSBub19zaGExOwoJCX0KCX0KCgkqc2hhMXAgPSBzaGExOwoJKm1vZGVwID0gbW9kZTsKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBzaG93X25ld19maWxlKHN0cnVjdCBjYWNoZV9lbnRyeSAqbmV3KQp7Cgl1bnNpZ25lZCBjaGFyICpzaGExOwoJdW5zaWduZWQgaW50IG1vZGU7CgoJLyogTmV3IGZpbGUgaW4gdGhlIGluZGV4OiBpdCBtaWdodCBhY3R1YWxseSBiZSBkaWZmZXJlbnQgaW4KCSAqIHRoZSB3b3JraW5nIGNvcHkuCgkgKi8KCWlmIChnZXRfc3RhdF9kYXRhKG5ldywgJnNoYTEsICZtb2RlKSA8IDApCgkJcmV0dXJuOwoKCXNob3dfZmlsZSgiKyIsIG5ldywgc2hhMSwgbW9kZSk7Cn0KCnN0YXRpYyBpbnQgc2hvd19tb2RpZmllZChzdHJ1Y3QgY2FjaGVfZW50cnkgKm9sZCwKCQkJIHN0cnVjdCBjYWNoZV9lbnRyeSAqbmV3LAoJCQkgaW50IHJlcG9ydF9taXNzaW5nKQp7Cgl1bnNpZ25lZCBpbnQgbW9kZSwgb2xkbW9kZTsKCXVuc2lnbmVkIGNoYXIgKnNoYTE7CgoJaWYgKGdldF9zdGF0X2RhdGEobmV3LCAmc2hhMSwgJm1vZGUpIDwgMCkgewoJCWlmIChyZXBvcnRfbWlzc2luZykKCQkJc2hvd19maWxlKCItIiwgb2xkLCBvbGQtPnNoYTEsIG9sZC0+Y2VfbW9kZSk7CgkJcmV0dXJuIC0xOwoJfQoKCW9sZG1vZGUgPSBvbGQtPmNlX21vZGU7CglpZiAobW9kZSA9PSBvbGRtb2RlICYmICFtZW1jbXAoc2hhMSwgb2xkLT5zaGExLCAyMCkgJiYKCSAgICAhZGlmZl9vcHRpb25zLmZpbmRfY29waWVzX2hhcmRlcikKCQlyZXR1cm4gMDsKCgltb2RlID0gbnRvaGwobW9kZSk7CglvbGRtb2RlID0gbnRvaGwob2xkbW9kZSk7CgoJZGlmZl9jaGFuZ2UoJmRpZmZfb3B0aW9ucywgb2xkbW9kZSwgbW9kZSwKCQkgICAgb2xkLT5zaGExLCBzaGExLCBvbGQtPm5hbWUsIE5VTEwpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZGlmZl9jYWNoZShzdHJ1Y3QgY2FjaGVfZW50cnkgKiphYywgaW50IGVudHJpZXMsIGNvbnN0IGNoYXIgKipwYXRoc3BlYykKewoJd2hpbGUgKGVudHJpZXMpIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gKmFjOwoJCWludCBzYW1lID0gKGVudHJpZXMgPiAxKSAmJiBjZV9zYW1lX25hbWUoY2UsIGFjWzFdKTsKCgkJaWYgKCFjZV9wYXRoX21hdGNoKGNlLCBwYXRoc3BlYykpCgkJCWdvdG8gc2tpcF9lbnRyeTsKCgkJc3dpdGNoIChjZV9zdGFnZShjZSkpIHsKCQljYXNlIDA6CgkJCS8qIE5vIHN0YWdlIDEgZW50cnk/IFRoYXQgbWVhbnMgaXQncyBhIG5ldyBmaWxlICovCgkJCWlmICghc2FtZSkgewoJCQkJc2hvd19uZXdfZmlsZShjZSk7CgkJCQlicmVhazsKCQkJfQoJCQkvKiBTaG93IGRpZmZlcmVuY2UgYmV0d2VlbiBvbGQgYW5kIG5ldyAqLwoJCQlzaG93X21vZGlmaWVkKGFjWzFdLCBjZSwgMSk7CgkJCWJyZWFrOwoJCWNhc2UgMToKCQkJLyogTm8gc3RhZ2UgMyAobWVyZ2UpIGVudHJ5PyBUaGF0IG1lYW5zIGl0J3MgYmVlbiBkZWxldGVkICovCgkJCWlmICghc2FtZSkgewoJCQkJc2hvd19maWxlKCItIiwgY2UsIGNlLT5zaGExLCBjZS0+Y2VfbW9kZSk7CgkJCQlicmVhazsKCQkJfQoJCQkvKiBXZSBjb21lIGhlcmUgd2l0aCBjZSBwb2ludGluZyBhdCBzdGFnZSAxCgkJCSAqIChvcmlnaW5hbCB0cmVlKSBhbmQgYWNbMV0gcG9pbnRpbmcgYXQgc3RhZ2UKCQkJICogMyAodW5tZXJnZWQpLiAgc2hvdy1tb2RpZmllZCB3aXRoCgkJCSAqIHJlcG9ydC1taXNpbmcgc2V0IHRvIGZhbHNlIGRvZXMgbm90IHNheSB0aGUKCQkJICogZmlsZSBpcyBkZWxldGVkIGJ1dCByZXBvcnRzIHRydWUgaWYgd29yawoJCQkgKiB0cmVlIGRvZXMgbm90IGhhdmUgaXQsIGluIHdoaWNoIGNhc2Ugd2UKCQkJICogZmFsbCB0aHJvdWdoIHRvIHJlcG9ydCB0aGUgdW5tZXJnZWQgc3RhdGUuCgkJCSAqIE90aGVyd2lzZSwgd2Ugc2hvdyB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbgoJCQkgKiB0aGUgb3JpZ2luYWwgdHJlZSBhbmQgdGhlIHdvcmsgdHJlZS4KCQkJICovCgkJCWlmICghY2FjaGVkX29ubHkgJiYgIXNob3dfbW9kaWZpZWQoY2UsIGFjWzFdLCAwKSkKCQkJCWJyZWFrOwoJCQkvKiBmYWxsdGhydSAqLwoJCWNhc2UgMzoKCQkJZGlmZl91bm1lcmdlKCZkaWZmX29wdGlvbnMsIGNlLT5uYW1lKTsKCQkJYnJlYWs7CgoJCWRlZmF1bHQ6CgkJCWRpZSgiaW1wb3NzaWJsZSBjYWNoZSBlbnRyeSBzdGFnZSIpOwoJCX0KCnNraXBfZW50cnk6CgkJLyoKCQkgKiBJZ25vcmUgYWxsIHRoZSBkaWZmZXJlbnQgc3RhZ2VzIGZvciB0aGlzIGZpbGUsCgkJICogd2UndmUgaGFuZGxlZCB0aGUgcmVsZXZhbnQgY2FzZXMgbm93LgoJCSAqLwoJCWRvIHsKCQkJYWMrKzsKCQkJZW50cmllcy0tOwoJCX0gd2hpbGUgKGVudHJpZXMgJiYgY2Vfc2FtZV9uYW1lKGNlLCBhY1swXSkpOwoJfQoJcmV0dXJuIDA7Cn0KCi8qCiAqIFRoaXMgdHVybnMgYWxsIG1lcmdlIGVudHJpZXMgaW50byAic3RhZ2UgMyIuIFRoYXQgZ3VhcmFudGVlcyB0aGF0CiAqIHdoZW4gd2UgcmVhZCBpbiB0aGUgbmV3IHRyZWUgKGludG8gInN0YWdlIDEiKSwgd2Ugd29uJ3QgbG9zZSBzaWdodAogKiBvZiB0aGUgZmFjdCB0aGF0IHdlIGhhZCB1bm1lcmdlZCBlbnRyaWVzLgogKi8Kc3RhdGljIHZvaWQgbWFya19tZXJnZV9lbnRyaWVzKHZvaWQpCnsKCWludCBpOwoJZm9yIChpID0gMDsgaSA8IGFjdGl2ZV9ucjsgaSsrKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGFjdGl2ZV9jYWNoZVtpXTsKCQlpZiAoIWNlX3N0YWdlKGNlKSkKCQkJY29udGludWU7CgkJY2UtPmNlX2ZsYWdzIHw9IGh0b25zKENFX1NUQUdFTUFTSyk7Cgl9Cn0KCnN0YXRpYyBjb25zdCBjaGFyIGRpZmZfY2FjaGVfdXNhZ2VbXSA9CiJnaXQtZGlmZi1pbmRleCBbLW1dIFstLWNhY2hlZF0gIgoiWzxjb21tb24gZGlmZiBvcHRpb25zPl0gPHRyZWUtaXNoPiBbPHBhdGg+Li4uXSIKQ09NTU9OX0RJRkZfT1BUSU9OU19IRUxQOwoKaW50IG1haW4oaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2KQp7Cgljb25zdCBjaGFyICp0cmVlX25hbWUgPSBOVUxMOwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCWNvbnN0IGNoYXIgKnByZWZpeCA9IHNldHVwX2dpdF9kaXJlY3RvcnkoKTsKCWNvbnN0IGNoYXIgKipwYXRoc3BlYyA9IE5VTEw7Cgl2b2lkICp0cmVlOwoJdW5zaWduZWQgbG9uZyBzaXplOwoJaW50IHJldDsKCWludCBhbGxvd19vcHRpb25zID0gMTsKCWludCBpOwoKCWdpdF9jb25maWcoZ2l0X2RpZmZfY29uZmlnKTsKCWRpZmZfc2V0dXAoJmRpZmZfb3B0aW9ucyk7Cglmb3IgKGkgPSAxOyBpIDwgYXJnYzsgaSsrKSB7CgkJY29uc3QgY2hhciAqYXJnID0gYXJndltpXTsKCQlpbnQgZGlmZl9vcHRfY250OwoKCQlpZiAoIWFsbG93X29wdGlvbnMgfHwgKmFyZyAhPSAnLScpIHsKCQkJaWYgKHRyZWVfbmFtZSkKCQkJCWJyZWFrOwoJCQl0cmVlX25hbWUgPSBhcmc7CgkJCWNvbnRpbnVlOwoJCX0KCQkJCgkJaWYgKCFzdHJjbXAoYXJnLCAiLS0iKSkgewoJCQlhbGxvd19vcHRpb25zID0gMDsKCQkJY29udGludWU7CgkJfQoJCWlmICghc3RyY21wKGFyZywgIi1yIikpIHsKCQkJLyogV2UgYWNjZXB0IHRoZSAtciBmbGFnIGp1c3QgdG8gbG9vayBsaWtlIGdpdC1kaWZmLXRyZWUgKi8KCQkJY29udGludWU7CgkJfQoJCWRpZmZfb3B0X2NudCA9IGRpZmZfb3B0X3BhcnNlKCZkaWZmX29wdGlvbnMsIGFyZ3YgKyBpLAoJCQkJCSAgICAgIGFyZ2MgLSBpKTsKCQlpZiAoZGlmZl9vcHRfY250IDwgMCkKCQkJdXNhZ2UoZGlmZl9jYWNoZV91c2FnZSk7CgkJZWxzZSBpZiAoZGlmZl9vcHRfY250KSB7CgkJCWkgKz0gZGlmZl9vcHRfY250IC0gMTsKCQkJY29udGludWU7CgkJfQoKCQlpZiAoIXN0cmNtcChhcmcsICItbSIpKSB7CgkJCW1hdGNoX25vbmV4aXN0aW5nID0gMTsKCQkJY29udGludWU7CgkJfQoJCWlmICghc3RyY21wKGFyZywgIi0tY2FjaGVkIikpIHsKCQkJY2FjaGVkX29ubHkgPSAxOwoJCQljb250aW51ZTsKCQl9CgkJdXNhZ2UoZGlmZl9jYWNoZV91c2FnZSk7Cgl9CgoJcGF0aHNwZWMgPSBnZXRfcGF0aHNwZWMocHJlZml4LCBhcmd2ICsgaSk7CgoJaWYgKGRpZmZfc2V0dXBfZG9uZSgmZGlmZl9vcHRpb25zKSA8IDApCgkJdXNhZ2UoZGlmZl9jYWNoZV91c2FnZSk7CgoJaWYgKCF0cmVlX25hbWUgfHwgZ2V0X3NoYTEodHJlZV9uYW1lLCBzaGExKSkKCQl1c2FnZShkaWZmX2NhY2hlX3VzYWdlKTsKCglyZWFkX2NhY2hlKCk7CgoJbWFya19tZXJnZV9lbnRyaWVzKCk7CgoJdHJlZSA9IHJlYWRfb2JqZWN0X3dpdGhfcmVmZXJlbmNlKHNoYTEsICJ0cmVlIiwgJnNpemUsIE5VTEwpOwoJaWYgKCF0cmVlKQoJCWRpZSgiYmFkIHRyZWUgb2JqZWN0ICVzIiwgdHJlZV9uYW1lKTsKCWlmIChyZWFkX3RyZWUodHJlZSwgc2l6ZSwgMSwgcGF0aHNwZWMpKQoJCWRpZSgidW5hYmxlIHRvIHJlYWQgdHJlZSBvYmplY3QgJXMiLCB0cmVlX25hbWUpOwoKCXJldCA9IGRpZmZfY2FjaGUoYWN0aXZlX2NhY2hlLCBhY3RpdmVfbnIsIHBhdGhzcGVjKTsKCglkaWZmY29yZV9zdGQoJmRpZmZfb3B0aW9ucyk7CglkaWZmX2ZsdXNoKCZkaWZmX29wdGlvbnMpOwoJcmV0dXJuIHJldDsKfQo=",
    "text": "#include \"cache.h\"\n#include \"diff.h\"\n\nstatic int cached_only = 0;\nstatic int match_nonexisting = 0;\nstatic struct diff_options diff_options;\n\n/* A file entry went away or appeared */\nstatic void show_file(const char *prefix,\n\t\t      struct cache_entry *ce,\n\t\t      unsigned char *sha1, unsigned int mode)\n{\n\tdiff_addremove(&diff_options, prefix[0], ntohl(mode),\n\t\t       sha1, ce->name, NULL);\n}\n\nstatic int get_stat_data(struct cache_entry *ce,\n\t\t\t unsigned char ** sha1p, unsigned int *modep)\n{\n\tunsigned char *sha1 = ce->sha1;\n\tunsigned int mode = ce->ce_mode;\n\n\tif (!cached_only) {\n\t\tstatic unsigned char no_sha1[20];\n\t\tint changed;\n\t\tstruct stat st;\n\t\tif (lstat(ce->name, &st) < 0) {\n\t\t\tif (errno == ENOENT && match_nonexisting) {\n\t\t\t\t*sha1p = sha1;\n\t\t\t\t*modep = mode;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tchanged = ce_match_stat(ce, &st);\n\t\tif (changed) {\n\t\t\tmode = create_ce_mode(st.st_mode);\n\t\t\tif (!trust_executable_bit &&\n\t\t\t    S_ISREG(mode) && S_ISREG(ce->ce_mode) &&\n\t\t\t    ((mode ^ ce->ce_mode) == 0111))\n\t\t\t\tmode = ce->ce_mode;\n\t\t\tsha1 = no_sha1;\n\t\t}\n\t}\n\n\t*sha1p = sha1;\n\t*modep = mode;\n\treturn 0;\n}\n\nstatic void show_new_file(struct cache_entry *new)\n{\n\tunsigned char *sha1;\n\tunsigned int mode;\n\n\t/* New file in the index: it might actually be different in\n\t * the working copy.\n\t */\n\tif (get_stat_data(new, &sha1, &mode) < 0)\n\t\treturn;\n\n\tshow_file(\"+\", new, sha1, mode);\n}\n\nstatic int show_modified(struct cache_entry *old,\n\t\t\t struct cache_entry *new,\n\t\t\t int report_missing)\n{\n\tunsigned int mode, oldmode;\n\tunsigned char *sha1;\n\n\tif (get_stat_data(new, &sha1, &mode) < 0) {\n\t\tif (report_missing)\n\t\t\tshow_file(\"-\", old, old->sha1, old->ce_mode);\n\t\treturn -1;\n\t}\n\n\toldmode = old->ce_mode;\n\tif (mode == oldmode && !memcmp(sha1, old->sha1, 20) &&\n\t    !diff_options.find_copies_harder)\n\t\treturn 0;\n\n\tmode = ntohl(mode);\n\toldmode = ntohl(oldmode);\n\n\tdiff_change(&diff_options, oldmode, mode,\n\t\t    old->sha1, sha1, old->name, NULL);\n\treturn 0;\n}\n\nstatic int diff_cache(struct cache_entry **ac, int entries, const char **pathspec)\n{\n\twhile (entries) {\n\t\tstruct cache_entry *ce = *ac;\n\t\tint same = (entries > 1) && ce_same_name(ce, ac[1]);\n\n\t\tif (!ce_path_match(ce, pathspec))\n\t\t\tgoto skip_entry;\n\n\t\tswitch (ce_stage(ce)) {\n\t\tcase 0:\n\t\t\t/* No stage 1 entry? That means it's a new file */\n\t\t\tif (!same) {\n\t\t\t\tshow_new_file(ce);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Show difference between old and new */\n\t\t\tshow_modified(ac[1], ce, 1);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* No stage 3 (merge) entry? That means it's been deleted */\n\t\t\tif (!same) {\n\t\t\t\tshow_file(\"-\", ce, ce->sha1, ce->ce_mode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* We come here with ce pointing at stage 1\n\t\t\t * (original tree) and ac[1] pointing at stage\n\t\t\t * 3 (unmerged).  show-modified with\n\t\t\t * report-mising set to false does not say the\n\t\t\t * file is deleted but reports true if work\n\t\t\t * tree does not have it, in which case we\n\t\t\t * fall through to report the unmerged state.\n\t\t\t * Otherwise, we show the differences between\n\t\t\t * the original tree and the work tree.\n\t\t\t */\n\t\t\tif (!cached_only && !show_modified(ce, ac[1], 0))\n\t\t\t\tbreak;\n\t\t\t/* fallthru */\n\t\tcase 3:\n\t\t\tdiff_unmerge(&diff_options, ce->name);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdie(\"impossible cache entry stage\");\n\t\t}\n\nskip_entry:\n\t\t/*\n\t\t * Ignore all the different stages for this file,\n\t\t * we've handled the relevant cases now.\n\t\t */\n\t\tdo {\n\t\t\tac++;\n\t\t\tentries--;\n\t\t} while (entries && ce_same_name(ce, ac[0]));\n\t}\n\treturn 0;\n}\n\n/*\n * This turns all merge entries into \"stage 3\". That guarantees that\n * when we read in the new tree (into \"stage 1\"), we won't lose sight\n * of the fact that we had unmerged entries.\n */\nstatic void mark_merge_entries(void)\n{\n\tint i;\n\tfor (i = 0; i < active_nr; i++) {\n\t\tstruct cache_entry *ce = active_cache[i];\n\t\tif (!ce_stage(ce))\n\t\t\tcontinue;\n\t\tce->ce_flags |= htons(CE_STAGEMASK);\n\t}\n}\n\nstatic const char diff_cache_usage[] =\n\"git-diff-index [-m] [--cached] \"\n\"[<common diff options>] <tree-ish> [<path>...]\"\nCOMMON_DIFF_OPTIONS_HELP;\n\nint main(int argc, const char **argv)\n{\n\tconst char *tree_name = NULL;\n\tunsigned char sha1[20];\n\tconst char *prefix = setup_git_directory();\n\tconst char **pathspec = NULL;\n\tvoid *tree;\n\tunsigned long size;\n\tint ret;\n\tint allow_options = 1;\n\tint i;\n\n\tgit_config(git_diff_config);\n\tdiff_setup(&diff_options);\n\tfor (i = 1; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\t\tint diff_opt_cnt;\n\n\t\tif (!allow_options || *arg != '-') {\n\t\t\tif (tree_name)\n\t\t\t\tbreak;\n\t\t\ttree_name = arg;\n\t\t\tcontinue;\n\t\t}\n\t\t\t\n\t\tif (!strcmp(arg, \"--\")) {\n\t\t\tallow_options = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"-r\")) {\n\t\t\t/* We accept the -r flag just to look like git-diff-tree */\n\t\t\tcontinue;\n\t\t}\n\t\tdiff_opt_cnt = diff_opt_parse(&diff_options, argv + i,\n\t\t\t\t\t      argc - i);\n\t\tif (diff_opt_cnt < 0)\n\t\t\tusage(diff_cache_usage);\n\t\telse if (diff_opt_cnt) {\n\t\t\ti += diff_opt_cnt - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(arg, \"-m\")) {\n\t\t\tmatch_nonexisting = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--cached\")) {\n\t\t\tcached_only = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tusage(diff_cache_usage);\n\t}\n\n\tpathspec = get_pathspec(prefix, argv + i);\n\n\tif (diff_setup_done(&diff_options) < 0)\n\t\tusage(diff_cache_usage);\n\n\tif (!tree_name || get_sha1(tree_name, sha1))\n\t\tusage(diff_cache_usage);\n\n\tread_cache();\n\n\tmark_merge_entries();\n\n\ttree = read_object_with_reference(sha1, \"tree\", &size, NULL);\n\tif (!tree)\n\t\tdie(\"bad tree object %s\", tree_name);\n\tif (read_tree(tree, size, 1, pathspec))\n\t\tdie(\"unable to read tree object %s\", tree_name);\n\n\tret = diff_cache(active_cache, active_nr, pathspec);\n\n\tdiffcore_std(&diff_options);\n\tdiff_flush(&diff_options);\n\treturn ret;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0054883a5e18aaacc682bb8369c6f0376cf75306",
  "sha1_ok": true,
  "size": 5594
}
