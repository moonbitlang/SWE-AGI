{
  "content": {
    "base64": "IyEvdXNyL2Jpbi9wZXJsIC13CiMKIyBDb3B5cmlnaHQgMjAwMiwyMDA1IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ0Brcm9haC5jb20+CiMgQ29weXJpZ2h0IDIwMDUgUnlhbiBBbmRlcnNvbiA8cnlhbkBtaWNob25saW5lLmNvbT4KIwojIEdQTCB2MiAoU2VlIENPUFlJTkcpCiMKIyBQb3J0ZWQgdG8gc3VwcG9ydCBnaXQgIm1ib3giIGZvcm1hdCBmaWxlcyBieSBSeWFuIEFuZGVyc29uIDxyeWFuQG1pY2hvbmxpbmUuY29tPgojCiMgU2VuZHMgYSBjb2xsZWN0aW9uIG9mIGVtYWlscyB0byB0aGUgZ2l2ZW4gZW1haWwgYWRkcmVzc2VzLCBkaXN0dXJiaW5nbHkgZmFzdC4KIwojIFN1cHBvcnRzIHR3byBmb3JtYXRzOgojIDEuIG1ib3ggZm9ybWF0IGZpbGVzIChpZ25vcmluZyBtb3N0IGhlYWRlcnMgYW5kIE1JTUUgZm9ybWF0dGluZyAtIHRoaXMgaXMgZGVzaWduZWQgZm9yIHNlbmRpbmcgcGF0Y2hlcykKIyAyLiBUaGUgb3JpZ2luYWwgZm9ybWF0IHN1cHBvcnQgYnkgR3JlZydzIHNjcmlwdDoKIyAgICBmaXJzdCBsaW5lIG9mIHRoZSBtZXNzYWdlIGlzIHdobyB0byBDQywKIyAgICBhbmQgc2Vjb25kIGxpbmUgaXMgdGhlIHN1YmplY3Qgb2YgdGhlIG1lc3NhZ2UuCiMKCnVzZSBzdHJpY3Q7CnVzZSB3YXJuaW5nczsKdXNlIFRlcm06OlJlYWRMaW5lOwp1c2UgR2V0b3B0OjpMb25nOwp1c2UgRGF0YTo6RHVtcGVyOwp1c2UgVGVybTo6QU5TSUNvbG9yOwp1c2UgR2l0OwoKcGFja2FnZSBGYWtlVGVybTsKc3ViIG5ldyB7CglteSAoJGNsYXNzLCAkcmVhc29uKSA9IEBfOwoJcmV0dXJuIGJsZXNzIFwkcmVhc29uLCBzaGlmdDsKfQpzdWIgcmVhZGxpbmUgewoJbXkgJHNlbGYgPSBzaGlmdDsKCWRpZSAiQ2Fubm90IHVzZSByZWFkbGluZSBvbiBGYWtlVGVybTogJCRzZWxmIjsKfQpwYWNrYWdlIG1haW47CgoKc3ViIHVzYWdlIHsKCXByaW50IDw8RU9UOwpnaXQgc2VuZC1lbWFpbCBbb3B0aW9uc10gPGZpbGUgfCBkaXJlY3Rvcnk+Li4uCgogIENvbXBvc2luZzoKICAgIC0tZnJvbSAgICAgICAgICAgICAgICAgIDxzdHI+ICAqIEVtYWlsIEZyb206CiAgICAtLXRvICAgICAgICAgICAgICAgICAgICA8c3RyPiAgKiBFbWFpbCBUbzoKICAgIC0tY2MgICAgICAgICAgICAgICAgICAgIDxzdHI+ICAqIEVtYWlsIENjOgogICAgLS1iY2MgICAgICAgICAgICAgICAgICAgPHN0cj4gICogRW1haWwgQmNjOgogICAgLS1zdWJqZWN0ICAgICAgICAgICAgICAgPHN0cj4gICogRW1haWwgIlN1YmplY3Q6IgogICAgLS1pbi1yZXBseS10byAgICAgICAgICAgPHN0cj4gICogRW1haWwgIkluLVJlcGx5LVRvOiIKICAgIC0tY29tcG9zZSAgICAgICAgICAgICAgICAgICAgICAqIE9wZW4gYW4gZWRpdG9yIGZvciBpbnRyb2R1Y3Rpb24uCgogIFNlbmRpbmc6CiAgICAtLWVudmVsb3BlLXNlbmRlciAgICAgICA8c3RyPiAgKiBFbWFpbCBlbnZlbG9wZSBzZW5kZXIuCiAgICAtLXNtdHAtc2VydmVyICAgICAgIDxzdHI6aW50PiAgKiBPdXRnb2luZyBTTVRQIHNlcnZlciB0byB1c2UuIFRoZSBwb3J0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBvcHRpb25hbC4gRGVmYXVsdCAnbG9jYWxob3N0Jy4KICAgIC0tc210cC1zZXJ2ZXItcG9ydCAgICAgIDxpbnQ+ICAqIE91dGdvaW5nIFNNVFAgc2VydmVyIHBvcnQuCiAgICAtLXNtdHAtdXNlciAgICAgICAgICAgICA8c3RyPiAgKiBVc2VybmFtZSBmb3IgU01UUC1BVVRILgogICAgLS1zbXRwLXBhc3MgICAgICAgICAgICAgPHN0cj4gICogUGFzc3dvcmQgZm9yIFNNVFAtQVVUSDsgbm90IG5lY2Vzc2FyeS4KICAgIC0tc210cC1lbmNyeXB0aW9uICAgICAgIDxzdHI+ICAqIHRscyBvciBzc2w7IGFueXRoaW5nIGVsc2UgZGlzYWJsZXMuCiAgICAtLXNtdHAtc3NsICAgICAgICAgICAgICAgICAgICAgKiBEZXByZWNhdGVkLiBVc2UgJy0tc210cC1lbmNyeXB0aW9uIHNzbCcuCgogIEF1dG9tYXRpbmc6CiAgICAtLWlkZW50aXR5ICAgICAgICAgICAgICA8c3RyPiAgKiBVc2UgdGhlIHNlbmRlbWFpbC48aWQ+IG9wdGlvbnMuCiAgICAtLWNjLWNtZCAgICAgICAgICAgICAgICA8c3RyPiAgKiBFbWFpbCBDYzogdmlhIGA8c3RyPiBcJHBhdGNoX3BhdGhgCiAgICAtLXN1cHByZXNzLWNjICAgICAgICAgICA8c3RyPiAgKiBhdXRob3IsIHNlbGYsIHNvYiwgY2NjbWQsIGFsbC4KICAgIC0tW25vLV1zaWduZWQtb2ZmLWJ5LWNjICAgICAgICAqIFNlbmQgdG8gQ2M6IGFuZCBTaWduZWQtb2ZmLWJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzLiBEZWZhdWx0IG9uLgogICAgLS1bbm8tXXN1cHByZXNzLWZyb20gICAgICAgICAgICogU2VuZCB0byBzZWxmLiBEZWZhdWx0IG9mZi4KICAgIC0tW25vLV1jaGFpbi1yZXBseS10byAgICAgICAgICAqIENoYWluIEluLVJlcGx5LVRvOiBmaWVsZHMuIERlZmF1bHQgb24uCiAgICAtLVtuby1ddGhyZWFkICAgICAgICAgICAgICAgICAgKiBVc2UgSW4tUmVwbHktVG86IGZpZWxkLiBEZWZhdWx0IG9uLgoKICBBZG1pbmlzdGVyaW5nOgogICAgLS1xdWlldCAgICAgICAgICAgICAgICAgICAgICAgICogT3V0cHV0IG9uZSBsaW5lIG9mIGluZm8gcGVyIGVtYWlsLgogICAgLS1kcnktcnVuICAgICAgICAgICAgICAgICAgICAgICogRG9uJ3QgYWN0dWFsbHkgc2VuZCB0aGUgZW1haWxzLgogICAgLS1bbm8tXXZhbGlkYXRlICAgICAgICAgICAgICAgICogUGVyZm9ybSBwYXRjaCBzYW5pdHkgY2hlY2tzLiBEZWZhdWx0IG9uLgoKRU9UCglleGl0KDEpOwp9CgojIG1vc3QgbWFpbCBzZXJ2ZXJzIGdlbmVyYXRlIHRoZSBEYXRlOiBoZWFkZXIsIGJ1dCBub3QgYWxsLi4uCnN1YiBmb3JtYXRfMjgyMl90aW1lIHsKCW15ICgkdGltZSkgPSBAXzsKCW15IEBsb2NhbHRtID0gbG9jYWx0aW1lKCR0aW1lKTsKCW15IEBnbXR0bSA9IGdtdGltZSgkdGltZSk7CglteSAkbG9jYWxtaW4gPSAkbG9jYWx0bVsxXSArICRsb2NhbHRtWzJdICogNjA7CglteSAkZ210bWluID0gJGdtdHRtWzFdICsgJGdtdHRtWzJdICogNjA7CglpZiAoJGxvY2FsdG1bMF0gIT0gJGdtdHRtWzBdKSB7CgkJZGllICJsb2NhbCB6b25lIGRpZmZlcnMgZnJvbSBHTVQgYnkgYSBub24tbWludXRlIGludGVydmFsXG4iOwoJfQoJaWYgKCgoJGdtdHRtWzZdICsgMSkgJSA3KSA9PSAkbG9jYWx0bVs2XSkgewoJCSRsb2NhbG1pbiArPSAxNDQwOwoJfSBlbHNpZiAoKCgkZ210dG1bNl0gLSAxKSAlIDcpID09ICRsb2NhbHRtWzZdKSB7CgkJJGxvY2FsbWluIC09IDE0NDA7Cgl9IGVsc2lmICgkZ210dG1bNl0gIT0gJGxvY2FsdG1bNl0pIHsKCQlkaWUgImxvY2FsIHRpbWUgb2Zmc2V0IGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAyNCBob3Vyc1xuIjsKCX0KCW15ICRvZmZzZXQgPSAkbG9jYWxtaW4gLSAkZ210bWluOwoJbXkgJG9mZmhvdXIgPSAkb2Zmc2V0IC8gNjA7CglteSAkb2ZmbWluID0gYWJzKCRvZmZzZXQgJSA2MCk7CglpZiAoYWJzKCRvZmZob3VyKSA+PSAyNCkgewoJCWRpZSAoImxvY2FsIHRpbWUgb2Zmc2V0IGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAyNCBob3Vyc1xuIik7Cgl9CgoJcmV0dXJuIHNwcmludGYoIiVzLCAlMmQgJXMgJWQgJTAyZDolMDJkOiUwMmQgJXMlMDJkJTAyZCIsCgkJICAgICAgIHF3KFN1biBNb24gVHVlIFdlZCBUaHUgRnJpIFNhdClbJGxvY2FsdG1bNl1dLAoJCSAgICAgICAkbG9jYWx0bVszXSwKCQkgICAgICAgcXcoSmFuIEZlYiBNYXIgQXByIE1heSBKdW4KCQkJICBKdWwgQXVnIFNlcCBPY3QgTm92IERlYylbJGxvY2FsdG1bNF1dLAoJCSAgICAgICAkbG9jYWx0bVs1XSsxOTAwLAoJCSAgICAgICAkbG9jYWx0bVsyXSwKCQkgICAgICAgJGxvY2FsdG1bMV0sCgkJICAgICAgICRsb2NhbHRtWzBdLAoJCSAgICAgICAoJG9mZnNldCA+PSAwKSA/ICcrJyA6ICctJywKCQkgICAgICAgYWJzKCRvZmZob3VyKSwKCQkgICAgICAgJG9mZm1pbiwKCQkgICAgICAgKTsKfQoKbXkgJGhhdmVfZW1haWxfdmFsaWQgPSBldmFsIHsgcmVxdWlyZSBFbWFpbDo6VmFsaWQ7IDEgfTsKbXkgJHNtdHA7Cm15ICRhdXRoOwoKc3ViIHVuaXF1ZV9lbWFpbF9saXN0KEApOwpzdWIgY2xlYW51cF9jb21wb3NlX2ZpbGVzKCk7CgojIENvbnN0YW50cyAoZXNzZW50aWFsbHkpCm15ICRjb21wb3NlX2ZpbGVuYW1lID0gIi5tc2cuJCQiOwoKIyBWYXJpYWJsZXMgd2UgZmlsbCBpbiBhdXRvbWF0aWNhbGx5LCBvciB2aWEgcHJvbXB0aW5nOgpteSAoQHRvLEBjYyxAaW5pdGlhbF9jYyxAYmNjbGlzdCxAeGgsCgkkaW5pdGlhbF9yZXBseV90bywkaW5pdGlhbF9zdWJqZWN0LEBmaWxlcywkYXV0aG9yLCRzZW5kZXIsJHNtdHBfYXV0aHBhc3MsJGNvbXBvc2UsJHRpbWUpOwoKbXkgJGVudmVsb3BlX3NlbmRlcjsKCiMgRXhhbXBsZSByZXBseSB0bzoKIyRpbml0aWFsX3JlcGx5X3RvID0gJyc7ICM8MjAwNTAyMDMxNzMyMDguR0EyMzk2NEBmb29iYXIuY29tPic7CgpteSAkcmVwbyA9IGV2YWwgeyBHaXQtPnJlcG9zaXRvcnkoKSB9OwpteSBAcmVwbyA9ICRyZXBvID8gKCRyZXBvKSA6ICgpOwpteSAkdGVybSA9IGV2YWwgewoJJEVOVnsiR0lUX1NFTkRfRU1BSUxfTk9UVFkifQoJCT8gbmV3IFRlcm06OlJlYWRMaW5lICdnaXQtc2VuZC1lbWFpbCcsIFwqU1RESU4sIFwqU1RET1VUCgkJOiBuZXcgVGVybTo6UmVhZExpbmUgJ2dpdC1zZW5kLWVtYWlsJzsKfTsKaWYgKCRAKSB7CgkkdGVybSA9IG5ldyBGYWtlVGVybSAiJEA6IGdvaW5nIG5vbi1pbnRlcmFjdGl2ZSI7Cn0KCiMgQmVoYXZpb3IgbW9kaWZpY2F0aW9uIHZhcmlhYmxlcwpteSAoJHF1aWV0LCAkZHJ5X3J1bikgPSAoMCwgMCk7CgojIFZhcmlhYmxlcyB3aXRoIGNvcnJlc3BvbmRpbmcgY29uZmlnIHNldHRpbmdzCm15ICgkdGhyZWFkLCAkY2hhaW5fcmVwbHlfdG8sICRzdXBwcmVzc19mcm9tLCAkc2lnbmVkX29mZl9ieV9jYywgJGNjX2NtZCk7Cm15ICgkc210cF9zZXJ2ZXIsICRzbXRwX3NlcnZlcl9wb3J0LCAkc210cF9hdXRodXNlciwgJHNtdHBfZW5jcnlwdGlvbik7Cm15ICgkaWRlbnRpdHksICRhbGlhc2ZpbGV0eXBlLCBAYWxpYXNfZmlsZXMsIEBzbXRwX2hvc3RfcGFydHMpOwpteSAoJHZhbGlkYXRlKTsKbXkgKEBzdXBwcmVzc19jYyk7CgpteSAlY29uZmlnX2Jvb2xfc2V0dGluZ3MgPSAoCiAgICAidGhyZWFkIiA9PiBbXCR0aHJlYWQsIDFdLAogICAgImNoYWlucmVwbHl0byIgPT4gW1wkY2hhaW5fcmVwbHlfdG8sIDFdLAogICAgInN1cHByZXNzZnJvbSIgPT4gW1wkc3VwcHJlc3NfZnJvbSwgdW5kZWZdLAogICAgInNpZ25lZG9mZmJ5Y2MiID0+IFtcJHNpZ25lZF9vZmZfYnlfY2MsIHVuZGVmXSwKICAgICJzaWduZWRvZmZjYyIgPT4gW1wkc2lnbmVkX29mZl9ieV9jYywgdW5kZWZdLCAgICAgICMgRGVwcmVjYXRlZAogICAgInZhbGlkYXRlIiA9PiBbXCR2YWxpZGF0ZSwgMV0sCik7CgpteSAlY29uZmlnX3NldHRpbmdzID0gKAogICAgInNtdHBzZXJ2ZXIiID0+IFwkc210cF9zZXJ2ZXIsCiAgICAic210cHNlcnZlcnBvcnQiID0+IFwkc210cF9zZXJ2ZXJfcG9ydCwKICAgICJzbXRwdXNlciIgPT4gXCRzbXRwX2F1dGh1c2VyLAogICAgInNtdHBwYXNzIiA9PiBcJHNtdHBfYXV0aHBhc3MsCiAgICAidG8iID0+IFxAdG8sCiAgICAiY2MiID0+IFxAaW5pdGlhbF9jYywKICAgICJjY2NtZCIgPT4gXCRjY19jbWQsCiAgICAiYWxpYXNmaWxldHlwZSIgPT4gXCRhbGlhc2ZpbGV0eXBlLAogICAgImJjYyIgPT4gXEBiY2NsaXN0LAogICAgImFsaWFzZXNmaWxlIiA9PiBcQGFsaWFzX2ZpbGVzLAogICAgInN1cHByZXNzY2MiID0+IFxAc3VwcHJlc3NfY2MsCiAgICAiZW52ZWxvcGVzZW5kZXIiID0+IFwkZW52ZWxvcGVfc2VuZGVyLAopOwoKIyBIYW5kbGUgVW5jb3V0aCBUZXJtaW5hdGlvbgpzdWIgc2lnbmFsX2hhbmRsZXIgewoKCSMgTWFrZSB0ZXh0IG5vcm1hbAoJcHJpbnQgY29sb3IoInJlc2V0IiksICJcbiI7CgoJIyBTTVRQIHBhc3N3b3JkIG1hc2tlZAoJc3lzdGVtICJzdHR5IGVjaG8iOwoKCSMgdG1wIGZpbGVzIGZyb20gLS1jb21wb3NlCglpZiAoLWUgJGNvbXBvc2VfZmlsZW5hbWUpIHsKCQlwcmludCAiJyRjb21wb3NlX2ZpbGVuYW1lJyBjb250YWlucyBhbiBpbnRlcm1lZGlhdGUgdmVyc2lvbiBvZiB0aGUgZW1haWwgeW91IHdlcmUgY29tcG9zaW5nLlxuIjsKCX0KCWlmICgtZSAoJGNvbXBvc2VfZmlsZW5hbWUgLiAiLmZpbmFsIikpIHsKCQlwcmludCAiJyRjb21wb3NlX2ZpbGVuYW1lLmZpbmFsJyBjb250YWlucyB0aGUgY29tcG9zZWQgZW1haWwuXG4iCgl9CgoJZXhpdDsKfTsKCiRTSUd7VEVSTX0gPSBcJnNpZ25hbF9oYW5kbGVyOwokU0lHe0lOVH0gID0gXCZzaWduYWxfaGFuZGxlcjsKCiMgQmVnaW4gYnkgYWNjdW11bGF0aW5nIGFsbCB0aGUgdmFyaWFibGVzIChkZWZpbmVkIGFib3ZlKSwgdGhhdCB3ZSB3aWxsIGVuZCB1cAojIG5lZWRpbmcsIGZpcnN0LCBmcm9tIHRoZSBjb21tYW5kIGxpbmU6CgpteSAkcmMgPSBHZXRPcHRpb25zKCJzZW5kZXJ8ZnJvbT1zIiA9PiBcJHNlbmRlciwKICAgICAgICAgICAgICAgICAgICAiaW4tcmVwbHktdG89cyIgPT4gXCRpbml0aWFsX3JlcGx5X3RvLAoJCSAgICAic3ViamVjdD1zIiA9PiBcJGluaXRpYWxfc3ViamVjdCwKCQkgICAgInRvPXMiID0+IFxAdG8sCgkJICAgICJjYz1zIiA9PiBcQGluaXRpYWxfY2MsCgkJICAgICJiY2M9cyIgPT4gXEBiY2NsaXN0LAoJCSAgICAiY2hhaW4tcmVwbHktdG8hIiA9PiBcJGNoYWluX3JlcGx5X3RvLAoJCSAgICAic210cC1zZXJ2ZXI9cyIgPT4gXCRzbXRwX3NlcnZlciwKCQkgICAgInNtdHAtc2VydmVyLXBvcnQ9cyIgPT4gXCRzbXRwX3NlcnZlcl9wb3J0LAoJCSAgICAic210cC11c2VyPXMiID0+IFwkc210cF9hdXRodXNlciwKCQkgICAgInNtdHAtcGFzczpzIiA9PiBcJHNtdHBfYXV0aHBhc3MsCgkJICAgICJzbXRwLXNzbCIgPT4gc3ViIHsgJHNtdHBfZW5jcnlwdGlvbiA9ICdzc2wnIH0sCgkJICAgICJzbXRwLWVuY3J5cHRpb249cyIgPT4gXCRzbXRwX2VuY3J5cHRpb24sCgkJICAgICJpZGVudGl0eT1zIiA9PiBcJGlkZW50aXR5LAoJCSAgICAiY29tcG9zZSIgPT4gXCRjb21wb3NlLAoJCSAgICAicXVpZXQiID0+IFwkcXVpZXQsCgkJICAgICJjYy1jbWQ9cyIgPT4gXCRjY19jbWQsCgkJICAgICJzdXBwcmVzcy1mcm9tISIgPT4gXCRzdXBwcmVzc19mcm9tLAoJCSAgICAic3VwcHJlc3MtY2M9cyIgPT4gXEBzdXBwcmVzc19jYywKCQkgICAgInNpZ25lZC1vZmYtY2N8c2lnbmVkLW9mZi1ieS1jYyEiID0+IFwkc2lnbmVkX29mZl9ieV9jYywKCQkgICAgImRyeS1ydW4iID0+IFwkZHJ5X3J1biwKCQkgICAgImVudmVsb3BlLXNlbmRlcj1zIiA9PiBcJGVudmVsb3BlX3NlbmRlciwKCQkgICAgInRocmVhZCEiID0+IFwkdGhyZWFkLAoJCSAgICAidmFsaWRhdGUhIiA9PiBcJHZhbGlkYXRlLAoJICk7Cgp1bmxlc3MgKCRyYykgewogICAgdXNhZ2UoKTsKfQoKIyBOb3csIGxldCdzIGZpbGwgYW55IHRoYXQgYXJlbid0IHNldCBpbiB3aXRoIGRlZmF1bHRzOgoKc3ViIHJlYWRfY29uZmlnIHsKCW15ICgkcHJlZml4KSA9IEBfOwoKCWZvcmVhY2ggbXkgJHNldHRpbmcgKGtleXMgJWNvbmZpZ19ib29sX3NldHRpbmdzKSB7CgkJbXkgJHRhcmdldCA9ICRjb25maWdfYm9vbF9zZXR0aW5nc3skc2V0dGluZ30tPlswXTsKCQkkJHRhcmdldCA9IEdpdDo6Y29uZmlnX2Jvb2woQHJlcG8sICIkcHJlZml4LiRzZXR0aW5nIikgdW5sZXNzIChkZWZpbmVkICQkdGFyZ2V0KTsKCX0KCglmb3JlYWNoIG15ICRzZXR0aW5nIChrZXlzICVjb25maWdfc2V0dGluZ3MpIHsKCQlteSAkdGFyZ2V0ID0gJGNvbmZpZ19zZXR0aW5nc3skc2V0dGluZ307CgkJaWYgKHJlZigkdGFyZ2V0KSBlcSAiQVJSQVkiKSB7CgkJCXVubGVzcyAoQCR0YXJnZXQpIHsKCQkJCW15IEB2YWx1ZXMgPSBHaXQ6OmNvbmZpZyhAcmVwbywgIiRwcmVmaXguJHNldHRpbmciKTsKCQkJCUAkdGFyZ2V0ID0gQHZhbHVlcyBpZiAoQHZhbHVlcyAmJiBkZWZpbmVkICR2YWx1ZXNbMF0pOwoJCQl9CgkJfQoJCWVsc2UgewoJCQkkJHRhcmdldCA9IEdpdDo6Y29uZmlnKEByZXBvLCAiJHByZWZpeC4kc2V0dGluZyIpIHVubGVzcyAoZGVmaW5lZCAkJHRhcmdldCk7CgkJfQoJfQoKCWlmICghZGVmaW5lZCAkc210cF9lbmNyeXB0aW9uKSB7CgkJbXkgJGVuYyA9IEdpdDo6Y29uZmlnKEByZXBvLCAiJHByZWZpeC5zbXRwZW5jcnlwdGlvbiIpOwoJCWlmIChkZWZpbmVkICRlbmMpIHsKCQkJJHNtdHBfZW5jcnlwdGlvbiA9ICRlbmM7CgkJfSBlbHNpZiAoR2l0Ojpjb25maWdfYm9vbChAcmVwbywgIiRwcmVmaXguc210cHNzbCIpKSB7CgkJCSRzbXRwX2VuY3J5cHRpb24gPSAnc3NsJzsKCQl9Cgl9Cn0KCiMgcmVhZCBjb25maWd1cmF0aW9uIGZyb20gW3NlbmRlbWFpbCAiJGlkZW50aXR5Il0sIGZhbGwgYmFjayBvbiBbc2VuZGVtYWlsXQokaWRlbnRpdHkgPSBHaXQ6OmNvbmZpZyhAcmVwbywgInNlbmRlbWFpbC5pZGVudGl0eSIpIHVubGVzcyAoZGVmaW5lZCAkaWRlbnRpdHkpOwpyZWFkX2NvbmZpZygic2VuZGVtYWlsLiRpZGVudGl0eSIpIGlmIChkZWZpbmVkICRpZGVudGl0eSk7CnJlYWRfY29uZmlnKCJzZW5kZW1haWwiKTsKCiMgZmFsbCBiYWNrIG9uIGJ1aWx0aW4gYm9vbCBkZWZhdWx0cwpmb3JlYWNoIG15ICRzZXR0aW5nICh2YWx1ZXMgJWNvbmZpZ19ib29sX3NldHRpbmdzKSB7CgkkeyRzZXR0aW5nLT5bMF19ID0gJHNldHRpbmctPlsxXSB1bmxlc3MgKGRlZmluZWQgKCR7JHNldHRpbmctPlswXX0pKTsKfQoKIyAnZGVmYXVsdCcgZW5jcnlwdGlvbiBpcyBub25lIC0tIHRoaXMgb25seSBwcmV2ZW50cyBhIHdhcm5pbmcKJHNtdHBfZW5jcnlwdGlvbiA9ICcnIHVubGVzcyAoZGVmaW5lZCAkc210cF9lbmNyeXB0aW9uKTsKCiMgU2V0IENDIHN1cHByZXNzaW9ucwpteSglc3VwcHJlc3NfY2MpOwppZiAoQHN1cHByZXNzX2NjKSB7Cglmb3JlYWNoIG15ICRlbnRyeSAoQHN1cHByZXNzX2NjKSB7CgkJZGllICJVbmtub3duIC0tc3VwcHJlc3MtY2MgZmllbGQ6ICckZW50cnknXG4iCgkJCXVubGVzcyAkZW50cnkgPX4gL14oYWxsfGNjY21kfGNjfGF1dGhvcnxzZWxmfHNvYikkLzsKCQkkc3VwcHJlc3NfY2N7JGVudHJ5fSA9IDE7Cgl9Cn0KCmlmICgkc3VwcHJlc3NfY2N7J2FsbCd9KSB7Cglmb3JlYWNoIG15ICRlbnRyeSAocXcgKGNjbWQgY2MgYXV0aG9yIHNlbGYgc29iKSkgewoJCSRzdXBwcmVzc19jY3skZW50cnl9ID0gMTsKCX0KCWRlbGV0ZSAkc3VwcHJlc3NfY2N7J2FsbCd9Owp9CgojIElmIGV4cGxpY2l0IG9sZC1zdHlsZSBvbmVzIGFyZSBzcGVjaWZpZWQsIHRoZXkgdHJ1bXAgLS1zdXBwcmVzcy1jYy4KJHN1cHByZXNzX2NjeydzZWxmJ30gPSAkc3VwcHJlc3NfZnJvbSBpZiBkZWZpbmVkICRzdXBwcmVzc19mcm9tOwokc3VwcHJlc3NfY2N7J3NvYid9ID0gISRzaWduZWRfb2ZmX2J5X2NjIGlmIGRlZmluZWQgJHNpZ25lZF9vZmZfYnlfY2M7CgojIERlYnVnZ2luZywgcHJpbnQgb3V0IHRoZSBzdXBwcmVzc2lvbnMuCmlmICgwKSB7CglwcmludCAic3VwcHJlc3Npb25zOlxuIjsKCWZvcmVhY2ggbXkgJGVudHJ5IChrZXlzICVzdXBwcmVzc19jYykgewoJCXByaW50ZiAiICAlLTVzIC0+ICRzdXBwcmVzc19jY3skZW50cnl9XG4iLCAkZW50cnk7Cgl9Cn0KCm15ICgkcmVwb2F1dGhvciwgJHJlcG9jb21taXR0ZXIpOwooJHJlcG9hdXRob3IpID0gR2l0OjppZGVudF9wZXJzb24oQHJlcG8sICdhdXRob3InKTsKKCRyZXBvY29tbWl0dGVyKSA9IEdpdDo6aWRlbnRfcGVyc29uKEByZXBvLCAnY29tbWl0dGVyJyk7CgojIFZlcmlmeSB0aGUgdXNlciBpbnB1dAoKZm9yZWFjaCBteSAkZW50cnkgKEB0bykgewoJZGllICJDb21tYSBpbiAtLXRvIGVudHJ5OiAkZW50cnknXG4iIHVubGVzcyAkZW50cnkgIX4gbS8sLzsKfQoKZm9yZWFjaCBteSAkZW50cnkgKEBpbml0aWFsX2NjKSB7CglkaWUgIkNvbW1hIGluIC0tY2MgZW50cnk6ICRlbnRyeSdcbiIgdW5sZXNzICRlbnRyeSAhfiBtLywvOwp9Cgpmb3JlYWNoIG15ICRlbnRyeSAoQGJjY2xpc3QpIHsKCWRpZSAiQ29tbWEgaW4gLS1iY2NsaXN0IGVudHJ5OiAkZW50cnknXG4iIHVubGVzcyAkZW50cnkgIX4gbS8sLzsKfQoKbXkgJWFsaWFzZXM7Cm15ICVwYXJzZV9hbGlhcyA9ICgKCSMgbXVsdGlsaW5lIGZvcm1hdHMgY2FuIGJlIHN1cHBvcnRlZCBpbiB0aGUgZnV0dXJlCgltdXR0ID0+IHN1YiB7IG15ICRmaCA9IHNoaWZ0OyB3aGlsZSAoPCRmaD4pIHsKCQlpZiAoL15ccyphbGlhc1xzKyhcUyspXHMrKC4qKSQvKSB7CgkJCW15ICgkYWxpYXMsICRhZGRyKSA9ICgkMSwgJDIpOwoJCQkkYWRkciA9fiBzLyMuKiQvLzsgIyBtdXR0IGFsbG93cyAjIGNvbW1lbnRzCgkJCSAjIGNvbW1hcyBkZWxpbWl0IG11bHRpcGxlIGFkZHJlc3NlcwoJCQkkYWxpYXNlc3skYWxpYXN9ID0gWyBzcGxpdCgvXHMqLFxzKi8sICRhZGRyKSBdOwoJCX19fSwKCW1haWxyYyA9PiBzdWIgeyBteSAkZmggPSBzaGlmdDsgd2hpbGUgKDwkZmg+KSB7CgkJaWYgKC9eYWxpYXNccysoXFMrKVxzKyguKikkLykgewoJCQkjIHNwYWNlcyBkZWxpbWl0IG11bHRpcGxlIGFkZHJlc3NlcwoJCQkkYWxpYXNlc3skMX0gPSBbIHNwbGl0KC9ccysvLCAkMikgXTsKCQl9fX0sCglwaW5lID0+IHN1YiB7IG15ICRmaCA9IHNoaWZ0OyBteSAkZj0nXHRbXlx0XSonOwoJICAgICAgICBmb3IgKG15ICR4ID0gJyc7IGRlZmluZWQoJHgpOyAkeCA9ICRfKSB7CgkJCWNob21wICR4OwoJCSAgICAgICAgJHggLj0gJDEgd2hpbGUoZGVmaW5lZCgkXyA9IDwkZmg+KSAmJiAvXiArKC4qKSQvKTsKCQkJJHggPX4gL14oXFMrKSRmXHRcKD8oW15cdF0rPylcKT8oOj8kZil7MCwyfSQvIG9yIG5leHQ7CgkJCSRhbGlhc2VzeyQxfSA9IFsgc3BsaXQoL1xzKixccyovLCAkMikgXTsKCQl9fSwKCWdudXMgPT4gc3ViIHsgbXkgJGZoID0gc2hpZnQ7IHdoaWxlICg8JGZoPikgewoJCWlmICgvXChkZWZpbmUtbWFpbC1hbGlhc1xzKyIoXFMrPykiXHMrIihcUys/KSJcKS8pIHsKCQkJJGFsaWFzZXN7JDF9ID0gWyAkMiBdOwoJCX19fQopOwoKaWYgKEBhbGlhc19maWxlcyBhbmQgJGFsaWFzZmlsZXR5cGUgYW5kIGRlZmluZWQgJHBhcnNlX2FsaWFzeyRhbGlhc2ZpbGV0eXBlfSkgewoJZm9yZWFjaCBteSAkZmlsZSAoQGFsaWFzX2ZpbGVzKSB7CgkJb3BlbiBteSAkZmgsICc8JywgJGZpbGUgb3IgZGllICJvcGVuaW5nICRmaWxlOiAkIVxuIjsKCQkkcGFyc2VfYWxpYXN7JGFsaWFzZmlsZXR5cGV9LT4oJGZoKTsKCQljbG9zZSAkZmg7Cgl9Cn0KCigkc2VuZGVyKSA9IGV4cGFuZF9hbGlhc2VzKCRzZW5kZXIpIGlmIGRlZmluZWQgJHNlbmRlcjsKCiMgTm93IHRoYXQgYWxsIHRoZSBkZWZhdWx0cyBhcmUgc2V0LCBwcm9jZXNzIHRoZSByZXN0IG9mIHRoZSBjb21tYW5kIGxpbmUKIyBhcmd1bWVudHMgYW5kIGNvbGxlY3QgdXAgdGhlIGZpbGVzIHRoYXQgbmVlZCB0byBiZSBwcm9jZXNzZWQuCmZvciBteSAkZiAoQEFSR1YpIHsKCWlmICgtZCAkZikgewoJCW9wZW5kaXIoREgsJGYpCgkJCW9yIGRpZSAiRmFpbGVkIHRvIG9wZW5kaXIgJGY6ICQhIjsKCgkJcHVzaCBAZmlsZXMsIGdyZXAgeyAtZiAkXyB9IG1hcCB7ICskZiAuICIvIiAuICRfIH0KCQkJCXNvcnQgcmVhZGRpcihESCk7CgkJY2xvc2VkaXIoREgpOwoJfSBlbHNpZiAoLWYgJGYgb3IgLXAgJGYpIHsKCQlwdXNoIEBmaWxlcywgJGY7Cgl9IGVsc2UgewoJCXByaW50IFNUREVSUiAiU2tpcHBpbmcgJGYgLSBub3QgZm91bmQuXG4iOwoJfQp9CgppZiAoJHZhbGlkYXRlKSB7Cglmb3JlYWNoIG15ICRmIChAZmlsZXMpIHsKCQl1bmxlc3MgKC1wICRmKSB7CgkJCW15ICRlcnJvciA9IHZhbGlkYXRlX3BhdGNoKCRmKTsKCQkJJGVycm9yIGFuZCBkaWUgImZhdGFsOiAkZjogJGVycm9yXG53YXJuaW5nOiBubyBwYXRjaGVzIHdlcmUgc2VudFxuIjsKCQl9Cgl9Cn0KCmlmIChAZmlsZXMpIHsKCXVubGVzcyAoJHF1aWV0KSB7CgkJcHJpbnQgJF8sIlxuIiBmb3IgKEBmaWxlcyk7Cgl9Cn0gZWxzZSB7CglwcmludCBTVERFUlIgIlxuTm8gcGF0Y2ggZmlsZXMgc3BlY2lmaWVkIVxuXG4iOwoJdXNhZ2UoKTsKfQoKbXkgJHByb21wdGluZyA9IDA7CmlmICghZGVmaW5lZCAkc2VuZGVyKSB7Cgkkc2VuZGVyID0gJHJlcG9hdXRob3IgfHwgJHJlcG9jb21taXR0ZXIgfHwgJyc7CgoJd2hpbGUgKDEpIHsKCQkkXyA9ICR0ZXJtLT5yZWFkbGluZSgiV2hvIHNob3VsZCB0aGUgZW1haWxzIGFwcGVhciB0byBiZSBmcm9tPyBbJHNlbmRlcl0gIik7CgkJbGFzdCBpZiBkZWZpbmVkICRfOwoJCXByaW50ICJcbiI7Cgl9CgoJJHNlbmRlciA9ICRfIGlmICgkXyk7CglwcmludCAiRW1haWxzIHdpbGwgYmUgc2VudCBmcm9tOiAiLCAkc2VuZGVyLCAiXG4iOwoJJHByb21wdGluZysrOwp9CgppZiAoIUB0bykgewoKCgl3aGlsZSAoMSkgewoJCSRfID0gJHRlcm0tPnJlYWRsaW5lKCJXaG8gc2hvdWxkIHRoZSBlbWFpbHMgYmUgc2VudCB0bz8gIiwgIiIpOwoJCWxhc3QgaWYgZGVmaW5lZCAkXzsKCQlwcmludCAiXG4iOwoJfQoKCW15ICR0byA9ICRfOwoJcHVzaCBAdG8sIHNwbGl0IC8sXHMqLywgJHRvOwoJJHByb21wdGluZysrOwp9CgpzdWIgZXhwYW5kX2FsaWFzZXMgewoJbXkgQGN1ciA9IEBfOwoJbXkgQGxhc3Q7CglkbyB7CgkJQGxhc3QgPSBAY3VyOwoJCUBjdXIgPSBtYXAgeyAkYWxpYXNlc3skX30gPyBAeyRhbGlhc2VzeyRffX0gOiAkXyB9IEBsYXN0OwoJfSB3aGlsZSAoam9pbignLCcsQGN1cikgbmUgam9pbignLCcsQGxhc3QpKTsKCXJldHVybiBAY3VyOwp9CgpAdG8gPSBleHBhbmRfYWxpYXNlcyhAdG8pOwpAdG8gPSAobWFwIHsgc2FuaXRpemVfYWRkcmVzcygkXykgfSBAdG8pOwpAaW5pdGlhbF9jYyA9IGV4cGFuZF9hbGlhc2VzKEBpbml0aWFsX2NjKTsKQGJjY2xpc3QgPSBleHBhbmRfYWxpYXNlcyhAYmNjbGlzdCk7CgppZiAoIWRlZmluZWQgJGluaXRpYWxfc3ViamVjdCAmJiAkY29tcG9zZSkgewoJd2hpbGUgKDEpIHsKCQkkXyA9ICR0ZXJtLT5yZWFkbGluZSgiV2hhdCBzdWJqZWN0IHNob3VsZCB0aGUgaW5pdGlhbCBlbWFpbCBzdGFydCB3aXRoPyAiLCAkaW5pdGlhbF9zdWJqZWN0KTsKCQlsYXN0IGlmIGRlZmluZWQgJF87CgkJcHJpbnQgIlxuIjsKCX0KCgkkaW5pdGlhbF9zdWJqZWN0ID0gJF87CgkkcHJvbXB0aW5nKys7Cn0KCmlmICgkdGhyZWFkICYmICFkZWZpbmVkICRpbml0aWFsX3JlcGx5X3RvICYmICRwcm9tcHRpbmcpIHsKCXdoaWxlICgxKSB7CgkJJF89ICR0ZXJtLT5yZWFkbGluZSgiTWVzc2FnZS1JRCB0byBiZSB1c2VkIGFzIEluLVJlcGx5LVRvIGZvciB0aGUgZmlyc3QgZW1haWw/ICIsICRpbml0aWFsX3JlcGx5X3RvKTsKCQlsYXN0IGlmIGRlZmluZWQgJF87CgkJcHJpbnQgIlxuIjsKCX0KCgkkaW5pdGlhbF9yZXBseV90byA9ICRfOwp9CmlmIChkZWZpbmVkICRpbml0aWFsX3JlcGx5X3RvKSB7CgkkaW5pdGlhbF9yZXBseV90byA9fiBzL15ccyo8Py8vOwoJJGluaXRpYWxfcmVwbHlfdG8gPX4gcy8+P1xzKiQvLzsKCSRpbml0aWFsX3JlcGx5X3RvID0gIjwkaW5pdGlhbF9yZXBseV90bz4iIGlmICRpbml0aWFsX3JlcGx5X3RvIG5lICcnOwp9CgppZiAoIWRlZmluZWQgJHNtdHBfc2VydmVyKSB7Cglmb3JlYWNoIChxdyggL3Vzci9zYmluL3NlbmRtYWlsIC91c3IvbGliL3NlbmRtYWlsICkpIHsKCQlpZiAoLXggJF8pIHsKCQkJJHNtdHBfc2VydmVyID0gJF87CgkJCWxhc3Q7CgkJfQoJfQoJJHNtdHBfc2VydmVyIHx8PSAnbG9jYWxob3N0JzsgIyBjb3VsZCBiZSAxMjcuMC4wLjEsIHRvby4uLiAqc2hydWcqCn0KCmlmICgkY29tcG9zZSkgewoJIyBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBuZWVkIHRvIGJlIHNlY3VyZSwgYnV0IHdlIHdpbGwgbWFrZSBhIHNtYWxsCgkjIGVmZm9ydCB0byBoYXZlIGl0IGJlIHVuaXF1ZQoJb3BlbihDLCI+IiwkY29tcG9zZV9maWxlbmFtZSkKCQlvciBkaWUgIkZhaWxlZCB0byBvcGVuIGZvciB3cml0aW5nICRjb21wb3NlX2ZpbGVuYW1lOiAkISI7CglwcmludCBDICJGcm9tICRzZW5kZXIgIyBUaGlzIGxpbmUgaXMgaWdub3JlZC5cbiI7CglwcmludGYgQyAiU3ViamVjdDogJXNcblxuIiwgJGluaXRpYWxfc3ViamVjdDsKCXByaW50ZiBDIDw8RU9UOwpHSVQ6IFBsZWFzZSBlbnRlciB5b3VyIGVtYWlsIGJlbG93LgpHSVQ6IExpbmVzIGJlZ2lubmluZyBpbiAiR0lUOiAiIHdpbGwgYmUgcmVtb3ZlZC4KR0lUOiBDb25zaWRlciBpbmNsdWRpbmcgYW4gb3ZlcmFsbCBkaWZmc3RhdCBvciB0YWJsZSBvZiBjb250ZW50cwpHSVQ6IGZvciB0aGUgcGF0Y2ggeW91IGFyZSB3cml0aW5nLgoKRU9UCgljbG9zZShDKTsKCglteSAkZWRpdG9yID0gJEVOVntHSVRfRURJVE9SfSB8fCBHaXQ6OmNvbmZpZyhAcmVwbywgImNvcmUuZWRpdG9yIikgfHwgJEVOVntWSVNVQUx9IHx8ICRFTlZ7RURJVE9SfSB8fCAidmkiOwoJc3lzdGVtKCdzaCcsICctYycsICRlZGl0b3IuJyAiJEAiJywgJGVkaXRvciwgJGNvbXBvc2VfZmlsZW5hbWUpOwoKCW9wZW4oQzIsIj4iLCRjb21wb3NlX2ZpbGVuYW1lIC4gIi5maW5hbCIpCgkJb3IgZGllICJGYWlsZWQgdG8gb3BlbiAkY29tcG9zZV9maWxlbmFtZS5maW5hbCA6ICIgLiAkITsKCglvcGVuKEMsIjwiLCRjb21wb3NlX2ZpbGVuYW1lKQoJCW9yIGRpZSAiRmFpbGVkIHRvIG9wZW4gJGNvbXBvc2VfZmlsZW5hbWUgOiAiIC4gJCE7CgoJbXkgJG5lZWRfOGJpdF9jdGUgPSBmaWxlX2hhc19ub25hc2NpaSgkY29tcG9zZV9maWxlbmFtZSk7CglteSAkaW5fYm9keSA9IDA7Cgl3aGlsZSg8Qz4pIHsKCQluZXh0IGlmIG0vXkdJVDogLzsKCQlpZiAoISRpbl9ib2R5ICYmIC9eXG4kLykgewoJCQkkaW5fYm9keSA9IDE7CgkJCWlmICgkbmVlZF84Yml0X2N0ZSkgewoJCQkJcHJpbnQgQzIgIk1JTUUtVmVyc2lvbjogMS4wXG4iLAoJCQkJCSAiQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluOyAiLAoJCQkJCSAgICJjaGFyc2V0PXV0Zi04XG4iLAoJCQkJCSAiQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZzogOGJpdFxuIjsKCQkJfQoJCX0KCQlpZiAoISRpbl9ib2R5ICYmIC9eTUlNRS1WZXJzaW9uOi9pKSB7CgkJCSRuZWVkXzhiaXRfY3RlID0gMDsKCQl9CgkJaWYgKCEkaW5fYm9keSAmJiAvXlN1YmplY3Q6ID8oLiopL2kpIHsKCQkJbXkgJHN1YmplY3QgPSAkMTsKCQkJJF8gPSAiU3ViamVjdDogIiAuCgkJCQkoJHN1YmplY3QgPX4gL1teWzphc2NpaTpdXS8gPwoJCQkJIHF1b3RlX3JmYzIwNDcoJHN1YmplY3QpIDoKCQkJCSAkc3ViamVjdCkgLgoJCQkJIlxuIjsKCQl9CgkJcHJpbnQgQzIgJF87Cgl9CgljbG9zZShDKTsKCWNsb3NlKEMyKTsKCgl3aGlsZSAoMSkgewoJCSRfID0gJHRlcm0tPnJlYWRsaW5lKCJTZW5kIHRoaXMgZW1haWw/ICh5fG4pICIpOwoJCWxhc3QgaWYgZGVmaW5lZCAkXzsKCQlwcmludCAiXG4iOwoJfQoKCWlmICh1YyBzdWJzdHIoJF8sMCwxKSBuZSAnWScpIHsKCQljbGVhbnVwX2NvbXBvc2VfZmlsZXMoKTsKCQlleGl0KDApOwoJfQoKCUBmaWxlcyA9ICgkY29tcG9zZV9maWxlbmFtZSAuICIuZmluYWwiLCBAZmlsZXMpOwp9CgojIFZhcmlhYmxlcyB3ZSBzZXQgYXMgcGFydCBvZiB0aGUgbG9vcCBvdmVyIGZpbGVzCm91ciAoJG1lc3NhZ2VfaWQsICVtYWlsLCAkc3ViamVjdCwgJHJlcGx5X3RvLCAkcmVmZXJlbmNlcywgJG1lc3NhZ2UpOwoKc3ViIGV4dHJhY3RfdmFsaWRfYWRkcmVzcyB7CglteSAkYWRkcmVzcyA9IHNoaWZ0OwoJbXkgJGxvY2FsX3BhcnRfcmVnZXhwID0gJ1tePD4iXHNAXSsnOwoJbXkgJGRvbWFpbl9yZWdleHAgPSAnW14uPD4iXHNAXSsoPzpcLlteLjw+IlxzQF0rKSsnOwoKCSMgY2hlY2sgZm9yIGEgbG9jYWwgYWRkcmVzczoKCXJldHVybiAkYWRkcmVzcyBpZiAoJGFkZHJlc3MgPX4gL14oJGxvY2FsX3BhcnRfcmVnZXhwKSQvKTsKCgkkYWRkcmVzcyA9fiBzL15ccyo8KC4qKT5ccyokLyQxLzsKCWlmICgkaGF2ZV9lbWFpbF92YWxpZCkgewoJCXJldHVybiBzY2FsYXIgRW1haWw6OlZhbGlkLT5hZGRyZXNzKCRhZGRyZXNzKTsKCX0gZWxzZSB7CgkJIyBsZXNzIHJvYnVzdC9jb3JyZWN0IHRoYW4gdGhlIG1vbnN0ZXIgcmVnZXhwIGluIEVtYWlsOjpWYWxpZCwKCQkjIGJ1dCBzdGlsbCBkb2VzIGEgOTklIGpvYiwgYW5kIG9uZSBsZXNzIGRlcGVuZGVuY3kKCQkkYWRkcmVzcyA9fiAvKCRsb2NhbF9wYXJ0X3JlZ2V4cFxAJGRvbWFpbl9yZWdleHApLzsKCQlyZXR1cm4gJDE7Cgl9Cn0KCiMgVXN1YWxseSBkb24ndCBuZWVkIHRvIGNoYW5nZSBhbnl0aGluZyBiZWxvdyBoZXJlLgoKIyB3ZSBtYWtlIGEgImZha2UiIG1lc3NhZ2UgaWQgYnkgdGFraW5nIHRoZSBjdXJyZW50IG51bWJlcgojIG9mIHNlY29uZHMgc2luY2UgdGhlIGJlZ2lubmluZyBvZiBVbml4IHRpbWUgYW5kIHRhY2tpbmcgb24KIyBhIHJhbmRvbSBudW1iZXIgdG8gdGhlIGVuZCwgaW4gY2FzZSB3ZSBhcmUgY2FsbGVkIHF1aWNrZXIgdGhhbgojIDEgc2Vjb25kIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2Ugd2VyZSBjYWxsZWQuCgojIFdlJ2xsIHNldHVwIGEgdGVtcGxhdGUgZm9yIHRoZSBtZXNzYWdlIGlkLCB1c2luZyB0aGUgImZyb20iIGFkZHJlc3M6CgpteSAoJG1lc3NhZ2VfaWRfc3RhbXAsICRtZXNzYWdlX2lkX3NlcmlhbCk7CnN1YiBtYWtlX21lc3NhZ2VfaWQKewoJbXkgJHVuaXE7CglpZiAoIWRlZmluZWQgJG1lc3NhZ2VfaWRfc3RhbXApIHsKCQkkbWVzc2FnZV9pZF9zdGFtcCA9IHNwcmludGYoIiVzLSVzIiwgdGltZSwgJCQpOwoJCSRtZXNzYWdlX2lkX3NlcmlhbCA9IDA7Cgl9CgkkbWVzc2FnZV9pZF9zZXJpYWwrKzsKCSR1bmlxID0gIiRtZXNzYWdlX2lkX3N0YW1wLSRtZXNzYWdlX2lkX3NlcmlhbCI7CgoJbXkgJGR1X3BhcnQ7Cglmb3IgKCRzZW5kZXIsICRyZXBvY29tbWl0dGVyLCAkcmVwb2F1dGhvcikgewoJCSRkdV9wYXJ0ID0gZXh0cmFjdF92YWxpZF9hZGRyZXNzKHNhbml0aXplX2FkZHJlc3MoJF8pKTsKCQlsYXN0IGlmIChkZWZpbmVkICRkdV9wYXJ0IGFuZCAkZHVfcGFydCBuZSAnJyk7Cgl9CglpZiAobm90IGRlZmluZWQgJGR1X3BhcnQgb3IgJGR1X3BhcnQgZXEgJycpIHsKCQl1c2UgU3lzOjpIb3N0bmFtZSBxdygpOwoJCSRkdV9wYXJ0ID0gJ3VzZXJAJyAuIFN5czo6SG9zdG5hbWU6Omhvc3RuYW1lKCk7Cgl9CglteSAkbWVzc2FnZV9pZF90ZW1wbGF0ZSA9ICI8JXMtZ2l0LXNlbmQtZW1haWwtJXM+IjsKCSRtZXNzYWdlX2lkID0gc3ByaW50ZigkbWVzc2FnZV9pZF90ZW1wbGF0ZSwgJHVuaXEsICRkdV9wYXJ0KTsKCSNwcmludCAibmV3IG1lc3NhZ2UgaWQgPSAkbWVzc2FnZV9pZFxuIjsgIyBXYXMgdXNlZnVsIGZvciBkZWJ1Z2dpbmcKfQoKCgokdGltZSA9IHRpbWUgLSBzY2FsYXIgJCNmaWxlczsKCnN1YiB1bnF1b3RlX3JmYzIwNDcgewoJbG9jYWwgKCRfKSA9IEBfOwoJbXkgJGVuY29kaW5nOwoJaWYgKHMvPVw/KFteP10rKVw/cVw/KC4qKVw/PS8kMi9nKSB7CgkJJGVuY29kaW5nID0gJDE7CgkJcy9fLyAvZzsKCQlzLz0oWzAtOUEtRl17Mn0pL2NocihoZXgoJDEpKS9lZzsKCX0KCXJldHVybiB3YW50YXJyYXkgPyAoJF8sICRlbmNvZGluZykgOiAkXzsKfQoKc3ViIHF1b3RlX3JmYzIwNDcgewoJbG9jYWwgJF8gPSBzaGlmdDsKCW15ICRlbmNvZGluZyA9IHNoaWZ0IHx8ICd1dGYtOCc7CglzLyhbXi1hLXpBLVowLTkhKitcL10pL3NwcmludGYoIj0lMDJYIiwgb3JkKCQxKSkvZWc7CglzLyguKikvPVw/JGVuY29kaW5nXD9xXD8kMVw/PS87CglyZXR1cm4gJF87Cn0KCiMgdXNlIHRoZSBzaW1wbGVzdCBxdW90aW5nIGJlaW5nIGFibGUgdG8gaGFuZGxlIHRoZSByZWNpcGllbnQKc3ViIHNhbml0aXplX2FkZHJlc3MKewoJbXkgKCRyZWNpcGllbnQpID0gQF87CglteSAoJHJlY2lwaWVudF9uYW1lLCAkcmVjaXBpZW50X2FkZHIpID0gKCRyZWNpcGllbnQgPX4gL14oLio/KVxzKig8LiopLyk7CgoJaWYgKG5vdCAkcmVjaXBpZW50X25hbWUpIHsKCQlyZXR1cm4gIiRyZWNpcGllbnQiOwoJfQoKCSMgaWYgcmVjaXBpZW50X25hbWUgaXMgYWxyZWFkeSBxdW90ZWQsIGRvIG5vdGhpbmcKCWlmICgkcmVjaXBpZW50X25hbWUgPX4gL14oIi4qInw9XD91dGYtOFw/cVw/LipcPz0pJC8pIHsKCQlyZXR1cm4gJHJlY2lwaWVudDsKCX0KCgkjIHJmYzIwNDcgaXMgbmVlZGVkIGlmIGEgbm9uLWFzY2lpIGNoYXIgaXMgaW5jbHVkZWQKCWlmICgkcmVjaXBpZW50X25hbWUgPX4gL1teWzphc2NpaTpdXS8pIHsKCQkkcmVjaXBpZW50X25hbWUgPSBxdW90ZV9yZmMyMDQ3KCRyZWNpcGllbnRfbmFtZSk7Cgl9CgoJIyBkb3VibGUgcXVvdGVzIGFyZSBuZWVkZWQgaWYgc3BlY2lhbHMgb3IgQ1RMcyBhcmUgaW5jbHVkZWQKCWVsc2lmICgkcmVjaXBpZW50X25hbWUgPX4gL1tdWygpPD5ALDs6XFwiLlwwMDAtXDAzN1wxNzddLykgewoJCSRyZWNpcGllbnRfbmFtZSA9fiBzLyhbIlxcXHJdKS9cXCQxL2c7CgkJJHJlY2lwaWVudF9uYW1lID0gIlwiJHJlY2lwaWVudF9uYW1lXCIiOwoJfQoKCXJldHVybiAiJHJlY2lwaWVudF9uYW1lICRyZWNpcGllbnRfYWRkciI7Cgp9CgpzdWIgc2VuZF9tZXNzYWdlCnsKCW15IEByZWNpcGllbnRzID0gdW5pcXVlX2VtYWlsX2xpc3QoQHRvKTsKCUBjYyA9IChncmVwIHsgbXkgJGNjID0gZXh0cmFjdF92YWxpZF9hZGRyZXNzKCRfKTsKCQkgICAgICBub3QgZ3JlcCB7ICRjYyBlcSAkXyB9IEByZWNpcGllbnRzCgkJICAgIH0KCSAgICAgICBtYXAgeyBzYW5pdGl6ZV9hZGRyZXNzKCRfKSB9CgkgICAgICAgQGNjKTsKCW15ICR0byA9IGpvaW4gKCIsXG5cdCIsIEByZWNpcGllbnRzKTsKCUByZWNpcGllbnRzID0gdW5pcXVlX2VtYWlsX2xpc3QoQHJlY2lwaWVudHMsQGNjLEBiY2NsaXN0KTsKCUByZWNpcGllbnRzID0gKG1hcCB7IGV4dHJhY3RfdmFsaWRfYWRkcmVzcygkXykgfSBAcmVjaXBpZW50cyk7CglteSAkZGF0ZSA9IGZvcm1hdF8yODIyX3RpbWUoJHRpbWUrKyk7CglteSAkZ2l0dmVyc2lvbiA9ICdAQEdJVF9WRVJTSU9OQEAnOwoJaWYgKCRnaXR2ZXJzaW9uID1+IG0vLi5HSVRfVkVSU0lPTi4uLykgewoJICAgICRnaXR2ZXJzaW9uID0gR2l0Ojp2ZXJzaW9uKCk7Cgl9CgoJbXkgJGNjID0gam9pbigiLCAiLCB1bmlxdWVfZW1haWxfbGlzdChAY2MpKTsKCW15ICRjY2xpbmUgPSAiIjsKCWlmICgkY2MgbmUgJycpIHsKCQkkY2NsaW5lID0gIlxuQ2M6ICRjYyI7Cgl9CglteSAkc2FuaXRpemVkX3NlbmRlciA9IHNhbml0aXplX2FkZHJlc3MoJHNlbmRlcik7CgltYWtlX21lc3NhZ2VfaWQoKSB1bmxlc3MgZGVmaW5lZCgkbWVzc2FnZV9pZCk7CgoJbXkgJGhlYWRlciA9ICJGcm9tOiAkc2FuaXRpemVkX3NlbmRlcgpUbzogJHRvJHtjY2xpbmV9ClN1YmplY3Q6ICRzdWJqZWN0CkRhdGU6ICRkYXRlCk1lc3NhZ2UtSWQ6ICRtZXNzYWdlX2lkClgtTWFpbGVyOiBnaXQtc2VuZC1lbWFpbCAkZ2l0dmVyc2lvbgoiOwoJaWYgKCR0aHJlYWQgJiYgJHJlcGx5X3RvKSB7CgoJCSRoZWFkZXIgLj0gIkluLVJlcGx5LVRvOiAkcmVwbHlfdG9cbiI7CgkJJGhlYWRlciAuPSAiUmVmZXJlbmNlczogJHJlZmVyZW5jZXNcbiI7Cgl9CglpZiAoQHhoKSB7CgkJJGhlYWRlciAuPSBqb2luKCJcbiIsIEB4aCkgLiAiXG4iOwoJfQoKCW15IEBzZW5kbWFpbF9wYXJhbWV0ZXJzID0gKCctaScsIEByZWNpcGllbnRzKTsKCW15ICRyYXdfZnJvbSA9ICRzYW5pdGl6ZWRfc2VuZGVyOwoJJHJhd19mcm9tID0gJGVudmVsb3BlX3NlbmRlciBpZiAoZGVmaW5lZCAkZW52ZWxvcGVfc2VuZGVyKTsKCSRyYXdfZnJvbSA9IGV4dHJhY3RfdmFsaWRfYWRkcmVzcygkcmF3X2Zyb20pOwoJdW5zaGlmdCAoQHNlbmRtYWlsX3BhcmFtZXRlcnMsCgkJCSctZicsICRyYXdfZnJvbSkgaWYoZGVmaW5lZCAkZW52ZWxvcGVfc2VuZGVyKTsKCglpZiAoJGRyeV9ydW4pIHsKCQkjIFdlIGRvbid0IHdhbnQgdG8gc2VuZCB0aGUgZW1haWwuCgl9IGVsc2lmICgkc210cF9zZXJ2ZXIgPX4gbSNeLyMpIHsKCQlteSAkcGlkID0gb3BlbiBteSAkc20sICd8LSc7CgkJZGVmaW5lZCAkcGlkIG9yIGRpZSAkITsKCQlpZiAoISRwaWQpIHsKCQkJZXhlYygkc210cF9zZXJ2ZXIsIEBzZW5kbWFpbF9wYXJhbWV0ZXJzKSBvciBkaWUgJCE7CgkJfQoJCXByaW50ICRzbSAiJGhlYWRlclxuJG1lc3NhZ2UiOwoJCWNsb3NlICRzbSBvciBkaWUgJD87Cgl9IGVsc2UgewoKCQlpZiAoIWRlZmluZWQgJHNtdHBfc2VydmVyKSB7CgkJCWRpZSAiVGhlIHJlcXVpcmVkIFNNVFAgc2VydmVyIGlzIG5vdCBwcm9wZXJseSBkZWZpbmVkLiIKCQl9CgoJCWlmICgkc210cF9lbmNyeXB0aW9uIGVxICdzc2wnKSB7CgkJCSRzbXRwX3NlcnZlcl9wb3J0IHx8PSA0NjU7ICMgc3NtdHAKCQkJcmVxdWlyZSBOZXQ6OlNNVFA6OlNTTDsKCQkJJHNtdHAgfHw9IE5ldDo6U01UUDo6U1NMLT5uZXcoJHNtdHBfc2VydmVyLCBQb3J0ID0+ICRzbXRwX3NlcnZlcl9wb3J0KTsKCQl9CgkJZWxzZSB7CgkJCXJlcXVpcmUgTmV0OjpTTVRQOwoJCQkkc210cCB8fD0gTmV0OjpTTVRQLT5uZXcoKGRlZmluZWQgJHNtdHBfc2VydmVyX3BvcnQpCgkJCQkJCSA/ICIkc210cF9zZXJ2ZXI6JHNtdHBfc2VydmVyX3BvcnQiCgkJCQkJCSA6ICRzbXRwX3NlcnZlcik7CgkJCWlmICgkc210cF9lbmNyeXB0aW9uIGVxICd0bHMnKSB7CgkJCQlyZXF1aXJlIE5ldDo6U01UUDo6U1NMOwoJCQkJJHNtdHAtPmNvbW1hbmQoJ1NUQVJUVExTJyk7CgkJCQkkc210cC0+cmVzcG9uc2UoKTsKCQkJCWlmICgkc210cC0+Y29kZSA9PSAyMjApIHsKCQkJCQkkc210cCA9IE5ldDo6U01UUDo6U1NMLT5zdGFydF9TU0woJHNtdHApCgkJCQkJCW9yIGRpZSAiU1RBUlRUTFMgZmFpbGVkISAiLiRzbXRwLT5tZXNzYWdlOwoJCQkJCSRzbXRwX2VuY3J5cHRpb24gPSAnJzsKCQkJCQkjIFNlbmQgRUhMTyBhZ2FpbiB0byByZWNlaXZlIGZyZXNoCgkJCQkJIyBzdXBwb3J0ZWQgY29tbWFuZHMKCQkJCQkkc210cC0+aGVsbG8oKTsKCQkJCX0gZWxzZSB7CgkJCQkJZGllICJTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCBTVEFSVFRMUyEgIi4kc210cC0+bWVzc2FnZTsKCQkJCX0KCQkJfQoJCX0KCgkJaWYgKCEkc210cCkgewoJCQlkaWUgIlVuYWJsZSB0byBpbml0aWFsaXplIFNNVFAgcHJvcGVybHkuICBJcyB0aGVyZSBzb21ldGhpbmcgd3Jvbmcgd2l0aCB5b3VyIGNvbmZpZz8iOwoJCX0KCgkJaWYgKGRlZmluZWQgJHNtdHBfYXV0aHVzZXIpIHsKCgkJCWlmICghZGVmaW5lZCAkc210cF9hdXRocGFzcykgewoKCQkJCXN5c3RlbSAic3R0eSAtZWNobyI7CgoJCQkJZG8gewoJCQkJCXByaW50ICJQYXNzd29yZDogIjsKCQkJCQkkXyA9IDxTVERJTj47CgkJCQkJcHJpbnQgIlxuIjsKCQkJCX0gd2hpbGUgKCFkZWZpbmVkICRfKTsKCgkJCQljaG9tcCgkc210cF9hdXRocGFzcyA9ICRfKTsKCgkJCQlzeXN0ZW0gInN0dHkgZWNobyI7CgkJCX0KCgkJCSRhdXRoIHx8PSAkc210cC0+YXV0aCggJHNtdHBfYXV0aHVzZXIsICRzbXRwX2F1dGhwYXNzICkgb3IgZGllICRzbXRwLT5tZXNzYWdlOwoJCX0KCgkJJHNtdHAtPm1haWwoICRyYXdfZnJvbSApIG9yIGRpZSAkc210cC0+bWVzc2FnZTsKCQkkc210cC0+dG8oIEByZWNpcGllbnRzICkgb3IgZGllICRzbXRwLT5tZXNzYWdlOwoJCSRzbXRwLT5kYXRhIG9yIGRpZSAkc210cC0+bWVzc2FnZTsKCQkkc210cC0+ZGF0YXNlbmQoIiRoZWFkZXJcbiRtZXNzYWdlIikgb3IgZGllICRzbXRwLT5tZXNzYWdlOwoJCSRzbXRwLT5kYXRhZW5kKCkgb3IgZGllICRzbXRwLT5tZXNzYWdlOwoJCSRzbXRwLT5vayBvciBkaWUgIkZhaWxlZCB0byBzZW5kICRzdWJqZWN0XG4iLiRzbXRwLT5tZXNzYWdlOwoJfQoJaWYgKCRxdWlldCkgewoJCXByaW50ZiAoKCRkcnlfcnVuID8gIkRyeS0iIDogIiIpLiJTZW50ICVzXG4iLCAkc3ViamVjdCk7Cgl9IGVsc2UgewoJCXByaW50ICgoJGRyeV9ydW4gPyAiRHJ5LSIgOiAiIikuIk9LLiBMb2cgc2F5czpcbiIpOwoJCWlmICgkc210cF9zZXJ2ZXIgIX4gbSNeLyMpIHsKCQkJcHJpbnQgIlNlcnZlcjogJHNtdHBfc2VydmVyXG4iOwoJCQlwcmludCAiTUFJTCBGUk9NOjwkcmF3X2Zyb20+XG4iOwoJCQlwcmludCAiUkNQVCBUTzoiLmpvaW4oJywnLChtYXAgeyAiPCRfPiIgfSBAcmVjaXBpZW50cykpLiJcbiI7CgkJfSBlbHNlIHsKCQkJcHJpbnQgIlNlbmRtYWlsOiAkc210cF9zZXJ2ZXIgIi5qb2luKCcgJyxAc2VuZG1haWxfcGFyYW1ldGVycykuIlxuIjsKCQl9CgkJcHJpbnQgJGhlYWRlciwgIlxuIjsKCQlpZiAoJHNtdHApIHsKCQkJcHJpbnQgIlJlc3VsdDogIiwgJHNtdHAtPmNvZGUsICcgJywKCQkJCSgkc210cC0+bWVzc2FnZSA9fiAvXG4oW15cbl0rXG4pJC9zKSwgIlxuIjsKCQl9IGVsc2UgewoJCQlwcmludCAiUmVzdWx0OiBPS1xuIjsKCQl9Cgl9Cn0KCiRyZXBseV90byA9ICRpbml0aWFsX3JlcGx5X3RvOwokcmVmZXJlbmNlcyA9ICRpbml0aWFsX3JlcGx5X3RvIHx8ICcnOwokc3ViamVjdCA9ICRpbml0aWFsX3N1YmplY3Q7Cgpmb3JlYWNoIG15ICR0IChAZmlsZXMpIHsKCW9wZW4oRiwiPCIsJHQpIG9yIGRpZSAiY2FuJ3Qgb3BlbiBmaWxlICR0IjsKCglteSAkYXV0aG9yID0gdW5kZWY7CglteSAkYXV0aG9yX2VuY29kaW5nOwoJbXkgJGhhc19jb250ZW50X3R5cGU7CglteSAkYm9keV9lbmNvZGluZzsKCUBjYyA9IEBpbml0aWFsX2NjOwoJQHhoID0gKCk7CglteSAkaW5wdXRfZm9ybWF0ID0gdW5kZWY7CglteSAkaGVhZGVyX2RvbmUgPSAwOwoJJG1lc3NhZ2UgPSAiIjsKCXdoaWxlKDxGPikgewoJCWlmICghJGhlYWRlcl9kb25lKSB7CgkJCWlmICgvXkZyb20gLykgewoJCQkJJGlucHV0X2Zvcm1hdCA9ICdtYm94JzsKCQkJCW5leHQ7CgkJCX0KCQkJY2hvbXA7CgkJCWlmICghZGVmaW5lZCAkaW5wdXRfZm9ybWF0ICYmIC9eWy1BLVphLXpdKzpccy8pIHsKCQkJCSRpbnB1dF9mb3JtYXQgPSAnbWJveCc7CgkJCX0KCgkJCWlmIChkZWZpbmVkICRpbnB1dF9mb3JtYXQgJiYgJGlucHV0X2Zvcm1hdCBlcSAnbWJveCcpIHsKCQkJCWlmICgvXlN1YmplY3Q6XHMrKC4qKSQvKSB7CgkJCQkJJHN1YmplY3QgPSAkMTsKCgkJCQl9IGVsc2lmICgvXihDY3xGcm9tKTpccysoLiopJC8pIHsKCQkJCQlpZiAodW5xdW90ZV9yZmMyMDQ3KCQyKSBlcSAkc2VuZGVyKSB7CgkJCQkJCW5leHQgaWYgKCRzdXBwcmVzc19jY3snc2VsZid9KTsKCQkJCQl9CgkJCQkJZWxzaWYgKCQxIGVxICdGcm9tJykgewoJCQkJCQkoJGF1dGhvciwgJGF1dGhvcl9lbmNvZGluZykKCQkJCQkJICA9IHVucXVvdGVfcmZjMjA0NygkMik7CgkJCQkJCW5leHQgaWYgKCRzdXBwcmVzc19jY3snYXV0aG9yJ30pOwoJCQkJCX0gZWxzZSB7CgkJCQkJCW5leHQgaWYgKCRzdXBwcmVzc19jY3snY2MnfSk7CgkJCQkJfQoJCQkJCXByaW50ZigiKG1ib3gpIEFkZGluZyBjYzogJXMgZnJvbSBsaW5lICclcydcbiIsCgkJCQkJCSQyLCAkXykgdW5sZXNzICRxdWlldDsKCQkJCQlwdXNoIEBjYywgJDI7CgkJCQl9CgkJCQllbHNpZiAoL15Db250ZW50LXR5cGU6L2kpIHsKCQkJCQkkaGFzX2NvbnRlbnRfdHlwZSA9IDE7CgkJCQkJaWYgKC9jaGFyc2V0PSI/KFteICJdKykvKSB7CgkJCQkJCSRib2R5X2VuY29kaW5nID0gJDE7CgkJCQkJfQoJCQkJCXB1c2ggQHhoLCAkXzsKCQkJCX0KCQkJCWVsc2lmICgvXk1lc3NhZ2UtSWQ6ICguKikvaSkgewoJCQkJCSRtZXNzYWdlX2lkID0gJDE7CgkJCQl9CgkJCQllbHNpZiAoIS9eRGF0ZTpccy8gJiYgL15bLUEtWmEtel0rOlxzK1xTLykgewoJCQkJCXB1c2ggQHhoLCAkXzsKCQkJCX0KCgkJCX0gZWxzZSB7CgkJCQkjIEluIHRoZSB0cmFkaXRpb25hbAoJCQkJIyAic2VuZCBsb3RzIG9mIGVtYWlsIiBmb3JtYXQsCgkJCQkjIGxpbmUgMSA9IGNjCgkJCQkjIGxpbmUgMiA9IHN1YmplY3QKCQkJCSMgU28gbGV0J3Mgc3VwcG9ydCB0aGF0LCB0b28uCgkJCQkkaW5wdXRfZm9ybWF0ID0gJ2xvdHMnOwoJCQkJaWYgKEBjYyA9PSAwICYmICEkc3VwcHJlc3NfY2N7J2NjJ30pIHsKCQkJCQlwcmludGYoIihub24tbWJveCkgQWRkaW5nIGNjOiAlcyBmcm9tIGxpbmUgJyVzJ1xuIiwKCQkJCQkJJF8sICRfKSB1bmxlc3MgJHF1aWV0OwoKCQkJCQlwdXNoIEBjYywgJF87CgoJCQkJfSBlbHNpZiAoIWRlZmluZWQgJHN1YmplY3QpIHsKCQkJCQkkc3ViamVjdCA9ICRfOwoJCQkJfQoJCQl9CgoJCQkjIEEgd2hpdGVzcGFjZSBsaW5lIHdpbGwgdGVybWluYXRlIHRoZSBoZWFkZXJzCgkJCWlmIChtL15ccyokLykgewoJCQkJJGhlYWRlcl9kb25lID0gMTsKCQkJfQoJCX0gZWxzZSB7CgkJCSRtZXNzYWdlIC49ICAkXzsKCQkJaWYgKC9eKFNpZ25lZC1vZmYtYnl8Q2MpOiAoLiopJC9pKSB7CgkJCQluZXh0IGlmICgkc3VwcHJlc3NfY2N7J3NvYid9KTsKCQkJCWNob21wOwoJCQkJbXkgJGMgPSAkMjsKCQkJCWNob21wICRjOwoJCQkJbmV4dCBpZiAoJGMgZXEgJHNlbmRlciBhbmQgJHN1cHByZXNzX2NjeydzZWxmJ30pOwoJCQkJcHVzaCBAY2MsICRjOwoJCQkJcHJpbnRmKCIoc29iKSBBZGRpbmcgY2M6ICVzIGZyb20gbGluZSAnJXMnXG4iLAoJCQkJCSRjLCAkXykgdW5sZXNzICRxdWlldDsKCQkJfQoJCX0KCX0KCWNsb3NlIEY7CgoJaWYgKGRlZmluZWQgJGNjX2NtZCAmJiAhJHN1cHByZXNzX2NjeydjY2NtZCd9KSB7CgkJb3BlbihGLCAiJGNjX2NtZCAkdCB8IikKCQkJb3IgZGllICIoY2MtY21kKSBDb3VsZCBub3QgZXhlY3V0ZSAnJGNjX2NtZCciOwoJCXdoaWxlKDxGPikgewoJCQlteSAkYyA9ICRfOwoJCQkkYyA9fiBzL15ccyovL2c7CgkJCSRjID1+IHMvXG4kLy9nOwoJCQluZXh0IGlmICgkYyBlcSAkc2VuZGVyIGFuZCAkc3VwcHJlc3NfZnJvbSk7CgkJCXB1c2ggQGNjLCAkYzsKCQkJcHJpbnRmKCIoY2MtY21kKSBBZGRpbmcgY2M6ICVzIGZyb206ICclcydcbiIsCgkJCQkkYywgJGNjX2NtZCkgdW5sZXNzICRxdWlldDsKCQl9CgkJY2xvc2UgRgoJCQlvciBkaWUgIihjYy1jbWQpIGZhaWxlZCB0byBjbG9zZSBwaXBlIHRvICckY2NfY21kJyI7Cgl9CgoJaWYgKGRlZmluZWQgJGF1dGhvcikgewoJCSRtZXNzYWdlID0gIkZyb206ICRhdXRob3JcblxuJG1lc3NhZ2UiOwoJCWlmIChkZWZpbmVkICRhdXRob3JfZW5jb2RpbmcpIHsKCQkJaWYgKCRoYXNfY29udGVudF90eXBlKSB7CgkJCQlpZiAoJGJvZHlfZW5jb2RpbmcgZXEgJGF1dGhvcl9lbmNvZGluZykgewoJCQkJCSMgb2ssIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgZW5jb2RpbmcKCQkJCX0KCQkJCWVsc2UgewoJCQkJCSMgdWggb2gsIHdlIHNob3VsZCByZS1lbmNvZGUKCQkJCX0KCQkJfQoJCQllbHNlIHsKCQkJCXB1c2ggQHhoLAoJCQkJICAnTUlNRS1WZXJzaW9uOiAxLjAnLAoJCQkJICAiQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluOyBjaGFyc2V0PSRhdXRob3JfZW5jb2RpbmciLAoJCQkJICAnQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZzogOGJpdCc7CgkJCX0KCQl9Cgl9CgoJc2VuZF9tZXNzYWdlKCk7CgoJIyBzZXQgdXAgZm9yIHRoZSBuZXh0IG1lc3NhZ2UKCWlmICgkY2hhaW5fcmVwbHlfdG8gfHwgIWRlZmluZWQgJHJlcGx5X3RvIHx8IGxlbmd0aCgkcmVwbHlfdG8pID09IDApIHsKCQkkcmVwbHlfdG8gPSAkbWVzc2FnZV9pZDsKCQlpZiAobGVuZ3RoICRyZWZlcmVuY2VzID4gMCkgewoJCQkkcmVmZXJlbmNlcyAuPSAiXG4gJG1lc3NhZ2VfaWQiOwoJCX0gZWxzZSB7CgkJCSRyZWZlcmVuY2VzID0gIiRtZXNzYWdlX2lkIjsKCQl9Cgl9CgkkbWVzc2FnZV9pZCA9IHVuZGVmOwp9CgppZiAoJGNvbXBvc2UpIHsKCWNsZWFudXBfY29tcG9zZV9maWxlcygpOwp9CgpzdWIgY2xlYW51cF9jb21wb3NlX2ZpbGVzKCkgewoJdW5saW5rKCRjb21wb3NlX2ZpbGVuYW1lLCAkY29tcG9zZV9maWxlbmFtZSAuICIuZmluYWwiKTsKCn0KCiRzbXRwLT5xdWl0IGlmICRzbXRwOwoKc3ViIHVuaXF1ZV9lbWFpbF9saXN0KEApIHsKCW15ICVzZWVuOwoJbXkgQGVtYWlsczsKCglmb3JlYWNoIG15ICRlbnRyeSAoQF8pIHsKCQlpZiAobXkgJGNsZWFuID0gZXh0cmFjdF92YWxpZF9hZGRyZXNzKCRlbnRyeSkpIHsKCQkJJHNlZW57JGNsZWFufSB8fD0gMDsKCQkJbmV4dCBpZiAkc2VlbnskY2xlYW59Kys7CgkJCXB1c2ggQGVtYWlscywgJGVudHJ5OwoJCX0gZWxzZSB7CgkJCXByaW50IFNUREVSUiAiVzogdW5hYmxlIHRvIGV4dHJhY3QgYSB2YWxpZCBhZGRyZXNzIiwKCQkJCQkiIGZyb206ICRlbnRyeVxuIjsKCQl9Cgl9CglyZXR1cm4gQGVtYWlsczsKfQoKc3ViIHZhbGlkYXRlX3BhdGNoIHsKCW15ICRmbiA9IHNoaWZ0OwoJb3BlbihteSAkZmgsICc8JywgJGZuKQoJCW9yIGRpZSAidW5hYmxlIHRvIG9wZW4gJGZuOiAkIVxuIjsKCXdoaWxlIChteSAkbGluZSA9IDwkZmg+KSB7CgkJaWYgKGxlbmd0aCgkbGluZSkgPiA5OTgpIHsKCQkJcmV0dXJuICIkLjogcGF0Y2ggY29udGFpbnMgYSBsaW5lIGxvbmdlciB0aGFuIDk5OCBjaGFyYWN0ZXJzIjsKCQl9Cgl9CglyZXR1cm4gdW5kZWY7Cn0KCnN1YiBmaWxlX2hhc19ub25hc2NpaSB7CglteSAkZm4gPSBzaGlmdDsKCW9wZW4obXkgJGZoLCAnPCcsICRmbikKCQlvciBkaWUgInVuYWJsZSB0byBvcGVuICRmbjogJCFcbiI7Cgl3aGlsZSAobXkgJGxpbmUgPSA8JGZoPikgewoJCXJldHVybiAxIGlmICRsaW5lID1+IC9bXls6YXNjaWk6XV0vOwoJfQoJcmV0dXJuIDA7Cn0K",
    "text": "#!/usr/bin/perl -w\n#\n# Copyright 2002,2005 Greg Kroah-Hartman <greg@kroah.com>\n# Copyright 2005 Ryan Anderson <ryan@michonline.com>\n#\n# GPL v2 (See COPYING)\n#\n# Ported to support git \"mbox\" format files by Ryan Anderson <ryan@michonline.com>\n#\n# Sends a collection of emails to the given email addresses, disturbingly fast.\n#\n# Supports two formats:\n# 1. mbox format files (ignoring most headers and MIME formatting - this is designed for sending patches)\n# 2. The original format support by Greg's script:\n#    first line of the message is who to CC,\n#    and second line is the subject of the message.\n#\n\nuse strict;\nuse warnings;\nuse Term::ReadLine;\nuse Getopt::Long;\nuse Data::Dumper;\nuse Term::ANSIColor;\nuse Git;\n\npackage FakeTerm;\nsub new {\n\tmy ($class, $reason) = @_;\n\treturn bless \\$reason, shift;\n}\nsub readline {\n\tmy $self = shift;\n\tdie \"Cannot use readline on FakeTerm: $$self\";\n}\npackage main;\n\n\nsub usage {\n\tprint <<EOT;\ngit send-email [options] <file | directory>...\n\n  Composing:\n    --from                  <str>  * Email From:\n    --to                    <str>  * Email To:\n    --cc                    <str>  * Email Cc:\n    --bcc                   <str>  * Email Bcc:\n    --subject               <str>  * Email \"Subject:\"\n    --in-reply-to           <str>  * Email \"In-Reply-To:\"\n    --compose                      * Open an editor for introduction.\n\n  Sending:\n    --envelope-sender       <str>  * Email envelope sender.\n    --smtp-server       <str:int>  * Outgoing SMTP server to use. The port\n                                     is optional. Default 'localhost'.\n    --smtp-server-port      <int>  * Outgoing SMTP server port.\n    --smtp-user             <str>  * Username for SMTP-AUTH.\n    --smtp-pass             <str>  * Password for SMTP-AUTH; not necessary.\n    --smtp-encryption       <str>  * tls or ssl; anything else disables.\n    --smtp-ssl                     * Deprecated. Use '--smtp-encryption ssl'.\n\n  Automating:\n    --identity              <str>  * Use the sendemail.<id> options.\n    --cc-cmd                <str>  * Email Cc: via `<str> \\$patch_path`\n    --suppress-cc           <str>  * author, self, sob, cccmd, all.\n    --[no-]signed-off-by-cc        * Send to Cc: and Signed-off-by:\n                                     addresses. Default on.\n    --[no-]suppress-from           * Send to self. Default off.\n    --[no-]chain-reply-to          * Chain In-Reply-To: fields. Default on.\n    --[no-]thread                  * Use In-Reply-To: field. Default on.\n\n  Administering:\n    --quiet                        * Output one line of info per email.\n    --dry-run                      * Don't actually send the emails.\n    --[no-]validate                * Perform patch sanity checks. Default on.\n\nEOT\n\texit(1);\n}\n\n# most mail servers generate the Date: header, but not all...\nsub format_2822_time {\n\tmy ($time) = @_;\n\tmy @localtm = localtime($time);\n\tmy @gmttm = gmtime($time);\n\tmy $localmin = $localtm[1] + $localtm[2] * 60;\n\tmy $gmtmin = $gmttm[1] + $gmttm[2] * 60;\n\tif ($localtm[0] != $gmttm[0]) {\n\t\tdie \"local zone differs from GMT by a non-minute interval\\n\";\n\t}\n\tif ((($gmttm[6] + 1) % 7) == $localtm[6]) {\n\t\t$localmin += 1440;\n\t} elsif ((($gmttm[6] - 1) % 7) == $localtm[6]) {\n\t\t$localmin -= 1440;\n\t} elsif ($gmttm[6] != $localtm[6]) {\n\t\tdie \"local time offset greater than or equal to 24 hours\\n\";\n\t}\n\tmy $offset = $localmin - $gmtmin;\n\tmy $offhour = $offset / 60;\n\tmy $offmin = abs($offset % 60);\n\tif (abs($offhour) >= 24) {\n\t\tdie (\"local time offset greater than or equal to 24 hours\\n\");\n\t}\n\n\treturn sprintf(\"%s, %2d %s %d %02d:%02d:%02d %s%02d%02d\",\n\t\t       qw(Sun Mon Tue Wed Thu Fri Sat)[$localtm[6]],\n\t\t       $localtm[3],\n\t\t       qw(Jan Feb Mar Apr May Jun\n\t\t\t  Jul Aug Sep Oct Nov Dec)[$localtm[4]],\n\t\t       $localtm[5]+1900,\n\t\t       $localtm[2],\n\t\t       $localtm[1],\n\t\t       $localtm[0],\n\t\t       ($offset >= 0) ? '+' : '-',\n\t\t       abs($offhour),\n\t\t       $offmin,\n\t\t       );\n}\n\nmy $have_email_valid = eval { require Email::Valid; 1 };\nmy $smtp;\nmy $auth;\n\nsub unique_email_list(@);\nsub cleanup_compose_files();\n\n# Constants (essentially)\nmy $compose_filename = \".msg.$$\";\n\n# Variables we fill in automatically, or via prompting:\nmy (@to,@cc,@initial_cc,@bcclist,@xh,\n\t$initial_reply_to,$initial_subject,@files,$author,$sender,$smtp_authpass,$compose,$time);\n\nmy $envelope_sender;\n\n# Example reply to:\n#$initial_reply_to = ''; #<20050203173208.GA23964@foobar.com>';\n\nmy $repo = eval { Git->repository() };\nmy @repo = $repo ? ($repo) : ();\nmy $term = eval {\n\t$ENV{\"GIT_SEND_EMAIL_NOTTY\"}\n\t\t? new Term::ReadLine 'git-send-email', \\*STDIN, \\*STDOUT\n\t\t: new Term::ReadLine 'git-send-email';\n};\nif ($@) {\n\t$term = new FakeTerm \"$@: going non-interactive\";\n}\n\n# Behavior modification variables\nmy ($quiet, $dry_run) = (0, 0);\n\n# Variables with corresponding config settings\nmy ($thread, $chain_reply_to, $suppress_from, $signed_off_by_cc, $cc_cmd);\nmy ($smtp_server, $smtp_server_port, $smtp_authuser, $smtp_encryption);\nmy ($identity, $aliasfiletype, @alias_files, @smtp_host_parts);\nmy ($validate);\nmy (@suppress_cc);\n\nmy %config_bool_settings = (\n    \"thread\" => [\\$thread, 1],\n    \"chainreplyto\" => [\\$chain_reply_to, 1],\n    \"suppressfrom\" => [\\$suppress_from, undef],\n    \"signedoffbycc\" => [\\$signed_off_by_cc, undef],\n    \"signedoffcc\" => [\\$signed_off_by_cc, undef],      # Deprecated\n    \"validate\" => [\\$validate, 1],\n);\n\nmy %config_settings = (\n    \"smtpserver\" => \\$smtp_server,\n    \"smtpserverport\" => \\$smtp_server_port,\n    \"smtpuser\" => \\$smtp_authuser,\n    \"smtppass\" => \\$smtp_authpass,\n    \"to\" => \\@to,\n    \"cc\" => \\@initial_cc,\n    \"cccmd\" => \\$cc_cmd,\n    \"aliasfiletype\" => \\$aliasfiletype,\n    \"bcc\" => \\@bcclist,\n    \"aliasesfile\" => \\@alias_files,\n    \"suppresscc\" => \\@suppress_cc,\n    \"envelopesender\" => \\$envelope_sender,\n);\n\n# Handle Uncouth Termination\nsub signal_handler {\n\n\t# Make text normal\n\tprint color(\"reset\"), \"\\n\";\n\n\t# SMTP password masked\n\tsystem \"stty echo\";\n\n\t# tmp files from --compose\n\tif (-e $compose_filename) {\n\t\tprint \"'$compose_filename' contains an intermediate version of the email you were composing.\\n\";\n\t}\n\tif (-e ($compose_filename . \".final\")) {\n\t\tprint \"'$compose_filename.final' contains the composed email.\\n\"\n\t}\n\n\texit;\n};\n\n$SIG{TERM} = \\&signal_handler;\n$SIG{INT}  = \\&signal_handler;\n\n# Begin by accumulating all the variables (defined above), that we will end up\n# needing, first, from the command line:\n\nmy $rc = GetOptions(\"sender|from=s\" => \\$sender,\n                    \"in-reply-to=s\" => \\$initial_reply_to,\n\t\t    \"subject=s\" => \\$initial_subject,\n\t\t    \"to=s\" => \\@to,\n\t\t    \"cc=s\" => \\@initial_cc,\n\t\t    \"bcc=s\" => \\@bcclist,\n\t\t    \"chain-reply-to!\" => \\$chain_reply_to,\n\t\t    \"smtp-server=s\" => \\$smtp_server,\n\t\t    \"smtp-server-port=s\" => \\$smtp_server_port,\n\t\t    \"smtp-user=s\" => \\$smtp_authuser,\n\t\t    \"smtp-pass:s\" => \\$smtp_authpass,\n\t\t    \"smtp-ssl\" => sub { $smtp_encryption = 'ssl' },\n\t\t    \"smtp-encryption=s\" => \\$smtp_encryption,\n\t\t    \"identity=s\" => \\$identity,\n\t\t    \"compose\" => \\$compose,\n\t\t    \"quiet\" => \\$quiet,\n\t\t    \"cc-cmd=s\" => \\$cc_cmd,\n\t\t    \"suppress-from!\" => \\$suppress_from,\n\t\t    \"suppress-cc=s\" => \\@suppress_cc,\n\t\t    \"signed-off-cc|signed-off-by-cc!\" => \\$signed_off_by_cc,\n\t\t    \"dry-run\" => \\$dry_run,\n\t\t    \"envelope-sender=s\" => \\$envelope_sender,\n\t\t    \"thread!\" => \\$thread,\n\t\t    \"validate!\" => \\$validate,\n\t );\n\nunless ($rc) {\n    usage();\n}\n\n# Now, let's fill any that aren't set in with defaults:\n\nsub read_config {\n\tmy ($prefix) = @_;\n\n\tforeach my $setting (keys %config_bool_settings) {\n\t\tmy $target = $config_bool_settings{$setting}->[0];\n\t\t$$target = Git::config_bool(@repo, \"$prefix.$setting\") unless (defined $$target);\n\t}\n\n\tforeach my $setting (keys %config_settings) {\n\t\tmy $target = $config_settings{$setting};\n\t\tif (ref($target) eq \"ARRAY\") {\n\t\t\tunless (@$target) {\n\t\t\t\tmy @values = Git::config(@repo, \"$prefix.$setting\");\n\t\t\t\t@$target = @values if (@values && defined $values[0]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t$$target = Git::config(@repo, \"$prefix.$setting\") unless (defined $$target);\n\t\t}\n\t}\n\n\tif (!defined $smtp_encryption) {\n\t\tmy $enc = Git::config(@repo, \"$prefix.smtpencryption\");\n\t\tif (defined $enc) {\n\t\t\t$smtp_encryption = $enc;\n\t\t} elsif (Git::config_bool(@repo, \"$prefix.smtpssl\")) {\n\t\t\t$smtp_encryption = 'ssl';\n\t\t}\n\t}\n}\n\n# read configuration from [sendemail \"$identity\"], fall back on [sendemail]\n$identity = Git::config(@repo, \"sendemail.identity\") unless (defined $identity);\nread_config(\"sendemail.$identity\") if (defined $identity);\nread_config(\"sendemail\");\n\n# fall back on builtin bool defaults\nforeach my $setting (values %config_bool_settings) {\n\t${$setting->[0]} = $setting->[1] unless (defined (${$setting->[0]}));\n}\n\n# 'default' encryption is none -- this only prevents a warning\n$smtp_encryption = '' unless (defined $smtp_encryption);\n\n# Set CC suppressions\nmy(%suppress_cc);\nif (@suppress_cc) {\n\tforeach my $entry (@suppress_cc) {\n\t\tdie \"Unknown --suppress-cc field: '$entry'\\n\"\n\t\t\tunless $entry =~ /^(all|cccmd|cc|author|self|sob)$/;\n\t\t$suppress_cc{$entry} = 1;\n\t}\n}\n\nif ($suppress_cc{'all'}) {\n\tforeach my $entry (qw (ccmd cc author self sob)) {\n\t\t$suppress_cc{$entry} = 1;\n\t}\n\tdelete $suppress_cc{'all'};\n}\n\n# If explicit old-style ones are specified, they trump --suppress-cc.\n$suppress_cc{'self'} = $suppress_from if defined $suppress_from;\n$suppress_cc{'sob'} = !$signed_off_by_cc if defined $signed_off_by_cc;\n\n# Debugging, print out the suppressions.\nif (0) {\n\tprint \"suppressions:\\n\";\n\tforeach my $entry (keys %suppress_cc) {\n\t\tprintf \"  %-5s -> $suppress_cc{$entry}\\n\", $entry;\n\t}\n}\n\nmy ($repoauthor, $repocommitter);\n($repoauthor) = Git::ident_person(@repo, 'author');\n($repocommitter) = Git::ident_person(@repo, 'committer');\n\n# Verify the user input\n\nforeach my $entry (@to) {\n\tdie \"Comma in --to entry: $entry'\\n\" unless $entry !~ m/,/;\n}\n\nforeach my $entry (@initial_cc) {\n\tdie \"Comma in --cc entry: $entry'\\n\" unless $entry !~ m/,/;\n}\n\nforeach my $entry (@bcclist) {\n\tdie \"Comma in --bcclist entry: $entry'\\n\" unless $entry !~ m/,/;\n}\n\nmy %aliases;\nmy %parse_alias = (\n\t# multiline formats can be supported in the future\n\tmutt => sub { my $fh = shift; while (<$fh>) {\n\t\tif (/^\\s*alias\\s+(\\S+)\\s+(.*)$/) {\n\t\t\tmy ($alias, $addr) = ($1, $2);\n\t\t\t$addr =~ s/#.*$//; # mutt allows # comments\n\t\t\t # commas delimit multiple addresses\n\t\t\t$aliases{$alias} = [ split(/\\s*,\\s*/, $addr) ];\n\t\t}}},\n\tmailrc => sub { my $fh = shift; while (<$fh>) {\n\t\tif (/^alias\\s+(\\S+)\\s+(.*)$/) {\n\t\t\t# spaces delimit multiple addresses\n\t\t\t$aliases{$1} = [ split(/\\s+/, $2) ];\n\t\t}}},\n\tpine => sub { my $fh = shift; my $f='\\t[^\\t]*';\n\t        for (my $x = ''; defined($x); $x = $_) {\n\t\t\tchomp $x;\n\t\t        $x .= $1 while(defined($_ = <$fh>) && /^ +(.*)$/);\n\t\t\t$x =~ /^(\\S+)$f\\t\\(?([^\\t]+?)\\)?(:?$f){0,2}$/ or next;\n\t\t\t$aliases{$1} = [ split(/\\s*,\\s*/, $2) ];\n\t\t}},\n\tgnus => sub { my $fh = shift; while (<$fh>) {\n\t\tif (/\\(define-mail-alias\\s+\"(\\S+?)\"\\s+\"(\\S+?)\"\\)/) {\n\t\t\t$aliases{$1} = [ $2 ];\n\t\t}}}\n);\n\nif (@alias_files and $aliasfiletype and defined $parse_alias{$aliasfiletype}) {\n\tforeach my $file (@alias_files) {\n\t\topen my $fh, '<', $file or die \"opening $file: $!\\n\";\n\t\t$parse_alias{$aliasfiletype}->($fh);\n\t\tclose $fh;\n\t}\n}\n\n($sender) = expand_aliases($sender) if defined $sender;\n\n# Now that all the defaults are set, process the rest of the command line\n# arguments and collect up the files that need to be processed.\nfor my $f (@ARGV) {\n\tif (-d $f) {\n\t\topendir(DH,$f)\n\t\t\tor die \"Failed to opendir $f: $!\";\n\n\t\tpush @files, grep { -f $_ } map { +$f . \"/\" . $_ }\n\t\t\t\tsort readdir(DH);\n\t\tclosedir(DH);\n\t} elsif (-f $f or -p $f) {\n\t\tpush @files, $f;\n\t} else {\n\t\tprint STDERR \"Skipping $f - not found.\\n\";\n\t}\n}\n\nif ($validate) {\n\tforeach my $f (@files) {\n\t\tunless (-p $f) {\n\t\t\tmy $error = validate_patch($f);\n\t\t\t$error and die \"fatal: $f: $error\\nwarning: no patches were sent\\n\";\n\t\t}\n\t}\n}\n\nif (@files) {\n\tunless ($quiet) {\n\t\tprint $_,\"\\n\" for (@files);\n\t}\n} else {\n\tprint STDERR \"\\nNo patch files specified!\\n\\n\";\n\tusage();\n}\n\nmy $prompting = 0;\nif (!defined $sender) {\n\t$sender = $repoauthor || $repocommitter || '';\n\n\twhile (1) {\n\t\t$_ = $term->readline(\"Who should the emails appear to be from? [$sender] \");\n\t\tlast if defined $_;\n\t\tprint \"\\n\";\n\t}\n\n\t$sender = $_ if ($_);\n\tprint \"Emails will be sent from: \", $sender, \"\\n\";\n\t$prompting++;\n}\n\nif (!@to) {\n\n\n\twhile (1) {\n\t\t$_ = $term->readline(\"Who should the emails be sent to? \", \"\");\n\t\tlast if defined $_;\n\t\tprint \"\\n\";\n\t}\n\n\tmy $to = $_;\n\tpush @to, split /,\\s*/, $to;\n\t$prompting++;\n}\n\nsub expand_aliases {\n\tmy @cur = @_;\n\tmy @last;\n\tdo {\n\t\t@last = @cur;\n\t\t@cur = map { $aliases{$_} ? @{$aliases{$_}} : $_ } @last;\n\t} while (join(',',@cur) ne join(',',@last));\n\treturn @cur;\n}\n\n@to = expand_aliases(@to);\n@to = (map { sanitize_address($_) } @to);\n@initial_cc = expand_aliases(@initial_cc);\n@bcclist = expand_aliases(@bcclist);\n\nif (!defined $initial_subject && $compose) {\n\twhile (1) {\n\t\t$_ = $term->readline(\"What subject should the initial email start with? \", $initial_subject);\n\t\tlast if defined $_;\n\t\tprint \"\\n\";\n\t}\n\n\t$initial_subject = $_;\n\t$prompting++;\n}\n\nif ($thread && !defined $initial_reply_to && $prompting) {\n\twhile (1) {\n\t\t$_= $term->readline(\"Message-ID to be used as In-Reply-To for the first email? \", $initial_reply_to);\n\t\tlast if defined $_;\n\t\tprint \"\\n\";\n\t}\n\n\t$initial_reply_to = $_;\n}\nif (defined $initial_reply_to) {\n\t$initial_reply_to =~ s/^\\s*<?//;\n\t$initial_reply_to =~ s/>?\\s*$//;\n\t$initial_reply_to = \"<$initial_reply_to>\" if $initial_reply_to ne '';\n}\n\nif (!defined $smtp_server) {\n\tforeach (qw( /usr/sbin/sendmail /usr/lib/sendmail )) {\n\t\tif (-x $_) {\n\t\t\t$smtp_server = $_;\n\t\t\tlast;\n\t\t}\n\t}\n\t$smtp_server ||= 'localhost'; # could be 127.0.0.1, too... *shrug*\n}\n\nif ($compose) {\n\t# Note that this does not need to be secure, but we will make a small\n\t# effort to have it be unique\n\topen(C,\">\",$compose_filename)\n\t\tor die \"Failed to open for writing $compose_filename: $!\";\n\tprint C \"From $sender # This line is ignored.\\n\";\n\tprintf C \"Subject: %s\\n\\n\", $initial_subject;\n\tprintf C <<EOT;\nGIT: Please enter your email below.\nGIT: Lines beginning in \"GIT: \" will be removed.\nGIT: Consider including an overall diffstat or table of contents\nGIT: for the patch you are writing.\n\nEOT\n\tclose(C);\n\n\tmy $editor = $ENV{GIT_EDITOR} || Git::config(@repo, \"core.editor\") || $ENV{VISUAL} || $ENV{EDITOR} || \"vi\";\n\tsystem('sh', '-c', $editor.' \"$@\"', $editor, $compose_filename);\n\n\topen(C2,\">\",$compose_filename . \".final\")\n\t\tor die \"Failed to open $compose_filename.final : \" . $!;\n\n\topen(C,\"<\",$compose_filename)\n\t\tor die \"Failed to open $compose_filename : \" . $!;\n\n\tmy $need_8bit_cte = file_has_nonascii($compose_filename);\n\tmy $in_body = 0;\n\twhile(<C>) {\n\t\tnext if m/^GIT: /;\n\t\tif (!$in_body && /^\\n$/) {\n\t\t\t$in_body = 1;\n\t\t\tif ($need_8bit_cte) {\n\t\t\t\tprint C2 \"MIME-Version: 1.0\\n\",\n\t\t\t\t\t \"Content-Type: text/plain; \",\n\t\t\t\t\t   \"charset=utf-8\\n\",\n\t\t\t\t\t \"Content-Transfer-Encoding: 8bit\\n\";\n\t\t\t}\n\t\t}\n\t\tif (!$in_body && /^MIME-Version:/i) {\n\t\t\t$need_8bit_cte = 0;\n\t\t}\n\t\tif (!$in_body && /^Subject: ?(.*)/i) {\n\t\t\tmy $subject = $1;\n\t\t\t$_ = \"Subject: \" .\n\t\t\t\t($subject =~ /[^[:ascii:]]/ ?\n\t\t\t\t quote_rfc2047($subject) :\n\t\t\t\t $subject) .\n\t\t\t\t\"\\n\";\n\t\t}\n\t\tprint C2 $_;\n\t}\n\tclose(C);\n\tclose(C2);\n\n\twhile (1) {\n\t\t$_ = $term->readline(\"Send this email? (y|n) \");\n\t\tlast if defined $_;\n\t\tprint \"\\n\";\n\t}\n\n\tif (uc substr($_,0,1) ne 'Y') {\n\t\tcleanup_compose_files();\n\t\texit(0);\n\t}\n\n\t@files = ($compose_filename . \".final\", @files);\n}\n\n# Variables we set as part of the loop over files\nour ($message_id, %mail, $subject, $reply_to, $references, $message);\n\nsub extract_valid_address {\n\tmy $address = shift;\n\tmy $local_part_regexp = '[^<>\"\\s@]+';\n\tmy $domain_regexp = '[^.<>\"\\s@]+(?:\\.[^.<>\"\\s@]+)+';\n\n\t# check for a local address:\n\treturn $address if ($address =~ /^($local_part_regexp)$/);\n\n\t$address =~ s/^\\s*<(.*)>\\s*$/$1/;\n\tif ($have_email_valid) {\n\t\treturn scalar Email::Valid->address($address);\n\t} else {\n\t\t# less robust/correct than the monster regexp in Email::Valid,\n\t\t# but still does a 99% job, and one less dependency\n\t\t$address =~ /($local_part_regexp\\@$domain_regexp)/;\n\t\treturn $1;\n\t}\n}\n\n# Usually don't need to change anything below here.\n\n# we make a \"fake\" message id by taking the current number\n# of seconds since the beginning of Unix time and tacking on\n# a random number to the end, in case we are called quicker than\n# 1 second since the last time we were called.\n\n# We'll setup a template for the message id, using the \"from\" address:\n\nmy ($message_id_stamp, $message_id_serial);\nsub make_message_id\n{\n\tmy $uniq;\n\tif (!defined $message_id_stamp) {\n\t\t$message_id_stamp = sprintf(\"%s-%s\", time, $$);\n\t\t$message_id_serial = 0;\n\t}\n\t$message_id_serial++;\n\t$uniq = \"$message_id_stamp-$message_id_serial\";\n\n\tmy $du_part;\n\tfor ($sender, $repocommitter, $repoauthor) {\n\t\t$du_part = extract_valid_address(sanitize_address($_));\n\t\tlast if (defined $du_part and $du_part ne '');\n\t}\n\tif (not defined $du_part or $du_part eq '') {\n\t\tuse Sys::Hostname qw();\n\t\t$du_part = 'user@' . Sys::Hostname::hostname();\n\t}\n\tmy $message_id_template = \"<%s-git-send-email-%s>\";\n\t$message_id = sprintf($message_id_template, $uniq, $du_part);\n\t#print \"new message id = $message_id\\n\"; # Was useful for debugging\n}\n\n\n\n$time = time - scalar $#files;\n\nsub unquote_rfc2047 {\n\tlocal ($_) = @_;\n\tmy $encoding;\n\tif (s/=\\?([^?]+)\\?q\\?(.*)\\?=/$2/g) {\n\t\t$encoding = $1;\n\t\ts/_/ /g;\n\t\ts/=([0-9A-F]{2})/chr(hex($1))/eg;\n\t}\n\treturn wantarray ? ($_, $encoding) : $_;\n}\n\nsub quote_rfc2047 {\n\tlocal $_ = shift;\n\tmy $encoding = shift || 'utf-8';\n\ts/([^-a-zA-Z0-9!*+\\/])/sprintf(\"=%02X\", ord($1))/eg;\n\ts/(.*)/=\\?$encoding\\?q\\?$1\\?=/;\n\treturn $_;\n}\n\n# use the simplest quoting being able to handle the recipient\nsub sanitize_address\n{\n\tmy ($recipient) = @_;\n\tmy ($recipient_name, $recipient_addr) = ($recipient =~ /^(.*?)\\s*(<.*)/);\n\n\tif (not $recipient_name) {\n\t\treturn \"$recipient\";\n\t}\n\n\t# if recipient_name is already quoted, do nothing\n\tif ($recipient_name =~ /^(\".*\"|=\\?utf-8\\?q\\?.*\\?=)$/) {\n\t\treturn $recipient;\n\t}\n\n\t# rfc2047 is needed if a non-ascii char is included\n\tif ($recipient_name =~ /[^[:ascii:]]/) {\n\t\t$recipient_name = quote_rfc2047($recipient_name);\n\t}\n\n\t# double quotes are needed if specials or CTLs are included\n\telsif ($recipient_name =~ /[][()<>@,;:\\\\\".\\000-\\037\\177]/) {\n\t\t$recipient_name =~ s/([\"\\\\\\r])/\\\\$1/g;\n\t\t$recipient_name = \"\\\"$recipient_name\\\"\";\n\t}\n\n\treturn \"$recipient_name $recipient_addr\";\n\n}\n\nsub send_message\n{\n\tmy @recipients = unique_email_list(@to);\n\t@cc = (grep { my $cc = extract_valid_address($_);\n\t\t      not grep { $cc eq $_ } @recipients\n\t\t    }\n\t       map { sanitize_address($_) }\n\t       @cc);\n\tmy $to = join (\",\\n\\t\", @recipients);\n\t@recipients = unique_email_list(@recipients,@cc,@bcclist);\n\t@recipients = (map { extract_valid_address($_) } @recipients);\n\tmy $date = format_2822_time($time++);\n\tmy $gitversion = '@@GIT_VERSION@@';\n\tif ($gitversion =~ m/..GIT_VERSION../) {\n\t    $gitversion = Git::version();\n\t}\n\n\tmy $cc = join(\", \", unique_email_list(@cc));\n\tmy $ccline = \"\";\n\tif ($cc ne '') {\n\t\t$ccline = \"\\nCc: $cc\";\n\t}\n\tmy $sanitized_sender = sanitize_address($sender);\n\tmake_message_id() unless defined($message_id);\n\n\tmy $header = \"From: $sanitized_sender\nTo: $to${ccline}\nSubject: $subject\nDate: $date\nMessage-Id: $message_id\nX-Mailer: git-send-email $gitversion\n\";\n\tif ($thread && $reply_to) {\n\n\t\t$header .= \"In-Reply-To: $reply_to\\n\";\n\t\t$header .= \"References: $references\\n\";\n\t}\n\tif (@xh) {\n\t\t$header .= join(\"\\n\", @xh) . \"\\n\";\n\t}\n\n\tmy @sendmail_parameters = ('-i', @recipients);\n\tmy $raw_from = $sanitized_sender;\n\t$raw_from = $envelope_sender if (defined $envelope_sender);\n\t$raw_from = extract_valid_address($raw_from);\n\tunshift (@sendmail_parameters,\n\t\t\t'-f', $raw_from) if(defined $envelope_sender);\n\n\tif ($dry_run) {\n\t\t# We don't want to send the email.\n\t} elsif ($smtp_server =~ m#^/#) {\n\t\tmy $pid = open my $sm, '|-';\n\t\tdefined $pid or die $!;\n\t\tif (!$pid) {\n\t\t\texec($smtp_server, @sendmail_parameters) or die $!;\n\t\t}\n\t\tprint $sm \"$header\\n$message\";\n\t\tclose $sm or die $?;\n\t} else {\n\n\t\tif (!defined $smtp_server) {\n\t\t\tdie \"The required SMTP server is not properly defined.\"\n\t\t}\n\n\t\tif ($smtp_encryption eq 'ssl') {\n\t\t\t$smtp_server_port ||= 465; # ssmtp\n\t\t\trequire Net::SMTP::SSL;\n\t\t\t$smtp ||= Net::SMTP::SSL->new($smtp_server, Port => $smtp_server_port);\n\t\t}\n\t\telse {\n\t\t\trequire Net::SMTP;\n\t\t\t$smtp ||= Net::SMTP->new((defined $smtp_server_port)\n\t\t\t\t\t\t ? \"$smtp_server:$smtp_server_port\"\n\t\t\t\t\t\t : $smtp_server);\n\t\t\tif ($smtp_encryption eq 'tls') {\n\t\t\t\trequire Net::SMTP::SSL;\n\t\t\t\t$smtp->command('STARTTLS');\n\t\t\t\t$smtp->response();\n\t\t\t\tif ($smtp->code == 220) {\n\t\t\t\t\t$smtp = Net::SMTP::SSL->start_SSL($smtp)\n\t\t\t\t\t\tor die \"STARTTLS failed! \".$smtp->message;\n\t\t\t\t\t$smtp_encryption = '';\n\t\t\t\t\t# Send EHLO again to receive fresh\n\t\t\t\t\t# supported commands\n\t\t\t\t\t$smtp->hello();\n\t\t\t\t} else {\n\t\t\t\t\tdie \"Server does not support STARTTLS! \".$smtp->message;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!$smtp) {\n\t\t\tdie \"Unable to initialize SMTP properly.  Is there something wrong with your config?\";\n\t\t}\n\n\t\tif (defined $smtp_authuser) {\n\n\t\t\tif (!defined $smtp_authpass) {\n\n\t\t\t\tsystem \"stty -echo\";\n\n\t\t\t\tdo {\n\t\t\t\t\tprint \"Password: \";\n\t\t\t\t\t$_ = <STDIN>;\n\t\t\t\t\tprint \"\\n\";\n\t\t\t\t} while (!defined $_);\n\n\t\t\t\tchomp($smtp_authpass = $_);\n\n\t\t\t\tsystem \"stty echo\";\n\t\t\t}\n\n\t\t\t$auth ||= $smtp->auth( $smtp_authuser, $smtp_authpass ) or die $smtp->message;\n\t\t}\n\n\t\t$smtp->mail( $raw_from ) or die $smtp->message;\n\t\t$smtp->to( @recipients ) or die $smtp->message;\n\t\t$smtp->data or die $smtp->message;\n\t\t$smtp->datasend(\"$header\\n$message\") or die $smtp->message;\n\t\t$smtp->dataend() or die $smtp->message;\n\t\t$smtp->ok or die \"Failed to send $subject\\n\".$smtp->message;\n\t}\n\tif ($quiet) {\n\t\tprintf (($dry_run ? \"Dry-\" : \"\").\"Sent %s\\n\", $subject);\n\t} else {\n\t\tprint (($dry_run ? \"Dry-\" : \"\").\"OK. Log says:\\n\");\n\t\tif ($smtp_server !~ m#^/#) {\n\t\t\tprint \"Server: $smtp_server\\n\";\n\t\t\tprint \"MAIL FROM:<$raw_from>\\n\";\n\t\t\tprint \"RCPT TO:\".join(',',(map { \"<$_>\" } @recipients)).\"\\n\";\n\t\t} else {\n\t\t\tprint \"Sendmail: $smtp_server \".join(' ',@sendmail_parameters).\"\\n\";\n\t\t}\n\t\tprint $header, \"\\n\";\n\t\tif ($smtp) {\n\t\t\tprint \"Result: \", $smtp->code, ' ',\n\t\t\t\t($smtp->message =~ /\\n([^\\n]+\\n)$/s), \"\\n\";\n\t\t} else {\n\t\t\tprint \"Result: OK\\n\";\n\t\t}\n\t}\n}\n\n$reply_to = $initial_reply_to;\n$references = $initial_reply_to || '';\n$subject = $initial_subject;\n\nforeach my $t (@files) {\n\topen(F,\"<\",$t) or die \"can't open file $t\";\n\n\tmy $author = undef;\n\tmy $author_encoding;\n\tmy $has_content_type;\n\tmy $body_encoding;\n\t@cc = @initial_cc;\n\t@xh = ();\n\tmy $input_format = undef;\n\tmy $header_done = 0;\n\t$message = \"\";\n\twhile(<F>) {\n\t\tif (!$header_done) {\n\t\t\tif (/^From /) {\n\t\t\t\t$input_format = 'mbox';\n\t\t\t\tnext;\n\t\t\t}\n\t\t\tchomp;\n\t\t\tif (!defined $input_format && /^[-A-Za-z]+:\\s/) {\n\t\t\t\t$input_format = 'mbox';\n\t\t\t}\n\n\t\t\tif (defined $input_format && $input_format eq 'mbox') {\n\t\t\t\tif (/^Subject:\\s+(.*)$/) {\n\t\t\t\t\t$subject = $1;\n\n\t\t\t\t} elsif (/^(Cc|From):\\s+(.*)$/) {\n\t\t\t\t\tif (unquote_rfc2047($2) eq $sender) {\n\t\t\t\t\t\tnext if ($suppress_cc{'self'});\n\t\t\t\t\t}\n\t\t\t\t\telsif ($1 eq 'From') {\n\t\t\t\t\t\t($author, $author_encoding)\n\t\t\t\t\t\t  = unquote_rfc2047($2);\n\t\t\t\t\t\tnext if ($suppress_cc{'author'});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext if ($suppress_cc{'cc'});\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"(mbox) Adding cc: %s from line '%s'\\n\",\n\t\t\t\t\t\t$2, $_) unless $quiet;\n\t\t\t\t\tpush @cc, $2;\n\t\t\t\t}\n\t\t\t\telsif (/^Content-type:/i) {\n\t\t\t\t\t$has_content_type = 1;\n\t\t\t\t\tif (/charset=\"?([^ \"]+)/) {\n\t\t\t\t\t\t$body_encoding = $1;\n\t\t\t\t\t}\n\t\t\t\t\tpush @xh, $_;\n\t\t\t\t}\n\t\t\t\telsif (/^Message-Id: (.*)/i) {\n\t\t\t\t\t$message_id = $1;\n\t\t\t\t}\n\t\t\t\telsif (!/^Date:\\s/ && /^[-A-Za-z]+:\\s+\\S/) {\n\t\t\t\t\tpush @xh, $_;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t# In the traditional\n\t\t\t\t# \"send lots of email\" format,\n\t\t\t\t# line 1 = cc\n\t\t\t\t# line 2 = subject\n\t\t\t\t# So let's support that, too.\n\t\t\t\t$input_format = 'lots';\n\t\t\t\tif (@cc == 0 && !$suppress_cc{'cc'}) {\n\t\t\t\t\tprintf(\"(non-mbox) Adding cc: %s from line '%s'\\n\",\n\t\t\t\t\t\t$_, $_) unless $quiet;\n\n\t\t\t\t\tpush @cc, $_;\n\n\t\t\t\t} elsif (!defined $subject) {\n\t\t\t\t\t$subject = $_;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t# A whitespace line will terminate the headers\n\t\t\tif (m/^\\s*$/) {\n\t\t\t\t$header_done = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t$message .=  $_;\n\t\t\tif (/^(Signed-off-by|Cc): (.*)$/i) {\n\t\t\t\tnext if ($suppress_cc{'sob'});\n\t\t\t\tchomp;\n\t\t\t\tmy $c = $2;\n\t\t\t\tchomp $c;\n\t\t\t\tnext if ($c eq $sender and $suppress_cc{'self'});\n\t\t\t\tpush @cc, $c;\n\t\t\t\tprintf(\"(sob) Adding cc: %s from line '%s'\\n\",\n\t\t\t\t\t$c, $_) unless $quiet;\n\t\t\t}\n\t\t}\n\t}\n\tclose F;\n\n\tif (defined $cc_cmd && !$suppress_cc{'cccmd'}) {\n\t\topen(F, \"$cc_cmd $t |\")\n\t\t\tor die \"(cc-cmd) Could not execute '$cc_cmd'\";\n\t\twhile(<F>) {\n\t\t\tmy $c = $_;\n\t\t\t$c =~ s/^\\s*//g;\n\t\t\t$c =~ s/\\n$//g;\n\t\t\tnext if ($c eq $sender and $suppress_from);\n\t\t\tpush @cc, $c;\n\t\t\tprintf(\"(cc-cmd) Adding cc: %s from: '%s'\\n\",\n\t\t\t\t$c, $cc_cmd) unless $quiet;\n\t\t}\n\t\tclose F\n\t\t\tor die \"(cc-cmd) failed to close pipe to '$cc_cmd'\";\n\t}\n\n\tif (defined $author) {\n\t\t$message = \"From: $author\\n\\n$message\";\n\t\tif (defined $author_encoding) {\n\t\t\tif ($has_content_type) {\n\t\t\t\tif ($body_encoding eq $author_encoding) {\n\t\t\t\t\t# ok, we already have the right encoding\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t# uh oh, we should re-encode\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpush @xh,\n\t\t\t\t  'MIME-Version: 1.0',\n\t\t\t\t  \"Content-Type: text/plain; charset=$author_encoding\",\n\t\t\t\t  'Content-Transfer-Encoding: 8bit';\n\t\t\t}\n\t\t}\n\t}\n\n\tsend_message();\n\n\t# set up for the next message\n\tif ($chain_reply_to || !defined $reply_to || length($reply_to) == 0) {\n\t\t$reply_to = $message_id;\n\t\tif (length $references > 0) {\n\t\t\t$references .= \"\\n $message_id\";\n\t\t} else {\n\t\t\t$references = \"$message_id\";\n\t\t}\n\t}\n\t$message_id = undef;\n}\n\nif ($compose) {\n\tcleanup_compose_files();\n}\n\nsub cleanup_compose_files() {\n\tunlink($compose_filename, $compose_filename . \".final\");\n\n}\n\n$smtp->quit if $smtp;\n\nsub unique_email_list(@) {\n\tmy %seen;\n\tmy @emails;\n\n\tforeach my $entry (@_) {\n\t\tif (my $clean = extract_valid_address($entry)) {\n\t\t\t$seen{$clean} ||= 0;\n\t\t\tnext if $seen{$clean}++;\n\t\t\tpush @emails, $entry;\n\t\t} else {\n\t\t\tprint STDERR \"W: unable to extract a valid address\",\n\t\t\t\t\t\" from: $entry\\n\";\n\t\t}\n\t}\n\treturn @emails;\n}\n\nsub validate_patch {\n\tmy $fn = shift;\n\topen(my $fh, '<', $fn)\n\t\tor die \"unable to open $fn: $!\\n\";\n\twhile (my $line = <$fh>) {\n\t\tif (length($line) > 998) {\n\t\t\treturn \"$.: patch contains a line longer than 998 characters\";\n\t\t}\n\t}\n\treturn undef;\n}\n\nsub file_has_nonascii {\n\tmy $fn = shift;\n\topen(my $fh, '<', $fn)\n\t\tor die \"unable to open $fn: $!\\n\";\n\twhile (my $line = <$fh>) {\n\t\treturn 1 if $line =~ /[^[:ascii:]]/;\n\t}\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "007e2c6ee12db18152884c5ac9aa26eff224e36e",
  "sha1_ok": true,
  "size": 26538
}
