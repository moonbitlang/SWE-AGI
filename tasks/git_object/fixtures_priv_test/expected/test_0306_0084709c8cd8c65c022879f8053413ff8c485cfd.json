{
  "content": {
    "base64": "IyEvdXNyL2Jpbi9lbnYgcHl0aG9uCiMKIyBDb3B5cmlnaHQgKGMpIDIwMTIgRmVsaXBlIENvbnRyZXJhcwojCgojIEluc3BpcmVkIGJ5IFJvY2NvIFJ1dHRlJ3MgaGctZmFzdC1leHBvcnQKCiMgSnVzdCBjb3B5IHRvIHlvdXIgfi9iaW4sIG9yIGFueXdoZXJlIGluIHlvdXIgJFBBVEguCiMgVGhlbiB5b3UgY2FuIGNsb25lIHdpdGg6CiMgZ2l0IGNsb25lIGhnOjovcGF0aC90by9tZXJjdXJpYWwvcmVwby8KIwojIEZvciByZW1vdGUgcmVwb3NpdG9yaWVzIGEgbG9jYWwgY2xvbmUgaXMgc3RvcmVkIGluCiMgIiRHSVRfRElSL2hnL29yaWdpbi9jbG9uZS8uaGcvIi4KCmZyb20gbWVyY3VyaWFsIGltcG9ydCBoZywgdWksIGJvb2ttYXJrcywgY29udGV4dCwgdXRpbCwgZW5jb2RpbmcsIG5vZGUsIGVycm9yCgppbXBvcnQgcmUKaW1wb3J0IHN5cwppbXBvcnQgb3MKaW1wb3J0IGpzb24KaW1wb3J0IHNodXRpbAppbXBvcnQgc3VicHJvY2VzcwppbXBvcnQgdXJsbGliCmltcG9ydCBhdGV4aXQKaW1wb3J0IHVybHBhcnNlCgojCiMgSWYgeW91IHdhbnQgdG8gc3dpdGNoIHRvIGhnLWdpdCBjb21wYXRpYmlsaXR5IG1vZGU6CiMgZ2l0IGNvbmZpZyAtLWdsb2JhbCByZW1vdGUtaGcuaGctZ2l0LWNvbXBhdCB0cnVlCiMKIyBJZiB5b3UgYXJlIG5vdCBpbiBoZy1naXQtY29tcGF0IG1vZGUgYW5kIHdhbnQgdG8gZGlzYWJsZSB0aGUgdHJhY2tpbmcgb2YKIyBuYW1lZCBicmFuY2hlczoKIyBnaXQgY29uZmlnIC0tZ2xvYmFsIHJlbW90ZS1oZy50cmFjay1icmFuY2hlcyBmYWxzZQojCiMgSWYgeW91IGRvbid0IHdhbnQgdG8gZm9yY2UgcHVzaGVzIChhbmQgdGh1cyByaXNrIGNyZWF0aW5nIG5ldyByZW1vdGUgaGVhZHMpOgojIGdpdCBjb25maWcgLS1nbG9iYWwgcmVtb3RlLWhnLmZvcmNlLXB1c2ggZmFsc2UKIwojIElmIHlvdSB3YW50IHRoZSBlcXVpdmFsZW50IG9mIGhnJ3MgY2xvbmUvcHVsbC0taW5zZWN1cmUgb3B0aW9uOgojIGdpdCBjb25maWcgcmVtb3RlLWhnLmluc2VjdXJlIHRydWUKIwojIGdpdDoKIyBTZW5zaWJsZSBkZWZhdWx0cyBmb3IgZ2l0LgojIGhnIGJvb2ttYXJrcyBhcmUgZXhwb3J0ZWQgYXMgZ2l0IGJyYW5jaGVzLCBoZyBicmFuY2hlcyBhcmUgcHJlZml4ZWQKIyB3aXRoICdicmFuY2hlcy8nLCBIRUFEIGlzIGEgc3BlY2lhbCBjYXNlLgojCiMgaGc6CiMgRW11bGF0ZSBoZy1naXQuCiMgT25seSBoZyBib29rbWFya3MgYXJlIGV4cG9ydGVkIGFzIGdpdCBicmFuY2hlcy4KIyBDb21taXRzIGFyZSBtb2RpZmllZCB0byBwcmVzZXJ2ZSBoZyBpbmZvcm1hdGlvbiBhbmQgYWxsb3cgYmlkaXJlY3Rpb25hbGl0eS4KIwoKTkFNRV9SRSA9IHJlLmNvbXBpbGUoJ14oW148Pl0rKScpCkFVVEhPUl9SRSA9IHJlLmNvbXBpbGUoJ14oW148Pl0rPyk/ID88KFtePD5dKik+JCcpCkVNQUlMX1JFID0gcmUuY29tcGlsZSgnXihbXjw+XStbXiBcXFx0PD5dKT9cXGIoPzpbIFxcdDw+XSo/KVxcYihbXiBcXHQ8Pl0rQFteIFxcdDw+XSspJykKQVVUSE9SX0hHX1JFID0gcmUuY29tcGlsZSgnXiguKj8pID88KC4qPykoPzo+KC4rKT8pPyQnKQpSQVdfQVVUSE9SX1JFID0gcmUuY29tcGlsZSgnXihcdyspICg/OiguKyk/ICk/PCguKik+IChcZCspIChbKy1dXGQrKScpCgpkZWYgZGllKG1zZywgKmFyZ3MpOgogICAgc3lzLnN0ZGVyci53cml0ZSgnRVJST1I6ICVzXG4nICUgKG1zZyAlIGFyZ3MpKQogICAgc3lzLmV4aXQoMSkKCmRlZiB3YXJuKG1zZywgKmFyZ3MpOgogICAgc3lzLnN0ZGVyci53cml0ZSgnV0FSTklORzogJXNcbicgJSAobXNnICUgYXJncykpCgpkZWYgZ2l0bW9kZShmbGFncyk6CiAgICByZXR1cm4gJ2wnIGluIGZsYWdzIGFuZCAnMTIwMDAwJyBvciAneCcgaW4gZmxhZ3MgYW5kICcxMDA3NTUnIG9yICcxMDA2NDQnCgpkZWYgZ2l0dHoodHopOgogICAgcmV0dXJuICclKzAzZCUwMmQnICUgKC10eiAvIDM2MDAsIC10eiAlIDM2MDAgLyA2MCkKCmRlZiBoZ21vZGUobW9kZSk6CiAgICBtID0geyAnMTAwNzU1JzogJ3gnLCAnMTIwMDAwJzogJ2wnIH0KICAgIHJldHVybiBtLmdldChtb2RlLCAnJykKCmRlZiBoZ2hleChub2RlKToKICAgIHJldHVybiBoZy5ub2RlLmhleChub2RlKQoKZGVmIGdldF9jb25maWcoY29uZmlnKToKICAgIGNtZCA9IFsnZ2l0JywgJ2NvbmZpZycsICctLWdldCcsIGNvbmZpZ10KICAgIHByb2Nlc3MgPSBzdWJwcm9jZXNzLlBvcGVuKGNtZCwgc3Rkb3V0PXN1YnByb2Nlc3MuUElQRSkKICAgIG91dHB1dCwgXyA9IHByb2Nlc3MuY29tbXVuaWNhdGUoKQogICAgcmV0dXJuIG91dHB1dAoKY2xhc3MgTWFya3M6CgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHBhdGgpOgogICAgICAgIHNlbGYucGF0aCA9IHBhdGgKICAgICAgICBzZWxmLnRpcHMgPSB7fQogICAgICAgIHNlbGYubWFya3MgPSB7fQogICAgICAgIHNlbGYucmV2X21hcmtzID0ge30KICAgICAgICBzZWxmLmxhc3RfbWFyayA9IDAKCiAgICAgICAgc2VsZi5sb2FkKCkKCiAgICBkZWYgbG9hZChzZWxmKToKICAgICAgICBpZiBub3Qgb3MucGF0aC5leGlzdHMoc2VsZi5wYXRoKToKICAgICAgICAgICAgcmV0dXJuCgogICAgICAgIHRtcCA9IGpzb24ubG9hZChvcGVuKHNlbGYucGF0aCkpCgogICAgICAgIHNlbGYudGlwcyA9IHRtcFsndGlwcyddCiAgICAgICAgc2VsZi5tYXJrcyA9IHRtcFsnbWFya3MnXQogICAgICAgIHNlbGYubGFzdF9tYXJrID0gdG1wWydsYXN0LW1hcmsnXQoKICAgICAgICBmb3IgcmV2LCBtYXJrIGluIHNlbGYubWFya3MuaXRlcml0ZW1zKCk6CiAgICAgICAgICAgIHNlbGYucmV2X21hcmtzW21hcmtdID0gaW50KHJldikKCiAgICBkZWYgZGljdChzZWxmKToKICAgICAgICByZXR1cm4geyAndGlwcyc6IHNlbGYudGlwcywgJ21hcmtzJzogc2VsZi5tYXJrcywgJ2xhc3QtbWFyaycgOiBzZWxmLmxhc3RfbWFyayB9CgogICAgZGVmIHN0b3JlKHNlbGYpOgogICAgICAgIGpzb24uZHVtcChzZWxmLmRpY3QoKSwgb3BlbihzZWxmLnBhdGgsICd3JykpCgogICAgZGVmIF9fc3RyX18oc2VsZik6CiAgICAgICAgcmV0dXJuIHN0cihzZWxmLmRpY3QoKSkKCiAgICBkZWYgZnJvbV9yZXYoc2VsZiwgcmV2KToKICAgICAgICByZXR1cm4gc2VsZi5tYXJrc1tzdHIocmV2KV0KCiAgICBkZWYgdG9fcmV2KHNlbGYsIG1hcmspOgogICAgICAgIHJldHVybiBzZWxmLnJldl9tYXJrc1ttYXJrXQoKICAgIGRlZiBnZXRfbWFyayhzZWxmLCByZXYpOgogICAgICAgIHNlbGYubGFzdF9tYXJrICs9IDEKICAgICAgICBzZWxmLm1hcmtzW3N0cihyZXYpXSA9IHNlbGYubGFzdF9tYXJrCiAgICAgICAgcmV0dXJuIHNlbGYubGFzdF9tYXJrCgogICAgZGVmIG5ld19tYXJrKHNlbGYsIHJldiwgbWFyayk6CiAgICAgICAgc2VsZi5tYXJrc1tzdHIocmV2KV0gPSBtYXJrCiAgICAgICAgc2VsZi5yZXZfbWFya3NbbWFya10gPSByZXYKICAgICAgICBzZWxmLmxhc3RfbWFyayA9IG1hcmsKCiAgICBkZWYgaXNfbWFya2VkKHNlbGYsIHJldik6CiAgICAgICAgcmV0dXJuIHN0cihyZXYpIGluIHNlbGYubWFya3MKCiAgICBkZWYgZ2V0X3RpcChzZWxmLCBicmFuY2gpOgogICAgICAgIHJldHVybiBzZWxmLnRpcHMuZ2V0KGJyYW5jaCwgMCkKCiAgICBkZWYgc2V0X3RpcChzZWxmLCBicmFuY2gsIHRpcCk6CiAgICAgICAgc2VsZi50aXBzW2JyYW5jaF0gPSB0aXAKCmNsYXNzIFBhcnNlcjoKCiAgICBkZWYgX19pbml0X18oc2VsZiwgcmVwbyk6CiAgICAgICAgc2VsZi5yZXBvID0gcmVwbwogICAgICAgIHNlbGYubGluZSA9IHNlbGYuZ2V0X2xpbmUoKQoKICAgIGRlZiBnZXRfbGluZShzZWxmKToKICAgICAgICByZXR1cm4gc3lzLnN0ZGluLnJlYWRsaW5lKCkuc3RyaXAoKQoKICAgIGRlZiBfX2dldGl0ZW1fXyhzZWxmLCBpKToKICAgICAgICByZXR1cm4gc2VsZi5saW5lLnNwbGl0KClbaV0KCiAgICBkZWYgY2hlY2soc2VsZiwgd29yZCk6CiAgICAgICAgcmV0dXJuIHNlbGYubGluZS5zdGFydHN3aXRoKHdvcmQpCgogICAgZGVmIGVhY2hfYmxvY2soc2VsZiwgc2VwYXJhdG9yKToKICAgICAgICB3aGlsZSBzZWxmLmxpbmUgIT0gc2VwYXJhdG9yOgogICAgICAgICAgICB5aWVsZCBzZWxmLmxpbmUKICAgICAgICAgICAgc2VsZi5saW5lID0gc2VsZi5nZXRfbGluZSgpCgogICAgZGVmIF9faXRlcl9fKHNlbGYpOgogICAgICAgIHJldHVybiBzZWxmLmVhY2hfYmxvY2soJycpCgogICAgZGVmIG5leHQoc2VsZik6CiAgICAgICAgc2VsZi5saW5lID0gc2VsZi5nZXRfbGluZSgpCiAgICAgICAgaWYgc2VsZi5saW5lID09ICdkb25lJzoKICAgICAgICAgICAgc2VsZi5saW5lID0gTm9uZQoKICAgIGRlZiBnZXRfbWFyayhzZWxmKToKICAgICAgICBpID0gc2VsZi5saW5lLmluZGV4KCc6JykgKyAxCiAgICAgICAgcmV0dXJuIGludChzZWxmLmxpbmVbaTpdKQoKICAgIGRlZiBnZXRfZGF0YShzZWxmKToKICAgICAgICBpZiBub3Qgc2VsZi5jaGVjaygnZGF0YScpOgogICAgICAgICAgICByZXR1cm4gTm9uZQogICAgICAgIGkgPSBzZWxmLmxpbmUuaW5kZXgoJyAnKSArIDEKICAgICAgICBzaXplID0gaW50KHNlbGYubGluZVtpOl0pCiAgICAgICAgcmV0dXJuIHN5cy5zdGRpbi5yZWFkKHNpemUpCgogICAgZGVmIGdldF9hdXRob3Ioc2VsZik6CiAgICAgICAgZ2xvYmFsIGJhZF9tYWlsCgogICAgICAgIGV4ID0gTm9uZQogICAgICAgIG0gPSBSQVdfQVVUSE9SX1JFLm1hdGNoKHNlbGYubGluZSkKICAgICAgICBpZiBub3QgbToKICAgICAgICAgICAgcmV0dXJuIE5vbmUKICAgICAgICBfLCBuYW1lLCBlbWFpbCwgZGF0ZSwgdHogPSBtLmdyb3VwcygpCiAgICAgICAgaWYgbmFtZSBhbmQgJ2V4dDonIGluIG5hbWU6CiAgICAgICAgICAgIG0gPSByZS5tYXRjaCgnXiguKz8pIGV4dDpcKCguKylcKSQnLCBuYW1lKQogICAgICAgICAgICBpZiBtOgogICAgICAgICAgICAgICAgbmFtZSA9IG0uZ3JvdXAoMSkKICAgICAgICAgICAgICAgIGV4ID0gdXJsbGliLnVucXVvdGUobS5ncm91cCgyKSkKCiAgICAgICAgaWYgZW1haWwgIT0gYmFkX21haWw6CiAgICAgICAgICAgIGlmIG5hbWU6CiAgICAgICAgICAgICAgICB1c2VyID0gJyVzIDwlcz4nICUgKG5hbWUsIGVtYWlsKQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgdXNlciA9ICc8JXM+JyAlIChlbWFpbCkKICAgICAgICBlbHNlOgogICAgICAgICAgICB1c2VyID0gbmFtZQoKICAgICAgICBpZiBleDoKICAgICAgICAgICAgdXNlciArPSBleAoKICAgICAgICB0eiA9IGludCh0eikKICAgICAgICB0eiA9ICgodHogLyAxMDApICogMzYwMCkgKyAoKHR6ICUgMTAwKSAqIDYwKQogICAgICAgIHJldHVybiAodXNlciwgaW50KGRhdGUpLCAtdHopCgpkZWYgZml4X2ZpbGVfcGF0aChwYXRoKToKICAgIGlmIG5vdCBvcy5wYXRoLmlzYWJzKHBhdGgpOgogICAgICAgIHJldHVybiBwYXRoCiAgICByZXR1cm4gb3MucGF0aC5yZWxwYXRoKHBhdGgsICcvJykKCmRlZiBleHBvcnRfZmlsZShmYyk6CiAgICBkID0gZmMuZGF0YSgpCiAgICBwYXRoID0gZml4X2ZpbGVfcGF0aChmYy5wYXRoKCkpCiAgICBwcmludCAiTSAlcyBpbmxpbmUgJXMiICUgKGdpdG1vZGUoZmMuZmxhZ3MoKSksIHBhdGgpCiAgICBwcmludCAiZGF0YSAlZCIgJSBsZW4oZCkKICAgIHByaW50IGQKCmRlZiBnZXRfZmlsZWNoYW5nZXMocmVwbywgY3R4LCBwYXJlbnQpOgogICAgbW9kaWZpZWQgPSBzZXQoKQogICAgYWRkZWQgPSBzZXQoKQogICAgcmVtb3ZlZCA9IHNldCgpCgogICAgY3VyID0gY3R4Lm1hbmlmZXN0KCkKICAgIHByZXYgPSByZXBvW3BhcmVudF0ubWFuaWZlc3QoKS5jb3B5KCkKCiAgICBmb3IgZm4gaW4gY3VyOgogICAgICAgIGlmIGZuIGluIHByZXY6CiAgICAgICAgICAgIGlmIChjdXIuZmxhZ3MoZm4pICE9IHByZXYuZmxhZ3MoZm4pIG9yIGN1cltmbl0gIT0gcHJldltmbl0pOgogICAgICAgICAgICAgICAgbW9kaWZpZWQuYWRkKGZuKQogICAgICAgICAgICBkZWwgcHJldltmbl0KICAgICAgICBlbHNlOgogICAgICAgICAgICBhZGRlZC5hZGQoZm4pCiAgICByZW1vdmVkIHw9IHNldChwcmV2LmtleXMoKSkKCiAgICByZXR1cm4gYWRkZWQgfCBtb2RpZmllZCwgcmVtb3ZlZAoKZGVmIGZpeHVwX3VzZXJfZ2l0KHVzZXIpOgogICAgbmFtZSA9IG1haWwgPSBOb25lCiAgICB1c2VyID0gdXNlci5yZXBsYWNlKCciJywgJycpCiAgICBtID0gQVVUSE9SX1JFLm1hdGNoKHVzZXIpCiAgICBpZiBtOgogICAgICAgIG5hbWUgPSBtLmdyb3VwKDEpCiAgICAgICAgbWFpbCA9IG0uZ3JvdXAoMikuc3RyaXAoKQogICAgZWxzZToKICAgICAgICBtID0gRU1BSUxfUkUubWF0Y2godXNlcikKICAgICAgICBpZiBtOgogICAgICAgICAgICBuYW1lID0gbS5ncm91cCgxKQogICAgICAgICAgICBtYWlsID0gbS5ncm91cCgyKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIG0gPSBOQU1FX1JFLm1hdGNoKHVzZXIpCiAgICAgICAgICAgIGlmIG06CiAgICAgICAgICAgICAgICBuYW1lID0gbS5ncm91cCgxKS5zdHJpcCgpCiAgICByZXR1cm4gKG5hbWUsIG1haWwpCgpkZWYgZml4dXBfdXNlcl9oZyh1c2VyKToKICAgIGRlZiBzYW5pdGl6ZShuYW1lKToKICAgICAgICAjIHN0b2xlIHRoaXMgZnJvbSBoZy1naXQKICAgICAgICByZXR1cm4gcmUuc3ViKCdbPD5cbl0nLCAnPycsIG5hbWUubHN0cmlwKCc8ICcpLnJzdHJpcCgnPiAnKSkKCiAgICBtID0gQVVUSE9SX0hHX1JFLm1hdGNoKHVzZXIpCiAgICBpZiBtOgogICAgICAgIG5hbWUgPSBzYW5pdGl6ZShtLmdyb3VwKDEpKQogICAgICAgIG1haWwgPSBzYW5pdGl6ZShtLmdyb3VwKDIpKQogICAgICAgIGV4ID0gbS5ncm91cCgzKQogICAgICAgIGlmIGV4OgogICAgICAgICAgICBuYW1lICs9ICcgZXh0OignICsgdXJsbGliLnF1b3RlKGV4KSArICcpJwogICAgZWxzZToKICAgICAgICBuYW1lID0gc2FuaXRpemUodXNlcikKICAgICAgICBpZiAnQCcgaW4gdXNlcjoKICAgICAgICAgICAgbWFpbCA9IG5hbWUKICAgICAgICBlbHNlOgogICAgICAgICAgICBtYWlsID0gTm9uZQoKICAgIHJldHVybiAobmFtZSwgbWFpbCkKCmRlZiBmaXh1cF91c2VyKHVzZXIpOgogICAgZ2xvYmFsIG1vZGUsIGJhZF9tYWlsCgogICAgaWYgbW9kZSA9PSAnZ2l0JzoKICAgICAgICBuYW1lLCBtYWlsID0gZml4dXBfdXNlcl9naXQodXNlcikKICAgIGVsc2U6CiAgICAgICAgbmFtZSwgbWFpbCA9IGZpeHVwX3VzZXJfaGcodXNlcikKCiAgICBpZiBub3QgbmFtZToKICAgICAgICBuYW1lID0gYmFkX25hbWUKICAgIGlmIG5vdCBtYWlsOgogICAgICAgIG1haWwgPSBiYWRfbWFpbAoKICAgIHJldHVybiAnJXMgPCVzPicgJSAobmFtZSwgbWFpbCkKCmRlZiBnZXRfcmVwbyh1cmwsIGFsaWFzKToKICAgIGdsb2JhbCBkaXJuYW1lLCBwZWVyCgogICAgbXl1aSA9IHVpLnVpKCkKICAgIG15dWkuc2V0Y29uZmlnKCd1aScsICdpbnRlcmFjdGl2ZScsICdvZmYnKQogICAgbXl1aS5mb3V0ID0gc3lzLnN0ZGVycgoKICAgIHRyeToKICAgICAgICBpZiBnZXRfY29uZmlnKCdyZW1vdGUtaGcuaW5zZWN1cmUnKSA9PSAndHJ1ZVxuJzoKICAgICAgICAgICAgbXl1aS5zZXRjb25maWcoJ3dlYicsICdjYWNlcnRzJywgJycpCiAgICBleGNlcHQgc3VicHJvY2Vzcy5DYWxsZWRQcm9jZXNzRXJyb3I6CiAgICAgICAgcGFzcwoKICAgIGlmIGhnLmlzbG9jYWwodXJsKToKICAgICAgICByZXBvID0gaGcucmVwb3NpdG9yeShteXVpLCB1cmwpCiAgICBlbHNlOgogICAgICAgIGxvY2FsX3BhdGggPSBvcy5wYXRoLmpvaW4oZGlybmFtZSwgJ2Nsb25lJykKICAgICAgICBpZiBub3Qgb3MucGF0aC5leGlzdHMobG9jYWxfcGF0aCk6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIHBlZXIsIGRzdHBlZXIgPSBoZy5jbG9uZShteXVpLCB7fSwgdXJsLCBsb2NhbF9wYXRoLCB1cGRhdGU9VHJ1ZSwgcHVsbD1UcnVlKQogICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICBkaWUoJ1JlcG9zaXRvcnkgZXJyb3InKQogICAgICAgICAgICByZXBvID0gZHN0cGVlci5sb2NhbCgpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmVwbyA9IGhnLnJlcG9zaXRvcnkobXl1aSwgbG9jYWxfcGF0aCkKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgcGVlciA9IGhnLnBlZXIobXl1aSwge30sIHVybCkKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgZGllKCdSZXBvc2l0b3J5IGVycm9yJykKICAgICAgICAgICAgcmVwby5wdWxsKHBlZXIsIGhlYWRzPU5vbmUsIGZvcmNlPVRydWUpCgogICAgcmV0dXJuIHJlcG8KCmRlZiByZXZfdG9fbWFyayhyZXYpOgogICAgZ2xvYmFsIG1hcmtzCiAgICByZXR1cm4gbWFya3MuZnJvbV9yZXYocmV2KQoKZGVmIG1hcmtfdG9fcmV2KG1hcmspOgogICAgZ2xvYmFsIG1hcmtzCiAgICByZXR1cm4gbWFya3MudG9fcmV2KG1hcmspCgpkZWYgZXhwb3J0X3JlZihyZXBvLCBuYW1lLCBraW5kLCBoZWFkKToKICAgIGdsb2JhbCBwcmVmaXgsIG1hcmtzLCBtb2RlCgogICAgZW5hbWUgPSAnJXMvJXMnICUgKGtpbmQsIG5hbWUpCiAgICB0aXAgPSBtYXJrcy5nZXRfdGlwKGVuYW1lKQoKICAgICMgbWVyY3VyaWFsIHRha2VzIHRvbyBtdWNoIHRpbWUgY2hlY2tpbmcgdGhpcwogICAgaWYgdGlwIGFuZCB0aXAgPT0gaGVhZC5yZXYoKToKICAgICAgICAjIG5vdGhpbmcgdG8gZG8KICAgICAgICByZXR1cm4KICAgIHJldnMgPSB4cmFuZ2UodGlwLCBoZWFkLnJldigpICsgMSkKICAgIGNvdW50ID0gMAoKICAgIHJldnMgPSBbcmV2IGZvciByZXYgaW4gcmV2cyBpZiBub3QgbWFya3MuaXNfbWFya2VkKHJldildCgogICAgZm9yIHJldiBpbiByZXZzOgoKICAgICAgICBjID0gcmVwb1tyZXZdCiAgICAgICAgKG1hbmlmZXN0LCB1c2VyLCAodGltZSwgdHopLCBmaWxlcywgZGVzYywgZXh0cmEpID0gcmVwby5jaGFuZ2Vsb2cucmVhZChjLm5vZGUoKSkKICAgICAgICByZXZfYnJhbmNoID0gZXh0cmFbJ2JyYW5jaCddCgogICAgICAgIGF1dGhvciA9ICIlcyAlZCAlcyIgJSAoZml4dXBfdXNlcih1c2VyKSwgdGltZSwgZ2l0dHoodHopKQogICAgICAgIGlmICdjb21taXR0ZXInIGluIGV4dHJhOgogICAgICAgICAgICB1c2VyLCB0aW1lLCB0eiA9IGV4dHJhWydjb21taXR0ZXInXS5yc3BsaXQoJyAnLCAyKQogICAgICAgICAgICBjb21taXR0ZXIgPSAiJXMgJXMgJXMiICUgKHVzZXIsIHRpbWUsIGdpdHR6KGludCh0eikpKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGNvbW1pdHRlciA9IGF1dGhvcgoKICAgICAgICBwYXJlbnRzID0gW3AgZm9yIHAgaW4gcmVwby5jaGFuZ2Vsb2cucGFyZW50cmV2cyhyZXYpIGlmIHAgPj0gMF0KCiAgICAgICAgaWYgbGVuKHBhcmVudHMpID09IDA6CiAgICAgICAgICAgIG1vZGlmaWVkID0gYy5tYW5pZmVzdCgpLmtleXMoKQogICAgICAgICAgICByZW1vdmVkID0gW10KICAgICAgICBlbHNlOgogICAgICAgICAgICBtb2RpZmllZCwgcmVtb3ZlZCA9IGdldF9maWxlY2hhbmdlcyhyZXBvLCBjLCBwYXJlbnRzWzBdKQoKICAgICAgICBkZXNjICs9ICdcbicKCiAgICAgICAgaWYgbW9kZSA9PSAnaGcnOgogICAgICAgICAgICBleHRyYV9tc2cgPSAnJwoKICAgICAgICAgICAgaWYgcmV2X2JyYW5jaCAhPSAnZGVmYXVsdCc6CiAgICAgICAgICAgICAgICBleHRyYV9tc2cgKz0gJ2JyYW5jaCA6ICVzXG4nICUgcmV2X2JyYW5jaAoKICAgICAgICAgICAgcmVuYW1lcyA9IFtdCiAgICAgICAgICAgIGZvciBmIGluIGMuZmlsZXMoKToKICAgICAgICAgICAgICAgIGlmIGYgbm90IGluIGMubWFuaWZlc3QoKToKICAgICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICAgICAgcmVuYW1lID0gYy5maWxlY3R4KGYpLnJlbmFtZWQoKQogICAgICAgICAgICAgICAgaWYgcmVuYW1lOgogICAgICAgICAgICAgICAgICAgIHJlbmFtZXMuYXBwZW5kKChyZW5hbWVbMF0sIGYpKQoKICAgICAgICAgICAgZm9yIGUgaW4gcmVuYW1lczoKICAgICAgICAgICAgICAgIGV4dHJhX21zZyArPSAicmVuYW1lIDogJXMgPT4gJXNcbiIgJSBlCgogICAgICAgICAgICBmb3Iga2V5LCB2YWx1ZSBpbiBleHRyYS5pdGVyaXRlbXMoKToKICAgICAgICAgICAgICAgIGlmIGtleSBpbiAoJ2F1dGhvcicsICdjb21taXR0ZXInLCAnZW5jb2RpbmcnLCAnbWVzc2FnZScsICdicmFuY2gnLCAnaGctZ2l0Jyk6CiAgICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgZXh0cmFfbXNnICs9ICJleHRyYSA6ICVzIDogJXNcbiIgJSAoa2V5LCB1cmxsaWIucXVvdGUodmFsdWUpKQoKICAgICAgICAgICAgaWYgZXh0cmFfbXNnOgogICAgICAgICAgICAgICAgZGVzYyArPSAnXG4tLUhHLS1cbicgKyBleHRyYV9tc2cKCiAgICAgICAgaWYgbGVuKHBhcmVudHMpID09IDAgYW5kIHJldjoKICAgICAgICAgICAgcHJpbnQgJ3Jlc2V0ICVzLyVzJyAlIChwcmVmaXgsIGVuYW1lKQoKICAgICAgICBwcmludCAiY29tbWl0ICVzLyVzIiAlIChwcmVmaXgsIGVuYW1lKQogICAgICAgIHByaW50ICJtYXJrIDolZCIgJSAobWFya3MuZ2V0X21hcmsocmV2KSkKICAgICAgICBwcmludCAiYXV0aG9yICVzIiAlIChhdXRob3IpCiAgICAgICAgcHJpbnQgImNvbW1pdHRlciAlcyIgJSAoY29tbWl0dGVyKQogICAgICAgIHByaW50ICJkYXRhICVkIiAlIChsZW4oZGVzYykpCiAgICAgICAgcHJpbnQgZGVzYwoKICAgICAgICBpZiBsZW4ocGFyZW50cykgPiAwOgogICAgICAgICAgICBwcmludCAiZnJvbSA6JXMiICUgKHJldl90b19tYXJrKHBhcmVudHNbMF0pKQogICAgICAgICAgICBpZiBsZW4ocGFyZW50cykgPiAxOgogICAgICAgICAgICAgICAgcHJpbnQgIm1lcmdlIDolcyIgJSAocmV2X3RvX21hcmsocGFyZW50c1sxXSkpCgogICAgICAgIGZvciBmIGluIG1vZGlmaWVkOgogICAgICAgICAgICBleHBvcnRfZmlsZShjLmZpbGVjdHgoZikpCiAgICAgICAgZm9yIGYgaW4gcmVtb3ZlZDoKICAgICAgICAgICAgcHJpbnQgIkQgJXMiICUgKGZpeF9maWxlX3BhdGgoZikpCiAgICAgICAgcHJpbnQKCiAgICAgICAgY291bnQgKz0gMQogICAgICAgIGlmIChjb3VudCAlIDEwMCA9PSAwKToKICAgICAgICAgICAgcHJpbnQgInByb2dyZXNzIHJldmlzaW9uICVkICclcycgKCVkLyVkKSIgJSAocmV2LCBuYW1lLCBjb3VudCwgbGVuKHJldnMpKQogICAgICAgICAgICBwcmludCAiIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyIKCiAgICAjIG1ha2Ugc3VyZSB0aGUgcmVmIGlzIHVwZGF0ZWQKICAgIHByaW50ICJyZXNldCAlcy8lcyIgJSAocHJlZml4LCBlbmFtZSkKICAgIHByaW50ICJmcm9tIDoldSIgJSByZXZfdG9fbWFyayhyZXYpCiAgICBwcmludAoKICAgIG1hcmtzLnNldF90aXAoZW5hbWUsIHJldikKCmRlZiBleHBvcnRfdGFnKHJlcG8sIHRhZyk6CiAgICBleHBvcnRfcmVmKHJlcG8sIHRhZywgJ3RhZ3MnLCByZXBvW3RhZ10pCgpkZWYgZXhwb3J0X2Jvb2ttYXJrKHJlcG8sIGJtYXJrKToKICAgIGhlYWQgPSBibWFya3NbYm1hcmtdCiAgICBleHBvcnRfcmVmKHJlcG8sIGJtYXJrLCAnYm9va21hcmtzJywgaGVhZCkKCmRlZiBleHBvcnRfYnJhbmNoKHJlcG8sIGJyYW5jaCk6CiAgICB0aXAgPSBnZXRfYnJhbmNoX3RpcChyZXBvLCBicmFuY2gpCiAgICBoZWFkID0gcmVwb1t0aXBdCiAgICBleHBvcnRfcmVmKHJlcG8sIGJyYW5jaCwgJ2JyYW5jaGVzJywgaGVhZCkKCmRlZiBleHBvcnRfaGVhZChyZXBvKToKICAgIGdsb2JhbCBnX2hlYWQKICAgIGV4cG9ydF9yZWYocmVwbywgZ19oZWFkWzBdLCAnYm9va21hcmtzJywgZ19oZWFkWzFdKQoKZGVmIGRvX2NhcGFiaWxpdGllcyhwYXJzZXIpOgogICAgZ2xvYmFsIHByZWZpeCwgZGlybmFtZQoKICAgIHByaW50ICJpbXBvcnQiCiAgICBwcmludCAiZXhwb3J0IgogICAgcHJpbnQgInJlZnNwZWMgcmVmcy9oZWFkcy9icmFuY2hlcy8qOiVzL2JyYW5jaGVzLyoiICUgcHJlZml4CiAgICBwcmludCAicmVmc3BlYyByZWZzL2hlYWRzLyo6JXMvYm9va21hcmtzLyoiICUgcHJlZml4CiAgICBwcmludCAicmVmc3BlYyByZWZzL3RhZ3MvKjolcy90YWdzLyoiICUgcHJlZml4CgogICAgcGF0aCA9IG9zLnBhdGguam9pbihkaXJuYW1lLCAnbWFya3MtZ2l0JykKCiAgICBpZiBvcy5wYXRoLmV4aXN0cyhwYXRoKToKICAgICAgICBwcmludCAiKmltcG9ydC1tYXJrcyAlcyIgJSBwYXRoCiAgICBwcmludCAiKmV4cG9ydC1tYXJrcyAlcyIgJSBwYXRoCgogICAgcHJpbnQKCmRlZiBicmFuY2hfdGlwKHJlcG8sIGJyYW5jaCk6CiAgICAjIG9sZGVyIHZlcnNpb25zIG9mIG1lcmN1cmlhbCBkb24ndCBoYXZlIHRoaXMKICAgIGlmIGhhc2F0dHIocmVwbywgJ2JyYW5jaHRpcCcpOgogICAgICAgIHJldHVybiByZXBvLmJyYW5jaHRpcChicmFuY2gpCiAgICBlbHNlOgogICAgICAgIHJldHVybiByZXBvLmJyYW5jaHRhZ3MoKVticmFuY2hdCgpkZWYgZ2V0X2JyYW5jaF90aXAocmVwbywgYnJhbmNoKToKICAgIGdsb2JhbCBicmFuY2hlcwoKICAgIGhlYWRzID0gYnJhbmNoZXMuZ2V0KGJyYW5jaCwgTm9uZSkKICAgIGlmIG5vdCBoZWFkczoKICAgICAgICByZXR1cm4gTm9uZQoKICAgICMgdmVyaWZ5IHRoZXJlJ3Mgb25seSBvbmUgaGVhZAogICAgaWYgKGxlbihoZWFkcykgPiAxKToKICAgICAgICB3YXJuKCJCcmFuY2ggJyVzJyBoYXMgbW9yZSB0aGFuIG9uZSBoZWFkLCBjb25zaWRlciBtZXJnaW5nIiAlIGJyYW5jaCkKICAgICAgICByZXR1cm4gYnJhbmNoX3RpcChyZXBvLCBicmFuY2gpCgogICAgcmV0dXJuIGhlYWRzWzBdCgpkZWYgbGlzdF9oZWFkKHJlcG8sIGN1cik6CiAgICBnbG9iYWwgZ19oZWFkLCBibWFya3MKCiAgICBoZWFkID0gYm9va21hcmtzLnJlYWRjdXJyZW50KHJlcG8pCiAgICBpZiBoZWFkOgogICAgICAgIG5vZGUgPSByZXBvW2hlYWRdCiAgICBlbHNlOgogICAgICAgICMgZmFrZSBib29rbWFyayBmcm9tIGN1cnJlbnQgYnJhbmNoCiAgICAgICAgaGVhZCA9IGN1cgogICAgICAgIG5vZGUgPSByZXBvWycuJ10KICAgICAgICBpZiBub3Qgbm9kZToKICAgICAgICAgICAgbm9kZSA9IHJlcG9bJ3RpcCddCiAgICAgICAgaWYgbm90IG5vZGU6CiAgICAgICAgICAgIHJldHVybgogICAgICAgIGlmIGhlYWQgPT0gJ2RlZmF1bHQnOgogICAgICAgICAgICBoZWFkID0gJ21hc3RlcicKICAgICAgICBibWFya3NbaGVhZF0gPSBub2RlCgogICAgcHJpbnQgIkByZWZzL2hlYWRzLyVzIEhFQUQiICUgaGVhZAogICAgZ19oZWFkID0gKGhlYWQsIG5vZGUpCgpkZWYgZG9fbGlzdChwYXJzZXIpOgogICAgZ2xvYmFsIGJyYW5jaGVzLCBibWFya3MsIG1vZGUsIHRyYWNrX2JyYW5jaGVzCgogICAgcmVwbyA9IHBhcnNlci5yZXBvCiAgICBmb3IgYm1hcmssIG5vZGUgaW4gYm9va21hcmtzLmxpc3Rib29rbWFya3MocmVwbykuaXRlcml0ZW1zKCk6CiAgICAgICAgYm1hcmtzW2JtYXJrXSA9IHJlcG9bbm9kZV0KCiAgICBjdXIgPSByZXBvLmRpcnN0YXRlLmJyYW5jaCgpCgogICAgbGlzdF9oZWFkKHJlcG8sIGN1cikKCiAgICBpZiB0cmFja19icmFuY2hlczoKICAgICAgICBmb3IgYnJhbmNoIGluIHJlcG8uYnJhbmNobWFwKCk6CiAgICAgICAgICAgIGhlYWRzID0gcmVwby5icmFuY2hoZWFkcyhicmFuY2gpCiAgICAgICAgICAgIGlmIGxlbihoZWFkcyk6CiAgICAgICAgICAgICAgICBicmFuY2hlc1ticmFuY2hdID0gaGVhZHMKCiAgICAgICAgZm9yIGJyYW5jaCBpbiBicmFuY2hlczoKICAgICAgICAgICAgcHJpbnQgIj8gcmVmcy9oZWFkcy9icmFuY2hlcy8lcyIgJSBicmFuY2gKCiAgICBmb3IgYm1hcmsgaW4gYm1hcmtzOgogICAgICAgIHByaW50ICI/IHJlZnMvaGVhZHMvJXMiICUgYm1hcmsKCiAgICBmb3IgdGFnLCBub2RlIGluIHJlcG8udGFnc2xpc3QoKToKICAgICAgICBpZiB0YWcgPT0gJ3RpcCc6CiAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgcHJpbnQgIj8gcmVmcy90YWdzLyVzIiAlIHRhZwoKICAgIHByaW50CgpkZWYgZG9faW1wb3J0KHBhcnNlcik6CiAgICByZXBvID0gcGFyc2VyLnJlcG8KCiAgICBwYXRoID0gb3MucGF0aC5qb2luKGRpcm5hbWUsICdtYXJrcy1naXQnKQoKICAgIHByaW50ICJmZWF0dXJlIGRvbmUiCiAgICBpZiBvcy5wYXRoLmV4aXN0cyhwYXRoKToKICAgICAgICBwcmludCAiZmVhdHVyZSBpbXBvcnQtbWFya3M9JXMiICUgcGF0aAogICAgcHJpbnQgImZlYXR1cmUgZXhwb3J0LW1hcmtzPSVzIiAlIHBhdGgKICAgIHN5cy5zdGRvdXQuZmx1c2goKQoKICAgIHRtcCA9IGVuY29kaW5nLmVuY29kaW5nCiAgICBlbmNvZGluZy5lbmNvZGluZyA9ICd1dGYtOCcKCiAgICAjIGxldHMgZ2V0IGFsbCB0aGUgaW1wb3J0IGxpbmVzCiAgICB3aGlsZSBwYXJzZXIuY2hlY2soJ2ltcG9ydCcpOgogICAgICAgIHJlZiA9IHBhcnNlclsxXQoKICAgICAgICBpZiAocmVmID09ICdIRUFEJyk6CiAgICAgICAgICAgIGV4cG9ydF9oZWFkKHJlcG8pCiAgICAgICAgZWxpZiByZWYuc3RhcnRzd2l0aCgncmVmcy9oZWFkcy9icmFuY2hlcy8nKToKICAgICAgICAgICAgYnJhbmNoID0gcmVmW2xlbigncmVmcy9oZWFkcy9icmFuY2hlcy8nKTpdCiAgICAgICAgICAgIGV4cG9ydF9icmFuY2gocmVwbywgYnJhbmNoKQogICAgICAgIGVsaWYgcmVmLnN0YXJ0c3dpdGgoJ3JlZnMvaGVhZHMvJyk6CiAgICAgICAgICAgIGJtYXJrID0gcmVmW2xlbigncmVmcy9oZWFkcy8nKTpdCiAgICAgICAgICAgIGV4cG9ydF9ib29rbWFyayhyZXBvLCBibWFyaykKICAgICAgICBlbGlmIHJlZi5zdGFydHN3aXRoKCdyZWZzL3RhZ3MvJyk6CiAgICAgICAgICAgIHRhZyA9IHJlZltsZW4oJ3JlZnMvdGFncy8nKTpdCiAgICAgICAgICAgIGV4cG9ydF90YWcocmVwbywgdGFnKQoKICAgICAgICBwYXJzZXIubmV4dCgpCgogICAgZW5jb2RpbmcuZW5jb2RpbmcgPSB0bXAKCiAgICBwcmludCAnZG9uZScKCmRlZiBwYXJzZV9ibG9iKHBhcnNlcik6CiAgICBnbG9iYWwgYmxvYl9tYXJrcwoKICAgIHBhcnNlci5uZXh0KCkKICAgIG1hcmsgPSBwYXJzZXIuZ2V0X21hcmsoKQogICAgcGFyc2VyLm5leHQoKQogICAgZGF0YSA9IHBhcnNlci5nZXRfZGF0YSgpCiAgICBibG9iX21hcmtzW21hcmtdID0gZGF0YQogICAgcGFyc2VyLm5leHQoKQoKZGVmIGdldF9tZXJnZV9maWxlcyhyZXBvLCBwMSwgcDIsIGZpbGVzKToKICAgIGZvciBlIGluIHJlcG9bcDFdLmZpbGVzKCk6CiAgICAgICAgaWYgZSBub3QgaW4gZmlsZXM6CiAgICAgICAgICAgIGlmIGUgbm90IGluIHJlcG9bcDFdLm1hbmlmZXN0KCk6CiAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICBmID0geyAnY3R4JyA6IHJlcG9bcDFdW2VdIH0KICAgICAgICAgICAgZmlsZXNbZV0gPSBmCgpkZWYgcGFyc2VfY29tbWl0KHBhcnNlcik6CiAgICBnbG9iYWwgbWFya3MsIGJsb2JfbWFya3MsIHBhcnNlZF9yZWZzCiAgICBnbG9iYWwgbW9kZQoKICAgIGZyb21fbWFyayA9IG1lcmdlX21hcmsgPSBOb25lCgogICAgcmVmID0gcGFyc2VyWzFdCiAgICBwYXJzZXIubmV4dCgpCgogICAgY29tbWl0X21hcmsgPSBwYXJzZXIuZ2V0X21hcmsoKQogICAgcGFyc2VyLm5leHQoKQogICAgYXV0aG9yID0gcGFyc2VyLmdldF9hdXRob3IoKQogICAgcGFyc2VyLm5leHQoKQogICAgY29tbWl0dGVyID0gcGFyc2VyLmdldF9hdXRob3IoKQogICAgcGFyc2VyLm5leHQoKQogICAgZGF0YSA9IHBhcnNlci5nZXRfZGF0YSgpCiAgICBwYXJzZXIubmV4dCgpCiAgICBpZiBwYXJzZXIuY2hlY2soJ2Zyb20nKToKICAgICAgICBmcm9tX21hcmsgPSBwYXJzZXIuZ2V0X21hcmsoKQogICAgICAgIHBhcnNlci5uZXh0KCkKICAgIGlmIHBhcnNlci5jaGVjaygnbWVyZ2UnKToKICAgICAgICBtZXJnZV9tYXJrID0gcGFyc2VyLmdldF9tYXJrKCkKICAgICAgICBwYXJzZXIubmV4dCgpCiAgICAgICAgaWYgcGFyc2VyLmNoZWNrKCdtZXJnZScpOgogICAgICAgICAgICBkaWUoJ29jdG9wdXMgbWVyZ2VzIGFyZSBub3Qgc3VwcG9ydGVkIHlldCcpCgogICAgZmlsZXMgPSB7fQoKICAgIGZvciBsaW5lIGluIHBhcnNlcjoKICAgICAgICBpZiBwYXJzZXIuY2hlY2soJ00nKToKICAgICAgICAgICAgdCwgbSwgbWFya19yZWYsIHBhdGggPSBsaW5lLnNwbGl0KCcgJywgMykKICAgICAgICAgICAgbWFyayA9IGludChtYXJrX3JlZlsxOl0pCiAgICAgICAgICAgIGYgPSB7ICdtb2RlJyA6IGhnbW9kZShtKSwgJ2RhdGEnIDogYmxvYl9tYXJrc1ttYXJrXSB9CiAgICAgICAgZWxpZiBwYXJzZXIuY2hlY2soJ0QnKToKICAgICAgICAgICAgdCwgcGF0aCA9IGxpbmUuc3BsaXQoJyAnLCAxKQogICAgICAgICAgICBmID0geyAnZGVsZXRlZCcgOiBUcnVlIH0KICAgICAgICBlbHNlOgogICAgICAgICAgICBkaWUoJ1Vua25vd24gZmlsZSBjb21tYW5kOiAlcycgJSBsaW5lKQogICAgICAgIGZpbGVzW3BhdGhdID0gZgoKICAgIGRlZiBnZXRmaWxlY3R4KHJlcG8sIG1lbWN0eCwgZik6CiAgICAgICAgb2YgPSBmaWxlc1tmXQogICAgICAgIGlmICdkZWxldGVkJyBpbiBvZjoKICAgICAgICAgICAgcmFpc2UgSU9FcnJvcgogICAgICAgIGlmICdjdHgnIGluIG9mOgogICAgICAgICAgICByZXR1cm4gb2ZbJ2N0eCddCiAgICAgICAgaXNfZXhlYyA9IG9mWydtb2RlJ10gPT0gJ3gnCiAgICAgICAgaXNfbGluayA9IG9mWydtb2RlJ10gPT0gJ2wnCiAgICAgICAgcmVuYW1lID0gb2YuZ2V0KCdyZW5hbWUnLCBOb25lKQogICAgICAgIHJldHVybiBjb250ZXh0Lm1lbWZpbGVjdHgoZiwgb2ZbJ2RhdGEnXSwKICAgICAgICAgICAgICAgIGlzX2xpbmssIGlzX2V4ZWMsIHJlbmFtZSkKCiAgICByZXBvID0gcGFyc2VyLnJlcG8KCiAgICB1c2VyLCBkYXRlLCB0eiA9IGF1dGhvcgogICAgZXh0cmEgPSB7fQoKICAgIGlmIGNvbW1pdHRlciAhPSBhdXRob3I6CiAgICAgICAgZXh0cmFbJ2NvbW1pdHRlciddID0gIiVzICV1ICV1IiAlIGNvbW1pdHRlcgoKICAgIGlmIGZyb21fbWFyazoKICAgICAgICBwMSA9IHJlcG8uY2hhbmdlbG9nLm5vZGUobWFya190b19yZXYoZnJvbV9tYXJrKSkKICAgIGVsc2U6CiAgICAgICAgcDEgPSAnXDAnICogMjAKCiAgICBpZiBtZXJnZV9tYXJrOgogICAgICAgIHAyID0gcmVwby5jaGFuZ2Vsb2cubm9kZShtYXJrX3RvX3JldihtZXJnZV9tYXJrKSkKICAgIGVsc2U6CiAgICAgICAgcDIgPSAnXDAnICogMjAKCiAgICAjCiAgICAjIElmIGZpbGVzIGNoYW5nZWQgZnJvbSBhbnkgb2YgdGhlIHBhcmVudHMsIGhnIHdhbnRzIHRvIGtub3csIGJ1dCBpbiBnaXQgaWYKICAgICMgbm90aGluZyBjaGFuZ2VkIGZyb20gdGhlIGZpcnN0IHBhcmVudCwgbm90aGluZyBjaGFuZ2VkLgogICAgIwogICAgaWYgbWVyZ2VfbWFyazoKICAgICAgICBnZXRfbWVyZ2VfZmlsZXMocmVwbywgcDEsIHAyLCBmaWxlcykKCiAgICAjIENoZWNrIGlmIHRoZSByZWYgaXMgc3VwcG9zZWQgdG8gYmUgYSBuYW1lZCBicmFuY2gKICAgIGlmIHJlZi5zdGFydHN3aXRoKCdyZWZzL2hlYWRzL2JyYW5jaGVzLycpOgogICAgICAgIGV4dHJhWydicmFuY2gnXSA9IHJlZltsZW4oJ3JlZnMvaGVhZHMvYnJhbmNoZXMvJyk6XQoKICAgIGlmIG1vZGUgPT0gJ2hnJzoKICAgICAgICBpID0gZGF0YS5maW5kKCdcbi0tSEctLVxuJykKICAgICAgICBpZiBpID49IDA6CiAgICAgICAgICAgIHRtcCA9IGRhdGFbaSArIGxlbignXG4tLUhHLS1cbicpOl0uc3RyaXAoKQogICAgICAgICAgICBmb3IgaywgdiBpbiBbZS5zcGxpdCgnIDogJywgMSkgZm9yIGUgaW4gdG1wLnNwbGl0KCdcbicpXToKICAgICAgICAgICAgICAgIGlmIGsgPT0gJ3JlbmFtZSc6CiAgICAgICAgICAgICAgICAgICAgb2xkLCBuZXcgPSB2LnNwbGl0KCcgPT4gJywgMSkKICAgICAgICAgICAgICAgICAgICBmaWxlc1tuZXddWydyZW5hbWUnXSA9IG9sZAogICAgICAgICAgICAgICAgZWxpZiBrID09ICdicmFuY2gnOgogICAgICAgICAgICAgICAgICAgIGV4dHJhW2tdID0gdgogICAgICAgICAgICAgICAgZWxpZiBrID09ICdleHRyYSc6CiAgICAgICAgICAgICAgICAgICAgZWssIGV2ID0gdi5zcGxpdCgnIDogJywgMSkKICAgICAgICAgICAgICAgICAgICBleHRyYVtla10gPSB1cmxsaWIudW5xdW90ZShldikKICAgICAgICAgICAgZGF0YSA9IGRhdGFbOmldCgogICAgY3R4ID0gY29udGV4dC5tZW1jdHgocmVwbywgKHAxLCBwMiksIGRhdGEsCiAgICAgICAgICAgIGZpbGVzLmtleXMoKSwgZ2V0ZmlsZWN0eCwKICAgICAgICAgICAgdXNlciwgKGRhdGUsIHR6KSwgZXh0cmEpCgogICAgdG1wID0gZW5jb2RpbmcuZW5jb2RpbmcKICAgIGVuY29kaW5nLmVuY29kaW5nID0gJ3V0Zi04JwoKICAgIG5vZGUgPSByZXBvLmNvbW1pdGN0eChjdHgpCgogICAgZW5jb2RpbmcuZW5jb2RpbmcgPSB0bXAKCiAgICByZXYgPSByZXBvW25vZGVdLnJldigpCgogICAgcGFyc2VkX3JlZnNbcmVmXSA9IG5vZGUKICAgIG1hcmtzLm5ld19tYXJrKHJldiwgY29tbWl0X21hcmspCgpkZWYgcGFyc2VfcmVzZXQocGFyc2VyKToKICAgIGdsb2JhbCBwYXJzZWRfcmVmcwoKICAgIHJlZiA9IHBhcnNlclsxXQogICAgcGFyc2VyLm5leHQoKQogICAgIyB1Z2gKICAgIGlmIHBhcnNlci5jaGVjaygnY29tbWl0Jyk6CiAgICAgICAgcGFyc2VfY29tbWl0KHBhcnNlcikKICAgICAgICByZXR1cm4KICAgIGlmIG5vdCBwYXJzZXIuY2hlY2soJ2Zyb20nKToKICAgICAgICByZXR1cm4KICAgIGZyb21fbWFyayA9IHBhcnNlci5nZXRfbWFyaygpCiAgICBwYXJzZXIubmV4dCgpCgogICAgbm9kZSA9IHBhcnNlci5yZXBvLmNoYW5nZWxvZy5ub2RlKG1hcmtfdG9fcmV2KGZyb21fbWFyaykpCiAgICBwYXJzZWRfcmVmc1tyZWZdID0gbm9kZQoKZGVmIHBhcnNlX3RhZyhwYXJzZXIpOgogICAgbmFtZSA9IHBhcnNlclsxXQogICAgcGFyc2VyLm5leHQoKQogICAgZnJvbV9tYXJrID0gcGFyc2VyLmdldF9tYXJrKCkKICAgIHBhcnNlci5uZXh0KCkKICAgIHRhZ2dlciA9IHBhcnNlci5nZXRfYXV0aG9yKCkKICAgIHBhcnNlci5uZXh0KCkKICAgIGRhdGEgPSBwYXJzZXIuZ2V0X2RhdGEoKQogICAgcGFyc2VyLm5leHQoKQoKICAgIHBhcnNlZF90YWdzW25hbWVdID0gKHRhZ2dlciwgZGF0YSkKCmRlZiB3cml0ZV90YWcocmVwbywgdGFnLCBub2RlLCBtc2csIGF1dGhvcik6CiAgICBicmFuY2ggPSByZXBvW25vZGVdLmJyYW5jaCgpCiAgICB0aXAgPSBicmFuY2hfdGlwKHJlcG8sIGJyYW5jaCkKICAgIHRpcCA9IHJlcG9bdGlwXQoKICAgIGRlZiBnZXRmaWxlY3R4KHJlcG8sIG1lbWN0eCwgZik6CiAgICAgICAgdHJ5OgogICAgICAgICAgICBmY3R4ID0gdGlwLmZpbGVjdHgoZikKICAgICAgICAgICAgZGF0YSA9IGZjdHguZGF0YSgpCiAgICAgICAgZXhjZXB0IGVycm9yLk1hbmlmZXN0TG9va3VwRXJyb3I6CiAgICAgICAgICAgIGRhdGEgPSAiIgogICAgICAgIGNvbnRlbnQgPSBkYXRhICsgIiVzICVzXG4iICUgKGhnaGV4KG5vZGUpLCB0YWcpCiAgICAgICAgcmV0dXJuIGNvbnRleHQubWVtZmlsZWN0eChmLCBjb250ZW50LCBGYWxzZSwgRmFsc2UsIE5vbmUpCgogICAgcDEgPSB0aXAuaGV4KCkKICAgIHAyID0gJ1wwJyAqIDIwCiAgICBpZiBub3QgYXV0aG9yOgogICAgICAgIGF1dGhvciA9IChOb25lLCAwLCAwKQogICAgdXNlciwgZGF0ZSwgdHogPSBhdXRob3IKCiAgICBjdHggPSBjb250ZXh0Lm1lbWN0eChyZXBvLCAocDEsIHAyKSwgbXNnLAogICAgICAgICAgICBbJy5oZ3RhZ3MnXSwgZ2V0ZmlsZWN0eCwKICAgICAgICAgICAgdXNlciwgKGRhdGUsIHR6KSwgeydicmFuY2gnIDogYnJhbmNofSkKCiAgICB0bXAgPSBlbmNvZGluZy5lbmNvZGluZwogICAgZW5jb2RpbmcuZW5jb2RpbmcgPSAndXRmLTgnCgogICAgdGFnbm9kZSA9IHJlcG8uY29tbWl0Y3R4KGN0eCkKCiAgICBlbmNvZGluZy5lbmNvZGluZyA9IHRtcAoKICAgIHJldHVybiB0YWdub2RlCgpkZWYgZG9fZXhwb3J0KHBhcnNlcik6CiAgICBnbG9iYWwgcGFyc2VkX3JlZnMsIGJtYXJrcywgcGVlcgoKICAgIHBfYm1hcmtzID0gW10KCiAgICBwYXJzZXIubmV4dCgpCgogICAgZm9yIGxpbmUgaW4gcGFyc2VyLmVhY2hfYmxvY2soJ2RvbmUnKToKICAgICAgICBpZiBwYXJzZXIuY2hlY2soJ2Jsb2InKToKICAgICAgICAgICAgcGFyc2VfYmxvYihwYXJzZXIpCiAgICAgICAgZWxpZiBwYXJzZXIuY2hlY2soJ2NvbW1pdCcpOgogICAgICAgICAgICBwYXJzZV9jb21taXQocGFyc2VyKQogICAgICAgIGVsaWYgcGFyc2VyLmNoZWNrKCdyZXNldCcpOgogICAgICAgICAgICBwYXJzZV9yZXNldChwYXJzZXIpCiAgICAgICAgZWxpZiBwYXJzZXIuY2hlY2soJ3RhZycpOgogICAgICAgICAgICBwYXJzZV90YWcocGFyc2VyKQogICAgICAgIGVsaWYgcGFyc2VyLmNoZWNrKCdmZWF0dXJlJyk6CiAgICAgICAgICAgIHBhc3MKICAgICAgICBlbHNlOgogICAgICAgICAgICBkaWUoJ3VuaGFuZGxlZCBleHBvcnQgY29tbWFuZDogJXMnICUgbGluZSkKCiAgICBmb3IgcmVmLCBub2RlIGluIHBhcnNlZF9yZWZzLml0ZXJpdGVtcygpOgogICAgICAgIGlmIHJlZi5zdGFydHN3aXRoKCdyZWZzL2hlYWRzL2JyYW5jaGVzJyk6CiAgICAgICAgICAgIGJyYW5jaCA9IHJlZltsZW4oJ3JlZnMvaGVhZHMvYnJhbmNoZXMvJyk6XQogICAgICAgICAgICBpZiBicmFuY2ggaW4gYnJhbmNoZXMgYW5kIG5vZGUgaW4gYnJhbmNoZXNbYnJhbmNoXToKICAgICAgICAgICAgICAgICMgdXAgdG8gZGF0ZQogICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgcHJpbnQgIm9rICVzIiAlIHJlZgogICAgICAgIGVsaWYgcmVmLnN0YXJ0c3dpdGgoJ3JlZnMvaGVhZHMvJyk6CiAgICAgICAgICAgIGJtYXJrID0gcmVmW2xlbigncmVmcy9oZWFkcy8nKTpdCiAgICAgICAgICAgIHBfYm1hcmtzLmFwcGVuZCgoYm1hcmssIG5vZGUpKQogICAgICAgICAgICBjb250aW51ZQogICAgICAgIGVsaWYgcmVmLnN0YXJ0c3dpdGgoJ3JlZnMvdGFncy8nKToKICAgICAgICAgICAgdGFnID0gcmVmW2xlbigncmVmcy90YWdzLycpOl0KICAgICAgICAgICAgYXV0aG9yLCBtc2cgPSBwYXJzZWRfdGFncy5nZXQodGFnLCAoTm9uZSwgTm9uZSkpCiAgICAgICAgICAgIGlmIG1vZGUgPT0gJ2dpdCc6CiAgICAgICAgICAgICAgICBpZiBub3QgbXNnOgogICAgICAgICAgICAgICAgICAgIG1zZyA9ICdBZGRlZCB0YWcgJXMgZm9yIGNoYW5nZXNldCAlcycgJSAodGFnLCBoZ2hleChub2RlWzo2XSkpOwogICAgICAgICAgICAgICAgd3JpdGVfdGFnKHBhcnNlci5yZXBvLCB0YWcsIG5vZGUsIG1zZywgYXV0aG9yKQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgZnAgPSBwYXJzZXIucmVwby5vcGVuZXIoJ2xvY2FsdGFncycsICdhJykKICAgICAgICAgICAgICAgIGZwLndyaXRlKCclcyAlc1xuJyAlIChoZ2hleChub2RlKSwgdGFnKSkKICAgICAgICAgICAgICAgIGZwLmNsb3NlKCkKICAgICAgICAgICAgcHJpbnQgIm9rICVzIiAlIHJlZgogICAgICAgIGVsc2U6CiAgICAgICAgICAgICMgdHJhbnNwb3J0LWhlbHBlci9mYXN0LWV4cG9ydCBidWdzCiAgICAgICAgICAgIGNvbnRpbnVlCgogICAgaWYgcGVlcjoKICAgICAgICBwYXJzZXIucmVwby5wdXNoKHBlZXIsIGZvcmNlPWZvcmNlX3B1c2gpCgogICAgIyBoYW5kbGUgYm9va21hcmtzCiAgICBmb3IgYm1hcmssIG5vZGUgaW4gcF9ibWFya3M6CiAgICAgICAgcmVmID0gJ3JlZnMvaGVhZHMvJyArIGJtYXJrCiAgICAgICAgbmV3ID0gaGdoZXgobm9kZSkKCiAgICAgICAgaWYgYm1hcmsgaW4gYm1hcmtzOgogICAgICAgICAgICBvbGQgPSBibWFya3NbYm1hcmtdLmhleCgpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgb2xkID0gJycKCiAgICAgICAgaWYgYm1hcmsgPT0gJ21hc3RlcicgYW5kICdtYXN0ZXInIG5vdCBpbiBwYXJzZXIucmVwby5fYm9va21hcmtzOgogICAgICAgICAgICAjIGZha2UgYm9va21hcmsKICAgICAgICAgICAgcGFzcwogICAgICAgIGVsaWYgYm9va21hcmtzLnB1c2hib29rbWFyayhwYXJzZXIucmVwbywgYm1hcmssIG9sZCwgbmV3KToKICAgICAgICAgICAgIyB1cGRhdGVkIGxvY2FsbHkKICAgICAgICAgICAgcGFzcwogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHByaW50ICJlcnJvciAlcyIgJSByZWYKICAgICAgICAgICAgY29udGludWUKCiAgICAgICAgaWYgcGVlcjoKICAgICAgICAgICAgcmIgPSBwZWVyLmxpc3RrZXlzKCdib29rbWFya3MnKQogICAgICAgICAgICBvbGQgPSByYi5nZXQoYm1hcmssICcnKQogICAgICAgICAgICBpZiBub3QgcGVlci5wdXNoa2V5KCdib29rbWFya3MnLCBibWFyaywgb2xkLCBuZXcpOgogICAgICAgICAgICAgICAgcHJpbnQgImVycm9yICVzIiAlIHJlZgogICAgICAgICAgICAgICAgY29udGludWUKCiAgICAgICAgcHJpbnQgIm9rICVzIiAlIHJlZgoKICAgIHByaW50CgpkZWYgZml4X3BhdGgoYWxpYXMsIHJlcG8sIG9yaWdfdXJsKToKICAgIHVybCA9IHVybHBhcnNlLnVybHBhcnNlKG9yaWdfdXJsLCAnZmlsZScpCiAgICBpZiB1cmwuc2NoZW1lICE9ICdmaWxlJyBvciBvcy5wYXRoLmlzYWJzKHVybC5wYXRoKToKICAgICAgICByZXR1cm4KICAgIGFic191cmwgPSB1cmxwYXJzZS51cmxqb2luKCIlcy8iICUgb3MuZ2V0Y3dkKCksIG9yaWdfdXJsKQogICAgY21kID0gWydnaXQnLCAnY29uZmlnJywgJ3JlbW90ZS4lcy51cmwnICUgYWxpYXMsICJoZzo6JXMiICUgYWJzX3VybF0KICAgIHN1YnByb2Nlc3MuY2FsbChjbWQpCgpkZWYgbWFpbihhcmdzKToKICAgIGdsb2JhbCBwcmVmaXgsIGRpcm5hbWUsIGJyYW5jaGVzLCBibWFya3MKICAgIGdsb2JhbCBtYXJrcywgYmxvYl9tYXJrcywgcGFyc2VkX3JlZnMKICAgIGdsb2JhbCBwZWVyLCBtb2RlLCBiYWRfbWFpbCwgYmFkX25hbWUKICAgIGdsb2JhbCB0cmFja19icmFuY2hlcywgZm9yY2VfcHVzaCwgaXNfdG1wCiAgICBnbG9iYWwgcGFyc2VkX3RhZ3MKCiAgICBhbGlhcyA9IGFyZ3NbMV0KICAgIHVybCA9IGFyZ3NbMl0KICAgIHBlZXIgPSBOb25lCgogICAgaGdfZ2l0X2NvbXBhdCA9IEZhbHNlCiAgICB0cmFja19icmFuY2hlcyA9IFRydWUKICAgIGZvcmNlX3B1c2ggPSBUcnVlCgogICAgdHJ5OgogICAgICAgIGlmIGdldF9jb25maWcoJ3JlbW90ZS1oZy5oZy1naXQtY29tcGF0JykgPT0gJ3RydWVcbic6CiAgICAgICAgICAgIGhnX2dpdF9jb21wYXQgPSBUcnVlCiAgICAgICAgICAgIHRyYWNrX2JyYW5jaGVzID0gRmFsc2UKICAgICAgICBpZiBnZXRfY29uZmlnKCdyZW1vdGUtaGcudHJhY2stYnJhbmNoZXMnKSA9PSAnZmFsc2Vcbic6CiAgICAgICAgICAgIHRyYWNrX2JyYW5jaGVzID0gRmFsc2UKICAgICAgICBpZiBnZXRfY29uZmlnKCdyZW1vdGUtaGcuZm9yY2UtcHVzaCcpID09ICdmYWxzZVxuJzoKICAgICAgICAgICAgZm9yY2VfcHVzaCA9IEZhbHNlCiAgICBleGNlcHQgc3VicHJvY2Vzcy5DYWxsZWRQcm9jZXNzRXJyb3I6CiAgICAgICAgcGFzcwoKICAgIGlmIGhnX2dpdF9jb21wYXQ6CiAgICAgICAgbW9kZSA9ICdoZycKICAgICAgICBiYWRfbWFpbCA9ICdub25lQG5vbmUnCiAgICAgICAgYmFkX25hbWUgPSAnJwogICAgZWxzZToKICAgICAgICBtb2RlID0gJ2dpdCcKICAgICAgICBiYWRfbWFpbCA9ICd1bmtub3duJwogICAgICAgIGJhZF9uYW1lID0gJ1Vua25vd24nCgogICAgaWYgYWxpYXNbNDpdID09IHVybDoKICAgICAgICBpc190bXAgPSBUcnVlCiAgICAgICAgYWxpYXMgPSB1dGlsLnNoYTEoYWxpYXMpLmhleGRpZ2VzdCgpCiAgICBlbHNlOgogICAgICAgIGlzX3RtcCA9IEZhbHNlCgogICAgZ2l0ZGlyID0gb3MuZW52aXJvblsnR0lUX0RJUiddCiAgICBkaXJuYW1lID0gb3MucGF0aC5qb2luKGdpdGRpciwgJ2hnJywgYWxpYXMpCiAgICBicmFuY2hlcyA9IHt9CiAgICBibWFya3MgPSB7fQogICAgYmxvYl9tYXJrcyA9IHt9CiAgICBwYXJzZWRfcmVmcyA9IHt9CiAgICBtYXJrcyA9IE5vbmUKICAgIHBhcnNlZF90YWdzID0ge30KCiAgICByZXBvID0gZ2V0X3JlcG8odXJsLCBhbGlhcykKICAgIHByZWZpeCA9ICdyZWZzL2hnLyVzJyAlIGFsaWFzCgogICAgaWYgbm90IGlzX3RtcDoKICAgICAgICBmaXhfcGF0aChhbGlhcywgcGVlciBvciByZXBvLCB1cmwpCgogICAgaWYgbm90IG9zLnBhdGguZXhpc3RzKGRpcm5hbWUpOgogICAgICAgIG9zLm1ha2VkaXJzKGRpcm5hbWUpCgogICAgbWFya3NfcGF0aCA9IG9zLnBhdGguam9pbihkaXJuYW1lLCAnbWFya3MtaGcnKQogICAgbWFya3MgPSBNYXJrcyhtYXJrc19wYXRoKQoKICAgIHBhcnNlciA9IFBhcnNlcihyZXBvKQogICAgZm9yIGxpbmUgaW4gcGFyc2VyOgogICAgICAgIGlmIHBhcnNlci5jaGVjaygnY2FwYWJpbGl0aWVzJyk6CiAgICAgICAgICAgIGRvX2NhcGFiaWxpdGllcyhwYXJzZXIpCiAgICAgICAgZWxpZiBwYXJzZXIuY2hlY2soJ2xpc3QnKToKICAgICAgICAgICAgZG9fbGlzdChwYXJzZXIpCiAgICAgICAgZWxpZiBwYXJzZXIuY2hlY2soJ2ltcG9ydCcpOgogICAgICAgICAgICBkb19pbXBvcnQocGFyc2VyKQogICAgICAgIGVsaWYgcGFyc2VyLmNoZWNrKCdleHBvcnQnKToKICAgICAgICAgICAgZG9fZXhwb3J0KHBhcnNlcikKICAgICAgICBlbHNlOgogICAgICAgICAgICBkaWUoJ3VuaGFuZGxlZCBjb21tYW5kOiAlcycgJSBsaW5lKQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQoKZGVmIGJ5ZSgpOgogICAgaWYgbm90IG1hcmtzOgogICAgICAgIHJldHVybgogICAgaWYgbm90IGlzX3RtcDoKICAgICAgICBtYXJrcy5zdG9yZSgpCiAgICBlbHNlOgogICAgICAgIHNodXRpbC5ybXRyZWUoZGlybmFtZSkKCmF0ZXhpdC5yZWdpc3RlcihieWUpCnN5cy5leGl0KG1haW4oc3lzLmFyZ3YpKQo=",
    "text": "#!/usr/bin/env python\n#\n# Copyright (c) 2012 Felipe Contreras\n#\n\n# Inspired by Rocco Rutte's hg-fast-export\n\n# Just copy to your ~/bin, or anywhere in your $PATH.\n# Then you can clone with:\n# git clone hg::/path/to/mercurial/repo/\n#\n# For remote repositories a local clone is stored in\n# \"$GIT_DIR/hg/origin/clone/.hg/\".\n\nfrom mercurial import hg, ui, bookmarks, context, util, encoding, node, error\n\nimport re\nimport sys\nimport os\nimport json\nimport shutil\nimport subprocess\nimport urllib\nimport atexit\nimport urlparse\n\n#\n# If you want to switch to hg-git compatibility mode:\n# git config --global remote-hg.hg-git-compat true\n#\n# If you are not in hg-git-compat mode and want to disable the tracking of\n# named branches:\n# git config --global remote-hg.track-branches false\n#\n# If you don't want to force pushes (and thus risk creating new remote heads):\n# git config --global remote-hg.force-push false\n#\n# If you want the equivalent of hg's clone/pull--insecure option:\n# git config remote-hg.insecure true\n#\n# git:\n# Sensible defaults for git.\n# hg bookmarks are exported as git branches, hg branches are prefixed\n# with 'branches/', HEAD is a special case.\n#\n# hg:\n# Emulate hg-git.\n# Only hg bookmarks are exported as git branches.\n# Commits are modified to preserve hg information and allow bidirectionality.\n#\n\nNAME_RE = re.compile('^([^<>]+)')\nAUTHOR_RE = re.compile('^([^<>]+?)? ?<([^<>]*)>$')\nEMAIL_RE = re.compile('^([^<>]+[^ \\\\\\t<>])?\\\\b(?:[ \\\\t<>]*?)\\\\b([^ \\\\t<>]+@[^ \\\\t<>]+)')\nAUTHOR_HG_RE = re.compile('^(.*?) ?<(.*?)(?:>(.+)?)?$')\nRAW_AUTHOR_RE = re.compile('^(\\w+) (?:(.+)? )?<(.*)> (\\d+) ([+-]\\d+)')\n\ndef die(msg, *args):\n    sys.stderr.write('ERROR: %s\\n' % (msg % args))\n    sys.exit(1)\n\ndef warn(msg, *args):\n    sys.stderr.write('WARNING: %s\\n' % (msg % args))\n\ndef gitmode(flags):\n    return 'l' in flags and '120000' or 'x' in flags and '100755' or '100644'\n\ndef gittz(tz):\n    return '%+03d%02d' % (-tz / 3600, -tz % 3600 / 60)\n\ndef hgmode(mode):\n    m = { '100755': 'x', '120000': 'l' }\n    return m.get(mode, '')\n\ndef hghex(node):\n    return hg.node.hex(node)\n\ndef get_config(config):\n    cmd = ['git', 'config', '--get', config]\n    process = subprocess.Popen(cmd, stdout=subprocess.PIPE)\n    output, _ = process.communicate()\n    return output\n\nclass Marks:\n\n    def __init__(self, path):\n        self.path = path\n        self.tips = {}\n        self.marks = {}\n        self.rev_marks = {}\n        self.last_mark = 0\n\n        self.load()\n\n    def load(self):\n        if not os.path.exists(self.path):\n            return\n\n        tmp = json.load(open(self.path))\n\n        self.tips = tmp['tips']\n        self.marks = tmp['marks']\n        self.last_mark = tmp['last-mark']\n\n        for rev, mark in self.marks.iteritems():\n            self.rev_marks[mark] = int(rev)\n\n    def dict(self):\n        return { 'tips': self.tips, 'marks': self.marks, 'last-mark' : self.last_mark }\n\n    def store(self):\n        json.dump(self.dict(), open(self.path, 'w'))\n\n    def __str__(self):\n        return str(self.dict())\n\n    def from_rev(self, rev):\n        return self.marks[str(rev)]\n\n    def to_rev(self, mark):\n        return self.rev_marks[mark]\n\n    def get_mark(self, rev):\n        self.last_mark += 1\n        self.marks[str(rev)] = self.last_mark\n        return self.last_mark\n\n    def new_mark(self, rev, mark):\n        self.marks[str(rev)] = mark\n        self.rev_marks[mark] = rev\n        self.last_mark = mark\n\n    def is_marked(self, rev):\n        return str(rev) in self.marks\n\n    def get_tip(self, branch):\n        return self.tips.get(branch, 0)\n\n    def set_tip(self, branch, tip):\n        self.tips[branch] = tip\n\nclass Parser:\n\n    def __init__(self, repo):\n        self.repo = repo\n        self.line = self.get_line()\n\n    def get_line(self):\n        return sys.stdin.readline().strip()\n\n    def __getitem__(self, i):\n        return self.line.split()[i]\n\n    def check(self, word):\n        return self.line.startswith(word)\n\n    def each_block(self, separator):\n        while self.line != separator:\n            yield self.line\n            self.line = self.get_line()\n\n    def __iter__(self):\n        return self.each_block('')\n\n    def next(self):\n        self.line = self.get_line()\n        if self.line == 'done':\n            self.line = None\n\n    def get_mark(self):\n        i = self.line.index(':') + 1\n        return int(self.line[i:])\n\n    def get_data(self):\n        if not self.check('data'):\n            return None\n        i = self.line.index(' ') + 1\n        size = int(self.line[i:])\n        return sys.stdin.read(size)\n\n    def get_author(self):\n        global bad_mail\n\n        ex = None\n        m = RAW_AUTHOR_RE.match(self.line)\n        if not m:\n            return None\n        _, name, email, date, tz = m.groups()\n        if name and 'ext:' in name:\n            m = re.match('^(.+?) ext:\\((.+)\\)$', name)\n            if m:\n                name = m.group(1)\n                ex = urllib.unquote(m.group(2))\n\n        if email != bad_mail:\n            if name:\n                user = '%s <%s>' % (name, email)\n            else:\n                user = '<%s>' % (email)\n        else:\n            user = name\n\n        if ex:\n            user += ex\n\n        tz = int(tz)\n        tz = ((tz / 100) * 3600) + ((tz % 100) * 60)\n        return (user, int(date), -tz)\n\ndef fix_file_path(path):\n    if not os.path.isabs(path):\n        return path\n    return os.path.relpath(path, '/')\n\ndef export_file(fc):\n    d = fc.data()\n    path = fix_file_path(fc.path())\n    print \"M %s inline %s\" % (gitmode(fc.flags()), path)\n    print \"data %d\" % len(d)\n    print d\n\ndef get_filechanges(repo, ctx, parent):\n    modified = set()\n    added = set()\n    removed = set()\n\n    cur = ctx.manifest()\n    prev = repo[parent].manifest().copy()\n\n    for fn in cur:\n        if fn in prev:\n            if (cur.flags(fn) != prev.flags(fn) or cur[fn] != prev[fn]):\n                modified.add(fn)\n            del prev[fn]\n        else:\n            added.add(fn)\n    removed |= set(prev.keys())\n\n    return added | modified, removed\n\ndef fixup_user_git(user):\n    name = mail = None\n    user = user.replace('\"', '')\n    m = AUTHOR_RE.match(user)\n    if m:\n        name = m.group(1)\n        mail = m.group(2).strip()\n    else:\n        m = EMAIL_RE.match(user)\n        if m:\n            name = m.group(1)\n            mail = m.group(2)\n        else:\n            m = NAME_RE.match(user)\n            if m:\n                name = m.group(1).strip()\n    return (name, mail)\n\ndef fixup_user_hg(user):\n    def sanitize(name):\n        # stole this from hg-git\n        return re.sub('[<>\\n]', '?', name.lstrip('< ').rstrip('> '))\n\n    m = AUTHOR_HG_RE.match(user)\n    if m:\n        name = sanitize(m.group(1))\n        mail = sanitize(m.group(2))\n        ex = m.group(3)\n        if ex:\n            name += ' ext:(' + urllib.quote(ex) + ')'\n    else:\n        name = sanitize(user)\n        if '@' in user:\n            mail = name\n        else:\n            mail = None\n\n    return (name, mail)\n\ndef fixup_user(user):\n    global mode, bad_mail\n\n    if mode == 'git':\n        name, mail = fixup_user_git(user)\n    else:\n        name, mail = fixup_user_hg(user)\n\n    if not name:\n        name = bad_name\n    if not mail:\n        mail = bad_mail\n\n    return '%s <%s>' % (name, mail)\n\ndef get_repo(url, alias):\n    global dirname, peer\n\n    myui = ui.ui()\n    myui.setconfig('ui', 'interactive', 'off')\n    myui.fout = sys.stderr\n\n    try:\n        if get_config('remote-hg.insecure') == 'true\\n':\n            myui.setconfig('web', 'cacerts', '')\n    except subprocess.CalledProcessError:\n        pass\n\n    if hg.islocal(url):\n        repo = hg.repository(myui, url)\n    else:\n        local_path = os.path.join(dirname, 'clone')\n        if not os.path.exists(local_path):\n            try:\n                peer, dstpeer = hg.clone(myui, {}, url, local_path, update=True, pull=True)\n            except:\n                die('Repository error')\n            repo = dstpeer.local()\n        else:\n            repo = hg.repository(myui, local_path)\n            try:\n                peer = hg.peer(myui, {}, url)\n            except:\n                die('Repository error')\n            repo.pull(peer, heads=None, force=True)\n\n    return repo\n\ndef rev_to_mark(rev):\n    global marks\n    return marks.from_rev(rev)\n\ndef mark_to_rev(mark):\n    global marks\n    return marks.to_rev(mark)\n\ndef export_ref(repo, name, kind, head):\n    global prefix, marks, mode\n\n    ename = '%s/%s' % (kind, name)\n    tip = marks.get_tip(ename)\n\n    # mercurial takes too much time checking this\n    if tip and tip == head.rev():\n        # nothing to do\n        return\n    revs = xrange(tip, head.rev() + 1)\n    count = 0\n\n    revs = [rev for rev in revs if not marks.is_marked(rev)]\n\n    for rev in revs:\n\n        c = repo[rev]\n        (manifest, user, (time, tz), files, desc, extra) = repo.changelog.read(c.node())\n        rev_branch = extra['branch']\n\n        author = \"%s %d %s\" % (fixup_user(user), time, gittz(tz))\n        if 'committer' in extra:\n            user, time, tz = extra['committer'].rsplit(' ', 2)\n            committer = \"%s %s %s\" % (user, time, gittz(int(tz)))\n        else:\n            committer = author\n\n        parents = [p for p in repo.changelog.parentrevs(rev) if p >= 0]\n\n        if len(parents) == 0:\n            modified = c.manifest().keys()\n            removed = []\n        else:\n            modified, removed = get_filechanges(repo, c, parents[0])\n\n        desc += '\\n'\n\n        if mode == 'hg':\n            extra_msg = ''\n\n            if rev_branch != 'default':\n                extra_msg += 'branch : %s\\n' % rev_branch\n\n            renames = []\n            for f in c.files():\n                if f not in c.manifest():\n                    continue\n                rename = c.filectx(f).renamed()\n                if rename:\n                    renames.append((rename[0], f))\n\n            for e in renames:\n                extra_msg += \"rename : %s => %s\\n\" % e\n\n            for key, value in extra.iteritems():\n                if key in ('author', 'committer', 'encoding', 'message', 'branch', 'hg-git'):\n                    continue\n                else:\n                    extra_msg += \"extra : %s : %s\\n\" % (key, urllib.quote(value))\n\n            if extra_msg:\n                desc += '\\n--HG--\\n' + extra_msg\n\n        if len(parents) == 0 and rev:\n            print 'reset %s/%s' % (prefix, ename)\n\n        print \"commit %s/%s\" % (prefix, ename)\n        print \"mark :%d\" % (marks.get_mark(rev))\n        print \"author %s\" % (author)\n        print \"committer %s\" % (committer)\n        print \"data %d\" % (len(desc))\n        print desc\n\n        if len(parents) > 0:\n            print \"from :%s\" % (rev_to_mark(parents[0]))\n            if len(parents) > 1:\n                print \"merge :%s\" % (rev_to_mark(parents[1]))\n\n        for f in modified:\n            export_file(c.filectx(f))\n        for f in removed:\n            print \"D %s\" % (fix_file_path(f))\n        print\n\n        count += 1\n        if (count % 100 == 0):\n            print \"progress revision %d '%s' (%d/%d)\" % (rev, name, count, len(revs))\n            print \"#############################################################\"\n\n    # make sure the ref is updated\n    print \"reset %s/%s\" % (prefix, ename)\n    print \"from :%u\" % rev_to_mark(rev)\n    print\n\n    marks.set_tip(ename, rev)\n\ndef export_tag(repo, tag):\n    export_ref(repo, tag, 'tags', repo[tag])\n\ndef export_bookmark(repo, bmark):\n    head = bmarks[bmark]\n    export_ref(repo, bmark, 'bookmarks', head)\n\ndef export_branch(repo, branch):\n    tip = get_branch_tip(repo, branch)\n    head = repo[tip]\n    export_ref(repo, branch, 'branches', head)\n\ndef export_head(repo):\n    global g_head\n    export_ref(repo, g_head[0], 'bookmarks', g_head[1])\n\ndef do_capabilities(parser):\n    global prefix, dirname\n\n    print \"import\"\n    print \"export\"\n    print \"refspec refs/heads/branches/*:%s/branches/*\" % prefix\n    print \"refspec refs/heads/*:%s/bookmarks/*\" % prefix\n    print \"refspec refs/tags/*:%s/tags/*\" % prefix\n\n    path = os.path.join(dirname, 'marks-git')\n\n    if os.path.exists(path):\n        print \"*import-marks %s\" % path\n    print \"*export-marks %s\" % path\n\n    print\n\ndef branch_tip(repo, branch):\n    # older versions of mercurial don't have this\n    if hasattr(repo, 'branchtip'):\n        return repo.branchtip(branch)\n    else:\n        return repo.branchtags()[branch]\n\ndef get_branch_tip(repo, branch):\n    global branches\n\n    heads = branches.get(branch, None)\n    if not heads:\n        return None\n\n    # verify there's only one head\n    if (len(heads) > 1):\n        warn(\"Branch '%s' has more than one head, consider merging\" % branch)\n        return branch_tip(repo, branch)\n\n    return heads[0]\n\ndef list_head(repo, cur):\n    global g_head, bmarks\n\n    head = bookmarks.readcurrent(repo)\n    if head:\n        node = repo[head]\n    else:\n        # fake bookmark from current branch\n        head = cur\n        node = repo['.']\n        if not node:\n            node = repo['tip']\n        if not node:\n            return\n        if head == 'default':\n            head = 'master'\n        bmarks[head] = node\n\n    print \"@refs/heads/%s HEAD\" % head\n    g_head = (head, node)\n\ndef do_list(parser):\n    global branches, bmarks, mode, track_branches\n\n    repo = parser.repo\n    for bmark, node in bookmarks.listbookmarks(repo).iteritems():\n        bmarks[bmark] = repo[node]\n\n    cur = repo.dirstate.branch()\n\n    list_head(repo, cur)\n\n    if track_branches:\n        for branch in repo.branchmap():\n            heads = repo.branchheads(branch)\n            if len(heads):\n                branches[branch] = heads\n\n        for branch in branches:\n            print \"? refs/heads/branches/%s\" % branch\n\n    for bmark in bmarks:\n        print \"? refs/heads/%s\" % bmark\n\n    for tag, node in repo.tagslist():\n        if tag == 'tip':\n            continue\n        print \"? refs/tags/%s\" % tag\n\n    print\n\ndef do_import(parser):\n    repo = parser.repo\n\n    path = os.path.join(dirname, 'marks-git')\n\n    print \"feature done\"\n    if os.path.exists(path):\n        print \"feature import-marks=%s\" % path\n    print \"feature export-marks=%s\" % path\n    sys.stdout.flush()\n\n    tmp = encoding.encoding\n    encoding.encoding = 'utf-8'\n\n    # lets get all the import lines\n    while parser.check('import'):\n        ref = parser[1]\n\n        if (ref == 'HEAD'):\n            export_head(repo)\n        elif ref.startswith('refs/heads/branches/'):\n            branch = ref[len('refs/heads/branches/'):]\n            export_branch(repo, branch)\n        elif ref.startswith('refs/heads/'):\n            bmark = ref[len('refs/heads/'):]\n            export_bookmark(repo, bmark)\n        elif ref.startswith('refs/tags/'):\n            tag = ref[len('refs/tags/'):]\n            export_tag(repo, tag)\n\n        parser.next()\n\n    encoding.encoding = tmp\n\n    print 'done'\n\ndef parse_blob(parser):\n    global blob_marks\n\n    parser.next()\n    mark = parser.get_mark()\n    parser.next()\n    data = parser.get_data()\n    blob_marks[mark] = data\n    parser.next()\n\ndef get_merge_files(repo, p1, p2, files):\n    for e in repo[p1].files():\n        if e not in files:\n            if e not in repo[p1].manifest():\n                continue\n            f = { 'ctx' : repo[p1][e] }\n            files[e] = f\n\ndef parse_commit(parser):\n    global marks, blob_marks, parsed_refs\n    global mode\n\n    from_mark = merge_mark = None\n\n    ref = parser[1]\n    parser.next()\n\n    commit_mark = parser.get_mark()\n    parser.next()\n    author = parser.get_author()\n    parser.next()\n    committer = parser.get_author()\n    parser.next()\n    data = parser.get_data()\n    parser.next()\n    if parser.check('from'):\n        from_mark = parser.get_mark()\n        parser.next()\n    if parser.check('merge'):\n        merge_mark = parser.get_mark()\n        parser.next()\n        if parser.check('merge'):\n            die('octopus merges are not supported yet')\n\n    files = {}\n\n    for line in parser:\n        if parser.check('M'):\n            t, m, mark_ref, path = line.split(' ', 3)\n            mark = int(mark_ref[1:])\n            f = { 'mode' : hgmode(m), 'data' : blob_marks[mark] }\n        elif parser.check('D'):\n            t, path = line.split(' ', 1)\n            f = { 'deleted' : True }\n        else:\n            die('Unknown file command: %s' % line)\n        files[path] = f\n\n    def getfilectx(repo, memctx, f):\n        of = files[f]\n        if 'deleted' in of:\n            raise IOError\n        if 'ctx' in of:\n            return of['ctx']\n        is_exec = of['mode'] == 'x'\n        is_link = of['mode'] == 'l'\n        rename = of.get('rename', None)\n        return context.memfilectx(f, of['data'],\n                is_link, is_exec, rename)\n\n    repo = parser.repo\n\n    user, date, tz = author\n    extra = {}\n\n    if committer != author:\n        extra['committer'] = \"%s %u %u\" % committer\n\n    if from_mark:\n        p1 = repo.changelog.node(mark_to_rev(from_mark))\n    else:\n        p1 = '\\0' * 20\n\n    if merge_mark:\n        p2 = repo.changelog.node(mark_to_rev(merge_mark))\n    else:\n        p2 = '\\0' * 20\n\n    #\n    # If files changed from any of the parents, hg wants to know, but in git if\n    # nothing changed from the first parent, nothing changed.\n    #\n    if merge_mark:\n        get_merge_files(repo, p1, p2, files)\n\n    # Check if the ref is supposed to be a named branch\n    if ref.startswith('refs/heads/branches/'):\n        extra['branch'] = ref[len('refs/heads/branches/'):]\n\n    if mode == 'hg':\n        i = data.find('\\n--HG--\\n')\n        if i >= 0:\n            tmp = data[i + len('\\n--HG--\\n'):].strip()\n            for k, v in [e.split(' : ', 1) for e in tmp.split('\\n')]:\n                if k == 'rename':\n                    old, new = v.split(' => ', 1)\n                    files[new]['rename'] = old\n                elif k == 'branch':\n                    extra[k] = v\n                elif k == 'extra':\n                    ek, ev = v.split(' : ', 1)\n                    extra[ek] = urllib.unquote(ev)\n            data = data[:i]\n\n    ctx = context.memctx(repo, (p1, p2), data,\n            files.keys(), getfilectx,\n            user, (date, tz), extra)\n\n    tmp = encoding.encoding\n    encoding.encoding = 'utf-8'\n\n    node = repo.commitctx(ctx)\n\n    encoding.encoding = tmp\n\n    rev = repo[node].rev()\n\n    parsed_refs[ref] = node\n    marks.new_mark(rev, commit_mark)\n\ndef parse_reset(parser):\n    global parsed_refs\n\n    ref = parser[1]\n    parser.next()\n    # ugh\n    if parser.check('commit'):\n        parse_commit(parser)\n        return\n    if not parser.check('from'):\n        return\n    from_mark = parser.get_mark()\n    parser.next()\n\n    node = parser.repo.changelog.node(mark_to_rev(from_mark))\n    parsed_refs[ref] = node\n\ndef parse_tag(parser):\n    name = parser[1]\n    parser.next()\n    from_mark = parser.get_mark()\n    parser.next()\n    tagger = parser.get_author()\n    parser.next()\n    data = parser.get_data()\n    parser.next()\n\n    parsed_tags[name] = (tagger, data)\n\ndef write_tag(repo, tag, node, msg, author):\n    branch = repo[node].branch()\n    tip = branch_tip(repo, branch)\n    tip = repo[tip]\n\n    def getfilectx(repo, memctx, f):\n        try:\n            fctx = tip.filectx(f)\n            data = fctx.data()\n        except error.ManifestLookupError:\n            data = \"\"\n        content = data + \"%s %s\\n\" % (hghex(node), tag)\n        return context.memfilectx(f, content, False, False, None)\n\n    p1 = tip.hex()\n    p2 = '\\0' * 20\n    if not author:\n        author = (None, 0, 0)\n    user, date, tz = author\n\n    ctx = context.memctx(repo, (p1, p2), msg,\n            ['.hgtags'], getfilectx,\n            user, (date, tz), {'branch' : branch})\n\n    tmp = encoding.encoding\n    encoding.encoding = 'utf-8'\n\n    tagnode = repo.commitctx(ctx)\n\n    encoding.encoding = tmp\n\n    return tagnode\n\ndef do_export(parser):\n    global parsed_refs, bmarks, peer\n\n    p_bmarks = []\n\n    parser.next()\n\n    for line in parser.each_block('done'):\n        if parser.check('blob'):\n            parse_blob(parser)\n        elif parser.check('commit'):\n            parse_commit(parser)\n        elif parser.check('reset'):\n            parse_reset(parser)\n        elif parser.check('tag'):\n            parse_tag(parser)\n        elif parser.check('feature'):\n            pass\n        else:\n            die('unhandled export command: %s' % line)\n\n    for ref, node in parsed_refs.iteritems():\n        if ref.startswith('refs/heads/branches'):\n            branch = ref[len('refs/heads/branches/'):]\n            if branch in branches and node in branches[branch]:\n                # up to date\n                continue\n            print \"ok %s\" % ref\n        elif ref.startswith('refs/heads/'):\n            bmark = ref[len('refs/heads/'):]\n            p_bmarks.append((bmark, node))\n            continue\n        elif ref.startswith('refs/tags/'):\n            tag = ref[len('refs/tags/'):]\n            author, msg = parsed_tags.get(tag, (None, None))\n            if mode == 'git':\n                if not msg:\n                    msg = 'Added tag %s for changeset %s' % (tag, hghex(node[:6]));\n                write_tag(parser.repo, tag, node, msg, author)\n            else:\n                fp = parser.repo.opener('localtags', 'a')\n                fp.write('%s %s\\n' % (hghex(node), tag))\n                fp.close()\n            print \"ok %s\" % ref\n        else:\n            # transport-helper/fast-export bugs\n            continue\n\n    if peer:\n        parser.repo.push(peer, force=force_push)\n\n    # handle bookmarks\n    for bmark, node in p_bmarks:\n        ref = 'refs/heads/' + bmark\n        new = hghex(node)\n\n        if bmark in bmarks:\n            old = bmarks[bmark].hex()\n        else:\n            old = ''\n\n        if bmark == 'master' and 'master' not in parser.repo._bookmarks:\n            # fake bookmark\n            pass\n        elif bookmarks.pushbookmark(parser.repo, bmark, old, new):\n            # updated locally\n            pass\n        else:\n            print \"error %s\" % ref\n            continue\n\n        if peer:\n            rb = peer.listkeys('bookmarks')\n            old = rb.get(bmark, '')\n            if not peer.pushkey('bookmarks', bmark, old, new):\n                print \"error %s\" % ref\n                continue\n\n        print \"ok %s\" % ref\n\n    print\n\ndef fix_path(alias, repo, orig_url):\n    url = urlparse.urlparse(orig_url, 'file')\n    if url.scheme != 'file' or os.path.isabs(url.path):\n        return\n    abs_url = urlparse.urljoin(\"%s/\" % os.getcwd(), orig_url)\n    cmd = ['git', 'config', 'remote.%s.url' % alias, \"hg::%s\" % abs_url]\n    subprocess.call(cmd)\n\ndef main(args):\n    global prefix, dirname, branches, bmarks\n    global marks, blob_marks, parsed_refs\n    global peer, mode, bad_mail, bad_name\n    global track_branches, force_push, is_tmp\n    global parsed_tags\n\n    alias = args[1]\n    url = args[2]\n    peer = None\n\n    hg_git_compat = False\n    track_branches = True\n    force_push = True\n\n    try:\n        if get_config('remote-hg.hg-git-compat') == 'true\\n':\n            hg_git_compat = True\n            track_branches = False\n        if get_config('remote-hg.track-branches') == 'false\\n':\n            track_branches = False\n        if get_config('remote-hg.force-push') == 'false\\n':\n            force_push = False\n    except subprocess.CalledProcessError:\n        pass\n\n    if hg_git_compat:\n        mode = 'hg'\n        bad_mail = 'none@none'\n        bad_name = ''\n    else:\n        mode = 'git'\n        bad_mail = 'unknown'\n        bad_name = 'Unknown'\n\n    if alias[4:] == url:\n        is_tmp = True\n        alias = util.sha1(alias).hexdigest()\n    else:\n        is_tmp = False\n\n    gitdir = os.environ['GIT_DIR']\n    dirname = os.path.join(gitdir, 'hg', alias)\n    branches = {}\n    bmarks = {}\n    blob_marks = {}\n    parsed_refs = {}\n    marks = None\n    parsed_tags = {}\n\n    repo = get_repo(url, alias)\n    prefix = 'refs/hg/%s' % alias\n\n    if not is_tmp:\n        fix_path(alias, peer or repo, url)\n\n    if not os.path.exists(dirname):\n        os.makedirs(dirname)\n\n    marks_path = os.path.join(dirname, 'marks-hg')\n    marks = Marks(marks_path)\n\n    parser = Parser(repo)\n    for line in parser:\n        if parser.check('capabilities'):\n            do_capabilities(parser)\n        elif parser.check('list'):\n            do_list(parser)\n        elif parser.check('import'):\n            do_import(parser)\n        elif parser.check('export'):\n            do_export(parser)\n        else:\n            die('unhandled command: %s' % line)\n        sys.stdout.flush()\n\ndef bye():\n    if not marks:\n        return\n    if not is_tmp:\n        marks.store()\n    else:\n        shutil.rmtree(dirname)\n\natexit.register(bye)\nsys.exit(main(sys.argv))\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0084709c8cd8c65c022879f8053413ff8c485cfd",
  "sha1_ok": true,
  "size": 24728
}
