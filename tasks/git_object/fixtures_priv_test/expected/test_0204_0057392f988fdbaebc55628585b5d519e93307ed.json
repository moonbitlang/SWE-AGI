{
  "content": {
    "base64": "LyoKICogImdpdCBhZGQiIGJ1aWx0aW4gY29tbWFuZAogKgogKiBDb3B5cmlnaHQgKEMpIDIwMDYgTGludXMgVG9ydmFsZHMKICovCiNkZWZpbmUgVVNFX1RIRV9JTkRFWF9WQVJJQUJMRQojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAiYWR2aWNlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImxvY2tmaWxlLmgiCiNpbmNsdWRlICJlZGl0b3IuaCIKI2luY2x1ZGUgImRpci5oIgojaW5jbHVkZSAiZ2V0dGV4dC5oIgojaW5jbHVkZSAicGF0aHNwZWMuaCIKI2luY2x1ZGUgImV4ZWMtY21kLmgiCiNpbmNsdWRlICJjYWNoZS10cmVlLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAicGF0aC5oIgojaW5jbHVkZSAicHJlbG9hZC1pbmRleC5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAiZGlmZmNvcmUuaCIKI2luY2x1ZGUgInJlYWQtY2FjaGUuaCIKI2luY2x1ZGUgInJlcG9zaXRvcnkuaCIKI2luY2x1ZGUgInJldmlzaW9uLmgiCiNpbmNsdWRlICJidWxrLWNoZWNraW4uaCIKI2luY2x1ZGUgInN0cnZlYy5oIgojaW5jbHVkZSAic3VibW9kdWxlLmgiCiNpbmNsdWRlICJhZGQtaW50ZXJhY3RpdmUuaCIKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgYnVpbHRpbl9hZGRfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgYWRkIFs8b3B0aW9ucz5dIFstLV0gPHBhdGhzcGVjPi4uLiIpLAoJTlVMTAp9OwpzdGF0aWMgaW50IHBhdGNoX2ludGVyYWN0aXZlLCBhZGRfaW50ZXJhY3RpdmUsIGVkaXRfaW50ZXJhY3RpdmU7CnN0YXRpYyBpbnQgdGFrZV93b3JrdHJlZV9jaGFuZ2VzOwpzdGF0aWMgaW50IGFkZF9yZW5vcm1hbGl6ZTsKc3RhdGljIGludCBwYXRoc3BlY19maWxlX251bDsKc3RhdGljIGludCBpbmNsdWRlX3NwYXJzZTsKc3RhdGljIGNvbnN0IGNoYXIgKnBhdGhzcGVjX2Zyb21fZmlsZTsKCnN0YXRpYyBpbnQgY2htb2RfcGF0aHNwZWMoc3RydWN0IHBhdGhzcGVjICpwYXRoc3BlYywgY2hhciBmbGlwLCBpbnQgc2hvd19vbmx5KQp7CglpbnQgaSwgcmV0ID0gMDsKCglmb3IgKGkgPSAwOyBpIDwgdGhlX2luZGV4LmNhY2hlX25yOyBpKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gdGhlX2luZGV4LmNhY2hlW2ldOwoJCWludCBlcnI7CgoJCWlmICghaW5jbHVkZV9zcGFyc2UgJiYKCQkgICAgKGNlX3NraXBfd29ya3RyZWUoY2UpIHx8CgkJICAgICAhcGF0aF9pbl9zcGFyc2VfY2hlY2tvdXQoY2UtPm5hbWUsICZ0aGVfaW5kZXgpKSkKCQkJY29udGludWU7CgoJCWlmIChwYXRoc3BlYyAmJiAhY2VfcGF0aF9tYXRjaCgmdGhlX2luZGV4LCBjZSwgcGF0aHNwZWMsIE5VTEwpKQoJCQljb250aW51ZTsKCgkJaWYgKCFzaG93X29ubHkpCgkJCWVyciA9IGNobW9kX2luZGV4X2VudHJ5KCZ0aGVfaW5kZXgsIGNlLCBmbGlwKTsKCQllbHNlCgkJCWVyciA9IFNfSVNSRUcoY2UtPmNlX21vZGUpID8gMCA6IC0xOwoKCQlpZiAoZXJyIDwgMCkKCQkJcmV0ID0gZXJyb3IoXygiY2Fubm90IGNobW9kICVjeCAnJXMnIiksIGZsaXAsIGNlLT5uYW1lKTsKCX0KCglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IHJlbm9ybWFsaXplX3RyYWNrZWRfZmlsZXMoY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwYXRoc3BlYywgaW50IGZsYWdzKQp7CglpbnQgaSwgcmV0dmFsID0gMDsKCglmb3IgKGkgPSAwOyBpIDwgdGhlX2luZGV4LmNhY2hlX25yOyBpKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gdGhlX2luZGV4LmNhY2hlW2ldOwoKCQlpZiAoIWluY2x1ZGVfc3BhcnNlICYmCgkJICAgIChjZV9za2lwX3dvcmt0cmVlKGNlKSB8fAoJCSAgICAgIXBhdGhfaW5fc3BhcnNlX2NoZWNrb3V0KGNlLT5uYW1lLCAmdGhlX2luZGV4KSkpCgkJCWNvbnRpbnVlOwoJCWlmIChjZV9zdGFnZShjZSkpCgkJCWNvbnRpbnVlOyAvKiBkbyBub3QgdG91Y2ggdW5tZXJnZWQgcGF0aHMgKi8KCQlpZiAoIVNfSVNSRUcoY2UtPmNlX21vZGUpICYmICFTX0lTTE5LKGNlLT5jZV9tb2RlKSkKCQkJY29udGludWU7IC8qIGRvIG5vdCB0b3VjaCBub24gYmxvYnMgKi8KCQlpZiAocGF0aHNwZWMgJiYgIWNlX3BhdGhfbWF0Y2goJnRoZV9pbmRleCwgY2UsIHBhdGhzcGVjLCBOVUxMKSkKCQkJY29udGludWU7CgkJcmV0dmFsIHw9IGFkZF9maWxlX3RvX2luZGV4KCZ0aGVfaW5kZXgsIGNlLT5uYW1lLAoJCQkJCSAgICBmbGFncyB8IEFERF9DQUNIRV9SRU5PUk1BTElaRSk7Cgl9CgoJcmV0dXJuIHJldHZhbDsKfQoKc3RhdGljIGNoYXIgKnBydW5lX2RpcmVjdG9yeShzdHJ1Y3QgZGlyX3N0cnVjdCAqZGlyLCBzdHJ1Y3QgcGF0aHNwZWMgKnBhdGhzcGVjLCBpbnQgcHJlZml4KQp7CgljaGFyICpzZWVuOwoJaW50IGk7CglzdHJ1Y3QgZGlyX2VudHJ5ICoqc3JjLCAqKmRzdDsKCglzZWVuID0geGNhbGxvYyhwYXRoc3BlYy0+bnIsIDEpOwoKCXNyYyA9IGRzdCA9IGRpci0+ZW50cmllczsKCWkgPSBkaXItPm5yOwoJd2hpbGUgKC0taSA+PSAwKSB7CgkJc3RydWN0IGRpcl9lbnRyeSAqZW50cnkgPSAqc3JjKys7CgkJaWYgKGRpcl9wYXRoX21hdGNoKCZ0aGVfaW5kZXgsIGVudHJ5LCBwYXRoc3BlYywgcHJlZml4LCBzZWVuKSkKCQkJKmRzdCsrID0gZW50cnk7Cgl9CglkaXItPm5yID0gZHN0IC0gZGlyLT5lbnRyaWVzOwoJYWRkX3BhdGhzcGVjX21hdGNoZXNfYWdhaW5zdF9pbmRleChwYXRoc3BlYywgJnRoZV9pbmRleCwgc2VlbiwKCQkJCQkgICBQU19JR05PUkVfU0tJUF9XT1JLVFJFRSk7CglyZXR1cm4gc2VlbjsKfQoKc3RhdGljIGludCByZWZyZXNoKGludCB2ZXJib3NlLCBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBhdGhzcGVjKQp7CgljaGFyICpzZWVuOwoJaW50IGksIHJldCA9IDA7CgljaGFyICpza2lwX3dvcmt0cmVlX3NlZW4gPSBOVUxMOwoJc3RydWN0IHN0cmluZ19saXN0IG9ubHlfbWF0Y2hfc2tpcF93b3JrdHJlZSA9IFNUUklOR19MSVNUX0lOSVRfTk9EVVA7CglpbnQgZmxhZ3MgPSBSRUZSRVNIX0lHTk9SRV9TS0lQX1dPUktUUkVFIHwKCQkgICAgKHZlcmJvc2UgPyBSRUZSRVNIX0lOX1BPUkNFTEFJTiA6IFJFRlJFU0hfUVVJRVQpOwoKCXNlZW4gPSB4Y2FsbG9jKHBhdGhzcGVjLT5uciwgMSk7CglyZWZyZXNoX2luZGV4KCZ0aGVfaW5kZXgsIGZsYWdzLCBwYXRoc3BlYywgc2VlbiwKCQkgICAgICBfKCJVbnN0YWdlZCBjaGFuZ2VzIGFmdGVyIHJlZnJlc2hpbmcgdGhlIGluZGV4OiIpKTsKCWZvciAoaSA9IDA7IGkgPCBwYXRoc3BlYy0+bnI7IGkrKykgewoJCWlmICghc2VlbltpXSkgewoJCQljb25zdCBjaGFyICpwYXRoID0gcGF0aHNwZWMtPml0ZW1zW2ldLm9yaWdpbmFsOwoKCQkJaWYgKG1hdGNoZXNfc2tpcF93b3JrdHJlZShwYXRoc3BlYywgaSwgJnNraXBfd29ya3RyZWVfc2VlbikgfHwKCQkJICAgICFwYXRoX2luX3NwYXJzZV9jaGVja291dChwYXRoLCAmdGhlX2luZGV4KSkgewoJCQkJc3RyaW5nX2xpc3RfYXBwZW5kKCZvbmx5X21hdGNoX3NraXBfd29ya3RyZWUsCgkJCQkJCSAgIHBhdGhzcGVjLT5pdGVtc1tpXS5vcmlnaW5hbCk7CgkJCX0gZWxzZSB7CgkJCQlkaWUoXygicGF0aHNwZWMgJyVzJyBkaWQgbm90IG1hdGNoIGFueSBmaWxlcyIpLAoJCQkJICAgIHBhdGhzcGVjLT5pdGVtc1tpXS5vcmlnaW5hbCk7CgkJCX0KCQl9Cgl9CgoJaWYgKG9ubHlfbWF0Y2hfc2tpcF93b3JrdHJlZS5ucikgewoJCWFkdmlzZV9vbl91cGRhdGluZ19zcGFyc2VfcGF0aHMoJm9ubHlfbWF0Y2hfc2tpcF93b3JrdHJlZSk7CgkJcmV0ID0gMTsKCX0KCglmcmVlKHNlZW4pOwoJZnJlZShza2lwX3dvcmt0cmVlX3NlZW4pOwoJc3RyaW5nX2xpc3RfY2xlYXIoJm9ubHlfbWF0Y2hfc2tpcF93b3JrdHJlZSwgMCk7CglyZXR1cm4gcmV0Owp9CgppbnQgaW50ZXJhY3RpdmVfYWRkKGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgsIGludCBwYXRjaCkKewoJc3RydWN0IHBhdGhzcGVjIHBhdGhzcGVjOwoJaW50IHVudXNlZDsKCglpZiAoIWdpdF9jb25maWdfZ2V0X2Jvb2woImFkZC5pbnRlcmFjdGl2ZS51c2VidWlsdGluIiwgJnVudXNlZCkpCgkJd2FybmluZyhfKCJ0aGUgYWRkLmludGVyYWN0aXZlLnVzZUJ1aWx0aW4gc2V0dGluZyBoYXMgYmVlbiByZW1vdmVkIVxuIgoJCQkgICJTZWUgaXRzIGVudHJ5IGluICdnaXQgaGVscCBjb25maWcnIGZvciBkZXRhaWxzLiIpKTsKCglwYXJzZV9wYXRoc3BlYygmcGF0aHNwZWMsIDAsCgkJICAgICAgIFBBVEhTUEVDX1BSRUZFUl9GVUxMIHwKCQkgICAgICAgUEFUSFNQRUNfU1lNTElOS19MRUFESU5HX1BBVEggfAoJCSAgICAgICBQQVRIU1BFQ19QUkVGSVhfT1JJR0lOLAoJCSAgICAgICBwcmVmaXgsIGFyZ3YpOwoKCWlmIChwYXRjaCkKCQlyZXR1cm4gISFydW5fYWRkX3AodGhlX3JlcG9zaXRvcnksIEFERF9QX0FERCwgTlVMTCwgJnBhdGhzcGVjKTsKCWVsc2UKCQlyZXR1cm4gISFydW5fYWRkX2kodGhlX3JlcG9zaXRvcnksICZwYXRoc3BlYyk7Cn0KCnN0YXRpYyBpbnQgZWRpdF9wYXRjaChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJY2hhciAqZmlsZSA9IGdpdF9wYXRoZHVwKCJBRERfRURJVC5wYXRjaCIpOwoJc3RydWN0IGNoaWxkX3Byb2Nlc3MgY2hpbGQgPSBDSElMRF9QUk9DRVNTX0lOSVQ7CglzdHJ1Y3QgcmV2X2luZm8gcmV2OwoJaW50IG91dDsKCXN0cnVjdCBzdGF0IHN0OwoKCWdpdF9jb25maWcoZ2l0X2RpZmZfYmFzaWNfY29uZmlnLCBOVUxMKTsgLyogbm8gImRpZmYiIFVJIG9wdGlvbnMgKi8KCglpZiAocmVwb19yZWFkX2luZGV4KHRoZV9yZXBvc2l0b3J5KSA8IDApCgkJZGllKF8oImNvdWxkIG5vdCByZWFkIHRoZSBpbmRleCIpKTsKCglyZXBvX2luaXRfcmV2aXNpb25zKHRoZV9yZXBvc2l0b3J5LCAmcmV2LCBwcmVmaXgpOwoJcmV2LmRpZmZvcHQuY29udGV4dCA9IDc7CgoJYXJnYyA9IHNldHVwX3JldmlzaW9ucyhhcmdjLCBhcmd2LCAmcmV2LCBOVUxMKTsKCXJldi5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9QQVRDSDsKCXJldi5kaWZmb3B0LnVzZV9jb2xvciA9IDA7CglyZXYuZGlmZm9wdC5mbGFncy5pZ25vcmVfZGlydHlfc3VibW9kdWxlcyA9IDE7CglvdXQgPSB4b3BlbihmaWxlLCBPX0NSRUFUIHwgT19XUk9OTFkgfCBPX1RSVU5DLCAwNjY2KTsKCXJldi5kaWZmb3B0LmZpbGUgPSB4ZmRvcGVuKG91dCwgInciKTsKCXJldi5kaWZmb3B0LmNsb3NlX2ZpbGUgPSAxOwoJcnVuX2RpZmZfZmlsZXMoJnJldiwgMCk7CgoJaWYgKGxhdW5jaF9lZGl0b3IoZmlsZSwgTlVMTCwgTlVMTCkpCgkJZGllKF8oImVkaXRpbmcgcGF0Y2ggZmFpbGVkIikpOwoKCWlmIChzdGF0KGZpbGUsICZzdCkpCgkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCBzdGF0ICclcyciKSwgZmlsZSk7CglpZiAoIXN0LnN0X3NpemUpCgkJZGllKF8oImVtcHR5IHBhdGNoLiBhYm9ydGVkIikpOwoKCWNoaWxkLmdpdF9jbWQgPSAxOwoJc3RydmVjX3B1c2hsKCZjaGlsZC5hcmdzLCAiYXBwbHkiLCAiLS1yZWNvdW50IiwgIi0tY2FjaGVkIiwgZmlsZSwKCQkgICAgIE5VTEwpOwoJaWYgKHJ1bl9jb21tYW5kKCZjaGlsZCkpCgkJZGllKF8oImNvdWxkIG5vdCBhcHBseSAnJXMnIiksIGZpbGUpOwoKCXVubGluayhmaWxlKTsKCWZyZWUoZmlsZSk7CglyZWxlYXNlX3JldmlzaW9ucygmcmV2KTsKCXJldHVybiAwOwp9CgpzdGF0aWMgY29uc3QgY2hhciBpZ25vcmVfZXJyb3JbXSA9Ck5fKCJUaGUgZm9sbG93aW5nIHBhdGhzIGFyZSBpZ25vcmVkIGJ5IG9uZSBvZiB5b3VyIC5naXRpZ25vcmUgZmlsZXM6XG4iKTsKCnN0YXRpYyBpbnQgdmVyYm9zZSwgc2hvd19vbmx5LCBpZ25vcmVkX3RvbywgcmVmcmVzaF9vbmx5OwpzdGF0aWMgaW50IGlnbm9yZV9hZGRfZXJyb3JzLCBpbnRlbnRfdG9fYWRkLCBpZ25vcmVfbWlzc2luZzsKc3RhdGljIGludCB3YXJuX29uX2VtYmVkZGVkX3JlcG8gPSAxOwoKI2RlZmluZSBBRERSRU1PVkVfREVGQVVMVCAxCnN0YXRpYyBpbnQgYWRkcmVtb3ZlID0gQUREUkVNT1ZFX0RFRkFVTFQ7CnN0YXRpYyBpbnQgYWRkcmVtb3ZlX2V4cGxpY2l0ID0gLTE7IC8qIHVuc3BlY2lmaWVkICovCgpzdGF0aWMgY2hhciAqY2htb2RfYXJnOwoKc3RhdGljIGludCBpZ25vcmVfcmVtb3ZhbF9jYihjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CgkvKiBpZiB3ZSBhcmUgdG9sZCB0byBpZ25vcmUsIHdlIGFyZSBub3QgYWRkaW5nIHJlbW92YWxzICovCgkqKGludCAqKW9wdC0+dmFsdWUgPSAhdW5zZXQgPyAwIDogMTsKCXJldHVybiAwOwp9CgpzdGF0aWMgc3RydWN0IG9wdGlvbiBidWlsdGluX2FkZF9vcHRpb25zW10gPSB7CglPUFRfX0RSWV9SVU4oJnNob3dfb25seSwgTl8oImRyeSBydW4iKSksCglPUFRfX1ZFUkJPU0UoJnZlcmJvc2UsIE5fKCJiZSB2ZXJib3NlIikpLAoJT1BUX0dST1VQKCIiKSwKCU9QVF9CT09MKCdpJywgImludGVyYWN0aXZlIiwgJmFkZF9pbnRlcmFjdGl2ZSwgTl8oImludGVyYWN0aXZlIHBpY2tpbmciKSksCglPUFRfQk9PTCgncCcsICJwYXRjaCIsICZwYXRjaF9pbnRlcmFjdGl2ZSwgTl8oInNlbGVjdCBodW5rcyBpbnRlcmFjdGl2ZWx5IikpLAoJT1BUX0JPT0woJ2UnLCAiZWRpdCIsICZlZGl0X2ludGVyYWN0aXZlLCBOXygiZWRpdCBjdXJyZW50IGRpZmYgYW5kIGFwcGx5IikpLAoJT1BUX19GT1JDRSgmaWdub3JlZF90b28sIE5fKCJhbGxvdyBhZGRpbmcgb3RoZXJ3aXNlIGlnbm9yZWQgZmlsZXMiKSwgMCksCglPUFRfQk9PTCgndScsICJ1cGRhdGUiLCAmdGFrZV93b3JrdHJlZV9jaGFuZ2VzLCBOXygidXBkYXRlIHRyYWNrZWQgZmlsZXMiKSksCglPUFRfQk9PTCgwLCAicmVub3JtYWxpemUiLCAmYWRkX3Jlbm9ybWFsaXplLCBOXygicmVub3JtYWxpemUgRU9MIG9mIHRyYWNrZWQgZmlsZXMgKGltcGxpZXMgLXUpIikpLAoJT1BUX0JPT0woJ04nLCAiaW50ZW50LXRvLWFkZCIsICZpbnRlbnRfdG9fYWRkLCBOXygicmVjb3JkIG9ubHkgdGhlIGZhY3QgdGhhdCB0aGUgcGF0aCB3aWxsIGJlIGFkZGVkIGxhdGVyIikpLAoJT1BUX0JPT0woJ0EnLCAiYWxsIiwgJmFkZHJlbW92ZV9leHBsaWNpdCwgTl8oImFkZCBjaGFuZ2VzIGZyb20gYWxsIHRyYWNrZWQgYW5kIHVudHJhY2tlZCBmaWxlcyIpKSwKCU9QVF9DQUxMQkFDS19GKDAsICJpZ25vcmUtcmVtb3ZhbCIsICZhZGRyZW1vdmVfZXhwbGljaXQsCgkgIE5VTEwgLyogdGFrZXMgbm8gYXJndW1lbnRzICovLAoJICBOXygiaWdub3JlIHBhdGhzIHJlbW92ZWQgaW4gdGhlIHdvcmtpbmcgdHJlZSAoc2FtZSBhcyAtLW5vLWFsbCkiKSwKCSAgUEFSU0VfT1BUX05PQVJHLCBpZ25vcmVfcmVtb3ZhbF9jYiksCglPUFRfQk9PTCggMCAsICJyZWZyZXNoIiwgJnJlZnJlc2hfb25seSwgTl8oImRvbid0IGFkZCwgb25seSByZWZyZXNoIHRoZSBpbmRleCIpKSwKCU9QVF9CT09MKCAwICwgImlnbm9yZS1lcnJvcnMiLCAmaWdub3JlX2FkZF9lcnJvcnMsIE5fKCJqdXN0IHNraXAgZmlsZXMgd2hpY2ggY2Fubm90IGJlIGFkZGVkIGJlY2F1c2Ugb2YgZXJyb3JzIikpLAoJT1BUX0JPT0woIDAgLCAiaWdub3JlLW1pc3NpbmciLCAmaWdub3JlX21pc3NpbmcsIE5fKCJjaGVjayBpZiAtIGV2ZW4gbWlzc2luZyAtIGZpbGVzIGFyZSBpZ25vcmVkIGluIGRyeSBydW4iKSksCglPUFRfQk9PTCgwLCAic3BhcnNlIiwgJmluY2x1ZGVfc3BhcnNlLCBOXygiYWxsb3cgdXBkYXRpbmcgZW50cmllcyBvdXRzaWRlIG9mIHRoZSBzcGFyc2UtY2hlY2tvdXQgY29uZSIpKSwKCU9QVF9TVFJJTkcoMCwgImNobW9kIiwgJmNobW9kX2FyZywgIigrfC0peCIsCgkJICAgTl8oIm92ZXJyaWRlIHRoZSBleGVjdXRhYmxlIGJpdCBvZiB0aGUgbGlzdGVkIGZpbGVzIikpLAoJT1BUX0hJRERFTl9CT09MKDAsICJ3YXJuLWVtYmVkZGVkLXJlcG8iLCAmd2Fybl9vbl9lbWJlZGRlZF9yZXBvLAoJCQlOXygid2FybiB3aGVuIGFkZGluZyBhbiBlbWJlZGRlZCByZXBvc2l0b3J5IikpLAoJT1BUX1BBVEhTUEVDX0ZST01fRklMRSgmcGF0aHNwZWNfZnJvbV9maWxlKSwKCU9QVF9QQVRIU1BFQ19GSUxFX05VTCgmcGF0aHNwZWNfZmlsZV9udWwpLAoJT1BUX0VORCgpLAp9OwoKc3RhdGljIGludCBhZGRfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsCgkJICAgICAgY29uc3Qgc3RydWN0IGNvbmZpZ19jb250ZXh0ICpjdHgsIHZvaWQgKmNiKQp7CglpZiAoIXN0cmNtcCh2YXIsICJhZGQuaWdub3JlZXJyb3JzIikgfHwKCSAgICAhc3RyY21wKHZhciwgImFkZC5pZ25vcmUtZXJyb3JzIikpIHsKCQlpZ25vcmVfYWRkX2Vycm9ycyA9IGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCglpZiAoZ2l0X2NvbG9yX2NvbmZpZyh2YXIsIHZhbHVlLCBjYikgPCAwKQoJCXJldHVybiAtMTsKCglyZXR1cm4gZ2l0X2RlZmF1bHRfY29uZmlnKHZhciwgdmFsdWUsIGN0eCwgY2IpOwp9CgpzdGF0aWMgY29uc3QgY2hhciBlbWJlZGRlZF9hZHZpY2VbXSA9IE5fKAoiWW91J3ZlIGFkZGVkIGFub3RoZXIgZ2l0IHJlcG9zaXRvcnkgaW5zaWRlIHlvdXIgY3VycmVudCByZXBvc2l0b3J5LlxuIgoiQ2xvbmVzIG9mIHRoZSBvdXRlciByZXBvc2l0b3J5IHdpbGwgbm90IGNvbnRhaW4gdGhlIGNvbnRlbnRzIG9mXG4iCiJ0aGUgZW1iZWRkZWQgcmVwb3NpdG9yeSBhbmQgd2lsbCBub3Qga25vdyBob3cgdG8gb2J0YWluIGl0LlxuIgoiSWYgeW91IG1lYW50IHRvIGFkZCBhIHN1Ym1vZHVsZSwgdXNlOlxuIgoiXG4iCiIJZ2l0IHN1Ym1vZHVsZSBhZGQgPHVybD4gJXNcbiIKIlxuIgoiSWYgeW91IGFkZGVkIHRoaXMgcGF0aCBieSBtaXN0YWtlLCB5b3UgY2FuIHJlbW92ZSBpdCBmcm9tIHRoZVxuIgoiaW5kZXggd2l0aDpcbiIKIlxuIgoiCWdpdCBybSAtLWNhY2hlZCAlc1xuIgoiXG4iCiJTZWUgXCJnaXQgaGVscCBzdWJtb2R1bGVcIiBmb3IgbW9yZSBpbmZvcm1hdGlvbi4iCik7CgpzdGF0aWMgdm9pZCBjaGVja19lbWJlZGRlZF9yZXBvKGNvbnN0IGNoYXIgKnBhdGgpCnsKCXN0cnVjdCBzdHJidWYgbmFtZSA9IFNUUkJVRl9JTklUOwoJc3RhdGljIGludCBhZHZpY2VkX29uX2VtYmVkZGVkX3JlcG8gPSAwOwoKCWlmICghd2Fybl9vbl9lbWJlZGRlZF9yZXBvKQoJCXJldHVybjsKCWlmICghZW5kc193aXRoKHBhdGgsICIvIikpCgkJcmV0dXJuOwoKCS8qIERyb3AgdHJhaWxpbmcgc2xhc2ggZm9yIGFlc3RoZXRpY3MgKi8KCXN0cmJ1Zl9hZGRzdHIoJm5hbWUsIHBhdGgpOwoJc3RyYnVmX3N0cmlwX3N1ZmZpeCgmbmFtZSwgIi8iKTsKCgl3YXJuaW5nKF8oImFkZGluZyBlbWJlZGRlZCBnaXQgcmVwb3NpdG9yeTogJXMiKSwgbmFtZS5idWYpOwoJaWYgKCFhZHZpY2VkX29uX2VtYmVkZGVkX3JlcG8gJiYKCSAgICBhZHZpY2VfZW5hYmxlZChBRFZJQ0VfQUREX0VNQkVEREVEX1JFUE8pKSB7CgkJYWR2aXNlKGVtYmVkZGVkX2FkdmljZSwgbmFtZS5idWYsIG5hbWUuYnVmKTsKCQlhZHZpY2VkX29uX2VtYmVkZGVkX3JlcG8gPSAxOwoJfQoKCXN0cmJ1Zl9yZWxlYXNlKCZuYW1lKTsKfQoKc3RhdGljIGludCBhZGRfZmlsZXMoc3RydWN0IGRpcl9zdHJ1Y3QgKmRpciwgaW50IGZsYWdzKQp7CglpbnQgaSwgZXhpdF9zdGF0dXMgPSAwOwoJc3RydWN0IHN0cmluZ19saXN0IG1hdGNoZWRfc3BhcnNlX3BhdGhzID0gU1RSSU5HX0xJU1RfSU5JVF9OT0RVUDsKCglpZiAoZGlyLT5pZ25vcmVkX25yKSB7CgkJZnByaW50ZihzdGRlcnIsIF8oaWdub3JlX2Vycm9yKSk7CgkJZm9yIChpID0gMDsgaSA8IGRpci0+aWdub3JlZF9ucjsgaSsrKQoJCQlmcHJpbnRmKHN0ZGVyciwgIiVzXG4iLCBkaXItPmlnbm9yZWRbaV0tPm5hbWUpOwoJCWlmIChhZHZpY2VfZW5hYmxlZChBRFZJQ0VfQUREX0lHTk9SRURfRklMRSkpCgkJCWFkdmlzZShfKCJVc2UgLWYgaWYgeW91IHJlYWxseSB3YW50IHRvIGFkZCB0aGVtLlxuIgoJCQkJIlR1cm4gdGhpcyBtZXNzYWdlIG9mZiBieSBydW5uaW5nXG4iCgkJCQkiXCJnaXQgY29uZmlnIGFkdmljZS5hZGRJZ25vcmVkRmlsZSBmYWxzZVwiIikpOwoJCWV4aXRfc3RhdHVzID0gMTsKCX0KCglmb3IgKGkgPSAwOyBpIDwgZGlyLT5ucjsgaSsrKSB7CgkJaWYgKCFpbmNsdWRlX3NwYXJzZSAmJgoJCSAgICAhcGF0aF9pbl9zcGFyc2VfY2hlY2tvdXQoZGlyLT5lbnRyaWVzW2ldLT5uYW1lLCAmdGhlX2luZGV4KSkgewoJCQlzdHJpbmdfbGlzdF9hcHBlbmQoJm1hdGNoZWRfc3BhcnNlX3BhdGhzLAoJCQkJCSAgIGRpci0+ZW50cmllc1tpXS0+bmFtZSk7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoYWRkX2ZpbGVfdG9faW5kZXgoJnRoZV9pbmRleCwgZGlyLT5lbnRyaWVzW2ldLT5uYW1lLCBmbGFncykpIHsKCQkJaWYgKCFpZ25vcmVfYWRkX2Vycm9ycykKCQkJCWRpZShfKCJhZGRpbmcgZmlsZXMgZmFpbGVkIikpOwoJCQlleGl0X3N0YXR1cyA9IDE7CgkJfSBlbHNlIHsKCQkJY2hlY2tfZW1iZWRkZWRfcmVwbyhkaXItPmVudHJpZXNbaV0tPm5hbWUpOwoJCX0KCX0KCglpZiAobWF0Y2hlZF9zcGFyc2VfcGF0aHMubnIpIHsKCQlhZHZpc2Vfb25fdXBkYXRpbmdfc3BhcnNlX3BhdGhzKCZtYXRjaGVkX3NwYXJzZV9wYXRocyk7CgkJZXhpdF9zdGF0dXMgPSAxOwoJfQoKCXN0cmluZ19saXN0X2NsZWFyKCZtYXRjaGVkX3NwYXJzZV9wYXRocywgMCk7CgoJcmV0dXJuIGV4aXRfc3RhdHVzOwp9CgppbnQgY21kX2FkZChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJaW50IGV4aXRfc3RhdHVzID0gMDsKCXN0cnVjdCBwYXRoc3BlYyBwYXRoc3BlYzsKCXN0cnVjdCBkaXJfc3RydWN0IGRpciA9IERJUl9JTklUOwoJaW50IGZsYWdzOwoJaW50IGFkZF9uZXdfZmlsZXM7CglpbnQgcmVxdWlyZV9wYXRoc3BlYzsKCWNoYXIgKnNlZW4gPSBOVUxMOwoJc3RydWN0IGxvY2tfZmlsZSBsb2NrX2ZpbGUgPSBMT0NLX0lOSVQ7CgoJZ2l0X2NvbmZpZyhhZGRfY29uZmlnLCBOVUxMKTsKCglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIGJ1aWx0aW5fYWRkX29wdGlvbnMsCgkJCSAgYnVpbHRpbl9hZGRfdXNhZ2UsIFBBUlNFX09QVF9LRUVQX0FSR1YwKTsKCWlmIChwYXRjaF9pbnRlcmFjdGl2ZSkKCQlhZGRfaW50ZXJhY3RpdmUgPSAxOwoJaWYgKGFkZF9pbnRlcmFjdGl2ZSkgewoJCWlmIChzaG93X29ubHkpCgkJCWRpZShfKCJvcHRpb25zICclcycgYW5kICclcycgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIiKSwgIi0tZHJ5LXJ1biIsICItLWludGVyYWN0aXZlLy0tcGF0Y2giKTsKCQlpZiAocGF0aHNwZWNfZnJvbV9maWxlKQoJCQlkaWUoXygib3B0aW9ucyAnJXMnIGFuZCAnJXMnIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIiksICItLXBhdGhzcGVjLWZyb20tZmlsZSIsICItLWludGVyYWN0aXZlLy0tcGF0Y2giKTsKCQlleGl0KGludGVyYWN0aXZlX2FkZChhcmd2ICsgMSwgcHJlZml4LCBwYXRjaF9pbnRlcmFjdGl2ZSkpOwoJfQoKCWlmIChlZGl0X2ludGVyYWN0aXZlKSB7CgkJaWYgKHBhdGhzcGVjX2Zyb21fZmlsZSkKCQkJZGllKF8oIm9wdGlvbnMgJyVzJyBhbmQgJyVzJyBjYW5ub3QgYmUgdXNlZCB0b2dldGhlciIpLCAiLS1wYXRoc3BlYy1mcm9tLWZpbGUiLCAiLS1lZGl0Iik7CgkJcmV0dXJuKGVkaXRfcGF0Y2goYXJnYywgYXJndiwgcHJlZml4KSk7Cgl9CglhcmdjLS07Cglhcmd2Kys7CgoJaWYgKDAgPD0gYWRkcmVtb3ZlX2V4cGxpY2l0KQoJCWFkZHJlbW92ZSA9IGFkZHJlbW92ZV9leHBsaWNpdDsKCWVsc2UgaWYgKHRha2Vfd29ya3RyZWVfY2hhbmdlcyAmJiBBRERSRU1PVkVfREVGQVVMVCkKCQlhZGRyZW1vdmUgPSAwOyAvKiAiLXUiIHdhcyBnaXZlbiBidXQgbm90ICItQSIgKi8KCglpZiAoYWRkcmVtb3ZlICYmIHRha2Vfd29ya3RyZWVfY2hhbmdlcykKCQlkaWUoXygib3B0aW9ucyAnJXMnIGFuZCAnJXMnIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIiksICItQSIsICItdSIpOwoKCWlmICghc2hvd19vbmx5ICYmIGlnbm9yZV9taXNzaW5nKQoJCWRpZShfKCJ0aGUgb3B0aW9uICclcycgcmVxdWlyZXMgJyVzJyIpLCAiLS1pZ25vcmUtbWlzc2luZyIsICItLWRyeS1ydW4iKTsKCglpZiAoY2htb2RfYXJnICYmICgoY2htb2RfYXJnWzBdICE9ICctJyAmJiBjaG1vZF9hcmdbMF0gIT0gJysnKSB8fAoJCQkgIGNobW9kX2FyZ1sxXSAhPSAneCcgfHwgY2htb2RfYXJnWzJdKSkKCQlkaWUoXygiLS1jaG1vZCBwYXJhbSAnJXMnIG11c3QgYmUgZWl0aGVyIC14IG9yICt4IiksIGNobW9kX2FyZyk7CgoJYWRkX25ld19maWxlcyA9ICF0YWtlX3dvcmt0cmVlX2NoYW5nZXMgJiYgIXJlZnJlc2hfb25seSAmJiAhYWRkX3Jlbm9ybWFsaXplOwoJcmVxdWlyZV9wYXRoc3BlYyA9ICEodGFrZV93b3JrdHJlZV9jaGFuZ2VzIHx8ICgwIDwgYWRkcmVtb3ZlX2V4cGxpY2l0KSk7CgoJcHJlcGFyZV9yZXBvX3NldHRpbmdzKHRoZV9yZXBvc2l0b3J5KTsKCXRoZV9yZXBvc2l0b3J5LT5zZXR0aW5ncy5jb21tYW5kX3JlcXVpcmVzX2Z1bGxfaW5kZXggPSAwOwoKCXJlcG9faG9sZF9sb2NrZWRfaW5kZXgodGhlX3JlcG9zaXRvcnksICZsb2NrX2ZpbGUsIExPQ0tfRElFX09OX0VSUk9SKTsKCgkvKgoJICogQ2hlY2sgdGhlICJwYXRoc3BlYyAnJXMnIGRpZCBub3QgbWF0Y2ggYW55IGZpbGVzIiBibG9jawoJICogYmVsb3cgYmVmb3JlIGVuYWJsaW5nIG5ldyBtYWdpYy4KCSAqLwoJcGFyc2VfcGF0aHNwZWMoJnBhdGhzcGVjLCBQQVRIU1BFQ19BVFRSLAoJCSAgICAgICBQQVRIU1BFQ19QUkVGRVJfRlVMTCB8CgkJICAgICAgIFBBVEhTUEVDX1NZTUxJTktfTEVBRElOR19QQVRILAoJCSAgICAgICBwcmVmaXgsIGFyZ3YpOwoKCWlmIChwYXRoc3BlY19mcm9tX2ZpbGUpIHsKCQlpZiAocGF0aHNwZWMubnIpCgkJCWRpZShfKCInJXMnIGFuZCBwYXRoc3BlYyBhcmd1bWVudHMgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIiKSwgIi0tcGF0aHNwZWMtZnJvbS1maWxlIik7CgoJCXBhcnNlX3BhdGhzcGVjX2ZpbGUoJnBhdGhzcGVjLCBQQVRIU1BFQ19BVFRSLAoJCQkJICAgIFBBVEhTUEVDX1BSRUZFUl9GVUxMIHwKCQkJCSAgICBQQVRIU1BFQ19TWU1MSU5LX0xFQURJTkdfUEFUSCwKCQkJCSAgICBwcmVmaXgsIHBhdGhzcGVjX2Zyb21fZmlsZSwgcGF0aHNwZWNfZmlsZV9udWwpOwoJfSBlbHNlIGlmIChwYXRoc3BlY19maWxlX251bCkgewoJCWRpZShfKCJ0aGUgb3B0aW9uICclcycgcmVxdWlyZXMgJyVzJyIpLCAiLS1wYXRoc3BlYy1maWxlLW51bCIsICItLXBhdGhzcGVjLWZyb20tZmlsZSIpOwoJfQoKCWlmIChyZXF1aXJlX3BhdGhzcGVjICYmIHBhdGhzcGVjLm5yID09IDApIHsKCQlmcHJpbnRmKHN0ZGVyciwgXygiTm90aGluZyBzcGVjaWZpZWQsIG5vdGhpbmcgYWRkZWQuXG4iKSk7CgkJaWYgKGFkdmljZV9lbmFibGVkKEFEVklDRV9BRERfRU1QVFlfUEFUSFNQRUMpKQoJCQlhZHZpc2UoIF8oIk1heWJlIHlvdSB3YW50ZWQgdG8gc2F5ICdnaXQgYWRkIC4nP1xuIgoJCQkJIlR1cm4gdGhpcyBtZXNzYWdlIG9mZiBieSBydW5uaW5nXG4iCgkJCQkiXCJnaXQgY29uZmlnIGFkdmljZS5hZGRFbXB0eVBhdGhzcGVjIGZhbHNlXCIiKSk7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKCF0YWtlX3dvcmt0cmVlX2NoYW5nZXMgJiYgYWRkcmVtb3ZlX2V4cGxpY2l0IDwgMCAmJiBwYXRoc3BlYy5ucikKCQkvKiBUdXJuICJnaXQgYWRkIHBhdGhzcGVjLi4uIiB0byAiZ2l0IGFkZCAtQSBwYXRoc3BlYy4uLiIgKi8KCQlhZGRyZW1vdmUgPSAxOwoKCWZsYWdzID0gKCh2ZXJib3NlID8gQUREX0NBQ0hFX1ZFUkJPU0UgOiAwKSB8CgkJIChzaG93X29ubHkgPyBBRERfQ0FDSEVfUFJFVEVORCA6IDApIHwKCQkgKGludGVudF90b19hZGQgPyBBRERfQ0FDSEVfSU5URU5UIDogMCkgfAoJCSAoaWdub3JlX2FkZF9lcnJvcnMgPyBBRERfQ0FDSEVfSUdOT1JFX0VSUk9SUyA6IDApIHwKCQkgKCEoYWRkcmVtb3ZlIHx8IHRha2Vfd29ya3RyZWVfY2hhbmdlcykKCQkgID8gQUREX0NBQ0hFX0lHTk9SRV9SRU1PVkFMIDogMCkpOwoKCWlmIChyZXBvX3JlYWRfaW5kZXhfcHJlbG9hZCh0aGVfcmVwb3NpdG9yeSwgJnBhdGhzcGVjLCAwKSA8IDApCgkJZGllKF8oImluZGV4IGZpbGUgY29ycnVwdCIpKTsKCglkaWVfaW5fdW5wb3B1bGF0ZWRfc3VibW9kdWxlKCZ0aGVfaW5kZXgsIHByZWZpeCk7CglkaWVfcGF0aF9pbnNpZGVfc3VibW9kdWxlKCZ0aGVfaW5kZXgsICZwYXRoc3BlYyk7CgoJaWYgKGFkZF9uZXdfZmlsZXMpIHsKCQlpbnQgYmFzZWxlbjsKCgkJLyogU2V0IHVwIHRoZSBkZWZhdWx0IGdpdCBwb3JjZWxhaW4gZXhjbHVkZXMgKi8KCQlpZiAoIWlnbm9yZWRfdG9vKSB7CgkJCWRpci5mbGFncyB8PSBESVJfQ09MTEVDVF9JR05PUkVEOwoJCQlzZXR1cF9zdGFuZGFyZF9leGNsdWRlcygmZGlyKTsKCQl9CgoJCS8qIFRoaXMgcGlja3MgdXAgdGhlIHBhdGhzIHRoYXQgYXJlIG5vdCB0cmFja2VkICovCgkJYmFzZWxlbiA9IGZpbGxfZGlyZWN0b3J5KCZkaXIsICZ0aGVfaW5kZXgsICZwYXRoc3BlYyk7CgkJaWYgKHBhdGhzcGVjLm5yKQoJCQlzZWVuID0gcHJ1bmVfZGlyZWN0b3J5KCZkaXIsICZwYXRoc3BlYywgYmFzZWxlbik7Cgl9CgoJaWYgKHJlZnJlc2hfb25seSkgewoJCWV4aXRfc3RhdHVzIHw9IHJlZnJlc2godmVyYm9zZSwgJnBhdGhzcGVjKTsKCQlnb3RvIGZpbmlzaDsKCX0KCglpZiAocGF0aHNwZWMubnIpIHsKCQlpbnQgaTsKCQljaGFyICpza2lwX3dvcmt0cmVlX3NlZW4gPSBOVUxMOwoJCXN0cnVjdCBzdHJpbmdfbGlzdCBvbmx5X21hdGNoX3NraXBfd29ya3RyZWUgPSBTVFJJTkdfTElTVF9JTklUX05PRFVQOwoKCQlpZiAoIXNlZW4pCgkJCXNlZW4gPSBmaW5kX3BhdGhzcGVjc19tYXRjaGluZ19hZ2FpbnN0X2luZGV4KCZwYXRoc3BlYywKCQkJCQkmdGhlX2luZGV4LCBQU19JR05PUkVfU0tJUF9XT1JLVFJFRSk7CgoJCS8qCgkJICogZmlsZV9leGlzdHMoKSBhc3N1bWVzIGV4YWN0IG1hdGNoCgkJICovCgkJR1VBUkRfUEFUSFNQRUMoJnBhdGhzcGVjLAoJCQkgICAgICAgUEFUSFNQRUNfRlJPTVRPUCB8CgkJCSAgICAgICBQQVRIU1BFQ19MSVRFUkFMIHwKCQkJICAgICAgIFBBVEhTUEVDX0dMT0IgfAoJCQkgICAgICAgUEFUSFNQRUNfSUNBU0UgfAoJCQkgICAgICAgUEFUSFNQRUNfRVhDTFVERSk7CgoJCWZvciAoaSA9IDA7IGkgPCBwYXRoc3BlYy5ucjsgaSsrKSB7CgkJCWNvbnN0IGNoYXIgKnBhdGggPSBwYXRoc3BlYy5pdGVtc1tpXS5tYXRjaDsKCgkJCWlmIChwYXRoc3BlYy5pdGVtc1tpXS5tYWdpYyAmIFBBVEhTUEVDX0VYQ0xVREUpCgkJCQljb250aW51ZTsKCQkJaWYgKHNlZW5baV0pCgkJCQljb250aW51ZTsKCgkJCWlmICghaW5jbHVkZV9zcGFyc2UgJiYKCQkJICAgIG1hdGNoZXNfc2tpcF93b3JrdHJlZSgmcGF0aHNwZWMsIGksICZza2lwX3dvcmt0cmVlX3NlZW4pKSB7CgkJCQlzdHJpbmdfbGlzdF9hcHBlbmQoJm9ubHlfbWF0Y2hfc2tpcF93b3JrdHJlZSwKCQkJCQkJICAgcGF0aHNwZWMuaXRlbXNbaV0ub3JpZ2luYWwpOwoJCQkJY29udGludWU7CgkJCX0KCgkJCS8qIERvbid0IGNvbXBsYWluIGF0ICdnaXQgYWRkIC4nIG9uIGVtcHR5IHJlcG8gKi8KCQkJaWYgKCFwYXRoWzBdKQoJCQkJY29udGludWU7CgoJCQlpZiAoKHBhdGhzcGVjLml0ZW1zW2ldLm1hZ2ljICYgKFBBVEhTUEVDX0dMT0IgfCBQQVRIU1BFQ19JQ0FTRSkpIHx8CgkJCSAgICAhZmlsZV9leGlzdHMocGF0aCkpIHsKCQkJCWlmIChpZ25vcmVfbWlzc2luZykgewoJCQkJCWludCBkdHlwZSA9IERUX1VOS05PV047CgkJCQkJaWYgKGlzX2V4Y2x1ZGVkKCZkaXIsICZ0aGVfaW5kZXgsIHBhdGgsICZkdHlwZSkpCgkJCQkJCWRpcl9hZGRfaWdub3JlZCgmZGlyLCAmdGhlX2luZGV4LAoJCQkJCQkJCXBhdGgsIHBhdGhzcGVjLml0ZW1zW2ldLmxlbik7CgkJCQl9IGVsc2UKCQkJCQlkaWUoXygicGF0aHNwZWMgJyVzJyBkaWQgbm90IG1hdGNoIGFueSBmaWxlcyIpLAoJCQkJCSAgICBwYXRoc3BlYy5pdGVtc1tpXS5vcmlnaW5hbCk7CgkJCX0KCQl9CgoKCQlpZiAob25seV9tYXRjaF9za2lwX3dvcmt0cmVlLm5yKSB7CgkJCWFkdmlzZV9vbl91cGRhdGluZ19zcGFyc2VfcGF0aHMoJm9ubHlfbWF0Y2hfc2tpcF93b3JrdHJlZSk7CgkJCWV4aXRfc3RhdHVzID0gMTsKCQl9CgoJCWZyZWUoc2Vlbik7CgkJZnJlZShza2lwX3dvcmt0cmVlX3NlZW4pOwoJCXN0cmluZ19saXN0X2NsZWFyKCZvbmx5X21hdGNoX3NraXBfd29ya3RyZWUsIDApOwoJfQoKCWJlZ2luX29kYl90cmFuc2FjdGlvbigpOwoKCWlmIChhZGRfcmVub3JtYWxpemUpCgkJZXhpdF9zdGF0dXMgfD0gcmVub3JtYWxpemVfdHJhY2tlZF9maWxlcygmcGF0aHNwZWMsIGZsYWdzKTsKCWVsc2UKCQlleGl0X3N0YXR1cyB8PSBhZGRfZmlsZXNfdG9fY2FjaGUodGhlX3JlcG9zaXRvcnksIHByZWZpeCwKCQkJCQkJICAmcGF0aHNwZWMsIGluY2x1ZGVfc3BhcnNlLAoJCQkJCQkgIGZsYWdzKTsKCglpZiAoYWRkX25ld19maWxlcykKCQlleGl0X3N0YXR1cyB8PSBhZGRfZmlsZXMoJmRpciwgZmxhZ3MpOwoKCWlmIChjaG1vZF9hcmcgJiYgcGF0aHNwZWMubnIpCgkJZXhpdF9zdGF0dXMgfD0gY2htb2RfcGF0aHNwZWMoJnBhdGhzcGVjLCBjaG1vZF9hcmdbMF0sIHNob3dfb25seSk7CgllbmRfb2RiX3RyYW5zYWN0aW9uKCk7CgpmaW5pc2g6CglpZiAod3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZsb2NrX2ZpbGUsCgkJCSAgICAgICBDT01NSVRfTE9DSyB8IFNLSVBfSUZfVU5DSEFOR0VEKSkKCQlkaWUoXygidW5hYmxlIHRvIHdyaXRlIG5ldyBpbmRleCBmaWxlIikpOwoKCWRpcl9jbGVhcigmZGlyKTsKCWNsZWFyX3BhdGhzcGVjKCZwYXRoc3BlYyk7CglyZXR1cm4gZXhpdF9zdGF0dXM7Cn0K",
    "text": "/*\n * \"git add\" builtin command\n *\n * Copyright (C) 2006 Linus Torvalds\n */\n#define USE_THE_INDEX_VARIABLE\n#include \"builtin.h\"\n#include \"advice.h\"\n#include \"config.h\"\n#include \"lockfile.h\"\n#include \"editor.h\"\n#include \"dir.h\"\n#include \"gettext.h\"\n#include \"pathspec.h\"\n#include \"exec-cmd.h\"\n#include \"cache-tree.h\"\n#include \"run-command.h\"\n#include \"parse-options.h\"\n#include \"path.h\"\n#include \"preload-index.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"read-cache.h\"\n#include \"repository.h\"\n#include \"revision.h\"\n#include \"bulk-checkin.h\"\n#include \"strvec.h\"\n#include \"submodule.h\"\n#include \"add-interactive.h\"\n\nstatic const char * const builtin_add_usage[] = {\n\tN_(\"git add [<options>] [--] <pathspec>...\"),\n\tNULL\n};\nstatic int patch_interactive, add_interactive, edit_interactive;\nstatic int take_worktree_changes;\nstatic int add_renormalize;\nstatic int pathspec_file_nul;\nstatic int include_sparse;\nstatic const char *pathspec_from_file;\n\nstatic int chmod_pathspec(struct pathspec *pathspec, char flip, int show_only)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < the_index.cache_nr; i++) {\n\t\tstruct cache_entry *ce = the_index.cache[i];\n\t\tint err;\n\n\t\tif (!include_sparse &&\n\t\t    (ce_skip_worktree(ce) ||\n\t\t     !path_in_sparse_checkout(ce->name, &the_index)))\n\t\t\tcontinue;\n\n\t\tif (pathspec && !ce_path_match(&the_index, ce, pathspec, NULL))\n\t\t\tcontinue;\n\n\t\tif (!show_only)\n\t\t\terr = chmod_index_entry(&the_index, ce, flip);\n\t\telse\n\t\t\terr = S_ISREG(ce->ce_mode) ? 0 : -1;\n\n\t\tif (err < 0)\n\t\t\tret = error(_(\"cannot chmod %cx '%s'\"), flip, ce->name);\n\t}\n\n\treturn ret;\n}\n\nstatic int renormalize_tracked_files(const struct pathspec *pathspec, int flags)\n{\n\tint i, retval = 0;\n\n\tfor (i = 0; i < the_index.cache_nr; i++) {\n\t\tstruct cache_entry *ce = the_index.cache[i];\n\n\t\tif (!include_sparse &&\n\t\t    (ce_skip_worktree(ce) ||\n\t\t     !path_in_sparse_checkout(ce->name, &the_index)))\n\t\t\tcontinue;\n\t\tif (ce_stage(ce))\n\t\t\tcontinue; /* do not touch unmerged paths */\n\t\tif (!S_ISREG(ce->ce_mode) && !S_ISLNK(ce->ce_mode))\n\t\t\tcontinue; /* do not touch non blobs */\n\t\tif (pathspec && !ce_path_match(&the_index, ce, pathspec, NULL))\n\t\t\tcontinue;\n\t\tretval |= add_file_to_index(&the_index, ce->name,\n\t\t\t\t\t    flags | ADD_CACHE_RENORMALIZE);\n\t}\n\n\treturn retval;\n}\n\nstatic char *prune_directory(struct dir_struct *dir, struct pathspec *pathspec, int prefix)\n{\n\tchar *seen;\n\tint i;\n\tstruct dir_entry **src, **dst;\n\n\tseen = xcalloc(pathspec->nr, 1);\n\n\tsrc = dst = dir->entries;\n\ti = dir->nr;\n\twhile (--i >= 0) {\n\t\tstruct dir_entry *entry = *src++;\n\t\tif (dir_path_match(&the_index, entry, pathspec, prefix, seen))\n\t\t\t*dst++ = entry;\n\t}\n\tdir->nr = dst - dir->entries;\n\tadd_pathspec_matches_against_index(pathspec, &the_index, seen,\n\t\t\t\t\t   PS_IGNORE_SKIP_WORKTREE);\n\treturn seen;\n}\n\nstatic int refresh(int verbose, const struct pathspec *pathspec)\n{\n\tchar *seen;\n\tint i, ret = 0;\n\tchar *skip_worktree_seen = NULL;\n\tstruct string_list only_match_skip_worktree = STRING_LIST_INIT_NODUP;\n\tint flags = REFRESH_IGNORE_SKIP_WORKTREE |\n\t\t    (verbose ? REFRESH_IN_PORCELAIN : REFRESH_QUIET);\n\n\tseen = xcalloc(pathspec->nr, 1);\n\trefresh_index(&the_index, flags, pathspec, seen,\n\t\t      _(\"Unstaged changes after refreshing the index:\"));\n\tfor (i = 0; i < pathspec->nr; i++) {\n\t\tif (!seen[i]) {\n\t\t\tconst char *path = pathspec->items[i].original;\n\n\t\t\tif (matches_skip_worktree(pathspec, i, &skip_worktree_seen) ||\n\t\t\t    !path_in_sparse_checkout(path, &the_index)) {\n\t\t\t\tstring_list_append(&only_match_skip_worktree,\n\t\t\t\t\t\t   pathspec->items[i].original);\n\t\t\t} else {\n\t\t\t\tdie(_(\"pathspec '%s' did not match any files\"),\n\t\t\t\t    pathspec->items[i].original);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (only_match_skip_worktree.nr) {\n\t\tadvise_on_updating_sparse_paths(&only_match_skip_worktree);\n\t\tret = 1;\n\t}\n\n\tfree(seen);\n\tfree(skip_worktree_seen);\n\tstring_list_clear(&only_match_skip_worktree, 0);\n\treturn ret;\n}\n\nint interactive_add(const char **argv, const char *prefix, int patch)\n{\n\tstruct pathspec pathspec;\n\tint unused;\n\n\tif (!git_config_get_bool(\"add.interactive.usebuiltin\", &unused))\n\t\twarning(_(\"the add.interactive.useBuiltin setting has been removed!\\n\"\n\t\t\t  \"See its entry in 'git help config' for details.\"));\n\n\tparse_pathspec(&pathspec, 0,\n\t\t       PATHSPEC_PREFER_FULL |\n\t\t       PATHSPEC_SYMLINK_LEADING_PATH |\n\t\t       PATHSPEC_PREFIX_ORIGIN,\n\t\t       prefix, argv);\n\n\tif (patch)\n\t\treturn !!run_add_p(the_repository, ADD_P_ADD, NULL, &pathspec);\n\telse\n\t\treturn !!run_add_i(the_repository, &pathspec);\n}\n\nstatic int edit_patch(int argc, const char **argv, const char *prefix)\n{\n\tchar *file = git_pathdup(\"ADD_EDIT.patch\");\n\tstruct child_process child = CHILD_PROCESS_INIT;\n\tstruct rev_info rev;\n\tint out;\n\tstruct stat st;\n\n\tgit_config(git_diff_basic_config, NULL); /* no \"diff\" UI options */\n\n\tif (repo_read_index(the_repository) < 0)\n\t\tdie(_(\"could not read the index\"));\n\n\trepo_init_revisions(the_repository, &rev, prefix);\n\trev.diffopt.context = 7;\n\n\targc = setup_revisions(argc, argv, &rev, NULL);\n\trev.diffopt.output_format = DIFF_FORMAT_PATCH;\n\trev.diffopt.use_color = 0;\n\trev.diffopt.flags.ignore_dirty_submodules = 1;\n\tout = xopen(file, O_CREAT | O_WRONLY | O_TRUNC, 0666);\n\trev.diffopt.file = xfdopen(out, \"w\");\n\trev.diffopt.close_file = 1;\n\trun_diff_files(&rev, 0);\n\n\tif (launch_editor(file, NULL, NULL))\n\t\tdie(_(\"editing patch failed\"));\n\n\tif (stat(file, &st))\n\t\tdie_errno(_(\"could not stat '%s'\"), file);\n\tif (!st.st_size)\n\t\tdie(_(\"empty patch. aborted\"));\n\n\tchild.git_cmd = 1;\n\tstrvec_pushl(&child.args, \"apply\", \"--recount\", \"--cached\", file,\n\t\t     NULL);\n\tif (run_command(&child))\n\t\tdie(_(\"could not apply '%s'\"), file);\n\n\tunlink(file);\n\tfree(file);\n\trelease_revisions(&rev);\n\treturn 0;\n}\n\nstatic const char ignore_error[] =\nN_(\"The following paths are ignored by one of your .gitignore files:\\n\");\n\nstatic int verbose, show_only, ignored_too, refresh_only;\nstatic int ignore_add_errors, intent_to_add, ignore_missing;\nstatic int warn_on_embedded_repo = 1;\n\n#define ADDREMOVE_DEFAULT 1\nstatic int addremove = ADDREMOVE_DEFAULT;\nstatic int addremove_explicit = -1; /* unspecified */\n\nstatic char *chmod_arg;\n\nstatic int ignore_removal_cb(const struct option *opt, const char *arg, int unset)\n{\n\t/* if we are told to ignore, we are not adding removals */\n\t*(int *)opt->value = !unset ? 0 : 1;\n\treturn 0;\n}\n\nstatic struct option builtin_add_options[] = {\n\tOPT__DRY_RUN(&show_only, N_(\"dry run\")),\n\tOPT__VERBOSE(&verbose, N_(\"be verbose\")),\n\tOPT_GROUP(\"\"),\n\tOPT_BOOL('i', \"interactive\", &add_interactive, N_(\"interactive picking\")),\n\tOPT_BOOL('p', \"patch\", &patch_interactive, N_(\"select hunks interactively\")),\n\tOPT_BOOL('e', \"edit\", &edit_interactive, N_(\"edit current diff and apply\")),\n\tOPT__FORCE(&ignored_too, N_(\"allow adding otherwise ignored files\"), 0),\n\tOPT_BOOL('u', \"update\", &take_worktree_changes, N_(\"update tracked files\")),\n\tOPT_BOOL(0, \"renormalize\", &add_renormalize, N_(\"renormalize EOL of tracked files (implies -u)\")),\n\tOPT_BOOL('N', \"intent-to-add\", &intent_to_add, N_(\"record only the fact that the path will be added later\")),\n\tOPT_BOOL('A', \"all\", &addremove_explicit, N_(\"add changes from all tracked and untracked files\")),\n\tOPT_CALLBACK_F(0, \"ignore-removal\", &addremove_explicit,\n\t  NULL /* takes no arguments */,\n\t  N_(\"ignore paths removed in the working tree (same as --no-all)\"),\n\t  PARSE_OPT_NOARG, ignore_removal_cb),\n\tOPT_BOOL( 0 , \"refresh\", &refresh_only, N_(\"don't add, only refresh the index\")),\n\tOPT_BOOL( 0 , \"ignore-errors\", &ignore_add_errors, N_(\"just skip files which cannot be added because of errors\")),\n\tOPT_BOOL( 0 , \"ignore-missing\", &ignore_missing, N_(\"check if - even missing - files are ignored in dry run\")),\n\tOPT_BOOL(0, \"sparse\", &include_sparse, N_(\"allow updating entries outside of the sparse-checkout cone\")),\n\tOPT_STRING(0, \"chmod\", &chmod_arg, \"(+|-)x\",\n\t\t   N_(\"override the executable bit of the listed files\")),\n\tOPT_HIDDEN_BOOL(0, \"warn-embedded-repo\", &warn_on_embedded_repo,\n\t\t\tN_(\"warn when adding an embedded repository\")),\n\tOPT_PATHSPEC_FROM_FILE(&pathspec_from_file),\n\tOPT_PATHSPEC_FILE_NUL(&pathspec_file_nul),\n\tOPT_END(),\n};\n\nstatic int add_config(const char *var, const char *value,\n\t\t      const struct config_context *ctx, void *cb)\n{\n\tif (!strcmp(var, \"add.ignoreerrors\") ||\n\t    !strcmp(var, \"add.ignore-errors\")) {\n\t\tignore_add_errors = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (git_color_config(var, value, cb) < 0)\n\t\treturn -1;\n\n\treturn git_default_config(var, value, ctx, cb);\n}\n\nstatic const char embedded_advice[] = N_(\n\"You've added another git repository inside your current repository.\\n\"\n\"Clones of the outer repository will not contain the contents of\\n\"\n\"the embedded repository and will not know how to obtain it.\\n\"\n\"If you meant to add a submodule, use:\\n\"\n\"\\n\"\n\"\tgit submodule add <url> %s\\n\"\n\"\\n\"\n\"If you added this path by mistake, you can remove it from the\\n\"\n\"index with:\\n\"\n\"\\n\"\n\"\tgit rm --cached %s\\n\"\n\"\\n\"\n\"See \\\"git help submodule\\\" for more information.\"\n);\n\nstatic void check_embedded_repo(const char *path)\n{\n\tstruct strbuf name = STRBUF_INIT;\n\tstatic int adviced_on_embedded_repo = 0;\n\n\tif (!warn_on_embedded_repo)\n\t\treturn;\n\tif (!ends_with(path, \"/\"))\n\t\treturn;\n\n\t/* Drop trailing slash for aesthetics */\n\tstrbuf_addstr(&name, path);\n\tstrbuf_strip_suffix(&name, \"/\");\n\n\twarning(_(\"adding embedded git repository: %s\"), name.buf);\n\tif (!adviced_on_embedded_repo &&\n\t    advice_enabled(ADVICE_ADD_EMBEDDED_REPO)) {\n\t\tadvise(embedded_advice, name.buf, name.buf);\n\t\tadviced_on_embedded_repo = 1;\n\t}\n\n\tstrbuf_release(&name);\n}\n\nstatic int add_files(struct dir_struct *dir, int flags)\n{\n\tint i, exit_status = 0;\n\tstruct string_list matched_sparse_paths = STRING_LIST_INIT_NODUP;\n\n\tif (dir->ignored_nr) {\n\t\tfprintf(stderr, _(ignore_error));\n\t\tfor (i = 0; i < dir->ignored_nr; i++)\n\t\t\tfprintf(stderr, \"%s\\n\", dir->ignored[i]->name);\n\t\tif (advice_enabled(ADVICE_ADD_IGNORED_FILE))\n\t\t\tadvise(_(\"Use -f if you really want to add them.\\n\"\n\t\t\t\t\"Turn this message off by running\\n\"\n\t\t\t\t\"\\\"git config advice.addIgnoredFile false\\\"\"));\n\t\texit_status = 1;\n\t}\n\n\tfor (i = 0; i < dir->nr; i++) {\n\t\tif (!include_sparse &&\n\t\t    !path_in_sparse_checkout(dir->entries[i]->name, &the_index)) {\n\t\t\tstring_list_append(&matched_sparse_paths,\n\t\t\t\t\t   dir->entries[i]->name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (add_file_to_index(&the_index, dir->entries[i]->name, flags)) {\n\t\t\tif (!ignore_add_errors)\n\t\t\t\tdie(_(\"adding files failed\"));\n\t\t\texit_status = 1;\n\t\t} else {\n\t\t\tcheck_embedded_repo(dir->entries[i]->name);\n\t\t}\n\t}\n\n\tif (matched_sparse_paths.nr) {\n\t\tadvise_on_updating_sparse_paths(&matched_sparse_paths);\n\t\texit_status = 1;\n\t}\n\n\tstring_list_clear(&matched_sparse_paths, 0);\n\n\treturn exit_status;\n}\n\nint cmd_add(int argc, const char **argv, const char *prefix)\n{\n\tint exit_status = 0;\n\tstruct pathspec pathspec;\n\tstruct dir_struct dir = DIR_INIT;\n\tint flags;\n\tint add_new_files;\n\tint require_pathspec;\n\tchar *seen = NULL;\n\tstruct lock_file lock_file = LOCK_INIT;\n\n\tgit_config(add_config, NULL);\n\n\targc = parse_options(argc, argv, prefix, builtin_add_options,\n\t\t\t  builtin_add_usage, PARSE_OPT_KEEP_ARGV0);\n\tif (patch_interactive)\n\t\tadd_interactive = 1;\n\tif (add_interactive) {\n\t\tif (show_only)\n\t\t\tdie(_(\"options '%s' and '%s' cannot be used together\"), \"--dry-run\", \"--interactive/--patch\");\n\t\tif (pathspec_from_file)\n\t\t\tdie(_(\"options '%s' and '%s' cannot be used together\"), \"--pathspec-from-file\", \"--interactive/--patch\");\n\t\texit(interactive_add(argv + 1, prefix, patch_interactive));\n\t}\n\n\tif (edit_interactive) {\n\t\tif (pathspec_from_file)\n\t\t\tdie(_(\"options '%s' and '%s' cannot be used together\"), \"--pathspec-from-file\", \"--edit\");\n\t\treturn(edit_patch(argc, argv, prefix));\n\t}\n\targc--;\n\targv++;\n\n\tif (0 <= addremove_explicit)\n\t\taddremove = addremove_explicit;\n\telse if (take_worktree_changes && ADDREMOVE_DEFAULT)\n\t\taddremove = 0; /* \"-u\" was given but not \"-A\" */\n\n\tif (addremove && take_worktree_changes)\n\t\tdie(_(\"options '%s' and '%s' cannot be used together\"), \"-A\", \"-u\");\n\n\tif (!show_only && ignore_missing)\n\t\tdie(_(\"the option '%s' requires '%s'\"), \"--ignore-missing\", \"--dry-run\");\n\n\tif (chmod_arg && ((chmod_arg[0] != '-' && chmod_arg[0] != '+') ||\n\t\t\t  chmod_arg[1] != 'x' || chmod_arg[2]))\n\t\tdie(_(\"--chmod param '%s' must be either -x or +x\"), chmod_arg);\n\n\tadd_new_files = !take_worktree_changes && !refresh_only && !add_renormalize;\n\trequire_pathspec = !(take_worktree_changes || (0 < addremove_explicit));\n\n\tprepare_repo_settings(the_repository);\n\tthe_repository->settings.command_requires_full_index = 0;\n\n\trepo_hold_locked_index(the_repository, &lock_file, LOCK_DIE_ON_ERROR);\n\n\t/*\n\t * Check the \"pathspec '%s' did not match any files\" block\n\t * below before enabling new magic.\n\t */\n\tparse_pathspec(&pathspec, PATHSPEC_ATTR,\n\t\t       PATHSPEC_PREFER_FULL |\n\t\t       PATHSPEC_SYMLINK_LEADING_PATH,\n\t\t       prefix, argv);\n\n\tif (pathspec_from_file) {\n\t\tif (pathspec.nr)\n\t\t\tdie(_(\"'%s' and pathspec arguments cannot be used together\"), \"--pathspec-from-file\");\n\n\t\tparse_pathspec_file(&pathspec, PATHSPEC_ATTR,\n\t\t\t\t    PATHSPEC_PREFER_FULL |\n\t\t\t\t    PATHSPEC_SYMLINK_LEADING_PATH,\n\t\t\t\t    prefix, pathspec_from_file, pathspec_file_nul);\n\t} else if (pathspec_file_nul) {\n\t\tdie(_(\"the option '%s' requires '%s'\"), \"--pathspec-file-nul\", \"--pathspec-from-file\");\n\t}\n\n\tif (require_pathspec && pathspec.nr == 0) {\n\t\tfprintf(stderr, _(\"Nothing specified, nothing added.\\n\"));\n\t\tif (advice_enabled(ADVICE_ADD_EMPTY_PATHSPEC))\n\t\t\tadvise( _(\"Maybe you wanted to say 'git add .'?\\n\"\n\t\t\t\t\"Turn this message off by running\\n\"\n\t\t\t\t\"\\\"git config advice.addEmptyPathspec false\\\"\"));\n\t\treturn 0;\n\t}\n\n\tif (!take_worktree_changes && addremove_explicit < 0 && pathspec.nr)\n\t\t/* Turn \"git add pathspec...\" to \"git add -A pathspec...\" */\n\t\taddremove = 1;\n\n\tflags = ((verbose ? ADD_CACHE_VERBOSE : 0) |\n\t\t (show_only ? ADD_CACHE_PRETEND : 0) |\n\t\t (intent_to_add ? ADD_CACHE_INTENT : 0) |\n\t\t (ignore_add_errors ? ADD_CACHE_IGNORE_ERRORS : 0) |\n\t\t (!(addremove || take_worktree_changes)\n\t\t  ? ADD_CACHE_IGNORE_REMOVAL : 0));\n\n\tif (repo_read_index_preload(the_repository, &pathspec, 0) < 0)\n\t\tdie(_(\"index file corrupt\"));\n\n\tdie_in_unpopulated_submodule(&the_index, prefix);\n\tdie_path_inside_submodule(&the_index, &pathspec);\n\n\tif (add_new_files) {\n\t\tint baselen;\n\n\t\t/* Set up the default git porcelain excludes */\n\t\tif (!ignored_too) {\n\t\t\tdir.flags |= DIR_COLLECT_IGNORED;\n\t\t\tsetup_standard_excludes(&dir);\n\t\t}\n\n\t\t/* This picks up the paths that are not tracked */\n\t\tbaselen = fill_directory(&dir, &the_index, &pathspec);\n\t\tif (pathspec.nr)\n\t\t\tseen = prune_directory(&dir, &pathspec, baselen);\n\t}\n\n\tif (refresh_only) {\n\t\texit_status |= refresh(verbose, &pathspec);\n\t\tgoto finish;\n\t}\n\n\tif (pathspec.nr) {\n\t\tint i;\n\t\tchar *skip_worktree_seen = NULL;\n\t\tstruct string_list only_match_skip_worktree = STRING_LIST_INIT_NODUP;\n\n\t\tif (!seen)\n\t\t\tseen = find_pathspecs_matching_against_index(&pathspec,\n\t\t\t\t\t&the_index, PS_IGNORE_SKIP_WORKTREE);\n\n\t\t/*\n\t\t * file_exists() assumes exact match\n\t\t */\n\t\tGUARD_PATHSPEC(&pathspec,\n\t\t\t       PATHSPEC_FROMTOP |\n\t\t\t       PATHSPEC_LITERAL |\n\t\t\t       PATHSPEC_GLOB |\n\t\t\t       PATHSPEC_ICASE |\n\t\t\t       PATHSPEC_EXCLUDE);\n\n\t\tfor (i = 0; i < pathspec.nr; i++) {\n\t\t\tconst char *path = pathspec.items[i].match;\n\n\t\t\tif (pathspec.items[i].magic & PATHSPEC_EXCLUDE)\n\t\t\t\tcontinue;\n\t\t\tif (seen[i])\n\t\t\t\tcontinue;\n\n\t\t\tif (!include_sparse &&\n\t\t\t    matches_skip_worktree(&pathspec, i, &skip_worktree_seen)) {\n\t\t\t\tstring_list_append(&only_match_skip_worktree,\n\t\t\t\t\t\t   pathspec.items[i].original);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Don't complain at 'git add .' on empty repo */\n\t\t\tif (!path[0])\n\t\t\t\tcontinue;\n\n\t\t\tif ((pathspec.items[i].magic & (PATHSPEC_GLOB | PATHSPEC_ICASE)) ||\n\t\t\t    !file_exists(path)) {\n\t\t\t\tif (ignore_missing) {\n\t\t\t\t\tint dtype = DT_UNKNOWN;\n\t\t\t\t\tif (is_excluded(&dir, &the_index, path, &dtype))\n\t\t\t\t\t\tdir_add_ignored(&dir, &the_index,\n\t\t\t\t\t\t\t\tpath, pathspec.items[i].len);\n\t\t\t\t} else\n\t\t\t\t\tdie(_(\"pathspec '%s' did not match any files\"),\n\t\t\t\t\t    pathspec.items[i].original);\n\t\t\t}\n\t\t}\n\n\n\t\tif (only_match_skip_worktree.nr) {\n\t\t\tadvise_on_updating_sparse_paths(&only_match_skip_worktree);\n\t\t\texit_status = 1;\n\t\t}\n\n\t\tfree(seen);\n\t\tfree(skip_worktree_seen);\n\t\tstring_list_clear(&only_match_skip_worktree, 0);\n\t}\n\n\tbegin_odb_transaction();\n\n\tif (add_renormalize)\n\t\texit_status |= renormalize_tracked_files(&pathspec, flags);\n\telse\n\t\texit_status |= add_files_to_cache(the_repository, prefix,\n\t\t\t\t\t\t  &pathspec, include_sparse,\n\t\t\t\t\t\t  flags);\n\n\tif (add_new_files)\n\t\texit_status |= add_files(&dir, flags);\n\n\tif (chmod_arg && pathspec.nr)\n\t\texit_status |= chmod_pathspec(&pathspec, chmod_arg[0], show_only);\n\tend_odb_transaction();\n\nfinish:\n\tif (write_locked_index(&the_index, &lock_file,\n\t\t\t       COMMIT_LOCK | SKIP_IF_UNCHANGED))\n\t\tdie(_(\"unable to write new index file\"));\n\n\tdir_clear(&dir);\n\tclear_pathspec(&pathspec);\n\treturn exit_status;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0057392f988fdbaebc55628585b5d519e93307ed",
  "sha1_ok": true,
  "size": 16833
}
