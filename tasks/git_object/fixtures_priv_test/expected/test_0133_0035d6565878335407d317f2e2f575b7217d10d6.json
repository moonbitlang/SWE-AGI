{
  "content": {
    "base64": "IyEvdXNyL2Jpbi9wZXJsIC13CiMgTWFpbnRhaW4gIndoYXQncyBjb29raW5nIiBtZXNzYWdlcwoKdXNlIHN0cmljdDsKCm15ICVyZXZlcnRzID0gKCduZXh0JyA9PiB7CgltYXAgeyAkXyA9PiAxIH0gcXcoCgkgICAgKSB9KTsKCiVyZXZlcnRzID0gKCk7CgpzdWIgcGhyYXNlX3RoZXNlIHsKCW15ICV1bmlxID0gKCk7CglteSAoQHUpID0gZ3JlcCB7ICR1bmlxeyRffSsrID09IDAgfSBzb3J0IEBfOwoJbXkgQGQgPSAoKTsKCWZvciAobXkgJGkgPSAwOyAkaSA8IEB1OyAkaSsrKSB7CgkJcHVzaCBAZCwgJHVbJGldOwoJCWlmICgkaSA9PSBAdSAtIDIpIHsKCQkJcHVzaCBAZCwgIiBhbmQgIjsKCQl9IGVsc2lmICgkaSA8IEB1IC0gMikgewoJCQlwdXNoIEBkLCAiLCAiOwoJCX0KCX0KCXJldHVybiBqb2luKCcnLCBAZCk7Cn0KCnN1YiBkZXNjcmliZV9yZWxhdGlvbiB7CglteSAoJHRvcGljX2luZm8pID0gQF87CglteSBAZGVzYzsKCglpZiAoZXhpc3RzICR0b3BpY19pbmZvLT57J3VzZWQnfSkgewoJCXB1c2ggQGRlc2MsICgiaXMgdXNlZCBieSAiIC4KCQkJICAgICBwaHJhc2VfdGhlc2UoQHskdG9waWNfaW5mby0+eyd1c2VkJ319KSk7Cgl9CgoJaWYgKGV4aXN0cyAkdG9waWNfaW5mby0+eyd1c2VzJ30pIHsKCQlwdXNoIEBkZXNjLCAoInVzZXMgIiAuCgkJCSAgICAgcGhyYXNlX3RoZXNlKEB7JHRvcGljX2luZm8tPnsndXNlcyd9fSkpOwoJfQoKCWlmIChleGlzdHMgJHRvcGljX2luZm8tPnsnc2hhcmVzJ30pIHsKCQlwdXNoIEBkZXNjLCAoImlzIHRhbmdsZWQgd2l0aCAiIC4KCQkJICAgICBwaHJhc2VfdGhlc2UoQHskdG9waWNfaW5mby0+eydzaGFyZXMnfX0pKTsKCX0KCglpZiAoIUBkZXNjKSB7CgkJcmV0dXJuICIiOwoJfQoKCXJldHVybiAiKHRoaXMgYnJhbmNoICIgLiBqb2luKCI7ICIsIEBkZXNjKSAuICIuKSI7Cn0KCnN1YiBmb3Jrc19mcm9tIHsKCW15ICgkdG9waWMsICRmb3JrLCAkZm9ya2VlLCBAb3ZlcmxhcCkgPSBAXzsKCW15ICVvdmwgPSBtYXAgeyAkXyA9PiAxIH0gKEBvdmVybGFwLCBAeyR0b3BpYy0+eyRmb3JrZWV9eydsb2cnfX0pOwoKCXB1c2ggQHskdG9waWMtPnskZm9ya317J3VzZXMnfX0sICRmb3JrZWU7CglwdXNoIEB7JHRvcGljLT57JGZvcmtlZX17J3VzZWQnfX0sICRmb3JrOwoJQHskdG9waWMtPnskZm9ya317J2xvZyd9fSA9IChncmVwIHsgIWV4aXN0cyAkb3ZseyRffSB9CgkJCQkgICAgIEB7JHRvcGljLT57JGZvcmt9eydsb2cnfX0pOwp9CgpzdWIgdG9waWNfcmVsYXRpb24gewoJbXkgKCR0b3BpYywgJG9uZSwgJHR3bykgPSBAXzsKCglteSAkZmg7CglvcGVuKCRmaCwgJy18JywKCSAgICAgcXcoZ2l0IGxvZyAtLWFiYnJldiksICItLWZvcm1hdD0lbSAlaCIsCgkgICAgICIkb25lLi4uJHR3byIsICJebWFzdGVyIikKCSAgICBvciBkaWUgIiQhOiBvcGVuIGxvZyAtLWxlZnQtcmlnaHQiOwoJbXkgKEBsZWZ0LCBAcmlnaHQpOwoJd2hpbGUgKDwkZmg+KSB7CgkJbXkgKCRzaWduLCAkc2hhMSkgPSAvXiguKSAoLiopLzsKCQlpZiAoJHNpZ24gZXEgJzwnKSB7CgkJCXB1c2ggQGxlZnQsICRzaGExOwoJCX0gZWxzaWYgKCRzaWduIGVxICc+JykgewoJCQlwdXNoIEByaWdodCwgJHNoYTE7CgkJfQoJfQoJY2xvc2UoJGZoKSBvciBkaWUgIiQhOiBjbG9zZSBsb2cgLS1sZWZ0LXJpZ2h0IjsKCglpZiAoIUBsZWZ0KSB7CgkJaWYgKEByaWdodCkgewoJCQlmb3Jrc19mcm9tKCR0b3BpYywgJHR3bywgJG9uZSk7CgkJfQoJfSBlbHNpZiAoIUByaWdodCkgewoJCWZvcmtzX2Zyb20oJHRvcGljLCAkb25lLCAkdHdvKTsKCX0gZWxzZSB7CgkJcHVzaCBAeyR0b3BpYy0+eyRvbmV9eydzaGFyZXMnfX0sICR0d287CgkJcHVzaCBAeyR0b3BpYy0+eyR0d299eydzaGFyZXMnfX0sICRvbmU7Cgl9Cn0KCj1oZWFkMQpJbnNwZWN0IHRoZSBjdXJyZW50IHNldCBvZiB0b3BpY3MKClJldHVybnMgYSBoYXNoOgoKICAgICR0b3BpYyA9IHsKICAgICAgICAkYnJhbmNobmFtZSA9PiB7CiAgICAgICAgICAgICd0aXBkYXRlJyA9PiBkYXRlIG9mIHRoZSB0aXAgY29tbWl0LAoJICAgICdkZXNjJyA9PiBkZXNjcmlwdGlvbiBzdHJpbmcsCgkgICAgJ2xvZycgPT4gWyAkY29tbWl0LC4uLiBdLAogICAgICAgIH0sCiAgICB9Cgo9Y3V0CgpzdWIgZ2V0X2NvbW1pdCB7CglteSAoQGJhc2UpID0gcXcobWFzdGVyIG5leHQgcHUpOwoJbXkgJGZoOwoJb3BlbigkZmgsICctfCcsCgkgICAgIHF3KGdpdCBmb3ItZWFjaC1yZWYpLAoJICAgICAiLS1mb3JtYXQ9JShyZWZuYW1lOnNob3J0KSAlKGNvbW1pdHRlcmRhdGU6aXNvODYwMSkiLAoJICAgICAicmVmcy9oZWFkcy8/Py8qIikKCSAgICBvciBkaWUgIiQhOiBvcGVuIGZvci1lYWNoLXJlZiI7CglteSBAdG9waWM7CglteSAldG9waWM7CgoJd2hpbGUgKDwkZmg+KSB7CgkJY2hvbXA7CgkJbXkgKCRicmFuY2gsICRkYXRlKSA9IC9eKFxTKykgKC4qKSQvOwoJCXB1c2ggQHRvcGljLCAkYnJhbmNoOwoJCSRkYXRlID1+IHMvIC4qLy87CgkJJHRvcGljeyRicmFuY2h9ID0gK3sKCQkJbG9nID0+IFtdLAoJCQl0aXBkYXRlID0+ICRkYXRlLAoJCX07Cgl9CgljbG9zZSgkZmgpIG9yIGRpZSAiJCE6IGNsb3NlIGZvci1lYWNoLXJlZiI7CgoJbXkgJWJhc2UgPSBtYXAgeyAkXyA9PiB1bmRlZiB9IEBiYXNlOwoJbXkgJWNvbW1pdDsKCW15ICRzaG93X2JyYW5jaF9iYXRjaCA9IDIwOwoKCXdoaWxlIChAdG9waWMpIHsKCQlteSBAdCA9IChAYmFzZSwgc3BsaWNlKEB0b3BpYywgMCwgJHNob3dfYnJhbmNoX2JhdGNoKSk7CgkJbXkgJGhlYWRlcl9kZWxpbSA9ICctJyB4IHNjYWxhcihAdCk7CgkJbXkgJGNvbnRhaW5fcGF0ID0gJy4nIHggc2NhbGFyKEB0KTsKCQlvcGVuKCRmaCwgJy18JywgcXcoZ2l0IHNob3ctYnJhbmNoIC0tc3BhcnNlIC0tc2hhMS1uYW1lKSwKCQkgICAgIG1hcCB7ICJyZWZzL2hlYWRzLyRfIiB9IEB0KQoJCSAgICBvciBkaWUgIiQhOiBvcGVuIHNob3ctYnJhbmNoIjsKCQl3aGlsZSAoPCRmaD4pIHsKCQkJY2hvbXA7CgkJCWlmICgkaGVhZGVyX2RlbGltKSB7CgkJCQlpZiAoL14kaGVhZGVyX2RlbGltJC8pIHsKCQkJCQkkaGVhZGVyX2RlbGltID0gdW5kZWY7CgkJCQl9CgkJCQluZXh0OwoJCQl9CgkJCW15ICgkY29udGFpbiwgJHNoYTEsICRsb2cpID0KCQkJICAgICgkXyA9fiAvXigkY29udGFpbl9wYXQpIFxbKFswLTlhLWZdKylcXSAoLiopJC8pOwoKCQkJZm9yIChteSAkaSA9IDA7ICRpIDwgQHQ7ICRpKyspIHsKCQkJCW15ICRicmFuY2ggPSAkdFskaV07CgkJCQlteSAkc2lnbiA9IHN1YnN0cigkY29udGFpbiwgJGksIDEpOwoJCQkJbmV4dCBpZiAoJHNpZ24gZXEgJyAnKTsKCQkJCW5leHQgaWYgKHN1YnN0cigkY29udGFpbiwgMCwgMSkgbmUgJyAnKTsKCgkJCQlpZiAoIWV4aXN0cyAkY29tbWl0eyRzaGExfSkgewoJCQkJCSRjb21taXR7JHNoYTF9ID0gK3sKCQkJCQkJYnJhbmNoID0+IHt9LAoJCQkJCQlsb2cgPT4gJGxvZywKCQkJCQl9OwoJCQkJfQoJCQkJbXkgJGNvID0gJGNvbW1pdHskc2hhMX07CgkJCQlpZiAoIWV4aXN0cyAkcmV2ZXJ0c3skYnJhbmNofXskc2hhMX0pIHsKCQkJCQkkY28tPnsnYnJhbmNoJ317JGJyYW5jaH0gPSAxOwoJCQkJfQoJCQkJbmV4dCBpZiAoZXhpc3RzICRiYXNleyRicmFuY2h9KTsKCQkJCXB1c2ggQHskdG9waWN7JGJyYW5jaH17J2xvZyd9fSwgJHNoYTE7CgkJCX0KCQl9CgkJY2xvc2UoJGZoKSBvciBkaWUgIiQhOiBjbG9zZSBzaG93LWJyYW5jaCI7Cgl9CgoJbXkgJXNoYXJlZDsKCWZvciBteSAkc2hhMSAoa2V5cyAlY29tbWl0KSB7CgkJbXkgJHNpZ247CgkJbXkgJGNvID0gJGNvbW1pdHskc2hhMX07CgkJaWYgKGV4aXN0cyAkY28tPnsnYnJhbmNoJ317J25leHQnfSkgewoJCQkkc2lnbiA9ICcrJzsKCQl9IGVsc2lmIChleGlzdHMgJGNvLT57J2JyYW5jaCd9eydwdSd9KSB7CgkJCSRzaWduID0gJy0nOwoJCX0gZWxzZSB7CgkJCSRzaWduID0gJy4nOwoJCX0KCQkkY28tPnsnbG9nJ30gPSAkc2lnbiAuICcgJyAuICRjby0+eydsb2cnfTsKCQlteSBAdCA9IChzb3J0IGdyZXAgeyAhZXhpc3RzICRiYXNleyRffSB9CgkJCSBrZXlzICV7JGNvLT57J2JyYW5jaCd9fSk7CgkJbmV4dCBpZiAoQHQgPCAyKTsKCQlteSAkdCA9ICJAdCI7CgkJJHNoYXJlZHskdH0gPSAxOwoJfQoKCWZvciBteSAkY29tYm8gKGtleXMgJXNoYXJlZCkgewoJCW15IEBjb21ibyA9IHNwbGl0KCcgJywgJGNvbWJvKTsKCQlmb3IgKG15ICRpID0gMDsgJGkgPCBAY29tYm8gLSAxOyAkaSsrKSB7CgkJCWZvciAobXkgJGogPSAkaSArIDE7ICRqIDwgQGNvbWJvOyAkaisrKSB7CgkJCQl0b3BpY19yZWxhdGlvbihcJXRvcGljLCAkY29tYm9bJGldLCAkY29tYm9bJGpdKTsKCQkJfQoJCX0KCX0KCglvcGVuKCRmaCwgJy18JywKCSAgICAgcXcoZ2l0IGxvZyAtLWZpcnN0LXBhcmVudCAtLWFiYnJldiksCgkgICAgICItLWZvcm1hdD0lY2kgJWggJXAgOiVzIiwgIm1hc3Rlci4ubmV4dCIpCgkgICAgb3IgZGllICIkITogb3BlbiBsb2cgbWFzdGVyLi5uZXh0IjsKCXdoaWxlICg8JGZoPikgewoJCW15ICgkZGF0ZSwgJGNvbW1pdCwgJHBhcmVudCwgJHRpcHMpOwoJCXVubGVzcyAoKCRkYXRlLCAkY29tbWl0LCAkcGFyZW50LCAkdGlwcykgPQoJCQkvXihbLTAtOV0rKSAuLjouLjouLiAuXGR7NH0gKFxTKykgKFxTKykgKFteOl0qKTovKSB7CgkJCWRpZSAiT29wczogJF8iOwoJCX0KCQlmb3IgbXkgJHRpcCAoc3BsaXQoJyAnLCAkdGlwcykpIHsKCQkJbXkgJGNvID0gJGNvbW1pdHskdGlwfTsKCQkJbmV4dCB1bmxlc3MgKCRjby0+eydicmFuY2gnfXsnbmV4dCd9KTsKCQkJJGNvLT57J21lcmdlZCd9ID0gIiAobWVyZ2VkIHRvICduZXh0JyBvbiAkZGF0ZSBhdCAkY29tbWl0KSI7CgkJfQoJfQoJY2xvc2UoJGZoKSBvciBkaWUgIiQhOiBjbG9zZSBsb2cgbWFzdGVyLi5uZXh0IjsKCglmb3IgbXkgJGJyYW5jaCAoa2V5cyAldG9waWMpIHsKCQlteSBAbG9nID0gKCk7CgkJbXkgJG4gPSBzY2FsYXIoQHskdG9waWN7JGJyYW5jaH17J2xvZyd9fSk7CgkJaWYgKCEkbikgewoJCQlkZWxldGUgJHRvcGljeyRicmFuY2h9OwoJCQluZXh0OwoJCX0gZWxzaWYgKCRuID09IDEpIHsKCQkJJG4gPSAiMSBjb21taXQiOwoJCX0gZWxzZSB7CgkJCSRuID0gIiRuIGNvbW1pdHMiOwoJCX0KCQlteSAkZCA9ICR0b3BpY3skYnJhbmNofXsndGlwZGF0ZSd9OwoJCW15ICRoZWFkID0gIiogJGJyYW5jaCAoJGQpICRuXG4iOwoJCW15IEBkZXNjOwoJCWZvciAoQHskdG9waWN7JGJyYW5jaH17J2xvZyd9fSkgewoJCQlteSAkY28gPSAkY29tbWl0eyRffTsKCQkJaWYgKGV4aXN0cyAkY28tPnsnbWVyZ2VkJ30pIHsKCQkJCXB1c2ggQGRlc2MsICRjby0+eydtZXJnZWQnfTsKCQkJfQoJCQlwdXNoIEBkZXNjLCAkY29tbWl0eyRffS0+eydsb2cnfTsKCQl9CgoJCWlmICgxMDAgPCBAZGVzYykgewoJCQlAZGVzYyA9IEBkZXNjWzAuLjk5XTsKCQkJcHVzaCBAZGVzYywgIi0gLi4uIjsKCQl9CgoJCW15ICRsaXN0ID0gam9pbigiXG4iLCBtYXAgeyAiICIgLiAkXyB9IEBkZXNjKTsKCQlteSAkcmVsYXRpb24gPSBkZXNjcmliZV9yZWxhdGlvbigkdG9waWN7JGJyYW5jaH0pOwoJCSR0b3BpY3skYnJhbmNofXsnZGVzYyd9ID0gJGhlYWQgLiAkbGlzdDsKCQlpZiAoJHJlbGF0aW9uKSB7CgkJCSR0b3BpY3skYnJhbmNofXsnZGVzYyd9IC49ICJcbiAkcmVsYXRpb24iOwoJCX0KCX0KCglyZXR1cm4gXCV0b3BpYzsKfQoKc3ViIGJsdXJiX3RleHQgewoJbXkgKCRtb24sICR5ZWFyLCAkaXNzdWUsICRkb3csICRkYXRlLAoJICAgICRtYXN0ZXJfYXQsICRuZXh0X2F0LCAkdGV4dCkgPSBAXzsKCglteSAkbm93X3N0cmluZyA9IGxvY2FsdGltZTsKCW15ICgkY3VycmVudF9kb3csICRjdXJyZW50X21vbiwgJGN1cnJlbnRfZGF0ZSwgJGN1cnJlbnRfeWVhcikgPQoJICAgICgkbm93X3N0cmluZyA9fiAvXihcdyspIChcdyspIChcZCspIFtcZDpdKyAoXGQrKSQvKTsKCgkkbW9uIHx8PSAkY3VycmVudF9tb247CgkkeWVhciB8fD0gJGN1cnJlbnRfeWVhcjsKCSRpc3N1ZSB8fD0gIjAxIjsKCSRkb3cgfHw9ICRjdXJyZW50X2RvdzsKCSRkYXRlIHx8PSAkY3VycmVudF9kYXRlOwoJJG1hc3Rlcl9hdCB8fD0gJzAnIHggNDA7CgkkbmV4dF9hdCB8fD0gJzAnIHggNDA7CgkkdGV4dCB8fD0gPDwnRU9GJzsKSGVyZSBhcmUgdGhlIHRvcGljcyB0aGF0IGhhdmUgYmVlbiBjb29raW5nLiAgQ29tbWl0cyBwcmVmaXhlZCB3aXRoICctJyBhcmUKb25seSBpbiAncHUnIChwcm9wb3NlZCB1cGRhdGVzKSB3aGlsZSBjb21taXRzIHByZWZpeGVkIHdpdGggJysnIGFyZSBpbiAnbmV4dCcuClRoZSBvbmVzIG1hcmtlZCB3aXRoICcuJyBkbyBub3QgYXBwZWFyIGluIGFueSBvZiB0aGUgaW50ZWdyYXRpb24gYnJhbmNoZXMsCmJ1dCBJIGFtIHN0aWxsIGhvbGRpbmcgb250byB0aGVtLgoKWW91IGNhbiBmaW5kIHRoZSBjaGFuZ2VzIGRlc2NyaWJlZCBoZXJlIGluIHRoZSBpbnRlZ3JhdGlvbiBicmFuY2hlcyBvZiB0aGUKcmVwb3NpdG9yaWVzIGxpc3RlZCBhdAoKICAgIGh0dHA6Ly9naXQtYmxhbWUuYmxvZ3Nwb3QuY29tL3AvZ2l0LXB1YmxpYy1yZXBvc2l0b3JpZXMuaHRtbApFT0YKCgkkdGV4dCA9IDw8RU9GOwpUbzogZ2l0XEB2Z2VyLmtlcm5lbC5vcmcKQmNjOiBsd25cQGx3bi5uZXQKU3ViamVjdDogV2hhdCdzIGNvb2tpbmcgaW4gZ2l0LmdpdCAoJG1vbiAkeWVhciwgIyRpc3N1ZTsgJGRvdywgJGRhdGUpClgtbWFzdGVyLWF0OiAkbWFzdGVyX2F0ClgtbmV4dC1hdDogJG5leHRfYXQKCldoYXQncyBjb29raW5nIGluIGdpdC5naXQgKCRtb24gJHllYXIsICMkaXNzdWU7ICRkb3csICRkYXRlKQotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKJHRleHQKRU9GCgkkdGV4dCA9fiBzL1xuK1xaL1xuLzsKCXJldHVybiAkdGV4dDsKfQoKbXkgJGJsdXJiX21hdGNoID0gPDwnRU9GJzsKKD86KD9pOlxzKlthLXpdKzogLip8XHMuKilcbikqP1N1YmplY3Q6IFdoYXQncyBjb29raW5nIGluIFxTKyBcKChcdyspIChcZCspLCAjKFxkKyk7IChcdyspLCAoXGQrKVwpClgtbWFzdGVyLWF0OiAoWzAtOWEtZl17NDB9KQpYLW5leHQtYXQ6IChbMC05YS1mXXs0MH0pCgpXaGF0J3MgY29va2luZyBpbiBcUysgXChcMSBcMiwgI1wzOyBcNCwgXDVcKQotezMwLH0KXG4qCkVPRgoKbXkgJGJsdXJiID0gImIuLmwuLnUuLnIuLmIiOwpzdWIgcmVhZF9wcmV2aW91cyB7CglteSAoJGZuKSA9IEBfOwoJbXkgJGZoOwogCW15ICRzZWN0aW9uID0gdW5kZWY7CglteSAkc2VyaWFsID0gMTsKCW15ICRicmFuY2ggPSAkYmx1cmI7CglteSAkbGFzdF9lbXB0eSA9IHVuZGVmOwoJbXkgKEBzZWN0aW9uLCAlc2VjdGlvbiwgQGJyYW5jaCwgJWJyYW5jaCwgJWRlc2NyaXB0aW9uLCBAbGVhZGVyKTsKCW15ICRpbl91bmVkaXRlZF9vbGRlID0gMDsKCglpZiAoIS1yICRmbikgewoJCXJldHVybiArewoJCQknc2VjdGlvbl9saXN0JyA9PiBbXSwKCQkJJ3NlY3Rpb25fZGF0YScgPT4ge30sCgkJCSd0b3BpY19kZXNjcmlwdGlvbicgPT4gewoJCQkJJGJsdXJiID0+IHsKCQkJCQlkZXNjID0+IHVuZGVmLAoJCQkJCXRleHQgPT4gYmx1cmJfdGV4dCgpLAoJCQkJfSwKCQkJfSwKCQl9OwoJfQoKCW9wZW4gKCRmaCwgJzwnLCAkZm4pIG9yIGRpZSAiJCE6IG9wZW4gJGZuIjsKCXdoaWxlICg8JGZoPikgewoJCWNob21wOwoJCXMvXHMrJC8vOwoJCWlmICgkaW5fdW5lZGl0ZWRfb2xkZSkgewoJCQlpZiAoL14+PiQvKSB7CgkJCQkkaW5fdW5lZGl0ZWRfb2xkZSA9IDA7CgkJCQkkXyA9ICIgfCAkXyI7CgkJCX0KCQl9IGVsc2lmICgvXjw8JC8pIHsKCQkJJGluX3VuZWRpdGVkX29sZGUgPSAxOwoJCX0KCgkJaWYgKCRpbl91bmVkaXRlZF9vbGRlKSB7CgkJCSRfID0gIiB8ICRfIjsKCQl9CgoJCWlmIChkZWZpbmVkICRzZWN0aW9uICYmIC9eLXsyMCx9JC8pIHsKCQkJJF8gPSAiIjsKCQl9CgkJaWYgKC9eJC8pIHsKCQkJJGxhc3RfZW1wdHkgPSAxOwoJCQluZXh0OwoJCX0KCQlpZiAoL15cWyguKilcXVxzKiQvKSB7CgkJCSRzZWN0aW9uID0gJDE7CgkJCSRicmFuY2ggPSB1bmRlZjsKCQkJaWYgKCFleGlzdHMgJHNlY3Rpb257JHNlY3Rpb259KSB7CgkJCQlwdXNoIEBzZWN0aW9uLCAkc2VjdGlvbjsKCQkJCSRzZWN0aW9ueyRzZWN0aW9ufSA9IFtdOwoJCQl9CgkJCW5leHQ7CgkJfQoJCWlmIChkZWZpbmVkICRzZWN0aW9uICYmIC9eXCogKFxTKykgLykgewoJCQkkYnJhbmNoID0gJDE7CgkJCSRsYXN0X2VtcHR5ID0gMDsKCQkJaWYgKCFleGlzdHMgJGJyYW5jaHskYnJhbmNofSkgewoJCQkJcHVzaCBAYnJhbmNoLCBbJGJyYW5jaCwgJHNlY3Rpb25dOwoJCQkJJGJyYW5jaHskYnJhbmNofSA9IDE7CgkJCX0KCQkJcHVzaCBAeyRzZWN0aW9ueyRzZWN0aW9ufX0sICRicmFuY2g7CgkJfQoJCWlmIChkZWZpbmVkICRicmFuY2gpIHsKCQkJbXkgJHdhc19sYXN0X2VtcHR5ID0gJGxhc3RfZW1wdHk7CgkJCSRsYXN0X2VtcHR5ID0gMDsKCQkJaWYgKCFleGlzdHMgJGRlc2NyaXB0aW9ueyRicmFuY2h9KSB7CgkJCQkkZGVzY3JpcHRpb257JGJyYW5jaH0gPSBbXTsKCQkJfQoJCQlpZiAoJHdhc19sYXN0X2VtcHR5KSB7CgkJCQlwdXNoIEB7JGRlc2NyaXB0aW9ueyRicmFuY2h9fSwgIiI7CgkJCX0KCQkJcHVzaCBAeyRkZXNjcmlwdGlvbnskYnJhbmNofX0sICRfOwoJCX0KCX0KCWNsb3NlKCRmaCk7CgoJbXkgJGxlYWQgPSAiICI7Cglmb3IgbXkgJGJyYW5jaCAoa2V5cyAlZGVzY3JpcHRpb24pIHsKCQlteSAkYXJ5ID0gJGRlc2NyaXB0aW9ueyRicmFuY2h9OwoJCWlmICgkYnJhbmNoIGVxICRibHVyYikgewoJCQl3aGlsZSAoQHskYXJ5fSAmJiAkYXJ5LT5bLTFdID1+IC9eLXszMCx9JC8pIHsKCQkJCXBvcCBAeyRhcnl9OwoJCQl9CgkJCSRkZXNjcmlwdGlvbnskYnJhbmNofSA9ICt7CgkJCQlkZXNjID0+IHVuZGVmLAoJCQkJdGV4dCA9PiBqb2luKCJcbiIsIEB7JGFyeX0pLAoJCQl9OwoJCX0gZWxzZSB7CgkJCW15IEBkZXNjID0gKCk7CgkJCXdoaWxlIChAeyRhcnl9KSB7CgkJCQlteSAkZWxlbSA9IHNoaWZ0IEB7JGFyeX07CgkJCQlsYXN0IGlmICgkZWxlbSBlcSAnJyk7CgkJCQlwdXNoIEBkZXNjLCAkZWxlbTsKCQkJfQoJCQlteSBAdHh0ID0gbWFwIHsKCQkJCXMvXlxzKy8vOwoJCQkJJF8gPSAiJGxlYWQkXyI7CgkJCQlzL1xzKyQvLzsKCQkJCSRfOwoJCQl9IEB7JGFyeX07CgoJCQkkZGVzY3JpcHRpb257JGJyYW5jaH0gPSArewoJCQkJZGVzYyA9PiBqb2luKCJcbiIsIEBkZXNjKSwKCQkJCXRleHQgPT4gam9pbigiXG4iLCBAdHh0KSwKCQkJfTsKCQl9Cgl9CgoJcmV0dXJuICt7CgkJc2VjdGlvbl9saXN0ID0+IFxAc2VjdGlvbiwKCQlzZWN0aW9uX2RhdGEgPT4gXCVzZWN0aW9uLAoJCXRvcGljX2Rlc2NyaXB0aW9uID0+IFwlZGVzY3JpcHRpb24sCgl9Owp9CgpzdWIgd3JpdGVfY29va2luZyB7CglteSAoJGZuLCAkY29va2luZykgPSBAXzsKCW15ICRmaDsKCglvcGVuKCRmaCwgJz4nLCAkZm4pIG9yIGRpZSAiJCE6IG9wZW4gJGZuIjsKCXByaW50ICRmaCAkY29va2luZy0+eyd0b3BpY19kZXNjcmlwdGlvbid9eyRibHVyYn17J3RleHQnfTsKCglmb3IgbXkgJHNlY3Rpb25fbmFtZSAoQHskY29va2luZy0+eydzZWN0aW9uX2xpc3QnfX0pIHsKCQlteSAkdG9waWNfbGlzdCA9ICRjb29raW5nLT57J3NlY3Rpb25fZGF0YSd9eyRzZWN0aW9uX25hbWV9OwoJCW5leHQgaWYgKCFAeyR0b3BpY19saXN0fSk7CgoJCXByaW50ICRmaCAiXG4iOwoJCXByaW50ICRmaCAnLScgeCA1MCwgIlxuIjsKCQlwcmludCAkZmggIlskc2VjdGlvbl9uYW1lXVxuIjsKCQlteSAkbGVhZCA9ICJcbiI7CgkJZm9yIG15ICR0b3BpYyAoQHskdG9waWNfbGlzdH0pIHsKCQkJbXkgJGQgPSAkY29va2luZy0+eyd0b3BpY19kZXNjcmlwdGlvbid9eyR0b3BpY307CgoJCQlwcmludCAkZmggJGxlYWQsICRkLT57J2Rlc2MnfSwgIlxuIjsKCQkJaWYgKCRkLT57J3RleHQnfSkgewoJCQkJIyBGaW5hbCBjbGVhbi11cC4gIE5vIGxlYWRpbmcgb3IgdHJhaWxpbmcKCQkJCSMgYmxhbmsgbGluZXMsIG5vIG11bHRpLWxpbmUgZ2Fwcy4KCQkJCWZvciAoJGQtPnsndGV4dCd9KSB7CgkJCQkJcy9eXG4rLy9zOwoJCQkJCXMvXG57Myx9L1xuXG4vczsKCQkJCQlzL1xuKyQvL3M7CgkJCQl9CgkJCQlwcmludCAkZmggIlxuIiwgJGQtPnsndGV4dCd9LCAiXG4iOwoJCQl9CgkJCSRsZWFkID0gIlxuXG4iOwoJCX0KCX0KCWNsb3NlKCRmaCk7Cn0KCm15ICRncmFkdWF0ZWQgPSAnR3JhZHVhdGVkIHRvICJtYXN0ZXIiJzsKbXkgJG5ld190b3BpY3MgPSAnTmV3IFRvcGljcyc7Cm15ICRkaXNjYXJkZWQgPSAnRGlzY2FyZGVkJzsKbXkgJGNvb2tpbmdfdG9waWNzID0gJ0Nvb2tpbmcnOwoKc3ViIHVwZGF0ZV9pc3N1ZSB7CglteSAoJGNvb2tpbmcpID0gQF87CglteSAoJGZoLCAkbWFzdGVyX2F0LCAkbmV4dF9hdCwgJGluY3JlbWVudGFsKTsKCglvcGVuKCRmaCwgJy18JywKCSAgICAgcXcoZ2l0IGZvci1lYWNoLXJlZiksCgkgICAgICItLWZvcm1hdD0lKHJlZm5hbWU6c2hvcnQpICUob2JqZWN0bmFtZSkiLAoJICAgICAicmVmcy9oZWFkcy9tYXN0ZXIiLAoJICAgICAicmVmcy9oZWFkcy9uZXh0Iikgb3IgZGllICIkITogb3BlbiBmb3ItZWFjaC1yZWYiOwoJd2hpbGUgKDwkZmg+KSB7CgkJbXkgKCRicmFuY2gsICRhdCkgPSAvXihcUyspIChcUyspJC87CgkJaWYgKCRicmFuY2ggZXEgJ21hc3RlcicpIHsgJG1hc3Rlcl9hdCA9ICRhdDsgfQoJCWlmICgkYnJhbmNoIGVxICduZXh0JykgeyAkbmV4dF9hdCA9ICRhdDsgfQoJfQoJY2xvc2UoJGZoKSBvciBkaWUgIiQhOiBjbG9zZSBmb3ItZWFjaC1yZWYiOwoKCSRpbmNyZW1lbnRhbCA9ICgoLXIgIk1ldGEvd2hhdHMtY29va2luZy50eHQiKSAmJgoJCQlzeXN0ZW0oImNkIE1ldGEgJiYgIiAuCgkJCSAgICAgICAiZ2l0IGRpZmYgLS1xdWlldCAtLW5vLWV4dC1kaWZmIEhFQUQgLS0gIiAuCgkJCSAgICAgICAid2hhdHMtY29va2luZy50eHQiKSk7CgoJbXkgJG5vd19zdHJpbmcgPSBsb2NhbHRpbWU7CglteSAoJGN1cnJlbnRfZG93LCAkY3VycmVudF9tb24sICRjdXJyZW50X2RhdGUsICRjdXJyZW50X3llYXIpID0KCSAgICAoJG5vd19zdHJpbmcgPX4gL14oXHcrKSAoXHcrKSArKFxkKykgW1xkOl0rIChcZCspJC8pOwoKCW15ICRidGV4dCA9ICRjb29raW5nLT57J3RvcGljX2Rlc2NyaXB0aW9uJ317JGJsdXJifXsndGV4dCd9OwoJaWYgKCRidGV4dCAhfiBzL1xBJGJsdXJiX21hdGNoLy8pIHsKCQlkaWUgIm1hdGNoIHBhdHRlcm4gYnJva2VuPyI7Cgl9CglteSAoJG1vbiwgJHllYXIsICRpc3N1ZSwgJGRvdywgJGRhdGUpID0gKCQxLCAkMiwgJDMsICQ0LCAkNSk7CgoJaWYgKCRjdXJyZW50X21vbiBuZSAkbW9uIHx8ICRjdXJyZW50X3llYXIgbmUgJHllYXIpIHsKCQkkaXNzdWUgPSAiMDEiOwoJfSBlbHNpZiAoISRpbmNyZW1lbnRhbCkgewoJCSRpc3N1ZSA9fiBzL14wKi8vOwoJCSRpc3N1ZSA9IHNwcmludGYgIiUwMmQiLCAoJGlzc3VlICsgMSk7Cgl9CgkkbW9uID0gJGN1cnJlbnRfbW9uOwoJJHllYXIgPSAkY3VycmVudF95ZWFyOwoJJGRvdyA9ICRjdXJyZW50X2RvdzsKCSRkYXRlID0gJGN1cnJlbnRfZGF0ZTsKCgkkY29va2luZy0+eyd0b3BpY19kZXNjcmlwdGlvbid9eyRibHVyYn17J3RleHQnfSA9CgkgICAgYmx1cmJfdGV4dCgkbW9uLCAkeWVhciwgJGlzc3VlLCAkZG93LCAkZGF0ZSwKCQkgICAgICAgJG1hc3Rlcl9hdCwgJG5leHRfYXQsICRidGV4dCk7CgoJIyBJZiBzdGFydGluZyBhIG5ldyBpc3N1ZSwgbW92ZSB3aGF0IHVzZWQgdG8gYmUgaW4KCSMgbmV3IHRvcGljcyB0byBjb29raW5nIHRvcGljcy4KCWlmICghJGluY3JlbWVudGFsKSB7CgkJbXkgJHNkID0gJGNvb2tpbmctPnsnc2VjdGlvbl9kYXRhJ307CgkJbXkgJHNsID0gJGNvb2tpbmctPnsnc2VjdGlvbl9saXN0J307CgoJCWlmIChleGlzdHMgJHNkLT57JG5ld190b3BpY3N9KSB7CgkJCWlmICghZXhpc3RzICRzZC0+eyRjb29raW5nX3RvcGljc30pIHsKCQkJCSRzZC0+eyRjb29raW5nX3RvcGljc30gPSBbXTsKCQkJCXVuc2hpZnQgQHskc2x9LCAkY29va2luZ190b3BpY3M7CgkJCX0KCQkJdW5zaGlmdCBAeyRzZC0+eyRjb29raW5nX3RvcGljc319LCBAeyRzZC0+eyRuZXdfdG9waWNzfX07CgkJfQoJCSRzZC0+eyRuZXdfdG9waWNzfSA9IFtdOwoJfQoKCXJldHVybiAkaW5jcmVtZW50YWw7Cn0KCnN1YiB0b3BpY19pbl9wdSB7CglteSAoJHRvcGljX2Rlc2MpID0gQF87Cglmb3IgbXkgJGxpbmUgKHNwbGl0KC9cbi8sICR0b3BpY19kZXNjKSkgewoJCWlmICgkbGluZSA9fiAvXiBbKy1dIC8pIHsKCQkJcmV0dXJuIDE7CgkJfQoJfQoJcmV0dXJuIDA7Cn0KCnN1YiB0d2Vha193aWxsZG8gewoJbXkgKCR0ZCkgPSBAXzsKCW15ICRkZXNjID0gJHRkLT57J2Rlc2MnfTsKCW15ICR0ZXh0ID0gJHRkLT57J3RleHQnfTsKCgkjIElmIHVwZGF0ZWQgZGVzY3JpcHRpb24gKGkuZS4gdGhlIGxpc3Qgb2YgcGF0Y2hlcyB3aXRoCgkjIG1lcmdlIHRyYWlsIHRvICduZXh0JykgaGFzICdtZXJnZWQgdG8gbmV4dCcsIHRoZW4KCSMgdHdlYWsgdGhlIHRvcGljIHRvIGJlIHNsYXRlZCB0byAnbWFzdGVyJy4KCSMgTkVFRFNXT1JLOiBkb2VzIHRoaXMgd29yayBjb3JyZWN0bHkgZm9yIGEgaGFsZi1tZXJnZWQgdG9waWM/CgkkZGVzYyA9fiBzL1xuPDxcbi4qLy9zOwoJaWYgKCRkZXNjID1+IC9eICBcKG1lcmdlZCB0byAnbmV4dCcvbSkgewoJCSR0ZXh0ID1+IHMvXiBXaWxsIG1lcmdlIHRvICduZXh0J1wuJC8gV2lsbCBtZXJnZSB0byAnbWFzdGVyJy4vbTsKCX0KCSR0ZC0+eyd0ZXh0J30gPSAkdGV4dDsKfQoKc3ViIHR3ZWFrX2dyYWR1YXRlZCB7CglteSAoJHRkKSA9IEBfOwoKCSMgUmVtb3ZlIHRoZSAiV2lsbCBtZXJnZSIgbWFya2VyIGZyb20gdG9waWNzIHRoYXQgaGF2ZSBncmFkdWF0ZWQuCglmb3IgKCR0ZC0+eyd0ZXh0J30pIHsKCQlzL1xuIFdpbGwgbWVyZ2UgdG8gJ21hc3RlcidcLihcbnwkKS8vczsKCX0KfQoKc3ViIG1lcmdlX2Nvb2tpbmcgewoJbXkgKCRjb29raW5nLCAkY3VycmVudCkgPSBAXzsKCgkjIEEgaGFzaCB0byBmaW5kIDxkZXNjLCB0ZXh0PiB3aXRoIGEgYnJhbmNoIG5hbWUgb3IgJGJsdXJiCglteSAkdGQgPSAkY29va2luZy0+eyd0b3BpY19kZXNjcmlwdGlvbid9OwoKCSMgQSBoYXNoIHRvIGZpbmQgYSBsaXN0IG9mICR0ZCBlbGVtZW50IGdpdmVuIGEgc2VjdGlvbiBuYW1lCglteSAkc2QgPSAkY29va2luZy0+eydzZWN0aW9uX2RhdGEnfTsKCgkjIEEgbGlzdCBvZiBzZWN0aW9uIG5hbWVzCglteSAkc2wgPSAkY29va2luZy0+eydzZWN0aW9uX2xpc3QnfTsKCglteSAoQG5ld190b3BpYywgQGdvbmVfdG9waWMpOwoKCSMgTWFrZSBzdXJlICJOZXcgVG9waWNzIiBhbmQgIkdyYWR1YXRlZCIgZXhpc3RzCglpZiAoIWV4aXN0cyAkc2QtPnskbmV3X3RvcGljc30pIHsKCQkkc2QtPnskbmV3X3RvcGljc30gPSBbXTsKCQl1bnNoaWZ0IEB7JHNsfSwgJG5ld190b3BpY3M7Cgl9CgoJaWYgKCFleGlzdHMgJHNkLT57JGdyYWR1YXRlZH0pIHsKCQkkc2QtPnskZ3JhZHVhdGVkfSA9IFtdOwoJCXVuc2hpZnQgQHskc2x9LCAkZ3JhZHVhdGVkOwoJfQoKCW15ICRpbmNyZW1lbnRhbCA9IHVwZGF0ZV9pc3N1ZSgkY29va2luZyk7CgoJZm9yIG15ICR0b3BpYyAoc29ydCBrZXlzICV7JGN1cnJlbnR9KSB7CgkJaWYgKCFleGlzdHMgJHRkLT57JHRvcGljfSkgewoJCQkjIElnbm9yZSBuZXcgdG9waWNzIHdpdGhvdXQgYW55dGhpbmcgbWVyZ2VkCgkJCWlmICh0b3BpY19pbl9wdSgkY3VycmVudC0+eyR0b3BpY317J2Rlc2MnfSkpIHsKCQkJCXB1c2ggQG5ld190b3BpYywgJHRvcGljOwoJCQl9CgkJCW5leHQ7CgkJfQoJCSMgQW5ub3RhdGUgaWYgdGhlIGNvbnRlbnRzIG9mIHRoZSB0b3BpYyBjaGFuZ2VkCgkJbXkgJG4gPSAkY3VycmVudC0+eyR0b3BpY317J2Rlc2MnfTsKCQlteSAkbyA9ICR0ZC0+eyR0b3BpY317J2Rlc2MnfTsKCQlpZiAoJG4gbmUgJG8pIHsKCQkJJHRkLT57JHRvcGljfXsnZGVzYyd9ID0gJG4gLiAiXG48PFxuIiAuICRvIC4iXG4+PiI7CgkJCXR3ZWFrX3dpbGxkbygkdGQtPnskdG9waWN9KTsKCQl9Cgl9CgoJZm9yIG15ICR0b3BpYyAoc29ydCBrZXlzICV7JHRkfSkgewoJCW5leHQgaWYgKCR0b3BpYyBlcSAkYmx1cmIpOwoJCW5leHQgaWYgKCEkaW5jcmVtZW50YWwgJiYKCQkJIGdyZXAgeyAkdG9waWMgZXEgJF8gfSBAeyRzZC0+eyRncmFkdWF0ZWR9fSk7CgkJbmV4dCBpZiAoZ3JlcCB7ICR0b3BpYyBlcSAkXyB9IEB7JHNkLT57JGRpc2NhcmRlZH19KTsKCQlpZiAoIWV4aXN0cyAkY3VycmVudC0+eyR0b3BpY30pIHsKCQkJcHVzaCBAZ29uZV90b3BpYywgJHRvcGljOwoJCX0KCX0KCglmb3IgKEBuZXdfdG9waWMpIHsKCQlwdXNoIEB7JHNkLT57JG5ld190b3BpY3N9fSwgJF87CgkJJHRkLT57JF99eydkZXNjJ30gPSAkY3VycmVudC0+eyRffXsnZGVzYyd9OwoJfQoKCWlmICghJGluY3JlbWVudGFsKSB7CgkJJHNkLT57JGdyYWR1YXRlZH0gPSBbXTsKCX0KCglpZiAoQGdvbmVfdG9waWMpIHsKCQlmb3IgbXkgJHRvcGljIChAZ29uZV90b3BpYykgewoJCQlmb3IgbXkgJHNlY3Rpb24gKEB7JHNsfSkgewoJCQkJbXkgJHByZSA9IHNjYWxhcihAeyRzZC0+eyRzZWN0aW9ufX0pOwoJCQkJQHskc2QtPnskc2VjdGlvbn19ID0gKGdyZXAgeyAkXyBuZSAkdG9waWMgfQoJCQkJCQkgICAgICBAeyRzZC0+eyRzZWN0aW9ufX0pOwoJCQkJbXkgJHBvc3QgPSBzY2FsYXIoQHskc2QtPnskc2VjdGlvbn19KTsKCQkJCW5leHQgaWYgKCRwcmUgPT0gJHBvc3QpOwoJCQl9CgkJfQoJCWZvciAoQGdvbmVfdG9waWMpIHsKCQkJcHVzaCBAeyRzZC0+eyRncmFkdWF0ZWR9fSwgJF87CgkJCXR3ZWFrX2dyYWR1YXRlZCgkdGQtPnskX30pOwoJCX0KCX0KfQoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIFdpbERvCnN1YiB3aWxkb19xdWV1ZSB7CglteSAoJHdoYXQsICRhY3Rpb24sICR0b3BpYykgPSBAXzsKCWlmICghZXhpc3RzICR3aGF0LT57JGFjdGlvbn0pIHsKCQkkd2hhdC0+eyRhY3Rpb259ID0gW107Cgl9CglwdXNoIEB7JHdoYXQtPnskYWN0aW9ufX0sICR0b3BpYzsKfQoKc3ViIHNlY3Rpb25fYWN0aW9uIHsKCW15ICgkc2VjdGlvbikgPSBAXzsKCWlmICgkc2VjdGlvbikgewoJCWZvciAoJHNlY3Rpb24pIHsKCQkJcmV0dXJuIGlmICgvXkdyYWR1YXRlZCB0by8gfHwgL15EaXNjYXJkZWQkLyk7CgkJCXJldHVybiAkXyBpZiAoL15TdGFsbGVkJC8pOwoJCX0KCX0KCXJldHVybiAiVW5kZWNpZGVkIjsKfQoKc3ViIHdpbGRvX2ZsdXNoX3RvcGljIHsKCW15ICgkaW5fc2VjdGlvbiwgJHdoYXQsICR0b3BpYykgPSBAXzsKCWlmIChkZWZpbmVkICR0b3BpYykgewoJCW15ICRhY3Rpb24gPSBzZWN0aW9uX2FjdGlvbigkaW5fc2VjdGlvbik7CgkJaWYgKCRhY3Rpb24pIHsKCQkJd2lsZG9fcXVldWUoJHdoYXQsICRhY3Rpb24sICR0b3BpYyk7CgkJfQoJfQp9CgpzdWIgd2lsZG9fbWF0Y2ggewoJaWYgKC9eV2lsbCAoPzpcUysgKXswLDJ9KGZhc3QtdHJhY2t8aG9sZHxrZWVwfG1lcmdlfGRyb3B8ZGlzY2FyZHxjb29rfGtpY2t8ZGVmZXJ8ZWplY3R8YmUgcmUtP3JvbGxlZClbLC4gXS8gfHwKCSAgICAvXk5vdCB1cmdlbnQvIHx8IC9eTm90IHJlYWR5LyB8fCAvXldhaXRpbmcgZm9yIC8gfHwKCSAgICAvXkNhbiB3YWl0IGluIC8gfHwgL15TdGlsbCAvIHx8CgkgICAgL15OZWVkcz8gLyB8fCAvXkV4cGVjdGluZyAvIHx8IC9eTWF5IHdhbnQgdG8gLykgewoJCXJldHVybiAxOwoJfQoJaWYgKC9eSSB0aGluayB0aGlzIGlzIHJlYWR5IGZvciAvKSB7CgkJcmV0dXJuIDE7Cgl9CglyZXR1cm4gMDsKfQoKc3ViIHdpbGRvIHsKCW15ICRmZCA9IHNoaWZ0OwoJbXkgKCV3aGF0LCAkdG9waWMsICRsYXN0X21lcmdlX3RvX25leHQsICRpbl9zZWN0aW9uLCAkaW5fZGVzYyk7CglteSAkdG9vX3JlY2VudCA9ICc5OTk5LTk5LTk5JzsKCXdoaWxlICg8JGZkPikgewoJCWNob21wOwoKCQlpZiAoL15cWyguKilcXSQvKSB7CgkJCW15ICRvbGRfc2VjdGlvbiA9ICRpbl9zZWN0aW9uOwoJCQkkaW5fc2VjdGlvbiA9ICQxOwoJCQl3aWxkb19mbHVzaF90b3BpYygkb2xkX3NlY3Rpb24sIFwld2hhdCwgJHRvcGljKTsKCQkJJHRvcGljID0gJGluX2Rlc2MgPSB1bmRlZjsKCQkJbmV4dDsKCQl9CgoJCWlmICgvXlwqIChcUyspIFwoKFstMC05XSspXCkgKFxkKykgY29tbWl0cz8kLykgewoJCQl3aWxkb19mbHVzaF90b3BpYygkaW5fc2VjdGlvbiwgXCV3aGF0LCAkdG9waWMpOwoKCQkJIyB0aXAtZGF0ZSwgbmV4dC1kYXRlLCB0b3BpYywgY291bnQsIHB1LWNvdW50CgkJCSR0b3BpYyA9IFskMiwgJHRvb19yZWNlbnQsICQxLCAkMywgMF07CgkJCSRpbl9kZXNjID0gdW5kZWY7CgkJCW5leHQ7CgkJfQoKCQlpZiAoZGVmaW5lZCAkdG9waWMgJiYKCQkgICAgKCR0b3BpYy0+WzFdIGVxICR0b29fcmVjZW50KSAmJgoJCSAgICAoJHRvcGljLT5bNF0gPT0gMCkgJiYKCQkgICAgKC9eICBcKG1lcmdlZCB0byAnbmV4dCcgb24gKFstMC05XSspLykpIHsKCQkJJHRvcGljLT5bMV0gPSAkMTsKCQl9CgkJaWYgKGRlZmluZWQgJHRvcGljICYmIC9eIC0gLykgewoJCQkkdG9waWMtPls0XSsrOwoJCX0KCgkJaWYgKGRlZmluZWQgJHRvcGljICYmIC9eJC8pIHsKCQkJJGluX2Rlc2MgPSAxOwoJCQluZXh0OwoJCX0KCgkJbmV4dCB1bmxlc3MgZGVmaW5lZCAkdG9waWMgJiYgJGluX2Rlc2M7CgoJCXMvXlxzKy8vOwoJCWlmICh3aWxkb19tYXRjaCgkXykpIHsKCQkJd2lsZG9fcXVldWUoXCV3aGF0LCAkXywgJHRvcGljKTsKCQkJJHRvcGljID0gJGluX2Rlc2MgPSB1bmRlZjsKCQl9CgoJCWlmICgvT3JpZ2luYWxseSBtZXJnZWQgdG8gJ25leHQnIG9uIChbLTAtOV0rKS8pIHsKCQkJJHRvcGljLT5bMV0gPSAkMTsKCQl9Cgl9Cgl3aWxkb19mbHVzaF90b3BpYygkaW5fc2VjdGlvbiwgXCV3aGF0LCAkdG9waWMpOwoKCW15ICRpcGJsID0gIiI7Cglmb3IgbXkgJHdoYXQgKHNvcnQga2V5cyAld2hhdCkgewoJCXByaW50ICIkaXBibCR3aGF0XG4iOwoJCWZvciAkdG9waWMgKHNvcnQgeyAoKCRhLT5bMV0gY21wICRiLT5bMV0pIHx8CgkJCQkgICAgKCRhLT5bMF0gY21wICRiLT5bMF0pKSB9CgkJCSAgICBAeyR3aGF0eyR3aGF0fX0pIHsKCQkJbXkgKCR0aXAsICRuZXh0LCAkbmFtZSwgJGNvdW50LCAkcHUpID0gQCR0b3BpYzsKCQkJbXkgKCRzaWduKTsKCQkJJHRpcCA9fiBzL15cZHs0fS0vLzsKCQkJaWYgKCgkbmV4dCBlcSAkdG9vX3JlY2VudCkgfHwgKDAgPCAkcHUpKSB7CgkJCQkkc2lnbiA9ICItIjsKCQkJCSRuZXh0ID0gIiAiIHggNjsKCQkJfSBlbHNlIHsKCQkJCSRzaWduID0gIisiOwoJCQkJJG5leHQgPX4gc3xeXGR7NH0tfC98OwoJCQl9CgkJCSRjb3VudCA9ICIjJGNvdW50IjsKCQkJcHJpbnRmICIgJXMgJS02MHMgJXMlcyAlNXNcbiIsICRzaWduLCAkbmFtZSwgJHRpcCwgJG5leHQsICRjb3VudDsKCQl9CgkJJGlwYmwgPSAiXG4iOwoJfQp9CgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMgSGF2RG9uZQpzdWIgaGF2ZWRvbmVfc2hvdyB7CglteSAkdG9waWMgPSBzaGlmdDsKCW15ICRzdHIgPSBzaGlmdDsKCW15ICRwcmVmaXggPSAiICogIjsKCSRzdHIgPX4gcy9cQVxuKy8vOwoJJHN0ciA9fiBzL1xuK1xaLy87CgoJcHJpbnQgIigkdG9waWMpXG4iOwoJZm9yICRzdHIgKHNwbGl0KC9cbi8sICRzdHIpKSB7CgkJcHJpbnQgIiRwcmVmaXgkc3RyXG4iOwoJCSRwcmVmaXggPSAiICAgIjsKCX0KfQoKc3ViIGhhdmVkb25lX2NvdW50IHsKCW15IEByYW5nZSA9IEBfOwoJbXkgJGNudCA9IGBnaXQgcmV2LWxpc3QgLS1jb3VudCBAcmFuZ2VgOwoJY2hvbXAgJGNudDsKCXJldHVybiAkY250Owp9CgpzdWIgaGF2ZWRvbmUgewoJbXkgJGZoOwoJbXkgJXRvcGljID0gKCk7CglteSBAdG9waWMgPSAoKTsKCW15ICgkdG9waWMsICR0b19tYWludCwgJXRvX21haW50LCAlbWVyZ2VkLCAkaW5fZGVzYyk7CglpZiAoIUBBUkdWKSB7CgkJb3BlbigkZmgsICctfCcsCgkJICAgICBxdyhnaXQgcmV2LWxpc3QgLS1maXJzdC1wYXJlbnQgLTEgbWFzdGVyIERvY3VtZW50YXRpb24vUmVsTm90ZXMgUmVsTm90ZXMpKQoJCSAgICBvciBkaWUgIiQhOiBvcGVuIHJldi1saXN0IjsKCQlteSAoJHJldikgPSA8JGZoPjsKCQljbG9zZSgkZmgpIG9yIGRpZSAiJCE6IGNsb3NlIHJldi1saXN0IjsKCQljaG9tcCAkcmV2OwoJCUBBUkdWID0gKCIkcmV2Li5tYXN0ZXIiKTsKCX0KCW9wZW4oJGZoLCAnLXwnLAoJICAgICBxdyhnaXQgbG9nIC0tZmlyc3QtcGFyZW50IC0tb25lbGluZSAtLXJldmVyc2UpLCBAQVJHVikKCSAgICBvciBkaWUgIiQhOiBvcGVuIGxvZyAtLWZpcnN0LXBhcmVudCI7Cgl3aGlsZSAoPCRmaD4pIHsKCQlteSAoJHNoYTEsICRicmFuY2gpID0gL14oWzAtOWEtZl0rKSBNZXJnZSBicmFuY2ggJyguKiknJC87CgkJbmV4dCB1bmxlc3MgJGJyYW5jaDsKCQkkdG9waWN7JGJyYW5jaH0gPSAiIjsKCQkkbWVyZ2VkeyRicmFuY2h9ID0gJHNoYTE7CgkJcHVzaCBAdG9waWMsICRicmFuY2g7Cgl9CgljbG9zZSgkZmgpIG9yIGRpZSAiJCE6IGNsb3NlIGxvZyAtLWZpcnN0LXBhcmVudCI7CglvcGVuKCRmaCwgIjwiLCAiTWV0YS93aGF0cy1jb29raW5nLnR4dCIpCgkgICAgb3IgZGllICIkITogb3BlbiB3aGF0cy1jb29raW5nIjsKCXdoaWxlICg8JGZoPikgewoJCWNob21wOwoJCWlmICgvXlxbKC4qKVxdJC8pIHsKCQkJIyBzZWN0aW9uIGhlYWRlcgoJCQkkaW5fZGVzYyA9ICR0b3BpYyA9IHVuZGVmOwoJCQluZXh0OwoJCX0KCQlpZiAoL15cKiAoXFMrKSBcKFstMC05XStcKSBcZCsgY29tbWl0cz8kLykgewoJCQlpZiAoZXhpc3RzICR0b3BpY3skMX0pIHsKCQkJCSR0b3BpYyA9ICQxOwoJCQkJJHRvX21haW50ID0gMDsKCQkJfSBlbHNlIHsKCQkJCSRpbl9kZXNjID0gJHRvcGljID0gdW5kZWY7CgkJCX0KCQkJbmV4dDsKCQl9CgkJaWYgKGRlZmluZWQgJHRvcGljICYmIC9eJC8pIHsKCQkJJGluX2Rlc2MgPSAxOwoJCQluZXh0OwoJCX0KCgkJbmV4dCB1bmxlc3MgZGVmaW5lZCAkdG9waWMgJiYgJGluX2Rlc2M7CgoJCXMvXlxzKy8vOwoJCWlmICh3aWxkb19tYXRjaCgkXykpIHsKCQkJbmV4dDsKCQl9CgkJJHRvcGljeyR0b3BpY30gLj0gIiRfXG4iOwoJfQoJY2xvc2UoJGZoKSBvciBkaWUgIiQhOiBjbG9zZSB3aGF0cy1jb29raW5nIjsKCglmb3IgJHRvcGljIChAdG9waWMpIHsKCQlteSAkbWVyZ2VkID0gJG1lcmdlZHskdG9waWN9OwoJCW15ICRpbl9tYXN0ZXIgPSBoYXZlZG9uZV9jb3VudCgiJG1lcmdlZF4xLi4kbWVyZ2VkXjIiKTsKCQlteSAkbm90X2luX21haW50ID0gaGF2ZWRvbmVfY291bnQoIm1haW50Li4kbWVyZ2VkXjIiKTsKCQlpZiAoJGluX21hc3RlciA9PSAkbm90X2luX21haW50KSB7CgkJCSR0b19tYWludHskdG9waWN9ID0gMTsKCQl9Cgl9CgoJbXkgJHNob3duID0gMDsKCWZvciAkdG9waWMgKEB0b3BpYykgewoJCW5leHQgaWYgKGV4aXN0cyAkdG9fbWFpbnR7JHRvcGljfSk7CgkJaGF2ZWRvbmVfc2hvdygkdG9waWMsICR0b3BpY3skdG9waWN9KTsKCQlwcmludCAiXG4iOwoJCSRzaG93bisrOwoJfQoKCWlmICgkc2hvd24pIHsKCQlwcmludCAiLSIgeCA2NCwgIlxuIjsKCX0KCglmb3IgJHRvcGljIChAdG9waWMpIHsKCQluZXh0IHVubGVzcyAoZXhpc3RzICR0b19tYWludHskdG9waWN9KTsKCQloYXZlZG9uZV9zaG93KCR0b3BpYywgJHRvcGljeyR0b3BpY30pOwoJCW15ICRzaGExID0gYGdpdCByZXYtcGFyc2UgLS1zaG9ydCAkdG9waWNgOwoJCWNob21wICRzaGExOwoJCXByaW50ICIgICAobWVyZ2UgJHNoYTEgJHRvcGljIGxhdGVyIHRvIG1haW50KS5cbiI7CgkJcHJpbnQgIlxuIjsKCX0KfQoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIFdoYXRzQ29va2luZwoKc3ViIGRvaXQgewoJbXkgJHRvcGljID0gZ2V0X2NvbW1pdCgpOwoJbXkgJGNvb2tpbmcgPSByZWFkX3ByZXZpb3VzKCdNZXRhL3doYXRzLWNvb2tpbmcudHh0Jyk7CgltZXJnZV9jb29raW5nKCRjb29raW5nLCAkdG9waWMpOwoJd3JpdGVfY29va2luZygnTWV0YS93aGF0cy1jb29raW5nLnR4dCcsICRjb29raW5nKTsKfQoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIE1haW4KCnVzZSBHZXRvcHQ6Okxvbmc7CgpteSAoJHdpbGRvLCAkaGF2ZWRvbmUpOwppZiAoIUdldE9wdGlvbnMoIndpbGRvIiA9PiBcJHdpbGRvLAoJCSJoYXZlZG9uZSIgPT4gXCRoYXZlZG9uZSkpIHsKCXByaW50IFNUREVSUiAiJDAgWy0td2lsZG98LS1oYXZlZG9uZV1cbiI7CglleGl0IDE7Cn0KCmlmICgkd2lsZG8pIHsKCW15ICRmZDsKCWlmICghQEFSR1YpIHsKCQlvcGVuKCRmZCwgIjwiLCAiTWV0YS93aGF0cy1jb29raW5nLnR4dCIpOwoJfSBlbHNpZiAoQEFSR1YgIT0gMSkgewoJCXByaW50IFNUREVSUiAiJDAgLS13aWxkbyBbZmlsZW5hbWV8SEVBRHwtXVxuIjsKCQlleGl0IDE7Cgl9IGVsc2lmICgkQVJHVlswXSBlcSAnLScpIHsKCQkkZmQgPSBcKlNURElOOwoJfSBlbHNpZiAoJEFSR1ZbMF0gPX4gL15IRUFELykgewoJCW9wZW4oJGZkLCAiLXwiLAoJCSAgICAgcXcoZ2l0IC0tZ2l0LWRpcj1NZXRhLy5naXQgY2F0LWZpbGUgLXApLAoJCSAgICAgIiRBUkdWWzBdOndoYXRzLWNvb2tpbmcudHh0Iik7Cgl9IGVsc2UgewoJCW9wZW4oJGZkLCAiPCIsICRBUkdWWzBdKTsKCX0KCXdpbGRvKCRmZCk7Cn0gZWxzaWYgKCRoYXZlZG9uZSkgewoJaGF2ZWRvbmUoKTsKfSBlbHNlIHsKCWRvaXQoKTsKfQo=",
    "text": "#!/usr/bin/perl -w\n# Maintain \"what's cooking\" messages\n\nuse strict;\n\nmy %reverts = ('next' => {\n\tmap { $_ => 1 } qw(\n\t    ) });\n\n%reverts = ();\n\nsub phrase_these {\n\tmy %uniq = ();\n\tmy (@u) = grep { $uniq{$_}++ == 0 } sort @_;\n\tmy @d = ();\n\tfor (my $i = 0; $i < @u; $i++) {\n\t\tpush @d, $u[$i];\n\t\tif ($i == @u - 2) {\n\t\t\tpush @d, \" and \";\n\t\t} elsif ($i < @u - 2) {\n\t\t\tpush @d, \", \";\n\t\t}\n\t}\n\treturn join('', @d);\n}\n\nsub describe_relation {\n\tmy ($topic_info) = @_;\n\tmy @desc;\n\n\tif (exists $topic_info->{'used'}) {\n\t\tpush @desc, (\"is used by \" .\n\t\t\t     phrase_these(@{$topic_info->{'used'}}));\n\t}\n\n\tif (exists $topic_info->{'uses'}) {\n\t\tpush @desc, (\"uses \" .\n\t\t\t     phrase_these(@{$topic_info->{'uses'}}));\n\t}\n\n\tif (exists $topic_info->{'shares'}) {\n\t\tpush @desc, (\"is tangled with \" .\n\t\t\t     phrase_these(@{$topic_info->{'shares'}}));\n\t}\n\n\tif (!@desc) {\n\t\treturn \"\";\n\t}\n\n\treturn \"(this branch \" . join(\"; \", @desc) . \".)\";\n}\n\nsub forks_from {\n\tmy ($topic, $fork, $forkee, @overlap) = @_;\n\tmy %ovl = map { $_ => 1 } (@overlap, @{$topic->{$forkee}{'log'}});\n\n\tpush @{$topic->{$fork}{'uses'}}, $forkee;\n\tpush @{$topic->{$forkee}{'used'}}, $fork;\n\t@{$topic->{$fork}{'log'}} = (grep { !exists $ovl{$_} }\n\t\t\t\t     @{$topic->{$fork}{'log'}});\n}\n\nsub topic_relation {\n\tmy ($topic, $one, $two) = @_;\n\n\tmy $fh;\n\topen($fh, '-|',\n\t     qw(git log --abbrev), \"--format=%m %h\",\n\t     \"$one...$two\", \"^master\")\n\t    or die \"$!: open log --left-right\";\n\tmy (@left, @right);\n\twhile (<$fh>) {\n\t\tmy ($sign, $sha1) = /^(.) (.*)/;\n\t\tif ($sign eq '<') {\n\t\t\tpush @left, $sha1;\n\t\t} elsif ($sign eq '>') {\n\t\t\tpush @right, $sha1;\n\t\t}\n\t}\n\tclose($fh) or die \"$!: close log --left-right\";\n\n\tif (!@left) {\n\t\tif (@right) {\n\t\t\tforks_from($topic, $two, $one);\n\t\t}\n\t} elsif (!@right) {\n\t\tforks_from($topic, $one, $two);\n\t} else {\n\t\tpush @{$topic->{$one}{'shares'}}, $two;\n\t\tpush @{$topic->{$two}{'shares'}}, $one;\n\t}\n}\n\n=head1\nInspect the current set of topics\n\nReturns a hash:\n\n    $topic = {\n        $branchname => {\n            'tipdate' => date of the tip commit,\n\t    'desc' => description string,\n\t    'log' => [ $commit,... ],\n        },\n    }\n\n=cut\n\nsub get_commit {\n\tmy (@base) = qw(master next pu);\n\tmy $fh;\n\topen($fh, '-|',\n\t     qw(git for-each-ref),\n\t     \"--format=%(refname:short) %(committerdate:iso8601)\",\n\t     \"refs/heads/??/*\")\n\t    or die \"$!: open for-each-ref\";\n\tmy @topic;\n\tmy %topic;\n\n\twhile (<$fh>) {\n\t\tchomp;\n\t\tmy ($branch, $date) = /^(\\S+) (.*)$/;\n\t\tpush @topic, $branch;\n\t\t$date =~ s/ .*//;\n\t\t$topic{$branch} = +{\n\t\t\tlog => [],\n\t\t\ttipdate => $date,\n\t\t};\n\t}\n\tclose($fh) or die \"$!: close for-each-ref\";\n\n\tmy %base = map { $_ => undef } @base;\n\tmy %commit;\n\tmy $show_branch_batch = 20;\n\n\twhile (@topic) {\n\t\tmy @t = (@base, splice(@topic, 0, $show_branch_batch));\n\t\tmy $header_delim = '-' x scalar(@t);\n\t\tmy $contain_pat = '.' x scalar(@t);\n\t\topen($fh, '-|', qw(git show-branch --sparse --sha1-name),\n\t\t     map { \"refs/heads/$_\" } @t)\n\t\t    or die \"$!: open show-branch\";\n\t\twhile (<$fh>) {\n\t\t\tchomp;\n\t\t\tif ($header_delim) {\n\t\t\t\tif (/^$header_delim$/) {\n\t\t\t\t\t$header_delim = undef;\n\t\t\t\t}\n\t\t\t\tnext;\n\t\t\t}\n\t\t\tmy ($contain, $sha1, $log) =\n\t\t\t    ($_ =~ /^($contain_pat) \\[([0-9a-f]+)\\] (.*)$/);\n\n\t\t\tfor (my $i = 0; $i < @t; $i++) {\n\t\t\t\tmy $branch = $t[$i];\n\t\t\t\tmy $sign = substr($contain, $i, 1);\n\t\t\t\tnext if ($sign eq ' ');\n\t\t\t\tnext if (substr($contain, 0, 1) ne ' ');\n\n\t\t\t\tif (!exists $commit{$sha1}) {\n\t\t\t\t\t$commit{$sha1} = +{\n\t\t\t\t\t\tbranch => {},\n\t\t\t\t\t\tlog => $log,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tmy $co = $commit{$sha1};\n\t\t\t\tif (!exists $reverts{$branch}{$sha1}) {\n\t\t\t\t\t$co->{'branch'}{$branch} = 1;\n\t\t\t\t}\n\t\t\t\tnext if (exists $base{$branch});\n\t\t\t\tpush @{$topic{$branch}{'log'}}, $sha1;\n\t\t\t}\n\t\t}\n\t\tclose($fh) or die \"$!: close show-branch\";\n\t}\n\n\tmy %shared;\n\tfor my $sha1 (keys %commit) {\n\t\tmy $sign;\n\t\tmy $co = $commit{$sha1};\n\t\tif (exists $co->{'branch'}{'next'}) {\n\t\t\t$sign = '+';\n\t\t} elsif (exists $co->{'branch'}{'pu'}) {\n\t\t\t$sign = '-';\n\t\t} else {\n\t\t\t$sign = '.';\n\t\t}\n\t\t$co->{'log'} = $sign . ' ' . $co->{'log'};\n\t\tmy @t = (sort grep { !exists $base{$_} }\n\t\t\t keys %{$co->{'branch'}});\n\t\tnext if (@t < 2);\n\t\tmy $t = \"@t\";\n\t\t$shared{$t} = 1;\n\t}\n\n\tfor my $combo (keys %shared) {\n\t\tmy @combo = split(' ', $combo);\n\t\tfor (my $i = 0; $i < @combo - 1; $i++) {\n\t\t\tfor (my $j = $i + 1; $j < @combo; $j++) {\n\t\t\t\ttopic_relation(\\%topic, $combo[$i], $combo[$j]);\n\t\t\t}\n\t\t}\n\t}\n\n\topen($fh, '-|',\n\t     qw(git log --first-parent --abbrev),\n\t     \"--format=%ci %h %p :%s\", \"master..next\")\n\t    or die \"$!: open log master..next\";\n\twhile (<$fh>) {\n\t\tmy ($date, $commit, $parent, $tips);\n\t\tunless (($date, $commit, $parent, $tips) =\n\t\t\t/^([-0-9]+) ..:..:.. .\\d{4} (\\S+) (\\S+) ([^:]*):/) {\n\t\t\tdie \"Oops: $_\";\n\t\t}\n\t\tfor my $tip (split(' ', $tips)) {\n\t\t\tmy $co = $commit{$tip};\n\t\t\tnext unless ($co->{'branch'}{'next'});\n\t\t\t$co->{'merged'} = \" (merged to 'next' on $date at $commit)\";\n\t\t}\n\t}\n\tclose($fh) or die \"$!: close log master..next\";\n\n\tfor my $branch (keys %topic) {\n\t\tmy @log = ();\n\t\tmy $n = scalar(@{$topic{$branch}{'log'}});\n\t\tif (!$n) {\n\t\t\tdelete $topic{$branch};\n\t\t\tnext;\n\t\t} elsif ($n == 1) {\n\t\t\t$n = \"1 commit\";\n\t\t} else {\n\t\t\t$n = \"$n commits\";\n\t\t}\n\t\tmy $d = $topic{$branch}{'tipdate'};\n\t\tmy $head = \"* $branch ($d) $n\\n\";\n\t\tmy @desc;\n\t\tfor (@{$topic{$branch}{'log'}}) {\n\t\t\tmy $co = $commit{$_};\n\t\t\tif (exists $co->{'merged'}) {\n\t\t\t\tpush @desc, $co->{'merged'};\n\t\t\t}\n\t\t\tpush @desc, $commit{$_}->{'log'};\n\t\t}\n\n\t\tif (100 < @desc) {\n\t\t\t@desc = @desc[0..99];\n\t\t\tpush @desc, \"- ...\";\n\t\t}\n\n\t\tmy $list = join(\"\\n\", map { \" \" . $_ } @desc);\n\t\tmy $relation = describe_relation($topic{$branch});\n\t\t$topic{$branch}{'desc'} = $head . $list;\n\t\tif ($relation) {\n\t\t\t$topic{$branch}{'desc'} .= \"\\n $relation\";\n\t\t}\n\t}\n\n\treturn \\%topic;\n}\n\nsub blurb_text {\n\tmy ($mon, $year, $issue, $dow, $date,\n\t    $master_at, $next_at, $text) = @_;\n\n\tmy $now_string = localtime;\n\tmy ($current_dow, $current_mon, $current_date, $current_year) =\n\t    ($now_string =~ /^(\\w+) (\\w+) (\\d+) [\\d:]+ (\\d+)$/);\n\n\t$mon ||= $current_mon;\n\t$year ||= $current_year;\n\t$issue ||= \"01\";\n\t$dow ||= $current_dow;\n\t$date ||= $current_date;\n\t$master_at ||= '0' x 40;\n\t$next_at ||= '0' x 40;\n\t$text ||= <<'EOF';\nHere are the topics that have been cooking.  Commits prefixed with '-' are\nonly in 'pu' (proposed updates) while commits prefixed with '+' are in 'next'.\nThe ones marked with '.' do not appear in any of the integration branches,\nbut I am still holding onto them.\n\nYou can find the changes described here in the integration branches of the\nrepositories listed at\n\n    http://git-blame.blogspot.com/p/git-public-repositories.html\nEOF\n\n\t$text = <<EOF;\nTo: git\\@vger.kernel.org\nBcc: lwn\\@lwn.net\nSubject: What's cooking in git.git ($mon $year, #$issue; $dow, $date)\nX-master-at: $master_at\nX-next-at: $next_at\n\nWhat's cooking in git.git ($mon $year, #$issue; $dow, $date)\n--------------------------------------------------\n\n$text\nEOF\n\t$text =~ s/\\n+\\Z/\\n/;\n\treturn $text;\n}\n\nmy $blurb_match = <<'EOF';\n(?:(?i:\\s*[a-z]+: .*|\\s.*)\\n)*?Subject: What's cooking in \\S+ \\((\\w+) (\\d+), #(\\d+); (\\w+), (\\d+)\\)\nX-master-at: ([0-9a-f]{40})\nX-next-at: ([0-9a-f]{40})\n\nWhat's cooking in \\S+ \\(\\1 \\2, #\\3; \\4, \\5\\)\n-{30,}\n\\n*\nEOF\n\nmy $blurb = \"b..l..u..r..b\";\nsub read_previous {\n\tmy ($fn) = @_;\n\tmy $fh;\n \tmy $section = undef;\n\tmy $serial = 1;\n\tmy $branch = $blurb;\n\tmy $last_empty = undef;\n\tmy (@section, %section, @branch, %branch, %description, @leader);\n\tmy $in_unedited_olde = 0;\n\n\tif (!-r $fn) {\n\t\treturn +{\n\t\t\t'section_list' => [],\n\t\t\t'section_data' => {},\n\t\t\t'topic_description' => {\n\t\t\t\t$blurb => {\n\t\t\t\t\tdesc => undef,\n\t\t\t\t\ttext => blurb_text(),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t}\n\n\topen ($fh, '<', $fn) or die \"$!: open $fn\";\n\twhile (<$fh>) {\n\t\tchomp;\n\t\ts/\\s+$//;\n\t\tif ($in_unedited_olde) {\n\t\t\tif (/^>>$/) {\n\t\t\t\t$in_unedited_olde = 0;\n\t\t\t\t$_ = \" | $_\";\n\t\t\t}\n\t\t} elsif (/^<<$/) {\n\t\t\t$in_unedited_olde = 1;\n\t\t}\n\n\t\tif ($in_unedited_olde) {\n\t\t\t$_ = \" | $_\";\n\t\t}\n\n\t\tif (defined $section && /^-{20,}$/) {\n\t\t\t$_ = \"\";\n\t\t}\n\t\tif (/^$/) {\n\t\t\t$last_empty = 1;\n\t\t\tnext;\n\t\t}\n\t\tif (/^\\[(.*)\\]\\s*$/) {\n\t\t\t$section = $1;\n\t\t\t$branch = undef;\n\t\t\tif (!exists $section{$section}) {\n\t\t\t\tpush @section, $section;\n\t\t\t\t$section{$section} = [];\n\t\t\t}\n\t\t\tnext;\n\t\t}\n\t\tif (defined $section && /^\\* (\\S+) /) {\n\t\t\t$branch = $1;\n\t\t\t$last_empty = 0;\n\t\t\tif (!exists $branch{$branch}) {\n\t\t\t\tpush @branch, [$branch, $section];\n\t\t\t\t$branch{$branch} = 1;\n\t\t\t}\n\t\t\tpush @{$section{$section}}, $branch;\n\t\t}\n\t\tif (defined $branch) {\n\t\t\tmy $was_last_empty = $last_empty;\n\t\t\t$last_empty = 0;\n\t\t\tif (!exists $description{$branch}) {\n\t\t\t\t$description{$branch} = [];\n\t\t\t}\n\t\t\tif ($was_last_empty) {\n\t\t\t\tpush @{$description{$branch}}, \"\";\n\t\t\t}\n\t\t\tpush @{$description{$branch}}, $_;\n\t\t}\n\t}\n\tclose($fh);\n\n\tmy $lead = \" \";\n\tfor my $branch (keys %description) {\n\t\tmy $ary = $description{$branch};\n\t\tif ($branch eq $blurb) {\n\t\t\twhile (@{$ary} && $ary->[-1] =~ /^-{30,}$/) {\n\t\t\t\tpop @{$ary};\n\t\t\t}\n\t\t\t$description{$branch} = +{\n\t\t\t\tdesc => undef,\n\t\t\t\ttext => join(\"\\n\", @{$ary}),\n\t\t\t};\n\t\t} else {\n\t\t\tmy @desc = ();\n\t\t\twhile (@{$ary}) {\n\t\t\t\tmy $elem = shift @{$ary};\n\t\t\t\tlast if ($elem eq '');\n\t\t\t\tpush @desc, $elem;\n\t\t\t}\n\t\t\tmy @txt = map {\n\t\t\t\ts/^\\s+//;\n\t\t\t\t$_ = \"$lead$_\";\n\t\t\t\ts/\\s+$//;\n\t\t\t\t$_;\n\t\t\t} @{$ary};\n\n\t\t\t$description{$branch} = +{\n\t\t\t\tdesc => join(\"\\n\", @desc),\n\t\t\t\ttext => join(\"\\n\", @txt),\n\t\t\t};\n\t\t}\n\t}\n\n\treturn +{\n\t\tsection_list => \\@section,\n\t\tsection_data => \\%section,\n\t\ttopic_description => \\%description,\n\t};\n}\n\nsub write_cooking {\n\tmy ($fn, $cooking) = @_;\n\tmy $fh;\n\n\topen($fh, '>', $fn) or die \"$!: open $fn\";\n\tprint $fh $cooking->{'topic_description'}{$blurb}{'text'};\n\n\tfor my $section_name (@{$cooking->{'section_list'}}) {\n\t\tmy $topic_list = $cooking->{'section_data'}{$section_name};\n\t\tnext if (!@{$topic_list});\n\n\t\tprint $fh \"\\n\";\n\t\tprint $fh '-' x 50, \"\\n\";\n\t\tprint $fh \"[$section_name]\\n\";\n\t\tmy $lead = \"\\n\";\n\t\tfor my $topic (@{$topic_list}) {\n\t\t\tmy $d = $cooking->{'topic_description'}{$topic};\n\n\t\t\tprint $fh $lead, $d->{'desc'}, \"\\n\";\n\t\t\tif ($d->{'text'}) {\n\t\t\t\t# Final clean-up.  No leading or trailing\n\t\t\t\t# blank lines, no multi-line gaps.\n\t\t\t\tfor ($d->{'text'}) {\n\t\t\t\t\ts/^\\n+//s;\n\t\t\t\t\ts/\\n{3,}/\\n\\n/s;\n\t\t\t\t\ts/\\n+$//s;\n\t\t\t\t}\n\t\t\t\tprint $fh \"\\n\", $d->{'text'}, \"\\n\";\n\t\t\t}\n\t\t\t$lead = \"\\n\\n\";\n\t\t}\n\t}\n\tclose($fh);\n}\n\nmy $graduated = 'Graduated to \"master\"';\nmy $new_topics = 'New Topics';\nmy $discarded = 'Discarded';\nmy $cooking_topics = 'Cooking';\n\nsub update_issue {\n\tmy ($cooking) = @_;\n\tmy ($fh, $master_at, $next_at, $incremental);\n\n\topen($fh, '-|',\n\t     qw(git for-each-ref),\n\t     \"--format=%(refname:short) %(objectname)\",\n\t     \"refs/heads/master\",\n\t     \"refs/heads/next\") or die \"$!: open for-each-ref\";\n\twhile (<$fh>) {\n\t\tmy ($branch, $at) = /^(\\S+) (\\S+)$/;\n\t\tif ($branch eq 'master') { $master_at = $at; }\n\t\tif ($branch eq 'next') { $next_at = $at; }\n\t}\n\tclose($fh) or die \"$!: close for-each-ref\";\n\n\t$incremental = ((-r \"Meta/whats-cooking.txt\") &&\n\t\t\tsystem(\"cd Meta && \" .\n\t\t\t       \"git diff --quiet --no-ext-diff HEAD -- \" .\n\t\t\t       \"whats-cooking.txt\"));\n\n\tmy $now_string = localtime;\n\tmy ($current_dow, $current_mon, $current_date, $current_year) =\n\t    ($now_string =~ /^(\\w+) (\\w+) +(\\d+) [\\d:]+ (\\d+)$/);\n\n\tmy $btext = $cooking->{'topic_description'}{$blurb}{'text'};\n\tif ($btext !~ s/\\A$blurb_match//) {\n\t\tdie \"match pattern broken?\";\n\t}\n\tmy ($mon, $year, $issue, $dow, $date) = ($1, $2, $3, $4, $5);\n\n\tif ($current_mon ne $mon || $current_year ne $year) {\n\t\t$issue = \"01\";\n\t} elsif (!$incremental) {\n\t\t$issue =~ s/^0*//;\n\t\t$issue = sprintf \"%02d\", ($issue + 1);\n\t}\n\t$mon = $current_mon;\n\t$year = $current_year;\n\t$dow = $current_dow;\n\t$date = $current_date;\n\n\t$cooking->{'topic_description'}{$blurb}{'text'} =\n\t    blurb_text($mon, $year, $issue, $dow, $date,\n\t\t       $master_at, $next_at, $btext);\n\n\t# If starting a new issue, move what used to be in\n\t# new topics to cooking topics.\n\tif (!$incremental) {\n\t\tmy $sd = $cooking->{'section_data'};\n\t\tmy $sl = $cooking->{'section_list'};\n\n\t\tif (exists $sd->{$new_topics}) {\n\t\t\tif (!exists $sd->{$cooking_topics}) {\n\t\t\t\t$sd->{$cooking_topics} = [];\n\t\t\t\tunshift @{$sl}, $cooking_topics;\n\t\t\t}\n\t\t\tunshift @{$sd->{$cooking_topics}}, @{$sd->{$new_topics}};\n\t\t}\n\t\t$sd->{$new_topics} = [];\n\t}\n\n\treturn $incremental;\n}\n\nsub topic_in_pu {\n\tmy ($topic_desc) = @_;\n\tfor my $line (split(/\\n/, $topic_desc)) {\n\t\tif ($line =~ /^ [+-] /) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nsub tweak_willdo {\n\tmy ($td) = @_;\n\tmy $desc = $td->{'desc'};\n\tmy $text = $td->{'text'};\n\n\t# If updated description (i.e. the list of patches with\n\t# merge trail to 'next') has 'merged to next', then\n\t# tweak the topic to be slated to 'master'.\n\t# NEEDSWORK: does this work correctly for a half-merged topic?\n\t$desc =~ s/\\n<<\\n.*//s;\n\tif ($desc =~ /^  \\(merged to 'next'/m) {\n\t\t$text =~ s/^ Will merge to 'next'\\.$/ Will merge to 'master'./m;\n\t}\n\t$td->{'text'} = $text;\n}\n\nsub tweak_graduated {\n\tmy ($td) = @_;\n\n\t# Remove the \"Will merge\" marker from topics that have graduated.\n\tfor ($td->{'text'}) {\n\t\ts/\\n Will merge to 'master'\\.(\\n|$)//s;\n\t}\n}\n\nsub merge_cooking {\n\tmy ($cooking, $current) = @_;\n\n\t# A hash to find <desc, text> with a branch name or $blurb\n\tmy $td = $cooking->{'topic_description'};\n\n\t# A hash to find a list of $td element given a section name\n\tmy $sd = $cooking->{'section_data'};\n\n\t# A list of section names\n\tmy $sl = $cooking->{'section_list'};\n\n\tmy (@new_topic, @gone_topic);\n\n\t# Make sure \"New Topics\" and \"Graduated\" exists\n\tif (!exists $sd->{$new_topics}) {\n\t\t$sd->{$new_topics} = [];\n\t\tunshift @{$sl}, $new_topics;\n\t}\n\n\tif (!exists $sd->{$graduated}) {\n\t\t$sd->{$graduated} = [];\n\t\tunshift @{$sl}, $graduated;\n\t}\n\n\tmy $incremental = update_issue($cooking);\n\n\tfor my $topic (sort keys %{$current}) {\n\t\tif (!exists $td->{$topic}) {\n\t\t\t# Ignore new topics without anything merged\n\t\t\tif (topic_in_pu($current->{$topic}{'desc'})) {\n\t\t\t\tpush @new_topic, $topic;\n\t\t\t}\n\t\t\tnext;\n\t\t}\n\t\t# Annotate if the contents of the topic changed\n\t\tmy $n = $current->{$topic}{'desc'};\n\t\tmy $o = $td->{$topic}{'desc'};\n\t\tif ($n ne $o) {\n\t\t\t$td->{$topic}{'desc'} = $n . \"\\n<<\\n\" . $o .\"\\n>>\";\n\t\t\ttweak_willdo($td->{$topic});\n\t\t}\n\t}\n\n\tfor my $topic (sort keys %{$td}) {\n\t\tnext if ($topic eq $blurb);\n\t\tnext if (!$incremental &&\n\t\t\t grep { $topic eq $_ } @{$sd->{$graduated}});\n\t\tnext if (grep { $topic eq $_ } @{$sd->{$discarded}});\n\t\tif (!exists $current->{$topic}) {\n\t\t\tpush @gone_topic, $topic;\n\t\t}\n\t}\n\n\tfor (@new_topic) {\n\t\tpush @{$sd->{$new_topics}}, $_;\n\t\t$td->{$_}{'desc'} = $current->{$_}{'desc'};\n\t}\n\n\tif (!$incremental) {\n\t\t$sd->{$graduated} = [];\n\t}\n\n\tif (@gone_topic) {\n\t\tfor my $topic (@gone_topic) {\n\t\t\tfor my $section (@{$sl}) {\n\t\t\t\tmy $pre = scalar(@{$sd->{$section}});\n\t\t\t\t@{$sd->{$section}} = (grep { $_ ne $topic }\n\t\t\t\t\t\t      @{$sd->{$section}});\n\t\t\t\tmy $post = scalar(@{$sd->{$section}});\n\t\t\t\tnext if ($pre == $post);\n\t\t\t}\n\t\t}\n\t\tfor (@gone_topic) {\n\t\t\tpush @{$sd->{$graduated}}, $_;\n\t\t\ttweak_graduated($td->{$_});\n\t\t}\n\t}\n}\n\n################################################################\n# WilDo\nsub wildo_queue {\n\tmy ($what, $action, $topic) = @_;\n\tif (!exists $what->{$action}) {\n\t\t$what->{$action} = [];\n\t}\n\tpush @{$what->{$action}}, $topic;\n}\n\nsub section_action {\n\tmy ($section) = @_;\n\tif ($section) {\n\t\tfor ($section) {\n\t\t\treturn if (/^Graduated to/ || /^Discarded$/);\n\t\t\treturn $_ if (/^Stalled$/);\n\t\t}\n\t}\n\treturn \"Undecided\";\n}\n\nsub wildo_flush_topic {\n\tmy ($in_section, $what, $topic) = @_;\n\tif (defined $topic) {\n\t\tmy $action = section_action($in_section);\n\t\tif ($action) {\n\t\t\twildo_queue($what, $action, $topic);\n\t\t}\n\t}\n}\n\nsub wildo_match {\n\tif (/^Will (?:\\S+ ){0,2}(fast-track|hold|keep|merge|drop|discard|cook|kick|defer|eject|be re-?rolled)[,. ]/ ||\n\t    /^Not urgent/ || /^Not ready/ || /^Waiting for / ||\n\t    /^Can wait in / || /^Still / ||\n\t    /^Needs? / || /^Expecting / || /^May want to /) {\n\t\treturn 1;\n\t}\n\tif (/^I think this is ready for /) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nsub wildo {\n\tmy $fd = shift;\n\tmy (%what, $topic, $last_merge_to_next, $in_section, $in_desc);\n\tmy $too_recent = '9999-99-99';\n\twhile (<$fd>) {\n\t\tchomp;\n\n\t\tif (/^\\[(.*)\\]$/) {\n\t\t\tmy $old_section = $in_section;\n\t\t\t$in_section = $1;\n\t\t\twildo_flush_topic($old_section, \\%what, $topic);\n\t\t\t$topic = $in_desc = undef;\n\t\t\tnext;\n\t\t}\n\n\t\tif (/^\\* (\\S+) \\(([-0-9]+)\\) (\\d+) commits?$/) {\n\t\t\twildo_flush_topic($in_section, \\%what, $topic);\n\n\t\t\t# tip-date, next-date, topic, count, pu-count\n\t\t\t$topic = [$2, $too_recent, $1, $3, 0];\n\t\t\t$in_desc = undef;\n\t\t\tnext;\n\t\t}\n\n\t\tif (defined $topic &&\n\t\t    ($topic->[1] eq $too_recent) &&\n\t\t    ($topic->[4] == 0) &&\n\t\t    (/^  \\(merged to 'next' on ([-0-9]+)/)) {\n\t\t\t$topic->[1] = $1;\n\t\t}\n\t\tif (defined $topic && /^ - /) {\n\t\t\t$topic->[4]++;\n\t\t}\n\n\t\tif (defined $topic && /^$/) {\n\t\t\t$in_desc = 1;\n\t\t\tnext;\n\t\t}\n\n\t\tnext unless defined $topic && $in_desc;\n\n\t\ts/^\\s+//;\n\t\tif (wildo_match($_)) {\n\t\t\twildo_queue(\\%what, $_, $topic);\n\t\t\t$topic = $in_desc = undef;\n\t\t}\n\n\t\tif (/Originally merged to 'next' on ([-0-9]+)/) {\n\t\t\t$topic->[1] = $1;\n\t\t}\n\t}\n\twildo_flush_topic($in_section, \\%what, $topic);\n\n\tmy $ipbl = \"\";\n\tfor my $what (sort keys %what) {\n\t\tprint \"$ipbl$what\\n\";\n\t\tfor $topic (sort { (($a->[1] cmp $b->[1]) ||\n\t\t\t\t    ($a->[0] cmp $b->[0])) }\n\t\t\t    @{$what{$what}}) {\n\t\t\tmy ($tip, $next, $name, $count, $pu) = @$topic;\n\t\t\tmy ($sign);\n\t\t\t$tip =~ s/^\\d{4}-//;\n\t\t\tif (($next eq $too_recent) || (0 < $pu)) {\n\t\t\t\t$sign = \"-\";\n\t\t\t\t$next = \" \" x 6;\n\t\t\t} else {\n\t\t\t\t$sign = \"+\";\n\t\t\t\t$next =~ s|^\\d{4}-|/|;\n\t\t\t}\n\t\t\t$count = \"#$count\";\n\t\t\tprintf \" %s %-60s %s%s %5s\\n\", $sign, $name, $tip, $next, $count;\n\t\t}\n\t\t$ipbl = \"\\n\";\n\t}\n}\n\n################################################################\n# HavDone\nsub havedone_show {\n\tmy $topic = shift;\n\tmy $str = shift;\n\tmy $prefix = \" * \";\n\t$str =~ s/\\A\\n+//;\n\t$str =~ s/\\n+\\Z//;\n\n\tprint \"($topic)\\n\";\n\tfor $str (split(/\\n/, $str)) {\n\t\tprint \"$prefix$str\\n\";\n\t\t$prefix = \"   \";\n\t}\n}\n\nsub havedone_count {\n\tmy @range = @_;\n\tmy $cnt = `git rev-list --count @range`;\n\tchomp $cnt;\n\treturn $cnt;\n}\n\nsub havedone {\n\tmy $fh;\n\tmy %topic = ();\n\tmy @topic = ();\n\tmy ($topic, $to_maint, %to_maint, %merged, $in_desc);\n\tif (!@ARGV) {\n\t\topen($fh, '-|',\n\t\t     qw(git rev-list --first-parent -1 master Documentation/RelNotes RelNotes))\n\t\t    or die \"$!: open rev-list\";\n\t\tmy ($rev) = <$fh>;\n\t\tclose($fh) or die \"$!: close rev-list\";\n\t\tchomp $rev;\n\t\t@ARGV = (\"$rev..master\");\n\t}\n\topen($fh, '-|',\n\t     qw(git log --first-parent --oneline --reverse), @ARGV)\n\t    or die \"$!: open log --first-parent\";\n\twhile (<$fh>) {\n\t\tmy ($sha1, $branch) = /^([0-9a-f]+) Merge branch '(.*)'$/;\n\t\tnext unless $branch;\n\t\t$topic{$branch} = \"\";\n\t\t$merged{$branch} = $sha1;\n\t\tpush @topic, $branch;\n\t}\n\tclose($fh) or die \"$!: close log --first-parent\";\n\topen($fh, \"<\", \"Meta/whats-cooking.txt\")\n\t    or die \"$!: open whats-cooking\";\n\twhile (<$fh>) {\n\t\tchomp;\n\t\tif (/^\\[(.*)\\]$/) {\n\t\t\t# section header\n\t\t\t$in_desc = $topic = undef;\n\t\t\tnext;\n\t\t}\n\t\tif (/^\\* (\\S+) \\([-0-9]+\\) \\d+ commits?$/) {\n\t\t\tif (exists $topic{$1}) {\n\t\t\t\t$topic = $1;\n\t\t\t\t$to_maint = 0;\n\t\t\t} else {\n\t\t\t\t$in_desc = $topic = undef;\n\t\t\t}\n\t\t\tnext;\n\t\t}\n\t\tif (defined $topic && /^$/) {\n\t\t\t$in_desc = 1;\n\t\t\tnext;\n\t\t}\n\n\t\tnext unless defined $topic && $in_desc;\n\n\t\ts/^\\s+//;\n\t\tif (wildo_match($_)) {\n\t\t\tnext;\n\t\t}\n\t\t$topic{$topic} .= \"$_\\n\";\n\t}\n\tclose($fh) or die \"$!: close whats-cooking\";\n\n\tfor $topic (@topic) {\n\t\tmy $merged = $merged{$topic};\n\t\tmy $in_master = havedone_count(\"$merged^1..$merged^2\");\n\t\tmy $not_in_maint = havedone_count(\"maint..$merged^2\");\n\t\tif ($in_master == $not_in_maint) {\n\t\t\t$to_maint{$topic} = 1;\n\t\t}\n\t}\n\n\tmy $shown = 0;\n\tfor $topic (@topic) {\n\t\tnext if (exists $to_maint{$topic});\n\t\thavedone_show($topic, $topic{$topic});\n\t\tprint \"\\n\";\n\t\t$shown++;\n\t}\n\n\tif ($shown) {\n\t\tprint \"-\" x 64, \"\\n\";\n\t}\n\n\tfor $topic (@topic) {\n\t\tnext unless (exists $to_maint{$topic});\n\t\thavedone_show($topic, $topic{$topic});\n\t\tmy $sha1 = `git rev-parse --short $topic`;\n\t\tchomp $sha1;\n\t\tprint \"   (merge $sha1 $topic later to maint).\\n\";\n\t\tprint \"\\n\";\n\t}\n}\n\n################################################################\n# WhatsCooking\n\nsub doit {\n\tmy $topic = get_commit();\n\tmy $cooking = read_previous('Meta/whats-cooking.txt');\n\tmerge_cooking($cooking, $topic);\n\twrite_cooking('Meta/whats-cooking.txt', $cooking);\n}\n\n################################################################\n# Main\n\nuse Getopt::Long;\n\nmy ($wildo, $havedone);\nif (!GetOptions(\"wildo\" => \\$wildo,\n\t\t\"havedone\" => \\$havedone)) {\n\tprint STDERR \"$0 [--wildo|--havedone]\\n\";\n\texit 1;\n}\n\nif ($wildo) {\n\tmy $fd;\n\tif (!@ARGV) {\n\t\topen($fd, \"<\", \"Meta/whats-cooking.txt\");\n\t} elsif (@ARGV != 1) {\n\t\tprint STDERR \"$0 --wildo [filename|HEAD|-]\\n\";\n\t\texit 1;\n\t} elsif ($ARGV[0] eq '-') {\n\t\t$fd = \\*STDIN;\n\t} elsif ($ARGV[0] =~ /^HEAD/) {\n\t\topen($fd, \"-|\",\n\t\t     qw(git --git-dir=Meta/.git cat-file -p),\n\t\t     \"$ARGV[0]:whats-cooking.txt\");\n\t} else {\n\t\topen($fd, \"<\", $ARGV[0]);\n\t}\n\twildo($fd);\n} elsif ($havedone) {\n\thavedone();\n} else {\n\tdoit();\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0035d6565878335407d317f2e2f575b7217d10d6",
  "sha1_ok": true,
  "size": 20852
}
