{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IG1lcmdlIgogKgogKiBDb3B5cmlnaHQgKGMpIDIwMDggTWlrbG9zIFZham5hIDx2bWlrbG9zQGZydWdhbHdhcmUub3JnPgogKgogKiBCYXNlZCBvbiBnaXQtbWVyZ2Uuc2ggYnkgSnVuaW8gQyBIYW1hbm8uCiAqLwoKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJsb2NrZmlsZS5oIgojaW5jbHVkZSAicnVuLWNvbW1hbmQuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAiZGlmZmNvcmUuaCIKI2luY2x1ZGUgInJldmlzaW9uLmgiCiNpbmNsdWRlICJ1bnBhY2stdHJlZXMuaCIKI2luY2x1ZGUgImNhY2hlLXRyZWUuaCIKI2luY2x1ZGUgImRpci5oIgojaW5jbHVkZSAidXRmOC5oIgojaW5jbHVkZSAibG9nLXRyZWUuaCIKI2luY2x1ZGUgImNvbG9yLmgiCiNpbmNsdWRlICJyZXJlcmUuaCIKI2luY2x1ZGUgImhlbHAuaCIKI2luY2x1ZGUgIm1lcmdlLXJlY3Vyc2l2ZS5oIgojaW5jbHVkZSAicmVzb2x2ZS11bmRvLmgiCiNpbmNsdWRlICJyZW1vdGUuaCIKI2luY2x1ZGUgImZtdC1tZXJnZS1tc2cuaCIKI2luY2x1ZGUgImdwZy1pbnRlcmZhY2UuaCIKI2luY2x1ZGUgInNlcXVlbmNlci5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKCiNkZWZpbmUgREVGQVVMVF9UV09IRUFEICgxPDwwKQojZGVmaW5lIERFRkFVTFRfT0NUT1BVUyAoMTw8MSkKI2RlZmluZSBOT19GQVNUX0ZPUldBUkQgKDE8PDIpCiNkZWZpbmUgTk9fVFJJVklBTCAgICAgICgxPDwzKQoKc3RydWN0IHN0cmF0ZWd5IHsKCWNvbnN0IGNoYXIgKm5hbWU7Cgl1bnNpZ25lZCBhdHRyOwp9OwoKc3RhdGljIGNvbnN0IGNoYXIgKiBjb25zdCBidWlsdGluX21lcmdlX3VzYWdlW10gPSB7CglOXygiZ2l0IG1lcmdlIFs8b3B0aW9ucz5dIFs8Y29tbWl0Pi4uLl0iKSwKCU5fKCJnaXQgbWVyZ2UgWzxvcHRpb25zPl0gPG1zZz4gSEVBRCA8Y29tbWl0PiIpLAoJTl8oImdpdCBtZXJnZSAtLWFib3J0IiksCglOVUxMCn07CgpzdGF0aWMgaW50IHNob3dfZGlmZnN0YXQgPSAxLCBzaG9ydGxvZ19sZW4gPSAtMSwgc3F1YXNoOwpzdGF0aWMgaW50IG9wdGlvbl9jb21taXQgPSAxOwpzdGF0aWMgaW50IG9wdGlvbl9lZGl0ID0gLTE7CnN0YXRpYyBpbnQgYWxsb3dfdHJpdmlhbCA9IDEsIGhhdmVfbWVzc2FnZSwgdmVyaWZ5X3NpZ25hdHVyZXM7CnN0YXRpYyBpbnQgb3ZlcndyaXRlX2lnbm9yZSA9IDE7CnN0YXRpYyBzdHJ1Y3Qgc3RyYnVmIG1lcmdlX21zZyA9IFNUUkJVRl9JTklUOwpzdGF0aWMgc3RydWN0IHN0cmF0ZWd5ICoqdXNlX3N0cmF0ZWdpZXM7CnN0YXRpYyBzaXplX3QgdXNlX3N0cmF0ZWdpZXNfbnIsIHVzZV9zdHJhdGVnaWVzX2FsbG9jOwpzdGF0aWMgY29uc3QgY2hhciAqKnhvcHRzOwpzdGF0aWMgc2l6ZV90IHhvcHRzX25yLCB4b3B0c19hbGxvYzsKc3RhdGljIGNvbnN0IGNoYXIgKmJyYW5jaDsKc3RhdGljIGNoYXIgKmJyYW5jaF9tZXJnZW9wdGlvbnM7CnN0YXRpYyBpbnQgb3B0aW9uX3Jlbm9ybWFsaXplOwpzdGF0aWMgaW50IHZlcmJvc2l0eTsKc3RhdGljIGludCBhbGxvd19yZXJlcmVfYXV0bzsKc3RhdGljIGludCBhYm9ydF9jdXJyZW50X21lcmdlOwpzdGF0aWMgaW50IGFsbG93X3VucmVsYXRlZF9oaXN0b3JpZXM7CnN0YXRpYyBpbnQgc2hvd19wcm9ncmVzcyA9IC0xOwpzdGF0aWMgaW50IGRlZmF1bHRfdG9fdXBzdHJlYW0gPSAxOwpzdGF0aWMgY29uc3QgY2hhciAqc2lnbl9jb21taXQ7CgpzdGF0aWMgc3RydWN0IHN0cmF0ZWd5IGFsbF9zdHJhdGVneVtdID0gewoJeyAicmVjdXJzaXZlIiwgIERFRkFVTFRfVFdPSEVBRCB8IE5PX1RSSVZJQUwgfSwKCXsgIm9jdG9wdXMiLCAgICBERUZBVUxUX09DVE9QVVMgfSwKCXsgInJlc29sdmUiLCAgICAwIH0sCgl7ICJvdXJzIiwgICAgICAgTk9fRkFTVF9GT1JXQVJEIHwgTk9fVFJJVklBTCB9LAoJeyAic3VidHJlZSIsICAgIE5PX0ZBU1RfRk9SV0FSRCB8IE5PX1RSSVZJQUwgfSwKfTsKCnN0YXRpYyBjb25zdCBjaGFyICpwdWxsX3R3b2hlYWQsICpwdWxsX29jdG9wdXM7CgplbnVtIGZmX3R5cGUgewoJRkZfTk8sCglGRl9BTExPVywKCUZGX09OTFkKfTsKCnN0YXRpYyBlbnVtIGZmX3R5cGUgZmFzdF9mb3J3YXJkID0gRkZfQUxMT1c7CgpzdGF0aWMgaW50IG9wdGlvbl9wYXJzZV9tZXNzYWdlKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwKCQkJCWNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglzdHJ1Y3Qgc3RyYnVmICpidWYgPSBvcHQtPnZhbHVlOwoKCWlmICh1bnNldCkKCQlzdHJidWZfc2V0bGVuKGJ1ZiwgMCk7CgllbHNlIGlmIChhcmcpIHsKCQlzdHJidWZfYWRkZihidWYsICIlcyVzIiwgYnVmLT5sZW4gPyAiXG5cbiIgOiAiIiwgYXJnKTsKCQloYXZlX21lc3NhZ2UgPSAxOwoJfSBlbHNlCgkJcmV0dXJuIGVycm9yKF8oInN3aXRjaCBgbScgcmVxdWlyZXMgYSB2YWx1ZSIpKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgc3RydWN0IHN0cmF0ZWd5ICpnZXRfc3RyYXRlZ3koY29uc3QgY2hhciAqbmFtZSkKewoJaW50IGk7CglzdHJ1Y3Qgc3RyYXRlZ3kgKnJldDsKCXN0YXRpYyBzdHJ1Y3QgY21kbmFtZXMgbWFpbl9jbWRzLCBvdGhlcl9jbWRzOwoJc3RhdGljIGludCBsb2FkZWQ7CgoJaWYgKCFuYW1lKQoJCXJldHVybiBOVUxMOwoKCWZvciAoaSA9IDA7IGkgPCBBUlJBWV9TSVpFKGFsbF9zdHJhdGVneSk7IGkrKykKCQlpZiAoIXN0cmNtcChuYW1lLCBhbGxfc3RyYXRlZ3lbaV0ubmFtZSkpCgkJCXJldHVybiAmYWxsX3N0cmF0ZWd5W2ldOwoKCWlmICghbG9hZGVkKSB7CgkJc3RydWN0IGNtZG5hbWVzIG5vdF9zdHJhdGVnaWVzOwoJCWxvYWRlZCA9IDE7CgoJCW1lbXNldCgmbm90X3N0cmF0ZWdpZXMsIDAsIHNpemVvZihzdHJ1Y3QgY21kbmFtZXMpKTsKCQlsb2FkX2NvbW1hbmRfbGlzdCgiZ2l0LW1lcmdlLSIsICZtYWluX2NtZHMsICZvdGhlcl9jbWRzKTsKCQlmb3IgKGkgPSAwOyBpIDwgbWFpbl9jbWRzLmNudDsgaSsrKSB7CgkJCWludCBqLCBmb3VuZCA9IDA7CgkJCXN0cnVjdCBjbWRuYW1lICplbnQgPSBtYWluX2NtZHMubmFtZXNbaV07CgkJCWZvciAoaiA9IDA7IGogPCBBUlJBWV9TSVpFKGFsbF9zdHJhdGVneSk7IGorKykKCQkJCWlmICghc3RybmNtcChlbnQtPm5hbWUsIGFsbF9zdHJhdGVneVtqXS5uYW1lLCBlbnQtPmxlbikKCQkJCQkJJiYgIWFsbF9zdHJhdGVneVtqXS5uYW1lW2VudC0+bGVuXSkKCQkJCQlmb3VuZCA9IDE7CgkJCWlmICghZm91bmQpCgkJCQlhZGRfY21kbmFtZSgmbm90X3N0cmF0ZWdpZXMsIGVudC0+bmFtZSwgZW50LT5sZW4pOwoJCX0KCQlleGNsdWRlX2NtZHMoJm1haW5fY21kcywgJm5vdF9zdHJhdGVnaWVzKTsKCX0KCWlmICghaXNfaW5fY21kbGlzdCgmbWFpbl9jbWRzLCBuYW1lKSAmJiAhaXNfaW5fY21kbGlzdCgmb3RoZXJfY21kcywgbmFtZSkpIHsKCQlmcHJpbnRmKHN0ZGVyciwgXygiQ291bGQgbm90IGZpbmQgbWVyZ2Ugc3RyYXRlZ3kgJyVzJy5cbiIpLCBuYW1lKTsKCQlmcHJpbnRmKHN0ZGVyciwgXygiQXZhaWxhYmxlIHN0cmF0ZWdpZXMgYXJlOiIpKTsKCQlmb3IgKGkgPSAwOyBpIDwgbWFpbl9jbWRzLmNudDsgaSsrKQoJCQlmcHJpbnRmKHN0ZGVyciwgIiAlcyIsIG1haW5fY21kcy5uYW1lc1tpXS0+bmFtZSk7CgkJZnByaW50ZihzdGRlcnIsICIuXG4iKTsKCQlpZiAob3RoZXJfY21kcy5jbnQpIHsKCQkJZnByaW50ZihzdGRlcnIsIF8oIkF2YWlsYWJsZSBjdXN0b20gc3RyYXRlZ2llcyBhcmU6IikpOwoJCQlmb3IgKGkgPSAwOyBpIDwgb3RoZXJfY21kcy5jbnQ7IGkrKykKCQkJCWZwcmludGYoc3RkZXJyLCAiICVzIiwgb3RoZXJfY21kcy5uYW1lc1tpXS0+bmFtZSk7CgkJCWZwcmludGYoc3RkZXJyLCAiLlxuIik7CgkJfQoJCWV4aXQoMSk7Cgl9CgoJcmV0ID0geGNhbGxvYygxLCBzaXplb2Yoc3RydWN0IHN0cmF0ZWd5KSk7CglyZXQtPm5hbWUgPSB4c3RyZHVwKG5hbWUpOwoJcmV0LT5hdHRyID0gTk9fVFJJVklBTDsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyB2b2lkIGFwcGVuZF9zdHJhdGVneShzdHJ1Y3Qgc3RyYXRlZ3kgKnMpCnsKCUFMTE9DX0dST1codXNlX3N0cmF0ZWdpZXMsIHVzZV9zdHJhdGVnaWVzX25yICsgMSwgdXNlX3N0cmF0ZWdpZXNfYWxsb2MpOwoJdXNlX3N0cmF0ZWdpZXNbdXNlX3N0cmF0ZWdpZXNfbnIrK10gPSBzOwp9CgpzdGF0aWMgaW50IG9wdGlvbl9wYXJzZV9zdHJhdGVneShjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsCgkJCQkgY29uc3QgY2hhciAqbmFtZSwgaW50IHVuc2V0KQp7CglpZiAodW5zZXQpCgkJcmV0dXJuIDA7CgoJYXBwZW5kX3N0cmF0ZWd5KGdldF9zdHJhdGVneShuYW1lKSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBvcHRpb25fcGFyc2VfeChjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsCgkJCSAgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCWlmICh1bnNldCkKCQlyZXR1cm4gMDsKCglBTExPQ19HUk9XKHhvcHRzLCB4b3B0c19uciArIDEsIHhvcHRzX2FsbG9jKTsKCXhvcHRzW3hvcHRzX25yKytdID0geHN0cmR1cChhcmcpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgb3B0aW9uX3BhcnNlX24oY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LAoJCQkgIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglzaG93X2RpZmZzdGF0ID0gdW5zZXQ7CglyZXR1cm4gMDsKfQoKc3RhdGljIHN0cnVjdCBvcHRpb24gYnVpbHRpbl9tZXJnZV9vcHRpb25zW10gPSB7Cgl7IE9QVElPTl9DQUxMQkFDSywgJ24nLCBOVUxMLCBOVUxMLCBOVUxMLAoJCU5fKCJkbyBub3Qgc2hvdyBhIGRpZmZzdGF0IGF0IHRoZSBlbmQgb2YgdGhlIG1lcmdlIiksCgkJUEFSU0VfT1BUX05PQVJHLCBvcHRpb25fcGFyc2VfbiB9LAoJT1BUX0JPT0woMCwgInN0YXQiLCAmc2hvd19kaWZmc3RhdCwKCQlOXygic2hvdyBhIGRpZmZzdGF0IGF0IHRoZSBlbmQgb2YgdGhlIG1lcmdlIikpLAoJT1BUX0JPT0woMCwgInN1bW1hcnkiLCAmc2hvd19kaWZmc3RhdCwgTl8oIihzeW5vbnltIHRvIC0tc3RhdCkiKSksCgl7IE9QVElPTl9JTlRFR0VSLCAwLCAibG9nIiwgJnNob3J0bG9nX2xlbiwgTl8oIm4iKSwKCSAgTl8oImFkZCAoYXQgbW9zdCA8bj4pIGVudHJpZXMgZnJvbSBzaG9ydGxvZyB0byBtZXJnZSBjb21taXQgbWVzc2FnZSIpLAoJICBQQVJTRV9PUFRfT1BUQVJHLCBOVUxMLCBERUZBVUxUX01FUkdFX0xPR19MRU4gfSwKCU9QVF9CT09MKDAsICJzcXVhc2giLCAmc3F1YXNoLAoJCU5fKCJjcmVhdGUgYSBzaW5nbGUgY29tbWl0IGluc3RlYWQgb2YgZG9pbmcgYSBtZXJnZSIpKSwKCU9QVF9CT09MKDAsICJjb21taXQiLCAmb3B0aW9uX2NvbW1pdCwKCQlOXygicGVyZm9ybSBhIGNvbW1pdCBpZiB0aGUgbWVyZ2Ugc3VjY2VlZHMgKGRlZmF1bHQpIikpLAoJT1BUX0JPT0woJ2UnLCAiZWRpdCIsICZvcHRpb25fZWRpdCwKCQlOXygiZWRpdCBtZXNzYWdlIGJlZm9yZSBjb21taXR0aW5nIikpLAoJT1BUX1NFVF9JTlQoMCwgImZmIiwgJmZhc3RfZm9yd2FyZCwgTl8oImFsbG93IGZhc3QtZm9yd2FyZCAoZGVmYXVsdCkiKSwgRkZfQUxMT1cpLAoJeyBPUFRJT05fU0VUX0lOVCwgMCwgImZmLW9ubHkiLCAmZmFzdF9mb3J3YXJkLCBOVUxMLAoJCU5fKCJhYm9ydCBpZiBmYXN0LWZvcndhcmQgaXMgbm90IHBvc3NpYmxlIiksCgkJUEFSU0VfT1BUX05PQVJHIHwgUEFSU0VfT1BUX05PTkVHLCBOVUxMLCBGRl9PTkxZIH0sCglPUFRfUkVSRVJFX0FVVE9VUERBVEUoJmFsbG93X3JlcmVyZV9hdXRvKSwKCU9QVF9CT09MKDAsICJ2ZXJpZnktc2lnbmF0dXJlcyIsICZ2ZXJpZnlfc2lnbmF0dXJlcywKCQlOXygidmVyaWZ5IHRoYXQgdGhlIG5hbWVkIGNvbW1pdCBoYXMgYSB2YWxpZCBHUEcgc2lnbmF0dXJlIikpLAoJT1BUX0NBTExCQUNLKCdzJywgInN0cmF0ZWd5IiwgJnVzZV9zdHJhdGVnaWVzLCBOXygic3RyYXRlZ3kiKSwKCQlOXygibWVyZ2Ugc3RyYXRlZ3kgdG8gdXNlIiksIG9wdGlvbl9wYXJzZV9zdHJhdGVneSksCglPUFRfQ0FMTEJBQ0soJ1gnLCAic3RyYXRlZ3ktb3B0aW9uIiwgJnhvcHRzLCBOXygib3B0aW9uPXZhbHVlIiksCgkJTl8oIm9wdGlvbiBmb3Igc2VsZWN0ZWQgbWVyZ2Ugc3RyYXRlZ3kiKSwgb3B0aW9uX3BhcnNlX3gpLAoJT1BUX0NBTExCQUNLKCdtJywgIm1lc3NhZ2UiLCAmbWVyZ2VfbXNnLCBOXygibWVzc2FnZSIpLAoJCU5fKCJtZXJnZSBjb21taXQgbWVzc2FnZSAoZm9yIGEgbm9uLWZhc3QtZm9yd2FyZCBtZXJnZSkiKSwKCQlvcHRpb25fcGFyc2VfbWVzc2FnZSksCglPUFRfX1ZFUkJPU0lUWSgmdmVyYm9zaXR5KSwKCU9QVF9CT09MKDAsICJhYm9ydCIsICZhYm9ydF9jdXJyZW50X21lcmdlLAoJCU5fKCJhYm9ydCB0aGUgY3VycmVudCBpbi1wcm9ncmVzcyBtZXJnZSIpKSwKCU9QVF9CT09MKDAsICJhbGxvdy11bnJlbGF0ZWQtaGlzdG9yaWVzIiwgJmFsbG93X3VucmVsYXRlZF9oaXN0b3JpZXMsCgkJIE5fKCJhbGxvdyBtZXJnaW5nIHVucmVsYXRlZCBoaXN0b3JpZXMiKSksCglPUFRfU0VUX0lOVCgwLCAicHJvZ3Jlc3MiLCAmc2hvd19wcm9ncmVzcywgTl8oImZvcmNlIHByb2dyZXNzIHJlcG9ydGluZyIpLCAxKSwKCXsgT1BUSU9OX1NUUklORywgJ1MnLCAiZ3BnLXNpZ24iLCAmc2lnbl9jb21taXQsIE5fKCJrZXktaWQiKSwKCSAgTl8oIkdQRyBzaWduIGNvbW1pdCIpLCBQQVJTRV9PUFRfT1BUQVJHLCBOVUxMLCAoaW50cHRyX3QpICIiIH0sCglPUFRfQk9PTCgwLCAib3ZlcndyaXRlLWlnbm9yZSIsICZvdmVyd3JpdGVfaWdub3JlLCBOXygidXBkYXRlIGlnbm9yZWQgZmlsZXMgKGRlZmF1bHQpIikpLAoJT1BUX0VORCgpCn07CgovKiBDbGVhbnMgdXAgbWV0YWRhdGEgdGhhdCBpcyB1bmludGVyZXN0aW5nIGFmdGVyIGEgc3VjY2VlZGVkIG1lcmdlLiAqLwpzdGF0aWMgdm9pZCBkcm9wX3NhdmUodm9pZCkKewoJdW5saW5rKGdpdF9wYXRoX21lcmdlX2hlYWQoKSk7Cgl1bmxpbmsoZ2l0X3BhdGhfbWVyZ2VfbXNnKCkpOwoJdW5saW5rKGdpdF9wYXRoX21lcmdlX21vZGUoKSk7Cn0KCnN0YXRpYyBpbnQgc2F2ZV9zdGF0ZSh1bnNpZ25lZCBjaGFyICpzdGFzaCkKewoJaW50IGxlbjsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGNwID0gQ0hJTERfUFJPQ0VTU19JTklUOwoJc3RydWN0IHN0cmJ1ZiBidWZmZXIgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKmFyZ3ZbXSA9IHsic3Rhc2giLCAiY3JlYXRlIiwgTlVMTH07CgoJY3AuYXJndiA9IGFyZ3Y7CgljcC5vdXQgPSAtMTsKCWNwLmdpdF9jbWQgPSAxOwoKCWlmIChzdGFydF9jb21tYW5kKCZjcCkpCgkJZGllKF8oImNvdWxkIG5vdCBydW4gc3Rhc2guIikpOwoJbGVuID0gc3RyYnVmX3JlYWQoJmJ1ZmZlciwgY3Aub3V0LCAxMDI0KTsKCWNsb3NlKGNwLm91dCk7CgoJaWYgKGZpbmlzaF9jb21tYW5kKCZjcCkgfHwgbGVuIDwgMCkKCQlkaWUoXygic3Rhc2ggZmFpbGVkIikpOwoJZWxzZSBpZiAoIWxlbikJCS8qIG5vIGNoYW5nZXMgKi8KCQlyZXR1cm4gLTE7CglzdHJidWZfc2V0bGVuKCZidWZmZXIsIGJ1ZmZlci5sZW4tMSk7CglpZiAoZ2V0X3NoYTEoYnVmZmVyLmJ1Ziwgc3Rhc2gpKQoJCWRpZShfKCJub3QgYSB2YWxpZCBvYmplY3Q6ICVzIiksIGJ1ZmZlci5idWYpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHJlYWRfZW1wdHkodW5zaWduZWQgY29uc3QgY2hhciAqc2hhMSwgaW50IHZlcmJvc2UpCnsKCWludCBpID0gMDsKCWNvbnN0IGNoYXIgKmFyZ3NbN107CgoJYXJnc1tpKytdID0gInJlYWQtdHJlZSI7CglpZiAodmVyYm9zZSkKCQlhcmdzW2krK10gPSAiLXYiOwoJYXJnc1tpKytdID0gIi1tIjsKCWFyZ3NbaSsrXSA9ICItdSI7CglhcmdzW2krK10gPSBFTVBUWV9UUkVFX1NIQTFfSEVYOwoJYXJnc1tpKytdID0gc2hhMV90b19oZXgoc2hhMSk7CglhcmdzW2ldID0gTlVMTDsKCglpZiAocnVuX2NvbW1hbmRfdl9vcHQoYXJncywgUlVOX0dJVF9DTUQpKQoJCWRpZShfKCJyZWFkLXRyZWUgZmFpbGVkIikpOwp9CgpzdGF0aWMgdm9pZCByZXNldF9oYXJkKHVuc2lnbmVkIGNvbnN0IGNoYXIgKnNoYTEsIGludCB2ZXJib3NlKQp7CglpbnQgaSA9IDA7Cgljb25zdCBjaGFyICphcmdzWzZdOwoKCWFyZ3NbaSsrXSA9ICJyZWFkLXRyZWUiOwoJaWYgKHZlcmJvc2UpCgkJYXJnc1tpKytdID0gIi12IjsKCWFyZ3NbaSsrXSA9ICItLXJlc2V0IjsKCWFyZ3NbaSsrXSA9ICItdSI7CglhcmdzW2krK10gPSBzaGExX3RvX2hleChzaGExKTsKCWFyZ3NbaV0gPSBOVUxMOwoKCWlmIChydW5fY29tbWFuZF92X29wdChhcmdzLCBSVU5fR0lUX0NNRCkpCgkJZGllKF8oInJlYWQtdHJlZSBmYWlsZWQiKSk7Cn0KCnN0YXRpYyB2b2lkIHJlc3RvcmVfc3RhdGUoY29uc3QgdW5zaWduZWQgY2hhciAqaGVhZCwKCQkJICBjb25zdCB1bnNpZ25lZCBjaGFyICpzdGFzaCkKewoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJY29uc3QgY2hhciAqYXJnc1tdID0geyAic3Rhc2giLCAiYXBwbHkiLCBOVUxMLCBOVUxMIH07CgoJaWYgKGlzX251bGxfc2hhMShzdGFzaCkpCgkJcmV0dXJuOwoKCXJlc2V0X2hhcmQoaGVhZCwgMSk7CgoJYXJnc1syXSA9IHNoYTFfdG9faGV4KHN0YXNoKTsKCgkvKgoJICogSXQgaXMgT0sgdG8gaWdub3JlIGVycm9yIGhlcmUsIGZvciBleGFtcGxlIHdoZW4gdGhlcmUgd2FzCgkgKiBub3RoaW5nIHRvIHJlc3RvcmUuCgkgKi8KCXJ1bl9jb21tYW5kX3Zfb3B0KGFyZ3MsIFJVTl9HSVRfQ01EKTsKCglzdHJidWZfcmVsZWFzZSgmc2IpOwoJcmVmcmVzaF9jYWNoZShSRUZSRVNIX1FVSUVUKTsKfQoKLyogVGhpcyBpcyBjYWxsZWQgd2hlbiBubyBtZXJnZSB3YXMgbmVjZXNzYXJ5LiAqLwpzdGF0aWMgdm9pZCBmaW5pc2hfdXBfdG9fZGF0ZShjb25zdCBjaGFyICptc2cpCnsKCWlmICh2ZXJib3NpdHkgPj0gMCkKCQlwcmludGYoIiVzJXNcbiIsIHNxdWFzaCA/IF8oIiAobm90aGluZyB0byBzcXVhc2gpIikgOiAiIiwgbXNnKTsKCWRyb3Bfc2F2ZSgpOwp9CgpzdGF0aWMgdm9pZCBzcXVhc2hfbWVzc2FnZShzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHN0cnVjdCBjb21taXRfbGlzdCAqcmVtb3RlaGVhZHMpCnsKCXN0cnVjdCByZXZfaW5mbyByZXY7CglzdHJ1Y3Qgc3RyYnVmIG91dCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IGNvbW1pdF9saXN0ICpqOwoJc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0IGN0eCA9IHswfTsKCglwcmludGYoXygiU3F1YXNoIGNvbW1pdCAtLSBub3QgdXBkYXRpbmcgSEVBRFxuIikpOwoKCWluaXRfcmV2aXNpb25zKCZyZXYsIE5VTEwpOwoJcmV2Lmlnbm9yZV9tZXJnZXMgPSAxOwoJcmV2LmNvbW1pdF9mb3JtYXQgPSBDTUlUX0ZNVF9NRURJVU07CgoJY29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gVU5JTlRFUkVTVElORzsKCWFkZF9wZW5kaW5nX29iamVjdCgmcmV2LCAmY29tbWl0LT5vYmplY3QsIE5VTEwpOwoKCWZvciAoaiA9IHJlbW90ZWhlYWRzOyBqOyBqID0gai0+bmV4dCkKCQlhZGRfcGVuZGluZ19vYmplY3QoJnJldiwgJmotPml0ZW0tPm9iamVjdCwgTlVMTCk7CgoJc2V0dXBfcmV2aXNpb25zKDAsIE5VTEwsICZyZXYsIE5VTEwpOwoJaWYgKHByZXBhcmVfcmV2aXNpb25fd2FsaygmcmV2KSkKCQlkaWUoXygicmV2aXNpb24gd2FsayBzZXR1cCBmYWlsZWQiKSk7CgoJY3R4LmFiYnJldiA9IHJldi5hYmJyZXY7CgljdHguZGF0ZV9tb2RlID0gcmV2LmRhdGVfbW9kZTsKCWN0eC5mbXQgPSByZXYuY29tbWl0X2Zvcm1hdDsKCglzdHJidWZfYWRkc3RyKCZvdXQsICJTcXVhc2hlZCBjb21taXQgb2YgdGhlIGZvbGxvd2luZzpcbiIpOwoJd2hpbGUgKChjb21taXQgPSBnZXRfcmV2aXNpb24oJnJldikpICE9IE5VTEwpIHsKCQlzdHJidWZfYWRkY2goJm91dCwgJ1xuJyk7CgkJc3RyYnVmX2FkZGYoJm91dCwgImNvbW1pdCAlc1xuIiwKCQkJb2lkX3RvX2hleCgmY29tbWl0LT5vYmplY3Qub2lkKSk7CgkJcHJldHR5X3ByaW50X2NvbW1pdCgmY3R4LCBjb21taXQsICZvdXQpOwoJfQoJd3JpdGVfZmlsZV9idWYoZ2l0X3BhdGhfc3F1YXNoX21zZygpLCBvdXQuYnVmLCBvdXQubGVuKTsKCXN0cmJ1Zl9yZWxlYXNlKCZvdXQpOwp9CgpzdGF0aWMgdm9pZCBmaW5pc2goc3RydWN0IGNvbW1pdCAqaGVhZF9jb21taXQsCgkJICAgc3RydWN0IGNvbW1pdF9saXN0ICpyZW1vdGVoZWFkcywKCQkgICBjb25zdCB1bnNpZ25lZCBjaGFyICpuZXdfaGVhZCwgY29uc3QgY2hhciAqbXNnKQp7CglzdHJ1Y3Qgc3RyYnVmIHJlZmxvZ19tZXNzYWdlID0gU1RSQlVGX0lOSVQ7Cgljb25zdCB1bnNpZ25lZCBjaGFyICpoZWFkID0gaGVhZF9jb21taXQtPm9iamVjdC5vaWQuaGFzaDsKCglpZiAoIW1zZykKCQlzdHJidWZfYWRkc3RyKCZyZWZsb2dfbWVzc2FnZSwgZ2V0ZW52KCJHSVRfUkVGTE9HX0FDVElPTiIpKTsKCWVsc2UgewoJCWlmICh2ZXJib3NpdHkgPj0gMCkKCQkJcHJpbnRmKCIlc1xuIiwgbXNnKTsKCQlzdHJidWZfYWRkZigmcmVmbG9nX21lc3NhZ2UsICIlczogJXMiLAoJCQlnZXRlbnYoIkdJVF9SRUZMT0dfQUNUSU9OIiksIG1zZyk7Cgl9CglpZiAoc3F1YXNoKSB7CgkJc3F1YXNoX21lc3NhZ2UoaGVhZF9jb21taXQsIHJlbW90ZWhlYWRzKTsKCX0gZWxzZSB7CgkJaWYgKHZlcmJvc2l0eSA+PSAwICYmICFtZXJnZV9tc2cubGVuKQoJCQlwcmludGYoXygiTm8gbWVyZ2UgbWVzc2FnZSAtLSBub3QgdXBkYXRpbmcgSEVBRFxuIikpOwoJCWVsc2UgewoJCQljb25zdCBjaGFyICphcmd2X2djX2F1dG9bXSA9IHsgImdjIiwgIi0tYXV0byIsIE5VTEwgfTsKCQkJdXBkYXRlX3JlZihyZWZsb2dfbWVzc2FnZS5idWYsICJIRUFEIiwKCQkJCW5ld19oZWFkLCBoZWFkLCAwLAoJCQkJVVBEQVRFX1JFRlNfRElFX09OX0VSUik7CgkJCS8qCgkJCSAqIFdlIGlnbm9yZSBlcnJvcnMgaW4gJ2djIC0tYXV0bycsIHNpbmNlIHRoZQoJCQkgKiB1c2VyIHNob3VsZCBzZWUgdGhlbS4KCQkJICovCgkJCWNsb3NlX2FsbF9wYWNrcygpOwoJCQlydW5fY29tbWFuZF92X29wdChhcmd2X2djX2F1dG8sIFJVTl9HSVRfQ01EKTsKCQl9Cgl9CglpZiAobmV3X2hlYWQgJiYgc2hvd19kaWZmc3RhdCkgewoJCXN0cnVjdCBkaWZmX29wdGlvbnMgb3B0czsKCQlkaWZmX3NldHVwKCZvcHRzKTsKCQlvcHRzLnN0YXRfd2lkdGggPSAtMTsgLyogdXNlIGZ1bGwgdGVybWluYWwgd2lkdGggKi8KCQlvcHRzLnN0YXRfZ3JhcGhfd2lkdGggPSAtMTsgLyogcmVzcGVjdCBzdGF0R3JhcGhXaWR0aCBjb25maWcgKi8KCQlvcHRzLm91dHB1dF9mb3JtYXQgfD0KCQkJRElGRl9GT1JNQVRfU1VNTUFSWSB8IERJRkZfRk9STUFUX0RJRkZTVEFUOwoJCW9wdHMuZGV0ZWN0X3JlbmFtZSA9IERJRkZfREVURUNUX1JFTkFNRTsKCQlkaWZmX3NldHVwX2RvbmUoJm9wdHMpOwoJCWRpZmZfdHJlZV9zaGExKGhlYWQsIG5ld19oZWFkLCAiIiwgJm9wdHMpOwoJCWRpZmZjb3JlX3N0ZCgmb3B0cyk7CgkJZGlmZl9mbHVzaCgmb3B0cyk7Cgl9CgoJLyogUnVuIGEgcG9zdC1tZXJnZSBob29rICovCglydW5faG9va19sZShOVUxMLCAicG9zdC1tZXJnZSIsIHNxdWFzaCA/ICIxIiA6ICIwIiwgTlVMTCk7CgoJc3RyYnVmX3JlbGVhc2UoJnJlZmxvZ19tZXNzYWdlKTsKfQoKLyogR2V0IHRoZSBuYW1lIGZvciB0aGUgbWVyZ2UgY29tbWl0J3MgbWVzc2FnZS4gKi8Kc3RhdGljIHZvaWQgbWVyZ2VfbmFtZShjb25zdCBjaGFyICpyZW1vdGUsIHN0cnVjdCBzdHJidWYgKm1zZykKewoJc3RydWN0IGNvbW1pdCAqcmVtb3RlX2hlYWQ7Cgl1bnNpZ25lZCBjaGFyIGJyYW5jaF9oZWFkWzIwXTsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGJuYW1lID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpwdHI7CgljaGFyICpmb3VuZF9yZWY7CglpbnQgbGVuLCBlYXJseTsKCglzdHJidWZfYnJhbmNobmFtZSgmYm5hbWUsIHJlbW90ZSk7CglyZW1vdGUgPSBibmFtZS5idWY7CgoJbWVtc2V0KGJyYW5jaF9oZWFkLCAwLCBzaXplb2YoYnJhbmNoX2hlYWQpKTsKCXJlbW90ZV9oZWFkID0gZ2V0X21lcmdlX3BhcmVudChyZW1vdGUpOwoJaWYgKCFyZW1vdGVfaGVhZCkKCQlkaWUoXygiJyVzJyBkb2VzIG5vdCBwb2ludCB0byBhIGNvbW1pdCIpLCByZW1vdGUpOwoKCWlmIChkd2ltX3JlZihyZW1vdGUsIHN0cmxlbihyZW1vdGUpLCBicmFuY2hfaGVhZCwgJmZvdW5kX3JlZikgPiAwKSB7CgkJaWYgKHN0YXJ0c193aXRoKGZvdW5kX3JlZiwgInJlZnMvaGVhZHMvIikpIHsKCQkJc3RyYnVmX2FkZGYobXNnLCAiJXNcdFx0YnJhbmNoICclcycgb2YgLlxuIiwKCQkJCSAgICBzaGExX3RvX2hleChicmFuY2hfaGVhZCksIHJlbW90ZSk7CgkJCWdvdG8gY2xlYW51cDsKCQl9CgkJaWYgKHN0YXJ0c193aXRoKGZvdW5kX3JlZiwgInJlZnMvdGFncy8iKSkgewoJCQlzdHJidWZfYWRkZihtc2csICIlc1x0XHR0YWcgJyVzJyBvZiAuXG4iLAoJCQkJICAgIHNoYTFfdG9faGV4KGJyYW5jaF9oZWFkKSwgcmVtb3RlKTsKCQkJZ290byBjbGVhbnVwOwoJCX0KCQlpZiAoc3RhcnRzX3dpdGgoZm91bmRfcmVmLCAicmVmcy9yZW1vdGVzLyIpKSB7CgkJCXN0cmJ1Zl9hZGRmKG1zZywgIiVzXHRcdHJlbW90ZS10cmFja2luZyBicmFuY2ggJyVzJyBvZiAuXG4iLAoJCQkJICAgIHNoYTFfdG9faGV4KGJyYW5jaF9oZWFkKSwgcmVtb3RlKTsKCQkJZ290byBjbGVhbnVwOwoJCX0KCX0KCgkvKiBTZWUgaWYgcmVtb3RlIG1hdGNoZXMgPG5hbWU+Xl5eLi4gb3IgPG5hbWU+fjxudW1iZXI+ICovCglmb3IgKGxlbiA9IDAsIHB0ciA9IHJlbW90ZSArIHN0cmxlbihyZW1vdGUpOwoJICAgICByZW1vdGUgPCBwdHIgJiYgcHRyWy0xXSA9PSAnXic7CgkgICAgIHB0ci0tKQoJCWxlbisrOwoJaWYgKGxlbikKCQllYXJseSA9IDE7CgllbHNlIHsKCQllYXJseSA9IDA7CgkJcHRyID0gc3RycmNocihyZW1vdGUsICd+Jyk7CgkJaWYgKHB0cikgewoJCQlpbnQgc2Vlbl9ub256ZXJvID0gMDsKCgkJCWxlbisrOyAvKiBjb3VudCB+ICovCgkJCXdoaWxlICgqKytwdHIgJiYgaXNkaWdpdCgqcHRyKSkgewoJCQkJc2Vlbl9ub256ZXJvIHw9ICgqcHRyICE9ICcwJyk7CgkJCQlsZW4rKzsKCQkJfQoJCQlpZiAoKnB0cikKCQkJCWxlbiA9IDA7IC8qIG5vdCAuLi5+PG51bWJlcj4gKi8KCQkJZWxzZSBpZiAoc2Vlbl9ub256ZXJvKQoJCQkJZWFybHkgPSAxOwoJCQllbHNlIGlmIChsZW4gPT0gMSkKCQkJCWVhcmx5ID0gMTsgLyogIm5hbWV+IiBpcyAibmFtZX4xIiEgKi8KCQl9Cgl9CglpZiAobGVuKSB7CgkJc3RydWN0IHN0cmJ1ZiB0cnVuYW1lID0gU1RSQlVGX0lOSVQ7CgkJc3RyYnVmX2FkZGYoJnRydW5hbWUsICJyZWZzL2hlYWRzLyVzIiwgcmVtb3RlKTsKCQlzdHJidWZfc2V0bGVuKCZ0cnVuYW1lLCB0cnVuYW1lLmxlbiAtIGxlbik7CgkJaWYgKHJlZl9leGlzdHModHJ1bmFtZS5idWYpKSB7CgkJCXN0cmJ1Zl9hZGRmKG1zZywKCQkJCSAgICAiJXNcdFx0YnJhbmNoICclcyclcyBvZiAuXG4iLAoJCQkJICAgIG9pZF90b19oZXgoJnJlbW90ZV9oZWFkLT5vYmplY3Qub2lkKSwKCQkJCSAgICB0cnVuYW1lLmJ1ZiArIDExLAoJCQkJICAgIChlYXJseSA/ICIgKGVhcmx5IHBhcnQpIiA6ICIiKSk7CgkJCXN0cmJ1Zl9yZWxlYXNlKCZ0cnVuYW1lKTsKCQkJZ290byBjbGVhbnVwOwoJCX0KCQlzdHJidWZfcmVsZWFzZSgmdHJ1bmFtZSk7Cgl9CgoJaWYgKHJlbW90ZV9oZWFkLT51dGlsKSB7CgkJc3RydWN0IG1lcmdlX3JlbW90ZV9kZXNjICpkZXNjOwoJCWRlc2MgPSBtZXJnZV9yZW1vdGVfdXRpbChyZW1vdGVfaGVhZCk7CgkJaWYgKGRlc2MgJiYgZGVzYy0+b2JqICYmIGRlc2MtPm9iai0+dHlwZSA9PSBPQkpfVEFHKSB7CgkJCXN0cmJ1Zl9hZGRmKG1zZywgIiVzXHRcdCVzICclcydcbiIsCgkJCQkgICAgb2lkX3RvX2hleCgmZGVzYy0+b2JqLT5vaWQpLAoJCQkJICAgIHR5cGVuYW1lKGRlc2MtPm9iai0+dHlwZSksCgkJCQkgICAgcmVtb3RlKTsKCQkJZ290byBjbGVhbnVwOwoJCX0KCX0KCglzdHJidWZfYWRkZihtc2csICIlc1x0XHRjb21taXQgJyVzJ1xuIiwKCQlvaWRfdG9faGV4KCZyZW1vdGVfaGVhZC0+b2JqZWN0Lm9pZCksIHJlbW90ZSk7CmNsZWFudXA6CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCXN0cmJ1Zl9yZWxlYXNlKCZibmFtZSk7Cn0KCnN0YXRpYyB2b2lkIHBhcnNlX2JyYW5jaF9tZXJnZV9vcHRpb25zKGNoYXIgKmJtbykKewoJY29uc3QgY2hhciAqKmFyZ3Y7CglpbnQgYXJnYzsKCglpZiAoIWJtbykKCQlyZXR1cm47CglhcmdjID0gc3BsaXRfY21kbGluZShibW8sICZhcmd2KTsKCWlmIChhcmdjIDwgMCkKCQlkaWUoXygiQmFkIGJyYW5jaC4lcy5tZXJnZW9wdGlvbnMgc3RyaW5nOiAlcyIpLCBicmFuY2gsCgkJICAgIHNwbGl0X2NtZGxpbmVfc3RyZXJyb3IoYXJnYykpOwoJUkVBTExPQ19BUlJBWShhcmd2LCBhcmdjICsgMik7CgltZW1tb3ZlKGFyZ3YgKyAxLCBhcmd2LCBzaXplb2YoKmFyZ3YpICogKGFyZ2MgKyAxKSk7CglhcmdjKys7Cglhcmd2WzBdID0gImJyYW5jaC4qLm1lcmdlb3B0aW9ucyI7CglwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIE5VTEwsIGJ1aWx0aW5fbWVyZ2Vfb3B0aW9ucywKCQkgICAgICBidWlsdGluX21lcmdlX3VzYWdlLCAwKTsKCWZyZWUoYXJndik7Cn0KCnN0YXRpYyBpbnQgZ2l0X21lcmdlX2NvbmZpZyhjb25zdCBjaGFyICprLCBjb25zdCBjaGFyICp2LCB2b2lkICpjYikKewoJaW50IHN0YXR1czsKCglpZiAoYnJhbmNoICYmIHN0YXJ0c193aXRoKGssICJicmFuY2guIikgJiYKCQlzdGFydHNfd2l0aChrICsgNywgYnJhbmNoKSAmJgoJCSFzdHJjbXAoayArIDcgKyBzdHJsZW4oYnJhbmNoKSwgIi5tZXJnZW9wdGlvbnMiKSkgewoJCWZyZWUoYnJhbmNoX21lcmdlb3B0aW9ucyk7CgkJYnJhbmNoX21lcmdlb3B0aW9ucyA9IHhzdHJkdXAodik7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKCFzdHJjbXAoaywgIm1lcmdlLmRpZmZzdGF0IikgfHwgIXN0cmNtcChrLCAibWVyZ2Uuc3RhdCIpKQoJCXNob3dfZGlmZnN0YXQgPSBnaXRfY29uZmlnX2Jvb2woaywgdik7CgllbHNlIGlmICghc3RyY21wKGssICJwdWxsLnR3b2hlYWQiKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJnB1bGxfdHdvaGVhZCwgaywgdik7CgllbHNlIGlmICghc3RyY21wKGssICJwdWxsLm9jdG9wdXMiKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJnB1bGxfb2N0b3B1cywgaywgdik7CgllbHNlIGlmICghc3RyY21wKGssICJtZXJnZS5yZW5vcm1hbGl6ZSIpKQoJCW9wdGlvbl9yZW5vcm1hbGl6ZSA9IGdpdF9jb25maWdfYm9vbChrLCB2KTsKCWVsc2UgaWYgKCFzdHJjbXAoaywgIm1lcmdlLmZmIikpIHsKCQlpbnQgYm9vbHZhbCA9IGdpdF9jb25maWdfbWF5YmVfYm9vbChrLCB2KTsKCQlpZiAoMCA8PSBib29sdmFsKSB7CgkJCWZhc3RfZm9yd2FyZCA9IGJvb2x2YWwgPyBGRl9BTExPVyA6IEZGX05POwoJCX0gZWxzZSBpZiAodiAmJiAhc3RyY21wKHYsICJvbmx5IikpIHsKCQkJZmFzdF9mb3J3YXJkID0gRkZfT05MWTsKCQl9IC8qIGRvIG5vdCBiYXJmIG9uIHZhbHVlcyBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnaXQgKi8KCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChrLCAibWVyZ2UuZGVmYXVsdHRvdXBzdHJlYW0iKSkgewoJCWRlZmF1bHRfdG9fdXBzdHJlYW0gPSBnaXRfY29uZmlnX2Jvb2woaywgdik7CgkJcmV0dXJuIDA7Cgl9IGVsc2UgaWYgKCFzdHJjbXAoaywgImNvbW1pdC5ncGdzaWduIikpIHsKCQlzaWduX2NvbW1pdCA9IGdpdF9jb25maWdfYm9vbChrLCB2KSA/ICIiIDogTlVMTDsKCQlyZXR1cm4gMDsKCX0KCglzdGF0dXMgPSBmbXRfbWVyZ2VfbXNnX2NvbmZpZyhrLCB2LCBjYik7CglpZiAoc3RhdHVzKQoJCXJldHVybiBzdGF0dXM7CglzdGF0dXMgPSBnaXRfZ3BnX2NvbmZpZyhrLCB2LCBOVUxMKTsKCWlmIChzdGF0dXMpCgkJcmV0dXJuIHN0YXR1czsKCXJldHVybiBnaXRfZGlmZl91aV9jb25maWcoaywgdiwgY2IpOwp9CgpzdGF0aWMgaW50IHJlYWRfdHJlZV90cml2aWFsKHVuc2lnbmVkIGNoYXIgKmNvbW1vbiwgdW5zaWduZWQgY2hhciAqaGVhZCwKCQkJICAgICB1bnNpZ25lZCBjaGFyICpvbmUpCnsKCWludCBpLCBucl90cmVlcyA9IDA7CglzdHJ1Y3QgdHJlZSAqdHJlZXNbTUFYX1VOUEFDS19UUkVFU107CglzdHJ1Y3QgdHJlZV9kZXNjIHRbTUFYX1VOUEFDS19UUkVFU107CglzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgb3B0czsKCgltZW1zZXQoJm9wdHMsIDAsIHNpemVvZihvcHRzKSk7CglvcHRzLmhlYWRfaWR4ID0gMjsKCW9wdHMuc3JjX2luZGV4ID0gJnRoZV9pbmRleDsKCW9wdHMuZHN0X2luZGV4ID0gJnRoZV9pbmRleDsKCW9wdHMudXBkYXRlID0gMTsKCW9wdHMudmVyYm9zZV91cGRhdGUgPSAxOwoJb3B0cy50cml2aWFsX21lcmdlc19vbmx5ID0gMTsKCW9wdHMubWVyZ2UgPSAxOwoJdHJlZXNbbnJfdHJlZXNdID0gcGFyc2VfdHJlZV9pbmRpcmVjdChjb21tb24pOwoJaWYgKCF0cmVlc1tucl90cmVlcysrXSkKCQlyZXR1cm4gLTE7Cgl0cmVlc1tucl90cmVlc10gPSBwYXJzZV90cmVlX2luZGlyZWN0KGhlYWQpOwoJaWYgKCF0cmVlc1tucl90cmVlcysrXSkKCQlyZXR1cm4gLTE7Cgl0cmVlc1tucl90cmVlc10gPSBwYXJzZV90cmVlX2luZGlyZWN0KG9uZSk7CglpZiAoIXRyZWVzW25yX3RyZWVzKytdKQoJCXJldHVybiAtMTsKCW9wdHMuZm4gPSB0aHJlZXdheV9tZXJnZTsKCWNhY2hlX3RyZWVfZnJlZSgmYWN0aXZlX2NhY2hlX3RyZWUpOwoJZm9yIChpID0gMDsgaSA8IG5yX3RyZWVzOyBpKyspIHsKCQlwYXJzZV90cmVlKHRyZWVzW2ldKTsKCQlpbml0X3RyZWVfZGVzYyh0K2ksIHRyZWVzW2ldLT5idWZmZXIsIHRyZWVzW2ldLT5zaXplKTsKCX0KCWlmICh1bnBhY2tfdHJlZXMobnJfdHJlZXMsIHQsICZvcHRzKSkKCQlyZXR1cm4gLTE7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgd3JpdGVfdHJlZV90cml2aWFsKHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCWlmICh3cml0ZV9jYWNoZV9hc190cmVlKHNoYTEsIDAsIE5VTEwpKQoJCWRpZShfKCJnaXQgd3JpdGUtdHJlZSBmYWlsZWQgdG8gd3JpdGUgYSB0cmVlIikpOwp9CgpzdGF0aWMgaW50IHRyeV9tZXJnZV9zdHJhdGVneShjb25zdCBjaGFyICpzdHJhdGVneSwgc3RydWN0IGNvbW1pdF9saXN0ICpjb21tb24sCgkJCSAgICAgIHN0cnVjdCBjb21taXRfbGlzdCAqcmVtb3RlaGVhZHMsCgkJCSAgICAgIHN0cnVjdCBjb21taXQgKmhlYWQsIGNvbnN0IGNoYXIgKmhlYWRfYXJnKQp7CglzdGF0aWMgc3RydWN0IGxvY2tfZmlsZSBsb2NrOwoKCWhvbGRfbG9ja2VkX2luZGV4KCZsb2NrLCBMT0NLX0RJRV9PTl9FUlJPUik7CglyZWZyZXNoX2NhY2hlKFJFRlJFU0hfUVVJRVQpOwoJaWYgKGFjdGl2ZV9jYWNoZV9jaGFuZ2VkICYmCgkgICAgd3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZsb2NrLCBDT01NSVRfTE9DSykpCgkJcmV0dXJuIGVycm9yKF8oIlVuYWJsZSB0byB3cml0ZSBpbmRleC4iKSk7Cglyb2xsYmFja19sb2NrX2ZpbGUoJmxvY2spOwoKCWlmICghc3RyY21wKHN0cmF0ZWd5LCAicmVjdXJzaXZlIikgfHwgIXN0cmNtcChzdHJhdGVneSwgInN1YnRyZWUiKSkgewoJCWludCBjbGVhbiwgeDsKCQlzdHJ1Y3QgY29tbWl0ICpyZXN1bHQ7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpyZXZlcnNlZCA9IE5VTEw7CgkJc3RydWN0IG1lcmdlX29wdGlvbnMgbzsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKmo7CgoJCWlmIChyZW1vdGVoZWFkcy0+bmV4dCkgewoJCQllcnJvcihfKCJOb3QgaGFuZGxpbmcgYW55dGhpbmcgb3RoZXIgdGhhbiB0d28gaGVhZHMgbWVyZ2UuIikpOwoJCQlyZXR1cm4gMjsKCQl9CgoJCWluaXRfbWVyZ2Vfb3B0aW9ucygmbyk7CgkJaWYgKCFzdHJjbXAoc3RyYXRlZ3ksICJzdWJ0cmVlIikpCgkJCW8uc3VidHJlZV9zaGlmdCA9ICIiOwoKCQlvLnJlbm9ybWFsaXplID0gb3B0aW9uX3Jlbm9ybWFsaXplOwoJCW8uc2hvd19yZW5hbWVfcHJvZ3Jlc3MgPQoJCQlzaG93X3Byb2dyZXNzID09IC0xID8gaXNhdHR5KDIpIDogc2hvd19wcm9ncmVzczsKCgkJZm9yICh4ID0gMDsgeCA8IHhvcHRzX25yOyB4KyspCgkJCWlmIChwYXJzZV9tZXJnZV9vcHQoJm8sIHhvcHRzW3hdKSkKCQkJCWRpZShfKCJVbmtub3duIG9wdGlvbiBmb3IgbWVyZ2UtcmVjdXJzaXZlOiAtWCVzIiksIHhvcHRzW3hdKTsKCgkJby5icmFuY2gxID0gaGVhZF9hcmc7CgkJby5icmFuY2gyID0gbWVyZ2VfcmVtb3RlX3V0aWwocmVtb3RlaGVhZHMtPml0ZW0pLT5uYW1lOwoKCQlmb3IgKGogPSBjb21tb247IGo7IGogPSBqLT5uZXh0KQoJCQljb21taXRfbGlzdF9pbnNlcnQoai0+aXRlbSwgJnJldmVyc2VkKTsKCgkJaG9sZF9sb2NrZWRfaW5kZXgoJmxvY2ssIExPQ0tfRElFX09OX0VSUk9SKTsKCQljbGVhbiA9IG1lcmdlX3JlY3Vyc2l2ZSgmbywgaGVhZCwKCQkJCXJlbW90ZWhlYWRzLT5pdGVtLCByZXZlcnNlZCwgJnJlc3VsdCk7CgkJaWYgKGNsZWFuIDwgMCkKCQkJZXhpdCgxMjgpOwoJCWlmIChhY3RpdmVfY2FjaGVfY2hhbmdlZCAmJgoJCSAgICB3cml0ZV9sb2NrZWRfaW5kZXgoJnRoZV9pbmRleCwgJmxvY2ssIENPTU1JVF9MT0NLKSkKCQkJZGllIChfKCJ1bmFibGUgdG8gd3JpdGUgJXMiKSwgZ2V0X2luZGV4X2ZpbGUoKSk7CgkJcm9sbGJhY2tfbG9ja19maWxlKCZsb2NrKTsKCQlyZXR1cm4gY2xlYW4gPyAwIDogMTsKCX0gZWxzZSB7CgkJcmV0dXJuIHRyeV9tZXJnZV9jb21tYW5kKHN0cmF0ZWd5LCB4b3B0c19uciwgeG9wdHMsCgkJCQkJCWNvbW1vbiwgaGVhZF9hcmcsIHJlbW90ZWhlYWRzKTsKCX0KfQoKc3RhdGljIHZvaWQgY291bnRfZGlmZl9maWxlcyhzdHJ1Y3QgZGlmZl9xdWV1ZV9zdHJ1Y3QgKnEsCgkJCSAgICAgc3RydWN0IGRpZmZfb3B0aW9ucyAqb3B0LCB2b2lkICpkYXRhKQp7CglpbnQgKmNvdW50ID0gZGF0YTsKCgkoKmNvdW50KSArPSBxLT5ucjsKfQoKc3RhdGljIGludCBjb3VudF91bm1lcmdlZF9lbnRyaWVzKHZvaWQpCnsKCWludCBpLCByZXQgPSAwOwoKCWZvciAoaSA9IDA7IGkgPCBhY3RpdmVfbnI7IGkrKykKCQlpZiAoY2Vfc3RhZ2UoYWN0aXZlX2NhY2hlW2ldKSkKCQkJcmV0Kys7CgoJcmV0dXJuIHJldDsKfQoKc3RhdGljIHZvaWQgYWRkX3N0cmF0ZWdpZXMoY29uc3QgY2hhciAqc3RyaW5nLCB1bnNpZ25lZCBhdHRyKQp7CglpbnQgaTsKCglpZiAoc3RyaW5nKSB7CgkJc3RydWN0IHN0cmluZ19saXN0IGxpc3QgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbTsKCQlzdHJpbmdfbGlzdF9zcGxpdCgmbGlzdCwgc3RyaW5nLCAnICcsIC0xKTsKCQlmb3JfZWFjaF9zdHJpbmdfbGlzdF9pdGVtKGl0ZW0sICZsaXN0KQoJCQlhcHBlbmRfc3RyYXRlZ3koZ2V0X3N0cmF0ZWd5KGl0ZW0tPnN0cmluZykpOwoJCXN0cmluZ19saXN0X2NsZWFyKCZsaXN0LCAwKTsKCQlyZXR1cm47Cgl9Cglmb3IgKGkgPSAwOyBpIDwgQVJSQVlfU0laRShhbGxfc3RyYXRlZ3kpOyBpKyspCgkJaWYgKGFsbF9zdHJhdGVneVtpXS5hdHRyICYgYXR0cikKCQkJYXBwZW5kX3N0cmF0ZWd5KCZhbGxfc3RyYXRlZ3lbaV0pOwoKfQoKc3RhdGljIHZvaWQgcmVhZF9tZXJnZV9tc2coc3RydWN0IHN0cmJ1ZiAqbXNnKQp7Cgljb25zdCBjaGFyICpmaWxlbmFtZSA9IGdpdF9wYXRoX21lcmdlX21zZygpOwoJc3RyYnVmX3Jlc2V0KG1zZyk7CglpZiAoc3RyYnVmX3JlYWRfZmlsZShtc2csIGZpbGVuYW1lLCAwKSA8IDApCgkJZGllX2Vycm5vKF8oIkNvdWxkIG5vdCByZWFkIGZyb20gJyVzJyIpLCBmaWxlbmFtZSk7Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX21lcmdlX3N0YXRlKHN0cnVjdCBjb21taXRfbGlzdCAqKTsKc3RhdGljIHZvaWQgYWJvcnRfY29tbWl0KHN0cnVjdCBjb21taXRfbGlzdCAqcmVtb3RlaGVhZHMsIGNvbnN0IGNoYXIgKmVycl9tc2cpCnsKCWlmIChlcnJfbXNnKQoJCWVycm9yKCIlcyIsIGVycl9tc2cpOwoJZnByaW50ZihzdGRlcnIsCgkJXygiTm90IGNvbW1pdHRpbmcgbWVyZ2U7IHVzZSAnZ2l0IGNvbW1pdCcgdG8gY29tcGxldGUgdGhlIG1lcmdlLlxuIikpOwoJd3JpdGVfbWVyZ2Vfc3RhdGUocmVtb3RlaGVhZHMpOwoJZXhpdCgxKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgbWVyZ2VfZWRpdG9yX2NvbW1lbnRbXSA9Ck5fKCJQbGVhc2UgZW50ZXIgYSBjb21taXQgbWVzc2FnZSB0byBleHBsYWluIHdoeSB0aGlzIG1lcmdlIGlzIG5lY2Vzc2FyeSxcbiIKICAgImVzcGVjaWFsbHkgaWYgaXQgbWVyZ2VzIGFuIHVwZGF0ZWQgdXBzdHJlYW0gaW50byBhIHRvcGljIGJyYW5jaC5cbiIKICAgIlxuIgogICAiTGluZXMgc3RhcnRpbmcgd2l0aCAnJWMnIHdpbGwgYmUgaWdub3JlZCwgYW5kIGFuIGVtcHR5IG1lc3NhZ2UgYWJvcnRzXG4iCiAgICJ0aGUgY29tbWl0LlxuIik7CgpzdGF0aWMgdm9pZCBwcmVwYXJlX3RvX2NvbW1pdChzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlbW90ZWhlYWRzKQp7CglzdHJ1Y3Qgc3RyYnVmIG1zZyA9IFNUUkJVRl9JTklUOwoJc3RyYnVmX2FkZGJ1ZigmbXNnLCAmbWVyZ2VfbXNnKTsKCXN0cmJ1Zl9hZGRjaCgmbXNnLCAnXG4nKTsKCWlmICgwIDwgb3B0aW9uX2VkaXQpCgkJc3RyYnVmX2NvbW1lbnRlZF9hZGRmKCZtc2csIF8obWVyZ2VfZWRpdG9yX2NvbW1lbnQpLCBjb21tZW50X2xpbmVfY2hhcik7Cgl3cml0ZV9maWxlX2J1ZihnaXRfcGF0aF9tZXJnZV9tc2coKSwgbXNnLmJ1ZiwgbXNnLmxlbik7CglpZiAocnVuX2NvbW1pdF9ob29rKDAgPCBvcHRpb25fZWRpdCwgZ2V0X2luZGV4X2ZpbGUoKSwgInByZXBhcmUtY29tbWl0LW1zZyIsCgkJCSAgICBnaXRfcGF0aF9tZXJnZV9tc2coKSwgIm1lcmdlIiwgTlVMTCkpCgkJYWJvcnRfY29tbWl0KHJlbW90ZWhlYWRzLCBOVUxMKTsKCWlmICgwIDwgb3B0aW9uX2VkaXQpIHsKCQlpZiAobGF1bmNoX2VkaXRvcihnaXRfcGF0aF9tZXJnZV9tc2coKSwgTlVMTCwgTlVMTCkpCgkJCWFib3J0X2NvbW1pdChyZW1vdGVoZWFkcywgTlVMTCk7Cgl9CglyZWFkX21lcmdlX21zZygmbXNnKTsKCXN0cmJ1Zl9zdHJpcHNwYWNlKCZtc2csIDAgPCBvcHRpb25fZWRpdCk7CglpZiAoIW1zZy5sZW4pCgkJYWJvcnRfY29tbWl0KHJlbW90ZWhlYWRzLCBfKCJFbXB0eSBjb21taXQgbWVzc2FnZS4iKSk7CglzdHJidWZfcmVsZWFzZSgmbWVyZ2VfbXNnKTsKCXN0cmJ1Zl9hZGRidWYoJm1lcmdlX21zZywgJm1zZyk7CglzdHJidWZfcmVsZWFzZSgmbXNnKTsKfQoKc3RhdGljIGludCBtZXJnZV90cml2aWFsKHN0cnVjdCBjb21taXQgKmhlYWQsIHN0cnVjdCBjb21taXRfbGlzdCAqcmVtb3RlaGVhZHMpCnsKCXVuc2lnbmVkIGNoYXIgcmVzdWx0X3RyZWVbMjBdLCByZXN1bHRfY29tbWl0WzIwXTsKCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50cywgKipwcHRyID0gJnBhcmVudHM7CglzdGF0aWMgc3RydWN0IGxvY2tfZmlsZSBsb2NrOwoKCWhvbGRfbG9ja2VkX2luZGV4KCZsb2NrLCBMT0NLX0RJRV9PTl9FUlJPUik7CglyZWZyZXNoX2NhY2hlKFJFRlJFU0hfUVVJRVQpOwoJaWYgKGFjdGl2ZV9jYWNoZV9jaGFuZ2VkICYmCgkgICAgd3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZsb2NrLCBDT01NSVRfTE9DSykpCgkJcmV0dXJuIGVycm9yKF8oIlVuYWJsZSB0byB3cml0ZSBpbmRleC4iKSk7Cglyb2xsYmFja19sb2NrX2ZpbGUoJmxvY2spOwoKCXdyaXRlX3RyZWVfdHJpdmlhbChyZXN1bHRfdHJlZSk7CglwcmludGYoXygiV29uZGVyZnVsLlxuIikpOwoJcHB0ciA9IGNvbW1pdF9saXN0X2FwcGVuZChoZWFkLCBwcHRyKTsKCXBwdHIgPSBjb21taXRfbGlzdF9hcHBlbmQocmVtb3RlaGVhZHMtPml0ZW0sIHBwdHIpOwoJcHJlcGFyZV90b19jb21taXQocmVtb3RlaGVhZHMpOwoJaWYgKGNvbW1pdF90cmVlKG1lcmdlX21zZy5idWYsIG1lcmdlX21zZy5sZW4sIHJlc3VsdF90cmVlLCBwYXJlbnRzLAoJCQlyZXN1bHRfY29tbWl0LCBOVUxMLCBzaWduX2NvbW1pdCkpCgkJZGllKF8oImZhaWxlZCB0byB3cml0ZSBjb21taXQgb2JqZWN0IikpOwoJZmluaXNoKGhlYWQsIHJlbW90ZWhlYWRzLCByZXN1bHRfY29tbWl0LCAiSW4taW5kZXggbWVyZ2UiKTsKCWRyb3Bfc2F2ZSgpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZmluaXNoX2F1dG9tZXJnZShzdHJ1Y3QgY29tbWl0ICpoZWFkLAoJCQkgICAgaW50IGhlYWRfc3Vic3VtZWQsCgkJCSAgICBzdHJ1Y3QgY29tbWl0X2xpc3QgKmNvbW1vbiwKCQkJICAgIHN0cnVjdCBjb21taXRfbGlzdCAqcmVtb3RlaGVhZHMsCgkJCSAgICB1bnNpZ25lZCBjaGFyICpyZXN1bHRfdHJlZSwKCQkJICAgIGNvbnN0IGNoYXIgKnd0X3N0cmF0ZWd5KQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMgPSBOVUxMOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCXVuc2lnbmVkIGNoYXIgcmVzdWx0X2NvbW1pdFsyMF07CgoJZnJlZV9jb21taXRfbGlzdChjb21tb24pOwoJcGFyZW50cyA9IHJlbW90ZWhlYWRzOwoJaWYgKCFoZWFkX3N1YnN1bWVkIHx8IGZhc3RfZm9yd2FyZCA9PSBGRl9OTykKCQljb21taXRfbGlzdF9pbnNlcnQoaGVhZCwgJnBhcmVudHMpOwoJc3RyYnVmX2FkZGNoKCZtZXJnZV9tc2csICdcbicpOwoJcHJlcGFyZV90b19jb21taXQocmVtb3RlaGVhZHMpOwoJaWYgKGNvbW1pdF90cmVlKG1lcmdlX21zZy5idWYsIG1lcmdlX21zZy5sZW4sIHJlc3VsdF90cmVlLCBwYXJlbnRzLAoJCQlyZXN1bHRfY29tbWl0LCBOVUxMLCBzaWduX2NvbW1pdCkpCgkJZGllKF8oImZhaWxlZCB0byB3cml0ZSBjb21taXQgb2JqZWN0IikpOwoJc3RyYnVmX2FkZGYoJmJ1ZiwgIk1lcmdlIG1hZGUgYnkgdGhlICclcycgc3RyYXRlZ3kuIiwgd3Rfc3RyYXRlZ3kpOwoJZmluaXNoKGhlYWQsIHJlbW90ZWhlYWRzLCByZXN1bHRfY29tbWl0LCBidWYuYnVmKTsKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJZHJvcF9zYXZlKCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBzdWdnZXN0X2NvbmZsaWN0cyh2b2lkKQp7Cgljb25zdCBjaGFyICpmaWxlbmFtZTsKCUZJTEUgKmZwOwoJc3RydWN0IHN0cmJ1ZiBtc2didWYgPSBTVFJCVUZfSU5JVDsKCglmaWxlbmFtZSA9IGdpdF9wYXRoX21lcmdlX21zZygpOwoJZnAgPSBmb3BlbihmaWxlbmFtZSwgImEiKTsKCWlmICghZnApCgkJZGllX2Vycm5vKF8oIkNvdWxkIG5vdCBvcGVuICclcycgZm9yIHdyaXRpbmciKSwgZmlsZW5hbWUpOwoKCWFwcGVuZF9jb25mbGljdHNfaGludCgmbXNnYnVmKTsKCWZwdXRzKG1zZ2J1Zi5idWYsIGZwKTsKCXN0cmJ1Zl9yZWxlYXNlKCZtc2didWYpOwoJZmNsb3NlKGZwKTsKCXJlcmVyZShhbGxvd19yZXJlcmVfYXV0byk7CglwcmludGYoXygiQXV0b21hdGljIG1lcmdlIGZhaWxlZDsgIgoJCQkiZml4IGNvbmZsaWN0cyBhbmQgdGhlbiBjb21taXQgdGhlIHJlc3VsdC5cbiIpKTsKCXJldHVybiAxOwp9CgpzdGF0aWMgc3RydWN0IGNvbW1pdCAqaXNfb2xkX3N0eWxlX2ludm9jYXRpb24oaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LAoJCQkJCSAgICAgIGNvbnN0IHVuc2lnbmVkIGNoYXIgKmhlYWQpCnsKCXN0cnVjdCBjb21taXQgKnNlY29uZF90b2tlbiA9IE5VTEw7CglpZiAoYXJnYyA+IDIpIHsKCQl1bnNpZ25lZCBjaGFyIHNlY29uZF9zaGExWzIwXTsKCgkJaWYgKGdldF9zaGExKGFyZ3ZbMV0sIHNlY29uZF9zaGExKSkKCQkJcmV0dXJuIE5VTEw7CgkJc2Vjb25kX3Rva2VuID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfZ2VudGx5KHNlY29uZF9zaGExLCAwKTsKCQlpZiAoIXNlY29uZF90b2tlbikKCQkJZGllKF8oIiclcycgaXMgbm90IGEgY29tbWl0IiksIGFyZ3ZbMV0pOwoJCWlmIChoYXNoY21wKHNlY29uZF90b2tlbi0+b2JqZWN0Lm9pZC5oYXNoLCBoZWFkKSkKCQkJcmV0dXJuIE5VTEw7Cgl9CglyZXR1cm4gc2Vjb25kX3Rva2VuOwp9CgpzdGF0aWMgaW50IGV2YWx1YXRlX3Jlc3VsdCh2b2lkKQp7CglpbnQgY250ID0gMDsKCXN0cnVjdCByZXZfaW5mbyByZXY7CgoJLyogQ2hlY2sgaG93IG1hbnkgZmlsZXMgZGlmZmVyLiAqLwoJaW5pdF9yZXZpc2lvbnMoJnJldiwgIiIpOwoJc2V0dXBfcmV2aXNpb25zKDAsIE5VTEwsICZyZXYsIE5VTEwpOwoJcmV2LmRpZmZvcHQub3V0cHV0X2Zvcm1hdCB8PQoJCURJRkZfRk9STUFUX0NBTExCQUNLOwoJcmV2LmRpZmZvcHQuZm9ybWF0X2NhbGxiYWNrID0gY291bnRfZGlmZl9maWxlczsKCXJldi5kaWZmb3B0LmZvcm1hdF9jYWxsYmFja19kYXRhID0gJmNudDsKCXJ1bl9kaWZmX2ZpbGVzKCZyZXYsIDApOwoKCS8qCgkgKiBDaGVjayBob3cgbWFueSB1bm1lcmdlZCBlbnRyaWVzIGFyZQoJICogdGhlcmUuCgkgKi8KCWNudCArPSBjb3VudF91bm1lcmdlZF9lbnRyaWVzKCk7CgoJcmV0dXJuIGNudDsKfQoKLyoKICogUHJldGVuZCBhcyBpZiB0aGUgdXNlciB0b2xkIHVzIHRvIG1lcmdlIHdpdGggdGhlIHJlbW90ZS10cmFja2luZwogKiBicmFuY2ggd2UgaGF2ZSBmb3IgdGhlIHVwc3RyZWFtIG9mIHRoZSBjdXJyZW50IGJyYW5jaAogKi8Kc3RhdGljIGludCBzZXR1cF93aXRoX3Vwc3RyZWFtKGNvbnN0IGNoYXIgKioqYXJndikKewoJc3RydWN0IGJyYW5jaCAqYnJhbmNoID0gYnJhbmNoX2dldChOVUxMKTsKCWludCBpOwoJY29uc3QgY2hhciAqKmFyZ3M7CgoJaWYgKCFicmFuY2gpCgkJZGllKF8oIk5vIGN1cnJlbnQgYnJhbmNoLiIpKTsKCWlmICghYnJhbmNoLT5yZW1vdGVfbmFtZSkKCQlkaWUoXygiTm8gcmVtb3RlIGZvciB0aGUgY3VycmVudCBicmFuY2guIikpOwoJaWYgKCFicmFuY2gtPm1lcmdlX25yKQoJCWRpZShfKCJObyBkZWZhdWx0IHVwc3RyZWFtIGRlZmluZWQgZm9yIHRoZSBjdXJyZW50IGJyYW5jaC4iKSk7CgoJYXJncyA9IHhjYWxsb2Moc3RfYWRkKGJyYW5jaC0+bWVyZ2VfbnIsIDEpLCBzaXplb2YoY2hhciAqKSk7Cglmb3IgKGkgPSAwOyBpIDwgYnJhbmNoLT5tZXJnZV9ucjsgaSsrKSB7CgkJaWYgKCFicmFuY2gtPm1lcmdlW2ldLT5kc3QpCgkJCWRpZShfKCJObyByZW1vdGUtdHJhY2tpbmcgYnJhbmNoIGZvciAlcyBmcm9tICVzIiksCgkJCSAgICBicmFuY2gtPm1lcmdlW2ldLT5zcmMsIGJyYW5jaC0+cmVtb3RlX25hbWUpOwoJCWFyZ3NbaV0gPSBicmFuY2gtPm1lcmdlW2ldLT5kc3Q7Cgl9CglhcmdzW2ldID0gTlVMTDsKCSphcmd2ID0gYXJnczsKCXJldHVybiBpOwp9CgpzdGF0aWMgdm9pZCB3cml0ZV9tZXJnZV9zdGF0ZShzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlbW90ZWhlYWRzKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKmo7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoKCWZvciAoaiA9IHJlbW90ZWhlYWRzOyBqOyBqID0gai0+bmV4dCkgewoJCXN0cnVjdCBvYmplY3RfaWQgKm9pZDsKCQlzdHJ1Y3QgY29tbWl0ICpjID0gai0+aXRlbTsKCQlpZiAoYy0+dXRpbCAmJiBtZXJnZV9yZW1vdGVfdXRpbChjKS0+b2JqKSB7CgkJCW9pZCA9ICZtZXJnZV9yZW1vdGVfdXRpbChjKS0+b2JqLT5vaWQ7CgkJfSBlbHNlIHsKCQkJb2lkID0gJmMtPm9iamVjdC5vaWQ7CgkJfQoJCXN0cmJ1Zl9hZGRmKCZidWYsICIlc1xuIiwgb2lkX3RvX2hleChvaWQpKTsKCX0KCXdyaXRlX2ZpbGVfYnVmKGdpdF9wYXRoX21lcmdlX2hlYWQoKSwgYnVmLmJ1ZiwgYnVmLmxlbik7CglzdHJidWZfYWRkY2goJm1lcmdlX21zZywgJ1xuJyk7Cgl3cml0ZV9maWxlX2J1ZihnaXRfcGF0aF9tZXJnZV9tc2coKSwgbWVyZ2VfbXNnLmJ1ZiwgbWVyZ2VfbXNnLmxlbik7CgoJc3RyYnVmX3Jlc2V0KCZidWYpOwoJaWYgKGZhc3RfZm9yd2FyZCA9PSBGRl9OTykKCQlzdHJidWZfYWRkc3RyKCZidWYsICJuby1mZiIpOwoJd3JpdGVfZmlsZV9idWYoZ2l0X3BhdGhfbWVyZ2VfbW9kZSgpLCBidWYuYnVmLCBidWYubGVuKTsKfQoKc3RhdGljIGludCBkZWZhdWx0X2VkaXRfb3B0aW9uKHZvaWQpCnsKCXN0YXRpYyBjb25zdCBjaGFyIG5hbWVbXSA9ICJHSVRfTUVSR0VfQVVUT0VESVQiOwoJY29uc3QgY2hhciAqZSA9IGdldGVudihuYW1lKTsKCXN0cnVjdCBzdGF0IHN0X3N0ZGluLCBzdF9zdGRvdXQ7CgoJaWYgKGhhdmVfbWVzc2FnZSkKCQkvKiBhbiBleHBsaWNpdCAtbSBtc2cgd2l0aG91dCAtLVtuby1dZWRpdCAqLwoJCXJldHVybiAwOwoKCWlmIChlKSB7CgkJaW50IHYgPSBnaXRfY29uZmlnX21heWJlX2Jvb2wobmFtZSwgZSk7CgkJaWYgKHYgPCAwKQoJCQlkaWUoXygiQmFkIHZhbHVlICclcycgaW4gZW52aXJvbm1lbnQgJyVzJyIpLCBlLCBuYW1lKTsKCQlyZXR1cm4gdjsKCX0KCgkvKiBVc2UgZWRpdG9yIGlmIHN0ZGluIGFuZCBzdGRvdXQgYXJlIHRoZSBzYW1lIGFuZCBpcyBhIHR0eSAqLwoJcmV0dXJuICghZnN0YXQoMCwgJnN0X3N0ZGluKSAmJgoJCSFmc3RhdCgxLCAmc3Rfc3Rkb3V0KSAmJgoJCWlzYXR0eSgwKSAmJiBpc2F0dHkoMSkgJiYKCQlzdF9zdGRpbi5zdF9kZXYgPT0gc3Rfc3Rkb3V0LnN0X2RldiAmJgoJCXN0X3N0ZGluLnN0X2lubyA9PSBzdF9zdGRvdXQuc3RfaW5vICYmCgkJc3Rfc3RkaW4uc3RfbW9kZSA9PSBzdF9zdGRvdXQuc3RfbW9kZSk7Cn0KCnN0YXRpYyBzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlZHVjZV9wYXJlbnRzKHN0cnVjdCBjb21taXQgKmhlYWRfY29tbWl0LAoJCQkJCSAgaW50ICpoZWFkX3N1YnN1bWVkLAoJCQkJCSAgc3RydWN0IGNvbW1pdF9saXN0ICpyZW1vdGVoZWFkcykKewoJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzLCAqKnJlbW90ZXM7CgoJLyoKCSAqIElzIHRoZSBjdXJyZW50IEhFQUQgcmVhY2hhYmxlIGZyb20gYW5vdGhlciBjb21taXQgYmVpbmcKCSAqIG1lcmdlZD8gIElmIHNvIHdlIGRvIG5vdCB3YW50IHRvIHJlY29yZCBpdCBhcyBhIHBhcmVudCBvZgoJICogdGhlIHJlc3VsdGluZyBtZXJnZSwgdW5sZXNzIC0tbm8tZmYgaXMgZ2l2ZW4uICBXZSB3aWxsIGZsaXAKCSAqIHRoaXMgdmFyaWFibGUgdG8gMCB3aGVuIHdlIGZpbmQgSEVBRCBhbW9uZyB0aGUgaW5kZXBlbmRlbnQKCSAqIHRpcHMgYmVpbmcgbWVyZ2VkLgoJICovCgkqaGVhZF9zdWJzdW1lZCA9IDE7CgoJLyogRmluZCB3aGF0IHBhcmVudHMgdG8gcmVjb3JkIGJ5IGNoZWNraW5nIGluZGVwZW5kZW50IG9uZXMuICovCglwYXJlbnRzID0gcmVkdWNlX2hlYWRzKHJlbW90ZWhlYWRzKTsKCglyZW1vdGVoZWFkcyA9IE5VTEw7CglyZW1vdGVzID0gJnJlbW90ZWhlYWRzOwoJd2hpbGUgKHBhcmVudHMpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBwb3BfY29tbWl0KCZwYXJlbnRzKTsKCQlpZiAoY29tbWl0ID09IGhlYWRfY29tbWl0KQoJCQkqaGVhZF9zdWJzdW1lZCA9IDA7CgkJZWxzZQoJCQlyZW1vdGVzID0gJmNvbW1pdF9saXN0X2luc2VydChjb21taXQsIHJlbW90ZXMpLT5uZXh0OwoJfQoJcmV0dXJuIHJlbW90ZWhlYWRzOwp9CgpzdGF0aWMgdm9pZCBwcmVwYXJlX21lcmdlX21lc3NhZ2Uoc3RydWN0IHN0cmJ1ZiAqbWVyZ2VfbmFtZXMsIHN0cnVjdCBzdHJidWYgKm1lcmdlX21zZykKewoJc3RydWN0IGZtdF9tZXJnZV9tc2dfb3B0cyBvcHRzOwoKCW1lbXNldCgmb3B0cywgMCwgc2l6ZW9mKG9wdHMpKTsKCW9wdHMuYWRkX3RpdGxlID0gIWhhdmVfbWVzc2FnZTsKCW9wdHMuc2hvcnRsb2dfbGVuID0gc2hvcnRsb2dfbGVuOwoJb3B0cy5jcmVkaXRfcGVvcGxlID0gKDAgPCBvcHRpb25fZWRpdCk7CgoJZm10X21lcmdlX21zZyhtZXJnZV9uYW1lcywgbWVyZ2VfbXNnLCAmb3B0cyk7CglpZiAobWVyZ2VfbXNnLT5sZW4pCgkJc3RyYnVmX3NldGxlbihtZXJnZV9tc2csIG1lcmdlX21zZy0+bGVuIC0gMSk7Cn0KCnN0YXRpYyB2b2lkIGhhbmRsZV9mZXRjaF9oZWFkKHN0cnVjdCBjb21taXRfbGlzdCAqKnJlbW90ZXMsIHN0cnVjdCBzdHJidWYgKm1lcmdlX25hbWVzKQp7Cgljb25zdCBjaGFyICpmaWxlbmFtZTsKCWludCBmZCwgcG9zLCBucG9zOwoJc3RydWN0IHN0cmJ1ZiBmZXRjaF9oZWFkX2ZpbGUgPSBTVFJCVUZfSU5JVDsKCglpZiAoIW1lcmdlX25hbWVzKQoJCW1lcmdlX25hbWVzID0gJmZldGNoX2hlYWRfZmlsZTsKCglmaWxlbmFtZSA9IGdpdF9wYXRoX2ZldGNoX2hlYWQoKTsKCWZkID0gb3BlbihmaWxlbmFtZSwgT19SRE9OTFkpOwoJaWYgKGZkIDwgMCkKCQlkaWVfZXJybm8oXygiY291bGQgbm90IG9wZW4gJyVzJyBmb3IgcmVhZGluZyIpLCBmaWxlbmFtZSk7CgoJaWYgKHN0cmJ1Zl9yZWFkKG1lcmdlX25hbWVzLCBmZCwgMCkgPCAwKQoJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgcmVhZCAnJXMnIiksIGZpbGVuYW1lKTsKCWlmIChjbG9zZShmZCkgPCAwKQoJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgY2xvc2UgJyVzJyIpLCBmaWxlbmFtZSk7CgoJZm9yIChwb3MgPSAwOyBwb3MgPCBtZXJnZV9uYW1lcy0+bGVuOyBwb3MgPSBucG9zKSB7CgkJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCQljaGFyICpwdHI7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoKCQlwdHIgPSBzdHJjaHIobWVyZ2VfbmFtZXMtPmJ1ZiArIHBvcywgJ1xuJyk7CgkJaWYgKHB0cikKCQkJbnBvcyA9IHB0ciAtIG1lcmdlX25hbWVzLT5idWYgKyAxOwoJCWVsc2UKCQkJbnBvcyA9IG1lcmdlX25hbWVzLT5sZW47CgoJCWlmIChucG9zIC0gcG9zIDwgNDAgKyAyIHx8CgkJICAgIGdldF9zaGExX2hleChtZXJnZV9uYW1lcy0+YnVmICsgcG9zLCBzaGExKSkKCQkJY29tbWl0ID0gTlVMTDsgLyogYmFkICovCgkJZWxzZSBpZiAobWVtY21wKG1lcmdlX25hbWVzLT5idWYgKyBwb3MgKyA0MCwgIlx0XHQiLCAyKSkKCQkJY29udGludWU7IC8qIG5vdC1mb3ItbWVyZ2UgKi8KCQllbHNlIHsKCQkJY2hhciBzYXZlZCA9IG1lcmdlX25hbWVzLT5idWZbcG9zICsgNDBdOwoJCQltZXJnZV9uYW1lcy0+YnVmW3BvcyArIDQwXSA9ICdcMCc7CgkJCWNvbW1pdCA9IGdldF9tZXJnZV9wYXJlbnQobWVyZ2VfbmFtZXMtPmJ1ZiArIHBvcyk7CgkJCW1lcmdlX25hbWVzLT5idWZbcG9zICsgNDBdID0gc2F2ZWQ7CgkJfQoJCWlmICghY29tbWl0KSB7CgkJCWlmIChwdHIpCgkJCQkqcHRyID0gJ1wwJzsKCQkJZGllKF8oIm5vdCBzb21ldGhpbmcgd2UgY2FuIG1lcmdlIGluICVzOiAlcyIpLAoJCQkgICAgZmlsZW5hbWUsIG1lcmdlX25hbWVzLT5idWYgKyBwb3MpOwoJCX0KCQlyZW1vdGVzID0gJmNvbW1pdF9saXN0X2luc2VydChjb21taXQsIHJlbW90ZXMpLT5uZXh0OwoJfQoKCWlmIChtZXJnZV9uYW1lcyA9PSAmZmV0Y2hfaGVhZF9maWxlKQoJCXN0cmJ1Zl9yZWxlYXNlKCZmZXRjaF9oZWFkX2ZpbGUpOwp9CgpzdGF0aWMgc3RydWN0IGNvbW1pdF9saXN0ICpjb2xsZWN0X3BhcmVudHMoc3RydWN0IGNvbW1pdCAqaGVhZF9jb21taXQsCgkJCQkJICAgaW50ICpoZWFkX3N1YnN1bWVkLAoJCQkJCSAgIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwKCQkJCQkgICBzdHJ1Y3Qgc3RyYnVmICptZXJnZV9tc2cpCnsKCWludCBpOwoJc3RydWN0IGNvbW1pdF9saXN0ICpyZW1vdGVoZWFkcyA9IE5VTEw7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKipyZW1vdGVzID0gJnJlbW90ZWhlYWRzOwoJc3RydWN0IHN0cmJ1ZiBtZXJnZV9uYW1lcyA9IFNUUkJVRl9JTklULCAqYXV0b2dlbiA9IE5VTEw7CgoJaWYgKG1lcmdlX21zZyAmJiAoIWhhdmVfbWVzc2FnZSB8fCBzaG9ydGxvZ19sZW4pKQoJCWF1dG9nZW4gPSAmbWVyZ2VfbmFtZXM7CgoJaWYgKGhlYWRfY29tbWl0KQoJCXJlbW90ZXMgPSAmY29tbWl0X2xpc3RfaW5zZXJ0KGhlYWRfY29tbWl0LCByZW1vdGVzKS0+bmV4dDsKCglpZiAoYXJnYyA9PSAxICYmICFzdHJjbXAoYXJndlswXSwgIkZFVENIX0hFQUQiKSkgewoJCWhhbmRsZV9mZXRjaF9oZWFkKHJlbW90ZXMsIGF1dG9nZW4pOwoJCXJlbW90ZWhlYWRzID0gcmVkdWNlX3BhcmVudHMoaGVhZF9jb21taXQsIGhlYWRfc3Vic3VtZWQsIHJlbW90ZWhlYWRzKTsKCX0gZWxzZSB7CgkJZm9yIChpID0gMDsgaSA8IGFyZ2M7IGkrKykgewoJCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBnZXRfbWVyZ2VfcGFyZW50KGFyZ3ZbaV0pOwoJCQlpZiAoIWNvbW1pdCkKCQkJCWhlbHBfdW5rbm93bl9yZWYoYXJndltpXSwgIm1lcmdlIiwKCQkJCQkJIF8oIm5vdCBzb21ldGhpbmcgd2UgY2FuIG1lcmdlIikpOwoJCQlyZW1vdGVzID0gJmNvbW1pdF9saXN0X2luc2VydChjb21taXQsIHJlbW90ZXMpLT5uZXh0OwoJCX0KCQlyZW1vdGVoZWFkcyA9IHJlZHVjZV9wYXJlbnRzKGhlYWRfY29tbWl0LCBoZWFkX3N1YnN1bWVkLCByZW1vdGVoZWFkcyk7CgkJaWYgKGF1dG9nZW4pIHsKCQkJc3RydWN0IGNvbW1pdF9saXN0ICpwOwoJCQlmb3IgKHAgPSByZW1vdGVoZWFkczsgcDsgcCA9IHAtPm5leHQpCgkJCQltZXJnZV9uYW1lKG1lcmdlX3JlbW90ZV91dGlsKHAtPml0ZW0pLT5uYW1lLCBhdXRvZ2VuKTsKCQl9Cgl9CgoJaWYgKGF1dG9nZW4pIHsKCQlwcmVwYXJlX21lcmdlX21lc3NhZ2UoYXV0b2dlbiwgbWVyZ2VfbXNnKTsKCQlzdHJidWZfcmVsZWFzZShhdXRvZ2VuKTsKCX0KCglyZXR1cm4gcmVtb3RlaGVhZHM7Cn0KCmludCBjbWRfbWVyZ2UoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXVuc2lnbmVkIGNoYXIgcmVzdWx0X3RyZWVbMjBdOwoJdW5zaWduZWQgY2hhciBzdGFzaFsyMF07Cgl1bnNpZ25lZCBjaGFyIGhlYWRfc2hhMVsyMF07CglzdHJ1Y3QgY29tbWl0ICpoZWFkX2NvbW1pdDsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpoZWFkX2FyZzsKCWludCBpLCByZXQgPSAwLCBoZWFkX3N1YnN1bWVkOwoJaW50IGJlc3RfY250ID0gLTEsIG1lcmdlX3dhc19vayA9IDAsIGF1dG9tZXJnZV93YXNfb2sgPSAwOwoJc3RydWN0IGNvbW1pdF9saXN0ICpjb21tb24gPSBOVUxMOwoJY29uc3QgY2hhciAqYmVzdF9zdHJhdGVneSA9IE5VTEwsICp3dF9zdHJhdGVneSA9IE5VTEw7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlbW90ZWhlYWRzLCAqcDsKCXZvaWQgKmJyYW5jaF90b19mcmVlOwoKCWlmIChhcmdjID09IDIgJiYgIXN0cmNtcChhcmd2WzFdLCAiLWgiKSkKCQl1c2FnZV93aXRoX29wdGlvbnMoYnVpbHRpbl9tZXJnZV91c2FnZSwgYnVpbHRpbl9tZXJnZV9vcHRpb25zKTsKCgkvKgoJICogQ2hlY2sgaWYgd2UgYXJlIF9ub3RfIG9uIGEgZGV0YWNoZWQgSEVBRCwgaS5lLiBpZiB0aGVyZSBpcyBhCgkgKiBjdXJyZW50IGJyYW5jaC4KCSAqLwoJYnJhbmNoID0gYnJhbmNoX3RvX2ZyZWUgPSByZXNvbHZlX3JlZmR1cCgiSEVBRCIsIDAsIGhlYWRfc2hhMSwgTlVMTCk7CglpZiAoYnJhbmNoICYmIHN0YXJ0c193aXRoKGJyYW5jaCwgInJlZnMvaGVhZHMvIikpCgkJYnJhbmNoICs9IDExOwoJaWYgKCFicmFuY2ggfHwgaXNfbnVsbF9zaGExKGhlYWRfc2hhMSkpCgkJaGVhZF9jb21taXQgPSBOVUxMOwoJZWxzZQoJCWhlYWRfY29tbWl0ID0gbG9va3VwX2NvbW1pdF9vcl9kaWUoaGVhZF9zaGExLCAiSEVBRCIpOwoKCWluaXRfZGlmZl91aV9kZWZhdWx0cygpOwoJZ2l0X2NvbmZpZyhnaXRfbWVyZ2VfY29uZmlnLCBOVUxMKTsKCglpZiAoYnJhbmNoX21lcmdlb3B0aW9ucykKCQlwYXJzZV9icmFuY2hfbWVyZ2Vfb3B0aW9ucyhicmFuY2hfbWVyZ2VvcHRpb25zKTsKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgYnVpbHRpbl9tZXJnZV9vcHRpb25zLAoJCQlidWlsdGluX21lcmdlX3VzYWdlLCAwKTsKCWlmIChzaG9ydGxvZ19sZW4gPCAwKQoJCXNob3J0bG9nX2xlbiA9IChtZXJnZV9sb2dfY29uZmlnID4gMCkgPyBtZXJnZV9sb2dfY29uZmlnIDogMDsKCglpZiAodmVyYm9zaXR5IDwgMCAmJiBzaG93X3Byb2dyZXNzID09IC0xKQoJCXNob3dfcHJvZ3Jlc3MgPSAwOwoKCWlmIChhYm9ydF9jdXJyZW50X21lcmdlKSB7CgkJaW50IG5hcmdjID0gMjsKCQljb25zdCBjaGFyICpuYXJndltdID0geyJyZXNldCIsICItLW1lcmdlIiwgTlVMTH07CgoJCWlmICghZmlsZV9leGlzdHMoZ2l0X3BhdGhfbWVyZ2VfaGVhZCgpKSkKCQkJZGllKF8oIlRoZXJlIGlzIG5vIG1lcmdlIHRvIGFib3J0IChNRVJHRV9IRUFEIG1pc3NpbmcpLiIpKTsKCgkJLyogSW52b2tlICdnaXQgcmVzZXQgLS1tZXJnZScgKi8KCQlyZXQgPSBjbWRfcmVzZXQobmFyZ2MsIG5hcmd2LCBwcmVmaXgpOwoJCWdvdG8gZG9uZTsKCX0KCglpZiAocmVhZF9jYWNoZV91bm1lcmdlZCgpKQoJCWRpZV9yZXNvbHZlX2NvbmZsaWN0KCJtZXJnZSIpOwoKCWlmIChmaWxlX2V4aXN0cyhnaXRfcGF0aF9tZXJnZV9oZWFkKCkpKSB7CgkJLyoKCQkgKiBUaGVyZSBpcyBubyB1bm1lcmdlZCBlbnRyeSwgZG9uJ3QgYWR2aXNlICdnaXQKCQkgKiBhZGQvcm0gPGZpbGU+JywganVzdCAnZ2l0IGNvbW1pdCcuCgkJICovCgkJaWYgKGFkdmljZV9yZXNvbHZlX2NvbmZsaWN0KQoJCQlkaWUoXygiWW91IGhhdmUgbm90IGNvbmNsdWRlZCB5b3VyIG1lcmdlIChNRVJHRV9IRUFEIGV4aXN0cykuXG4iCgkJCQkgICJQbGVhc2UsIGNvbW1pdCB5b3VyIGNoYW5nZXMgYmVmb3JlIHlvdSBtZXJnZS4iKSk7CgkJZWxzZQoJCQlkaWUoXygiWW91IGhhdmUgbm90IGNvbmNsdWRlZCB5b3VyIG1lcmdlIChNRVJHRV9IRUFEIGV4aXN0cykuIikpOwoJfQoJaWYgKGZpbGVfZXhpc3RzKGdpdF9wYXRoX2NoZXJyeV9waWNrX2hlYWQoKSkpIHsKCQlpZiAoYWR2aWNlX3Jlc29sdmVfY29uZmxpY3QpCgkJCWRpZShfKCJZb3UgaGF2ZSBub3QgY29uY2x1ZGVkIHlvdXIgY2hlcnJ5LXBpY2sgKENIRVJSWV9QSUNLX0hFQUQgZXhpc3RzKS5cbiIKCQkJICAgICJQbGVhc2UsIGNvbW1pdCB5b3VyIGNoYW5nZXMgYmVmb3JlIHlvdSBtZXJnZS4iKSk7CgkJZWxzZQoJCQlkaWUoXygiWW91IGhhdmUgbm90IGNvbmNsdWRlZCB5b3VyIGNoZXJyeS1waWNrIChDSEVSUllfUElDS19IRUFEIGV4aXN0cykuIikpOwoJfQoJcmVzb2x2ZV91bmRvX2NsZWFyKCk7CgoJaWYgKHZlcmJvc2l0eSA8IDApCgkJc2hvd19kaWZmc3RhdCA9IDA7CgoJaWYgKHNxdWFzaCkgewoJCWlmIChmYXN0X2ZvcndhcmQgPT0gRkZfTk8pCgkJCWRpZShfKCJZb3UgY2Fubm90IGNvbWJpbmUgLS1zcXVhc2ggd2l0aCAtLW5vLWZmLiIpKTsKCQlvcHRpb25fY29tbWl0ID0gMDsKCX0KCglpZiAoIWFyZ2MpIHsKCQlpZiAoZGVmYXVsdF90b191cHN0cmVhbSkKCQkJYXJnYyA9IHNldHVwX3dpdGhfdXBzdHJlYW0oJmFyZ3YpOwoJCWVsc2UKCQkJZGllKF8oIk5vIGNvbW1pdCBzcGVjaWZpZWQgYW5kIG1lcmdlLmRlZmF1bHRUb1Vwc3RyZWFtIG5vdCBzZXQuIikpOwoJfSBlbHNlIGlmIChhcmdjID09IDEgJiYgIXN0cmNtcChhcmd2WzBdLCAiLSIpKSB7CgkJYXJndlswXSA9ICJAey0xfSI7Cgl9CgoJaWYgKCFhcmdjKQoJCXVzYWdlX3dpdGhfb3B0aW9ucyhidWlsdGluX21lcmdlX3VzYWdlLAoJCQlidWlsdGluX21lcmdlX29wdGlvbnMpOwoKCWlmICghaGVhZF9jb21taXQpIHsKCQkvKgoJCSAqIElmIHRoZSBtZXJnZWQgaGVhZCBpcyBhIHZhbGlkIG9uZSB0aGVyZSBpcyBubyByZWFzb24KCQkgKiB0byBmb3JiaWQgImdpdCBtZXJnZSIgaW50byBhIGJyYW5jaCB5ZXQgdG8gYmUgYm9ybi4KCQkgKiBXZSBkbyB0aGUgc2FtZSBmb3IgImdpdCBwdWxsIi4KCQkgKi8KCQl1bnNpZ25lZCBjaGFyICpyZW1vdGVfaGVhZF9zaGExOwoJCWlmIChzcXVhc2gpCgkJCWRpZShfKCJTcXVhc2ggY29tbWl0IGludG8gZW1wdHkgaGVhZCBub3Qgc3VwcG9ydGVkIHlldCIpKTsKCQlpZiAoZmFzdF9mb3J3YXJkID09IEZGX05PKQoJCQlkaWUoXygiTm9uLWZhc3QtZm9yd2FyZCBjb21taXQgZG9lcyBub3QgbWFrZSBzZW5zZSBpbnRvICIKCQkJICAgICJhbiBlbXB0eSBoZWFkIikpOwoJCXJlbW90ZWhlYWRzID0gY29sbGVjdF9wYXJlbnRzKGhlYWRfY29tbWl0LCAmaGVhZF9zdWJzdW1lZCwKCQkJCQkgICAgICBhcmdjLCBhcmd2LCBOVUxMKTsKCQlpZiAoIXJlbW90ZWhlYWRzKQoJCQlkaWUoXygiJXMgLSBub3Qgc29tZXRoaW5nIHdlIGNhbiBtZXJnZSIpLCBhcmd2WzBdKTsKCQlpZiAocmVtb3RlaGVhZHMtPm5leHQpCgkJCWRpZShfKCJDYW4gbWVyZ2Ugb25seSBleGFjdGx5IG9uZSBjb21taXQgaW50byBlbXB0eSBoZWFkIikpOwoJCXJlbW90ZV9oZWFkX3NoYTEgPSByZW1vdGVoZWFkcy0+aXRlbS0+b2JqZWN0Lm9pZC5oYXNoOwoJCXJlYWRfZW1wdHkocmVtb3RlX2hlYWRfc2hhMSwgMCk7CgkJdXBkYXRlX3JlZigiaW5pdGlhbCBwdWxsIiwgIkhFQUQiLCByZW1vdGVfaGVhZF9zaGExLAoJCQkgICBOVUxMLCAwLCBVUERBVEVfUkVGU19ESUVfT05fRVJSKTsKCQlnb3RvIGRvbmU7Cgl9CgoJLyoKCSAqIFRoaXMgY291bGQgYmUgdHJhZGl0aW9uYWwgIm1lcmdlIDxtc2c+IEhFQUQgPGNvbW1pdD4uLi4iICBhbmQKCSAqIHRoZSB3YXkgd2UgY2FuIHRlbGwgaXQgaXMgdG8gc2VlIGlmIHRoZSBzZWNvbmQgdG9rZW4gaXMgSEVBRCwKCSAqIGJ1dCBzb21lIHBlb3BsZSBtaWdodCBoYXZlIG1pc3VzZWQgdGhlIGludGVyZmFjZSBhbmQgdXNlZCBhCgkgKiBjb21taXQtaXNoIHRoYXQgaXMgdGhlIHNhbWUgYXMgSEVBRCB0aGVyZSBpbnN0ZWFkLgoJICogVHJhZGl0aW9uYWwgZm9ybWF0IG5ldmVyIHdvdWxkIGhhdmUgIi1tIiBzbyBpdCBpcyBhbgoJICogYWRkaXRpb25hbCBzYWZldHkgbWVhc3VyZSB0byBjaGVjayBmb3IgaXQuCgkgKi8KCWlmICghaGF2ZV9tZXNzYWdlICYmCgkgICAgaXNfb2xkX3N0eWxlX2ludm9jYXRpb24oYXJnYywgYXJndiwgaGVhZF9jb21taXQtPm9iamVjdC5vaWQuaGFzaCkpIHsKCQl3YXJuaW5nKCJvbGQtc3R5bGUgJ2dpdCBtZXJnZSA8bXNnPiBIRUFEIDxjb21taXQ+JyBpcyBkZXByZWNhdGVkLiIpOwoJCXN0cmJ1Zl9hZGRzdHIoJm1lcmdlX21zZywgYXJndlswXSk7CgkJaGVhZF9hcmcgPSBhcmd2WzFdOwoJCWFyZ3YgKz0gMjsKCQlhcmdjIC09IDI7CgkJcmVtb3RlaGVhZHMgPSBjb2xsZWN0X3BhcmVudHMoaGVhZF9jb21taXQsICZoZWFkX3N1YnN1bWVkLAoJCQkJCSAgICAgIGFyZ2MsIGFyZ3YsIE5VTEwpOwoJfSBlbHNlIHsKCQkvKiBXZSBhcmUgaW52b2tlZCBkaXJlY3RseSBhcyB0aGUgZmlyc3QtY2xhc3MgVUkuICovCgkJaGVhZF9hcmcgPSAiSEVBRCI7CgoJCS8qCgkJICogQWxsIHRoZSByZXN0IGFyZSB0aGUgY29tbWl0cyBiZWluZyBtZXJnZWQ7IHByZXBhcmUKCQkgKiB0aGUgc3RhbmRhcmQgbWVyZ2Ugc3VtbWFyeSBtZXNzYWdlIHRvIGJlIGFwcGVuZGVkCgkJICogdG8gdGhlIGdpdmVuIG1lc3NhZ2UuCgkJICovCgkJcmVtb3RlaGVhZHMgPSBjb2xsZWN0X3BhcmVudHMoaGVhZF9jb21taXQsICZoZWFkX3N1YnN1bWVkLAoJCQkJCSAgICAgIGFyZ2MsIGFyZ3YsICZtZXJnZV9tc2cpOwoJfQoKCWlmICghaGVhZF9jb21taXQgfHwgIWFyZ2MpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGJ1aWx0aW5fbWVyZ2VfdXNhZ2UsCgkJCWJ1aWx0aW5fbWVyZ2Vfb3B0aW9ucyk7CgoJaWYgKHZlcmlmeV9zaWduYXR1cmVzKSB7CgkJZm9yIChwID0gcmVtb3RlaGVhZHM7IHA7IHAgPSBwLT5uZXh0KSB7CgkJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IHAtPml0ZW07CgkJCWNoYXIgaGV4W0dJVF9TSEExX0hFWFNaICsgMV07CgkJCXN0cnVjdCBzaWduYXR1cmVfY2hlY2sgc2lnbmF0dXJlX2NoZWNrOwoJCQltZW1zZXQoJnNpZ25hdHVyZV9jaGVjaywgMCwgc2l6ZW9mKHNpZ25hdHVyZV9jaGVjaykpOwoKCQkJY2hlY2tfY29tbWl0X3NpZ25hdHVyZShjb21taXQsICZzaWduYXR1cmVfY2hlY2spOwoKCQkJZmluZF91bmlxdWVfYWJicmV2X3IoaGV4LCBjb21taXQtPm9iamVjdC5vaWQuaGFzaCwgREVGQVVMVF9BQkJSRVYpOwoJCQlzd2l0Y2ggKHNpZ25hdHVyZV9jaGVjay5yZXN1bHQpIHsKCQkJY2FzZSAnRyc6CgkJCQlicmVhazsKCQkJY2FzZSAnVSc6CgkJCQlkaWUoXygiQ29tbWl0ICVzIGhhcyBhbiB1bnRydXN0ZWQgR1BHIHNpZ25hdHVyZSwgIgoJCQkJICAgICAgImFsbGVnZWRseSBieSAlcy4iKSwgaGV4LCBzaWduYXR1cmVfY2hlY2suc2lnbmVyKTsKCQkJY2FzZSAnQic6CgkJCQlkaWUoXygiQ29tbWl0ICVzIGhhcyBhIGJhZCBHUEcgc2lnbmF0dXJlICIKCQkJCSAgICAgICJhbGxlZ2VkbHkgYnkgJXMuIiksIGhleCwgc2lnbmF0dXJlX2NoZWNrLnNpZ25lcik7CgkJCWRlZmF1bHQ6IC8qICdOJyAqLwoJCQkJZGllKF8oIkNvbW1pdCAlcyBkb2VzIG5vdCBoYXZlIGEgR1BHIHNpZ25hdHVyZS4iKSwgaGV4KTsKCQkJfQoJCQlpZiAodmVyYm9zaXR5ID49IDAgJiYgc2lnbmF0dXJlX2NoZWNrLnJlc3VsdCA9PSAnRycpCgkJCQlwcmludGYoXygiQ29tbWl0ICVzIGhhcyBhIGdvb2QgR1BHIHNpZ25hdHVyZSBieSAlc1xuIiksCgkJCQkgICAgICAgaGV4LCBzaWduYXR1cmVfY2hlY2suc2lnbmVyKTsKCgkJCXNpZ25hdHVyZV9jaGVja19jbGVhcigmc2lnbmF0dXJlX2NoZWNrKTsKCQl9Cgl9CgoJc3RyYnVmX2FkZHN0cigmYnVmLCAibWVyZ2UiKTsKCWZvciAocCA9IHJlbW90ZWhlYWRzOyBwOyBwID0gcC0+bmV4dCkKCQlzdHJidWZfYWRkZigmYnVmLCAiICVzIiwgbWVyZ2VfcmVtb3RlX3V0aWwocC0+aXRlbSktPm5hbWUpOwoJc2V0ZW52KCJHSVRfUkVGTE9HX0FDVElPTiIsIGJ1Zi5idWYsIDApOwoJc3RyYnVmX3Jlc2V0KCZidWYpOwoKCWZvciAocCA9IHJlbW90ZWhlYWRzOyBwOyBwID0gcC0+bmV4dCkgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IHAtPml0ZW07CgkJc3RyYnVmX2FkZGYoJmJ1ZiwgIkdJVEhFQURfJXMiLAoJCQkgICAgb2lkX3RvX2hleCgmY29tbWl0LT5vYmplY3Qub2lkKSk7CgkJc2V0ZW52KGJ1Zi5idWYsIG1lcmdlX3JlbW90ZV91dGlsKGNvbW1pdCktPm5hbWUsIDEpOwoJCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCQlpZiAoZmFzdF9mb3J3YXJkICE9IEZGX09OTFkgJiYKCQkgICAgbWVyZ2VfcmVtb3RlX3V0aWwoY29tbWl0KSAmJgoJCSAgICBtZXJnZV9yZW1vdGVfdXRpbChjb21taXQpLT5vYmogJiYKCQkgICAgbWVyZ2VfcmVtb3RlX3V0aWwoY29tbWl0KS0+b2JqLT50eXBlID09IE9CSl9UQUcpCgkJCWZhc3RfZm9yd2FyZCA9IEZGX05POwoJfQoKCWlmIChvcHRpb25fZWRpdCA8IDApCgkJb3B0aW9uX2VkaXQgPSBkZWZhdWx0X2VkaXRfb3B0aW9uKCk7CgoJaWYgKCF1c2Vfc3RyYXRlZ2llcykgewoJCWlmICghcmVtb3RlaGVhZHMpCgkJCTsgLyogYWxyZWFkeSB1cC10by1kYXRlICovCgkJZWxzZSBpZiAoIXJlbW90ZWhlYWRzLT5uZXh0KQoJCQlhZGRfc3RyYXRlZ2llcyhwdWxsX3R3b2hlYWQsIERFRkFVTFRfVFdPSEVBRCk7CgkJZWxzZQoJCQlhZGRfc3RyYXRlZ2llcyhwdWxsX29jdG9wdXMsIERFRkFVTFRfT0NUT1BVUyk7Cgl9CgoJZm9yIChpID0gMDsgaSA8IHVzZV9zdHJhdGVnaWVzX25yOyBpKyspIHsKCQlpZiAodXNlX3N0cmF0ZWdpZXNbaV0tPmF0dHIgJiBOT19GQVNUX0ZPUldBUkQpCgkJCWZhc3RfZm9yd2FyZCA9IEZGX05POwoJCWlmICh1c2Vfc3RyYXRlZ2llc1tpXS0+YXR0ciAmIE5PX1RSSVZJQUwpCgkJCWFsbG93X3RyaXZpYWwgPSAwOwoJfQoKCWlmICghcmVtb3RlaGVhZHMpCgkJOyAvKiBhbHJlYWR5IHVwLXRvLWRhdGUgKi8KCWVsc2UgaWYgKCFyZW1vdGVoZWFkcy0+bmV4dCkKCQljb21tb24gPSBnZXRfbWVyZ2VfYmFzZXMoaGVhZF9jb21taXQsIHJlbW90ZWhlYWRzLT5pdGVtKTsKCWVsc2UgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCA9IHJlbW90ZWhlYWRzOwoJCWNvbW1pdF9saXN0X2luc2VydChoZWFkX2NvbW1pdCwgJmxpc3QpOwoJCWNvbW1vbiA9IGdldF9vY3RvcHVzX21lcmdlX2Jhc2VzKGxpc3QpOwoJCWZyZWUobGlzdCk7Cgl9CgoJdXBkYXRlX3JlZigidXBkYXRpbmcgT1JJR19IRUFEIiwgIk9SSUdfSEVBRCIsIGhlYWRfY29tbWl0LT5vYmplY3Qub2lkLmhhc2gsCgkJICAgTlVMTCwgMCwgVVBEQVRFX1JFRlNfRElFX09OX0VSUik7CgoJaWYgKHJlbW90ZWhlYWRzICYmICFjb21tb24pIHsKCQkvKiBObyBjb21tb24gYW5jZXN0b3JzIGZvdW5kLiAqLwoJCWlmICghYWxsb3dfdW5yZWxhdGVkX2hpc3RvcmllcykKCQkJZGllKF8oInJlZnVzaW5nIHRvIG1lcmdlIHVucmVsYXRlZCBoaXN0b3JpZXMiKSk7CgkJLyogb3RoZXJ3aXNlLCB3ZSBuZWVkIGEgcmVhbCBtZXJnZS4gKi8KCX0gZWxzZSBpZiAoIXJlbW90ZWhlYWRzIHx8CgkJICghcmVtb3RlaGVhZHMtPm5leHQgJiYgIWNvbW1vbi0+bmV4dCAmJgoJCSAgY29tbW9uLT5pdGVtID09IHJlbW90ZWhlYWRzLT5pdGVtKSkgewoJCS8qCgkJICogSWYgaGVhZCBjYW4gcmVhY2ggYWxsIHRoZSBtZXJnZSB0aGVuIHdlIGFyZSB1cCB0byBkYXRlLgoJCSAqIGJ1dCBmaXJzdCB0aGUgbW9zdCBjb21tb24gY2FzZSBvZiBtZXJnaW5nIG9uZSByZW1vdGUuCgkJICovCgkJZmluaXNoX3VwX3RvX2RhdGUoXygiQWxyZWFkeSB1cC10by1kYXRlLiIpKTsKCQlnb3RvIGRvbmU7Cgl9IGVsc2UgaWYgKGZhc3RfZm9yd2FyZCAhPSBGRl9OTyAmJiAhcmVtb3RlaGVhZHMtPm5leHQgJiYKCQkJIWNvbW1vbi0+bmV4dCAmJgoJCQkhb2lkY21wKCZjb21tb24tPml0ZW0tPm9iamVjdC5vaWQsICZoZWFkX2NvbW1pdC0+b2JqZWN0Lm9pZCkpIHsKCQkvKiBBZ2FpbiB0aGUgbW9zdCBjb21tb24gY2FzZSBvZiBtZXJnaW5nIG9uZSByZW1vdGUuICovCgkJc3RydWN0IHN0cmJ1ZiBtc2cgPSBTVFJCVUZfSU5JVDsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgoJCWlmICh2ZXJib3NpdHkgPj0gMCkgewoJCQlwcmludGYoXygiVXBkYXRpbmcgJXMuLiVzXG4iKSwKCQkJICAgICAgIGZpbmRfdW5pcXVlX2FiYnJldihoZWFkX2NvbW1pdC0+b2JqZWN0Lm9pZC5oYXNoLAoJCQkJCQkgIERFRkFVTFRfQUJCUkVWKSwKCQkJICAgICAgIGZpbmRfdW5pcXVlX2FiYnJldihyZW1vdGVoZWFkcy0+aXRlbS0+b2JqZWN0Lm9pZC5oYXNoLAoJCQkJCQkgIERFRkFVTFRfQUJCUkVWKSk7CgkJfQoJCXN0cmJ1Zl9hZGRzdHIoJm1zZywgIkZhc3QtZm9yd2FyZCIpOwoJCWlmIChoYXZlX21lc3NhZ2UpCgkJCXN0cmJ1Zl9hZGRzdHIoJm1zZywKCQkJCSIgKG5vIGNvbW1pdCBjcmVhdGVkOyAtbSBvcHRpb24gaWdub3JlZCkiKTsKCQljb21taXQgPSByZW1vdGVoZWFkcy0+aXRlbTsKCQlpZiAoIWNvbW1pdCkgewoJCQlyZXQgPSAxOwoJCQlnb3RvIGRvbmU7CgkJfQoKCQlpZiAoY2hlY2tvdXRfZmFzdF9mb3J3YXJkKGhlYWRfY29tbWl0LT5vYmplY3Qub2lkLmhhc2gsCgkJCQkJICBjb21taXQtPm9iamVjdC5vaWQuaGFzaCwKCQkJCQkgIG92ZXJ3cml0ZV9pZ25vcmUpKSB7CgkJCXJldCA9IDE7CgkJCWdvdG8gZG9uZTsKCQl9CgoJCWZpbmlzaChoZWFkX2NvbW1pdCwgcmVtb3RlaGVhZHMsIGNvbW1pdC0+b2JqZWN0Lm9pZC5oYXNoLCBtc2cuYnVmKTsKCQlkcm9wX3NhdmUoKTsKCQlnb3RvIGRvbmU7Cgl9IGVsc2UgaWYgKCFyZW1vdGVoZWFkcy0+bmV4dCAmJiBjb21tb24tPm5leHQpCgkJOwoJCS8qCgkJICogV2UgYXJlIG5vdCBkb2luZyBvY3RvcHVzIGFuZCBub3QgZmFzdC1mb3J3YXJkLiAgTmVlZAoJCSAqIGEgcmVhbCBtZXJnZS4KCQkgKi8KCWVsc2UgaWYgKCFyZW1vdGVoZWFkcy0+bmV4dCAmJiAhY29tbW9uLT5uZXh0ICYmIG9wdGlvbl9jb21taXQpIHsKCQkvKgoJCSAqIFdlIGFyZSBub3QgZG9pbmcgb2N0b3B1cywgbm90IGZhc3QtZm9yd2FyZCwgYW5kIGhhdmUKCQkgKiBvbmx5IG9uZSBjb21tb24uCgkJICovCgkJcmVmcmVzaF9jYWNoZShSRUZSRVNIX1FVSUVUKTsKCQlpZiAoYWxsb3dfdHJpdmlhbCAmJiBmYXN0X2ZvcndhcmQgIT0gRkZfT05MWSkgewoJCQkvKiBTZWUgaWYgaXQgaXMgcmVhbGx5IHRyaXZpYWwuICovCgkJCWdpdF9jb21taXR0ZXJfaW5mbyhJREVOVF9TVFJJQ1QpOwoJCQlwcmludGYoXygiVHJ5aW5nIHJlYWxseSB0cml2aWFsIGluLWluZGV4IG1lcmdlLi4uXG4iKSk7CgkJCWlmICghcmVhZF90cmVlX3RyaXZpYWwoY29tbW9uLT5pdGVtLT5vYmplY3Qub2lkLmhhc2gsCgkJCQkJICAgICAgIGhlYWRfY29tbWl0LT5vYmplY3Qub2lkLmhhc2gsCgkJCQkJICAgICAgIHJlbW90ZWhlYWRzLT5pdGVtLT5vYmplY3Qub2lkLmhhc2gpKSB7CgkJCQlyZXQgPSBtZXJnZV90cml2aWFsKGhlYWRfY29tbWl0LCByZW1vdGVoZWFkcyk7CgkJCQlnb3RvIGRvbmU7CgkJCX0KCQkJcHJpbnRmKF8oIk5vcGUuXG4iKSk7CgkJfQoJfSBlbHNlIHsKCQkvKgoJCSAqIEFuIG9jdG9wdXMuICBJZiB3ZSBjYW4gcmVhY2ggYWxsIHRoZSByZW1vdGUgd2UgYXJlIHVwCgkJICogdG8gZGF0ZS4KCQkgKi8KCQlpbnQgdXBfdG9fZGF0ZSA9IDE7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpqOwoKCQlmb3IgKGogPSByZW1vdGVoZWFkczsgajsgaiA9IGotPm5leHQpIHsKCQkJc3RydWN0IGNvbW1pdF9saXN0ICpjb21tb25fb25lOwoKCQkJLyoKCQkJICogSGVyZSB3ZSAqaGF2ZSogdG8gY2FsY3VsYXRlIHRoZSBpbmRpdmlkdWFsCgkJCSAqIG1lcmdlX2Jhc2VzIGFnYWluLCBvdGhlcndpc2UgImdpdCBtZXJnZSBIRUFEXgoJCQkgKiBIRUFEXl4iIHdvdWxkIGJlIG1pc3NlZC4KCQkJICovCgkJCWNvbW1vbl9vbmUgPSBnZXRfbWVyZ2VfYmFzZXMoaGVhZF9jb21taXQsIGotPml0ZW0pOwoJCQlpZiAob2lkY21wKCZjb21tb25fb25lLT5pdGVtLT5vYmplY3Qub2lkLCAmai0+aXRlbS0+b2JqZWN0Lm9pZCkpIHsKCQkJCXVwX3RvX2RhdGUgPSAwOwoJCQkJYnJlYWs7CgkJCX0KCQl9CgkJaWYgKHVwX3RvX2RhdGUpIHsKCQkJZmluaXNoX3VwX3RvX2RhdGUoXygiQWxyZWFkeSB1cC10by1kYXRlLiBZZWVhaCEiKSk7CgkJCWdvdG8gZG9uZTsKCQl9Cgl9CgoJaWYgKGZhc3RfZm9yd2FyZCA9PSBGRl9PTkxZKQoJCWRpZShfKCJOb3QgcG9zc2libGUgdG8gZmFzdC1mb3J3YXJkLCBhYm9ydGluZy4iKSk7CgoJLyogV2UgYXJlIGdvaW5nIHRvIG1ha2UgYSBuZXcgY29tbWl0LiAqLwoJZ2l0X2NvbW1pdHRlcl9pbmZvKElERU5UX1NUUklDVCk7CgoJLyoKCSAqIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgYSByZWFsIG1lcmdlLiAgTm8gbWF0dGVyIHdoYXQgc3RyYXRlZ3kKCSAqIHdlIHVzZSwgaXQgd291bGQgb3BlcmF0ZSBvbiB0aGUgaW5kZXgsIHBvc3NpYmx5IGFmZmVjdGluZyB0aGUKCSAqIHdvcmtpbmcgdHJlZSwgYW5kIHdoZW4gcmVzb2x2ZWQgY2xlYW5seSwgaGF2ZSB0aGUgZGVzaXJlZAoJICogdHJlZSBpbiB0aGUgaW5kZXggLS0gdGhpcyBtZWFucyB0aGF0IHRoZSBpbmRleCBtdXN0IGJlIGluCgkgKiBzeW5jIHdpdGggdGhlIGhlYWQgY29tbWl0LiAgVGhlIHN0cmF0ZWdpZXMgYXJlIHJlc3BvbnNpYmxlCgkgKiB0byBlbnN1cmUgdGhpcy4KCSAqLwoJaWYgKHVzZV9zdHJhdGVnaWVzX25yID09IDEgfHwKCSAgICAvKgoJICAgICAqIFN0YXNoIGF3YXkgdGhlIGxvY2FsIGNoYW5nZXMgc28gdGhhdCB3ZSBjYW4gdHJ5IG1vcmUgdGhhbiBvbmUuCgkgICAgICovCgkgICAgc2F2ZV9zdGF0ZShzdGFzaCkpCgkJaGFzaGNscihzdGFzaCk7CgoJZm9yIChpID0gMDsgaSA8IHVzZV9zdHJhdGVnaWVzX25yOyBpKyspIHsKCQlpbnQgcmV0OwoJCWlmIChpKSB7CgkJCXByaW50ZihfKCJSZXdpbmRpbmcgdGhlIHRyZWUgdG8gcHJpc3RpbmUuLi5cbiIpKTsKCQkJcmVzdG9yZV9zdGF0ZShoZWFkX2NvbW1pdC0+b2JqZWN0Lm9pZC5oYXNoLCBzdGFzaCk7CgkJfQoJCWlmICh1c2Vfc3RyYXRlZ2llc19uciAhPSAxKQoJCQlwcmludGYoXygiVHJ5aW5nIG1lcmdlIHN0cmF0ZWd5ICVzLi4uXG4iKSwKCQkJCXVzZV9zdHJhdGVnaWVzW2ldLT5uYW1lKTsKCQkvKgoJCSAqIFJlbWVtYmVyIHdoaWNoIHN0cmF0ZWd5IGxlZnQgdGhlIHN0YXRlIGluIHRoZSB3b3JraW5nCgkJICogdHJlZS4KCQkgKi8KCQl3dF9zdHJhdGVneSA9IHVzZV9zdHJhdGVnaWVzW2ldLT5uYW1lOwoKCQlyZXQgPSB0cnlfbWVyZ2Vfc3RyYXRlZ3kodXNlX3N0cmF0ZWdpZXNbaV0tPm5hbWUsCgkJCQkJIGNvbW1vbiwgcmVtb3RlaGVhZHMsCgkJCQkJIGhlYWRfY29tbWl0LCBoZWFkX2FyZyk7CgkJaWYgKCFvcHRpb25fY29tbWl0ICYmICFyZXQpIHsKCQkJbWVyZ2Vfd2FzX29rID0gMTsKCQkJLyoKCQkJICogVGhpcyBpcyBuZWNlc3NhcnkgaGVyZSBqdXN0IHRvIGF2b2lkIHdyaXRpbmcKCQkJICogdGhlIHRyZWUsIGJ1dCBsYXRlciB3ZSB3aWxsICpub3QqIGV4aXQgd2l0aAoJCQkgKiBzdGF0dXMgY29kZSAxIGJlY2F1c2UgbWVyZ2Vfd2FzX29rIGlzIHNldC4KCQkJICovCgkJCXJldCA9IDE7CgkJfQoKCQlpZiAocmV0KSB7CgkJCS8qCgkJCSAqIFRoZSBiYWNrZW5kIGV4aXRzIHdpdGggMSB3aGVuIGNvbmZsaWN0cyBhcmUKCQkJICogbGVmdCB0byBiZSByZXNvbHZlZCwgd2l0aCAyIHdoZW4gaXQgZG9lcyBub3QKCQkJICogaGFuZGxlIHRoZSBnaXZlbiBtZXJnZSBhdCBhbGwuCgkJCSAqLwoJCQlpZiAocmV0ID09IDEpIHsKCQkJCWludCBjbnQgPSBldmFsdWF0ZV9yZXN1bHQoKTsKCgkJCQlpZiAoYmVzdF9jbnQgPD0gMCB8fCBjbnQgPD0gYmVzdF9jbnQpIHsKCQkJCQliZXN0X3N0cmF0ZWd5ID0gdXNlX3N0cmF0ZWdpZXNbaV0tPm5hbWU7CgkJCQkJYmVzdF9jbnQgPSBjbnQ7CgkJCQl9CgkJCX0KCQkJaWYgKG1lcmdlX3dhc19vaykKCQkJCWJyZWFrOwoJCQllbHNlCgkJCQljb250aW51ZTsKCQl9CgoJCS8qIEF1dG9tZXJnZSBzdWNjZWVkZWQuICovCgkJd3JpdGVfdHJlZV90cml2aWFsKHJlc3VsdF90cmVlKTsKCQlhdXRvbWVyZ2Vfd2FzX29rID0gMTsKCQlicmVhazsKCX0KCgkvKgoJICogSWYgd2UgaGF2ZSBhIHJlc3VsdGluZyB0cmVlLCB0aGF0IG1lYW5zIHRoZSBzdHJhdGVneSBtb2R1bGUKCSAqIGF1dG8gcmVzb2x2ZWQgdGhlIG1lcmdlIGNsZWFubHkuCgkgKi8KCWlmIChhdXRvbWVyZ2Vfd2FzX29rKSB7CgkJcmV0ID0gZmluaXNoX2F1dG9tZXJnZShoZWFkX2NvbW1pdCwgaGVhZF9zdWJzdW1lZCwKCQkJCSAgICAgICBjb21tb24sIHJlbW90ZWhlYWRzLAoJCQkJICAgICAgIHJlc3VsdF90cmVlLCB3dF9zdHJhdGVneSk7CgkJZ290byBkb25lOwoJfQoKCS8qCgkgKiBQaWNrIHRoZSByZXN1bHQgZnJvbSB0aGUgYmVzdCBzdHJhdGVneSBhbmQgaGF2ZSB0aGUgdXNlciBmaXgKCSAqIGl0IHVwLgoJICovCglpZiAoIWJlc3Rfc3RyYXRlZ3kpIHsKCQlyZXN0b3JlX3N0YXRlKGhlYWRfY29tbWl0LT5vYmplY3Qub2lkLmhhc2gsIHN0YXNoKTsKCQlpZiAodXNlX3N0cmF0ZWdpZXNfbnIgPiAxKQoJCQlmcHJpbnRmKHN0ZGVyciwKCQkJCV8oIk5vIG1lcmdlIHN0cmF0ZWd5IGhhbmRsZWQgdGhlIG1lcmdlLlxuIikpOwoJCWVsc2UKCQkJZnByaW50ZihzdGRlcnIsIF8oIk1lcmdlIHdpdGggc3RyYXRlZ3kgJXMgZmFpbGVkLlxuIiksCgkJCQl1c2Vfc3RyYXRlZ2llc1swXS0+bmFtZSk7CgkJcmV0ID0gMjsKCQlnb3RvIGRvbmU7Cgl9IGVsc2UgaWYgKGJlc3Rfc3RyYXRlZ3kgPT0gd3Rfc3RyYXRlZ3kpCgkJOyAvKiBXZSBhbHJlYWR5IGhhdmUgaXRzIHJlc3VsdCBpbiB0aGUgd29ya2luZyB0cmVlLiAqLwoJZWxzZSB7CgkJcHJpbnRmKF8oIlJld2luZGluZyB0aGUgdHJlZSB0byBwcmlzdGluZS4uLlxuIikpOwoJCXJlc3RvcmVfc3RhdGUoaGVhZF9jb21taXQtPm9iamVjdC5vaWQuaGFzaCwgc3Rhc2gpOwoJCXByaW50ZihfKCJVc2luZyB0aGUgJXMgdG8gcHJlcGFyZSByZXNvbHZpbmcgYnkgaGFuZC5cbiIpLAoJCQliZXN0X3N0cmF0ZWd5KTsKCQl0cnlfbWVyZ2Vfc3RyYXRlZ3koYmVzdF9zdHJhdGVneSwgY29tbW9uLCByZW1vdGVoZWFkcywKCQkJCSAgIGhlYWRfY29tbWl0LCBoZWFkX2FyZyk7Cgl9CgoJaWYgKHNxdWFzaCkKCQlmaW5pc2goaGVhZF9jb21taXQsIHJlbW90ZWhlYWRzLCBOVUxMLCBOVUxMKTsKCWVsc2UKCQl3cml0ZV9tZXJnZV9zdGF0ZShyZW1vdGVoZWFkcyk7CgoJaWYgKG1lcmdlX3dhc19vaykKCQlmcHJpbnRmKHN0ZGVyciwgXygiQXV0b21hdGljIG1lcmdlIHdlbnQgd2VsbDsgIgoJCQkic3RvcHBlZCBiZWZvcmUgY29tbWl0dGluZyBhcyByZXF1ZXN0ZWRcbiIpKTsKCWVsc2UKCQlyZXQgPSBzdWdnZXN0X2NvbmZsaWN0cygpOwoKZG9uZToKCWZyZWUoYnJhbmNoX3RvX2ZyZWUpOwoJcmV0dXJuIHJldDsKfQo=",
    "text": "/*\n * Builtin \"git merge\"\n *\n * Copyright (c) 2008 Miklos Vajna <vmiklos@frugalware.org>\n *\n * Based on git-merge.sh by Junio C Hamano.\n */\n\n#include \"cache.h\"\n#include \"parse-options.h\"\n#include \"builtin.h\"\n#include \"lockfile.h\"\n#include \"run-command.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"commit.h\"\n#include \"diffcore.h\"\n#include \"revision.h\"\n#include \"unpack-trees.h\"\n#include \"cache-tree.h\"\n#include \"dir.h\"\n#include \"utf8.h\"\n#include \"log-tree.h\"\n#include \"color.h\"\n#include \"rerere.h\"\n#include \"help.h\"\n#include \"merge-recursive.h\"\n#include \"resolve-undo.h\"\n#include \"remote.h\"\n#include \"fmt-merge-msg.h\"\n#include \"gpg-interface.h\"\n#include \"sequencer.h\"\n#include \"string-list.h\"\n\n#define DEFAULT_TWOHEAD (1<<0)\n#define DEFAULT_OCTOPUS (1<<1)\n#define NO_FAST_FORWARD (1<<2)\n#define NO_TRIVIAL      (1<<3)\n\nstruct strategy {\n\tconst char *name;\n\tunsigned attr;\n};\n\nstatic const char * const builtin_merge_usage[] = {\n\tN_(\"git merge [<options>] [<commit>...]\"),\n\tN_(\"git merge [<options>] <msg> HEAD <commit>\"),\n\tN_(\"git merge --abort\"),\n\tNULL\n};\n\nstatic int show_diffstat = 1, shortlog_len = -1, squash;\nstatic int option_commit = 1;\nstatic int option_edit = -1;\nstatic int allow_trivial = 1, have_message, verify_signatures;\nstatic int overwrite_ignore = 1;\nstatic struct strbuf merge_msg = STRBUF_INIT;\nstatic struct strategy **use_strategies;\nstatic size_t use_strategies_nr, use_strategies_alloc;\nstatic const char **xopts;\nstatic size_t xopts_nr, xopts_alloc;\nstatic const char *branch;\nstatic char *branch_mergeoptions;\nstatic int option_renormalize;\nstatic int verbosity;\nstatic int allow_rerere_auto;\nstatic int abort_current_merge;\nstatic int allow_unrelated_histories;\nstatic int show_progress = -1;\nstatic int default_to_upstream = 1;\nstatic const char *sign_commit;\n\nstatic struct strategy all_strategy[] = {\n\t{ \"recursive\",  DEFAULT_TWOHEAD | NO_TRIVIAL },\n\t{ \"octopus\",    DEFAULT_OCTOPUS },\n\t{ \"resolve\",    0 },\n\t{ \"ours\",       NO_FAST_FORWARD | NO_TRIVIAL },\n\t{ \"subtree\",    NO_FAST_FORWARD | NO_TRIVIAL },\n};\n\nstatic const char *pull_twohead, *pull_octopus;\n\nenum ff_type {\n\tFF_NO,\n\tFF_ALLOW,\n\tFF_ONLY\n};\n\nstatic enum ff_type fast_forward = FF_ALLOW;\n\nstatic int option_parse_message(const struct option *opt,\n\t\t\t\tconst char *arg, int unset)\n{\n\tstruct strbuf *buf = opt->value;\n\n\tif (unset)\n\t\tstrbuf_setlen(buf, 0);\n\telse if (arg) {\n\t\tstrbuf_addf(buf, \"%s%s\", buf->len ? \"\\n\\n\" : \"\", arg);\n\t\thave_message = 1;\n\t} else\n\t\treturn error(_(\"switch `m' requires a value\"));\n\treturn 0;\n}\n\nstatic struct strategy *get_strategy(const char *name)\n{\n\tint i;\n\tstruct strategy *ret;\n\tstatic struct cmdnames main_cmds, other_cmds;\n\tstatic int loaded;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(all_strategy); i++)\n\t\tif (!strcmp(name, all_strategy[i].name))\n\t\t\treturn &all_strategy[i];\n\n\tif (!loaded) {\n\t\tstruct cmdnames not_strategies;\n\t\tloaded = 1;\n\n\t\tmemset(&not_strategies, 0, sizeof(struct cmdnames));\n\t\tload_command_list(\"git-merge-\", &main_cmds, &other_cmds);\n\t\tfor (i = 0; i < main_cmds.cnt; i++) {\n\t\t\tint j, found = 0;\n\t\t\tstruct cmdname *ent = main_cmds.names[i];\n\t\t\tfor (j = 0; j < ARRAY_SIZE(all_strategy); j++)\n\t\t\t\tif (!strncmp(ent->name, all_strategy[j].name, ent->len)\n\t\t\t\t\t\t&& !all_strategy[j].name[ent->len])\n\t\t\t\t\tfound = 1;\n\t\t\tif (!found)\n\t\t\t\tadd_cmdname(&not_strategies, ent->name, ent->len);\n\t\t}\n\t\texclude_cmds(&main_cmds, &not_strategies);\n\t}\n\tif (!is_in_cmdlist(&main_cmds, name) && !is_in_cmdlist(&other_cmds, name)) {\n\t\tfprintf(stderr, _(\"Could not find merge strategy '%s'.\\n\"), name);\n\t\tfprintf(stderr, _(\"Available strategies are:\"));\n\t\tfor (i = 0; i < main_cmds.cnt; i++)\n\t\t\tfprintf(stderr, \" %s\", main_cmds.names[i]->name);\n\t\tfprintf(stderr, \".\\n\");\n\t\tif (other_cmds.cnt) {\n\t\t\tfprintf(stderr, _(\"Available custom strategies are:\"));\n\t\t\tfor (i = 0; i < other_cmds.cnt; i++)\n\t\t\t\tfprintf(stderr, \" %s\", other_cmds.names[i]->name);\n\t\t\tfprintf(stderr, \".\\n\");\n\t\t}\n\t\texit(1);\n\t}\n\n\tret = xcalloc(1, sizeof(struct strategy));\n\tret->name = xstrdup(name);\n\tret->attr = NO_TRIVIAL;\n\treturn ret;\n}\n\nstatic void append_strategy(struct strategy *s)\n{\n\tALLOC_GROW(use_strategies, use_strategies_nr + 1, use_strategies_alloc);\n\tuse_strategies[use_strategies_nr++] = s;\n}\n\nstatic int option_parse_strategy(const struct option *opt,\n\t\t\t\t const char *name, int unset)\n{\n\tif (unset)\n\t\treturn 0;\n\n\tappend_strategy(get_strategy(name));\n\treturn 0;\n}\n\nstatic int option_parse_x(const struct option *opt,\n\t\t\t  const char *arg, int unset)\n{\n\tif (unset)\n\t\treturn 0;\n\n\tALLOC_GROW(xopts, xopts_nr + 1, xopts_alloc);\n\txopts[xopts_nr++] = xstrdup(arg);\n\treturn 0;\n}\n\nstatic int option_parse_n(const struct option *opt,\n\t\t\t  const char *arg, int unset)\n{\n\tshow_diffstat = unset;\n\treturn 0;\n}\n\nstatic struct option builtin_merge_options[] = {\n\t{ OPTION_CALLBACK, 'n', NULL, NULL, NULL,\n\t\tN_(\"do not show a diffstat at the end of the merge\"),\n\t\tPARSE_OPT_NOARG, option_parse_n },\n\tOPT_BOOL(0, \"stat\", &show_diffstat,\n\t\tN_(\"show a diffstat at the end of the merge\")),\n\tOPT_BOOL(0, \"summary\", &show_diffstat, N_(\"(synonym to --stat)\")),\n\t{ OPTION_INTEGER, 0, \"log\", &shortlog_len, N_(\"n\"),\n\t  N_(\"add (at most <n>) entries from shortlog to merge commit message\"),\n\t  PARSE_OPT_OPTARG, NULL, DEFAULT_MERGE_LOG_LEN },\n\tOPT_BOOL(0, \"squash\", &squash,\n\t\tN_(\"create a single commit instead of doing a merge\")),\n\tOPT_BOOL(0, \"commit\", &option_commit,\n\t\tN_(\"perform a commit if the merge succeeds (default)\")),\n\tOPT_BOOL('e', \"edit\", &option_edit,\n\t\tN_(\"edit message before committing\")),\n\tOPT_SET_INT(0, \"ff\", &fast_forward, N_(\"allow fast-forward (default)\"), FF_ALLOW),\n\t{ OPTION_SET_INT, 0, \"ff-only\", &fast_forward, NULL,\n\t\tN_(\"abort if fast-forward is not possible\"),\n\t\tPARSE_OPT_NOARG | PARSE_OPT_NONEG, NULL, FF_ONLY },\n\tOPT_RERERE_AUTOUPDATE(&allow_rerere_auto),\n\tOPT_BOOL(0, \"verify-signatures\", &verify_signatures,\n\t\tN_(\"verify that the named commit has a valid GPG signature\")),\n\tOPT_CALLBACK('s', \"strategy\", &use_strategies, N_(\"strategy\"),\n\t\tN_(\"merge strategy to use\"), option_parse_strategy),\n\tOPT_CALLBACK('X', \"strategy-option\", &xopts, N_(\"option=value\"),\n\t\tN_(\"option for selected merge strategy\"), option_parse_x),\n\tOPT_CALLBACK('m', \"message\", &merge_msg, N_(\"message\"),\n\t\tN_(\"merge commit message (for a non-fast-forward merge)\"),\n\t\toption_parse_message),\n\tOPT__VERBOSITY(&verbosity),\n\tOPT_BOOL(0, \"abort\", &abort_current_merge,\n\t\tN_(\"abort the current in-progress merge\")),\n\tOPT_BOOL(0, \"allow-unrelated-histories\", &allow_unrelated_histories,\n\t\t N_(\"allow merging unrelated histories\")),\n\tOPT_SET_INT(0, \"progress\", &show_progress, N_(\"force progress reporting\"), 1),\n\t{ OPTION_STRING, 'S', \"gpg-sign\", &sign_commit, N_(\"key-id\"),\n\t  N_(\"GPG sign commit\"), PARSE_OPT_OPTARG, NULL, (intptr_t) \"\" },\n\tOPT_BOOL(0, \"overwrite-ignore\", &overwrite_ignore, N_(\"update ignored files (default)\")),\n\tOPT_END()\n};\n\n/* Cleans up metadata that is uninteresting after a succeeded merge. */\nstatic void drop_save(void)\n{\n\tunlink(git_path_merge_head());\n\tunlink(git_path_merge_msg());\n\tunlink(git_path_merge_mode());\n}\n\nstatic int save_state(unsigned char *stash)\n{\n\tint len;\n\tstruct child_process cp = CHILD_PROCESS_INIT;\n\tstruct strbuf buffer = STRBUF_INIT;\n\tconst char *argv[] = {\"stash\", \"create\", NULL};\n\n\tcp.argv = argv;\n\tcp.out = -1;\n\tcp.git_cmd = 1;\n\n\tif (start_command(&cp))\n\t\tdie(_(\"could not run stash.\"));\n\tlen = strbuf_read(&buffer, cp.out, 1024);\n\tclose(cp.out);\n\n\tif (finish_command(&cp) || len < 0)\n\t\tdie(_(\"stash failed\"));\n\telse if (!len)\t\t/* no changes */\n\t\treturn -1;\n\tstrbuf_setlen(&buffer, buffer.len-1);\n\tif (get_sha1(buffer.buf, stash))\n\t\tdie(_(\"not a valid object: %s\"), buffer.buf);\n\treturn 0;\n}\n\nstatic void read_empty(unsigned const char *sha1, int verbose)\n{\n\tint i = 0;\n\tconst char *args[7];\n\n\targs[i++] = \"read-tree\";\n\tif (verbose)\n\t\targs[i++] = \"-v\";\n\targs[i++] = \"-m\";\n\targs[i++] = \"-u\";\n\targs[i++] = EMPTY_TREE_SHA1_HEX;\n\targs[i++] = sha1_to_hex(sha1);\n\targs[i] = NULL;\n\n\tif (run_command_v_opt(args, RUN_GIT_CMD))\n\t\tdie(_(\"read-tree failed\"));\n}\n\nstatic void reset_hard(unsigned const char *sha1, int verbose)\n{\n\tint i = 0;\n\tconst char *args[6];\n\n\targs[i++] = \"read-tree\";\n\tif (verbose)\n\t\targs[i++] = \"-v\";\n\targs[i++] = \"--reset\";\n\targs[i++] = \"-u\";\n\targs[i++] = sha1_to_hex(sha1);\n\targs[i] = NULL;\n\n\tif (run_command_v_opt(args, RUN_GIT_CMD))\n\t\tdie(_(\"read-tree failed\"));\n}\n\nstatic void restore_state(const unsigned char *head,\n\t\t\t  const unsigned char *stash)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *args[] = { \"stash\", \"apply\", NULL, NULL };\n\n\tif (is_null_sha1(stash))\n\t\treturn;\n\n\treset_hard(head, 1);\n\n\targs[2] = sha1_to_hex(stash);\n\n\t/*\n\t * It is OK to ignore error here, for example when there was\n\t * nothing to restore.\n\t */\n\trun_command_v_opt(args, RUN_GIT_CMD);\n\n\tstrbuf_release(&sb);\n\trefresh_cache(REFRESH_QUIET);\n}\n\n/* This is called when no merge was necessary. */\nstatic void finish_up_to_date(const char *msg)\n{\n\tif (verbosity >= 0)\n\t\tprintf(\"%s%s\\n\", squash ? _(\" (nothing to squash)\") : \"\", msg);\n\tdrop_save();\n}\n\nstatic void squash_message(struct commit *commit, struct commit_list *remoteheads)\n{\n\tstruct rev_info rev;\n\tstruct strbuf out = STRBUF_INIT;\n\tstruct commit_list *j;\n\tstruct pretty_print_context ctx = {0};\n\n\tprintf(_(\"Squash commit -- not updating HEAD\\n\"));\n\n\tinit_revisions(&rev, NULL);\n\trev.ignore_merges = 1;\n\trev.commit_format = CMIT_FMT_MEDIUM;\n\n\tcommit->object.flags |= UNINTERESTING;\n\tadd_pending_object(&rev, &commit->object, NULL);\n\n\tfor (j = remoteheads; j; j = j->next)\n\t\tadd_pending_object(&rev, &j->item->object, NULL);\n\n\tsetup_revisions(0, NULL, &rev, NULL);\n\tif (prepare_revision_walk(&rev))\n\t\tdie(_(\"revision walk setup failed\"));\n\n\tctx.abbrev = rev.abbrev;\n\tctx.date_mode = rev.date_mode;\n\tctx.fmt = rev.commit_format;\n\n\tstrbuf_addstr(&out, \"Squashed commit of the following:\\n\");\n\twhile ((commit = get_revision(&rev)) != NULL) {\n\t\tstrbuf_addch(&out, '\\n');\n\t\tstrbuf_addf(&out, \"commit %s\\n\",\n\t\t\toid_to_hex(&commit->object.oid));\n\t\tpretty_print_commit(&ctx, commit, &out);\n\t}\n\twrite_file_buf(git_path_squash_msg(), out.buf, out.len);\n\tstrbuf_release(&out);\n}\n\nstatic void finish(struct commit *head_commit,\n\t\t   struct commit_list *remoteheads,\n\t\t   const unsigned char *new_head, const char *msg)\n{\n\tstruct strbuf reflog_message = STRBUF_INIT;\n\tconst unsigned char *head = head_commit->object.oid.hash;\n\n\tif (!msg)\n\t\tstrbuf_addstr(&reflog_message, getenv(\"GIT_REFLOG_ACTION\"));\n\telse {\n\t\tif (verbosity >= 0)\n\t\t\tprintf(\"%s\\n\", msg);\n\t\tstrbuf_addf(&reflog_message, \"%s: %s\",\n\t\t\tgetenv(\"GIT_REFLOG_ACTION\"), msg);\n\t}\n\tif (squash) {\n\t\tsquash_message(head_commit, remoteheads);\n\t} else {\n\t\tif (verbosity >= 0 && !merge_msg.len)\n\t\t\tprintf(_(\"No merge message -- not updating HEAD\\n\"));\n\t\telse {\n\t\t\tconst char *argv_gc_auto[] = { \"gc\", \"--auto\", NULL };\n\t\t\tupdate_ref(reflog_message.buf, \"HEAD\",\n\t\t\t\tnew_head, head, 0,\n\t\t\t\tUPDATE_REFS_DIE_ON_ERR);\n\t\t\t/*\n\t\t\t * We ignore errors in 'gc --auto', since the\n\t\t\t * user should see them.\n\t\t\t */\n\t\t\tclose_all_packs();\n\t\t\trun_command_v_opt(argv_gc_auto, RUN_GIT_CMD);\n\t\t}\n\t}\n\tif (new_head && show_diffstat) {\n\t\tstruct diff_options opts;\n\t\tdiff_setup(&opts);\n\t\topts.stat_width = -1; /* use full terminal width */\n\t\topts.stat_graph_width = -1; /* respect statGraphWidth config */\n\t\topts.output_format |=\n\t\t\tDIFF_FORMAT_SUMMARY | DIFF_FORMAT_DIFFSTAT;\n\t\topts.detect_rename = DIFF_DETECT_RENAME;\n\t\tdiff_setup_done(&opts);\n\t\tdiff_tree_sha1(head, new_head, \"\", &opts);\n\t\tdiffcore_std(&opts);\n\t\tdiff_flush(&opts);\n\t}\n\n\t/* Run a post-merge hook */\n\trun_hook_le(NULL, \"post-merge\", squash ? \"1\" : \"0\", NULL);\n\n\tstrbuf_release(&reflog_message);\n}\n\n/* Get the name for the merge commit's message. */\nstatic void merge_name(const char *remote, struct strbuf *msg)\n{\n\tstruct commit *remote_head;\n\tunsigned char branch_head[20];\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf bname = STRBUF_INIT;\n\tconst char *ptr;\n\tchar *found_ref;\n\tint len, early;\n\n\tstrbuf_branchname(&bname, remote);\n\tremote = bname.buf;\n\n\tmemset(branch_head, 0, sizeof(branch_head));\n\tremote_head = get_merge_parent(remote);\n\tif (!remote_head)\n\t\tdie(_(\"'%s' does not point to a commit\"), remote);\n\n\tif (dwim_ref(remote, strlen(remote), branch_head, &found_ref) > 0) {\n\t\tif (starts_with(found_ref, \"refs/heads/\")) {\n\t\t\tstrbuf_addf(msg, \"%s\\t\\tbranch '%s' of .\\n\",\n\t\t\t\t    sha1_to_hex(branch_head), remote);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (starts_with(found_ref, \"refs/tags/\")) {\n\t\t\tstrbuf_addf(msg, \"%s\\t\\ttag '%s' of .\\n\",\n\t\t\t\t    sha1_to_hex(branch_head), remote);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (starts_with(found_ref, \"refs/remotes/\")) {\n\t\t\tstrbuf_addf(msg, \"%s\\t\\tremote-tracking branch '%s' of .\\n\",\n\t\t\t\t    sha1_to_hex(branch_head), remote);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* See if remote matches <name>^^^.. or <name>~<number> */\n\tfor (len = 0, ptr = remote + strlen(remote);\n\t     remote < ptr && ptr[-1] == '^';\n\t     ptr--)\n\t\tlen++;\n\tif (len)\n\t\tearly = 1;\n\telse {\n\t\tearly = 0;\n\t\tptr = strrchr(remote, '~');\n\t\tif (ptr) {\n\t\t\tint seen_nonzero = 0;\n\n\t\t\tlen++; /* count ~ */\n\t\t\twhile (*++ptr && isdigit(*ptr)) {\n\t\t\t\tseen_nonzero |= (*ptr != '0');\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (*ptr)\n\t\t\t\tlen = 0; /* not ...~<number> */\n\t\t\telse if (seen_nonzero)\n\t\t\t\tearly = 1;\n\t\t\telse if (len == 1)\n\t\t\t\tearly = 1; /* \"name~\" is \"name~1\"! */\n\t\t}\n\t}\n\tif (len) {\n\t\tstruct strbuf truname = STRBUF_INIT;\n\t\tstrbuf_addf(&truname, \"refs/heads/%s\", remote);\n\t\tstrbuf_setlen(&truname, truname.len - len);\n\t\tif (ref_exists(truname.buf)) {\n\t\t\tstrbuf_addf(msg,\n\t\t\t\t    \"%s\\t\\tbranch '%s'%s of .\\n\",\n\t\t\t\t    oid_to_hex(&remote_head->object.oid),\n\t\t\t\t    truname.buf + 11,\n\t\t\t\t    (early ? \" (early part)\" : \"\"));\n\t\t\tstrbuf_release(&truname);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tstrbuf_release(&truname);\n\t}\n\n\tif (remote_head->util) {\n\t\tstruct merge_remote_desc *desc;\n\t\tdesc = merge_remote_util(remote_head);\n\t\tif (desc && desc->obj && desc->obj->type == OBJ_TAG) {\n\t\t\tstrbuf_addf(msg, \"%s\\t\\t%s '%s'\\n\",\n\t\t\t\t    oid_to_hex(&desc->obj->oid),\n\t\t\t\t    typename(desc->obj->type),\n\t\t\t\t    remote);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tstrbuf_addf(msg, \"%s\\t\\tcommit '%s'\\n\",\n\t\toid_to_hex(&remote_head->object.oid), remote);\ncleanup:\n\tstrbuf_release(&buf);\n\tstrbuf_release(&bname);\n}\n\nstatic void parse_branch_merge_options(char *bmo)\n{\n\tconst char **argv;\n\tint argc;\n\n\tif (!bmo)\n\t\treturn;\n\targc = split_cmdline(bmo, &argv);\n\tif (argc < 0)\n\t\tdie(_(\"Bad branch.%s.mergeoptions string: %s\"), branch,\n\t\t    split_cmdline_strerror(argc));\n\tREALLOC_ARRAY(argv, argc + 2);\n\tmemmove(argv + 1, argv, sizeof(*argv) * (argc + 1));\n\targc++;\n\targv[0] = \"branch.*.mergeoptions\";\n\tparse_options(argc, argv, NULL, builtin_merge_options,\n\t\t      builtin_merge_usage, 0);\n\tfree(argv);\n}\n\nstatic int git_merge_config(const char *k, const char *v, void *cb)\n{\n\tint status;\n\n\tif (branch && starts_with(k, \"branch.\") &&\n\t\tstarts_with(k + 7, branch) &&\n\t\t!strcmp(k + 7 + strlen(branch), \".mergeoptions\")) {\n\t\tfree(branch_mergeoptions);\n\t\tbranch_mergeoptions = xstrdup(v);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(k, \"merge.diffstat\") || !strcmp(k, \"merge.stat\"))\n\t\tshow_diffstat = git_config_bool(k, v);\n\telse if (!strcmp(k, \"pull.twohead\"))\n\t\treturn git_config_string(&pull_twohead, k, v);\n\telse if (!strcmp(k, \"pull.octopus\"))\n\t\treturn git_config_string(&pull_octopus, k, v);\n\telse if (!strcmp(k, \"merge.renormalize\"))\n\t\toption_renormalize = git_config_bool(k, v);\n\telse if (!strcmp(k, \"merge.ff\")) {\n\t\tint boolval = git_config_maybe_bool(k, v);\n\t\tif (0 <= boolval) {\n\t\t\tfast_forward = boolval ? FF_ALLOW : FF_NO;\n\t\t} else if (v && !strcmp(v, \"only\")) {\n\t\t\tfast_forward = FF_ONLY;\n\t\t} /* do not barf on values from future versions of git */\n\t\treturn 0;\n\t} else if (!strcmp(k, \"merge.defaulttoupstream\")) {\n\t\tdefault_to_upstream = git_config_bool(k, v);\n\t\treturn 0;\n\t} else if (!strcmp(k, \"commit.gpgsign\")) {\n\t\tsign_commit = git_config_bool(k, v) ? \"\" : NULL;\n\t\treturn 0;\n\t}\n\n\tstatus = fmt_merge_msg_config(k, v, cb);\n\tif (status)\n\t\treturn status;\n\tstatus = git_gpg_config(k, v, NULL);\n\tif (status)\n\t\treturn status;\n\treturn git_diff_ui_config(k, v, cb);\n}\n\nstatic int read_tree_trivial(unsigned char *common, unsigned char *head,\n\t\t\t     unsigned char *one)\n{\n\tint i, nr_trees = 0;\n\tstruct tree *trees[MAX_UNPACK_TREES];\n\tstruct tree_desc t[MAX_UNPACK_TREES];\n\tstruct unpack_trees_options opts;\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.head_idx = 2;\n\topts.src_index = &the_index;\n\topts.dst_index = &the_index;\n\topts.update = 1;\n\topts.verbose_update = 1;\n\topts.trivial_merges_only = 1;\n\topts.merge = 1;\n\ttrees[nr_trees] = parse_tree_indirect(common);\n\tif (!trees[nr_trees++])\n\t\treturn -1;\n\ttrees[nr_trees] = parse_tree_indirect(head);\n\tif (!trees[nr_trees++])\n\t\treturn -1;\n\ttrees[nr_trees] = parse_tree_indirect(one);\n\tif (!trees[nr_trees++])\n\t\treturn -1;\n\topts.fn = threeway_merge;\n\tcache_tree_free(&active_cache_tree);\n\tfor (i = 0; i < nr_trees; i++) {\n\t\tparse_tree(trees[i]);\n\t\tinit_tree_desc(t+i, trees[i]->buffer, trees[i]->size);\n\t}\n\tif (unpack_trees(nr_trees, t, &opts))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void write_tree_trivial(unsigned char *sha1)\n{\n\tif (write_cache_as_tree(sha1, 0, NULL))\n\t\tdie(_(\"git write-tree failed to write a tree\"));\n}\n\nstatic int try_merge_strategy(const char *strategy, struct commit_list *common,\n\t\t\t      struct commit_list *remoteheads,\n\t\t\t      struct commit *head, const char *head_arg)\n{\n\tstatic struct lock_file lock;\n\n\thold_locked_index(&lock, LOCK_DIE_ON_ERROR);\n\trefresh_cache(REFRESH_QUIET);\n\tif (active_cache_changed &&\n\t    write_locked_index(&the_index, &lock, COMMIT_LOCK))\n\t\treturn error(_(\"Unable to write index.\"));\n\trollback_lock_file(&lock);\n\n\tif (!strcmp(strategy, \"recursive\") || !strcmp(strategy, \"subtree\")) {\n\t\tint clean, x;\n\t\tstruct commit *result;\n\t\tstruct commit_list *reversed = NULL;\n\t\tstruct merge_options o;\n\t\tstruct commit_list *j;\n\n\t\tif (remoteheads->next) {\n\t\t\terror(_(\"Not handling anything other than two heads merge.\"));\n\t\t\treturn 2;\n\t\t}\n\n\t\tinit_merge_options(&o);\n\t\tif (!strcmp(strategy, \"subtree\"))\n\t\t\to.subtree_shift = \"\";\n\n\t\to.renormalize = option_renormalize;\n\t\to.show_rename_progress =\n\t\t\tshow_progress == -1 ? isatty(2) : show_progress;\n\n\t\tfor (x = 0; x < xopts_nr; x++)\n\t\t\tif (parse_merge_opt(&o, xopts[x]))\n\t\t\t\tdie(_(\"Unknown option for merge-recursive: -X%s\"), xopts[x]);\n\n\t\to.branch1 = head_arg;\n\t\to.branch2 = merge_remote_util(remoteheads->item)->name;\n\n\t\tfor (j = common; j; j = j->next)\n\t\t\tcommit_list_insert(j->item, &reversed);\n\n\t\thold_locked_index(&lock, LOCK_DIE_ON_ERROR);\n\t\tclean = merge_recursive(&o, head,\n\t\t\t\tremoteheads->item, reversed, &result);\n\t\tif (clean < 0)\n\t\t\texit(128);\n\t\tif (active_cache_changed &&\n\t\t    write_locked_index(&the_index, &lock, COMMIT_LOCK))\n\t\t\tdie (_(\"unable to write %s\"), get_index_file());\n\t\trollback_lock_file(&lock);\n\t\treturn clean ? 0 : 1;\n\t} else {\n\t\treturn try_merge_command(strategy, xopts_nr, xopts,\n\t\t\t\t\t\tcommon, head_arg, remoteheads);\n\t}\n}\n\nstatic void count_diff_files(struct diff_queue_struct *q,\n\t\t\t     struct diff_options *opt, void *data)\n{\n\tint *count = data;\n\n\t(*count) += q->nr;\n}\n\nstatic int count_unmerged_entries(void)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < active_nr; i++)\n\t\tif (ce_stage(active_cache[i]))\n\t\t\tret++;\n\n\treturn ret;\n}\n\nstatic void add_strategies(const char *string, unsigned attr)\n{\n\tint i;\n\n\tif (string) {\n\t\tstruct string_list list = STRING_LIST_INIT_DUP;\n\t\tstruct string_list_item *item;\n\t\tstring_list_split(&list, string, ' ', -1);\n\t\tfor_each_string_list_item(item, &list)\n\t\t\tappend_strategy(get_strategy(item->string));\n\t\tstring_list_clear(&list, 0);\n\t\treturn;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(all_strategy); i++)\n\t\tif (all_strategy[i].attr & attr)\n\t\t\tappend_strategy(&all_strategy[i]);\n\n}\n\nstatic void read_merge_msg(struct strbuf *msg)\n{\n\tconst char *filename = git_path_merge_msg();\n\tstrbuf_reset(msg);\n\tif (strbuf_read_file(msg, filename, 0) < 0)\n\t\tdie_errno(_(\"Could not read from '%s'\"), filename);\n}\n\nstatic void write_merge_state(struct commit_list *);\nstatic void abort_commit(struct commit_list *remoteheads, const char *err_msg)\n{\n\tif (err_msg)\n\t\terror(\"%s\", err_msg);\n\tfprintf(stderr,\n\t\t_(\"Not committing merge; use 'git commit' to complete the merge.\\n\"));\n\twrite_merge_state(remoteheads);\n\texit(1);\n}\n\nstatic const char merge_editor_comment[] =\nN_(\"Please enter a commit message to explain why this merge is necessary,\\n\"\n   \"especially if it merges an updated upstream into a topic branch.\\n\"\n   \"\\n\"\n   \"Lines starting with '%c' will be ignored, and an empty message aborts\\n\"\n   \"the commit.\\n\");\n\nstatic void prepare_to_commit(struct commit_list *remoteheads)\n{\n\tstruct strbuf msg = STRBUF_INIT;\n\tstrbuf_addbuf(&msg, &merge_msg);\n\tstrbuf_addch(&msg, '\\n');\n\tif (0 < option_edit)\n\t\tstrbuf_commented_addf(&msg, _(merge_editor_comment), comment_line_char);\n\twrite_file_buf(git_path_merge_msg(), msg.buf, msg.len);\n\tif (run_commit_hook(0 < option_edit, get_index_file(), \"prepare-commit-msg\",\n\t\t\t    git_path_merge_msg(), \"merge\", NULL))\n\t\tabort_commit(remoteheads, NULL);\n\tif (0 < option_edit) {\n\t\tif (launch_editor(git_path_merge_msg(), NULL, NULL))\n\t\t\tabort_commit(remoteheads, NULL);\n\t}\n\tread_merge_msg(&msg);\n\tstrbuf_stripspace(&msg, 0 < option_edit);\n\tif (!msg.len)\n\t\tabort_commit(remoteheads, _(\"Empty commit message.\"));\n\tstrbuf_release(&merge_msg);\n\tstrbuf_addbuf(&merge_msg, &msg);\n\tstrbuf_release(&msg);\n}\n\nstatic int merge_trivial(struct commit *head, struct commit_list *remoteheads)\n{\n\tunsigned char result_tree[20], result_commit[20];\n\tstruct commit_list *parents, **pptr = &parents;\n\tstatic struct lock_file lock;\n\n\thold_locked_index(&lock, LOCK_DIE_ON_ERROR);\n\trefresh_cache(REFRESH_QUIET);\n\tif (active_cache_changed &&\n\t    write_locked_index(&the_index, &lock, COMMIT_LOCK))\n\t\treturn error(_(\"Unable to write index.\"));\n\trollback_lock_file(&lock);\n\n\twrite_tree_trivial(result_tree);\n\tprintf(_(\"Wonderful.\\n\"));\n\tpptr = commit_list_append(head, pptr);\n\tpptr = commit_list_append(remoteheads->item, pptr);\n\tprepare_to_commit(remoteheads);\n\tif (commit_tree(merge_msg.buf, merge_msg.len, result_tree, parents,\n\t\t\tresult_commit, NULL, sign_commit))\n\t\tdie(_(\"failed to write commit object\"));\n\tfinish(head, remoteheads, result_commit, \"In-index merge\");\n\tdrop_save();\n\treturn 0;\n}\n\nstatic int finish_automerge(struct commit *head,\n\t\t\t    int head_subsumed,\n\t\t\t    struct commit_list *common,\n\t\t\t    struct commit_list *remoteheads,\n\t\t\t    unsigned char *result_tree,\n\t\t\t    const char *wt_strategy)\n{\n\tstruct commit_list *parents = NULL;\n\tstruct strbuf buf = STRBUF_INIT;\n\tunsigned char result_commit[20];\n\n\tfree_commit_list(common);\n\tparents = remoteheads;\n\tif (!head_subsumed || fast_forward == FF_NO)\n\t\tcommit_list_insert(head, &parents);\n\tstrbuf_addch(&merge_msg, '\\n');\n\tprepare_to_commit(remoteheads);\n\tif (commit_tree(merge_msg.buf, merge_msg.len, result_tree, parents,\n\t\t\tresult_commit, NULL, sign_commit))\n\t\tdie(_(\"failed to write commit object\"));\n\tstrbuf_addf(&buf, \"Merge made by the '%s' strategy.\", wt_strategy);\n\tfinish(head, remoteheads, result_commit, buf.buf);\n\tstrbuf_release(&buf);\n\tdrop_save();\n\treturn 0;\n}\n\nstatic int suggest_conflicts(void)\n{\n\tconst char *filename;\n\tFILE *fp;\n\tstruct strbuf msgbuf = STRBUF_INIT;\n\n\tfilename = git_path_merge_msg();\n\tfp = fopen(filename, \"a\");\n\tif (!fp)\n\t\tdie_errno(_(\"Could not open '%s' for writing\"), filename);\n\n\tappend_conflicts_hint(&msgbuf);\n\tfputs(msgbuf.buf, fp);\n\tstrbuf_release(&msgbuf);\n\tfclose(fp);\n\trerere(allow_rerere_auto);\n\tprintf(_(\"Automatic merge failed; \"\n\t\t\t\"fix conflicts and then commit the result.\\n\"));\n\treturn 1;\n}\n\nstatic struct commit *is_old_style_invocation(int argc, const char **argv,\n\t\t\t\t\t      const unsigned char *head)\n{\n\tstruct commit *second_token = NULL;\n\tif (argc > 2) {\n\t\tunsigned char second_sha1[20];\n\n\t\tif (get_sha1(argv[1], second_sha1))\n\t\t\treturn NULL;\n\t\tsecond_token = lookup_commit_reference_gently(second_sha1, 0);\n\t\tif (!second_token)\n\t\t\tdie(_(\"'%s' is not a commit\"), argv[1]);\n\t\tif (hashcmp(second_token->object.oid.hash, head))\n\t\t\treturn NULL;\n\t}\n\treturn second_token;\n}\n\nstatic int evaluate_result(void)\n{\n\tint cnt = 0;\n\tstruct rev_info rev;\n\n\t/* Check how many files differ. */\n\tinit_revisions(&rev, \"\");\n\tsetup_revisions(0, NULL, &rev, NULL);\n\trev.diffopt.output_format |=\n\t\tDIFF_FORMAT_CALLBACK;\n\trev.diffopt.format_callback = count_diff_files;\n\trev.diffopt.format_callback_data = &cnt;\n\trun_diff_files(&rev, 0);\n\n\t/*\n\t * Check how many unmerged entries are\n\t * there.\n\t */\n\tcnt += count_unmerged_entries();\n\n\treturn cnt;\n}\n\n/*\n * Pretend as if the user told us to merge with the remote-tracking\n * branch we have for the upstream of the current branch\n */\nstatic int setup_with_upstream(const char ***argv)\n{\n\tstruct branch *branch = branch_get(NULL);\n\tint i;\n\tconst char **args;\n\n\tif (!branch)\n\t\tdie(_(\"No current branch.\"));\n\tif (!branch->remote_name)\n\t\tdie(_(\"No remote for the current branch.\"));\n\tif (!branch->merge_nr)\n\t\tdie(_(\"No default upstream defined for the current branch.\"));\n\n\targs = xcalloc(st_add(branch->merge_nr, 1), sizeof(char *));\n\tfor (i = 0; i < branch->merge_nr; i++) {\n\t\tif (!branch->merge[i]->dst)\n\t\t\tdie(_(\"No remote-tracking branch for %s from %s\"),\n\t\t\t    branch->merge[i]->src, branch->remote_name);\n\t\targs[i] = branch->merge[i]->dst;\n\t}\n\targs[i] = NULL;\n\t*argv = args;\n\treturn i;\n}\n\nstatic void write_merge_state(struct commit_list *remoteheads)\n{\n\tstruct commit_list *j;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tfor (j = remoteheads; j; j = j->next) {\n\t\tstruct object_id *oid;\n\t\tstruct commit *c = j->item;\n\t\tif (c->util && merge_remote_util(c)->obj) {\n\t\t\toid = &merge_remote_util(c)->obj->oid;\n\t\t} else {\n\t\t\toid = &c->object.oid;\n\t\t}\n\t\tstrbuf_addf(&buf, \"%s\\n\", oid_to_hex(oid));\n\t}\n\twrite_file_buf(git_path_merge_head(), buf.buf, buf.len);\n\tstrbuf_addch(&merge_msg, '\\n');\n\twrite_file_buf(git_path_merge_msg(), merge_msg.buf, merge_msg.len);\n\n\tstrbuf_reset(&buf);\n\tif (fast_forward == FF_NO)\n\t\tstrbuf_addstr(&buf, \"no-ff\");\n\twrite_file_buf(git_path_merge_mode(), buf.buf, buf.len);\n}\n\nstatic int default_edit_option(void)\n{\n\tstatic const char name[] = \"GIT_MERGE_AUTOEDIT\";\n\tconst char *e = getenv(name);\n\tstruct stat st_stdin, st_stdout;\n\n\tif (have_message)\n\t\t/* an explicit -m msg without --[no-]edit */\n\t\treturn 0;\n\n\tif (e) {\n\t\tint v = git_config_maybe_bool(name, e);\n\t\tif (v < 0)\n\t\t\tdie(_(\"Bad value '%s' in environment '%s'\"), e, name);\n\t\treturn v;\n\t}\n\n\t/* Use editor if stdin and stdout are the same and is a tty */\n\treturn (!fstat(0, &st_stdin) &&\n\t\t!fstat(1, &st_stdout) &&\n\t\tisatty(0) && isatty(1) &&\n\t\tst_stdin.st_dev == st_stdout.st_dev &&\n\t\tst_stdin.st_ino == st_stdout.st_ino &&\n\t\tst_stdin.st_mode == st_stdout.st_mode);\n}\n\nstatic struct commit_list *reduce_parents(struct commit *head_commit,\n\t\t\t\t\t  int *head_subsumed,\n\t\t\t\t\t  struct commit_list *remoteheads)\n{\n\tstruct commit_list *parents, **remotes;\n\n\t/*\n\t * Is the current HEAD reachable from another commit being\n\t * merged?  If so we do not want to record it as a parent of\n\t * the resulting merge, unless --no-ff is given.  We will flip\n\t * this variable to 0 when we find HEAD among the independent\n\t * tips being merged.\n\t */\n\t*head_subsumed = 1;\n\n\t/* Find what parents to record by checking independent ones. */\n\tparents = reduce_heads(remoteheads);\n\n\tremoteheads = NULL;\n\tremotes = &remoteheads;\n\twhile (parents) {\n\t\tstruct commit *commit = pop_commit(&parents);\n\t\tif (commit == head_commit)\n\t\t\t*head_subsumed = 0;\n\t\telse\n\t\t\tremotes = &commit_list_insert(commit, remotes)->next;\n\t}\n\treturn remoteheads;\n}\n\nstatic void prepare_merge_message(struct strbuf *merge_names, struct strbuf *merge_msg)\n{\n\tstruct fmt_merge_msg_opts opts;\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.add_title = !have_message;\n\topts.shortlog_len = shortlog_len;\n\topts.credit_people = (0 < option_edit);\n\n\tfmt_merge_msg(merge_names, merge_msg, &opts);\n\tif (merge_msg->len)\n\t\tstrbuf_setlen(merge_msg, merge_msg->len - 1);\n}\n\nstatic void handle_fetch_head(struct commit_list **remotes, struct strbuf *merge_names)\n{\n\tconst char *filename;\n\tint fd, pos, npos;\n\tstruct strbuf fetch_head_file = STRBUF_INIT;\n\n\tif (!merge_names)\n\t\tmerge_names = &fetch_head_file;\n\n\tfilename = git_path_fetch_head();\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0)\n\t\tdie_errno(_(\"could not open '%s' for reading\"), filename);\n\n\tif (strbuf_read(merge_names, fd, 0) < 0)\n\t\tdie_errno(_(\"could not read '%s'\"), filename);\n\tif (close(fd) < 0)\n\t\tdie_errno(_(\"could not close '%s'\"), filename);\n\n\tfor (pos = 0; pos < merge_names->len; pos = npos) {\n\t\tunsigned char sha1[20];\n\t\tchar *ptr;\n\t\tstruct commit *commit;\n\n\t\tptr = strchr(merge_names->buf + pos, '\\n');\n\t\tif (ptr)\n\t\t\tnpos = ptr - merge_names->buf + 1;\n\t\telse\n\t\t\tnpos = merge_names->len;\n\n\t\tif (npos - pos < 40 + 2 ||\n\t\t    get_sha1_hex(merge_names->buf + pos, sha1))\n\t\t\tcommit = NULL; /* bad */\n\t\telse if (memcmp(merge_names->buf + pos + 40, \"\\t\\t\", 2))\n\t\t\tcontinue; /* not-for-merge */\n\t\telse {\n\t\t\tchar saved = merge_names->buf[pos + 40];\n\t\t\tmerge_names->buf[pos + 40] = '\\0';\n\t\t\tcommit = get_merge_parent(merge_names->buf + pos);\n\t\t\tmerge_names->buf[pos + 40] = saved;\n\t\t}\n\t\tif (!commit) {\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tdie(_(\"not something we can merge in %s: %s\"),\n\t\t\t    filename, merge_names->buf + pos);\n\t\t}\n\t\tremotes = &commit_list_insert(commit, remotes)->next;\n\t}\n\n\tif (merge_names == &fetch_head_file)\n\t\tstrbuf_release(&fetch_head_file);\n}\n\nstatic struct commit_list *collect_parents(struct commit *head_commit,\n\t\t\t\t\t   int *head_subsumed,\n\t\t\t\t\t   int argc, const char **argv,\n\t\t\t\t\t   struct strbuf *merge_msg)\n{\n\tint i;\n\tstruct commit_list *remoteheads = NULL;\n\tstruct commit_list **remotes = &remoteheads;\n\tstruct strbuf merge_names = STRBUF_INIT, *autogen = NULL;\n\n\tif (merge_msg && (!have_message || shortlog_len))\n\t\tautogen = &merge_names;\n\n\tif (head_commit)\n\t\tremotes = &commit_list_insert(head_commit, remotes)->next;\n\n\tif (argc == 1 && !strcmp(argv[0], \"FETCH_HEAD\")) {\n\t\thandle_fetch_head(remotes, autogen);\n\t\tremoteheads = reduce_parents(head_commit, head_subsumed, remoteheads);\n\t} else {\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tstruct commit *commit = get_merge_parent(argv[i]);\n\t\t\tif (!commit)\n\t\t\t\thelp_unknown_ref(argv[i], \"merge\",\n\t\t\t\t\t\t _(\"not something we can merge\"));\n\t\t\tremotes = &commit_list_insert(commit, remotes)->next;\n\t\t}\n\t\tremoteheads = reduce_parents(head_commit, head_subsumed, remoteheads);\n\t\tif (autogen) {\n\t\t\tstruct commit_list *p;\n\t\t\tfor (p = remoteheads; p; p = p->next)\n\t\t\t\tmerge_name(merge_remote_util(p->item)->name, autogen);\n\t\t}\n\t}\n\n\tif (autogen) {\n\t\tprepare_merge_message(autogen, merge_msg);\n\t\tstrbuf_release(autogen);\n\t}\n\n\treturn remoteheads;\n}\n\nint cmd_merge(int argc, const char **argv, const char *prefix)\n{\n\tunsigned char result_tree[20];\n\tunsigned char stash[20];\n\tunsigned char head_sha1[20];\n\tstruct commit *head_commit;\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *head_arg;\n\tint i, ret = 0, head_subsumed;\n\tint best_cnt = -1, merge_was_ok = 0, automerge_was_ok = 0;\n\tstruct commit_list *common = NULL;\n\tconst char *best_strategy = NULL, *wt_strategy = NULL;\n\tstruct commit_list *remoteheads, *p;\n\tvoid *branch_to_free;\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_merge_usage, builtin_merge_options);\n\n\t/*\n\t * Check if we are _not_ on a detached HEAD, i.e. if there is a\n\t * current branch.\n\t */\n\tbranch = branch_to_free = resolve_refdup(\"HEAD\", 0, head_sha1, NULL);\n\tif (branch && starts_with(branch, \"refs/heads/\"))\n\t\tbranch += 11;\n\tif (!branch || is_null_sha1(head_sha1))\n\t\thead_commit = NULL;\n\telse\n\t\thead_commit = lookup_commit_or_die(head_sha1, \"HEAD\");\n\n\tinit_diff_ui_defaults();\n\tgit_config(git_merge_config, NULL);\n\n\tif (branch_mergeoptions)\n\t\tparse_branch_merge_options(branch_mergeoptions);\n\targc = parse_options(argc, argv, prefix, builtin_merge_options,\n\t\t\tbuiltin_merge_usage, 0);\n\tif (shortlog_len < 0)\n\t\tshortlog_len = (merge_log_config > 0) ? merge_log_config : 0;\n\n\tif (verbosity < 0 && show_progress == -1)\n\t\tshow_progress = 0;\n\n\tif (abort_current_merge) {\n\t\tint nargc = 2;\n\t\tconst char *nargv[] = {\"reset\", \"--merge\", NULL};\n\n\t\tif (!file_exists(git_path_merge_head()))\n\t\t\tdie(_(\"There is no merge to abort (MERGE_HEAD missing).\"));\n\n\t\t/* Invoke 'git reset --merge' */\n\t\tret = cmd_reset(nargc, nargv, prefix);\n\t\tgoto done;\n\t}\n\n\tif (read_cache_unmerged())\n\t\tdie_resolve_conflict(\"merge\");\n\n\tif (file_exists(git_path_merge_head())) {\n\t\t/*\n\t\t * There is no unmerged entry, don't advise 'git\n\t\t * add/rm <file>', just 'git commit'.\n\t\t */\n\t\tif (advice_resolve_conflict)\n\t\t\tdie(_(\"You have not concluded your merge (MERGE_HEAD exists).\\n\"\n\t\t\t\t  \"Please, commit your changes before you merge.\"));\n\t\telse\n\t\t\tdie(_(\"You have not concluded your merge (MERGE_HEAD exists).\"));\n\t}\n\tif (file_exists(git_path_cherry_pick_head())) {\n\t\tif (advice_resolve_conflict)\n\t\t\tdie(_(\"You have not concluded your cherry-pick (CHERRY_PICK_HEAD exists).\\n\"\n\t\t\t    \"Please, commit your changes before you merge.\"));\n\t\telse\n\t\t\tdie(_(\"You have not concluded your cherry-pick (CHERRY_PICK_HEAD exists).\"));\n\t}\n\tresolve_undo_clear();\n\n\tif (verbosity < 0)\n\t\tshow_diffstat = 0;\n\n\tif (squash) {\n\t\tif (fast_forward == FF_NO)\n\t\t\tdie(_(\"You cannot combine --squash with --no-ff.\"));\n\t\toption_commit = 0;\n\t}\n\n\tif (!argc) {\n\t\tif (default_to_upstream)\n\t\t\targc = setup_with_upstream(&argv);\n\t\telse\n\t\t\tdie(_(\"No commit specified and merge.defaultToUpstream not set.\"));\n\t} else if (argc == 1 && !strcmp(argv[0], \"-\")) {\n\t\targv[0] = \"@{-1}\";\n\t}\n\n\tif (!argc)\n\t\tusage_with_options(builtin_merge_usage,\n\t\t\tbuiltin_merge_options);\n\n\tif (!head_commit) {\n\t\t/*\n\t\t * If the merged head is a valid one there is no reason\n\t\t * to forbid \"git merge\" into a branch yet to be born.\n\t\t * We do the same for \"git pull\".\n\t\t */\n\t\tunsigned char *remote_head_sha1;\n\t\tif (squash)\n\t\t\tdie(_(\"Squash commit into empty head not supported yet\"));\n\t\tif (fast_forward == FF_NO)\n\t\t\tdie(_(\"Non-fast-forward commit does not make sense into \"\n\t\t\t    \"an empty head\"));\n\t\tremoteheads = collect_parents(head_commit, &head_subsumed,\n\t\t\t\t\t      argc, argv, NULL);\n\t\tif (!remoteheads)\n\t\t\tdie(_(\"%s - not something we can merge\"), argv[0]);\n\t\tif (remoteheads->next)\n\t\t\tdie(_(\"Can merge only exactly one commit into empty head\"));\n\t\tremote_head_sha1 = remoteheads->item->object.oid.hash;\n\t\tread_empty(remote_head_sha1, 0);\n\t\tupdate_ref(\"initial pull\", \"HEAD\", remote_head_sha1,\n\t\t\t   NULL, 0, UPDATE_REFS_DIE_ON_ERR);\n\t\tgoto done;\n\t}\n\n\t/*\n\t * This could be traditional \"merge <msg> HEAD <commit>...\"  and\n\t * the way we can tell it is to see if the second token is HEAD,\n\t * but some people might have misused the interface and used a\n\t * commit-ish that is the same as HEAD there instead.\n\t * Traditional format never would have \"-m\" so it is an\n\t * additional safety measure to check for it.\n\t */\n\tif (!have_message &&\n\t    is_old_style_invocation(argc, argv, head_commit->object.oid.hash)) {\n\t\twarning(\"old-style 'git merge <msg> HEAD <commit>' is deprecated.\");\n\t\tstrbuf_addstr(&merge_msg, argv[0]);\n\t\thead_arg = argv[1];\n\t\targv += 2;\n\t\targc -= 2;\n\t\tremoteheads = collect_parents(head_commit, &head_subsumed,\n\t\t\t\t\t      argc, argv, NULL);\n\t} else {\n\t\t/* We are invoked directly as the first-class UI. */\n\t\thead_arg = \"HEAD\";\n\n\t\t/*\n\t\t * All the rest are the commits being merged; prepare\n\t\t * the standard merge summary message to be appended\n\t\t * to the given message.\n\t\t */\n\t\tremoteheads = collect_parents(head_commit, &head_subsumed,\n\t\t\t\t\t      argc, argv, &merge_msg);\n\t}\n\n\tif (!head_commit || !argc)\n\t\tusage_with_options(builtin_merge_usage,\n\t\t\tbuiltin_merge_options);\n\n\tif (verify_signatures) {\n\t\tfor (p = remoteheads; p; p = p->next) {\n\t\t\tstruct commit *commit = p->item;\n\t\t\tchar hex[GIT_SHA1_HEXSZ + 1];\n\t\t\tstruct signature_check signature_check;\n\t\t\tmemset(&signature_check, 0, sizeof(signature_check));\n\n\t\t\tcheck_commit_signature(commit, &signature_check);\n\n\t\t\tfind_unique_abbrev_r(hex, commit->object.oid.hash, DEFAULT_ABBREV);\n\t\t\tswitch (signature_check.result) {\n\t\t\tcase 'G':\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\tdie(_(\"Commit %s has an untrusted GPG signature, \"\n\t\t\t\t      \"allegedly by %s.\"), hex, signature_check.signer);\n\t\t\tcase 'B':\n\t\t\t\tdie(_(\"Commit %s has a bad GPG signature \"\n\t\t\t\t      \"allegedly by %s.\"), hex, signature_check.signer);\n\t\t\tdefault: /* 'N' */\n\t\t\t\tdie(_(\"Commit %s does not have a GPG signature.\"), hex);\n\t\t\t}\n\t\t\tif (verbosity >= 0 && signature_check.result == 'G')\n\t\t\t\tprintf(_(\"Commit %s has a good GPG signature by %s\\n\"),\n\t\t\t\t       hex, signature_check.signer);\n\n\t\t\tsignature_check_clear(&signature_check);\n\t\t}\n\t}\n\n\tstrbuf_addstr(&buf, \"merge\");\n\tfor (p = remoteheads; p; p = p->next)\n\t\tstrbuf_addf(&buf, \" %s\", merge_remote_util(p->item)->name);\n\tsetenv(\"GIT_REFLOG_ACTION\", buf.buf, 0);\n\tstrbuf_reset(&buf);\n\n\tfor (p = remoteheads; p; p = p->next) {\n\t\tstruct commit *commit = p->item;\n\t\tstrbuf_addf(&buf, \"GITHEAD_%s\",\n\t\t\t    oid_to_hex(&commit->object.oid));\n\t\tsetenv(buf.buf, merge_remote_util(commit)->name, 1);\n\t\tstrbuf_reset(&buf);\n\t\tif (fast_forward != FF_ONLY &&\n\t\t    merge_remote_util(commit) &&\n\t\t    merge_remote_util(commit)->obj &&\n\t\t    merge_remote_util(commit)->obj->type == OBJ_TAG)\n\t\t\tfast_forward = FF_NO;\n\t}\n\n\tif (option_edit < 0)\n\t\toption_edit = default_edit_option();\n\n\tif (!use_strategies) {\n\t\tif (!remoteheads)\n\t\t\t; /* already up-to-date */\n\t\telse if (!remoteheads->next)\n\t\t\tadd_strategies(pull_twohead, DEFAULT_TWOHEAD);\n\t\telse\n\t\t\tadd_strategies(pull_octopus, DEFAULT_OCTOPUS);\n\t}\n\n\tfor (i = 0; i < use_strategies_nr; i++) {\n\t\tif (use_strategies[i]->attr & NO_FAST_FORWARD)\n\t\t\tfast_forward = FF_NO;\n\t\tif (use_strategies[i]->attr & NO_TRIVIAL)\n\t\t\tallow_trivial = 0;\n\t}\n\n\tif (!remoteheads)\n\t\t; /* already up-to-date */\n\telse if (!remoteheads->next)\n\t\tcommon = get_merge_bases(head_commit, remoteheads->item);\n\telse {\n\t\tstruct commit_list *list = remoteheads;\n\t\tcommit_list_insert(head_commit, &list);\n\t\tcommon = get_octopus_merge_bases(list);\n\t\tfree(list);\n\t}\n\n\tupdate_ref(\"updating ORIG_HEAD\", \"ORIG_HEAD\", head_commit->object.oid.hash,\n\t\t   NULL, 0, UPDATE_REFS_DIE_ON_ERR);\n\n\tif (remoteheads && !common) {\n\t\t/* No common ancestors found. */\n\t\tif (!allow_unrelated_histories)\n\t\t\tdie(_(\"refusing to merge unrelated histories\"));\n\t\t/* otherwise, we need a real merge. */\n\t} else if (!remoteheads ||\n\t\t (!remoteheads->next && !common->next &&\n\t\t  common->item == remoteheads->item)) {\n\t\t/*\n\t\t * If head can reach all the merge then we are up to date.\n\t\t * but first the most common case of merging one remote.\n\t\t */\n\t\tfinish_up_to_date(_(\"Already up-to-date.\"));\n\t\tgoto done;\n\t} else if (fast_forward != FF_NO && !remoteheads->next &&\n\t\t\t!common->next &&\n\t\t\t!oidcmp(&common->item->object.oid, &head_commit->object.oid)) {\n\t\t/* Again the most common case of merging one remote. */\n\t\tstruct strbuf msg = STRBUF_INIT;\n\t\tstruct commit *commit;\n\n\t\tif (verbosity >= 0) {\n\t\t\tprintf(_(\"Updating %s..%s\\n\"),\n\t\t\t       find_unique_abbrev(head_commit->object.oid.hash,\n\t\t\t\t\t\t  DEFAULT_ABBREV),\n\t\t\t       find_unique_abbrev(remoteheads->item->object.oid.hash,\n\t\t\t\t\t\t  DEFAULT_ABBREV));\n\t\t}\n\t\tstrbuf_addstr(&msg, \"Fast-forward\");\n\t\tif (have_message)\n\t\t\tstrbuf_addstr(&msg,\n\t\t\t\t\" (no commit created; -m option ignored)\");\n\t\tcommit = remoteheads->item;\n\t\tif (!commit) {\n\t\t\tret = 1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (checkout_fast_forward(head_commit->object.oid.hash,\n\t\t\t\t\t  commit->object.oid.hash,\n\t\t\t\t\t  overwrite_ignore)) {\n\t\t\tret = 1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tfinish(head_commit, remoteheads, commit->object.oid.hash, msg.buf);\n\t\tdrop_save();\n\t\tgoto done;\n\t} else if (!remoteheads->next && common->next)\n\t\t;\n\t\t/*\n\t\t * We are not doing octopus and not fast-forward.  Need\n\t\t * a real merge.\n\t\t */\n\telse if (!remoteheads->next && !common->next && option_commit) {\n\t\t/*\n\t\t * We are not doing octopus, not fast-forward, and have\n\t\t * only one common.\n\t\t */\n\t\trefresh_cache(REFRESH_QUIET);\n\t\tif (allow_trivial && fast_forward != FF_ONLY) {\n\t\t\t/* See if it is really trivial. */\n\t\t\tgit_committer_info(IDENT_STRICT);\n\t\t\tprintf(_(\"Trying really trivial in-index merge...\\n\"));\n\t\t\tif (!read_tree_trivial(common->item->object.oid.hash,\n\t\t\t\t\t       head_commit->object.oid.hash,\n\t\t\t\t\t       remoteheads->item->object.oid.hash)) {\n\t\t\t\tret = merge_trivial(head_commit, remoteheads);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tprintf(_(\"Nope.\\n\"));\n\t\t}\n\t} else {\n\t\t/*\n\t\t * An octopus.  If we can reach all the remote we are up\n\t\t * to date.\n\t\t */\n\t\tint up_to_date = 1;\n\t\tstruct commit_list *j;\n\n\t\tfor (j = remoteheads; j; j = j->next) {\n\t\t\tstruct commit_list *common_one;\n\n\t\t\t/*\n\t\t\t * Here we *have* to calculate the individual\n\t\t\t * merge_bases again, otherwise \"git merge HEAD^\n\t\t\t * HEAD^^\" would be missed.\n\t\t\t */\n\t\t\tcommon_one = get_merge_bases(head_commit, j->item);\n\t\t\tif (oidcmp(&common_one->item->object.oid, &j->item->object.oid)) {\n\t\t\t\tup_to_date = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (up_to_date) {\n\t\t\tfinish_up_to_date(_(\"Already up-to-date. Yeeah!\"));\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (fast_forward == FF_ONLY)\n\t\tdie(_(\"Not possible to fast-forward, aborting.\"));\n\n\t/* We are going to make a new commit. */\n\tgit_committer_info(IDENT_STRICT);\n\n\t/*\n\t * At this point, we need a real merge.  No matter what strategy\n\t * we use, it would operate on the index, possibly affecting the\n\t * working tree, and when resolved cleanly, have the desired\n\t * tree in the index -- this means that the index must be in\n\t * sync with the head commit.  The strategies are responsible\n\t * to ensure this.\n\t */\n\tif (use_strategies_nr == 1 ||\n\t    /*\n\t     * Stash away the local changes so that we can try more than one.\n\t     */\n\t    save_state(stash))\n\t\thashclr(stash);\n\n\tfor (i = 0; i < use_strategies_nr; i++) {\n\t\tint ret;\n\t\tif (i) {\n\t\t\tprintf(_(\"Rewinding the tree to pristine...\\n\"));\n\t\t\trestore_state(head_commit->object.oid.hash, stash);\n\t\t}\n\t\tif (use_strategies_nr != 1)\n\t\t\tprintf(_(\"Trying merge strategy %s...\\n\"),\n\t\t\t\tuse_strategies[i]->name);\n\t\t/*\n\t\t * Remember which strategy left the state in the working\n\t\t * tree.\n\t\t */\n\t\twt_strategy = use_strategies[i]->name;\n\n\t\tret = try_merge_strategy(use_strategies[i]->name,\n\t\t\t\t\t common, remoteheads,\n\t\t\t\t\t head_commit, head_arg);\n\t\tif (!option_commit && !ret) {\n\t\t\tmerge_was_ok = 1;\n\t\t\t/*\n\t\t\t * This is necessary here just to avoid writing\n\t\t\t * the tree, but later we will *not* exit with\n\t\t\t * status code 1 because merge_was_ok is set.\n\t\t\t */\n\t\t\tret = 1;\n\t\t}\n\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * The backend exits with 1 when conflicts are\n\t\t\t * left to be resolved, with 2 when it does not\n\t\t\t * handle the given merge at all.\n\t\t\t */\n\t\t\tif (ret == 1) {\n\t\t\t\tint cnt = evaluate_result();\n\n\t\t\t\tif (best_cnt <= 0 || cnt <= best_cnt) {\n\t\t\t\t\tbest_strategy = use_strategies[i]->name;\n\t\t\t\t\tbest_cnt = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (merge_was_ok)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Automerge succeeded. */\n\t\twrite_tree_trivial(result_tree);\n\t\tautomerge_was_ok = 1;\n\t\tbreak;\n\t}\n\n\t/*\n\t * If we have a resulting tree, that means the strategy module\n\t * auto resolved the merge cleanly.\n\t */\n\tif (automerge_was_ok) {\n\t\tret = finish_automerge(head_commit, head_subsumed,\n\t\t\t\t       common, remoteheads,\n\t\t\t\t       result_tree, wt_strategy);\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Pick the result from the best strategy and have the user fix\n\t * it up.\n\t */\n\tif (!best_strategy) {\n\t\trestore_state(head_commit->object.oid.hash, stash);\n\t\tif (use_strategies_nr > 1)\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"No merge strategy handled the merge.\\n\"));\n\t\telse\n\t\t\tfprintf(stderr, _(\"Merge with strategy %s failed.\\n\"),\n\t\t\t\tuse_strategies[0]->name);\n\t\tret = 2;\n\t\tgoto done;\n\t} else if (best_strategy == wt_strategy)\n\t\t; /* We already have its result in the working tree. */\n\telse {\n\t\tprintf(_(\"Rewinding the tree to pristine...\\n\"));\n\t\trestore_state(head_commit->object.oid.hash, stash);\n\t\tprintf(_(\"Using the %s to prepare resolving by hand.\\n\"),\n\t\t\tbest_strategy);\n\t\ttry_merge_strategy(best_strategy, common, remoteheads,\n\t\t\t\t   head_commit, head_arg);\n\t}\n\n\tif (squash)\n\t\tfinish(head_commit, remoteheads, NULL, NULL);\n\telse\n\t\twrite_merge_state(remoteheads);\n\n\tif (merge_was_ok)\n\t\tfprintf(stderr, _(\"Automatic merge went well; \"\n\t\t\t\"stopped before committing as requested\\n\"));\n\telse\n\t\tret = suggest_conflicts();\n\ndone:\n\tfree(branch_to_free);\n\treturn ret;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0070bf255612ea9d4826720df7a77dd8ccb762e8",
  "sha1_ok": true,
  "size": 43868
}
