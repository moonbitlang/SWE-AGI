{
  "content": {
    "base64": "I2RlZmluZSBVU0VfVEhFX1JFUE9TSVRPUllfVkFSSUFCTEUKCiNpbmNsdWRlICJnaXQtY29tcGF0LXV0aWwuaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJjb21taXQtZ3JhcGguaCIKI2luY2x1ZGUgImVudmlyb25tZW50LmgiCiNpbmNsdWRlICJnZXR0ZXh0LmgiCiNpbmNsdWRlICJoZXguaCIKI2luY2x1ZGUgInJlcG9zaXRvcnkuaCIKI2luY2x1ZGUgIm9iamVjdC1uYW1lLmgiCiNpbmNsdWRlICJvYmplY3Qtc3RvcmUuaCIKI2luY2x1ZGUgInV0ZjguaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgInJldmlzaW9uLmgiCiNpbmNsdWRlICJub3Rlcy5oIgojaW5jbHVkZSAiYWxsb2MuaCIKI2luY2x1ZGUgImdwZy1pbnRlcmZhY2UuaCIKI2luY2x1ZGUgIm1lcmdlc29ydC5oIgojaW5jbHVkZSAiY29tbWl0LXNsYWIuaCIKI2luY2x1ZGUgInByaW8tcXVldWUuaCIKI2luY2x1ZGUgImhhc2gtbG9va3VwLmgiCiNpbmNsdWRlICJ3dC1zdGF0dXMuaCIKI2luY2x1ZGUgImFkdmljZS5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAiY29tbWl0LXJlYWNoLmgiCiNpbmNsdWRlICJzZXR1cC5oIgojaW5jbHVkZSAic2hhbGxvdy5oIgojaW5jbHVkZSAidHJlZS5oIgojaW5jbHVkZSAiaG9vay5oIgojaW5jbHVkZSAicGFyc2UuaCIKI2luY2x1ZGUgIm9iamVjdC1maWxlLmgiCiNpbmNsdWRlICJvYmplY3QtZmlsZS1jb252ZXJ0LmgiCgpzdGF0aWMgc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKnJlYWRfY29tbWl0X2V4dHJhX2hlYWRlcl9saW5lcyhjb25zdCBjaGFyICpidWYsIHNpemVfdCBsZW4sIGNvbnN0IGNoYXIgKiopOwoKaW50IHNhdmVfY29tbWl0X2J1ZmZlciA9IDE7CmludCBub19ncmFmdF9maWxlX2RlcHJlY2F0ZWRfYWR2aWNlOwoKY29uc3QgY2hhciAqY29tbWl0X3R5cGUgPSAiY29tbWl0IjsKCnN0cnVjdCBjb21taXQgKmxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGludCBxdWlldCkKewoJc3RydWN0IG9iamVjdCAqb2JqID0gZGVyZWZfdGFnKHIsCgkJCQkgICAgICAgcGFyc2Vfb2JqZWN0KHIsIG9pZCksCgkJCQkgICAgICAgTlVMTCwgMCk7CgoJaWYgKCFvYmopCgkJcmV0dXJuIE5VTEw7CglyZXR1cm4gb2JqZWN0X2FzX3R5cGUob2JqLCBPQkpfQ09NTUlULCBxdWlldCk7Cn0KCnN0cnVjdCBjb21taXQgKmxvb2t1cF9jb21taXRfcmVmZXJlbmNlKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXJldHVybiBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkociwgb2lkLCAwKTsKfQoKc3RydWN0IGNvbW1pdCAqbG9va3VwX2NvbW1pdF9vcl9kaWUoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBjb25zdCBjaGFyICpyZWZfbmFtZSkKewoJc3RydWN0IGNvbW1pdCAqYyA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlKHRoZV9yZXBvc2l0b3J5LCBvaWQpOwoJaWYgKCFjKQoJCWRpZShfKCJjb3VsZCBub3QgcGFyc2UgJXMiKSwgcmVmX25hbWUpOwoJaWYgKCFvaWRlcShvaWQsICZjLT5vYmplY3Qub2lkKSkgewoJCXdhcm5pbmcoXygiJXMgJXMgaXMgbm90IGEgY29tbWl0ISIpLAoJCQlyZWZfbmFtZSwgb2lkX3RvX2hleChvaWQpKTsKCX0KCXJldHVybiBjOwp9CgpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0X29iamVjdChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJCSAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXN0cnVjdCBvYmplY3QgKm9iaiA9IHBhcnNlX29iamVjdChyLCBvaWQpOwoJcmV0dXJuIG9iaiA/IG9iamVjdF9hc190eXBlKG9iaiwgT0JKX0NPTU1JVCwgMCkgOiBOVUxMOwoKfQoKc3RydWN0IGNvbW1pdCAqbG9va3VwX2NvbW1pdChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmogPSBsb29rdXBfb2JqZWN0KHIsIG9pZCk7CglpZiAoIW9iaikKCQlyZXR1cm4gY3JlYXRlX29iamVjdChyLCBvaWQsIGFsbG9jX2NvbW1pdF9ub2RlKHIpKTsKCXJldHVybiBvYmplY3RfYXNfdHlwZShvYmosIE9CSl9DT01NSVQsIDApOwp9CgpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9ieV9uYW1lKGNvbnN0IGNoYXIgKm5hbWUpCnsKCXJldHVybiBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9ieV9uYW1lX2dlbnRseShuYW1lLCAwKTsKfQoKc3RydWN0IGNvbW1pdCAqbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfYnlfbmFtZV9nZW50bHkoY29uc3QgY2hhciAqbmFtZSwKCQkJCQkJICAgICAgaW50IHF1aWV0KQp7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCglpZiAocmVwb19nZXRfb2lkX2NvbW1pdHRpc2godGhlX3JlcG9zaXRvcnksIG5hbWUsICZvaWQpKQoJCXJldHVybiBOVUxMOwoJY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfZ2VudGx5KHRoZV9yZXBvc2l0b3J5LCAmb2lkLCBxdWlldCk7CglpZiAocmVwb19wYXJzZV9jb21taXQodGhlX3JlcG9zaXRvcnksIGNvbW1pdCkpCgkJcmV0dXJuIE5VTEw7CglyZXR1cm4gY29tbWl0Owp9CgpzdGF0aWMgdGltZXN0YW1wX3QgcGFyc2VfY29tbWl0X2RhdGUoY29uc3QgY2hhciAqYnVmLCBjb25zdCBjaGFyICp0YWlsKQp7Cgljb25zdCBjaGFyICpkYXRlcHRyOwoJY29uc3QgY2hhciAqZW9sOwoKCWlmIChidWYgKyA2ID49IHRhaWwpCgkJcmV0dXJuIDA7CglpZiAobWVtY21wKGJ1ZiwgImF1dGhvciIsIDYpKQoJCXJldHVybiAwOwoJd2hpbGUgKGJ1ZiA8IHRhaWwgJiYgKmJ1ZisrICE9ICdcbicpCgkJLyogbmFkYSAqLzsKCWlmIChidWYgKyA5ID49IHRhaWwpCgkJcmV0dXJuIDA7CglpZiAobWVtY21wKGJ1ZiwgImNvbW1pdHRlciIsIDkpKQoJCXJldHVybiAwOwoKCS8qCgkgKiBKdW1wIHRvIGVuZC1vZi1saW5lIHNvIHRoYXQgd2UgY2FuIHdhbGsgYmFja3dhcmRzIHRvIGZpbmQgdGhlCgkgKiBlbmQtb2YtZW1haWwgIj4iLiBUaGlzIGlzIG1vcmUgZm9yZ2l2aW5nIG9mIG1hbGZvcm1lZCBjYXNlcwoJICogYmVjYXVzZSB1bmV4cGVjdGVkIGNoYXJhY3RlcnMgdGVuZCB0byBiZSBpbiB0aGUgbmFtZSBhbmQgZW1haWwKCSAqIGZpZWxkcy4KCSAqLwoJZW9sID0gbWVtY2hyKGJ1ZiwgJ1xuJywgdGFpbCAtIGJ1Zik7CglpZiAoIWVvbCkKCQlyZXR1cm4gMDsKCWRhdGVwdHIgPSBlb2w7Cgl3aGlsZSAoZGF0ZXB0ciA+IGJ1ZiAmJiBkYXRlcHRyWy0xXSAhPSAnPicpCgkJZGF0ZXB0ci0tOwoJaWYgKGRhdGVwdHIgPT0gYnVmKQoJCXJldHVybiAwOwoKCS8qCgkgKiBUcmltIGxlYWRpbmcgd2hpdGVzcGFjZSwgYnV0IG1ha2Ugc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IG9uZQoJICogbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLCBhcyBwYXJzZV90aW1lc3RhbXAoKSB3aWxsIG90aGVyd2lzZSB3YWxrCgkgKiByaWdodCBwYXN0IHRoZSBuZXdsaW5lIHdlIGZvdW5kIGluICJlb2wiIHdoZW4gc2tpcHBpbmcgd2hpdGVzcGFjZQoJICogaXRzZWxmLgoJICoKCSAqIEluIHRoZW9yeSBpdCB3b3VsZCBiZSBzdWZmaWNpZW50IHRvIGFsbG93IGFueSBjaGFyYWN0ZXIgbm90IG1hdGNoZWQKCSAqIGJ5IGlzc3BhY2UoKSwgYnV0IHRoZXJlJ3MgYSBjYXRjaDogb3VyIGlzc3BhY2UoKSBkb2VzIG5vdAoJICogbmVjZXNzYXJpbHkgbWF0Y2ggdGhlIGJlaGF2aW9yIG9mIHBhcnNlX3RpbWVzdGFtcCgpLCBhcyB0aGUgbGF0dGVyCgkgKiBpcyBpbXBsZW1lbnRlZCBieSBzeXN0ZW0gcm91dGluZXMgd2hpY2ggbWF0Y2ggbW9yZSBleG90aWMgY29udHJvbAoJICogY29kZXMsIG9yIGV2ZW4gbG9jYWxlLWRlcGVuZGVudCBzZXF1ZW5jZXMuCgkgKgoJICogU2luY2Ugd2UgZXhwZWN0IHRoZSB0aW1lc3RhbXAgdG8gYmUgYSBudW1iZXIsIHdlIGNhbiBjaGVjayBmb3IgdGhhdC4KCSAqIEFueXRoaW5nIGVsc2UgKGUuZy4sIGEgbm9uLW51bWVyaWMgdG9rZW4gbGlrZSAiZm9vIikgd291bGQganVzdAoJICogY2F1c2UgcGFyc2VfdGltZXN0YW1wKCkgdG8gcmV0dXJuIDAgYW55d2F5LgoJICovCgl3aGlsZSAoZGF0ZXB0ciA8IGVvbCAmJiBpc3NwYWNlKCpkYXRlcHRyKSkKCQlkYXRlcHRyKys7CglpZiAoIWlzZGlnaXQoKmRhdGVwdHIpICYmICpkYXRlcHRyICE9ICctJykKCQlyZXR1cm4gMDsKCgkvKgoJICogV2Uga25vdyB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZGlnaXQgKG9yIGRhc2gpLCBzbyB3ZSdsbCBiZWdpbgoJICogcGFyc2luZyB0aGVyZSBhbmQgc3RvcCBhdCB3b3JzdCBjYXNlIGF0IGVvbC4KCSAqCgkgKiBOb3RlIHRoYXQgd2UgbWF5IGZlZWQgcGFyc2VfdGltZXN0YW1wKCkgZXh0cmEgY2hhcmFjdGVycyBoZXJlIGlmIHRoZQoJICogY29tbWl0IGlzIG1hbGZvcm1lZCwgYW5kIGl0IHdpbGwgcGFyc2UgYXMgZmFyIGFzIGl0IGNhbi4gRm9yCgkgKiBleGFtcGxlLCAiMTIzZm9vNDU2IiB3b3VsZCByZXR1cm4gIjEyMyIuIFRoYXQgbWlnaHQgYmUgcXVlc3Rpb25hYmxlCgkgKiAodmVyc3VzIHJldHVybmluZyAiMCIpLCBidXQgaXQgd291bGQgaGVscCBpbiBhIGh5cG90aGV0aWNhbCBjYXNlCgkgKiBsaWtlICIxMjM0NTYrMDEwMCIsIHdoZXJlIHRoZSB3aGl0ZXNwYWNlIGZyb20gdGhlIHRpbWV6b25lIGlzCgkgKiBtaXNzaW5nLiBTaW5jZSBzdWNoIHN5bnRhY3RpYyBlcnJvcnMgbWF5IGJlIGJha2VkIGludG8gaGlzdG9yeSBhbmQKCSAqIGhhcmQgdG8gY29ycmVjdCBub3csIGxldCdzIGVyciBvbiB0cnlpbmcgdG8gbWFrZSBvdXIgYmVzdCBndWVzcwoJICogaGVyZSwgcmF0aGVyIHRoYW4gaW5zaXN0IG9uIHBlcmZlY3Qgc3ludGF4LgoJICovCglyZXR1cm4gcGFyc2VfdGltZXN0YW1wKGRhdGVwdHIsIE5VTEwsIDEwKTsKfQoKc3RhdGljIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKmNvbW1pdF9ncmFmdF9vaWRfYWNjZXNzKHNpemVfdCBpbmRleCwgY29uc3Qgdm9pZCAqdGFibGUpCnsKCWNvbnN0IHN0cnVjdCBjb21taXRfZ3JhZnQgKiBjb25zdCAqY29tbWl0X2dyYWZ0X3RhYmxlID0gdGFibGU7CglyZXR1cm4gJmNvbW1pdF9ncmFmdF90YWJsZVtpbmRleF0tPm9pZDsKfQoKaW50IGNvbW1pdF9ncmFmdF9wb3Moc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJcmV0dXJuIG9pZF9wb3Mob2lkLCByLT5wYXJzZWRfb2JqZWN0cy0+Z3JhZnRzLAoJCSAgICAgICByLT5wYXJzZWRfb2JqZWN0cy0+Z3JhZnRzX25yLAoJCSAgICAgICBjb21taXRfZ3JhZnRfb2lkX2FjY2Vzcyk7Cn0KCnZvaWQgdW5wYXJzZV9jb21taXQoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJc3RydWN0IGNvbW1pdCAqYyA9IGxvb2t1cF9jb21taXQociwgb2lkKTsKCglpZiAoIWMtPm9iamVjdC5wYXJzZWQpCgkJcmV0dXJuOwoJZnJlZV9jb21taXRfbGlzdChjLT5wYXJlbnRzKTsKCWMtPnBhcmVudHMgPSBOVUxMOwoJYy0+b2JqZWN0LnBhcnNlZCA9IDA7Cn0KCmludCByZWdpc3Rlcl9jb21taXRfZ3JhZnQoc3RydWN0IHJlcG9zaXRvcnkgKnIsIHN0cnVjdCBjb21taXRfZ3JhZnQgKmdyYWZ0LAoJCQkgIGludCBpZ25vcmVfZHVwcykKewoJaW50IHBvcyA9IGNvbW1pdF9ncmFmdF9wb3MociwgJmdyYWZ0LT5vaWQpOwoKCWlmICgwIDw9IHBvcykgewoJCWlmIChpZ25vcmVfZHVwcykKCQkJZnJlZShncmFmdCk7CgkJZWxzZSB7CgkJCWZyZWUoci0+cGFyc2VkX29iamVjdHMtPmdyYWZ0c1twb3NdKTsKCQkJci0+cGFyc2VkX29iamVjdHMtPmdyYWZ0c1twb3NdID0gZ3JhZnQ7CgkJfQoJCXJldHVybiAxOwoJfQoJcG9zID0gLXBvcyAtIDE7CglBTExPQ19HUk9XKHItPnBhcnNlZF9vYmplY3RzLT5ncmFmdHMsCgkJICAgci0+cGFyc2VkX29iamVjdHMtPmdyYWZ0c19uciArIDEsCgkJICAgci0+cGFyc2VkX29iamVjdHMtPmdyYWZ0c19hbGxvYyk7CglyLT5wYXJzZWRfb2JqZWN0cy0+Z3JhZnRzX25yKys7CglpZiAocG9zIDwgci0+cGFyc2VkX29iamVjdHMtPmdyYWZ0c19ucikKCQltZW1tb3ZlKHItPnBhcnNlZF9vYmplY3RzLT5ncmFmdHMgKyBwb3MgKyAxLAoJCQlyLT5wYXJzZWRfb2JqZWN0cy0+Z3JhZnRzICsgcG9zLAoJCQkoci0+cGFyc2VkX29iamVjdHMtPmdyYWZ0c19uciAtIHBvcyAtIDEpICoKCQkJc2l6ZW9mKCpyLT5wYXJzZWRfb2JqZWN0cy0+Z3JhZnRzKSk7CglyLT5wYXJzZWRfb2JqZWN0cy0+Z3JhZnRzW3Bvc10gPSBncmFmdDsKCXVucGFyc2VfY29tbWl0KHIsICZncmFmdC0+b2lkKTsKCXJldHVybiAwOwp9CgpzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpyZWFkX2dyYWZ0X2xpbmUoc3RydWN0IHN0cmJ1ZiAqbGluZSkKewoJLyogVGhlIGZvcm1hdCBpcyBqdXN0ICJDb21taXQgUGFyZW50MSBQYXJlbnQyIC4uLlxuIiAqLwoJaW50IGksIHBoYXNlOwoJY29uc3QgY2hhciAqdGFpbCA9IE5VTEw7CglzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpncmFmdCA9IE5VTEw7CglzdHJ1Y3Qgb2JqZWN0X2lkIGR1bW15X29pZCwgKm9pZDsKCglzdHJidWZfcnRyaW0obGluZSk7CglpZiAoIWxpbmUtPmxlbiB8fCBsaW5lLT5idWZbMF0gPT0gJyMnKQoJCXJldHVybiBOVUxMOwoJLyoKCSAqIHBoYXNlIDAgdmVyaWZpZXMgbGluZSwgY291bnRzIGhhc2hlcyBpbiBsaW5lIGFuZCBhbGxvY2F0ZXMgZ3JhZnQKCSAqIHBoYXNlIDEgZmlsbHMgZ3JhZnQKCSAqLwoJZm9yIChwaGFzZSA9IDA7IHBoYXNlIDwgMjsgcGhhc2UrKykgewoJCW9pZCA9IGdyYWZ0ID8gJmdyYWZ0LT5vaWQgOiAmZHVtbXlfb2lkOwoJCWlmIChwYXJzZV9vaWRfaGV4KGxpbmUtPmJ1Ziwgb2lkLCAmdGFpbCkpCgkJCWdvdG8gYmFkX2dyYWZ0X2RhdGE7CgkJZm9yIChpID0gMDsgKnRhaWwgIT0gJ1wwJzsgaSsrKSB7CgkJCW9pZCA9IGdyYWZ0ID8gJmdyYWZ0LT5wYXJlbnRbaV0gOiAmZHVtbXlfb2lkOwoJCQlpZiAoIWlzc3BhY2UoKnRhaWwrKykgfHwgcGFyc2Vfb2lkX2hleCh0YWlsLCBvaWQsICZ0YWlsKSkKCQkJCWdvdG8gYmFkX2dyYWZ0X2RhdGE7CgkJfQoJCWlmICghZ3JhZnQpIHsKCQkJZ3JhZnQgPSB4bWFsbG9jKHN0X2FkZChzaXplb2YoKmdyYWZ0KSwKCQkJCQkgICAgICAgc3RfbXVsdChzaXplb2Yoc3RydWN0IG9iamVjdF9pZCksIGkpKSk7CgkJCWdyYWZ0LT5ucl9wYXJlbnQgPSBpOwoJCX0KCX0KCXJldHVybiBncmFmdDsKCmJhZF9ncmFmdF9kYXRhOgoJZXJyb3IoImJhZCBncmFmdCBkYXRhOiAlcyIsIGxpbmUtPmJ1Zik7Cglhc3NlcnQoIWdyYWZ0KTsKCXJldHVybiBOVUxMOwp9CgpzdGF0aWMgaW50IHJlYWRfZ3JhZnRfZmlsZShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgY29uc3QgY2hhciAqZ3JhZnRfZmlsZSkKewoJRklMRSAqZnAgPSBmb3Blbl9vcl93YXJuKGdyYWZ0X2ZpbGUsICJyIik7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaWYgKCFmcCkKCQlyZXR1cm4gLTE7CglpZiAoIW5vX2dyYWZ0X2ZpbGVfZGVwcmVjYXRlZF9hZHZpY2UgJiYKCSAgICBhZHZpY2VfZW5hYmxlZChBRFZJQ0VfR1JBRlRfRklMRV9ERVBSRUNBVEVEKSkKCQlhZHZpc2UoXygiU3VwcG9ydCBmb3IgPEdJVF9ESVI+L2luZm8vZ3JhZnRzIGlzIGRlcHJlY2F0ZWRcbiIKCQkJICJhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIEdpdCB2ZXJzaW9uLlxuIgoJCQkgIlxuIgoJCQkgIlBsZWFzZSB1c2UgXCJnaXQgcmVwbGFjZSAtLWNvbnZlcnQtZ3JhZnQtZmlsZVwiXG4iCgkJCSAidG8gY29udmVydCB0aGUgZ3JhZnRzIGludG8gcmVwbGFjZSByZWZzLlxuIgoJCQkgIlxuIgoJCQkgIlR1cm4gdGhpcyBtZXNzYWdlIG9mZiBieSBydW5uaW5nXG4iCgkJCSAiXCJnaXQgY29uZmlnIHNldCBhZHZpY2UuZ3JhZnRGaWxlRGVwcmVjYXRlZCBmYWxzZVwiIikpOwoJd2hpbGUgKCFzdHJidWZfZ2V0d2hvbGVsaW5lKCZidWYsIGZwLCAnXG4nKSkgewoJCS8qIFRoZSBmb3JtYXQgaXMganVzdCAiQ29tbWl0IFBhcmVudDEgUGFyZW50MiAuLi5cbiIgKi8KCQlzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpncmFmdCA9IHJlYWRfZ3JhZnRfbGluZSgmYnVmKTsKCQlpZiAoIWdyYWZ0KQoJCQljb250aW51ZTsKCQlpZiAocmVnaXN0ZXJfY29tbWl0X2dyYWZ0KHIsIGdyYWZ0LCAxKSkKCQkJZXJyb3IoImR1cGxpY2F0ZSBncmFmdCBkYXRhOiAlcyIsIGJ1Zi5idWYpOwoJfQoJZmNsb3NlKGZwKTsKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJcmV0dXJuIDA7Cn0KCnZvaWQgcHJlcGFyZV9jb21taXRfZ3JhZnQoc3RydWN0IHJlcG9zaXRvcnkgKnIpCnsKCWNvbnN0IGNoYXIgKmdyYWZ0X2ZpbGU7CgoJaWYgKHItPnBhcnNlZF9vYmplY3RzLT5jb21taXRfZ3JhZnRfcHJlcGFyZWQpCgkJcmV0dXJuOwoJaWYgKCFzdGFydHVwX2luZm8tPmhhdmVfcmVwb3NpdG9yeSkKCQlyZXR1cm47CgoJZ3JhZnRfZmlsZSA9IHJlcG9fZ2V0X2dyYWZ0X2ZpbGUocik7CglyZWFkX2dyYWZ0X2ZpbGUociwgZ3JhZnRfZmlsZSk7CgkvKiBtYWtlIHN1cmUgc2hhbGxvd3MgYXJlIHJlYWQgKi8KCWlzX3JlcG9zaXRvcnlfc2hhbGxvdyhyKTsKCXItPnBhcnNlZF9vYmplY3RzLT5jb21taXRfZ3JhZnRfcHJlcGFyZWQgPSAxOwp9CgpzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpsb29rdXBfY29tbWl0X2dyYWZ0KHN0cnVjdCByZXBvc2l0b3J5ICpyLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCWludCBwb3M7CglwcmVwYXJlX2NvbW1pdF9ncmFmdChyKTsKCXBvcyA9IGNvbW1pdF9ncmFmdF9wb3Mociwgb2lkKTsKCWlmIChwb3MgPCAwKQoJCXJldHVybiBOVUxMOwoJcmV0dXJuIHItPnBhcnNlZF9vYmplY3RzLT5ncmFmdHNbcG9zXTsKfQoKaW50IGZvcl9lYWNoX2NvbW1pdF9ncmFmdChlYWNoX2NvbW1pdF9ncmFmdF9mbiBmbiwgdm9pZCAqY2JfZGF0YSkKewoJaW50IGksIHJldDsKCWZvciAoaSA9IHJldCA9IDA7IGkgPCB0aGVfcmVwb3NpdG9yeS0+cGFyc2VkX29iamVjdHMtPmdyYWZ0c19uciAmJiAhcmV0OyBpKyspCgkJcmV0ID0gZm4odGhlX3JlcG9zaXRvcnktPnBhcnNlZF9vYmplY3RzLT5ncmFmdHNbaV0sIGNiX2RhdGEpOwoJcmV0dXJuIHJldDsKfQoKc3RydWN0IGNvbW1pdF9idWZmZXIgewoJdm9pZCAqYnVmZmVyOwoJdW5zaWduZWQgbG9uZyBzaXplOwp9OwpkZWZpbmVfY29tbWl0X3NsYWIoYnVmZmVyX3NsYWIsIHN0cnVjdCBjb21taXRfYnVmZmVyKTsKCnN0cnVjdCBidWZmZXJfc2xhYiAqYWxsb2NhdGVfY29tbWl0X2J1ZmZlcl9zbGFiKHZvaWQpCnsKCXN0cnVjdCBidWZmZXJfc2xhYiAqYnMgPSB4bWFsbG9jKHNpemVvZigqYnMpKTsKCWluaXRfYnVmZmVyX3NsYWIoYnMpOwoJcmV0dXJuIGJzOwp9Cgp2b2lkIGZyZWVfY29tbWl0X2J1ZmZlcl9zbGFiKHN0cnVjdCBidWZmZXJfc2xhYiAqYnMpCnsKCWNsZWFyX2J1ZmZlcl9zbGFiKGJzKTsKCWZyZWUoYnMpOwp9Cgp2b2lkIHNldF9jb21taXRfYnVmZmVyKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHZvaWQgKmJ1ZmZlciwgdW5zaWduZWQgbG9uZyBzaXplKQp7CglzdHJ1Y3QgY29tbWl0X2J1ZmZlciAqdiA9IGJ1ZmZlcl9zbGFiX2F0KAoJCXItPnBhcnNlZF9vYmplY3RzLT5idWZmZXJfc2xhYiwgY29tbWl0KTsKCXYtPmJ1ZmZlciA9IGJ1ZmZlcjsKCXYtPnNpemUgPSBzaXplOwp9Cgpjb25zdCB2b2lkICpnZXRfY2FjaGVkX2NvbW1pdF9idWZmZXIoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IHN0cnVjdCBjb21taXQgKmNvbW1pdCwgdW5zaWduZWQgbG9uZyAqc2l6ZXApCnsKCXN0cnVjdCBjb21taXRfYnVmZmVyICp2ID0gYnVmZmVyX3NsYWJfcGVlaygKCQlyLT5wYXJzZWRfb2JqZWN0cy0+YnVmZmVyX3NsYWIsIGNvbW1pdCk7CglpZiAoIXYpIHsKCQlpZiAoc2l6ZXApCgkJCSpzaXplcCA9IDA7CgkJcmV0dXJuIE5VTEw7Cgl9CglpZiAoc2l6ZXApCgkJKnNpemVwID0gdi0+c2l6ZTsKCXJldHVybiB2LT5idWZmZXI7Cn0KCmNvbnN0IHZvaWQgKnJlcG9fZ2V0X2NvbW1pdF9idWZmZXIoc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCQkgICBjb25zdCBzdHJ1Y3QgY29tbWl0ICpjb21taXQsCgkJCQkgICB1bnNpZ25lZCBsb25nICpzaXplcCkKewoJY29uc3Qgdm9pZCAqcmV0ID0gZ2V0X2NhY2hlZF9jb21taXRfYnVmZmVyKHIsIGNvbW1pdCwgc2l6ZXApOwoJaWYgKCFyZXQpIHsKCQllbnVtIG9iamVjdF90eXBlIHR5cGU7CgkJdW5zaWduZWQgbG9uZyBzaXplOwoJCXJldCA9IHJlcG9fcmVhZF9vYmplY3RfZmlsZShyLCAmY29tbWl0LT5vYmplY3Qub2lkLCAmdHlwZSwgJnNpemUpOwoJCWlmICghcmV0KQoJCQlkaWUoImNhbm5vdCByZWFkIGNvbW1pdCBvYmplY3QgJXMiLAoJCQkgICAgb2lkX3RvX2hleCgmY29tbWl0LT5vYmplY3Qub2lkKSk7CgkJaWYgKHR5cGUgIT0gT0JKX0NPTU1JVCkKCQkJZGllKCJleHBlY3RlZCBjb21taXQgZm9yICVzLCBnb3QgJXMiLAoJCQkgICAgb2lkX3RvX2hleCgmY29tbWl0LT5vYmplY3Qub2lkKSwgdHlwZV9uYW1lKHR5cGUpKTsKCQlpZiAoc2l6ZXApCgkJCSpzaXplcCA9IHNpemU7Cgl9CglyZXR1cm4gcmV0Owp9Cgp2b2lkIHJlcG9fdW51c2VfY29tbWl0X2J1ZmZlcihzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJICAgICAgY29uc3Qgc3RydWN0IGNvbW1pdCAqY29tbWl0LAoJCQkgICAgICBjb25zdCB2b2lkICpidWZmZXIpCnsKCXN0cnVjdCBjb21taXRfYnVmZmVyICp2ID0gYnVmZmVyX3NsYWJfcGVlaygKCQlyLT5wYXJzZWRfb2JqZWN0cy0+YnVmZmVyX3NsYWIsIGNvbW1pdCk7CglpZiAoISh2ICYmIHYtPmJ1ZmZlciA9PSBidWZmZXIpKQoJCWZyZWUoKHZvaWQgKilidWZmZXIpOwp9Cgp2b2lkIGZyZWVfY29tbWl0X2J1ZmZlcihzdHJ1Y3QgcGFyc2VkX29iamVjdF9wb29sICpwb29sLCBzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCXN0cnVjdCBjb21taXRfYnVmZmVyICp2ID0gYnVmZmVyX3NsYWJfcGVlaygKCQlwb29sLT5idWZmZXJfc2xhYiwgY29tbWl0KTsKCWlmICh2KSB7CgkJRlJFRV9BTkRfTlVMTCh2LT5idWZmZXIpOwoJCXYtPnNpemUgPSAwOwoJfQp9CgpzdGF0aWMgaW5saW5lIHZvaWQgc2V0X2NvbW1pdF90cmVlKHN0cnVjdCBjb21taXQgKmMsIHN0cnVjdCB0cmVlICp0KQp7CgljLT5tYXliZV90cmVlID0gdDsKfQoKc3RydWN0IHRyZWUgKnJlcG9fZ2V0X2NvbW1pdF90cmVlKHN0cnVjdCByZXBvc2l0b3J5ICpyLAoJCQkJICBjb25zdCBzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCWlmIChjb21taXQtPm1heWJlX3RyZWUgfHwgIWNvbW1pdC0+b2JqZWN0LnBhcnNlZCkKCQlyZXR1cm4gY29tbWl0LT5tYXliZV90cmVlOwoKCWlmIChjb21taXRfZ3JhcGhfcG9zaXRpb24oY29tbWl0KSAhPSBDT01NSVRfTk9UX0ZST01fR1JBUEgpCgkJcmV0dXJuIGdldF9jb21taXRfdHJlZV9pbl9ncmFwaChyLCBjb21taXQpOwoKCXJldHVybiBOVUxMOwp9CgpzdHJ1Y3Qgb2JqZWN0X2lkICpnZXRfY29tbWl0X3RyZWVfb2lkKGNvbnN0IHN0cnVjdCBjb21taXQgKmNvbW1pdCkKewoJc3RydWN0IHRyZWUgKnRyZWUgPSByZXBvX2dldF9jb21taXRfdHJlZSh0aGVfcmVwb3NpdG9yeSwgY29tbWl0KTsKCXJldHVybiB0cmVlID8gJnRyZWUtPm9iamVjdC5vaWQgOiBOVUxMOwp9Cgp2b2lkIHJlbGVhc2VfY29tbWl0X21lbW9yeShzdHJ1Y3QgcGFyc2VkX29iamVjdF9wb29sICpwb29sLCBzdHJ1Y3QgY29tbWl0ICpjKQp7CglzZXRfY29tbWl0X3RyZWUoYywgTlVMTCk7CglmcmVlX2NvbW1pdF9idWZmZXIocG9vbCwgYyk7CgljLT5pbmRleCA9IDA7CglmcmVlX2NvbW1pdF9saXN0KGMtPnBhcmVudHMpOwoKCWMtPm9iamVjdC5wYXJzZWQgPSAwOwp9Cgpjb25zdCB2b2lkICpkZXRhY2hfY29tbWl0X2J1ZmZlcihzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHVuc2lnbmVkIGxvbmcgKnNpemVwKQp7CglzdHJ1Y3QgY29tbWl0X2J1ZmZlciAqdiA9IGJ1ZmZlcl9zbGFiX3BlZWsoCgkJdGhlX3JlcG9zaXRvcnktPnBhcnNlZF9vYmplY3RzLT5idWZmZXJfc2xhYiwgY29tbWl0KTsKCXZvaWQgKnJldDsKCglpZiAoIXYpIHsKCQlpZiAoc2l6ZXApCgkJCSpzaXplcCA9IDA7CgkJcmV0dXJuIE5VTEw7Cgl9CglyZXQgPSB2LT5idWZmZXI7CglpZiAoc2l6ZXApCgkJKnNpemVwID0gdi0+c2l6ZTsKCgl2LT5idWZmZXIgPSBOVUxMOwoJdi0+c2l6ZSA9IDA7CglyZXR1cm4gcmV0Owp9CgppbnQgcGFyc2VfY29tbWl0X2J1ZmZlcihzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgc3RydWN0IGNvbW1pdCAqaXRlbSwgY29uc3Qgdm9pZCAqYnVmZmVyLCB1bnNpZ25lZCBsb25nIHNpemUsIGludCBjaGVja19ncmFwaCkKewoJY29uc3QgY2hhciAqdGFpbCA9IGJ1ZmZlcjsKCWNvbnN0IGNoYXIgKmJ1ZnB0ciA9IGJ1ZmZlcjsKCXN0cnVjdCBvYmplY3RfaWQgcGFyZW50OwoJc3RydWN0IGNvbW1pdF9saXN0ICoqcHB0cjsKCXN0cnVjdCBjb21taXRfZ3JhZnQgKmdyYWZ0OwoJY29uc3QgaW50IHRyZWVfZW50cnlfbGVuID0gdGhlX2hhc2hfYWxnby0+aGV4c3ogKyA1OwoJY29uc3QgaW50IHBhcmVudF9lbnRyeV9sZW4gPSB0aGVfaGFzaF9hbGdvLT5oZXhzeiArIDc7CglzdHJ1Y3QgdHJlZSAqdHJlZTsKCglpZiAoaXRlbS0+b2JqZWN0LnBhcnNlZCkKCQlyZXR1cm4gMDsKCS8qCgkgKiBQcmVzdW1hYmx5IHRoaXMgaXMgbGVmdG92ZXIgZnJvbSBhbiBlYXJsaWVyIGZhaWxlZCBwYXJzZTsKCSAqIGNsZWFyIGl0IG91dCBpbiBwcmVwYXJhdGlvbiBmb3IgdXMgcmUtcGFyc2luZyAod2UnbGwgaGl0IHRoZQoJICogc2FtZSBlcnJvciwgYnV0IHRoYXQncyBnb29kLCBzaW5jZSBpdCBsZXRzIG91ciBjYWxsZXIga25vdwoJICogdGhlIHJlc3VsdCBjYW5ub3QgYmUgdHJ1c3RlZC4KCSAqLwoJZnJlZV9jb21taXRfbGlzdChpdGVtLT5wYXJlbnRzKTsKCWl0ZW0tPnBhcmVudHMgPSBOVUxMOwoKCXRhaWwgKz0gc2l6ZTsKCWlmICh0YWlsIDw9IGJ1ZnB0ciArIHRyZWVfZW50cnlfbGVuICsgMSB8fCBtZW1jbXAoYnVmcHRyLCAidHJlZSAiLCA1KSB8fAoJCQlidWZwdHJbdHJlZV9lbnRyeV9sZW5dICE9ICdcbicpCgkJcmV0dXJuIGVycm9yKCJib2d1cyBjb21taXQgb2JqZWN0ICVzIiwgb2lkX3RvX2hleCgmaXRlbS0+b2JqZWN0Lm9pZCkpOwoJaWYgKGdldF9vaWRfaGV4KGJ1ZnB0ciArIDUsICZwYXJlbnQpIDwgMCkKCQlyZXR1cm4gZXJyb3IoImJhZCB0cmVlIHBvaW50ZXIgaW4gY29tbWl0ICVzIiwKCQkJICAgICBvaWRfdG9faGV4KCZpdGVtLT5vYmplY3Qub2lkKSk7Cgl0cmVlID0gbG9va3VwX3RyZWUociwgJnBhcmVudCk7CglpZiAoIXRyZWUpCgkJcmV0dXJuIGVycm9yKCJiYWQgdHJlZSBwb2ludGVyICVzIGluIGNvbW1pdCAlcyIsCgkJCSAgICAgb2lkX3RvX2hleCgmcGFyZW50KSwKCQkJICAgICBvaWRfdG9faGV4KCZpdGVtLT5vYmplY3Qub2lkKSk7CglzZXRfY29tbWl0X3RyZWUoaXRlbSwgdHJlZSk7CglidWZwdHIgKz0gdHJlZV9lbnRyeV9sZW4gKyAxOyAvKiAidHJlZSAiICsgImhleCBzaGExIiArICJcbiIgKi8KCXBwdHIgPSAmaXRlbS0+cGFyZW50czsKCglncmFmdCA9IGxvb2t1cF9jb21taXRfZ3JhZnQociwgJml0ZW0tPm9iamVjdC5vaWQpOwoJaWYgKGdyYWZ0KQoJCXItPnBhcnNlZF9vYmplY3RzLT5zdWJzdGl0dXRlZF9wYXJlbnQgPSAxOwoJd2hpbGUgKGJ1ZnB0ciArIHBhcmVudF9lbnRyeV9sZW4gPCB0YWlsICYmICFtZW1jbXAoYnVmcHRyLCAicGFyZW50ICIsIDcpKSB7CgkJc3RydWN0IGNvbW1pdCAqbmV3X3BhcmVudDsKCgkJaWYgKHRhaWwgPD0gYnVmcHRyICsgcGFyZW50X2VudHJ5X2xlbiArIDEgfHwKCQkgICAgZ2V0X29pZF9oZXgoYnVmcHRyICsgNywgJnBhcmVudCkgfHwKCQkgICAgYnVmcHRyW3BhcmVudF9lbnRyeV9sZW5dICE9ICdcbicpCgkJCXJldHVybiBlcnJvcigiYmFkIHBhcmVudHMgaW4gY29tbWl0ICVzIiwgb2lkX3RvX2hleCgmaXRlbS0+b2JqZWN0Lm9pZCkpOwoJCWJ1ZnB0ciArPSBwYXJlbnRfZW50cnlfbGVuICsgMTsKCQkvKgoJCSAqIFRoZSBjbG9uZSBpcyBzaGFsbG93IGlmIG5yX3BhcmVudCA8IDAsIGFuZCB3ZSBtdXN0CgkJICogbm90IHRyYXZlcnNlIGl0cyByZWFsIHBhcmVudHMgZXZlbiB3aGVuIHdlIHVuaGlkZSB0aGVtLgoJCSAqLwoJCWlmIChncmFmdCAmJiAoZ3JhZnQtPm5yX3BhcmVudCA8IDAgfHwgIWdyYWZ0c19rZWVwX3RydWVfcGFyZW50cykpCgkJCWNvbnRpbnVlOwoJCW5ld19wYXJlbnQgPSBsb29rdXBfY29tbWl0KHIsICZwYXJlbnQpOwoJCWlmICghbmV3X3BhcmVudCkKCQkJcmV0dXJuIGVycm9yKCJiYWQgcGFyZW50ICVzIGluIGNvbW1pdCAlcyIsCgkJCQkgICAgIG9pZF90b19oZXgoJnBhcmVudCksCgkJCQkgICAgIG9pZF90b19oZXgoJml0ZW0tPm9iamVjdC5vaWQpKTsKCQlwcHRyID0gJmNvbW1pdF9saXN0X2luc2VydChuZXdfcGFyZW50LCBwcHRyKS0+bmV4dDsKCX0KCWlmIChncmFmdCkgewoJCWludCBpOwoJCXN0cnVjdCBjb21taXQgKm5ld19wYXJlbnQ7CgkJZm9yIChpID0gMDsgaSA8IGdyYWZ0LT5ucl9wYXJlbnQ7IGkrKykgewoJCQluZXdfcGFyZW50ID0gbG9va3VwX2NvbW1pdChyLAoJCQkJCQkgICAmZ3JhZnQtPnBhcmVudFtpXSk7CgkJCWlmICghbmV3X3BhcmVudCkKCQkJCXJldHVybiBlcnJvcigiYmFkIGdyYWZ0IHBhcmVudCAlcyBpbiBjb21taXQgJXMiLAoJCQkJCSAgICAgb2lkX3RvX2hleCgmZ3JhZnQtPnBhcmVudFtpXSksCgkJCQkJICAgICBvaWRfdG9faGV4KCZpdGVtLT5vYmplY3Qub2lkKSk7CgkJCXBwdHIgPSAmY29tbWl0X2xpc3RfaW5zZXJ0KG5ld19wYXJlbnQsIHBwdHIpLT5uZXh0OwoJCX0KCX0KCWl0ZW0tPmRhdGUgPSBwYXJzZV9jb21taXRfZGF0ZShidWZwdHIsIHRhaWwpOwoKCWlmIChjaGVja19ncmFwaCkKCQlsb2FkX2NvbW1pdF9ncmFwaF9pbmZvKHIsIGl0ZW0pOwoKCWl0ZW0tPm9iamVjdC5wYXJzZWQgPSAxOwoJcmV0dXJuIDA7Cn0KCmludCByZXBvX3BhcnNlX2NvbW1pdF9pbnRlcm5hbChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJICAgICAgIHN0cnVjdCBjb21taXQgKml0ZW0sCgkJCSAgICAgICBpbnQgcXVpZXRfb25fbWlzc2luZywKCQkJICAgICAgIGludCB1c2VfY29tbWl0X2dyYXBoKQp7CgllbnVtIG9iamVjdF90eXBlIHR5cGU7Cgl2b2lkICpidWZmZXI7Cgl1bnNpZ25lZCBsb25nIHNpemU7CglzdHJ1Y3Qgb2JqZWN0X2luZm8gb2kgPSB7CgkJLnR5cGVwID0gJnR5cGUsCgkJLnNpemVwID0gJnNpemUsCgkJLmNvbnRlbnRwID0gJmJ1ZmZlciwKCX07CgkvKgoJICogR2l0IGRvZXMgbm90IHN1cHBvcnQgcGFydGlhbCBjbG9uZXMgdGhhdCBleGNsdWRlIGNvbW1pdHMsIHNvIHNldAoJICogT0JKRUNUX0lORk9fU0tJUF9GRVRDSF9PQkpFQ1QgdG8gZmFpbCBmYXN0IHdoZW4gYW4gb2JqZWN0IGlzIG1pc3NpbmcuCgkgKi8KCWludCBmbGFncyA9IE9CSkVDVF9JTkZPX0xPT0tVUF9SRVBMQUNFIHwgT0JKRUNUX0lORk9fU0tJUF9GRVRDSF9PQkpFQ1QgfAoJCU9CSkVDVF9JTkZPX0RJRV9JRl9DT1JSVVBUOwoJaW50IHJldDsKCglpZiAoIWl0ZW0pCgkJcmV0dXJuIC0xOwoJaWYgKGl0ZW0tPm9iamVjdC5wYXJzZWQpCgkJcmV0dXJuIDA7CglpZiAodXNlX2NvbW1pdF9ncmFwaCAmJiBwYXJzZV9jb21taXRfaW5fZ3JhcGgociwgaXRlbSkpIHsKCQlzdGF0aWMgaW50IGNvbW1pdF9ncmFwaF9wYXJhbm9pYSA9IC0xOwoKCQlpZiAoY29tbWl0X2dyYXBoX3BhcmFub2lhID09IC0xKQoJCQljb21taXRfZ3JhcGhfcGFyYW5vaWEgPSBnaXRfZW52X2Jvb2woR0lUX0NPTU1JVF9HUkFQSF9QQVJBTk9JQSwgMCk7CgoJCWlmIChjb21taXRfZ3JhcGhfcGFyYW5vaWEgJiYgIWhhc19vYmplY3QociwgJml0ZW0tPm9iamVjdC5vaWQsIDApKSB7CgkJCXVucGFyc2VfY29tbWl0KHIsICZpdGVtLT5vYmplY3Qub2lkKTsKCQkJcmV0dXJuIHF1aWV0X29uX21pc3NpbmcgPyAtMSA6CgkJCQllcnJvcihfKCJjb21taXQgJXMgZXhpc3RzIGluIGNvbW1pdC1ncmFwaCBidXQgbm90IGluIHRoZSBvYmplY3QgZGF0YWJhc2UiKSwKCQkJCSAgICAgIG9pZF90b19oZXgoJml0ZW0tPm9iamVjdC5vaWQpKTsKCQl9CgoJCXJldHVybiAwOwoJfQoKCWlmIChvaWRfb2JqZWN0X2luZm9fZXh0ZW5kZWQociwgJml0ZW0tPm9iamVjdC5vaWQsICZvaSwgZmxhZ3MpIDwgMCkKCQlyZXR1cm4gcXVpZXRfb25fbWlzc2luZyA/IC0xIDoKCQkJZXJyb3IoIkNvdWxkIG5vdCByZWFkICVzIiwKCQkJICAgICBvaWRfdG9faGV4KCZpdGVtLT5vYmplY3Qub2lkKSk7CglpZiAodHlwZSAhPSBPQkpfQ09NTUlUKSB7CgkJZnJlZShidWZmZXIpOwoJCXJldHVybiBlcnJvcigiT2JqZWN0ICVzIG5vdCBhIGNvbW1pdCIsCgkJCSAgICAgb2lkX3RvX2hleCgmaXRlbS0+b2JqZWN0Lm9pZCkpOwoJfQoKCXJldCA9IHBhcnNlX2NvbW1pdF9idWZmZXIociwgaXRlbSwgYnVmZmVyLCBzaXplLCAwKTsKCWlmIChzYXZlX2NvbW1pdF9idWZmZXIgJiYgIXJldCAmJgoJICAgICFnZXRfY2FjaGVkX2NvbW1pdF9idWZmZXIociwgaXRlbSwgTlVMTCkpIHsKCQlzZXRfY29tbWl0X2J1ZmZlcihyLCBpdGVtLCBidWZmZXIsIHNpemUpOwoJCXJldHVybiAwOwoJfQoJZnJlZShidWZmZXIpOwoJcmV0dXJuIHJldDsKfQoKaW50IHJlcG9fcGFyc2VfY29tbWl0X2dlbnRseShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJICAgICBzdHJ1Y3QgY29tbWl0ICppdGVtLCBpbnQgcXVpZXRfb25fbWlzc2luZykKewoJcmV0dXJuIHJlcG9fcGFyc2VfY29tbWl0X2ludGVybmFsKHIsIGl0ZW0sIHF1aWV0X29uX21pc3NpbmcsIDEpOwp9Cgp2b2lkIHBhcnNlX2NvbW1pdF9vcl9kaWUoc3RydWN0IGNvbW1pdCAqaXRlbSkKewoJaWYgKHJlcG9fcGFyc2VfY29tbWl0KHRoZV9yZXBvc2l0b3J5LCBpdGVtKSkKCQlkaWUoInVuYWJsZSB0byBwYXJzZSBjb21taXQgJXMiLAoJCSAgICBpdGVtID8gb2lkX3RvX2hleCgmaXRlbS0+b2JqZWN0Lm9pZCkgOiAiKG51bGwpIik7Cn0KCmludCBmaW5kX2NvbW1pdF9zdWJqZWN0KGNvbnN0IGNoYXIgKmNvbW1pdF9idWZmZXIsIGNvbnN0IGNoYXIgKipzdWJqZWN0KQp7Cgljb25zdCBjaGFyICplb2w7Cgljb25zdCBjaGFyICpwID0gY29tbWl0X2J1ZmZlcjsKCgl3aGlsZSAoKnAgJiYgKCpwICE9ICdcbicgfHwgcFsxXSAhPSAnXG4nKSkKCQlwKys7CglpZiAoKnApIHsKCQlwID0gc2tpcF9ibGFua19saW5lcyhwICsgMik7CgkJZW9sID0gc3RyY2hybnVsKHAsICdcbicpOwoJfSBlbHNlCgkJZW9sID0gcDsKCgkqc3ViamVjdCA9IHA7CgoJcmV0dXJuIGVvbCAtIHA7Cn0KCnNpemVfdCBjb21taXRfc3ViamVjdF9sZW5ndGgoY29uc3QgY2hhciAqYm9keSkKewoJY29uc3QgY2hhciAqcCA9IGJvZHk7Cgl3aGlsZSAoKnApIHsKCQljb25zdCBjaGFyICpuZXh0ID0gc2tpcF9ibGFua19saW5lcyhwKTsKCQlpZiAobmV4dCAhPSBwKQoJCQlicmVhazsKCQlwID0gc3RyY2hybnVsKHAsICdcbicpOwoJCWlmICgqcCkKCQkJcCsrOwoJfQoJcmV0dXJuIHAgLSBib2R5Owp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKmNvbW1pdF9saXN0X2luc2VydChzdHJ1Y3QgY29tbWl0ICppdGVtLCBzdHJ1Y3QgY29tbWl0X2xpc3QgKipsaXN0X3ApCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqbmV3X2xpc3QgPSB4bWFsbG9jKHNpemVvZihzdHJ1Y3QgY29tbWl0X2xpc3QpKTsKCW5ld19saXN0LT5pdGVtID0gaXRlbTsKCW5ld19saXN0LT5uZXh0ID0gKmxpc3RfcDsKCSpsaXN0X3AgPSBuZXdfbGlzdDsKCXJldHVybiBuZXdfbGlzdDsKfQoKaW50IGNvbW1pdF9saXN0X2NvbnRhaW5zKHN0cnVjdCBjb21taXQgKml0ZW0sIHN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCkKewoJd2hpbGUgKGxpc3QpIHsKCQlpZiAobGlzdC0+aXRlbSA9PSBpdGVtKQoJCQlyZXR1cm4gMTsKCQlsaXN0ID0gbGlzdC0+bmV4dDsKCX0KCglyZXR1cm4gMDsKfQoKdW5zaWduZWQgY29tbWl0X2xpc3RfY291bnQoY29uc3Qgc3RydWN0IGNvbW1pdF9saXN0ICpsKQp7Cgl1bnNpZ25lZCBjID0gMDsKCWZvciAoOyBsOyBsID0gbC0+bmV4dCApCgkJYysrOwoJcmV0dXJuIGM7Cn0KCnN0cnVjdCBjb21taXRfbGlzdCAqY29weV9jb21taXRfbGlzdChjb25zdCBzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqaGVhZCA9IE5VTEw7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKipwcCA9ICZoZWFkOwoJd2hpbGUgKGxpc3QpIHsKCQlwcCA9IGNvbW1pdF9saXN0X2FwcGVuZChsaXN0LT5pdGVtLCBwcCk7CgkJbGlzdCA9IGxpc3QtPm5leHQ7Cgl9CglyZXR1cm4gaGVhZDsKfQoKc3RydWN0IGNvbW1pdF9saXN0ICpyZXZlcnNlX2NvbW1pdF9saXN0KHN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpuZXh0ID0gTlVMTCwgKmN1cnJlbnQsICpiYWNrdXA7Cglmb3IgKGN1cnJlbnQgPSBsaXN0OyBjdXJyZW50OyBjdXJyZW50ID0gYmFja3VwKSB7CgkJYmFja3VwID0gY3VycmVudC0+bmV4dDsKCQljdXJyZW50LT5uZXh0ID0gbmV4dDsKCQluZXh0ID0gY3VycmVudDsKCX0KCXJldHVybiBuZXh0Owp9Cgp2b2lkIGZyZWVfY29tbWl0X2xpc3Qoc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0KQp7Cgl3aGlsZSAobGlzdCkKCQlwb3BfY29tbWl0KCZsaXN0KTsKfQoKc3RydWN0IGNvbW1pdF9saXN0ICogY29tbWl0X2xpc3RfaW5zZXJ0X2J5X2RhdGUoc3RydWN0IGNvbW1pdCAqaXRlbSwgc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICoqcHAgPSBsaXN0OwoJc3RydWN0IGNvbW1pdF9saXN0ICpwOwoJd2hpbGUgKChwID0gKnBwKSAhPSBOVUxMKSB7CgkJaWYgKHAtPml0ZW0tPmRhdGUgPCBpdGVtLT5kYXRlKSB7CgkJCWJyZWFrOwoJCX0KCQlwcCA9ICZwLT5uZXh0OwoJfQoJcmV0dXJuIGNvbW1pdF9saXN0X2luc2VydChpdGVtLCBwcCk7Cn0KCnN0YXRpYyBpbnQgY29tbWl0X2xpc3RfY29tcGFyZV9ieV9kYXRlKGNvbnN0IHN0cnVjdCBjb21taXRfbGlzdCAqYSwKCQkJCSAgICAgICBjb25zdCBzdHJ1Y3QgY29tbWl0X2xpc3QgKmIpCnsKCXRpbWVzdGFtcF90IGFfZGF0ZSA9IGEtPml0ZW0tPmRhdGU7Cgl0aW1lc3RhbXBfdCBiX2RhdGUgPSBiLT5pdGVtLT5kYXRlOwoJaWYgKGFfZGF0ZSA8IGJfZGF0ZSkKCQlyZXR1cm4gMTsKCWlmIChhX2RhdGUgPiBiX2RhdGUpCgkJcmV0dXJuIC0xOwoJcmV0dXJuIDA7Cn0KCkRFRklORV9MSVNUX1NPUlQoc3RhdGljLCBjb21taXRfbGlzdF9zb3J0LCBzdHJ1Y3QgY29tbWl0X2xpc3QsIG5leHQpOwoKdm9pZCBjb21taXRfbGlzdF9zb3J0X2J5X2RhdGUoc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCkKewoJY29tbWl0X2xpc3Rfc29ydChsaXN0LCBjb21taXRfbGlzdF9jb21wYXJlX2J5X2RhdGUpOwp9CgpzdHJ1Y3QgY29tbWl0ICpwb3BfbW9zdF9yZWNlbnRfY29tbWl0KHN0cnVjdCBjb21taXRfbGlzdCAqKmxpc3QsCgkJCQkgICAgICB1bnNpZ25lZCBpbnQgbWFyaykKewoJc3RydWN0IGNvbW1pdCAqcmV0ID0gcG9wX2NvbW1pdChsaXN0KTsKCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50cyA9IHJldC0+cGFyZW50czsKCgl3aGlsZSAocGFyZW50cykgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IHBhcmVudHMtPml0ZW07CgkJaWYgKCFyZXBvX3BhcnNlX2NvbW1pdCh0aGVfcmVwb3NpdG9yeSwgY29tbWl0KSAmJiAhKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgbWFyaykpIHsKCQkJY29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gbWFyazsKCQkJY29tbWl0X2xpc3RfaW5zZXJ0X2J5X2RhdGUoY29tbWl0LCBsaXN0KTsKCQl9CgkJcGFyZW50cyA9IHBhcmVudHMtPm5leHQ7Cgl9CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgdm9pZCBjbGVhcl9jb21taXRfbWFya3NfMShzdHJ1Y3QgY29tbWl0X2xpc3QgKipwbGlzdCwKCQkJCSBzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHVuc2lnbmVkIGludCBtYXJrKQp7Cgl3aGlsZSAoY29tbWl0KSB7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzOwoKCQlpZiAoIShtYXJrICYgY29tbWl0LT5vYmplY3QuZmxhZ3MpKQoJCQlyZXR1cm47CgoJCWNvbW1pdC0+b2JqZWN0LmZsYWdzICY9IH5tYXJrOwoKCQlwYXJlbnRzID0gY29tbWl0LT5wYXJlbnRzOwoJCWlmICghcGFyZW50cykKCQkJcmV0dXJuOwoKCQl3aGlsZSAoKHBhcmVudHMgPSBwYXJlbnRzLT5uZXh0KSkgewoJCQlpZiAocGFyZW50cy0+aXRlbS0+b2JqZWN0LmZsYWdzICYgbWFyaykKCQkJCWNvbW1pdF9saXN0X2luc2VydChwYXJlbnRzLT5pdGVtLCBwbGlzdCk7CgkJfQoKCQljb21taXQgPSBjb21taXQtPnBhcmVudHMtPml0ZW07Cgl9Cn0KCnZvaWQgY2xlYXJfY29tbWl0X21hcmtzX21hbnkoc2l6ZV90IG5yLCBzdHJ1Y3QgY29tbWl0ICoqY29tbWl0LCB1bnNpZ25lZCBpbnQgbWFyaykKewoJZm9yIChzaXplX3QgaSA9IDA7IGkgPCBucjsgaSsrKSB7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0ID0gTlVMTDsKCgkJY2xlYXJfY29tbWl0X21hcmtzXzEoJmxpc3QsICpjb21taXQsIG1hcmspOwoJCXdoaWxlIChsaXN0KQoJCQljbGVhcl9jb21taXRfbWFya3NfMSgmbGlzdCwgcG9wX2NvbW1pdCgmbGlzdCksIG1hcmspOwoJCWNvbW1pdCsrOwoJfQp9Cgp2b2lkIGNsZWFyX2NvbW1pdF9tYXJrcyhzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHVuc2lnbmVkIGludCBtYXJrKQp7CgljbGVhcl9jb21taXRfbWFya3NfbWFueSgxLCAmY29tbWl0LCBtYXJrKTsKfQoKc3RydWN0IGNvbW1pdCAqcG9wX2NvbW1pdChzdHJ1Y3QgY29tbWl0X2xpc3QgKipzdGFjaykKewoJc3RydWN0IGNvbW1pdF9saXN0ICp0b3AgPSAqc3RhY2s7CglzdHJ1Y3QgY29tbWl0ICppdGVtID0gdG9wID8gdG9wLT5pdGVtIDogTlVMTDsKCglpZiAodG9wKSB7CgkJKnN0YWNrID0gdG9wLT5uZXh0OwoJCWZyZWUodG9wKTsKCX0KCXJldHVybiBpdGVtOwp9CgovKgogKiBUb3BvbG9naWNhbCBzb3J0IHN1cHBvcnQKICovCgovKiBjb3VudCBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBoYXZlIG5vdCBiZWVuIGVtaXR0ZWQgKi8KZGVmaW5lX2NvbW1pdF9zbGFiKGluZGVncmVlX3NsYWIsIGludCk7CgpkZWZpbmVfY29tbWl0X3NsYWIoYXV0aG9yX2RhdGVfc2xhYiwgdGltZXN0YW1wX3QpOwoKdm9pZCByZWNvcmRfYXV0aG9yX2RhdGUoc3RydWN0IGF1dGhvcl9kYXRlX3NsYWIgKmF1dGhvcl9kYXRlLAoJCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCWNvbnN0IGNoYXIgKmJ1ZmZlciA9IHJlcG9fZ2V0X2NvbW1pdF9idWZmZXIodGhlX3JlcG9zaXRvcnksIGNvbW1pdCwKCQkJCQkJICAgIE5VTEwpOwoJc3RydWN0IGlkZW50X3NwbGl0IGlkZW50OwoJY29uc3QgY2hhciAqaWRlbnRfbGluZTsKCXNpemVfdCBpZGVudF9sZW47CgljaGFyICpkYXRlX2VuZDsKCXRpbWVzdGFtcF90IGRhdGU7CgoJaWRlbnRfbGluZSA9IGZpbmRfY29tbWl0X2hlYWRlcihidWZmZXIsICJhdXRob3IiLCAmaWRlbnRfbGVuKTsKCWlmICghaWRlbnRfbGluZSkKCQlnb3RvIGZhaWxfZXhpdDsgLyogbm8gYXV0aG9yIGxpbmUgKi8KCWlmIChzcGxpdF9pZGVudF9saW5lKCZpZGVudCwgaWRlbnRfbGluZSwgaWRlbnRfbGVuKSB8fAoJICAgICFpZGVudC5kYXRlX2JlZ2luIHx8ICFpZGVudC5kYXRlX2VuZCkKCQlnb3RvIGZhaWxfZXhpdDsgLyogbWFsZm9ybWVkICJhdXRob3IiIGxpbmUgKi8KCglkYXRlID0gcGFyc2VfdGltZXN0YW1wKGlkZW50LmRhdGVfYmVnaW4sICZkYXRlX2VuZCwgMTApOwoJaWYgKGRhdGVfZW5kICE9IGlkZW50LmRhdGVfZW5kKQoJCWdvdG8gZmFpbF9leGl0OyAvKiBtYWxmb3JtZWQgZGF0ZSAqLwoJKihhdXRob3JfZGF0ZV9zbGFiX2F0KGF1dGhvcl9kYXRlLCBjb21taXQpKSA9IGRhdGU7CgpmYWlsX2V4aXQ6CglyZXBvX3VudXNlX2NvbW1pdF9idWZmZXIodGhlX3JlcG9zaXRvcnksIGNvbW1pdCwgYnVmZmVyKTsKfQoKaW50IGNvbXBhcmVfY29tbWl0c19ieV9hdXRob3JfZGF0ZShjb25zdCB2b2lkICphXywgY29uc3Qgdm9pZCAqYl8sCgkJCQkgICB2b2lkICpjYl9kYXRhKQp7Cgljb25zdCBzdHJ1Y3QgY29tbWl0ICphID0gYV8sICpiID0gYl87CglzdHJ1Y3QgYXV0aG9yX2RhdGVfc2xhYiAqYXV0aG9yX2RhdGUgPSBjYl9kYXRhOwoJdGltZXN0YW1wX3QgYV9kYXRlID0gKihhdXRob3JfZGF0ZV9zbGFiX2F0KGF1dGhvcl9kYXRlLCBhKSk7Cgl0aW1lc3RhbXBfdCBiX2RhdGUgPSAqKGF1dGhvcl9kYXRlX3NsYWJfYXQoYXV0aG9yX2RhdGUsIGIpKTsKCgkvKiBuZXdlciBjb21taXRzIHdpdGggbGFyZ2VyIGRhdGUgZmlyc3QgKi8KCWlmIChhX2RhdGUgPCBiX2RhdGUpCgkJcmV0dXJuIDE7CgllbHNlIGlmIChhX2RhdGUgPiBiX2RhdGUpCgkJcmV0dXJuIC0xOwoJcmV0dXJuIDA7Cn0KCmludCBjb21wYXJlX2NvbW1pdHNfYnlfZ2VuX3RoZW5fY29tbWl0X2RhdGUoY29uc3Qgdm9pZCAqYV8sIGNvbnN0IHZvaWQgKmJfLAoJCQkJCSAgICB2b2lkICp1bnVzZWQgVU5VU0VEKQp7Cgljb25zdCBzdHJ1Y3QgY29tbWl0ICphID0gYV8sICpiID0gYl87Cgljb25zdCB0aW1lc3RhbXBfdCBnZW5lcmF0aW9uX2EgPSBjb21taXRfZ3JhcGhfZ2VuZXJhdGlvbihhKSwKCQkJICBnZW5lcmF0aW9uX2IgPSBjb21taXRfZ3JhcGhfZ2VuZXJhdGlvbihiKTsKCgkvKiBuZXdlciBjb21taXRzIGZpcnN0ICovCglpZiAoZ2VuZXJhdGlvbl9hIDwgZ2VuZXJhdGlvbl9iKQoJCXJldHVybiAxOwoJZWxzZSBpZiAoZ2VuZXJhdGlvbl9hID4gZ2VuZXJhdGlvbl9iKQoJCXJldHVybiAtMTsKCgkvKiB1c2UgZGF0ZSBhcyBhIGhldXJpc3RpYyB3aGVuIGdlbmVyYXRpb25zIGFyZSBlcXVhbCAqLwoJaWYgKGEtPmRhdGUgPCBiLT5kYXRlKQoJCXJldHVybiAxOwoJZWxzZSBpZiAoYS0+ZGF0ZSA+IGItPmRhdGUpCgkJcmV0dXJuIC0xOwoJcmV0dXJuIDA7Cn0KCmludCBjb21wYXJlX2NvbW1pdHNfYnlfY29tbWl0X2RhdGUoY29uc3Qgdm9pZCAqYV8sIGNvbnN0IHZvaWQgKmJfLAoJCQkJICAgdm9pZCAqdW51c2VkIFVOVVNFRCkKewoJY29uc3Qgc3RydWN0IGNvbW1pdCAqYSA9IGFfLCAqYiA9IGJfOwoJLyogbmV3ZXIgY29tbWl0cyB3aXRoIGxhcmdlciBkYXRlIGZpcnN0ICovCglpZiAoYS0+ZGF0ZSA8IGItPmRhdGUpCgkJcmV0dXJuIDE7CgllbHNlIGlmIChhLT5kYXRlID4gYi0+ZGF0ZSkKCQlyZXR1cm4gLTE7CglyZXR1cm4gMDsKfQoKLyoKICogUGVyZm9ybXMgYW4gaW4tcGxhY2UgdG9wb2xvZ2ljYWwgc29ydCBvbiB0aGUgbGlzdCBzdXBwbGllZC4KICovCnZvaWQgc29ydF9pbl90b3BvbG9naWNhbF9vcmRlcihzdHJ1Y3QgY29tbWl0X2xpc3QgKipsaXN0LCBlbnVtIHJldl9zb3J0X29yZGVyIHNvcnRfb3JkZXIpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqbmV4dCwgKm9yaWcgPSAqbGlzdDsKCXN0cnVjdCBjb21taXRfbGlzdCAqKnBwdHI7CglzdHJ1Y3QgaW5kZWdyZWVfc2xhYiBpbmRlZ3JlZTsKCXN0cnVjdCBwcmlvX3F1ZXVlIHF1ZXVlOwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJc3RydWN0IGF1dGhvcl9kYXRlX3NsYWIgYXV0aG9yX2RhdGU7CgoJaWYgKCFvcmlnKQoJCXJldHVybjsKCSpsaXN0ID0gTlVMTDsKCglpbml0X2luZGVncmVlX3NsYWIoJmluZGVncmVlKTsKCW1lbXNldCgmcXVldWUsICdcMCcsIHNpemVvZihxdWV1ZSkpOwoKCXN3aXRjaCAoc29ydF9vcmRlcikgewoJZGVmYXVsdDogLyogUkVWX1NPUlRfSU5fR1JBUEhfT1JERVIgKi8KCQlxdWV1ZS5jb21wYXJlID0gTlVMTDsKCQlicmVhazsKCWNhc2UgUkVWX1NPUlRfQllfQ09NTUlUX0RBVEU6CgkJcXVldWUuY29tcGFyZSA9IGNvbXBhcmVfY29tbWl0c19ieV9jb21taXRfZGF0ZTsKCQlicmVhazsKCWNhc2UgUkVWX1NPUlRfQllfQVVUSE9SX0RBVEU6CgkJaW5pdF9hdXRob3JfZGF0ZV9zbGFiKCZhdXRob3JfZGF0ZSk7CgkJcXVldWUuY29tcGFyZSA9IGNvbXBhcmVfY29tbWl0c19ieV9hdXRob3JfZGF0ZTsKCQlxdWV1ZS5jYl9kYXRhID0gJmF1dGhvcl9kYXRlOwoJCWJyZWFrOwoJfQoKCS8qIE1hcmsgdGhlbSBhbmQgY2xlYXIgdGhlIGluZGVncmVlICovCglmb3IgKG5leHQgPSBvcmlnOyBuZXh0OyBuZXh0ID0gbmV4dC0+bmV4dCkgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IG5leHQtPml0ZW07CgkJKihpbmRlZ3JlZV9zbGFiX2F0KCZpbmRlZ3JlZSwgY29tbWl0KSkgPSAxOwoJCS8qIGFsc28gcmVjb3JkIHRoZSBhdXRob3IgZGF0ZXMsIGlmIG5lZWRlZCAqLwoJCWlmIChzb3J0X29yZGVyID09IFJFVl9TT1JUX0JZX0FVVEhPUl9EQVRFKQoJCQlyZWNvcmRfYXV0aG9yX2RhdGUoJmF1dGhvcl9kYXRlLCBjb21taXQpOwoJfQoKCS8qIHVwZGF0ZSB0aGUgaW5kZWdyZWUgKi8KCWZvciAobmV4dCA9IG9yaWc7IG5leHQ7IG5leHQgPSBuZXh0LT5uZXh0KSB7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzID0gbmV4dC0+aXRlbS0+cGFyZW50czsKCQl3aGlsZSAocGFyZW50cykgewoJCQlzdHJ1Y3QgY29tbWl0ICpwYXJlbnQgPSBwYXJlbnRzLT5pdGVtOwoJCQlpbnQgKnBpID0gaW5kZWdyZWVfc2xhYl9hdCgmaW5kZWdyZWUsIHBhcmVudCk7CgoJCQlpZiAoKnBpKQoJCQkJKCpwaSkrKzsKCQkJcGFyZW50cyA9IHBhcmVudHMtPm5leHQ7CgkJfQoJfQoKCS8qCgkgKiBmaW5kIHRoZSB0aXBzCgkgKgoJICogdGlwcyBhcmUgbm9kZXMgbm90IHJlYWNoYWJsZSBmcm9tIGFueSBvdGhlciBub2RlIGluIHRoZSBsaXN0CgkgKgoJICogdGhlIHRpcHMgc2VydmUgYXMgYSBzdGFydGluZyBzZXQgZm9yIHRoZSB3b3JrIHF1ZXVlLgoJICovCglmb3IgKG5leHQgPSBvcmlnOyBuZXh0OyBuZXh0ID0gbmV4dC0+bmV4dCkgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IG5leHQtPml0ZW07CgoJCWlmICgqKGluZGVncmVlX3NsYWJfYXQoJmluZGVncmVlLCBjb21taXQpKSA9PSAxKQoJCQlwcmlvX3F1ZXVlX3B1dCgmcXVldWUsIGNvbW1pdCk7Cgl9CgoJLyoKCSAqIFRoaXMgaXMgdW5mb3J0dW5hdGU7IHRoZSBpbml0aWFsIHRpcHMgbmVlZCB0byBiZSBzaG93bgoJICogaW4gdGhlIG9yZGVyIGdpdmVuIGZyb20gdGhlIHJldmlzaW9uIHRyYXZlcnNhbCBtYWNoaW5lcnkuCgkgKi8KCWlmIChzb3J0X29yZGVyID09IFJFVl9TT1JUX0lOX0dSQVBIX09SREVSKQoJCXByaW9fcXVldWVfcmV2ZXJzZSgmcXVldWUpOwoKCS8qIFdlIG5vIGxvbmdlciBuZWVkIHRoZSBjb21taXQgbGlzdCAqLwoJZnJlZV9jb21taXRfbGlzdChvcmlnKTsKCglwcHRyID0gbGlzdDsKCSpsaXN0ID0gTlVMTDsKCXdoaWxlICgoY29tbWl0ID0gcHJpb19xdWV1ZV9nZXQoJnF1ZXVlKSkgIT0gTlVMTCkgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50czsKCgkJZm9yIChwYXJlbnRzID0gY29tbWl0LT5wYXJlbnRzOyBwYXJlbnRzIDsgcGFyZW50cyA9IHBhcmVudHMtPm5leHQpIHsKCQkJc3RydWN0IGNvbW1pdCAqcGFyZW50ID0gcGFyZW50cy0+aXRlbTsKCQkJaW50ICpwaSA9IGluZGVncmVlX3NsYWJfYXQoJmluZGVncmVlLCBwYXJlbnQpOwoKCQkJaWYgKCEqcGkpCgkJCQljb250aW51ZTsKCgkJCS8qCgkJCSAqIHBhcmVudHMgYXJlIG9ubHkgZW5xdWV1ZWQgZm9yIGVtaXNzaW9uCgkJCSAqIHdoZW4gYWxsIHRoZWlyIGNoaWxkcmVuIGhhdmUgYmVlbiBlbWl0dGVkIHRoZXJlYnkKCQkJICogZ3VhcmFudGVlaW5nIHRvcG9sb2dpY2FsIG9yZGVyLgoJCQkgKi8KCQkJaWYgKC0tKCpwaSkgPT0gMSkKCQkJCXByaW9fcXVldWVfcHV0KCZxdWV1ZSwgcGFyZW50KTsKCQl9CgkJLyoKCQkgKiBhbGwgY2hpbGRyZW4gb2YgY29tbWl0IGhhdmUgYWxyZWFkeSBiZWVuCgkJICogZW1pdHRlZC4gd2UgY2FuIGVtaXQgaXQgbm93LgoJCSAqLwoJCSooaW5kZWdyZWVfc2xhYl9hdCgmaW5kZWdyZWUsIGNvbW1pdCkpID0gMDsKCgkJcHB0ciA9ICZjb21taXRfbGlzdF9pbnNlcnQoY29tbWl0LCBwcHRyKS0+bmV4dDsKCX0KCgljbGVhcl9pbmRlZ3JlZV9zbGFiKCZpbmRlZ3JlZSk7CgljbGVhcl9wcmlvX3F1ZXVlKCZxdWV1ZSk7CglpZiAoc29ydF9vcmRlciA9PSBSRVZfU09SVF9CWV9BVVRIT1JfREFURSkKCQljbGVhcl9hdXRob3JfZGF0ZV9zbGFiKCZhdXRob3JfZGF0ZSk7Cn0KCnN0cnVjdCByZXZfY29sbGVjdCB7CglzdHJ1Y3QgY29tbWl0ICoqY29tbWl0OwoJaW50IG5yOwoJaW50IGFsbG9jOwoJdW5zaWduZWQgaW50IGluaXRpYWwgOiAxOwp9OwoKc3RhdGljIHZvaWQgYWRkX29uZV9jb21taXQoc3RydWN0IG9iamVjdF9pZCAqb2lkLCBzdHJ1Y3QgcmV2X2NvbGxlY3QgKnJldnMpCnsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCglpZiAoaXNfbnVsbF9vaWQob2lkKSkKCQlyZXR1cm47CgoJY29tbWl0ID0gbG9va3VwX2NvbW1pdCh0aGVfcmVwb3NpdG9yeSwgb2lkKTsKCWlmICghY29tbWl0IHx8CgkgICAgKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgVE1QX01BUkspIHx8CgkgICAgcmVwb19wYXJzZV9jb21taXQodGhlX3JlcG9zaXRvcnksIGNvbW1pdCkpCgkJcmV0dXJuOwoKCUFMTE9DX0dST1cocmV2cy0+Y29tbWl0LCByZXZzLT5uciArIDEsIHJldnMtPmFsbG9jKTsKCXJldnMtPmNvbW1pdFtyZXZzLT5ucisrXSA9IGNvbW1pdDsKCWNvbW1pdC0+b2JqZWN0LmZsYWdzIHw9IFRNUF9NQVJLOwp9CgpzdGF0aWMgaW50IGNvbGxlY3Rfb25lX3JlZmxvZ19lbnQoc3RydWN0IG9iamVjdF9pZCAqb29pZCwgc3RydWN0IG9iamVjdF9pZCAqbm9pZCwKCQkJCSAgY29uc3QgY2hhciAqaWRlbnQgVU5VU0VELAoJCQkJICB0aW1lc3RhbXBfdCB0aW1lc3RhbXAgVU5VU0VELCBpbnQgdHogVU5VU0VELAoJCQkJICBjb25zdCBjaGFyICptZXNzYWdlIFVOVVNFRCwgdm9pZCAqY2JkYXRhKQp7CglzdHJ1Y3QgcmV2X2NvbGxlY3QgKnJldnMgPSBjYmRhdGE7CgoJaWYgKHJldnMtPmluaXRpYWwpIHsKCQlyZXZzLT5pbml0aWFsID0gMDsKCQlhZGRfb25lX2NvbW1pdChvb2lkLCByZXZzKTsKCX0KCWFkZF9vbmVfY29tbWl0KG5vaWQsIHJldnMpOwoJcmV0dXJuIDA7Cn0KCnN0cnVjdCBjb21taXQgKmdldF9mb3JrX3BvaW50KGNvbnN0IGNoYXIgKnJlZm5hbWUsIHN0cnVjdCBjb21taXQgKmNvbW1pdCkKewoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CglzdHJ1Y3QgcmV2X2NvbGxlY3QgcmV2czsKCXN0cnVjdCBjb21taXRfbGlzdCAqYmFzZXMgPSBOVUxMOwoJaW50IGk7CglzdHJ1Y3QgY29tbWl0ICpyZXQgPSBOVUxMOwoJY2hhciAqZnVsbF9yZWZuYW1lOwoKCXN3aXRjaCAocmVwb19kd2ltX3JlZih0aGVfcmVwb3NpdG9yeSwgcmVmbmFtZSwgc3RybGVuKHJlZm5hbWUpLCAmb2lkLAoJCQkgICAgICAmZnVsbF9yZWZuYW1lLCAwKSkgewoJY2FzZSAwOgoJCWRpZSgiTm8gc3VjaCByZWY6ICclcyciLCByZWZuYW1lKTsKCWNhc2UgMToKCQlicmVhazsgLyogZ29vZCAqLwoJZGVmYXVsdDoKCQlkaWUoIkFtYmlndW91cyByZWZuYW1lOiAnJXMnIiwgcmVmbmFtZSk7Cgl9CgoJbWVtc2V0KCZyZXZzLCAwLCBzaXplb2YocmV2cykpOwoJcmV2cy5pbml0aWFsID0gMTsKCXJlZnNfZm9yX2VhY2hfcmVmbG9nX2VudChnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLAoJCQkJIGZ1bGxfcmVmbmFtZSwgY29sbGVjdF9vbmVfcmVmbG9nX2VudCwgJnJldnMpOwoKCWlmICghcmV2cy5ucikKCQlhZGRfb25lX2NvbW1pdCgmb2lkLCAmcmV2cyk7CgoJZm9yIChpID0gMDsgaSA8IHJldnMubnI7IGkrKykKCQlyZXZzLmNvbW1pdFtpXS0+b2JqZWN0LmZsYWdzICY9IH5UTVBfTUFSSzsKCglpZiAocmVwb19nZXRfbWVyZ2VfYmFzZXNfbWFueSh0aGVfcmVwb3NpdG9yeSwgY29tbWl0LCByZXZzLm5yLAoJCQkJICAgICAgcmV2cy5jb21taXQsICZiYXNlcykgPCAwKQoJCWV4aXQoMTI4KTsKCgkvKgoJICogVGhlcmUgc2hvdWxkIGJlIG9uZSBhbmQgb25seSBvbmUgbWVyZ2UgYmFzZSwgd2hlbiB3ZSBmb3VuZAoJICogYSBjb21tb24gYW5jZXN0b3IgYW1vbmcgcmVmbG9nIGVudHJpZXMuCgkgKi8KCWlmICghYmFzZXMgfHwgYmFzZXMtPm5leHQpCgkJZ290byBjbGVhbnVwX3JldHVybjsKCgkvKiBBbmQgdGhlIGZvdW5kIG9uZSBtdXN0IGJlIG9uZSBvZiB0aGUgcmVmbG9nIGVudHJpZXMgKi8KCWZvciAoaSA9IDA7IGkgPCByZXZzLm5yOyBpKyspCgkJaWYgKCZiYXNlcy0+aXRlbS0+b2JqZWN0ID09ICZyZXZzLmNvbW1pdFtpXS0+b2JqZWN0KQoJCQlicmVhazsgLyogZm91bmQgKi8KCWlmIChyZXZzLm5yIDw9IGkpCgkJZ290byBjbGVhbnVwX3JldHVybjsKCglyZXQgPSBiYXNlcy0+aXRlbTsKCmNsZWFudXBfcmV0dXJuOgoJZnJlZShyZXZzLmNvbW1pdCk7CglmcmVlX2NvbW1pdF9saXN0KGJhc2VzKTsKCWZyZWUoZnVsbF9yZWZuYW1lKTsKCXJldHVybiByZXQ7Cn0KCi8qCiAqIEluZGV4ZWQgYnkgaGFzaCBhbGdvcml0aG0gaWRlbnRpZmllci4KICovCnN0YXRpYyBjb25zdCBjaGFyICpncGdfc2lnX2hlYWRlcnNbXSA9IHsKCU5VTEwsCgkiZ3Bnc2lnIiwKCSJncGdzaWctc2hhMjU2IiwKfTsKCmludCBhZGRfaGVhZGVyX3NpZ25hdHVyZShzdHJ1Y3Qgc3RyYnVmICpidWYsIHN0cnVjdCBzdHJidWYgKnNpZywgY29uc3Qgc3RydWN0IGdpdF9oYXNoX2FsZ28gKmFsZ28pCnsKCWludCBpbnNwb3MsIGNvcHlwb3M7Cgljb25zdCBjaGFyICplb2g7Cgljb25zdCBjaGFyICpncGdfc2lnX2hlYWRlciA9IGdwZ19zaWdfaGVhZGVyc1toYXNoX2FsZ29fYnlfcHRyKGFsZ28pXTsKCWludCBncGdfc2lnX2hlYWRlcl9sZW4gPSBzdHJsZW4oZ3BnX3NpZ19oZWFkZXIpOwoKCS8qIGZpbmQgdGhlIGVuZCBvZiB0aGUgaGVhZGVyICovCgllb2ggPSBzdHJzdHIoYnVmLT5idWYsICJcblxuIik7CglpZiAoIWVvaCkKCQlpbnNwb3MgPSBidWYtPmxlbjsKCWVsc2UKCQlpbnNwb3MgPSBlb2ggLSBidWYtPmJ1ZiArIDE7CgoJZm9yIChjb3B5cG9zID0gMDsgc2lnLT5idWZbY29weXBvc107ICkgewoJCWNvbnN0IGNoYXIgKmJvbCA9IHNpZy0+YnVmICsgY29weXBvczsKCQljb25zdCBjaGFyICplb2wgPSBzdHJjaHJudWwoYm9sLCAnXG4nKTsKCQlpbnQgbGVuID0gKGVvbCAtIGJvbCkgKyAhISplb2w7CgoJCWlmICghY29weXBvcykgewoJCQlzdHJidWZfaW5zZXJ0KGJ1ZiwgaW5zcG9zLCBncGdfc2lnX2hlYWRlciwgZ3BnX3NpZ19oZWFkZXJfbGVuKTsKCQkJaW5zcG9zICs9IGdwZ19zaWdfaGVhZGVyX2xlbjsKCQl9CgkJc3RyYnVmX2luc2VydHN0cihidWYsIGluc3BvcysrLCAiICIpOwoJCXN0cmJ1Zl9pbnNlcnQoYnVmLCBpbnNwb3MsIGJvbCwgbGVuKTsKCQlpbnNwb3MgKz0gbGVuOwoJCWNvcHlwb3MgKz0gbGVuOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgc2lnbl9jb21taXRfdG9fc3RyYnVmKHN0cnVjdCBzdHJidWYgKnNpZywgc3RydWN0IHN0cmJ1ZiAqYnVmLCBjb25zdCBjaGFyICprZXlpZCkKewoJY2hhciAqa2V5aWRfdG9fZnJlZSA9IE5VTEw7CglpbnQgcmV0ID0gMDsKCWlmICgha2V5aWQgfHwgISprZXlpZCkKCQlrZXlpZCA9IGtleWlkX3RvX2ZyZWUgPSBnZXRfc2lnbmluZ19rZXkoKTsKCWlmIChzaWduX2J1ZmZlcihidWYsIHNpZywga2V5aWQpKQoJCXJldCA9IC0xOwoJZnJlZShrZXlpZF90b19mcmVlKTsKCXJldHVybiByZXQ7Cn0KCmludCBwYXJzZV9zaWduZWRfY29tbWl0KGNvbnN0IHN0cnVjdCBjb21taXQgKmNvbW1pdCwKCQkJc3RydWN0IHN0cmJ1ZiAqcGF5bG9hZCwgc3RydWN0IHN0cmJ1ZiAqc2lnbmF0dXJlLAoJCQljb25zdCBzdHJ1Y3QgZ2l0X2hhc2hfYWxnbyAqYWxnb3ApCnsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCWNvbnN0IGNoYXIgKmJ1ZmZlciA9IHJlcG9fZ2V0X2NvbW1pdF9idWZmZXIodGhlX3JlcG9zaXRvcnksIGNvbW1pdCwKCQkJCQkJICAgICZzaXplKTsKCWludCByZXQgPSBwYXJzZV9idWZmZXJfc2lnbmVkX2J5X2hlYWRlcihidWZmZXIsIHNpemUsIHBheWxvYWQsIHNpZ25hdHVyZSwgYWxnb3ApOwoKCXJlcG9fdW51c2VfY29tbWl0X2J1ZmZlcih0aGVfcmVwb3NpdG9yeSwgY29tbWl0LCBidWZmZXIpOwoJcmV0dXJuIHJldDsKfQoKaW50IHBhcnNlX2J1ZmZlcl9zaWduZWRfYnlfaGVhZGVyKGNvbnN0IGNoYXIgKmJ1ZmZlciwKCQkJCSAgdW5zaWduZWQgbG9uZyBzaXplLAoJCQkJICBzdHJ1Y3Qgc3RyYnVmICpwYXlsb2FkLAoJCQkJICBzdHJ1Y3Qgc3RyYnVmICpzaWduYXR1cmUsCgkJCQkgIGNvbnN0IHN0cnVjdCBnaXRfaGFzaF9hbGdvICphbGdvcCkKewoJaW50IGluX3NpZ25hdHVyZSA9IDAsIHNhd19zaWduYXR1cmUgPSAwLCBvdGhlcl9zaWduYXR1cmUgPSAwOwoJY29uc3QgY2hhciAqbGluZSwgKnRhaWwsICpwOwoJY29uc3QgY2hhciAqZ3BnX3NpZ19oZWFkZXIgPSBncGdfc2lnX2hlYWRlcnNbaGFzaF9hbGdvX2J5X3B0cihhbGdvcCldOwoKCWxpbmUgPSBidWZmZXI7Cgl0YWlsID0gYnVmZmVyICsgc2l6ZTsKCXdoaWxlIChsaW5lIDwgdGFpbCkgewoJCWNvbnN0IGNoYXIgKnNpZyA9IE5VTEw7CgkJY29uc3QgY2hhciAqbmV4dCA9IG1lbWNocihsaW5lLCAnXG4nLCB0YWlsIC0gbGluZSk7CgoJCW5leHQgPSBuZXh0ID8gbmV4dCArIDEgOiB0YWlsOwoJCWlmIChpbl9zaWduYXR1cmUgJiYgbGluZVswXSA9PSAnICcpCgkJCXNpZyA9IGxpbmUgKyAxOwoJCWVsc2UgaWYgKHNraXBfcHJlZml4KGxpbmUsIGdwZ19zaWdfaGVhZGVyLCAmcCkgJiYKCQkJICpwID09ICcgJykgewoJCQlzaWcgPSBsaW5lICsgc3RybGVuKGdwZ19zaWdfaGVhZGVyKSArIDE7CgkJCW90aGVyX3NpZ25hdHVyZSA9IDA7CgkJfQoJCWVsc2UgaWYgKHN0YXJ0c193aXRoKGxpbmUsICJncGdzaWciKSkKCQkJb3RoZXJfc2lnbmF0dXJlID0gMTsKCQllbHNlIGlmIChvdGhlcl9zaWduYXR1cmUgJiYgbGluZVswXSAhPSAnICcpCgkJCW90aGVyX3NpZ25hdHVyZSA9IDA7CgkJaWYgKHNpZykgewoJCQlzdHJidWZfYWRkKHNpZ25hdHVyZSwgc2lnLCBuZXh0IC0gc2lnKTsKCQkJc2F3X3NpZ25hdHVyZSA9IDE7CgkJCWluX3NpZ25hdHVyZSA9IDE7CgkJfSBlbHNlIHsKCQkJaWYgKCpsaW5lID09ICdcbicpCgkJCQkvKiBkdW1wIHRoZSB3aG9sZSByZW1haW5kZXIgb2YgdGhlIGJ1ZmZlciAqLwoJCQkJbmV4dCA9IHRhaWw7CgkJCWlmICghb3RoZXJfc2lnbmF0dXJlKQoJCQkJc3RyYnVmX2FkZChwYXlsb2FkLCBsaW5lLCBuZXh0IC0gbGluZSk7CgkJCWluX3NpZ25hdHVyZSA9IDA7CgkJfQoJCWxpbmUgPSBuZXh0OwoJfQoJcmV0dXJuIHNhd19zaWduYXR1cmU7Cn0KCmludCByZW1vdmVfc2lnbmF0dXJlKHN0cnVjdCBzdHJidWYgKmJ1ZikKewoJY29uc3QgY2hhciAqbGluZSA9IGJ1Zi0+YnVmOwoJY29uc3QgY2hhciAqdGFpbCA9IGJ1Zi0+YnVmICsgYnVmLT5sZW47CglpbnQgaW5fc2lnbmF0dXJlID0gMDsKCXN0cnVjdCBzaWdidWYgewoJCWNvbnN0IGNoYXIgKnN0YXJ0OwoJCWNvbnN0IGNoYXIgKmVuZDsKCX0gc2lnc1syXSwgKnNpZ3AgPSAmc2lnc1swXTsKCWludCBpOwoJY29uc3QgY2hhciAqb3JpZ19idWYgPSBidWYtPmJ1ZjsKCgltZW1zZXQoc2lncywgMCwgc2l6ZW9mKHNpZ3MpKTsKCgl3aGlsZSAobGluZSA8IHRhaWwpIHsKCQljb25zdCBjaGFyICpuZXh0ID0gbWVtY2hyKGxpbmUsICdcbicsIHRhaWwgLSBsaW5lKTsKCQluZXh0ID0gbmV4dCA/IG5leHQgKyAxIDogdGFpbDsKCgkJaWYgKGluX3NpZ25hdHVyZSAmJiBsaW5lWzBdID09ICcgJykKCQkJc2lncC0+ZW5kID0gbmV4dDsKCQllbHNlIGlmIChzdGFydHNfd2l0aChsaW5lLCAiZ3Bnc2lnIikpIHsKCQkJaW50IGk7CgkJCWZvciAoaSA9IDE7IGkgPCBHSVRfSEFTSF9OQUxHT1M7IGkrKykgewoJCQkJY29uc3QgY2hhciAqcDsKCQkJCWlmIChza2lwX3ByZWZpeChsaW5lLCBncGdfc2lnX2hlYWRlcnNbaV0sICZwKSAmJgoJCQkJICAgICpwID09ICcgJykgewoJCQkJCXNpZ3AtPnN0YXJ0ID0gbGluZTsKCQkJCQlzaWdwLT5lbmQgPSBuZXh0OwoJCQkJCWluX3NpZ25hdHVyZSA9IDE7CgkJCQl9CgkJCX0KCQl9IGVsc2UgewoJCQlpZiAoKmxpbmUgPT0gJ1xuJykKCQkJCS8qIGR1bXAgdGhlIHdob2xlIHJlbWFpbmRlciBvZiB0aGUgYnVmZmVyICovCgkJCQluZXh0ID0gdGFpbDsKCQkJaWYgKGluX3NpZ25hdHVyZSAmJiBzaWdwIC0gc2lncyAhPSBBUlJBWV9TSVpFKHNpZ3MpKQoJCQkJc2lncCsrOwoJCQlpbl9zaWduYXR1cmUgPSAwOwoJCX0KCQlsaW5lID0gbmV4dDsKCX0KCglmb3IgKGkgPSBBUlJBWV9TSVpFKHNpZ3MpIC0gMTsgaSA+PSAwOyBpLS0pCgkJaWYgKHNpZ3NbaV0uc3RhcnQpCgkJCXN0cmJ1Zl9yZW1vdmUoYnVmLCBzaWdzW2ldLnN0YXJ0IC0gb3JpZ19idWYsIHNpZ3NbaV0uZW5kIC0gc2lnc1tpXS5zdGFydCk7CgoJcmV0dXJuIHNpZ3NbMF0uc3RhcnQgIT0gTlVMTDsKfQoKc3RhdGljIHZvaWQgaGFuZGxlX3NpZ25lZF90YWcoY29uc3Qgc3RydWN0IGNvbW1pdCAqcGFyZW50LCBzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqKip0YWlsKQp7CglzdHJ1Y3QgbWVyZ2VfcmVtb3RlX2Rlc2MgKmRlc2M7CglzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqbWVyZ2V0YWc7CgljaGFyICpidWY7Cgl1bnNpZ25lZCBsb25nIHNpemU7CgllbnVtIG9iamVjdF90eXBlIHR5cGU7CglzdHJ1Y3Qgc3RyYnVmIHBheWxvYWQgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgc2lnbmF0dXJlID0gU1RSQlVGX0lOSVQ7CgoJZGVzYyA9IG1lcmdlX3JlbW90ZV91dGlsKHBhcmVudCk7CglpZiAoIWRlc2MgfHwgIWRlc2MtPm9iaikKCQlyZXR1cm47CglidWYgPSByZXBvX3JlYWRfb2JqZWN0X2ZpbGUodGhlX3JlcG9zaXRvcnksICZkZXNjLT5vYmotPm9pZCwgJnR5cGUsCgkJCQkgICAgJnNpemUpOwoJaWYgKCFidWYgfHwgdHlwZSAhPSBPQkpfVEFHKQoJCWdvdG8gZnJlZV9yZXR1cm47CglpZiAoIXBhcnNlX3NpZ25hdHVyZShidWYsIHNpemUsICZwYXlsb2FkLCAmc2lnbmF0dXJlKSkKCQlnb3RvIGZyZWVfcmV0dXJuOwoJLyoKCSAqIFdlIGNvdWxkIHZlcmlmeSB0aGlzIHNpZ25hdHVyZSBhbmQgZWl0aGVyIG9taXQgdGhlIHRhZyB3aGVuCgkgKiBpdCBkb2VzIG5vdCB2YWxpZGF0ZSwgYnV0IHRoZSBpbnRlZ3JhdG9yIG1heSBub3QgaGF2ZSB0aGUKCSAqIHB1YmxpYyBrZXkgb2YgdGhlIHNpZ25lciBvZiB0aGUgdGFnIGJlaW5nIG1lcmdlZCwgd2hpbGUgYQoJICogbGF0ZXIgYXVkaXRvciBtYXkgaGF2ZSBpdCB3aGlsZSBhdWRpdGluZywgc28gbGV0J3Mgbm90IHJ1bgoJICogdmVyaWZ5LXNpZ25lZC1idWZmZXIgaGVyZSBmb3Igbm93Li4uCgkgKgoJICogaWYgKHZlcmlmeV9zaWduZWRfYnVmZmVyKGJ1ZiwgbGVuLCBidWYgKyBsZW4sIHNpemUgLSBsZW4sIC4uLikpCgkgKgl3YXJuKCJ3YXJuaW5nOiBzaWduZWQgdGFnIHVudmVyaWZpZWQuIik7CgkgKi8KCUNBTExPQ19BUlJBWShtZXJnZXRhZywgMSk7CgltZXJnZXRhZy0+a2V5ID0geHN0cmR1cCgibWVyZ2V0YWciKTsKCW1lcmdldGFnLT52YWx1ZSA9IGJ1ZjsKCW1lcmdldGFnLT5sZW4gPSBzaXplOwoKCSoqdGFpbCA9IG1lcmdldGFnOwoJKnRhaWwgPSAmbWVyZ2V0YWctPm5leHQ7CglzdHJidWZfcmVsZWFzZSgmcGF5bG9hZCk7CglzdHJidWZfcmVsZWFzZSgmc2lnbmF0dXJlKTsKCXJldHVybjsKCmZyZWVfcmV0dXJuOgoJZnJlZShidWYpOwp9CgppbnQgY2hlY2tfY29tbWl0X3NpZ25hdHVyZShjb25zdCBzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHN0cnVjdCBzaWduYXR1cmVfY2hlY2sgKnNpZ2MpCnsKCXN0cnVjdCBzdHJidWYgcGF5bG9hZCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBzaWduYXR1cmUgPSBTVFJCVUZfSU5JVDsKCWludCByZXQgPSAxOwoKCXNpZ2MtPnJlc3VsdCA9ICdOJzsKCglpZiAocGFyc2Vfc2lnbmVkX2NvbW1pdChjb21taXQsICZwYXlsb2FkLCAmc2lnbmF0dXJlLCB0aGVfaGFzaF9hbGdvKSA8PSAwKQoJCWdvdG8gb3V0OwoKCXNpZ2MtPnBheWxvYWRfdHlwZSA9IFNJR05BVFVSRV9QQVlMT0FEX0NPTU1JVDsKCXNpZ2MtPnBheWxvYWQgPSBzdHJidWZfZGV0YWNoKCZwYXlsb2FkLCAmc2lnYy0+cGF5bG9hZF9sZW4pOwoJcmV0ID0gY2hlY2tfc2lnbmF0dXJlKHNpZ2MsIHNpZ25hdHVyZS5idWYsIHNpZ25hdHVyZS5sZW4pOwoKIG91dDoKCXN0cmJ1Zl9yZWxlYXNlKCZwYXlsb2FkKTsKCXN0cmJ1Zl9yZWxlYXNlKCZzaWduYXR1cmUpOwoKCXJldHVybiByZXQ7Cn0KCnZvaWQgdmVyaWZ5X21lcmdlX3NpZ25hdHVyZShzdHJ1Y3QgY29tbWl0ICpjb21taXQsIGludCB2ZXJib3NpdHksCgkJCSAgICBpbnQgY2hlY2tfdHJ1c3QpCnsKCWNoYXIgaGV4W0dJVF9NQVhfSEVYU1ogKyAxXTsKCXN0cnVjdCBzaWduYXR1cmVfY2hlY2sgc2lnbmF0dXJlX2NoZWNrOwoJaW50IHJldDsKCW1lbXNldCgmc2lnbmF0dXJlX2NoZWNrLCAwLCBzaXplb2Yoc2lnbmF0dXJlX2NoZWNrKSk7CgoJcmV0ID0gY2hlY2tfY29tbWl0X3NpZ25hdHVyZShjb21taXQsICZzaWduYXR1cmVfY2hlY2spOwoKCXJlcG9fZmluZF91bmlxdWVfYWJicmV2X3IodGhlX3JlcG9zaXRvcnksIGhleCwgJmNvbW1pdC0+b2JqZWN0Lm9pZCwKCQkJCSAgREVGQVVMVF9BQkJSRVYpOwoJc3dpdGNoIChzaWduYXR1cmVfY2hlY2sucmVzdWx0KSB7CgljYXNlICdHJzoKCQlpZiAocmV0IHx8IChjaGVja190cnVzdCAmJiBzaWduYXR1cmVfY2hlY2sudHJ1c3RfbGV2ZWwgPCBUUlVTVF9NQVJHSU5BTCkpCgkJCWRpZShfKCJDb21taXQgJXMgaGFzIGFuIHVudHJ1c3RlZCBHUEcgc2lnbmF0dXJlLCAiCgkJCSAgICAgICJhbGxlZ2VkbHkgYnkgJXMuIiksIGhleCwgc2lnbmF0dXJlX2NoZWNrLnNpZ25lcik7CgkJYnJlYWs7CgljYXNlICdCJzoKCQlkaWUoXygiQ29tbWl0ICVzIGhhcyBhIGJhZCBHUEcgc2lnbmF0dXJlICIKCQkgICAgICAiYWxsZWdlZGx5IGJ5ICVzLiIpLCBoZXgsIHNpZ25hdHVyZV9jaGVjay5zaWduZXIpOwoJZGVmYXVsdDogLyogJ04nICovCgkJZGllKF8oIkNvbW1pdCAlcyBkb2VzIG5vdCBoYXZlIGEgR1BHIHNpZ25hdHVyZS4iKSwgaGV4KTsKCX0KCWlmICh2ZXJib3NpdHkgPj0gMCAmJiBzaWduYXR1cmVfY2hlY2sucmVzdWx0ID09ICdHJykKCQlwcmludGYoXygiQ29tbWl0ICVzIGhhcyBhIGdvb2QgR1BHIHNpZ25hdHVyZSBieSAlc1xuIiksCgkJICAgICAgIGhleCwgc2lnbmF0dXJlX2NoZWNrLnNpZ25lcik7CgoJc2lnbmF0dXJlX2NoZWNrX2NsZWFyKCZzaWduYXR1cmVfY2hlY2spOwp9Cgp2b2lkIGFwcGVuZF9tZXJnZV90YWdfaGVhZGVycyhjb25zdCBzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMsCgkJCSAgICAgIHN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICoqKnRhaWwpCnsKCXdoaWxlIChwYXJlbnRzKSB7CgkJY29uc3Qgc3RydWN0IGNvbW1pdCAqcGFyZW50ID0gcGFyZW50cy0+aXRlbTsKCQloYW5kbGVfc2lnbmVkX3RhZyhwYXJlbnQsIHRhaWwpOwoJCXBhcmVudHMgPSBwYXJlbnRzLT5uZXh0OwoJfQp9CgpzdGF0aWMgaW50IGNvbnZlcnRfY29tbWl0X2V4dHJhX2hlYWRlcnMoY29uc3Qgc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKm9yaWcsCgkJCQkJc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKipyZXN1bHQpCnsKCWNvbnN0IHN0cnVjdCBnaXRfaGFzaF9hbGdvICpjb21wYXQgPSB0aGVfcmVwb3NpdG9yeS0+Y29tcGF0X2hhc2hfYWxnbzsKCWNvbnN0IHN0cnVjdCBnaXRfaGFzaF9hbGdvICphbGdvID0gdGhlX3JlcG9zaXRvcnktPmhhc2hfYWxnbzsKCXN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpleHRyYSA9IE5VTEwsICoqdGFpbCA9ICZleHRyYTsKCXN0cnVjdCBzdHJidWYgb3V0ID0gU1RSQlVGX0lOSVQ7Cgl3aGlsZSAob3JpZykgewoJCXN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpuZXc7CgkJQ0FMTE9DX0FSUkFZKG5ldywgMSk7CgkJaWYgKCFzdHJjbXAob3JpZy0+a2V5LCAibWVyZ2V0YWciKSkgewoJCQlpZiAoY29udmVydF9vYmplY3RfZmlsZSh0aGVfcmVwb3NpdG9yeSwgJm91dCwgYWxnbywgY29tcGF0LAoJCQkJCQlvcmlnLT52YWx1ZSwgb3JpZy0+bGVuLAoJCQkJCQlPQkpfVEFHLCAxKSkgewoJCQkJZnJlZShuZXcpOwoJCQkJZnJlZV9jb21taXRfZXh0cmFfaGVhZGVycyhleHRyYSk7CgkJCQlyZXR1cm4gLTE7CgkJCX0KCQkJbmV3LT5rZXkgPSB4c3RyZHVwKCJtZXJnZXRhZyIpOwoJCQluZXctPnZhbHVlID0gc3RyYnVmX2RldGFjaCgmb3V0LCAmbmV3LT5sZW4pOwoJCX0gZWxzZSB7CgkJCW5ldy0+a2V5ID0geHN0cmR1cChvcmlnLT5rZXkpOwoJCQluZXctPmxlbiA9IG9yaWctPmxlbjsKCQkJbmV3LT52YWx1ZSA9IHhtZW1kdXB6KG9yaWctPnZhbHVlLCBvcmlnLT5sZW4pOwoJCX0KCQkqdGFpbCA9IG5ldzsKCQl0YWlsID0gJm5ldy0+bmV4dDsKCQlvcmlnID0gb3JpZy0+bmV4dDsKCX0KCSpyZXN1bHQgPSBleHRyYTsKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBhZGRfZXh0cmFfaGVhZGVyKHN0cnVjdCBzdHJidWYgKmJ1ZmZlciwKCQkJICAgICBjb25zdCBzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqZXh0cmEpCnsKCXN0cmJ1Zl9hZGRzdHIoYnVmZmVyLCBleHRyYS0+a2V5KTsKCWlmIChleHRyYS0+bGVuKQoJCXN0cmJ1Zl9hZGRfbGluZXMoYnVmZmVyLCAiICIsIGV4dHJhLT52YWx1ZSwgZXh0cmEtPmxlbik7CgllbHNlCgkJc3RyYnVmX2FkZGNoKGJ1ZmZlciwgJ1xuJyk7Cn0KCnN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpyZWFkX2NvbW1pdF9leHRyYV9oZWFkZXJzKHN0cnVjdCBjb21taXQgKmNvbW1pdCwKCQkJCQkJICAgICAgY29uc3QgY2hhciAqKmV4Y2x1ZGUpCnsKCXN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpleHRyYSA9IE5VTEw7Cgl1bnNpZ25lZCBsb25nIHNpemU7Cgljb25zdCBjaGFyICpidWZmZXIgPSByZXBvX2dldF9jb21taXRfYnVmZmVyKHRoZV9yZXBvc2l0b3J5LCBjb21taXQsCgkJCQkJCSAgICAmc2l6ZSk7CglleHRyYSA9IHJlYWRfY29tbWl0X2V4dHJhX2hlYWRlcl9saW5lcyhidWZmZXIsIHNpemUsIGV4Y2x1ZGUpOwoJcmVwb191bnVzZV9jb21taXRfYnVmZmVyKHRoZV9yZXBvc2l0b3J5LCBjb21taXQsIGJ1ZmZlcik7CglyZXR1cm4gZXh0cmE7Cn0KCmludCBmb3JfZWFjaF9tZXJnZXRhZyhlYWNoX21lcmdldGFnX2ZuIGZuLCBzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHZvaWQgKmRhdGEpCnsKCXN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpleHRyYSwgKnRvX2ZyZWU7CglpbnQgcmVzID0gMDsKCgl0b19mcmVlID0gcmVhZF9jb21taXRfZXh0cmFfaGVhZGVycyhjb21taXQsIE5VTEwpOwoJZm9yIChleHRyYSA9IHRvX2ZyZWU7ICFyZXMgJiYgZXh0cmE7IGV4dHJhID0gZXh0cmEtPm5leHQpIHsKCQlpZiAoc3RyY21wKGV4dHJhLT5rZXksICJtZXJnZXRhZyIpKQoJCQljb250aW51ZTsgLyogbm90IGEgbWVyZ2UgdGFnICovCgkJcmVzID0gZm4oY29tbWl0LCBleHRyYSwgZGF0YSk7Cgl9CglmcmVlX2NvbW1pdF9leHRyYV9oZWFkZXJzKHRvX2ZyZWUpOwoJcmV0dXJuIHJlczsKfQoKc3RhdGljIGlubGluZSBpbnQgc3RhbmRhcmRfaGVhZGVyX2ZpZWxkKGNvbnN0IGNoYXIgKmZpZWxkLCBzaXplX3QgbGVuKQp7CglyZXR1cm4gKChsZW4gPT0gNCAmJiAhbWVtY21wKGZpZWxkLCAidHJlZSIsIDQpKSB8fAoJCShsZW4gPT0gNiAmJiAhbWVtY21wKGZpZWxkLCAicGFyZW50IiwgNikpIHx8CgkJKGxlbiA9PSA2ICYmICFtZW1jbXAoZmllbGQsICJhdXRob3IiLCA2KSkgfHwKCQkobGVuID09IDkgJiYgIW1lbWNtcChmaWVsZCwgImNvbW1pdHRlciIsIDkpKSB8fAoJCShsZW4gPT0gOCAmJiAhbWVtY21wKGZpZWxkLCAiZW5jb2RpbmciLCA4KSkpOwp9CgpzdGF0aWMgaW50IGV4Y2x1ZGVkX2hlYWRlcl9maWVsZChjb25zdCBjaGFyICpmaWVsZCwgc2l6ZV90IGxlbiwgY29uc3QgY2hhciAqKmV4Y2x1ZGUpCnsKCWlmICghZXhjbHVkZSkKCQlyZXR1cm4gMDsKCgl3aGlsZSAoKmV4Y2x1ZGUpIHsKCQlzaXplX3QgeGxlbiA9IHN0cmxlbigqZXhjbHVkZSk7CgkJaWYgKGxlbiA9PSB4bGVuICYmICFtZW1jbXAoZmllbGQsICpleGNsdWRlLCB4bGVuKSkKCQkJcmV0dXJuIDE7CgkJZXhjbHVkZSsrOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqcmVhZF9jb21taXRfZXh0cmFfaGVhZGVyX2xpbmVzKAoJY29uc3QgY2hhciAqYnVmZmVyLCBzaXplX3Qgc2l6ZSwKCWNvbnN0IGNoYXIgKipleGNsdWRlKQp7CglzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqZXh0cmEgPSBOVUxMLCAqKnRhaWwgPSAmZXh0cmEsICppdCA9IE5VTEw7Cgljb25zdCBjaGFyICpsaW5lLCAqbmV4dCwgKmVvZiwgKmVvYjsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJZm9yIChsaW5lID0gYnVmZmVyLCBlb2IgPSBsaW5lICsgc2l6ZTsKCSAgICAgbGluZSA8IGVvYiAmJiAqbGluZSAhPSAnXG4nOwoJICAgICBsaW5lID0gbmV4dCkgewoJCW5leHQgPSBtZW1jaHIobGluZSwgJ1xuJywgZW9iIC0gbGluZSk7CgkJbmV4dCA9IG5leHQgPyBuZXh0ICsgMSA6IGVvYjsKCQlpZiAoKmxpbmUgPT0gJyAnKSB7CgkJCS8qIGNvbnRpbnVhdGlvbiAqLwoJCQlpZiAoaXQpCgkJCQlzdHJidWZfYWRkKCZidWYsIGxpbmUgKyAxLCBuZXh0IC0gKGxpbmUgKyAxKSk7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoaXQpCgkJCWl0LT52YWx1ZSA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgJml0LT5sZW4pOwoJCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCQlpdCA9IE5VTEw7CgoJCWVvZiA9IG1lbWNocihsaW5lLCAnICcsIG5leHQgLSBsaW5lKTsKCQlpZiAoIWVvZikKCQkJZW9mID0gbmV4dDsKCQllbHNlIGlmIChzdGFuZGFyZF9oZWFkZXJfZmllbGQobGluZSwgZW9mIC0gbGluZSkgfHwKCQkJIGV4Y2x1ZGVkX2hlYWRlcl9maWVsZChsaW5lLCBlb2YgLSBsaW5lLCBleGNsdWRlKSkKCQkJY29udGludWU7CgoJCUNBTExPQ19BUlJBWShpdCwgMSk7CgkJaXQtPmtleSA9IHhtZW1kdXB6KGxpbmUsIGVvZi1saW5lKTsKCQkqdGFpbCA9IGl0OwoJCXRhaWwgPSAmaXQtPm5leHQ7CgkJaWYgKGVvZiArIDEgPCBuZXh0KQoJCQlzdHJidWZfYWRkKCZidWYsIGVvZiArIDEsIG5leHQgLSAoZW9mICsgMSkpOwoJfQoJaWYgKGl0KQoJCWl0LT52YWx1ZSA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgJml0LT5sZW4pOwoJcmV0dXJuIGV4dHJhOwp9Cgp2b2lkIGZyZWVfY29tbWl0X2V4dHJhX2hlYWRlcnMoc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKmV4dHJhKQp7Cgl3aGlsZSAoZXh0cmEpIHsKCQlzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqbmV4dCA9IGV4dHJhLT5uZXh0OwoJCWZyZWUoZXh0cmEtPmtleSk7CgkJZnJlZShleHRyYS0+dmFsdWUpOwoJCWZyZWUoZXh0cmEpOwoJCWV4dHJhID0gbmV4dDsKCX0KfQoKaW50IGNvbW1pdF90cmVlKGNvbnN0IGNoYXIgKm1zZywgc2l6ZV90IG1zZ19sZW4sIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKnRyZWUsCgkJY29uc3Qgc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzLCBzdHJ1Y3Qgb2JqZWN0X2lkICpyZXQsCgkJY29uc3QgY2hhciAqYXV0aG9yLCBjb25zdCBjaGFyICpzaWduX2NvbW1pdCkKewoJc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKmV4dHJhID0gTlVMTCwgKip0YWlsID0gJmV4dHJhOwoJaW50IHJlc3VsdDsKCglhcHBlbmRfbWVyZ2VfdGFnX2hlYWRlcnMocGFyZW50cywgJnRhaWwpOwoJcmVzdWx0ID0gY29tbWl0X3RyZWVfZXh0ZW5kZWQobXNnLCBtc2dfbGVuLCB0cmVlLCBwYXJlbnRzLCByZXQsIGF1dGhvciwKCQkJCSAgICAgIE5VTEwsIHNpZ25fY29tbWl0LCBleHRyYSk7CglmcmVlX2NvbW1pdF9leHRyYV9oZWFkZXJzKGV4dHJhKTsKCXJldHVybiByZXN1bHQ7Cn0KCnN0YXRpYyBpbnQgZmluZF9pbnZhbGlkX3V0ZjgoY29uc3QgY2hhciAqYnVmLCBpbnQgbGVuKQp7CglpbnQgb2Zmc2V0ID0gMDsKCXN0YXRpYyBjb25zdCB1bnNpZ25lZCBpbnQgbWF4X2NvZGVwb2ludFtdID0gewoJCTB4N2YsIDB4N2ZmLCAweGZmZmYsIDB4MTBmZmZmCgl9OwoKCXdoaWxlIChsZW4pIHsKCQl1bnNpZ25lZCBjaGFyIGMgPSAqYnVmKys7CgkJaW50IGJ5dGVzLCBiYWRfb2Zmc2V0OwoJCXVuc2lnbmVkIGludCBjb2RlcG9pbnQ7CgkJdW5zaWduZWQgaW50IG1pbl92YWwsIG1heF92YWw7CgoJCWxlbi0tOwoJCW9mZnNldCsrOwoKCQkvKiBTaW1wbGUgVVMtQVNDSUk/IE5vIHdvcnJpZXMuICovCgkJaWYgKGMgPCAweDgwKQoJCQljb250aW51ZTsKCgkJYmFkX29mZnNldCA9IG9mZnNldC0xOwoKCQkvKgoJCSAqIENvdW50IGhvdyBtYW55IG1vcmUgaGlnaCBiaXRzIHNldDogdGhhdCdzIGhvdwoJCSAqIG1hbnkgbW9yZSBieXRlcyB0aGlzIHNlcXVlbmNlIHNob3VsZCBoYXZlLgoJCSAqLwoJCWJ5dGVzID0gMDsKCQl3aGlsZSAoYyAmIDB4NDApIHsKCQkJYyA8PD0gMTsKCQkJYnl0ZXMrKzsKCQl9CgoJCS8qCgkJICogTXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDMgbW9yZSBieXRlcy4gIExvbmdlciBzZXF1ZW5jZXMgcmVzdWx0IGluCgkJICogY29kZXBvaW50cyBiZXlvbmQgVSsxMEZGRkYsIHdoaWNoIGFyZSBndWFyYW50ZWVkIG5ldmVyIHRvIGV4aXN0LgoJCSAqLwoJCWlmIChieXRlcyA8IDEgfHwgMyA8IGJ5dGVzKQoJCQlyZXR1cm4gYmFkX29mZnNldDsKCgkJLyogRG8gd2UgKmhhdmUqIHRoYXQgbWFueSBieXRlcz8gKi8KCQlpZiAobGVuIDwgYnl0ZXMpCgkJCXJldHVybiBiYWRfb2Zmc2V0OwoKCQkvKgoJCSAqIFBsYWNlIHRoZSBlbmNvZGVkIGJpdHMgYXQgdGhlIGJvdHRvbSBvZiB0aGUgdmFsdWUgYW5kIGNvbXB1dGUgdGhlCgkJICogdmFsaWQgcmFuZ2UuCgkJICovCgkJY29kZXBvaW50ID0gKGMgJiAweDdmKSA+PiBieXRlczsKCQltaW5fdmFsID0gbWF4X2NvZGVwb2ludFtieXRlcy0xXSArIDE7CgkJbWF4X3ZhbCA9IG1heF9jb2RlcG9pbnRbYnl0ZXNdOwoKCQlvZmZzZXQgKz0gYnl0ZXM7CgkJbGVuIC09IGJ5dGVzOwoKCQkvKiBBbmQgdmVyaWZ5IHRoYXQgdGhleSBhcmUgZ29vZCBjb250aW51YXRpb24gYnl0ZXMgKi8KCQlkbyB7CgkJCWNvZGVwb2ludCA8PD0gNjsKCQkJY29kZXBvaW50IHw9ICpidWYgJiAweDNmOwoJCQlpZiAoKCpidWYrKyAmIDB4YzApICE9IDB4ODApCgkJCQlyZXR1cm4gYmFkX29mZnNldDsKCQl9IHdoaWxlICgtLWJ5dGVzKTsKCgkJLyogUmVqZWN0IGNvZGVwb2ludHMgdGhhdCBhcmUgb3V0IG9mIHJhbmdlIGZvciB0aGUgc2VxdWVuY2UgbGVuZ3RoLiAqLwoJCWlmIChjb2RlcG9pbnQgPCBtaW5fdmFsIHx8IGNvZGVwb2ludCA+IG1heF92YWwpCgkJCXJldHVybiBiYWRfb2Zmc2V0OwoJCS8qIFN1cnJvZ2F0ZXMgYXJlIG9ubHkgZm9yIFVURi0xNiBhbmQgY2Fubm90IGJlIGVuY29kZWQgaW4gVVRGLTguICovCgkJaWYgKChjb2RlcG9pbnQgJiAweDFmZjgwMCkgPT0gMHhkODAwKQoJCQlyZXR1cm4gYmFkX29mZnNldDsKCQkvKiBVK3h4RkZGRSBhbmQgVSt4eEZGRkYgYXJlIGd1YXJhbnRlZWQgbm9uLWNoYXJhY3RlcnMuICovCgkJaWYgKChjb2RlcG9pbnQgJiAweGZmZmUpID09IDB4ZmZmZSkKCQkJcmV0dXJuIGJhZF9vZmZzZXQ7CgkJLyogU28gYXJlIGFueXRoaW5nIGluIHRoZSByYW5nZSBVK0ZERDAuLlUrRkRFRi4gKi8KCQlpZiAoY29kZXBvaW50ID49IDB4ZmRkMCAmJiBjb2RlcG9pbnQgPD0gMHhmZGVmKQoJCQlyZXR1cm4gYmFkX29mZnNldDsKCX0KCXJldHVybiAtMTsKfQoKLyoKICogVGhpcyB2ZXJpZmllcyB0aGF0IHRoZSBidWZmZXIgaXMgaW4gcHJvcGVyIHV0ZjggZm9ybWF0LgogKgogKiBJZiBpdCBpc24ndCwgaXQgYXNzdW1lcyBhbnkgbm9uLXV0ZjggY2hhcmFjdGVycyBhcmUgTGF0aW4xLAogKiBhbmQgZG9lcyB0aGUgY29udmVyc2lvbi4KICovCnN0YXRpYyBpbnQgdmVyaWZ5X3V0Zjgoc3RydWN0IHN0cmJ1ZiAqYnVmKQp7CglpbnQgb2sgPSAxOwoJbG9uZyBwb3MgPSAwOwoKCWZvciAoOzspIHsKCQlpbnQgYmFkOwoJCXVuc2lnbmVkIGNoYXIgYzsKCQl1bnNpZ25lZCBjaGFyIHJlcGxhY2VbMl07CgoJCWJhZCA9IGZpbmRfaW52YWxpZF91dGY4KGJ1Zi0+YnVmICsgcG9zLCBidWYtPmxlbiAtIHBvcyk7CgkJaWYgKGJhZCA8IDApCgkJCXJldHVybiBvazsKCQlwb3MgKz0gYmFkOwoJCW9rID0gMDsKCQljID0gYnVmLT5idWZbcG9zXTsKCQlzdHJidWZfcmVtb3ZlKGJ1ZiwgcG9zLCAxKTsKCgkJLyogV2Uga25vdyAnYycgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgMTI4LTI1NSAqLwoJCXJlcGxhY2VbMF0gPSAweGMwICsgKGMgPj4gNik7CgkJcmVwbGFjZVsxXSA9IDB4ODAgKyAoYyAmIDB4M2YpOwoJCXN0cmJ1Zl9pbnNlcnQoYnVmLCBwb3MsIHJlcGxhY2UsIDIpOwoJCXBvcyArPSAyOwoJfQp9CgpzdGF0aWMgY29uc3QgY2hhciBjb21taXRfdXRmOF93YXJuW10gPQpOXygiV2FybmluZzogY29tbWl0IG1lc3NhZ2UgZGlkIG5vdCBjb25mb3JtIHRvIFVURi04LlxuIgogICAiWW91IG1heSB3YW50IHRvIGFtZW5kIGl0IGFmdGVyIGZpeGluZyB0aGUgbWVzc2FnZSwgb3Igc2V0IHRoZSBjb25maWdcbiIKICAgInZhcmlhYmxlIGkxOG4uY29tbWl0RW5jb2RpbmcgdG8gdGhlIGVuY29kaW5nIHlvdXIgcHJvamVjdCB1c2VzLlxuIik7CgpzdGF0aWMgdm9pZCB3cml0ZV9jb21taXRfdHJlZShzdHJ1Y3Qgc3RyYnVmICpidWZmZXIsIGNvbnN0IGNoYXIgKm1zZywgc2l6ZV90IG1zZ19sZW4sCgkJCSAgICAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKnRyZWUsCgkJCSAgICAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKnBhcmVudHMsIHNpemVfdCBwYXJlbnRzX2xlbiwKCQkJICAgICAgY29uc3QgY2hhciAqYXV0aG9yLCBjb25zdCBjaGFyICpjb21taXR0ZXIsCgkJCSAgICAgIGNvbnN0IHN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpleHRyYSkKewoJaW50IGVuY29kaW5nX2lzX3V0Zjg7CglzaXplX3QgaTsKCgkvKiBOb3QgaGF2aW5nIGkxOG4uY29tbWl0ZW5jb2RpbmcgaXMgdGhlIHNhbWUgYXMgaGF2aW5nIHV0Zi04ICovCgllbmNvZGluZ19pc191dGY4ID0gaXNfZW5jb2RpbmdfdXRmOChnaXRfY29tbWl0X2VuY29kaW5nKTsKCglzdHJidWZfZ3JvdyhidWZmZXIsIDgxOTIpOyAvKiBzaG91bGQgYXZvaWQgcmVhbGxvY3MgZm9yIHRoZSBoZWFkZXJzICovCglzdHJidWZfYWRkZihidWZmZXIsICJ0cmVlICVzXG4iLCBvaWRfdG9faGV4KHRyZWUpKTsKCgkvKgoJICogTk9URSEgVGhpcyBvcmRlcmluZyBtZWFucyB0aGF0IHRoZSBzYW1lIGV4YWN0IHRyZWUgbWVyZ2VkIHdpdGggYQoJICogZGlmZmVyZW50IG9yZGVyIG9mIHBhcmVudHMgd2lsbCBiZSBhIF9kaWZmZXJlbnRfIGNoYW5nZXNldCBldmVuCgkgKiBpZiBldmVyeXRoaW5nIGVsc2Ugc3RheXMgdGhlIHNhbWUuCgkgKi8KCWZvciAoaSA9IDA7IGkgPCBwYXJlbnRzX2xlbjsgaSsrKQoJCXN0cmJ1Zl9hZGRmKGJ1ZmZlciwgInBhcmVudCAlc1xuIiwgb2lkX3RvX2hleCgmcGFyZW50c1tpXSkpOwoKCS8qIFBlcnNvbi9kYXRlIGluZm9ybWF0aW9uICovCglpZiAoIWF1dGhvcikKCQlhdXRob3IgPSBnaXRfYXV0aG9yX2luZm8oSURFTlRfU1RSSUNUKTsKCXN0cmJ1Zl9hZGRmKGJ1ZmZlciwgImF1dGhvciAlc1xuIiwgYXV0aG9yKTsKCWlmICghY29tbWl0dGVyKQoJCWNvbW1pdHRlciA9IGdpdF9jb21taXR0ZXJfaW5mbyhJREVOVF9TVFJJQ1QpOwoJc3RyYnVmX2FkZGYoYnVmZmVyLCAiY29tbWl0dGVyICVzXG4iLCBjb21taXR0ZXIpOwoJaWYgKCFlbmNvZGluZ19pc191dGY4KQoJCXN0cmJ1Zl9hZGRmKGJ1ZmZlciwgImVuY29kaW5nICVzXG4iLCBnaXRfY29tbWl0X2VuY29kaW5nKTsKCgl3aGlsZSAoZXh0cmEpIHsKCQlhZGRfZXh0cmFfaGVhZGVyKGJ1ZmZlciwgZXh0cmEpOwoJCWV4dHJhID0gZXh0cmEtPm5leHQ7Cgl9CglzdHJidWZfYWRkY2goYnVmZmVyLCAnXG4nKTsKCgkvKiBBbmQgYWRkIHRoZSBjb21tZW50ICovCglzdHJidWZfYWRkKGJ1ZmZlciwgbXNnLCBtc2dfbGVuKTsKfQoKaW50IGNvbW1pdF90cmVlX2V4dGVuZGVkKGNvbnN0IGNoYXIgKm1zZywgc2l6ZV90IG1zZ19sZW4sCgkJCSBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICp0cmVlLAoJCQkgY29uc3Qgc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzLCBzdHJ1Y3Qgb2JqZWN0X2lkICpyZXQsCgkJCSBjb25zdCBjaGFyICphdXRob3IsIGNvbnN0IGNoYXIgKmNvbW1pdHRlciwKCQkJIGNvbnN0IGNoYXIgKnNpZ25fY29tbWl0LAoJCQkgY29uc3Qgc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKmV4dHJhKQp7CglzdHJ1Y3QgcmVwb3NpdG9yeSAqciA9IHRoZV9yZXBvc2l0b3J5OwoJaW50IHJlc3VsdCA9IDA7CglpbnQgZW5jb2RpbmdfaXNfdXRmODsKCXN0cnVjdCBzdHJidWYgYnVmZmVyID0gU1RSQlVGX0lOSVQsIGNvbXBhdF9idWZmZXIgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgc2lnID0gU1RSQlVGX0lOSVQsIGNvbXBhdF9zaWcgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBvYmplY3RfaWQgKnBhcmVudF9idWYgPSBOVUxMLCAqY29tcGF0X29pZCA9IE5VTEw7CglzdHJ1Y3Qgb2JqZWN0X2lkIGNvbXBhdF9vaWRfYnVmOwoJc2l6ZV90IGksIG5wYXJlbnRzOwoKCS8qIE5vdCBoYXZpbmcgaTE4bi5jb21taXRlbmNvZGluZyBpcyB0aGUgc2FtZSBhcyBoYXZpbmcgdXRmLTggKi8KCWVuY29kaW5nX2lzX3V0ZjggPSBpc19lbmNvZGluZ191dGY4KGdpdF9jb21taXRfZW5jb2RpbmcpOwoKCWFzc2VydF9vaWRfdHlwZSh0cmVlLCBPQkpfVFJFRSk7CgoJaWYgKG1lbWNocihtc2csICdcMCcsIG1zZ19sZW4pKQoJCXJldHVybiBlcnJvcigiYSBOVUwgYnl0ZSBpbiBjb21taXQgbG9nIG1lc3NhZ2Ugbm90IGFsbG93ZWQuIik7CgoJbnBhcmVudHMgPSBjb21taXRfbGlzdF9jb3VudChwYXJlbnRzKTsKCUNBTExPQ19BUlJBWShwYXJlbnRfYnVmLCBucGFyZW50cyk7CglpID0gMDsKCWZvciAoY29uc3Qgc3RydWN0IGNvbW1pdF9saXN0ICpwID0gcGFyZW50czsgcDsgcCA9IHAtPm5leHQpCgkJb2lkY3B5KCZwYXJlbnRfYnVmW2krK10sICZwLT5pdGVtLT5vYmplY3Qub2lkKTsKCgl3cml0ZV9jb21taXRfdHJlZSgmYnVmZmVyLCBtc2csIG1zZ19sZW4sIHRyZWUsIHBhcmVudF9idWYsIG5wYXJlbnRzLCBhdXRob3IsIGNvbW1pdHRlciwgZXh0cmEpOwoJaWYgKHNpZ25fY29tbWl0ICYmIHNpZ25fY29tbWl0X3RvX3N0cmJ1Zigmc2lnLCAmYnVmZmVyLCBzaWduX2NvbW1pdCkpIHsKCQlyZXN1bHQgPSAtMTsKCQlnb3RvIG91dDsKCX0KCWlmIChyLT5jb21wYXRfaGFzaF9hbGdvKSB7CgkJc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKmNvbXBhdF9leHRyYSA9IE5VTEw7CgkJc3RydWN0IG9iamVjdF9pZCBtYXBwZWRfdHJlZTsKCQlzdHJ1Y3Qgb2JqZWN0X2lkICptYXBwZWRfcGFyZW50czsKCgkJQ0FMTE9DX0FSUkFZKG1hcHBlZF9wYXJlbnRzLCBucGFyZW50cyk7CgoJCWlmIChyZXBvX29pZF90b19hbGdvcChyLCB0cmVlLCByLT5jb21wYXRfaGFzaF9hbGdvLCAmbWFwcGVkX3RyZWUpKSB7CgkJCXJlc3VsdCA9IC0xOwoJCQlmcmVlKG1hcHBlZF9wYXJlbnRzKTsKCQkJZ290byBvdXQ7CgkJfQoJCWZvciAoaSA9IDA7IGkgPCBucGFyZW50czsgaSsrKQoJCQlpZiAocmVwb19vaWRfdG9fYWxnb3AociwgJnBhcmVudF9idWZbaV0sIHItPmNvbXBhdF9oYXNoX2FsZ28sICZtYXBwZWRfcGFyZW50c1tpXSkpIHsKCQkJCXJlc3VsdCA9IC0xOwoJCQkJZnJlZShtYXBwZWRfcGFyZW50cyk7CgkJCQlnb3RvIG91dDsKCQkJfQoJCWlmIChjb252ZXJ0X2NvbW1pdF9leHRyYV9oZWFkZXJzKGV4dHJhLCAmY29tcGF0X2V4dHJhKSkgewoJCQlyZXN1bHQgPSAtMTsKCQkJZnJlZShtYXBwZWRfcGFyZW50cyk7CgkJCWdvdG8gb3V0OwoJCX0KCQl3cml0ZV9jb21taXRfdHJlZSgmY29tcGF0X2J1ZmZlciwgbXNnLCBtc2dfbGVuLCAmbWFwcGVkX3RyZWUsCgkJCQkgIG1hcHBlZF9wYXJlbnRzLCBucGFyZW50cywgYXV0aG9yLCBjb21taXR0ZXIsIGNvbXBhdF9leHRyYSk7CgkJZnJlZV9jb21taXRfZXh0cmFfaGVhZGVycyhjb21wYXRfZXh0cmEpOwoJCWZyZWUobWFwcGVkX3BhcmVudHMpOwoKCQlpZiAoc2lnbl9jb21taXQgJiYgc2lnbl9jb21taXRfdG9fc3RyYnVmKCZjb21wYXRfc2lnLCAmY29tcGF0X2J1ZmZlciwgc2lnbl9jb21taXQpKSB7CgkJCXJlc3VsdCA9IC0xOwoJCQlnb3RvIG91dDsKCQl9Cgl9CgoJaWYgKHNpZ25fY29tbWl0KSB7CgkJc3RydWN0IHNpZ19wYWlycyB7CgkJCXN0cnVjdCBzdHJidWYgKnNpZzsKCQkJY29uc3Qgc3RydWN0IGdpdF9oYXNoX2FsZ28gKmFsZ287CgkJfSBidWZzIFsyXSA9IHsKCQkJeyAmY29tcGF0X3NpZywgci0+Y29tcGF0X2hhc2hfYWxnbyB9LAoJCQl7ICZzaWcsIHItPmhhc2hfYWxnbyB9LAoJCX07CgoJCS8qCgkJICogV2Ugd3JpdGUgYWxnb3JpdGhtcyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIGltcGxlbWVudGVkIGluCgkJICogR2l0IHRvIHByb2R1Y2UgYSBzdGFibGUgaGFzaCB3aGVuIG11bHRpcGxlIGFsZ29yaXRobXMgYXJlCgkJICogdXNlZC4KCQkgKi8KCQlpZiAoci0+Y29tcGF0X2hhc2hfYWxnbyAmJiBoYXNoX2FsZ29fYnlfcHRyKGJ1ZnNbMF0uYWxnbykgPiBoYXNoX2FsZ29fYnlfcHRyKGJ1ZnNbMV0uYWxnbykpCgkJCVNXQVAoYnVmc1swXSwgYnVmc1sxXSk7CgoJCS8qCgkJICogV2UgdHJhdmVyc2UgZWFjaCBhbGdvcml0aG0gaW4gb3JkZXIsIGFuZCBhcHBseSB0aGUgc2lnbmF0dXJlCgkJICogdG8gZWFjaCBidWZmZXIuCgkJICovCgkJZm9yIChzaXplX3QgaSA9IDA7IGkgPCBBUlJBWV9TSVpFKGJ1ZnMpOyBpKyspIHsKCQkJaWYgKCFidWZzW2ldLmFsZ28pCgkJCQljb250aW51ZTsKCQkJYWRkX2hlYWRlcl9zaWduYXR1cmUoJmJ1ZmZlciwgYnVmc1tpXS5zaWcsIGJ1ZnNbaV0uYWxnbyk7CgkJCWlmIChyLT5jb21wYXRfaGFzaF9hbGdvKQoJCQkJYWRkX2hlYWRlcl9zaWduYXR1cmUoJmNvbXBhdF9idWZmZXIsIGJ1ZnNbaV0uc2lnLCBidWZzW2ldLmFsZ28pOwoJCX0KCX0KCgkvKiBBbmQgY2hlY2sgdGhlIGVuY29kaW5nLiAqLwoJaWYgKGVuY29kaW5nX2lzX3V0ZjggJiYgKCF2ZXJpZnlfdXRmOCgmYnVmZmVyKSB8fCAhdmVyaWZ5X3V0ZjgoJmNvbXBhdF9idWZmZXIpKSkKCQlmcHJpbnRmKHN0ZGVyciwgXyhjb21taXRfdXRmOF93YXJuKSk7CgoJaWYgKHItPmNvbXBhdF9oYXNoX2FsZ28pIHsKCQloYXNoX29iamVjdF9maWxlKHItPmNvbXBhdF9oYXNoX2FsZ28sIGNvbXBhdF9idWZmZXIuYnVmLCBjb21wYXRfYnVmZmVyLmxlbiwKCQkJT0JKX0NPTU1JVCwgJmNvbXBhdF9vaWRfYnVmKTsKCQljb21wYXRfb2lkID0gJmNvbXBhdF9vaWRfYnVmOwoJfQoKCXJlc3VsdCA9IHdyaXRlX29iamVjdF9maWxlX2ZsYWdzKGJ1ZmZlci5idWYsIGJ1ZmZlci5sZW4sIE9CSl9DT01NSVQsCgkJCQkJIHJldCwgY29tcGF0X29pZCwgMCk7Cm91dDoKCWZyZWUocGFyZW50X2J1Zik7CglzdHJidWZfcmVsZWFzZSgmYnVmZmVyKTsKCXN0cmJ1Zl9yZWxlYXNlKCZjb21wYXRfYnVmZmVyKTsKCXN0cmJ1Zl9yZWxlYXNlKCZzaWcpOwoJc3RyYnVmX3JlbGVhc2UoJmNvbXBhdF9zaWcpOwoJcmV0dXJuIHJlc3VsdDsKfQoKZGVmaW5lX2NvbW1pdF9zbGFiKG1lcmdlX2Rlc2Nfc2xhYiwgc3RydWN0IG1lcmdlX3JlbW90ZV9kZXNjICopOwpzdGF0aWMgc3RydWN0IG1lcmdlX2Rlc2Nfc2xhYiBtZXJnZV9kZXNjX3NsYWIgPSBDT01NSVRfU0xBQl9JTklUKDEsIG1lcmdlX2Rlc2Nfc2xhYik7CgpzdHJ1Y3QgbWVyZ2VfcmVtb3RlX2Rlc2MgKm1lcmdlX3JlbW90ZV91dGlsKGNvbnN0IHN0cnVjdCBjb21taXQgKmNvbW1pdCkKewoJcmV0dXJuICptZXJnZV9kZXNjX3NsYWJfYXQoJm1lcmdlX2Rlc2Nfc2xhYiwgY29tbWl0KTsKfQoKdm9pZCBzZXRfbWVyZ2VfcmVtb3RlX2Rlc2Moc3RydWN0IGNvbW1pdCAqY29tbWl0LAoJCQkgICBjb25zdCBjaGFyICpuYW1lLCBzdHJ1Y3Qgb2JqZWN0ICpvYmopCnsKCXN0cnVjdCBtZXJnZV9yZW1vdGVfZGVzYyAqZGVzYzsKCUZMRVhfQUxMT0NfU1RSKGRlc2MsIG5hbWUsIG5hbWUpOwoJZGVzYy0+b2JqID0gb2JqOwoJKm1lcmdlX2Rlc2Nfc2xhYl9hdCgmbWVyZ2VfZGVzY19zbGFiLCBjb21taXQpID0gZGVzYzsKfQoKc3RydWN0IGNvbW1pdCAqZ2V0X21lcmdlX3BhcmVudChjb25zdCBjaGFyICpuYW1lKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmo7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCWlmIChyZXBvX2dldF9vaWQodGhlX3JlcG9zaXRvcnksIG5hbWUsICZvaWQpKQoJCXJldHVybiBOVUxMOwoJb2JqID0gcGFyc2Vfb2JqZWN0KHRoZV9yZXBvc2l0b3J5LCAmb2lkKTsKCWNvbW1pdCA9IChzdHJ1Y3QgY29tbWl0ICopcmVwb19wZWVsX3RvX3R5cGUodGhlX3JlcG9zaXRvcnksIG5hbWUsIDAsCgkJCQkJCSAgICBvYmosIE9CSl9DT01NSVQpOwoJaWYgKGNvbW1pdCAmJiAhbWVyZ2VfcmVtb3RlX3V0aWwoY29tbWl0KSkKCQlzZXRfbWVyZ2VfcmVtb3RlX2Rlc2MoY29tbWl0LCBuYW1lLCBvYmopOwoJcmV0dXJuIGNvbW1pdDsKfQoKLyoKICogQXBwZW5kIGEgY29tbWl0IHRvIHRoZSBlbmQgb2YgdGhlIGNvbW1pdF9saXN0LgogKgogKiBuZXh0IHN0YXJ0cyBieSBwb2ludGluZyB0byB0aGUgdmFyaWFibGUgdGhhdCBob2xkcyB0aGUgaGVhZCBvZiBhbgogKiBlbXB0eSBjb21taXRfbGlzdCwgYW5kIGlzIHVwZGF0ZWQgdG8gcG9pbnQgdG8gdGhlICJuZXh0IiBmaWVsZCBvZgogKiB0aGUgbGFzdCBpdGVtIG9uIHRoZSBsaXN0IGFzIG5ldyBjb21taXRzIGFyZSBhcHBlbmRlZC4KICoKICogVXNhZ2UgZXhhbXBsZToKICoKICogICAgIHN0cnVjdCBjb21taXRfbGlzdCAqbGlzdDsKICogICAgIHN0cnVjdCBjb21taXRfbGlzdCAqKm5leHQgPSAmbGlzdDsKICoKICogICAgIG5leHQgPSBjb21taXRfbGlzdF9hcHBlbmQoYzEsIG5leHQpOwogKiAgICAgbmV4dCA9IGNvbW1pdF9saXN0X2FwcGVuZChjMiwgbmV4dCk7CiAqICAgICBhc3NlcnQoY29tbWl0X2xpc3RfY291bnQobGlzdCkgPT0gMik7CiAqICAgICByZXR1cm4gbGlzdDsKICovCnN0cnVjdCBjb21taXRfbGlzdCAqKmNvbW1pdF9saXN0X2FwcGVuZChzdHJ1Y3QgY29tbWl0ICpjb21taXQsCgkJCQkJc3RydWN0IGNvbW1pdF9saXN0ICoqbmV4dCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpuZXdfY29tbWl0ID0geG1hbGxvYyhzaXplb2Yoc3RydWN0IGNvbW1pdF9saXN0KSk7CgluZXdfY29tbWl0LT5pdGVtID0gY29tbWl0OwoJKm5leHQgPSBuZXdfY29tbWl0OwoJbmV3X2NvbW1pdC0+bmV4dCA9IE5VTEw7CglyZXR1cm4gJm5ld19jb21taXQtPm5leHQ7Cn0KCmNvbnN0IGNoYXIgKmZpbmRfY29tbWl0X2hlYWRlcihjb25zdCBjaGFyICptc2csIGNvbnN0IGNoYXIgKmtleSwgc2l6ZV90ICpvdXRfbGVuKQp7CglpbnQga2V5X2xlbiA9IHN0cmxlbihrZXkpOwoJY29uc3QgY2hhciAqbGluZSA9IG1zZzsKCgl3aGlsZSAobGluZSkgewoJCWNvbnN0IGNoYXIgKmVvbCA9IHN0cmNocm51bChsaW5lLCAnXG4nKTsKCgkJaWYgKGxpbmUgPT0gZW9sKQoJCQlyZXR1cm4gTlVMTDsKCgkJaWYgKGVvbCAtIGxpbmUgPiBrZXlfbGVuICYmCgkJICAgICFzdHJuY21wKGxpbmUsIGtleSwga2V5X2xlbikgJiYKCQkgICAgbGluZVtrZXlfbGVuXSA9PSAnICcpIHsKCQkJKm91dF9sZW4gPSBlb2wgLSBsaW5lIC0ga2V5X2xlbiAtIDE7CgkJCXJldHVybiBsaW5lICsga2V5X2xlbiArIDE7CgkJfQoJCWxpbmUgPSAqZW9sID8gZW9sICsgMSA6IE5VTEw7Cgl9CglyZXR1cm4gTlVMTDsKfQoKLyoKICogSW5zcGVjdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCBkZXRlcm1pbmUgdGhlIHRydWUgImVuZCIgb2YgdGhlIGxvZyBtZXNzYWdlLCBpbgogKiBvcmRlciB0byBmaW5kIHdoZXJlIHRvIHB1dCBhIG5ldyBTaWduZWQtb2ZmLWJ5IHRyYWlsZXIuICBJZ25vcmVkIGFyZQogKiB0cmFpbGluZyBjb21tZW50IGxpbmVzIGFuZCBibGFuayBsaW5lcy4gIFRvIHN1cHBvcnQgImdpdCBjb21taXQgLXMKICogLS1hbWVuZCIgb24gYW4gZXhpc3RpbmcgY29tbWl0LCB3ZSBhbHNvIGlnbm9yZSAiQ29uZmxpY3RzOiIuICBUbwogKiBzdXBwb3J0ICJnaXQgY29tbWl0IC12Iiwgd2UgdHJ1bmNhdGUgYXQgY3V0IGxpbmVzLgogKgogKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgZnJvbSB0aGUgdGFpbCB0byBpZ25vcmUsIHRvIGJlIGZlZCBhcwogKiB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBhcHBlbmRfc2lnbm9mZigpLgogKi8Kc2l6ZV90IGlnbm9yZWRfbG9nX21lc3NhZ2VfYnl0ZXMoY29uc3QgY2hhciAqYnVmLCBzaXplX3QgbGVuKQp7CglzaXplX3QgYm9jID0gMDsKCXNpemVfdCBib2wgPSAwOwoJaW50IGluX29sZF9jb25mbGljdHNfYmxvY2sgPSAwOwoJc2l6ZV90IGN1dG9mZiA9IHd0X3N0YXR1c19sb2NhdGVfZW5kKGJ1ZiwgbGVuKTsKCgl3aGlsZSAoYm9sIDwgY3V0b2ZmKSB7CgkJY29uc3QgY2hhciAqbmV4dF9saW5lID0gbWVtY2hyKGJ1ZiArIGJvbCwgJ1xuJywgbGVuIC0gYm9sKTsKCgkJaWYgKCFuZXh0X2xpbmUpCgkJCW5leHRfbGluZSA9IGJ1ZiArIGxlbjsKCQllbHNlCgkJCW5leHRfbGluZSsrOwoKCQlpZiAoc3RhcnRzX3dpdGhfbWVtKGJ1ZiArIGJvbCwgY3V0b2ZmIC0gYm9sLCBjb21tZW50X2xpbmVfc3RyKSB8fAoJCSAgICBidWZbYm9sXSA9PSAnXG4nKSB7CgkJCS8qIGlzIHRoaXMgdGhlIGZpcnN0IG9mIHRoZSBydW4gb2YgY29tbWVudHM/ICovCgkJCWlmICghYm9jKQoJCQkJYm9jID0gYm9sOwoJCQkvKiBvdGhlcndpc2UsIGl0IGlzIGp1c3QgY29udGludWluZyAqLwoJCX0gZWxzZSBpZiAoc3RhcnRzX3dpdGgoYnVmICsgYm9sLCAiQ29uZmxpY3RzOlxuIikpIHsKCQkJaW5fb2xkX2NvbmZsaWN0c19ibG9jayA9IDE7CgkJCWlmICghYm9jKQoJCQkJYm9jID0gYm9sOwoJCX0gZWxzZSBpZiAoaW5fb2xkX2NvbmZsaWN0c19ibG9jayAmJiBidWZbYm9sXSA9PSAnXHQnKSB7CgkJCTsgLyogYSBwYXRobmFtZSBpbiB0aGUgY29uZmxpY3RzIGJsb2NrICovCgkJfSBlbHNlIGlmIChib2MpIHsKCQkJLyogdGhlIHByZXZpb3VzIHdhcyBub3QgdHJhaWxpbmcgY29tbWVudCAqLwoJCQlib2MgPSAwOwoJCQlpbl9vbGRfY29uZmxpY3RzX2Jsb2NrID0gMDsKCQl9CgkJYm9sID0gbmV4dF9saW5lIC0gYnVmOwoJfQoJcmV0dXJuIGJvYyA/IGxlbiAtIGJvYyA6IGxlbiAtIGN1dG9mZjsKfQoKaW50IHJ1bl9jb21taXRfaG9vayhpbnQgZWRpdG9yX2lzX3VzZWQsIGNvbnN0IGNoYXIgKmluZGV4X2ZpbGUsCgkJICAgIGludCAqaW52b2tlZF9ob29rLCBjb25zdCBjaGFyICpuYW1lLCAuLi4pCnsKCXN0cnVjdCBydW5faG9va3Nfb3B0IG9wdCA9IFJVTl9IT09LU19PUFRfSU5JVDsKCXZhX2xpc3QgYXJnczsKCWNvbnN0IGNoYXIgKmFyZzsKCglzdHJ2ZWNfcHVzaGYoJm9wdC5lbnYsICJHSVRfSU5ERVhfRklMRT0lcyIsIGluZGV4X2ZpbGUpOwoKCS8qCgkgKiBMZXQgdGhlIGhvb2sga25vdyB0aGF0IG5vIGVkaXRvciB3aWxsIGJlIGxhdW5jaGVkLgoJICovCglpZiAoIWVkaXRvcl9pc191c2VkKQoJCXN0cnZlY19wdXNoKCZvcHQuZW52LCAiR0lUX0VESVRPUj06Iik7CgoJdmFfc3RhcnQoYXJncywgbmFtZSk7Cgl3aGlsZSAoKGFyZyA9IHZhX2FyZyhhcmdzLCBjb25zdCBjaGFyICopKSkKCQlzdHJ2ZWNfcHVzaCgmb3B0LmFyZ3MsIGFyZyk7Cgl2YV9lbmQoYXJncyk7CgoJb3B0Lmludm9rZWRfaG9vayA9IGludm9rZWRfaG9vazsKCXJldHVybiBydW5faG9va3Nfb3B0KHRoZV9yZXBvc2l0b3J5LCBuYW1lLCAmb3B0KTsKfQo=",
    "text": "#define USE_THE_REPOSITORY_VARIABLE\n\n#include \"git-compat-util.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"commit-graph.h\"\n#include \"environment.h\"\n#include \"gettext.h\"\n#include \"hex.h\"\n#include \"repository.h\"\n#include \"object-name.h\"\n#include \"object-store.h\"\n#include \"utf8.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"notes.h\"\n#include \"alloc.h\"\n#include \"gpg-interface.h\"\n#include \"mergesort.h\"\n#include \"commit-slab.h\"\n#include \"prio-queue.h\"\n#include \"hash-lookup.h\"\n#include \"wt-status.h\"\n#include \"advice.h\"\n#include \"refs.h\"\n#include \"commit-reach.h\"\n#include \"setup.h\"\n#include \"shallow.h\"\n#include \"tree.h\"\n#include \"hook.h\"\n#include \"parse.h\"\n#include \"object-file.h\"\n#include \"object-file-convert.h\"\n\nstatic struct commit_extra_header *read_commit_extra_header_lines(const char *buf, size_t len, const char **);\n\nint save_commit_buffer = 1;\nint no_graft_file_deprecated_advice;\n\nconst char *commit_type = \"commit\";\n\nstruct commit *lookup_commit_reference_gently(struct repository *r,\n\t\tconst struct object_id *oid, int quiet)\n{\n\tstruct object *obj = deref_tag(r,\n\t\t\t\t       parse_object(r, oid),\n\t\t\t\t       NULL, 0);\n\n\tif (!obj)\n\t\treturn NULL;\n\treturn object_as_type(obj, OBJ_COMMIT, quiet);\n}\n\nstruct commit *lookup_commit_reference(struct repository *r, const struct object_id *oid)\n{\n\treturn lookup_commit_reference_gently(r, oid, 0);\n}\n\nstruct commit *lookup_commit_or_die(const struct object_id *oid, const char *ref_name)\n{\n\tstruct commit *c = lookup_commit_reference(the_repository, oid);\n\tif (!c)\n\t\tdie(_(\"could not parse %s\"), ref_name);\n\tif (!oideq(oid, &c->object.oid)) {\n\t\twarning(_(\"%s %s is not a commit!\"),\n\t\t\tref_name, oid_to_hex(oid));\n\t}\n\treturn c;\n}\n\nstruct commit *lookup_commit_object(struct repository *r,\n\t\t\t\t    const struct object_id *oid)\n{\n\tstruct object *obj = parse_object(r, oid);\n\treturn obj ? object_as_type(obj, OBJ_COMMIT, 0) : NULL;\n\n}\n\nstruct commit *lookup_commit(struct repository *r, const struct object_id *oid)\n{\n\tstruct object *obj = lookup_object(r, oid);\n\tif (!obj)\n\t\treturn create_object(r, oid, alloc_commit_node(r));\n\treturn object_as_type(obj, OBJ_COMMIT, 0);\n}\n\nstruct commit *lookup_commit_reference_by_name(const char *name)\n{\n\treturn lookup_commit_reference_by_name_gently(name, 0);\n}\n\nstruct commit *lookup_commit_reference_by_name_gently(const char *name,\n\t\t\t\t\t\t      int quiet)\n{\n\tstruct object_id oid;\n\tstruct commit *commit;\n\n\tif (repo_get_oid_committish(the_repository, name, &oid))\n\t\treturn NULL;\n\tcommit = lookup_commit_reference_gently(the_repository, &oid, quiet);\n\tif (repo_parse_commit(the_repository, commit))\n\t\treturn NULL;\n\treturn commit;\n}\n\nstatic timestamp_t parse_commit_date(const char *buf, const char *tail)\n{\n\tconst char *dateptr;\n\tconst char *eol;\n\n\tif (buf + 6 >= tail)\n\t\treturn 0;\n\tif (memcmp(buf, \"author\", 6))\n\t\treturn 0;\n\twhile (buf < tail && *buf++ != '\\n')\n\t\t/* nada */;\n\tif (buf + 9 >= tail)\n\t\treturn 0;\n\tif (memcmp(buf, \"committer\", 9))\n\t\treturn 0;\n\n\t/*\n\t * Jump to end-of-line so that we can walk backwards to find the\n\t * end-of-email \">\". This is more forgiving of malformed cases\n\t * because unexpected characters tend to be in the name and email\n\t * fields.\n\t */\n\teol = memchr(buf, '\\n', tail - buf);\n\tif (!eol)\n\t\treturn 0;\n\tdateptr = eol;\n\twhile (dateptr > buf && dateptr[-1] != '>')\n\t\tdateptr--;\n\tif (dateptr == buf)\n\t\treturn 0;\n\n\t/*\n\t * Trim leading whitespace, but make sure we have at least one\n\t * non-whitespace character, as parse_timestamp() will otherwise walk\n\t * right past the newline we found in \"eol\" when skipping whitespace\n\t * itself.\n\t *\n\t * In theory it would be sufficient to allow any character not matched\n\t * by isspace(), but there's a catch: our isspace() does not\n\t * necessarily match the behavior of parse_timestamp(), as the latter\n\t * is implemented by system routines which match more exotic control\n\t * codes, or even locale-dependent sequences.\n\t *\n\t * Since we expect the timestamp to be a number, we can check for that.\n\t * Anything else (e.g., a non-numeric token like \"foo\") would just\n\t * cause parse_timestamp() to return 0 anyway.\n\t */\n\twhile (dateptr < eol && isspace(*dateptr))\n\t\tdateptr++;\n\tif (!isdigit(*dateptr) && *dateptr != '-')\n\t\treturn 0;\n\n\t/*\n\t * We know there is at least one digit (or dash), so we'll begin\n\t * parsing there and stop at worst case at eol.\n\t *\n\t * Note that we may feed parse_timestamp() extra characters here if the\n\t * commit is malformed, and it will parse as far as it can. For\n\t * example, \"123foo456\" would return \"123\". That might be questionable\n\t * (versus returning \"0\"), but it would help in a hypothetical case\n\t * like \"123456+0100\", where the whitespace from the timezone is\n\t * missing. Since such syntactic errors may be baked into history and\n\t * hard to correct now, let's err on trying to make our best guess\n\t * here, rather than insist on perfect syntax.\n\t */\n\treturn parse_timestamp(dateptr, NULL, 10);\n}\n\nstatic const struct object_id *commit_graft_oid_access(size_t index, const void *table)\n{\n\tconst struct commit_graft * const *commit_graft_table = table;\n\treturn &commit_graft_table[index]->oid;\n}\n\nint commit_graft_pos(struct repository *r, const struct object_id *oid)\n{\n\treturn oid_pos(oid, r->parsed_objects->grafts,\n\t\t       r->parsed_objects->grafts_nr,\n\t\t       commit_graft_oid_access);\n}\n\nvoid unparse_commit(struct repository *r, const struct object_id *oid)\n{\n\tstruct commit *c = lookup_commit(r, oid);\n\n\tif (!c->object.parsed)\n\t\treturn;\n\tfree_commit_list(c->parents);\n\tc->parents = NULL;\n\tc->object.parsed = 0;\n}\n\nint register_commit_graft(struct repository *r, struct commit_graft *graft,\n\t\t\t  int ignore_dups)\n{\n\tint pos = commit_graft_pos(r, &graft->oid);\n\n\tif (0 <= pos) {\n\t\tif (ignore_dups)\n\t\t\tfree(graft);\n\t\telse {\n\t\t\tfree(r->parsed_objects->grafts[pos]);\n\t\t\tr->parsed_objects->grafts[pos] = graft;\n\t\t}\n\t\treturn 1;\n\t}\n\tpos = -pos - 1;\n\tALLOC_GROW(r->parsed_objects->grafts,\n\t\t   r->parsed_objects->grafts_nr + 1,\n\t\t   r->parsed_objects->grafts_alloc);\n\tr->parsed_objects->grafts_nr++;\n\tif (pos < r->parsed_objects->grafts_nr)\n\t\tmemmove(r->parsed_objects->grafts + pos + 1,\n\t\t\tr->parsed_objects->grafts + pos,\n\t\t\t(r->parsed_objects->grafts_nr - pos - 1) *\n\t\t\tsizeof(*r->parsed_objects->grafts));\n\tr->parsed_objects->grafts[pos] = graft;\n\tunparse_commit(r, &graft->oid);\n\treturn 0;\n}\n\nstruct commit_graft *read_graft_line(struct strbuf *line)\n{\n\t/* The format is just \"Commit Parent1 Parent2 ...\\n\" */\n\tint i, phase;\n\tconst char *tail = NULL;\n\tstruct commit_graft *graft = NULL;\n\tstruct object_id dummy_oid, *oid;\n\n\tstrbuf_rtrim(line);\n\tif (!line->len || line->buf[0] == '#')\n\t\treturn NULL;\n\t/*\n\t * phase 0 verifies line, counts hashes in line and allocates graft\n\t * phase 1 fills graft\n\t */\n\tfor (phase = 0; phase < 2; phase++) {\n\t\toid = graft ? &graft->oid : &dummy_oid;\n\t\tif (parse_oid_hex(line->buf, oid, &tail))\n\t\t\tgoto bad_graft_data;\n\t\tfor (i = 0; *tail != '\\0'; i++) {\n\t\t\toid = graft ? &graft->parent[i] : &dummy_oid;\n\t\t\tif (!isspace(*tail++) || parse_oid_hex(tail, oid, &tail))\n\t\t\t\tgoto bad_graft_data;\n\t\t}\n\t\tif (!graft) {\n\t\t\tgraft = xmalloc(st_add(sizeof(*graft),\n\t\t\t\t\t       st_mult(sizeof(struct object_id), i)));\n\t\t\tgraft->nr_parent = i;\n\t\t}\n\t}\n\treturn graft;\n\nbad_graft_data:\n\terror(\"bad graft data: %s\", line->buf);\n\tassert(!graft);\n\treturn NULL;\n}\n\nstatic int read_graft_file(struct repository *r, const char *graft_file)\n{\n\tFILE *fp = fopen_or_warn(graft_file, \"r\");\n\tstruct strbuf buf = STRBUF_INIT;\n\tif (!fp)\n\t\treturn -1;\n\tif (!no_graft_file_deprecated_advice &&\n\t    advice_enabled(ADVICE_GRAFT_FILE_DEPRECATED))\n\t\tadvise(_(\"Support for <GIT_DIR>/info/grafts is deprecated\\n\"\n\t\t\t \"and will be removed in a future Git version.\\n\"\n\t\t\t \"\\n\"\n\t\t\t \"Please use \\\"git replace --convert-graft-file\\\"\\n\"\n\t\t\t \"to convert the grafts into replace refs.\\n\"\n\t\t\t \"\\n\"\n\t\t\t \"Turn this message off by running\\n\"\n\t\t\t \"\\\"git config set advice.graftFileDeprecated false\\\"\"));\n\twhile (!strbuf_getwholeline(&buf, fp, '\\n')) {\n\t\t/* The format is just \"Commit Parent1 Parent2 ...\\n\" */\n\t\tstruct commit_graft *graft = read_graft_line(&buf);\n\t\tif (!graft)\n\t\t\tcontinue;\n\t\tif (register_commit_graft(r, graft, 1))\n\t\t\terror(\"duplicate graft data: %s\", buf.buf);\n\t}\n\tfclose(fp);\n\tstrbuf_release(&buf);\n\treturn 0;\n}\n\nvoid prepare_commit_graft(struct repository *r)\n{\n\tconst char *graft_file;\n\n\tif (r->parsed_objects->commit_graft_prepared)\n\t\treturn;\n\tif (!startup_info->have_repository)\n\t\treturn;\n\n\tgraft_file = repo_get_graft_file(r);\n\tread_graft_file(r, graft_file);\n\t/* make sure shallows are read */\n\tis_repository_shallow(r);\n\tr->parsed_objects->commit_graft_prepared = 1;\n}\n\nstruct commit_graft *lookup_commit_graft(struct repository *r, const struct object_id *oid)\n{\n\tint pos;\n\tprepare_commit_graft(r);\n\tpos = commit_graft_pos(r, oid);\n\tif (pos < 0)\n\t\treturn NULL;\n\treturn r->parsed_objects->grafts[pos];\n}\n\nint for_each_commit_graft(each_commit_graft_fn fn, void *cb_data)\n{\n\tint i, ret;\n\tfor (i = ret = 0; i < the_repository->parsed_objects->grafts_nr && !ret; i++)\n\t\tret = fn(the_repository->parsed_objects->grafts[i], cb_data);\n\treturn ret;\n}\n\nstruct commit_buffer {\n\tvoid *buffer;\n\tunsigned long size;\n};\ndefine_commit_slab(buffer_slab, struct commit_buffer);\n\nstruct buffer_slab *allocate_commit_buffer_slab(void)\n{\n\tstruct buffer_slab *bs = xmalloc(sizeof(*bs));\n\tinit_buffer_slab(bs);\n\treturn bs;\n}\n\nvoid free_commit_buffer_slab(struct buffer_slab *bs)\n{\n\tclear_buffer_slab(bs);\n\tfree(bs);\n}\n\nvoid set_commit_buffer(struct repository *r, struct commit *commit, void *buffer, unsigned long size)\n{\n\tstruct commit_buffer *v = buffer_slab_at(\n\t\tr->parsed_objects->buffer_slab, commit);\n\tv->buffer = buffer;\n\tv->size = size;\n}\n\nconst void *get_cached_commit_buffer(struct repository *r, const struct commit *commit, unsigned long *sizep)\n{\n\tstruct commit_buffer *v = buffer_slab_peek(\n\t\tr->parsed_objects->buffer_slab, commit);\n\tif (!v) {\n\t\tif (sizep)\n\t\t\t*sizep = 0;\n\t\treturn NULL;\n\t}\n\tif (sizep)\n\t\t*sizep = v->size;\n\treturn v->buffer;\n}\n\nconst void *repo_get_commit_buffer(struct repository *r,\n\t\t\t\t   const struct commit *commit,\n\t\t\t\t   unsigned long *sizep)\n{\n\tconst void *ret = get_cached_commit_buffer(r, commit, sizep);\n\tif (!ret) {\n\t\tenum object_type type;\n\t\tunsigned long size;\n\t\tret = repo_read_object_file(r, &commit->object.oid, &type, &size);\n\t\tif (!ret)\n\t\t\tdie(\"cannot read commit object %s\",\n\t\t\t    oid_to_hex(&commit->object.oid));\n\t\tif (type != OBJ_COMMIT)\n\t\t\tdie(\"expected commit for %s, got %s\",\n\t\t\t    oid_to_hex(&commit->object.oid), type_name(type));\n\t\tif (sizep)\n\t\t\t*sizep = size;\n\t}\n\treturn ret;\n}\n\nvoid repo_unuse_commit_buffer(struct repository *r,\n\t\t\t      const struct commit *commit,\n\t\t\t      const void *buffer)\n{\n\tstruct commit_buffer *v = buffer_slab_peek(\n\t\tr->parsed_objects->buffer_slab, commit);\n\tif (!(v && v->buffer == buffer))\n\t\tfree((void *)buffer);\n}\n\nvoid free_commit_buffer(struct parsed_object_pool *pool, struct commit *commit)\n{\n\tstruct commit_buffer *v = buffer_slab_peek(\n\t\tpool->buffer_slab, commit);\n\tif (v) {\n\t\tFREE_AND_NULL(v->buffer);\n\t\tv->size = 0;\n\t}\n}\n\nstatic inline void set_commit_tree(struct commit *c, struct tree *t)\n{\n\tc->maybe_tree = t;\n}\n\nstruct tree *repo_get_commit_tree(struct repository *r,\n\t\t\t\t  const struct commit *commit)\n{\n\tif (commit->maybe_tree || !commit->object.parsed)\n\t\treturn commit->maybe_tree;\n\n\tif (commit_graph_position(commit) != COMMIT_NOT_FROM_GRAPH)\n\t\treturn get_commit_tree_in_graph(r, commit);\n\n\treturn NULL;\n}\n\nstruct object_id *get_commit_tree_oid(const struct commit *commit)\n{\n\tstruct tree *tree = repo_get_commit_tree(the_repository, commit);\n\treturn tree ? &tree->object.oid : NULL;\n}\n\nvoid release_commit_memory(struct parsed_object_pool *pool, struct commit *c)\n{\n\tset_commit_tree(c, NULL);\n\tfree_commit_buffer(pool, c);\n\tc->index = 0;\n\tfree_commit_list(c->parents);\n\n\tc->object.parsed = 0;\n}\n\nconst void *detach_commit_buffer(struct commit *commit, unsigned long *sizep)\n{\n\tstruct commit_buffer *v = buffer_slab_peek(\n\t\tthe_repository->parsed_objects->buffer_slab, commit);\n\tvoid *ret;\n\n\tif (!v) {\n\t\tif (sizep)\n\t\t\t*sizep = 0;\n\t\treturn NULL;\n\t}\n\tret = v->buffer;\n\tif (sizep)\n\t\t*sizep = v->size;\n\n\tv->buffer = NULL;\n\tv->size = 0;\n\treturn ret;\n}\n\nint parse_commit_buffer(struct repository *r, struct commit *item, const void *buffer, unsigned long size, int check_graph)\n{\n\tconst char *tail = buffer;\n\tconst char *bufptr = buffer;\n\tstruct object_id parent;\n\tstruct commit_list **pptr;\n\tstruct commit_graft *graft;\n\tconst int tree_entry_len = the_hash_algo->hexsz + 5;\n\tconst int parent_entry_len = the_hash_algo->hexsz + 7;\n\tstruct tree *tree;\n\n\tif (item->object.parsed)\n\t\treturn 0;\n\t/*\n\t * Presumably this is leftover from an earlier failed parse;\n\t * clear it out in preparation for us re-parsing (we'll hit the\n\t * same error, but that's good, since it lets our caller know\n\t * the result cannot be trusted.\n\t */\n\tfree_commit_list(item->parents);\n\titem->parents = NULL;\n\n\ttail += size;\n\tif (tail <= bufptr + tree_entry_len + 1 || memcmp(bufptr, \"tree \", 5) ||\n\t\t\tbufptr[tree_entry_len] != '\\n')\n\t\treturn error(\"bogus commit object %s\", oid_to_hex(&item->object.oid));\n\tif (get_oid_hex(bufptr + 5, &parent) < 0)\n\t\treturn error(\"bad tree pointer in commit %s\",\n\t\t\t     oid_to_hex(&item->object.oid));\n\ttree = lookup_tree(r, &parent);\n\tif (!tree)\n\t\treturn error(\"bad tree pointer %s in commit %s\",\n\t\t\t     oid_to_hex(&parent),\n\t\t\t     oid_to_hex(&item->object.oid));\n\tset_commit_tree(item, tree);\n\tbufptr += tree_entry_len + 1; /* \"tree \" + \"hex sha1\" + \"\\n\" */\n\tpptr = &item->parents;\n\n\tgraft = lookup_commit_graft(r, &item->object.oid);\n\tif (graft)\n\t\tr->parsed_objects->substituted_parent = 1;\n\twhile (bufptr + parent_entry_len < tail && !memcmp(bufptr, \"parent \", 7)) {\n\t\tstruct commit *new_parent;\n\n\t\tif (tail <= bufptr + parent_entry_len + 1 ||\n\t\t    get_oid_hex(bufptr + 7, &parent) ||\n\t\t    bufptr[parent_entry_len] != '\\n')\n\t\t\treturn error(\"bad parents in commit %s\", oid_to_hex(&item->object.oid));\n\t\tbufptr += parent_entry_len + 1;\n\t\t/*\n\t\t * The clone is shallow if nr_parent < 0, and we must\n\t\t * not traverse its real parents even when we unhide them.\n\t\t */\n\t\tif (graft && (graft->nr_parent < 0 || !grafts_keep_true_parents))\n\t\t\tcontinue;\n\t\tnew_parent = lookup_commit(r, &parent);\n\t\tif (!new_parent)\n\t\t\treturn error(\"bad parent %s in commit %s\",\n\t\t\t\t     oid_to_hex(&parent),\n\t\t\t\t     oid_to_hex(&item->object.oid));\n\t\tpptr = &commit_list_insert(new_parent, pptr)->next;\n\t}\n\tif (graft) {\n\t\tint i;\n\t\tstruct commit *new_parent;\n\t\tfor (i = 0; i < graft->nr_parent; i++) {\n\t\t\tnew_parent = lookup_commit(r,\n\t\t\t\t\t\t   &graft->parent[i]);\n\t\t\tif (!new_parent)\n\t\t\t\treturn error(\"bad graft parent %s in commit %s\",\n\t\t\t\t\t     oid_to_hex(&graft->parent[i]),\n\t\t\t\t\t     oid_to_hex(&item->object.oid));\n\t\t\tpptr = &commit_list_insert(new_parent, pptr)->next;\n\t\t}\n\t}\n\titem->date = parse_commit_date(bufptr, tail);\n\n\tif (check_graph)\n\t\tload_commit_graph_info(r, item);\n\n\titem->object.parsed = 1;\n\treturn 0;\n}\n\nint repo_parse_commit_internal(struct repository *r,\n\t\t\t       struct commit *item,\n\t\t\t       int quiet_on_missing,\n\t\t\t       int use_commit_graph)\n{\n\tenum object_type type;\n\tvoid *buffer;\n\tunsigned long size;\n\tstruct object_info oi = {\n\t\t.typep = &type,\n\t\t.sizep = &size,\n\t\t.contentp = &buffer,\n\t};\n\t/*\n\t * Git does not support partial clones that exclude commits, so set\n\t * OBJECT_INFO_SKIP_FETCH_OBJECT to fail fast when an object is missing.\n\t */\n\tint flags = OBJECT_INFO_LOOKUP_REPLACE | OBJECT_INFO_SKIP_FETCH_OBJECT |\n\t\tOBJECT_INFO_DIE_IF_CORRUPT;\n\tint ret;\n\n\tif (!item)\n\t\treturn -1;\n\tif (item->object.parsed)\n\t\treturn 0;\n\tif (use_commit_graph && parse_commit_in_graph(r, item)) {\n\t\tstatic int commit_graph_paranoia = -1;\n\n\t\tif (commit_graph_paranoia == -1)\n\t\t\tcommit_graph_paranoia = git_env_bool(GIT_COMMIT_GRAPH_PARANOIA, 0);\n\n\t\tif (commit_graph_paranoia && !has_object(r, &item->object.oid, 0)) {\n\t\t\tunparse_commit(r, &item->object.oid);\n\t\t\treturn quiet_on_missing ? -1 :\n\t\t\t\terror(_(\"commit %s exists in commit-graph but not in the object database\"),\n\t\t\t\t      oid_to_hex(&item->object.oid));\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (oid_object_info_extended(r, &item->object.oid, &oi, flags) < 0)\n\t\treturn quiet_on_missing ? -1 :\n\t\t\terror(\"Could not read %s\",\n\t\t\t     oid_to_hex(&item->object.oid));\n\tif (type != OBJ_COMMIT) {\n\t\tfree(buffer);\n\t\treturn error(\"Object %s not a commit\",\n\t\t\t     oid_to_hex(&item->object.oid));\n\t}\n\n\tret = parse_commit_buffer(r, item, buffer, size, 0);\n\tif (save_commit_buffer && !ret &&\n\t    !get_cached_commit_buffer(r, item, NULL)) {\n\t\tset_commit_buffer(r, item, buffer, size);\n\t\treturn 0;\n\t}\n\tfree(buffer);\n\treturn ret;\n}\n\nint repo_parse_commit_gently(struct repository *r,\n\t\t\t     struct commit *item, int quiet_on_missing)\n{\n\treturn repo_parse_commit_internal(r, item, quiet_on_missing, 1);\n}\n\nvoid parse_commit_or_die(struct commit *item)\n{\n\tif (repo_parse_commit(the_repository, item))\n\t\tdie(\"unable to parse commit %s\",\n\t\t    item ? oid_to_hex(&item->object.oid) : \"(null)\");\n}\n\nint find_commit_subject(const char *commit_buffer, const char **subject)\n{\n\tconst char *eol;\n\tconst char *p = commit_buffer;\n\n\twhile (*p && (*p != '\\n' || p[1] != '\\n'))\n\t\tp++;\n\tif (*p) {\n\t\tp = skip_blank_lines(p + 2);\n\t\teol = strchrnul(p, '\\n');\n\t} else\n\t\teol = p;\n\n\t*subject = p;\n\n\treturn eol - p;\n}\n\nsize_t commit_subject_length(const char *body)\n{\n\tconst char *p = body;\n\twhile (*p) {\n\t\tconst char *next = skip_blank_lines(p);\n\t\tif (next != p)\n\t\t\tbreak;\n\t\tp = strchrnul(p, '\\n');\n\t\tif (*p)\n\t\t\tp++;\n\t}\n\treturn p - body;\n}\n\nstruct commit_list *commit_list_insert(struct commit *item, struct commit_list **list_p)\n{\n\tstruct commit_list *new_list = xmalloc(sizeof(struct commit_list));\n\tnew_list->item = item;\n\tnew_list->next = *list_p;\n\t*list_p = new_list;\n\treturn new_list;\n}\n\nint commit_list_contains(struct commit *item, struct commit_list *list)\n{\n\twhile (list) {\n\t\tif (list->item == item)\n\t\t\treturn 1;\n\t\tlist = list->next;\n\t}\n\n\treturn 0;\n}\n\nunsigned commit_list_count(const struct commit_list *l)\n{\n\tunsigned c = 0;\n\tfor (; l; l = l->next )\n\t\tc++;\n\treturn c;\n}\n\nstruct commit_list *copy_commit_list(const struct commit_list *list)\n{\n\tstruct commit_list *head = NULL;\n\tstruct commit_list **pp = &head;\n\twhile (list) {\n\t\tpp = commit_list_append(list->item, pp);\n\t\tlist = list->next;\n\t}\n\treturn head;\n}\n\nstruct commit_list *reverse_commit_list(struct commit_list *list)\n{\n\tstruct commit_list *next = NULL, *current, *backup;\n\tfor (current = list; current; current = backup) {\n\t\tbackup = current->next;\n\t\tcurrent->next = next;\n\t\tnext = current;\n\t}\n\treturn next;\n}\n\nvoid free_commit_list(struct commit_list *list)\n{\n\twhile (list)\n\t\tpop_commit(&list);\n}\n\nstruct commit_list * commit_list_insert_by_date(struct commit *item, struct commit_list **list)\n{\n\tstruct commit_list **pp = list;\n\tstruct commit_list *p;\n\twhile ((p = *pp) != NULL) {\n\t\tif (p->item->date < item->date) {\n\t\t\tbreak;\n\t\t}\n\t\tpp = &p->next;\n\t}\n\treturn commit_list_insert(item, pp);\n}\n\nstatic int commit_list_compare_by_date(const struct commit_list *a,\n\t\t\t\t       const struct commit_list *b)\n{\n\ttimestamp_t a_date = a->item->date;\n\ttimestamp_t b_date = b->item->date;\n\tif (a_date < b_date)\n\t\treturn 1;\n\tif (a_date > b_date)\n\t\treturn -1;\n\treturn 0;\n}\n\nDEFINE_LIST_SORT(static, commit_list_sort, struct commit_list, next);\n\nvoid commit_list_sort_by_date(struct commit_list **list)\n{\n\tcommit_list_sort(list, commit_list_compare_by_date);\n}\n\nstruct commit *pop_most_recent_commit(struct commit_list **list,\n\t\t\t\t      unsigned int mark)\n{\n\tstruct commit *ret = pop_commit(list);\n\tstruct commit_list *parents = ret->parents;\n\n\twhile (parents) {\n\t\tstruct commit *commit = parents->item;\n\t\tif (!repo_parse_commit(the_repository, commit) && !(commit->object.flags & mark)) {\n\t\t\tcommit->object.flags |= mark;\n\t\t\tcommit_list_insert_by_date(commit, list);\n\t\t}\n\t\tparents = parents->next;\n\t}\n\treturn ret;\n}\n\nstatic void clear_commit_marks_1(struct commit_list **plist,\n\t\t\t\t struct commit *commit, unsigned int mark)\n{\n\twhile (commit) {\n\t\tstruct commit_list *parents;\n\n\t\tif (!(mark & commit->object.flags))\n\t\t\treturn;\n\n\t\tcommit->object.flags &= ~mark;\n\n\t\tparents = commit->parents;\n\t\tif (!parents)\n\t\t\treturn;\n\n\t\twhile ((parents = parents->next)) {\n\t\t\tif (parents->item->object.flags & mark)\n\t\t\t\tcommit_list_insert(parents->item, plist);\n\t\t}\n\n\t\tcommit = commit->parents->item;\n\t}\n}\n\nvoid clear_commit_marks_many(size_t nr, struct commit **commit, unsigned int mark)\n{\n\tfor (size_t i = 0; i < nr; i++) {\n\t\tstruct commit_list *list = NULL;\n\n\t\tclear_commit_marks_1(&list, *commit, mark);\n\t\twhile (list)\n\t\t\tclear_commit_marks_1(&list, pop_commit(&list), mark);\n\t\tcommit++;\n\t}\n}\n\nvoid clear_commit_marks(struct commit *commit, unsigned int mark)\n{\n\tclear_commit_marks_many(1, &commit, mark);\n}\n\nstruct commit *pop_commit(struct commit_list **stack)\n{\n\tstruct commit_list *top = *stack;\n\tstruct commit *item = top ? top->item : NULL;\n\n\tif (top) {\n\t\t*stack = top->next;\n\t\tfree(top);\n\t}\n\treturn item;\n}\n\n/*\n * Topological sort support\n */\n\n/* count number of children that have not been emitted */\ndefine_commit_slab(indegree_slab, int);\n\ndefine_commit_slab(author_date_slab, timestamp_t);\n\nvoid record_author_date(struct author_date_slab *author_date,\n\t\t\tstruct commit *commit)\n{\n\tconst char *buffer = repo_get_commit_buffer(the_repository, commit,\n\t\t\t\t\t\t    NULL);\n\tstruct ident_split ident;\n\tconst char *ident_line;\n\tsize_t ident_len;\n\tchar *date_end;\n\ttimestamp_t date;\n\n\tident_line = find_commit_header(buffer, \"author\", &ident_len);\n\tif (!ident_line)\n\t\tgoto fail_exit; /* no author line */\n\tif (split_ident_line(&ident, ident_line, ident_len) ||\n\t    !ident.date_begin || !ident.date_end)\n\t\tgoto fail_exit; /* malformed \"author\" line */\n\n\tdate = parse_timestamp(ident.date_begin, &date_end, 10);\n\tif (date_end != ident.date_end)\n\t\tgoto fail_exit; /* malformed date */\n\t*(author_date_slab_at(author_date, commit)) = date;\n\nfail_exit:\n\trepo_unuse_commit_buffer(the_repository, commit, buffer);\n}\n\nint compare_commits_by_author_date(const void *a_, const void *b_,\n\t\t\t\t   void *cb_data)\n{\n\tconst struct commit *a = a_, *b = b_;\n\tstruct author_date_slab *author_date = cb_data;\n\ttimestamp_t a_date = *(author_date_slab_at(author_date, a));\n\ttimestamp_t b_date = *(author_date_slab_at(author_date, b));\n\n\t/* newer commits with larger date first */\n\tif (a_date < b_date)\n\t\treturn 1;\n\telse if (a_date > b_date)\n\t\treturn -1;\n\treturn 0;\n}\n\nint compare_commits_by_gen_then_commit_date(const void *a_, const void *b_,\n\t\t\t\t\t    void *unused UNUSED)\n{\n\tconst struct commit *a = a_, *b = b_;\n\tconst timestamp_t generation_a = commit_graph_generation(a),\n\t\t\t  generation_b = commit_graph_generation(b);\n\n\t/* newer commits first */\n\tif (generation_a < generation_b)\n\t\treturn 1;\n\telse if (generation_a > generation_b)\n\t\treturn -1;\n\n\t/* use date as a heuristic when generations are equal */\n\tif (a->date < b->date)\n\t\treturn 1;\n\telse if (a->date > b->date)\n\t\treturn -1;\n\treturn 0;\n}\n\nint compare_commits_by_commit_date(const void *a_, const void *b_,\n\t\t\t\t   void *unused UNUSED)\n{\n\tconst struct commit *a = a_, *b = b_;\n\t/* newer commits with larger date first */\n\tif (a->date < b->date)\n\t\treturn 1;\n\telse if (a->date > b->date)\n\t\treturn -1;\n\treturn 0;\n}\n\n/*\n * Performs an in-place topological sort on the list supplied.\n */\nvoid sort_in_topological_order(struct commit_list **list, enum rev_sort_order sort_order)\n{\n\tstruct commit_list *next, *orig = *list;\n\tstruct commit_list **pptr;\n\tstruct indegree_slab indegree;\n\tstruct prio_queue queue;\n\tstruct commit *commit;\n\tstruct author_date_slab author_date;\n\n\tif (!orig)\n\t\treturn;\n\t*list = NULL;\n\n\tinit_indegree_slab(&indegree);\n\tmemset(&queue, '\\0', sizeof(queue));\n\n\tswitch (sort_order) {\n\tdefault: /* REV_SORT_IN_GRAPH_ORDER */\n\t\tqueue.compare = NULL;\n\t\tbreak;\n\tcase REV_SORT_BY_COMMIT_DATE:\n\t\tqueue.compare = compare_commits_by_commit_date;\n\t\tbreak;\n\tcase REV_SORT_BY_AUTHOR_DATE:\n\t\tinit_author_date_slab(&author_date);\n\t\tqueue.compare = compare_commits_by_author_date;\n\t\tqueue.cb_data = &author_date;\n\t\tbreak;\n\t}\n\n\t/* Mark them and clear the indegree */\n\tfor (next = orig; next; next = next->next) {\n\t\tstruct commit *commit = next->item;\n\t\t*(indegree_slab_at(&indegree, commit)) = 1;\n\t\t/* also record the author dates, if needed */\n\t\tif (sort_order == REV_SORT_BY_AUTHOR_DATE)\n\t\t\trecord_author_date(&author_date, commit);\n\t}\n\n\t/* update the indegree */\n\tfor (next = orig; next; next = next->next) {\n\t\tstruct commit_list *parents = next->item->parents;\n\t\twhile (parents) {\n\t\t\tstruct commit *parent = parents->item;\n\t\t\tint *pi = indegree_slab_at(&indegree, parent);\n\n\t\t\tif (*pi)\n\t\t\t\t(*pi)++;\n\t\t\tparents = parents->next;\n\t\t}\n\t}\n\n\t/*\n\t * find the tips\n\t *\n\t * tips are nodes not reachable from any other node in the list\n\t *\n\t * the tips serve as a starting set for the work queue.\n\t */\n\tfor (next = orig; next; next = next->next) {\n\t\tstruct commit *commit = next->item;\n\n\t\tif (*(indegree_slab_at(&indegree, commit)) == 1)\n\t\t\tprio_queue_put(&queue, commit);\n\t}\n\n\t/*\n\t * This is unfortunate; the initial tips need to be shown\n\t * in the order given from the revision traversal machinery.\n\t */\n\tif (sort_order == REV_SORT_IN_GRAPH_ORDER)\n\t\tprio_queue_reverse(&queue);\n\n\t/* We no longer need the commit list */\n\tfree_commit_list(orig);\n\n\tpptr = list;\n\t*list = NULL;\n\twhile ((commit = prio_queue_get(&queue)) != NULL) {\n\t\tstruct commit_list *parents;\n\n\t\tfor (parents = commit->parents; parents ; parents = parents->next) {\n\t\t\tstruct commit *parent = parents->item;\n\t\t\tint *pi = indegree_slab_at(&indegree, parent);\n\n\t\t\tif (!*pi)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * parents are only enqueued for emission\n\t\t\t * when all their children have been emitted thereby\n\t\t\t * guaranteeing topological order.\n\t\t\t */\n\t\t\tif (--(*pi) == 1)\n\t\t\t\tprio_queue_put(&queue, parent);\n\t\t}\n\t\t/*\n\t\t * all children of commit have already been\n\t\t * emitted. we can emit it now.\n\t\t */\n\t\t*(indegree_slab_at(&indegree, commit)) = 0;\n\n\t\tpptr = &commit_list_insert(commit, pptr)->next;\n\t}\n\n\tclear_indegree_slab(&indegree);\n\tclear_prio_queue(&queue);\n\tif (sort_order == REV_SORT_BY_AUTHOR_DATE)\n\t\tclear_author_date_slab(&author_date);\n}\n\nstruct rev_collect {\n\tstruct commit **commit;\n\tint nr;\n\tint alloc;\n\tunsigned int initial : 1;\n};\n\nstatic void add_one_commit(struct object_id *oid, struct rev_collect *revs)\n{\n\tstruct commit *commit;\n\n\tif (is_null_oid(oid))\n\t\treturn;\n\n\tcommit = lookup_commit(the_repository, oid);\n\tif (!commit ||\n\t    (commit->object.flags & TMP_MARK) ||\n\t    repo_parse_commit(the_repository, commit))\n\t\treturn;\n\n\tALLOC_GROW(revs->commit, revs->nr + 1, revs->alloc);\n\trevs->commit[revs->nr++] = commit;\n\tcommit->object.flags |= TMP_MARK;\n}\n\nstatic int collect_one_reflog_ent(struct object_id *ooid, struct object_id *noid,\n\t\t\t\t  const char *ident UNUSED,\n\t\t\t\t  timestamp_t timestamp UNUSED, int tz UNUSED,\n\t\t\t\t  const char *message UNUSED, void *cbdata)\n{\n\tstruct rev_collect *revs = cbdata;\n\n\tif (revs->initial) {\n\t\trevs->initial = 0;\n\t\tadd_one_commit(ooid, revs);\n\t}\n\tadd_one_commit(noid, revs);\n\treturn 0;\n}\n\nstruct commit *get_fork_point(const char *refname, struct commit *commit)\n{\n\tstruct object_id oid;\n\tstruct rev_collect revs;\n\tstruct commit_list *bases = NULL;\n\tint i;\n\tstruct commit *ret = NULL;\n\tchar *full_refname;\n\n\tswitch (repo_dwim_ref(the_repository, refname, strlen(refname), &oid,\n\t\t\t      &full_refname, 0)) {\n\tcase 0:\n\t\tdie(\"No such ref: '%s'\", refname);\n\tcase 1:\n\t\tbreak; /* good */\n\tdefault:\n\t\tdie(\"Ambiguous refname: '%s'\", refname);\n\t}\n\n\tmemset(&revs, 0, sizeof(revs));\n\trevs.initial = 1;\n\trefs_for_each_reflog_ent(get_main_ref_store(the_repository),\n\t\t\t\t full_refname, collect_one_reflog_ent, &revs);\n\n\tif (!revs.nr)\n\t\tadd_one_commit(&oid, &revs);\n\n\tfor (i = 0; i < revs.nr; i++)\n\t\trevs.commit[i]->object.flags &= ~TMP_MARK;\n\n\tif (repo_get_merge_bases_many(the_repository, commit, revs.nr,\n\t\t\t\t      revs.commit, &bases) < 0)\n\t\texit(128);\n\n\t/*\n\t * There should be one and only one merge base, when we found\n\t * a common ancestor among reflog entries.\n\t */\n\tif (!bases || bases->next)\n\t\tgoto cleanup_return;\n\n\t/* And the found one must be one of the reflog entries */\n\tfor (i = 0; i < revs.nr; i++)\n\t\tif (&bases->item->object == &revs.commit[i]->object)\n\t\t\tbreak; /* found */\n\tif (revs.nr <= i)\n\t\tgoto cleanup_return;\n\n\tret = bases->item;\n\ncleanup_return:\n\tfree(revs.commit);\n\tfree_commit_list(bases);\n\tfree(full_refname);\n\treturn ret;\n}\n\n/*\n * Indexed by hash algorithm identifier.\n */\nstatic const char *gpg_sig_headers[] = {\n\tNULL,\n\t\"gpgsig\",\n\t\"gpgsig-sha256\",\n};\n\nint add_header_signature(struct strbuf *buf, struct strbuf *sig, const struct git_hash_algo *algo)\n{\n\tint inspos, copypos;\n\tconst char *eoh;\n\tconst char *gpg_sig_header = gpg_sig_headers[hash_algo_by_ptr(algo)];\n\tint gpg_sig_header_len = strlen(gpg_sig_header);\n\n\t/* find the end of the header */\n\teoh = strstr(buf->buf, \"\\n\\n\");\n\tif (!eoh)\n\t\tinspos = buf->len;\n\telse\n\t\tinspos = eoh - buf->buf + 1;\n\n\tfor (copypos = 0; sig->buf[copypos]; ) {\n\t\tconst char *bol = sig->buf + copypos;\n\t\tconst char *eol = strchrnul(bol, '\\n');\n\t\tint len = (eol - bol) + !!*eol;\n\n\t\tif (!copypos) {\n\t\t\tstrbuf_insert(buf, inspos, gpg_sig_header, gpg_sig_header_len);\n\t\t\tinspos += gpg_sig_header_len;\n\t\t}\n\t\tstrbuf_insertstr(buf, inspos++, \" \");\n\t\tstrbuf_insert(buf, inspos, bol, len);\n\t\tinspos += len;\n\t\tcopypos += len;\n\t}\n\treturn 0;\n}\n\nstatic int sign_commit_to_strbuf(struct strbuf *sig, struct strbuf *buf, const char *keyid)\n{\n\tchar *keyid_to_free = NULL;\n\tint ret = 0;\n\tif (!keyid || !*keyid)\n\t\tkeyid = keyid_to_free = get_signing_key();\n\tif (sign_buffer(buf, sig, keyid))\n\t\tret = -1;\n\tfree(keyid_to_free);\n\treturn ret;\n}\n\nint parse_signed_commit(const struct commit *commit,\n\t\t\tstruct strbuf *payload, struct strbuf *signature,\n\t\t\tconst struct git_hash_algo *algop)\n{\n\tunsigned long size;\n\tconst char *buffer = repo_get_commit_buffer(the_repository, commit,\n\t\t\t\t\t\t    &size);\n\tint ret = parse_buffer_signed_by_header(buffer, size, payload, signature, algop);\n\n\trepo_unuse_commit_buffer(the_repository, commit, buffer);\n\treturn ret;\n}\n\nint parse_buffer_signed_by_header(const char *buffer,\n\t\t\t\t  unsigned long size,\n\t\t\t\t  struct strbuf *payload,\n\t\t\t\t  struct strbuf *signature,\n\t\t\t\t  const struct git_hash_algo *algop)\n{\n\tint in_signature = 0, saw_signature = 0, other_signature = 0;\n\tconst char *line, *tail, *p;\n\tconst char *gpg_sig_header = gpg_sig_headers[hash_algo_by_ptr(algop)];\n\n\tline = buffer;\n\ttail = buffer + size;\n\twhile (line < tail) {\n\t\tconst char *sig = NULL;\n\t\tconst char *next = memchr(line, '\\n', tail - line);\n\n\t\tnext = next ? next + 1 : tail;\n\t\tif (in_signature && line[0] == ' ')\n\t\t\tsig = line + 1;\n\t\telse if (skip_prefix(line, gpg_sig_header, &p) &&\n\t\t\t *p == ' ') {\n\t\t\tsig = line + strlen(gpg_sig_header) + 1;\n\t\t\tother_signature = 0;\n\t\t}\n\t\telse if (starts_with(line, \"gpgsig\"))\n\t\t\tother_signature = 1;\n\t\telse if (other_signature && line[0] != ' ')\n\t\t\tother_signature = 0;\n\t\tif (sig) {\n\t\t\tstrbuf_add(signature, sig, next - sig);\n\t\t\tsaw_signature = 1;\n\t\t\tin_signature = 1;\n\t\t} else {\n\t\t\tif (*line == '\\n')\n\t\t\t\t/* dump the whole remainder of the buffer */\n\t\t\t\tnext = tail;\n\t\t\tif (!other_signature)\n\t\t\t\tstrbuf_add(payload, line, next - line);\n\t\t\tin_signature = 0;\n\t\t}\n\t\tline = next;\n\t}\n\treturn saw_signature;\n}\n\nint remove_signature(struct strbuf *buf)\n{\n\tconst char *line = buf->buf;\n\tconst char *tail = buf->buf + buf->len;\n\tint in_signature = 0;\n\tstruct sigbuf {\n\t\tconst char *start;\n\t\tconst char *end;\n\t} sigs[2], *sigp = &sigs[0];\n\tint i;\n\tconst char *orig_buf = buf->buf;\n\n\tmemset(sigs, 0, sizeof(sigs));\n\n\twhile (line < tail) {\n\t\tconst char *next = memchr(line, '\\n', tail - line);\n\t\tnext = next ? next + 1 : tail;\n\n\t\tif (in_signature && line[0] == ' ')\n\t\t\tsigp->end = next;\n\t\telse if (starts_with(line, \"gpgsig\")) {\n\t\t\tint i;\n\t\t\tfor (i = 1; i < GIT_HASH_NALGOS; i++) {\n\t\t\t\tconst char *p;\n\t\t\t\tif (skip_prefix(line, gpg_sig_headers[i], &p) &&\n\t\t\t\t    *p == ' ') {\n\t\t\t\t\tsigp->start = line;\n\t\t\t\t\tsigp->end = next;\n\t\t\t\t\tin_signature = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (*line == '\\n')\n\t\t\t\t/* dump the whole remainder of the buffer */\n\t\t\t\tnext = tail;\n\t\t\tif (in_signature && sigp - sigs != ARRAY_SIZE(sigs))\n\t\t\t\tsigp++;\n\t\t\tin_signature = 0;\n\t\t}\n\t\tline = next;\n\t}\n\n\tfor (i = ARRAY_SIZE(sigs) - 1; i >= 0; i--)\n\t\tif (sigs[i].start)\n\t\t\tstrbuf_remove(buf, sigs[i].start - orig_buf, sigs[i].end - sigs[i].start);\n\n\treturn sigs[0].start != NULL;\n}\n\nstatic void handle_signed_tag(const struct commit *parent, struct commit_extra_header ***tail)\n{\n\tstruct merge_remote_desc *desc;\n\tstruct commit_extra_header *mergetag;\n\tchar *buf;\n\tunsigned long size;\n\tenum object_type type;\n\tstruct strbuf payload = STRBUF_INIT;\n\tstruct strbuf signature = STRBUF_INIT;\n\n\tdesc = merge_remote_util(parent);\n\tif (!desc || !desc->obj)\n\t\treturn;\n\tbuf = repo_read_object_file(the_repository, &desc->obj->oid, &type,\n\t\t\t\t    &size);\n\tif (!buf || type != OBJ_TAG)\n\t\tgoto free_return;\n\tif (!parse_signature(buf, size, &payload, &signature))\n\t\tgoto free_return;\n\t/*\n\t * We could verify this signature and either omit the tag when\n\t * it does not validate, but the integrator may not have the\n\t * public key of the signer of the tag being merged, while a\n\t * later auditor may have it while auditing, so let's not run\n\t * verify-signed-buffer here for now...\n\t *\n\t * if (verify_signed_buffer(buf, len, buf + len, size - len, ...))\n\t *\twarn(\"warning: signed tag unverified.\");\n\t */\n\tCALLOC_ARRAY(mergetag, 1);\n\tmergetag->key = xstrdup(\"mergetag\");\n\tmergetag->value = buf;\n\tmergetag->len = size;\n\n\t**tail = mergetag;\n\t*tail = &mergetag->next;\n\tstrbuf_release(&payload);\n\tstrbuf_release(&signature);\n\treturn;\n\nfree_return:\n\tfree(buf);\n}\n\nint check_commit_signature(const struct commit *commit, struct signature_check *sigc)\n{\n\tstruct strbuf payload = STRBUF_INIT;\n\tstruct strbuf signature = STRBUF_INIT;\n\tint ret = 1;\n\n\tsigc->result = 'N';\n\n\tif (parse_signed_commit(commit, &payload, &signature, the_hash_algo) <= 0)\n\t\tgoto out;\n\n\tsigc->payload_type = SIGNATURE_PAYLOAD_COMMIT;\n\tsigc->payload = strbuf_detach(&payload, &sigc->payload_len);\n\tret = check_signature(sigc, signature.buf, signature.len);\n\n out:\n\tstrbuf_release(&payload);\n\tstrbuf_release(&signature);\n\n\treturn ret;\n}\n\nvoid verify_merge_signature(struct commit *commit, int verbosity,\n\t\t\t    int check_trust)\n{\n\tchar hex[GIT_MAX_HEXSZ + 1];\n\tstruct signature_check signature_check;\n\tint ret;\n\tmemset(&signature_check, 0, sizeof(signature_check));\n\n\tret = check_commit_signature(commit, &signature_check);\n\n\trepo_find_unique_abbrev_r(the_repository, hex, &commit->object.oid,\n\t\t\t\t  DEFAULT_ABBREV);\n\tswitch (signature_check.result) {\n\tcase 'G':\n\t\tif (ret || (check_trust && signature_check.trust_level < TRUST_MARGINAL))\n\t\t\tdie(_(\"Commit %s has an untrusted GPG signature, \"\n\t\t\t      \"allegedly by %s.\"), hex, signature_check.signer);\n\t\tbreak;\n\tcase 'B':\n\t\tdie(_(\"Commit %s has a bad GPG signature \"\n\t\t      \"allegedly by %s.\"), hex, signature_check.signer);\n\tdefault: /* 'N' */\n\t\tdie(_(\"Commit %s does not have a GPG signature.\"), hex);\n\t}\n\tif (verbosity >= 0 && signature_check.result == 'G')\n\t\tprintf(_(\"Commit %s has a good GPG signature by %s\\n\"),\n\t\t       hex, signature_check.signer);\n\n\tsignature_check_clear(&signature_check);\n}\n\nvoid append_merge_tag_headers(const struct commit_list *parents,\n\t\t\t      struct commit_extra_header ***tail)\n{\n\twhile (parents) {\n\t\tconst struct commit *parent = parents->item;\n\t\thandle_signed_tag(parent, tail);\n\t\tparents = parents->next;\n\t}\n}\n\nstatic int convert_commit_extra_headers(const struct commit_extra_header *orig,\n\t\t\t\t\tstruct commit_extra_header **result)\n{\n\tconst struct git_hash_algo *compat = the_repository->compat_hash_algo;\n\tconst struct git_hash_algo *algo = the_repository->hash_algo;\n\tstruct commit_extra_header *extra = NULL, **tail = &extra;\n\tstruct strbuf out = STRBUF_INIT;\n\twhile (orig) {\n\t\tstruct commit_extra_header *new;\n\t\tCALLOC_ARRAY(new, 1);\n\t\tif (!strcmp(orig->key, \"mergetag\")) {\n\t\t\tif (convert_object_file(the_repository, &out, algo, compat,\n\t\t\t\t\t\torig->value, orig->len,\n\t\t\t\t\t\tOBJ_TAG, 1)) {\n\t\t\t\tfree(new);\n\t\t\t\tfree_commit_extra_headers(extra);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tnew->key = xstrdup(\"mergetag\");\n\t\t\tnew->value = strbuf_detach(&out, &new->len);\n\t\t} else {\n\t\t\tnew->key = xstrdup(orig->key);\n\t\t\tnew->len = orig->len;\n\t\t\tnew->value = xmemdupz(orig->value, orig->len);\n\t\t}\n\t\t*tail = new;\n\t\ttail = &new->next;\n\t\torig = orig->next;\n\t}\n\t*result = extra;\n\treturn 0;\n}\n\nstatic void add_extra_header(struct strbuf *buffer,\n\t\t\t     const struct commit_extra_header *extra)\n{\n\tstrbuf_addstr(buffer, extra->key);\n\tif (extra->len)\n\t\tstrbuf_add_lines(buffer, \" \", extra->value, extra->len);\n\telse\n\t\tstrbuf_addch(buffer, '\\n');\n}\n\nstruct commit_extra_header *read_commit_extra_headers(struct commit *commit,\n\t\t\t\t\t\t      const char **exclude)\n{\n\tstruct commit_extra_header *extra = NULL;\n\tunsigned long size;\n\tconst char *buffer = repo_get_commit_buffer(the_repository, commit,\n\t\t\t\t\t\t    &size);\n\textra = read_commit_extra_header_lines(buffer, size, exclude);\n\trepo_unuse_commit_buffer(the_repository, commit, buffer);\n\treturn extra;\n}\n\nint for_each_mergetag(each_mergetag_fn fn, struct commit *commit, void *data)\n{\n\tstruct commit_extra_header *extra, *to_free;\n\tint res = 0;\n\n\tto_free = read_commit_extra_headers(commit, NULL);\n\tfor (extra = to_free; !res && extra; extra = extra->next) {\n\t\tif (strcmp(extra->key, \"mergetag\"))\n\t\t\tcontinue; /* not a merge tag */\n\t\tres = fn(commit, extra, data);\n\t}\n\tfree_commit_extra_headers(to_free);\n\treturn res;\n}\n\nstatic inline int standard_header_field(const char *field, size_t len)\n{\n\treturn ((len == 4 && !memcmp(field, \"tree\", 4)) ||\n\t\t(len == 6 && !memcmp(field, \"parent\", 6)) ||\n\t\t(len == 6 && !memcmp(field, \"author\", 6)) ||\n\t\t(len == 9 && !memcmp(field, \"committer\", 9)) ||\n\t\t(len == 8 && !memcmp(field, \"encoding\", 8)));\n}\n\nstatic int excluded_header_field(const char *field, size_t len, const char **exclude)\n{\n\tif (!exclude)\n\t\treturn 0;\n\n\twhile (*exclude) {\n\t\tsize_t xlen = strlen(*exclude);\n\t\tif (len == xlen && !memcmp(field, *exclude, xlen))\n\t\t\treturn 1;\n\t\texclude++;\n\t}\n\treturn 0;\n}\n\nstatic struct commit_extra_header *read_commit_extra_header_lines(\n\tconst char *buffer, size_t size,\n\tconst char **exclude)\n{\n\tstruct commit_extra_header *extra = NULL, **tail = &extra, *it = NULL;\n\tconst char *line, *next, *eof, *eob;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tfor (line = buffer, eob = line + size;\n\t     line < eob && *line != '\\n';\n\t     line = next) {\n\t\tnext = memchr(line, '\\n', eob - line);\n\t\tnext = next ? next + 1 : eob;\n\t\tif (*line == ' ') {\n\t\t\t/* continuation */\n\t\t\tif (it)\n\t\t\t\tstrbuf_add(&buf, line + 1, next - (line + 1));\n\t\t\tcontinue;\n\t\t}\n\t\tif (it)\n\t\t\tit->value = strbuf_detach(&buf, &it->len);\n\t\tstrbuf_reset(&buf);\n\t\tit = NULL;\n\n\t\teof = memchr(line, ' ', next - line);\n\t\tif (!eof)\n\t\t\teof = next;\n\t\telse if (standard_header_field(line, eof - line) ||\n\t\t\t excluded_header_field(line, eof - line, exclude))\n\t\t\tcontinue;\n\n\t\tCALLOC_ARRAY(it, 1);\n\t\tit->key = xmemdupz(line, eof-line);\n\t\t*tail = it;\n\t\ttail = &it->next;\n\t\tif (eof + 1 < next)\n\t\t\tstrbuf_add(&buf, eof + 1, next - (eof + 1));\n\t}\n\tif (it)\n\t\tit->value = strbuf_detach(&buf, &it->len);\n\treturn extra;\n}\n\nvoid free_commit_extra_headers(struct commit_extra_header *extra)\n{\n\twhile (extra) {\n\t\tstruct commit_extra_header *next = extra->next;\n\t\tfree(extra->key);\n\t\tfree(extra->value);\n\t\tfree(extra);\n\t\textra = next;\n\t}\n}\n\nint commit_tree(const char *msg, size_t msg_len, const struct object_id *tree,\n\t\tconst struct commit_list *parents, struct object_id *ret,\n\t\tconst char *author, const char *sign_commit)\n{\n\tstruct commit_extra_header *extra = NULL, **tail = &extra;\n\tint result;\n\n\tappend_merge_tag_headers(parents, &tail);\n\tresult = commit_tree_extended(msg, msg_len, tree, parents, ret, author,\n\t\t\t\t      NULL, sign_commit, extra);\n\tfree_commit_extra_headers(extra);\n\treturn result;\n}\n\nstatic int find_invalid_utf8(const char *buf, int len)\n{\n\tint offset = 0;\n\tstatic const unsigned int max_codepoint[] = {\n\t\t0x7f, 0x7ff, 0xffff, 0x10ffff\n\t};\n\n\twhile (len) {\n\t\tunsigned char c = *buf++;\n\t\tint bytes, bad_offset;\n\t\tunsigned int codepoint;\n\t\tunsigned int min_val, max_val;\n\n\t\tlen--;\n\t\toffset++;\n\n\t\t/* Simple US-ASCII? No worries. */\n\t\tif (c < 0x80)\n\t\t\tcontinue;\n\n\t\tbad_offset = offset-1;\n\n\t\t/*\n\t\t * Count how many more high bits set: that's how\n\t\t * many more bytes this sequence should have.\n\t\t */\n\t\tbytes = 0;\n\t\twhile (c & 0x40) {\n\t\t\tc <<= 1;\n\t\t\tbytes++;\n\t\t}\n\n\t\t/*\n\t\t * Must be between 1 and 3 more bytes.  Longer sequences result in\n\t\t * codepoints beyond U+10FFFF, which are guaranteed never to exist.\n\t\t */\n\t\tif (bytes < 1 || 3 < bytes)\n\t\t\treturn bad_offset;\n\n\t\t/* Do we *have* that many bytes? */\n\t\tif (len < bytes)\n\t\t\treturn bad_offset;\n\n\t\t/*\n\t\t * Place the encoded bits at the bottom of the value and compute the\n\t\t * valid range.\n\t\t */\n\t\tcodepoint = (c & 0x7f) >> bytes;\n\t\tmin_val = max_codepoint[bytes-1] + 1;\n\t\tmax_val = max_codepoint[bytes];\n\n\t\toffset += bytes;\n\t\tlen -= bytes;\n\n\t\t/* And verify that they are good continuation bytes */\n\t\tdo {\n\t\t\tcodepoint <<= 6;\n\t\t\tcodepoint |= *buf & 0x3f;\n\t\t\tif ((*buf++ & 0xc0) != 0x80)\n\t\t\t\treturn bad_offset;\n\t\t} while (--bytes);\n\n\t\t/* Reject codepoints that are out of range for the sequence length. */\n\t\tif (codepoint < min_val || codepoint > max_val)\n\t\t\treturn bad_offset;\n\t\t/* Surrogates are only for UTF-16 and cannot be encoded in UTF-8. */\n\t\tif ((codepoint & 0x1ff800) == 0xd800)\n\t\t\treturn bad_offset;\n\t\t/* U+xxFFFE and U+xxFFFF are guaranteed non-characters. */\n\t\tif ((codepoint & 0xfffe) == 0xfffe)\n\t\t\treturn bad_offset;\n\t\t/* So are anything in the range U+FDD0..U+FDEF. */\n\t\tif (codepoint >= 0xfdd0 && codepoint <= 0xfdef)\n\t\t\treturn bad_offset;\n\t}\n\treturn -1;\n}\n\n/*\n * This verifies that the buffer is in proper utf8 format.\n *\n * If it isn't, it assumes any non-utf8 characters are Latin1,\n * and does the conversion.\n */\nstatic int verify_utf8(struct strbuf *buf)\n{\n\tint ok = 1;\n\tlong pos = 0;\n\n\tfor (;;) {\n\t\tint bad;\n\t\tunsigned char c;\n\t\tunsigned char replace[2];\n\n\t\tbad = find_invalid_utf8(buf->buf + pos, buf->len - pos);\n\t\tif (bad < 0)\n\t\t\treturn ok;\n\t\tpos += bad;\n\t\tok = 0;\n\t\tc = buf->buf[pos];\n\t\tstrbuf_remove(buf, pos, 1);\n\n\t\t/* We know 'c' must be in the range 128-255 */\n\t\treplace[0] = 0xc0 + (c >> 6);\n\t\treplace[1] = 0x80 + (c & 0x3f);\n\t\tstrbuf_insert(buf, pos, replace, 2);\n\t\tpos += 2;\n\t}\n}\n\nstatic const char commit_utf8_warn[] =\nN_(\"Warning: commit message did not conform to UTF-8.\\n\"\n   \"You may want to amend it after fixing the message, or set the config\\n\"\n   \"variable i18n.commitEncoding to the encoding your project uses.\\n\");\n\nstatic void write_commit_tree(struct strbuf *buffer, const char *msg, size_t msg_len,\n\t\t\t      const struct object_id *tree,\n\t\t\t      const struct object_id *parents, size_t parents_len,\n\t\t\t      const char *author, const char *committer,\n\t\t\t      const struct commit_extra_header *extra)\n{\n\tint encoding_is_utf8;\n\tsize_t i;\n\n\t/* Not having i18n.commitencoding is the same as having utf-8 */\n\tencoding_is_utf8 = is_encoding_utf8(git_commit_encoding);\n\n\tstrbuf_grow(buffer, 8192); /* should avoid reallocs for the headers */\n\tstrbuf_addf(buffer, \"tree %s\\n\", oid_to_hex(tree));\n\n\t/*\n\t * NOTE! This ordering means that the same exact tree merged with a\n\t * different order of parents will be a _different_ changeset even\n\t * if everything else stays the same.\n\t */\n\tfor (i = 0; i < parents_len; i++)\n\t\tstrbuf_addf(buffer, \"parent %s\\n\", oid_to_hex(&parents[i]));\n\n\t/* Person/date information */\n\tif (!author)\n\t\tauthor = git_author_info(IDENT_STRICT);\n\tstrbuf_addf(buffer, \"author %s\\n\", author);\n\tif (!committer)\n\t\tcommitter = git_committer_info(IDENT_STRICT);\n\tstrbuf_addf(buffer, \"committer %s\\n\", committer);\n\tif (!encoding_is_utf8)\n\t\tstrbuf_addf(buffer, \"encoding %s\\n\", git_commit_encoding);\n\n\twhile (extra) {\n\t\tadd_extra_header(buffer, extra);\n\t\textra = extra->next;\n\t}\n\tstrbuf_addch(buffer, '\\n');\n\n\t/* And add the comment */\n\tstrbuf_add(buffer, msg, msg_len);\n}\n\nint commit_tree_extended(const char *msg, size_t msg_len,\n\t\t\t const struct object_id *tree,\n\t\t\t const struct commit_list *parents, struct object_id *ret,\n\t\t\t const char *author, const char *committer,\n\t\t\t const char *sign_commit,\n\t\t\t const struct commit_extra_header *extra)\n{\n\tstruct repository *r = the_repository;\n\tint result = 0;\n\tint encoding_is_utf8;\n\tstruct strbuf buffer = STRBUF_INIT, compat_buffer = STRBUF_INIT;\n\tstruct strbuf sig = STRBUF_INIT, compat_sig = STRBUF_INIT;\n\tstruct object_id *parent_buf = NULL, *compat_oid = NULL;\n\tstruct object_id compat_oid_buf;\n\tsize_t i, nparents;\n\n\t/* Not having i18n.commitencoding is the same as having utf-8 */\n\tencoding_is_utf8 = is_encoding_utf8(git_commit_encoding);\n\n\tassert_oid_type(tree, OBJ_TREE);\n\n\tif (memchr(msg, '\\0', msg_len))\n\t\treturn error(\"a NUL byte in commit log message not allowed.\");\n\n\tnparents = commit_list_count(parents);\n\tCALLOC_ARRAY(parent_buf, nparents);\n\ti = 0;\n\tfor (const struct commit_list *p = parents; p; p = p->next)\n\t\toidcpy(&parent_buf[i++], &p->item->object.oid);\n\n\twrite_commit_tree(&buffer, msg, msg_len, tree, parent_buf, nparents, author, committer, extra);\n\tif (sign_commit && sign_commit_to_strbuf(&sig, &buffer, sign_commit)) {\n\t\tresult = -1;\n\t\tgoto out;\n\t}\n\tif (r->compat_hash_algo) {\n\t\tstruct commit_extra_header *compat_extra = NULL;\n\t\tstruct object_id mapped_tree;\n\t\tstruct object_id *mapped_parents;\n\n\t\tCALLOC_ARRAY(mapped_parents, nparents);\n\n\t\tif (repo_oid_to_algop(r, tree, r->compat_hash_algo, &mapped_tree)) {\n\t\t\tresult = -1;\n\t\t\tfree(mapped_parents);\n\t\t\tgoto out;\n\t\t}\n\t\tfor (i = 0; i < nparents; i++)\n\t\t\tif (repo_oid_to_algop(r, &parent_buf[i], r->compat_hash_algo, &mapped_parents[i])) {\n\t\t\t\tresult = -1;\n\t\t\t\tfree(mapped_parents);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\tif (convert_commit_extra_headers(extra, &compat_extra)) {\n\t\t\tresult = -1;\n\t\t\tfree(mapped_parents);\n\t\t\tgoto out;\n\t\t}\n\t\twrite_commit_tree(&compat_buffer, msg, msg_len, &mapped_tree,\n\t\t\t\t  mapped_parents, nparents, author, committer, compat_extra);\n\t\tfree_commit_extra_headers(compat_extra);\n\t\tfree(mapped_parents);\n\n\t\tif (sign_commit && sign_commit_to_strbuf(&compat_sig, &compat_buffer, sign_commit)) {\n\t\t\tresult = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (sign_commit) {\n\t\tstruct sig_pairs {\n\t\t\tstruct strbuf *sig;\n\t\t\tconst struct git_hash_algo *algo;\n\t\t} bufs [2] = {\n\t\t\t{ &compat_sig, r->compat_hash_algo },\n\t\t\t{ &sig, r->hash_algo },\n\t\t};\n\n\t\t/*\n\t\t * We write algorithms in the order they were implemented in\n\t\t * Git to produce a stable hash when multiple algorithms are\n\t\t * used.\n\t\t */\n\t\tif (r->compat_hash_algo && hash_algo_by_ptr(bufs[0].algo) > hash_algo_by_ptr(bufs[1].algo))\n\t\t\tSWAP(bufs[0], bufs[1]);\n\n\t\t/*\n\t\t * We traverse each algorithm in order, and apply the signature\n\t\t * to each buffer.\n\t\t */\n\t\tfor (size_t i = 0; i < ARRAY_SIZE(bufs); i++) {\n\t\t\tif (!bufs[i].algo)\n\t\t\t\tcontinue;\n\t\t\tadd_header_signature(&buffer, bufs[i].sig, bufs[i].algo);\n\t\t\tif (r->compat_hash_algo)\n\t\t\t\tadd_header_signature(&compat_buffer, bufs[i].sig, bufs[i].algo);\n\t\t}\n\t}\n\n\t/* And check the encoding. */\n\tif (encoding_is_utf8 && (!verify_utf8(&buffer) || !verify_utf8(&compat_buffer)))\n\t\tfprintf(stderr, _(commit_utf8_warn));\n\n\tif (r->compat_hash_algo) {\n\t\thash_object_file(r->compat_hash_algo, compat_buffer.buf, compat_buffer.len,\n\t\t\tOBJ_COMMIT, &compat_oid_buf);\n\t\tcompat_oid = &compat_oid_buf;\n\t}\n\n\tresult = write_object_file_flags(buffer.buf, buffer.len, OBJ_COMMIT,\n\t\t\t\t\t ret, compat_oid, 0);\nout:\n\tfree(parent_buf);\n\tstrbuf_release(&buffer);\n\tstrbuf_release(&compat_buffer);\n\tstrbuf_release(&sig);\n\tstrbuf_release(&compat_sig);\n\treturn result;\n}\n\ndefine_commit_slab(merge_desc_slab, struct merge_remote_desc *);\nstatic struct merge_desc_slab merge_desc_slab = COMMIT_SLAB_INIT(1, merge_desc_slab);\n\nstruct merge_remote_desc *merge_remote_util(const struct commit *commit)\n{\n\treturn *merge_desc_slab_at(&merge_desc_slab, commit);\n}\n\nvoid set_merge_remote_desc(struct commit *commit,\n\t\t\t   const char *name, struct object *obj)\n{\n\tstruct merge_remote_desc *desc;\n\tFLEX_ALLOC_STR(desc, name, name);\n\tdesc->obj = obj;\n\t*merge_desc_slab_at(&merge_desc_slab, commit) = desc;\n}\n\nstruct commit *get_merge_parent(const char *name)\n{\n\tstruct object *obj;\n\tstruct commit *commit;\n\tstruct object_id oid;\n\tif (repo_get_oid(the_repository, name, &oid))\n\t\treturn NULL;\n\tobj = parse_object(the_repository, &oid);\n\tcommit = (struct commit *)repo_peel_to_type(the_repository, name, 0,\n\t\t\t\t\t\t    obj, OBJ_COMMIT);\n\tif (commit && !merge_remote_util(commit))\n\t\tset_merge_remote_desc(commit, name, obj);\n\treturn commit;\n}\n\n/*\n * Append a commit to the end of the commit_list.\n *\n * next starts by pointing to the variable that holds the head of an\n * empty commit_list, and is updated to point to the \"next\" field of\n * the last item on the list as new commits are appended.\n *\n * Usage example:\n *\n *     struct commit_list *list;\n *     struct commit_list **next = &list;\n *\n *     next = commit_list_append(c1, next);\n *     next = commit_list_append(c2, next);\n *     assert(commit_list_count(list) == 2);\n *     return list;\n */\nstruct commit_list **commit_list_append(struct commit *commit,\n\t\t\t\t\tstruct commit_list **next)\n{\n\tstruct commit_list *new_commit = xmalloc(sizeof(struct commit_list));\n\tnew_commit->item = commit;\n\t*next = new_commit;\n\tnew_commit->next = NULL;\n\treturn &new_commit->next;\n}\n\nconst char *find_commit_header(const char *msg, const char *key, size_t *out_len)\n{\n\tint key_len = strlen(key);\n\tconst char *line = msg;\n\n\twhile (line) {\n\t\tconst char *eol = strchrnul(line, '\\n');\n\n\t\tif (line == eol)\n\t\t\treturn NULL;\n\n\t\tif (eol - line > key_len &&\n\t\t    !strncmp(line, key, key_len) &&\n\t\t    line[key_len] == ' ') {\n\t\t\t*out_len = eol - line - key_len - 1;\n\t\t\treturn line + key_len + 1;\n\t\t}\n\t\tline = *eol ? eol + 1 : NULL;\n\t}\n\treturn NULL;\n}\n\n/*\n * Inspect the given string and determine the true \"end\" of the log message, in\n * order to find where to put a new Signed-off-by trailer.  Ignored are\n * trailing comment lines and blank lines.  To support \"git commit -s\n * --amend\" on an existing commit, we also ignore \"Conflicts:\".  To\n * support \"git commit -v\", we truncate at cut lines.\n *\n * Returns the number of bytes from the tail to ignore, to be fed as\n * the second parameter to append_signoff().\n */\nsize_t ignored_log_message_bytes(const char *buf, size_t len)\n{\n\tsize_t boc = 0;\n\tsize_t bol = 0;\n\tint in_old_conflicts_block = 0;\n\tsize_t cutoff = wt_status_locate_end(buf, len);\n\n\twhile (bol < cutoff) {\n\t\tconst char *next_line = memchr(buf + bol, '\\n', len - bol);\n\n\t\tif (!next_line)\n\t\t\tnext_line = buf + len;\n\t\telse\n\t\t\tnext_line++;\n\n\t\tif (starts_with_mem(buf + bol, cutoff - bol, comment_line_str) ||\n\t\t    buf[bol] == '\\n') {\n\t\t\t/* is this the first of the run of comments? */\n\t\t\tif (!boc)\n\t\t\t\tboc = bol;\n\t\t\t/* otherwise, it is just continuing */\n\t\t} else if (starts_with(buf + bol, \"Conflicts:\\n\")) {\n\t\t\tin_old_conflicts_block = 1;\n\t\t\tif (!boc)\n\t\t\t\tboc = bol;\n\t\t} else if (in_old_conflicts_block && buf[bol] == '\\t') {\n\t\t\t; /* a pathname in the conflicts block */\n\t\t} else if (boc) {\n\t\t\t/* the previous was not trailing comment */\n\t\t\tboc = 0;\n\t\t\tin_old_conflicts_block = 0;\n\t\t}\n\t\tbol = next_line - buf;\n\t}\n\treturn boc ? len - boc : len - cutoff;\n}\n\nint run_commit_hook(int editor_is_used, const char *index_file,\n\t\t    int *invoked_hook, const char *name, ...)\n{\n\tstruct run_hooks_opt opt = RUN_HOOKS_OPT_INIT;\n\tva_list args;\n\tconst char *arg;\n\n\tstrvec_pushf(&opt.env, \"GIT_INDEX_FILE=%s\", index_file);\n\n\t/*\n\t * Let the hook know that no editor will be launched.\n\t */\n\tif (!editor_is_used)\n\t\tstrvec_push(&opt.env, \"GIT_EDITOR=:\");\n\n\tva_start(args, name);\n\twhile ((arg = va_arg(args, const char *)))\n\t\tstrvec_push(&opt.args, arg);\n\tva_end(args);\n\n\topt.invoked_hook = invoked_hook;\n\treturn run_hooks_opt(the_repository, name, &opt);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00842678bd212236544e55f13661fd47aae2467f",
  "sha1_ok": true,
  "size": 51566
}
