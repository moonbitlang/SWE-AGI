{
  "content": {
    "base64": "I2lmbmRlZiBDQUNIRV9ICiNkZWZpbmUgQ0FDSEVfSAoKI2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAic3RyYnVmLmgiCiNpbmNsdWRlICJoYXNobWFwLmgiCiNpbmNsdWRlICJsaXN0LmgiCiNpbmNsdWRlICJhZHZpY2UuaCIKI2luY2x1ZGUgImdldHRleHQuaCIKI2luY2x1ZGUgImNvbnZlcnQuaCIKI2luY2x1ZGUgInRyYWNlLmgiCiNpbmNsdWRlICJzdHJpbmctbGlzdC5oIgojaW5jbHVkZSAicGFjay1yZXZpbmRleC5oIgojaW5jbHVkZSAiaGFzaC5oIgojaW5jbHVkZSAicGF0aC5oIgojaW5jbHVkZSAic2hhMS1hcnJheS5oIgojaW5jbHVkZSAicmVwb3NpdG9yeS5oIgojaW5jbHVkZSAibWVtLXBvb2wuaCIKCiNpbmNsdWRlIDx6bGliLmg+CnR5cGVkZWYgc3RydWN0IGdpdF96c3RyZWFtIHsKCXpfc3RyZWFtIHo7Cgl1bnNpZ25lZCBsb25nIGF2YWlsX2luOwoJdW5zaWduZWQgbG9uZyBhdmFpbF9vdXQ7Cgl1bnNpZ25lZCBsb25nIHRvdGFsX2luOwoJdW5zaWduZWQgbG9uZyB0b3RhbF9vdXQ7Cgl1bnNpZ25lZCBjaGFyICpuZXh0X2luOwoJdW5zaWduZWQgY2hhciAqbmV4dF9vdXQ7Cn0gZ2l0X3pzdHJlYW07Cgp2b2lkIGdpdF9pbmZsYXRlX2luaXQoZ2l0X3pzdHJlYW0gKik7CnZvaWQgZ2l0X2luZmxhdGVfaW5pdF9nemlwX29ubHkoZ2l0X3pzdHJlYW0gKik7CnZvaWQgZ2l0X2luZmxhdGVfZW5kKGdpdF96c3RyZWFtICopOwppbnQgZ2l0X2luZmxhdGUoZ2l0X3pzdHJlYW0gKiwgaW50IGZsdXNoKTsKCnZvaWQgZ2l0X2RlZmxhdGVfaW5pdChnaXRfenN0cmVhbSAqLCBpbnQgbGV2ZWwpOwp2b2lkIGdpdF9kZWZsYXRlX2luaXRfZ3ppcChnaXRfenN0cmVhbSAqLCBpbnQgbGV2ZWwpOwp2b2lkIGdpdF9kZWZsYXRlX2luaXRfcmF3KGdpdF96c3RyZWFtICosIGludCBsZXZlbCk7CnZvaWQgZ2l0X2RlZmxhdGVfZW5kKGdpdF96c3RyZWFtICopOwppbnQgZ2l0X2RlZmxhdGVfYWJvcnQoZ2l0X3pzdHJlYW0gKik7CmludCBnaXRfZGVmbGF0ZV9lbmRfZ2VudGx5KGdpdF96c3RyZWFtICopOwppbnQgZ2l0X2RlZmxhdGUoZ2l0X3pzdHJlYW0gKiwgaW50IGZsdXNoKTsKdW5zaWduZWQgbG9uZyBnaXRfZGVmbGF0ZV9ib3VuZChnaXRfenN0cmVhbSAqLCB1bnNpZ25lZCBsb25nKTsKCi8qIFRoZSBsZW5ndGggaW4gYnl0ZXMgYW5kIGluIGhleCBkaWdpdHMgb2YgYW4gb2JqZWN0IG5hbWUgKFNIQS0xIHZhbHVlKS4gKi8KI2RlZmluZSBHSVRfU0hBMV9SQVdTWiAyMAojZGVmaW5lIEdJVF9TSEExX0hFWFNaICgyICogR0lUX1NIQTFfUkFXU1opCi8qIFRoZSBibG9jayBzaXplIG9mIFNIQS0xLiAqLwojZGVmaW5lIEdJVF9TSEExX0JMS1NaIDY0CgovKiBUaGUgbGVuZ3RoIGluIGJ5dGVzIGFuZCBpbiBoZXggZGlnaXRzIG9mIGFuIG9iamVjdCBuYW1lIChTSEEtMjU2IHZhbHVlKS4gKi8KI2RlZmluZSBHSVRfU0hBMjU2X1JBV1NaIDMyCiNkZWZpbmUgR0lUX1NIQTI1Nl9IRVhTWiAoMiAqIEdJVF9TSEEyNTZfUkFXU1opCi8qIFRoZSBibG9jayBzaXplIG9mIFNIQS0yNTYuICovCiNkZWZpbmUgR0lUX1NIQTI1Nl9CTEtTWiA2NAoKLyogVGhlIGxlbmd0aCBpbiBieXRlIGFuZCBpbiBoZXggZGlnaXRzIG9mIHRoZSBsYXJnZXN0IHBvc3NpYmxlIGhhc2ggdmFsdWUuICovCiNkZWZpbmUgR0lUX01BWF9SQVdTWiBHSVRfU0hBMjU2X1JBV1NaCiNkZWZpbmUgR0lUX01BWF9IRVhTWiBHSVRfU0hBMjU2X0hFWFNaCi8qIFRoZSBsYXJnZXN0IHBvc3NpYmxlIGJsb2NrIHNpemUgZm9yIGFueSBzdXBwb3J0ZWQgaGFzaC4gKi8KI2RlZmluZSBHSVRfTUFYX0JMS1NaIEdJVF9TSEEyNTZfQkxLU1oKCnN0cnVjdCBvYmplY3RfaWQgewoJdW5zaWduZWQgY2hhciBoYXNoW0dJVF9NQVhfUkFXU1pdOwp9OwoKI2RlZmluZSB0aGVfaGFzaF9hbGdvIHRoZV9yZXBvc2l0b3J5LT5oYXNoX2FsZ28KCiNpZiBkZWZpbmVkKERUX1VOS05PV04pICYmICFkZWZpbmVkKE5PX0RfVFlQRV9JTl9ESVJFTlQpCiNkZWZpbmUgRFRZUEUoZGUpCSgoZGUpLT5kX3R5cGUpCiNlbHNlCiN1bmRlZiBEVF9VTktOT1dOCiN1bmRlZiBEVF9ESVIKI3VuZGVmIERUX1JFRwojdW5kZWYgRFRfTE5LCiNkZWZpbmUgRFRfVU5LTk9XTgkwCiNkZWZpbmUgRFRfRElSCQkxCiNkZWZpbmUgRFRfUkVHCQkyCiNkZWZpbmUgRFRfTE5LCQkzCiNkZWZpbmUgRFRZUEUoZGUpCURUX1VOS05PV04KI2VuZGlmCgovKiB1bmtub3duIG1vZGUgKGltcG9zc2libGUgY29tYmluYXRpb24gU19JRklGT3xTX0lGQ0hSKSAqLwojZGVmaW5lIFNfSUZJTlZBTElEICAgICAwMDMwMDAwCgovKgogKiBBICJkaXJlY3RvcnkgbGluayIgaXMgYSBsaW5rIHRvIGFub3RoZXIgZ2l0IGRpcmVjdG9yeS4KICoKICogVGhlIHZhbHVlIDAxNjAwMDAgaXMgbm90IG5vcm1hbGx5IGEgdmFsaWQgbW9kZSwgYW5kCiAqIGFsc28ganVzdCBoYXBwZW5zIHRvIGJlIFNfSUZESVIgKyBTX0lGTE5LCiAqLwojZGVmaW5lIFNfSUZHSVRMSU5LCTAxNjAwMDAKI2RlZmluZSBTX0lTR0lUTElOSyhtKQkoKChtKSAmIFNfSUZNVCkgPT0gU19JRkdJVExJTkspCgovKgogKiBTb21lIG1vZGUgYml0cyBhcmUgYWxzbyB1c2VkIGludGVybmFsbHkgZm9yIGNvbXB1dGF0aW9ucy4KICoKICogVGhleSAqbXVzdCogbm90IG92ZXJsYXAgd2l0aCBhbnkgdmFsaWQgbW9kZXMsIGFuZCB0aGV5ICptdXN0KiBub3QgYmUgZW1pdHRlZAogKiB0byBvdXRzaWRlIHdvcmxkIC0gaS5lLiBhcHBlYXIgb24gZGlzayBvciBuZXR3b3JrLiBJbiBvdGhlciB3b3JkcywgaXQncyBqdXN0CiAqIHRlbXBvcmFyeSBmaWVsZHMsIHdoaWNoIHdlIGludGVybmFsbHkgdXNlLCBidXQgdGhleSBoYXZlIHRvIHN0YXkgaW4taG91c2UuCiAqCiAqICggc3VjaCBhcHByb2FjaCBpcyB2YWxpZCwgYXMgc3RhbmRhcmQgU19JRiogZml0cyBpbnRvIDE2IGJpdHMsIGFuZCBpbiBHaXQKICogICBjb2RlYmFzZSBtb2RlIGlzIGB1bnNpZ25lZCBpbnRgIHdoaWNoIGlzIGFzc3VtZWQgdG8gYmUgYXQgbGVhc3QgMzIgYml0cyApCiAqLwoKLyogdXNlZCBpbnRlcm5hbGx5IGluIHRyZWUtZGlmZiAqLwojZGVmaW5lIFNfRElGRlRSRUVfSUZYTUlOX05FUQkweDgwMDAwMDAwCgoKLyoKICogSW50ZW5zaXZlIHJlc2VhcmNoIG92ZXIgdGhlIGNvdXJzZSBvZiBtYW55IHllYXJzIGhhcyBzaG93biB0aGF0CiAqIHBvcnQgOTQxOCBpcyB0b3RhbGx5IHVudXNlZCBieSBhbnl0aGluZyBlbHNlLiBPcgogKgogKglZb3VyIHNlYXJjaCAtICJwb3J0IDk0MTgiIC0gZGlkIG5vdCBtYXRjaCBhbnkgZG9jdW1lbnRzLgogKgogKiBhcyB3d3cuZ29vZ2xlLmNvbSBwdXRzIGl0LgogKgogKiBUaGlzIHBvcnQgaGFzIGJlZW4gcHJvcGVybHkgYXNzaWduZWQgZm9yIGdpdCB1c2UgYnkgSUFOQToKICogZ2l0IChBc3NpZ25lZC05NDE4KSBbSTA2LTA1MDcyOC0wMDAxXS4KICoKICoJZ2l0ICA5NDE4L3RjcCAgIGdpdCBwYWNrIHRyYW5zZmVyIHNlcnZpY2UKICoJZ2l0ICA5NDE4L3VkcCAgIGdpdCBwYWNrIHRyYW5zZmVyIHNlcnZpY2UKICoKICogd2l0aCBMaW51cyBUb3J2YWxkcyA8dG9ydmFsZHNAb3NkbC5vcmc+IGFzIHRoZSBwb2ludCBvZgogKiBjb250YWN0LiBTZXB0ZW1iZXIgMjAwNS4KICoKICogU2VlIGh0dHA6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvcG9ydC1udW1iZXJzCiAqLwojZGVmaW5lIERFRkFVTFRfR0lUX1BPUlQgOTQxOAoKLyoKICogQmFzaWMgZGF0YSBzdHJ1Y3R1cmVzIGZvciB0aGUgZGlyZWN0b3J5IGNhY2hlCiAqLwoKI2RlZmluZSBDQUNIRV9TSUdOQVRVUkUgMHg0NDQ5NTI0MwkvKiAiRElSQyIgKi8Kc3RydWN0IGNhY2hlX2hlYWRlciB7Cgl1aW50MzJfdCBoZHJfc2lnbmF0dXJlOwoJdWludDMyX3QgaGRyX3ZlcnNpb247Cgl1aW50MzJfdCBoZHJfZW50cmllczsKfTsKCiNkZWZpbmUgSU5ERVhfRk9STUFUX0xCIDIKI2RlZmluZSBJTkRFWF9GT1JNQVRfVUIgNAoKLyoKICogVGhlICJjYWNoZV90aW1lIiBpcyBqdXN0IHRoZSBsb3cgMzIgYml0cyBvZiB0aGUKICogdGltZS4gSXQgZG9lc24ndCBtYXR0ZXIgaWYgaXQgb3ZlcmZsb3dzIC0gd2Ugb25seQogKiBjaGVjayBpdCBmb3IgZXF1YWxpdHkgaW4gdGhlIDMyIGJpdHMgd2Ugc2F2ZS4KICovCnN0cnVjdCBjYWNoZV90aW1lIHsKCXVpbnQzMl90IHNlYzsKCXVpbnQzMl90IG5zZWM7Cn07CgpzdHJ1Y3Qgc3RhdF9kYXRhIHsKCXN0cnVjdCBjYWNoZV90aW1lIHNkX2N0aW1lOwoJc3RydWN0IGNhY2hlX3RpbWUgc2RfbXRpbWU7Cgl1bnNpZ25lZCBpbnQgc2RfZGV2OwoJdW5zaWduZWQgaW50IHNkX2lubzsKCXVuc2lnbmVkIGludCBzZF91aWQ7Cgl1bnNpZ25lZCBpbnQgc2RfZ2lkOwoJdW5zaWduZWQgaW50IHNkX3NpemU7Cn07CgpzdHJ1Y3QgY2FjaGVfZW50cnkgewoJc3RydWN0IGhhc2htYXBfZW50cnkgZW50OwoJc3RydWN0IHN0YXRfZGF0YSBjZV9zdGF0X2RhdGE7Cgl1bnNpZ25lZCBpbnQgY2VfbW9kZTsKCXVuc2lnbmVkIGludCBjZV9mbGFnczsKCXVuc2lnbmVkIGludCBtZW1fcG9vbF9hbGxvY2F0ZWQ7Cgl1bnNpZ25lZCBpbnQgY2VfbmFtZWxlbjsKCXVuc2lnbmVkIGludCBpbmRleDsJLyogZm9yIGxpbmsgZXh0ZW5zaW9uICovCglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCWNoYXIgbmFtZVtGTEVYX0FSUkFZXTsgLyogbW9yZSAqLwp9OwoKI2RlZmluZSBDRV9TVEFHRU1BU0sgKDB4MzAwMCkKI2RlZmluZSBDRV9FWFRFTkRFRCAgKDB4NDAwMCkKI2RlZmluZSBDRV9WQUxJRCAgICAgKDB4ODAwMCkKI2RlZmluZSBDRV9TVEFHRVNISUZUIDEyCgovKgogKiBSYW5nZSAweEZGRkYwRkZGIGluIGNlX2ZsYWdzIGlzIGRpdmlkZWQgaW50bwogKiB0d28gcGFydHM6IGluLW1lbW9yeSBmbGFncyBhbmQgb24tZGlzayBvbmVzLgogKiBGbGFncyBpbiBDRV9FWFRFTkRFRF9GTEFHUyB3aWxsIGdldCBzYXZlZCBvbi1kaXNrCiAqIGlmIHlvdSB3YW50IHRvIHNhdmUgYSBuZXcgZmxhZywgYWRkIGl0IGluCiAqIENFX0VYVEVOREVEX0ZMQUdTCiAqCiAqIEluLW1lbW9yeSBvbmx5IGZsYWdzCiAqLwojZGVmaW5lIENFX1VQREFURSAgICAgICAgICAgICgxIDw8IDE2KQojZGVmaW5lIENFX1JFTU9WRSAgICAgICAgICAgICgxIDw8IDE3KQojZGVmaW5lIENFX1VQVE9EQVRFICAgICAgICAgICgxIDw8IDE4KQojZGVmaW5lIENFX0FEREVEICAgICAgICAgICAgICgxIDw8IDE5KQoKI2RlZmluZSBDRV9IQVNIRUQgICAgICAgICAgICAoMSA8PCAyMCkKI2RlZmluZSBDRV9GU01PTklUT1JfVkFMSUQgICAoMSA8PCAyMSkKI2RlZmluZSBDRV9XVF9SRU1PVkUgICAgICAgICAoMSA8PCAyMikgLyogcmVtb3ZlIGluIHdvcmsgZGlyZWN0b3J5ICovCiNkZWZpbmUgQ0VfQ09ORkxJQ1RFRCAgICAgICAgKDEgPDwgMjMpCgojZGVmaW5lIENFX1VOUEFDS0VEICAgICAgICAgICgxIDw8IDI0KQojZGVmaW5lIENFX05FV19TS0lQX1dPUktUUkVFICgxIDw8IDI1KQoKLyogdXNlZCB0byB0ZW1wb3JhcmlseSBtYXJrIHBhdGhzIG1hdGNoZWQgYnkgcGF0aHNwZWNzICovCiNkZWZpbmUgQ0VfTUFUQ0hFRCAgICAgICAgICAgKDEgPDwgMjYpCgojZGVmaW5lIENFX1VQREFURV9JTl9CQVNFICAgICgxIDw8IDI3KQojZGVmaW5lIENFX1NUUklQX05BTUUgICAgICAgICgxIDw8IDI4KQoKLyoKICogRXh0ZW5kZWQgb24tZGlzayBmbGFncwogKi8KI2RlZmluZSBDRV9JTlRFTlRfVE9fQUREICAgICAoMSA8PCAyOSkKI2RlZmluZSBDRV9TS0lQX1dPUktUUkVFICAgICAoMSA8PCAzMCkKLyogQ0VfRVhURU5ERUQyIGlzIGZvciBmdXR1cmUgZXh0ZW5zaW9uICovCiNkZWZpbmUgQ0VfRVhURU5ERUQyICAgICAgICAgKDFVIDw8IDMxKQoKI2RlZmluZSBDRV9FWFRFTkRFRF9GTEFHUyAoQ0VfSU5URU5UX1RPX0FERCB8IENFX1NLSVBfV09SS1RSRUUpCgovKgogKiBTYWZlZ3VhcmQgdG8gYXZvaWQgc2F2aW5nIHdyb25nIGZsYWdzOgogKiAgLSBDRV9FWFRFTkRFRDIgd29uJ3QgZ2V0IHNhdmVkIHVudGlsIGl0cyBzZW1hbnRpYyBpcyBrbm93bgogKiAgLSBCaXRzIGluIDB4MDAwMEZGRkYgaGF2ZSBiZWVuIHNhdmVkIGluIGNlX2ZsYWdzIGFscmVhZHkKICogIC0gQml0cyBpbiAweDAwM0YwMDAwIGFyZSBjdXJyZW50bHkgaW4tbWVtb3J5IGZsYWdzCiAqLwojaWYgQ0VfRVhURU5ERURfRkxBR1MgJiAweDgwM0ZGRkZGCiNlcnJvciAiQ0VfRVhURU5ERURfRkxBR1Mgb3V0IG9mIHJhbmdlIgojZW5kaWYKCi8qIEZvcndhcmQgc3RydWN0dXJlIGRlY2xzICovCnN0cnVjdCBwYXRoc3BlYzsKc3RydWN0IGNoaWxkX3Byb2Nlc3M7CnN0cnVjdCB0cmVlOwoKLyoKICogQ29weSB0aGUgc2hhMSBhbmQgc3RhdCBzdGF0ZSBvZiBhIGNhY2hlIGVudHJ5IGZyb20gb25lIHRvCiAqIGFub3RoZXIuIEJ1dCB3ZSBuZXZlciBjaGFuZ2UgdGhlIG5hbWUsIG9yIHRoZSBoYXNoIHN0YXRlIQogKi8Kc3RhdGljIGlubGluZSB2b2lkIGNvcHlfY2FjaGVfZW50cnkoc3RydWN0IGNhY2hlX2VudHJ5ICpkc3QsCgkJCQkgICAgY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpzcmMpCnsKCXVuc2lnbmVkIGludCBzdGF0ZSA9IGRzdC0+Y2VfZmxhZ3MgJiBDRV9IQVNIRUQ7CglpbnQgbWVtX3Bvb2xfYWxsb2NhdGVkID0gZHN0LT5tZW1fcG9vbF9hbGxvY2F0ZWQ7CgoJLyogRG9uJ3QgY29weSBoYXNoIGNoYWluIGFuZCBuYW1lICovCgltZW1jcHkoJmRzdC0+Y2Vfc3RhdF9kYXRhLCAmc3JjLT5jZV9zdGF0X2RhdGEsCgkJCW9mZnNldG9mKHN0cnVjdCBjYWNoZV9lbnRyeSwgbmFtZSkgLQoJCQlvZmZzZXRvZihzdHJ1Y3QgY2FjaGVfZW50cnksIGNlX3N0YXRfZGF0YSkpOwoKCS8qIFJlc3RvcmUgdGhlIGhhc2ggc3RhdGUgKi8KCWRzdC0+Y2VfZmxhZ3MgPSAoZHN0LT5jZV9mbGFncyAmIH5DRV9IQVNIRUQpIHwgc3RhdGU7CgoJLyogUmVzdG9yZSB0aGUgbWVtX3Bvb2xfYWxsb2NhdGVkIGZsYWcgKi8KCWRzdC0+bWVtX3Bvb2xfYWxsb2NhdGVkID0gbWVtX3Bvb2xfYWxsb2NhdGVkOwp9CgpzdGF0aWMgaW5saW5lIHVuc2lnbmVkIGNyZWF0ZV9jZV9mbGFncyh1bnNpZ25lZCBzdGFnZSkKewoJcmV0dXJuIChzdGFnZSA8PCBDRV9TVEFHRVNISUZUKTsKfQoKI2RlZmluZSBjZV9uYW1lbGVuKGNlKSAoKGNlKS0+Y2VfbmFtZWxlbikKI2RlZmluZSBjZV9zaXplKGNlKSBjYWNoZV9lbnRyeV9zaXplKGNlX25hbWVsZW4oY2UpKQojZGVmaW5lIGNlX3N0YWdlKGNlKSAoKENFX1NUQUdFTUFTSyAmIChjZSktPmNlX2ZsYWdzKSA+PiBDRV9TVEFHRVNISUZUKQojZGVmaW5lIGNlX3VwdG9kYXRlKGNlKSAoKGNlKS0+Y2VfZmxhZ3MgJiBDRV9VUFRPREFURSkKI2RlZmluZSBjZV9za2lwX3dvcmt0cmVlKGNlKSAoKGNlKS0+Y2VfZmxhZ3MgJiBDRV9TS0lQX1dPUktUUkVFKQojZGVmaW5lIGNlX21hcmtfdXB0b2RhdGUoY2UpICgoY2UpLT5jZV9mbGFncyB8PSBDRV9VUFRPREFURSkKI2RlZmluZSBjZV9pbnRlbnRfdG9fYWRkKGNlKSAoKGNlKS0+Y2VfZmxhZ3MgJiBDRV9JTlRFTlRfVE9fQUREKQoKI2RlZmluZSBjZV9wZXJtaXNzaW9ucyhtb2RlKSAoKChtb2RlKSAmIDAxMDApID8gMDc1NSA6IDA2NDQpCnN0YXRpYyBpbmxpbmUgdW5zaWduZWQgaW50IGNyZWF0ZV9jZV9tb2RlKHVuc2lnbmVkIGludCBtb2RlKQp7CglpZiAoU19JU0xOSyhtb2RlKSkKCQlyZXR1cm4gU19JRkxOSzsKCWlmIChTX0lTRElSKG1vZGUpIHx8IFNfSVNHSVRMSU5LKG1vZGUpKQoJCXJldHVybiBTX0lGR0lUTElOSzsKCXJldHVybiBTX0lGUkVHIHwgY2VfcGVybWlzc2lvbnMobW9kZSk7Cn0Kc3RhdGljIGlubGluZSB1bnNpZ25lZCBpbnQgY2VfbW9kZV9mcm9tX3N0YXQoY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwKCQkJCQkgICAgIHVuc2lnbmVkIGludCBtb2RlKQp7CglleHRlcm4gaW50IHRydXN0X2V4ZWN1dGFibGVfYml0LCBoYXNfc3ltbGlua3M7CglpZiAoIWhhc19zeW1saW5rcyAmJiBTX0lTUkVHKG1vZGUpICYmCgkgICAgY2UgJiYgU19JU0xOSyhjZS0+Y2VfbW9kZSkpCgkJcmV0dXJuIGNlLT5jZV9tb2RlOwoJaWYgKCF0cnVzdF9leGVjdXRhYmxlX2JpdCAmJiBTX0lTUkVHKG1vZGUpKSB7CgkJaWYgKGNlICYmIFNfSVNSRUcoY2UtPmNlX21vZGUpKQoJCQlyZXR1cm4gY2UtPmNlX21vZGU7CgkJcmV0dXJuIGNyZWF0ZV9jZV9tb2RlKDA2NjYpOwoJfQoJcmV0dXJuIGNyZWF0ZV9jZV9tb2RlKG1vZGUpOwp9CnN0YXRpYyBpbmxpbmUgaW50IGNlX3RvX2R0eXBlKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UpCnsKCXVuc2lnbmVkIGNlX21vZGUgPSBudG9obChjZS0+Y2VfbW9kZSk7CglpZiAoU19JU1JFRyhjZV9tb2RlKSkKCQlyZXR1cm4gRFRfUkVHOwoJZWxzZSBpZiAoU19JU0RJUihjZV9tb2RlKSB8fCBTX0lTR0lUTElOSyhjZV9tb2RlKSkKCQlyZXR1cm4gRFRfRElSOwoJZWxzZSBpZiAoU19JU0xOSyhjZV9tb2RlKSkKCQlyZXR1cm4gRFRfTE5LOwoJZWxzZQoJCXJldHVybiBEVF9VTktOT1dOOwp9CnN0YXRpYyBpbmxpbmUgdW5zaWduZWQgaW50IGNhbm9uX21vZGUodW5zaWduZWQgaW50IG1vZGUpCnsKCWlmIChTX0lTUkVHKG1vZGUpKQoJCXJldHVybiBTX0lGUkVHIHwgY2VfcGVybWlzc2lvbnMobW9kZSk7CglpZiAoU19JU0xOSyhtb2RlKSkKCQlyZXR1cm4gU19JRkxOSzsKCWlmIChTX0lTRElSKG1vZGUpKQoJCXJldHVybiBTX0lGRElSOwoJcmV0dXJuIFNfSUZHSVRMSU5LOwp9CgojZGVmaW5lIGNhY2hlX2VudHJ5X3NpemUobGVuKSAob2Zmc2V0b2Yoc3RydWN0IGNhY2hlX2VudHJ5LG5hbWUpICsgKGxlbikgKyAxKQoKI2RlZmluZSBTT01FVEhJTkdfQ0hBTkdFRAkoMSA8PCAwKSAvKiB1bmNsYXNzaWZpZWQgY2hhbmdlcyBnbyBoZXJlICovCiNkZWZpbmUgQ0VfRU5UUllfQ0hBTkdFRAkoMSA8PCAxKQojZGVmaW5lIENFX0VOVFJZX1JFTU9WRUQJKDEgPDwgMikKI2RlZmluZSBDRV9FTlRSWV9BRERFRAkJKDEgPDwgMykKI2RlZmluZSBSRVNPTFZFX1VORE9fQ0hBTkdFRAkoMSA8PCA0KQojZGVmaW5lIENBQ0hFX1RSRUVfQ0hBTkdFRAkoMSA8PCA1KQojZGVmaW5lIFNQTElUX0lOREVYX09SREVSRUQJKDEgPDwgNikKI2RlZmluZSBVTlRSQUNLRURfQ0hBTkdFRAkoMSA8PCA3KQojZGVmaW5lIEZTTU9OSVRPUl9DSEFOR0VECSgxIDw8IDgpCgpzdHJ1Y3Qgc3BsaXRfaW5kZXg7CnN0cnVjdCB1bnRyYWNrZWRfY2FjaGU7CgpzdHJ1Y3QgaW5kZXhfc3RhdGUgewoJc3RydWN0IGNhY2hlX2VudHJ5ICoqY2FjaGU7Cgl1bnNpZ25lZCBpbnQgdmVyc2lvbjsKCXVuc2lnbmVkIGludCBjYWNoZV9uciwgY2FjaGVfYWxsb2MsIGNhY2hlX2NoYW5nZWQ7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnJlc29sdmVfdW5kbzsKCXN0cnVjdCBjYWNoZV90cmVlICpjYWNoZV90cmVlOwoJc3RydWN0IHNwbGl0X2luZGV4ICpzcGxpdF9pbmRleDsKCXN0cnVjdCBjYWNoZV90aW1lIHRpbWVzdGFtcDsKCXVuc2lnbmVkIG5hbWVfaGFzaF9pbml0aWFsaXplZCA6IDEsCgkJIGluaXRpYWxpemVkIDogMSwKCQkgZHJvcF9jYWNoZV90cmVlIDogMTsKCXN0cnVjdCBoYXNobWFwIG5hbWVfaGFzaDsKCXN0cnVjdCBoYXNobWFwIGRpcl9oYXNoOwoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CglzdHJ1Y3QgdW50cmFja2VkX2NhY2hlICp1bnRyYWNrZWQ7Cgl1aW50NjRfdCBmc21vbml0b3JfbGFzdF91cGRhdGU7CglzdHJ1Y3QgZXdhaF9iaXRtYXAgKmZzbW9uaXRvcl9kaXJ0eTsKCXN0cnVjdCBtZW1fcG9vbCAqY2VfbWVtX3Bvb2w7Cn07CgpleHRlcm4gc3RydWN0IGluZGV4X3N0YXRlIHRoZV9pbmRleDsKCi8qIE5hbWUgaGFzaGluZyAqLwpleHRlcm4gaW50IHRlc3RfbGF6eV9pbml0X25hbWVfaGFzaChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgaW50IHRyeV90aHJlYWRlZCk7CmV4dGVybiB2b2lkIGFkZF9uYW1lX2hhc2goc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UpOwpleHRlcm4gdm9pZCByZW1vdmVfbmFtZV9oYXNoKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKTsKZXh0ZXJuIHZvaWQgZnJlZV9uYW1lX2hhc2goc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUpOwoKCi8qIENhY2hlIGVudHJ5IGNyZWF0aW9uIGFuZCBjbGVhbnVwICovCgovKgogKiBDcmVhdGUgY2FjaGVfZW50cnkgaW50ZW5kZWQgZm9yIHVzZSBpbiB0aGUgc3BlY2lmaWVkIGluZGV4LiBDYWxsZXIKICogaXMgcmVzcG9uc2libGUgZm9yIGRpc2NhcmRpbmcgdGhlIGNhY2hlX2VudHJ5IHdpdGgKICogYGRpc2NhcmRfY2FjaGVfZW50cnlgLgogKi8Kc3RydWN0IGNhY2hlX2VudHJ5ICptYWtlX2NhY2hlX2VudHJ5KHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLAoJCQkJICAgICB1bnNpZ25lZCBpbnQgbW9kZSwKCQkJCSAgICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkJICAgICBjb25zdCBjaGFyICpwYXRoLAoJCQkJICAgICBpbnQgc3RhZ2UsCgkJCQkgICAgIHVuc2lnbmVkIGludCByZWZyZXNoX29wdGlvbnMpOwoKc3RydWN0IGNhY2hlX2VudHJ5ICptYWtlX2VtcHR5X2NhY2hlX2VudHJ5KHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLAoJCQkJCSAgIHNpemVfdCBuYW1lX2xlbik7CgovKgogKiBDcmVhdGUgYSBjYWNoZV9lbnRyeSB0aGF0IGlzIG5vdCBpbnRlbmRlZCB0byBiZSBhZGRlZCB0byBhbiBpbmRleC4KICogQ2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBkaXNjYXJkaW5nIHRoZSBjYWNoZV9lbnRyeQogKiB3aXRoIGBkaXNjYXJkX2NhY2hlX2VudHJ5YC4KICovCnN0cnVjdCBjYWNoZV9lbnRyeSAqbWFrZV90cmFuc2llbnRfY2FjaGVfZW50cnkodW5zaWduZWQgaW50IG1vZGUsCgkJCQkJICAgICAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCQkgICAgICAgY29uc3QgY2hhciAqcGF0aCwKCQkJCQkgICAgICAgaW50IHN0YWdlKTsKCnN0cnVjdCBjYWNoZV9lbnRyeSAqbWFrZV9lbXB0eV90cmFuc2llbnRfY2FjaGVfZW50cnkoc2l6ZV90IG5hbWVfbGVuKTsKCi8qCiAqIERpc2NhcmQgY2FjaGUgZW50cnkuCiAqLwp2b2lkIGRpc2NhcmRfY2FjaGVfZW50cnkoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSk7CgovKgogKiBDaGVjayBjb25maWd1cmF0aW9uIGlmIHdlIHNob3VsZCBwZXJmb3JtIGV4dHJhIHZhbGlkYXRpb24gb24gY2FjaGUKICogZW50cmllcy4KICovCmludCBzaG91bGRfdmFsaWRhdGVfY2FjaGVfZW50cmllcyh2b2lkKTsKCi8qCiAqIER1cGxpY2F0ZSBhIGNhY2hlX2VudHJ5LiBBbGxvY2F0ZSBtZW1vcnkgZm9yIHRoZSBuZXcgZW50cnkgZnJvbSBhCiAqIG1lbW9yeV9wb29sLiBUYWtlcyBpbnRvIGFjY291bnQgY2FjaGVfZW50cnkgZmllbGRzIHRoYXQgYXJlIG1lYW50CiAqIGZvciBtYW5hZ2luZyB0aGUgdW5kZXJseWluZyBtZW1vcnkgYWxsb2NhdGlvbiBvZiB0aGUgY2FjaGVfZW50cnkuCiAqLwpzdHJ1Y3QgY2FjaGVfZW50cnkgKmR1cF9jYWNoZV9lbnRyeShjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSk7CgovKgogKiBWYWxpZGF0ZSB0aGUgY2FjaGUgZW50cmllcyBpbiB0aGUgaW5kZXguICBUaGlzIGlzIGFuIGludGVybmFsCiAqIGNvbnNpc3RlbmN5IGNoZWNrIHRoYXQgdGhlIGNhY2hlX2VudHJ5IHN0cnVjdHMgYXJlIGFsbG9jYXRlZCBmcm9tCiAqIHRoZSBleHBlY3RlZCBtZW1vcnkgcG9vbC4KICovCnZvaWQgdmFsaWRhdGVfY2FjaGVfZW50cmllcyhjb25zdCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSk7CgojaWZuZGVmIE5PX1RIRV9JTkRFWF9DT01QQVRJQklMSVRZX01BQ1JPUwojZGVmaW5lIGFjdGl2ZV9jYWNoZSAodGhlX2luZGV4LmNhY2hlKQojZGVmaW5lIGFjdGl2ZV9uciAodGhlX2luZGV4LmNhY2hlX25yKQojZGVmaW5lIGFjdGl2ZV9hbGxvYyAodGhlX2luZGV4LmNhY2hlX2FsbG9jKQojZGVmaW5lIGFjdGl2ZV9jYWNoZV9jaGFuZ2VkICh0aGVfaW5kZXguY2FjaGVfY2hhbmdlZCkKI2RlZmluZSBhY3RpdmVfY2FjaGVfdHJlZSAodGhlX2luZGV4LmNhY2hlX3RyZWUpCgojZGVmaW5lIHJlYWRfY2FjaGUoKSByZWFkX2luZGV4KCZ0aGVfaW5kZXgpCiNkZWZpbmUgcmVhZF9jYWNoZV9mcm9tKHBhdGgpIHJlYWRfaW5kZXhfZnJvbSgmdGhlX2luZGV4LCAocGF0aCksIChnZXRfZ2l0X2RpcigpKSkKI2RlZmluZSByZWFkX2NhY2hlX3ByZWxvYWQocGF0aHNwZWMpIHJlYWRfaW5kZXhfcHJlbG9hZCgmdGhlX2luZGV4LCAocGF0aHNwZWMpLCAwKQojZGVmaW5lIGlzX2NhY2hlX3VuYm9ybigpIGlzX2luZGV4X3VuYm9ybigmdGhlX2luZGV4KQojZGVmaW5lIHJlYWRfY2FjaGVfdW5tZXJnZWQoKSByZWFkX2luZGV4X3VubWVyZ2VkKCZ0aGVfaW5kZXgpCiNkZWZpbmUgZGlzY2FyZF9jYWNoZSgpIGRpc2NhcmRfaW5kZXgoJnRoZV9pbmRleCkKI2RlZmluZSB1bm1lcmdlZF9jYWNoZSgpIHVubWVyZ2VkX2luZGV4KCZ0aGVfaW5kZXgpCiNkZWZpbmUgY2FjaGVfbmFtZV9wb3MobmFtZSwgbmFtZWxlbikgaW5kZXhfbmFtZV9wb3MoJnRoZV9pbmRleCwobmFtZSksKG5hbWVsZW4pKQojZGVmaW5lIGFkZF9jYWNoZV9lbnRyeShjZSwgb3B0aW9uKSBhZGRfaW5kZXhfZW50cnkoJnRoZV9pbmRleCwgKGNlKSwgKG9wdGlvbikpCiNkZWZpbmUgcmVuYW1lX2NhY2hlX2VudHJ5X2F0KHBvcywgbmV3X25hbWUpIHJlbmFtZV9pbmRleF9lbnRyeV9hdCgmdGhlX2luZGV4LCAocG9zKSwgKG5ld19uYW1lKSkKI2RlZmluZSByZW1vdmVfY2FjaGVfZW50cnlfYXQocG9zKSByZW1vdmVfaW5kZXhfZW50cnlfYXQoJnRoZV9pbmRleCwgKHBvcykpCiNkZWZpbmUgcmVtb3ZlX2ZpbGVfZnJvbV9jYWNoZShwYXRoKSByZW1vdmVfZmlsZV9mcm9tX2luZGV4KCZ0aGVfaW5kZXgsIChwYXRoKSkKI2RlZmluZSBhZGRfdG9fY2FjaGUocGF0aCwgc3QsIGZsYWdzKSBhZGRfdG9faW5kZXgoJnRoZV9pbmRleCwgKHBhdGgpLCAoc3QpLCAoZmxhZ3MpKQojZGVmaW5lIGFkZF9maWxlX3RvX2NhY2hlKHBhdGgsIGZsYWdzKSBhZGRfZmlsZV90b19pbmRleCgmdGhlX2luZGV4LCAocGF0aCksIChmbGFncykpCiNkZWZpbmUgY2htb2RfY2FjaGVfZW50cnkoY2UsIGZsaXApIGNobW9kX2luZGV4X2VudHJ5KCZ0aGVfaW5kZXgsIChjZSksIChmbGlwKSkKI2RlZmluZSByZWZyZXNoX2NhY2hlKGZsYWdzKSByZWZyZXNoX2luZGV4KCZ0aGVfaW5kZXgsIChmbGFncyksIE5VTEwsIE5VTEwsIE5VTEwpCiNkZWZpbmUgY2VfbWF0Y2hfc3RhdChjZSwgc3QsIG9wdGlvbnMpIGllX21hdGNoX3N0YXQoJnRoZV9pbmRleCwgKGNlKSwgKHN0KSwgKG9wdGlvbnMpKQojZGVmaW5lIGNlX21vZGlmaWVkKGNlLCBzdCwgb3B0aW9ucykgaWVfbW9kaWZpZWQoJnRoZV9pbmRleCwgKGNlKSwgKHN0KSwgKG9wdGlvbnMpKQojZGVmaW5lIGNhY2hlX2Rpcl9leGlzdHMobmFtZSwgbmFtZWxlbikgaW5kZXhfZGlyX2V4aXN0cygmdGhlX2luZGV4LCAobmFtZSksIChuYW1lbGVuKSkKI2RlZmluZSBjYWNoZV9maWxlX2V4aXN0cyhuYW1lLCBuYW1lbGVuLCBpZ25jYXNlKSBpbmRleF9maWxlX2V4aXN0cygmdGhlX2luZGV4LCAobmFtZSksIChuYW1lbGVuKSwgKGlnbmNhc2UpKQojZGVmaW5lIGNhY2hlX25hbWVfaXNfb3RoZXIobmFtZSwgbmFtZWxlbikgaW5kZXhfbmFtZV9pc19vdGhlcigmdGhlX2luZGV4LCAobmFtZSksIChuYW1lbGVuKSkKI2RlZmluZSByZXNvbHZlX3VuZG9fY2xlYXIoKSByZXNvbHZlX3VuZG9fY2xlYXJfaW5kZXgoJnRoZV9pbmRleCkKI2RlZmluZSB1bm1lcmdlX2NhY2hlX2VudHJ5X2F0KGF0KSB1bm1lcmdlX2luZGV4X2VudHJ5X2F0KCZ0aGVfaW5kZXgsIGF0KQojZGVmaW5lIHVubWVyZ2VfY2FjaGUocGF0aHNwZWMpIHVubWVyZ2VfaW5kZXgoJnRoZV9pbmRleCwgcGF0aHNwZWMpCiNkZWZpbmUgcmVhZF9ibG9iX2RhdGFfZnJvbV9jYWNoZShwYXRoLCBzeikgcmVhZF9ibG9iX2RhdGFfZnJvbV9pbmRleCgmdGhlX2luZGV4LCAocGF0aCksIChzeikpCiNlbmRpZgoKI2RlZmluZSBUWVBFX0JJVFMgMwoKLyoKICogVmFsdWVzIGluIHRoaXMgZW51bSAoZXhjZXB0IHRob3NlIG91dHNpZGUgdGhlIDMgYml0IHJhbmdlKSBhcmUgcGFydAogKiBvZiBwYWNrIGZpbGUgZm9ybWF0LiBTZWUgRG9jdW1lbnRhdGlvbi90ZWNobmljYWwvcGFjay1mb3JtYXQudHh0CiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLgogKi8KZW51bSBvYmplY3RfdHlwZSB7CglPQkpfQkFEID0gLTEsCglPQkpfTk9ORSA9IDAsCglPQkpfQ09NTUlUID0gMSwKCU9CSl9UUkVFID0gMiwKCU9CSl9CTE9CID0gMywKCU9CSl9UQUcgPSA0LAoJLyogNSBmb3IgZnV0dXJlIGV4cGFuc2lvbiAqLwoJT0JKX09GU19ERUxUQSA9IDYsCglPQkpfUkVGX0RFTFRBID0gNywKCU9CSl9BTlksCglPQkpfTUFYCn07CgpzdGF0aWMgaW5saW5lIGVudW0gb2JqZWN0X3R5cGUgb2JqZWN0X3R5cGUodW5zaWduZWQgaW50IG1vZGUpCnsKCXJldHVybiBTX0lTRElSKG1vZGUpID8gT0JKX1RSRUUgOgoJCVNfSVNHSVRMSU5LKG1vZGUpID8gT0JKX0NPTU1JVCA6CgkJT0JKX0JMT0I7Cn0KCi8qIERvdWJsZS1jaGVjayBsb2NhbF9yZXBvX2VudiBiZWxvdyBpZiB5b3UgYWRkIHRvIHRoaXMgbGlzdC4gKi8KI2RlZmluZSBHSVRfRElSX0VOVklST05NRU5UICJHSVRfRElSIgojZGVmaW5lIEdJVF9DT01NT05fRElSX0VOVklST05NRU5UICJHSVRfQ09NTU9OX0RJUiIKI2RlZmluZSBHSVRfTkFNRVNQQUNFX0VOVklST05NRU5UICJHSVRfTkFNRVNQQUNFIgojZGVmaW5lIEdJVF9XT1JLX1RSRUVfRU5WSVJPTk1FTlQgIkdJVF9XT1JLX1RSRUUiCiNkZWZpbmUgR0lUX1BSRUZJWF9FTlZJUk9OTUVOVCAiR0lUX1BSRUZJWCIKI2RlZmluZSBHSVRfU1VQRVJfUFJFRklYX0VOVklST05NRU5UICJHSVRfSU5URVJOQUxfU1VQRVJfUFJFRklYIgojZGVmaW5lIERFRkFVTFRfR0lUX0RJUl9FTlZJUk9OTUVOVCAiLmdpdCIKI2RlZmluZSBEQl9FTlZJUk9OTUVOVCAiR0lUX09CSkVDVF9ESVJFQ1RPUlkiCiNkZWZpbmUgSU5ERVhfRU5WSVJPTk1FTlQgIkdJVF9JTkRFWF9GSUxFIgojZGVmaW5lIEdSQUZUX0VOVklST05NRU5UICJHSVRfR1JBRlRfRklMRSIKI2RlZmluZSBHSVRfU0hBTExPV19GSUxFX0VOVklST05NRU5UICJHSVRfU0hBTExPV19GSUxFIgojZGVmaW5lIFRFTVBMQVRFX0RJUl9FTlZJUk9OTUVOVCAiR0lUX1RFTVBMQVRFX0RJUiIKI2RlZmluZSBDT05GSUdfRU5WSVJPTk1FTlQgIkdJVF9DT05GSUciCiNkZWZpbmUgQ09ORklHX0RBVEFfRU5WSVJPTk1FTlQgIkdJVF9DT05GSUdfUEFSQU1FVEVSUyIKI2RlZmluZSBFWEVDX1BBVEhfRU5WSVJPTk1FTlQgIkdJVF9FWEVDX1BBVEgiCiNkZWZpbmUgQ0VJTElOR19ESVJFQ1RPUklFU19FTlZJUk9OTUVOVCAiR0lUX0NFSUxJTkdfRElSRUNUT1JJRVMiCiNkZWZpbmUgTk9fUkVQTEFDRV9PQkpFQ1RTX0VOVklST05NRU5UICJHSVRfTk9fUkVQTEFDRV9PQkpFQ1RTIgojZGVmaW5lIEdJVF9SRVBMQUNFX1JFRl9CQVNFX0VOVklST05NRU5UICJHSVRfUkVQTEFDRV9SRUZfQkFTRSIKI2RlZmluZSBHSVRBVFRSSUJVVEVTX0ZJTEUgIi5naXRhdHRyaWJ1dGVzIgojZGVmaW5lIElORk9BVFRSSUJVVEVTX0ZJTEUgImluZm8vYXR0cmlidXRlcyIKI2RlZmluZSBBVFRSSUJVVEVfTUFDUk9fUFJFRklYICJbYXR0cl0iCiNkZWZpbmUgR0lUTU9EVUxFU19GSUxFICIuZ2l0bW9kdWxlcyIKI2RlZmluZSBHSVRNT0RVTEVTX0lOREVYICI6LmdpdG1vZHVsZXMiCiNkZWZpbmUgR0lUTU9EVUxFU19IRUFEICJIRUFEOi5naXRtb2R1bGVzIgojZGVmaW5lIEdJVF9OT1RFU19SRUZfRU5WSVJPTk1FTlQgIkdJVF9OT1RFU19SRUYiCiNkZWZpbmUgR0lUX05PVEVTX0RFRkFVTFRfUkVGICJyZWZzL25vdGVzL2NvbW1pdHMiCiNkZWZpbmUgR0lUX05PVEVTX0RJU1BMQVlfUkVGX0VOVklST05NRU5UICJHSVRfTk9URVNfRElTUExBWV9SRUYiCiNkZWZpbmUgR0lUX05PVEVTX1JFV1JJVEVfUkVGX0VOVklST05NRU5UICJHSVRfTk9URVNfUkVXUklURV9SRUYiCiNkZWZpbmUgR0lUX05PVEVTX1JFV1JJVEVfTU9ERV9FTlZJUk9OTUVOVCAiR0lUX05PVEVTX1JFV1JJVEVfTU9ERSIKI2RlZmluZSBHSVRfTElURVJBTF9QQVRIU1BFQ1NfRU5WSVJPTk1FTlQgIkdJVF9MSVRFUkFMX1BBVEhTUEVDUyIKI2RlZmluZSBHSVRfR0xPQl9QQVRIU1BFQ1NfRU5WSVJPTk1FTlQgIkdJVF9HTE9CX1BBVEhTUEVDUyIKI2RlZmluZSBHSVRfTk9HTE9CX1BBVEhTUEVDU19FTlZJUk9OTUVOVCAiR0lUX05PR0xPQl9QQVRIU1BFQ1MiCiNkZWZpbmUgR0lUX0lDQVNFX1BBVEhTUEVDU19FTlZJUk9OTUVOVCAiR0lUX0lDQVNFX1BBVEhTUEVDUyIKI2RlZmluZSBHSVRfUVVBUkFOVElORV9FTlZJUk9OTUVOVCAiR0lUX1FVQVJBTlRJTkVfUEFUSCIKI2RlZmluZSBHSVRfT1BUSU9OQUxfTE9DS1NfRU5WSVJPTk1FTlQgIkdJVF9PUFRJT05BTF9MT0NLUyIKI2RlZmluZSBHSVRfVEVYVF9ET01BSU5fRElSX0VOVklST05NRU5UICJHSVRfVEVYVERPTUFJTkRJUiIKCi8qCiAqIEVudmlyb25tZW50IHZhcmlhYmxlIHVzZWQgaW4gaGFuZHNoYWtpbmcgdGhlIHdpcmUgcHJvdG9jb2wuCiAqIENvbnRhaW5zIGEgY29sb24gJzonIHNlcGFyYXRlZCBsaXN0IG9mIGtleXMgd2l0aCBvcHRpb25hbCB2YWx1ZXMKICogJ2tleVs9dmFsdWVdJy4gIFByZXNlbmNlIG9mIHVua25vd24ga2V5cyBhbmQgdmFsdWVzIG11c3QgYmUKICogaWdub3JlZC4KICovCiNkZWZpbmUgR0lUX1BST1RPQ09MX0VOVklST05NRU5UICJHSVRfUFJPVE9DT0wiCi8qIEhUVFAgaGVhZGVyIHVzZWQgdG8gaGFuZHNoYWtlIHRoZSB3aXJlIHByb3RvY29sICovCiNkZWZpbmUgR0lUX1BST1RPQ09MX0hFQURFUiAiR2l0LVByb3RvY29sIgoKLyoKICogVGhpcyBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBleHBlY3RlZCB0byBjb250YWluIGEgYm9vbGVhbiBpbmRpY2F0aW5nCiAqIHdoZXRoZXIgd2Ugc2hvdWxkIG9yIHNob3VsZCBub3QgdHJlYXQ6CiAqCiAqICAgR0lUX0RJUj1mb28uZ2l0IGdpdCAuLi4KICoKICogYXMgaWYgR0lUX1dPUktfVFJFRT0uIHdhcyBnaXZlbi4gSXQncyBub3QgZXhwZWN0ZWQgdGhhdCB1c2VycyB3aWxsIG1ha2UgdXNlCiAqIG9mIHRoaXMsIGJ1dCB3ZSB1c2UgaXQgaW50ZXJuYWxseSB0byBjb21tdW5pY2F0ZSB0byBzdWItcHJvY2Vzc2VzIHRoYXQgd2UKICogYXJlIGluIGEgYmFyZSByZXBvLiBJZiBub3Qgc2V0LCBkZWZhdWx0cyB0byB0cnVlLgogKi8KI2RlZmluZSBHSVRfSU1QTElDSVRfV09SS19UUkVFX0VOVklST05NRU5UICJHSVRfSU1QTElDSVRfV09SS19UUkVFIgoKLyoKICogUmVwb3NpdG9yeS1sb2NhbCBHSVRfKiBlbnZpcm9ubWVudCB2YXJpYWJsZXM7IHRoZXNlIHdpbGwgYmUgY2xlYXJlZAogKiB3aGVuIGdpdCBzcGF3bnMgYSBzdWItcHJvY2VzcyB0aGF0IHJ1bnMgaW5zaWRlIGFub3RoZXIgcmVwb3NpdG9yeS4KICogVGhlIGFycmF5IGlzIE5VTEwtdGVybWluYXRlZCwgd2hpY2ggbWFrZXMgaXQgZWFzeSB0byBwYXNzIGluIHRoZSAiZW52IgogKiBwYXJhbWV0ZXIgb2YgYSBydW4tY29tbWFuZCBpbnZvY2F0aW9uLCBvciB0byBkbyBhIHNpbXBsZSB3YWxrLgogKi8KZXh0ZXJuIGNvbnN0IGNoYXIgKiBjb25zdCBsb2NhbF9yZXBvX2VudltdOwoKZXh0ZXJuIHZvaWQgc2V0dXBfZ2l0X2Vudihjb25zdCBjaGFyICpnaXRfZGlyKTsKCi8qCiAqIFJldHVybnMgdHJ1ZSBpZmYgd2UgaGF2ZSBhIGNvbmZpZ3VyZWQgZ2l0IHJlcG9zaXRvcnkgKGVpdGhlciB2aWEKICogc2V0dXBfZ2l0X2RpcmVjdG9yeSwgb3IgaW4gdGhlIGVudmlyb25tZW50IHZpYSAkR0lUX0RJUikuCiAqLwppbnQgaGF2ZV9naXRfZGlyKHZvaWQpOwoKZXh0ZXJuIGludCBpc19iYXJlX3JlcG9zaXRvcnlfY2ZnOwpleHRlcm4gaW50IGlzX2JhcmVfcmVwb3NpdG9yeSh2b2lkKTsKZXh0ZXJuIGludCBpc19pbnNpZGVfZ2l0X2Rpcih2b2lkKTsKZXh0ZXJuIGNoYXIgKmdpdF93b3JrX3RyZWVfY2ZnOwpleHRlcm4gaW50IGlzX2luc2lkZV93b3JrX3RyZWUodm9pZCk7CmV4dGVybiBjb25zdCBjaGFyICpnZXRfZ2l0X2Rpcih2b2lkKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdldF9naXRfY29tbW9uX2Rpcih2b2lkKTsKZXh0ZXJuIGNoYXIgKmdldF9vYmplY3RfZGlyZWN0b3J5KHZvaWQpOwpleHRlcm4gY2hhciAqZ2V0X2luZGV4X2ZpbGUodm9pZCk7CmV4dGVybiBjaGFyICpnZXRfZ3JhZnRfZmlsZShzdHJ1Y3QgcmVwb3NpdG9yeSAqcik7CmV4dGVybiB2b2lkIHNldF9naXRfZGlyKGNvbnN0IGNoYXIgKnBhdGgpOwpleHRlcm4gaW50IGdldF9jb21tb25fZGlyX25vZW52KHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpnaXRkaXIpOwpleHRlcm4gaW50IGdldF9jb21tb25fZGlyKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpnaXRkaXIpOwpleHRlcm4gY29uc3QgY2hhciAqZ2V0X2dpdF9uYW1lc3BhY2Uodm9pZCk7CmV4dGVybiBjb25zdCBjaGFyICpzdHJpcF9uYW1lc3BhY2UoY29uc3QgY2hhciAqbmFtZXNwYWNlZF9yZWYpOwpleHRlcm4gY29uc3QgY2hhciAqZ2V0X3N1cGVyX3ByZWZpeCh2b2lkKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdldF9naXRfd29ya190cmVlKHZvaWQpOwoKLyoKICogUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIHBhdGggaXMgYSBnaXQgZGlyZWN0b3J5OyBub3RlIHRoYXQgdGhpcyBfanVzdF8KICogbG9va3MgYXQgdGhlIGRpcmVjdG9yeSBpdHNlbGYuIElmIHlvdSB3YW50IHRvIGtub3cgd2hldGhlciAiZm9vLy5naXQiCiAqIGlzIGEgcmVwb3NpdG9yeSwgeW91IG11c3QgZmVlZCB0aGF0IHBhdGgsIG5vdCBqdXN0ICJmb28iLgogKi8KZXh0ZXJuIGludCBpc19naXRfZGlyZWN0b3J5KGNvbnN0IGNoYXIgKnBhdGgpOwoKLyoKICogUmV0dXJuIDEgaWYgdGhlIGdpdmVuIHBhdGggaXMgdGhlIHJvb3Qgb2YgYSBnaXQgcmVwb3NpdG9yeSBvcgogKiBzdWJtb2R1bGUsIGVsc2UgMC4gV2lsbCBub3QgcmV0dXJuIDEgZm9yIGJhcmUgcmVwb3NpdG9yaWVzIHdpdGggdGhlCiAqIGV4Y2VwdGlvbiBvZiBjcmVhdGluZyBhIGJhcmUgcmVwb3NpdG9yeSBpbiAiZm9vLy5naXQiIGFuZCBjYWxsaW5nCiAqIGlzX2dpdF9yZXBvc2l0b3J5KCJmb28iKS4KICoKICogSWYgd2UgcnVuIGludG8gcmVhZCBlcnJvcnMsIHdlIGVyciBvbiB0aGUgc2lkZSBvZiBzYXlpbmcgInllcywgaXQgaXMiLAogKiBhcyB3ZSB1c3VhbGx5IGNvbnNpZGVyIHN1Yi1yZXBvcyBwcmVjaW91cywgYW5kIHdvdWxkIHByZWZlciB0byBlcnIgb24gdGhlCiAqIHNpZGUgb2Ygbm90IGRpc3J1cHRpbmcgb3IgZGVsZXRpbmcgdGhlbS4KICovCmV4dGVybiBpbnQgaXNfbm9uYmFyZV9yZXBvc2l0b3J5X2RpcihzdHJ1Y3Qgc3RyYnVmICpwYXRoKTsKCiNkZWZpbmUgUkVBRF9HSVRGSUxFX0VSUl9TVEFUX0ZBSUxFRCAxCiNkZWZpbmUgUkVBRF9HSVRGSUxFX0VSUl9OT1RfQV9GSUxFIDIKI2RlZmluZSBSRUFEX0dJVEZJTEVfRVJSX09QRU5fRkFJTEVEIDMKI2RlZmluZSBSRUFEX0dJVEZJTEVfRVJSX1JFQURfRkFJTEVEIDQKI2RlZmluZSBSRUFEX0dJVEZJTEVfRVJSX0lOVkFMSURfRk9STUFUIDUKI2RlZmluZSBSRUFEX0dJVEZJTEVfRVJSX05PX1BBVEggNgojZGVmaW5lIFJFQURfR0lURklMRV9FUlJfTk9UX0FfUkVQTyA3CiNkZWZpbmUgUkVBRF9HSVRGSUxFX0VSUl9UT09fTEFSR0UgOApleHRlcm4gdm9pZCByZWFkX2dpdGZpbGVfZXJyb3JfZGllKGludCBlcnJvcl9jb2RlLCBjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFyICpkaXIpOwpleHRlcm4gY29uc3QgY2hhciAqcmVhZF9naXRmaWxlX2dlbnRseShjb25zdCBjaGFyICpwYXRoLCBpbnQgKnJldHVybl9lcnJvcl9jb2RlKTsKI2RlZmluZSByZWFkX2dpdGZpbGUocGF0aCkgcmVhZF9naXRmaWxlX2dlbnRseSgocGF0aCksIE5VTEwpCmV4dGVybiBjb25zdCBjaGFyICpyZXNvbHZlX2dpdGRpcl9nZW50bHkoY29uc3QgY2hhciAqc3VzcGVjdCwgaW50ICpyZXR1cm5fZXJyb3JfY29kZSk7CiNkZWZpbmUgcmVzb2x2ZV9naXRkaXIocGF0aCkgcmVzb2x2ZV9naXRkaXJfZ2VudGx5KChwYXRoKSwgTlVMTCkKCmV4dGVybiB2b2lkIHNldF9naXRfd29ya190cmVlKGNvbnN0IGNoYXIgKnRyZWUpOwoKI2RlZmluZSBBTFRFUk5BVEVfREJfRU5WSVJPTk1FTlQgIkdJVF9BTFRFUk5BVEVfT0JKRUNUX0RJUkVDVE9SSUVTIgoKZXh0ZXJuIHZvaWQgc2V0dXBfd29ya190cmVlKHZvaWQpOwovKgogKiBGaW5kIHRoZSBjb21tb25kaXIgYW5kIGdpdGRpciBvZiB0aGUgcmVwb3NpdG9yeSB0aGF0IGNvbnRhaW5zIHRoZSBjdXJyZW50CiAqIHdvcmtpbmcgZGlyZWN0b3J5LCB3aXRob3V0IGNoYW5naW5nIHRoZSB3b3JraW5nIGRpcmVjdG9yeSBvciBvdGhlciBnbG9iYWwKICogc3RhdGUuIFRoZSByZXN1bHQgaXMgYXBwZW5kZWQgdG8gY29tbW9uZGlyIGFuZCBnaXRkaXIuICBJZiB0aGUgZGlzY292ZXJlZAogKiBnaXRkaXIgZG9lcyBub3QgY29ycmVzcG9uZCB0byBhIHdvcmt0cmVlLCB0aGVuICdjb21tb25kaXInIGFuZCAnZ2l0ZGlyJyB3aWxsCiAqIGJvdGggaGF2ZSB0aGUgc2FtZSByZXN1bHQgYXBwZW5kZWQgdG8gdGhlIGJ1ZmZlci4gIFRoZSByZXR1cm4gdmFsdWUgaXMKICogZWl0aGVyIDAgdXBvbiBzdWNjZXNzIGFuZCBub24temVybyBpZiBubyByZXBvc2l0b3J5IHdhcyBmb3VuZC4KICovCmV4dGVybiBpbnQgZGlzY292ZXJfZ2l0X2RpcmVjdG9yeShzdHJ1Y3Qgc3RyYnVmICpjb21tb25kaXIsCgkJCQkgIHN0cnVjdCBzdHJidWYgKmdpdGRpcik7CmV4dGVybiBjb25zdCBjaGFyICpzZXR1cF9naXRfZGlyZWN0b3J5X2dlbnRseShpbnQgKik7CmV4dGVybiBjb25zdCBjaGFyICpzZXR1cF9naXRfZGlyZWN0b3J5KHZvaWQpOwpleHRlcm4gY2hhciAqcHJlZml4X3BhdGgoY29uc3QgY2hhciAqcHJlZml4LCBpbnQgbGVuLCBjb25zdCBjaGFyICpwYXRoKTsKZXh0ZXJuIGNoYXIgKnByZWZpeF9wYXRoX2dlbnRseShjb25zdCBjaGFyICpwcmVmaXgsIGludCBsZW4sIGludCAqcmVtYWluaW5nLCBjb25zdCBjaGFyICpwYXRoKTsKCi8qCiAqIENvbmNhdGVuYXRlICJwcmVmaXgiIChpZiBsZW4gaXMgbm9uLXplcm8pIGFuZCAicGF0aCIsIHdpdGggbm8KICogY29ubmVjdGluZyBjaGFyYWN0ZXJzIChzbyAicHJlZml4IiBzaG91bGQgZW5kIHdpdGggYSAiLyIpLgogKiBVbmxpa2UgcHJlZml4X3BhdGgsIHRoaXMgc2hvdWxkIGJlIHVzZWQgaWYgdGhlIG5hbWVkIGZpbGUgZG9lcwogKiBub3QgaGF2ZSB0byBpbnRlcmFjdCB3aXRoIGluZGV4IGVudHJ5OyBpLmUuIG5hbWUgb2YgYSByYW5kb20gZmlsZQogKiBvbiB0aGUgZmlsZXN5c3RlbS4KICoKICogVGhlIHJldHVybiB2YWx1ZSBpcyBhbHdheXMgYSBuZXdseSBhbGxvY2F0ZWQgc3RyaW5nIChldmVuIGlmIHRoZQogKiBwcmVmaXggd2FzIGVtcHR5KS4KICovCmV4dGVybiBjaGFyICpwcmVmaXhfZmlsZW5hbWUoY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCBjaGFyICpwYXRoKTsKCmV4dGVybiBpbnQgY2hlY2tfZmlsZW5hbWUoY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCBjaGFyICpuYW1lKTsKZXh0ZXJuIHZvaWQgdmVyaWZ5X2ZpbGVuYW1lKGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJICAgIGNvbnN0IGNoYXIgKm5hbWUsCgkJCSAgICBpbnQgZGlhZ25vc2VfbWlzc3BlbHRfcmV2KTsKZXh0ZXJuIHZvaWQgdmVyaWZ5X25vbl9maWxlbmFtZShjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IGNoYXIgKm5hbWUpOwpleHRlcm4gaW50IHBhdGhfaW5zaWRlX3JlcG8oY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCBjaGFyICpwYXRoKTsKCiNkZWZpbmUgSU5JVF9EQl9RVUlFVCAweDAwMDEKI2RlZmluZSBJTklUX0RCX0VYSVNUX09LIDB4MDAwMgoKZXh0ZXJuIGludCBpbml0X2RiKGNvbnN0IGNoYXIgKmdpdF9kaXIsIGNvbnN0IGNoYXIgKnJlYWxfZ2l0X2RpciwKCQkgICBjb25zdCBjaGFyICp0ZW1wbGF0ZV9kaXIsIHVuc2lnbmVkIGludCBmbGFncyk7CgpleHRlcm4gdm9pZCBzYW5pdGl6ZV9zdGRmZHModm9pZCk7CmV4dGVybiBpbnQgZGFlbW9uaXplKHZvaWQpOwoKI2RlZmluZSBhbGxvY19ucih4KSAoKCh4KSsxNikqMy8yKQoKLyoKICogUmVhbGxvYyB0aGUgYnVmZmVyIHBvaW50ZWQgYXQgYnkgdmFyaWFibGUgJ3gnIHNvIHRoYXQgaXQgY2FuIGhvbGQKICogYXQgbGVhc3QgJ25yJyBlbnRyaWVzOyB0aGUgbnVtYmVyIG9mIGVudHJpZXMgY3VycmVudGx5IGFsbG9jYXRlZAogKiBpcyAnYWxsb2MnLCB1c2luZyB0aGUgc3RhbmRhcmQgZ3Jvd2luZyBmYWN0b3IgYWxsb2NfbnIoKSBtYWNyby4KICoKICogRE8gTk9UIFVTRSBhbnkgZXhwcmVzc2lvbiB3aXRoIHNpZGUtZWZmZWN0IGZvciAneCcsICducicsIG9yICdhbGxvYycuCiAqLwojZGVmaW5lIEFMTE9DX0dST1coeCwgbnIsIGFsbG9jKSBcCglkbyB7IFwKCQlpZiAoKG5yKSA+IGFsbG9jKSB7IFwKCQkJaWYgKGFsbG9jX25yKGFsbG9jKSA8IChucikpIFwKCQkJCWFsbG9jID0gKG5yKTsgXAoJCQllbHNlIFwKCQkJCWFsbG9jID0gYWxsb2NfbnIoYWxsb2MpOyBcCgkJCVJFQUxMT0NfQVJSQVkoeCwgYWxsb2MpOyBcCgkJfSBcCgl9IHdoaWxlICgwKQoKLyogSW5pdGlhbGl6ZSBhbmQgdXNlIHRoZSBjYWNoZSBpbmZvcm1hdGlvbiAqLwpzdHJ1Y3QgbG9ja19maWxlOwpleHRlcm4gaW50IHJlYWRfaW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICopOwpleHRlcm4gdm9pZCBwcmVsb2FkX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqaW5kZXgsCgkJCSAgY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwYXRoc3BlYywKCQkJICB1bnNpZ25lZCBpbnQgcmVmcmVzaF9mbGFncyk7CmV4dGVybiBpbnQgcmVhZF9pbmRleF9wcmVsb2FkKHN0cnVjdCBpbmRleF9zdGF0ZSAqLAoJCQkgICAgICBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBhdGhzcGVjLAoJCQkgICAgICB1bnNpZ25lZCBpbnQgcmVmcmVzaF9mbGFncyk7CmV4dGVybiBpbnQgZG9fcmVhZF9pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgY29uc3QgY2hhciAqcGF0aCwKCQkJIGludCBtdXN0X2V4aXN0KTsgLyogZm9yIHRlc3R0aW5nIG9ubHkhICovCmV4dGVybiBpbnQgcmVhZF9pbmRleF9mcm9tKHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBjb25zdCBjaGFyICpwYXRoLAoJCQkgICBjb25zdCBjaGFyICpnaXRkaXIpOwpleHRlcm4gaW50IGlzX2luZGV4X3VuYm9ybihzdHJ1Y3QgaW5kZXhfc3RhdGUgKik7CmV4dGVybiBpbnQgcmVhZF9pbmRleF91bm1lcmdlZChzdHJ1Y3QgaW5kZXhfc3RhdGUgKik7CgovKiBGb3IgdXNlIHdpdGggYHdyaXRlX2xvY2tlZF9pbmRleCgpYC4gKi8KI2RlZmluZSBDT01NSVRfTE9DSwkJKDEgPDwgMCkKI2RlZmluZSBTS0lQX0lGX1VOQ0hBTkdFRAkoMSA8PCAxKQoKLyoKICogV3JpdGUgdGhlIGluZGV4IHdoaWxlIGhvbGRpbmcgYW4gYWxyZWFkeS10YWtlbiBsb2NrLiBDbG9zZSB0aGUgbG9jaywKICogYW5kIGlmIGBDT01NSVRfTE9DS2AgaXMgZ2l2ZW4sIGNvbW1pdCBpdC4KICoKICogVW5sZXNzIGEgc3BsaXQgaW5kZXggaXMgaW4gdXNlLCB3cml0ZSB0aGUgaW5kZXggaW50byB0aGUgbG9ja2ZpbGUuCiAqCiAqIFdpdGggYSBzcGxpdCBpbmRleCwgd3JpdGUgdGhlIHNoYXJlZCBpbmRleCB0byBhIHRlbXBvcmFyeSBmaWxlLAogKiBhZGp1c3QgaXRzIHBlcm1pc3Npb25zIGFuZCByZW5hbWUgaXQgaW50byBwbGFjZSwgdGhlbiB3cml0ZSB0aGUKICogc3BsaXQgaW5kZXggdG8gdGhlIGxvY2tmaWxlLiBJZiB0aGUgdGVtcG9yYXJ5IGZpbGUgZm9yIHRoZSBzaGFyZWQKICogaW5kZXggY2Fubm90IGJlIGNyZWF0ZWQsIGZhbGwgYmFjayB0byB0aGUgYmVoYXZpb3IgZGVzY3JpYmVkIGluCiAqIHRoZSBwcmV2aW91cyBwYXJhZ3JhcGguCiAqCiAqIFdpdGggYENPTU1JVF9MT0NLYCwgdGhlIGxvY2sgaXMgYWx3YXlzIGNvbW1pdHRlZCBvciByb2xsZWQgYmFjay4KICogV2l0aG91dCBpdCwgdGhlIGxvY2sgaXMgY2xvc2VkLCBidXQgbmVpdGhlciBjb21taXR0ZWQgbm9yIHJvbGxlZAogKiBiYWNrLgogKgogKiBJZiBgU0tJUF9JRl9VTkNIQU5HRURgIGlzIGdpdmVuIGFuZCB0aGUgaW5kZXggaXMgdW5jaGFuZ2VkLCBub3RoaW5nCiAqIGlzIHdyaXR0ZW4gKGFuZCB0aGUgbG9jayBpcyByb2xsZWQgYmFjayBpZiBgQ09NTUlUX0xPQ0tgIGlzIGdpdmVuKS4KICovCmV4dGVybiBpbnQgd3JpdGVfbG9ja2VkX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBzdHJ1Y3QgbG9ja19maWxlICpsb2NrLCB1bnNpZ25lZCBmbGFncyk7CgpleHRlcm4gaW50IGRpc2NhcmRfaW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICopOwpleHRlcm4gdm9pZCBtb3ZlX2luZGV4X2V4dGVuc2lvbnMoc3RydWN0IGluZGV4X3N0YXRlICpkc3QsIHN0cnVjdCBpbmRleF9zdGF0ZSAqc3JjKTsKZXh0ZXJuIGludCB1bm1lcmdlZF9pbmRleChjb25zdCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKik7CgovKioKICogUmV0dXJucyAxIGlmIGlzdGF0ZSBkaWZmZXJzIGZyb20gdHJlZSwgMCBvdGhlcndpc2UuICBJZiB0cmVlIGlzIE5VTEwsCiAqIGNvbXBhcmVzIGlzdGF0ZSB0byBIRUFELiAgSWYgdHJlZSBpcyBOVUxMIGFuZCBvbiBhbiB1bmJvcm4gYnJhbmNoLAogKiByZXR1cm5zIDEgaWYgdGhlcmUgYXJlIGVudHJpZXMgaW4gaXN0YXRlLCAwIG90aGVyd2lzZS4gIElmIGFuIHN0cmJ1ZiBpcwogKiBwcm92aWRlZCwgdGhlIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIGZpbGVzIHRoYXQgZGlmZmVyIHdpbGwgYmUgYXBwZW5kZWQKICogdG8gaXQuCiAqLwpleHRlcm4gaW50IGluZGV4X2hhc19jaGFuZ2VzKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLAoJCQkgICAgIHN0cnVjdCB0cmVlICp0cmVlLAoJCQkgICAgIHN0cnVjdCBzdHJidWYgKnNiKTsKCmV4dGVybiBpbnQgdmVyaWZ5X3BhdGgoY29uc3QgY2hhciAqcGF0aCwgdW5zaWduZWQgbW9kZSk7CmV4dGVybiBpbnQgc3RyY21wX29mZnNldChjb25zdCBjaGFyICpzMSwgY29uc3QgY2hhciAqczIsIHNpemVfdCAqZmlyc3RfY2hhbmdlKTsKZXh0ZXJuIGludCBpbmRleF9kaXJfZXhpc3RzKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbik7CmV4dGVybiB2b2lkIGFkanVzdF9kaXJuYW1lX2Nhc2Uoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIGNoYXIgKm5hbWUpOwpleHRlcm4gc3RydWN0IGNhY2hlX2VudHJ5ICppbmRleF9maWxlX2V4aXN0cyhzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgY29uc3QgY2hhciAqbmFtZSwgaW50IG5hbWVsZW4sIGludCBpZ25jYXNlKTsKCi8qCiAqIFNlYXJjaGVzIGZvciBhbiBlbnRyeSBkZWZpbmVkIGJ5IG5hbWUgYW5kIG5hbWVsZW4gaW4gdGhlIGdpdmVuIGluZGV4LgogKiBJZiB0aGUgcmV0dXJuIHZhbHVlIGlzIHBvc2l0aXZlIChpbmNsdWRpbmcgMCkgaXQgaXMgdGhlIHBvc2l0aW9uIG9mIGFuCiAqIGV4YWN0IG1hdGNoLiBJZiB0aGUgcmV0dXJuIHZhbHVlIGlzIG5lZ2F0aXZlLCB0aGUgbmVnYXRlZCB2YWx1ZSBtaW51cyAxCiAqIGlzIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgZW50cnkgd291bGQgYmUgaW5zZXJ0ZWQuCiAqIEV4YW1wbGU6IFRoZSBjdXJyZW50IGluZGV4IGNvbnNpc3RzIG9mIHRoZXNlIGZpbGVzIGFuZCBpdHMgc3RhZ2VzOgogKgogKiAgIGIjMCwgZCMwLCBmIzEsIGYjMwogKgogKiBpbmRleF9uYW1lX3BvcygmaW5kZXgsICJhIiwgMSkgLT4gLTEKICogaW5kZXhfbmFtZV9wb3MoJmluZGV4LCAiYiIsIDEpIC0+ICAwCiAqIGluZGV4X25hbWVfcG9zKCZpbmRleCwgImMiLCAxKSAtPiAtMgogKiBpbmRleF9uYW1lX3BvcygmaW5kZXgsICJkIiwgMSkgLT4gIDEKICogaW5kZXhfbmFtZV9wb3MoJmluZGV4LCAiZSIsIDEpIC0+IC0zCiAqIGluZGV4X25hbWVfcG9zKCZpbmRleCwgImYiLCAxKSAtPiAtMwogKiBpbmRleF9uYW1lX3BvcygmaW5kZXgsICJnIiwgMSkgLT4gLTUKICovCmV4dGVybiBpbnQgaW5kZXhfbmFtZV9wb3MoY29uc3Qgc3RydWN0IGluZGV4X3N0YXRlICosIGNvbnN0IGNoYXIgKm5hbWUsIGludCBuYW1lbGVuKTsKCiNkZWZpbmUgQUREX0NBQ0hFX09LX1RPX0FERCAxCQkvKiBPayB0byBhZGQgKi8KI2RlZmluZSBBRERfQ0FDSEVfT0tfVE9fUkVQTEFDRSAyCS8qIE9rIHRvIHJlcGxhY2UgZmlsZS9kaXJlY3RvcnkgKi8KI2RlZmluZSBBRERfQ0FDSEVfU0tJUF9ERkNIRUNLIDQJLyogT2sgdG8gc2tpcCBERiBjb25mbGljdCBjaGVja3MgKi8KI2RlZmluZSBBRERfQ0FDSEVfSlVTVF9BUFBFTkQgOAkJLyogQXBwZW5kIG9ubHk7IHRyZWUuYzo6cmVhZF90cmVlKCkgKi8KI2RlZmluZSBBRERfQ0FDSEVfTkVXX09OTFkgMTYJCS8qIERvIG5vdCByZXBsYWNlIGV4aXN0aW5nIG9uZXMgKi8KI2RlZmluZSBBRERfQ0FDSEVfS0VFUF9DQUNIRV9UUkVFIDMyCS8qIERvIG5vdCBpbnZhbGlkYXRlIGNhY2hlLXRyZWUgKi8KZXh0ZXJuIGludCBhZGRfaW5kZXhfZW50cnkoc3RydWN0IGluZGV4X3N0YXRlICosIHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIGludCBvcHRpb24pOwpleHRlcm4gdm9pZCByZW5hbWVfaW5kZXhfZW50cnlfYXQoc3RydWN0IGluZGV4X3N0YXRlICosIGludCBwb3MsIGNvbnN0IGNoYXIgKm5ld19uYW1lKTsKCi8qIFJlbW92ZSBlbnRyeSwgcmV0dXJuIHRydWUgaWYgdGhlcmUgYXJlIG1vcmUgZW50cmllcyB0byBnby4gKi8KZXh0ZXJuIGludCByZW1vdmVfaW5kZXhfZW50cnlfYXQoc3RydWN0IGluZGV4X3N0YXRlICosIGludCBwb3MpOwoKZXh0ZXJuIHZvaWQgcmVtb3ZlX21hcmtlZF9jYWNoZV9lbnRyaWVzKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlKTsKZXh0ZXJuIGludCByZW1vdmVfZmlsZV9mcm9tX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBjb25zdCBjaGFyICpwYXRoKTsKI2RlZmluZSBBRERfQ0FDSEVfVkVSQk9TRSAxCiNkZWZpbmUgQUREX0NBQ0hFX1BSRVRFTkQgMgojZGVmaW5lIEFERF9DQUNIRV9JR05PUkVfRVJST1JTCTQKI2RlZmluZSBBRERfQ0FDSEVfSUdOT1JFX1JFTU9WQUwgOAojZGVmaW5lIEFERF9DQUNIRV9JTlRFTlQgMTYKLyoKICogVGhlc2UgdHdvIGFyZSB1c2VkIHRvIGFkZCB0aGUgY29udGVudHMgb2YgdGhlIGZpbGUgYXQgcGF0aAogKiB0byB0aGUgaW5kZXgsIG1hcmtpbmcgdGhlIHdvcmtpbmcgdHJlZSB1cC10by1kYXRlIGJ5IHN0b3JpbmcKICogdGhlIGNhY2hlZCBzdGF0IGluZm8gaW4gdGhlIHJlc3VsdGluZyBjYWNoZSBlbnRyeS4gIEEgY2FsbGVyCiAqIHRoYXQgaGFzIGFscmVhZHkgcnVuIGxzdGF0KDIpIG9uIHRoZSBwYXRoIGNhbiBjYWxsCiAqIGFkZF90b19pbmRleCgpLCBhbmQgYWxsIG90aGVycyBjYW4gY2FsbCBhZGRfZmlsZV90b19pbmRleCgpOwogKiB0aGUgbGF0dGVyIHdpbGwgZG8gbmVjZXNzYXJ5IGxzdGF0KDIpIGludGVybmFsbHkgYmVmb3JlCiAqIGNhbGxpbmcgdGhlIGZvcm1lci4KICovCmV4dGVybiBpbnQgYWRkX3RvX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBjb25zdCBjaGFyICpwYXRoLCBzdHJ1Y3Qgc3RhdCAqLCBpbnQgZmxhZ3MpOwpleHRlcm4gaW50IGFkZF9maWxlX3RvX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBjb25zdCBjaGFyICpwYXRoLCBpbnQgZmxhZ3MpOwoKZXh0ZXJuIGludCBjaG1vZF9pbmRleF9lbnRyeShzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgY2hhciBmbGlwKTsKZXh0ZXJuIGludCBjZV9zYW1lX25hbWUoY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICphLCBjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmIpOwpleHRlcm4gdm9pZCBzZXRfb2JqZWN0X25hbWVfZm9yX2ludGVudF90b19hZGRfZW50cnkoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSk7CmV4dGVybiBpbnQgaW5kZXhfbmFtZV9pc19vdGhlcihjb25zdCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgY29uc3QgY2hhciAqLCBpbnQpOwpleHRlcm4gdm9pZCAqcmVhZF9ibG9iX2RhdGFfZnJvbV9pbmRleChjb25zdCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgY29uc3QgY2hhciAqLCB1bnNpZ25lZCBsb25nICopOwoKLyogZG8gc3RhdCBjb21wYXJpc29uIGV2ZW4gaWYgQ0VfVkFMSUQgaXMgdHJ1ZSAqLwojZGVmaW5lIENFX01BVENIX0lHTk9SRV9WQUxJRAkJMDEKLyogZG8gbm90IGNoZWNrIHRoZSBjb250ZW50cyBidXQgcmVwb3J0IGRpcnR5IG9uIHJhY2lseS1jbGVhbiBlbnRyaWVzICovCiNkZWZpbmUgQ0VfTUFUQ0hfUkFDWV9JU19ESVJUWQkJMDIKLyogZG8gc3RhdCBjb21wYXJpc29uIGV2ZW4gaWYgQ0VfU0tJUF9XT1JLVFJFRSBpcyB0cnVlICovCiNkZWZpbmUgQ0VfTUFUQ0hfSUdOT1JFX1NLSVBfV09SS1RSRUUJMDQKLyogaWdub3JlIG5vbi1leGlzdGVudCBmaWxlcyBkdXJpbmcgc3RhdCB1cGRhdGUgICovCiNkZWZpbmUgQ0VfTUFUQ0hfSUdOT1JFX01JU1NJTkcJCTB4MDgKLyogZW5hYmxlIHN0YXQgcmVmcmVzaCAqLwojZGVmaW5lIENFX01BVENIX1JFRlJFU0gJCTB4MTAKLyogZG9uJ3QgcmVmcmVzaF9mc21vbml0b3Igc3RhdGUgb3IgZG8gc3RhdCBjb21wYXJpc29uIGV2ZW4gaWYgQ0VfRlNNT05JVE9SX1ZBTElEIGlzIHRydWUgKi8KI2RlZmluZSBDRV9NQVRDSF9JR05PUkVfRlNNT05JVE9SIDBYMjAKZXh0ZXJuIGludCBpc19yYWN5X3RpbWVzdGFtcChjb25zdCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwKCQkJICAgICBjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKTsKZXh0ZXJuIGludCBpZV9tYXRjaF9zdGF0KHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKiwgc3RydWN0IHN0YXQgKiwgdW5zaWduZWQgaW50KTsKZXh0ZXJuIGludCBpZV9tb2RpZmllZChzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICosIHN0cnVjdCBzdGF0ICosIHVuc2lnbmVkIGludCk7CgojZGVmaW5lIEhBU0hfV1JJVEVfT0JKRUNUIDEKI2RlZmluZSBIQVNIX0ZPUk1BVF9DSEVDSyAyCiNkZWZpbmUgSEFTSF9SRU5PUk1BTElaRSAgNApleHRlcm4gaW50IGluZGV4X2ZkKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGludCBmZCwgc3RydWN0IHN0YXQgKnN0LCBlbnVtIG9iamVjdF90eXBlIHR5cGUsIGNvbnN0IGNoYXIgKnBhdGgsIHVuc2lnbmVkIGZsYWdzKTsKZXh0ZXJuIGludCBpbmRleF9wYXRoKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGNvbnN0IGNoYXIgKnBhdGgsIHN0cnVjdCBzdGF0ICpzdCwgdW5zaWduZWQgZmxhZ3MpOwoKLyoKICogUmVjb3JkIHRvIHNkIHRoZSBkYXRhIGZyb20gc3QgdGhhdCB3ZSB1c2UgdG8gY2hlY2sgd2hldGhlciBhIGZpbGUKICogbWlnaHQgaGF2ZSBjaGFuZ2VkLgogKi8KZXh0ZXJuIHZvaWQgZmlsbF9zdGF0X2RhdGEoc3RydWN0IHN0YXRfZGF0YSAqc2QsIHN0cnVjdCBzdGF0ICpzdCk7CgovKgogKiBSZXR1cm4gMCBpZiBzdCBpcyBjb25zaXN0ZW50IHdpdGggYSBmaWxlIG5vdCBoYXZpbmcgYmVlbiBjaGFuZ2VkCiAqIHNpbmNlIHNkIHdhcyBmaWxsZWQuICBJZiB0aGVyZSBhcmUgZGlmZmVyZW5jZXMsIHJldHVybiBhCiAqIGNvbWJpbmF0aW9uIG9mIE1USU1FX0NIQU5HRUQsIENUSU1FX0NIQU5HRUQsIE9XTkVSX0NIQU5HRUQsCiAqIElOT0RFX0NIQU5HRUQsIGFuZCBEQVRBX0NIQU5HRUQuCiAqLwpleHRlcm4gaW50IG1hdGNoX3N0YXRfZGF0YShjb25zdCBzdHJ1Y3Qgc3RhdF9kYXRhICpzZCwgc3RydWN0IHN0YXQgKnN0KTsKZXh0ZXJuIGludCBtYXRjaF9zdGF0X2RhdGFfcmFjeShjb25zdCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwKCQkJCWNvbnN0IHN0cnVjdCBzdGF0X2RhdGEgKnNkLCBzdHJ1Y3Qgc3RhdCAqc3QpOwoKZXh0ZXJuIHZvaWQgZmlsbF9zdGF0X2NhY2hlX2luZm8oc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgc3RydWN0IHN0YXQgKnN0KTsKCiNkZWZpbmUgUkVGUkVTSF9SRUFMTFkJCTB4MDAwMQkvKiBpZ25vcmVfdmFsaWQgKi8KI2RlZmluZSBSRUZSRVNIX1VOTUVSR0VECTB4MDAwMgkvKiBhbGxvdyB1bm1lcmdlZCAqLwojZGVmaW5lIFJFRlJFU0hfUVVJRVQJCTB4MDAwNAkvKiBiZSBxdWlldCBhYm91dCBpdCAqLwojZGVmaW5lIFJFRlJFU0hfSUdOT1JFX01JU1NJTkcJMHgwMDA4CS8qIGlnbm9yZSBub24tZXhpc3RlbnQgKi8KI2RlZmluZSBSRUZSRVNIX0lHTk9SRV9TVUJNT0RVTEVTCTB4MDAxMAkvKiBpZ25vcmUgc3VibW9kdWxlcyAqLwojZGVmaW5lIFJFRlJFU0hfSU5fUE9SQ0VMQUlOCTB4MDAyMAkvKiB1c2VyIGZyaWVuZGx5IG91dHB1dCwgbm90ICJuZWVkcyB1cGRhdGUiICovCiNkZWZpbmUgUkVGUkVTSF9QUk9HUkVTUwkweDAwNDAgIC8qIHNob3cgcHJvZ3Jlc3MgYmFyIGlmIHN0ZGVyciBpcyB0dHkgKi8KZXh0ZXJuIGludCByZWZyZXNoX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqLCB1bnNpZ25lZCBpbnQgZmxhZ3MsIGNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcGF0aHNwZWMsIGNoYXIgKnNlZW4sIGNvbnN0IGNoYXIgKmhlYWRlcl9tc2cpOwpleHRlcm4gc3RydWN0IGNhY2hlX2VudHJ5ICpyZWZyZXNoX2NhY2hlX2VudHJ5KHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBzdHJ1Y3QgY2FjaGVfZW50cnkgKiwgdW5zaWduZWQgaW50KTsKCi8qCiAqIE9wcG9ydHVuaXN0aWNhbGx5IHVwZGF0ZSB0aGUgaW5kZXggYnV0IGRvIG5vdCBjb21wbGFpbiBpZiB3ZSBjYW4ndC4KICogVGhlIGxvY2tmaWxlIGlzIGFsd2F5cyBjb21taXR0ZWQgb3Igcm9sbGVkIGJhY2suCiAqLwpleHRlcm4gdm9pZCB1cGRhdGVfaW5kZXhfaWZfYWJsZShzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgc3RydWN0IGxvY2tfZmlsZSAqKTsKCmV4dGVybiBpbnQgaG9sZF9sb2NrZWRfaW5kZXgoc3RydWN0IGxvY2tfZmlsZSAqLCBpbnQpOwpleHRlcm4gdm9pZCBzZXRfYWx0ZXJuYXRlX2luZGV4X291dHB1dChjb25zdCBjaGFyICopOwoKZXh0ZXJuIGludCB2ZXJpZnlfaW5kZXhfY2hlY2tzdW07CmV4dGVybiBpbnQgdmVyaWZ5X2NlX29yZGVyOwoKLyogRW52aXJvbm1lbnQgYml0cyBmcm9tIGNvbmZpZ3VyYXRpb24gbWVjaGFuaXNtICovCmV4dGVybiBpbnQgdHJ1c3RfZXhlY3V0YWJsZV9iaXQ7CmV4dGVybiBpbnQgdHJ1c3RfY3RpbWU7CmV4dGVybiBpbnQgY2hlY2tfc3RhdDsKZXh0ZXJuIGludCBxdW90ZV9wYXRoX2Z1bGx5OwpleHRlcm4gaW50IGhhc19zeW1saW5rczsKZXh0ZXJuIGludCBtaW5pbXVtX2FiYnJldiwgZGVmYXVsdF9hYmJyZXY7CmV4dGVybiBpbnQgaWdub3JlX2Nhc2U7CmV4dGVybiBpbnQgYXNzdW1lX3VuY2hhbmdlZDsKZXh0ZXJuIGludCBwcmVmZXJfc3ltbGlua19yZWZzOwpleHRlcm4gaW50IHdhcm5fYW1iaWd1b3VzX3JlZnM7CmV4dGVybiBpbnQgd2Fybl9vbl9vYmplY3RfcmVmbmFtZV9hbWJpZ3VpdHk7CmV4dGVybiBjb25zdCBjaGFyICphcHBseV9kZWZhdWx0X3doaXRlc3BhY2U7CmV4dGVybiBjb25zdCBjaGFyICphcHBseV9kZWZhdWx0X2lnbm9yZXdoaXRlc3BhY2U7CmV4dGVybiBjb25zdCBjaGFyICpnaXRfYXR0cmlidXRlc19maWxlOwpleHRlcm4gY29uc3QgY2hhciAqZ2l0X2hvb2tzX3BhdGg7CmV4dGVybiBpbnQgemxpYl9jb21wcmVzc2lvbl9sZXZlbDsKZXh0ZXJuIGludCBjb3JlX2NvbXByZXNzaW9uX2xldmVsOwpleHRlcm4gaW50IHBhY2tfY29tcHJlc3Npb25fbGV2ZWw7CmV4dGVybiBzaXplX3QgcGFja2VkX2dpdF93aW5kb3dfc2l6ZTsKZXh0ZXJuIHNpemVfdCBwYWNrZWRfZ2l0X2xpbWl0OwpleHRlcm4gc2l6ZV90IGRlbHRhX2Jhc2VfY2FjaGVfbGltaXQ7CmV4dGVybiB1bnNpZ25lZCBsb25nIGJpZ19maWxlX3RocmVzaG9sZDsKZXh0ZXJuIHVuc2lnbmVkIGxvbmcgcGFja19zaXplX2xpbWl0X2NmZzsKCi8qCiAqIEFjY2Vzc29ycyBmb3IgdGhlIGNvcmUuc2hhcmVkcmVwb3NpdG9yeSBjb25maWcgd2hpY2ggbGF6eS1sb2FkIHRoZSB2YWx1ZQogKiBmcm9tIHRoZSBjb25maWcgKGlmIG5vdCBhbHJlYWR5IHNldCkuIFRoZSAicmVzZXQiIGZ1bmN0aW9uIGNhbiBiZQogKiB1c2VkIHRvIHVuc2V0ICJzZXQiIG9yIGNhY2hlZCB2YWx1ZSwgbWVhbmluZyB0aGF0IHRoZSB2YWx1ZSB3aWxsIGJlIGxvYWRlZAogKiBmcmVzaCBmcm9tIHRoZSBjb25maWcgZmlsZSBvbiB0aGUgbmV4dCBjYWxsIHRvIGdldF9zaGFyZWRfcmVwb3NpdG9yeSgpLgogKi8Kdm9pZCBzZXRfc2hhcmVkX3JlcG9zaXRvcnkoaW50IHZhbHVlKTsKaW50IGdldF9zaGFyZWRfcmVwb3NpdG9yeSh2b2lkKTsKdm9pZCByZXNldF9zaGFyZWRfcmVwb3NpdG9yeSh2b2lkKTsKCi8qCiAqIERvIHJlcGxhY2UgcmVmcyBuZWVkIHRvIGJlIGNoZWNrZWQgdGhpcyBydW4/ICBUaGlzIHZhcmlhYmxlIGlzCiAqIGluaXRpYWxpemVkIHRvIHRydWUgdW5sZXNzIC0tbm8tcmVwbGFjZS1vYmplY3QgaXMgdXNlZCBvcgogKiAkR0lUX05PX1JFUExBQ0VfT0JKRUNUUyBpcyBzZXQsIGJ1dCBpcyBzZXQgdG8gZmFsc2UgYnkgc29tZQogKiBjb21tYW5kcyB0aGF0IGRvIG5vdCB3YW50IHJlcGxhY2UgcmVmZXJlbmNlcyB0byBiZSBhY3RpdmUuCiAqLwpleHRlcm4gaW50IHJlYWRfcmVwbGFjZV9yZWZzOwpleHRlcm4gY2hhciAqZ2l0X3JlcGxhY2VfcmVmX2Jhc2U7CgpleHRlcm4gaW50IGZzeW5jX29iamVjdF9maWxlczsKZXh0ZXJuIGludCBjb3JlX3ByZWxvYWRfaW5kZXg7CmV4dGVybiBpbnQgY29yZV9hcHBseV9zcGFyc2VfY2hlY2tvdXQ7CmV4dGVybiBpbnQgcHJlY29tcG9zZWRfdW5pY29kZTsKZXh0ZXJuIGludCBwcm90ZWN0X2hmczsKZXh0ZXJuIGludCBwcm90ZWN0X250ZnM7CmV4dGVybiBjb25zdCBjaGFyICpjb3JlX2ZzbW9uaXRvcjsKCi8qCiAqIEluY2x1ZGUgYnJva2VuIHJlZnMgaW4gYWxsIHJlZiBpdGVyYXRpb25zLCB3aGljaCB3aWxsCiAqIGdlbmVyYWxseSBjaG9rZSBkYW5nZXJvdXMgb3BlcmF0aW9ucyByYXRoZXIgdGhhbiBsZXR0aW5nCiAqIHRoZW0gc2lsZW50bHkgcHJvY2VlZCB3aXRob3V0IHRha2luZyB0aGUgYnJva2VuIHJlZiBpbnRvCiAqIGFjY291bnQuCiAqLwpleHRlcm4gaW50IHJlZl9wYXJhbm9pYTsKCi8qCiAqIFJldHVybnMgdGhlIGJvb2xlYW4gdmFsdWUgb2YgJEdJVF9PUFRJT05BTF9MT0NLUyAob3IgdGhlIGRlZmF1bHQgdmFsdWUpLgogKi8KaW50IHVzZV9vcHRpb25hbF9sb2Nrcyh2b2lkKTsKCi8qCiAqIFRoZSBjaGFyYWN0ZXIgdGhhdCBiZWdpbnMgYSBjb21tZW50ZWQgbGluZSBpbiB1c2VyLWVkaXRhYmxlIGZpbGUKICogdGhhdCBpcyBzdWJqZWN0IHRvIHN0cmlwc3BhY2UuCiAqLwpleHRlcm4gY2hhciBjb21tZW50X2xpbmVfY2hhcjsKZXh0ZXJuIGludCBhdXRvX2NvbW1lbnRfbGluZV9jaGFyOwoKZW51bSBsb2dfcmVmc19jb25maWcgewoJTE9HX1JFRlNfVU5TRVQgPSAtMSwKCUxPR19SRUZTX05PTkUgPSAwLAoJTE9HX1JFRlNfTk9STUFMLAoJTE9HX1JFRlNfQUxXQVlTCn07CmV4dGVybiBlbnVtIGxvZ19yZWZzX2NvbmZpZyBsb2dfYWxsX3JlZl91cGRhdGVzOwoKZW51bSByZWJhc2Vfc2V0dXBfdHlwZSB7CglBVVRPUkVCQVNFX05FVkVSID0gMCwKCUFVVE9SRUJBU0VfTE9DQUwsCglBVVRPUkVCQVNFX1JFTU9URSwKCUFVVE9SRUJBU0VfQUxXQVlTCn07CgplbnVtIHB1c2hfZGVmYXVsdF90eXBlIHsKCVBVU0hfREVGQVVMVF9OT1RISU5HID0gMCwKCVBVU0hfREVGQVVMVF9NQVRDSElORywKCVBVU0hfREVGQVVMVF9TSU1QTEUsCglQVVNIX0RFRkFVTFRfVVBTVFJFQU0sCglQVVNIX0RFRkFVTFRfQ1VSUkVOVCwKCVBVU0hfREVGQVVMVF9VTlNQRUNJRklFRAp9OwoKZXh0ZXJuIGVudW0gcmViYXNlX3NldHVwX3R5cGUgYXV0b3JlYmFzZTsKZXh0ZXJuIGVudW0gcHVzaF9kZWZhdWx0X3R5cGUgcHVzaF9kZWZhdWx0OwoKZW51bSBvYmplY3RfY3JlYXRpb25fbW9kZSB7CglPQkpFQ1RfQ1JFQVRJT05fVVNFU19IQVJETElOS1MgPSAwLAoJT0JKRUNUX0NSRUFUSU9OX1VTRVNfUkVOQU1FUyA9IDEKfTsKCmV4dGVybiBlbnVtIG9iamVjdF9jcmVhdGlvbl9tb2RlIG9iamVjdF9jcmVhdGlvbl9tb2RlOwoKZXh0ZXJuIGNoYXIgKm5vdGVzX3JlZl9uYW1lOwoKZXh0ZXJuIGludCBncmFmdHNfcmVwbGFjZV9wYXJlbnRzOwoKLyoKICogR0lUX1JFUE9fVkVSU0lPTiBpcyB0aGUgdmVyc2lvbiB3ZSB3cml0ZSBieSBkZWZhdWx0LiBUaGUKICogX1JFQUQgdmFyaWFudCBpcyB0aGUgaGlnaGVzdCBudW1iZXIgd2Uga25vdyBob3cgdG8KICogaGFuZGxlLgogKi8KI2RlZmluZSBHSVRfUkVQT19WRVJTSU9OIDAKI2RlZmluZSBHSVRfUkVQT19WRVJTSU9OX1JFQUQgMQpleHRlcm4gaW50IHJlcG9zaXRvcnlfZm9ybWF0X3ByZWNpb3VzX29iamVjdHM7CmV4dGVybiBjaGFyICpyZXBvc2l0b3J5X2Zvcm1hdF9wYXJ0aWFsX2Nsb25lOwpleHRlcm4gY29uc3QgY2hhciAqY29yZV9wYXJ0aWFsX2Nsb25lX2ZpbHRlcl9kZWZhdWx0OwpleHRlcm4gaW50IHJlcG9zaXRvcnlfZm9ybWF0X3dvcmt0cmVlX2NvbmZpZzsKCnN0cnVjdCByZXBvc2l0b3J5X2Zvcm1hdCB7CglpbnQgdmVyc2lvbjsKCWludCBwcmVjaW91c19vYmplY3RzOwoJY2hhciAqcGFydGlhbF9jbG9uZTsgLyogdmFsdWUgb2YgZXh0ZW5zaW9ucy5wYXJ0aWFsY2xvbmUgKi8KCWludCB3b3JrdHJlZV9jb25maWc7CglpbnQgaXNfYmFyZTsKCWludCBoYXNoX2FsZ287CgljaGFyICp3b3JrX3RyZWU7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgdW5rbm93bl9leHRlbnNpb25zOwp9OwoKLyoKICogUmVhZCB0aGUgcmVwb3NpdG9yeSBmb3JtYXQgY2hhcmFjdGVyaXN0aWNzIGZyb20gdGhlIGNvbmZpZyBmaWxlICJwYXRoIiBpbnRvCiAqICJmb3JtYXQiIHN0cnVjdC4gUmV0dXJucyB0aGUgbnVtZXJpYyB2ZXJzaW9uLiBPbiBlcnJvciwgLTEgaXMgcmV0dXJuZWQsCiAqIGZvcm1hdC0+dmVyc2lvbiBpcyBzZXQgdG8gLTEsIGFuZCBhbGwgb3RoZXIgZmllbGRzIGluIHRoZSBzdHJ1Y3QgYXJlCiAqIHVuZGVmaW5lZC4KICovCmludCByZWFkX3JlcG9zaXRvcnlfZm9ybWF0KHN0cnVjdCByZXBvc2l0b3J5X2Zvcm1hdCAqZm9ybWF0LCBjb25zdCBjaGFyICpwYXRoKTsKCi8qCiAqIFZlcmlmeSB0aGF0IHRoZSByZXBvc2l0b3J5IGRlc2NyaWJlZCBieSByZXBvc2l0b3J5X2Zvcm1hdCBpcyBzb21ldGhpbmcgd2UKICogY2FuIHJlYWQuIElmIGl0IGlzLCByZXR1cm4gMC4gT3RoZXJ3aXNlLCByZXR1cm4gLTEsIGFuZCAiZXJyIiB3aWxsIGRlc2NyaWJlCiAqIGFueSBlcnJvcnMgZW5jb3VudGVyZWQuCiAqLwppbnQgdmVyaWZ5X3JlcG9zaXRvcnlfZm9ybWF0KGNvbnN0IHN0cnVjdCByZXBvc2l0b3J5X2Zvcm1hdCAqZm9ybWF0LAoJCQkgICAgIHN0cnVjdCBzdHJidWYgKmVycik7CgovKgogKiBDaGVjayB0aGUgcmVwb3NpdG9yeSBmb3JtYXQgdmVyc2lvbiBpbiB0aGUgcGF0aCBmb3VuZCBpbiBnZXRfZ2l0X2RpcigpLAogKiBhbmQgZGllIGlmIGl0IGlzIGEgdmVyc2lvbiB3ZSBkb24ndCB1bmRlcnN0YW5kLiBHZW5lcmFsbHkgb25lIHdvdWxkCiAqIHNldF9naXRfZGlyKCkgYmVmb3JlIGNhbGxpbmcgdGhpcywgYW5kIHVzZSBpdCBvbmx5IGZvciAiYXJlIHdlIGluIGEgdmFsaWQKICogcmVwbz8iLgogKi8KZXh0ZXJuIHZvaWQgY2hlY2tfcmVwb3NpdG9yeV9mb3JtYXQodm9pZCk7CgojZGVmaW5lIE1USU1FX0NIQU5HRUQJMHgwMDAxCiNkZWZpbmUgQ1RJTUVfQ0hBTkdFRAkweDAwMDIKI2RlZmluZSBPV05FUl9DSEFOR0VECTB4MDAwNAojZGVmaW5lIE1PREVfQ0hBTkdFRCAgICAweDAwMDgKI2RlZmluZSBJTk9ERV9DSEFOR0VEICAgMHgwMDEwCiNkZWZpbmUgREFUQV9DSEFOR0VEICAgIDB4MDAyMAojZGVmaW5lIFRZUEVfQ0hBTkdFRCAgICAweDAwNDAKCi8qCiAqIFJldHVybiBhbiBhYmJyZXZpYXRlZCBzaGExIHVuaXF1ZSB3aXRoaW4gdGhpcyByZXBvc2l0b3J5J3Mgb2JqZWN0IGRhdGFiYXNlLgogKiBUaGUgcmVzdWx0IHdpbGwgYmUgYXQgbGVhc3QgYGxlbmAgY2hhcmFjdGVycyBsb25nLCBhbmQgd2lsbCBiZSBOVUwKICogdGVybWluYXRlZC4KICoKICogVGhlIG5vbi1gX3JgIHZlcnNpb24gcmV0dXJucyBhIHN0YXRpYyBidWZmZXIgd2hpY2ggcmVtYWlucyB2YWxpZCB1bnRpbCA0CiAqIG1vcmUgY2FsbHMgdG8gZmluZF91bmlxdWVfYWJicmV2IGFyZSBtYWRlLgogKgogKiBUaGUgYF9yYCB2YXJpYW50IHdyaXRlcyB0byBhIGJ1ZmZlciBzdXBwbGllZCBieSB0aGUgY2FsbGVyLCB3aGljaCBtdXN0IGJlIGF0CiAqIGxlYXN0IGBHSVRfTUFYX0hFWFNaICsgMWAgYnl0ZXMuIFRoZSByZXR1cm4gdmFsdWUgaXMgdGhlIG51bWJlciBvZiBieXRlcwogKiB3cml0dGVuIChleGNsdWRpbmcgdGhlIE5VTCB0ZXJtaW5hdG9yKS4KICoKICogTm90ZSB0aGF0IHdoaWxlIHRoaXMgdmVyc2lvbiBhdm9pZHMgdGhlIHN0YXRpYyBidWZmZXIsIGl0IGlzIG5vdCBmdWxseQogKiByZWVudHJhbnQsIGFzIGl0IGNhbGxzIGludG8gb3RoZXIgbm9uLXJlZW50cmFudCBnaXQgY29kZS4KICovCmV4dGVybiBjb25zdCBjaGFyICpmaW5kX3VuaXF1ZV9hYmJyZXYoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBpbnQgbGVuKTsKZXh0ZXJuIGludCBmaW5kX3VuaXF1ZV9hYmJyZXZfcihjaGFyICpoZXgsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgaW50IGxlbik7CgpleHRlcm4gY29uc3QgdW5zaWduZWQgY2hhciBudWxsX3NoYTFbR0lUX01BWF9SQVdTWl07CmV4dGVybiBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkIG51bGxfb2lkOwoKc3RhdGljIGlubGluZSBpbnQgaGFzaGNtcChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGEyKQp7CgkvKgoJICogVGVhY2ggdGhlIGNvbXBpbGVyIHRoYXQgdGhlcmUgYXJlIG9ubHkgdHdvIHBvc3NpYmlsaXRpZXMgb2YgaGFzaCBzaXplCgkgKiBoZXJlLCBzbyB0aGF0IGl0IGNhbiBvcHRpbWl6ZSBmb3IgdGhpcyBjYXNlIGFzIG11Y2ggYXMgcG9zc2libGUuCgkgKi8KCWlmICh0aGVfaGFzaF9hbGdvLT5yYXdzeiA9PSBHSVRfTUFYX1JBV1NaKQoJCXJldHVybiBtZW1jbXAoc2hhMSwgc2hhMiwgR0lUX01BWF9SQVdTWik7CglyZXR1cm4gbWVtY21wKHNoYTEsIHNoYTIsIEdJVF9TSEExX1JBV1NaKTsKfQoKc3RhdGljIGlubGluZSBpbnQgb2lkY21wKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZDEsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZDIpCnsKCXJldHVybiBoYXNoY21wKG9pZDEtPmhhc2gsIG9pZDItPmhhc2gpOwp9CgpzdGF0aWMgaW5saW5lIGludCBoYXNoZXEoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMikKewoJLyoKCSAqIFdlIHdyaXRlIHRoaXMgaGVyZSBpbnN0ZWFkIG9mIGRlZmVycmluZyB0byBoYXNoY21wIHNvIHRoYXQgdGhlCgkgKiBjb21waWxlciBjYW4gcHJvcGVybHkgaW5saW5lIGl0IGFuZCBhdm9pZCBjYWxsaW5nIG1lbWNtcC4KCSAqLwoJaWYgKHRoZV9oYXNoX2FsZ28tPnJhd3N6ID09IEdJVF9NQVhfUkFXU1opCgkJcmV0dXJuICFtZW1jbXAoc2hhMSwgc2hhMiwgR0lUX01BWF9SQVdTWik7CglyZXR1cm4gIW1lbWNtcChzaGExLCBzaGEyLCBHSVRfU0hBMV9SQVdTWik7Cn0KCnN0YXRpYyBpbmxpbmUgaW50IG9pZGVxKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZDEsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZDIpCnsKCXJldHVybiBoYXNoZXEob2lkMS0+aGFzaCwgb2lkMi0+aGFzaCk7Cn0KCnN0YXRpYyBpbmxpbmUgaW50IGlzX251bGxfc2hhMShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglyZXR1cm4gaGFzaGVxKHNoYTEsIG51bGxfc2hhMSk7Cn0KCnN0YXRpYyBpbmxpbmUgaW50IGlzX251bGxfb2lkKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJcmV0dXJuIGhhc2hlcShvaWQtPmhhc2gsIG51bGxfc2hhMSk7Cn0KCnN0YXRpYyBpbmxpbmUgdm9pZCBoYXNoY3B5KHVuc2lnbmVkIGNoYXIgKnNoYV9kc3QsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYV9zcmMpCnsKCW1lbWNweShzaGFfZHN0LCBzaGFfc3JjLCB0aGVfaGFzaF9hbGdvLT5yYXdzeik7Cn0KCnN0YXRpYyBpbmxpbmUgdm9pZCBvaWRjcHkoc3RydWN0IG9iamVjdF9pZCAqZHN0LCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpzcmMpCnsKCW1lbWNweShkc3QtPmhhc2gsIHNyYy0+aGFzaCwgR0lUX01BWF9SQVdTWik7Cn0KCnN0YXRpYyBpbmxpbmUgc3RydWN0IG9iamVjdF9pZCAqb2lkZHVwKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKnNyYykKewoJc3RydWN0IG9iamVjdF9pZCAqZHN0ID0geG1hbGxvYyhzaXplb2Yoc3RydWN0IG9iamVjdF9pZCkpOwoJb2lkY3B5KGRzdCwgc3JjKTsKCXJldHVybiBkc3Q7Cn0KCnN0YXRpYyBpbmxpbmUgdm9pZCBoYXNoY2xyKHVuc2lnbmVkIGNoYXIgKmhhc2gpCnsKCW1lbXNldChoYXNoLCAwLCB0aGVfaGFzaF9hbGdvLT5yYXdzeik7Cn0KCnN0YXRpYyBpbmxpbmUgdm9pZCBvaWRjbHIoc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CgltZW1zZXQob2lkLT5oYXNoLCAwLCBHSVRfTUFYX1JBV1NaKTsKfQoKc3RhdGljIGlubGluZSB2b2lkIG9pZHJlYWQoc3RydWN0IG9iamVjdF9pZCAqb2lkLCBjb25zdCB1bnNpZ25lZCBjaGFyICpoYXNoKQp7CgltZW1jcHkob2lkLT5oYXNoLCBoYXNoLCB0aGVfaGFzaF9hbGdvLT5yYXdzeik7Cn0KCnN0YXRpYyBpbmxpbmUgaW50IGlzX2VtcHR5X2Jsb2Jfc2hhMShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglyZXR1cm4gaGFzaGVxKHNoYTEsIHRoZV9oYXNoX2FsZ28tPmVtcHR5X2Jsb2ItPmhhc2gpOwp9CgpzdGF0aWMgaW5saW5lIGludCBpc19lbXB0eV9ibG9iX29pZChjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXJldHVybiBvaWRlcShvaWQsIHRoZV9oYXNoX2FsZ28tPmVtcHR5X2Jsb2IpOwp9CgpzdGF0aWMgaW5saW5lIGludCBpc19lbXB0eV90cmVlX3NoYTEoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJcmV0dXJuIGhhc2hlcShzaGExLCB0aGVfaGFzaF9hbGdvLT5lbXB0eV90cmVlLT5oYXNoKTsKfQoKc3RhdGljIGlubGluZSBpbnQgaXNfZW1wdHlfdHJlZV9vaWQoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglyZXR1cm4gb2lkZXEob2lkLCB0aGVfaGFzaF9hbGdvLT5lbXB0eV90cmVlKTsKfQoKY29uc3QgY2hhciAqZW1wdHlfdHJlZV9vaWRfaGV4KHZvaWQpOwpjb25zdCBjaGFyICplbXB0eV9ibG9iX29pZF9oZXgodm9pZCk7CgovKiBzZXQgZGVmYXVsdCBwZXJtaXNzaW9ucyBieSBwYXNzaW5nIG1vZGUgYXJndW1lbnRzIHRvIG9wZW4oMikgKi8KaW50IGdpdF9ta3N0ZW1wc19tb2RlKGNoYXIgKnBhdHRlcm4sIGludCBzdWZmaXhfbGVuLCBpbnQgbW9kZSk7CmludCBnaXRfbWtzdGVtcF9tb2RlKGNoYXIgKnBhdHRlcm4sIGludCBtb2RlKTsKCi8qCiAqIE5PVEUgTk9URSBOT1RFISEKICoKICogUEVSTV9VTUFTSywgT0xEX1BFUk1fR1JPVVAgYW5kIE9MRF9QRVJNX0VWRVJZQk9EWSBlbnVtZXJhdGlvbnMgbXVzdAogKiBub3QgYmUgY2hhbmdlZC4gT2xkIHJlcG9zaXRvcmllcyBoYXZlIGNvcmUuc2hhcmVkcmVwb3NpdG9yeSB3cml0dGVuIGluCiAqIG51bWVyaWMgZm9ybWF0LCBhbmQgdGhlcmVmb3JlIHRoZXNlIHZhbHVlcyBhcmUgcHJlc2VydmVkIGZvciBjb21wYXRpYmlsaXR5CiAqIHJlYXNvbnMuCiAqLwplbnVtIHNoYXJlZHJlcG8gewoJUEVSTV9VTUFTSyAgICAgICAgICA9IDAsCglPTERfUEVSTV9HUk9VUCAgICAgID0gMSwKCU9MRF9QRVJNX0VWRVJZQk9EWSAgPSAyLAoJUEVSTV9HUk9VUCAgICAgICAgICA9IDA2NjAsCglQRVJNX0VWRVJZQk9EWSAgICAgID0gMDY2NAp9OwppbnQgZ2l0X2NvbmZpZ19wZXJtKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUpOwppbnQgYWRqdXN0X3NoYXJlZF9wZXJtKGNvbnN0IGNoYXIgKnBhdGgpOwoKLyoKICogQ3JlYXRlIHRoZSBkaXJlY3RvcnkgY29udGFpbmluZyB0aGUgbmFtZWQgcGF0aCwgdXNpbmcgY2FyZSB0byBiZQogKiBzb21ld2hhdCBzYWZlIGFnYWluc3QgcmFjZXMuIFJldHVybiBvbmUgb2YgdGhlIHNjbGRfZXJyb3IgdmFsdWVzIHRvCiAqIGluZGljYXRlIHN1Y2Nlc3MvZmFpbHVyZS4gT24gZXJyb3IsIHNldCBlcnJubyB0byBkZXNjcmliZSB0aGUKICogcHJvYmxlbS4KICoKICogU0NMRF9WQU5JU0hFRCBpbmRpY2F0ZXMgdGhhdCBvbmUgb2YgdGhlIGFuY2VzdG9yIGRpcmVjdG9yaWVzIG9mIHRoZQogKiBwYXRoIGV4aXN0ZWQgYXQgb25lIHBvaW50IGR1cmluZyB0aGUgZnVuY3Rpb24gY2FsbCBhbmQgdGhlbgogKiBzdWRkZW5seSB2YW5pc2hlZCwgcHJvYmFibHkgYmVjYXVzZSBhbm90aGVyIHByb2Nlc3MgcHJ1bmVkIHRoZQogKiBkaXJlY3Rvcnkgd2hpbGUgd2Ugd2VyZSB3b3JraW5nLiAgVG8gYmUgcm9idXN0IGFnYWluc3QgdGhpcyBraW5kIG9mCiAqIHJhY2UsIGNhbGxlcnMgbWlnaHQgd2FudCB0byB0cnkgaW52b2tpbmcgdGhlIGZ1bmN0aW9uIGFnYWluIHdoZW4gaXQKICogcmV0dXJucyBTQ0xEX1ZBTklTSEVELgogKgogKiBzYWZlX2NyZWF0ZV9sZWFkaW5nX2RpcmVjdG9yaWVzKCkgdGVtcG9yYXJpbHkgY2hhbmdlcyBwYXRoIHdoaWxlIGl0CiAqIGlzIHdvcmtpbmcgYnV0IHJlc3RvcmVzIGl0IGJlZm9yZSByZXR1cm5pbmcuCiAqIHNhZmVfY3JlYXRlX2xlYWRpbmdfZGlyZWN0b3JpZXNfY29uc3QoKSBkb2Vzbid0IG1vZGlmeSBwYXRoLCBldmVuCiAqIHRlbXBvcmFyaWx5LgogKi8KZW51bSBzY2xkX2Vycm9yIHsKCVNDTERfT0sgPSAwLAoJU0NMRF9GQUlMRUQgPSAtMSwKCVNDTERfUEVSTVMgPSAtMiwKCVNDTERfRVhJU1RTID0gLTMsCglTQ0xEX1ZBTklTSEVEID0gLTQKfTsKZW51bSBzY2xkX2Vycm9yIHNhZmVfY3JlYXRlX2xlYWRpbmdfZGlyZWN0b3JpZXMoY2hhciAqcGF0aCk7CmVudW0gc2NsZF9lcnJvciBzYWZlX2NyZWF0ZV9sZWFkaW5nX2RpcmVjdG9yaWVzX2NvbnN0KGNvbnN0IGNoYXIgKnBhdGgpOwoKLyoKICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHJhY2Vwcm9vZl9jcmVhdGVfZmlsZSgpLiBUaGlzIGZ1bmN0aW9uIGlzCiAqIGV4cGVjdGVkIHRvIGRvIHNvbWV0aGluZyB0aGF0IG1ha2VzIGRpcm5hbWUocGF0aCkgcGVybWFuZW50IGRlc3BpdGUKICogdGhlIGZhY3QgdGhhdCBvdGhlciBwcm9jZXNzZXMgbWlnaHQgYmUgY2xlYW5pbmcgdXAgZW1wdHkKICogZGlyZWN0b3JpZXMgYXQgdGhlIHNhbWUgdGltZS4gVXN1YWxseSBpdCB3aWxsIGNyZWF0ZSBhIGZpbGUgbmFtZWQKICogcGF0aCwgYnV0IGFsdGVybmF0aXZlbHkgaXQgY291bGQgY3JlYXRlIGFub3RoZXIgZmlsZSBpbiB0aGF0CiAqIGRpcmVjdG9yeSwgb3IgZXZlbiBjaGRpcigpIGludG8gdGhhdCBkaXJlY3RvcnkuIFRoZSBmdW5jdGlvbiBzaG91bGQKICogcmV0dXJuIDAgaWYgdGhlIGFjdGlvbiB3YXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS4gT24gZXJyb3IsIGl0CiAqIHNob3VsZCByZXR1cm4gYSBub256ZXJvIHJlc3VsdCBhbmQgc2V0IGVycm5vLgogKiByYWNlcHJvb2ZfY3JlYXRlX2ZpbGUoKSB0cmVhdHMgdHdvIGVycm5vIHZhbHVlcyBzcGVjaWFsbHk6CiAqCiAqIC0gRU5PRU5UIC0tIGRpcm5hbWUocGF0aCkgZG9lcyBub3QgZXhpc3QuIEluIHRoaXMgY2FzZSwKICogICAgICAgICAgICAgcmFjZXByb29mX2NyZWF0ZV9maWxlKCkgdHJpZXMgY3JlYXRpbmcgZGlybmFtZShwYXRoKQogKiAgICAgICAgICAgICAoYW5kIGFueSBwYXJlbnQgZGlyZWN0b3JpZXMsIGlmIG5lY2Vzc2FyeSkgYW5kIGNhbGxzCiAqICAgICAgICAgICAgIHRoZSBmdW5jdGlvbiBhZ2Fpbi4KICoKICogLSBFSVNESVIgLS0gdGhlIGZpbGUgYWxyZWFkeSBleGlzdHMgYW5kIGlzIGEgZGlyZWN0b3J5LiBJbiB0aGlzCiAqICAgICAgICAgICAgIGNhc2UsIHJhY2Vwcm9vZl9jcmVhdGVfZmlsZSgpIHJlbW92ZXMgdGhlIGRpcmVjdG9yeSBpZgogKiAgICAgICAgICAgICBpdCBpcyBlbXB0eSAoYW5kIHJlY3Vyc2l2ZWx5IGFueSBlbXB0eSBkaXJlY3RvcmllcyB0aGF0CiAqICAgICAgICAgICAgIGl0IGNvbnRhaW5zKSBhbmQgY2FsbHMgdGhlIGZ1bmN0aW9uIGFnYWluLgogKgogKiBBbnkgb3RoZXIgZXJybm8gY2F1c2VzIHJhY2Vwcm9vZl9jcmVhdGVfZmlsZSgpIHRvIGZhaWwgd2l0aCB0aGUKICogY2FsbGJhY2sncyByZXR1cm4gdmFsdWUgYW5kIGVycm5vLgogKgogKiBPYnZpb3VzbHksIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIE9LIHdpdGggYmVpbmcgY2FsbGVkIGFnYWluIGlmIGl0CiAqIGZhaWxzIHdpdGggRU5PRU5UIG9yIEVJU0RJUi4gSW4gb3RoZXIgc2NlbmFyaW9zIGl0IHdpbGwgbm90IGJlCiAqIGNhbGxlZCBhZ2Fpbi4KICovCnR5cGVkZWYgaW50IGNyZWF0ZV9maWxlX2ZuKGNvbnN0IGNoYXIgKnBhdGgsIHZvaWQgKmNiKTsKCi8qCiAqIENyZWF0ZSBhIGZpbGUgaW4gZGlybmFtZShwYXRoKSBieSBjYWxsaW5nIGZuLCBjcmVhdGluZyBsZWFkaW5nCiAqIGRpcmVjdG9yaWVzIGlmIG5lY2Vzc2FyeS4gUmV0cnkgYSBmZXcgdGltZXMgaW4gY2FzZSB3ZSBhcmUgcmFjaW5nCiAqIHdpdGggYW5vdGhlciBwcm9jZXNzIHRoYXQgaXMgdHJ5aW5nIHRvIGNsZWFuIHVwIHRoZSBkaXJlY3RvcnkgdGhhdAogKiBjb250YWlucyBwYXRoLiBTZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIGNyZWF0ZV9maWxlX2ZuIGZvciBtb3JlCiAqIGRldGFpbHMuCiAqCiAqIFJldHVybiB0aGUgdmFsdWUgYW5kIHNldCB0aGUgZXJybm8gdGhhdCByZXN1bHRlZCBmcm9tIHRoZSBtb3N0CiAqIHJlY2VudCBjYWxsIG9mIGZuLiBmbiBpcyBhbHdheXMgY2FsbGVkIGF0IGxlYXN0IG9uY2UsIGFuZCB3aWxsIGJlCiAqIGNhbGxlZCBtb3JlIHRoYW4gb25jZSBpZiBpdCByZXR1cm5zIEVOT0VOVCBvciBFSVNESVIuCiAqLwppbnQgcmFjZXByb29mX2NyZWF0ZV9maWxlKGNvbnN0IGNoYXIgKnBhdGgsIGNyZWF0ZV9maWxlX2ZuIGZuLCB2b2lkICpjYik7CgppbnQgbWtkaXJfaW5fZ2l0ZGlyKGNvbnN0IGNoYXIgKnBhdGgpOwpleHRlcm4gY2hhciAqZXhwYW5kX3VzZXJfcGF0aChjb25zdCBjaGFyICpwYXRoLCBpbnQgcmVhbF9ob21lKTsKY29uc3QgY2hhciAqZW50ZXJfcmVwbyhjb25zdCBjaGFyICpwYXRoLCBpbnQgc3RyaWN0KTsKc3RhdGljIGlubGluZSBpbnQgaXNfYWJzb2x1dGVfcGF0aChjb25zdCBjaGFyICpwYXRoKQp7CglyZXR1cm4gaXNfZGlyX3NlcChwYXRoWzBdKSB8fCBoYXNfZG9zX2RyaXZlX3ByZWZpeChwYXRoKTsKfQppbnQgaXNfZGlyZWN0b3J5KGNvbnN0IGNoYXIgKik7CmNoYXIgKnN0cmJ1Zl9yZWFscGF0aChzdHJ1Y3Qgc3RyYnVmICpyZXNvbHZlZCwgY29uc3QgY2hhciAqcGF0aCwKCQkgICAgICBpbnQgZGllX29uX2Vycm9yKTsKY29uc3QgY2hhciAqcmVhbF9wYXRoKGNvbnN0IGNoYXIgKnBhdGgpOwpjb25zdCBjaGFyICpyZWFsX3BhdGhfaWZfdmFsaWQoY29uc3QgY2hhciAqcGF0aCk7CmNoYXIgKnJlYWxfcGF0aGR1cChjb25zdCBjaGFyICpwYXRoLCBpbnQgZGllX29uX2Vycm9yKTsKY29uc3QgY2hhciAqYWJzb2x1dGVfcGF0aChjb25zdCBjaGFyICpwYXRoKTsKY2hhciAqYWJzb2x1dGVfcGF0aGR1cChjb25zdCBjaGFyICpwYXRoKTsKY29uc3QgY2hhciAqcmVtb3ZlX2xlYWRpbmdfcGF0aChjb25zdCBjaGFyICppbiwgY29uc3QgY2hhciAqcHJlZml4KTsKY29uc3QgY2hhciAqcmVsYXRpdmVfcGF0aChjb25zdCBjaGFyICppbiwgY29uc3QgY2hhciAqcHJlZml4LCBzdHJ1Y3Qgc3RyYnVmICpzYik7CmludCBub3JtYWxpemVfcGF0aF9jb3B5X2xlbihjaGFyICpkc3QsIGNvbnN0IGNoYXIgKnNyYywgaW50ICpwcmVmaXhfbGVuKTsKaW50IG5vcm1hbGl6ZV9wYXRoX2NvcHkoY2hhciAqZHN0LCBjb25zdCBjaGFyICpzcmMpOwppbnQgbG9uZ2VzdF9hbmNlc3Rvcl9sZW5ndGgoY29uc3QgY2hhciAqcGF0aCwgc3RydWN0IHN0cmluZ19saXN0ICpwcmVmaXhlcyk7CmNoYXIgKnN0cmlwX3BhdGhfc3VmZml4KGNvbnN0IGNoYXIgKnBhdGgsIGNvbnN0IGNoYXIgKnN1ZmZpeCk7CmludCBkYWVtb25fYXZvaWRfYWxpYXMoY29uc3QgY2hhciAqcGF0aCk7CgovKgogKiBUaGVzZSBmdW5jdGlvbnMgbWF0Y2ggdGhlaXIgaXNfaGZzX2RvdGdpdCgpIGNvdW50ZXJwYXJ0czsgc2VlIHV0ZjguaCBmb3IKICogZGV0YWlscy4KICovCmludCBpc19udGZzX2RvdGdpdChjb25zdCBjaGFyICpuYW1lKTsKaW50IGlzX250ZnNfZG90Z2l0bW9kdWxlcyhjb25zdCBjaGFyICpuYW1lKTsKaW50IGlzX250ZnNfZG90Z2l0aWdub3JlKGNvbnN0IGNoYXIgKm5hbWUpOwppbnQgaXNfbnRmc19kb3RnaXRhdHRyaWJ1dGVzKGNvbnN0IGNoYXIgKm5hbWUpOwoKLyoKICogUmV0dXJucyB0cnVlIGlmZiAic3RyIiBjb3VsZCBiZSBjb25mdXNlZCBhcyBhIGNvbW1hbmQtbGluZSBvcHRpb24gd2hlbgogKiBwYXNzZWQgdG8gYSBzdWItcHJvZ3JhbSBsaWtlICJzc2giLiBOb3RlIHRoYXQgdGhpcyBoYXMgbm90aGluZyB0byBkbyB3aXRoCiAqIHNoZWxsLXF1b3RpbmcsIHdoaWNoIHNob3VsZCBiZSBoYW5kbGVkIHNlcGFyYXRlbHk7IHdlJ3JlIGFzc3VtaW5nIGhlcmUgdGhhdAogKiB0aGUgc3RyaW5nIG1ha2VzIGl0IHZlcmJhdGltIHRvIHRoZSBzdWItcHJvZ3JhbS4KICovCmludCBsb29rc19saWtlX2NvbW1hbmRfbGluZV9vcHRpb24oY29uc3QgY2hhciAqc3RyKTsKCi8qKgogKiBSZXR1cm4gYSBuZXdseSBhbGxvY2F0ZWQgc3RyaW5nIHdpdGggdGhlIGV2YWx1YXRpb24gb2YKICogIiRYREdfQ09ORklHX0hPTUUvZ2l0LyRmaWxlbmFtZSIgaWYgJFhER19DT05GSUdfSE9NRSBpcyBub24tZW1wdHksIG90aGVyd2lzZQogKiAiJEhPTUUvLmNvbmZpZy9naXQvJGZpbGVuYW1lIi4gUmV0dXJuIE5VTEwgdXBvbiBlcnJvci4KICovCmV4dGVybiBjaGFyICp4ZGdfY29uZmlnX2hvbWUoY29uc3QgY2hhciAqZmlsZW5hbWUpOwoKLyoqCiAqIFJldHVybiBhIG5ld2x5IGFsbG9jYXRlZCBzdHJpbmcgd2l0aCB0aGUgZXZhbHVhdGlvbiBvZgogKiAiJFhER19DQUNIRV9IT01FL2dpdC8kZmlsZW5hbWUiIGlmICRYREdfQ0FDSEVfSE9NRSBpcyBub24tZW1wdHksIG90aGVyd2lzZQogKiAiJEhPTUUvLmNhY2hlL2dpdC8kZmlsZW5hbWUiLiBSZXR1cm4gTlVMTCB1cG9uIGVycm9yLgogKi8KZXh0ZXJuIGNoYXIgKnhkZ19jYWNoZV9ob21lKGNvbnN0IGNoYXIgKmZpbGVuYW1lKTsKCmV4dGVybiBpbnQgZ2l0X29wZW5fY2xvZXhlYyhjb25zdCBjaGFyICpuYW1lLCBpbnQgZmxhZ3MpOwojZGVmaW5lIGdpdF9vcGVuKG5hbWUpIGdpdF9vcGVuX2Nsb2V4ZWMobmFtZSwgT19SRE9OTFkpCmV4dGVybiBpbnQgdW5wYWNrX3NoYTFfaGVhZGVyKGdpdF96c3RyZWFtICpzdHJlYW0sIHVuc2lnbmVkIGNoYXIgKm1hcCwgdW5zaWduZWQgbG9uZyBtYXBzaXplLCB2b2lkICpidWZmZXIsIHVuc2lnbmVkIGxvbmcgYnVmc2l6KTsKZXh0ZXJuIGludCBwYXJzZV9zaGExX2hlYWRlcihjb25zdCBjaGFyICpoZHIsIHVuc2lnbmVkIGxvbmcgKnNpemVwKTsKCmV4dGVybiBpbnQgY2hlY2tfb2JqZWN0X3NpZ25hdHVyZShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIHZvaWQgKmJ1ZiwgdW5zaWduZWQgbG9uZyBzaXplLCBjb25zdCBjaGFyICp0eXBlKTsKCmV4dGVybiBpbnQgZmluYWxpemVfb2JqZWN0X2ZpbGUoY29uc3QgY2hhciAqdG1wZmlsZSwgY29uc3QgY2hhciAqZmlsZW5hbWUpOwoKLyogSGVscGVyIHRvIGNoZWNrIGFuZCAidG91Y2giIGEgZmlsZSAqLwpleHRlcm4gaW50IGNoZWNrX2FuZF9mcmVzaGVuX2ZpbGUoY29uc3QgY2hhciAqZm4sIGludCBmcmVzaGVuKTsKCmV4dGVybiBjb25zdCBzaWduZWQgY2hhciBoZXh2YWxfdGFibGVbMjU2XTsKc3RhdGljIGlubGluZSB1bnNpZ25lZCBpbnQgaGV4dmFsKHVuc2lnbmVkIGNoYXIgYykKewoJcmV0dXJuIGhleHZhbF90YWJsZVtjXTsKfQoKLyoKICogQ29udmVydCB0d28gY29uc2VjdXRpdmUgaGV4YWRlY2ltYWwgZGlnaXRzIGludG8gYSBjaGFyLiAgUmV0dXJuIGEKICogbmVnYXRpdmUgdmFsdWUgb24gZXJyb3IuICBEb24ndCBydW4gb3ZlciB0aGUgZW5kIG9mIHNob3J0IHN0cmluZ3MuCiAqLwpzdGF0aWMgaW5saW5lIGludCBoZXgyY2hyKGNvbnN0IGNoYXIgKnMpCnsKCXVuc2lnbmVkIGludCB2YWwgPSBoZXh2YWwoc1swXSk7CglyZXR1cm4gKHZhbCAmIH4weGYpID8gdmFsIDogKHZhbCA8PCA0KSB8IGhleHZhbChzWzFdKTsKfQoKLyogQ29udmVydCB0by9mcm9tIGhleC9zaGExIHJlcHJlc2VudGF0aW9uICovCiNkZWZpbmUgTUlOSU1VTV9BQkJSRVYgbWluaW11bV9hYmJyZXYKI2RlZmluZSBERUZBVUxUX0FCQlJFViBkZWZhdWx0X2FiYnJldgoKLyogdXNlZCB3aGVuIHRoZSBjb2RlIGRvZXMgbm90IGtub3cgb3IgY2FyZSB3aGF0IHRoZSBkZWZhdWx0IGFiYnJldiBpcyAqLwojZGVmaW5lIEZBTExCQUNLX0RFRkFVTFRfQUJCUkVWIDcKCnN0cnVjdCBvYmplY3RfY29udGV4dCB7Cgl1bnNpZ25lZCBtb2RlOwoJLyoKCSAqIHN5bWxpbmtfcGF0aCBpcyBvbmx5IHVzZWQgYnkgZ2V0X3RyZWVfZW50cnlfZm9sbG93X3N5bWxpbmtzLAoJICogYW5kIG9ubHkgZm9yIHN5bWxpbmtzIHRoYXQgcG9pbnQgb3V0c2lkZSB0aGUgcmVwb3NpdG9yeS4KCSAqLwoJc3RydWN0IHN0cmJ1ZiBzeW1saW5rX3BhdGg7CgkvKgoJICogSWYgR0VUX09JRF9SRUNPUkRfUEFUSCBpcyBzZXQsIHRoaXMgd2lsbCByZWNvcmQgcGF0aCAoaWYgYW55KQoJICogZm91bmQgd2hlbiByZXNvbHZpbmcgdGhlIG5hbWUuIFRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yCgkgKiByZWxlYXNpbmcgdGhlIG1lbW9yeS4KCSAqLwoJY2hhciAqcGF0aDsKfTsKCiNkZWZpbmUgR0VUX09JRF9RVUlFVExZICAgICAgICAgICAwMQojZGVmaW5lIEdFVF9PSURfQ09NTUlUICAgICAgICAgICAgMDIKI2RlZmluZSBHRVRfT0lEX0NPTU1JVFRJU0ggICAgICAgIDA0CiNkZWZpbmUgR0VUX09JRF9UUkVFICAgICAgICAgICAgIDAxMAojZGVmaW5lIEdFVF9PSURfVFJFRUlTSCAgICAgICAgICAwMjAKI2RlZmluZSBHRVRfT0lEX0JMT0IgICAgICAgICAgICAgMDQwCiNkZWZpbmUgR0VUX09JRF9GT0xMT1dfU1lNTElOS1MgMDEwMAojZGVmaW5lIEdFVF9PSURfUkVDT1JEX1BBVEggICAgIDAyMDAKI2RlZmluZSBHRVRfT0lEX09OTFlfVE9fRElFICAgIDA0MDAwCgojZGVmaW5lIEdFVF9PSURfRElTQU1CSUdVQVRPUlMgXAoJKEdFVF9PSURfQ09NTUlUIHwgR0VUX09JRF9DT01NSVRUSVNIIHwgXAoJR0VUX09JRF9UUkVFIHwgR0VUX09JRF9UUkVFSVNIIHwgXAoJR0VUX09JRF9CTE9CKQoKZXh0ZXJuIGludCBnZXRfb2lkKGNvbnN0IGNoYXIgKnN0ciwgc3RydWN0IG9iamVjdF9pZCAqb2lkKTsKZXh0ZXJuIGludCBnZXRfb2lkX2NvbW1pdChjb25zdCBjaGFyICpzdHIsIHN0cnVjdCBvYmplY3RfaWQgKm9pZCk7CmV4dGVybiBpbnQgZ2V0X29pZF9jb21taXR0aXNoKGNvbnN0IGNoYXIgKnN0ciwgc3RydWN0IG9iamVjdF9pZCAqb2lkKTsKZXh0ZXJuIGludCBnZXRfb2lkX3RyZWUoY29uc3QgY2hhciAqc3RyLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpOwpleHRlcm4gaW50IGdldF9vaWRfdHJlZWlzaChjb25zdCBjaGFyICpzdHIsIHN0cnVjdCBvYmplY3RfaWQgKm9pZCk7CmV4dGVybiBpbnQgZ2V0X29pZF9ibG9iKGNvbnN0IGNoYXIgKnN0ciwgc3RydWN0IG9iamVjdF9pZCAqb2lkKTsKZXh0ZXJuIHZvaWQgbWF5YmVfZGllX29uX21pc3NwZWx0X29iamVjdF9uYW1lKGNvbnN0IGNoYXIgKm5hbWUsIGNvbnN0IGNoYXIgKnByZWZpeCk7CmV4dGVybiBpbnQgZ2V0X29pZF93aXRoX2NvbnRleHQoY29uc3QgY2hhciAqc3RyLCB1bnNpZ25lZCBmbGFncywgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBzdHJ1Y3Qgb2JqZWN0X2NvbnRleHQgKm9jKTsKCgp0eXBlZGVmIGludCBlYWNoX2FiYnJldl9mbihjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIHZvaWQgKik7CmV4dGVybiBpbnQgZm9yX2VhY2hfYWJicmV2KGNvbnN0IGNoYXIgKnByZWZpeCwgZWFjaF9hYmJyZXZfZm4sIHZvaWQgKik7CgpleHRlcm4gaW50IHNldF9kaXNhbWJpZ3VhdGVfaGludF9jb25maWcoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSk7CgovKgogKiBUcnkgdG8gcmVhZCBhIFNIQTEgaW4gaGV4YWRlY2ltYWwgZm9ybWF0IGZyb20gdGhlIDQwIGNoYXJhY3RlcnMKICogc3RhcnRpbmcgYXQgaGV4LiAgV3JpdGUgdGhlIDIwLWJ5dGUgcmVzdWx0IHRvIHNoYTEgaW4gYmluYXJ5IGZvcm0uCiAqIFJldHVybiAwIG9uIHN1Y2Nlc3MuICBSZWFkaW5nIHN0b3BzIGlmIGEgTlVMIGlzIGVuY291bnRlcmVkIGluIHRoZQogKiBpbnB1dCwgc28gaXQgaXMgc2FmZSB0byBwYXNzIHRoaXMgZnVuY3Rpb24gYW4gYXJiaXRyYXJ5CiAqIG51bGwtdGVybWluYXRlZCBzdHJpbmcuCiAqLwpleHRlcm4gaW50IGdldF9zaGExX2hleChjb25zdCBjaGFyICpoZXgsIHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpleHRlcm4gaW50IGdldF9vaWRfaGV4KGNvbnN0IGNoYXIgKmhleCwgc3RydWN0IG9iamVjdF9pZCAqc2hhMSk7CgovKgogKiBSZWFkIGBsZW5gIHBhaXJzIG9mIGhleGFkZWNpbWFsIGRpZ2l0cyBmcm9tIGBoZXhgIGFuZCB3cml0ZSB0aGUKICogdmFsdWVzIHRvIGBiaW5hcnlgIGFzIGBsZW5gIGJ5dGVzLiBSZXR1cm4gMCBvbiBzdWNjZXNzLCBvciAtMSBpZgogKiB0aGUgaW5wdXQgZG9lcyBub3QgY29uc2lzdCBvZiBoZXggZGlnaXRzKS4KICovCmV4dGVybiBpbnQgaGV4X3RvX2J5dGVzKHVuc2lnbmVkIGNoYXIgKmJpbmFyeSwgY29uc3QgY2hhciAqaGV4LCBzaXplX3QgbGVuKTsKCi8qCiAqIENvbnZlcnQgYSBiaW5hcnkgaGFzaCB0byBpdHMgaGV4IGVxdWl2YWxlbnQuIFRoZSBgX3JgIHZhcmlhbnQgaXMgcmVlbnRyYW50LAogKiBhbmQgd3JpdGVzIHRoZSBOVUwtdGVybWluYXRlZCBvdXRwdXQgdG8gdGhlIGJ1ZmZlciBgb3V0YCwgd2hpY2ggbXVzdCBiZSBhdAogKiBsZWFzdCBgR0lUX01BWF9IRVhTWiArIDFgIGJ5dGVzLCBhbmQgcmV0dXJucyBhIHBvaW50ZXIgdG8gb3V0IGZvcgogKiBjb252ZW5pZW5jZS4KICoKICogVGhlIG5vbi1gX3JgIHZhcmlhbnQgcmV0dXJucyBhIHN0YXRpYyBidWZmZXIsIGJ1dCB1c2VzIGEgcmluZyBvZiA0CiAqIGJ1ZmZlcnMsIG1ha2luZyBpdCBzYWZlIHRvIG1ha2UgbXVsdGlwbGUgY2FsbHMgZm9yIGEgc2luZ2xlIHN0YXRlbWVudCwgbGlrZToKICoKICogICBwcmludGYoIiVzIC0+ICVzIiwgc2hhMV90b19oZXgob25lKSwgc2hhMV90b19oZXgodHdvKSk7CiAqLwpjaGFyICpoYXNoX3RvX2hleF9hbGdvcF9yKGNoYXIgKmJ1ZmZlciwgY29uc3QgdW5zaWduZWQgY2hhciAqaGFzaCwgY29uc3Qgc3RydWN0IGdpdF9oYXNoX2FsZ28gKik7CmNoYXIgKnNoYTFfdG9faGV4X3IoY2hhciAqb3V0LCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKTsKY2hhciAqb2lkX3RvX2hleF9yKGNoYXIgKm91dCwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKTsKY2hhciAqaGFzaF90b19oZXhfYWxnb3AoY29uc3QgdW5zaWduZWQgY2hhciAqaGFzaCwgY29uc3Qgc3RydWN0IGdpdF9oYXNoX2FsZ28gKik7CS8qIHN0YXRpYyBidWZmZXIgcmVzdWx0ISAqLwpjaGFyICpzaGExX3RvX2hleChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKTsJCQkJCQkvKiBzYW1lIHN0YXRpYyBidWZmZXIgKi8KY2hhciAqaGFzaF90b19oZXgoY29uc3QgdW5zaWduZWQgY2hhciAqaGFzaCk7CQkJCQkJLyogc2FtZSBzdGF0aWMgYnVmZmVyICovCmNoYXIgKm9pZF90b19oZXgoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKTsJCQkJCQkvKiBzYW1lIHN0YXRpYyBidWZmZXIgKi8KCi8qCiAqIFBhcnNlIGEgNDAtY2hhcmFjdGVyIGhleGFkZWNpbWFsIG9iamVjdCBJRCBzdGFydGluZyBmcm9tIGhleCwgdXBkYXRpbmcgdGhlCiAqIHBvaW50ZXIgc3BlY2lmaWVkIGJ5IGVuZCB3aGVuIHBhcnNpbmcgc3RvcHMuICBUaGUgcmVzdWx0aW5nIG9iamVjdCBJRCBpcwogKiBzdG9yZWQgaW4gb2lkLiAgUmV0dXJucyAwIG9uIHN1Y2Nlc3MuICBQYXJzaW5nIHdpbGwgc3RvcCBvbiB0aGUgZmlyc3QgTlVMIG9yCiAqIG90aGVyIGludmFsaWQgY2hhcmFjdGVyLiAgZW5kIGlzIG9ubHkgdXBkYXRlZCBvbiBzdWNjZXNzOyBvdGhlcndpc2UsIGl0IGlzCiAqIHVubW9kaWZpZWQuCiAqLwpleHRlcm4gaW50IHBhcnNlX29pZF9oZXgoY29uc3QgY2hhciAqaGV4LCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGNvbnN0IGNoYXIgKiplbmQpOwoKLyoKICogVGhpcyByZWFkcyBzaG9ydC1oYW5kIHN5bnRheCB0aGF0IG5vdCBvbmx5IGV2YWx1YXRlcyB0byBhIGNvbW1pdAogKiBvYmplY3QgbmFtZSwgYnV0IGFsc28gY2FuIGFjdCBhcyBpZiB0aGUgZW5kIHVzZXIgc3BlbGxlZCB0aGUgbmFtZQogKiBvZiB0aGUgYnJhbmNoIGZyb20gdGhlIGNvbW1hbmQgbGluZS4KICoKICogLSAiQHstTn0iIGZpbmRzIHRoZSBuYW1lIG9mIHRoZSBOdGggcHJldmlvdXMgYnJhbmNoIHdlIHdlcmUgb24sIGFuZAogKiAgIHBsYWNlcyB0aGUgbmFtZSBvZiB0aGUgYnJhbmNoIGluIHRoZSBnaXZlbiBidWYgYW5kIHJldHVybnMgdGhlCiAqICAgbnVtYmVyIG9mIGNoYXJhY3RlcnMgcGFyc2VkIGlmIHN1Y2Nlc3NmdWwuCiAqCiAqIC0gIjxicmFuY2g+QHt1cHN0cmVhbX0iIGZpbmRzIHRoZSBuYW1lIG9mIHRoZSBvdGhlciByZWYgdGhhdAogKiAgIDxicmFuY2g+IGlzIGNvbmZpZ3VyZWQgdG8gbWVyZ2Ugd2l0aCAobWlzc2luZyA8YnJhbmNoPiBkZWZhdWx0cwogKiAgIHRvIHRoZSBjdXJyZW50IGJyYW5jaCksIGFuZCBwbGFjZXMgdGhlIG5hbWUgb2YgdGhlIGJyYW5jaCBpbiB0aGUKICogICBnaXZlbiBidWYgYW5kIHJldHVybnMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHBhcnNlZCBpZgogKiAgIHN1Y2Nlc3NmdWwuCiAqCiAqIElmIHRoZSBpbnB1dCBpcyBub3Qgb2YgdGhlIGFjY2VwdGVkIGZvcm1hdCwgaXQgcmV0dXJucyBhIG5lZ2F0aXZlCiAqIG51bWJlciB0byBzaWduYWwgYW4gZXJyb3IuCiAqCiAqIElmIHRoZSBpbnB1dCB3YXMgb2sgYnV0IHRoZXJlIGFyZSBub3QgTiBicmFuY2ggc3dpdGNoZXMgaW4gdGhlCiAqIHJlZmxvZywgaXQgcmV0dXJucyAwLgogKgogKiBJZiAiYWxsb3dlZCIgaXMgbm9uLXplcm8sIGl0IGlzIGEgdHJlYXRlZCBhcyBhIGJpdGZpZWxkIG9mIGFsbG93YWJsZQogKiBleHBhbnNpb25zOiBsb2NhbCBicmFuY2hlcyAoInJlZnMvaGVhZHMvIiksIHJlbW90ZSBicmFuY2hlcwogKiAoInJlZnMvcmVtb3Rlcy8iKSwgb3IgIkhFQUQiLiBJZiBubyAiYWxsb3dlZCIgYml0cyBhcmUgc2V0LCBhbnkgZXhwYW5zaW9uIGlzCiAqIGFsbG93ZWQsIGV2ZW4gb25lcyB0byByZWZzIG91dHNpZGUgb2YgdGhvc2UgbmFtZXNwYWNlcy4KICovCiNkZWZpbmUgSU5URVJQUkVUX0JSQU5DSF9MT0NBTCAoMTw8MCkKI2RlZmluZSBJTlRFUlBSRVRfQlJBTkNIX1JFTU9URSAoMTw8MSkKI2RlZmluZSBJTlRFUlBSRVRfQlJBTkNIX0hFQUQgKDE8PDIpCmV4dGVybiBpbnQgaW50ZXJwcmV0X2JyYW5jaF9uYW1lKGNvbnN0IGNoYXIgKnN0ciwgaW50IGxlbiwgc3RydWN0IHN0cmJ1ZiAqLAoJCQkJIHVuc2lnbmVkIGFsbG93ZWQpOwpleHRlcm4gaW50IGdldF9vaWRfbWIoY29uc3QgY2hhciAqc3RyLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpOwoKZXh0ZXJuIGludCB2YWxpZGF0ZV9oZWFkcmVmKGNvbnN0IGNoYXIgKnJlZik7CgpleHRlcm4gaW50IGJhc2VfbmFtZV9jb21wYXJlKGNvbnN0IGNoYXIgKm5hbWUxLCBpbnQgbGVuMSwgaW50IG1vZGUxLCBjb25zdCBjaGFyICpuYW1lMiwgaW50IGxlbjIsIGludCBtb2RlMik7CmV4dGVybiBpbnQgZGZfbmFtZV9jb21wYXJlKGNvbnN0IGNoYXIgKm5hbWUxLCBpbnQgbGVuMSwgaW50IG1vZGUxLCBjb25zdCBjaGFyICpuYW1lMiwgaW50IGxlbjIsIGludCBtb2RlMik7CmV4dGVybiBpbnQgbmFtZV9jb21wYXJlKGNvbnN0IGNoYXIgKm5hbWUxLCBzaXplX3QgbGVuMSwgY29uc3QgY2hhciAqbmFtZTIsIHNpemVfdCBsZW4yKTsKZXh0ZXJuIGludCBjYWNoZV9uYW1lX3N0YWdlX2NvbXBhcmUoY29uc3QgY2hhciAqbmFtZTEsIGludCBsZW4xLCBpbnQgc3RhZ2UxLCBjb25zdCBjaGFyICpuYW1lMiwgaW50IGxlbjIsIGludCBzdGFnZTIpOwoKZXh0ZXJuIHZvaWQgKnJlYWRfb2JqZWN0X3dpdGhfcmVmZXJlbmNlKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCQljb25zdCBjaGFyICpyZXF1aXJlZF90eXBlLAoJCQkJCXVuc2lnbmVkIGxvbmcgKnNpemUsCgkJCQkJc3RydWN0IG9iamVjdF9pZCAqb2lkX3JldCk7CgpleHRlcm4gc3RydWN0IG9iamVjdCAqcGVlbF90b190eXBlKGNvbnN0IGNoYXIgKm5hbWUsIGludCBuYW1lbGVuLAoJCQkJICAgc3RydWN0IG9iamVjdCAqbywgZW51bSBvYmplY3RfdHlwZSk7CgplbnVtIGRhdGVfbW9kZV90eXBlIHsKCURBVEVfTk9STUFMID0gMCwKCURBVEVfUkVMQVRJVkUsCglEQVRFX1NIT1JULAoJREFURV9JU084NjAxLAoJREFURV9JU084NjAxX1NUUklDVCwKCURBVEVfUkZDMjgyMiwKCURBVEVfU1RSRlRJTUUsCglEQVRFX1JBVywKCURBVEVfVU5JWAp9OwoKc3RydWN0IGRhdGVfbW9kZSB7CgllbnVtIGRhdGVfbW9kZV90eXBlIHR5cGU7Cgljb25zdCBjaGFyICpzdHJmdGltZV9mbXQ7CglpbnQgbG9jYWw7Cn07CgovKgogKiBDb252ZW5pZW5jZSBoZWxwZXIgZm9yIHBhc3NpbmcgYSBjb25zdGFudCB0eXBlLCBsaWtlOgogKgogKiAgIHNob3dfZGF0ZSh0LCB0eiwgREFURV9NT0RFKE5PUk1BTCkpOwogKi8KI2RlZmluZSBEQVRFX01PREUodCkgZGF0ZV9tb2RlX2Zyb21fdHlwZShEQVRFXyMjdCkKc3RydWN0IGRhdGVfbW9kZSAqZGF0ZV9tb2RlX2Zyb21fdHlwZShlbnVtIGRhdGVfbW9kZV90eXBlIHR5cGUpOwoKY29uc3QgY2hhciAqc2hvd19kYXRlKHRpbWVzdGFtcF90IHRpbWUsIGludCB0aW1lem9uZSwgY29uc3Qgc3RydWN0IGRhdGVfbW9kZSAqbW9kZSk7CnZvaWQgc2hvd19kYXRlX3JlbGF0aXZlKHRpbWVzdGFtcF90IHRpbWUsIGludCB0eiwgY29uc3Qgc3RydWN0IHRpbWV2YWwgKm5vdywKCQkJc3RydWN0IHN0cmJ1ZiAqdGltZWJ1Zik7CmludCBwYXJzZV9kYXRlKGNvbnN0IGNoYXIgKmRhdGUsIHN0cnVjdCBzdHJidWYgKm91dCk7CmludCBwYXJzZV9kYXRlX2Jhc2ljKGNvbnN0IGNoYXIgKmRhdGUsIHRpbWVzdGFtcF90ICp0aW1lc3RhbXAsIGludCAqb2Zmc2V0KTsKaW50IHBhcnNlX2V4cGlyeV9kYXRlKGNvbnN0IGNoYXIgKmRhdGUsIHRpbWVzdGFtcF90ICp0aW1lc3RhbXApOwp2b2lkIGRhdGVzdGFtcChzdHJ1Y3Qgc3RyYnVmICpvdXQpOwojZGVmaW5lIGFwcHJveGlkYXRlKHMpIGFwcHJveGlkYXRlX2NhcmVmdWwoKHMpLCBOVUxMKQp0aW1lc3RhbXBfdCBhcHByb3hpZGF0ZV9jYXJlZnVsKGNvbnN0IGNoYXIgKiwgaW50ICopOwp0aW1lc3RhbXBfdCBhcHByb3hpZGF0ZV9yZWxhdGl2ZShjb25zdCBjaGFyICpkYXRlLCBjb25zdCBzdHJ1Y3QgdGltZXZhbCAqbm93KTsKdm9pZCBwYXJzZV9kYXRlX2Zvcm1hdChjb25zdCBjaGFyICpmb3JtYXQsIHN0cnVjdCBkYXRlX21vZGUgKm1vZGUpOwppbnQgZGF0ZV9vdmVyZmxvd3ModGltZXN0YW1wX3QgZGF0ZSk7CgojZGVmaW5lIElERU5UX1NUUklDVAkgICAgICAgMQojZGVmaW5lIElERU5UX05PX0RBVEUJICAgICAgIDIKI2RlZmluZSBJREVOVF9OT19OQU1FCSAgICAgICA0CmV4dGVybiBjb25zdCBjaGFyICpnaXRfYXV0aG9yX2luZm8oaW50KTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdpdF9jb21taXR0ZXJfaW5mbyhpbnQpOwpleHRlcm4gY29uc3QgY2hhciAqZm10X2lkZW50KGNvbnN0IGNoYXIgKm5hbWUsIGNvbnN0IGNoYXIgKmVtYWlsLCBjb25zdCBjaGFyICpkYXRlX3N0ciwgaW50KTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmZtdF9uYW1lKGNvbnN0IGNoYXIgKm5hbWUsIGNvbnN0IGNoYXIgKmVtYWlsKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmlkZW50X2RlZmF1bHRfbmFtZSh2b2lkKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmlkZW50X2RlZmF1bHRfZW1haWwodm9pZCk7CmV4dGVybiBjb25zdCBjaGFyICpnaXRfZWRpdG9yKHZvaWQpOwpleHRlcm4gY29uc3QgY2hhciAqZ2l0X3NlcXVlbmNlX2VkaXRvcih2b2lkKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdpdF9wYWdlcihpbnQgc3Rkb3V0X2lzX3R0eSk7CmV4dGVybiBpbnQgaXNfdGVybWluYWxfZHVtYih2b2lkKTsKZXh0ZXJuIGludCBnaXRfaWRlbnRfY29uZmlnKGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqLCB2b2lkICopOwpleHRlcm4gdm9pZCByZXNldF9pZGVudF9kYXRlKHZvaWQpOwoKc3RydWN0IGlkZW50X3NwbGl0IHsKCWNvbnN0IGNoYXIgKm5hbWVfYmVnaW47Cgljb25zdCBjaGFyICpuYW1lX2VuZDsKCWNvbnN0IGNoYXIgKm1haWxfYmVnaW47Cgljb25zdCBjaGFyICptYWlsX2VuZDsKCWNvbnN0IGNoYXIgKmRhdGVfYmVnaW47Cgljb25zdCBjaGFyICpkYXRlX2VuZDsKCWNvbnN0IGNoYXIgKnR6X2JlZ2luOwoJY29uc3QgY2hhciAqdHpfZW5kOwp9OwovKgogKiBTaWduYWxzIGFuIHN1Y2Nlc3Mgd2l0aCAwLCBidXQgdGltZSBwYXJ0IG9mIHRoZSByZXN1bHQgbWF5IGJlIE5VTEwKICogaWYgdGhlIGlucHV0IGxhY2tzIHRpbWVzdGFtcCBhbmQgem9uZQogKi8KZXh0ZXJuIGludCBzcGxpdF9pZGVudF9saW5lKHN0cnVjdCBpZGVudF9zcGxpdCAqLCBjb25zdCBjaGFyICosIGludCk7CgovKgogKiBMaWtlIHNob3dfZGF0ZSwgYnV0IHB1bGwgdGhlIHRpbWVzdGFtcCBhbmQgdHogcGFyYW1ldGVycyBmcm9tCiAqIHRoZSBpZGVudF9zcGxpdC4gSXQgd2lsbCBhbHNvIHNhbml0eS1jaGVjayB0aGUgdmFsdWVzIGFuZCBwcm9kdWNlCiAqIGEgd2VsbC1rbm93biBzZW50aW5lbCBkYXRlIGlmIHRoZXkgYXBwZWFyIGJvZ3VzLgogKi8KY29uc3QgY2hhciAqc2hvd19pZGVudF9kYXRlKGNvbnN0IHN0cnVjdCBpZGVudF9zcGxpdCAqaWQsCgkJCSAgICBjb25zdCBzdHJ1Y3QgZGF0ZV9tb2RlICptb2RlKTsKCi8qCiAqIENvbXBhcmUgc3BsaXQgaWRlbnRzIGZvciBlcXVhbGl0eSBvciBzdHJpY3Qgb3JkZXJpbmcuIE5vdGUgdGhhdCB3ZQogKiBjb21wYXJlIG9ubHkgdGhlIGlkZW50IHBhcnQgb2YgdGhlIGxpbmUsIGlnbm9yaW5nIGFueSB0aW1lc3RhbXAuCiAqCiAqIEJlY2F1c2UgdGhlcmUgYXJlIHR3byBmaWVsZHMsIHdlIG11c3QgY2hvb3NlIG9uZSBhcyB0aGUgcHJpbWFyeSBrZXk7IHdlCiAqIGN1cnJlbnRseSBhcmJpdHJhcmlseSBwaWNrIHRoZSBlbWFpbC4KICovCmV4dGVybiBpbnQgaWRlbnRfY21wKGNvbnN0IHN0cnVjdCBpZGVudF9zcGxpdCAqLCBjb25zdCBzdHJ1Y3QgaWRlbnRfc3BsaXQgKik7CgpzdHJ1Y3QgY2hlY2tvdXQgewoJc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGU7Cgljb25zdCBjaGFyICpiYXNlX2RpcjsKCWludCBiYXNlX2Rpcl9sZW47CglzdHJ1Y3QgZGVsYXllZF9jaGVja291dCAqZGVsYXllZF9jaGVja291dDsKCXVuc2lnbmVkIGZvcmNlOjEsCgkJIHF1aWV0OjEsCgkJIG5vdF9uZXc6MSwKCQkgY2xvbmU6MSwKCQkgcmVmcmVzaF9jYWNoZToxOwp9OwojZGVmaW5lIENIRUNLT1VUX0lOSVQgeyBOVUxMLCAiIiB9CgojZGVmaW5lIFRFTVBPUkFSWV9GSUxFTkFNRV9MRU5HVEggMjUKZXh0ZXJuIGludCBjaGVja291dF9lbnRyeShzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBjb25zdCBzdHJ1Y3QgY2hlY2tvdXQgKnN0YXRlLCBjaGFyICp0b3BhdGgsIGludCAqbnJfY2hlY2tvdXRzKTsKZXh0ZXJuIHZvaWQgZW5hYmxlX2RlbGF5ZWRfY2hlY2tvdXQoc3RydWN0IGNoZWNrb3V0ICpzdGF0ZSk7CmV4dGVybiBpbnQgZmluaXNoX2RlbGF5ZWRfY2hlY2tvdXQoc3RydWN0IGNoZWNrb3V0ICpzdGF0ZSwgaW50ICpucl9jaGVja291dHMpOwoKc3RydWN0IGNhY2hlX2RlZiB7CglzdHJ1Y3Qgc3RyYnVmIHBhdGg7CglpbnQgZmxhZ3M7CglpbnQgdHJhY2tfZmxhZ3M7CglpbnQgcHJlZml4X2xlbl9zdGF0X2Z1bmM7Cn07CiNkZWZpbmUgQ0FDSEVfREVGX0lOSVQgeyBTVFJCVUZfSU5JVCwgMCwgMCwgMCB9CnN0YXRpYyBpbmxpbmUgdm9pZCBjYWNoZV9kZWZfY2xlYXIoc3RydWN0IGNhY2hlX2RlZiAqY2FjaGUpCnsKCXN0cmJ1Zl9yZWxlYXNlKCZjYWNoZS0+cGF0aCk7Cn0KCmV4dGVybiBpbnQgaGFzX3N5bWxpbmtfbGVhZGluZ19wYXRoKGNvbnN0IGNoYXIgKm5hbWUsIGludCBsZW4pOwpleHRlcm4gaW50IHRocmVhZGVkX2hhc19zeW1saW5rX2xlYWRpbmdfcGF0aChzdHJ1Y3QgY2FjaGVfZGVmICosIGNvbnN0IGNoYXIgKiwgaW50KTsKZXh0ZXJuIGludCBjaGVja19sZWFkaW5nX3BhdGgoY29uc3QgY2hhciAqbmFtZSwgaW50IGxlbik7CmV4dGVybiBpbnQgaGFzX2RpcnNfb25seV9wYXRoKGNvbnN0IGNoYXIgKm5hbWUsIGludCBsZW4sIGludCBwcmVmaXhfbGVuKTsKZXh0ZXJuIHZvaWQgc2NoZWR1bGVfZGlyX2Zvcl9yZW1vdmFsKGNvbnN0IGNoYXIgKm5hbWUsIGludCBsZW4pOwpleHRlcm4gdm9pZCByZW1vdmVfc2NoZWR1bGVkX2RpcnModm9pZCk7CgpzdHJ1Y3QgcGFja193aW5kb3cgewoJc3RydWN0IHBhY2tfd2luZG93ICpuZXh0OwoJdW5zaWduZWQgY2hhciAqYmFzZTsKCW9mZl90IG9mZnNldDsKCXNpemVfdCBsZW47Cgl1bnNpZ25lZCBpbnQgbGFzdF91c2VkOwoJdW5zaWduZWQgaW50IGludXNlX2NudDsKfTsKCnN0cnVjdCBwYWNrX2VudHJ5IHsKCW9mZl90IG9mZnNldDsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwOwp9OwoKLyoKICogQ3JlYXRlIGEgdGVtcG9yYXJ5IGZpbGUgcm9vdGVkIGluIHRoZSBvYmplY3QgZGF0YWJhc2UgZGlyZWN0b3J5LCBvcgogKiBkaWUgb24gZmFpbHVyZS4gVGhlIGZpbGVuYW1lIGlzIHRha2VuIGZyb20gInBhdHRlcm4iLCB3aGljaCBzaG91bGQgaGF2ZSB0aGUKICogdXN1YWwgIlhYWFhYWCIgdHJhaWxlciwgYW5kIHRoZSByZXN1bHRpbmcgZmlsZW5hbWUgaXMgd3JpdHRlbiBpbnRvIHRoZQogKiAidGVtcGxhdGUiIGJ1ZmZlci4gUmV0dXJucyB0aGUgb3BlbiBkZXNjcmlwdG9yLgogKi8KZXh0ZXJuIGludCBvZGJfbWtzdGVtcChzdHJ1Y3Qgc3RyYnVmICp0ZW1wX2ZpbGVuYW1lLCBjb25zdCBjaGFyICpwYXR0ZXJuKTsKCi8qCiAqIENyZWF0ZSBhIHBhY2sgLmtlZXAgZmlsZSBuYW1lZCAibmFtZSIgKHdoaWNoIHNob3VsZCBnZW5lcmFsbHkgYmUgdGhlIG91dHB1dAogKiBvZiBvZGJfcGFja19uYW1lKS4gUmV0dXJucyBhIGZpbGUgZGVzY3JpcHRvciBvcGVuZWQgZm9yIHdyaXRpbmcsIG9yIC0xIG9uCiAqIGVycm9yLgogKi8KZXh0ZXJuIGludCBvZGJfcGFja19rZWVwKGNvbnN0IGNoYXIgKm5hbWUpOwoKLyoKICogU2V0IHRoaXMgdG8gMCB0byBwcmV2ZW50IHNoYTFfb2JqZWN0X2luZm9fZXh0ZW5kZWQoKSBmcm9tIGZldGNoaW5nIG1pc3NpbmcKICogYmxvYnMuIFRoaXMgaGFzIGEgZGlmZmVyZW5jZSBvbmx5IGlmIGV4dGVuc2lvbnMucGFydGlhbENsb25lIGlzIHNldC4KICoKICogSXRzIGRlZmF1bHQgdmFsdWUgaXMgMS4KICovCmV4dGVybiBpbnQgZmV0Y2hfaWZfbWlzc2luZzsKCi8qIER1bWIgc2VydmVycyBzdXBwb3J0ICovCmV4dGVybiBpbnQgdXBkYXRlX3NlcnZlcl9pbmZvKGludCk7CgpleHRlcm4gY29uc3QgY2hhciAqZ2V0X2xvZ19vdXRwdXRfZW5jb2Rpbmcodm9pZCk7CmV4dGVybiBjb25zdCBjaGFyICpnZXRfY29tbWl0X291dHB1dF9lbmNvZGluZyh2b2lkKTsKCi8qCiAqIFRoaXMgaXMgYSBoYWNrIGZvciB0ZXN0IHByb2dyYW1zIGxpa2UgdGVzdC1kdW1wLXVudHJhY2tlZC1jYWNoZSB0bwogKiBlbnN1cmUgdGhhdCB0aGV5IGRvIG5vdCBtb2RpZnkgdGhlIHVudHJhY2tlZCBjYWNoZSB3aGVuIHJlYWRpbmcgaXQuCiAqIERvIG5vdCB1c2UgaXQgb3RoZXJ3aXNlIQogKi8KZXh0ZXJuIGludCBpZ25vcmVfdW50cmFja2VkX2NhY2hlX2NvbmZpZzsKCmV4dGVybiBpbnQgY29tbWl0dGVyX2lkZW50X3N1ZmZpY2llbnRseV9naXZlbih2b2lkKTsKZXh0ZXJuIGludCBhdXRob3JfaWRlbnRfc3VmZmljaWVudGx5X2dpdmVuKHZvaWQpOwoKZXh0ZXJuIGNvbnN0IGNoYXIgKmdpdF9jb21taXRfZW5jb2Rpbmc7CmV4dGVybiBjb25zdCBjaGFyICpnaXRfbG9nX291dHB1dF9lbmNvZGluZzsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdpdF9tYWlsbWFwX2ZpbGU7CmV4dGVybiBjb25zdCBjaGFyICpnaXRfbWFpbG1hcF9ibG9iOwoKLyogSU8gaGVscGVyIGZ1bmN0aW9ucyAqLwpleHRlcm4gdm9pZCBtYXliZV9mbHVzaF9vcl9kaWUoRklMRSAqLCBjb25zdCBjaGFyICopOwpfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMiwgMykpKQpleHRlcm4gdm9pZCBmcHJpbnRmX29yX2RpZShGSUxFICosIGNvbnN0IGNoYXIgKmZtdCwgLi4uKTsKCiNkZWZpbmUgQ09QWV9SRUFEX0VSUk9SICgtMikKI2RlZmluZSBDT1BZX1dSSVRFX0VSUk9SICgtMykKZXh0ZXJuIGludCBjb3B5X2ZkKGludCBpZmQsIGludCBvZmQpOwpleHRlcm4gaW50IGNvcHlfZmlsZShjb25zdCBjaGFyICpkc3QsIGNvbnN0IGNoYXIgKnNyYywgaW50IG1vZGUpOwpleHRlcm4gaW50IGNvcHlfZmlsZV93aXRoX3RpbWUoY29uc3QgY2hhciAqZHN0LCBjb25zdCBjaGFyICpzcmMsIGludCBtb2RlKTsKCmV4dGVybiB2b2lkIHdyaXRlX29yX2RpZShpbnQgZmQsIGNvbnN0IHZvaWQgKmJ1Ziwgc2l6ZV90IGNvdW50KTsKZXh0ZXJuIHZvaWQgZnN5bmNfb3JfZGllKGludCBmZCwgY29uc3QgY2hhciAqKTsKCmV4dGVybiBzc2l6ZV90IHJlYWRfaW5fZnVsbChpbnQgZmQsIHZvaWQgKmJ1Ziwgc2l6ZV90IGNvdW50KTsKZXh0ZXJuIHNzaXplX3Qgd3JpdGVfaW5fZnVsbChpbnQgZmQsIGNvbnN0IHZvaWQgKmJ1Ziwgc2l6ZV90IGNvdW50KTsKZXh0ZXJuIHNzaXplX3QgcHJlYWRfaW5fZnVsbChpbnQgZmQsIHZvaWQgKmJ1Ziwgc2l6ZV90IGNvdW50LCBvZmZfdCBvZmZzZXQpOwoKc3RhdGljIGlubGluZSBzc2l6ZV90IHdyaXRlX3N0cl9pbl9mdWxsKGludCBmZCwgY29uc3QgY2hhciAqc3RyKQp7CglyZXR1cm4gd3JpdGVfaW5fZnVsbChmZCwgc3RyLCBzdHJsZW4oc3RyKSk7Cn0KCi8qKgogKiBPcGVuIChhbmQgdHJ1bmNhdGUpIHRoZSBmaWxlIGF0IHBhdGgsIHdyaXRlIHRoZSBjb250ZW50cyBvZiBidWYgdG8gaXQsCiAqIGFuZCBjbG9zZSBpdC4gRGllcyBpZiBhbnkgZXJyb3JzIGFyZSBlbmNvdW50ZXJlZC4KICovCmV4dGVybiB2b2lkIHdyaXRlX2ZpbGVfYnVmKGNvbnN0IGNoYXIgKnBhdGgsIGNvbnN0IGNoYXIgKmJ1Ziwgc2l6ZV90IGxlbik7CgovKioKICogTGlrZSB3cml0ZV9maWxlX2J1ZigpLCBidXQgZm9ybWF0IHRoZSBjb250ZW50cyBpbnRvIGEgYnVmZmVyIGZpcnN0LgogKiBBZGRpdGlvbmFsbHksIHdyaXRlX2ZpbGUoKSB3aWxsIGFwcGVuZCBhIG5ld2xpbmUgaWYgb25lIGlzIG5vdCBhbHJlYWR5CiAqIHByZXNlbnQsIG1ha2luZyBpdCBjb252ZW5pZW50IHRvIHdyaXRlIHRleHQgZmlsZXM6CiAqCiAqICAgd3JpdGVfZmlsZShwYXRoLCAiY291bnRlcjogJWQiLCBjdHIpOwogKi8KX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsIDIsIDMpKSkKZXh0ZXJuIHZvaWQgd3JpdGVfZmlsZShjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFyICpmbXQsIC4uLik7CgovKiBwYWdlci5jICovCmV4dGVybiB2b2lkIHNldHVwX3BhZ2VyKHZvaWQpOwpleHRlcm4gaW50IHBhZ2VyX2luX3VzZSh2b2lkKTsKZXh0ZXJuIGludCBwYWdlcl91c2VfY29sb3I7CmV4dGVybiBpbnQgdGVybV9jb2x1bW5zKHZvaWQpOwpleHRlcm4gaW50IGRlY2ltYWxfd2lkdGgodWludG1heF90KTsKZXh0ZXJuIGludCBjaGVja19wYWdlcl9jb25maWcoY29uc3QgY2hhciAqY21kKTsKZXh0ZXJuIHZvaWQgcHJlcGFyZV9wYWdlcl9hcmdzKHN0cnVjdCBjaGlsZF9wcm9jZXNzICosIGNvbnN0IGNoYXIgKnBhZ2VyKTsKCmV4dGVybiBjb25zdCBjaGFyICplZGl0b3JfcHJvZ3JhbTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmFza3Bhc3NfcHJvZ3JhbTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmV4Y2x1ZGVzX2ZpbGU7CgovKiBiYXNlODUgKi8KaW50IGRlY29kZV84NShjaGFyICpkc3QsIGNvbnN0IGNoYXIgKmxpbmUsIGludCBsaW5lbGVuKTsKdm9pZCBlbmNvZGVfODUoY2hhciAqYnVmLCBjb25zdCB1bnNpZ25lZCBjaGFyICpkYXRhLCBpbnQgYnl0ZXMpOwoKLyogcGt0LWxpbmUuYyAqLwp2b2lkIHBhY2tldF90cmFjZV9pZGVudGl0eShjb25zdCBjaGFyICpwcm9nKTsKCi8qIGFkZCAqLwovKgogKiByZXR1cm4gMCBpZiBzdWNjZXNzLCAxIC0gaWYgYWRkaXRpb24gb2YgYSBmaWxlIGZhaWxlZCBhbmQKICogQUREX0ZJTEVTX0lHTk9SRV9FUlJPUlMgd2FzIHNwZWNpZmllZCBpbiBmbGFncwogKi8KaW50IGFkZF9maWxlc190b19jYWNoZShjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcGF0aHNwZWMsIGludCBmbGFncyk7CgovKiBkaWZmLmMgKi8KZXh0ZXJuIGludCBkaWZmX2F1dG9fcmVmcmVzaF9pbmRleDsKCi8qIG1hdGNoLXRyZWVzLmMgKi8Kdm9pZCBzaGlmdF90cmVlKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKiwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqLCBzdHJ1Y3Qgb2JqZWN0X2lkICosIGludCk7CnZvaWQgc2hpZnRfdHJlZV9ieShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICosIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKiwgc3RydWN0IG9iamVjdF9pZCAqLCBjb25zdCBjaGFyICopOwoKLyoKICogd2hpdGVzcGFjZSBydWxlcy4KICogdXNlZCBieSBib3RoIGRpZmYgYW5kIGFwcGx5CiAqIGxhc3QgdHdvIGRpZ2l0cyBhcmUgdGFiIHdpZHRoCiAqLwojZGVmaW5lIFdTX0JMQU5LX0FUX0VPTCAgICAgICAgIDAxMDAKI2RlZmluZSBXU19TUEFDRV9CRUZPUkVfVEFCICAgICAwMjAwCiNkZWZpbmUgV1NfSU5ERU5UX1dJVEhfTk9OX1RBQiAgMDQwMAojZGVmaW5lIFdTX0NSX0FUX0VPTCAgICAgICAgICAgMDEwMDAKI2RlZmluZSBXU19CTEFOS19BVF9FT0YgICAgICAgIDAyMDAwCiNkZWZpbmUgV1NfVEFCX0lOX0lOREVOVCAgICAgICAwNDAwMAojZGVmaW5lIFdTX1RSQUlMSU5HX1NQQUNFICAgICAgKFdTX0JMQU5LX0FUX0VPTHxXU19CTEFOS19BVF9FT0YpCiNkZWZpbmUgV1NfREVGQVVMVF9SVUxFIChXU19UUkFJTElOR19TUEFDRXxXU19TUEFDRV9CRUZPUkVfVEFCfDgpCiNkZWZpbmUgV1NfVEFCX1dJRFRIX01BU0sgICAgICAgIDA3NwovKiBBbGwgV1NfKiAtLSB3aGVuIGV4dGVuZGVkLCBhZGFwdCBkaWZmLmMgZW1pdF9zeW1ib2wgKi8KI2RlZmluZSBXU19SVUxFX01BU0sgICAgICAgICAgIDA3Nzc3CmV4dGVybiB1bnNpZ25lZCB3aGl0ZXNwYWNlX3J1bGVfY2ZnOwpleHRlcm4gdW5zaWduZWQgd2hpdGVzcGFjZV9ydWxlKHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBjb25zdCBjaGFyICopOwpleHRlcm4gdW5zaWduZWQgcGFyc2Vfd2hpdGVzcGFjZV9ydWxlKGNvbnN0IGNoYXIgKik7CmV4dGVybiB1bnNpZ25lZCB3c19jaGVjayhjb25zdCBjaGFyICpsaW5lLCBpbnQgbGVuLCB1bnNpZ25lZCB3c19ydWxlKTsKZXh0ZXJuIHZvaWQgd3NfY2hlY2tfZW1pdChjb25zdCBjaGFyICpsaW5lLCBpbnQgbGVuLCB1bnNpZ25lZCB3c19ydWxlLCBGSUxFICpzdHJlYW0sIGNvbnN0IGNoYXIgKnNldCwgY29uc3QgY2hhciAqcmVzZXQsIGNvbnN0IGNoYXIgKndzKTsKZXh0ZXJuIGNoYXIgKndoaXRlc3BhY2VfZXJyb3Jfc3RyaW5nKHVuc2lnbmVkIHdzKTsKZXh0ZXJuIHZvaWQgd3NfZml4X2NvcHkoc3RydWN0IHN0cmJ1ZiAqLCBjb25zdCBjaGFyICosIGludCwgdW5zaWduZWQsIGludCAqKTsKZXh0ZXJuIGludCB3c19ibGFua19saW5lKGNvbnN0IGNoYXIgKmxpbmUsIGludCBsZW4sIHVuc2lnbmVkIHdzX3J1bGUpOwojZGVmaW5lIHdzX3RhYl93aWR0aChydWxlKSAgICAgKChydWxlKSAmIFdTX1RBQl9XSURUSF9NQVNLKQoKLyogbHMtZmlsZXMgKi8Kdm9pZCBvdmVybGF5X3RyZWVfb25faW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsCgkJCSAgIGNvbnN0IGNoYXIgKnRyZWVfbmFtZSwgY29uc3QgY2hhciAqcHJlZml4KTsKCi8qIHNldHVwLmMgKi8Kc3RydWN0IHN0YXJ0dXBfaW5mbyB7CglpbnQgaGF2ZV9yZXBvc2l0b3J5OwoJY29uc3QgY2hhciAqcHJlZml4Owp9OwpleHRlcm4gc3RydWN0IHN0YXJ0dXBfaW5mbyAqc3RhcnR1cF9pbmZvOwoKLyogbWVyZ2UuYyAqLwpzdHJ1Y3QgY29tbWl0X2xpc3Q7CmludCB0cnlfbWVyZ2VfY29tbWFuZChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQljb25zdCBjaGFyICpzdHJhdGVneSwgc2l6ZV90IHhvcHRzX25yLAoJCWNvbnN0IGNoYXIgKip4b3B0cywgc3RydWN0IGNvbW1pdF9saXN0ICpjb21tb24sCgkJY29uc3QgY2hhciAqaGVhZF9hcmcsIHN0cnVjdCBjb21taXRfbGlzdCAqcmVtb3Rlcyk7CmludCBjaGVja291dF9mYXN0X2ZvcndhcmQoc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCSAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqZnJvbSwKCQkJICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICp0bywKCQkJICBpbnQgb3ZlcndyaXRlX2lnbm9yZSk7CgoKaW50IHNhbmVfZXhlY3ZwKGNvbnN0IGNoYXIgKmZpbGUsIGNoYXIgKmNvbnN0IGFyZ3ZbXSk7CgovKgogKiBBIHN0cnVjdCB0byBlbmNhcHN1bGF0ZSB0aGUgY29uY2VwdCBvZiB3aGV0aGVyIGEgZmlsZSBoYXMgY2hhbmdlZAogKiBzaW5jZSB3ZSBsYXN0IGNoZWNrZWQgaXQuIFRoaXMgdXNlcyBjcml0ZXJpYSBzaW1pbGFyIHRvIHRob3NlIHVzZWQKICogZm9yIHRoZSBpbmRleC4KICovCnN0cnVjdCBzdGF0X3ZhbGlkaXR5IHsKCXN0cnVjdCBzdGF0X2RhdGEgKnNkOwp9OwoKdm9pZCBzdGF0X3ZhbGlkaXR5X2NsZWFyKHN0cnVjdCBzdGF0X3ZhbGlkaXR5ICpzdik7CgovKgogKiBSZXR1cm5zIDEgaWYgdGhlIHBhdGggaXMgYSByZWd1bGFyIGZpbGUgKG9yIGEgc3ltbGluayB0byBhIHJlZ3VsYXIKICogZmlsZSkgYW5kIG1hdGNoZXMgdGhlIHNhdmVkIHN0YXRfdmFsaWRpdHksIDAgb3RoZXJ3aXNlLiAgQSBtaXNzaW5nCiAqIG9yIGluYWNjZXNzaWJsZSBmaWxlIGlzIGNvbnNpZGVyZWQgYSBtYXRjaCBpZiB0aGUgc3RydWN0IHdhcyBqdXN0CiAqIGluaXRpYWxpemVkLCBvciBpZiB0aGUgcHJldmlvdXMgdXBkYXRlIGZvdW5kIGFuIGluYWNjZXNzaWJsZSBmaWxlLgogKi8KaW50IHN0YXRfdmFsaWRpdHlfY2hlY2soc3RydWN0IHN0YXRfdmFsaWRpdHkgKnN2LCBjb25zdCBjaGFyICpwYXRoKTsKCi8qCiAqIFVwZGF0ZSB0aGUgc3RhdF92YWxpZGl0eSBmcm9tIGEgZmlsZSBvcGVuZWQgYXQgZGVzY3JpcHRvciBmZC4gSWYKICogdGhlIGZpbGUgaXMgbWlzc2luZywgaW5hY2Nlc3NpYmxlLCBvciBub3QgYSByZWd1bGFyIGZpbGUsIHRoZW4KICogZnV0dXJlIGNhbGxzIHRvIHN0YXRfdmFsaWRpdHlfY2hlY2sgd2lsbCBtYXRjaCBpZmYgb25lIG9mIHRob3NlCiAqIGNvbmRpdGlvbnMgY29udGludWVzIHRvIGJlIHRydWUuCiAqLwp2b2lkIHN0YXRfdmFsaWRpdHlfdXBkYXRlKHN0cnVjdCBzdGF0X3ZhbGlkaXR5ICpzdiwgaW50IGZkKTsKCmludCB2ZXJzaW9uY21wKGNvbnN0IGNoYXIgKnMxLCBjb25zdCBjaGFyICpzMik7CnZvaWQgc2xlZXBfbWlsbGlzZWMoaW50IG1pbGxpc2VjKTsKCi8qCiAqIENyZWF0ZSBhIGRpcmVjdG9yeSBhbmQgKGlmIHNoYXJlIGlzIG5vbnplcm8pIGFkanVzdCBpdHMgcGVybWlzc2lvbnMKICogYWNjb3JkaW5nIHRvIHRoZSBzaGFyZWRfcmVwb3NpdG9yeSBzZXR0aW5nLiBPbmx5IHVzZSB0aGlzIGZvcgogKiBkaXJlY3RvcmllcyB1bmRlciAkR0lUX0RJUi4gIERvbid0IHVzZSBpdCBmb3Igd29ya2luZyB0cmVlCiAqIGRpcmVjdG9yaWVzLgogKi8Kdm9pZCBzYWZlX2NyZWF0ZV9kaXIoY29uc3QgY2hhciAqZGlyLCBpbnQgc2hhcmUpOwoKLyoKICogU2hvdWxkIHdlIHByaW50IGFuIGVsbGlwc2lzIGFmdGVyIGFuIGFiYnJldmlhdGVkIFNIQS0xIHZhbHVlCiAqIHdoZW4gZG9pbmcgZGlmZi1yYXcgb3V0cHV0IG9yIGluZGljYXRpbmcgYSBkZXRhY2hlZCBIRUFEPwogKi8KZXh0ZXJuIGludCBwcmludF9zaGExX2VsbGlwc2lzKHZvaWQpOwoKI2VuZGlmIC8qIENBQ0hFX0ggKi8K",
    "text": "#ifndef CACHE_H\n#define CACHE_H\n\n#include \"git-compat-util.h\"\n#include \"strbuf.h\"\n#include \"hashmap.h\"\n#include \"list.h\"\n#include \"advice.h\"\n#include \"gettext.h\"\n#include \"convert.h\"\n#include \"trace.h\"\n#include \"string-list.h\"\n#include \"pack-revindex.h\"\n#include \"hash.h\"\n#include \"path.h\"\n#include \"sha1-array.h\"\n#include \"repository.h\"\n#include \"mem-pool.h\"\n\n#include <zlib.h>\ntypedef struct git_zstream {\n\tz_stream z;\n\tunsigned long avail_in;\n\tunsigned long avail_out;\n\tunsigned long total_in;\n\tunsigned long total_out;\n\tunsigned char *next_in;\n\tunsigned char *next_out;\n} git_zstream;\n\nvoid git_inflate_init(git_zstream *);\nvoid git_inflate_init_gzip_only(git_zstream *);\nvoid git_inflate_end(git_zstream *);\nint git_inflate(git_zstream *, int flush);\n\nvoid git_deflate_init(git_zstream *, int level);\nvoid git_deflate_init_gzip(git_zstream *, int level);\nvoid git_deflate_init_raw(git_zstream *, int level);\nvoid git_deflate_end(git_zstream *);\nint git_deflate_abort(git_zstream *);\nint git_deflate_end_gently(git_zstream *);\nint git_deflate(git_zstream *, int flush);\nunsigned long git_deflate_bound(git_zstream *, unsigned long);\n\n/* The length in bytes and in hex digits of an object name (SHA-1 value). */\n#define GIT_SHA1_RAWSZ 20\n#define GIT_SHA1_HEXSZ (2 * GIT_SHA1_RAWSZ)\n/* The block size of SHA-1. */\n#define GIT_SHA1_BLKSZ 64\n\n/* The length in bytes and in hex digits of an object name (SHA-256 value). */\n#define GIT_SHA256_RAWSZ 32\n#define GIT_SHA256_HEXSZ (2 * GIT_SHA256_RAWSZ)\n/* The block size of SHA-256. */\n#define GIT_SHA256_BLKSZ 64\n\n/* The length in byte and in hex digits of the largest possible hash value. */\n#define GIT_MAX_RAWSZ GIT_SHA256_RAWSZ\n#define GIT_MAX_HEXSZ GIT_SHA256_HEXSZ\n/* The largest possible block size for any supported hash. */\n#define GIT_MAX_BLKSZ GIT_SHA256_BLKSZ\n\nstruct object_id {\n\tunsigned char hash[GIT_MAX_RAWSZ];\n};\n\n#define the_hash_algo the_repository->hash_algo\n\n#if defined(DT_UNKNOWN) && !defined(NO_D_TYPE_IN_DIRENT)\n#define DTYPE(de)\t((de)->d_type)\n#else\n#undef DT_UNKNOWN\n#undef DT_DIR\n#undef DT_REG\n#undef DT_LNK\n#define DT_UNKNOWN\t0\n#define DT_DIR\t\t1\n#define DT_REG\t\t2\n#define DT_LNK\t\t3\n#define DTYPE(de)\tDT_UNKNOWN\n#endif\n\n/* unknown mode (impossible combination S_IFIFO|S_IFCHR) */\n#define S_IFINVALID     0030000\n\n/*\n * A \"directory link\" is a link to another git directory.\n *\n * The value 0160000 is not normally a valid mode, and\n * also just happens to be S_IFDIR + S_IFLNK\n */\n#define S_IFGITLINK\t0160000\n#define S_ISGITLINK(m)\t(((m) & S_IFMT) == S_IFGITLINK)\n\n/*\n * Some mode bits are also used internally for computations.\n *\n * They *must* not overlap with any valid modes, and they *must* not be emitted\n * to outside world - i.e. appear on disk or network. In other words, it's just\n * temporary fields, which we internally use, but they have to stay in-house.\n *\n * ( such approach is valid, as standard S_IF* fits into 16 bits, and in Git\n *   codebase mode is `unsigned int` which is assumed to be at least 32 bits )\n */\n\n/* used internally in tree-diff */\n#define S_DIFFTREE_IFXMIN_NEQ\t0x80000000\n\n\n/*\n * Intensive research over the course of many years has shown that\n * port 9418 is totally unused by anything else. Or\n *\n *\tYour search - \"port 9418\" - did not match any documents.\n *\n * as www.google.com puts it.\n *\n * This port has been properly assigned for git use by IANA:\n * git (Assigned-9418) [I06-050728-0001].\n *\n *\tgit  9418/tcp   git pack transfer service\n *\tgit  9418/udp   git pack transfer service\n *\n * with Linus Torvalds <torvalds@osdl.org> as the point of\n * contact. September 2005.\n *\n * See http://www.iana.org/assignments/port-numbers\n */\n#define DEFAULT_GIT_PORT 9418\n\n/*\n * Basic data structures for the directory cache\n */\n\n#define CACHE_SIGNATURE 0x44495243\t/* \"DIRC\" */\nstruct cache_header {\n\tuint32_t hdr_signature;\n\tuint32_t hdr_version;\n\tuint32_t hdr_entries;\n};\n\n#define INDEX_FORMAT_LB 2\n#define INDEX_FORMAT_UB 4\n\n/*\n * The \"cache_time\" is just the low 32 bits of the\n * time. It doesn't matter if it overflows - we only\n * check it for equality in the 32 bits we save.\n */\nstruct cache_time {\n\tuint32_t sec;\n\tuint32_t nsec;\n};\n\nstruct stat_data {\n\tstruct cache_time sd_ctime;\n\tstruct cache_time sd_mtime;\n\tunsigned int sd_dev;\n\tunsigned int sd_ino;\n\tunsigned int sd_uid;\n\tunsigned int sd_gid;\n\tunsigned int sd_size;\n};\n\nstruct cache_entry {\n\tstruct hashmap_entry ent;\n\tstruct stat_data ce_stat_data;\n\tunsigned int ce_mode;\n\tunsigned int ce_flags;\n\tunsigned int mem_pool_allocated;\n\tunsigned int ce_namelen;\n\tunsigned int index;\t/* for link extension */\n\tstruct object_id oid;\n\tchar name[FLEX_ARRAY]; /* more */\n};\n\n#define CE_STAGEMASK (0x3000)\n#define CE_EXTENDED  (0x4000)\n#define CE_VALID     (0x8000)\n#define CE_STAGESHIFT 12\n\n/*\n * Range 0xFFFF0FFF in ce_flags is divided into\n * two parts: in-memory flags and on-disk ones.\n * Flags in CE_EXTENDED_FLAGS will get saved on-disk\n * if you want to save a new flag, add it in\n * CE_EXTENDED_FLAGS\n *\n * In-memory only flags\n */\n#define CE_UPDATE            (1 << 16)\n#define CE_REMOVE            (1 << 17)\n#define CE_UPTODATE          (1 << 18)\n#define CE_ADDED             (1 << 19)\n\n#define CE_HASHED            (1 << 20)\n#define CE_FSMONITOR_VALID   (1 << 21)\n#define CE_WT_REMOVE         (1 << 22) /* remove in work directory */\n#define CE_CONFLICTED        (1 << 23)\n\n#define CE_UNPACKED          (1 << 24)\n#define CE_NEW_SKIP_WORKTREE (1 << 25)\n\n/* used to temporarily mark paths matched by pathspecs */\n#define CE_MATCHED           (1 << 26)\n\n#define CE_UPDATE_IN_BASE    (1 << 27)\n#define CE_STRIP_NAME        (1 << 28)\n\n/*\n * Extended on-disk flags\n */\n#define CE_INTENT_TO_ADD     (1 << 29)\n#define CE_SKIP_WORKTREE     (1 << 30)\n/* CE_EXTENDED2 is for future extension */\n#define CE_EXTENDED2         (1U << 31)\n\n#define CE_EXTENDED_FLAGS (CE_INTENT_TO_ADD | CE_SKIP_WORKTREE)\n\n/*\n * Safeguard to avoid saving wrong flags:\n *  - CE_EXTENDED2 won't get saved until its semantic is known\n *  - Bits in 0x0000FFFF have been saved in ce_flags already\n *  - Bits in 0x003F0000 are currently in-memory flags\n */\n#if CE_EXTENDED_FLAGS & 0x803FFFFF\n#error \"CE_EXTENDED_FLAGS out of range\"\n#endif\n\n/* Forward structure decls */\nstruct pathspec;\nstruct child_process;\nstruct tree;\n\n/*\n * Copy the sha1 and stat state of a cache entry from one to\n * another. But we never change the name, or the hash state!\n */\nstatic inline void copy_cache_entry(struct cache_entry *dst,\n\t\t\t\t    const struct cache_entry *src)\n{\n\tunsigned int state = dst->ce_flags & CE_HASHED;\n\tint mem_pool_allocated = dst->mem_pool_allocated;\n\n\t/* Don't copy hash chain and name */\n\tmemcpy(&dst->ce_stat_data, &src->ce_stat_data,\n\t\t\toffsetof(struct cache_entry, name) -\n\t\t\toffsetof(struct cache_entry, ce_stat_data));\n\n\t/* Restore the hash state */\n\tdst->ce_flags = (dst->ce_flags & ~CE_HASHED) | state;\n\n\t/* Restore the mem_pool_allocated flag */\n\tdst->mem_pool_allocated = mem_pool_allocated;\n}\n\nstatic inline unsigned create_ce_flags(unsigned stage)\n{\n\treturn (stage << CE_STAGESHIFT);\n}\n\n#define ce_namelen(ce) ((ce)->ce_namelen)\n#define ce_size(ce) cache_entry_size(ce_namelen(ce))\n#define ce_stage(ce) ((CE_STAGEMASK & (ce)->ce_flags) >> CE_STAGESHIFT)\n#define ce_uptodate(ce) ((ce)->ce_flags & CE_UPTODATE)\n#define ce_skip_worktree(ce) ((ce)->ce_flags & CE_SKIP_WORKTREE)\n#define ce_mark_uptodate(ce) ((ce)->ce_flags |= CE_UPTODATE)\n#define ce_intent_to_add(ce) ((ce)->ce_flags & CE_INTENT_TO_ADD)\n\n#define ce_permissions(mode) (((mode) & 0100) ? 0755 : 0644)\nstatic inline unsigned int create_ce_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\tif (S_ISDIR(mode) || S_ISGITLINK(mode))\n\t\treturn S_IFGITLINK;\n\treturn S_IFREG | ce_permissions(mode);\n}\nstatic inline unsigned int ce_mode_from_stat(const struct cache_entry *ce,\n\t\t\t\t\t     unsigned int mode)\n{\n\textern int trust_executable_bit, has_symlinks;\n\tif (!has_symlinks && S_ISREG(mode) &&\n\t    ce && S_ISLNK(ce->ce_mode))\n\t\treturn ce->ce_mode;\n\tif (!trust_executable_bit && S_ISREG(mode)) {\n\t\tif (ce && S_ISREG(ce->ce_mode))\n\t\t\treturn ce->ce_mode;\n\t\treturn create_ce_mode(0666);\n\t}\n\treturn create_ce_mode(mode);\n}\nstatic inline int ce_to_dtype(const struct cache_entry *ce)\n{\n\tunsigned ce_mode = ntohl(ce->ce_mode);\n\tif (S_ISREG(ce_mode))\n\t\treturn DT_REG;\n\telse if (S_ISDIR(ce_mode) || S_ISGITLINK(ce_mode))\n\t\treturn DT_DIR;\n\telse if (S_ISLNK(ce_mode))\n\t\treturn DT_LNK;\n\telse\n\t\treturn DT_UNKNOWN;\n}\nstatic inline unsigned int canon_mode(unsigned int mode)\n{\n\tif (S_ISREG(mode))\n\t\treturn S_IFREG | ce_permissions(mode);\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\tif (S_ISDIR(mode))\n\t\treturn S_IFDIR;\n\treturn S_IFGITLINK;\n}\n\n#define cache_entry_size(len) (offsetof(struct cache_entry,name) + (len) + 1)\n\n#define SOMETHING_CHANGED\t(1 << 0) /* unclassified changes go here */\n#define CE_ENTRY_CHANGED\t(1 << 1)\n#define CE_ENTRY_REMOVED\t(1 << 2)\n#define CE_ENTRY_ADDED\t\t(1 << 3)\n#define RESOLVE_UNDO_CHANGED\t(1 << 4)\n#define CACHE_TREE_CHANGED\t(1 << 5)\n#define SPLIT_INDEX_ORDERED\t(1 << 6)\n#define UNTRACKED_CHANGED\t(1 << 7)\n#define FSMONITOR_CHANGED\t(1 << 8)\n\nstruct split_index;\nstruct untracked_cache;\n\nstruct index_state {\n\tstruct cache_entry **cache;\n\tunsigned int version;\n\tunsigned int cache_nr, cache_alloc, cache_changed;\n\tstruct string_list *resolve_undo;\n\tstruct cache_tree *cache_tree;\n\tstruct split_index *split_index;\n\tstruct cache_time timestamp;\n\tunsigned name_hash_initialized : 1,\n\t\t initialized : 1,\n\t\t drop_cache_tree : 1;\n\tstruct hashmap name_hash;\n\tstruct hashmap dir_hash;\n\tstruct object_id oid;\n\tstruct untracked_cache *untracked;\n\tuint64_t fsmonitor_last_update;\n\tstruct ewah_bitmap *fsmonitor_dirty;\n\tstruct mem_pool *ce_mem_pool;\n};\n\nextern struct index_state the_index;\n\n/* Name hashing */\nextern int test_lazy_init_name_hash(struct index_state *istate, int try_threaded);\nextern void add_name_hash(struct index_state *istate, struct cache_entry *ce);\nextern void remove_name_hash(struct index_state *istate, struct cache_entry *ce);\nextern void free_name_hash(struct index_state *istate);\n\n\n/* Cache entry creation and cleanup */\n\n/*\n * Create cache_entry intended for use in the specified index. Caller\n * is responsible for discarding the cache_entry with\n * `discard_cache_entry`.\n */\nstruct cache_entry *make_cache_entry(struct index_state *istate,\n\t\t\t\t     unsigned int mode,\n\t\t\t\t     const struct object_id *oid,\n\t\t\t\t     const char *path,\n\t\t\t\t     int stage,\n\t\t\t\t     unsigned int refresh_options);\n\nstruct cache_entry *make_empty_cache_entry(struct index_state *istate,\n\t\t\t\t\t   size_t name_len);\n\n/*\n * Create a cache_entry that is not intended to be added to an index.\n * Caller is responsible for discarding the cache_entry\n * with `discard_cache_entry`.\n */\nstruct cache_entry *make_transient_cache_entry(unsigned int mode,\n\t\t\t\t\t       const struct object_id *oid,\n\t\t\t\t\t       const char *path,\n\t\t\t\t\t       int stage);\n\nstruct cache_entry *make_empty_transient_cache_entry(size_t name_len);\n\n/*\n * Discard cache entry.\n */\nvoid discard_cache_entry(struct cache_entry *ce);\n\n/*\n * Check configuration if we should perform extra validation on cache\n * entries.\n */\nint should_validate_cache_entries(void);\n\n/*\n * Duplicate a cache_entry. Allocate memory for the new entry from a\n * memory_pool. Takes into account cache_entry fields that are meant\n * for managing the underlying memory allocation of the cache_entry.\n */\nstruct cache_entry *dup_cache_entry(const struct cache_entry *ce, struct index_state *istate);\n\n/*\n * Validate the cache entries in the index.  This is an internal\n * consistency check that the cache_entry structs are allocated from\n * the expected memory pool.\n */\nvoid validate_cache_entries(const struct index_state *istate);\n\n#ifndef NO_THE_INDEX_COMPATIBILITY_MACROS\n#define active_cache (the_index.cache)\n#define active_nr (the_index.cache_nr)\n#define active_alloc (the_index.cache_alloc)\n#define active_cache_changed (the_index.cache_changed)\n#define active_cache_tree (the_index.cache_tree)\n\n#define read_cache() read_index(&the_index)\n#define read_cache_from(path) read_index_from(&the_index, (path), (get_git_dir()))\n#define read_cache_preload(pathspec) read_index_preload(&the_index, (pathspec), 0)\n#define is_cache_unborn() is_index_unborn(&the_index)\n#define read_cache_unmerged() read_index_unmerged(&the_index)\n#define discard_cache() discard_index(&the_index)\n#define unmerged_cache() unmerged_index(&the_index)\n#define cache_name_pos(name, namelen) index_name_pos(&the_index,(name),(namelen))\n#define add_cache_entry(ce, option) add_index_entry(&the_index, (ce), (option))\n#define rename_cache_entry_at(pos, new_name) rename_index_entry_at(&the_index, (pos), (new_name))\n#define remove_cache_entry_at(pos) remove_index_entry_at(&the_index, (pos))\n#define remove_file_from_cache(path) remove_file_from_index(&the_index, (path))\n#define add_to_cache(path, st, flags) add_to_index(&the_index, (path), (st), (flags))\n#define add_file_to_cache(path, flags) add_file_to_index(&the_index, (path), (flags))\n#define chmod_cache_entry(ce, flip) chmod_index_entry(&the_index, (ce), (flip))\n#define refresh_cache(flags) refresh_index(&the_index, (flags), NULL, NULL, NULL)\n#define ce_match_stat(ce, st, options) ie_match_stat(&the_index, (ce), (st), (options))\n#define ce_modified(ce, st, options) ie_modified(&the_index, (ce), (st), (options))\n#define cache_dir_exists(name, namelen) index_dir_exists(&the_index, (name), (namelen))\n#define cache_file_exists(name, namelen, igncase) index_file_exists(&the_index, (name), (namelen), (igncase))\n#define cache_name_is_other(name, namelen) index_name_is_other(&the_index, (name), (namelen))\n#define resolve_undo_clear() resolve_undo_clear_index(&the_index)\n#define unmerge_cache_entry_at(at) unmerge_index_entry_at(&the_index, at)\n#define unmerge_cache(pathspec) unmerge_index(&the_index, pathspec)\n#define read_blob_data_from_cache(path, sz) read_blob_data_from_index(&the_index, (path), (sz))\n#endif\n\n#define TYPE_BITS 3\n\n/*\n * Values in this enum (except those outside the 3 bit range) are part\n * of pack file format. See Documentation/technical/pack-format.txt\n * for more information.\n */\nenum object_type {\n\tOBJ_BAD = -1,\n\tOBJ_NONE = 0,\n\tOBJ_COMMIT = 1,\n\tOBJ_TREE = 2,\n\tOBJ_BLOB = 3,\n\tOBJ_TAG = 4,\n\t/* 5 for future expansion */\n\tOBJ_OFS_DELTA = 6,\n\tOBJ_REF_DELTA = 7,\n\tOBJ_ANY,\n\tOBJ_MAX\n};\n\nstatic inline enum object_type object_type(unsigned int mode)\n{\n\treturn S_ISDIR(mode) ? OBJ_TREE :\n\t\tS_ISGITLINK(mode) ? OBJ_COMMIT :\n\t\tOBJ_BLOB;\n}\n\n/* Double-check local_repo_env below if you add to this list. */\n#define GIT_DIR_ENVIRONMENT \"GIT_DIR\"\n#define GIT_COMMON_DIR_ENVIRONMENT \"GIT_COMMON_DIR\"\n#define GIT_NAMESPACE_ENVIRONMENT \"GIT_NAMESPACE\"\n#define GIT_WORK_TREE_ENVIRONMENT \"GIT_WORK_TREE\"\n#define GIT_PREFIX_ENVIRONMENT \"GIT_PREFIX\"\n#define GIT_SUPER_PREFIX_ENVIRONMENT \"GIT_INTERNAL_SUPER_PREFIX\"\n#define DEFAULT_GIT_DIR_ENVIRONMENT \".git\"\n#define DB_ENVIRONMENT \"GIT_OBJECT_DIRECTORY\"\n#define INDEX_ENVIRONMENT \"GIT_INDEX_FILE\"\n#define GRAFT_ENVIRONMENT \"GIT_GRAFT_FILE\"\n#define GIT_SHALLOW_FILE_ENVIRONMENT \"GIT_SHALLOW_FILE\"\n#define TEMPLATE_DIR_ENVIRONMENT \"GIT_TEMPLATE_DIR\"\n#define CONFIG_ENVIRONMENT \"GIT_CONFIG\"\n#define CONFIG_DATA_ENVIRONMENT \"GIT_CONFIG_PARAMETERS\"\n#define EXEC_PATH_ENVIRONMENT \"GIT_EXEC_PATH\"\n#define CEILING_DIRECTORIES_ENVIRONMENT \"GIT_CEILING_DIRECTORIES\"\n#define NO_REPLACE_OBJECTS_ENVIRONMENT \"GIT_NO_REPLACE_OBJECTS\"\n#define GIT_REPLACE_REF_BASE_ENVIRONMENT \"GIT_REPLACE_REF_BASE\"\n#define GITATTRIBUTES_FILE \".gitattributes\"\n#define INFOATTRIBUTES_FILE \"info/attributes\"\n#define ATTRIBUTE_MACRO_PREFIX \"[attr]\"\n#define GITMODULES_FILE \".gitmodules\"\n#define GITMODULES_INDEX \":.gitmodules\"\n#define GITMODULES_HEAD \"HEAD:.gitmodules\"\n#define GIT_NOTES_REF_ENVIRONMENT \"GIT_NOTES_REF\"\n#define GIT_NOTES_DEFAULT_REF \"refs/notes/commits\"\n#define GIT_NOTES_DISPLAY_REF_ENVIRONMENT \"GIT_NOTES_DISPLAY_REF\"\n#define GIT_NOTES_REWRITE_REF_ENVIRONMENT \"GIT_NOTES_REWRITE_REF\"\n#define GIT_NOTES_REWRITE_MODE_ENVIRONMENT \"GIT_NOTES_REWRITE_MODE\"\n#define GIT_LITERAL_PATHSPECS_ENVIRONMENT \"GIT_LITERAL_PATHSPECS\"\n#define GIT_GLOB_PATHSPECS_ENVIRONMENT \"GIT_GLOB_PATHSPECS\"\n#define GIT_NOGLOB_PATHSPECS_ENVIRONMENT \"GIT_NOGLOB_PATHSPECS\"\n#define GIT_ICASE_PATHSPECS_ENVIRONMENT \"GIT_ICASE_PATHSPECS\"\n#define GIT_QUARANTINE_ENVIRONMENT \"GIT_QUARANTINE_PATH\"\n#define GIT_OPTIONAL_LOCKS_ENVIRONMENT \"GIT_OPTIONAL_LOCKS\"\n#define GIT_TEXT_DOMAIN_DIR_ENVIRONMENT \"GIT_TEXTDOMAINDIR\"\n\n/*\n * Environment variable used in handshaking the wire protocol.\n * Contains a colon ':' separated list of keys with optional values\n * 'key[=value]'.  Presence of unknown keys and values must be\n * ignored.\n */\n#define GIT_PROTOCOL_ENVIRONMENT \"GIT_PROTOCOL\"\n/* HTTP header used to handshake the wire protocol */\n#define GIT_PROTOCOL_HEADER \"Git-Protocol\"\n\n/*\n * This environment variable is expected to contain a boolean indicating\n * whether we should or should not treat:\n *\n *   GIT_DIR=foo.git git ...\n *\n * as if GIT_WORK_TREE=. was given. It's not expected that users will make use\n * of this, but we use it internally to communicate to sub-processes that we\n * are in a bare repo. If not set, defaults to true.\n */\n#define GIT_IMPLICIT_WORK_TREE_ENVIRONMENT \"GIT_IMPLICIT_WORK_TREE\"\n\n/*\n * Repository-local GIT_* environment variables; these will be cleared\n * when git spawns a sub-process that runs inside another repository.\n * The array is NULL-terminated, which makes it easy to pass in the \"env\"\n * parameter of a run-command invocation, or to do a simple walk.\n */\nextern const char * const local_repo_env[];\n\nextern void setup_git_env(const char *git_dir);\n\n/*\n * Returns true iff we have a configured git repository (either via\n * setup_git_directory, or in the environment via $GIT_DIR).\n */\nint have_git_dir(void);\n\nextern int is_bare_repository_cfg;\nextern int is_bare_repository(void);\nextern int is_inside_git_dir(void);\nextern char *git_work_tree_cfg;\nextern int is_inside_work_tree(void);\nextern const char *get_git_dir(void);\nextern const char *get_git_common_dir(void);\nextern char *get_object_directory(void);\nextern char *get_index_file(void);\nextern char *get_graft_file(struct repository *r);\nextern void set_git_dir(const char *path);\nextern int get_common_dir_noenv(struct strbuf *sb, const char *gitdir);\nextern int get_common_dir(struct strbuf *sb, const char *gitdir);\nextern const char *get_git_namespace(void);\nextern const char *strip_namespace(const char *namespaced_ref);\nextern const char *get_super_prefix(void);\nextern const char *get_git_work_tree(void);\n\n/*\n * Return true if the given path is a git directory; note that this _just_\n * looks at the directory itself. If you want to know whether \"foo/.git\"\n * is a repository, you must feed that path, not just \"foo\".\n */\nextern int is_git_directory(const char *path);\n\n/*\n * Return 1 if the given path is the root of a git repository or\n * submodule, else 0. Will not return 1 for bare repositories with the\n * exception of creating a bare repository in \"foo/.git\" and calling\n * is_git_repository(\"foo\").\n *\n * If we run into read errors, we err on the side of saying \"yes, it is\",\n * as we usually consider sub-repos precious, and would prefer to err on the\n * side of not disrupting or deleting them.\n */\nextern int is_nonbare_repository_dir(struct strbuf *path);\n\n#define READ_GITFILE_ERR_STAT_FAILED 1\n#define READ_GITFILE_ERR_NOT_A_FILE 2\n#define READ_GITFILE_ERR_OPEN_FAILED 3\n#define READ_GITFILE_ERR_READ_FAILED 4\n#define READ_GITFILE_ERR_INVALID_FORMAT 5\n#define READ_GITFILE_ERR_NO_PATH 6\n#define READ_GITFILE_ERR_NOT_A_REPO 7\n#define READ_GITFILE_ERR_TOO_LARGE 8\nextern void read_gitfile_error_die(int error_code, const char *path, const char *dir);\nextern const char *read_gitfile_gently(const char *path, int *return_error_code);\n#define read_gitfile(path) read_gitfile_gently((path), NULL)\nextern const char *resolve_gitdir_gently(const char *suspect, int *return_error_code);\n#define resolve_gitdir(path) resolve_gitdir_gently((path), NULL)\n\nextern void set_git_work_tree(const char *tree);\n\n#define ALTERNATE_DB_ENVIRONMENT \"GIT_ALTERNATE_OBJECT_DIRECTORIES\"\n\nextern void setup_work_tree(void);\n/*\n * Find the commondir and gitdir of the repository that contains the current\n * working directory, without changing the working directory or other global\n * state. The result is appended to commondir and gitdir.  If the discovered\n * gitdir does not correspond to a worktree, then 'commondir' and 'gitdir' will\n * both have the same result appended to the buffer.  The return value is\n * either 0 upon success and non-zero if no repository was found.\n */\nextern int discover_git_directory(struct strbuf *commondir,\n\t\t\t\t  struct strbuf *gitdir);\nextern const char *setup_git_directory_gently(int *);\nextern const char *setup_git_directory(void);\nextern char *prefix_path(const char *prefix, int len, const char *path);\nextern char *prefix_path_gently(const char *prefix, int len, int *remaining, const char *path);\n\n/*\n * Concatenate \"prefix\" (if len is non-zero) and \"path\", with no\n * connecting characters (so \"prefix\" should end with a \"/\").\n * Unlike prefix_path, this should be used if the named file does\n * not have to interact with index entry; i.e. name of a random file\n * on the filesystem.\n *\n * The return value is always a newly allocated string (even if the\n * prefix was empty).\n */\nextern char *prefix_filename(const char *prefix, const char *path);\n\nextern int check_filename(const char *prefix, const char *name);\nextern void verify_filename(const char *prefix,\n\t\t\t    const char *name,\n\t\t\t    int diagnose_misspelt_rev);\nextern void verify_non_filename(const char *prefix, const char *name);\nextern int path_inside_repo(const char *prefix, const char *path);\n\n#define INIT_DB_QUIET 0x0001\n#define INIT_DB_EXIST_OK 0x0002\n\nextern int init_db(const char *git_dir, const char *real_git_dir,\n\t\t   const char *template_dir, unsigned int flags);\n\nextern void sanitize_stdfds(void);\nextern int daemonize(void);\n\n#define alloc_nr(x) (((x)+16)*3/2)\n\n/*\n * Realloc the buffer pointed at by variable 'x' so that it can hold\n * at least 'nr' entries; the number of entries currently allocated\n * is 'alloc', using the standard growing factor alloc_nr() macro.\n *\n * DO NOT USE any expression with side-effect for 'x', 'nr', or 'alloc'.\n */\n#define ALLOC_GROW(x, nr, alloc) \\\n\tdo { \\\n\t\tif ((nr) > alloc) { \\\n\t\t\tif (alloc_nr(alloc) < (nr)) \\\n\t\t\t\talloc = (nr); \\\n\t\t\telse \\\n\t\t\t\talloc = alloc_nr(alloc); \\\n\t\t\tREALLOC_ARRAY(x, alloc); \\\n\t\t} \\\n\t} while (0)\n\n/* Initialize and use the cache information */\nstruct lock_file;\nextern int read_index(struct index_state *);\nextern void preload_index(struct index_state *index,\n\t\t\t  const struct pathspec *pathspec,\n\t\t\t  unsigned int refresh_flags);\nextern int read_index_preload(struct index_state *,\n\t\t\t      const struct pathspec *pathspec,\n\t\t\t      unsigned int refresh_flags);\nextern int do_read_index(struct index_state *istate, const char *path,\n\t\t\t int must_exist); /* for testting only! */\nextern int read_index_from(struct index_state *, const char *path,\n\t\t\t   const char *gitdir);\nextern int is_index_unborn(struct index_state *);\nextern int read_index_unmerged(struct index_state *);\n\n/* For use with `write_locked_index()`. */\n#define COMMIT_LOCK\t\t(1 << 0)\n#define SKIP_IF_UNCHANGED\t(1 << 1)\n\n/*\n * Write the index while holding an already-taken lock. Close the lock,\n * and if `COMMIT_LOCK` is given, commit it.\n *\n * Unless a split index is in use, write the index into the lockfile.\n *\n * With a split index, write the shared index to a temporary file,\n * adjust its permissions and rename it into place, then write the\n * split index to the lockfile. If the temporary file for the shared\n * index cannot be created, fall back to the behavior described in\n * the previous paragraph.\n *\n * With `COMMIT_LOCK`, the lock is always committed or rolled back.\n * Without it, the lock is closed, but neither committed nor rolled\n * back.\n *\n * If `SKIP_IF_UNCHANGED` is given and the index is unchanged, nothing\n * is written (and the lock is rolled back if `COMMIT_LOCK` is given).\n */\nextern int write_locked_index(struct index_state *, struct lock_file *lock, unsigned flags);\n\nextern int discard_index(struct index_state *);\nextern void move_index_extensions(struct index_state *dst, struct index_state *src);\nextern int unmerged_index(const struct index_state *);\n\n/**\n * Returns 1 if istate differs from tree, 0 otherwise.  If tree is NULL,\n * compares istate to HEAD.  If tree is NULL and on an unborn branch,\n * returns 1 if there are entries in istate, 0 otherwise.  If an strbuf is\n * provided, the space-separated list of files that differ will be appended\n * to it.\n */\nextern int index_has_changes(struct index_state *istate,\n\t\t\t     struct tree *tree,\n\t\t\t     struct strbuf *sb);\n\nextern int verify_path(const char *path, unsigned mode);\nextern int strcmp_offset(const char *s1, const char *s2, size_t *first_change);\nextern int index_dir_exists(struct index_state *istate, const char *name, int namelen);\nextern void adjust_dirname_case(struct index_state *istate, char *name);\nextern struct cache_entry *index_file_exists(struct index_state *istate, const char *name, int namelen, int igncase);\n\n/*\n * Searches for an entry defined by name and namelen in the given index.\n * If the return value is positive (including 0) it is the position of an\n * exact match. If the return value is negative, the negated value minus 1\n * is the position where the entry would be inserted.\n * Example: The current index consists of these files and its stages:\n *\n *   b#0, d#0, f#1, f#3\n *\n * index_name_pos(&index, \"a\", 1) -> -1\n * index_name_pos(&index, \"b\", 1) ->  0\n * index_name_pos(&index, \"c\", 1) -> -2\n * index_name_pos(&index, \"d\", 1) ->  1\n * index_name_pos(&index, \"e\", 1) -> -3\n * index_name_pos(&index, \"f\", 1) -> -3\n * index_name_pos(&index, \"g\", 1) -> -5\n */\nextern int index_name_pos(const struct index_state *, const char *name, int namelen);\n\n#define ADD_CACHE_OK_TO_ADD 1\t\t/* Ok to add */\n#define ADD_CACHE_OK_TO_REPLACE 2\t/* Ok to replace file/directory */\n#define ADD_CACHE_SKIP_DFCHECK 4\t/* Ok to skip DF conflict checks */\n#define ADD_CACHE_JUST_APPEND 8\t\t/* Append only; tree.c::read_tree() */\n#define ADD_CACHE_NEW_ONLY 16\t\t/* Do not replace existing ones */\n#define ADD_CACHE_KEEP_CACHE_TREE 32\t/* Do not invalidate cache-tree */\nextern int add_index_entry(struct index_state *, struct cache_entry *ce, int option);\nextern void rename_index_entry_at(struct index_state *, int pos, const char *new_name);\n\n/* Remove entry, return true if there are more entries to go. */\nextern int remove_index_entry_at(struct index_state *, int pos);\n\nextern void remove_marked_cache_entries(struct index_state *istate);\nextern int remove_file_from_index(struct index_state *, const char *path);\n#define ADD_CACHE_VERBOSE 1\n#define ADD_CACHE_PRETEND 2\n#define ADD_CACHE_IGNORE_ERRORS\t4\n#define ADD_CACHE_IGNORE_REMOVAL 8\n#define ADD_CACHE_INTENT 16\n/*\n * These two are used to add the contents of the file at path\n * to the index, marking the working tree up-to-date by storing\n * the cached stat info in the resulting cache entry.  A caller\n * that has already run lstat(2) on the path can call\n * add_to_index(), and all others can call add_file_to_index();\n * the latter will do necessary lstat(2) internally before\n * calling the former.\n */\nextern int add_to_index(struct index_state *, const char *path, struct stat *, int flags);\nextern int add_file_to_index(struct index_state *, const char *path, int flags);\n\nextern int chmod_index_entry(struct index_state *, struct cache_entry *ce, char flip);\nextern int ce_same_name(const struct cache_entry *a, const struct cache_entry *b);\nextern void set_object_name_for_intent_to_add_entry(struct cache_entry *ce);\nextern int index_name_is_other(const struct index_state *, const char *, int);\nextern void *read_blob_data_from_index(const struct index_state *, const char *, unsigned long *);\n\n/* do stat comparison even if CE_VALID is true */\n#define CE_MATCH_IGNORE_VALID\t\t01\n/* do not check the contents but report dirty on racily-clean entries */\n#define CE_MATCH_RACY_IS_DIRTY\t\t02\n/* do stat comparison even if CE_SKIP_WORKTREE is true */\n#define CE_MATCH_IGNORE_SKIP_WORKTREE\t04\n/* ignore non-existent files during stat update  */\n#define CE_MATCH_IGNORE_MISSING\t\t0x08\n/* enable stat refresh */\n#define CE_MATCH_REFRESH\t\t0x10\n/* don't refresh_fsmonitor state or do stat comparison even if CE_FSMONITOR_VALID is true */\n#define CE_MATCH_IGNORE_FSMONITOR 0X20\nextern int is_racy_timestamp(const struct index_state *istate,\n\t\t\t     const struct cache_entry *ce);\nextern int ie_match_stat(struct index_state *, const struct cache_entry *, struct stat *, unsigned int);\nextern int ie_modified(struct index_state *, const struct cache_entry *, struct stat *, unsigned int);\n\n#define HASH_WRITE_OBJECT 1\n#define HASH_FORMAT_CHECK 2\n#define HASH_RENORMALIZE  4\nextern int index_fd(struct index_state *istate, struct object_id *oid, int fd, struct stat *st, enum object_type type, const char *path, unsigned flags);\nextern int index_path(struct index_state *istate, struct object_id *oid, const char *path, struct stat *st, unsigned flags);\n\n/*\n * Record to sd the data from st that we use to check whether a file\n * might have changed.\n */\nextern void fill_stat_data(struct stat_data *sd, struct stat *st);\n\n/*\n * Return 0 if st is consistent with a file not having been changed\n * since sd was filled.  If there are differences, return a\n * combination of MTIME_CHANGED, CTIME_CHANGED, OWNER_CHANGED,\n * INODE_CHANGED, and DATA_CHANGED.\n */\nextern int match_stat_data(const struct stat_data *sd, struct stat *st);\nextern int match_stat_data_racy(const struct index_state *istate,\n\t\t\t\tconst struct stat_data *sd, struct stat *st);\n\nextern void fill_stat_cache_info(struct cache_entry *ce, struct stat *st);\n\n#define REFRESH_REALLY\t\t0x0001\t/* ignore_valid */\n#define REFRESH_UNMERGED\t0x0002\t/* allow unmerged */\n#define REFRESH_QUIET\t\t0x0004\t/* be quiet about it */\n#define REFRESH_IGNORE_MISSING\t0x0008\t/* ignore non-existent */\n#define REFRESH_IGNORE_SUBMODULES\t0x0010\t/* ignore submodules */\n#define REFRESH_IN_PORCELAIN\t0x0020\t/* user friendly output, not \"needs update\" */\n#define REFRESH_PROGRESS\t0x0040  /* show progress bar if stderr is tty */\nextern int refresh_index(struct index_state *, unsigned int flags, const struct pathspec *pathspec, char *seen, const char *header_msg);\nextern struct cache_entry *refresh_cache_entry(struct index_state *, struct cache_entry *, unsigned int);\n\n/*\n * Opportunistically update the index but do not complain if we can't.\n * The lockfile is always committed or rolled back.\n */\nextern void update_index_if_able(struct index_state *, struct lock_file *);\n\nextern int hold_locked_index(struct lock_file *, int);\nextern void set_alternate_index_output(const char *);\n\nextern int verify_index_checksum;\nextern int verify_ce_order;\n\n/* Environment bits from configuration mechanism */\nextern int trust_executable_bit;\nextern int trust_ctime;\nextern int check_stat;\nextern int quote_path_fully;\nextern int has_symlinks;\nextern int minimum_abbrev, default_abbrev;\nextern int ignore_case;\nextern int assume_unchanged;\nextern int prefer_symlink_refs;\nextern int warn_ambiguous_refs;\nextern int warn_on_object_refname_ambiguity;\nextern const char *apply_default_whitespace;\nextern const char *apply_default_ignorewhitespace;\nextern const char *git_attributes_file;\nextern const char *git_hooks_path;\nextern int zlib_compression_level;\nextern int core_compression_level;\nextern int pack_compression_level;\nextern size_t packed_git_window_size;\nextern size_t packed_git_limit;\nextern size_t delta_base_cache_limit;\nextern unsigned long big_file_threshold;\nextern unsigned long pack_size_limit_cfg;\n\n/*\n * Accessors for the core.sharedrepository config which lazy-load the value\n * from the config (if not already set). The \"reset\" function can be\n * used to unset \"set\" or cached value, meaning that the value will be loaded\n * fresh from the config file on the next call to get_shared_repository().\n */\nvoid set_shared_repository(int value);\nint get_shared_repository(void);\nvoid reset_shared_repository(void);\n\n/*\n * Do replace refs need to be checked this run?  This variable is\n * initialized to true unless --no-replace-object is used or\n * $GIT_NO_REPLACE_OBJECTS is set, but is set to false by some\n * commands that do not want replace references to be active.\n */\nextern int read_replace_refs;\nextern char *git_replace_ref_base;\n\nextern int fsync_object_files;\nextern int core_preload_index;\nextern int core_apply_sparse_checkout;\nextern int precomposed_unicode;\nextern int protect_hfs;\nextern int protect_ntfs;\nextern const char *core_fsmonitor;\n\n/*\n * Include broken refs in all ref iterations, which will\n * generally choke dangerous operations rather than letting\n * them silently proceed without taking the broken ref into\n * account.\n */\nextern int ref_paranoia;\n\n/*\n * Returns the boolean value of $GIT_OPTIONAL_LOCKS (or the default value).\n */\nint use_optional_locks(void);\n\n/*\n * The character that begins a commented line in user-editable file\n * that is subject to stripspace.\n */\nextern char comment_line_char;\nextern int auto_comment_line_char;\n\nenum log_refs_config {\n\tLOG_REFS_UNSET = -1,\n\tLOG_REFS_NONE = 0,\n\tLOG_REFS_NORMAL,\n\tLOG_REFS_ALWAYS\n};\nextern enum log_refs_config log_all_ref_updates;\n\nenum rebase_setup_type {\n\tAUTOREBASE_NEVER = 0,\n\tAUTOREBASE_LOCAL,\n\tAUTOREBASE_REMOTE,\n\tAUTOREBASE_ALWAYS\n};\n\nenum push_default_type {\n\tPUSH_DEFAULT_NOTHING = 0,\n\tPUSH_DEFAULT_MATCHING,\n\tPUSH_DEFAULT_SIMPLE,\n\tPUSH_DEFAULT_UPSTREAM,\n\tPUSH_DEFAULT_CURRENT,\n\tPUSH_DEFAULT_UNSPECIFIED\n};\n\nextern enum rebase_setup_type autorebase;\nextern enum push_default_type push_default;\n\nenum object_creation_mode {\n\tOBJECT_CREATION_USES_HARDLINKS = 0,\n\tOBJECT_CREATION_USES_RENAMES = 1\n};\n\nextern enum object_creation_mode object_creation_mode;\n\nextern char *notes_ref_name;\n\nextern int grafts_replace_parents;\n\n/*\n * GIT_REPO_VERSION is the version we write by default. The\n * _READ variant is the highest number we know how to\n * handle.\n */\n#define GIT_REPO_VERSION 0\n#define GIT_REPO_VERSION_READ 1\nextern int repository_format_precious_objects;\nextern char *repository_format_partial_clone;\nextern const char *core_partial_clone_filter_default;\nextern int repository_format_worktree_config;\n\nstruct repository_format {\n\tint version;\n\tint precious_objects;\n\tchar *partial_clone; /* value of extensions.partialclone */\n\tint worktree_config;\n\tint is_bare;\n\tint hash_algo;\n\tchar *work_tree;\n\tstruct string_list unknown_extensions;\n};\n\n/*\n * Read the repository format characteristics from the config file \"path\" into\n * \"format\" struct. Returns the numeric version. On error, -1 is returned,\n * format->version is set to -1, and all other fields in the struct are\n * undefined.\n */\nint read_repository_format(struct repository_format *format, const char *path);\n\n/*\n * Verify that the repository described by repository_format is something we\n * can read. If it is, return 0. Otherwise, return -1, and \"err\" will describe\n * any errors encountered.\n */\nint verify_repository_format(const struct repository_format *format,\n\t\t\t     struct strbuf *err);\n\n/*\n * Check the repository format version in the path found in get_git_dir(),\n * and die if it is a version we don't understand. Generally one would\n * set_git_dir() before calling this, and use it only for \"are we in a valid\n * repo?\".\n */\nextern void check_repository_format(void);\n\n#define MTIME_CHANGED\t0x0001\n#define CTIME_CHANGED\t0x0002\n#define OWNER_CHANGED\t0x0004\n#define MODE_CHANGED    0x0008\n#define INODE_CHANGED   0x0010\n#define DATA_CHANGED    0x0020\n#define TYPE_CHANGED    0x0040\n\n/*\n * Return an abbreviated sha1 unique within this repository's object database.\n * The result will be at least `len` characters long, and will be NUL\n * terminated.\n *\n * The non-`_r` version returns a static buffer which remains valid until 4\n * more calls to find_unique_abbrev are made.\n *\n * The `_r` variant writes to a buffer supplied by the caller, which must be at\n * least `GIT_MAX_HEXSZ + 1` bytes. The return value is the number of bytes\n * written (excluding the NUL terminator).\n *\n * Note that while this version avoids the static buffer, it is not fully\n * reentrant, as it calls into other non-reentrant git code.\n */\nextern const char *find_unique_abbrev(const struct object_id *oid, int len);\nextern int find_unique_abbrev_r(char *hex, const struct object_id *oid, int len);\n\nextern const unsigned char null_sha1[GIT_MAX_RAWSZ];\nextern const struct object_id null_oid;\n\nstatic inline int hashcmp(const unsigned char *sha1, const unsigned char *sha2)\n{\n\t/*\n\t * Teach the compiler that there are only two possibilities of hash size\n\t * here, so that it can optimize for this case as much as possible.\n\t */\n\tif (the_hash_algo->rawsz == GIT_MAX_RAWSZ)\n\t\treturn memcmp(sha1, sha2, GIT_MAX_RAWSZ);\n\treturn memcmp(sha1, sha2, GIT_SHA1_RAWSZ);\n}\n\nstatic inline int oidcmp(const struct object_id *oid1, const struct object_id *oid2)\n{\n\treturn hashcmp(oid1->hash, oid2->hash);\n}\n\nstatic inline int hasheq(const unsigned char *sha1, const unsigned char *sha2)\n{\n\t/*\n\t * We write this here instead of deferring to hashcmp so that the\n\t * compiler can properly inline it and avoid calling memcmp.\n\t */\n\tif (the_hash_algo->rawsz == GIT_MAX_RAWSZ)\n\t\treturn !memcmp(sha1, sha2, GIT_MAX_RAWSZ);\n\treturn !memcmp(sha1, sha2, GIT_SHA1_RAWSZ);\n}\n\nstatic inline int oideq(const struct object_id *oid1, const struct object_id *oid2)\n{\n\treturn hasheq(oid1->hash, oid2->hash);\n}\n\nstatic inline int is_null_sha1(const unsigned char *sha1)\n{\n\treturn hasheq(sha1, null_sha1);\n}\n\nstatic inline int is_null_oid(const struct object_id *oid)\n{\n\treturn hasheq(oid->hash, null_sha1);\n}\n\nstatic inline void hashcpy(unsigned char *sha_dst, const unsigned char *sha_src)\n{\n\tmemcpy(sha_dst, sha_src, the_hash_algo->rawsz);\n}\n\nstatic inline void oidcpy(struct object_id *dst, const struct object_id *src)\n{\n\tmemcpy(dst->hash, src->hash, GIT_MAX_RAWSZ);\n}\n\nstatic inline struct object_id *oiddup(const struct object_id *src)\n{\n\tstruct object_id *dst = xmalloc(sizeof(struct object_id));\n\toidcpy(dst, src);\n\treturn dst;\n}\n\nstatic inline void hashclr(unsigned char *hash)\n{\n\tmemset(hash, 0, the_hash_algo->rawsz);\n}\n\nstatic inline void oidclr(struct object_id *oid)\n{\n\tmemset(oid->hash, 0, GIT_MAX_RAWSZ);\n}\n\nstatic inline void oidread(struct object_id *oid, const unsigned char *hash)\n{\n\tmemcpy(oid->hash, hash, the_hash_algo->rawsz);\n}\n\nstatic inline int is_empty_blob_sha1(const unsigned char *sha1)\n{\n\treturn hasheq(sha1, the_hash_algo->empty_blob->hash);\n}\n\nstatic inline int is_empty_blob_oid(const struct object_id *oid)\n{\n\treturn oideq(oid, the_hash_algo->empty_blob);\n}\n\nstatic inline int is_empty_tree_sha1(const unsigned char *sha1)\n{\n\treturn hasheq(sha1, the_hash_algo->empty_tree->hash);\n}\n\nstatic inline int is_empty_tree_oid(const struct object_id *oid)\n{\n\treturn oideq(oid, the_hash_algo->empty_tree);\n}\n\nconst char *empty_tree_oid_hex(void);\nconst char *empty_blob_oid_hex(void);\n\n/* set default permissions by passing mode arguments to open(2) */\nint git_mkstemps_mode(char *pattern, int suffix_len, int mode);\nint git_mkstemp_mode(char *pattern, int mode);\n\n/*\n * NOTE NOTE NOTE!!\n *\n * PERM_UMASK, OLD_PERM_GROUP and OLD_PERM_EVERYBODY enumerations must\n * not be changed. Old repositories have core.sharedrepository written in\n * numeric format, and therefore these values are preserved for compatibility\n * reasons.\n */\nenum sharedrepo {\n\tPERM_UMASK          = 0,\n\tOLD_PERM_GROUP      = 1,\n\tOLD_PERM_EVERYBODY  = 2,\n\tPERM_GROUP          = 0660,\n\tPERM_EVERYBODY      = 0664\n};\nint git_config_perm(const char *var, const char *value);\nint adjust_shared_perm(const char *path);\n\n/*\n * Create the directory containing the named path, using care to be\n * somewhat safe against races. Return one of the scld_error values to\n * indicate success/failure. On error, set errno to describe the\n * problem.\n *\n * SCLD_VANISHED indicates that one of the ancestor directories of the\n * path existed at one point during the function call and then\n * suddenly vanished, probably because another process pruned the\n * directory while we were working.  To be robust against this kind of\n * race, callers might want to try invoking the function again when it\n * returns SCLD_VANISHED.\n *\n * safe_create_leading_directories() temporarily changes path while it\n * is working but restores it before returning.\n * safe_create_leading_directories_const() doesn't modify path, even\n * temporarily.\n */\nenum scld_error {\n\tSCLD_OK = 0,\n\tSCLD_FAILED = -1,\n\tSCLD_PERMS = -2,\n\tSCLD_EXISTS = -3,\n\tSCLD_VANISHED = -4\n};\nenum scld_error safe_create_leading_directories(char *path);\nenum scld_error safe_create_leading_directories_const(const char *path);\n\n/*\n * Callback function for raceproof_create_file(). This function is\n * expected to do something that makes dirname(path) permanent despite\n * the fact that other processes might be cleaning up empty\n * directories at the same time. Usually it will create a file named\n * path, but alternatively it could create another file in that\n * directory, or even chdir() into that directory. The function should\n * return 0 if the action was completed successfully. On error, it\n * should return a nonzero result and set errno.\n * raceproof_create_file() treats two errno values specially:\n *\n * - ENOENT -- dirname(path) does not exist. In this case,\n *             raceproof_create_file() tries creating dirname(path)\n *             (and any parent directories, if necessary) and calls\n *             the function again.\n *\n * - EISDIR -- the file already exists and is a directory. In this\n *             case, raceproof_create_file() removes the directory if\n *             it is empty (and recursively any empty directories that\n *             it contains) and calls the function again.\n *\n * Any other errno causes raceproof_create_file() to fail with the\n * callback's return value and errno.\n *\n * Obviously, this function should be OK with being called again if it\n * fails with ENOENT or EISDIR. In other scenarios it will not be\n * called again.\n */\ntypedef int create_file_fn(const char *path, void *cb);\n\n/*\n * Create a file in dirname(path) by calling fn, creating leading\n * directories if necessary. Retry a few times in case we are racing\n * with another process that is trying to clean up the directory that\n * contains path. See the documentation for create_file_fn for more\n * details.\n *\n * Return the value and set the errno that resulted from the most\n * recent call of fn. fn is always called at least once, and will be\n * called more than once if it returns ENOENT or EISDIR.\n */\nint raceproof_create_file(const char *path, create_file_fn fn, void *cb);\n\nint mkdir_in_gitdir(const char *path);\nextern char *expand_user_path(const char *path, int real_home);\nconst char *enter_repo(const char *path, int strict);\nstatic inline int is_absolute_path(const char *path)\n{\n\treturn is_dir_sep(path[0]) || has_dos_drive_prefix(path);\n}\nint is_directory(const char *);\nchar *strbuf_realpath(struct strbuf *resolved, const char *path,\n\t\t      int die_on_error);\nconst char *real_path(const char *path);\nconst char *real_path_if_valid(const char *path);\nchar *real_pathdup(const char *path, int die_on_error);\nconst char *absolute_path(const char *path);\nchar *absolute_pathdup(const char *path);\nconst char *remove_leading_path(const char *in, const char *prefix);\nconst char *relative_path(const char *in, const char *prefix, struct strbuf *sb);\nint normalize_path_copy_len(char *dst, const char *src, int *prefix_len);\nint normalize_path_copy(char *dst, const char *src);\nint longest_ancestor_length(const char *path, struct string_list *prefixes);\nchar *strip_path_suffix(const char *path, const char *suffix);\nint daemon_avoid_alias(const char *path);\n\n/*\n * These functions match their is_hfs_dotgit() counterparts; see utf8.h for\n * details.\n */\nint is_ntfs_dotgit(const char *name);\nint is_ntfs_dotgitmodules(const char *name);\nint is_ntfs_dotgitignore(const char *name);\nint is_ntfs_dotgitattributes(const char *name);\n\n/*\n * Returns true iff \"str\" could be confused as a command-line option when\n * passed to a sub-program like \"ssh\". Note that this has nothing to do with\n * shell-quoting, which should be handled separately; we're assuming here that\n * the string makes it verbatim to the sub-program.\n */\nint looks_like_command_line_option(const char *str);\n\n/**\n * Return a newly allocated string with the evaluation of\n * \"$XDG_CONFIG_HOME/git/$filename\" if $XDG_CONFIG_HOME is non-empty, otherwise\n * \"$HOME/.config/git/$filename\". Return NULL upon error.\n */\nextern char *xdg_config_home(const char *filename);\n\n/**\n * Return a newly allocated string with the evaluation of\n * \"$XDG_CACHE_HOME/git/$filename\" if $XDG_CACHE_HOME is non-empty, otherwise\n * \"$HOME/.cache/git/$filename\". Return NULL upon error.\n */\nextern char *xdg_cache_home(const char *filename);\n\nextern int git_open_cloexec(const char *name, int flags);\n#define git_open(name) git_open_cloexec(name, O_RDONLY)\nextern int unpack_sha1_header(git_zstream *stream, unsigned char *map, unsigned long mapsize, void *buffer, unsigned long bufsiz);\nextern int parse_sha1_header(const char *hdr, unsigned long *sizep);\n\nextern int check_object_signature(const struct object_id *oid, void *buf, unsigned long size, const char *type);\n\nextern int finalize_object_file(const char *tmpfile, const char *filename);\n\n/* Helper to check and \"touch\" a file */\nextern int check_and_freshen_file(const char *fn, int freshen);\n\nextern const signed char hexval_table[256];\nstatic inline unsigned int hexval(unsigned char c)\n{\n\treturn hexval_table[c];\n}\n\n/*\n * Convert two consecutive hexadecimal digits into a char.  Return a\n * negative value on error.  Don't run over the end of short strings.\n */\nstatic inline int hex2chr(const char *s)\n{\n\tunsigned int val = hexval(s[0]);\n\treturn (val & ~0xf) ? val : (val << 4) | hexval(s[1]);\n}\n\n/* Convert to/from hex/sha1 representation */\n#define MINIMUM_ABBREV minimum_abbrev\n#define DEFAULT_ABBREV default_abbrev\n\n/* used when the code does not know or care what the default abbrev is */\n#define FALLBACK_DEFAULT_ABBREV 7\n\nstruct object_context {\n\tunsigned mode;\n\t/*\n\t * symlink_path is only used by get_tree_entry_follow_symlinks,\n\t * and only for symlinks that point outside the repository.\n\t */\n\tstruct strbuf symlink_path;\n\t/*\n\t * If GET_OID_RECORD_PATH is set, this will record path (if any)\n\t * found when resolving the name. The caller is responsible for\n\t * releasing the memory.\n\t */\n\tchar *path;\n};\n\n#define GET_OID_QUIETLY           01\n#define GET_OID_COMMIT            02\n#define GET_OID_COMMITTISH        04\n#define GET_OID_TREE             010\n#define GET_OID_TREEISH          020\n#define GET_OID_BLOB             040\n#define GET_OID_FOLLOW_SYMLINKS 0100\n#define GET_OID_RECORD_PATH     0200\n#define GET_OID_ONLY_TO_DIE    04000\n\n#define GET_OID_DISAMBIGUATORS \\\n\t(GET_OID_COMMIT | GET_OID_COMMITTISH | \\\n\tGET_OID_TREE | GET_OID_TREEISH | \\\n\tGET_OID_BLOB)\n\nextern int get_oid(const char *str, struct object_id *oid);\nextern int get_oid_commit(const char *str, struct object_id *oid);\nextern int get_oid_committish(const char *str, struct object_id *oid);\nextern int get_oid_tree(const char *str, struct object_id *oid);\nextern int get_oid_treeish(const char *str, struct object_id *oid);\nextern int get_oid_blob(const char *str, struct object_id *oid);\nextern void maybe_die_on_misspelt_object_name(const char *name, const char *prefix);\nextern int get_oid_with_context(const char *str, unsigned flags, struct object_id *oid, struct object_context *oc);\n\n\ntypedef int each_abbrev_fn(const struct object_id *oid, void *);\nextern int for_each_abbrev(const char *prefix, each_abbrev_fn, void *);\n\nextern int set_disambiguate_hint_config(const char *var, const char *value);\n\n/*\n * Try to read a SHA1 in hexadecimal format from the 40 characters\n * starting at hex.  Write the 20-byte result to sha1 in binary form.\n * Return 0 on success.  Reading stops if a NUL is encountered in the\n * input, so it is safe to pass this function an arbitrary\n * null-terminated string.\n */\nextern int get_sha1_hex(const char *hex, unsigned char *sha1);\nextern int get_oid_hex(const char *hex, struct object_id *sha1);\n\n/*\n * Read `len` pairs of hexadecimal digits from `hex` and write the\n * values to `binary` as `len` bytes. Return 0 on success, or -1 if\n * the input does not consist of hex digits).\n */\nextern int hex_to_bytes(unsigned char *binary, const char *hex, size_t len);\n\n/*\n * Convert a binary hash to its hex equivalent. The `_r` variant is reentrant,\n * and writes the NUL-terminated output to the buffer `out`, which must be at\n * least `GIT_MAX_HEXSZ + 1` bytes, and returns a pointer to out for\n * convenience.\n *\n * The non-`_r` variant returns a static buffer, but uses a ring of 4\n * buffers, making it safe to make multiple calls for a single statement, like:\n *\n *   printf(\"%s -> %s\", sha1_to_hex(one), sha1_to_hex(two));\n */\nchar *hash_to_hex_algop_r(char *buffer, const unsigned char *hash, const struct git_hash_algo *);\nchar *sha1_to_hex_r(char *out, const unsigned char *sha1);\nchar *oid_to_hex_r(char *out, const struct object_id *oid);\nchar *hash_to_hex_algop(const unsigned char *hash, const struct git_hash_algo *);\t/* static buffer result! */\nchar *sha1_to_hex(const unsigned char *sha1);\t\t\t\t\t\t/* same static buffer */\nchar *hash_to_hex(const unsigned char *hash);\t\t\t\t\t\t/* same static buffer */\nchar *oid_to_hex(const struct object_id *oid);\t\t\t\t\t\t/* same static buffer */\n\n/*\n * Parse a 40-character hexadecimal object ID starting from hex, updating the\n * pointer specified by end when parsing stops.  The resulting object ID is\n * stored in oid.  Returns 0 on success.  Parsing will stop on the first NUL or\n * other invalid character.  end is only updated on success; otherwise, it is\n * unmodified.\n */\nextern int parse_oid_hex(const char *hex, struct object_id *oid, const char **end);\n\n/*\n * This reads short-hand syntax that not only evaluates to a commit\n * object name, but also can act as if the end user spelled the name\n * of the branch from the command line.\n *\n * - \"@{-N}\" finds the name of the Nth previous branch we were on, and\n *   places the name of the branch in the given buf and returns the\n *   number of characters parsed if successful.\n *\n * - \"<branch>@{upstream}\" finds the name of the other ref that\n *   <branch> is configured to merge with (missing <branch> defaults\n *   to the current branch), and places the name of the branch in the\n *   given buf and returns the number of characters parsed if\n *   successful.\n *\n * If the input is not of the accepted format, it returns a negative\n * number to signal an error.\n *\n * If the input was ok but there are not N branch switches in the\n * reflog, it returns 0.\n *\n * If \"allowed\" is non-zero, it is a treated as a bitfield of allowable\n * expansions: local branches (\"refs/heads/\"), remote branches\n * (\"refs/remotes/\"), or \"HEAD\". If no \"allowed\" bits are set, any expansion is\n * allowed, even ones to refs outside of those namespaces.\n */\n#define INTERPRET_BRANCH_LOCAL (1<<0)\n#define INTERPRET_BRANCH_REMOTE (1<<1)\n#define INTERPRET_BRANCH_HEAD (1<<2)\nextern int interpret_branch_name(const char *str, int len, struct strbuf *,\n\t\t\t\t unsigned allowed);\nextern int get_oid_mb(const char *str, struct object_id *oid);\n\nextern int validate_headref(const char *ref);\n\nextern int base_name_compare(const char *name1, int len1, int mode1, const char *name2, int len2, int mode2);\nextern int df_name_compare(const char *name1, int len1, int mode1, const char *name2, int len2, int mode2);\nextern int name_compare(const char *name1, size_t len1, const char *name2, size_t len2);\nextern int cache_name_stage_compare(const char *name1, int len1, int stage1, const char *name2, int len2, int stage2);\n\nextern void *read_object_with_reference(const struct object_id *oid,\n\t\t\t\t\tconst char *required_type,\n\t\t\t\t\tunsigned long *size,\n\t\t\t\t\tstruct object_id *oid_ret);\n\nextern struct object *peel_to_type(const char *name, int namelen,\n\t\t\t\t   struct object *o, enum object_type);\n\nenum date_mode_type {\n\tDATE_NORMAL = 0,\n\tDATE_RELATIVE,\n\tDATE_SHORT,\n\tDATE_ISO8601,\n\tDATE_ISO8601_STRICT,\n\tDATE_RFC2822,\n\tDATE_STRFTIME,\n\tDATE_RAW,\n\tDATE_UNIX\n};\n\nstruct date_mode {\n\tenum date_mode_type type;\n\tconst char *strftime_fmt;\n\tint local;\n};\n\n/*\n * Convenience helper for passing a constant type, like:\n *\n *   show_date(t, tz, DATE_MODE(NORMAL));\n */\n#define DATE_MODE(t) date_mode_from_type(DATE_##t)\nstruct date_mode *date_mode_from_type(enum date_mode_type type);\n\nconst char *show_date(timestamp_t time, int timezone, const struct date_mode *mode);\nvoid show_date_relative(timestamp_t time, int tz, const struct timeval *now,\n\t\t\tstruct strbuf *timebuf);\nint parse_date(const char *date, struct strbuf *out);\nint parse_date_basic(const char *date, timestamp_t *timestamp, int *offset);\nint parse_expiry_date(const char *date, timestamp_t *timestamp);\nvoid datestamp(struct strbuf *out);\n#define approxidate(s) approxidate_careful((s), NULL)\ntimestamp_t approxidate_careful(const char *, int *);\ntimestamp_t approxidate_relative(const char *date, const struct timeval *now);\nvoid parse_date_format(const char *format, struct date_mode *mode);\nint date_overflows(timestamp_t date);\n\n#define IDENT_STRICT\t       1\n#define IDENT_NO_DATE\t       2\n#define IDENT_NO_NAME\t       4\nextern const char *git_author_info(int);\nextern const char *git_committer_info(int);\nextern const char *fmt_ident(const char *name, const char *email, const char *date_str, int);\nextern const char *fmt_name(const char *name, const char *email);\nextern const char *ident_default_name(void);\nextern const char *ident_default_email(void);\nextern const char *git_editor(void);\nextern const char *git_sequence_editor(void);\nextern const char *git_pager(int stdout_is_tty);\nextern int is_terminal_dumb(void);\nextern int git_ident_config(const char *, const char *, void *);\nextern void reset_ident_date(void);\n\nstruct ident_split {\n\tconst char *name_begin;\n\tconst char *name_end;\n\tconst char *mail_begin;\n\tconst char *mail_end;\n\tconst char *date_begin;\n\tconst char *date_end;\n\tconst char *tz_begin;\n\tconst char *tz_end;\n};\n/*\n * Signals an success with 0, but time part of the result may be NULL\n * if the input lacks timestamp and zone\n */\nextern int split_ident_line(struct ident_split *, const char *, int);\n\n/*\n * Like show_date, but pull the timestamp and tz parameters from\n * the ident_split. It will also sanity-check the values and produce\n * a well-known sentinel date if they appear bogus.\n */\nconst char *show_ident_date(const struct ident_split *id,\n\t\t\t    const struct date_mode *mode);\n\n/*\n * Compare split idents for equality or strict ordering. Note that we\n * compare only the ident part of the line, ignoring any timestamp.\n *\n * Because there are two fields, we must choose one as the primary key; we\n * currently arbitrarily pick the email.\n */\nextern int ident_cmp(const struct ident_split *, const struct ident_split *);\n\nstruct checkout {\n\tstruct index_state *istate;\n\tconst char *base_dir;\n\tint base_dir_len;\n\tstruct delayed_checkout *delayed_checkout;\n\tunsigned force:1,\n\t\t quiet:1,\n\t\t not_new:1,\n\t\t clone:1,\n\t\t refresh_cache:1;\n};\n#define CHECKOUT_INIT { NULL, \"\" }\n\n#define TEMPORARY_FILENAME_LENGTH 25\nextern int checkout_entry(struct cache_entry *ce, const struct checkout *state, char *topath, int *nr_checkouts);\nextern void enable_delayed_checkout(struct checkout *state);\nextern int finish_delayed_checkout(struct checkout *state, int *nr_checkouts);\n\nstruct cache_def {\n\tstruct strbuf path;\n\tint flags;\n\tint track_flags;\n\tint prefix_len_stat_func;\n};\n#define CACHE_DEF_INIT { STRBUF_INIT, 0, 0, 0 }\nstatic inline void cache_def_clear(struct cache_def *cache)\n{\n\tstrbuf_release(&cache->path);\n}\n\nextern int has_symlink_leading_path(const char *name, int len);\nextern int threaded_has_symlink_leading_path(struct cache_def *, const char *, int);\nextern int check_leading_path(const char *name, int len);\nextern int has_dirs_only_path(const char *name, int len, int prefix_len);\nextern void schedule_dir_for_removal(const char *name, int len);\nextern void remove_scheduled_dirs(void);\n\nstruct pack_window {\n\tstruct pack_window *next;\n\tunsigned char *base;\n\toff_t offset;\n\tsize_t len;\n\tunsigned int last_used;\n\tunsigned int inuse_cnt;\n};\n\nstruct pack_entry {\n\toff_t offset;\n\tstruct packed_git *p;\n};\n\n/*\n * Create a temporary file rooted in the object database directory, or\n * die on failure. The filename is taken from \"pattern\", which should have the\n * usual \"XXXXXX\" trailer, and the resulting filename is written into the\n * \"template\" buffer. Returns the open descriptor.\n */\nextern int odb_mkstemp(struct strbuf *temp_filename, const char *pattern);\n\n/*\n * Create a pack .keep file named \"name\" (which should generally be the output\n * of odb_pack_name). Returns a file descriptor opened for writing, or -1 on\n * error.\n */\nextern int odb_pack_keep(const char *name);\n\n/*\n * Set this to 0 to prevent sha1_object_info_extended() from fetching missing\n * blobs. This has a difference only if extensions.partialClone is set.\n *\n * Its default value is 1.\n */\nextern int fetch_if_missing;\n\n/* Dumb servers support */\nextern int update_server_info(int);\n\nextern const char *get_log_output_encoding(void);\nextern const char *get_commit_output_encoding(void);\n\n/*\n * This is a hack for test programs like test-dump-untracked-cache to\n * ensure that they do not modify the untracked cache when reading it.\n * Do not use it otherwise!\n */\nextern int ignore_untracked_cache_config;\n\nextern int committer_ident_sufficiently_given(void);\nextern int author_ident_sufficiently_given(void);\n\nextern const char *git_commit_encoding;\nextern const char *git_log_output_encoding;\nextern const char *git_mailmap_file;\nextern const char *git_mailmap_blob;\n\n/* IO helper functions */\nextern void maybe_flush_or_die(FILE *, const char *);\n__attribute__((format (printf, 2, 3)))\nextern void fprintf_or_die(FILE *, const char *fmt, ...);\n\n#define COPY_READ_ERROR (-2)\n#define COPY_WRITE_ERROR (-3)\nextern int copy_fd(int ifd, int ofd);\nextern int copy_file(const char *dst, const char *src, int mode);\nextern int copy_file_with_time(const char *dst, const char *src, int mode);\n\nextern void write_or_die(int fd, const void *buf, size_t count);\nextern void fsync_or_die(int fd, const char *);\n\nextern ssize_t read_in_full(int fd, void *buf, size_t count);\nextern ssize_t write_in_full(int fd, const void *buf, size_t count);\nextern ssize_t pread_in_full(int fd, void *buf, size_t count, off_t offset);\n\nstatic inline ssize_t write_str_in_full(int fd, const char *str)\n{\n\treturn write_in_full(fd, str, strlen(str));\n}\n\n/**\n * Open (and truncate) the file at path, write the contents of buf to it,\n * and close it. Dies if any errors are encountered.\n */\nextern void write_file_buf(const char *path, const char *buf, size_t len);\n\n/**\n * Like write_file_buf(), but format the contents into a buffer first.\n * Additionally, write_file() will append a newline if one is not already\n * present, making it convenient to write text files:\n *\n *   write_file(path, \"counter: %d\", ctr);\n */\n__attribute__((format (printf, 2, 3)))\nextern void write_file(const char *path, const char *fmt, ...);\n\n/* pager.c */\nextern void setup_pager(void);\nextern int pager_in_use(void);\nextern int pager_use_color;\nextern int term_columns(void);\nextern int decimal_width(uintmax_t);\nextern int check_pager_config(const char *cmd);\nextern void prepare_pager_args(struct child_process *, const char *pager);\n\nextern const char *editor_program;\nextern const char *askpass_program;\nextern const char *excludes_file;\n\n/* base85 */\nint decode_85(char *dst, const char *line, int linelen);\nvoid encode_85(char *buf, const unsigned char *data, int bytes);\n\n/* pkt-line.c */\nvoid packet_trace_identity(const char *prog);\n\n/* add */\n/*\n * return 0 if success, 1 - if addition of a file failed and\n * ADD_FILES_IGNORE_ERRORS was specified in flags\n */\nint add_files_to_cache(const char *prefix, const struct pathspec *pathspec, int flags);\n\n/* diff.c */\nextern int diff_auto_refresh_index;\n\n/* match-trees.c */\nvoid shift_tree(const struct object_id *, const struct object_id *, struct object_id *, int);\nvoid shift_tree_by(const struct object_id *, const struct object_id *, struct object_id *, const char *);\n\n/*\n * whitespace rules.\n * used by both diff and apply\n * last two digits are tab width\n */\n#define WS_BLANK_AT_EOL         0100\n#define WS_SPACE_BEFORE_TAB     0200\n#define WS_INDENT_WITH_NON_TAB  0400\n#define WS_CR_AT_EOL           01000\n#define WS_BLANK_AT_EOF        02000\n#define WS_TAB_IN_INDENT       04000\n#define WS_TRAILING_SPACE      (WS_BLANK_AT_EOL|WS_BLANK_AT_EOF)\n#define WS_DEFAULT_RULE (WS_TRAILING_SPACE|WS_SPACE_BEFORE_TAB|8)\n#define WS_TAB_WIDTH_MASK        077\n/* All WS_* -- when extended, adapt diff.c emit_symbol */\n#define WS_RULE_MASK           07777\nextern unsigned whitespace_rule_cfg;\nextern unsigned whitespace_rule(struct index_state *, const char *);\nextern unsigned parse_whitespace_rule(const char *);\nextern unsigned ws_check(const char *line, int len, unsigned ws_rule);\nextern void ws_check_emit(const char *line, int len, unsigned ws_rule, FILE *stream, const char *set, const char *reset, const char *ws);\nextern char *whitespace_error_string(unsigned ws);\nextern void ws_fix_copy(struct strbuf *, const char *, int, unsigned, int *);\nextern int ws_blank_line(const char *line, int len, unsigned ws_rule);\n#define ws_tab_width(rule)     ((rule) & WS_TAB_WIDTH_MASK)\n\n/* ls-files */\nvoid overlay_tree_on_index(struct index_state *istate,\n\t\t\t   const char *tree_name, const char *prefix);\n\n/* setup.c */\nstruct startup_info {\n\tint have_repository;\n\tconst char *prefix;\n};\nextern struct startup_info *startup_info;\n\n/* merge.c */\nstruct commit_list;\nint try_merge_command(struct repository *r,\n\t\tconst char *strategy, size_t xopts_nr,\n\t\tconst char **xopts, struct commit_list *common,\n\t\tconst char *head_arg, struct commit_list *remotes);\nint checkout_fast_forward(struct repository *r,\n\t\t\t  const struct object_id *from,\n\t\t\t  const struct object_id *to,\n\t\t\t  int overwrite_ignore);\n\n\nint sane_execvp(const char *file, char *const argv[]);\n\n/*\n * A struct to encapsulate the concept of whether a file has changed\n * since we last checked it. This uses criteria similar to those used\n * for the index.\n */\nstruct stat_validity {\n\tstruct stat_data *sd;\n};\n\nvoid stat_validity_clear(struct stat_validity *sv);\n\n/*\n * Returns 1 if the path is a regular file (or a symlink to a regular\n * file) and matches the saved stat_validity, 0 otherwise.  A missing\n * or inaccessible file is considered a match if the struct was just\n * initialized, or if the previous update found an inaccessible file.\n */\nint stat_validity_check(struct stat_validity *sv, const char *path);\n\n/*\n * Update the stat_validity from a file opened at descriptor fd. If\n * the file is missing, inaccessible, or not a regular file, then\n * future calls to stat_validity_check will match iff one of those\n * conditions continues to be true.\n */\nvoid stat_validity_update(struct stat_validity *sv, int fd);\n\nint versioncmp(const char *s1, const char *s2);\nvoid sleep_millisec(int millisec);\n\n/*\n * Create a directory and (if share is nonzero) adjust its permissions\n * according to the shared_repository setting. Only use this for\n * directories under $GIT_DIR.  Don't use it for working tree\n * directories.\n */\nvoid safe_create_dir(const char *dir, int share);\n\n/*\n * Should we print an ellipsis after an abbreviated SHA-1 value\n * when doing diff-raw output or indicating a detached HEAD?\n */\nextern int print_sha1_ellipsis(void);\n\n#endif /* CACHE_H */\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "009e8b3b150eaab7c5c3705c0d466773743dbe0f",
  "sha1_ok": true,
  "size": 63897
}
