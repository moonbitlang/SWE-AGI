{
  "content": {
    "base64": "I2lmbmRlZiBSRUZTX0gKI2RlZmluZSBSRUZTX0gKCnN0cnVjdCByZWZfbG9jayB7CgljaGFyICpyZWZfbmFtZTsKCWNoYXIgKm9yaWdfcmVmX25hbWU7CglzdHJ1Y3QgbG9ja19maWxlICpsazsKCXVuc2lnbmVkIGNoYXIgb2xkX3NoYTFbMjBdOwoJaW50IGxvY2tfZmQ7CglpbnQgZm9yY2Vfd3JpdGU7Cn07CgojZGVmaW5lIFJFRl9JU1NZTVJFRiAweDAxCiNkZWZpbmUgUkVGX0lTUEFDS0VEIDB4MDIKI2RlZmluZSBSRUZfSVNCUk9LRU4gMHgwNAoKLyoKICogQ2FsbHMgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBmb3IgZWFjaCByZWYgZmlsZSB1bnRpbCBpdCByZXR1cm5zIG5vbnplcm8sCiAqIGFuZCByZXR1cm5zIHRoZSB2YWx1ZQogKi8KdHlwZWRlZiBpbnQgZWFjaF9yZWZfZm4oY29uc3QgY2hhciAqcmVmbmFtZSwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgaW50IGZsYWdzLCB2b2lkICpjYl9kYXRhKTsKZXh0ZXJuIGludCBoZWFkX3JlZihlYWNoX3JlZl9mbiwgdm9pZCAqKTsKZXh0ZXJuIGludCBmb3JfZWFjaF9yZWYoZWFjaF9yZWZfZm4sIHZvaWQgKik7CmV4dGVybiBpbnQgZm9yX2VhY2hfcmVmX2luKGNvbnN0IGNoYXIgKiwgZWFjaF9yZWZfZm4sIHZvaWQgKik7CmV4dGVybiBpbnQgZm9yX2VhY2hfdGFnX3JlZihlYWNoX3JlZl9mbiwgdm9pZCAqKTsKZXh0ZXJuIGludCBmb3JfZWFjaF9icmFuY2hfcmVmKGVhY2hfcmVmX2ZuLCB2b2lkICopOwpleHRlcm4gaW50IGZvcl9lYWNoX3JlbW90ZV9yZWYoZWFjaF9yZWZfZm4sIHZvaWQgKik7CmV4dGVybiBpbnQgZm9yX2VhY2hfcmVwbGFjZV9yZWYoZWFjaF9yZWZfZm4sIHZvaWQgKik7CmV4dGVybiBpbnQgZm9yX2VhY2hfZ2xvYl9yZWYoZWFjaF9yZWZfZm4sIGNvbnN0IGNoYXIgKnBhdHRlcm4sIHZvaWQgKik7CmV4dGVybiBpbnQgZm9yX2VhY2hfZ2xvYl9yZWZfaW4oZWFjaF9yZWZfZm4sIGNvbnN0IGNoYXIgKnBhdHRlcm4sIGNvbnN0IGNoYXIqIHByZWZpeCwgdm9pZCAqKTsKCmV4dGVybiBpbnQgaGVhZF9yZWZfc3VibW9kdWxlKGNvbnN0IGNoYXIgKnN1Ym1vZHVsZSwgZWFjaF9yZWZfZm4gZm4sIHZvaWQgKmNiX2RhdGEpOwpleHRlcm4gaW50IGZvcl9lYWNoX3JlZl9zdWJtb2R1bGUoY29uc3QgY2hhciAqc3VibW9kdWxlLCBlYWNoX3JlZl9mbiBmbiwgdm9pZCAqY2JfZGF0YSk7CmV4dGVybiBpbnQgZm9yX2VhY2hfcmVmX2luX3N1Ym1vZHVsZShjb25zdCBjaGFyICpzdWJtb2R1bGUsIGNvbnN0IGNoYXIgKnByZWZpeCwKCQllYWNoX3JlZl9mbiBmbiwgdm9pZCAqY2JfZGF0YSk7CmV4dGVybiBpbnQgZm9yX2VhY2hfdGFnX3JlZl9zdWJtb2R1bGUoY29uc3QgY2hhciAqc3VibW9kdWxlLCBlYWNoX3JlZl9mbiBmbiwgdm9pZCAqY2JfZGF0YSk7CmV4dGVybiBpbnQgZm9yX2VhY2hfYnJhbmNoX3JlZl9zdWJtb2R1bGUoY29uc3QgY2hhciAqc3VibW9kdWxlLCBlYWNoX3JlZl9mbiBmbiwgdm9pZCAqY2JfZGF0YSk7CmV4dGVybiBpbnQgZm9yX2VhY2hfcmVtb3RlX3JlZl9zdWJtb2R1bGUoY29uc3QgY2hhciAqc3VibW9kdWxlLCBlYWNoX3JlZl9mbiBmbiwgdm9pZCAqY2JfZGF0YSk7CgpleHRlcm4gaW50IGhlYWRfcmVmX25hbWVzcGFjZWQoZWFjaF9yZWZfZm4gZm4sIHZvaWQgKmNiX2RhdGEpOwpleHRlcm4gaW50IGZvcl9lYWNoX25hbWVzcGFjZWRfcmVmKGVhY2hfcmVmX2ZuIGZuLCB2b2lkICpjYl9kYXRhKTsKCnN0YXRpYyBpbmxpbmUgY29uc3QgY2hhciAqaGFzX2dsb2Jfc3BlY2lhbHMoY29uc3QgY2hhciAqcGF0dGVybikKewoJcmV0dXJuIHN0cnBicmsocGF0dGVybiwgIj8qWyIpOwp9CgovKiBjYW4gYmUgdXNlZCB0byBsZWFybiBhYm91dCBicm9rZW4gcmVmIGFuZCBzeW1yZWYgKi8KZXh0ZXJuIGludCBmb3JfZWFjaF9yYXdyZWYoZWFjaF9yZWZfZm4sIHZvaWQgKik7CgpleHRlcm4gdm9pZCB3YXJuX2RhbmdsaW5nX3N5bXJlZihGSUxFICpmcCwgY29uc3QgY2hhciAqbXNnX2ZtdCwgY29uc3QgY2hhciAqcmVmbmFtZSk7CgovKgogKiBBZGQgYSByZWZlcmVuY2UgdG8gdGhlIGluLW1lbW9yeSBwYWNrZWQgcmVmZXJlbmNlIGNhY2hlLiAgVG8gYWN0dWFsbHkKICogd3JpdGUgdGhlIHJlZmVyZW5jZSB0byB0aGUgcGFja2VkLXJlZnMgZmlsZSwgY2FsbCBwYWNrX3JlZnMoKS4KICovCmV4dGVybiB2b2lkIGFkZF9wYWNrZWRfcmVmKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpOwoKLyoKICogRXh0cmEgcmVmcyB3aWxsIGJlIGxpc3RlZCBieSBmb3JfZWFjaF9yZWYoKSBiZWZvcmUgYW55IGFjdHVhbCByZWZzCiAqIGZvciB0aGUgZHVyYXRpb24gb2YgdGhpcyBwcm9jZXNzIG9yIHVudGlsIGNsZWFyX2V4dHJhX3JlZnMoKSBpcwogKiBjYWxsZWQuIE9ubHkgZXh0cmEgcmVmcyBhZGRlZCBiZWZvcmUgZm9yX2VhY2hfcmVmKCkgaXMgY2FsbGVkIHdpbGwKICogYmUgbGlzdGVkIG9uIGEgZ2l2ZW4gY2FsbCBvZiBmb3JfZWFjaF9yZWYoKS4KICovCmV4dGVybiB2b2lkIGFkZF9leHRyYV9yZWYoY29uc3QgY2hhciAqcmVmbmFtZSwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgaW50IGZsYWdzKTsKZXh0ZXJuIHZvaWQgY2xlYXJfZXh0cmFfcmVmcyh2b2lkKTsKZXh0ZXJuIGludCByZWZfZXhpc3RzKGNvbnN0IGNoYXIgKik7CgpleHRlcm4gaW50IHBlZWxfcmVmKGNvbnN0IGNoYXIgKnJlZm5hbWUsIHVuc2lnbmVkIGNoYXIgKnNoYTEpOwoKLyoqIExvY2tzIGEgInJlZnMvIiByZWYgcmV0dXJuaW5nIHRoZSBsb2NrIG9uIHN1Y2Nlc3MgYW5kIE5VTEwgb24gZmFpbHVyZS4gKiovCmV4dGVybiBzdHJ1Y3QgcmVmX2xvY2sgKmxvY2tfcmVmX3NoYTEoY29uc3QgY2hhciAqcmVmbmFtZSwgY29uc3QgdW5zaWduZWQgY2hhciAqb2xkX3NoYTEpOwoKLyoqIExvY2tzIGFueSByZWYgKGZvciAnSEVBRCcgdHlwZSByZWZzKS4gKi8KI2RlZmluZSBSRUZfTk9ERVJFRgkweDAxCmV4dGVybiBzdHJ1Y3QgcmVmX2xvY2sgKmxvY2tfYW55X3JlZl9mb3JfdXBkYXRlKGNvbnN0IGNoYXIgKnJlZm5hbWUsCgkJCQkJCWNvbnN0IHVuc2lnbmVkIGNoYXIgKm9sZF9zaGExLAoJCQkJCQlpbnQgZmxhZ3MpOwoKLyoqIENsb3NlIHRoZSBmaWxlIGRlc2NyaXB0b3Igb3duZWQgYnkgYSBsb2NrIGFuZCByZXR1cm4gdGhlIHN0YXR1cyAqLwpleHRlcm4gaW50IGNsb3NlX3JlZihzdHJ1Y3QgcmVmX2xvY2sgKmxvY2spOwoKLyoqIENsb3NlIGFuZCBjb21taXQgdGhlIHJlZiBsb2NrZWQgYnkgdGhlIGxvY2sgKi8KZXh0ZXJuIGludCBjb21taXRfcmVmKHN0cnVjdCByZWZfbG9jayAqbG9jayk7CgovKiogUmVsZWFzZSBhbnkgbG9jayB0YWtlbiBidXQgbm90IHdyaXR0ZW4uICoqLwpleHRlcm4gdm9pZCB1bmxvY2tfcmVmKHN0cnVjdCByZWZfbG9jayAqbG9jayk7CgovKiogV3JpdGVzIHNoYTEgaW50byB0aGUgcmVmIHNwZWNpZmllZCBieSB0aGUgbG9jay4gKiovCmV4dGVybiBpbnQgd3JpdGVfcmVmX3NoYTEoc3RydWN0IHJlZl9sb2NrICpsb2NrLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBjb25zdCBjaGFyICptc2cpOwoKLyoKICogSW52YWxpZGF0ZSB0aGUgcmVmZXJlbmNlIGNhY2hlIGZvciB0aGUgc3BlY2lmaWVkIHN1Ym1vZHVsZS4gIFVzZQogKiBzdWJtb2R1bGU9TlVMTCB0byBpbnZhbGlkYXRlIHRoZSBjYWNoZSBmb3IgdGhlIG1haW4gbW9kdWxlLiAgVGhpcwogKiBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBpZiByZWZlcmVuY2VzIGFyZSBjaGFuZ2VkIHZpYSBhIG1lY2hhbmlzbQogKiBvdGhlciB0aGFuIHRoZSByZWZzIEFQSS4KICovCmV4dGVybiB2b2lkIGludmFsaWRhdGVfcmVmX2NhY2hlKGNvbnN0IGNoYXIgKnN1Ym1vZHVsZSk7CgovKiogU2V0dXAgcmVmbG9nIGJlZm9yZSB1c2luZy4gKiovCmludCBsb2dfcmVmX3NldHVwKGNvbnN0IGNoYXIgKnJlZl9uYW1lLCBjaGFyICpsb2dmaWxlLCBpbnQgYnVmc2l6ZSk7CgovKiogUmVhZHMgbG9nIGZvciB0aGUgdmFsdWUgb2YgcmVmIGR1cmluZyBhdF90aW1lLiAqKi8KZXh0ZXJuIGludCByZWFkX3JlZl9hdChjb25zdCBjaGFyICpyZWZuYW1lLCB1bnNpZ25lZCBsb25nIGF0X3RpbWUsIGludCBjbnQsCgkJICAgICAgIHVuc2lnbmVkIGNoYXIgKnNoYTEsIGNoYXIgKiptc2csCgkJICAgICAgIHVuc2lnbmVkIGxvbmcgKmN1dG9mZl90aW1lLCBpbnQgKmN1dG9mZl90eiwgaW50ICpjdXRvZmZfY250KTsKCi8qIGl0ZXJhdGUgb3ZlciByZWZsb2cgZW50cmllcyAqLwp0eXBlZGVmIGludCBlYWNoX3JlZmxvZ19lbnRfZm4odW5zaWduZWQgY2hhciAqb3NoYTEsIHVuc2lnbmVkIGNoYXIgKm5zaGExLCBjb25zdCBjaGFyICosIHVuc2lnbmVkIGxvbmcsIGludCwgY29uc3QgY2hhciAqLCB2b2lkICopOwppbnQgZm9yX2VhY2hfcmVmbG9nX2VudChjb25zdCBjaGFyICpyZWZuYW1lLCBlYWNoX3JlZmxvZ19lbnRfZm4gZm4sIHZvaWQgKmNiX2RhdGEpOwppbnQgZm9yX2VhY2hfcmVjZW50X3JlZmxvZ19lbnQoY29uc3QgY2hhciAqcmVmbmFtZSwgZWFjaF9yZWZsb2dfZW50X2ZuIGZuLCBsb25nLCB2b2lkICpjYl9kYXRhKTsKCi8qCiAqIENhbGxzIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gZm9yIGVhY2ggcmVmbG9nIGZpbGUgdW50aWwgaXQgcmV0dXJucyBub256ZXJvLAogKiBhbmQgcmV0dXJucyB0aGUgdmFsdWUKICovCmV4dGVybiBpbnQgZm9yX2VhY2hfcmVmbG9nKGVhY2hfcmVmX2ZuLCB2b2lkICopOwoKI2RlZmluZSBSRUZOQU1FX0FMTE9XX09ORUxFVkVMIDEKI2RlZmluZSBSRUZOQU1FX1JFRlNQRUNfUEFUVEVSTiAyCiNkZWZpbmUgUkVGTkFNRV9ET1RfQ09NUE9ORU5UIDQKCi8qCiAqIFJldHVybiAwIGlmZiByZWZuYW1lIGhhcyB0aGUgY29ycmVjdCBmb3JtYXQgZm9yIGEgcmVmbmFtZSBhY2NvcmRpbmcKICogdG8gdGhlIHJ1bGVzIGRlc2NyaWJlZCBpbiBEb2N1bWVudGF0aW9uL2dpdC1jaGVjay1yZWYtZm9ybWF0LnR4dC4KICogSWYgUkVGTkFNRV9BTExPV19PTkVMRVZFTCBpcyBzZXQgaW4gZmxhZ3MsIHRoZW4gYWNjZXB0IG9uZS1sZXZlbAogKiByZWZlcmVuY2UgbmFtZXMuICBJZiBSRUZOQU1FX1JFRlNQRUNfUEFUVEVSTiBpcyBzZXQgaW4gZmxhZ3MsIHRoZW4KICogYWxsb3cgYSAiKiIgd2lsZGNhcmQgY2hhcmFjdGVyIGluIHBsYWNlIG9mIG9uZSBvZiB0aGUgbmFtZQogKiBjb21wb25lbnRzLiAgTm8gbGVhZGluZyBvciByZXBlYXRlZCBzbGFzaGVzIGFyZSBhY2NlcHRlZC4gIElmCiAqIFJFRk5BTUVfRE9UX0NPTVBPTkVOVCBpcyBzZXQgaW4gZmxhZ3MsIHRoZW4gYWxsb3cgcmVmbmFtZQogKiBjb21wb25lbnRzIHRvIHN0YXJ0IHdpdGggIi4iIChidXQgbm90IGEgd2hvbGUgY29tcG9uZW50IGVxdWFsIHRvCiAqICIuIiBvciAiLi4iKS4KICovCmV4dGVybiBpbnQgY2hlY2tfcmVmbmFtZV9mb3JtYXQoY29uc3QgY2hhciAqcmVmbmFtZSwgaW50IGZsYWdzKTsKCmV4dGVybiBjb25zdCBjaGFyICpwcmV0dGlmeV9yZWZuYW1lKGNvbnN0IGNoYXIgKnJlZm5hbWUpOwpleHRlcm4gY2hhciAqc2hvcnRlbl91bmFtYmlndW91c19yZWYoY29uc3QgY2hhciAqcmVmbmFtZSwgaW50IHN0cmljdCk7CgovKiogcmVuYW1lIHJlZiwgcmV0dXJuIDAgb24gc3VjY2VzcyAqKi8KZXh0ZXJuIGludCByZW5hbWVfcmVmKGNvbnN0IGNoYXIgKm9sZHJlZiwgY29uc3QgY2hhciAqbmV3cmVmLCBjb25zdCBjaGFyICpsb2dtc2cpOwoKLyoqCiAqIFJlc29sdmUgcmVmbmFtZSBpbiB0aGUgbmVzdGVkICJnaXRsaW5rIiByZXBvc2l0b3J5IHRoYXQgaXMgbG9jYXRlZAogKiBhdCBwYXRoLiAgSWYgdGhlIHJlc29sdXRpb24gaXMgc3VjY2Vzc2Z1bCwgcmV0dXJuIDAgYW5kIHNldCBzaGExIHRvCiAqIHRoZSBuYW1lIG9mIHRoZSBvYmplY3Q7IG90aGVyd2lzZSwgcmV0dXJuIGEgbm9uLXplcm8gdmFsdWUuCiAqLwpleHRlcm4gaW50IHJlc29sdmVfZ2l0bGlua19yZWYoY29uc3QgY2hhciAqcGF0aCwgY29uc3QgY2hhciAqcmVmbmFtZSwgdW5zaWduZWQgY2hhciAqc2hhMSk7CgovKiogbG9jayBhIHJlZiBhbmQgdGhlbiB3cml0ZSBpdHMgZmlsZSAqLwplbnVtIGFjdGlvbl9vbl9lcnIgeyBNU0dfT05fRVJSLCBESUVfT05fRVJSLCBRVUlFVF9PTl9FUlIgfTsKaW50IHVwZGF0ZV9yZWYoY29uc3QgY2hhciAqYWN0aW9uLCBjb25zdCBjaGFyICpyZWZuYW1lLAoJCWNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKm9sZHZhbCwKCQlpbnQgZmxhZ3MsIGVudW0gYWN0aW9uX29uX2VyciBvbmVycik7CgojZW5kaWYgLyogUkVGU19IICovCg==",
    "text": "#ifndef REFS_H\n#define REFS_H\n\nstruct ref_lock {\n\tchar *ref_name;\n\tchar *orig_ref_name;\n\tstruct lock_file *lk;\n\tunsigned char old_sha1[20];\n\tint lock_fd;\n\tint force_write;\n};\n\n#define REF_ISSYMREF 0x01\n#define REF_ISPACKED 0x02\n#define REF_ISBROKEN 0x04\n\n/*\n * Calls the specified function for each ref file until it returns nonzero,\n * and returns the value\n */\ntypedef int each_ref_fn(const char *refname, const unsigned char *sha1, int flags, void *cb_data);\nextern int head_ref(each_ref_fn, void *);\nextern int for_each_ref(each_ref_fn, void *);\nextern int for_each_ref_in(const char *, each_ref_fn, void *);\nextern int for_each_tag_ref(each_ref_fn, void *);\nextern int for_each_branch_ref(each_ref_fn, void *);\nextern int for_each_remote_ref(each_ref_fn, void *);\nextern int for_each_replace_ref(each_ref_fn, void *);\nextern int for_each_glob_ref(each_ref_fn, const char *pattern, void *);\nextern int for_each_glob_ref_in(each_ref_fn, const char *pattern, const char* prefix, void *);\n\nextern int head_ref_submodule(const char *submodule, each_ref_fn fn, void *cb_data);\nextern int for_each_ref_submodule(const char *submodule, each_ref_fn fn, void *cb_data);\nextern int for_each_ref_in_submodule(const char *submodule, const char *prefix,\n\t\teach_ref_fn fn, void *cb_data);\nextern int for_each_tag_ref_submodule(const char *submodule, each_ref_fn fn, void *cb_data);\nextern int for_each_branch_ref_submodule(const char *submodule, each_ref_fn fn, void *cb_data);\nextern int for_each_remote_ref_submodule(const char *submodule, each_ref_fn fn, void *cb_data);\n\nextern int head_ref_namespaced(each_ref_fn fn, void *cb_data);\nextern int for_each_namespaced_ref(each_ref_fn fn, void *cb_data);\n\nstatic inline const char *has_glob_specials(const char *pattern)\n{\n\treturn strpbrk(pattern, \"?*[\");\n}\n\n/* can be used to learn about broken ref and symref */\nextern int for_each_rawref(each_ref_fn, void *);\n\nextern void warn_dangling_symref(FILE *fp, const char *msg_fmt, const char *refname);\n\n/*\n * Add a reference to the in-memory packed reference cache.  To actually\n * write the reference to the packed-refs file, call pack_refs().\n */\nextern void add_packed_ref(const char *refname, const unsigned char *sha1);\n\n/*\n * Extra refs will be listed by for_each_ref() before any actual refs\n * for the duration of this process or until clear_extra_refs() is\n * called. Only extra refs added before for_each_ref() is called will\n * be listed on a given call of for_each_ref().\n */\nextern void add_extra_ref(const char *refname, const unsigned char *sha1, int flags);\nextern void clear_extra_refs(void);\nextern int ref_exists(const char *);\n\nextern int peel_ref(const char *refname, unsigned char *sha1);\n\n/** Locks a \"refs/\" ref returning the lock on success and NULL on failure. **/\nextern struct ref_lock *lock_ref_sha1(const char *refname, const unsigned char *old_sha1);\n\n/** Locks any ref (for 'HEAD' type refs). */\n#define REF_NODEREF\t0x01\nextern struct ref_lock *lock_any_ref_for_update(const char *refname,\n\t\t\t\t\t\tconst unsigned char *old_sha1,\n\t\t\t\t\t\tint flags);\n\n/** Close the file descriptor owned by a lock and return the status */\nextern int close_ref(struct ref_lock *lock);\n\n/** Close and commit the ref locked by the lock */\nextern int commit_ref(struct ref_lock *lock);\n\n/** Release any lock taken but not written. **/\nextern void unlock_ref(struct ref_lock *lock);\n\n/** Writes sha1 into the ref specified by the lock. **/\nextern int write_ref_sha1(struct ref_lock *lock, const unsigned char *sha1, const char *msg);\n\n/*\n * Invalidate the reference cache for the specified submodule.  Use\n * submodule=NULL to invalidate the cache for the main module.  This\n * function must be called if references are changed via a mechanism\n * other than the refs API.\n */\nextern void invalidate_ref_cache(const char *submodule);\n\n/** Setup reflog before using. **/\nint log_ref_setup(const char *ref_name, char *logfile, int bufsize);\n\n/** Reads log for the value of ref during at_time. **/\nextern int read_ref_at(const char *refname, unsigned long at_time, int cnt,\n\t\t       unsigned char *sha1, char **msg,\n\t\t       unsigned long *cutoff_time, int *cutoff_tz, int *cutoff_cnt);\n\n/* iterate over reflog entries */\ntypedef int each_reflog_ent_fn(unsigned char *osha1, unsigned char *nsha1, const char *, unsigned long, int, const char *, void *);\nint for_each_reflog_ent(const char *refname, each_reflog_ent_fn fn, void *cb_data);\nint for_each_recent_reflog_ent(const char *refname, each_reflog_ent_fn fn, long, void *cb_data);\n\n/*\n * Calls the specified function for each reflog file until it returns nonzero,\n * and returns the value\n */\nextern int for_each_reflog(each_ref_fn, void *);\n\n#define REFNAME_ALLOW_ONELEVEL 1\n#define REFNAME_REFSPEC_PATTERN 2\n#define REFNAME_DOT_COMPONENT 4\n\n/*\n * Return 0 iff refname has the correct format for a refname according\n * to the rules described in Documentation/git-check-ref-format.txt.\n * If REFNAME_ALLOW_ONELEVEL is set in flags, then accept one-level\n * reference names.  If REFNAME_REFSPEC_PATTERN is set in flags, then\n * allow a \"*\" wildcard character in place of one of the name\n * components.  No leading or repeated slashes are accepted.  If\n * REFNAME_DOT_COMPONENT is set in flags, then allow refname\n * components to start with \".\" (but not a whole component equal to\n * \".\" or \"..\").\n */\nextern int check_refname_format(const char *refname, int flags);\n\nextern const char *prettify_refname(const char *refname);\nextern char *shorten_unambiguous_ref(const char *refname, int strict);\n\n/** rename ref, return 0 on success **/\nextern int rename_ref(const char *oldref, const char *newref, const char *logmsg);\n\n/**\n * Resolve refname in the nested \"gitlink\" repository that is located\n * at path.  If the resolution is successful, return 0 and set sha1 to\n * the name of the object; otherwise, return a non-zero value.\n */\nextern int resolve_gitlink_ref(const char *path, const char *refname, unsigned char *sha1);\n\n/** lock a ref and then write its file */\nenum action_on_err { MSG_ON_ERR, DIE_ON_ERR, QUIET_ON_ERR };\nint update_ref(const char *action, const char *refname,\n\t\tconst unsigned char *sha1, const unsigned char *oldval,\n\t\tint flags, enum action_on_err onerr);\n\n#endif /* REFS_H */\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00ba1e2813b2c2fff74300e3b2036a04f9e28065",
  "sha1_ok": true,
  "size": 6247
}
