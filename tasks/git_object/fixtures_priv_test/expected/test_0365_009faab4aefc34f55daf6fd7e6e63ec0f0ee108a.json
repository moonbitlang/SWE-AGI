{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJ0cmVlLmgiCiNpbmNsdWRlICJibG9iLmgiCiNpbmNsdWRlICJ0cmVlLXdhbGsuaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgInJlbW90ZS5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJzaGExLWFycmF5LmgiCiNpbmNsdWRlICJwYWNrZmlsZS5oIgojaW5jbHVkZSAib2JqZWN0LXN0b3JlLmgiCiNpbmNsdWRlICJyZXBvc2l0b3J5LmgiCgpzdGF0aWMgaW50IGdldF9vaWRfb25lbGluZShjb25zdCBjaGFyICosIHN0cnVjdCBvYmplY3RfaWQgKiwgc3RydWN0IGNvbW1pdF9saXN0ICopOwoKdHlwZWRlZiBpbnQgKCpkaXNhbWJpZ3VhdGVfaGludF9mbikoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqLCB2b2lkICopOwoKc3RydWN0IGRpc2FtYmlndWF0ZV9zdGF0ZSB7CglpbnQgbGVuOyAvKiBsZW5ndGggb2YgcHJlZml4IGluIGhleCBjaGFycyAqLwoJY2hhciBoZXhfcGZ4W0dJVF9NQVhfSEVYU1ogKyAxXTsKCXN0cnVjdCBvYmplY3RfaWQgYmluX3BmeDsKCglkaXNhbWJpZ3VhdGVfaGludF9mbiBmbjsKCXZvaWQgKmNiX2RhdGE7CglzdHJ1Y3Qgb2JqZWN0X2lkIGNhbmRpZGF0ZTsKCXVuc2lnbmVkIGNhbmRpZGF0ZV9leGlzdHM6MTsKCXVuc2lnbmVkIGNhbmRpZGF0ZV9jaGVja2VkOjE7Cgl1bnNpZ25lZCBjYW5kaWRhdGVfb2s6MTsKCXVuc2lnbmVkIGRpc2FtYmlndWF0ZV9mbl91c2VkOjE7Cgl1bnNpZ25lZCBhbWJpZ3VvdXM6MTsKCXVuc2lnbmVkIGFsd2F5c19jYWxsX2ZuOjE7Cn07CgpzdGF0aWMgdm9pZCB1cGRhdGVfY2FuZGlkYXRlcyhzdHJ1Y3QgZGlzYW1iaWd1YXRlX3N0YXRlICpkcywgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqY3VycmVudCkKewoJaWYgKGRzLT5hbHdheXNfY2FsbF9mbikgewoJCWRzLT5hbWJpZ3VvdXMgPSBkcy0+Zm4oY3VycmVudCwgZHMtPmNiX2RhdGEpID8gMSA6IDA7CgkJcmV0dXJuOwoJfQoJaWYgKCFkcy0+Y2FuZGlkYXRlX2V4aXN0cykgewoJCS8qIHRoaXMgaXMgdGhlIGZpcnN0IGNhbmRpZGF0ZSAqLwoJCW9pZGNweSgmZHMtPmNhbmRpZGF0ZSwgY3VycmVudCk7CgkJZHMtPmNhbmRpZGF0ZV9leGlzdHMgPSAxOwoJCXJldHVybjsKCX0gZWxzZSBpZiAoIW9pZGNtcCgmZHMtPmNhbmRpZGF0ZSwgY3VycmVudCkpIHsKCQkvKiB0aGUgc2FtZSBhcyB3aGF0IHdlIGFscmVhZHkgaGF2ZSBzZWVuICovCgkJcmV0dXJuOwoJfQoKCWlmICghZHMtPmZuKSB7CgkJLyogY2Fubm90IGRpc2FtYmlndWF0ZSBiZXR3ZWVuIGRzLT5jYW5kaWRhdGUgYW5kIGN1cnJlbnQgKi8KCQlkcy0+YW1iaWd1b3VzID0gMTsKCQlyZXR1cm47Cgl9CgoJaWYgKCFkcy0+Y2FuZGlkYXRlX2NoZWNrZWQpIHsKCQlkcy0+Y2FuZGlkYXRlX29rID0gZHMtPmZuKCZkcy0+Y2FuZGlkYXRlLCBkcy0+Y2JfZGF0YSk7CgkJZHMtPmRpc2FtYmlndWF0ZV9mbl91c2VkID0gMTsKCQlkcy0+Y2FuZGlkYXRlX2NoZWNrZWQgPSAxOwoJfQoKCWlmICghZHMtPmNhbmRpZGF0ZV9vaykgewoJCS8qIGRpc2NhcmQgdGhlIGNhbmRpZGF0ZTsgd2Uga25vdyBpdCBkb2VzIG5vdCBzYXRpc2Z5IGZuICovCgkJb2lkY3B5KCZkcy0+Y2FuZGlkYXRlLCBjdXJyZW50KTsKCQlkcy0+Y2FuZGlkYXRlX2NoZWNrZWQgPSAwOwoJCXJldHVybjsKCX0KCgkvKiBpZiB3ZSByZWFjaCB0aGlzIHBvaW50LCB3ZSBrbm93IGRzLT5jYW5kaWRhdGUgc2F0aXNmaWVzIGZuICovCglpZiAoZHMtPmZuKGN1cnJlbnQsIGRzLT5jYl9kYXRhKSkgewoJCS8qCgkJICogaWYgYm90aCBjdXJyZW50IGFuZCBjYW5kaWRhdGUgc2F0aXNmeSBmbiwgd2UgY2Fubm90CgkJICogZGlzYW1iaWd1YXRlLgoJCSAqLwoJCWRzLT5jYW5kaWRhdGVfb2sgPSAwOwoJCWRzLT5hbWJpZ3VvdXMgPSAxOwoJfQoKCS8qIG90aGVyd2lzZSwgY3VycmVudCBjYW4gYmUgZGlzY2FyZGVkIGFuZCBjYW5kaWRhdGUgaXMgc3RpbGwgZ29vZCAqLwp9CgpzdGF0aWMgaW50IGFwcGVuZF9sb29zZV9vYmplY3QoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBjb25zdCBjaGFyICpwYXRoLAoJCQkgICAgICAgdm9pZCAqZGF0YSkKewoJb2lkX2FycmF5X2FwcGVuZChkYXRhLCBvaWQpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgbWF0Y2hfc2hhKHVuc2lnbmVkLCBjb25zdCB1bnNpZ25lZCBjaGFyICosIGNvbnN0IHVuc2lnbmVkIGNoYXIgKik7CgpzdGF0aWMgdm9pZCBmaW5kX3Nob3J0X29iamVjdF9maWxlbmFtZShzdHJ1Y3QgZGlzYW1iaWd1YXRlX3N0YXRlICpkcykKewoJaW50IHN1YmRpcl9uciA9IGRzLT5iaW5fcGZ4Lmhhc2hbMF07CglzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSAqYWx0OwoJc3RhdGljIHN0cnVjdCBhbHRlcm5hdGVfb2JqZWN0X2RhdGFiYXNlICpmYWtlZW50OwoKCWlmICghZmFrZWVudCkgewoJCS8qCgkJICogQ3JlYXRlIGEgImZha2UiIGFsdGVybmF0ZSBvYmplY3QgZGF0YWJhc2UgdGhhdAoJCSAqIHBvaW50cyB0byBvdXIgb3duIG9iamVjdCBkYXRhYmFzZSwgdG8gbWFrZSBpdAoJCSAqIGVhc2llciB0byBnZXQgYSB0ZW1wb3Jhcnkgd29ya2luZyBzcGFjZSBpbgoJCSAqIGFsdC0+bmFtZS9hbHQtPmJhc2Ugd2hpbGUgaXRlcmF0aW5nIG92ZXIgdGhlCgkJICogb2JqZWN0IGRhdGFiYXNlcyBpbmNsdWRpbmcgb3VyIG93bi4KCQkgKi8KCQlmYWtlZW50ID0gYWxsb2NfYWx0X29kYihnZXRfb2JqZWN0X2RpcmVjdG9yeSgpKTsKCX0KCWZha2VlbnQtPm5leHQgPSB0aGVfcmVwb3NpdG9yeS0+b2JqZWN0cy0+YWx0X29kYl9saXN0OwoKCWZvciAoYWx0ID0gZmFrZWVudDsgYWx0ICYmICFkcy0+YW1iaWd1b3VzOyBhbHQgPSBhbHQtPm5leHQpIHsKCQlpbnQgcG9zOwoKCQlpZiAoIWFsdC0+bG9vc2Vfb2JqZWN0c19zdWJkaXJfc2VlbltzdWJkaXJfbnJdKSB7CgkJCXN0cnVjdCBzdHJidWYgKmJ1ZiA9IGFsdF9zY3JhdGNoX2J1ZihhbHQpOwoJCQlmb3JfZWFjaF9maWxlX2luX29ial9zdWJkaXIoc3ViZGlyX25yLCBidWYsCgkJCQkJCSAgICBhcHBlbmRfbG9vc2Vfb2JqZWN0LAoJCQkJCQkgICAgTlVMTCwgTlVMTCwKCQkJCQkJICAgICZhbHQtPmxvb3NlX29iamVjdHNfY2FjaGUpOwoJCQlhbHQtPmxvb3NlX29iamVjdHNfc3ViZGlyX3NlZW5bc3ViZGlyX25yXSA9IDE7CgkJfQoKCQlwb3MgPSBvaWRfYXJyYXlfbG9va3VwKCZhbHQtPmxvb3NlX29iamVjdHNfY2FjaGUsICZkcy0+YmluX3BmeCk7CgkJaWYgKHBvcyA8IDApCgkJCXBvcyA9IC0xIC0gcG9zOwoJCXdoaWxlICghZHMtPmFtYmlndW91cyAmJiBwb3MgPCBhbHQtPmxvb3NlX29iamVjdHNfY2FjaGUubnIpIHsKCQkJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkOwoJCQlvaWQgPSBhbHQtPmxvb3NlX29iamVjdHNfY2FjaGUub2lkICsgcG9zOwoJCQlpZiAoIW1hdGNoX3NoYShkcy0+bGVuLCBkcy0+YmluX3BmeC5oYXNoLCBvaWQtPmhhc2gpKQoJCQkJYnJlYWs7CgkJCXVwZGF0ZV9jYW5kaWRhdGVzKGRzLCBvaWQpOwoJCQlwb3MrKzsKCQl9Cgl9Cn0KCnN0YXRpYyBpbnQgbWF0Y2hfc2hhKHVuc2lnbmVkIGxlbiwgY29uc3QgdW5zaWduZWQgY2hhciAqYSwgY29uc3QgdW5zaWduZWQgY2hhciAqYikKewoJZG8gewoJCWlmICgqYSAhPSAqYikKCQkJcmV0dXJuIDA7CgkJYSsrOwoJCWIrKzsKCQlsZW4gLT0gMjsKCX0gd2hpbGUgKGxlbiA+IDEpOwoJaWYgKGxlbikKCQlpZiAoKCphIF4gKmIpICYgMHhmMCkKCQkJcmV0dXJuIDA7CglyZXR1cm4gMTsKfQoKc3RhdGljIHZvaWQgdW5pcXVlX2luX3BhY2soc3RydWN0IHBhY2tlZF9naXQgKnAsCgkJCSAgIHN0cnVjdCBkaXNhbWJpZ3VhdGVfc3RhdGUgKmRzKQp7Cgl1aW50MzJfdCBudW0sIGksIGZpcnN0ID0gMDsKCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKmN1cnJlbnQgPSBOVUxMOwoKCWlmIChvcGVuX3BhY2tfaW5kZXgocCkgfHwgIXAtPm51bV9vYmplY3RzKQoJCXJldHVybjsKCgludW0gPSBwLT5udW1fb2JqZWN0czsKCWJzZWFyY2hfcGFjaygmZHMtPmJpbl9wZngsIHAsICZmaXJzdCk7CgoJLyoKCSAqIEF0IHRoaXMgcG9pbnQsICJmaXJzdCIgaXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBsb3dlc3Qgb2JqZWN0CgkgKiB3aXRoIGFuIG9iamVjdCBuYW1lIHRoYXQgY291bGQgbWF0Y2ggImJpbl9wZngiLiAgU2VlIGlmIHdlIGhhdmUKCSAqIDAsIDEgb3IgbW9yZSBvYmplY3RzIHRoYXQgYWN0dWFsbHkgbWF0Y2goZXMpLgoJICovCglmb3IgKGkgPSBmaXJzdDsgaSA8IG51bSAmJiAhZHMtPmFtYmlndW91czsgaSsrKSB7CgkJc3RydWN0IG9iamVjdF9pZCBvaWQ7CgkJY3VycmVudCA9IG50aF9wYWNrZWRfb2JqZWN0X29pZCgmb2lkLCBwLCBpKTsKCQlpZiAoIW1hdGNoX3NoYShkcy0+bGVuLCBkcy0+YmluX3BmeC5oYXNoLCBjdXJyZW50LT5oYXNoKSkKCQkJYnJlYWs7CgkJdXBkYXRlX2NhbmRpZGF0ZXMoZHMsIGN1cnJlbnQpOwoJfQp9CgpzdGF0aWMgdm9pZCBmaW5kX3Nob3J0X3BhY2tlZF9vYmplY3Qoc3RydWN0IGRpc2FtYmlndWF0ZV9zdGF0ZSAqZHMpCnsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwOwoKCWZvciAocCA9IGdldF9wYWNrZWRfZ2l0KHRoZV9yZXBvc2l0b3J5KTsgcCAmJiAhZHMtPmFtYmlndW91czsKCSAgICAgcCA9IHAtPm5leHQpCgkJdW5pcXVlX2luX3BhY2socCwgZHMpOwp9CgojZGVmaW5lIFNIT1JUX05BTUVfTk9UX0ZPVU5EICgtMSkKI2RlZmluZSBTSE9SVF9OQU1FX0FNQklHVU9VUyAoLTIpCgpzdGF0aWMgaW50IGZpbmlzaF9vYmplY3RfZGlzYW1iaWd1YXRpb24oc3RydWN0IGRpc2FtYmlndWF0ZV9zdGF0ZSAqZHMsCgkJCQkJc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglpZiAoZHMtPmFtYmlndW91cykKCQlyZXR1cm4gU0hPUlRfTkFNRV9BTUJJR1VPVVM7CgoJaWYgKCFkcy0+Y2FuZGlkYXRlX2V4aXN0cykKCQlyZXR1cm4gU0hPUlRfTkFNRV9OT1RfRk9VTkQ7CgoJaWYgKCFkcy0+Y2FuZGlkYXRlX2NoZWNrZWQpCgkJLyoKCQkgKiBJZiB0aGlzIGlzIHRoZSBvbmx5IGNhbmRpZGF0ZSwgdGhlcmUgaXMgbm8gcG9pbnQKCQkgKiBjYWxsaW5nIHRoZSBkaXNhbWJpZ3VhdGlvbiBoaW50IGNhbGxiYWNrLgoJCSAqCgkJICogT24gdGhlIG90aGVyIGhhbmQsIGlmIHRoZSBjdXJyZW50IGNhbmRpZGF0ZQoJCSAqIHJlcGxhY2VkIGFuIGVhcmxpZXIgY2FuZGlkYXRlIHRoYXQgZGlkIF9ub3RfIHBhc3MKCQkgKiB0aGUgZGlzYW1iaWd1YXRpb24gaGludCBjYWxsYmFjaywgdGhlbiB3ZSBkbyBoYXZlCgkJICogbW9yZSB0aGFuIG9uZSBvYmplY3RzIHRoYXQgbWF0Y2ggdGhlIHNob3J0IG5hbWUKCQkgKiBnaXZlbiwgc28gd2Ugc2hvdWxkIG1ha2Ugc3VyZSB0aGlzIG9uZSBtYXRjaGVzOwoJCSAqIG90aGVyd2lzZSwgaWYgd2UgZGlzY292ZXJlZCB0aGlzIG9uZSBhbmQgdGhlIG9uZQoJCSAqIHRoYXQgd2UgcHJldmlvdXNseSBkaXNjYXJkZWQgaW4gdGhlIHJldmVyc2Ugb3JkZXIsCgkJICogd2Ugd291bGQgZW5kIHVwIHNob3dpbmcgZGlmZmVyZW50IHJlc3VsdHMgaW4gdGhlCgkJICogc2FtZSByZXBvc2l0b3J5IQoJCSAqLwoJCWRzLT5jYW5kaWRhdGVfb2sgPSAoIWRzLT5kaXNhbWJpZ3VhdGVfZm5fdXNlZCB8fAoJCQkJICAgIGRzLT5mbigmZHMtPmNhbmRpZGF0ZSwgZHMtPmNiX2RhdGEpKTsKCglpZiAoIWRzLT5jYW5kaWRhdGVfb2spCgkJcmV0dXJuIFNIT1JUX05BTUVfQU1CSUdVT1VTOwoKCW9pZGNweShvaWQsICZkcy0+Y2FuZGlkYXRlKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGRpc2FtYmlndWF0ZV9jb21taXRfb25seShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIHZvaWQgKmNiX2RhdGFfdW51c2VkKQp7CglpbnQga2luZCA9IG9pZF9vYmplY3RfaW5mbyh0aGVfcmVwb3NpdG9yeSwgb2lkLCBOVUxMKTsKCXJldHVybiBraW5kID09IE9CSl9DT01NSVQ7Cn0KCnN0YXRpYyBpbnQgZGlzYW1iaWd1YXRlX2NvbW1pdHRpc2hfb25seShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIHZvaWQgKmNiX2RhdGFfdW51c2VkKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmo7CglpbnQga2luZDsKCglraW5kID0gb2lkX29iamVjdF9pbmZvKHRoZV9yZXBvc2l0b3J5LCBvaWQsIE5VTEwpOwoJaWYgKGtpbmQgPT0gT0JKX0NPTU1JVCkKCQlyZXR1cm4gMTsKCWlmIChraW5kICE9IE9CSl9UQUcpCgkJcmV0dXJuIDA7CgoJLyogV2UgbmVlZCB0byBkbyB0aGlzIHRoZSBoYXJkIHdheS4uLiAqLwoJb2JqID0gZGVyZWZfdGFnKHRoZV9yZXBvc2l0b3J5LCBwYXJzZV9vYmplY3QodGhlX3JlcG9zaXRvcnksIG9pZCksCgkJCU5VTEwsIDApOwoJaWYgKG9iaiAmJiBvYmotPnR5cGUgPT0gT0JKX0NPTU1JVCkKCQlyZXR1cm4gMTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGRpc2FtYmlndWF0ZV90cmVlX29ubHkoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCB2b2lkICpjYl9kYXRhX3VudXNlZCkKewoJaW50IGtpbmQgPSBvaWRfb2JqZWN0X2luZm8odGhlX3JlcG9zaXRvcnksIG9pZCwgTlVMTCk7CglyZXR1cm4ga2luZCA9PSBPQkpfVFJFRTsKfQoKc3RhdGljIGludCBkaXNhbWJpZ3VhdGVfdHJlZWlzaF9vbmx5KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgdm9pZCAqY2JfZGF0YV91bnVzZWQpCnsKCXN0cnVjdCBvYmplY3QgKm9iajsKCWludCBraW5kOwoKCWtpbmQgPSBvaWRfb2JqZWN0X2luZm8odGhlX3JlcG9zaXRvcnksIG9pZCwgTlVMTCk7CglpZiAoa2luZCA9PSBPQkpfVFJFRSB8fCBraW5kID09IE9CSl9DT01NSVQpCgkJcmV0dXJuIDE7CglpZiAoa2luZCAhPSBPQkpfVEFHKQoJCXJldHVybiAwOwoKCS8qIFdlIG5lZWQgdG8gZG8gdGhpcyB0aGUgaGFyZCB3YXkuLi4gKi8KCW9iaiA9IGRlcmVmX3RhZyh0aGVfcmVwb3NpdG9yeSwgcGFyc2Vfb2JqZWN0KHRoZV9yZXBvc2l0b3J5LCBvaWQpLAoJCQlOVUxMLCAwKTsKCWlmIChvYmogJiYgKG9iai0+dHlwZSA9PSBPQkpfVFJFRSB8fCBvYmotPnR5cGUgPT0gT0JKX0NPTU1JVCkpCgkJcmV0dXJuIDE7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBkaXNhbWJpZ3VhdGVfYmxvYl9vbmx5KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgdm9pZCAqY2JfZGF0YV91bnVzZWQpCnsKCWludCBraW5kID0gb2lkX29iamVjdF9pbmZvKHRoZV9yZXBvc2l0b3J5LCBvaWQsIE5VTEwpOwoJcmV0dXJuIGtpbmQgPT0gT0JKX0JMT0I7Cn0KCnN0YXRpYyBkaXNhbWJpZ3VhdGVfaGludF9mbiBkZWZhdWx0X2Rpc2FtYmlndWF0ZV9oaW50OwoKaW50IHNldF9kaXNhbWJpZ3VhdGVfaGludF9jb25maWcoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSkKewoJc3RhdGljIGNvbnN0IHN0cnVjdCB7CgkJY29uc3QgY2hhciAqbmFtZTsKCQlkaXNhbWJpZ3VhdGVfaGludF9mbiBmbjsKCX0gaGludHNbXSA9IHsKCQl7ICJub25lIiwgTlVMTCB9LAoJCXsgImNvbW1pdCIsIGRpc2FtYmlndWF0ZV9jb21taXRfb25seSB9LAoJCXsgImNvbW1pdHRpc2giLCBkaXNhbWJpZ3VhdGVfY29tbWl0dGlzaF9vbmx5IH0sCgkJeyAidHJlZSIsIGRpc2FtYmlndWF0ZV90cmVlX29ubHkgfSwKCQl7ICJ0cmVlaXNoIiwgZGlzYW1iaWd1YXRlX3RyZWVpc2hfb25seSB9LAoJCXsgImJsb2IiLCBkaXNhbWJpZ3VhdGVfYmxvYl9vbmx5IH0KCX07CglpbnQgaTsKCglpZiAoIXZhbHVlKQoJCXJldHVybiBjb25maWdfZXJyb3Jfbm9uYm9vbCh2YXIpOwoKCWZvciAoaSA9IDA7IGkgPCBBUlJBWV9TSVpFKGhpbnRzKTsgaSsrKSB7CgkJaWYgKCFzdHJjYXNlY21wKHZhbHVlLCBoaW50c1tpXS5uYW1lKSkgewoJCQlkZWZhdWx0X2Rpc2FtYmlndWF0ZV9oaW50ID0gaGludHNbaV0uZm47CgkJCXJldHVybiAwOwoJCX0KCX0KCglyZXR1cm4gZXJyb3IoInVua25vd24gaGludCB0eXBlIGZvciAnJXMnOiAlcyIsIHZhciwgdmFsdWUpOwp9CgpzdGF0aWMgaW50IGluaXRfb2JqZWN0X2Rpc2FtYmlndWF0aW9uKGNvbnN0IGNoYXIgKm5hbWUsIGludCBsZW4sCgkJCQkgICAgICBzdHJ1Y3QgZGlzYW1iaWd1YXRlX3N0YXRlICpkcykKewoJaW50IGk7CgoJaWYgKGxlbiA8IE1JTklNVU1fQUJCUkVWIHx8IGxlbiA+IEdJVF9TSEExX0hFWFNaKQoJCXJldHVybiAtMTsKCgltZW1zZXQoZHMsIDAsIHNpemVvZigqZHMpKTsKCglmb3IgKGkgPSAwOyBpIDwgbGVuIDtpKyspIHsKCQl1bnNpZ25lZCBjaGFyIGMgPSBuYW1lW2ldOwoJCXVuc2lnbmVkIGNoYXIgdmFsOwoJCWlmIChjID49ICcwJyAmJiBjIDw9ICc5JykKCQkJdmFsID0gYyAtICcwJzsKCQllbHNlIGlmIChjID49ICdhJyAmJiBjIDw9ICdmJykKCQkJdmFsID0gYyAtICdhJyArIDEwOwoJCWVsc2UgaWYgKGMgPj0gJ0EnICYmIGMgPD0nRicpIHsKCQkJdmFsID0gYyAtICdBJyArIDEwOwoJCQljIC09ICdBJyAtICdhJzsKCQl9CgkJZWxzZQoJCQlyZXR1cm4gLTE7CgkJZHMtPmhleF9wZnhbaV0gPSBjOwoJCWlmICghKGkgJiAxKSkKCQkJdmFsIDw8PSA0OwoJCWRzLT5iaW5fcGZ4Lmhhc2hbaSA+PiAxXSB8PSB2YWw7Cgl9CgoJZHMtPmxlbiA9IGxlbjsKCWRzLT5oZXhfcGZ4W2xlbl0gPSAnXDAnOwoJcHJlcGFyZV9hbHRfb2RiKHRoZV9yZXBvc2l0b3J5KTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHNob3dfYW1iaWd1b3VzX29iamVjdChjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIHZvaWQgKmRhdGEpCnsKCWNvbnN0IHN0cnVjdCBkaXNhbWJpZ3VhdGVfc3RhdGUgKmRzID0gZGF0YTsKCXN0cnVjdCBzdHJidWYgZGVzYyA9IFNUUkJVRl9JTklUOwoJaW50IHR5cGU7CgoJaWYgKGRzLT5mbiAmJiAhZHMtPmZuKG9pZCwgZHMtPmNiX2RhdGEpKQoJCXJldHVybiAwOwoKCXR5cGUgPSBvaWRfb2JqZWN0X2luZm8odGhlX3JlcG9zaXRvcnksIG9pZCwgTlVMTCk7CglpZiAodHlwZSA9PSBPQkpfQ09NTUlUKSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gbG9va3VwX2NvbW1pdCh0aGVfcmVwb3NpdG9yeSwgb2lkKTsKCQlpZiAoY29tbWl0KSB7CgkJCXN0cnVjdCBwcmV0dHlfcHJpbnRfY29udGV4dCBwcCA9IHswfTsKCQkJcHAuZGF0ZV9tb2RlLnR5cGUgPSBEQVRFX1NIT1JUOwoJCQlmb3JtYXRfY29tbWl0X21lc3NhZ2UoY29tbWl0LCAiICVhZCAtICVzIiwgJmRlc2MsICZwcCk7CgkJfQoJfSBlbHNlIGlmICh0eXBlID09IE9CSl9UQUcpIHsKCQlzdHJ1Y3QgdGFnICp0YWcgPSBsb29rdXBfdGFnKHRoZV9yZXBvc2l0b3J5LCBvaWQpOwoJCWlmICghcGFyc2VfdGFnKHRhZykgJiYgdGFnLT50YWcpCgkJCXN0cmJ1Zl9hZGRmKCZkZXNjLCAiICVzIiwgdGFnLT50YWcpOwoJfQoKCWFkdmlzZSgiICAlcyAlcyVzIiwKCSAgICAgICBmaW5kX3VuaXF1ZV9hYmJyZXYob2lkLCBERUZBVUxUX0FCQlJFViksCgkgICAgICAgdHlwZV9uYW1lKHR5cGUpID8gdHlwZV9uYW1lKHR5cGUpIDogInVua25vd24gdHlwZSIsCgkgICAgICAgZGVzYy5idWYpOwoKCXN0cmJ1Zl9yZWxlYXNlKCZkZXNjKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGNvbGxlY3RfYW1iaWd1b3VzKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgdm9pZCAqZGF0YSkKewoJb2lkX2FycmF5X2FwcGVuZChkYXRhLCBvaWQpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgc29ydF9hbWJpZ3VvdXMoY29uc3Qgdm9pZCAqYSwgY29uc3Qgdm9pZCAqYikKewoJaW50IGFfdHlwZSA9IG9pZF9vYmplY3RfaW5mbyh0aGVfcmVwb3NpdG9yeSwgYSwgTlVMTCk7CglpbnQgYl90eXBlID0gb2lkX29iamVjdF9pbmZvKHRoZV9yZXBvc2l0b3J5LCBiLCBOVUxMKTsKCWludCBhX3R5cGVfc29ydDsKCWludCBiX3R5cGVfc29ydDsKCgkvKgoJICogU29ydHMgYnkgaGFzaCB3aXRoaW4gdGhlIHNhbWUgb2JqZWN0IHR5cGUsIGp1c3QgYXMKCSAqIG9pZF9hcnJheV9mb3JfZWFjaF91bmlxdWUoKSB3b3VsZCBkby4KCSAqLwoJaWYgKGFfdHlwZSA9PSBiX3R5cGUpCgkJcmV0dXJuIG9pZGNtcChhLCBiKTsKCgkvKgoJICogQmV0d2VlbiBvYmplY3QgdHlwZXMgc2hvdyB0YWdzLCB0aGVuIGNvbW1pdHMsIGFuZCBmaW5hbGx5CgkgKiB0cmVlcyBhbmQgYmxvYnMuCgkgKgoJICogVGhlIG9iamVjdF90eXBlIGVudW0gaXMgY29tbWl0LCB0cmVlLCBibG9iLCB0YWcsIGJ1dCB3ZQoJICogd2FudCB0YWcsIGNvbW1pdCwgdHJlZSBibG9iLiBDbGV2ZXJseSAocGVyaGFwcyB0b28KCSAqIGNsZXZlcmx5KSBkbyB0aGF0IHdpdGggbW9kdWx1cywgc2luY2UgdGhlIGVudW0gYXNzaWducyAxIHRvCgkgKiBjb21taXQsIHNvIHRhZyBiZWNvbWVzIDAuCgkgKi8KCWFfdHlwZV9zb3J0ID0gYV90eXBlICUgNDsKCWJfdHlwZV9zb3J0ID0gYl90eXBlICUgNDsKCXJldHVybiBhX3R5cGVfc29ydCA+IGJfdHlwZV9zb3J0ID8gMSA6IC0xOwp9CgpzdGF0aWMgaW50IGdldF9zaG9ydF9vaWQoY29uc3QgY2hhciAqbmFtZSwgaW50IGxlbiwgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgIHVuc2lnbmVkIGZsYWdzKQp7CglpbnQgc3RhdHVzOwoJc3RydWN0IGRpc2FtYmlndWF0ZV9zdGF0ZSBkczsKCWludCBxdWlldGx5ID0gISEoZmxhZ3MgJiBHRVRfT0lEX1FVSUVUTFkpOwoKCWlmIChpbml0X29iamVjdF9kaXNhbWJpZ3VhdGlvbihuYW1lLCBsZW4sICZkcykgPCAwKQoJCXJldHVybiAtMTsKCglpZiAoSEFTX01VTFRJX0JJVFMoZmxhZ3MgJiBHRVRfT0lEX0RJU0FNQklHVUFUT1JTKSkKCQlCVUcoIm11bHRpcGxlIGdldF9zaG9ydF9vaWQgZGlzYW1iaWd1YXRvciBmbGFncyIpOwoKCWlmIChmbGFncyAmIEdFVF9PSURfQ09NTUlUKQoJCWRzLmZuID0gZGlzYW1iaWd1YXRlX2NvbW1pdF9vbmx5OwoJZWxzZSBpZiAoZmxhZ3MgJiBHRVRfT0lEX0NPTU1JVFRJU0gpCgkJZHMuZm4gPSBkaXNhbWJpZ3VhdGVfY29tbWl0dGlzaF9vbmx5OwoJZWxzZSBpZiAoZmxhZ3MgJiBHRVRfT0lEX1RSRUUpCgkJZHMuZm4gPSBkaXNhbWJpZ3VhdGVfdHJlZV9vbmx5OwoJZWxzZSBpZiAoZmxhZ3MgJiBHRVRfT0lEX1RSRUVJU0gpCgkJZHMuZm4gPSBkaXNhbWJpZ3VhdGVfdHJlZWlzaF9vbmx5OwoJZWxzZSBpZiAoZmxhZ3MgJiBHRVRfT0lEX0JMT0IpCgkJZHMuZm4gPSBkaXNhbWJpZ3VhdGVfYmxvYl9vbmx5OwoJZWxzZQoJCWRzLmZuID0gZGVmYXVsdF9kaXNhbWJpZ3VhdGVfaGludDsKCglmaW5kX3Nob3J0X29iamVjdF9maWxlbmFtZSgmZHMpOwoJZmluZF9zaG9ydF9wYWNrZWRfb2JqZWN0KCZkcyk7CglzdGF0dXMgPSBmaW5pc2hfb2JqZWN0X2Rpc2FtYmlndWF0aW9uKCZkcywgb2lkKTsKCglpZiAoIXF1aWV0bHkgJiYgKHN0YXR1cyA9PSBTSE9SVF9OQU1FX0FNQklHVU9VUykpIHsKCQlzdHJ1Y3Qgb2lkX2FycmF5IGNvbGxlY3QgPSBPSURfQVJSQVlfSU5JVDsKCgkJZXJyb3IoXygic2hvcnQgU0hBMSAlcyBpcyBhbWJpZ3VvdXMiKSwgZHMuaGV4X3BmeCk7CgoJCS8qCgkJICogV2UgbWF5IHN0aWxsIGhhdmUgYW1iaWd1aXR5IGlmIHdlIHNpbXBseSBzYXcgYSBzZXJpZXMgb2YKCQkgKiBjYW5kaWRhdGVzIHRoYXQgZGlkIG5vdCBzYXRpc2Z5IG91ciBoaW50IGZ1bmN0aW9uLiBJbgoJCSAqIHRoYXQgY2FzZSwgd2Ugc3RpbGwgd2FudCB0byBzaG93IHRoZW0sIHNvIGRpc2FibGUgdGhlIGhpbnQKCQkgKiBmdW5jdGlvbiBlbnRpcmVseS4KCQkgKi8KCQlpZiAoIWRzLmFtYmlndW91cykKCQkJZHMuZm4gPSBOVUxMOwoKCQlhZHZpc2UoXygiVGhlIGNhbmRpZGF0ZXMgYXJlOiIpKTsKCQlmb3JfZWFjaF9hYmJyZXYoZHMuaGV4X3BmeCwgY29sbGVjdF9hbWJpZ3VvdXMsICZjb2xsZWN0KTsKCQlRU09SVChjb2xsZWN0Lm9pZCwgY29sbGVjdC5uciwgc29ydF9hbWJpZ3VvdXMpOwoKCQlpZiAob2lkX2FycmF5X2Zvcl9lYWNoKCZjb2xsZWN0LCBzaG93X2FtYmlndW91c19vYmplY3QsICZkcykpCgkJCUJVRygic2hvd19hbWJpZ3VvdXNfb2JqZWN0IHNob3VsZG4ndCByZXR1cm4gbm9uLXplcm8iKTsKCQlvaWRfYXJyYXlfY2xlYXIoJmNvbGxlY3QpOwoJfQoKCXJldHVybiBzdGF0dXM7Cn0KCmludCBmb3JfZWFjaF9hYmJyZXYoY29uc3QgY2hhciAqcHJlZml4LCBlYWNoX2FiYnJldl9mbiBmbiwgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IG9pZF9hcnJheSBjb2xsZWN0ID0gT0lEX0FSUkFZX0lOSVQ7CglzdHJ1Y3QgZGlzYW1iaWd1YXRlX3N0YXRlIGRzOwoJaW50IHJldDsKCglpZiAoaW5pdF9vYmplY3RfZGlzYW1iaWd1YXRpb24ocHJlZml4LCBzdHJsZW4ocHJlZml4KSwgJmRzKSA8IDApCgkJcmV0dXJuIC0xOwoKCWRzLmFsd2F5c19jYWxsX2ZuID0gMTsKCWRzLmZuID0gY29sbGVjdF9hbWJpZ3VvdXM7Cglkcy5jYl9kYXRhID0gJmNvbGxlY3Q7CglmaW5kX3Nob3J0X29iamVjdF9maWxlbmFtZSgmZHMpOwoJZmluZF9zaG9ydF9wYWNrZWRfb2JqZWN0KCZkcyk7CgoJcmV0ID0gb2lkX2FycmF5X2Zvcl9lYWNoX3VuaXF1ZSgmY29sbGVjdCwgZm4sIGNiX2RhdGEpOwoJb2lkX2FycmF5X2NsZWFyKCZjb2xsZWN0KTsKCXJldHVybiByZXQ7Cn0KCi8qCiAqIFJldHVybiB0aGUgc2xvdCBvZiB0aGUgbW9zdC1zaWduaWZpY2FudCBiaXQgc2V0IGluICJ2YWwiLiBUaGVyZSBhcmUgdmFyaW91cwogKiB3YXlzIHRvIGRvIHRoaXMgcXVpY2tseSB3aXRoIGZscygpIG9yIF9fYnVpbHRpbl9jbHpsKCksIGJ1dCBzcGVlZCBpcwogKiBwcm9iYWJseSBub3QgYSBiaWcgZGVhbCBoZXJlLgogKi8Kc3RhdGljIHVuc2lnbmVkIG1zYih1bnNpZ25lZCBsb25nIHZhbCkKewoJdW5zaWduZWQgciA9IDA7Cgl3aGlsZSAodmFsID4+PSAxKQoJCXIrKzsKCXJldHVybiByOwp9CgpzdHJ1Y3QgbWluX2FiYnJldl9kYXRhIHsKCXVuc2lnbmVkIGludCBpbml0X2xlbjsKCXVuc2lnbmVkIGludCBjdXJfbGVuOwoJY2hhciAqaGV4OwoJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkOwp9OwoKc3RhdGljIGlubGluZSBjaGFyIGdldF9oZXhfY2hhcl9mcm9tX29pZChjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCQkJIHVuc2lnbmVkIGludCBwb3MpCnsKCXN0YXRpYyBjb25zdCBjaGFyIGhleFtdID0gIjAxMjM0NTY3ODlhYmNkZWYiOwoKCWlmICgocG9zICYgMSkgPT0gMCkKCQlyZXR1cm4gaGV4W29pZC0+aGFzaFtwb3MgPj4gMV0gPj4gNF07CgllbHNlCgkJcmV0dXJuIGhleFtvaWQtPmhhc2hbcG9zID4+IDFdICYgMHhmXTsKfQoKc3RhdGljIGludCBleHRlbmRfYWJicmV2X2xlbihjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBtaW5fYWJicmV2X2RhdGEgKm1hZCA9IGNiX2RhdGE7CgoJdW5zaWduZWQgaW50IGkgPSBtYWQtPmluaXRfbGVuOwoJd2hpbGUgKG1hZC0+aGV4W2ldICYmIG1hZC0+aGV4W2ldID09IGdldF9oZXhfY2hhcl9mcm9tX29pZChvaWQsIGkpKQoJCWkrKzsKCglpZiAoaSA8IEdJVF9NQVhfUkFXU1ogJiYgaSA+PSBtYWQtPmN1cl9sZW4pCgkJbWFkLT5jdXJfbGVuID0gaSArIDE7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGZpbmRfYWJicmV2X2xlbl9mb3JfcGFjayhzdHJ1Y3QgcGFja2VkX2dpdCAqcCwKCQkJCSAgICAgc3RydWN0IG1pbl9hYmJyZXZfZGF0YSAqbWFkKQp7CglpbnQgbWF0Y2ggPSAwOwoJdWludDMyX3QgbnVtLCBmaXJzdCA9IDA7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm1hZF9vaWQ7CgoJaWYgKG9wZW5fcGFja19pbmRleChwKSB8fCAhcC0+bnVtX29iamVjdHMpCgkJcmV0dXJuOwoKCW51bSA9IHAtPm51bV9vYmplY3RzOwoJbWFkX29pZCA9IG1hZC0+b2lkOwoJbWF0Y2ggPSBic2VhcmNoX3BhY2sobWFkX29pZCwgcCwgJmZpcnN0KTsKCgkvKgoJICogZmlyc3QgaXMgbm93IHRoZSBwb3NpdGlvbiBpbiB0aGUgcGFja2ZpbGUgd2hlcmUgd2Ugd291bGQgaW5zZXJ0CgkgKiBtYWQtPmhhc2ggaWYgaXQgZG9lcyBub3QgZXhpc3QgKG9yIHRoZSBwb3NpdGlvbiBvZiBtYWQtPmhhc2ggaWYKCSAqIGl0IGRvZXMgZXhpc3QpLiBIZW5jZSwgd2UgY29uc2lkZXIgYSBtYXhpbXVtIG9mIHR3byBvYmplY3RzCgkgKiBuZWFyYnkgZm9yIHRoZSBhYmJyZXZpYXRpb24gbGVuZ3RoLgoJICovCgltYWQtPmluaXRfbGVuID0gMDsKCWlmICghbWF0Y2gpIHsKCQlpZiAobnRoX3BhY2tlZF9vYmplY3Rfb2lkKCZvaWQsIHAsIGZpcnN0KSkKCQkJZXh0ZW5kX2FiYnJldl9sZW4oJm9pZCwgbWFkKTsKCX0gZWxzZSBpZiAoZmlyc3QgPCBudW0gLSAxKSB7CgkJaWYgKG50aF9wYWNrZWRfb2JqZWN0X29pZCgmb2lkLCBwLCBmaXJzdCArIDEpKQoJCQlleHRlbmRfYWJicmV2X2xlbigmb2lkLCBtYWQpOwoJfQoJaWYgKGZpcnN0ID4gMCkgewoJCWlmIChudGhfcGFja2VkX29iamVjdF9vaWQoJm9pZCwgcCwgZmlyc3QgLSAxKSkKCQkJZXh0ZW5kX2FiYnJldl9sZW4oJm9pZCwgbWFkKTsKCX0KCW1hZC0+aW5pdF9sZW4gPSBtYWQtPmN1cl9sZW47Cn0KCnN0YXRpYyB2b2lkIGZpbmRfYWJicmV2X2xlbl9wYWNrZWQoc3RydWN0IG1pbl9hYmJyZXZfZGF0YSAqbWFkKQp7CglzdHJ1Y3QgcGFja2VkX2dpdCAqcDsKCglmb3IgKHAgPSBnZXRfcGFja2VkX2dpdCh0aGVfcmVwb3NpdG9yeSk7IHA7IHAgPSBwLT5uZXh0KQoJCWZpbmRfYWJicmV2X2xlbl9mb3JfcGFjayhwLCBtYWQpOwp9CgppbnQgZmluZF91bmlxdWVfYWJicmV2X3IoY2hhciAqaGV4LCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGludCBsZW4pCnsKCXN0cnVjdCBkaXNhbWJpZ3VhdGVfc3RhdGUgZHM7CglzdHJ1Y3QgbWluX2FiYnJldl9kYXRhIG1hZDsKCXN0cnVjdCBvYmplY3RfaWQgb2lkX3JldDsKCWlmIChsZW4gPCAwKSB7CgkJdW5zaWduZWQgbG9uZyBjb3VudCA9IGFwcHJveGltYXRlX29iamVjdF9jb3VudCgpOwoJCS8qCgkJICogQWRkIG9uZSBiZWNhdXNlIHRoZSBNU0Igb25seSB0ZWxscyB1cyB0aGUgaGlnaGVzdCBiaXQgc2V0LAoJCSAqIG5vdCBpbmNsdWRpbmcgdGhlIHZhbHVlIG9mIGFsbCB0aGUgX290aGVyXyBiaXRzIChzbyAiMTUiCgkJICogaXMgb25seSBvbmUgb2ZmIG9mIDJeNCwgYnV0IHRoZSBNU0IgaXMgdGhlIDNyZCBiaXQuCgkJICovCgkJbGVuID0gbXNiKGNvdW50KSArIDE7CgkJLyoKCQkgKiBXZSBub3cga25vdyB3ZSBoYXZlIG9uIHRoZSBvcmRlciBvZiAyXmxlbiBvYmplY3RzLCB3aGljaAoJCSAqIGV4cGVjdHMgYSBjb2xsaXNpb24gYXQgMl4obGVuLzIpLiBCdXQgd2UgYWxzbyBjYXJlIGFib3V0IGhleAoJCSAqIGNoYXJzLCBub3QgYml0cywgYW5kIHRoZXJlIGFyZSA0IGJpdHMgcGVyIGhleC4gU28gYWxsCgkJICogdG9nZXRoZXIgd2UgbmVlZCB0byBkaXZpZGUgYnkgMiBhbmQgcm91bmQgdXAuCgkJICovCgkJbGVuID0gRElWX1JPVU5EX1VQKGxlbiwgMik7CgkJLyoKCQkgKiBGb3IgdmVyeSBzbWFsbCByZXBvcywgd2Ugc3RpY2sgd2l0aCBvdXIgcmVndWxhciBmYWxsYmFjay4KCQkgKi8KCQlpZiAobGVuIDwgRkFMTEJBQ0tfREVGQVVMVF9BQkJSRVYpCgkJCWxlbiA9IEZBTExCQUNLX0RFRkFVTFRfQUJCUkVWOwoJfQoKCW9pZF90b19oZXhfcihoZXgsIG9pZCk7CglpZiAobGVuID09IEdJVF9TSEExX0hFWFNaIHx8ICFsZW4pCgkJcmV0dXJuIEdJVF9TSEExX0hFWFNaOwoKCW1hZC5pbml0X2xlbiA9IGxlbjsKCW1hZC5jdXJfbGVuID0gbGVuOwoJbWFkLmhleCA9IGhleDsKCW1hZC5vaWQgPSBvaWQ7CgoJZmluZF9hYmJyZXZfbGVuX3BhY2tlZCgmbWFkKTsKCglpZiAoaW5pdF9vYmplY3RfZGlzYW1iaWd1YXRpb24oaGV4LCBtYWQuY3VyX2xlbiwgJmRzKSA8IDApCgkJcmV0dXJuIC0xOwoKCWRzLmZuID0gZXh0ZW5kX2FiYnJldl9sZW47Cglkcy5hbHdheXNfY2FsbF9mbiA9IDE7Cglkcy5jYl9kYXRhID0gKHZvaWQgKikmbWFkOwoKCWZpbmRfc2hvcnRfb2JqZWN0X2ZpbGVuYW1lKCZkcyk7Cgkodm9pZClmaW5pc2hfb2JqZWN0X2Rpc2FtYmlndWF0aW9uKCZkcywgJm9pZF9yZXQpOwoKCWhleFttYWQuY3VyX2xlbl0gPSAwOwoJcmV0dXJuIG1hZC5jdXJfbGVuOwp9Cgpjb25zdCBjaGFyICpmaW5kX3VuaXF1ZV9hYmJyZXYoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBpbnQgbGVuKQp7CglzdGF0aWMgaW50IGJ1Zm5vOwoJc3RhdGljIGNoYXIgaGV4YnVmZmVyWzRdW0dJVF9NQVhfSEVYU1ogKyAxXTsKCWNoYXIgKmhleCA9IGhleGJ1ZmZlcltidWZub107CglidWZubyA9IChidWZubyArIDEpICUgQVJSQVlfU0laRShoZXhidWZmZXIpOwoJZmluZF91bmlxdWVfYWJicmV2X3IoaGV4LCBvaWQsIGxlbik7CglyZXR1cm4gaGV4Owp9CgpzdGF0aWMgaW50IGFtYmlndW91c19wYXRoKGNvbnN0IGNoYXIgKnBhdGgsIGludCBsZW4pCnsKCWludCBzbGFzaCA9IDE7CglpbnQgY250OwoKCWZvciAoY250ID0gMDsgY250IDwgbGVuOyBjbnQrKykgewoJCXN3aXRjaCAoKnBhdGgrKykgewoJCWNhc2UgJ1wwJzoKCQkJYnJlYWs7CgkJY2FzZSAnLyc6CgkJCWlmIChzbGFzaCkKCQkJCWJyZWFrOwoJCQlzbGFzaCA9IDE7CgkJCWNvbnRpbnVlOwoJCWNhc2UgJy4nOgoJCQljb250aW51ZTsKCQlkZWZhdWx0OgoJCQlzbGFzaCA9IDA7CgkJCWNvbnRpbnVlOwoJCX0KCQlicmVhazsKCX0KCXJldHVybiBzbGFzaDsKfQoKc3RhdGljIGlubGluZSBpbnQgYXRfbWFyayhjb25zdCBjaGFyICpzdHJpbmcsIGludCBsZW4sCgkJCSAgY29uc3QgY2hhciAqKnN1ZmZpeCwgaW50IG5yKQp7CglpbnQgaTsKCglmb3IgKGkgPSAwOyBpIDwgbnI7IGkrKykgewoJCWludCBzdWZmaXhfbGVuID0gc3RybGVuKHN1ZmZpeFtpXSk7CgkJaWYgKHN1ZmZpeF9sZW4gPD0gbGVuCgkJICAgICYmICFzdHJuY2FzZWNtcChzdHJpbmcsIHN1ZmZpeFtpXSwgc3VmZml4X2xlbikpCgkJCXJldHVybiBzdWZmaXhfbGVuOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbmxpbmUgaW50IHVwc3RyZWFtX21hcmsoY29uc3QgY2hhciAqc3RyaW5nLCBpbnQgbGVuKQp7Cgljb25zdCBjaGFyICpzdWZmaXhbXSA9IHsgIkB7dXBzdHJlYW19IiwgIkB7dX0iIH07CglyZXR1cm4gYXRfbWFyayhzdHJpbmcsIGxlbiwgc3VmZml4LCBBUlJBWV9TSVpFKHN1ZmZpeCkpOwp9CgpzdGF0aWMgaW5saW5lIGludCBwdXNoX21hcmsoY29uc3QgY2hhciAqc3RyaW5nLCBpbnQgbGVuKQp7Cgljb25zdCBjaGFyICpzdWZmaXhbXSA9IHsgIkB7cHVzaH0iIH07CglyZXR1cm4gYXRfbWFyayhzdHJpbmcsIGxlbiwgc3VmZml4LCBBUlJBWV9TSVpFKHN1ZmZpeCkpOwp9CgpzdGF0aWMgaW50IGdldF9vaWRfMShjb25zdCBjaGFyICpuYW1lLCBpbnQgbGVuLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIHVuc2lnbmVkIGxvb2t1cF9mbGFncyk7CnN0YXRpYyBpbnQgaW50ZXJwcmV0X250aF9wcmlvcl9jaGVja291dChjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbiwgc3RydWN0IHN0cmJ1ZiAqYnVmKTsKCnN0YXRpYyBpbnQgZ2V0X29pZF9iYXNpYyhjb25zdCBjaGFyICpzdHIsIGludCBsZW4sIHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJICB1bnNpZ25lZCBpbnQgZmxhZ3MpCnsKCXN0YXRpYyBjb25zdCBjaGFyICp3YXJuX21zZyA9ICJyZWZuYW1lICclLipzJyBpcyBhbWJpZ3VvdXMuIjsKCXN0YXRpYyBjb25zdCBjaGFyICpvYmplY3RfbmFtZV9tc2cgPSBOXygKCSJHaXQgbm9ybWFsbHkgbmV2ZXIgY3JlYXRlcyBhIHJlZiB0aGF0IGVuZHMgd2l0aCA0MCBoZXggY2hhcmFjdGVyc1xuIgoJImJlY2F1c2UgaXQgd2lsbCBiZSBpZ25vcmVkIHdoZW4geW91IGp1c3Qgc3BlY2lmeSA0MC1oZXguIFRoZXNlIHJlZnNcbiIKCSJtYXkgYmUgY3JlYXRlZCBieSBtaXN0YWtlLiBGb3IgZXhhbXBsZSxcbiIKCSJcbiIKCSIgIGdpdCBjaGVja291dCAtYiAkYnIgJChnaXQgcmV2LXBhcnNlIC4uLilcbiIKCSJcbiIKCSJ3aGVyZSBcIiRiclwiIGlzIHNvbWVob3cgZW1wdHkgYW5kIGEgNDAtaGV4IHJlZiBpcyBjcmVhdGVkLiBQbGVhc2VcbiIKCSJleGFtaW5lIHRoZXNlIHJlZnMgYW5kIG1heWJlIGRlbGV0ZSB0aGVtLiBUdXJuIHRoaXMgbWVzc2FnZSBvZmYgYnlcbiIKCSJydW5uaW5nIFwiZ2l0IGNvbmZpZyBhZHZpY2Uub2JqZWN0TmFtZVdhcm5pbmcgZmFsc2VcIiIpOwoJc3RydWN0IG9iamVjdF9pZCB0bXBfb2lkOwoJY2hhciAqcmVhbF9yZWYgPSBOVUxMOwoJaW50IHJlZnNfZm91bmQgPSAwOwoJaW50IGF0LCByZWZsb2dfbGVuLCBudGhfcHJpb3IgPSAwOwoKCWlmIChsZW4gPT0gR0lUX1NIQTFfSEVYU1ogJiYgIWdldF9vaWRfaGV4KHN0ciwgb2lkKSkgewoJCWlmICh3YXJuX2FtYmlndW91c19yZWZzICYmIHdhcm5fb25fb2JqZWN0X3JlZm5hbWVfYW1iaWd1aXR5KSB7CgkJCXJlZnNfZm91bmQgPSBkd2ltX3JlZihzdHIsIGxlbiwgJnRtcF9vaWQsICZyZWFsX3JlZik7CgkJCWlmIChyZWZzX2ZvdW5kID4gMCkgewoJCQkJd2FybmluZyh3YXJuX21zZywgbGVuLCBzdHIpOwoJCQkJaWYgKGFkdmljZV9vYmplY3RfbmFtZV93YXJuaW5nKQoJCQkJCWZwcmludGYoc3RkZXJyLCAiJXNcbiIsIF8ob2JqZWN0X25hbWVfbXNnKSk7CgkJCX0KCQkJZnJlZShyZWFsX3JlZik7CgkJfQoJCXJldHVybiAwOwoJfQoKCS8qIGJhc2ljQHt0aW1lIG9yIG51bWJlciBvciAtbnVtYmVyfSBmb3JtYXQgdG8gcXVlcnkgcmVmLWxvZyAqLwoJcmVmbG9nX2xlbiA9IGF0ID0gMDsKCWlmIChsZW4gJiYgc3RyW2xlbi0xXSA9PSAnfScpIHsKCQlmb3IgKGF0ID0gbGVuLTQ7IGF0ID49IDA7IGF0LS0pIHsKCQkJaWYgKHN0clthdF0gPT0gJ0AnICYmIHN0clthdCsxXSA9PSAneycpIHsKCQkJCWlmIChzdHJbYXQrMl0gPT0gJy0nKSB7CgkJCQkJaWYgKGF0ICE9IDApCgkJCQkJCS8qIEB7LU59IG5vdCBhdCBzdGFydCAqLwoJCQkJCQlyZXR1cm4gLTE7CgkJCQkJbnRoX3ByaW9yID0gMTsKCQkJCQljb250aW51ZTsKCQkJCX0KCQkJCWlmICghdXBzdHJlYW1fbWFyayhzdHIgKyBhdCwgbGVuIC0gYXQpICYmCgkJCQkgICAgIXB1c2hfbWFyayhzdHIgKyBhdCwgbGVuIC0gYXQpKSB7CgkJCQkJcmVmbG9nX2xlbiA9IChsZW4tMSkgLSAoYXQrMik7CgkJCQkJbGVuID0gYXQ7CgkJCQl9CgkJCQlicmVhazsKCQkJfQoJCX0KCX0KCgkvKiBBY2NlcHQgb25seSB1bmFtYmlndW91cyByZWYgcGF0aHMuICovCglpZiAobGVuICYmIGFtYmlndW91c19wYXRoKHN0ciwgbGVuKSkKCQlyZXR1cm4gLTE7CgoJaWYgKG50aF9wcmlvcikgewoJCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgkJaW50IGRldGFjaGVkOwoKCQlpZiAoaW50ZXJwcmV0X250aF9wcmlvcl9jaGVja291dChzdHIsIGxlbiwgJmJ1ZikgPiAwKSB7CgkJCWRldGFjaGVkID0gKGJ1Zi5sZW4gPT0gR0lUX1NIQTFfSEVYU1ogJiYgIWdldF9vaWRfaGV4KGJ1Zi5idWYsIG9pZCkpOwoJCQlzdHJidWZfcmVsZWFzZSgmYnVmKTsKCQkJaWYgKGRldGFjaGVkKQoJCQkJcmV0dXJuIDA7CgkJfQoJfQoKCWlmICghbGVuICYmIHJlZmxvZ19sZW4pCgkJLyogYWxsb3cgIkB7Li4ufSIgdG8gbWVhbiB0aGUgY3VycmVudCBicmFuY2ggcmVmbG9nICovCgkJcmVmc19mb3VuZCA9IGR3aW1fcmVmKCJIRUFEIiwgNCwgb2lkLCAmcmVhbF9yZWYpOwoJZWxzZSBpZiAocmVmbG9nX2xlbikKCQlyZWZzX2ZvdW5kID0gZHdpbV9sb2coc3RyLCBsZW4sIG9pZCwgJnJlYWxfcmVmKTsKCWVsc2UKCQlyZWZzX2ZvdW5kID0gZHdpbV9yZWYoc3RyLCBsZW4sIG9pZCwgJnJlYWxfcmVmKTsKCglpZiAoIXJlZnNfZm91bmQpCgkJcmV0dXJuIC0xOwoKCWlmICh3YXJuX2FtYmlndW91c19yZWZzICYmICEoZmxhZ3MgJiBHRVRfT0lEX1FVSUVUTFkpICYmCgkgICAgKHJlZnNfZm91bmQgPiAxIHx8CgkgICAgICFnZXRfc2hvcnRfb2lkKHN0ciwgbGVuLCAmdG1wX29pZCwgR0VUX09JRF9RVUlFVExZKSkpCgkJd2FybmluZyh3YXJuX21zZywgbGVuLCBzdHIpOwoKCWlmIChyZWZsb2dfbGVuKSB7CgkJaW50IG50aCwgaTsKCQl0aW1lc3RhbXBfdCBhdF90aW1lOwoJCXRpbWVzdGFtcF90IGNvX3RpbWU7CgkJaW50IGNvX3R6LCBjb19jbnQ7CgoJCS8qIElzIGl0IGFza2luZyBmb3IgTi10aCBlbnRyeSwgb3IgYXBwcm94aWRhdGU/ICovCgkJZm9yIChpID0gbnRoID0gMDsgMCA8PSBudGggJiYgaSA8IHJlZmxvZ19sZW47IGkrKykgewoJCQljaGFyIGNoID0gc3RyW2F0KzIraV07CgkJCWlmICgnMCcgPD0gY2ggJiYgY2ggPD0gJzknKQoJCQkJbnRoID0gbnRoICogMTAgKyBjaCAtICcwJzsKCQkJZWxzZQoJCQkJbnRoID0gLTE7CgkJfQoJCWlmICgxMDAwMDAwMDAgPD0gbnRoKSB7CgkJCWF0X3RpbWUgPSBudGg7CgkJCW50aCA9IC0xOwoJCX0gZWxzZSBpZiAoMCA8PSBudGgpCgkJCWF0X3RpbWUgPSAwOwoJCWVsc2UgewoJCQlpbnQgZXJyb3JzID0gMDsKCQkJY2hhciAqdG1wID0geHN0cm5kdXAoc3RyICsgYXQgKyAyLCByZWZsb2dfbGVuKTsKCQkJYXRfdGltZSA9IGFwcHJveGlkYXRlX2NhcmVmdWwodG1wLCAmZXJyb3JzKTsKCQkJZnJlZSh0bXApOwoJCQlpZiAoZXJyb3JzKSB7CgkJCQlmcmVlKHJlYWxfcmVmKTsKCQkJCXJldHVybiAtMTsKCQkJfQoJCX0KCQlpZiAocmVhZF9yZWZfYXQocmVhbF9yZWYsIGZsYWdzLCBhdF90aW1lLCBudGgsIG9pZCwgTlVMTCwKCQkJCSZjb190aW1lLCAmY29fdHosICZjb19jbnQpKSB7CgkJCWlmICghbGVuKSB7CgkJCQlpZiAoc3RhcnRzX3dpdGgocmVhbF9yZWYsICJyZWZzL2hlYWRzLyIpKSB7CgkJCQkJc3RyID0gcmVhbF9yZWYgKyAxMTsKCQkJCQlsZW4gPSBzdHJsZW4ocmVhbF9yZWYgKyAxMSk7CgkJCQl9IGVsc2UgewoJCQkJCS8qIGRldGFjaGVkIEhFQUQgKi8KCQkJCQlzdHIgPSAiSEVBRCI7CgkJCQkJbGVuID0gNDsKCQkJCX0KCQkJfQoJCQlpZiAoYXRfdGltZSkgewoJCQkJaWYgKCEoZmxhZ3MgJiBHRVRfT0lEX1FVSUVUTFkpKSB7CgkJCQkJd2FybmluZygiTG9nIGZvciAnJS4qcycgb25seSBnb2VzICIKCQkJCQkJImJhY2sgdG8gJXMuIiwgbGVuLCBzdHIsCgkJCQkJCXNob3dfZGF0ZShjb190aW1lLCBjb190eiwgREFURV9NT0RFKFJGQzI4MjIpKSk7CgkJCQl9CgkJCX0gZWxzZSB7CgkJCQlpZiAoZmxhZ3MgJiBHRVRfT0lEX1FVSUVUTFkpIHsKCQkJCQlleGl0KDEyOCk7CgkJCQl9CgkJCQlkaWUoIkxvZyBmb3IgJyUuKnMnIG9ubHkgaGFzICVkIGVudHJpZXMuIiwKCQkJCSAgICBsZW4sIHN0ciwgY29fY250KTsKCQkJfQoJCX0KCX0KCglmcmVlKHJlYWxfcmVmKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdldF9wYXJlbnQoY29uc3QgY2hhciAqbmFtZSwgaW50IGxlbiwKCQkgICAgICBzdHJ1Y3Qgb2JqZWN0X2lkICpyZXN1bHQsIGludCBpZHgpCnsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJaW50IHJldCA9IGdldF9vaWRfMShuYW1lLCBsZW4sICZvaWQsIEdFVF9PSURfQ09NTUlUVElTSCk7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnA7CgoJaWYgKHJldCkKCQlyZXR1cm4gcmV0OwoJY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2UodGhlX3JlcG9zaXRvcnksICZvaWQpOwoJaWYgKHBhcnNlX2NvbW1pdChjb21taXQpKQoJCXJldHVybiAtMTsKCWlmICghaWR4KSB7CgkJb2lkY3B5KHJlc3VsdCwgJmNvbW1pdC0+b2JqZWN0Lm9pZCk7CgkJcmV0dXJuIDA7Cgl9CglwID0gY29tbWl0LT5wYXJlbnRzOwoJd2hpbGUgKHApIHsKCQlpZiAoIS0taWR4KSB7CgkJCW9pZGNweShyZXN1bHQsICZwLT5pdGVtLT5vYmplY3Qub2lkKTsKCQkJcmV0dXJuIDA7CgkJfQoJCXAgPSBwLT5uZXh0OwoJfQoJcmV0dXJuIC0xOwp9CgpzdGF0aWMgaW50IGdldF9udGhfYW5jZXN0b3IoY29uc3QgY2hhciAqbmFtZSwgaW50IGxlbiwKCQkJICAgIHN0cnVjdCBvYmplY3RfaWQgKnJlc3VsdCwgaW50IGdlbmVyYXRpb24pCnsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJaW50IHJldDsKCglyZXQgPSBnZXRfb2lkXzEobmFtZSwgbGVuLCAmb2lkLCBHRVRfT0lEX0NPTU1JVFRJU0gpOwoJaWYgKHJldCkKCQlyZXR1cm4gcmV0OwoJY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2UodGhlX3JlcG9zaXRvcnksICZvaWQpOwoJaWYgKCFjb21taXQpCgkJcmV0dXJuIC0xOwoKCXdoaWxlIChnZW5lcmF0aW9uLS0pIHsKCQlpZiAocGFyc2VfY29tbWl0KGNvbW1pdCkgfHwgIWNvbW1pdC0+cGFyZW50cykKCQkJcmV0dXJuIC0xOwoJCWNvbW1pdCA9IGNvbW1pdC0+cGFyZW50cy0+aXRlbTsKCX0KCW9pZGNweShyZXN1bHQsICZjb21taXQtPm9iamVjdC5vaWQpOwoJcmV0dXJuIDA7Cn0KCnN0cnVjdCBvYmplY3QgKnBlZWxfdG9fdHlwZShjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbiwKCQkJICAgIHN0cnVjdCBvYmplY3QgKm8sIGVudW0gb2JqZWN0X3R5cGUgZXhwZWN0ZWRfdHlwZSkKewoJaWYgKG5hbWUgJiYgIW5hbWVsZW4pCgkJbmFtZWxlbiA9IHN0cmxlbihuYW1lKTsKCXdoaWxlICgxKSB7CgkJaWYgKCFvIHx8ICghby0+cGFyc2VkICYmICFwYXJzZV9vYmplY3QodGhlX3JlcG9zaXRvcnksICZvLT5vaWQpKSkKCQkJcmV0dXJuIE5VTEw7CgkJaWYgKGV4cGVjdGVkX3R5cGUgPT0gT0JKX0FOWSB8fCBvLT50eXBlID09IGV4cGVjdGVkX3R5cGUpCgkJCXJldHVybiBvOwoJCWlmIChvLT50eXBlID09IE9CSl9UQUcpCgkJCW8gPSAoKHN0cnVjdCB0YWcqKSBvKS0+dGFnZ2VkOwoJCWVsc2UgaWYgKG8tPnR5cGUgPT0gT0JKX0NPTU1JVCkKCQkJbyA9ICYoZ2V0X2NvbW1pdF90cmVlKCgoc3RydWN0IGNvbW1pdCAqKW8pKS0+b2JqZWN0KTsKCQllbHNlIHsKCQkJaWYgKG5hbWUpCgkJCQllcnJvcigiJS4qczogZXhwZWN0ZWQgJXMgdHlwZSwgYnV0IHRoZSBvYmplY3QgIgoJCQkJICAgICAgImRlcmVmZXJlbmNlcyB0byAlcyB0eXBlIiwKCQkJCSAgICAgIG5hbWVsZW4sIG5hbWUsIHR5cGVfbmFtZShleHBlY3RlZF90eXBlKSwKCQkJCSAgICAgIHR5cGVfbmFtZShvLT50eXBlKSk7CgkJCXJldHVybiBOVUxMOwoJCX0KCX0KfQoKc3RhdGljIGludCBwZWVsX29uaW9uKGNvbnN0IGNoYXIgKm5hbWUsIGludCBsZW4sIHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkgICAgICB1bnNpZ25lZCBsb29rdXBfZmxhZ3MpCnsKCXN0cnVjdCBvYmplY3RfaWQgb3V0ZXI7Cgljb25zdCBjaGFyICpzcDsKCXVuc2lnbmVkIGludCBleHBlY3RlZF90eXBlID0gMDsKCXN0cnVjdCBvYmplY3QgKm87CgoJLyoKCSAqICJyZWZee3R5cGV9IiBkZXJlZmVyZW5jZXMgcmVmIHJlcGVhdGVkbHkgdW50aWwgeW91IGNhbm5vdAoJICogZGVyZWZlcmVuY2UgYW55bW9yZSwgb3IgeW91IGdldCBhbiBvYmplY3Qgb2YgZ2l2ZW4gdHlwZSwKCSAqIHdoaWNoZXZlciBjb21lcyBmaXJzdC4gICJyZWZee30iIG1lYW5zIGp1c3QgZGVyZWZlcmVuY2UKCSAqIHRhZ3MgdW50aWwgeW91IGdldCBhIG5vbi10YWcuICAicmVmXjAiIGlzIGEgc2hvcnRoYW5kIGZvcgoJICogInJlZl57Y29tbWl0fSIuICAiY29tbWl0Xnt0cmVlfSIgY291bGQgYmUgdXNlZCB0byBmaW5kIHRoZQoJICogdG9wLWxldmVsIHRyZWUgb2YgdGhlIGdpdmVuIGNvbW1pdC4KCSAqLwoJaWYgKGxlbiA8IDQgfHwgbmFtZVtsZW4tMV0gIT0gJ30nKQoJCXJldHVybiAtMTsKCglmb3IgKHNwID0gbmFtZSArIGxlbiAtIDE7IG5hbWUgPD0gc3A7IHNwLS0pIHsKCQlpbnQgY2ggPSAqc3A7CgkJaWYgKGNoID09ICd7JyAmJiBuYW1lIDwgc3AgJiYgc3BbLTFdID09ICdeJykKCQkJYnJlYWs7Cgl9CglpZiAoc3AgPD0gbmFtZSkKCQlyZXR1cm4gLTE7CgoJc3ArKzsgLyogYmVnaW5uaW5nIG9mIHR5cGUgbmFtZSwgb3IgY2xvc2luZyBicmFjZSBmb3IgZW1wdHkgKi8KCWlmIChzdGFydHNfd2l0aChzcCwgImNvbW1pdH0iKSkKCQlleHBlY3RlZF90eXBlID0gT0JKX0NPTU1JVDsKCWVsc2UgaWYgKHN0YXJ0c193aXRoKHNwLCAidGFnfSIpKQoJCWV4cGVjdGVkX3R5cGUgPSBPQkpfVEFHOwoJZWxzZSBpZiAoc3RhcnRzX3dpdGgoc3AsICJ0cmVlfSIpKQoJCWV4cGVjdGVkX3R5cGUgPSBPQkpfVFJFRTsKCWVsc2UgaWYgKHN0YXJ0c193aXRoKHNwLCAiYmxvYn0iKSkKCQlleHBlY3RlZF90eXBlID0gT0JKX0JMT0I7CgllbHNlIGlmIChzdGFydHNfd2l0aChzcCwgIm9iamVjdH0iKSkKCQlleHBlY3RlZF90eXBlID0gT0JKX0FOWTsKCWVsc2UgaWYgKHNwWzBdID09ICd9JykKCQlleHBlY3RlZF90eXBlID0gT0JKX05PTkU7CgllbHNlIGlmIChzcFswXSA9PSAnLycpCgkJZXhwZWN0ZWRfdHlwZSA9IE9CSl9DT01NSVQ7CgllbHNlCgkJcmV0dXJuIC0xOwoKCWxvb2t1cF9mbGFncyAmPSB+R0VUX09JRF9ESVNBTUJJR1VBVE9SUzsKCWlmIChleHBlY3RlZF90eXBlID09IE9CSl9DT01NSVQpCgkJbG9va3VwX2ZsYWdzIHw9IEdFVF9PSURfQ09NTUlUVElTSDsKCWVsc2UgaWYgKGV4cGVjdGVkX3R5cGUgPT0gT0JKX1RSRUUpCgkJbG9va3VwX2ZsYWdzIHw9IEdFVF9PSURfVFJFRUlTSDsKCglpZiAoZ2V0X29pZF8xKG5hbWUsIHNwIC0gbmFtZSAtIDIsICZvdXRlciwgbG9va3VwX2ZsYWdzKSkKCQlyZXR1cm4gLTE7CgoJbyA9IHBhcnNlX29iamVjdCh0aGVfcmVwb3NpdG9yeSwgJm91dGVyKTsKCWlmICghbykKCQlyZXR1cm4gLTE7CglpZiAoIWV4cGVjdGVkX3R5cGUpIHsKCQlvID0gZGVyZWZfdGFnKHRoZV9yZXBvc2l0b3J5LCBvLCBuYW1lLCBzcCAtIG5hbWUgLSAyKTsKCQlpZiAoIW8gfHwgKCFvLT5wYXJzZWQgJiYgIXBhcnNlX29iamVjdCh0aGVfcmVwb3NpdG9yeSwgJm8tPm9pZCkpKQoJCQlyZXR1cm4gLTE7CgkJb2lkY3B5KG9pZCwgJm8tPm9pZCk7CgkJcmV0dXJuIDA7Cgl9CgoJLyoKCSAqIEF0IHRoaXMgcG9pbnQsIHRoZSBzeW50YXggbG9vayBjb3JyZWN0LCBzbwoJICogaWYgd2UgZG8gbm90IGdldCB0aGUgbmVlZGVkIG9iamVjdCwgd2Ugc2hvdWxkCgkgKiBiYXJmLgoJICovCglvID0gcGVlbF90b190eXBlKG5hbWUsIGxlbiwgbywgZXhwZWN0ZWRfdHlwZSk7CglpZiAoIW8pCgkJcmV0dXJuIC0xOwoKCW9pZGNweShvaWQsICZvLT5vaWQpOwoJaWYgKHNwWzBdID09ICcvJykgewoJCS8qICIkY29tbWl0XnsvZm9vfSIgKi8KCQljaGFyICpwcmVmaXg7CgkJaW50IHJldDsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QgPSBOVUxMOwoKCQkvKgoJCSAqICRjb21taXReey99LiBTb21lIHJlZ2V4IGltcGxlbWVudGF0aW9uIG1heSByZWplY3QuCgkJICogV2UgZG9uJ3QgbmVlZCByZWdleCBhbnl3YXkuICcnIHBhdHRlcm4gYWx3YXlzIG1hdGNoZXMuCgkJICovCgkJaWYgKHNwWzFdID09ICd9JykKCQkJcmV0dXJuIDA7CgoJCXByZWZpeCA9IHhzdHJuZHVwKHNwICsgMSwgbmFtZSArIGxlbiAtIDEgLSAoc3AgKyAxKSk7CgkJY29tbWl0X2xpc3RfaW5zZXJ0KChzdHJ1Y3QgY29tbWl0ICopbywgJmxpc3QpOwoJCXJldCA9IGdldF9vaWRfb25lbGluZShwcmVmaXgsIG9pZCwgbGlzdCk7CgkJZnJlZShwcmVmaXgpOwoJCXJldHVybiByZXQ7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBnZXRfZGVzY3JpYmVfbmFtZShjb25zdCBjaGFyICpuYW1lLCBpbnQgbGVuLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCWNvbnN0IGNoYXIgKmNwOwoJdW5zaWduZWQgZmxhZ3MgPSBHRVRfT0lEX1FVSUVUTFkgfCBHRVRfT0lEX0NPTU1JVDsKCglmb3IgKGNwID0gbmFtZSArIGxlbiAtIDE7IG5hbWUgKyAyIDw9IGNwOyBjcC0tKSB7CgkJY2hhciBjaCA9ICpjcDsKCQlpZiAoIWlzeGRpZ2l0KGNoKSkgewoJCQkvKiBXZSBtdXN0IGJlIGxvb2tpbmcgYXQgZyBpbiAiU09NRVRISU5HLWciCgkJCSAqIGZvciBpdCB0byBiZSBkZXNjcmliZSBvdXRwdXQuCgkJCSAqLwoJCQlpZiAoY2ggPT0gJ2cnICYmIGNwWy0xXSA9PSAnLScpIHsKCQkJCWNwKys7CgkJCQlsZW4gLT0gY3AgLSBuYW1lOwoJCQkJcmV0dXJuIGdldF9zaG9ydF9vaWQoY3AsIGxlbiwgb2lkLCBmbGFncyk7CgkJCX0KCQl9Cgl9CglyZXR1cm4gLTE7Cn0KCnN0YXRpYyBpbnQgZ2V0X29pZF8xKGNvbnN0IGNoYXIgKm5hbWUsIGludCBsZW4sIHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgdW5zaWduZWQgbG9va3VwX2ZsYWdzKQp7CglpbnQgcmV0LCBoYXNfc3VmZml4OwoJY29uc3QgY2hhciAqY3A7CgoJLyoKCSAqICJuYW1lfjMiIGlzICJuYW1lXl5eIiwgIm5hbWV+IiBpcyAibmFtZX4xIiwgYW5kICJuYW1lXiIgaXMgIm5hbWVeMSIuCgkgKi8KCWhhc19zdWZmaXggPSAwOwoJZm9yIChjcCA9IG5hbWUgKyBsZW4gLSAxOyBuYW1lIDw9IGNwOyBjcC0tKSB7CgkJaW50IGNoID0gKmNwOwoJCWlmICgnMCcgPD0gY2ggJiYgY2ggPD0gJzknKQoJCQljb250aW51ZTsKCQlpZiAoY2ggPT0gJ34nIHx8IGNoID09ICdeJykKCQkJaGFzX3N1ZmZpeCA9IGNoOwoJCWJyZWFrOwoJfQoKCWlmIChoYXNfc3VmZml4KSB7CgkJaW50IG51bSA9IDA7CgkJaW50IGxlbjEgPSBjcCAtIG5hbWU7CgkJY3ArKzsKCQl3aGlsZSAoY3AgPCBuYW1lICsgbGVuKQoJCQludW0gPSBudW0gKiAxMCArICpjcCsrIC0gJzAnOwoJCWlmICghbnVtICYmIGxlbjEgPT0gbGVuIC0gMSkKCQkJbnVtID0gMTsKCQlpZiAoaGFzX3N1ZmZpeCA9PSAnXicpCgkJCXJldHVybiBnZXRfcGFyZW50KG5hbWUsIGxlbjEsIG9pZCwgbnVtKTsKCQkvKiBlbHNlIGlmIChoYXNfc3VmZml4ID09ICd+JykgLS0gZ29lcyB3aXRob3V0IHNheWluZyAqLwoJCXJldHVybiBnZXRfbnRoX2FuY2VzdG9yKG5hbWUsIGxlbjEsIG9pZCwgbnVtKTsKCX0KCglyZXQgPSBwZWVsX29uaW9uKG5hbWUsIGxlbiwgb2lkLCBsb29rdXBfZmxhZ3MpOwoJaWYgKCFyZXQpCgkJcmV0dXJuIDA7CgoJcmV0ID0gZ2V0X29pZF9iYXNpYyhuYW1lLCBsZW4sIG9pZCwgbG9va3VwX2ZsYWdzKTsKCWlmICghcmV0KQoJCXJldHVybiAwOwoKCS8qIEl0IGNvdWxkIGJlIGRlc2NyaWJlIG91dHB1dCB0aGF0IGlzICJTT01FVEhJTkctZ1hYWFgiICovCglyZXQgPSBnZXRfZGVzY3JpYmVfbmFtZShuYW1lLCBsZW4sIG9pZCk7CglpZiAoIXJldCkKCQlyZXR1cm4gMDsKCglyZXR1cm4gZ2V0X3Nob3J0X29pZChuYW1lLCBsZW4sIG9pZCwgbG9va3VwX2ZsYWdzKTsKfQoKLyoKICogVGhpcyBpbnRlcnByZXRzIG5hbWVzIGxpa2UgJzovSW5pdGlhbCByZXZpc2lvbiBvZiAiZ2l0IicgYnkgc2VhcmNoaW5nCiAqIHRocm91Z2ggaGlzdG9yeSBhbmQgcmV0dXJuaW5nIHRoZSBmaXJzdCBjb21taXQgd2hvc2UgbWVzc2FnZSBzdGFydHMKICogdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi4KICoKICogRm9yIG5lZ2F0aXZlLW1hdGNoaW5nLCBwcmVmaXggdGhlIHBhdHRlcm4tcGFydCB3aXRoICchLScsIGxpa2U6ICc6LyEtV0lQJy4KICoKICogRm9yIGEgbGl0ZXJhbCAnIScgY2hhcmFjdGVyIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBwYXR0ZXJuLCB5b3UgaGF2ZSB0byByZXBlYXQKICogdGhhdCwgbGlrZTogJzovISFmb28nCiAqCiAqIEZvciBmdXR1cmUgZXh0ZW5zaW9uLCBhbGwgb3RoZXIgc2VxdWVuY2VzIGJlZ2lubmluZyB3aXRoICc6LyEnIGFyZSByZXNlcnZlZC4KICovCgovKiBSZW1lbWJlciB0byB1cGRhdGUgb2JqZWN0IGZsYWcgYWxsb2NhdGlvbiBpbiBvYmplY3QuaCAqLwojZGVmaW5lIE9ORUxJTkVfU0VFTiAoMXU8PDIwKQoKc3RhdGljIGludCBoYW5kbGVfb25lX3JlZihjb25zdCBjaGFyICpwYXRoLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCSAgaW50IGZsYWcsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqKmxpc3QgPSBjYl9kYXRhOwoJc3RydWN0IG9iamVjdCAqb2JqZWN0ID0gcGFyc2Vfb2JqZWN0KHRoZV9yZXBvc2l0b3J5LCBvaWQpOwoJaWYgKCFvYmplY3QpCgkJcmV0dXJuIDA7CglpZiAob2JqZWN0LT50eXBlID09IE9CSl9UQUcpIHsKCQlvYmplY3QgPSBkZXJlZl90YWcodGhlX3JlcG9zaXRvcnksIG9iamVjdCwgcGF0aCwKCQkJCSAgIHN0cmxlbihwYXRoKSk7CgkJaWYgKCFvYmplY3QpCgkJCXJldHVybiAwOwoJfQoJaWYgKG9iamVjdC0+dHlwZSAhPSBPQkpfQ09NTUlUKQoJCXJldHVybiAwOwoJY29tbWl0X2xpc3RfaW5zZXJ0KChzdHJ1Y3QgY29tbWl0ICopb2JqZWN0LCBsaXN0KTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdldF9vaWRfb25lbGluZShjb25zdCBjaGFyICpwcmVmaXgsIHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJICAgIHN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpiYWNrdXAgPSBOVUxMLCAqbDsKCWludCBmb3VuZCA9IDA7CglpbnQgbmVnYXRpdmUgPSAwOwoJcmVnZXhfdCByZWdleDsKCglpZiAocHJlZml4WzBdID09ICchJykgewoJCXByZWZpeCsrOwoKCQlpZiAocHJlZml4WzBdID09ICctJykgewoJCQlwcmVmaXgrKzsKCQkJbmVnYXRpdmUgPSAxOwoJCX0gZWxzZSBpZiAocHJlZml4WzBdICE9ICchJykgewoJCQlyZXR1cm4gLTE7CgkJfQoJfQoKCWlmIChyZWdjb21wKCZyZWdleCwgcHJlZml4LCBSRUdfRVhURU5ERUQpKQoJCXJldHVybiAtMTsKCglmb3IgKGwgPSBsaXN0OyBsOyBsID0gbC0+bmV4dCkgewoJCWwtPml0ZW0tPm9iamVjdC5mbGFncyB8PSBPTkVMSU5FX1NFRU47CgkJY29tbWl0X2xpc3RfaW5zZXJ0KGwtPml0ZW0sICZiYWNrdXApOwoJfQoJd2hpbGUgKGxpc3QpIHsKCQljb25zdCBjaGFyICpwLCAqYnVmOwoJCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCQlpbnQgbWF0Y2hlczsKCgkJY29tbWl0ID0gcG9wX21vc3RfcmVjZW50X2NvbW1pdCgmbGlzdCwgT05FTElORV9TRUVOKTsKCQlpZiAoIXBhcnNlX29iamVjdCh0aGVfcmVwb3NpdG9yeSwgJmNvbW1pdC0+b2JqZWN0Lm9pZCkpCgkJCWNvbnRpbnVlOwoJCWJ1ZiA9IGdldF9jb21taXRfYnVmZmVyKGNvbW1pdCwgTlVMTCk7CgkJcCA9IHN0cnN0cihidWYsICJcblxuIik7CgkJbWF0Y2hlcyA9IG5lZ2F0aXZlIF4gKHAgJiYgIXJlZ2V4ZWMoJnJlZ2V4LCBwICsgMiwgMCwgTlVMTCwgMCkpOwoJCXVudXNlX2NvbW1pdF9idWZmZXIoY29tbWl0LCBidWYpOwoKCQlpZiAobWF0Y2hlcykgewoJCQlvaWRjcHkob2lkLCAmY29tbWl0LT5vYmplY3Qub2lkKTsKCQkJZm91bmQgPSAxOwoJCQlicmVhazsKCQl9Cgl9CglyZWdmcmVlKCZyZWdleCk7CglmcmVlX2NvbW1pdF9saXN0KGxpc3QpOwoJZm9yIChsID0gYmFja3VwOyBsOyBsID0gbC0+bmV4dCkKCQljbGVhcl9jb21taXRfbWFya3MobC0+aXRlbSwgT05FTElORV9TRUVOKTsKCWZyZWVfY29tbWl0X2xpc3QoYmFja3VwKTsKCXJldHVybiBmb3VuZCA/IDAgOiAtMTsKfQoKc3RydWN0IGdyYWJfbnRoX2JyYW5jaF9zd2l0Y2hfY2JkYXRhIHsKCWludCByZW1haW5pbmc7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZjsKfTsKCnN0YXRpYyBpbnQgZ3JhYl9udGhfYnJhbmNoX3N3aXRjaChzdHJ1Y3Qgb2JqZWN0X2lkICpvb2lkLCBzdHJ1Y3Qgb2JqZWN0X2lkICpub2lkLAoJCQkJICBjb25zdCBjaGFyICplbWFpbCwgdGltZXN0YW1wX3QgdGltZXN0YW1wLCBpbnQgdHosCgkJCQkgIGNvbnN0IGNoYXIgKm1lc3NhZ2UsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBncmFiX250aF9icmFuY2hfc3dpdGNoX2NiZGF0YSAqY2IgPSBjYl9kYXRhOwoJY29uc3QgY2hhciAqbWF0Y2ggPSBOVUxMLCAqdGFyZ2V0ID0gTlVMTDsKCXNpemVfdCBsZW47CgoJaWYgKHNraXBfcHJlZml4KG1lc3NhZ2UsICJjaGVja291dDogbW92aW5nIGZyb20gIiwgJm1hdGNoKSkKCQl0YXJnZXQgPSBzdHJzdHIobWF0Y2gsICIgdG8gIik7CgoJaWYgKCFtYXRjaCB8fCAhdGFyZ2V0KQoJCXJldHVybiAwOwoJaWYgKC0tKGNiLT5yZW1haW5pbmcpID09IDApIHsKCQlsZW4gPSB0YXJnZXQgLSBtYXRjaDsKCQlzdHJidWZfcmVzZXQoJmNiLT5idWYpOwoJCXN0cmJ1Zl9hZGQoJmNiLT5idWYsIG1hdGNoLCBsZW4pOwoJCXJldHVybiAxOyAvKiB3ZSBhcmUgZG9uZSAqLwoJfQoJcmV0dXJuIDA7Cn0KCi8qCiAqIFBhcnNlIEB7LU59IHN5bnRheCwgcmV0dXJuIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBwYXJzZWQKICogaWYgc3VjY2Vzc2Z1bDsgb3RoZXJ3aXNlIHNpZ25hbCBhbiBlcnJvciB3aXRoIG5lZ2F0aXZlIHZhbHVlLgogKi8Kc3RhdGljIGludCBpbnRlcnByZXRfbnRoX3ByaW9yX2NoZWNrb3V0KGNvbnN0IGNoYXIgKm5hbWUsIGludCBuYW1lbGVuLAoJCQkJCXN0cnVjdCBzdHJidWYgKmJ1ZikKewoJbG9uZyBudGg7CglpbnQgcmV0dmFsOwoJc3RydWN0IGdyYWJfbnRoX2JyYW5jaF9zd2l0Y2hfY2JkYXRhIGNiOwoJY29uc3QgY2hhciAqYnJhY2U7CgljaGFyICpudW1fZW5kOwoKCWlmIChuYW1lbGVuIDwgNCkKCQlyZXR1cm4gLTE7CglpZiAobmFtZVswXSAhPSAnQCcgfHwgbmFtZVsxXSAhPSAneycgfHwgbmFtZVsyXSAhPSAnLScpCgkJcmV0dXJuIC0xOwoJYnJhY2UgPSBtZW1jaHIobmFtZSwgJ30nLCBuYW1lbGVuKTsKCWlmICghYnJhY2UpCgkJcmV0dXJuIC0xOwoJbnRoID0gc3RydG9sKG5hbWUgKyAzLCAmbnVtX2VuZCwgMTApOwoJaWYgKG51bV9lbmQgIT0gYnJhY2UpCgkJcmV0dXJuIC0xOwoJaWYgKG50aCA8PSAwKQoJCXJldHVybiAtMTsKCWNiLnJlbWFpbmluZyA9IG50aDsKCXN0cmJ1Zl9pbml0KCZjYi5idWYsIDIwKTsKCglyZXR2YWwgPSAwOwoJaWYgKDAgPCBmb3JfZWFjaF9yZWZsb2dfZW50X3JldmVyc2UoIkhFQUQiLCBncmFiX250aF9icmFuY2hfc3dpdGNoLCAmY2IpKSB7CgkJc3RyYnVmX3Jlc2V0KGJ1Zik7CgkJc3RyYnVmX2FkZGJ1ZihidWYsICZjYi5idWYpOwoJCXJldHZhbCA9IGJyYWNlIC0gbmFtZSArIDE7Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJmNiLmJ1Zik7CglyZXR1cm4gcmV0dmFsOwp9CgppbnQgZ2V0X29pZF9tYihjb25zdCBjaGFyICpuYW1lLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXN0cnVjdCBjb21taXQgKm9uZSwgKnR3bzsKCXN0cnVjdCBjb21taXRfbGlzdCAqbWJzOwoJc3RydWN0IG9iamVjdF9pZCBvaWRfdG1wOwoJY29uc3QgY2hhciAqZG90czsKCWludCBzdDsKCglkb3RzID0gc3Ryc3RyKG5hbWUsICIuLi4iKTsKCWlmICghZG90cykKCQlyZXR1cm4gZ2V0X29pZChuYW1lLCBvaWQpOwoJaWYgKGRvdHMgPT0gbmFtZSkKCQlzdCA9IGdldF9vaWQoIkhFQUQiLCAmb2lkX3RtcCk7CgllbHNlIHsKCQlzdHJ1Y3Qgc3RyYnVmIHNiOwoJCXN0cmJ1Zl9pbml0KCZzYiwgZG90cyAtIG5hbWUpOwoJCXN0cmJ1Zl9hZGQoJnNiLCBuYW1lLCBkb3RzIC0gbmFtZSk7CgkJc3QgPSBnZXRfb2lkX2NvbW1pdHRpc2goc2IuYnVmLCAmb2lkX3RtcCk7CgkJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCX0KCWlmIChzdCkKCQlyZXR1cm4gc3Q7CglvbmUgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkodGhlX3JlcG9zaXRvcnksICZvaWRfdG1wLCAwKTsKCWlmICghb25lKQoJCXJldHVybiAtMTsKCglpZiAoZ2V0X29pZF9jb21taXR0aXNoKGRvdHNbM10gPyAoZG90cyArIDMpIDogIkhFQUQiLCAmb2lkX3RtcCkpCgkJcmV0dXJuIC0xOwoJdHdvID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfZ2VudGx5KHRoZV9yZXBvc2l0b3J5LCAmb2lkX3RtcCwgMCk7CglpZiAoIXR3bykKCQlyZXR1cm4gLTE7CgltYnMgPSBnZXRfbWVyZ2VfYmFzZXMob25lLCB0d28pOwoJaWYgKCFtYnMgfHwgbWJzLT5uZXh0KQoJCXN0ID0gLTE7CgllbHNlIHsKCQlzdCA9IDA7CgkJb2lkY3B5KG9pZCwgJm1icy0+aXRlbS0+b2JqZWN0Lm9pZCk7Cgl9CglmcmVlX2NvbW1pdF9saXN0KG1icyk7CglyZXR1cm4gc3Q7Cn0KCi8qIHBhcnNlIEBzb21ldGhpbmcgc3ludGF4LCB3aGVuICdzb21ldGhpbmcnIGlzIG5vdCB7Lip9ICovCnN0YXRpYyBpbnQgaW50ZXJwcmV0X2VtcHR5X2F0KGNvbnN0IGNoYXIgKm5hbWUsIGludCBuYW1lbGVuLCBpbnQgbGVuLCBzdHJ1Y3Qgc3RyYnVmICpidWYpCnsKCWNvbnN0IGNoYXIgKm5leHQ7CgoJaWYgKGxlbiB8fCBuYW1lWzFdID09ICd7JykKCQlyZXR1cm4gLTE7CgoJLyogbWFrZSBzdXJlIGl0J3MgYSBzaW5nbGUgQCwgb3IgQEB7Lip9LCBub3QgQGZvbyAqLwoJbmV4dCA9IG1lbWNocihuYW1lICsgbGVuICsgMSwgJ0AnLCBuYW1lbGVuIC0gbGVuIC0gMSk7CglpZiAobmV4dCAmJiBuZXh0WzFdICE9ICd7JykKCQlyZXR1cm4gLTE7CglpZiAoIW5leHQpCgkJbmV4dCA9IG5hbWUgKyBuYW1lbGVuOwoJaWYgKG5leHQgIT0gbmFtZSArIDEpCgkJcmV0dXJuIC0xOwoKCXN0cmJ1Zl9yZXNldChidWYpOwoJc3RyYnVmX2FkZChidWYsICJIRUFEIiwgNCk7CglyZXR1cm4gMTsKfQoKc3RhdGljIGludCByZWludGVycHJldChjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbiwgaW50IGxlbiwKCQkgICAgICAgc3RydWN0IHN0cmJ1ZiAqYnVmLCB1bnNpZ25lZCBhbGxvd2VkKQp7CgkvKiB3ZSBoYXZlIGV4dHJhIGRhdGEsIHdoaWNoIG1pZ2h0IG5lZWQgZnVydGhlciBwcm9jZXNzaW5nICovCglzdHJ1Y3Qgc3RyYnVmIHRtcCA9IFNUUkJVRl9JTklUOwoJaW50IHVzZWQgPSBidWYtPmxlbjsKCWludCByZXQ7CgoJc3RyYnVmX2FkZChidWYsIG5hbWUgKyBsZW4sIG5hbWVsZW4gLSBsZW4pOwoJcmV0ID0gaW50ZXJwcmV0X2JyYW5jaF9uYW1lKGJ1Zi0+YnVmLCBidWYtPmxlbiwgJnRtcCwgYWxsb3dlZCk7CgkvKiB0aGF0IGRhdGEgd2FzIG5vdCBpbnRlcnByZXRlZCwgcmVtb3ZlIG91ciBjcnVmdCAqLwoJaWYgKHJldCA8IDApIHsKCQlzdHJidWZfc2V0bGVuKGJ1ZiwgdXNlZCk7CgkJcmV0dXJuIGxlbjsKCX0KCXN0cmJ1Zl9yZXNldChidWYpOwoJc3RyYnVmX2FkZGJ1ZihidWYsICZ0bXApOwoJc3RyYnVmX3JlbGVhc2UoJnRtcCk7CgkvKiB0d2VhayBmb3Igc2l6ZSBvZiB7LU59IHZlcnN1cyBleHBhbmRlZCByZWYgbmFtZSAqLwoJcmV0dXJuIHJldCAtIHVzZWQgKyBsZW47Cn0KCnN0YXRpYyB2b2lkIHNldF9zaG9ydGVuZWRfcmVmKHN0cnVjdCBzdHJidWYgKmJ1ZiwgY29uc3QgY2hhciAqcmVmKQp7CgljaGFyICpzID0gc2hvcnRlbl91bmFtYmlndW91c19yZWYocmVmLCAwKTsKCXN0cmJ1Zl9yZXNldChidWYpOwoJc3RyYnVmX2FkZHN0cihidWYsIHMpOwoJZnJlZShzKTsKfQoKc3RhdGljIGludCBicmFuY2hfaW50ZXJwcmV0X2FsbG93ZWQoY29uc3QgY2hhciAqcmVmbmFtZSwgdW5zaWduZWQgYWxsb3dlZCkKewoJaWYgKCFhbGxvd2VkKQoJCXJldHVybiAxOwoKCWlmICgoYWxsb3dlZCAmIElOVEVSUFJFVF9CUkFOQ0hfTE9DQUwpICYmCgkgICAgc3RhcnRzX3dpdGgocmVmbmFtZSwgInJlZnMvaGVhZHMvIikpCgkJcmV0dXJuIDE7CglpZiAoKGFsbG93ZWQgJiBJTlRFUlBSRVRfQlJBTkNIX1JFTU9URSkgJiYKCSAgICBzdGFydHNfd2l0aChyZWZuYW1lLCAicmVmcy9yZW1vdGVzLyIpKQoJCXJldHVybiAxOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGludGVycHJldF9icmFuY2hfbWFyayhjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbiwKCQkJCSBpbnQgYXQsIHN0cnVjdCBzdHJidWYgKmJ1ZiwKCQkJCSBpbnQgKCpnZXRfbWFyaykoY29uc3QgY2hhciAqLCBpbnQpLAoJCQkJIGNvbnN0IGNoYXIgKigqZ2V0X2RhdGEpKHN0cnVjdCBicmFuY2ggKiwKCQkJCQkJCSBzdHJ1Y3Qgc3RyYnVmICopLAoJCQkJIHVuc2lnbmVkIGFsbG93ZWQpCnsKCWludCBsZW47CglzdHJ1Y3QgYnJhbmNoICpicmFuY2g7CglzdHJ1Y3Qgc3RyYnVmIGVyciA9IFNUUkJVRl9JTklUOwoJY29uc3QgY2hhciAqdmFsdWU7CgoJbGVuID0gZ2V0X21hcmsobmFtZSArIGF0LCBuYW1lbGVuIC0gYXQpOwoJaWYgKCFsZW4pCgkJcmV0dXJuIC0xOwoKCWlmIChtZW1jaHIobmFtZSwgJzonLCBhdCkpCgkJcmV0dXJuIC0xOwoKCWlmIChhdCkgewoJCWNoYXIgKm5hbWVfc3RyID0geG1lbWR1cHoobmFtZSwgYXQpOwoJCWJyYW5jaCA9IGJyYW5jaF9nZXQobmFtZV9zdHIpOwoJCWZyZWUobmFtZV9zdHIpOwoJfSBlbHNlCgkJYnJhbmNoID0gYnJhbmNoX2dldChOVUxMKTsKCgl2YWx1ZSA9IGdldF9kYXRhKGJyYW5jaCwgJmVycik7CglpZiAoIXZhbHVlKQoJCWRpZSgiJXMiLCBlcnIuYnVmKTsKCglpZiAoIWJyYW5jaF9pbnRlcnByZXRfYWxsb3dlZCh2YWx1ZSwgYWxsb3dlZCkpCgkJcmV0dXJuIC0xOwoKCXNldF9zaG9ydGVuZWRfcmVmKGJ1ZiwgdmFsdWUpOwoJcmV0dXJuIGxlbiArIGF0Owp9CgppbnQgaW50ZXJwcmV0X2JyYW5jaF9uYW1lKGNvbnN0IGNoYXIgKm5hbWUsIGludCBuYW1lbGVuLCBzdHJ1Y3Qgc3RyYnVmICpidWYsCgkJCSAgdW5zaWduZWQgYWxsb3dlZCkKewoJY2hhciAqYXQ7Cgljb25zdCBjaGFyICpzdGFydDsKCWludCBsZW47CgoJaWYgKCFuYW1lbGVuKQoJCW5hbWVsZW4gPSBzdHJsZW4obmFtZSk7CgoJaWYgKCFhbGxvd2VkIHx8IChhbGxvd2VkICYgSU5URVJQUkVUX0JSQU5DSF9MT0NBTCkpIHsKCQlsZW4gPSBpbnRlcnByZXRfbnRoX3ByaW9yX2NoZWNrb3V0KG5hbWUsIG5hbWVsZW4sIGJ1Zik7CgkJaWYgKCFsZW4pIHsKCQkJcmV0dXJuIGxlbjsgLyogc3ludGF4IE9rLCBub3QgZW5vdWdoIHN3aXRjaGVzICovCgkJfSBlbHNlIGlmIChsZW4gPiAwKSB7CgkJCWlmIChsZW4gPT0gbmFtZWxlbikKCQkJCXJldHVybiBsZW47IC8qIGNvbnN1bWVkIGFsbCAqLwoJCQllbHNlCgkJCQlyZXR1cm4gcmVpbnRlcnByZXQobmFtZSwgbmFtZWxlbiwgbGVuLCBidWYsIGFsbG93ZWQpOwoJCX0KCX0KCglmb3IgKHN0YXJ0ID0gbmFtZTsKCSAgICAgKGF0ID0gbWVtY2hyKHN0YXJ0LCAnQCcsIG5hbWVsZW4gLSAoc3RhcnQgLSBuYW1lKSkpOwoJICAgICBzdGFydCA9IGF0ICsgMSkgewoKCQlpZiAoIWFsbG93ZWQgfHwgKGFsbG93ZWQgJiBJTlRFUlBSRVRfQlJBTkNIX0hFQUQpKSB7CgkJCWxlbiA9IGludGVycHJldF9lbXB0eV9hdChuYW1lLCBuYW1lbGVuLCBhdCAtIG5hbWUsIGJ1Zik7CgkJCWlmIChsZW4gPiAwKQoJCQkJcmV0dXJuIHJlaW50ZXJwcmV0KG5hbWUsIG5hbWVsZW4sIGxlbiwgYnVmLAoJCQkJCQkgICBhbGxvd2VkKTsKCQl9CgoJCWxlbiA9IGludGVycHJldF9icmFuY2hfbWFyayhuYW1lLCBuYW1lbGVuLCBhdCAtIG5hbWUsIGJ1ZiwKCQkJCQkgICAgdXBzdHJlYW1fbWFyaywgYnJhbmNoX2dldF91cHN0cmVhbSwKCQkJCQkgICAgYWxsb3dlZCk7CgkJaWYgKGxlbiA+IDApCgkJCXJldHVybiBsZW47CgoJCWxlbiA9IGludGVycHJldF9icmFuY2hfbWFyayhuYW1lLCBuYW1lbGVuLCBhdCAtIG5hbWUsIGJ1ZiwKCQkJCQkgICAgcHVzaF9tYXJrLCBicmFuY2hfZ2V0X3B1c2gsCgkJCQkJICAgIGFsbG93ZWQpOwoJCWlmIChsZW4gPiAwKQoJCQlyZXR1cm4gbGVuOwoJfQoKCXJldHVybiAtMTsKfQoKdm9pZCBzdHJidWZfYnJhbmNobmFtZShzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqbmFtZSwgdW5zaWduZWQgYWxsb3dlZCkKewoJaW50IGxlbiA9IHN0cmxlbihuYW1lKTsKCWludCB1c2VkID0gaW50ZXJwcmV0X2JyYW5jaF9uYW1lKG5hbWUsIGxlbiwgc2IsIGFsbG93ZWQpOwoKCWlmICh1c2VkIDwgMCkKCQl1c2VkID0gMDsKCXN0cmJ1Zl9hZGQoc2IsIG5hbWUgKyB1c2VkLCBsZW4gLSB1c2VkKTsKfQoKaW50IHN0cmJ1Zl9jaGVja19icmFuY2hfcmVmKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpuYW1lKQp7CglpZiAoc3RhcnR1cF9pbmZvLT5oYXZlX3JlcG9zaXRvcnkpCgkJc3RyYnVmX2JyYW5jaG5hbWUoc2IsIG5hbWUsIElOVEVSUFJFVF9CUkFOQ0hfTE9DQUwpOwoJZWxzZQoJCXN0cmJ1Zl9hZGRzdHIoc2IsIG5hbWUpOwoKCS8qCgkgKiBUaGlzIHNwbGljZSBtdXN0IGJlIGRvbmUgZXZlbiBpZiB3ZSBlbmQgdXAgcmVqZWN0aW5nIHRoZQoJICogbmFtZTsgYnVpbHRpbi9icmFuY2guYzo6Y29weV9vcl9yZW5hbWVfYnJhbmNoKCkgc3RpbGwgd2FudHMKCSAqIHRvIHNlZSB3aGF0IHRoZSBuYW1lIGV4cGFuZGVkIHRvIHNvIHRoYXQgImJyYW5jaCAtbSIgY2FuIGJlCgkgKiB1c2VkIGFzIGEgdG9vbCB0byBjb3JyZWN0IGVhcmxpZXIgbWlzdGFrZXMuCgkgKi8KCXN0cmJ1Zl9zcGxpY2Uoc2IsIDAsIDAsICJyZWZzL2hlYWRzLyIsIDExKTsKCglpZiAoKm5hbWUgPT0gJy0nIHx8CgkgICAgIXN0cmNtcChzYi0+YnVmLCAicmVmcy9oZWFkcy9IRUFEIikpCgkJcmV0dXJuIC0xOwoKCXJldHVybiBjaGVja19yZWZuYW1lX2Zvcm1hdChzYi0+YnVmLCAwKTsKfQoKLyoKICogVGhpcyBpcyBsaWtlICJnZXRfb2lkX2Jhc2ljKCkiLCBleGNlcHQgaXQgYWxsb3dzICJvYmplY3QgSUQgZXhwcmVzc2lvbnMiLAogKiBub3RhYmx5ICJ4eXpeIiBmb3IgInBhcmVudCBvZiB4eXoiCiAqLwppbnQgZ2V0X29pZChjb25zdCBjaGFyICpuYW1lLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXN0cnVjdCBvYmplY3RfY29udGV4dCB1bnVzZWQ7CglyZXR1cm4gZ2V0X29pZF93aXRoX2NvbnRleHQobmFtZSwgMCwgb2lkLCAmdW51c2VkKTsKfQoKCi8qCiAqIE1hbnkgY2FsbGVycyBrbm93IHRoYXQgdGhlIHVzZXIgbWVhbnQgdG8gbmFtZSBhIGNvbW1pdC1pc2ggYnkKICogc3ludGFjdGljYWwgcG9zaXRpb25zIHdoZXJlIHRoZSBvYmplY3QgbmFtZSBhcHBlYXJzLiAgQ2FsbGluZyB0aGlzCiAqIGZ1bmN0aW9uIGFsbG93cyB0aGUgbWFjaGluZXJ5IHRvIGRpc2FtYmlndWF0ZSBzaG9ydGVyLXRoYW4tdW5pcXVlCiAqIGFiYnJldmlhdGVkIG9iamVjdCBuYW1lcyBiZXR3ZWVuIGNvbW1pdC1pc2ggYW5kIG90aGVycy4KICoKICogTm90ZSB0aGF0IHRoaXMgZG9lcyBOT1QgZXJyb3Igb3V0IHdoZW4gdGhlIG5hbWVkIG9iamVjdCBpcyBub3QgYQogKiBjb21taXQtaXNoLiBJdCBpcyBtZXJlbHkgdG8gZ2l2ZSBhIGhpbnQgdG8gdGhlIGRpc2FtYmlndWF0aW9uCiAqIG1hY2hpbmVyeS4KICovCmludCBnZXRfb2lkX2NvbW1pdHRpc2goY29uc3QgY2hhciAqbmFtZSwgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglzdHJ1Y3Qgb2JqZWN0X2NvbnRleHQgdW51c2VkOwoJcmV0dXJuIGdldF9vaWRfd2l0aF9jb250ZXh0KG5hbWUsIEdFVF9PSURfQ09NTUlUVElTSCwKCQkJCSAgICBvaWQsICZ1bnVzZWQpOwp9CgppbnQgZ2V0X29pZF90cmVlaXNoKGNvbnN0IGNoYXIgKm5hbWUsIHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJc3RydWN0IG9iamVjdF9jb250ZXh0IHVudXNlZDsKCXJldHVybiBnZXRfb2lkX3dpdGhfY29udGV4dChuYW1lLCBHRVRfT0lEX1RSRUVJU0gsCgkJCQkgICAgb2lkLCAmdW51c2VkKTsKfQoKaW50IGdldF9vaWRfY29tbWl0KGNvbnN0IGNoYXIgKm5hbWUsIHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJc3RydWN0IG9iamVjdF9jb250ZXh0IHVudXNlZDsKCXJldHVybiBnZXRfb2lkX3dpdGhfY29udGV4dChuYW1lLCBHRVRfT0lEX0NPTU1JVCwKCQkJCSAgICBvaWQsICZ1bnVzZWQpOwp9CgppbnQgZ2V0X29pZF90cmVlKGNvbnN0IGNoYXIgKm5hbWUsIHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJc3RydWN0IG9iamVjdF9jb250ZXh0IHVudXNlZDsKCXJldHVybiBnZXRfb2lkX3dpdGhfY29udGV4dChuYW1lLCBHRVRfT0lEX1RSRUUsCgkJCQkgICAgb2lkLCAmdW51c2VkKTsKfQoKaW50IGdldF9vaWRfYmxvYihjb25zdCBjaGFyICpuYW1lLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXN0cnVjdCBvYmplY3RfY29udGV4dCB1bnVzZWQ7CglyZXR1cm4gZ2V0X29pZF93aXRoX2NvbnRleHQobmFtZSwgR0VUX09JRF9CTE9CLAoJCQkJICAgIG9pZCwgJnVudXNlZCk7Cn0KCi8qIE11c3QgYmUgY2FsbGVkIG9ubHkgd2hlbiBvYmplY3RfbmFtZTpmaWxlbmFtZSBkb2Vzbid0IGV4aXN0LiAqLwpzdGF0aWMgdm9pZCBkaWFnbm9zZV9pbnZhbGlkX29pZF9wYXRoKGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJCSAgICAgIGNvbnN0IGNoYXIgKmZpbGVuYW1lLAoJCQkJICAgICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqdHJlZV9vaWQsCgkJCQkgICAgICBjb25zdCBjaGFyICpvYmplY3RfbmFtZSwKCQkJCSAgICAgIGludCBvYmplY3RfbmFtZV9sZW4pCnsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJdW5zaWduZWQgbW9kZTsKCglpZiAoIXByZWZpeCkKCQlwcmVmaXggPSAiIjsKCglpZiAoZmlsZV9leGlzdHMoZmlsZW5hbWUpKQoJCWRpZSgiUGF0aCAnJXMnIGV4aXN0cyBvbiBkaXNrLCBidXQgbm90IGluICclLipzJy4iLAoJCSAgICBmaWxlbmFtZSwgb2JqZWN0X25hbWVfbGVuLCBvYmplY3RfbmFtZSk7CglpZiAoaXNfbWlzc2luZ19maWxlX2Vycm9yKGVycm5vKSkgewoJCWNoYXIgKmZ1bGxuYW1lID0geHN0cmZtdCgiJXMlcyIsIHByZWZpeCwgZmlsZW5hbWUpOwoKCQlpZiAoIWdldF90cmVlX2VudHJ5KHRyZWVfb2lkLCBmdWxsbmFtZSwgJm9pZCwgJm1vZGUpKSB7CgkJCWRpZSgiUGF0aCAnJXMnIGV4aXN0cywgYnV0IG5vdCAnJXMnLlxuIgoJCQkgICAgIkRpZCB5b3UgbWVhbiAnJS4qczolcycgYWthICclLipzOi4vJXMnPyIsCgkJCSAgICBmdWxsbmFtZSwKCQkJICAgIGZpbGVuYW1lLAoJCQkgICAgb2JqZWN0X25hbWVfbGVuLCBvYmplY3RfbmFtZSwKCQkJICAgIGZ1bGxuYW1lLAoJCQkgICAgb2JqZWN0X25hbWVfbGVuLCBvYmplY3RfbmFtZSwKCQkJICAgIGZpbGVuYW1lKTsKCQl9CgkJZGllKCJQYXRoICclcycgZG9lcyBub3QgZXhpc3QgaW4gJyUuKnMnIiwKCQkgICAgZmlsZW5hbWUsIG9iamVjdF9uYW1lX2xlbiwgb2JqZWN0X25hbWUpOwoJfQp9CgovKiBNdXN0IGJlIGNhbGxlZCBvbmx5IHdoZW4gOnN0YWdlOmZpbGVuYW1lIGRvZXNuJ3QgZXhpc3QuICovCnN0YXRpYyB2b2lkIGRpYWdub3NlX2ludmFsaWRfaW5kZXhfcGF0aChpbnQgc3RhZ2UsCgkJCQkJY29uc3QgY2hhciAqcHJlZml4LAoJCQkJCWNvbnN0IGNoYXIgKmZpbGVuYW1lKQp7Cgljb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlOwoJaW50IHBvczsKCXVuc2lnbmVkIG5hbWVsZW4gPSBzdHJsZW4oZmlsZW5hbWUpOwoJc3RydWN0IHN0cmJ1ZiBmdWxsbmFtZSA9IFNUUkJVRl9JTklUOwoKCWlmICghcHJlZml4KQoJCXByZWZpeCA9ICIiOwoKCS8qIFdyb25nIHN0YWdlIG51bWJlcj8gKi8KCXBvcyA9IGNhY2hlX25hbWVfcG9zKGZpbGVuYW1lLCBuYW1lbGVuKTsKCWlmIChwb3MgPCAwKQoJCXBvcyA9IC1wb3MgLSAxOwoJaWYgKHBvcyA8IGFjdGl2ZV9ucikgewoJCWNlID0gYWN0aXZlX2NhY2hlW3Bvc107CgkJaWYgKGNlX25hbWVsZW4oY2UpID09IG5hbWVsZW4gJiYKCQkgICAgIW1lbWNtcChjZS0+bmFtZSwgZmlsZW5hbWUsIG5hbWVsZW4pKQoJCQlkaWUoIlBhdGggJyVzJyBpcyBpbiB0aGUgaW5kZXgsIGJ1dCBub3QgYXQgc3RhZ2UgJWQuXG4iCgkJCSAgICAiRGlkIHlvdSBtZWFuICc6JWQ6JXMnPyIsCgkJCSAgICBmaWxlbmFtZSwgc3RhZ2UsCgkJCSAgICBjZV9zdGFnZShjZSksIGZpbGVuYW1lKTsKCX0KCgkvKiBDb25mdXNpb24gYmV0d2VlbiByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgZmlsZW5hbWVzPyAqLwoJc3RyYnVmX2FkZHN0cigmZnVsbG5hbWUsIHByZWZpeCk7CglzdHJidWZfYWRkc3RyKCZmdWxsbmFtZSwgZmlsZW5hbWUpOwoJcG9zID0gY2FjaGVfbmFtZV9wb3MoZnVsbG5hbWUuYnVmLCBmdWxsbmFtZS5sZW4pOwoJaWYgKHBvcyA8IDApCgkJcG9zID0gLXBvcyAtIDE7CglpZiAocG9zIDwgYWN0aXZlX25yKSB7CgkJY2UgPSBhY3RpdmVfY2FjaGVbcG9zXTsKCQlpZiAoY2VfbmFtZWxlbihjZSkgPT0gZnVsbG5hbWUubGVuICYmCgkJICAgICFtZW1jbXAoY2UtPm5hbWUsIGZ1bGxuYW1lLmJ1ZiwgZnVsbG5hbWUubGVuKSkKCQkJZGllKCJQYXRoICclcycgaXMgaW4gdGhlIGluZGV4LCBidXQgbm90ICclcycuXG4iCgkJCSAgICAiRGlkIHlvdSBtZWFuICc6JWQ6JXMnIGFrYSAnOiVkOi4vJXMnPyIsCgkJCSAgICBmdWxsbmFtZS5idWYsIGZpbGVuYW1lLAoJCQkgICAgY2Vfc3RhZ2UoY2UpLCBmdWxsbmFtZS5idWYsCgkJCSAgICBjZV9zdGFnZShjZSksIGZpbGVuYW1lKTsKCX0KCglpZiAoZmlsZV9leGlzdHMoZmlsZW5hbWUpKQoJCWRpZSgiUGF0aCAnJXMnIGV4aXN0cyBvbiBkaXNrLCBidXQgbm90IGluIHRoZSBpbmRleC4iLCBmaWxlbmFtZSk7CglpZiAoaXNfbWlzc2luZ19maWxlX2Vycm9yKGVycm5vKSkKCQlkaWUoIlBhdGggJyVzJyBkb2VzIG5vdCBleGlzdCAobmVpdGhlciBvbiBkaXNrIG5vciBpbiB0aGUgaW5kZXgpLiIsCgkJICAgIGZpbGVuYW1lKTsKCglzdHJidWZfcmVsZWFzZSgmZnVsbG5hbWUpOwp9CgoKc3RhdGljIGNoYXIgKnJlc29sdmVfcmVsYXRpdmVfcGF0aChjb25zdCBjaGFyICpyZWwpCnsKCWlmICghc3RhcnRzX3dpdGgocmVsLCAiLi8iKSAmJiAhc3RhcnRzX3dpdGgocmVsLCAiLi4vIikpCgkJcmV0dXJuIE5VTEw7CgoJaWYgKCFpc19pbnNpZGVfd29ya190cmVlKCkpCgkJZGllKCJyZWxhdGl2ZSBwYXRoIHN5bnRheCBjYW4ndCBiZSB1c2VkIG91dHNpZGUgd29ya2luZyB0cmVlLiIpOwoKCS8qIGRpZSgpIGluc2lkZSBwcmVmaXhfcGF0aCgpIGlmIHJlc29sdmVkIHBhdGggaXMgb3V0c2lkZSB3b3JrdHJlZSAqLwoJcmV0dXJuIHByZWZpeF9wYXRoKHN0YXJ0dXBfaW5mby0+cHJlZml4LAoJCQkgICBzdGFydHVwX2luZm8tPnByZWZpeCA/IHN0cmxlbihzdGFydHVwX2luZm8tPnByZWZpeCkgOiAwLAoJCQkgICByZWwpOwp9CgpzdGF0aWMgaW50IGdldF9vaWRfd2l0aF9jb250ZXh0XzEoY29uc3QgY2hhciAqbmFtZSwKCQkJCSAgdW5zaWduZWQgZmxhZ3MsCgkJCQkgIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJCSAgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkJICBzdHJ1Y3Qgb2JqZWN0X2NvbnRleHQgKm9jKQp7CglpbnQgcmV0LCBicmFja2V0X2RlcHRoOwoJaW50IG5hbWVsZW4gPSBzdHJsZW4obmFtZSk7Cgljb25zdCBjaGFyICpjcDsKCWludCBvbmx5X3RvX2RpZSA9IGZsYWdzICYgR0VUX09JRF9PTkxZX1RPX0RJRTsKCglpZiAob25seV90b19kaWUpCgkJZmxhZ3MgfD0gR0VUX09JRF9RVUlFVExZOwoKCW1lbXNldChvYywgMCwgc2l6ZW9mKCpvYykpOwoJb2MtPm1vZGUgPSBTX0lGSU5WQUxJRDsKCXN0cmJ1Zl9pbml0KCZvYy0+c3ltbGlua19wYXRoLCAwKTsKCXJldCA9IGdldF9vaWRfMShuYW1lLCBuYW1lbGVuLCBvaWQsIGZsYWdzKTsKCWlmICghcmV0KQoJCXJldHVybiByZXQ7CgkvKgoJICogc2hhMTpwYXRoIC0tPiBvYmplY3QgbmFtZSBvZiBwYXRoIGluIGVudCBzaGExCgkgKiA6cGF0aCAtPiBvYmplY3QgbmFtZSBvZiBhYnNvbHV0ZSBwYXRoIGluIGluZGV4CgkgKiA6Li9wYXRoIC0+IG9iamVjdCBuYW1lIG9mIHBhdGggcmVsYXRpdmUgdG8gY3dkIGluIGluZGV4CgkgKiA6WzAtM106cGF0aCAtPiBvYmplY3QgbmFtZSBvZiBwYXRoIGluIGluZGV4IGF0IHN0YWdlCgkgKiA6L2ZvbyAtPiByZWNlbnQgY29tbWl0IG1hdGNoaW5nIGZvbwoJICovCglpZiAobmFtZVswXSA9PSAnOicpIHsKCQlpbnQgc3RhZ2UgPSAwOwoJCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2U7CgkJY2hhciAqbmV3X3BhdGggPSBOVUxMOwoJCWludCBwb3M7CgkJaWYgKCFvbmx5X3RvX2RpZSAmJiBuYW1lbGVuID4gMiAmJiBuYW1lWzFdID09ICcvJykgewoJCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QgPSBOVUxMOwoKCQkJZm9yX2VhY2hfcmVmKGhhbmRsZV9vbmVfcmVmLCAmbGlzdCk7CgkJCWNvbW1pdF9saXN0X3NvcnRfYnlfZGF0ZSgmbGlzdCk7CgkJCXJldHVybiBnZXRfb2lkX29uZWxpbmUobmFtZSArIDIsIG9pZCwgbGlzdCk7CgkJfQoJCWlmIChuYW1lbGVuIDwgMyB8fAoJCSAgICBuYW1lWzJdICE9ICc6JyB8fAoJCSAgICBuYW1lWzFdIDwgJzAnIHx8ICczJyA8IG5hbWVbMV0pCgkJCWNwID0gbmFtZSArIDE7CgkJZWxzZSB7CgkJCXN0YWdlID0gbmFtZVsxXSAtICcwJzsKCQkJY3AgPSBuYW1lICsgMzsKCQl9CgkJbmV3X3BhdGggPSByZXNvbHZlX3JlbGF0aXZlX3BhdGgoY3ApOwoJCWlmICghbmV3X3BhdGgpIHsKCQkJbmFtZWxlbiA9IG5hbWVsZW4gLSAoY3AgLSBuYW1lKTsKCQl9IGVsc2UgewoJCQljcCA9IG5ld19wYXRoOwoJCQluYW1lbGVuID0gc3RybGVuKGNwKTsKCQl9CgoJCWlmIChmbGFncyAmIEdFVF9PSURfUkVDT1JEX1BBVEgpCgkJCW9jLT5wYXRoID0geHN0cmR1cChjcCk7CgoJCWlmICghYWN0aXZlX2NhY2hlKQoJCQlyZWFkX2NhY2hlKCk7CgkJcG9zID0gY2FjaGVfbmFtZV9wb3MoY3AsIG5hbWVsZW4pOwoJCWlmIChwb3MgPCAwKQoJCQlwb3MgPSAtcG9zIC0gMTsKCQl3aGlsZSAocG9zIDwgYWN0aXZlX25yKSB7CgkJCWNlID0gYWN0aXZlX2NhY2hlW3Bvc107CgkJCWlmIChjZV9uYW1lbGVuKGNlKSAhPSBuYW1lbGVuIHx8CgkJCSAgICBtZW1jbXAoY2UtPm5hbWUsIGNwLCBuYW1lbGVuKSkKCQkJCWJyZWFrOwoJCQlpZiAoY2Vfc3RhZ2UoY2UpID09IHN0YWdlKSB7CgkJCQlvaWRjcHkob2lkLCAmY2UtPm9pZCk7CgkJCQlvYy0+bW9kZSA9IGNlLT5jZV9tb2RlOwoJCQkJZnJlZShuZXdfcGF0aCk7CgkJCQlyZXR1cm4gMDsKCQkJfQoJCQlwb3MrKzsKCQl9CgkJaWYgKG9ubHlfdG9fZGllICYmIG5hbWVbMV0gJiYgbmFtZVsxXSAhPSAnLycpCgkJCWRpYWdub3NlX2ludmFsaWRfaW5kZXhfcGF0aChzdGFnZSwgcHJlZml4LCBjcCk7CgkJZnJlZShuZXdfcGF0aCk7CgkJcmV0dXJuIC0xOwoJfQoJZm9yIChjcCA9IG5hbWUsIGJyYWNrZXRfZGVwdGggPSAwOyAqY3A7IGNwKyspIHsKCQlpZiAoKmNwID09ICd7JykKCQkJYnJhY2tldF9kZXB0aCsrOwoJCWVsc2UgaWYgKGJyYWNrZXRfZGVwdGggJiYgKmNwID09ICd9JykKCQkJYnJhY2tldF9kZXB0aC0tOwoJCWVsc2UgaWYgKCFicmFja2V0X2RlcHRoICYmICpjcCA9PSAnOicpCgkJCWJyZWFrOwoJfQoJaWYgKCpjcCA9PSAnOicpIHsKCQlzdHJ1Y3Qgb2JqZWN0X2lkIHRyZWVfb2lkOwoJCWludCBsZW4gPSBjcCAtIG5hbWU7CgkJdW5zaWduZWQgc3ViX2ZsYWdzID0gZmxhZ3M7CgoJCXN1Yl9mbGFncyAmPSB+R0VUX09JRF9ESVNBTUJJR1VBVE9SUzsKCQlzdWJfZmxhZ3MgfD0gR0VUX09JRF9UUkVFSVNIOwoKCQlpZiAoIWdldF9vaWRfMShuYW1lLCBsZW4sICZ0cmVlX29pZCwgc3ViX2ZsYWdzKSkgewoJCQljb25zdCBjaGFyICpmaWxlbmFtZSA9IGNwKzE7CgkJCWNoYXIgKm5ld19maWxlbmFtZSA9IE5VTEw7CgoJCQluZXdfZmlsZW5hbWUgPSByZXNvbHZlX3JlbGF0aXZlX3BhdGgoZmlsZW5hbWUpOwoJCQlpZiAobmV3X2ZpbGVuYW1lKQoJCQkJZmlsZW5hbWUgPSBuZXdfZmlsZW5hbWU7CgkJCWlmIChmbGFncyAmIEdFVF9PSURfRk9MTE9XX1NZTUxJTktTKSB7CgkJCQlyZXQgPSBnZXRfdHJlZV9lbnRyeV9mb2xsb3dfc3ltbGlua3MoJnRyZWVfb2lkLAoJCQkJCWZpbGVuYW1lLCBvaWQsICZvYy0+c3ltbGlua19wYXRoLAoJCQkJCSZvYy0+bW9kZSk7CgkJCX0gZWxzZSB7CgkJCQlyZXQgPSBnZXRfdHJlZV9lbnRyeSgmdHJlZV9vaWQsIGZpbGVuYW1lLCBvaWQsCgkJCQkJCSAgICAgJm9jLT5tb2RlKTsKCQkJCWlmIChyZXQgJiYgb25seV90b19kaWUpIHsKCQkJCQlkaWFnbm9zZV9pbnZhbGlkX29pZF9wYXRoKHByZWZpeCwKCQkJCQkJCQkgICBmaWxlbmFtZSwKCQkJCQkJCQkgICAmdHJlZV9vaWQsCgkJCQkJCQkJICAgbmFtZSwgbGVuKTsKCQkJCX0KCQkJfQoJCQlpZiAoZmxhZ3MgJiBHRVRfT0lEX1JFQ09SRF9QQVRIKQoJCQkJb2MtPnBhdGggPSB4c3RyZHVwKGZpbGVuYW1lKTsKCgkJCWZyZWUobmV3X2ZpbGVuYW1lKTsKCQkJcmV0dXJuIHJldDsKCQl9IGVsc2UgewoJCQlpZiAob25seV90b19kaWUpCgkJCQlkaWUoIkludmFsaWQgb2JqZWN0IG5hbWUgJyUuKnMnLiIsIGxlbiwgbmFtZSk7CgkJfQoJfQoJcmV0dXJuIHJldDsKfQoKLyoKICogQ2FsbCB0aGlzIGZ1bmN0aW9uIHdoZW4geW91IGtub3cgIm5hbWUiIGdpdmVuIGJ5IHRoZSBlbmQgdXNlciBtdXN0CiAqIG5hbWUgYW4gb2JqZWN0IGJ1dCBpdCBkb2Vzbid0OyB0aGUgZnVuY3Rpb24gX21heV8gZGllIHdpdGggYSBiZXR0ZXIKICogZGlhZ25vc3RpYyBtZXNzYWdlIHRoYW4gIm5vIHN1Y2ggb2JqZWN0ICduYW1lJyIsIGUuZy4gIlBhdGggJ2RvYycgZG9lcyBub3QKICogZXhpc3QgaW4gJ0hFQUQnIiB3aGVuIGdpdmVuICJIRUFEOmRvYyIsIG9yIGl0IG1heSByZXR1cm4gaW4gd2hpY2ggY2FzZQogKiB5b3UgaGF2ZSBhIGNoYW5jZSB0byBkaWFnbm9zZSB0aGUgZXJyb3IgZnVydGhlci4KICovCnZvaWQgbWF5YmVfZGllX29uX21pc3NwZWx0X29iamVjdF9uYW1lKGNvbnN0IGNoYXIgKm5hbWUsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IG9iamVjdF9jb250ZXh0IG9jOwoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CglnZXRfb2lkX3dpdGhfY29udGV4dF8xKG5hbWUsIEdFVF9PSURfT05MWV9UT19ESUUsIHByZWZpeCwgJm9pZCwgJm9jKTsKfQoKaW50IGdldF9vaWRfd2l0aF9jb250ZXh0KGNvbnN0IGNoYXIgKnN0ciwgdW5zaWduZWQgZmxhZ3MsIHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgc3RydWN0IG9iamVjdF9jb250ZXh0ICpvYykKewoJaWYgKGZsYWdzICYgR0VUX09JRF9GT0xMT1dfU1lNTElOS1MgJiYgZmxhZ3MgJiBHRVRfT0lEX09OTFlfVE9fRElFKQoJCUJVRygiaW5jb21wYXRpYmxlIGZsYWdzIGZvciBnZXRfc2hhMV93aXRoX2NvbnRleHQiKTsKCXJldHVybiBnZXRfb2lkX3dpdGhfY29udGV4dF8xKHN0ciwgZmxhZ3MsIE5VTEwsIG9pZCwgb2MpOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"tree.h\"\n#include \"blob.h\"\n#include \"tree-walk.h\"\n#include \"refs.h\"\n#include \"remote.h\"\n#include \"dir.h\"\n#include \"sha1-array.h\"\n#include \"packfile.h\"\n#include \"object-store.h\"\n#include \"repository.h\"\n\nstatic int get_oid_oneline(const char *, struct object_id *, struct commit_list *);\n\ntypedef int (*disambiguate_hint_fn)(const struct object_id *, void *);\n\nstruct disambiguate_state {\n\tint len; /* length of prefix in hex chars */\n\tchar hex_pfx[GIT_MAX_HEXSZ + 1];\n\tstruct object_id bin_pfx;\n\n\tdisambiguate_hint_fn fn;\n\tvoid *cb_data;\n\tstruct object_id candidate;\n\tunsigned candidate_exists:1;\n\tunsigned candidate_checked:1;\n\tunsigned candidate_ok:1;\n\tunsigned disambiguate_fn_used:1;\n\tunsigned ambiguous:1;\n\tunsigned always_call_fn:1;\n};\n\nstatic void update_candidates(struct disambiguate_state *ds, const struct object_id *current)\n{\n\tif (ds->always_call_fn) {\n\t\tds->ambiguous = ds->fn(current, ds->cb_data) ? 1 : 0;\n\t\treturn;\n\t}\n\tif (!ds->candidate_exists) {\n\t\t/* this is the first candidate */\n\t\toidcpy(&ds->candidate, current);\n\t\tds->candidate_exists = 1;\n\t\treturn;\n\t} else if (!oidcmp(&ds->candidate, current)) {\n\t\t/* the same as what we already have seen */\n\t\treturn;\n\t}\n\n\tif (!ds->fn) {\n\t\t/* cannot disambiguate between ds->candidate and current */\n\t\tds->ambiguous = 1;\n\t\treturn;\n\t}\n\n\tif (!ds->candidate_checked) {\n\t\tds->candidate_ok = ds->fn(&ds->candidate, ds->cb_data);\n\t\tds->disambiguate_fn_used = 1;\n\t\tds->candidate_checked = 1;\n\t}\n\n\tif (!ds->candidate_ok) {\n\t\t/* discard the candidate; we know it does not satisfy fn */\n\t\toidcpy(&ds->candidate, current);\n\t\tds->candidate_checked = 0;\n\t\treturn;\n\t}\n\n\t/* if we reach this point, we know ds->candidate satisfies fn */\n\tif (ds->fn(current, ds->cb_data)) {\n\t\t/*\n\t\t * if both current and candidate satisfy fn, we cannot\n\t\t * disambiguate.\n\t\t */\n\t\tds->candidate_ok = 0;\n\t\tds->ambiguous = 1;\n\t}\n\n\t/* otherwise, current can be discarded and candidate is still good */\n}\n\nstatic int append_loose_object(const struct object_id *oid, const char *path,\n\t\t\t       void *data)\n{\n\toid_array_append(data, oid);\n\treturn 0;\n}\n\nstatic int match_sha(unsigned, const unsigned char *, const unsigned char *);\n\nstatic void find_short_object_filename(struct disambiguate_state *ds)\n{\n\tint subdir_nr = ds->bin_pfx.hash[0];\n\tstruct alternate_object_database *alt;\n\tstatic struct alternate_object_database *fakeent;\n\n\tif (!fakeent) {\n\t\t/*\n\t\t * Create a \"fake\" alternate object database that\n\t\t * points to our own object database, to make it\n\t\t * easier to get a temporary working space in\n\t\t * alt->name/alt->base while iterating over the\n\t\t * object databases including our own.\n\t\t */\n\t\tfakeent = alloc_alt_odb(get_object_directory());\n\t}\n\tfakeent->next = the_repository->objects->alt_odb_list;\n\n\tfor (alt = fakeent; alt && !ds->ambiguous; alt = alt->next) {\n\t\tint pos;\n\n\t\tif (!alt->loose_objects_subdir_seen[subdir_nr]) {\n\t\t\tstruct strbuf *buf = alt_scratch_buf(alt);\n\t\t\tfor_each_file_in_obj_subdir(subdir_nr, buf,\n\t\t\t\t\t\t    append_loose_object,\n\t\t\t\t\t\t    NULL, NULL,\n\t\t\t\t\t\t    &alt->loose_objects_cache);\n\t\t\talt->loose_objects_subdir_seen[subdir_nr] = 1;\n\t\t}\n\n\t\tpos = oid_array_lookup(&alt->loose_objects_cache, &ds->bin_pfx);\n\t\tif (pos < 0)\n\t\t\tpos = -1 - pos;\n\t\twhile (!ds->ambiguous && pos < alt->loose_objects_cache.nr) {\n\t\t\tconst struct object_id *oid;\n\t\t\toid = alt->loose_objects_cache.oid + pos;\n\t\t\tif (!match_sha(ds->len, ds->bin_pfx.hash, oid->hash))\n\t\t\t\tbreak;\n\t\t\tupdate_candidates(ds, oid);\n\t\t\tpos++;\n\t\t}\n\t}\n}\n\nstatic int match_sha(unsigned len, const unsigned char *a, const unsigned char *b)\n{\n\tdo {\n\t\tif (*a != *b)\n\t\t\treturn 0;\n\t\ta++;\n\t\tb++;\n\t\tlen -= 2;\n\t} while (len > 1);\n\tif (len)\n\t\tif ((*a ^ *b) & 0xf0)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic void unique_in_pack(struct packed_git *p,\n\t\t\t   struct disambiguate_state *ds)\n{\n\tuint32_t num, i, first = 0;\n\tconst struct object_id *current = NULL;\n\n\tif (open_pack_index(p) || !p->num_objects)\n\t\treturn;\n\n\tnum = p->num_objects;\n\tbsearch_pack(&ds->bin_pfx, p, &first);\n\n\t/*\n\t * At this point, \"first\" is the location of the lowest object\n\t * with an object name that could match \"bin_pfx\".  See if we have\n\t * 0, 1 or more objects that actually match(es).\n\t */\n\tfor (i = first; i < num && !ds->ambiguous; i++) {\n\t\tstruct object_id oid;\n\t\tcurrent = nth_packed_object_oid(&oid, p, i);\n\t\tif (!match_sha(ds->len, ds->bin_pfx.hash, current->hash))\n\t\t\tbreak;\n\t\tupdate_candidates(ds, current);\n\t}\n}\n\nstatic void find_short_packed_object(struct disambiguate_state *ds)\n{\n\tstruct packed_git *p;\n\n\tfor (p = get_packed_git(the_repository); p && !ds->ambiguous;\n\t     p = p->next)\n\t\tunique_in_pack(p, ds);\n}\n\n#define SHORT_NAME_NOT_FOUND (-1)\n#define SHORT_NAME_AMBIGUOUS (-2)\n\nstatic int finish_object_disambiguation(struct disambiguate_state *ds,\n\t\t\t\t\tstruct object_id *oid)\n{\n\tif (ds->ambiguous)\n\t\treturn SHORT_NAME_AMBIGUOUS;\n\n\tif (!ds->candidate_exists)\n\t\treturn SHORT_NAME_NOT_FOUND;\n\n\tif (!ds->candidate_checked)\n\t\t/*\n\t\t * If this is the only candidate, there is no point\n\t\t * calling the disambiguation hint callback.\n\t\t *\n\t\t * On the other hand, if the current candidate\n\t\t * replaced an earlier candidate that did _not_ pass\n\t\t * the disambiguation hint callback, then we do have\n\t\t * more than one objects that match the short name\n\t\t * given, so we should make sure this one matches;\n\t\t * otherwise, if we discovered this one and the one\n\t\t * that we previously discarded in the reverse order,\n\t\t * we would end up showing different results in the\n\t\t * same repository!\n\t\t */\n\t\tds->candidate_ok = (!ds->disambiguate_fn_used ||\n\t\t\t\t    ds->fn(&ds->candidate, ds->cb_data));\n\n\tif (!ds->candidate_ok)\n\t\treturn SHORT_NAME_AMBIGUOUS;\n\n\toidcpy(oid, &ds->candidate);\n\treturn 0;\n}\n\nstatic int disambiguate_commit_only(const struct object_id *oid, void *cb_data_unused)\n{\n\tint kind = oid_object_info(the_repository, oid, NULL);\n\treturn kind == OBJ_COMMIT;\n}\n\nstatic int disambiguate_committish_only(const struct object_id *oid, void *cb_data_unused)\n{\n\tstruct object *obj;\n\tint kind;\n\n\tkind = oid_object_info(the_repository, oid, NULL);\n\tif (kind == OBJ_COMMIT)\n\t\treturn 1;\n\tif (kind != OBJ_TAG)\n\t\treturn 0;\n\n\t/* We need to do this the hard way... */\n\tobj = deref_tag(the_repository, parse_object(the_repository, oid),\n\t\t\tNULL, 0);\n\tif (obj && obj->type == OBJ_COMMIT)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int disambiguate_tree_only(const struct object_id *oid, void *cb_data_unused)\n{\n\tint kind = oid_object_info(the_repository, oid, NULL);\n\treturn kind == OBJ_TREE;\n}\n\nstatic int disambiguate_treeish_only(const struct object_id *oid, void *cb_data_unused)\n{\n\tstruct object *obj;\n\tint kind;\n\n\tkind = oid_object_info(the_repository, oid, NULL);\n\tif (kind == OBJ_TREE || kind == OBJ_COMMIT)\n\t\treturn 1;\n\tif (kind != OBJ_TAG)\n\t\treturn 0;\n\n\t/* We need to do this the hard way... */\n\tobj = deref_tag(the_repository, parse_object(the_repository, oid),\n\t\t\tNULL, 0);\n\tif (obj && (obj->type == OBJ_TREE || obj->type == OBJ_COMMIT))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int disambiguate_blob_only(const struct object_id *oid, void *cb_data_unused)\n{\n\tint kind = oid_object_info(the_repository, oid, NULL);\n\treturn kind == OBJ_BLOB;\n}\n\nstatic disambiguate_hint_fn default_disambiguate_hint;\n\nint set_disambiguate_hint_config(const char *var, const char *value)\n{\n\tstatic const struct {\n\t\tconst char *name;\n\t\tdisambiguate_hint_fn fn;\n\t} hints[] = {\n\t\t{ \"none\", NULL },\n\t\t{ \"commit\", disambiguate_commit_only },\n\t\t{ \"committish\", disambiguate_committish_only },\n\t\t{ \"tree\", disambiguate_tree_only },\n\t\t{ \"treeish\", disambiguate_treeish_only },\n\t\t{ \"blob\", disambiguate_blob_only }\n\t};\n\tint i;\n\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\n\tfor (i = 0; i < ARRAY_SIZE(hints); i++) {\n\t\tif (!strcasecmp(value, hints[i].name)) {\n\t\t\tdefault_disambiguate_hint = hints[i].fn;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn error(\"unknown hint type for '%s': %s\", var, value);\n}\n\nstatic int init_object_disambiguation(const char *name, int len,\n\t\t\t\t      struct disambiguate_state *ds)\n{\n\tint i;\n\n\tif (len < MINIMUM_ABBREV || len > GIT_SHA1_HEXSZ)\n\t\treturn -1;\n\n\tmemset(ds, 0, sizeof(*ds));\n\n\tfor (i = 0; i < len ;i++) {\n\t\tunsigned char c = name[i];\n\t\tunsigned char val;\n\t\tif (c >= '0' && c <= '9')\n\t\t\tval = c - '0';\n\t\telse if (c >= 'a' && c <= 'f')\n\t\t\tval = c - 'a' + 10;\n\t\telse if (c >= 'A' && c <='F') {\n\t\t\tval = c - 'A' + 10;\n\t\t\tc -= 'A' - 'a';\n\t\t}\n\t\telse\n\t\t\treturn -1;\n\t\tds->hex_pfx[i] = c;\n\t\tif (!(i & 1))\n\t\t\tval <<= 4;\n\t\tds->bin_pfx.hash[i >> 1] |= val;\n\t}\n\n\tds->len = len;\n\tds->hex_pfx[len] = '\\0';\n\tprepare_alt_odb(the_repository);\n\treturn 0;\n}\n\nstatic int show_ambiguous_object(const struct object_id *oid, void *data)\n{\n\tconst struct disambiguate_state *ds = data;\n\tstruct strbuf desc = STRBUF_INIT;\n\tint type;\n\n\tif (ds->fn && !ds->fn(oid, ds->cb_data))\n\t\treturn 0;\n\n\ttype = oid_object_info(the_repository, oid, NULL);\n\tif (type == OBJ_COMMIT) {\n\t\tstruct commit *commit = lookup_commit(the_repository, oid);\n\t\tif (commit) {\n\t\t\tstruct pretty_print_context pp = {0};\n\t\t\tpp.date_mode.type = DATE_SHORT;\n\t\t\tformat_commit_message(commit, \" %ad - %s\", &desc, &pp);\n\t\t}\n\t} else if (type == OBJ_TAG) {\n\t\tstruct tag *tag = lookup_tag(the_repository, oid);\n\t\tif (!parse_tag(tag) && tag->tag)\n\t\t\tstrbuf_addf(&desc, \" %s\", tag->tag);\n\t}\n\n\tadvise(\"  %s %s%s\",\n\t       find_unique_abbrev(oid, DEFAULT_ABBREV),\n\t       type_name(type) ? type_name(type) : \"unknown type\",\n\t       desc.buf);\n\n\tstrbuf_release(&desc);\n\treturn 0;\n}\n\nstatic int collect_ambiguous(const struct object_id *oid, void *data)\n{\n\toid_array_append(data, oid);\n\treturn 0;\n}\n\nstatic int sort_ambiguous(const void *a, const void *b)\n{\n\tint a_type = oid_object_info(the_repository, a, NULL);\n\tint b_type = oid_object_info(the_repository, b, NULL);\n\tint a_type_sort;\n\tint b_type_sort;\n\n\t/*\n\t * Sorts by hash within the same object type, just as\n\t * oid_array_for_each_unique() would do.\n\t */\n\tif (a_type == b_type)\n\t\treturn oidcmp(a, b);\n\n\t/*\n\t * Between object types show tags, then commits, and finally\n\t * trees and blobs.\n\t *\n\t * The object_type enum is commit, tree, blob, tag, but we\n\t * want tag, commit, tree blob. Cleverly (perhaps too\n\t * cleverly) do that with modulus, since the enum assigns 1 to\n\t * commit, so tag becomes 0.\n\t */\n\ta_type_sort = a_type % 4;\n\tb_type_sort = b_type % 4;\n\treturn a_type_sort > b_type_sort ? 1 : -1;\n}\n\nstatic int get_short_oid(const char *name, int len, struct object_id *oid,\n\t\t\t  unsigned flags)\n{\n\tint status;\n\tstruct disambiguate_state ds;\n\tint quietly = !!(flags & GET_OID_QUIETLY);\n\n\tif (init_object_disambiguation(name, len, &ds) < 0)\n\t\treturn -1;\n\n\tif (HAS_MULTI_BITS(flags & GET_OID_DISAMBIGUATORS))\n\t\tBUG(\"multiple get_short_oid disambiguator flags\");\n\n\tif (flags & GET_OID_COMMIT)\n\t\tds.fn = disambiguate_commit_only;\n\telse if (flags & GET_OID_COMMITTISH)\n\t\tds.fn = disambiguate_committish_only;\n\telse if (flags & GET_OID_TREE)\n\t\tds.fn = disambiguate_tree_only;\n\telse if (flags & GET_OID_TREEISH)\n\t\tds.fn = disambiguate_treeish_only;\n\telse if (flags & GET_OID_BLOB)\n\t\tds.fn = disambiguate_blob_only;\n\telse\n\t\tds.fn = default_disambiguate_hint;\n\n\tfind_short_object_filename(&ds);\n\tfind_short_packed_object(&ds);\n\tstatus = finish_object_disambiguation(&ds, oid);\n\n\tif (!quietly && (status == SHORT_NAME_AMBIGUOUS)) {\n\t\tstruct oid_array collect = OID_ARRAY_INIT;\n\n\t\terror(_(\"short SHA1 %s is ambiguous\"), ds.hex_pfx);\n\n\t\t/*\n\t\t * We may still have ambiguity if we simply saw a series of\n\t\t * candidates that did not satisfy our hint function. In\n\t\t * that case, we still want to show them, so disable the hint\n\t\t * function entirely.\n\t\t */\n\t\tif (!ds.ambiguous)\n\t\t\tds.fn = NULL;\n\n\t\tadvise(_(\"The candidates are:\"));\n\t\tfor_each_abbrev(ds.hex_pfx, collect_ambiguous, &collect);\n\t\tQSORT(collect.oid, collect.nr, sort_ambiguous);\n\n\t\tif (oid_array_for_each(&collect, show_ambiguous_object, &ds))\n\t\t\tBUG(\"show_ambiguous_object shouldn't return non-zero\");\n\t\toid_array_clear(&collect);\n\t}\n\n\treturn status;\n}\n\nint for_each_abbrev(const char *prefix, each_abbrev_fn fn, void *cb_data)\n{\n\tstruct oid_array collect = OID_ARRAY_INIT;\n\tstruct disambiguate_state ds;\n\tint ret;\n\n\tif (init_object_disambiguation(prefix, strlen(prefix), &ds) < 0)\n\t\treturn -1;\n\n\tds.always_call_fn = 1;\n\tds.fn = collect_ambiguous;\n\tds.cb_data = &collect;\n\tfind_short_object_filename(&ds);\n\tfind_short_packed_object(&ds);\n\n\tret = oid_array_for_each_unique(&collect, fn, cb_data);\n\toid_array_clear(&collect);\n\treturn ret;\n}\n\n/*\n * Return the slot of the most-significant bit set in \"val\". There are various\n * ways to do this quickly with fls() or __builtin_clzl(), but speed is\n * probably not a big deal here.\n */\nstatic unsigned msb(unsigned long val)\n{\n\tunsigned r = 0;\n\twhile (val >>= 1)\n\t\tr++;\n\treturn r;\n}\n\nstruct min_abbrev_data {\n\tunsigned int init_len;\n\tunsigned int cur_len;\n\tchar *hex;\n\tconst struct object_id *oid;\n};\n\nstatic inline char get_hex_char_from_oid(const struct object_id *oid,\n\t\t\t\t\t unsigned int pos)\n{\n\tstatic const char hex[] = \"0123456789abcdef\";\n\n\tif ((pos & 1) == 0)\n\t\treturn hex[oid->hash[pos >> 1] >> 4];\n\telse\n\t\treturn hex[oid->hash[pos >> 1] & 0xf];\n}\n\nstatic int extend_abbrev_len(const struct object_id *oid, void *cb_data)\n{\n\tstruct min_abbrev_data *mad = cb_data;\n\n\tunsigned int i = mad->init_len;\n\twhile (mad->hex[i] && mad->hex[i] == get_hex_char_from_oid(oid, i))\n\t\ti++;\n\n\tif (i < GIT_MAX_RAWSZ && i >= mad->cur_len)\n\t\tmad->cur_len = i + 1;\n\n\treturn 0;\n}\n\nstatic void find_abbrev_len_for_pack(struct packed_git *p,\n\t\t\t\t     struct min_abbrev_data *mad)\n{\n\tint match = 0;\n\tuint32_t num, first = 0;\n\tstruct object_id oid;\n\tconst struct object_id *mad_oid;\n\n\tif (open_pack_index(p) || !p->num_objects)\n\t\treturn;\n\n\tnum = p->num_objects;\n\tmad_oid = mad->oid;\n\tmatch = bsearch_pack(mad_oid, p, &first);\n\n\t/*\n\t * first is now the position in the packfile where we would insert\n\t * mad->hash if it does not exist (or the position of mad->hash if\n\t * it does exist). Hence, we consider a maximum of two objects\n\t * nearby for the abbreviation length.\n\t */\n\tmad->init_len = 0;\n\tif (!match) {\n\t\tif (nth_packed_object_oid(&oid, p, first))\n\t\t\textend_abbrev_len(&oid, mad);\n\t} else if (first < num - 1) {\n\t\tif (nth_packed_object_oid(&oid, p, first + 1))\n\t\t\textend_abbrev_len(&oid, mad);\n\t}\n\tif (first > 0) {\n\t\tif (nth_packed_object_oid(&oid, p, first - 1))\n\t\t\textend_abbrev_len(&oid, mad);\n\t}\n\tmad->init_len = mad->cur_len;\n}\n\nstatic void find_abbrev_len_packed(struct min_abbrev_data *mad)\n{\n\tstruct packed_git *p;\n\n\tfor (p = get_packed_git(the_repository); p; p = p->next)\n\t\tfind_abbrev_len_for_pack(p, mad);\n}\n\nint find_unique_abbrev_r(char *hex, const struct object_id *oid, int len)\n{\n\tstruct disambiguate_state ds;\n\tstruct min_abbrev_data mad;\n\tstruct object_id oid_ret;\n\tif (len < 0) {\n\t\tunsigned long count = approximate_object_count();\n\t\t/*\n\t\t * Add one because the MSB only tells us the highest bit set,\n\t\t * not including the value of all the _other_ bits (so \"15\"\n\t\t * is only one off of 2^4, but the MSB is the 3rd bit.\n\t\t */\n\t\tlen = msb(count) + 1;\n\t\t/*\n\t\t * We now know we have on the order of 2^len objects, which\n\t\t * expects a collision at 2^(len/2). But we also care about hex\n\t\t * chars, not bits, and there are 4 bits per hex. So all\n\t\t * together we need to divide by 2 and round up.\n\t\t */\n\t\tlen = DIV_ROUND_UP(len, 2);\n\t\t/*\n\t\t * For very small repos, we stick with our regular fallback.\n\t\t */\n\t\tif (len < FALLBACK_DEFAULT_ABBREV)\n\t\t\tlen = FALLBACK_DEFAULT_ABBREV;\n\t}\n\n\toid_to_hex_r(hex, oid);\n\tif (len == GIT_SHA1_HEXSZ || !len)\n\t\treturn GIT_SHA1_HEXSZ;\n\n\tmad.init_len = len;\n\tmad.cur_len = len;\n\tmad.hex = hex;\n\tmad.oid = oid;\n\n\tfind_abbrev_len_packed(&mad);\n\n\tif (init_object_disambiguation(hex, mad.cur_len, &ds) < 0)\n\t\treturn -1;\n\n\tds.fn = extend_abbrev_len;\n\tds.always_call_fn = 1;\n\tds.cb_data = (void *)&mad;\n\n\tfind_short_object_filename(&ds);\n\t(void)finish_object_disambiguation(&ds, &oid_ret);\n\n\thex[mad.cur_len] = 0;\n\treturn mad.cur_len;\n}\n\nconst char *find_unique_abbrev(const struct object_id *oid, int len)\n{\n\tstatic int bufno;\n\tstatic char hexbuffer[4][GIT_MAX_HEXSZ + 1];\n\tchar *hex = hexbuffer[bufno];\n\tbufno = (bufno + 1) % ARRAY_SIZE(hexbuffer);\n\tfind_unique_abbrev_r(hex, oid, len);\n\treturn hex;\n}\n\nstatic int ambiguous_path(const char *path, int len)\n{\n\tint slash = 1;\n\tint cnt;\n\n\tfor (cnt = 0; cnt < len; cnt++) {\n\t\tswitch (*path++) {\n\t\tcase '\\0':\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tif (slash)\n\t\t\t\tbreak;\n\t\t\tslash = 1;\n\t\t\tcontinue;\n\t\tcase '.':\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tslash = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn slash;\n}\n\nstatic inline int at_mark(const char *string, int len,\n\t\t\t  const char **suffix, int nr)\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tint suffix_len = strlen(suffix[i]);\n\t\tif (suffix_len <= len\n\t\t    && !strncasecmp(string, suffix[i], suffix_len))\n\t\t\treturn suffix_len;\n\t}\n\treturn 0;\n}\n\nstatic inline int upstream_mark(const char *string, int len)\n{\n\tconst char *suffix[] = { \"@{upstream}\", \"@{u}\" };\n\treturn at_mark(string, len, suffix, ARRAY_SIZE(suffix));\n}\n\nstatic inline int push_mark(const char *string, int len)\n{\n\tconst char *suffix[] = { \"@{push}\" };\n\treturn at_mark(string, len, suffix, ARRAY_SIZE(suffix));\n}\n\nstatic int get_oid_1(const char *name, int len, struct object_id *oid, unsigned lookup_flags);\nstatic int interpret_nth_prior_checkout(const char *name, int namelen, struct strbuf *buf);\n\nstatic int get_oid_basic(const char *str, int len, struct object_id *oid,\n\t\t\t  unsigned int flags)\n{\n\tstatic const char *warn_msg = \"refname '%.*s' is ambiguous.\";\n\tstatic const char *object_name_msg = N_(\n\t\"Git normally never creates a ref that ends with 40 hex characters\\n\"\n\t\"because it will be ignored when you just specify 40-hex. These refs\\n\"\n\t\"may be created by mistake. For example,\\n\"\n\t\"\\n\"\n\t\"  git checkout -b $br $(git rev-parse ...)\\n\"\n\t\"\\n\"\n\t\"where \\\"$br\\\" is somehow empty and a 40-hex ref is created. Please\\n\"\n\t\"examine these refs and maybe delete them. Turn this message off by\\n\"\n\t\"running \\\"git config advice.objectNameWarning false\\\"\");\n\tstruct object_id tmp_oid;\n\tchar *real_ref = NULL;\n\tint refs_found = 0;\n\tint at, reflog_len, nth_prior = 0;\n\n\tif (len == GIT_SHA1_HEXSZ && !get_oid_hex(str, oid)) {\n\t\tif (warn_ambiguous_refs && warn_on_object_refname_ambiguity) {\n\t\t\trefs_found = dwim_ref(str, len, &tmp_oid, &real_ref);\n\t\t\tif (refs_found > 0) {\n\t\t\t\twarning(warn_msg, len, str);\n\t\t\t\tif (advice_object_name_warning)\n\t\t\t\t\tfprintf(stderr, \"%s\\n\", _(object_name_msg));\n\t\t\t}\n\t\t\tfree(real_ref);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* basic@{time or number or -number} format to query ref-log */\n\treflog_len = at = 0;\n\tif (len && str[len-1] == '}') {\n\t\tfor (at = len-4; at >= 0; at--) {\n\t\t\tif (str[at] == '@' && str[at+1] == '{') {\n\t\t\t\tif (str[at+2] == '-') {\n\t\t\t\t\tif (at != 0)\n\t\t\t\t\t\t/* @{-N} not at start */\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tnth_prior = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!upstream_mark(str + at, len - at) &&\n\t\t\t\t    !push_mark(str + at, len - at)) {\n\t\t\t\t\treflog_len = (len-1) - (at+2);\n\t\t\t\t\tlen = at;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Accept only unambiguous ref paths. */\n\tif (len && ambiguous_path(str, len))\n\t\treturn -1;\n\n\tif (nth_prior) {\n\t\tstruct strbuf buf = STRBUF_INIT;\n\t\tint detached;\n\n\t\tif (interpret_nth_prior_checkout(str, len, &buf) > 0) {\n\t\t\tdetached = (buf.len == GIT_SHA1_HEXSZ && !get_oid_hex(buf.buf, oid));\n\t\t\tstrbuf_release(&buf);\n\t\t\tif (detached)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!len && reflog_len)\n\t\t/* allow \"@{...}\" to mean the current branch reflog */\n\t\trefs_found = dwim_ref(\"HEAD\", 4, oid, &real_ref);\n\telse if (reflog_len)\n\t\trefs_found = dwim_log(str, len, oid, &real_ref);\n\telse\n\t\trefs_found = dwim_ref(str, len, oid, &real_ref);\n\n\tif (!refs_found)\n\t\treturn -1;\n\n\tif (warn_ambiguous_refs && !(flags & GET_OID_QUIETLY) &&\n\t    (refs_found > 1 ||\n\t     !get_short_oid(str, len, &tmp_oid, GET_OID_QUIETLY)))\n\t\twarning(warn_msg, len, str);\n\n\tif (reflog_len) {\n\t\tint nth, i;\n\t\ttimestamp_t at_time;\n\t\ttimestamp_t co_time;\n\t\tint co_tz, co_cnt;\n\n\t\t/* Is it asking for N-th entry, or approxidate? */\n\t\tfor (i = nth = 0; 0 <= nth && i < reflog_len; i++) {\n\t\t\tchar ch = str[at+2+i];\n\t\t\tif ('0' <= ch && ch <= '9')\n\t\t\t\tnth = nth * 10 + ch - '0';\n\t\t\telse\n\t\t\t\tnth = -1;\n\t\t}\n\t\tif (100000000 <= nth) {\n\t\t\tat_time = nth;\n\t\t\tnth = -1;\n\t\t} else if (0 <= nth)\n\t\t\tat_time = 0;\n\t\telse {\n\t\t\tint errors = 0;\n\t\t\tchar *tmp = xstrndup(str + at + 2, reflog_len);\n\t\t\tat_time = approxidate_careful(tmp, &errors);\n\t\t\tfree(tmp);\n\t\t\tif (errors) {\n\t\t\t\tfree(real_ref);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (read_ref_at(real_ref, flags, at_time, nth, oid, NULL,\n\t\t\t\t&co_time, &co_tz, &co_cnt)) {\n\t\t\tif (!len) {\n\t\t\t\tif (starts_with(real_ref, \"refs/heads/\")) {\n\t\t\t\t\tstr = real_ref + 11;\n\t\t\t\t\tlen = strlen(real_ref + 11);\n\t\t\t\t} else {\n\t\t\t\t\t/* detached HEAD */\n\t\t\t\t\tstr = \"HEAD\";\n\t\t\t\t\tlen = 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (at_time) {\n\t\t\t\tif (!(flags & GET_OID_QUIETLY)) {\n\t\t\t\t\twarning(\"Log for '%.*s' only goes \"\n\t\t\t\t\t\t\"back to %s.\", len, str,\n\t\t\t\t\t\tshow_date(co_time, co_tz, DATE_MODE(RFC2822)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (flags & GET_OID_QUIETLY) {\n\t\t\t\t\texit(128);\n\t\t\t\t}\n\t\t\t\tdie(\"Log for '%.*s' only has %d entries.\",\n\t\t\t\t    len, str, co_cnt);\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(real_ref);\n\treturn 0;\n}\n\nstatic int get_parent(const char *name, int len,\n\t\t      struct object_id *result, int idx)\n{\n\tstruct object_id oid;\n\tint ret = get_oid_1(name, len, &oid, GET_OID_COMMITTISH);\n\tstruct commit *commit;\n\tstruct commit_list *p;\n\n\tif (ret)\n\t\treturn ret;\n\tcommit = lookup_commit_reference(the_repository, &oid);\n\tif (parse_commit(commit))\n\t\treturn -1;\n\tif (!idx) {\n\t\toidcpy(result, &commit->object.oid);\n\t\treturn 0;\n\t}\n\tp = commit->parents;\n\twhile (p) {\n\t\tif (!--idx) {\n\t\t\toidcpy(result, &p->item->object.oid);\n\t\t\treturn 0;\n\t\t}\n\t\tp = p->next;\n\t}\n\treturn -1;\n}\n\nstatic int get_nth_ancestor(const char *name, int len,\n\t\t\t    struct object_id *result, int generation)\n{\n\tstruct object_id oid;\n\tstruct commit *commit;\n\tint ret;\n\n\tret = get_oid_1(name, len, &oid, GET_OID_COMMITTISH);\n\tif (ret)\n\t\treturn ret;\n\tcommit = lookup_commit_reference(the_repository, &oid);\n\tif (!commit)\n\t\treturn -1;\n\n\twhile (generation--) {\n\t\tif (parse_commit(commit) || !commit->parents)\n\t\t\treturn -1;\n\t\tcommit = commit->parents->item;\n\t}\n\toidcpy(result, &commit->object.oid);\n\treturn 0;\n}\n\nstruct object *peel_to_type(const char *name, int namelen,\n\t\t\t    struct object *o, enum object_type expected_type)\n{\n\tif (name && !namelen)\n\t\tnamelen = strlen(name);\n\twhile (1) {\n\t\tif (!o || (!o->parsed && !parse_object(the_repository, &o->oid)))\n\t\t\treturn NULL;\n\t\tif (expected_type == OBJ_ANY || o->type == expected_type)\n\t\t\treturn o;\n\t\tif (o->type == OBJ_TAG)\n\t\t\to = ((struct tag*) o)->tagged;\n\t\telse if (o->type == OBJ_COMMIT)\n\t\t\to = &(get_commit_tree(((struct commit *)o))->object);\n\t\telse {\n\t\t\tif (name)\n\t\t\t\terror(\"%.*s: expected %s type, but the object \"\n\t\t\t\t      \"dereferences to %s type\",\n\t\t\t\t      namelen, name, type_name(expected_type),\n\t\t\t\t      type_name(o->type));\n\t\t\treturn NULL;\n\t\t}\n\t}\n}\n\nstatic int peel_onion(const char *name, int len, struct object_id *oid,\n\t\t      unsigned lookup_flags)\n{\n\tstruct object_id outer;\n\tconst char *sp;\n\tunsigned int expected_type = 0;\n\tstruct object *o;\n\n\t/*\n\t * \"ref^{type}\" dereferences ref repeatedly until you cannot\n\t * dereference anymore, or you get an object of given type,\n\t * whichever comes first.  \"ref^{}\" means just dereference\n\t * tags until you get a non-tag.  \"ref^0\" is a shorthand for\n\t * \"ref^{commit}\".  \"commit^{tree}\" could be used to find the\n\t * top-level tree of the given commit.\n\t */\n\tif (len < 4 || name[len-1] != '}')\n\t\treturn -1;\n\n\tfor (sp = name + len - 1; name <= sp; sp--) {\n\t\tint ch = *sp;\n\t\tif (ch == '{' && name < sp && sp[-1] == '^')\n\t\t\tbreak;\n\t}\n\tif (sp <= name)\n\t\treturn -1;\n\n\tsp++; /* beginning of type name, or closing brace for empty */\n\tif (starts_with(sp, \"commit}\"))\n\t\texpected_type = OBJ_COMMIT;\n\telse if (starts_with(sp, \"tag}\"))\n\t\texpected_type = OBJ_TAG;\n\telse if (starts_with(sp, \"tree}\"))\n\t\texpected_type = OBJ_TREE;\n\telse if (starts_with(sp, \"blob}\"))\n\t\texpected_type = OBJ_BLOB;\n\telse if (starts_with(sp, \"object}\"))\n\t\texpected_type = OBJ_ANY;\n\telse if (sp[0] == '}')\n\t\texpected_type = OBJ_NONE;\n\telse if (sp[0] == '/')\n\t\texpected_type = OBJ_COMMIT;\n\telse\n\t\treturn -1;\n\n\tlookup_flags &= ~GET_OID_DISAMBIGUATORS;\n\tif (expected_type == OBJ_COMMIT)\n\t\tlookup_flags |= GET_OID_COMMITTISH;\n\telse if (expected_type == OBJ_TREE)\n\t\tlookup_flags |= GET_OID_TREEISH;\n\n\tif (get_oid_1(name, sp - name - 2, &outer, lookup_flags))\n\t\treturn -1;\n\n\to = parse_object(the_repository, &outer);\n\tif (!o)\n\t\treturn -1;\n\tif (!expected_type) {\n\t\to = deref_tag(the_repository, o, name, sp - name - 2);\n\t\tif (!o || (!o->parsed && !parse_object(the_repository, &o->oid)))\n\t\t\treturn -1;\n\t\toidcpy(oid, &o->oid);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * At this point, the syntax look correct, so\n\t * if we do not get the needed object, we should\n\t * barf.\n\t */\n\to = peel_to_type(name, len, o, expected_type);\n\tif (!o)\n\t\treturn -1;\n\n\toidcpy(oid, &o->oid);\n\tif (sp[0] == '/') {\n\t\t/* \"$commit^{/foo}\" */\n\t\tchar *prefix;\n\t\tint ret;\n\t\tstruct commit_list *list = NULL;\n\n\t\t/*\n\t\t * $commit^{/}. Some regex implementation may reject.\n\t\t * We don't need regex anyway. '' pattern always matches.\n\t\t */\n\t\tif (sp[1] == '}')\n\t\t\treturn 0;\n\n\t\tprefix = xstrndup(sp + 1, name + len - 1 - (sp + 1));\n\t\tcommit_list_insert((struct commit *)o, &list);\n\t\tret = get_oid_oneline(prefix, oid, list);\n\t\tfree(prefix);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int get_describe_name(const char *name, int len, struct object_id *oid)\n{\n\tconst char *cp;\n\tunsigned flags = GET_OID_QUIETLY | GET_OID_COMMIT;\n\n\tfor (cp = name + len - 1; name + 2 <= cp; cp--) {\n\t\tchar ch = *cp;\n\t\tif (!isxdigit(ch)) {\n\t\t\t/* We must be looking at g in \"SOMETHING-g\"\n\t\t\t * for it to be describe output.\n\t\t\t */\n\t\t\tif (ch == 'g' && cp[-1] == '-') {\n\t\t\t\tcp++;\n\t\t\t\tlen -= cp - name;\n\t\t\t\treturn get_short_oid(cp, len, oid, flags);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic int get_oid_1(const char *name, int len, struct object_id *oid, unsigned lookup_flags)\n{\n\tint ret, has_suffix;\n\tconst char *cp;\n\n\t/*\n\t * \"name~3\" is \"name^^^\", \"name~\" is \"name~1\", and \"name^\" is \"name^1\".\n\t */\n\thas_suffix = 0;\n\tfor (cp = name + len - 1; name <= cp; cp--) {\n\t\tint ch = *cp;\n\t\tif ('0' <= ch && ch <= '9')\n\t\t\tcontinue;\n\t\tif (ch == '~' || ch == '^')\n\t\t\thas_suffix = ch;\n\t\tbreak;\n\t}\n\n\tif (has_suffix) {\n\t\tint num = 0;\n\t\tint len1 = cp - name;\n\t\tcp++;\n\t\twhile (cp < name + len)\n\t\t\tnum = num * 10 + *cp++ - '0';\n\t\tif (!num && len1 == len - 1)\n\t\t\tnum = 1;\n\t\tif (has_suffix == '^')\n\t\t\treturn get_parent(name, len1, oid, num);\n\t\t/* else if (has_suffix == '~') -- goes without saying */\n\t\treturn get_nth_ancestor(name, len1, oid, num);\n\t}\n\n\tret = peel_onion(name, len, oid, lookup_flags);\n\tif (!ret)\n\t\treturn 0;\n\n\tret = get_oid_basic(name, len, oid, lookup_flags);\n\tif (!ret)\n\t\treturn 0;\n\n\t/* It could be describe output that is \"SOMETHING-gXXXX\" */\n\tret = get_describe_name(name, len, oid);\n\tif (!ret)\n\t\treturn 0;\n\n\treturn get_short_oid(name, len, oid, lookup_flags);\n}\n\n/*\n * This interprets names like ':/Initial revision of \"git\"' by searching\n * through history and returning the first commit whose message starts\n * the given regular expression.\n *\n * For negative-matching, prefix the pattern-part with '!-', like: ':/!-WIP'.\n *\n * For a literal '!' character at the beginning of a pattern, you have to repeat\n * that, like: ':/!!foo'\n *\n * For future extension, all other sequences beginning with ':/!' are reserved.\n */\n\n/* Remember to update object flag allocation in object.h */\n#define ONELINE_SEEN (1u<<20)\n\nstatic int handle_one_ref(const char *path, const struct object_id *oid,\n\t\t\t  int flag, void *cb_data)\n{\n\tstruct commit_list **list = cb_data;\n\tstruct object *object = parse_object(the_repository, oid);\n\tif (!object)\n\t\treturn 0;\n\tif (object->type == OBJ_TAG) {\n\t\tobject = deref_tag(the_repository, object, path,\n\t\t\t\t   strlen(path));\n\t\tif (!object)\n\t\t\treturn 0;\n\t}\n\tif (object->type != OBJ_COMMIT)\n\t\treturn 0;\n\tcommit_list_insert((struct commit *)object, list);\n\treturn 0;\n}\n\nstatic int get_oid_oneline(const char *prefix, struct object_id *oid,\n\t\t\t    struct commit_list *list)\n{\n\tstruct commit_list *backup = NULL, *l;\n\tint found = 0;\n\tint negative = 0;\n\tregex_t regex;\n\n\tif (prefix[0] == '!') {\n\t\tprefix++;\n\n\t\tif (prefix[0] == '-') {\n\t\t\tprefix++;\n\t\t\tnegative = 1;\n\t\t} else if (prefix[0] != '!') {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (regcomp(&regex, prefix, REG_EXTENDED))\n\t\treturn -1;\n\n\tfor (l = list; l; l = l->next) {\n\t\tl->item->object.flags |= ONELINE_SEEN;\n\t\tcommit_list_insert(l->item, &backup);\n\t}\n\twhile (list) {\n\t\tconst char *p, *buf;\n\t\tstruct commit *commit;\n\t\tint matches;\n\n\t\tcommit = pop_most_recent_commit(&list, ONELINE_SEEN);\n\t\tif (!parse_object(the_repository, &commit->object.oid))\n\t\t\tcontinue;\n\t\tbuf = get_commit_buffer(commit, NULL);\n\t\tp = strstr(buf, \"\\n\\n\");\n\t\tmatches = negative ^ (p && !regexec(&regex, p + 2, 0, NULL, 0));\n\t\tunuse_commit_buffer(commit, buf);\n\n\t\tif (matches) {\n\t\t\toidcpy(oid, &commit->object.oid);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tregfree(&regex);\n\tfree_commit_list(list);\n\tfor (l = backup; l; l = l->next)\n\t\tclear_commit_marks(l->item, ONELINE_SEEN);\n\tfree_commit_list(backup);\n\treturn found ? 0 : -1;\n}\n\nstruct grab_nth_branch_switch_cbdata {\n\tint remaining;\n\tstruct strbuf buf;\n};\n\nstatic int grab_nth_branch_switch(struct object_id *ooid, struct object_id *noid,\n\t\t\t\t  const char *email, timestamp_t timestamp, int tz,\n\t\t\t\t  const char *message, void *cb_data)\n{\n\tstruct grab_nth_branch_switch_cbdata *cb = cb_data;\n\tconst char *match = NULL, *target = NULL;\n\tsize_t len;\n\n\tif (skip_prefix(message, \"checkout: moving from \", &match))\n\t\ttarget = strstr(match, \" to \");\n\n\tif (!match || !target)\n\t\treturn 0;\n\tif (--(cb->remaining) == 0) {\n\t\tlen = target - match;\n\t\tstrbuf_reset(&cb->buf);\n\t\tstrbuf_add(&cb->buf, match, len);\n\t\treturn 1; /* we are done */\n\t}\n\treturn 0;\n}\n\n/*\n * Parse @{-N} syntax, return the number of characters parsed\n * if successful; otherwise signal an error with negative value.\n */\nstatic int interpret_nth_prior_checkout(const char *name, int namelen,\n\t\t\t\t\tstruct strbuf *buf)\n{\n\tlong nth;\n\tint retval;\n\tstruct grab_nth_branch_switch_cbdata cb;\n\tconst char *brace;\n\tchar *num_end;\n\n\tif (namelen < 4)\n\t\treturn -1;\n\tif (name[0] != '@' || name[1] != '{' || name[2] != '-')\n\t\treturn -1;\n\tbrace = memchr(name, '}', namelen);\n\tif (!brace)\n\t\treturn -1;\n\tnth = strtol(name + 3, &num_end, 10);\n\tif (num_end != brace)\n\t\treturn -1;\n\tif (nth <= 0)\n\t\treturn -1;\n\tcb.remaining = nth;\n\tstrbuf_init(&cb.buf, 20);\n\n\tretval = 0;\n\tif (0 < for_each_reflog_ent_reverse(\"HEAD\", grab_nth_branch_switch, &cb)) {\n\t\tstrbuf_reset(buf);\n\t\tstrbuf_addbuf(buf, &cb.buf);\n\t\tretval = brace - name + 1;\n\t}\n\n\tstrbuf_release(&cb.buf);\n\treturn retval;\n}\n\nint get_oid_mb(const char *name, struct object_id *oid)\n{\n\tstruct commit *one, *two;\n\tstruct commit_list *mbs;\n\tstruct object_id oid_tmp;\n\tconst char *dots;\n\tint st;\n\n\tdots = strstr(name, \"...\");\n\tif (!dots)\n\t\treturn get_oid(name, oid);\n\tif (dots == name)\n\t\tst = get_oid(\"HEAD\", &oid_tmp);\n\telse {\n\t\tstruct strbuf sb;\n\t\tstrbuf_init(&sb, dots - name);\n\t\tstrbuf_add(&sb, name, dots - name);\n\t\tst = get_oid_committish(sb.buf, &oid_tmp);\n\t\tstrbuf_release(&sb);\n\t}\n\tif (st)\n\t\treturn st;\n\tone = lookup_commit_reference_gently(the_repository, &oid_tmp, 0);\n\tif (!one)\n\t\treturn -1;\n\n\tif (get_oid_committish(dots[3] ? (dots + 3) : \"HEAD\", &oid_tmp))\n\t\treturn -1;\n\ttwo = lookup_commit_reference_gently(the_repository, &oid_tmp, 0);\n\tif (!two)\n\t\treturn -1;\n\tmbs = get_merge_bases(one, two);\n\tif (!mbs || mbs->next)\n\t\tst = -1;\n\telse {\n\t\tst = 0;\n\t\toidcpy(oid, &mbs->item->object.oid);\n\t}\n\tfree_commit_list(mbs);\n\treturn st;\n}\n\n/* parse @something syntax, when 'something' is not {.*} */\nstatic int interpret_empty_at(const char *name, int namelen, int len, struct strbuf *buf)\n{\n\tconst char *next;\n\n\tif (len || name[1] == '{')\n\t\treturn -1;\n\n\t/* make sure it's a single @, or @@{.*}, not @foo */\n\tnext = memchr(name + len + 1, '@', namelen - len - 1);\n\tif (next && next[1] != '{')\n\t\treturn -1;\n\tif (!next)\n\t\tnext = name + namelen;\n\tif (next != name + 1)\n\t\treturn -1;\n\n\tstrbuf_reset(buf);\n\tstrbuf_add(buf, \"HEAD\", 4);\n\treturn 1;\n}\n\nstatic int reinterpret(const char *name, int namelen, int len,\n\t\t       struct strbuf *buf, unsigned allowed)\n{\n\t/* we have extra data, which might need further processing */\n\tstruct strbuf tmp = STRBUF_INIT;\n\tint used = buf->len;\n\tint ret;\n\n\tstrbuf_add(buf, name + len, namelen - len);\n\tret = interpret_branch_name(buf->buf, buf->len, &tmp, allowed);\n\t/* that data was not interpreted, remove our cruft */\n\tif (ret < 0) {\n\t\tstrbuf_setlen(buf, used);\n\t\treturn len;\n\t}\n\tstrbuf_reset(buf);\n\tstrbuf_addbuf(buf, &tmp);\n\tstrbuf_release(&tmp);\n\t/* tweak for size of {-N} versus expanded ref name */\n\treturn ret - used + len;\n}\n\nstatic void set_shortened_ref(struct strbuf *buf, const char *ref)\n{\n\tchar *s = shorten_unambiguous_ref(ref, 0);\n\tstrbuf_reset(buf);\n\tstrbuf_addstr(buf, s);\n\tfree(s);\n}\n\nstatic int branch_interpret_allowed(const char *refname, unsigned allowed)\n{\n\tif (!allowed)\n\t\treturn 1;\n\n\tif ((allowed & INTERPRET_BRANCH_LOCAL) &&\n\t    starts_with(refname, \"refs/heads/\"))\n\t\treturn 1;\n\tif ((allowed & INTERPRET_BRANCH_REMOTE) &&\n\t    starts_with(refname, \"refs/remotes/\"))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int interpret_branch_mark(const char *name, int namelen,\n\t\t\t\t int at, struct strbuf *buf,\n\t\t\t\t int (*get_mark)(const char *, int),\n\t\t\t\t const char *(*get_data)(struct branch *,\n\t\t\t\t\t\t\t struct strbuf *),\n\t\t\t\t unsigned allowed)\n{\n\tint len;\n\tstruct branch *branch;\n\tstruct strbuf err = STRBUF_INIT;\n\tconst char *value;\n\n\tlen = get_mark(name + at, namelen - at);\n\tif (!len)\n\t\treturn -1;\n\n\tif (memchr(name, ':', at))\n\t\treturn -1;\n\n\tif (at) {\n\t\tchar *name_str = xmemdupz(name, at);\n\t\tbranch = branch_get(name_str);\n\t\tfree(name_str);\n\t} else\n\t\tbranch = branch_get(NULL);\n\n\tvalue = get_data(branch, &err);\n\tif (!value)\n\t\tdie(\"%s\", err.buf);\n\n\tif (!branch_interpret_allowed(value, allowed))\n\t\treturn -1;\n\n\tset_shortened_ref(buf, value);\n\treturn len + at;\n}\n\nint interpret_branch_name(const char *name, int namelen, struct strbuf *buf,\n\t\t\t  unsigned allowed)\n{\n\tchar *at;\n\tconst char *start;\n\tint len;\n\n\tif (!namelen)\n\t\tnamelen = strlen(name);\n\n\tif (!allowed || (allowed & INTERPRET_BRANCH_LOCAL)) {\n\t\tlen = interpret_nth_prior_checkout(name, namelen, buf);\n\t\tif (!len) {\n\t\t\treturn len; /* syntax Ok, not enough switches */\n\t\t} else if (len > 0) {\n\t\t\tif (len == namelen)\n\t\t\t\treturn len; /* consumed all */\n\t\t\telse\n\t\t\t\treturn reinterpret(name, namelen, len, buf, allowed);\n\t\t}\n\t}\n\n\tfor (start = name;\n\t     (at = memchr(start, '@', namelen - (start - name)));\n\t     start = at + 1) {\n\n\t\tif (!allowed || (allowed & INTERPRET_BRANCH_HEAD)) {\n\t\t\tlen = interpret_empty_at(name, namelen, at - name, buf);\n\t\t\tif (len > 0)\n\t\t\t\treturn reinterpret(name, namelen, len, buf,\n\t\t\t\t\t\t   allowed);\n\t\t}\n\n\t\tlen = interpret_branch_mark(name, namelen, at - name, buf,\n\t\t\t\t\t    upstream_mark, branch_get_upstream,\n\t\t\t\t\t    allowed);\n\t\tif (len > 0)\n\t\t\treturn len;\n\n\t\tlen = interpret_branch_mark(name, namelen, at - name, buf,\n\t\t\t\t\t    push_mark, branch_get_push,\n\t\t\t\t\t    allowed);\n\t\tif (len > 0)\n\t\t\treturn len;\n\t}\n\n\treturn -1;\n}\n\nvoid strbuf_branchname(struct strbuf *sb, const char *name, unsigned allowed)\n{\n\tint len = strlen(name);\n\tint used = interpret_branch_name(name, len, sb, allowed);\n\n\tif (used < 0)\n\t\tused = 0;\n\tstrbuf_add(sb, name + used, len - used);\n}\n\nint strbuf_check_branch_ref(struct strbuf *sb, const char *name)\n{\n\tif (startup_info->have_repository)\n\t\tstrbuf_branchname(sb, name, INTERPRET_BRANCH_LOCAL);\n\telse\n\t\tstrbuf_addstr(sb, name);\n\n\t/*\n\t * This splice must be done even if we end up rejecting the\n\t * name; builtin/branch.c::copy_or_rename_branch() still wants\n\t * to see what the name expanded to so that \"branch -m\" can be\n\t * used as a tool to correct earlier mistakes.\n\t */\n\tstrbuf_splice(sb, 0, 0, \"refs/heads/\", 11);\n\n\tif (*name == '-' ||\n\t    !strcmp(sb->buf, \"refs/heads/HEAD\"))\n\t\treturn -1;\n\n\treturn check_refname_format(sb->buf, 0);\n}\n\n/*\n * This is like \"get_oid_basic()\", except it allows \"object ID expressions\",\n * notably \"xyz^\" for \"parent of xyz\"\n */\nint get_oid(const char *name, struct object_id *oid)\n{\n\tstruct object_context unused;\n\treturn get_oid_with_context(name, 0, oid, &unused);\n}\n\n\n/*\n * Many callers know that the user meant to name a commit-ish by\n * syntactical positions where the object name appears.  Calling this\n * function allows the machinery to disambiguate shorter-than-unique\n * abbreviated object names between commit-ish and others.\n *\n * Note that this does NOT error out when the named object is not a\n * commit-ish. It is merely to give a hint to the disambiguation\n * machinery.\n */\nint get_oid_committish(const char *name, struct object_id *oid)\n{\n\tstruct object_context unused;\n\treturn get_oid_with_context(name, GET_OID_COMMITTISH,\n\t\t\t\t    oid, &unused);\n}\n\nint get_oid_treeish(const char *name, struct object_id *oid)\n{\n\tstruct object_context unused;\n\treturn get_oid_with_context(name, GET_OID_TREEISH,\n\t\t\t\t    oid, &unused);\n}\n\nint get_oid_commit(const char *name, struct object_id *oid)\n{\n\tstruct object_context unused;\n\treturn get_oid_with_context(name, GET_OID_COMMIT,\n\t\t\t\t    oid, &unused);\n}\n\nint get_oid_tree(const char *name, struct object_id *oid)\n{\n\tstruct object_context unused;\n\treturn get_oid_with_context(name, GET_OID_TREE,\n\t\t\t\t    oid, &unused);\n}\n\nint get_oid_blob(const char *name, struct object_id *oid)\n{\n\tstruct object_context unused;\n\treturn get_oid_with_context(name, GET_OID_BLOB,\n\t\t\t\t    oid, &unused);\n}\n\n/* Must be called only when object_name:filename doesn't exist. */\nstatic void diagnose_invalid_oid_path(const char *prefix,\n\t\t\t\t      const char *filename,\n\t\t\t\t      const struct object_id *tree_oid,\n\t\t\t\t      const char *object_name,\n\t\t\t\t      int object_name_len)\n{\n\tstruct object_id oid;\n\tunsigned mode;\n\n\tif (!prefix)\n\t\tprefix = \"\";\n\n\tif (file_exists(filename))\n\t\tdie(\"Path '%s' exists on disk, but not in '%.*s'.\",\n\t\t    filename, object_name_len, object_name);\n\tif (is_missing_file_error(errno)) {\n\t\tchar *fullname = xstrfmt(\"%s%s\", prefix, filename);\n\n\t\tif (!get_tree_entry(tree_oid, fullname, &oid, &mode)) {\n\t\t\tdie(\"Path '%s' exists, but not '%s'.\\n\"\n\t\t\t    \"Did you mean '%.*s:%s' aka '%.*s:./%s'?\",\n\t\t\t    fullname,\n\t\t\t    filename,\n\t\t\t    object_name_len, object_name,\n\t\t\t    fullname,\n\t\t\t    object_name_len, object_name,\n\t\t\t    filename);\n\t\t}\n\t\tdie(\"Path '%s' does not exist in '%.*s'\",\n\t\t    filename, object_name_len, object_name);\n\t}\n}\n\n/* Must be called only when :stage:filename doesn't exist. */\nstatic void diagnose_invalid_index_path(int stage,\n\t\t\t\t\tconst char *prefix,\n\t\t\t\t\tconst char *filename)\n{\n\tconst struct cache_entry *ce;\n\tint pos;\n\tunsigned namelen = strlen(filename);\n\tstruct strbuf fullname = STRBUF_INIT;\n\n\tif (!prefix)\n\t\tprefix = \"\";\n\n\t/* Wrong stage number? */\n\tpos = cache_name_pos(filename, namelen);\n\tif (pos < 0)\n\t\tpos = -pos - 1;\n\tif (pos < active_nr) {\n\t\tce = active_cache[pos];\n\t\tif (ce_namelen(ce) == namelen &&\n\t\t    !memcmp(ce->name, filename, namelen))\n\t\t\tdie(\"Path '%s' is in the index, but not at stage %d.\\n\"\n\t\t\t    \"Did you mean ':%d:%s'?\",\n\t\t\t    filename, stage,\n\t\t\t    ce_stage(ce), filename);\n\t}\n\n\t/* Confusion between relative and absolute filenames? */\n\tstrbuf_addstr(&fullname, prefix);\n\tstrbuf_addstr(&fullname, filename);\n\tpos = cache_name_pos(fullname.buf, fullname.len);\n\tif (pos < 0)\n\t\tpos = -pos - 1;\n\tif (pos < active_nr) {\n\t\tce = active_cache[pos];\n\t\tif (ce_namelen(ce) == fullname.len &&\n\t\t    !memcmp(ce->name, fullname.buf, fullname.len))\n\t\t\tdie(\"Path '%s' is in the index, but not '%s'.\\n\"\n\t\t\t    \"Did you mean ':%d:%s' aka ':%d:./%s'?\",\n\t\t\t    fullname.buf, filename,\n\t\t\t    ce_stage(ce), fullname.buf,\n\t\t\t    ce_stage(ce), filename);\n\t}\n\n\tif (file_exists(filename))\n\t\tdie(\"Path '%s' exists on disk, but not in the index.\", filename);\n\tif (is_missing_file_error(errno))\n\t\tdie(\"Path '%s' does not exist (neither on disk nor in the index).\",\n\t\t    filename);\n\n\tstrbuf_release(&fullname);\n}\n\n\nstatic char *resolve_relative_path(const char *rel)\n{\n\tif (!starts_with(rel, \"./\") && !starts_with(rel, \"../\"))\n\t\treturn NULL;\n\n\tif (!is_inside_work_tree())\n\t\tdie(\"relative path syntax can't be used outside working tree.\");\n\n\t/* die() inside prefix_path() if resolved path is outside worktree */\n\treturn prefix_path(startup_info->prefix,\n\t\t\t   startup_info->prefix ? strlen(startup_info->prefix) : 0,\n\t\t\t   rel);\n}\n\nstatic int get_oid_with_context_1(const char *name,\n\t\t\t\t  unsigned flags,\n\t\t\t\t  const char *prefix,\n\t\t\t\t  struct object_id *oid,\n\t\t\t\t  struct object_context *oc)\n{\n\tint ret, bracket_depth;\n\tint namelen = strlen(name);\n\tconst char *cp;\n\tint only_to_die = flags & GET_OID_ONLY_TO_DIE;\n\n\tif (only_to_die)\n\t\tflags |= GET_OID_QUIETLY;\n\n\tmemset(oc, 0, sizeof(*oc));\n\toc->mode = S_IFINVALID;\n\tstrbuf_init(&oc->symlink_path, 0);\n\tret = get_oid_1(name, namelen, oid, flags);\n\tif (!ret)\n\t\treturn ret;\n\t/*\n\t * sha1:path --> object name of path in ent sha1\n\t * :path -> object name of absolute path in index\n\t * :./path -> object name of path relative to cwd in index\n\t * :[0-3]:path -> object name of path in index at stage\n\t * :/foo -> recent commit matching foo\n\t */\n\tif (name[0] == ':') {\n\t\tint stage = 0;\n\t\tconst struct cache_entry *ce;\n\t\tchar *new_path = NULL;\n\t\tint pos;\n\t\tif (!only_to_die && namelen > 2 && name[1] == '/') {\n\t\t\tstruct commit_list *list = NULL;\n\n\t\t\tfor_each_ref(handle_one_ref, &list);\n\t\t\tcommit_list_sort_by_date(&list);\n\t\t\treturn get_oid_oneline(name + 2, oid, list);\n\t\t}\n\t\tif (namelen < 3 ||\n\t\t    name[2] != ':' ||\n\t\t    name[1] < '0' || '3' < name[1])\n\t\t\tcp = name + 1;\n\t\telse {\n\t\t\tstage = name[1] - '0';\n\t\t\tcp = name + 3;\n\t\t}\n\t\tnew_path = resolve_relative_path(cp);\n\t\tif (!new_path) {\n\t\t\tnamelen = namelen - (cp - name);\n\t\t} else {\n\t\t\tcp = new_path;\n\t\t\tnamelen = strlen(cp);\n\t\t}\n\n\t\tif (flags & GET_OID_RECORD_PATH)\n\t\t\toc->path = xstrdup(cp);\n\n\t\tif (!active_cache)\n\t\t\tread_cache();\n\t\tpos = cache_name_pos(cp, namelen);\n\t\tif (pos < 0)\n\t\t\tpos = -pos - 1;\n\t\twhile (pos < active_nr) {\n\t\t\tce = active_cache[pos];\n\t\t\tif (ce_namelen(ce) != namelen ||\n\t\t\t    memcmp(ce->name, cp, namelen))\n\t\t\t\tbreak;\n\t\t\tif (ce_stage(ce) == stage) {\n\t\t\t\toidcpy(oid, &ce->oid);\n\t\t\t\toc->mode = ce->ce_mode;\n\t\t\t\tfree(new_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t\tif (only_to_die && name[1] && name[1] != '/')\n\t\t\tdiagnose_invalid_index_path(stage, prefix, cp);\n\t\tfree(new_path);\n\t\treturn -1;\n\t}\n\tfor (cp = name, bracket_depth = 0; *cp; cp++) {\n\t\tif (*cp == '{')\n\t\t\tbracket_depth++;\n\t\telse if (bracket_depth && *cp == '}')\n\t\t\tbracket_depth--;\n\t\telse if (!bracket_depth && *cp == ':')\n\t\t\tbreak;\n\t}\n\tif (*cp == ':') {\n\t\tstruct object_id tree_oid;\n\t\tint len = cp - name;\n\t\tunsigned sub_flags = flags;\n\n\t\tsub_flags &= ~GET_OID_DISAMBIGUATORS;\n\t\tsub_flags |= GET_OID_TREEISH;\n\n\t\tif (!get_oid_1(name, len, &tree_oid, sub_flags)) {\n\t\t\tconst char *filename = cp+1;\n\t\t\tchar *new_filename = NULL;\n\n\t\t\tnew_filename = resolve_relative_path(filename);\n\t\t\tif (new_filename)\n\t\t\t\tfilename = new_filename;\n\t\t\tif (flags & GET_OID_FOLLOW_SYMLINKS) {\n\t\t\t\tret = get_tree_entry_follow_symlinks(&tree_oid,\n\t\t\t\t\tfilename, oid, &oc->symlink_path,\n\t\t\t\t\t&oc->mode);\n\t\t\t} else {\n\t\t\t\tret = get_tree_entry(&tree_oid, filename, oid,\n\t\t\t\t\t\t     &oc->mode);\n\t\t\t\tif (ret && only_to_die) {\n\t\t\t\t\tdiagnose_invalid_oid_path(prefix,\n\t\t\t\t\t\t\t\t   filename,\n\t\t\t\t\t\t\t\t   &tree_oid,\n\t\t\t\t\t\t\t\t   name, len);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flags & GET_OID_RECORD_PATH)\n\t\t\t\toc->path = xstrdup(filename);\n\n\t\t\tfree(new_filename);\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tif (only_to_die)\n\t\t\t\tdie(\"Invalid object name '%.*s'.\", len, name);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/*\n * Call this function when you know \"name\" given by the end user must\n * name an object but it doesn't; the function _may_ die with a better\n * diagnostic message than \"no such object 'name'\", e.g. \"Path 'doc' does not\n * exist in 'HEAD'\" when given \"HEAD:doc\", or it may return in which case\n * you have a chance to diagnose the error further.\n */\nvoid maybe_die_on_misspelt_object_name(const char *name, const char *prefix)\n{\n\tstruct object_context oc;\n\tstruct object_id oid;\n\tget_oid_with_context_1(name, GET_OID_ONLY_TO_DIE, prefix, &oid, &oc);\n}\n\nint get_oid_with_context(const char *str, unsigned flags, struct object_id *oid, struct object_context *oc)\n{\n\tif (flags & GET_OID_FOLLOW_SYMLINKS && flags & GET_OID_ONLY_TO_DIE)\n\t\tBUG(\"incompatible flags for get_sha1_with_context\");\n\treturn get_oid_with_context_1(str, flags, NULL, oid, oc);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "009faab4aefc34f55daf6fd7e6e63ec0f0ee108a",
  "sha1_ok": true,
  "size": 44296
}
