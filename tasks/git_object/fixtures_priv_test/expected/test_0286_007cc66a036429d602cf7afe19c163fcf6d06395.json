{
  "content": {
    "base64": "I2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgInN0cmluZy1saXN0LmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAidXRmOC5oIgojaW5jbHVkZSAibWFpbG1hcC5oIgojaW5jbHVkZSAic2hvcnRsb2cuaCIKI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCIKCnN0YXRpYyBjaGFyIGNvbnN0ICogY29uc3Qgc2hvcnRsb2dfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgc2hvcnRsb2cgWzxvcHRpb25zPl0gWzxyZXZpc2lvbi1yYW5nZT5dIFtbLS1dIFs8cGF0aD4uLi5dXSIpLAoJTlVMTAp9OwoKc3RhdGljIGludCBjb21wYXJlX2J5X251bWJlcihjb25zdCB2b2lkICphMSwgY29uc3Qgdm9pZCAqYTIpCnsKCWNvbnN0IHN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppMSA9IGExLCAqaTIgPSBhMjsKCWNvbnN0IHN0cnVjdCBzdHJpbmdfbGlzdCAqbDEgPSBpMS0+dXRpbCwgKmwyID0gaTItPnV0aWw7CgoJaWYgKGwxLT5uciA8IGwyLT5ucikKCQlyZXR1cm4gMTsKCWVsc2UgaWYgKGwxLT5uciA9PSBsMi0+bnIpCgkJcmV0dXJuIDA7CgllbHNlCgkJcmV0dXJuIC0xOwp9CgpzdGF0aWMgdm9pZCBpbnNlcnRfb25lX3JlY29yZChzdHJ1Y3Qgc2hvcnRsb2cgKmxvZywKCQkJICAgICAgY29uc3QgY2hhciAqYXV0aG9yLAoJCQkgICAgICBjb25zdCBjaGFyICpvbmVsaW5lKQp7Cgljb25zdCBjaGFyICpkb3QzID0gbG9nLT5jb21tb25fcmVwb19wcmVmaXg7CgljaGFyICpidWZmZXIsICpwOwoJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW07Cgljb25zdCBjaGFyICptYWlsYnVmLCAqbmFtZWJ1ZjsKCXNpemVfdCBuYW1lbGVuLCBtYWlsbGVuOwoJY29uc3QgY2hhciAqZW9sOwoJc3RydWN0IHN0cmJ1ZiBzdWJqZWN0ID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIG5hbWVtYWlsYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3QgaWRlbnRfc3BsaXQgaWRlbnQ7CgoJaWYgKHNwbGl0X2lkZW50X2xpbmUoJmlkZW50LCBhdXRob3IsIHN0cmxlbihhdXRob3IpKSkKCQlyZXR1cm47CgoJbmFtZWJ1ZiA9IGlkZW50Lm5hbWVfYmVnaW47CgltYWlsYnVmID0gaWRlbnQubWFpbF9iZWdpbjsKCW5hbWVsZW4gPSBpZGVudC5uYW1lX2VuZCAtIGlkZW50Lm5hbWVfYmVnaW47CgltYWlsbGVuID0gaWRlbnQubWFpbF9lbmQgLSBpZGVudC5tYWlsX2JlZ2luOwoKCW1hcF91c2VyKCZsb2ctPm1haWxtYXAsICZtYWlsYnVmLCAmbWFpbGxlbiwgJm5hbWVidWYsICZuYW1lbGVuKTsKCXN0cmJ1Zl9hZGQoJm5hbWVtYWlsYnVmLCBuYW1lYnVmLCBuYW1lbGVuKTsKCglpZiAobG9nLT5lbWFpbCkKCQlzdHJidWZfYWRkZigmbmFtZW1haWxidWYsICIgPCUuKnM+IiwgKGludCltYWlsbGVuLCBtYWlsYnVmKTsKCglpdGVtID0gc3RyaW5nX2xpc3RfaW5zZXJ0KCZsb2ctPmxpc3QsIG5hbWVtYWlsYnVmLmJ1Zik7CglpZiAoaXRlbS0+dXRpbCA9PSBOVUxMKQoJCWl0ZW0tPnV0aWwgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3Qgc3RyaW5nX2xpc3QpKTsKCgkvKiBTa2lwIGFueSBsZWFkaW5nIHdoaXRlc3BhY2UsIGluY2x1ZGluZyBhbnkgYmxhbmsgbGluZXMuICovCgl3aGlsZSAoKm9uZWxpbmUgJiYgaXNzcGFjZSgqb25lbGluZSkpCgkJb25lbGluZSsrOwoJZW9sID0gc3RyY2hyKG9uZWxpbmUsICdcbicpOwoJaWYgKCFlb2wpCgkJZW9sID0gb25lbGluZSArIHN0cmxlbihvbmVsaW5lKTsKCWlmIChzdGFydHNfd2l0aChvbmVsaW5lLCAiW1BBVENIIikpIHsKCQljaGFyICplb2IgPSBzdHJjaHIob25lbGluZSwgJ10nKTsKCQlpZiAoZW9iICYmICghZW9sIHx8IGVvYiA8IGVvbCkpCgkJCW9uZWxpbmUgPSBlb2IgKyAxOwoJfQoJd2hpbGUgKCpvbmVsaW5lICYmIGlzc3BhY2UoKm9uZWxpbmUpICYmICpvbmVsaW5lICE9ICdcbicpCgkJb25lbGluZSsrOwoJZm9ybWF0X3N1YmplY3QoJnN1YmplY3QsIG9uZWxpbmUsICIgIik7CglidWZmZXIgPSBzdHJidWZfZGV0YWNoKCZzdWJqZWN0LCBOVUxMKTsKCglpZiAoZG90MykgewoJCWludCBkb3QzbGVuID0gc3RybGVuKGRvdDMpOwoJCWlmIChkb3QzbGVuID4gNSkgewoJCQl3aGlsZSAoKHAgPSBzdHJzdHIoYnVmZmVyLCBkb3QzKSkgIT0gTlVMTCkgewoJCQkJaW50IHRhaWxsZW4gPSBzdHJsZW4ocCkgLSBkb3QzbGVuOwoJCQkJbWVtY3B5KHAsICIvLi4uLyIsIDUpOwoJCQkJbWVtbW92ZShwICsgNSwgcCArIGRvdDNsZW4sIHRhaWxsZW4gKyAxKTsKCQkJfQoJCX0KCX0KCglzdHJpbmdfbGlzdF9hcHBlbmQoaXRlbS0+dXRpbCwgYnVmZmVyKTsKfQoKc3RhdGljIHZvaWQgcmVhZF9mcm9tX3N0ZGluKHN0cnVjdCBzaG9ydGxvZyAqbG9nKQp7CgljaGFyIGF1dGhvclsxMDI0XSwgb25lbGluZVsxMDI0XTsKCgl3aGlsZSAoZmdldHMoYXV0aG9yLCBzaXplb2YoYXV0aG9yKSwgc3RkaW4pICE9IE5VTEwpIHsKCQlpZiAoIShhdXRob3JbMF0gPT0gJ0EnIHx8IGF1dGhvclswXSA9PSAnYScpIHx8CgkJICAgICFzdGFydHNfd2l0aChhdXRob3IgKyAxLCAidXRob3I6ICIpKQoJCQljb250aW51ZTsKCQl3aGlsZSAoZmdldHMob25lbGluZSwgc2l6ZW9mKG9uZWxpbmUpLCBzdGRpbikgJiYKCQkgICAgICAgb25lbGluZVswXSAhPSAnXG4nKQoJCQk7IC8qIGRpc2NhcmQgaGVhZGVycyAqLwoJCXdoaWxlIChmZ2V0cyhvbmVsaW5lLCBzaXplb2Yob25lbGluZSksIHN0ZGluKSAmJgoJCSAgICAgICBvbmVsaW5lWzBdID09ICdcbicpCgkJCTsgLyogZGlzY2FyZCBibGFua3MgKi8KCQlpbnNlcnRfb25lX3JlY29yZChsb2csIGF1dGhvciArIDgsIG9uZWxpbmUpOwoJfQp9Cgp2b2lkIHNob3J0bG9nX2FkZF9jb21taXQoc3RydWN0IHNob3J0bG9nICpsb2csIHN0cnVjdCBjb21taXQgKmNvbW1pdCkKewoJY29uc3QgY2hhciAqYXV0aG9yID0gTlVMTCwgKmJ1ZmZlcjsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIHVmYnVmID0gU1RSQlVGX0lOSVQ7CgoJcHBfY29tbWl0X2Vhc3koQ01JVF9GTVRfUkFXLCBjb21taXQsICZidWYpOwoJYnVmZmVyID0gYnVmLmJ1ZjsKCXdoaWxlICgqYnVmZmVyICYmICpidWZmZXIgIT0gJ1xuJykgewoJCWNvbnN0IGNoYXIgKmVvbCA9IHN0cmNocihidWZmZXIsICdcbicpOwoKCQlpZiAoZW9sID09IE5VTEwpCgkJCWVvbCA9IGJ1ZmZlciArIHN0cmxlbihidWZmZXIpOwoJCWVsc2UKCQkJZW9sKys7CgoJCWlmIChzdGFydHNfd2l0aChidWZmZXIsICJhdXRob3IgIikpCgkJCWF1dGhvciA9IGJ1ZmZlciArIDc7CgkJYnVmZmVyID0gZW9sOwoJfQoJaWYgKCFhdXRob3IpIHsKCQl3YXJuaW5nKF8oIk1pc3NpbmcgYXV0aG9yOiAlcyIpLAoJCSAgICBzaGExX3RvX2hleChjb21taXQtPm9iamVjdC5zaGExKSk7CgkJcmV0dXJuOwoJfQoJaWYgKGxvZy0+dXNlcl9mb3JtYXQpIHsKCQlzdHJ1Y3QgcHJldHR5X3ByaW50X2NvbnRleHQgY3R4ID0gezB9OwoJCWN0eC5mbXQgPSBDTUlUX0ZNVF9VU0VSRk9STUFUOwoJCWN0eC5hYmJyZXYgPSBsb2ctPmFiYnJldjsKCQljdHguc3ViamVjdCA9ICIiOwoJCWN0eC5hZnRlcl9zdWJqZWN0ID0gIiI7CgkJY3R4LmRhdGVfbW9kZS50eXBlID0gREFURV9OT1JNQUw7CgkJY3R4Lm91dHB1dF9lbmNvZGluZyA9IGdldF9sb2dfb3V0cHV0X2VuY29kaW5nKCk7CgkJcHJldHR5X3ByaW50X2NvbW1pdCgmY3R4LCBjb21taXQsICZ1ZmJ1Zik7CgkJYnVmZmVyID0gdWZidWYuYnVmOwoJfSBlbHNlIGlmICgqYnVmZmVyKSB7CgkJYnVmZmVyKys7Cgl9CglpbnNlcnRfb25lX3JlY29yZChsb2csIGF1dGhvciwgISpidWZmZXIgPyAiPG5vbmU+IiA6IGJ1ZmZlcik7CglzdHJidWZfcmVsZWFzZSgmdWZidWYpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7Cn0KCnN0YXRpYyB2b2lkIGdldF9mcm9tX3JldihzdHJ1Y3QgcmV2X2luZm8gKnJldiwgc3RydWN0IHNob3J0bG9nICpsb2cpCnsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCglpZiAocHJlcGFyZV9yZXZpc2lvbl93YWxrKHJldikpCgkJZGllKF8oInJldmlzaW9uIHdhbGsgc2V0dXAgZmFpbGVkIikpOwoJd2hpbGUgKChjb21taXQgPSBnZXRfcmV2aXNpb24ocmV2KSkgIT0gTlVMTCkKCQlzaG9ydGxvZ19hZGRfY29tbWl0KGxvZywgY29tbWl0KTsKfQoKc3RhdGljIGludCBwYXJzZV91aW50KGNoYXIgY29uc3QgKiphcmcsIGludCBjb21tYSwgaW50IGRlZnZhbCkKewoJdW5zaWduZWQgbG9uZyB1bDsKCWludCByZXQ7CgljaGFyICplbmRwOwoKCXVsID0gc3RydG91bCgqYXJnLCAmZW5kcCwgMTApOwoJaWYgKCplbmRwICYmICplbmRwICE9IGNvbW1hKQoJCXJldHVybiAtMTsKCWlmICh1bCA+IElOVF9NQVgpCgkJcmV0dXJuIC0xOwoJcmV0ID0gKmFyZyA9PSBlbmRwID8gZGVmdmFsIDogKGludCl1bDsKCSphcmcgPSAqZW5kcCA/IGVuZHAgKyAxIDogZW5kcDsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBjb25zdCBjaGFyIHdyYXBfYXJnX3VzYWdlW10gPSAiLXdbPHdpZHRoPlssPGluZGVudDE+Wyw8aW5kZW50Mj5dXV0iOwojZGVmaW5lIERFRkFVTFRfV1JBUExFTiA3NgojZGVmaW5lIERFRkFVTFRfSU5ERU5UMSA2CiNkZWZpbmUgREVGQVVMVF9JTkRFTlQyIDkKCnN0YXRpYyBpbnQgcGFyc2Vfd3JhcF9hcmdzKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCXN0cnVjdCBzaG9ydGxvZyAqbG9nID0gb3B0LT52YWx1ZTsKCglsb2ctPndyYXBfbGluZXMgPSAhdW5zZXQ7CglpZiAodW5zZXQpCgkJcmV0dXJuIDA7CglpZiAoIWFyZykgewoJCWxvZy0+d3JhcCA9IERFRkFVTFRfV1JBUExFTjsKCQlsb2ctPmluMSA9IERFRkFVTFRfSU5ERU5UMTsKCQlsb2ctPmluMiA9IERFRkFVTFRfSU5ERU5UMjsKCQlyZXR1cm4gMDsKCX0KCglsb2ctPndyYXAgPSBwYXJzZV91aW50KCZhcmcsICcsJywgREVGQVVMVF9XUkFQTEVOKTsKCWxvZy0+aW4xID0gcGFyc2VfdWludCgmYXJnLCAnLCcsIERFRkFVTFRfSU5ERU5UMSk7Cglsb2ctPmluMiA9IHBhcnNlX3VpbnQoJmFyZywgJ1wwJywgREVGQVVMVF9JTkRFTlQyKTsKCWlmIChsb2ctPndyYXAgPCAwIHx8IGxvZy0+aW4xIDwgMCB8fCBsb2ctPmluMiA8IDApCgkJcmV0dXJuIGVycm9yKHdyYXBfYXJnX3VzYWdlKTsKCWlmIChsb2ctPndyYXAgJiYKCSAgICAoKGxvZy0+aW4xICYmIGxvZy0+d3JhcCA8PSBsb2ctPmluMSkgfHwKCSAgICAgKGxvZy0+aW4yICYmIGxvZy0+d3JhcCA8PSBsb2ctPmluMikpKQoJCXJldHVybiBlcnJvcih3cmFwX2FyZ191c2FnZSk7CglyZXR1cm4gMDsKfQoKdm9pZCBzaG9ydGxvZ19pbml0KHN0cnVjdCBzaG9ydGxvZyAqbG9nKQp7CgltZW1zZXQobG9nLCAwLCBzaXplb2YoKmxvZykpOwoKCXJlYWRfbWFpbG1hcCgmbG9nLT5tYWlsbWFwLCAmbG9nLT5jb21tb25fcmVwb19wcmVmaXgpOwoKCWxvZy0+bGlzdC5zdHJkdXBfc3RyaW5ncyA9IDE7Cglsb2ctPndyYXAgPSBERUZBVUxUX1dSQVBMRU47Cglsb2ctPmluMSA9IERFRkFVTFRfSU5ERU5UMTsKCWxvZy0+aW4yID0gREVGQVVMVF9JTkRFTlQyOwp9CgppbnQgY21kX3Nob3J0bG9nKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdGF0aWMgc3RydWN0IHNob3J0bG9nIGxvZzsKCXN0YXRpYyBzdHJ1Y3QgcmV2X2luZm8gcmV2OwoJaW50IG5vbmdpdCA9ICFzdGFydHVwX2luZm8tPmhhdmVfcmVwb3NpdG9yeTsKCglzdGF0aWMgY29uc3Qgc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJT1BUX0JPT0woJ24nLCAibnVtYmVyZWQiLCAmbG9nLnNvcnRfYnlfbnVtYmVyLAoJCQkgTl8oInNvcnQgb3V0cHV0IGFjY29yZGluZyB0byB0aGUgbnVtYmVyIG9mIGNvbW1pdHMgcGVyIGF1dGhvciIpKSwKCQlPUFRfQk9PTCgncycsICJzdW1tYXJ5IiwgJmxvZy5zdW1tYXJ5LAoJCQkgTl8oIlN1cHByZXNzIGNvbW1pdCBkZXNjcmlwdGlvbnMsIG9ubHkgcHJvdmlkZXMgY29tbWl0IGNvdW50IikpLAoJCU9QVF9CT09MKCdlJywgImVtYWlsIiwgJmxvZy5lbWFpbCwKCQkJIE5fKCJTaG93IHRoZSBlbWFpbCBhZGRyZXNzIG9mIGVhY2ggYXV0aG9yIikpLAoJCXsgT1BUSU9OX0NBTExCQUNLLCAndycsIE5VTEwsICZsb2csIE5fKCJ3WyxpMVssaTJdXSIpLAoJCQlOXygiTGluZXdyYXAgb3V0cHV0IiksIFBBUlNFX09QVF9PUFRBUkcsICZwYXJzZV93cmFwX2FyZ3MgfSwKCQlPUFRfRU5EKCksCgl9OwoKCXN0cnVjdCBwYXJzZV9vcHRfY3R4X3QgY3R4OwoKCWdpdF9jb25maWcoZ2l0X2RlZmF1bHRfY29uZmlnLCBOVUxMKTsKCXNob3J0bG9nX2luaXQoJmxvZyk7Cglpbml0X3JldmlzaW9ucygmcmV2LCBwcmVmaXgpOwoJcGFyc2Vfb3B0aW9uc19zdGFydCgmY3R4LCBhcmdjLCBhcmd2LCBwcmVmaXgsIG9wdGlvbnMsCgkJCSAgICBQQVJTRV9PUFRfS0VFUF9EQVNIREFTSCB8IFBBUlNFX09QVF9LRUVQX0FSR1YwKTsKCglmb3IgKDs7KSB7CgkJc3dpdGNoIChwYXJzZV9vcHRpb25zX3N0ZXAoJmN0eCwgb3B0aW9ucywgc2hvcnRsb2dfdXNhZ2UpKSB7CgkJY2FzZSBQQVJTRV9PUFRfSEVMUDoKCQkJZXhpdCgxMjkpOwoJCWNhc2UgUEFSU0VfT1BUX0RPTkU6CgkJCWdvdG8gcGFyc2VfZG9uZTsKCQl9CgkJcGFyc2VfcmV2aXNpb25fb3B0KCZyZXYsICZjdHgsIG9wdGlvbnMsIHNob3J0bG9nX3VzYWdlKTsKCX0KcGFyc2VfZG9uZToKCWFyZ2MgPSBwYXJzZV9vcHRpb25zX2VuZCgmY3R4KTsKCglpZiAoc2V0dXBfcmV2aXNpb25zKGFyZ2MsIGFyZ3YsICZyZXYsIE5VTEwpICE9IDEpIHsKCQllcnJvcihfKCJ1bnJlY29nbml6ZWQgYXJndW1lbnQ6ICVzIiksIGFyZ3ZbMV0pOwoJCXVzYWdlX3dpdGhfb3B0aW9ucyhzaG9ydGxvZ191c2FnZSwgb3B0aW9ucyk7Cgl9CgoJbG9nLnVzZXJfZm9ybWF0ID0gcmV2LmNvbW1pdF9mb3JtYXQgPT0gQ01JVF9GTVRfVVNFUkZPUk1BVDsKCWxvZy5hYmJyZXYgPSByZXYuYWJicmV2OwoKCS8qIGFzc3VtZSBIRUFEIGlmIGZyb20gYSB0dHkgKi8KCWlmICghbm9uZ2l0ICYmICFyZXYucGVuZGluZy5uciAmJiBpc2F0dHkoMCkpCgkJYWRkX2hlYWRfdG9fcGVuZGluZygmcmV2KTsKCWlmIChyZXYucGVuZGluZy5uciA9PSAwKSB7CgkJaWYgKGlzYXR0eSgwKSkKCQkJZnByaW50ZihzdGRlcnIsIF8oIihyZWFkaW5nIGxvZyBtZXNzYWdlIGZyb20gc3RhbmRhcmQgaW5wdXQpXG4iKSk7CgkJcmVhZF9mcm9tX3N0ZGluKCZsb2cpOwoJfQoJZWxzZQoJCWdldF9mcm9tX3JldigmcmV2LCAmbG9nKTsKCglzaG9ydGxvZ19vdXRwdXQoJmxvZyk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgYWRkX3dyYXBwZWRfc2hvcnRsb2dfbXNnKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpzLAoJCQkJICAgICBjb25zdCBzdHJ1Y3Qgc2hvcnRsb2cgKmxvZykKewoJc3RyYnVmX2FkZF93cmFwcGVkX3RleHQoc2IsIHMsIGxvZy0+aW4xLCBsb2ctPmluMiwgbG9nLT53cmFwKTsKCXN0cmJ1Zl9hZGRjaChzYiwgJ1xuJyk7Cn0KCnZvaWQgc2hvcnRsb2dfb3V0cHV0KHN0cnVjdCBzaG9ydGxvZyAqbG9nKQp7CglpbnQgaSwgajsKCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCglpZiAobG9nLT5zb3J0X2J5X251bWJlcikKCQlxc29ydChsb2ctPmxpc3QuaXRlbXMsIGxvZy0+bGlzdC5uciwgc2l6ZW9mKHN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtKSwKCQkJY29tcGFyZV9ieV9udW1iZXIpOwoJZm9yIChpID0gMDsgaSA8IGxvZy0+bGlzdC5ucjsgaSsrKSB7CgkJc3RydWN0IHN0cmluZ19saXN0ICpvbmVsaW5lcyA9IGxvZy0+bGlzdC5pdGVtc1tpXS51dGlsOwoKCQlpZiAobG9nLT5zdW1tYXJ5KSB7CgkJCXByaW50ZigiJTZkXHQlc1xuIiwgb25lbGluZXMtPm5yLCBsb2ctPmxpc3QuaXRlbXNbaV0uc3RyaW5nKTsKCQl9IGVsc2UgewoJCQlwcmludGYoIiVzICglZCk6XG4iLCBsb2ctPmxpc3QuaXRlbXNbaV0uc3RyaW5nLCBvbmVsaW5lcy0+bnIpOwoJCQlmb3IgKGogPSBvbmVsaW5lcy0+bnIgLSAxOyBqID49IDA7IGotLSkgewoJCQkJY29uc3QgY2hhciAqbXNnID0gb25lbGluZXMtPml0ZW1zW2pdLnN0cmluZzsKCgkJCQlpZiAobG9nLT53cmFwX2xpbmVzKSB7CgkJCQkJc3RyYnVmX3Jlc2V0KCZzYik7CgkJCQkJYWRkX3dyYXBwZWRfc2hvcnRsb2dfbXNnKCZzYiwgbXNnLCBsb2cpOwoJCQkJCWZ3cml0ZShzYi5idWYsIHNiLmxlbiwgMSwgc3Rkb3V0KTsKCQkJCX0KCQkJCWVsc2UKCQkJCQlwcmludGYoIiAgICAgICVzXG4iLCBtc2cpOwoJCQl9CgkJCXB1dGNoYXIoJ1xuJyk7CgkJfQoKCQlvbmVsaW5lcy0+c3RyZHVwX3N0cmluZ3MgPSAxOwoJCXN0cmluZ19saXN0X2NsZWFyKG9uZWxpbmVzLCAwKTsKCQlmcmVlKG9uZWxpbmVzKTsKCQlsb2ctPmxpc3QuaXRlbXNbaV0udXRpbCA9IE5VTEw7Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCWxvZy0+bGlzdC5zdHJkdXBfc3RyaW5ncyA9IDE7CglzdHJpbmdfbGlzdF9jbGVhcigmbG9nLT5saXN0LCAxKTsKCWNsZWFyX21haWxtYXAoJmxvZy0+bWFpbG1hcCk7Cn0K",
    "text": "#include \"builtin.h\"\n#include \"cache.h\"\n#include \"commit.h\"\n#include \"diff.h\"\n#include \"string-list.h\"\n#include \"revision.h\"\n#include \"utf8.h\"\n#include \"mailmap.h\"\n#include \"shortlog.h\"\n#include \"parse-options.h\"\n\nstatic char const * const shortlog_usage[] = {\n\tN_(\"git shortlog [<options>] [<revision-range>] [[--] [<path>...]]\"),\n\tNULL\n};\n\nstatic int compare_by_number(const void *a1, const void *a2)\n{\n\tconst struct string_list_item *i1 = a1, *i2 = a2;\n\tconst struct string_list *l1 = i1->util, *l2 = i2->util;\n\n\tif (l1->nr < l2->nr)\n\t\treturn 1;\n\telse if (l1->nr == l2->nr)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}\n\nstatic void insert_one_record(struct shortlog *log,\n\t\t\t      const char *author,\n\t\t\t      const char *oneline)\n{\n\tconst char *dot3 = log->common_repo_prefix;\n\tchar *buffer, *p;\n\tstruct string_list_item *item;\n\tconst char *mailbuf, *namebuf;\n\tsize_t namelen, maillen;\n\tconst char *eol;\n\tstruct strbuf subject = STRBUF_INIT;\n\tstruct strbuf namemailbuf = STRBUF_INIT;\n\tstruct ident_split ident;\n\n\tif (split_ident_line(&ident, author, strlen(author)))\n\t\treturn;\n\n\tnamebuf = ident.name_begin;\n\tmailbuf = ident.mail_begin;\n\tnamelen = ident.name_end - ident.name_begin;\n\tmaillen = ident.mail_end - ident.mail_begin;\n\n\tmap_user(&log->mailmap, &mailbuf, &maillen, &namebuf, &namelen);\n\tstrbuf_add(&namemailbuf, namebuf, namelen);\n\n\tif (log->email)\n\t\tstrbuf_addf(&namemailbuf, \" <%.*s>\", (int)maillen, mailbuf);\n\n\titem = string_list_insert(&log->list, namemailbuf.buf);\n\tif (item->util == NULL)\n\t\titem->util = xcalloc(1, sizeof(struct string_list));\n\n\t/* Skip any leading whitespace, including any blank lines. */\n\twhile (*oneline && isspace(*oneline))\n\t\toneline++;\n\teol = strchr(oneline, '\\n');\n\tif (!eol)\n\t\teol = oneline + strlen(oneline);\n\tif (starts_with(oneline, \"[PATCH\")) {\n\t\tchar *eob = strchr(oneline, ']');\n\t\tif (eob && (!eol || eob < eol))\n\t\t\toneline = eob + 1;\n\t}\n\twhile (*oneline && isspace(*oneline) && *oneline != '\\n')\n\t\toneline++;\n\tformat_subject(&subject, oneline, \" \");\n\tbuffer = strbuf_detach(&subject, NULL);\n\n\tif (dot3) {\n\t\tint dot3len = strlen(dot3);\n\t\tif (dot3len > 5) {\n\t\t\twhile ((p = strstr(buffer, dot3)) != NULL) {\n\t\t\t\tint taillen = strlen(p) - dot3len;\n\t\t\t\tmemcpy(p, \"/.../\", 5);\n\t\t\t\tmemmove(p + 5, p + dot3len, taillen + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tstring_list_append(item->util, buffer);\n}\n\nstatic void read_from_stdin(struct shortlog *log)\n{\n\tchar author[1024], oneline[1024];\n\n\twhile (fgets(author, sizeof(author), stdin) != NULL) {\n\t\tif (!(author[0] == 'A' || author[0] == 'a') ||\n\t\t    !starts_with(author + 1, \"uthor: \"))\n\t\t\tcontinue;\n\t\twhile (fgets(oneline, sizeof(oneline), stdin) &&\n\t\t       oneline[0] != '\\n')\n\t\t\t; /* discard headers */\n\t\twhile (fgets(oneline, sizeof(oneline), stdin) &&\n\t\t       oneline[0] == '\\n')\n\t\t\t; /* discard blanks */\n\t\tinsert_one_record(log, author + 8, oneline);\n\t}\n}\n\nvoid shortlog_add_commit(struct shortlog *log, struct commit *commit)\n{\n\tconst char *author = NULL, *buffer;\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf ufbuf = STRBUF_INIT;\n\n\tpp_commit_easy(CMIT_FMT_RAW, commit, &buf);\n\tbuffer = buf.buf;\n\twhile (*buffer && *buffer != '\\n') {\n\t\tconst char *eol = strchr(buffer, '\\n');\n\n\t\tif (eol == NULL)\n\t\t\teol = buffer + strlen(buffer);\n\t\telse\n\t\t\teol++;\n\n\t\tif (starts_with(buffer, \"author \"))\n\t\t\tauthor = buffer + 7;\n\t\tbuffer = eol;\n\t}\n\tif (!author) {\n\t\twarning(_(\"Missing author: %s\"),\n\t\t    sha1_to_hex(commit->object.sha1));\n\t\treturn;\n\t}\n\tif (log->user_format) {\n\t\tstruct pretty_print_context ctx = {0};\n\t\tctx.fmt = CMIT_FMT_USERFORMAT;\n\t\tctx.abbrev = log->abbrev;\n\t\tctx.subject = \"\";\n\t\tctx.after_subject = \"\";\n\t\tctx.date_mode.type = DATE_NORMAL;\n\t\tctx.output_encoding = get_log_output_encoding();\n\t\tpretty_print_commit(&ctx, commit, &ufbuf);\n\t\tbuffer = ufbuf.buf;\n\t} else if (*buffer) {\n\t\tbuffer++;\n\t}\n\tinsert_one_record(log, author, !*buffer ? \"<none>\" : buffer);\n\tstrbuf_release(&ufbuf);\n\tstrbuf_release(&buf);\n}\n\nstatic void get_from_rev(struct rev_info *rev, struct shortlog *log)\n{\n\tstruct commit *commit;\n\n\tif (prepare_revision_walk(rev))\n\t\tdie(_(\"revision walk setup failed\"));\n\twhile ((commit = get_revision(rev)) != NULL)\n\t\tshortlog_add_commit(log, commit);\n}\n\nstatic int parse_uint(char const **arg, int comma, int defval)\n{\n\tunsigned long ul;\n\tint ret;\n\tchar *endp;\n\n\tul = strtoul(*arg, &endp, 10);\n\tif (*endp && *endp != comma)\n\t\treturn -1;\n\tif (ul > INT_MAX)\n\t\treturn -1;\n\tret = *arg == endp ? defval : (int)ul;\n\t*arg = *endp ? endp + 1 : endp;\n\treturn ret;\n}\n\nstatic const char wrap_arg_usage[] = \"-w[<width>[,<indent1>[,<indent2>]]]\";\n#define DEFAULT_WRAPLEN 76\n#define DEFAULT_INDENT1 6\n#define DEFAULT_INDENT2 9\n\nstatic int parse_wrap_args(const struct option *opt, const char *arg, int unset)\n{\n\tstruct shortlog *log = opt->value;\n\n\tlog->wrap_lines = !unset;\n\tif (unset)\n\t\treturn 0;\n\tif (!arg) {\n\t\tlog->wrap = DEFAULT_WRAPLEN;\n\t\tlog->in1 = DEFAULT_INDENT1;\n\t\tlog->in2 = DEFAULT_INDENT2;\n\t\treturn 0;\n\t}\n\n\tlog->wrap = parse_uint(&arg, ',', DEFAULT_WRAPLEN);\n\tlog->in1 = parse_uint(&arg, ',', DEFAULT_INDENT1);\n\tlog->in2 = parse_uint(&arg, '\\0', DEFAULT_INDENT2);\n\tif (log->wrap < 0 || log->in1 < 0 || log->in2 < 0)\n\t\treturn error(wrap_arg_usage);\n\tif (log->wrap &&\n\t    ((log->in1 && log->wrap <= log->in1) ||\n\t     (log->in2 && log->wrap <= log->in2)))\n\t\treturn error(wrap_arg_usage);\n\treturn 0;\n}\n\nvoid shortlog_init(struct shortlog *log)\n{\n\tmemset(log, 0, sizeof(*log));\n\n\tread_mailmap(&log->mailmap, &log->common_repo_prefix);\n\n\tlog->list.strdup_strings = 1;\n\tlog->wrap = DEFAULT_WRAPLEN;\n\tlog->in1 = DEFAULT_INDENT1;\n\tlog->in2 = DEFAULT_INDENT2;\n}\n\nint cmd_shortlog(int argc, const char **argv, const char *prefix)\n{\n\tstatic struct shortlog log;\n\tstatic struct rev_info rev;\n\tint nongit = !startup_info->have_repository;\n\n\tstatic const struct option options[] = {\n\t\tOPT_BOOL('n', \"numbered\", &log.sort_by_number,\n\t\t\t N_(\"sort output according to the number of commits per author\")),\n\t\tOPT_BOOL('s', \"summary\", &log.summary,\n\t\t\t N_(\"Suppress commit descriptions, only provides commit count\")),\n\t\tOPT_BOOL('e', \"email\", &log.email,\n\t\t\t N_(\"Show the email address of each author\")),\n\t\t{ OPTION_CALLBACK, 'w', NULL, &log, N_(\"w[,i1[,i2]]\"),\n\t\t\tN_(\"Linewrap output\"), PARSE_OPT_OPTARG, &parse_wrap_args },\n\t\tOPT_END(),\n\t};\n\n\tstruct parse_opt_ctx_t ctx;\n\n\tgit_config(git_default_config, NULL);\n\tshortlog_init(&log);\n\tinit_revisions(&rev, prefix);\n\tparse_options_start(&ctx, argc, argv, prefix, options,\n\t\t\t    PARSE_OPT_KEEP_DASHDASH | PARSE_OPT_KEEP_ARGV0);\n\n\tfor (;;) {\n\t\tswitch (parse_options_step(&ctx, options, shortlog_usage)) {\n\t\tcase PARSE_OPT_HELP:\n\t\t\texit(129);\n\t\tcase PARSE_OPT_DONE:\n\t\t\tgoto parse_done;\n\t\t}\n\t\tparse_revision_opt(&rev, &ctx, options, shortlog_usage);\n\t}\nparse_done:\n\targc = parse_options_end(&ctx);\n\n\tif (setup_revisions(argc, argv, &rev, NULL) != 1) {\n\t\terror(_(\"unrecognized argument: %s\"), argv[1]);\n\t\tusage_with_options(shortlog_usage, options);\n\t}\n\n\tlog.user_format = rev.commit_format == CMIT_FMT_USERFORMAT;\n\tlog.abbrev = rev.abbrev;\n\n\t/* assume HEAD if from a tty */\n\tif (!nongit && !rev.pending.nr && isatty(0))\n\t\tadd_head_to_pending(&rev);\n\tif (rev.pending.nr == 0) {\n\t\tif (isatty(0))\n\t\t\tfprintf(stderr, _(\"(reading log message from standard input)\\n\"));\n\t\tread_from_stdin(&log);\n\t}\n\telse\n\t\tget_from_rev(&rev, &log);\n\n\tshortlog_output(&log);\n\treturn 0;\n}\n\nstatic void add_wrapped_shortlog_msg(struct strbuf *sb, const char *s,\n\t\t\t\t     const struct shortlog *log)\n{\n\tstrbuf_add_wrapped_text(sb, s, log->in1, log->in2, log->wrap);\n\tstrbuf_addch(sb, '\\n');\n}\n\nvoid shortlog_output(struct shortlog *log)\n{\n\tint i, j;\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tif (log->sort_by_number)\n\t\tqsort(log->list.items, log->list.nr, sizeof(struct string_list_item),\n\t\t\tcompare_by_number);\n\tfor (i = 0; i < log->list.nr; i++) {\n\t\tstruct string_list *onelines = log->list.items[i].util;\n\n\t\tif (log->summary) {\n\t\t\tprintf(\"%6d\\t%s\\n\", onelines->nr, log->list.items[i].string);\n\t\t} else {\n\t\t\tprintf(\"%s (%d):\\n\", log->list.items[i].string, onelines->nr);\n\t\t\tfor (j = onelines->nr - 1; j >= 0; j--) {\n\t\t\t\tconst char *msg = onelines->items[j].string;\n\n\t\t\t\tif (log->wrap_lines) {\n\t\t\t\t\tstrbuf_reset(&sb);\n\t\t\t\t\tadd_wrapped_shortlog_msg(&sb, msg, log);\n\t\t\t\t\tfwrite(sb.buf, sb.len, 1, stdout);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tprintf(\"      %s\\n\", msg);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\n\t\tonelines->strdup_strings = 1;\n\t\tstring_list_clear(onelines, 0);\n\t\tfree(onelines);\n\t\tlog->list.items[i].util = NULL;\n\t}\n\n\tstrbuf_release(&sb);\n\tlog->list.strdup_strings = 1;\n\tstring_list_clear(&log->list, 1);\n\tclear_mailmap(&log->mailmap);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "007cc66a036429d602cf7afe19c163fcf6d06395",
  "sha1_ok": true,
  "size": 8505
}
