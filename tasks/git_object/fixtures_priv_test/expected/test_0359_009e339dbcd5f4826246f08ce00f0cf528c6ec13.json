{
  "content": {
    "base64": "Q29yZSBHSVQgVGVzdHMKPT09PT09PT09PT09PT0KClRoaXMgZGlyZWN0b3J5IGhvbGRzIG1hbnkgdGVzdCBzY3JpcHRzIGZvciBjb3JlIEdJVCB0b29scy4gIFRoZQpmaXJzdCBwYXJ0IG9mIHRoaXMgc2hvcnQgZG9jdW1lbnQgZGVzY3JpYmVzIGhvdyB0byBydW4gdGhlIHRlc3RzCmFuZCByZWFkIHRoZWlyIG91dHB1dC4KCldoZW4gZml4aW5nIHRoZSB0b29scyBvciBhZGRpbmcgZW5oYW5jZW1lbnRzLCB5b3UgYXJlIHN0cm9uZ2x5CmVuY291cmFnZWQgdG8gYWRkIHRlc3RzIGluIHRoaXMgZGlyZWN0b3J5IHRvIGNvdmVyIHdoYXQgeW91IGFyZQp0cnlpbmcgdG8gZml4IG9yIGVuaGFuY2UuICBUaGUgbGF0ZXIgcGFydCBvZiB0aGlzIHNob3J0IGRvY3VtZW50CmRlc2NyaWJlcyBob3cgeW91ciB0ZXN0IHNjcmlwdHMgc2hvdWxkIGJlIG9yZ2FuaXplZC4KCgpSdW5uaW5nIFRlc3RzCi0tLS0tLS0tLS0tLS0KClRoZSBlYXNpZXN0IHdheSB0byBydW4gdGVzdHMgaXMgdG8gc2F5ICJtYWtlIi4gIFRoaXMgcnVucyBhbGwKdGhlIHRlc3RzLgoKICAgICoqKiB0MDAwMC1iYXNpYy5zaCAqKioKICAgIG9rIDEgLSAuZ2l0L29iamVjdHMgc2hvdWxkIGJlIGVtcHR5IGFmdGVyIGdpdCBpbml0IGluIGFuIGVtcHR5IHJlcG8uCiAgICBvayAyIC0gLmdpdC9vYmplY3RzIHNob3VsZCBoYXZlIDMgc3ViZGlyZWN0b3JpZXMuCiAgICBvayAzIC0gc3VjY2VzcyBpcyByZXBvcnRlZCBsaWtlIHRoaXMKICAgIC4uLgogICAgb2sgNDMgLSB2ZXJ5IGxvbmcgbmFtZSBpbiB0aGUgaW5kZXggaGFuZGxlZCBzYW5lbHkKICAgICMgZml4ZWQgMSBrbm93biBicmVha2FnZShzKQogICAgIyBzdGlsbCBoYXZlIDEga25vd24gYnJlYWthZ2UocykKICAgICMgcGFzc2VkIGFsbCByZW1haW5pbmcgNDIgdGVzdChzKQogICAgMS4uNDMKICAgICoqKiB0MDAwMS1pbml0LnNoICoqKgogICAgb2sgMSAtIHBsYWluCiAgICBvayAyIC0gcGxhaW4gd2l0aCBHSVRfV09SS19UUkVFCiAgICBvayAzIC0gcGxhaW4gYmFyZQoKU2luY2UgdGhlIHRlc3RzIGFsbCBvdXRwdXQgVEFQIChzZWUgaHR0cDovL3Rlc3Rhbnl0aGluZy5vcmcpIHRoZXkgY2FuCmJlIHJ1biB3aXRoIGFueSBUQVAgaGFybmVzcy4gSGVyZSdzIGFuIGV4YW1wbGUgb2YgcGFyYWxsZWwgdGVzdGluZwpwb3dlcmVkIGJ5IGEgcmVjZW50IHZlcnNpb24gb2YgcHJvdmUoMSk6CgogICAgJCBwcm92ZSAtLXRpbWVyIC0tam9icyAxNSAuL3RbMC05XSouc2gKICAgIFsxOToxNzozM10gLi90MDAwNS1zaWduYWxzLnNoIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uIG9rICAgICAgIDM2IG1zCiAgICBbMTk6MTc6MzNdIC4vdDAwMjItY3JsZi1yZW5hbWUuc2ggLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiBvayAgICAgICA2OSBtcwogICAgWzE5OjE3OjMzXSAuL3QwMDI0LWNybGYtYXJjaGl2ZS5zaCAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gb2sgICAgICAxNTQgbXMKICAgIFsxOToxNzozM10gLi90MDAwNC11bndyaXRhYmxlLnNoIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uIG9rICAgICAgMjg5IG1zCiAgICBbMTk6MTc6MzNdIC4vdDAwMDItZ2l0ZmlsZS5zaCAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiBvayAgICAgIDQ4MCBtcwogICAgPT09KCAgICAgMTAyOzAgIDI1Lz8gIDYvPyAgNS8/ICAxNi8/ICAxLz8gIDQvPyAgMi8/ICAxLz8gIDMvPyAgMS4uLiApPT09Cgpwcm92ZSBhbmQgb3RoZXIgaGFybmVzc2VzIGNvbWUgd2l0aCBhIGxvdCBvZiB1c2VmdWwgb3B0aW9ucy4gVGhlCi0tc3RhdGUgb3B0aW9uIGluIHBhcnRpY3VsYXIgaXMgdmVyeSB1c2VmdWw6CgogICAgIyBSZXBlYXQgdW50aWwgbm8gbW9yZSBmYWlsdXJlcwogICAgJCBwcm92ZSAtaiAxNSAtLXN0YXRlPWZhaWxlZCxzYXZlIC4vdFswLTldKi5zaAoKWW91IGNhbiBnaXZlIERFRkFVTFRfVEVTVF9UQVJHRVQ9cHJvdmUgb24gdGhlIG1ha2UgY29tbWFuZCAob3IgZGVmaW5lIGl0CmluIGNvbmZpZy5tYWspIHRvIGNhdXNlICJtYWtlIHRlc3QiIHRvIHJ1biB0ZXN0cyB1bmRlciBwcm92ZS4KR0lUX1BST1ZFX09QVFMgY2FuIGJlIHVzZWQgdG8gcGFzcyBhZGRpdGlvbmFsIG9wdGlvbnMsIGUuZy4KCiAgICAkIG1ha2UgREVGQVVMVF9URVNUX1RBUkdFVD1wcm92ZSBHSVRfUFJPVkVfT1BUUz0nLS10aW1lciAtLWpvYnMgMTYnIHRlc3QKCllvdSBjYW4gYWxzbyBydW4gZWFjaCB0ZXN0IGluZGl2aWR1YWxseSBmcm9tIGNvbW1hbmQgbGluZSwgbGlrZSB0aGlzOgoKICAgICQgc2ggLi90MzAxMC1scy1maWxlcy1raWxsZWQtbW9kaWZpZWQuc2gKICAgIG9rIDEgLSBnaXQgdXBkYXRlLWluZGV4IC0tYWRkIHRvIGFkZCB2YXJpb3VzIHBhdGhzLgogICAgb2sgMiAtIGdpdCBscy1maWxlcyAtayB0byBzaG93IGtpbGxlZCBmaWxlcy4KICAgIG9rIDMgLSB2YWxpZGF0ZSBnaXQgbHMtZmlsZXMgLWsgb3V0cHV0LgogICAgb2sgNCAtIGdpdCBscy1maWxlcyAtbSB0byBzaG93IG1vZGlmaWVkIGZpbGVzLgogICAgb2sgNSAtIHZhbGlkYXRlIGdpdCBscy1maWxlcyAtbSBvdXRwdXQuCiAgICAjIHBhc3NlZCBhbGwgNSB0ZXN0KHMpCiAgICAxLi41CgpZb3UgY2FuIHBhc3MgLS12ZXJib3NlIChvciAtdiksIC0tZGVidWcgKG9yIC1kKSwgYW5kIC0taW1tZWRpYXRlCihvciAtaSkgY29tbWFuZCBsaW5lIGFyZ3VtZW50IHRvIHRoZSB0ZXN0LCBvciBieSBzZXR0aW5nIEdJVF9URVNUX09QVFMKYXBwcm9wcmlhdGVseSBiZWZvcmUgcnVubmluZyAibWFrZSIuCgotdjo6Ci0tdmVyYm9zZTo6CglUaGlzIG1ha2VzIHRoZSB0ZXN0IG1vcmUgdmVyYm9zZS4gIFNwZWNpZmljYWxseSwgdGhlCgljb21tYW5kIGJlaW5nIHJ1biBhbmQgdGhlaXIgb3V0cHV0IGlmIGFueSBhcmUgYWxzbwoJb3V0cHV0LgoKLS12ZXJib3NlLW9ubHk9PHBhdHRlcm4+OjoKCUxpa2UgLS12ZXJib3NlLCBidXQgdGhlIGVmZmVjdCBpcyBsaW1pdGVkIHRvIHRlc3RzIHdpdGgKCW51bWJlcnMgbWF0Y2hpbmcgPHBhdHRlcm4+LiAgVGhlIG51bWJlciBtYXRjaGVkIGFnYWluc3QgaXMKCXNpbXBseSB0aGUgcnVubmluZyBjb3VudCBvZiB0aGUgdGVzdCB3aXRoaW4gdGhlIGZpbGUuCgoteDo6CglUdXJuIG9uIHNoZWxsIHRyYWNpbmcgKGkuZS4sIGBzZXQgLXhgKSBkdXJpbmcgdGhlIHRlc3RzCgl0aGVtc2VsdmVzLiBJbXBsaWVzIGAtLXZlcmJvc2VgLiBOb3RlIHRoYXQgaW4gbm9uLWJhc2ggc2hlbGxzLAoJdGhpcyBjYW4gY2F1c2UgZmFpbHVyZXMgaW4gc29tZSB0ZXN0cyB3aGljaCByZWRpcmVjdCBhbmQgdGVzdAoJdGhlIG91dHB1dCBvZiBzaGVsbCBmdW5jdGlvbnMuIFVzZSB3aXRoIGNhdXRpb24uCgotZDo6Ci0tZGVidWc6OgoJVGhpcyBtYXkgaGVscCB0aGUgcGVyc29uIHdobyBpcyBkZXZlbG9waW5nIGEgbmV3IHRlc3QuCglJdCBjYXVzZXMgdGhlIGNvbW1hbmQgZGVmaW5lZCB3aXRoIHRlc3RfZGVidWcgdG8gcnVuLgoJVGhlICJ0cmFzaCIgZGlyZWN0b3J5ICh1c2VkIHRvIHN0b3JlIGFsbCB0ZW1wb3JhcnkgZGF0YQoJZHVyaW5nIHRlc3RpbmcpIGlzIG5vdCBkZWxldGVkIGV2ZW4gaWYgdGhlcmUgYXJlIG5vCglmYWlsZWQgdGVzdHMgc28gdGhhdCB5b3UgY2FuIGluc3BlY3QgaXRzIGNvbnRlbnRzIGFmdGVyCgl0aGUgdGVzdCBmaW5pc2hlZC4KCi1pOjoKLS1pbW1lZGlhdGU6OgoJVGhpcyBjYXVzZXMgdGhlIHRlc3QgdG8gaW1tZWRpYXRlbHkgZXhpdCB1cG9uIHRoZSBmaXJzdAoJZmFpbGVkIHRlc3QuIENsZWFudXAgY29tbWFuZHMgcmVxdWVzdGVkIHdpdGgKCXRlc3Rfd2hlbl9maW5pc2hlZCBhcmUgbm90IGV4ZWN1dGVkIGlmIHRoZSB0ZXN0IGZhaWxlZCwKCWluIG9yZGVyIHRvIGtlZXAgdGhlIHN0YXRlIGZvciBpbnNwZWN0aW9uIGJ5IHRoZSB0ZXN0ZXIKCXRvIGRpYWdub3NlIHRoZSBidWcuCgotbDo6Ci0tbG9uZy10ZXN0czo6CglUaGlzIGNhdXNlcyBhZGRpdGlvbmFsIGxvbmctcnVubmluZyB0ZXN0cyB0byBiZSBydW4gKHdoZXJlCglhdmFpbGFibGUpLCBmb3IgbW9yZSBleGhhdXN0aXZlIHRlc3RpbmcuCgotcjo6Ci0tcnVuPTx0ZXN0LXNlbGVjdG9yPjo6CglSdW4gb25seSB0aGUgc3Vic2V0IG9mIHRlc3RzIGluZGljYXRlZCBieQoJPHRlc3Qtc2VsZWN0b3I+LiAgU2VlIHNlY3Rpb24gIlNraXBwaW5nIFRlc3RzIiBiZWxvdyBmb3IKCTx0ZXN0LXNlbGVjdG9yPiBzeW50YXguCgotLXZhbGdyaW5kPTx0b29sPjo6CglFeGVjdXRlIGFsbCBHaXQgYmluYXJpZXMgdW5kZXIgdmFsZ3JpbmQgdG9vbCA8dG9vbD4gYW5kIGV4aXQKCXdpdGggc3RhdHVzIDEyNiBvbiBlcnJvcnMgKGp1c3QgbGlrZSByZWd1bGFyIHRlc3RzLCB0aGlzIHdpbGwKCW9ubHkgc3RvcCB0aGUgdGVzdCBzY3JpcHQgd2hlbiBydW5uaW5nIHVuZGVyIC1pKS4KCglTaW5jZSBpdCBtYWtlcyBubyBzZW5zZSB0byBydW4gdGhlIHRlc3RzIHdpdGggLS12YWxncmluZCBhbmQKCW5vdCBzZWUgYW55IG91dHB1dCwgdGhpcyBvcHRpb24gaW1wbGllcyAtLXZlcmJvc2UuICBGb3IKCWNvbnZlbmllbmNlLCBpdCBhbHNvIGltcGxpZXMgLS10ZWUuCgoJPHRvb2w+IGRlZmF1bHRzIHRvICdtZW1jaGVjaycsIGp1c3QgbGlrZSB2YWxncmluZCBpdHNlbGYuCglPdGhlciBwYXJ0aWN1bGFybHkgdXNlZnVsIGNob2ljZXMgaW5jbHVkZSAnaGVsZ3JpbmQnIGFuZAoJJ2RyZCcsIGJ1dCB5b3UgbWF5IHVzZSBhbnkgdG9vbCByZWNvZ25pemVkIGJ5IHlvdXIgdmFsZ3JpbmQKCWluc3RhbGxhdGlvbi4KCglBcyBhIHNwZWNpYWwgY2FzZSwgPHRvb2w+IGNhbiBiZSAnbWVtY2hlY2stZmFzdCcsIHdoaWNoIHVzZXMKCW1lbWNoZWNrIGJ1dCBkaXNhYmxlcyAtLXRyYWNrLW9yaWdpbnMuICBVc2UgdGhpcyBpZiB5b3UgYXJlCglydW5uaW5nIHRlc3RzIGluIGJ1bGssIHRvIHNlZSBpZiB0aGVyZSBhcmUgX2FueV8gbWVtb3J5Cglpc3N1ZXMuCgoJTm90ZSB0aGF0IG1lbWNoZWNrIGlzIHJ1biB3aXRoIHRoZSBvcHRpb24gLS1sZWFrLWNoZWNrPW5vLAoJYXMgdGhlIGdpdCBwcm9jZXNzIGlzIHNob3J0LWxpdmVkIGFuZCBzb21lIGVycm9ycyBhcmUgbm90CglpbnRlcmVzdGluZy4gSW4gb3JkZXIgdG8gcnVuIGEgc2luZ2xlIGNvbW1hbmQgdW5kZXIgdGhlIHNhbWUKCWNvbmRpdGlvbnMgbWFudWFsbHksIHlvdSBzaG91bGQgc2V0IEdJVF9WQUxHUklORCB0byBwb2ludCB0bwoJdGhlICd0L3ZhbGdyaW5kLycgZGlyZWN0b3J5IGFuZCB1c2UgdGhlIGNvbW1hbmRzIHVuZGVyCgkndC92YWxncmluZC9iaW4vJy4KCi0tdmFsZ3JpbmQtb25seT08cGF0dGVybj46OgoJTGlrZSAtLXZhbGdyaW5kLCBidXQgdGhlIGVmZmVjdCBpcyBsaW1pdGVkIHRvIHRlc3RzIHdpdGgKCW51bWJlcnMgbWF0Y2hpbmcgPHBhdHRlcm4+LiAgVGhlIG51bWJlciBtYXRjaGVkIGFnYWluc3QgaXMKCXNpbXBseSB0aGUgcnVubmluZyBjb3VudCBvZiB0aGUgdGVzdCB3aXRoaW4gdGhlIGZpbGUuCgotLXRlZTo6CglJbiBhZGRpdGlvbiB0byBwcmludGluZyB0aGUgdGVzdCBvdXRwdXQgdG8gdGhlIHRlcm1pbmFsLAoJd3JpdGUgaXQgdG8gZmlsZXMgbmFtZWQgJ3QvdGVzdC1yZXN1bHRzLyRURVNUX05BTUUub3V0Jy4KCUFzIHRoZSBuYW1lcyBkZXBlbmQgb24gdGhlIHRlc3RzJyBmaWxlIG5hbWVzLCBpdCBpcyBzYWZlIHRvCglydW4gdGhlIHRlc3RzIHdpdGggdGhpcyBvcHRpb24gaW4gcGFyYWxsZWwuCgotLXdpdGgtZGFzaGVzOjoKCUJ5IGRlZmF1bHQgdGVzdHMgYXJlIHJ1biB3aXRob3V0IGRhc2hlZCBmb3JtcyBvZgoJY29tbWFuZHMgKGxpa2UgZ2l0LWNvbW1pdCkgaW4gdGhlIFBBVEggKGl0IG9ubHkgdXNlcwoJd3JhcHBlcnMgZnJvbSAuLi9iaW4td3JhcHBlcnMpLiAgVXNlIHRoaXMgb3B0aW9uIHRvIGluY2x1ZGUKCXRoZSBidWlsZCBkaXJlY3RvcnkgKC4uKSBpbiB0aGUgUEFUSCwgd2hpY2ggY29udGFpbnMgYWxsCgl0aGUgZGFzaGVkIGZvcm1zIG9mIGNvbW1hbmRzLiAgVGhpcyBvcHRpb24gaXMgY3VycmVudGx5CglpbXBsaWVkIGJ5IG90aGVyIG9wdGlvbnMgbGlrZSAtLXZhbGdyaW5kIGFuZAoJR0lUX1RFU1RfSU5TVEFMTEVELgoKLS1yb290PTxkaXJlY3Rvcnk+OjoKCUNyZWF0ZSAidHJhc2giIGRpcmVjdG9yaWVzIHVzZWQgdG8gc3RvcmUgYWxsIHRlbXBvcmFyeSBkYXRhIGR1cmluZwoJdGVzdGluZyB1bmRlciA8ZGlyZWN0b3J5PiwgaW5zdGVhZCBvZiB0aGUgdC8gZGlyZWN0b3J5LgoJVXNpbmcgdGhpcyBvcHRpb24gd2l0aCBhIFJBTS1iYXNlZCBmaWxlc3lzdGVtIChzdWNoIGFzIHRtcGZzKQoJY2FuIG1hc3NpdmVseSBzcGVlZCB1cCB0aGUgdGVzdCBzdWl0ZS4KCi0tY2hhaW4tbGludDo6Ci0tbm8tY2hhaW4tbGludDo6CglJZiAtLWNoYWluLWxpbnQgaXMgZW5hYmxlZCwgdGhlIHRlc3QgaGFybmVzcyB3aWxsIGNoZWNrIGVhY2gKCXRlc3QgdG8gbWFrZSBzdXJlIHRoYXQgaXQgcHJvcGVybHkgIiYmLWNoYWlucyIgYWxsIGNvbW1hbmRzIChzbwoJdGhhdCBhIGZhaWx1cmUgaW4gdGhlIG1pZGRsZSBkb2VzIG5vdCBnbyB1bm5vdGljZWQgYnkgdGhlIGZpbmFsCglleGl0IGNvZGUgb2YgdGhlIHRlc3QpLiBUaGlzIGNoZWNrIGlzIHBlcmZvcm1lZCBpbiBhZGRpdGlvbiB0bwoJcnVubmluZyB0aGUgdGVzdHMgdGhlbXNlbHZlcy4gWW91IG1heSBhbHNvIGVuYWJsZSBvciBkaXNhYmxlCgl0aGlzIGZlYXR1cmUgYnkgc2V0dGluZyB0aGUgR0lUX1RFU1RfQ0hBSU5fTElOVCBlbnZpcm9ubWVudAoJdmFyaWFibGUgdG8gIjEiIG9yICIwIiwgcmVzcGVjdGl2ZWx5LgoKWW91IGNhbiBhbHNvIHNldCB0aGUgR0lUX1RFU1RfSU5TVEFMTEVEIGVudmlyb25tZW50IHZhcmlhYmxlIHRvCnRoZSBiaW5kaXIgb2YgYW4gZXhpc3RpbmcgZ2l0IGluc3RhbGxhdGlvbiB0byB0ZXN0IHRoYXQgaW5zdGFsbGF0aW9uLgpZb3Ugc3RpbGwgbmVlZCB0byBoYXZlIGJ1aWx0IHRoaXMgZ2l0IHNhbmRib3gsIGZyb20gd2hpY2ggdmFyaW91cwp0ZXN0LSogc3VwcG9ydCBwcm9ncmFtcywgdGVtcGxhdGVzLCBhbmQgcGVybCBsaWJyYXJpZXMgYXJlIHVzZWQuCklmIHlvdXIgaW5zdGFsbGVkIGdpdCBpcyBpbmNvbXBsZXRlLCBpdCB3aWxsIHNpbGVudGx5IHRlc3QgcGFydHMgb2YKeW91ciBidWlsdCB2ZXJzaW9uIGluc3RlYWQuCgpXaGVuIHVzaW5nIEdJVF9URVNUX0lOU1RBTExFRCwgeW91IGNhbiBhbHNvIHNldCBHSVRfVEVTVF9FWEVDX1BBVEggdG8Kb3ZlcnJpZGUgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXNoZWQtZm9ybSBzdWJjb21tYW5kcyAod2hhdApHSVRfRVhFQ19QQVRIIHdvdWxkIGJlIHVzZWQgZm9yIGR1cmluZyBub3JtYWwgb3BlcmF0aW9uKS4KR0lUX1RFU1RfRVhFQ19QQVRIIGRlZmF1bHRzIHRvIGAkR0lUX1RFU1RfSU5TVEFMTEVEL2dpdCAtLWV4ZWMtcGF0aGAuCgoKU2tpcHBpbmcgVGVzdHMKLS0tLS0tLS0tLS0tLS0KCkluIHNvbWUgZW52aXJvbm1lbnRzLCBjZXJ0YWluIHRlc3RzIGhhdmUgbm8gd2F5IG9mIHN1Y2NlZWRpbmcKZHVlIHRvIHBsYXRmb3JtIGxpbWl0YXRpb24sIHN1Y2ggYXMgbGFjayBvZiAndW56aXAnIHByb2dyYW0sIG9yCmZpbGVzeXN0ZW0gdGhhdCBkbyBub3QgYWxsb3cgYXJiaXRyYXJ5IHNlcXVlbmNlIG9mIG5vbi1OVUwgYnl0ZXMKYXMgcGF0aG5hbWVzLgoKWW91IHNob3VsZCBiZSBhYmxlIHRvIHNheSBzb21ldGhpbmcgbGlrZQoKICAgICQgR0lUX1NLSVBfVEVTVFM9dDkyMDAuOCBzaCAuL3Q5MjAwLWdpdC1jdnNleHBvcnQtY29tbWl0LnNoCgphbmQgZXZlbjoKCiAgICAkIEdJVF9TS0lQX1RFU1RTPSd0WzAtNF0/Pz8gdDkxPz8gdDkyMDAuOCcgbWFrZQoKdG8gb21pdCBzdWNoIHRlc3RzLiAgVGhlIHZhbHVlIG9mIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBhClNQIHNlcGFyYXRlZCBsaXN0IG9mIHBhdHRlcm5zIHRoYXQgdGVsbHMgd2hpY2ggdGVzdHMgdG8gc2tpcCwKYW5kIGVpdGhlciBjYW4gbWF0Y2ggdGhlICJ0WzAtOV17NH0iIHBhcnQgdG8gc2tpcCB0aGUgd2hvbGUKdGVzdCwgb3IgdFswLTldezR9IGZvbGxvd2VkIGJ5ICIuJG51bWJlciIgdG8gc2F5IHdoaWNoCnBhcnRpY3VsYXIgdGVzdCB0byBza2lwLgoKRm9yIGFuIGluZGl2aWR1YWwgdGVzdCBzdWl0ZSAtLXJ1biBjb3VsZCBiZSB1c2VkIHRvIHNwZWNpZnkgdGhhdApvbmx5IHNvbWUgdGVzdHMgc2hvdWxkIGJlIHJ1biBvciB0aGF0IHNvbWUgdGVzdHMgc2hvdWxkIGJlCmV4Y2x1ZGVkIGZyb20gYSBydW4uCgpUaGUgYXJndW1lbnQgZm9yIC0tcnVuIGlzIGEgbGlzdCBvZiBpbmRpdmlkdWFsIHRlc3QgbnVtYmVycyBvcgpyYW5nZXMgd2l0aCBhbiBvcHRpb25hbCBuZWdhdGlvbiBwcmVmaXggdGhhdCBkZWZpbmUgd2hhdCB0ZXN0cyBpbgphIHRlc3Qgc3VpdGUgdG8gaW5jbHVkZSBpbiB0aGUgcnVuLiAgQSByYW5nZSBpcyB0d28gbnVtYmVycwpzZXBhcmF0ZWQgd2l0aCBhIGRhc2ggYW5kIG1hdGNoZXMgYSByYW5nZSBvZiB0ZXN0cyB3aXRoIGJvdGggZW5kcwpiZWVuIGluY2x1ZGVkLiAgWW91IG1heSBvbWl0IHRoZSBmaXJzdCBvciB0aGUgc2Vjb25kIG51bWJlciB0bwptZWFuICJmcm9tIHRoZSBmaXJzdCB0ZXN0IiBvciAidXAgdG8gdGhlIHZlcnkgbGFzdCB0ZXN0IgpyZXNwZWN0aXZlbHkuCgpPcHRpb25hbCBwcmVmaXggb2YgJyEnIG1lYW5zIHRoYXQgdGhlIHRlc3Qgb3IgYSByYW5nZSBvZiB0ZXN0cwpzaG91bGQgYmUgZXhjbHVkZWQgZnJvbSB0aGUgcnVuLgoKSWYgLS1ydW4gc3RhcnRzIHdpdGggYW4gdW5wcmVmaXhlZCBudW1iZXIgb3IgcmFuZ2UgdGhlIGluaXRpYWwKc2V0IG9mIHRlc3RzIHRvIHJ1biBpcyBlbXB0eS4gSWYgdGhlIGZpcnN0IGl0ZW0gc3RhcnRzIHdpdGggJyEnCmFsbCB0aGUgdGVzdHMgYXJlIGFkZGVkIHRvIHRoZSBpbml0aWFsIHNldC4gIEFmdGVyIGluaXRpYWwgc2V0IGlzCmRldGVybWluZWQgZXZlcnkgdGVzdCBudW1iZXIgb3IgcmFuZ2UgaXMgYWRkZWQgb3IgZXhjbHVkZWQgZnJvbQp0aGUgc2V0IG9uZSBieSBvbmUsIGZyb20gbGVmdCB0byByaWdodC4KCkluZGl2aWR1YWwgbnVtYmVycyBvciByYW5nZXMgY291bGQgYmUgc2VwYXJhdGVkIGVpdGhlciBieSBhIHNwYWNlCm9yIGEgY29tbWEuCgpGb3IgZXhhbXBsZSwgdG8gcnVuIG9ubHkgdGVzdHMgdXAgdG8gYSBzcGVjaWZpYyB0ZXN0ICgyMSksIG9uZQpjb3VsZCBkbyB0aGlzOgoKICAgICQgc2ggLi90OTIwMC1naXQtY3ZzZXhwb3J0LWNvbW1pdC5zaCAtLXJ1bj0nMS0yMScKCm9yIHRoaXM6CgogICAgJCBzaCAuL3Q5MjAwLWdpdC1jdnNleHBvcnQtY29tbWl0LnNoIC0tcnVuPSctMjEnCgpDb21tb24gY2FzZSBpcyB0byBydW4gc2V2ZXJhbCBzZXR1cCB0ZXN0cyAoMSwgMiwgMykgYW5kIHRoZW4gYQpzcGVjaWZpYyB0ZXN0ICgyMSkgdGhhdCByZWxpZXMgb24gdGhhdCBzZXR1cDoKCiAgICAkIHNoIC4vdDkyMDAtZ2l0LWN2c2V4cG9ydC1jb21taXQuc2ggLS1ydW49JzEgMiAzIDIxJwoKb3I6CgogICAgJCBzaCAuL3Q5MjAwLWdpdC1jdnNleHBvcnQtY29tbWl0LnNoIC0tcnVuPTEsMiwzLDIxCgpvcjoKCiAgICAkIHNoIC4vdDkyMDAtZ2l0LWN2c2V4cG9ydC1jb21taXQuc2ggLS1ydW49Jy0zIDIxJwoKQXMgbm90ZWQgYWJvdmUsIHRoZSB0ZXN0IHNldCBpcyBidWlsdCBnb2luZyB0aG91Z2ggaXRlbXMgbGVmdCB0bwpyaWdodCwgc28gdGhpczoKCiAgICAkIHNoIC4vdDkyMDAtZ2l0LWN2c2V4cG9ydC1jb21taXQuc2ggLS1ydW49JzEtNCAhMycKCndpbGwgcnVuIHRlc3RzIDEsIDIsIGFuZCA0LiAgSXRlbXMgdGhhdCBjb21lcyBsYXRlciBoYXZlIGhpZ2hlcgpwcmVjZW5kZW5jZS4gIEl0IG1lYW5zIHRoYXQgdGhpczoKCiAgICAkIHNoIC4vdDkyMDAtZ2l0LWN2c2V4cG9ydC1jb21taXQuc2ggLS1ydW49JyEzIDEtNCcKCndvdWxkIGp1c3QgcnVuIHRlc3RzIGZyb20gMSB0byA0LCBpbmNsdWRpbmcgMy4KCllvdSBtYXkgdXNlIG5lZ2F0aW9uIHdpdGggcmFuZ2VzLiAgVGhlIGZvbGxvd2luZyB3aWxsIHJ1biBhbGwKdGVzdCBpbiB0aGUgdGVzdCBzdWl0ZSBleGNlcHQgZnJvbSA3IHVwIHRvIDExOgoKICAgICQgc2ggLi90OTIwMC1naXQtY3ZzZXhwb3J0LWNvbW1pdC5zaCAtLXJ1bj0nITctMTEnCgpTb21lIHRlc3RzIGluIGEgdGVzdCBzdWl0ZSByZWx5IG9uIHRoZSBwcmV2aW91cyB0ZXN0cyBwZXJmb3JtaW5nCmNlcnRhaW4gYWN0aW9ucywgc3BlY2lmaWNhbGx5IHNvbWUgdGVzdHMgYXJlIGRlc2lnbmF0ZWQgYXMKInNldHVwIiB0ZXN0LCBzbyB5b3UgY2Fubm90IF9hcmJpdHJhcmlseV8gZGlzYWJsZSBvbmUgdGVzdCBhbmQKZXhwZWN0IHRoZSByZXN0IHRvIGZ1bmN0aW9uIGNvcnJlY3RseS4KCi0tcnVuIGlzIG1vc3RseSB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBmb2N1cyBvbiBhIHNwZWNpZmljIHRlc3QKYW5kIGtub3cgd2hhdCBzZXR1cCBpcyBuZWVkZWQgZm9yIGl0LiAgT3Igd2hlbiB5b3Ugd2FudCB0byBydW4KZXZlcnl0aGluZyB1cCB0byBhIGNlcnRhaW4gdGVzdC4KCgpOYW1pbmcgVGVzdHMKLS0tLS0tLS0tLS0tCgpUaGUgdGVzdCBmaWxlcyBhcmUgbmFtZWQgYXM6CgoJdE5OTk4tY29tbWFuZG5hbWUtZGV0YWlscy5zaAoKd2hlcmUgTiBpcyBhIGRlY2ltYWwgZGlnaXQuCgpGaXJzdCBkaWdpdCB0ZWxscyB0aGUgZmFtaWx5OgoKCTAgLSB0aGUgYWJzb2x1dGUgYmFzaWNzIGFuZCBnbG9iYWwgc3R1ZmYKCTEgLSB0aGUgYmFzaWMgY29tbWFuZHMgY29uY2VybmluZyBkYXRhYmFzZQoJMiAtIHRoZSBiYXNpYyBjb21tYW5kcyBjb25jZXJuaW5nIHRoZSB3b3JraW5nIHRyZWUKCTMgLSB0aGUgb3RoZXIgYmFzaWMgY29tbWFuZHMgKGUuZy4gbHMtZmlsZXMpCgk0IC0gdGhlIGRpZmYgY29tbWFuZHMKCTUgLSB0aGUgcHVsbCBhbmQgZXhwb3J0aW5nIGNvbW1hbmRzCgk2IC0gdGhlIHJldmlzaW9uIHRyZWUgY29tbWFuZHMgKGV2ZW4gZS5nLiBtZXJnZS1iYXNlKQoJNyAtIHRoZSBwb3JjZWxhaW5pc2ggY29tbWFuZHMgY29uY2VybmluZyB0aGUgd29ya2luZyB0cmVlCgk4IC0gdGhlIHBvcmNlbGFpbmlzaCBjb21tYW5kcyBjb25jZXJuaW5nIGZvcmVuc2ljcwoJOSAtIHRoZSBnaXQgdG9vbHMKClNlY29uZCBkaWdpdCB0ZWxscyB0aGUgcGFydGljdWxhciBjb21tYW5kIHdlIGFyZSB0ZXN0aW5nLgoKVGhpcmQgZGlnaXQgKG9wdGlvbmFsbHkpIHRlbGxzIHRoZSBwYXJ0aWN1bGFyIHN3aXRjaCBvciBncm91cCBvZiBzd2l0Y2hlcwp3ZSBhcmUgdGVzdGluZy4KCklmIHlvdSBjcmVhdGUgZmlsZXMgdW5kZXIgdC8gZGlyZWN0b3J5IChpLmUuIGhlcmUpIHRoYXQgaXMgbm90CnRoZSB0b3AtbGV2ZWwgdGVzdCBzY3JpcHQsIG5ldmVyIG5hbWUgdGhlIGZpbGUgdG8gbWF0Y2ggdGhlIGFib3ZlCnBhdHRlcm4uICBUaGUgTWFrZWZpbGUgaGVyZSBjb25zaWRlcnMgYWxsIHN1Y2ggZmlsZXMgYXMgdGhlCnRvcC1sZXZlbCB0ZXN0IHNjcmlwdCBhbmQgdHJpZXMgdG8gcnVuIGFsbCBvZiB0aGVtLiAgQ2FyZSBpcwplc3BlY2lhbGx5IG5lZWRlZCBpZiB5b3UgYXJlIGNyZWF0aW5nIGEgY29tbW9uIHRlc3QgbGlicmFyeQpmaWxlLCBzaW1pbGFyIHRvIHRlc3QtbGliLnNoLCBiZWNhdXNlIHN1Y2ggYSBsaWJyYXJ5IGZpbGUgbWF5Cm5vdCBiZSBzdWl0YWJsZSBmb3Igc3RhbmRhbG9uZSBleGVjdXRpb24uCgoKV3JpdGluZyBUZXN0cwotLS0tLS0tLS0tLS0tCgpUaGUgdGVzdCBzY3JpcHQgaXMgd3JpdHRlbiBhcyBhIHNoZWxsIHNjcmlwdC4gIEl0IHNob3VsZCBzdGFydAp3aXRoIHRoZSBzdGFuZGFyZCAiIyEvYmluL3NoIiB3aXRoIGNvcHlyaWdodCBub3RpY2VzLCBhbmQgYW4KYXNzaWdubWVudCB0byB2YXJpYWJsZSAndGVzdF9kZXNjcmlwdGlvbicsIGxpa2UgdGhpczoKCgkjIS9iaW4vc2gKCSMKCSMgQ29weXJpZ2h0IChjKSAyMDA1IEp1bmlvIEMgSGFtYW5vCgkjCgoJdGVzdF9kZXNjcmlwdGlvbj0neHh4IHRlc3QgKG9wdGlvbiAtLWZyb3R6KQoKCVRoaXMgdGVzdCByZWdpc3RlcnMgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmUgaW4gdGhlIGNhY2hlCglhbmQgdHJpZXMgdG8gcnVuIGdpdC1scy1maWxlcyB3aXRoIG9wdGlvbiAtLWZyb3R6LicKCgpTb3VyY2UgJ3Rlc3QtbGliLnNoJwotLS0tLS0tLS0tLS0tLS0tLS0tLQoKQWZ0ZXIgYXNzaWduaW5nIHRlc3RfZGVzY3JpcHRpb24sIHRoZSB0ZXN0IHNjcmlwdCBzaG91bGQgc291cmNlCnRlc3QtbGliLnNoIGxpa2UgdGhpczoKCgkuIC4vdGVzdC1saWIuc2gKClRoaXMgdGVzdCBoYXJuZXNzIGxpYnJhcnkgZG9lcyB0aGUgZm9sbG93aW5nIHRoaW5nczoKCiAtIElmIHRoZSBzY3JpcHQgaXMgaW52b2tlZCB3aXRoIGNvbW1hbmQgbGluZSBhcmd1bWVudCAtLWhlbHAKICAgKG9yIC1oKSwgaXQgc2hvd3MgdGhlIHRlc3RfZGVzY3JpcHRpb24gYW5kIGV4aXRzLgoKIC0gQ3JlYXRlcyBhbiBlbXB0eSB0ZXN0IGRpcmVjdG9yeSB3aXRoIGFuIGVtcHR5IC5naXQvb2JqZWN0cyBkYXRhYmFzZQogICBhbmQgY2hkaXIoMikgaW50byBpdC4gIFRoaXMgZGlyZWN0b3J5IGlzICd0L3RyYXNoCiAgIGRpcmVjdG9yeS4kdGVzdF9uYW1lX3dpdGhvdXRfZG90c2gnLCB3aXRoIHQvIHN1YmplY3QgdG8gY2hhbmdlIGJ5CiAgIHRoZSAtLXJvb3Qgb3B0aW9uIGRvY3VtZW50ZWQgYWJvdmUuCgogLSBEZWZpbmVzIHN0YW5kYXJkIHRlc3QgaGVscGVyIGZ1bmN0aW9ucyBmb3IgeW91ciBzY3JpcHRzIHRvCiAgIHVzZS4gIFRoZXNlIGZ1bmN0aW9ucyBhcmUgZGVzaWduZWQgdG8gbWFrZSBhbGwgc2NyaXB0cyBiZWhhdmUKICAgY29uc2lzdGVudGx5IHdoZW4gY29tbWFuZCBsaW5lIGFyZ3VtZW50cyAtLXZlcmJvc2UgKG9yIC12KSwKICAgLS1kZWJ1ZyAob3IgLWQpLCBhbmQgLS1pbW1lZGlhdGUgKG9yIC1pKSBpcyBnaXZlbi4KCkRvJ3MsIGRvbid0cyAmIHRoaW5ncyB0byBrZWVwIGluIG1pbmQKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKSGVyZSBhcmUgYSBmZXcgZXhhbXBsZXMgb2YgdGhpbmdzIHlvdSBwcm9iYWJseSBzaG91bGQgYW5kIHNob3VsZG4ndCBkbwp3aGVuIHdyaXRpbmcgdGVzdHMuCgpEbzoKCiAtIFB1dCBhbGwgY29kZSBpbnNpZGUgdGVzdF9leHBlY3Rfc3VjY2VzcyBhbmQgb3RoZXIgYXNzZXJ0aW9ucy4KCiAgIEV2ZW4gY29kZSB0aGF0IGlzbid0IGEgdGVzdCBwZXIgc2UsIGJ1dCBtZXJlbHkgc29tZSBzZXR1cCBjb2RlCiAgIHNob3VsZCBiZSBpbnNpZGUgYSB0ZXN0IGFzc2VydGlvbi4KCiAtIENoYWluIHlvdXIgdGVzdCBhc3NlcnRpb25zCgogICBXcml0ZSB0ZXN0IGNvZGUgbGlrZSB0aGlzOgoKCWdpdCBtZXJnZSBmb28gJiYKCWdpdCBwdXNoIGJhciAmJgoJdGVzdCAuLi4KCiAgIEluc3RlYWQgb2Y6CgoJZ2l0IG1lcmdlIGhsYQoJZ2l0IHB1c2ggZ2gKCXRlc3QgLi4uCgogICBUaGF0IHdheSBhbGwgb2YgdGhlIGNvbW1hbmRzIGluIHlvdXIgdGVzdHMgd2lsbCBzdWNjZWVkIG9yIGZhaWwuIElmCiAgIHlvdSBtdXN0IGlnbm9yZSB0aGUgcmV0dXJuIHZhbHVlIG9mIHNvbWV0aGluZywgY29uc2lkZXIgdXNpbmcgYQogICBoZWxwZXIgZnVuY3Rpb24gKGUuZy4gdXNlIHNhbmVfdW5zZXQgaW5zdGVhZCBvZiB1bnNldCwgaW4gb3JkZXIKICAgdG8gYXZvaWQgdW5wb3J0YWJsZSByZXR1cm4gdmFsdWUgZm9yIHVuc2V0dGluZyBhIHZhcmlhYmxlIHRoYXQgd2FzCiAgIGFscmVhZHkgdW5zZXQpLCBvciBwcmVwZW5kaW5nIHRoZSBjb21tYW5kIHdpdGggdGVzdF9taWdodF9mYWlsIG9yCiAgIHRlc3RfbXVzdF9mYWlsLgoKIC0gQ2hlY2sgdGhlIHRlc3QgY292ZXJhZ2UgZm9yIHlvdXIgdGVzdHMuIFNlZSB0aGUgIlRlc3QgY292ZXJhZ2UiCiAgIGJlbG93LgoKICAgRG9uJ3QgYmxpbmRseSBmb2xsb3cgdGVzdCBjb3ZlcmFnZSBtZXRyaWNzOyBpZiBhIG5ldyBmdW5jdGlvbiB5b3UgYWRkZWQKICAgZG9lc24ndCBoYXZlIGFueSBjb3ZlcmFnZSwgdGhlbiB5b3UncmUgcHJvYmFibHkgZG9pbmcgc29tZXRoaW5nIHdyb25nLAogICBidXQgaGF2aW5nIDEwMCUgY292ZXJhZ2UgZG9lc24ndCBuZWNlc3NhcmlseSBtZWFuIHRoYXQgeW91IHRlc3RlZAogICBldmVyeXRoaW5nLgoKICAgVGVzdHMgdGhhdCBhcmUgbGlrZWx5IHRvIHNtb2tlIG91dCBmdXR1cmUgcmVncmVzc2lvbnMgYXJlIGJldHRlcgogICB0aGFuIHRlc3RzIHRoYXQganVzdCBpbmZsYXRlIHRoZSBjb3ZlcmFnZSBtZXRyaWNzLgoKIC0gV2hlbiBhIHRlc3QgY2hlY2tzIGZvciBhbiBhYnNvbHV0ZSBwYXRoIHRoYXQgYSBnaXQgY29tbWFuZCBnZW5lcmF0ZWQsCiAgIGNvbnN0cnVjdCB0aGUgZXhwZWN0ZWQgdmFsdWUgdXNpbmcgJChwd2QpIHJhdGhlciB0aGFuICRQV0QsCiAgICRURVNUX0RJUkVDVE9SWSwgb3IgJFRSQVNIX0RJUkVDVE9SWS4gSXQgbWFrZXMgYSBkaWZmZXJlbmNlIG9uCiAgIFdpbmRvd3MsIHdoZXJlIHRoZSBzaGVsbCAoTVNZUyBiYXNoKSBtYW5nbGVzIGFic29sdXRlIHBhdGggbmFtZXMuCiAgIEZvciBkZXRhaWxzLCBzZWUgdGhlIGNvbW1pdCBtZXNzYWdlIG9mIDQxMTQxNTZhZTkuCgpEb24ndDoKCiAtIGV4aXQoKSB3aXRoaW4gYSA8c2NyaXB0PiBwYXJ0LgoKICAgVGhlIGhhcm5lc3Mgd2lsbCBjYXRjaCB0aGlzIGFzIGEgcHJvZ3JhbW1pbmcgZXJyb3Igb2YgdGhlIHRlc3QuCiAgIFVzZSB0ZXN0X2RvbmUgaW5zdGVhZCBpZiB5b3UgbmVlZCB0byBzdG9wIHRoZSB0ZXN0cyBlYXJseSAoc2VlCiAgICJTa2lwcGluZyB0ZXN0cyIgYmVsb3cpLgoKIC0gdXNlICchIGdpdCBjbWQnIHdoZW4geW91IHdhbnQgdG8gbWFrZSBzdXJlIHRoZSBnaXQgY29tbWFuZCBleGl0cwogICB3aXRoIGZhaWx1cmUgaW4gYSBjb250cm9sbGVkIHdheSBieSBjYWxsaW5nICJkaWUoKSIuICBJbnN0ZWFkLAogICB1c2UgJ3Rlc3RfbXVzdF9mYWlsIGdpdCBjbWQnLiAgVGhpcyB3aWxsIHNpZ25hbCBhIGZhaWx1cmUgaWYgZ2l0CiAgIGRpZXMgaW4gYW4gdW5leHBlY3RlZCB3YXkgKGUuZy4gc2VnZmF1bHQpLgoKICAgT24gdGhlIG90aGVyIGhhbmQsIGRvbid0IHVzZSB0ZXN0X211c3RfZmFpbCBmb3IgcnVubmluZyByZWd1bGFyCiAgIHBsYXRmb3JtIGNvbW1hbmRzOyBqdXN0IHVzZSAnISBjbWQnLiAgV2UgYXJlIG5vdCBpbiB0aGUgYnVzaW5lc3MKICAgb2YgdmVyaWZ5aW5nIHRoYXQgdGhlIHdvcmxkIGdpdmVuIHRvIHVzIHNhbmVseSB3b3Jrcy4KCiAtIHVzZSBwZXJsIHdpdGhvdXQgc3BlbGxpbmcgaXQgYXMgIiRQRVJMX1BBVEgiLiBUaGlzIGlzIHRvIGhlbHAgb3VyCiAgIGZyaWVuZHMgb24gV2luZG93cyB3aGVyZSB0aGUgcGxhdGZvcm0gUGVybCBvZnRlbiBhZGRzIENSIGJlZm9yZQogICB0aGUgZW5kIG9mIGxpbmUsIGFuZCB0aGV5IGJ1bmRsZSBHaXQgd2l0aCBhIHZlcnNpb24gb2YgUGVybCB0aGF0CiAgIGRvZXMgbm90IGRvIHNvLCB3aG9zZSBwYXRoIGlzIHNwZWNpZmllZCB3aXRoICRQRVJMX1BBVEguIE5vdGUgdGhhdCB3ZQogICBwcm92aWRlIGEgInBlcmwiIGZ1bmN0aW9uIHdoaWNoIHVzZXMgJFBFUkxfUEFUSCB1bmRlciB0aGUgaG9vZCwgc28KICAgeW91IGRvIG5vdCBuZWVkIHRvIHdvcnJ5IHdoZW4gc2ltcGx5IHJ1bm5pbmcgcGVybCBpbiB0aGUgdGVzdCBzY3JpcHRzCiAgIChidXQgeW91IGRvLCBmb3IgZXhhbXBsZSwgb24gYSBzaGViYW5nIGxpbmUgb3IgaW4gYSBzdWIgc2NyaXB0CiAgIGNyZWF0ZWQgdmlhICJ3cml0ZV9zY3JpcHQiKS4KCiAtIHVzZSBzaCB3aXRob3V0IHNwZWxsaW5nIGl0IGFzICIkU0hFTExfUEFUSCIsIHdoZW4gdGhlIHNjcmlwdCBjYW4KICAgYmUgbWlzaW50ZXJwcmV0ZWQgYnkgYnJva2VuIHBsYXRmb3JtIHNoZWxsIChlLmcuIFNvbGFyaXMpLgoKIC0gY2hkaXIgYXJvdW5kIGluIHRlc3RzLiAgSXQgaXMgbm90IHN1ZmZpY2llbnQgdG8gY2hkaXIgdG8KICAgc29tZXdoZXJlIGFuZCB0aGVuIGNoZGlyIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGxvY2F0aW9uIGxhdGVyIGluCiAgIHRoZSB0ZXN0LCBhcyBhbnkgaW50ZXJtZWRpYXRlIHN0ZXAgY2FuIGZhaWwgYW5kIGFib3J0IHRoZSB0ZXN0LAogICBjYXVzaW5nIHRoZSBuZXh0IHRlc3QgdG8gc3RhcnQgaW4gYW4gdW5leHBlY3RlZCBkaXJlY3RvcnkuICBEbyBzbwogICBpbnNpZGUgYSBzdWJzaGVsbCBpZiBuZWNlc3NhcnkuCgogLSBCcmVhayB0aGUgVEFQIG91dHB1dAoKICAgVGhlIHJhdyBvdXRwdXQgZnJvbSB5b3VyIHRlc3QgbWF5IGJlIGludGVycHJldGVkIGJ5IGEgVEFQIGhhcm5lc3MuIFRBUAogICBoYXJuZXNzZXMgd2lsbCBpZ25vcmUgZXZlcnl0aGluZyB0aGV5IGRvbid0IGtub3cgYWJvdXQsIGJ1dCBkb24ndCBzdGVwCiAgIG9uIHRoZWlyIHRvZXMgaW4gdGhlc2UgYXJlYXM6CgogICAtIERvbid0IHByaW50IGxpbmVzIGxpa2UgIiR4Li4keSIgd2hlcmUgJHggYW5kICR5IGFyZSBpbnRlZ2Vycy4KCiAgIC0gRG9uJ3QgcHJpbnQgbGluZXMgdGhhdCBiZWdpbiB3aXRoICJvayIgb3IgIm5vdCBvayIuCgogICBUQVAgaGFybmVzc2VzIGV4cGVjdCBhIGxpbmUgdGhhdCBiZWdpbnMgd2l0aCBlaXRoZXIgIm9rIiBhbmQgIm5vdAogICBvayIgdG8gc2lnbmFsIGEgdGVzdCBwYXNzZWQgb3IgZmFpbGVkIChhbmQgb3VyIGhhcm5lc3MgYWxyZWFkeQogICBwcm9kdWNlcyBzdWNoIGxpbmVzKSwgc28geW91ciBzY3JpcHQgc2hvdWxkbid0IGVtaXQgc3VjaCBsaW5lcyB0bwogICB0aGVpciBvdXRwdXQuCgogICBZb3UgY2FuIGdsZWFuIHNvbWUgZnVydGhlciBwb3NzaWJsZSBpc3N1ZXMgZnJvbSB0aGUgVEFQIGdyYW1tYXIKICAgKHNlZSBodHRwOi8vc2VhcmNoLmNwYW4ub3JnL3Blcmxkb2M/VEFQOjpQYXJzZXI6OkdyYW1tYXIjVEFQX0dyYW1tYXIpCiAgIGJ1dCB0aGUgYmVzdCBpbmRpY2F0aW9uIGlzIHRvIGp1c3QgcnVuIHRoZSB0ZXN0cyB3aXRoIHByb3ZlKDEpLAogICBpdCdsbCBjb21wbGFpbiBpZiBhbnl0aGluZyBpcyBhbWlzcy4KCktlZXAgaW4gbWluZDoKCiAtIEluc2lkZSA8c2NyaXB0PiBwYXJ0LCB0aGUgc3RhbmRhcmQgb3V0cHV0IGFuZCBzdGFuZGFyZCBlcnJvcgogICBzdHJlYW1zIGFyZSBkaXNjYXJkZWQsIGFuZCB0aGUgdGVzdCBoYXJuZXNzIG9ubHkgcmVwb3J0cyAib2siIG9yCiAgICJub3Qgb2siIHRvIHRoZSBlbmQgdXNlciBydW5uaW5nIHRoZSB0ZXN0cy4gVW5kZXIgLS12ZXJib3NlLCB0aGV5CiAgIGFyZSBzaG93biB0byBoZWxwIGRlYnVnZ2luZyB0aGUgdGVzdHMuCgoKU2tpcHBpbmcgdGVzdHMKLS0tLS0tLS0tLS0tLS0KCklmIHlvdSBuZWVkIHRvIHNraXAgdGVzdHMgeW91IHNob3VsZCBkbyBzbyBieSB1c2luZyB0aGUgdGhyZWUtYXJnIGZvcm0Kb2YgdGhlIHRlc3RfKiBmdW5jdGlvbnMgKHNlZSB0aGUgIlRlc3QgaGFybmVzcyBsaWJyYXJ5IiBzZWN0aW9uCmJlbG93KSwgZS5nLjoKCiAgICB0ZXN0X2V4cGVjdF9zdWNjZXNzIFBFUkwgJ0kgbmVlZCBQZXJsJyAnCiAgICAgICAgcGVybCAtZSAiaGxhZ2goKSBpZiB1bmZfdW5mKCkiCiAgICAnCgpUaGUgYWR2YW50YWdlIG9mIHNraXBwaW5nIHRlc3RzIGxpa2UgdGhpcyBpcyB0aGF0IHBsYXRmb3JtcyB0aGF0IGRvbid0CmhhdmUgdGhlIFBFUkwgYW5kIG90aGVyIG9wdGlvbmFsIGRlcGVuZGVuY2llcyBnZXQgYW4gaW5kaWNhdGlvbiBvZiBob3cKbWFueSB0ZXN0cyB0aGV5J3JlIG1pc3NpbmcuCgpJZiB0aGUgdGVzdCBjb2RlIGlzIHRvbyBoYWlyeSBmb3IgdGhhdCAoaS5lLiBkb2VzIGEgbG90IG9mIHNldHVwIHdvcmsKb3V0c2lkZSB0ZXN0IGFzc2VydGlvbnMpIHlvdSBjYW4gYWxzbyBza2lwIGFsbCByZW1haW5pbmcgdGVzdHMgYnkKc2V0dGluZyBza2lwX2FsbCBhbmQgaW1tZWRpYXRlbHkgY2FsbCB0ZXN0X2RvbmU6CgoJaWYgISB0ZXN0X2hhdmVfcHJlcmVxIFBFUkwKCXRoZW4KCSAgICBza2lwX2FsbD0nc2tpcHBpbmcgcGVybCBpbnRlcmZhY2UgdGVzdHMsIHBlcmwgbm90IGF2YWlsYWJsZScKCSAgICB0ZXN0X2RvbmUKCWZpCgpUaGUgc3RyaW5nIHlvdSBnaXZlIHRvIHNraXBfYWxsIHdpbGwgYmUgdXNlZCBhcyBhbiBleHBsYW5hdGlvbiBmb3Igd2h5CnRoZSB0ZXN0IHdhcyBza2lwcGVkLgoKRW5kIHdpdGggdGVzdF9kb25lCi0tLS0tLS0tLS0tLS0tLS0tLQoKWW91ciBzY3JpcHQgd2lsbCBiZSBhIHNlcXVlbmNlIG9mIHRlc3RzLCB1c2luZyBoZWxwZXIgZnVuY3Rpb25zCmZyb20gdGhlIHRlc3QgaGFybmVzcyBsaWJyYXJ5LiAgQXQgdGhlIGVuZCBvZiB0aGUgc2NyaXB0LCBjYWxsCid0ZXN0X2RvbmUnLgoKClRlc3QgaGFybmVzcyBsaWJyYXJ5Ci0tLS0tLS0tLS0tLS0tLS0tLS0tCgpUaGVyZSBhcmUgYSBoYW5kZnVsIGhlbHBlciBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGUgdGVzdCBoYXJuZXNzCmxpYnJhcnkgZm9yIHlvdXIgc2NyaXB0IHRvIHVzZS4KCiAtIHRlc3RfZXhwZWN0X3N1Y2Nlc3MgWzxwcmVyZXE+XSA8bWVzc2FnZT4gPHNjcmlwdD4KCiAgIFVzdWFsbHkgdGFrZXMgdHdvIHN0cmluZ3MgYXMgcGFyYW1ldGVycywgYW5kIGV2YWx1YXRlcyB0aGUKICAgPHNjcmlwdD4uICBJZiBpdCB5aWVsZHMgc3VjY2VzcywgdGVzdCBpcyBjb25zaWRlcmVkCiAgIHN1Y2Nlc3NmdWwuICA8bWVzc2FnZT4gc2hvdWxkIHN0YXRlIHdoYXQgaXQgaXMgdGVzdGluZy4KCiAgIEV4YW1wbGU6CgoJdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgkgICAgJ2dpdC13cml0ZS10cmVlIHNob3VsZCBiZSBhYmxlIHRvIHdyaXRlIGFuIGVtcHR5IHRyZWUuJyBcCgkgICAgJ3RyZWU9JChnaXQtd3JpdGUtdHJlZSknCgogICBJZiB5b3Ugc3VwcGx5IHRocmVlIHBhcmFtZXRlcnMgdGhlIGZpcnN0IHdpbGwgYmUgdGFrZW4gdG8gYmUgYQogICBwcmVyZXF1aXNpdGU7IHNlZSB0aGUgdGVzdF9zZXRfcHJlcmVxIGFuZCB0ZXN0X2hhdmVfcHJlcmVxCiAgIGRvY3VtZW50YXRpb24gYmVsb3c6CgoJdGVzdF9leHBlY3Rfc3VjY2VzcyBUVFkgJ2dpdCAtLXBhZ2luYXRlIHJldi1saXN0IHVzZXMgYSBwYWdlcicgXAoJICAgICcgLi4uICcKCiAgIFlvdSBjYW4gYWxzbyBzdXBwbHkgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBwcmVyZXF1aXNpdGVzLCBpbiB0aGUKICAgcmFyZSBjYXNlIHdoZXJlIHlvdXIgdGVzdCBkZXBlbmRzIG9uIG1vcmUgdGhhbiBvbmU6CgoJdGVzdF9leHBlY3Rfc3VjY2VzcyBQRVJMLFBZVEhPTiAneW8gZGF3ZycgXAoJICAgICcgdGVzdCAkKHBlcmwgLUUgJ3ByaW50IGV2YWwgIjEgKyIgLiBxeFtweXRob24gLWMgInByaW50IDIiXScpID09ICI0IiAnCgogLSB0ZXN0X2V4cGVjdF9mYWlsdXJlIFs8cHJlcmVxPl0gPG1lc3NhZ2U+IDxzY3JpcHQ+CgogICBUaGlzIGlzIE5PVCB0aGUgb3Bwb3NpdGUgb2YgdGVzdF9leHBlY3Rfc3VjY2VzcywgYnV0IGlzIHVzZWQKICAgdG8gbWFyayBhIHRlc3QgdGhhdCBkZW1vbnN0cmF0ZXMgYSBrbm93biBicmVha2FnZS4gIFVubGlrZQogICB0aGUgdXN1YWwgdGVzdF9leHBlY3Rfc3VjY2VzcyB0ZXN0cywgd2hpY2ggc2F5ICJvayIgb24KICAgc3VjY2VzcyBhbmQgIkZBSUwiIG9uIGZhaWx1cmUsIHRoaXMgd2lsbCBzYXkgIkZJWEVEIiBvbgogICBzdWNjZXNzIGFuZCAic3RpbGwgYnJva2VuIiBvbiBmYWlsdXJlLiAgRmFpbHVyZXMgZnJvbSB0aGVzZQogICB0ZXN0cyB3b24ndCBjYXVzZSAtaSAoaW1tZWRpYXRlKSB0byBzdG9wLgoKICAgTGlrZSB0ZXN0X2V4cGVjdF9zdWNjZXNzIHRoaXMgZnVuY3Rpb24gY2FuIG9wdGlvbmFsbHkgdXNlIGEgdGhyZWUKICAgYXJndW1lbnQgaW52b2NhdGlvbiB3aXRoIGEgcHJlcmVxdWlzaXRlIGFzIHRoZSBmaXJzdCBhcmd1bWVudC4KCiAtIHRlc3RfZGVidWcgPHNjcmlwdD4KCiAgIFRoaXMgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQsIDxzY3JpcHQ+LCBhbmQgZXZhbHVhdGVzIGl0IG9ubHkKICAgd2hlbiB0aGUgdGVzdCBzY3JpcHQgaXMgc3RhcnRlZCB3aXRoIC0tZGVidWcgY29tbWFuZCBsaW5lCiAgIGFyZ3VtZW50LiAgVGhpcyBpcyBwcmltYXJpbHkgbWVhbnQgZm9yIHVzZSBkdXJpbmcgdGhlCiAgIGRldmVsb3BtZW50IG9mIGEgbmV3IHRlc3Qgc2NyaXB0LgoKIC0gdGVzdF9kb25lCgogICBZb3VyIHRlc3Qgc2NyaXB0IG11c3QgaGF2ZSB0ZXN0X2RvbmUgYXQgdGhlIGVuZC4gIEl0cyBwdXJwb3NlCiAgIGlzIHRvIHN1bW1hcml6ZSBzdWNjZXNzZXMgYW5kIGZhaWx1cmVzIGluIHRoZSB0ZXN0IHNjcmlwdCBhbmQKICAgZXhpdCB3aXRoIGFuIGFwcHJvcHJpYXRlIGVycm9yIGNvZGUuCgogLSB0ZXN0X3RpY2sKCiAgIE1ha2UgY29tbWl0IGFuZCB0YWcgbmFtZXMgY29uc2lzdGVudCBieSBzZXR0aW5nIHRoZSBhdXRob3IgYW5kCiAgIGNvbW1pdHRlciB0aW1lcyB0byBkZWZpbmVkIHN0YXRlLiAgU3Vic2VxdWVudCBjYWxscyB3aWxsCiAgIGFkdmFuY2UgdGhlIHRpbWVzIGJ5IGEgZml4ZWQgYW1vdW50LgoKIC0gdGVzdF9jb21taXQgPG1lc3NhZ2U+IFs8ZmlsZW5hbWU+IFs8Y29udGVudHM+XV0KCiAgIENyZWF0ZXMgYSBjb21taXQgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSwgY29tbWl0dGluZyB0aGUgZ2l2ZW4KICAgZmlsZSB3aXRoIHRoZSBnaXZlbiBjb250ZW50cyAoZGVmYXVsdCBmb3IgYm90aCBpcyB0byByZXVzZSB0aGUKICAgbWVzc2FnZSBzdHJpbmcpLCBhbmQgYWRkcyBhIHRhZyAoYWdhaW4gcmV1c2luZyB0aGUgbWVzc2FnZQogICBzdHJpbmcgYXMgbmFtZSkuICBDYWxscyB0ZXN0X3RpY2sgdG8gbWFrZSB0aGUgU0hBLTFzCiAgIHJlcHJvZHVjaWJsZS4KCiAtIHRlc3RfbWVyZ2UgPG1lc3NhZ2U+IDxjb21taXQtb3ItdGFnPgoKICAgTWVyZ2VzIHRoZSBnaXZlbiByZXYgdXNpbmcgdGhlIGdpdmVuIG1lc3NhZ2UuICBMaWtlIHRlc3RfY29tbWl0LAogICBjcmVhdGVzIGEgdGFnIGFuZCBjYWxscyB0ZXN0X3RpY2sgYmVmb3JlIGNvbW1pdHRpbmcuCgogLSB0ZXN0X3NldF9wcmVyZXEgPHByZXJlcT4KCiAgIFNldCBhIHRlc3QgcHJlcmVxdWlzaXRlIHRvIGJlIHVzZWQgbGF0ZXIgd2l0aCB0ZXN0X2hhdmVfcHJlcmVxLiBUaGUKICAgdGVzdC1saWIgd2lsbCBzZXQgc29tZSBwcmVyZXF1aXNpdGVzIGZvciB5b3UsIHNlZSB0aGUKICAgIlByZXJlcXVpc2l0ZXMiIHNlY3Rpb24gYmVsb3cgZm9yIGEgZnVsbCBsaXN0IG9mIHRoZXNlLgoKICAgT3RoZXJzIHlvdSBjYW4gc2V0IHlvdXJzZWxmIGFuZCB1c2UgbGF0ZXIgd2l0aCBlaXRoZXIKICAgdGVzdF9oYXZlX3ByZXJlcSBkaXJlY3RseSwgb3IgdGhlIHRocmVlIGFyZ3VtZW50IGludm9jYXRpb24gb2YKICAgdGVzdF9leHBlY3Rfc3VjY2VzcyBhbmQgdGVzdF9leHBlY3RfZmFpbHVyZS4KCiAtIHRlc3RfaGF2ZV9wcmVyZXEgPHByZXJlcT4KCiAgIENoZWNrIGlmIHdlIGhhdmUgYSBwcmVyZXF1aXNpdGUgcHJldmlvdXNseSBzZXQgd2l0aAogICB0ZXN0X3NldF9wcmVyZXEuIFRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgdGhpcyBkaXJlY3RseSBpcyB0byBza2lwCiAgIGFsbCB0aGUgdGVzdHMgaWYgd2UgZG9uJ3QgaGF2ZSBzb21lIGVzc2VudGlhbCBwcmVyZXF1aXNpdGU6CgoJaWYgISB0ZXN0X2hhdmVfcHJlcmVxIFBFUkwKCXRoZW4KCSAgICBza2lwX2FsbD0nc2tpcHBpbmcgcGVybCBpbnRlcmZhY2UgdGVzdHMsIHBlcmwgbm90IGF2YWlsYWJsZScKCSAgICB0ZXN0X2RvbmUKCWZpCgogLSB0ZXN0X2V4dGVybmFsIFs8cHJlcmVxPl0gPG1lc3NhZ2U+IDxleHRlcm5hbD4gPHNjcmlwdD4KCiAgIEV4ZWN1dGUgYSA8c2NyaXB0PiB3aXRoIGFuIDxleHRlcm5hbD4gaW50ZXJwcmV0ZXIgKGxpa2UgcGVybCkuIFRoaXMKICAgd2FzIGFkZGVkIGZvciB0ZXN0cyBsaWtlIHQ5NzAwLXBlcmwtZ2l0LnNoIHdoaWNoIGRvIG1vc3Qgb2YgdGhlaXIKICAgd29yayBpbiBhbiBleHRlcm5hbCB0ZXN0IHNjcmlwdC4KCgl0ZXN0X2V4dGVybmFsIFwKCSAgICAnR2l0d2ViQ2FjaGU6OipGaWxlQ2FjaGUqJyBcCgkgICAgcGVybCAiJFRFU1RfRElSRUNUT1JZIi90OTUwMy90ZXN0X2NhY2hlX2ludGVyZmFjZS5wbAoKICAgSWYgdGhlIHRlc3QgaXMgb3V0cHV0dGluZyBpdHMgb3duIFRBUCB5b3Ugc2hvdWxkIHNldCB0aGUKICAgdGVzdF9leHRlcm5hbF9oYXNfdGFwIHZhcmlhYmxlIHNvbWV3aGVyZSBiZWZvcmUgY2FsbGluZyB0aGUgZmlyc3QKICAgdGVzdF9leHRlcm5hbCogZnVuY3Rpb24uIFNlZSB0OTcwMC1wZXJsLWdpdC5zaCBmb3IgYW4gZXhhbXBsZS4KCgkjIFRoZSBleHRlcm5hbCB0ZXN0IHdpbGwgb3V0cHV0cyBpdHMgb3duIHBsYW4KCXRlc3RfZXh0ZXJuYWxfaGFzX3RhcD0xCgogLSB0ZXN0X2V4dGVybmFsX3dpdGhvdXRfc3RkZXJyIFs8cHJlcmVxPl0gPG1lc3NhZ2U+IDxleHRlcm5hbD4gPHNjcmlwdD4KCiAgIExpa2UgdGVzdF9leHRlcm5hbCBidXQgZmFpbCBpZiB0aGVyZSdzIGFueSBvdXRwdXQgb24gc3RkZXJyLAogICBpbnN0ZWFkIG9mIGNoZWNraW5nIHRoZSBleGl0IGNvZGUuCgoJdGVzdF9leHRlcm5hbF93aXRob3V0X3N0ZGVyciBcCgkgICAgJ1BlcmwgQVBJJyBcCgkgICAgcGVybCAiJFRFU1RfRElSRUNUT1JZIi90OTcwMC90ZXN0LnBsCgogLSB0ZXN0X2V4cGVjdF9jb2RlIDxleGl0LWNvZGU+IDxjb21tYW5kPgoKICAgUnVuIGEgY29tbWFuZCBhbmQgZW5zdXJlIHRoYXQgaXQgZXhpdHMgd2l0aCB0aGUgZ2l2ZW4gZXhpdCBjb2RlLgogICBGb3IgZXhhbXBsZToKCgl0ZXN0X2V4cGVjdF9zdWNjZXNzICdNZXJnZSB3aXRoIGQvZiBjb25mbGljdHMnICcKCQl0ZXN0X2V4cGVjdF9jb2RlIDEgZ2l0IG1lcmdlICJtZXJnZSBtc2ciIEIgbWFzdGVyCgknCgogLSB0ZXN0X211c3RfZmFpbCA8Z2l0LWNvbW1hbmQ+CgogICBSdW4gYSBnaXQgY29tbWFuZCBhbmQgZW5zdXJlIGl0IGZhaWxzIGluIGEgY29udHJvbGxlZCB3YXkuICBVc2UKICAgdGhpcyBpbnN0ZWFkIG9mICIhIDxnaXQtY29tbWFuZD4iLiAgV2hlbiBnaXQtY29tbWFuZCBkaWVzIGR1ZSB0byBhCiAgIHNlZ2ZhdWx0LCB0ZXN0X211c3RfZmFpbCBkaWFnbm9zZXMgaXQgYXMgYW4gZXJyb3I7ICIhIDxnaXQtY29tbWFuZD4iCiAgIHRyZWF0cyBpdCBhcyBqdXN0IGFub3RoZXIgZXhwZWN0ZWQgZmFpbHVyZSwgd2hpY2ggd291bGQgbGV0IHN1Y2ggYQogICBidWcgZ28gdW5ub3RpY2VkLgoKIC0gdGVzdF9taWdodF9mYWlsIDxnaXQtY29tbWFuZD4KCiAgIFNpbWlsYXIgdG8gdGVzdF9tdXN0X2ZhaWwsIGJ1dCB0b2xlcmF0ZSBzdWNjZXNzLCB0b28uICBVc2UgdGhpcwogICBpbnN0ZWFkIG9mICI8Z2l0LWNvbW1hbmQ+IHx8IDoiIHRvIGNhdGNoIGZhaWx1cmVzIGR1ZSB0byBzZWd2LgoKIC0gdGVzdF9jbXAgPGV4cGVjdGVkPiA8YWN0dWFsPgoKICAgQ2hlY2sgd2hldGhlciB0aGUgY29udGVudCBvZiB0aGUgPGFjdHVhbD4gZmlsZSBtYXRjaGVzIHRoZQogICA8ZXhwZWN0ZWQ+IGZpbGUuICBUaGlzIGJlaGF2ZXMgbGlrZSAiY21wIiBidXQgcHJvZHVjZXMgbW9yZQogICBoZWxwZnVsIG91dHB1dCB3aGVuIHRoZSB0ZXN0IGlzIHJ1biB3aXRoICItdiIgb3B0aW9uLgoKIC0gdGVzdF9saW5lX2NvdW50ICg9IHwgLWx0IHwgLWdlIHwgLi4uKSA8bGVuZ3RoPiA8ZmlsZT4KCiAgIENoZWNrIHdoZXRoZXIgYSBmaWxlIGhhcyB0aGUgbGVuZ3RoIGl0IGlzIGV4cGVjdGVkIHRvLgoKIC0gdGVzdF9wYXRoX2lzX2ZpbGUgPHBhdGg+IFs8ZGlhZ25vc2lzPl0KICAgdGVzdF9wYXRoX2lzX2RpciA8cGF0aD4gWzxkaWFnbm9zaXM+XQogICB0ZXN0X3BhdGhfaXNfbWlzc2luZyA8cGF0aD4gWzxkaWFnbm9zaXM+XQoKICAgQ2hlY2sgaWYgdGhlIG5hbWVkIHBhdGggaXMgYSBmaWxlLCBpZiB0aGUgbmFtZWQgcGF0aCBpcyBhCiAgIGRpcmVjdG9yeSwgb3IgaWYgdGhlIG5hbWVkIHBhdGggZG9lcyBub3QgZXhpc3QsIHJlc3BlY3RpdmVseSwKICAgYW5kIGZhaWwgb3RoZXJ3aXNlLCBzaG93aW5nIHRoZSA8ZGlhZ25vc2lzPiB0ZXh0LgoKIC0gdGVzdF93aGVuX2ZpbmlzaGVkIDxzY3JpcHQ+CgogICBQcmVwZW5kIDxzY3JpcHQ+IHRvIGEgbGlzdCBvZiBjb21tYW5kcyB0byBydW4gdG8gY2xlYW4gdXAKICAgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCB0ZXN0LiAgSWYgc29tZSBjbGVhbi11cCBjb21tYW5kCiAgIGZhaWxzLCB0aGUgdGVzdCB3aWxsIG5vdCBwYXNzLgoKICAgRXhhbXBsZToKCgl0ZXN0X2V4cGVjdF9zdWNjZXNzICdicmFuY2ggcG9pbnRpbmcgdG8gbm9uLWNvbW1pdCcgJwoJCWdpdCByZXYtcGFyc2UgSEVBRF57dHJlZX0gPi5naXQvcmVmcy9oZWFkcy9pbnZhbGlkICYmCgkJdGVzdF93aGVuX2ZpbmlzaGVkICJnaXQgdXBkYXRlLXJlZiAtZCByZWZzL2hlYWRzL2ludmFsaWQiICYmCgkJLi4uCgknCgogLSB0ZXN0X3dyaXRlX2xpbmVzIDxsaW5lcz4KCiAgIFdyaXRlIDxsaW5lcz4gb24gc3RhbmRhcmQgb3V0cHV0LCBvbmUgbGluZSBwZXIgYXJndW1lbnQuCiAgIFVzZWZ1bCB0byBwcmVwYXJlIG11bHRpLWxpbmUgZmlsZXMgaW4gYSBjb21wYWN0IGZvcm0uCgogICBFeGFtcGxlOgoKCXRlc3Rfd3JpdGVfbGluZXMgYSBiIGMgZCBlIGYgZyA+Zm9vCgogICBJcyBhIG1vcmUgY29tcGFjdCBlcXVpdmFsZW50IG9mOgoJY2F0ID5mb28gPDwtRU9GCglhCgliCgljCglkCgllCglmCglnCglFT0YKCgogLSB0ZXN0X3BhdXNlCgoJVGhpcyBjb21tYW5kIGlzIHVzZWZ1bCBmb3Igd3JpdGluZyBhbmQgZGVidWdnaW5nIHRlc3RzIGFuZCBtdXN0IGJlCglyZW1vdmVkIGJlZm9yZSBzdWJtaXR0aW5nLiBJdCBoYWx0cyB0aGUgZXhlY3V0aW9uIG9mIHRoZSB0ZXN0IGFuZAoJc3Bhd25zIGEgc2hlbGwgaW4gdGhlIHRyYXNoIGRpcmVjdG9yeS4gRXhpdCB0aGUgc2hlbGwgdG8gY29udGludWUKCXRoZSB0ZXN0LiBFeGFtcGxlOgoKCXRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3Rlc3QnICcKCQlnaXQgZG8tc29tZXRoaW5nID5hY3R1YWwgJiYKCQl0ZXN0X3BhdXNlICYmCgkJdGVzdF9jbXAgZXhwZWN0ZWQgYWN0dWFsCgknCgogLSB0ZXN0X2xuX3NfYWRkIDxwYXRoMT4gPHBhdGgyPgoKICAgVGhpcyBmdW5jdGlvbiBoZWxwcyBzeXN0ZW1zIHdob3NlIGZpbGVzeXN0ZW0gZG9lcyBub3Qgc3VwcG9ydCBzeW1ib2xpYwogICBsaW5rcy4gVXNlIGl0IHRvIGFkZCBhIHN5bWJvbGljIGxpbmsgZW50cnkgdG8gdGhlIGluZGV4IHdoZW4gaXQgaXMgbm90CiAgIGltcG9ydGFudCB0aGF0IHRoZSBmaWxlIHN5c3RlbSBlbnRyeSBpcyBhIHN5bWJvbGljIGxpbmssIGkuZS4sIGluc3RlYWQKICAgb2YgdGhlIHNlcXVlbmNlCgoJbG4gLXMgZm9vIGJhciAmJgoJZ2l0IGFkZCBiYXIKCiAgIFNvbWV0aW1lcyBpdCBpcyBwb3NzaWJsZSB0byBzcGxpdCBhIHRlc3QgaW4gYSBwYXJ0IHRoYXQgZG9lcyBub3QgbmVlZAogICB0aGUgc3ltYm9saWMgbGluayBpbiB0aGUgZmlsZSBzeXN0ZW0gYW5kIGEgcGFydCB0aGF0IGRvZXM7IHRoZW4gb25seQogICB0aGUgbGF0dGVyIHBhcnQgbmVlZCBiZSBwcm90ZWN0ZWQgYnkgYSBTWU1MSU5LUyBwcmVyZXF1aXNpdGUgKHNlZSBiZWxvdykuCgpQcmVyZXF1aXNpdGVzCi0tLS0tLS0tLS0tLS0KClRoZXNlIGFyZSB0aGUgcHJlcmVxdWlzaXRlcyB0aGF0IHRoZSB0ZXN0IGxpYnJhcnkgcHJlZGVmaW5lcyB3aXRoCnRlc3RfaGF2ZV9wcmVyZXEuCgpTZWUgdGhlIHByZXJlcSBhcmd1bWVudCB0byB0aGUgdGVzdF8qIGZ1bmN0aW9ucyBpbiB0aGUgIlRlc3QgaGFybmVzcwpsaWJyYXJ5IiBzZWN0aW9uIGFib3ZlIGFuZCB0aGUgInRlc3RfaGF2ZV9wcmVyZXEiIGZ1bmN0aW9uIGZvciBob3cgdG8KdXNlIHRoZXNlLCBhbmQgInRlc3Rfc2V0X3ByZXJlcSIgZm9yIGhvdyB0byBkZWZpbmUgeW91ciBvd24uCgogLSBQWVRIT04KCiAgIEdpdCB3YXNuJ3QgY29tcGlsZWQgd2l0aCBOT19QWVRIT049WWVzUGxlYXNlLiBXcmFwIGFueSB0ZXN0cyB0aGF0CiAgIG5lZWQgUHl0aG9uIHdpdGggdGhpcy4KCiAtIFBFUkwKCiAgIEdpdCB3YXNuJ3QgY29tcGlsZWQgd2l0aCBOT19QRVJMPVllc1BsZWFzZS4KCiAgIEV2ZW4gd2l0aG91dCB0aGUgUEVSTCBwcmVyZXF1aXNpdGUsIHRlc3RzIGNhbiBhc3N1bWUgdGhlcmUgaXMgYQogICB1c2FibGUgcGVybCBpbnRlcnByZXRlciBhdCAkUEVSTF9QQVRILCB0aG91Z2ggaXQgbmVlZCBub3QgYmUKICAgcGFydGljdWxhcmx5IG1vZGVybi4KCiAtIFBPU0lYUEVSTQoKICAgVGhlIGZpbGVzeXN0ZW0gc3VwcG9ydHMgUE9TSVggc3R5bGUgcGVybWlzc2lvbiBiaXRzLgoKIC0gQlNMQVNIUFNQRUMKCiAgIEJhY2tzbGFzaGVzIGluIHBhdGhzcGVjIGFyZSBub3QgZGlyZWN0b3J5IHNlcGFyYXRvcnMuIFRoaXMgaXMgbm90CiAgIHNldCBvbiBXaW5kb3dzLiBTZWUgNmZkMTEwNmEgZm9yIGRldGFpbHMuCgogLSBFWEVDS0VFUFNQSUQKCiAgIFRoZSBwcm9jZXNzIHJldGFpbnMgdGhlIHNhbWUgcGlkIGFjcm9zcyBleGVjKDIpLiBTZWUgZmI5YTJiZWEgZm9yCiAgIGRldGFpbHMuCgogLSBQSVBFCgogICBUaGUgZmlsZXN5c3RlbSB3ZSdyZSBvbiBzdXBwb3J0cyBjcmVhdGlvbiBvZiBGSUZPcyAobmFtZWQgcGlwZXMpCiAgIHZpYSBta2ZpZm8oMSkuCgogLSBTWU1MSU5LUwoKICAgVGhlIGZpbGVzeXN0ZW0gd2UncmUgb24gc3VwcG9ydHMgc3ltYm9saWMgbGlua3MuIEUuZy4gYSBGQVQKICAgZmlsZXN5c3RlbSBkb2Vzbid0IHN1cHBvcnQgdGhlc2UuIFNlZSA3MDRhMzE0MyBmb3IgZGV0YWlscy4KCiAtIFNBTklUWQoKICAgVGVzdCBpcyBub3QgcnVuIGJ5IHJvb3QgdXNlciwgYW5kIGFuIGF0dGVtcHQgdG8gd3JpdGUgdG8gYW4KICAgdW53cml0YWJsZSBmaWxlIGlzIGV4cGVjdGVkIHRvIGZhaWwgY29ycmVjdGx5LgoKIC0gTElCUENSRQoKICAgR2l0IHdhcyBjb21waWxlZCB3aXRoIFVTRV9MSUJQQ1JFPVllc1BsZWFzZS4gV3JhcCBhbnkgdGVzdHMKICAgdGhhdCB1c2UgZ2l0LWdyZXAgLS1wZXJsLXJlZ2V4cCBvciBnaXQtZ3JlcCAtUCBpbiB0aGVzZS4KCiAtIENBU0VfSU5TRU5TSVRJVkVfRlMKCiAgIFRlc3QgaXMgcnVuIG9uIGEgY2FzZSBpbnNlbnNpdGl2ZSBmaWxlIHN5c3RlbS4KCiAtIFVURjhfTkZEX1RPX05GQwoKICAgVGVzdCBpcyBydW4gb24gYSBmaWxlc3lzdGVtIHdoaWNoIGNvbnZlcnRzIGRlY29tcG9zZWQgdXRmLTggKG5mZCkKICAgdG8gcHJlY29tcG9zZWQgdXRmLTggKG5mYykuCgpUaXBzIGZvciBXcml0aW5nIFRlc3RzCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCkFzIHdpdGggYW55IHByb2dyYW1taW5nIHByb2plY3RzLCBleGlzdGluZyBwcm9ncmFtcyBhcmUgdGhlIGJlc3QKc291cmNlIG9mIHRoZSBpbmZvcm1hdGlvbi4gIEhvd2V2ZXIsIGRvIF9ub3RfIGVtdWxhdGUKdDAwMDAtYmFzaWMuc2ggd2hlbiB3cml0aW5nIHlvdXIgdGVzdHMuICBUaGUgdGVzdCBpcyBzcGVjaWFsIGluCnRoYXQgaXQgdHJpZXMgdG8gdmFsaWRhdGUgdGhlIHZlcnkgY29yZSBvZiBHSVQuICBGb3IgZXhhbXBsZSwgaXQKa25vd3MgdGhhdCB0aGVyZSB3aWxsIGJlIDI1NiBzdWJkaXJlY3RvcmllcyB1bmRlciAuZ2l0L29iamVjdHMvLAphbmQgaXQga25vd3MgdGhhdCB0aGUgb2JqZWN0IElEIG9mIGFuIGVtcHR5IHRyZWUgaXMgYSBjZXJ0YWluCjQwLWJ5dGUgc3RyaW5nLiAgVGhpcyBpcyBkZWxpYmVyYXRlbHkgZG9uZSBzbyBpbiB0MDAwMC1iYXNpYy5zaApiZWNhdXNlIHRoZSB0aGluZ3MgdGhlIHZlcnkgYmFzaWMgY29yZSB0ZXN0IHRyaWVzIHRvIGFjaGlldmUgaXMKdG8gc2VydmUgYXMgYSBiYXNpcyBmb3IgcGVvcGxlIHdobyBhcmUgY2hhbmdpbmcgdGhlIEdJVCBpbnRlcm5hbApkcmFzdGljYWxseS4gIEZvciB0aGVzZSBwZW9wbGUsIGFmdGVyIG1ha2luZyBjZXJ0YWluIGNoYW5nZXMsCm5vdCBzZWVpbmcgZmFpbHVyZXMgZnJvbSB0aGUgYmFzaWMgdGVzdCBfaXNfIGEgZmFpbHVyZS4gIEFuZApzdWNoIGRyYXN0aWMgY2hhbmdlcyB0byB0aGUgY29yZSBHSVQgdGhhdCBldmVuIGNoYW5nZXMgdGhlc2UKb3RoZXJ3aXNlIHN1cHBvc2VkbHkgc3RhYmxlIG9iamVjdCBJRHMgc2hvdWxkIGJlIGFjY29tcGFuaWVkIGJ5CmFuIHVwZGF0ZSB0byB0MDAwMC1iYXNpYy5zaC4KCkhvd2V2ZXIsIG90aGVyIHRlc3RzIHRoYXQgc2ltcGx5IHJlbHkgb24gYmFzaWMgcGFydHMgb2YgdGhlIGNvcmUKR0lUIHdvcmtpbmcgcHJvcGVybHkgc2hvdWxkIG5vdCBoYXZlIHRoYXQgbGV2ZWwgb2YgaW50aW1hdGUKa25vd2xlZGdlIG9mIHRoZSBjb3JlIEdJVCBpbnRlcm5hbHMuICBJZiBhbGwgdGhlIHRlc3Qgc2NyaXB0cwpoYXJkY29kZWQgdGhlIG9iamVjdCBJRHMgbGlrZSB0MDAwMC1iYXNpYy5zaCBkb2VzLCB0aGF0IGRlZmVhdHMKdGhlIHB1cnBvc2Ugb2YgdDAwMDAtYmFzaWMuc2gsIHdoaWNoIGlzIHRvIGlzb2xhdGUgdGhhdCBsZXZlbCBvZgp2YWxpZGF0aW9uIGluIG9uZSBwbGFjZS4gIFlvdXIgdGVzdCBhbHNvIGVuZHMgdXAgbmVlZGluZwp1cGRhdGluZyB3aGVuIHN1Y2ggYSBjaGFuZ2UgdG8gdGhlIGludGVybmFsIGhhcHBlbnMsIHNvIGRvIF9ub3RfCmRvIGl0IGFuZCBsZWF2ZSB0aGUgbG93IGxldmVsIG9mIHZhbGlkYXRpb24gdG8gdDAwMDAtYmFzaWMuc2guCgpUZXN0IGNvdmVyYWdlCi0tLS0tLS0tLS0tLS0KCllvdSBjYW4gdXNlIHRoZSBjb3ZlcmFnZSB0ZXN0cyB0byBmaW5kIGNvZGUgcGF0aHMgdGhhdCBhcmUgbm90IGJlaW5nCnVzZWQgb3IgcHJvcGVybHkgZXhlcmNpc2VkIHlldC4KClRvIGRvIHRoYXQsIHJ1biB0aGUgY292ZXJhZ2UgdGFyZ2V0IGF0IHRoZSB0b3AtbGV2ZWwgKG5vdCBpbiB0aGUgdC8KZGlyZWN0b3J5KToKCiAgICBtYWtlIGNvdmVyYWdlCgpUaGF0J2xsIGNvbXBpbGUgR2l0IHdpdGggR0NDJ3MgY292ZXJhZ2UgYXJndW1lbnRzLCBhbmQgZ2VuZXJhdGUgYSB0ZXN0CnJlcG9ydCB3aXRoIGdjb3YgYWZ0ZXIgdGhlIHRlc3RzIGZpbmlzaC4gUnVubmluZyB0aGUgY292ZXJhZ2UgdGVzdHMKY2FuIHRha2UgYSB3aGlsZSwgc2luY2UgcnVubmluZyB0aGUgdGVzdHMgaW4gcGFyYWxsZWwgaXMgaW5jb21wYXRpYmxlCndpdGggR0NDJ3MgY292ZXJhZ2UgbW9kZS4KCkFmdGVyIHRoZSB0ZXN0cyBoYXZlIHJ1biB5b3UgY2FuIGdlbmVyYXRlIGEgbGlzdCBvZiB1bnRlc3RlZApmdW5jdGlvbnM6CgogICAgbWFrZSBjb3ZlcmFnZS11bnRlc3RlZC1mdW5jdGlvbnMKCllvdSBjYW4gYWxzbyBnZW5lcmF0ZSBhIGRldGFpbGVkIHBlci1maWxlIEhUTUwgcmVwb3J0IHVzaW5nIHRoZQpEZXZlbDo6Q292ZXIgbW9kdWxlLiBUbyBpbnN0YWxsIGl0IGRvOgoKICAgIyBPbiBEZWJpYW4gb3IgVWJ1bnR1OgogICBzdWRvIGFwdGl0dWRlIGluc3RhbGwgbGliZGV2ZWwtY292ZXItcGVybAoKICAgIyBGcm9tIHRoZSBDUEFOIHdpdGggY3Bhbm1pbnVzCiAgIGN1cmwgLUwgaHR0cDovL2NwYW5taW4udXMgfCBwZXJsIC0gLS1zdWRvIC0tc2VsZi11cGdyYWRlCiAgIGNwYW5tIC0tc3VkbyBEZXZlbDo6Q292ZXIKClRoZW4sIGF0IHRoZSB0b3AtbGV2ZWw6CgogICAgbWFrZSBjb3Zlcl9kYl9odG1sCgpUaGF0J2xsIGdlbmVyYXRlIGEgZGV0YWlsZWQgY292ZXIgcmVwb3J0IGluIHRoZSAiY292ZXJfZGJfaHRtbCIKZGlyZWN0b3J5LCB3aGljaCB5b3UgY2FuIHRoZW4gY29weSB0byBhIHdlYnNlcnZlciwgb3IgaW5zcGVjdCBsb2NhbGx5CmluIGEgYnJvd3Nlci4K",
    "text": "Core GIT Tests\n==============\n\nThis directory holds many test scripts for core GIT tools.  The\nfirst part of this short document describes how to run the tests\nand read their output.\n\nWhen fixing the tools or adding enhancements, you are strongly\nencouraged to add tests in this directory to cover what you are\ntrying to fix or enhance.  The later part of this short document\ndescribes how your test scripts should be organized.\n\n\nRunning Tests\n-------------\n\nThe easiest way to run tests is to say \"make\".  This runs all\nthe tests.\n\n    *** t0000-basic.sh ***\n    ok 1 - .git/objects should be empty after git init in an empty repo.\n    ok 2 - .git/objects should have 3 subdirectories.\n    ok 3 - success is reported like this\n    ...\n    ok 43 - very long name in the index handled sanely\n    # fixed 1 known breakage(s)\n    # still have 1 known breakage(s)\n    # passed all remaining 42 test(s)\n    1..43\n    *** t0001-init.sh ***\n    ok 1 - plain\n    ok 2 - plain with GIT_WORK_TREE\n    ok 3 - plain bare\n\nSince the tests all output TAP (see http://testanything.org) they can\nbe run with any TAP harness. Here's an example of parallel testing\npowered by a recent version of prove(1):\n\n    $ prove --timer --jobs 15 ./t[0-9]*.sh\n    [19:17:33] ./t0005-signals.sh ................................... ok       36 ms\n    [19:17:33] ./t0022-crlf-rename.sh ............................... ok       69 ms\n    [19:17:33] ./t0024-crlf-archive.sh .............................. ok      154 ms\n    [19:17:33] ./t0004-unwritable.sh ................................ ok      289 ms\n    [19:17:33] ./t0002-gitfile.sh ................................... ok      480 ms\n    ===(     102;0  25/?  6/?  5/?  16/?  1/?  4/?  2/?  1/?  3/?  1... )===\n\nprove and other harnesses come with a lot of useful options. The\n--state option in particular is very useful:\n\n    # Repeat until no more failures\n    $ prove -j 15 --state=failed,save ./t[0-9]*.sh\n\nYou can give DEFAULT_TEST_TARGET=prove on the make command (or define it\nin config.mak) to cause \"make test\" to run tests under prove.\nGIT_PROVE_OPTS can be used to pass additional options, e.g.\n\n    $ make DEFAULT_TEST_TARGET=prove GIT_PROVE_OPTS='--timer --jobs 16' test\n\nYou can also run each test individually from command line, like this:\n\n    $ sh ./t3010-ls-files-killed-modified.sh\n    ok 1 - git update-index --add to add various paths.\n    ok 2 - git ls-files -k to show killed files.\n    ok 3 - validate git ls-files -k output.\n    ok 4 - git ls-files -m to show modified files.\n    ok 5 - validate git ls-files -m output.\n    # passed all 5 test(s)\n    1..5\n\nYou can pass --verbose (or -v), --debug (or -d), and --immediate\n(or -i) command line argument to the test, or by setting GIT_TEST_OPTS\nappropriately before running \"make\".\n\n-v::\n--verbose::\n\tThis makes the test more verbose.  Specifically, the\n\tcommand being run and their output if any are also\n\toutput.\n\n--verbose-only=<pattern>::\n\tLike --verbose, but the effect is limited to tests with\n\tnumbers matching <pattern>.  The number matched against is\n\tsimply the running count of the test within the file.\n\n-x::\n\tTurn on shell tracing (i.e., `set -x`) during the tests\n\tthemselves. Implies `--verbose`. Note that in non-bash shells,\n\tthis can cause failures in some tests which redirect and test\n\tthe output of shell functions. Use with caution.\n\n-d::\n--debug::\n\tThis may help the person who is developing a new test.\n\tIt causes the command defined with test_debug to run.\n\tThe \"trash\" directory (used to store all temporary data\n\tduring testing) is not deleted even if there are no\n\tfailed tests so that you can inspect its contents after\n\tthe test finished.\n\n-i::\n--immediate::\n\tThis causes the test to immediately exit upon the first\n\tfailed test. Cleanup commands requested with\n\ttest_when_finished are not executed if the test failed,\n\tin order to keep the state for inspection by the tester\n\tto diagnose the bug.\n\n-l::\n--long-tests::\n\tThis causes additional long-running tests to be run (where\n\tavailable), for more exhaustive testing.\n\n-r::\n--run=<test-selector>::\n\tRun only the subset of tests indicated by\n\t<test-selector>.  See section \"Skipping Tests\" below for\n\t<test-selector> syntax.\n\n--valgrind=<tool>::\n\tExecute all Git binaries under valgrind tool <tool> and exit\n\twith status 126 on errors (just like regular tests, this will\n\tonly stop the test script when running under -i).\n\n\tSince it makes no sense to run the tests with --valgrind and\n\tnot see any output, this option implies --verbose.  For\n\tconvenience, it also implies --tee.\n\n\t<tool> defaults to 'memcheck', just like valgrind itself.\n\tOther particularly useful choices include 'helgrind' and\n\t'drd', but you may use any tool recognized by your valgrind\n\tinstallation.\n\n\tAs a special case, <tool> can be 'memcheck-fast', which uses\n\tmemcheck but disables --track-origins.  Use this if you are\n\trunning tests in bulk, to see if there are _any_ memory\n\tissues.\n\n\tNote that memcheck is run with the option --leak-check=no,\n\tas the git process is short-lived and some errors are not\n\tinteresting. In order to run a single command under the same\n\tconditions manually, you should set GIT_VALGRIND to point to\n\tthe 't/valgrind/' directory and use the commands under\n\t't/valgrind/bin/'.\n\n--valgrind-only=<pattern>::\n\tLike --valgrind, but the effect is limited to tests with\n\tnumbers matching <pattern>.  The number matched against is\n\tsimply the running count of the test within the file.\n\n--tee::\n\tIn addition to printing the test output to the terminal,\n\twrite it to files named 't/test-results/$TEST_NAME.out'.\n\tAs the names depend on the tests' file names, it is safe to\n\trun the tests with this option in parallel.\n\n--with-dashes::\n\tBy default tests are run without dashed forms of\n\tcommands (like git-commit) in the PATH (it only uses\n\twrappers from ../bin-wrappers).  Use this option to include\n\tthe build directory (..) in the PATH, which contains all\n\tthe dashed forms of commands.  This option is currently\n\timplied by other options like --valgrind and\n\tGIT_TEST_INSTALLED.\n\n--root=<directory>::\n\tCreate \"trash\" directories used to store all temporary data during\n\ttesting under <directory>, instead of the t/ directory.\n\tUsing this option with a RAM-based filesystem (such as tmpfs)\n\tcan massively speed up the test suite.\n\n--chain-lint::\n--no-chain-lint::\n\tIf --chain-lint is enabled, the test harness will check each\n\ttest to make sure that it properly \"&&-chains\" all commands (so\n\tthat a failure in the middle does not go unnoticed by the final\n\texit code of the test). This check is performed in addition to\n\trunning the tests themselves. You may also enable or disable\n\tthis feature by setting the GIT_TEST_CHAIN_LINT environment\n\tvariable to \"1\" or \"0\", respectively.\n\nYou can also set the GIT_TEST_INSTALLED environment variable to\nthe bindir of an existing git installation to test that installation.\nYou still need to have built this git sandbox, from which various\ntest-* support programs, templates, and perl libraries are used.\nIf your installed git is incomplete, it will silently test parts of\nyour built version instead.\n\nWhen using GIT_TEST_INSTALLED, you can also set GIT_TEST_EXEC_PATH to\noverride the location of the dashed-form subcommands (what\nGIT_EXEC_PATH would be used for during normal operation).\nGIT_TEST_EXEC_PATH defaults to `$GIT_TEST_INSTALLED/git --exec-path`.\n\n\nSkipping Tests\n--------------\n\nIn some environments, certain tests have no way of succeeding\ndue to platform limitation, such as lack of 'unzip' program, or\nfilesystem that do not allow arbitrary sequence of non-NUL bytes\nas pathnames.\n\nYou should be able to say something like\n\n    $ GIT_SKIP_TESTS=t9200.8 sh ./t9200-git-cvsexport-commit.sh\n\nand even:\n\n    $ GIT_SKIP_TESTS='t[0-4]??? t91?? t9200.8' make\n\nto omit such tests.  The value of the environment variable is a\nSP separated list of patterns that tells which tests to skip,\nand either can match the \"t[0-9]{4}\" part to skip the whole\ntest, or t[0-9]{4} followed by \".$number\" to say which\nparticular test to skip.\n\nFor an individual test suite --run could be used to specify that\nonly some tests should be run or that some tests should be\nexcluded from a run.\n\nThe argument for --run is a list of individual test numbers or\nranges with an optional negation prefix that define what tests in\na test suite to include in the run.  A range is two numbers\nseparated with a dash and matches a range of tests with both ends\nbeen included.  You may omit the first or the second number to\nmean \"from the first test\" or \"up to the very last test\"\nrespectively.\n\nOptional prefix of '!' means that the test or a range of tests\nshould be excluded from the run.\n\nIf --run starts with an unprefixed number or range the initial\nset of tests to run is empty. If the first item starts with '!'\nall the tests are added to the initial set.  After initial set is\ndetermined every test number or range is added or excluded from\nthe set one by one, from left to right.\n\nIndividual numbers or ranges could be separated either by a space\nor a comma.\n\nFor example, to run only tests up to a specific test (21), one\ncould do this:\n\n    $ sh ./t9200-git-cvsexport-commit.sh --run='1-21'\n\nor this:\n\n    $ sh ./t9200-git-cvsexport-commit.sh --run='-21'\n\nCommon case is to run several setup tests (1, 2, 3) and then a\nspecific test (21) that relies on that setup:\n\n    $ sh ./t9200-git-cvsexport-commit.sh --run='1 2 3 21'\n\nor:\n\n    $ sh ./t9200-git-cvsexport-commit.sh --run=1,2,3,21\n\nor:\n\n    $ sh ./t9200-git-cvsexport-commit.sh --run='-3 21'\n\nAs noted above, the test set is built going though items left to\nright, so this:\n\n    $ sh ./t9200-git-cvsexport-commit.sh --run='1-4 !3'\n\nwill run tests 1, 2, and 4.  Items that comes later have higher\nprecendence.  It means that this:\n\n    $ sh ./t9200-git-cvsexport-commit.sh --run='!3 1-4'\n\nwould just run tests from 1 to 4, including 3.\n\nYou may use negation with ranges.  The following will run all\ntest in the test suite except from 7 up to 11:\n\n    $ sh ./t9200-git-cvsexport-commit.sh --run='!7-11'\n\nSome tests in a test suite rely on the previous tests performing\ncertain actions, specifically some tests are designated as\n\"setup\" test, so you cannot _arbitrarily_ disable one test and\nexpect the rest to function correctly.\n\n--run is mostly useful when you want to focus on a specific test\nand know what setup is needed for it.  Or when you want to run\neverything up to a certain test.\n\n\nNaming Tests\n------------\n\nThe test files are named as:\n\n\ttNNNN-commandname-details.sh\n\nwhere N is a decimal digit.\n\nFirst digit tells the family:\n\n\t0 - the absolute basics and global stuff\n\t1 - the basic commands concerning database\n\t2 - the basic commands concerning the working tree\n\t3 - the other basic commands (e.g. ls-files)\n\t4 - the diff commands\n\t5 - the pull and exporting commands\n\t6 - the revision tree commands (even e.g. merge-base)\n\t7 - the porcelainish commands concerning the working tree\n\t8 - the porcelainish commands concerning forensics\n\t9 - the git tools\n\nSecond digit tells the particular command we are testing.\n\nThird digit (optionally) tells the particular switch or group of switches\nwe are testing.\n\nIf you create files under t/ directory (i.e. here) that is not\nthe top-level test script, never name the file to match the above\npattern.  The Makefile here considers all such files as the\ntop-level test script and tries to run all of them.  Care is\nespecially needed if you are creating a common test library\nfile, similar to test-lib.sh, because such a library file may\nnot be suitable for standalone execution.\n\n\nWriting Tests\n-------------\n\nThe test script is written as a shell script.  It should start\nwith the standard \"#!/bin/sh\" with copyright notices, and an\nassignment to variable 'test_description', like this:\n\n\t#!/bin/sh\n\t#\n\t# Copyright (c) 2005 Junio C Hamano\n\t#\n\n\ttest_description='xxx test (option --frotz)\n\n\tThis test registers the following structure in the cache\n\tand tries to run git-ls-files with option --frotz.'\n\n\nSource 'test-lib.sh'\n--------------------\n\nAfter assigning test_description, the test script should source\ntest-lib.sh like this:\n\n\t. ./test-lib.sh\n\nThis test harness library does the following things:\n\n - If the script is invoked with command line argument --help\n   (or -h), it shows the test_description and exits.\n\n - Creates an empty test directory with an empty .git/objects database\n   and chdir(2) into it.  This directory is 't/trash\n   directory.$test_name_without_dotsh', with t/ subject to change by\n   the --root option documented above.\n\n - Defines standard test helper functions for your scripts to\n   use.  These functions are designed to make all scripts behave\n   consistently when command line arguments --verbose (or -v),\n   --debug (or -d), and --immediate (or -i) is given.\n\nDo's, don'ts & things to keep in mind\n-------------------------------------\n\nHere are a few examples of things you probably should and shouldn't do\nwhen writing tests.\n\nDo:\n\n - Put all code inside test_expect_success and other assertions.\n\n   Even code that isn't a test per se, but merely some setup code\n   should be inside a test assertion.\n\n - Chain your test assertions\n\n   Write test code like this:\n\n\tgit merge foo &&\n\tgit push bar &&\n\ttest ...\n\n   Instead of:\n\n\tgit merge hla\n\tgit push gh\n\ttest ...\n\n   That way all of the commands in your tests will succeed or fail. If\n   you must ignore the return value of something, consider using a\n   helper function (e.g. use sane_unset instead of unset, in order\n   to avoid unportable return value for unsetting a variable that was\n   already unset), or prepending the command with test_might_fail or\n   test_must_fail.\n\n - Check the test coverage for your tests. See the \"Test coverage\"\n   below.\n\n   Don't blindly follow test coverage metrics; if a new function you added\n   doesn't have any coverage, then you're probably doing something wrong,\n   but having 100% coverage doesn't necessarily mean that you tested\n   everything.\n\n   Tests that are likely to smoke out future regressions are better\n   than tests that just inflate the coverage metrics.\n\n - When a test checks for an absolute path that a git command generated,\n   construct the expected value using $(pwd) rather than $PWD,\n   $TEST_DIRECTORY, or $TRASH_DIRECTORY. It makes a difference on\n   Windows, where the shell (MSYS bash) mangles absolute path names.\n   For details, see the commit message of 4114156ae9.\n\nDon't:\n\n - exit() within a <script> part.\n\n   The harness will catch this as a programming error of the test.\n   Use test_done instead if you need to stop the tests early (see\n   \"Skipping tests\" below).\n\n - use '! git cmd' when you want to make sure the git command exits\n   with failure in a controlled way by calling \"die()\".  Instead,\n   use 'test_must_fail git cmd'.  This will signal a failure if git\n   dies in an unexpected way (e.g. segfault).\n\n   On the other hand, don't use test_must_fail for running regular\n   platform commands; just use '! cmd'.  We are not in the business\n   of verifying that the world given to us sanely works.\n\n - use perl without spelling it as \"$PERL_PATH\". This is to help our\n   friends on Windows where the platform Perl often adds CR before\n   the end of line, and they bundle Git with a version of Perl that\n   does not do so, whose path is specified with $PERL_PATH. Note that we\n   provide a \"perl\" function which uses $PERL_PATH under the hood, so\n   you do not need to worry when simply running perl in the test scripts\n   (but you do, for example, on a shebang line or in a sub script\n   created via \"write_script\").\n\n - use sh without spelling it as \"$SHELL_PATH\", when the script can\n   be misinterpreted by broken platform shell (e.g. Solaris).\n\n - chdir around in tests.  It is not sufficient to chdir to\n   somewhere and then chdir back to the original location later in\n   the test, as any intermediate step can fail and abort the test,\n   causing the next test to start in an unexpected directory.  Do so\n   inside a subshell if necessary.\n\n - Break the TAP output\n\n   The raw output from your test may be interpreted by a TAP harness. TAP\n   harnesses will ignore everything they don't know about, but don't step\n   on their toes in these areas:\n\n   - Don't print lines like \"$x..$y\" where $x and $y are integers.\n\n   - Don't print lines that begin with \"ok\" or \"not ok\".\n\n   TAP harnesses expect a line that begins with either \"ok\" and \"not\n   ok\" to signal a test passed or failed (and our harness already\n   produces such lines), so your script shouldn't emit such lines to\n   their output.\n\n   You can glean some further possible issues from the TAP grammar\n   (see http://search.cpan.org/perldoc?TAP::Parser::Grammar#TAP_Grammar)\n   but the best indication is to just run the tests with prove(1),\n   it'll complain if anything is amiss.\n\nKeep in mind:\n\n - Inside <script> part, the standard output and standard error\n   streams are discarded, and the test harness only reports \"ok\" or\n   \"not ok\" to the end user running the tests. Under --verbose, they\n   are shown to help debugging the tests.\n\n\nSkipping tests\n--------------\n\nIf you need to skip tests you should do so by using the three-arg form\nof the test_* functions (see the \"Test harness library\" section\nbelow), e.g.:\n\n    test_expect_success PERL 'I need Perl' '\n        perl -e \"hlagh() if unf_unf()\"\n    '\n\nThe advantage of skipping tests like this is that platforms that don't\nhave the PERL and other optional dependencies get an indication of how\nmany tests they're missing.\n\nIf the test code is too hairy for that (i.e. does a lot of setup work\noutside test assertions) you can also skip all remaining tests by\nsetting skip_all and immediately call test_done:\n\n\tif ! test_have_prereq PERL\n\tthen\n\t    skip_all='skipping perl interface tests, perl not available'\n\t    test_done\n\tfi\n\nThe string you give to skip_all will be used as an explanation for why\nthe test was skipped.\n\nEnd with test_done\n------------------\n\nYour script will be a sequence of tests, using helper functions\nfrom the test harness library.  At the end of the script, call\n'test_done'.\n\n\nTest harness library\n--------------------\n\nThere are a handful helper functions defined in the test harness\nlibrary for your script to use.\n\n - test_expect_success [<prereq>] <message> <script>\n\n   Usually takes two strings as parameters, and evaluates the\n   <script>.  If it yields success, test is considered\n   successful.  <message> should state what it is testing.\n\n   Example:\n\n\ttest_expect_success \\\n\t    'git-write-tree should be able to write an empty tree.' \\\n\t    'tree=$(git-write-tree)'\n\n   If you supply three parameters the first will be taken to be a\n   prerequisite; see the test_set_prereq and test_have_prereq\n   documentation below:\n\n\ttest_expect_success TTY 'git --paginate rev-list uses a pager' \\\n\t    ' ... '\n\n   You can also supply a comma-separated list of prerequisites, in the\n   rare case where your test depends on more than one:\n\n\ttest_expect_success PERL,PYTHON 'yo dawg' \\\n\t    ' test $(perl -E 'print eval \"1 +\" . qx[python -c \"print 2\"]') == \"4\" '\n\n - test_expect_failure [<prereq>] <message> <script>\n\n   This is NOT the opposite of test_expect_success, but is used\n   to mark a test that demonstrates a known breakage.  Unlike\n   the usual test_expect_success tests, which say \"ok\" on\n   success and \"FAIL\" on failure, this will say \"FIXED\" on\n   success and \"still broken\" on failure.  Failures from these\n   tests won't cause -i (immediate) to stop.\n\n   Like test_expect_success this function can optionally use a three\n   argument invocation with a prerequisite as the first argument.\n\n - test_debug <script>\n\n   This takes a single argument, <script>, and evaluates it only\n   when the test script is started with --debug command line\n   argument.  This is primarily meant for use during the\n   development of a new test script.\n\n - test_done\n\n   Your test script must have test_done at the end.  Its purpose\n   is to summarize successes and failures in the test script and\n   exit with an appropriate error code.\n\n - test_tick\n\n   Make commit and tag names consistent by setting the author and\n   committer times to defined state.  Subsequent calls will\n   advance the times by a fixed amount.\n\n - test_commit <message> [<filename> [<contents>]]\n\n   Creates a commit with the given message, committing the given\n   file with the given contents (default for both is to reuse the\n   message string), and adds a tag (again reusing the message\n   string as name).  Calls test_tick to make the SHA-1s\n   reproducible.\n\n - test_merge <message> <commit-or-tag>\n\n   Merges the given rev using the given message.  Like test_commit,\n   creates a tag and calls test_tick before committing.\n\n - test_set_prereq <prereq>\n\n   Set a test prerequisite to be used later with test_have_prereq. The\n   test-lib will set some prerequisites for you, see the\n   \"Prerequisites\" section below for a full list of these.\n\n   Others you can set yourself and use later with either\n   test_have_prereq directly, or the three argument invocation of\n   test_expect_success and test_expect_failure.\n\n - test_have_prereq <prereq>\n\n   Check if we have a prerequisite previously set with\n   test_set_prereq. The most common use of this directly is to skip\n   all the tests if we don't have some essential prerequisite:\n\n\tif ! test_have_prereq PERL\n\tthen\n\t    skip_all='skipping perl interface tests, perl not available'\n\t    test_done\n\tfi\n\n - test_external [<prereq>] <message> <external> <script>\n\n   Execute a <script> with an <external> interpreter (like perl). This\n   was added for tests like t9700-perl-git.sh which do most of their\n   work in an external test script.\n\n\ttest_external \\\n\t    'GitwebCache::*FileCache*' \\\n\t    perl \"$TEST_DIRECTORY\"/t9503/test_cache_interface.pl\n\n   If the test is outputting its own TAP you should set the\n   test_external_has_tap variable somewhere before calling the first\n   test_external* function. See t9700-perl-git.sh for an example.\n\n\t# The external test will outputs its own plan\n\ttest_external_has_tap=1\n\n - test_external_without_stderr [<prereq>] <message> <external> <script>\n\n   Like test_external but fail if there's any output on stderr,\n   instead of checking the exit code.\n\n\ttest_external_without_stderr \\\n\t    'Perl API' \\\n\t    perl \"$TEST_DIRECTORY\"/t9700/test.pl\n\n - test_expect_code <exit-code> <command>\n\n   Run a command and ensure that it exits with the given exit code.\n   For example:\n\n\ttest_expect_success 'Merge with d/f conflicts' '\n\t\ttest_expect_code 1 git merge \"merge msg\" B master\n\t'\n\n - test_must_fail <git-command>\n\n   Run a git command and ensure it fails in a controlled way.  Use\n   this instead of \"! <git-command>\".  When git-command dies due to a\n   segfault, test_must_fail diagnoses it as an error; \"! <git-command>\"\n   treats it as just another expected failure, which would let such a\n   bug go unnoticed.\n\n - test_might_fail <git-command>\n\n   Similar to test_must_fail, but tolerate success, too.  Use this\n   instead of \"<git-command> || :\" to catch failures due to segv.\n\n - test_cmp <expected> <actual>\n\n   Check whether the content of the <actual> file matches the\n   <expected> file.  This behaves like \"cmp\" but produces more\n   helpful output when the test is run with \"-v\" option.\n\n - test_line_count (= | -lt | -ge | ...) <length> <file>\n\n   Check whether a file has the length it is expected to.\n\n - test_path_is_file <path> [<diagnosis>]\n   test_path_is_dir <path> [<diagnosis>]\n   test_path_is_missing <path> [<diagnosis>]\n\n   Check if the named path is a file, if the named path is a\n   directory, or if the named path does not exist, respectively,\n   and fail otherwise, showing the <diagnosis> text.\n\n - test_when_finished <script>\n\n   Prepend <script> to a list of commands to run to clean up\n   at the end of the current test.  If some clean-up command\n   fails, the test will not pass.\n\n   Example:\n\n\ttest_expect_success 'branch pointing to non-commit' '\n\t\tgit rev-parse HEAD^{tree} >.git/refs/heads/invalid &&\n\t\ttest_when_finished \"git update-ref -d refs/heads/invalid\" &&\n\t\t...\n\t'\n\n - test_write_lines <lines>\n\n   Write <lines> on standard output, one line per argument.\n   Useful to prepare multi-line files in a compact form.\n\n   Example:\n\n\ttest_write_lines a b c d e f g >foo\n\n   Is a more compact equivalent of:\n\tcat >foo <<-EOF\n\ta\n\tb\n\tc\n\td\n\te\n\tf\n\tg\n\tEOF\n\n\n - test_pause\n\n\tThis command is useful for writing and debugging tests and must be\n\tremoved before submitting. It halts the execution of the test and\n\tspawns a shell in the trash directory. Exit the shell to continue\n\tthe test. Example:\n\n\ttest_expect_success 'test' '\n\t\tgit do-something >actual &&\n\t\ttest_pause &&\n\t\ttest_cmp expected actual\n\t'\n\n - test_ln_s_add <path1> <path2>\n\n   This function helps systems whose filesystem does not support symbolic\n   links. Use it to add a symbolic link entry to the index when it is not\n   important that the file system entry is a symbolic link, i.e., instead\n   of the sequence\n\n\tln -s foo bar &&\n\tgit add bar\n\n   Sometimes it is possible to split a test in a part that does not need\n   the symbolic link in the file system and a part that does; then only\n   the latter part need be protected by a SYMLINKS prerequisite (see below).\n\nPrerequisites\n-------------\n\nThese are the prerequisites that the test library predefines with\ntest_have_prereq.\n\nSee the prereq argument to the test_* functions in the \"Test harness\nlibrary\" section above and the \"test_have_prereq\" function for how to\nuse these, and \"test_set_prereq\" for how to define your own.\n\n - PYTHON\n\n   Git wasn't compiled with NO_PYTHON=YesPlease. Wrap any tests that\n   need Python with this.\n\n - PERL\n\n   Git wasn't compiled with NO_PERL=YesPlease.\n\n   Even without the PERL prerequisite, tests can assume there is a\n   usable perl interpreter at $PERL_PATH, though it need not be\n   particularly modern.\n\n - POSIXPERM\n\n   The filesystem supports POSIX style permission bits.\n\n - BSLASHPSPEC\n\n   Backslashes in pathspec are not directory separators. This is not\n   set on Windows. See 6fd1106a for details.\n\n - EXECKEEPSPID\n\n   The process retains the same pid across exec(2). See fb9a2bea for\n   details.\n\n - PIPE\n\n   The filesystem we're on supports creation of FIFOs (named pipes)\n   via mkfifo(1).\n\n - SYMLINKS\n\n   The filesystem we're on supports symbolic links. E.g. a FAT\n   filesystem doesn't support these. See 704a3143 for details.\n\n - SANITY\n\n   Test is not run by root user, and an attempt to write to an\n   unwritable file is expected to fail correctly.\n\n - LIBPCRE\n\n   Git was compiled with USE_LIBPCRE=YesPlease. Wrap any tests\n   that use git-grep --perl-regexp or git-grep -P in these.\n\n - CASE_INSENSITIVE_FS\n\n   Test is run on a case insensitive file system.\n\n - UTF8_NFD_TO_NFC\n\n   Test is run on a filesystem which converts decomposed utf-8 (nfd)\n   to precomposed utf-8 (nfc).\n\nTips for Writing Tests\n----------------------\n\nAs with any programming projects, existing programs are the best\nsource of the information.  However, do _not_ emulate\nt0000-basic.sh when writing your tests.  The test is special in\nthat it tries to validate the very core of GIT.  For example, it\nknows that there will be 256 subdirectories under .git/objects/,\nand it knows that the object ID of an empty tree is a certain\n40-byte string.  This is deliberately done so in t0000-basic.sh\nbecause the things the very basic core test tries to achieve is\nto serve as a basis for people who are changing the GIT internal\ndrastically.  For these people, after making certain changes,\nnot seeing failures from the basic test _is_ a failure.  And\nsuch drastic changes to the core GIT that even changes these\notherwise supposedly stable object IDs should be accompanied by\nan update to t0000-basic.sh.\n\nHowever, other tests that simply rely on basic parts of the core\nGIT working properly should not have that level of intimate\nknowledge of the core GIT internals.  If all the test scripts\nhardcoded the object IDs like t0000-basic.sh does, that defeats\nthe purpose of t0000-basic.sh, which is to isolate that level of\nvalidation in one place.  Your test also ends up needing\nupdating when such a change to the internal happens, so do _not_\ndo it and leave the low level of validation to t0000-basic.sh.\n\nTest coverage\n-------------\n\nYou can use the coverage tests to find code paths that are not being\nused or properly exercised yet.\n\nTo do that, run the coverage target at the top-level (not in the t/\ndirectory):\n\n    make coverage\n\nThat'll compile Git with GCC's coverage arguments, and generate a test\nreport with gcov after the tests finish. Running the coverage tests\ncan take a while, since running the tests in parallel is incompatible\nwith GCC's coverage mode.\n\nAfter the tests have run you can generate a list of untested\nfunctions:\n\n    make coverage-untested-functions\n\nYou can also generate a detailed per-file HTML report using the\nDevel::Cover module. To install it do:\n\n   # On Debian or Ubuntu:\n   sudo aptitude install libdevel-cover-perl\n\n   # From the CPAN with cpanminus\n   curl -L http://cpanmin.us | perl - --sudo --self-upgrade\n   cpanm --sudo Devel::Cover\n\nThen, at the top-level:\n\n    make cover_db_html\n\nThat'll generate a detailed cover report in the \"cover_db_html\"\ndirectory, which you can then copy to a webserver, or inspect locally\nin a browser.\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "009e339dbcd5f4826246f08ce00f0cf528c6ec13",
  "sha1_ok": true,
  "size": 29388
}
