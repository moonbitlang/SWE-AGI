{
  "content": {
    "base64": "IyEvdXNyL2Jpbi9wZXJsIC13CiMKIyBUaGlzIHRvb2wgaXMgY29weXJpZ2h0IChjKSAyMDA1LCBNYXJ0aW4gTGFuZ2hvZmYuCiMgSXQgaXMgcmVsZWFzZWQgdW5kZXIgdGhlIEdudSBQdWJsaWMgTGljZW5zZSwgdmVyc2lvbiAyLgojCiMgVGhlIGJhc2ljIGlkZWEgaXMgdG8gd2FsayB0aGUgb3V0cHV0IG9mIHRsYSBhYnJvd3NlLCAKIyBmZXRjaCB0aGUgY2hhbmdlc2V0cyBhbmQgYXBwbHkgdGhlbS4gCiMKCj1oZWFkMSBJbnZvY2F0aW9uCgogICAgZ2l0LWFyY2hpbXBvcnQgWyAtaCBdIFsgLXYgXSBbIC1UIF0gWyAtdCB0ZW1wZGlyIF0gPGFyY2hpdmU+LzxicmFuY2g+IFsgPGFyY2hpdmU+LzxicmFuY2g+IF0KCkltcG9ydHMgYSBwcm9qZWN0IGZyb20gb25lIG9yIG1vcmUgQXJjaCByZXBvc2l0b3JpZXMuIEl0IHdpbGwgZm9sbG93IGJyYW5jaGVzCmFuZCByZXBvc2l0b3JpZXMgd2l0aGluIHRoZSBuYW1lc3BhY2VzIGRlZmluZWQgYnkgdGhlIDxhcmNoaXZlL2JyYW5jaD4KcGFyYW1ldGVycyBzdXBwcGxpZWQuIElmIGl0IGNhbm5vdCBmaW5kIHRoZSByZW1vdGUgYnJhbmNoIGEgbWVyZ2UgY29tZXMgZnJvbQppdCB3aWxsIGp1c3QgaW1wb3J0IGl0IGFzIGEgcmVndWxhciBjb21taXQuIElmIGl0IGNhbiBmaW5kIGl0LCBpdCB3aWxsIG1hcmsgaXQgCmFzIGEgbWVyZ2Ugd2hlbmV2ZXIgcG9zc2libGUuCgpTZWUgbWFuICgxKSBnaXQtYXJjaGltcG9ydCBmb3IgbW9yZSBkZXRhaWxzLgoKPWhlYWQxIFRPRE8KCiAtIGNyZWF0ZSB0YWcgb2JqZWN0cyBpbnN0ZWFkIG9mIHJlZiB0YWdzCiAtIGF1ZGl0IHNoZWxsLWVzY2FwaW5nIG9mIGZpbGVuYW1lcwogLSBoaWRlIG91ciBwcml2YXRlIHRhZ3Mgc29tZXdoZXJlIHNtYXJ0ZXIKIC0gZmluZCBhIHdheSB0byBtYWtlICJjYXQgKnBhdGNoZXMgfCBwYXRjaCIgc2FmZSBldmVuIHdoZW4gcGF0Y2hmaWxlcyBhcmUgbWlzc2luZyBuZXdsaW5lcyAgCiAtIHNvcnQgYW5kIGFwcGx5IHBhdGNoZXMgYnkgZ3JhcGhpbmcgYW5jZXN0cnkgcmVsYXRpb25zIGluc3RlYWQgb2YganVzdAogICByZWx5aW5nIGluIGRhdGVzIHN1cHBsaWVkIGluIHRoZSBjaGFuZ2VzZXQgaXRzZWxmLgogICB0bGEgYW5jZXN0cnktZ3JhcGggLW0gY291bGQgYmUgaGVscGZ1bCBoZXJlLi4uCgo9aGVhZDEgRGV2ZWwgdHJpY2tzCgpBZGQgcHJpbnQgaW4gZnJvbnQgb2YgdGhlIHNoZWxsIGNvbW1hbmRzIGludm9rZWQgdmlhIGJhY2t0aWNrcy4gCgo9aGVhZDEgRGV2ZWwgTm90ZXMKClRoZXJlIGFyZSBzZXZlcmFsIHBsYWNlcyB3aGVyZSBBcmNoIGFuZCBnaXQgdGVybWlub2xvZ3kgYXJlIGludGVybWl4ZWQKYW5kIHBvdGVudGlhbGx5IGNvbmZ1c2VkLgoKVGhlIG5vdGlvbiBvZiBhICJicmFuY2giIGluIGdpdCBpcyBhcHByb3hpbWF0ZWx5IGVxdWl2YWxlbnQgdG8KYSAiYXJjaGl2ZS9jYXRlZ29yeS0tYnJhbmNoLS12ZXJzaW9uIiBpbiBBcmNoLiAgQWxzbywgaXQgc2hvdWxkIGJlIG5vdGVkCnRoYXQgdGhlICItLWJyYW5jaCIgcG9ydGlvbiBvZiAiYXJjaGl2ZS9jYXRlZ29yeS0tYnJhbmNoLS12ZXJzaW9uIiBpcyByZWFsbHkKb3B0aW9uYWwgaW4gQXJjaCBhbHRob3VnaCBub3QgbWFueSBwZW9wbGUgKG5vciB0b29scyEpIHNlZW0gdG8ga25vdyB0aGlzLgpUaGlzIG1lYW5zIHRoYXQgImFyY2hpdmUvY2F0ZWdvcnktLXZlcnNpb24iIGlzIGFsc28gYSB2YWxpZCAiYnJhbmNoIgppbiBnaXQgdGVybXMuCgpXZSBhbHdheXMgcmVmZXIgdG8gQXJjaCBuYW1lcyBieSB0aGVpciBmdWxseSBxdWFsaWZpZWQgdmFyaWFudCAod2hpY2gKbWVhbnMgdGhlICJhcmNoaXZlIiBuYW1lIGlzIHByZWZpeGVkLgoKRm9yIHBlb3BsZSB1bmZhbWlsaWFyIHdpdGggQXJjaCwgYW4gImFyY2hpdmUiIGlzIHRoZSB0ZXJtIGZvciAicmVwb3NpdG9yeSIsCmFuZCBjYW4gY29udGFpbiBtdWx0aXBsZSwgdW5yZWxhdGVkIGJyYW5jaGVzLgoKPWN1dAoKdXNlIHN0cmljdDsKdXNlIHdhcm5pbmdzOwp1c2UgR2V0b3B0OjpTdGQ7CnVzZSBGaWxlOjpUZW1wIHF3KHRlbXBkaXIpOwp1c2UgRmlsZTo6UGF0aCBxdyhta3BhdGggcm10cmVlKTsKdXNlIEZpbGU6OkJhc2VuYW1lIHF3KGJhc2VuYW1lIGRpcm5hbWUpOwp1c2UgRGF0YTo6RHVtcGVyIHF3LyBEdW1wZXIgLzsKdXNlIElQQzo6T3BlbjI7CgokU0lHeydQSVBFJ309IklHTk9SRSI7CiRFTlZ7J1RaJ309IlVUQyI7CgpteSAkZ2l0X2RpciA9ICRFTlZ7IkdJVF9ESVIifSB8fCAiLmdpdCI7CiRFTlZ7IkdJVF9ESVIifSA9ICRnaXRfZGlyOwpteSAkcHRhZ19kaXIgPSAiJGdpdF9kaXIvYXJjaGltcG9ydC90YWdzIjsKCm91cigkb3B0X2gsJG9wdF9mLCRvcHRfdiwkb3B0X1QsJG9wdF90LCRvcHRfRCwkb3B0X2EsJG9wdF9vKTsKCnN1YiB1c2FnZSgpIHsKICAgIHByaW50IFNUREVSUiA8PEVORDsKVXNhZ2U6ICR7XGJhc2VuYW1lICQwfSAgICAgIyBmZXRjaC91cGRhdGUgR0lUIGZyb20gQXJjaAogICAgICAgWyAtZiBdIFsgLW8gXSBbIC1oIF0gWyAtdiBdIFsgLVQgXSBbIC1hIF0gWyAtRCBkZXB0aCAgXSBbIC10IHRlbXBkaXIgXQogICAgICAgcmVwb3NpdG9yeS9hcmNoLWJyYW5jaCBbIHJlcG9zaXRvcnkvYXJjaC1icmFuY2hdIC4uLgpFTkQKICAgIGV4aXQoMSk7Cn0KCmdldG9wdHMoImZUaHZhdDpEOiIpIG9yIHVzYWdlKCk7CnVzYWdlIGlmICRvcHRfaDsKCkBBUkdWID49IDEgb3IgdXNhZ2UoKTsKIyAkYXJjaF9icmFuY2hlczoKIyB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGtleXM6CiMgICA9MSAtIEFyY2ggdmVyc2lvbiAvIGdpdCAnYnJhbmNoJyBkZXRlY3RlZCB2aWEgYWJyb3dzZSBvbiBhIGxpbWl0CiMgICA+MSAtIEFyY2ggdmVyc2lvbiAvIGdpdCAnYnJhbmNoJyBvZiBhbiBhdXhpbGxpYXJ5IGJyYW5jaCB3ZSd2ZSBtZXJnZWQKbXkgJWFyY2hfYnJhbmNoZXMgPSBtYXAgeyAkXyA9PiAxIH0gQEFSR1Y7CgokRU5WeydUTVBESVInfSA9ICRvcHRfdCBpZiAkb3B0X3Q7ICMgJEVOVntUTVBESVJ9IHdpbGwgYWZmZWN0IHRlbXBkaXIoKSBjYWxsczoKbXkgJHRtcCA9IHRlbXBkaXIoJ2dpdC1hcmNoaW1wb3J0LVhYWFhYWCcsIFRNUERJUiA9PiAxLCBDTEVBTlVQID0+IDEpOwokb3B0X3YgJiYgcHJpbnQgIisgVXNpbmcgJHRtcCBhcyB0ZW1wb3JhcnkgZGlyZWN0b3J5XG4iOwoKbXkgJXJlYWNoYWJsZSA9ICgpOyAgICAgICAgICAgICAjIEFyY2ggcmVwb3NpdG9yaWVzIHdlIGNhbiBhY2Nlc3MKbXkgJXVucmVhY2hhYmxlID0gKCk7ICAgICAgICAgICAjIEFyY2ggcmVwb3NpdG9yaWVzIHdlIGNhbid0IGFjY2VzcyA6PApteSBAcHNldHMgID0gKCk7ICAgICAgICAgICAgICAgICMgdGhlIGNvbGxlY3Rpb24KbXkgJXBzZXRzICA9ICgpOyAgICAgICAgICAgICAgICAjIHRoZSBjb2xsZWN0aW9uLCBieSBuYW1lCm15ICVzdGF0cyAgPSAoCQkJIyBUcmFjayB3aGljaCBzdHJhdGVneSB3ZSB1c2VkIHRvIGltcG9ydDoKCWdldF90YWcgPT4gMCwgcmVwbGF5ID0+IDAsIGdldF9uZXcgPT4gMCwgZ2V0X2RlbHRhID0+IDAsCiAgICAgICAgc2ltcGxlX2NoYW5nZXNldCA9PiAwLCBpbXBvcnRfb3JfdGFnID0+IDAKKTsKCm15ICVycHRhZ3MgPSAoKTsgICAgICAgICAgICAgICAgIyBteSByZXZlcnNlIHByaXZhdGUgdGFncwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgdG8gbWFwIGEgU0hBMSB0byBhIGNvbW1pdGlkCm15ICRUTEEgPSAkRU5WeydBUkNIX0NMSUVOVCd9IHx8ICd0bGEnOwoKc3ViIGRvX2Ficm93c2UgewogICAgbXkgJHN0YWdlID0gc2hpZnQ7CiAgICB3aGlsZSAobXkgKCRsaW1pdCwgJGxldmVsKSA9IGVhY2ggJWFyY2hfYnJhbmNoZXMpIHsKICAgICAgICBuZXh0IHVubGVzcyAkbGV2ZWwgPT0gJHN0YWdlOwogICAgICAgIAoJb3BlbiBBQlJPV1NFLCAiJFRMQSBhYnJvd3NlIC1ma0QgLS1tZXJnZXMgJGxpbWl0IHwiIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGRpZSAiUHJvYmxlbXMgd2l0aCB0bGEgYWJyb3dzZTogJCEiOwogICAgCiAgICAgICAgbXkgJXBzICAgICAgICA9ICgpOyAgICAgICAgICMgdGhlIGN1cnJlbnQgb25lCiAgICAgICAgbXkgJGxhc3RzZWVuICA9ICcnOwogICAgCiAgICAgICAgd2hpbGUgKDxBQlJPV1NFPikgewogICAgICAgICAgICBjaG9tcDsKICAgICAgICAgICAgCiAgICAgICAgICAgICMgZmlyc3QgcmVjb3JkIHBhZGRlZCB3IDggc3BhY2VzCiAgICAgICAgICAgIGlmIChzL15cc3s4fVxiLy8pIHsKICAgICAgICAgICAgICAgIG15ICgkaWQsICR0eXBlKSA9IHNwbGl0KG0vXHMrLywgJF8sIDIpOwoKICAgICAgICAgICAgICAgIG15ICVsYXN0X3BzOwogICAgICAgICAgICAgICAgIyBzdG9yZSB0aGUgcmVjb3JkIHdlIGp1c3QgY2FwdHVyZWQKICAgICAgICAgICAgICAgIGlmICglcHMgJiYgIWV4aXN0cyAkcHNldHN7ICRwc3tpZH0gfSkgewogICAgICAgICAgICAgICAgICAgICVsYXN0X3BzID0gJXBzOyAjIGJyZWFrIHJlZmVyZW5jZXMKICAgICAgICAgICAgICAgICAgICBwdXNoIChAcHNldHMsIFwlbGFzdF9wcyk7CiAgICAgICAgICAgICAgICAgICAgJHBzZXRzeyAkbGFzdF9wc3tpZH0gfSA9IFwlbGFzdF9wczsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgbXkgJGJyYW5jaCA9IGV4dHJhY3RfdmVyc2lvbm5hbWUoJGlkKTsKICAgICAgICAgICAgICAgICVwcyA9ICggaWQgPT4gJGlkLCBicmFuY2ggPT4gJGJyYW5jaCApOwogICAgICAgICAgICAgICAgaWYgKCVsYXN0X3BzICYmICgkbGFzdF9wc3ticmFuY2h9IGVxICRicmFuY2gpKSB7CiAgICAgICAgICAgICAgICAgICAgJHBze3BhcmVudF9pZH0gPSAkbGFzdF9wc3tpZH07CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICRhcmNoX2JyYW5jaGVzeyRicmFuY2h9ID0gMTsKICAgICAgICAgICAgICAgICRsYXN0c2VlbiA9ICdpZCc7CgogICAgICAgICAgICAgICAgIyBkZWFsIHdpdGggdHlwZXMgKHNob3VsZCB3b3JrIHdpdGggYmF6IG9yIHRsYSk6CiAgICAgICAgICAgICAgICBpZiAoJHR5cGUgPX4gbS9cKC4qY2hhbmdlc2V0XCkvKSB7CiAgICAgICAgICAgICAgICAgICAgJHBze3R5cGV9ID0gJ3MnOwogICAgICAgICAgICAgICAgfSBlbHNpZiAoJHR5cGUgPX4gL1woLippbXBvcnRcKS8pIHsKICAgICAgICAgICAgICAgICAgICAkcHN7dHlwZX0gPSAnaSc7CiAgICAgICAgICAgICAgICB9IGVsc2lmICgkdHlwZSA9fiBtL1wodGFnLio/KFxTK1xAXFMrKS4qP1wpLykgewogICAgICAgICAgICAgICAgICAgICRwc3t0eXBlfSA9ICd0JzsKICAgICAgICAgICAgICAgICAgICAjIHJlYWQgd2hpY2ggcmV2aXNpb24gd2UndmUgdGFnZ2VkIHdoZW4gd2UgcGFyc2UgdGhlIGxvZwogICAgICAgICAgICAgICAgICAgICRwc3t0YWd9ICA9ICQxOwogICAgICAgICAgICAgICAgfSBlbHNlIHsgCiAgICAgICAgICAgICAgICAgICAgd2FybiAiVW5rbm93biB0eXBlICR0eXBlIjsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAkYXJjaF9icmFuY2hlc3skYnJhbmNofSA9IDE7CiAgICAgICAgICAgICAgICAkbGFzdHNlZW4gPSAnaWQnOwogICAgICAgICAgICB9IGVsc2lmIChzL15cc3sxMH0vLykgeyAKICAgICAgICAgICAgICAgICMgMTAgbGVhZGluZyBzcGFjZXMgb3IgbW9yZSAKICAgICAgICAgICAgICAgICMgaW5kaWNhdGUgY29tbWl0IG1ldGFkYXRhCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICMgZGF0ZQogICAgICAgICAgICAgICAgaWYgKCRsYXN0c2VlbiBlcSAnaWQnICYmIG0vXihcZHs0fS1cZFxkLVxkXGQgXGRcZDpcZFxkOlxkXGQpLyl7CiAgICAgICAgICAgICAgICAgICAgJHBze2RhdGV9ICAgPSAkMTsKICAgICAgICAgICAgICAgICAgICAkbGFzdHNlZW4gPSAnZGF0ZSc7CiAgICAgICAgICAgICAgICB9IGVsc2lmICgkXyBlcSAnbWVyZ2VzIGluOicpIHsKICAgICAgICAgICAgICAgICAgICAkcHN7bWVyZ2VzfSA9IFtdOwogICAgICAgICAgICAgICAgICAgICRsYXN0c2VlbiA9ICdtZXJnZXMnOwogICAgICAgICAgICAgICAgfSBlbHNpZiAoJGxhc3RzZWVuIGVxICdtZXJnZXMnICYmIHMvXlxzezJ9Ly8pIHsKICAgICAgICAgICAgICAgICAgICBteSAkaWQgPSAkXzsKICAgICAgICAgICAgICAgICAgICBwdXNoIChAeyRwc3ttZXJnZXN9fSwgJGlkKTsKICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICMgYWdncmVzc2l2ZSBicmFuY2ggZmluZGluZzoKICAgICAgICAgICAgICAgICAgICBpZiAoJG9wdF9EKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIG15ICRicmFuY2ggPSBleHRyYWN0X3ZlcnNpb25uYW1lKCRpZCk7CiAgICAgICAgICAgICAgICAgICAgICAgIG15ICRyZXBvID0gZXh0cmFjdF9yZXBvbmFtZSgkYnJhbmNoKTsKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmNoaXZlX3JlYWNoYWJsZSgkcmVwbykgJiYKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZGVmaW5lZCAkYXJjaF9icmFuY2hlc3skYnJhbmNofSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgJGFyY2hfYnJhbmNoZXN7JGJyYW5jaH0gPSAkc3RhZ2UgKyAxOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB3YXJuICJtb3JlIG1ldGFkYXRhIGFmdGVyIG1lcmdlcyE/OiAkX1xuIiB1bmxlc3MgL15ccyokLzsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKCVwcyAmJiAhZXhpc3RzICRwc2V0c3sgJHBze2lkfSB9KSB7CiAgICAgICAgICAgIG15ICV0ZW1wID0gJXBzOyAgICAgICAgICMgYnJlYWsgcmVmZXJlbmNlcwogICAgICAgICAgICBpZiAoQHBzZXRzICYmICRwc2V0c1skI3BzZXRzXXticmFuY2h9IGVxICRwc3ticmFuY2h9KSB7CiAgICAgICAgICAgICAgICAkdGVtcHtwYXJlbnRfaWR9ID0gJHBzZXRzWyQjcHNldHNde2lkfTsKICAgICAgICAgICAgfQogICAgICAgICAgICBwdXNoIChAcHNldHMsIFwldGVtcCk7ICAKICAgICAgICAgICAgJHBzZXRzeyAkdGVtcHtpZH0gfSA9IFwldGVtcDsKICAgICAgICB9ICAgIAogICAgICAgIAogICAgICAgIGNsb3NlIEFCUk9XU0Ugb3IgZGllICIkVExBIGFicm93c2UgZmFpbGVkIG9uICRsaW1pdFxuIjsKICAgIH0KfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGVuZCBmb3JlYWNoICRyb290Cgpkb19hYnJvd3NlKDEpOwpteSAkZGVwdGggPSAyOwokb3B0X0QgfHw9IDA7CndoaWxlICgkZGVwdGggPD0gJG9wdF9EKSB7CiAgICBkb19hYnJvd3NlKCRkZXB0aCk7CiAgICAkZGVwdGgrKzsKfQoKIyMgT3JkZXIgcGF0Y2hlcyBieSB0aW1lCiMgRklYTUUgc2VlIGlmIHdlIGNhbiBmaW5kIGEgbW9yZSBvcHRpbWFsIHdheSB0byBkbyB0aGlzIGJ5IGdyYXBoaW5nCiMgdGhlIGFuY2VzdHJ5IGRhdGEgYW5kIHdhbGtpbmcgaXQsIHRoYXQgd2F5IHdlIHdvbid0IGhhdmUgdG8gcmVseSBvbgojIGNsaWVudC1zdXBwbGllZCBkYXRlcwpAcHNldHMgPSBzb3J0IHskYS0+e2RhdGV9LiRiLT57aWR9IGNtcCAkYi0+e2RhdGV9LiRiLT57aWR9fSBAcHNldHM7CgojcHJpbnQgRHVtcGVyIFxAcHNldHM7CgojIwojIyBUT0RPIGNsZWFudXAgaXJyZWxldmFudCBwYXRjaGVzCiMjICAgICAgYW5kIHB1dCBhbiBpbml0aWFsIGltcG9ydAojIyAgICAgIG9yIGEgZnVsbCB0YWcKbXkgJGltcG9ydCA9IDA7CnVubGVzcyAoLWQgJGdpdF9kaXIpIHsgIyBpbml0aWFsIGltcG9ydAogICAgaWYgKCRwc2V0c1swXXt0eXBlfSBlcSAnaScgfHwgJHBzZXRzWzBde3R5cGV9IGVxICd0JykgewogICAgICAgIHByaW50ICJTdGFydGluZyBpbXBvcnQgZnJvbSAkcHNldHNbMF17aWR9XG4iOwoJYGdpdC1pbml0LWRiYDsKCWRpZSAkISBpZiAkPzsKCSRpbXBvcnQgPSAxOwogICAgfSBlbHNlIHsKICAgICAgICBkaWUgIk5lZWQgdG8gc3RhcnQgZnJvbSBhbiBpbXBvcnQgb3IgYSB0YWcgLS0gY2Fubm90IHVzZSAkcHNldHNbMF17aWR9IjsKICAgIH0KfSBlbHNlIHsgICAgIyBwcm9ncmVzc2luZyBhbiBpbXBvcnQKICAgICMgbG9hZCB0aGUgcnB0YWdzCiAgICBvcGVuZGlyKERJUiwgJHB0YWdfZGlyKQoJfHwgZGllICJjYW4ndCBvcGVuZGlyOiAkISI7CiAgICB3aGlsZSAobXkgJGZpbGUgPSByZWFkZGlyKERJUikpIHsKICAgICAgICAjIHNraXAgbm9uLWludGVyZXN0aW5nLWZpbGVzCiAgICAgICAgbmV4dCB1bmxlc3MgLWYgIiRwdGFnX2Rpci8kZmlsZSI7CiAgIAogICAgICAgICMgY29udmVydCBmaXJzdCAnLS0nIHRvICcvJyBmcm9tIG9sZCBnaXQtYXJjaGltcG9ydCB0byB1c2UKICAgICAgICAjIGFzIGFuIGFyY2hpdmVuYW1lL2MtLWItLXYgcHJpdmF0ZSB0YWcKICAgICAgICBpZiAoJGZpbGUgIX4gbSEsISkgewogICAgICAgICAgICBteSAkb2xkZmlsZSA9ICRmaWxlOwogICAgICAgICAgICAkZmlsZSA9fiBzIS0tISwhOwogICAgICAgICAgICBwcmludCBTVERFUlIgImNvbnZlcnRpbmcgb2xkIHRhZyAkb2xkZmlsZSB0byAkZmlsZVxuIjsKICAgICAgICAgICAgcmVuYW1lKCIkcHRhZ19kaXIvJG9sZGZpbGUiLCAiJHB0YWdfZGlyLyRmaWxlIikgb3IgZGllICQhOwogICAgICAgIH0KCW15ICRzaGEgPSBwdGFnKCRmaWxlKTsKCWNob21wICRzaGE7CgkkcnB0YWdzeyRzaGF9ID0gJGZpbGU7CiAgICB9CiAgICBjbG9zZWRpciBESVI7Cn0KCiMgcHJvY2VzcyBwYXRjaHNldHMKIyBleHRyYWN0IHRoZSBBcmNoIHJlcG9zaXRvcnkgbmFtZSAoQXJjaCAiYXJjaGl2ZSIgaW4gQXJjaC1zcGVhaykKc3ViIGV4dHJhY3RfcmVwb25hbWUgewogICAgbXkgJGZxX2N2YnIgPSBzaGlmdDsgIyBhcmNoaXZlbmFtZS9bW1tbY2F0ZWdvcnldYnJhbmNoXXZlcnNpb25dcmV2aXNpb25dCiAgICByZXR1cm4gKHNwbGl0KC9cLy8sICRmcV9jdmJyKSlbMF07Cn0KIApzdWIgZXh0cmFjdF92ZXJzaW9ubmFtZSB7CiAgICBteSAkbmFtZSA9IHNoaWZ0OwogICAgJG5hbWUgPX4gcy8tLSg/OnBhdGNofHZlcnNpb24oPzpmaXgpP3xiYXNlKS1cZCskLy87CiAgICByZXR1cm4gJG5hbWU7Cn0KCiMgY29udmVydCBhIGZ1bGx5LXF1YWxpZmllZCByZXZpc2lvbiBvciB2ZXJzaW9uIHRvIGEgdW5pcXVlIGRpcm5hbWU6CiMgICBub3JtYWxwZXJzb25AeWhidC5uZXQtMDUvbXBkLS11Y2xpbnV4LS0xLS1wYXRjaC0yIAojIGJlY29tZXM6IG5vcm1hbHBlcnNvbkB5aGJ0Lm5ldC0wNSxtcGQtLXVjbGludXgtLTEKIwojIHRoZSBnaXQgbm90aW9uIG9mIGEgYnJhbmNoIGlzIGNsb3NlciB0bwojIGFyY2hpdmUvY2F0ZWdvcnktLWJyYW5jaC0tdmVyc2lvbiB0aGFuIGFyY2hpdmUvY2F0ZWdvcnktLWJyYW5jaCwgc28gd2UKIyB1c2UgdGhpcyB0byBjb252ZXJ0IHRvIGdpdCBicmFuY2ggbmFtZXMuCiMgQWxzbywga2VlcCBhcmNoaXZlIG5hbWVzIGJ1dCByZXBsYWNlICcvJyB3aXRoICcsJyBzaW5jZSBpdCB3b24ndCByZXF1aXJlCiMgc3ViZGlyZWN0b3JpZXMsIGFuZCBpcyBzYWZlciB0aGFuIHN3YXBwaW5nICctLScgd2hpY2ggY291bGQgY29uZnVzZQojIHJldmVyc2UtbWFwcGluZyB3aGVuIGRlYWxpbmcgd2l0aCBiYXN0YXJkIGJyYW5jaGVzIHRoYXQKIyBhcmUganVzdCBhcmNoaXZlL2NhdGVnb3J5LS12ZXJzaW9uICAobm8gLS1icmFuY2gpCnN1YiB0cmVlX2Rpcm5hbWUgewogICAgbXkgJHJldmlzaW9uID0gc2hpZnQ7CiAgICBteSAkbmFtZSA9IGV4dHJhY3RfdmVyc2lvbm5hbWUoJHJldmlzaW9uKTsKICAgICRuYW1lID1+IHMjLyMsIzsKICAgIHJldHVybiAkbmFtZTsKfQoKIyBvbGQgdmVyc2lvbnMgb2YgZ2l0LWFyY2hpbXBvcnQganVzdCB1c2UgdGhlIDxjYXRlZ29yeS0tYnJhbmNoPiBwYXJ0OgpzdWIgb2xkX3N0eWxlX2JyYW5jaG5hbWUgewogICAgbXkgJGlkID0gc2hpZnQ7CiAgICBteSAkcmV0ID0gc2FmZV9waXBlX2NhcHR1cmUoJFRMQSwncGFyc2UtcGFja2FnZS1uYW1lJywnLXAnLCRpZCk7CiAgICBjaG9tcCAkcmV0OwogICAgcmV0dXJuICRyZXQ7Cn0KCipnaXRfYnJhbmNobmFtZSA9ICRvcHRfbyA/ICpvbGRfc3R5bGVfYnJhbmNobmFtZSA6ICp0cmVlX2Rpcm5hbWU7CgpzdWIgcHJvY2Vzc19wYXRjaHNldF9hY2N1cmF0ZSB7CiAgICBteSAkcHMgPSBzaGlmdDsKICAgIAogICAgIyBzd2l0Y2ggdG8gdGhhdCBicmFuY2ggaWYgd2UncmUgbm90IGFscmVhZHkgaW4gdGhhdCBicmFuY2g6CiAgICBpZiAoLWUgIiRnaXRfZGlyL3JlZnMvaGVhZHMvJHBzLT57YnJhbmNofSIpIHsKICAgICAgIHN5c3RlbSgnZ2l0LWNoZWNrb3V0JywnLWYnLCRwcy0+e2JyYW5jaH0pID09IDAgb3IgZGllICIkISAkP1xuIjsKCiAgICAgICAjIHJlbW92ZSBhbnkgb2xkIHN0dWZmIHRoYXQgZ290IGxlZnRvdmVyOgogICAgICAgbXkgJHJtID0gc2FmZV9waXBlX2NhcHR1cmUoJ2dpdC1scy1maWxlcycsJy0tb3RoZXJzJywnLXonKTsKICAgICAgIHJtdHJlZShzcGxpdCgvXDAvLCRybSkpIGlmICRybTsKICAgIH0KICAgIAogICAgIyBBcHBseSB0aGUgaW1wb3J0L2NoYW5nZXNldC9tZXJnZSBpbnRvIHRoZSB3b3JraW5nIHRyZWUKICAgIG15ICRkaXIgPSBzeW5jX3RvX3BzKCRwcyk7CiAgICAjIHJlYWQgdGhlIG5ldyBsb2cgZW50cnk6CiAgICBteSBAY29tbWl0bG9nID0gc2FmZV9waXBlX2NhcHR1cmUoJFRMQSwnY2F0LWxvZycsJy1kJywkZGlyLCRwcy0+e2lkfSk7CiAgICBkaWUgIkVycm9yIGluIGNhdC1sb2c6ICQhIiBpZiAkPzsKICAgIGNob21wIEBjb21taXRsb2c7CgogICAgIyBncmFiIHZhcmlhYmxlcyB3ZSB3YW50IGZyb20gdGhlIGxvZywgbmV3IGZpZWxkcyBnZXQgYWRkZWQgdG8gJHBzOgogICAgIyAoYXV0aG9yLCBkYXRlLCBlbWFpbCwgc3VtbWFyeSwgbWVzc2FnZSBib2R5IC4uLikKICAgIHBhcnNlbG9nKCRwcywgXEBjb21taXRsb2cpOwoKICAgIGlmICgkcHMtPntpZH0gPX4gLy0tYmFzZS0wJC8gJiYgJHBzLT57aWR9IG5lICRwc2V0c1swXXtpZH0pIHsKICAgICAgICAjIHRoaXMgc2hvdWxkIHdvcmsgd2hlbiBpbXBvcnRpbmcgY29udGludWF0aW9ucyAKICAgICAgICBpZiAoJHBzLT57dGFnfSAmJiAobXkgJGJyYW5jaHBvaW50ID0gZXZhbCB7IHB0YWcoJHBzLT57dGFnfSkgfSkpIHsKICAgICAgICAgICAgCiAgICAgICAgICAgICMgZmluZCB3aGVyZSB3ZSBhcmUgc3VwcG9zZWQgdG8gYnJhbmNoIGZyb20KICAgICAgICAgICAgc3lzdGVtKCdnaXQtY2hlY2tvdXQnLCctZicsJy1iJywkcHMtPnticmFuY2h9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgJGJyYW5jaHBvaW50KSA9PSAwIG9yIGRpZSAiJCEgJD9cbiI7CiAgICAgICAgICAgIAogICAgICAgICAgICAjIHJlbW92ZSBhbnkgb2xkIHN0dWZmIHRoYXQgZ290IGxlZnRvdmVyOgogICAgICAgICAgICBteSAkcm0gPSBzYWZlX3BpcGVfY2FwdHVyZSgnZ2l0LWxzLWZpbGVzJywnLS1vdGhlcnMnLCcteicpOwogICAgICAgICAgICBybXRyZWUoc3BsaXQoL1wwLywkcm0pKSBpZiAkcm07CgogICAgICAgICAgICAjIElmIHdlIHRydXN0IEFyY2ggd2l0aCB0aGUgZmFjdCB0aGF0IHRoaXMgaXMganVzdCAKICAgICAgICAgICAgIyBhIHRhZywgYW5kIGl0IGRvZXMgbm90IGFmZmVjdCB0aGUgc3RhdGUgb2YgdGhlIHRyZWUKICAgICAgICAgICAgIyB0aGVuIHdlIGp1c3QgdGFnIGFuZCBtb3ZlIG9uCiAgICAgICAgICAgIHRhZygkcHMtPntpZH0sICRicmFuY2hwb2ludCk7CiAgICAgICAgICAgIHB0YWcoJHBzLT57aWR9LCAkYnJhbmNocG9pbnQpOwogICAgICAgICAgICBwcmludCAiICogVGFnZ2VkICRwcy0+e2lkfSBhdCAkYnJhbmNocG9pbnRcbiI7CiAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHdhcm4gIlRhZ2dpbmcgZnJvbSB1bmtub3duIGlkIHVuc3VwcG9ydGVkXG4iIGlmICRwcy0+e3RhZ307CiAgICAgICAgfQogICAgICAgICMgYWxsb3cgbXVsdGlwbGUgYmFzZXMvaW1wb3J0cyBoZXJlIHNpbmNlIEFyY2ggc3VwcG9ydHMgY2hlcnJ5LXBpY2tzCiAgICAgICAgIyBmcm9tIHVucmVsYXRlZCB0cmVlcwogICAgfSAKICAgIAogICAgIyB1cGRhdGUgdGhlIGluZGV4IHdpdGggYWxsIHRoZSBjaGFuZ2VzIHdlIGdvdAogICAgc3lzdGVtKCdnaXQtbHMtZmlsZXMgLS1vdGhlcnMgLXogfCAnLgogICAgICAgICAgICAnZ2l0LXVwZGF0ZS1pbmRleCAtLWFkZCAteiAtLXN0ZGluJykgPT0gMCBvciBkaWUgIiQhICQ/XG4iOwogICAgc3lzdGVtKCdnaXQtbHMtZmlsZXMgLS1kZWxldGVkIC16IHwgJy4KICAgICAgICAgICAgJ2dpdC11cGRhdGUtaW5kZXggLS1yZW1vdmUgLXogLS1zdGRpbicpID09IDAgb3IgZGllICIkISAkP1xuIjsKICAgIHN5c3RlbSgnZ2l0LWxzLWZpbGVzIC16IHwgJy4KICAgICAgICAgICAgICdnaXQtdXBkYXRlLWluZGV4IC16IC0tc3RkaW4nKSA9PSAwIG9yIGRpZSAiJCEgJD9cbiI7CiAgICByZXR1cm4gMTsKfQoKIyB0aGUgbmF0aXZlIGNoYW5nZXNldCBwcm9jZXNzaW5nIHN0cmF0ZWd5LiAgVGhpcyBpcyB2ZXJ5IGZhc3QsIGJ1dAojIGRvZXMgbm90IGhhbmRsZSBwZXJtaXNzaW9ucyBvciBhbnkgcmVuYW1lcyBpbnZvbHZpbmcgZGlyZWN0b3JpZXMKc3ViIHByb2Nlc3NfcGF0Y2hzZXRfZmFzdCB7CiAgICBteSAkcHMgPSBzaGlmdDsKICAgICMgCiAgICAjIGNyZWF0ZSB0aGUgYnJhbmNoIGlmIG5lZWRlZAogICAgIwogICAgaWYgKCRwcy0+e3R5cGV9IGVxICdpJyAmJiAhJGltcG9ydCkgewogICAgICAgIGRpZSAiU2hvdWxkIG5vdCBoYXZlIG1vcmUgdGhhbiBvbmUgJ0luaXRpYWwgaW1wb3J0JyBwZXIgR0lUIGltcG9ydDogJHBzLT57aWR9IjsKICAgIH0KCiAgICB1bmxlc3MgKCRpbXBvcnQpIHsgIyBza2lwIGZvciBpbXBvcnQKICAgICAgICBpZiAoIC1lICIkZ2l0X2Rpci9yZWZzL2hlYWRzLyRwcy0+e2JyYW5jaH0iKSB7CiAgICAgICAgICAgICMgd2Uga25vdyBhYm91dCB0aGlzIGJyYW5jaAogICAgICAgICAgICBzeXN0ZW0oJ2dpdC1jaGVja291dCcsJHBzLT57YnJhbmNofSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgIyBuZXcgYnJhbmNoISB3ZSBuZWVkIHRvIHZlcmlmeSBhIGZldyB0aGluZ3MKICAgICAgICAgICAgZGllICJCcmFuY2ggb24gYSBub24tdGFnISIgdW5sZXNzICRwcy0+e3R5cGV9IGVxICd0JzsKICAgICAgICAgICAgbXkgJGJyYW5jaHBvaW50ID0gcHRhZygkcHMtPnt0YWd9KTsKICAgICAgICAgICAgZGllICJUYWdnaW5nIGZyb20gdW5rbm93biBpZCB1bnN1cHBvcnRlZDogJHBzLT57dGFnfSIgCiAgICAgICAgICAgICAgICB1bmxlc3MgJGJyYW5jaHBvaW50OwogICAgICAgICAgICAKICAgICAgICAgICAgIyBmaW5kIHdoZXJlIHdlIGFyZSBzdXBwb3NlZCB0byBicmFuY2ggZnJvbQogICAgICAgICAgICBzeXN0ZW0oJ2dpdC1jaGVja291dCcsJy1iJywkcHMtPnticmFuY2h9LCRicmFuY2hwb2ludCk7CgogICAgICAgICAgICAjIElmIHdlIHRydXN0IEFyY2ggd2l0aCB0aGUgZmFjdCB0aGF0IHRoaXMgaXMganVzdCAKICAgICAgICAgICAgIyBhIHRhZywgYW5kIGl0IGRvZXMgbm90IGFmZmVjdCB0aGUgc3RhdGUgb2YgdGhlIHRyZWUKICAgICAgICAgICAgIyB0aGVuIHdlIGp1c3QgdGFnIGFuZCBtb3ZlIG9uCiAgICAgICAgICAgIHRhZygkcHMtPntpZH0sICRicmFuY2hwb2ludCk7CiAgICAgICAgICAgIHB0YWcoJHBzLT57aWR9LCAkYnJhbmNocG9pbnQpOwogICAgICAgICAgICBwcmludCAiICogVGFnZ2VkICRwcy0+e2lkfSBhdCAkYnJhbmNocG9pbnRcbiI7CiAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0gCiAgICAgICAgZGllICQhIGlmICQ/OwogICAgfSAKCiAgICAjCiAgICAjIEFwcGx5IHRoZSBpbXBvcnQvY2hhbmdlc2V0L21lcmdlIGludG8gdGhlIHdvcmtpbmcgdHJlZQogICAgIyAKICAgIGlmICgkcHMtPnt0eXBlfSBlcSAnaScgfHwgJHBzLT57dHlwZX0gZXEgJ3QnKSB7CiAgICAgICAgYXBwbHlfaW1wb3J0KCRwcykgb3IgZGllICQhOwogICAgICAgICRzdGF0c3tpbXBvcnRfb3JfdGFnfSsrOwogICAgICAgICRpbXBvcnQ9MDsKICAgIH0gZWxzaWYgKCRwcy0+e3R5cGV9IGVxICdzJykgewogICAgICAgIGFwcGx5X2NzZXQoJHBzKTsKICAgICAgICAkc3RhdHN7c2ltcGxlX2NoYW5nZXNldH0rKzsKICAgIH0KCiAgICAjCiAgICAjIHByZXBhcmUgdXBkYXRlIGdpdCdzIGluZGV4LCBiYXNlZCBvbiB3aGF0IGFyY2gga25vd3MKICAgICMgYWJvdXQgdGhlIHBzZXQsIHJlc29sdmUgcGFyZW50cywgZXRjCiAgICAjCiAgICAKICAgIG15IEBjb21taXRsb2cgPSBzYWZlX3BpcGVfY2FwdHVyZSgkVExBLCdjYXQtYXJjaGl2ZS1sb2cnLCRwcy0+e2lkfSk7IAogICAgZGllICJFcnJvciBpbiBjYXQtYXJjaGl2ZS1sb2c6ICQhIiBpZiAkPzsKICAgICAgICAKICAgIHBhcnNlbG9nKCRwcyxcQGNvbW1pdGxvZyk7CgogICAgIyBpbXBvcnRzIGRvbid0IGdpdmUgdXMgZ29vZCBpbmZvCiAgICAjIG9uIGFkZGVkIGZpbGVzLiBTaGFtZSBvbiB0aGVtCiAgICBpZiAoJHBzLT57dHlwZX0gZXEgJ2knIHx8ICRwcy0+e3R5cGV9IGVxICd0JykgewogICAgICAgIHN5c3RlbSgnZ2l0LWxzLWZpbGVzIC0tb3RoZXJzIC16IHwgJy4KICAgICAgICAgICAgICAgICdnaXQtdXBkYXRlLWluZGV4IC0tYWRkIC16IC0tc3RkaW4nKSA9PSAwIG9yIGRpZSAiJCEgJD9cbiI7CiAgICAgICAgc3lzdGVtKCdnaXQtbHMtZmlsZXMgLS1kZWxldGVkIC16IHwgJy4KICAgICAgICAgICAgICAgICdnaXQtdXBkYXRlLWluZGV4IC0tcmVtb3ZlIC16IC0tc3RkaW4nKSA9PSAwIG9yIGRpZSAiJCEgJD9cbiI7CiAgICB9CgogICAgIyBUT0RPOiBoYW5kbGUgcmVtb3ZlZF9kaXJlY3RvcmllcyBhbmQgcmVuYW1lZF9kaXJlY3RvcmllczoKICAgCiAgICBpZiAobXkgJGFkZCA9ICRwcy0+e25ld19maWxlc30pIHsKICAgICAgICB3aGlsZSAoQCRhZGQpIHsKICAgICAgICAgICAgbXkgQHNsaWNlID0gc3BsaWNlKEAkYWRkLCAwLCAxMDApOwogICAgICAgICAgICBzeXN0ZW0oJ2dpdC11cGRhdGUtaW5kZXgnLCctLWFkZCcsJy0tJyxAc2xpY2UpID09IDAgb3IKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZSAiRXJyb3IgaW4gZ2l0LXVwZGF0ZS1pbmRleCAtLWFkZDogJCEgJD9cbiI7CiAgICAgICAgfQogICAgfQogICAKICAgIGlmIChteSAkZGVsID0gJHBzLT57cmVtb3ZlZF9maWxlc30pIHsKICAgICAgICB1bmxpbmsgQCRkZWw7CiAgICAgICAgd2hpbGUgKEAkZGVsKSB7CiAgICAgICAgICAgIG15IEBzbGljZSA9IHNwbGljZShAJGRlbCwgMCwgMTAwKTsKICAgICAgICAgICAgc3lzdGVtKCdnaXQtdXBkYXRlLWluZGV4JywnLS1yZW1vdmUnLCctLScsQHNsaWNlKSA9PSAwIG9yCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWUgIkVycm9yIGluIGdpdC11cGRhdGUtaW5kZXggLS1yZW1vdmU6ICQhICQ/XG4iOwogICAgICAgIH0KICAgIH0KCiAgICBpZiAobXkgJHJlbiA9ICRwcy0+e3JlbmFtZWRfZmlsZXN9KSB7ICAgICAgICAgICAgICAgICMgcmVuYW1lZAogICAgICAgIGlmIChAJHJlbiAlIDIpIHsKICAgICAgICAgICAgZGllICJPZGQgbnVtYmVyIG9mIGVudHJpZXMgaW4gcmVuYW1lIT8iOwogICAgICAgIH0KICAgICAgICAKICAgICAgICB3aGlsZSAoQCRyZW4pIHsKICAgICAgICAgICAgbXkgJGZyb20gPSBzaGlmdCBAJHJlbjsKICAgICAgICAgICAgbXkgJHRvICAgPSBzaGlmdCBAJHJlbjsgICAgICAgICAgIAoKICAgICAgICAgICAgdW5sZXNzICgtZCBkaXJuYW1lKCR0bykpIHsKICAgICAgICAgICAgICAgIG1rcGF0aChkaXJuYW1lKCR0bykpOyAjIHdpbGwgZGllIG9uIGVycgogICAgICAgICAgICB9CiAgICAgICAgICAgICMgcHJpbnQgIm1vdmluZyAkZnJvbSAkdG8iOwogICAgICAgICAgICByZW5hbWUoJGZyb20sICR0bykgb3IgZGllICJFcnJvciByZW5hbWluZyAnJGZyb20nICckdG8nOiAkIVxuIjsKICAgICAgICAgICAgc3lzdGVtKCdnaXQtdXBkYXRlLWluZGV4JywnLS1yZW1vdmUnLCctLScsJGZyb20pID09IDAgb3IKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZSAiRXJyb3IgaW4gZ2l0LXVwZGF0ZS1pbmRleCAtLXJlbW92ZTogJCEgJD9cbiI7CiAgICAgICAgICAgIHN5c3RlbSgnZ2l0LXVwZGF0ZS1pbmRleCcsJy0tYWRkJywnLS0nLCR0bykgPT0gMCBvcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGllICJFcnJvciBpbiBnaXQtdXBkYXRlLWluZGV4IC0tYWRkOiAkISAkP1xuIjsKICAgICAgICB9CiAgICB9CgogICAgaWYgKG15ICRtb2QgPSAkcHMtPnttb2RpZmllZF9maWxlc30pIHsKICAgICAgICB3aGlsZSAoQCRtb2QpIHsKICAgICAgICAgICAgbXkgQHNsaWNlID0gc3BsaWNlKEAkbW9kLCAwLCAxMDApOwogICAgICAgICAgICBzeXN0ZW0oJ2dpdC11cGRhdGUtaW5kZXgnLCctLScsQHNsaWNlKSA9PSAwIG9yCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWUgIkVycm9yIGluIGdpdC11cGRhdGUtaW5kZXg6ICQhICQ/XG4iOwogICAgICAgIH0KICAgIH0KICAgIHJldHVybiAxOyAjIHdlIHN1Y2Nlc3NmdWxseSBhcHBsaWVkIHRoZSBjaGFuZ2VzZXQKfQoKaWYgKCRvcHRfZikgewogICAgcHJpbnQgIldpbGwgaW1wb3J0IHBhdGNoc2V0cyB1c2luZyB0aGUgZmFzdCBzdHJhdGVneVxuIiwKICAgICAgICAgICAgIlJlbmFtZWQgZGlyZWN0b3JpZXMgYW5kIHBlcm1pc3Npb24gY2hhbmdlcyB3aWxsIGJlIG1pc3NlZFxuIjsKICAgICpwcm9jZXNzX3BhdGNoc2V0ID0gKnByb2Nlc3NfcGF0Y2hzZXRfZmFzdDsKfSBlbHNlIHsKICAgIHByaW50ICJVc2luZyB0aGUgZGVmYXVsdCAoYWNjdXJhdGUpIGltcG9ydCBzdHJhdGVneS5cbiIsCiAgICAgICAgICAgICJUaGluZ3MgbWF5IGJlIGEgYml0IHNsb3dcbiI7CiAgICAqcHJvY2Vzc19wYXRjaHNldCA9ICpwcm9jZXNzX3BhdGNoc2V0X2FjY3VyYXRlOwp9CiAgICAKZm9yZWFjaCBteSAkcHMgKEBwc2V0cykgewogICAgIyBwcm9jZXNzIHBhdGNoc2V0cwogICAgJHBzLT57YnJhbmNofSA9IGdpdF9icmFuY2huYW1lKCRwcy0+e2lkfSk7CgogICAgIwogICAgIyBlbnN1cmUgd2UgaGF2ZSBhIGNsZWFuIHN0YXRlIAogICAgIyAKICAgIGlmIChteSAkZGlydHkgPSBgZ2l0LWRpZmYtZmlsZXNgKSB7CiAgICAgICAgZGllICJVbmNsZWFuIHRyZWUgd2hlbiBhYm91dCB0byBwcm9jZXNzICRwcy0+e2lkfSAiIC4KICAgICAgICAgICAgIiAtIGRpZCB3ZSBmYWlsIHRvIGNvbW1pdCBjbGVhbmx5IGJlZm9yZT9cbiRkaXJ0eSI7CiAgICB9CiAgICBkaWUgJCEgaWYgJD87CiAgICAKICAgICMKICAgICMgc2tpcCBjb21taXRzIGFscmVhZHkgaW4gcmVwbwogICAgIwogICAgaWYgKHB0YWcoJHBzLT57aWR9KSkgewogICAgICAkb3B0X3YgJiYgcHJpbnQgIiAqIFNraXBwaW5nIGFscmVhZHkgaW1wb3J0ZWQ6ICRwcy0+e2lkfVxuIjsKICAgICAgcmV0dXJuIDA7CiAgICB9CgogICAgcHJpbnQgIiAqIFN0YXJ0aW5nIHRvIHdvcmsgb24gJHBzLT57aWR9XG4iOwoKICAgIHByb2Nlc3NfcGF0Y2hzZXQoJHBzKSBvciBuZXh0OwoKICAgICMgd2FybiAiZXJyb3JzIHdoZW4gcnVubmluZyBnaXQtdXBkYXRlLWluZGV4ISAkISI7CiAgICBteSAkdHJlZSA9IGBnaXQtd3JpdGUtdHJlZWA7CiAgICBkaWUgImNhbm5vdCB3cml0ZSB0cmVlICQhIiBpZiAkPzsKICAgIGNob21wICR0cmVlOwogICAgCiAgICAjCiAgICAjIFdobydzIHlvdXIgZGFkZHk/CiAgICAjCiAgICBteSBAcGFyOwogICAgaWYgKCAtZSAiJGdpdF9kaXIvcmVmcy9oZWFkcy8kcHMtPnticmFuY2h9IikgewogICAgICAgIGlmIChvcGVuIEhFQUQsICI8IiwiJGdpdF9kaXIvcmVmcy9oZWFkcy8kcHMtPnticmFuY2h9IikgewogICAgICAgICAgICBteSAkcCA9IDxIRUFEPjsKICAgICAgICAgICAgY2xvc2UgSEVBRDsKICAgICAgICAgICAgY2hvbXAgJHA7CiAgICAgICAgICAgIHB1c2ggQHBhciwgJy1wJywgJHA7CiAgICAgICAgfSBlbHNlIHsgCiAgICAgICAgICAgIGlmICgkcHMtPnt0eXBlfSBlcSAncycpIHsKICAgICAgICAgICAgICAgIHdhcm4gIkNvdWxkIG5vdCBmaW5kIHRoZSByaWdodCBoZWFkIGZvciB0aGUgYnJhbmNoICRwcy0+e2JyYW5jaH0iOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQogICAgCiAgICBpZiAoJHBzLT57bWVyZ2VzfSkgewogICAgICAgIHB1c2ggQHBhciwgZmluZF9wYXJlbnRzKCRwcyk7CiAgICB9CgogICAgIyAgICAKICAgICMgQ29tbWl0LCB0YWcgYW5kIGNsZWFuIHN0YXRlCiAgICAjCiAgICAkRU5We1RafSAgICAgICAgICAgICAgICAgID0gJ0dNVCc7CiAgICAkRU5We0dJVF9BVVRIT1JfTkFNRX0gICAgID0gJHBzLT57YXV0aG9yfTsKICAgICRFTlZ7R0lUX0FVVEhPUl9FTUFJTH0gICAgPSAkcHMtPntlbWFpbH07CiAgICAkRU5We0dJVF9BVVRIT1JfREFURX0gICAgID0gJHBzLT57ZGF0ZX07CiAgICAkRU5We0dJVF9DT01NSVRURVJfTkFNRX0gID0gJHBzLT57YXV0aG9yfTsKICAgICRFTlZ7R0lUX0NPTU1JVFRFUl9FTUFJTH0gPSAkcHMtPntlbWFpbH07CiAgICAkRU5We0dJVF9DT01NSVRURVJfREFURX0gID0gJHBzLT57ZGF0ZX07CgogICAgbXkgJHBpZCA9IG9wZW4yKCpSRUFERVIsICpXUklURVIsJ2dpdC1jb21taXQtdHJlZScsJHRyZWUsQHBhcikgCiAgICAgICAgb3IgZGllICQhOwogICAgcHJpbnQgV1JJVEVSICRwcy0+e3N1bW1hcnl9LCJcbiI7CiAgICBwcmludCBXUklURVIgJHBzLT57bWVzc2FnZX0sIlxuIjsKICAgIAogICAgIyBtYWtlIGl0IGVhc3kgdG8gYmFja3RyYWNrIGFuZCBmaWd1cmUgb3V0IHdoaWNoIEFyY2ggcmV2aXNpb24gdGhpcyB3YXM6CiAgICBwcmludCBXUklURVIgJ2dpdC1hcmNoaW1wb3J0LWlkOiAnLCRwcy0+e2lkfSwiXG4iOwogICAgCiAgICBjbG9zZSBXUklURVI7CiAgICBteSAkY29tbWl0aWQgPSA8UkVBREVSPjsgICAgIyByZWFkCiAgICBjaG9tcCAkY29tbWl0aWQ7CiAgICBjbG9zZSBSRUFERVI7CiAgICB3YWl0cGlkICRwaWQsMDsgICAgICAgICAgICAgIyBjbG9zZTsKCiAgICBpZiAobGVuZ3RoICRjb21taXRpZCAhPSA0MCkgewogICAgICAgIGRpZSAiU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2l0aCB0aGUgY29tbWl0ISAkISAkY29tbWl0aWQiOwogICAgfQogICAgIwogICAgIyBVcGRhdGUgdGhlIGJyYW5jaAogICAgIyAKICAgIG9wZW4gIEhFQUQsICI+IiwiJGdpdF9kaXIvcmVmcy9oZWFkcy8kcHMtPnticmFuY2h9IjsKICAgIHByaW50IEhFQUQgJGNvbW1pdGlkOwogICAgY2xvc2UgSEVBRDsKICAgIHN5c3RlbSgnZ2l0LXVwZGF0ZS1yZWYnLCAnSEVBRCcsICIkcHMtPnticmFuY2h9Iik7CgogICAgIyB0YWcgYWNjb3JkaW5nbHkKICAgIHB0YWcoJHBzLT57aWR9LCAkY29tbWl0aWQpOyAjIHByaXZhdGUgdGFnCiAgICBpZiAoJG9wdF9UIHx8ICRwcy0+e3R5cGV9IGVxICd0JyB8fCAkcHMtPnt0eXBlfSBlcSAnaScpIHsKICAgICAgICB0YWcoJHBzLT57aWR9LCAkY29tbWl0aWQpOwogICAgfQogICAgcHJpbnQgIiAqIENvbW1pdHRlZCAkcHMtPntpZH1cbiI7CiAgICBwcmludCAiICAgKyB0cmVlICAgJHRyZWVcbiI7CiAgICBwcmludCAiICAgKyBjb21taXQgJGNvbW1pdGlkXG4iOwogICAgJG9wdF92ICYmIHByaW50ICIgICArIGNvbW1pdCBkYXRlIGlzICAkcHMtPntkYXRlfSBcbiI7CiAgICAkb3B0X3YgJiYgcHJpbnQgIiAgICsgcGFyZW50czogICIsam9pbignICcsQHBhciksIlxuIjsKICAgIGlmIChteSAkZGlydHkgPSBgZ2l0LWRpZmYtZmlsZXNgKSB7CiAgICAgICAgZGllICIyMiBVbmNsZWFuIHRyZWUgd2hlbiBhYm91dCB0byBwcm9jZXNzICRwcy0+e2lkfSAiIC4KICAgICAgICAgICAgIiAtIGRpZCB3ZSBmYWlsIHRvIGNvbW1pdCBjbGVhbmx5IGJlZm9yZT9cbiRkaXJ0eSI7CiAgICB9Cn0KCmlmICgkb3B0X3YpIHsKICAgIGZvcmVhY2ggKHNvcnQga2V5cyAlc3RhdHMpIHsKICAgICAgICBwcmludCIgJF86ICRzdGF0c3skX31cbiI7CiAgICB9Cn0KZXhpdCAwOwoKIyB1c2VkIGJ5IHRoZSBhY2N1cmF0ZSBzdHJhdGVneToKc3ViIHN5bmNfdG9fcHMgewogICAgbXkgJHBzID0gc2hpZnQ7CiAgICBteSAkdHJlZV9kaXIgPSAkdG1wLicvJy50cmVlX2Rpcm5hbWUoJHBzLT57aWR9KTsKICAgIAogICAgJG9wdF92ICYmIHByaW50ICJzeW5jX3RvX3BzKCRwcy0+e2lkfSkgbWV0aG9kOiAiOwoKICAgIGlmICgtZCAkdHJlZV9kaXIpIHsKICAgICAgICBpZiAoJHBzLT57dHlwZX0gZXEgJ3QnKSB7CgkgICAgJG9wdF92ICYmIHByaW50ICJnZXQgKHRhZylcbiI7CiAgICAgICAgICAgICMgbG9va3MgbGlrZSBhIHRhZy1vbmx5IG9yICh3b3JzZSwpIGEgbWl4ZWQgdGFncy9jaGFuZ2VzZXQgYnJhbmNoLAogICAgICAgICAgICAjIGNhbid0IHJlbHkgb24gcmVwbGF5IHRvIHdvcmsgY29ycmVjdGx5IG9uIHRoZXNlCiAgICAgICAgICAgIHJtdHJlZSgkdHJlZV9kaXIpOwogICAgICAgICAgICBzYWZlX3BpcGVfY2FwdHVyZSgkVExBLCdnZXQnLCctLW5vLXByaXN0aW5lJywkcHMtPntpZH0sJHRyZWVfZGlyKTsKICAgICAgICAgICAgJHN0YXRze2dldF90YWd9Kys7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIG15ICR0cmVlX2lkID0gYXJjaF90cmVlX2lkKCR0cmVlX2Rpcik7CiAgICAgICAgICAgICAgICBpZiAoJHBzLT57cGFyZW50X2lkfSAmJiAoJHBzLT57cGFyZW50X2lkfSBlcSAkdHJlZV9pZCkpIHsKICAgICAgICAgICAgICAgICAgICAjIHRoZSBjb21tb24gY2FzZSAoaG9wZWZ1bGx5KQoJCSAgICAkb3B0X3YgJiYgcHJpbnQgInJlcGxheVxuIjsKICAgICAgICAgICAgICAgICAgICBzYWZlX3BpcGVfY2FwdHVyZSgkVExBLCdyZXBsYXknLCctZCcsJHRyZWVfZGlyLCRwcy0+e2lkfSk7CiAgICAgICAgICAgICAgICAgICAgJHN0YXRze3JlcGxheX0rKzsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgIyBnZXR0aW5nIG9uZSB0cmVlIGlzIHVzdWFsbHkgZmFzdGVyIHRoYW4gZ2V0dGluZyB0d28gdHJlZXMKICAgICAgICAgICAgICAgICAgICAjIGFuZCBhcHBseWluZyB0aGUgZGVsdGEgLi4uCiAgICAgICAgICAgICAgICAgICAgcm10cmVlKCR0cmVlX2Rpcik7CgkJICAgICRvcHRfdiAmJiBwcmludCAiYXBwbHktZGVsdGFcbiI7CiAgICAgICAgICAgICAgICAgICAgc2FmZV9waXBlX2NhcHR1cmUoJFRMQSwnZ2V0JywnLS1uby1wcmlzdGluZScsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcHMtPntpZH0sJHRyZWVfZGlyKTsKICAgICAgICAgICAgICAgICAgICAkc3RhdHN7Z2V0X2RlbHRhfSsrOwogICAgICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgICAgIyBuZXcgYnJhbmNoIHdvcmsKICAgICAgICAkb3B0X3YgJiYgcHJpbnQgImdldCAobmV3IHRyZWUpXG4iOwogICAgICAgIHNhZmVfcGlwZV9jYXB0dXJlKCRUTEEsJ2dldCcsJy0tbm8tcHJpc3RpbmUnLCRwcy0+e2lkfSwkdHJlZV9kaXIpOwogICAgICAgICRzdGF0c3tnZXRfbmV3fSsrOwogICAgfQogICAKICAgICMgYWRkZWQgLUkgZmxhZyB0byByc3luYyBzaW5jZSB3ZSdyZSBnb2luZyB0byBmYXN0ISBBSUVFRUVFISEhIQogICAgc3lzdGVtKCdyc3luYycsJy1hSScsJy0tZGVsZXRlJywnLS1leGNsdWRlJywkZ2l0X2RpciwKIyAgICAgICAgICAgICAgICctLWV4Y2x1ZGUnLCcuYXJjaC1pbnZlbnRvcnknLAogICAgICAgICAgICAgICAgJy0tZXhjbHVkZScsJy5hcmNoLWlkcycsJy0tZXhjbHVkZScsJ3thcmNofScsCiAgICAgICAgICAgICAgICAnLS1leGNsdWRlJywnKyonLCctLWV4Y2x1ZGUnLCcsKicsCiAgICAgICAgICAgICAgICAiJHRyZWVfZGlyLyIsJy4vJykgPT0gMCBvciBkaWUgIkNhbm5vdCByc3luYyAkdHJlZV9kaXI6ICQhICQ/IjsKICAgIHJldHVybiAkdHJlZV9kaXI7Cn0KCnN1YiBhcHBseV9pbXBvcnQgewogICAgbXkgJHBzID0gc2hpZnQ7CiAgICBteSAkYm5hbWUgPSBnaXRfYnJhbmNobmFtZSgkcHMtPntpZH0pOwoKICAgIG1rcGF0aCgkdG1wKTsKCiAgICBzYWZlX3BpcGVfY2FwdHVyZSgkVExBLCdnZXQnLCctcycsJy0tbm8tcHJpc3RpbmUnLCRwcy0+e2lkfSwiJHRtcC9pbXBvcnQiKTsKICAgIGRpZSAiQ2Fubm90IGdldCBpbXBvcnQ6ICQhIiBpZiAkPzsgICAgCiAgICBzeXN0ZW0oJ3JzeW5jJywnLWFJJywnLS1kZWxldGUnLCAnLS1leGNsdWRlJywkZ2l0X2RpciwKCQknLS1leGNsdWRlJywnLmFyY2gtaWRzJywnLS1leGNsdWRlJywne2FyY2h9JywKCQkiJHRtcC9pbXBvcnQvIiwgJy4vJyk7CiAgICBkaWUgIkNhbm5vdCByc3luYyBpbXBvcnQ6JCEiIGlmICQ/OwogICAgCiAgICBybXRyZWUoIiR0bXAvaW1wb3J0Iik7CiAgICBkaWUgIkNhbm5vdCByZW1vdmUgdGVtcGRpcjogJCEiIGlmICQ/OwogICAgCgogICAgcmV0dXJuIDE7Cn0KCnN1YiBhcHBseV9jc2V0IHsKICAgIG15ICRwcyA9IHNoaWZ0OwoKICAgIG1rcGF0aCgkdG1wKTsKCiAgICAjIGdldCB0aGUgY2hhbmdlc2V0CiAgICBzYWZlX3BpcGVfY2FwdHVyZSgkVExBLCdnZXQtY2hhbmdlc2V0JywkcHMtPntpZH0sIiR0bXAvY2hhbmdlc2V0Iik7CiAgICBkaWUgIkNhbm5vdCBnZXQgY2hhbmdlc2V0OiAkISIgaWYgJD87CiAgICAKICAgICMgYXBwbHkgcGF0Y2hlcwogICAgaWYgKGBmaW5kICR0bXAvY2hhbmdlc2V0L3BhdGNoZXMgLXR5cGUgZiAtbmFtZSAnKi5wYXRjaCdgKSB7CiAgICAgICAgIyB0aGlzIGNhbiBiZSBzcGVkIHVwIGNvbnNpZGVyYWJseSBieSBkb2luZwogICAgICAgICMgICAgKGZpbmQgfCB4YXJncyBjYXQpIHwgcGF0Y2gKICAgICAgICAjIGJ1dCB0aGF0IGNuYSBnZXQgbXVja2VkIHVwIGJ5IHBhdGNoZXMKICAgICAgICAjIHdpdGggbWlzc2luZyB0cmFpbGluZyBuZXdsaW5lcyBvciB0aGUgc3RhbmRhcmQgCiAgICAgICAgIyAnbWlzc2luZyBuZXdsaW5lJyBmbGFnIGluIHRoZSBwYXRjaCAtIHBvc3NpYmx5CiAgICAgICAgIyBwcm9kdWNlZCB3aXRoIGFuIG9sZC9idWdneSBkaWZmLgogICAgICAgICMgc2xvdyBhbmQgc2FmZSwgd2UgaW52b2tlIHBhdGNoIG9uY2UgcGVyIHBhdGNoZmlsZQogICAgICAgIGBmaW5kICR0bXAvY2hhbmdlc2V0L3BhdGNoZXMgLXR5cGUgZiAtbmFtZSAnKi5wYXRjaCcgLXByaW50MCB8IGdyZXAgLXp2ICd7YXJjaH0nIHwgeGFyZ3MgLWlGSUxFIC0wIC0tbm8tcnVuLWlmLWVtcHR5IHBhdGNoIC1wMSAtLWZvcndhcmQgLWlGSUxFYDsKICAgICAgICBkaWUgIlByb2JsZW0gYXBwbHlpbmcgcGF0Y2hlcyEgJCEiIGlmICQ/OwogICAgfQoKICAgICMgYXBwbHkgY2hhbmdlZCBiaW5hcnkgZmlsZXMKICAgIGlmIChteSBAbW9kaWZpZWQgPSBgZmluZCAkdG1wL2NoYW5nZXNldC9wYXRjaGVzIC10eXBlIGYgLW5hbWUgJyoubW9kaWZpZWQnYCkgewogICAgICAgIGZvcmVhY2ggbXkgJG1vZCAoQG1vZGlmaWVkKSB7CiAgICAgICAgICAgIGNob21wICRtb2Q7CiAgICAgICAgICAgIG15ICRvcmlnID0gJG1vZDsKICAgICAgICAgICAgJG9yaWcgPX4gcy9cLm1vZGlmaWVkJC8vOyAjIGxhenkKICAgICAgICAgICAgJG9yaWcgPX4gcyFeXFEkdG1wXEUvY2hhbmdlc2V0L3BhdGNoZXMvISE7CiAgICAgICAgICAgICNwcmludCAicnN5bmMgLXAgJyRtb2QnICckb3JpZyciOwogICAgICAgICAgICBzeXN0ZW0oJ3JzeW5jJywnLXAnLCRtb2QsIi4vJG9yaWciKTsKICAgICAgICAgICAgZGllICJQcm9ibGVtIGFwcGx5aW5nIGJpbmFyeSBjaGFuZ2VzISAkISIgaWYgJD87CiAgICAgICAgfQogICAgfQoKICAgICMgYnJpbmcgaW4gbmV3IGZpbGVzCiAgICBzeXN0ZW0oJ3JzeW5jJywnLWFJJywnLS1leGNsdWRlJywkZ2l0X2RpciwKICAgIAkJJy0tZXhjbHVkZScsJy5hcmNoLWlkcycsCgkJJy0tZXhjbHVkZScsICd7YXJjaH0nLAoJCSIkdG1wL2NoYW5nZXNldC9uZXctZmlsZXMtYXJjaGl2ZS8iLCcuLycpOwoKICAgICMgZGVsZXRlZCBmaWxlcyBhcmUgaGludGVkIGZyb20gdGhlIGNvbW1pdGxvZyBwcm9jZXNzaW5nCgogICAgcm10cmVlKCIkdG1wL2NoYW5nZXNldCIpOwp9CgoKIyA9Zm9yIHJlZmVyZW5jZQojIG5vdGVzOiAqLWZpbGVzLy1kaXJlY3RvcmllcyBrZXlzIGNhbm5vdCBoYXZlIHNwYWNlcywgdGhleSdyZSBhbHdheXMKIyBwaWthLWVzY2FwZWQuICBFdmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBuZXdsaW5lCiMgQSBsb2cgZW50cnkgbG9va3MgbGlrZToKIyBSZXZpc2lvbjogbW9vZGxlLW9yZy0tbW9vZGxlLS0xLjMuMy0tcGF0Y2gtMTUKIyBBcmNoaXZlOiBhcmNoLWVkdWZvcmdlQGNhdGFseXN0Lm5ldC5uei0tMjAwNAojIENyZWF0b3I6IFBlbm55IExlYWNoIDxwZW5ueUBjYXRhbHlzdC5uZXQubno+CiMgRGF0ZTogV2VkIE1heSAyNSAxNDoxNTozNCBOWlNUIDIwMDUKIyBTdGFuZGFyZC1kYXRlOiAyMDA1LTA1LTI1IDAyOjE1OjM0IEdNVAojIE5ldy1maWxlczogbGFuZy9kZS8uYXJjaC1pZHMvYmxvY2tfZ2xvc3NhcnlfcmFuZG9tLnBocC5pZAojICAgICBsYW5nL2RlLy5hcmNoLWlkcy9ibG9ja19odG1sLnBocC5pZAojIE5ldy1kaXJlY3RvcmllczogbGFuZy9kZS9oZWxwL3F1ZXN0aW9ubmFpcmUKIyAgICAgbGFuZy9kZS9oZWxwL3F1ZXN0aW9ubmFpcmUvLmFyY2gtaWRzCiMgUmVuYW1lZC1maWxlczogLmFyY2gtaWRzL2RiX3NlYXJzLnNxbC5pZCBkYi8uYXJjaC1pZHMvZGJfc2VhcnMuc3FsLmlkCiMgICAgZGJfc2VhcnMuc3FsIGRiL2RiX3NlYXJzLnNxbAojIFJlbW92ZWQtZmlsZXM6IGxhbmcvYmUvZG9jcy8uYXJjaC1pZHMvcmVsZWFzZS5odG1sLmlkCiMgICAgIGxhbmcvYmUvZG9jcy8uYXJjaC1pZHMvcmVsZWFzZW9sZC5odG1sLmlkCiMgTW9kaWZpZWQtZmlsZXM6IGFkbWluL2Nyb24ucGhwIGFkbWluL2RlbGV0ZS5waHAKIyAgICAgYWRtaW4vZWRpdG9yLmh0bWwgYmFja3VwL2xpYi5waHAgYmFja3VwL3Jlc3RvcmUucGhwCiMgTmV3LXBhdGNoZXM6IGFyY2gtZWR1Zm9yZ2VAY2F0YWx5c3QubmV0Lm56LS0yMDA0L21vb2RsZS1vcmctLW1vb2RsZS0tMS4zLjMtLXBhdGNoLTE1CiMgU3VtbWFyeTogVXBkYXRpbmcgdG8gbGF0ZXN0IGZyb20gTU9PRExFXzE0X1NUQUJMRSAoMS40LjUrKQojICAgc3VtbWFyeSBjYW4gYmUgbXVsdGlsaW5lIHdpdGggYSBsZWFkaW5nIHNwYWNlIGp1c3QgbGlrZSB0aGUgYWJvdmUgZmllbGRzCiMgS2V5d29yZHM6CiMKIyBVcGRhdGluZyB5YWRkYSB0YWRkYSB0YWRkYSBtYWRkYQpzdWIgcGFyc2Vsb2cgewogICAgbXkgKCRwcywgJGxvZykgPSBAXzsKICAgIG15ICRrZXkgPSB1bmRlZjsKCiAgICAjIGhlYWRlcnMgd2Ugd2FudCB0aGF0IGNvbnRhaW4gZmlsZW5hbWVzOgogICAgbXkgJXdhbnRfaGVhZGVycyA9ICgKICAgICAgICBuZXdfZmlsZXMgPT4gMSwKICAgICAgICBtb2RpZmllZF9maWxlcyA9PiAxLAogICAgICAgIHJlbmFtZWRfZmlsZXMgPT4gMSwKICAgICAgICByZW5hbWVkX2RpcmVjdG9yaWVzID0+IDEsCiAgICAgICAgcmVtb3ZlZF9maWxlcyA9PiAxLAogICAgICAgIHJlbW92ZWRfZGlyZWN0b3JpZXMgPT4gMSwKICAgICk7CiAgICAKICAgIGNob21wIChAJGxvZyk7CiAgICB3aGlsZSAoJF8gPSBzaGlmdCBAJGxvZykgewogICAgICAgIGlmICgvXkNvbnRpbnVhdGlvbi1vZjpccyooLiopLykgewogICAgICAgICAgICAkcHMtPnt0YWd9ID0gJDE7CiAgICAgICAgICAgICRrZXkgPSB1bmRlZjsKICAgICAgICB9IGVsc2lmICgvXlN1bW1hcnk6XHMqKC4qKSQvICkgewogICAgICAgICAgICAjIHN1bW1hcnkgY2FuIGJlIG11bHRpbGluZSBhcyBsb25nIGFzIGl0IGhhcyBhIGxlYWRpbmcgc3BhY2UKICAgICAgICAgICAgJHBzLT57c3VtbWFyeX0gPSBbICQxIF07CiAgICAgICAgICAgICRrZXkgPSAnc3VtbWFyeSc7CiAgICAgICAgfSBlbHNpZiAoL15DcmVhdG9yOiAoLiopXHMqPChbXlw+XSspPi8pIHsKICAgICAgICAgICAgJHBzLT57YXV0aG9yfSA9ICQxOwogICAgICAgICAgICAkcHMtPntlbWFpbH0gPSAkMjsKICAgICAgICAgICAgJGtleSA9IHVuZGVmOwogICAgICAgICMgYW55ICotZmlsZXMgb3IgKi1kaXJlY3RvcmllcyBjYW4gYmUgcmVhZCBoZXJlOgogICAgICAgIH0gZWxzaWYgKC9eKFtBLVpdW2EtelwtXSspOlxzKiguKikkLykgewogICAgICAgICAgICBteSAkdmFsID0gJDI7CiAgICAgICAgICAgICRrZXkgPSBsYyAkMTsKICAgICAgICAgICAgJGtleSA9fiB0ci8tL18vOyAjIHRvbyBsYXp5IHRvIHF1b3RlIDpQCiAgICAgICAgICAgIGlmICgkd2FudF9oZWFkZXJzeyRrZXl9KSB7CiAgICAgICAgICAgICAgICBwdXNoIEB7JHBzLT57JGtleX19LCBzcGxpdCgvXHMrLywgJHZhbCk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAka2V5ID0gdW5kZWY7CiAgICAgICAgICAgIH0KICAgICAgICB9IGVsc2lmICgvXiQvKSB7CiAgICAgICAgICAgIGxhc3Q7ICMgcmVtYWluZGVyIG9mIEAkbG9nIHRoYXQgZGlkbid0IGdldCBzaGlmdGVkIG9mZiBpcyBtZXNzYWdlCiAgICAgICAgfSBlbHNpZiAoJGtleSkgewogICAgICAgICAgICBpZiAoL15ccysoLiopJC8pIHsKICAgICAgICAgICAgICAgIGlmICgka2V5IGVxICdzdW1tYXJ5JykgewogICAgICAgICAgICAgICAgICAgIHB1c2ggQHskcHMtPnska2V5fX0sICQxOwogICAgICAgICAgICAgICAgfSBlbHNlIHsgIyBmaWxlcy9kaXJlY3RvcmllczoKICAgICAgICAgICAgICAgICAgICBwdXNoIEB7JHBzLT57JGtleX19LCBzcGxpdCgvXHMrLywgJDEpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgJGtleSA9IHVuZGVmOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQogICAKICAgICMgcG9zdC1wcm9jZXNzaW5nOgogICAgJHBzLT57c3VtbWFyeX0gPSBqb2luKCJcbiIsQHskcHMtPntzdW1tYXJ5fX0pLiJcbiI7CiAgICAkcHMtPnttZXNzYWdlfSA9IGpvaW4oIlxuIixAJGxvZyk7CiAgICAKICAgICMgc2tpcCBBcmNoIGNvbnRyb2wgZmlsZXMsIHVuZXNjYXBlIHBpa2EtZXNjYXBlZCBmaWxlcwogICAgZm9yZWFjaCBteSAkayAoa2V5cyAld2FudF9oZWFkZXJzKSB7CiAgICAgICAgbmV4dCB1bmxlc3MgKGRlZmluZWQgJHBzLT57JGt9KTsKICAgICAgICBteSBAdG1wID0gKCk7CiAgICAgICAgZm9yZWFjaCBteSAkdCAoQHskcHMtPnska319KSB7CiAgICAgICAgICAgbmV4dCB1bmxlc3MgbGVuZ3RoICgkdCk7CiAgICAgICAgICAgbmV4dCBpZiAkdCA9fiBtIVx7YXJjaFx9LyE7CiAgICAgICAgICAgbmV4dCBpZiAkdCA9fiBtIVwuYXJjaC1pZHMvITsKICAgICAgICAgICAjIHNob3VsZCB3ZSBza2lwIHRoaXM/CiAgICAgICAgICAgbmV4dCBpZiAkdCA9fiBtIVwuYXJjaC1pbnZlbnRvcnkkITsKICAgICAgICAgICAjIHRsYSBjYXQtYXJjaGl2ZS1sb2cgd2lsbCBnaXZlIHVzIGZpbGVuYW1lcyB3aXRoIHNwYWNlcyBhcyBmaWxlXChzcCluYW1lIC0gd2h5PwogICAgICAgICAgICMgd2UgY2FuIGFzc3VtZSB0aGF0IGFueSBmaWxlbmFtZSB3aXRoIFwgaW5kaWNhdGVzIHNvbWUgcGlrYSBlc2NhcGluZyB0aGF0IHdlIHdhbnQgdG8gZ2V0IHJpZCBvZi4KICAgICAgICAgICBpZiAoJHQgPX4gL1xcLyApewogICAgICAgICAgICAgICAkdCA9IChzYWZlX3BpcGVfY2FwdHVyZSgkVExBLCdlc2NhcGUnLCctLXVuZXNjYXBlZCcsJHQpKVswXTsKICAgICAgICAgICB9CiAgICAgICAgICAgcHVzaCBAdG1wLCAkdDsKICAgICAgICB9CiAgICAgICAgJHBzLT57JGt9ID0gXEB0bXA7CiAgICB9Cn0KCiMgd3JpdGUvcmVhZCBhIHRhZwpzdWIgdGFnIHsKICAgIG15ICgkdGFnLCAkY29tbWl0KSA9IEBfOwogCiAgICBpZiAoJG9wdF9vKSB7CiAgICAgICAgJHRhZyA9fiBzfC98LS18ZzsKICAgIH0gZWxzZSB7CiAgICAgICAgIyBkb24ndCB1c2Ugc3ViZGlycyBmb3IgdGFncyB5ZXQsIGl0IGNvdWxkIHNjcmV3IHVwIG90aGVyIHBvcmNlbGFpbnMKICAgICAgICAkdGFnID1+IHN8L3wsfGc7CiAgICB9CiAgICAKICAgIGlmICgkY29tbWl0KSB7CiAgICAgICAgb3BlbihDLCI+IiwiJGdpdF9kaXIvcmVmcy90YWdzLyR0YWciKQogICAgICAgICAgICBvciBkaWUgIkNhbm5vdCBjcmVhdGUgdGFnICR0YWc6ICQhXG4iOwogICAgICAgIHByaW50IEMgIiRjb21taXRcbiIKICAgICAgICAgICAgb3IgZGllICJDYW5ub3Qgd3JpdGUgdGFnICR0YWc6ICQhXG4iOwogICAgICAgIGNsb3NlKEMpCiAgICAgICAgICAgIG9yIGRpZSAiQ2Fubm90IHdyaXRlIHRhZyAkdGFnOiAkIVxuIjsKICAgICAgICBwcmludCAiICogQ3JlYXRlZCB0YWcgJyR0YWcnIG9uICckY29tbWl0J1xuIiBpZiAkb3B0X3Y7CiAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgIyByZWFkCiAgICAgICAgb3BlbihDLCI8IiwiJGdpdF9kaXIvcmVmcy90YWdzLyR0YWciKQogICAgICAgICAgICBvciBkaWUgIkNhbm5vdCByZWFkIHRhZyAkdGFnOiAkIVxuIjsKICAgICAgICAkY29tbWl0ID0gPEM+OwogICAgICAgIGNob21wICRjb21taXQ7CiAgICAgICAgZGllICJFcnJvciByZWFkaW5nIHRhZyAkdGFnOiAkIVxuIiB1bmxlc3MgbGVuZ3RoICRjb21taXQgPT0gNDA7CiAgICAgICAgY2xvc2UoQykKICAgICAgICAgICAgb3IgZGllICJDYW5ub3QgcmVhZCB0YWcgJHRhZzogJCFcbiI7CiAgICAgICAgcmV0dXJuICRjb21taXQ7CiAgICB9Cn0KCiMgd3JpdGUvcmVhZCBhIHByaXZhdGUgdGFnCiMgcmVhZHMgZmFpbCBzb2Z0bHkgaWYgdGhlIHRhZyBpc24ndCB0aGVyZQpzdWIgcHRhZyB7CiAgICBteSAoJHRhZywgJGNvbW1pdCkgPSBAXzsKCiAgICAjIGRvbid0IHVzZSBzdWJkaXJzIGZvciB0YWdzIHlldCwgaXQgY291bGQgc2NyZXcgdXAgb3RoZXIgcG9yY2VsYWlucwogICAgJHRhZyA9fiBzfC98LHxnOyAKICAgIAogICAgbXkgJHRhZ19maWxlID0gIiRwdGFnX2Rpci8kdGFnIjsKICAgIG15ICR0YWdfYnJhbmNoX2RpciA9IGRpcm5hbWUoJHRhZ19maWxlKTsKICAgIG1rcGF0aCgkdGFnX2JyYW5jaF9kaXIpIHVubGVzcyAoLWQgJHRhZ19icmFuY2hfZGlyKTsKCiAgICBpZiAoJGNvbW1pdCkgeyAgICAgICAgICAgICAgIyB3cml0ZQogICAgICAgIG9wZW4oQywiPiIsJHRhZ19maWxlKQogICAgICAgICAgICBvciBkaWUgIkNhbm5vdCBjcmVhdGUgdGFnICR0YWc6ICQhXG4iOwogICAgICAgIHByaW50IEMgIiRjb21taXRcbiIKICAgICAgICAgICAgb3IgZGllICJDYW5ub3Qgd3JpdGUgdGFnICR0YWc6ICQhXG4iOwogICAgICAgIGNsb3NlKEMpCiAgICAgICAgICAgIG9yIGRpZSAiQ2Fubm90IHdyaXRlIHRhZyAkdGFnOiAkIVxuIjsKCSRycHRhZ3N7JGNvbW1pdH0gPSAkdGFnIAoJICAgIHVubGVzcyAkdGFnID1+IG0vLS1iYXNlLTAkLzsKICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAjIHJlYWQKICAgICAgICAjIGlmIHRoZSB0YWcgaXNuJ3QgdGhlcmUsIHJldHVybiAwCiAgICAgICAgdW5sZXNzICggLXMgJHRhZ19maWxlKSB7CiAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBvcGVuKEMsIjwiLCR0YWdfZmlsZSkKICAgICAgICAgICAgb3IgZGllICJDYW5ub3QgcmVhZCB0YWcgJHRhZzogJCFcbiI7CiAgICAgICAgJGNvbW1pdCA9IDxDPjsKICAgICAgICBjaG9tcCAkY29tbWl0OwogICAgICAgIGRpZSAiRXJyb3IgcmVhZGluZyB0YWcgJHRhZzogJCFcbiIgdW5sZXNzIGxlbmd0aCAkY29tbWl0ID09IDQwOwogICAgICAgIGNsb3NlKEMpCiAgICAgICAgICAgIG9yIGRpZSAiQ2Fubm90IHJlYWQgdGFnICR0YWc6ICQhXG4iOwoJdW5sZXNzIChkZWZpbmVkICRycHRhZ3N7JGNvbW1pdH0pIHsKCSAgICAkcnB0YWdzeyRjb21taXR9ID0gJHRhZzsKCX0KICAgICAgICByZXR1cm4gJGNvbW1pdDsKICAgIH0KfQoKc3ViIGZpbmRfcGFyZW50cyB7CiAgICAjCiAgICAjIElkZW50aWZ5IHdoYXQgYnJhbmNoZXMgYXJlIG1lcmdpbmcgaW50byBtZQogICAgIyBhbmQgd2hldGhlciB3ZSBhcmUgZnVsbHkgbWVyZ2VkCiAgICAjIGdpdC1tZXJnZS1iYXNlIDxoZWFkc2hhPiA8aGVhZHNoYT4gc2hvdWxkIHRlbGwKICAgICMgbWUgd2hhdCB0aGUgYmFzZSBvZiB0aGUgbWVyZ2Ugc2hvdWxkIGJlIAogICAgIwogICAgbXkgJHBzID0gc2hpZnQ7CgogICAgbXkgJWJyYW5jaGVzOyAjIGhvbGRzIGFuIGFycmF5cmVmIHBlciBicmFuY2gKICAgICAgICAgICAgICAgICAgIyB0aGUgYXJyYXlyZWYgY29udGFpbnMgYSBsaXN0IG9mCiAgICAgICAgICAgICAgICAgICMgbWVyZ2VkIHBhdGNoZXMgYmV0d2VlbiB0aGUgYmFzZQogICAgICAgICAgICAgICAgICAjIG9mIHRoZSBtZXJnZSBhbmQgdGhlIGN1cnJlbnQgaGVhZAoKICAgIG15IEBwYXJlbnRzOyAgIyBwYXJlbnRzIGZvdW5kIGZvciB0aGlzIGNvbW1pdAoKICAgICMgc2ltcGxlIGxvb3AgdG8gc3BsaXQgdGhlIG1lcmdlcwogICAgIyBwZXIgYnJhbmNoCiAgICBmb3JlYWNoIG15ICRtZXJnZSAoQHskcHMtPnttZXJnZXN9fSkgewoJbXkgJGJyYW5jaCA9IGdpdF9icmFuY2huYW1lKCRtZXJnZSk7Cgl1bmxlc3MgKGRlZmluZWQgJGJyYW5jaGVzeyRicmFuY2h9ICl7CgkgICAgJGJyYW5jaGVzeyRicmFuY2h9ID0gW107Cgl9CglwdXNoIEB7JGJyYW5jaGVzeyRicmFuY2h9fSwgJG1lcmdlOwogICAgfQoKICAgICMKICAgICMgZm9yZWFjaCBicmFuY2ggZmluZCBhIG1lcmdlIGJhc2UgYW5kIHdhbGsgaXQgdG8gdGhlIAogICAgIyBoZWFkIHdoZXJlIHdlIGFyZSwgY29sbGVjdGluZyB0aGUgbWVyZ2VkIHBhdGNoc2V0cyB0aGF0CiAgICAjIEFyY2ggaGFzIHJlY29yZGVkLiBLZWVwIHRoYXQgaW4gQGhhdmUKICAgICMgQ29tcGFyZSB0aGF0IHdpdGggdGhlIGNvbW1pdHMgb24gdGhlIG90aGVyIGJyYW5jaAogICAgIyBiZXR3ZWVuIG1lcmdlLWJhc2UgYW5kIHRoZSB0aXAgb2YgdGhlIGJyYW5jaCAoQG5lZWQpCiAgICAjIGFuZCBzZWUgaWYgd2UgaGF2ZSBhIHNlcmllcyBvZiBjb25zZWN1dGl2ZSBwYXRjaGVzCiAgICAjIHN0YXJ0aW5nIGZyb20gdGhlIG1lcmdlIGJhc2UuIFRoZSB0aXAgb2YgdGhlIHNlcmllcwogICAgIyBvZiBjb25zZWN1dGl2ZSBwYXRjaGVzIG1lcmdlZCBpcyBvdXIgbmV3IHBhcmVudCBmb3IgCiAgICAjIHRoYXQgYnJhbmNoLgogICAgIwogICAgZm9yZWFjaCBteSAkYnJhbmNoIChrZXlzICVicmFuY2hlcykgewoKCSMgY2hlY2sgdGhhdCB3ZSBhY3R1YWxseSBrbm93IGFib3V0IHRoZSBicmFuY2gKCW5leHQgdW5sZXNzIC1lICIkZ2l0X2Rpci9yZWZzL2hlYWRzLyRicmFuY2giOwoKCW15ICRtZXJnZWJhc2UgPSBgZ2l0LW1lcmdlLWJhc2UgJGJyYW5jaCAkcHMtPnticmFuY2h9YDsKIAlpZiAoJD8pIHsgCiAJICAgICMgRG9uJ3QgZGllIGhlcmUsIEFyY2ggc3VwcG9ydHMgb25lLXdheSBjaGVycnktcGlja2luZwogCSAgICAjIGJldHdlZW4gYnJhbmNoZXMgd2l0aCBubyBjb21tb24gYmFzZSAob3IgYW55IHJlbGF0aW9uc2hpcAogCSAgICAjIGF0IGFsbCBiZWZvcmVoYW5kKQogCSAgICB3YXJuICJDYW5ub3QgZmluZCBtZXJnZSBiYXNlIGZvciAkYnJhbmNoIGFuZCAkcHMtPnticmFuY2h9IjsKIAkgICAgbmV4dDsKIAl9CgljaG9tcCAkbWVyZ2ViYXNlOwoKCSMgbm93IHdhbGsgdXAgdG8gdGhlIG1lcmdlcG9pbnQgY29sbGVjdGluZyB3aGF0IHBhdGNoZXMgd2UgaGF2ZQoJbXkgJGJyYW5jaHRpcCA9IGdpdF9yZXZfcGFyc2UoJHBzLT57YnJhbmNofSk7CglteSBAYW5jZXN0b3JzID0gYGdpdC1yZXYtbGlzdCAtLW1lcmdlLW9yZGVyICRicmFuY2h0aXAgXiRtZXJnZWJhc2VgOwoJbXkgJWhhdmU7ICMgY29sbGVjdGVkIG1lcmdlcyB0aGlzIGJyYW5jaCBoYXMKCWZvcmVhY2ggbXkgJG1lcmdlIChAeyRwcy0+e21lcmdlc319KSB7CgkgICAgJGhhdmV7JG1lcmdlfSA9IDE7Cgl9CglteSAlYW5jZXN0b3JzaGF2ZTsKCWZvcmVhY2ggbXkgJHBhciAoQGFuY2VzdG9ycykgewoJICAgICRwYXIgPSBjb21taXRpZDJwc2V0KCRwYXIpOwoJICAgIGlmIChkZWZpbmVkICRwYXItPnttZXJnZXN9KSB7CgkJZm9yZWFjaCBteSAkbWVyZ2UgKEB7JHBhci0+e21lcmdlc319KSB7CgkJICAgICRhbmNlc3RvcnNoYXZleyRtZXJnZX09MTsKCQl9CgkgICAgfQoJfQoJIyBwcmludCAiKysrKyBNZXJnZXMgaW4gJHBzLT57aWR9IGFyZS4uLi5cbiI7CgkjIG15IEBoYXZlID0gc29ydCBrZXlzICVoYXZlOwlwcmludCBEdW1wZXIoXEBoYXZlKTsKCgkjIG1lcmdlIHdoYXQgd2UgaGF2ZSB3aXRoIHdoYXQgYW5jZXN0b3JzIGhhdmUKCSVoYXZlID0gKCVoYXZlLCAlYW5jZXN0b3JzaGF2ZSk7CgoJIyBzZWUgd2hhdCB0aGUgcmVtb3RlIGJyYW5jaCBoYXMgLSB0aGVzZSBhcmUgdGhlIG1lcmdlcyB3ZSAKCSMgd2lsbCB3YW50IHRvIGhhdmUgaW4gYSBjb25zZWN1dGl2ZSBzZXJpZXMgZnJvbSB0aGUgbWVyZ2ViYXNlCglteSAkb3RoZXJicmFuY2h0aXAgPSBnaXRfcmV2X3BhcnNlKCRicmFuY2gpOwoJbXkgQG5lZWRyYXcgPSBgZ2l0LXJldi1saXN0IC0tbWVyZ2Utb3JkZXIgJG90aGVyYnJhbmNodGlwIF4kbWVyZ2ViYXNlYDsKCW15IEBuZWVkOwoJZm9yZWFjaCBteSAkbmVlZHBzIChAbmVlZHJhdykgeyAJIyBnZXQgdGhlIHBzZXRzCgkgICAgJG5lZWRwcyA9IGNvbW1pdGlkMnBzZXQoJG5lZWRwcyk7CgkgICAgIyBnaXQtcmV2LWxpc3Qgd2lsbCBhbHNvCgkgICAgIyBsaXN0IGNvbW1pdHMgbWVyZ2VkIGluIHZpYSBlYXJsaWVyIAoJICAgICMgbWVyZ2VzLiB3ZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIGNvbW1pdHMKCSAgICAjIGZyb20gdGhlIGJyYW5jaCB3ZSdyZSBsb29raW5nIGF0CgkgICAgaWYgKCRicmFuY2ggZXEgJG5lZWRwcy0+e2JyYW5jaH0pIHsKCQlwdXNoIEBuZWVkLCAkbmVlZHBzLT57aWR9OwoJICAgIH0KCX0KCgkjIHByaW50ICIrKysrIE1lcmdlcyBmcm9tICRicmFuY2ggd2Ugd2FudCBhcmUuLi4uXG4iOwoJIyBwcmludCBEdW1wZXIoXEBuZWVkKTsKCglteSAkbmV3cGFyZW50OwoJd2hpbGUgKG15ICRuZWVkZWRfY29tbWl0ID0gcG9wIEBuZWVkKSB7CgkgICAgaWYgKCRoYXZleyRuZWVkZWRfY29tbWl0fSkgewoJCSRuZXdwYXJlbnQgPSAkbmVlZGVkX2NvbW1pdDsKCSAgICB9IGVsc2UgewoJCWxhc3Q7ICMgYnJlYWsgb3V0IG9mIHRoZSB3aGlsZQoJICAgIH0KCX0KCWlmICgkbmV3cGFyZW50KSB7CgkgICAgcHVzaCBAcGFyZW50cywgJG5ld3BhcmVudDsKCX0KCgogICAgfSAjIGVuZCBmb3JlYWNoIGJyYW5jaAoKICAgICMgcHJ1bmUgcmVkdW5kYW50IHBhcmVudHMKICAgIG15ICVwYXJlbnRzOwogICAgZm9yZWFjaCBteSAkcCAoQHBhcmVudHMpIHsKCSRwYXJlbnRzeyRwfSA9IDE7CiAgICB9CiAgICBmb3JlYWNoIG15ICRwIChAcGFyZW50cykgewoJbmV4dCB1bmxlc3MgZXhpc3RzICRwc2V0c3skcH17bWVyZ2VzfTsKCW5leHQgdW5sZXNzIHJlZiAgICAkcHNldHN7JHB9e21lcmdlc307CglteSBAbWVyZ2VzID0gQHskcHNldHN7JHB9e21lcmdlc319OwoJZm9yZWFjaCBteSAkbWVyZ2UgKEBtZXJnZXMpIHsKCSAgICBpZiAoJHBhcmVudHN7JG1lcmdlfSkgeyAKCQlkZWxldGUgJHBhcmVudHN7JG1lcmdlfTsKCSAgICB9Cgl9CiAgICB9CgogICAgQHBhcmVudHMgPSAoKTsKICAgIGZvcmVhY2ggKGtleXMgJXBhcmVudHMpIHsKICAgICAgICBwdXNoIEBwYXJlbnRzLCAnLXAnLCBwdGFnKCRfKTsKICAgIH0KICAgIHJldHVybiBAcGFyZW50czsKfQoKc3ViIGdpdF9yZXZfcGFyc2UgewogICAgbXkgJG5hbWUgPSBzaGlmdDsKICAgIG15ICR2YWwgID0gYGdpdC1yZXYtcGFyc2UgJG5hbWVgOwogICAgZGllICJFcnJvcjogZ2l0LXJldi1wYXJzZSAkbmFtZSIgaWYgJD87CiAgICBjaG9tcCAkdmFsOwogICAgcmV0dXJuICR2YWw7Cn0KCiMgcmVzb2x2ZSBhIFNIQTEgdG8gYSBrbm93biBwYXRjaHNldApzdWIgY29tbWl0aWQycHNldCB7CiAgICBteSAkY29tbWl0aWQgPSBzaGlmdDsKICAgIGNob21wICRjb21taXRpZDsKICAgIG15ICRuYW1lID0gJHJwdGFnc3skY29tbWl0aWR9IAoJfHwgZGllICJDYW5ub3QgZmluZCByZXZlcnNlIHRhZyBtYXBwaW5nIGZvciAkY29tbWl0aWQiOwogICAgJG5hbWUgPX4gc3wsfC98OwogICAgbXkgJHBzICAgPSAkcHNldHN7JG5hbWV9IAoJfHwgKHByaW50IER1bXBlcihzb3J0IGtleXMgJXBzZXRzKSkgJiYgZGllICJDYW5ub3QgZmluZCBwYXRjaHNldCBmb3IgJG5hbWUiOwogICAgcmV0dXJuICRwczsKfQoKCiMgYW4gYWx0ZXJhdGl2ZSB0byBgY29tbWFuZGAgdGhhdCBhbGxvd3MgaW5wdXQgdG8gYmUgcGFzc2VkIGFzIGFuIGFycmF5CiMgdG8gd29yayBhcm91bmQgc2hlbGwgcHJvYmxlbXMgd2l0aCB3ZWlyZCBjaGFyYWN0ZXJzIGluIGFyZ3VtZW50cwpzdWIgc2FmZV9waXBlX2NhcHR1cmUgewogICAgbXkgQG91dHB1dDsKICAgIGlmIChteSAkcGlkID0gb3BlbiBteSAkY2hpbGQsICctfCcpIHsKICAgICAgICBAb3V0cHV0ID0gKDwkY2hpbGQ+KTsKICAgICAgICBjbG9zZSAkY2hpbGQgb3IgZGllIGpvaW4oJyAnLEBfKS4iOiAkISAkPyI7CiAgICB9IGVsc2UgewoJZXhlYyhAXykgb3IgZGllICIkISAkPyI7ICMgZXhlYygpIGNhbiBmYWlsIHRoZSBleGVjdXRhYmxlIGNhbid0IGJlIGZvdW5kCiAgICB9CiAgICByZXR1cm4gd2FudGFycmF5ID8gQG91dHB1dCA6IGpvaW4oJycsQG91dHB1dCk7Cn0KCiMgYHRsYSBsb2dzIC1yZiAtZCA8ZGlyPiB8IGhlYWQgLW4xYCBvciBgYmF6IHRyZWUtaWQgPGRpcj5gCnN1YiBhcmNoX3RyZWVfaWQgewogICAgbXkgJGRpciA9IHNoaWZ0OwogICAgY2hvbXAoIG15ICRyZXQgPSAoc2FmZV9waXBlX2NhcHR1cmUoJFRMQSwnbG9ncycsJy1yZicsJy1kJywkZGlyKSlbMF0gKTsKICAgIHJldHVybiAkcmV0Owp9CgpzdWIgYXJjaGl2ZV9yZWFjaGFibGUgewogICAgbXkgJGFyY2hpdmUgPSBzaGlmdDsKICAgIHJldHVybiAxIGlmICRyZWFjaGFibGV7JGFyY2hpdmV9OwogICAgcmV0dXJuIDAgaWYgJHVucmVhY2hhYmxleyRhcmNoaXZlfTsKICAgIAogICAgaWYgKHN5c3RlbSAiJFRMQSB3aGVyZWlzLWFyY2hpdmUgJGFyY2hpdmUgPi9kZXYvbnVsbCIpIHsKICAgICAgICBpZiAoJG9wdF9hICYmIChzeXN0ZW0oJFRMQSwncmVnaXN0ZXItYXJjaGl2ZScsCiAgICAgICAgICAgICAgICAgICAgICAiaHR0cDovL21pcnJvcnMuc291cmNlY29udHJvbC5uZXQvJGFyY2hpdmUiKSA9PSAwKSkgewogICAgICAgICAgICAkcmVhY2hhYmxleyRhcmNoaXZlfSA9IDE7CiAgICAgICAgICAgIHJldHVybiAxOwogICAgICAgIH0KICAgICAgICBwcmludCBTVERFUlIgIkFyY2hpdmUgaXMgdW5yZWFjaGFibGU6ICRhcmNoaXZlXG4iOwogICAgICAgICR1bnJlYWNoYWJsZXskYXJjaGl2ZX0gPSAxOwogICAgICAgIHJldHVybiAwOwogICAgfSBlbHNlIHsKICAgICAgICAkcmVhY2hhYmxleyRhcmNoaXZlfSA9IDE7CiAgICAgICAgcmV0dXJuIDE7CiAgICB9Cn0KCg==",
    "text": "#!/usr/bin/perl -w\n#\n# This tool is copyright (c) 2005, Martin Langhoff.\n# It is released under the Gnu Public License, version 2.\n#\n# The basic idea is to walk the output of tla abrowse, \n# fetch the changesets and apply them. \n#\n\n=head1 Invocation\n\n    git-archimport [ -h ] [ -v ] [ -T ] [ -t tempdir ] <archive>/<branch> [ <archive>/<branch> ]\n\nImports a project from one or more Arch repositories. It will follow branches\nand repositories within the namespaces defined by the <archive/branch>\nparameters suppplied. If it cannot find the remote branch a merge comes from\nit will just import it as a regular commit. If it can find it, it will mark it \nas a merge whenever possible.\n\nSee man (1) git-archimport for more details.\n\n=head1 TODO\n\n - create tag objects instead of ref tags\n - audit shell-escaping of filenames\n - hide our private tags somewhere smarter\n - find a way to make \"cat *patches | patch\" safe even when patchfiles are missing newlines  \n - sort and apply patches by graphing ancestry relations instead of just\n   relying in dates supplied in the changeset itself.\n   tla ancestry-graph -m could be helpful here...\n\n=head1 Devel tricks\n\nAdd print in front of the shell commands invoked via backticks. \n\n=head1 Devel Notes\n\nThere are several places where Arch and git terminology are intermixed\nand potentially confused.\n\nThe notion of a \"branch\" in git is approximately equivalent to\na \"archive/category--branch--version\" in Arch.  Also, it should be noted\nthat the \"--branch\" portion of \"archive/category--branch--version\" is really\noptional in Arch although not many people (nor tools!) seem to know this.\nThis means that \"archive/category--version\" is also a valid \"branch\"\nin git terms.\n\nWe always refer to Arch names by their fully qualified variant (which\nmeans the \"archive\" name is prefixed.\n\nFor people unfamiliar with Arch, an \"archive\" is the term for \"repository\",\nand can contain multiple, unrelated branches.\n\n=cut\n\nuse strict;\nuse warnings;\nuse Getopt::Std;\nuse File::Temp qw(tempdir);\nuse File::Path qw(mkpath rmtree);\nuse File::Basename qw(basename dirname);\nuse Data::Dumper qw/ Dumper /;\nuse IPC::Open2;\n\n$SIG{'PIPE'}=\"IGNORE\";\n$ENV{'TZ'}=\"UTC\";\n\nmy $git_dir = $ENV{\"GIT_DIR\"} || \".git\";\n$ENV{\"GIT_DIR\"} = $git_dir;\nmy $ptag_dir = \"$git_dir/archimport/tags\";\n\nour($opt_h,$opt_f,$opt_v,$opt_T,$opt_t,$opt_D,$opt_a,$opt_o);\n\nsub usage() {\n    print STDERR <<END;\nUsage: ${\\basename $0}     # fetch/update GIT from Arch\n       [ -f ] [ -o ] [ -h ] [ -v ] [ -T ] [ -a ] [ -D depth  ] [ -t tempdir ]\n       repository/arch-branch [ repository/arch-branch] ...\nEND\n    exit(1);\n}\n\ngetopts(\"fThvat:D:\") or usage();\nusage if $opt_h;\n\n@ARGV >= 1 or usage();\n# $arch_branches:\n# values associated with keys:\n#   =1 - Arch version / git 'branch' detected via abrowse on a limit\n#   >1 - Arch version / git 'branch' of an auxilliary branch we've merged\nmy %arch_branches = map { $_ => 1 } @ARGV;\n\n$ENV{'TMPDIR'} = $opt_t if $opt_t; # $ENV{TMPDIR} will affect tempdir() calls:\nmy $tmp = tempdir('git-archimport-XXXXXX', TMPDIR => 1, CLEANUP => 1);\n$opt_v && print \"+ Using $tmp as temporary directory\\n\";\n\nmy %reachable = ();             # Arch repositories we can access\nmy %unreachable = ();           # Arch repositories we can't access :<\nmy @psets  = ();                # the collection\nmy %psets  = ();                # the collection, by name\nmy %stats  = (\t\t\t# Track which strategy we used to import:\n\tget_tag => 0, replay => 0, get_new => 0, get_delta => 0,\n        simple_changeset => 0, import_or_tag => 0\n);\n\nmy %rptags = ();                # my reverse private tags\n                                # to map a SHA1 to a commitid\nmy $TLA = $ENV{'ARCH_CLIENT'} || 'tla';\n\nsub do_abrowse {\n    my $stage = shift;\n    while (my ($limit, $level) = each %arch_branches) {\n        next unless $level == $stage;\n        \n\topen ABROWSE, \"$TLA abrowse -fkD --merges $limit |\" \n                                or die \"Problems with tla abrowse: $!\";\n    \n        my %ps        = ();         # the current one\n        my $lastseen  = '';\n    \n        while (<ABROWSE>) {\n            chomp;\n            \n            # first record padded w 8 spaces\n            if (s/^\\s{8}\\b//) {\n                my ($id, $type) = split(m/\\s+/, $_, 2);\n\n                my %last_ps;\n                # store the record we just captured\n                if (%ps && !exists $psets{ $ps{id} }) {\n                    %last_ps = %ps; # break references\n                    push (@psets, \\%last_ps);\n                    $psets{ $last_ps{id} } = \\%last_ps;\n                }\n                \n                my $branch = extract_versionname($id);\n                %ps = ( id => $id, branch => $branch );\n                if (%last_ps && ($last_ps{branch} eq $branch)) {\n                    $ps{parent_id} = $last_ps{id};\n                }\n                \n                $arch_branches{$branch} = 1;\n                $lastseen = 'id';\n\n                # deal with types (should work with baz or tla):\n                if ($type =~ m/\\(.*changeset\\)/) {\n                    $ps{type} = 's';\n                } elsif ($type =~ /\\(.*import\\)/) {\n                    $ps{type} = 'i';\n                } elsif ($type =~ m/\\(tag.*?(\\S+\\@\\S+).*?\\)/) {\n                    $ps{type} = 't';\n                    # read which revision we've tagged when we parse the log\n                    $ps{tag}  = $1;\n                } else { \n                    warn \"Unknown type $type\";\n                }\n\n                $arch_branches{$branch} = 1;\n                $lastseen = 'id';\n            } elsif (s/^\\s{10}//) { \n                # 10 leading spaces or more \n                # indicate commit metadata\n                \n                # date\n                if ($lastseen eq 'id' && m/^(\\d{4}-\\d\\d-\\d\\d \\d\\d:\\d\\d:\\d\\d)/){\n                    $ps{date}   = $1;\n                    $lastseen = 'date';\n                } elsif ($_ eq 'merges in:') {\n                    $ps{merges} = [];\n                    $lastseen = 'merges';\n                } elsif ($lastseen eq 'merges' && s/^\\s{2}//) {\n                    my $id = $_;\n                    push (@{$ps{merges}}, $id);\n                   \n                    # aggressive branch finding:\n                    if ($opt_D) {\n                        my $branch = extract_versionname($id);\n                        my $repo = extract_reponame($branch);\n                        \n                        if (archive_reachable($repo) &&\n                                !defined $arch_branches{$branch}) {\n                            $arch_branches{$branch} = $stage + 1;\n                        }\n                    }\n                } else {\n                    warn \"more metadata after merges!?: $_\\n\" unless /^\\s*$/;\n                }\n            }\n        }\n\n        if (%ps && !exists $psets{ $ps{id} }) {\n            my %temp = %ps;         # break references\n            if (@psets && $psets[$#psets]{branch} eq $ps{branch}) {\n                $temp{parent_id} = $psets[$#psets]{id};\n            }\n            push (@psets, \\%temp);  \n            $psets{ $temp{id} } = \\%temp;\n        }    \n        \n        close ABROWSE or die \"$TLA abrowse failed on $limit\\n\";\n    }\n}                               # end foreach $root\n\ndo_abrowse(1);\nmy $depth = 2;\n$opt_D ||= 0;\nwhile ($depth <= $opt_D) {\n    do_abrowse($depth);\n    $depth++;\n}\n\n## Order patches by time\n# FIXME see if we can find a more optimal way to do this by graphing\n# the ancestry data and walking it, that way we won't have to rely on\n# client-supplied dates\n@psets = sort {$a->{date}.$b->{id} cmp $b->{date}.$b->{id}} @psets;\n\n#print Dumper \\@psets;\n\n##\n## TODO cleanup irrelevant patches\n##      and put an initial import\n##      or a full tag\nmy $import = 0;\nunless (-d $git_dir) { # initial import\n    if ($psets[0]{type} eq 'i' || $psets[0]{type} eq 't') {\n        print \"Starting import from $psets[0]{id}\\n\";\n\t`git-init-db`;\n\tdie $! if $?;\n\t$import = 1;\n    } else {\n        die \"Need to start from an import or a tag -- cannot use $psets[0]{id}\";\n    }\n} else {    # progressing an import\n    # load the rptags\n    opendir(DIR, $ptag_dir)\n\t|| die \"can't opendir: $!\";\n    while (my $file = readdir(DIR)) {\n        # skip non-interesting-files\n        next unless -f \"$ptag_dir/$file\";\n   \n        # convert first '--' to '/' from old git-archimport to use\n        # as an archivename/c--b--v private tag\n        if ($file !~ m!,!) {\n            my $oldfile = $file;\n            $file =~ s!--!,!;\n            print STDERR \"converting old tag $oldfile to $file\\n\";\n            rename(\"$ptag_dir/$oldfile\", \"$ptag_dir/$file\") or die $!;\n        }\n\tmy $sha = ptag($file);\n\tchomp $sha;\n\t$rptags{$sha} = $file;\n    }\n    closedir DIR;\n}\n\n# process patchsets\n# extract the Arch repository name (Arch \"archive\" in Arch-speak)\nsub extract_reponame {\n    my $fq_cvbr = shift; # archivename/[[[[category]branch]version]revision]\n    return (split(/\\//, $fq_cvbr))[0];\n}\n \nsub extract_versionname {\n    my $name = shift;\n    $name =~ s/--(?:patch|version(?:fix)?|base)-\\d+$//;\n    return $name;\n}\n\n# convert a fully-qualified revision or version to a unique dirname:\n#   normalperson@yhbt.net-05/mpd--uclinux--1--patch-2 \n# becomes: normalperson@yhbt.net-05,mpd--uclinux--1\n#\n# the git notion of a branch is closer to\n# archive/category--branch--version than archive/category--branch, so we\n# use this to convert to git branch names.\n# Also, keep archive names but replace '/' with ',' since it won't require\n# subdirectories, and is safer than swapping '--' which could confuse\n# reverse-mapping when dealing with bastard branches that\n# are just archive/category--version  (no --branch)\nsub tree_dirname {\n    my $revision = shift;\n    my $name = extract_versionname($revision);\n    $name =~ s#/#,#;\n    return $name;\n}\n\n# old versions of git-archimport just use the <category--branch> part:\nsub old_style_branchname {\n    my $id = shift;\n    my $ret = safe_pipe_capture($TLA,'parse-package-name','-p',$id);\n    chomp $ret;\n    return $ret;\n}\n\n*git_branchname = $opt_o ? *old_style_branchname : *tree_dirname;\n\nsub process_patchset_accurate {\n    my $ps = shift;\n    \n    # switch to that branch if we're not already in that branch:\n    if (-e \"$git_dir/refs/heads/$ps->{branch}\") {\n       system('git-checkout','-f',$ps->{branch}) == 0 or die \"$! $?\\n\";\n\n       # remove any old stuff that got leftover:\n       my $rm = safe_pipe_capture('git-ls-files','--others','-z');\n       rmtree(split(/\\0/,$rm)) if $rm;\n    }\n    \n    # Apply the import/changeset/merge into the working tree\n    my $dir = sync_to_ps($ps);\n    # read the new log entry:\n    my @commitlog = safe_pipe_capture($TLA,'cat-log','-d',$dir,$ps->{id});\n    die \"Error in cat-log: $!\" if $?;\n    chomp @commitlog;\n\n    # grab variables we want from the log, new fields get added to $ps:\n    # (author, date, email, summary, message body ...)\n    parselog($ps, \\@commitlog);\n\n    if ($ps->{id} =~ /--base-0$/ && $ps->{id} ne $psets[0]{id}) {\n        # this should work when importing continuations \n        if ($ps->{tag} && (my $branchpoint = eval { ptag($ps->{tag}) })) {\n            \n            # find where we are supposed to branch from\n            system('git-checkout','-f','-b',$ps->{branch},\n                            $branchpoint) == 0 or die \"$! $?\\n\";\n            \n            # remove any old stuff that got leftover:\n            my $rm = safe_pipe_capture('git-ls-files','--others','-z');\n            rmtree(split(/\\0/,$rm)) if $rm;\n\n            # If we trust Arch with the fact that this is just \n            # a tag, and it does not affect the state of the tree\n            # then we just tag and move on\n            tag($ps->{id}, $branchpoint);\n            ptag($ps->{id}, $branchpoint);\n            print \" * Tagged $ps->{id} at $branchpoint\\n\";\n            return 0;\n        } else {\n            warn \"Tagging from unknown id unsupported\\n\" if $ps->{tag};\n        }\n        # allow multiple bases/imports here since Arch supports cherry-picks\n        # from unrelated trees\n    } \n    \n    # update the index with all the changes we got\n    system('git-ls-files --others -z | '.\n            'git-update-index --add -z --stdin') == 0 or die \"$! $?\\n\";\n    system('git-ls-files --deleted -z | '.\n            'git-update-index --remove -z --stdin') == 0 or die \"$! $?\\n\";\n    system('git-ls-files -z | '.\n             'git-update-index -z --stdin') == 0 or die \"$! $?\\n\";\n    return 1;\n}\n\n# the native changeset processing strategy.  This is very fast, but\n# does not handle permissions or any renames involving directories\nsub process_patchset_fast {\n    my $ps = shift;\n    # \n    # create the branch if needed\n    #\n    if ($ps->{type} eq 'i' && !$import) {\n        die \"Should not have more than one 'Initial import' per GIT import: $ps->{id}\";\n    }\n\n    unless ($import) { # skip for import\n        if ( -e \"$git_dir/refs/heads/$ps->{branch}\") {\n            # we know about this branch\n            system('git-checkout',$ps->{branch});\n        } else {\n            # new branch! we need to verify a few things\n            die \"Branch on a non-tag!\" unless $ps->{type} eq 't';\n            my $branchpoint = ptag($ps->{tag});\n            die \"Tagging from unknown id unsupported: $ps->{tag}\" \n                unless $branchpoint;\n            \n            # find where we are supposed to branch from\n            system('git-checkout','-b',$ps->{branch},$branchpoint);\n\n            # If we trust Arch with the fact that this is just \n            # a tag, and it does not affect the state of the tree\n            # then we just tag and move on\n            tag($ps->{id}, $branchpoint);\n            ptag($ps->{id}, $branchpoint);\n            print \" * Tagged $ps->{id} at $branchpoint\\n\";\n            return 0;\n        } \n        die $! if $?;\n    } \n\n    #\n    # Apply the import/changeset/merge into the working tree\n    # \n    if ($ps->{type} eq 'i' || $ps->{type} eq 't') {\n        apply_import($ps) or die $!;\n        $stats{import_or_tag}++;\n        $import=0;\n    } elsif ($ps->{type} eq 's') {\n        apply_cset($ps);\n        $stats{simple_changeset}++;\n    }\n\n    #\n    # prepare update git's index, based on what arch knows\n    # about the pset, resolve parents, etc\n    #\n    \n    my @commitlog = safe_pipe_capture($TLA,'cat-archive-log',$ps->{id}); \n    die \"Error in cat-archive-log: $!\" if $?;\n        \n    parselog($ps,\\@commitlog);\n\n    # imports don't give us good info\n    # on added files. Shame on them\n    if ($ps->{type} eq 'i' || $ps->{type} eq 't') {\n        system('git-ls-files --others -z | '.\n                'git-update-index --add -z --stdin') == 0 or die \"$! $?\\n\";\n        system('git-ls-files --deleted -z | '.\n                'git-update-index --remove -z --stdin') == 0 or die \"$! $?\\n\";\n    }\n\n    # TODO: handle removed_directories and renamed_directories:\n   \n    if (my $add = $ps->{new_files}) {\n        while (@$add) {\n            my @slice = splice(@$add, 0, 100);\n            system('git-update-index','--add','--',@slice) == 0 or\n                            die \"Error in git-update-index --add: $! $?\\n\";\n        }\n    }\n   \n    if (my $del = $ps->{removed_files}) {\n        unlink @$del;\n        while (@$del) {\n            my @slice = splice(@$del, 0, 100);\n            system('git-update-index','--remove','--',@slice) == 0 or\n                            die \"Error in git-update-index --remove: $! $?\\n\";\n        }\n    }\n\n    if (my $ren = $ps->{renamed_files}) {                # renamed\n        if (@$ren % 2) {\n            die \"Odd number of entries in rename!?\";\n        }\n        \n        while (@$ren) {\n            my $from = shift @$ren;\n            my $to   = shift @$ren;           \n\n            unless (-d dirname($to)) {\n                mkpath(dirname($to)); # will die on err\n            }\n            # print \"moving $from $to\";\n            rename($from, $to) or die \"Error renaming '$from' '$to': $!\\n\";\n            system('git-update-index','--remove','--',$from) == 0 or\n                            die \"Error in git-update-index --remove: $! $?\\n\";\n            system('git-update-index','--add','--',$to) == 0 or\n                            die \"Error in git-update-index --add: $! $?\\n\";\n        }\n    }\n\n    if (my $mod = $ps->{modified_files}) {\n        while (@$mod) {\n            my @slice = splice(@$mod, 0, 100);\n            system('git-update-index','--',@slice) == 0 or\n                            die \"Error in git-update-index: $! $?\\n\";\n        }\n    }\n    return 1; # we successfully applied the changeset\n}\n\nif ($opt_f) {\n    print \"Will import patchsets using the fast strategy\\n\",\n            \"Renamed directories and permission changes will be missed\\n\";\n    *process_patchset = *process_patchset_fast;\n} else {\n    print \"Using the default (accurate) import strategy.\\n\",\n            \"Things may be a bit slow\\n\";\n    *process_patchset = *process_patchset_accurate;\n}\n    \nforeach my $ps (@psets) {\n    # process patchsets\n    $ps->{branch} = git_branchname($ps->{id});\n\n    #\n    # ensure we have a clean state \n    # \n    if (my $dirty = `git-diff-files`) {\n        die \"Unclean tree when about to process $ps->{id} \" .\n            \" - did we fail to commit cleanly before?\\n$dirty\";\n    }\n    die $! if $?;\n    \n    #\n    # skip commits already in repo\n    #\n    if (ptag($ps->{id})) {\n      $opt_v && print \" * Skipping already imported: $ps->{id}\\n\";\n      return 0;\n    }\n\n    print \" * Starting to work on $ps->{id}\\n\";\n\n    process_patchset($ps) or next;\n\n    # warn \"errors when running git-update-index! $!\";\n    my $tree = `git-write-tree`;\n    die \"cannot write tree $!\" if $?;\n    chomp $tree;\n    \n    #\n    # Who's your daddy?\n    #\n    my @par;\n    if ( -e \"$git_dir/refs/heads/$ps->{branch}\") {\n        if (open HEAD, \"<\",\"$git_dir/refs/heads/$ps->{branch}\") {\n            my $p = <HEAD>;\n            close HEAD;\n            chomp $p;\n            push @par, '-p', $p;\n        } else { \n            if ($ps->{type} eq 's') {\n                warn \"Could not find the right head for the branch $ps->{branch}\";\n            }\n        }\n    }\n    \n    if ($ps->{merges}) {\n        push @par, find_parents($ps);\n    }\n\n    #    \n    # Commit, tag and clean state\n    #\n    $ENV{TZ}                  = 'GMT';\n    $ENV{GIT_AUTHOR_NAME}     = $ps->{author};\n    $ENV{GIT_AUTHOR_EMAIL}    = $ps->{email};\n    $ENV{GIT_AUTHOR_DATE}     = $ps->{date};\n    $ENV{GIT_COMMITTER_NAME}  = $ps->{author};\n    $ENV{GIT_COMMITTER_EMAIL} = $ps->{email};\n    $ENV{GIT_COMMITTER_DATE}  = $ps->{date};\n\n    my $pid = open2(*READER, *WRITER,'git-commit-tree',$tree,@par) \n        or die $!;\n    print WRITER $ps->{summary},\"\\n\";\n    print WRITER $ps->{message},\"\\n\";\n    \n    # make it easy to backtrack and figure out which Arch revision this was:\n    print WRITER 'git-archimport-id: ',$ps->{id},\"\\n\";\n    \n    close WRITER;\n    my $commitid = <READER>;    # read\n    chomp $commitid;\n    close READER;\n    waitpid $pid,0;             # close;\n\n    if (length $commitid != 40) {\n        die \"Something went wrong with the commit! $! $commitid\";\n    }\n    #\n    # Update the branch\n    # \n    open  HEAD, \">\",\"$git_dir/refs/heads/$ps->{branch}\";\n    print HEAD $commitid;\n    close HEAD;\n    system('git-update-ref', 'HEAD', \"$ps->{branch}\");\n\n    # tag accordingly\n    ptag($ps->{id}, $commitid); # private tag\n    if ($opt_T || $ps->{type} eq 't' || $ps->{type} eq 'i') {\n        tag($ps->{id}, $commitid);\n    }\n    print \" * Committed $ps->{id}\\n\";\n    print \"   + tree   $tree\\n\";\n    print \"   + commit $commitid\\n\";\n    $opt_v && print \"   + commit date is  $ps->{date} \\n\";\n    $opt_v && print \"   + parents:  \",join(' ',@par),\"\\n\";\n    if (my $dirty = `git-diff-files`) {\n        die \"22 Unclean tree when about to process $ps->{id} \" .\n            \" - did we fail to commit cleanly before?\\n$dirty\";\n    }\n}\n\nif ($opt_v) {\n    foreach (sort keys %stats) {\n        print\" $_: $stats{$_}\\n\";\n    }\n}\nexit 0;\n\n# used by the accurate strategy:\nsub sync_to_ps {\n    my $ps = shift;\n    my $tree_dir = $tmp.'/'.tree_dirname($ps->{id});\n    \n    $opt_v && print \"sync_to_ps($ps->{id}) method: \";\n\n    if (-d $tree_dir) {\n        if ($ps->{type} eq 't') {\n\t    $opt_v && print \"get (tag)\\n\";\n            # looks like a tag-only or (worse,) a mixed tags/changeset branch,\n            # can't rely on replay to work correctly on these\n            rmtree($tree_dir);\n            safe_pipe_capture($TLA,'get','--no-pristine',$ps->{id},$tree_dir);\n            $stats{get_tag}++;\n        } else {\n                my $tree_id = arch_tree_id($tree_dir);\n                if ($ps->{parent_id} && ($ps->{parent_id} eq $tree_id)) {\n                    # the common case (hopefully)\n\t\t    $opt_v && print \"replay\\n\";\n                    safe_pipe_capture($TLA,'replay','-d',$tree_dir,$ps->{id});\n                    $stats{replay}++;\n                } else {\n                    # getting one tree is usually faster than getting two trees\n                    # and applying the delta ...\n                    rmtree($tree_dir);\n\t\t    $opt_v && print \"apply-delta\\n\";\n                    safe_pipe_capture($TLA,'get','--no-pristine',\n                                        $ps->{id},$tree_dir);\n                    $stats{get_delta}++;\n                }\n        }\n    } else {\n        # new branch work\n        $opt_v && print \"get (new tree)\\n\";\n        safe_pipe_capture($TLA,'get','--no-pristine',$ps->{id},$tree_dir);\n        $stats{get_new}++;\n    }\n   \n    # added -I flag to rsync since we're going to fast! AIEEEEE!!!!\n    system('rsync','-aI','--delete','--exclude',$git_dir,\n#               '--exclude','.arch-inventory',\n                '--exclude','.arch-ids','--exclude','{arch}',\n                '--exclude','+*','--exclude',',*',\n                \"$tree_dir/\",'./') == 0 or die \"Cannot rsync $tree_dir: $! $?\";\n    return $tree_dir;\n}\n\nsub apply_import {\n    my $ps = shift;\n    my $bname = git_branchname($ps->{id});\n\n    mkpath($tmp);\n\n    safe_pipe_capture($TLA,'get','-s','--no-pristine',$ps->{id},\"$tmp/import\");\n    die \"Cannot get import: $!\" if $?;    \n    system('rsync','-aI','--delete', '--exclude',$git_dir,\n\t\t'--exclude','.arch-ids','--exclude','{arch}',\n\t\t\"$tmp/import/\", './');\n    die \"Cannot rsync import:$!\" if $?;\n    \n    rmtree(\"$tmp/import\");\n    die \"Cannot remove tempdir: $!\" if $?;\n    \n\n    return 1;\n}\n\nsub apply_cset {\n    my $ps = shift;\n\n    mkpath($tmp);\n\n    # get the changeset\n    safe_pipe_capture($TLA,'get-changeset',$ps->{id},\"$tmp/changeset\");\n    die \"Cannot get changeset: $!\" if $?;\n    \n    # apply patches\n    if (`find $tmp/changeset/patches -type f -name '*.patch'`) {\n        # this can be sped up considerably by doing\n        #    (find | xargs cat) | patch\n        # but that cna get mucked up by patches\n        # with missing trailing newlines or the standard \n        # 'missing newline' flag in the patch - possibly\n        # produced with an old/buggy diff.\n        # slow and safe, we invoke patch once per patchfile\n        `find $tmp/changeset/patches -type f -name '*.patch' -print0 | grep -zv '{arch}' | xargs -iFILE -0 --no-run-if-empty patch -p1 --forward -iFILE`;\n        die \"Problem applying patches! $!\" if $?;\n    }\n\n    # apply changed binary files\n    if (my @modified = `find $tmp/changeset/patches -type f -name '*.modified'`) {\n        foreach my $mod (@modified) {\n            chomp $mod;\n            my $orig = $mod;\n            $orig =~ s/\\.modified$//; # lazy\n            $orig =~ s!^\\Q$tmp\\E/changeset/patches/!!;\n            #print \"rsync -p '$mod' '$orig'\";\n            system('rsync','-p',$mod,\"./$orig\");\n            die \"Problem applying binary changes! $!\" if $?;\n        }\n    }\n\n    # bring in new files\n    system('rsync','-aI','--exclude',$git_dir,\n    \t\t'--exclude','.arch-ids',\n\t\t'--exclude', '{arch}',\n\t\t\"$tmp/changeset/new-files-archive/\",'./');\n\n    # deleted files are hinted from the commitlog processing\n\n    rmtree(\"$tmp/changeset\");\n}\n\n\n# =for reference\n# notes: *-files/-directories keys cannot have spaces, they're always\n# pika-escaped.  Everything after the first newline\n# A log entry looks like:\n# Revision: moodle-org--moodle--1.3.3--patch-15\n# Archive: arch-eduforge@catalyst.net.nz--2004\n# Creator: Penny Leach <penny@catalyst.net.nz>\n# Date: Wed May 25 14:15:34 NZST 2005\n# Standard-date: 2005-05-25 02:15:34 GMT\n# New-files: lang/de/.arch-ids/block_glossary_random.php.id\n#     lang/de/.arch-ids/block_html.php.id\n# New-directories: lang/de/help/questionnaire\n#     lang/de/help/questionnaire/.arch-ids\n# Renamed-files: .arch-ids/db_sears.sql.id db/.arch-ids/db_sears.sql.id\n#    db_sears.sql db/db_sears.sql\n# Removed-files: lang/be/docs/.arch-ids/release.html.id\n#     lang/be/docs/.arch-ids/releaseold.html.id\n# Modified-files: admin/cron.php admin/delete.php\n#     admin/editor.html backup/lib.php backup/restore.php\n# New-patches: arch-eduforge@catalyst.net.nz--2004/moodle-org--moodle--1.3.3--patch-15\n# Summary: Updating to latest from MOODLE_14_STABLE (1.4.5+)\n#   summary can be multiline with a leading space just like the above fields\n# Keywords:\n#\n# Updating yadda tadda tadda madda\nsub parselog {\n    my ($ps, $log) = @_;\n    my $key = undef;\n\n    # headers we want that contain filenames:\n    my %want_headers = (\n        new_files => 1,\n        modified_files => 1,\n        renamed_files => 1,\n        renamed_directories => 1,\n        removed_files => 1,\n        removed_directories => 1,\n    );\n    \n    chomp (@$log);\n    while ($_ = shift @$log) {\n        if (/^Continuation-of:\\s*(.*)/) {\n            $ps->{tag} = $1;\n            $key = undef;\n        } elsif (/^Summary:\\s*(.*)$/ ) {\n            # summary can be multiline as long as it has a leading space\n            $ps->{summary} = [ $1 ];\n            $key = 'summary';\n        } elsif (/^Creator: (.*)\\s*<([^\\>]+)>/) {\n            $ps->{author} = $1;\n            $ps->{email} = $2;\n            $key = undef;\n        # any *-files or *-directories can be read here:\n        } elsif (/^([A-Z][a-z\\-]+):\\s*(.*)$/) {\n            my $val = $2;\n            $key = lc $1;\n            $key =~ tr/-/_/; # too lazy to quote :P\n            if ($want_headers{$key}) {\n                push @{$ps->{$key}}, split(/\\s+/, $val);\n            } else {\n                $key = undef;\n            }\n        } elsif (/^$/) {\n            last; # remainder of @$log that didn't get shifted off is message\n        } elsif ($key) {\n            if (/^\\s+(.*)$/) {\n                if ($key eq 'summary') {\n                    push @{$ps->{$key}}, $1;\n                } else { # files/directories:\n                    push @{$ps->{$key}}, split(/\\s+/, $1);\n                }\n            } else {\n                $key = undef;\n            }\n        }\n    }\n   \n    # post-processing:\n    $ps->{summary} = join(\"\\n\",@{$ps->{summary}}).\"\\n\";\n    $ps->{message} = join(\"\\n\",@$log);\n    \n    # skip Arch control files, unescape pika-escaped files\n    foreach my $k (keys %want_headers) {\n        next unless (defined $ps->{$k});\n        my @tmp = ();\n        foreach my $t (@{$ps->{$k}}) {\n           next unless length ($t);\n           next if $t =~ m!\\{arch\\}/!;\n           next if $t =~ m!\\.arch-ids/!;\n           # should we skip this?\n           next if $t =~ m!\\.arch-inventory$!;\n           # tla cat-archive-log will give us filenames with spaces as file\\(sp)name - why?\n           # we can assume that any filename with \\ indicates some pika escaping that we want to get rid of.\n           if ($t =~ /\\\\/ ){\n               $t = (safe_pipe_capture($TLA,'escape','--unescaped',$t))[0];\n           }\n           push @tmp, $t;\n        }\n        $ps->{$k} = \\@tmp;\n    }\n}\n\n# write/read a tag\nsub tag {\n    my ($tag, $commit) = @_;\n \n    if ($opt_o) {\n        $tag =~ s|/|--|g;\n    } else {\n        # don't use subdirs for tags yet, it could screw up other porcelains\n        $tag =~ s|/|,|g;\n    }\n    \n    if ($commit) {\n        open(C,\">\",\"$git_dir/refs/tags/$tag\")\n            or die \"Cannot create tag $tag: $!\\n\";\n        print C \"$commit\\n\"\n            or die \"Cannot write tag $tag: $!\\n\";\n        close(C)\n            or die \"Cannot write tag $tag: $!\\n\";\n        print \" * Created tag '$tag' on '$commit'\\n\" if $opt_v;\n    } else {                    # read\n        open(C,\"<\",\"$git_dir/refs/tags/$tag\")\n            or die \"Cannot read tag $tag: $!\\n\";\n        $commit = <C>;\n        chomp $commit;\n        die \"Error reading tag $tag: $!\\n\" unless length $commit == 40;\n        close(C)\n            or die \"Cannot read tag $tag: $!\\n\";\n        return $commit;\n    }\n}\n\n# write/read a private tag\n# reads fail softly if the tag isn't there\nsub ptag {\n    my ($tag, $commit) = @_;\n\n    # don't use subdirs for tags yet, it could screw up other porcelains\n    $tag =~ s|/|,|g; \n    \n    my $tag_file = \"$ptag_dir/$tag\";\n    my $tag_branch_dir = dirname($tag_file);\n    mkpath($tag_branch_dir) unless (-d $tag_branch_dir);\n\n    if ($commit) {              # write\n        open(C,\">\",$tag_file)\n            or die \"Cannot create tag $tag: $!\\n\";\n        print C \"$commit\\n\"\n            or die \"Cannot write tag $tag: $!\\n\";\n        close(C)\n            or die \"Cannot write tag $tag: $!\\n\";\n\t$rptags{$commit} = $tag \n\t    unless $tag =~ m/--base-0$/;\n    } else {                    # read\n        # if the tag isn't there, return 0\n        unless ( -s $tag_file) {\n            return 0;\n        }\n        open(C,\"<\",$tag_file)\n            or die \"Cannot read tag $tag: $!\\n\";\n        $commit = <C>;\n        chomp $commit;\n        die \"Error reading tag $tag: $!\\n\" unless length $commit == 40;\n        close(C)\n            or die \"Cannot read tag $tag: $!\\n\";\n\tunless (defined $rptags{$commit}) {\n\t    $rptags{$commit} = $tag;\n\t}\n        return $commit;\n    }\n}\n\nsub find_parents {\n    #\n    # Identify what branches are merging into me\n    # and whether we are fully merged\n    # git-merge-base <headsha> <headsha> should tell\n    # me what the base of the merge should be \n    #\n    my $ps = shift;\n\n    my %branches; # holds an arrayref per branch\n                  # the arrayref contains a list of\n                  # merged patches between the base\n                  # of the merge and the current head\n\n    my @parents;  # parents found for this commit\n\n    # simple loop to split the merges\n    # per branch\n    foreach my $merge (@{$ps->{merges}}) {\n\tmy $branch = git_branchname($merge);\n\tunless (defined $branches{$branch} ){\n\t    $branches{$branch} = [];\n\t}\n\tpush @{$branches{$branch}}, $merge;\n    }\n\n    #\n    # foreach branch find a merge base and walk it to the \n    # head where we are, collecting the merged patchsets that\n    # Arch has recorded. Keep that in @have\n    # Compare that with the commits on the other branch\n    # between merge-base and the tip of the branch (@need)\n    # and see if we have a series of consecutive patches\n    # starting from the merge base. The tip of the series\n    # of consecutive patches merged is our new parent for \n    # that branch.\n    #\n    foreach my $branch (keys %branches) {\n\n\t# check that we actually know about the branch\n\tnext unless -e \"$git_dir/refs/heads/$branch\";\n\n\tmy $mergebase = `git-merge-base $branch $ps->{branch}`;\n \tif ($?) { \n \t    # Don't die here, Arch supports one-way cherry-picking\n \t    # between branches with no common base (or any relationship\n \t    # at all beforehand)\n \t    warn \"Cannot find merge base for $branch and $ps->{branch}\";\n \t    next;\n \t}\n\tchomp $mergebase;\n\n\t# now walk up to the mergepoint collecting what patches we have\n\tmy $branchtip = git_rev_parse($ps->{branch});\n\tmy @ancestors = `git-rev-list --merge-order $branchtip ^$mergebase`;\n\tmy %have; # collected merges this branch has\n\tforeach my $merge (@{$ps->{merges}}) {\n\t    $have{$merge} = 1;\n\t}\n\tmy %ancestorshave;\n\tforeach my $par (@ancestors) {\n\t    $par = commitid2pset($par);\n\t    if (defined $par->{merges}) {\n\t\tforeach my $merge (@{$par->{merges}}) {\n\t\t    $ancestorshave{$merge}=1;\n\t\t}\n\t    }\n\t}\n\t# print \"++++ Merges in $ps->{id} are....\\n\";\n\t# my @have = sort keys %have;\tprint Dumper(\\@have);\n\n\t# merge what we have with what ancestors have\n\t%have = (%have, %ancestorshave);\n\n\t# see what the remote branch has - these are the merges we \n\t# will want to have in a consecutive series from the mergebase\n\tmy $otherbranchtip = git_rev_parse($branch);\n\tmy @needraw = `git-rev-list --merge-order $otherbranchtip ^$mergebase`;\n\tmy @need;\n\tforeach my $needps (@needraw) { \t# get the psets\n\t    $needps = commitid2pset($needps);\n\t    # git-rev-list will also\n\t    # list commits merged in via earlier \n\t    # merges. we are only interested in commits\n\t    # from the branch we're looking at\n\t    if ($branch eq $needps->{branch}) {\n\t\tpush @need, $needps->{id};\n\t    }\n\t}\n\n\t# print \"++++ Merges from $branch we want are....\\n\";\n\t# print Dumper(\\@need);\n\n\tmy $newparent;\n\twhile (my $needed_commit = pop @need) {\n\t    if ($have{$needed_commit}) {\n\t\t$newparent = $needed_commit;\n\t    } else {\n\t\tlast; # break out of the while\n\t    }\n\t}\n\tif ($newparent) {\n\t    push @parents, $newparent;\n\t}\n\n\n    } # end foreach branch\n\n    # prune redundant parents\n    my %parents;\n    foreach my $p (@parents) {\n\t$parents{$p} = 1;\n    }\n    foreach my $p (@parents) {\n\tnext unless exists $psets{$p}{merges};\n\tnext unless ref    $psets{$p}{merges};\n\tmy @merges = @{$psets{$p}{merges}};\n\tforeach my $merge (@merges) {\n\t    if ($parents{$merge}) { \n\t\tdelete $parents{$merge};\n\t    }\n\t}\n    }\n\n    @parents = ();\n    foreach (keys %parents) {\n        push @parents, '-p', ptag($_);\n    }\n    return @parents;\n}\n\nsub git_rev_parse {\n    my $name = shift;\n    my $val  = `git-rev-parse $name`;\n    die \"Error: git-rev-parse $name\" if $?;\n    chomp $val;\n    return $val;\n}\n\n# resolve a SHA1 to a known patchset\nsub commitid2pset {\n    my $commitid = shift;\n    chomp $commitid;\n    my $name = $rptags{$commitid} \n\t|| die \"Cannot find reverse tag mapping for $commitid\";\n    $name =~ s|,|/|;\n    my $ps   = $psets{$name} \n\t|| (print Dumper(sort keys %psets)) && die \"Cannot find patchset for $name\";\n    return $ps;\n}\n\n\n# an alterative to `command` that allows input to be passed as an array\n# to work around shell problems with weird characters in arguments\nsub safe_pipe_capture {\n    my @output;\n    if (my $pid = open my $child, '-|') {\n        @output = (<$child>);\n        close $child or die join(' ',@_).\": $! $?\";\n    } else {\n\texec(@_) or die \"$! $?\"; # exec() can fail the executable can't be found\n    }\n    return wantarray ? @output : join('',@output);\n}\n\n# `tla logs -rf -d <dir> | head -n1` or `baz tree-id <dir>`\nsub arch_tree_id {\n    my $dir = shift;\n    chomp( my $ret = (safe_pipe_capture($TLA,'logs','-rf','-d',$dir))[0] );\n    return $ret;\n}\n\nsub archive_reachable {\n    my $archive = shift;\n    return 1 if $reachable{$archive};\n    return 0 if $unreachable{$archive};\n    \n    if (system \"$TLA whereis-archive $archive >/dev/null\") {\n        if ($opt_a && (system($TLA,'register-archive',\n                      \"http://mirrors.sourcecontrol.net/$archive\") == 0)) {\n            $reachable{$archive} = 1;\n            return 1;\n        }\n        print STDERR \"Archive is unreachable: $archive\\n\";\n        $unreachable{$archive} = 1;\n        return 0;\n    } else {\n        $reachable{$archive} = 1;\n        return 1;\n    }\n}\n\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00808500165068247826895c063aebce8e9901f7",
  "sha1_ok": true,
  "size": 35314
}
