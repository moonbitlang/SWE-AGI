{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImRpci5oIgojaW5jbHVkZSAiZ2l0LWNvbXBhdC11dGlsLmgiCiNpbmNsdWRlICJsb2NrZmlsZS5oIgojaW5jbHVkZSAicGFjay5oIgojaW5jbHVkZSAicGFja2ZpbGUuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAib2JqZWN0LmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAic2hhMS1sb29rdXAuaCIKI2luY2x1ZGUgImNvbW1pdC1ncmFwaC5oIgojaW5jbHVkZSAib2JqZWN0LXN0b3JlLmgiCiNpbmNsdWRlICJhbGxvYy5oIgoKI2RlZmluZSBHUkFQSF9TSUdOQVRVUkUgMHg0MzQ3NTA0OCAvKiAiQ0dQSCIgKi8KI2RlZmluZSBHUkFQSF9DSFVOS0lEX09JREZBTk9VVCAweDRmNDk0NDQ2IC8qICJPSURGIiAqLwojZGVmaW5lIEdSQVBIX0NIVU5LSURfT0lETE9PS1VQIDB4NGY0OTQ0NGMgLyogIk9JREwiICovCiNkZWZpbmUgR1JBUEhfQ0hVTktJRF9EQVRBIDB4NDM0NDQxNTQgLyogIkNEQVQiICovCiNkZWZpbmUgR1JBUEhfQ0hVTktJRF9MQVJHRUVER0VTIDB4NDU0NDQ3NDUgLyogIkVER0UiICovCgojZGVmaW5lIEdSQVBIX0RBVEFfV0lEVEggMzYKCiNkZWZpbmUgR1JBUEhfVkVSU0lPTl8xIDB4MQojZGVmaW5lIEdSQVBIX1ZFUlNJT04gR1JBUEhfVkVSU0lPTl8xCgojZGVmaW5lIEdSQVBIX09JRF9WRVJTSU9OX1NIQTEgMQojZGVmaW5lIEdSQVBIX09JRF9MRU5fU0hBMSBHSVRfU0hBMV9SQVdTWgojZGVmaW5lIEdSQVBIX09JRF9WRVJTSU9OIEdSQVBIX09JRF9WRVJTSU9OX1NIQTEKI2RlZmluZSBHUkFQSF9PSURfTEVOIEdSQVBIX09JRF9MRU5fU0hBMQoKI2RlZmluZSBHUkFQSF9PQ1RPUFVTX0VER0VTX05FRURFRCAweDgwMDAwMDAwCiNkZWZpbmUgR1JBUEhfUEFSRU5UX01JU1NJTkcgMHg3ZmZmZmZmZgojZGVmaW5lIEdSQVBIX0VER0VfTEFTVF9NQVNLIDB4N2ZmZmZmZmYKI2RlZmluZSBHUkFQSF9QQVJFTlRfTk9ORSAweDcwMDAwMDAwCgojZGVmaW5lIEdSQVBIX0xBU1RfRURHRSAweDgwMDAwMDAwCgojZGVmaW5lIEdSQVBIX0hFQURFUl9TSVpFIDgKI2RlZmluZSBHUkFQSF9GQU5PVVRfU0laRSAoNCAqIDI1NikKI2RlZmluZSBHUkFQSF9DSFVOS0xPT0tVUF9XSURUSCAxMgojZGVmaW5lIEdSQVBIX01JTl9TSVpFIChHUkFQSF9IRUFERVJfU0laRSArIDQgKiBHUkFQSF9DSFVOS0xPT0tVUF9XSURUSCBcCgkJCSsgR1JBUEhfRkFOT1VUX1NJWkUgKyBHUkFQSF9PSURfTEVOKQoKY2hhciAqZ2V0X2NvbW1pdF9ncmFwaF9maWxlbmFtZShjb25zdCBjaGFyICpvYmpfZGlyKQp7CglyZXR1cm4geHN0cmZtdCgiJXMvaW5mby9jb21taXQtZ3JhcGgiLCBvYmpfZGlyKTsKfQoKc3RhdGljIHN0cnVjdCBjb21taXRfZ3JhcGggKmFsbG9jX2NvbW1pdF9ncmFwaCh2b2lkKQp7CglzdHJ1Y3QgY29tbWl0X2dyYXBoICpnID0geGNhbGxvYygxLCBzaXplb2YoKmcpKTsKCWctPmdyYXBoX2ZkID0gLTE7CgoJcmV0dXJuIGc7Cn0KCnN0cnVjdCBjb21taXRfZ3JhcGggKmxvYWRfY29tbWl0X2dyYXBoX29uZShjb25zdCBjaGFyICpncmFwaF9maWxlKQp7Cgl2b2lkICpncmFwaF9tYXA7Cgljb25zdCB1bnNpZ25lZCBjaGFyICpkYXRhLCAqY2h1bmtfbG9va3VwOwoJc2l6ZV90IGdyYXBoX3NpemU7CglzdHJ1Y3Qgc3RhdCBzdDsKCXVpbnQzMl90IGk7CglzdHJ1Y3QgY29tbWl0X2dyYXBoICpncmFwaDsKCWludCBmZCA9IGdpdF9vcGVuKGdyYXBoX2ZpbGUpOwoJdWludDY0X3QgbGFzdF9jaHVua19vZmZzZXQ7Cgl1aW50MzJfdCBsYXN0X2NodW5rX2lkOwoJdWludDMyX3QgZ3JhcGhfc2lnbmF0dXJlOwoJdW5zaWduZWQgY2hhciBncmFwaF92ZXJzaW9uLCBoYXNoX3ZlcnNpb247CgoJaWYgKGZkIDwgMCkKCQlyZXR1cm4gTlVMTDsKCWlmIChmc3RhdChmZCwgJnN0KSkgewoJCWNsb3NlKGZkKTsKCQlyZXR1cm4gTlVMTDsKCX0KCWdyYXBoX3NpemUgPSB4c2l6ZV90KHN0LnN0X3NpemUpOwoKCWlmIChncmFwaF9zaXplIDwgR1JBUEhfTUlOX1NJWkUpIHsKCQljbG9zZShmZCk7CgkJZGllKF8oImdyYXBoIGZpbGUgJXMgaXMgdG9vIHNtYWxsIiksIGdyYXBoX2ZpbGUpOwoJfQoJZ3JhcGhfbWFwID0geG1tYXAoTlVMTCwgZ3JhcGhfc2l6ZSwgUFJPVF9SRUFELCBNQVBfUFJJVkFURSwgZmQsIDApOwoJZGF0YSA9IChjb25zdCB1bnNpZ25lZCBjaGFyICopZ3JhcGhfbWFwOwoKCWdyYXBoX3NpZ25hdHVyZSA9IGdldF9iZTMyKGRhdGEpOwoJaWYgKGdyYXBoX3NpZ25hdHVyZSAhPSBHUkFQSF9TSUdOQVRVUkUpIHsKCQllcnJvcihfKCJncmFwaCBzaWduYXR1cmUgJVggZG9lcyBub3QgbWF0Y2ggc2lnbmF0dXJlICVYIiksCgkJICAgICAgZ3JhcGhfc2lnbmF0dXJlLCBHUkFQSF9TSUdOQVRVUkUpOwoJCWdvdG8gY2xlYW51cF9mYWlsOwoJfQoKCWdyYXBoX3ZlcnNpb24gPSAqKHVuc2lnbmVkIGNoYXIqKShkYXRhICsgNCk7CglpZiAoZ3JhcGhfdmVyc2lvbiAhPSBHUkFQSF9WRVJTSU9OKSB7CgkJZXJyb3IoXygiZ3JhcGggdmVyc2lvbiAlWCBkb2VzIG5vdCBtYXRjaCB2ZXJzaW9uICVYIiksCgkJICAgICAgZ3JhcGhfdmVyc2lvbiwgR1JBUEhfVkVSU0lPTik7CgkJZ290byBjbGVhbnVwX2ZhaWw7Cgl9CgoJaGFzaF92ZXJzaW9uID0gKih1bnNpZ25lZCBjaGFyKikoZGF0YSArIDUpOwoJaWYgKGhhc2hfdmVyc2lvbiAhPSBHUkFQSF9PSURfVkVSU0lPTikgewoJCWVycm9yKF8oImhhc2ggdmVyc2lvbiAlWCBkb2VzIG5vdCBtYXRjaCB2ZXJzaW9uICVYIiksCgkJICAgICAgaGFzaF92ZXJzaW9uLCBHUkFQSF9PSURfVkVSU0lPTik7CgkJZ290byBjbGVhbnVwX2ZhaWw7Cgl9CgoJZ3JhcGggPSBhbGxvY19jb21taXRfZ3JhcGgoKTsKCglncmFwaC0+aGFzaF9sZW4gPSBHUkFQSF9PSURfTEVOOwoJZ3JhcGgtPm51bV9jaHVua3MgPSAqKHVuc2lnbmVkIGNoYXIqKShkYXRhICsgNik7CglncmFwaC0+Z3JhcGhfZmQgPSBmZDsKCWdyYXBoLT5kYXRhID0gZ3JhcGhfbWFwOwoJZ3JhcGgtPmRhdGFfbGVuID0gZ3JhcGhfc2l6ZTsKCglsYXN0X2NodW5rX2lkID0gMDsKCWxhc3RfY2h1bmtfb2Zmc2V0ID0gODsKCWNodW5rX2xvb2t1cCA9IGRhdGEgKyA4OwoJZm9yIChpID0gMDsgaSA8IGdyYXBoLT5udW1fY2h1bmtzOyBpKyspIHsKCQl1aW50MzJfdCBjaHVua19pZCA9IGdldF9iZTMyKGNodW5rX2xvb2t1cCArIDApOwoJCXVpbnQ2NF90IGNodW5rX29mZnNldCA9IGdldF9iZTY0KGNodW5rX2xvb2t1cCArIDQpOwoJCWludCBjaHVua19yZXBlYXRlZCA9IDA7CgoJCWNodW5rX2xvb2t1cCArPSBHUkFQSF9DSFVOS0xPT0tVUF9XSURUSDsKCgkJaWYgKGNodW5rX29mZnNldCA+IGdyYXBoX3NpemUgLSBHSVRfTUFYX1JBV1NaKSB7CgkJCWVycm9yKF8oImltcHJvcGVyIGNodW5rIG9mZnNldCAlMDh4JTA4eCIpLCAodWludDMyX3QpKGNodW5rX29mZnNldCA+PiAzMiksCgkJCSAgICAgICh1aW50MzJfdCljaHVua19vZmZzZXQpOwoJCQlnb3RvIGNsZWFudXBfZmFpbDsKCQl9CgoJCXN3aXRjaCAoY2h1bmtfaWQpIHsKCQljYXNlIEdSQVBIX0NIVU5LSURfT0lERkFOT1VUOgoJCQlpZiAoZ3JhcGgtPmNodW5rX29pZF9mYW5vdXQpCgkJCQljaHVua19yZXBlYXRlZCA9IDE7CgkJCWVsc2UKCQkJCWdyYXBoLT5jaHVua19vaWRfZmFub3V0ID0gKHVpbnQzMl90KikoZGF0YSArIGNodW5rX29mZnNldCk7CgkJCWJyZWFrOwoKCQljYXNlIEdSQVBIX0NIVU5LSURfT0lETE9PS1VQOgoJCQlpZiAoZ3JhcGgtPmNodW5rX29pZF9sb29rdXApCgkJCQljaHVua19yZXBlYXRlZCA9IDE7CgkJCWVsc2UKCQkJCWdyYXBoLT5jaHVua19vaWRfbG9va3VwID0gZGF0YSArIGNodW5rX29mZnNldDsKCQkJYnJlYWs7CgoJCWNhc2UgR1JBUEhfQ0hVTktJRF9EQVRBOgoJCQlpZiAoZ3JhcGgtPmNodW5rX2NvbW1pdF9kYXRhKQoJCQkJY2h1bmtfcmVwZWF0ZWQgPSAxOwoJCQllbHNlCgkJCQlncmFwaC0+Y2h1bmtfY29tbWl0X2RhdGEgPSBkYXRhICsgY2h1bmtfb2Zmc2V0OwoJCQlicmVhazsKCgkJY2FzZSBHUkFQSF9DSFVOS0lEX0xBUkdFRURHRVM6CgkJCWlmIChncmFwaC0+Y2h1bmtfbGFyZ2VfZWRnZXMpCgkJCQljaHVua19yZXBlYXRlZCA9IDE7CgkJCWVsc2UKCQkJCWdyYXBoLT5jaHVua19sYXJnZV9lZGdlcyA9IGRhdGEgKyBjaHVua19vZmZzZXQ7CgkJCWJyZWFrOwoJCX0KCgkJaWYgKGNodW5rX3JlcGVhdGVkKSB7CgkJCWVycm9yKF8oImNodW5rIGlkICUwOHggYXBwZWFycyBtdWx0aXBsZSB0aW1lcyIpLCBjaHVua19pZCk7CgkJCWdvdG8gY2xlYW51cF9mYWlsOwoJCX0KCgkJaWYgKGxhc3RfY2h1bmtfaWQgPT0gR1JBUEhfQ0hVTktJRF9PSURMT09LVVApCgkJewoJCQlncmFwaC0+bnVtX2NvbW1pdHMgPSAoY2h1bmtfb2Zmc2V0IC0gbGFzdF9jaHVua19vZmZzZXQpCgkJCQkJICAgICAvIGdyYXBoLT5oYXNoX2xlbjsKCQl9CgoJCWxhc3RfY2h1bmtfaWQgPSBjaHVua19pZDsKCQlsYXN0X2NodW5rX29mZnNldCA9IGNodW5rX29mZnNldDsKCX0KCglyZXR1cm4gZ3JhcGg7CgpjbGVhbnVwX2ZhaWw6CgltdW5tYXAoZ3JhcGhfbWFwLCBncmFwaF9zaXplKTsKCWNsb3NlKGZkKTsKCWV4aXQoMSk7Cn0KCnN0YXRpYyB2b2lkIHByZXBhcmVfY29tbWl0X2dyYXBoX29uZShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgY29uc3QgY2hhciAqb2JqX2RpcikKewoJY2hhciAqZ3JhcGhfbmFtZTsKCglpZiAoci0+b2JqZWN0cy0+Y29tbWl0X2dyYXBoKQoJCXJldHVybjsKCglncmFwaF9uYW1lID0gZ2V0X2NvbW1pdF9ncmFwaF9maWxlbmFtZShvYmpfZGlyKTsKCXItPm9iamVjdHMtPmNvbW1pdF9ncmFwaCA9CgkJbG9hZF9jb21taXRfZ3JhcGhfb25lKGdyYXBoX25hbWUpOwoKCUZSRUVfQU5EX05VTEwoZ3JhcGhfbmFtZSk7Cn0KCi8qCiAqIFJldHVybiAxIGlmIGNvbW1pdF9ncmFwaCBpcyBub24tTlVMTCwgYW5kIDAgb3RoZXJ3aXNlLgogKgogKiBPbiB0aGUgZmlyc3QgaW52b2NhdGlvbiwgdGhpcyBmdW5jdGlvbiBhdHRlbXBzIHRvIGxvYWQgdGhlIGNvbW1pdAogKiBncmFwaCBpZiB0aGVfcmVwb3NpdG9yeSBpcyBjb25maWd1cmVkIHRvIGhhdmUgb25lLgogKi8Kc3RhdGljIGludCBwcmVwYXJlX2NvbW1pdF9ncmFwaChzdHJ1Y3QgcmVwb3NpdG9yeSAqcikKewoJc3RydWN0IGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UgKmFsdDsKCWNoYXIgKm9ial9kaXI7CglpbnQgY29uZmlnX3ZhbHVlOwoKCWlmIChyLT5vYmplY3RzLT5jb21taXRfZ3JhcGhfYXR0ZW1wdGVkKQoJCXJldHVybiAhIXItPm9iamVjdHMtPmNvbW1pdF9ncmFwaDsKCXItPm9iamVjdHMtPmNvbW1pdF9ncmFwaF9hdHRlbXB0ZWQgPSAxOwoKCWlmIChyZXBvX2NvbmZpZ19nZXRfYm9vbChyLCAiY29yZS5jb21taXRncmFwaCIsICZjb25maWdfdmFsdWUpIHx8CgkgICAgIWNvbmZpZ192YWx1ZSkKCQkvKgoJCSAqIFRoaXMgcmVwb3NpdG9yeSBpcyBub3QgY29uZmlndXJlZCB0byB1c2UgY29tbWl0IGdyYXBocywgc28KCQkgKiBkbyBub3QgbG9hZCBvbmUuIChCdXQgcmVwb3J0IGNvbW1pdF9ncmFwaF9hdHRlbXB0ZWQgYW55d2F5CgkJICogc28gdGhhdCBjb21taXQgZ3JhcGggbG9hZGluZyBpcyBub3QgYXR0ZW1wdGVkIGFnYWluIGZvciB0aGlzCgkJICogcmVwb3NpdG9yeS4pCgkJICovCgkJcmV0dXJuIDA7CgoJb2JqX2RpciA9IHItPm9iamVjdHMtPm9iamVjdGRpcjsKCXByZXBhcmVfY29tbWl0X2dyYXBoX29uZShyLCBvYmpfZGlyKTsKCXByZXBhcmVfYWx0X29kYihyKTsKCWZvciAoYWx0ID0gci0+b2JqZWN0cy0+YWx0X29kYl9saXN0OwoJICAgICAhci0+b2JqZWN0cy0+Y29tbWl0X2dyYXBoICYmIGFsdDsKCSAgICAgYWx0ID0gYWx0LT5uZXh0KQoJCXByZXBhcmVfY29tbWl0X2dyYXBoX29uZShyLCBhbHQtPnBhdGgpOwoJcmV0dXJuICEhci0+b2JqZWN0cy0+Y29tbWl0X2dyYXBoOwp9CgpzdGF0aWMgdm9pZCBjbG9zZV9jb21taXRfZ3JhcGgodm9pZCkKewoJZnJlZV9jb21taXRfZ3JhcGgodGhlX3JlcG9zaXRvcnktPm9iamVjdHMtPmNvbW1pdF9ncmFwaCk7Cgl0aGVfcmVwb3NpdG9yeS0+b2JqZWN0cy0+Y29tbWl0X2dyYXBoID0gTlVMTDsKfQoKc3RhdGljIGludCBic2VhcmNoX2dyYXBoKHN0cnVjdCBjb21taXRfZ3JhcGggKmcsIHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgdWludDMyX3QgKnBvcykKewoJcmV0dXJuIGJzZWFyY2hfaGFzaChvaWQtPmhhc2gsIGctPmNodW5rX29pZF9mYW5vdXQsCgkJCSAgICBnLT5jaHVua19vaWRfbG9va3VwLCBnLT5oYXNoX2xlbiwgcG9zKTsKfQoKc3RhdGljIHN0cnVjdCBjb21taXRfbGlzdCAqKmluc2VydF9wYXJlbnRfb3JfZGllKHN0cnVjdCBjb21taXRfZ3JhcGggKmcsCgkJCQkJCSB1aW50NjRfdCBwb3MsCgkJCQkJCSBzdHJ1Y3QgY29tbWl0X2xpc3QgKipwcHRyKQp7CglzdHJ1Y3QgY29tbWl0ICpjOwoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CgoJaWYgKHBvcyA+PSBnLT5udW1fY29tbWl0cykKCQlkaWUoImludmFsaWQgcGFyZW50IHBvc2l0aW9uICUiUFJJdTY0LCBwb3MpOwoKCWhhc2hjcHkob2lkLmhhc2gsIGctPmNodW5rX29pZF9sb29rdXAgKyBnLT5oYXNoX2xlbiAqIHBvcyk7CgljID0gbG9va3VwX2NvbW1pdCh0aGVfcmVwb3NpdG9yeSwgJm9pZCk7CglpZiAoIWMpCgkJZGllKF8oImNvdWxkIG5vdCBmaW5kIGNvbW1pdCAlcyIpLCBvaWRfdG9faGV4KCZvaWQpKTsKCWMtPmdyYXBoX3BvcyA9IHBvczsKCXJldHVybiAmY29tbWl0X2xpc3RfaW5zZXJ0KGMsIHBwdHIpLT5uZXh0Owp9CgpzdGF0aWMgdm9pZCBmaWxsX2NvbW1pdF9ncmFwaF9pbmZvKHN0cnVjdCBjb21taXQgKml0ZW0sIHN0cnVjdCBjb21taXRfZ3JhcGggKmcsIHVpbnQzMl90IHBvcykKewoJY29uc3QgdW5zaWduZWQgY2hhciAqY29tbWl0X2RhdGEgPSBnLT5jaHVua19jb21taXRfZGF0YSArIEdSQVBIX0RBVEFfV0lEVEggKiBwb3M7CglpdGVtLT5ncmFwaF9wb3MgPSBwb3M7CglpdGVtLT5nZW5lcmF0aW9uID0gZ2V0X2JlMzIoY29tbWl0X2RhdGEgKyBnLT5oYXNoX2xlbiArIDgpID4+IDI7Cn0KCnN0YXRpYyBpbnQgZmlsbF9jb21taXRfaW5fZ3JhcGgoc3RydWN0IGNvbW1pdCAqaXRlbSwgc3RydWN0IGNvbW1pdF9ncmFwaCAqZywgdWludDMyX3QgcG9zKQp7Cgl1aW50MzJfdCBlZGdlX3ZhbHVlOwoJdWludDMyX3QgKnBhcmVudF9kYXRhX3B0cjsKCXVpbnQ2NF90IGRhdGVfbG93LCBkYXRlX2hpZ2g7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKipwcHRyOwoJY29uc3QgdW5zaWduZWQgY2hhciAqY29tbWl0X2RhdGEgPSBnLT5jaHVua19jb21taXRfZGF0YSArIChnLT5oYXNoX2xlbiArIDE2KSAqIHBvczsKCglpdGVtLT5vYmplY3QucGFyc2VkID0gMTsKCWl0ZW0tPmdyYXBoX3BvcyA9IHBvczsKCglpdGVtLT5tYXliZV90cmVlID0gTlVMTDsKCglkYXRlX2hpZ2ggPSBnZXRfYmUzMihjb21taXRfZGF0YSArIGctPmhhc2hfbGVuICsgOCkgJiAweDM7CglkYXRlX2xvdyA9IGdldF9iZTMyKGNvbW1pdF9kYXRhICsgZy0+aGFzaF9sZW4gKyAxMik7CglpdGVtLT5kYXRlID0gKHRpbWVzdGFtcF90KSgoZGF0ZV9oaWdoIDw8IDMyKSB8IGRhdGVfbG93KTsKCglpdGVtLT5nZW5lcmF0aW9uID0gZ2V0X2JlMzIoY29tbWl0X2RhdGEgKyBnLT5oYXNoX2xlbiArIDgpID4+IDI7CgoJcHB0ciA9ICZpdGVtLT5wYXJlbnRzOwoKCWVkZ2VfdmFsdWUgPSBnZXRfYmUzMihjb21taXRfZGF0YSArIGctPmhhc2hfbGVuKTsKCWlmIChlZGdlX3ZhbHVlID09IEdSQVBIX1BBUkVOVF9OT05FKQoJCXJldHVybiAxOwoJcHB0ciA9IGluc2VydF9wYXJlbnRfb3JfZGllKGcsIGVkZ2VfdmFsdWUsIHBwdHIpOwoKCWVkZ2VfdmFsdWUgPSBnZXRfYmUzMihjb21taXRfZGF0YSArIGctPmhhc2hfbGVuICsgNCk7CglpZiAoZWRnZV92YWx1ZSA9PSBHUkFQSF9QQVJFTlRfTk9ORSkKCQlyZXR1cm4gMTsKCWlmICghKGVkZ2VfdmFsdWUgJiBHUkFQSF9PQ1RPUFVTX0VER0VTX05FRURFRCkpIHsKCQlwcHRyID0gaW5zZXJ0X3BhcmVudF9vcl9kaWUoZywgZWRnZV92YWx1ZSwgcHB0cik7CgkJcmV0dXJuIDE7Cgl9CgoJcGFyZW50X2RhdGFfcHRyID0gKHVpbnQzMl90KikoZy0+Y2h1bmtfbGFyZ2VfZWRnZXMgKwoJCQkgIDQgKiAodWludDY0X3QpKGVkZ2VfdmFsdWUgJiBHUkFQSF9FREdFX0xBU1RfTUFTSykpOwoJZG8gewoJCWVkZ2VfdmFsdWUgPSBnZXRfYmUzMihwYXJlbnRfZGF0YV9wdHIpOwoJCXBwdHIgPSBpbnNlcnRfcGFyZW50X29yX2RpZShnLAoJCQkJCSAgICBlZGdlX3ZhbHVlICYgR1JBUEhfRURHRV9MQVNUX01BU0ssCgkJCQkJICAgIHBwdHIpOwoJCXBhcmVudF9kYXRhX3B0cisrOwoJfSB3aGlsZSAoIShlZGdlX3ZhbHVlICYgR1JBUEhfTEFTVF9FREdFKSk7CgoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBpbnQgZmluZF9jb21taXRfaW5fZ3JhcGgoc3RydWN0IGNvbW1pdCAqaXRlbSwgc3RydWN0IGNvbW1pdF9ncmFwaCAqZywgdWludDMyX3QgKnBvcykKewoJaWYgKGl0ZW0tPmdyYXBoX3BvcyAhPSBDT01NSVRfTk9UX0ZST01fR1JBUEgpIHsKCQkqcG9zID0gaXRlbS0+Z3JhcGhfcG9zOwoJCXJldHVybiAxOwoJfSBlbHNlIHsKCQlyZXR1cm4gYnNlYXJjaF9ncmFwaChnLCAmKGl0ZW0tPm9iamVjdC5vaWQpLCBwb3MpOwoJfQp9CgpzdGF0aWMgaW50IHBhcnNlX2NvbW1pdF9pbl9ncmFwaF9vbmUoc3RydWN0IGNvbW1pdF9ncmFwaCAqZywgc3RydWN0IGNvbW1pdCAqaXRlbSkKewoJdWludDMyX3QgcG9zOwoKCWlmIChpdGVtLT5vYmplY3QucGFyc2VkKQoJCXJldHVybiAxOwoKCWlmIChmaW5kX2NvbW1pdF9pbl9ncmFwaChpdGVtLCBnLCAmcG9zKSkKCQlyZXR1cm4gZmlsbF9jb21taXRfaW5fZ3JhcGgoaXRlbSwgZywgcG9zKTsKCglyZXR1cm4gMDsKfQoKaW50IHBhcnNlX2NvbW1pdF9pbl9ncmFwaChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgc3RydWN0IGNvbW1pdCAqaXRlbSkKewoJaWYgKCFwcmVwYXJlX2NvbW1pdF9ncmFwaChyKSkKCQlyZXR1cm4gMDsKCXJldHVybiBwYXJzZV9jb21taXRfaW5fZ3JhcGhfb25lKHItPm9iamVjdHMtPmNvbW1pdF9ncmFwaCwgaXRlbSk7Cn0KCnZvaWQgbG9hZF9jb21taXRfZ3JhcGhfaW5mbyhzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgc3RydWN0IGNvbW1pdCAqaXRlbSkKewoJdWludDMyX3QgcG9zOwoJaWYgKCFwcmVwYXJlX2NvbW1pdF9ncmFwaChyKSkKCQlyZXR1cm47CglpZiAoZmluZF9jb21taXRfaW5fZ3JhcGgoaXRlbSwgci0+b2JqZWN0cy0+Y29tbWl0X2dyYXBoLCAmcG9zKSkKCQlmaWxsX2NvbW1pdF9ncmFwaF9pbmZvKGl0ZW0sIHItPm9iamVjdHMtPmNvbW1pdF9ncmFwaCwgcG9zKTsKfQoKc3RhdGljIHN0cnVjdCB0cmVlICpsb2FkX3RyZWVfZm9yX2NvbW1pdChzdHJ1Y3QgY29tbWl0X2dyYXBoICpnLCBzdHJ1Y3QgY29tbWl0ICpjKQp7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCWNvbnN0IHVuc2lnbmVkIGNoYXIgKmNvbW1pdF9kYXRhID0gZy0+Y2h1bmtfY29tbWl0X2RhdGEgKwoJCQkJCSAgIEdSQVBIX0RBVEFfV0lEVEggKiAoYy0+Z3JhcGhfcG9zKTsKCgloYXNoY3B5KG9pZC5oYXNoLCBjb21taXRfZGF0YSk7CgljLT5tYXliZV90cmVlID0gbG9va3VwX3RyZWUodGhlX3JlcG9zaXRvcnksICZvaWQpOwoKCXJldHVybiBjLT5tYXliZV90cmVlOwp9CgpzdGF0aWMgc3RydWN0IHRyZWUgKmdldF9jb21taXRfdHJlZV9pbl9ncmFwaF9vbmUoc3RydWN0IGNvbW1pdF9ncmFwaCAqZywKCQkJCQkJIGNvbnN0IHN0cnVjdCBjb21taXQgKmMpCnsKCWlmIChjLT5tYXliZV90cmVlKQoJCXJldHVybiBjLT5tYXliZV90cmVlOwoJaWYgKGMtPmdyYXBoX3BvcyA9PSBDT01NSVRfTk9UX0ZST01fR1JBUEgpCgkJQlVHKCJnZXRfY29tbWl0X3RyZWVfaW5fZ3JhcGhfb25lIGNhbGxlZCBmcm9tIG5vbi1jb21taXQtZ3JhcGggY29tbWl0Iik7CgoJcmV0dXJuIGxvYWRfdHJlZV9mb3JfY29tbWl0KGcsIChzdHJ1Y3QgY29tbWl0ICopYyk7Cn0KCnN0cnVjdCB0cmVlICpnZXRfY29tbWl0X3RyZWVfaW5fZ3JhcGgoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IHN0cnVjdCBjb21taXQgKmMpCnsKCXJldHVybiBnZXRfY29tbWl0X3RyZWVfaW5fZ3JhcGhfb25lKHItPm9iamVjdHMtPmNvbW1pdF9ncmFwaCwgYyk7Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX2dyYXBoX2NodW5rX2Zhbm91dChzdHJ1Y3QgaGFzaGZpbGUgKmYsCgkJCQkgICAgIHN0cnVjdCBjb21taXQgKipjb21taXRzLAoJCQkJICAgICBpbnQgbnJfY29tbWl0cykKewoJaW50IGksIGNvdW50ID0gMDsKCXN0cnVjdCBjb21taXQgKipsaXN0ID0gY29tbWl0czsKCgkvKgoJICogV3JpdGUgdGhlIGZpcnN0LWxldmVsIHRhYmxlICh0aGUgbGlzdCBpcyBzb3J0ZWQsCgkgKiBidXQgd2UgdXNlIGEgMjU2LWVudHJ5IGxvb2t1cCB0byBiZSBhYmxlIHRvIGF2b2lkCgkgKiBoYXZpbmcgdG8gZG8gZWlnaHQgZXh0cmEgYmluYXJ5IHNlYXJjaCBpdGVyYXRpb25zKS4KCSAqLwoJZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7CgkJd2hpbGUgKGNvdW50IDwgbnJfY29tbWl0cykgewoJCQlpZiAoKCpsaXN0KS0+b2JqZWN0Lm9pZC5oYXNoWzBdICE9IGkpCgkJCQlicmVhazsKCQkJY291bnQrKzsKCQkJbGlzdCsrOwoJCX0KCgkJaGFzaHdyaXRlX2JlMzIoZiwgY291bnQpOwoJfQp9CgpzdGF0aWMgdm9pZCB3cml0ZV9ncmFwaF9jaHVua19vaWRzKHN0cnVjdCBoYXNoZmlsZSAqZiwgaW50IGhhc2hfbGVuLAoJCQkJICAgc3RydWN0IGNvbW1pdCAqKmNvbW1pdHMsIGludCBucl9jb21taXRzKQp7CglzdHJ1Y3QgY29tbWl0ICoqbGlzdCA9IGNvbW1pdHM7CglpbnQgY291bnQ7Cglmb3IgKGNvdW50ID0gMDsgY291bnQgPCBucl9jb21taXRzOyBjb3VudCsrLCBsaXN0KyspCgkJaGFzaHdyaXRlKGYsICgqbGlzdCktPm9iamVjdC5vaWQuaGFzaCwgKGludCloYXNoX2xlbik7Cn0KCnN0YXRpYyBjb25zdCB1bnNpZ25lZCBjaGFyICpjb21taXRfdG9fc2hhMShzaXplX3QgaW5kZXgsIHZvaWQgKnRhYmxlKQp7CglzdHJ1Y3QgY29tbWl0ICoqY29tbWl0cyA9IHRhYmxlOwoJcmV0dXJuIGNvbW1pdHNbaW5kZXhdLT5vYmplY3Qub2lkLmhhc2g7Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX2dyYXBoX2NodW5rX2RhdGEoc3RydWN0IGhhc2hmaWxlICpmLCBpbnQgaGFzaF9sZW4sCgkJCQkgICBzdHJ1Y3QgY29tbWl0ICoqY29tbWl0cywgaW50IG5yX2NvbW1pdHMpCnsKCXN0cnVjdCBjb21taXQgKipsaXN0ID0gY29tbWl0czsKCXN0cnVjdCBjb21taXQgKipsYXN0ID0gY29tbWl0cyArIG5yX2NvbW1pdHM7Cgl1aW50MzJfdCBudW1fZXh0cmFfZWRnZXMgPSAwOwoKCXdoaWxlIChsaXN0IDwgbGFzdCkgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50OwoJCWludCBlZGdlX3ZhbHVlOwoJCXVpbnQzMl90IHBhY2tlZERhdGVbMl07CgoJCXBhcnNlX2NvbW1pdCgqbGlzdCk7CgkJaGFzaHdyaXRlKGYsIGdldF9jb21taXRfdHJlZV9vaWQoKmxpc3QpLT5oYXNoLCBoYXNoX2xlbik7CgoJCXBhcmVudCA9ICgqbGlzdCktPnBhcmVudHM7CgoJCWlmICghcGFyZW50KQoJCQllZGdlX3ZhbHVlID0gR1JBUEhfUEFSRU5UX05PTkU7CgkJZWxzZSB7CgkJCWVkZ2VfdmFsdWUgPSBzaGExX3BvcyhwYXJlbnQtPml0ZW0tPm9iamVjdC5vaWQuaGFzaCwKCQkJCQkgICAgICBjb21taXRzLAoJCQkJCSAgICAgIG5yX2NvbW1pdHMsCgkJCQkJICAgICAgY29tbWl0X3RvX3NoYTEpOwoKCQkJaWYgKGVkZ2VfdmFsdWUgPCAwKQoJCQkJZWRnZV92YWx1ZSA9IEdSQVBIX1BBUkVOVF9NSVNTSU5HOwoJCX0KCgkJaGFzaHdyaXRlX2JlMzIoZiwgZWRnZV92YWx1ZSk7CgoJCWlmIChwYXJlbnQpCgkJCXBhcmVudCA9IHBhcmVudC0+bmV4dDsKCgkJaWYgKCFwYXJlbnQpCgkJCWVkZ2VfdmFsdWUgPSBHUkFQSF9QQVJFTlRfTk9ORTsKCQllbHNlIGlmIChwYXJlbnQtPm5leHQpCgkJCWVkZ2VfdmFsdWUgPSBHUkFQSF9PQ1RPUFVTX0VER0VTX05FRURFRCB8IG51bV9leHRyYV9lZGdlczsKCQllbHNlIHsKCQkJZWRnZV92YWx1ZSA9IHNoYTFfcG9zKHBhcmVudC0+aXRlbS0+b2JqZWN0Lm9pZC5oYXNoLAoJCQkJCSAgICAgIGNvbW1pdHMsCgkJCQkJICAgICAgbnJfY29tbWl0cywKCQkJCQkgICAgICBjb21taXRfdG9fc2hhMSk7CgkJCWlmIChlZGdlX3ZhbHVlIDwgMCkKCQkJCWVkZ2VfdmFsdWUgPSBHUkFQSF9QQVJFTlRfTUlTU0lORzsKCQl9CgoJCWhhc2h3cml0ZV9iZTMyKGYsIGVkZ2VfdmFsdWUpOwoKCQlpZiAoZWRnZV92YWx1ZSAmIEdSQVBIX09DVE9QVVNfRURHRVNfTkVFREVEKSB7CgkJCWRvIHsKCQkJCW51bV9leHRyYV9lZGdlcysrOwoJCQkJcGFyZW50ID0gcGFyZW50LT5uZXh0OwoJCQl9IHdoaWxlIChwYXJlbnQpOwoJCX0KCgkJaWYgKHNpemVvZigoKmxpc3QpLT5kYXRlKSA+IDQpCgkJCXBhY2tlZERhdGVbMF0gPSBodG9ubCgoKCpsaXN0KS0+ZGF0ZSA+PiAzMikgJiAweDMpOwoJCWVsc2UKCQkJcGFja2VkRGF0ZVswXSA9IDA7CgoJCXBhY2tlZERhdGVbMF0gfD0gaHRvbmwoKCpsaXN0KS0+Z2VuZXJhdGlvbiA8PCAyKTsKCgkJcGFja2VkRGF0ZVsxXSA9IGh0b25sKCgqbGlzdCktPmRhdGUpOwoJCWhhc2h3cml0ZShmLCBwYWNrZWREYXRlLCA4KTsKCgkJbGlzdCsrOwoJfQp9CgpzdGF0aWMgdm9pZCB3cml0ZV9ncmFwaF9jaHVua19sYXJnZV9lZGdlcyhzdHJ1Y3QgaGFzaGZpbGUgKmYsCgkJCQkJICBzdHJ1Y3QgY29tbWl0ICoqY29tbWl0cywKCQkJCQkgIGludCBucl9jb21taXRzKQp7CglzdHJ1Y3QgY29tbWl0ICoqbGlzdCA9IGNvbW1pdHM7CglzdHJ1Y3QgY29tbWl0ICoqbGFzdCA9IGNvbW1pdHMgKyBucl9jb21taXRzOwoJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnQ7CgoJd2hpbGUgKGxpc3QgPCBsYXN0KSB7CgkJaW50IG51bV9wYXJlbnRzID0gMDsKCQlmb3IgKHBhcmVudCA9ICgqbGlzdCktPnBhcmVudHM7IG51bV9wYXJlbnRzIDwgMyAmJiBwYXJlbnQ7CgkJICAgICBwYXJlbnQgPSBwYXJlbnQtPm5leHQpCgkJCW51bV9wYXJlbnRzKys7CgoJCWlmIChudW1fcGFyZW50cyA8PSAyKSB7CgkJCWxpc3QrKzsKCQkJY29udGludWU7CgkJfQoKCQkvKiBTaW5jZSBudW1fcGFyZW50cyA+IDIsIHRoaXMgaW5pdGlhbGl6ZXIgaXMgc2FmZS4gKi8KCQlmb3IgKHBhcmVudCA9ICgqbGlzdCktPnBhcmVudHMtPm5leHQ7IHBhcmVudDsgcGFyZW50ID0gcGFyZW50LT5uZXh0KSB7CgkJCWludCBlZGdlX3ZhbHVlID0gc2hhMV9wb3MocGFyZW50LT5pdGVtLT5vYmplY3Qub2lkLmhhc2gsCgkJCQkJCSAgY29tbWl0cywKCQkJCQkJICBucl9jb21taXRzLAoJCQkJCQkgIGNvbW1pdF90b19zaGExKTsKCgkJCWlmIChlZGdlX3ZhbHVlIDwgMCkKCQkJCWVkZ2VfdmFsdWUgPSBHUkFQSF9QQVJFTlRfTUlTU0lORzsKCQkJZWxzZSBpZiAoIXBhcmVudC0+bmV4dCkKCQkJCWVkZ2VfdmFsdWUgfD0gR1JBUEhfTEFTVF9FREdFOwoKCQkJaGFzaHdyaXRlX2JlMzIoZiwgZWRnZV92YWx1ZSk7CgkJfQoKCQlsaXN0Kys7Cgl9Cn0KCnN0YXRpYyBpbnQgY29tbWl0X2NvbXBhcmUoY29uc3Qgdm9pZCAqX2EsIGNvbnN0IHZvaWQgKl9iKQp7Cgljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICphID0gKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKilfYTsKCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKmIgPSAoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqKV9iOwoJcmV0dXJuIG9pZGNtcChhLCBiKTsKfQoKc3RydWN0IHBhY2tlZF9jb21taXRfbGlzdCB7CglzdHJ1Y3QgY29tbWl0ICoqbGlzdDsKCWludCBucjsKCWludCBhbGxvYzsKfTsKCnN0cnVjdCBwYWNrZWRfb2lkX2xpc3QgewoJc3RydWN0IG9iamVjdF9pZCAqbGlzdDsKCWludCBucjsKCWludCBhbGxvYzsKfTsKCnN0YXRpYyBpbnQgYWRkX3BhY2tlZF9jb21taXRzKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJICAgICAgc3RydWN0IHBhY2tlZF9naXQgKnBhY2ssCgkJCSAgICAgIHVpbnQzMl90IHBvcywKCQkJICAgICAgdm9pZCAqZGF0YSkKewoJc3RydWN0IHBhY2tlZF9vaWRfbGlzdCAqbGlzdCA9IChzdHJ1Y3QgcGFja2VkX29pZF9saXN0KilkYXRhOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJb2ZmX3Qgb2Zmc2V0ID0gbnRoX3BhY2tlZF9vYmplY3Rfb2Zmc2V0KHBhY2ssIHBvcyk7CglzdHJ1Y3Qgb2JqZWN0X2luZm8gb2kgPSBPQkpFQ1RfSU5GT19JTklUOwoKCW9pLnR5cGVwID0gJnR5cGU7CglpZiAocGFja2VkX29iamVjdF9pbmZvKHRoZV9yZXBvc2l0b3J5LCBwYWNrLCBvZmZzZXQsICZvaSkgPCAwKQoJCWRpZShfKCJ1bmFibGUgdG8gZ2V0IHR5cGUgb2Ygb2JqZWN0ICVzIiksIG9pZF90b19oZXgob2lkKSk7CgoJaWYgKHR5cGUgIT0gT0JKX0NPTU1JVCkKCQlyZXR1cm4gMDsKCglBTExPQ19HUk9XKGxpc3QtPmxpc3QsIGxpc3QtPm5yICsgMSwgbGlzdC0+YWxsb2MpOwoJb2lkY3B5KCYobGlzdC0+bGlzdFtsaXN0LT5ucl0pLCBvaWQpOwoJbGlzdC0+bnIrKzsKCglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgYWRkX21pc3NpbmdfcGFyZW50cyhzdHJ1Y3QgcGFja2VkX29pZF9saXN0ICpvaWRzLCBzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50OwoJZm9yIChwYXJlbnQgPSBjb21taXQtPnBhcmVudHM7IHBhcmVudDsgcGFyZW50ID0gcGFyZW50LT5uZXh0KSB7CgkJaWYgKCEocGFyZW50LT5pdGVtLT5vYmplY3QuZmxhZ3MgJiBVTklOVEVSRVNUSU5HKSkgewoJCQlBTExPQ19HUk9XKG9pZHMtPmxpc3QsIG9pZHMtPm5yICsgMSwgb2lkcy0+YWxsb2MpOwoJCQlvaWRjcHkoJm9pZHMtPmxpc3Rbb2lkcy0+bnJdLCAmKHBhcmVudC0+aXRlbS0+b2JqZWN0Lm9pZCkpOwoJCQlvaWRzLT5ucisrOwoJCQlwYXJlbnQtPml0ZW0tPm9iamVjdC5mbGFncyB8PSBVTklOVEVSRVNUSU5HOwoJCX0KCX0KfQoKc3RhdGljIHZvaWQgY2xvc2VfcmVhY2hhYmxlKHN0cnVjdCBwYWNrZWRfb2lkX2xpc3QgKm9pZHMpCnsKCWludCBpOwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoKCWZvciAoaSA9IDA7IGkgPCBvaWRzLT5ucjsgaSsrKSB7CgkJY29tbWl0ID0gbG9va3VwX2NvbW1pdCh0aGVfcmVwb3NpdG9yeSwgJm9pZHMtPmxpc3RbaV0pOwoJCWlmIChjb21taXQpCgkJCWNvbW1pdC0+b2JqZWN0LmZsYWdzIHw9IFVOSU5URVJFU1RJTkc7Cgl9CgoJLyoKCSAqIEFzIHRoaXMgbG9vcCBydW5zLCBvaWRzLT5uciBtYXkgZ3JvdywgYnV0IG5vdCBtb3JlCgkgKiB0aGFuIHRoZSBudW1iZXIgb2YgbWlzc2luZyBjb21taXRzIGluIHRoZSByZWFjaGFibGUKCSAqIGNsb3N1cmUuCgkgKi8KCWZvciAoaSA9IDA7IGkgPCBvaWRzLT5ucjsgaSsrKSB7CgkJY29tbWl0ID0gbG9va3VwX2NvbW1pdCh0aGVfcmVwb3NpdG9yeSwgJm9pZHMtPmxpc3RbaV0pOwoKCQlpZiAoY29tbWl0ICYmICFwYXJzZV9jb21taXQoY29tbWl0KSkKCQkJYWRkX21pc3NpbmdfcGFyZW50cyhvaWRzLCBjb21taXQpOwoJfQoKCWZvciAoaSA9IDA7IGkgPCBvaWRzLT5ucjsgaSsrKSB7CgkJY29tbWl0ID0gbG9va3VwX2NvbW1pdCh0aGVfcmVwb3NpdG9yeSwgJm9pZHMtPmxpc3RbaV0pOwoKCQlpZiAoY29tbWl0KQoJCQljb21taXQtPm9iamVjdC5mbGFncyAmPSB+VU5JTlRFUkVTVElORzsKCX0KfQoKc3RhdGljIHZvaWQgY29tcHV0ZV9nZW5lcmF0aW9uX251bWJlcnMoc3RydWN0IHBhY2tlZF9jb21taXRfbGlzdCogY29tbWl0cykKewoJaW50IGk7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QgPSBOVUxMOwoKCWZvciAoaSA9IDA7IGkgPCBjb21taXRzLT5ucjsgaSsrKSB7CgkJaWYgKGNvbW1pdHMtPmxpc3RbaV0tPmdlbmVyYXRpb24gIT0gR0VORVJBVElPTl9OVU1CRVJfSU5GSU5JVFkgJiYKCQkgICAgY29tbWl0cy0+bGlzdFtpXS0+Z2VuZXJhdGlvbiAhPSBHRU5FUkFUSU9OX05VTUJFUl9aRVJPKQoJCQljb250aW51ZTsKCgkJY29tbWl0X2xpc3RfaW5zZXJ0KGNvbW1pdHMtPmxpc3RbaV0sICZsaXN0KTsKCQl3aGlsZSAobGlzdCkgewoJCQlzdHJ1Y3QgY29tbWl0ICpjdXJyZW50ID0gbGlzdC0+aXRlbTsKCQkJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnQ7CgkJCWludCBhbGxfcGFyZW50c19jb21wdXRlZCA9IDE7CgkJCXVpbnQzMl90IG1heF9nZW5lcmF0aW9uID0gMDsKCgkJCWZvciAocGFyZW50ID0gY3VycmVudC0+cGFyZW50czsgcGFyZW50OyBwYXJlbnQgPSBwYXJlbnQtPm5leHQpIHsKCQkJCWlmIChwYXJlbnQtPml0ZW0tPmdlbmVyYXRpb24gPT0gR0VORVJBVElPTl9OVU1CRVJfSU5GSU5JVFkgfHwKCQkJCSAgICBwYXJlbnQtPml0ZW0tPmdlbmVyYXRpb24gPT0gR0VORVJBVElPTl9OVU1CRVJfWkVSTykgewoJCQkJCWFsbF9wYXJlbnRzX2NvbXB1dGVkID0gMDsKCQkJCQljb21taXRfbGlzdF9pbnNlcnQocGFyZW50LT5pdGVtLCAmbGlzdCk7CgkJCQkJYnJlYWs7CgkJCQl9IGVsc2UgaWYgKHBhcmVudC0+aXRlbS0+Z2VuZXJhdGlvbiA+IG1heF9nZW5lcmF0aW9uKSB7CgkJCQkJbWF4X2dlbmVyYXRpb24gPSBwYXJlbnQtPml0ZW0tPmdlbmVyYXRpb247CgkJCQl9CgkJCX0KCgkJCWlmIChhbGxfcGFyZW50c19jb21wdXRlZCkgewoJCQkJY3VycmVudC0+Z2VuZXJhdGlvbiA9IG1heF9nZW5lcmF0aW9uICsgMTsKCQkJCXBvcF9jb21taXQoJmxpc3QpOwoKCQkJCWlmIChjdXJyZW50LT5nZW5lcmF0aW9uID4gR0VORVJBVElPTl9OVU1CRVJfTUFYKQoJCQkJCWN1cnJlbnQtPmdlbmVyYXRpb24gPSBHRU5FUkFUSU9OX05VTUJFUl9NQVg7CgkJCX0KCQl9Cgl9Cn0KCnN0YXRpYyBpbnQgYWRkX3JlZl90b19saXN0KGNvbnN0IGNoYXIgKnJlZm5hbWUsCgkJCSAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJICAgaW50IGZsYWdzLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QgPSAoc3RydWN0IHN0cmluZ19saXN0ICopY2JfZGF0YTsKCglzdHJpbmdfbGlzdF9hcHBlbmQobGlzdCwgb2lkX3RvX2hleChvaWQpKTsKCXJldHVybiAwOwp9Cgp2b2lkIHdyaXRlX2NvbW1pdF9ncmFwaF9yZWFjaGFibGUoY29uc3QgY2hhciAqb2JqX2RpciwgaW50IGFwcGVuZCkKewoJc3RydWN0IHN0cmluZ19saXN0IGxpc3Q7CgoJc3RyaW5nX2xpc3RfaW5pdCgmbGlzdCwgMSk7Cglmb3JfZWFjaF9yZWYoYWRkX3JlZl90b19saXN0LCAmbGlzdCk7Cgl3cml0ZV9jb21taXRfZ3JhcGgob2JqX2RpciwgTlVMTCwgJmxpc3QsIGFwcGVuZCk7Cn0KCnZvaWQgd3JpdGVfY29tbWl0X2dyYXBoKGNvbnN0IGNoYXIgKm9ial9kaXIsCgkJCXN0cnVjdCBzdHJpbmdfbGlzdCAqcGFja19pbmRleGVzLAoJCQlzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmNvbW1pdF9oZXgsCgkJCWludCBhcHBlbmQpCnsKCXN0cnVjdCBwYWNrZWRfb2lkX2xpc3Qgb2lkczsKCXN0cnVjdCBwYWNrZWRfY29tbWl0X2xpc3QgY29tbWl0czsKCXN0cnVjdCBoYXNoZmlsZSAqZjsKCXVpbnQzMl90IGksIGNvdW50X2Rpc3RpbmN0ID0gMDsKCWNoYXIgKmdyYXBoX25hbWU7CglzdHJ1Y3QgbG9ja19maWxlIGxrID0gTE9DS19JTklUOwoJdWludDMyX3QgY2h1bmtfaWRzWzVdOwoJdWludDY0X3QgY2h1bmtfb2Zmc2V0c1s1XTsKCWludCBudW1fY2h1bmtzOwoJaW50IG51bV9leHRyYV9lZGdlczsKCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50OwoKCW9pZHMubnIgPSAwOwoJb2lkcy5hbGxvYyA9IGFwcHJveGltYXRlX29iamVjdF9jb3VudCgpIC8gNDsKCglpZiAoYXBwZW5kKSB7CgkJcHJlcGFyZV9jb21taXRfZ3JhcGhfb25lKHRoZV9yZXBvc2l0b3J5LCBvYmpfZGlyKTsKCQlpZiAodGhlX3JlcG9zaXRvcnktPm9iamVjdHMtPmNvbW1pdF9ncmFwaCkKCQkJb2lkcy5hbGxvYyArPSB0aGVfcmVwb3NpdG9yeS0+b2JqZWN0cy0+Y29tbWl0X2dyYXBoLT5udW1fY29tbWl0czsKCX0KCglpZiAob2lkcy5hbGxvYyA8IDEwMjQpCgkJb2lkcy5hbGxvYyA9IDEwMjQ7CglBTExPQ19BUlJBWShvaWRzLmxpc3QsIG9pZHMuYWxsb2MpOwoKCWlmIChhcHBlbmQgJiYgdGhlX3JlcG9zaXRvcnktPm9iamVjdHMtPmNvbW1pdF9ncmFwaCkgewoJCXN0cnVjdCBjb21taXRfZ3JhcGggKmNvbW1pdF9ncmFwaCA9CgkJCXRoZV9yZXBvc2l0b3J5LT5vYmplY3RzLT5jb21taXRfZ3JhcGg7CgkJZm9yIChpID0gMDsgaSA8IGNvbW1pdF9ncmFwaC0+bnVtX2NvbW1pdHM7IGkrKykgewoJCQljb25zdCB1bnNpZ25lZCBjaGFyICpoYXNoID0gY29tbWl0X2dyYXBoLT5jaHVua19vaWRfbG9va3VwICsKCQkJCWNvbW1pdF9ncmFwaC0+aGFzaF9sZW4gKiBpOwoJCQloYXNoY3B5KG9pZHMubGlzdFtvaWRzLm5yKytdLmhhc2gsIGhhc2gpOwoJCX0KCX0KCglpZiAocGFja19pbmRleGVzKSB7CgkJc3RydWN0IHN0cmJ1ZiBwYWNrbmFtZSA9IFNUUkJVRl9JTklUOwoJCWludCBkaXJsZW47CgkJc3RyYnVmX2FkZGYoJnBhY2tuYW1lLCAiJXMvcGFjay8iLCBvYmpfZGlyKTsKCQlkaXJsZW4gPSBwYWNrbmFtZS5sZW47CgkJZm9yIChpID0gMDsgaSA8IHBhY2tfaW5kZXhlcy0+bnI7IGkrKykgewoJCQlzdHJ1Y3QgcGFja2VkX2dpdCAqcDsKCQkJc3RyYnVmX3NldGxlbigmcGFja25hbWUsIGRpcmxlbik7CgkJCXN0cmJ1Zl9hZGRzdHIoJnBhY2tuYW1lLCBwYWNrX2luZGV4ZXMtPml0ZW1zW2ldLnN0cmluZyk7CgkJCXAgPSBhZGRfcGFja2VkX2dpdChwYWNrbmFtZS5idWYsIHBhY2tuYW1lLmxlbiwgMSk7CgkJCWlmICghcCkKCQkJCWRpZShfKCJlcnJvciBhZGRpbmcgcGFjayAlcyIpLCBwYWNrbmFtZS5idWYpOwoJCQlpZiAob3Blbl9wYWNrX2luZGV4KHApKQoJCQkJZGllKF8oImVycm9yIG9wZW5pbmcgaW5kZXggZm9yICVzIiksIHBhY2tuYW1lLmJ1Zik7CgkJCWZvcl9lYWNoX29iamVjdF9pbl9wYWNrKHAsIGFkZF9wYWNrZWRfY29tbWl0cywgJm9pZHMpOwoJCQljbG9zZV9wYWNrKHApOwoJCX0KCQlzdHJidWZfcmVsZWFzZSgmcGFja25hbWUpOwoJfQoKCWlmIChjb21taXRfaGV4KSB7CgkJZm9yIChpID0gMDsgaSA8IGNvbW1pdF9oZXgtPm5yOyBpKyspIHsKCQkJY29uc3QgY2hhciAqZW5kOwoJCQlzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCQkJc3RydWN0IGNvbW1pdCAqcmVzdWx0OwoKCQkJaWYgKGNvbW1pdF9oZXgtPml0ZW1zW2ldLnN0cmluZyAmJgoJCQkgICAgcGFyc2Vfb2lkX2hleChjb21taXRfaGV4LT5pdGVtc1tpXS5zdHJpbmcsICZvaWQsICZlbmQpKQoJCQkJY29udGludWU7CgoJCQlyZXN1bHQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkodGhlX3JlcG9zaXRvcnksICZvaWQsIDEpOwoKCQkJaWYgKHJlc3VsdCkgewoJCQkJQUxMT0NfR1JPVyhvaWRzLmxpc3QsIG9pZHMubnIgKyAxLCBvaWRzLmFsbG9jKTsKCQkJCW9pZGNweSgmb2lkcy5saXN0W29pZHMubnJdLCAmKHJlc3VsdC0+b2JqZWN0Lm9pZCkpOwoJCQkJb2lkcy5ucisrOwoJCQl9CgkJfQoJfQoKCWlmICghcGFja19pbmRleGVzICYmICFjb21taXRfaGV4KQoJCWZvcl9lYWNoX3BhY2tlZF9vYmplY3QoYWRkX3BhY2tlZF9jb21taXRzLCAmb2lkcywgMCk7CgoJY2xvc2VfcmVhY2hhYmxlKCZvaWRzKTsKCglRU09SVChvaWRzLmxpc3QsIG9pZHMubnIsIGNvbW1pdF9jb21wYXJlKTsKCgljb3VudF9kaXN0aW5jdCA9IDE7Cglmb3IgKGkgPSAxOyBpIDwgb2lkcy5ucjsgaSsrKSB7CgkJaWYgKG9pZGNtcCgmb2lkcy5saXN0W2ktMV0sICZvaWRzLmxpc3RbaV0pKQoJCQljb3VudF9kaXN0aW5jdCsrOwoJfQoKCWlmIChjb3VudF9kaXN0aW5jdCA+PSBHUkFQSF9QQVJFTlRfTUlTU0lORykKCQlkaWUoXygidGhlIGNvbW1pdCBncmFwaCBmb3JtYXQgY2Fubm90IHdyaXRlICVkIGNvbW1pdHMiKSwgY291bnRfZGlzdGluY3QpOwoKCWNvbW1pdHMubnIgPSAwOwoJY29tbWl0cy5hbGxvYyA9IGNvdW50X2Rpc3RpbmN0OwoJQUxMT0NfQVJSQVkoY29tbWl0cy5saXN0LCBjb21taXRzLmFsbG9jKTsKCgludW1fZXh0cmFfZWRnZXMgPSAwOwoJZm9yIChpID0gMDsgaSA8IG9pZHMubnI7IGkrKykgewoJCWludCBudW1fcGFyZW50cyA9IDA7CgkJaWYgKGkgPiAwICYmICFvaWRjbXAoJm9pZHMubGlzdFtpLTFdLCAmb2lkcy5saXN0W2ldKSkKCQkJY29udGludWU7CgoJCWNvbW1pdHMubGlzdFtjb21taXRzLm5yXSA9IGxvb2t1cF9jb21taXQodGhlX3JlcG9zaXRvcnksICZvaWRzLmxpc3RbaV0pOwoJCXBhcnNlX2NvbW1pdChjb21taXRzLmxpc3RbY29tbWl0cy5ucl0pOwoKCQlmb3IgKHBhcmVudCA9IGNvbW1pdHMubGlzdFtjb21taXRzLm5yXS0+cGFyZW50czsKCQkgICAgIHBhcmVudDsgcGFyZW50ID0gcGFyZW50LT5uZXh0KQoJCQludW1fcGFyZW50cysrOwoKCQlpZiAobnVtX3BhcmVudHMgPiAyKQoJCQludW1fZXh0cmFfZWRnZXMgKz0gbnVtX3BhcmVudHMgLSAxOwoKCQljb21taXRzLm5yKys7Cgl9CgludW1fY2h1bmtzID0gbnVtX2V4dHJhX2VkZ2VzID8gNCA6IDM7CgoJaWYgKGNvbW1pdHMubnIgPj0gR1JBUEhfUEFSRU5UX01JU1NJTkcpCgkJZGllKF8oInRvbyBtYW55IGNvbW1pdHMgdG8gd3JpdGUgZ3JhcGgiKSk7CgoJY29tcHV0ZV9nZW5lcmF0aW9uX251bWJlcnMoJmNvbW1pdHMpOwoKCWdyYXBoX25hbWUgPSBnZXRfY29tbWl0X2dyYXBoX2ZpbGVuYW1lKG9ial9kaXIpOwoJaWYgKHNhZmVfY3JlYXRlX2xlYWRpbmdfZGlyZWN0b3JpZXMoZ3JhcGhfbmFtZSkpCgkJZGllX2Vycm5vKF8oInVuYWJsZSB0byBjcmVhdGUgbGVhZGluZyBkaXJlY3RvcmllcyBvZiAlcyIpLAoJCQkgIGdyYXBoX25hbWUpOwoKCWhvbGRfbG9ja19maWxlX2Zvcl91cGRhdGUoJmxrLCBncmFwaF9uYW1lLCBMT0NLX0RJRV9PTl9FUlJPUik7CglmID0gaGFzaGZkKGxrLnRlbXBmaWxlLT5mZCwgbGsudGVtcGZpbGUtPmZpbGVuYW1lLmJ1Zik7CgoJaGFzaHdyaXRlX2JlMzIoZiwgR1JBUEhfU0lHTkFUVVJFKTsKCgloYXNod3JpdGVfdTgoZiwgR1JBUEhfVkVSU0lPTik7CgloYXNod3JpdGVfdTgoZiwgR1JBUEhfT0lEX1ZFUlNJT04pOwoJaGFzaHdyaXRlX3U4KGYsIG51bV9jaHVua3MpOwoJaGFzaHdyaXRlX3U4KGYsIDApOyAvKiB1bnVzZWQgcGFkZGluZyBieXRlICovCgoJY2h1bmtfaWRzWzBdID0gR1JBUEhfQ0hVTktJRF9PSURGQU5PVVQ7CgljaHVua19pZHNbMV0gPSBHUkFQSF9DSFVOS0lEX09JRExPT0tVUDsKCWNodW5rX2lkc1syXSA9IEdSQVBIX0NIVU5LSURfREFUQTsKCWlmIChudW1fZXh0cmFfZWRnZXMpCgkJY2h1bmtfaWRzWzNdID0gR1JBUEhfQ0hVTktJRF9MQVJHRUVER0VTOwoJZWxzZQoJCWNodW5rX2lkc1szXSA9IDA7CgljaHVua19pZHNbNF0gPSAwOwoKCWNodW5rX29mZnNldHNbMF0gPSA4ICsgKG51bV9jaHVua3MgKyAxKSAqIEdSQVBIX0NIVU5LTE9PS1VQX1dJRFRIOwoJY2h1bmtfb2Zmc2V0c1sxXSA9IGNodW5rX29mZnNldHNbMF0gKyBHUkFQSF9GQU5PVVRfU0laRTsKCWNodW5rX29mZnNldHNbMl0gPSBjaHVua19vZmZzZXRzWzFdICsgR1JBUEhfT0lEX0xFTiAqIGNvbW1pdHMubnI7CgljaHVua19vZmZzZXRzWzNdID0gY2h1bmtfb2Zmc2V0c1syXSArIChHUkFQSF9PSURfTEVOICsgMTYpICogY29tbWl0cy5ucjsKCWNodW5rX29mZnNldHNbNF0gPSBjaHVua19vZmZzZXRzWzNdICsgNCAqIG51bV9leHRyYV9lZGdlczsKCglmb3IgKGkgPSAwOyBpIDw9IG51bV9jaHVua3M7IGkrKykgewoJCXVpbnQzMl90IGNodW5rX3dyaXRlWzNdOwoKCQljaHVua193cml0ZVswXSA9IGh0b25sKGNodW5rX2lkc1tpXSk7CgkJY2h1bmtfd3JpdGVbMV0gPSBodG9ubChjaHVua19vZmZzZXRzW2ldID4+IDMyKTsKCQljaHVua193cml0ZVsyXSA9IGh0b25sKGNodW5rX29mZnNldHNbaV0gJiAweGZmZmZmZmZmKTsKCQloYXNod3JpdGUoZiwgY2h1bmtfd3JpdGUsIDEyKTsKCX0KCgl3cml0ZV9ncmFwaF9jaHVua19mYW5vdXQoZiwgY29tbWl0cy5saXN0LCBjb21taXRzLm5yKTsKCXdyaXRlX2dyYXBoX2NodW5rX29pZHMoZiwgR1JBUEhfT0lEX0xFTiwgY29tbWl0cy5saXN0LCBjb21taXRzLm5yKTsKCXdyaXRlX2dyYXBoX2NodW5rX2RhdGEoZiwgR1JBUEhfT0lEX0xFTiwgY29tbWl0cy5saXN0LCBjb21taXRzLm5yKTsKCXdyaXRlX2dyYXBoX2NodW5rX2xhcmdlX2VkZ2VzKGYsIGNvbW1pdHMubGlzdCwgY29tbWl0cy5ucik7CgoJY2xvc2VfY29tbWl0X2dyYXBoKCk7CglmaW5hbGl6ZV9oYXNoZmlsZShmLCBOVUxMLCBDU1VNX0hBU0hfSU5fU1RSRUFNIHwgQ1NVTV9GU1lOQyk7Cgljb21taXRfbG9ja19maWxlKCZsayk7CgoJZnJlZShvaWRzLmxpc3QpOwoJb2lkcy5hbGxvYyA9IDA7CglvaWRzLm5yID0gMDsKfQoKI2RlZmluZSBWRVJJRllfQ09NTUlUX0dSQVBIX0VSUk9SX0hBU0ggMgpzdGF0aWMgaW50IHZlcmlmeV9jb21taXRfZ3JhcGhfZXJyb3I7CgpzdGF0aWMgdm9pZCBncmFwaF9yZXBvcnQoY29uc3QgY2hhciAqZm10LCAuLi4pCnsKCXZhX2xpc3QgYXA7CgoJdmVyaWZ5X2NvbW1pdF9ncmFwaF9lcnJvciA9IDE7Cgl2YV9zdGFydChhcCwgZm10KTsKCXZmcHJpbnRmKHN0ZGVyciwgZm10LCBhcCk7CglmcHJpbnRmKHN0ZGVyciwgIlxuIik7Cgl2YV9lbmQoYXApOwp9CgojZGVmaW5lIEdFTkVSQVRJT05fWkVST19FWElTVFMgMQojZGVmaW5lIEdFTkVSQVRJT05fTlVNQkVSX0VYSVNUUyAyCgppbnQgdmVyaWZ5X2NvbW1pdF9ncmFwaChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgc3RydWN0IGNvbW1pdF9ncmFwaCAqZykKewoJdWludDMyX3QgaSwgY3VyX2Zhbm91dF9wb3MgPSAwOwoJc3RydWN0IG9iamVjdF9pZCBwcmV2X29pZCwgY3VyX29pZCwgY2hlY2tzdW07CglpbnQgZ2VuZXJhdGlvbl96ZXJvID0gMDsKCXN0cnVjdCBoYXNoZmlsZSAqZjsKCWludCBkZXZudWxsOwoKCWlmICghZykgewoJCWdyYXBoX3JlcG9ydCgibm8gY29tbWl0LWdyYXBoIGZpbGUgbG9hZGVkIik7CgkJcmV0dXJuIDE7Cgl9CgoJdmVyaWZ5X2NvbW1pdF9ncmFwaF9lcnJvciA9IDA7CgoJaWYgKCFnLT5jaHVua19vaWRfZmFub3V0KQoJCWdyYXBoX3JlcG9ydCgiY29tbWl0LWdyYXBoIGlzIG1pc3NpbmcgdGhlIE9JRCBGYW5vdXQgY2h1bmsiKTsKCWlmICghZy0+Y2h1bmtfb2lkX2xvb2t1cCkKCQlncmFwaF9yZXBvcnQoImNvbW1pdC1ncmFwaCBpcyBtaXNzaW5nIHRoZSBPSUQgTG9va3VwIGNodW5rIik7CglpZiAoIWctPmNodW5rX2NvbW1pdF9kYXRhKQoJCWdyYXBoX3JlcG9ydCgiY29tbWl0LWdyYXBoIGlzIG1pc3NpbmcgdGhlIENvbW1pdCBEYXRhIGNodW5rIik7CgoJaWYgKHZlcmlmeV9jb21taXRfZ3JhcGhfZXJyb3IpCgkJcmV0dXJuIHZlcmlmeV9jb21taXRfZ3JhcGhfZXJyb3I7CgoJZGV2bnVsbCA9IG9wZW4oIi9kZXYvbnVsbCIsIE9fV1JPTkxZKTsKCWYgPSBoYXNoZmQoZGV2bnVsbCwgTlVMTCk7CgloYXNod3JpdGUoZiwgZy0+ZGF0YSwgZy0+ZGF0YV9sZW4gLSBnLT5oYXNoX2xlbik7CglmaW5hbGl6ZV9oYXNoZmlsZShmLCBjaGVja3N1bS5oYXNoLCBDU1VNX0NMT1NFKTsKCWlmIChoYXNoY21wKGNoZWNrc3VtLmhhc2gsIGctPmRhdGEgKyBnLT5kYXRhX2xlbiAtIGctPmhhc2hfbGVuKSkgewoJCWdyYXBoX3JlcG9ydChfKCJ0aGUgY29tbWl0LWdyYXBoIGZpbGUgaGFzIGluY29ycmVjdCBjaGVja3N1bSBhbmQgaXMgbGlrZWx5IGNvcnJ1cHQiKSk7CgkJdmVyaWZ5X2NvbW1pdF9ncmFwaF9lcnJvciA9IFZFUklGWV9DT01NSVRfR1JBUEhfRVJST1JfSEFTSDsKCX0KCglmb3IgKGkgPSAwOyBpIDwgZy0+bnVtX2NvbW1pdHM7IGkrKykgewoJCXN0cnVjdCBjb21taXQgKmdyYXBoX2NvbW1pdDsKCgkJaGFzaGNweShjdXJfb2lkLmhhc2gsIGctPmNodW5rX29pZF9sb29rdXAgKyBnLT5oYXNoX2xlbiAqIGkpOwoKCQlpZiAoaSAmJiBvaWRjbXAoJnByZXZfb2lkLCAmY3VyX29pZCkgPj0gMCkKCQkJZ3JhcGhfcmVwb3J0KCJjb21taXQtZ3JhcGggaGFzIGluY29ycmVjdCBPSUQgb3JkZXI6ICVzIHRoZW4gJXMiLAoJCQkJICAgICBvaWRfdG9faGV4KCZwcmV2X29pZCksCgkJCQkgICAgIG9pZF90b19oZXgoJmN1cl9vaWQpKTsKCgkJb2lkY3B5KCZwcmV2X29pZCwgJmN1cl9vaWQpOwoKCQl3aGlsZSAoY3VyX29pZC5oYXNoWzBdID4gY3VyX2Zhbm91dF9wb3MpIHsKCQkJdWludDMyX3QgZmFub3V0X3ZhbHVlID0gZ2V0X2JlMzIoZy0+Y2h1bmtfb2lkX2Zhbm91dCArIGN1cl9mYW5vdXRfcG9zKTsKCgkJCWlmIChpICE9IGZhbm91dF92YWx1ZSkKCQkJCWdyYXBoX3JlcG9ydCgiY29tbWl0LWdyYXBoIGhhcyBpbmNvcnJlY3QgZmFub3V0IHZhbHVlOiBmYW5vdXRbJWRdID0gJXUgIT0gJXUiLAoJCQkJCSAgICAgY3VyX2Zhbm91dF9wb3MsIGZhbm91dF92YWx1ZSwgaSk7CgkJCWN1cl9mYW5vdXRfcG9zKys7CgkJfQoKCQlncmFwaF9jb21taXQgPSBsb29rdXBfY29tbWl0KHIsICZjdXJfb2lkKTsKCQlpZiAoIXBhcnNlX2NvbW1pdF9pbl9ncmFwaF9vbmUoZywgZ3JhcGhfY29tbWl0KSkKCQkJZ3JhcGhfcmVwb3J0KCJmYWlsZWQgdG8gcGFyc2UgJXMgZnJvbSBjb21taXQtZ3JhcGgiLAoJCQkJICAgICBvaWRfdG9faGV4KCZjdXJfb2lkKSk7Cgl9CgoJd2hpbGUgKGN1cl9mYW5vdXRfcG9zIDwgMjU2KSB7CgkJdWludDMyX3QgZmFub3V0X3ZhbHVlID0gZ2V0X2JlMzIoZy0+Y2h1bmtfb2lkX2Zhbm91dCArIGN1cl9mYW5vdXRfcG9zKTsKCgkJaWYgKGctPm51bV9jb21taXRzICE9IGZhbm91dF92YWx1ZSkKCQkJZ3JhcGhfcmVwb3J0KCJjb21taXQtZ3JhcGggaGFzIGluY29ycmVjdCBmYW5vdXQgdmFsdWU6IGZhbm91dFslZF0gPSAldSAhPSAldSIsCgkJCQkgICAgIGN1cl9mYW5vdXRfcG9zLCBmYW5vdXRfdmFsdWUsIGkpOwoKCQljdXJfZmFub3V0X3BvcysrOwoJfQoKCWlmICh2ZXJpZnlfY29tbWl0X2dyYXBoX2Vycm9yICYgflZFUklGWV9DT01NSVRfR1JBUEhfRVJST1JfSEFTSCkKCQlyZXR1cm4gdmVyaWZ5X2NvbW1pdF9ncmFwaF9lcnJvcjsKCglmb3IgKGkgPSAwOyBpIDwgZy0+bnVtX2NvbW1pdHM7IGkrKykgewoJCXN0cnVjdCBjb21taXQgKmdyYXBoX2NvbW1pdCwgKm9kYl9jb21taXQ7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpncmFwaF9wYXJlbnRzLCAqb2RiX3BhcmVudHM7CgkJdWludDMyX3QgbWF4X2dlbmVyYXRpb24gPSAwOwoKCQloYXNoY3B5KGN1cl9vaWQuaGFzaCwgZy0+Y2h1bmtfb2lkX2xvb2t1cCArIGctPmhhc2hfbGVuICogaSk7CgoJCWdyYXBoX2NvbW1pdCA9IGxvb2t1cF9jb21taXQociwgJmN1cl9vaWQpOwoJCW9kYl9jb21taXQgPSAoc3RydWN0IGNvbW1pdCAqKWNyZWF0ZV9vYmplY3QociwgY3VyX29pZC5oYXNoLCBhbGxvY19jb21taXRfbm9kZShyKSk7CgkJaWYgKHBhcnNlX2NvbW1pdF9pbnRlcm5hbChvZGJfY29tbWl0LCAwLCAwKSkgewoJCQlncmFwaF9yZXBvcnQoImZhaWxlZCB0byBwYXJzZSAlcyBmcm9tIG9iamVjdCBkYXRhYmFzZSIsCgkJCQkgICAgIG9pZF90b19oZXgoJmN1cl9vaWQpKTsKCQkJY29udGludWU7CgkJfQoKCQlpZiAob2lkY21wKCZnZXRfY29tbWl0X3RyZWVfaW5fZ3JhcGhfb25lKGcsIGdyYXBoX2NvbW1pdCktPm9iamVjdC5vaWQsCgkJCSAgIGdldF9jb21taXRfdHJlZV9vaWQob2RiX2NvbW1pdCkpKQoJCQlncmFwaF9yZXBvcnQoInJvb3QgdHJlZSBPSUQgZm9yIGNvbW1pdCAlcyBpbiBjb21taXQtZ3JhcGggaXMgJXMgIT0gJXMiLAoJCQkJICAgICBvaWRfdG9faGV4KCZjdXJfb2lkKSwKCQkJCSAgICAgb2lkX3RvX2hleChnZXRfY29tbWl0X3RyZWVfb2lkKGdyYXBoX2NvbW1pdCkpLAoJCQkJICAgICBvaWRfdG9faGV4KGdldF9jb21taXRfdHJlZV9vaWQob2RiX2NvbW1pdCkpKTsKCgkJZ3JhcGhfcGFyZW50cyA9IGdyYXBoX2NvbW1pdC0+cGFyZW50czsKCQlvZGJfcGFyZW50cyA9IG9kYl9jb21taXQtPnBhcmVudHM7CgoJCXdoaWxlIChncmFwaF9wYXJlbnRzKSB7CgkJCWlmIChvZGJfcGFyZW50cyA9PSBOVUxMKSB7CgkJCQlncmFwaF9yZXBvcnQoImNvbW1pdC1ncmFwaCBwYXJlbnQgbGlzdCBmb3IgY29tbWl0ICVzIGlzIHRvbyBsb25nIiwKCQkJCQkgICAgIG9pZF90b19oZXgoJmN1cl9vaWQpKTsKCQkJCWJyZWFrOwoJCQl9CgoJCQlpZiAob2lkY21wKCZncmFwaF9wYXJlbnRzLT5pdGVtLT5vYmplY3Qub2lkLCAmb2RiX3BhcmVudHMtPml0ZW0tPm9iamVjdC5vaWQpKQoJCQkJZ3JhcGhfcmVwb3J0KCJjb21taXQtZ3JhcGggcGFyZW50IGZvciAlcyBpcyAlcyAhPSAlcyIsCgkJCQkJICAgICBvaWRfdG9faGV4KCZjdXJfb2lkKSwKCQkJCQkgICAgIG9pZF90b19oZXgoJmdyYXBoX3BhcmVudHMtPml0ZW0tPm9iamVjdC5vaWQpLAoJCQkJCSAgICAgb2lkX3RvX2hleCgmb2RiX3BhcmVudHMtPml0ZW0tPm9iamVjdC5vaWQpKTsKCgkJCWlmIChncmFwaF9wYXJlbnRzLT5pdGVtLT5nZW5lcmF0aW9uID4gbWF4X2dlbmVyYXRpb24pCgkJCQltYXhfZ2VuZXJhdGlvbiA9IGdyYXBoX3BhcmVudHMtPml0ZW0tPmdlbmVyYXRpb247CgoJCQlncmFwaF9wYXJlbnRzID0gZ3JhcGhfcGFyZW50cy0+bmV4dDsKCQkJb2RiX3BhcmVudHMgPSBvZGJfcGFyZW50cy0+bmV4dDsKCQl9CgoJCWlmIChvZGJfcGFyZW50cyAhPSBOVUxMKQoJCQlncmFwaF9yZXBvcnQoImNvbW1pdC1ncmFwaCBwYXJlbnQgbGlzdCBmb3IgY29tbWl0ICVzIHRlcm1pbmF0ZXMgZWFybHkiLAoJCQkJICAgICBvaWRfdG9faGV4KCZjdXJfb2lkKSk7CgoJCWlmICghZ3JhcGhfY29tbWl0LT5nZW5lcmF0aW9uKSB7CgkJCWlmIChnZW5lcmF0aW9uX3plcm8gPT0gR0VORVJBVElPTl9OVU1CRVJfRVhJU1RTKQoJCQkJZ3JhcGhfcmVwb3J0KCJjb21taXQtZ3JhcGggaGFzIGdlbmVyYXRpb24gbnVtYmVyIHplcm8gZm9yIGNvbW1pdCAlcywgYnV0IG5vbi16ZXJvIGVsc2V3aGVyZSIsCgkJCQkJICAgICBvaWRfdG9faGV4KCZjdXJfb2lkKSk7CgkJCWdlbmVyYXRpb25femVybyA9IEdFTkVSQVRJT05fWkVST19FWElTVFM7CgkJfSBlbHNlIGlmIChnZW5lcmF0aW9uX3plcm8gPT0gR0VORVJBVElPTl9aRVJPX0VYSVNUUykKCQkJZ3JhcGhfcmVwb3J0KCJjb21taXQtZ3JhcGggaGFzIG5vbi16ZXJvIGdlbmVyYXRpb24gbnVtYmVyIGZvciBjb21taXQgJXMsIGJ1dCB6ZXJvIGVsc2V3aGVyZSIsCgkJCQkgICAgIG9pZF90b19oZXgoJmN1cl9vaWQpKTsKCgkJaWYgKGdlbmVyYXRpb25femVybyA9PSBHRU5FUkFUSU9OX1pFUk9fRVhJU1RTKQoJCQljb250aW51ZTsKCgkJLyoKCQkgKiBJZiBvbmUgb2Ygb3VyIHBhcmVudHMgaGFzIGdlbmVyYXRpb24gR0VORVJBVElPTl9OVU1CRVJfTUFYLCB0aGVuCgkJICogb3VyIGdlbmVyYXRpb24gaXMgYWxzbyBHRU5FUkFUSU9OX05VTUJFUl9NQVguIERlY3JlbWVudCB0byBhdm9pZAoJCSAqIGV4dHJhIGxvZ2ljIGluIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uLgoJCSAqLwoJCWlmIChtYXhfZ2VuZXJhdGlvbiA9PSBHRU5FUkFUSU9OX05VTUJFUl9NQVgpCgkJCW1heF9nZW5lcmF0aW9uLS07CgoJCWlmIChncmFwaF9jb21taXQtPmdlbmVyYXRpb24gIT0gbWF4X2dlbmVyYXRpb24gKyAxKQoJCQlncmFwaF9yZXBvcnQoImNvbW1pdC1ncmFwaCBnZW5lcmF0aW9uIGZvciBjb21taXQgJXMgaXMgJXUgIT0gJXUiLAoJCQkJICAgICBvaWRfdG9faGV4KCZjdXJfb2lkKSwKCQkJCSAgICAgZ3JhcGhfY29tbWl0LT5nZW5lcmF0aW9uLAoJCQkJICAgICBtYXhfZ2VuZXJhdGlvbiArIDEpOwoKCQlpZiAoZ3JhcGhfY29tbWl0LT5kYXRlICE9IG9kYl9jb21taXQtPmRhdGUpCgkJCWdyYXBoX3JlcG9ydCgiY29tbWl0IGRhdGUgZm9yIGNvbW1pdCAlcyBpbiBjb21taXQtZ3JhcGggaXMgJSJQUkl0aW1lIiAhPSAlIlBSSXRpbWUsCgkJCQkgICAgIG9pZF90b19oZXgoJmN1cl9vaWQpLAoJCQkJICAgICBncmFwaF9jb21taXQtPmRhdGUsCgkJCQkgICAgIG9kYl9jb21taXQtPmRhdGUpOwoJfQoKCXJldHVybiB2ZXJpZnlfY29tbWl0X2dyYXBoX2Vycm9yOwp9Cgp2b2lkIGZyZWVfY29tbWl0X2dyYXBoKHN0cnVjdCBjb21taXRfZ3JhcGggKmcpCnsKCWlmICghZykKCQlyZXR1cm47CglpZiAoZy0+Z3JhcGhfZmQgPj0gMCkgewoJCW11bm1hcCgodm9pZCAqKWctPmRhdGEsIGctPmRhdGFfbGVuKTsKCQlnLT5kYXRhID0gTlVMTDsKCQljbG9zZShnLT5ncmFwaF9mZCk7Cgl9CglmcmVlKGcpOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"git-compat-util.h\"\n#include \"lockfile.h\"\n#include \"pack.h\"\n#include \"packfile.h\"\n#include \"commit.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"revision.h\"\n#include \"sha1-lookup.h\"\n#include \"commit-graph.h\"\n#include \"object-store.h\"\n#include \"alloc.h\"\n\n#define GRAPH_SIGNATURE 0x43475048 /* \"CGPH\" */\n#define GRAPH_CHUNKID_OIDFANOUT 0x4f494446 /* \"OIDF\" */\n#define GRAPH_CHUNKID_OIDLOOKUP 0x4f49444c /* \"OIDL\" */\n#define GRAPH_CHUNKID_DATA 0x43444154 /* \"CDAT\" */\n#define GRAPH_CHUNKID_LARGEEDGES 0x45444745 /* \"EDGE\" */\n\n#define GRAPH_DATA_WIDTH 36\n\n#define GRAPH_VERSION_1 0x1\n#define GRAPH_VERSION GRAPH_VERSION_1\n\n#define GRAPH_OID_VERSION_SHA1 1\n#define GRAPH_OID_LEN_SHA1 GIT_SHA1_RAWSZ\n#define GRAPH_OID_VERSION GRAPH_OID_VERSION_SHA1\n#define GRAPH_OID_LEN GRAPH_OID_LEN_SHA1\n\n#define GRAPH_OCTOPUS_EDGES_NEEDED 0x80000000\n#define GRAPH_PARENT_MISSING 0x7fffffff\n#define GRAPH_EDGE_LAST_MASK 0x7fffffff\n#define GRAPH_PARENT_NONE 0x70000000\n\n#define GRAPH_LAST_EDGE 0x80000000\n\n#define GRAPH_HEADER_SIZE 8\n#define GRAPH_FANOUT_SIZE (4 * 256)\n#define GRAPH_CHUNKLOOKUP_WIDTH 12\n#define GRAPH_MIN_SIZE (GRAPH_HEADER_SIZE + 4 * GRAPH_CHUNKLOOKUP_WIDTH \\\n\t\t\t+ GRAPH_FANOUT_SIZE + GRAPH_OID_LEN)\n\nchar *get_commit_graph_filename(const char *obj_dir)\n{\n\treturn xstrfmt(\"%s/info/commit-graph\", obj_dir);\n}\n\nstatic struct commit_graph *alloc_commit_graph(void)\n{\n\tstruct commit_graph *g = xcalloc(1, sizeof(*g));\n\tg->graph_fd = -1;\n\n\treturn g;\n}\n\nstruct commit_graph *load_commit_graph_one(const char *graph_file)\n{\n\tvoid *graph_map;\n\tconst unsigned char *data, *chunk_lookup;\n\tsize_t graph_size;\n\tstruct stat st;\n\tuint32_t i;\n\tstruct commit_graph *graph;\n\tint fd = git_open(graph_file);\n\tuint64_t last_chunk_offset;\n\tuint32_t last_chunk_id;\n\tuint32_t graph_signature;\n\tunsigned char graph_version, hash_version;\n\n\tif (fd < 0)\n\t\treturn NULL;\n\tif (fstat(fd, &st)) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tgraph_size = xsize_t(st.st_size);\n\n\tif (graph_size < GRAPH_MIN_SIZE) {\n\t\tclose(fd);\n\t\tdie(_(\"graph file %s is too small\"), graph_file);\n\t}\n\tgraph_map = xmmap(NULL, graph_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\tdata = (const unsigned char *)graph_map;\n\n\tgraph_signature = get_be32(data);\n\tif (graph_signature != GRAPH_SIGNATURE) {\n\t\terror(_(\"graph signature %X does not match signature %X\"),\n\t\t      graph_signature, GRAPH_SIGNATURE);\n\t\tgoto cleanup_fail;\n\t}\n\n\tgraph_version = *(unsigned char*)(data + 4);\n\tif (graph_version != GRAPH_VERSION) {\n\t\terror(_(\"graph version %X does not match version %X\"),\n\t\t      graph_version, GRAPH_VERSION);\n\t\tgoto cleanup_fail;\n\t}\n\n\thash_version = *(unsigned char*)(data + 5);\n\tif (hash_version != GRAPH_OID_VERSION) {\n\t\terror(_(\"hash version %X does not match version %X\"),\n\t\t      hash_version, GRAPH_OID_VERSION);\n\t\tgoto cleanup_fail;\n\t}\n\n\tgraph = alloc_commit_graph();\n\n\tgraph->hash_len = GRAPH_OID_LEN;\n\tgraph->num_chunks = *(unsigned char*)(data + 6);\n\tgraph->graph_fd = fd;\n\tgraph->data = graph_map;\n\tgraph->data_len = graph_size;\n\n\tlast_chunk_id = 0;\n\tlast_chunk_offset = 8;\n\tchunk_lookup = data + 8;\n\tfor (i = 0; i < graph->num_chunks; i++) {\n\t\tuint32_t chunk_id = get_be32(chunk_lookup + 0);\n\t\tuint64_t chunk_offset = get_be64(chunk_lookup + 4);\n\t\tint chunk_repeated = 0;\n\n\t\tchunk_lookup += GRAPH_CHUNKLOOKUP_WIDTH;\n\n\t\tif (chunk_offset > graph_size - GIT_MAX_RAWSZ) {\n\t\t\terror(_(\"improper chunk offset %08x%08x\"), (uint32_t)(chunk_offset >> 32),\n\t\t\t      (uint32_t)chunk_offset);\n\t\t\tgoto cleanup_fail;\n\t\t}\n\n\t\tswitch (chunk_id) {\n\t\tcase GRAPH_CHUNKID_OIDFANOUT:\n\t\t\tif (graph->chunk_oid_fanout)\n\t\t\t\tchunk_repeated = 1;\n\t\t\telse\n\t\t\t\tgraph->chunk_oid_fanout = (uint32_t*)(data + chunk_offset);\n\t\t\tbreak;\n\n\t\tcase GRAPH_CHUNKID_OIDLOOKUP:\n\t\t\tif (graph->chunk_oid_lookup)\n\t\t\t\tchunk_repeated = 1;\n\t\t\telse\n\t\t\t\tgraph->chunk_oid_lookup = data + chunk_offset;\n\t\t\tbreak;\n\n\t\tcase GRAPH_CHUNKID_DATA:\n\t\t\tif (graph->chunk_commit_data)\n\t\t\t\tchunk_repeated = 1;\n\t\t\telse\n\t\t\t\tgraph->chunk_commit_data = data + chunk_offset;\n\t\t\tbreak;\n\n\t\tcase GRAPH_CHUNKID_LARGEEDGES:\n\t\t\tif (graph->chunk_large_edges)\n\t\t\t\tchunk_repeated = 1;\n\t\t\telse\n\t\t\t\tgraph->chunk_large_edges = data + chunk_offset;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chunk_repeated) {\n\t\t\terror(_(\"chunk id %08x appears multiple times\"), chunk_id);\n\t\t\tgoto cleanup_fail;\n\t\t}\n\n\t\tif (last_chunk_id == GRAPH_CHUNKID_OIDLOOKUP)\n\t\t{\n\t\t\tgraph->num_commits = (chunk_offset - last_chunk_offset)\n\t\t\t\t\t     / graph->hash_len;\n\t\t}\n\n\t\tlast_chunk_id = chunk_id;\n\t\tlast_chunk_offset = chunk_offset;\n\t}\n\n\treturn graph;\n\ncleanup_fail:\n\tmunmap(graph_map, graph_size);\n\tclose(fd);\n\texit(1);\n}\n\nstatic void prepare_commit_graph_one(struct repository *r, const char *obj_dir)\n{\n\tchar *graph_name;\n\n\tif (r->objects->commit_graph)\n\t\treturn;\n\n\tgraph_name = get_commit_graph_filename(obj_dir);\n\tr->objects->commit_graph =\n\t\tload_commit_graph_one(graph_name);\n\n\tFREE_AND_NULL(graph_name);\n}\n\n/*\n * Return 1 if commit_graph is non-NULL, and 0 otherwise.\n *\n * On the first invocation, this function attemps to load the commit\n * graph if the_repository is configured to have one.\n */\nstatic int prepare_commit_graph(struct repository *r)\n{\n\tstruct alternate_object_database *alt;\n\tchar *obj_dir;\n\tint config_value;\n\n\tif (r->objects->commit_graph_attempted)\n\t\treturn !!r->objects->commit_graph;\n\tr->objects->commit_graph_attempted = 1;\n\n\tif (repo_config_get_bool(r, \"core.commitgraph\", &config_value) ||\n\t    !config_value)\n\t\t/*\n\t\t * This repository is not configured to use commit graphs, so\n\t\t * do not load one. (But report commit_graph_attempted anyway\n\t\t * so that commit graph loading is not attempted again for this\n\t\t * repository.)\n\t\t */\n\t\treturn 0;\n\n\tobj_dir = r->objects->objectdir;\n\tprepare_commit_graph_one(r, obj_dir);\n\tprepare_alt_odb(r);\n\tfor (alt = r->objects->alt_odb_list;\n\t     !r->objects->commit_graph && alt;\n\t     alt = alt->next)\n\t\tprepare_commit_graph_one(r, alt->path);\n\treturn !!r->objects->commit_graph;\n}\n\nstatic void close_commit_graph(void)\n{\n\tfree_commit_graph(the_repository->objects->commit_graph);\n\tthe_repository->objects->commit_graph = NULL;\n}\n\nstatic int bsearch_graph(struct commit_graph *g, struct object_id *oid, uint32_t *pos)\n{\n\treturn bsearch_hash(oid->hash, g->chunk_oid_fanout,\n\t\t\t    g->chunk_oid_lookup, g->hash_len, pos);\n}\n\nstatic struct commit_list **insert_parent_or_die(struct commit_graph *g,\n\t\t\t\t\t\t uint64_t pos,\n\t\t\t\t\t\t struct commit_list **pptr)\n{\n\tstruct commit *c;\n\tstruct object_id oid;\n\n\tif (pos >= g->num_commits)\n\t\tdie(\"invalid parent position %\"PRIu64, pos);\n\n\thashcpy(oid.hash, g->chunk_oid_lookup + g->hash_len * pos);\n\tc = lookup_commit(the_repository, &oid);\n\tif (!c)\n\t\tdie(_(\"could not find commit %s\"), oid_to_hex(&oid));\n\tc->graph_pos = pos;\n\treturn &commit_list_insert(c, pptr)->next;\n}\n\nstatic void fill_commit_graph_info(struct commit *item, struct commit_graph *g, uint32_t pos)\n{\n\tconst unsigned char *commit_data = g->chunk_commit_data + GRAPH_DATA_WIDTH * pos;\n\titem->graph_pos = pos;\n\titem->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n}\n\nstatic int fill_commit_in_graph(struct commit *item, struct commit_graph *g, uint32_t pos)\n{\n\tuint32_t edge_value;\n\tuint32_t *parent_data_ptr;\n\tuint64_t date_low, date_high;\n\tstruct commit_list **pptr;\n\tconst unsigned char *commit_data = g->chunk_commit_data + (g->hash_len + 16) * pos;\n\n\titem->object.parsed = 1;\n\titem->graph_pos = pos;\n\n\titem->maybe_tree = NULL;\n\n\tdate_high = get_be32(commit_data + g->hash_len + 8) & 0x3;\n\tdate_low = get_be32(commit_data + g->hash_len + 12);\n\titem->date = (timestamp_t)((date_high << 32) | date_low);\n\n\titem->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n\n\tpptr = &item->parents;\n\n\tedge_value = get_be32(commit_data + g->hash_len);\n\tif (edge_value == GRAPH_PARENT_NONE)\n\t\treturn 1;\n\tpptr = insert_parent_or_die(g, edge_value, pptr);\n\n\tedge_value = get_be32(commit_data + g->hash_len + 4);\n\tif (edge_value == GRAPH_PARENT_NONE)\n\t\treturn 1;\n\tif (!(edge_value & GRAPH_OCTOPUS_EDGES_NEEDED)) {\n\t\tpptr = insert_parent_or_die(g, edge_value, pptr);\n\t\treturn 1;\n\t}\n\n\tparent_data_ptr = (uint32_t*)(g->chunk_large_edges +\n\t\t\t  4 * (uint64_t)(edge_value & GRAPH_EDGE_LAST_MASK));\n\tdo {\n\t\tedge_value = get_be32(parent_data_ptr);\n\t\tpptr = insert_parent_or_die(g,\n\t\t\t\t\t    edge_value & GRAPH_EDGE_LAST_MASK,\n\t\t\t\t\t    pptr);\n\t\tparent_data_ptr++;\n\t} while (!(edge_value & GRAPH_LAST_EDGE));\n\n\treturn 1;\n}\n\nstatic int find_commit_in_graph(struct commit *item, struct commit_graph *g, uint32_t *pos)\n{\n\tif (item->graph_pos != COMMIT_NOT_FROM_GRAPH) {\n\t\t*pos = item->graph_pos;\n\t\treturn 1;\n\t} else {\n\t\treturn bsearch_graph(g, &(item->object.oid), pos);\n\t}\n}\n\nstatic int parse_commit_in_graph_one(struct commit_graph *g, struct commit *item)\n{\n\tuint32_t pos;\n\n\tif (item->object.parsed)\n\t\treturn 1;\n\n\tif (find_commit_in_graph(item, g, &pos))\n\t\treturn fill_commit_in_graph(item, g, pos);\n\n\treturn 0;\n}\n\nint parse_commit_in_graph(struct repository *r, struct commit *item)\n{\n\tif (!prepare_commit_graph(r))\n\t\treturn 0;\n\treturn parse_commit_in_graph_one(r->objects->commit_graph, item);\n}\n\nvoid load_commit_graph_info(struct repository *r, struct commit *item)\n{\n\tuint32_t pos;\n\tif (!prepare_commit_graph(r))\n\t\treturn;\n\tif (find_commit_in_graph(item, r->objects->commit_graph, &pos))\n\t\tfill_commit_graph_info(item, r->objects->commit_graph, pos);\n}\n\nstatic struct tree *load_tree_for_commit(struct commit_graph *g, struct commit *c)\n{\n\tstruct object_id oid;\n\tconst unsigned char *commit_data = g->chunk_commit_data +\n\t\t\t\t\t   GRAPH_DATA_WIDTH * (c->graph_pos);\n\n\thashcpy(oid.hash, commit_data);\n\tc->maybe_tree = lookup_tree(the_repository, &oid);\n\n\treturn c->maybe_tree;\n}\n\nstatic struct tree *get_commit_tree_in_graph_one(struct commit_graph *g,\n\t\t\t\t\t\t const struct commit *c)\n{\n\tif (c->maybe_tree)\n\t\treturn c->maybe_tree;\n\tif (c->graph_pos == COMMIT_NOT_FROM_GRAPH)\n\t\tBUG(\"get_commit_tree_in_graph_one called from non-commit-graph commit\");\n\n\treturn load_tree_for_commit(g, (struct commit *)c);\n}\n\nstruct tree *get_commit_tree_in_graph(struct repository *r, const struct commit *c)\n{\n\treturn get_commit_tree_in_graph_one(r->objects->commit_graph, c);\n}\n\nstatic void write_graph_chunk_fanout(struct hashfile *f,\n\t\t\t\t     struct commit **commits,\n\t\t\t\t     int nr_commits)\n{\n\tint i, count = 0;\n\tstruct commit **list = commits;\n\n\t/*\n\t * Write the first-level table (the list is sorted,\n\t * but we use a 256-entry lookup to be able to avoid\n\t * having to do eight extra binary search iterations).\n\t */\n\tfor (i = 0; i < 256; i++) {\n\t\twhile (count < nr_commits) {\n\t\t\tif ((*list)->object.oid.hash[0] != i)\n\t\t\t\tbreak;\n\t\t\tcount++;\n\t\t\tlist++;\n\t\t}\n\n\t\thashwrite_be32(f, count);\n\t}\n}\n\nstatic void write_graph_chunk_oids(struct hashfile *f, int hash_len,\n\t\t\t\t   struct commit **commits, int nr_commits)\n{\n\tstruct commit **list = commits;\n\tint count;\n\tfor (count = 0; count < nr_commits; count++, list++)\n\t\thashwrite(f, (*list)->object.oid.hash, (int)hash_len);\n}\n\nstatic const unsigned char *commit_to_sha1(size_t index, void *table)\n{\n\tstruct commit **commits = table;\n\treturn commits[index]->object.oid.hash;\n}\n\nstatic void write_graph_chunk_data(struct hashfile *f, int hash_len,\n\t\t\t\t   struct commit **commits, int nr_commits)\n{\n\tstruct commit **list = commits;\n\tstruct commit **last = commits + nr_commits;\n\tuint32_t num_extra_edges = 0;\n\n\twhile (list < last) {\n\t\tstruct commit_list *parent;\n\t\tint edge_value;\n\t\tuint32_t packedDate[2];\n\n\t\tparse_commit(*list);\n\t\thashwrite(f, get_commit_tree_oid(*list)->hash, hash_len);\n\n\t\tparent = (*list)->parents;\n\n\t\tif (!parent)\n\t\t\tedge_value = GRAPH_PARENT_NONE;\n\t\telse {\n\t\t\tedge_value = sha1_pos(parent->item->object.oid.hash,\n\t\t\t\t\t      commits,\n\t\t\t\t\t      nr_commits,\n\t\t\t\t\t      commit_to_sha1);\n\n\t\t\tif (edge_value < 0)\n\t\t\t\tedge_value = GRAPH_PARENT_MISSING;\n\t\t}\n\n\t\thashwrite_be32(f, edge_value);\n\n\t\tif (parent)\n\t\t\tparent = parent->next;\n\n\t\tif (!parent)\n\t\t\tedge_value = GRAPH_PARENT_NONE;\n\t\telse if (parent->next)\n\t\t\tedge_value = GRAPH_OCTOPUS_EDGES_NEEDED | num_extra_edges;\n\t\telse {\n\t\t\tedge_value = sha1_pos(parent->item->object.oid.hash,\n\t\t\t\t\t      commits,\n\t\t\t\t\t      nr_commits,\n\t\t\t\t\t      commit_to_sha1);\n\t\t\tif (edge_value < 0)\n\t\t\t\tedge_value = GRAPH_PARENT_MISSING;\n\t\t}\n\n\t\thashwrite_be32(f, edge_value);\n\n\t\tif (edge_value & GRAPH_OCTOPUS_EDGES_NEEDED) {\n\t\t\tdo {\n\t\t\t\tnum_extra_edges++;\n\t\t\t\tparent = parent->next;\n\t\t\t} while (parent);\n\t\t}\n\n\t\tif (sizeof((*list)->date) > 4)\n\t\t\tpackedDate[0] = htonl(((*list)->date >> 32) & 0x3);\n\t\telse\n\t\t\tpackedDate[0] = 0;\n\n\t\tpackedDate[0] |= htonl((*list)->generation << 2);\n\n\t\tpackedDate[1] = htonl((*list)->date);\n\t\thashwrite(f, packedDate, 8);\n\n\t\tlist++;\n\t}\n}\n\nstatic void write_graph_chunk_large_edges(struct hashfile *f,\n\t\t\t\t\t  struct commit **commits,\n\t\t\t\t\t  int nr_commits)\n{\n\tstruct commit **list = commits;\n\tstruct commit **last = commits + nr_commits;\n\tstruct commit_list *parent;\n\n\twhile (list < last) {\n\t\tint num_parents = 0;\n\t\tfor (parent = (*list)->parents; num_parents < 3 && parent;\n\t\t     parent = parent->next)\n\t\t\tnum_parents++;\n\n\t\tif (num_parents <= 2) {\n\t\t\tlist++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Since num_parents > 2, this initializer is safe. */\n\t\tfor (parent = (*list)->parents->next; parent; parent = parent->next) {\n\t\t\tint edge_value = sha1_pos(parent->item->object.oid.hash,\n\t\t\t\t\t\t  commits,\n\t\t\t\t\t\t  nr_commits,\n\t\t\t\t\t\t  commit_to_sha1);\n\n\t\t\tif (edge_value < 0)\n\t\t\t\tedge_value = GRAPH_PARENT_MISSING;\n\t\t\telse if (!parent->next)\n\t\t\t\tedge_value |= GRAPH_LAST_EDGE;\n\n\t\t\thashwrite_be32(f, edge_value);\n\t\t}\n\n\t\tlist++;\n\t}\n}\n\nstatic int commit_compare(const void *_a, const void *_b)\n{\n\tconst struct object_id *a = (const struct object_id *)_a;\n\tconst struct object_id *b = (const struct object_id *)_b;\n\treturn oidcmp(a, b);\n}\n\nstruct packed_commit_list {\n\tstruct commit **list;\n\tint nr;\n\tint alloc;\n};\n\nstruct packed_oid_list {\n\tstruct object_id *list;\n\tint nr;\n\tint alloc;\n};\n\nstatic int add_packed_commits(const struct object_id *oid,\n\t\t\t      struct packed_git *pack,\n\t\t\t      uint32_t pos,\n\t\t\t      void *data)\n{\n\tstruct packed_oid_list *list = (struct packed_oid_list*)data;\n\tenum object_type type;\n\toff_t offset = nth_packed_object_offset(pack, pos);\n\tstruct object_info oi = OBJECT_INFO_INIT;\n\n\toi.typep = &type;\n\tif (packed_object_info(the_repository, pack, offset, &oi) < 0)\n\t\tdie(_(\"unable to get type of object %s\"), oid_to_hex(oid));\n\n\tif (type != OBJ_COMMIT)\n\t\treturn 0;\n\n\tALLOC_GROW(list->list, list->nr + 1, list->alloc);\n\toidcpy(&(list->list[list->nr]), oid);\n\tlist->nr++;\n\n\treturn 0;\n}\n\nstatic void add_missing_parents(struct packed_oid_list *oids, struct commit *commit)\n{\n\tstruct commit_list *parent;\n\tfor (parent = commit->parents; parent; parent = parent->next) {\n\t\tif (!(parent->item->object.flags & UNINTERESTING)) {\n\t\t\tALLOC_GROW(oids->list, oids->nr + 1, oids->alloc);\n\t\t\toidcpy(&oids->list[oids->nr], &(parent->item->object.oid));\n\t\t\toids->nr++;\n\t\t\tparent->item->object.flags |= UNINTERESTING;\n\t\t}\n\t}\n}\n\nstatic void close_reachable(struct packed_oid_list *oids)\n{\n\tint i;\n\tstruct commit *commit;\n\n\tfor (i = 0; i < oids->nr; i++) {\n\t\tcommit = lookup_commit(the_repository, &oids->list[i]);\n\t\tif (commit)\n\t\t\tcommit->object.flags |= UNINTERESTING;\n\t}\n\n\t/*\n\t * As this loop runs, oids->nr may grow, but not more\n\t * than the number of missing commits in the reachable\n\t * closure.\n\t */\n\tfor (i = 0; i < oids->nr; i++) {\n\t\tcommit = lookup_commit(the_repository, &oids->list[i]);\n\n\t\tif (commit && !parse_commit(commit))\n\t\t\tadd_missing_parents(oids, commit);\n\t}\n\n\tfor (i = 0; i < oids->nr; i++) {\n\t\tcommit = lookup_commit(the_repository, &oids->list[i]);\n\n\t\tif (commit)\n\t\t\tcommit->object.flags &= ~UNINTERESTING;\n\t}\n}\n\nstatic void compute_generation_numbers(struct packed_commit_list* commits)\n{\n\tint i;\n\tstruct commit_list *list = NULL;\n\n\tfor (i = 0; i < commits->nr; i++) {\n\t\tif (commits->list[i]->generation != GENERATION_NUMBER_INFINITY &&\n\t\t    commits->list[i]->generation != GENERATION_NUMBER_ZERO)\n\t\t\tcontinue;\n\n\t\tcommit_list_insert(commits->list[i], &list);\n\t\twhile (list) {\n\t\t\tstruct commit *current = list->item;\n\t\t\tstruct commit_list *parent;\n\t\t\tint all_parents_computed = 1;\n\t\t\tuint32_t max_generation = 0;\n\n\t\t\tfor (parent = current->parents; parent; parent = parent->next) {\n\t\t\t\tif (parent->item->generation == GENERATION_NUMBER_INFINITY ||\n\t\t\t\t    parent->item->generation == GENERATION_NUMBER_ZERO) {\n\t\t\t\t\tall_parents_computed = 0;\n\t\t\t\t\tcommit_list_insert(parent->item, &list);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (parent->item->generation > max_generation) {\n\t\t\t\t\tmax_generation = parent->item->generation;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (all_parents_computed) {\n\t\t\t\tcurrent->generation = max_generation + 1;\n\t\t\t\tpop_commit(&list);\n\n\t\t\t\tif (current->generation > GENERATION_NUMBER_MAX)\n\t\t\t\t\tcurrent->generation = GENERATION_NUMBER_MAX;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int add_ref_to_list(const char *refname,\n\t\t\t   const struct object_id *oid,\n\t\t\t   int flags, void *cb_data)\n{\n\tstruct string_list *list = (struct string_list *)cb_data;\n\n\tstring_list_append(list, oid_to_hex(oid));\n\treturn 0;\n}\n\nvoid write_commit_graph_reachable(const char *obj_dir, int append)\n{\n\tstruct string_list list;\n\n\tstring_list_init(&list, 1);\n\tfor_each_ref(add_ref_to_list, &list);\n\twrite_commit_graph(obj_dir, NULL, &list, append);\n}\n\nvoid write_commit_graph(const char *obj_dir,\n\t\t\tstruct string_list *pack_indexes,\n\t\t\tstruct string_list *commit_hex,\n\t\t\tint append)\n{\n\tstruct packed_oid_list oids;\n\tstruct packed_commit_list commits;\n\tstruct hashfile *f;\n\tuint32_t i, count_distinct = 0;\n\tchar *graph_name;\n\tstruct lock_file lk = LOCK_INIT;\n\tuint32_t chunk_ids[5];\n\tuint64_t chunk_offsets[5];\n\tint num_chunks;\n\tint num_extra_edges;\n\tstruct commit_list *parent;\n\n\toids.nr = 0;\n\toids.alloc = approximate_object_count() / 4;\n\n\tif (append) {\n\t\tprepare_commit_graph_one(the_repository, obj_dir);\n\t\tif (the_repository->objects->commit_graph)\n\t\t\toids.alloc += the_repository->objects->commit_graph->num_commits;\n\t}\n\n\tif (oids.alloc < 1024)\n\t\toids.alloc = 1024;\n\tALLOC_ARRAY(oids.list, oids.alloc);\n\n\tif (append && the_repository->objects->commit_graph) {\n\t\tstruct commit_graph *commit_graph =\n\t\t\tthe_repository->objects->commit_graph;\n\t\tfor (i = 0; i < commit_graph->num_commits; i++) {\n\t\t\tconst unsigned char *hash = commit_graph->chunk_oid_lookup +\n\t\t\t\tcommit_graph->hash_len * i;\n\t\t\thashcpy(oids.list[oids.nr++].hash, hash);\n\t\t}\n\t}\n\n\tif (pack_indexes) {\n\t\tstruct strbuf packname = STRBUF_INIT;\n\t\tint dirlen;\n\t\tstrbuf_addf(&packname, \"%s/pack/\", obj_dir);\n\t\tdirlen = packname.len;\n\t\tfor (i = 0; i < pack_indexes->nr; i++) {\n\t\t\tstruct packed_git *p;\n\t\t\tstrbuf_setlen(&packname, dirlen);\n\t\t\tstrbuf_addstr(&packname, pack_indexes->items[i].string);\n\t\t\tp = add_packed_git(packname.buf, packname.len, 1);\n\t\t\tif (!p)\n\t\t\t\tdie(_(\"error adding pack %s\"), packname.buf);\n\t\t\tif (open_pack_index(p))\n\t\t\t\tdie(_(\"error opening index for %s\"), packname.buf);\n\t\t\tfor_each_object_in_pack(p, add_packed_commits, &oids);\n\t\t\tclose_pack(p);\n\t\t}\n\t\tstrbuf_release(&packname);\n\t}\n\n\tif (commit_hex) {\n\t\tfor (i = 0; i < commit_hex->nr; i++) {\n\t\t\tconst char *end;\n\t\t\tstruct object_id oid;\n\t\t\tstruct commit *result;\n\n\t\t\tif (commit_hex->items[i].string &&\n\t\t\t    parse_oid_hex(commit_hex->items[i].string, &oid, &end))\n\t\t\t\tcontinue;\n\n\t\t\tresult = lookup_commit_reference_gently(the_repository, &oid, 1);\n\n\t\t\tif (result) {\n\t\t\t\tALLOC_GROW(oids.list, oids.nr + 1, oids.alloc);\n\t\t\t\toidcpy(&oids.list[oids.nr], &(result->object.oid));\n\t\t\t\toids.nr++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!pack_indexes && !commit_hex)\n\t\tfor_each_packed_object(add_packed_commits, &oids, 0);\n\n\tclose_reachable(&oids);\n\n\tQSORT(oids.list, oids.nr, commit_compare);\n\n\tcount_distinct = 1;\n\tfor (i = 1; i < oids.nr; i++) {\n\t\tif (oidcmp(&oids.list[i-1], &oids.list[i]))\n\t\t\tcount_distinct++;\n\t}\n\n\tif (count_distinct >= GRAPH_PARENT_MISSING)\n\t\tdie(_(\"the commit graph format cannot write %d commits\"), count_distinct);\n\n\tcommits.nr = 0;\n\tcommits.alloc = count_distinct;\n\tALLOC_ARRAY(commits.list, commits.alloc);\n\n\tnum_extra_edges = 0;\n\tfor (i = 0; i < oids.nr; i++) {\n\t\tint num_parents = 0;\n\t\tif (i > 0 && !oidcmp(&oids.list[i-1], &oids.list[i]))\n\t\t\tcontinue;\n\n\t\tcommits.list[commits.nr] = lookup_commit(the_repository, &oids.list[i]);\n\t\tparse_commit(commits.list[commits.nr]);\n\n\t\tfor (parent = commits.list[commits.nr]->parents;\n\t\t     parent; parent = parent->next)\n\t\t\tnum_parents++;\n\n\t\tif (num_parents > 2)\n\t\t\tnum_extra_edges += num_parents - 1;\n\n\t\tcommits.nr++;\n\t}\n\tnum_chunks = num_extra_edges ? 4 : 3;\n\n\tif (commits.nr >= GRAPH_PARENT_MISSING)\n\t\tdie(_(\"too many commits to write graph\"));\n\n\tcompute_generation_numbers(&commits);\n\n\tgraph_name = get_commit_graph_filename(obj_dir);\n\tif (safe_create_leading_directories(graph_name))\n\t\tdie_errno(_(\"unable to create leading directories of %s\"),\n\t\t\t  graph_name);\n\n\thold_lock_file_for_update(&lk, graph_name, LOCK_DIE_ON_ERROR);\n\tf = hashfd(lk.tempfile->fd, lk.tempfile->filename.buf);\n\n\thashwrite_be32(f, GRAPH_SIGNATURE);\n\n\thashwrite_u8(f, GRAPH_VERSION);\n\thashwrite_u8(f, GRAPH_OID_VERSION);\n\thashwrite_u8(f, num_chunks);\n\thashwrite_u8(f, 0); /* unused padding byte */\n\n\tchunk_ids[0] = GRAPH_CHUNKID_OIDFANOUT;\n\tchunk_ids[1] = GRAPH_CHUNKID_OIDLOOKUP;\n\tchunk_ids[2] = GRAPH_CHUNKID_DATA;\n\tif (num_extra_edges)\n\t\tchunk_ids[3] = GRAPH_CHUNKID_LARGEEDGES;\n\telse\n\t\tchunk_ids[3] = 0;\n\tchunk_ids[4] = 0;\n\n\tchunk_offsets[0] = 8 + (num_chunks + 1) * GRAPH_CHUNKLOOKUP_WIDTH;\n\tchunk_offsets[1] = chunk_offsets[0] + GRAPH_FANOUT_SIZE;\n\tchunk_offsets[2] = chunk_offsets[1] + GRAPH_OID_LEN * commits.nr;\n\tchunk_offsets[3] = chunk_offsets[2] + (GRAPH_OID_LEN + 16) * commits.nr;\n\tchunk_offsets[4] = chunk_offsets[3] + 4 * num_extra_edges;\n\n\tfor (i = 0; i <= num_chunks; i++) {\n\t\tuint32_t chunk_write[3];\n\n\t\tchunk_write[0] = htonl(chunk_ids[i]);\n\t\tchunk_write[1] = htonl(chunk_offsets[i] >> 32);\n\t\tchunk_write[2] = htonl(chunk_offsets[i] & 0xffffffff);\n\t\thashwrite(f, chunk_write, 12);\n\t}\n\n\twrite_graph_chunk_fanout(f, commits.list, commits.nr);\n\twrite_graph_chunk_oids(f, GRAPH_OID_LEN, commits.list, commits.nr);\n\twrite_graph_chunk_data(f, GRAPH_OID_LEN, commits.list, commits.nr);\n\twrite_graph_chunk_large_edges(f, commits.list, commits.nr);\n\n\tclose_commit_graph();\n\tfinalize_hashfile(f, NULL, CSUM_HASH_IN_STREAM | CSUM_FSYNC);\n\tcommit_lock_file(&lk);\n\n\tfree(oids.list);\n\toids.alloc = 0;\n\toids.nr = 0;\n}\n\n#define VERIFY_COMMIT_GRAPH_ERROR_HASH 2\nstatic int verify_commit_graph_error;\n\nstatic void graph_report(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tverify_commit_graph_error = 1;\n\tva_start(ap, fmt);\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \"\\n\");\n\tva_end(ap);\n}\n\n#define GENERATION_ZERO_EXISTS 1\n#define GENERATION_NUMBER_EXISTS 2\n\nint verify_commit_graph(struct repository *r, struct commit_graph *g)\n{\n\tuint32_t i, cur_fanout_pos = 0;\n\tstruct object_id prev_oid, cur_oid, checksum;\n\tint generation_zero = 0;\n\tstruct hashfile *f;\n\tint devnull;\n\n\tif (!g) {\n\t\tgraph_report(\"no commit-graph file loaded\");\n\t\treturn 1;\n\t}\n\n\tverify_commit_graph_error = 0;\n\n\tif (!g->chunk_oid_fanout)\n\t\tgraph_report(\"commit-graph is missing the OID Fanout chunk\");\n\tif (!g->chunk_oid_lookup)\n\t\tgraph_report(\"commit-graph is missing the OID Lookup chunk\");\n\tif (!g->chunk_commit_data)\n\t\tgraph_report(\"commit-graph is missing the Commit Data chunk\");\n\n\tif (verify_commit_graph_error)\n\t\treturn verify_commit_graph_error;\n\n\tdevnull = open(\"/dev/null\", O_WRONLY);\n\tf = hashfd(devnull, NULL);\n\thashwrite(f, g->data, g->data_len - g->hash_len);\n\tfinalize_hashfile(f, checksum.hash, CSUM_CLOSE);\n\tif (hashcmp(checksum.hash, g->data + g->data_len - g->hash_len)) {\n\t\tgraph_report(_(\"the commit-graph file has incorrect checksum and is likely corrupt\"));\n\t\tverify_commit_graph_error = VERIFY_COMMIT_GRAPH_ERROR_HASH;\n\t}\n\n\tfor (i = 0; i < g->num_commits; i++) {\n\t\tstruct commit *graph_commit;\n\n\t\thashcpy(cur_oid.hash, g->chunk_oid_lookup + g->hash_len * i);\n\n\t\tif (i && oidcmp(&prev_oid, &cur_oid) >= 0)\n\t\t\tgraph_report(\"commit-graph has incorrect OID order: %s then %s\",\n\t\t\t\t     oid_to_hex(&prev_oid),\n\t\t\t\t     oid_to_hex(&cur_oid));\n\n\t\toidcpy(&prev_oid, &cur_oid);\n\n\t\twhile (cur_oid.hash[0] > cur_fanout_pos) {\n\t\t\tuint32_t fanout_value = get_be32(g->chunk_oid_fanout + cur_fanout_pos);\n\n\t\t\tif (i != fanout_value)\n\t\t\t\tgraph_report(\"commit-graph has incorrect fanout value: fanout[%d] = %u != %u\",\n\t\t\t\t\t     cur_fanout_pos, fanout_value, i);\n\t\t\tcur_fanout_pos++;\n\t\t}\n\n\t\tgraph_commit = lookup_commit(r, &cur_oid);\n\t\tif (!parse_commit_in_graph_one(g, graph_commit))\n\t\t\tgraph_report(\"failed to parse %s from commit-graph\",\n\t\t\t\t     oid_to_hex(&cur_oid));\n\t}\n\n\twhile (cur_fanout_pos < 256) {\n\t\tuint32_t fanout_value = get_be32(g->chunk_oid_fanout + cur_fanout_pos);\n\n\t\tif (g->num_commits != fanout_value)\n\t\t\tgraph_report(\"commit-graph has incorrect fanout value: fanout[%d] = %u != %u\",\n\t\t\t\t     cur_fanout_pos, fanout_value, i);\n\n\t\tcur_fanout_pos++;\n\t}\n\n\tif (verify_commit_graph_error & ~VERIFY_COMMIT_GRAPH_ERROR_HASH)\n\t\treturn verify_commit_graph_error;\n\n\tfor (i = 0; i < g->num_commits; i++) {\n\t\tstruct commit *graph_commit, *odb_commit;\n\t\tstruct commit_list *graph_parents, *odb_parents;\n\t\tuint32_t max_generation = 0;\n\n\t\thashcpy(cur_oid.hash, g->chunk_oid_lookup + g->hash_len * i);\n\n\t\tgraph_commit = lookup_commit(r, &cur_oid);\n\t\todb_commit = (struct commit *)create_object(r, cur_oid.hash, alloc_commit_node(r));\n\t\tif (parse_commit_internal(odb_commit, 0, 0)) {\n\t\t\tgraph_report(\"failed to parse %s from object database\",\n\t\t\t\t     oid_to_hex(&cur_oid));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (oidcmp(&get_commit_tree_in_graph_one(g, graph_commit)->object.oid,\n\t\t\t   get_commit_tree_oid(odb_commit)))\n\t\t\tgraph_report(\"root tree OID for commit %s in commit-graph is %s != %s\",\n\t\t\t\t     oid_to_hex(&cur_oid),\n\t\t\t\t     oid_to_hex(get_commit_tree_oid(graph_commit)),\n\t\t\t\t     oid_to_hex(get_commit_tree_oid(odb_commit)));\n\n\t\tgraph_parents = graph_commit->parents;\n\t\todb_parents = odb_commit->parents;\n\n\t\twhile (graph_parents) {\n\t\t\tif (odb_parents == NULL) {\n\t\t\t\tgraph_report(\"commit-graph parent list for commit %s is too long\",\n\t\t\t\t\t     oid_to_hex(&cur_oid));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (oidcmp(&graph_parents->item->object.oid, &odb_parents->item->object.oid))\n\t\t\t\tgraph_report(\"commit-graph parent for %s is %s != %s\",\n\t\t\t\t\t     oid_to_hex(&cur_oid),\n\t\t\t\t\t     oid_to_hex(&graph_parents->item->object.oid),\n\t\t\t\t\t     oid_to_hex(&odb_parents->item->object.oid));\n\n\t\t\tif (graph_parents->item->generation > max_generation)\n\t\t\t\tmax_generation = graph_parents->item->generation;\n\n\t\t\tgraph_parents = graph_parents->next;\n\t\t\todb_parents = odb_parents->next;\n\t\t}\n\n\t\tif (odb_parents != NULL)\n\t\t\tgraph_report(\"commit-graph parent list for commit %s terminates early\",\n\t\t\t\t     oid_to_hex(&cur_oid));\n\n\t\tif (!graph_commit->generation) {\n\t\t\tif (generation_zero == GENERATION_NUMBER_EXISTS)\n\t\t\t\tgraph_report(\"commit-graph has generation number zero for commit %s, but non-zero elsewhere\",\n\t\t\t\t\t     oid_to_hex(&cur_oid));\n\t\t\tgeneration_zero = GENERATION_ZERO_EXISTS;\n\t\t} else if (generation_zero == GENERATION_ZERO_EXISTS)\n\t\t\tgraph_report(\"commit-graph has non-zero generation number for commit %s, but zero elsewhere\",\n\t\t\t\t     oid_to_hex(&cur_oid));\n\n\t\tif (generation_zero == GENERATION_ZERO_EXISTS)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If one of our parents has generation GENERATION_NUMBER_MAX, then\n\t\t * our generation is also GENERATION_NUMBER_MAX. Decrement to avoid\n\t\t * extra logic in the following condition.\n\t\t */\n\t\tif (max_generation == GENERATION_NUMBER_MAX)\n\t\t\tmax_generation--;\n\n\t\tif (graph_commit->generation != max_generation + 1)\n\t\t\tgraph_report(\"commit-graph generation for commit %s is %u != %u\",\n\t\t\t\t     oid_to_hex(&cur_oid),\n\t\t\t\t     graph_commit->generation,\n\t\t\t\t     max_generation + 1);\n\n\t\tif (graph_commit->date != odb_commit->date)\n\t\t\tgraph_report(\"commit date for commit %s in commit-graph is %\"PRItime\" != %\"PRItime,\n\t\t\t\t     oid_to_hex(&cur_oid),\n\t\t\t\t     graph_commit->date,\n\t\t\t\t     odb_commit->date);\n\t}\n\n\treturn verify_commit_graph_error;\n}\n\nvoid free_commit_graph(struct commit_graph *g)\n{\n\tif (!g)\n\t\treturn;\n\tif (g->graph_fd >= 0) {\n\t\tmunmap((void *)g->data, g->data_len);\n\t\tg->data = NULL;\n\t\tclose(g->graph_fd);\n\t}\n\tfree(g);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0034740c26b48eda147d45258505df278b84cc0a",
  "sha1_ok": true,
  "size": 27979
}
