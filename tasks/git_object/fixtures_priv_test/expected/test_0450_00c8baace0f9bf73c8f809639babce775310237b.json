{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAic2lnY2hhaW4uaCIKCiNpZm5kZWYgREVGQVVMVF9QQUdFUgojZGVmaW5lIERFRkFVTFRfUEFHRVIgImxlc3MiCiNlbmRpZgoKc3RhdGljIHN0cnVjdCBjaGlsZF9wcm9jZXNzIHBhZ2VyX3Byb2Nlc3MgPSBDSElMRF9QUk9DRVNTX0lOSVQ7CnN0YXRpYyBjb25zdCBjaGFyICpwYWdlcl9wcm9ncmFtOwoKc3RhdGljIHZvaWQgd2FpdF9mb3JfcGFnZXIoaW50IGluX3NpZ25hbCkKewoJaWYgKCFpbl9zaWduYWwpIHsKCQlmZmx1c2goc3Rkb3V0KTsKCQlmZmx1c2goc3RkZXJyKTsKCX0KCS8qIHNpZ25hbCBFT0YgdG8gcGFnZXIgKi8KCWNsb3NlKDEpOwoJY2xvc2UoMik7CglpZiAoaW5fc2lnbmFsKQoJCWZpbmlzaF9jb21tYW5kX2luX3NpZ25hbCgmcGFnZXJfcHJvY2Vzcyk7CgllbHNlCgkJZmluaXNoX2NvbW1hbmQoJnBhZ2VyX3Byb2Nlc3MpOwp9CgpzdGF0aWMgdm9pZCB3YWl0X2Zvcl9wYWdlcl9hdGV4aXQodm9pZCkKewoJd2FpdF9mb3JfcGFnZXIoMCk7Cn0KCnN0YXRpYyB2b2lkIHdhaXRfZm9yX3BhZ2VyX3NpZ25hbChpbnQgc2lnbm8pCnsKCXdhaXRfZm9yX3BhZ2VyKDEpOwoJc2lnY2hhaW5fcG9wKHNpZ25vKTsKCXJhaXNlKHNpZ25vKTsKfQoKc3RhdGljIGludCBjb3JlX3BhZ2VyX2NvbmZpZyhjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlLCB2b2lkICpkYXRhKQp7CglpZiAoIXN0cmNtcCh2YXIsICJjb3JlLnBhZ2VyIikpCgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZwYWdlcl9wcm9ncmFtLCB2YXIsIHZhbHVlKTsKCXJldHVybiAwOwp9Cgpjb25zdCBjaGFyICpnaXRfcGFnZXIoaW50IHN0ZG91dF9pc190dHkpCnsKCWNvbnN0IGNoYXIgKnBhZ2VyOwoKCWlmICghc3Rkb3V0X2lzX3R0eSkKCQlyZXR1cm4gTlVMTDsKCglwYWdlciA9IGdldGVudigiR0lUX1BBR0VSIik7CglpZiAoIXBhZ2VyKSB7CgkJaWYgKCFwYWdlcl9wcm9ncmFtKQoJCQlnaXRfY29uZmlnKGNvcmVfcGFnZXJfY29uZmlnLCBOVUxMKTsKCQlwYWdlciA9IHBhZ2VyX3Byb2dyYW07Cgl9CglpZiAoIXBhZ2VyKQoJCXBhZ2VyID0gZ2V0ZW52KCJQQUdFUiIpOwoJaWYgKCFwYWdlcikKCQlwYWdlciA9IERFRkFVTFRfUEFHRVI7CglpZiAoISpwYWdlciB8fCAhc3RyY21wKHBhZ2VyLCAiY2F0IikpCgkJcGFnZXIgPSBOVUxMOwoKCXJldHVybiBwYWdlcjsKfQoKdm9pZCBwcmVwYXJlX3BhZ2VyX2FyZ3Moc3RydWN0IGNoaWxkX3Byb2Nlc3MgKnBhZ2VyX3Byb2Nlc3MsIGNvbnN0IGNoYXIgKnBhZ2VyKQp7Cglhcmd2X2FycmF5X3B1c2goJnBhZ2VyX3Byb2Nlc3MtPmFyZ3MsIHBhZ2VyKTsKCXBhZ2VyX3Byb2Nlc3MtPnVzZV9zaGVsbCA9IDE7CglpZiAoIWdldGVudigiTEVTUyIpKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmcGFnZXJfcHJvY2Vzcy0+ZW52X2FycmF5LCAiTEVTUz1GUlgiKTsKCWlmICghZ2V0ZW52KCJMViIpKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmcGFnZXJfcHJvY2Vzcy0+ZW52X2FycmF5LCAiTFY9LWMiKTsKfQoKdm9pZCBzZXR1cF9wYWdlcih2b2lkKQp7Cgljb25zdCBjaGFyICpwYWdlciA9IGdpdF9wYWdlcihpc2F0dHkoMSkpOwoKCWlmICghcGFnZXIpCgkJcmV0dXJuOwoKCS8qCgkgKiBmb3JjZSBjb21wdXRpbmcgdGhlIHdpZHRoIG9mIHRoZSB0ZXJtaW5hbCBiZWZvcmUgd2UgcmVkaXJlY3QKCSAqIHRoZSBzdGFuZGFyZCBvdXRwdXQgdG8gdGhlIHBhZ2VyLgoJICovCgkodm9pZCkgdGVybV9jb2x1bW5zKCk7CgoJc2V0ZW52KCJHSVRfUEFHRVJfSU5fVVNFIiwgInRydWUiLCAxKTsKCgkvKiBzcGF3biB0aGUgcGFnZXIgKi8KCXByZXBhcmVfcGFnZXJfYXJncygmcGFnZXJfcHJvY2VzcywgcGFnZXIpOwoJcGFnZXJfcHJvY2Vzcy5pbiA9IC0xOwoJYXJndl9hcnJheV9wdXNoKCZwYWdlcl9wcm9jZXNzLmVudl9hcnJheSwgIkdJVF9QQUdFUl9JTl9VU0UiKTsKCWlmIChzdGFydF9jb21tYW5kKCZwYWdlcl9wcm9jZXNzKSkKCQlyZXR1cm47CgoJLyogb3JpZ2luYWwgcHJvY2VzcyBjb250aW51ZXMsIGJ1dCB3cml0ZXMgdG8gdGhlIHBpcGUgKi8KCWR1cDIocGFnZXJfcHJvY2Vzcy5pbiwgMSk7CglpZiAoaXNhdHR5KDIpKQoJCWR1cDIocGFnZXJfcHJvY2Vzcy5pbiwgMik7CgljbG9zZShwYWdlcl9wcm9jZXNzLmluKTsKCgkvKiB0aGlzIG1ha2VzIHN1cmUgdGhhdCB0aGUgcGFyZW50IHRlcm1pbmF0ZXMgYWZ0ZXIgdGhlIHBhZ2VyICovCglzaWdjaGFpbl9wdXNoX2NvbW1vbih3YWl0X2Zvcl9wYWdlcl9zaWduYWwpOwoJYXRleGl0KHdhaXRfZm9yX3BhZ2VyX2F0ZXhpdCk7Cn0KCmludCBwYWdlcl9pbl91c2Uodm9pZCkKewoJY29uc3QgY2hhciAqZW52OwoJZW52ID0gZ2V0ZW52KCJHSVRfUEFHRVJfSU5fVVNFIik7CglyZXR1cm4gZW52ID8gZ2l0X2NvbmZpZ19ib29sKCJHSVRfUEFHRVJfSU5fVVNFIiwgZW52KSA6IDA7Cn0KCi8qCiAqIFJldHVybiBjYWNoZWQgdmFsdWUgKGlmIHNldCkgb3IgJENPTFVNTlMgZW52aXJvbm1lbnQgdmFyaWFibGUgKGlmCiAqIHNldCBhbmQgcG9zaXRpdmUpIG9yIGlvY3RsKDEsIFRJT0NHV0lOU1opLndzX2NvbCAoaWYgcG9zaXRpdmUpLAogKiBhbmQgZGVmYXVsdCB0byA4MCBpZiBhbGwgZWxzZSBmYWlscy4KICovCmludCB0ZXJtX2NvbHVtbnModm9pZCkKewoJc3RhdGljIGludCB0ZXJtX2NvbHVtbnNfYXRfc3RhcnR1cDsKCgljaGFyICpjb2xfc3RyaW5nOwoJaW50IG5fY29sczsKCglpZiAodGVybV9jb2x1bW5zX2F0X3N0YXJ0dXApCgkJcmV0dXJuIHRlcm1fY29sdW1uc19hdF9zdGFydHVwOwoKCXRlcm1fY29sdW1uc19hdF9zdGFydHVwID0gODA7CgoJY29sX3N0cmluZyA9IGdldGVudigiQ09MVU1OUyIpOwoJaWYgKGNvbF9zdHJpbmcgJiYgKG5fY29scyA9IGF0b2koY29sX3N0cmluZykpID4gMCkKCQl0ZXJtX2NvbHVtbnNfYXRfc3RhcnR1cCA9IG5fY29sczsKI2lmZGVmIFRJT0NHV0lOU1oKCWVsc2UgewoJCXN0cnVjdCB3aW5zaXplIHdzOwoJCWlmICghaW9jdGwoMSwgVElPQ0dXSU5TWiwgJndzKSAmJiB3cy53c19jb2wpCgkJCXRlcm1fY29sdW1uc19hdF9zdGFydHVwID0gd3Mud3NfY29sOwoJfQojZW5kaWYKCglyZXR1cm4gdGVybV9jb2x1bW5zX2F0X3N0YXJ0dXA7Cn0KCi8qCiAqIEhvdyBtYW55IGNvbHVtbnMgZG8gd2UgbmVlZCB0byBzaG93IHRoaXMgbnVtYmVyIGluIGRlY2ltYWw/CiAqLwppbnQgZGVjaW1hbF93aWR0aCh1aW50bWF4X3QgbnVtYmVyKQp7CglpbnQgd2lkdGg7CgoJZm9yICh3aWR0aCA9IDE7IG51bWJlciA+PSAxMDsgd2lkdGgrKykKCQludW1iZXIgLz0gMTA7CglyZXR1cm4gd2lkdGg7Cn0KCi8qIHJldHVybnMgMCBmb3IgIm5vIHBhZ2VyIiwgMSBmb3IgInVzZSBwYWdlciIsIGFuZCAtMSBmb3IgIm5vdCBzcGVjaWZpZWQiICovCmludCBjaGVja19wYWdlcl9jb25maWcoY29uc3QgY2hhciAqY21kKQp7CglpbnQgd2FudCA9IC0xOwoJc3RydWN0IHN0cmJ1ZiBrZXkgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKnZhbHVlID0gTlVMTDsKCXN0cmJ1Zl9hZGRmKCZrZXksICJwYWdlci4lcyIsIGNtZCk7CglpZiAoZ2l0X2NvbmZpZ19rZXlfaXNfdmFsaWQoa2V5LmJ1ZikgJiYKCSAgICAhZ2l0X2NvbmZpZ19nZXRfdmFsdWUoa2V5LmJ1ZiwgJnZhbHVlKSkgewoJCWludCBiID0gZ2l0X2NvbmZpZ19tYXliZV9ib29sKGtleS5idWYsIHZhbHVlKTsKCQlpZiAoYiA+PSAwKQoJCQl3YW50ID0gYjsKCQllbHNlIHsKCQkJd2FudCA9IDE7CgkJCXBhZ2VyX3Byb2dyYW0gPSB4c3RyZHVwKHZhbHVlKTsKCQl9Cgl9CglzdHJidWZfcmVsZWFzZSgma2V5KTsKCXJldHVybiB3YW50Owp9Cg==",
    "text": "#include \"cache.h\"\n#include \"run-command.h\"\n#include \"sigchain.h\"\n\n#ifndef DEFAULT_PAGER\n#define DEFAULT_PAGER \"less\"\n#endif\n\nstatic struct child_process pager_process = CHILD_PROCESS_INIT;\nstatic const char *pager_program;\n\nstatic void wait_for_pager(int in_signal)\n{\n\tif (!in_signal) {\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\t}\n\t/* signal EOF to pager */\n\tclose(1);\n\tclose(2);\n\tif (in_signal)\n\t\tfinish_command_in_signal(&pager_process);\n\telse\n\t\tfinish_command(&pager_process);\n}\n\nstatic void wait_for_pager_atexit(void)\n{\n\twait_for_pager(0);\n}\n\nstatic void wait_for_pager_signal(int signo)\n{\n\twait_for_pager(1);\n\tsigchain_pop(signo);\n\traise(signo);\n}\n\nstatic int core_pager_config(const char *var, const char *value, void *data)\n{\n\tif (!strcmp(var, \"core.pager\"))\n\t\treturn git_config_string(&pager_program, var, value);\n\treturn 0;\n}\n\nconst char *git_pager(int stdout_is_tty)\n{\n\tconst char *pager;\n\n\tif (!stdout_is_tty)\n\t\treturn NULL;\n\n\tpager = getenv(\"GIT_PAGER\");\n\tif (!pager) {\n\t\tif (!pager_program)\n\t\t\tgit_config(core_pager_config, NULL);\n\t\tpager = pager_program;\n\t}\n\tif (!pager)\n\t\tpager = getenv(\"PAGER\");\n\tif (!pager)\n\t\tpager = DEFAULT_PAGER;\n\tif (!*pager || !strcmp(pager, \"cat\"))\n\t\tpager = NULL;\n\n\treturn pager;\n}\n\nvoid prepare_pager_args(struct child_process *pager_process, const char *pager)\n{\n\targv_array_push(&pager_process->args, pager);\n\tpager_process->use_shell = 1;\n\tif (!getenv(\"LESS\"))\n\t\targv_array_push(&pager_process->env_array, \"LESS=FRX\");\n\tif (!getenv(\"LV\"))\n\t\targv_array_push(&pager_process->env_array, \"LV=-c\");\n}\n\nvoid setup_pager(void)\n{\n\tconst char *pager = git_pager(isatty(1));\n\n\tif (!pager)\n\t\treturn;\n\n\t/*\n\t * force computing the width of the terminal before we redirect\n\t * the standard output to the pager.\n\t */\n\t(void) term_columns();\n\n\tsetenv(\"GIT_PAGER_IN_USE\", \"true\", 1);\n\n\t/* spawn the pager */\n\tprepare_pager_args(&pager_process, pager);\n\tpager_process.in = -1;\n\targv_array_push(&pager_process.env_array, \"GIT_PAGER_IN_USE\");\n\tif (start_command(&pager_process))\n\t\treturn;\n\n\t/* original process continues, but writes to the pipe */\n\tdup2(pager_process.in, 1);\n\tif (isatty(2))\n\t\tdup2(pager_process.in, 2);\n\tclose(pager_process.in);\n\n\t/* this makes sure that the parent terminates after the pager */\n\tsigchain_push_common(wait_for_pager_signal);\n\tatexit(wait_for_pager_atexit);\n}\n\nint pager_in_use(void)\n{\n\tconst char *env;\n\tenv = getenv(\"GIT_PAGER_IN_USE\");\n\treturn env ? git_config_bool(\"GIT_PAGER_IN_USE\", env) : 0;\n}\n\n/*\n * Return cached value (if set) or $COLUMNS environment variable (if\n * set and positive) or ioctl(1, TIOCGWINSZ).ws_col (if positive),\n * and default to 80 if all else fails.\n */\nint term_columns(void)\n{\n\tstatic int term_columns_at_startup;\n\n\tchar *col_string;\n\tint n_cols;\n\n\tif (term_columns_at_startup)\n\t\treturn term_columns_at_startup;\n\n\tterm_columns_at_startup = 80;\n\n\tcol_string = getenv(\"COLUMNS\");\n\tif (col_string && (n_cols = atoi(col_string)) > 0)\n\t\tterm_columns_at_startup = n_cols;\n#ifdef TIOCGWINSZ\n\telse {\n\t\tstruct winsize ws;\n\t\tif (!ioctl(1, TIOCGWINSZ, &ws) && ws.ws_col)\n\t\t\tterm_columns_at_startup = ws.ws_col;\n\t}\n#endif\n\n\treturn term_columns_at_startup;\n}\n\n/*\n * How many columns do we need to show this number in decimal?\n */\nint decimal_width(uintmax_t number)\n{\n\tint width;\n\n\tfor (width = 1; number >= 10; width++)\n\t\tnumber /= 10;\n\treturn width;\n}\n\n/* returns 0 for \"no pager\", 1 for \"use pager\", and -1 for \"not specified\" */\nint check_pager_config(const char *cmd)\n{\n\tint want = -1;\n\tstruct strbuf key = STRBUF_INIT;\n\tconst char *value = NULL;\n\tstrbuf_addf(&key, \"pager.%s\", cmd);\n\tif (git_config_key_is_valid(key.buf) &&\n\t    !git_config_get_value(key.buf, &value)) {\n\t\tint b = git_config_maybe_bool(key.buf, value);\n\t\tif (b >= 0)\n\t\t\twant = b;\n\t\telse {\n\t\t\twant = 1;\n\t\t\tpager_program = xstrdup(value);\n\t\t}\n\t}\n\tstrbuf_release(&key);\n\treturn want;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00c8baace0f9bf73c8f809639babce775310237b",
  "sha1_ok": true,
  "size": 3832
}
