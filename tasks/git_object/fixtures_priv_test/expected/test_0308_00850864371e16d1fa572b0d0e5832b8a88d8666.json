{
  "content": {
    "base64": "IyEvYmluL3NoCiMKIyBDb3B5cmlnaHQgKGMpIDIwMDcgQW5keSBQYXJraW5zCiMKIyBBbiBleGFtcGxlIGhvb2sgc2NyaXB0IHRvIG1haWwgb3V0IGNvbW1pdCB1cGRhdGUgaW5mb3JtYXRpb24uICBUaGlzIGhvb2sKIyBzZW5kcyBlbWFpbHMgbGlzdGluZyBuZXcgcmV2aXNpb25zIHRvIHRoZSByZXBvc2l0b3J5IGludHJvZHVjZWQgYnkgdGhlCiMgY2hhbmdlIGJlaW5nIHJlcG9ydGVkLiAgVGhlIHJ1bGUgaXMgdGhhdCAoZm9yIGJyYW5jaCB1cGRhdGVzKSBlYWNoIGNvbW1pdAojIHdpbGwgYXBwZWFyIG9uIG9uZSBlbWFpbCBhbmQgb25lIGVtYWlsIG9ubHkuCiMKIyBUaGlzIGhvb2sgaXMgc3RvcmVkIGluIHRoZSBjb250cmliL2hvb2tzIGRpcmVjdG9yeS4gIFlvdXIgZGlzdHJpYnV0aW9uCiMgd2lsbCBoYXZlIHB1dCB0aGlzIHNvbWV3aGVyZSBzdGFuZGFyZC4gIFlvdSBzaG91bGQgbWFrZSB0aGlzIHNjcmlwdAojIGV4ZWN1dGFibGUgdGhlbiBsaW5rIHRvIGl0IGluIHRoZSByZXBvc2l0b3J5IHlvdSB3b3VsZCBsaWtlIHRvIHVzZSBpdCBpbi4KIyBGb3IgZXhhbXBsZSwgb24gZGViaWFuIHRoZSBob29rIGlzIHN0b3JlZCBpbgojIC91c3Ivc2hhcmUvZG9jL2dpdC1jb3JlL2NvbnRyaWIvaG9va3MvcG9zdC1yZWNlaXZlLWVtYWlsOgojCiMgIGNobW9kIGEreCBwb3N0LXJlY2VpdmUtZW1haWwKIyAgY2QgL3BhdGgvdG8veW91ci9yZXBvc2l0b3J5LmdpdAojICBsbiAtc2YgL3Vzci9zaGFyZS9kb2MvZ2l0LWNvcmUvY29udHJpYi9ob29rcy9wb3N0LXJlY2VpdmUtZW1haWwgaG9va3MvcG9zdC1yZWNlaXZlCiMKIyBUaGlzIGhvb2sgc2NyaXB0IGFzc3VtZXMgaXQgaXMgZW5hYmxlZCBvbiB0aGUgY2VudHJhbCByZXBvc2l0b3J5IG9mIGEKIyBwcm9qZWN0LCB3aXRoIGFsbCB1c2VycyBwdXNoaW5nIG9ubHkgdG8gaXQgYW5kIG5vdCBiZXR3ZWVuIGVhY2ggb3RoZXIuICBJdAojIHdpbGwgc3RpbGwgd29yayBpZiB5b3UgZG9uJ3Qgb3BlcmF0ZSBpbiB0aGF0IHN0eWxlLCBidXQgaXQgd291bGQgYmVjb21lCiMgcG9zc2libGUgZm9yIHRoZSBlbWFpbCB0byBiZSBmcm9tIHNvbWVvbmUgb3RoZXIgdGhhbiB0aGUgcGVyc29uIGRvaW5nIHRoZQojIHB1c2guCiMKIyBUbyBoZWxwIHdpdGggZGVidWdnaW5nIGFuZCB1c2Ugb24gcHJlLXYxLjUuMSBnaXQgc2VydmVycywgdGhpcyBzY3JpcHQgd2lsbAojIGFsc28gb2JleSB0aGUgaW50ZXJmYWNlIG9mIGhvb2tzL3VwZGF0ZSwgdGFraW5nIGl0cyBhcmd1bWVudHMgb24gdGhlCiMgY29tbWFuZCBsaW5lLiAgVW5mb3J0dW5hdGVseSwgaG9va3MvdXBkYXRlIGlzIGNhbGxlZCBvbmNlIGZvciBlYWNoIHJlZi4KIyBUbyBhdm9pZCBmaXJpbmcgb25lIGVtYWlsIHBlciByZWYsIHRoaXMgc2NyaXB0IGp1c3QgcHJpbnRzIGl0cyBvdXRwdXQgdG8KIyB0aGUgc2NyZWVuIHdoZW4gdXNlZCBpbiB0aGlzIG1vZGUuICBUaGUgb3V0cHV0IGNhbiB0aGVuIGJlIHJlZGlyZWN0ZWQgaWYKIyB3YW50ZWQuCiMKIyBDb25maWcKIyAtLS0tLS0KIyBob29rcy5tYWlsaW5nbGlzdAojICAgVGhpcyBpcyB0aGUgbGlzdCB0aGF0IGFsbCBwdXNoZXMgd2lsbCBnbyB0bzsgbGVhdmUgaXQgYmxhbmsgdG8gbm90IHNlbmQKIyAgIGVtYWlscyBmb3IgZXZlcnkgcmVmIHVwZGF0ZS4KIyBob29rcy5hbm5vdW5jZWxpc3QKIyAgIFRoaXMgaXMgdGhlIGxpc3QgdGhhdCBhbGwgcHVzaGVzIG9mIGFubm90YXRlZCB0YWdzIHdpbGwgZ28gdG8uICBMZWF2ZSBpdAojICAgYmxhbmsgdG8gZGVmYXVsdCB0byB0aGUgbWFpbGluZ2xpc3QgZmllbGQuICBUaGUgYW5ub3VuY2UgZW1haWxzIGxpc3RzCiMgICB0aGUgc2hvcnQgbG9nIHN1bW1hcnkgb2YgdGhlIGNoYW5nZXMgc2luY2UgdGhlIGxhc3QgYW5ub3RhdGVkIHRhZy4KIyBob29rcy5lbnZlbG9wZXNlbmRlcgojICAgSWYgc2V0IHRoZW4gdGhlIC1mIG9wdGlvbiBpcyBwYXNzZWQgdG8gc2VuZG1haWwgdG8gYWxsb3cgdGhlIGVudmVsb3BlCiMgICBzZW5kZXIgYWRkcmVzcyB0byBiZSBzZXQKIyBob29rcy5lbWFpbHByZWZpeAojICAgQWxsIGVtYWlscyBoYXZlIHRoZWlyIHN1YmplY3RzIHByZWZpeGVkIHdpdGggdGhpcyBwcmVmaXgsIG9yICJbU0NNXSIKIyAgIGlmIGVtYWlscHJlZml4IGlzIHVuc2V0LCB0byBhaWQgZmlsdGVyaW5nCiMgaG9va3Muc2hvd3JldgojICAgVGhlIHNoZWxsIGNvbW1hbmQgdXNlZCB0byBmb3JtYXQgZWFjaCByZXZpc2lvbiBpbiB0aGUgZW1haWwsIHdpdGgKIyAgICIlcyIgcmVwbGFjZWQgd2l0aCB0aGUgY29tbWl0IGlkLiAgRGVmYXVsdHMgdG8gImdpdCByZXYtbGlzdCAtMQojICAgLS1wcmV0dHkgJXMiLCBkaXNwbGF5aW5nIHRoZSBjb21taXQgaWQsIGF1dGhvciwgZGF0ZSBhbmQgbG9nCiMgICBtZXNzYWdlLiAgVG8gbGlzdCBmdWxsIHBhdGNoZXMgc2VwYXJhdGVkIGJ5IGEgYmxhbmsgbGluZSwgeW91CiMgICBjb3VsZCBzZXQgdGhpcyB0byAiZ2l0IHNob3cgLUMgJXM7IGVjaG8iLgojICAgVG8gbGlzdCBhIGdpdHdlYi9jZ2l0IFVSTCAqYW5kKiBhIGZ1bGwgcGF0Y2ggZm9yIGVhY2ggY2hhbmdlIHNldCwgdXNlIHRoaXM6CiMgICAgICJ0PSVzOyBwcmludGYgJ2h0dHA6Ly8uLi4vP2lkPSUlcycgXCR0OyBlY2hvO2VjaG87IGdpdCBzaG93IC1DIFwkdDsgZWNobyIKIyAgIEJlIGNhcmVmdWwgaWYgIi4uLiIgY29udGFpbnMgdGhpbmdzIHRoYXQgd2lsbCBiZSBleHBhbmRlZCBieSBzaGVsbCAiZXZhbCIKIyAgIG9yIHByaW50Zi4KIyBob29rcy5lbWFpbG1heGxpbmVzCiMgICBUaGUgbWF4aW11bSBudW1iZXIgb2YgbGluZXMgdGhhdCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIGdlbmVyYXRlZAojICAgZW1haWwgYm9keS4gSWYgbm90IHNwZWNpZmllZCwgdGhlcmUgaXMgbm8gbGltaXQuCiMgICBMaW5lcyBiZXlvbmQgdGhlIGxpbWl0IGFyZSBzdXBwcmVzc2VkIGFuZCBjb3VudGVkLCBhbmQgYSBmaW5hbAojICAgbGluZSBpcyBhZGRlZCBpbmRpY2F0aW5nIHRoZSBudW1iZXIgb2Ygc3VwcHJlc3NlZCBsaW5lcy4KIwojIE5vdGVzCiMgLS0tLS0KIyBBbGwgZW1haWxzIGluY2x1ZGUgdGhlIGhlYWRlcnMgIlgtR2l0LVJlZm5hbWUiLCAiWC1HaXQtT2xkcmV2IiwKIyAiWC1HaXQtTmV3cmV2IiwgYW5kICJYLUdpdC1SZWZ0eXBlIiB0byBlbmFibGUgZmluZSB0dW5lZCBmaWx0ZXJpbmcgYW5kCiMgZ2l2ZSBpbmZvcm1hdGlvbiBmb3IgZGVidWdnaW5nLgojCgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRnVuY3Rpb25zCgojCiMgVG9wIGxldmVsIGVtYWlsIGdlbmVyYXRpb24gZnVuY3Rpb24uICBUaGlzIGRlY2lkZXMgd2hhdCB0eXBlIG9mIHVwZGF0ZQojIHRoaXMgaXMgYW5kIGNhbGxzIHRoZSBhcHByb3ByaWF0ZSBib2R5LWdlbmVyYXRpb24gcm91dGluZSBhZnRlciBvdXRwdXR0aW5nCiMgdGhlIGNvbW1vbiBoZWFkZXIKIwojIE5vdGUgdGhpcyBmdW5jdGlvbiBkb2Vzbid0IGFjdHVhbGx5IGdlbmVyYXRlIGFueSBlbWFpbCBvdXRwdXQsIHRoYXQgaXMKIyB0YWtlbiBjYXJlIG9mIGJ5IHRoZSBmdW5jdGlvbnMgaXQgY2FsbHM6CiMgIC0gZ2VuZXJhdGVfZW1haWxfaGVhZGVyCiMgIC0gZ2VuZXJhdGVfY3JlYXRlX1hYWFhfZW1haWwKIyAgLSBnZW5lcmF0ZV91cGRhdGVfWFhYWF9lbWFpbAojICAtIGdlbmVyYXRlX2RlbGV0ZV9YWFhYX2VtYWlsCiMgIC0gZ2VuZXJhdGVfZW1haWxfZm9vdGVyCiMKZ2VuZXJhdGVfZW1haWwoKQp7CgkjIC0tLSBBcmd1bWVudHMKCW9sZHJldj0kKGdpdCByZXYtcGFyc2UgJDEpCgluZXdyZXY9JChnaXQgcmV2LXBhcnNlICQyKQoJcmVmbmFtZT0iJDMiCgltYXhsaW5lcz0kNAoKCSMgLS0tIEludGVycHJldAoJIyAwMDAwLT4xMjM0IChjcmVhdGUpCgkjIDEyMzQtPjIzNDUgKHVwZGF0ZSkKCSMgMjM0NS0+MDAwMCAoZGVsZXRlKQoJaWYgZXhwciAiJG9sZHJldiIgOiAnMCokJyA+L2Rldi9udWxsCgl0aGVuCgkJY2hhbmdlX3R5cGU9ImNyZWF0ZSIKCWVsc2UKCQlpZiBleHByICIkbmV3cmV2IiA6ICcwKiQnID4vZGV2L251bGwKCQl0aGVuCgkJCWNoYW5nZV90eXBlPSJkZWxldGUiCgkJZWxzZQoJCQljaGFuZ2VfdHlwZT0idXBkYXRlIgoJCWZpCglmaQoKCSMgLS0tIEdldCB0aGUgcmV2aXNpb24gdHlwZXMKCW5ld3Jldl90eXBlPSQoZ2l0IGNhdC1maWxlIC10ICRuZXdyZXYgMj4gL2Rldi9udWxsKQoJb2xkcmV2X3R5cGU9JChnaXQgY2F0LWZpbGUgLXQgIiRvbGRyZXYiIDI+IC9kZXYvbnVsbCkKCWNhc2UgIiRjaGFuZ2VfdHlwZSIgaW4KCWNyZWF0ZXx1cGRhdGUpCgkJcmV2PSIkbmV3cmV2IgoJCXJldl90eXBlPSIkbmV3cmV2X3R5cGUiCgkJOzsKCWRlbGV0ZSkKCQlyZXY9IiRvbGRyZXYiCgkJcmV2X3R5cGU9IiRvbGRyZXZfdHlwZSIKCQk7OwoJZXNhYwoKCSMgVGhlIHJldmlzaW9uIHR5cGUgdGVsbHMgdXMgd2hhdCB0eXBlIHRoZSBjb21taXQgaXMsIGNvbWJpbmVkIHdpdGgKCSMgdGhlIGxvY2F0aW9uIG9mIHRoZSByZWYgd2UgY2FuIGRlY2lkZSBiZXR3ZWVuCgkjICAtIHdvcmtpbmcgYnJhbmNoCgkjICAtIHRyYWNraW5nIGJyYW5jaAoJIyAgLSB1bmFubm90ZWQgdGFnCgkjICAtIGFubm90YXRlZCB0YWcKCWNhc2UgIiRyZWZuYW1lIiwiJHJldl90eXBlIiBpbgoJCXJlZnMvdGFncy8qLGNvbW1pdCkKCQkJIyB1bi1hbm5vdGF0ZWQgdGFnCgkJCXJlZm5hbWVfdHlwZT0idGFnIgoJCQlzaG9ydF9yZWZuYW1lPSR7cmVmbmFtZSMjcmVmcy90YWdzL30KCQkJOzsKCQlyZWZzL3RhZ3MvKix0YWcpCgkJCSMgYW5ub3RhdGVkIHRhZwoJCQlyZWZuYW1lX3R5cGU9ImFubm90YXRlZCB0YWciCgkJCXNob3J0X3JlZm5hbWU9JHtyZWZuYW1lIyNyZWZzL3RhZ3MvfQoJCQkjIGNoYW5nZSByZWNpcGllbnRzCgkJCWlmIFsgLW4gIiRhbm5vdW5jZXJlY2lwaWVudHMiIF07IHRoZW4KCQkJCXJlY2lwaWVudHM9IiRhbm5vdW5jZXJlY2lwaWVudHMiCgkJCWZpCgkJCTs7CgkJcmVmcy9oZWFkcy8qLGNvbW1pdCkKCQkJIyBicmFuY2gKCQkJcmVmbmFtZV90eXBlPSJicmFuY2giCgkJCXNob3J0X3JlZm5hbWU9JHtyZWZuYW1lIyNyZWZzL2hlYWRzL30KCQkJOzsKCQlyZWZzL3JlbW90ZXMvKixjb21taXQpCgkJCSMgdHJhY2tpbmcgYnJhbmNoCgkJCXJlZm5hbWVfdHlwZT0idHJhY2tpbmcgYnJhbmNoIgoJCQlzaG9ydF9yZWZuYW1lPSR7cmVmbmFtZSMjcmVmcy9yZW1vdGVzL30KCQkJZWNobyA+JjIgIioqKiBQdXNoLXVwZGF0ZSBvZiB0cmFja2luZyBicmFuY2gsICRyZWZuYW1lIgoJCQllY2hvID4mMiAiKioqICAtIG5vIGVtYWlsIGdlbmVyYXRlZC4iCgkJCWV4aXQgMAoJCQk7OwoJCSopCgkJCSMgQW55dGhpbmcgZWxzZSAoaXMgdGhlcmUgYW55dGhpbmcgZWxzZT8pCgkJCWVjaG8gPiYyICIqKiogVW5rbm93biB0eXBlIG9mIHVwZGF0ZSB0byAkcmVmbmFtZSAoJHJldl90eXBlKSIKCQkJZWNobyA+JjIgIioqKiAgLSBubyBlbWFpbCBnZW5lcmF0ZWQiCgkJCWV4aXQgMQoJCQk7OwoJZXNhYwoKCSMgQ2hlY2sgaWYgd2UndmUgZ290IGFueW9uZSB0byBzZW5kIHRvCglpZiBbIC16ICIkcmVjaXBpZW50cyIgXTsgdGhlbgoJCWNhc2UgIiRyZWZuYW1lX3R5cGUiIGluCgkJCSJhbm5vdGF0ZWQgdGFnIikKCQkJCWNvbmZpZ19uYW1lPSJob29rcy5hbm5vdW5jZWxpc3QiCgkJCQk7OwoJCQkqKQoJCQkJY29uZmlnX25hbWU9Imhvb2tzLm1haWxpbmdsaXN0IgoJCQkJOzsKCQllc2FjCgkJZWNobyA+JjIgIioqKiAkY29uZmlnX25hbWUgaXMgbm90IHNldCBzbyBubyBlbWFpbCB3aWxsIGJlIHNlbnQiCgkJZWNobyA+JjIgIioqKiBmb3IgJHJlZm5hbWUgdXBkYXRlICRvbGRyZXYtPiRuZXdyZXYiCgkJZXhpdCAwCglmaQoKCSMgRW1haWwgcGFyYW1ldGVycwoJIyBUaGUgZW1haWwgc3ViamVjdCB3aWxsIGNvbnRhaW4gdGhlIGJlc3QgZGVzY3JpcHRpb24gb2YgdGhlIHJlZgoJIyB0aGF0IHdlIGNhbiBidWlsZCBmcm9tIHRoZSBwYXJhbWV0ZXJzCglkZXNjcmliZT0kKGdpdCBkZXNjcmliZSAkcmV2IDI+L2Rldi9udWxsKQoJaWYgWyAteiAiJGRlc2NyaWJlIiBdOyB0aGVuCgkJZGVzY3JpYmU9JHJldgoJZmkKCglnZW5lcmF0ZV9lbWFpbF9oZWFkZXIKCgkjIENhbGwgdGhlIGNvcnJlY3QgYm9keSBnZW5lcmF0aW9uIGZ1bmN0aW9uCglmbl9uYW1lPWdlbmVyYWwKCWNhc2UgIiRyZWZuYW1lX3R5cGUiIGluCgkidHJhY2tpbmcgYnJhbmNoInxicmFuY2gpCgkJZm5fbmFtZT1icmFuY2gKCQk7OwoJImFubm90YXRlZCB0YWciKQoJCWZuX25hbWU9YXRhZwoJCTs7Cgllc2FjCgoJaWYgWyAteiAiJG1heGxpbmVzIiBdOyB0aGVuCgkJZ2VuZXJhdGVfJHtjaGFuZ2VfdHlwZX1fJHtmbl9uYW1lfV9lbWFpbAoJZWxzZQoJCWdlbmVyYXRlXyR7Y2hhbmdlX3R5cGV9XyR7Zm5fbmFtZX1fZW1haWwgfCBsaW1pdF9saW5lcyAkbWF4bGluZXMKCWZpCgoJZ2VuZXJhdGVfZW1haWxfZm9vdGVyCn0KCmdlbmVyYXRlX2VtYWlsX2hlYWRlcigpCnsKCSMgLS0tIEVtYWlsIChhbGwgc3Rkb3V0IHdpbGwgYmUgdGhlIGVtYWlsKQoJIyBHZW5lcmF0ZSBoZWFkZXIKCWNhdCA8PC1FT0YKCVRvOiAkcmVjaXBpZW50cwoJU3ViamVjdDogJHtlbWFpbHByZWZpeH0kcHJvamVjdGRlc2MgJHJlZm5hbWVfdHlwZSAkc2hvcnRfcmVmbmFtZSAke2NoYW5nZV90eXBlfWQuICRkZXNjcmliZQoJWC1HaXQtUmVmbmFtZTogJHJlZm5hbWUKCVgtR2l0LVJlZnR5cGU6ICRyZWZuYW1lX3R5cGUKCVgtR2l0LU9sZHJldjogJG9sZHJldgoJWC1HaXQtTmV3cmV2OiAkbmV3cmV2CgoJVGhpcyBpcyBhbiBhdXRvbWF0ZWQgZW1haWwgZnJvbSB0aGUgZ2l0IGhvb2tzL3Bvc3QtcmVjZWl2ZSBzY3JpcHQuIEl0IHdhcwoJZ2VuZXJhdGVkIGJlY2F1c2UgYSByZWYgY2hhbmdlIHdhcyBwdXNoZWQgdG8gdGhlIHJlcG9zaXRvcnkgY29udGFpbmluZwoJdGhlIHByb2plY3QgIiRwcm9qZWN0ZGVzYyIuCgoJVGhlICRyZWZuYW1lX3R5cGUsICRzaG9ydF9yZWZuYW1lIGhhcyBiZWVuICR7Y2hhbmdlX3R5cGV9ZAoJRU9GCn0KCmdlbmVyYXRlX2VtYWlsX2Zvb3RlcigpCnsKCVNQQUNFPSIgIgoJY2F0IDw8LUVPRgoKCglob29rcy9wb3N0LXJlY2VpdmUKCS0tJHtTUEFDRX0KCSRwcm9qZWN0ZGVzYwoJRU9GCn0KCiMgLS0tLS0tLS0tLS0tLS0tIEJyYW5jaGVzCgojCiMgQ2FsbGVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSBicmFuY2gKIwpnZW5lcmF0ZV9jcmVhdGVfYnJhbmNoX2VtYWlsKCkKewoJIyBUaGlzIGlzIGEgbmV3IGJyYW5jaCBhbmQgc28gb2xkcmV2IGlzIG5vdCB2YWxpZAoJZWNobyAiICAgICAgICBhdCAgJG5ld3JldiAoJG5ld3Jldl90eXBlKSIKCWVjaG8gIiIKCgllY2hvICRMT0dCRUdJTgoJc2hvd19uZXdfcmV2aXNpb25zCgllY2hvICRMT0dFTkQKfQoKIwojIENhbGxlZCBmb3IgdGhlIGNoYW5nZSBvZiBhIHByZS1leGlzdGluZyBicmFuY2gKIwpnZW5lcmF0ZV91cGRhdGVfYnJhbmNoX2VtYWlsKCkKewoJIyBDb25zaWRlciB0aGlzOgoJIyAgIDEgLS0tIDIgLS0tIE8gLS0tIFggLS0tIDMgLS0tIDQgLS0tIE4KCSMKCSMgTyBpcyAkb2xkcmV2IGZvciAkcmVmbmFtZQoJIyBOIGlzICRuZXdyZXYgZm9yICRyZWZuYW1lCgkjIFggaXMgYSByZXZpc2lvbiBwb2ludGVkIHRvIGJ5IHNvbWUgb3RoZXIgcmVmLCBmb3Igd2hpY2ggd2UgbWF5CgkjICAgYXNzdW1lIHRoYXQgYW4gZW1haWwgaGFzIGFscmVhZHkgYmVlbiBnZW5lcmF0ZWQuCgkjIEluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIGlzc3VlIGFuIGVtYWlsIGNvbnRhaW5pbmcgb25seSByZXZpc2lvbnMKCSMgMywgNCwgYW5kIE4uICBHaXZlbiAoYWxtb3N0KSBieQoJIwoJIyAgZ2l0IHJldi1saXN0IE4gXk8gLS1ub3QgLS1hbGwKCSMKCSMgVGhlIHJlYXNvbiBmb3IgdGhlICJhbG1vc3QiLCBpcyB0aGF0IHRoZSAiLS1ub3QgLS1hbGwiIHdpbGwgdGFrZQoJIyBwcmVjZWRlbmNlIG92ZXIgdGhlICJOIiwgYW5kIGVmZmVjdGl2ZWx5IHdpbGwgdHJhbnNsYXRlIHRvCgkjCgkjICBnaXQgcmV2LWxpc3QgTiBeTyBeWCBeTgoJIwoJIyBTbywgd2UgbmVlZCB0byBidWlsZCB1cCB0aGUgbGlzdCBtb3JlIGNhcmVmdWxseS4gIGdpdCByZXYtcGFyc2UKCSMgd2lsbCBnZW5lcmF0ZSBhIGxpc3Qgb2YgcmV2cyB0aGF0IG1heSBiZSBmZWQgaW50byBnaXQgcmV2LWxpc3QuCgkjIFdlIGNhbiBnZXQgaXQgdG8gbWFrZSB0aGUgIi0tbm90IC0tYWxsIiBwYXJ0IGFuZCB0aGVuIGZpbHRlciBvdXQKCSMgdGhlICJeTiIgd2l0aDoKCSMKCSMgIGdpdCByZXYtcGFyc2UgLS1ub3QgLS1hbGwgfCBncmVwIC12IE4KCSMKCSMgVGhlbiwgdXNpbmcgdGhlIC0tc3RkaW4gc3dpdGNoIHRvIGdpdCByZXYtbGlzdCB3ZSBoYXZlIGVmZmVjdGl2ZWx5CgkjIG1hbnVmYWN0dXJlZAoJIwoJIyAgZ2l0IHJldi1saXN0IE4gXk8gXlgKCSMKCSMgVGhpcyBsZWF2ZXMgYSBwcm9ibGVtIHdoZW4gc29tZW9uZSBlbHNlIHVwZGF0ZXMgdGhlIHJlcG9zaXRvcnkKCSMgd2hpbGUgdGhpcyBzY3JpcHQgaXMgcnVubmluZy4gIFRoZWlyIG5ldyB2YWx1ZSBvZiB0aGUgcmVmIHdlJ3JlCgkjIHdvcmtpbmcgb24gd291bGQgYmUgaW5jbHVkZWQgaW4gdGhlICItLW5vdCAtLWFsbCIgb3V0cHV0OyBhbmQgYXMKCSMgb3VyICRuZXdyZXYgd291bGQgYmUgYW4gYW5jZXN0b3Igb2YgdGhhdCBjb21taXQsIGl0IHdvdWxkIGV4Y2x1ZGUKCSMgYWxsIG9mIG91ciBjb21taXRzLiAgV2hhdCB3ZSByZWFsbHkgd2FudCBpcyB0byBleGNsdWRlIHRoZSBjdXJyZW50CgkjIHZhbHVlIG9mICRyZWZuYW1lIGZyb20gdGhlIC0tbm90IGxpc3QsIHJhdGhlciB0aGFuIE4gaXRzZWxmLiAgU286CgkjCgkjICBnaXQgcmV2LXBhcnNlIC0tbm90IC0tYWxsIHwgZ3JlcCAtdiAkKGdpdCByZXYtcGFyc2UgJHJlZm5hbWUpCgkjCgkjIEdldCdzIHVzIHRvIHNvbWV0aGluZyBwcmV0dHkgc2FmZSAoYXBhcnQgZnJvbSB0aGUgc21hbGwgdGltZQoJIyBiZXR3ZWVuIHJlZm5hbWUgYmVpbmcgcmVhZCwgYW5kIGdpdCByZXYtcGFyc2UgcnVubmluZyAtIGZvciB0aGF0LAoJIyBJIGdpdmUgdXApCgkjCgkjCgkjIE5leHQgcHJvYmxlbSwgY29uc2lkZXIgdGhpczoKCSMgICAqIC0tLSBCIC0tLSAqIC0tLSBPICgkb2xkcmV2KQoJIyAgICAgICAgICBcCgkjICAgICAgICAgICAqIC0tLSBYIC0tLSAqIC0tLSBOICgkbmV3cmV2KQoJIwoJIyBUaGF0IGlzIHRvIHNheSwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgb2xkcmV2IGlzIGEgc3RyaWN0CgkjIHN1YnNldCBvZiBuZXdyZXYgKGl0IHdvdWxkIGhhdmUgcmVxdWlyZWQgYSAtLWZvcmNlLCBidXQgdGhhdCdzCgkjIGFsbG93ZWQpLiAgU28sIHdlIGNhbid0IHNpbXBseSBzYXkgcmV2LWxpc3QgJG9sZHJldi4uJG5ld3Jldi4KCSMgSW5zdGVhZCB3ZSBmaW5kIHRoZSBjb21tb24gYmFzZSBvZiB0aGUgdHdvIHJldnMgYW5kIGxpc3QgZnJvbQoJIyB0aGVyZS4KCSMKCSMgQXMgYWJvdmUsIHdlIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlIHByZXNlbmNlIG9mIFg7IGlmCgkjIGFub3RoZXIgYnJhbmNoIGlzIGFscmVhZHkgaW4gdGhlIHJlcG9zaXRvcnkgYW5kIHBvaW50cyBhdCBzb21lIG9mCgkjIHRoZSByZXZpc2lvbnMgdGhhdCB3ZSBhcmUgYWJvdXQgdG8gb3V0cHV0IC0gd2UgZG9uJ3Qgd2FudCB0aGVtLgoJIyBUaGUgc29sdXRpb24gaXMgYXMgYmVmb3JlOiBnaXQgcmV2LXBhcnNlIG91dHB1dCBmaWx0ZXJlZC4KCSMKCSMgRmluYWxseSwgdGFnczogMSAtLS0gMiAtLS0gTyAtLS0gVCAtLS0gMyAtLS0gNCAtLS0gTgoJIwoJIyBUYWdzIHB1c2hlZCBpbnRvIHRoZSByZXBvc2l0b3J5IGdlbmVyYXRlIG5pY2Ugc2hvcnRsb2cgZW1haWxzIHRoYXQKCSMgc3VtbWFyaXNlIHRoZSBjb21taXRzIGJldHdlZW4gdGhlbSBhbmQgdGhlIHByZXZpb3VzIHRhZy4gIEhvd2V2ZXIsCgkjIHRob3NlIGVtYWlscyBkb24ndCBpbmNsdWRlIHRoZSBmdWxsIGNvbW1pdCBtZXNzYWdlcyB0aGF0IHdlIG91dHB1dAoJIyBmb3IgYSBicmFuY2ggdXBkYXRlLiAgVGhlcmVmb3JlIHdlIHN0aWxsIHdhbnQgdG8gb3V0cHV0IHJldmlzaW9ucwoJIyB0aGF0IGhhdmUgYmVlbiBvdXRwdXQgb24gYSB0YWcgZW1haWwuCgkjCgkjIEx1Y2tpbHksIGdpdCByZXYtcGFyc2UgaW5jbHVkZXMganVzdCB0aGUgdG9vbC4gIEluc3RlYWQgb2YgdXNpbmcKCSMgIi0tYWxsIiB3ZSB1c2UgIi0tYnJhbmNoZXMiOyB0aGlzIGhhcyB0aGUgYWRkZWQgYmVuZWZpdCB0aGF0CgkjICJyZW1vdGVzLyIgd2lsbCBiZSBpZ25vcmVkIGFzIHdlbGwuCgoJIyBMaXN0IGFsbCBvZiB0aGUgcmV2aXNpb25zIHRoYXQgd2VyZSByZW1vdmVkIGJ5IHRoaXMgdXBkYXRlLCBpbiBhCgkjIGZhc3QtZm9yd2FyZCB1cGRhdGUsIHRoaXMgbGlzdCB3aWxsIGJlIGVtcHR5LCBiZWNhdXNlIHJldi1saXN0IE8KCSMgXk4gaXMgZW1wdHkuICBGb3IgYSBub24tZmFzdC1mb3J3YXJkLCBPIF5OIGlzIHRoZSBsaXN0IG9mIHJlbW92ZWQKCSMgcmV2aXNpb25zCglmYXN0X2ZvcndhcmQ9IiIKCXJldj0iIgoJZm9yIHJldiBpbiAkKGdpdCByZXYtbGlzdCAkbmV3cmV2Li4kb2xkcmV2KQoJZG8KCQlyZXZ0eXBlPSQoZ2l0IGNhdC1maWxlIC10ICIkcmV2IikKCQllY2hvICIgIGRpc2NhcmRzICAkcmV2ICgkcmV2dHlwZSkiCglkb25lCglpZiBbIC16ICIkcmV2IiBdOyB0aGVuCgkJZmFzdF9mb3J3YXJkPTEKCWZpCgoJIyBMaXN0IGFsbCB0aGUgcmV2aXNpb25zIGZyb20gYmFzZXJldiB0byBuZXdyZXYgaW4gYSBraW5kIG9mCgkjICJ0YWJsZS1vZi1jb250ZW50cyI7IG5vdGUgdGhpcyBsaXN0IGNhbiBpbmNsdWRlIHJldmlzaW9ucyB0aGF0CgkjIGhhdmUgYWxyZWFkeSBoYWQgbm90aWZpY2F0aW9uIGVtYWlscyBhbmQgaXMgcHJlc2VudCB0byBzaG93IHRoZQoJIyBmdWxsIGRldGFpbCBvZiB0aGUgY2hhbmdlIGZyb20gcm9sbGluZyBiYWNrIHRoZSBvbGQgcmV2aXNpb24gdG8KCSMgdGhlIGJhc2UgcmV2aXNpb24gYW5kIHRoZW4gZm9yd2FyZCB0byB0aGUgbmV3IHJldmlzaW9uCglmb3IgcmV2IGluICQoZ2l0IHJldi1saXN0ICRvbGRyZXYuLiRuZXdyZXYpCglkbwoJCXJldnR5cGU9JChnaXQgY2F0LWZpbGUgLXQgIiRyZXYiKQoJCWVjaG8gIiAgICAgICB2aWEgICRyZXYgKCRyZXZ0eXBlKSIKCWRvbmUKCglpZiBbICIkZmFzdF9mb3J3YXJkIiBdOyB0aGVuCgkJZWNobyAiICAgICAgZnJvbSAgJG9sZHJldiAoJG9sZHJldl90eXBlKSIKCWVsc2UKCQkjICAxLiBFeGlzdGluZyByZXZpc2lvbnMgd2VyZSByZW1vdmVkLiAgSW4gdGhpcyBjYXNlIG5ld3JldgoJCSMgICAgIGlzIGEgc3Vic2V0IG9mIG9sZHJldiAtIHRoaXMgaXMgdGhlIHJldmVyc2Ugb2YgYQoJCSMgICAgIGZhc3QtZm9yd2FyZCwgYSByZXdpbmQKCQkjICAyLiBOZXcgcmV2aXNpb25zIHdlcmUgYWRkZWQgb24gdG9wIG9mIGFuIG9sZCByZXZpc2lvbiwKCQkjICAgICB0aGlzIGlzIGEgcmV3aW5kIGFuZCBhZGRpdGlvbi4KCgkJIyAoMSkgY2VydGFpbmx5IGhhcHBlbmVkLCAoMikgcG9zc2libHkuICBXaGVuICgyKSBoYXNuJ3QKCQkjIGhhcHBlbmVkLCB3ZSBzZXQgYSBmbGFnIHRvIGluZGljYXRlIHRoYXQgbm8gbG9nIHByaW50b3V0CgkJIyBpcyByZXF1aXJlZC4KCgkJZWNobyAiIgoKCQkjIEZpbmQgdGhlIGNvbW1vbiBhbmNlc3RvciBvZiB0aGUgb2xkIGFuZCBuZXcgcmV2aXNpb25zIGFuZAoJCSMgY29tcGFyZSBpdCB3aXRoIG5ld3JldgoJCWJhc2VyZXY9JChnaXQgbWVyZ2UtYmFzZSAkb2xkcmV2ICRuZXdyZXYpCgkJcmV3aW5kX29ubHk9IiIKCQlpZiBbICIkYmFzZXJldiIgPSAiJG5ld3JldiIgXTsgdGhlbgoJCQllY2hvICJUaGlzIHVwZGF0ZSBkaXNjYXJkZWQgZXhpc3RpbmcgcmV2aXNpb25zIGFuZCBsZWZ0IHRoZSBicmFuY2ggcG9pbnRpbmcgYXQiCgkJCWVjaG8gImEgcHJldmlvdXMgcG9pbnQgaW4gdGhlIHJlcG9zaXRvcnkgaGlzdG9yeS4iCgkJCWVjaG8gIiIKCQkJZWNobyAiICogLS0gKiAtLSBOICgkbmV3cmV2KSIKCQkJZWNobyAiICAgICAgICAgICAgXFwiCgkJCWVjaG8gIiAgICAgICAgICAgICBPIC0tIE8gLS0gTyAoJG9sZHJldikiCgkJCWVjaG8gIiIKCQkJZWNobyAiVGhlIHJlbW92ZWQgcmV2aXNpb25zIGFyZSBub3QgbmVjZXNzYXJpbGx5IGdvbmUgLSBpZiBhbm90aGVyIHJlZmVyZW5jZSIKCQkJZWNobyAic3RpbGwgcmVmZXJzIHRvIHRoZW0gdGhleSB3aWxsIHN0YXkgaW4gdGhlIHJlcG9zaXRvcnkuIgoJCQlyZXdpbmRfb25seT0xCgkJZWxzZQoJCQllY2hvICJUaGlzIHVwZGF0ZSBhZGRlZCBuZXcgcmV2aXNpb25zIGFmdGVyIHVuZG9pbmcgZXhpc3RpbmcgcmV2aXNpb25zLiAgVGhhdCBpcyIKCQkJZWNobyAidG8gc2F5LCB0aGUgb2xkIHJldmlzaW9uIGlzIG5vdCBhIHN0cmljdCBzdWJzZXQgb2YgdGhlIG5ldyByZXZpc2lvbi4gIFRoaXMiCgkJCWVjaG8gInNpdHVhdGlvbiBvY2N1cnMgd2hlbiB5b3UgLS1mb3JjZSBwdXNoIGEgY2hhbmdlIGFuZCBnZW5lcmF0ZSBhIHJlcG9zaXRvcnkiCgkJCWVjaG8gImNvbnRhaW5pbmcgc29tZXRoaW5nIGxpa2UgdGhpczoiCgkJCWVjaG8gIiIKCQkJZWNobyAiICogLS0gKiAtLSBCIC0tIE8gLS0gTyAtLSBPICgkb2xkcmV2KSIKCQkJZWNobyAiICAgICAgICAgICAgXFwiCgkJCWVjaG8gIiAgICAgICAgICAgICBOIC0tIE4gLS0gTiAoJG5ld3JldikiCgkJCWVjaG8gIiIKCQkJZWNobyAiV2hlbiB0aGlzIGhhcHBlbnMgd2UgYXNzdW1lIHRoYXQgeW91J3ZlIGFscmVhZHkgaGFkIGFsZXJ0IGVtYWlscyBmb3IgYWxsIgoJCQllY2hvICJvZiB0aGUgTyByZXZpc2lvbnMsIGFuZCBzbyB3ZSBoZXJlIHJlcG9ydCBvbmx5IHRoZSByZXZpc2lvbnMgaW4gdGhlIE4iCgkJCWVjaG8gImJyYW5jaCBmcm9tIHRoZSBjb21tb24gYmFzZSwgQi4iCgkJZmkKCWZpCgoJZWNobyAiIgoJaWYgWyAteiAiJHJld2luZF9vbmx5IiBdOyB0aGVuCgkJZWNobyAiVGhvc2UgcmV2aXNpb25zIGxpc3RlZCBhYm92ZSB0aGF0IGFyZSBuZXcgdG8gdGhpcyByZXBvc2l0b3J5IGhhdmUiCgkJZWNobyAibm90IGFwcGVhcmVkIG9uIGFueSBvdGhlciBub3RpZmljYXRpb24gZW1haWw7IHNvIHdlIGxpc3QgdGhvc2UiCgkJZWNobyAicmV2aXNpb25zIGluIGZ1bGwsIGJlbG93LiIKCgkJZWNobyAiIgoJCWVjaG8gJExPR0JFR0lOCgkJc2hvd19uZXdfcmV2aXNpb25zCgoJCSMgWFhYOiBOZWVkIGEgd2F5IG9mIGRldGVjdGluZyB3aGV0aGVyIGdpdCByZXYtbGlzdCBhY3R1YWxseQoJCSMgb3V0cHV0dGVkIGFueXRoaW5nLCBzbyB0aGF0IHdlIGNhbiBpc3N1ZSBhICJubyBuZXcKCQkjIHJldmlzaW9ucyBhZGRlZCBieSB0aGlzIHVwZGF0ZSIgbWVzc2FnZQoKCQllY2hvICRMT0dFTkQKCWVsc2UKCQllY2hvICJObyBuZXcgcmV2aXNpb25zIHdlcmUgYWRkZWQgYnkgdGhpcyB1cGRhdGUuIgoJZmkKCgkjIFRoZSBkaWZmc3RhdCBpcyBzaG93biBmcm9tIHRoZSBvbGQgcmV2aXNpb24gdG8gdGhlIG5ldyByZXZpc2lvbi4KCSMgVGhpcyBpcyB0byBzaG93IHRoZSB0cnV0aCBvZiB3aGF0IGhhcHBlbmVkIGluIHRoaXMgY2hhbmdlLgoJIyBUaGVyZSdzIG5vIHBvaW50IHNob3dpbmcgdGhlIHN0YXQgZnJvbSB0aGUgYmFzZSB0byB0aGUgbmV3CgkjIHJldmlzaW9uIGJlY2F1c2UgdGhlIGJhc2UgaXMgZWZmZWN0aXZlbHkgYSByYW5kb20gcmV2aXNpb24gYXQgdGhpcwoJIyBwb2ludCAtIHRoZSB1c2VyIHdpbGwgYmUgaW50ZXJlc3RlZCBpbiB3aGF0IHRoaXMgcmV2aXNpb24gY2hhbmdlZAoJIyAtIGluY2x1ZGluZyB0aGUgdW5kb2luZyBvZiBwcmV2aW91cyByZXZpc2lvbnMgaW4gdGhlIGNhc2Ugb2YKCSMgbm9uLWZhc3QtZm9yd2FyZCB1cGRhdGVzLgoJZWNobyAiIgoJZWNobyAiU3VtbWFyeSBvZiBjaGFuZ2VzOiIKCWdpdCBkaWZmLXRyZWUgLS1zdGF0IC0tc3VtbWFyeSAtLWZpbmQtY29waWVzLWhhcmRlciAkb2xkcmV2Li4kbmV3cmV2Cn0KCiMKIyBDYWxsZWQgZm9yIHRoZSBkZWxldGlvbiBvZiBhIGJyYW5jaAojCmdlbmVyYXRlX2RlbGV0ZV9icmFuY2hfZW1haWwoKQp7CgllY2hvICIgICAgICAgd2FzICAkb2xkcmV2IgoJZWNobyAiIgoJZWNobyAkTE9HRU5ECglnaXQgc2hvdyAtcyAtLXByZXR0eT1vbmVsaW5lICRvbGRyZXYKCWVjaG8gJExPR0VORAp9CgojIC0tLS0tLS0tLS0tLS0tLSBBbm5vdGF0ZWQgdGFncwoKIwojIENhbGxlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGFuIGFubm90YXRlZCB0YWcKIwpnZW5lcmF0ZV9jcmVhdGVfYXRhZ19lbWFpbCgpCnsKCWVjaG8gIiAgICAgICAgYXQgICRuZXdyZXYgKCRuZXdyZXZfdHlwZSkiCgoJZ2VuZXJhdGVfYXRhZ19lbWFpbAp9CgojCiMgQ2FsbGVkIGZvciB0aGUgdXBkYXRlIG9mIGFuIGFubm90YXRlZCB0YWcgKHRoaXMgaXMgcHJvYmFibHkgYSByYXJlIGV2ZW50CiMgYW5kIG1heSBub3QgZXZlbiBiZSBhbGxvd2VkKQojCmdlbmVyYXRlX3VwZGF0ZV9hdGFnX2VtYWlsKCkKewoJZWNobyAiICAgICAgICB0byAgJG5ld3JldiAoJG5ld3Jldl90eXBlKSIKCWVjaG8gIiAgICAgIGZyb20gICRvbGRyZXYgKHdoaWNoIGlzIG5vdyBvYnNvbGV0ZSkiCgoJZ2VuZXJhdGVfYXRhZ19lbWFpbAp9CgojCiMgQ2FsbGVkIHdoZW4gYW4gYW5ub3RhdGVkIHRhZyBpcyBjcmVhdGVkIG9yIGNoYW5nZWQKIwpnZW5lcmF0ZV9hdGFnX2VtYWlsKCkKewoJIyBVc2UgZ2l0IGZvci1lYWNoLXJlZiB0byBwdWxsIG91dCB0aGUgaW5kaXZpZHVhbCBmaWVsZHMgZnJvbSB0aGUKCSMgdGFnCglldmFsICQoZ2l0IGZvci1lYWNoLXJlZiAtLXNoZWxsIC0tZm9ybWF0PScKCXRhZ29iamVjdD0lKCpvYmplY3RuYW1lKQoJdGFndHlwZT0lKCpvYmplY3R0eXBlKQoJdGFnZ2VyPSUodGFnZ2VybmFtZSkKCXRhZ2dlZD0lKHRhZ2dlcmRhdGUpJyAkcmVmbmFtZQoJKQoKCWVjaG8gIiAgIHRhZ2dpbmcgICR0YWdvYmplY3QgKCR0YWd0eXBlKSIKCWNhc2UgIiR0YWd0eXBlIiBpbgoJY29tbWl0KQoKCQkjIElmIHRoZSB0YWdnZWQgb2JqZWN0IGlzIGEgY29tbWl0LCB0aGVuIHdlIGFzc3VtZSB0aGlzIGlzIGEKCQkjIHJlbGVhc2UsIGFuZCBzbyB3ZSBjYWxjdWxhdGUgd2hpY2ggdGFnIHRoaXMgdGFnIGlzCgkJIyByZXBsYWNpbmcKCQlwcmV2dGFnPSQoZ2l0IGRlc2NyaWJlIC0tYWJicmV2PTAgJG5ld3Jldl4gMj4vZGV2L251bGwpCgoJCWlmIFsgLW4gIiRwcmV2dGFnIiBdOyB0aGVuCgkJCWVjaG8gIiAgcmVwbGFjZXMgICRwcmV2dGFnIgoJCWZpCgkJOzsKCSopCgkJZWNobyAiICAgIGxlbmd0aCAgJChnaXQgY2F0LWZpbGUgLXMgJHRhZ29iamVjdCkgYnl0ZXMiCgkJOzsKCWVzYWMKCWVjaG8gIiB0YWdnZWQgYnkgICR0YWdnZXIiCgllY2hvICIgICAgICAgIG9uICAkdGFnZ2VkIgoKCWVjaG8gIiIKCWVjaG8gJExPR0JFR0lOCgoJIyBTaG93IHRoZSBjb250ZW50IG9mIHRoZSB0YWcgbWVzc2FnZTsgdGhpcyBtaWdodCBjb250YWluIGEgY2hhbmdlCgkjIGxvZyBvciByZWxlYXNlIG5vdGVzIHNvIGlzIHdvcnRoIGRpc3BsYXlpbmcuCglnaXQgY2F0LWZpbGUgdGFnICRuZXdyZXYgfCBzZWQgLWUgJzEsL14kL2QnCgoJZWNobyAiIgoJY2FzZSAiJHRhZ3R5cGUiIGluCgljb21taXQpCgkJIyBPbmx5IGNvbW1pdCB0YWdzIG1ha2Ugc2Vuc2UgdG8gaGF2ZSByZXYtbGlzdCBvcGVyYXRpb25zCgkJIyBwZXJmb3JtZWQgb24gdGhlbQoJCWlmIFsgLW4gIiRwcmV2dGFnIiBdOyB0aGVuCgkJCSMgU2hvdyBjaGFuZ2VzIHNpbmNlIHRoZSBwcmV2aW91cyByZWxlYXNlCgkJCWdpdCByZXYtbGlzdCAtLXByZXR0eT1zaG9ydCAiJHByZXZ0YWcuLiRuZXdyZXYiIHwgZ2l0IHNob3J0bG9nCgkJZWxzZQoJCQkjIE5vIHByZXZpb3VzIHRhZywgc2hvdyBhbGwgdGhlIGNoYW5nZXMgc2luY2UgdGltZQoJCQkjIGJlZ2FuCgkJCWdpdCByZXYtbGlzdCAtLXByZXR0eT1zaG9ydCAkbmV3cmV2IHwgZ2l0IHNob3J0bG9nCgkJZmkKCQk7OwoJKikKCQkjIFhYWDogSXMgdGhlcmUgYW55dGhpbmcgdXNlZnVsIHdlIGNhbiBkbyBmb3Igbm9uLWNvbW1pdAoJCSMgb2JqZWN0cz8KCQk7OwoJZXNhYwoKCWVjaG8gJExPR0VORAp9CgojCiMgQ2FsbGVkIGZvciB0aGUgZGVsZXRpb24gb2YgYW4gYW5ub3RhdGVkIHRhZwojCmdlbmVyYXRlX2RlbGV0ZV9hdGFnX2VtYWlsKCkKewoJZWNobyAiICAgICAgIHdhcyAgJG9sZHJldiIKCWVjaG8gIiIKCWVjaG8gJExPR0VORAoJZ2l0IHNob3cgLXMgLS1wcmV0dHk9b25lbGluZSAkb2xkcmV2CgllY2hvICRMT0dFTkQKfQoKIyAtLS0tLS0tLS0tLS0tLS0gR2VuZXJhbCByZWZlcmVuY2VzCgojCiMgQ2FsbGVkIHdoZW4gYW55IG90aGVyIHR5cGUgb2YgcmVmZXJlbmNlIGlzIGNyZWF0ZWQgKG1vc3QgbGlrZWx5IGEKIyBub24tYW5ub3RhdGVkIHRhZykKIwpnZW5lcmF0ZV9jcmVhdGVfZ2VuZXJhbF9lbWFpbCgpCnsKCWVjaG8gIiAgICAgICAgYXQgICRuZXdyZXYgKCRuZXdyZXZfdHlwZSkiCgoJZ2VuZXJhdGVfZ2VuZXJhbF9lbWFpbAp9CgojCiMgQ2FsbGVkIHdoZW4gYW55IG90aGVyIHR5cGUgb2YgcmVmZXJlbmNlIGlzIHVwZGF0ZWQgKG1vc3QgbGlrZWx5IGEKIyBub24tYW5ub3RhdGVkIHRhZykKIwpnZW5lcmF0ZV91cGRhdGVfZ2VuZXJhbF9lbWFpbCgpCnsKCWVjaG8gIiAgICAgICAgdG8gICRuZXdyZXYgKCRuZXdyZXZfdHlwZSkiCgllY2hvICIgICAgICBmcm9tICAkb2xkcmV2IgoKCWdlbmVyYXRlX2dlbmVyYWxfZW1haWwKfQoKIwojIENhbGxlZCBmb3IgY3JlYXRpb24gb3IgdXBkYXRlIG9mIGFueSBvdGhlciB0eXBlIG9mIHJlZmVyZW5jZQojCmdlbmVyYXRlX2dlbmVyYWxfZW1haWwoKQp7CgkjIFVuYW5ub3RhdGVkIHRhZ3MgYXJlIG1vcmUgYWJvdXQgbWFya2luZyBhIHBvaW50IHRoYW4gcmVsZWFzaW5nIGEKCSMgdmVyc2lvbjsgdGhlcmVmb3JlIHdlIGRvbid0IGRvIHRoZSBzaG9ydGxvZyBzdW1tYXJ5IHRoYXQgd2UgZG8gZm9yCgkjIGFubm90YXRlZCB0YWdzIGFib3ZlIC0gd2Ugc2ltcGx5IHNob3cgdGhhdCB0aGUgcG9pbnQgaGFzIGJlZW4KCSMgbWFya2VkLCBhbmQgcHJpbnQgdGhlIGxvZyBtZXNzYWdlIGZvciB0aGUgbWFya2VkIHBvaW50IGZvcgoJIyByZWZlcmVuY2UgcHVycG9zZXMKCSMKCSMgTm90ZSB0aGlzIHNlY3Rpb24gYWxzbyBjYXRjaGVzIGFueSBvdGhlciByZWZlcmVuY2UgdHlwZSAoYWx0aG91Z2gKCSMgdGhlcmUgYXJlbid0IGFueSkgYW5kIGRlYWxzIHdpdGggdGhlbSBpbiB0aGUgc2FtZSB3YXkuCgoJZWNobyAiIgoJaWYgWyAiJG5ld3Jldl90eXBlIiA9ICJjb21taXQiIF07IHRoZW4KCQllY2hvICRMT0dCRUdJTgoJCWdpdCBzaG93IC0tbm8tY29sb3IgLS1yb290IC1zIC0tcHJldHR5PW1lZGl1bSAkbmV3cmV2CgkJZWNobyAkTE9HRU5ECgllbHNlCgkJIyBXaGF0IGNhbiB3ZSBkbyBoZXJlPyAgVGhlIHRhZyBtYXJrcyBhbiBvYmplY3QgdGhhdCBpcyBub3QKCQkjIGEgY29tbWl0LCBzbyB0aGVyZSBpcyBubyBsb2cgZm9yIHVzIHRvIGRpc3BsYXkuICBJdCdzCgkJIyBwcm9iYWJseSBub3Qgd2lzZSB0byBvdXRwdXQgZ2l0IGNhdC1maWxlIGFzIGl0IGNvdWxkIGJlIGEKCQkjIGJpbmFyeSBibG9iLiAgV2UnbGwganVzdCBzYXkgaG93IGJpZyBpdCBpcwoJCWVjaG8gIiRuZXdyZXYgaXMgYSAkbmV3cmV2X3R5cGUsIGFuZCBpcyAkKGdpdCBjYXQtZmlsZSAtcyAkbmV3cmV2KSBieXRlcyBsb25nLiIKCWZpCn0KCiMKIyBDYWxsZWQgZm9yIHRoZSBkZWxldGlvbiBvZiBhbnkgb3RoZXIgdHlwZSBvZiByZWZlcmVuY2UKIwpnZW5lcmF0ZV9kZWxldGVfZ2VuZXJhbF9lbWFpbCgpCnsKCWVjaG8gIiAgICAgICB3YXMgICRvbGRyZXYiCgllY2hvICIiCgllY2hvICRMT0dFTkQKCWdpdCBzaG93IC1zIC0tcHJldHR5PW9uZWxpbmUgJG9sZHJldgoJZWNobyAkTE9HRU5ECn0KCgojIC0tLS0tLS0tLS0tLS0tLSBNaXNjZWxsYW5lb3VzIHV0aWxpdGllcwoKIwojIFNob3cgbmV3IHJldmlzaW9ucyBhcyB0aGUgdXNlciB3b3VsZCBsaWtlIHRvIHNlZSB0aGVtIGluIHRoZSBlbWFpbC4KIwpzaG93X25ld19yZXZpc2lvbnMoKQp7CgkjIFRoaXMgc2hvd3MgYWxsIGxvZyBlbnRyaWVzIHRoYXQgYXJlIG5vdCBhbHJlYWR5IGNvdmVyZWQgYnkKCSMgYW5vdGhlciByZWYgLSBpLmUuIGNvbW1pdHMgdGhhdCBhcmUgbm93IGFjY2Vzc2libGUgZnJvbSB0aGlzCgkjIHJlZiB0aGF0IHdlcmUgcHJldmlvdXNseSBub3QgYWNjZXNzaWJsZQoJIyAoc2VlIGdlbmVyYXRlX3VwZGF0ZV9icmFuY2hfZW1haWwgZm9yIHRoZSBleHBsYW5hdGlvbiBvZiB0aGlzCgkjIGNvbW1hbmQpCgoJIyBSZXZpc2lvbiByYW5nZSBwYXNzZWQgdG8gcmV2LWxpc3QgZGlmZmVycyBmb3IgbmV3IHZzLiB1cGRhdGVkCgkjIGJyYW5jaGVzLgoJaWYgWyAiJGNoYW5nZV90eXBlIiA9IGNyZWF0ZSBdCgl0aGVuCgkJIyBTaG93IGFsbCByZXZpc2lvbnMgZXhjbHVzaXZlIHRvIHRoaXMgKG5ldykgYnJhbmNoLgoJCXJldnNwZWM9JG5ld3JldgoJZWxzZQoJCSMgQnJhbmNoIHVwZGF0ZTsgc2hvdyByZXZpc2lvbnMgbm90IHBhcnQgb2YgJG9sZHJldi4KCQlyZXZzcGVjPSRvbGRyZXYuLiRuZXdyZXYKCWZpCgoJb3RoZXJfYnJhbmNoZXM9JChnaXQgZm9yLWVhY2gtcmVmIC0tZm9ybWF0PSclKHJlZm5hbWUpJyByZWZzL2hlYWRzLyB8CgkgICAgZ3JlcCAtRiAtdiAkcmVmbmFtZSkKCWdpdCByZXYtcGFyc2UgLS1ub3QgJG90aGVyX2JyYW5jaGVzIHwKCWlmIFsgLXogIiRjdXN0b21fc2hvd3JldiIgXQoJdGhlbgoJCWdpdCByZXYtbGlzdCAtLXByZXR0eSAtLXN0ZGluICRyZXZzcGVjCgllbHNlCgkJZ2l0IHJldi1saXN0IC0tc3RkaW4gJHJldnNwZWMgfAoJCXdoaWxlIHJlYWQgb25lcmV2CgkJZG8KCQkJZXZhbCAkKHByaW50ZiAiJGN1c3RvbV9zaG93cmV2IiAkb25lcmV2KQoJCWRvbmUKCWZpCn0KCgpsaW1pdF9saW5lcygpCnsKCWxpbmVzPTAKCXNraXBwZWQ9MAoJd2hpbGUgSUZTPSIiIHJlYWQgLXIgbGluZTsgZG8KCQlsaW5lcz0kKChsaW5lcyArIDEpKQoJCWlmIFsgJGxpbmVzIC1ndCAkMSBdOyB0aGVuCgkJCXNraXBwZWQ9JCgoc2tpcHBlZCArIDEpKQoJCWVsc2UKCQkJcHJpbnRmICIlc1xuIiAiJGxpbmUiCgkJZmkKCWRvbmUKCWlmIFsgJHNraXBwZWQgLW5lIDAgXTsgdGhlbgoJCWVjaG8gIi4uLiAkc2tpcHBlZCBsaW5lcyBzdXBwcmVzc2VkIC4uLiIKCWZpCn0KCgpzZW5kX21haWwoKQp7CglpZiBbIC1uICIkZW52ZWxvcGVzZW5kZXIiIF07IHRoZW4KCQkvdXNyL3NiaW4vc2VuZG1haWwgLXQgLWYgIiRlbnZlbG9wZXNlbmRlciIKCWVsc2UKCQkvdXNyL3NiaW4vc2VuZG1haWwgLXQKCWZpCn0KCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBtYWluKCkKCiMgLS0tIENvbnN0YW50cwpMT0dCRUdJTj0iLSBMb2cgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0iCkxPR0VORD0iLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0iCgojIC0tLSBDb25maWcKIyBTZXQgR0lUX0RJUiBlaXRoZXIgZnJvbSB0aGUgd29ya2luZyBkaXJlY3RvcnksIG9yIGZyb20gdGhlIGVudmlyb25tZW50CiMgdmFyaWFibGUuCkdJVF9ESVI9JChnaXQgcmV2LXBhcnNlIC0tZ2l0LWRpciAyPi9kZXYvbnVsbCkKaWYgWyAteiAiJEdJVF9ESVIiIF07IHRoZW4KCWVjaG8gPiYyICJmYXRhbDogcG9zdC1yZWNlaXZlOiBHSVRfRElSIG5vdCBzZXQiCglleGl0IDEKZmkKCnByb2plY3RkZXNjPSQoc2VkIC1uZSAnMXAnICIkR0lUX0RJUi9kZXNjcmlwdGlvbiIpCiMgQ2hlY2sgaWYgdGhlIGRlc2NyaXB0aW9uIGlzIHVuY2hhbmdlZCBmcm9tIGl0J3MgZGVmYXVsdCwgYW5kIHNob3J0ZW4gaXQgdG8KIyBhIG1vcmUgbWFuYWdlYWJsZSBsZW5ndGggaWYgaXQgaXMKaWYgZXhwciAiJHByb2plY3RkZXNjIiA6ICJVbm5hbWVkIHJlcG9zaXRvcnkuKiQiID4vZGV2L251bGwKdGhlbgoJcHJvamVjdGRlc2M9IlVOTkFNRUQgUFJPSkVDVCIKZmkKCnJlY2lwaWVudHM9JChnaXQgY29uZmlnIGhvb2tzLm1haWxpbmdsaXN0KQphbm5vdW5jZXJlY2lwaWVudHM9JChnaXQgY29uZmlnIGhvb2tzLmFubm91bmNlbGlzdCkKZW52ZWxvcGVzZW5kZXI9JChnaXQgY29uZmlnIGhvb2tzLmVudmVsb3Blc2VuZGVyKQplbWFpbHByZWZpeD0kKGdpdCBjb25maWcgaG9va3MuZW1haWxwcmVmaXggfHwgZWNobyAnW1NDTV0gJykKY3VzdG9tX3Nob3dyZXY9JChnaXQgY29uZmlnIGhvb2tzLnNob3dyZXYpCm1heGxpbmVzPSQoZ2l0IGNvbmZpZyBob29rcy5lbWFpbG1heGxpbmVzKQoKIyAtLS0gTWFpbiBsb29wCiMgQWxsb3cgZHVhbCBtb2RlOiBydW4gZnJvbSB0aGUgY29tbWFuZCBsaW5lIGp1c3QgbGlrZSB0aGUgdXBkYXRlIGhvb2ssIG9yCiMgaWYgbm8gYXJndW1lbnRzIGFyZSBnaXZlbiB0aGVuIHJ1biBhcyBhIGhvb2sgc2NyaXB0CmlmIFsgLW4gIiQxIiAtYSAtbiAiJDIiIC1hIC1uICIkMyIgXTsgdGhlbgoJIyBPdXRwdXQgdG8gdGhlIHRlcm1pbmFsIGluIGNvbW1hbmQgbGluZSBtb2RlIC0gaWYgc29tZW9uZSB3YW50ZWQgdG8KCSMgcmVzZW5kIGFuIGVtYWlsOyB0aGV5IGNvdWxkIHJlZGlyZWN0IHRoZSBvdXRwdXQgdG8gc2VuZG1haWwKCSMgdGhlbXNlbHZlcwoJUEFHRVI9IGdlbmVyYXRlX2VtYWlsICQyICQzICQxCmVsc2UKCXdoaWxlIHJlYWQgb2xkcmV2IG5ld3JldiByZWZuYW1lCglkbwoJCWdlbmVyYXRlX2VtYWlsICRvbGRyZXYgJG5ld3JldiAkcmVmbmFtZSAkbWF4bGluZXMgfCBzZW5kX21haWwKCWRvbmUKZmkK",
    "text": "#!/bin/sh\n#\n# Copyright (c) 2007 Andy Parkins\n#\n# An example hook script to mail out commit update information.  This hook\n# sends emails listing new revisions to the repository introduced by the\n# change being reported.  The rule is that (for branch updates) each commit\n# will appear on one email and one email only.\n#\n# This hook is stored in the contrib/hooks directory.  Your distribution\n# will have put this somewhere standard.  You should make this script\n# executable then link to it in the repository you would like to use it in.\n# For example, on debian the hook is stored in\n# /usr/share/doc/git-core/contrib/hooks/post-receive-email:\n#\n#  chmod a+x post-receive-email\n#  cd /path/to/your/repository.git\n#  ln -sf /usr/share/doc/git-core/contrib/hooks/post-receive-email hooks/post-receive\n#\n# This hook script assumes it is enabled on the central repository of a\n# project, with all users pushing only to it and not between each other.  It\n# will still work if you don't operate in that style, but it would become\n# possible for the email to be from someone other than the person doing the\n# push.\n#\n# To help with debugging and use on pre-v1.5.1 git servers, this script will\n# also obey the interface of hooks/update, taking its arguments on the\n# command line.  Unfortunately, hooks/update is called once for each ref.\n# To avoid firing one email per ref, this script just prints its output to\n# the screen when used in this mode.  The output can then be redirected if\n# wanted.\n#\n# Config\n# ------\n# hooks.mailinglist\n#   This is the list that all pushes will go to; leave it blank to not send\n#   emails for every ref update.\n# hooks.announcelist\n#   This is the list that all pushes of annotated tags will go to.  Leave it\n#   blank to default to the mailinglist field.  The announce emails lists\n#   the short log summary of the changes since the last annotated tag.\n# hooks.envelopesender\n#   If set then the -f option is passed to sendmail to allow the envelope\n#   sender address to be set\n# hooks.emailprefix\n#   All emails have their subjects prefixed with this prefix, or \"[SCM]\"\n#   if emailprefix is unset, to aid filtering\n# hooks.showrev\n#   The shell command used to format each revision in the email, with\n#   \"%s\" replaced with the commit id.  Defaults to \"git rev-list -1\n#   --pretty %s\", displaying the commit id, author, date and log\n#   message.  To list full patches separated by a blank line, you\n#   could set this to \"git show -C %s; echo\".\n#   To list a gitweb/cgit URL *and* a full patch for each change set, use this:\n#     \"t=%s; printf 'http://.../?id=%%s' \\$t; echo;echo; git show -C \\$t; echo\"\n#   Be careful if \"...\" contains things that will be expanded by shell \"eval\"\n#   or printf.\n# hooks.emailmaxlines\n#   The maximum number of lines that should be included in the generated\n#   email body. If not specified, there is no limit.\n#   Lines beyond the limit are suppressed and counted, and a final\n#   line is added indicating the number of suppressed lines.\n#\n# Notes\n# -----\n# All emails include the headers \"X-Git-Refname\", \"X-Git-Oldrev\",\n# \"X-Git-Newrev\", and \"X-Git-Reftype\" to enable fine tuned filtering and\n# give information for debugging.\n#\n\n# ---------------------------- Functions\n\n#\n# Top level email generation function.  This decides what type of update\n# this is and calls the appropriate body-generation routine after outputting\n# the common header\n#\n# Note this function doesn't actually generate any email output, that is\n# taken care of by the functions it calls:\n#  - generate_email_header\n#  - generate_create_XXXX_email\n#  - generate_update_XXXX_email\n#  - generate_delete_XXXX_email\n#  - generate_email_footer\n#\ngenerate_email()\n{\n\t# --- Arguments\n\toldrev=$(git rev-parse $1)\n\tnewrev=$(git rev-parse $2)\n\trefname=\"$3\"\n\tmaxlines=$4\n\n\t# --- Interpret\n\t# 0000->1234 (create)\n\t# 1234->2345 (update)\n\t# 2345->0000 (delete)\n\tif expr \"$oldrev\" : '0*$' >/dev/null\n\tthen\n\t\tchange_type=\"create\"\n\telse\n\t\tif expr \"$newrev\" : '0*$' >/dev/null\n\t\tthen\n\t\t\tchange_type=\"delete\"\n\t\telse\n\t\t\tchange_type=\"update\"\n\t\tfi\n\tfi\n\n\t# --- Get the revision types\n\tnewrev_type=$(git cat-file -t $newrev 2> /dev/null)\n\toldrev_type=$(git cat-file -t \"$oldrev\" 2> /dev/null)\n\tcase \"$change_type\" in\n\tcreate|update)\n\t\trev=\"$newrev\"\n\t\trev_type=\"$newrev_type\"\n\t\t;;\n\tdelete)\n\t\trev=\"$oldrev\"\n\t\trev_type=\"$oldrev_type\"\n\t\t;;\n\tesac\n\n\t# The revision type tells us what type the commit is, combined with\n\t# the location of the ref we can decide between\n\t#  - working branch\n\t#  - tracking branch\n\t#  - unannoted tag\n\t#  - annotated tag\n\tcase \"$refname\",\"$rev_type\" in\n\t\trefs/tags/*,commit)\n\t\t\t# un-annotated tag\n\t\t\trefname_type=\"tag\"\n\t\t\tshort_refname=${refname##refs/tags/}\n\t\t\t;;\n\t\trefs/tags/*,tag)\n\t\t\t# annotated tag\n\t\t\trefname_type=\"annotated tag\"\n\t\t\tshort_refname=${refname##refs/tags/}\n\t\t\t# change recipients\n\t\t\tif [ -n \"$announcerecipients\" ]; then\n\t\t\t\trecipients=\"$announcerecipients\"\n\t\t\tfi\n\t\t\t;;\n\t\trefs/heads/*,commit)\n\t\t\t# branch\n\t\t\trefname_type=\"branch\"\n\t\t\tshort_refname=${refname##refs/heads/}\n\t\t\t;;\n\t\trefs/remotes/*,commit)\n\t\t\t# tracking branch\n\t\t\trefname_type=\"tracking branch\"\n\t\t\tshort_refname=${refname##refs/remotes/}\n\t\t\techo >&2 \"*** Push-update of tracking branch, $refname\"\n\t\t\techo >&2 \"***  - no email generated.\"\n\t\t\texit 0\n\t\t\t;;\n\t\t*)\n\t\t\t# Anything else (is there anything else?)\n\t\t\techo >&2 \"*** Unknown type of update to $refname ($rev_type)\"\n\t\t\techo >&2 \"***  - no email generated\"\n\t\t\texit 1\n\t\t\t;;\n\tesac\n\n\t# Check if we've got anyone to send to\n\tif [ -z \"$recipients\" ]; then\n\t\tcase \"$refname_type\" in\n\t\t\t\"annotated tag\")\n\t\t\t\tconfig_name=\"hooks.announcelist\"\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tconfig_name=\"hooks.mailinglist\"\n\t\t\t\t;;\n\t\tesac\n\t\techo >&2 \"*** $config_name is not set so no email will be sent\"\n\t\techo >&2 \"*** for $refname update $oldrev->$newrev\"\n\t\texit 0\n\tfi\n\n\t# Email parameters\n\t# The email subject will contain the best description of the ref\n\t# that we can build from the parameters\n\tdescribe=$(git describe $rev 2>/dev/null)\n\tif [ -z \"$describe\" ]; then\n\t\tdescribe=$rev\n\tfi\n\n\tgenerate_email_header\n\n\t# Call the correct body generation function\n\tfn_name=general\n\tcase \"$refname_type\" in\n\t\"tracking branch\"|branch)\n\t\tfn_name=branch\n\t\t;;\n\t\"annotated tag\")\n\t\tfn_name=atag\n\t\t;;\n\tesac\n\n\tif [ -z \"$maxlines\" ]; then\n\t\tgenerate_${change_type}_${fn_name}_email\n\telse\n\t\tgenerate_${change_type}_${fn_name}_email | limit_lines $maxlines\n\tfi\n\n\tgenerate_email_footer\n}\n\ngenerate_email_header()\n{\n\t# --- Email (all stdout will be the email)\n\t# Generate header\n\tcat <<-EOF\n\tTo: $recipients\n\tSubject: ${emailprefix}$projectdesc $refname_type $short_refname ${change_type}d. $describe\n\tX-Git-Refname: $refname\n\tX-Git-Reftype: $refname_type\n\tX-Git-Oldrev: $oldrev\n\tX-Git-Newrev: $newrev\n\n\tThis is an automated email from the git hooks/post-receive script. It was\n\tgenerated because a ref change was pushed to the repository containing\n\tthe project \"$projectdesc\".\n\n\tThe $refname_type, $short_refname has been ${change_type}d\n\tEOF\n}\n\ngenerate_email_footer()\n{\n\tSPACE=\" \"\n\tcat <<-EOF\n\n\n\thooks/post-receive\n\t--${SPACE}\n\t$projectdesc\n\tEOF\n}\n\n# --------------- Branches\n\n#\n# Called for the creation of a branch\n#\ngenerate_create_branch_email()\n{\n\t# This is a new branch and so oldrev is not valid\n\techo \"        at  $newrev ($newrev_type)\"\n\techo \"\"\n\n\techo $LOGBEGIN\n\tshow_new_revisions\n\techo $LOGEND\n}\n\n#\n# Called for the change of a pre-existing branch\n#\ngenerate_update_branch_email()\n{\n\t# Consider this:\n\t#   1 --- 2 --- O --- X --- 3 --- 4 --- N\n\t#\n\t# O is $oldrev for $refname\n\t# N is $newrev for $refname\n\t# X is a revision pointed to by some other ref, for which we may\n\t#   assume that an email has already been generated.\n\t# In this case we want to issue an email containing only revisions\n\t# 3, 4, and N.  Given (almost) by\n\t#\n\t#  git rev-list N ^O --not --all\n\t#\n\t# The reason for the \"almost\", is that the \"--not --all\" will take\n\t# precedence over the \"N\", and effectively will translate to\n\t#\n\t#  git rev-list N ^O ^X ^N\n\t#\n\t# So, we need to build up the list more carefully.  git rev-parse\n\t# will generate a list of revs that may be fed into git rev-list.\n\t# We can get it to make the \"--not --all\" part and then filter out\n\t# the \"^N\" with:\n\t#\n\t#  git rev-parse --not --all | grep -v N\n\t#\n\t# Then, using the --stdin switch to git rev-list we have effectively\n\t# manufactured\n\t#\n\t#  git rev-list N ^O ^X\n\t#\n\t# This leaves a problem when someone else updates the repository\n\t# while this script is running.  Their new value of the ref we're\n\t# working on would be included in the \"--not --all\" output; and as\n\t# our $newrev would be an ancestor of that commit, it would exclude\n\t# all of our commits.  What we really want is to exclude the current\n\t# value of $refname from the --not list, rather than N itself.  So:\n\t#\n\t#  git rev-parse --not --all | grep -v $(git rev-parse $refname)\n\t#\n\t# Get's us to something pretty safe (apart from the small time\n\t# between refname being read, and git rev-parse running - for that,\n\t# I give up)\n\t#\n\t#\n\t# Next problem, consider this:\n\t#   * --- B --- * --- O ($oldrev)\n\t#          \\\n\t#           * --- X --- * --- N ($newrev)\n\t#\n\t# That is to say, there is no guarantee that oldrev is a strict\n\t# subset of newrev (it would have required a --force, but that's\n\t# allowed).  So, we can't simply say rev-list $oldrev..$newrev.\n\t# Instead we find the common base of the two revs and list from\n\t# there.\n\t#\n\t# As above, we need to take into account the presence of X; if\n\t# another branch is already in the repository and points at some of\n\t# the revisions that we are about to output - we don't want them.\n\t# The solution is as before: git rev-parse output filtered.\n\t#\n\t# Finally, tags: 1 --- 2 --- O --- T --- 3 --- 4 --- N\n\t#\n\t# Tags pushed into the repository generate nice shortlog emails that\n\t# summarise the commits between them and the previous tag.  However,\n\t# those emails don't include the full commit messages that we output\n\t# for a branch update.  Therefore we still want to output revisions\n\t# that have been output on a tag email.\n\t#\n\t# Luckily, git rev-parse includes just the tool.  Instead of using\n\t# \"--all\" we use \"--branches\"; this has the added benefit that\n\t# \"remotes/\" will be ignored as well.\n\n\t# List all of the revisions that were removed by this update, in a\n\t# fast-forward update, this list will be empty, because rev-list O\n\t# ^N is empty.  For a non-fast-forward, O ^N is the list of removed\n\t# revisions\n\tfast_forward=\"\"\n\trev=\"\"\n\tfor rev in $(git rev-list $newrev..$oldrev)\n\tdo\n\t\trevtype=$(git cat-file -t \"$rev\")\n\t\techo \"  discards  $rev ($revtype)\"\n\tdone\n\tif [ -z \"$rev\" ]; then\n\t\tfast_forward=1\n\tfi\n\n\t# List all the revisions from baserev to newrev in a kind of\n\t# \"table-of-contents\"; note this list can include revisions that\n\t# have already had notification emails and is present to show the\n\t# full detail of the change from rolling back the old revision to\n\t# the base revision and then forward to the new revision\n\tfor rev in $(git rev-list $oldrev..$newrev)\n\tdo\n\t\trevtype=$(git cat-file -t \"$rev\")\n\t\techo \"       via  $rev ($revtype)\"\n\tdone\n\n\tif [ \"$fast_forward\" ]; then\n\t\techo \"      from  $oldrev ($oldrev_type)\"\n\telse\n\t\t#  1. Existing revisions were removed.  In this case newrev\n\t\t#     is a subset of oldrev - this is the reverse of a\n\t\t#     fast-forward, a rewind\n\t\t#  2. New revisions were added on top of an old revision,\n\t\t#     this is a rewind and addition.\n\n\t\t# (1) certainly happened, (2) possibly.  When (2) hasn't\n\t\t# happened, we set a flag to indicate that no log printout\n\t\t# is required.\n\n\t\techo \"\"\n\n\t\t# Find the common ancestor of the old and new revisions and\n\t\t# compare it with newrev\n\t\tbaserev=$(git merge-base $oldrev $newrev)\n\t\trewind_only=\"\"\n\t\tif [ \"$baserev\" = \"$newrev\" ]; then\n\t\t\techo \"This update discarded existing revisions and left the branch pointing at\"\n\t\t\techo \"a previous point in the repository history.\"\n\t\t\techo \"\"\n\t\t\techo \" * -- * -- N ($newrev)\"\n\t\t\techo \"            \\\\\"\n\t\t\techo \"             O -- O -- O ($oldrev)\"\n\t\t\techo \"\"\n\t\t\techo \"The removed revisions are not necessarilly gone - if another reference\"\n\t\t\techo \"still refers to them they will stay in the repository.\"\n\t\t\trewind_only=1\n\t\telse\n\t\t\techo \"This update added new revisions after undoing existing revisions.  That is\"\n\t\t\techo \"to say, the old revision is not a strict subset of the new revision.  This\"\n\t\t\techo \"situation occurs when you --force push a change and generate a repository\"\n\t\t\techo \"containing something like this:\"\n\t\t\techo \"\"\n\t\t\techo \" * -- * -- B -- O -- O -- O ($oldrev)\"\n\t\t\techo \"            \\\\\"\n\t\t\techo \"             N -- N -- N ($newrev)\"\n\t\t\techo \"\"\n\t\t\techo \"When this happens we assume that you've already had alert emails for all\"\n\t\t\techo \"of the O revisions, and so we here report only the revisions in the N\"\n\t\t\techo \"branch from the common base, B.\"\n\t\tfi\n\tfi\n\n\techo \"\"\n\tif [ -z \"$rewind_only\" ]; then\n\t\techo \"Those revisions listed above that are new to this repository have\"\n\t\techo \"not appeared on any other notification email; so we list those\"\n\t\techo \"revisions in full, below.\"\n\n\t\techo \"\"\n\t\techo $LOGBEGIN\n\t\tshow_new_revisions\n\n\t\t# XXX: Need a way of detecting whether git rev-list actually\n\t\t# outputted anything, so that we can issue a \"no new\n\t\t# revisions added by this update\" message\n\n\t\techo $LOGEND\n\telse\n\t\techo \"No new revisions were added by this update.\"\n\tfi\n\n\t# The diffstat is shown from the old revision to the new revision.\n\t# This is to show the truth of what happened in this change.\n\t# There's no point showing the stat from the base to the new\n\t# revision because the base is effectively a random revision at this\n\t# point - the user will be interested in what this revision changed\n\t# - including the undoing of previous revisions in the case of\n\t# non-fast-forward updates.\n\techo \"\"\n\techo \"Summary of changes:\"\n\tgit diff-tree --stat --summary --find-copies-harder $oldrev..$newrev\n}\n\n#\n# Called for the deletion of a branch\n#\ngenerate_delete_branch_email()\n{\n\techo \"       was  $oldrev\"\n\techo \"\"\n\techo $LOGEND\n\tgit show -s --pretty=oneline $oldrev\n\techo $LOGEND\n}\n\n# --------------- Annotated tags\n\n#\n# Called for the creation of an annotated tag\n#\ngenerate_create_atag_email()\n{\n\techo \"        at  $newrev ($newrev_type)\"\n\n\tgenerate_atag_email\n}\n\n#\n# Called for the update of an annotated tag (this is probably a rare event\n# and may not even be allowed)\n#\ngenerate_update_atag_email()\n{\n\techo \"        to  $newrev ($newrev_type)\"\n\techo \"      from  $oldrev (which is now obsolete)\"\n\n\tgenerate_atag_email\n}\n\n#\n# Called when an annotated tag is created or changed\n#\ngenerate_atag_email()\n{\n\t# Use git for-each-ref to pull out the individual fields from the\n\t# tag\n\teval $(git for-each-ref --shell --format='\n\ttagobject=%(*objectname)\n\ttagtype=%(*objecttype)\n\ttagger=%(taggername)\n\ttagged=%(taggerdate)' $refname\n\t)\n\n\techo \"   tagging  $tagobject ($tagtype)\"\n\tcase \"$tagtype\" in\n\tcommit)\n\n\t\t# If the tagged object is a commit, then we assume this is a\n\t\t# release, and so we calculate which tag this tag is\n\t\t# replacing\n\t\tprevtag=$(git describe --abbrev=0 $newrev^ 2>/dev/null)\n\n\t\tif [ -n \"$prevtag\" ]; then\n\t\t\techo \"  replaces  $prevtag\"\n\t\tfi\n\t\t;;\n\t*)\n\t\techo \"    length  $(git cat-file -s $tagobject) bytes\"\n\t\t;;\n\tesac\n\techo \" tagged by  $tagger\"\n\techo \"        on  $tagged\"\n\n\techo \"\"\n\techo $LOGBEGIN\n\n\t# Show the content of the tag message; this might contain a change\n\t# log or release notes so is worth displaying.\n\tgit cat-file tag $newrev | sed -e '1,/^$/d'\n\n\techo \"\"\n\tcase \"$tagtype\" in\n\tcommit)\n\t\t# Only commit tags make sense to have rev-list operations\n\t\t# performed on them\n\t\tif [ -n \"$prevtag\" ]; then\n\t\t\t# Show changes since the previous release\n\t\t\tgit rev-list --pretty=short \"$prevtag..$newrev\" | git shortlog\n\t\telse\n\t\t\t# No previous tag, show all the changes since time\n\t\t\t# began\n\t\t\tgit rev-list --pretty=short $newrev | git shortlog\n\t\tfi\n\t\t;;\n\t*)\n\t\t# XXX: Is there anything useful we can do for non-commit\n\t\t# objects?\n\t\t;;\n\tesac\n\n\techo $LOGEND\n}\n\n#\n# Called for the deletion of an annotated tag\n#\ngenerate_delete_atag_email()\n{\n\techo \"       was  $oldrev\"\n\techo \"\"\n\techo $LOGEND\n\tgit show -s --pretty=oneline $oldrev\n\techo $LOGEND\n}\n\n# --------------- General references\n\n#\n# Called when any other type of reference is created (most likely a\n# non-annotated tag)\n#\ngenerate_create_general_email()\n{\n\techo \"        at  $newrev ($newrev_type)\"\n\n\tgenerate_general_email\n}\n\n#\n# Called when any other type of reference is updated (most likely a\n# non-annotated tag)\n#\ngenerate_update_general_email()\n{\n\techo \"        to  $newrev ($newrev_type)\"\n\techo \"      from  $oldrev\"\n\n\tgenerate_general_email\n}\n\n#\n# Called for creation or update of any other type of reference\n#\ngenerate_general_email()\n{\n\t# Unannotated tags are more about marking a point than releasing a\n\t# version; therefore we don't do the shortlog summary that we do for\n\t# annotated tags above - we simply show that the point has been\n\t# marked, and print the log message for the marked point for\n\t# reference purposes\n\t#\n\t# Note this section also catches any other reference type (although\n\t# there aren't any) and deals with them in the same way.\n\n\techo \"\"\n\tif [ \"$newrev_type\" = \"commit\" ]; then\n\t\techo $LOGBEGIN\n\t\tgit show --no-color --root -s --pretty=medium $newrev\n\t\techo $LOGEND\n\telse\n\t\t# What can we do here?  The tag marks an object that is not\n\t\t# a commit, so there is no log for us to display.  It's\n\t\t# probably not wise to output git cat-file as it could be a\n\t\t# binary blob.  We'll just say how big it is\n\t\techo \"$newrev is a $newrev_type, and is $(git cat-file -s $newrev) bytes long.\"\n\tfi\n}\n\n#\n# Called for the deletion of any other type of reference\n#\ngenerate_delete_general_email()\n{\n\techo \"       was  $oldrev\"\n\techo \"\"\n\techo $LOGEND\n\tgit show -s --pretty=oneline $oldrev\n\techo $LOGEND\n}\n\n\n# --------------- Miscellaneous utilities\n\n#\n# Show new revisions as the user would like to see them in the email.\n#\nshow_new_revisions()\n{\n\t# This shows all log entries that are not already covered by\n\t# another ref - i.e. commits that are now accessible from this\n\t# ref that were previously not accessible\n\t# (see generate_update_branch_email for the explanation of this\n\t# command)\n\n\t# Revision range passed to rev-list differs for new vs. updated\n\t# branches.\n\tif [ \"$change_type\" = create ]\n\tthen\n\t\t# Show all revisions exclusive to this (new) branch.\n\t\trevspec=$newrev\n\telse\n\t\t# Branch update; show revisions not part of $oldrev.\n\t\trevspec=$oldrev..$newrev\n\tfi\n\n\tother_branches=$(git for-each-ref --format='%(refname)' refs/heads/ |\n\t    grep -F -v $refname)\n\tgit rev-parse --not $other_branches |\n\tif [ -z \"$custom_showrev\" ]\n\tthen\n\t\tgit rev-list --pretty --stdin $revspec\n\telse\n\t\tgit rev-list --stdin $revspec |\n\t\twhile read onerev\n\t\tdo\n\t\t\teval $(printf \"$custom_showrev\" $onerev)\n\t\tdone\n\tfi\n}\n\n\nlimit_lines()\n{\n\tlines=0\n\tskipped=0\n\twhile IFS=\"\" read -r line; do\n\t\tlines=$((lines + 1))\n\t\tif [ $lines -gt $1 ]; then\n\t\t\tskipped=$((skipped + 1))\n\t\telse\n\t\t\tprintf \"%s\\n\" \"$line\"\n\t\tfi\n\tdone\n\tif [ $skipped -ne 0 ]; then\n\t\techo \"... $skipped lines suppressed ...\"\n\tfi\n}\n\n\nsend_mail()\n{\n\tif [ -n \"$envelopesender\" ]; then\n\t\t/usr/sbin/sendmail -t -f \"$envelopesender\"\n\telse\n\t\t/usr/sbin/sendmail -t\n\tfi\n}\n\n# ---------------------------- main()\n\n# --- Constants\nLOGBEGIN=\"- Log -----------------------------------------------------------------\"\nLOGEND=\"-----------------------------------------------------------------------\"\n\n# --- Config\n# Set GIT_DIR either from the working directory, or from the environment\n# variable.\nGIT_DIR=$(git rev-parse --git-dir 2>/dev/null)\nif [ -z \"$GIT_DIR\" ]; then\n\techo >&2 \"fatal: post-receive: GIT_DIR not set\"\n\texit 1\nfi\n\nprojectdesc=$(sed -ne '1p' \"$GIT_DIR/description\")\n# Check if the description is unchanged from it's default, and shorten it to\n# a more manageable length if it is\nif expr \"$projectdesc\" : \"Unnamed repository.*$\" >/dev/null\nthen\n\tprojectdesc=\"UNNAMED PROJECT\"\nfi\n\nrecipients=$(git config hooks.mailinglist)\nannouncerecipients=$(git config hooks.announcelist)\nenvelopesender=$(git config hooks.envelopesender)\nemailprefix=$(git config hooks.emailprefix || echo '[SCM] ')\ncustom_showrev=$(git config hooks.showrev)\nmaxlines=$(git config hooks.emailmaxlines)\n\n# --- Main loop\n# Allow dual mode: run from the command line just like the update hook, or\n# if no arguments are given then run as a hook script\nif [ -n \"$1\" -a -n \"$2\" -a -n \"$3\" ]; then\n\t# Output to the terminal in command line mode - if someone wanted to\n\t# resend an email; they could redirect the output to sendmail\n\t# themselves\n\tPAGER= generate_email $2 $3 $1\nelse\n\twhile read oldrev newrev refname\n\tdo\n\t\tgenerate_email $oldrev $newrev $refname $maxlines | send_mail\n\tdone\nfi\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00850864371e16d1fa572b0d0e5832b8a88d8666",
  "sha1_ok": true,
  "size": 20679
}
