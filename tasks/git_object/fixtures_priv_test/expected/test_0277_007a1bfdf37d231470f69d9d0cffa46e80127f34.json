{
  "content": {
    "base64": "IyEvdXNyL2Jpbi9lbnYgcHl0aG9uCgoiIiJGdW5jdGlvbmFsaXR5IGZvciBpbnRlcmFjdGluZyB3aXRoIEdpdCByZXBvc2l0b3JpZXMuCgpUaGlzIG1vZHVsZSBwcm92aWRlcyBjbGFzc2VzIGZvciBpbnRlcmZhY2luZyB3aXRoIGEgR2l0IHJlcG9zaXRvcnkuCiIiIgoKaW1wb3J0IG9zCmltcG9ydCByZQppbXBvcnQgdGltZQpmcm9tIGJpbmFzY2lpIGltcG9ydCBoZXhsaWZ5CmZyb20gY1N0cmluZ0lPIGltcG9ydCBTdHJpbmdJTwppbXBvcnQgdW5pdHRlc3QKCmZyb20gZ2l0X3JlbW90ZV9oZWxwZXJzLnV0aWwgaW1wb3J0IGRlYnVnLCBlcnJvciwgZGllLCBzdGFydF9jb21tYW5kLCBydW5fY29tbWFuZAoKCmRlZiBnZXRfZ2l0X2RpciAoKToKICAgICIiIlJldHVybiB0aGUgcGF0aCB0byB0aGUgR0lUX0RJUiBmb3IgdGhpcyByZXBvLiIiIgogICAgYXJncyA9ICgiZ2l0IiwgInJldi1wYXJzZSIsICItLWdpdC1kaXIiKQogICAgZXhpdF9jb2RlLCBvdXRwdXQsIGVycm9ycyA9IHJ1bl9jb21tYW5kKGFyZ3MpCiAgICBpZiBleGl0X2NvZGU6CiAgICAgICAgZGllKCJGYWlsZWQgdG8gcmV0cmlldmUgZ2l0IGRpciIpCiAgICBhc3NlcnQgbm90IGVycm9ycwogICAgcmV0dXJuIG91dHB1dC5zdHJpcCgpCgoKZGVmIHBhcnNlX2dpdF9jb25maWcgKCk6CiAgICAiIiJSZXR1cm4gYSBkaWN0IGNvbnRhaW5pbmcgdGhlIHBhcnNlZCB2ZXJzaW9uIG9mICdnaXQgY29uZmlnIC1sJy4iIiIKICAgIGV4aXRfY29kZSwgb3V0cHV0LCBlcnJvcnMgPSBydW5fY29tbWFuZCgoImdpdCIsICJjb25maWciLCAiLXoiLCAiLWwiKSkKICAgIGlmIGV4aXRfY29kZToKICAgICAgICBkaWUoIkZhaWxlZCB0byByZXRyaWV2ZSBnaXQgY29uZmlndXJhdGlvbiIpCiAgICBhc3NlcnQgbm90IGVycm9ycwogICAgcmV0dXJuIGRpY3QoW2Uuc3BsaXQoJ1xuJywgMSkgZm9yIGUgaW4gb3V0cHV0LnNwbGl0KCJcMCIpIGlmIGVdKQoKCmRlZiBnaXRfY29uZmlnX2Jvb2wgKHZhbHVlKToKICAgICIiIkNvbnZlcnQgdGhlIGdpdmVuIGdpdCBjb25maWcgc3RyaW5nIHZhbHVlIHRvIFRydWUgb3IgRmFsc2UuCgogICAgUmFpc2UgVmFsdWVFcnJvciBpZiB0aGUgZ2l2ZW4gc3RyaW5nIHdhcyBub3QgcmVjb2duaXplZCBhcyBhCiAgICBib29sZWFuIHZhbHVlLgoKICAgICIiIgogICAgbm9ybV92YWx1ZSA9IHN0cih2YWx1ZSkuc3RyaXAoKS5sb3dlcigpCiAgICBpZiBub3JtX3ZhbHVlIGluICgidHJ1ZSIsICIxIiwgInllcyIsICJvbiIsICIiKToKICAgICAgICByZXR1cm4gVHJ1ZQogICAgaWYgbm9ybV92YWx1ZSBpbiAoImZhbHNlIiwgIjAiLCAibm8iLCAib2ZmIiwgIm5vbmUiKToKICAgICAgICByZXR1cm4gRmFsc2UKICAgIHJhaXNlIFZhbHVlRXJyb3IoIkZhaWxlZCB0byBwYXJzZSAnJXMnIGludG8gYSBib29sZWFuIHZhbHVlIiAlICh2YWx1ZSkpCgoKZGVmIHZhbGlkX2dpdF9yZWYgKHJlZl9uYW1lKToKICAgICIiIlJldHVybiBUcnVlIGlmZiB0aGUgZ2l2ZW4gcmVmIG5hbWUgaXMgYSB2YWxpZCBnaXQgcmVmIG5hbWUuIiIiCiAgICAjIFRoZSBmb2xsb3dpbmcgaXMgYSByZWltcGxlbWVudGF0aW9uIG9mIHRoZSBnaXQgY2hlY2stcmVmLWZvcm1hdAogICAgIyBjb21tYW5kLiAgVGhlIHJ1bGVzIHdlcmUgZGVyaXZlZCBmcm9tIHRoZSBnaXQgY2hlY2stcmVmLWZvcm1hdCgxKQogICAgIyBtYW51YWwgcGFnZS4gIFRoaXMgY29kZSBzaG91bGQgYmUgcmVwbGFjZWQgYnkgYSBjYWxsIHRvCiAgICAjIGNoZWNrX3JlZm5hbWVfZm9ybWF0KCkgaW4gdGhlIGdpdCBsaWJyYXJ5LCB3aGVuIHN1Y2ggaXMgYXZhaWxhYmxlLgogICAgaWYgcmVmX25hbWUuZW5kc3dpdGgoJy8nKSBvciBcCiAgICAgICByZWZfbmFtZS5zdGFydHN3aXRoKCcuJykgb3IgXAogICAgICAgcmVmX25hbWUuY291bnQoJy8uJykgb3IgXAogICAgICAgcmVmX25hbWUuY291bnQoJy4uJykgb3IgXAogICAgICAgcmVmX25hbWUuZW5kc3dpdGgoJy5sb2NrJyk6CiAgICAgICAgcmV0dXJuIEZhbHNlCiAgICBmb3IgYyBpbiByZWZfbmFtZToKICAgICAgICBpZiBvcmQoYykgPCAweDIwIG9yIG9yZChjKSA9PSAweDdmIG9yIGMgaW4gIiB+Xjo/KlsiOgogICAgICAgICAgICByZXR1cm4gRmFsc2UKICAgIHJldHVybiBUcnVlCgoKY2xhc3MgR2l0T2JqZWN0RmV0Y2hlcihvYmplY3QpOgoKICAgICIiIlByb3ZpZGUgcGFyc2VkIGFjY2VzcyB0byAnZ2l0IGNhdC1maWxlIC0tYmF0Y2gnLgoKICAgIFRoaXMgcHJvdmlkZXMgYSByZWFkLW9ubHkgaW50ZXJmYWNlIHRvIHRoZSBHaXQgb2JqZWN0IGRhdGFiYXNlLgoKICAgICIiIgoKICAgIGRlZiBfX2luaXRfXyAoc2VsZik6CiAgICAgICAgIiIiSW5pdGlhdGUgYSAnZ2l0IGNhdC1maWxlIC0tYmF0Y2gnIHNlc3Npb24uIiIiCiAgICAgICAgc2VsZi5xdWV1ZSA9IFtdICAjIExpc3Qgb2Ygb2JqZWN0IG5hbWVzIHRvIGJlIHN1Ym1pdHRlZAogICAgICAgIHNlbGYuaW5fdHJhbnNpdCA9IE5vbmUgICMgT2JqZWN0IG5hbWUgY3VycmVudGx5IGluIHRyYW5zaXQKCiAgICAgICAgIyAnZ2l0IGNhdC1maWxlIC0tYmF0Y2gnIHByb2R1Y2VzIGJpbmFyeSBvdXRwdXQgd2hpY2ggaXMgbGlrZWx5CiAgICAgICAgIyB0byBiZSBjb3JydXB0ZWQgYnkgdGhlIGRlZmF1bHQgInJVIi1tb2RlIHBpcGUgb3BlbmVkIGJ5CiAgICAgICAgIyBzdGFydF9jb21tYW5kLiAgKE1vZGUgPT0gInJVIiBkb2VzIHVuaXZlcnNhbCBuZXctbGluZQogICAgICAgICMgY29udmVyc2lvbiwgd2hpY2ggbWFuZ2xlcyBjYXJyaWFnZSByZXR1cm5zLikgVGhlcmVmb3JlLCB3ZQogICAgICAgICMgb3BlbiBhbiBleHBsaWNpdGx5IGJpbmFyeS1zYWZlIHBpcGUgZm9yIHRyYW5zZmVycmluZyB0aGUKICAgICAgICAjIG91dHB1dCBmcm9tICdnaXQgY2F0LWZpbGUgLS1iYXRjaCcuCiAgICAgICAgcGlwZV9yX2ZkLCBwaXBlX3dfZmQgPSBvcy5waXBlKCkKICAgICAgICBwaXBlX3IgPSBvcy5mZG9wZW4ocGlwZV9yX2ZkLCAicmIiKQogICAgICAgIHBpcGVfdyA9IG9zLmZkb3BlbihwaXBlX3dfZmQsICJ3YiIpCiAgICAgICAgc2VsZi5wcm9jID0gc3RhcnRfY29tbWFuZCgoImdpdCIsICJjYXQtZmlsZSIsICItLWJhdGNoIiksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGRvdXQgPSBwaXBlX3cpCiAgICAgICAgc2VsZi5mID0gcGlwZV9yCgogICAgZGVmIF9fZGVsX18gKHNlbGYpOgogICAgICAgICIiIlZlcmlmeSBjb21wbGV0ZWQgY29tbXVuaWNhdGlvbiB3aXRoICdnaXQgY2F0LWZpbGUgLS1iYXRjaCcuIiIiCiAgICAgICAgYXNzZXJ0IG5vdCBzZWxmLnF1ZXVlCiAgICAgICAgYXNzZXJ0IHNlbGYuaW5fdHJhbnNpdCBpcyBOb25lCiAgICAgICAgc2VsZi5wcm9jLnN0ZGluLmNsb3NlKCkKICAgICAgICBhc3NlcnQgc2VsZi5wcm9jLndhaXQoKSA9PSAwICAjIFplcm8gZXhpdCBjb2RlCiAgICAgICAgYXNzZXJ0IHNlbGYuZi5yZWFkKCkgPT0gIiIgICMgTm8gcmVtYWluaW5nIG91dHB1dAoKICAgIGRlZiBfc3VibWl0X25leHRfb2JqZWN0IChzZWxmKToKICAgICAgICAiIiJTdWJtaXQgcXVldWUgaXRlbXMgdG8gdGhlICdnaXQgY2F0LWZpbGUgLS1iYXRjaCcgcHJvY2Vzcy4KCiAgICAgICAgSWYgdGhlcmUgYXJlIGl0ZW1zIGluIHRoZSBxdWV1ZSwgYW5kIHRoZXJlIGlzIGN1cnJlbnRseSBubyBpdGVtCiAgICAgICAgY3VycmVudGx5IGluICd0cmFuc2l0JywgdGhlbiBwb3AgdGhlIGZpcnN0IGl0ZW0gb2ZmIHRoZSBxdWV1ZSwKICAgICAgICBhbmQgc3VibWl0IGl0LgoKICAgICAgICAiIiIKICAgICAgICBpZiBzZWxmLnF1ZXVlIGFuZCBzZWxmLmluX3RyYW5zaXQgaXMgTm9uZToKICAgICAgICAgICAgc2VsZi5pbl90cmFuc2l0ID0gc2VsZi5xdWV1ZS5wb3AoMCkKICAgICAgICAgICAgcHJpbnQgPj4gc2VsZi5wcm9jLnN0ZGluLCBzZWxmLmluX3RyYW5zaXRbMF0KCiAgICBkZWYgcHVzaCAoc2VsZiwgb2JqLCBjYWxsYmFjayk6CiAgICAgICAgIiIiUHVzaCB0aGUgZ2l2ZW4gb2JqZWN0IG5hbWUgb250byB0aGUgcXVldWUuCgogICAgICAgIFRoZSBnaXZlbiBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZQogICAgICAgIGJlIGNhbGxlZCBleGFjdGx5IG9uY2Ugd2l0aCB0aGUgZm9sbG93aW5nIGFyZ3VtZW50czoKICAgICAgICAtIHNlbGYgLSB0aGlzIEdpdE9iamVjdEZldGNoZXIgaW5zdGFuY2UKICAgICAgICAtIG9iaiAgLSB0aGUgb2JqZWN0IG5hbWUgcHJvdmlkZWQgdG8gcHVzaCgpCiAgICAgICAgLSBzaGExIC0gdGhlIFNIQTEgb2YgdGhlIG9iamVjdCwgaWYgJ05vbmUnIG9iaiBpcyBtaXNzaW5nCiAgICAgICAgLSB0ICAgIC0gdGhlIHR5cGUgb2YgdGhlIG9iamVjdCAodGFnL2NvbW1pdC90cmVlL2Jsb2IpCiAgICAgICAgLSBzaXplIC0gdGhlIHNpemUgb2YgdGhlIG9iamVjdCBpbiBieXRlcwogICAgICAgIC0gZGF0YSAtIHRoZSBvYmplY3QgY29udGVudHMKCiAgICAgICAgIiIiCiAgICAgICAgc2VsZi5xdWV1ZS5hcHBlbmQoKG9iaiwgY2FsbGJhY2spKQogICAgICAgIHNlbGYuX3N1Ym1pdF9uZXh0X29iamVjdCgpICAjIChSZSlzdGFydCBxdWV1ZSBwcm9jZXNzaW5nCgogICAgZGVmIHByb2Nlc3NfbmV4dF9lbnRyeSAoc2VsZik6CiAgICAgICAgIiIiUmVhZCB0aGUgbmV4dCBlbnRyeSBvZmYgdGhlIHF1ZXVlIGFuZCBpbnZva2UgY2FsbGJhY2suIiIiCiAgICAgICAgb2JqLCBjYiA9IHNlbGYuaW5fdHJhbnNpdAogICAgICAgIHNlbGYuaW5fdHJhbnNpdCA9IE5vbmUKICAgICAgICBoZWFkZXIgPSBzZWxmLmYucmVhZGxpbmUoKQogICAgICAgIGlmIGhlYWRlciA9PSAiJXMgbWlzc2luZ1xuIiAlIChvYmopOgogICAgICAgICAgICBjYihzZWxmLCBvYmosIE5vbmUsIE5vbmUsIE5vbmUsIE5vbmUpCiAgICAgICAgICAgIHJldHVybgogICAgICAgIHNoYTEsIHQsIHNpemUgPSBoZWFkZXIuc3BsaXQoIiAiKQogICAgICAgIGFzc2VydCBsZW4oc2hhMSkgPT0gNDAKICAgICAgICBhc3NlcnQgdCBpbiAoInRhZyIsICJjb21taXQiLCAidHJlZSIsICJibG9iIikKICAgICAgICBhc3NlcnQgc2l6ZS5lbmRzd2l0aCgiXG4iKQogICAgICAgIHNpemUgPSBpbnQoc2l6ZS5zdHJpcCgpKQogICAgICAgIGRhdGEgPSBzZWxmLmYucmVhZChzaXplKQogICAgICAgIGFzc2VydCBzZWxmLmYucmVhZCgxKSA9PSAiXG4iCiAgICAgICAgY2Ioc2VsZiwgb2JqLCBzaGExLCB0LCBzaXplLCBkYXRhKQogICAgICAgIHNlbGYuX3N1Ym1pdF9uZXh0X29iamVjdCgpCgogICAgZGVmIHByb2Nlc3MgKHNlbGYpOgogICAgICAgICIiIlByb2Nlc3MgdGhlIGN1cnJlbnQgcXVldWUgdW50aWwgZW1wdHkuIiIiCiAgICAgICAgd2hpbGUgc2VsZi5pbl90cmFuc2l0IGlzIG5vdCBOb25lOgogICAgICAgICAgICBzZWxmLnByb2Nlc3NfbmV4dF9lbnRyeSgpCgogICAgIyBIaWdoLWxldmVsIGNvbnZlbmllbmNlIG1ldGhvZHM6CgogICAgZGVmIGdldF9zaGExIChzZWxmLCBvYmpzcGVjKToKICAgICAgICAiIiJSZXR1cm4gdGhlIFNIQTEgb2YgdGhlIG9iamVjdCBzcGVjaWZpZWQgYnkgJ29ianNwZWMnLgoKICAgICAgICBSZXR1cm4gTm9uZSBpZiAnb2Jqc3BlYycgZG9lcyBub3Qgc3BlY2lmeSBhbiBleGlzdGluZyBvYmplY3QuCgogICAgICAgICIiIgogICAgICAgIGNsYXNzIF9PYmpIYW5kbGVyKG9iamVjdCk6CiAgICAgICAgICAgICIiIkhlbHBlciBjbGFzcyBmb3IgZ2V0dGluZyB0aGUgcmV0dXJuZWQgU0hBMS4iIiIKICAgICAgICAgICAgZGVmIF9faW5pdF9fIChzZWxmLCBwYXJzZXIpOgogICAgICAgICAgICAgICAgc2VsZi5wYXJzZXIgPSBwYXJzZXIKICAgICAgICAgICAgICAgIHNlbGYuc2hhMSA9IE5vbmUKCiAgICAgICAgICAgIGRlZiBfX2NhbGxfXyAoc2VsZiwgcGFyc2VyLCBvYmosIHNoYTEsIHQsIHNpemUsIGRhdGEpOgogICAgICAgICAgICAgICAgIyBGSVhNRTogTWFueSB1bnVzZWQgYXJndW1lbnRzLiBDb3VsZCB0aGlzIGJlIGNoZWFwZXI/CiAgICAgICAgICAgICAgICBhc3NlcnQgcGFyc2VyID09IHNlbGYucGFyc2VyCiAgICAgICAgICAgICAgICBzZWxmLnNoYTEgPSBzaGExCgogICAgICAgIGhhbmRsZXIgPSBfT2JqSGFuZGxlcihzZWxmKQogICAgICAgIHNlbGYucHVzaChvYmpzcGVjLCBoYW5kbGVyKQogICAgICAgIHNlbGYucHJvY2VzcygpCiAgICAgICAgcmV0dXJuIGhhbmRsZXIuc2hhMQoKICAgIGRlZiBvcGVuX29iaiAoc2VsZiwgb2Jqc3BlYyk6CiAgICAgICAgIiIiUmV0dXJuIGEgZmlsZSBvYmplY3Qgd3JhcHBpbmcgdGhlIGNvbnRlbnRzIG9mIGEgbmFtZWQgb2JqZWN0LgoKICAgICAgICBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBjYWxsaW5nIC5jbG9zZSgpIG9uIHRoZSByZXR1cm5lZAogICAgICAgIGZpbGUgb2JqZWN0LgoKICAgICAgICBSYWlzZSBLZXlFcnJvciBpZiAnb2Jqc3BlYycgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHJlcG8uCgogICAgICAgICIiIgogICAgICAgIGNsYXNzIF9PYmpIYW5kbGVyKG9iamVjdCk6CiAgICAgICAgICAgICIiIkhlbHBlciBjbGFzcyBmb3IgcGFyc2luZyB0aGUgcmV0dXJuZWQgZ2l0IG9iamVjdC4iIiIKICAgICAgICAgICAgZGVmIF9faW5pdF9fIChzZWxmLCBwYXJzZXIpOgogICAgICAgICAgICAgICAgIiIiU2V0IHVwIGhlbHBlci4iIiIKICAgICAgICAgICAgICAgIHNlbGYucGFyc2VyID0gcGFyc2VyCiAgICAgICAgICAgICAgICBzZWxmLmNvbnRlbnRzID0gU3RyaW5nSU8oKQogICAgICAgICAgICAgICAgc2VsZi5lcnIgPSBOb25lCgogICAgICAgICAgICBkZWYgX19jYWxsX18gKHNlbGYsIHBhcnNlciwgb2JqLCBzaGExLCB0LCBzaXplLCBkYXRhKToKICAgICAgICAgICAgICAgICIiIkdpdCBvYmplY3QgY2FsbGJhY2sgKHNlZSBHaXRPYmplY3RGZXRjaGVyIGRvY3VtZW50YXRpb24pLiIiIgogICAgICAgICAgICAgICAgYXNzZXJ0IHBhcnNlciA9PSBzZWxmLnBhcnNlcgogICAgICAgICAgICAgICAgaWYgbm90IHNoYTE6ICAjIE1pc3Npbmcgb2JqZWN0CiAgICAgICAgICAgICAgICAgICAgc2VsZi5lcnIgPSAiTWlzc2luZyBvYmplY3QgJyVzJyIgJSBvYmoKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IHNpemUgPT0gbGVuKGRhdGEpCiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb250ZW50cy53cml0ZShkYXRhKQoKICAgICAgICBoYW5kbGVyID0gX09iakhhbmRsZXIoc2VsZikKICAgICAgICBzZWxmLnB1c2gob2Jqc3BlYywgaGFuZGxlcikKICAgICAgICBzZWxmLnByb2Nlc3MoKQogICAgICAgIGlmIGhhbmRsZXIuZXJyOgogICAgICAgICAgICByYWlzZSBLZXlFcnJvcihoYW5kbGVyLmVycikKICAgICAgICBoYW5kbGVyLmNvbnRlbnRzLnNlZWsoMCkKICAgICAgICByZXR1cm4gaGFuZGxlci5jb250ZW50cwoKICAgIGRlZiB3YWxrX3RyZWUgKHNlbGYsIHRyZWVfb2Jqc3BlYywgY2FsbGJhY2ssIHByZWZpeCA9ICIiKToKICAgICAgICAiIiJSZWN1cnNpdmVseSB3YWxrIHRoZSBnaXZlbiBHaXQgdHJlZSBvYmplY3QuCgogICAgICAgIFJlY3Vyc2l2ZWx5IHdhbGsgYWxsIHN1YnRyZWVzIG9mIHRoZSBnaXZlbiB0cmVlIG9iamVjdCwgYW5kCiAgICAgICAgaW52b2tlIHRoZSBnaXZlbiBjYWxsYmFjayBwYXNzaW5nIHRocmVlIGFyZ3VtZW50czoKICAgICAgICAocGF0aCwgbW9kZSwgZGF0YSkgd2l0aCB0aGUgcGF0aCwgcGVybWlzc2lvbiBiaXRzLCBhbmQgY29udGVudHMKICAgICAgICBvZiBhbGwgdGhlIGJsb2JzIGZvdW5kIGluIHRoZSBlbnRpcmUgdHJlZSBzdHJ1Y3R1cmUuCgogICAgICAgICIiIgogICAgICAgIGNsYXNzIF9PYmpIYW5kbGVyKG9iamVjdCk6CiAgICAgICAgICAgICIiIkhlbHBlciBjbGFzcyBmb3Igd2Fsa2luZyBhIGdpdCB0cmVlIHN0cnVjdHVyZS4iIiIKICAgICAgICAgICAgZGVmIF9faW5pdF9fIChzZWxmLCBwYXJzZXIsIGNiLCBwYXRoLCBtb2RlID0gTm9uZSk6CiAgICAgICAgICAgICAgICAiIiJTZXQgdXAgaGVscGVyLiIiIgogICAgICAgICAgICAgICAgc2VsZi5wYXJzZXIgPSBwYXJzZXIKICAgICAgICAgICAgICAgIHNlbGYuY2IgPSBjYgogICAgICAgICAgICAgICAgc2VsZi5wYXRoID0gcGF0aAogICAgICAgICAgICAgICAgc2VsZi5tb2RlID0gbW9kZQogICAgICAgICAgICAgICAgc2VsZi5lcnIgPSBOb25lCgogICAgICAgICAgICBkZWYgcGFyc2VfdHJlZSAoc2VsZiwgdHJlZWRhdGEpOgogICAgICAgICAgICAgICAgIiIiUGFyc2UgdHJlZSBvYmplY3QgZGF0YSwgeWllbGQgdHJlZSBlbnRyaWVzLgoKICAgICAgICAgICAgICAgIEVhY2ggdHJlZSBlbnRyeSBpcyBhIDMtdHVwbGUgKG1vZGUsIHNoYTEsIHBhdGgpCgogICAgICAgICAgICAgICAgc2VsZi5wYXRoIGlzIHByZXBlbmRlZCB0byBhbGwgcGF0aHMgeWllbGRlZAogICAgICAgICAgICAgICAgZnJvbSB0aGlzIG1ldGhvZC4KCiAgICAgICAgICAgICAgICAiIiIKICAgICAgICAgICAgICAgIHdoaWxlIHRyZWVkYXRhOgogICAgICAgICAgICAgICAgICAgIG1vZGUgPSBpbnQodHJlZWRhdGFbOjZdLCAxMCkKICAgICAgICAgICAgICAgICAgICAjIFR1cm4gMTAweHh4IGludG8geHh4CiAgICAgICAgICAgICAgICAgICAgaWYgbW9kZSA+IDEwMDAwMDoKICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSAtPSAxMDAwMDAKICAgICAgICAgICAgICAgICAgICBhc3NlcnQgdHJlZWRhdGFbNl0gPT0gIiAiCiAgICAgICAgICAgICAgICAgICAgaSA9IHRyZWVkYXRhLmZpbmQoIlwwIiwgNykKICAgICAgICAgICAgICAgICAgICBhc3NlcnQgaSA+IDAKICAgICAgICAgICAgICAgICAgICBwYXRoID0gdHJlZWRhdGFbNzppXQogICAgICAgICAgICAgICAgICAgIHNoYTEgPSBoZXhsaWZ5KHRyZWVkYXRhW2kgKyAxOiBpICsgMjFdKQogICAgICAgICAgICAgICAgICAgIHlpZWxkIChtb2RlLCBzaGExLCBzZWxmLnBhdGggKyBwYXRoKQogICAgICAgICAgICAgICAgICAgIHRyZWVkYXRhID0gdHJlZWRhdGFbaSArIDIxOl0KCiAgICAgICAgICAgIGRlZiBfX2NhbGxfXyAoc2VsZiwgcGFyc2VyLCBvYmosIHNoYTEsIHQsIHNpemUsIGRhdGEpOgogICAgICAgICAgICAgICAgIiIiR2l0IG9iamVjdCBjYWxsYmFjayAoc2VlIEdpdE9iamVjdEZldGNoZXIgZG9jdW1lbnRhdGlvbikuIiIiCiAgICAgICAgICAgICAgICBhc3NlcnQgcGFyc2VyID09IHNlbGYucGFyc2VyCiAgICAgICAgICAgICAgICBpZiBub3Qgc2hhMTogICMgTWlzc2luZyBvYmplY3QKICAgICAgICAgICAgICAgICAgICBzZWxmLmVyciA9ICJNaXNzaW5nIG9iamVjdCAnJXMnIiAlIChvYmopCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgICAgICBhc3NlcnQgc2l6ZSA9PSBsZW4oZGF0YSkKICAgICAgICAgICAgICAgIGlmIHQgPT0gInRyZWUiOgogICAgICAgICAgICAgICAgICAgIGlmIHNlbGYucGF0aDoKICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXRoICs9ICIvIgogICAgICAgICAgICAgICAgICAgICMgUmVjdXJzZSBpbnRvIGFsbCBibG9icyBhbmQgc3VidHJlZXMKICAgICAgICAgICAgICAgICAgICBmb3IgbSwgcywgcCBpbiBzZWxmLnBhcnNlX3RyZWUoZGF0YSk6CiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5wdXNoKHMsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX19jbGFzc19fKHNlbGYucGFyc2VyLCBzZWxmLmNiLCBwLCBtKSkKICAgICAgICAgICAgICAgIGVsaWYgdCA9PSAiYmxvYiI6CiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYihzZWxmLnBhdGgsIHNlbGYubW9kZSwgZGF0YSkKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcigiVW5rbm93biBvYmplY3QgdHlwZSAnJXMnIiAlICh0KSkKCiAgICAgICAgc2VsZi5wdXNoKHRyZWVfb2Jqc3BlYywgX09iakhhbmRsZXIoc2VsZiwgY2FsbGJhY2ssIHByZWZpeCkpCiAgICAgICAgc2VsZi5wcm9jZXNzKCkKCgpjbGFzcyBHaXRSZWZNYXAob2JqZWN0KToKCiAgICAiIiJNYXAgR2l0IHJlZiBuYW1lcyB0byB0aGUgR2l0IG9iamVjdCBuYW1lcyB0aGV5IGN1cnJlbnRseSBwb2ludCB0by4KCiAgICBCZWhhdmVzIGxpa2UgYSBkaWN0aW9uYXJ5IG9mIEdpdCByZWYgbmFtZXMgLT4gR2l0IG9iamVjdCBuYW1lcy4KCiAgICAiIiIKCiAgICBkZWYgX19pbml0X18gKHNlbGYsIG9ial9mZXRjaGVyKToKICAgICAgICAiIiJDcmVhdGUgYSBuZXcgR2l0IHJlZiAtPiBvYmplY3QgbWFwLiIiIgogICAgICAgIHNlbGYub2JqX2ZldGNoZXIgPSBvYmpfZmV0Y2hlcgogICAgICAgIHNlbGYuX2NhY2hlID0ge30gICMgZGljdDogcmVmbmFtZSAtPiBvYmpuYW1lCgogICAgZGVmIF9sb2FkIChzZWxmLCByZWYpOgogICAgICAgICIiIlJldHJpZXZlIHRoZSBvYmplY3QgY3VycmVudGx5IGJvdW5kIHRvIHRoZSBnaXZlbiByZWYuCgogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBvYmplY3QgcG9pbnRlZCB0byBieSB0aGUgZ2l2ZW4gcmVmIGlzIHN0b3JlZAogICAgICAgIGludG8gdGhpcyBtYXBwaW5nLCBhbmQgYWxzbyByZXR1cm5lZC4KCiAgICAgICAgIiIiCiAgICAgICAgaWYgcmVmIG5vdCBpbiBzZWxmLl9jYWNoZToKICAgICAgICAgICAgc2VsZi5fY2FjaGVbcmVmXSA9IHNlbGYub2JqX2ZldGNoZXIuZ2V0X3NoYTEocmVmKQogICAgICAgIHJldHVybiBzZWxmLl9jYWNoZVtyZWZdCgogICAgZGVmIF9fY29udGFpbnNfXyAoc2VsZiwgcmVmbmFtZSk6CiAgICAgICAgIiIiUmV0dXJuIFRydWUgaWYgdGhlIGdpdmVuIHJlZm5hbWUgaXMgcHJlc2VudCBpbiB0aGlzIGNhY2hlLiIiIgogICAgICAgIHJldHVybiBib29sKHNlbGYuX2xvYWQocmVmbmFtZSkpCgogICAgZGVmIF9fZ2V0aXRlbV9fIChzZWxmLCByZWZuYW1lKToKICAgICAgICAiIiJSZXR1cm4gdGhlIGdpdCBvYmplY3QgbmFtZSBwb2ludGVkIHRvIGJ5IHRoZSBnaXZlbiByZWZuYW1lLiIiIgogICAgICAgIGNvbW1pdCA9IHNlbGYuX2xvYWQocmVmbmFtZSkKICAgICAgICBpZiBjb21taXQgaXMgTm9uZToKICAgICAgICAgICAgcmFpc2UgS2V5RXJyb3IoIlVua25vd24gcmVmICclcyciICUgKHJlZm5hbWUpKQogICAgICAgIHJldHVybiBjb21taXQKCiAgICBkZWYgZ2V0IChzZWxmLCByZWZuYW1lLCBkZWZhdWx0ID0gTm9uZSk6CiAgICAgICAgIiIiUmV0dXJuIHRoZSBnaXQgb2JqZWN0IG5hbWUgcG9pbnRlZCB0byBieSB0aGUgZ2l2ZW4gcmVmbmFtZS4iIiIKICAgICAgICBjb21taXQgPSBzZWxmLl9sb2FkKHJlZm5hbWUpCiAgICAgICAgaWYgY29tbWl0IGlzIE5vbmU6CiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0CiAgICAgICAgcmV0dXJuIGNvbW1pdAoKCmNsYXNzIEdpdEZJQ29tbWl0KG9iamVjdCk6CgogICAgIiIiRW5jYXBzdWxhdGUgdGhlIGRhdGEgaW4gYSBHaXQgZmFzdC1pbXBvcnQgY29tbWl0IGNvbW1hbmQuIiIiCgogICAgU0hBMVJFID0gcmUuY29tcGlsZShyJ15bMC05YS1mXXs0MH0kJykKCiAgICBAY2xhc3NtZXRob2QKICAgIGRlZiBwYXJzZV9tb2RlIChjbHMsIG1vZGUpOgogICAgICAgICIiIlZlcmlmeSB0aGUgZ2l2ZW4gZ2l0IGZpbGUgbW9kZSwgYW5kIHJldHVybiBpdCBhcyBhIHN0cmluZy4iIiIKICAgICAgICBhc3NlcnQgbW9kZSBpbiAoNjQ0LCA3NTUsIDEwMDY0NCwgMTAwNzU1LCAxMjAwMDApCiAgICAgICAgcmV0dXJuICIlaSIgJSAobW9kZSkKCiAgICBAY2xhc3NtZXRob2QKICAgIGRlZiBwYXJzZV9vYmpuYW1lIChjbHMsIG9iam5hbWUpOgogICAgICAgICIiIlJldHVybiB0aGUgZ2l2ZW4gb2JqZWN0IG5hbWUgKG9yIG1hcmsgbnVtYmVyKSBhcyBhIHN0cmluZy4iIiIKICAgICAgICBpZiBpc2luc3RhbmNlKG9iam5hbWUsIGludCk6ICAjIE9iamVjdCBuYW1lIGlzIGEgbWFyayBudW1iZXIKICAgICAgICAgICAgYXNzZXJ0IG9iam5hbWUgPiAwCiAgICAgICAgICAgIHJldHVybiAiOiVpIiAlIChvYmpuYW1lKQoKICAgICAgICAjIE5vIGV4aXN0ZW5jZSBjaGVjayBpcyBkb25lLCBvbmx5IGNoZWNrcyBmb3IgdmFsaWQgZm9ybWF0CiAgICAgICAgYXNzZXJ0IGNscy5TSEExUkUubWF0Y2gob2JqbmFtZSkgICMgT2JqZWN0IG5hbWUgaXMgdmFsaWQgU0hBMQogICAgICAgIHJldHVybiBvYmpuYW1lCgogICAgQGNsYXNzbWV0aG9kCiAgICBkZWYgcXVvdGVfcGF0aCAoY2xzLCBwYXRoKToKICAgICAgICAiIiJSZXR1cm4gYSBxdW90ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcGF0aC4iIiIKICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKCJcXCIsICJcXFxcIikKICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKCJcbiIsICJcXG4iKQogICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoJyInLCAnXFwiJykKICAgICAgICByZXR1cm4gJyIlcyInICUgKHBhdGgpCgogICAgQGNsYXNzbWV0aG9kCiAgICBkZWYgcGFyc2VfcGF0aCAoY2xzLCBwYXRoKToKICAgICAgICAiIiJWZXJpZnkgdGhhdCB0aGUgZ2l2ZW4gcGF0aCBpcyB2YWxpZCwgYW5kIHF1b3RlIGl0LCBpZiBuZWVkZWQuIiIiCiAgICAgICAgYXNzZXJ0IG5vdCBpc2luc3RhbmNlKHBhdGgsIGludCkgICMgQ2Fubm90IGJlIGEgbWFyayBudW1iZXIKCiAgICAgICAgIyBUaGVzZSBjaGVja3MgdmVyaWZ5IHRoZSBydWxlcyBvbiB0aGUgZmFzdC1pbXBvcnQgbWFuIHBhZ2UKICAgICAgICBhc3NlcnQgbm90IHBhdGguY291bnQoIi8vIikKICAgICAgICBhc3NlcnQgbm90IHBhdGguZW5kc3dpdGgoIi8iKQogICAgICAgIGFzc2VydCBub3QgcGF0aC5zdGFydHN3aXRoKCIvIikKICAgICAgICBhc3NlcnQgbm90IHBhdGguY291bnQoIi8uLyIpCiAgICAgICAgYXNzZXJ0IG5vdCBwYXRoLmNvdW50KCIvLi4vIikKICAgICAgICBhc3NlcnQgbm90IHBhdGguZW5kc3dpdGgoIi8uIikKICAgICAgICBhc3NlcnQgbm90IHBhdGguZW5kc3dpdGgoIi8uLiIpCiAgICAgICAgYXNzZXJ0IG5vdCBwYXRoLnN0YXJ0c3dpdGgoIi4vIikKICAgICAgICBhc3NlcnQgbm90IHBhdGguc3RhcnRzd2l0aCgiLi4vIikKCiAgICAgICAgaWYgcGF0aC5jb3VudCgnIicpICsgcGF0aC5jb3VudCgnXG4nKSArIHBhdGguY291bnQoJ1xcJyk6CiAgICAgICAgICAgIHJldHVybiBjbHMucXVvdGVfcGF0aChwYXRoKQogICAgICAgIHJldHVybiBwYXRoCgogICAgZGVmIF9faW5pdF9fIChzZWxmLCBuYW1lLCBlbWFpbCwgdGltZXN0YW1wLCB0aW1lem9uZSwgbWVzc2FnZSk6CiAgICAgICAgIiIiQ3JlYXRlIGEgbmV3IEdpdCBmYXN0LWltcG9ydCBjb21taXQsIHdpdGggdGhlIGdpdmVuIG1ldGFkYXRhLiIiIgogICAgICAgIHNlbGYubmFtZSA9IG5hbWUKICAgICAgICBzZWxmLmVtYWlsID0gZW1haWwKICAgICAgICBzZWxmLnRpbWVzdGFtcCA9IHRpbWVzdGFtcAogICAgICAgIHNlbGYudGltZXpvbmUgPSB0aW1lem9uZQogICAgICAgIHNlbGYubWVzc2FnZSA9IG1lc3NhZ2UKICAgICAgICBzZWxmLnBhdGhvcHMgPSBbXSAgIyBMaXN0IG9mIHBhdGggb3BlcmF0aW9ucyBpbiB0aGlzIGNvbW1pdAoKICAgIGRlZiBtb2RpZnkgKHNlbGYsIG1vZGUsIGJsb2JuYW1lLCBwYXRoKToKICAgICAgICAiIiJBZGQgYSBmaWxlIG1vZGlmaWNhdGlvbiB0byB0aGlzIEdpdCBmYXN0LWltcG9ydCBjb21taXQuIiIiCiAgICAgICAgc2VsZi5wYXRob3BzLmFwcGVuZCgoIk0iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGFyc2VfbW9kZShtb2RlKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBhcnNlX29iam5hbWUoYmxvYm5hbWUpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGFyc2VfcGF0aChwYXRoKSkpCgogICAgZGVmIGRlbGV0ZSAoc2VsZiwgcGF0aCk6CiAgICAgICAgIiIiQWRkIGEgZmlsZSBkZWxldGlvbiB0byB0aGlzIEdpdCBmYXN0LWltcG9ydCBjb21taXQuIiIiCiAgICAgICAgc2VsZi5wYXRob3BzLmFwcGVuZCgoIkQiLCBzZWxmLnBhcnNlX3BhdGgocGF0aCkpKQoKICAgIGRlZiBjb3B5IChzZWxmLCBwYXRoLCBuZXdwYXRoKToKICAgICAgICAiIiJBZGQgYSBmaWxlIGNvcHkgdG8gdGhpcyBHaXQgZmFzdC1pbXBvcnQgY29tbWl0LiIiIgogICAgICAgIHNlbGYucGF0aG9wcy5hcHBlbmQoKCJDIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBhcnNlX3BhdGgocGF0aCksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXJzZV9wYXRoKG5ld3BhdGgpKSkKCiAgICBkZWYgcmVuYW1lIChzZWxmLCBwYXRoLCBuZXdwYXRoKToKICAgICAgICAiIiJBZGQgYSBmaWxlIHJlbmFtZSB0byB0aGlzIEdpdCBmYXN0LWltcG9ydCBjb21taXQuIiIiCiAgICAgICAgc2VsZi5wYXRob3BzLmFwcGVuZCgoIlIiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGFyc2VfcGF0aChwYXRoKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBhcnNlX3BhdGgobmV3cGF0aCkpKQoKICAgIGRlZiBub3RlIChzZWxmLCBibG9ibmFtZSwgY29tbWl0KToKICAgICAgICAiIiJBZGQgYSBub3RlIG9iamVjdCB0byB0aGlzIEdpdCBmYXN0LWltcG9ydCBjb21taXQuIiIiCiAgICAgICAgc2VsZi5wYXRob3BzLmFwcGVuZCgoIk4iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGFyc2Vfb2JqbmFtZShibG9ibmFtZSksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXJzZV9vYmpuYW1lKGNvbW1pdCkpKQoKICAgIGRlZiBkZWxldGVhbGwgKHNlbGYpOgogICAgICAgICIiIkRlbGV0ZSBhbGwgZmlsZXMgaW4gdGhpcyBHaXQgZmFzdC1pbXBvcnQgY29tbWl0LiIiIgogICAgICAgIHNlbGYucGF0aG9wcy5hcHBlbmQoImRlbGV0ZWFsbCIpCgoKY2xhc3MgVGVzdEdpdEZJQ29tbWl0KHVuaXR0ZXN0LlRlc3RDYXNlKToKCiAgICAiIiJHaXRGSUNvbW1pdCBzZWxmdGVzdHMuIiIiCgogICAgZGVmIHRlc3RfYmFzaWMgKHNlbGYpOgogICAgICAgICIiIkdpdEZJQ29tbWl0IGJhc2ljIHNlbGZ0ZXN0cy4iIiIKCiAgICAgICAgZGVmIGV4cGVjdF9mYWlsIChtZXRob2QsIGRhdGEpOgogICAgICAgICAgICAiIiJWZXJpZnkgdGhhdCB0aGUgbWV0aG9kKGRhdGEpIHJhaXNlcyBhbiBBc3NlcnRpb25FcnJvci4iIiIKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgbWV0aG9kKGRhdGEpCiAgICAgICAgICAgIGV4Y2VwdCBBc3NlcnRpb25FcnJvcjoKICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICByYWlzZSBBc3NlcnRpb25FcnJvcigiRmFpbGVkIHRlc3QgZm9yIGludmFsaWQgZGF0YSAnJXMoJXMpJyIgJQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWV0aG9kLl9fbmFtZV9fLCByZXByKGRhdGEpKSkKCiAgICBkZWYgdGVzdF9wYXJzZV9tb2RlIChzZWxmKToKICAgICAgICAiIiJHaXRGSUNvbW1pdC5wYXJzZV9tb2RlKCkgc2VsZnRlc3RzLiIiIgogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwoR2l0RklDb21taXQucGFyc2VfbW9kZSg2NDQpLCAiNjQ0IikKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKEdpdEZJQ29tbWl0LnBhcnNlX21vZGUoNzU1KSwgIjc1NSIpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChHaXRGSUNvbW1pdC5wYXJzZV9tb2RlKDEwMDY0NCksICIxMDA2NDQiKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwoR2l0RklDb21taXQucGFyc2VfbW9kZSgxMDA3NTUpLCAiMTAwNzU1IikKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKEdpdEZJQ29tbWl0LnBhcnNlX21vZGUoMTIwMDAwKSwgIjEyMDAwMCIpCiAgICAgICAgc2VsZi5hc3NlcnRSYWlzZXMoQXNzZXJ0aW9uRXJyb3IsIEdpdEZJQ29tbWl0LnBhcnNlX21vZGUsIDApCiAgICAgICAgc2VsZi5hc3NlcnRSYWlzZXMoQXNzZXJ0aW9uRXJyb3IsIEdpdEZJQ29tbWl0LnBhcnNlX21vZGUsIDEyMykKICAgICAgICBzZWxmLmFzc2VydFJhaXNlcyhBc3NlcnRpb25FcnJvciwgR2l0RklDb21taXQucGFyc2VfbW9kZSwgNjAwKQogICAgICAgIHNlbGYuYXNzZXJ0UmFpc2VzKEFzc2VydGlvbkVycm9yLCBHaXRGSUNvbW1pdC5wYXJzZV9tb2RlLCAiNjQ0IikKICAgICAgICBzZWxmLmFzc2VydFJhaXNlcyhBc3NlcnRpb25FcnJvciwgR2l0RklDb21taXQucGFyc2VfbW9kZSwgImFiYyIpCgogICAgZGVmIHRlc3RfcGFyc2Vfb2JqbmFtZSAoc2VsZik6CiAgICAgICAgIiIiR2l0RklDb21taXQucGFyc2Vfb2JqbmFtZSgpIHNlbGZ0ZXN0cy4iIiIKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKEdpdEZJQ29tbWl0LnBhcnNlX29iam5hbWUoMSksICI6MSIpCiAgICAgICAgc2VsZi5hc3NlcnRSYWlzZXMoQXNzZXJ0aW9uRXJyb3IsIEdpdEZJQ29tbWl0LnBhcnNlX29iam5hbWUsIDApCiAgICAgICAgc2VsZi5hc3NlcnRSYWlzZXMoQXNzZXJ0aW9uRXJyb3IsIEdpdEZJQ29tbWl0LnBhcnNlX29iam5hbWUsIC0xKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwoR2l0RklDb21taXQucGFyc2Vfb2JqbmFtZSgiMDEyMzQ1Njc4OSIgKiA0KSwKICAgICAgICAgICAgICAgICAgICAgICAgICIwMTIzNDU2Nzg5IiAqIDQpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChHaXRGSUNvbW1pdC5wYXJzZV9vYmpuYW1lKCIyNDY4YWJjZGVmIiAqIDQpLAogICAgICAgICAgICAgICAgICAgICAgICAgIjI0NjhhYmNkZWYiICogNCkKICAgICAgICBzZWxmLmFzc2VydFJhaXNlcyhBc3NlcnRpb25FcnJvciwgR2l0RklDb21taXQucGFyc2Vfb2JqbmFtZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAiYWJjZGVmZ2hpaiIgKiA0KQoKICAgIGRlZiB0ZXN0X3BhcnNlX3BhdGggKHNlbGYpOgogICAgICAgICIiIkdpdEZJQ29tbWl0LnBhcnNlX3BhdGgoKSBzZWxmdGVzdHMuIiIiCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChHaXRGSUNvbW1pdC5wYXJzZV9wYXRoKCJmb28vYmFyIiksICJmb28vYmFyIikKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKEdpdEZJQ29tbWl0LnBhcnNlX3BhdGgoInBhdGgvd2l0aFxuIGFuZCBcIiBpbiBpdCIpLAogICAgICAgICAgICAgICAgICAgICAgICAgJyJwYXRoL3dpdGhcXG4gYW5kIFxcIiBpbiBpdCInKQogICAgICAgIHNlbGYuYXNzZXJ0UmFpc2VzKEFzc2VydGlvbkVycm9yLCBHaXRGSUNvbW1pdC5wYXJzZV9wYXRoLCAxKQogICAgICAgIHNlbGYuYXNzZXJ0UmFpc2VzKEFzc2VydGlvbkVycm9yLCBHaXRGSUNvbW1pdC5wYXJzZV9wYXRoLCAwKQogICAgICAgIHNlbGYuYXNzZXJ0UmFpc2VzKEFzc2VydGlvbkVycm9yLCBHaXRGSUNvbW1pdC5wYXJzZV9wYXRoLCAtMSkKICAgICAgICBzZWxmLmFzc2VydFJhaXNlcyhBc3NlcnRpb25FcnJvciwgR2l0RklDb21taXQucGFyc2VfcGF0aCwgImZvby8vYmFyIikKICAgICAgICBzZWxmLmFzc2VydFJhaXNlcyhBc3NlcnRpb25FcnJvciwgR2l0RklDb21taXQucGFyc2VfcGF0aCwgImZvby9iYXIvIikKICAgICAgICBzZWxmLmFzc2VydFJhaXNlcyhBc3NlcnRpb25FcnJvciwgR2l0RklDb21taXQucGFyc2VfcGF0aCwgIi9mb28vYmFyIikKICAgICAgICBzZWxmLmFzc2VydFJhaXNlcyhBc3NlcnRpb25FcnJvciwgR2l0RklDb21taXQucGFyc2VfcGF0aCwgImZvby8uL2JhciIpCiAgICAgICAgc2VsZi5hc3NlcnRSYWlzZXMoQXNzZXJ0aW9uRXJyb3IsIEdpdEZJQ29tbWl0LnBhcnNlX3BhdGgsICJmb28vLi4vYmFyIikKICAgICAgICBzZWxmLmFzc2VydFJhaXNlcyhBc3NlcnRpb25FcnJvciwgR2l0RklDb21taXQucGFyc2VfcGF0aCwgImZvby9iYXIvLiIpCiAgICAgICAgc2VsZi5hc3NlcnRSYWlzZXMoQXNzZXJ0aW9uRXJyb3IsIEdpdEZJQ29tbWl0LnBhcnNlX3BhdGgsICJmb28vYmFyLy4uIikKICAgICAgICBzZWxmLmFzc2VydFJhaXNlcyhBc3NlcnRpb25FcnJvciwgR2l0RklDb21taXQucGFyc2VfcGF0aCwgIi4vZm9vL2JhciIpCiAgICAgICAgc2VsZi5hc3NlcnRSYWlzZXMoQXNzZXJ0aW9uRXJyb3IsIEdpdEZJQ29tbWl0LnBhcnNlX3BhdGgsICIuLi9mb28vYmFyIikKCgpjbGFzcyBHaXRGYXN0SW1wb3J0KG9iamVjdCk6CgogICAgIiIiRW5jYXBzdWxhdGUgY29tbXVuaWNhdGlvbiB3aXRoIGdpdCBmYXN0LWltcG9ydC4iIiIKCiAgICBkZWYgX19pbml0X18gKHNlbGYsIGYsIG9ial9mZXRjaGVyLCBsYXN0X21hcmsgPSAwKToKICAgICAgICAiIiJTZXQgdXAgc2VsZiB0byBjb21tdW5pY2F0ZSB3aXRoIGEgZmFzdC1pbXBvcnQgcHJvY2VzcyB0aHJvdWdoIGYuIiIiCiAgICAgICAgc2VsZi5mID0gZiAgIyBGaWxlIG9iamVjdCB3aGVyZSBmYXN0LWltcG9ydCBzdHJlYW0gaXMgd3JpdHRlbgogICAgICAgIHNlbGYub2JqX2ZldGNoZXIgPSBvYmpfZmV0Y2hlciAgIyBHaXRPYmplY3RGZXRjaGVyIGluc3RhbmNlCiAgICAgICAgc2VsZi5uZXh0X21hcmsgPSBsYXN0X21hcmsgKyAxICAjIE5leHQgbWFyayBudW1iZXIKICAgICAgICBzZWxmLnJlZnMgPSBzZXQoKSAgIyBLZWVwIHRyYWNrIG9mIHRoZSByZWZuYW1lcyB3ZSd2ZSBzZWVuCgogICAgZGVmIGNvbW1lbnQgKHNlbGYsIHMpOgogICAgICAgICIiIldyaXRlIHRoZSBnaXZlbiBjb21tZW50IGluIHRoZSBmYXN0LWltcG9ydCBzdHJlYW0uIiIiCiAgICAgICAgYXNzZXJ0ICJcbiIgbm90IGluIHMsICJNYWxmb3JtZWQgY29tbWVudDogJyVzJyIgJSAocykKICAgICAgICBzZWxmLmYud3JpdGUoIiMgJXNcbiIgJSAocykpCgogICAgZGVmIGNvbW1pdCAoc2VsZiwgcmVmLCBjb21taXRkYXRhKToKICAgICAgICAiIiJNYWtlIGEgY29tbWl0IG9uIHRoZSBnaXZlbiByZWYsIHdpdGggdGhlIGdpdmVuIEdpdEZJQ29tbWl0LgoKICAgICAgICBSZXR1cm4gdGhlIG1hcmsgbnVtYmVyIGlkZW50aWZ5aW5nIHRoaXMgY29tbWl0LgoKICAgICAgICAiIiIKICAgICAgICBzZWxmLmYud3JpdGUoIiIiXApjb21taXQgJShyZWYpcwptYXJrIDolKG1hcmspaQpjb21taXR0ZXIgJShuYW1lKXMgPCUoZW1haWwpcz4gJSh0aW1lc3RhbXApaSAlKHRpbWV6b25lKXMKZGF0YSAlKG1zZ0xlbmd0aClpCiUobXNnKXMKIiIiICUgewogICAgJ3JlZic6IHJlZiwKICAgICdtYXJrJzogc2VsZi5uZXh0X21hcmssCiAgICAnbmFtZSc6IGNvbW1pdGRhdGEubmFtZSwKICAgICdlbWFpbCc6IGNvbW1pdGRhdGEuZW1haWwsCiAgICAndGltZXN0YW1wJzogY29tbWl0ZGF0YS50aW1lc3RhbXAsCiAgICAndGltZXpvbmUnOiBjb21taXRkYXRhLnRpbWV6b25lLAogICAgJ21zZ0xlbmd0aCc6IGxlbihjb21taXRkYXRhLm1lc3NhZ2UpLAogICAgJ21zZyc6IGNvbW1pdGRhdGEubWVzc2FnZSwKfSkKCiAgICAgICAgaWYgcmVmIG5vdCBpbiBzZWxmLnJlZnM6CiAgICAgICAgICAgIHNlbGYucmVmcy5hZGQocmVmKQogICAgICAgICAgICBwYXJlbnQgPSByZWYgKyAiXjAiCiAgICAgICAgICAgIGlmIHNlbGYub2JqX2ZldGNoZXIuZ2V0X3NoYTEocGFyZW50KToKICAgICAgICAgICAgICAgIHNlbGYuZi53cml0ZSgiZnJvbSAlc1xuIiAlIChwYXJlbnQpKQoKICAgICAgICBmb3Igb3AgaW4gY29tbWl0ZGF0YS5wYXRob3BzOgogICAgICAgICAgICBzZWxmLmYud3JpdGUoIiAiLmpvaW4ob3ApKQogICAgICAgICAgICBzZWxmLmYud3JpdGUoIlxuIikKICAgICAgICBzZWxmLmYud3JpdGUoIlxuIikKICAgICAgICByZXR2YWwgPSBzZWxmLm5leHRfbWFyawogICAgICAgIHNlbGYubmV4dF9tYXJrICs9IDEKICAgICAgICByZXR1cm4gcmV0dmFsCgogICAgZGVmIGJsb2IgKHNlbGYsIGRhdGEpOgogICAgICAgICIiIkltcG9ydCB0aGUgZ2l2ZW4gYmxvYi4KCiAgICAgICAgUmV0dXJuIHRoZSBtYXJrIG51bWJlciBpZGVudGlmeWluZyB0aGlzIGJsb2IuCgogICAgICAgICIiIgogICAgICAgIHNlbGYuZi53cml0ZSgiYmxvYlxubWFyayA6JWlcbmRhdGEgJWlcbiVzXG4iICUKICAgICAgICAgICAgICAgICAgICAgKHNlbGYubmV4dF9tYXJrLCBsZW4oZGF0YSksIGRhdGEpKQogICAgICAgIHJldHZhbCA9IHNlbGYubmV4dF9tYXJrCiAgICAgICAgc2VsZi5uZXh0X21hcmsgKz0gMQogICAgICAgIHJldHVybiByZXR2YWwKCiAgICBkZWYgcmVzZXQgKHNlbGYsIHJlZiwgb2JqbmFtZSk6CiAgICAgICAgIiIiUmVzZXQgdGhlIGdpdmVuIHJlZiB0byBwb2ludCBhdCB0aGUgZ2l2ZW4gR2l0IG9iamVjdC4iIiIKICAgICAgICBzZWxmLmYud3JpdGUoInJlc2V0ICVzXG5mcm9tICVzXG5cbiIgJQogICAgICAgICAgICAgICAgICAgICAocmVmLCBHaXRGSUNvbW1pdC5wYXJzZV9vYmpuYW1lKG9iam5hbWUpKSkKICAgICAgICBpZiByZWYgbm90IGluIHNlbGYucmVmczoKICAgICAgICAgICAgc2VsZi5yZWZzLmFkZChyZWYpCgoKY2xhc3MgR2l0Tm90ZXMob2JqZWN0KToKCiAgICAiIiJFbmNhcHN1bGF0ZSBhY2Nlc3MgdG8gR2l0IG5vdGVzLgoKICAgIFNpbXVsYXRlcyBhIGRpY3Rpb25hcnkgb2Ygb2JqZWN0IG5hbWUgKFNIQTEpIC0+IEdpdCBub3RlIG1hcHBpbmdzLgoKICAgICIiIgoKICAgIGRlZiBfX2luaXRfXyAoc2VsZiwgbm90ZXNfcmVmLCBvYmpfZmV0Y2hlcik6CiAgICAgICAgIiIiQ3JlYXRlIGEgbmV3IEdpdCBub3RlcyBpbnRlcmZhY2UsIGJvdW5kIHRvIHRoZSBnaXZlbiBub3RlcyByZWYuIiIiCiAgICAgICAgc2VsZi5ub3Rlc19yZWYgPSBub3Rlc19yZWYKICAgICAgICBzZWxmLm9ial9mZXRjaGVyID0gb2JqX2ZldGNoZXIgICMgVXNlZCB0byBnZXQgb2JqZWN0cyBmcm9tIHJlcG8KICAgICAgICBzZWxmLmltcG9ydHMgPSBbXSAgIyBsaXN0OiAob2JqbmFtZSwgbm90ZSBkYXRhIGJsb2IgbmFtZSkgdHVwbGVzCgogICAgZGVmIF9fZGVsX18gKHNlbGYpOgogICAgICAgICIiIlZlcmlmeSB0aGF0IHNlbGYuY29tbWl0X25vdGVzKCkgd2FzIGNhbGxlZCBiZWZvcmUgZGVzdHJ1Y3Rpb24uIiIiCiAgICAgICAgaWYgc2VsZi5pbXBvcnRzOgogICAgICAgICAgICBlcnJvcigiTWlzc2luZyBjYWxsIHRvIHNlbGYuY29tbWl0X25vdGVzKCkuIikKICAgICAgICAgICAgZXJyb3IoIiVpIG5vdGVzIGFyZSBub3QgY29tbWl0dGVkISIsIGxlbihzZWxmLmltcG9ydHMpKQoKICAgIGRlZiBfbG9hZCAoc2VsZiwgb2JqbmFtZSk6CiAgICAgICAgIiIiUmV0dXJuIHRoZSBub3RlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBnaXQgb2JqZWN0LgoKICAgICAgICBUaGUgbm90ZSBkYXRhIGlzIHJldHVybmVkIGluIHN0cmluZyBmb3JtLiBJZiBubyBub3RlIGlzIGZvdW5kCiAgICAgICAgZm9yIHRoZSBnaXZlbiBvYmplY3QsIE5vbmUgaXMgcmV0dXJuZWQuCgogICAgICAgICIiIgogICAgICAgIHRyeToKICAgICAgICAgICAgZiA9IHNlbGYub2JqX2ZldGNoZXIub3Blbl9vYmooIiVzOiVzIiAlIChzZWxmLm5vdGVzX3JlZiwgb2JqbmFtZSkpCiAgICAgICAgICAgIHJldCA9IGYucmVhZCgpCiAgICAgICAgICAgIGYuY2xvc2UoKQogICAgICAgIGV4Y2VwdCBLZXlFcnJvcjoKICAgICAgICAgICAgcmV0ID0gTm9uZQogICAgICAgIHJldHVybiByZXQKCiAgICBkZWYgX19nZXRpdGVtX18gKHNlbGYsIG9iam5hbWUpOgogICAgICAgICIiIlJldHVybiB0aGUgbm90ZSBjb250ZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIG9iamVjdC4KCiAgICAgICAgUmFpc2UgS2V5RXJyb3IgaWYgZ2l2ZW4gb2JqZWN0IGhhcyBubyBhc3NvY2lhdGVkIG5vdGUuCgogICAgICAgICIiIgogICAgICAgIGJsb2JkYXRhID0gc2VsZi5fbG9hZChvYmpuYW1lKQogICAgICAgIGlmIGJsb2JkYXRhIGlzIE5vbmU6CiAgICAgICAgICAgIHJhaXNlIEtleUVycm9yKCJPYmplY3QgJyVzJyBoYXMgbm8gbm90ZSIgJSAob2JqbmFtZSkpCiAgICAgICAgcmV0dXJuIGJsb2JkYXRhCgogICAgZGVmIGdldCAoc2VsZiwgb2JqbmFtZSwgZGVmYXVsdCA9IE5vbmUpOgogICAgICAgICIiIlJldHVybiB0aGUgbm90ZSBjb250ZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIG9iamVjdC4KCiAgICAgICAgUmV0dXJuIGdpdmVuIGRlZmF1bHQgaWYgZ2l2ZW4gb2JqZWN0IGhhcyBubyBhc3NvY2lhdGVkIG5vdGUuCgogICAgICAgICIiIgogICAgICAgIGJsb2JkYXRhID0gc2VsZi5fbG9hZChvYmpuYW1lKQogICAgICAgIGlmIGJsb2JkYXRhIGlzIE5vbmU6CiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0CiAgICAgICAgcmV0dXJuIGJsb2JkYXRhCgogICAgZGVmIGltcG9ydF9ub3RlIChzZWxmLCBvYmpuYW1lLCBkYXRhLCBnZmkpOgogICAgICAgICIiIlRlbGwgZ2l0IGZhc3QtaW1wb3J0IHRvIHN0b3JlIGRhdGEgYXMgYSBub3RlIGZvciBvYmpuYW1lLgoKICAgICAgICBUaGlzIG1ldGhvZCB1c2VzIHRoZSBnaXZlbiBHaXRGYXN0SW1wb3J0IG9iamVjdCB0byBjcmVhdGUgYQogICAgICAgIGJsb2IgY29udGFpbmluZyB0aGUgZ2l2ZW4gbm90ZSBkYXRhLiAgQWxzbyBhbiBlbnRyeSBtYXBwaW5nIHRoZQogICAgICAgIGdpdmVuIG9iamVjdCBuYW1lIHRvIHRoZSBjcmVhdGVkIGJsb2IgaXMgc3RvcmVkIHVudGlsCiAgICAgICAgY29tbWl0X25vdGVzKCkgaXMgY2FsbGVkLgoKICAgICAgICBOb3RlIHRoYXQgdGhpcyBtZXRob2Qgb25seSB3b3JrcyBpZiBpdCBpcyBsYXRlciBmb2xsb3dlZCBieSBhCiAgICAgICAgY2FsbCB0byBzZWxmLmNvbW1pdF9ub3RlcygpICh3aGljaCBwcm9kdWNlcyB0aGUgbm90ZSBjb21taXQKICAgICAgICB0aGF0IHJlZmVycyB0byB0aGUgYmxvYiBwcm9kdWNlZCBoZXJlKS4KCiAgICAgICAgIiIiCiAgICAgICAgaWYgbm90IGRhdGEuZW5kc3dpdGgoIlxuIik6CiAgICAgICAgICAgIGRhdGEgKz0gIlxuIgogICAgICAgIGdmaS5jb21tZW50KCJJbXBvcnRpbmcgbm90ZSBmb3Igb2JqZWN0ICVzIiAlIChvYmpuYW1lKSkKICAgICAgICBtYXJrID0gZ2ZpLmJsb2IoZGF0YSkKICAgICAgICBzZWxmLmltcG9ydHMuYXBwZW5kKChvYmpuYW1lLCBtYXJrKSkKCiAgICBkZWYgY29tbWl0X25vdGVzIChzZWxmLCBnZmksIGF1dGhvciwgbWVzc2FnZSk6CiAgICAgICAgIiIiUHJvZHVjZSBhIGdpdCBmYXN0LWltcG9ydCBub3RlIGNvbW1pdCBmb3IgdGhlIGltcG9ydGVkIG5vdGVzLgoKICAgICAgICBUaGlzIG1ldGhvZCB1c2VzIHRoZSBnaXZlbiBHaXRGYXN0SW1wb3J0IG9iamVjdCB0byBjcmVhdGUgYQogICAgICAgIGNvbW1pdCBvbiB0aGUgbm90ZXMgcmVmLCBpbnRyb2R1Y2luZyB0aGUgbm90ZXMgcHJldmlvdXNseQogICAgICAgIHN1Ym1pdHRlZCB0byBpbXBvcnRfbm90ZSgpLgoKICAgICAgICAiIiIKICAgICAgICBpZiBub3Qgc2VsZi5pbXBvcnRzOgogICAgICAgICAgICByZXR1cm4KICAgICAgICBjb21taXRkYXRhID0gR2l0RklDb21taXQoYXV0aG9yWzBdLCBhdXRob3JbMV0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUudGltZSgpLCAiMDAwMCIsIG1lc3NhZ2UpCiAgICAgICAgZm9yIG9iam5hbWUsIGJsb2JuYW1lIGluIHNlbGYuaW1wb3J0czoKICAgICAgICAgICAgYXNzZXJ0IGlzaW5zdGFuY2Uob2JqbmFtZSwgaW50KSBhbmQgb2JqbmFtZSA+IDAKICAgICAgICAgICAgYXNzZXJ0IGlzaW5zdGFuY2UoYmxvYm5hbWUsIGludCkgYW5kIGJsb2JuYW1lID4gMAogICAgICAgICAgICBjb21taXRkYXRhLm5vdGUoYmxvYm5hbWUsIG9iam5hbWUpCiAgICAgICAgZ2ZpLmNvbW1pdChzZWxmLm5vdGVzX3JlZiwgY29tbWl0ZGF0YSkKICAgICAgICBzZWxmLmltcG9ydHMgPSBbXQoKCmNsYXNzIEdpdENhY2hlZE5vdGVzKEdpdE5vdGVzKToKCiAgICAiIiJFbmNhcHN1bGF0ZSBhY2Nlc3MgdG8gR2l0IG5vdGVzIChjYWNoZWQgdmVyc2lvbikuCgogICAgT25seSB1c2UgdGhpcyBjbGFzcyBpZiBubyBjYWNoaW5nIGlzIGRvbmUgYXQgYSBoaWdoZXIgbGV2ZWwuCgogICAgU2ltdWxhdGVzIGEgZGljdGlvbmFyeSBvZiBvYmplY3QgbmFtZSAoU0hBMSkgLT4gR2l0IG5vdGUgbWFwcGluZ3MuCgogICAgIiIiCgogICAgZGVmIF9faW5pdF9fIChzZWxmLCBub3Rlc19yZWYsIG9ial9mZXRjaGVyKToKICAgICAgICAiIiJTZXQgdXAgYSBjYWNoaW5nIHdyYXBwZXIgYXJvdW5kIEdpdE5vdGVzLiIiIgogICAgICAgIEdpdE5vdGVzLl9faW5pdF9fKHNlbGYsIG5vdGVzX3JlZiwgb2JqX2ZldGNoZXIpCiAgICAgICAgc2VsZi5fY2FjaGUgPSB7fSAgIyBDYWNoZTogb2JqZWN0IG5hbWUgLT4gbm90ZSBkYXRhCgogICAgZGVmIF9fZGVsX18gKHNlbGYpOgogICAgICAgICIiIlZlcmlmeSB0aGF0IEdpdE5vdGVzJyBkZXN0cnVjdG9yIGlzIGNhbGxlZC4iIiIKICAgICAgICBHaXROb3Rlcy5fX2RlbF9fKHNlbGYpCgogICAgZGVmIF9sb2FkIChzZWxmLCBvYmpuYW1lKToKICAgICAgICAiIiJFeHRlbmQgR2l0Tm90ZXMuX2xvYWQoKSB3aXRoIGEgbG9jYWwgb2JqbmFtZSAtPiBub3RlIGNhY2hlLiIiIgogICAgICAgIGlmIG9iam5hbWUgbm90IGluIHNlbGYuX2NhY2hlOgogICAgICAgICAgICBzZWxmLl9jYWNoZVtvYmpuYW1lXSA9IEdpdE5vdGVzLl9sb2FkKHNlbGYsIG9iam5hbWUpCiAgICAgICAgcmV0dXJuIHNlbGYuX2NhY2hlW29iam5hbWVdCgogICAgZGVmIGltcG9ydF9ub3RlIChzZWxmLCBvYmpuYW1lLCBkYXRhLCBnZmkpOgogICAgICAgICIiIkV4dGVuZCBHaXROb3Rlcy5pbXBvcnRfbm90ZSgpIHdpdGggYSBsb2NhbCBvYmpuYW1lIC0+IG5vdGUgY2FjaGUuIiIiCiAgICAgICAgaWYgbm90IGRhdGEuZW5kc3dpdGgoIlxuIik6CiAgICAgICAgICAgIGRhdGEgKz0gIlxuIgogICAgICAgIGFzc2VydCBvYmpuYW1lIG5vdCBpbiBzZWxmLl9jYWNoZQogICAgICAgIHNlbGYuX2NhY2hlW29iam5hbWVdID0gZGF0YQogICAgICAgIEdpdE5vdGVzLmltcG9ydF9ub3RlKHNlbGYsIG9iam5hbWUsIGRhdGEsIGdmaSkKCgppZiBfX25hbWVfXyA9PSAnX19tYWluX18nOgogICAgdW5pdHRlc3QubWFpbigpCg==",
    "text": "#!/usr/bin/env python\n\n\"\"\"Functionality for interacting with Git repositories.\n\nThis module provides classes for interfacing with a Git repository.\n\"\"\"\n\nimport os\nimport re\nimport time\nfrom binascii import hexlify\nfrom cStringIO import StringIO\nimport unittest\n\nfrom git_remote_helpers.util import debug, error, die, start_command, run_command\n\n\ndef get_git_dir ():\n    \"\"\"Return the path to the GIT_DIR for this repo.\"\"\"\n    args = (\"git\", \"rev-parse\", \"--git-dir\")\n    exit_code, output, errors = run_command(args)\n    if exit_code:\n        die(\"Failed to retrieve git dir\")\n    assert not errors\n    return output.strip()\n\n\ndef parse_git_config ():\n    \"\"\"Return a dict containing the parsed version of 'git config -l'.\"\"\"\n    exit_code, output, errors = run_command((\"git\", \"config\", \"-z\", \"-l\"))\n    if exit_code:\n        die(\"Failed to retrieve git configuration\")\n    assert not errors\n    return dict([e.split('\\n', 1) for e in output.split(\"\\0\") if e])\n\n\ndef git_config_bool (value):\n    \"\"\"Convert the given git config string value to True or False.\n\n    Raise ValueError if the given string was not recognized as a\n    boolean value.\n\n    \"\"\"\n    norm_value = str(value).strip().lower()\n    if norm_value in (\"true\", \"1\", \"yes\", \"on\", \"\"):\n        return True\n    if norm_value in (\"false\", \"0\", \"no\", \"off\", \"none\"):\n        return False\n    raise ValueError(\"Failed to parse '%s' into a boolean value\" % (value))\n\n\ndef valid_git_ref (ref_name):\n    \"\"\"Return True iff the given ref name is a valid git ref name.\"\"\"\n    # The following is a reimplementation of the git check-ref-format\n    # command.  The rules were derived from the git check-ref-format(1)\n    # manual page.  This code should be replaced by a call to\n    # check_refname_format() in the git library, when such is available.\n    if ref_name.endswith('/') or \\\n       ref_name.startswith('.') or \\\n       ref_name.count('/.') or \\\n       ref_name.count('..') or \\\n       ref_name.endswith('.lock'):\n        return False\n    for c in ref_name:\n        if ord(c) < 0x20 or ord(c) == 0x7f or c in \" ~^:?*[\":\n            return False\n    return True\n\n\nclass GitObjectFetcher(object):\n\n    \"\"\"Provide parsed access to 'git cat-file --batch'.\n\n    This provides a read-only interface to the Git object database.\n\n    \"\"\"\n\n    def __init__ (self):\n        \"\"\"Initiate a 'git cat-file --batch' session.\"\"\"\n        self.queue = []  # List of object names to be submitted\n        self.in_transit = None  # Object name currently in transit\n\n        # 'git cat-file --batch' produces binary output which is likely\n        # to be corrupted by the default \"rU\"-mode pipe opened by\n        # start_command.  (Mode == \"rU\" does universal new-line\n        # conversion, which mangles carriage returns.) Therefore, we\n        # open an explicitly binary-safe pipe for transferring the\n        # output from 'git cat-file --batch'.\n        pipe_r_fd, pipe_w_fd = os.pipe()\n        pipe_r = os.fdopen(pipe_r_fd, \"rb\")\n        pipe_w = os.fdopen(pipe_w_fd, \"wb\")\n        self.proc = start_command((\"git\", \"cat-file\", \"--batch\"),\n                                  stdout = pipe_w)\n        self.f = pipe_r\n\n    def __del__ (self):\n        \"\"\"Verify completed communication with 'git cat-file --batch'.\"\"\"\n        assert not self.queue\n        assert self.in_transit is None\n        self.proc.stdin.close()\n        assert self.proc.wait() == 0  # Zero exit code\n        assert self.f.read() == \"\"  # No remaining output\n\n    def _submit_next_object (self):\n        \"\"\"Submit queue items to the 'git cat-file --batch' process.\n\n        If there are items in the queue, and there is currently no item\n        currently in 'transit', then pop the first item off the queue,\n        and submit it.\n\n        \"\"\"\n        if self.queue and self.in_transit is None:\n            self.in_transit = self.queue.pop(0)\n            print >> self.proc.stdin, self.in_transit[0]\n\n    def push (self, obj, callback):\n        \"\"\"Push the given object name onto the queue.\n\n        The given callback function will at some point in the future\n        be called exactly once with the following arguments:\n        - self - this GitObjectFetcher instance\n        - obj  - the object name provided to push()\n        - sha1 - the SHA1 of the object, if 'None' obj is missing\n        - t    - the type of the object (tag/commit/tree/blob)\n        - size - the size of the object in bytes\n        - data - the object contents\n\n        \"\"\"\n        self.queue.append((obj, callback))\n        self._submit_next_object()  # (Re)start queue processing\n\n    def process_next_entry (self):\n        \"\"\"Read the next entry off the queue and invoke callback.\"\"\"\n        obj, cb = self.in_transit\n        self.in_transit = None\n        header = self.f.readline()\n        if header == \"%s missing\\n\" % (obj):\n            cb(self, obj, None, None, None, None)\n            return\n        sha1, t, size = header.split(\" \")\n        assert len(sha1) == 40\n        assert t in (\"tag\", \"commit\", \"tree\", \"blob\")\n        assert size.endswith(\"\\n\")\n        size = int(size.strip())\n        data = self.f.read(size)\n        assert self.f.read(1) == \"\\n\"\n        cb(self, obj, sha1, t, size, data)\n        self._submit_next_object()\n\n    def process (self):\n        \"\"\"Process the current queue until empty.\"\"\"\n        while self.in_transit is not None:\n            self.process_next_entry()\n\n    # High-level convenience methods:\n\n    def get_sha1 (self, objspec):\n        \"\"\"Return the SHA1 of the object specified by 'objspec'.\n\n        Return None if 'objspec' does not specify an existing object.\n\n        \"\"\"\n        class _ObjHandler(object):\n            \"\"\"Helper class for getting the returned SHA1.\"\"\"\n            def __init__ (self, parser):\n                self.parser = parser\n                self.sha1 = None\n\n            def __call__ (self, parser, obj, sha1, t, size, data):\n                # FIXME: Many unused arguments. Could this be cheaper?\n                assert parser == self.parser\n                self.sha1 = sha1\n\n        handler = _ObjHandler(self)\n        self.push(objspec, handler)\n        self.process()\n        return handler.sha1\n\n    def open_obj (self, objspec):\n        \"\"\"Return a file object wrapping the contents of a named object.\n\n        The caller is responsible for calling .close() on the returned\n        file object.\n\n        Raise KeyError if 'objspec' does not exist in the repo.\n\n        \"\"\"\n        class _ObjHandler(object):\n            \"\"\"Helper class for parsing the returned git object.\"\"\"\n            def __init__ (self, parser):\n                \"\"\"Set up helper.\"\"\"\n                self.parser = parser\n                self.contents = StringIO()\n                self.err = None\n\n            def __call__ (self, parser, obj, sha1, t, size, data):\n                \"\"\"Git object callback (see GitObjectFetcher documentation).\"\"\"\n                assert parser == self.parser\n                if not sha1:  # Missing object\n                    self.err = \"Missing object '%s'\" % obj\n                else:\n                    assert size == len(data)\n                    self.contents.write(data)\n\n        handler = _ObjHandler(self)\n        self.push(objspec, handler)\n        self.process()\n        if handler.err:\n            raise KeyError(handler.err)\n        handler.contents.seek(0)\n        return handler.contents\n\n    def walk_tree (self, tree_objspec, callback, prefix = \"\"):\n        \"\"\"Recursively walk the given Git tree object.\n\n        Recursively walk all subtrees of the given tree object, and\n        invoke the given callback passing three arguments:\n        (path, mode, data) with the path, permission bits, and contents\n        of all the blobs found in the entire tree structure.\n\n        \"\"\"\n        class _ObjHandler(object):\n            \"\"\"Helper class for walking a git tree structure.\"\"\"\n            def __init__ (self, parser, cb, path, mode = None):\n                \"\"\"Set up helper.\"\"\"\n                self.parser = parser\n                self.cb = cb\n                self.path = path\n                self.mode = mode\n                self.err = None\n\n            def parse_tree (self, treedata):\n                \"\"\"Parse tree object data, yield tree entries.\n\n                Each tree entry is a 3-tuple (mode, sha1, path)\n\n                self.path is prepended to all paths yielded\n                from this method.\n\n                \"\"\"\n                while treedata:\n                    mode = int(treedata[:6], 10)\n                    # Turn 100xxx into xxx\n                    if mode > 100000:\n                        mode -= 100000\n                    assert treedata[6] == \" \"\n                    i = treedata.find(\"\\0\", 7)\n                    assert i > 0\n                    path = treedata[7:i]\n                    sha1 = hexlify(treedata[i + 1: i + 21])\n                    yield (mode, sha1, self.path + path)\n                    treedata = treedata[i + 21:]\n\n            def __call__ (self, parser, obj, sha1, t, size, data):\n                \"\"\"Git object callback (see GitObjectFetcher documentation).\"\"\"\n                assert parser == self.parser\n                if not sha1:  # Missing object\n                    self.err = \"Missing object '%s'\" % (obj)\n                    return\n                assert size == len(data)\n                if t == \"tree\":\n                    if self.path:\n                        self.path += \"/\"\n                    # Recurse into all blobs and subtrees\n                    for m, s, p in self.parse_tree(data):\n                        parser.push(s,\n                                    self.__class__(self.parser, self.cb, p, m))\n                elif t == \"blob\":\n                    self.cb(self.path, self.mode, data)\n                else:\n                    raise ValueError(\"Unknown object type '%s'\" % (t))\n\n        self.push(tree_objspec, _ObjHandler(self, callback, prefix))\n        self.process()\n\n\nclass GitRefMap(object):\n\n    \"\"\"Map Git ref names to the Git object names they currently point to.\n\n    Behaves like a dictionary of Git ref names -> Git object names.\n\n    \"\"\"\n\n    def __init__ (self, obj_fetcher):\n        \"\"\"Create a new Git ref -> object map.\"\"\"\n        self.obj_fetcher = obj_fetcher\n        self._cache = {}  # dict: refname -> objname\n\n    def _load (self, ref):\n        \"\"\"Retrieve the object currently bound to the given ref.\n\n        The name of the object pointed to by the given ref is stored\n        into this mapping, and also returned.\n\n        \"\"\"\n        if ref not in self._cache:\n            self._cache[ref] = self.obj_fetcher.get_sha1(ref)\n        return self._cache[ref]\n\n    def __contains__ (self, refname):\n        \"\"\"Return True if the given refname is present in this cache.\"\"\"\n        return bool(self._load(refname))\n\n    def __getitem__ (self, refname):\n        \"\"\"Return the git object name pointed to by the given refname.\"\"\"\n        commit = self._load(refname)\n        if commit is None:\n            raise KeyError(\"Unknown ref '%s'\" % (refname))\n        return commit\n\n    def get (self, refname, default = None):\n        \"\"\"Return the git object name pointed to by the given refname.\"\"\"\n        commit = self._load(refname)\n        if commit is None:\n            return default\n        return commit\n\n\nclass GitFICommit(object):\n\n    \"\"\"Encapsulate the data in a Git fast-import commit command.\"\"\"\n\n    SHA1RE = re.compile(r'^[0-9a-f]{40}$')\n\n    @classmethod\n    def parse_mode (cls, mode):\n        \"\"\"Verify the given git file mode, and return it as a string.\"\"\"\n        assert mode in (644, 755, 100644, 100755, 120000)\n        return \"%i\" % (mode)\n\n    @classmethod\n    def parse_objname (cls, objname):\n        \"\"\"Return the given object name (or mark number) as a string.\"\"\"\n        if isinstance(objname, int):  # Object name is a mark number\n            assert objname > 0\n            return \":%i\" % (objname)\n\n        # No existence check is done, only checks for valid format\n        assert cls.SHA1RE.match(objname)  # Object name is valid SHA1\n        return objname\n\n    @classmethod\n    def quote_path (cls, path):\n        \"\"\"Return a quoted version of the given path.\"\"\"\n        path = path.replace(\"\\\\\", \"\\\\\\\\\")\n        path = path.replace(\"\\n\", \"\\\\n\")\n        path = path.replace('\"', '\\\\\"')\n        return '\"%s\"' % (path)\n\n    @classmethod\n    def parse_path (cls, path):\n        \"\"\"Verify that the given path is valid, and quote it, if needed.\"\"\"\n        assert not isinstance(path, int)  # Cannot be a mark number\n\n        # These checks verify the rules on the fast-import man page\n        assert not path.count(\"//\")\n        assert not path.endswith(\"/\")\n        assert not path.startswith(\"/\")\n        assert not path.count(\"/./\")\n        assert not path.count(\"/../\")\n        assert not path.endswith(\"/.\")\n        assert not path.endswith(\"/..\")\n        assert not path.startswith(\"./\")\n        assert not path.startswith(\"../\")\n\n        if path.count('\"') + path.count('\\n') + path.count('\\\\'):\n            return cls.quote_path(path)\n        return path\n\n    def __init__ (self, name, email, timestamp, timezone, message):\n        \"\"\"Create a new Git fast-import commit, with the given metadata.\"\"\"\n        self.name = name\n        self.email = email\n        self.timestamp = timestamp\n        self.timezone = timezone\n        self.message = message\n        self.pathops = []  # List of path operations in this commit\n\n    def modify (self, mode, blobname, path):\n        \"\"\"Add a file modification to this Git fast-import commit.\"\"\"\n        self.pathops.append((\"M\",\n                             self.parse_mode(mode),\n                             self.parse_objname(blobname),\n                             self.parse_path(path)))\n\n    def delete (self, path):\n        \"\"\"Add a file deletion to this Git fast-import commit.\"\"\"\n        self.pathops.append((\"D\", self.parse_path(path)))\n\n    def copy (self, path, newpath):\n        \"\"\"Add a file copy to this Git fast-import commit.\"\"\"\n        self.pathops.append((\"C\",\n                             self.parse_path(path),\n                             self.parse_path(newpath)))\n\n    def rename (self, path, newpath):\n        \"\"\"Add a file rename to this Git fast-import commit.\"\"\"\n        self.pathops.append((\"R\",\n                             self.parse_path(path),\n                             self.parse_path(newpath)))\n\n    def note (self, blobname, commit):\n        \"\"\"Add a note object to this Git fast-import commit.\"\"\"\n        self.pathops.append((\"N\",\n                             self.parse_objname(blobname),\n                             self.parse_objname(commit)))\n\n    def deleteall (self):\n        \"\"\"Delete all files in this Git fast-import commit.\"\"\"\n        self.pathops.append(\"deleteall\")\n\n\nclass TestGitFICommit(unittest.TestCase):\n\n    \"\"\"GitFICommit selftests.\"\"\"\n\n    def test_basic (self):\n        \"\"\"GitFICommit basic selftests.\"\"\"\n\n        def expect_fail (method, data):\n            \"\"\"Verify that the method(data) raises an AssertionError.\"\"\"\n            try:\n                method(data)\n            except AssertionError:\n                return\n            raise AssertionError(\"Failed test for invalid data '%s(%s)'\" %\n                                 (method.__name__, repr(data)))\n\n    def test_parse_mode (self):\n        \"\"\"GitFICommit.parse_mode() selftests.\"\"\"\n        self.assertEqual(GitFICommit.parse_mode(644), \"644\")\n        self.assertEqual(GitFICommit.parse_mode(755), \"755\")\n        self.assertEqual(GitFICommit.parse_mode(100644), \"100644\")\n        self.assertEqual(GitFICommit.parse_mode(100755), \"100755\")\n        self.assertEqual(GitFICommit.parse_mode(120000), \"120000\")\n        self.assertRaises(AssertionError, GitFICommit.parse_mode, 0)\n        self.assertRaises(AssertionError, GitFICommit.parse_mode, 123)\n        self.assertRaises(AssertionError, GitFICommit.parse_mode, 600)\n        self.assertRaises(AssertionError, GitFICommit.parse_mode, \"644\")\n        self.assertRaises(AssertionError, GitFICommit.parse_mode, \"abc\")\n\n    def test_parse_objname (self):\n        \"\"\"GitFICommit.parse_objname() selftests.\"\"\"\n        self.assertEqual(GitFICommit.parse_objname(1), \":1\")\n        self.assertRaises(AssertionError, GitFICommit.parse_objname, 0)\n        self.assertRaises(AssertionError, GitFICommit.parse_objname, -1)\n        self.assertEqual(GitFICommit.parse_objname(\"0123456789\" * 4),\n                         \"0123456789\" * 4)\n        self.assertEqual(GitFICommit.parse_objname(\"2468abcdef\" * 4),\n                         \"2468abcdef\" * 4)\n        self.assertRaises(AssertionError, GitFICommit.parse_objname,\n                          \"abcdefghij\" * 4)\n\n    def test_parse_path (self):\n        \"\"\"GitFICommit.parse_path() selftests.\"\"\"\n        self.assertEqual(GitFICommit.parse_path(\"foo/bar\"), \"foo/bar\")\n        self.assertEqual(GitFICommit.parse_path(\"path/with\\n and \\\" in it\"),\n                         '\"path/with\\\\n and \\\\\" in it\"')\n        self.assertRaises(AssertionError, GitFICommit.parse_path, 1)\n        self.assertRaises(AssertionError, GitFICommit.parse_path, 0)\n        self.assertRaises(AssertionError, GitFICommit.parse_path, -1)\n        self.assertRaises(AssertionError, GitFICommit.parse_path, \"foo//bar\")\n        self.assertRaises(AssertionError, GitFICommit.parse_path, \"foo/bar/\")\n        self.assertRaises(AssertionError, GitFICommit.parse_path, \"/foo/bar\")\n        self.assertRaises(AssertionError, GitFICommit.parse_path, \"foo/./bar\")\n        self.assertRaises(AssertionError, GitFICommit.parse_path, \"foo/../bar\")\n        self.assertRaises(AssertionError, GitFICommit.parse_path, \"foo/bar/.\")\n        self.assertRaises(AssertionError, GitFICommit.parse_path, \"foo/bar/..\")\n        self.assertRaises(AssertionError, GitFICommit.parse_path, \"./foo/bar\")\n        self.assertRaises(AssertionError, GitFICommit.parse_path, \"../foo/bar\")\n\n\nclass GitFastImport(object):\n\n    \"\"\"Encapsulate communication with git fast-import.\"\"\"\n\n    def __init__ (self, f, obj_fetcher, last_mark = 0):\n        \"\"\"Set up self to communicate with a fast-import process through f.\"\"\"\n        self.f = f  # File object where fast-import stream is written\n        self.obj_fetcher = obj_fetcher  # GitObjectFetcher instance\n        self.next_mark = last_mark + 1  # Next mark number\n        self.refs = set()  # Keep track of the refnames we've seen\n\n    def comment (self, s):\n        \"\"\"Write the given comment in the fast-import stream.\"\"\"\n        assert \"\\n\" not in s, \"Malformed comment: '%s'\" % (s)\n        self.f.write(\"# %s\\n\" % (s))\n\n    def commit (self, ref, commitdata):\n        \"\"\"Make a commit on the given ref, with the given GitFICommit.\n\n        Return the mark number identifying this commit.\n\n        \"\"\"\n        self.f.write(\"\"\"\\\ncommit %(ref)s\nmark :%(mark)i\ncommitter %(name)s <%(email)s> %(timestamp)i %(timezone)s\ndata %(msgLength)i\n%(msg)s\n\"\"\" % {\n    'ref': ref,\n    'mark': self.next_mark,\n    'name': commitdata.name,\n    'email': commitdata.email,\n    'timestamp': commitdata.timestamp,\n    'timezone': commitdata.timezone,\n    'msgLength': len(commitdata.message),\n    'msg': commitdata.message,\n})\n\n        if ref not in self.refs:\n            self.refs.add(ref)\n            parent = ref + \"^0\"\n            if self.obj_fetcher.get_sha1(parent):\n                self.f.write(\"from %s\\n\" % (parent))\n\n        for op in commitdata.pathops:\n            self.f.write(\" \".join(op))\n            self.f.write(\"\\n\")\n        self.f.write(\"\\n\")\n        retval = self.next_mark\n        self.next_mark += 1\n        return retval\n\n    def blob (self, data):\n        \"\"\"Import the given blob.\n\n        Return the mark number identifying this blob.\n\n        \"\"\"\n        self.f.write(\"blob\\nmark :%i\\ndata %i\\n%s\\n\" %\n                     (self.next_mark, len(data), data))\n        retval = self.next_mark\n        self.next_mark += 1\n        return retval\n\n    def reset (self, ref, objname):\n        \"\"\"Reset the given ref to point at the given Git object.\"\"\"\n        self.f.write(\"reset %s\\nfrom %s\\n\\n\" %\n                     (ref, GitFICommit.parse_objname(objname)))\n        if ref not in self.refs:\n            self.refs.add(ref)\n\n\nclass GitNotes(object):\n\n    \"\"\"Encapsulate access to Git notes.\n\n    Simulates a dictionary of object name (SHA1) -> Git note mappings.\n\n    \"\"\"\n\n    def __init__ (self, notes_ref, obj_fetcher):\n        \"\"\"Create a new Git notes interface, bound to the given notes ref.\"\"\"\n        self.notes_ref = notes_ref\n        self.obj_fetcher = obj_fetcher  # Used to get objects from repo\n        self.imports = []  # list: (objname, note data blob name) tuples\n\n    def __del__ (self):\n        \"\"\"Verify that self.commit_notes() was called before destruction.\"\"\"\n        if self.imports:\n            error(\"Missing call to self.commit_notes().\")\n            error(\"%i notes are not committed!\", len(self.imports))\n\n    def _load (self, objname):\n        \"\"\"Return the note data associated with the given git object.\n\n        The note data is returned in string form. If no note is found\n        for the given object, None is returned.\n\n        \"\"\"\n        try:\n            f = self.obj_fetcher.open_obj(\"%s:%s\" % (self.notes_ref, objname))\n            ret = f.read()\n            f.close()\n        except KeyError:\n            ret = None\n        return ret\n\n    def __getitem__ (self, objname):\n        \"\"\"Return the note contents associated with the given object.\n\n        Raise KeyError if given object has no associated note.\n\n        \"\"\"\n        blobdata = self._load(objname)\n        if blobdata is None:\n            raise KeyError(\"Object '%s' has no note\" % (objname))\n        return blobdata\n\n    def get (self, objname, default = None):\n        \"\"\"Return the note contents associated with the given object.\n\n        Return given default if given object has no associated note.\n\n        \"\"\"\n        blobdata = self._load(objname)\n        if blobdata is None:\n            return default\n        return blobdata\n\n    def import_note (self, objname, data, gfi):\n        \"\"\"Tell git fast-import to store data as a note for objname.\n\n        This method uses the given GitFastImport object to create a\n        blob containing the given note data.  Also an entry mapping the\n        given object name to the created blob is stored until\n        commit_notes() is called.\n\n        Note that this method only works if it is later followed by a\n        call to self.commit_notes() (which produces the note commit\n        that refers to the blob produced here).\n\n        \"\"\"\n        if not data.endswith(\"\\n\"):\n            data += \"\\n\"\n        gfi.comment(\"Importing note for object %s\" % (objname))\n        mark = gfi.blob(data)\n        self.imports.append((objname, mark))\n\n    def commit_notes (self, gfi, author, message):\n        \"\"\"Produce a git fast-import note commit for the imported notes.\n\n        This method uses the given GitFastImport object to create a\n        commit on the notes ref, introducing the notes previously\n        submitted to import_note().\n\n        \"\"\"\n        if not self.imports:\n            return\n        commitdata = GitFICommit(author[0], author[1],\n                                 time.time(), \"0000\", message)\n        for objname, blobname in self.imports:\n            assert isinstance(objname, int) and objname > 0\n            assert isinstance(blobname, int) and blobname > 0\n            commitdata.note(blobname, objname)\n        gfi.commit(self.notes_ref, commitdata)\n        self.imports = []\n\n\nclass GitCachedNotes(GitNotes):\n\n    \"\"\"Encapsulate access to Git notes (cached version).\n\n    Only use this class if no caching is done at a higher level.\n\n    Simulates a dictionary of object name (SHA1) -> Git note mappings.\n\n    \"\"\"\n\n    def __init__ (self, notes_ref, obj_fetcher):\n        \"\"\"Set up a caching wrapper around GitNotes.\"\"\"\n        GitNotes.__init__(self, notes_ref, obj_fetcher)\n        self._cache = {}  # Cache: object name -> note data\n\n    def __del__ (self):\n        \"\"\"Verify that GitNotes' destructor is called.\"\"\"\n        GitNotes.__del__(self)\n\n    def _load (self, objname):\n        \"\"\"Extend GitNotes._load() with a local objname -> note cache.\"\"\"\n        if objname not in self._cache:\n            self._cache[objname] = GitNotes._load(self, objname)\n        return self._cache[objname]\n\n    def import_note (self, objname, data, gfi):\n        \"\"\"Extend GitNotes.import_note() with a local objname -> note cache.\"\"\"\n        if not data.endswith(\"\\n\"):\n            data += \"\\n\"\n        assert objname not in self._cache\n        self._cache[objname] = data\n        GitNotes.import_note(self, objname, data, gfi)\n\n\nif __name__ == '__main__':\n    unittest.main()\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "007a1bfdf37d231470f69d9d0cffa46e80127f34",
  "sha1_ok": true,
  "size": 24712
}
