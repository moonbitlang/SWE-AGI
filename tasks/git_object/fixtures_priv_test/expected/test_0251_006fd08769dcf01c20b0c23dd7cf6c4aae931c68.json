{
  "content": {
    "base64": "LyoKICogImdpdCBhZGQiIGJ1aWx0aW4gY29tbWFuZAogKgogKiBDb3B5cmlnaHQgKEMpIDIwMDYgTGludXMgVG9ydmFsZHMKICovCiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJleGVjX2NtZC5oIgojaW5jbHVkZSAiY2FjaGUtdHJlZS5oIgojaW5jbHVkZSAicnVuLWNvbW1hbmQuaCIKI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgInJldmlzaW9uLmgiCgpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGJ1aWx0aW5fYWRkX3VzYWdlW10gPSB7CgkiZ2l0IGFkZCBbb3B0aW9uc10gWy0tXSA8ZmlsZXBhdHRlcm4+Li4uIiwKCU5VTEwKfTsKc3RhdGljIGludCBwYXRjaF9pbnRlcmFjdGl2ZSwgYWRkX2ludGVyYWN0aXZlLCBlZGl0X2ludGVyYWN0aXZlOwpzdGF0aWMgaW50IHRha2Vfd29ya3RyZWVfY2hhbmdlczsKCnN0YXRpYyB2b2lkIGZpbGxfcGF0aHNwZWNfbWF0Y2hlcyhjb25zdCBjaGFyICoqcGF0aHNwZWMsIGNoYXIgKnNlZW4sIGludCBzcGVjcykKewoJaW50IG51bV91bm1hdGNoZWQgPSAwLCBpOwoKCS8qCgkgKiBTaW5jZSB3ZSBhcmUgd2Fsa2luZyB0aGUgaW5kZXggYXMgaWYgd2Ugd2VyZSB3YWxraW5nIHRoZSBkaXJlY3RvcnksCgkgKiB3ZSBoYXZlIHRvIG1hcmsgdGhlIG1hdGNoZWQgcGF0aHNwZWMgYXMgc2Vlbjsgb3RoZXJ3aXNlIHdlIHdpbGwKCSAqIG1pc3Rha2VubHkgdGhpbmsgdGhhdCB0aGUgdXNlciBnYXZlIGEgcGF0aHNwZWMgdGhhdCBkaWQgbm90IG1hdGNoCgkgKiBhbnl0aGluZy4KCSAqLwoJZm9yIChpID0gMDsgaSA8IHNwZWNzOyBpKyspCgkJaWYgKCFzZWVuW2ldKQoJCQludW1fdW5tYXRjaGVkKys7CglpZiAoIW51bV91bm1hdGNoZWQpCgkJcmV0dXJuOwoJZm9yIChpID0gMDsgaSA8IGFjdGl2ZV9ucjsgaSsrKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGFjdGl2ZV9jYWNoZVtpXTsKCQltYXRjaF9wYXRoc3BlYyhwYXRoc3BlYywgY2UtPm5hbWUsIGNlX25hbWVsZW4oY2UpLCAwLCBzZWVuKTsKCX0KfQoKc3RhdGljIHZvaWQgcHJ1bmVfZGlyZWN0b3J5KHN0cnVjdCBkaXJfc3RydWN0ICpkaXIsIGNvbnN0IGNoYXIgKipwYXRoc3BlYywgaW50IHByZWZpeCkKewoJY2hhciAqc2VlbjsKCWludCBpLCBzcGVjczsKCXN0cnVjdCBkaXJfZW50cnkgKipzcmMsICoqZHN0OwoKCWZvciAoc3BlY3MgPSAwOyBwYXRoc3BlY1tzcGVjc107ICBzcGVjcysrKQoJCS8qIG5vdGhpbmcgKi87CglzZWVuID0geGNhbGxvYyhzcGVjcywgMSk7CgoJc3JjID0gZHN0ID0gZGlyLT5lbnRyaWVzOwoJaSA9IGRpci0+bnI7Cgl3aGlsZSAoLS1pID49IDApIHsKCQlzdHJ1Y3QgZGlyX2VudHJ5ICplbnRyeSA9ICpzcmMrKzsKCQlpZiAobWF0Y2hfcGF0aHNwZWMocGF0aHNwZWMsIGVudHJ5LT5uYW1lLCBlbnRyeS0+bGVuLAoJCQkJICAgcHJlZml4LCBzZWVuKSkKCQkJKmRzdCsrID0gZW50cnk7Cgl9CglkaXItPm5yID0gZHN0IC0gZGlyLT5lbnRyaWVzOwoJZmlsbF9wYXRoc3BlY19tYXRjaGVzKHBhdGhzcGVjLCBzZWVuLCBzcGVjcyk7CgoJZm9yIChpID0gMDsgaSA8IHNwZWNzOyBpKyspIHsKCQlpZiAoIXNlZW5baV0gJiYgcGF0aHNwZWNbaV1bMF0gJiYgIWZpbGVfZXhpc3RzKHBhdGhzcGVjW2ldKSkKCQkJZGllKCJwYXRoc3BlYyAnJXMnIGRpZCBub3QgbWF0Y2ggYW55IGZpbGVzIiwKCQkJCQlwYXRoc3BlY1tpXSk7Cgl9CiAgICAgICAgZnJlZShzZWVuKTsKfQoKc3RhdGljIHZvaWQgdHJlYXRfZ2l0bGlua3MoY29uc3QgY2hhciAqKnBhdGhzcGVjKQp7CglpbnQgaTsKCglpZiAoIXBhdGhzcGVjIHx8ICEqcGF0aHNwZWMpCgkJcmV0dXJuOwoKCWZvciAoaSA9IDA7IGkgPCBhY3RpdmVfbnI7IGkrKykgewoJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBhY3RpdmVfY2FjaGVbaV07CgkJaWYgKFNfSVNHSVRMSU5LKGNlLT5jZV9tb2RlKSkgewoJCQlpbnQgbGVuID0gY2VfbmFtZWxlbihjZSksIGo7CgkJCWZvciAoaiA9IDA7IHBhdGhzcGVjW2pdOyBqKyspIHsKCQkJCWludCBsZW4yID0gc3RybGVuKHBhdGhzcGVjW2pdKTsKCQkJCWlmIChsZW4yIDw9IGxlbiB8fCBwYXRoc3BlY1tqXVtsZW5dICE9ICcvJyB8fAoJCQkJICAgIG1lbWNtcChjZS0+bmFtZSwgcGF0aHNwZWNbal0sIGxlbikpCgkJCQkJY29udGludWU7CgkJCQlpZiAobGVuMiA9PSBsZW4gKyAxKQoJCQkJCS8qIHN0cmlwIHRyYWlsaW5nIHNsYXNoICovCgkJCQkJcGF0aHNwZWNbal0gPSB4c3RybmR1cChjZS0+bmFtZSwgbGVuKTsKCQkJCWVsc2UKCQkJCQlkaWUgKCJQYXRoICclcycgaXMgaW4gc3VibW9kdWxlICclLipzJyIsCgkJCQkJCXBhdGhzcGVjW2pdLCBsZW4sIGNlLT5uYW1lKTsKCQkJfQoJCX0KCX0KfQoKc3RhdGljIHZvaWQgcmVmcmVzaChpbnQgdmVyYm9zZSwgY29uc3QgY2hhciAqKnBhdGhzcGVjKQp7CgljaGFyICpzZWVuOwoJaW50IGksIHNwZWNzOwoKCWZvciAoc3BlY3MgPSAwOyBwYXRoc3BlY1tzcGVjc107ICBzcGVjcysrKQoJCS8qIG5vdGhpbmcgKi87CglzZWVuID0geGNhbGxvYyhzcGVjcywgMSk7CglyZWZyZXNoX2luZGV4KCZ0aGVfaW5kZXgsIHZlcmJvc2UgPyBSRUZSRVNIX0lOX1BPUkNFTEFJTiA6IFJFRlJFU0hfUVVJRVQsCgkJICAgICAgcGF0aHNwZWMsIHNlZW4sICJVbnN0YWdlZCBjaGFuZ2VzIGFmdGVyIHJlZnJlc2hpbmcgdGhlIGluZGV4OiIpOwoJZm9yIChpID0gMDsgaSA8IHNwZWNzOyBpKyspIHsKCQlpZiAoIXNlZW5baV0pCgkJCWRpZSgicGF0aHNwZWMgJyVzJyBkaWQgbm90IG1hdGNoIGFueSBmaWxlcyIsIHBhdGhzcGVjW2ldKTsKCX0KICAgICAgICBmcmVlKHNlZW4pOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqKnZhbGlkYXRlX3BhdGhzcGVjKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7Cgljb25zdCBjaGFyICoqcGF0aHNwZWMgPSBnZXRfcGF0aHNwZWMocHJlZml4LCBhcmd2KTsKCglpZiAocGF0aHNwZWMpIHsKCQljb25zdCBjaGFyICoqcDsKCQlmb3IgKHAgPSBwYXRoc3BlYzsgKnA7IHArKykgewoJCQlpZiAoaGFzX3N5bWxpbmtfbGVhZGluZ19wYXRoKCpwLCBzdHJsZW4oKnApKSkgewoJCQkJaW50IGxlbiA9IHByZWZpeCA/IHN0cmxlbihwcmVmaXgpIDogMDsKCQkJCWRpZSgiJyVzJyBpcyBiZXlvbmQgYSBzeW1ib2xpYyBsaW5rIiwgKnAgKyBsZW4pOwoJCQl9CgkJfQoJfQoKCXJldHVybiBwYXRoc3BlYzsKfQoKaW50IGludGVyYWN0aXZlX2FkZChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJaW50IHN0YXR1cywgYWM7Cgljb25zdCBjaGFyICoqYXJnczsKCWNvbnN0IGNoYXIgKipwYXRoc3BlYyA9IE5VTEw7CgoJaWYgKGFyZ2MpIHsKCQlwYXRoc3BlYyA9IHZhbGlkYXRlX3BhdGhzcGVjKGFyZ2MsIGFyZ3YsIHByZWZpeCk7CgkJaWYgKCFwYXRoc3BlYykKCQkJcmV0dXJuIC0xOwoJfQoKCWFyZ3MgPSB4Y2FsbG9jKHNpemVvZihjb25zdCBjaGFyICopLCAoYXJnYyArIDQpKTsKCWFjID0gMDsKCWFyZ3NbYWMrK10gPSAiYWRkLS1pbnRlcmFjdGl2ZSI7CglpZiAocGF0Y2hfaW50ZXJhY3RpdmUpCgkJYXJnc1thYysrXSA9ICItLXBhdGNoIjsKCWFyZ3NbYWMrK10gPSAiLS0iOwoJaWYgKGFyZ2MpIHsKCQltZW1jcHkoJihhcmdzW2FjXSksIHBhdGhzcGVjLCBzaXplb2YoY29uc3QgY2hhciAqKSAqIGFyZ2MpOwoJCWFjICs9IGFyZ2M7Cgl9CglhcmdzW2FjXSA9IE5VTEw7CgoJc3RhdHVzID0gcnVuX2NvbW1hbmRfdl9vcHQoYXJncywgUlVOX0dJVF9DTUQpOwoJZnJlZShhcmdzKTsKCXJldHVybiBzdGF0dXM7Cn0KCnN0YXRpYyBpbnQgZWRpdF9wYXRjaChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJY2hhciAqZmlsZSA9IHhzdHJkdXAoZ2l0X3BhdGgoIkFERF9FRElULnBhdGNoIikpOwoJY29uc3QgY2hhciAqYXBwbHlfYXJndltdID0geyAiYXBwbHkiLCAiLS1yZWNvdW50IiwgIi0tY2FjaGVkIiwKCQlmaWxlLCBOVUxMIH07CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBjaGlsZDsKCXN0cnVjdCByZXZfaW5mbyByZXY7CglpbnQgb3V0OwoJc3RydWN0IHN0YXQgc3Q7CgoJZ2l0X2NvbmZpZyhnaXRfZGlmZl9iYXNpY19jb25maWcsIE5VTEwpOyAvKiBubyAiZGlmZiIgVUkgb3B0aW9ucyAqLwoKCWlmIChyZWFkX2NhY2hlKCkgPCAwKQoJCWRpZSAoIkNvdWxkIG5vdCByZWFkIHRoZSBpbmRleCIpOwoKCWluaXRfcmV2aXNpb25zKCZyZXYsIHByZWZpeCk7CglyZXYuZGlmZm9wdC5jb250ZXh0ID0gNzsKCglhcmdjID0gc2V0dXBfcmV2aXNpb25zKGFyZ2MsIGFyZ3YsICZyZXYsIE5VTEwpOwoJcmV2LmRpZmZvcHQub3V0cHV0X2Zvcm1hdCA9IERJRkZfRk9STUFUX1BBVENIOwoJb3V0ID0gb3BlbihmaWxlLCBPX0NSRUFUIHwgT19XUk9OTFksIDA2NDQpOwoJaWYgKG91dCA8IDApCgkJZGllICgiQ291bGQgbm90IG9wZW4gJyVzJyBmb3Igd3JpdGluZy4iLCBmaWxlKTsKCXJldi5kaWZmb3B0LmZpbGUgPSBmZG9wZW4ob3V0LCAidyIpOwoJcmV2LmRpZmZvcHQuY2xvc2VfZmlsZSA9IDE7CglpZiAocnVuX2RpZmZfZmlsZXMoJnJldiwgMCkpCgkJZGllICgiQ291bGQgbm90IHdyaXRlIHBhdGNoIik7CgoJbGF1bmNoX2VkaXRvcihmaWxlLCBOVUxMLCBOVUxMKTsKCglpZiAoc3RhdChmaWxlLCAmc3QpKQoJCWRpZV9lcnJubygiQ291bGQgbm90IHN0YXQgJyVzJyIsIGZpbGUpOwoJaWYgKCFzdC5zdF9zaXplKQoJCWRpZSgiRW1wdHkgcGF0Y2guIEFib3J0ZWQuIik7CgoJbWVtc2V0KCZjaGlsZCwgMCwgc2l6ZW9mKGNoaWxkKSk7CgljaGlsZC5naXRfY21kID0gMTsKCWNoaWxkLmFyZ3YgPSBhcHBseV9hcmd2OwoJaWYgKHJ1bl9jb21tYW5kKCZjaGlsZCkpCgkJZGllICgiQ291bGQgbm90IGFwcGx5ICclcyciLCBmaWxlKTsKCgl1bmxpbmsoZmlsZSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHN0cnVjdCBsb2NrX2ZpbGUgbG9ja19maWxlOwoKc3RhdGljIGNvbnN0IGNoYXIgaWdub3JlX2Vycm9yW10gPQoiVGhlIGZvbGxvd2luZyBwYXRocyBhcmUgaWdub3JlZCBieSBvbmUgb2YgeW91ciAuZ2l0aWdub3JlIGZpbGVzOlxuIjsKCnN0YXRpYyBpbnQgdmVyYm9zZSA9IDAsIHNob3dfb25seSA9IDAsIGlnbm9yZWRfdG9vID0gMCwgcmVmcmVzaF9vbmx5ID0gMDsKc3RhdGljIGludCBpZ25vcmVfYWRkX2Vycm9ycywgYWRkcmVtb3ZlLCBpbnRlbnRfdG9fYWRkOwoKc3RhdGljIHN0cnVjdCBvcHRpb24gYnVpbHRpbl9hZGRfb3B0aW9uc1tdID0gewoJT1BUX19EUllfUlVOKCZzaG93X29ubHkpLAoJT1BUX19WRVJCT1NFKCZ2ZXJib3NlKSwKCU9QVF9HUk9VUCgiIiksCglPUFRfQk9PTEVBTignaScsICJpbnRlcmFjdGl2ZSIsICZhZGRfaW50ZXJhY3RpdmUsICJpbnRlcmFjdGl2ZSBwaWNraW5nIiksCglPUFRfQk9PTEVBTigncCcsICJwYXRjaCIsICZwYXRjaF9pbnRlcmFjdGl2ZSwgImludGVyYWN0aXZlIHBhdGNoaW5nIiksCglPUFRfQk9PTEVBTignZScsICJlZGl0IiwgJmVkaXRfaW50ZXJhY3RpdmUsICJlZGl0IGN1cnJlbnQgZGlmZiBhbmQgYXBwbHkiKSwKCU9QVF9CT09MRUFOKCdmJywgImZvcmNlIiwgJmlnbm9yZWRfdG9vLCAiYWxsb3cgYWRkaW5nIG90aGVyd2lzZSBpZ25vcmVkIGZpbGVzIiksCglPUFRfQk9PTEVBTigndScsICJ1cGRhdGUiLCAmdGFrZV93b3JrdHJlZV9jaGFuZ2VzLCAidXBkYXRlIHRyYWNrZWQgZmlsZXMiKSwKCU9QVF9CT09MRUFOKCdOJywgImludGVudC10by1hZGQiLCAmaW50ZW50X3RvX2FkZCwgInJlY29yZCBvbmx5IHRoZSBmYWN0IHRoYXQgdGhlIHBhdGggd2lsbCBiZSBhZGRlZCBsYXRlciIpLAoJT1BUX0JPT0xFQU4oJ0EnLCAiYWxsIiwgJmFkZHJlbW92ZSwgImFkZCBhbGwsIG5vdGljaW5nIHJlbW92YWwgb2YgdHJhY2tlZCBmaWxlcyIpLAoJT1BUX0JPT0xFQU4oIDAgLCAicmVmcmVzaCIsICZyZWZyZXNoX29ubHksICJkb24ndCBhZGQsIG9ubHkgcmVmcmVzaCB0aGUgaW5kZXgiKSwKCU9QVF9CT09MRUFOKCAwICwgImlnbm9yZS1lcnJvcnMiLCAmaWdub3JlX2FkZF9lcnJvcnMsICJqdXN0IHNraXAgZmlsZXMgd2hpY2ggY2Fubm90IGJlIGFkZGVkIGJlY2F1c2Ugb2YgZXJyb3JzIiksCglPUFRfRU5EKCksCn07CgpzdGF0aWMgaW50IGFkZF9jb25maWcoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSwgdm9pZCAqY2IpCnsKCWlmICghc3RyY2FzZWNtcCh2YXIsICJhZGQuaWdub3JlLWVycm9ycyIpKSB7CgkJaWdub3JlX2FkZF9lcnJvcnMgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CglyZXR1cm4gZ2l0X2RlZmF1bHRfY29uZmlnKHZhciwgdmFsdWUsIGNiKTsKfQoKc3RhdGljIGludCBhZGRfZmlsZXMoc3RydWN0IGRpcl9zdHJ1Y3QgKmRpciwgaW50IGZsYWdzKQp7CglpbnQgaSwgZXhpdF9zdGF0dXMgPSAwOwoKCWlmIChkaXItPmlnbm9yZWRfbnIpIHsKCQlmcHJpbnRmKHN0ZGVyciwgaWdub3JlX2Vycm9yKTsKCQlmb3IgKGkgPSAwOyBpIDwgZGlyLT5pZ25vcmVkX25yOyBpKyspCgkJCWZwcmludGYoc3RkZXJyLCAiJXNcbiIsIGRpci0+aWdub3JlZFtpXS0+bmFtZSk7CgkJZnByaW50ZihzdGRlcnIsICJVc2UgLWYgaWYgeW91IHJlYWxseSB3YW50IHRvIGFkZCB0aGVtLlxuIik7CgkJZGllKCJubyBmaWxlcyBhZGRlZCIpOwoJfQoKCWZvciAoaSA9IDA7IGkgPCBkaXItPm5yOyBpKyspCgkJaWYgKGFkZF9maWxlX3RvX2NhY2hlKGRpci0+ZW50cmllc1tpXS0+bmFtZSwgZmxhZ3MpKSB7CgkJCWlmICghaWdub3JlX2FkZF9lcnJvcnMpCgkJCQlkaWUoImFkZGluZyBmaWxlcyBmYWlsZWQiKTsKCQkJZXhpdF9zdGF0dXMgPSAxOwoJCX0KCXJldHVybiBleGl0X3N0YXR1czsKfQoKaW50IGNtZF9hZGQoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCWludCBleGl0X3N0YXR1cyA9IDA7CglpbnQgbmV3ZmQ7Cgljb25zdCBjaGFyICoqcGF0aHNwZWM7CglzdHJ1Y3QgZGlyX3N0cnVjdCBkaXI7CglpbnQgZmxhZ3M7CglpbnQgYWRkX25ld19maWxlczsKCWludCByZXF1aXJlX3BhdGhzcGVjOwoKCWdpdF9jb25maWcoYWRkX2NvbmZpZywgTlVMTCk7CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBidWlsdGluX2FkZF9vcHRpb25zLAoJCQkgIGJ1aWx0aW5fYWRkX3VzYWdlLCBQQVJTRV9PUFRfS0VFUF9BUkdWMCk7CglpZiAocGF0Y2hfaW50ZXJhY3RpdmUpCgkJYWRkX2ludGVyYWN0aXZlID0gMTsKCWlmIChhZGRfaW50ZXJhY3RpdmUpCgkJZXhpdChpbnRlcmFjdGl2ZV9hZGQoYXJnYyAtIDEsIGFyZ3YgKyAxLCBwcmVmaXgpKTsKCglpZiAoZWRpdF9pbnRlcmFjdGl2ZSkKCQlyZXR1cm4oZWRpdF9wYXRjaChhcmdjLCBhcmd2LCBwcmVmaXgpKTsKCWFyZ2MtLTsKCWFyZ3YrKzsKCglpZiAoYWRkcmVtb3ZlICYmIHRha2Vfd29ya3RyZWVfY2hhbmdlcykKCQlkaWUoIi1BIGFuZCAtdSBhcmUgbXV0dWFsbHkgaW5jb21wYXRpYmxlIik7CglpZiAoKGFkZHJlbW92ZSB8fCB0YWtlX3dvcmt0cmVlX2NoYW5nZXMpICYmICFhcmdjKSB7CgkJc3RhdGljIGNvbnN0IGNoYXIgKmhlcmVbMl0gPSB7ICIuIiwgTlVMTCB9OwoJCWFyZ2MgPSAxOwoJCWFyZ3YgPSBoZXJlOwoJfQoKCWFkZF9uZXdfZmlsZXMgPSAhdGFrZV93b3JrdHJlZV9jaGFuZ2VzICYmICFyZWZyZXNoX29ubHk7CglyZXF1aXJlX3BhdGhzcGVjID0gIXRha2Vfd29ya3RyZWVfY2hhbmdlczsKCgluZXdmZCA9IGhvbGRfbG9ja2VkX2luZGV4KCZsb2NrX2ZpbGUsIDEpOwoKCWZsYWdzID0gKCh2ZXJib3NlID8gQUREX0NBQ0hFX1ZFUkJPU0UgOiAwKSB8CgkJIChzaG93X29ubHkgPyBBRERfQ0FDSEVfUFJFVEVORCA6IDApIHwKCQkgKGludGVudF90b19hZGQgPyBBRERfQ0FDSEVfSU5URU5UIDogMCkgfAoJCSAoaWdub3JlX2FkZF9lcnJvcnMgPyBBRERfQ0FDSEVfSUdOT1JFX0VSUk9SUyA6IDApIHwKCQkgKCEoYWRkcmVtb3ZlIHx8IHRha2Vfd29ya3RyZWVfY2hhbmdlcykKCQkgID8gQUREX0NBQ0hFX0lHTk9SRV9SRU1PVkFMIDogMCkpOwoKCWlmIChyZXF1aXJlX3BhdGhzcGVjICYmIGFyZ2MgPT0gMCkgewoJCWZwcmludGYoc3RkZXJyLCAiTm90aGluZyBzcGVjaWZpZWQsIG5vdGhpbmcgYWRkZWQuXG4iKTsKCQlmcHJpbnRmKHN0ZGVyciwgIk1heWJlIHlvdSB3YW50ZWQgdG8gc2F5ICdnaXQgYWRkIC4nP1xuIik7CgkJcmV0dXJuIDA7Cgl9CglwYXRoc3BlYyA9IHZhbGlkYXRlX3BhdGhzcGVjKGFyZ2MsIGFyZ3YsIHByZWZpeCk7CgoJaWYgKHJlYWRfY2FjaGUoKSA8IDApCgkJZGllKCJpbmRleCBmaWxlIGNvcnJ1cHQiKTsKCXRyZWF0X2dpdGxpbmtzKHBhdGhzcGVjKTsKCglpZiAoYWRkX25ld19maWxlcykgewoJCWludCBiYXNlbGVuOwoKCQkvKiBTZXQgdXAgdGhlIGRlZmF1bHQgZ2l0IHBvcmNlbGFpbiBleGNsdWRlcyAqLwoJCW1lbXNldCgmZGlyLCAwLCBzaXplb2YoZGlyKSk7CgkJaWYgKCFpZ25vcmVkX3RvbykgewoJCQlkaXIuZmxhZ3MgfD0gRElSX0NPTExFQ1RfSUdOT1JFRDsKCQkJc2V0dXBfc3RhbmRhcmRfZXhjbHVkZXMoJmRpcik7CgkJfQoKCQkvKiBUaGlzIHBpY2tzIHVwIHRoZSBwYXRocyB0aGF0IGFyZSBub3QgdHJhY2tlZCAqLwoJCWJhc2VsZW4gPSBmaWxsX2RpcmVjdG9yeSgmZGlyLCBwYXRoc3BlYyk7CgkJaWYgKHBhdGhzcGVjKQoJCQlwcnVuZV9kaXJlY3RvcnkoJmRpciwgcGF0aHNwZWMsIGJhc2VsZW4pOwoJfQoKCWlmIChyZWZyZXNoX29ubHkpIHsKCQlyZWZyZXNoKHZlcmJvc2UsIHBhdGhzcGVjKTsKCQlnb3RvIGZpbmlzaDsKCX0KCglleGl0X3N0YXR1cyB8PSBhZGRfZmlsZXNfdG9fY2FjaGUocHJlZml4LCBwYXRoc3BlYywgZmxhZ3MpOwoKCWlmIChhZGRfbmV3X2ZpbGVzKQoJCWV4aXRfc3RhdHVzIHw9IGFkZF9maWxlcygmZGlyLCBmbGFncyk7CgogZmluaXNoOgoJaWYgKGFjdGl2ZV9jYWNoZV9jaGFuZ2VkKSB7CgkJaWYgKHdyaXRlX2NhY2hlKG5ld2ZkLCBhY3RpdmVfY2FjaGUsIGFjdGl2ZV9ucikgfHwKCQkgICAgY29tbWl0X2xvY2tlZF9pbmRleCgmbG9ja19maWxlKSkKCQkJZGllKCJVbmFibGUgdG8gd3JpdGUgbmV3IGluZGV4IGZpbGUiKTsKCX0KCglyZXR1cm4gZXhpdF9zdGF0dXM7Cn0K",
    "text": "/*\n * \"git add\" builtin command\n *\n * Copyright (C) 2006 Linus Torvalds\n */\n#include \"cache.h\"\n#include \"builtin.h\"\n#include \"dir.h\"\n#include \"exec_cmd.h\"\n#include \"cache-tree.h\"\n#include \"run-command.h\"\n#include \"parse-options.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n\nstatic const char * const builtin_add_usage[] = {\n\t\"git add [options] [--] <filepattern>...\",\n\tNULL\n};\nstatic int patch_interactive, add_interactive, edit_interactive;\nstatic int take_worktree_changes;\n\nstatic void fill_pathspec_matches(const char **pathspec, char *seen, int specs)\n{\n\tint num_unmatched = 0, i;\n\n\t/*\n\t * Since we are walking the index as if we were walking the directory,\n\t * we have to mark the matched pathspec as seen; otherwise we will\n\t * mistakenly think that the user gave a pathspec that did not match\n\t * anything.\n\t */\n\tfor (i = 0; i < specs; i++)\n\t\tif (!seen[i])\n\t\t\tnum_unmatched++;\n\tif (!num_unmatched)\n\t\treturn;\n\tfor (i = 0; i < active_nr; i++) {\n\t\tstruct cache_entry *ce = active_cache[i];\n\t\tmatch_pathspec(pathspec, ce->name, ce_namelen(ce), 0, seen);\n\t}\n}\n\nstatic void prune_directory(struct dir_struct *dir, const char **pathspec, int prefix)\n{\n\tchar *seen;\n\tint i, specs;\n\tstruct dir_entry **src, **dst;\n\n\tfor (specs = 0; pathspec[specs];  specs++)\n\t\t/* nothing */;\n\tseen = xcalloc(specs, 1);\n\n\tsrc = dst = dir->entries;\n\ti = dir->nr;\n\twhile (--i >= 0) {\n\t\tstruct dir_entry *entry = *src++;\n\t\tif (match_pathspec(pathspec, entry->name, entry->len,\n\t\t\t\t   prefix, seen))\n\t\t\t*dst++ = entry;\n\t}\n\tdir->nr = dst - dir->entries;\n\tfill_pathspec_matches(pathspec, seen, specs);\n\n\tfor (i = 0; i < specs; i++) {\n\t\tif (!seen[i] && pathspec[i][0] && !file_exists(pathspec[i]))\n\t\t\tdie(\"pathspec '%s' did not match any files\",\n\t\t\t\t\tpathspec[i]);\n\t}\n        free(seen);\n}\n\nstatic void treat_gitlinks(const char **pathspec)\n{\n\tint i;\n\n\tif (!pathspec || !*pathspec)\n\t\treturn;\n\n\tfor (i = 0; i < active_nr; i++) {\n\t\tstruct cache_entry *ce = active_cache[i];\n\t\tif (S_ISGITLINK(ce->ce_mode)) {\n\t\t\tint len = ce_namelen(ce), j;\n\t\t\tfor (j = 0; pathspec[j]; j++) {\n\t\t\t\tint len2 = strlen(pathspec[j]);\n\t\t\t\tif (len2 <= len || pathspec[j][len] != '/' ||\n\t\t\t\t    memcmp(ce->name, pathspec[j], len))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (len2 == len + 1)\n\t\t\t\t\t/* strip trailing slash */\n\t\t\t\t\tpathspec[j] = xstrndup(ce->name, len);\n\t\t\t\telse\n\t\t\t\t\tdie (\"Path '%s' is in submodule '%.*s'\",\n\t\t\t\t\t\tpathspec[j], len, ce->name);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void refresh(int verbose, const char **pathspec)\n{\n\tchar *seen;\n\tint i, specs;\n\n\tfor (specs = 0; pathspec[specs];  specs++)\n\t\t/* nothing */;\n\tseen = xcalloc(specs, 1);\n\trefresh_index(&the_index, verbose ? REFRESH_IN_PORCELAIN : REFRESH_QUIET,\n\t\t      pathspec, seen, \"Unstaged changes after refreshing the index:\");\n\tfor (i = 0; i < specs; i++) {\n\t\tif (!seen[i])\n\t\t\tdie(\"pathspec '%s' did not match any files\", pathspec[i]);\n\t}\n        free(seen);\n}\n\nstatic const char **validate_pathspec(int argc, const char **argv, const char *prefix)\n{\n\tconst char **pathspec = get_pathspec(prefix, argv);\n\n\tif (pathspec) {\n\t\tconst char **p;\n\t\tfor (p = pathspec; *p; p++) {\n\t\t\tif (has_symlink_leading_path(*p, strlen(*p))) {\n\t\t\t\tint len = prefix ? strlen(prefix) : 0;\n\t\t\t\tdie(\"'%s' is beyond a symbolic link\", *p + len);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pathspec;\n}\n\nint interactive_add(int argc, const char **argv, const char *prefix)\n{\n\tint status, ac;\n\tconst char **args;\n\tconst char **pathspec = NULL;\n\n\tif (argc) {\n\t\tpathspec = validate_pathspec(argc, argv, prefix);\n\t\tif (!pathspec)\n\t\t\treturn -1;\n\t}\n\n\targs = xcalloc(sizeof(const char *), (argc + 4));\n\tac = 0;\n\targs[ac++] = \"add--interactive\";\n\tif (patch_interactive)\n\t\targs[ac++] = \"--patch\";\n\targs[ac++] = \"--\";\n\tif (argc) {\n\t\tmemcpy(&(args[ac]), pathspec, sizeof(const char *) * argc);\n\t\tac += argc;\n\t}\n\targs[ac] = NULL;\n\n\tstatus = run_command_v_opt(args, RUN_GIT_CMD);\n\tfree(args);\n\treturn status;\n}\n\nstatic int edit_patch(int argc, const char **argv, const char *prefix)\n{\n\tchar *file = xstrdup(git_path(\"ADD_EDIT.patch\"));\n\tconst char *apply_argv[] = { \"apply\", \"--recount\", \"--cached\",\n\t\tfile, NULL };\n\tstruct child_process child;\n\tstruct rev_info rev;\n\tint out;\n\tstruct stat st;\n\n\tgit_config(git_diff_basic_config, NULL); /* no \"diff\" UI options */\n\n\tif (read_cache() < 0)\n\t\tdie (\"Could not read the index\");\n\n\tinit_revisions(&rev, prefix);\n\trev.diffopt.context = 7;\n\n\targc = setup_revisions(argc, argv, &rev, NULL);\n\trev.diffopt.output_format = DIFF_FORMAT_PATCH;\n\tout = open(file, O_CREAT | O_WRONLY, 0644);\n\tif (out < 0)\n\t\tdie (\"Could not open '%s' for writing.\", file);\n\trev.diffopt.file = fdopen(out, \"w\");\n\trev.diffopt.close_file = 1;\n\tif (run_diff_files(&rev, 0))\n\t\tdie (\"Could not write patch\");\n\n\tlaunch_editor(file, NULL, NULL);\n\n\tif (stat(file, &st))\n\t\tdie_errno(\"Could not stat '%s'\", file);\n\tif (!st.st_size)\n\t\tdie(\"Empty patch. Aborted.\");\n\n\tmemset(&child, 0, sizeof(child));\n\tchild.git_cmd = 1;\n\tchild.argv = apply_argv;\n\tif (run_command(&child))\n\t\tdie (\"Could not apply '%s'\", file);\n\n\tunlink(file);\n\treturn 0;\n}\n\nstatic struct lock_file lock_file;\n\nstatic const char ignore_error[] =\n\"The following paths are ignored by one of your .gitignore files:\\n\";\n\nstatic int verbose = 0, show_only = 0, ignored_too = 0, refresh_only = 0;\nstatic int ignore_add_errors, addremove, intent_to_add;\n\nstatic struct option builtin_add_options[] = {\n\tOPT__DRY_RUN(&show_only),\n\tOPT__VERBOSE(&verbose),\n\tOPT_GROUP(\"\"),\n\tOPT_BOOLEAN('i', \"interactive\", &add_interactive, \"interactive picking\"),\n\tOPT_BOOLEAN('p', \"patch\", &patch_interactive, \"interactive patching\"),\n\tOPT_BOOLEAN('e', \"edit\", &edit_interactive, \"edit current diff and apply\"),\n\tOPT_BOOLEAN('f', \"force\", &ignored_too, \"allow adding otherwise ignored files\"),\n\tOPT_BOOLEAN('u', \"update\", &take_worktree_changes, \"update tracked files\"),\n\tOPT_BOOLEAN('N', \"intent-to-add\", &intent_to_add, \"record only the fact that the path will be added later\"),\n\tOPT_BOOLEAN('A', \"all\", &addremove, \"add all, noticing removal of tracked files\"),\n\tOPT_BOOLEAN( 0 , \"refresh\", &refresh_only, \"don't add, only refresh the index\"),\n\tOPT_BOOLEAN( 0 , \"ignore-errors\", &ignore_add_errors, \"just skip files which cannot be added because of errors\"),\n\tOPT_END(),\n};\n\nstatic int add_config(const char *var, const char *value, void *cb)\n{\n\tif (!strcasecmp(var, \"add.ignore-errors\")) {\n\t\tignore_add_errors = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\treturn git_default_config(var, value, cb);\n}\n\nstatic int add_files(struct dir_struct *dir, int flags)\n{\n\tint i, exit_status = 0;\n\n\tif (dir->ignored_nr) {\n\t\tfprintf(stderr, ignore_error);\n\t\tfor (i = 0; i < dir->ignored_nr; i++)\n\t\t\tfprintf(stderr, \"%s\\n\", dir->ignored[i]->name);\n\t\tfprintf(stderr, \"Use -f if you really want to add them.\\n\");\n\t\tdie(\"no files added\");\n\t}\n\n\tfor (i = 0; i < dir->nr; i++)\n\t\tif (add_file_to_cache(dir->entries[i]->name, flags)) {\n\t\t\tif (!ignore_add_errors)\n\t\t\t\tdie(\"adding files failed\");\n\t\t\texit_status = 1;\n\t\t}\n\treturn exit_status;\n}\n\nint cmd_add(int argc, const char **argv, const char *prefix)\n{\n\tint exit_status = 0;\n\tint newfd;\n\tconst char **pathspec;\n\tstruct dir_struct dir;\n\tint flags;\n\tint add_new_files;\n\tint require_pathspec;\n\n\tgit_config(add_config, NULL);\n\n\targc = parse_options(argc, argv, prefix, builtin_add_options,\n\t\t\t  builtin_add_usage, PARSE_OPT_KEEP_ARGV0);\n\tif (patch_interactive)\n\t\tadd_interactive = 1;\n\tif (add_interactive)\n\t\texit(interactive_add(argc - 1, argv + 1, prefix));\n\n\tif (edit_interactive)\n\t\treturn(edit_patch(argc, argv, prefix));\n\targc--;\n\targv++;\n\n\tif (addremove && take_worktree_changes)\n\t\tdie(\"-A and -u are mutually incompatible\");\n\tif ((addremove || take_worktree_changes) && !argc) {\n\t\tstatic const char *here[2] = { \".\", NULL };\n\t\targc = 1;\n\t\targv = here;\n\t}\n\n\tadd_new_files = !take_worktree_changes && !refresh_only;\n\trequire_pathspec = !take_worktree_changes;\n\n\tnewfd = hold_locked_index(&lock_file, 1);\n\n\tflags = ((verbose ? ADD_CACHE_VERBOSE : 0) |\n\t\t (show_only ? ADD_CACHE_PRETEND : 0) |\n\t\t (intent_to_add ? ADD_CACHE_INTENT : 0) |\n\t\t (ignore_add_errors ? ADD_CACHE_IGNORE_ERRORS : 0) |\n\t\t (!(addremove || take_worktree_changes)\n\t\t  ? ADD_CACHE_IGNORE_REMOVAL : 0));\n\n\tif (require_pathspec && argc == 0) {\n\t\tfprintf(stderr, \"Nothing specified, nothing added.\\n\");\n\t\tfprintf(stderr, \"Maybe you wanted to say 'git add .'?\\n\");\n\t\treturn 0;\n\t}\n\tpathspec = validate_pathspec(argc, argv, prefix);\n\n\tif (read_cache() < 0)\n\t\tdie(\"index file corrupt\");\n\ttreat_gitlinks(pathspec);\n\n\tif (add_new_files) {\n\t\tint baselen;\n\n\t\t/* Set up the default git porcelain excludes */\n\t\tmemset(&dir, 0, sizeof(dir));\n\t\tif (!ignored_too) {\n\t\t\tdir.flags |= DIR_COLLECT_IGNORED;\n\t\t\tsetup_standard_excludes(&dir);\n\t\t}\n\n\t\t/* This picks up the paths that are not tracked */\n\t\tbaselen = fill_directory(&dir, pathspec);\n\t\tif (pathspec)\n\t\t\tprune_directory(&dir, pathspec, baselen);\n\t}\n\n\tif (refresh_only) {\n\t\trefresh(verbose, pathspec);\n\t\tgoto finish;\n\t}\n\n\texit_status |= add_files_to_cache(prefix, pathspec, flags);\n\n\tif (add_new_files)\n\t\texit_status |= add_files(&dir, flags);\n\n finish:\n\tif (active_cache_changed) {\n\t\tif (write_cache(newfd, active_cache, active_nr) ||\n\t\t    commit_locked_index(&lock_file))\n\t\t\tdie(\"Unable to write new index file\");\n\t}\n\n\treturn exit_status;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "006fd08769dcf01c20b0c23dd7cf6c4aae931c68",
  "sha1_ok": true,
  "size": 9159
}
