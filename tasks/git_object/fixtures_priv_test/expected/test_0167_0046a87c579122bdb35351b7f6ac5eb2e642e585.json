{
  "content": {
    "base64": "I2RlZmluZSBVU0VfVEhFX1JFUE9TSVRPUllfVkFSSUFCTEUKI2RlZmluZSBESVNBQkxFX1NJR05fQ09NUEFSRV9XQVJOSU5HUwoKI2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImNvbmZpZy5oIgojaW5jbHVkZSAiZW52aXJvbm1lbnQuaCIKI2luY2x1ZGUgImdldHRleHQuaCIKI2luY2x1ZGUgImhhc2guaCIKI2luY2x1ZGUgImhleC5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAib2JqZWN0LW5hbWUuaCIKI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCIKI2luY2x1ZGUgInF1b3RlLmgiCgpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGdpdF91cGRhdGVfcmVmX3VzYWdlW10gPSB7CglOXygiZ2l0IHVwZGF0ZS1yZWYgWzxvcHRpb25zPl0gLWQgPHJlZm5hbWU+IFs8b2xkLW9pZD5dIiksCglOXygiZ2l0IHVwZGF0ZS1yZWYgWzxvcHRpb25zPl0gICAgPHJlZm5hbWU+IDxuZXctb2lkPiBbPG9sZC1vaWQ+XSIpLAoJTl8oImdpdCB1cGRhdGUtcmVmIFs8b3B0aW9ucz5dIC0tc3RkaW4gWy16XSBbLS1iYXRjaC11cGRhdGVzXSIpLAoJTlVMTAp9OwoKc3RhdGljIGNoYXIgbGluZV90ZXJtaW5hdGlvbiA9ICdcbic7CnN0YXRpYyB1bnNpZ25lZCBpbnQgdXBkYXRlX2ZsYWdzOwpzdGF0aWMgdW5zaWduZWQgaW50IGRlZmF1bHRfZmxhZ3M7CnN0YXRpYyB1bnNpZ25lZCBjcmVhdGVfcmVmbG9nX2ZsYWc7CnN0YXRpYyBjb25zdCBjaGFyICptc2c7CgovKgogKiBQYXJzZSBvbmUgd2hpdGVzcGFjZS0gb3IgTlVMLXRlcm1pbmF0ZWQsIHBvc3NpYmx5IEMtcXVvdGVkIGFyZ3VtZW50CiAqIGFuZCBhcHBlbmQgdGhlIHJlc3VsdCB0byBhcmcuICBSZXR1cm4gYSBwb2ludGVyIHRvIHRoZSB0ZXJtaW5hdG9yLgogKiBEaWUgaWYgdGhlcmUgaXMgYW4gZXJyb3IgaW4gaG93IHRoZSBhcmd1bWVudCBpcyBDLXF1b3RlZC4gIFRoaXMKICogZnVuY3Rpb24gaXMgb25seSB1c2VkIGlmIG5vdCAtei4KICovCnN0YXRpYyBjb25zdCBjaGFyICpwYXJzZV9hcmcoY29uc3QgY2hhciAqbmV4dCwgc3RydWN0IHN0cmJ1ZiAqYXJnKQp7CglpZiAoKm5leHQgPT0gJyInKSB7CgkJY29uc3QgY2hhciAqb3JpZyA9IG5leHQ7CgoJCWlmICh1bnF1b3RlX2Nfc3R5bGUoYXJnLCBuZXh0LCAmbmV4dCkpCgkJCWRpZSgiYmFkbHkgcXVvdGVkIGFyZ3VtZW50OiAlcyIsIG9yaWcpOwoJCWlmICgqbmV4dCAmJiAhaXNzcGFjZSgqbmV4dCkpCgkJCWRpZSgidW5leHBlY3RlZCBjaGFyYWN0ZXIgYWZ0ZXIgcXVvdGVkIGFyZ3VtZW50OiAlcyIsIG9yaWcpOwoJfSBlbHNlIHsKCQl3aGlsZSAoKm5leHQgJiYgIWlzc3BhY2UoKm5leHQpKQoJCQlzdHJidWZfYWRkY2goYXJnLCAqbmV4dCsrKTsKCX0KCglyZXR1cm4gbmV4dDsKfQoKLyoKICogUGFyc2UgdGhlIHJlZmVyZW5jZSBuYW1lIGltbWVkaWF0ZWx5IGFmdGVyICJjb21tYW5kIFNQIi4gIElmIG5vdAogKiAteiwgdGhlbiBoYW5kbGUgQy1xdW90aW5nLiAgUmV0dXJuIGEgcG9pbnRlciB0byBhIG5ld2x5IGFsbG9jYXRlZAogKiBzdHJpbmcgY29udGFpbmluZyB0aGUgbmFtZSBvZiB0aGUgcmVmZXJlbmNlLCBvciBOVUxMIGlmIHRoZXJlIHdhcwogKiBhbiBlcnJvci4gIFVwZGF0ZSAqbmV4dCB0byBwb2ludCBhdCB0aGUgY2hhcmFjdGVyIHRoYXQgdGVybWluYXRlcwogKiB0aGUgYXJndW1lbnQuICBEaWUgaWYgQy1xdW90aW5nIGlzIG1hbGZvcm1lZCBvciB0aGUgcmVmZXJlbmNlIG5hbWUKICogaXMgaW52YWxpZC4KICovCnN0YXRpYyBjaGFyICpwYXJzZV9yZWZuYW1lKGNvbnN0IGNoYXIgKipuZXh0KQp7CglzdHJ1Y3Qgc3RyYnVmIHJlZiA9IFNUUkJVRl9JTklUOwoKCWlmIChsaW5lX3Rlcm1pbmF0aW9uKSB7CgkJLyogV2l0aG91dCAteiwgdXNlIHRoZSBuZXh0IGFyZ3VtZW50ICovCgkJKm5leHQgPSBwYXJzZV9hcmcoKm5leHQsICZyZWYpOwoJfSBlbHNlIHsKCQkvKiBXaXRoIC16LCB1c2UgZXZlcnl0aGluZyB1cCB0byB0aGUgbmV4dCBOVUwgKi8KCQlzdHJidWZfYWRkc3RyKCZyZWYsICpuZXh0KTsKCQkqbmV4dCArPSByZWYubGVuOwoJfQoKCWlmICghcmVmLmxlbikgewoJCXN0cmJ1Zl9yZWxlYXNlKCZyZWYpOwoJCXJldHVybiBOVUxMOwoJfQoKCWlmIChjaGVja19yZWZuYW1lX2Zvcm1hdChyZWYuYnVmLCBSRUZOQU1FX0FMTE9XX09ORUxFVkVMKSkKCQlkaWUoImludmFsaWQgcmVmIGZvcm1hdDogJXMiLCByZWYuYnVmKTsKCglyZXR1cm4gc3RyYnVmX2RldGFjaCgmcmVmLCBOVUxMKTsKfQoKLyoKICogV3JhcHBlciBhcm91bmQgcGFyc2VfcmVmbmFtZSB3aGljaCBza2lwcyB0aGUgbmV4dCBkZWxpbWl0ZXIuCiAqLwpzdGF0aWMgY2hhciAqcGFyc2VfbmV4dF9yZWZuYW1lKGNvbnN0IGNoYXIgKipuZXh0KQp7CglpZiAobGluZV90ZXJtaW5hdGlvbikgewoJCS8qIFdpdGhvdXQgLXosIGNvbnN1bWUgU1AgYW5kIHVzZSBuZXh0IGFyZ3VtZW50ICovCgkJaWYgKCEqKm5leHQgfHwgKipuZXh0ID09IGxpbmVfdGVybWluYXRpb24pCgkJCXJldHVybiBOVUxMOwoJCWlmICgqKm5leHQgIT0gJyAnKQoJCQlkaWUoImV4cGVjdGVkIFNQIGJ1dCBnb3Q6ICVzIiwgKm5leHQpOwoJfSBlbHNlIHsKCQkvKiBXaXRoIC16LCByZWFkIHRoZSBuZXh0IE5VTC10ZXJtaW5hdGVkIGxpbmUgKi8KCQlpZiAoKipuZXh0KQoJCQlyZXR1cm4gTlVMTDsKCX0KCS8qIFNraXAgdGhlIGRlbGltaXRlciAqLwoJKCpuZXh0KSsrOwoKCXJldHVybiBwYXJzZV9yZWZuYW1lKG5leHQpOwp9CgovKgogKiBXcmFwcGVyIGFyb3VuZCBwYXJzZV9hcmcgd2hpY2ggc2tpcHMgdGhlIG5leHQgZGVsaW1pdGVyLgogKi8Kc3RhdGljIGNoYXIgKnBhcnNlX25leHRfYXJnKGNvbnN0IGNoYXIgKipuZXh0KQp7CglzdHJ1Y3Qgc3RyYnVmIGFyZyA9IFNUUkJVRl9JTklUOwoKCWlmIChsaW5lX3Rlcm1pbmF0aW9uKSB7CgkJLyogV2l0aG91dCAteiwgY29uc3VtZSBTUCBhbmQgdXNlIG5leHQgYXJndW1lbnQgKi8KCQlpZiAoISoqbmV4dCB8fCAqKm5leHQgPT0gbGluZV90ZXJtaW5hdGlvbikKCQkJcmV0dXJuIE5VTEw7CgkJaWYgKCoqbmV4dCAhPSAnICcpCgkJCWRpZSgiZXhwZWN0ZWQgU1AgYnV0IGdvdDogJXMiLCAqbmV4dCk7Cgl9IGVsc2UgewoJCS8qIFdpdGggLXosIHJlYWQgdGhlIG5leHQgTlVMLXRlcm1pbmF0ZWQgbGluZSAqLwoJCWlmICgqKm5leHQpCgkJCXJldHVybiBOVUxMOwoJfQoJLyogU2tpcCB0aGUgZGVsaW1pdGVyICovCgkoKm5leHQpKys7CgoJaWYgKGxpbmVfdGVybWluYXRpb24pIHsKCQkvKiBXaXRob3V0IC16LCB1c2UgdGhlIG5leHQgYXJndW1lbnQgKi8KCQkqbmV4dCA9IHBhcnNlX2FyZygqbmV4dCwgJmFyZyk7Cgl9IGVsc2UgewoJCS8qIFdpdGggLXosIHVzZSBldmVyeXRoaW5nIHVwIHRvIHRoZSBuZXh0IE5VTCAqLwoJCXN0cmJ1Zl9hZGRzdHIoJmFyZywgKm5leHQpOwoJCSpuZXh0ICs9IGFyZy5sZW47Cgl9CgoJaWYgKGFyZy5sZW4pCgkJcmV0dXJuIHN0cmJ1Zl9kZXRhY2goJmFyZywgTlVMTCk7CgoJc3RyYnVmX3JlbGVhc2UoJmFyZyk7CglyZXR1cm4gTlVMTDsKfQoKLyoKICogVGhlIHZhbHVlIGJlaW5nIHBhcnNlZCBpcyA8b2xkLW9pZD4gKGFzIG9wcG9zZWQgdG8gPG5ldy1vaWQ+OyB0aGUKICogZGlmZmVyZW5jZSBhZmZlY3RzIHdoaWNoIGVycm9yIG1lc3NhZ2VzIGFyZSBnZW5lcmF0ZWQpOgogKi8KI2RlZmluZSBQQVJTRV9TSEExX09MRCAweDAxCgovKgogKiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGFjY2VwdCBhbiBlbXB0eSBzdHJpbmcgZm9yIHVwZGF0ZSdzCiAqIDxuZXctb2lkPiBpbiBiaW5hcnkgbW9kZSB0byBiZSBlcXVpdmFsZW50IHRvIHNwZWNpZnlpbmcgemVyb3MuCiAqLwojZGVmaW5lIFBBUlNFX1NIQTFfQUxMT1dfRU1QVFkgMHgwMgoKLyoKICogUGFyc2UgYW4gYXJndW1lbnQgc2VwYXJhdG9yIGZvbGxvd2VkIGJ5IHRoZSBuZXh0IGFyZ3VtZW50LCBpZiBhbnkuCiAqIElmIHRoZXJlIGlzIGFuIGFyZ3VtZW50LCBjb252ZXJ0IGl0IHRvIGEgU0hBLTEsIHdyaXRlIGl0IHRvIHNoYTEsCiAqIHNldCAqbmV4dCB0byBwb2ludCBhdCB0aGUgY2hhcmFjdGVyIHRlcm1pbmF0aW5nIHRoZSBhcmd1bWVudCwgYW5kCiAqIHJldHVybiAwLiAgSWYgdGhlcmUgaXMgbm8gYXJndW1lbnQgYXQgYWxsIChub3QgZXZlbiB0aGUgZW1wdHkKICogc3RyaW5nKSwgcmV0dXJuIDEgYW5kIGxlYXZlICpuZXh0IHVuY2hhbmdlZC4gIElmIHRoZSB2YWx1ZSBpcwogKiBwcm92aWRlZCBidXQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIFNIQS0xLCBkaWUuICBmbGFncyBjYW4KICogaW5jbHVkZSBQQVJTRV9TSEExX09MRCBhbmQvb3IgUEFSU0VfU0hBMV9BTExPV19FTVBUWS4KICovCnN0YXRpYyBpbnQgcGFyc2VfbmV4dF9vaWQoY29uc3QgY2hhciAqKm5leHQsIGNvbnN0IGNoYXIgKmVuZCwKCQkJICBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCSAgY29uc3QgY2hhciAqY29tbWFuZCwgY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJICBpbnQgZmxhZ3MpCnsKCXN0cnVjdCBzdHJidWYgYXJnID0gU1RSQlVGX0lOSVQ7CglpbnQgcmV0ID0gMDsKCglpZiAoKm5leHQgPT0gZW5kKQoJCWdvdG8gZW9mOwoKCWlmIChsaW5lX3Rlcm1pbmF0aW9uKSB7CgkJLyogV2l0aG91dCAteiwgY29uc3VtZSBTUCBhbmQgdXNlIG5leHQgYXJndW1lbnQgKi8KCQlpZiAoISoqbmV4dCB8fCAqKm5leHQgPT0gbGluZV90ZXJtaW5hdGlvbikKCQkJcmV0dXJuIDE7CgkJaWYgKCoqbmV4dCAhPSAnICcpCgkJCWRpZSgiJXMgJXM6IGV4cGVjdGVkIFNQIGJ1dCBnb3Q6ICVzIiwKCQkJICAgIGNvbW1hbmQsIHJlZm5hbWUsICpuZXh0KTsKCQkoKm5leHQpKys7CgkJKm5leHQgPSBwYXJzZV9hcmcoKm5leHQsICZhcmcpOwoJCWlmIChhcmcubGVuKSB7CgkJCWlmIChyZXBvX2dldF9vaWRfd2l0aF9mbGFncyh0aGVfcmVwb3NpdG9yeSwgYXJnLmJ1Ziwgb2lkLAoJCQkJCQkgICAgR0VUX09JRF9TS0lQX0FNQklHVUlUWV9DSEVDSykpCgkJCQlnb3RvIGludmFsaWQ7CgkJfSBlbHNlIHsKCQkJLyogV2l0aG91dCAteiwgYW4gZW1wdHkgdmFsdWUgbWVhbnMgYWxsIHplcm9zOiAqLwoJCQlvaWRjbHIob2lkLCB0aGVfcmVwb3NpdG9yeS0+aGFzaF9hbGdvKTsKCQl9Cgl9IGVsc2UgewoJCS8qIFdpdGggLXosIHJlYWQgdGhlIG5leHQgTlVMLXRlcm1pbmF0ZWQgbGluZSAqLwoJCWlmICgqKm5leHQpCgkJCWRpZSgiJXMgJXM6IGV4cGVjdGVkIE5VTCBidXQgZ290OiAlcyIsCgkJCSAgICBjb21tYW5kLCByZWZuYW1lLCAqbmV4dCk7CgkJKCpuZXh0KSsrOwoJCWlmICgqbmV4dCA9PSBlbmQpCgkJCWdvdG8gZW9mOwoJCXN0cmJ1Zl9hZGRzdHIoJmFyZywgKm5leHQpOwoJCSpuZXh0ICs9IGFyZy5sZW47CgoJCWlmIChhcmcubGVuKSB7CgkJCWlmIChyZXBvX2dldF9vaWRfd2l0aF9mbGFncyh0aGVfcmVwb3NpdG9yeSwgYXJnLmJ1Ziwgb2lkLAoJCQkJCQkgICAgR0VUX09JRF9TS0lQX0FNQklHVUlUWV9DSEVDSykpCgkJCQlnb3RvIGludmFsaWQ7CgkJfSBlbHNlIGlmIChmbGFncyAmIFBBUlNFX1NIQTFfQUxMT1dfRU1QVFkpIHsKCQkJLyogV2l0aCAteiwgdHJlYXQgYW4gZW1wdHkgdmFsdWUgYXMgYWxsIHplcm9zOiAqLwoJCQl3YXJuaW5nKCIlcyAlczogbWlzc2luZyA8bmV3LW9pZD4sIHRyZWF0aW5nIGFzIHplcm8iLAoJCQkJY29tbWFuZCwgcmVmbmFtZSk7CgkJCW9pZGNscihvaWQsIHRoZV9yZXBvc2l0b3J5LT5oYXNoX2FsZ28pOwoJCX0gZWxzZSB7CgkJCS8qCgkJCSAqIFdpdGggLXosIGFuIGVtcHR5IG5vbi1yZXF1aXJlZCB2YWx1ZSBtZWFucwoJCQkgKiB1bnNwZWNpZmllZDoKCQkJICovCgkJCXJldCA9IDE7CgkJfQoJfQoKCXN0cmJ1Zl9yZWxlYXNlKCZhcmcpOwoKCXJldHVybiByZXQ7CgogaW52YWxpZDoKCWRpZShmbGFncyAmIFBBUlNFX1NIQTFfT0xEID8KCSAgICAiJXMgJXM6IGludmFsaWQgPG9sZC1vaWQ+OiAlcyIgOgoJICAgICIlcyAlczogaW52YWxpZCA8bmV3LW9pZD46ICVzIiwKCSAgICBjb21tYW5kLCByZWZuYW1lLCBhcmcuYnVmKTsKCiBlb2Y6CglkaWUoZmxhZ3MgJiBQQVJTRV9TSEExX09MRCA/CgkgICAgIiVzICVzOiB1bmV4cGVjdGVkIGVuZCBvZiBpbnB1dCB3aGVuIHJlYWRpbmcgPG9sZC1vaWQ+IiA6CgkgICAgIiVzICVzOiB1bmV4cGVjdGVkIGVuZCBvZiBpbnB1dCB3aGVuIHJlYWRpbmcgPG5ldy1vaWQ+IiwKCSAgICBjb21tYW5kLCByZWZuYW1lKTsKfQoKCi8qCiAqIFRoZSBmb2xsb3dpbmcgZml2ZSBwYXJzZV9jbWRfKigpIGZ1bmN0aW9ucyBwYXJzZSB0aGUgY29ycmVzcG9uZGluZwogKiBjb21tYW5kLiAgSW4gZWFjaCBjYXNlLCBuZXh0IHBvaW50cyBhdCB0aGUgY2hhcmFjdGVyIGZvbGxvd2luZyB0aGUKICogY29tbWFuZCBuYW1lIGFuZCB0aGUgZm9sbG93aW5nIHNwYWNlLiAgVGhleSBlYWNoIHJldHVybiBhIHBvaW50ZXIKICogdG8gdGhlIGNoYXJhY3RlciB0ZXJtaW5hdGluZyB0aGUgY29tbWFuZCwgYW5kIGRpZSB3aXRoIGFuCiAqIGV4cGxhbmF0b3J5IG1lc3NhZ2UgaWYgdGhlcmUgYXJlIGFueSBwYXJzaW5nIHByb2JsZW1zLiAgQWxsIG9mCiAqIHRoZXNlIGZ1bmN0aW9ucyBoYW5kbGUgZWl0aGVyIHRleHQgb3IgYmluYXJ5IGZvcm1hdCBpbnB1dCwKICogZGVwZW5kaW5nIG9uIGhvdyBsaW5lX3Rlcm1pbmF0aW9uIGlzIHNldC4KICovCgpzdGF0aWMgdm9pZCBwYXJzZV9jbWRfdXBkYXRlKHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyYW5zYWN0aW9uLAoJCQkgICAgIGNvbnN0IGNoYXIgKm5leHQsIGNvbnN0IGNoYXIgKmVuZCkKewoJc3RydWN0IHN0cmJ1ZiBlcnIgPSBTVFJCVUZfSU5JVDsKCWNoYXIgKnJlZm5hbWU7CglzdHJ1Y3Qgb2JqZWN0X2lkIG5ld19vaWQsIG9sZF9vaWQ7CglpbnQgaGF2ZV9vbGQ7CgoJcmVmbmFtZSA9IHBhcnNlX3JlZm5hbWUoJm5leHQpOwoJaWYgKCFyZWZuYW1lKQoJCWRpZSgidXBkYXRlOiBtaXNzaW5nIDxyZWY+Iik7CgoJaWYgKHBhcnNlX25leHRfb2lkKCZuZXh0LCBlbmQsICZuZXdfb2lkLCAidXBkYXRlIiwgcmVmbmFtZSwKCQkJICAgUEFSU0VfU0hBMV9BTExPV19FTVBUWSkpCgkJZGllKCJ1cGRhdGUgJXM6IG1pc3NpbmcgPG5ldy1vaWQ+IiwgcmVmbmFtZSk7CgoJaGF2ZV9vbGQgPSAhcGFyc2VfbmV4dF9vaWQoJm5leHQsIGVuZCwgJm9sZF9vaWQsICJ1cGRhdGUiLCByZWZuYW1lLAoJCQkJICAgUEFSU0VfU0hBMV9PTEQpOwoKCWlmICgqbmV4dCAhPSBsaW5lX3Rlcm1pbmF0aW9uKQoJCWRpZSgidXBkYXRlICVzOiBleHRyYSBpbnB1dDogJXMiLCByZWZuYW1lLCBuZXh0KTsKCglpZiAocmVmX3RyYW5zYWN0aW9uX3VwZGF0ZSh0cmFuc2FjdGlvbiwgcmVmbmFtZSwKCQkJCSAgICZuZXdfb2lkLCBoYXZlX29sZCA/ICZvbGRfb2lkIDogTlVMTCwKCQkJCSAgIE5VTEwsIE5VTEwsCgkJCQkgICB1cGRhdGVfZmxhZ3MgfCBjcmVhdGVfcmVmbG9nX2ZsYWcsCgkJCQkgICBtc2csICZlcnIpKQoJCWRpZSgiJXMiLCBlcnIuYnVmKTsKCgl1cGRhdGVfZmxhZ3MgPSBkZWZhdWx0X2ZsYWdzOwoJZnJlZShyZWZuYW1lKTsKCXN0cmJ1Zl9yZWxlYXNlKCZlcnIpOwp9CgpzdGF0aWMgdm9pZCBwYXJzZV9jbWRfc3ltcmVmX3VwZGF0ZShzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0cmFuc2FjdGlvbiwKCQkJCSAgICBjb25zdCBjaGFyICpuZXh0LCBjb25zdCBjaGFyICplbmQgVU5VU0VEKQp7CgljaGFyICpyZWZuYW1lLCAqbmV3X3RhcmdldCwgKm9sZF9hcmc7CgljaGFyICpvbGRfdGFyZ2V0ID0gTlVMTDsKCXN0cnVjdCBzdHJidWYgZXJyID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9sZF9vaWQ7CglpbnQgaGF2ZV9vbGRfb2lkID0gMDsKCglyZWZuYW1lID0gcGFyc2VfcmVmbmFtZSgmbmV4dCk7CglpZiAoIXJlZm5hbWUpCgkJZGllKCJzeW1yZWYtdXBkYXRlOiBtaXNzaW5nIDxyZWY+Iik7CgoJbmV3X3RhcmdldCA9IHBhcnNlX25leHRfcmVmbmFtZSgmbmV4dCk7CglpZiAoIW5ld190YXJnZXQpCgkJZGllKCJzeW1yZWYtdXBkYXRlICVzOiBtaXNzaW5nIDxuZXctdGFyZ2V0PiIsIHJlZm5hbWUpOwoKCW9sZF9hcmcgPSBwYXJzZV9uZXh0X2FyZygmbmV4dCk7CglpZiAob2xkX2FyZykgewoJCW9sZF90YXJnZXQgPSBwYXJzZV9uZXh0X2FyZygmbmV4dCk7CgkJaWYgKCFvbGRfdGFyZ2V0KQoJCQlkaWUoInN5bXJlZi11cGRhdGUgJXM6IGV4cGVjdGVkIG9sZCB2YWx1ZSIsIHJlZm5hbWUpOwoKCQlpZiAoIXN0cmNtcChvbGRfYXJnLCAib2lkIikpIHsKCQkJaWYgKHJlcG9fZ2V0X29pZF93aXRoX2ZsYWdzKHRoZV9yZXBvc2l0b3J5LCBvbGRfdGFyZ2V0LCAmb2xkX29pZCwKCQkJCQkJICAgIEdFVF9PSURfU0tJUF9BTUJJR1VJVFlfQ0hFQ0spKQoJCQkJZGllKCJzeW1yZWYtdXBkYXRlICVzOiBpbnZhbGlkIG9pZDogJXMiLCByZWZuYW1lLCBvbGRfdGFyZ2V0KTsKCgkJCWhhdmVfb2xkX29pZCA9IDE7CgkJfSBlbHNlIGlmICghc3RyY21wKG9sZF9hcmcsICJyZWYiKSkgewoJCQlpZiAoY2hlY2tfcmVmbmFtZV9mb3JtYXQob2xkX3RhcmdldCwgUkVGTkFNRV9BTExPV19PTkVMRVZFTCkpCgkJCQlkaWUoInN5bXJlZi11cGRhdGUgJXM6IGludmFsaWQgcmVmOiAlcyIsIHJlZm5hbWUsIG9sZF90YXJnZXQpOwoJCX0gZWxzZSB7CgkJCWRpZSgic3ltcmVmLXVwZGF0ZSAlczogaW52YWxpZCBhcmcgJyVzJyBmb3Igb2xkIHZhbHVlIiwgcmVmbmFtZSwgb2xkX2FyZyk7CgkJfQoJfQoKCWlmICgqbmV4dCAhPSBsaW5lX3Rlcm1pbmF0aW9uKQoJCWRpZSgic3ltcmVmLXVwZGF0ZSAlczogZXh0cmEgaW5wdXQ6ICVzIiwgcmVmbmFtZSwgbmV4dCk7CgoJaWYgKHJlZl90cmFuc2FjdGlvbl91cGRhdGUodHJhbnNhY3Rpb24sIHJlZm5hbWUsIE5VTEwsCgkJCQkgICBoYXZlX29sZF9vaWQgPyAmb2xkX29pZCA6IE5VTEwsCgkJCQkgICBuZXdfdGFyZ2V0LAoJCQkJICAgaGF2ZV9vbGRfb2lkID8gTlVMTCA6IG9sZF90YXJnZXQsCgkJCQkgICB1cGRhdGVfZmxhZ3MgfCBjcmVhdGVfcmVmbG9nX2ZsYWcsCgkJCQkgICBtc2csICZlcnIpKQoJCWRpZSgiJXMiLCBlcnIuYnVmKTsKCgl1cGRhdGVfZmxhZ3MgPSBkZWZhdWx0X2ZsYWdzOwoJZnJlZShyZWZuYW1lKTsKCWZyZWUob2xkX2FyZyk7CglmcmVlKG9sZF90YXJnZXQpOwoJZnJlZShuZXdfdGFyZ2V0KTsKCXN0cmJ1Zl9yZWxlYXNlKCZlcnIpOwp9CgpzdGF0aWMgdm9pZCBwYXJzZV9jbWRfY3JlYXRlKHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyYW5zYWN0aW9uLAoJCQkgICAgIGNvbnN0IGNoYXIgKm5leHQsIGNvbnN0IGNoYXIgKmVuZCkKewoJc3RydWN0IHN0cmJ1ZiBlcnIgPSBTVFJCVUZfSU5JVDsKCWNoYXIgKnJlZm5hbWU7CglzdHJ1Y3Qgb2JqZWN0X2lkIG5ld19vaWQ7CgoJcmVmbmFtZSA9IHBhcnNlX3JlZm5hbWUoJm5leHQpOwoJaWYgKCFyZWZuYW1lKQoJCWRpZSgiY3JlYXRlOiBtaXNzaW5nIDxyZWY+Iik7CgoJaWYgKHBhcnNlX25leHRfb2lkKCZuZXh0LCBlbmQsICZuZXdfb2lkLCAiY3JlYXRlIiwgcmVmbmFtZSwgMCkpCgkJZGllKCJjcmVhdGUgJXM6IG1pc3NpbmcgPG5ldy1vaWQ+IiwgcmVmbmFtZSk7CgoJaWYgKGlzX251bGxfb2lkKCZuZXdfb2lkKSkKCQlkaWUoImNyZWF0ZSAlczogemVybyA8bmV3LW9pZD4iLCByZWZuYW1lKTsKCglpZiAoKm5leHQgIT0gbGluZV90ZXJtaW5hdGlvbikKCQlkaWUoImNyZWF0ZSAlczogZXh0cmEgaW5wdXQ6ICVzIiwgcmVmbmFtZSwgbmV4dCk7CgoJaWYgKHJlZl90cmFuc2FjdGlvbl9jcmVhdGUodHJhbnNhY3Rpb24sIHJlZm5hbWUsICZuZXdfb2lkLCBOVUxMLAoJCQkJICAgdXBkYXRlX2ZsYWdzIHwgY3JlYXRlX3JlZmxvZ19mbGFnLAoJCQkJICAgbXNnLCAmZXJyKSkKCQlkaWUoIiVzIiwgZXJyLmJ1Zik7CgoJdXBkYXRlX2ZsYWdzID0gZGVmYXVsdF9mbGFnczsKCWZyZWUocmVmbmFtZSk7CglzdHJidWZfcmVsZWFzZSgmZXJyKTsKfQoKCnN0YXRpYyB2b2lkIHBhcnNlX2NtZF9zeW1yZWZfY3JlYXRlKHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyYW5zYWN0aW9uLAoJCQkJICAgIGNvbnN0IGNoYXIgKm5leHQsIGNvbnN0IGNoYXIgKmVuZCBVTlVTRUQpCnsKCXN0cnVjdCBzdHJidWYgZXJyID0gU1RSQlVGX0lOSVQ7CgljaGFyICpyZWZuYW1lLCAqbmV3X3RhcmdldDsKCglyZWZuYW1lID0gcGFyc2VfcmVmbmFtZSgmbmV4dCk7CglpZiAoIXJlZm5hbWUpCgkJZGllKCJzeW1yZWYtY3JlYXRlOiBtaXNzaW5nIDxyZWY+Iik7CgoJbmV3X3RhcmdldCA9IHBhcnNlX25leHRfcmVmbmFtZSgmbmV4dCk7CglpZiAoIW5ld190YXJnZXQpCgkJZGllKCJzeW1yZWYtY3JlYXRlICVzOiBtaXNzaW5nIDxuZXctdGFyZ2V0PiIsIHJlZm5hbWUpOwoKCWlmICgqbmV4dCAhPSBsaW5lX3Rlcm1pbmF0aW9uKQoJCWRpZSgic3ltcmVmLWNyZWF0ZSAlczogZXh0cmEgaW5wdXQ6ICVzIiwgcmVmbmFtZSwgbmV4dCk7CgoJaWYgKHJlZl90cmFuc2FjdGlvbl9jcmVhdGUodHJhbnNhY3Rpb24sIHJlZm5hbWUsIE5VTEwsIG5ld190YXJnZXQsCgkJCQkgICB1cGRhdGVfZmxhZ3MgfCBjcmVhdGVfcmVmbG9nX2ZsYWcsCgkJCQkgICBtc2csICZlcnIpKQoJCWRpZSgiJXMiLCBlcnIuYnVmKTsKCgl1cGRhdGVfZmxhZ3MgPSBkZWZhdWx0X2ZsYWdzOwoJZnJlZShyZWZuYW1lKTsKCWZyZWUobmV3X3RhcmdldCk7CglzdHJidWZfcmVsZWFzZSgmZXJyKTsKfQoKc3RhdGljIHZvaWQgcGFyc2VfY21kX2RlbGV0ZShzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0cmFuc2FjdGlvbiwKCQkJICAgICBjb25zdCBjaGFyICpuZXh0LCBjb25zdCBjaGFyICplbmQpCnsKCXN0cnVjdCBzdHJidWYgZXJyID0gU1RSQlVGX0lOSVQ7CgljaGFyICpyZWZuYW1lOwoJc3RydWN0IG9iamVjdF9pZCBvbGRfb2lkOwoJaW50IGhhdmVfb2xkOwoKCXJlZm5hbWUgPSBwYXJzZV9yZWZuYW1lKCZuZXh0KTsKCWlmICghcmVmbmFtZSkKCQlkaWUoImRlbGV0ZTogbWlzc2luZyA8cmVmPiIpOwoKCWlmIChwYXJzZV9uZXh0X29pZCgmbmV4dCwgZW5kLCAmb2xkX29pZCwgImRlbGV0ZSIsIHJlZm5hbWUsCgkJCSAgIFBBUlNFX1NIQTFfT0xEKSkgewoJCWhhdmVfb2xkID0gMDsKCX0gZWxzZSB7CgkJaWYgKGlzX251bGxfb2lkKCZvbGRfb2lkKSkKCQkJZGllKCJkZWxldGUgJXM6IHplcm8gPG9sZC1vaWQ+IiwgcmVmbmFtZSk7CgkJaGF2ZV9vbGQgPSAxOwoJfQoKCWlmICgqbmV4dCAhPSBsaW5lX3Rlcm1pbmF0aW9uKQoJCWRpZSgiZGVsZXRlICVzOiBleHRyYSBpbnB1dDogJXMiLCByZWZuYW1lLCBuZXh0KTsKCglpZiAocmVmX3RyYW5zYWN0aW9uX2RlbGV0ZSh0cmFuc2FjdGlvbiwgcmVmbmFtZSwKCQkJCSAgIGhhdmVfb2xkID8gJm9sZF9vaWQgOiBOVUxMLAoJCQkJICAgTlVMTCwgdXBkYXRlX2ZsYWdzLCBtc2csICZlcnIpKQoJCWRpZSgiJXMiLCBlcnIuYnVmKTsKCgl1cGRhdGVfZmxhZ3MgPSBkZWZhdWx0X2ZsYWdzOwoJZnJlZShyZWZuYW1lKTsKCXN0cmJ1Zl9yZWxlYXNlKCZlcnIpOwp9CgoKc3RhdGljIHZvaWQgcGFyc2VfY21kX3N5bXJlZl9kZWxldGUoc3RydWN0IHJlZl90cmFuc2FjdGlvbiAqdHJhbnNhY3Rpb24sCgkJCQkgICAgY29uc3QgY2hhciAqbmV4dCwgY29uc3QgY2hhciAqZW5kIFVOVVNFRCkKewoJc3RydWN0IHN0cmJ1ZiBlcnIgPSBTVFJCVUZfSU5JVDsKCWNoYXIgKnJlZm5hbWUsICpvbGRfdGFyZ2V0OwoKCWlmICghKHVwZGF0ZV9mbGFncyAmIFJFRl9OT19ERVJFRikpCgkJZGllKCJzeW1yZWYtZGVsZXRlOiBjYW5ub3Qgb3BlcmF0ZSB3aXRoIGRlcmVmIG1vZGUiKTsKCglyZWZuYW1lID0gcGFyc2VfcmVmbmFtZSgmbmV4dCk7CglpZiAoIXJlZm5hbWUpCgkJZGllKCJzeW1yZWYtZGVsZXRlOiBtaXNzaW5nIDxyZWY+Iik7CgoJb2xkX3RhcmdldCA9IHBhcnNlX25leHRfcmVmbmFtZSgmbmV4dCk7CgoJaWYgKCpuZXh0ICE9IGxpbmVfdGVybWluYXRpb24pCgkJZGllKCJzeW1yZWYtZGVsZXRlICVzOiBleHRyYSBpbnB1dDogJXMiLCByZWZuYW1lLCBuZXh0KTsKCglpZiAocmVmX3RyYW5zYWN0aW9uX2RlbGV0ZSh0cmFuc2FjdGlvbiwgcmVmbmFtZSwgTlVMTCwKCQkJCSAgIG9sZF90YXJnZXQsIHVwZGF0ZV9mbGFncywgbXNnLCAmZXJyKSkKCQlkaWUoIiVzIiwgZXJyLmJ1Zik7CgoJdXBkYXRlX2ZsYWdzID0gZGVmYXVsdF9mbGFnczsKCWZyZWUocmVmbmFtZSk7CglmcmVlKG9sZF90YXJnZXQpOwoJc3RyYnVmX3JlbGVhc2UoJmVycik7Cn0KCgpzdGF0aWMgdm9pZCBwYXJzZV9jbWRfdmVyaWZ5KHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyYW5zYWN0aW9uLAoJCQkgICAgIGNvbnN0IGNoYXIgKm5leHQsIGNvbnN0IGNoYXIgKmVuZCkKewoJc3RydWN0IHN0cmJ1ZiBlcnIgPSBTVFJCVUZfSU5JVDsKCWNoYXIgKnJlZm5hbWU7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9sZF9vaWQ7CgoJcmVmbmFtZSA9IHBhcnNlX3JlZm5hbWUoJm5leHQpOwoJaWYgKCFyZWZuYW1lKQoJCWRpZSgidmVyaWZ5OiBtaXNzaW5nIDxyZWY+Iik7CgoJaWYgKHBhcnNlX25leHRfb2lkKCZuZXh0LCBlbmQsICZvbGRfb2lkLCAidmVyaWZ5IiwgcmVmbmFtZSwKCQkJICAgUEFSU0VfU0hBMV9PTEQpKQoJCW9pZGNscigmb2xkX29pZCwgdGhlX3JlcG9zaXRvcnktPmhhc2hfYWxnbyk7CgoJaWYgKCpuZXh0ICE9IGxpbmVfdGVybWluYXRpb24pCgkJZGllKCJ2ZXJpZnkgJXM6IGV4dHJhIGlucHV0OiAlcyIsIHJlZm5hbWUsIG5leHQpOwoKCWlmIChyZWZfdHJhbnNhY3Rpb25fdmVyaWZ5KHRyYW5zYWN0aW9uLCByZWZuYW1lLCAmb2xkX29pZCwKCQkJCSAgIE5VTEwsIHVwZGF0ZV9mbGFncywgJmVycikpCgkJZGllKCIlcyIsIGVyci5idWYpOwoKCXVwZGF0ZV9mbGFncyA9IGRlZmF1bHRfZmxhZ3M7CglmcmVlKHJlZm5hbWUpOwoJc3RyYnVmX3JlbGVhc2UoJmVycik7Cn0KCnN0YXRpYyB2b2lkIHBhcnNlX2NtZF9zeW1yZWZfdmVyaWZ5KHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyYW5zYWN0aW9uLAoJCQkJICAgIGNvbnN0IGNoYXIgKm5leHQsIGNvbnN0IGNoYXIgKmVuZCBVTlVTRUQpCnsKCXN0cnVjdCBzdHJidWYgZXJyID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9sZF9vaWQ7CgljaGFyICpyZWZuYW1lLCAqb2xkX3RhcmdldDsKCglpZiAoISh1cGRhdGVfZmxhZ3MgJiBSRUZfTk9fREVSRUYpKQoJCWRpZSgic3ltcmVmLXZlcmlmeTogY2Fubm90IG9wZXJhdGUgd2l0aCBkZXJlZiBtb2RlIik7CgoJcmVmbmFtZSA9IHBhcnNlX3JlZm5hbWUoJm5leHQpOwoJaWYgKCFyZWZuYW1lKQoJCWRpZSgic3ltcmVmLXZlcmlmeTogbWlzc2luZyA8cmVmPiIpOwoKCS8qCgkgKiBvbGRfcmVmIGlzIG9wdGlvbmFsLCBpZiBub3QgcHJvdmlkZWQsIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlCgkgKiByZWYgZG9lc24ndCBleGlzdC4KCSAqLwoJb2xkX3RhcmdldCA9IHBhcnNlX25leHRfcmVmbmFtZSgmbmV4dCk7CglpZiAoIW9sZF90YXJnZXQpCgkJb2lkY3B5KCZvbGRfb2lkLCBudWxsX29pZCh0aGVfaGFzaF9hbGdvKSk7CgoJaWYgKCpuZXh0ICE9IGxpbmVfdGVybWluYXRpb24pCgkJZGllKCJzeW1yZWYtdmVyaWZ5ICVzOiBleHRyYSBpbnB1dDogJXMiLCByZWZuYW1lLCBuZXh0KTsKCglpZiAocmVmX3RyYW5zYWN0aW9uX3ZlcmlmeSh0cmFuc2FjdGlvbiwgcmVmbmFtZSwKCQkJCSAgIG9sZF90YXJnZXQgPyBOVUxMIDogJm9sZF9vaWQsCgkJCQkgICBvbGRfdGFyZ2V0LCB1cGRhdGVfZmxhZ3MsICZlcnIpKQoJCWRpZSgiJXMiLCBlcnIuYnVmKTsKCgl1cGRhdGVfZmxhZ3MgPSBkZWZhdWx0X2ZsYWdzOwoJZnJlZShyZWZuYW1lKTsKCWZyZWUob2xkX3RhcmdldCk7CglzdHJidWZfcmVsZWFzZSgmZXJyKTsKfQoKc3RhdGljIHZvaWQgcmVwb3J0X29rKGNvbnN0IGNoYXIgKmNvbW1hbmQpCnsKCWZwcmludGYoc3Rkb3V0LCAiJXM6IG9rXG4iLCBjb21tYW5kKTsKCWZmbHVzaChzdGRvdXQpOwp9CgpzdGF0aWMgdm9pZCBwYXJzZV9jbWRfb3B0aW9uKHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyYW5zYWN0aW9uIFVOVVNFRCwKCQkJICAgICBjb25zdCBjaGFyICpuZXh0LCBjb25zdCBjaGFyICplbmQgVU5VU0VEKQp7Cgljb25zdCBjaGFyICpyZXN0OwoJaWYgKHNraXBfcHJlZml4KG5leHQsICJuby1kZXJlZiIsICZyZXN0KSAmJiAqcmVzdCA9PSBsaW5lX3Rlcm1pbmF0aW9uKQoJCXVwZGF0ZV9mbGFncyB8PSBSRUZfTk9fREVSRUY7CgllbHNlCgkJZGllKCJvcHRpb24gdW5rbm93bjogJXMiLCBuZXh0KTsKfQoKc3RhdGljIHZvaWQgcGFyc2VfY21kX3N0YXJ0KHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyYW5zYWN0aW9uIFVOVVNFRCwKCQkJICAgIGNvbnN0IGNoYXIgKm5leHQsIGNvbnN0IGNoYXIgKmVuZCBVTlVTRUQpCnsKCWlmICgqbmV4dCAhPSBsaW5lX3Rlcm1pbmF0aW9uKQoJCWRpZSgic3RhcnQ6IGV4dHJhIGlucHV0OiAlcyIsIG5leHQpOwoJcmVwb3J0X29rKCJzdGFydCIpOwp9CgpzdGF0aWMgdm9pZCBwYXJzZV9jbWRfcHJlcGFyZShzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0cmFuc2FjdGlvbiwKCQkJICAgICAgY29uc3QgY2hhciAqbmV4dCwgY29uc3QgY2hhciAqZW5kIFVOVVNFRCkKewoJc3RydWN0IHN0cmJ1ZiBlcnJvciA9IFNUUkJVRl9JTklUOwoJaWYgKCpuZXh0ICE9IGxpbmVfdGVybWluYXRpb24pCgkJZGllKCJwcmVwYXJlOiBleHRyYSBpbnB1dDogJXMiLCBuZXh0KTsKCWlmIChyZWZfdHJhbnNhY3Rpb25fcHJlcGFyZSh0cmFuc2FjdGlvbiwgJmVycm9yKSkKCQlkaWUoInByZXBhcmU6ICVzIiwgZXJyb3IuYnVmKTsKCXJlcG9ydF9vaygicHJlcGFyZSIpOwp9CgpzdGF0aWMgdm9pZCBwYXJzZV9jbWRfYWJvcnQoc3RydWN0IHJlZl90cmFuc2FjdGlvbiAqdHJhbnNhY3Rpb24sCgkJCSAgICBjb25zdCBjaGFyICpuZXh0LCBjb25zdCBjaGFyICplbmQgVU5VU0VEKQp7CglzdHJ1Y3Qgc3RyYnVmIGVycm9yID0gU1RSQlVGX0lOSVQ7CglpZiAoKm5leHQgIT0gbGluZV90ZXJtaW5hdGlvbikKCQlkaWUoImFib3J0OiBleHRyYSBpbnB1dDogJXMiLCBuZXh0KTsKCWlmIChyZWZfdHJhbnNhY3Rpb25fYWJvcnQodHJhbnNhY3Rpb24sICZlcnJvcikpCgkJZGllKCJhYm9ydDogJXMiLCBlcnJvci5idWYpOwoJcmVwb3J0X29rKCJhYm9ydCIpOwp9CgpzdGF0aWMgdm9pZCBwcmludF9yZWplY3RlZF9yZWZzKGNvbnN0IGNoYXIgKnJlZm5hbWUsCgkJCQljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvbGRfb2lkLAoJCQkJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqbmV3X29pZCwKCQkJCWNvbnN0IGNoYXIgKm9sZF90YXJnZXQsCgkJCQljb25zdCBjaGFyICpuZXdfdGFyZ2V0LAoJCQkJZW51bSByZWZfdHJhbnNhY3Rpb25fZXJyb3IgZXJyLAoJCQkJY29uc3QgY2hhciAqZGV0YWlscyBVTlVTRUQsCgkJCQl2b2lkICpjYl9kYXRhIFVOVVNFRCkKewoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJY29uc3QgY2hhciAqcmVhc29uID0gcmVmX3RyYW5zYWN0aW9uX2Vycm9yX21zZyhlcnIpOwoKCXN0cmJ1Zl9hZGRmKCZzYiwgInJlamVjdGVkICVzICVzICVzICVzXG4iLCByZWZuYW1lLAoJCSAgICBuZXdfb2lkID8gb2lkX3RvX2hleChuZXdfb2lkKSA6IG5ld190YXJnZXQsCgkJICAgIG9sZF9vaWQgPyBvaWRfdG9faGV4KG9sZF9vaWQpIDogb2xkX3RhcmdldCwKCQkgICAgcmVhc29uKTsKCglmd3JpdGUoc2IuYnVmLCBzYi5sZW4sIDEsIHN0ZG91dCk7CglzdHJidWZfcmVsZWFzZSgmc2IpOwp9CgpzdGF0aWMgdm9pZCBwYXJzZV9jbWRfY29tbWl0KHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyYW5zYWN0aW9uLAoJCQkgICAgIGNvbnN0IGNoYXIgKm5leHQsIGNvbnN0IGNoYXIgKmVuZCBVTlVTRUQpCnsKCXN0cnVjdCBzdHJidWYgZXJyb3IgPSBTVFJCVUZfSU5JVDsKCWlmICgqbmV4dCAhPSBsaW5lX3Rlcm1pbmF0aW9uKQoJCWRpZSgiY29tbWl0OiBleHRyYSBpbnB1dDogJXMiLCBuZXh0KTsKCWlmIChyZWZfdHJhbnNhY3Rpb25fY29tbWl0KHRyYW5zYWN0aW9uLCAmZXJyb3IpKQoJCWRpZSgiY29tbWl0OiAlcyIsIGVycm9yLmJ1Zik7CgoJcmVmX3RyYW5zYWN0aW9uX2Zvcl9lYWNoX3JlamVjdGVkX3VwZGF0ZSh0cmFuc2FjdGlvbiwKCQkJCQkJIHByaW50X3JlamVjdGVkX3JlZnMsIE5VTEwpOwoKCXJlcG9ydF9vaygiY29tbWl0Iik7CglyZWZfdHJhbnNhY3Rpb25fZnJlZSh0cmFuc2FjdGlvbik7Cn0KCmVudW0gdXBkYXRlX3JlZnNfc3RhdGUgewoJLyogTm9uLXRyYW5zYWN0aW9uYWwgc3RhdGUgb3BlbiBmb3IgdXBkYXRlcy4gKi8KCVVQREFURV9SRUZTX09QRU4sCgkvKiBBIHRyYW5zYWN0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQuICovCglVUERBVEVfUkVGU19TVEFSVEVELAoJLyogUmVmZXJlbmNlcyBhcmUgbG9ja2VkIGFuZCByZWFkeSBmb3IgY29tbWl0ICovCglVUERBVEVfUkVGU19QUkVQQVJFRCwKCS8qIFRyYW5zYWN0aW9uIGhhcyBiZWVuIGNvbW1pdHRlZCBvciBjbG9zZWQuICovCglVUERBVEVfUkVGU19DTE9TRUQsCn07CgpzdGF0aWMgY29uc3Qgc3RydWN0IHBhcnNlX2NtZCB7Cgljb25zdCBjaGFyICpwcmVmaXg7Cgl2b2lkICgqZm4pKHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKiwgY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICopOwoJdW5zaWduZWQgYXJnczsKCWVudW0gdXBkYXRlX3JlZnNfc3RhdGUgc3RhdGU7Cn0gY29tbWFuZFtdID0gewoJeyAidXBkYXRlIiwgICAgICAgIHBhcnNlX2NtZF91cGRhdGUsICAgICAgICAzLCBVUERBVEVfUkVGU19PUEVOIH0sCgl7ICJjcmVhdGUiLCAgICAgICAgcGFyc2VfY21kX2NyZWF0ZSwgICAgICAgIDIsIFVQREFURV9SRUZTX09QRU4gfSwKCXsgImRlbGV0ZSIsICAgICAgICBwYXJzZV9jbWRfZGVsZXRlLCAgICAgICAgMiwgVVBEQVRFX1JFRlNfT1BFTiB9LAoJeyAidmVyaWZ5IiwgICAgICAgIHBhcnNlX2NtZF92ZXJpZnksICAgICAgICAyLCBVUERBVEVfUkVGU19PUEVOIH0sCgl7ICJzeW1yZWYtdXBkYXRlIiwgcGFyc2VfY21kX3N5bXJlZl91cGRhdGUsIDQsIFVQREFURV9SRUZTX09QRU4gfSwKCXsgInN5bXJlZi1jcmVhdGUiLCBwYXJzZV9jbWRfc3ltcmVmX2NyZWF0ZSwgMiwgVVBEQVRFX1JFRlNfT1BFTiB9LAoJeyAic3ltcmVmLWRlbGV0ZSIsIHBhcnNlX2NtZF9zeW1yZWZfZGVsZXRlLCAyLCBVUERBVEVfUkVGU19PUEVOIH0sCgl7ICJzeW1yZWYtdmVyaWZ5IiwgcGFyc2VfY21kX3N5bXJlZl92ZXJpZnksIDIsIFVQREFURV9SRUZTX09QRU4gfSwKCXsgIm9wdGlvbiIsICAgICAgICBwYXJzZV9jbWRfb3B0aW9uLCAgICAgICAgMSwgVVBEQVRFX1JFRlNfT1BFTiB9LAoJeyAic3RhcnQiLCAgICAgICAgIHBhcnNlX2NtZF9zdGFydCwgICAgICAgICAwLCBVUERBVEVfUkVGU19TVEFSVEVEIH0sCgl7ICJwcmVwYXJlIiwgICAgICAgcGFyc2VfY21kX3ByZXBhcmUsICAgICAgIDAsIFVQREFURV9SRUZTX1BSRVBBUkVEIH0sCgl7ICJhYm9ydCIsICAgICAgICAgcGFyc2VfY21kX2Fib3J0LCAgICAgICAgIDAsIFVQREFURV9SRUZTX0NMT1NFRCB9LAoJeyAiY29tbWl0IiwgICAgICAgIHBhcnNlX2NtZF9jb21taXQsICAgICAgICAwLCBVUERBVEVfUkVGU19DTE9TRUQgfSwKfTsKCnN0YXRpYyB2b2lkIHVwZGF0ZV9yZWZzX3N0ZGluKHVuc2lnbmVkIGludCBmbGFncykKewoJc3RydWN0IHN0cmJ1ZiBpbnB1dCA9IFNUUkJVRl9JTklULCBlcnIgPSBTVFJCVUZfSU5JVDsKCWVudW0gdXBkYXRlX3JlZnNfc3RhdGUgc3RhdGUgPSBVUERBVEVfUkVGU19PUEVOOwoJc3RydWN0IHJlZl90cmFuc2FjdGlvbiAqdHJhbnNhY3Rpb247CglpbnQgaSwgajsKCgl0cmFuc2FjdGlvbiA9IHJlZl9zdG9yZV90cmFuc2FjdGlvbl9iZWdpbihnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLAoJCQkJCQkgIGZsYWdzLCAmZXJyKTsKCWlmICghdHJhbnNhY3Rpb24pCgkJZGllKCIlcyIsIGVyci5idWYpOwoKCS8qIFJlYWQgZWFjaCBsaW5lIGRpc3BhdGNoIGl0cyBjb21tYW5kICovCgl3aGlsZSAoIXN0cmJ1Zl9nZXR3aG9sZWxpbmUoJmlucHV0LCBzdGRpbiwgbGluZV90ZXJtaW5hdGlvbikpIHsKCQljb25zdCBzdHJ1Y3QgcGFyc2VfY21kICpjbWQgPSBOVUxMOwoKCQlpZiAoKmlucHV0LmJ1ZiA9PSBsaW5lX3Rlcm1pbmF0aW9uKQoJCQlkaWUoImVtcHR5IGNvbW1hbmQgaW4gaW5wdXQiKTsKCQllbHNlIGlmIChpc3NwYWNlKCppbnB1dC5idWYpKQoJCQlkaWUoIndoaXRlc3BhY2UgYmVmb3JlIGNvbW1hbmQ6ICVzIiwgaW5wdXQuYnVmKTsKCgkJZm9yIChpID0gMDsgaSA8IEFSUkFZX1NJWkUoY29tbWFuZCk7IGkrKykgewoJCQljb25zdCBjaGFyICpwcmVmaXggPSBjb21tYW5kW2ldLnByZWZpeDsKCQkJY2hhciBjOwoKCQkJaWYgKCFzdGFydHNfd2l0aChpbnB1dC5idWYsIHByZWZpeCkpCgkJCQljb250aW51ZTsKCgkJCS8qCgkJCSAqIElmIHRoZSBjb21tYW5kIGhhcyBhcmd1bWVudHMsIHZlcmlmeSB0aGF0IGl0J3MKCQkJICogZm9sbG93ZWQgYnkgYSBzcGFjZS4gT3RoZXJ3aXNlLCBpdCBzaGFsbCBiZSBmb2xsb3dlZAoJCQkgKiBieSBhIGxpbmUgdGVybWluYXRvci4KCQkJICovCgkJCWMgPSBjb21tYW5kW2ldLmFyZ3MgPyAnICcgOiBsaW5lX3Rlcm1pbmF0aW9uOwoJCQlpZiAoaW5wdXQuYnVmW3N0cmxlbihwcmVmaXgpXSAhPSBjKQoJCQkJY29udGludWU7CgoJCQljbWQgPSAmY29tbWFuZFtpXTsKCQkJYnJlYWs7CgkJfQoJCWlmICghY21kKQoJCQlkaWUoInVua25vd24gY29tbWFuZDogJXMiLCBpbnB1dC5idWYpOwoKCQkvKgoJCSAqIFJlYWQgYWRkaXRpb25hbCBhcmd1bWVudHMgaWYgTlVMLXRlcm1pbmF0ZWQuIERvIG5vdCByYWlzZSBhbgoJCSAqIGVycm9yIGluIGNhc2UgdGhlcmUgaXMgYW4gZWFybHkgRU9GIHRvIGxldCB0aGUgY29tbWFuZAoJCSAqIGhhbmRsZSBtaXNzaW5nIGFyZ3VtZW50cyB3aXRoIGEgcHJvcGVyIGVycm9yIG1lc3NhZ2UuCgkJICovCgkJZm9yIChqID0gMTsgbGluZV90ZXJtaW5hdGlvbiA9PSAnXDAnICYmIGogPCBjbWQtPmFyZ3M7IGorKykKCQkJaWYgKHN0cmJ1Zl9hcHBlbmR3aG9sZWxpbmUoJmlucHV0LCBzdGRpbiwgbGluZV90ZXJtaW5hdGlvbikpCgkJCQlicmVhazsKCgkJc3dpdGNoIChzdGF0ZSkgewoJCWNhc2UgVVBEQVRFX1JFRlNfT1BFTjoKCQljYXNlIFVQREFURV9SRUZTX1NUQVJURUQ6CgkJCWlmIChzdGF0ZSA9PSBVUERBVEVfUkVGU19TVEFSVEVEICYmIGNtZC0+c3RhdGUgPT0gVVBEQVRFX1JFRlNfU1RBUlRFRCkKCQkJCWRpZSgiY2Fubm90IHJlc3RhcnQgb25nb2luZyB0cmFuc2FjdGlvbiIpOwoJCQkvKiBEbyBub3QgZG93bmdyYWRlIGEgdHJhbnNhY3Rpb24gdG8gYSBub24tdHJhbnNhY3Rpb24uICovCgkJCWlmIChjbWQtPnN0YXRlID49IHN0YXRlKQoJCQkJc3RhdGUgPSBjbWQtPnN0YXRlOwoJCQlicmVhazsKCQljYXNlIFVQREFURV9SRUZTX1BSRVBBUkVEOgoJCQlpZiAoY21kLT5zdGF0ZSAhPSBVUERBVEVfUkVGU19DTE9TRUQpCgkJCQlkaWUoInByZXBhcmVkIHRyYW5zYWN0aW9ucyBjYW4gb25seSBiZSBjbG9zZWQiKTsKCQkJc3RhdGUgPSBjbWQtPnN0YXRlOwoJCQlicmVhazsKCQljYXNlIFVQREFURV9SRUZTX0NMT1NFRDoKCQkJaWYgKGNtZC0+c3RhdGUgIT0gVVBEQVRFX1JFRlNfU1RBUlRFRCkKCQkJCWRpZSgidHJhbnNhY3Rpb24gaXMgY2xvc2VkIik7CgoJCQkvKgoJCQkgKiBPcGVuIGEgbmV3IHRyYW5zYWN0aW9uIGlmIHdlJ3JlIGN1cnJlbnRseSBjbG9zZWQgYW5kCgkJCSAqIGdldCBhICJzdGFydCIuCgkJCSAqLwoJCQlzdGF0ZSA9IGNtZC0+c3RhdGU7CgkJCXRyYW5zYWN0aW9uID0gcmVmX3N0b3JlX3RyYW5zYWN0aW9uX2JlZ2luKGdldF9tYWluX3JlZl9zdG9yZSh0aGVfcmVwb3NpdG9yeSksCgkJCQkJCQkJICBmbGFncywgJmVycik7CgkJCWlmICghdHJhbnNhY3Rpb24pCgkJCQlkaWUoIiVzIiwgZXJyLmJ1Zik7CgoJCQlicmVhazsKCQl9CgoJCWNtZC0+Zm4odHJhbnNhY3Rpb24sIGlucHV0LmJ1ZiArIHN0cmxlbihjbWQtPnByZWZpeCkgKyAhIWNtZC0+YXJncywKCQkJaW5wdXQuYnVmICsgaW5wdXQubGVuKTsKCX0KCglzd2l0Y2ggKHN0YXRlKSB7CgljYXNlIFVQREFURV9SRUZTX09QRU46CgkJLyogQ29tbWl0IGJ5IGRlZmF1bHQgaWYgbm8gdHJhbnNhY3Rpb24gd2FzIHJlcXVlc3RlZC4gKi8KCQlpZiAocmVmX3RyYW5zYWN0aW9uX2NvbW1pdCh0cmFuc2FjdGlvbiwgJmVycikpCgkJCWRpZSgiJXMiLCBlcnIuYnVmKTsKCQlyZWZfdHJhbnNhY3Rpb25fZm9yX2VhY2hfcmVqZWN0ZWRfdXBkYXRlKHRyYW5zYWN0aW9uLAoJCQkJCQkgcHJpbnRfcmVqZWN0ZWRfcmVmcywgTlVMTCk7CgkJcmVmX3RyYW5zYWN0aW9uX2ZyZWUodHJhbnNhY3Rpb24pOwoJCWJyZWFrOwoJY2FzZSBVUERBVEVfUkVGU19TVEFSVEVEOgoJY2FzZSBVUERBVEVfUkVGU19QUkVQQVJFRDoKCQkvKiBJZiB1c2luZyBhIHRyYW5zYWN0aW9uLCB3ZSB3YW50IHRvIGFib3J0IGl0LiAqLwoJCWlmIChyZWZfdHJhbnNhY3Rpb25fYWJvcnQodHJhbnNhY3Rpb24sICZlcnIpKQoJCQlkaWUoIiVzIiwgZXJyLmJ1Zik7CgkJYnJlYWs7CgljYXNlIFVQREFURV9SRUZTX0NMT1NFRDoKCQkvKiBPdGhlcndpc2Ugbm8gbmVlZCB0byBkbyBhbnl0aGluZywgdGhlIHRyYW5zYWN0aW9uIHdhcyBjbG9zZWQgYWxyZWFkeS4gKi8KCQlicmVhazsKCX0KCglzdHJidWZfcmVsZWFzZSgmZXJyKTsKCXN0cmJ1Zl9yZWxlYXNlKCZpbnB1dCk7Cn0KCmludCBjbWRfdXBkYXRlX3JlZihpbnQgYXJnYywKCQkgICBjb25zdCBjaGFyICoqYXJndiwKCQkgICBjb25zdCBjaGFyICpwcmVmaXgsCgkJICAgc3RydWN0IHJlcG9zaXRvcnkgKnJlcG8gVU5VU0VEKQp7Cgljb25zdCBjaGFyICpyZWZuYW1lLCAqb2xkdmFsOwoJc3RydWN0IG9iamVjdF9pZCBvaWQsIG9sZG9pZDsKCWludCBkZWxldGUgPSAwLCBub19kZXJlZiA9IDAsIHJlYWRfc3RkaW4gPSAwLCBlbmRfbnVsbCA9IDA7CglpbnQgY3JlYXRlX3JlZmxvZyA9IDA7Cgl1bnNpZ25lZCBpbnQgZmxhZ3MgPSAwOwoKCXN0cnVjdCBvcHRpb24gb3B0aW9uc1tdID0gewoJCU9QVF9TVFJJTkcoICdtJywgTlVMTCwgJm1zZywgTl8oInJlYXNvbiIpLCBOXygicmVhc29uIG9mIHRoZSB1cGRhdGUiKSksCgkJT1BUX0JPT0woJ2QnLCBOVUxMLCAmZGVsZXRlLCBOXygiZGVsZXRlIHRoZSByZWZlcmVuY2UiKSksCgkJT1BUX0JPT0woIDAgLCAibm8tZGVyZWYiLCAmbm9fZGVyZWYsCgkJCQkJTl8oInVwZGF0ZSA8cmVmbmFtZT4gbm90IHRoZSBvbmUgaXQgcG9pbnRzIHRvIikpLAoJCU9QVF9CT09MKCd6JywgTlVMTCwgJmVuZF9udWxsLCBOXygic3RkaW4gaGFzIE5VTC10ZXJtaW5hdGVkIGFyZ3VtZW50cyIpKSwKCQlPUFRfQk9PTCggMCAsICJzdGRpbiIsICZyZWFkX3N0ZGluLCBOXygicmVhZCB1cGRhdGVzIGZyb20gc3RkaW4iKSksCgkJT1BUX0JPT0woIDAgLCAiY3JlYXRlLXJlZmxvZyIsICZjcmVhdGVfcmVmbG9nLCBOXygiY3JlYXRlIGEgcmVmbG9nIikpLAoJCU9QVF9CSVQoJzAnLCAiYmF0Y2gtdXBkYXRlcyIsICZmbGFncywgTl8oImJhdGNoIHJlZmVyZW5jZSB1cGRhdGVzIiksCgkJCVJFRl9UUkFOU0FDVElPTl9BTExPV19GQUlMVVJFKSwKCQlPUFRfRU5EKCksCgl9OwoKCXJlcG9fY29uZmlnKHRoZV9yZXBvc2l0b3J5LCBnaXRfZGVmYXVsdF9jb25maWcsIE5VTEwpOwoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBvcHRpb25zLCBnaXRfdXBkYXRlX3JlZl91c2FnZSwKCQkJICAgICAwKTsKCWlmIChtc2cgJiYgISptc2cpCgkJZGllKCJSZWZ1c2luZyB0byBwZXJmb3JtIHVwZGF0ZSB3aXRoIGVtcHR5IG1lc3NhZ2UuIik7CgoJY3JlYXRlX3JlZmxvZ19mbGFnID0gY3JlYXRlX3JlZmxvZyA/IFJFRl9GT1JDRV9DUkVBVEVfUkVGTE9HIDogMDsKCglpZiAobm9fZGVyZWYpIHsKCQlkZWZhdWx0X2ZsYWdzID0gUkVGX05PX0RFUkVGOwoJCXVwZGF0ZV9mbGFncyA9IGRlZmF1bHRfZmxhZ3M7Cgl9CgoJaWYgKHJlYWRfc3RkaW4pIHsKCQlpZiAoZGVsZXRlIHx8IGFyZ2MgPiAwKQoJCQl1c2FnZV93aXRoX29wdGlvbnMoZ2l0X3VwZGF0ZV9yZWZfdXNhZ2UsIG9wdGlvbnMpOwoJCWlmIChlbmRfbnVsbCkKCQkJbGluZV90ZXJtaW5hdGlvbiA9ICdcMCc7CgkJdXBkYXRlX3JlZnNfc3RkaW4oZmxhZ3MpOwoJCXJldHVybiAwOwoJfSBlbHNlIGlmIChmbGFncyAmIFJFRl9UUkFOU0FDVElPTl9BTExPV19GQUlMVVJFKSB7CgkJZGllKCItLWJhdGNoLXVwZGF0ZXMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIC0tc3RkaW4iKTsKCX0KCglpZiAoZW5kX251bGwpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGdpdF91cGRhdGVfcmVmX3VzYWdlLCBvcHRpb25zKTsKCglpZiAoZGVsZXRlKSB7CgkJaWYgKGFyZ2MgPCAxIHx8IGFyZ2MgPiAyKQoJCQl1c2FnZV93aXRoX29wdGlvbnMoZ2l0X3VwZGF0ZV9yZWZfdXNhZ2UsIG9wdGlvbnMpOwoJCXJlZm5hbWUgPSBhcmd2WzBdOwoJCW9sZHZhbCA9IGFyZ3ZbMV07Cgl9IGVsc2UgewoJCWNvbnN0IGNoYXIgKnZhbHVlOwoJCWlmIChhcmdjIDwgMiB8fCBhcmdjID4gMykKCQkJdXNhZ2Vfd2l0aF9vcHRpb25zKGdpdF91cGRhdGVfcmVmX3VzYWdlLCBvcHRpb25zKTsKCQlyZWZuYW1lID0gYXJndlswXTsKCQl2YWx1ZSA9IGFyZ3ZbMV07CgkJb2xkdmFsID0gYXJndlsyXTsKCQlpZiAocmVwb19nZXRfb2lkX3dpdGhfZmxhZ3ModGhlX3JlcG9zaXRvcnksIHZhbHVlLCAmb2lkLAoJCQkJCSAgICBHRVRfT0lEX1NLSVBfQU1CSUdVSVRZX0NIRUNLKSkKCQkJZGllKCIlczogbm90IGEgdmFsaWQgU0hBMSIsIHZhbHVlKTsKCX0KCglpZiAob2xkdmFsKSB7CgkJaWYgKCEqb2xkdmFsKQoJCQkvKgoJCQkgKiBUaGUgZW1wdHkgc3RyaW5nIGltcGxpZXMgdGhhdCB0aGUgcmVmZXJlbmNlCgkJCSAqIG11c3Qgbm90IGFscmVhZHkgZXhpc3Q6CgkJCSAqLwoJCQlvaWRjbHIoJm9sZG9pZCwgdGhlX3JlcG9zaXRvcnktPmhhc2hfYWxnbyk7CgkJZWxzZSBpZiAocmVwb19nZXRfb2lkX3dpdGhfZmxhZ3ModGhlX3JlcG9zaXRvcnksIG9sZHZhbCwgJm9sZG9pZCwKCQkJCQkJIEdFVF9PSURfU0tJUF9BTUJJR1VJVFlfQ0hFQ0spKQoJCQlkaWUoIiVzOiBub3QgYSB2YWxpZCBvbGQgU0hBMSIsIG9sZHZhbCk7Cgl9CgoJaWYgKGRlbGV0ZSkKCQkvKgoJCSAqIEZvciBwdXJwb3NlcyBvZiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgd2UgdHJlYXQKCQkgKiBOVUxMX1NIQTEgYXMgImRvbid0IGNhcmUiIGhlcmU6CgkJICovCgkJcmV0dXJuIHJlZnNfZGVsZXRlX3JlZihnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLAoJCQkJICAgICAgIG1zZywgcmVmbmFtZSwKCQkJCSAgICAgICAob2xkdmFsICYmICFpc19udWxsX29pZCgmb2xkb2lkKSkgPyAmb2xkb2lkIDogTlVMTCwKCQkJCSAgICAgICBkZWZhdWx0X2ZsYWdzKTsKCWVsc2UKCQlyZXR1cm4gcmVmc191cGRhdGVfcmVmKGdldF9tYWluX3JlZl9zdG9yZSh0aGVfcmVwb3NpdG9yeSksCgkJCQkgICAgICAgbXNnLCByZWZuYW1lLCAmb2lkLAoJCQkJICAgICAgIG9sZHZhbCA/ICZvbGRvaWQgOiBOVUxMLAoJCQkJICAgICAgIGRlZmF1bHRfZmxhZ3MgfCBjcmVhdGVfcmVmbG9nX2ZsYWcsCgkJCQkgICAgICAgVVBEQVRFX1JFRlNfRElFX09OX0VSUik7Cn0K",
    "text": "#define USE_THE_REPOSITORY_VARIABLE\n#define DISABLE_SIGN_COMPARE_WARNINGS\n\n#include \"builtin.h\"\n#include \"config.h\"\n#include \"environment.h\"\n#include \"gettext.h\"\n#include \"hash.h\"\n#include \"hex.h\"\n#include \"refs.h\"\n#include \"object-name.h\"\n#include \"parse-options.h\"\n#include \"quote.h\"\n\nstatic const char * const git_update_ref_usage[] = {\n\tN_(\"git update-ref [<options>] -d <refname> [<old-oid>]\"),\n\tN_(\"git update-ref [<options>]    <refname> <new-oid> [<old-oid>]\"),\n\tN_(\"git update-ref [<options>] --stdin [-z] [--batch-updates]\"),\n\tNULL\n};\n\nstatic char line_termination = '\\n';\nstatic unsigned int update_flags;\nstatic unsigned int default_flags;\nstatic unsigned create_reflog_flag;\nstatic const char *msg;\n\n/*\n * Parse one whitespace- or NUL-terminated, possibly C-quoted argument\n * and append the result to arg.  Return a pointer to the terminator.\n * Die if there is an error in how the argument is C-quoted.  This\n * function is only used if not -z.\n */\nstatic const char *parse_arg(const char *next, struct strbuf *arg)\n{\n\tif (*next == '\"') {\n\t\tconst char *orig = next;\n\n\t\tif (unquote_c_style(arg, next, &next))\n\t\t\tdie(\"badly quoted argument: %s\", orig);\n\t\tif (*next && !isspace(*next))\n\t\t\tdie(\"unexpected character after quoted argument: %s\", orig);\n\t} else {\n\t\twhile (*next && !isspace(*next))\n\t\t\tstrbuf_addch(arg, *next++);\n\t}\n\n\treturn next;\n}\n\n/*\n * Parse the reference name immediately after \"command SP\".  If not\n * -z, then handle C-quoting.  Return a pointer to a newly allocated\n * string containing the name of the reference, or NULL if there was\n * an error.  Update *next to point at the character that terminates\n * the argument.  Die if C-quoting is malformed or the reference name\n * is invalid.\n */\nstatic char *parse_refname(const char **next)\n{\n\tstruct strbuf ref = STRBUF_INIT;\n\n\tif (line_termination) {\n\t\t/* Without -z, use the next argument */\n\t\t*next = parse_arg(*next, &ref);\n\t} else {\n\t\t/* With -z, use everything up to the next NUL */\n\t\tstrbuf_addstr(&ref, *next);\n\t\t*next += ref.len;\n\t}\n\n\tif (!ref.len) {\n\t\tstrbuf_release(&ref);\n\t\treturn NULL;\n\t}\n\n\tif (check_refname_format(ref.buf, REFNAME_ALLOW_ONELEVEL))\n\t\tdie(\"invalid ref format: %s\", ref.buf);\n\n\treturn strbuf_detach(&ref, NULL);\n}\n\n/*\n * Wrapper around parse_refname which skips the next delimiter.\n */\nstatic char *parse_next_refname(const char **next)\n{\n\tif (line_termination) {\n\t\t/* Without -z, consume SP and use next argument */\n\t\tif (!**next || **next == line_termination)\n\t\t\treturn NULL;\n\t\tif (**next != ' ')\n\t\t\tdie(\"expected SP but got: %s\", *next);\n\t} else {\n\t\t/* With -z, read the next NUL-terminated line */\n\t\tif (**next)\n\t\t\treturn NULL;\n\t}\n\t/* Skip the delimiter */\n\t(*next)++;\n\n\treturn parse_refname(next);\n}\n\n/*\n * Wrapper around parse_arg which skips the next delimiter.\n */\nstatic char *parse_next_arg(const char **next)\n{\n\tstruct strbuf arg = STRBUF_INIT;\n\n\tif (line_termination) {\n\t\t/* Without -z, consume SP and use next argument */\n\t\tif (!**next || **next == line_termination)\n\t\t\treturn NULL;\n\t\tif (**next != ' ')\n\t\t\tdie(\"expected SP but got: %s\", *next);\n\t} else {\n\t\t/* With -z, read the next NUL-terminated line */\n\t\tif (**next)\n\t\t\treturn NULL;\n\t}\n\t/* Skip the delimiter */\n\t(*next)++;\n\n\tif (line_termination) {\n\t\t/* Without -z, use the next argument */\n\t\t*next = parse_arg(*next, &arg);\n\t} else {\n\t\t/* With -z, use everything up to the next NUL */\n\t\tstrbuf_addstr(&arg, *next);\n\t\t*next += arg.len;\n\t}\n\n\tif (arg.len)\n\t\treturn strbuf_detach(&arg, NULL);\n\n\tstrbuf_release(&arg);\n\treturn NULL;\n}\n\n/*\n * The value being parsed is <old-oid> (as opposed to <new-oid>; the\n * difference affects which error messages are generated):\n */\n#define PARSE_SHA1_OLD 0x01\n\n/*\n * For backwards compatibility, accept an empty string for update's\n * <new-oid> in binary mode to be equivalent to specifying zeros.\n */\n#define PARSE_SHA1_ALLOW_EMPTY 0x02\n\n/*\n * Parse an argument separator followed by the next argument, if any.\n * If there is an argument, convert it to a SHA-1, write it to sha1,\n * set *next to point at the character terminating the argument, and\n * return 0.  If there is no argument at all (not even the empty\n * string), return 1 and leave *next unchanged.  If the value is\n * provided but cannot be converted to a SHA-1, die.  flags can\n * include PARSE_SHA1_OLD and/or PARSE_SHA1_ALLOW_EMPTY.\n */\nstatic int parse_next_oid(const char **next, const char *end,\n\t\t\t  struct object_id *oid,\n\t\t\t  const char *command, const char *refname,\n\t\t\t  int flags)\n{\n\tstruct strbuf arg = STRBUF_INIT;\n\tint ret = 0;\n\n\tif (*next == end)\n\t\tgoto eof;\n\n\tif (line_termination) {\n\t\t/* Without -z, consume SP and use next argument */\n\t\tif (!**next || **next == line_termination)\n\t\t\treturn 1;\n\t\tif (**next != ' ')\n\t\t\tdie(\"%s %s: expected SP but got: %s\",\n\t\t\t    command, refname, *next);\n\t\t(*next)++;\n\t\t*next = parse_arg(*next, &arg);\n\t\tif (arg.len) {\n\t\t\tif (repo_get_oid_with_flags(the_repository, arg.buf, oid,\n\t\t\t\t\t\t    GET_OID_SKIP_AMBIGUITY_CHECK))\n\t\t\t\tgoto invalid;\n\t\t} else {\n\t\t\t/* Without -z, an empty value means all zeros: */\n\t\t\toidclr(oid, the_repository->hash_algo);\n\t\t}\n\t} else {\n\t\t/* With -z, read the next NUL-terminated line */\n\t\tif (**next)\n\t\t\tdie(\"%s %s: expected NUL but got: %s\",\n\t\t\t    command, refname, *next);\n\t\t(*next)++;\n\t\tif (*next == end)\n\t\t\tgoto eof;\n\t\tstrbuf_addstr(&arg, *next);\n\t\t*next += arg.len;\n\n\t\tif (arg.len) {\n\t\t\tif (repo_get_oid_with_flags(the_repository, arg.buf, oid,\n\t\t\t\t\t\t    GET_OID_SKIP_AMBIGUITY_CHECK))\n\t\t\t\tgoto invalid;\n\t\t} else if (flags & PARSE_SHA1_ALLOW_EMPTY) {\n\t\t\t/* With -z, treat an empty value as all zeros: */\n\t\t\twarning(\"%s %s: missing <new-oid>, treating as zero\",\n\t\t\t\tcommand, refname);\n\t\t\toidclr(oid, the_repository->hash_algo);\n\t\t} else {\n\t\t\t/*\n\t\t\t * With -z, an empty non-required value means\n\t\t\t * unspecified:\n\t\t\t */\n\t\t\tret = 1;\n\t\t}\n\t}\n\n\tstrbuf_release(&arg);\n\n\treturn ret;\n\n invalid:\n\tdie(flags & PARSE_SHA1_OLD ?\n\t    \"%s %s: invalid <old-oid>: %s\" :\n\t    \"%s %s: invalid <new-oid>: %s\",\n\t    command, refname, arg.buf);\n\n eof:\n\tdie(flags & PARSE_SHA1_OLD ?\n\t    \"%s %s: unexpected end of input when reading <old-oid>\" :\n\t    \"%s %s: unexpected end of input when reading <new-oid>\",\n\t    command, refname);\n}\n\n\n/*\n * The following five parse_cmd_*() functions parse the corresponding\n * command.  In each case, next points at the character following the\n * command name and the following space.  They each return a pointer\n * to the character terminating the command, and die with an\n * explanatory message if there are any parsing problems.  All of\n * these functions handle either text or binary format input,\n * depending on how line_termination is set.\n */\n\nstatic void parse_cmd_update(struct ref_transaction *transaction,\n\t\t\t     const char *next, const char *end)\n{\n\tstruct strbuf err = STRBUF_INIT;\n\tchar *refname;\n\tstruct object_id new_oid, old_oid;\n\tint have_old;\n\n\trefname = parse_refname(&next);\n\tif (!refname)\n\t\tdie(\"update: missing <ref>\");\n\n\tif (parse_next_oid(&next, end, &new_oid, \"update\", refname,\n\t\t\t   PARSE_SHA1_ALLOW_EMPTY))\n\t\tdie(\"update %s: missing <new-oid>\", refname);\n\n\thave_old = !parse_next_oid(&next, end, &old_oid, \"update\", refname,\n\t\t\t\t   PARSE_SHA1_OLD);\n\n\tif (*next != line_termination)\n\t\tdie(\"update %s: extra input: %s\", refname, next);\n\n\tif (ref_transaction_update(transaction, refname,\n\t\t\t\t   &new_oid, have_old ? &old_oid : NULL,\n\t\t\t\t   NULL, NULL,\n\t\t\t\t   update_flags | create_reflog_flag,\n\t\t\t\t   msg, &err))\n\t\tdie(\"%s\", err.buf);\n\n\tupdate_flags = default_flags;\n\tfree(refname);\n\tstrbuf_release(&err);\n}\n\nstatic void parse_cmd_symref_update(struct ref_transaction *transaction,\n\t\t\t\t    const char *next, const char *end UNUSED)\n{\n\tchar *refname, *new_target, *old_arg;\n\tchar *old_target = NULL;\n\tstruct strbuf err = STRBUF_INIT;\n\tstruct object_id old_oid;\n\tint have_old_oid = 0;\n\n\trefname = parse_refname(&next);\n\tif (!refname)\n\t\tdie(\"symref-update: missing <ref>\");\n\n\tnew_target = parse_next_refname(&next);\n\tif (!new_target)\n\t\tdie(\"symref-update %s: missing <new-target>\", refname);\n\n\told_arg = parse_next_arg(&next);\n\tif (old_arg) {\n\t\told_target = parse_next_arg(&next);\n\t\tif (!old_target)\n\t\t\tdie(\"symref-update %s: expected old value\", refname);\n\n\t\tif (!strcmp(old_arg, \"oid\")) {\n\t\t\tif (repo_get_oid_with_flags(the_repository, old_target, &old_oid,\n\t\t\t\t\t\t    GET_OID_SKIP_AMBIGUITY_CHECK))\n\t\t\t\tdie(\"symref-update %s: invalid oid: %s\", refname, old_target);\n\n\t\t\thave_old_oid = 1;\n\t\t} else if (!strcmp(old_arg, \"ref\")) {\n\t\t\tif (check_refname_format(old_target, REFNAME_ALLOW_ONELEVEL))\n\t\t\t\tdie(\"symref-update %s: invalid ref: %s\", refname, old_target);\n\t\t} else {\n\t\t\tdie(\"symref-update %s: invalid arg '%s' for old value\", refname, old_arg);\n\t\t}\n\t}\n\n\tif (*next != line_termination)\n\t\tdie(\"symref-update %s: extra input: %s\", refname, next);\n\n\tif (ref_transaction_update(transaction, refname, NULL,\n\t\t\t\t   have_old_oid ? &old_oid : NULL,\n\t\t\t\t   new_target,\n\t\t\t\t   have_old_oid ? NULL : old_target,\n\t\t\t\t   update_flags | create_reflog_flag,\n\t\t\t\t   msg, &err))\n\t\tdie(\"%s\", err.buf);\n\n\tupdate_flags = default_flags;\n\tfree(refname);\n\tfree(old_arg);\n\tfree(old_target);\n\tfree(new_target);\n\tstrbuf_release(&err);\n}\n\nstatic void parse_cmd_create(struct ref_transaction *transaction,\n\t\t\t     const char *next, const char *end)\n{\n\tstruct strbuf err = STRBUF_INIT;\n\tchar *refname;\n\tstruct object_id new_oid;\n\n\trefname = parse_refname(&next);\n\tif (!refname)\n\t\tdie(\"create: missing <ref>\");\n\n\tif (parse_next_oid(&next, end, &new_oid, \"create\", refname, 0))\n\t\tdie(\"create %s: missing <new-oid>\", refname);\n\n\tif (is_null_oid(&new_oid))\n\t\tdie(\"create %s: zero <new-oid>\", refname);\n\n\tif (*next != line_termination)\n\t\tdie(\"create %s: extra input: %s\", refname, next);\n\n\tif (ref_transaction_create(transaction, refname, &new_oid, NULL,\n\t\t\t\t   update_flags | create_reflog_flag,\n\t\t\t\t   msg, &err))\n\t\tdie(\"%s\", err.buf);\n\n\tupdate_flags = default_flags;\n\tfree(refname);\n\tstrbuf_release(&err);\n}\n\n\nstatic void parse_cmd_symref_create(struct ref_transaction *transaction,\n\t\t\t\t    const char *next, const char *end UNUSED)\n{\n\tstruct strbuf err = STRBUF_INIT;\n\tchar *refname, *new_target;\n\n\trefname = parse_refname(&next);\n\tif (!refname)\n\t\tdie(\"symref-create: missing <ref>\");\n\n\tnew_target = parse_next_refname(&next);\n\tif (!new_target)\n\t\tdie(\"symref-create %s: missing <new-target>\", refname);\n\n\tif (*next != line_termination)\n\t\tdie(\"symref-create %s: extra input: %s\", refname, next);\n\n\tif (ref_transaction_create(transaction, refname, NULL, new_target,\n\t\t\t\t   update_flags | create_reflog_flag,\n\t\t\t\t   msg, &err))\n\t\tdie(\"%s\", err.buf);\n\n\tupdate_flags = default_flags;\n\tfree(refname);\n\tfree(new_target);\n\tstrbuf_release(&err);\n}\n\nstatic void parse_cmd_delete(struct ref_transaction *transaction,\n\t\t\t     const char *next, const char *end)\n{\n\tstruct strbuf err = STRBUF_INIT;\n\tchar *refname;\n\tstruct object_id old_oid;\n\tint have_old;\n\n\trefname = parse_refname(&next);\n\tif (!refname)\n\t\tdie(\"delete: missing <ref>\");\n\n\tif (parse_next_oid(&next, end, &old_oid, \"delete\", refname,\n\t\t\t   PARSE_SHA1_OLD)) {\n\t\thave_old = 0;\n\t} else {\n\t\tif (is_null_oid(&old_oid))\n\t\t\tdie(\"delete %s: zero <old-oid>\", refname);\n\t\thave_old = 1;\n\t}\n\n\tif (*next != line_termination)\n\t\tdie(\"delete %s: extra input: %s\", refname, next);\n\n\tif (ref_transaction_delete(transaction, refname,\n\t\t\t\t   have_old ? &old_oid : NULL,\n\t\t\t\t   NULL, update_flags, msg, &err))\n\t\tdie(\"%s\", err.buf);\n\n\tupdate_flags = default_flags;\n\tfree(refname);\n\tstrbuf_release(&err);\n}\n\n\nstatic void parse_cmd_symref_delete(struct ref_transaction *transaction,\n\t\t\t\t    const char *next, const char *end UNUSED)\n{\n\tstruct strbuf err = STRBUF_INIT;\n\tchar *refname, *old_target;\n\n\tif (!(update_flags & REF_NO_DEREF))\n\t\tdie(\"symref-delete: cannot operate with deref mode\");\n\n\trefname = parse_refname(&next);\n\tif (!refname)\n\t\tdie(\"symref-delete: missing <ref>\");\n\n\told_target = parse_next_refname(&next);\n\n\tif (*next != line_termination)\n\t\tdie(\"symref-delete %s: extra input: %s\", refname, next);\n\n\tif (ref_transaction_delete(transaction, refname, NULL,\n\t\t\t\t   old_target, update_flags, msg, &err))\n\t\tdie(\"%s\", err.buf);\n\n\tupdate_flags = default_flags;\n\tfree(refname);\n\tfree(old_target);\n\tstrbuf_release(&err);\n}\n\n\nstatic void parse_cmd_verify(struct ref_transaction *transaction,\n\t\t\t     const char *next, const char *end)\n{\n\tstruct strbuf err = STRBUF_INIT;\n\tchar *refname;\n\tstruct object_id old_oid;\n\n\trefname = parse_refname(&next);\n\tif (!refname)\n\t\tdie(\"verify: missing <ref>\");\n\n\tif (parse_next_oid(&next, end, &old_oid, \"verify\", refname,\n\t\t\t   PARSE_SHA1_OLD))\n\t\toidclr(&old_oid, the_repository->hash_algo);\n\n\tif (*next != line_termination)\n\t\tdie(\"verify %s: extra input: %s\", refname, next);\n\n\tif (ref_transaction_verify(transaction, refname, &old_oid,\n\t\t\t\t   NULL, update_flags, &err))\n\t\tdie(\"%s\", err.buf);\n\n\tupdate_flags = default_flags;\n\tfree(refname);\n\tstrbuf_release(&err);\n}\n\nstatic void parse_cmd_symref_verify(struct ref_transaction *transaction,\n\t\t\t\t    const char *next, const char *end UNUSED)\n{\n\tstruct strbuf err = STRBUF_INIT;\n\tstruct object_id old_oid;\n\tchar *refname, *old_target;\n\n\tif (!(update_flags & REF_NO_DEREF))\n\t\tdie(\"symref-verify: cannot operate with deref mode\");\n\n\trefname = parse_refname(&next);\n\tif (!refname)\n\t\tdie(\"symref-verify: missing <ref>\");\n\n\t/*\n\t * old_ref is optional, if not provided, we need to ensure that the\n\t * ref doesn't exist.\n\t */\n\told_target = parse_next_refname(&next);\n\tif (!old_target)\n\t\toidcpy(&old_oid, null_oid(the_hash_algo));\n\n\tif (*next != line_termination)\n\t\tdie(\"symref-verify %s: extra input: %s\", refname, next);\n\n\tif (ref_transaction_verify(transaction, refname,\n\t\t\t\t   old_target ? NULL : &old_oid,\n\t\t\t\t   old_target, update_flags, &err))\n\t\tdie(\"%s\", err.buf);\n\n\tupdate_flags = default_flags;\n\tfree(refname);\n\tfree(old_target);\n\tstrbuf_release(&err);\n}\n\nstatic void report_ok(const char *command)\n{\n\tfprintf(stdout, \"%s: ok\\n\", command);\n\tfflush(stdout);\n}\n\nstatic void parse_cmd_option(struct ref_transaction *transaction UNUSED,\n\t\t\t     const char *next, const char *end UNUSED)\n{\n\tconst char *rest;\n\tif (skip_prefix(next, \"no-deref\", &rest) && *rest == line_termination)\n\t\tupdate_flags |= REF_NO_DEREF;\n\telse\n\t\tdie(\"option unknown: %s\", next);\n}\n\nstatic void parse_cmd_start(struct ref_transaction *transaction UNUSED,\n\t\t\t    const char *next, const char *end UNUSED)\n{\n\tif (*next != line_termination)\n\t\tdie(\"start: extra input: %s\", next);\n\treport_ok(\"start\");\n}\n\nstatic void parse_cmd_prepare(struct ref_transaction *transaction,\n\t\t\t      const char *next, const char *end UNUSED)\n{\n\tstruct strbuf error = STRBUF_INIT;\n\tif (*next != line_termination)\n\t\tdie(\"prepare: extra input: %s\", next);\n\tif (ref_transaction_prepare(transaction, &error))\n\t\tdie(\"prepare: %s\", error.buf);\n\treport_ok(\"prepare\");\n}\n\nstatic void parse_cmd_abort(struct ref_transaction *transaction,\n\t\t\t    const char *next, const char *end UNUSED)\n{\n\tstruct strbuf error = STRBUF_INIT;\n\tif (*next != line_termination)\n\t\tdie(\"abort: extra input: %s\", next);\n\tif (ref_transaction_abort(transaction, &error))\n\t\tdie(\"abort: %s\", error.buf);\n\treport_ok(\"abort\");\n}\n\nstatic void print_rejected_refs(const char *refname,\n\t\t\t\tconst struct object_id *old_oid,\n\t\t\t\tconst struct object_id *new_oid,\n\t\t\t\tconst char *old_target,\n\t\t\t\tconst char *new_target,\n\t\t\t\tenum ref_transaction_error err,\n\t\t\t\tconst char *details UNUSED,\n\t\t\t\tvoid *cb_data UNUSED)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *reason = ref_transaction_error_msg(err);\n\n\tstrbuf_addf(&sb, \"rejected %s %s %s %s\\n\", refname,\n\t\t    new_oid ? oid_to_hex(new_oid) : new_target,\n\t\t    old_oid ? oid_to_hex(old_oid) : old_target,\n\t\t    reason);\n\n\tfwrite(sb.buf, sb.len, 1, stdout);\n\tstrbuf_release(&sb);\n}\n\nstatic void parse_cmd_commit(struct ref_transaction *transaction,\n\t\t\t     const char *next, const char *end UNUSED)\n{\n\tstruct strbuf error = STRBUF_INIT;\n\tif (*next != line_termination)\n\t\tdie(\"commit: extra input: %s\", next);\n\tif (ref_transaction_commit(transaction, &error))\n\t\tdie(\"commit: %s\", error.buf);\n\n\tref_transaction_for_each_rejected_update(transaction,\n\t\t\t\t\t\t print_rejected_refs, NULL);\n\n\treport_ok(\"commit\");\n\tref_transaction_free(transaction);\n}\n\nenum update_refs_state {\n\t/* Non-transactional state open for updates. */\n\tUPDATE_REFS_OPEN,\n\t/* A transaction has been started. */\n\tUPDATE_REFS_STARTED,\n\t/* References are locked and ready for commit */\n\tUPDATE_REFS_PREPARED,\n\t/* Transaction has been committed or closed. */\n\tUPDATE_REFS_CLOSED,\n};\n\nstatic const struct parse_cmd {\n\tconst char *prefix;\n\tvoid (*fn)(struct ref_transaction *, const char *, const char *);\n\tunsigned args;\n\tenum update_refs_state state;\n} command[] = {\n\t{ \"update\",        parse_cmd_update,        3, UPDATE_REFS_OPEN },\n\t{ \"create\",        parse_cmd_create,        2, UPDATE_REFS_OPEN },\n\t{ \"delete\",        parse_cmd_delete,        2, UPDATE_REFS_OPEN },\n\t{ \"verify\",        parse_cmd_verify,        2, UPDATE_REFS_OPEN },\n\t{ \"symref-update\", parse_cmd_symref_update, 4, UPDATE_REFS_OPEN },\n\t{ \"symref-create\", parse_cmd_symref_create, 2, UPDATE_REFS_OPEN },\n\t{ \"symref-delete\", parse_cmd_symref_delete, 2, UPDATE_REFS_OPEN },\n\t{ \"symref-verify\", parse_cmd_symref_verify, 2, UPDATE_REFS_OPEN },\n\t{ \"option\",        parse_cmd_option,        1, UPDATE_REFS_OPEN },\n\t{ \"start\",         parse_cmd_start,         0, UPDATE_REFS_STARTED },\n\t{ \"prepare\",       parse_cmd_prepare,       0, UPDATE_REFS_PREPARED },\n\t{ \"abort\",         parse_cmd_abort,         0, UPDATE_REFS_CLOSED },\n\t{ \"commit\",        parse_cmd_commit,        0, UPDATE_REFS_CLOSED },\n};\n\nstatic void update_refs_stdin(unsigned int flags)\n{\n\tstruct strbuf input = STRBUF_INIT, err = STRBUF_INIT;\n\tenum update_refs_state state = UPDATE_REFS_OPEN;\n\tstruct ref_transaction *transaction;\n\tint i, j;\n\n\ttransaction = ref_store_transaction_begin(get_main_ref_store(the_repository),\n\t\t\t\t\t\t  flags, &err);\n\tif (!transaction)\n\t\tdie(\"%s\", err.buf);\n\n\t/* Read each line dispatch its command */\n\twhile (!strbuf_getwholeline(&input, stdin, line_termination)) {\n\t\tconst struct parse_cmd *cmd = NULL;\n\n\t\tif (*input.buf == line_termination)\n\t\t\tdie(\"empty command in input\");\n\t\telse if (isspace(*input.buf))\n\t\t\tdie(\"whitespace before command: %s\", input.buf);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(command); i++) {\n\t\t\tconst char *prefix = command[i].prefix;\n\t\t\tchar c;\n\n\t\t\tif (!starts_with(input.buf, prefix))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If the command has arguments, verify that it's\n\t\t\t * followed by a space. Otherwise, it shall be followed\n\t\t\t * by a line terminator.\n\t\t\t */\n\t\t\tc = command[i].args ? ' ' : line_termination;\n\t\t\tif (input.buf[strlen(prefix)] != c)\n\t\t\t\tcontinue;\n\n\t\t\tcmd = &command[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (!cmd)\n\t\t\tdie(\"unknown command: %s\", input.buf);\n\n\t\t/*\n\t\t * Read additional arguments if NUL-terminated. Do not raise an\n\t\t * error in case there is an early EOF to let the command\n\t\t * handle missing arguments with a proper error message.\n\t\t */\n\t\tfor (j = 1; line_termination == '\\0' && j < cmd->args; j++)\n\t\t\tif (strbuf_appendwholeline(&input, stdin, line_termination))\n\t\t\t\tbreak;\n\n\t\tswitch (state) {\n\t\tcase UPDATE_REFS_OPEN:\n\t\tcase UPDATE_REFS_STARTED:\n\t\t\tif (state == UPDATE_REFS_STARTED && cmd->state == UPDATE_REFS_STARTED)\n\t\t\t\tdie(\"cannot restart ongoing transaction\");\n\t\t\t/* Do not downgrade a transaction to a non-transaction. */\n\t\t\tif (cmd->state >= state)\n\t\t\t\tstate = cmd->state;\n\t\t\tbreak;\n\t\tcase UPDATE_REFS_PREPARED:\n\t\t\tif (cmd->state != UPDATE_REFS_CLOSED)\n\t\t\t\tdie(\"prepared transactions can only be closed\");\n\t\t\tstate = cmd->state;\n\t\t\tbreak;\n\t\tcase UPDATE_REFS_CLOSED:\n\t\t\tif (cmd->state != UPDATE_REFS_STARTED)\n\t\t\t\tdie(\"transaction is closed\");\n\n\t\t\t/*\n\t\t\t * Open a new transaction if we're currently closed and\n\t\t\t * get a \"start\".\n\t\t\t */\n\t\t\tstate = cmd->state;\n\t\t\ttransaction = ref_store_transaction_begin(get_main_ref_store(the_repository),\n\t\t\t\t\t\t\t\t  flags, &err);\n\t\t\tif (!transaction)\n\t\t\t\tdie(\"%s\", err.buf);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcmd->fn(transaction, input.buf + strlen(cmd->prefix) + !!cmd->args,\n\t\t\tinput.buf + input.len);\n\t}\n\n\tswitch (state) {\n\tcase UPDATE_REFS_OPEN:\n\t\t/* Commit by default if no transaction was requested. */\n\t\tif (ref_transaction_commit(transaction, &err))\n\t\t\tdie(\"%s\", err.buf);\n\t\tref_transaction_for_each_rejected_update(transaction,\n\t\t\t\t\t\t print_rejected_refs, NULL);\n\t\tref_transaction_free(transaction);\n\t\tbreak;\n\tcase UPDATE_REFS_STARTED:\n\tcase UPDATE_REFS_PREPARED:\n\t\t/* If using a transaction, we want to abort it. */\n\t\tif (ref_transaction_abort(transaction, &err))\n\t\t\tdie(\"%s\", err.buf);\n\t\tbreak;\n\tcase UPDATE_REFS_CLOSED:\n\t\t/* Otherwise no need to do anything, the transaction was closed already. */\n\t\tbreak;\n\t}\n\n\tstrbuf_release(&err);\n\tstrbuf_release(&input);\n}\n\nint cmd_update_ref(int argc,\n\t\t   const char **argv,\n\t\t   const char *prefix,\n\t\t   struct repository *repo UNUSED)\n{\n\tconst char *refname, *oldval;\n\tstruct object_id oid, oldoid;\n\tint delete = 0, no_deref = 0, read_stdin = 0, end_null = 0;\n\tint create_reflog = 0;\n\tunsigned int flags = 0;\n\n\tstruct option options[] = {\n\t\tOPT_STRING( 'm', NULL, &msg, N_(\"reason\"), N_(\"reason of the update\")),\n\t\tOPT_BOOL('d', NULL, &delete, N_(\"delete the reference\")),\n\t\tOPT_BOOL( 0 , \"no-deref\", &no_deref,\n\t\t\t\t\tN_(\"update <refname> not the one it points to\")),\n\t\tOPT_BOOL('z', NULL, &end_null, N_(\"stdin has NUL-terminated arguments\")),\n\t\tOPT_BOOL( 0 , \"stdin\", &read_stdin, N_(\"read updates from stdin\")),\n\t\tOPT_BOOL( 0 , \"create-reflog\", &create_reflog, N_(\"create a reflog\")),\n\t\tOPT_BIT('0', \"batch-updates\", &flags, N_(\"batch reference updates\"),\n\t\t\tREF_TRANSACTION_ALLOW_FAILURE),\n\t\tOPT_END(),\n\t};\n\n\trepo_config(the_repository, git_default_config, NULL);\n\targc = parse_options(argc, argv, prefix, options, git_update_ref_usage,\n\t\t\t     0);\n\tif (msg && !*msg)\n\t\tdie(\"Refusing to perform update with empty message.\");\n\n\tcreate_reflog_flag = create_reflog ? REF_FORCE_CREATE_REFLOG : 0;\n\n\tif (no_deref) {\n\t\tdefault_flags = REF_NO_DEREF;\n\t\tupdate_flags = default_flags;\n\t}\n\n\tif (read_stdin) {\n\t\tif (delete || argc > 0)\n\t\t\tusage_with_options(git_update_ref_usage, options);\n\t\tif (end_null)\n\t\t\tline_termination = '\\0';\n\t\tupdate_refs_stdin(flags);\n\t\treturn 0;\n\t} else if (flags & REF_TRANSACTION_ALLOW_FAILURE) {\n\t\tdie(\"--batch-updates can only be used with --stdin\");\n\t}\n\n\tif (end_null)\n\t\tusage_with_options(git_update_ref_usage, options);\n\n\tif (delete) {\n\t\tif (argc < 1 || argc > 2)\n\t\t\tusage_with_options(git_update_ref_usage, options);\n\t\trefname = argv[0];\n\t\toldval = argv[1];\n\t} else {\n\t\tconst char *value;\n\t\tif (argc < 2 || argc > 3)\n\t\t\tusage_with_options(git_update_ref_usage, options);\n\t\trefname = argv[0];\n\t\tvalue = argv[1];\n\t\toldval = argv[2];\n\t\tif (repo_get_oid_with_flags(the_repository, value, &oid,\n\t\t\t\t\t    GET_OID_SKIP_AMBIGUITY_CHECK))\n\t\t\tdie(\"%s: not a valid SHA1\", value);\n\t}\n\n\tif (oldval) {\n\t\tif (!*oldval)\n\t\t\t/*\n\t\t\t * The empty string implies that the reference\n\t\t\t * must not already exist:\n\t\t\t */\n\t\t\toidclr(&oldoid, the_repository->hash_algo);\n\t\telse if (repo_get_oid_with_flags(the_repository, oldval, &oldoid,\n\t\t\t\t\t\t GET_OID_SKIP_AMBIGUITY_CHECK))\n\t\t\tdie(\"%s: not a valid old SHA1\", oldval);\n\t}\n\n\tif (delete)\n\t\t/*\n\t\t * For purposes of backwards compatibility, we treat\n\t\t * NULL_SHA1 as \"don't care\" here:\n\t\t */\n\t\treturn refs_delete_ref(get_main_ref_store(the_repository),\n\t\t\t\t       msg, refname,\n\t\t\t\t       (oldval && !is_null_oid(&oldoid)) ? &oldoid : NULL,\n\t\t\t\t       default_flags);\n\telse\n\t\treturn refs_update_ref(get_main_ref_store(the_repository),\n\t\t\t\t       msg, refname, &oid,\n\t\t\t\t       oldval ? &oldoid : NULL,\n\t\t\t\t       default_flags | create_reflog_flag,\n\t\t\t\t       UPDATE_REFS_DIE_ON_ERR);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0046a87c579122bdb35351b7f6ac5eb2e642e585",
  "sha1_ok": true,
  "size": 23502
}
