{
  "content": {
    "base64": "IyEvYmluL2Jhc2gKIwojIGdpdC1zdWJ0cmVlLnNoOiBzcGxpdC9qb2luIGdpdCByZXBvc2l0b3JpZXMgaW4gc3ViZGlyZWN0b3JpZXMgb2YgdGhpcyBvbmUKIwojIENvcHlyaWdodCAoQykgMjAwOSBBdmVyeSBQZW5uYXJ1biA8YXBlbndhcnJAZ21haWwuY29tPgojCmlmIFsgJCMgLWVxIDAgXTsgdGhlbgogICAgc2V0IC0tIC1oCmZpCk9QVFNfU1BFQz0iXApnaXQgc3VidHJlZSBhZGQgICAtLXByZWZpeD08cHJlZml4PiA8Y29tbWl0PgpnaXQgc3VidHJlZSBtZXJnZSAtLXByZWZpeD08cHJlZml4PiA8Y29tbWl0PgpnaXQgc3VidHJlZSBwdWxsICAtLXByZWZpeD08cHJlZml4PiA8cmVwb3NpdG9yeT4gPHJlZnNwZWMuLi4+CmdpdCBzdWJ0cmVlIHNwbGl0IC0tcHJlZml4PTxwcmVmaXg+IDxjb21taXQuLi4+Ci0tCmgsaGVscCAgICAgICAgc2hvdyB0aGUgaGVscApxICAgICAgICAgICAgIHF1aWV0CmQgICAgICAgICAgICAgc2hvdyBkZWJ1ZyBtZXNzYWdlcwpQLHByZWZpeD0gICAgIHRoZSBuYW1lIG9mIHRoZSBzdWJkaXIgdG8gc3BsaXQgb3V0Cm0sbWVzc2FnZT0gICAgdXNlIHRoZSBnaXZlbiBtZXNzYWdlIGFzIHRoZSBjb21taXQgbWVzc2FnZSBmb3IgdGhlIG1lcmdlIGNvbW1pdAogb3B0aW9ucyBmb3IgJ3NwbGl0Jwphbm5vdGF0ZT0gICAgIGFkZCBhIHByZWZpeCB0byBjb21taXQgbWVzc2FnZSBvZiBuZXcgY29tbWl0cwpiLGJyYW5jaD0gICAgIGNyZWF0ZSBhIG5ldyBicmFuY2ggZnJvbSB0aGUgc3BsaXQgc3VidHJlZQppZ25vcmUtam9pbnMgIGlnbm9yZSBwcmlvciAtLXJlam9pbiBjb21taXRzCm9udG89ICAgICAgICAgdHJ5IGNvbm5lY3RpbmcgbmV3IHRyZWUgdG8gYW4gZXhpc3Rpbmcgb25lCnJlam9pbiAgICAgICAgbWVyZ2UgdGhlIG5ldyBicmFuY2ggYmFjayBpbnRvIEhFQUQKIG9wdGlvbnMgZm9yICdhZGQnLCAnbWVyZ2UnLCBhbmQgJ3B1bGwnCnNxdWFzaCAgICAgICAgbWVyZ2Ugc3VidHJlZSBjaGFuZ2VzIGFzIGEgc2luZ2xlIGNvbW1pdAoiCmV2YWwgJChlY2hvICIkT1BUU19TUEVDIiB8IGdpdCByZXYtcGFyc2UgLS1wYXJzZW9wdCAtLSAiJEAiIHx8IGVjaG8gZXhpdCAkPykKUEFUSD0kKGdpdCAtLWV4ZWMtcGF0aCk6JFBBVEgKLiBnaXQtc2gtc2V0dXAKcmVxdWlyZV93b3JrX3RyZWUKCnF1aWV0PQpicmFuY2g9CmRlYnVnPQpjb21tYW5kPQpvbnRvPQpyZWpvaW49Cmlnbm9yZV9qb2lucz0KYW5ub3RhdGU9CnNxdWFzaD0KbWVzc2FnZT0KCmRlYnVnKCkKewoJaWYgWyAtbiAiJGRlYnVnIiBdOyB0aGVuCgkJZWNobyAiJEAiID4mMgoJZmkKfQoKc2F5KCkKewoJaWYgWyAteiAiJHF1aWV0IiBdOyB0aGVuCgkJZWNobyAiJEAiID4mMgoJZmkKfQoKYXNzZXJ0KCkKewoJaWYgIiRAIjsgdGhlbgoJCToKCWVsc2UKCQlkaWUgImFzc2VydGlvbiBmYWlsZWQ6ICIgIiRAIgoJZmkKfQoKCiNlY2hvICJPcHRpb25zOiAkKiIKCndoaWxlIFsgJCMgLWd0IDAgXTsgZG8KCW9wdD0iJDEiCglzaGlmdAoJY2FzZSAiJG9wdCIgaW4KCQktcSkgcXVpZXQ9MSA7OwoJCS1kKSBkZWJ1Zz0xIDs7CgkJLS1hbm5vdGF0ZSkgYW5ub3RhdGU9IiQxIjsgc2hpZnQgOzsKCQktLW5vLWFubm90YXRlKSBhbm5vdGF0ZT0gOzsKCQktYikgYnJhbmNoPSIkMSI7IHNoaWZ0IDs7CgkJLVApIHByZWZpeD0iJDEiOyBzaGlmdCA7OwoJCS1tKSBtZXNzYWdlPSIkMSI7IHNoaWZ0IDs7CgkJLS1uby1wcmVmaXgpIHByZWZpeD0gOzsKCQktLW9udG8pIG9udG89IiQxIjsgc2hpZnQgOzsKCQktLW5vLW9udG8pIG9udG89IDs7CgkJLS1yZWpvaW4pIHJlam9pbj0xIDs7CgkJLS1uby1yZWpvaW4pIHJlam9pbj0gOzsKCQktLWlnbm9yZS1qb2lucykgaWdub3JlX2pvaW5zPTEgOzsKCQktLW5vLWlnbm9yZS1qb2lucykgaWdub3JlX2pvaW5zPSA7OwoJCS0tc3F1YXNoKSBzcXVhc2g9MSA7OwoJCS0tbm8tc3F1YXNoKSBzcXVhc2g9IDs7CgkJLS0pIGJyZWFrIDs7CgkJKikgZGllICJVbmV4cGVjdGVkIG9wdGlvbjogJG9wdCIgOzsKCWVzYWMKZG9uZQoKY29tbWFuZD0iJDEiCnNoaWZ0CmNhc2UgIiRjb21tYW5kIiBpbgoJYWRkfG1lcmdlfHB1bGwpIGRlZmF1bHQ9IDs7CglzcGxpdCkgZGVmYXVsdD0iLS1kZWZhdWx0IEhFQUQiIDs7CgkqKSBkaWUgIlVua25vd24gY29tbWFuZCAnJGNvbW1hbmQnIiA7Owplc2FjCgppZiBbIC16ICIkcHJlZml4IiBdOyB0aGVuCglkaWUgIllvdSBtdXN0IHByb3ZpZGUgdGhlIC0tcHJlZml4IG9wdGlvbi4iCmZpCmRpcj0iJChkaXJuYW1lICIkcHJlZml4Ly4iKSIKCmlmIFsgIiRjb21tYW5kIiAhPSAicHVsbCIgXTsgdGhlbgoJcmV2cz0kKGdpdCByZXYtcGFyc2UgJGRlZmF1bHQgLS1yZXZzLW9ubHkgIiRAIikgfHwgZXhpdCAkPwoJZGlycz0iJChnaXQgcmV2LXBhcnNlIC0tbm8tcmV2cyAtLW5vLWZsYWdzICIkQCIpIiB8fCBleGl0ICQ/CglpZiBbIC1uICIkZGlycyIgXTsgdGhlbgoJCWRpZSAiRXJyb3I6IFVzZSAtLXByZWZpeCBpbnN0ZWFkIG9mIGJhcmUgZmlsZW5hbWVzLiIKCWZpCmZpCgpkZWJ1ZyAiY29tbWFuZDogeyRjb21tYW5kfSIKZGVidWcgInF1aWV0OiB7JHF1aWV0fSIKZGVidWcgInJldnM6IHskcmV2c30iCmRlYnVnICJkaXI6IHskZGlyfSIKZGVidWcgIm9wdHM6IHskKn0iCmRlYnVnCgpjYWNoZV9zZXR1cCgpCnsKCWNhY2hlZGlyPSIkR0lUX0RJUi9zdWJ0cmVlLWNhY2hlLyQkIgoJcm0gLXJmICIkY2FjaGVkaXIiIHx8IGRpZSAiQ2FuJ3QgZGVsZXRlIG9sZCBjYWNoZWRpcjogJGNhY2hlZGlyIgoJbWtkaXIgLXAgIiRjYWNoZWRpciIgfHwgZGllICJDYW4ndCBjcmVhdGUgbmV3IGNhY2hlZGlyOiAkY2FjaGVkaXIiCglkZWJ1ZyAiVXNpbmcgY2FjaGVkaXI6ICRjYWNoZWRpciIgPiYyCn0KCmNhY2hlX2dldCgpCnsKCWZvciBvbGRyZXYgaW4gJCo7IGRvCgkJaWYgWyAtciAiJGNhY2hlZGlyLyRvbGRyZXYiIF07IHRoZW4KCQkJcmVhZCBuZXdyZXYgPCIkY2FjaGVkaXIvJG9sZHJldiIKCQkJZWNobyAkbmV3cmV2CgkJZmkKCWRvbmUKfQoKY2FjaGVfc2V0KCkKewoJb2xkcmV2PSIkMSIKCW5ld3Jldj0iJDIiCglpZiBbICIkb2xkcmV2IiAhPSAibGF0ZXN0X29sZCIgXAoJICAgICAtYSAiJG9sZHJldiIgIT0gImxhdGVzdF9uZXciIFwKCSAgICAgLWEgLWUgIiRjYWNoZWRpci8kb2xkcmV2IiBdOyB0aGVuCgkJZGllICJjYWNoZSBmb3IgJG9sZHJldiBhbHJlYWR5IGV4aXN0cyEiCglmaQoJZWNobyAiJG5ld3JldiIgPiIkY2FjaGVkaXIvJG9sZHJldiIKfQoKcmV2X2V4aXN0cygpCnsKCWlmIGdpdCByZXYtcGFyc2UgIiQxIiA+L2Rldi9udWxsIDI+JjE7IHRoZW4KCQlyZXR1cm4gMAoJZWxzZQoJCXJldHVybiAxCglmaQp9CgpyZXZfaXNfZGVzY2VuZGFudF9vZl9icmFuY2goKQp7CgluZXdyZXY9IiQxIgoJYnJhbmNoPSIkMiIKCWJyYW5jaF9oYXNoPSQoZ2l0IHJldi1wYXJzZSAkYnJhbmNoKQoJbWF0Y2g9JChnaXQgcmV2LWxpc3QgLTEgJGJyYW5jaF9oYXNoIF4kbmV3cmV2KQoKCWlmIFsgLXogIiRtYXRjaCIgXTsgdGhlbgoJCXJldHVybiAwCgllbHNlCgkJcmV0dXJuIDEKCWZpCn0KCiMgaWYgYSBjb21taXQgZG9lc24ndCBoYXZlIGEgcGFyZW50LCB0aGlzIG1pZ2h0IG5vdCB3b3JrLiAgQnV0IHdlIG9ubHkgd2FudAojIHRvIHJlbW92ZSB0aGUgcGFyZW50IGZyb20gdGhlIHJldi1saXN0LCBhbmQgc2luY2UgaXQgZG9lc24ndCBleGlzdCwgaXQgd29uJ3QKIyBiZSB0aGVyZSBhbnl3YXksIHNvIGRvIG5vdGhpbmcgaW4gdGhhdCBjYXNlLgp0cnlfcmVtb3ZlX3ByZXZpb3VzKCkKewoJaWYgcmV2X2V4aXN0cyAiJDFeIjsgdGhlbgoJCWVjaG8gIl4kMV4iCglmaQp9CgpmaW5kX2xhdGVzdF9zcXVhc2goKQp7CglkZWJ1ZyAiTG9va2luZyBmb3IgbGF0ZXN0IHNxdWFzaCAoJGRpcikuLi4iCglkaXI9IiQxIgoJc3E9CgltYWluPQoJc3ViPQoJZ2l0IGxvZyAtLWdyZXA9Il5naXQtc3VidHJlZS1kaXI6ICRkaXIvKlwkIiBcCgkJLS1wcmV0dHk9Zm9ybWF0OidTVEFSVCAlSCVuJXMlbiVuJWIlbkVORCVuJyBIRUFEIHwKCXdoaWxlIHJlYWQgYSBiIGp1bms7IGRvCgkJZGVidWcgIiRhICRiICRqdW5rIgoJCWRlYnVnICJ7eyRzcS8kbWFpbi8kc3VifX0iCgkJY2FzZSAiJGEiIGluCgkJCVNUQVJUKSBzcT0iJGIiIDs7CgkJCWdpdC1zdWJ0cmVlLW1haW5saW5lOikgbWFpbj0iJGIiIDs7CgkJCWdpdC1zdWJ0cmVlLXNwbGl0Oikgc3ViPSIkYiIgOzsKCQkJRU5EKQoJCQkJaWYgWyAtbiAiJHN1YiIgXTsgdGhlbgoJCQkJCWlmIFsgLW4gIiRtYWluIiBdOyB0aGVuCgkJCQkJCSMgYSByZWpvaW4gY29tbWl0PwoJCQkJCQkjIFByZXRlbmQgaXRzIHN1YiB3YXMgYSBzcXVhc2guCgkJCQkJCXNxPSIkc3ViIgoJCQkJCWZpCgkJCQkJZGVidWcgIlNxdWFzaCBmb3VuZDogJHNxICRzdWIiCgkJCQkJZWNobyAiJHNxIiAiJHN1YiIKCQkJCQlicmVhawoJCQkJZmkKCQkJCXNxPQoJCQkJbWFpbj0KCQkJCXN1Yj0KCQkJCTs7CgkJZXNhYwoJZG9uZQp9CgpmaW5kX2V4aXN0aW5nX3NwbGl0cygpCnsKCWRlYnVnICJMb29raW5nIGZvciBwcmlvciBzcGxpdHMuLi4iCglkaXI9IiQxIgoJcmV2cz0iJDIiCgltYWluPQoJc3ViPQoJZ2l0IGxvZyAtLWdyZXA9Il5naXQtc3VidHJlZS1kaXI6ICRkaXIvKlwkIiBcCgkJLS1wcmV0dHk9Zm9ybWF0OidTVEFSVCAlSCVuJXMlbiVuJWIlbkVORCVuJyAkcmV2cyB8Cgl3aGlsZSByZWFkIGEgYiBqdW5rOyBkbwoJCWNhc2UgIiRhIiBpbgoJCQlTVEFSVCkgc3E9IiRiIiA7OwoJCQlnaXQtc3VidHJlZS1tYWlubGluZTopIG1haW49IiRiIiA7OwoJCQlnaXQtc3VidHJlZS1zcGxpdDopIHN1Yj0iJGIiIDs7CgkJCUVORCkKCQkJCWRlYnVnICIgIE1haW4gaXM6ICckbWFpbiciCgkJCQlpZiBbIC16ICIkbWFpbiIgLWEgLW4gIiRzdWIiIF07IHRoZW4KCQkJCQkjIHNxdWFzaCBjb21taXRzIHJlZmVyIHRvIGEgc3VidHJlZQoJCQkJCWRlYnVnICIgIFNxdWFzaDogJHNxIGZyb20gJHN1YiIKCQkJCQljYWNoZV9zZXQgIiRzcSIgIiRzdWIiCgkJCQlmaQoJCQkJaWYgWyAtbiAiJG1haW4iIC1hIC1uICIkc3ViIiBdOyB0aGVuCgkJCQkJZGVidWcgIiAgUHJpb3I6ICRtYWluIC0+ICRzdWIiCgkJCQkJY2FjaGVfc2V0ICRtYWluICRzdWIKCQkJCQl0cnlfcmVtb3ZlX3ByZXZpb3VzICIkbWFpbiIKCQkJCQl0cnlfcmVtb3ZlX3ByZXZpb3VzICIkc3ViIgoJCQkJZmkKCQkJCW1haW49CgkJCQlzdWI9CgkJCQk7OwoJCWVzYWMKCWRvbmUKfQoKY29weV9jb21taXQoKQp7CgkjIFdlJ3JlIGdvaW5nIHRvIHNldCBzb21lIGVudmlyb25tZW50IHZhcnMgaGVyZSwgc28KCSMgZG8gaXQgaW4gYSBzdWJzaGVsbCB0byBnZXQgcmlkIG9mIHRoZW0gc2FmZWx5IGxhdGVyCglkZWJ1ZyBjb3B5X2NvbW1pdCAieyQxfSIgInskMn0iICJ7JDN9IgoJZ2l0IGxvZyAtMSAtLXByZXR0eT1mb3JtYXQ6JyVhbiVuJWFlJW4lYWQlbiVjbiVuJWNlJW4lY2QlbiVzJW4lbiViJyAiJDEiIHwKCSgKCQlyZWFkIEdJVF9BVVRIT1JfTkFNRQoJCXJlYWQgR0lUX0FVVEhPUl9FTUFJTAoJCXJlYWQgR0lUX0FVVEhPUl9EQVRFCgkJcmVhZCBHSVRfQ09NTUlUVEVSX05BTUUKCQlyZWFkIEdJVF9DT01NSVRURVJfRU1BSUwKCQlyZWFkIEdJVF9DT01NSVRURVJfREFURQoJCWV4cG9ydCAgR0lUX0FVVEhPUl9OQU1FIFwKCQkJR0lUX0FVVEhPUl9FTUFJTCBcCgkJCUdJVF9BVVRIT1JfREFURSBcCgkJCUdJVF9DT01NSVRURVJfTkFNRSBcCgkJCUdJVF9DT01NSVRURVJfRU1BSUwgXAoJCQlHSVRfQ09NTUlUVEVSX0RBVEUKCQkoZWNobyAtbiAiJGFubm90YXRlIjsgY2F0ICkgfAoJCWdpdCBjb21taXQtdHJlZSAiJDIiICQzICAjIHJlYWRzIHRoZSByZXN0IG9mIHN0ZGluCgkpIHx8IGRpZSAiQ2FuJ3QgY29weSBjb21taXQgJDEiCn0KCmFkZF9tc2coKQp7CglkaXI9IiQxIgoJbGF0ZXN0X29sZD0iJDIiCglsYXRlc3RfbmV3PSIkMyIKCWlmIFsgLW4gIiRtZXNzYWdlIiBdOyB0aGVuCgkJY29tbWl0X21lc3NhZ2U9IiRtZXNzYWdlIgoJZWxzZQoJCWNvbW1pdF9tZXNzYWdlPSJBZGQgJyRkaXIvJyBmcm9tIGNvbW1pdCAnJGxhdGVzdF9uZXcnIgoJZmkKCWNhdCA8PC1FT0YKCQkkY29tbWl0X21lc3NhZ2UKCQkKCQlnaXQtc3VidHJlZS1kaXI6ICRkaXIKCQlnaXQtc3VidHJlZS1tYWlubGluZTogJGxhdGVzdF9vbGQKCQlnaXQtc3VidHJlZS1zcGxpdDogJGxhdGVzdF9uZXcKCUVPRgp9CgphZGRfc3F1YXNoZWRfbXNnKCkKewoJaWYgWyAtbiAiJG1lc3NhZ2UiIF07IHRoZW4KCQllY2hvICIkbWVzc2FnZSIKCWVsc2UKCQllY2hvICJNZXJnZSBjb21taXQgJyQxJyBhcyAnJDInIgoJZmkKfQoKcmVqb2luX21zZygpCnsKCWRpcj0iJDEiCglsYXRlc3Rfb2xkPSIkMiIKCWxhdGVzdF9uZXc9IiQzIgoJaWYgWyAtbiAiJG1lc3NhZ2UiIF07IHRoZW4KCQljb21taXRfbWVzc2FnZT0iJG1lc3NhZ2UiCgllbHNlCgkJY29tbWl0X21lc3NhZ2U9IlNwbGl0ICckZGlyLycgaW50byBjb21taXQgJyRsYXRlc3RfbmV3JyIKCWZpCgljYXQgPDwtRU9GCgkJJGNvbW1pdF9tZXNzYWdlCgkJCgkJZ2l0LXN1YnRyZWUtZGlyOiAkZGlyCgkJZ2l0LXN1YnRyZWUtbWFpbmxpbmU6ICRsYXRlc3Rfb2xkCgkJZ2l0LXN1YnRyZWUtc3BsaXQ6ICRsYXRlc3RfbmV3CglFT0YKfQoKc3F1YXNoX21zZygpCnsKCWRpcj0iJDEiCglvbGRzdWI9IiQyIgoJbmV3c3ViPSIkMyIKCW5ld3N1Yl9zaG9ydD0kKGdpdCByZXYtcGFyc2UgLS1zaG9ydCAiJG5ld3N1YiIpCgkKCWlmIFsgLW4gIiRvbGRzdWIiIF07IHRoZW4KCQlvbGRzdWJfc2hvcnQ9JChnaXQgcmV2LXBhcnNlIC0tc2hvcnQgIiRvbGRzdWIiKQoJCWVjaG8gIlNxdWFzaGVkICckZGlyLycgY2hhbmdlcyBmcm9tICRvbGRzdWJfc2hvcnQuLiRuZXdzdWJfc2hvcnQiCgkJZWNobwoJCWdpdCBsb2cgLS1wcmV0dHk9dGZvcm1hdDonJWggJXMnICIkb2xkc3ViLi4kbmV3c3ViIgoJCWdpdCBsb2cgLS1wcmV0dHk9dGZvcm1hdDonUkVWRVJUOiAlaCAlcycgIiRuZXdzdWIuLiRvbGRzdWIiCgllbHNlCgkJZWNobyAiU3F1YXNoZWQgJyRkaXIvJyBjb250ZW50IGZyb20gY29tbWl0ICRuZXdzdWJfc2hvcnQiCglmaQoJCgllY2hvCgllY2hvICJnaXQtc3VidHJlZS1kaXI6ICRkaXIiCgllY2hvICJnaXQtc3VidHJlZS1zcGxpdDogJG5ld3N1YiIKfQoKdG9wdHJlZV9mb3JfY29tbWl0KCkKewoJY29tbWl0PSIkMSIKCWdpdCBsb2cgLTEgLS1wcmV0dHk9Zm9ybWF0OiclVCcgIiRjb21taXQiIC0tIHx8IGV4aXQgJD8KfQoKc3VidHJlZV9mb3JfY29tbWl0KCkKewoJY29tbWl0PSIkMSIKCWRpcj0iJDIiCglnaXQgbHMtdHJlZSAiJGNvbW1pdCIgLS0gIiRkaXIiIHwKCXdoaWxlIHJlYWQgbW9kZSB0eXBlIHRyZWUgbmFtZTsgZG8KCQlhc3NlcnQgWyAiJG5hbWUiID0gIiRkaXIiIF0KCQlhc3NlcnQgWyAiJHR5cGUiID0gInRyZWUiIF0KCQllY2hvICR0cmVlCgkJYnJlYWsKCWRvbmUKfQoKdHJlZV9jaGFuZ2VkKCkKewoJdHJlZT0kMQoJc2hpZnQKCWlmIFsgJCMgLW5lIDEgXTsgdGhlbgoJCXJldHVybiAwICAgIyB3ZWlyZCBwYXJlbnRzLCBjb25zaWRlciBpdCBjaGFuZ2VkCgllbHNlCgkJcHRyZWU9JCh0b3B0cmVlX2Zvcl9jb21taXQgJDEpCgkJaWYgWyAiJHB0cmVlIiAhPSAiJHRyZWUiIF07IHRoZW4KCQkJcmV0dXJuIDAgICAjIGNoYW5nZWQKCQllbHNlCgkJCXJldHVybiAxICAgIyBub3QgY2hhbmdlZAoJCWZpCglmaQp9CgpuZXdfc3F1YXNoX2NvbW1pdCgpCnsKCW9sZD0iJDEiCglvbGRzdWI9IiQyIgoJbmV3c3ViPSIkMyIKCXRyZWU9JCh0b3B0cmVlX2Zvcl9jb21taXQgJG5ld3N1YikgfHwgZXhpdCAkPwoJaWYgWyAtbiAiJG9sZCIgXTsgdGhlbgoJCXNxdWFzaF9tc2cgIiRkaXIiICIkb2xkc3ViIiAiJG5ld3N1YiIgfCAKCQkJZ2l0IGNvbW1pdC10cmVlICIkdHJlZSIgLXAgIiRvbGQiIHx8IGV4aXQgJD8KCWVsc2UKCQlzcXVhc2hfbXNnICIkZGlyIiAiIiAiJG5ld3N1YiIgfAoJCQlnaXQgY29tbWl0LXRyZWUgIiR0cmVlIiB8fCBleGl0ICQ/CglmaQp9Cgpjb3B5X29yX3NraXAoKQp7CglyZXY9IiQxIgoJdHJlZT0iJDIiCgluZXdwYXJlbnRzPSIkMyIKCWFzc2VydCBbIC1uICIkdHJlZSIgXQoKCWlkZW50aWNhbD0KCW5vbmlkZW50aWNhbD0KCXA9Cglnb3RwYXJlbnRzPQoJZm9yIHBhcmVudCBpbiAkbmV3cGFyZW50czsgZG8KCQlwdHJlZT0kKHRvcHRyZWVfZm9yX2NvbW1pdCAkcGFyZW50KSB8fCBleGl0ICQ/CgkJWyAteiAiJHB0cmVlIiBdICYmIGNvbnRpbnVlCgkJaWYgWyAiJHB0cmVlIiA9ICIkdHJlZSIgXTsgdGhlbgoJCQkjIGFuIGlkZW50aWNhbCBwYXJlbnQgY291bGQgYmUgdXNlZCBpbiBwbGFjZSBvZiB0aGlzIHJldi4KCQkJaWRlbnRpY2FsPSIkcGFyZW50IgoJCWVsc2UKCQkJbm9uaWRlbnRpY2FsPSIkcGFyZW50IgoJCWZpCgkJCgkJIyBzb21ldGltZXMgYm90aCBvbGQgcGFyZW50cyBtYXAgdG8gdGhlIHNhbWUgbmV3cGFyZW50OwoJCSMgZWxpbWluYXRlIGR1cGxpY2F0ZXMKCQlpc19uZXc9MQoJCWZvciBncCBpbiAkZ290cGFyZW50czsgZG8KCQkJaWYgWyAiJGdwIiA9ICIkcGFyZW50IiBdOyB0aGVuCgkJCQlpc19uZXc9CgkJCQlicmVhawoJCQlmaQoJCWRvbmUKCQlpZiBbIC1uICIkaXNfbmV3IiBdOyB0aGVuCgkJCWdvdHBhcmVudHM9IiRnb3RwYXJlbnRzICRwYXJlbnQiCgkJCXA9IiRwIC1wICRwYXJlbnQiCgkJZmkKCWRvbmUKCQoJaWYgWyAtbiAiJGlkZW50aWNhbCIgXTsgdGhlbgoJCWVjaG8gJGlkZW50aWNhbAoJZWxzZQoJCWNvcHlfY29tbWl0ICRyZXYgJHRyZWUgIiRwIiB8fCBleGl0ICQ/CglmaQp9CgplbnN1cmVfY2xlYW4oKQp7CglpZiAhIGdpdCBkaWZmLWluZGV4IEhFQUQgLS1leGl0LWNvZGUgLS1xdWlldDsgdGhlbgoJCWRpZSAiV29ya2luZyB0cmVlIGhhcyBtb2RpZmljYXRpb25zLiAgQ2Fubm90IGFkZC4iCglmaQoJaWYgISBnaXQgZGlmZi1pbmRleCAtLWNhY2hlZCBIRUFEIC0tZXhpdC1jb2RlIC0tcXVpZXQ7IHRoZW4KCQlkaWUgIkluZGV4IGhhcyBtb2RpZmljYXRpb25zLiAgQ2Fubm90IGFkZC4iCglmaQp9CgpjbWRfYWRkKCkKewoJaWYgWyAtZSAiJGRpciIgXTsgdGhlbgoJCWRpZSAiJyRkaXInIGFscmVhZHkgZXhpc3RzLiAgQ2Fubm90IGFkZC4iCglmaQoJZW5zdXJlX2NsZWFuCgkKCXNldCAtLSAkcmV2cwoJaWYgWyAkIyAtbmUgMSBdOyB0aGVuCgkJZGllICJZb3UgbXVzdCBwcm92aWRlIGV4YWN0bHkgb25lIHJldmlzaW9uLiAgR290OiAnJHJldnMnIgoJZmkKCXJldj0iJDEiCgkKCWRlYnVnICJBZGRpbmcgJGRpciBhcyAnJHJldicuLi4iCglnaXQgcmVhZC10cmVlIC0tcHJlZml4PSIkZGlyIiAkcmV2IHx8IGV4aXQgJD8KCWdpdCBjaGVja291dCAtLSAiJGRpciIgfHwgZXhpdCAkPwoJdHJlZT0kKGdpdCB3cml0ZS10cmVlKSB8fCBleGl0ICQ/CgkKCWhlYWRyZXY9JChnaXQgcmV2LXBhcnNlIEhFQUQpIHx8IGV4aXQgJD8KCWlmIFsgLW4gIiRoZWFkcmV2IiAtYSAiJGhlYWRyZXYiICE9ICIkcmV2IiBdOyB0aGVuCgkJaGVhZHA9Ii1wICRoZWFkcmV2IgoJZWxzZQoJCWhlYWRwPQoJZmkKCQoJaWYgWyAtbiAiJHNxdWFzaCIgXTsgdGhlbgoJCXJldj0kKG5ld19zcXVhc2hfY29tbWl0ICIiICIiICIkcmV2IikgfHwgZXhpdCAkPwoJCWNvbW1pdD0kKGFkZF9zcXVhc2hlZF9tc2cgIiRyZXYiICIkZGlyIiB8CgkJCSBnaXQgY29tbWl0LXRyZWUgJHRyZWUgJGhlYWRwIC1wICIkcmV2IikgfHwgZXhpdCAkPwoJZWxzZQoJCWNvbW1pdD0kKGFkZF9tc2cgIiRkaXIiICIkaGVhZHJldiIgIiRyZXYiIHwKCQkJIGdpdCBjb21taXQtdHJlZSAkdHJlZSAkaGVhZHAgLXAgIiRyZXYiKSB8fCBleGl0ICQ/CglmaQoJZ2l0IHJlc2V0ICIkY29tbWl0IiB8fCBleGl0ICQ/CgkKCXNheSAiQWRkZWQgZGlyICckZGlyJyIKfQoKY21kX3NwbGl0KCkKewoJZGVidWcgIlNwbGl0dGluZyAkZGlyLi4uIgoJY2FjaGVfc2V0dXAgfHwgZXhpdCAkPwoJCglpZiBbIC1uICIkb250byIgXTsgdGhlbgoJCWRlYnVnICJSZWFkaW5nIGhpc3RvcnkgZm9yIC0tb250bz0kb250by4uLiIKCQlnaXQgcmV2LWxpc3QgJG9udG8gfAoJCXdoaWxlIHJlYWQgcmV2OyBkbwoJCQkjIHRoZSAnb250bycgaGlzdG9yeSBpcyBhbHJlYWR5IGp1c3QgdGhlIHN1YmRpciwgc28KCQkJIyBhbnkgcGFyZW50IHdlIGZpbmQgdGhlcmUgY2FuIGJlIHVzZWQgdmVyYmF0aW0KCQkJZGVidWcgIiAgY2FjaGU6ICRyZXYiCgkJCWNhY2hlX3NldCAkcmV2ICRyZXYKCQlkb25lCglmaQoJCglpZiBbIC1uICIkaWdub3JlX2pvaW5zIiBdOyB0aGVuCgkJdW5yZXZzPQoJZWxzZQoJCXVucmV2cz0iJChmaW5kX2V4aXN0aW5nX3NwbGl0cyAiJGRpciIgIiRyZXZzIikiCglmaQoJCgkjIFdlIGNhbid0IHJlc3RyaWN0IHJldi1saXN0IHRvIG9ubHkgJGRpciBoZXJlLCBiZWNhdXNlIHNvbWUgb2Ygb3VyCgkjIHBhcmVudHMgaGF2ZSB0aGUgJGRpciBjb250ZW50cyB0aGUgcm9vdCwgYW5kIHRob3NlIHdvbid0IG1hdGNoLgoJIyAoYW5kIHJldi1saXN0IC0tZm9sbG93IGRvZXNuJ3Qgc2VlbSB0byBzb2x2ZSB0aGlzKQoJZ3JsPSdnaXQgcmV2LWxpc3QgLS1yZXZlcnNlIC0tcGFyZW50cyAkcmV2cyAkdW5yZXZzJwoJcmV2bWF4PSQoZXZhbCAiJGdybCIgfCB3YyAtbCkKCXJldmNvdW50PTAKCWNyZWF0ZWNvdW50PTAKCWV2YWwgIiRncmwiIHwKCXdoaWxlIHJlYWQgcmV2IHBhcmVudHM7IGRvCgkJcmV2Y291bnQ9JCgoJHJldmNvdW50ICsgMSkpCgkJc2F5IC1uICIkcmV2Y291bnQvJHJldm1heCAoJGNyZWF0ZWNvdW50KQ0iCgkJZGVidWcgIlByb2Nlc3NpbmcgY29tbWl0OiAkcmV2IgoJCWV4aXN0cz0kKGNhY2hlX2dldCAkcmV2KQoJCWlmIFsgLW4gIiRleGlzdHMiIF07IHRoZW4KCQkJZGVidWcgIiAgcHJpb3I6ICRleGlzdHMiCgkJCWNvbnRpbnVlCgkJZmkKCQljcmVhdGVjb3VudD0kKCgkY3JlYXRlY291bnQgKyAxKSkKCQlkZWJ1ZyAiICBwYXJlbnRzOiAkcGFyZW50cyIKCQluZXdwYXJlbnRzPSQoY2FjaGVfZ2V0ICRwYXJlbnRzKQoJCWRlYnVnICIgIG5ld3BhcmVudHM6ICRuZXdwYXJlbnRzIgoJCQoJCXRyZWU9JChzdWJ0cmVlX2Zvcl9jb21taXQgJHJldiAiJGRpciIpCgkJZGVidWcgIiAgdHJlZSBpczogJHRyZWUiCgkJCgkJIyB1Z2x5LiAgaXMgdGhlcmUgbm8gYmV0dGVyIHdheSB0byB0ZWxsIGlmIHRoaXMgaXMgYSBzdWJ0cmVlCgkJIyB2cy4gYSBtYWlubGluZSBjb21taXQ/ICBEb2VzIGl0IG1hdHRlcj8KCQlpZiBbIC16ICR0cmVlIF07IHRoZW4KCQkJY2FjaGVfc2V0ICRyZXYgJHJldgoJCQljb250aW51ZQoJCWZpCgoJCW5ld3Jldj0kKGNvcHlfb3Jfc2tpcCAiJHJldiIgIiR0cmVlIiAiJG5ld3BhcmVudHMiKSB8fCBleGl0ICQ/CgkJZGVidWcgIiAgbmV3cmV2IGlzOiAkbmV3cmV2IgoJCWNhY2hlX3NldCAkcmV2ICRuZXdyZXYKCQljYWNoZV9zZXQgbGF0ZXN0X25ldyAkbmV3cmV2CgkJY2FjaGVfc2V0IGxhdGVzdF9vbGQgJHJldgoJZG9uZSB8fCBleGl0ICQ/CglsYXRlc3RfbmV3PSQoY2FjaGVfZ2V0IGxhdGVzdF9uZXcpCglpZiBbIC16ICIkbGF0ZXN0X25ldyIgXTsgdGhlbgoJCWRpZSAiTm8gbmV3IHJldmlzaW9ucyB3ZXJlIGZvdW5kIgoJZmkKCQoJaWYgWyAtbiAiJHJlam9pbiIgXTsgdGhlbgoJCWRlYnVnICJNZXJnaW5nIHNwbGl0IGJyYW5jaCBpbnRvIEhFQUQuLi4iCgkJbGF0ZXN0X29sZD0kKGNhY2hlX2dldCBsYXRlc3Rfb2xkKQoJCWdpdCBtZXJnZSAtcyBvdXJzIFwKCQkJLW0gIiQocmVqb2luX21zZyAkZGlyICRsYXRlc3Rfb2xkICRsYXRlc3RfbmV3KSIgXAoJCQkkbGF0ZXN0X25ldyA+JjIgfHwgZXhpdCAkPwoJZmkKCWlmIFsgLW4gIiRicmFuY2giIF07IHRoZW4KCQlpZiByZXZfZXhpc3RzICJyZWZzL2hlYWRzLyRicmFuY2giOyB0aGVuCgkJCWlmICEgcmV2X2lzX2Rlc2NlbmRhbnRfb2ZfYnJhbmNoICRsYXRlc3RfbmV3ICRicmFuY2g7IHRoZW4KCQkJCWRpZSAiQnJhbmNoICckYnJhbmNoJyBpcyBub3QgYW4gYW5jZXN0b3Igb2YgY29tbWl0ICckbGF0ZXN0X25ldycuIgoJCQlmaQoJCQlhY3Rpb249J1VwZGF0ZWQnCgkJZWxzZQoJCQlhY3Rpb249J0NyZWF0ZWQnCgkJZmkKCQlnaXQgdXBkYXRlLXJlZiAtbSAnc3VidHJlZSBzcGxpdCcgInJlZnMvaGVhZHMvJGJyYW5jaCIgJGxhdGVzdF9uZXcgfHwgZXhpdCAkPwoJCXNheSAiJGFjdGlvbiBicmFuY2ggJyRicmFuY2gnIgoJZmkKCWVjaG8gJGxhdGVzdF9uZXcKCWV4aXQgMAp9CgpjbWRfbWVyZ2UoKQp7CgllbnN1cmVfY2xlYW4KCQoJc2V0IC0tICRyZXZzCglpZiBbICQjIC1uZSAxIF07IHRoZW4KCQlkaWUgIllvdSBtdXN0IHByb3ZpZGUgZXhhY3RseSBvbmUgcmV2aXNpb24uICBHb3Q6ICckcmV2cyciCglmaQoJcmV2PSIkMSIKCQoJaWYgWyAtbiAiJHNxdWFzaCIgXTsgdGhlbgoJCWZpcnN0X3NwbGl0PSIkKGZpbmRfbGF0ZXN0X3NxdWFzaCAiJGRpciIpIgoJCWlmIFsgLXogIiRmaXJzdF9zcGxpdCIgXTsgdGhlbgoJCQlkaWUgIkNhbid0IHNxdWFzaC1tZXJnZTogJyRkaXInIHdhcyBuZXZlciBhZGRlZC4iCgkJZmkKCQlzZXQgJGZpcnN0X3NwbGl0CgkJb2xkPSQxCgkJc3ViPSQyCgkJaWYgWyAiJHN1YiIgPSAiJHJldiIgXTsgdGhlbgoJCQlzYXkgIlN1YnRyZWUgaXMgYWxyZWFkeSBhdCBjb21taXQgJHJldi4iCgkJCWV4aXQgMAoJCWZpCgkJbmV3PSQobmV3X3NxdWFzaF9jb21taXQgIiRvbGQiICIkc3ViIiAiJHJldiIpIHx8IGV4aXQgJD8KCQlkZWJ1ZyAiTmV3IHNxdWFzaCBjb21taXQ6ICRuZXciCgkJcmV2PSIkbmV3IgoJZmkKCQoJaWYgWyAtbiAiJG1lc3NhZ2UiIF07IHRoZW4KCQlnaXQgbWVyZ2UgLXMgc3VidHJlZSAtLW1lc3NhZ2U9IiRtZXNzYWdlIiAkcmV2CgllbHNlCgkJZ2l0IG1lcmdlIC1zIHN1YnRyZWUgJHJldgoJZmkKfQoKY21kX3B1bGwoKQp7CgllbnN1cmVfY2xlYW4KCWdpdCBmZXRjaCAiJEAiIHx8IGV4aXQgJD8KCXJldnM9RkVUQ0hfSEVBRAoJY21kX21lcmdlCn0KCiJjbWRfJGNvbW1hbmQiICIkQCIK",
    "text": "#!/bin/bash\n#\n# git-subtree.sh: split/join git repositories in subdirectories of this one\n#\n# Copyright (C) 2009 Avery Pennarun <apenwarr@gmail.com>\n#\nif [ $# -eq 0 ]; then\n    set -- -h\nfi\nOPTS_SPEC=\"\\\ngit subtree add   --prefix=<prefix> <commit>\ngit subtree merge --prefix=<prefix> <commit>\ngit subtree pull  --prefix=<prefix> <repository> <refspec...>\ngit subtree split --prefix=<prefix> <commit...>\n--\nh,help        show the help\nq             quiet\nd             show debug messages\nP,prefix=     the name of the subdir to split out\nm,message=    use the given message as the commit message for the merge commit\n options for 'split'\nannotate=     add a prefix to commit message of new commits\nb,branch=     create a new branch from the split subtree\nignore-joins  ignore prior --rejoin commits\nonto=         try connecting new tree to an existing one\nrejoin        merge the new branch back into HEAD\n options for 'add', 'merge', and 'pull'\nsquash        merge subtree changes as a single commit\n\"\neval $(echo \"$OPTS_SPEC\" | git rev-parse --parseopt -- \"$@\" || echo exit $?)\nPATH=$(git --exec-path):$PATH\n. git-sh-setup\nrequire_work_tree\n\nquiet=\nbranch=\ndebug=\ncommand=\nonto=\nrejoin=\nignore_joins=\nannotate=\nsquash=\nmessage=\n\ndebug()\n{\n\tif [ -n \"$debug\" ]; then\n\t\techo \"$@\" >&2\n\tfi\n}\n\nsay()\n{\n\tif [ -z \"$quiet\" ]; then\n\t\techo \"$@\" >&2\n\tfi\n}\n\nassert()\n{\n\tif \"$@\"; then\n\t\t:\n\telse\n\t\tdie \"assertion failed: \" \"$@\"\n\tfi\n}\n\n\n#echo \"Options: $*\"\n\nwhile [ $# -gt 0 ]; do\n\topt=\"$1\"\n\tshift\n\tcase \"$opt\" in\n\t\t-q) quiet=1 ;;\n\t\t-d) debug=1 ;;\n\t\t--annotate) annotate=\"$1\"; shift ;;\n\t\t--no-annotate) annotate= ;;\n\t\t-b) branch=\"$1\"; shift ;;\n\t\t-P) prefix=\"$1\"; shift ;;\n\t\t-m) message=\"$1\"; shift ;;\n\t\t--no-prefix) prefix= ;;\n\t\t--onto) onto=\"$1\"; shift ;;\n\t\t--no-onto) onto= ;;\n\t\t--rejoin) rejoin=1 ;;\n\t\t--no-rejoin) rejoin= ;;\n\t\t--ignore-joins) ignore_joins=1 ;;\n\t\t--no-ignore-joins) ignore_joins= ;;\n\t\t--squash) squash=1 ;;\n\t\t--no-squash) squash= ;;\n\t\t--) break ;;\n\t\t*) die \"Unexpected option: $opt\" ;;\n\tesac\ndone\n\ncommand=\"$1\"\nshift\ncase \"$command\" in\n\tadd|merge|pull) default= ;;\n\tsplit) default=\"--default HEAD\" ;;\n\t*) die \"Unknown command '$command'\" ;;\nesac\n\nif [ -z \"$prefix\" ]; then\n\tdie \"You must provide the --prefix option.\"\nfi\ndir=\"$(dirname \"$prefix/.\")\"\n\nif [ \"$command\" != \"pull\" ]; then\n\trevs=$(git rev-parse $default --revs-only \"$@\") || exit $?\n\tdirs=\"$(git rev-parse --no-revs --no-flags \"$@\")\" || exit $?\n\tif [ -n \"$dirs\" ]; then\n\t\tdie \"Error: Use --prefix instead of bare filenames.\"\n\tfi\nfi\n\ndebug \"command: {$command}\"\ndebug \"quiet: {$quiet}\"\ndebug \"revs: {$revs}\"\ndebug \"dir: {$dir}\"\ndebug \"opts: {$*}\"\ndebug\n\ncache_setup()\n{\n\tcachedir=\"$GIT_DIR/subtree-cache/$$\"\n\trm -rf \"$cachedir\" || die \"Can't delete old cachedir: $cachedir\"\n\tmkdir -p \"$cachedir\" || die \"Can't create new cachedir: $cachedir\"\n\tdebug \"Using cachedir: $cachedir\" >&2\n}\n\ncache_get()\n{\n\tfor oldrev in $*; do\n\t\tif [ -r \"$cachedir/$oldrev\" ]; then\n\t\t\tread newrev <\"$cachedir/$oldrev\"\n\t\t\techo $newrev\n\t\tfi\n\tdone\n}\n\ncache_set()\n{\n\toldrev=\"$1\"\n\tnewrev=\"$2\"\n\tif [ \"$oldrev\" != \"latest_old\" \\\n\t     -a \"$oldrev\" != \"latest_new\" \\\n\t     -a -e \"$cachedir/$oldrev\" ]; then\n\t\tdie \"cache for $oldrev already exists!\"\n\tfi\n\techo \"$newrev\" >\"$cachedir/$oldrev\"\n}\n\nrev_exists()\n{\n\tif git rev-parse \"$1\" >/dev/null 2>&1; then\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi\n}\n\nrev_is_descendant_of_branch()\n{\n\tnewrev=\"$1\"\n\tbranch=\"$2\"\n\tbranch_hash=$(git rev-parse $branch)\n\tmatch=$(git rev-list -1 $branch_hash ^$newrev)\n\n\tif [ -z \"$match\" ]; then\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi\n}\n\n# if a commit doesn't have a parent, this might not work.  But we only want\n# to remove the parent from the rev-list, and since it doesn't exist, it won't\n# be there anyway, so do nothing in that case.\ntry_remove_previous()\n{\n\tif rev_exists \"$1^\"; then\n\t\techo \"^$1^\"\n\tfi\n}\n\nfind_latest_squash()\n{\n\tdebug \"Looking for latest squash ($dir)...\"\n\tdir=\"$1\"\n\tsq=\n\tmain=\n\tsub=\n\tgit log --grep=\"^git-subtree-dir: $dir/*\\$\" \\\n\t\t--pretty=format:'START %H%n%s%n%n%b%nEND%n' HEAD |\n\twhile read a b junk; do\n\t\tdebug \"$a $b $junk\"\n\t\tdebug \"{{$sq/$main/$sub}}\"\n\t\tcase \"$a\" in\n\t\t\tSTART) sq=\"$b\" ;;\n\t\t\tgit-subtree-mainline:) main=\"$b\" ;;\n\t\t\tgit-subtree-split:) sub=\"$b\" ;;\n\t\t\tEND)\n\t\t\t\tif [ -n \"$sub\" ]; then\n\t\t\t\t\tif [ -n \"$main\" ]; then\n\t\t\t\t\t\t# a rejoin commit?\n\t\t\t\t\t\t# Pretend its sub was a squash.\n\t\t\t\t\t\tsq=\"$sub\"\n\t\t\t\t\tfi\n\t\t\t\t\tdebug \"Squash found: $sq $sub\"\n\t\t\t\t\techo \"$sq\" \"$sub\"\n\t\t\t\t\tbreak\n\t\t\t\tfi\n\t\t\t\tsq=\n\t\t\t\tmain=\n\t\t\t\tsub=\n\t\t\t\t;;\n\t\tesac\n\tdone\n}\n\nfind_existing_splits()\n{\n\tdebug \"Looking for prior splits...\"\n\tdir=\"$1\"\n\trevs=\"$2\"\n\tmain=\n\tsub=\n\tgit log --grep=\"^git-subtree-dir: $dir/*\\$\" \\\n\t\t--pretty=format:'START %H%n%s%n%n%b%nEND%n' $revs |\n\twhile read a b junk; do\n\t\tcase \"$a\" in\n\t\t\tSTART) sq=\"$b\" ;;\n\t\t\tgit-subtree-mainline:) main=\"$b\" ;;\n\t\t\tgit-subtree-split:) sub=\"$b\" ;;\n\t\t\tEND)\n\t\t\t\tdebug \"  Main is: '$main'\"\n\t\t\t\tif [ -z \"$main\" -a -n \"$sub\" ]; then\n\t\t\t\t\t# squash commits refer to a subtree\n\t\t\t\t\tdebug \"  Squash: $sq from $sub\"\n\t\t\t\t\tcache_set \"$sq\" \"$sub\"\n\t\t\t\tfi\n\t\t\t\tif [ -n \"$main\" -a -n \"$sub\" ]; then\n\t\t\t\t\tdebug \"  Prior: $main -> $sub\"\n\t\t\t\t\tcache_set $main $sub\n\t\t\t\t\ttry_remove_previous \"$main\"\n\t\t\t\t\ttry_remove_previous \"$sub\"\n\t\t\t\tfi\n\t\t\t\tmain=\n\t\t\t\tsub=\n\t\t\t\t;;\n\t\tesac\n\tdone\n}\n\ncopy_commit()\n{\n\t# We're going to set some environment vars here, so\n\t# do it in a subshell to get rid of them safely later\n\tdebug copy_commit \"{$1}\" \"{$2}\" \"{$3}\"\n\tgit log -1 --pretty=format:'%an%n%ae%n%ad%n%cn%n%ce%n%cd%n%s%n%n%b' \"$1\" |\n\t(\n\t\tread GIT_AUTHOR_NAME\n\t\tread GIT_AUTHOR_EMAIL\n\t\tread GIT_AUTHOR_DATE\n\t\tread GIT_COMMITTER_NAME\n\t\tread GIT_COMMITTER_EMAIL\n\t\tread GIT_COMMITTER_DATE\n\t\texport  GIT_AUTHOR_NAME \\\n\t\t\tGIT_AUTHOR_EMAIL \\\n\t\t\tGIT_AUTHOR_DATE \\\n\t\t\tGIT_COMMITTER_NAME \\\n\t\t\tGIT_COMMITTER_EMAIL \\\n\t\t\tGIT_COMMITTER_DATE\n\t\t(echo -n \"$annotate\"; cat ) |\n\t\tgit commit-tree \"$2\" $3  # reads the rest of stdin\n\t) || die \"Can't copy commit $1\"\n}\n\nadd_msg()\n{\n\tdir=\"$1\"\n\tlatest_old=\"$2\"\n\tlatest_new=\"$3\"\n\tif [ -n \"$message\" ]; then\n\t\tcommit_message=\"$message\"\n\telse\n\t\tcommit_message=\"Add '$dir/' from commit '$latest_new'\"\n\tfi\n\tcat <<-EOF\n\t\t$commit_message\n\t\t\n\t\tgit-subtree-dir: $dir\n\t\tgit-subtree-mainline: $latest_old\n\t\tgit-subtree-split: $latest_new\n\tEOF\n}\n\nadd_squashed_msg()\n{\n\tif [ -n \"$message\" ]; then\n\t\techo \"$message\"\n\telse\n\t\techo \"Merge commit '$1' as '$2'\"\n\tfi\n}\n\nrejoin_msg()\n{\n\tdir=\"$1\"\n\tlatest_old=\"$2\"\n\tlatest_new=\"$3\"\n\tif [ -n \"$message\" ]; then\n\t\tcommit_message=\"$message\"\n\telse\n\t\tcommit_message=\"Split '$dir/' into commit '$latest_new'\"\n\tfi\n\tcat <<-EOF\n\t\t$commit_message\n\t\t\n\t\tgit-subtree-dir: $dir\n\t\tgit-subtree-mainline: $latest_old\n\t\tgit-subtree-split: $latest_new\n\tEOF\n}\n\nsquash_msg()\n{\n\tdir=\"$1\"\n\toldsub=\"$2\"\n\tnewsub=\"$3\"\n\tnewsub_short=$(git rev-parse --short \"$newsub\")\n\t\n\tif [ -n \"$oldsub\" ]; then\n\t\toldsub_short=$(git rev-parse --short \"$oldsub\")\n\t\techo \"Squashed '$dir/' changes from $oldsub_short..$newsub_short\"\n\t\techo\n\t\tgit log --pretty=tformat:'%h %s' \"$oldsub..$newsub\"\n\t\tgit log --pretty=tformat:'REVERT: %h %s' \"$newsub..$oldsub\"\n\telse\n\t\techo \"Squashed '$dir/' content from commit $newsub_short\"\n\tfi\n\t\n\techo\n\techo \"git-subtree-dir: $dir\"\n\techo \"git-subtree-split: $newsub\"\n}\n\ntoptree_for_commit()\n{\n\tcommit=\"$1\"\n\tgit log -1 --pretty=format:'%T' \"$commit\" -- || exit $?\n}\n\nsubtree_for_commit()\n{\n\tcommit=\"$1\"\n\tdir=\"$2\"\n\tgit ls-tree \"$commit\" -- \"$dir\" |\n\twhile read mode type tree name; do\n\t\tassert [ \"$name\" = \"$dir\" ]\n\t\tassert [ \"$type\" = \"tree\" ]\n\t\techo $tree\n\t\tbreak\n\tdone\n}\n\ntree_changed()\n{\n\ttree=$1\n\tshift\n\tif [ $# -ne 1 ]; then\n\t\treturn 0   # weird parents, consider it changed\n\telse\n\t\tptree=$(toptree_for_commit $1)\n\t\tif [ \"$ptree\" != \"$tree\" ]; then\n\t\t\treturn 0   # changed\n\t\telse\n\t\t\treturn 1   # not changed\n\t\tfi\n\tfi\n}\n\nnew_squash_commit()\n{\n\told=\"$1\"\n\toldsub=\"$2\"\n\tnewsub=\"$3\"\n\ttree=$(toptree_for_commit $newsub) || exit $?\n\tif [ -n \"$old\" ]; then\n\t\tsquash_msg \"$dir\" \"$oldsub\" \"$newsub\" | \n\t\t\tgit commit-tree \"$tree\" -p \"$old\" || exit $?\n\telse\n\t\tsquash_msg \"$dir\" \"\" \"$newsub\" |\n\t\t\tgit commit-tree \"$tree\" || exit $?\n\tfi\n}\n\ncopy_or_skip()\n{\n\trev=\"$1\"\n\ttree=\"$2\"\n\tnewparents=\"$3\"\n\tassert [ -n \"$tree\" ]\n\n\tidentical=\n\tnonidentical=\n\tp=\n\tgotparents=\n\tfor parent in $newparents; do\n\t\tptree=$(toptree_for_commit $parent) || exit $?\n\t\t[ -z \"$ptree\" ] && continue\n\t\tif [ \"$ptree\" = \"$tree\" ]; then\n\t\t\t# an identical parent could be used in place of this rev.\n\t\t\tidentical=\"$parent\"\n\t\telse\n\t\t\tnonidentical=\"$parent\"\n\t\tfi\n\t\t\n\t\t# sometimes both old parents map to the same newparent;\n\t\t# eliminate duplicates\n\t\tis_new=1\n\t\tfor gp in $gotparents; do\n\t\t\tif [ \"$gp\" = \"$parent\" ]; then\n\t\t\t\tis_new=\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\tif [ -n \"$is_new\" ]; then\n\t\t\tgotparents=\"$gotparents $parent\"\n\t\t\tp=\"$p -p $parent\"\n\t\tfi\n\tdone\n\t\n\tif [ -n \"$identical\" ]; then\n\t\techo $identical\n\telse\n\t\tcopy_commit $rev $tree \"$p\" || exit $?\n\tfi\n}\n\nensure_clean()\n{\n\tif ! git diff-index HEAD --exit-code --quiet; then\n\t\tdie \"Working tree has modifications.  Cannot add.\"\n\tfi\n\tif ! git diff-index --cached HEAD --exit-code --quiet; then\n\t\tdie \"Index has modifications.  Cannot add.\"\n\tfi\n}\n\ncmd_add()\n{\n\tif [ -e \"$dir\" ]; then\n\t\tdie \"'$dir' already exists.  Cannot add.\"\n\tfi\n\tensure_clean\n\t\n\tset -- $revs\n\tif [ $# -ne 1 ]; then\n\t\tdie \"You must provide exactly one revision.  Got: '$revs'\"\n\tfi\n\trev=\"$1\"\n\t\n\tdebug \"Adding $dir as '$rev'...\"\n\tgit read-tree --prefix=\"$dir\" $rev || exit $?\n\tgit checkout -- \"$dir\" || exit $?\n\ttree=$(git write-tree) || exit $?\n\t\n\theadrev=$(git rev-parse HEAD) || exit $?\n\tif [ -n \"$headrev\" -a \"$headrev\" != \"$rev\" ]; then\n\t\theadp=\"-p $headrev\"\n\telse\n\t\theadp=\n\tfi\n\t\n\tif [ -n \"$squash\" ]; then\n\t\trev=$(new_squash_commit \"\" \"\" \"$rev\") || exit $?\n\t\tcommit=$(add_squashed_msg \"$rev\" \"$dir\" |\n\t\t\t git commit-tree $tree $headp -p \"$rev\") || exit $?\n\telse\n\t\tcommit=$(add_msg \"$dir\" \"$headrev\" \"$rev\" |\n\t\t\t git commit-tree $tree $headp -p \"$rev\") || exit $?\n\tfi\n\tgit reset \"$commit\" || exit $?\n\t\n\tsay \"Added dir '$dir'\"\n}\n\ncmd_split()\n{\n\tdebug \"Splitting $dir...\"\n\tcache_setup || exit $?\n\t\n\tif [ -n \"$onto\" ]; then\n\t\tdebug \"Reading history for --onto=$onto...\"\n\t\tgit rev-list $onto |\n\t\twhile read rev; do\n\t\t\t# the 'onto' history is already just the subdir, so\n\t\t\t# any parent we find there can be used verbatim\n\t\t\tdebug \"  cache: $rev\"\n\t\t\tcache_set $rev $rev\n\t\tdone\n\tfi\n\t\n\tif [ -n \"$ignore_joins\" ]; then\n\t\tunrevs=\n\telse\n\t\tunrevs=\"$(find_existing_splits \"$dir\" \"$revs\")\"\n\tfi\n\t\n\t# We can't restrict rev-list to only $dir here, because some of our\n\t# parents have the $dir contents the root, and those won't match.\n\t# (and rev-list --follow doesn't seem to solve this)\n\tgrl='git rev-list --reverse --parents $revs $unrevs'\n\trevmax=$(eval \"$grl\" | wc -l)\n\trevcount=0\n\tcreatecount=0\n\teval \"$grl\" |\n\twhile read rev parents; do\n\t\trevcount=$(($revcount + 1))\n\t\tsay -n \"$revcount/$revmax ($createcount)\r\"\n\t\tdebug \"Processing commit: $rev\"\n\t\texists=$(cache_get $rev)\n\t\tif [ -n \"$exists\" ]; then\n\t\t\tdebug \"  prior: $exists\"\n\t\t\tcontinue\n\t\tfi\n\t\tcreatecount=$(($createcount + 1))\n\t\tdebug \"  parents: $parents\"\n\t\tnewparents=$(cache_get $parents)\n\t\tdebug \"  newparents: $newparents\"\n\t\t\n\t\ttree=$(subtree_for_commit $rev \"$dir\")\n\t\tdebug \"  tree is: $tree\"\n\t\t\n\t\t# ugly.  is there no better way to tell if this is a subtree\n\t\t# vs. a mainline commit?  Does it matter?\n\t\tif [ -z $tree ]; then\n\t\t\tcache_set $rev $rev\n\t\t\tcontinue\n\t\tfi\n\n\t\tnewrev=$(copy_or_skip \"$rev\" \"$tree\" \"$newparents\") || exit $?\n\t\tdebug \"  newrev is: $newrev\"\n\t\tcache_set $rev $newrev\n\t\tcache_set latest_new $newrev\n\t\tcache_set latest_old $rev\n\tdone || exit $?\n\tlatest_new=$(cache_get latest_new)\n\tif [ -z \"$latest_new\" ]; then\n\t\tdie \"No new revisions were found\"\n\tfi\n\t\n\tif [ -n \"$rejoin\" ]; then\n\t\tdebug \"Merging split branch into HEAD...\"\n\t\tlatest_old=$(cache_get latest_old)\n\t\tgit merge -s ours \\\n\t\t\t-m \"$(rejoin_msg $dir $latest_old $latest_new)\" \\\n\t\t\t$latest_new >&2 || exit $?\n\tfi\n\tif [ -n \"$branch\" ]; then\n\t\tif rev_exists \"refs/heads/$branch\"; then\n\t\t\tif ! rev_is_descendant_of_branch $latest_new $branch; then\n\t\t\t\tdie \"Branch '$branch' is not an ancestor of commit '$latest_new'.\"\n\t\t\tfi\n\t\t\taction='Updated'\n\t\telse\n\t\t\taction='Created'\n\t\tfi\n\t\tgit update-ref -m 'subtree split' \"refs/heads/$branch\" $latest_new || exit $?\n\t\tsay \"$action branch '$branch'\"\n\tfi\n\techo $latest_new\n\texit 0\n}\n\ncmd_merge()\n{\n\tensure_clean\n\t\n\tset -- $revs\n\tif [ $# -ne 1 ]; then\n\t\tdie \"You must provide exactly one revision.  Got: '$revs'\"\n\tfi\n\trev=\"$1\"\n\t\n\tif [ -n \"$squash\" ]; then\n\t\tfirst_split=\"$(find_latest_squash \"$dir\")\"\n\t\tif [ -z \"$first_split\" ]; then\n\t\t\tdie \"Can't squash-merge: '$dir' was never added.\"\n\t\tfi\n\t\tset $first_split\n\t\told=$1\n\t\tsub=$2\n\t\tif [ \"$sub\" = \"$rev\" ]; then\n\t\t\tsay \"Subtree is already at commit $rev.\"\n\t\t\texit 0\n\t\tfi\n\t\tnew=$(new_squash_commit \"$old\" \"$sub\" \"$rev\") || exit $?\n\t\tdebug \"New squash commit: $new\"\n\t\trev=\"$new\"\n\tfi\n\t\n\tif [ -n \"$message\" ]; then\n\t\tgit merge -s subtree --message=\"$message\" $rev\n\telse\n\t\tgit merge -s subtree $rev\n\tfi\n}\n\ncmd_pull()\n{\n\tensure_clean\n\tgit fetch \"$@\" || exit $?\n\trevs=FETCH_HEAD\n\tcmd_merge\n}\n\n\"cmd_$command\" \"$@\"\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "009c0db9bc3c92607d942f5fe858eeee0603b039",
  "sha1_ok": true,
  "size": 12948
}
