{
  "content": {
    "base64": "I2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAianNvbi13cml0ZXIuaCIKCnZvaWQgandfaW5pdChzdHJ1Y3QganNvbl93cml0ZXIgKmp3KQp7CglzdHJ1Y3QganNvbl93cml0ZXIgYmxhbmsgPSBKU09OX1dSSVRFUl9JTklUOwoJbWVtY3B5KGp3LCAmYmxhbmssIHNpemVvZigqancpKTs7Cn0KCnZvaWQgandfcmVsZWFzZShzdHJ1Y3QganNvbl93cml0ZXIgKmp3KQp7CglzdHJidWZfcmVsZWFzZSgmanctPmpzb24pOwoJc3RyYnVmX3JlbGVhc2UoJmp3LT5vcGVuX3N0YWNrKTsKfQoKLyoKICogQXBwZW5kIEpTT04tcXVvdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIHN0cmluZyB0byAnb3V0Jy4KICovCnN0YXRpYyB2b2lkIGFwcGVuZF9xdW90ZWRfc3RyaW5nKHN0cnVjdCBzdHJidWYgKm91dCwgY29uc3QgY2hhciAqaW4pCnsKCXVuc2lnbmVkIGNoYXIgYzsKCglzdHJidWZfYWRkY2gob3V0LCAnIicpOwoJd2hpbGUgKChjID0gKmluKyspICE9ICdcMCcpIHsKCQlpZiAoYyA9PSAnIicpCgkJCXN0cmJ1Zl9hZGRzdHIob3V0LCAiXFxcIiIpOwoJCWVsc2UgaWYgKGMgPT0gJ1xcJykKCQkJc3RyYnVmX2FkZHN0cihvdXQsICJcXFxcIik7CgkJZWxzZSBpZiAoYyA9PSAnXG4nKQoJCQlzdHJidWZfYWRkc3RyKG91dCwgIlxcbiIpOwoJCWVsc2UgaWYgKGMgPT0gJ1xyJykKCQkJc3RyYnVmX2FkZHN0cihvdXQsICJcXHIiKTsKCQllbHNlIGlmIChjID09ICdcdCcpCgkJCXN0cmJ1Zl9hZGRzdHIob3V0LCAiXFx0Iik7CgkJZWxzZSBpZiAoYyA9PSAnXGYnKQoJCQlzdHJidWZfYWRkc3RyKG91dCwgIlxcZiIpOwoJCWVsc2UgaWYgKGMgPT0gJ1xiJykKCQkJc3RyYnVmX2FkZHN0cihvdXQsICJcXGIiKTsKCQllbHNlIGlmIChjIDwgMHgyMCkKCQkJc3RyYnVmX2FkZGYob3V0LCAiXFx1JTA0eCIsIGMpOwoJCWVsc2UKCQkJc3RyYnVmX2FkZGNoKG91dCwgYyk7Cgl9CglzdHJidWZfYWRkY2gob3V0LCAnIicpOwp9CgpzdGF0aWMgdm9pZCBpbmRlbnRfcHJldHR5KHN0cnVjdCBqc29uX3dyaXRlciAqancpCnsKCWludCBrOwoKCWZvciAoayA9IDA7IGsgPCBqdy0+b3Blbl9zdGFjay5sZW47IGsrKykKCQlzdHJidWZfYWRkc3RyKCZqdy0+anNvbiwgIiAgIik7Cn0KCi8qCiAqIEJlZ2luIGFuIG9iamVjdCBvciBhcnJheSAoZWl0aGVyIHRvcC1sZXZlbCBvciBuZXN0ZWQgd2l0aGluIHRoZSBjdXJyZW50bHkKICogb3BlbiBvYmplY3Qgb3IgYXJyYXkpLgogKi8Kc3RhdGljIHZvaWQgYmVnaW4oc3RydWN0IGpzb25fd3JpdGVyICpqdywgY2hhciBjaF9vcGVuLCBpbnQgcHJldHR5KQp7Cglqdy0+cHJldHR5ID0gcHJldHR5OwoKCXN0cmJ1Zl9hZGRjaCgmanctPmpzb24sIGNoX29wZW4pOwoKCXN0cmJ1Zl9hZGRjaCgmanctPm9wZW5fc3RhY2ssIGNoX29wZW4pOwoJanctPm5lZWRfY29tbWEgPSAwOwp9CgovKgogKiBBc3NlcnQgdGhhdCB0aGUgdG9wIG9mIHRoZSBvcGVuLXN0YWNrIGlzIGFuIG9iamVjdC4KICovCnN0YXRpYyB2b2lkIGFzc2VydF9pbl9vYmplY3QoY29uc3Qgc3RydWN0IGpzb25fd3JpdGVyICpqdywgY29uc3QgY2hhciAqa2V5KQp7CglpZiAoIWp3LT5vcGVuX3N0YWNrLmxlbikKCQlCVUcoImpzb24td3JpdGVyOiBvYmplY3Q6IG1pc3Npbmcgandfb2JqZWN0X2JlZ2luKCk6ICclcyciLCBrZXkpOwoJaWYgKGp3LT5vcGVuX3N0YWNrLmJ1Zltqdy0+b3Blbl9zdGFjay5sZW4gLSAxXSAhPSAneycpCgkJQlVHKCJqc29uLXdyaXRlcjogb2JqZWN0OiBub3QgaW4gb2JqZWN0OiAnJXMnIiwga2V5KTsKfQoKLyoKICogQXNzZXJ0IHRoYXQgdGhlIHRvcCBvZiB0aGUgb3Blbi1zdGFjayBpcyBhbiBhcnJheS4KICovCnN0YXRpYyB2b2lkIGFzc2VydF9pbl9hcnJheShjb25zdCBzdHJ1Y3QganNvbl93cml0ZXIgKmp3KQp7CglpZiAoIWp3LT5vcGVuX3N0YWNrLmxlbikKCQlCVUcoImpzb24td3JpdGVyOiBhcnJheTogbWlzc2luZyBqd19hcnJheV9iZWdpbigpIik7CglpZiAoanctPm9wZW5fc3RhY2suYnVmW2p3LT5vcGVuX3N0YWNrLmxlbiAtIDFdICE9ICdbJykKCQlCVUcoImpzb24td3JpdGVyOiBhcnJheTogbm90IGluIGFycmF5Iik7Cn0KCi8qCiAqIEFkZCBjb21tYSBpZiB3ZSBoYXZlIGFscmVhZHkgc2VlbiBhIG1lbWJlciBhdCB0aGlzIGxldmVsLgogKi8Kc3RhdGljIHZvaWQgbWF5YmVfYWRkX2NvbW1hKHN0cnVjdCBqc29uX3dyaXRlciAqancpCnsKCWlmIChqdy0+bmVlZF9jb21tYSkKCQlzdHJidWZfYWRkY2goJmp3LT5qc29uLCAnLCcpOwoJZWxzZQoJCWp3LT5uZWVkX2NvbW1hID0gMTsKfQoKc3RhdGljIHZvaWQgZm10X2RvdWJsZShzdHJ1Y3QganNvbl93cml0ZXIgKmp3LCBpbnQgcHJlY2lzaW9uLAoJCQkgICAgICBkb3VibGUgdmFsdWUpCnsKCWlmIChwcmVjaXNpb24gPCAwKSB7CgkJc3RyYnVmX2FkZGYoJmp3LT5qc29uLCAiJWYiLCB2YWx1ZSk7Cgl9IGVsc2UgewoJCXN0cnVjdCBzdHJidWYgZm10ID0gU1RSQlVGX0lOSVQ7CgkJc3RyYnVmX2FkZGYoJmZtdCwgIiUlLiVkZiIsIHByZWNpc2lvbik7CgkJc3RyYnVmX2FkZGYoJmp3LT5qc29uLCBmbXQuYnVmLCB2YWx1ZSk7CgkJc3RyYnVmX3JlbGVhc2UoJmZtdCk7Cgl9Cn0KCnN0YXRpYyB2b2lkIG9iamVjdF9jb21tb24oc3RydWN0IGpzb25fd3JpdGVyICpqdywgY29uc3QgY2hhciAqa2V5KQp7Cglhc3NlcnRfaW5fb2JqZWN0KGp3LCBrZXkpOwoJbWF5YmVfYWRkX2NvbW1hKGp3KTsKCglpZiAoanctPnByZXR0eSkgewoJCXN0cmJ1Zl9hZGRjaCgmanctPmpzb24sICdcbicpOwoJCWluZGVudF9wcmV0dHkoancpOwoJfQoKCWFwcGVuZF9xdW90ZWRfc3RyaW5nKCZqdy0+anNvbiwga2V5KTsKCXN0cmJ1Zl9hZGRjaCgmanctPmpzb24sICc6Jyk7CglpZiAoanctPnByZXR0eSkKCQlzdHJidWZfYWRkY2goJmp3LT5qc29uLCAnICcpOwp9CgpzdGF0aWMgdm9pZCBhcnJheV9jb21tb24oc3RydWN0IGpzb25fd3JpdGVyICpqdykKewoJYXNzZXJ0X2luX2FycmF5KGp3KTsKCW1heWJlX2FkZF9jb21tYShqdyk7CgoJaWYgKGp3LT5wcmV0dHkpIHsKCQlzdHJidWZfYWRkY2goJmp3LT5qc29uLCAnXG4nKTsKCQlpbmRlbnRfcHJldHR5KGp3KTsKCX0KfQoKLyoKICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIEpTT04gb2JqZWN0IG9yIEpTT04gYXJyYXkgaGFzIGJlZW4gcHJvcGVybHkKICogdGVybWluYXRlZC4gIChIYXMgY2xvc2luZyBicmFja2V0LikKICovCnN0YXRpYyB2b2lkIGFzc2VydF9pc190ZXJtaW5hdGVkKGNvbnN0IHN0cnVjdCBqc29uX3dyaXRlciAqancpCnsKCWlmIChqdy0+b3Blbl9zdGFjay5sZW4pCgkJQlVHKCJqc29uLXdyaXRlcjogb2JqZWN0OiBtaXNzaW5nIGp3X2VuZCgpOiAnJXMnIiwKCQkgICAganctPmpzb24uYnVmKTsKfQoKdm9pZCBqd19vYmplY3RfYmVnaW4oc3RydWN0IGpzb25fd3JpdGVyICpqdywgaW50IHByZXR0eSkKewoJYmVnaW4oancsICd7JywgcHJldHR5KTsKfQoKdm9pZCBqd19vYmplY3Rfc3RyaW5nKHN0cnVjdCBqc29uX3dyaXRlciAqancsIGNvbnN0IGNoYXIgKmtleSwgY29uc3QgY2hhciAqdmFsdWUpCnsKCW9iamVjdF9jb21tb24oancsIGtleSk7CglhcHBlbmRfcXVvdGVkX3N0cmluZygmanctPmpzb24sIHZhbHVlKTsKfQoKdm9pZCBqd19vYmplY3RfaW50bWF4KHN0cnVjdCBqc29uX3dyaXRlciAqancsIGNvbnN0IGNoYXIgKmtleSwgaW50bWF4X3QgdmFsdWUpCnsKCW9iamVjdF9jb21tb24oancsIGtleSk7CglzdHJidWZfYWRkZigmanctPmpzb24sICIlIlBSSWRNQVgsIHZhbHVlKTsKfQoKdm9pZCBqd19vYmplY3RfZG91YmxlKHN0cnVjdCBqc29uX3dyaXRlciAqancsIGNvbnN0IGNoYXIgKmtleSwgaW50IHByZWNpc2lvbiwKCQkgICAgICBkb3VibGUgdmFsdWUpCnsKCW9iamVjdF9jb21tb24oancsIGtleSk7CglmbXRfZG91YmxlKGp3LCBwcmVjaXNpb24sIHZhbHVlKTsKfQoKdm9pZCBqd19vYmplY3RfdHJ1ZShzdHJ1Y3QganNvbl93cml0ZXIgKmp3LCBjb25zdCBjaGFyICprZXkpCnsKCW9iamVjdF9jb21tb24oancsIGtleSk7CglzdHJidWZfYWRkc3RyKCZqdy0+anNvbiwgInRydWUiKTsKfQoKdm9pZCBqd19vYmplY3RfZmFsc2Uoc3RydWN0IGpzb25fd3JpdGVyICpqdywgY29uc3QgY2hhciAqa2V5KQp7CglvYmplY3RfY29tbW9uKGp3LCBrZXkpOwoJc3RyYnVmX2FkZHN0cigmanctPmpzb24sICJmYWxzZSIpOwp9Cgp2b2lkIGp3X29iamVjdF9ib29sKHN0cnVjdCBqc29uX3dyaXRlciAqancsIGNvbnN0IGNoYXIgKmtleSwgaW50IHZhbHVlKQp7CglpZiAodmFsdWUpCgkJandfb2JqZWN0X3RydWUoancsIGtleSk7CgllbHNlCgkJandfb2JqZWN0X2ZhbHNlKGp3LCBrZXkpOwp9Cgp2b2lkIGp3X29iamVjdF9udWxsKHN0cnVjdCBqc29uX3dyaXRlciAqancsIGNvbnN0IGNoYXIgKmtleSkKewoJb2JqZWN0X2NvbW1vbihqdywga2V5KTsKCXN0cmJ1Zl9hZGRzdHIoJmp3LT5qc29uLCAibnVsbCIpOwp9CgpzdGF0aWMgdm9pZCBpbmNyZWFzZV9pbmRlbnQoc3RydWN0IHN0cmJ1ZiAqc2IsCgkJCSAgICBjb25zdCBzdHJ1Y3QganNvbl93cml0ZXIgKmp3LAoJCQkgICAgaW50IGluZGVudCkKewoJaW50IGs7CgoJc3RyYnVmX3Jlc2V0KHNiKTsKCWZvciAoayA9IDA7IGsgPCBqdy0+anNvbi5sZW47IGsrKykgewoJCWNoYXIgY2ggPSBqdy0+anNvbi5idWZba107CgkJc3RyYnVmX2FkZGNoKHNiLCBjaCk7CgkJaWYgKGNoID09ICdcbicpCgkJCXN0cmJ1Zl9hZGRjaGFycyhzYiwgJyAnLCBpbmRlbnQpOwoJfQp9CgpzdGF0aWMgdm9pZCBraWxsX2luZGVudChzdHJ1Y3Qgc3RyYnVmICpzYiwKCQkJY29uc3Qgc3RydWN0IGpzb25fd3JpdGVyICpqdykKewoJaW50IGs7CglpbnQgZWF0X2l0ID0gMDsKCglzdHJidWZfcmVzZXQoc2IpOwoJZm9yIChrID0gMDsgayA8IGp3LT5qc29uLmxlbjsgaysrKSB7CgkJY2hhciBjaCA9IGp3LT5qc29uLmJ1ZltrXTsKCQlpZiAoZWF0X2l0ICYmIGNoID09ICcgJykKCQkJY29udGludWU7CgkJaWYgKGNoID09ICdcbicpIHsKCQkJZWF0X2l0ID0gMTsKCQkJY29udGludWU7CgkJfQoJCWVhdF9pdCA9IDA7CgkJc3RyYnVmX2FkZGNoKHNiLCBjaCk7Cgl9Cn0KCnN0YXRpYyB2b2lkIGFwcGVuZF9zdWJfancoc3RydWN0IGpzb25fd3JpdGVyICpqdywKCQkJICBjb25zdCBzdHJ1Y3QganNvbl93cml0ZXIgKnZhbHVlKQp7CgkvKgoJICogSWYgYm90aCBhcmUgcHJldHR5LCBpbmNyZWFzZSB0aGUgaW5kZW50YXRpb24gb2YgdGhlIHN1Yl9qdwoJICogdG8gYmV0dGVyIGZpdCB1bmRlciB0aGUgc3VwZXIuCgkgKgoJICogSWYgdGhlIHN1cGVyIGlzIHByZXR0eSwgYnV0IHRoZSBzdWJfancgaXMgY29tcGFjdCwgbGVhdmUgdGhlCgkgKiBzdWJfancgY29tcGFjdC4gIChXZSBkb24ndCB3YW50IHRvIHBhcnNlIGFuZCByZWJ1aWxkIHRoZSBzdWJfancKCSAqIGZvciB0aGlzIGRlYnVnLWlzaCBmZWF0dXJlLikKCSAqCgkgKiBJZiB0aGUgc3VwZXIgaXMgY29tcGFjdCwgYW5kIHRoZSBzdWJfancgaXMgcHJldHR5LCBjb252ZXJ0CgkgKiB0aGUgc3ViX2p3IHRvIGNvbXBhY3QuCgkgKgoJICogSWYgYm90aCBhcmUgY29tcGFjdCwga2VlcCB0aGUgc3ViX2p3IGNvbXBhY3QuCgkgKi8KCWlmIChqdy0+cHJldHR5ICYmIGp3LT5vcGVuX3N0YWNrLmxlbiAmJiB2YWx1ZS0+cHJldHR5KSB7CgkJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJCWluY3JlYXNlX2luZGVudCgmc2IsIHZhbHVlLCBqdy0+b3Blbl9zdGFjay5sZW4gKiAyKTsKCQlzdHJidWZfYWRkYnVmKCZqdy0+anNvbiwgJnNiKTsKCQlzdHJidWZfcmVsZWFzZSgmc2IpOwoJCXJldHVybjsKCX0KCWlmICghanctPnByZXR0eSAmJiB2YWx1ZS0+cHJldHR5KSB7CgkJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJCWtpbGxfaW5kZW50KCZzYiwgdmFsdWUpOwoJCXN0cmJ1Zl9hZGRidWYoJmp3LT5qc29uLCAmc2IpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZzYik7CgkJcmV0dXJuOwoJfQoKCXN0cmJ1Zl9hZGRidWYoJmp3LT5qc29uLCAmdmFsdWUtPmpzb24pOwp9CgovKgogKiBBcHBlbmQgZXhpc3RpbmcgKHByb3Blcmx5IHRlcm1pbmF0ZWQpIEpTT04gc3ViLWRhdGEgKG9iamVjdCBvciBhcnJheSkKICogYXMtaXMgb250byB0aGUgZ2l2ZW4gSlNPTiBkYXRhLgogKi8Kdm9pZCBqd19vYmplY3Rfc3ViX2p3KHN0cnVjdCBqc29uX3dyaXRlciAqancsIGNvbnN0IGNoYXIgKmtleSwKCQkgICAgICBjb25zdCBzdHJ1Y3QganNvbl93cml0ZXIgKnZhbHVlKQp7Cglhc3NlcnRfaXNfdGVybWluYXRlZCh2YWx1ZSk7CgoJb2JqZWN0X2NvbW1vbihqdywga2V5KTsKCWFwcGVuZF9zdWJfancoancsIHZhbHVlKTsKfQoKdm9pZCBqd19vYmplY3RfaW5saW5lX2JlZ2luX29iamVjdChzdHJ1Y3QganNvbl93cml0ZXIgKmp3LCBjb25zdCBjaGFyICprZXkpCnsKCW9iamVjdF9jb21tb24oancsIGtleSk7CgoJandfb2JqZWN0X2JlZ2luKGp3LCBqdy0+cHJldHR5KTsKfQoKdm9pZCBqd19vYmplY3RfaW5saW5lX2JlZ2luX2FycmF5KHN0cnVjdCBqc29uX3dyaXRlciAqancsIGNvbnN0IGNoYXIgKmtleSkKewoJb2JqZWN0X2NvbW1vbihqdywga2V5KTsKCglqd19hcnJheV9iZWdpbihqdywganctPnByZXR0eSk7Cn0KCnZvaWQgandfYXJyYXlfYmVnaW4oc3RydWN0IGpzb25fd3JpdGVyICpqdywgaW50IHByZXR0eSkKewoJYmVnaW4oancsICdbJywgcHJldHR5KTsKfQoKdm9pZCBqd19hcnJheV9zdHJpbmcoc3RydWN0IGpzb25fd3JpdGVyICpqdywgY29uc3QgY2hhciAqdmFsdWUpCnsKCWFycmF5X2NvbW1vbihqdyk7CglhcHBlbmRfcXVvdGVkX3N0cmluZygmanctPmpzb24sIHZhbHVlKTsKfQoKdm9pZCBqd19hcnJheV9pbnRtYXgoc3RydWN0IGpzb25fd3JpdGVyICpqdywgaW50bWF4X3QgdmFsdWUpCnsKCWFycmF5X2NvbW1vbihqdyk7CglzdHJidWZfYWRkZigmanctPmpzb24sICIlIlBSSWRNQVgsIHZhbHVlKTsKfQoKdm9pZCBqd19hcnJheV9kb3VibGUoc3RydWN0IGpzb25fd3JpdGVyICpqdywgaW50IHByZWNpc2lvbiwgZG91YmxlIHZhbHVlKQp7CglhcnJheV9jb21tb24oancpOwoJZm10X2RvdWJsZShqdywgcHJlY2lzaW9uLCB2YWx1ZSk7Cn0KCnZvaWQgandfYXJyYXlfdHJ1ZShzdHJ1Y3QganNvbl93cml0ZXIgKmp3KQp7CglhcnJheV9jb21tb24oancpOwoJc3RyYnVmX2FkZHN0cigmanctPmpzb24sICJ0cnVlIik7Cn0KCnZvaWQgandfYXJyYXlfZmFsc2Uoc3RydWN0IGpzb25fd3JpdGVyICpqdykKewoJYXJyYXlfY29tbW9uKGp3KTsKCXN0cmJ1Zl9hZGRzdHIoJmp3LT5qc29uLCAiZmFsc2UiKTsKfQoKdm9pZCBqd19hcnJheV9ib29sKHN0cnVjdCBqc29uX3dyaXRlciAqancsIGludCB2YWx1ZSkKewoJaWYgKHZhbHVlKQoJCWp3X2FycmF5X3RydWUoancpOwoJZWxzZQoJCWp3X2FycmF5X2ZhbHNlKGp3KTsKfQoKdm9pZCBqd19hcnJheV9udWxsKHN0cnVjdCBqc29uX3dyaXRlciAqancpCnsKCWFycmF5X2NvbW1vbihqdyk7CglzdHJidWZfYWRkc3RyKCZqdy0+anNvbiwgIm51bGwiKTsKfQoKdm9pZCBqd19hcnJheV9zdWJfancoc3RydWN0IGpzb25fd3JpdGVyICpqdywgY29uc3Qgc3RydWN0IGpzb25fd3JpdGVyICp2YWx1ZSkKewoJYXNzZXJ0X2lzX3Rlcm1pbmF0ZWQodmFsdWUpOwoKCWFycmF5X2NvbW1vbihqdyk7CglhcHBlbmRfc3ViX2p3KGp3LCB2YWx1ZSk7Cn0KCnZvaWQgandfYXJyYXlfYXJnY19hcmd2KHN0cnVjdCBqc29uX3dyaXRlciAqancsIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndikKewoJaW50IGs7CgoJZm9yIChrID0gMDsgayA8IGFyZ2M7IGsrKykKCQlqd19hcnJheV9zdHJpbmcoancsIGFyZ3Zba10pOwp9Cgp2b2lkIGp3X2FycmF5X2FyZ3Yoc3RydWN0IGpzb25fd3JpdGVyICpqdywgY29uc3QgY2hhciAqKmFyZ3YpCnsKCXdoaWxlICgqYXJndikKCQlqd19hcnJheV9zdHJpbmcoancsICphcmd2KyspOwp9Cgp2b2lkIGp3X2FycmF5X2lubGluZV9iZWdpbl9vYmplY3Qoc3RydWN0IGpzb25fd3JpdGVyICpqdykKewoJYXJyYXlfY29tbW9uKGp3KTsKCglqd19vYmplY3RfYmVnaW4oancsIGp3LT5wcmV0dHkpOwp9Cgp2b2lkIGp3X2FycmF5X2lubGluZV9iZWdpbl9hcnJheShzdHJ1Y3QganNvbl93cml0ZXIgKmp3KQp7CglhcnJheV9jb21tb24oancpOwoKCWp3X2FycmF5X2JlZ2luKGp3LCBqdy0+cHJldHR5KTsKfQoKaW50IGp3X2lzX3Rlcm1pbmF0ZWQoY29uc3Qgc3RydWN0IGpzb25fd3JpdGVyICpqdykKewoJcmV0dXJuICFqdy0+b3Blbl9zdGFjay5sZW47Cn0KCnZvaWQgandfZW5kKHN0cnVjdCBqc29uX3dyaXRlciAqancpCnsKCWNoYXIgY2hfb3BlbjsKCWludCBsZW47CgoJaWYgKCFqdy0+b3Blbl9zdGFjay5sZW4pCgkJQlVHKCJqc29uLXdyaXRlcjogdG9vIG1hbnkgandfZW5kKCk6ICclcyciLCBqdy0+anNvbi5idWYpOwoKCWxlbiA9IGp3LT5vcGVuX3N0YWNrLmxlbiAtIDE7CgljaF9vcGVuID0ganctPm9wZW5fc3RhY2suYnVmW2xlbl07CgoJc3RyYnVmX3NldGxlbigmanctPm9wZW5fc3RhY2ssIGxlbik7Cglqdy0+bmVlZF9jb21tYSA9IDE7CgoJaWYgKGp3LT5wcmV0dHkpIHsKCQlzdHJidWZfYWRkY2goJmp3LT5qc29uLCAnXG4nKTsKCQlpbmRlbnRfcHJldHR5KGp3KTsKCX0KCglpZiAoY2hfb3BlbiA9PSAneycpCgkJc3RyYnVmX2FkZGNoKCZqdy0+anNvbiwgJ30nKTsKCWVsc2UKCQlzdHJidWZfYWRkY2goJmp3LT5qc29uLCAnXScpOwp9Cg==",
    "text": "#include \"git-compat-util.h\"\n#include \"json-writer.h\"\n\nvoid jw_init(struct json_writer *jw)\n{\n\tstruct json_writer blank = JSON_WRITER_INIT;\n\tmemcpy(jw, &blank, sizeof(*jw));;\n}\n\nvoid jw_release(struct json_writer *jw)\n{\n\tstrbuf_release(&jw->json);\n\tstrbuf_release(&jw->open_stack);\n}\n\n/*\n * Append JSON-quoted version of the given string to 'out'.\n */\nstatic void append_quoted_string(struct strbuf *out, const char *in)\n{\n\tunsigned char c;\n\n\tstrbuf_addch(out, '\"');\n\twhile ((c = *in++) != '\\0') {\n\t\tif (c == '\"')\n\t\t\tstrbuf_addstr(out, \"\\\\\\\"\");\n\t\telse if (c == '\\\\')\n\t\t\tstrbuf_addstr(out, \"\\\\\\\\\");\n\t\telse if (c == '\\n')\n\t\t\tstrbuf_addstr(out, \"\\\\n\");\n\t\telse if (c == '\\r')\n\t\t\tstrbuf_addstr(out, \"\\\\r\");\n\t\telse if (c == '\\t')\n\t\t\tstrbuf_addstr(out, \"\\\\t\");\n\t\telse if (c == '\\f')\n\t\t\tstrbuf_addstr(out, \"\\\\f\");\n\t\telse if (c == '\\b')\n\t\t\tstrbuf_addstr(out, \"\\\\b\");\n\t\telse if (c < 0x20)\n\t\t\tstrbuf_addf(out, \"\\\\u%04x\", c);\n\t\telse\n\t\t\tstrbuf_addch(out, c);\n\t}\n\tstrbuf_addch(out, '\"');\n}\n\nstatic void indent_pretty(struct json_writer *jw)\n{\n\tint k;\n\n\tfor (k = 0; k < jw->open_stack.len; k++)\n\t\tstrbuf_addstr(&jw->json, \"  \");\n}\n\n/*\n * Begin an object or array (either top-level or nested within the currently\n * open object or array).\n */\nstatic void begin(struct json_writer *jw, char ch_open, int pretty)\n{\n\tjw->pretty = pretty;\n\n\tstrbuf_addch(&jw->json, ch_open);\n\n\tstrbuf_addch(&jw->open_stack, ch_open);\n\tjw->need_comma = 0;\n}\n\n/*\n * Assert that the top of the open-stack is an object.\n */\nstatic void assert_in_object(const struct json_writer *jw, const char *key)\n{\n\tif (!jw->open_stack.len)\n\t\tBUG(\"json-writer: object: missing jw_object_begin(): '%s'\", key);\n\tif (jw->open_stack.buf[jw->open_stack.len - 1] != '{')\n\t\tBUG(\"json-writer: object: not in object: '%s'\", key);\n}\n\n/*\n * Assert that the top of the open-stack is an array.\n */\nstatic void assert_in_array(const struct json_writer *jw)\n{\n\tif (!jw->open_stack.len)\n\t\tBUG(\"json-writer: array: missing jw_array_begin()\");\n\tif (jw->open_stack.buf[jw->open_stack.len - 1] != '[')\n\t\tBUG(\"json-writer: array: not in array\");\n}\n\n/*\n * Add comma if we have already seen a member at this level.\n */\nstatic void maybe_add_comma(struct json_writer *jw)\n{\n\tif (jw->need_comma)\n\t\tstrbuf_addch(&jw->json, ',');\n\telse\n\t\tjw->need_comma = 1;\n}\n\nstatic void fmt_double(struct json_writer *jw, int precision,\n\t\t\t      double value)\n{\n\tif (precision < 0) {\n\t\tstrbuf_addf(&jw->json, \"%f\", value);\n\t} else {\n\t\tstruct strbuf fmt = STRBUF_INIT;\n\t\tstrbuf_addf(&fmt, \"%%.%df\", precision);\n\t\tstrbuf_addf(&jw->json, fmt.buf, value);\n\t\tstrbuf_release(&fmt);\n\t}\n}\n\nstatic void object_common(struct json_writer *jw, const char *key)\n{\n\tassert_in_object(jw, key);\n\tmaybe_add_comma(jw);\n\n\tif (jw->pretty) {\n\t\tstrbuf_addch(&jw->json, '\\n');\n\t\tindent_pretty(jw);\n\t}\n\n\tappend_quoted_string(&jw->json, key);\n\tstrbuf_addch(&jw->json, ':');\n\tif (jw->pretty)\n\t\tstrbuf_addch(&jw->json, ' ');\n}\n\nstatic void array_common(struct json_writer *jw)\n{\n\tassert_in_array(jw);\n\tmaybe_add_comma(jw);\n\n\tif (jw->pretty) {\n\t\tstrbuf_addch(&jw->json, '\\n');\n\t\tindent_pretty(jw);\n\t}\n}\n\n/*\n * Assert that the given JSON object or JSON array has been properly\n * terminated.  (Has closing bracket.)\n */\nstatic void assert_is_terminated(const struct json_writer *jw)\n{\n\tif (jw->open_stack.len)\n\t\tBUG(\"json-writer: object: missing jw_end(): '%s'\",\n\t\t    jw->json.buf);\n}\n\nvoid jw_object_begin(struct json_writer *jw, int pretty)\n{\n\tbegin(jw, '{', pretty);\n}\n\nvoid jw_object_string(struct json_writer *jw, const char *key, const char *value)\n{\n\tobject_common(jw, key);\n\tappend_quoted_string(&jw->json, value);\n}\n\nvoid jw_object_intmax(struct json_writer *jw, const char *key, intmax_t value)\n{\n\tobject_common(jw, key);\n\tstrbuf_addf(&jw->json, \"%\"PRIdMAX, value);\n}\n\nvoid jw_object_double(struct json_writer *jw, const char *key, int precision,\n\t\t      double value)\n{\n\tobject_common(jw, key);\n\tfmt_double(jw, precision, value);\n}\n\nvoid jw_object_true(struct json_writer *jw, const char *key)\n{\n\tobject_common(jw, key);\n\tstrbuf_addstr(&jw->json, \"true\");\n}\n\nvoid jw_object_false(struct json_writer *jw, const char *key)\n{\n\tobject_common(jw, key);\n\tstrbuf_addstr(&jw->json, \"false\");\n}\n\nvoid jw_object_bool(struct json_writer *jw, const char *key, int value)\n{\n\tif (value)\n\t\tjw_object_true(jw, key);\n\telse\n\t\tjw_object_false(jw, key);\n}\n\nvoid jw_object_null(struct json_writer *jw, const char *key)\n{\n\tobject_common(jw, key);\n\tstrbuf_addstr(&jw->json, \"null\");\n}\n\nstatic void increase_indent(struct strbuf *sb,\n\t\t\t    const struct json_writer *jw,\n\t\t\t    int indent)\n{\n\tint k;\n\n\tstrbuf_reset(sb);\n\tfor (k = 0; k < jw->json.len; k++) {\n\t\tchar ch = jw->json.buf[k];\n\t\tstrbuf_addch(sb, ch);\n\t\tif (ch == '\\n')\n\t\t\tstrbuf_addchars(sb, ' ', indent);\n\t}\n}\n\nstatic void kill_indent(struct strbuf *sb,\n\t\t\tconst struct json_writer *jw)\n{\n\tint k;\n\tint eat_it = 0;\n\n\tstrbuf_reset(sb);\n\tfor (k = 0; k < jw->json.len; k++) {\n\t\tchar ch = jw->json.buf[k];\n\t\tif (eat_it && ch == ' ')\n\t\t\tcontinue;\n\t\tif (ch == '\\n') {\n\t\t\teat_it = 1;\n\t\t\tcontinue;\n\t\t}\n\t\teat_it = 0;\n\t\tstrbuf_addch(sb, ch);\n\t}\n}\n\nstatic void append_sub_jw(struct json_writer *jw,\n\t\t\t  const struct json_writer *value)\n{\n\t/*\n\t * If both are pretty, increase the indentation of the sub_jw\n\t * to better fit under the super.\n\t *\n\t * If the super is pretty, but the sub_jw is compact, leave the\n\t * sub_jw compact.  (We don't want to parse and rebuild the sub_jw\n\t * for this debug-ish feature.)\n\t *\n\t * If the super is compact, and the sub_jw is pretty, convert\n\t * the sub_jw to compact.\n\t *\n\t * If both are compact, keep the sub_jw compact.\n\t */\n\tif (jw->pretty && jw->open_stack.len && value->pretty) {\n\t\tstruct strbuf sb = STRBUF_INIT;\n\t\tincrease_indent(&sb, value, jw->open_stack.len * 2);\n\t\tstrbuf_addbuf(&jw->json, &sb);\n\t\tstrbuf_release(&sb);\n\t\treturn;\n\t}\n\tif (!jw->pretty && value->pretty) {\n\t\tstruct strbuf sb = STRBUF_INIT;\n\t\tkill_indent(&sb, value);\n\t\tstrbuf_addbuf(&jw->json, &sb);\n\t\tstrbuf_release(&sb);\n\t\treturn;\n\t}\n\n\tstrbuf_addbuf(&jw->json, &value->json);\n}\n\n/*\n * Append existing (properly terminated) JSON sub-data (object or array)\n * as-is onto the given JSON data.\n */\nvoid jw_object_sub_jw(struct json_writer *jw, const char *key,\n\t\t      const struct json_writer *value)\n{\n\tassert_is_terminated(value);\n\n\tobject_common(jw, key);\n\tappend_sub_jw(jw, value);\n}\n\nvoid jw_object_inline_begin_object(struct json_writer *jw, const char *key)\n{\n\tobject_common(jw, key);\n\n\tjw_object_begin(jw, jw->pretty);\n}\n\nvoid jw_object_inline_begin_array(struct json_writer *jw, const char *key)\n{\n\tobject_common(jw, key);\n\n\tjw_array_begin(jw, jw->pretty);\n}\n\nvoid jw_array_begin(struct json_writer *jw, int pretty)\n{\n\tbegin(jw, '[', pretty);\n}\n\nvoid jw_array_string(struct json_writer *jw, const char *value)\n{\n\tarray_common(jw);\n\tappend_quoted_string(&jw->json, value);\n}\n\nvoid jw_array_intmax(struct json_writer *jw, intmax_t value)\n{\n\tarray_common(jw);\n\tstrbuf_addf(&jw->json, \"%\"PRIdMAX, value);\n}\n\nvoid jw_array_double(struct json_writer *jw, int precision, double value)\n{\n\tarray_common(jw);\n\tfmt_double(jw, precision, value);\n}\n\nvoid jw_array_true(struct json_writer *jw)\n{\n\tarray_common(jw);\n\tstrbuf_addstr(&jw->json, \"true\");\n}\n\nvoid jw_array_false(struct json_writer *jw)\n{\n\tarray_common(jw);\n\tstrbuf_addstr(&jw->json, \"false\");\n}\n\nvoid jw_array_bool(struct json_writer *jw, int value)\n{\n\tif (value)\n\t\tjw_array_true(jw);\n\telse\n\t\tjw_array_false(jw);\n}\n\nvoid jw_array_null(struct json_writer *jw)\n{\n\tarray_common(jw);\n\tstrbuf_addstr(&jw->json, \"null\");\n}\n\nvoid jw_array_sub_jw(struct json_writer *jw, const struct json_writer *value)\n{\n\tassert_is_terminated(value);\n\n\tarray_common(jw);\n\tappend_sub_jw(jw, value);\n}\n\nvoid jw_array_argc_argv(struct json_writer *jw, int argc, const char **argv)\n{\n\tint k;\n\n\tfor (k = 0; k < argc; k++)\n\t\tjw_array_string(jw, argv[k]);\n}\n\nvoid jw_array_argv(struct json_writer *jw, const char **argv)\n{\n\twhile (*argv)\n\t\tjw_array_string(jw, *argv++);\n}\n\nvoid jw_array_inline_begin_object(struct json_writer *jw)\n{\n\tarray_common(jw);\n\n\tjw_object_begin(jw, jw->pretty);\n}\n\nvoid jw_array_inline_begin_array(struct json_writer *jw)\n{\n\tarray_common(jw);\n\n\tjw_array_begin(jw, jw->pretty);\n}\n\nint jw_is_terminated(const struct json_writer *jw)\n{\n\treturn !jw->open_stack.len;\n}\n\nvoid jw_end(struct json_writer *jw)\n{\n\tchar ch_open;\n\tint len;\n\n\tif (!jw->open_stack.len)\n\t\tBUG(\"json-writer: too many jw_end(): '%s'\", jw->json.buf);\n\n\tlen = jw->open_stack.len - 1;\n\tch_open = jw->open_stack.buf[len];\n\n\tstrbuf_setlen(&jw->open_stack, len);\n\tjw->need_comma = 1;\n\n\tif (jw->pretty) {\n\t\tstrbuf_addch(&jw->json, '\\n');\n\t\tindent_pretty(jw);\n\t}\n\n\tif (ch_open == '{')\n\t\tstrbuf_addch(&jw->json, '}');\n\telse\n\t\tstrbuf_addch(&jw->json, ']');\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "005c820aa42e1f3c98bd2c1a376bd3a52bfc32a2",
  "sha1_ok": true,
  "size": 8689
}
