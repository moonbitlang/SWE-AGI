{
  "content": {
    "base64": "LyoKQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQwoKVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUKbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0Cmh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL29wZW4tc291cmNlL2xpY2Vuc2VzL2JzZAoqLwoKI2luY2x1ZGUgImJhc2ljcy5oIgoKdm9pZCBwdXRfYmUyNCh1aW50OF90ICpvdXQsIHVpbnQzMl90IGkpCnsKCW91dFswXSA9ICh1aW50OF90KSgoaSA+PiAxNikgJiAweGZmKTsKCW91dFsxXSA9ICh1aW50OF90KSgoaSA+PiA4KSAmIDB4ZmYpOwoJb3V0WzJdID0gKHVpbnQ4X3QpKGkgJiAweGZmKTsKfQoKdWludDMyX3QgZ2V0X2JlMjQodWludDhfdCAqaW4pCnsKCXJldHVybiAodWludDMyX3QpKGluWzBdKSA8PCAxNiB8ICh1aW50MzJfdCkoaW5bMV0pIDw8IDggfAoJICAgICAgICh1aW50MzJfdCkoaW5bMl0pOwp9Cgp2b2lkIHB1dF9iZTE2KHVpbnQ4X3QgKm91dCwgdWludDE2X3QgaSkKewoJb3V0WzBdID0gKHVpbnQ4X3QpKChpID4+IDgpICYgMHhmZik7CglvdXRbMV0gPSAodWludDhfdCkoaSAmIDB4ZmYpOwp9CgpzaXplX3QgYmluc2VhcmNoKHNpemVfdCBzeiwgaW50ICgqZikoc2l6ZV90IGssIHZvaWQgKmFyZ3MpLCB2b2lkICphcmdzKQp7CglzaXplX3QgbG8gPSAwOwoJc2l6ZV90IGhpID0gc3o7CgoJLyogSW52YXJpYW50czoKCSAqCgkgKiAgKGhpID09IHN6KSB8fCBmKGhpKSA9PSB0cnVlCgkgKiAgKGxvID09IDAgJiYgZigwKSA9PSB0cnVlKSB8fCBmaShsbykgPT0gZmFsc2UKCSAqLwoJd2hpbGUgKGhpIC0gbG8gPiAxKSB7CgkJc2l6ZV90IG1pZCA9IGxvICsgKGhpIC0gbG8pIC8gMjsKCQlpbnQgcmV0ID0gZihtaWQsIGFyZ3MpOwoJCWlmIChyZXQgPCAwKQoJCQlyZXR1cm4gc3o7CgoJCWlmIChyZXQgPiAwKQoJCQloaSA9IG1pZDsKCQllbHNlCgkJCWxvID0gbWlkOwoJfQoKCWlmIChsbykKCQlyZXR1cm4gaGk7CgoJcmV0dXJuIGYoMCwgYXJncykgPyAwIDogMTsKfQoKdm9pZCBmcmVlX25hbWVzKGNoYXIgKiphKQp7CgljaGFyICoqcDsKCWlmICghYSkgewoJCXJldHVybjsKCX0KCWZvciAocCA9IGE7ICpwOyBwKyspIHsKCQlyZWZ0YWJsZV9mcmVlKCpwKTsKCX0KCXJlZnRhYmxlX2ZyZWUoYSk7Cn0KCnNpemVfdCBuYW1lc19sZW5ndGgoY29uc3QgY2hhciAqKm5hbWVzKQp7Cgljb25zdCBjaGFyICoqcCA9IG5hbWVzOwoJd2hpbGUgKCpwKQoJCXArKzsKCXJldHVybiBwIC0gbmFtZXM7Cn0KCnZvaWQgcGFyc2VfbmFtZXMoY2hhciAqYnVmLCBpbnQgc2l6ZSwgY2hhciAqKipuYW1lc3ApCnsKCWNoYXIgKipuYW1lcyA9IE5VTEw7CglzaXplX3QgbmFtZXNfY2FwID0gMDsKCXNpemVfdCBuYW1lc19sZW4gPSAwOwoKCWNoYXIgKnAgPSBidWY7CgljaGFyICplbmQgPSBidWYgKyBzaXplOwoJd2hpbGUgKHAgPCBlbmQpIHsKCQljaGFyICpuZXh0ID0gc3RyY2hyKHAsICdcbicpOwoJCWlmIChuZXh0ICYmIG5leHQgPCBlbmQpIHsKCQkJKm5leHQgPSAwOwoJCX0gZWxzZSB7CgkJCW5leHQgPSBlbmQ7CgkJfQoJCWlmIChwIDwgbmV4dCkgewoJCQlSRUZUQUJMRV9BTExPQ19HUk9XKG5hbWVzLCBuYW1lc19sZW4gKyAxLCBuYW1lc19jYXApOwoJCQluYW1lc1tuYW1lc19sZW4rK10gPSB4c3RyZHVwKHApOwoJCX0KCQlwID0gbmV4dCArIDE7Cgl9CgoJUkVGVEFCTEVfUkVBTExPQ19BUlJBWShuYW1lcywgbmFtZXNfbGVuICsgMSk7CgluYW1lc1tuYW1lc19sZW5dID0gTlVMTDsKCSpuYW1lc3AgPSBuYW1lczsKfQoKaW50IG5hbWVzX2VxdWFsKGNvbnN0IGNoYXIgKiphLCBjb25zdCBjaGFyICoqYikKewoJc2l6ZV90IGkgPSAwOwoJZm9yICg7IGFbaV0gJiYgYltpXTsgaSsrKQoJCWlmIChzdHJjbXAoYVtpXSwgYltpXSkpCgkJCXJldHVybiAwOwoJcmV0dXJuIGFbaV0gPT0gYltpXTsKfQoKaW50IGNvbW1vbl9wcmVmaXhfc2l6ZShzdHJ1Y3Qgc3RyYnVmICphLCBzdHJ1Y3Qgc3RyYnVmICpiKQp7CglpbnQgcCA9IDA7Cglmb3IgKDsgcCA8IGEtPmxlbiAmJiBwIDwgYi0+bGVuOyBwKyspIHsKCQlpZiAoYS0+YnVmW3BdICE9IGItPmJ1ZltwXSkKCQkJYnJlYWs7Cgl9CgoJcmV0dXJuIHA7Cn0K",
    "text": "/*\nCopyright 2020 Google LLC\n\nUse of this source code is governed by a BSD-style\nlicense that can be found in the LICENSE file or at\nhttps://developers.google.com/open-source/licenses/bsd\n*/\n\n#include \"basics.h\"\n\nvoid put_be24(uint8_t *out, uint32_t i)\n{\n\tout[0] = (uint8_t)((i >> 16) & 0xff);\n\tout[1] = (uint8_t)((i >> 8) & 0xff);\n\tout[2] = (uint8_t)(i & 0xff);\n}\n\nuint32_t get_be24(uint8_t *in)\n{\n\treturn (uint32_t)(in[0]) << 16 | (uint32_t)(in[1]) << 8 |\n\t       (uint32_t)(in[2]);\n}\n\nvoid put_be16(uint8_t *out, uint16_t i)\n{\n\tout[0] = (uint8_t)((i >> 8) & 0xff);\n\tout[1] = (uint8_t)(i & 0xff);\n}\n\nsize_t binsearch(size_t sz, int (*f)(size_t k, void *args), void *args)\n{\n\tsize_t lo = 0;\n\tsize_t hi = sz;\n\n\t/* Invariants:\n\t *\n\t *  (hi == sz) || f(hi) == true\n\t *  (lo == 0 && f(0) == true) || fi(lo) == false\n\t */\n\twhile (hi - lo > 1) {\n\t\tsize_t mid = lo + (hi - lo) / 2;\n\t\tint ret = f(mid, args);\n\t\tif (ret < 0)\n\t\t\treturn sz;\n\n\t\tif (ret > 0)\n\t\t\thi = mid;\n\t\telse\n\t\t\tlo = mid;\n\t}\n\n\tif (lo)\n\t\treturn hi;\n\n\treturn f(0, args) ? 0 : 1;\n}\n\nvoid free_names(char **a)\n{\n\tchar **p;\n\tif (!a) {\n\t\treturn;\n\t}\n\tfor (p = a; *p; p++) {\n\t\treftable_free(*p);\n\t}\n\treftable_free(a);\n}\n\nsize_t names_length(const char **names)\n{\n\tconst char **p = names;\n\twhile (*p)\n\t\tp++;\n\treturn p - names;\n}\n\nvoid parse_names(char *buf, int size, char ***namesp)\n{\n\tchar **names = NULL;\n\tsize_t names_cap = 0;\n\tsize_t names_len = 0;\n\n\tchar *p = buf;\n\tchar *end = buf + size;\n\twhile (p < end) {\n\t\tchar *next = strchr(p, '\\n');\n\t\tif (next && next < end) {\n\t\t\t*next = 0;\n\t\t} else {\n\t\t\tnext = end;\n\t\t}\n\t\tif (p < next) {\n\t\t\tREFTABLE_ALLOC_GROW(names, names_len + 1, names_cap);\n\t\t\tnames[names_len++] = xstrdup(p);\n\t\t}\n\t\tp = next + 1;\n\t}\n\n\tREFTABLE_REALLOC_ARRAY(names, names_len + 1);\n\tnames[names_len] = NULL;\n\t*namesp = names;\n}\n\nint names_equal(const char **a, const char **b)\n{\n\tsize_t i = 0;\n\tfor (; a[i] && b[i]; i++)\n\t\tif (strcmp(a[i], b[i]))\n\t\t\treturn 0;\n\treturn a[i] == b[i];\n}\n\nint common_prefix_size(struct strbuf *a, struct strbuf *b)\n{\n\tint p = 0;\n\tfor (; p < a->len && p < b->len; p++) {\n\t\tif (a->buf[p] != b->buf[p])\n\t\t\tbreak;\n\t}\n\n\treturn p;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0058619ca6742ae29b4f50d7188b0fc19d87f45b",
  "sha1_ok": true,
  "size": 2124
}
