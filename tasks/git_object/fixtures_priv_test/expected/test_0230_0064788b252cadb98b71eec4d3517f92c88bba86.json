{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgIm9iamVjdC1zdG9yZS5oIgojaW5jbHVkZSAicmVwb3NpdG9yeS5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgImdyYXBoLmgiCiNpbmNsdWRlICJsb2ctdHJlZS5oIgojaW5jbHVkZSAicmVmbG9nLXdhbGsuaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgInN0cmluZy1saXN0LmgiCiNpbmNsdWRlICJjb2xvci5oIgojaW5jbHVkZSAiZ3BnLWludGVyZmFjZS5oIgojaW5jbHVkZSAic2VxdWVuY2VyLmgiCiNpbmNsdWRlICJsaW5lLWxvZy5oIgojaW5jbHVkZSAiaGVscC5oIgojaW5jbHVkZSAiaW50ZXJkaWZmLmgiCiNpbmNsdWRlICJyYW5nZS1kaWZmLmgiCgpzdGF0aWMgc3RydWN0IGRlY29yYXRpb24gbmFtZV9kZWNvcmF0aW9uID0geyAib2JqZWN0IG5hbWVzIiB9OwpzdGF0aWMgaW50IGRlY29yYXRpb25fbG9hZGVkOwpzdGF0aWMgaW50IGRlY29yYXRpb25fZmxhZ3M7CgpzdGF0aWMgY2hhciBkZWNvcmF0aW9uX2NvbG9yc1tdW0NPTE9SX01BWExFTl0gPSB7CglHSVRfQ09MT1JfUkVTRVQsCglHSVRfQ09MT1JfQk9MRF9HUkVFTiwJLyogUkVGX0xPQ0FMICovCglHSVRfQ09MT1JfQk9MRF9SRUQsCS8qIFJFRl9SRU1PVEUgKi8KCUdJVF9DT0xPUl9CT0xEX1lFTExPVywJLyogUkVGX1RBRyAqLwoJR0lUX0NPTE9SX0JPTERfTUFHRU5UQSwJLyogUkVGX1NUQVNIICovCglHSVRfQ09MT1JfQk9MRF9DWUFOLAkvKiBSRUZfSEVBRCAqLwoJR0lUX0NPTE9SX0JPTERfQkxVRSwJLyogR1JBRlRFRCAqLwp9OwoKc3RhdGljIGNvbnN0IGNoYXIgKmNvbG9yX2RlY29yYXRlX3Nsb3RzW10gPSB7CglbREVDT1JBVElPTl9SRUZfTE9DQUxdCT0gImJyYW5jaCIsCglbREVDT1JBVElPTl9SRUZfUkVNT1RFXSA9ICJyZW1vdGVCcmFuY2giLAoJW0RFQ09SQVRJT05fUkVGX1RBR10JPSAidGFnIiwKCVtERUNPUkFUSU9OX1JFRl9TVEFTSF0JPSAic3Rhc2giLAoJW0RFQ09SQVRJT05fUkVGX0hFQURdCT0gIkhFQUQiLAoJW0RFQ09SQVRJT05fR1JBRlRFRF0JPSAiZ3JhZnRlZCIsCn07CgpzdGF0aWMgY29uc3QgY2hhciAqZGVjb3JhdGVfZ2V0X2NvbG9yKGludCBkZWNvcmF0ZV91c2VfY29sb3IsIGVudW0gZGVjb3JhdGlvbl90eXBlIGl4KQp7CglpZiAod2FudF9jb2xvcihkZWNvcmF0ZV91c2VfY29sb3IpKQoJCXJldHVybiBkZWNvcmF0aW9uX2NvbG9yc1tpeF07CglyZXR1cm4gIiI7Cn0KCmRlZmluZV9saXN0X2NvbmZpZ19hcnJheShjb2xvcl9kZWNvcmF0ZV9zbG90cyk7CgppbnQgcGFyc2VfZGVjb3JhdGVfY29sb3JfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqc2xvdF9uYW1lLCBjb25zdCBjaGFyICp2YWx1ZSkKewoJaW50IHNsb3QgPSBMT09LVVBfQ09ORklHKGNvbG9yX2RlY29yYXRlX3Nsb3RzLCBzbG90X25hbWUpOwoJaWYgKHNsb3QgPCAwKQoJCXJldHVybiAwOwoJaWYgKCF2YWx1ZSkKCQlyZXR1cm4gY29uZmlnX2Vycm9yX25vbmJvb2wodmFyKTsKCXJldHVybiBjb2xvcl9wYXJzZSh2YWx1ZSwgZGVjb3JhdGlvbl9jb2xvcnNbc2xvdF0pOwp9CgovKgogKiBsb2ctdHJlZS5jIHVzZXMgRElGRl9PUFRfVFNUIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRvIHVzZSBjb2xvcgogKiBmb3Igc2hvd2luZyB0aGUgY29tbWl0IHNoYTEsIHVzZSB0aGUgc2FtZSBjaGVjayBmb3IgLS1kZWNvcmF0ZQogKi8KI2RlZmluZSBkZWNvcmF0ZV9nZXRfY29sb3Jfb3B0KG8sIGl4KSBcCglkZWNvcmF0ZV9nZXRfY29sb3IoKG8pLT51c2VfY29sb3IsIGl4KQoKdm9pZCBhZGRfbmFtZV9kZWNvcmF0aW9uKGVudW0gZGVjb3JhdGlvbl90eXBlIHR5cGUsIGNvbnN0IGNoYXIgKm5hbWUsIHN0cnVjdCBvYmplY3QgKm9iaikKewoJc3RydWN0IG5hbWVfZGVjb3JhdGlvbiAqcmVzOwoJRkxFWF9BTExPQ19TVFIocmVzLCBuYW1lLCBuYW1lKTsKCXJlcy0+dHlwZSA9IHR5cGU7CglyZXMtPm5leHQgPSBhZGRfZGVjb3JhdGlvbigmbmFtZV9kZWNvcmF0aW9uLCBvYmosIHJlcyk7Cn0KCmNvbnN0IHN0cnVjdCBuYW1lX2RlY29yYXRpb24gKmdldF9uYW1lX2RlY29yYXRpb24oY29uc3Qgc3RydWN0IG9iamVjdCAqb2JqKQp7Cglsb2FkX3JlZl9kZWNvcmF0aW9ucyhOVUxMLCBERUNPUkFURV9TSE9SVF9SRUZTKTsKCXJldHVybiBsb29rdXBfZGVjb3JhdGlvbigmbmFtZV9kZWNvcmF0aW9uLCBvYmopOwp9CgpzdGF0aWMgaW50IGFkZF9yZWZfZGVjb3JhdGlvbihjb25zdCBjaGFyICpyZWZuYW1lLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCSAgICAgIGludCBmbGFncywgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IG9iamVjdCAqb2JqOwoJZW51bSBkZWNvcmF0aW9uX3R5cGUgdHlwZSA9IERFQ09SQVRJT05fTk9ORTsKCXN0cnVjdCBkZWNvcmF0aW9uX2ZpbHRlciAqZmlsdGVyID0gKHN0cnVjdCBkZWNvcmF0aW9uX2ZpbHRlciAqKWNiX2RhdGE7CgoJaWYgKGZpbHRlciAmJiAhcmVmX2ZpbHRlcl9tYXRjaChyZWZuYW1lLAoJCQkgICAgICBmaWx0ZXItPmluY2x1ZGVfcmVmX3BhdHRlcm4sCgkJCSAgICAgIGZpbHRlci0+ZXhjbHVkZV9yZWZfcGF0dGVybikpCgkJcmV0dXJuIDA7CgoJaWYgKHN0YXJ0c193aXRoKHJlZm5hbWUsIGdpdF9yZXBsYWNlX3JlZl9iYXNlKSkgewoJCXN0cnVjdCBvYmplY3RfaWQgb3JpZ2luYWxfb2lkOwoJCWlmICghcmVhZF9yZXBsYWNlX3JlZnMpCgkJCXJldHVybiAwOwoJCWlmIChnZXRfb2lkX2hleChyZWZuYW1lICsgc3RybGVuKGdpdF9yZXBsYWNlX3JlZl9iYXNlKSwKCQkJCSZvcmlnaW5hbF9vaWQpKSB7CgkJCXdhcm5pbmcoImludmFsaWQgcmVwbGFjZSByZWYgJXMiLCByZWZuYW1lKTsKCQkJcmV0dXJuIDA7CgkJfQoJCW9iaiA9IHBhcnNlX29iamVjdCh0aGVfcmVwb3NpdG9yeSwgJm9yaWdpbmFsX29pZCk7CgkJaWYgKG9iaikKCQkJYWRkX25hbWVfZGVjb3JhdGlvbihERUNPUkFUSU9OX0dSQUZURUQsICJyZXBsYWNlZCIsIG9iaik7CgkJcmV0dXJuIDA7Cgl9CgoJb2JqID0gcGFyc2Vfb2JqZWN0KHRoZV9yZXBvc2l0b3J5LCBvaWQpOwoJaWYgKCFvYmopCgkJcmV0dXJuIDA7CgoJaWYgKHN0YXJ0c193aXRoKHJlZm5hbWUsICJyZWZzL2hlYWRzLyIpKQoJCXR5cGUgPSBERUNPUkFUSU9OX1JFRl9MT0NBTDsKCWVsc2UgaWYgKHN0YXJ0c193aXRoKHJlZm5hbWUsICJyZWZzL3JlbW90ZXMvIikpCgkJdHlwZSA9IERFQ09SQVRJT05fUkVGX1JFTU9URTsKCWVsc2UgaWYgKHN0YXJ0c193aXRoKHJlZm5hbWUsICJyZWZzL3RhZ3MvIikpCgkJdHlwZSA9IERFQ09SQVRJT05fUkVGX1RBRzsKCWVsc2UgaWYgKCFzdHJjbXAocmVmbmFtZSwgInJlZnMvc3Rhc2giKSkKCQl0eXBlID0gREVDT1JBVElPTl9SRUZfU1RBU0g7CgllbHNlIGlmICghc3RyY21wKHJlZm5hbWUsICJIRUFEIikpCgkJdHlwZSA9IERFQ09SQVRJT05fUkVGX0hFQUQ7CgoJYWRkX25hbWVfZGVjb3JhdGlvbih0eXBlLCByZWZuYW1lLCBvYmopOwoJd2hpbGUgKG9iai0+dHlwZSA9PSBPQkpfVEFHKSB7CgkJb2JqID0gKChzdHJ1Y3QgdGFnICopb2JqKS0+dGFnZ2VkOwoJCWlmICghb2JqKQoJCQlicmVhazsKCQlpZiAoIW9iai0+cGFyc2VkKQoJCQlwYXJzZV9vYmplY3QodGhlX3JlcG9zaXRvcnksICZvYmotPm9pZCk7CgkJYWRkX25hbWVfZGVjb3JhdGlvbihERUNPUkFUSU9OX1JFRl9UQUcsIHJlZm5hbWUsIG9iaik7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBhZGRfZ3JhZnRfZGVjb3JhdGlvbihjb25zdCBzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpncmFmdCwgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gbG9va3VwX2NvbW1pdCh0aGVfcmVwb3NpdG9yeSwgJmdyYWZ0LT5vaWQpOwoJaWYgKCFjb21taXQpCgkJcmV0dXJuIDA7CglhZGRfbmFtZV9kZWNvcmF0aW9uKERFQ09SQVRJT05fR1JBRlRFRCwgImdyYWZ0ZWQiLCAmY29tbWl0LT5vYmplY3QpOwoJcmV0dXJuIDA7Cn0KCnZvaWQgbG9hZF9yZWZfZGVjb3JhdGlvbnMoc3RydWN0IGRlY29yYXRpb25fZmlsdGVyICpmaWx0ZXIsIGludCBmbGFncykKewoJaWYgKCFkZWNvcmF0aW9uX2xvYWRlZCkgewoJCWlmIChmaWx0ZXIpIHsKCQkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW07CgkJCWZvcl9lYWNoX3N0cmluZ19saXN0X2l0ZW0oaXRlbSwgZmlsdGVyLT5leGNsdWRlX3JlZl9wYXR0ZXJuKSB7CgkJCQlub3JtYWxpemVfZ2xvYl9yZWYoaXRlbSwgTlVMTCwgaXRlbS0+c3RyaW5nKTsKCQkJfQoJCQlmb3JfZWFjaF9zdHJpbmdfbGlzdF9pdGVtKGl0ZW0sIGZpbHRlci0+aW5jbHVkZV9yZWZfcGF0dGVybikgewoJCQkJbm9ybWFsaXplX2dsb2JfcmVmKGl0ZW0sIE5VTEwsIGl0ZW0tPnN0cmluZyk7CgkJCX0KCQl9CgkJZGVjb3JhdGlvbl9sb2FkZWQgPSAxOwoJCWRlY29yYXRpb25fZmxhZ3MgPSBmbGFnczsKCQlmb3JfZWFjaF9yZWYoYWRkX3JlZl9kZWNvcmF0aW9uLCBmaWx0ZXIpOwoJCWhlYWRfcmVmKGFkZF9yZWZfZGVjb3JhdGlvbiwgZmlsdGVyKTsKCQlmb3JfZWFjaF9jb21taXRfZ3JhZnQoYWRkX2dyYWZ0X2RlY29yYXRpb24sIGZpbHRlcik7Cgl9Cn0KCnN0YXRpYyB2b2lkIHNob3dfcGFyZW50cyhzdHJ1Y3QgY29tbWl0ICpjb21taXQsIGludCBhYmJyZXYsIEZJTEUgKmZpbGUpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqcDsKCWZvciAocCA9IGNvbW1pdC0+cGFyZW50czsgcCA7IHAgPSBwLT5uZXh0KSB7CgkJc3RydWN0IGNvbW1pdCAqcGFyZW50ID0gcC0+aXRlbTsKCQlmcHJpbnRmKGZpbGUsICIgJXMiLCBmaW5kX3VuaXF1ZV9hYmJyZXYoJnBhcmVudC0+b2JqZWN0Lm9pZCwgYWJicmV2KSk7Cgl9Cn0KCnN0YXRpYyB2b2lkIHNob3dfY2hpbGRyZW4oc3RydWN0IHJldl9pbmZvICpvcHQsIHN0cnVjdCBjb21taXQgKmNvbW1pdCwgaW50IGFiYnJldikKewoJc3RydWN0IGNvbW1pdF9saXN0ICpwID0gbG9va3VwX2RlY29yYXRpb24oJm9wdC0+Y2hpbGRyZW4sICZjb21taXQtPm9iamVjdCk7Cglmb3IgKCA7IHA7IHAgPSBwLT5uZXh0KSB7CgkJZnByaW50ZihvcHQtPmRpZmZvcHQuZmlsZSwgIiAlcyIsIGZpbmRfdW5pcXVlX2FiYnJldigmcC0+aXRlbS0+b2JqZWN0Lm9pZCwgYWJicmV2KSk7Cgl9Cn0KCi8qCiAqIERvIHdlIGhhdmUgSEVBRCBpbiB0aGUgb3V0cHV0LCBhbmQgYWxzbyB0aGUgYnJhbmNoIGl0IHBvaW50cyBhdD8KICogSWYgc28sIGZpbmQgdGhhdCBkZWNvcmF0aW9uIGVudHJ5IGZvciB0aGF0IGN1cnJlbnQgYnJhbmNoLgogKi8Kc3RhdGljIGNvbnN0IHN0cnVjdCBuYW1lX2RlY29yYXRpb24gKmN1cnJlbnRfcG9pbnRlZF9ieV9IRUFEKGNvbnN0IHN0cnVjdCBuYW1lX2RlY29yYXRpb24gKmRlY29yYXRpb24pCnsKCWNvbnN0IHN0cnVjdCBuYW1lX2RlY29yYXRpb24gKmxpc3QsICpoZWFkID0gTlVMTDsKCWNvbnN0IGNoYXIgKmJyYW5jaF9uYW1lID0gTlVMTDsKCWludCBycnVfZmxhZ3M7CgoJLyogRmlyc3QgZmluZCBIRUFEICovCglmb3IgKGxpc3QgPSBkZWNvcmF0aW9uOyBsaXN0OyBsaXN0ID0gbGlzdC0+bmV4dCkKCQlpZiAobGlzdC0+dHlwZSA9PSBERUNPUkFUSU9OX1JFRl9IRUFEKSB7CgkJCWhlYWQgPSBsaXN0OwoJCQlicmVhazsKCQl9CglpZiAoIWhlYWQpCgkJcmV0dXJuIE5VTEw7CgoJLyogTm93IHJlc29sdmUgYW5kIGZpbmQgdGhlIG1hdGNoaW5nIGN1cnJlbnQgYnJhbmNoICovCglicmFuY2hfbmFtZSA9IHJlc29sdmVfcmVmX3Vuc2FmZSgiSEVBRCIsIDAsIE5VTEwsICZycnVfZmxhZ3MpOwoJaWYgKCFicmFuY2hfbmFtZSB8fCAhKHJydV9mbGFncyAmIFJFRl9JU1NZTVJFRikpCgkJcmV0dXJuIE5VTEw7CgoJaWYgKCFzdGFydHNfd2l0aChicmFuY2hfbmFtZSwgInJlZnMvIikpCgkJcmV0dXJuIE5VTEw7CgoJLyogT0ssIGRvIHdlIGhhdmUgdGhhdCByZWYgaW4gdGhlIGxpc3Q/ICovCglmb3IgKGxpc3QgPSBkZWNvcmF0aW9uOyBsaXN0OyBsaXN0ID0gbGlzdC0+bmV4dCkKCQlpZiAoKGxpc3QtPnR5cGUgPT0gREVDT1JBVElPTl9SRUZfTE9DQUwpICYmCgkJICAgICFzdHJjbXAoYnJhbmNoX25hbWUsIGxpc3QtPm5hbWUpKSB7CgkJCXJldHVybiBsaXN0OwoJCX0KCglyZXR1cm4gTlVMTDsKfQoKc3RhdGljIHZvaWQgc2hvd19uYW1lKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBzdHJ1Y3QgbmFtZV9kZWNvcmF0aW9uICpkZWNvcmF0aW9uKQp7CglpZiAoZGVjb3JhdGlvbl9mbGFncyA9PSBERUNPUkFURV9TSE9SVF9SRUZTKQoJCXN0cmJ1Zl9hZGRzdHIoc2IsIHByZXR0aWZ5X3JlZm5hbWUoZGVjb3JhdGlvbi0+bmFtZSkpOwoJZWxzZQoJCXN0cmJ1Zl9hZGRzdHIoc2IsIGRlY29yYXRpb24tPm5hbWUpOwp9CgovKgogKiBUaGUgY2FsbGVyIG1ha2VzIHN1cmUgdGhlcmUgaXMgbm8gZnVubnkgY29sb3IgYmVmb3JlIGNhbGxpbmcuCiAqIGZvcm1hdF9kZWNvcmF0aW9uc19leHRlbmRlZCBtYWtlcyBzdXJlIHRoZSBzYW1lIGFmdGVyIHJldHVybi4KICovCnZvaWQgZm9ybWF0X2RlY29yYXRpb25zX2V4dGVuZGVkKHN0cnVjdCBzdHJidWYgKnNiLAoJCQljb25zdCBzdHJ1Y3QgY29tbWl0ICpjb21taXQsCgkJCWludCB1c2VfY29sb3IsCgkJCWNvbnN0IGNoYXIgKnByZWZpeCwKCQkJY29uc3QgY2hhciAqc2VwYXJhdG9yLAoJCQljb25zdCBjaGFyICpzdWZmaXgpCnsKCWNvbnN0IHN0cnVjdCBuYW1lX2RlY29yYXRpb24gKmRlY29yYXRpb247Cgljb25zdCBzdHJ1Y3QgbmFtZV9kZWNvcmF0aW9uICpjdXJyZW50X2FuZF9IRUFEOwoJY29uc3QgY2hhciAqY29sb3JfY29tbWl0ID0KCQlkaWZmX2dldF9jb2xvcih1c2VfY29sb3IsIERJRkZfQ09NTUlUKTsKCWNvbnN0IGNoYXIgKmNvbG9yX3Jlc2V0ID0KCQlkZWNvcmF0ZV9nZXRfY29sb3IodXNlX2NvbG9yLCBERUNPUkFUSU9OX05PTkUpOwoKCWRlY29yYXRpb24gPSBnZXRfbmFtZV9kZWNvcmF0aW9uKCZjb21taXQtPm9iamVjdCk7CglpZiAoIWRlY29yYXRpb24pCgkJcmV0dXJuOwoKCWN1cnJlbnRfYW5kX0hFQUQgPSBjdXJyZW50X3BvaW50ZWRfYnlfSEVBRChkZWNvcmF0aW9uKTsKCXdoaWxlIChkZWNvcmF0aW9uKSB7CgkJLyoKCQkgKiBXaGVuIGJvdGggY3VycmVudCBhbmQgSEVBRCBhcmUgdGhlcmUsIG9ubHkKCQkgKiBzaG93IEhFQUQtPmN1cnJlbnQgd2hlcmUgSEVBRCB3b3VsZCBoYXZlCgkJICogYXBwZWFyZWQsIHNraXBwaW5nIHRoZSBlbnRyeSBmb3IgY3VycmVudC4KCQkgKi8KCQlpZiAoZGVjb3JhdGlvbiAhPSBjdXJyZW50X2FuZF9IRUFEKSB7CgkJCXN0cmJ1Zl9hZGRzdHIoc2IsIGNvbG9yX2NvbW1pdCk7CgkJCXN0cmJ1Zl9hZGRzdHIoc2IsIHByZWZpeCk7CgkJCXN0cmJ1Zl9hZGRzdHIoc2IsIGNvbG9yX3Jlc2V0KTsKCQkJc3RyYnVmX2FkZHN0cihzYiwgZGVjb3JhdGVfZ2V0X2NvbG9yKHVzZV9jb2xvciwgZGVjb3JhdGlvbi0+dHlwZSkpOwoJCQlpZiAoZGVjb3JhdGlvbi0+dHlwZSA9PSBERUNPUkFUSU9OX1JFRl9UQUcpCgkJCQlzdHJidWZfYWRkc3RyKHNiLCAidGFnOiAiKTsKCgkJCXNob3dfbmFtZShzYiwgZGVjb3JhdGlvbik7CgoJCQlpZiAoY3VycmVudF9hbmRfSEVBRCAmJgoJCQkgICAgZGVjb3JhdGlvbi0+dHlwZSA9PSBERUNPUkFUSU9OX1JFRl9IRUFEKSB7CgkJCQlzdHJidWZfYWRkc3RyKHNiLCAiIC0+ICIpOwoJCQkJc3RyYnVmX2FkZHN0cihzYiwgY29sb3JfcmVzZXQpOwoJCQkJc3RyYnVmX2FkZHN0cihzYiwgZGVjb3JhdGVfZ2V0X2NvbG9yKHVzZV9jb2xvciwgY3VycmVudF9hbmRfSEVBRC0+dHlwZSkpOwoJCQkJc2hvd19uYW1lKHNiLCBjdXJyZW50X2FuZF9IRUFEKTsKCQkJfQoJCQlzdHJidWZfYWRkc3RyKHNiLCBjb2xvcl9yZXNldCk7CgoJCQlwcmVmaXggPSBzZXBhcmF0b3I7CgkJfQoJCWRlY29yYXRpb24gPSBkZWNvcmF0aW9uLT5uZXh0OwoJfQoJc3RyYnVmX2FkZHN0cihzYiwgY29sb3JfY29tbWl0KTsKCXN0cmJ1Zl9hZGRzdHIoc2IsIHN1ZmZpeCk7CglzdHJidWZfYWRkc3RyKHNiLCBjb2xvcl9yZXNldCk7Cn0KCnZvaWQgc2hvd19kZWNvcmF0aW9ucyhzdHJ1Y3QgcmV2X2luZm8gKm9wdCwgc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CgoJaWYgKG9wdC0+c291cmNlcykgewoJCWNoYXIgKipzbG90ID0gcmV2aXNpb25fc291cmNlc19wZWVrKG9wdC0+c291cmNlcywgY29tbWl0KTsKCgkJaWYgKHNsb3QgJiYgKnNsb3QpCgkJCWZwcmludGYob3B0LT5kaWZmb3B0LmZpbGUsICJcdCVzIiwgKnNsb3QpOwoJfQoJaWYgKCFvcHQtPnNob3dfZGVjb3JhdGlvbnMpCgkJcmV0dXJuOwoJZm9ybWF0X2RlY29yYXRpb25zKCZzYiwgY29tbWl0LCBvcHQtPmRpZmZvcHQudXNlX2NvbG9yKTsKCWZwdXRzKHNiLmJ1Ziwgb3B0LT5kaWZmb3B0LmZpbGUpOwoJc3RyYnVmX3JlbGVhc2UoJnNiKTsKfQoKc3RhdGljIHVuc2lnbmVkIGludCBkaWdpdHNfaW5fbnVtYmVyKHVuc2lnbmVkIGludCBudW1iZXIpCnsKCXVuc2lnbmVkIGludCBpID0gMTAsIHJlc3VsdCA9IDE7Cgl3aGlsZSAoaSA8PSBudW1iZXIpIHsKCQlpICo9IDEwOwoJCXJlc3VsdCsrOwoJfQoJcmV0dXJuIHJlc3VsdDsKfQoKdm9pZCBmbXRfb3V0cHV0X3N1YmplY3Qoc3RydWN0IHN0cmJ1ZiAqZmlsZW5hbWUsCgkJCWNvbnN0IGNoYXIgKnN1YmplY3QsCgkJCXN0cnVjdCByZXZfaW5mbyAqaW5mbykKewoJY29uc3QgY2hhciAqc3VmZml4ID0gaW5mby0+cGF0Y2hfc3VmZml4OwoJaW50IG5yID0gaW5mby0+bnI7CglpbnQgc3RhcnRfbGVuID0gZmlsZW5hbWUtPmxlbjsKCWludCBtYXhfbGVuID0gc3RhcnRfbGVuICsgRk9STUFUX1BBVENIX05BTUVfTUFYIC0gKHN0cmxlbihzdWZmaXgpICsgMSk7CgoJaWYgKDAgPCBpbmZvLT5yZXJvbGxfY291bnQpCgkJc3RyYnVmX2FkZGYoZmlsZW5hbWUsICJ2JWQtIiwgaW5mby0+cmVyb2xsX2NvdW50KTsKCXN0cmJ1Zl9hZGRmKGZpbGVuYW1lLCAiJTA0ZC0lcyIsIG5yLCBzdWJqZWN0KTsKCglpZiAobWF4X2xlbiA8IGZpbGVuYW1lLT5sZW4pCgkJc3RyYnVmX3NldGxlbihmaWxlbmFtZSwgbWF4X2xlbik7CglzdHJidWZfYWRkc3RyKGZpbGVuYW1lLCBzdWZmaXgpOwp9Cgp2b2lkIGZtdF9vdXRwdXRfY29tbWl0KHN0cnVjdCBzdHJidWYgKmZpbGVuYW1lLAoJCSAgICAgICBzdHJ1Y3QgY29tbWl0ICpjb21taXQsCgkJICAgICAgIHN0cnVjdCByZXZfaW5mbyAqaW5mbykKewoJc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0IGN0eCA9IHswfTsKCXN0cnVjdCBzdHJidWYgc3ViamVjdCA9IFNUUkJVRl9JTklUOwoKCWZvcm1hdF9jb21taXRfbWVzc2FnZShjb21taXQsICIlZiIsICZzdWJqZWN0LCAmY3R4KTsKCWZtdF9vdXRwdXRfc3ViamVjdChmaWxlbmFtZSwgc3ViamVjdC5idWYsIGluZm8pOwoJc3RyYnVmX3JlbGVhc2UoJnN1YmplY3QpOwp9Cgp2b2lkIGZtdF9vdXRwdXRfZW1haWxfc3ViamVjdChzdHJ1Y3Qgc3RyYnVmICpzYiwgc3RydWN0IHJldl9pbmZvICpvcHQpCnsKCWlmIChvcHQtPnRvdGFsID4gMCkgewoJCXN0cmJ1Zl9hZGRmKHNiLCAiU3ViamVjdDogWyVzJXMlMCpkLyVkXSAiLAoJCQkgICAgb3B0LT5zdWJqZWN0X3ByZWZpeCwKCQkJICAgICpvcHQtPnN1YmplY3RfcHJlZml4ID8gIiAiIDogIiIsCgkJCSAgICBkaWdpdHNfaW5fbnVtYmVyKG9wdC0+dG90YWwpLAoJCQkgICAgb3B0LT5uciwgb3B0LT50b3RhbCk7Cgl9IGVsc2UgaWYgKG9wdC0+dG90YWwgPT0gMCAmJiBvcHQtPnN1YmplY3RfcHJlZml4ICYmICpvcHQtPnN1YmplY3RfcHJlZml4KSB7CgkJc3RyYnVmX2FkZGYoc2IsICJTdWJqZWN0OiBbJXNdICIsCgkJCSAgICBvcHQtPnN1YmplY3RfcHJlZml4KTsKCX0gZWxzZSB7CgkJc3RyYnVmX2FkZHN0cihzYiwgIlN1YmplY3Q6ICIpOwoJfQp9Cgp2b2lkIGxvZ193cml0ZV9lbWFpbF9oZWFkZXJzKHN0cnVjdCByZXZfaW5mbyAqb3B0LCBzdHJ1Y3QgY29tbWl0ICpjb21taXQsCgkJCSAgICAgY29uc3QgY2hhciAqKmV4dHJhX2hlYWRlcnNfcCwKCQkJICAgICBpbnQgKm5lZWRfOGJpdF9jdGVfcCwKCQkJICAgICBpbnQgbWF5YmVfbXVsdGlwYXJ0KQp7Cgljb25zdCBjaGFyICpleHRyYV9oZWFkZXJzID0gb3B0LT5leHRyYV9oZWFkZXJzOwoJY29uc3QgY2hhciAqbmFtZSA9IG9pZF90b19oZXgob3B0LT56ZXJvX2NvbW1pdCA/CgkJCQkgICAgICAmbnVsbF9vaWQgOiAmY29tbWl0LT5vYmplY3Qub2lkKTsKCgkqbmVlZF84Yml0X2N0ZV9wID0gMDsgLyogdW5rbm93biAqLwoKCWZwcmludGYob3B0LT5kaWZmb3B0LmZpbGUsICJGcm9tICVzIE1vbiBTZXAgMTcgMDA6MDA6MDAgMjAwMVxuIiwgbmFtZSk7CglncmFwaF9zaG93X29uZWxpbmUob3B0LT5ncmFwaCk7CglpZiAob3B0LT5tZXNzYWdlX2lkKSB7CgkJZnByaW50ZihvcHQtPmRpZmZvcHQuZmlsZSwgIk1lc3NhZ2UtSWQ6IDwlcz5cbiIsIG9wdC0+bWVzc2FnZV9pZCk7CgkJZ3JhcGhfc2hvd19vbmVsaW5lKG9wdC0+Z3JhcGgpOwoJfQoJaWYgKG9wdC0+cmVmX21lc3NhZ2VfaWRzICYmIG9wdC0+cmVmX21lc3NhZ2VfaWRzLT5uciA+IDApIHsKCQlpbnQgaSwgbjsKCQluID0gb3B0LT5yZWZfbWVzc2FnZV9pZHMtPm5yOwoJCWZwcmludGYob3B0LT5kaWZmb3B0LmZpbGUsICJJbi1SZXBseS1UbzogPCVzPlxuIiwgb3B0LT5yZWZfbWVzc2FnZV9pZHMtPml0ZW1zW24tMV0uc3RyaW5nKTsKCQlmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKQoJCQlmcHJpbnRmKG9wdC0+ZGlmZm9wdC5maWxlLCAiJXM8JXM+XG4iLCAoaSA+IDAgPyAiXHQiIDogIlJlZmVyZW5jZXM6ICIpLAoJCQkgICAgICAgb3B0LT5yZWZfbWVzc2FnZV9pZHMtPml0ZW1zW2ldLnN0cmluZyk7CgkJZ3JhcGhfc2hvd19vbmVsaW5lKG9wdC0+Z3JhcGgpOwoJfQoJaWYgKG9wdC0+bWltZV9ib3VuZGFyeSAmJiBtYXliZV9tdWx0aXBhcnQpIHsKCQlzdGF0aWMgc3RydWN0IHN0cmJ1ZiBzdWJqZWN0X2J1ZmZlciA9IFNUUkJVRl9JTklUOwoJCXN0YXRpYyBzdHJ1Y3Qgc3RyYnVmIGJ1ZmZlciA9IFNUUkJVRl9JTklUOwoJCXN0cnVjdCBzdHJidWYgZmlsZW5hbWUgPSAgU1RSQlVGX0lOSVQ7CgkJKm5lZWRfOGJpdF9jdGVfcCA9IC0xOyAvKiBORVZFUiAqLwoKCQlzdHJidWZfcmVzZXQoJnN1YmplY3RfYnVmZmVyKTsKCQlzdHJidWZfcmVzZXQoJmJ1ZmZlcik7CgoJCXN0cmJ1Zl9hZGRmKCZzdWJqZWN0X2J1ZmZlciwKCQkJICIlcyIKCQkJICJNSU1FLVZlcnNpb246IDEuMFxuIgoJCQkgIkNvbnRlbnQtVHlwZTogbXVsdGlwYXJ0L21peGVkOyIKCQkJICIgYm91bmRhcnk9XCIlcyVzXCJcbiIKCQkJICJcbiIKCQkJICJUaGlzIGlzIGEgbXVsdGktcGFydCBtZXNzYWdlIGluIE1JTUUgIgoJCQkgImZvcm1hdC5cbiIKCQkJICItLSVzJXNcbiIKCQkJICJDb250ZW50LVR5cGU6IHRleHQvcGxhaW47ICIKCQkJICJjaGFyc2V0PVVURi04OyBmb3JtYXQ9Zml4ZWRcbiIKCQkJICJDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nOiA4Yml0XG5cbiIsCgkJCSBleHRyYV9oZWFkZXJzID8gZXh0cmFfaGVhZGVycyA6ICIiLAoJCQkgbWltZV9ib3VuZGFyeV9sZWFkZXIsIG9wdC0+bWltZV9ib3VuZGFyeSwKCQkJIG1pbWVfYm91bmRhcnlfbGVhZGVyLCBvcHQtPm1pbWVfYm91bmRhcnkpOwoJCWV4dHJhX2hlYWRlcnMgPSBzdWJqZWN0X2J1ZmZlci5idWY7CgoJCWlmIChvcHQtPm51bWJlcmVkX2ZpbGVzKQoJCQlzdHJidWZfYWRkZigmZmlsZW5hbWUsICIlZCIsIG9wdC0+bnIpOwoJCWVsc2UKCQkJZm10X291dHB1dF9jb21taXQoJmZpbGVuYW1lLCBjb21taXQsIG9wdCk7CgkJc3RyYnVmX2FkZGYoJmJ1ZmZlciwKCQkJICJcbi0tJXMlc1xuIgoJCQkgIkNvbnRlbnQtVHlwZTogdGV4dC94LXBhdGNoOyIKCQkJICIgbmFtZT1cIiVzXCJcbiIKCQkJICJDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nOiA4Yml0XG4iCgkJCSAiQ29udGVudC1EaXNwb3NpdGlvbjogJXM7IgoJCQkgIiBmaWxlbmFtZT1cIiVzXCJcblxuIiwKCQkJIG1pbWVfYm91bmRhcnlfbGVhZGVyLCBvcHQtPm1pbWVfYm91bmRhcnksCgkJCSBmaWxlbmFtZS5idWYsCgkJCSBvcHQtPm5vX2lubGluZSA/ICJhdHRhY2htZW50IiA6ICJpbmxpbmUiLAoJCQkgZmlsZW5hbWUuYnVmKTsKCQlvcHQtPmRpZmZvcHQuc3RhdF9zZXAgPSBidWZmZXIuYnVmOwoJCXN0cmJ1Zl9yZWxlYXNlKCZmaWxlbmFtZSk7Cgl9CgkqZXh0cmFfaGVhZGVyc19wID0gZXh0cmFfaGVhZGVyczsKfQoKc3RhdGljIHZvaWQgc2hvd19zaWdfbGluZXMoc3RydWN0IHJldl9pbmZvICpvcHQsIGludCBzdGF0dXMsIGNvbnN0IGNoYXIgKmJvbCkKewoJY29uc3QgY2hhciAqY29sb3IsICpyZXNldCwgKmVvbDsKCgljb2xvciA9IGRpZmZfZ2V0X2NvbG9yX29wdCgmb3B0LT5kaWZmb3B0LAoJCQkJICAgc3RhdHVzID8gRElGRl9XSElURVNQQUNFIDogRElGRl9GUkFHSU5GTyk7CglyZXNldCA9IGRpZmZfZ2V0X2NvbG9yX29wdCgmb3B0LT5kaWZmb3B0LCBESUZGX1JFU0VUKTsKCXdoaWxlICgqYm9sKSB7CgkJZW9sID0gc3RyY2hybnVsKGJvbCwgJ1xuJyk7CgkJZnByaW50ZihvcHQtPmRpZmZvcHQuZmlsZSwgIiVzJS4qcyVzJXMiLCBjb2xvciwgKGludCkoZW9sIC0gYm9sKSwgYm9sLCByZXNldCwKCQkgICAgICAgKmVvbCA/ICJcbiIgOiAiIik7CgkJZ3JhcGhfc2hvd19vbmVsaW5lKG9wdC0+Z3JhcGgpOwoJCWJvbCA9ICgqZW9sKSA/IChlb2wgKyAxKSA6IGVvbDsKCX0KfQoKc3RhdGljIHZvaWQgc2hvd19zaWduYXR1cmUoc3RydWN0IHJldl9pbmZvICpvcHQsIHN0cnVjdCBjb21taXQgKmNvbW1pdCkKewoJc3RydWN0IHN0cmJ1ZiBwYXlsb2FkID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIHNpZ25hdHVyZSA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHNpZ25hdHVyZV9jaGVjayBzaWdjID0geyAwIH07CglpbnQgc3RhdHVzOwoKCWlmIChwYXJzZV9zaWduZWRfY29tbWl0KGNvbW1pdCwgJnBheWxvYWQsICZzaWduYXR1cmUpIDw9IDApCgkJZ290byBvdXQ7CgoJc3RhdHVzID0gY2hlY2tfc2lnbmF0dXJlKHBheWxvYWQuYnVmLCBwYXlsb2FkLmxlbiwgc2lnbmF0dXJlLmJ1ZiwKCQkJCSBzaWduYXR1cmUubGVuLCAmc2lnYyk7CglpZiAoc3RhdHVzICYmICFzaWdjLmdwZ19vdXRwdXQpCgkJc2hvd19zaWdfbGluZXMob3B0LCBzdGF0dXMsICJObyBzaWduYXR1cmVcbiIpOwoJZWxzZQoJCXNob3dfc2lnX2xpbmVzKG9wdCwgc3RhdHVzLCBzaWdjLmdwZ19vdXRwdXQpOwoJc2lnbmF0dXJlX2NoZWNrX2NsZWFyKCZzaWdjKTsKCiBvdXQ6CglzdHJidWZfcmVsZWFzZSgmcGF5bG9hZCk7CglzdHJidWZfcmVsZWFzZSgmc2lnbmF0dXJlKTsKfQoKc3RhdGljIGludCB3aGljaF9wYXJlbnQoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBjb25zdCBzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCWludCBudGg7Cgljb25zdCBzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudDsKCglmb3IgKG50aCA9IDAsIHBhcmVudCA9IGNvbW1pdC0+cGFyZW50czsgcGFyZW50OyBwYXJlbnQgPSBwYXJlbnQtPm5leHQpIHsKCQlpZiAob2lkZXEoJnBhcmVudC0+aXRlbS0+b2JqZWN0Lm9pZCwgb2lkKSkKCQkJcmV0dXJuIG50aDsKCQludGgrKzsKCX0KCXJldHVybiAtMTsKfQoKc3RhdGljIGludCBpc19jb21tb25fbWVyZ2UoY29uc3Qgc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglyZXR1cm4gKGNvbW1pdC0+cGFyZW50cwoJCSYmIGNvbW1pdC0+cGFyZW50cy0+bmV4dAoJCSYmICFjb21taXQtPnBhcmVudHMtPm5leHQtPm5leHQpOwp9CgpzdGF0aWMgaW50IHNob3dfb25lX21lcmdldGFnKHN0cnVjdCBjb21taXQgKmNvbW1pdCwKCQkJICAgICBzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqZXh0cmEsCgkJCSAgICAgdm9pZCAqZGF0YSkKewoJc3RydWN0IHJldl9pbmZvICpvcHQgPSAoc3RydWN0IHJldl9pbmZvICopZGF0YTsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJc3RydWN0IHRhZyAqdGFnOwoJc3RydWN0IHN0cmJ1ZiB2ZXJpZnlfbWVzc2FnZTsKCXN0cnVjdCBzaWduYXR1cmVfY2hlY2sgc2lnYyA9IHsgMCB9OwoJaW50IHN0YXR1cywgbnRoOwoJc2l6ZV90IHBheWxvYWRfc2l6ZTsKCgloYXNoX29iamVjdF9maWxlKHRoZV9oYXNoX2FsZ28sIGV4dHJhLT52YWx1ZSwgZXh0cmEtPmxlbiwKCQkJIHR5cGVfbmFtZShPQkpfVEFHKSwgJm9pZCk7Cgl0YWcgPSBsb29rdXBfdGFnKHRoZV9yZXBvc2l0b3J5LCAmb2lkKTsKCWlmICghdGFnKQoJCXJldHVybiAtMTsgLyogZXJyb3IgbWVzc2FnZSBhbHJlYWR5IGdpdmVuICovCgoJc3RyYnVmX2luaXQoJnZlcmlmeV9tZXNzYWdlLCAyNTYpOwoJaWYgKHBhcnNlX3RhZ19idWZmZXIodGhlX3JlcG9zaXRvcnksIHRhZywgZXh0cmEtPnZhbHVlLCBleHRyYS0+bGVuKSkKCQlzdHJidWZfYWRkc3RyKCZ2ZXJpZnlfbWVzc2FnZSwgIm1hbGZvcm1lZCBtZXJnZXRhZ1xuIik7CgllbHNlIGlmIChpc19jb21tb25fbWVyZ2UoY29tbWl0KSAmJgoJCSBvaWRlcSgmdGFnLT50YWdnZWQtPm9pZCwKCQkgICAgICAgJmNvbW1pdC0+cGFyZW50cy0+bmV4dC0+aXRlbS0+b2JqZWN0Lm9pZCkpCgkJc3RyYnVmX2FkZGYoJnZlcmlmeV9tZXNzYWdlLAoJCQkgICAgIm1lcmdlZCB0YWcgJyVzJ1xuIiwgdGFnLT50YWcpOwoJZWxzZSBpZiAoKG50aCA9IHdoaWNoX3BhcmVudCgmdGFnLT50YWdnZWQtPm9pZCwgY29tbWl0KSkgPCAwKQoJCXN0cmJ1Zl9hZGRmKCZ2ZXJpZnlfbWVzc2FnZSwgInRhZyAlcyBuYW1lcyBhIG5vbi1wYXJlbnQgJXNcbiIsCgkJCQkgICAgdGFnLT50YWcsIG9pZF90b19oZXgoJnRhZy0+dGFnZ2VkLT5vaWQpKTsKCWVsc2UKCQlzdHJidWZfYWRkZigmdmVyaWZ5X21lc3NhZ2UsCgkJCSAgICAicGFyZW50ICMlZCwgdGFnZ2VkICclcydcbiIsIG50aCArIDEsIHRhZy0+dGFnKTsKCglwYXlsb2FkX3NpemUgPSBwYXJzZV9zaWduYXR1cmUoZXh0cmEtPnZhbHVlLCBleHRyYS0+bGVuKTsKCXN0YXR1cyA9IC0xOwoJaWYgKGV4dHJhLT5sZW4gPiBwYXlsb2FkX3NpemUpIHsKCQkvKiBjb3VsZCBoYXZlIGEgZ29vZCBzaWduYXR1cmUgKi8KCQlzdGF0dXMgPSBjaGVja19zaWduYXR1cmUoZXh0cmEtPnZhbHVlLCBwYXlsb2FkX3NpemUsCgkJCQkJIGV4dHJhLT52YWx1ZSArIHBheWxvYWRfc2l6ZSwKCQkJCQkgZXh0cmEtPmxlbiAtIHBheWxvYWRfc2l6ZSwgJnNpZ2MpOwoJCWlmIChzaWdjLmdwZ19vdXRwdXQpCgkJCXN0cmJ1Zl9hZGRzdHIoJnZlcmlmeV9tZXNzYWdlLCBzaWdjLmdwZ19vdXRwdXQpOwoJCWVsc2UKCQkJc3RyYnVmX2FkZHN0cigmdmVyaWZ5X21lc3NhZ2UsICJObyBzaWduYXR1cmVcbiIpOwoJCXNpZ25hdHVyZV9jaGVja19jbGVhcigmc2lnYyk7CgkJLyogb3RoZXJ3aXNlIHdlIGNvdWxkbid0IHZlcmlmeSwgd2hpY2ggaXMgc2hvd24gYXMgYmFkICovCgl9CgoJc2hvd19zaWdfbGluZXMob3B0LCBzdGF0dXMsIHZlcmlmeV9tZXNzYWdlLmJ1Zik7CglzdHJidWZfcmVsZWFzZSgmdmVyaWZ5X21lc3NhZ2UpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgc2hvd19tZXJnZXRhZyhzdHJ1Y3QgcmV2X2luZm8gKm9wdCwgc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglyZXR1cm4gZm9yX2VhY2hfbWVyZ2V0YWcoc2hvd19vbmVfbWVyZ2V0YWcsIGNvbW1pdCwgb3B0KTsKfQoKc3RhdGljIHZvaWQgbmV4dF9jb21tZW50YXJ5X2Jsb2NrKHN0cnVjdCByZXZfaW5mbyAqb3B0LCBzdHJ1Y3Qgc3RyYnVmICpzYikKewoJY29uc3QgY2hhciAqeCA9IG9wdC0+c2hvd25fZGFzaGVzID8gIlxuIiA6ICItLS1cbiI7CglpZiAoc2IpCgkJc3RyYnVmX2FkZHN0cihzYiwgeCk7CgllbHNlCgkJZnB1dHMoeCwgb3B0LT5kaWZmb3B0LmZpbGUpOwoJb3B0LT5zaG93bl9kYXNoZXMgPSAxOwp9Cgp2b2lkIHNob3dfbG9nKHN0cnVjdCByZXZfaW5mbyAqb3B0KQp7CglzdHJ1Y3Qgc3RyYnVmIG1zZ2J1ZiA9IFNUUkJVRl9JTklUOwoJc3RydWN0IGxvZ19pbmZvICpsb2cgPSBvcHQtPmxvZ2luZm87CglzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBsb2ctPmNvbW1pdCwgKnBhcmVudCA9IGxvZy0+cGFyZW50OwoJaW50IGFiYnJldl9jb21taXQgPSBvcHQtPmFiYnJldl9jb21taXQgPyBvcHQtPmFiYnJldiA6IHRoZV9oYXNoX2FsZ28tPmhleHN6OwoJY29uc3QgY2hhciAqZXh0cmFfaGVhZGVycyA9IG9wdC0+ZXh0cmFfaGVhZGVyczsKCXN0cnVjdCBwcmV0dHlfcHJpbnRfY29udGV4dCBjdHggPSB7MH07CgoJb3B0LT5sb2dpbmZvID0gTlVMTDsKCWlmICghb3B0LT52ZXJib3NlX2hlYWRlcikgewoJCWdyYXBoX3Nob3dfY29tbWl0KG9wdC0+Z3JhcGgpOwoKCQlpZiAoIW9wdC0+Z3JhcGgpCgkJCXB1dF9yZXZpc2lvbl9tYXJrKG9wdCwgY29tbWl0KTsKCQlmcHV0cyhmaW5kX3VuaXF1ZV9hYmJyZXYoJmNvbW1pdC0+b2JqZWN0Lm9pZCwgYWJicmV2X2NvbW1pdCksIG9wdC0+ZGlmZm9wdC5maWxlKTsKCQlpZiAob3B0LT5wcmludF9wYXJlbnRzKQoJCQlzaG93X3BhcmVudHMoY29tbWl0LCBhYmJyZXZfY29tbWl0LCBvcHQtPmRpZmZvcHQuZmlsZSk7CgkJaWYgKG9wdC0+Y2hpbGRyZW4ubmFtZSkKCQkJc2hvd19jaGlsZHJlbihvcHQsIGNvbW1pdCwgYWJicmV2X2NvbW1pdCk7CgkJc2hvd19kZWNvcmF0aW9ucyhvcHQsIGNvbW1pdCk7CgkJaWYgKG9wdC0+Z3JhcGggJiYgIWdyYXBoX2lzX2NvbW1pdF9maW5pc2hlZChvcHQtPmdyYXBoKSkgewoJCQlwdXRjKCdcbicsIG9wdC0+ZGlmZm9wdC5maWxlKTsKCQkJZ3JhcGhfc2hvd19yZW1haW5kZXIob3B0LT5ncmFwaCk7CgkJfQoJCXB1dGMob3B0LT5kaWZmb3B0LmxpbmVfdGVybWluYXRpb24sIG9wdC0+ZGlmZm9wdC5maWxlKTsKCQlyZXR1cm47Cgl9CgoJLyoKCSAqIElmIHVzZV90ZXJtaW5hdG9yIGlzIHNldCwgd2UgYWxyZWFkeSBoYW5kbGVkIGFueSByZWNvcmQgdGVybWluYXRpb24KCSAqIGF0IHRoZSBlbmQgb2YgdGhlIGxhc3QgcmVjb3JkLgoJICogT3RoZXJ3aXNlLCBhZGQgYSBkaWZmb3B0LmxpbmVfdGVybWluYXRpb24gY2hhcmFjdGVyIGJlZm9yZSBhbGwKCSAqIGVudHJpZXMgYnV0IHRoZSBmaXJzdC4gIChJT1csIGFzIGEgc2VwYXJhdG9yIGJldHdlZW4gZW50cmllcykKCSAqLwoJaWYgKG9wdC0+c2hvd25fb25lICYmICFvcHQtPnVzZV90ZXJtaW5hdG9yKSB7CgkJLyoKCQkgKiBJZiBlbnRyaWVzIGFyZSBzZXBhcmF0ZWQgYnkgYSBuZXdsaW5lLCB0aGUgb3V0cHV0CgkJICogc2hvdWxkIGxvb2sgaHVtYW4tcmVhZGFibGUuICBJZiB0aGUgbGFzdCBlbnRyeSBlbmRlZAoJCSAqIHdpdGggYSBuZXdsaW5lLCBwcmludCB0aGUgZ3JhcGggb3V0cHV0IGJlZm9yZSB0aGlzCgkJICogbmV3bGluZS4gIE90aGVyd2lzZSBpdCB3aWxsIGVuZCB1cCBhcyBhIGNvbXBsZXRlbHkgYmxhbmsKCQkgKiBsaW5lIGFuZCB3aWxsIGxvb2sgbGlrZSBhIGdhcCBpbiB0aGUgZ3JhcGguCgkJICoKCQkgKiBJZiB0aGUgZW50cnkgc2VwYXJhdG9yIGlzIG5vdCBhIG5ld2xpbmUsIHRoZSBvdXRwdXQgaXMKCQkgKiBwcmltYXJpbHkgaW50ZW5kZWQgZm9yIHByb2dyYW1tYXRpYyBjb25zdW1wdGlvbiwgYW5kIHdlCgkJICogbmV2ZXIgd2FudCB0aGUgZXh0cmEgZ3JhcGggb3V0cHV0IGJlZm9yZSB0aGUgZW50cnkKCQkgKiBzZXBhcmF0b3IuCgkJICovCgkJaWYgKG9wdC0+ZGlmZm9wdC5saW5lX3Rlcm1pbmF0aW9uID09ICdcbicgJiYKCQkgICAgIW9wdC0+bWlzc2luZ19uZXdsaW5lKQoJCQlncmFwaF9zaG93X3BhZGRpbmcob3B0LT5ncmFwaCk7CgkJcHV0YyhvcHQtPmRpZmZvcHQubGluZV90ZXJtaW5hdGlvbiwgb3B0LT5kaWZmb3B0LmZpbGUpOwoJfQoJb3B0LT5zaG93bl9vbmUgPSAxOwoKCS8qCgkgKiBJZiB0aGUgaGlzdG9yeSBncmFwaCB3YXMgcmVxdWVzdGVkLAoJICogcHJpbnQgdGhlIGdyYXBoLCB1cCB0byB0aGlzIGNvbW1pdCdzIGxpbmUKCSAqLwoJZ3JhcGhfc2hvd19jb21taXQob3B0LT5ncmFwaCk7CgoJLyoKCSAqIFByaW50IGhlYWRlciBsaW5lIG9mIGhlYWRlci4uCgkgKi8KCglpZiAoY21pdF9mbXRfaXNfbWFpbChvcHQtPmNvbW1pdF9mb3JtYXQpKSB7CgkJbG9nX3dyaXRlX2VtYWlsX2hlYWRlcnMob3B0LCBjb21taXQsICZleHRyYV9oZWFkZXJzLAoJCQkJCSZjdHgubmVlZF84Yml0X2N0ZSwgMSk7CgkJY3R4LnJldiA9IG9wdDsKCQljdHgucHJpbnRfZW1haWxfc3ViamVjdCA9IDE7Cgl9IGVsc2UgaWYgKG9wdC0+Y29tbWl0X2Zvcm1hdCAhPSBDTUlUX0ZNVF9VU0VSRk9STUFUKSB7CgkJZnB1dHMoZGlmZl9nZXRfY29sb3Jfb3B0KCZvcHQtPmRpZmZvcHQsIERJRkZfQ09NTUlUKSwgb3B0LT5kaWZmb3B0LmZpbGUpOwoJCWlmIChvcHQtPmNvbW1pdF9mb3JtYXQgIT0gQ01JVF9GTVRfT05FTElORSkKCQkJZnB1dHMoImNvbW1pdCAiLCBvcHQtPmRpZmZvcHQuZmlsZSk7CgoJCWlmICghb3B0LT5ncmFwaCkKCQkJcHV0X3JldmlzaW9uX21hcmsob3B0LCBjb21taXQpOwoJCWZwdXRzKGZpbmRfdW5pcXVlX2FiYnJldigmY29tbWl0LT5vYmplY3Qub2lkLAoJCQkJCSBhYmJyZXZfY29tbWl0KSwKCQkgICAgICBvcHQtPmRpZmZvcHQuZmlsZSk7CgkJaWYgKG9wdC0+cHJpbnRfcGFyZW50cykKCQkJc2hvd19wYXJlbnRzKGNvbW1pdCwgYWJicmV2X2NvbW1pdCwgb3B0LT5kaWZmb3B0LmZpbGUpOwoJCWlmIChvcHQtPmNoaWxkcmVuLm5hbWUpCgkJCXNob3dfY2hpbGRyZW4ob3B0LCBjb21taXQsIGFiYnJldl9jb21taXQpOwoJCWlmIChwYXJlbnQpCgkJCWZwcmludGYob3B0LT5kaWZmb3B0LmZpbGUsICIgKGZyb20gJXMpIiwKCQkJICAgICAgIGZpbmRfdW5pcXVlX2FiYnJldigmcGFyZW50LT5vYmplY3Qub2lkLCBhYmJyZXZfY29tbWl0KSk7CgkJZnB1dHMoZGlmZl9nZXRfY29sb3Jfb3B0KCZvcHQtPmRpZmZvcHQsIERJRkZfUkVTRVQpLCBvcHQtPmRpZmZvcHQuZmlsZSk7CgkJc2hvd19kZWNvcmF0aW9ucyhvcHQsIGNvbW1pdCk7CgkJaWYgKG9wdC0+Y29tbWl0X2Zvcm1hdCA9PSBDTUlUX0ZNVF9PTkVMSU5FKSB7CgkJCXB1dGMoJyAnLCBvcHQtPmRpZmZvcHQuZmlsZSk7CgkJfSBlbHNlIHsKCQkJcHV0YygnXG4nLCBvcHQtPmRpZmZvcHQuZmlsZSk7CgkJCWdyYXBoX3Nob3dfb25lbGluZShvcHQtPmdyYXBoKTsKCQl9CgkJaWYgKG9wdC0+cmVmbG9nX2luZm8pIHsKCQkJLyoKCQkJICogc2V0dXBfcmV2aXNpb25zKCkgZW5zdXJlcyB0aGF0IG9wdC0+cmVmbG9nX2luZm8KCQkJICogYW5kIG9wdC0+Z3JhcGggY2Fubm90IGJvdGggYmUgc2V0LAoJCQkgKiBzbyB3ZSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHByaW50aW5nIHRoZQoJCQkgKiBncmFwaCBpbmZvIGhlcmUuCgkJCSAqLwoJCQlzaG93X3JlZmxvZ19tZXNzYWdlKG9wdC0+cmVmbG9nX2luZm8sCgkJCQkJICAgIG9wdC0+Y29tbWl0X2Zvcm1hdCA9PSBDTUlUX0ZNVF9PTkVMSU5FLAoJCQkJCSAgICAmb3B0LT5kYXRlX21vZGUsCgkJCQkJICAgIG9wdC0+ZGF0ZV9tb2RlX2V4cGxpY2l0KTsKCQkJaWYgKG9wdC0+Y29tbWl0X2Zvcm1hdCA9PSBDTUlUX0ZNVF9PTkVMSU5FKQoJCQkJcmV0dXJuOwoJCX0KCX0KCglpZiAob3B0LT5zaG93X3NpZ25hdHVyZSkgewoJCXNob3dfc2lnbmF0dXJlKG9wdCwgY29tbWl0KTsKCQlzaG93X21lcmdldGFnKG9wdCwgY29tbWl0KTsKCX0KCglpZiAob3B0LT5zaG93X25vdGVzKSB7CgkJaW50IHJhdzsKCQlzdHJ1Y3Qgc3RyYnVmIG5vdGVidWYgPSBTVFJCVUZfSU5JVDsKCgkJcmF3ID0gKG9wdC0+Y29tbWl0X2Zvcm1hdCA9PSBDTUlUX0ZNVF9VU0VSRk9STUFUKTsKCQlmb3JtYXRfZGlzcGxheV9ub3RlcygmY29tbWl0LT5vYmplY3Qub2lkLCAmbm90ZWJ1ZiwKCQkJCSAgICAgZ2V0X2xvZ19vdXRwdXRfZW5jb2RpbmcoKSwgcmF3KTsKCQljdHgubm90ZXNfbWVzc2FnZSA9IHN0cmJ1Zl9kZXRhY2goJm5vdGVidWYsIE5VTEwpOwoJfQoKCS8qCgkgKiBBbmQgdGhlbiB0aGUgcHJldHR5LXByaW50ZWQgbWVzc2FnZSBpdHNlbGYKCSAqLwoJaWYgKGN0eC5uZWVkXzhiaXRfY3RlID49IDAgJiYgb3B0LT5hZGRfc2lnbm9mZikKCQljdHgubmVlZF84Yml0X2N0ZSA9CgkJCWhhc19ub25fYXNjaWkoZm10X25hbWUoV0FOVF9DT01NSVRURVJfSURFTlQpKTsKCWN0eC5kYXRlX21vZGUgPSBvcHQtPmRhdGVfbW9kZTsKCWN0eC5kYXRlX21vZGVfZXhwbGljaXQgPSBvcHQtPmRhdGVfbW9kZV9leHBsaWNpdDsKCWN0eC5hYmJyZXYgPSBvcHQtPmRpZmZvcHQuYWJicmV2OwoJY3R4LmFmdGVyX3N1YmplY3QgPSBleHRyYV9oZWFkZXJzOwoJY3R4LnByZXNlcnZlX3N1YmplY3QgPSBvcHQtPnByZXNlcnZlX3N1YmplY3Q7CgljdHguZW5jb2RlX2VtYWlsX2hlYWRlcnMgPSBvcHQtPmVuY29kZV9lbWFpbF9oZWFkZXJzOwoJY3R4LnJlZmxvZ19pbmZvID0gb3B0LT5yZWZsb2dfaW5mbzsKCWN0eC5mbXQgPSBvcHQtPmNvbW1pdF9mb3JtYXQ7CgljdHgubWFpbG1hcCA9IG9wdC0+bWFpbG1hcDsKCWN0eC5jb2xvciA9IG9wdC0+ZGlmZm9wdC51c2VfY29sb3I7CgljdHguZXhwYW5kX3RhYnNfaW5fbG9nID0gb3B0LT5leHBhbmRfdGFic19pbl9sb2c7CgljdHgub3V0cHV0X2VuY29kaW5nID0gZ2V0X2xvZ19vdXRwdXRfZW5jb2RpbmcoKTsKCWN0eC5yZXYgPSBvcHQ7CglpZiAob3B0LT5mcm9tX2lkZW50Lm1haWxfYmVnaW4gJiYgb3B0LT5mcm9tX2lkZW50Lm5hbWVfYmVnaW4pCgkJY3R4LmZyb21faWRlbnQgPSAmb3B0LT5mcm9tX2lkZW50OwoJaWYgKG9wdC0+Z3JhcGgpCgkJY3R4LmdyYXBoX3dpZHRoID0gZ3JhcGhfd2lkdGgob3B0LT5ncmFwaCk7CglwcmV0dHlfcHJpbnRfY29tbWl0KCZjdHgsIGNvbW1pdCwgJm1zZ2J1Zik7CgoJaWYgKG9wdC0+YWRkX3NpZ25vZmYpCgkJYXBwZW5kX3NpZ25vZmYoJm1zZ2J1ZiwgMCwgQVBQRU5EX1NJR05PRkZfREVEVVApOwoKCWlmICgoY3R4LmZtdCAhPSBDTUlUX0ZNVF9VU0VSRk9STUFUKSAmJgoJICAgIGN0eC5ub3Rlc19tZXNzYWdlICYmICpjdHgubm90ZXNfbWVzc2FnZSkgewoJCWlmIChjbWl0X2ZtdF9pc19tYWlsKGN0eC5mbXQpKQoJCQluZXh0X2NvbW1lbnRhcnlfYmxvY2sob3B0LCAmbXNnYnVmKTsKCQlzdHJidWZfYWRkc3RyKCZtc2didWYsIGN0eC5ub3Rlc19tZXNzYWdlKTsKCX0KCglpZiAob3B0LT5zaG93X2xvZ19zaXplKSB7CgkJZnByaW50ZihvcHQtPmRpZmZvcHQuZmlsZSwgImxvZyBzaXplICVpXG4iLCAoaW50KW1zZ2J1Zi5sZW4pOwoJCWdyYXBoX3Nob3dfb25lbGluZShvcHQtPmdyYXBoKTsKCX0KCgkvKgoJICogU2V0IG9wdC0+bWlzc2luZ19uZXdsaW5lIGlmIG1zZ2J1ZiBkb2Vzbid0CgkgKiBlbmQgaW4gYSBuZXdsaW5lIChpbmNsdWRpbmcgaWYgaXQgaXMgZW1wdHkpCgkgKi8KCWlmICghbXNnYnVmLmxlbiB8fCBtc2didWYuYnVmW21zZ2J1Zi5sZW4gLSAxXSAhPSAnXG4nKQoJCW9wdC0+bWlzc2luZ19uZXdsaW5lID0gMTsKCWVsc2UKCQlvcHQtPm1pc3NpbmdfbmV3bGluZSA9IDA7CgoJZ3JhcGhfc2hvd19jb21taXRfbXNnKG9wdC0+Z3JhcGgsIG9wdC0+ZGlmZm9wdC5maWxlLCAmbXNnYnVmKTsKCWlmIChvcHQtPnVzZV90ZXJtaW5hdG9yICYmICFjb21taXRfZm9ybWF0X2lzX2VtcHR5KG9wdC0+Y29tbWl0X2Zvcm1hdCkpIHsKCQlpZiAoIW9wdC0+bWlzc2luZ19uZXdsaW5lKQoJCQlncmFwaF9zaG93X3BhZGRpbmcob3B0LT5ncmFwaCk7CgkJcHV0YyhvcHQtPmRpZmZvcHQubGluZV90ZXJtaW5hdGlvbiwgb3B0LT5kaWZmb3B0LmZpbGUpOwoJfQoKCXN0cmJ1Zl9yZWxlYXNlKCZtc2didWYpOwoJZnJlZShjdHgubm90ZXNfbWVzc2FnZSk7CgoJaWYgKGNtaXRfZm10X2lzX21haWwoY3R4LmZtdCkgJiYgb3B0LT5pZGlmZl9vaWQxKSB7CgkJc3RydWN0IGRpZmZfcXVldWVfc3RydWN0IGRxOwoKCQltZW1jcHkoJmRxLCAmZGlmZl9xdWV1ZWRfZGlmZiwgc2l6ZW9mKGRpZmZfcXVldWVkX2RpZmYpKTsKCQlESUZGX1FVRVVFX0NMRUFSKCZkaWZmX3F1ZXVlZF9kaWZmKTsKCgkJbmV4dF9jb21tZW50YXJ5X2Jsb2NrKG9wdCwgTlVMTCk7CgkJZnByaW50Zl9sbihvcHQtPmRpZmZvcHQuZmlsZSwgIiVzIiwgb3B0LT5pZGlmZl90aXRsZSk7CgkJc2hvd19pbnRlcmRpZmYob3B0LCAyKTsKCgkJbWVtY3B5KCZkaWZmX3F1ZXVlZF9kaWZmLCAmZHEsIHNpemVvZihkaWZmX3F1ZXVlZF9kaWZmKSk7Cgl9CgoJaWYgKGNtaXRfZm10X2lzX21haWwoY3R4LmZtdCkgJiYgb3B0LT5yZGlmZjEpIHsKCQlzdHJ1Y3QgZGlmZl9xdWV1ZV9zdHJ1Y3QgZHE7CgkJc3RydWN0IGRpZmZfb3B0aW9ucyBvcHRzOwoKCQltZW1jcHkoJmRxLCAmZGlmZl9xdWV1ZWRfZGlmZiwgc2l6ZW9mKGRpZmZfcXVldWVkX2RpZmYpKTsKCQlESUZGX1FVRVVFX0NMRUFSKCZkaWZmX3F1ZXVlZF9kaWZmKTsKCgkJbmV4dF9jb21tZW50YXJ5X2Jsb2NrKG9wdCwgTlVMTCk7CgkJZnByaW50Zl9sbihvcHQtPmRpZmZvcHQuZmlsZSwgIiVzIiwgb3B0LT5yZGlmZl90aXRsZSk7CgkJLyoKCQkgKiBQYXNzIG1pbmltdW0gcmVxdWlyZWQgZGlmZi1vcHRpb25zIHRvIHJhbmdlLWRpZmY7IG90aGVycwoJCSAqIGNhbiBiZSBhZGRlZCBsYXRlciBpZiBkZWVtZWQgZGVzaXJhYmxlLgoJCSAqLwoJCWRpZmZfc2V0dXAoJm9wdHMpOwoJCW9wdHMuZmlsZSA9IG9wdC0+ZGlmZm9wdC5maWxlOwoJCW9wdHMudXNlX2NvbG9yID0gb3B0LT5kaWZmb3B0LnVzZV9jb2xvcjsKCQlkaWZmX3NldHVwX2RvbmUoJm9wdHMpOwoJCXNob3dfcmFuZ2VfZGlmZihvcHQtPnJkaWZmMSwgb3B0LT5yZGlmZjIsCgkJCQlvcHQtPmNyZWF0aW9uX2ZhY3RvciwgMSwgJm9wdHMsIE5VTEwpOwoKCQltZW1jcHkoJmRpZmZfcXVldWVkX2RpZmYsICZkcSwgc2l6ZW9mKGRpZmZfcXVldWVkX2RpZmYpKTsKCX0KfQoKaW50IGxvZ190cmVlX2RpZmZfZmx1c2goc3RydWN0IHJldl9pbmZvICpvcHQpCnsKCW9wdC0+c2hvd25fZGFzaGVzID0gMDsKCWRpZmZjb3JlX3N0ZCgmb3B0LT5kaWZmb3B0KTsKCglpZiAoZGlmZl9xdWV1ZV9pc19lbXB0eSgpKSB7CgkJaW50IHNhdmVkX2ZtdCA9IG9wdC0+ZGlmZm9wdC5vdXRwdXRfZm9ybWF0OwoJCW9wdC0+ZGlmZm9wdC5vdXRwdXRfZm9ybWF0ID0gRElGRl9GT1JNQVRfTk9fT1VUUFVUOwoJCWRpZmZfZmx1c2goJm9wdC0+ZGlmZm9wdCk7CgkJb3B0LT5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgPSBzYXZlZF9mbXQ7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKG9wdC0+bG9naW5mbyAmJiAhb3B0LT5ub19jb21taXRfaWQpIHsKCQlzaG93X2xvZyhvcHQpOwoJCWlmICgob3B0LT5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgJiB+RElGRl9GT1JNQVRfTk9fT1VUUFVUKSAmJgoJCSAgICBvcHQtPnZlcmJvc2VfaGVhZGVyICYmCgkJICAgIG9wdC0+Y29tbWl0X2Zvcm1hdCAhPSBDTUlUX0ZNVF9PTkVMSU5FICYmCgkJICAgICFjb21taXRfZm9ybWF0X2lzX2VtcHR5KG9wdC0+Y29tbWl0X2Zvcm1hdCkpIHsKCQkJLyoKCQkJICogV2hlbiBzaG93aW5nIGEgdmVyYm9zZSBoZWFkZXIgKGkuZS4gbG9nIG1lc3NhZ2UpLAoJCQkgKiBhbmQgbm90IGluIC0tcHJldHR5PW9uZWxpbmUgZm9ybWF0LCB3ZSB3b3VsZCB3YW50CgkJCSAqIGFuIGV4dHJhIG5ld2xpbmUgYmV0d2VlbiB0aGUgZW5kIG9mIGxvZyBhbmQgdGhlCgkJCSAqIGRpZmYvZGlmZnN0YXQgb3V0cHV0IGZvciByZWFkYWJpbGl0eS4KCQkJICovCgkJCWludCBwY2ggPSBESUZGX0ZPUk1BVF9ESUZGU1RBVCB8IERJRkZfRk9STUFUX1BBVENIOwoJCQlpZiAob3B0LT5kaWZmb3B0Lm91dHB1dF9wcmVmaXgpIHsKCQkJCXN0cnVjdCBzdHJidWYgKm1zZyA9IE5VTEw7CgkJCQltc2cgPSBvcHQtPmRpZmZvcHQub3V0cHV0X3ByZWZpeCgmb3B0LT5kaWZmb3B0LAoJCQkJCW9wdC0+ZGlmZm9wdC5vdXRwdXRfcHJlZml4X2RhdGEpOwoJCQkJZndyaXRlKG1zZy0+YnVmLCBtc2ctPmxlbiwgMSwgb3B0LT5kaWZmb3B0LmZpbGUpOwoJCQl9CgoJCQkvKgoJCQkgKiBXZSBtYXkgaGF2ZSBzaG93biB0aHJlZS1kYXNoZXMgbGluZSBlYXJseQoJCQkgKiBiZXR3ZWVuIGdlbmVyYXRlZCBjb21tZW50YXJ5IChub3RlcywgZXRjLikKCQkJICogYW5kIHRoZSBsb2cgbWVzc2FnZSwgaW4gd2hpY2ggY2FzZSB3ZSBvbmx5CgkJCSAqIHdhbnQgYSBibGFuayBsaW5lIGFmdGVyIHRoZSBjb21tZW50YXJ5CgkJCSAqIHdpdGhvdXQgKGFuIGV4dHJhKSB0aHJlZS1kYXNoZXMgbGluZS4KCQkJICogT3RoZXJ3aXNlLCB3ZSBzaG93IHRoZSB0aHJlZS1kYXNoZXMgbGluZSBpZgoJCQkgKiB3ZSBhcmUgc2hvd2luZyB0aGUgcGF0Y2ggd2l0aCBkaWZmc3RhdCwgYnV0CgkJCSAqIGluIHRoYXQgY2FzZSwgdGhlcmUgaXMgbm8gZXh0cmEgYmxhbmsgbGluZQoJCQkgKiBhZnRlciB0aGUgdGhyZWUtZGFzaGVzIGxpbmUuCgkJCSAqLwoJCQlpZiAoIW9wdC0+c2hvd25fZGFzaGVzICYmCgkJCSAgICAocGNoICYgb3B0LT5kaWZmb3B0Lm91dHB1dF9mb3JtYXQpID09IHBjaCkKCQkJCWZwcmludGYob3B0LT5kaWZmb3B0LmZpbGUsICItLS0iKTsKCQkJcHV0YygnXG4nLCBvcHQtPmRpZmZvcHQuZmlsZSk7CgkJfQoJfQoJZGlmZl9mbHVzaCgmb3B0LT5kaWZmb3B0KTsKCXJldHVybiAxOwp9CgpzdGF0aWMgaW50IGRvX2RpZmZfY29tYmluZWQoc3RydWN0IHJldl9pbmZvICpvcHQsIHN0cnVjdCBjb21taXQgKmNvbW1pdCkKewoJZGlmZl90cmVlX2NvbWJpbmVkX21lcmdlKGNvbW1pdCwgb3B0LT5kZW5zZV9jb21iaW5lZF9tZXJnZXMsIG9wdCk7CglyZXR1cm4gIW9wdC0+bG9naW5mbzsKfQoKLyoKICogU2hvdyB0aGUgZGlmZiBvZiBhIGNvbW1pdC4KICoKICogUmV0dXJuIHRydWUgaWYgd2UgcHJpbnRlZCBhbnkgbG9nIGluZm8gbWVzc2FnZXMKICovCnN0YXRpYyBpbnQgbG9nX3RyZWVfZGlmZihzdHJ1Y3QgcmV2X2luZm8gKm9wdCwgc3RydWN0IGNvbW1pdCAqY29tbWl0LCBzdHJ1Y3QgbG9nX2luZm8gKmxvZykKewoJaW50IHNob3dlZF9sb2c7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHM7CglzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQ7CgoJaWYgKCFvcHQtPmRpZmYgJiYgIW9wdC0+ZGlmZm9wdC5mbGFncy5leGl0X3dpdGhfc3RhdHVzKQoJCXJldHVybiAwOwoKCXBhcnNlX2NvbW1pdF9vcl9kaWUoY29tbWl0KTsKCW9pZCA9IGdldF9jb21taXRfdHJlZV9vaWQoY29tbWl0KTsKCgkvKiBSb290IGNvbW1pdD8gKi8KCXBhcmVudHMgPSBnZXRfc2F2ZWRfcGFyZW50cyhvcHQsIGNvbW1pdCk7CglpZiAoIXBhcmVudHMpIHsKCQlpZiAob3B0LT5zaG93X3Jvb3RfZGlmZikgewoJCQlkaWZmX3Jvb3RfdHJlZV9vaWQob2lkLCAiIiwgJm9wdC0+ZGlmZm9wdCk7CgkJCWxvZ190cmVlX2RpZmZfZmx1c2gob3B0KTsKCQl9CgkJcmV0dXJuICFvcHQtPmxvZ2luZm87Cgl9CgoJLyogTW9yZSB0aGFuIG9uZSBwYXJlbnQ/ICovCglpZiAocGFyZW50cyAmJiBwYXJlbnRzLT5uZXh0KSB7CgkJaWYgKG9wdC0+aWdub3JlX21lcmdlcykKCQkJcmV0dXJuIDA7CgkJZWxzZSBpZiAob3B0LT5jb21iaW5lX21lcmdlcykKCQkJcmV0dXJuIGRvX2RpZmZfY29tYmluZWQob3B0LCBjb21taXQpOwoJCWVsc2UgaWYgKG9wdC0+Zmlyc3RfcGFyZW50X29ubHkpIHsKCQkJLyoKCQkJICogR2VuZXJhdGUgbWVyZ2UgbG9nIGVudHJ5IG9ubHkgZm9yIHRoZSBmaXJzdAoJCQkgKiBwYXJlbnQsIHNob3dpbmcgc3VtbWFyeSBkaWZmIG9mIHRoZSBvdGhlcnMKCQkJICogd2UgbWVyZ2VkIF9pbl8uCgkJCSAqLwoJCQlwYXJzZV9jb21taXRfb3JfZGllKHBhcmVudHMtPml0ZW0pOwoJCQlkaWZmX3RyZWVfb2lkKGdldF9jb21taXRfdHJlZV9vaWQocGFyZW50cy0+aXRlbSksCgkJCQkgICAgICBvaWQsICIiLCAmb3B0LT5kaWZmb3B0KTsKCQkJbG9nX3RyZWVfZGlmZl9mbHVzaChvcHQpOwoJCQlyZXR1cm4gIW9wdC0+bG9naW5mbzsKCQl9CgoJCS8qIElmIHdlIHNob3cgaW5kaXZpZHVhbCBkaWZmcywgc2hvdyB0aGUgcGFyZW50IGluZm8gKi8KCQlsb2ctPnBhcmVudCA9IHBhcmVudHMtPml0ZW07Cgl9CgoJc2hvd2VkX2xvZyA9IDA7Cglmb3IgKDs7KSB7CgkJc3RydWN0IGNvbW1pdCAqcGFyZW50ID0gcGFyZW50cy0+aXRlbTsKCgkJcGFyc2VfY29tbWl0X29yX2RpZShwYXJlbnQpOwoJCWRpZmZfdHJlZV9vaWQoZ2V0X2NvbW1pdF90cmVlX29pZChwYXJlbnQpLAoJCQkgICAgICBvaWQsICIiLCAmb3B0LT5kaWZmb3B0KTsKCQlsb2dfdHJlZV9kaWZmX2ZsdXNoKG9wdCk7CgoJCXNob3dlZF9sb2cgfD0gIW9wdC0+bG9naW5mbzsKCgkJLyogU2V0IHVwIHRoZSBsb2cgaW5mbyBmb3IgdGhlIG5leHQgcGFyZW50LCBpZiBhbnkuLiAqLwoJCXBhcmVudHMgPSBwYXJlbnRzLT5uZXh0OwoJCWlmICghcGFyZW50cykKCQkJYnJlYWs7CgkJbG9nLT5wYXJlbnQgPSBwYXJlbnRzLT5pdGVtOwoJCW9wdC0+bG9naW5mbyA9IGxvZzsKCX0KCXJldHVybiBzaG93ZWRfbG9nOwp9CgppbnQgbG9nX3RyZWVfY29tbWl0KHN0cnVjdCByZXZfaW5mbyAqb3B0LCBzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCXN0cnVjdCBsb2dfaW5mbyBsb2c7CglpbnQgc2hvd24sIGNsb3NlX2ZpbGUgPSBvcHQtPmRpZmZvcHQuY2xvc2VfZmlsZTsKCglsb2cuY29tbWl0ID0gY29tbWl0OwoJbG9nLnBhcmVudCA9IE5VTEw7CglvcHQtPmxvZ2luZm8gPSAmbG9nOwoJb3B0LT5kaWZmb3B0LmNsb3NlX2ZpbGUgPSAwOwoKCWlmIChvcHQtPmxpbmVfbGV2ZWxfdHJhdmVyc2UpCgkJcmV0dXJuIGxpbmVfbG9nX3ByaW50KG9wdCwgY29tbWl0KTsKCglpZiAob3B0LT50cmFja19saW5lYXIgJiYgIW9wdC0+bGluZWFyICYmICFvcHQtPnJldmVyc2Vfb3V0cHV0X3N0YWdlKQoJCWZwcmludGYob3B0LT5kaWZmb3B0LmZpbGUsICJcbiVzXG4iLCBvcHQtPmJyZWFrX2Jhcik7CglzaG93biA9IGxvZ190cmVlX2RpZmYob3B0LCBjb21taXQsICZsb2cpOwoJaWYgKCFzaG93biAmJiBvcHQtPmxvZ2luZm8gJiYgb3B0LT5hbHdheXNfc2hvd19oZWFkZXIpIHsKCQlsb2cucGFyZW50ID0gTlVMTDsKCQlzaG93X2xvZyhvcHQpOwoJCXNob3duID0gMTsKCX0KCWlmIChvcHQtPnRyYWNrX2xpbmVhciAmJiAhb3B0LT5saW5lYXIgJiYgb3B0LT5yZXZlcnNlX291dHB1dF9zdGFnZSkKCQlmcHJpbnRmKG9wdC0+ZGlmZm9wdC5maWxlLCAiXG4lc1xuIiwgb3B0LT5icmVha19iYXIpOwoJb3B0LT5sb2dpbmZvID0gTlVMTDsKCW1heWJlX2ZsdXNoX29yX2RpZShvcHQtPmRpZmZvcHQuZmlsZSwgInN0ZG91dCIpOwoJaWYgKGNsb3NlX2ZpbGUpCgkJZmNsb3NlKG9wdC0+ZGlmZm9wdC5maWxlKTsKCXJldHVybiBzaG93bjsKfQo=",
    "text": "#include \"cache.h\"\n#include \"config.h\"\n#include \"diff.h\"\n#include \"object-store.h\"\n#include \"repository.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"graph.h\"\n#include \"log-tree.h\"\n#include \"reflog-walk.h\"\n#include \"refs.h\"\n#include \"string-list.h\"\n#include \"color.h\"\n#include \"gpg-interface.h\"\n#include \"sequencer.h\"\n#include \"line-log.h\"\n#include \"help.h\"\n#include \"interdiff.h\"\n#include \"range-diff.h\"\n\nstatic struct decoration name_decoration = { \"object names\" };\nstatic int decoration_loaded;\nstatic int decoration_flags;\n\nstatic char decoration_colors[][COLOR_MAXLEN] = {\n\tGIT_COLOR_RESET,\n\tGIT_COLOR_BOLD_GREEN,\t/* REF_LOCAL */\n\tGIT_COLOR_BOLD_RED,\t/* REF_REMOTE */\n\tGIT_COLOR_BOLD_YELLOW,\t/* REF_TAG */\n\tGIT_COLOR_BOLD_MAGENTA,\t/* REF_STASH */\n\tGIT_COLOR_BOLD_CYAN,\t/* REF_HEAD */\n\tGIT_COLOR_BOLD_BLUE,\t/* GRAFTED */\n};\n\nstatic const char *color_decorate_slots[] = {\n\t[DECORATION_REF_LOCAL]\t= \"branch\",\n\t[DECORATION_REF_REMOTE] = \"remoteBranch\",\n\t[DECORATION_REF_TAG]\t= \"tag\",\n\t[DECORATION_REF_STASH]\t= \"stash\",\n\t[DECORATION_REF_HEAD]\t= \"HEAD\",\n\t[DECORATION_GRAFTED]\t= \"grafted\",\n};\n\nstatic const char *decorate_get_color(int decorate_use_color, enum decoration_type ix)\n{\n\tif (want_color(decorate_use_color))\n\t\treturn decoration_colors[ix];\n\treturn \"\";\n}\n\ndefine_list_config_array(color_decorate_slots);\n\nint parse_decorate_color_config(const char *var, const char *slot_name, const char *value)\n{\n\tint slot = LOOKUP_CONFIG(color_decorate_slots, slot_name);\n\tif (slot < 0)\n\t\treturn 0;\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\treturn color_parse(value, decoration_colors[slot]);\n}\n\n/*\n * log-tree.c uses DIFF_OPT_TST for determining whether to use color\n * for showing the commit sha1, use the same check for --decorate\n */\n#define decorate_get_color_opt(o, ix) \\\n\tdecorate_get_color((o)->use_color, ix)\n\nvoid add_name_decoration(enum decoration_type type, const char *name, struct object *obj)\n{\n\tstruct name_decoration *res;\n\tFLEX_ALLOC_STR(res, name, name);\n\tres->type = type;\n\tres->next = add_decoration(&name_decoration, obj, res);\n}\n\nconst struct name_decoration *get_name_decoration(const struct object *obj)\n{\n\tload_ref_decorations(NULL, DECORATE_SHORT_REFS);\n\treturn lookup_decoration(&name_decoration, obj);\n}\n\nstatic int add_ref_decoration(const char *refname, const struct object_id *oid,\n\t\t\t      int flags, void *cb_data)\n{\n\tstruct object *obj;\n\tenum decoration_type type = DECORATION_NONE;\n\tstruct decoration_filter *filter = (struct decoration_filter *)cb_data;\n\n\tif (filter && !ref_filter_match(refname,\n\t\t\t      filter->include_ref_pattern,\n\t\t\t      filter->exclude_ref_pattern))\n\t\treturn 0;\n\n\tif (starts_with(refname, git_replace_ref_base)) {\n\t\tstruct object_id original_oid;\n\t\tif (!read_replace_refs)\n\t\t\treturn 0;\n\t\tif (get_oid_hex(refname + strlen(git_replace_ref_base),\n\t\t\t\t&original_oid)) {\n\t\t\twarning(\"invalid replace ref %s\", refname);\n\t\t\treturn 0;\n\t\t}\n\t\tobj = parse_object(the_repository, &original_oid);\n\t\tif (obj)\n\t\t\tadd_name_decoration(DECORATION_GRAFTED, \"replaced\", obj);\n\t\treturn 0;\n\t}\n\n\tobj = parse_object(the_repository, oid);\n\tif (!obj)\n\t\treturn 0;\n\n\tif (starts_with(refname, \"refs/heads/\"))\n\t\ttype = DECORATION_REF_LOCAL;\n\telse if (starts_with(refname, \"refs/remotes/\"))\n\t\ttype = DECORATION_REF_REMOTE;\n\telse if (starts_with(refname, \"refs/tags/\"))\n\t\ttype = DECORATION_REF_TAG;\n\telse if (!strcmp(refname, \"refs/stash\"))\n\t\ttype = DECORATION_REF_STASH;\n\telse if (!strcmp(refname, \"HEAD\"))\n\t\ttype = DECORATION_REF_HEAD;\n\n\tadd_name_decoration(type, refname, obj);\n\twhile (obj->type == OBJ_TAG) {\n\t\tobj = ((struct tag *)obj)->tagged;\n\t\tif (!obj)\n\t\t\tbreak;\n\t\tif (!obj->parsed)\n\t\t\tparse_object(the_repository, &obj->oid);\n\t\tadd_name_decoration(DECORATION_REF_TAG, refname, obj);\n\t}\n\treturn 0;\n}\n\nstatic int add_graft_decoration(const struct commit_graft *graft, void *cb_data)\n{\n\tstruct commit *commit = lookup_commit(the_repository, &graft->oid);\n\tif (!commit)\n\t\treturn 0;\n\tadd_name_decoration(DECORATION_GRAFTED, \"grafted\", &commit->object);\n\treturn 0;\n}\n\nvoid load_ref_decorations(struct decoration_filter *filter, int flags)\n{\n\tif (!decoration_loaded) {\n\t\tif (filter) {\n\t\t\tstruct string_list_item *item;\n\t\t\tfor_each_string_list_item(item, filter->exclude_ref_pattern) {\n\t\t\t\tnormalize_glob_ref(item, NULL, item->string);\n\t\t\t}\n\t\t\tfor_each_string_list_item(item, filter->include_ref_pattern) {\n\t\t\t\tnormalize_glob_ref(item, NULL, item->string);\n\t\t\t}\n\t\t}\n\t\tdecoration_loaded = 1;\n\t\tdecoration_flags = flags;\n\t\tfor_each_ref(add_ref_decoration, filter);\n\t\thead_ref(add_ref_decoration, filter);\n\t\tfor_each_commit_graft(add_graft_decoration, filter);\n\t}\n}\n\nstatic void show_parents(struct commit *commit, int abbrev, FILE *file)\n{\n\tstruct commit_list *p;\n\tfor (p = commit->parents; p ; p = p->next) {\n\t\tstruct commit *parent = p->item;\n\t\tfprintf(file, \" %s\", find_unique_abbrev(&parent->object.oid, abbrev));\n\t}\n}\n\nstatic void show_children(struct rev_info *opt, struct commit *commit, int abbrev)\n{\n\tstruct commit_list *p = lookup_decoration(&opt->children, &commit->object);\n\tfor ( ; p; p = p->next) {\n\t\tfprintf(opt->diffopt.file, \" %s\", find_unique_abbrev(&p->item->object.oid, abbrev));\n\t}\n}\n\n/*\n * Do we have HEAD in the output, and also the branch it points at?\n * If so, find that decoration entry for that current branch.\n */\nstatic const struct name_decoration *current_pointed_by_HEAD(const struct name_decoration *decoration)\n{\n\tconst struct name_decoration *list, *head = NULL;\n\tconst char *branch_name = NULL;\n\tint rru_flags;\n\n\t/* First find HEAD */\n\tfor (list = decoration; list; list = list->next)\n\t\tif (list->type == DECORATION_REF_HEAD) {\n\t\t\thead = list;\n\t\t\tbreak;\n\t\t}\n\tif (!head)\n\t\treturn NULL;\n\n\t/* Now resolve and find the matching current branch */\n\tbranch_name = resolve_ref_unsafe(\"HEAD\", 0, NULL, &rru_flags);\n\tif (!branch_name || !(rru_flags & REF_ISSYMREF))\n\t\treturn NULL;\n\n\tif (!starts_with(branch_name, \"refs/\"))\n\t\treturn NULL;\n\n\t/* OK, do we have that ref in the list? */\n\tfor (list = decoration; list; list = list->next)\n\t\tif ((list->type == DECORATION_REF_LOCAL) &&\n\t\t    !strcmp(branch_name, list->name)) {\n\t\t\treturn list;\n\t\t}\n\n\treturn NULL;\n}\n\nstatic void show_name(struct strbuf *sb, const struct name_decoration *decoration)\n{\n\tif (decoration_flags == DECORATE_SHORT_REFS)\n\t\tstrbuf_addstr(sb, prettify_refname(decoration->name));\n\telse\n\t\tstrbuf_addstr(sb, decoration->name);\n}\n\n/*\n * The caller makes sure there is no funny color before calling.\n * format_decorations_extended makes sure the same after return.\n */\nvoid format_decorations_extended(struct strbuf *sb,\n\t\t\tconst struct commit *commit,\n\t\t\tint use_color,\n\t\t\tconst char *prefix,\n\t\t\tconst char *separator,\n\t\t\tconst char *suffix)\n{\n\tconst struct name_decoration *decoration;\n\tconst struct name_decoration *current_and_HEAD;\n\tconst char *color_commit =\n\t\tdiff_get_color(use_color, DIFF_COMMIT);\n\tconst char *color_reset =\n\t\tdecorate_get_color(use_color, DECORATION_NONE);\n\n\tdecoration = get_name_decoration(&commit->object);\n\tif (!decoration)\n\t\treturn;\n\n\tcurrent_and_HEAD = current_pointed_by_HEAD(decoration);\n\twhile (decoration) {\n\t\t/*\n\t\t * When both current and HEAD are there, only\n\t\t * show HEAD->current where HEAD would have\n\t\t * appeared, skipping the entry for current.\n\t\t */\n\t\tif (decoration != current_and_HEAD) {\n\t\t\tstrbuf_addstr(sb, color_commit);\n\t\t\tstrbuf_addstr(sb, prefix);\n\t\t\tstrbuf_addstr(sb, color_reset);\n\t\t\tstrbuf_addstr(sb, decorate_get_color(use_color, decoration->type));\n\t\t\tif (decoration->type == DECORATION_REF_TAG)\n\t\t\t\tstrbuf_addstr(sb, \"tag: \");\n\n\t\t\tshow_name(sb, decoration);\n\n\t\t\tif (current_and_HEAD &&\n\t\t\t    decoration->type == DECORATION_REF_HEAD) {\n\t\t\t\tstrbuf_addstr(sb, \" -> \");\n\t\t\t\tstrbuf_addstr(sb, color_reset);\n\t\t\t\tstrbuf_addstr(sb, decorate_get_color(use_color, current_and_HEAD->type));\n\t\t\t\tshow_name(sb, current_and_HEAD);\n\t\t\t}\n\t\t\tstrbuf_addstr(sb, color_reset);\n\n\t\t\tprefix = separator;\n\t\t}\n\t\tdecoration = decoration->next;\n\t}\n\tstrbuf_addstr(sb, color_commit);\n\tstrbuf_addstr(sb, suffix);\n\tstrbuf_addstr(sb, color_reset);\n}\n\nvoid show_decorations(struct rev_info *opt, struct commit *commit)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tif (opt->sources) {\n\t\tchar **slot = revision_sources_peek(opt->sources, commit);\n\n\t\tif (slot && *slot)\n\t\t\tfprintf(opt->diffopt.file, \"\\t%s\", *slot);\n\t}\n\tif (!opt->show_decorations)\n\t\treturn;\n\tformat_decorations(&sb, commit, opt->diffopt.use_color);\n\tfputs(sb.buf, opt->diffopt.file);\n\tstrbuf_release(&sb);\n}\n\nstatic unsigned int digits_in_number(unsigned int number)\n{\n\tunsigned int i = 10, result = 1;\n\twhile (i <= number) {\n\t\ti *= 10;\n\t\tresult++;\n\t}\n\treturn result;\n}\n\nvoid fmt_output_subject(struct strbuf *filename,\n\t\t\tconst char *subject,\n\t\t\tstruct rev_info *info)\n{\n\tconst char *suffix = info->patch_suffix;\n\tint nr = info->nr;\n\tint start_len = filename->len;\n\tint max_len = start_len + FORMAT_PATCH_NAME_MAX - (strlen(suffix) + 1);\n\n\tif (0 < info->reroll_count)\n\t\tstrbuf_addf(filename, \"v%d-\", info->reroll_count);\n\tstrbuf_addf(filename, \"%04d-%s\", nr, subject);\n\n\tif (max_len < filename->len)\n\t\tstrbuf_setlen(filename, max_len);\n\tstrbuf_addstr(filename, suffix);\n}\n\nvoid fmt_output_commit(struct strbuf *filename,\n\t\t       struct commit *commit,\n\t\t       struct rev_info *info)\n{\n\tstruct pretty_print_context ctx = {0};\n\tstruct strbuf subject = STRBUF_INIT;\n\n\tformat_commit_message(commit, \"%f\", &subject, &ctx);\n\tfmt_output_subject(filename, subject.buf, info);\n\tstrbuf_release(&subject);\n}\n\nvoid fmt_output_email_subject(struct strbuf *sb, struct rev_info *opt)\n{\n\tif (opt->total > 0) {\n\t\tstrbuf_addf(sb, \"Subject: [%s%s%0*d/%d] \",\n\t\t\t    opt->subject_prefix,\n\t\t\t    *opt->subject_prefix ? \" \" : \"\",\n\t\t\t    digits_in_number(opt->total),\n\t\t\t    opt->nr, opt->total);\n\t} else if (opt->total == 0 && opt->subject_prefix && *opt->subject_prefix) {\n\t\tstrbuf_addf(sb, \"Subject: [%s] \",\n\t\t\t    opt->subject_prefix);\n\t} else {\n\t\tstrbuf_addstr(sb, \"Subject: \");\n\t}\n}\n\nvoid log_write_email_headers(struct rev_info *opt, struct commit *commit,\n\t\t\t     const char **extra_headers_p,\n\t\t\t     int *need_8bit_cte_p,\n\t\t\t     int maybe_multipart)\n{\n\tconst char *extra_headers = opt->extra_headers;\n\tconst char *name = oid_to_hex(opt->zero_commit ?\n\t\t\t\t      &null_oid : &commit->object.oid);\n\n\t*need_8bit_cte_p = 0; /* unknown */\n\n\tfprintf(opt->diffopt.file, \"From %s Mon Sep 17 00:00:00 2001\\n\", name);\n\tgraph_show_oneline(opt->graph);\n\tif (opt->message_id) {\n\t\tfprintf(opt->diffopt.file, \"Message-Id: <%s>\\n\", opt->message_id);\n\t\tgraph_show_oneline(opt->graph);\n\t}\n\tif (opt->ref_message_ids && opt->ref_message_ids->nr > 0) {\n\t\tint i, n;\n\t\tn = opt->ref_message_ids->nr;\n\t\tfprintf(opt->diffopt.file, \"In-Reply-To: <%s>\\n\", opt->ref_message_ids->items[n-1].string);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfprintf(opt->diffopt.file, \"%s<%s>\\n\", (i > 0 ? \"\\t\" : \"References: \"),\n\t\t\t       opt->ref_message_ids->items[i].string);\n\t\tgraph_show_oneline(opt->graph);\n\t}\n\tif (opt->mime_boundary && maybe_multipart) {\n\t\tstatic struct strbuf subject_buffer = STRBUF_INIT;\n\t\tstatic struct strbuf buffer = STRBUF_INIT;\n\t\tstruct strbuf filename =  STRBUF_INIT;\n\t\t*need_8bit_cte_p = -1; /* NEVER */\n\n\t\tstrbuf_reset(&subject_buffer);\n\t\tstrbuf_reset(&buffer);\n\n\t\tstrbuf_addf(&subject_buffer,\n\t\t\t \"%s\"\n\t\t\t \"MIME-Version: 1.0\\n\"\n\t\t\t \"Content-Type: multipart/mixed;\"\n\t\t\t \" boundary=\\\"%s%s\\\"\\n\"\n\t\t\t \"\\n\"\n\t\t\t \"This is a multi-part message in MIME \"\n\t\t\t \"format.\\n\"\n\t\t\t \"--%s%s\\n\"\n\t\t\t \"Content-Type: text/plain; \"\n\t\t\t \"charset=UTF-8; format=fixed\\n\"\n\t\t\t \"Content-Transfer-Encoding: 8bit\\n\\n\",\n\t\t\t extra_headers ? extra_headers : \"\",\n\t\t\t mime_boundary_leader, opt->mime_boundary,\n\t\t\t mime_boundary_leader, opt->mime_boundary);\n\t\textra_headers = subject_buffer.buf;\n\n\t\tif (opt->numbered_files)\n\t\t\tstrbuf_addf(&filename, \"%d\", opt->nr);\n\t\telse\n\t\t\tfmt_output_commit(&filename, commit, opt);\n\t\tstrbuf_addf(&buffer,\n\t\t\t \"\\n--%s%s\\n\"\n\t\t\t \"Content-Type: text/x-patch;\"\n\t\t\t \" name=\\\"%s\\\"\\n\"\n\t\t\t \"Content-Transfer-Encoding: 8bit\\n\"\n\t\t\t \"Content-Disposition: %s;\"\n\t\t\t \" filename=\\\"%s\\\"\\n\\n\",\n\t\t\t mime_boundary_leader, opt->mime_boundary,\n\t\t\t filename.buf,\n\t\t\t opt->no_inline ? \"attachment\" : \"inline\",\n\t\t\t filename.buf);\n\t\topt->diffopt.stat_sep = buffer.buf;\n\t\tstrbuf_release(&filename);\n\t}\n\t*extra_headers_p = extra_headers;\n}\n\nstatic void show_sig_lines(struct rev_info *opt, int status, const char *bol)\n{\n\tconst char *color, *reset, *eol;\n\n\tcolor = diff_get_color_opt(&opt->diffopt,\n\t\t\t\t   status ? DIFF_WHITESPACE : DIFF_FRAGINFO);\n\treset = diff_get_color_opt(&opt->diffopt, DIFF_RESET);\n\twhile (*bol) {\n\t\teol = strchrnul(bol, '\\n');\n\t\tfprintf(opt->diffopt.file, \"%s%.*s%s%s\", color, (int)(eol - bol), bol, reset,\n\t\t       *eol ? \"\\n\" : \"\");\n\t\tgraph_show_oneline(opt->graph);\n\t\tbol = (*eol) ? (eol + 1) : eol;\n\t}\n}\n\nstatic void show_signature(struct rev_info *opt, struct commit *commit)\n{\n\tstruct strbuf payload = STRBUF_INIT;\n\tstruct strbuf signature = STRBUF_INIT;\n\tstruct signature_check sigc = { 0 };\n\tint status;\n\n\tif (parse_signed_commit(commit, &payload, &signature) <= 0)\n\t\tgoto out;\n\n\tstatus = check_signature(payload.buf, payload.len, signature.buf,\n\t\t\t\t signature.len, &sigc);\n\tif (status && !sigc.gpg_output)\n\t\tshow_sig_lines(opt, status, \"No signature\\n\");\n\telse\n\t\tshow_sig_lines(opt, status, sigc.gpg_output);\n\tsignature_check_clear(&sigc);\n\n out:\n\tstrbuf_release(&payload);\n\tstrbuf_release(&signature);\n}\n\nstatic int which_parent(const struct object_id *oid, const struct commit *commit)\n{\n\tint nth;\n\tconst struct commit_list *parent;\n\n\tfor (nth = 0, parent = commit->parents; parent; parent = parent->next) {\n\t\tif (oideq(&parent->item->object.oid, oid))\n\t\t\treturn nth;\n\t\tnth++;\n\t}\n\treturn -1;\n}\n\nstatic int is_common_merge(const struct commit *commit)\n{\n\treturn (commit->parents\n\t\t&& commit->parents->next\n\t\t&& !commit->parents->next->next);\n}\n\nstatic int show_one_mergetag(struct commit *commit,\n\t\t\t     struct commit_extra_header *extra,\n\t\t\t     void *data)\n{\n\tstruct rev_info *opt = (struct rev_info *)data;\n\tstruct object_id oid;\n\tstruct tag *tag;\n\tstruct strbuf verify_message;\n\tstruct signature_check sigc = { 0 };\n\tint status, nth;\n\tsize_t payload_size;\n\n\thash_object_file(the_hash_algo, extra->value, extra->len,\n\t\t\t type_name(OBJ_TAG), &oid);\n\ttag = lookup_tag(the_repository, &oid);\n\tif (!tag)\n\t\treturn -1; /* error message already given */\n\n\tstrbuf_init(&verify_message, 256);\n\tif (parse_tag_buffer(the_repository, tag, extra->value, extra->len))\n\t\tstrbuf_addstr(&verify_message, \"malformed mergetag\\n\");\n\telse if (is_common_merge(commit) &&\n\t\t oideq(&tag->tagged->oid,\n\t\t       &commit->parents->next->item->object.oid))\n\t\tstrbuf_addf(&verify_message,\n\t\t\t    \"merged tag '%s'\\n\", tag->tag);\n\telse if ((nth = which_parent(&tag->tagged->oid, commit)) < 0)\n\t\tstrbuf_addf(&verify_message, \"tag %s names a non-parent %s\\n\",\n\t\t\t\t    tag->tag, oid_to_hex(&tag->tagged->oid));\n\telse\n\t\tstrbuf_addf(&verify_message,\n\t\t\t    \"parent #%d, tagged '%s'\\n\", nth + 1, tag->tag);\n\n\tpayload_size = parse_signature(extra->value, extra->len);\n\tstatus = -1;\n\tif (extra->len > payload_size) {\n\t\t/* could have a good signature */\n\t\tstatus = check_signature(extra->value, payload_size,\n\t\t\t\t\t extra->value + payload_size,\n\t\t\t\t\t extra->len - payload_size, &sigc);\n\t\tif (sigc.gpg_output)\n\t\t\tstrbuf_addstr(&verify_message, sigc.gpg_output);\n\t\telse\n\t\t\tstrbuf_addstr(&verify_message, \"No signature\\n\");\n\t\tsignature_check_clear(&sigc);\n\t\t/* otherwise we couldn't verify, which is shown as bad */\n\t}\n\n\tshow_sig_lines(opt, status, verify_message.buf);\n\tstrbuf_release(&verify_message);\n\treturn 0;\n}\n\nstatic int show_mergetag(struct rev_info *opt, struct commit *commit)\n{\n\treturn for_each_mergetag(show_one_mergetag, commit, opt);\n}\n\nstatic void next_commentary_block(struct rev_info *opt, struct strbuf *sb)\n{\n\tconst char *x = opt->shown_dashes ? \"\\n\" : \"---\\n\";\n\tif (sb)\n\t\tstrbuf_addstr(sb, x);\n\telse\n\t\tfputs(x, opt->diffopt.file);\n\topt->shown_dashes = 1;\n}\n\nvoid show_log(struct rev_info *opt)\n{\n\tstruct strbuf msgbuf = STRBUF_INIT;\n\tstruct log_info *log = opt->loginfo;\n\tstruct commit *commit = log->commit, *parent = log->parent;\n\tint abbrev_commit = opt->abbrev_commit ? opt->abbrev : the_hash_algo->hexsz;\n\tconst char *extra_headers = opt->extra_headers;\n\tstruct pretty_print_context ctx = {0};\n\n\topt->loginfo = NULL;\n\tif (!opt->verbose_header) {\n\t\tgraph_show_commit(opt->graph);\n\n\t\tif (!opt->graph)\n\t\t\tput_revision_mark(opt, commit);\n\t\tfputs(find_unique_abbrev(&commit->object.oid, abbrev_commit), opt->diffopt.file);\n\t\tif (opt->print_parents)\n\t\t\tshow_parents(commit, abbrev_commit, opt->diffopt.file);\n\t\tif (opt->children.name)\n\t\t\tshow_children(opt, commit, abbrev_commit);\n\t\tshow_decorations(opt, commit);\n\t\tif (opt->graph && !graph_is_commit_finished(opt->graph)) {\n\t\t\tputc('\\n', opt->diffopt.file);\n\t\t\tgraph_show_remainder(opt->graph);\n\t\t}\n\t\tputc(opt->diffopt.line_termination, opt->diffopt.file);\n\t\treturn;\n\t}\n\n\t/*\n\t * If use_terminator is set, we already handled any record termination\n\t * at the end of the last record.\n\t * Otherwise, add a diffopt.line_termination character before all\n\t * entries but the first.  (IOW, as a separator between entries)\n\t */\n\tif (opt->shown_one && !opt->use_terminator) {\n\t\t/*\n\t\t * If entries are separated by a newline, the output\n\t\t * should look human-readable.  If the last entry ended\n\t\t * with a newline, print the graph output before this\n\t\t * newline.  Otherwise it will end up as a completely blank\n\t\t * line and will look like a gap in the graph.\n\t\t *\n\t\t * If the entry separator is not a newline, the output is\n\t\t * primarily intended for programmatic consumption, and we\n\t\t * never want the extra graph output before the entry\n\t\t * separator.\n\t\t */\n\t\tif (opt->diffopt.line_termination == '\\n' &&\n\t\t    !opt->missing_newline)\n\t\t\tgraph_show_padding(opt->graph);\n\t\tputc(opt->diffopt.line_termination, opt->diffopt.file);\n\t}\n\topt->shown_one = 1;\n\n\t/*\n\t * If the history graph was requested,\n\t * print the graph, up to this commit's line\n\t */\n\tgraph_show_commit(opt->graph);\n\n\t/*\n\t * Print header line of header..\n\t */\n\n\tif (cmit_fmt_is_mail(opt->commit_format)) {\n\t\tlog_write_email_headers(opt, commit, &extra_headers,\n\t\t\t\t\t&ctx.need_8bit_cte, 1);\n\t\tctx.rev = opt;\n\t\tctx.print_email_subject = 1;\n\t} else if (opt->commit_format != CMIT_FMT_USERFORMAT) {\n\t\tfputs(diff_get_color_opt(&opt->diffopt, DIFF_COMMIT), opt->diffopt.file);\n\t\tif (opt->commit_format != CMIT_FMT_ONELINE)\n\t\t\tfputs(\"commit \", opt->diffopt.file);\n\n\t\tif (!opt->graph)\n\t\t\tput_revision_mark(opt, commit);\n\t\tfputs(find_unique_abbrev(&commit->object.oid,\n\t\t\t\t\t abbrev_commit),\n\t\t      opt->diffopt.file);\n\t\tif (opt->print_parents)\n\t\t\tshow_parents(commit, abbrev_commit, opt->diffopt.file);\n\t\tif (opt->children.name)\n\t\t\tshow_children(opt, commit, abbrev_commit);\n\t\tif (parent)\n\t\t\tfprintf(opt->diffopt.file, \" (from %s)\",\n\t\t\t       find_unique_abbrev(&parent->object.oid, abbrev_commit));\n\t\tfputs(diff_get_color_opt(&opt->diffopt, DIFF_RESET), opt->diffopt.file);\n\t\tshow_decorations(opt, commit);\n\t\tif (opt->commit_format == CMIT_FMT_ONELINE) {\n\t\t\tputc(' ', opt->diffopt.file);\n\t\t} else {\n\t\t\tputc('\\n', opt->diffopt.file);\n\t\t\tgraph_show_oneline(opt->graph);\n\t\t}\n\t\tif (opt->reflog_info) {\n\t\t\t/*\n\t\t\t * setup_revisions() ensures that opt->reflog_info\n\t\t\t * and opt->graph cannot both be set,\n\t\t\t * so we don't need to worry about printing the\n\t\t\t * graph info here.\n\t\t\t */\n\t\t\tshow_reflog_message(opt->reflog_info,\n\t\t\t\t\t    opt->commit_format == CMIT_FMT_ONELINE,\n\t\t\t\t\t    &opt->date_mode,\n\t\t\t\t\t    opt->date_mode_explicit);\n\t\t\tif (opt->commit_format == CMIT_FMT_ONELINE)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tif (opt->show_signature) {\n\t\tshow_signature(opt, commit);\n\t\tshow_mergetag(opt, commit);\n\t}\n\n\tif (opt->show_notes) {\n\t\tint raw;\n\t\tstruct strbuf notebuf = STRBUF_INIT;\n\n\t\traw = (opt->commit_format == CMIT_FMT_USERFORMAT);\n\t\tformat_display_notes(&commit->object.oid, &notebuf,\n\t\t\t\t     get_log_output_encoding(), raw);\n\t\tctx.notes_message = strbuf_detach(&notebuf, NULL);\n\t}\n\n\t/*\n\t * And then the pretty-printed message itself\n\t */\n\tif (ctx.need_8bit_cte >= 0 && opt->add_signoff)\n\t\tctx.need_8bit_cte =\n\t\t\thas_non_ascii(fmt_name(WANT_COMMITTER_IDENT));\n\tctx.date_mode = opt->date_mode;\n\tctx.date_mode_explicit = opt->date_mode_explicit;\n\tctx.abbrev = opt->diffopt.abbrev;\n\tctx.after_subject = extra_headers;\n\tctx.preserve_subject = opt->preserve_subject;\n\tctx.encode_email_headers = opt->encode_email_headers;\n\tctx.reflog_info = opt->reflog_info;\n\tctx.fmt = opt->commit_format;\n\tctx.mailmap = opt->mailmap;\n\tctx.color = opt->diffopt.use_color;\n\tctx.expand_tabs_in_log = opt->expand_tabs_in_log;\n\tctx.output_encoding = get_log_output_encoding();\n\tctx.rev = opt;\n\tif (opt->from_ident.mail_begin && opt->from_ident.name_begin)\n\t\tctx.from_ident = &opt->from_ident;\n\tif (opt->graph)\n\t\tctx.graph_width = graph_width(opt->graph);\n\tpretty_print_commit(&ctx, commit, &msgbuf);\n\n\tif (opt->add_signoff)\n\t\tappend_signoff(&msgbuf, 0, APPEND_SIGNOFF_DEDUP);\n\n\tif ((ctx.fmt != CMIT_FMT_USERFORMAT) &&\n\t    ctx.notes_message && *ctx.notes_message) {\n\t\tif (cmit_fmt_is_mail(ctx.fmt))\n\t\t\tnext_commentary_block(opt, &msgbuf);\n\t\tstrbuf_addstr(&msgbuf, ctx.notes_message);\n\t}\n\n\tif (opt->show_log_size) {\n\t\tfprintf(opt->diffopt.file, \"log size %i\\n\", (int)msgbuf.len);\n\t\tgraph_show_oneline(opt->graph);\n\t}\n\n\t/*\n\t * Set opt->missing_newline if msgbuf doesn't\n\t * end in a newline (including if it is empty)\n\t */\n\tif (!msgbuf.len || msgbuf.buf[msgbuf.len - 1] != '\\n')\n\t\topt->missing_newline = 1;\n\telse\n\t\topt->missing_newline = 0;\n\n\tgraph_show_commit_msg(opt->graph, opt->diffopt.file, &msgbuf);\n\tif (opt->use_terminator && !commit_format_is_empty(opt->commit_format)) {\n\t\tif (!opt->missing_newline)\n\t\t\tgraph_show_padding(opt->graph);\n\t\tputc(opt->diffopt.line_termination, opt->diffopt.file);\n\t}\n\n\tstrbuf_release(&msgbuf);\n\tfree(ctx.notes_message);\n\n\tif (cmit_fmt_is_mail(ctx.fmt) && opt->idiff_oid1) {\n\t\tstruct diff_queue_struct dq;\n\n\t\tmemcpy(&dq, &diff_queued_diff, sizeof(diff_queued_diff));\n\t\tDIFF_QUEUE_CLEAR(&diff_queued_diff);\n\n\t\tnext_commentary_block(opt, NULL);\n\t\tfprintf_ln(opt->diffopt.file, \"%s\", opt->idiff_title);\n\t\tshow_interdiff(opt, 2);\n\n\t\tmemcpy(&diff_queued_diff, &dq, sizeof(diff_queued_diff));\n\t}\n\n\tif (cmit_fmt_is_mail(ctx.fmt) && opt->rdiff1) {\n\t\tstruct diff_queue_struct dq;\n\t\tstruct diff_options opts;\n\n\t\tmemcpy(&dq, &diff_queued_diff, sizeof(diff_queued_diff));\n\t\tDIFF_QUEUE_CLEAR(&diff_queued_diff);\n\n\t\tnext_commentary_block(opt, NULL);\n\t\tfprintf_ln(opt->diffopt.file, \"%s\", opt->rdiff_title);\n\t\t/*\n\t\t * Pass minimum required diff-options to range-diff; others\n\t\t * can be added later if deemed desirable.\n\t\t */\n\t\tdiff_setup(&opts);\n\t\topts.file = opt->diffopt.file;\n\t\topts.use_color = opt->diffopt.use_color;\n\t\tdiff_setup_done(&opts);\n\t\tshow_range_diff(opt->rdiff1, opt->rdiff2,\n\t\t\t\topt->creation_factor, 1, &opts, NULL);\n\n\t\tmemcpy(&diff_queued_diff, &dq, sizeof(diff_queued_diff));\n\t}\n}\n\nint log_tree_diff_flush(struct rev_info *opt)\n{\n\topt->shown_dashes = 0;\n\tdiffcore_std(&opt->diffopt);\n\n\tif (diff_queue_is_empty()) {\n\t\tint saved_fmt = opt->diffopt.output_format;\n\t\topt->diffopt.output_format = DIFF_FORMAT_NO_OUTPUT;\n\t\tdiff_flush(&opt->diffopt);\n\t\topt->diffopt.output_format = saved_fmt;\n\t\treturn 0;\n\t}\n\n\tif (opt->loginfo && !opt->no_commit_id) {\n\t\tshow_log(opt);\n\t\tif ((opt->diffopt.output_format & ~DIFF_FORMAT_NO_OUTPUT) &&\n\t\t    opt->verbose_header &&\n\t\t    opt->commit_format != CMIT_FMT_ONELINE &&\n\t\t    !commit_format_is_empty(opt->commit_format)) {\n\t\t\t/*\n\t\t\t * When showing a verbose header (i.e. log message),\n\t\t\t * and not in --pretty=oneline format, we would want\n\t\t\t * an extra newline between the end of log and the\n\t\t\t * diff/diffstat output for readability.\n\t\t\t */\n\t\t\tint pch = DIFF_FORMAT_DIFFSTAT | DIFF_FORMAT_PATCH;\n\t\t\tif (opt->diffopt.output_prefix) {\n\t\t\t\tstruct strbuf *msg = NULL;\n\t\t\t\tmsg = opt->diffopt.output_prefix(&opt->diffopt,\n\t\t\t\t\topt->diffopt.output_prefix_data);\n\t\t\t\tfwrite(msg->buf, msg->len, 1, opt->diffopt.file);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We may have shown three-dashes line early\n\t\t\t * between generated commentary (notes, etc.)\n\t\t\t * and the log message, in which case we only\n\t\t\t * want a blank line after the commentary\n\t\t\t * without (an extra) three-dashes line.\n\t\t\t * Otherwise, we show the three-dashes line if\n\t\t\t * we are showing the patch with diffstat, but\n\t\t\t * in that case, there is no extra blank line\n\t\t\t * after the three-dashes line.\n\t\t\t */\n\t\t\tif (!opt->shown_dashes &&\n\t\t\t    (pch & opt->diffopt.output_format) == pch)\n\t\t\t\tfprintf(opt->diffopt.file, \"---\");\n\t\t\tputc('\\n', opt->diffopt.file);\n\t\t}\n\t}\n\tdiff_flush(&opt->diffopt);\n\treturn 1;\n}\n\nstatic int do_diff_combined(struct rev_info *opt, struct commit *commit)\n{\n\tdiff_tree_combined_merge(commit, opt->dense_combined_merges, opt);\n\treturn !opt->loginfo;\n}\n\n/*\n * Show the diff of a commit.\n *\n * Return true if we printed any log info messages\n */\nstatic int log_tree_diff(struct rev_info *opt, struct commit *commit, struct log_info *log)\n{\n\tint showed_log;\n\tstruct commit_list *parents;\n\tstruct object_id *oid;\n\n\tif (!opt->diff && !opt->diffopt.flags.exit_with_status)\n\t\treturn 0;\n\n\tparse_commit_or_die(commit);\n\toid = get_commit_tree_oid(commit);\n\n\t/* Root commit? */\n\tparents = get_saved_parents(opt, commit);\n\tif (!parents) {\n\t\tif (opt->show_root_diff) {\n\t\t\tdiff_root_tree_oid(oid, \"\", &opt->diffopt);\n\t\t\tlog_tree_diff_flush(opt);\n\t\t}\n\t\treturn !opt->loginfo;\n\t}\n\n\t/* More than one parent? */\n\tif (parents && parents->next) {\n\t\tif (opt->ignore_merges)\n\t\t\treturn 0;\n\t\telse if (opt->combine_merges)\n\t\t\treturn do_diff_combined(opt, commit);\n\t\telse if (opt->first_parent_only) {\n\t\t\t/*\n\t\t\t * Generate merge log entry only for the first\n\t\t\t * parent, showing summary diff of the others\n\t\t\t * we merged _in_.\n\t\t\t */\n\t\t\tparse_commit_or_die(parents->item);\n\t\t\tdiff_tree_oid(get_commit_tree_oid(parents->item),\n\t\t\t\t      oid, \"\", &opt->diffopt);\n\t\t\tlog_tree_diff_flush(opt);\n\t\t\treturn !opt->loginfo;\n\t\t}\n\n\t\t/* If we show individual diffs, show the parent info */\n\t\tlog->parent = parents->item;\n\t}\n\n\tshowed_log = 0;\n\tfor (;;) {\n\t\tstruct commit *parent = parents->item;\n\n\t\tparse_commit_or_die(parent);\n\t\tdiff_tree_oid(get_commit_tree_oid(parent),\n\t\t\t      oid, \"\", &opt->diffopt);\n\t\tlog_tree_diff_flush(opt);\n\n\t\tshowed_log |= !opt->loginfo;\n\n\t\t/* Set up the log info for the next parent, if any.. */\n\t\tparents = parents->next;\n\t\tif (!parents)\n\t\t\tbreak;\n\t\tlog->parent = parents->item;\n\t\topt->loginfo = log;\n\t}\n\treturn showed_log;\n}\n\nint log_tree_commit(struct rev_info *opt, struct commit *commit)\n{\n\tstruct log_info log;\n\tint shown, close_file = opt->diffopt.close_file;\n\n\tlog.commit = commit;\n\tlog.parent = NULL;\n\topt->loginfo = &log;\n\topt->diffopt.close_file = 0;\n\n\tif (opt->line_level_traverse)\n\t\treturn line_log_print(opt, commit);\n\n\tif (opt->track_linear && !opt->linear && !opt->reverse_output_stage)\n\t\tfprintf(opt->diffopt.file, \"\\n%s\\n\", opt->break_bar);\n\tshown = log_tree_diff(opt, commit, &log);\n\tif (!shown && opt->loginfo && opt->always_show_header) {\n\t\tlog.parent = NULL;\n\t\tshow_log(opt);\n\t\tshown = 1;\n\t}\n\tif (opt->track_linear && !opt->linear && opt->reverse_output_stage)\n\t\tfprintf(opt->diffopt.file, \"\\n%s\\n\", opt->break_bar);\n\topt->loginfo = NULL;\n\tmaybe_flush_or_die(opt->diffopt.file, \"stdout\");\n\tif (close_file)\n\t\tfclose(opt->diffopt.file);\n\treturn shown;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0064788b252cadb98b71eec4d3517f92c88bba86",
  "sha1_ok": true,
  "size": 27143
}
