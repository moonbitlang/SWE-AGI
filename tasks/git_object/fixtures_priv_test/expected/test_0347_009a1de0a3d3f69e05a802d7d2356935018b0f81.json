{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGNvbW1pdCIKICoKICogQ29weXJpZ2h0IChjKSAyMDA3IEtyaXN0aWFuIEjDuGdzYmVyZyA8a3JoQHJlZGhhdC5jb20+CiAqIEJhc2VkIG9uIGdpdC1jb21taXQuc2ggYnkgSnVuaW8gQyBIYW1hbm8gYW5kIExpbnVzIFRvcnZhbGRzCiAqLwoKI2RlZmluZSBVU0VfVEhFX0lOREVYX0NPTVBBVElCSUxJVFlfTUFDUk9TCiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAiY29uZmlnLmgiCiNpbmNsdWRlICJsb2NrZmlsZS5oIgojaW5jbHVkZSAiY2FjaGUtdHJlZS5oIgojaW5jbHVkZSAiY29sb3IuaCIKI2luY2x1ZGUgImRpci5oIgojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAiZGlmZmNvcmUuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAicmV2aXNpb24uaCIKI2luY2x1ZGUgInd0LXN0YXR1cy5oIgojaW5jbHVkZSAicnVuLWNvbW1hbmQuaCIKI2luY2x1ZGUgImhvb2suaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgImxvZy10cmVlLmgiCiNpbmNsdWRlICJzdHJidWYuaCIKI2luY2x1ZGUgInV0ZjguaCIKI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCIKI2luY2x1ZGUgInN0cmluZy1saXN0LmgiCiNpbmNsdWRlICJyZXJlcmUuaCIKI2luY2x1ZGUgInVucGFjay10cmVlcy5oIgojaW5jbHVkZSAicXVvdGUuaCIKI2luY2x1ZGUgInN1Ym1vZHVsZS5oIgojaW5jbHVkZSAiZ3BnLWludGVyZmFjZS5oIgojaW5jbHVkZSAiY29sdW1uLmgiCiNpbmNsdWRlICJzZXF1ZW5jZXIuaCIKI2luY2x1ZGUgIm1haWxtYXAuaCIKI2luY2x1ZGUgImhlbHAuaCIKI2luY2x1ZGUgImNvbW1pdC1yZWFjaC5oIgojaW5jbHVkZSAiY29tbWl0LWdyYXBoLmgiCiNpbmNsdWRlICJwcmV0dHkuaCIKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgYnVpbHRpbl9jb21taXRfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgY29tbWl0IFs8b3B0aW9ucz5dIFstLV0gPHBhdGhzcGVjPi4uLiIpLAoJTlVMTAp9OwoKc3RhdGljIGNvbnN0IGNoYXIgKiBjb25zdCBidWlsdGluX3N0YXR1c191c2FnZVtdID0gewoJTl8oImdpdCBzdGF0dXMgWzxvcHRpb25zPl0gWy0tXSA8cGF0aHNwZWM+Li4uIiksCglOVUxMCn07CgpzdGF0aWMgY29uc3QgY2hhciBlbXB0eV9hbWVuZF9hZHZpY2VbXSA9Ck5fKCJZb3UgYXNrZWQgdG8gYW1lbmQgdGhlIG1vc3QgcmVjZW50IGNvbW1pdCwgYnV0IGRvaW5nIHNvIHdvdWxkIG1ha2VcbiIKIml0IGVtcHR5LiBZb3UgY2FuIHJlcGVhdCB5b3VyIGNvbW1hbmQgd2l0aCAtLWFsbG93LWVtcHR5LCBvciB5b3UgY2FuXG4iCiJyZW1vdmUgdGhlIGNvbW1pdCBlbnRpcmVseSB3aXRoIFwiZ2l0IHJlc2V0IEhFQUReXCIuXG4iKTsKCnN0YXRpYyBjb25zdCBjaGFyIGVtcHR5X2NoZXJyeV9waWNrX2FkdmljZVtdID0KTl8oIlRoZSBwcmV2aW91cyBjaGVycnktcGljayBpcyBub3cgZW1wdHksIHBvc3NpYmx5IGR1ZSB0byBjb25mbGljdCByZXNvbHV0aW9uLlxuIgoiSWYgeW91IHdpc2ggdG8gY29tbWl0IGl0IGFueXdheSwgdXNlOlxuIgoiXG4iCiIgICAgZ2l0IGNvbW1pdCAtLWFsbG93LWVtcHR5XG4iCiJcbiIpOwoKc3RhdGljIGNvbnN0IGNoYXIgZW1wdHlfcmViYXNlX3BpY2tfYWR2aWNlW10gPQpOXygiT3RoZXJ3aXNlLCBwbGVhc2UgdXNlICdnaXQgcmViYXNlIC0tc2tpcCdcbiIpOwoKc3RhdGljIGNvbnN0IGNoYXIgZW1wdHlfY2hlcnJ5X3BpY2tfYWR2aWNlX3NpbmdsZVtdID0KTl8oIk90aGVyd2lzZSwgcGxlYXNlIHVzZSAnZ2l0IGNoZXJyeS1waWNrIC0tc2tpcCdcbiIpOwoKc3RhdGljIGNvbnN0IGNoYXIgZW1wdHlfY2hlcnJ5X3BpY2tfYWR2aWNlX211bHRpW10gPQpOXygiYW5kIHRoZW4gdXNlOlxuIgoiXG4iCiIgICAgZ2l0IGNoZXJyeS1waWNrIC0tY29udGludWVcbiIKIlxuIgoidG8gcmVzdW1lIGNoZXJyeS1waWNraW5nIHRoZSByZW1haW5pbmcgY29tbWl0cy5cbiIKIklmIHlvdSB3aXNoIHRvIHNraXAgdGhpcyBjb21taXQsIHVzZTpcbiIKIlxuIgoiICAgIGdpdCBjaGVycnktcGljayAtLXNraXBcbiIKIlxuIik7CgpzdGF0aWMgY29uc3QgY2hhciAqY29sb3Jfc3RhdHVzX3Nsb3RzW10gPSB7CglbV1RfU1RBVFVTX0hFQURFUl0JICA9ICJoZWFkZXIiLAoJW1dUX1NUQVRVU19VUERBVEVEXQkgID0gInVwZGF0ZWQiLAoJW1dUX1NUQVRVU19DSEFOR0VEXQkgID0gImNoYW5nZWQiLAoJW1dUX1NUQVRVU19VTlRSQUNLRURdCSAgPSAidW50cmFja2VkIiwKCVtXVF9TVEFUVVNfTk9CUkFOQ0hdCSAgPSAibm9CcmFuY2giLAoJW1dUX1NUQVRVU19VTk1FUkdFRF0JICA9ICJ1bm1lcmdlZCIsCglbV1RfU1RBVFVTX0xPQ0FMX0JSQU5DSF0gID0gImxvY2FsQnJhbmNoIiwKCVtXVF9TVEFUVVNfUkVNT1RFX0JSQU5DSF0gPSAicmVtb3RlQnJhbmNoIiwKCVtXVF9TVEFUVVNfT05CUkFOQ0hdCSAgPSAiYnJhbmNoIiwKfTsKCnN0YXRpYyBjb25zdCBjaGFyICp1c2VfbWVzc2FnZV9idWZmZXI7CnN0YXRpYyBzdHJ1Y3QgbG9ja19maWxlIGluZGV4X2xvY2s7IC8qIHJlYWwgaW5kZXggKi8Kc3RhdGljIHN0cnVjdCBsb2NrX2ZpbGUgZmFsc2VfbG9jazsgLyogdXNlZCBvbmx5IGZvciBwYXJ0aWFsIGNvbW1pdHMgKi8Kc3RhdGljIGVudW0gewoJQ09NTUlUX0FTX0lTID0gMSwKCUNPTU1JVF9OT1JNQUwsCglDT01NSVRfUEFSVElBTAp9IGNvbW1pdF9zdHlsZTsKCnN0YXRpYyBjb25zdCBjaGFyICpsb2dmaWxlLCAqZm9yY2VfYXV0aG9yOwpzdGF0aWMgY29uc3QgY2hhciAqdGVtcGxhdGVfZmlsZTsKLyoKICogVGhlIF9tZXNzYWdlIHZhcmlhYmxlcyBhcmUgY29tbWl0IG5hbWVzIGZyb20gd2hpY2ggdG8gdGFrZQogKiB0aGUgY29tbWl0IG1lc3NhZ2UgYW5kL29yIGF1dGhvcnNoaXAuCiAqLwpzdGF0aWMgY29uc3QgY2hhciAqYXV0aG9yX21lc3NhZ2UsICphdXRob3JfbWVzc2FnZV9idWZmZXI7CnN0YXRpYyBjaGFyICplZGl0X21lc3NhZ2UsICp1c2VfbWVzc2FnZTsKc3RhdGljIGNoYXIgKmZpeHVwX21lc3NhZ2UsICpmaXh1cF9jb21taXQsICpzcXVhc2hfbWVzc2FnZTsKc3RhdGljIGNvbnN0IGNoYXIgKmZpeHVwX3ByZWZpeDsKc3RhdGljIGludCBhbGwsIGFsc28sIGludGVyYWN0aXZlLCBwYXRjaF9pbnRlcmFjdGl2ZSwgb25seSwgYW1lbmQsIHNpZ25vZmY7CnN0YXRpYyBpbnQgZWRpdF9mbGFnID0gLTE7IC8qIHVuc3BlY2lmaWVkICovCnN0YXRpYyBpbnQgcXVpZXQsIHZlcmJvc2UsIG5vX3ZlcmlmeSwgYWxsb3dfZW1wdHksIGRyeV9ydW4sIHJlbmV3X2F1dGhvcnNoaXA7CnN0YXRpYyBpbnQgY29uZmlnX2NvbW1pdF92ZXJib3NlID0gLTE7IC8qIHVuc3BlY2lmaWVkICovCnN0YXRpYyBpbnQgbm9fcG9zdF9yZXdyaXRlLCBhbGxvd19lbXB0eV9tZXNzYWdlLCBwYXRoc3BlY19maWxlX251bDsKc3RhdGljIGNoYXIgKnVudHJhY2tlZF9maWxlc19hcmcsICpmb3JjZV9kYXRlLCAqaWdub3JlX3N1Ym1vZHVsZV9hcmcsICppZ25vcmVkX2FyZzsKc3RhdGljIGNoYXIgKnNpZ25fY29tbWl0LCAqcGF0aHNwZWNfZnJvbV9maWxlOwpzdGF0aWMgc3RydWN0IHN0cnZlYyB0cmFpbGVyX2FyZ3MgPSBTVFJWRUNfSU5JVDsKCi8qCiAqIFRoZSBkZWZhdWx0IGNvbW1pdCBtZXNzYWdlIGNsZWFudXAgbW9kZSB3aWxsIHJlbW92ZSB0aGUgbGluZXMKICogYmVnaW5uaW5nIHdpdGggIyAoc2hlbGwgY29tbWVudHMpIGFuZCBsZWFkaW5nIGFuZCB0cmFpbGluZwogKiB3aGl0ZXNwYWNlcyAoZW1wdHkgbGluZXMgb3IgY29udGFpbmluZyBvbmx5IHdoaXRlc3BhY2VzKQogKiBpZiBlZGl0b3IgaXMgdXNlZCwgYW5kIG9ubHkgdGhlIHdoaXRlc3BhY2VzIGlmIHRoZSBtZXNzYWdlCiAqIGlzIHNwZWNpZmllZCBleHBsaWNpdGx5LgogKi8Kc3RhdGljIGVudW0gY29tbWl0X21zZ19jbGVhbnVwX21vZGUgY2xlYW51cF9tb2RlOwpzdGF0aWMgY29uc3QgY2hhciAqY2xlYW51cF9hcmc7CgpzdGF0aWMgZW51bSBjb21taXRfd2hlbmNlIHdoZW5jZTsKc3RhdGljIGludCB1c2VfZWRpdG9yID0gMSwgaW5jbHVkZV9zdGF0dXMgPSAxOwpzdGF0aWMgaW50IGhhdmVfb3B0aW9uX207CnN0YXRpYyBzdHJ1Y3Qgc3RyYnVmIG1lc3NhZ2UgPSBTVFJCVUZfSU5JVDsKCnN0YXRpYyBlbnVtIHd0X3N0YXR1c19mb3JtYXQgc3RhdHVzX2Zvcm1hdCA9IFNUQVRVU19GT1JNQVRfVU5TUEVDSUZJRUQ7CgpzdGF0aWMgaW50IG9wdF9wYXNzX3RyYWlsZXIoY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJQlVHX09OX09QVF9ORUcodW5zZXQpOwoKCXN0cnZlY19wdXNobCgmdHJhaWxlcl9hcmdzLCAiLS10cmFpbGVyIiwgYXJnLCBOVUxMKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IG9wdF9wYXJzZV9wb3JjZWxhaW4oY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJZW51bSB3dF9zdGF0dXNfZm9ybWF0ICp2YWx1ZSA9IChlbnVtIHd0X3N0YXR1c19mb3JtYXQgKilvcHQtPnZhbHVlOwoJaWYgKHVuc2V0KQoJCSp2YWx1ZSA9IFNUQVRVU19GT1JNQVRfTk9ORTsKCWVsc2UgaWYgKCFhcmcpCgkJKnZhbHVlID0gU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU47CgllbHNlIGlmICghc3RyY21wKGFyZywgInYxIikgfHwgIXN0cmNtcChhcmcsICIxIikpCgkJKnZhbHVlID0gU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU47CgllbHNlIGlmICghc3RyY21wKGFyZywgInYyIikgfHwgIXN0cmNtcChhcmcsICIyIikpCgkJKnZhbHVlID0gU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU5fVjI7CgllbHNlCgkJZGllKCJ1bnN1cHBvcnRlZCBwb3JjZWxhaW4gdmVyc2lvbiAnJXMnIiwgYXJnKTsKCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBvcHRfcGFyc2VfbShjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglzdHJ1Y3Qgc3RyYnVmICpidWYgPSBvcHQtPnZhbHVlOwoJaWYgKHVuc2V0KSB7CgkJaGF2ZV9vcHRpb25fbSA9IDA7CgkJc3RyYnVmX3NldGxlbihidWYsIDApOwoJfSBlbHNlIHsKCQloYXZlX29wdGlvbl9tID0gMTsKCQlpZiAoYnVmLT5sZW4pCgkJCXN0cmJ1Zl9hZGRjaChidWYsICdcbicpOwoJCXN0cmJ1Zl9hZGRzdHIoYnVmLCBhcmcpOwoJCXN0cmJ1Zl9jb21wbGV0ZV9saW5lKGJ1Zik7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBvcHRfcGFyc2VfcmVuYW1lX3Njb3JlKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCWNvbnN0IGNoYXIgKip2YWx1ZSA9IG9wdC0+dmFsdWU7CgoJQlVHX09OX09QVF9ORUcodW5zZXQpOwoKCWlmIChhcmcgIT0gTlVMTCAmJiAqYXJnID09ICc9JykKCQlhcmcgPSBhcmcgKyAxOwoKCSp2YWx1ZSA9IGFyZzsKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBkZXRlcm1pbmVfd2hlbmNlKHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWlmIChmaWxlX2V4aXN0cyhnaXRfcGF0aF9tZXJnZV9oZWFkKHRoZV9yZXBvc2l0b3J5KSkpCgkJd2hlbmNlID0gRlJPTV9NRVJHRTsKCWVsc2UgaWYgKCFzZXF1ZW5jZXJfZGV0ZXJtaW5lX3doZW5jZSh0aGVfcmVwb3NpdG9yeSwgJndoZW5jZSkpCgkJd2hlbmNlID0gRlJPTV9DT01NSVQ7CglpZiAocykKCQlzLT53aGVuY2UgPSB3aGVuY2U7Cn0KCnN0YXRpYyB2b2lkIHN0YXR1c19pbml0X2NvbmZpZyhzdHJ1Y3Qgd3Rfc3RhdHVzICpzLCBjb25maWdfZm5fdCBmbikKewoJd3Rfc3RhdHVzX3ByZXBhcmUodGhlX3JlcG9zaXRvcnksIHMpOwoJaW5pdF9kaWZmX3VpX2RlZmF1bHRzKCk7CglnaXRfY29uZmlnKGZuLCBzKTsKCWRldGVybWluZV93aGVuY2Uocyk7CglzLT5oaW50cyA9IGFkdmljZV9lbmFibGVkKEFEVklDRV9TVEFUVVNfSElOVFMpOyAvKiBtdXN0IGNvbWUgYWZ0ZXIgZ2l0X2NvbmZpZygpICovCn0KCnN0YXRpYyB2b2lkIHJvbGxiYWNrX2luZGV4X2ZpbGVzKHZvaWQpCnsKCXN3aXRjaCAoY29tbWl0X3N0eWxlKSB7CgljYXNlIENPTU1JVF9BU19JUzoKCQlicmVhazsgLyogbm90aGluZyB0byBkbyAqLwoJY2FzZSBDT01NSVRfTk9STUFMOgoJCXJvbGxiYWNrX2xvY2tfZmlsZSgmaW5kZXhfbG9jayk7CgkJYnJlYWs7CgljYXNlIENPTU1JVF9QQVJUSUFMOgoJCXJvbGxiYWNrX2xvY2tfZmlsZSgmaW5kZXhfbG9jayk7CgkJcm9sbGJhY2tfbG9ja19maWxlKCZmYWxzZV9sb2NrKTsKCQlicmVhazsKCX0KfQoKc3RhdGljIGludCBjb21taXRfaW5kZXhfZmlsZXModm9pZCkKewoJaW50IGVyciA9IDA7CgoJc3dpdGNoIChjb21taXRfc3R5bGUpIHsKCWNhc2UgQ09NTUlUX0FTX0lTOgoJCWJyZWFrOyAvKiBub3RoaW5nIHRvIGRvICovCgljYXNlIENPTU1JVF9OT1JNQUw6CgkJZXJyID0gY29tbWl0X2xvY2tfZmlsZSgmaW5kZXhfbG9jayk7CgkJYnJlYWs7CgljYXNlIENPTU1JVF9QQVJUSUFMOgoJCWVyciA9IGNvbW1pdF9sb2NrX2ZpbGUoJmluZGV4X2xvY2spOwoJCXJvbGxiYWNrX2xvY2tfZmlsZSgmZmFsc2VfbG9jayk7CgkJYnJlYWs7Cgl9CgoJcmV0dXJuIGVycjsKfQoKLyoKICogVGFrZSBhIHVuaW9uIG9mIHBhdGhzIGluIHRoZSBpbmRleCBhbmQgdGhlIG5hbWVkIHRyZWUgKHR5cGljYWxseSwgIkhFQUQiKSwKICogYW5kIHJldHVybiB0aGUgcGF0aHMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gcGF0dGVybiBpbiBsaXN0LgogKi8Kc3RhdGljIGludCBsaXN0X3BhdGhzKHN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCwgY29uc3QgY2hhciAqd2l0aF90cmVlLAoJCSAgICAgIGNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcGF0dGVybikKewoJaW50IGksIHJldDsKCWNoYXIgKm07CgoJaWYgKCFwYXR0ZXJuLT5ucikKCQlyZXR1cm4gMDsKCgltID0geGNhbGxvYygxLCBwYXR0ZXJuLT5ucik7CgoJaWYgKHdpdGhfdHJlZSkgewoJCWNoYXIgKm1heF9wcmVmaXggPSBjb21tb25fcHJlZml4KHBhdHRlcm4pOwoJCW92ZXJsYXlfdHJlZV9vbl9pbmRleCgmdGhlX2luZGV4LCB3aXRoX3RyZWUsIG1heF9wcmVmaXgpOwoJCWZyZWUobWF4X3ByZWZpeCk7Cgl9CgoJLyogVE9ETzogYXVkaXQgZm9yIGludGVyYWN0aW9uIHdpdGggc3BhcnNlLWluZGV4LiAqLwoJZW5zdXJlX2Z1bGxfaW5kZXgoJnRoZV9pbmRleCk7Cglmb3IgKGkgPSAwOyBpIDwgYWN0aXZlX25yOyBpKyspIHsKCQljb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gYWN0aXZlX2NhY2hlW2ldOwoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoKCQlpZiAoY2UtPmNlX2ZsYWdzICYgQ0VfVVBEQVRFKQoJCQljb250aW51ZTsKCQlpZiAoIWNlX3BhdGhfbWF0Y2goJnRoZV9pbmRleCwgY2UsIHBhdHRlcm4sIG0pKQoJCQljb250aW51ZTsKCQlpdGVtID0gc3RyaW5nX2xpc3RfaW5zZXJ0KGxpc3QsIGNlLT5uYW1lKTsKCQlpZiAoY2Vfc2tpcF93b3JrdHJlZShjZSkpCgkJCWl0ZW0tPnV0aWwgPSBpdGVtOyAvKiBiZXR0ZXIgYSB2YWxpZCBwb2ludGVyIHRoYW4gYSBmYWtlIG9uZSAqLwoJfQoKCXJldCA9IHJlcG9ydF9wYXRoX2Vycm9yKG0sIHBhdHRlcm4pOwoJZnJlZShtKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyB2b2lkIGFkZF9yZW1vdmVfZmlsZXMoc3RydWN0IHN0cmluZ19saXN0ICpsaXN0KQp7CglpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCBsaXN0LT5ucjsgaSsrKSB7CgkJc3RydWN0IHN0YXQgc3Q7CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKnAgPSAmKGxpc3QtPml0ZW1zW2ldKTsKCgkJLyogcC0+dXRpbCBpcyBza2lwLXdvcmt0cmVlICovCgkJaWYgKHAtPnV0aWwpCgkJCWNvbnRpbnVlOwoKCQlpZiAoIWxzdGF0KHAtPnN0cmluZywgJnN0KSkgewoJCQlpZiAoYWRkX3RvX2NhY2hlKHAtPnN0cmluZywgJnN0LCAwKSkKCQkJCWRpZShfKCJ1cGRhdGluZyBmaWxlcyBmYWlsZWQiKSk7CgkJfSBlbHNlCgkJCXJlbW92ZV9maWxlX2Zyb21fY2FjaGUocC0+c3RyaW5nKTsKCX0KfQoKc3RhdGljIHZvaWQgY3JlYXRlX2Jhc2VfaW5kZXgoY29uc3Qgc3RydWN0IGNvbW1pdCAqY3VycmVudF9oZWFkKQp7CglzdHJ1Y3QgdHJlZSAqdHJlZTsKCXN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyBvcHRzOwoJc3RydWN0IHRyZWVfZGVzYyB0OwoKCWlmICghY3VycmVudF9oZWFkKSB7CgkJZGlzY2FyZF9jYWNoZSgpOwoJCXJldHVybjsKCX0KCgltZW1zZXQoJm9wdHMsIDAsIHNpemVvZihvcHRzKSk7CglvcHRzLmhlYWRfaWR4ID0gMTsKCW9wdHMuaW5kZXhfb25seSA9IDE7CglvcHRzLm1lcmdlID0gMTsKCW9wdHMuc3JjX2luZGV4ID0gJnRoZV9pbmRleDsKCW9wdHMuZHN0X2luZGV4ID0gJnRoZV9pbmRleDsKCglvcHRzLmZuID0gb25ld2F5X21lcmdlOwoJdHJlZSA9IHBhcnNlX3RyZWVfaW5kaXJlY3QoJmN1cnJlbnRfaGVhZC0+b2JqZWN0Lm9pZCk7CglpZiAoIXRyZWUpCgkJZGllKF8oImZhaWxlZCB0byB1bnBhY2sgSEVBRCB0cmVlIG9iamVjdCIpKTsKCXBhcnNlX3RyZWUodHJlZSk7Cglpbml0X3RyZWVfZGVzYygmdCwgdHJlZS0+YnVmZmVyLCB0cmVlLT5zaXplKTsKCWlmICh1bnBhY2tfdHJlZXMoMSwgJnQsICZvcHRzKSkKCQlleGl0KDEyOCk7IC8qIFdlJ3ZlIGFscmVhZHkgcmVwb3J0ZWQgdGhlIGVycm9yLCBmaW5pc2ggZHlpbmcgKi8KfQoKc3RhdGljIHZvaWQgcmVmcmVzaF9jYWNoZV9vcl9kaWUoaW50IHJlZnJlc2hfZmxhZ3MpCnsKCS8qCgkgKiByZWZyZXNoX2ZsYWdzIGNvbnRhaW5zIFJFRlJFU0hfUVVJRVQsIHNvIHRoZSBvbmx5IGVycm9ycwoJICogYXJlIGZvciB1bm1lcmdlZCBlbnRyaWVzLgoJICovCglpZiAocmVmcmVzaF9jYWNoZShyZWZyZXNoX2ZsYWdzIHwgUkVGUkVTSF9JTl9QT1JDRUxBSU4pKQoJCWRpZV9yZXNvbHZlX2NvbmZsaWN0KCJjb21taXQiKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnByZXBhcmVfaW5kZXgoY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJCSBjb25zdCBzdHJ1Y3QgY29tbWl0ICpjdXJyZW50X2hlYWQsIGludCBpc19zdGF0dXMpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdCBwYXJ0aWFsID0gU1RSSU5HX0xJU1RfSU5JVF9EVVA7CglzdHJ1Y3QgcGF0aHNwZWMgcGF0aHNwZWM7CglpbnQgcmVmcmVzaF9mbGFncyA9IFJFRlJFU0hfUVVJRVQ7Cgljb25zdCBjaGFyICpyZXQ7CgoJaWYgKGlzX3N0YXR1cykKCQlyZWZyZXNoX2ZsYWdzIHw9IFJFRlJFU0hfVU5NRVJHRUQ7CglwYXJzZV9wYXRoc3BlYygmcGF0aHNwZWMsIDAsCgkJICAgICAgIFBBVEhTUEVDX1BSRUZFUl9GVUxMLAoJCSAgICAgICBwcmVmaXgsIGFyZ3YpOwoKCWlmIChwYXRoc3BlY19mcm9tX2ZpbGUpIHsKCQlpZiAoaW50ZXJhY3RpdmUpCgkJCWRpZShfKCJvcHRpb25zICclcycgYW5kICclcycgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIiKSwgIi0tcGF0aHNwZWMtZnJvbS1maWxlIiwgIi0taW50ZXJhY3RpdmUvLS1wYXRjaCIpOwoKCQlpZiAoYWxsKQoJCQlkaWUoXygib3B0aW9ucyAnJXMnIGFuZCAnJXMnIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIiksICItLXBhdGhzcGVjLWZyb20tZmlsZSIsICItYSIpOwoKCQlpZiAocGF0aHNwZWMubnIpCgkJCWRpZShfKCInJXMnIGFuZCBwYXRoc3BlYyBhcmd1bWVudHMgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIiKSwgIi0tcGF0aHNwZWMtZnJvbS1maWxlIik7CgoJCXBhcnNlX3BhdGhzcGVjX2ZpbGUoJnBhdGhzcGVjLCAwLAoJCQkJICAgIFBBVEhTUEVDX1BSRUZFUl9GVUxMLAoJCQkJICAgIHByZWZpeCwgcGF0aHNwZWNfZnJvbV9maWxlLCBwYXRoc3BlY19maWxlX251bCk7Cgl9IGVsc2UgaWYgKHBhdGhzcGVjX2ZpbGVfbnVsKSB7CgkJZGllKF8oInRoZSBvcHRpb24gJyVzJyByZXF1aXJlcyAnJXMnIiksICItLXBhdGhzcGVjLWZpbGUtbnVsIiwgIi0tcGF0aHNwZWMtZnJvbS1maWxlIik7Cgl9CgoJaWYgKCFwYXRoc3BlYy5uciAmJiAoYWxzbyB8fCAob25seSAmJiAhYWxsb3dfZW1wdHkgJiYKCSAgICAoIWFtZW5kIHx8IChmaXh1cF9tZXNzYWdlICYmIHN0cmNtcChmaXh1cF9wcmVmaXgsICJhbWVuZCIpKSkpKSkKCQlkaWUoXygiTm8gcGF0aHMgd2l0aCAtLWluY2x1ZGUvLS1vbmx5IGRvZXMgbm90IG1ha2Ugc2Vuc2UuIikpOwoKCWlmIChyZWFkX2NhY2hlX3ByZWxvYWQoJnBhdGhzcGVjKSA8IDApCgkJZGllKF8oImluZGV4IGZpbGUgY29ycnVwdCIpKTsKCglpZiAoaW50ZXJhY3RpdmUpIHsKCQljaGFyICpvbGRfaW5kZXhfZW52ID0gTlVMTCwgKm9sZF9yZXBvX2luZGV4X2ZpbGU7CgkJaG9sZF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2ssIExPQ0tfRElFX09OX0VSUk9SKTsKCgkJcmVmcmVzaF9jYWNoZV9vcl9kaWUocmVmcmVzaF9mbGFncyk7CgoJCWlmICh3cml0ZV9sb2NrZWRfaW5kZXgoJnRoZV9pbmRleCwgJmluZGV4X2xvY2ssIDApKQoJCQlkaWUoXygidW5hYmxlIHRvIGNyZWF0ZSB0ZW1wb3JhcnkgaW5kZXgiKSk7CgoJCW9sZF9yZXBvX2luZGV4X2ZpbGUgPSB0aGVfcmVwb3NpdG9yeS0+aW5kZXhfZmlsZTsKCQl0aGVfcmVwb3NpdG9yeS0+aW5kZXhfZmlsZSA9CgkJCShjaGFyICopZ2V0X2xvY2tfZmlsZV9wYXRoKCZpbmRleF9sb2NrKTsKCQlvbGRfaW5kZXhfZW52ID0geHN0cmR1cF9vcl9udWxsKGdldGVudihJTkRFWF9FTlZJUk9OTUVOVCkpOwoJCXNldGVudihJTkRFWF9FTlZJUk9OTUVOVCwgdGhlX3JlcG9zaXRvcnktPmluZGV4X2ZpbGUsIDEpOwoKCQlpZiAoaW50ZXJhY3RpdmVfYWRkKGFyZ3YsIHByZWZpeCwgcGF0Y2hfaW50ZXJhY3RpdmUpICE9IDApCgkJCWRpZShfKCJpbnRlcmFjdGl2ZSBhZGQgZmFpbGVkIikpOwoKCQl0aGVfcmVwb3NpdG9yeS0+aW5kZXhfZmlsZSA9IG9sZF9yZXBvX2luZGV4X2ZpbGU7CgkJaWYgKG9sZF9pbmRleF9lbnYgJiYgKm9sZF9pbmRleF9lbnYpCgkJCXNldGVudihJTkRFWF9FTlZJUk9OTUVOVCwgb2xkX2luZGV4X2VudiwgMSk7CgkJZWxzZQoJCQl1bnNldGVudihJTkRFWF9FTlZJUk9OTUVOVCk7CgkJRlJFRV9BTkRfTlVMTChvbGRfaW5kZXhfZW52KTsKCgkJZGlzY2FyZF9jYWNoZSgpOwoJCXJlYWRfY2FjaGVfZnJvbShnZXRfbG9ja19maWxlX3BhdGgoJmluZGV4X2xvY2spKTsKCQlpZiAodXBkYXRlX21haW5fY2FjaGVfdHJlZShXUklURV9UUkVFX1NJTEVOVCkgPT0gMCkgewoJCQlpZiAocmVvcGVuX2xvY2tfZmlsZSgmaW5kZXhfbG9jaykgPCAwKQoJCQkJZGllKF8oInVuYWJsZSB0byB3cml0ZSBpbmRleCBmaWxlIikpOwoJCQlpZiAod3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZpbmRleF9sb2NrLCAwKSkKCQkJCWRpZShfKCJ1bmFibGUgdG8gdXBkYXRlIHRlbXBvcmFyeSBpbmRleCIpKTsKCQl9IGVsc2UKCQkJd2FybmluZyhfKCJGYWlsZWQgdG8gdXBkYXRlIG1haW4gY2FjaGUgdHJlZSIpKTsKCgkJY29tbWl0X3N0eWxlID0gQ09NTUlUX05PUk1BTDsKCQlyZXQgPSBnZXRfbG9ja19maWxlX3BhdGgoJmluZGV4X2xvY2spOwoJCWdvdG8gb3V0OwoJfQoKCS8qCgkgKiBOb24gcGFydGlhbCwgbm9uIGFzLWlzIGNvbW1pdC4KCSAqCgkgKiAoMSkgZ2V0IHRoZSByZWFsIGluZGV4OwoJICogKDIpIHVwZGF0ZSB0aGVfaW5kZXggYXMgbmVjZXNzYXJ5OwoJICogKDMpIHdyaXRlIHRoZV9pbmRleCBvdXQgdG8gdGhlIHJlYWwgaW5kZXggKHN0aWxsIGxvY2tlZCk7CgkgKiAoNCkgcmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBsb2NrZWQgaW5kZXggZmlsZS4KCSAqCgkgKiBUaGUgY2FsbGVyIHNob3VsZCBydW4gaG9va3Mgb24gdGhlIGxvY2tlZCByZWFsIGluZGV4LCBhbmQKCSAqIChBKSBpZiBhbGwgZ29lcyB3ZWxsLCBjb21taXQgdGhlIHJlYWwgaW5kZXg7CgkgKiAoQikgb24gZmFpbHVyZSwgcm9sbGJhY2sgdGhlIHJlYWwgaW5kZXguCgkgKi8KCWlmIChhbGwgfHwgKGFsc28gJiYgcGF0aHNwZWMubnIpKSB7CgkJaG9sZF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2ssIExPQ0tfRElFX09OX0VSUk9SKTsKCQlhZGRfZmlsZXNfdG9fY2FjaGUoYWxzbyA/IHByZWZpeCA6IE5VTEwsICZwYXRoc3BlYywgMCk7CgkJcmVmcmVzaF9jYWNoZV9vcl9kaWUocmVmcmVzaF9mbGFncyk7CgkJdXBkYXRlX21haW5fY2FjaGVfdHJlZShXUklURV9UUkVFX1NJTEVOVCk7CgkJaWYgKHdyaXRlX2xvY2tlZF9pbmRleCgmdGhlX2luZGV4LCAmaW5kZXhfbG9jaywgMCkpCgkJCWRpZShfKCJ1bmFibGUgdG8gd3JpdGUgbmV3X2luZGV4IGZpbGUiKSk7CgkJY29tbWl0X3N0eWxlID0gQ09NTUlUX05PUk1BTDsKCQlyZXQgPSBnZXRfbG9ja19maWxlX3BhdGgoJmluZGV4X2xvY2spOwoJCWdvdG8gb3V0OwoJfQoKCS8qCgkgKiBBcy1pcyBjb21taXQuCgkgKgoJICogKDEpIHJldHVybiB0aGUgbmFtZSBvZiB0aGUgcmVhbCBpbmRleCBmaWxlLgoJICoKCSAqIFRoZSBjYWxsZXIgc2hvdWxkIHJ1biBob29rcyBvbiB0aGUgcmVhbCBpbmRleCwKCSAqIGFuZCBjcmVhdGUgY29tbWl0IGZyb20gdGhlX2luZGV4LgoJICogV2Ugc3RpbGwgbmVlZCB0byByZWZyZXNoIHRoZSBpbmRleCBoZXJlLgoJICovCglpZiAoIW9ubHkgJiYgIXBhdGhzcGVjLm5yKSB7CgkJaG9sZF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2ssIExPQ0tfRElFX09OX0VSUk9SKTsKCQlyZWZyZXNoX2NhY2hlX29yX2RpZShyZWZyZXNoX2ZsYWdzKTsKCQlpZiAoYWN0aXZlX2NhY2hlX2NoYW5nZWQKCQkgICAgfHwgIWNhY2hlX3RyZWVfZnVsbHlfdmFsaWQoYWN0aXZlX2NhY2hlX3RyZWUpKQoJCQl1cGRhdGVfbWFpbl9jYWNoZV90cmVlKFdSSVRFX1RSRUVfU0lMRU5UKTsKCQlpZiAod3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZpbmRleF9sb2NrLAoJCQkJICAgICAgIENPTU1JVF9MT0NLIHwgU0tJUF9JRl9VTkNIQU5HRUQpKQoJCQlkaWUoXygidW5hYmxlIHRvIHdyaXRlIG5ld19pbmRleCBmaWxlIikpOwoJCWNvbW1pdF9zdHlsZSA9IENPTU1JVF9BU19JUzsKCQlyZXQgPSBnZXRfaW5kZXhfZmlsZSgpOwoJCWdvdG8gb3V0OwoJfQoKCS8qCgkgKiBBIHBhcnRpYWwgY29tbWl0LgoJICoKCSAqICgwKSBmaW5kIHRoZSBzZXQgb2YgYWZmZWN0ZWQgcGF0aHM7CgkgKiAoMSkgZ2V0IGxvY2sgb24gdGhlIHJlYWwgaW5kZXggZmlsZTsKCSAqICgyKSB1cGRhdGUgdGhlX2luZGV4IHdpdGggdGhlIGdpdmVuIHBhdGhzOwoJICogKDMpIHdyaXRlIHRoZV9pbmRleCBvdXQgdG8gdGhlIHJlYWwgaW5kZXggKHN0aWxsIGxvY2tlZCk7CgkgKiAoNCkgZ2V0IGxvY2sgb24gdGhlIGZhbHNlIGluZGV4IGZpbGU7CgkgKiAoNSkgcmVzZXQgdGhlX2luZGV4IGZyb20gSEVBRDsKCSAqICg2KSB1cGRhdGUgdGhlX2luZGV4IHRoZSBzYW1lIHdheSBhcyAoMik7CgkgKiAoNykgd3JpdGUgdGhlX2luZGV4IG91dCB0byB0aGUgZmFsc2UgaW5kZXggZmlsZTsKCSAqICg4KSByZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGZhbHNlIGluZGV4IGZpbGUgKHN0aWxsIGxvY2tlZCk7CgkgKgoJICogVGhlIGNhbGxlciBzaG91bGQgcnVuIGhvb2tzIG9uIHRoZSBsb2NrZWQgZmFsc2UgaW5kZXgsIGFuZAoJICogY3JlYXRlIGNvbW1pdCBmcm9tIGl0LiAgVGhlbgoJICogKEEpIGlmIGFsbCBnb2VzIHdlbGwsIGNvbW1pdCB0aGUgcmVhbCBpbmRleDsKCSAqIChCKSBvbiBmYWlsdXJlLCByb2xsYmFjayB0aGUgcmVhbCBpbmRleDsKCSAqIEluIGVpdGhlciBjYXNlLCByb2xsYmFjayB0aGUgZmFsc2UgaW5kZXguCgkgKi8KCWNvbW1pdF9zdHlsZSA9IENPTU1JVF9QQVJUSUFMOwoKCWlmICh3aGVuY2UgIT0gRlJPTV9DT01NSVQpIHsKCQlpZiAod2hlbmNlID09IEZST01fTUVSR0UpCgkJCWRpZShfKCJjYW5ub3QgZG8gYSBwYXJ0aWFsIGNvbW1pdCBkdXJpbmcgYSBtZXJnZS4iKSk7CgkJZWxzZSBpZiAoaXNfZnJvbV9jaGVycnlfcGljayh3aGVuY2UpKQoJCQlkaWUoXygiY2Fubm90IGRvIGEgcGFydGlhbCBjb21taXQgZHVyaW5nIGEgY2hlcnJ5LXBpY2suIikpOwoJCWVsc2UgaWYgKGlzX2Zyb21fcmViYXNlKHdoZW5jZSkpCgkJCWRpZShfKCJjYW5ub3QgZG8gYSBwYXJ0aWFsIGNvbW1pdCBkdXJpbmcgYSByZWJhc2UuIikpOwoJfQoKCWlmIChsaXN0X3BhdGhzKCZwYXJ0aWFsLCAhY3VycmVudF9oZWFkID8gTlVMTCA6ICJIRUFEIiwgJnBhdGhzcGVjKSkKCQlleGl0KDEpOwoKCWRpc2NhcmRfY2FjaGUoKTsKCWlmIChyZWFkX2NhY2hlKCkgPCAwKQoJCWRpZShfKCJjYW5ub3QgcmVhZCB0aGUgaW5kZXgiKSk7CgoJaG9sZF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2ssIExPQ0tfRElFX09OX0VSUk9SKTsKCWFkZF9yZW1vdmVfZmlsZXMoJnBhcnRpYWwpOwoJcmVmcmVzaF9jYWNoZShSRUZSRVNIX1FVSUVUKTsKCXVwZGF0ZV9tYWluX2NhY2hlX3RyZWUoV1JJVEVfVFJFRV9TSUxFTlQpOwoJaWYgKHdyaXRlX2xvY2tlZF9pbmRleCgmdGhlX2luZGV4LCAmaW5kZXhfbG9jaywgMCkpCgkJZGllKF8oInVuYWJsZSB0byB3cml0ZSBuZXdfaW5kZXggZmlsZSIpKTsKCglob2xkX2xvY2tfZmlsZV9mb3JfdXBkYXRlKCZmYWxzZV9sb2NrLAoJCQkJICBnaXRfcGF0aCgibmV4dC1pbmRleC0lIlBSSXVNQVgsCgkJCQkJICAgKHVpbnRtYXhfdCkgZ2V0cGlkKCkpLAoJCQkJICBMT0NLX0RJRV9PTl9FUlJPUik7CgoJY3JlYXRlX2Jhc2VfaW5kZXgoY3VycmVudF9oZWFkKTsKCWFkZF9yZW1vdmVfZmlsZXMoJnBhcnRpYWwpOwoJcmVmcmVzaF9jYWNoZShSRUZSRVNIX1FVSUVUKTsKCglpZiAod3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZmYWxzZV9sb2NrLCAwKSkKCQlkaWUoXygidW5hYmxlIHRvIHdyaXRlIHRlbXBvcmFyeSBpbmRleCBmaWxlIikpOwoKCWRpc2NhcmRfY2FjaGUoKTsKCXJldCA9IGdldF9sb2NrX2ZpbGVfcGF0aCgmZmFsc2VfbG9jayk7CglyZWFkX2NhY2hlX2Zyb20ocmV0KTsKb3V0OgoJc3RyaW5nX2xpc3RfY2xlYXIoJnBhcnRpYWwsIDApOwoJY2xlYXJfcGF0aHNwZWMoJnBhdGhzcGVjKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQgcnVuX3N0YXR1cyhGSUxFICpmcCwgY29uc3QgY2hhciAqaW5kZXhfZmlsZSwgY29uc3QgY2hhciAqcHJlZml4LCBpbnQgbm93YXJuLAoJCSAgICAgIHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoKCWlmIChzLT5yZWxhdGl2ZV9wYXRocykKCQlzLT5wcmVmaXggPSBwcmVmaXg7CgoJaWYgKGFtZW5kKSB7CgkJcy0+YW1lbmQgPSAxOwoJCXMtPnJlZmVyZW5jZSA9ICJIRUFEXjEiOwoJfQoJcy0+dmVyYm9zZSA9IHZlcmJvc2U7CglzLT5pbmRleF9maWxlID0gaW5kZXhfZmlsZTsKCXMtPmZwID0gZnA7CglzLT5ub3dhcm4gPSBub3dhcm47CglzLT5pc19pbml0aWFsID0gZ2V0X29pZChzLT5yZWZlcmVuY2UsICZvaWQpID8gMSA6IDA7CglpZiAoIXMtPmlzX2luaXRpYWwpCgkJb2lkY3B5KCZzLT5vaWRfY29tbWl0LCAmb2lkKTsKCXMtPnN0YXR1c19mb3JtYXQgPSBzdGF0dXNfZm9ybWF0OwoJcy0+aWdub3JlX3N1Ym1vZHVsZV9hcmcgPSBpZ25vcmVfc3VibW9kdWxlX2FyZzsKCgl3dF9zdGF0dXNfY29sbGVjdChzKTsKCXd0X3N0YXR1c19wcmludChzKTsKCXd0X3N0YXR1c19jb2xsZWN0X2ZyZWVfYnVmZmVycyhzKTsKCglyZXR1cm4gcy0+Y29tbWl0dGFibGU7Cn0KCnN0YXRpYyBpbnQgaXNfYV9tZXJnZShjb25zdCBzdHJ1Y3QgY29tbWl0ICpjdXJyZW50X2hlYWQpCnsKCXJldHVybiAhIShjdXJyZW50X2hlYWQtPnBhcmVudHMgJiYgY3VycmVudF9oZWFkLT5wYXJlbnRzLT5uZXh0KTsKfQoKc3RhdGljIHZvaWQgYXNzZXJ0X3NwbGl0X2lkZW50KHN0cnVjdCBpZGVudF9zcGxpdCAqaWQsIGNvbnN0IHN0cnVjdCBzdHJidWYgKmJ1ZikKewoJaWYgKHNwbGl0X2lkZW50X2xpbmUoaWQsIGJ1Zi0+YnVmLCBidWYtPmxlbikgfHwgIWlkLT5kYXRlX2JlZ2luKQoJCUJVRygidW5hYmxlIHRvIHBhcnNlIG91ciBvd24gaWRlbnQ6ICVzIiwgYnVmLT5idWYpOwp9CgpzdGF0aWMgdm9pZCBleHBvcnRfb25lKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqcywgY29uc3QgY2hhciAqZSwgaW50IGhhY2spCnsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglpZiAoaGFjaykKCQlzdHJidWZfYWRkY2goJmJ1ZiwgaGFjayk7CglzdHJidWZfYWRkKCZidWYsIHMsIGUgLSBzKTsKCXNldGVudih2YXIsIGJ1Zi5idWYsIDEpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7Cn0KCnN0YXRpYyBpbnQgcGFyc2VfZm9yY2VfZGF0ZShjb25zdCBjaGFyICppbiwgc3RydWN0IHN0cmJ1ZiAqb3V0KQp7CglzdHJidWZfYWRkY2gob3V0LCAnQCcpOwoKCWlmIChwYXJzZV9kYXRlKGluLCBvdXQpIDwgMCkgewoJCWludCBlcnJvcnMgPSAwOwoJCXVuc2lnbmVkIGxvbmcgdCA9IGFwcHJveGlkYXRlX2NhcmVmdWwoaW4sICZlcnJvcnMpOwoJCWlmIChlcnJvcnMpCgkJCXJldHVybiAtMTsKCQlzdHJidWZfYWRkZihvdXQsICIlbHUiLCB0KTsKCX0KCglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgc2V0X2lkZW50X3ZhcihjaGFyICoqYnVmLCBjaGFyICp2YWwpCnsKCWZyZWUoKmJ1Zik7CgkqYnVmID0gdmFsOwp9CgpzdGF0aWMgdm9pZCBkZXRlcm1pbmVfYXV0aG9yX2luZm8oc3RydWN0IHN0cmJ1ZiAqYXV0aG9yX2lkZW50KQp7CgljaGFyICpuYW1lLCAqZW1haWwsICpkYXRlOwoJc3RydWN0IGlkZW50X3NwbGl0IGF1dGhvcjsKCgluYW1lID0geHN0cmR1cF9vcl9udWxsKGdldGVudigiR0lUX0FVVEhPUl9OQU1FIikpOwoJZW1haWwgPSB4c3RyZHVwX29yX251bGwoZ2V0ZW52KCJHSVRfQVVUSE9SX0VNQUlMIikpOwoJZGF0ZSA9IHhzdHJkdXBfb3JfbnVsbChnZXRlbnYoIkdJVF9BVVRIT1JfREFURSIpKTsKCglpZiAoYXV0aG9yX21lc3NhZ2UpIHsKCQlzdHJ1Y3QgaWRlbnRfc3BsaXQgaWRlbnQ7CgkJc2l6ZV90IGxlbjsKCQljb25zdCBjaGFyICphOwoKCQlhID0gZmluZF9jb21taXRfaGVhZGVyKGF1dGhvcl9tZXNzYWdlX2J1ZmZlciwgImF1dGhvciIsICZsZW4pOwoJCWlmICghYSkKCQkJZGllKF8oImNvbW1pdCAnJXMnIGxhY2tzIGF1dGhvciBoZWFkZXIiKSwgYXV0aG9yX21lc3NhZ2UpOwoJCWlmIChzcGxpdF9pZGVudF9saW5lKCZpZGVudCwgYSwgbGVuKSA8IDApCgkJCWRpZShfKCJjb21taXQgJyVzJyBoYXMgbWFsZm9ybWVkIGF1dGhvciBsaW5lIiksIGF1dGhvcl9tZXNzYWdlKTsKCgkJc2V0X2lkZW50X3ZhcigmbmFtZSwgeG1lbWR1cHooaWRlbnQubmFtZV9iZWdpbiwgaWRlbnQubmFtZV9lbmQgLSBpZGVudC5uYW1lX2JlZ2luKSk7CgkJc2V0X2lkZW50X3ZhcigmZW1haWwsIHhtZW1kdXB6KGlkZW50Lm1haWxfYmVnaW4sIGlkZW50Lm1haWxfZW5kIC0gaWRlbnQubWFpbF9iZWdpbikpOwoKCQlpZiAoaWRlbnQuZGF0ZV9iZWdpbikgewoJCQlzdHJ1Y3Qgc3RyYnVmIGRhdGVfYnVmID0gU1RSQlVGX0lOSVQ7CgkJCXN0cmJ1Zl9hZGRjaCgmZGF0ZV9idWYsICdAJyk7CgkJCXN0cmJ1Zl9hZGQoJmRhdGVfYnVmLCBpZGVudC5kYXRlX2JlZ2luLCBpZGVudC5kYXRlX2VuZCAtIGlkZW50LmRhdGVfYmVnaW4pOwoJCQlzdHJidWZfYWRkY2goJmRhdGVfYnVmLCAnICcpOwoJCQlzdHJidWZfYWRkKCZkYXRlX2J1ZiwgaWRlbnQudHpfYmVnaW4sIGlkZW50LnR6X2VuZCAtIGlkZW50LnR6X2JlZ2luKTsKCQkJc2V0X2lkZW50X3ZhcigmZGF0ZSwgc3RyYnVmX2RldGFjaCgmZGF0ZV9idWYsIE5VTEwpKTsKCQl9Cgl9CgoJaWYgKGZvcmNlX2F1dGhvcikgewoJCXN0cnVjdCBpZGVudF9zcGxpdCBpZGVudDsKCgkJaWYgKHNwbGl0X2lkZW50X2xpbmUoJmlkZW50LCBmb3JjZV9hdXRob3IsIHN0cmxlbihmb3JjZV9hdXRob3IpKSA8IDApCgkJCWRpZShfKCJtYWxmb3JtZWQgLS1hdXRob3IgcGFyYW1ldGVyIikpOwoJCXNldF9pZGVudF92YXIoJm5hbWUsIHhtZW1kdXB6KGlkZW50Lm5hbWVfYmVnaW4sIGlkZW50Lm5hbWVfZW5kIC0gaWRlbnQubmFtZV9iZWdpbikpOwoJCXNldF9pZGVudF92YXIoJmVtYWlsLCB4bWVtZHVweihpZGVudC5tYWlsX2JlZ2luLCBpZGVudC5tYWlsX2VuZCAtIGlkZW50Lm1haWxfYmVnaW4pKTsKCX0KCglpZiAoZm9yY2VfZGF0ZSkgewoJCXN0cnVjdCBzdHJidWYgZGF0ZV9idWYgPSBTVFJCVUZfSU5JVDsKCQlpZiAocGFyc2VfZm9yY2VfZGF0ZShmb3JjZV9kYXRlLCAmZGF0ZV9idWYpKQoJCQlkaWUoXygiaW52YWxpZCBkYXRlIGZvcm1hdDogJXMiKSwgZm9yY2VfZGF0ZSk7CgkJc2V0X2lkZW50X3ZhcigmZGF0ZSwgc3RyYnVmX2RldGFjaCgmZGF0ZV9idWYsIE5VTEwpKTsKCX0KCglzdHJidWZfYWRkc3RyKGF1dGhvcl9pZGVudCwgZm10X2lkZW50KG5hbWUsIGVtYWlsLCBXQU5UX0FVVEhPUl9JREVOVCwgZGF0ZSwKCQkJCUlERU5UX1NUUklDVCkpOwoJYXNzZXJ0X3NwbGl0X2lkZW50KCZhdXRob3IsIGF1dGhvcl9pZGVudCk7CglleHBvcnRfb25lKCJHSVRfQVVUSE9SX05BTUUiLCBhdXRob3IubmFtZV9iZWdpbiwgYXV0aG9yLm5hbWVfZW5kLCAwKTsKCWV4cG9ydF9vbmUoIkdJVF9BVVRIT1JfRU1BSUwiLCBhdXRob3IubWFpbF9iZWdpbiwgYXV0aG9yLm1haWxfZW5kLCAwKTsKCWV4cG9ydF9vbmUoIkdJVF9BVVRIT1JfREFURSIsIGF1dGhvci5kYXRlX2JlZ2luLCBhdXRob3IudHpfZW5kLCAnQCcpOwoJZnJlZShuYW1lKTsKCWZyZWUoZW1haWwpOwoJZnJlZShkYXRlKTsKfQoKc3RhdGljIGludCBhdXRob3JfZGF0ZV9pc19pbnRlcmVzdGluZyh2b2lkKQp7CglyZXR1cm4gYXV0aG9yX21lc3NhZ2UgfHwgZm9yY2VfZGF0ZTsKfQoKc3RhdGljIHZvaWQgYWRqdXN0X2NvbW1lbnRfbGluZV9jaGFyKGNvbnN0IHN0cnVjdCBzdHJidWYgKnNiKQp7CgljaGFyIGNhbmRpZGF0ZXNbXSA9ICIjO0AhJCVeJnw6IjsKCWNoYXIgKmNhbmRpZGF0ZTsKCWNvbnN0IGNoYXIgKnA7CgoJY29tbWVudF9saW5lX2NoYXIgPSBjYW5kaWRhdGVzWzBdOwoJaWYgKCFtZW1jaHIoc2ItPmJ1ZiwgY29tbWVudF9saW5lX2NoYXIsIHNiLT5sZW4pKQoJCXJldHVybjsKCglwID0gc2ItPmJ1ZjsKCWNhbmRpZGF0ZSA9IHN0cmNocihjYW5kaWRhdGVzLCAqcCk7CglpZiAoY2FuZGlkYXRlKQoJCSpjYW5kaWRhdGUgPSAnICc7Cglmb3IgKHAgPSBzYi0+YnVmOyAqcDsgcCsrKSB7CgkJaWYgKChwWzBdID09ICdcbicgfHwgcFswXSA9PSAnXHInKSAmJiBwWzFdKSB7CgkJCWNhbmRpZGF0ZSA9IHN0cmNocihjYW5kaWRhdGVzLCBwWzFdKTsKCQkJaWYgKGNhbmRpZGF0ZSkKCQkJCSpjYW5kaWRhdGUgPSAnICc7CgkJfQoJfQoKCWZvciAocCA9IGNhbmRpZGF0ZXM7ICpwID09ICcgJzsgcCsrKQoJCTsKCWlmICghKnApCgkJZGllKF8oInVuYWJsZSB0byBzZWxlY3QgYSBjb21tZW50IGNoYXJhY3RlciB0aGF0IGlzIG5vdCB1c2VkXG4iCgkJICAgICAgImluIHRoZSBjdXJyZW50IGNvbW1pdCBtZXNzYWdlIikpOwoJY29tbWVudF9saW5lX2NoYXIgPSAqcDsKfQoKc3RhdGljIHZvaWQgcHJlcGFyZV9hbWVuZF9jb21taXQoc3RydWN0IGNvbW1pdCAqY29tbWl0LCBzdHJ1Y3Qgc3RyYnVmICpzYiwKCQkJCXN0cnVjdCBwcmV0dHlfcHJpbnRfY29udGV4dCAqY3R4KQp7Cgljb25zdCBjaGFyICpidWZmZXIsICpzdWJqZWN0LCAqZm10OwoKCWJ1ZmZlciA9IGdldF9jb21taXRfYnVmZmVyKGNvbW1pdCwgTlVMTCk7CglmaW5kX2NvbW1pdF9zdWJqZWN0KGJ1ZmZlciwgJnN1YmplY3QpOwoJLyoKCSAqIElmIHdlIGFtZW5kIHRoZSAnYW1lbmQhJyBjb21taXQgdGhlbiB3ZSBkb24ndCB3YW50IHRvCgkgKiBkdXBsaWNhdGUgdGhlIHN1YmplY3QgbGluZS4KCSAqLwoJZm10ID0gc3RhcnRzX3dpdGgoc3ViamVjdCwgImFtZW5kISIpID8gIiViIiA6ICIlQiI7Cglmb3JtYXRfY29tbWl0X21lc3NhZ2UoY29tbWl0LCBmbXQsIHNiLCBjdHgpOwoJdW51c2VfY29tbWl0X2J1ZmZlcihjb21taXQsIGJ1ZmZlcik7Cn0KCnN0YXRpYyBpbnQgcHJlcGFyZV90b19jb21taXQoY29uc3QgY2hhciAqaW5kZXhfZmlsZSwgY29uc3QgY2hhciAqcHJlZml4LAoJCQkgICAgIHN0cnVjdCBjb21taXQgKmN1cnJlbnRfaGVhZCwKCQkJICAgICBzdHJ1Y3Qgd3Rfc3RhdHVzICpzLAoJCQkgICAgIHN0cnVjdCBzdHJidWYgKmF1dGhvcl9pZGVudCkKewoJc3RydWN0IHN0YXQgc3RhdGJ1ZjsKCXN0cnVjdCBzdHJidWYgY29tbWl0dGVyX2lkZW50ID0gU1RSQlVGX0lOSVQ7CglpbnQgY29tbWl0dGFibGU7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpob29rX2FyZzEgPSBOVUxMOwoJY29uc3QgY2hhciAqaG9va19hcmcyID0gTlVMTDsKCWludCBjbGVhbl9tZXNzYWdlX2NvbnRlbnRzID0gKGNsZWFudXBfbW9kZSAhPSBDT01NSVRfTVNHX0NMRUFOVVBfTk9ORSk7CglpbnQgb2xkX2Rpc3BsYXlfY29tbWVudF9wcmVmaXg7CglpbnQgbWVyZ2VfY29udGFpbnNfc2Npc3NvcnMgPSAwOwoJaW50IGludm9rZWRfaG9vazsKCgkvKiBUaGlzIGNoZWNrcyBhbmQgYmFyZnMgaWYgYXV0aG9yIGlzIGJhZGx5IHNwZWNpZmllZCAqLwoJZGV0ZXJtaW5lX2F1dGhvcl9pbmZvKGF1dGhvcl9pZGVudCk7CgoJaWYgKCFub192ZXJpZnkgJiYgcnVuX2NvbW1pdF9ob29rKHVzZV9lZGl0b3IsIGluZGV4X2ZpbGUsICZpbnZva2VkX2hvb2ssCgkJCQkJICAicHJlLWNvbW1pdCIsIE5VTEwpKQoJCXJldHVybiAwOwoKCWlmIChzcXVhc2hfbWVzc2FnZSkgewoJCS8qCgkJICogSW5zZXJ0IHRoZSBwcm9wZXIgc3ViamVjdCBsaW5lIGJlZm9yZSBvdGhlciBjb21taXQKCQkgKiBtZXNzYWdlIG9wdGlvbnMgYWRkIHRoZWlyIGNvbnRlbnQuCgkJICovCgkJaWYgKHVzZV9tZXNzYWdlICYmICFzdHJjbXAodXNlX21lc3NhZ2UsIHNxdWFzaF9tZXNzYWdlKSkKCQkJc3RyYnVmX2FkZHN0cigmc2IsICJzcXVhc2ghICIpOwoJCWVsc2UgewoJCQlzdHJ1Y3QgcHJldHR5X3ByaW50X2NvbnRleHQgY3R4ID0gezB9OwoJCQlzdHJ1Y3QgY29tbWl0ICpjOwoJCQljID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfYnlfbmFtZShzcXVhc2hfbWVzc2FnZSk7CgkJCWlmICghYykKCQkJCWRpZShfKCJjb3VsZCBub3QgbG9va3VwIGNvbW1pdCAlcyIpLCBzcXVhc2hfbWVzc2FnZSk7CgkJCWN0eC5vdXRwdXRfZW5jb2RpbmcgPSBnZXRfY29tbWl0X291dHB1dF9lbmNvZGluZygpOwoJCQlmb3JtYXRfY29tbWl0X21lc3NhZ2UoYywgInNxdWFzaCEgJXNcblxuIiwgJnNiLAoJCQkJCSAgICAgICZjdHgpOwoJCX0KCX0KCglpZiAoaGF2ZV9vcHRpb25fbSAmJiAhZml4dXBfbWVzc2FnZSkgewoJCXN0cmJ1Zl9hZGRidWYoJnNiLCAmbWVzc2FnZSk7CgkJaG9va19hcmcxID0gIm1lc3NhZ2UiOwoJfSBlbHNlIGlmIChsb2dmaWxlICYmICFzdHJjbXAobG9nZmlsZSwgIi0iKSkgewoJCWlmIChpc2F0dHkoMCkpCgkJCWZwcmludGYoc3RkZXJyLCBfKCIocmVhZGluZyBsb2cgbWVzc2FnZSBmcm9tIHN0YW5kYXJkIGlucHV0KVxuIikpOwoJCWlmIChzdHJidWZfcmVhZCgmc2IsIDAsIDApIDwgMCkKCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkIGxvZyBmcm9tIHN0YW5kYXJkIGlucHV0IikpOwoJCWhvb2tfYXJnMSA9ICJtZXNzYWdlIjsKCX0gZWxzZSBpZiAobG9nZmlsZSkgewoJCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgbG9nZmlsZSwgMCkgPCAwKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlYWQgbG9nIGZpbGUgJyVzJyIpLAoJCQkJICBsb2dmaWxlKTsKCQlob29rX2FyZzEgPSAibWVzc2FnZSI7Cgl9IGVsc2UgaWYgKHVzZV9tZXNzYWdlKSB7CgkJY2hhciAqYnVmZmVyOwoJCWJ1ZmZlciA9IHN0cnN0cih1c2VfbWVzc2FnZV9idWZmZXIsICJcblxuIik7CgkJaWYgKGJ1ZmZlcikKCQkJc3RyYnVmX2FkZHN0cigmc2IsIHNraXBfYmxhbmtfbGluZXMoYnVmZmVyICsgMikpOwoJCWhvb2tfYXJnMSA9ICJjb21taXQiOwoJCWhvb2tfYXJnMiA9IHVzZV9tZXNzYWdlOwoJfSBlbHNlIGlmIChmaXh1cF9tZXNzYWdlKSB7CgkJc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0IGN0eCA9IHswfTsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgkJY2hhciAqZm10OwoJCWNvbW1pdCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2J5X25hbWUoZml4dXBfY29tbWl0KTsKCQlpZiAoIWNvbW1pdCkKCQkJZGllKF8oImNvdWxkIG5vdCBsb29rdXAgY29tbWl0ICVzIiksIGZpeHVwX2NvbW1pdCk7CgkJY3R4Lm91dHB1dF9lbmNvZGluZyA9IGdldF9jb21taXRfb3V0cHV0X2VuY29kaW5nKCk7CgkJZm10ID0geHN0cmZtdCgiJXMhICUlc1xuXG4iLCBmaXh1cF9wcmVmaXgpOwoJCWZvcm1hdF9jb21taXRfbWVzc2FnZShjb21taXQsIGZtdCwgJnNiLCAmY3R4KTsKCQlmcmVlKGZtdCk7CgkJaG9va19hcmcxID0gIm1lc3NhZ2UiOwoKCQkvKgoJCSAqIE9ubHkgYC1tYCBjb21taXQgbWVzc2FnZSBvcHRpb24gaXMgY2hlY2tlZCBoZXJlLCBhcwoJCSAqIGl0IHN1cHBvcnRzIGAtLWZpeHVwYCB0byBhcHBlbmQgdGhlIGNvbW1pdCBtZXNzYWdlLgoJCSAqCgkJICogVGhlIG90aGVyIGNvbW1pdCBtZXNzYWdlIG9wdGlvbnMgYC1jYC9gLUNgL2AtRmAgYXJlCgkJICogaW5jb21wYXRpYmxlIHdpdGggYWxsIHRoZSBmb3JtcyBvZiBgLS1maXh1cGAgYW5kCgkJICogaGF2ZSBhbHJlYWR5IGVycm9yZWQgb3V0IHdoaWxlIHBhcnNpbmcgdGhlIGBnaXQgY29tbWl0YAoJCSAqIG9wdGlvbnMuCgkJICovCgkJaWYgKGhhdmVfb3B0aW9uX20gJiYgIXN0cmNtcChmaXh1cF9wcmVmaXgsICJmaXh1cCIpKQoJCQlzdHJidWZfYWRkYnVmKCZzYiwgJm1lc3NhZ2UpOwoKCQlpZiAoIXN0cmNtcChmaXh1cF9wcmVmaXgsICJhbWVuZCIpKSB7CgkJCWlmIChoYXZlX29wdGlvbl9tKQoJCQkJZGllKF8oIm9wdGlvbnMgJyVzJyBhbmQgJyVzOiVzJyBjYW5ub3QgYmUgdXNlZCB0b2dldGhlciIpLCAiLW0iLCAiLS1maXh1cCIsIGZpeHVwX21lc3NhZ2UpOwoJCQlwcmVwYXJlX2FtZW5kX2NvbW1pdChjb21taXQsICZzYiwgJmN0eCk7CgkJfQoJfSBlbHNlIGlmICghc3RhdChnaXRfcGF0aF9tZXJnZV9tc2codGhlX3JlcG9zaXRvcnkpLCAmc3RhdGJ1ZikpIHsKCQlzaXplX3QgbWVyZ2VfbXNnX3N0YXJ0OwoKCQkvKgoJCSAqIHByZXBlbmQgU1FVQVNIX01TRyBoZXJlIGlmIGl0IGV4aXN0cyBhbmQgYQoJCSAqICJtZXJnZSAtLXNxdWFzaCIgd2FzIG9yaWdpbmFsbHkgcGVyZm9ybWVkCgkJICovCgkJaWYgKCFzdGF0KGdpdF9wYXRoX3NxdWFzaF9tc2codGhlX3JlcG9zaXRvcnkpLCAmc3RhdGJ1ZikpIHsKCQkJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJnNiLCBnaXRfcGF0aF9zcXVhc2hfbXNnKHRoZV9yZXBvc2l0b3J5KSwgMCkgPCAwKQoJCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkIFNRVUFTSF9NU0ciKSk7CgkJCWhvb2tfYXJnMSA9ICJzcXVhc2giOwoJCX0gZWxzZQoJCQlob29rX2FyZzEgPSAibWVyZ2UiOwoKCQltZXJnZV9tc2dfc3RhcnQgPSBzYi5sZW47CgkJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJnNiLCBnaXRfcGF0aF9tZXJnZV9tc2codGhlX3JlcG9zaXRvcnkpLCAwKSA8IDApCgkJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgcmVhZCBNRVJHRV9NU0ciKSk7CgoJCWlmIChjbGVhbnVwX21vZGUgPT0gQ09NTUlUX01TR19DTEVBTlVQX1NDSVNTT1JTICYmCgkJICAgIHd0X3N0YXR1c19sb2NhdGVfZW5kKHNiLmJ1ZiArIG1lcmdlX21zZ19zdGFydCwKCQkJCQkgc2IubGVuIC0gbWVyZ2VfbXNnX3N0YXJ0KSA8CgkJCQlzYi5sZW4gLSBtZXJnZV9tc2dfc3RhcnQpCgkJCW1lcmdlX2NvbnRhaW5zX3NjaXNzb3JzID0gMTsKCX0gZWxzZSBpZiAoIXN0YXQoZ2l0X3BhdGhfc3F1YXNoX21zZyh0aGVfcmVwb3NpdG9yeSksICZzdGF0YnVmKSkgewoJCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgZ2l0X3BhdGhfc3F1YXNoX21zZyh0aGVfcmVwb3NpdG9yeSksIDApIDwgMCkKCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkIFNRVUFTSF9NU0ciKSk7CgkJaG9va19hcmcxID0gInNxdWFzaCI7Cgl9IGVsc2UgaWYgKHRlbXBsYXRlX2ZpbGUpIHsKCQlpZiAoc3RyYnVmX3JlYWRfZmlsZSgmc2IsIHRlbXBsYXRlX2ZpbGUsIDApIDwgMCkKCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkICclcyciKSwgdGVtcGxhdGVfZmlsZSk7CgkJaG9va19hcmcxID0gInRlbXBsYXRlIjsKCQljbGVhbl9tZXNzYWdlX2NvbnRlbnRzID0gMDsKCX0KCgkvKgoJICogVGhlIHJlbWFpbmluZyBjYXNlcyBkb24ndCBtb2RpZnkgdGhlIHRlbXBsYXRlIG1lc3NhZ2UsIGJ1dAoJICoganVzdCBzZXQgdGhlIGFyZ3VtZW50KHMpIHRvIHRoZSBwcmVwYXJlLWNvbW1pdC1tc2cgaG9vay4KCSAqLwoJZWxzZSBpZiAod2hlbmNlID09IEZST01fTUVSR0UpCgkJaG9va19hcmcxID0gIm1lcmdlIjsKCWVsc2UgaWYgKGlzX2Zyb21fY2hlcnJ5X3BpY2sod2hlbmNlKSB8fCB3aGVuY2UgPT0gRlJPTV9SRUJBU0VfUElDSykgewoJCWhvb2tfYXJnMSA9ICJjb21taXQiOwoJCWhvb2tfYXJnMiA9ICJDSEVSUllfUElDS19IRUFEIjsKCX0KCglpZiAoc3F1YXNoX21lc3NhZ2UpIHsKCQkvKgoJCSAqIElmIHNxdWFzaF9jb21taXQgd2FzIHVzZWQgZm9yIHRoZSBjb21taXQgc3ViamVjdCwKCQkgKiB0aGVuIHdlJ3JlIHBvc3NpYmx5IGhpamFja2luZyBvdGhlciBjb21taXQgbG9nIG9wdGlvbnMuCgkJICogUmVzZXQgdGhlIGhvb2sgYXJncyB0byB0ZWxsIHRoZSByZWFsIHN0b3J5LgoJCSAqLwoJCWhvb2tfYXJnMSA9ICJtZXNzYWdlIjsKCQlob29rX2FyZzIgPSAiIjsKCX0KCglzLT5mcCA9IGZvcGVuX2Zvcl93cml0aW5nKGdpdF9wYXRoX2NvbW1pdF9lZGl0bXNnKCkpOwoJaWYgKHMtPmZwID09IE5VTEwpCgkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCBvcGVuICclcyciKSwgZ2l0X3BhdGhfY29tbWl0X2VkaXRtc2coKSk7CgoJLyogSWdub3JlIHN0YXR1cy5kaXNwbGF5Q29tbWVudFByZWZpeDogd2UgZG8gbmVlZCBjb21tZW50cyBpbiBDT01NSVRfRURJVE1TRy4gKi8KCW9sZF9kaXNwbGF5X2NvbW1lbnRfcHJlZml4ID0gcy0+ZGlzcGxheV9jb21tZW50X3ByZWZpeDsKCXMtPmRpc3BsYXlfY29tbWVudF9wcmVmaXggPSAxOwoKCS8qCgkgKiBNb3N0IGhpbnRzIGFyZSBjb3VudGVyLXByb2R1Y3RpdmUgd2hlbiB0aGUgY29tbWl0IGhhcwoJICogYWxyZWFkeSBzdGFydGVkLgoJICovCglzLT5oaW50cyA9IDA7CgoJaWYgKGNsZWFuX21lc3NhZ2VfY29udGVudHMpCgkJc3RyYnVmX3N0cmlwc3BhY2UoJnNiLCAwKTsKCglpZiAoc2lnbm9mZikKCQlhcHBlbmRfc2lnbm9mZigmc2IsIGlnbm9yZV9ub25fdHJhaWxlcihzYi5idWYsIHNiLmxlbiksIDApOwoKCWlmIChmd3JpdGUoc2IuYnVmLCAxLCBzYi5sZW4sIHMtPmZwKSA8IHNiLmxlbikKCQlkaWVfZXJybm8oXygiY291bGQgbm90IHdyaXRlIGNvbW1pdCB0ZW1wbGF0ZSIpKTsKCglpZiAoYXV0b19jb21tZW50X2xpbmVfY2hhcikKCQlhZGp1c3RfY29tbWVudF9saW5lX2NoYXIoJnNiKTsKCXN0cmJ1Zl9yZWxlYXNlKCZzYik7CgoJLyogVGhpcyBjaGVja3MgaWYgY29tbWl0dGVyIGlkZW50IGlzIGV4cGxpY2l0bHkgZ2l2ZW4gKi8KCXN0cmJ1Zl9hZGRzdHIoJmNvbW1pdHRlcl9pZGVudCwgZ2l0X2NvbW1pdHRlcl9pbmZvKElERU5UX1NUUklDVCkpOwoJaWYgKHVzZV9lZGl0b3IgJiYgaW5jbHVkZV9zdGF0dXMpIHsKCQlpbnQgaWRlbnRfc2hvd24gPSAwOwoJCWludCBzYXZlZF9jb2xvcl9zZXR0aW5nOwoJCXN0cnVjdCBpZGVudF9zcGxpdCBjaSwgYWk7CgkJY29uc3QgY2hhciAqaGludF9jbGVhbnVwX2FsbCA9IGFsbG93X2VtcHR5X21lc3NhZ2UgPwoJCQlfKCJQbGVhc2UgZW50ZXIgdGhlIGNvbW1pdCBtZXNzYWdlIGZvciB5b3VyIGNoYW5nZXMuIgoJCQkgICIgTGluZXMgc3RhcnRpbmdcbndpdGggJyVjJyB3aWxsIGJlIGlnbm9yZWQuXG4iKSA6CgkJCV8oIlBsZWFzZSBlbnRlciB0aGUgY29tbWl0IG1lc3NhZ2UgZm9yIHlvdXIgY2hhbmdlcy4iCgkJCSAgIiBMaW5lcyBzdGFydGluZ1xud2l0aCAnJWMnIHdpbGwgYmUgaWdub3JlZCwgYW5kIGFuIGVtcHR5IgoJCQkgICIgbWVzc2FnZSBhYm9ydHMgdGhlIGNvbW1pdC5cbiIpOwoJCWNvbnN0IGNoYXIgKmhpbnRfY2xlYW51cF9zcGFjZSA9IGFsbG93X2VtcHR5X21lc3NhZ2UgPwoJCQlfKCJQbGVhc2UgZW50ZXIgdGhlIGNvbW1pdCBtZXNzYWdlIGZvciB5b3VyIGNoYW5nZXMuIgoJCQkgICIgTGluZXMgc3RhcnRpbmdcbiIKCQkJICAid2l0aCAnJWMnIHdpbGwgYmUga2VwdDsgeW91IG1heSByZW1vdmUgdGhlbSIKCQkJICAiIHlvdXJzZWxmIGlmIHlvdSB3YW50IHRvLlxuIikgOgoJCQlfKCJQbGVhc2UgZW50ZXIgdGhlIGNvbW1pdCBtZXNzYWdlIGZvciB5b3VyIGNoYW5nZXMuIgoJCQkgICIgTGluZXMgc3RhcnRpbmdcbiIKCQkJICAid2l0aCAnJWMnIHdpbGwgYmUga2VwdDsgeW91IG1heSByZW1vdmUgdGhlbSIKCQkJICAiIHlvdXJzZWxmIGlmIHlvdSB3YW50IHRvLlxuIgoJCQkgICJBbiBlbXB0eSBtZXNzYWdlIGFib3J0cyB0aGUgY29tbWl0LlxuIik7CgkJaWYgKHdoZW5jZSAhPSBGUk9NX0NPTU1JVCkgewoJCQlpZiAoY2xlYW51cF9tb2RlID09IENPTU1JVF9NU0dfQ0xFQU5VUF9TQ0lTU09SUyAmJgoJCQkJIW1lcmdlX2NvbnRhaW5zX3NjaXNzb3JzKQoJCQkJd3Rfc3RhdHVzX2FkZF9jdXRfbGluZShzLT5mcCk7CgkJCXN0YXR1c19wcmludGZfbG4oCgkJCQlzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJd2hlbmNlID09IEZST01fTUVSR0UgPwoJCQkJCSAgICAgIF8oIlxuIgoJCQkJCSAgIkl0IGxvb2tzIGxpa2UgeW91IG1heSBiZSBjb21taXR0aW5nIGEgbWVyZ2UuXG4iCgkJCQkJICAiSWYgdGhpcyBpcyBub3QgY29ycmVjdCwgcGxlYXNlIHJ1blxuIgoJCQkJCSAgIglnaXQgdXBkYXRlLXJlZiAtZCBNRVJHRV9IRUFEXG4iCgkJCQkJICAiYW5kIHRyeSBhZ2Fpbi5cbiIpIDoKCQkJCQkgICAgICBfKCJcbiIKCQkJCQkgICJJdCBsb29rcyBsaWtlIHlvdSBtYXkgYmUgY29tbWl0dGluZyBhIGNoZXJyeS1waWNrLlxuIgoJCQkJCSAgIklmIHRoaXMgaXMgbm90IGNvcnJlY3QsIHBsZWFzZSBydW5cbiIKCQkJCQkgICIJZ2l0IHVwZGF0ZS1yZWYgLWQgQ0hFUlJZX1BJQ0tfSEVBRFxuIgoJCQkJCSAgImFuZCB0cnkgYWdhaW4uXG4iKSk7CgkJfQoKCQlmcHJpbnRmKHMtPmZwLCAiXG4iKTsKCQlpZiAoY2xlYW51cF9tb2RlID09IENPTU1JVF9NU0dfQ0xFQU5VUF9BTEwpCgkJCXN0YXR1c19wcmludGYocywgR0lUX0NPTE9SX05PUk1BTCwgaGludF9jbGVhbnVwX2FsbCwgY29tbWVudF9saW5lX2NoYXIpOwoJCWVsc2UgaWYgKGNsZWFudXBfbW9kZSA9PSBDT01NSVRfTVNHX0NMRUFOVVBfU0NJU1NPUlMpIHsKCQkJaWYgKHdoZW5jZSA9PSBGUk9NX0NPTU1JVCAmJiAhbWVyZ2VfY29udGFpbnNfc2Npc3NvcnMpCgkJCQl3dF9zdGF0dXNfYWRkX2N1dF9saW5lKHMtPmZwKTsKCQl9IGVsc2UgLyogQ09NTUlUX01TR19DTEVBTlVQX1NQQUNFLCB0aGF0IGlzLiAqLwoJCQlzdGF0dXNfcHJpbnRmKHMsIEdJVF9DT0xPUl9OT1JNQUwsIGhpbnRfY2xlYW51cF9zcGFjZSwgY29tbWVudF9saW5lX2NoYXIpOwoKCQkvKgoJCSAqIFRoZXNlIHNob3VsZCBuZXZlciBmYWlsIGJlY2F1c2UgdGhleSBjb21lIGZyb20gb3VyIG93bgoJCSAqIGZtdF9pZGVudC4gVGhleSBtYXkgZmFpbCB0aGUgc2FuZV9pZGVudCB0ZXN0LCBidXQgd2Uga25vdwoJCSAqIHRoYXQgdGhlIG5hbWUgYW5kIG1haWwgcG9pbnRlcnMgd2lsbCBhdCBsZWFzdCBiZSB2YWxpZCwKCQkgKiB3aGljaCBpcyBlbm91Z2ggZm9yIG91ciB0ZXN0cyBhbmQgcHJpbnRpbmcgaGVyZS4KCQkgKi8KCQlhc3NlcnRfc3BsaXRfaWRlbnQoJmFpLCBhdXRob3JfaWRlbnQpOwoJCWFzc2VydF9zcGxpdF9pZGVudCgmY2ksICZjb21taXR0ZXJfaWRlbnQpOwoKCQlpZiAoaWRlbnRfY21wKCZhaSwgJmNpKSkKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJXygiJXMiCgkJCQkiQXV0aG9yOiAgICAlLipzIDwlLipzPiIpLAoJCQkJaWRlbnRfc2hvd24rKyA/ICIiIDogIlxuIiwKCQkJCShpbnQpKGFpLm5hbWVfZW5kIC0gYWkubmFtZV9iZWdpbiksIGFpLm5hbWVfYmVnaW4sCgkJCQkoaW50KShhaS5tYWlsX2VuZCAtIGFpLm1haWxfYmVnaW4pLCBhaS5tYWlsX2JlZ2luKTsKCgkJaWYgKGF1dGhvcl9kYXRlX2lzX2ludGVyZXN0aW5nKCkpCgkJCXN0YXR1c19wcmludGZfbG4ocywgR0lUX0NPTE9SX05PUk1BTCwKCQkJCV8oIiVzIgoJCQkJIkRhdGU6ICAgICAgJXMiKSwKCQkJCWlkZW50X3Nob3duKysgPyAiIiA6ICJcbiIsCgkJCQlzaG93X2lkZW50X2RhdGUoJmFpLCBEQVRFX01PREUoTk9STUFMKSkpOwoKCQlpZiAoIWNvbW1pdHRlcl9pZGVudF9zdWZmaWNpZW50bHlfZ2l2ZW4oKSkKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJXygiJXMiCgkJCQkiQ29tbWl0dGVyOiAlLipzIDwlLipzPiIpLAoJCQkJaWRlbnRfc2hvd24rKyA/ICIiIDogIlxuIiwKCQkJCShpbnQpKGNpLm5hbWVfZW5kIC0gY2kubmFtZV9iZWdpbiksIGNpLm5hbWVfYmVnaW4sCgkJCQkoaW50KShjaS5tYWlsX2VuZCAtIGNpLm1haWxfYmVnaW4pLCBjaS5tYWlsX2JlZ2luKTsKCgkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLCAiJXMiLCAiIik7IC8qIEFkZCBuZXcgbGluZSBmb3IgY2xhcml0eSAqLwoKCQlzYXZlZF9jb2xvcl9zZXR0aW5nID0gcy0+dXNlX2NvbG9yOwoJCXMtPnVzZV9jb2xvciA9IDA7CgkJY29tbWl0dGFibGUgPSBydW5fc3RhdHVzKHMtPmZwLCBpbmRleF9maWxlLCBwcmVmaXgsIDEsIHMpOwoJCXMtPnVzZV9jb2xvciA9IHNhdmVkX2NvbG9yX3NldHRpbmc7CgkJc3RyaW5nX2xpc3RfY2xlYXIoJnMtPmNoYW5nZSwgMSk7Cgl9IGVsc2UgewoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCWNvbnN0IGNoYXIgKnBhcmVudCA9ICJIRUFEIjsKCgkJaWYgKCFhY3RpdmVfbnIgJiYgcmVhZF9jYWNoZSgpIDwgMCkKCQkJZGllKF8oIkNhbm5vdCByZWFkIGluZGV4IikpOwoKCQlpZiAoYW1lbmQpCgkJCXBhcmVudCA9ICJIRUFEXjEiOwoKCQlpZiAoZ2V0X29pZChwYXJlbnQsICZvaWQpKSB7CgkJCWludCBpLCBpdGFfbnIgPSAwOwoKCQkJLyogVE9ETzogYXVkaXQgZm9yIGludGVyYWN0aW9uIHdpdGggc3BhcnNlLWluZGV4LiAqLwoJCQllbnN1cmVfZnVsbF9pbmRleCgmdGhlX2luZGV4KTsKCQkJZm9yIChpID0gMDsgaSA8IGFjdGl2ZV9ucjsgaSsrKQoJCQkJaWYgKGNlX2ludGVudF90b19hZGQoYWN0aXZlX2NhY2hlW2ldKSkKCQkJCQlpdGFfbnIrKzsKCQkJY29tbWl0dGFibGUgPSBhY3RpdmVfbnIgLSBpdGFfbnIgPiAwOwoJCX0gZWxzZSB7CgkJCS8qCgkJCSAqIFVubGVzcyB0aGUgdXNlciBkaWQgZXhwbGljaXRseSByZXF1ZXN0IGEgc3VibW9kdWxlCgkJCSAqIGlnbm9yZSBtb2RlIGJ5IHBhc3NpbmcgYSBjb21tYW5kIGxpbmUgb3B0aW9uIHdlIGRvCgkJCSAqIG5vdCBpZ25vcmUgYW55IGNoYW5nZWQgc3VibW9kdWxlIFNIQS0xcyB3aGVuCgkJCSAqIGNvbXBhcmluZyBpbmRleCBhbmQgcGFyZW50LCBubyBtYXR0ZXIgd2hhdCBpcwoJCQkgKiBjb25maWd1cmVkLiBPdGhlcndpc2Ugd2Ugd29uJ3QgY29tbWl0IGFueQoJCQkgKiBzdWJtb2R1bGVzIHdoaWNoIHdlcmUgbWFudWFsbHkgc3RhZ2VkLCB3aGljaCB3b3VsZAoJCQkgKiBiZSByZWFsbHkgY29uZnVzaW5nLgoJCQkgKi8KCQkJc3RydWN0IGRpZmZfZmxhZ3MgZmxhZ3MgPSBESUZGX0ZMQUdTX0lOSVQ7CgkJCWZsYWdzLm92ZXJyaWRlX3N1Ym1vZHVsZV9jb25maWcgPSAxOwoJCQlpZiAoaWdub3JlX3N1Ym1vZHVsZV9hcmcgJiYKCQkJICAgICFzdHJjbXAoaWdub3JlX3N1Ym1vZHVsZV9hcmcsICJhbGwiKSkKCQkJCWZsYWdzLmlnbm9yZV9zdWJtb2R1bGVzID0gMTsKCQkJY29tbWl0dGFibGUgPSBpbmRleF9kaWZmZXJzX2Zyb20odGhlX3JlcG9zaXRvcnksCgkJCQkJCQkgcGFyZW50LCAmZmxhZ3MsIDEpOwoJCX0KCX0KCXN0cmJ1Zl9yZWxlYXNlKCZjb21taXR0ZXJfaWRlbnQpOwoKCWZjbG9zZShzLT5mcCk7CgoJaWYgKHRyYWlsZXJfYXJncy5ucikgewoJCXN0cnVjdCBjaGlsZF9wcm9jZXNzIHJ1bl90cmFpbGVyID0gQ0hJTERfUFJPQ0VTU19JTklUOwoKCQlzdHJ2ZWNfcHVzaGwoJnJ1bl90cmFpbGVyLmFyZ3MsICJpbnRlcnByZXQtdHJhaWxlcnMiLAoJCQkgICAgICItLWluLXBsYWNlIiwgZ2l0X3BhdGhfY29tbWl0X2VkaXRtc2coKSwgTlVMTCk7CgkJc3RydmVjX3B1c2h2KCZydW5fdHJhaWxlci5hcmdzLCB0cmFpbGVyX2FyZ3Mudik7CgkJcnVuX3RyYWlsZXIuZ2l0X2NtZCA9IDE7CgkJaWYgKHJ1bl9jb21tYW5kKCZydW5fdHJhaWxlcikpCgkJCWRpZShfKCJ1bmFibGUgdG8gcGFzcyB0cmFpbGVycyB0byAtLXRyYWlsZXJzIikpOwoJCXN0cnZlY19jbGVhcigmdHJhaWxlcl9hcmdzKTsKCX0KCgkvKgoJICogUmVqZWN0IGFuIGF0dGVtcHQgdG8gcmVjb3JkIGEgbm9uLW1lcmdlIGVtcHR5IGNvbW1pdCB3aXRob3V0CgkgKiBleHBsaWNpdCAtLWFsbG93LWVtcHR5LiBJbiB0aGUgY2hlcnJ5LXBpY2sgY2FzZSwgaXQgbWF5IGJlCgkgKiBlbXB0eSBkdWUgdG8gY29uZmxpY3QgcmVzb2x1dGlvbiwgd2hpY2ggdGhlIHVzZXIgc2hvdWxkIG9rYXkuCgkgKi8KCWlmICghY29tbWl0dGFibGUgJiYgd2hlbmNlICE9IEZST01fTUVSR0UgJiYgIWFsbG93X2VtcHR5ICYmCgkgICAgIShhbWVuZCAmJiBpc19hX21lcmdlKGN1cnJlbnRfaGVhZCkpKSB7CgkJcy0+aGludHMgPSBhZHZpY2VfZW5hYmxlZChBRFZJQ0VfU1RBVFVTX0hJTlRTKTsKCQlzLT5kaXNwbGF5X2NvbW1lbnRfcHJlZml4ID0gb2xkX2Rpc3BsYXlfY29tbWVudF9wcmVmaXg7CgkJcnVuX3N0YXR1cyhzdGRvdXQsIGluZGV4X2ZpbGUsIHByZWZpeCwgMCwgcyk7CgkJaWYgKGFtZW5kKQoJCQlmcHV0cyhfKGVtcHR5X2FtZW5kX2FkdmljZSksIHN0ZGVycik7CgkJZWxzZSBpZiAoaXNfZnJvbV9jaGVycnlfcGljayh3aGVuY2UpIHx8CgkJCSB3aGVuY2UgPT0gRlJPTV9SRUJBU0VfUElDSykgewoJCQlmcHV0cyhfKGVtcHR5X2NoZXJyeV9waWNrX2FkdmljZSksIHN0ZGVycik7CgkJCWlmICh3aGVuY2UgPT0gRlJPTV9DSEVSUllfUElDS19TSU5HTEUpCgkJCQlmcHV0cyhfKGVtcHR5X2NoZXJyeV9waWNrX2FkdmljZV9zaW5nbGUpLCBzdGRlcnIpOwoJCQllbHNlIGlmICh3aGVuY2UgPT0gRlJPTV9DSEVSUllfUElDS19NVUxUSSkKCQkJCWZwdXRzKF8oZW1wdHlfY2hlcnJ5X3BpY2tfYWR2aWNlX211bHRpKSwgc3RkZXJyKTsKCQkJZWxzZQoJCQkJZnB1dHMoXyhlbXB0eV9yZWJhc2VfcGlja19hZHZpY2UpLCBzdGRlcnIpOwoJCX0KCQlyZXR1cm4gMDsKCX0KCglpZiAoIW5vX3ZlcmlmeSAmJiBpbnZva2VkX2hvb2spIHsKCQkvKgoJCSAqIFJlLXJlYWQgdGhlIGluZGV4IGFzIHRoZSBwcmUtY29tbWl0LWNvbW1pdCBob29rIHdhcyBpbnZva2VkCgkJICogYW5kIGNvdWxkIGhhdmUgdXBkYXRlZCBpdC4gV2UgbXVzdCBkbyB0aGlzIGJlZm9yZSB3ZSBpbnZva2UKCQkgKiB0aGUgZWRpdG9yIGFuZCBhZnRlciB3ZSBpbnZva2UgcnVuX3N0YXR1cyBhYm92ZS4KCQkgKi8KCQlkaXNjYXJkX2NhY2hlKCk7Cgl9CglyZWFkX2NhY2hlX2Zyb20oaW5kZXhfZmlsZSk7CgoJaWYgKHVwZGF0ZV9tYWluX2NhY2hlX3RyZWUoMCkpIHsKCQllcnJvcihfKCJFcnJvciBidWlsZGluZyB0cmVlcyIpKTsKCQlyZXR1cm4gMDsKCX0KCglpZiAocnVuX2NvbW1pdF9ob29rKHVzZV9lZGl0b3IsIGluZGV4X2ZpbGUsIE5VTEwsICJwcmVwYXJlLWNvbW1pdC1tc2ciLAoJCQkgICAgZ2l0X3BhdGhfY29tbWl0X2VkaXRtc2coKSwgaG9va19hcmcxLCBob29rX2FyZzIsIE5VTEwpKQoJCXJldHVybiAwOwoKCWlmICh1c2VfZWRpdG9yKSB7CgkJc3RydWN0IHN0cnZlYyBlbnYgPSBTVFJWRUNfSU5JVDsKCgkJc3RydmVjX3B1c2hmKCZlbnYsICJHSVRfSU5ERVhfRklMRT0lcyIsIGluZGV4X2ZpbGUpOwoJCWlmIChsYXVuY2hfZWRpdG9yKGdpdF9wYXRoX2NvbW1pdF9lZGl0bXNnKCksIE5VTEwsIGVudi52KSkgewoJCQlmcHJpbnRmKHN0ZGVyciwKCQkJXygiUGxlYXNlIHN1cHBseSB0aGUgbWVzc2FnZSB1c2luZyBlaXRoZXIgLW0gb3IgLUYgb3B0aW9uLlxuIikpOwoJCQlleGl0KDEpOwoJCX0KCQlzdHJ2ZWNfY2xlYXIoJmVudik7Cgl9CgoJaWYgKCFub192ZXJpZnkgJiYKCSAgICBydW5fY29tbWl0X2hvb2sodXNlX2VkaXRvciwgaW5kZXhfZmlsZSwgTlVMTCwgImNvbW1pdC1tc2ciLAoJCQkgICAgZ2l0X3BhdGhfY29tbWl0X2VkaXRtc2coKSwgTlVMTCkpIHsKCQlyZXR1cm4gMDsKCX0KCglyZXR1cm4gMTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKmZpbmRfYXV0aG9yX2J5X25pY2tuYW1lKGNvbnN0IGNoYXIgKm5hbWUpCnsKCXN0cnVjdCByZXZfaW5mbyByZXZzOwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJpbmdfbGlzdCBtYWlsbWFwID0gU1RSSU5HX0xJU1RfSU5JVF9OT0RVUDsKCWNvbnN0IGNoYXIgKmF2WzIwXTsKCWludCBhYyA9IDA7CgoJcmVwb19pbml0X3JldmlzaW9ucyh0aGVfcmVwb3NpdG9yeSwgJnJldnMsIE5VTEwpOwoJc3RyYnVmX2FkZGYoJmJ1ZiwgIi0tYXV0aG9yPSVzIiwgbmFtZSk7CglhdlsrK2FjXSA9ICItLWFsbCI7CglhdlsrK2FjXSA9ICItaSI7CglhdlsrK2FjXSA9IGJ1Zi5idWY7CglhdlsrK2FjXSA9IE5VTEw7CglzZXR1cF9yZXZpc2lvbnMoYWMsIGF2LCAmcmV2cywgTlVMTCk7CglyZXZzLm1haWxtYXAgPSAmbWFpbG1hcDsKCXJlYWRfbWFpbG1hcChyZXZzLm1haWxtYXApOwoKCWlmIChwcmVwYXJlX3JldmlzaW9uX3dhbGsoJnJldnMpKQoJCWRpZShfKCJyZXZpc2lvbiB3YWxrIHNldHVwIGZhaWxlZCIpKTsKCWNvbW1pdCA9IGdldF9yZXZpc2lvbigmcmV2cyk7CglpZiAoY29tbWl0KSB7CgkJc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0IGN0eCA9IHswfTsKCQljdHguZGF0ZV9tb2RlLnR5cGUgPSBEQVRFX05PUk1BTDsKCQlzdHJidWZfcmVsZWFzZSgmYnVmKTsKCQlmb3JtYXRfY29tbWl0X21lc3NhZ2UoY29tbWl0LCAiJWFOIDwlYUU+IiwgJmJ1ZiwgJmN0eCk7CgkJY2xlYXJfbWFpbG1hcCgmbWFpbG1hcCk7CgkJcmV0dXJuIHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7Cgl9CglkaWUoXygiLS1hdXRob3IgJyVzJyBpcyBub3QgJ05hbWUgPGVtYWlsPicgYW5kIG1hdGNoZXMgbm8gZXhpc3RpbmcgYXV0aG9yIiksIG5hbWUpOwp9CgpzdGF0aWMgdm9pZCBoYW5kbGVfaWdub3JlZF9hcmcoc3RydWN0IHd0X3N0YXR1cyAqcykKewoJaWYgKCFpZ25vcmVkX2FyZykKCQk7IC8qIGRlZmF1bHQgYWxyZWFkeSBpbml0aWFsaXplZCAqLwoJZWxzZSBpZiAoIXN0cmNtcChpZ25vcmVkX2FyZywgInRyYWRpdGlvbmFsIikpCgkJcy0+c2hvd19pZ25vcmVkX21vZGUgPSBTSE9XX1RSQURJVElPTkFMX0lHTk9SRUQ7CgllbHNlIGlmICghc3RyY21wKGlnbm9yZWRfYXJnLCAibm8iKSkKCQlzLT5zaG93X2lnbm9yZWRfbW9kZSA9IFNIT1dfTk9fSUdOT1JFRDsKCWVsc2UgaWYgKCFzdHJjbXAoaWdub3JlZF9hcmcsICJtYXRjaGluZyIpKQoJCXMtPnNob3dfaWdub3JlZF9tb2RlID0gU0hPV19NQVRDSElOR19JR05PUkVEOwoJZWxzZQoJCWRpZShfKCJJbnZhbGlkIGlnbm9yZWQgbW9kZSAnJXMnIiksIGlnbm9yZWRfYXJnKTsKfQoKc3RhdGljIHZvaWQgaGFuZGxlX3VudHJhY2tlZF9maWxlc19hcmcoc3RydWN0IHd0X3N0YXR1cyAqcykKewoJaWYgKCF1bnRyYWNrZWRfZmlsZXNfYXJnKQoJCTsgLyogZGVmYXVsdCBhbHJlYWR5IGluaXRpYWxpemVkICovCgllbHNlIGlmICghc3RyY21wKHVudHJhY2tlZF9maWxlc19hcmcsICJubyIpKQoJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19OT19VTlRSQUNLRURfRklMRVM7CgllbHNlIGlmICghc3RyY21wKHVudHJhY2tlZF9maWxlc19hcmcsICJub3JtYWwiKSkKCQlzLT5zaG93X3VudHJhY2tlZF9maWxlcyA9IFNIT1dfTk9STUFMX1VOVFJBQ0tFRF9GSUxFUzsKCWVsc2UgaWYgKCFzdHJjbXAodW50cmFja2VkX2ZpbGVzX2FyZywgImFsbCIpKQoJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19BTExfVU5UUkFDS0VEX0ZJTEVTOwoJLyoKCSAqIFBsZWFzZSB1cGRhdGUgJF9fZ2l0X3VudHJhY2tlZF9maWxlX21vZGVzIGluCgkgKiBnaXQtY29tcGxldGlvbi5iYXNoIHdoZW4geW91IGFkZCBuZXcgb3B0aW9ucwoJICovCgllbHNlCgkJZGllKF8oIkludmFsaWQgdW50cmFja2VkIGZpbGVzIG1vZGUgJyVzJyIpLCB1bnRyYWNrZWRfZmlsZXNfYXJnKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnJlYWRfY29tbWl0X21lc3NhZ2UoY29uc3QgY2hhciAqbmFtZSkKewoJY29uc3QgY2hhciAqb3V0X2VuYzsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCgljb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9ieV9uYW1lKG5hbWUpOwoJaWYgKCFjb21taXQpCgkJZGllKF8oImNvdWxkIG5vdCBsb29rdXAgY29tbWl0ICVzIiksIG5hbWUpOwoJb3V0X2VuYyA9IGdldF9jb21taXRfb3V0cHV0X2VuY29kaW5nKCk7CglyZXR1cm4gbG9nbXNnX3JlZW5jb2RlKGNvbW1pdCwgTlVMTCwgb3V0X2VuYyk7Cn0KCi8qCiAqIEVudW1lcmF0ZSB3aGF0IG5lZWRzIHRvIGJlIHByb3BhZ2F0ZWQgd2hlbiAtLXBvcmNlbGFpbgogKiBpcyBub3QgaW4gZWZmZWN0IGhlcmUuCiAqLwpzdGF0aWMgc3RydWN0IHN0YXR1c19kZWZlcnJlZF9jb25maWcgewoJZW51bSB3dF9zdGF0dXNfZm9ybWF0IHN0YXR1c19mb3JtYXQ7CglpbnQgc2hvd19icmFuY2g7CgllbnVtIGFoZWFkX2JlaGluZF9mbGFncyBhaGVhZF9iZWhpbmQ7Cn0gc3RhdHVzX2RlZmVycmVkX2NvbmZpZyA9IHsKCVNUQVRVU19GT1JNQVRfVU5TUEVDSUZJRUQsCgktMSwgLyogdW5zcGVjaWZpZWQgKi8KCUFIRUFEX0JFSElORF9VTlNQRUNJRklFRCwKfTsKCnN0YXRpYyB2b2lkIGZpbmFsaXplX2RlZmVycmVkX2NvbmZpZyhzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglpbnQgdXNlX2RlZmVycmVkX2NvbmZpZyA9IChzdGF0dXNfZm9ybWF0ICE9IFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOICYmCgkJCQkgICBzdGF0dXNfZm9ybWF0ICE9IFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOX1YyICYmCgkJCQkgICAhcy0+bnVsbF90ZXJtaW5hdGlvbik7CgoJaWYgKHMtPm51bGxfdGVybWluYXRpb24pIHsKCQlpZiAoc3RhdHVzX2Zvcm1hdCA9PSBTVEFUVVNfRk9STUFUX05PTkUgfHwKCQkgICAgc3RhdHVzX2Zvcm1hdCA9PSBTVEFUVVNfRk9STUFUX1VOU1BFQ0lGSUVEKQoJCQlzdGF0dXNfZm9ybWF0ID0gU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU47CgkJZWxzZSBpZiAoc3RhdHVzX2Zvcm1hdCA9PSBTVEFUVVNfRk9STUFUX0xPTkcpCgkJCWRpZShfKCJvcHRpb25zICclcycgYW5kICclcycgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIiKSwgIi0tbG9uZyIsICIteiIpOwoJfQoKCWlmICh1c2VfZGVmZXJyZWRfY29uZmlnICYmIHN0YXR1c19mb3JtYXQgPT0gU1RBVFVTX0ZPUk1BVF9VTlNQRUNJRklFRCkKCQlzdGF0dXNfZm9ybWF0ID0gc3RhdHVzX2RlZmVycmVkX2NvbmZpZy5zdGF0dXNfZm9ybWF0OwoJaWYgKHN0YXR1c19mb3JtYXQgPT0gU1RBVFVTX0ZPUk1BVF9VTlNQRUNJRklFRCkKCQlzdGF0dXNfZm9ybWF0ID0gU1RBVFVTX0ZPUk1BVF9OT05FOwoKCWlmICh1c2VfZGVmZXJyZWRfY29uZmlnICYmIHMtPnNob3dfYnJhbmNoIDwgMCkKCQlzLT5zaG93X2JyYW5jaCA9IHN0YXR1c19kZWZlcnJlZF9jb25maWcuc2hvd19icmFuY2g7CglpZiAocy0+c2hvd19icmFuY2ggPCAwKQoJCXMtPnNob3dfYnJhbmNoID0gMDsKCgkvKgoJICogSWYgdGhlIHVzZXIgZGlkIG5vdCBnaXZlIGEgIi0tW25vXS1haGVhZC1iZWhpbmQiIGNvbW1hbmQKCSAqIGxpbmUgYXJndW1lbnQgKkFORCogd2Ugd2lsbCBwcmludCBpbiBhIGh1bWFuLXJlYWRhYmxlIGZvcm1hdAoJICogKHNob3J0LCBsb25nIGV0Yy4pIHRoZW4gd2UgaW5oZXJpdCBmcm9tIHRoZSBzdGF0dXMuYWhlYWRiZWhpbmQKCSAqIGNvbmZpZyBzZXR0aW5nLiAgSW4gYWxsIG90aGVyIGNhc2VzIChhbmQgcG9yY2VsYWluIFZbMTJdIGZvcm1hdHMKCSAqIGluIHBhcnRpY3VsYXIpLCB3ZSBpbmhlcml0IF9GVUxMIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4KCSAqLwoJaWYgKHVzZV9kZWZlcnJlZF9jb25maWcgJiYKCSAgICBzLT5haGVhZF9iZWhpbmRfZmxhZ3MgPT0gQUhFQURfQkVISU5EX1VOU1BFQ0lGSUVEKQoJCXMtPmFoZWFkX2JlaGluZF9mbGFncyA9IHN0YXR1c19kZWZlcnJlZF9jb25maWcuYWhlYWRfYmVoaW5kOwoKCWlmIChzLT5haGVhZF9iZWhpbmRfZmxhZ3MgPT0gQUhFQURfQkVISU5EX1VOU1BFQ0lGSUVEKQoJCXMtPmFoZWFkX2JlaGluZF9mbGFncyA9IEFIRUFEX0JFSElORF9GVUxMOwp9CgpzdGF0aWMgdm9pZCBjaGVja19maXh1cF9yZXdvcmRfb3B0aW9ucyhpbnQgYXJnYywgY29uc3QgY2hhciAqYXJndltdKSB7CglpZiAod2hlbmNlICE9IEZST01fQ09NTUlUKSB7CgkJaWYgKHdoZW5jZSA9PSBGUk9NX01FUkdFKQoJCQlkaWUoXygiWW91IGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgbWVyZ2UgLS0gY2Fubm90IHJld29yZC4iKSk7CgkJZWxzZSBpZiAoaXNfZnJvbV9jaGVycnlfcGljayh3aGVuY2UpKQoJCQlkaWUoXygiWW91IGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgY2hlcnJ5LXBpY2sgLS0gY2Fubm90IHJld29yZC4iKSk7Cgl9CglpZiAoYXJnYykKCQlkaWUoXygicmV3b3JkIG9wdGlvbiBvZiAnJXMnIGFuZCBwYXRoICclcycgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIiKSwgIi0tZml4dXAiLCAqYXJndik7CglpZiAocGF0Y2hfaW50ZXJhY3RpdmUgfHwgaW50ZXJhY3RpdmUgfHwgYWxsIHx8IGFsc28gfHwgb25seSkKCQlkaWUoXygicmV3b3JkIG9wdGlvbiBvZiAnJXMnIGFuZCAnJXMnIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIiksCgkJCSItLWZpeHVwIiwgIi0tcGF0Y2gvLS1pbnRlcmFjdGl2ZS8tLWFsbC8tLWluY2x1ZGUvLS1vbmx5Iik7Cn0KCnN0YXRpYyBpbnQgcGFyc2VfYW5kX3ZhbGlkYXRlX29wdGlvbnMoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKmFyZ3ZbXSwKCQkJCSAgICAgIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdGlvbnMsCgkJCQkgICAgICBjb25zdCBjaGFyICogY29uc3QgdXNhZ2VbXSwKCQkJCSAgICAgIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJCSAgICAgIHN0cnVjdCBjb21taXQgKmN1cnJlbnRfaGVhZCwKCQkJCSAgICAgIHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgb3B0aW9ucywgdXNhZ2UsIDApOwoJZmluYWxpemVfZGVmZXJyZWRfY29uZmlnKHMpOwoKCWlmIChmb3JjZV9hdXRob3IgJiYgIXN0cmNocihmb3JjZV9hdXRob3IsICc+JykpCgkJZm9yY2VfYXV0aG9yID0gZmluZF9hdXRob3JfYnlfbmlja25hbWUoZm9yY2VfYXV0aG9yKTsKCglpZiAoZm9yY2VfYXV0aG9yICYmIHJlbmV3X2F1dGhvcnNoaXApCgkJZGllKF8oIm9wdGlvbnMgJyVzJyBhbmQgJyVzJyBjYW5ub3QgYmUgdXNlZCB0b2dldGhlciIpLCAiLS1yZXNldC1hdXRob3IiLCAiLS1hdXRob3IiKTsKCglpZiAobG9nZmlsZSB8fCBoYXZlX29wdGlvbl9tIHx8IHVzZV9tZXNzYWdlKQoJCXVzZV9lZGl0b3IgPSAwOwoKCS8qIFNhbml0eSBjaGVjayBvcHRpb25zICovCglpZiAoYW1lbmQgJiYgIWN1cnJlbnRfaGVhZCkKCQlkaWUoXygiWW91IGhhdmUgbm90aGluZyB0byBhbWVuZC4iKSk7CglpZiAoYW1lbmQgJiYgd2hlbmNlICE9IEZST01fQ09NTUlUKSB7CgkJaWYgKHdoZW5jZSA9PSBGUk9NX01FUkdFKQoJCQlkaWUoXygiWW91IGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgbWVyZ2UgLS0gY2Fubm90IGFtZW5kLiIpKTsKCQllbHNlIGlmIChpc19mcm9tX2NoZXJyeV9waWNrKHdoZW5jZSkpCgkJCWRpZShfKCJZb3UgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSBjaGVycnktcGljayAtLSBjYW5ub3QgYW1lbmQuIikpOwoJCWVsc2UgaWYgKHdoZW5jZSA9PSBGUk9NX1JFQkFTRV9QSUNLKQoJCQlkaWUoXygiWW91IGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgcmViYXNlIC0tIGNhbm5vdCBhbWVuZC4iKSk7Cgl9CglpZiAoZml4dXBfbWVzc2FnZSAmJiBzcXVhc2hfbWVzc2FnZSkKCQlkaWUoXygib3B0aW9ucyAnJXMnIGFuZCAnJXMnIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIiksICItLXNxdWFzaCIsICItLWZpeHVwIik7CglkaWVfZm9yX2luY29tcGF0aWJsZV9vcHQ0KCEhdXNlX21lc3NhZ2UsICItQyIsCgkJCQkgICEhZWRpdF9tZXNzYWdlLCAiLWMiLAoJCQkJICAhIWxvZ2ZpbGUsICItRiIsCgkJCQkgICEhZml4dXBfbWVzc2FnZSwgIi0tZml4dXAiKTsKCWRpZV9mb3JfaW5jb21wYXRpYmxlX29wdDQoaGF2ZV9vcHRpb25fbSwgIi1tIiwKCQkJCSAgISFlZGl0X21lc3NhZ2UsICItYyIsCgkJCQkgICEhdXNlX21lc3NhZ2UsICItQyIsCgkJCQkgICEhbG9nZmlsZSwgIi1GIik7CglpZiAodXNlX21lc3NhZ2UgfHwgZWRpdF9tZXNzYWdlIHx8IGxvZ2ZpbGUgfHxmaXh1cF9tZXNzYWdlIHx8IGhhdmVfb3B0aW9uX20pCgkJdGVtcGxhdGVfZmlsZSA9IE5VTEw7CglpZiAoZWRpdF9tZXNzYWdlKQoJCXVzZV9tZXNzYWdlID0gZWRpdF9tZXNzYWdlOwoJaWYgKGFtZW5kICYmICF1c2VfbWVzc2FnZSAmJiAhZml4dXBfbWVzc2FnZSkKCQl1c2VfbWVzc2FnZSA9ICJIRUFEIjsKCWlmICghdXNlX21lc3NhZ2UgJiYgIWlzX2Zyb21fY2hlcnJ5X3BpY2sod2hlbmNlKSAmJgoJICAgICFpc19mcm9tX3JlYmFzZSh3aGVuY2UpICYmIHJlbmV3X2F1dGhvcnNoaXApCgkJZGllKF8oIi0tcmVzZXQtYXV0aG9yIGNhbiBiZSB1c2VkIG9ubHkgd2l0aCAtQywgLWMgb3IgLS1hbWVuZC4iKSk7CglpZiAodXNlX21lc3NhZ2UpIHsKCQl1c2VfbWVzc2FnZV9idWZmZXIgPSByZWFkX2NvbW1pdF9tZXNzYWdlKHVzZV9tZXNzYWdlKTsKCQlpZiAoIXJlbmV3X2F1dGhvcnNoaXApIHsKCQkJYXV0aG9yX21lc3NhZ2UgPSB1c2VfbWVzc2FnZTsKCQkJYXV0aG9yX21lc3NhZ2VfYnVmZmVyID0gdXNlX21lc3NhZ2VfYnVmZmVyOwoJCX0KCX0KCWlmICgoaXNfZnJvbV9jaGVycnlfcGljayh3aGVuY2UpIHx8IHdoZW5jZSA9PSBGUk9NX1JFQkFTRV9QSUNLKSAmJgoJICAgICFyZW5ld19hdXRob3JzaGlwKSB7CgkJYXV0aG9yX21lc3NhZ2UgPSAiQ0hFUlJZX1BJQ0tfSEVBRCI7CgkJYXV0aG9yX21lc3NhZ2VfYnVmZmVyID0gcmVhZF9jb21taXRfbWVzc2FnZShhdXRob3JfbWVzc2FnZSk7Cgl9CgoJaWYgKHBhdGNoX2ludGVyYWN0aXZlKQoJCWludGVyYWN0aXZlID0gMTsKCglkaWVfZm9yX2luY29tcGF0aWJsZV9vcHQ0KGFsc28sICItaS8tLWluY2x1ZGUiLAoJCQkJICBvbmx5LCAiLW8vLS1vbmx5IiwKCQkJCSAgYWxsLCAiLWEvLS1hbGwiLAoJCQkJICBpbnRlcmFjdGl2ZSwgIi0taW50ZXJhY3RpdmUvLXAvLS1wYXRjaCIpOwoJaWYgKGZpeHVwX21lc3NhZ2UpIHsKCQkvKgoJCSAqIFdlIGxpbWl0IC0tZml4dXAncyBzdWJvcHRpb25zIHRvIG9ubHkgYWxwaGEgY2hhcmFjdGVycy4KCQkgKiBJZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGFmdGVyIGEgcnVuIG9mIGFscGhhIGlzIGNvbG9uLAoJCSAqIHRoZW4gdGhlIHBhcnQgYmVmb3JlIHRoZSBjb2xvbiBtYXkgYmUgYSBrbm93biBzdWJvcHRpb24KCQkgKiBuYW1lIGxpa2UgYGFtZW5kYCBvciBgcmV3b3JkYCwgb3IgYSBtaXNzcGVsdCBzdWJvcHRpb24KCQkgKiBuYW1lLiBJbiBlaXRoZXIgY2FzZSwgd2UgdHJlYXQgaXQgYXMKCQkgKiAtLWZpeHVwPTxzdWJvcHRpb24+Ojxhcmc+LgoJCSAqCgkJICogT3RoZXJ3aXNlLCB3ZSBhcmUgZGVhbGluZyB3aXRoIC0tZml4dXA9PGNvbW1pdD4uCgkJICovCgkJY2hhciAqcCA9IGZpeHVwX21lc3NhZ2U7CgkJd2hpbGUgKGlzYWxwaGEoKnApKQoJCQlwKys7CgkJaWYgKHAgPiBmaXh1cF9tZXNzYWdlICYmICpwID09ICc6JykgewoJCQkqcCA9ICdcMCc7CgkJCWZpeHVwX2NvbW1pdCA9IHAgKyAxOwoJCQlpZiAoIXN0cmNtcCgiYW1lbmQiLCBmaXh1cF9tZXNzYWdlKSB8fAoJCQkgICAgIXN0cmNtcCgicmV3b3JkIiwgZml4dXBfbWVzc2FnZSkpIHsKCQkJCWZpeHVwX3ByZWZpeCA9ICJhbWVuZCI7CgkJCQlhbGxvd19lbXB0eSA9IDE7CgkJCQlpZiAoKmZpeHVwX21lc3NhZ2UgPT0gJ3InKSB7CgkJCQkJY2hlY2tfZml4dXBfcmV3b3JkX29wdGlvbnMoYXJnYywgYXJndik7CgkJCQkJb25seSA9IDE7CgkJCQl9CgkJCX0gZWxzZSB7CgkJCQlkaWUoXygidW5rbm93biBvcHRpb246IC0tZml4dXA9JXM6JXMiKSwgZml4dXBfbWVzc2FnZSwgZml4dXBfY29tbWl0KTsKCQkJfQoJCX0gZWxzZSB7CgkJCWZpeHVwX2NvbW1pdCA9IGZpeHVwX21lc3NhZ2U7CgkJCWZpeHVwX3ByZWZpeCA9ICJmaXh1cCI7CgkJCXVzZV9lZGl0b3IgPSAwOwoJCX0KCX0KCglpZiAoMCA8PSBlZGl0X2ZsYWcpCgkJdXNlX2VkaXRvciA9IGVkaXRfZmxhZzsKCgljbGVhbnVwX21vZGUgPSBnZXRfY2xlYW51cF9tb2RlKGNsZWFudXBfYXJnLCB1c2VfZWRpdG9yKTsKCgloYW5kbGVfdW50cmFja2VkX2ZpbGVzX2FyZyhzKTsKCglpZiAoYWxsICYmIGFyZ2MgPiAwKQoJCWRpZShfKCJwYXRocyAnJXMgLi4uJyB3aXRoIC1hIGRvZXMgbm90IG1ha2Ugc2Vuc2UiKSwKCQkgICAgYXJndlswXSk7CgoJaWYgKHN0YXR1c19mb3JtYXQgIT0gU1RBVFVTX0ZPUk1BVF9OT05FKQoJCWRyeV9ydW4gPSAxOwoKCXJldHVybiBhcmdjOwp9CgpzdGF0aWMgaW50IGRyeV9ydW5fY29tbWl0KGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgsCgkJCSAgY29uc3Qgc3RydWN0IGNvbW1pdCAqY3VycmVudF9oZWFkLCBzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglpbnQgY29tbWl0dGFibGU7Cgljb25zdCBjaGFyICppbmRleF9maWxlOwoKCWluZGV4X2ZpbGUgPSBwcmVwYXJlX2luZGV4KGFyZ3YsIHByZWZpeCwgY3VycmVudF9oZWFkLCAxKTsKCWNvbW1pdHRhYmxlID0gcnVuX3N0YXR1cyhzdGRvdXQsIGluZGV4X2ZpbGUsIHByZWZpeCwgMCwgcyk7Cglyb2xsYmFja19pbmRleF9maWxlcygpOwoKCXJldHVybiBjb21taXR0YWJsZSA/IDAgOiAxOwp9CgpkZWZpbmVfbGlzdF9jb25maWdfYXJyYXlfZXh0cmEoY29sb3Jfc3RhdHVzX3Nsb3RzLCB7ImFkZGVkIn0pOwoKc3RhdGljIGludCBwYXJzZV9zdGF0dXNfc2xvdChjb25zdCBjaGFyICpzbG90KQp7CglpZiAoIXN0cmNhc2VjbXAoc2xvdCwgImFkZGVkIikpCgkJcmV0dXJuIFdUX1NUQVRVU19VUERBVEVEOwoKCXJldHVybiBMT09LVVBfQ09ORklHKGNvbG9yX3N0YXR1c19zbG90cywgc2xvdCk7Cn0KCnN0YXRpYyBpbnQgZ2l0X3N0YXR1c19jb25maWcoY29uc3QgY2hhciAqaywgY29uc3QgY2hhciAqdiwgdm9pZCAqY2IpCnsKCXN0cnVjdCB3dF9zdGF0dXMgKnMgPSBjYjsKCWNvbnN0IGNoYXIgKnNsb3RfbmFtZTsKCglpZiAoc3RhcnRzX3dpdGgoaywgImNvbHVtbi4iKSkKCQlyZXR1cm4gZ2l0X2NvbHVtbl9jb25maWcoaywgdiwgInN0YXR1cyIsICZzLT5jb2xvcHRzKTsKCWlmICghc3RyY21wKGssICJzdGF0dXMuc3VibW9kdWxlc3VtbWFyeSIpKSB7CgkJaW50IGlzX2Jvb2w7CgkJcy0+c3VibW9kdWxlX3N1bW1hcnkgPSBnaXRfY29uZmlnX2Jvb2xfb3JfaW50KGssIHYsICZpc19ib29sKTsKCQlpZiAoaXNfYm9vbCAmJiBzLT5zdWJtb2R1bGVfc3VtbWFyeSkKCQkJcy0+c3VibW9kdWxlX3N1bW1hcnkgPSAtMTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMuc2hvcnQiKSkgewoJCWlmIChnaXRfY29uZmlnX2Jvb2woaywgdikpCgkJCXN0YXR1c19kZWZlcnJlZF9jb25maWcuc3RhdHVzX2Zvcm1hdCA9IFNUQVRVU19GT1JNQVRfU0hPUlQ7CgkJZWxzZQoJCQlzdGF0dXNfZGVmZXJyZWRfY29uZmlnLnN0YXR1c19mb3JtYXQgPSBTVEFUVVNfRk9STUFUX05PTkU7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAic3RhdHVzLmJyYW5jaCIpKSB7CgkJc3RhdHVzX2RlZmVycmVkX2NvbmZpZy5zaG93X2JyYW5jaCA9IGdpdF9jb25maWdfYm9vbChrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMuYWhlYWRiZWhpbmQiKSkgewoJCXN0YXR1c19kZWZlcnJlZF9jb25maWcuYWhlYWRfYmVoaW5kID0gZ2l0X2NvbmZpZ19ib29sKGssIHYpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaywgInN0YXR1cy5zaG93c3Rhc2giKSkgewoJCXMtPnNob3dfc3Rhc2ggPSBnaXRfY29uZmlnX2Jvb2woaywgdik7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAic3RhdHVzLmNvbG9yIikgfHwgIXN0cmNtcChrLCAiY29sb3Iuc3RhdHVzIikpIHsKCQlzLT51c2VfY29sb3IgPSBnaXRfY29uZmlnX2NvbG9yYm9vbChrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMuZGlzcGxheWNvbW1lbnRwcmVmaXgiKSkgewoJCXMtPmRpc3BsYXlfY29tbWVudF9wcmVmaXggPSBnaXRfY29uZmlnX2Jvb2woaywgdik7CgkJcmV0dXJuIDA7Cgl9CglpZiAoc2tpcF9wcmVmaXgoaywgInN0YXR1cy5jb2xvci4iLCAmc2xvdF9uYW1lKSB8fAoJICAgIHNraXBfcHJlZml4KGssICJjb2xvci5zdGF0dXMuIiwgJnNsb3RfbmFtZSkpIHsKCQlpbnQgc2xvdCA9IHBhcnNlX3N0YXR1c19zbG90KHNsb3RfbmFtZSk7CgkJaWYgKHNsb3QgPCAwKQoJCQlyZXR1cm4gMDsKCQlpZiAoIXYpCgkJCXJldHVybiBjb25maWdfZXJyb3Jfbm9uYm9vbChrKTsKCQlyZXR1cm4gY29sb3JfcGFyc2Uodiwgcy0+Y29sb3JfcGFsZXR0ZVtzbG90XSk7Cgl9CglpZiAoIXN0cmNtcChrLCAic3RhdHVzLnJlbGF0aXZlcGF0aHMiKSkgewoJCXMtPnJlbGF0aXZlX3BhdGhzID0gZ2l0X2NvbmZpZ19ib29sKGssIHYpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaywgInN0YXR1cy5zaG93dW50cmFja2VkZmlsZXMiKSkgewoJCWlmICghdikKCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKGspOwoJCWVsc2UgaWYgKCFzdHJjbXAodiwgIm5vIikpCgkJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19OT19VTlRSQUNLRURfRklMRVM7CgkJZWxzZSBpZiAoIXN0cmNtcCh2LCAibm9ybWFsIikpCgkJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19OT1JNQUxfVU5UUkFDS0VEX0ZJTEVTOwoJCWVsc2UgaWYgKCFzdHJjbXAodiwgImFsbCIpKQoJCQlzLT5zaG93X3VudHJhY2tlZF9maWxlcyA9IFNIT1dfQUxMX1VOVFJBQ0tFRF9GSUxFUzsKCQllbHNlCgkJCXJldHVybiBlcnJvcihfKCJJbnZhbGlkIHVudHJhY2tlZCBmaWxlcyBtb2RlICclcyciKSwgdik7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAiZGlmZi5yZW5hbWVsaW1pdCIpKSB7CgkJaWYgKHMtPnJlbmFtZV9saW1pdCA9PSAtMSkKCQkJcy0+cmVuYW1lX2xpbWl0ID0gZ2l0X2NvbmZpZ19pbnQoaywgdik7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAic3RhdHVzLnJlbmFtZWxpbWl0IikpIHsKCQlzLT5yZW5hbWVfbGltaXQgPSBnaXRfY29uZmlnX2ludChrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJkaWZmLnJlbmFtZXMiKSkgewoJCWlmIChzLT5kZXRlY3RfcmVuYW1lID09IC0xKQoJCQlzLT5kZXRlY3RfcmVuYW1lID0gZ2l0X2NvbmZpZ19yZW5hbWUoaywgdik7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAic3RhdHVzLnJlbmFtZXMiKSkgewoJCXMtPmRldGVjdF9yZW5hbWUgPSBnaXRfY29uZmlnX3JlbmFtZShrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCXJldHVybiBnaXRfZGlmZl91aV9jb25maWcoaywgdiwgTlVMTCk7Cn0KCmludCBjbWRfc3RhdHVzKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdGF0aWMgaW50IG5vX3JlbmFtZXMgPSAtMTsKCXN0YXRpYyBjb25zdCBjaGFyICpyZW5hbWVfc2NvcmVfYXJnID0gKGNvbnN0IGNoYXIgKiktMTsKCXN0YXRpYyBzdHJ1Y3Qgd3Rfc3RhdHVzIHM7Cgl1bnNpZ25lZCBpbnQgcHJvZ3Jlc3NfZmxhZyA9IDA7CglpbnQgZmQ7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCXN0YXRpYyBzdHJ1Y3Qgb3B0aW9uIGJ1aWx0aW5fc3RhdHVzX29wdGlvbnNbXSA9IHsKCQlPUFRfX1ZFUkJPU0UoJnZlcmJvc2UsIE5fKCJiZSB2ZXJib3NlIikpLAoJCU9QVF9TRVRfSU5UKCdzJywgInNob3J0IiwgJnN0YXR1c19mb3JtYXQsCgkJCSAgICBOXygic2hvdyBzdGF0dXMgY29uY2lzZWx5IiksIFNUQVRVU19GT1JNQVRfU0hPUlQpLAoJCU9QVF9CT09MKCdiJywgImJyYW5jaCIsICZzLnNob3dfYnJhbmNoLAoJCQkgTl8oInNob3cgYnJhbmNoIGluZm9ybWF0aW9uIikpLAoJCU9QVF9CT09MKDAsICJzaG93LXN0YXNoIiwgJnMuc2hvd19zdGFzaCwKCQkJIE5fKCJzaG93IHN0YXNoIGluZm9ybWF0aW9uIikpLAoJCU9QVF9CT09MKDAsICJhaGVhZC1iZWhpbmQiLCAmcy5haGVhZF9iZWhpbmRfZmxhZ3MsCgkJCSBOXygiY29tcHV0ZSBmdWxsIGFoZWFkL2JlaGluZCB2YWx1ZXMiKSksCgkJT1BUX0NBTExCQUNLX0YoMCwgInBvcmNlbGFpbiIsICZzdGF0dXNfZm9ybWF0LAoJCSAgTl8oInZlcnNpb24iKSwgTl8oIm1hY2hpbmUtcmVhZGFibGUgb3V0cHV0IiksCgkJICBQQVJTRV9PUFRfT1BUQVJHLCBvcHRfcGFyc2VfcG9yY2VsYWluKSwKCQlPUFRfU0VUX0lOVCgwLCAibG9uZyIsICZzdGF0dXNfZm9ybWF0LAoJCQkgICAgTl8oInNob3cgc3RhdHVzIGluIGxvbmcgZm9ybWF0IChkZWZhdWx0KSIpLAoJCQkgICAgU1RBVFVTX0ZPUk1BVF9MT05HKSwKCQlPUFRfQk9PTCgneicsICJudWxsIiwgJnMubnVsbF90ZXJtaW5hdGlvbiwKCQkJIE5fKCJ0ZXJtaW5hdGUgZW50cmllcyB3aXRoIE5VTCIpKSwKCQl7IE9QVElPTl9TVFJJTkcsICd1JywgInVudHJhY2tlZC1maWxlcyIsICZ1bnRyYWNrZWRfZmlsZXNfYXJnLAoJCSAgTl8oIm1vZGUiKSwKCQkgIE5fKCJzaG93IHVudHJhY2tlZCBmaWxlcywgb3B0aW9uYWwgbW9kZXM6IGFsbCwgbm9ybWFsLCBuby4gKERlZmF1bHQ6IGFsbCkiKSwKCQkgIFBBUlNFX09QVF9PUFRBUkcsIE5VTEwsIChpbnRwdHJfdCkiYWxsIiB9LAoJCXsgT1BUSU9OX1NUUklORywgMCwgImlnbm9yZWQiLCAmaWdub3JlZF9hcmcsCgkJICBOXygibW9kZSIpLAoJCSAgTl8oInNob3cgaWdub3JlZCBmaWxlcywgb3B0aW9uYWwgbW9kZXM6IHRyYWRpdGlvbmFsLCBtYXRjaGluZywgbm8uIChEZWZhdWx0OiB0cmFkaXRpb25hbCkiKSwKCQkgIFBBUlNFX09QVF9PUFRBUkcsIE5VTEwsIChpbnRwdHJfdCkidHJhZGl0aW9uYWwiIH0sCgkJeyBPUFRJT05fU1RSSU5HLCAwLCAiaWdub3JlLXN1Ym1vZHVsZXMiLCAmaWdub3JlX3N1Ym1vZHVsZV9hcmcsIE5fKCJ3aGVuIiksCgkJICBOXygiaWdub3JlIGNoYW5nZXMgdG8gc3VibW9kdWxlcywgb3B0aW9uYWwgd2hlbjogYWxsLCBkaXJ0eSwgdW50cmFja2VkLiAoRGVmYXVsdDogYWxsKSIpLAoJCSAgUEFSU0VfT1BUX09QVEFSRywgTlVMTCwgKGludHB0cl90KSJhbGwiIH0sCgkJT1BUX0NPTFVNTigwLCAiY29sdW1uIiwgJnMuY29sb3B0cywgTl8oImxpc3QgdW50cmFja2VkIGZpbGVzIGluIGNvbHVtbnMiKSksCgkJT1BUX0JPT0woMCwgIm5vLXJlbmFtZXMiLCAmbm9fcmVuYW1lcywgTl8oImRvIG5vdCBkZXRlY3QgcmVuYW1lcyIpKSwKCQlPUFRfQ0FMTEJBQ0tfRignTScsICJmaW5kLXJlbmFtZXMiLCAmcmVuYW1lX3Njb3JlX2FyZywKCQkgIE5fKCJuIiksIE5fKCJkZXRlY3QgcmVuYW1lcywgb3B0aW9uYWxseSBzZXQgc2ltaWxhcml0eSBpbmRleCIpLAoJCSAgUEFSU0VfT1BUX09QVEFSRyB8IFBBUlNFX09QVF9OT05FRywgb3B0X3BhcnNlX3JlbmFtZV9zY29yZSksCgkJT1BUX0VORCgpLAoJfTsKCglpZiAoYXJnYyA9PSAyICYmICFzdHJjbXAoYXJndlsxXSwgIi1oIikpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGJ1aWx0aW5fc3RhdHVzX3VzYWdlLCBidWlsdGluX3N0YXR1c19vcHRpb25zKTsKCglwcmVwYXJlX3JlcG9fc2V0dGluZ3ModGhlX3JlcG9zaXRvcnkpOwoJdGhlX3JlcG9zaXRvcnktPnNldHRpbmdzLmNvbW1hbmRfcmVxdWlyZXNfZnVsbF9pbmRleCA9IDA7CgoJc3RhdHVzX2luaXRfY29uZmlnKCZzLCBnaXRfc3RhdHVzX2NvbmZpZyk7CglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsCgkJCSAgICAgYnVpbHRpbl9zdGF0dXNfb3B0aW9ucywKCQkJICAgICBidWlsdGluX3N0YXR1c191c2FnZSwgMCk7CglmaW5hbGl6ZV9jb2xvcHRzKCZzLmNvbG9wdHMsIC0xKTsKCWZpbmFsaXplX2RlZmVycmVkX2NvbmZpZygmcyk7CgoJaGFuZGxlX3VudHJhY2tlZF9maWxlc19hcmcoJnMpOwoJaGFuZGxlX2lnbm9yZWRfYXJnKCZzKTsKCglpZiAocy5zaG93X2lnbm9yZWRfbW9kZSA9PSBTSE9XX01BVENISU5HX0lHTk9SRUQgJiYKCSAgICBzLnNob3dfdW50cmFja2VkX2ZpbGVzID09IFNIT1dfTk9fVU5UUkFDS0VEX0ZJTEVTKQoJCWRpZShfKCJVbnN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBpZ25vcmVkIGFuZCB1bnRyYWNrZWQtZmlsZXMgYXJndW1lbnRzIikpOwoKCXBhcnNlX3BhdGhzcGVjKCZzLnBhdGhzcGVjLCAwLAoJCSAgICAgICBQQVRIU1BFQ19QUkVGRVJfRlVMTCwKCQkgICAgICAgcHJlZml4LCBhcmd2KTsKCglpZiAoc3RhdHVzX2Zvcm1hdCAhPSBTVEFUVVNfRk9STUFUX1BPUkNFTEFJTiAmJgoJICAgIHN0YXR1c19mb3JtYXQgIT0gU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU5fVjIpCgkJcHJvZ3Jlc3NfZmxhZyA9IFJFRlJFU0hfUFJPR1JFU1M7CglyZXBvX3JlYWRfaW5kZXgodGhlX3JlcG9zaXRvcnkpOwoJcmVmcmVzaF9pbmRleCgmdGhlX2luZGV4LAoJCSAgICAgIFJFRlJFU0hfUVVJRVR8UkVGUkVTSF9VTk1FUkdFRHxwcm9ncmVzc19mbGFnLAoJCSAgICAgICZzLnBhdGhzcGVjLCBOVUxMLCBOVUxMKTsKCglpZiAodXNlX29wdGlvbmFsX2xvY2tzKCkpCgkJZmQgPSBob2xkX2xvY2tlZF9pbmRleCgmaW5kZXhfbG9jaywgMCk7CgllbHNlCgkJZmQgPSAtMTsKCglzLmlzX2luaXRpYWwgPSBnZXRfb2lkKHMucmVmZXJlbmNlLCAmb2lkKSA/IDEgOiAwOwoJaWYgKCFzLmlzX2luaXRpYWwpCgkJb2lkY3B5KCZzLm9pZF9jb21taXQsICZvaWQpOwoKCXMuaWdub3JlX3N1Ym1vZHVsZV9hcmcgPSBpZ25vcmVfc3VibW9kdWxlX2FyZzsKCXMuc3RhdHVzX2Zvcm1hdCA9IHN0YXR1c19mb3JtYXQ7CglzLnZlcmJvc2UgPSB2ZXJib3NlOwoJaWYgKG5vX3JlbmFtZXMgIT0gLTEpCgkJcy5kZXRlY3RfcmVuYW1lID0gIW5vX3JlbmFtZXM7CglpZiAoKGludHB0cl90KXJlbmFtZV9zY29yZV9hcmcgIT0gLTEpIHsKCQlpZiAocy5kZXRlY3RfcmVuYW1lIDwgRElGRl9ERVRFQ1RfUkVOQU1FKQoJCQlzLmRldGVjdF9yZW5hbWUgPSBESUZGX0RFVEVDVF9SRU5BTUU7CgkJaWYgKHJlbmFtZV9zY29yZV9hcmcpCgkJCXMucmVuYW1lX3Njb3JlID0gcGFyc2VfcmVuYW1lX3Njb3JlKCZyZW5hbWVfc2NvcmVfYXJnKTsKCX0KCgl3dF9zdGF0dXNfY29sbGVjdCgmcyk7CgoJaWYgKDAgPD0gZmQpCgkJcmVwb191cGRhdGVfaW5kZXhfaWZfYWJsZSh0aGVfcmVwb3NpdG9yeSwgJmluZGV4X2xvY2spOwoKCWlmIChzLnJlbGF0aXZlX3BhdGhzKQoJCXMucHJlZml4ID0gcHJlZml4OwoKCXd0X3N0YXR1c19wcmludCgmcyk7Cgl3dF9zdGF0dXNfY29sbGVjdF9mcmVlX2J1ZmZlcnMoJnMpOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdpdF9jb21taXRfY29uZmlnKGNvbnN0IGNoYXIgKmssIGNvbnN0IGNoYXIgKnYsIHZvaWQgKmNiKQp7CglzdHJ1Y3Qgd3Rfc3RhdHVzICpzID0gY2I7CglpbnQgc3RhdHVzOwoKCWlmICghc3RyY21wKGssICJjb21taXQudGVtcGxhdGUiKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19wYXRobmFtZSgmdGVtcGxhdGVfZmlsZSwgaywgdik7CglpZiAoIXN0cmNtcChrLCAiY29tbWl0LnN0YXR1cyIpKSB7CgkJaW5jbHVkZV9zdGF0dXMgPSBnaXRfY29uZmlnX2Jvb2woaywgdik7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAiY29tbWl0LmNsZWFudXAiKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJmNsZWFudXBfYXJnLCBrLCB2KTsKCWlmICghc3RyY21wKGssICJjb21taXQuZ3Bnc2lnbiIpKSB7CgkJc2lnbl9jb21taXQgPSBnaXRfY29uZmlnX2Jvb2woaywgdikgPyAiIiA6IE5VTEw7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAiY29tbWl0LnZlcmJvc2UiKSkgewoJCWludCBpc19ib29sOwoJCWNvbmZpZ19jb21taXRfdmVyYm9zZSA9IGdpdF9jb25maWdfYm9vbF9vcl9pbnQoaywgdiwgJmlzX2Jvb2wpOwoJCXJldHVybiAwOwoJfQoKCXN0YXR1cyA9IGdpdF9ncGdfY29uZmlnKGssIHYsIE5VTEwpOwoJaWYgKHN0YXR1cykKCQlyZXR1cm4gc3RhdHVzOwoJcmV0dXJuIGdpdF9zdGF0dXNfY29uZmlnKGssIHYsIHMpOwp9CgppbnQgY21kX2NvbW1pdChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RhdGljIHN0cnVjdCB3dF9zdGF0dXMgczsKCXN0YXRpYyBzdHJ1Y3Qgb3B0aW9uIGJ1aWx0aW5fY29tbWl0X29wdGlvbnNbXSA9IHsKCQlPUFRfX1FVSUVUKCZxdWlldCwgTl8oInN1cHByZXNzIHN1bW1hcnkgYWZ0ZXIgc3VjY2Vzc2Z1bCBjb21taXQiKSksCgkJT1BUX19WRVJCT1NFKCZ2ZXJib3NlLCBOXygic2hvdyBkaWZmIGluIGNvbW1pdCBtZXNzYWdlIHRlbXBsYXRlIikpLAoKCQlPUFRfR1JPVVAoTl8oIkNvbW1pdCBtZXNzYWdlIG9wdGlvbnMiKSksCgkJT1BUX0ZJTEVOQU1FKCdGJywgImZpbGUiLCAmbG9nZmlsZSwgTl8oInJlYWQgbWVzc2FnZSBmcm9tIGZpbGUiKSksCgkJT1BUX1NUUklORygwLCAiYXV0aG9yIiwgJmZvcmNlX2F1dGhvciwgTl8oImF1dGhvciIpLCBOXygib3ZlcnJpZGUgYXV0aG9yIGZvciBjb21taXQiKSksCgkJT1BUX1NUUklORygwLCAiZGF0ZSIsICZmb3JjZV9kYXRlLCBOXygiZGF0ZSIpLCBOXygib3ZlcnJpZGUgZGF0ZSBmb3IgY29tbWl0IikpLAoJCU9QVF9DQUxMQkFDSygnbScsICJtZXNzYWdlIiwgJm1lc3NhZ2UsIE5fKCJtZXNzYWdlIiksIE5fKCJjb21taXQgbWVzc2FnZSIpLCBvcHRfcGFyc2VfbSksCgkJT1BUX1NUUklORygnYycsICJyZWVkaXQtbWVzc2FnZSIsICZlZGl0X21lc3NhZ2UsIE5fKCJjb21taXQiKSwgTl8oInJldXNlIGFuZCBlZGl0IG1lc3NhZ2UgZnJvbSBzcGVjaWZpZWQgY29tbWl0IikpLAoJCU9QVF9TVFJJTkcoJ0MnLCAicmV1c2UtbWVzc2FnZSIsICZ1c2VfbWVzc2FnZSwgTl8oImNvbW1pdCIpLCBOXygicmV1c2UgbWVzc2FnZSBmcm9tIHNwZWNpZmllZCBjb21taXQiKSksCgkJLyoKCQkgKiBUUkFOU0xBVE9SUzogTGVhdmUgIlsoYW1lbmR8cmV3b3JkKTpdIiBhcy1pcywKCQkgKiBhbmQgb25seSB0cmFuc2xhdGUgPGNvbW1pdD4uCgkJICovCgkJT1BUX1NUUklORygwLCAiZml4dXAiLCAmZml4dXBfbWVzc2FnZSwgTl8oIlsoYW1lbmR8cmV3b3JkKTpdY29tbWl0IiksIE5fKCJ1c2UgYXV0b3NxdWFzaCBmb3JtYXR0ZWQgbWVzc2FnZSB0byBmaXh1cCBvciBhbWVuZC9yZXdvcmQgc3BlY2lmaWVkIGNvbW1pdCIpKSwKCQlPUFRfU1RSSU5HKDAsICJzcXVhc2giLCAmc3F1YXNoX21lc3NhZ2UsIE5fKCJjb21taXQiKSwgTl8oInVzZSBhdXRvc3F1YXNoIGZvcm1hdHRlZCBtZXNzYWdlIHRvIHNxdWFzaCBzcGVjaWZpZWQgY29tbWl0IikpLAoJCU9QVF9CT09MKDAsICJyZXNldC1hdXRob3IiLCAmcmVuZXdfYXV0aG9yc2hpcCwgTl8oInRoZSBjb21taXQgaXMgYXV0aG9yZWQgYnkgbWUgbm93ICh1c2VkIHdpdGggLUMvLWMvLS1hbWVuZCkiKSksCgkJT1BUX0NBTExCQUNLX0YoMCwgInRyYWlsZXIiLCBOVUxMLCBOXygidHJhaWxlciIpLCBOXygiYWRkIGN1c3RvbSB0cmFpbGVyKHMpIiksIFBBUlNFX09QVF9OT05FRywgb3B0X3Bhc3NfdHJhaWxlciksCgkJT1BUX0JPT0woJ3MnLCAic2lnbm9mZiIsICZzaWdub2ZmLCBOXygiYWRkIGEgU2lnbmVkLW9mZi1ieSB0cmFpbGVyIikpLAoJCU9QVF9GSUxFTkFNRSgndCcsICJ0ZW1wbGF0ZSIsICZ0ZW1wbGF0ZV9maWxlLCBOXygidXNlIHNwZWNpZmllZCB0ZW1wbGF0ZSBmaWxlIikpLAoJCU9QVF9CT09MKCdlJywgImVkaXQiLCAmZWRpdF9mbGFnLCBOXygiZm9yY2UgZWRpdCBvZiBjb21taXQiKSksCgkJT1BUX0NMRUFOVVAoJmNsZWFudXBfYXJnKSwKCQlPUFRfQk9PTCgwLCAic3RhdHVzIiwgJmluY2x1ZGVfc3RhdHVzLCBOXygiaW5jbHVkZSBzdGF0dXMgaW4gY29tbWl0IG1lc3NhZ2UgdGVtcGxhdGUiKSksCgkJeyBPUFRJT05fU1RSSU5HLCAnUycsICJncGctc2lnbiIsICZzaWduX2NvbW1pdCwgTl8oImtleS1pZCIpLAoJCSAgTl8oIkdQRyBzaWduIGNvbW1pdCIpLCBQQVJTRV9PUFRfT1BUQVJHLCBOVUxMLCAoaW50cHRyX3QpICIiIH0sCgkJLyogZW5kIGNvbW1pdCBtZXNzYWdlIG9wdGlvbnMgKi8KCgkJT1BUX0dST1VQKE5fKCJDb21taXQgY29udGVudHMgb3B0aW9ucyIpKSwKCQlPUFRfQk9PTCgnYScsICJhbGwiLCAmYWxsLCBOXygiY29tbWl0IGFsbCBjaGFuZ2VkIGZpbGVzIikpLAoJCU9QVF9CT09MKCdpJywgImluY2x1ZGUiLCAmYWxzbywgTl8oImFkZCBzcGVjaWZpZWQgZmlsZXMgdG8gaW5kZXggZm9yIGNvbW1pdCIpKSwKCQlPUFRfQk9PTCgwLCAiaW50ZXJhY3RpdmUiLCAmaW50ZXJhY3RpdmUsIE5fKCJpbnRlcmFjdGl2ZWx5IGFkZCBmaWxlcyIpKSwKCQlPUFRfQk9PTCgncCcsICJwYXRjaCIsICZwYXRjaF9pbnRlcmFjdGl2ZSwgTl8oImludGVyYWN0aXZlbHkgYWRkIGNoYW5nZXMiKSksCgkJT1BUX0JPT0woJ28nLCAib25seSIsICZvbmx5LCBOXygiY29tbWl0IG9ubHkgc3BlY2lmaWVkIGZpbGVzIikpLAoJCU9QVF9CT09MKCduJywgIm5vLXZlcmlmeSIsICZub192ZXJpZnksIE5fKCJieXBhc3MgcHJlLWNvbW1pdCBhbmQgY29tbWl0LW1zZyBob29rcyIpKSwKCQlPUFRfQk9PTCgwLCAiZHJ5LXJ1biIsICZkcnlfcnVuLCBOXygic2hvdyB3aGF0IHdvdWxkIGJlIGNvbW1pdHRlZCIpKSwKCQlPUFRfU0VUX0lOVCgwLCAic2hvcnQiLCAmc3RhdHVzX2Zvcm1hdCwgTl8oInNob3cgc3RhdHVzIGNvbmNpc2VseSIpLAoJCQkgICAgU1RBVFVTX0ZPUk1BVF9TSE9SVCksCgkJT1BUX0JPT0woMCwgImJyYW5jaCIsICZzLnNob3dfYnJhbmNoLCBOXygic2hvdyBicmFuY2ggaW5mb3JtYXRpb24iKSksCgkJT1BUX0JPT0woMCwgImFoZWFkLWJlaGluZCIsICZzLmFoZWFkX2JlaGluZF9mbGFncywKCQkJIE5fKCJjb21wdXRlIGZ1bGwgYWhlYWQvYmVoaW5kIHZhbHVlcyIpKSwKCQlPUFRfU0VUX0lOVCgwLCAicG9yY2VsYWluIiwgJnN0YXR1c19mb3JtYXQsCgkJCSAgICBOXygibWFjaGluZS1yZWFkYWJsZSBvdXRwdXQiKSwgU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU4pLAoJCU9QVF9TRVRfSU5UKDAsICJsb25nIiwgJnN0YXR1c19mb3JtYXQsCgkJCSAgICBOXygic2hvdyBzdGF0dXMgaW4gbG9uZyBmb3JtYXQgKGRlZmF1bHQpIiksCgkJCSAgICBTVEFUVVNfRk9STUFUX0xPTkcpLAoJCU9QVF9CT09MKCd6JywgIm51bGwiLCAmcy5udWxsX3Rlcm1pbmF0aW9uLAoJCQkgTl8oInRlcm1pbmF0ZSBlbnRyaWVzIHdpdGggTlVMIikpLAoJCU9QVF9CT09MKDAsICJhbWVuZCIsICZhbWVuZCwgTl8oImFtZW5kIHByZXZpb3VzIGNvbW1pdCIpKSwKCQlPUFRfQk9PTCgwLCAibm8tcG9zdC1yZXdyaXRlIiwgJm5vX3Bvc3RfcmV3cml0ZSwgTl8oImJ5cGFzcyBwb3N0LXJld3JpdGUgaG9vayIpKSwKCQl7IE9QVElPTl9TVFJJTkcsICd1JywgInVudHJhY2tlZC1maWxlcyIsICZ1bnRyYWNrZWRfZmlsZXNfYXJnLCBOXygibW9kZSIpLCBOXygic2hvdyB1bnRyYWNrZWQgZmlsZXMsIG9wdGlvbmFsIG1vZGVzOiBhbGwsIG5vcm1hbCwgbm8uIChEZWZhdWx0OiBhbGwpIiksIFBBUlNFX09QVF9PUFRBUkcsIE5VTEwsIChpbnRwdHJfdCkiYWxsIiB9LAoJCU9QVF9QQVRIU1BFQ19GUk9NX0ZJTEUoJnBhdGhzcGVjX2Zyb21fZmlsZSksCgkJT1BUX1BBVEhTUEVDX0ZJTEVfTlVMKCZwYXRoc3BlY19maWxlX251bCksCgkJLyogZW5kIGNvbW1pdCBjb250ZW50cyBvcHRpb25zICovCgoJCU9QVF9ISURERU5fQk9PTCgwLCAiYWxsb3ctZW1wdHkiLCAmYWxsb3dfZW1wdHksCgkJCQlOXygib2sgdG8gcmVjb3JkIGFuIGVtcHR5IGNoYW5nZSIpKSwKCQlPUFRfSElEREVOX0JPT0woMCwgImFsbG93LWVtcHR5LW1lc3NhZ2UiLCAmYWxsb3dfZW1wdHlfbWVzc2FnZSwKCQkJCU5fKCJvayB0byByZWNvcmQgYSBjaGFuZ2Ugd2l0aCBhbiBlbXB0eSBtZXNzYWdlIikpLAoKCQlPUFRfRU5EKCkKCX07CgoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBhdXRob3JfaWRlbnQgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKmluZGV4X2ZpbGUsICpyZWZsb2dfbXNnOwoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMgPSBOVUxMOwoJc3RydWN0IHN0YXQgc3RhdGJ1ZjsKCXN0cnVjdCBjb21taXQgKmN1cnJlbnRfaGVhZCA9IE5VTEw7CglzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqZXh0cmEgPSBOVUxMOwoJc3RydWN0IHN0cmJ1ZiBlcnIgPSBTVFJCVUZfSU5JVDsKCglpZiAoYXJnYyA9PSAyICYmICFzdHJjbXAoYXJndlsxXSwgIi1oIikpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGJ1aWx0aW5fY29tbWl0X3VzYWdlLCBidWlsdGluX2NvbW1pdF9vcHRpb25zKTsKCglwcmVwYXJlX3JlcG9fc2V0dGluZ3ModGhlX3JlcG9zaXRvcnkpOwoJdGhlX3JlcG9zaXRvcnktPnNldHRpbmdzLmNvbW1hbmRfcmVxdWlyZXNfZnVsbF9pbmRleCA9IDA7CgoJc3RhdHVzX2luaXRfY29uZmlnKCZzLCBnaXRfY29tbWl0X2NvbmZpZyk7CglzLmNvbW1pdF90ZW1wbGF0ZSA9IDE7CglzdGF0dXNfZm9ybWF0ID0gU1RBVFVTX0ZPUk1BVF9OT05FOyAvKiBJZ25vcmUgc3RhdHVzLnNob3J0ICovCglzLmNvbG9wdHMgPSAwOwoKCWlmIChnZXRfb2lkKCJIRUFEIiwgJm9pZCkpCgkJY3VycmVudF9oZWFkID0gTlVMTDsKCWVsc2UgewoJCWN1cnJlbnRfaGVhZCA9IGxvb2t1cF9jb21taXRfb3JfZGllKCZvaWQsICJIRUFEIik7CgkJaWYgKHBhcnNlX2NvbW1pdChjdXJyZW50X2hlYWQpKQoJCQlkaWUoXygiY291bGQgbm90IHBhcnNlIEhFQUQgY29tbWl0IikpOwoJfQoJdmVyYm9zZSA9IC0xOyAvKiB1bnNwZWNpZmllZCAqLwoJYXJnYyA9IHBhcnNlX2FuZF92YWxpZGF0ZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIGJ1aWx0aW5fY29tbWl0X29wdGlvbnMsCgkJCQkJICBidWlsdGluX2NvbW1pdF91c2FnZSwKCQkJCQkgIHByZWZpeCwgY3VycmVudF9oZWFkLCAmcyk7CglpZiAodmVyYm9zZSA9PSAtMSkKCQl2ZXJib3NlID0gKGNvbmZpZ19jb21taXRfdmVyYm9zZSA8IDApID8gMCA6IGNvbmZpZ19jb21taXRfdmVyYm9zZTsKCglpZiAoZHJ5X3J1bikKCQlyZXR1cm4gZHJ5X3J1bl9jb21taXQoYXJndiwgcHJlZml4LCBjdXJyZW50X2hlYWQsICZzKTsKCWluZGV4X2ZpbGUgPSBwcmVwYXJlX2luZGV4KGFyZ3YsIHByZWZpeCwgY3VycmVudF9oZWFkLCAwKTsKCgkvKiBTZXQgdXAgZXZlcnl0aGluZyBmb3Igd3JpdGluZyB0aGUgY29tbWl0IG9iamVjdC4gIFRoaXMgaW5jbHVkZXMKCSAgIHJ1bm5pbmcgaG9va3MsIHdyaXRpbmcgdGhlIHRyZWVzLCBhbmQgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdXNlci4gICovCglpZiAoIXByZXBhcmVfdG9fY29tbWl0KGluZGV4X2ZpbGUsIHByZWZpeCwKCQkJICAgICAgIGN1cnJlbnRfaGVhZCwgJnMsICZhdXRob3JfaWRlbnQpKSB7CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlyZXR1cm4gMTsKCX0KCgkvKiBEZXRlcm1pbmUgcGFyZW50cyAqLwoJcmVmbG9nX21zZyA9IGdldGVudigiR0lUX1JFRkxPR19BQ1RJT04iKTsKCWlmICghY3VycmVudF9oZWFkKSB7CgkJaWYgKCFyZWZsb2dfbXNnKQoJCQlyZWZsb2dfbXNnID0gImNvbW1pdCAoaW5pdGlhbCkiOwoJfSBlbHNlIGlmIChhbWVuZCkgewoJCWlmICghcmVmbG9nX21zZykKCQkJcmVmbG9nX21zZyA9ICJjb21taXQgKGFtZW5kKSI7CgkJcGFyZW50cyA9IGNvcHlfY29tbWl0X2xpc3QoY3VycmVudF9oZWFkLT5wYXJlbnRzKTsKCX0gZWxzZSBpZiAod2hlbmNlID09IEZST01fTUVSR0UpIHsKCQlzdHJ1Y3Qgc3RyYnVmIG0gPSBTVFJCVUZfSU5JVDsKCQlGSUxFICpmcDsKCQlpbnQgYWxsb3dfZmFzdF9mb3J3YXJkID0gMTsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKipwcHRyID0gJnBhcmVudHM7CgoJCWlmICghcmVmbG9nX21zZykKCQkJcmVmbG9nX21zZyA9ICJjb21taXQgKG1lcmdlKSI7CgkJcHB0ciA9IGNvbW1pdF9saXN0X2FwcGVuZChjdXJyZW50X2hlYWQsIHBwdHIpOwoJCWZwID0geGZvcGVuKGdpdF9wYXRoX21lcmdlX2hlYWQodGhlX3JlcG9zaXRvcnkpLCAiciIpOwoJCXdoaWxlIChzdHJidWZfZ2V0bGluZV9sZigmbSwgZnApICE9IEVPRikgewoJCQlzdHJ1Y3QgY29tbWl0ICpwYXJlbnQ7CgoJCQlwYXJlbnQgPSBnZXRfbWVyZ2VfcGFyZW50KG0uYnVmKTsKCQkJaWYgKCFwYXJlbnQpCgkJCQlkaWUoXygiQ29ycnVwdCBNRVJHRV9IRUFEIGZpbGUgKCVzKSIpLCBtLmJ1Zik7CgkJCXBwdHIgPSBjb21taXRfbGlzdF9hcHBlbmQocGFyZW50LCBwcHRyKTsKCQl9CgkJZmNsb3NlKGZwKTsKCQlzdHJidWZfcmVsZWFzZSgmbSk7CgkJaWYgKCFzdGF0KGdpdF9wYXRoX21lcmdlX21vZGUodGhlX3JlcG9zaXRvcnkpLCAmc3RhdGJ1ZikpIHsKCQkJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJnNiLCBnaXRfcGF0aF9tZXJnZV9tb2RlKHRoZV9yZXBvc2l0b3J5KSwgMCkgPCAwKQoJCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkIE1FUkdFX01PREUiKSk7CgkJCWlmICghc3RyY21wKHNiLmJ1ZiwgIm5vLWZmIikpCgkJCQlhbGxvd19mYXN0X2ZvcndhcmQgPSAwOwoJCX0KCQlpZiAoYWxsb3dfZmFzdF9mb3J3YXJkKQoJCQlyZWR1Y2VfaGVhZHNfcmVwbGFjZSgmcGFyZW50cyk7Cgl9IGVsc2UgewoJCWlmICghcmVmbG9nX21zZykKCQkJcmVmbG9nX21zZyA9IGlzX2Zyb21fY2hlcnJ5X3BpY2sod2hlbmNlKQoJCQkJCT8gImNvbW1pdCAoY2hlcnJ5LXBpY2spIgoJCQkJCTogaXNfZnJvbV9yZWJhc2Uod2hlbmNlKQoJCQkJCT8gImNvbW1pdCAocmViYXNlKSIKCQkJCQk6ICJjb21taXQiOwoJCWNvbW1pdF9saXN0X2luc2VydChjdXJyZW50X2hlYWQsICZwYXJlbnRzKTsKCX0KCgkvKiBGaW5hbGx5LCBnZXQgdGhlIGNvbW1pdCBtZXNzYWdlICovCglzdHJidWZfcmVzZXQoJnNiKTsKCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgZ2l0X3BhdGhfY29tbWl0X2VkaXRtc2coKSwgMCkgPCAwKSB7CgkJaW50IHNhdmVkX2Vycm5vID0gZXJybm87CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlkaWUoXygiY291bGQgbm90IHJlYWQgY29tbWl0IG1lc3NhZ2U6ICVzIiksIHN0cmVycm9yKHNhdmVkX2Vycm5vKSk7Cgl9CgoJY2xlYW51cF9tZXNzYWdlKCZzYiwgY2xlYW51cF9tb2RlLCB2ZXJib3NlKTsKCglpZiAobWVzc2FnZV9pc19lbXB0eSgmc2IsIGNsZWFudXBfbW9kZSkgJiYgIWFsbG93X2VtcHR5X21lc3NhZ2UpIHsKCQlyb2xsYmFja19pbmRleF9maWxlcygpOwoJCWZwcmludGYoc3RkZXJyLCBfKCJBYm9ydGluZyBjb21taXQgZHVlIHRvIGVtcHR5IGNvbW1pdCBtZXNzYWdlLlxuIikpOwoJCWV4aXQoMSk7Cgl9CglpZiAodGVtcGxhdGVfdW50b3VjaGVkKCZzYiwgdGVtcGxhdGVfZmlsZSwgY2xlYW51cF9tb2RlKSAmJiAhYWxsb3dfZW1wdHlfbWVzc2FnZSkgewoJCXJvbGxiYWNrX2luZGV4X2ZpbGVzKCk7CgkJZnByaW50ZihzdGRlcnIsIF8oIkFib3J0aW5nIGNvbW1pdDsgeW91IGRpZCBub3QgZWRpdCB0aGUgbWVzc2FnZS5cbiIpKTsKCQlleGl0KDEpOwoJfQoKCWlmIChmaXh1cF9tZXNzYWdlICYmIHN0YXJ0c193aXRoKHNiLmJ1ZiwgImFtZW5kISAiKSAmJgoJICAgICFhbGxvd19lbXB0eV9tZXNzYWdlKSB7CgkJc3RydWN0IHN0cmJ1ZiBib2R5ID0gU1RSQlVGX0lOSVQ7CgkJc2l6ZV90IGxlbiA9IGNvbW1pdF9zdWJqZWN0X2xlbmd0aChzYi5idWYpOwoJCXN0cmJ1Zl9hZGRzdHIoJmJvZHksIHNiLmJ1ZiArIGxlbik7CgkJaWYgKG1lc3NhZ2VfaXNfZW1wdHkoJmJvZHksIGNsZWFudXBfbW9kZSkpIHsKCQkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQkJZnByaW50ZihzdGRlcnIsIF8oIkFib3J0aW5nIGNvbW1pdCBkdWUgdG8gZW1wdHkgY29tbWl0IG1lc3NhZ2UgYm9keS5cbiIpKTsKCQkJZXhpdCgxKTsKCQl9CgkJc3RyYnVmX3JlbGVhc2UoJmJvZHkpOwoJfQoKCWlmIChhbWVuZCkgewoJCWNvbnN0IGNoYXIgKmV4Y2x1ZGVfZ3Bnc2lnWzNdID0geyAiZ3Bnc2lnIiwgImdwZ3NpZy1zaGEyNTYiLCBOVUxMIH07CgkJZXh0cmEgPSByZWFkX2NvbW1pdF9leHRyYV9oZWFkZXJzKGN1cnJlbnRfaGVhZCwgZXhjbHVkZV9ncGdzaWcpOwoJfSBlbHNlIHsKCQlzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqKnRhaWwgPSAmZXh0cmE7CgkJYXBwZW5kX21lcmdlX3RhZ19oZWFkZXJzKHBhcmVudHMsICZ0YWlsKTsKCX0KCglpZiAoY29tbWl0X3RyZWVfZXh0ZW5kZWQoc2IuYnVmLCBzYi5sZW4sICZhY3RpdmVfY2FjaGVfdHJlZS0+b2lkLAoJCQkJIHBhcmVudHMsICZvaWQsIGF1dGhvcl9pZGVudC5idWYsIE5VTEwsCgkJCQkgc2lnbl9jb21taXQsIGV4dHJhKSkgewoJCXJvbGxiYWNrX2luZGV4X2ZpbGVzKCk7CgkJZGllKF8oImZhaWxlZCB0byB3cml0ZSBjb21taXQgb2JqZWN0IikpOwoJfQoJc3RyYnVmX3JlbGVhc2UoJmF1dGhvcl9pZGVudCk7CglmcmVlX2NvbW1pdF9leHRyYV9oZWFkZXJzKGV4dHJhKTsKCglpZiAodXBkYXRlX2hlYWRfd2l0aF9yZWZsb2coY3VycmVudF9oZWFkLCAmb2lkLCByZWZsb2dfbXNnLCAmc2IsCgkJCQkgICAgJmVycikpIHsKCQlyb2xsYmFja19pbmRleF9maWxlcygpOwoJCWRpZSgiJXMiLCBlcnIuYnVmKTsKCX0KCglzZXF1ZW5jZXJfcG9zdF9jb21taXRfY2xlYW51cCh0aGVfcmVwb3NpdG9yeSwgMCk7Cgl1bmxpbmsoZ2l0X3BhdGhfbWVyZ2VfaGVhZCh0aGVfcmVwb3NpdG9yeSkpOwoJdW5saW5rKGdpdF9wYXRoX21lcmdlX21zZyh0aGVfcmVwb3NpdG9yeSkpOwoJdW5saW5rKGdpdF9wYXRoX21lcmdlX21vZGUodGhlX3JlcG9zaXRvcnkpKTsKCXVubGluayhnaXRfcGF0aF9zcXVhc2hfbXNnKHRoZV9yZXBvc2l0b3J5KSk7CgoJaWYgKGNvbW1pdF9pbmRleF9maWxlcygpKQoJCWRpZShfKCJyZXBvc2l0b3J5IGhhcyBiZWVuIHVwZGF0ZWQsIGJ1dCB1bmFibGUgdG8gd3JpdGVcbiIKCQkgICAgICAibmV3X2luZGV4IGZpbGUuIENoZWNrIHRoYXQgZGlzayBpcyBub3QgZnVsbCBhbmQgcXVvdGEgaXNcbiIKCQkgICAgICAibm90IGV4Y2VlZGVkLCBhbmQgdGhlbiBcImdpdCByZXN0b3JlIC0tc3RhZ2VkIDovXCIgdG8gcmVjb3Zlci4iKSk7CgoJZ2l0X3Rlc3Rfd3JpdGVfY29tbWl0X2dyYXBoX29yX2RpZSgpOwoKCXJlcG9fcmVyZXJlKHRoZV9yZXBvc2l0b3J5LCAwKTsKCXJ1bl9hdXRvX21haW50ZW5hbmNlKHF1aWV0KTsKCXJ1bl9jb21taXRfaG9vayh1c2VfZWRpdG9yLCBnZXRfaW5kZXhfZmlsZSgpLCBOVUxMLCAicG9zdC1jb21taXQiLAoJCQlOVUxMKTsKCWlmIChhbWVuZCAmJiAhbm9fcG9zdF9yZXdyaXRlKSB7CgkJY29tbWl0X3Bvc3RfcmV3cml0ZSh0aGVfcmVwb3NpdG9yeSwgY3VycmVudF9oZWFkLCAmb2lkKTsKCX0KCWlmICghcXVpZXQpIHsKCQl1bnNpZ25lZCBpbnQgZmxhZ3MgPSAwOwoKCQlpZiAoIWN1cnJlbnRfaGVhZCkKCQkJZmxhZ3MgfD0gU1VNTUFSWV9JTklUSUFMX0NPTU1JVDsKCQlpZiAoYXV0aG9yX2RhdGVfaXNfaW50ZXJlc3RpbmcoKSkKCQkJZmxhZ3MgfD0gU1VNTUFSWV9TSE9XX0FVVEhPUl9EQVRFOwoJCXByaW50X2NvbW1pdF9zdW1tYXJ5KHRoZV9yZXBvc2l0b3J5LCBwcmVmaXgsCgkJCQkgICAgICZvaWQsIGZsYWdzKTsKCX0KCglhcHBseV9hdXRvc3Rhc2goZ2l0X3BhdGhfbWVyZ2VfYXV0b3N0YXNoKHRoZV9yZXBvc2l0b3J5KSk7CgoJVU5MRUFLKGVycik7CglVTkxFQUsoc2IpOwoJcmV0dXJuIDA7Cn0K",
    "text": "/*\n * Builtin \"git commit\"\n *\n * Copyright (c) 2007 Kristian H\u00f8gsberg <krh@redhat.com>\n * Based on git-commit.sh by Junio C Hamano and Linus Torvalds\n */\n\n#define USE_THE_INDEX_COMPATIBILITY_MACROS\n#include \"cache.h\"\n#include \"config.h\"\n#include \"lockfile.h\"\n#include \"cache-tree.h\"\n#include \"color.h\"\n#include \"dir.h\"\n#include \"builtin.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"commit.h\"\n#include \"revision.h\"\n#include \"wt-status.h\"\n#include \"run-command.h\"\n#include \"hook.h\"\n#include \"refs.h\"\n#include \"log-tree.h\"\n#include \"strbuf.h\"\n#include \"utf8.h\"\n#include \"parse-options.h\"\n#include \"string-list.h\"\n#include \"rerere.h\"\n#include \"unpack-trees.h\"\n#include \"quote.h\"\n#include \"submodule.h\"\n#include \"gpg-interface.h\"\n#include \"column.h\"\n#include \"sequencer.h\"\n#include \"mailmap.h\"\n#include \"help.h\"\n#include \"commit-reach.h\"\n#include \"commit-graph.h\"\n#include \"pretty.h\"\n\nstatic const char * const builtin_commit_usage[] = {\n\tN_(\"git commit [<options>] [--] <pathspec>...\"),\n\tNULL\n};\n\nstatic const char * const builtin_status_usage[] = {\n\tN_(\"git status [<options>] [--] <pathspec>...\"),\n\tNULL\n};\n\nstatic const char empty_amend_advice[] =\nN_(\"You asked to amend the most recent commit, but doing so would make\\n\"\n\"it empty. You can repeat your command with --allow-empty, or you can\\n\"\n\"remove the commit entirely with \\\"git reset HEAD^\\\".\\n\");\n\nstatic const char empty_cherry_pick_advice[] =\nN_(\"The previous cherry-pick is now empty, possibly due to conflict resolution.\\n\"\n\"If you wish to commit it anyway, use:\\n\"\n\"\\n\"\n\"    git commit --allow-empty\\n\"\n\"\\n\");\n\nstatic const char empty_rebase_pick_advice[] =\nN_(\"Otherwise, please use 'git rebase --skip'\\n\");\n\nstatic const char empty_cherry_pick_advice_single[] =\nN_(\"Otherwise, please use 'git cherry-pick --skip'\\n\");\n\nstatic const char empty_cherry_pick_advice_multi[] =\nN_(\"and then use:\\n\"\n\"\\n\"\n\"    git cherry-pick --continue\\n\"\n\"\\n\"\n\"to resume cherry-picking the remaining commits.\\n\"\n\"If you wish to skip this commit, use:\\n\"\n\"\\n\"\n\"    git cherry-pick --skip\\n\"\n\"\\n\");\n\nstatic const char *color_status_slots[] = {\n\t[WT_STATUS_HEADER]\t  = \"header\",\n\t[WT_STATUS_UPDATED]\t  = \"updated\",\n\t[WT_STATUS_CHANGED]\t  = \"changed\",\n\t[WT_STATUS_UNTRACKED]\t  = \"untracked\",\n\t[WT_STATUS_NOBRANCH]\t  = \"noBranch\",\n\t[WT_STATUS_UNMERGED]\t  = \"unmerged\",\n\t[WT_STATUS_LOCAL_BRANCH]  = \"localBranch\",\n\t[WT_STATUS_REMOTE_BRANCH] = \"remoteBranch\",\n\t[WT_STATUS_ONBRANCH]\t  = \"branch\",\n};\n\nstatic const char *use_message_buffer;\nstatic struct lock_file index_lock; /* real index */\nstatic struct lock_file false_lock; /* used only for partial commits */\nstatic enum {\n\tCOMMIT_AS_IS = 1,\n\tCOMMIT_NORMAL,\n\tCOMMIT_PARTIAL\n} commit_style;\n\nstatic const char *logfile, *force_author;\nstatic const char *template_file;\n/*\n * The _message variables are commit names from which to take\n * the commit message and/or authorship.\n */\nstatic const char *author_message, *author_message_buffer;\nstatic char *edit_message, *use_message;\nstatic char *fixup_message, *fixup_commit, *squash_message;\nstatic const char *fixup_prefix;\nstatic int all, also, interactive, patch_interactive, only, amend, signoff;\nstatic int edit_flag = -1; /* unspecified */\nstatic int quiet, verbose, no_verify, allow_empty, dry_run, renew_authorship;\nstatic int config_commit_verbose = -1; /* unspecified */\nstatic int no_post_rewrite, allow_empty_message, pathspec_file_nul;\nstatic char *untracked_files_arg, *force_date, *ignore_submodule_arg, *ignored_arg;\nstatic char *sign_commit, *pathspec_from_file;\nstatic struct strvec trailer_args = STRVEC_INIT;\n\n/*\n * The default commit message cleanup mode will remove the lines\n * beginning with # (shell comments) and leading and trailing\n * whitespaces (empty lines or containing only whitespaces)\n * if editor is used, and only the whitespaces if the message\n * is specified explicitly.\n */\nstatic enum commit_msg_cleanup_mode cleanup_mode;\nstatic const char *cleanup_arg;\n\nstatic enum commit_whence whence;\nstatic int use_editor = 1, include_status = 1;\nstatic int have_option_m;\nstatic struct strbuf message = STRBUF_INIT;\n\nstatic enum wt_status_format status_format = STATUS_FORMAT_UNSPECIFIED;\n\nstatic int opt_pass_trailer(const struct option *opt, const char *arg, int unset)\n{\n\tBUG_ON_OPT_NEG(unset);\n\n\tstrvec_pushl(&trailer_args, \"--trailer\", arg, NULL);\n\treturn 0;\n}\n\nstatic int opt_parse_porcelain(const struct option *opt, const char *arg, int unset)\n{\n\tenum wt_status_format *value = (enum wt_status_format *)opt->value;\n\tif (unset)\n\t\t*value = STATUS_FORMAT_NONE;\n\telse if (!arg)\n\t\t*value = STATUS_FORMAT_PORCELAIN;\n\telse if (!strcmp(arg, \"v1\") || !strcmp(arg, \"1\"))\n\t\t*value = STATUS_FORMAT_PORCELAIN;\n\telse if (!strcmp(arg, \"v2\") || !strcmp(arg, \"2\"))\n\t\t*value = STATUS_FORMAT_PORCELAIN_V2;\n\telse\n\t\tdie(\"unsupported porcelain version '%s'\", arg);\n\n\treturn 0;\n}\n\nstatic int opt_parse_m(const struct option *opt, const char *arg, int unset)\n{\n\tstruct strbuf *buf = opt->value;\n\tif (unset) {\n\t\thave_option_m = 0;\n\t\tstrbuf_setlen(buf, 0);\n\t} else {\n\t\thave_option_m = 1;\n\t\tif (buf->len)\n\t\t\tstrbuf_addch(buf, '\\n');\n\t\tstrbuf_addstr(buf, arg);\n\t\tstrbuf_complete_line(buf);\n\t}\n\treturn 0;\n}\n\nstatic int opt_parse_rename_score(const struct option *opt, const char *arg, int unset)\n{\n\tconst char **value = opt->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tif (arg != NULL && *arg == '=')\n\t\targ = arg + 1;\n\n\t*value = arg;\n\treturn 0;\n}\n\nstatic void determine_whence(struct wt_status *s)\n{\n\tif (file_exists(git_path_merge_head(the_repository)))\n\t\twhence = FROM_MERGE;\n\telse if (!sequencer_determine_whence(the_repository, &whence))\n\t\twhence = FROM_COMMIT;\n\tif (s)\n\t\ts->whence = whence;\n}\n\nstatic void status_init_config(struct wt_status *s, config_fn_t fn)\n{\n\twt_status_prepare(the_repository, s);\n\tinit_diff_ui_defaults();\n\tgit_config(fn, s);\n\tdetermine_whence(s);\n\ts->hints = advice_enabled(ADVICE_STATUS_HINTS); /* must come after git_config() */\n}\n\nstatic void rollback_index_files(void)\n{\n\tswitch (commit_style) {\n\tcase COMMIT_AS_IS:\n\t\tbreak; /* nothing to do */\n\tcase COMMIT_NORMAL:\n\t\trollback_lock_file(&index_lock);\n\t\tbreak;\n\tcase COMMIT_PARTIAL:\n\t\trollback_lock_file(&index_lock);\n\t\trollback_lock_file(&false_lock);\n\t\tbreak;\n\t}\n}\n\nstatic int commit_index_files(void)\n{\n\tint err = 0;\n\n\tswitch (commit_style) {\n\tcase COMMIT_AS_IS:\n\t\tbreak; /* nothing to do */\n\tcase COMMIT_NORMAL:\n\t\terr = commit_lock_file(&index_lock);\n\t\tbreak;\n\tcase COMMIT_PARTIAL:\n\t\terr = commit_lock_file(&index_lock);\n\t\trollback_lock_file(&false_lock);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/*\n * Take a union of paths in the index and the named tree (typically, \"HEAD\"),\n * and return the paths that match the given pattern in list.\n */\nstatic int list_paths(struct string_list *list, const char *with_tree,\n\t\t      const struct pathspec *pattern)\n{\n\tint i, ret;\n\tchar *m;\n\n\tif (!pattern->nr)\n\t\treturn 0;\n\n\tm = xcalloc(1, pattern->nr);\n\n\tif (with_tree) {\n\t\tchar *max_prefix = common_prefix(pattern);\n\t\toverlay_tree_on_index(&the_index, with_tree, max_prefix);\n\t\tfree(max_prefix);\n\t}\n\n\t/* TODO: audit for interaction with sparse-index. */\n\tensure_full_index(&the_index);\n\tfor (i = 0; i < active_nr; i++) {\n\t\tconst struct cache_entry *ce = active_cache[i];\n\t\tstruct string_list_item *item;\n\n\t\tif (ce->ce_flags & CE_UPDATE)\n\t\t\tcontinue;\n\t\tif (!ce_path_match(&the_index, ce, pattern, m))\n\t\t\tcontinue;\n\t\titem = string_list_insert(list, ce->name);\n\t\tif (ce_skip_worktree(ce))\n\t\t\titem->util = item; /* better a valid pointer than a fake one */\n\t}\n\n\tret = report_path_error(m, pattern);\n\tfree(m);\n\treturn ret;\n}\n\nstatic void add_remove_files(struct string_list *list)\n{\n\tint i;\n\tfor (i = 0; i < list->nr; i++) {\n\t\tstruct stat st;\n\t\tstruct string_list_item *p = &(list->items[i]);\n\n\t\t/* p->util is skip-worktree */\n\t\tif (p->util)\n\t\t\tcontinue;\n\n\t\tif (!lstat(p->string, &st)) {\n\t\t\tif (add_to_cache(p->string, &st, 0))\n\t\t\t\tdie(_(\"updating files failed\"));\n\t\t} else\n\t\t\tremove_file_from_cache(p->string);\n\t}\n}\n\nstatic void create_base_index(const struct commit *current_head)\n{\n\tstruct tree *tree;\n\tstruct unpack_trees_options opts;\n\tstruct tree_desc t;\n\n\tif (!current_head) {\n\t\tdiscard_cache();\n\t\treturn;\n\t}\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.head_idx = 1;\n\topts.index_only = 1;\n\topts.merge = 1;\n\topts.src_index = &the_index;\n\topts.dst_index = &the_index;\n\n\topts.fn = oneway_merge;\n\ttree = parse_tree_indirect(&current_head->object.oid);\n\tif (!tree)\n\t\tdie(_(\"failed to unpack HEAD tree object\"));\n\tparse_tree(tree);\n\tinit_tree_desc(&t, tree->buffer, tree->size);\n\tif (unpack_trees(1, &t, &opts))\n\t\texit(128); /* We've already reported the error, finish dying */\n}\n\nstatic void refresh_cache_or_die(int refresh_flags)\n{\n\t/*\n\t * refresh_flags contains REFRESH_QUIET, so the only errors\n\t * are for unmerged entries.\n\t */\n\tif (refresh_cache(refresh_flags | REFRESH_IN_PORCELAIN))\n\t\tdie_resolve_conflict(\"commit\");\n}\n\nstatic const char *prepare_index(const char **argv, const char *prefix,\n\t\t\t\t const struct commit *current_head, int is_status)\n{\n\tstruct string_list partial = STRING_LIST_INIT_DUP;\n\tstruct pathspec pathspec;\n\tint refresh_flags = REFRESH_QUIET;\n\tconst char *ret;\n\n\tif (is_status)\n\t\trefresh_flags |= REFRESH_UNMERGED;\n\tparse_pathspec(&pathspec, 0,\n\t\t       PATHSPEC_PREFER_FULL,\n\t\t       prefix, argv);\n\n\tif (pathspec_from_file) {\n\t\tif (interactive)\n\t\t\tdie(_(\"options '%s' and '%s' cannot be used together\"), \"--pathspec-from-file\", \"--interactive/--patch\");\n\n\t\tif (all)\n\t\t\tdie(_(\"options '%s' and '%s' cannot be used together\"), \"--pathspec-from-file\", \"-a\");\n\n\t\tif (pathspec.nr)\n\t\t\tdie(_(\"'%s' and pathspec arguments cannot be used together\"), \"--pathspec-from-file\");\n\n\t\tparse_pathspec_file(&pathspec, 0,\n\t\t\t\t    PATHSPEC_PREFER_FULL,\n\t\t\t\t    prefix, pathspec_from_file, pathspec_file_nul);\n\t} else if (pathspec_file_nul) {\n\t\tdie(_(\"the option '%s' requires '%s'\"), \"--pathspec-file-nul\", \"--pathspec-from-file\");\n\t}\n\n\tif (!pathspec.nr && (also || (only && !allow_empty &&\n\t    (!amend || (fixup_message && strcmp(fixup_prefix, \"amend\"))))))\n\t\tdie(_(\"No paths with --include/--only does not make sense.\"));\n\n\tif (read_cache_preload(&pathspec) < 0)\n\t\tdie(_(\"index file corrupt\"));\n\n\tif (interactive) {\n\t\tchar *old_index_env = NULL, *old_repo_index_file;\n\t\thold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);\n\n\t\trefresh_cache_or_die(refresh_flags);\n\n\t\tif (write_locked_index(&the_index, &index_lock, 0))\n\t\t\tdie(_(\"unable to create temporary index\"));\n\n\t\told_repo_index_file = the_repository->index_file;\n\t\tthe_repository->index_file =\n\t\t\t(char *)get_lock_file_path(&index_lock);\n\t\told_index_env = xstrdup_or_null(getenv(INDEX_ENVIRONMENT));\n\t\tsetenv(INDEX_ENVIRONMENT, the_repository->index_file, 1);\n\n\t\tif (interactive_add(argv, prefix, patch_interactive) != 0)\n\t\t\tdie(_(\"interactive add failed\"));\n\n\t\tthe_repository->index_file = old_repo_index_file;\n\t\tif (old_index_env && *old_index_env)\n\t\t\tsetenv(INDEX_ENVIRONMENT, old_index_env, 1);\n\t\telse\n\t\t\tunsetenv(INDEX_ENVIRONMENT);\n\t\tFREE_AND_NULL(old_index_env);\n\n\t\tdiscard_cache();\n\t\tread_cache_from(get_lock_file_path(&index_lock));\n\t\tif (update_main_cache_tree(WRITE_TREE_SILENT) == 0) {\n\t\t\tif (reopen_lock_file(&index_lock) < 0)\n\t\t\t\tdie(_(\"unable to write index file\"));\n\t\t\tif (write_locked_index(&the_index, &index_lock, 0))\n\t\t\t\tdie(_(\"unable to update temporary index\"));\n\t\t} else\n\t\t\twarning(_(\"Failed to update main cache tree\"));\n\n\t\tcommit_style = COMMIT_NORMAL;\n\t\tret = get_lock_file_path(&index_lock);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Non partial, non as-is commit.\n\t *\n\t * (1) get the real index;\n\t * (2) update the_index as necessary;\n\t * (3) write the_index out to the real index (still locked);\n\t * (4) return the name of the locked index file.\n\t *\n\t * The caller should run hooks on the locked real index, and\n\t * (A) if all goes well, commit the real index;\n\t * (B) on failure, rollback the real index.\n\t */\n\tif (all || (also && pathspec.nr)) {\n\t\thold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);\n\t\tadd_files_to_cache(also ? prefix : NULL, &pathspec, 0);\n\t\trefresh_cache_or_die(refresh_flags);\n\t\tupdate_main_cache_tree(WRITE_TREE_SILENT);\n\t\tif (write_locked_index(&the_index, &index_lock, 0))\n\t\t\tdie(_(\"unable to write new_index file\"));\n\t\tcommit_style = COMMIT_NORMAL;\n\t\tret = get_lock_file_path(&index_lock);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * As-is commit.\n\t *\n\t * (1) return the name of the real index file.\n\t *\n\t * The caller should run hooks on the real index,\n\t * and create commit from the_index.\n\t * We still need to refresh the index here.\n\t */\n\tif (!only && !pathspec.nr) {\n\t\thold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);\n\t\trefresh_cache_or_die(refresh_flags);\n\t\tif (active_cache_changed\n\t\t    || !cache_tree_fully_valid(active_cache_tree))\n\t\t\tupdate_main_cache_tree(WRITE_TREE_SILENT);\n\t\tif (write_locked_index(&the_index, &index_lock,\n\t\t\t\t       COMMIT_LOCK | SKIP_IF_UNCHANGED))\n\t\t\tdie(_(\"unable to write new_index file\"));\n\t\tcommit_style = COMMIT_AS_IS;\n\t\tret = get_index_file();\n\t\tgoto out;\n\t}\n\n\t/*\n\t * A partial commit.\n\t *\n\t * (0) find the set of affected paths;\n\t * (1) get lock on the real index file;\n\t * (2) update the_index with the given paths;\n\t * (3) write the_index out to the real index (still locked);\n\t * (4) get lock on the false index file;\n\t * (5) reset the_index from HEAD;\n\t * (6) update the_index the same way as (2);\n\t * (7) write the_index out to the false index file;\n\t * (8) return the name of the false index file (still locked);\n\t *\n\t * The caller should run hooks on the locked false index, and\n\t * create commit from it.  Then\n\t * (A) if all goes well, commit the real index;\n\t * (B) on failure, rollback the real index;\n\t * In either case, rollback the false index.\n\t */\n\tcommit_style = COMMIT_PARTIAL;\n\n\tif (whence != FROM_COMMIT) {\n\t\tif (whence == FROM_MERGE)\n\t\t\tdie(_(\"cannot do a partial commit during a merge.\"));\n\t\telse if (is_from_cherry_pick(whence))\n\t\t\tdie(_(\"cannot do a partial commit during a cherry-pick.\"));\n\t\telse if (is_from_rebase(whence))\n\t\t\tdie(_(\"cannot do a partial commit during a rebase.\"));\n\t}\n\n\tif (list_paths(&partial, !current_head ? NULL : \"HEAD\", &pathspec))\n\t\texit(1);\n\n\tdiscard_cache();\n\tif (read_cache() < 0)\n\t\tdie(_(\"cannot read the index\"));\n\n\thold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);\n\tadd_remove_files(&partial);\n\trefresh_cache(REFRESH_QUIET);\n\tupdate_main_cache_tree(WRITE_TREE_SILENT);\n\tif (write_locked_index(&the_index, &index_lock, 0))\n\t\tdie(_(\"unable to write new_index file\"));\n\n\thold_lock_file_for_update(&false_lock,\n\t\t\t\t  git_path(\"next-index-%\"PRIuMAX,\n\t\t\t\t\t   (uintmax_t) getpid()),\n\t\t\t\t  LOCK_DIE_ON_ERROR);\n\n\tcreate_base_index(current_head);\n\tadd_remove_files(&partial);\n\trefresh_cache(REFRESH_QUIET);\n\n\tif (write_locked_index(&the_index, &false_lock, 0))\n\t\tdie(_(\"unable to write temporary index file\"));\n\n\tdiscard_cache();\n\tret = get_lock_file_path(&false_lock);\n\tread_cache_from(ret);\nout:\n\tstring_list_clear(&partial, 0);\n\tclear_pathspec(&pathspec);\n\treturn ret;\n}\n\nstatic int run_status(FILE *fp, const char *index_file, const char *prefix, int nowarn,\n\t\t      struct wt_status *s)\n{\n\tstruct object_id oid;\n\n\tif (s->relative_paths)\n\t\ts->prefix = prefix;\n\n\tif (amend) {\n\t\ts->amend = 1;\n\t\ts->reference = \"HEAD^1\";\n\t}\n\ts->verbose = verbose;\n\ts->index_file = index_file;\n\ts->fp = fp;\n\ts->nowarn = nowarn;\n\ts->is_initial = get_oid(s->reference, &oid) ? 1 : 0;\n\tif (!s->is_initial)\n\t\toidcpy(&s->oid_commit, &oid);\n\ts->status_format = status_format;\n\ts->ignore_submodule_arg = ignore_submodule_arg;\n\n\twt_status_collect(s);\n\twt_status_print(s);\n\twt_status_collect_free_buffers(s);\n\n\treturn s->committable;\n}\n\nstatic int is_a_merge(const struct commit *current_head)\n{\n\treturn !!(current_head->parents && current_head->parents->next);\n}\n\nstatic void assert_split_ident(struct ident_split *id, const struct strbuf *buf)\n{\n\tif (split_ident_line(id, buf->buf, buf->len) || !id->date_begin)\n\t\tBUG(\"unable to parse our own ident: %s\", buf->buf);\n}\n\nstatic void export_one(const char *var, const char *s, const char *e, int hack)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tif (hack)\n\t\tstrbuf_addch(&buf, hack);\n\tstrbuf_add(&buf, s, e - s);\n\tsetenv(var, buf.buf, 1);\n\tstrbuf_release(&buf);\n}\n\nstatic int parse_force_date(const char *in, struct strbuf *out)\n{\n\tstrbuf_addch(out, '@');\n\n\tif (parse_date(in, out) < 0) {\n\t\tint errors = 0;\n\t\tunsigned long t = approxidate_careful(in, &errors);\n\t\tif (errors)\n\t\t\treturn -1;\n\t\tstrbuf_addf(out, \"%lu\", t);\n\t}\n\n\treturn 0;\n}\n\nstatic void set_ident_var(char **buf, char *val)\n{\n\tfree(*buf);\n\t*buf = val;\n}\n\nstatic void determine_author_info(struct strbuf *author_ident)\n{\n\tchar *name, *email, *date;\n\tstruct ident_split author;\n\n\tname = xstrdup_or_null(getenv(\"GIT_AUTHOR_NAME\"));\n\temail = xstrdup_or_null(getenv(\"GIT_AUTHOR_EMAIL\"));\n\tdate = xstrdup_or_null(getenv(\"GIT_AUTHOR_DATE\"));\n\n\tif (author_message) {\n\t\tstruct ident_split ident;\n\t\tsize_t len;\n\t\tconst char *a;\n\n\t\ta = find_commit_header(author_message_buffer, \"author\", &len);\n\t\tif (!a)\n\t\t\tdie(_(\"commit '%s' lacks author header\"), author_message);\n\t\tif (split_ident_line(&ident, a, len) < 0)\n\t\t\tdie(_(\"commit '%s' has malformed author line\"), author_message);\n\n\t\tset_ident_var(&name, xmemdupz(ident.name_begin, ident.name_end - ident.name_begin));\n\t\tset_ident_var(&email, xmemdupz(ident.mail_begin, ident.mail_end - ident.mail_begin));\n\n\t\tif (ident.date_begin) {\n\t\t\tstruct strbuf date_buf = STRBUF_INIT;\n\t\t\tstrbuf_addch(&date_buf, '@');\n\t\t\tstrbuf_add(&date_buf, ident.date_begin, ident.date_end - ident.date_begin);\n\t\t\tstrbuf_addch(&date_buf, ' ');\n\t\t\tstrbuf_add(&date_buf, ident.tz_begin, ident.tz_end - ident.tz_begin);\n\t\t\tset_ident_var(&date, strbuf_detach(&date_buf, NULL));\n\t\t}\n\t}\n\n\tif (force_author) {\n\t\tstruct ident_split ident;\n\n\t\tif (split_ident_line(&ident, force_author, strlen(force_author)) < 0)\n\t\t\tdie(_(\"malformed --author parameter\"));\n\t\tset_ident_var(&name, xmemdupz(ident.name_begin, ident.name_end - ident.name_begin));\n\t\tset_ident_var(&email, xmemdupz(ident.mail_begin, ident.mail_end - ident.mail_begin));\n\t}\n\n\tif (force_date) {\n\t\tstruct strbuf date_buf = STRBUF_INIT;\n\t\tif (parse_force_date(force_date, &date_buf))\n\t\t\tdie(_(\"invalid date format: %s\"), force_date);\n\t\tset_ident_var(&date, strbuf_detach(&date_buf, NULL));\n\t}\n\n\tstrbuf_addstr(author_ident, fmt_ident(name, email, WANT_AUTHOR_IDENT, date,\n\t\t\t\tIDENT_STRICT));\n\tassert_split_ident(&author, author_ident);\n\texport_one(\"GIT_AUTHOR_NAME\", author.name_begin, author.name_end, 0);\n\texport_one(\"GIT_AUTHOR_EMAIL\", author.mail_begin, author.mail_end, 0);\n\texport_one(\"GIT_AUTHOR_DATE\", author.date_begin, author.tz_end, '@');\n\tfree(name);\n\tfree(email);\n\tfree(date);\n}\n\nstatic int author_date_is_interesting(void)\n{\n\treturn author_message || force_date;\n}\n\nstatic void adjust_comment_line_char(const struct strbuf *sb)\n{\n\tchar candidates[] = \"#;@!$%^&|:\";\n\tchar *candidate;\n\tconst char *p;\n\n\tcomment_line_char = candidates[0];\n\tif (!memchr(sb->buf, comment_line_char, sb->len))\n\t\treturn;\n\n\tp = sb->buf;\n\tcandidate = strchr(candidates, *p);\n\tif (candidate)\n\t\t*candidate = ' ';\n\tfor (p = sb->buf; *p; p++) {\n\t\tif ((p[0] == '\\n' || p[0] == '\\r') && p[1]) {\n\t\t\tcandidate = strchr(candidates, p[1]);\n\t\t\tif (candidate)\n\t\t\t\t*candidate = ' ';\n\t\t}\n\t}\n\n\tfor (p = candidates; *p == ' '; p++)\n\t\t;\n\tif (!*p)\n\t\tdie(_(\"unable to select a comment character that is not used\\n\"\n\t\t      \"in the current commit message\"));\n\tcomment_line_char = *p;\n}\n\nstatic void prepare_amend_commit(struct commit *commit, struct strbuf *sb,\n\t\t\t\tstruct pretty_print_context *ctx)\n{\n\tconst char *buffer, *subject, *fmt;\n\n\tbuffer = get_commit_buffer(commit, NULL);\n\tfind_commit_subject(buffer, &subject);\n\t/*\n\t * If we amend the 'amend!' commit then we don't want to\n\t * duplicate the subject line.\n\t */\n\tfmt = starts_with(subject, \"amend!\") ? \"%b\" : \"%B\";\n\tformat_commit_message(commit, fmt, sb, ctx);\n\tunuse_commit_buffer(commit, buffer);\n}\n\nstatic int prepare_to_commit(const char *index_file, const char *prefix,\n\t\t\t     struct commit *current_head,\n\t\t\t     struct wt_status *s,\n\t\t\t     struct strbuf *author_ident)\n{\n\tstruct stat statbuf;\n\tstruct strbuf committer_ident = STRBUF_INIT;\n\tint committable;\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *hook_arg1 = NULL;\n\tconst char *hook_arg2 = NULL;\n\tint clean_message_contents = (cleanup_mode != COMMIT_MSG_CLEANUP_NONE);\n\tint old_display_comment_prefix;\n\tint merge_contains_scissors = 0;\n\tint invoked_hook;\n\n\t/* This checks and barfs if author is badly specified */\n\tdetermine_author_info(author_ident);\n\n\tif (!no_verify && run_commit_hook(use_editor, index_file, &invoked_hook,\n\t\t\t\t\t  \"pre-commit\", NULL))\n\t\treturn 0;\n\n\tif (squash_message) {\n\t\t/*\n\t\t * Insert the proper subject line before other commit\n\t\t * message options add their content.\n\t\t */\n\t\tif (use_message && !strcmp(use_message, squash_message))\n\t\t\tstrbuf_addstr(&sb, \"squash! \");\n\t\telse {\n\t\t\tstruct pretty_print_context ctx = {0};\n\t\t\tstruct commit *c;\n\t\t\tc = lookup_commit_reference_by_name(squash_message);\n\t\t\tif (!c)\n\t\t\t\tdie(_(\"could not lookup commit %s\"), squash_message);\n\t\t\tctx.output_encoding = get_commit_output_encoding();\n\t\t\tformat_commit_message(c, \"squash! %s\\n\\n\", &sb,\n\t\t\t\t\t      &ctx);\n\t\t}\n\t}\n\n\tif (have_option_m && !fixup_message) {\n\t\tstrbuf_addbuf(&sb, &message);\n\t\thook_arg1 = \"message\";\n\t} else if (logfile && !strcmp(logfile, \"-\")) {\n\t\tif (isatty(0))\n\t\t\tfprintf(stderr, _(\"(reading log message from standard input)\\n\"));\n\t\tif (strbuf_read(&sb, 0, 0) < 0)\n\t\t\tdie_errno(_(\"could not read log from standard input\"));\n\t\thook_arg1 = \"message\";\n\t} else if (logfile) {\n\t\tif (strbuf_read_file(&sb, logfile, 0) < 0)\n\t\t\tdie_errno(_(\"could not read log file '%s'\"),\n\t\t\t\t  logfile);\n\t\thook_arg1 = \"message\";\n\t} else if (use_message) {\n\t\tchar *buffer;\n\t\tbuffer = strstr(use_message_buffer, \"\\n\\n\");\n\t\tif (buffer)\n\t\t\tstrbuf_addstr(&sb, skip_blank_lines(buffer + 2));\n\t\thook_arg1 = \"commit\";\n\t\thook_arg2 = use_message;\n\t} else if (fixup_message) {\n\t\tstruct pretty_print_context ctx = {0};\n\t\tstruct commit *commit;\n\t\tchar *fmt;\n\t\tcommit = lookup_commit_reference_by_name(fixup_commit);\n\t\tif (!commit)\n\t\t\tdie(_(\"could not lookup commit %s\"), fixup_commit);\n\t\tctx.output_encoding = get_commit_output_encoding();\n\t\tfmt = xstrfmt(\"%s! %%s\\n\\n\", fixup_prefix);\n\t\tformat_commit_message(commit, fmt, &sb, &ctx);\n\t\tfree(fmt);\n\t\thook_arg1 = \"message\";\n\n\t\t/*\n\t\t * Only `-m` commit message option is checked here, as\n\t\t * it supports `--fixup` to append the commit message.\n\t\t *\n\t\t * The other commit message options `-c`/`-C`/`-F` are\n\t\t * incompatible with all the forms of `--fixup` and\n\t\t * have already errored out while parsing the `git commit`\n\t\t * options.\n\t\t */\n\t\tif (have_option_m && !strcmp(fixup_prefix, \"fixup\"))\n\t\t\tstrbuf_addbuf(&sb, &message);\n\n\t\tif (!strcmp(fixup_prefix, \"amend\")) {\n\t\t\tif (have_option_m)\n\t\t\t\tdie(_(\"options '%s' and '%s:%s' cannot be used together\"), \"-m\", \"--fixup\", fixup_message);\n\t\t\tprepare_amend_commit(commit, &sb, &ctx);\n\t\t}\n\t} else if (!stat(git_path_merge_msg(the_repository), &statbuf)) {\n\t\tsize_t merge_msg_start;\n\n\t\t/*\n\t\t * prepend SQUASH_MSG here if it exists and a\n\t\t * \"merge --squash\" was originally performed\n\t\t */\n\t\tif (!stat(git_path_squash_msg(the_repository), &statbuf)) {\n\t\t\tif (strbuf_read_file(&sb, git_path_squash_msg(the_repository), 0) < 0)\n\t\t\t\tdie_errno(_(\"could not read SQUASH_MSG\"));\n\t\t\thook_arg1 = \"squash\";\n\t\t} else\n\t\t\thook_arg1 = \"merge\";\n\n\t\tmerge_msg_start = sb.len;\n\t\tif (strbuf_read_file(&sb, git_path_merge_msg(the_repository), 0) < 0)\n\t\t\tdie_errno(_(\"could not read MERGE_MSG\"));\n\n\t\tif (cleanup_mode == COMMIT_MSG_CLEANUP_SCISSORS &&\n\t\t    wt_status_locate_end(sb.buf + merge_msg_start,\n\t\t\t\t\t sb.len - merge_msg_start) <\n\t\t\t\tsb.len - merge_msg_start)\n\t\t\tmerge_contains_scissors = 1;\n\t} else if (!stat(git_path_squash_msg(the_repository), &statbuf)) {\n\t\tif (strbuf_read_file(&sb, git_path_squash_msg(the_repository), 0) < 0)\n\t\t\tdie_errno(_(\"could not read SQUASH_MSG\"));\n\t\thook_arg1 = \"squash\";\n\t} else if (template_file) {\n\t\tif (strbuf_read_file(&sb, template_file, 0) < 0)\n\t\t\tdie_errno(_(\"could not read '%s'\"), template_file);\n\t\thook_arg1 = \"template\";\n\t\tclean_message_contents = 0;\n\t}\n\n\t/*\n\t * The remaining cases don't modify the template message, but\n\t * just set the argument(s) to the prepare-commit-msg hook.\n\t */\n\telse if (whence == FROM_MERGE)\n\t\thook_arg1 = \"merge\";\n\telse if (is_from_cherry_pick(whence) || whence == FROM_REBASE_PICK) {\n\t\thook_arg1 = \"commit\";\n\t\thook_arg2 = \"CHERRY_PICK_HEAD\";\n\t}\n\n\tif (squash_message) {\n\t\t/*\n\t\t * If squash_commit was used for the commit subject,\n\t\t * then we're possibly hijacking other commit log options.\n\t\t * Reset the hook args to tell the real story.\n\t\t */\n\t\thook_arg1 = \"message\";\n\t\thook_arg2 = \"\";\n\t}\n\n\ts->fp = fopen_for_writing(git_path_commit_editmsg());\n\tif (s->fp == NULL)\n\t\tdie_errno(_(\"could not open '%s'\"), git_path_commit_editmsg());\n\n\t/* Ignore status.displayCommentPrefix: we do need comments in COMMIT_EDITMSG. */\n\told_display_comment_prefix = s->display_comment_prefix;\n\ts->display_comment_prefix = 1;\n\n\t/*\n\t * Most hints are counter-productive when the commit has\n\t * already started.\n\t */\n\ts->hints = 0;\n\n\tif (clean_message_contents)\n\t\tstrbuf_stripspace(&sb, 0);\n\n\tif (signoff)\n\t\tappend_signoff(&sb, ignore_non_trailer(sb.buf, sb.len), 0);\n\n\tif (fwrite(sb.buf, 1, sb.len, s->fp) < sb.len)\n\t\tdie_errno(_(\"could not write commit template\"));\n\n\tif (auto_comment_line_char)\n\t\tadjust_comment_line_char(&sb);\n\tstrbuf_release(&sb);\n\n\t/* This checks if committer ident is explicitly given */\n\tstrbuf_addstr(&committer_ident, git_committer_info(IDENT_STRICT));\n\tif (use_editor && include_status) {\n\t\tint ident_shown = 0;\n\t\tint saved_color_setting;\n\t\tstruct ident_split ci, ai;\n\t\tconst char *hint_cleanup_all = allow_empty_message ?\n\t\t\t_(\"Please enter the commit message for your changes.\"\n\t\t\t  \" Lines starting\\nwith '%c' will be ignored.\\n\") :\n\t\t\t_(\"Please enter the commit message for your changes.\"\n\t\t\t  \" Lines starting\\nwith '%c' will be ignored, and an empty\"\n\t\t\t  \" message aborts the commit.\\n\");\n\t\tconst char *hint_cleanup_space = allow_empty_message ?\n\t\t\t_(\"Please enter the commit message for your changes.\"\n\t\t\t  \" Lines starting\\n\"\n\t\t\t  \"with '%c' will be kept; you may remove them\"\n\t\t\t  \" yourself if you want to.\\n\") :\n\t\t\t_(\"Please enter the commit message for your changes.\"\n\t\t\t  \" Lines starting\\n\"\n\t\t\t  \"with '%c' will be kept; you may remove them\"\n\t\t\t  \" yourself if you want to.\\n\"\n\t\t\t  \"An empty message aborts the commit.\\n\");\n\t\tif (whence != FROM_COMMIT) {\n\t\t\tif (cleanup_mode == COMMIT_MSG_CLEANUP_SCISSORS &&\n\t\t\t\t!merge_contains_scissors)\n\t\t\t\twt_status_add_cut_line(s->fp);\n\t\t\tstatus_printf_ln(\n\t\t\t\ts, GIT_COLOR_NORMAL,\n\t\t\t\twhence == FROM_MERGE ?\n\t\t\t\t\t      _(\"\\n\"\n\t\t\t\t\t  \"It looks like you may be committing a merge.\\n\"\n\t\t\t\t\t  \"If this is not correct, please run\\n\"\n\t\t\t\t\t  \"\tgit update-ref -d MERGE_HEAD\\n\"\n\t\t\t\t\t  \"and try again.\\n\") :\n\t\t\t\t\t      _(\"\\n\"\n\t\t\t\t\t  \"It looks like you may be committing a cherry-pick.\\n\"\n\t\t\t\t\t  \"If this is not correct, please run\\n\"\n\t\t\t\t\t  \"\tgit update-ref -d CHERRY_PICK_HEAD\\n\"\n\t\t\t\t\t  \"and try again.\\n\"));\n\t\t}\n\n\t\tfprintf(s->fp, \"\\n\");\n\t\tif (cleanup_mode == COMMIT_MSG_CLEANUP_ALL)\n\t\t\tstatus_printf(s, GIT_COLOR_NORMAL, hint_cleanup_all, comment_line_char);\n\t\telse if (cleanup_mode == COMMIT_MSG_CLEANUP_SCISSORS) {\n\t\t\tif (whence == FROM_COMMIT && !merge_contains_scissors)\n\t\t\t\twt_status_add_cut_line(s->fp);\n\t\t} else /* COMMIT_MSG_CLEANUP_SPACE, that is. */\n\t\t\tstatus_printf(s, GIT_COLOR_NORMAL, hint_cleanup_space, comment_line_char);\n\n\t\t/*\n\t\t * These should never fail because they come from our own\n\t\t * fmt_ident. They may fail the sane_ident test, but we know\n\t\t * that the name and mail pointers will at least be valid,\n\t\t * which is enough for our tests and printing here.\n\t\t */\n\t\tassert_split_ident(&ai, author_ident);\n\t\tassert_split_ident(&ci, &committer_ident);\n\n\t\tif (ident_cmp(&ai, &ci))\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"%s\"\n\t\t\t\t\"Author:    %.*s <%.*s>\"),\n\t\t\t\tident_shown++ ? \"\" : \"\\n\",\n\t\t\t\t(int)(ai.name_end - ai.name_begin), ai.name_begin,\n\t\t\t\t(int)(ai.mail_end - ai.mail_begin), ai.mail_begin);\n\n\t\tif (author_date_is_interesting())\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"%s\"\n\t\t\t\t\"Date:      %s\"),\n\t\t\t\tident_shown++ ? \"\" : \"\\n\",\n\t\t\t\tshow_ident_date(&ai, DATE_MODE(NORMAL)));\n\n\t\tif (!committer_ident_sufficiently_given())\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"%s\"\n\t\t\t\t\"Committer: %.*s <%.*s>\"),\n\t\t\t\tident_shown++ ? \"\" : \"\\n\",\n\t\t\t\t(int)(ci.name_end - ci.name_begin), ci.name_begin,\n\t\t\t\t(int)(ci.mail_end - ci.mail_begin), ci.mail_begin);\n\n\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL, \"%s\", \"\"); /* Add new line for clarity */\n\n\t\tsaved_color_setting = s->use_color;\n\t\ts->use_color = 0;\n\t\tcommittable = run_status(s->fp, index_file, prefix, 1, s);\n\t\ts->use_color = saved_color_setting;\n\t\tstring_list_clear(&s->change, 1);\n\t} else {\n\t\tstruct object_id oid;\n\t\tconst char *parent = \"HEAD\";\n\n\t\tif (!active_nr && read_cache() < 0)\n\t\t\tdie(_(\"Cannot read index\"));\n\n\t\tif (amend)\n\t\t\tparent = \"HEAD^1\";\n\n\t\tif (get_oid(parent, &oid)) {\n\t\t\tint i, ita_nr = 0;\n\n\t\t\t/* TODO: audit for interaction with sparse-index. */\n\t\t\tensure_full_index(&the_index);\n\t\t\tfor (i = 0; i < active_nr; i++)\n\t\t\t\tif (ce_intent_to_add(active_cache[i]))\n\t\t\t\t\tita_nr++;\n\t\t\tcommittable = active_nr - ita_nr > 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Unless the user did explicitly request a submodule\n\t\t\t * ignore mode by passing a command line option we do\n\t\t\t * not ignore any changed submodule SHA-1s when\n\t\t\t * comparing index and parent, no matter what is\n\t\t\t * configured. Otherwise we won't commit any\n\t\t\t * submodules which were manually staged, which would\n\t\t\t * be really confusing.\n\t\t\t */\n\t\t\tstruct diff_flags flags = DIFF_FLAGS_INIT;\n\t\t\tflags.override_submodule_config = 1;\n\t\t\tif (ignore_submodule_arg &&\n\t\t\t    !strcmp(ignore_submodule_arg, \"all\"))\n\t\t\t\tflags.ignore_submodules = 1;\n\t\t\tcommittable = index_differs_from(the_repository,\n\t\t\t\t\t\t\t parent, &flags, 1);\n\t\t}\n\t}\n\tstrbuf_release(&committer_ident);\n\n\tfclose(s->fp);\n\n\tif (trailer_args.nr) {\n\t\tstruct child_process run_trailer = CHILD_PROCESS_INIT;\n\n\t\tstrvec_pushl(&run_trailer.args, \"interpret-trailers\",\n\t\t\t     \"--in-place\", git_path_commit_editmsg(), NULL);\n\t\tstrvec_pushv(&run_trailer.args, trailer_args.v);\n\t\trun_trailer.git_cmd = 1;\n\t\tif (run_command(&run_trailer))\n\t\t\tdie(_(\"unable to pass trailers to --trailers\"));\n\t\tstrvec_clear(&trailer_args);\n\t}\n\n\t/*\n\t * Reject an attempt to record a non-merge empty commit without\n\t * explicit --allow-empty. In the cherry-pick case, it may be\n\t * empty due to conflict resolution, which the user should okay.\n\t */\n\tif (!committable && whence != FROM_MERGE && !allow_empty &&\n\t    !(amend && is_a_merge(current_head))) {\n\t\ts->hints = advice_enabled(ADVICE_STATUS_HINTS);\n\t\ts->display_comment_prefix = old_display_comment_prefix;\n\t\trun_status(stdout, index_file, prefix, 0, s);\n\t\tif (amend)\n\t\t\tfputs(_(empty_amend_advice), stderr);\n\t\telse if (is_from_cherry_pick(whence) ||\n\t\t\t whence == FROM_REBASE_PICK) {\n\t\t\tfputs(_(empty_cherry_pick_advice), stderr);\n\t\t\tif (whence == FROM_CHERRY_PICK_SINGLE)\n\t\t\t\tfputs(_(empty_cherry_pick_advice_single), stderr);\n\t\t\telse if (whence == FROM_CHERRY_PICK_MULTI)\n\t\t\t\tfputs(_(empty_cherry_pick_advice_multi), stderr);\n\t\t\telse\n\t\t\t\tfputs(_(empty_rebase_pick_advice), stderr);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!no_verify && invoked_hook) {\n\t\t/*\n\t\t * Re-read the index as the pre-commit-commit hook was invoked\n\t\t * and could have updated it. We must do this before we invoke\n\t\t * the editor and after we invoke run_status above.\n\t\t */\n\t\tdiscard_cache();\n\t}\n\tread_cache_from(index_file);\n\n\tif (update_main_cache_tree(0)) {\n\t\terror(_(\"Error building trees\"));\n\t\treturn 0;\n\t}\n\n\tif (run_commit_hook(use_editor, index_file, NULL, \"prepare-commit-msg\",\n\t\t\t    git_path_commit_editmsg(), hook_arg1, hook_arg2, NULL))\n\t\treturn 0;\n\n\tif (use_editor) {\n\t\tstruct strvec env = STRVEC_INIT;\n\n\t\tstrvec_pushf(&env, \"GIT_INDEX_FILE=%s\", index_file);\n\t\tif (launch_editor(git_path_commit_editmsg(), NULL, env.v)) {\n\t\t\tfprintf(stderr,\n\t\t\t_(\"Please supply the message using either -m or -F option.\\n\"));\n\t\t\texit(1);\n\t\t}\n\t\tstrvec_clear(&env);\n\t}\n\n\tif (!no_verify &&\n\t    run_commit_hook(use_editor, index_file, NULL, \"commit-msg\",\n\t\t\t    git_path_commit_editmsg(), NULL)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic const char *find_author_by_nickname(const char *name)\n{\n\tstruct rev_info revs;\n\tstruct commit *commit;\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct string_list mailmap = STRING_LIST_INIT_NODUP;\n\tconst char *av[20];\n\tint ac = 0;\n\n\trepo_init_revisions(the_repository, &revs, NULL);\n\tstrbuf_addf(&buf, \"--author=%s\", name);\n\tav[++ac] = \"--all\";\n\tav[++ac] = \"-i\";\n\tav[++ac] = buf.buf;\n\tav[++ac] = NULL;\n\tsetup_revisions(ac, av, &revs, NULL);\n\trevs.mailmap = &mailmap;\n\tread_mailmap(revs.mailmap);\n\n\tif (prepare_revision_walk(&revs))\n\t\tdie(_(\"revision walk setup failed\"));\n\tcommit = get_revision(&revs);\n\tif (commit) {\n\t\tstruct pretty_print_context ctx = {0};\n\t\tctx.date_mode.type = DATE_NORMAL;\n\t\tstrbuf_release(&buf);\n\t\tformat_commit_message(commit, \"%aN <%aE>\", &buf, &ctx);\n\t\tclear_mailmap(&mailmap);\n\t\treturn strbuf_detach(&buf, NULL);\n\t}\n\tdie(_(\"--author '%s' is not 'Name <email>' and matches no existing author\"), name);\n}\n\nstatic void handle_ignored_arg(struct wt_status *s)\n{\n\tif (!ignored_arg)\n\t\t; /* default already initialized */\n\telse if (!strcmp(ignored_arg, \"traditional\"))\n\t\ts->show_ignored_mode = SHOW_TRADITIONAL_IGNORED;\n\telse if (!strcmp(ignored_arg, \"no\"))\n\t\ts->show_ignored_mode = SHOW_NO_IGNORED;\n\telse if (!strcmp(ignored_arg, \"matching\"))\n\t\ts->show_ignored_mode = SHOW_MATCHING_IGNORED;\n\telse\n\t\tdie(_(\"Invalid ignored mode '%s'\"), ignored_arg);\n}\n\nstatic void handle_untracked_files_arg(struct wt_status *s)\n{\n\tif (!untracked_files_arg)\n\t\t; /* default already initialized */\n\telse if (!strcmp(untracked_files_arg, \"no\"))\n\t\ts->show_untracked_files = SHOW_NO_UNTRACKED_FILES;\n\telse if (!strcmp(untracked_files_arg, \"normal\"))\n\t\ts->show_untracked_files = SHOW_NORMAL_UNTRACKED_FILES;\n\telse if (!strcmp(untracked_files_arg, \"all\"))\n\t\ts->show_untracked_files = SHOW_ALL_UNTRACKED_FILES;\n\t/*\n\t * Please update $__git_untracked_file_modes in\n\t * git-completion.bash when you add new options\n\t */\n\telse\n\t\tdie(_(\"Invalid untracked files mode '%s'\"), untracked_files_arg);\n}\n\nstatic const char *read_commit_message(const char *name)\n{\n\tconst char *out_enc;\n\tstruct commit *commit;\n\n\tcommit = lookup_commit_reference_by_name(name);\n\tif (!commit)\n\t\tdie(_(\"could not lookup commit %s\"), name);\n\tout_enc = get_commit_output_encoding();\n\treturn logmsg_reencode(commit, NULL, out_enc);\n}\n\n/*\n * Enumerate what needs to be propagated when --porcelain\n * is not in effect here.\n */\nstatic struct status_deferred_config {\n\tenum wt_status_format status_format;\n\tint show_branch;\n\tenum ahead_behind_flags ahead_behind;\n} status_deferred_config = {\n\tSTATUS_FORMAT_UNSPECIFIED,\n\t-1, /* unspecified */\n\tAHEAD_BEHIND_UNSPECIFIED,\n};\n\nstatic void finalize_deferred_config(struct wt_status *s)\n{\n\tint use_deferred_config = (status_format != STATUS_FORMAT_PORCELAIN &&\n\t\t\t\t   status_format != STATUS_FORMAT_PORCELAIN_V2 &&\n\t\t\t\t   !s->null_termination);\n\n\tif (s->null_termination) {\n\t\tif (status_format == STATUS_FORMAT_NONE ||\n\t\t    status_format == STATUS_FORMAT_UNSPECIFIED)\n\t\t\tstatus_format = STATUS_FORMAT_PORCELAIN;\n\t\telse if (status_format == STATUS_FORMAT_LONG)\n\t\t\tdie(_(\"options '%s' and '%s' cannot be used together\"), \"--long\", \"-z\");\n\t}\n\n\tif (use_deferred_config && status_format == STATUS_FORMAT_UNSPECIFIED)\n\t\tstatus_format = status_deferred_config.status_format;\n\tif (status_format == STATUS_FORMAT_UNSPECIFIED)\n\t\tstatus_format = STATUS_FORMAT_NONE;\n\n\tif (use_deferred_config && s->show_branch < 0)\n\t\ts->show_branch = status_deferred_config.show_branch;\n\tif (s->show_branch < 0)\n\t\ts->show_branch = 0;\n\n\t/*\n\t * If the user did not give a \"--[no]-ahead-behind\" command\n\t * line argument *AND* we will print in a human-readable format\n\t * (short, long etc.) then we inherit from the status.aheadbehind\n\t * config setting.  In all other cases (and porcelain V[12] formats\n\t * in particular), we inherit _FULL for backwards compatibility.\n\t */\n\tif (use_deferred_config &&\n\t    s->ahead_behind_flags == AHEAD_BEHIND_UNSPECIFIED)\n\t\ts->ahead_behind_flags = status_deferred_config.ahead_behind;\n\n\tif (s->ahead_behind_flags == AHEAD_BEHIND_UNSPECIFIED)\n\t\ts->ahead_behind_flags = AHEAD_BEHIND_FULL;\n}\n\nstatic void check_fixup_reword_options(int argc, const char *argv[]) {\n\tif (whence != FROM_COMMIT) {\n\t\tif (whence == FROM_MERGE)\n\t\t\tdie(_(\"You are in the middle of a merge -- cannot reword.\"));\n\t\telse if (is_from_cherry_pick(whence))\n\t\t\tdie(_(\"You are in the middle of a cherry-pick -- cannot reword.\"));\n\t}\n\tif (argc)\n\t\tdie(_(\"reword option of '%s' and path '%s' cannot be used together\"), \"--fixup\", *argv);\n\tif (patch_interactive || interactive || all || also || only)\n\t\tdie(_(\"reword option of '%s' and '%s' cannot be used together\"),\n\t\t\t\"--fixup\", \"--patch/--interactive/--all/--include/--only\");\n}\n\nstatic int parse_and_validate_options(int argc, const char *argv[],\n\t\t\t\t      const struct option *options,\n\t\t\t\t      const char * const usage[],\n\t\t\t\t      const char *prefix,\n\t\t\t\t      struct commit *current_head,\n\t\t\t\t      struct wt_status *s)\n{\n\targc = parse_options(argc, argv, prefix, options, usage, 0);\n\tfinalize_deferred_config(s);\n\n\tif (force_author && !strchr(force_author, '>'))\n\t\tforce_author = find_author_by_nickname(force_author);\n\n\tif (force_author && renew_authorship)\n\t\tdie(_(\"options '%s' and '%s' cannot be used together\"), \"--reset-author\", \"--author\");\n\n\tif (logfile || have_option_m || use_message)\n\t\tuse_editor = 0;\n\n\t/* Sanity check options */\n\tif (amend && !current_head)\n\t\tdie(_(\"You have nothing to amend.\"));\n\tif (amend && whence != FROM_COMMIT) {\n\t\tif (whence == FROM_MERGE)\n\t\t\tdie(_(\"You are in the middle of a merge -- cannot amend.\"));\n\t\telse if (is_from_cherry_pick(whence))\n\t\t\tdie(_(\"You are in the middle of a cherry-pick -- cannot amend.\"));\n\t\telse if (whence == FROM_REBASE_PICK)\n\t\t\tdie(_(\"You are in the middle of a rebase -- cannot amend.\"));\n\t}\n\tif (fixup_message && squash_message)\n\t\tdie(_(\"options '%s' and '%s' cannot be used together\"), \"--squash\", \"--fixup\");\n\tdie_for_incompatible_opt4(!!use_message, \"-C\",\n\t\t\t\t  !!edit_message, \"-c\",\n\t\t\t\t  !!logfile, \"-F\",\n\t\t\t\t  !!fixup_message, \"--fixup\");\n\tdie_for_incompatible_opt4(have_option_m, \"-m\",\n\t\t\t\t  !!edit_message, \"-c\",\n\t\t\t\t  !!use_message, \"-C\",\n\t\t\t\t  !!logfile, \"-F\");\n\tif (use_message || edit_message || logfile ||fixup_message || have_option_m)\n\t\ttemplate_file = NULL;\n\tif (edit_message)\n\t\tuse_message = edit_message;\n\tif (amend && !use_message && !fixup_message)\n\t\tuse_message = \"HEAD\";\n\tif (!use_message && !is_from_cherry_pick(whence) &&\n\t    !is_from_rebase(whence) && renew_authorship)\n\t\tdie(_(\"--reset-author can be used only with -C, -c or --amend.\"));\n\tif (use_message) {\n\t\tuse_message_buffer = read_commit_message(use_message);\n\t\tif (!renew_authorship) {\n\t\t\tauthor_message = use_message;\n\t\t\tauthor_message_buffer = use_message_buffer;\n\t\t}\n\t}\n\tif ((is_from_cherry_pick(whence) || whence == FROM_REBASE_PICK) &&\n\t    !renew_authorship) {\n\t\tauthor_message = \"CHERRY_PICK_HEAD\";\n\t\tauthor_message_buffer = read_commit_message(author_message);\n\t}\n\n\tif (patch_interactive)\n\t\tinteractive = 1;\n\n\tdie_for_incompatible_opt4(also, \"-i/--include\",\n\t\t\t\t  only, \"-o/--only\",\n\t\t\t\t  all, \"-a/--all\",\n\t\t\t\t  interactive, \"--interactive/-p/--patch\");\n\tif (fixup_message) {\n\t\t/*\n\t\t * We limit --fixup's suboptions to only alpha characters.\n\t\t * If the first character after a run of alpha is colon,\n\t\t * then the part before the colon may be a known suboption\n\t\t * name like `amend` or `reword`, or a misspelt suboption\n\t\t * name. In either case, we treat it as\n\t\t * --fixup=<suboption>:<arg>.\n\t\t *\n\t\t * Otherwise, we are dealing with --fixup=<commit>.\n\t\t */\n\t\tchar *p = fixup_message;\n\t\twhile (isalpha(*p))\n\t\t\tp++;\n\t\tif (p > fixup_message && *p == ':') {\n\t\t\t*p = '\\0';\n\t\t\tfixup_commit = p + 1;\n\t\t\tif (!strcmp(\"amend\", fixup_message) ||\n\t\t\t    !strcmp(\"reword\", fixup_message)) {\n\t\t\t\tfixup_prefix = \"amend\";\n\t\t\t\tallow_empty = 1;\n\t\t\t\tif (*fixup_message == 'r') {\n\t\t\t\t\tcheck_fixup_reword_options(argc, argv);\n\t\t\t\t\tonly = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdie(_(\"unknown option: --fixup=%s:%s\"), fixup_message, fixup_commit);\n\t\t\t}\n\t\t} else {\n\t\t\tfixup_commit = fixup_message;\n\t\t\tfixup_prefix = \"fixup\";\n\t\t\tuse_editor = 0;\n\t\t}\n\t}\n\n\tif (0 <= edit_flag)\n\t\tuse_editor = edit_flag;\n\n\tcleanup_mode = get_cleanup_mode(cleanup_arg, use_editor);\n\n\thandle_untracked_files_arg(s);\n\n\tif (all && argc > 0)\n\t\tdie(_(\"paths '%s ...' with -a does not make sense\"),\n\t\t    argv[0]);\n\n\tif (status_format != STATUS_FORMAT_NONE)\n\t\tdry_run = 1;\n\n\treturn argc;\n}\n\nstatic int dry_run_commit(const char **argv, const char *prefix,\n\t\t\t  const struct commit *current_head, struct wt_status *s)\n{\n\tint committable;\n\tconst char *index_file;\n\n\tindex_file = prepare_index(argv, prefix, current_head, 1);\n\tcommittable = run_status(stdout, index_file, prefix, 0, s);\n\trollback_index_files();\n\n\treturn committable ? 0 : 1;\n}\n\ndefine_list_config_array_extra(color_status_slots, {\"added\"});\n\nstatic int parse_status_slot(const char *slot)\n{\n\tif (!strcasecmp(slot, \"added\"))\n\t\treturn WT_STATUS_UPDATED;\n\n\treturn LOOKUP_CONFIG(color_status_slots, slot);\n}\n\nstatic int git_status_config(const char *k, const char *v, void *cb)\n{\n\tstruct wt_status *s = cb;\n\tconst char *slot_name;\n\n\tif (starts_with(k, \"column.\"))\n\t\treturn git_column_config(k, v, \"status\", &s->colopts);\n\tif (!strcmp(k, \"status.submodulesummary\")) {\n\t\tint is_bool;\n\t\ts->submodule_summary = git_config_bool_or_int(k, v, &is_bool);\n\t\tif (is_bool && s->submodule_summary)\n\t\t\ts->submodule_summary = -1;\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.short\")) {\n\t\tif (git_config_bool(k, v))\n\t\t\tstatus_deferred_config.status_format = STATUS_FORMAT_SHORT;\n\t\telse\n\t\t\tstatus_deferred_config.status_format = STATUS_FORMAT_NONE;\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.branch\")) {\n\t\tstatus_deferred_config.show_branch = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.aheadbehind\")) {\n\t\tstatus_deferred_config.ahead_behind = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.showstash\")) {\n\t\ts->show_stash = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.color\") || !strcmp(k, \"color.status\")) {\n\t\ts->use_color = git_config_colorbool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.displaycommentprefix\")) {\n\t\ts->display_comment_prefix = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (skip_prefix(k, \"status.color.\", &slot_name) ||\n\t    skip_prefix(k, \"color.status.\", &slot_name)) {\n\t\tint slot = parse_status_slot(slot_name);\n\t\tif (slot < 0)\n\t\t\treturn 0;\n\t\tif (!v)\n\t\t\treturn config_error_nonbool(k);\n\t\treturn color_parse(v, s->color_palette[slot]);\n\t}\n\tif (!strcmp(k, \"status.relativepaths\")) {\n\t\ts->relative_paths = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.showuntrackedfiles\")) {\n\t\tif (!v)\n\t\t\treturn config_error_nonbool(k);\n\t\telse if (!strcmp(v, \"no\"))\n\t\t\ts->show_untracked_files = SHOW_NO_UNTRACKED_FILES;\n\t\telse if (!strcmp(v, \"normal\"))\n\t\t\ts->show_untracked_files = SHOW_NORMAL_UNTRACKED_FILES;\n\t\telse if (!strcmp(v, \"all\"))\n\t\t\ts->show_untracked_files = SHOW_ALL_UNTRACKED_FILES;\n\t\telse\n\t\t\treturn error(_(\"Invalid untracked files mode '%s'\"), v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"diff.renamelimit\")) {\n\t\tif (s->rename_limit == -1)\n\t\t\ts->rename_limit = git_config_int(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.renamelimit\")) {\n\t\ts->rename_limit = git_config_int(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"diff.renames\")) {\n\t\tif (s->detect_rename == -1)\n\t\t\ts->detect_rename = git_config_rename(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.renames\")) {\n\t\ts->detect_rename = git_config_rename(k, v);\n\t\treturn 0;\n\t}\n\treturn git_diff_ui_config(k, v, NULL);\n}\n\nint cmd_status(int argc, const char **argv, const char *prefix)\n{\n\tstatic int no_renames = -1;\n\tstatic const char *rename_score_arg = (const char *)-1;\n\tstatic struct wt_status s;\n\tunsigned int progress_flag = 0;\n\tint fd;\n\tstruct object_id oid;\n\tstatic struct option builtin_status_options[] = {\n\t\tOPT__VERBOSE(&verbose, N_(\"be verbose\")),\n\t\tOPT_SET_INT('s', \"short\", &status_format,\n\t\t\t    N_(\"show status concisely\"), STATUS_FORMAT_SHORT),\n\t\tOPT_BOOL('b', \"branch\", &s.show_branch,\n\t\t\t N_(\"show branch information\")),\n\t\tOPT_BOOL(0, \"show-stash\", &s.show_stash,\n\t\t\t N_(\"show stash information\")),\n\t\tOPT_BOOL(0, \"ahead-behind\", &s.ahead_behind_flags,\n\t\t\t N_(\"compute full ahead/behind values\")),\n\t\tOPT_CALLBACK_F(0, \"porcelain\", &status_format,\n\t\t  N_(\"version\"), N_(\"machine-readable output\"),\n\t\t  PARSE_OPT_OPTARG, opt_parse_porcelain),\n\t\tOPT_SET_INT(0, \"long\", &status_format,\n\t\t\t    N_(\"show status in long format (default)\"),\n\t\t\t    STATUS_FORMAT_LONG),\n\t\tOPT_BOOL('z', \"null\", &s.null_termination,\n\t\t\t N_(\"terminate entries with NUL\")),\n\t\t{ OPTION_STRING, 'u', \"untracked-files\", &untracked_files_arg,\n\t\t  N_(\"mode\"),\n\t\t  N_(\"show untracked files, optional modes: all, normal, no. (Default: all)\"),\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\t{ OPTION_STRING, 0, \"ignored\", &ignored_arg,\n\t\t  N_(\"mode\"),\n\t\t  N_(\"show ignored files, optional modes: traditional, matching, no. (Default: traditional)\"),\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"traditional\" },\n\t\t{ OPTION_STRING, 0, \"ignore-submodules\", &ignore_submodule_arg, N_(\"when\"),\n\t\t  N_(\"ignore changes to submodules, optional when: all, dirty, untracked. (Default: all)\"),\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\tOPT_COLUMN(0, \"column\", &s.colopts, N_(\"list untracked files in columns\")),\n\t\tOPT_BOOL(0, \"no-renames\", &no_renames, N_(\"do not detect renames\")),\n\t\tOPT_CALLBACK_F('M', \"find-renames\", &rename_score_arg,\n\t\t  N_(\"n\"), N_(\"detect renames, optionally set similarity index\"),\n\t\t  PARSE_OPT_OPTARG | PARSE_OPT_NONEG, opt_parse_rename_score),\n\t\tOPT_END(),\n\t};\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_status_usage, builtin_status_options);\n\n\tprepare_repo_settings(the_repository);\n\tthe_repository->settings.command_requires_full_index = 0;\n\n\tstatus_init_config(&s, git_status_config);\n\targc = parse_options(argc, argv, prefix,\n\t\t\t     builtin_status_options,\n\t\t\t     builtin_status_usage, 0);\n\tfinalize_colopts(&s.colopts, -1);\n\tfinalize_deferred_config(&s);\n\n\thandle_untracked_files_arg(&s);\n\thandle_ignored_arg(&s);\n\n\tif (s.show_ignored_mode == SHOW_MATCHING_IGNORED &&\n\t    s.show_untracked_files == SHOW_NO_UNTRACKED_FILES)\n\t\tdie(_(\"Unsupported combination of ignored and untracked-files arguments\"));\n\n\tparse_pathspec(&s.pathspec, 0,\n\t\t       PATHSPEC_PREFER_FULL,\n\t\t       prefix, argv);\n\n\tif (status_format != STATUS_FORMAT_PORCELAIN &&\n\t    status_format != STATUS_FORMAT_PORCELAIN_V2)\n\t\tprogress_flag = REFRESH_PROGRESS;\n\trepo_read_index(the_repository);\n\trefresh_index(&the_index,\n\t\t      REFRESH_QUIET|REFRESH_UNMERGED|progress_flag,\n\t\t      &s.pathspec, NULL, NULL);\n\n\tif (use_optional_locks())\n\t\tfd = hold_locked_index(&index_lock, 0);\n\telse\n\t\tfd = -1;\n\n\ts.is_initial = get_oid(s.reference, &oid) ? 1 : 0;\n\tif (!s.is_initial)\n\t\toidcpy(&s.oid_commit, &oid);\n\n\ts.ignore_submodule_arg = ignore_submodule_arg;\n\ts.status_format = status_format;\n\ts.verbose = verbose;\n\tif (no_renames != -1)\n\t\ts.detect_rename = !no_renames;\n\tif ((intptr_t)rename_score_arg != -1) {\n\t\tif (s.detect_rename < DIFF_DETECT_RENAME)\n\t\t\ts.detect_rename = DIFF_DETECT_RENAME;\n\t\tif (rename_score_arg)\n\t\t\ts.rename_score = parse_rename_score(&rename_score_arg);\n\t}\n\n\twt_status_collect(&s);\n\n\tif (0 <= fd)\n\t\trepo_update_index_if_able(the_repository, &index_lock);\n\n\tif (s.relative_paths)\n\t\ts.prefix = prefix;\n\n\twt_status_print(&s);\n\twt_status_collect_free_buffers(&s);\n\n\treturn 0;\n}\n\nstatic int git_commit_config(const char *k, const char *v, void *cb)\n{\n\tstruct wt_status *s = cb;\n\tint status;\n\n\tif (!strcmp(k, \"commit.template\"))\n\t\treturn git_config_pathname(&template_file, k, v);\n\tif (!strcmp(k, \"commit.status\")) {\n\t\tinclude_status = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"commit.cleanup\"))\n\t\treturn git_config_string(&cleanup_arg, k, v);\n\tif (!strcmp(k, \"commit.gpgsign\")) {\n\t\tsign_commit = git_config_bool(k, v) ? \"\" : NULL;\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"commit.verbose\")) {\n\t\tint is_bool;\n\t\tconfig_commit_verbose = git_config_bool_or_int(k, v, &is_bool);\n\t\treturn 0;\n\t}\n\n\tstatus = git_gpg_config(k, v, NULL);\n\tif (status)\n\t\treturn status;\n\treturn git_status_config(k, v, s);\n}\n\nint cmd_commit(int argc, const char **argv, const char *prefix)\n{\n\tstatic struct wt_status s;\n\tstatic struct option builtin_commit_options[] = {\n\t\tOPT__QUIET(&quiet, N_(\"suppress summary after successful commit\")),\n\t\tOPT__VERBOSE(&verbose, N_(\"show diff in commit message template\")),\n\n\t\tOPT_GROUP(N_(\"Commit message options\")),\n\t\tOPT_FILENAME('F', \"file\", &logfile, N_(\"read message from file\")),\n\t\tOPT_STRING(0, \"author\", &force_author, N_(\"author\"), N_(\"override author for commit\")),\n\t\tOPT_STRING(0, \"date\", &force_date, N_(\"date\"), N_(\"override date for commit\")),\n\t\tOPT_CALLBACK('m', \"message\", &message, N_(\"message\"), N_(\"commit message\"), opt_parse_m),\n\t\tOPT_STRING('c', \"reedit-message\", &edit_message, N_(\"commit\"), N_(\"reuse and edit message from specified commit\")),\n\t\tOPT_STRING('C', \"reuse-message\", &use_message, N_(\"commit\"), N_(\"reuse message from specified commit\")),\n\t\t/*\n\t\t * TRANSLATORS: Leave \"[(amend|reword):]\" as-is,\n\t\t * and only translate <commit>.\n\t\t */\n\t\tOPT_STRING(0, \"fixup\", &fixup_message, N_(\"[(amend|reword):]commit\"), N_(\"use autosquash formatted message to fixup or amend/reword specified commit\")),\n\t\tOPT_STRING(0, \"squash\", &squash_message, N_(\"commit\"), N_(\"use autosquash formatted message to squash specified commit\")),\n\t\tOPT_BOOL(0, \"reset-author\", &renew_authorship, N_(\"the commit is authored by me now (used with -C/-c/--amend)\")),\n\t\tOPT_CALLBACK_F(0, \"trailer\", NULL, N_(\"trailer\"), N_(\"add custom trailer(s)\"), PARSE_OPT_NONEG, opt_pass_trailer),\n\t\tOPT_BOOL('s', \"signoff\", &signoff, N_(\"add a Signed-off-by trailer\")),\n\t\tOPT_FILENAME('t', \"template\", &template_file, N_(\"use specified template file\")),\n\t\tOPT_BOOL('e', \"edit\", &edit_flag, N_(\"force edit of commit\")),\n\t\tOPT_CLEANUP(&cleanup_arg),\n\t\tOPT_BOOL(0, \"status\", &include_status, N_(\"include status in commit message template\")),\n\t\t{ OPTION_STRING, 'S', \"gpg-sign\", &sign_commit, N_(\"key-id\"),\n\t\t  N_(\"GPG sign commit\"), PARSE_OPT_OPTARG, NULL, (intptr_t) \"\" },\n\t\t/* end commit message options */\n\n\t\tOPT_GROUP(N_(\"Commit contents options\")),\n\t\tOPT_BOOL('a', \"all\", &all, N_(\"commit all changed files\")),\n\t\tOPT_BOOL('i', \"include\", &also, N_(\"add specified files to index for commit\")),\n\t\tOPT_BOOL(0, \"interactive\", &interactive, N_(\"interactively add files\")),\n\t\tOPT_BOOL('p', \"patch\", &patch_interactive, N_(\"interactively add changes\")),\n\t\tOPT_BOOL('o', \"only\", &only, N_(\"commit only specified files\")),\n\t\tOPT_BOOL('n', \"no-verify\", &no_verify, N_(\"bypass pre-commit and commit-msg hooks\")),\n\t\tOPT_BOOL(0, \"dry-run\", &dry_run, N_(\"show what would be committed\")),\n\t\tOPT_SET_INT(0, \"short\", &status_format, N_(\"show status concisely\"),\n\t\t\t    STATUS_FORMAT_SHORT),\n\t\tOPT_BOOL(0, \"branch\", &s.show_branch, N_(\"show branch information\")),\n\t\tOPT_BOOL(0, \"ahead-behind\", &s.ahead_behind_flags,\n\t\t\t N_(\"compute full ahead/behind values\")),\n\t\tOPT_SET_INT(0, \"porcelain\", &status_format,\n\t\t\t    N_(\"machine-readable output\"), STATUS_FORMAT_PORCELAIN),\n\t\tOPT_SET_INT(0, \"long\", &status_format,\n\t\t\t    N_(\"show status in long format (default)\"),\n\t\t\t    STATUS_FORMAT_LONG),\n\t\tOPT_BOOL('z', \"null\", &s.null_termination,\n\t\t\t N_(\"terminate entries with NUL\")),\n\t\tOPT_BOOL(0, \"amend\", &amend, N_(\"amend previous commit\")),\n\t\tOPT_BOOL(0, \"no-post-rewrite\", &no_post_rewrite, N_(\"bypass post-rewrite hook\")),\n\t\t{ OPTION_STRING, 'u', \"untracked-files\", &untracked_files_arg, N_(\"mode\"), N_(\"show untracked files, optional modes: all, normal, no. (Default: all)\"), PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\tOPT_PATHSPEC_FROM_FILE(&pathspec_from_file),\n\t\tOPT_PATHSPEC_FILE_NUL(&pathspec_file_nul),\n\t\t/* end commit contents options */\n\n\t\tOPT_HIDDEN_BOOL(0, \"allow-empty\", &allow_empty,\n\t\t\t\tN_(\"ok to record an empty change\")),\n\t\tOPT_HIDDEN_BOOL(0, \"allow-empty-message\", &allow_empty_message,\n\t\t\t\tN_(\"ok to record a change with an empty message\")),\n\n\t\tOPT_END()\n\t};\n\n\tstruct strbuf sb = STRBUF_INIT;\n\tstruct strbuf author_ident = STRBUF_INIT;\n\tconst char *index_file, *reflog_msg;\n\tstruct object_id oid;\n\tstruct commit_list *parents = NULL;\n\tstruct stat statbuf;\n\tstruct commit *current_head = NULL;\n\tstruct commit_extra_header *extra = NULL;\n\tstruct strbuf err = STRBUF_INIT;\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_commit_usage, builtin_commit_options);\n\n\tprepare_repo_settings(the_repository);\n\tthe_repository->settings.command_requires_full_index = 0;\n\n\tstatus_init_config(&s, git_commit_config);\n\ts.commit_template = 1;\n\tstatus_format = STATUS_FORMAT_NONE; /* Ignore status.short */\n\ts.colopts = 0;\n\n\tif (get_oid(\"HEAD\", &oid))\n\t\tcurrent_head = NULL;\n\telse {\n\t\tcurrent_head = lookup_commit_or_die(&oid, \"HEAD\");\n\t\tif (parse_commit(current_head))\n\t\t\tdie(_(\"could not parse HEAD commit\"));\n\t}\n\tverbose = -1; /* unspecified */\n\targc = parse_and_validate_options(argc, argv, builtin_commit_options,\n\t\t\t\t\t  builtin_commit_usage,\n\t\t\t\t\t  prefix, current_head, &s);\n\tif (verbose == -1)\n\t\tverbose = (config_commit_verbose < 0) ? 0 : config_commit_verbose;\n\n\tif (dry_run)\n\t\treturn dry_run_commit(argv, prefix, current_head, &s);\n\tindex_file = prepare_index(argv, prefix, current_head, 0);\n\n\t/* Set up everything for writing the commit object.  This includes\n\t   running hooks, writing the trees, and interacting with the user.  */\n\tif (!prepare_to_commit(index_file, prefix,\n\t\t\t       current_head, &s, &author_ident)) {\n\t\trollback_index_files();\n\t\treturn 1;\n\t}\n\n\t/* Determine parents */\n\treflog_msg = getenv(\"GIT_REFLOG_ACTION\");\n\tif (!current_head) {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (initial)\";\n\t} else if (amend) {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (amend)\";\n\t\tparents = copy_commit_list(current_head->parents);\n\t} else if (whence == FROM_MERGE) {\n\t\tstruct strbuf m = STRBUF_INIT;\n\t\tFILE *fp;\n\t\tint allow_fast_forward = 1;\n\t\tstruct commit_list **pptr = &parents;\n\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (merge)\";\n\t\tpptr = commit_list_append(current_head, pptr);\n\t\tfp = xfopen(git_path_merge_head(the_repository), \"r\");\n\t\twhile (strbuf_getline_lf(&m, fp) != EOF) {\n\t\t\tstruct commit *parent;\n\n\t\t\tparent = get_merge_parent(m.buf);\n\t\t\tif (!parent)\n\t\t\t\tdie(_(\"Corrupt MERGE_HEAD file (%s)\"), m.buf);\n\t\t\tpptr = commit_list_append(parent, pptr);\n\t\t}\n\t\tfclose(fp);\n\t\tstrbuf_release(&m);\n\t\tif (!stat(git_path_merge_mode(the_repository), &statbuf)) {\n\t\t\tif (strbuf_read_file(&sb, git_path_merge_mode(the_repository), 0) < 0)\n\t\t\t\tdie_errno(_(\"could not read MERGE_MODE\"));\n\t\t\tif (!strcmp(sb.buf, \"no-ff\"))\n\t\t\t\tallow_fast_forward = 0;\n\t\t}\n\t\tif (allow_fast_forward)\n\t\t\treduce_heads_replace(&parents);\n\t} else {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = is_from_cherry_pick(whence)\n\t\t\t\t\t? \"commit (cherry-pick)\"\n\t\t\t\t\t: is_from_rebase(whence)\n\t\t\t\t\t? \"commit (rebase)\"\n\t\t\t\t\t: \"commit\";\n\t\tcommit_list_insert(current_head, &parents);\n\t}\n\n\t/* Finally, get the commit message */\n\tstrbuf_reset(&sb);\n\tif (strbuf_read_file(&sb, git_path_commit_editmsg(), 0) < 0) {\n\t\tint saved_errno = errno;\n\t\trollback_index_files();\n\t\tdie(_(\"could not read commit message: %s\"), strerror(saved_errno));\n\t}\n\n\tcleanup_message(&sb, cleanup_mode, verbose);\n\n\tif (message_is_empty(&sb, cleanup_mode) && !allow_empty_message) {\n\t\trollback_index_files();\n\t\tfprintf(stderr, _(\"Aborting commit due to empty commit message.\\n\"));\n\t\texit(1);\n\t}\n\tif (template_untouched(&sb, template_file, cleanup_mode) && !allow_empty_message) {\n\t\trollback_index_files();\n\t\tfprintf(stderr, _(\"Aborting commit; you did not edit the message.\\n\"));\n\t\texit(1);\n\t}\n\n\tif (fixup_message && starts_with(sb.buf, \"amend! \") &&\n\t    !allow_empty_message) {\n\t\tstruct strbuf body = STRBUF_INIT;\n\t\tsize_t len = commit_subject_length(sb.buf);\n\t\tstrbuf_addstr(&body, sb.buf + len);\n\t\tif (message_is_empty(&body, cleanup_mode)) {\n\t\t\trollback_index_files();\n\t\t\tfprintf(stderr, _(\"Aborting commit due to empty commit message body.\\n\"));\n\t\t\texit(1);\n\t\t}\n\t\tstrbuf_release(&body);\n\t}\n\n\tif (amend) {\n\t\tconst char *exclude_gpgsig[3] = { \"gpgsig\", \"gpgsig-sha256\", NULL };\n\t\textra = read_commit_extra_headers(current_head, exclude_gpgsig);\n\t} else {\n\t\tstruct commit_extra_header **tail = &extra;\n\t\tappend_merge_tag_headers(parents, &tail);\n\t}\n\n\tif (commit_tree_extended(sb.buf, sb.len, &active_cache_tree->oid,\n\t\t\t\t parents, &oid, author_ident.buf, NULL,\n\t\t\t\t sign_commit, extra)) {\n\t\trollback_index_files();\n\t\tdie(_(\"failed to write commit object\"));\n\t}\n\tstrbuf_release(&author_ident);\n\tfree_commit_extra_headers(extra);\n\n\tif (update_head_with_reflog(current_head, &oid, reflog_msg, &sb,\n\t\t\t\t    &err)) {\n\t\trollback_index_files();\n\t\tdie(\"%s\", err.buf);\n\t}\n\n\tsequencer_post_commit_cleanup(the_repository, 0);\n\tunlink(git_path_merge_head(the_repository));\n\tunlink(git_path_merge_msg(the_repository));\n\tunlink(git_path_merge_mode(the_repository));\n\tunlink(git_path_squash_msg(the_repository));\n\n\tif (commit_index_files())\n\t\tdie(_(\"repository has been updated, but unable to write\\n\"\n\t\t      \"new_index file. Check that disk is not full and quota is\\n\"\n\t\t      \"not exceeded, and then \\\"git restore --staged :/\\\" to recover.\"));\n\n\tgit_test_write_commit_graph_or_die();\n\n\trepo_rerere(the_repository, 0);\n\trun_auto_maintenance(quiet);\n\trun_commit_hook(use_editor, get_index_file(), NULL, \"post-commit\",\n\t\t\tNULL);\n\tif (amend && !no_post_rewrite) {\n\t\tcommit_post_rewrite(the_repository, current_head, &oid);\n\t}\n\tif (!quiet) {\n\t\tunsigned int flags = 0;\n\n\t\tif (!current_head)\n\t\t\tflags |= SUMMARY_INITIAL_COMMIT;\n\t\tif (author_date_is_interesting())\n\t\t\tflags |= SUMMARY_SHOW_AUTHOR_DATE;\n\t\tprint_commit_summary(the_repository, prefix,\n\t\t\t\t     &oid, flags);\n\t}\n\n\tapply_autostash(git_path_merge_autostash(the_repository));\n\n\tUNLEAK(err);\n\tUNLEAK(sb);\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "009a1de0a3d3f69e05a802d7d2356935018b0f81",
  "sha1_ok": true,
  "size": 57813
}
