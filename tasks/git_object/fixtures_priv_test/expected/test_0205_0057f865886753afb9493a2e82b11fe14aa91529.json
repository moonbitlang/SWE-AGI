{
  "content": {
    "base64": "IyEvdXNyL2Jpbi9wZXJsIC13CgoKdXNlIHN0cmljdDsKCnN1YiBydW5fY21kX3BpcGUgewoJbXkgJGZoID0gdW5kZWY7CglvcGVuKCRmaCwgJy18JywgQF8pIG9yIGRpZTsKCXJldHVybiA8JGZoPjsKfQoKbXkgKCRHSVRfRElSKSA9IHJ1bl9jbWRfcGlwZShxdyhnaXQgcmV2LXBhcnNlIC0tZ2l0LWRpcikpOwoKaWYgKCFkZWZpbmVkICRHSVRfRElSKSB7CglleGl0KDEpOyAjIHJldi1wYXJzZSB3b3VsZCBoYXZlIGFscmVhZHkgc2FpZCAibm90IGEgZ2l0IHJlcG8iCn0KY2hvbXAoJEdJVF9ESVIpOwoKc3ViIHJlZnJlc2ggewoJbXkgJGZoOwoJb3BlbiAkZmgsICctfCcsIHF3KGdpdCB1cGRhdGUtaW5kZXggLS1yZWZyZXNoKQoJICAgIG9yIGRpZTsKCXdoaWxlICg8JGZoPikgewoJCTsjIGlnbm9yZSAnbmVlZHMgdXBkYXRlJwoJfQoJY2xvc2UgJGZoOwp9CgpzdWIgbGlzdF91bnRyYWNrZWQgewoJbWFwIHsKCQljaG9tcCAkXzsKCQkkXzsKCX0KCXJ1bl9jbWRfcGlwZShxdyhnaXQgbHMtZmlsZXMgLS1vdGhlcnMKCQkJLS1leGNsdWRlLXBlci1kaXJlY3Rvcnk9LmdpdGlnbm9yZSksCgkJICAgICAiLS1leGNsdWRlLWZyb209JEdJVF9ESVIvaW5mby9leGNsdWRlIiwKCQkgICAgICctLScsIEBfKTsKfQoKbXkgJHN0YXR1c19mbXQgPSAnJTEycyAlMTJzICVzJzsKbXkgJHN0YXR1c19oZWFkID0gc3ByaW50Zigkc3RhdHVzX2ZtdCwgJ3N0YWdlZCcsICd1bnN0YWdlZCcsICdwYXRoJyk7CgojIFJldHVybnMgbGlzdCBvZiBoYXNoZXMsIGNvbnRlbnRzIG9mIGVhY2ggb2Ygd2hpY2ggYXJlOgojIFBSSU5UOglwcmludCBtZXNzYWdlCiMgVkFMVUU6CXBhdGhuYW1lCiMgQklOQVJZOglpcyBhIGJpbmFyeSBwYXRoCiMgSU5ERVg6CWlzIGluZGV4IGRpZmZlcmVudCBmcm9tIEhFQUQ/CiMgRklMRToJCWlzIGZpbGUgZGlmZmVyZW50IGZyb20gaW5kZXg/CiMgSU5ERVhfQUREREVMOglpcyBpdCBhZGQvZGVsZXRlIGJldHdlZW4gSEVBRCBhbmQgaW5kZXg/CiMgRklMRV9BRERERUw6CWlzIGl0IGFkZC9kZWxldGUgYmV0d2VlbiBpbmRleCBhbmQgZmlsZT8KCnN1YiBsaXN0X21vZGlmaWVkIHsKCW15ICgkb25seSkgPSBAXzsKCW15ICglZGF0YSwgQHJldHVybik7CglteSAoJGFkZCwgJGRlbCwgJGFkZGRlbCwgJGZpbGUpOwoKCWZvciAocnVuX2NtZF9waXBlKHF3KGdpdCBkaWZmLWluZGV4IC0tY2FjaGVkCgkJCSAgICAgLS1udW1zdGF0IC0tc3VtbWFyeSBIRUFEKSkpIHsKCQlpZiAoKCRhZGQsICRkZWwsICRmaWxlKSA9CgkJICAgIC9eKFstXGRdKykJKFstXGRdKykJKC4qKS8pIHsKCQkJbXkgKCRjaGFuZ2UsICRiaW4pOwoJCQlpZiAoJGFkZCBlcSAnLScgJiYgJGRlbCBlcSAnLScpIHsKCQkJCSRjaGFuZ2UgPSAnYmluYXJ5JzsKCQkJCSRiaW4gPSAxOwoJCQl9CgkJCWVsc2UgewoJCQkJJGNoYW5nZSA9ICIrJGFkZC8tJGRlbCI7CgkJCX0KCQkJJGRhdGF7JGZpbGV9ID0gewoJCQkJSU5ERVggPT4gJGNoYW5nZSwKCQkJCUJJTkFSWSA9PiAkYmluLAoJCQkJRklMRSA9PiAnbm90aGluZycsCgkJCX0KCQl9CgkJZWxzaWYgKCgkYWRkZGVsLCAkZmlsZSkgPQoJCSAgICAgICAvXiAoY3JlYXRlfGRlbGV0ZSkgbW9kZSBbMC03XSsgKC4qKSQvKSB7CgkJCSRkYXRheyRmaWxlfXtJTkRFWF9BRERERUx9ID0gJGFkZGRlbDsKCQl9Cgl9CgoJZm9yIChydW5fY21kX3BpcGUocXcoZ2l0IGRpZmYtZmlsZXMgLS1udW1zdGF0IC0tc3VtbWFyeSkpKSB7CgkJaWYgKCgkYWRkLCAkZGVsLCAkZmlsZSkgPQoJCSAgICAvXihbLVxkXSspCShbLVxkXSspCSguKikvKSB7CgkJCWlmICghZXhpc3RzICRkYXRheyRmaWxlfSkgewoJCQkJJGRhdGF7JGZpbGV9ID0gK3sKCQkJCQlJTkRFWCA9PiAndW5jaGFuZ2VkJywKCQkJCQlCSU5BUlkgPT4gMCwKCQkJCX07CgkJCX0KCQkJbXkgKCRjaGFuZ2UsICRiaW4pOwoJCQlpZiAoJGFkZCBlcSAnLScgJiYgJGRlbCBlcSAnLScpIHsKCQkJCSRjaGFuZ2UgPSAnYmluYXJ5JzsKCQkJCSRiaW4gPSAxOwoJCQl9CgkJCWVsc2UgewoJCQkJJGNoYW5nZSA9ICIrJGFkZC8tJGRlbCI7CgkJCX0KCQkJJGRhdGF7JGZpbGV9e0ZJTEV9ID0gJGNoYW5nZTsKCQkJaWYgKCRiaW4pIHsKCQkJCSRkYXRheyRmaWxlfXtCSU5BUll9ID0gMTsKCQkJfQoJCX0KCQllbHNpZiAoKCRhZGRkZWwsICRmaWxlKSA9CgkJICAgICAgIC9eIChjcmVhdGV8ZGVsZXRlKSBtb2RlIFswLTddKyAoLiopJC8pIHsKCQkJJGRhdGF7JGZpbGV9e0ZJTEVfQUREREVMfSA9ICRhZGRkZWw7CgkJfQoJfQoKCWZvciAoc29ydCBrZXlzICVkYXRhKSB7CgkJbXkgJGl0ID0gJGRhdGF7JF99OwoKCQlpZiAoJG9ubHkpIHsKCQkJaWYgKCRvbmx5IGVxICdpbmRleC1vbmx5JykgewoJCQkJbmV4dCBpZiAoJGl0LT57SU5ERVh9IGVxICd1bmNoYW5nZWQnKTsKCQkJfQoJCQlpZiAoJG9ubHkgZXEgJ2ZpbGUtb25seScpIHsKCQkJCW5leHQgaWYgKCRpdC0+e0ZJTEV9IGVxICdub3RoaW5nJyk7CgkJCX0KCQl9CgkJcHVzaCBAcmV0dXJuLCArewoJCQlWQUxVRSA9PiAkXywKCQkJUFJJTlQgPT4gKHNwcmludGYgJHN0YXR1c19mbXQsCgkJCQkgICRpdC0+e0lOREVYfSwgJGl0LT57RklMRX0sICRfKSwKCQkJJSRpdCwKCQl9OwoJfQoJcmV0dXJuIEByZXR1cm47Cn0KCnN1YiBmaW5kX3VuaXF1ZSB7CglteSAoJHN0cmluZywgQHN0dWZmKSA9IEBfOwoJbXkgJGZvdW5kID0gdW5kZWY7Cglmb3IgKG15ICRpID0gMDsgJGkgPCBAc3R1ZmY7ICRpKyspIHsKCQlteSAkaXQgPSAkc3R1ZmZbJGldOwoJCW15ICRoaXQgPSB1bmRlZjsKCQlpZiAocmVmICRpdCkgewoJCQlpZiAoKHJlZiAkaXQpIGVxICdBUlJBWScpIHsKCQkJCSRpdCA9ICRpdC0+WzBdOwoJCQl9CgkJCWVsc2UgewoJCQkJJGl0ID0gJGl0LT57VkFMVUV9OwoJCQl9CgkJfQoJCWV2YWwgewoJCQlpZiAoJGl0ID1+IC9eJHN0cmluZy8pIHsKCQkJCSRoaXQgPSAxOwoJCQl9OwoJCX07CgkJaWYgKGRlZmluZWQgJGhpdCAmJiBkZWZpbmVkICRmb3VuZCkgewoJCQlyZXR1cm4gdW5kZWY7CgkJfQoJCWlmICgkaGl0KSB7CgkJCSRmb3VuZCA9ICRpICsgMTsKCQl9Cgl9CglyZXR1cm4gJGZvdW5kOwp9CgpzdWIgbGlzdF9hbmRfY2hvb3NlIHsKCW15ICgkb3B0cywgQHN0dWZmKSA9IEBfOwoJbXkgKEBjaG9zZW4sIEByZXR1cm4pOwoJbXkgJGk7CgogICAgICBUT1BMT09QOgoJd2hpbGUgKDEpIHsKCQlteSAkbGFzdF9sZiA9IDA7CgoJCWlmICgkb3B0cy0+e0hFQURFUn0pIHsKCQkJaWYgKCEkb3B0cy0+e0xJU1RfRkxBVH0pIHsKCQkJCXByaW50ICIgICAgICI7CgkJCX0KCQkJcHJpbnQgIiRvcHRzLT57SEVBREVSfVxuIjsKCQl9CgkJZm9yICgkaSA9IDA7ICRpIDwgQHN0dWZmOyAkaSsrKSB7CgkJCW15ICRjaG9zZW4gPSAkY2hvc2VuWyRpXSA/ICcqJyA6ICcgJzsKCQkJbXkgJHByaW50ID0gJHN0dWZmWyRpXTsKCQkJaWYgKHJlZiAkcHJpbnQpIHsKCQkJCWlmICgocmVmICRwcmludCkgZXEgJ0FSUkFZJykgewoJCQkJCSRwcmludCA9ICRwcmludC0+WzBdOwoJCQkJfQoJCQkJZWxzZSB7CgkJCQkJJHByaW50ID0gJHByaW50LT57UFJJTlR9OwoJCQkJfQoJCQl9CgkJCXByaW50ZigiJXMlMmQ6ICVzIiwgJGNob3NlbiwgJGkrMSwgJHByaW50KTsKCQkJaWYgKCgkb3B0cy0+e0xJU1RfRkxBVH0pICYmCgkJCSAgICAoKCRpICsgMSkgJSAoJG9wdHMtPntMSVNUX0ZMQVR9KSkpIHsKCQkJCXByaW50ICJcdCI7CgkJCQkkbGFzdF9sZiA9IDA7CgkJCX0KCQkJZWxzZSB7CgkJCQlwcmludCAiXG4iOwoJCQkJJGxhc3RfbGYgPSAxOwoJCQl9CgkJfQoJCWlmICghJGxhc3RfbGYpIHsKCQkJcHJpbnQgIlxuIjsKCQl9CgoJCXJldHVybiBpZiAoJG9wdHMtPntMSVNUX09OTFl9KTsKCgkJcHJpbnQgJG9wdHMtPntQUk9NUFR9OwoJCWlmICgkb3B0cy0+e1NJTkdMRVRPTn0pIHsKCQkJcHJpbnQgIj4gIjsKCQl9CgkJZWxzZSB7CgkJCXByaW50ICI+PiAiOwoJCX0KCQlteSAkbGluZSA9IDxTVERJTj47CgkJbGFzdCBpZiAoISRsaW5lKTsKCQljaG9tcCAkbGluZTsKCQlteSAkZG9uZXNvbWV0aGluZyA9IDA7CgkJZm9yIG15ICRjaG9pY2UgKHNwbGl0KC9bXHMsXSsvLCAkbGluZSkpIHsKCQkJbXkgJGNob29zZSA9IDE7CgkJCW15ICgkYm90dG9tLCAkdG9wKTsKCgkJCSMgSW5wdXQgdGhhdCBiZWdpbnMgd2l0aCAnLSc7IHVuY2hvb3NlCgkJCWlmICgkY2hvaWNlID1+IHMvXi0vLykgewoJCQkJJGNob29zZSA9IDA7CgkJCX0KCQkJIyBBIHJhbmdlIGNhbiBiZSBzcGVjaWZpZWQgbGlrZSA1LTcKCQkJaWYgKCRjaG9pY2UgPX4gL14oXGQrKS0oXGQrKSQvKSB7CgkJCQkoJGJvdHRvbSwgJHRvcCkgPSAoJDEsICQyKTsKCQkJfQoJCQllbHNpZiAoJGNob2ljZSA9fiAvXlxkKyQvKSB7CgkJCQkkYm90dG9tID0gJHRvcCA9ICRjaG9pY2U7CgkJCX0KCQkJZWxzaWYgKCRjaG9pY2UgZXEgJyonKSB7CgkJCQkkYm90dG9tID0gMTsKCQkJCSR0b3AgPSAxICsgQHN0dWZmOwoJCQl9CgkJCWVsc2UgewoJCQkJJGJvdHRvbSA9ICR0b3AgPSBmaW5kX3VuaXF1ZSgkY2hvaWNlLCBAc3R1ZmYpOwoJCQkJaWYgKCFkZWZpbmVkICRib3R0b20pIHsKCQkJCQlwcmludCAiSHVoICgkY2hvaWNlKT9cbiI7CgkJCQkJbmV4dCBUT1BMT09QOwoJCQkJfQoJCQl9CgkJCWlmICgkb3B0cy0+e1NJTkdMRVRPTn0gJiYgJGJvdHRvbSAhPSAkdG9wKSB7CgkJCQlwcmludCAiSHVoICgkY2hvaWNlKT9cbiI7CgkJCQluZXh0IFRPUExPT1A7CgkJCX0KCQkJZm9yICgkaSA9ICRib3R0b20tMTsgJGkgPD0gJHRvcC0xOyAkaSsrKSB7CgkJCQluZXh0IGlmIChAc3R1ZmYgPD0gJGkpOwoJCQkJJGNob3NlblskaV0gPSAkY2hvb3NlOwoJCQkJJGRvbmVzb21ldGhpbmcrKzsKCQkJfQoJCX0KCQlsYXN0IGlmICghJGRvbmVzb21ldGhpbmcgfHwgJG9wdHMtPntJTU1FRElBVEV9KTsKCX0KCWZvciAoJGkgPSAwOyAkaSA8IEBzdHVmZjsgJGkrKykgewoJCWlmICgkY2hvc2VuWyRpXSkgewoJCQlwdXNoIEByZXR1cm4sICRzdHVmZlskaV07CgkJfQoJfQoJcmV0dXJuIEByZXR1cm47Cn0KCnN1YiBzdGF0dXNfY21kIHsKCWxpc3RfYW5kX2Nob29zZSh7IExJU1RfT05MWSA9PiAxLCBIRUFERVIgPT4gJHN0YXR1c19oZWFkIH0sCgkJCWxpc3RfbW9kaWZpZWQoKSk7CglwcmludCAiXG4iOwp9CgpzdWIgc2F5X25fcGF0aHMgewoJbXkgJGRpZCA9IHNoaWZ0IEBfOwoJbXkgJGNudCA9IHNjYWxhciBAXzsKCXByaW50ICIkZGlkICI7CglpZiAoMSA8ICRjbnQpIHsKCQlwcmludCAiJGNudCBwYXRoc1xuIjsKCX0KCWVsc2UgewoJCXByaW50ICJvbmUgcGF0aFxuIjsKCX0KfQoKc3ViIHVwZGF0ZV9jbWQgewoJbXkgQG1vZHMgPSBsaXN0X21vZGlmaWVkKCdmaWxlLW9ubHknKTsKCXJldHVybiBpZiAoIUBtb2RzKTsKCglteSBAdXBkYXRlID0gbGlzdF9hbmRfY2hvb3NlKHsgUFJPTVBUID0+ICdVcGRhdGUnLAoJCQkJICAgICAgIEhFQURFUiA9PiAkc3RhdHVzX2hlYWQsIH0sCgkJCQkgICAgIEBtb2RzKTsKCWlmIChAdXBkYXRlKSB7CgkJc3lzdGVtKHF3KGdpdCB1cGRhdGUtaW5kZXggLS1hZGQgLS0pLAoJCSAgICAgICBtYXAgeyAkXy0+e1ZBTFVFfSB9IEB1cGRhdGUpOwoJCXNheV9uX3BhdGhzKCd1cGRhdGVkJywgQHVwZGF0ZSk7Cgl9CglwcmludCAiXG4iOwp9CgpzdWIgcmV2ZXJ0X2NtZCB7CglteSBAdXBkYXRlID0gbGlzdF9hbmRfY2hvb3NlKHsgUFJPTVBUID0+ICdSZXZlcnQnLAoJCQkJICAgICAgIEhFQURFUiA9PiAkc3RhdHVzX2hlYWQsIH0sCgkJCQkgICAgIGxpc3RfbW9kaWZpZWQoKSk7CglpZiAoQHVwZGF0ZSkgewoJCW15IEBsaW5lcyA9IHJ1bl9jbWRfcGlwZShxdyhnaXQgbHMtdHJlZSBIRUFEIC0tKSwKCQkJCQkgbWFwIHsgJF8tPntWQUxVRX0gfSBAdXBkYXRlKTsKCQlteSAkZmg7CgkJb3BlbiAkZmgsICd8LScsIHF3KGdpdCB1cGRhdGUtaW5kZXggLS1pbmRleC1pbmZvKQoJCSAgICBvciBkaWU7CgkJZm9yIChAbGluZXMpIHsKCQkJcHJpbnQgJGZoICRfOwoJCX0KCQljbG9zZSgkZmgpOwoJCWZvciAoQHVwZGF0ZSkgewoJCQlpZiAoJF8tPntJTkRFWF9BRERERUx9ICYmCgkJCSAgICAkXy0+e0lOREVYX0FERERFTH0gZXEgJ2NyZWF0ZScpIHsKCQkJCXN5c3RlbShxdyhnaXQgdXBkYXRlLWluZGV4IC0tZm9yY2UtcmVtb3ZlIC0tKSwKCQkJCSAgICAgICAkXy0+e1ZBTFVFfSk7CgkJCQlwcmludCAibm90ZTogJF8tPntWQUxVRX0gaXMgdW50cmFja2VkIG5vdy5cbiI7CgkJCX0KCQl9CgkJcmVmcmVzaCgpOwoJCXNheV9uX3BhdGhzKCdyZXZlcnRlZCcsIEB1cGRhdGUpOwoJfQoJcHJpbnQgIlxuIjsKfQoKc3ViIGFkZF91bnRyYWNrZWRfY21kIHsKCW15IEBhZGQgPSBsaXN0X2FuZF9jaG9vc2UoeyBQUk9NUFQgPT4gJ0FkZCB1bnRyYWNrZWQnIH0sCgkJCQkgIGxpc3RfdW50cmFja2VkKCkpOwoJaWYgKEBhZGQpIHsKCQlzeXN0ZW0ocXcoZ2l0IHVwZGF0ZS1pbmRleCAtLWFkZCAtLSksIEBhZGQpOwoJCXNheV9uX3BhdGhzKCdhZGRlZCcsIEBhZGQpOwoJfQoJcHJpbnQgIlxuIjsKfQoKc3ViIHBhcnNlX2RpZmYgewoJbXkgKCRwYXRoKSA9IEBfOwoJbXkgQGRpZmYgPSBydW5fY21kX3BpcGUocXcoZ2l0IGRpZmYtZmlsZXMgLXAgLS0pLCAkcGF0aCk7CglteSAoQGh1bmspID0geyBURVhUID0+IFtdIH07CgoJZm9yIChAZGlmZikgewoJCWlmICgvXkBAIC8pIHsKCQkJcHVzaCBAaHVuaywgeyBURVhUID0+IFtdIH07CgkJfQoJCXB1c2ggQHskaHVua1stMV17VEVYVH19LCAkXzsKCX0KCXJldHVybiBAaHVuazsKfQoKc3ViIGh1bmtfc3BsaXR0YWJsZSB7CglteSAoJHRleHQpID0gQF87CgoJbXkgQHMgPSBzcGxpdF9odW5rKCR0ZXh0KTsKCXJldHVybiAoMSA8IEBzKTsKfQoKc3ViIHBhcnNlX2h1bmtfaGVhZGVyIHsKCW15ICgkbGluZSkgPSBAXzsKCW15ICgkb19vZnMsICRvX2NudCwgJG5fb2ZzLCAkbl9jbnQpID0KCSAgICAkbGluZSA9fiAvXkBAIC0oXGQrKSg/OiwoXGQrKSkgXCsoXGQrKSg/OiwoXGQrKSkgQEAvOwoJcmV0dXJuICgkb19vZnMsICRvX2NudCwgJG5fb2ZzLCAkbl9jbnQpOwp9CgpzdWIgc3BsaXRfaHVuayB7CglteSAoJHRleHQpID0gQF87CglteSBAc3BsaXQgPSAoKTsKCgkjIElmIHRoZXJlIGFyZSBjb250ZXh0IGxpbmVzIGluIHRoZSBtaWRkbGUgb2YgYSBodW5rLAoJIyBpdCBjYW4gYmUgc3BsaXQsIGJ1dCB3ZSB3b3VsZCBuZWVkIHRvIHRha2UgY2FyZSBvZgoJIyBvdmVybGFwcyBsYXRlci4KCglteSAoJG9fb2ZzLCAkb19jbnQsICRuX29mcywgJG5fY250KSA9IHBhcnNlX2h1bmtfaGVhZGVyKCR0ZXh0LT5bMF0pOwoJbXkgJGh1bmtfc3RhcnQgPSAxOwoJbXkgJG5leHRfaHVua19zdGFydDsKCiAgICAgIE9VVEVSOgoJd2hpbGUgKDEpIHsKCQlteSAkbmV4dF9odW5rX3N0YXJ0ID0gdW5kZWY7CgkJbXkgJGkgPSAkaHVua19zdGFydCAtIDE7CgkJbXkgJHRoaXMgPSArewoJCQlURVhUID0+IFtdLAoJCQlPTEQgPT4gJG9fb2ZzLAoJCQlORVcgPT4gJG5fb2ZzLAoJCQlPQ05UID0+IDAsCgkJCU5DTlQgPT4gMCwKCQkJQUREREVMID0+IDAsCgkJCVBPU1RDVFggPT4gMCwKCQl9OwoKCQl3aGlsZSAoKyskaSA8IEAkdGV4dCkgewoJCQlteSAkbGluZSA9ICR0ZXh0LT5bJGldOwoJCQlpZiAoJGxpbmUgPX4gL14gLykgewoJCQkJaWYgKCR0aGlzLT57QUREREVMfSAmJgoJCQkJICAgICFkZWZpbmVkICRuZXh0X2h1bmtfc3RhcnQpIHsKCQkJCQkjIFdlIGhhdmUgc2VlbiBsZWFkaW5nIGNvbnRleHQgYW5kCgkJCQkJIyBhZGRzL2RlbHMgYW5kIHRoZW4gaGVyZSBpcyBhbm90aGVyCgkJCQkJIyBjb250ZXh0LCB3aGljaCBpcyB0cmFpbGluZyBmb3IgdGhpcwoJCQkJCSMgc3BsaXQgaHVuayBhbmQgbGVhZGluZyBmb3IgdGhlIG5leHQKCQkJCQkjIG9uZS4KCQkJCQkkbmV4dF9odW5rX3N0YXJ0ID0gJGk7CgkJCQl9CgkJCQlwdXNoIEB7JHRoaXMtPntURVhUfX0sICRsaW5lOwoJCQkJJHRoaXMtPntPQ05UfSsrOwoJCQkJJHRoaXMtPntOQ05UfSsrOwoJCQkJaWYgKGRlZmluZWQgJG5leHRfaHVua19zdGFydCkgewoJCQkJCSR0aGlzLT57UE9TVENUWH0rKzsKCQkJCX0KCQkJCW5leHQ7CgkJCX0KCgkJCSMgYWRkL2RlbAoJCQlpZiAoZGVmaW5lZCAkbmV4dF9odW5rX3N0YXJ0KSB7CgkJCQkjIFdlIGFyZSBkb25lIHdpdGggdGhlIGN1cnJlbnQgaHVuayBhbmQKCQkJCSMgdGhpcyBpcyB0aGUgZmlyc3QgcmVhbCBjaGFuZ2UgZm9yIHRoZQoJCQkJIyBuZXh0IHNwbGl0IG9uZS4KCQkJCSRodW5rX3N0YXJ0ID0gJG5leHRfaHVua19zdGFydDsKCQkJCSRvX29mcyA9ICR0aGlzLT57T0xEfSArICR0aGlzLT57T0NOVH07CgkJCQkkbl9vZnMgPSAkdGhpcy0+e05FV30gKyAkdGhpcy0+e05DTlR9OwoJCQkJJG9fb2ZzIC09ICR0aGlzLT57UE9TVENUWH07CgkJCQkkbl9vZnMgLT0gJHRoaXMtPntQT1NUQ1RYfTsKCQkJCXB1c2ggQHNwbGl0LCAkdGhpczsKCQkJCXJlZG8gT1VURVI7CgkJCX0KCQkJcHVzaCBAeyR0aGlzLT57VEVYVH19LCAkbGluZTsKCQkJJHRoaXMtPntBRERERUx9Kys7CgkJCWlmICgkbGluZSA9fiAvXi0vKSB7CgkJCQkkdGhpcy0+e09DTlR9Kys7CgkJCX0KCQkJZWxzZSB7CgkJCQkkdGhpcy0+e05DTlR9Kys7CgkJCX0KCQl9CgoJCXB1c2ggQHNwbGl0LCAkdGhpczsKCQlsYXN0OwoJfQoKCWZvciBteSAkaHVuayAoQHNwbGl0KSB7CgkJJG9fb2ZzID0gJGh1bmstPntPTER9OwoJCSRuX29mcyA9ICRodW5rLT57TkVXfTsKCQkkb19jbnQgPSAkaHVuay0+e09DTlR9OwoJCSRuX2NudCA9ICRodW5rLT57TkNOVH07CgoJCW15ICRoZWFkID0gKCJAQCAtJG9fb2ZzIiAuCgkJCSAgICAoKCRvX2NudCAhPSAxKSA/ICIsJG9fY250IiA6ICcnKSAuCgkJCSAgICAiICskbl9vZnMiIC4KCQkJICAgICgoJG5fY250ICE9IDEpID8gIiwkbl9jbnQiIDogJycpIC4KCQkJICAgICIgQEBcbiIpOwoJCXVuc2hpZnQgQHskaHVuay0+e1RFWFR9fSwgJGhlYWQ7Cgl9CglyZXR1cm4gbWFwIHsgJF8tPntURVhUfSB9IEBzcGxpdDsKfQoKc3ViIGZpbmRfbGFzdF9vX2N0eCB7CglteSAoJGl0KSA9IEBfOwoJbXkgJHRleHQgPSAkaXQtPntURVhUfTsKCW15ICgkb19vZnMsICRvX2NudCwgJG5fb2ZzLCAkbl9jbnQpID0gcGFyc2VfaHVua19oZWFkZXIoJHRleHQtPlswXSk7CglteSAkaSA9IEB7JHRleHR9OwoJbXkgJGxhc3Rfb19jdHggPSAkb19vZnMgKyAkb19jbnQ7Cgl3aGlsZSAoMCA8IC0tJGkpIHsKCQlteSAkbGluZSA9ICR0ZXh0LT5bJGldOwoJCWlmICgkbGluZSA9fiAvXiAvKSB7CgkJCSRsYXN0X29fY3R4LS07CgkJCW5leHQ7CgkJfQoJCWxhc3Q7Cgl9CglyZXR1cm4gJGxhc3Rfb19jdHg7Cn0KCnN1YiBtZXJnZV9odW5rIHsKCW15ICgkcHJldiwgJHRoaXMpID0gQF87CglteSAoJG8wX29mcywgJG8wX2NudCwgJG4wX29mcywgJG4wX2NudCkgPQoJICAgIHBhcnNlX2h1bmtfaGVhZGVyKCRwcmV2LT57VEVYVH1bMF0pOwoJbXkgKCRvMV9vZnMsICRvMV9jbnQsICRuMV9vZnMsICRuMV9jbnQpID0KCSAgICBwYXJzZV9odW5rX2hlYWRlcigkdGhpcy0+e1RFWFR9WzBdKTsKCglteSAoQGxpbmUsICRpLCAkb2ZzLCAkb19jbnQsICRuX2NudCk7Cgkkb2ZzID0gJG8wX29mczsKCSRvX2NudCA9ICRuX2NudCA9IDA7Cglmb3IgKCRpID0gMTsgJGkgPCBAeyRwcmV2LT57VEVYVH19OyAkaSsrKSB7CgkJbXkgJGxpbmUgPSAkcHJldi0+e1RFWFR9WyRpXTsKCQlpZiAoJGxpbmUgPX4gL15cKy8pIHsKCQkJJG5fY250Kys7CgkJCXB1c2ggQGxpbmUsICRsaW5lOwoJCQluZXh0OwoJCX0KCgkJbGFzdCBpZiAoJG8xX29mcyA8PSAkb2ZzKTsKCgkJJG9fY250Kys7CgkJJG9mcysrOwoJCWlmICgkbGluZSA9fiAvXiAvKSB7CgkJCSRuX2NudCsrOwoJCX0KCQlwdXNoIEBsaW5lLCAkbGluZTsKCX0KCglmb3IgKCRpID0gMTsgJGkgPCBAeyR0aGlzLT57VEVYVH19OyAkaSsrKSB7CgkJbXkgJGxpbmUgPSAkdGhpcy0+e1RFWFR9WyRpXTsKCQlpZiAoJGxpbmUgPX4gL15cKy8pIHsKCQkJJG5fY250Kys7CgkJCXB1c2ggQGxpbmUsICRsaW5lOwoJCQluZXh0OwoJCX0KCQkkb2ZzKys7CgkJJG9fY250Kys7CgkJaWYgKCRsaW5lID1+IC9eIC8pIHsKCQkJJG5fY250Kys7CgkJfQoJCXB1c2ggQGxpbmUsICRsaW5lOwoJfQoJbXkgJGhlYWQgPSAoIkBAIC0kbzBfb2ZzIiAuCgkJICAgICgoJG9fY250ICE9IDEpID8gIiwkb19jbnQiIDogJycpIC4KCQkgICAgIiArJG4wX29mcyIgLgoJCSAgICAoKCRuX2NudCAhPSAxKSA/ICIsJG5fY250IiA6ICcnKSAuCgkJICAgICIgQEBcbiIpOwoJQHskcHJldi0+e1RFWFR9fSA9ICgkaGVhZCwgQGxpbmUpOwp9CgpzdWIgY29hbGVzY2Vfb3ZlcmxhcHBpbmdfaHVua3MgewoJbXkgKEBpbikgPSBAXzsKCW15IEBvdXQgPSAoKTsKCglteSAoJGxhc3Rfb19jdHgpOwoKCWZvciAoZ3JlcCB7ICRfLT57VVNFfSB9IEBpbikgewoJCW15ICR0ZXh0ID0gJF8tPntURVhUfTsKCQlteSAoJG9fb2ZzLCAkb19jbnQsICRuX29mcywgJG5fY250KSA9CgkJICAgIHBhcnNlX2h1bmtfaGVhZGVyKCR0ZXh0LT5bMF0pOwoJCWlmIChkZWZpbmVkICRsYXN0X29fY3R4ICYmCgkJICAgICRvX29mcyA8PSAkbGFzdF9vX2N0eCkgewoJCQltZXJnZV9odW5rKCRvdXRbLTFdLCAkXyk7CgkJfQoJCWVsc2UgewoJCQlwdXNoIEBvdXQsICRfOwoJCX0KCQkkbGFzdF9vX2N0eCA9IGZpbmRfbGFzdF9vX2N0eCgkb3V0Wy0xXSk7Cgl9CglyZXR1cm4gQG91dDsKfQoKc3ViIGhlbHBfcGF0Y2hfY21kIHsKCXByaW50IDw8XEVPRiA7CnkgLSBzdGFnZSB0aGlzIGh1bmsKbiAtIGRvIG5vdCBzdGFnZSB0aGlzIGh1bmsKYSAtIHN0YWdlIHRoaXMgYW5kIGFsbCB0aGUgcmVtYWluaW5nIGh1bmtzCmQgLSBkbyBub3Qgc3RhZ2UgdGhpcyBodW5rIG5vciBhbnkgb2YgdGhlIHJlbWFpbmluZyBodW5rcwpqIC0gbGVhdmUgdGhpcyBodW5rIHVuZGVjaWRlZCwgc2VlIG5leHQgdW5kZWNpZGVkIGh1bmsKSiAtIGxlYXZlIHRoaXMgaHVuayB1bmRlY2lkZWQsIHNlZSBuZXh0IGh1bmsKayAtIGxlYXZlIHRoaXMgaHVuayB1bmRlY2lkZWQsIHNlZSBwcmV2aW91cyB1bmRlY2lkZWQgaHVuawpLIC0gbGVhdmUgdGhpcyBodW5rIHVuZGVjaWRlZCwgc2VlIHByZXZpb3VzIGh1bmsKcyAtIHNwbGl0IHRoZSBjdXJyZW50IGh1bmsgaW50byBzbWFsbGVyIGh1bmtzCkVPRgp9CgpzdWIgcGF0Y2hfdXBkYXRlX2NtZCB7CglteSBAbW9kcyA9IGxpc3RfbW9kaWZpZWQoJ2ZpbGUtb25seScpOwoJQG1vZHMgPSBncmVwIHsgISgkXy0+e0JJTkFSWX0pIH0gQG1vZHM7CglyZXR1cm4gaWYgKCFAbW9kcyk7CgoJbXkgKCRpdCkgPSBsaXN0X2FuZF9jaG9vc2UoeyBQUk9NUFQgPT4gJ1BhdGNoIHVwZGF0ZScsCgkJCQkgICAgIFNJTkdMRVRPTiA9PiAxLAoJCQkJICAgICBJTU1FRElBVEUgPT4gMSwKCQkJCSAgICAgSEVBREVSID0+ICRzdGF0dXNfaGVhZCwgfSwKCQkJCSAgIEBtb2RzKTsKCXJldHVybiBpZiAoISRpdCk7CgoJbXkgKCRpeCwgJG51bSk7CglteSAkcGF0aCA9ICRpdC0+e1ZBTFVFfTsKCW15ICgkaGVhZCwgQGh1bmspID0gcGFyc2VfZGlmZigkcGF0aCk7Cglmb3IgKEB7JGhlYWQtPntURVhUfX0pIHsKCQlwcmludDsKCX0KCSRudW0gPSBzY2FsYXIgQGh1bms7CgkkaXggPSAwOwoKCXdoaWxlICgxKSB7CgkJbXkgKCRwcmV2LCAkbmV4dCwgJG90aGVyLCAkdW5kZWNpZGVkLCAkaSk7CgkJJG90aGVyID0gJyc7CgoJCWlmICgkbnVtIDw9ICRpeCkgewoJCQkkaXggPSAwOwoJCX0KCQlmb3IgKCRpID0gMDsgJGkgPCAkaXg7ICRpKyspIHsKCQkJaWYgKCFkZWZpbmVkICRodW5rWyRpXXtVU0V9KSB7CgkJCQkkcHJldiA9IDE7CgkJCQkkb3RoZXIgLj0gJy9rJzsKCQkJCWxhc3Q7CgkJCX0KCQl9CgkJaWYgKCRpeCkgewoJCQkkb3RoZXIgLj0gJy9LJzsKCQl9CgkJZm9yICgkaSA9ICRpeCArIDE7ICRpIDwgJG51bTsgJGkrKykgewoJCQlpZiAoIWRlZmluZWQgJGh1bmtbJGlde1VTRX0pIHsKCQkJCSRuZXh0ID0gMTsKCQkJCSRvdGhlciAuPSAnL2onOwoJCQkJbGFzdDsKCQkJfQoJCX0KCQlpZiAoJGl4IDwgJG51bSAtIDEpIHsKCQkJJG90aGVyIC49ICcvSic7CgkJfQoJCWZvciAoJGkgPSAwOyAkaSA8ICRudW07ICRpKyspIHsKCQkJaWYgKCFkZWZpbmVkICRodW5rWyRpXXtVU0V9KSB7CgkJCQkkdW5kZWNpZGVkID0gMTsKCQkJCWxhc3Q7CgkJCX0KCQl9CgkJbGFzdCBpZiAoISR1bmRlY2lkZWQpOwoKCQlpZiAoaHVua19zcGxpdHRhYmxlKCRodW5rWyRpeF17VEVYVH0pKSB7CgkJCSRvdGhlciAuPSAnL3MnOwoJCX0KCQlmb3IgKEB7JGh1bmtbJGl4XXtURVhUfX0pIHsKCQkJcHJpbnQ7CgkJfQoJCXByaW50ICJTdGFnZSB0aGlzIGh1bmsgW3kvbi9hL2Qkb3RoZXIvP10/ICI7CgkJbXkgJGxpbmUgPSA8U1RESU4+OwoJCWlmICgkbGluZSkgewoJCQlpZiAoJGxpbmUgPX4gL155L2kpIHsKCQkJCSRodW5rWyRpeF17VVNFfSA9IDE7CgkJCX0KCQkJZWxzaWYgKCRsaW5lID1+IC9ebi9pKSB7CgkJCQkkaHVua1skaXhde1VTRX0gPSAwOwoJCQl9CgkJCWVsc2lmICgkbGluZSA9fiAvXmEvaSkgewoJCQkJd2hpbGUgKCRpeCA8ICRudW0pIHsKCQkJCQlpZiAoIWRlZmluZWQgJGh1bmtbJGl4XXtVU0V9KSB7CgkJCQkJCSRodW5rWyRpeF17VVNFfSA9IDE7CgkJCQkJfQoJCQkJCSRpeCsrOwoJCQkJfQoJCQkJbmV4dDsKCQkJfQoJCQllbHNpZiAoJGxpbmUgPX4gL15kL2kpIHsKCQkJCXdoaWxlICgkaXggPCAkbnVtKSB7CgkJCQkJaWYgKCFkZWZpbmVkICRodW5rWyRpeF17VVNFfSkgewoJCQkJCQkkaHVua1skaXhde1VTRX0gPSAwOwoJCQkJCX0KCQkJCQkkaXgrKzsKCQkJCX0KCQkJCW5leHQ7CgkJCX0KCQkJZWxzaWYgKCRvdGhlciA9fiAvSy8gJiYgJGxpbmUgPX4gL15LLykgewoJCQkJJGl4LS07CgkJCQluZXh0OwoJCQl9CgkJCWVsc2lmICgkb3RoZXIgPX4gL0ovICYmICRsaW5lID1+IC9eSi8pIHsKCQkJCSRpeCsrOwoJCQkJbmV4dDsKCQkJfQoJCQllbHNpZiAoJG90aGVyID1+IC9rLyAmJiAkbGluZSA9fiAvXmsvKSB7CgkJCQl3aGlsZSAoMSkgewoJCQkJCSRpeC0tOwoJCQkJCWxhc3QgaWYgKCEkaXggfHwKCQkJCQkJICFkZWZpbmVkICRodW5rWyRpeF17VVNFfSk7CgkJCQl9CgkJCQluZXh0OwoJCQl9CgkJCWVsc2lmICgkb3RoZXIgPX4gL2ovICYmICRsaW5lID1+IC9eai8pIHsKCQkJCXdoaWxlICgxKSB7CgkJCQkJJGl4Kys7CgkJCQkJbGFzdCBpZiAoJGl4ID49ICRudW0gfHwKCQkJCQkJICFkZWZpbmVkICRodW5rWyRpeF17VVNFfSk7CgkJCQl9CgkJCQluZXh0OwoJCQl9CgkJCWVsc2lmICgkb3RoZXIgPX4gL3MvICYmICRsaW5lID1+IC9ecy8pIHsKCQkJCW15IEBzcGxpdCA9IHNwbGl0X2h1bmsoJGh1bmtbJGl4XXtURVhUfSk7CgkJCQlpZiAoMSA8IEBzcGxpdCkgewoJCQkJCXByaW50ICJTcGxpdCBpbnRvICIsCgkJCQkJc2NhbGFyKEBzcGxpdCksICIgaHVua3MuXG4iOwoJCQkJfQoJCQkJc3BsaWNlKEBodW5rLCAkaXgsIDEsCgkJCQkgICAgICAgbWFwIHsgK3sgVEVYVCA9PiAkXywgVVNFID0+IHVuZGVmIH0gfQoJCQkJICAgICAgIEBzcGxpdCk7CgkJCQkkbnVtID0gc2NhbGFyIEBodW5rOwoJCQkJbmV4dDsKCQkJfQoJCQllbHNlIHsKCQkJCWhlbHBfcGF0Y2hfY21kKCRvdGhlcik7CgkJCQluZXh0OwoJCQl9CgkJCSMgc29mdCBpbmNyZW1lbnQKCQkJd2hpbGUgKDEpIHsKCQkJCSRpeCsrOwoJCQkJbGFzdCBpZiAoJGl4ID49ICRudW0gfHwKCQkJCQkgIWRlZmluZWQgJGh1bmtbJGl4XXtVU0V9KTsKCQkJfQoJCX0KCX0KCglAaHVuayA9IGNvYWxlc2NlX292ZXJsYXBwaW5nX2h1bmtzKEBodW5rKTsKCglteSAoJG9fbG9mcywgJG5fbG9mcykgPSAoMCwgMCk7CglteSBAcmVzdWx0ID0gKCk7Cglmb3IgKEBodW5rKSB7CgkJbXkgJHRleHQgPSAkXy0+e1RFWFR9OwoJCW15ICgkb19vZnMsICRvX2NudCwgJG5fb2ZzLCAkbl9jbnQpID0KCQkgICAgcGFyc2VfaHVua19oZWFkZXIoJHRleHQtPlswXSk7CgoJCWlmICghJF8tPntVU0V9KSB7CgkJCWlmICghZGVmaW5lZCAkb19jbnQpIHsgJG9fY250ID0gMTsgfQoJCQlpZiAoIWRlZmluZWQgJG5fY250KSB7ICRuX2NudCA9IDE7IH0KCgkJCSMgV2Ugd291bGQgaGF2ZSBhZGRlZCAoJG5fY250IC0gJG9fY250KSBsaW5lcwoJCQkjIHRvIHRoZSBwb3N0aW1hZ2UgaWYgd2Ugd2VyZSB0byB1c2UgdGhpcyBodW5rLAoJCQkjIGJ1dCB3ZSBkaWRuJ3QuICBTbyB0aGUgbGluZSBudW1iZXIgdGhhdCB0aGUgbmV4dAoJCQkjIGh1bmsgc3RhcnRzIGF0IHdvdWxkIGJlIHNoaWZ0ZWQgYnkgdGhhdCBtdWNoLgoJCQkkbl9sb2ZzIC09ICgkbl9jbnQgLSAkb19jbnQpOwoJCQluZXh0OwoJCX0KCQllbHNlIHsKCQkJaWYgKCRuX2xvZnMpIHsKCQkJCSRuX29mcyArPSAkbl9sb2ZzOwoJCQkJJHRleHQtPlswXSA9ICgiQEAgLSRvX29mcyIgLgoJCQkJCSAgICAgICgoZGVmaW5lZCAkb19jbnQpCgkJCQkJICAgICAgID8gIiwkb19jbnQiIDogJycpIC4KCQkJCQkgICAgICAiICskbl9vZnMiIC4KCQkJCQkgICAgICAoKGRlZmluZWQgJG5fY250KQoJCQkJCSAgICAgICA/ICIsJG5fY250IiA6ICcnKSAuCgkJCQkJICAgICAgIiBAQFxuIik7CgkJCX0KCQkJZm9yIChAJHRleHQpIHsKCQkJCXB1c2ggQHJlc3VsdCwgJF87CgkJCX0KCQl9Cgl9CgoJaWYgKEByZXN1bHQpIHsKCQlteSAkZmg7CgoJCW9wZW4gJGZoLCAnfC0nLCBxdyhnaXQgYXBwbHkgLS1jYWNoZWQpOwoJCWZvciAoQHskaGVhZC0+e1RFWFR9fSwgQHJlc3VsdCkgewoJCQlwcmludCAkZmggJF87CgkJfQoJCWlmICghY2xvc2UgJGZoKSB7CgkJCWZvciAoQHskaGVhZC0+e1RFWFR9fSwgQHJlc3VsdCkgewoJCQkJcHJpbnQgU1RERVJSICRfOwoJCQl9CgkJfQoJCXJlZnJlc2goKTsKCX0KCglwcmludCAiXG4iOwp9CgpzdWIgZGlmZl9jbWQgewoJbXkgQG1vZHMgPSBsaXN0X21vZGlmaWVkKCdpbmRleC1vbmx5Jyk7CglAbW9kcyA9IGdyZXAgeyAhKCRfLT57QklOQVJZfSkgfSBAbW9kczsKCXJldHVybiBpZiAoIUBtb2RzKTsKCW15IChAdGhlbSkgPSBsaXN0X2FuZF9jaG9vc2UoeyBQUk9NUFQgPT4gJ1JldmlldyBkaWZmJywKCQkJCSAgICAgSU1NRURJQVRFID0+IDEsCgkJCQkgICAgIEhFQURFUiA9PiAkc3RhdHVzX2hlYWQsIH0sCgkJCQkgICBAbW9kcyk7CglyZXR1cm4gaWYgKCFAdGhlbSk7CglzeXN0ZW0ocXcoZ2l0IGRpZmYtaW5kZXggLXAgLS1jYWNoZWQgSEVBRCAtLSksCgkgICAgICAgbWFwIHsgJF8tPntWQUxVRX0gfSBAdGhlbSk7Cn0KCnN1YiBxdWl0X2NtZCB7CglwcmludCAiQnllLlxuIjsKCWV4aXQoMCk7Cn0KCnN1YiBoZWxwX2NtZCB7CglwcmludCA8PFxFT0YgOwpzdGF0dXMgICAgICAgIC0gc2hvdyBwYXRocyB3aXRoIGNoYW5nZXMKdXBkYXRlICAgICAgICAtIGFkZCB3b3JraW5nIHRyZWUgc3RhdGUgdG8gdGhlIHN0YWdlZCBzZXQgb2YgY2hhbmdlcwpyZXZlcnQgICAgICAgIC0gcmV2ZXJ0IHN0YWdlZCBzZXQgb2YgY2hhbmdlcyBiYWNrIHRvIHRoZSBIRUFEIHZlcnNpb24KcGF0Y2ggICAgICAgICAtIHBpY2sgaHVua3MgYW5kIHVwZGF0ZSBzZWxlY3RpdmVseQpkaWZmCSAgICAgIC0gdmlldyBkaWZmIGJldHdlZW4gSEVBRCBhbmQgaW5kZXgKYWRkIHVudHJhY2tlZCAtIGFkZCBjb250ZW50cyBvZiB1bnRyYWNrZWQgZmlsZXMgdG8gdGhlIHN0YWdlZCBzZXQgb2YgY2hhbmdlcwpFT0YKfQoKc3ViIG1haW5fbG9vcCB7CglteSBAY21kID0gKFsgJ3N0YXR1cycsIFwmc3RhdHVzX2NtZCwgXSwKCQkgICBbICd1cGRhdGUnLCBcJnVwZGF0ZV9jbWQsIF0sCgkJICAgWyAncmV2ZXJ0JywgXCZyZXZlcnRfY21kLCBdLAoJCSAgIFsgJ2FkZCB1bnRyYWNrZWQnLCBcJmFkZF91bnRyYWNrZWRfY21kLCBdLAoJCSAgIFsgJ3BhdGNoJywgXCZwYXRjaF91cGRhdGVfY21kLCBdLAoJCSAgIFsgJ2RpZmYnLCBcJmRpZmZfY21kLCBdLAoJCSAgIFsgJ3F1aXQnLCBcJnF1aXRfY21kLCBdLAoJCSAgIFsgJ2hlbHAnLCBcJmhlbHBfY21kLCBdLAoJKTsKCXdoaWxlICgxKSB7CgkJbXkgKCRpdCkgPSBsaXN0X2FuZF9jaG9vc2UoeyBQUk9NUFQgPT4gJ1doYXQgbm93JywKCQkJCQkgICAgIFNJTkdMRVRPTiA9PiAxLAoJCQkJCSAgICAgTElTVF9GTEFUID0+IDQsCgkJCQkJICAgICBIRUFERVIgPT4gJyoqKiBDb21tYW5kcyAqKionLAoJCQkJCSAgICAgSU1NRURJQVRFID0+IDEgfSwgQGNtZCk7CgkJaWYgKCRpdCkgewoJCQlldmFsIHsKCQkJCSRpdC0+WzFdLT4oKTsKCQkJfTsKCQkJaWYgKCRAKSB7CgkJCQlwcmludCAiJEAiOwoJCQl9CgkJfQoJfQp9CgpteSBAejsKCnJlZnJlc2goKTsKc3RhdHVzX2NtZCgpOwptYWluX2xvb3AoKTsK",
    "text": "#!/usr/bin/perl -w\n\n\nuse strict;\n\nsub run_cmd_pipe {\n\tmy $fh = undef;\n\topen($fh, '-|', @_) or die;\n\treturn <$fh>;\n}\n\nmy ($GIT_DIR) = run_cmd_pipe(qw(git rev-parse --git-dir));\n\nif (!defined $GIT_DIR) {\n\texit(1); # rev-parse would have already said \"not a git repo\"\n}\nchomp($GIT_DIR);\n\nsub refresh {\n\tmy $fh;\n\topen $fh, '-|', qw(git update-index --refresh)\n\t    or die;\n\twhile (<$fh>) {\n\t\t;# ignore 'needs update'\n\t}\n\tclose $fh;\n}\n\nsub list_untracked {\n\tmap {\n\t\tchomp $_;\n\t\t$_;\n\t}\n\trun_cmd_pipe(qw(git ls-files --others\n\t\t\t--exclude-per-directory=.gitignore),\n\t\t     \"--exclude-from=$GIT_DIR/info/exclude\",\n\t\t     '--', @_);\n}\n\nmy $status_fmt = '%12s %12s %s';\nmy $status_head = sprintf($status_fmt, 'staged', 'unstaged', 'path');\n\n# Returns list of hashes, contents of each of which are:\n# PRINT:\tprint message\n# VALUE:\tpathname\n# BINARY:\tis a binary path\n# INDEX:\tis index different from HEAD?\n# FILE:\t\tis file different from index?\n# INDEX_ADDDEL:\tis it add/delete between HEAD and index?\n# FILE_ADDDEL:\tis it add/delete between index and file?\n\nsub list_modified {\n\tmy ($only) = @_;\n\tmy (%data, @return);\n\tmy ($add, $del, $adddel, $file);\n\n\tfor (run_cmd_pipe(qw(git diff-index --cached\n\t\t\t     --numstat --summary HEAD))) {\n\t\tif (($add, $del, $file) =\n\t\t    /^([-\\d]+)\t([-\\d]+)\t(.*)/) {\n\t\t\tmy ($change, $bin);\n\t\t\tif ($add eq '-' && $del eq '-') {\n\t\t\t\t$change = 'binary';\n\t\t\t\t$bin = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$change = \"+$add/-$del\";\n\t\t\t}\n\t\t\t$data{$file} = {\n\t\t\t\tINDEX => $change,\n\t\t\t\tBINARY => $bin,\n\t\t\t\tFILE => 'nothing',\n\t\t\t}\n\t\t}\n\t\telsif (($adddel, $file) =\n\t\t       /^ (create|delete) mode [0-7]+ (.*)$/) {\n\t\t\t$data{$file}{INDEX_ADDDEL} = $adddel;\n\t\t}\n\t}\n\n\tfor (run_cmd_pipe(qw(git diff-files --numstat --summary))) {\n\t\tif (($add, $del, $file) =\n\t\t    /^([-\\d]+)\t([-\\d]+)\t(.*)/) {\n\t\t\tif (!exists $data{$file}) {\n\t\t\t\t$data{$file} = +{\n\t\t\t\t\tINDEX => 'unchanged',\n\t\t\t\t\tBINARY => 0,\n\t\t\t\t};\n\t\t\t}\n\t\t\tmy ($change, $bin);\n\t\t\tif ($add eq '-' && $del eq '-') {\n\t\t\t\t$change = 'binary';\n\t\t\t\t$bin = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$change = \"+$add/-$del\";\n\t\t\t}\n\t\t\t$data{$file}{FILE} = $change;\n\t\t\tif ($bin) {\n\t\t\t\t$data{$file}{BINARY} = 1;\n\t\t\t}\n\t\t}\n\t\telsif (($adddel, $file) =\n\t\t       /^ (create|delete) mode [0-7]+ (.*)$/) {\n\t\t\t$data{$file}{FILE_ADDDEL} = $adddel;\n\t\t}\n\t}\n\n\tfor (sort keys %data) {\n\t\tmy $it = $data{$_};\n\n\t\tif ($only) {\n\t\t\tif ($only eq 'index-only') {\n\t\t\t\tnext if ($it->{INDEX} eq 'unchanged');\n\t\t\t}\n\t\t\tif ($only eq 'file-only') {\n\t\t\t\tnext if ($it->{FILE} eq 'nothing');\n\t\t\t}\n\t\t}\n\t\tpush @return, +{\n\t\t\tVALUE => $_,\n\t\t\tPRINT => (sprintf $status_fmt,\n\t\t\t\t  $it->{INDEX}, $it->{FILE}, $_),\n\t\t\t%$it,\n\t\t};\n\t}\n\treturn @return;\n}\n\nsub find_unique {\n\tmy ($string, @stuff) = @_;\n\tmy $found = undef;\n\tfor (my $i = 0; $i < @stuff; $i++) {\n\t\tmy $it = $stuff[$i];\n\t\tmy $hit = undef;\n\t\tif (ref $it) {\n\t\t\tif ((ref $it) eq 'ARRAY') {\n\t\t\t\t$it = $it->[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$it = $it->{VALUE};\n\t\t\t}\n\t\t}\n\t\teval {\n\t\t\tif ($it =~ /^$string/) {\n\t\t\t\t$hit = 1;\n\t\t\t};\n\t\t};\n\t\tif (defined $hit && defined $found) {\n\t\t\treturn undef;\n\t\t}\n\t\tif ($hit) {\n\t\t\t$found = $i + 1;\n\t\t}\n\t}\n\treturn $found;\n}\n\nsub list_and_choose {\n\tmy ($opts, @stuff) = @_;\n\tmy (@chosen, @return);\n\tmy $i;\n\n      TOPLOOP:\n\twhile (1) {\n\t\tmy $last_lf = 0;\n\n\t\tif ($opts->{HEADER}) {\n\t\t\tif (!$opts->{LIST_FLAT}) {\n\t\t\t\tprint \"     \";\n\t\t\t}\n\t\t\tprint \"$opts->{HEADER}\\n\";\n\t\t}\n\t\tfor ($i = 0; $i < @stuff; $i++) {\n\t\t\tmy $chosen = $chosen[$i] ? '*' : ' ';\n\t\t\tmy $print = $stuff[$i];\n\t\t\tif (ref $print) {\n\t\t\t\tif ((ref $print) eq 'ARRAY') {\n\t\t\t\t\t$print = $print->[0];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$print = $print->{PRINT};\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%s%2d: %s\", $chosen, $i+1, $print);\n\t\t\tif (($opts->{LIST_FLAT}) &&\n\t\t\t    (($i + 1) % ($opts->{LIST_FLAT}))) {\n\t\t\t\tprint \"\\t\";\n\t\t\t\t$last_lf = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprint \"\\n\";\n\t\t\t\t$last_lf = 1;\n\t\t\t}\n\t\t}\n\t\tif (!$last_lf) {\n\t\t\tprint \"\\n\";\n\t\t}\n\n\t\treturn if ($opts->{LIST_ONLY});\n\n\t\tprint $opts->{PROMPT};\n\t\tif ($opts->{SINGLETON}) {\n\t\t\tprint \"> \";\n\t\t}\n\t\telse {\n\t\t\tprint \">> \";\n\t\t}\n\t\tmy $line = <STDIN>;\n\t\tlast if (!$line);\n\t\tchomp $line;\n\t\tmy $donesomething = 0;\n\t\tfor my $choice (split(/[\\s,]+/, $line)) {\n\t\t\tmy $choose = 1;\n\t\t\tmy ($bottom, $top);\n\n\t\t\t# Input that begins with '-'; unchoose\n\t\t\tif ($choice =~ s/^-//) {\n\t\t\t\t$choose = 0;\n\t\t\t}\n\t\t\t# A range can be specified like 5-7\n\t\t\tif ($choice =~ /^(\\d+)-(\\d+)$/) {\n\t\t\t\t($bottom, $top) = ($1, $2);\n\t\t\t}\n\t\t\telsif ($choice =~ /^\\d+$/) {\n\t\t\t\t$bottom = $top = $choice;\n\t\t\t}\n\t\t\telsif ($choice eq '*') {\n\t\t\t\t$bottom = 1;\n\t\t\t\t$top = 1 + @stuff;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$bottom = $top = find_unique($choice, @stuff);\n\t\t\t\tif (!defined $bottom) {\n\t\t\t\t\tprint \"Huh ($choice)?\\n\";\n\t\t\t\t\tnext TOPLOOP;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($opts->{SINGLETON} && $bottom != $top) {\n\t\t\t\tprint \"Huh ($choice)?\\n\";\n\t\t\t\tnext TOPLOOP;\n\t\t\t}\n\t\t\tfor ($i = $bottom-1; $i <= $top-1; $i++) {\n\t\t\t\tnext if (@stuff <= $i);\n\t\t\t\t$chosen[$i] = $choose;\n\t\t\t\t$donesomething++;\n\t\t\t}\n\t\t}\n\t\tlast if (!$donesomething || $opts->{IMMEDIATE});\n\t}\n\tfor ($i = 0; $i < @stuff; $i++) {\n\t\tif ($chosen[$i]) {\n\t\t\tpush @return, $stuff[$i];\n\t\t}\n\t}\n\treturn @return;\n}\n\nsub status_cmd {\n\tlist_and_choose({ LIST_ONLY => 1, HEADER => $status_head },\n\t\t\tlist_modified());\n\tprint \"\\n\";\n}\n\nsub say_n_paths {\n\tmy $did = shift @_;\n\tmy $cnt = scalar @_;\n\tprint \"$did \";\n\tif (1 < $cnt) {\n\t\tprint \"$cnt paths\\n\";\n\t}\n\telse {\n\t\tprint \"one path\\n\";\n\t}\n}\n\nsub update_cmd {\n\tmy @mods = list_modified('file-only');\n\treturn if (!@mods);\n\n\tmy @update = list_and_choose({ PROMPT => 'Update',\n\t\t\t\t       HEADER => $status_head, },\n\t\t\t\t     @mods);\n\tif (@update) {\n\t\tsystem(qw(git update-index --add --),\n\t\t       map { $_->{VALUE} } @update);\n\t\tsay_n_paths('updated', @update);\n\t}\n\tprint \"\\n\";\n}\n\nsub revert_cmd {\n\tmy @update = list_and_choose({ PROMPT => 'Revert',\n\t\t\t\t       HEADER => $status_head, },\n\t\t\t\t     list_modified());\n\tif (@update) {\n\t\tmy @lines = run_cmd_pipe(qw(git ls-tree HEAD --),\n\t\t\t\t\t map { $_->{VALUE} } @update);\n\t\tmy $fh;\n\t\topen $fh, '|-', qw(git update-index --index-info)\n\t\t    or die;\n\t\tfor (@lines) {\n\t\t\tprint $fh $_;\n\t\t}\n\t\tclose($fh);\n\t\tfor (@update) {\n\t\t\tif ($_->{INDEX_ADDDEL} &&\n\t\t\t    $_->{INDEX_ADDDEL} eq 'create') {\n\t\t\t\tsystem(qw(git update-index --force-remove --),\n\t\t\t\t       $_->{VALUE});\n\t\t\t\tprint \"note: $_->{VALUE} is untracked now.\\n\";\n\t\t\t}\n\t\t}\n\t\trefresh();\n\t\tsay_n_paths('reverted', @update);\n\t}\n\tprint \"\\n\";\n}\n\nsub add_untracked_cmd {\n\tmy @add = list_and_choose({ PROMPT => 'Add untracked' },\n\t\t\t\t  list_untracked());\n\tif (@add) {\n\t\tsystem(qw(git update-index --add --), @add);\n\t\tsay_n_paths('added', @add);\n\t}\n\tprint \"\\n\";\n}\n\nsub parse_diff {\n\tmy ($path) = @_;\n\tmy @diff = run_cmd_pipe(qw(git diff-files -p --), $path);\n\tmy (@hunk) = { TEXT => [] };\n\n\tfor (@diff) {\n\t\tif (/^@@ /) {\n\t\t\tpush @hunk, { TEXT => [] };\n\t\t}\n\t\tpush @{$hunk[-1]{TEXT}}, $_;\n\t}\n\treturn @hunk;\n}\n\nsub hunk_splittable {\n\tmy ($text) = @_;\n\n\tmy @s = split_hunk($text);\n\treturn (1 < @s);\n}\n\nsub parse_hunk_header {\n\tmy ($line) = @_;\n\tmy ($o_ofs, $o_cnt, $n_ofs, $n_cnt) =\n\t    $line =~ /^@@ -(\\d+)(?:,(\\d+)) \\+(\\d+)(?:,(\\d+)) @@/;\n\treturn ($o_ofs, $o_cnt, $n_ofs, $n_cnt);\n}\n\nsub split_hunk {\n\tmy ($text) = @_;\n\tmy @split = ();\n\n\t# If there are context lines in the middle of a hunk,\n\t# it can be split, but we would need to take care of\n\t# overlaps later.\n\n\tmy ($o_ofs, $o_cnt, $n_ofs, $n_cnt) = parse_hunk_header($text->[0]);\n\tmy $hunk_start = 1;\n\tmy $next_hunk_start;\n\n      OUTER:\n\twhile (1) {\n\t\tmy $next_hunk_start = undef;\n\t\tmy $i = $hunk_start - 1;\n\t\tmy $this = +{\n\t\t\tTEXT => [],\n\t\t\tOLD => $o_ofs,\n\t\t\tNEW => $n_ofs,\n\t\t\tOCNT => 0,\n\t\t\tNCNT => 0,\n\t\t\tADDDEL => 0,\n\t\t\tPOSTCTX => 0,\n\t\t};\n\n\t\twhile (++$i < @$text) {\n\t\t\tmy $line = $text->[$i];\n\t\t\tif ($line =~ /^ /) {\n\t\t\t\tif ($this->{ADDDEL} &&\n\t\t\t\t    !defined $next_hunk_start) {\n\t\t\t\t\t# We have seen leading context and\n\t\t\t\t\t# adds/dels and then here is another\n\t\t\t\t\t# context, which is trailing for this\n\t\t\t\t\t# split hunk and leading for the next\n\t\t\t\t\t# one.\n\t\t\t\t\t$next_hunk_start = $i;\n\t\t\t\t}\n\t\t\t\tpush @{$this->{TEXT}}, $line;\n\t\t\t\t$this->{OCNT}++;\n\t\t\t\t$this->{NCNT}++;\n\t\t\t\tif (defined $next_hunk_start) {\n\t\t\t\t\t$this->{POSTCTX}++;\n\t\t\t\t}\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\t# add/del\n\t\t\tif (defined $next_hunk_start) {\n\t\t\t\t# We are done with the current hunk and\n\t\t\t\t# this is the first real change for the\n\t\t\t\t# next split one.\n\t\t\t\t$hunk_start = $next_hunk_start;\n\t\t\t\t$o_ofs = $this->{OLD} + $this->{OCNT};\n\t\t\t\t$n_ofs = $this->{NEW} + $this->{NCNT};\n\t\t\t\t$o_ofs -= $this->{POSTCTX};\n\t\t\t\t$n_ofs -= $this->{POSTCTX};\n\t\t\t\tpush @split, $this;\n\t\t\t\tredo OUTER;\n\t\t\t}\n\t\t\tpush @{$this->{TEXT}}, $line;\n\t\t\t$this->{ADDDEL}++;\n\t\t\tif ($line =~ /^-/) {\n\t\t\t\t$this->{OCNT}++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$this->{NCNT}++;\n\t\t\t}\n\t\t}\n\n\t\tpush @split, $this;\n\t\tlast;\n\t}\n\n\tfor my $hunk (@split) {\n\t\t$o_ofs = $hunk->{OLD};\n\t\t$n_ofs = $hunk->{NEW};\n\t\t$o_cnt = $hunk->{OCNT};\n\t\t$n_cnt = $hunk->{NCNT};\n\n\t\tmy $head = (\"@@ -$o_ofs\" .\n\t\t\t    (($o_cnt != 1) ? \",$o_cnt\" : '') .\n\t\t\t    \" +$n_ofs\" .\n\t\t\t    (($n_cnt != 1) ? \",$n_cnt\" : '') .\n\t\t\t    \" @@\\n\");\n\t\tunshift @{$hunk->{TEXT}}, $head;\n\t}\n\treturn map { $_->{TEXT} } @split;\n}\n\nsub find_last_o_ctx {\n\tmy ($it) = @_;\n\tmy $text = $it->{TEXT};\n\tmy ($o_ofs, $o_cnt, $n_ofs, $n_cnt) = parse_hunk_header($text->[0]);\n\tmy $i = @{$text};\n\tmy $last_o_ctx = $o_ofs + $o_cnt;\n\twhile (0 < --$i) {\n\t\tmy $line = $text->[$i];\n\t\tif ($line =~ /^ /) {\n\t\t\t$last_o_ctx--;\n\t\t\tnext;\n\t\t}\n\t\tlast;\n\t}\n\treturn $last_o_ctx;\n}\n\nsub merge_hunk {\n\tmy ($prev, $this) = @_;\n\tmy ($o0_ofs, $o0_cnt, $n0_ofs, $n0_cnt) =\n\t    parse_hunk_header($prev->{TEXT}[0]);\n\tmy ($o1_ofs, $o1_cnt, $n1_ofs, $n1_cnt) =\n\t    parse_hunk_header($this->{TEXT}[0]);\n\n\tmy (@line, $i, $ofs, $o_cnt, $n_cnt);\n\t$ofs = $o0_ofs;\n\t$o_cnt = $n_cnt = 0;\n\tfor ($i = 1; $i < @{$prev->{TEXT}}; $i++) {\n\t\tmy $line = $prev->{TEXT}[$i];\n\t\tif ($line =~ /^\\+/) {\n\t\t\t$n_cnt++;\n\t\t\tpush @line, $line;\n\t\t\tnext;\n\t\t}\n\n\t\tlast if ($o1_ofs <= $ofs);\n\n\t\t$o_cnt++;\n\t\t$ofs++;\n\t\tif ($line =~ /^ /) {\n\t\t\t$n_cnt++;\n\t\t}\n\t\tpush @line, $line;\n\t}\n\n\tfor ($i = 1; $i < @{$this->{TEXT}}; $i++) {\n\t\tmy $line = $this->{TEXT}[$i];\n\t\tif ($line =~ /^\\+/) {\n\t\t\t$n_cnt++;\n\t\t\tpush @line, $line;\n\t\t\tnext;\n\t\t}\n\t\t$ofs++;\n\t\t$o_cnt++;\n\t\tif ($line =~ /^ /) {\n\t\t\t$n_cnt++;\n\t\t}\n\t\tpush @line, $line;\n\t}\n\tmy $head = (\"@@ -$o0_ofs\" .\n\t\t    (($o_cnt != 1) ? \",$o_cnt\" : '') .\n\t\t    \" +$n0_ofs\" .\n\t\t    (($n_cnt != 1) ? \",$n_cnt\" : '') .\n\t\t    \" @@\\n\");\n\t@{$prev->{TEXT}} = ($head, @line);\n}\n\nsub coalesce_overlapping_hunks {\n\tmy (@in) = @_;\n\tmy @out = ();\n\n\tmy ($last_o_ctx);\n\n\tfor (grep { $_->{USE} } @in) {\n\t\tmy $text = $_->{TEXT};\n\t\tmy ($o_ofs, $o_cnt, $n_ofs, $n_cnt) =\n\t\t    parse_hunk_header($text->[0]);\n\t\tif (defined $last_o_ctx &&\n\t\t    $o_ofs <= $last_o_ctx) {\n\t\t\tmerge_hunk($out[-1], $_);\n\t\t}\n\t\telse {\n\t\t\tpush @out, $_;\n\t\t}\n\t\t$last_o_ctx = find_last_o_ctx($out[-1]);\n\t}\n\treturn @out;\n}\n\nsub help_patch_cmd {\n\tprint <<\\EOF ;\ny - stage this hunk\nn - do not stage this hunk\na - stage this and all the remaining hunks\nd - do not stage this hunk nor any of the remaining hunks\nj - leave this hunk undecided, see next undecided hunk\nJ - leave this hunk undecided, see next hunk\nk - leave this hunk undecided, see previous undecided hunk\nK - leave this hunk undecided, see previous hunk\ns - split the current hunk into smaller hunks\nEOF\n}\n\nsub patch_update_cmd {\n\tmy @mods = list_modified('file-only');\n\t@mods = grep { !($_->{BINARY}) } @mods;\n\treturn if (!@mods);\n\n\tmy ($it) = list_and_choose({ PROMPT => 'Patch update',\n\t\t\t\t     SINGLETON => 1,\n\t\t\t\t     IMMEDIATE => 1,\n\t\t\t\t     HEADER => $status_head, },\n\t\t\t\t   @mods);\n\treturn if (!$it);\n\n\tmy ($ix, $num);\n\tmy $path = $it->{VALUE};\n\tmy ($head, @hunk) = parse_diff($path);\n\tfor (@{$head->{TEXT}}) {\n\t\tprint;\n\t}\n\t$num = scalar @hunk;\n\t$ix = 0;\n\n\twhile (1) {\n\t\tmy ($prev, $next, $other, $undecided, $i);\n\t\t$other = '';\n\n\t\tif ($num <= $ix) {\n\t\t\t$ix = 0;\n\t\t}\n\t\tfor ($i = 0; $i < $ix; $i++) {\n\t\t\tif (!defined $hunk[$i]{USE}) {\n\t\t\t\t$prev = 1;\n\t\t\t\t$other .= '/k';\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t\tif ($ix) {\n\t\t\t$other .= '/K';\n\t\t}\n\t\tfor ($i = $ix + 1; $i < $num; $i++) {\n\t\t\tif (!defined $hunk[$i]{USE}) {\n\t\t\t\t$next = 1;\n\t\t\t\t$other .= '/j';\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t\tif ($ix < $num - 1) {\n\t\t\t$other .= '/J';\n\t\t}\n\t\tfor ($i = 0; $i < $num; $i++) {\n\t\t\tif (!defined $hunk[$i]{USE}) {\n\t\t\t\t$undecided = 1;\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t\tlast if (!$undecided);\n\n\t\tif (hunk_splittable($hunk[$ix]{TEXT})) {\n\t\t\t$other .= '/s';\n\t\t}\n\t\tfor (@{$hunk[$ix]{TEXT}}) {\n\t\t\tprint;\n\t\t}\n\t\tprint \"Stage this hunk [y/n/a/d$other/?]? \";\n\t\tmy $line = <STDIN>;\n\t\tif ($line) {\n\t\t\tif ($line =~ /^y/i) {\n\t\t\t\t$hunk[$ix]{USE} = 1;\n\t\t\t}\n\t\t\telsif ($line =~ /^n/i) {\n\t\t\t\t$hunk[$ix]{USE} = 0;\n\t\t\t}\n\t\t\telsif ($line =~ /^a/i) {\n\t\t\t\twhile ($ix < $num) {\n\t\t\t\t\tif (!defined $hunk[$ix]{USE}) {\n\t\t\t\t\t\t$hunk[$ix]{USE} = 1;\n\t\t\t\t\t}\n\t\t\t\t\t$ix++;\n\t\t\t\t}\n\t\t\t\tnext;\n\t\t\t}\n\t\t\telsif ($line =~ /^d/i) {\n\t\t\t\twhile ($ix < $num) {\n\t\t\t\t\tif (!defined $hunk[$ix]{USE}) {\n\t\t\t\t\t\t$hunk[$ix]{USE} = 0;\n\t\t\t\t\t}\n\t\t\t\t\t$ix++;\n\t\t\t\t}\n\t\t\t\tnext;\n\t\t\t}\n\t\t\telsif ($other =~ /K/ && $line =~ /^K/) {\n\t\t\t\t$ix--;\n\t\t\t\tnext;\n\t\t\t}\n\t\t\telsif ($other =~ /J/ && $line =~ /^J/) {\n\t\t\t\t$ix++;\n\t\t\t\tnext;\n\t\t\t}\n\t\t\telsif ($other =~ /k/ && $line =~ /^k/) {\n\t\t\t\twhile (1) {\n\t\t\t\t\t$ix--;\n\t\t\t\t\tlast if (!$ix ||\n\t\t\t\t\t\t !defined $hunk[$ix]{USE});\n\t\t\t\t}\n\t\t\t\tnext;\n\t\t\t}\n\t\t\telsif ($other =~ /j/ && $line =~ /^j/) {\n\t\t\t\twhile (1) {\n\t\t\t\t\t$ix++;\n\t\t\t\t\tlast if ($ix >= $num ||\n\t\t\t\t\t\t !defined $hunk[$ix]{USE});\n\t\t\t\t}\n\t\t\t\tnext;\n\t\t\t}\n\t\t\telsif ($other =~ /s/ && $line =~ /^s/) {\n\t\t\t\tmy @split = split_hunk($hunk[$ix]{TEXT});\n\t\t\t\tif (1 < @split) {\n\t\t\t\t\tprint \"Split into \",\n\t\t\t\t\tscalar(@split), \" hunks.\\n\";\n\t\t\t\t}\n\t\t\t\tsplice(@hunk, $ix, 1,\n\t\t\t\t       map { +{ TEXT => $_, USE => undef } }\n\t\t\t\t       @split);\n\t\t\t\t$num = scalar @hunk;\n\t\t\t\tnext;\n\t\t\t}\n\t\t\telse {\n\t\t\t\thelp_patch_cmd($other);\n\t\t\t\tnext;\n\t\t\t}\n\t\t\t# soft increment\n\t\t\twhile (1) {\n\t\t\t\t$ix++;\n\t\t\t\tlast if ($ix >= $num ||\n\t\t\t\t\t !defined $hunk[$ix]{USE});\n\t\t\t}\n\t\t}\n\t}\n\n\t@hunk = coalesce_overlapping_hunks(@hunk);\n\n\tmy ($o_lofs, $n_lofs) = (0, 0);\n\tmy @result = ();\n\tfor (@hunk) {\n\t\tmy $text = $_->{TEXT};\n\t\tmy ($o_ofs, $o_cnt, $n_ofs, $n_cnt) =\n\t\t    parse_hunk_header($text->[0]);\n\n\t\tif (!$_->{USE}) {\n\t\t\tif (!defined $o_cnt) { $o_cnt = 1; }\n\t\t\tif (!defined $n_cnt) { $n_cnt = 1; }\n\n\t\t\t# We would have added ($n_cnt - $o_cnt) lines\n\t\t\t# to the postimage if we were to use this hunk,\n\t\t\t# but we didn't.  So the line number that the next\n\t\t\t# hunk starts at would be shifted by that much.\n\t\t\t$n_lofs -= ($n_cnt - $o_cnt);\n\t\t\tnext;\n\t\t}\n\t\telse {\n\t\t\tif ($n_lofs) {\n\t\t\t\t$n_ofs += $n_lofs;\n\t\t\t\t$text->[0] = (\"@@ -$o_ofs\" .\n\t\t\t\t\t      ((defined $o_cnt)\n\t\t\t\t\t       ? \",$o_cnt\" : '') .\n\t\t\t\t\t      \" +$n_ofs\" .\n\t\t\t\t\t      ((defined $n_cnt)\n\t\t\t\t\t       ? \",$n_cnt\" : '') .\n\t\t\t\t\t      \" @@\\n\");\n\t\t\t}\n\t\t\tfor (@$text) {\n\t\t\t\tpush @result, $_;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (@result) {\n\t\tmy $fh;\n\n\t\topen $fh, '|-', qw(git apply --cached);\n\t\tfor (@{$head->{TEXT}}, @result) {\n\t\t\tprint $fh $_;\n\t\t}\n\t\tif (!close $fh) {\n\t\t\tfor (@{$head->{TEXT}}, @result) {\n\t\t\t\tprint STDERR $_;\n\t\t\t}\n\t\t}\n\t\trefresh();\n\t}\n\n\tprint \"\\n\";\n}\n\nsub diff_cmd {\n\tmy @mods = list_modified('index-only');\n\t@mods = grep { !($_->{BINARY}) } @mods;\n\treturn if (!@mods);\n\tmy (@them) = list_and_choose({ PROMPT => 'Review diff',\n\t\t\t\t     IMMEDIATE => 1,\n\t\t\t\t     HEADER => $status_head, },\n\t\t\t\t   @mods);\n\treturn if (!@them);\n\tsystem(qw(git diff-index -p --cached HEAD --),\n\t       map { $_->{VALUE} } @them);\n}\n\nsub quit_cmd {\n\tprint \"Bye.\\n\";\n\texit(0);\n}\n\nsub help_cmd {\n\tprint <<\\EOF ;\nstatus        - show paths with changes\nupdate        - add working tree state to the staged set of changes\nrevert        - revert staged set of changes back to the HEAD version\npatch         - pick hunks and update selectively\ndiff\t      - view diff between HEAD and index\nadd untracked - add contents of untracked files to the staged set of changes\nEOF\n}\n\nsub main_loop {\n\tmy @cmd = ([ 'status', \\&status_cmd, ],\n\t\t   [ 'update', \\&update_cmd, ],\n\t\t   [ 'revert', \\&revert_cmd, ],\n\t\t   [ 'add untracked', \\&add_untracked_cmd, ],\n\t\t   [ 'patch', \\&patch_update_cmd, ],\n\t\t   [ 'diff', \\&diff_cmd, ],\n\t\t   [ 'quit', \\&quit_cmd, ],\n\t\t   [ 'help', \\&help_cmd, ],\n\t);\n\twhile (1) {\n\t\tmy ($it) = list_and_choose({ PROMPT => 'What now',\n\t\t\t\t\t     SINGLETON => 1,\n\t\t\t\t\t     LIST_FLAT => 4,\n\t\t\t\t\t     HEADER => '*** Commands ***',\n\t\t\t\t\t     IMMEDIATE => 1 }, @cmd);\n\t\tif ($it) {\n\t\t\teval {\n\t\t\t\t$it->[1]->();\n\t\t\t};\n\t\t\tif ($@) {\n\t\t\t\tprint \"$@\";\n\t\t\t}\n\t\t}\n\t}\n}\n\nmy @z;\n\nrefresh();\nstatus_cmd();\nmain_loop();\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0057f865886753afb9493a2e82b11fe14aa91529",
  "sha1_ok": true,
  "size": 16242
}
