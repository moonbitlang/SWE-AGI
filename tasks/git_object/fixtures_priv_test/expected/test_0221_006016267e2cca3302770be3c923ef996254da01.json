{
  "content": {
    "base64": "LyoKICogImdpdCBhZGQiIGJ1aWx0aW4gY29tbWFuZAogKgogKiBDb3B5cmlnaHQgKEMpIDIwMDYgTGludXMgVG9ydmFsZHMKICovCiNkZWZpbmUgVVNFX1RIRV9JTkRFWF9DT01QQVRJQklMSVRZX01BQ1JPUwojaW5jbHVkZSAiY2FjaGUuaCIKI2luY2x1ZGUgImNvbmZpZy5oIgojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAibG9ja2ZpbGUuaCIKI2luY2x1ZGUgImRpci5oIgojaW5jbHVkZSAicGF0aHNwZWMuaCIKI2luY2x1ZGUgImV4ZWMtY21kLmgiCiNpbmNsdWRlICJjYWNoZS10cmVlLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAiZGlmZmNvcmUuaCIKI2luY2x1ZGUgInJldmlzaW9uLmgiCiNpbmNsdWRlICJidWxrLWNoZWNraW4uaCIKI2luY2x1ZGUgImFyZ3YtYXJyYXkuaCIKI2luY2x1ZGUgInN1Ym1vZHVsZS5oIgojaW5jbHVkZSAiYWRkLWludGVyYWN0aXZlLmgiCgpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGJ1aWx0aW5fYWRkX3VzYWdlW10gPSB7CglOXygiZ2l0IGFkZCBbPG9wdGlvbnM+XSBbLS1dIDxwYXRoc3BlYz4uLi4iKSwKCU5VTEwKfTsKc3RhdGljIGludCBwYXRjaF9pbnRlcmFjdGl2ZSwgYWRkX2ludGVyYWN0aXZlLCBlZGl0X2ludGVyYWN0aXZlOwpzdGF0aWMgaW50IHRha2Vfd29ya3RyZWVfY2hhbmdlczsKc3RhdGljIGludCBhZGRfcmVub3JtYWxpemU7CgpzdHJ1Y3QgdXBkYXRlX2NhbGxiYWNrX2RhdGEgewoJaW50IGZsYWdzOwoJaW50IGFkZF9lcnJvcnM7Cn07CgpzdGF0aWMgdm9pZCBjaG1vZF9wYXRoc3BlYyhzdHJ1Y3QgcGF0aHNwZWMgKnBhdGhzcGVjLCBjaGFyIGZsaXApCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBhY3RpdmVfbnI7IGkrKykgewoJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBhY3RpdmVfY2FjaGVbaV07CgoJCWlmIChwYXRoc3BlYyAmJiAhY2VfcGF0aF9tYXRjaCgmdGhlX2luZGV4LCBjZSwgcGF0aHNwZWMsIE5VTEwpKQoJCQljb250aW51ZTsKCgkJaWYgKGNobW9kX2NhY2hlX2VudHJ5KGNlLCBmbGlwKSA8IDApCgkJCWZwcmludGYoc3RkZXJyLCAiY2Fubm90IGNobW9kICVjeCAnJXMnXG4iLCBmbGlwLCBjZS0+bmFtZSk7Cgl9Cn0KCnN0YXRpYyBpbnQgZml4X3VubWVyZ2VkX3N0YXR1cyhzdHJ1Y3QgZGlmZl9maWxlcGFpciAqcCwKCQkJICAgICAgIHN0cnVjdCB1cGRhdGVfY2FsbGJhY2tfZGF0YSAqZGF0YSkKewoJaWYgKHAtPnN0YXR1cyAhPSBESUZGX1NUQVRVU19VTk1FUkdFRCkKCQlyZXR1cm4gcC0+c3RhdHVzOwoJaWYgKCEoZGF0YS0+ZmxhZ3MgJiBBRERfQ0FDSEVfSUdOT1JFX1JFTU9WQUwpICYmICFwLT50d28tPm1vZGUpCgkJLyoKCQkgKiBUaGlzIGlzIG5vdCBhbiBleHBsaWNpdCBhZGQgcmVxdWVzdCwgYW5kIHRoZQoJCSAqIHBhdGggaXMgbWlzc2luZyBmcm9tIHRoZSB3b3JraW5nIHRyZWUgKGRlbGV0ZWQpCgkJICovCgkJcmV0dXJuIERJRkZfU1RBVFVTX0RFTEVURUQ7CgllbHNlCgkJLyoKCQkgKiBFaXRoZXIgYW4gZXhwbGljaXQgYWRkIHJlcXVlc3QsIG9yIHBhdGggZXhpc3RzCgkJICogaW4gdGhlIHdvcmtpbmcgdHJlZS4gIEFuIGF0dGVtcHQgdG8gZXhwbGljaXRseQoJCSAqIGFkZCBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgd29ya2luZyB0cmVlCgkJICogd2lsbCBiZSBjYXVnaHQgYXMgYW4gZXJyb3IgYnkgdGhlIGNhbGxlciBpbW1lZGlhdGVseS4KCQkgKi8KCQlyZXR1cm4gRElGRl9TVEFUVVNfTU9ESUZJRUQ7Cn0KCnN0YXRpYyB2b2lkIHVwZGF0ZV9jYWxsYmFjayhzdHJ1Y3QgZGlmZl9xdWV1ZV9zdHJ1Y3QgKnEsCgkJCSAgICBzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHQsIHZvaWQgKmNiZGF0YSkKewoJaW50IGk7CglzdHJ1Y3QgdXBkYXRlX2NhbGxiYWNrX2RhdGEgKmRhdGEgPSBjYmRhdGE7CgoJZm9yIChpID0gMDsgaSA8IHEtPm5yOyBpKyspIHsKCQlzdHJ1Y3QgZGlmZl9maWxlcGFpciAqcCA9IHEtPnF1ZXVlW2ldOwoJCWNvbnN0IGNoYXIgKnBhdGggPSBwLT5vbmUtPnBhdGg7CgkJc3dpdGNoIChmaXhfdW5tZXJnZWRfc3RhdHVzKHAsIGRhdGEpKSB7CgkJZGVmYXVsdDoKCQkJZGllKF8oInVuZXhwZWN0ZWQgZGlmZiBzdGF0dXMgJWMiKSwgcC0+c3RhdHVzKTsKCQljYXNlIERJRkZfU1RBVFVTX01PRElGSUVEOgoJCWNhc2UgRElGRl9TVEFUVVNfVFlQRV9DSEFOR0VEOgoJCQlpZiAoYWRkX2ZpbGVfdG9faW5kZXgoJnRoZV9pbmRleCwgcGF0aCwJZGF0YS0+ZmxhZ3MpKSB7CgkJCQlpZiAoIShkYXRhLT5mbGFncyAmIEFERF9DQUNIRV9JR05PUkVfRVJST1JTKSkKCQkJCQlkaWUoXygidXBkYXRpbmcgZmlsZXMgZmFpbGVkIikpOwoJCQkJZGF0YS0+YWRkX2Vycm9ycysrOwoJCQl9CgkJCWJyZWFrOwoJCWNhc2UgRElGRl9TVEFUVVNfREVMRVRFRDoKCQkJaWYgKGRhdGEtPmZsYWdzICYgQUREX0NBQ0hFX0lHTk9SRV9SRU1PVkFMKQoJCQkJYnJlYWs7CgkJCWlmICghKGRhdGEtPmZsYWdzICYgQUREX0NBQ0hFX1BSRVRFTkQpKQoJCQkJcmVtb3ZlX2ZpbGVfZnJvbV9pbmRleCgmdGhlX2luZGV4LCBwYXRoKTsKCQkJaWYgKGRhdGEtPmZsYWdzICYgKEFERF9DQUNIRV9QUkVURU5EfEFERF9DQUNIRV9WRVJCT1NFKSkKCQkJCXByaW50ZihfKCJyZW1vdmUgJyVzJ1xuIiksIHBhdGgpOwoJCQlicmVhazsKCQl9Cgl9Cn0KCmludCBhZGRfZmlsZXNfdG9fY2FjaGUoY29uc3QgY2hhciAqcHJlZml4LAoJCSAgICAgICBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBhdGhzcGVjLCBpbnQgZmxhZ3MpCnsKCXN0cnVjdCB1cGRhdGVfY2FsbGJhY2tfZGF0YSBkYXRhOwoJc3RydWN0IHJldl9pbmZvIHJldjsKCgltZW1zZXQoJmRhdGEsIDAsIHNpemVvZihkYXRhKSk7CglkYXRhLmZsYWdzID0gZmxhZ3M7CgoJcmVwb19pbml0X3JldmlzaW9ucyh0aGVfcmVwb3NpdG9yeSwgJnJldiwgcHJlZml4KTsKCXNldHVwX3JldmlzaW9ucygwLCBOVUxMLCAmcmV2LCBOVUxMKTsKCWlmIChwYXRoc3BlYykKCQljb3B5X3BhdGhzcGVjKCZyZXYucHJ1bmVfZGF0YSwgcGF0aHNwZWMpOwoJcmV2LmRpZmZvcHQub3V0cHV0X2Zvcm1hdCA9IERJRkZfRk9STUFUX0NBTExCQUNLOwoJcmV2LmRpZmZvcHQuZm9ybWF0X2NhbGxiYWNrID0gdXBkYXRlX2NhbGxiYWNrOwoJcmV2LmRpZmZvcHQuZm9ybWF0X2NhbGxiYWNrX2RhdGEgPSAmZGF0YTsKCXJldi5kaWZmb3B0LmZsYWdzLm92ZXJyaWRlX3N1Ym1vZHVsZV9jb25maWcgPSAxOwoJcmV2Lm1heF9jb3VudCA9IDA7IC8qIGRvIG5vdCBjb21wYXJlIHVubWVyZ2VkIHBhdGhzIHdpdGggc3RhZ2UgIzIgKi8KCXJ1bl9kaWZmX2ZpbGVzKCZyZXYsIERJRkZfUkFDWV9JU19NT0RJRklFRCk7CgljbGVhcl9wYXRoc3BlYygmcmV2LnBydW5lX2RhdGEpOwoJcmV0dXJuICEhZGF0YS5hZGRfZXJyb3JzOwp9CgpzdGF0aWMgaW50IHJlbm9ybWFsaXplX3RyYWNrZWRfZmlsZXMoY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwYXRoc3BlYywgaW50IGZsYWdzKQp7CglpbnQgaSwgcmV0dmFsID0gMDsKCglmb3IgKGkgPSAwOyBpIDwgYWN0aXZlX25yOyBpKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gYWN0aXZlX2NhY2hlW2ldOwoKCQlpZiAoY2Vfc3RhZ2UoY2UpKQoJCQljb250aW51ZTsgLyogZG8gbm90IHRvdWNoIHVubWVyZ2VkIHBhdGhzICovCgkJaWYgKCFTX0lTUkVHKGNlLT5jZV9tb2RlKSAmJiAhU19JU0xOSyhjZS0+Y2VfbW9kZSkpCgkJCWNvbnRpbnVlOyAvKiBkbyBub3QgdG91Y2ggbm9uIGJsb2JzICovCgkJaWYgKHBhdGhzcGVjICYmICFjZV9wYXRoX21hdGNoKCZ0aGVfaW5kZXgsIGNlLCBwYXRoc3BlYywgTlVMTCkpCgkJCWNvbnRpbnVlOwoJCXJldHZhbCB8PSBhZGRfZmlsZV90b19jYWNoZShjZS0+bmFtZSwgZmxhZ3MgfCBBRERfQ0FDSEVfUkVOT1JNQUxJWkUpOwoJfQoKCXJldHVybiByZXR2YWw7Cn0KCnN0YXRpYyBjaGFyICpwcnVuZV9kaXJlY3Rvcnkoc3RydWN0IGRpcl9zdHJ1Y3QgKmRpciwgc3RydWN0IHBhdGhzcGVjICpwYXRoc3BlYywgaW50IHByZWZpeCkKewoJY2hhciAqc2VlbjsKCWludCBpOwoJc3RydWN0IGRpcl9lbnRyeSAqKnNyYywgKipkc3Q7CgoJc2VlbiA9IHhjYWxsb2MocGF0aHNwZWMtPm5yLCAxKTsKCglzcmMgPSBkc3QgPSBkaXItPmVudHJpZXM7CglpID0gZGlyLT5ucjsKCXdoaWxlICgtLWkgPj0gMCkgewoJCXN0cnVjdCBkaXJfZW50cnkgKmVudHJ5ID0gKnNyYysrOwoJCWlmIChkaXJfcGF0aF9tYXRjaCgmdGhlX2luZGV4LCBlbnRyeSwgcGF0aHNwZWMsIHByZWZpeCwgc2VlbikpCgkJCSpkc3QrKyA9IGVudHJ5OwoJfQoJZGlyLT5uciA9IGRzdCAtIGRpci0+ZW50cmllczsKCWFkZF9wYXRoc3BlY19tYXRjaGVzX2FnYWluc3RfaW5kZXgocGF0aHNwZWMsICZ0aGVfaW5kZXgsIHNlZW4pOwoJcmV0dXJuIHNlZW47Cn0KCnN0YXRpYyB2b2lkIHJlZnJlc2goaW50IHZlcmJvc2UsIGNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcGF0aHNwZWMpCnsKCWNoYXIgKnNlZW47CglpbnQgaTsKCglzZWVuID0geGNhbGxvYyhwYXRoc3BlYy0+bnIsIDEpOwoJcmVmcmVzaF9pbmRleCgmdGhlX2luZGV4LCB2ZXJib3NlID8gUkVGUkVTSF9JTl9QT1JDRUxBSU4gOiBSRUZSRVNIX1FVSUVULAoJCSAgICAgIHBhdGhzcGVjLCBzZWVuLCBfKCJVbnN0YWdlZCBjaGFuZ2VzIGFmdGVyIHJlZnJlc2hpbmcgdGhlIGluZGV4OiIpKTsKCWZvciAoaSA9IDA7IGkgPCBwYXRoc3BlYy0+bnI7IGkrKykgewoJCWlmICghc2VlbltpXSkKCQkJZGllKF8oInBhdGhzcGVjICclcycgZGlkIG5vdCBtYXRjaCBhbnkgZmlsZXMiKSwKCQkJICAgIHBhdGhzcGVjLT5pdGVtc1tpXS5tYXRjaCk7Cgl9CglmcmVlKHNlZW4pOwp9CgppbnQgcnVuX2FkZF9pbnRlcmFjdGl2ZShjb25zdCBjaGFyICpyZXZpc2lvbiwgY29uc3QgY2hhciAqcGF0Y2hfbW9kZSwKCQkJY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwYXRoc3BlYykKewoJaW50IHN0YXR1cywgaTsKCXN0cnVjdCBhcmd2X2FycmF5IGFyZ3YgPSBBUkdWX0FSUkFZX0lOSVQ7CglpbnQgdXNlX2J1aWx0aW5fYWRkX2kgPQoJCWdpdF9lbnZfYm9vbCgiR0lUX1RFU1RfQUREX0lfVVNFX0JVSUxUSU4iLCAtMSk7CgoJaWYgKHVzZV9idWlsdGluX2FkZF9pIDwgMCkKCQlnaXRfY29uZmlnX2dldF9ib29sKCJhZGQuaW50ZXJhY3RpdmUudXNlYnVpbHRpbiIsCgkJCQkgICAgJnVzZV9idWlsdGluX2FkZF9pKTsKCglpZiAodXNlX2J1aWx0aW5fYWRkX2kgPT0gMSkgewoJCWVudW0gYWRkX3BfbW9kZSBtb2RlOwoKCQlpZiAoIXBhdGNoX21vZGUpCgkJCXJldHVybiAhIXJ1bl9hZGRfaSh0aGVfcmVwb3NpdG9yeSwgcGF0aHNwZWMpOwoKCQlpZiAoIXN0cmNtcChwYXRjaF9tb2RlLCAiLS1wYXRjaCIpKQoJCQltb2RlID0gQUREX1BfQUREOwoJCWVsc2UKCQkJZGllKCInJXMnIG5vdCB5ZXQgc3VwcG9ydGVkIGluIHRoZSBidWlsdC1pbiBhZGQgLXAiLAoJCQkgICAgcGF0Y2hfbW9kZSk7CgoJCXJldHVybiAhIXJ1bl9hZGRfcCh0aGVfcmVwb3NpdG9yeSwgbW9kZSwgcmV2aXNpb24sIHBhdGhzcGVjKTsKCX0KCglhcmd2X2FycmF5X3B1c2goJmFyZ3YsICJhZGQtLWludGVyYWN0aXZlIik7CglpZiAocGF0Y2hfbW9kZSkKCQlhcmd2X2FycmF5X3B1c2goJmFyZ3YsIHBhdGNoX21vZGUpOwoJaWYgKHJldmlzaW9uKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJndiwgcmV2aXNpb24pOwoJYXJndl9hcnJheV9wdXNoKCZhcmd2LCAiLS0iKTsKCWZvciAoaSA9IDA7IGkgPCBwYXRoc3BlYy0+bnI7IGkrKykKCQkvKiBwYXNzIG9yaWdpbmFsIHBhdGhzcGVjLCB0byBiZSByZS1wYXJzZWQgKi8KCQlhcmd2X2FycmF5X3B1c2goJmFyZ3YsIHBhdGhzcGVjLT5pdGVtc1tpXS5vcmlnaW5hbCk7CgoJc3RhdHVzID0gcnVuX2NvbW1hbmRfdl9vcHQoYXJndi5hcmd2LCBSVU5fR0lUX0NNRCk7Cglhcmd2X2FycmF5X2NsZWFyKCZhcmd2KTsKCXJldHVybiBzdGF0dXM7Cn0KCmludCBpbnRlcmFjdGl2ZV9hZGQoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgsIGludCBwYXRjaCkKewoJc3RydWN0IHBhdGhzcGVjIHBhdGhzcGVjOwoKCXBhcnNlX3BhdGhzcGVjKCZwYXRoc3BlYywgMCwKCQkgICAgICAgUEFUSFNQRUNfUFJFRkVSX0ZVTEwgfAoJCSAgICAgICBQQVRIU1BFQ19TWU1MSU5LX0xFQURJTkdfUEFUSCB8CgkJICAgICAgIFBBVEhTUEVDX1BSRUZJWF9PUklHSU4sCgkJICAgICAgIHByZWZpeCwgYXJndik7CgoJcmV0dXJuIHJ1bl9hZGRfaW50ZXJhY3RpdmUoTlVMTCwKCQkJCSAgIHBhdGNoID8gIi0tcGF0Y2giIDogTlVMTCwKCQkJCSAgICZwYXRoc3BlYyk7Cn0KCnN0YXRpYyBpbnQgZWRpdF9wYXRjaChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJY2hhciAqZmlsZSA9IGdpdF9wYXRoZHVwKCJBRERfRURJVC5wYXRjaCIpOwoJY29uc3QgY2hhciAqYXBwbHlfYXJndltdID0geyAiYXBwbHkiLCAiLS1yZWNvdW50IiwgIi0tY2FjaGVkIiwKCQlOVUxMLCBOVUxMIH07CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBjaGlsZCA9IENISUxEX1BST0NFU1NfSU5JVDsKCXN0cnVjdCByZXZfaW5mbyByZXY7CglpbnQgb3V0OwoJc3RydWN0IHN0YXQgc3Q7CgoJYXBwbHlfYXJndlszXSA9IGZpbGU7CgoJZ2l0X2NvbmZpZyhnaXRfZGlmZl9iYXNpY19jb25maWcsIE5VTEwpOyAvKiBubyAiZGlmZiIgVUkgb3B0aW9ucyAqLwoKCWlmIChyZWFkX2NhY2hlKCkgPCAwKQoJCWRpZShfKCJDb3VsZCBub3QgcmVhZCB0aGUgaW5kZXgiKSk7CgoJcmVwb19pbml0X3JldmlzaW9ucyh0aGVfcmVwb3NpdG9yeSwgJnJldiwgcHJlZml4KTsKCXJldi5kaWZmb3B0LmNvbnRleHQgPSA3OwoKCWFyZ2MgPSBzZXR1cF9yZXZpc2lvbnMoYXJnYywgYXJndiwgJnJldiwgTlVMTCk7CglyZXYuZGlmZm9wdC5vdXRwdXRfZm9ybWF0ID0gRElGRl9GT1JNQVRfUEFUQ0g7CglyZXYuZGlmZm9wdC51c2VfY29sb3IgPSAwOwoJcmV2LmRpZmZvcHQuZmxhZ3MuaWdub3JlX2RpcnR5X3N1Ym1vZHVsZXMgPSAxOwoJb3V0ID0gb3BlbihmaWxlLCBPX0NSRUFUIHwgT19XUk9OTFkgfCBPX1RSVU5DLCAwNjY2KTsKCWlmIChvdXQgPCAwKQoJCWRpZShfKCJDb3VsZCBub3Qgb3BlbiAnJXMnIGZvciB3cml0aW5nLiIpLCBmaWxlKTsKCXJldi5kaWZmb3B0LmZpbGUgPSB4ZmRvcGVuKG91dCwgInciKTsKCXJldi5kaWZmb3B0LmNsb3NlX2ZpbGUgPSAxOwoJaWYgKHJ1bl9kaWZmX2ZpbGVzKCZyZXYsIDApKQoJCWRpZShfKCJDb3VsZCBub3Qgd3JpdGUgcGF0Y2giKSk7CgoJaWYgKGxhdW5jaF9lZGl0b3IoZmlsZSwgTlVMTCwgTlVMTCkpCgkJZGllKF8oImVkaXRpbmcgcGF0Y2ggZmFpbGVkIikpOwoKCWlmIChzdGF0KGZpbGUsICZzdCkpCgkJZGllX2Vycm5vKF8oIkNvdWxkIG5vdCBzdGF0ICclcyciKSwgZmlsZSk7CglpZiAoIXN0LnN0X3NpemUpCgkJZGllKF8oIkVtcHR5IHBhdGNoLiBBYm9ydGVkLiIpKTsKCgljaGlsZC5naXRfY21kID0gMTsKCWNoaWxkLmFyZ3YgPSBhcHBseV9hcmd2OwoJaWYgKHJ1bl9jb21tYW5kKCZjaGlsZCkpCgkJZGllKF8oIkNvdWxkIG5vdCBhcHBseSAnJXMnIiksIGZpbGUpOwoKCXVubGluayhmaWxlKTsKCWZyZWUoZmlsZSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGNvbnN0IGNoYXIgaWdub3JlX2Vycm9yW10gPQpOXygiVGhlIGZvbGxvd2luZyBwYXRocyBhcmUgaWdub3JlZCBieSBvbmUgb2YgeW91ciAuZ2l0aWdub3JlIGZpbGVzOlxuIik7CgpzdGF0aWMgaW50IHZlcmJvc2UsIHNob3dfb25seSwgaWdub3JlZF90b28sIHJlZnJlc2hfb25seTsKc3RhdGljIGludCBpZ25vcmVfYWRkX2Vycm9ycywgaW50ZW50X3RvX2FkZCwgaWdub3JlX21pc3Npbmc7CnN0YXRpYyBpbnQgd2Fybl9vbl9lbWJlZGRlZF9yZXBvID0gMTsKCiNkZWZpbmUgQUREUkVNT1ZFX0RFRkFVTFQgMQpzdGF0aWMgaW50IGFkZHJlbW92ZSA9IEFERFJFTU9WRV9ERUZBVUxUOwpzdGF0aWMgaW50IGFkZHJlbW92ZV9leHBsaWNpdCA9IC0xOyAvKiB1bnNwZWNpZmllZCAqLwoKc3RhdGljIGNoYXIgKmNobW9kX2FyZzsKCnN0YXRpYyBpbnQgaWdub3JlX3JlbW92YWxfY2IoY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJLyogaWYgd2UgYXJlIHRvbGQgdG8gaWdub3JlLCB3ZSBhcmUgbm90IGFkZGluZyByZW1vdmFscyAqLwoJKihpbnQgKilvcHQtPnZhbHVlID0gIXVuc2V0ID8gMCA6IDE7CglyZXR1cm4gMDsKfQoKc3RhdGljIHN0cnVjdCBvcHRpb24gYnVpbHRpbl9hZGRfb3B0aW9uc1tdID0gewoJT1BUX19EUllfUlVOKCZzaG93X29ubHksIE5fKCJkcnkgcnVuIikpLAoJT1BUX19WRVJCT1NFKCZ2ZXJib3NlLCBOXygiYmUgdmVyYm9zZSIpKSwKCU9QVF9HUk9VUCgiIiksCglPUFRfQk9PTCgnaScsICJpbnRlcmFjdGl2ZSIsICZhZGRfaW50ZXJhY3RpdmUsIE5fKCJpbnRlcmFjdGl2ZSBwaWNraW5nIikpLAoJT1BUX0JPT0woJ3AnLCAicGF0Y2giLCAmcGF0Y2hfaW50ZXJhY3RpdmUsIE5fKCJzZWxlY3QgaHVua3MgaW50ZXJhY3RpdmVseSIpKSwKCU9QVF9CT09MKCdlJywgImVkaXQiLCAmZWRpdF9pbnRlcmFjdGl2ZSwgTl8oImVkaXQgY3VycmVudCBkaWZmIGFuZCBhcHBseSIpKSwKCU9QVF9fRk9SQ0UoJmlnbm9yZWRfdG9vLCBOXygiYWxsb3cgYWRkaW5nIG90aGVyd2lzZSBpZ25vcmVkIGZpbGVzIiksIDApLAoJT1BUX0JPT0woJ3UnLCAidXBkYXRlIiwgJnRha2Vfd29ya3RyZWVfY2hhbmdlcywgTl8oInVwZGF0ZSB0cmFja2VkIGZpbGVzIikpLAoJT1BUX0JPT0woMCwgInJlbm9ybWFsaXplIiwgJmFkZF9yZW5vcm1hbGl6ZSwgTl8oInJlbm9ybWFsaXplIEVPTCBvZiB0cmFja2VkIGZpbGVzIChpbXBsaWVzIC11KSIpKSwKCU9QVF9CT09MKCdOJywgImludGVudC10by1hZGQiLCAmaW50ZW50X3RvX2FkZCwgTl8oInJlY29yZCBvbmx5IHRoZSBmYWN0IHRoYXQgdGhlIHBhdGggd2lsbCBiZSBhZGRlZCBsYXRlciIpKSwKCU9QVF9CT09MKCdBJywgImFsbCIsICZhZGRyZW1vdmVfZXhwbGljaXQsIE5fKCJhZGQgY2hhbmdlcyBmcm9tIGFsbCB0cmFja2VkIGFuZCB1bnRyYWNrZWQgZmlsZXMiKSksCgl7IE9QVElPTl9DQUxMQkFDSywgMCwgImlnbm9yZS1yZW1vdmFsIiwgJmFkZHJlbW92ZV9leHBsaWNpdCwKCSAgTlVMTCAvKiB0YWtlcyBubyBhcmd1bWVudHMgKi8sCgkgIE5fKCJpZ25vcmUgcGF0aHMgcmVtb3ZlZCBpbiB0aGUgd29ya2luZyB0cmVlIChzYW1lIGFzIC0tbm8tYWxsKSIpLAoJICBQQVJTRV9PUFRfTk9BUkcsIGlnbm9yZV9yZW1vdmFsX2NiIH0sCglPUFRfQk9PTCggMCAsICJyZWZyZXNoIiwgJnJlZnJlc2hfb25seSwgTl8oImRvbid0IGFkZCwgb25seSByZWZyZXNoIHRoZSBpbmRleCIpKSwKCU9QVF9CT09MKCAwICwgImlnbm9yZS1lcnJvcnMiLCAmaWdub3JlX2FkZF9lcnJvcnMsIE5fKCJqdXN0IHNraXAgZmlsZXMgd2hpY2ggY2Fubm90IGJlIGFkZGVkIGJlY2F1c2Ugb2YgZXJyb3JzIikpLAoJT1BUX0JPT0woIDAgLCAiaWdub3JlLW1pc3NpbmciLCAmaWdub3JlX21pc3NpbmcsIE5fKCJjaGVjayBpZiAtIGV2ZW4gbWlzc2luZyAtIGZpbGVzIGFyZSBpZ25vcmVkIGluIGRyeSBydW4iKSksCglPUFRfU1RSSU5HKDAsICJjaG1vZCIsICZjaG1vZF9hcmcsICIoK3wtKXgiLAoJCSAgIE5fKCJvdmVycmlkZSB0aGUgZXhlY3V0YWJsZSBiaXQgb2YgdGhlIGxpc3RlZCBmaWxlcyIpKSwKCU9QVF9ISURERU5fQk9PTCgwLCAid2Fybi1lbWJlZGRlZC1yZXBvIiwgJndhcm5fb25fZW1iZWRkZWRfcmVwbywKCQkJTl8oIndhcm4gd2hlbiBhZGRpbmcgYW4gZW1iZWRkZWQgcmVwb3NpdG9yeSIpKSwKCU9QVF9FTkQoKSwKfTsKCnN0YXRpYyBpbnQgYWRkX2NvbmZpZyhjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlLCB2b2lkICpjYikKewoJaWYgKCFzdHJjbXAodmFyLCAiYWRkLmlnbm9yZWVycm9ycyIpIHx8CgkgICAgIXN0cmNtcCh2YXIsICJhZGQuaWdub3JlLWVycm9ycyIpKSB7CgkJaWdub3JlX2FkZF9lcnJvcnMgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CgoJcmV0dXJuIGdpdF9kZWZhdWx0X2NvbmZpZyh2YXIsIHZhbHVlLCBjYik7Cn0KCnN0YXRpYyBjb25zdCBjaGFyIGVtYmVkZGVkX2FkdmljZVtdID0gTl8oCiJZb3UndmUgYWRkZWQgYW5vdGhlciBnaXQgcmVwb3NpdG9yeSBpbnNpZGUgeW91ciBjdXJyZW50IHJlcG9zaXRvcnkuXG4iCiJDbG9uZXMgb2YgdGhlIG91dGVyIHJlcG9zaXRvcnkgd2lsbCBub3QgY29udGFpbiB0aGUgY29udGVudHMgb2ZcbiIKInRoZSBlbWJlZGRlZCByZXBvc2l0b3J5IGFuZCB3aWxsIG5vdCBrbm93IGhvdyB0byBvYnRhaW4gaXQuXG4iCiJJZiB5b3UgbWVhbnQgdG8gYWRkIGEgc3VibW9kdWxlLCB1c2U6XG4iCiJcbiIKIglnaXQgc3VibW9kdWxlIGFkZCA8dXJsPiAlc1xuIgoiXG4iCiJJZiB5b3UgYWRkZWQgdGhpcyBwYXRoIGJ5IG1pc3Rha2UsIHlvdSBjYW4gcmVtb3ZlIGl0IGZyb20gdGhlXG4iCiJpbmRleCB3aXRoOlxuIgoiXG4iCiIJZ2l0IHJtIC0tY2FjaGVkICVzXG4iCiJcbiIKIlNlZSBcImdpdCBoZWxwIHN1Ym1vZHVsZVwiIGZvciBtb3JlIGluZm9ybWF0aW9uLiIKKTsKCnN0YXRpYyB2b2lkIGNoZWNrX2VtYmVkZGVkX3JlcG8oY29uc3QgY2hhciAqcGF0aCkKewoJc3RydWN0IHN0cmJ1ZiBuYW1lID0gU1RSQlVGX0lOSVQ7CgoJaWYgKCF3YXJuX29uX2VtYmVkZGVkX3JlcG8pCgkJcmV0dXJuOwoJaWYgKCFlbmRzX3dpdGgocGF0aCwgIi8iKSkKCQlyZXR1cm47CgoJLyogRHJvcCB0cmFpbGluZyBzbGFzaCBmb3IgYWVzdGhldGljcyAqLwoJc3RyYnVmX2FkZHN0cigmbmFtZSwgcGF0aCk7CglzdHJidWZfc3RyaXBfc3VmZml4KCZuYW1lLCAiLyIpOwoKCXdhcm5pbmcoXygiYWRkaW5nIGVtYmVkZGVkIGdpdCByZXBvc2l0b3J5OiAlcyIpLCBuYW1lLmJ1Zik7CglpZiAoYWR2aWNlX2FkZF9lbWJlZGRlZF9yZXBvKSB7CgkJYWR2aXNlKGVtYmVkZGVkX2FkdmljZSwgbmFtZS5idWYsIG5hbWUuYnVmKTsKCQkvKiB0aGVyZSBtYXkgYmUgbXVsdGlwbGUgZW50cmllczsgYWR2aXNlIG9ubHkgb25jZSAqLwoJCWFkdmljZV9hZGRfZW1iZWRkZWRfcmVwbyA9IDA7Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJm5hbWUpOwp9CgpzdGF0aWMgaW50IGFkZF9maWxlcyhzdHJ1Y3QgZGlyX3N0cnVjdCAqZGlyLCBpbnQgZmxhZ3MpCnsKCWludCBpLCBleGl0X3N0YXR1cyA9IDA7CgoJaWYgKGRpci0+aWdub3JlZF9ucikgewoJCWZwcmludGYoc3RkZXJyLCBfKGlnbm9yZV9lcnJvcikpOwoJCWZvciAoaSA9IDA7IGkgPCBkaXItPmlnbm9yZWRfbnI7IGkrKykKCQkJZnByaW50ZihzdGRlcnIsICIlc1xuIiwgZGlyLT5pZ25vcmVkW2ldLT5uYW1lKTsKCQlmcHJpbnRmKHN0ZGVyciwgXygiVXNlIC1mIGlmIHlvdSByZWFsbHkgd2FudCB0byBhZGQgdGhlbS5cbiIpKTsKCQlleGl0X3N0YXR1cyA9IDE7Cgl9CgoJZm9yIChpID0gMDsgaSA8IGRpci0+bnI7IGkrKykgewoJCWlmIChhZGRfZmlsZV90b19pbmRleCgmdGhlX2luZGV4LCBkaXItPmVudHJpZXNbaV0tPm5hbWUsIGZsYWdzKSkgewoJCQlpZiAoIWlnbm9yZV9hZGRfZXJyb3JzKQoJCQkJZGllKF8oImFkZGluZyBmaWxlcyBmYWlsZWQiKSk7CgkJCWV4aXRfc3RhdHVzID0gMTsKCQl9IGVsc2UgewoJCQljaGVja19lbWJlZGRlZF9yZXBvKGRpci0+ZW50cmllc1tpXS0+bmFtZSk7CgkJfQoJfQoJcmV0dXJuIGV4aXRfc3RhdHVzOwp9CgppbnQgY21kX2FkZChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJaW50IGV4aXRfc3RhdHVzID0gMDsKCXN0cnVjdCBwYXRoc3BlYyBwYXRoc3BlYzsKCXN0cnVjdCBkaXJfc3RydWN0IGRpcjsKCWludCBmbGFnczsKCWludCBhZGRfbmV3X2ZpbGVzOwoJaW50IHJlcXVpcmVfcGF0aHNwZWM7CgljaGFyICpzZWVuID0gTlVMTDsKCXN0cnVjdCBsb2NrX2ZpbGUgbG9ja19maWxlID0gTE9DS19JTklUOwoKCWdpdF9jb25maWcoYWRkX2NvbmZpZywgTlVMTCk7CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBidWlsdGluX2FkZF9vcHRpb25zLAoJCQkgIGJ1aWx0aW5fYWRkX3VzYWdlLCBQQVJTRV9PUFRfS0VFUF9BUkdWMCk7CglpZiAocGF0Y2hfaW50ZXJhY3RpdmUpCgkJYWRkX2ludGVyYWN0aXZlID0gMTsKCWlmIChhZGRfaW50ZXJhY3RpdmUpCgkJZXhpdChpbnRlcmFjdGl2ZV9hZGQoYXJnYyAtIDEsIGFyZ3YgKyAxLCBwcmVmaXgsIHBhdGNoX2ludGVyYWN0aXZlKSk7CgoJaWYgKGVkaXRfaW50ZXJhY3RpdmUpCgkJcmV0dXJuKGVkaXRfcGF0Y2goYXJnYywgYXJndiwgcHJlZml4KSk7CglhcmdjLS07Cglhcmd2Kys7CgoJaWYgKDAgPD0gYWRkcmVtb3ZlX2V4cGxpY2l0KQoJCWFkZHJlbW92ZSA9IGFkZHJlbW92ZV9leHBsaWNpdDsKCWVsc2UgaWYgKHRha2Vfd29ya3RyZWVfY2hhbmdlcyAmJiBBRERSRU1PVkVfREVGQVVMVCkKCQlhZGRyZW1vdmUgPSAwOyAvKiAiLXUiIHdhcyBnaXZlbiBidXQgbm90ICItQSIgKi8KCglpZiAoYWRkcmVtb3ZlICYmIHRha2Vfd29ya3RyZWVfY2hhbmdlcykKCQlkaWUoXygiLUEgYW5kIC11IGFyZSBtdXR1YWxseSBpbmNvbXBhdGlibGUiKSk7CgoJaWYgKCF0YWtlX3dvcmt0cmVlX2NoYW5nZXMgJiYgYWRkcmVtb3ZlX2V4cGxpY2l0IDwgMCAmJiBhcmdjKQoJCS8qIFR1cm4gImdpdCBhZGQgcGF0aHNwZWMuLi4iIHRvICJnaXQgYWRkIC1BIHBhdGhzcGVjLi4uIiAqLwoJCWFkZHJlbW92ZSA9IDE7CgoJaWYgKCFzaG93X29ubHkgJiYgaWdub3JlX21pc3NpbmcpCgkJZGllKF8oIk9wdGlvbiAtLWlnbm9yZS1taXNzaW5nIGNhbiBvbmx5IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCAtLWRyeS1ydW4iKSk7CgoJaWYgKGNobW9kX2FyZyAmJiAoKGNobW9kX2FyZ1swXSAhPSAnLScgJiYgY2htb2RfYXJnWzBdICE9ICcrJykgfHwKCQkJICBjaG1vZF9hcmdbMV0gIT0gJ3gnIHx8IGNobW9kX2FyZ1syXSkpCgkJZGllKF8oIi0tY2htb2QgcGFyYW0gJyVzJyBtdXN0IGJlIGVpdGhlciAteCBvciAreCIpLCBjaG1vZF9hcmcpOwoKCWFkZF9uZXdfZmlsZXMgPSAhdGFrZV93b3JrdHJlZV9jaGFuZ2VzICYmICFyZWZyZXNoX29ubHkgJiYgIWFkZF9yZW5vcm1hbGl6ZTsKCXJlcXVpcmVfcGF0aHNwZWMgPSAhKHRha2Vfd29ya3RyZWVfY2hhbmdlcyB8fCAoMCA8IGFkZHJlbW92ZV9leHBsaWNpdCkpOwoKCWhvbGRfbG9ja2VkX2luZGV4KCZsb2NrX2ZpbGUsIExPQ0tfRElFX09OX0VSUk9SKTsKCglmbGFncyA9ICgodmVyYm9zZSA/IEFERF9DQUNIRV9WRVJCT1NFIDogMCkgfAoJCSAoc2hvd19vbmx5ID8gQUREX0NBQ0hFX1BSRVRFTkQgOiAwKSB8CgkJIChpbnRlbnRfdG9fYWRkID8gQUREX0NBQ0hFX0lOVEVOVCA6IDApIHwKCQkgKGlnbm9yZV9hZGRfZXJyb3JzID8gQUREX0NBQ0hFX0lHTk9SRV9FUlJPUlMgOiAwKSB8CgkJICghKGFkZHJlbW92ZSB8fCB0YWtlX3dvcmt0cmVlX2NoYW5nZXMpCgkJICA/IEFERF9DQUNIRV9JR05PUkVfUkVNT1ZBTCA6IDApKTsKCglpZiAocmVxdWlyZV9wYXRoc3BlYyAmJiBhcmdjID09IDApIHsKCQlmcHJpbnRmKHN0ZGVyciwgXygiTm90aGluZyBzcGVjaWZpZWQsIG5vdGhpbmcgYWRkZWQuXG4iKSk7CgkJZnByaW50ZihzdGRlcnIsIF8oIk1heWJlIHlvdSB3YW50ZWQgdG8gc2F5ICdnaXQgYWRkIC4nP1xuIikpOwoJCXJldHVybiAwOwoJfQoKCS8qCgkgKiBDaGVjayB0aGUgInBhdGhzcGVjICclcycgZGlkIG5vdCBtYXRjaCBhbnkgZmlsZXMiIGJsb2NrCgkgKiBiZWxvdyBiZWZvcmUgZW5hYmxpbmcgbmV3IG1hZ2ljLgoJICovCglwYXJzZV9wYXRoc3BlYygmcGF0aHNwZWMsIFBBVEhTUEVDX0FUVFIsCgkJICAgICAgIFBBVEhTUEVDX1BSRUZFUl9GVUxMIHwKCQkgICAgICAgUEFUSFNQRUNfU1lNTElOS19MRUFESU5HX1BBVEgsCgkJICAgICAgIHByZWZpeCwgYXJndik7CgoJaWYgKHJlYWRfY2FjaGVfcHJlbG9hZCgmcGF0aHNwZWMpIDwgMCkKCQlkaWUoXygiaW5kZXggZmlsZSBjb3JydXB0IikpOwoKCWRpZV9pbl91bnBvcHVsYXRlZF9zdWJtb2R1bGUoJnRoZV9pbmRleCwgcHJlZml4KTsKCWRpZV9wYXRoX2luc2lkZV9zdWJtb2R1bGUoJnRoZV9pbmRleCwgJnBhdGhzcGVjKTsKCglpZiAoYWRkX25ld19maWxlcykgewoJCWludCBiYXNlbGVuOwoKCQkvKiBTZXQgdXAgdGhlIGRlZmF1bHQgZ2l0IHBvcmNlbGFpbiBleGNsdWRlcyAqLwoJCW1lbXNldCgmZGlyLCAwLCBzaXplb2YoZGlyKSk7CgkJaWYgKCFpZ25vcmVkX3RvbykgewoJCQlkaXIuZmxhZ3MgfD0gRElSX0NPTExFQ1RfSUdOT1JFRDsKCQkJc2V0dXBfc3RhbmRhcmRfZXhjbHVkZXMoJmRpcik7CgkJfQoKCQkvKiBUaGlzIHBpY2tzIHVwIHRoZSBwYXRocyB0aGF0IGFyZSBub3QgdHJhY2tlZCAqLwoJCWJhc2VsZW4gPSBmaWxsX2RpcmVjdG9yeSgmZGlyLCAmdGhlX2luZGV4LCAmcGF0aHNwZWMpOwoJCWlmIChwYXRoc3BlYy5ucikKCQkJc2VlbiA9IHBydW5lX2RpcmVjdG9yeSgmZGlyLCAmcGF0aHNwZWMsIGJhc2VsZW4pOwoJfQoKCWlmIChyZWZyZXNoX29ubHkpIHsKCQlyZWZyZXNoKHZlcmJvc2UsICZwYXRoc3BlYyk7CgkJZ290byBmaW5pc2g7Cgl9CgoJaWYgKHBhdGhzcGVjLm5yKSB7CgkJaW50IGk7CgoJCWlmICghc2VlbikKCQkJc2VlbiA9IGZpbmRfcGF0aHNwZWNzX21hdGNoaW5nX2FnYWluc3RfaW5kZXgoJnBhdGhzcGVjLCAmdGhlX2luZGV4KTsKCgkJLyoKCQkgKiBmaWxlX2V4aXN0cygpIGFzc3VtZXMgZXhhY3QgbWF0Y2gKCQkgKi8KCQlHVUFSRF9QQVRIU1BFQygmcGF0aHNwZWMsCgkJCSAgICAgICBQQVRIU1BFQ19GUk9NVE9QIHwKCQkJICAgICAgIFBBVEhTUEVDX0xJVEVSQUwgfAoJCQkgICAgICAgUEFUSFNQRUNfR0xPQiB8CgkJCSAgICAgICBQQVRIU1BFQ19JQ0FTRSB8CgkJCSAgICAgICBQQVRIU1BFQ19FWENMVURFKTsKCgkJZm9yIChpID0gMDsgaSA8IHBhdGhzcGVjLm5yOyBpKyspIHsKCQkJY29uc3QgY2hhciAqcGF0aCA9IHBhdGhzcGVjLml0ZW1zW2ldLm1hdGNoOwoJCQlpZiAocGF0aHNwZWMuaXRlbXNbaV0ubWFnaWMgJiBQQVRIU1BFQ19FWENMVURFKQoJCQkJY29udGludWU7CgkJCWlmICghc2VlbltpXSAmJiBwYXRoWzBdICYmCgkJCSAgICAoKHBhdGhzcGVjLml0ZW1zW2ldLm1hZ2ljICYKCQkJICAgICAgKFBBVEhTUEVDX0dMT0IgfCBQQVRIU1BFQ19JQ0FTRSkpIHx8CgkJCSAgICAgIWZpbGVfZXhpc3RzKHBhdGgpKSkgewoJCQkJaWYgKGlnbm9yZV9taXNzaW5nKSB7CgkJCQkJaW50IGR0eXBlID0gRFRfVU5LTk9XTjsKCQkJCQlpZiAoaXNfZXhjbHVkZWQoJmRpciwgJnRoZV9pbmRleCwgcGF0aCwgJmR0eXBlKSkKCQkJCQkJZGlyX2FkZF9pZ25vcmVkKCZkaXIsICZ0aGVfaW5kZXgsCgkJCQkJCQkJcGF0aCwgcGF0aHNwZWMuaXRlbXNbaV0ubGVuKTsKCQkJCX0gZWxzZQoJCQkJCWRpZShfKCJwYXRoc3BlYyAnJXMnIGRpZCBub3QgbWF0Y2ggYW55IGZpbGVzIiksCgkJCQkJICAgIHBhdGhzcGVjLml0ZW1zW2ldLm9yaWdpbmFsKTsKCQkJfQoJCX0KCQlmcmVlKHNlZW4pOwoJfQoKCXBsdWdfYnVsa19jaGVja2luKCk7CgoJaWYgKGFkZF9yZW5vcm1hbGl6ZSkKCQlleGl0X3N0YXR1cyB8PSByZW5vcm1hbGl6ZV90cmFja2VkX2ZpbGVzKCZwYXRoc3BlYywgZmxhZ3MpOwoJZWxzZQoJCWV4aXRfc3RhdHVzIHw9IGFkZF9maWxlc190b19jYWNoZShwcmVmaXgsICZwYXRoc3BlYywgZmxhZ3MpOwoKCWlmIChhZGRfbmV3X2ZpbGVzKQoJCWV4aXRfc3RhdHVzIHw9IGFkZF9maWxlcygmZGlyLCBmbGFncyk7CgoJaWYgKGNobW9kX2FyZyAmJiBwYXRoc3BlYy5ucikKCQljaG1vZF9wYXRoc3BlYygmcGF0aHNwZWMsIGNobW9kX2FyZ1swXSk7Cgl1bnBsdWdfYnVsa19jaGVja2luKCk7CgpmaW5pc2g6CglpZiAod3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZsb2NrX2ZpbGUsCgkJCSAgICAgICBDT01NSVRfTE9DSyB8IFNLSVBfSUZfVU5DSEFOR0VEKSkKCQlkaWUoXygiVW5hYmxlIHRvIHdyaXRlIG5ldyBpbmRleCBmaWxlIikpOwoKCVVOTEVBSyhwYXRoc3BlYyk7CglVTkxFQUsoZGlyKTsKCXJldHVybiBleGl0X3N0YXR1czsKfQo=",
    "text": "/*\n * \"git add\" builtin command\n *\n * Copyright (C) 2006 Linus Torvalds\n */\n#define USE_THE_INDEX_COMPATIBILITY_MACROS\n#include \"cache.h\"\n#include \"config.h\"\n#include \"builtin.h\"\n#include \"lockfile.h\"\n#include \"dir.h\"\n#include \"pathspec.h\"\n#include \"exec-cmd.h\"\n#include \"cache-tree.h\"\n#include \"run-command.h\"\n#include \"parse-options.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"revision.h\"\n#include \"bulk-checkin.h\"\n#include \"argv-array.h\"\n#include \"submodule.h\"\n#include \"add-interactive.h\"\n\nstatic const char * const builtin_add_usage[] = {\n\tN_(\"git add [<options>] [--] <pathspec>...\"),\n\tNULL\n};\nstatic int patch_interactive, add_interactive, edit_interactive;\nstatic int take_worktree_changes;\nstatic int add_renormalize;\n\nstruct update_callback_data {\n\tint flags;\n\tint add_errors;\n};\n\nstatic void chmod_pathspec(struct pathspec *pathspec, char flip)\n{\n\tint i;\n\n\tfor (i = 0; i < active_nr; i++) {\n\t\tstruct cache_entry *ce = active_cache[i];\n\n\t\tif (pathspec && !ce_path_match(&the_index, ce, pathspec, NULL))\n\t\t\tcontinue;\n\n\t\tif (chmod_cache_entry(ce, flip) < 0)\n\t\t\tfprintf(stderr, \"cannot chmod %cx '%s'\\n\", flip, ce->name);\n\t}\n}\n\nstatic int fix_unmerged_status(struct diff_filepair *p,\n\t\t\t       struct update_callback_data *data)\n{\n\tif (p->status != DIFF_STATUS_UNMERGED)\n\t\treturn p->status;\n\tif (!(data->flags & ADD_CACHE_IGNORE_REMOVAL) && !p->two->mode)\n\t\t/*\n\t\t * This is not an explicit add request, and the\n\t\t * path is missing from the working tree (deleted)\n\t\t */\n\t\treturn DIFF_STATUS_DELETED;\n\telse\n\t\t/*\n\t\t * Either an explicit add request, or path exists\n\t\t * in the working tree.  An attempt to explicitly\n\t\t * add a path that does not exist in the working tree\n\t\t * will be caught as an error by the caller immediately.\n\t\t */\n\t\treturn DIFF_STATUS_MODIFIED;\n}\n\nstatic void update_callback(struct diff_queue_struct *q,\n\t\t\t    struct diff_options *opt, void *cbdata)\n{\n\tint i;\n\tstruct update_callback_data *data = cbdata;\n\n\tfor (i = 0; i < q->nr; i++) {\n\t\tstruct diff_filepair *p = q->queue[i];\n\t\tconst char *path = p->one->path;\n\t\tswitch (fix_unmerged_status(p, data)) {\n\t\tdefault:\n\t\t\tdie(_(\"unexpected diff status %c\"), p->status);\n\t\tcase DIFF_STATUS_MODIFIED:\n\t\tcase DIFF_STATUS_TYPE_CHANGED:\n\t\t\tif (add_file_to_index(&the_index, path,\tdata->flags)) {\n\t\t\t\tif (!(data->flags & ADD_CACHE_IGNORE_ERRORS))\n\t\t\t\t\tdie(_(\"updating files failed\"));\n\t\t\t\tdata->add_errors++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DIFF_STATUS_DELETED:\n\t\t\tif (data->flags & ADD_CACHE_IGNORE_REMOVAL)\n\t\t\t\tbreak;\n\t\t\tif (!(data->flags & ADD_CACHE_PRETEND))\n\t\t\t\tremove_file_from_index(&the_index, path);\n\t\t\tif (data->flags & (ADD_CACHE_PRETEND|ADD_CACHE_VERBOSE))\n\t\t\t\tprintf(_(\"remove '%s'\\n\"), path);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint add_files_to_cache(const char *prefix,\n\t\t       const struct pathspec *pathspec, int flags)\n{\n\tstruct update_callback_data data;\n\tstruct rev_info rev;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.flags = flags;\n\n\trepo_init_revisions(the_repository, &rev, prefix);\n\tsetup_revisions(0, NULL, &rev, NULL);\n\tif (pathspec)\n\t\tcopy_pathspec(&rev.prune_data, pathspec);\n\trev.diffopt.output_format = DIFF_FORMAT_CALLBACK;\n\trev.diffopt.format_callback = update_callback;\n\trev.diffopt.format_callback_data = &data;\n\trev.diffopt.flags.override_submodule_config = 1;\n\trev.max_count = 0; /* do not compare unmerged paths with stage #2 */\n\trun_diff_files(&rev, DIFF_RACY_IS_MODIFIED);\n\tclear_pathspec(&rev.prune_data);\n\treturn !!data.add_errors;\n}\n\nstatic int renormalize_tracked_files(const struct pathspec *pathspec, int flags)\n{\n\tint i, retval = 0;\n\n\tfor (i = 0; i < active_nr; i++) {\n\t\tstruct cache_entry *ce = active_cache[i];\n\n\t\tif (ce_stage(ce))\n\t\t\tcontinue; /* do not touch unmerged paths */\n\t\tif (!S_ISREG(ce->ce_mode) && !S_ISLNK(ce->ce_mode))\n\t\t\tcontinue; /* do not touch non blobs */\n\t\tif (pathspec && !ce_path_match(&the_index, ce, pathspec, NULL))\n\t\t\tcontinue;\n\t\tretval |= add_file_to_cache(ce->name, flags | ADD_CACHE_RENORMALIZE);\n\t}\n\n\treturn retval;\n}\n\nstatic char *prune_directory(struct dir_struct *dir, struct pathspec *pathspec, int prefix)\n{\n\tchar *seen;\n\tint i;\n\tstruct dir_entry **src, **dst;\n\n\tseen = xcalloc(pathspec->nr, 1);\n\n\tsrc = dst = dir->entries;\n\ti = dir->nr;\n\twhile (--i >= 0) {\n\t\tstruct dir_entry *entry = *src++;\n\t\tif (dir_path_match(&the_index, entry, pathspec, prefix, seen))\n\t\t\t*dst++ = entry;\n\t}\n\tdir->nr = dst - dir->entries;\n\tadd_pathspec_matches_against_index(pathspec, &the_index, seen);\n\treturn seen;\n}\n\nstatic void refresh(int verbose, const struct pathspec *pathspec)\n{\n\tchar *seen;\n\tint i;\n\n\tseen = xcalloc(pathspec->nr, 1);\n\trefresh_index(&the_index, verbose ? REFRESH_IN_PORCELAIN : REFRESH_QUIET,\n\t\t      pathspec, seen, _(\"Unstaged changes after refreshing the index:\"));\n\tfor (i = 0; i < pathspec->nr; i++) {\n\t\tif (!seen[i])\n\t\t\tdie(_(\"pathspec '%s' did not match any files\"),\n\t\t\t    pathspec->items[i].match);\n\t}\n\tfree(seen);\n}\n\nint run_add_interactive(const char *revision, const char *patch_mode,\n\t\t\tconst struct pathspec *pathspec)\n{\n\tint status, i;\n\tstruct argv_array argv = ARGV_ARRAY_INIT;\n\tint use_builtin_add_i =\n\t\tgit_env_bool(\"GIT_TEST_ADD_I_USE_BUILTIN\", -1);\n\n\tif (use_builtin_add_i < 0)\n\t\tgit_config_get_bool(\"add.interactive.usebuiltin\",\n\t\t\t\t    &use_builtin_add_i);\n\n\tif (use_builtin_add_i == 1) {\n\t\tenum add_p_mode mode;\n\n\t\tif (!patch_mode)\n\t\t\treturn !!run_add_i(the_repository, pathspec);\n\n\t\tif (!strcmp(patch_mode, \"--patch\"))\n\t\t\tmode = ADD_P_ADD;\n\t\telse\n\t\t\tdie(\"'%s' not yet supported in the built-in add -p\",\n\t\t\t    patch_mode);\n\n\t\treturn !!run_add_p(the_repository, mode, revision, pathspec);\n\t}\n\n\targv_array_push(&argv, \"add--interactive\");\n\tif (patch_mode)\n\t\targv_array_push(&argv, patch_mode);\n\tif (revision)\n\t\targv_array_push(&argv, revision);\n\targv_array_push(&argv, \"--\");\n\tfor (i = 0; i < pathspec->nr; i++)\n\t\t/* pass original pathspec, to be re-parsed */\n\t\targv_array_push(&argv, pathspec->items[i].original);\n\n\tstatus = run_command_v_opt(argv.argv, RUN_GIT_CMD);\n\targv_array_clear(&argv);\n\treturn status;\n}\n\nint interactive_add(int argc, const char **argv, const char *prefix, int patch)\n{\n\tstruct pathspec pathspec;\n\n\tparse_pathspec(&pathspec, 0,\n\t\t       PATHSPEC_PREFER_FULL |\n\t\t       PATHSPEC_SYMLINK_LEADING_PATH |\n\t\t       PATHSPEC_PREFIX_ORIGIN,\n\t\t       prefix, argv);\n\n\treturn run_add_interactive(NULL,\n\t\t\t\t   patch ? \"--patch\" : NULL,\n\t\t\t\t   &pathspec);\n}\n\nstatic int edit_patch(int argc, const char **argv, const char *prefix)\n{\n\tchar *file = git_pathdup(\"ADD_EDIT.patch\");\n\tconst char *apply_argv[] = { \"apply\", \"--recount\", \"--cached\",\n\t\tNULL, NULL };\n\tstruct child_process child = CHILD_PROCESS_INIT;\n\tstruct rev_info rev;\n\tint out;\n\tstruct stat st;\n\n\tapply_argv[3] = file;\n\n\tgit_config(git_diff_basic_config, NULL); /* no \"diff\" UI options */\n\n\tif (read_cache() < 0)\n\t\tdie(_(\"Could not read the index\"));\n\n\trepo_init_revisions(the_repository, &rev, prefix);\n\trev.diffopt.context = 7;\n\n\targc = setup_revisions(argc, argv, &rev, NULL);\n\trev.diffopt.output_format = DIFF_FORMAT_PATCH;\n\trev.diffopt.use_color = 0;\n\trev.diffopt.flags.ignore_dirty_submodules = 1;\n\tout = open(file, O_CREAT | O_WRONLY | O_TRUNC, 0666);\n\tif (out < 0)\n\t\tdie(_(\"Could not open '%s' for writing.\"), file);\n\trev.diffopt.file = xfdopen(out, \"w\");\n\trev.diffopt.close_file = 1;\n\tif (run_diff_files(&rev, 0))\n\t\tdie(_(\"Could not write patch\"));\n\n\tif (launch_editor(file, NULL, NULL))\n\t\tdie(_(\"editing patch failed\"));\n\n\tif (stat(file, &st))\n\t\tdie_errno(_(\"Could not stat '%s'\"), file);\n\tif (!st.st_size)\n\t\tdie(_(\"Empty patch. Aborted.\"));\n\n\tchild.git_cmd = 1;\n\tchild.argv = apply_argv;\n\tif (run_command(&child))\n\t\tdie(_(\"Could not apply '%s'\"), file);\n\n\tunlink(file);\n\tfree(file);\n\treturn 0;\n}\n\nstatic const char ignore_error[] =\nN_(\"The following paths are ignored by one of your .gitignore files:\\n\");\n\nstatic int verbose, show_only, ignored_too, refresh_only;\nstatic int ignore_add_errors, intent_to_add, ignore_missing;\nstatic int warn_on_embedded_repo = 1;\n\n#define ADDREMOVE_DEFAULT 1\nstatic int addremove = ADDREMOVE_DEFAULT;\nstatic int addremove_explicit = -1; /* unspecified */\n\nstatic char *chmod_arg;\n\nstatic int ignore_removal_cb(const struct option *opt, const char *arg, int unset)\n{\n\t/* if we are told to ignore, we are not adding removals */\n\t*(int *)opt->value = !unset ? 0 : 1;\n\treturn 0;\n}\n\nstatic struct option builtin_add_options[] = {\n\tOPT__DRY_RUN(&show_only, N_(\"dry run\")),\n\tOPT__VERBOSE(&verbose, N_(\"be verbose\")),\n\tOPT_GROUP(\"\"),\n\tOPT_BOOL('i', \"interactive\", &add_interactive, N_(\"interactive picking\")),\n\tOPT_BOOL('p', \"patch\", &patch_interactive, N_(\"select hunks interactively\")),\n\tOPT_BOOL('e', \"edit\", &edit_interactive, N_(\"edit current diff and apply\")),\n\tOPT__FORCE(&ignored_too, N_(\"allow adding otherwise ignored files\"), 0),\n\tOPT_BOOL('u', \"update\", &take_worktree_changes, N_(\"update tracked files\")),\n\tOPT_BOOL(0, \"renormalize\", &add_renormalize, N_(\"renormalize EOL of tracked files (implies -u)\")),\n\tOPT_BOOL('N', \"intent-to-add\", &intent_to_add, N_(\"record only the fact that the path will be added later\")),\n\tOPT_BOOL('A', \"all\", &addremove_explicit, N_(\"add changes from all tracked and untracked files\")),\n\t{ OPTION_CALLBACK, 0, \"ignore-removal\", &addremove_explicit,\n\t  NULL /* takes no arguments */,\n\t  N_(\"ignore paths removed in the working tree (same as --no-all)\"),\n\t  PARSE_OPT_NOARG, ignore_removal_cb },\n\tOPT_BOOL( 0 , \"refresh\", &refresh_only, N_(\"don't add, only refresh the index\")),\n\tOPT_BOOL( 0 , \"ignore-errors\", &ignore_add_errors, N_(\"just skip files which cannot be added because of errors\")),\n\tOPT_BOOL( 0 , \"ignore-missing\", &ignore_missing, N_(\"check if - even missing - files are ignored in dry run\")),\n\tOPT_STRING(0, \"chmod\", &chmod_arg, \"(+|-)x\",\n\t\t   N_(\"override the executable bit of the listed files\")),\n\tOPT_HIDDEN_BOOL(0, \"warn-embedded-repo\", &warn_on_embedded_repo,\n\t\t\tN_(\"warn when adding an embedded repository\")),\n\tOPT_END(),\n};\n\nstatic int add_config(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(var, \"add.ignoreerrors\") ||\n\t    !strcmp(var, \"add.ignore-errors\")) {\n\t\tignore_add_errors = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\treturn git_default_config(var, value, cb);\n}\n\nstatic const char embedded_advice[] = N_(\n\"You've added another git repository inside your current repository.\\n\"\n\"Clones of the outer repository will not contain the contents of\\n\"\n\"the embedded repository and will not know how to obtain it.\\n\"\n\"If you meant to add a submodule, use:\\n\"\n\"\\n\"\n\"\tgit submodule add <url> %s\\n\"\n\"\\n\"\n\"If you added this path by mistake, you can remove it from the\\n\"\n\"index with:\\n\"\n\"\\n\"\n\"\tgit rm --cached %s\\n\"\n\"\\n\"\n\"See \\\"git help submodule\\\" for more information.\"\n);\n\nstatic void check_embedded_repo(const char *path)\n{\n\tstruct strbuf name = STRBUF_INIT;\n\n\tif (!warn_on_embedded_repo)\n\t\treturn;\n\tif (!ends_with(path, \"/\"))\n\t\treturn;\n\n\t/* Drop trailing slash for aesthetics */\n\tstrbuf_addstr(&name, path);\n\tstrbuf_strip_suffix(&name, \"/\");\n\n\twarning(_(\"adding embedded git repository: %s\"), name.buf);\n\tif (advice_add_embedded_repo) {\n\t\tadvise(embedded_advice, name.buf, name.buf);\n\t\t/* there may be multiple entries; advise only once */\n\t\tadvice_add_embedded_repo = 0;\n\t}\n\n\tstrbuf_release(&name);\n}\n\nstatic int add_files(struct dir_struct *dir, int flags)\n{\n\tint i, exit_status = 0;\n\n\tif (dir->ignored_nr) {\n\t\tfprintf(stderr, _(ignore_error));\n\t\tfor (i = 0; i < dir->ignored_nr; i++)\n\t\t\tfprintf(stderr, \"%s\\n\", dir->ignored[i]->name);\n\t\tfprintf(stderr, _(\"Use -f if you really want to add them.\\n\"));\n\t\texit_status = 1;\n\t}\n\n\tfor (i = 0; i < dir->nr; i++) {\n\t\tif (add_file_to_index(&the_index, dir->entries[i]->name, flags)) {\n\t\t\tif (!ignore_add_errors)\n\t\t\t\tdie(_(\"adding files failed\"));\n\t\t\texit_status = 1;\n\t\t} else {\n\t\t\tcheck_embedded_repo(dir->entries[i]->name);\n\t\t}\n\t}\n\treturn exit_status;\n}\n\nint cmd_add(int argc, const char **argv, const char *prefix)\n{\n\tint exit_status = 0;\n\tstruct pathspec pathspec;\n\tstruct dir_struct dir;\n\tint flags;\n\tint add_new_files;\n\tint require_pathspec;\n\tchar *seen = NULL;\n\tstruct lock_file lock_file = LOCK_INIT;\n\n\tgit_config(add_config, NULL);\n\n\targc = parse_options(argc, argv, prefix, builtin_add_options,\n\t\t\t  builtin_add_usage, PARSE_OPT_KEEP_ARGV0);\n\tif (patch_interactive)\n\t\tadd_interactive = 1;\n\tif (add_interactive)\n\t\texit(interactive_add(argc - 1, argv + 1, prefix, patch_interactive));\n\n\tif (edit_interactive)\n\t\treturn(edit_patch(argc, argv, prefix));\n\targc--;\n\targv++;\n\n\tif (0 <= addremove_explicit)\n\t\taddremove = addremove_explicit;\n\telse if (take_worktree_changes && ADDREMOVE_DEFAULT)\n\t\taddremove = 0; /* \"-u\" was given but not \"-A\" */\n\n\tif (addremove && take_worktree_changes)\n\t\tdie(_(\"-A and -u are mutually incompatible\"));\n\n\tif (!take_worktree_changes && addremove_explicit < 0 && argc)\n\t\t/* Turn \"git add pathspec...\" to \"git add -A pathspec...\" */\n\t\taddremove = 1;\n\n\tif (!show_only && ignore_missing)\n\t\tdie(_(\"Option --ignore-missing can only be used together with --dry-run\"));\n\n\tif (chmod_arg && ((chmod_arg[0] != '-' && chmod_arg[0] != '+') ||\n\t\t\t  chmod_arg[1] != 'x' || chmod_arg[2]))\n\t\tdie(_(\"--chmod param '%s' must be either -x or +x\"), chmod_arg);\n\n\tadd_new_files = !take_worktree_changes && !refresh_only && !add_renormalize;\n\trequire_pathspec = !(take_worktree_changes || (0 < addremove_explicit));\n\n\thold_locked_index(&lock_file, LOCK_DIE_ON_ERROR);\n\n\tflags = ((verbose ? ADD_CACHE_VERBOSE : 0) |\n\t\t (show_only ? ADD_CACHE_PRETEND : 0) |\n\t\t (intent_to_add ? ADD_CACHE_INTENT : 0) |\n\t\t (ignore_add_errors ? ADD_CACHE_IGNORE_ERRORS : 0) |\n\t\t (!(addremove || take_worktree_changes)\n\t\t  ? ADD_CACHE_IGNORE_REMOVAL : 0));\n\n\tif (require_pathspec && argc == 0) {\n\t\tfprintf(stderr, _(\"Nothing specified, nothing added.\\n\"));\n\t\tfprintf(stderr, _(\"Maybe you wanted to say 'git add .'?\\n\"));\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check the \"pathspec '%s' did not match any files\" block\n\t * below before enabling new magic.\n\t */\n\tparse_pathspec(&pathspec, PATHSPEC_ATTR,\n\t\t       PATHSPEC_PREFER_FULL |\n\t\t       PATHSPEC_SYMLINK_LEADING_PATH,\n\t\t       prefix, argv);\n\n\tif (read_cache_preload(&pathspec) < 0)\n\t\tdie(_(\"index file corrupt\"));\n\n\tdie_in_unpopulated_submodule(&the_index, prefix);\n\tdie_path_inside_submodule(&the_index, &pathspec);\n\n\tif (add_new_files) {\n\t\tint baselen;\n\n\t\t/* Set up the default git porcelain excludes */\n\t\tmemset(&dir, 0, sizeof(dir));\n\t\tif (!ignored_too) {\n\t\t\tdir.flags |= DIR_COLLECT_IGNORED;\n\t\t\tsetup_standard_excludes(&dir);\n\t\t}\n\n\t\t/* This picks up the paths that are not tracked */\n\t\tbaselen = fill_directory(&dir, &the_index, &pathspec);\n\t\tif (pathspec.nr)\n\t\t\tseen = prune_directory(&dir, &pathspec, baselen);\n\t}\n\n\tif (refresh_only) {\n\t\trefresh(verbose, &pathspec);\n\t\tgoto finish;\n\t}\n\n\tif (pathspec.nr) {\n\t\tint i;\n\n\t\tif (!seen)\n\t\t\tseen = find_pathspecs_matching_against_index(&pathspec, &the_index);\n\n\t\t/*\n\t\t * file_exists() assumes exact match\n\t\t */\n\t\tGUARD_PATHSPEC(&pathspec,\n\t\t\t       PATHSPEC_FROMTOP |\n\t\t\t       PATHSPEC_LITERAL |\n\t\t\t       PATHSPEC_GLOB |\n\t\t\t       PATHSPEC_ICASE |\n\t\t\t       PATHSPEC_EXCLUDE);\n\n\t\tfor (i = 0; i < pathspec.nr; i++) {\n\t\t\tconst char *path = pathspec.items[i].match;\n\t\t\tif (pathspec.items[i].magic & PATHSPEC_EXCLUDE)\n\t\t\t\tcontinue;\n\t\t\tif (!seen[i] && path[0] &&\n\t\t\t    ((pathspec.items[i].magic &\n\t\t\t      (PATHSPEC_GLOB | PATHSPEC_ICASE)) ||\n\t\t\t     !file_exists(path))) {\n\t\t\t\tif (ignore_missing) {\n\t\t\t\t\tint dtype = DT_UNKNOWN;\n\t\t\t\t\tif (is_excluded(&dir, &the_index, path, &dtype))\n\t\t\t\t\t\tdir_add_ignored(&dir, &the_index,\n\t\t\t\t\t\t\t\tpath, pathspec.items[i].len);\n\t\t\t\t} else\n\t\t\t\t\tdie(_(\"pathspec '%s' did not match any files\"),\n\t\t\t\t\t    pathspec.items[i].original);\n\t\t\t}\n\t\t}\n\t\tfree(seen);\n\t}\n\n\tplug_bulk_checkin();\n\n\tif (add_renormalize)\n\t\texit_status |= renormalize_tracked_files(&pathspec, flags);\n\telse\n\t\texit_status |= add_files_to_cache(prefix, &pathspec, flags);\n\n\tif (add_new_files)\n\t\texit_status |= add_files(&dir, flags);\n\n\tif (chmod_arg && pathspec.nr)\n\t\tchmod_pathspec(&pathspec, chmod_arg[0]);\n\tunplug_bulk_checkin();\n\nfinish:\n\tif (write_locked_index(&the_index, &lock_file,\n\t\t\t       COMMIT_LOCK | SKIP_IF_UNCHANGED))\n\t\tdie(_(\"Unable to write new index file\"));\n\n\tUNLEAK(pathspec);\n\tUNLEAK(dir);\n\treturn exit_status;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "006016267e2cca3302770be3c923ef996254da01",
  "sha1_ok": true,
  "size": 16106
}
