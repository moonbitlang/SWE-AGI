{
  "content": {
    "base64": "LyoKICogSGFuZGxlIGdpdCBhdHRyaWJ1dGVzLiAgU2VlIGdpdGF0dHJpYnV0ZXMoNSkgZm9yIGEgZGVzY3JpcHRpb24gb2YKICogdGhlIGZpbGUgc3ludGF4LCBhbmQgRG9jdW1lbnRhdGlvbi90ZWNobmljYWwvYXBpLWdpdGF0dHJpYnV0ZXMudHh0CiAqIGZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBBUEkuCiAqCiAqIE9uZSBiYXNpYyBkZXNpZ24gZGVjaXNpb24gaGVyZSBpcyB0aGF0IHdlIGFyZSBub3QgZ29pbmcgdG8gc3VwcG9ydAogKiBhbiBpbnNhbmVseSBsYXJnZSBudW1iZXIgb2YgYXR0cmlidXRlcy4KICovCgojZGVmaW5lIE5PX1RIRV9JTkRFWF9DT01QQVRJQklMSVRZX01BQ1JPUwojaW5jbHVkZSAiY2FjaGUuaCIKI2luY2x1ZGUgImV4ZWNfY21kLmgiCiNpbmNsdWRlICJhdHRyLmgiCiNpbmNsdWRlICJkaXIuaCIKI2luY2x1ZGUgInV0ZjguaCIKCmNvbnN0IGNoYXIgZ2l0X2F0dHJfX3RydWVbXSA9ICIoYnVpbHRpbil0cnVlIjsKY29uc3QgY2hhciBnaXRfYXR0cl9fZmFsc2VbXSA9ICJcMChidWlsdGluKWZhbHNlIjsKc3RhdGljIGNvbnN0IGNoYXIgZ2l0X2F0dHJfX3Vua25vd25bXSA9ICIoYnVpbHRpbil1bmtub3duIjsKI2RlZmluZSBBVFRSX19UUlVFIGdpdF9hdHRyX190cnVlCiNkZWZpbmUgQVRUUl9fRkFMU0UgZ2l0X2F0dHJfX2ZhbHNlCiNkZWZpbmUgQVRUUl9fVU5TRVQgTlVMTAojZGVmaW5lIEFUVFJfX1VOS05PV04gZ2l0X2F0dHJfX3Vua25vd24KCi8qIFRoaXMgaXMgYSByYW5kb21seSBjaG9zZW4gcHJpbWUuICovCiNkZWZpbmUgSEFTSFNJWkUgMjU3CgojaWZuZGVmIERFQlVHX0FUVFIKI2RlZmluZSBERUJVR19BVFRSIDAKI2VuZGlmCgpzdHJ1Y3QgZ2l0X2F0dHIgewoJc3RydWN0IGdpdF9hdHRyICpuZXh0OwoJdW5zaWduZWQgaDsKCWludCBhdHRyX25yOwoJaW50IG1heWJlX21hY3JvOwoJaW50IG1heWJlX3JlYWw7CgljaGFyIG5hbWVbRkxFWF9BUlJBWV07Cn07CnN0YXRpYyBpbnQgYXR0cl9ucjsKc3RhdGljIGludCBjYW5ub3RfdHJ1c3RfbWF5YmVfcmVhbDsKCnN0YXRpYyBzdHJ1Y3QgZ2l0X2F0dHJfY2hlY2sgKmNoZWNrX2FsbF9hdHRyOwpzdGF0aWMgc3RydWN0IGdpdF9hdHRyICooZ2l0X2F0dHJfaGFzaFtIQVNIU0laRV0pOwoKY2hhciAqZ2l0X2F0dHJfbmFtZShzdHJ1Y3QgZ2l0X2F0dHIgKmF0dHIpCnsKCXJldHVybiBhdHRyLT5uYW1lOwp9CgpzdGF0aWMgdW5zaWduZWQgaGFzaF9uYW1lKGNvbnN0IGNoYXIgKm5hbWUsIGludCBuYW1lbGVuKQp7Cgl1bnNpZ25lZCB2YWwgPSAwLCBjOwoKCXdoaWxlIChuYW1lbGVuLS0pIHsKCQljID0gKm5hbWUrKzsKCQl2YWwgPSAoKHZhbCA8PCA3KSB8ICh2YWwgPj4gMjIpKSBeIGM7Cgl9CglyZXR1cm4gdmFsOwp9CgpzdGF0aWMgaW50IGludmFsaWRfYXR0cl9uYW1lKGNvbnN0IGNoYXIgKm5hbWUsIGludCBuYW1lbGVuKQp7CgkvKgoJICogQXR0cmlidXRlIG5hbWUgY2Fubm90IGJlZ2luIHdpdGggJy0nIGFuZCBtdXN0IGNvbnNpc3Qgb2YKCSAqIGNoYXJhY3RlcnMgZnJvbSBbLUEtWmEtejAtOV8uXS4KCSAqLwoJaWYgKG5hbWVsZW4gPD0gMCB8fCAqbmFtZSA9PSAnLScpCgkJcmV0dXJuIC0xOwoJd2hpbGUgKG5hbWVsZW4tLSkgewoJCWNoYXIgY2ggPSAqbmFtZSsrOwoJCWlmICghIChjaCA9PSAnLScgfHwgY2ggPT0gJy4nIHx8IGNoID09ICdfJyB8fAoJCSAgICAgICAoJzAnIDw9IGNoICYmIGNoIDw9ICc5JykgfHwKCQkgICAgICAgKCdhJyA8PSBjaCAmJiBjaCA8PSAneicpIHx8CgkJICAgICAgICgnQScgPD0gY2ggJiYgY2ggPD0gJ1onKSkgKQoJCQlyZXR1cm4gLTE7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIHN0cnVjdCBnaXRfYXR0ciAqZ2l0X2F0dHJfaW50ZXJuYWwoY29uc3QgY2hhciAqbmFtZSwgaW50IGxlbikKewoJdW5zaWduZWQgaHZhbCA9IGhhc2hfbmFtZShuYW1lLCBsZW4pOwoJdW5zaWduZWQgcG9zID0gaHZhbCAlIEhBU0hTSVpFOwoJc3RydWN0IGdpdF9hdHRyICphOwoKCWZvciAoYSA9IGdpdF9hdHRyX2hhc2hbcG9zXTsgYTsgYSA9IGEtPm5leHQpIHsKCQlpZiAoYS0+aCA9PSBodmFsICYmCgkJICAgICFtZW1jbXAoYS0+bmFtZSwgbmFtZSwgbGVuKSAmJiAhYS0+bmFtZVtsZW5dKQoJCQlyZXR1cm4gYTsKCX0KCglpZiAoaW52YWxpZF9hdHRyX25hbWUobmFtZSwgbGVuKSkKCQlyZXR1cm4gTlVMTDsKCglGTEVYX0FMTE9DX01FTShhLCBuYW1lLCBuYW1lLCBsZW4pOwoJYS0+aCA9IGh2YWw7CglhLT5uZXh0ID0gZ2l0X2F0dHJfaGFzaFtwb3NdOwoJYS0+YXR0cl9uciA9IGF0dHJfbnIrKzsKCWEtPm1heWJlX21hY3JvID0gMDsKCWEtPm1heWJlX3JlYWwgPSAwOwoJZ2l0X2F0dHJfaGFzaFtwb3NdID0gYTsKCglSRUFMTE9DX0FSUkFZKGNoZWNrX2FsbF9hdHRyLCBhdHRyX25yKTsKCWNoZWNrX2FsbF9hdHRyW2EtPmF0dHJfbnJdLmF0dHIgPSBhOwoJY2hlY2tfYWxsX2F0dHJbYS0+YXR0cl9ucl0udmFsdWUgPSBBVFRSX19VTktOT1dOOwoJcmV0dXJuIGE7Cn0KCnN0cnVjdCBnaXRfYXR0ciAqZ2l0X2F0dHIoY29uc3QgY2hhciAqbmFtZSkKewoJcmV0dXJuIGdpdF9hdHRyX2ludGVybmFsKG5hbWUsIHN0cmxlbihuYW1lKSk7Cn0KCi8qIFdoYXQgZG9lcyBhIG1hdGNoZWQgcGF0dGVybiBkZWNpZGU/ICovCnN0cnVjdCBhdHRyX3N0YXRlIHsKCXN0cnVjdCBnaXRfYXR0ciAqYXR0cjsKCWNvbnN0IGNoYXIgKnNldHRvOwp9OwoKc3RydWN0IHBhdHRlcm4gewoJY29uc3QgY2hhciAqcGF0dGVybjsKCWludCBwYXR0ZXJubGVuOwoJaW50IG5vd2lsZGNhcmRsZW47Cgl1bnNpZ25lZCBmbGFnczsJCS8qIEVYQ19GTEFHXyogKi8KfTsKCi8qCiAqIE9uZSBydWxlLCBhcyBmcm9tIGEgLmdpdGF0dHJpYnV0ZXMgZmlsZS4KICoKICogSWYgaXNfbWFjcm8gaXMgdHJ1ZSwgdGhlbiB1LmF0dHIgaXMgYSBwb2ludGVyIHRvIHRoZSBnaXRfYXR0ciBiZWluZwogKiBkZWZpbmVkLgogKgogKiBJZiBpc19tYWNybyBpcyBmYWxzZSwgdGhlbiB1LnBhdCBpcyB0aGUgZmlsZW5hbWUgcGF0dGVybiB0byB3aGljaCB0aGUKICogcnVsZSBhcHBsaWVzLgogKgogKiBJbiBlaXRoZXIgY2FzZSwgbnVtX2F0dHIgaXMgdGhlIG51bWJlciBvZiBhdHRyaWJ1dGVzIGFmZmVjdGVkIGJ5CiAqIHRoaXMgcnVsZSwgYW5kIHN0YXRlIGlzIGFuIGFycmF5IGxpc3RpbmcgdGhlbS4gIFRoZSBhdHRyaWJ1dGVzIGFyZQogKiBsaXN0ZWQgYXMgdGhleSBhcHBlYXIgaW4gdGhlIGZpbGUgKG1hY3JvcyB1bmV4cGFuZGVkKS4KICovCnN0cnVjdCBtYXRjaF9hdHRyIHsKCXVuaW9uIHsKCQlzdHJ1Y3QgcGF0dGVybiBwYXQ7CgkJc3RydWN0IGdpdF9hdHRyICphdHRyOwoJfSB1OwoJY2hhciBpc19tYWNybzsKCXVuc2lnbmVkIG51bV9hdHRyOwoJc3RydWN0IGF0dHJfc3RhdGUgc3RhdGVbRkxFWF9BUlJBWV07Cn07CgpzdGF0aWMgY29uc3QgY2hhciBibGFua1tdID0gIiBcdFxyXG4iOwoKLyoKICogUGFyc2UgYSB3aGl0ZXNwYWNlLWRlbGltaXRlZCBhdHRyaWJ1dGUgc3RhdGUgKGkuZS4sICJhdHRyIiwKICogIi1hdHRyIiwgIiFhdHRyIiwgb3IgImF0dHI9dmFsdWUiKSBmcm9tIHRoZSBzdHJpbmcgc3RhcnRpbmcgYXQgc3JjLgogKiBJZiBlIGlzIG5vdCBOVUxMLCB3cml0ZSB0aGUgcmVzdWx0cyB0byAqZS4gIFJldHVybiBhIHBvaW50ZXIgdG8gdGhlCiAqIHJlbWFpbmRlciBvZiB0aGUgc3RyaW5nICh3aXRoIGxlYWRpbmcgd2hpdGVzcGFjZSByZW1vdmVkKSwgb3IgTlVMTAogKiBpZiB0aGVyZSB3YXMgYW4gZXJyb3IuCiAqLwpzdGF0aWMgY29uc3QgY2hhciAqcGFyc2VfYXR0cihjb25zdCBjaGFyICpzcmMsIGludCBsaW5lbm8sIGNvbnN0IGNoYXIgKmNwLAoJCQkgICAgICBzdHJ1Y3QgYXR0cl9zdGF0ZSAqZSkKewoJY29uc3QgY2hhciAqZXAsICplcXVhbHM7CglpbnQgbGVuOwoKCWVwID0gY3AgKyBzdHJjc3BuKGNwLCBibGFuayk7CgllcXVhbHMgPSBzdHJjaHIoY3AsICc9Jyk7CglpZiAoZXF1YWxzICYmIGVwIDwgZXF1YWxzKQoJCWVxdWFscyA9IE5VTEw7CglpZiAoZXF1YWxzKQoJCWxlbiA9IGVxdWFscyAtIGNwOwoJZWxzZQoJCWxlbiA9IGVwIC0gY3A7CglpZiAoIWUpIHsKCQlpZiAoKmNwID09ICctJyB8fCAqY3AgPT0gJyEnKSB7CgkJCWNwKys7CgkJCWxlbi0tOwoJCX0KCQlpZiAoaW52YWxpZF9hdHRyX25hbWUoY3AsIGxlbikpIHsKCQkJZnByaW50ZihzdGRlcnIsCgkJCQkiJS4qcyBpcyBub3QgYSB2YWxpZCBhdHRyaWJ1dGUgbmFtZTogJXM6JWRcbiIsCgkJCQlsZW4sIGNwLCBzcmMsIGxpbmVubyk7CgkJCXJldHVybiBOVUxMOwoJCX0KCX0gZWxzZSB7CgkJaWYgKCpjcCA9PSAnLScgfHwgKmNwID09ICchJykgewoJCQllLT5zZXR0byA9ICgqY3AgPT0gJy0nKSA/IEFUVFJfX0ZBTFNFIDogQVRUUl9fVU5TRVQ7CgkJCWNwKys7CgkJCWxlbi0tOwoJCX0KCQllbHNlIGlmICghZXF1YWxzKQoJCQllLT5zZXR0byA9IEFUVFJfX1RSVUU7CgkJZWxzZSB7CgkJCWUtPnNldHRvID0geG1lbWR1cHooZXF1YWxzICsgMSwgZXAgLSBlcXVhbHMgLSAxKTsKCQl9CgkJZS0+YXR0ciA9IGdpdF9hdHRyX2ludGVybmFsKGNwLCBsZW4pOwoJfQoJcmV0dXJuIGVwICsgc3Ryc3BuKGVwLCBibGFuayk7Cn0KCnN0YXRpYyBzdHJ1Y3QgbWF0Y2hfYXR0ciAqcGFyc2VfYXR0cl9saW5lKGNvbnN0IGNoYXIgKmxpbmUsIGNvbnN0IGNoYXIgKnNyYywKCQkJCQkgIGludCBsaW5lbm8sIGludCBtYWNyb19vaykKewoJaW50IG5hbWVsZW47CglpbnQgbnVtX2F0dHIsIGk7Cgljb25zdCBjaGFyICpjcCwgKm5hbWUsICpzdGF0ZXM7CglzdHJ1Y3QgbWF0Y2hfYXR0ciAqcmVzID0gTlVMTDsKCWludCBpc19tYWNybzsKCgljcCA9IGxpbmUgKyBzdHJzcG4obGluZSwgYmxhbmspOwoJaWYgKCEqY3AgfHwgKmNwID09ICcjJykKCQlyZXR1cm4gTlVMTDsKCW5hbWUgPSBjcDsKCW5hbWVsZW4gPSBzdHJjc3BuKG5hbWUsIGJsYW5rKTsKCWlmIChzdHJsZW4oQVRUUklCVVRFX01BQ1JPX1BSRUZJWCkgPCBuYW1lbGVuICYmCgkgICAgc3RhcnRzX3dpdGgobmFtZSwgQVRUUklCVVRFX01BQ1JPX1BSRUZJWCkpIHsKCQlpZiAoIW1hY3JvX29rKSB7CgkJCWZwcmludGYoc3RkZXJyLCAiJXMgbm90IGFsbG93ZWQ6ICVzOiVkXG4iLAoJCQkJbmFtZSwgc3JjLCBsaW5lbm8pOwoJCQlyZXR1cm4gTlVMTDsKCQl9CgkJaXNfbWFjcm8gPSAxOwoJCW5hbWUgKz0gc3RybGVuKEFUVFJJQlVURV9NQUNST19QUkVGSVgpOwoJCW5hbWUgKz0gc3Ryc3BuKG5hbWUsIGJsYW5rKTsKCQluYW1lbGVuID0gc3RyY3NwbihuYW1lLCBibGFuayk7CgkJaWYgKGludmFsaWRfYXR0cl9uYW1lKG5hbWUsIG5hbWVsZW4pKSB7CgkJCWZwcmludGYoc3RkZXJyLAoJCQkJIiUuKnMgaXMgbm90IGEgdmFsaWQgYXR0cmlidXRlIG5hbWU6ICVzOiVkXG4iLAoJCQkJbmFtZWxlbiwgbmFtZSwgc3JjLCBsaW5lbm8pOwoJCQlyZXR1cm4gTlVMTDsKCQl9Cgl9CgllbHNlCgkJaXNfbWFjcm8gPSAwOwoKCXN0YXRlcyA9IG5hbWUgKyBuYW1lbGVuOwoJc3RhdGVzICs9IHN0cnNwbihzdGF0ZXMsIGJsYW5rKTsKCgkvKiBGaXJzdCBwYXNzIHRvIGNvdW50IHRoZSBhdHRyX3N0YXRlcyAqLwoJZm9yIChjcCA9IHN0YXRlcywgbnVtX2F0dHIgPSAwOyAqY3A7IG51bV9hdHRyKyspIHsKCQljcCA9IHBhcnNlX2F0dHIoc3JjLCBsaW5lbm8sIGNwLCBOVUxMKTsKCQlpZiAoIWNwKQoJCQlyZXR1cm4gTlVMTDsKCX0KCglyZXMgPSB4Y2FsbG9jKDEsCgkJICAgICAgc2l6ZW9mKCpyZXMpICsKCQkgICAgICBzaXplb2Yoc3RydWN0IGF0dHJfc3RhdGUpICogbnVtX2F0dHIgKwoJCSAgICAgIChpc19tYWNybyA/IDAgOiBuYW1lbGVuICsgMSkpOwoJaWYgKGlzX21hY3JvKSB7CgkJcmVzLT51LmF0dHIgPSBnaXRfYXR0cl9pbnRlcm5hbChuYW1lLCBuYW1lbGVuKTsKCQlyZXMtPnUuYXR0ci0+bWF5YmVfbWFjcm8gPSAxOwoJfSBlbHNlIHsKCQljaGFyICpwID0gKGNoYXIgKikmKHJlcy0+c3RhdGVbbnVtX2F0dHJdKTsKCQltZW1jcHkocCwgbmFtZSwgbmFtZWxlbik7CgkJcmVzLT51LnBhdC5wYXR0ZXJuID0gcDsKCQlwYXJzZV9leGNsdWRlX3BhdHRlcm4oJnJlcy0+dS5wYXQucGF0dGVybiwKCQkJCSAgICAgICZyZXMtPnUucGF0LnBhdHRlcm5sZW4sCgkJCQkgICAgICAmcmVzLT51LnBhdC5mbGFncywKCQkJCSAgICAgICZyZXMtPnUucGF0Lm5vd2lsZGNhcmRsZW4pOwoJCWlmIChyZXMtPnUucGF0LmZsYWdzICYgRVhDX0ZMQUdfTkVHQVRJVkUpIHsKCQkJd2FybmluZyhfKCJOZWdhdGl2ZSBwYXR0ZXJucyBhcmUgaWdub3JlZCBpbiBnaXQgYXR0cmlidXRlc1xuIgoJCQkJICAiVXNlICdcXCEnIGZvciBsaXRlcmFsIGxlYWRpbmcgZXhjbGFtYXRpb24uIikpOwoJCQlyZXR1cm4gTlVMTDsKCQl9Cgl9CglyZXMtPmlzX21hY3JvID0gaXNfbWFjcm87CglyZXMtPm51bV9hdHRyID0gbnVtX2F0dHI7CgoJLyogU2Vjb25kIHBhc3MgdG8gZmlsbCB0aGUgYXR0cl9zdGF0ZXMgKi8KCWZvciAoY3AgPSBzdGF0ZXMsIGkgPSAwOyAqY3A7IGkrKykgewoJCWNwID0gcGFyc2VfYXR0cihzcmMsIGxpbmVubywgY3AsICYocmVzLT5zdGF0ZVtpXSkpOwoJCWlmICghaXNfbWFjcm8pCgkJCXJlcy0+c3RhdGVbaV0uYXR0ci0+bWF5YmVfcmVhbCA9IDE7CgkJaWYgKHJlcy0+c3RhdGVbaV0uYXR0ci0+bWF5YmVfbWFjcm8pCgkJCWNhbm5vdF90cnVzdF9tYXliZV9yZWFsID0gMTsKCX0KCglyZXR1cm4gcmVzOwp9CgovKgogKiBMaWtlIGluZm8vZXhjbHVkZSBhbmQgLmdpdGlnbm9yZSwgdGhlIGF0dHJpYnV0ZSBpbmZvcm1hdGlvbiBjYW4KICogY29tZSBmcm9tIG1hbnkgcGxhY2VzLgogKgogKiAoMSkgLmdpdGF0dHJpYnV0ZSBmaWxlIG9mIHRoZSBzYW1lIGRpcmVjdG9yeTsKICogKDIpIC5naXRhdHRyaWJ1dGUgZmlsZSBvZiB0aGUgcGFyZW50IGRpcmVjdG9yeSBpZiAoMSkgZG9lcyBub3QgaGF2ZQogKiAgICAgIGFueSBtYXRjaDsgdGhpcyBnb2VzIHJlY3Vyc2l2ZWx5IHVwd2FyZHMsIGp1c3QgbGlrZSAuZ2l0aWdub3JlLgogKiAoMykgJEdJVF9ESVIvaW5mby9hdHRyaWJ1dGVzLCB3aGljaCBvdmVycmlkZXMgYm90aCBvZiB0aGUgYWJvdmUuCiAqCiAqIEluIHRoZSBzYW1lIGZpbGUsIGxhdGVyIGVudHJpZXMgb3ZlcnJpZGUgdGhlIGVhcmxpZXIgbWF0Y2gsIHNvIGluIHRoZQogKiBnbG9iYWwgbGlzdCwgd2Ugd291bGQgaGF2ZSBlbnRyaWVzIGZyb20gaW5mby9hdHRyaWJ1dGVzIHRoZSBlYXJsaWVzdAogKiAocmVhZGluZyB0aGUgZmlsZSBmcm9tIHRvcCB0byBib3R0b20pLCAuZ2l0YXR0cmlidXRlIG9mIHRoZSByb290CiAqIGRpcmVjdG9yeSAoYWdhaW4sIHJlYWRpbmcgdGhlIGZpbGUgZnJvbSB0b3AgdG8gYm90dG9tKSBkb3duIHRvIHRoZQogKiBjdXJyZW50IGRpcmVjdG9yeSwgYW5kIHRoZW4gc2NhbiB0aGUgbGlzdCBiYWNrd2FyZHMgdG8gZmluZCB0aGUgZmlyc3QgbWF0Y2guCiAqIFRoaXMgaXMgZXhhY3RseSB0aGUgc2FtZSBhcyB3aGF0IGlzX2V4Y2x1ZGVkKCkgZG9lcyBpbiBkaXIuYyB0byBkZWFsIHdpdGgKICogLmdpdGlnbm9yZQogKi8KCnN0YXRpYyBzdHJ1Y3QgYXR0cl9zdGFjayB7CglzdHJ1Y3QgYXR0cl9zdGFjayAqcHJldjsKCWNoYXIgKm9yaWdpbjsKCXNpemVfdCBvcmlnaW5sZW47Cgl1bnNpZ25lZCBudW1fbWF0Y2hlczsKCXVuc2lnbmVkIGFsbG9jOwoJc3RydWN0IG1hdGNoX2F0dHIgKiphdHRyczsKfSAqYXR0cl9zdGFjazsKCnN0YXRpYyB2b2lkIGZyZWVfYXR0cl9lbGVtKHN0cnVjdCBhdHRyX3N0YWNrICplKQp7CglpbnQgaTsKCWZyZWUoZS0+b3JpZ2luKTsKCWZvciAoaSA9IDA7IGkgPCBlLT5udW1fbWF0Y2hlczsgaSsrKSB7CgkJc3RydWN0IG1hdGNoX2F0dHIgKmEgPSBlLT5hdHRyc1tpXTsKCQlpbnQgajsKCQlmb3IgKGogPSAwOyBqIDwgYS0+bnVtX2F0dHI7IGorKykgewoJCQljb25zdCBjaGFyICpzZXR0byA9IGEtPnN0YXRlW2pdLnNldHRvOwoJCQlpZiAoc2V0dG8gPT0gQVRUUl9fVFJVRSB8fAoJCQkgICAgc2V0dG8gPT0gQVRUUl9fRkFMU0UgfHwKCQkJICAgIHNldHRvID09IEFUVFJfX1VOU0VUIHx8CgkJCSAgICBzZXR0byA9PSBBVFRSX19VTktOT1dOKQoJCQkJOwoJCQllbHNlCgkJCQlmcmVlKChjaGFyICopIHNldHRvKTsKCQl9CgkJZnJlZShhKTsKCX0KCWZyZWUoZS0+YXR0cnMpOwoJZnJlZShlKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKmJ1aWx0aW5fYXR0cltdID0gewoJIlthdHRyXWJpbmFyeSAtZGlmZiAtbWVyZ2UgLXRleHQiLAoJTlVMTCwKfTsKCnN0YXRpYyB2b2lkIGhhbmRsZV9hdHRyX2xpbmUoc3RydWN0IGF0dHJfc3RhY2sgKnJlcywKCQkJICAgICBjb25zdCBjaGFyICpsaW5lLAoJCQkgICAgIGNvbnN0IGNoYXIgKnNyYywKCQkJICAgICBpbnQgbGluZW5vLAoJCQkgICAgIGludCBtYWNyb19vaykKewoJc3RydWN0IG1hdGNoX2F0dHIgKmE7CgoJYSA9IHBhcnNlX2F0dHJfbGluZShsaW5lLCBzcmMsIGxpbmVubywgbWFjcm9fb2spOwoJaWYgKCFhKQoJCXJldHVybjsKCUFMTE9DX0dST1cocmVzLT5hdHRycywgcmVzLT5udW1fbWF0Y2hlcyArIDEsIHJlcy0+YWxsb2MpOwoJcmVzLT5hdHRyc1tyZXMtPm51bV9tYXRjaGVzKytdID0gYTsKfQoKc3RhdGljIHN0cnVjdCBhdHRyX3N0YWNrICpyZWFkX2F0dHJfZnJvbV9hcnJheShjb25zdCBjaGFyICoqbGlzdCkKewoJc3RydWN0IGF0dHJfc3RhY2sgKnJlczsKCWNvbnN0IGNoYXIgKmxpbmU7CglpbnQgbGluZW5vID0gMDsKCglyZXMgPSB4Y2FsbG9jKDEsIHNpemVvZigqcmVzKSk7Cgl3aGlsZSAoKGxpbmUgPSAqKGxpc3QrKykpICE9IE5VTEwpCgkJaGFuZGxlX2F0dHJfbGluZShyZXMsIGxpbmUsICJbYnVpbHRpbl0iLCArK2xpbmVubywgMSk7CglyZXR1cm4gcmVzOwp9CgpzdGF0aWMgZW51bSBnaXRfYXR0cl9kaXJlY3Rpb24gZGlyZWN0aW9uOwpzdGF0aWMgc3RydWN0IGluZGV4X3N0YXRlICp1c2VfaW5kZXg7CgpzdGF0aWMgc3RydWN0IGF0dHJfc3RhY2sgKnJlYWRfYXR0cl9mcm9tX2ZpbGUoY29uc3QgY2hhciAqcGF0aCwgaW50IG1hY3JvX29rKQp7CglGSUxFICpmcCA9IGZvcGVuKHBhdGgsICJyIik7CglzdHJ1Y3QgYXR0cl9zdGFjayAqcmVzOwoJY2hhciBidWZbMjA0OF07CglpbnQgbGluZW5vID0gMDsKCglpZiAoIWZwKSB7CgkJaWYgKGVycm5vICE9IEVOT0VOVCAmJiBlcnJubyAhPSBFTk9URElSKQoJCQl3YXJuX29uX2luYWNjZXNzaWJsZShwYXRoKTsKCQlyZXR1cm4gTlVMTDsKCX0KCXJlcyA9IHhjYWxsb2MoMSwgc2l6ZW9mKCpyZXMpKTsKCXdoaWxlIChmZ2V0cyhidWYsIHNpemVvZihidWYpLCBmcCkpIHsKCQljaGFyICpidWZwID0gYnVmOwoJCWlmICghbGluZW5vKQoJCQlza2lwX3V0ZjhfYm9tKCZidWZwLCBzdHJsZW4oYnVmcCkpOwoJCWhhbmRsZV9hdHRyX2xpbmUocmVzLCBidWZwLCBwYXRoLCArK2xpbmVubywgbWFjcm9fb2spOwoJfQoJZmNsb3NlKGZwKTsKCXJldHVybiByZXM7Cn0KCnN0YXRpYyBzdHJ1Y3QgYXR0cl9zdGFjayAqcmVhZF9hdHRyX2Zyb21faW5kZXgoY29uc3QgY2hhciAqcGF0aCwgaW50IG1hY3JvX29rKQp7CglzdHJ1Y3QgYXR0cl9zdGFjayAqcmVzOwoJY2hhciAqYnVmLCAqc3A7CglpbnQgbGluZW5vID0gMDsKCglidWYgPSByZWFkX2Jsb2JfZGF0YV9mcm9tX2luZGV4KHVzZV9pbmRleCA/IHVzZV9pbmRleCA6ICZ0aGVfaW5kZXgsIHBhdGgsIE5VTEwpOwoJaWYgKCFidWYpCgkJcmV0dXJuIE5VTEw7CgoJcmVzID0geGNhbGxvYygxLCBzaXplb2YoKnJlcykpOwoJZm9yIChzcCA9IGJ1ZjsgKnNwOyApIHsKCQljaGFyICplcDsKCQlpbnQgbW9yZTsKCgkJZXAgPSBzdHJjaHJudWwoc3AsICdcbicpOwoJCW1vcmUgPSAoKmVwID09ICdcbicpOwoJCSplcCA9ICdcMCc7CgkJaGFuZGxlX2F0dHJfbGluZShyZXMsIHNwLCBwYXRoLCArK2xpbmVubywgbWFjcm9fb2spOwoJCXNwID0gZXAgKyBtb3JlOwoJfQoJZnJlZShidWYpOwoJcmV0dXJuIHJlczsKfQoKc3RhdGljIHN0cnVjdCBhdHRyX3N0YWNrICpyZWFkX2F0dHIoY29uc3QgY2hhciAqcGF0aCwgaW50IG1hY3JvX29rKQp7CglzdHJ1Y3QgYXR0cl9zdGFjayAqcmVzOwoKCWlmIChkaXJlY3Rpb24gPT0gR0lUX0FUVFJfQ0hFQ0tPVVQpIHsKCQlyZXMgPSByZWFkX2F0dHJfZnJvbV9pbmRleChwYXRoLCBtYWNyb19vayk7CgkJaWYgKCFyZXMpCgkJCXJlcyA9IHJlYWRfYXR0cl9mcm9tX2ZpbGUocGF0aCwgbWFjcm9fb2spOwoJfQoJZWxzZSBpZiAoZGlyZWN0aW9uID09IEdJVF9BVFRSX0NIRUNLSU4pIHsKCQlyZXMgPSByZWFkX2F0dHJfZnJvbV9maWxlKHBhdGgsIG1hY3JvX29rKTsKCQlpZiAoIXJlcykKCQkJLyoKCQkJICogVGhlcmUgaXMgbm8gY2hlY2tlZCBvdXQgLmdpdGF0dHJpYnV0ZXMgZmlsZSB0aGVyZSwgYnV0CgkJCSAqIHdlIG1pZ2h0IGhhdmUgaXQgaW4gdGhlIGluZGV4LiAgV2UgYWxsb3cgb3BlcmF0aW9uIGluIGEKCQkJICogc3BhcnNlbHkgY2hlY2tlZCBvdXQgd29yayB0cmVlLCBzbyByZWFkIGZyb20gaXQuCgkJCSAqLwoJCQlyZXMgPSByZWFkX2F0dHJfZnJvbV9pbmRleChwYXRoLCBtYWNyb19vayk7Cgl9CgllbHNlCgkJcmVzID0gcmVhZF9hdHRyX2Zyb21faW5kZXgocGF0aCwgbWFjcm9fb2spOwoJaWYgKCFyZXMpCgkJcmVzID0geGNhbGxvYygxLCBzaXplb2YoKnJlcykpOwoJcmV0dXJuIHJlczsKfQoKI2lmIERFQlVHX0FUVFIKc3RhdGljIHZvaWQgZGVidWdfaW5mbyhjb25zdCBjaGFyICp3aGF0LCBzdHJ1Y3QgYXR0cl9zdGFjayAqZWxlbSkKewoJZnByaW50ZihzdGRlcnIsICIlczogJXNcbiIsIHdoYXQsIGVsZW0tPm9yaWdpbiA/IGVsZW0tPm9yaWdpbiA6ICIoKSIpOwp9CnN0YXRpYyB2b2lkIGRlYnVnX3NldChjb25zdCBjaGFyICp3aGF0LCBjb25zdCBjaGFyICptYXRjaCwgc3RydWN0IGdpdF9hdHRyICphdHRyLCBjb25zdCB2b2lkICp2KQp7Cgljb25zdCBjaGFyICp2YWx1ZSA9IHY7CgoJaWYgKEFUVFJfVFJVRSh2YWx1ZSkpCgkJdmFsdWUgPSAic2V0IjsKCWVsc2UgaWYgKEFUVFJfRkFMU0UodmFsdWUpKQoJCXZhbHVlID0gInVuc2V0IjsKCWVsc2UgaWYgKEFUVFJfVU5TRVQodmFsdWUpKQoJCXZhbHVlID0gInVuc3BlY2lmaWVkIjsKCglmcHJpbnRmKHN0ZGVyciwgIiVzOiAlcyA9PiAlcyAoJXMpXG4iLAoJCXdoYXQsIGF0dHItPm5hbWUsIChjaGFyICopIHZhbHVlLCBtYXRjaCk7Cn0KI2RlZmluZSBkZWJ1Z19wdXNoKGEpIGRlYnVnX2luZm8oInB1c2giLCAoYSkpCiNkZWZpbmUgZGVidWdfcG9wKGEpIGRlYnVnX2luZm8oInBvcCIsIChhKSkKI2Vsc2UKI2RlZmluZSBkZWJ1Z19wdXNoKGEpIGRvIHsgOyB9IHdoaWxlICgwKQojZGVmaW5lIGRlYnVnX3BvcChhKSBkbyB7IDsgfSB3aGlsZSAoMCkKI2RlZmluZSBkZWJ1Z19zZXQoYSxiLGMsZCkgZG8geyA7IH0gd2hpbGUgKDApCiNlbmRpZgoKc3RhdGljIHZvaWQgZHJvcF9hdHRyX3N0YWNrKHZvaWQpCnsKCXdoaWxlIChhdHRyX3N0YWNrKSB7CgkJc3RydWN0IGF0dHJfc3RhY2sgKmVsZW0gPSBhdHRyX3N0YWNrOwoJCWF0dHJfc3RhY2sgPSBlbGVtLT5wcmV2OwoJCWZyZWVfYXR0cl9lbGVtKGVsZW0pOwoJfQp9CgpzdGF0aWMgY29uc3QgY2hhciAqZ2l0X2V0Y19naXRhdHRyaWJ1dGVzKHZvaWQpCnsKCXN0YXRpYyBjb25zdCBjaGFyICpzeXN0ZW1fd2lkZTsKCWlmICghc3lzdGVtX3dpZGUpCgkJc3lzdGVtX3dpZGUgPSBzeXN0ZW1fcGF0aChFVENfR0lUQVRUUklCVVRFUyk7CglyZXR1cm4gc3lzdGVtX3dpZGU7Cn0KCnN0YXRpYyBpbnQgZ2l0X2F0dHJfc3lzdGVtKHZvaWQpCnsKCXJldHVybiAhZ2l0X2Vudl9ib29sKCJHSVRfQVRUUl9OT1NZU1RFTSIsIDApOwp9CgpzdGF0aWMgR0lUX1BBVEhfRlVOQyhnaXRfcGF0aF9pbmZvX2F0dHJpYnV0ZXMsIElORk9BVFRSSUJVVEVTX0ZJTEUpCgpzdGF0aWMgdm9pZCBib290c3RyYXBfYXR0cl9zdGFjayh2b2lkKQp7CglzdHJ1Y3QgYXR0cl9zdGFjayAqZWxlbTsKCglpZiAoYXR0cl9zdGFjaykKCQlyZXR1cm47CgoJZWxlbSA9IHJlYWRfYXR0cl9mcm9tX2FycmF5KGJ1aWx0aW5fYXR0cik7CgllbGVtLT5vcmlnaW4gPSBOVUxMOwoJZWxlbS0+cHJldiA9IGF0dHJfc3RhY2s7CglhdHRyX3N0YWNrID0gZWxlbTsKCglpZiAoZ2l0X2F0dHJfc3lzdGVtKCkpIHsKCQllbGVtID0gcmVhZF9hdHRyX2Zyb21fZmlsZShnaXRfZXRjX2dpdGF0dHJpYnV0ZXMoKSwgMSk7CgkJaWYgKGVsZW0pIHsKCQkJZWxlbS0+b3JpZ2luID0gTlVMTDsKCQkJZWxlbS0+cHJldiA9IGF0dHJfc3RhY2s7CgkJCWF0dHJfc3RhY2sgPSBlbGVtOwoJCX0KCX0KCglpZiAoIWdpdF9hdHRyaWJ1dGVzX2ZpbGUpCgkJZ2l0X2F0dHJpYnV0ZXNfZmlsZSA9IHhkZ19jb25maWdfaG9tZSgiYXR0cmlidXRlcyIpOwoJaWYgKGdpdF9hdHRyaWJ1dGVzX2ZpbGUpIHsKCQllbGVtID0gcmVhZF9hdHRyX2Zyb21fZmlsZShnaXRfYXR0cmlidXRlc19maWxlLCAxKTsKCQlpZiAoZWxlbSkgewoJCQllbGVtLT5vcmlnaW4gPSBOVUxMOwoJCQllbGVtLT5wcmV2ID0gYXR0cl9zdGFjazsKCQkJYXR0cl9zdGFjayA9IGVsZW07CgkJfQoJfQoKCWlmICghaXNfYmFyZV9yZXBvc2l0b3J5KCkgfHwgZGlyZWN0aW9uID09IEdJVF9BVFRSX0lOREVYKSB7CgkJZWxlbSA9IHJlYWRfYXR0cihHSVRBVFRSSUJVVEVTX0ZJTEUsIDEpOwoJCWVsZW0tPm9yaWdpbiA9IHhzdHJkdXAoIiIpOwoJCWVsZW0tPm9yaWdpbmxlbiA9IDA7CgkJZWxlbS0+cHJldiA9IGF0dHJfc3RhY2s7CgkJYXR0cl9zdGFjayA9IGVsZW07CgkJZGVidWdfcHVzaChlbGVtKTsKCX0KCglpZiAoc3RhcnR1cF9pbmZvLT5oYXZlX3JlcG9zaXRvcnkpCgkJZWxlbSA9IHJlYWRfYXR0cl9mcm9tX2ZpbGUoZ2l0X3BhdGhfaW5mb19hdHRyaWJ1dGVzKCksIDEpOwoJZWxzZQoJCWVsZW0gPSBOVUxMOwoKCWlmICghZWxlbSkKCQllbGVtID0geGNhbGxvYygxLCBzaXplb2YoKmVsZW0pKTsKCWVsZW0tPm9yaWdpbiA9IE5VTEw7CgllbGVtLT5wcmV2ID0gYXR0cl9zdGFjazsKCWF0dHJfc3RhY2sgPSBlbGVtOwp9CgpzdGF0aWMgdm9pZCBwcmVwYXJlX2F0dHJfc3RhY2soY29uc3QgY2hhciAqcGF0aCwgaW50IGRpcmxlbikKewoJc3RydWN0IGF0dHJfc3RhY2sgKmVsZW0sICppbmZvOwoJaW50IGxlbjsKCWNvbnN0IGNoYXIgKmNwOwoKCS8qCgkgKiBBdCB0aGUgYm90dG9tIG9mIHRoZSBhdHRyaWJ1dGUgc3RhY2sgaXMgdGhlIGJ1aWx0LWluCgkgKiBzZXQgb2YgYXR0cmlidXRlIGRlZmluaXRpb25zLCBmb2xsb3dlZCBieSB0aGUgY29udGVudHMKCSAqIG9mICQocHJlZml4KS9ldGMvZ2l0YXR0cmlidXRlcyBhbmQgYSBmaWxlIHNwZWNpZmllZCBieQoJICogY29yZS5hdHRyaWJ1dGVzZmlsZS4gIFRoZW4sIGNvbnRlbnRzIGZyb20KCSAqIC5naXRhdHRyaWJ1dGUgZmlsZXMgZnJvbSBkaXJlY3RvcmllcyBjbG9zZXIgdG8gdGhlCgkgKiByb290IHRvIHRoZSBvbmVzIGluIGRlZXBlciBkaXJlY3RvcmllcyBhcmUgcHVzaGVkCgkgKiB0byB0aGUgc3RhY2suICBGaW5hbGx5LCBhdCB0aGUgdmVyeSB0b3Agb2YgdGhlIHN0YWNrCgkgKiB3ZSBhbHdheXMga2VlcCB0aGUgY29udGVudHMgb2YgJEdJVF9ESVIvaW5mby9hdHRyaWJ1dGVzLgoJICoKCSAqIFdoZW4gY2hlY2tpbmcsIHdlIHVzZSBlbnRyaWVzIGZyb20gbmVhciB0aGUgdG9wIG9mIHRoZQoJICogc3RhY2ssIHByZWZlcnJpbmcgJEdJVF9ESVIvaW5mby9hdHRyaWJ1dGVzLCB0aGVuCgkgKiAuZ2l0YXR0cmlidXRlcyBpbiBkZWVwZXIgZGlyZWN0b3JpZXMgdG8gc2hhbGxvd2VyIG9uZXMsCgkgKiBhbmQgZmluYWxseSB1c2UgdGhlIGJ1aWx0LWluIHNldCBhcyB0aGUgZGVmYXVsdC4KCSAqLwoJYm9vdHN0cmFwX2F0dHJfc3RhY2soKTsKCgkvKgoJICogUG9wIHRoZSAiaW5mbyIgb25lIHRoYXQgaXMgYWx3YXlzIGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrLgoJICovCglpbmZvID0gYXR0cl9zdGFjazsKCWF0dHJfc3RhY2sgPSBpbmZvLT5wcmV2OwoKCS8qCgkgKiBQb3AgdGhlIG9uZXMgZnJvbSBkaXJlY3RvcmllcyB0aGF0IGFyZSBub3QgdGhlIHByZWZpeCBvZgoJICogdGhlIHBhdGggd2UgYXJlIGNoZWNraW5nLiBCcmVhayBvdXQgb2YgdGhlIGxvb3Agd2hlbiB3ZSBzZWUKCSAqIHRoZSByb290IG9uZSAod2hvc2Ugb3JpZ2luIGlzIGFuIGVtcHR5IHN0cmluZyAiIikgb3IgdGhlIGJ1aWx0aW4KCSAqIG9uZSAod2hvc2Ugb3JpZ2luIGlzIE5VTEwpIHdpdGhvdXQgcG9wcGluZyBpdC4KCSAqLwoJd2hpbGUgKGF0dHJfc3RhY2stPm9yaWdpbikgewoJCWludCBuYW1lbGVuID0gc3RybGVuKGF0dHJfc3RhY2stPm9yaWdpbik7CgoJCWVsZW0gPSBhdHRyX3N0YWNrOwoJCWlmIChuYW1lbGVuIDw9IGRpcmxlbiAmJgoJCSAgICAhc3RybmNtcChlbGVtLT5vcmlnaW4sIHBhdGgsIG5hbWVsZW4pICYmCgkJICAgICghbmFtZWxlbiB8fCBwYXRoW25hbWVsZW5dID09ICcvJykpCgkJCWJyZWFrOwoKCQlkZWJ1Z19wb3AoZWxlbSk7CgkJYXR0cl9zdGFjayA9IGVsZW0tPnByZXY7CgkJZnJlZV9hdHRyX2VsZW0oZWxlbSk7Cgl9CgoJLyoKCSAqIFJlYWQgZnJvbSBwYXJlbnQgZGlyZWN0b3JpZXMgYW5kIHB1c2ggdGhlbSBkb3duCgkgKi8KCWlmICghaXNfYmFyZV9yZXBvc2l0b3J5KCkgfHwgZGlyZWN0aW9uID09IEdJVF9BVFRSX0lOREVYKSB7CgkJLyoKCQkgKiBib290c3RyYXBfYXR0cl9zdGFjaygpIHNob3VsZCBoYXZlIGFkZGVkLCBhbmQgdGhlCgkJICogYWJvdmUgbG9vcCBzaG91bGQgaGF2ZSBzdG9wcGVkIGJlZm9yZSBwb3BwaW5nLCB0aGUKCQkgKiByb290IGVsZW1lbnQgd2hvc2UgYXR0cl9zdGFjay0+b3JpZ2luIGlzIHNldCB0byBhbgoJCSAqIGVtcHR5IHN0cmluZy4KCQkgKi8KCQlzdHJ1Y3Qgc3RyYnVmIHBhdGhidWYgPSBTVFJCVUZfSU5JVDsKCgkJYXNzZXJ0KGF0dHJfc3RhY2stPm9yaWdpbik7CgkJd2hpbGUgKDEpIHsKCQkJbGVuID0gc3RybGVuKGF0dHJfc3RhY2stPm9yaWdpbik7CgkJCWlmIChkaXJsZW4gPD0gbGVuKQoJCQkJYnJlYWs7CgkJCWNwID0gbWVtY2hyKHBhdGggKyBsZW4gKyAxLCAnLycsIGRpcmxlbiAtIGxlbiAtIDEpOwoJCQlpZiAoIWNwKQoJCQkJY3AgPSBwYXRoICsgZGlybGVuOwoJCQlzdHJidWZfYWRkKCZwYXRoYnVmLCBwYXRoLCBjcCAtIHBhdGgpOwoJCQlzdHJidWZfYWRkY2goJnBhdGhidWYsICcvJyk7CgkJCXN0cmJ1Zl9hZGRzdHIoJnBhdGhidWYsIEdJVEFUVFJJQlVURVNfRklMRSk7CgkJCWVsZW0gPSByZWFkX2F0dHIocGF0aGJ1Zi5idWYsIDApOwoJCQlzdHJidWZfc2V0bGVuKCZwYXRoYnVmLCBjcCAtIHBhdGgpOwoJCQllbGVtLT5vcmlnaW4gPSBzdHJidWZfZGV0YWNoKCZwYXRoYnVmLCAmZWxlbS0+b3JpZ2lubGVuKTsKCQkJZWxlbS0+cHJldiA9IGF0dHJfc3RhY2s7CgkJCWF0dHJfc3RhY2sgPSBlbGVtOwoJCQlkZWJ1Z19wdXNoKGVsZW0pOwoJCX0KCgkJc3RyYnVmX3JlbGVhc2UoJnBhdGhidWYpOwoJfQoKCS8qCgkgKiBGaW5hbGx5IHB1c2ggdGhlICJpbmZvIiBvbmUgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2suCgkgKi8KCWluZm8tPnByZXYgPSBhdHRyX3N0YWNrOwoJYXR0cl9zdGFjayA9IGluZm87Cn0KCnN0YXRpYyBpbnQgcGF0aF9tYXRjaGVzKGNvbnN0IGNoYXIgKnBhdGhuYW1lLCBpbnQgcGF0aGxlbiwKCQkJaW50IGJhc2VuYW1lX29mZnNldCwKCQkJY29uc3Qgc3RydWN0IHBhdHRlcm4gKnBhdCwKCQkJY29uc3QgY2hhciAqYmFzZSwgaW50IGJhc2VsZW4pCnsKCWNvbnN0IGNoYXIgKnBhdHRlcm4gPSBwYXQtPnBhdHRlcm47CglpbnQgcHJlZml4ID0gcGF0LT5ub3dpbGRjYXJkbGVuOwoJaW50IGlzZGlyID0gKHBhdGhsZW4gJiYgcGF0aG5hbWVbcGF0aGxlbiAtIDFdID09ICcvJyk7CgoJaWYgKChwYXQtPmZsYWdzICYgRVhDX0ZMQUdfTVVTVEJFRElSKSAmJiAhaXNkaXIpCgkJcmV0dXJuIDA7CgoJaWYgKHBhdC0+ZmxhZ3MgJiBFWENfRkxBR19OT0RJUikgewoJCXJldHVybiBtYXRjaF9iYXNlbmFtZShwYXRobmFtZSArIGJhc2VuYW1lX29mZnNldCwKCQkJCSAgICAgIHBhdGhsZW4gLSBiYXNlbmFtZV9vZmZzZXQgLSBpc2RpciwKCQkJCSAgICAgIHBhdHRlcm4sIHByZWZpeCwKCQkJCSAgICAgIHBhdC0+cGF0dGVybmxlbiwgcGF0LT5mbGFncyk7Cgl9CglyZXR1cm4gbWF0Y2hfcGF0aG5hbWUocGF0aG5hbWUsIHBhdGhsZW4gLSBpc2RpciwKCQkJICAgICAgYmFzZSwgYmFzZWxlbiwKCQkJICAgICAgcGF0dGVybiwgcHJlZml4LCBwYXQtPnBhdHRlcm5sZW4sIHBhdC0+ZmxhZ3MpOwp9CgpzdGF0aWMgaW50IG1hY3JvZXhwYW5kX29uZShpbnQgYXR0cl9uciwgaW50IHJlbSk7CgpzdGF0aWMgaW50IGZpbGxfb25lKGNvbnN0IGNoYXIgKndoYXQsIHN0cnVjdCBtYXRjaF9hdHRyICphLCBpbnQgcmVtKQp7CglzdHJ1Y3QgZ2l0X2F0dHJfY2hlY2sgKmNoZWNrID0gY2hlY2tfYWxsX2F0dHI7CglpbnQgaTsKCglmb3IgKGkgPSBhLT5udW1fYXR0ciAtIDE7IDAgPCByZW0gJiYgMCA8PSBpOyBpLS0pIHsKCQlzdHJ1Y3QgZ2l0X2F0dHIgKmF0dHIgPSBhLT5zdGF0ZVtpXS5hdHRyOwoJCWNvbnN0IGNoYXIgKipuID0gJihjaGVja1thdHRyLT5hdHRyX25yXS52YWx1ZSk7CgkJY29uc3QgY2hhciAqdiA9IGEtPnN0YXRlW2ldLnNldHRvOwoKCQlpZiAoKm4gPT0gQVRUUl9fVU5LTk9XTikgewoJCQlkZWJ1Z19zZXQod2hhdCwKCQkJCSAgYS0+aXNfbWFjcm8gPyBhLT51LmF0dHItPm5hbWUgOiBhLT51LnBhdC5wYXR0ZXJuLAoJCQkJICBhdHRyLCB2KTsKCQkJKm4gPSB2OwoJCQlyZW0tLTsKCQkJcmVtID0gbWFjcm9leHBhbmRfb25lKGF0dHItPmF0dHJfbnIsIHJlbSk7CgkJfQoJfQoJcmV0dXJuIHJlbTsKfQoKc3RhdGljIGludCBmaWxsKGNvbnN0IGNoYXIgKnBhdGgsIGludCBwYXRobGVuLCBpbnQgYmFzZW5hbWVfb2Zmc2V0LAoJCXN0cnVjdCBhdHRyX3N0YWNrICpzdGssIGludCByZW0pCnsKCWludCBpOwoJY29uc3QgY2hhciAqYmFzZSA9IHN0ay0+b3JpZ2luID8gc3RrLT5vcmlnaW4gOiAiIjsKCglmb3IgKGkgPSBzdGstPm51bV9tYXRjaGVzIC0gMTsgMCA8IHJlbSAmJiAwIDw9IGk7IGktLSkgewoJCXN0cnVjdCBtYXRjaF9hdHRyICphID0gc3RrLT5hdHRyc1tpXTsKCQlpZiAoYS0+aXNfbWFjcm8pCgkJCWNvbnRpbnVlOwoJCWlmIChwYXRoX21hdGNoZXMocGF0aCwgcGF0aGxlbiwgYmFzZW5hbWVfb2Zmc2V0LAoJCQkJICZhLT51LnBhdCwgYmFzZSwgc3RrLT5vcmlnaW5sZW4pKQoJCQlyZW0gPSBmaWxsX29uZSgiZmlsbCIsIGEsIHJlbSk7Cgl9CglyZXR1cm4gcmVtOwp9CgpzdGF0aWMgaW50IG1hY3JvZXhwYW5kX29uZShpbnQgbnIsIGludCByZW0pCnsKCXN0cnVjdCBhdHRyX3N0YWNrICpzdGs7CglzdHJ1Y3QgbWF0Y2hfYXR0ciAqYSA9IE5VTEw7CglpbnQgaTsKCglpZiAoY2hlY2tfYWxsX2F0dHJbbnJdLnZhbHVlICE9IEFUVFJfX1RSVUUgfHwKCSAgICAhY2hlY2tfYWxsX2F0dHJbbnJdLmF0dHItPm1heWJlX21hY3JvKQoJCXJldHVybiByZW07CgoJZm9yIChzdGsgPSBhdHRyX3N0YWNrOyAhYSAmJiBzdGs7IHN0ayA9IHN0ay0+cHJldikKCQlmb3IgKGkgPSBzdGstPm51bV9tYXRjaGVzIC0gMTsgIWEgJiYgMCA8PSBpOyBpLS0pIHsKCQkJc3RydWN0IG1hdGNoX2F0dHIgKm1hID0gc3RrLT5hdHRyc1tpXTsKCQkJaWYgKCFtYS0+aXNfbWFjcm8pCgkJCQljb250aW51ZTsKCQkJaWYgKG1hLT51LmF0dHItPmF0dHJfbnIgPT0gbnIpCgkJCQlhID0gbWE7CgkJfQoKCWlmIChhKQoJCXJlbSA9IGZpbGxfb25lKCJleHBhbmQiLCBhLCByZW0pOwoKCXJldHVybiByZW07Cn0KCi8qCiAqIENvbGxlY3QgYXR0cmlidXRlcyBmb3IgcGF0aCBpbnRvIHRoZSBhcnJheSBwb2ludGVkIHRvIGJ5CiAqIGNoZWNrX2FsbF9hdHRyLiBJZiBudW0gaXMgbm9uLXplcm8sIG9ubHkgYXR0cmlidXRlcyBpbiBjaGVja1tdIGFyZQogKiBjb2xsZWN0ZWQuIE90aGVyd2lzZSBhbGwgYXR0cmlidXRlcyBhcmUgY29sbGVjdGVkLgogKi8Kc3RhdGljIHZvaWQgY29sbGVjdF9zb21lX2F0dHJzKGNvbnN0IGNoYXIgKnBhdGgsIGludCBudW0sCgkJCSAgICAgICBzdHJ1Y3QgZ2l0X2F0dHJfY2hlY2sgKmNoZWNrKQoKewoJc3RydWN0IGF0dHJfc3RhY2sgKnN0azsKCWludCBpLCBwYXRobGVuLCByZW0sIGRpcmxlbjsKCWNvbnN0IGNoYXIgKmNwLCAqbGFzdF9zbGFzaCA9IE5VTEw7CglpbnQgYmFzZW5hbWVfb2Zmc2V0OwoKCWZvciAoY3AgPSBwYXRoOyAqY3A7IGNwKyspIHsKCQlpZiAoKmNwID09ICcvJyAmJiBjcFsxXSkKCQkJbGFzdF9zbGFzaCA9IGNwOwoJfQoJcGF0aGxlbiA9IGNwIC0gcGF0aDsKCWlmIChsYXN0X3NsYXNoKSB7CgkJYmFzZW5hbWVfb2Zmc2V0ID0gbGFzdF9zbGFzaCArIDEgLSBwYXRoOwoJCWRpcmxlbiA9IGxhc3Rfc2xhc2ggLSBwYXRoOwoJfSBlbHNlIHsKCQliYXNlbmFtZV9vZmZzZXQgPSAwOwoJCWRpcmxlbiA9IDA7Cgl9CgoJcHJlcGFyZV9hdHRyX3N0YWNrKHBhdGgsIGRpcmxlbik7Cglmb3IgKGkgPSAwOyBpIDwgYXR0cl9ucjsgaSsrKQoJCWNoZWNrX2FsbF9hdHRyW2ldLnZhbHVlID0gQVRUUl9fVU5LTk9XTjsKCWlmIChudW0gJiYgIWNhbm5vdF90cnVzdF9tYXliZV9yZWFsKSB7CgkJcmVtID0gMDsKCQlmb3IgKGkgPSAwOyBpIDwgbnVtOyBpKyspIHsKCQkJaWYgKCFjaGVja1tpXS5hdHRyLT5tYXliZV9yZWFsKSB7CgkJCQlzdHJ1Y3QgZ2l0X2F0dHJfY2hlY2sgKmM7CgkJCQljID0gY2hlY2tfYWxsX2F0dHIgKyBjaGVja1tpXS5hdHRyLT5hdHRyX25yOwoJCQkJYy0+dmFsdWUgPSBBVFRSX19VTlNFVDsKCQkJCXJlbSsrOwoJCQl9CgkJfQoJCWlmIChyZW0gPT0gbnVtKQoJCQlyZXR1cm47Cgl9CgoJcmVtID0gYXR0cl9ucjsKCWZvciAoc3RrID0gYXR0cl9zdGFjazsgMCA8IHJlbSAmJiBzdGs7IHN0ayA9IHN0ay0+cHJldikKCQlyZW0gPSBmaWxsKHBhdGgsIHBhdGhsZW4sIGJhc2VuYW1lX29mZnNldCwgc3RrLCByZW0pOwp9CgppbnQgZ2l0X2NoZWNrX2F0dHIoY29uc3QgY2hhciAqcGF0aCwgaW50IG51bSwgc3RydWN0IGdpdF9hdHRyX2NoZWNrICpjaGVjaykKewoJaW50IGk7CgoJY29sbGVjdF9zb21lX2F0dHJzKHBhdGgsIG51bSwgY2hlY2spOwoKCWZvciAoaSA9IDA7IGkgPCBudW07IGkrKykgewoJCWNvbnN0IGNoYXIgKnZhbHVlID0gY2hlY2tfYWxsX2F0dHJbY2hlY2tbaV0uYXR0ci0+YXR0cl9ucl0udmFsdWU7CgkJaWYgKHZhbHVlID09IEFUVFJfX1VOS05PV04pCgkJCXZhbHVlID0gQVRUUl9fVU5TRVQ7CgkJY2hlY2tbaV0udmFsdWUgPSB2YWx1ZTsKCX0KCglyZXR1cm4gMDsKfQoKaW50IGdpdF9hbGxfYXR0cnMoY29uc3QgY2hhciAqcGF0aCwgaW50ICpudW0sIHN0cnVjdCBnaXRfYXR0cl9jaGVjayAqKmNoZWNrKQp7CglpbnQgaSwgY291bnQsIGo7CgoJY29sbGVjdF9zb21lX2F0dHJzKHBhdGgsIDAsIE5VTEwpOwoKCS8qIENvdW50IHRoZSBudW1iZXIgb2YgYXR0cmlidXRlcyB0aGF0IGFyZSBzZXQuICovCgljb3VudCA9IDA7Cglmb3IgKGkgPSAwOyBpIDwgYXR0cl9ucjsgaSsrKSB7CgkJY29uc3QgY2hhciAqdmFsdWUgPSBjaGVja19hbGxfYXR0cltpXS52YWx1ZTsKCQlpZiAodmFsdWUgIT0gQVRUUl9fVU5TRVQgJiYgdmFsdWUgIT0gQVRUUl9fVU5LTk9XTikKCQkJKytjb3VudDsKCX0KCSpudW0gPSBjb3VudDsKCUFMTE9DX0FSUkFZKCpjaGVjaywgY291bnQpOwoJaiA9IDA7Cglmb3IgKGkgPSAwOyBpIDwgYXR0cl9ucjsgaSsrKSB7CgkJY29uc3QgY2hhciAqdmFsdWUgPSBjaGVja19hbGxfYXR0cltpXS52YWx1ZTsKCQlpZiAodmFsdWUgIT0gQVRUUl9fVU5TRVQgJiYgdmFsdWUgIT0gQVRUUl9fVU5LTk9XTikgewoJCQkoKmNoZWNrKVtqXS5hdHRyID0gY2hlY2tfYWxsX2F0dHJbaV0uYXR0cjsKCQkJKCpjaGVjaylbal0udmFsdWUgPSB2YWx1ZTsKCQkJKytqOwoJCX0KCX0KCglyZXR1cm4gMDsKfQoKdm9pZCBnaXRfYXR0cl9zZXRfZGlyZWN0aW9uKGVudW0gZ2l0X2F0dHJfZGlyZWN0aW9uIG5ldywgc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUpCnsKCWVudW0gZ2l0X2F0dHJfZGlyZWN0aW9uIG9sZCA9IGRpcmVjdGlvbjsKCglpZiAoaXNfYmFyZV9yZXBvc2l0b3J5KCkgJiYgbmV3ICE9IEdJVF9BVFRSX0lOREVYKQoJCWRpZSgiQlVHOiBub24tSU5ERVggYXR0ciBkaXJlY3Rpb24gaW4gYSBiYXJlIHJlcG8iKTsKCglkaXJlY3Rpb24gPSBuZXc7CglpZiAobmV3ICE9IG9sZCkKCQlkcm9wX2F0dHJfc3RhY2soKTsKCXVzZV9pbmRleCA9IGlzdGF0ZTsKfQo=",
    "text": "/*\n * Handle git attributes.  See gitattributes(5) for a description of\n * the file syntax, and Documentation/technical/api-gitattributes.txt\n * for a description of the API.\n *\n * One basic design decision here is that we are not going to support\n * an insanely large number of attributes.\n */\n\n#define NO_THE_INDEX_COMPATIBILITY_MACROS\n#include \"cache.h\"\n#include \"exec_cmd.h\"\n#include \"attr.h\"\n#include \"dir.h\"\n#include \"utf8.h\"\n\nconst char git_attr__true[] = \"(builtin)true\";\nconst char git_attr__false[] = \"\\0(builtin)false\";\nstatic const char git_attr__unknown[] = \"(builtin)unknown\";\n#define ATTR__TRUE git_attr__true\n#define ATTR__FALSE git_attr__false\n#define ATTR__UNSET NULL\n#define ATTR__UNKNOWN git_attr__unknown\n\n/* This is a randomly chosen prime. */\n#define HASHSIZE 257\n\n#ifndef DEBUG_ATTR\n#define DEBUG_ATTR 0\n#endif\n\nstruct git_attr {\n\tstruct git_attr *next;\n\tunsigned h;\n\tint attr_nr;\n\tint maybe_macro;\n\tint maybe_real;\n\tchar name[FLEX_ARRAY];\n};\nstatic int attr_nr;\nstatic int cannot_trust_maybe_real;\n\nstatic struct git_attr_check *check_all_attr;\nstatic struct git_attr *(git_attr_hash[HASHSIZE]);\n\nchar *git_attr_name(struct git_attr *attr)\n{\n\treturn attr->name;\n}\n\nstatic unsigned hash_name(const char *name, int namelen)\n{\n\tunsigned val = 0, c;\n\n\twhile (namelen--) {\n\t\tc = *name++;\n\t\tval = ((val << 7) | (val >> 22)) ^ c;\n\t}\n\treturn val;\n}\n\nstatic int invalid_attr_name(const char *name, int namelen)\n{\n\t/*\n\t * Attribute name cannot begin with '-' and must consist of\n\t * characters from [-A-Za-z0-9_.].\n\t */\n\tif (namelen <= 0 || *name == '-')\n\t\treturn -1;\n\twhile (namelen--) {\n\t\tchar ch = *name++;\n\t\tif (! (ch == '-' || ch == '.' || ch == '_' ||\n\t\t       ('0' <= ch && ch <= '9') ||\n\t\t       ('a' <= ch && ch <= 'z') ||\n\t\t       ('A' <= ch && ch <= 'Z')) )\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic struct git_attr *git_attr_internal(const char *name, int len)\n{\n\tunsigned hval = hash_name(name, len);\n\tunsigned pos = hval % HASHSIZE;\n\tstruct git_attr *a;\n\n\tfor (a = git_attr_hash[pos]; a; a = a->next) {\n\t\tif (a->h == hval &&\n\t\t    !memcmp(a->name, name, len) && !a->name[len])\n\t\t\treturn a;\n\t}\n\n\tif (invalid_attr_name(name, len))\n\t\treturn NULL;\n\n\tFLEX_ALLOC_MEM(a, name, name, len);\n\ta->h = hval;\n\ta->next = git_attr_hash[pos];\n\ta->attr_nr = attr_nr++;\n\ta->maybe_macro = 0;\n\ta->maybe_real = 0;\n\tgit_attr_hash[pos] = a;\n\n\tREALLOC_ARRAY(check_all_attr, attr_nr);\n\tcheck_all_attr[a->attr_nr].attr = a;\n\tcheck_all_attr[a->attr_nr].value = ATTR__UNKNOWN;\n\treturn a;\n}\n\nstruct git_attr *git_attr(const char *name)\n{\n\treturn git_attr_internal(name, strlen(name));\n}\n\n/* What does a matched pattern decide? */\nstruct attr_state {\n\tstruct git_attr *attr;\n\tconst char *setto;\n};\n\nstruct pattern {\n\tconst char *pattern;\n\tint patternlen;\n\tint nowildcardlen;\n\tunsigned flags;\t\t/* EXC_FLAG_* */\n};\n\n/*\n * One rule, as from a .gitattributes file.\n *\n * If is_macro is true, then u.attr is a pointer to the git_attr being\n * defined.\n *\n * If is_macro is false, then u.pat is the filename pattern to which the\n * rule applies.\n *\n * In either case, num_attr is the number of attributes affected by\n * this rule, and state is an array listing them.  The attributes are\n * listed as they appear in the file (macros unexpanded).\n */\nstruct match_attr {\n\tunion {\n\t\tstruct pattern pat;\n\t\tstruct git_attr *attr;\n\t} u;\n\tchar is_macro;\n\tunsigned num_attr;\n\tstruct attr_state state[FLEX_ARRAY];\n};\n\nstatic const char blank[] = \" \\t\\r\\n\";\n\n/*\n * Parse a whitespace-delimited attribute state (i.e., \"attr\",\n * \"-attr\", \"!attr\", or \"attr=value\") from the string starting at src.\n * If e is not NULL, write the results to *e.  Return a pointer to the\n * remainder of the string (with leading whitespace removed), or NULL\n * if there was an error.\n */\nstatic const char *parse_attr(const char *src, int lineno, const char *cp,\n\t\t\t      struct attr_state *e)\n{\n\tconst char *ep, *equals;\n\tint len;\n\n\tep = cp + strcspn(cp, blank);\n\tequals = strchr(cp, '=');\n\tif (equals && ep < equals)\n\t\tequals = NULL;\n\tif (equals)\n\t\tlen = equals - cp;\n\telse\n\t\tlen = ep - cp;\n\tif (!e) {\n\t\tif (*cp == '-' || *cp == '!') {\n\t\t\tcp++;\n\t\t\tlen--;\n\t\t}\n\t\tif (invalid_attr_name(cp, len)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%.*s is not a valid attribute name: %s:%d\\n\",\n\t\t\t\tlen, cp, src, lineno);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tif (*cp == '-' || *cp == '!') {\n\t\t\te->setto = (*cp == '-') ? ATTR__FALSE : ATTR__UNSET;\n\t\t\tcp++;\n\t\t\tlen--;\n\t\t}\n\t\telse if (!equals)\n\t\t\te->setto = ATTR__TRUE;\n\t\telse {\n\t\t\te->setto = xmemdupz(equals + 1, ep - equals - 1);\n\t\t}\n\t\te->attr = git_attr_internal(cp, len);\n\t}\n\treturn ep + strspn(ep, blank);\n}\n\nstatic struct match_attr *parse_attr_line(const char *line, const char *src,\n\t\t\t\t\t  int lineno, int macro_ok)\n{\n\tint namelen;\n\tint num_attr, i;\n\tconst char *cp, *name, *states;\n\tstruct match_attr *res = NULL;\n\tint is_macro;\n\n\tcp = line + strspn(line, blank);\n\tif (!*cp || *cp == '#')\n\t\treturn NULL;\n\tname = cp;\n\tnamelen = strcspn(name, blank);\n\tif (strlen(ATTRIBUTE_MACRO_PREFIX) < namelen &&\n\t    starts_with(name, ATTRIBUTE_MACRO_PREFIX)) {\n\t\tif (!macro_ok) {\n\t\t\tfprintf(stderr, \"%s not allowed: %s:%d\\n\",\n\t\t\t\tname, src, lineno);\n\t\t\treturn NULL;\n\t\t}\n\t\tis_macro = 1;\n\t\tname += strlen(ATTRIBUTE_MACRO_PREFIX);\n\t\tname += strspn(name, blank);\n\t\tnamelen = strcspn(name, blank);\n\t\tif (invalid_attr_name(name, namelen)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%.*s is not a valid attribute name: %s:%d\\n\",\n\t\t\t\tnamelen, name, src, lineno);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse\n\t\tis_macro = 0;\n\n\tstates = name + namelen;\n\tstates += strspn(states, blank);\n\n\t/* First pass to count the attr_states */\n\tfor (cp = states, num_attr = 0; *cp; num_attr++) {\n\t\tcp = parse_attr(src, lineno, cp, NULL);\n\t\tif (!cp)\n\t\t\treturn NULL;\n\t}\n\n\tres = xcalloc(1,\n\t\t      sizeof(*res) +\n\t\t      sizeof(struct attr_state) * num_attr +\n\t\t      (is_macro ? 0 : namelen + 1));\n\tif (is_macro) {\n\t\tres->u.attr = git_attr_internal(name, namelen);\n\t\tres->u.attr->maybe_macro = 1;\n\t} else {\n\t\tchar *p = (char *)&(res->state[num_attr]);\n\t\tmemcpy(p, name, namelen);\n\t\tres->u.pat.pattern = p;\n\t\tparse_exclude_pattern(&res->u.pat.pattern,\n\t\t\t\t      &res->u.pat.patternlen,\n\t\t\t\t      &res->u.pat.flags,\n\t\t\t\t      &res->u.pat.nowildcardlen);\n\t\tif (res->u.pat.flags & EXC_FLAG_NEGATIVE) {\n\t\t\twarning(_(\"Negative patterns are ignored in git attributes\\n\"\n\t\t\t\t  \"Use '\\\\!' for literal leading exclamation.\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tres->is_macro = is_macro;\n\tres->num_attr = num_attr;\n\n\t/* Second pass to fill the attr_states */\n\tfor (cp = states, i = 0; *cp; i++) {\n\t\tcp = parse_attr(src, lineno, cp, &(res->state[i]));\n\t\tif (!is_macro)\n\t\t\tres->state[i].attr->maybe_real = 1;\n\t\tif (res->state[i].attr->maybe_macro)\n\t\t\tcannot_trust_maybe_real = 1;\n\t}\n\n\treturn res;\n}\n\n/*\n * Like info/exclude and .gitignore, the attribute information can\n * come from many places.\n *\n * (1) .gitattribute file of the same directory;\n * (2) .gitattribute file of the parent directory if (1) does not have\n *      any match; this goes recursively upwards, just like .gitignore.\n * (3) $GIT_DIR/info/attributes, which overrides both of the above.\n *\n * In the same file, later entries override the earlier match, so in the\n * global list, we would have entries from info/attributes the earliest\n * (reading the file from top to bottom), .gitattribute of the root\n * directory (again, reading the file from top to bottom) down to the\n * current directory, and then scan the list backwards to find the first match.\n * This is exactly the same as what is_excluded() does in dir.c to deal with\n * .gitignore\n */\n\nstatic struct attr_stack {\n\tstruct attr_stack *prev;\n\tchar *origin;\n\tsize_t originlen;\n\tunsigned num_matches;\n\tunsigned alloc;\n\tstruct match_attr **attrs;\n} *attr_stack;\n\nstatic void free_attr_elem(struct attr_stack *e)\n{\n\tint i;\n\tfree(e->origin);\n\tfor (i = 0; i < e->num_matches; i++) {\n\t\tstruct match_attr *a = e->attrs[i];\n\t\tint j;\n\t\tfor (j = 0; j < a->num_attr; j++) {\n\t\t\tconst char *setto = a->state[j].setto;\n\t\t\tif (setto == ATTR__TRUE ||\n\t\t\t    setto == ATTR__FALSE ||\n\t\t\t    setto == ATTR__UNSET ||\n\t\t\t    setto == ATTR__UNKNOWN)\n\t\t\t\t;\n\t\t\telse\n\t\t\t\tfree((char *) setto);\n\t\t}\n\t\tfree(a);\n\t}\n\tfree(e->attrs);\n\tfree(e);\n}\n\nstatic const char *builtin_attr[] = {\n\t\"[attr]binary -diff -merge -text\",\n\tNULL,\n};\n\nstatic void handle_attr_line(struct attr_stack *res,\n\t\t\t     const char *line,\n\t\t\t     const char *src,\n\t\t\t     int lineno,\n\t\t\t     int macro_ok)\n{\n\tstruct match_attr *a;\n\n\ta = parse_attr_line(line, src, lineno, macro_ok);\n\tif (!a)\n\t\treturn;\n\tALLOC_GROW(res->attrs, res->num_matches + 1, res->alloc);\n\tres->attrs[res->num_matches++] = a;\n}\n\nstatic struct attr_stack *read_attr_from_array(const char **list)\n{\n\tstruct attr_stack *res;\n\tconst char *line;\n\tint lineno = 0;\n\n\tres = xcalloc(1, sizeof(*res));\n\twhile ((line = *(list++)) != NULL)\n\t\thandle_attr_line(res, line, \"[builtin]\", ++lineno, 1);\n\treturn res;\n}\n\nstatic enum git_attr_direction direction;\nstatic struct index_state *use_index;\n\nstatic struct attr_stack *read_attr_from_file(const char *path, int macro_ok)\n{\n\tFILE *fp = fopen(path, \"r\");\n\tstruct attr_stack *res;\n\tchar buf[2048];\n\tint lineno = 0;\n\n\tif (!fp) {\n\t\tif (errno != ENOENT && errno != ENOTDIR)\n\t\t\twarn_on_inaccessible(path);\n\t\treturn NULL;\n\t}\n\tres = xcalloc(1, sizeof(*res));\n\twhile (fgets(buf, sizeof(buf), fp)) {\n\t\tchar *bufp = buf;\n\t\tif (!lineno)\n\t\t\tskip_utf8_bom(&bufp, strlen(bufp));\n\t\thandle_attr_line(res, bufp, path, ++lineno, macro_ok);\n\t}\n\tfclose(fp);\n\treturn res;\n}\n\nstatic struct attr_stack *read_attr_from_index(const char *path, int macro_ok)\n{\n\tstruct attr_stack *res;\n\tchar *buf, *sp;\n\tint lineno = 0;\n\n\tbuf = read_blob_data_from_index(use_index ? use_index : &the_index, path, NULL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tres = xcalloc(1, sizeof(*res));\n\tfor (sp = buf; *sp; ) {\n\t\tchar *ep;\n\t\tint more;\n\n\t\tep = strchrnul(sp, '\\n');\n\t\tmore = (*ep == '\\n');\n\t\t*ep = '\\0';\n\t\thandle_attr_line(res, sp, path, ++lineno, macro_ok);\n\t\tsp = ep + more;\n\t}\n\tfree(buf);\n\treturn res;\n}\n\nstatic struct attr_stack *read_attr(const char *path, int macro_ok)\n{\n\tstruct attr_stack *res;\n\n\tif (direction == GIT_ATTR_CHECKOUT) {\n\t\tres = read_attr_from_index(path, macro_ok);\n\t\tif (!res)\n\t\t\tres = read_attr_from_file(path, macro_ok);\n\t}\n\telse if (direction == GIT_ATTR_CHECKIN) {\n\t\tres = read_attr_from_file(path, macro_ok);\n\t\tif (!res)\n\t\t\t/*\n\t\t\t * There is no checked out .gitattributes file there, but\n\t\t\t * we might have it in the index.  We allow operation in a\n\t\t\t * sparsely checked out work tree, so read from it.\n\t\t\t */\n\t\t\tres = read_attr_from_index(path, macro_ok);\n\t}\n\telse\n\t\tres = read_attr_from_index(path, macro_ok);\n\tif (!res)\n\t\tres = xcalloc(1, sizeof(*res));\n\treturn res;\n}\n\n#if DEBUG_ATTR\nstatic void debug_info(const char *what, struct attr_stack *elem)\n{\n\tfprintf(stderr, \"%s: %s\\n\", what, elem->origin ? elem->origin : \"()\");\n}\nstatic void debug_set(const char *what, const char *match, struct git_attr *attr, const void *v)\n{\n\tconst char *value = v;\n\n\tif (ATTR_TRUE(value))\n\t\tvalue = \"set\";\n\telse if (ATTR_FALSE(value))\n\t\tvalue = \"unset\";\n\telse if (ATTR_UNSET(value))\n\t\tvalue = \"unspecified\";\n\n\tfprintf(stderr, \"%s: %s => %s (%s)\\n\",\n\t\twhat, attr->name, (char *) value, match);\n}\n#define debug_push(a) debug_info(\"push\", (a))\n#define debug_pop(a) debug_info(\"pop\", (a))\n#else\n#define debug_push(a) do { ; } while (0)\n#define debug_pop(a) do { ; } while (0)\n#define debug_set(a,b,c,d) do { ; } while (0)\n#endif\n\nstatic void drop_attr_stack(void)\n{\n\twhile (attr_stack) {\n\t\tstruct attr_stack *elem = attr_stack;\n\t\tattr_stack = elem->prev;\n\t\tfree_attr_elem(elem);\n\t}\n}\n\nstatic const char *git_etc_gitattributes(void)\n{\n\tstatic const char *system_wide;\n\tif (!system_wide)\n\t\tsystem_wide = system_path(ETC_GITATTRIBUTES);\n\treturn system_wide;\n}\n\nstatic int git_attr_system(void)\n{\n\treturn !git_env_bool(\"GIT_ATTR_NOSYSTEM\", 0);\n}\n\nstatic GIT_PATH_FUNC(git_path_info_attributes, INFOATTRIBUTES_FILE)\n\nstatic void bootstrap_attr_stack(void)\n{\n\tstruct attr_stack *elem;\n\n\tif (attr_stack)\n\t\treturn;\n\n\telem = read_attr_from_array(builtin_attr);\n\telem->origin = NULL;\n\telem->prev = attr_stack;\n\tattr_stack = elem;\n\n\tif (git_attr_system()) {\n\t\telem = read_attr_from_file(git_etc_gitattributes(), 1);\n\t\tif (elem) {\n\t\t\telem->origin = NULL;\n\t\t\telem->prev = attr_stack;\n\t\t\tattr_stack = elem;\n\t\t}\n\t}\n\n\tif (!git_attributes_file)\n\t\tgit_attributes_file = xdg_config_home(\"attributes\");\n\tif (git_attributes_file) {\n\t\telem = read_attr_from_file(git_attributes_file, 1);\n\t\tif (elem) {\n\t\t\telem->origin = NULL;\n\t\t\telem->prev = attr_stack;\n\t\t\tattr_stack = elem;\n\t\t}\n\t}\n\n\tif (!is_bare_repository() || direction == GIT_ATTR_INDEX) {\n\t\telem = read_attr(GITATTRIBUTES_FILE, 1);\n\t\telem->origin = xstrdup(\"\");\n\t\telem->originlen = 0;\n\t\telem->prev = attr_stack;\n\t\tattr_stack = elem;\n\t\tdebug_push(elem);\n\t}\n\n\tif (startup_info->have_repository)\n\t\telem = read_attr_from_file(git_path_info_attributes(), 1);\n\telse\n\t\telem = NULL;\n\n\tif (!elem)\n\t\telem = xcalloc(1, sizeof(*elem));\n\telem->origin = NULL;\n\telem->prev = attr_stack;\n\tattr_stack = elem;\n}\n\nstatic void prepare_attr_stack(const char *path, int dirlen)\n{\n\tstruct attr_stack *elem, *info;\n\tint len;\n\tconst char *cp;\n\n\t/*\n\t * At the bottom of the attribute stack is the built-in\n\t * set of attribute definitions, followed by the contents\n\t * of $(prefix)/etc/gitattributes and a file specified by\n\t * core.attributesfile.  Then, contents from\n\t * .gitattribute files from directories closer to the\n\t * root to the ones in deeper directories are pushed\n\t * to the stack.  Finally, at the very top of the stack\n\t * we always keep the contents of $GIT_DIR/info/attributes.\n\t *\n\t * When checking, we use entries from near the top of the\n\t * stack, preferring $GIT_DIR/info/attributes, then\n\t * .gitattributes in deeper directories to shallower ones,\n\t * and finally use the built-in set as the default.\n\t */\n\tbootstrap_attr_stack();\n\n\t/*\n\t * Pop the \"info\" one that is always at the top of the stack.\n\t */\n\tinfo = attr_stack;\n\tattr_stack = info->prev;\n\n\t/*\n\t * Pop the ones from directories that are not the prefix of\n\t * the path we are checking. Break out of the loop when we see\n\t * the root one (whose origin is an empty string \"\") or the builtin\n\t * one (whose origin is NULL) without popping it.\n\t */\n\twhile (attr_stack->origin) {\n\t\tint namelen = strlen(attr_stack->origin);\n\n\t\telem = attr_stack;\n\t\tif (namelen <= dirlen &&\n\t\t    !strncmp(elem->origin, path, namelen) &&\n\t\t    (!namelen || path[namelen] == '/'))\n\t\t\tbreak;\n\n\t\tdebug_pop(elem);\n\t\tattr_stack = elem->prev;\n\t\tfree_attr_elem(elem);\n\t}\n\n\t/*\n\t * Read from parent directories and push them down\n\t */\n\tif (!is_bare_repository() || direction == GIT_ATTR_INDEX) {\n\t\t/*\n\t\t * bootstrap_attr_stack() should have added, and the\n\t\t * above loop should have stopped before popping, the\n\t\t * root element whose attr_stack->origin is set to an\n\t\t * empty string.\n\t\t */\n\t\tstruct strbuf pathbuf = STRBUF_INIT;\n\n\t\tassert(attr_stack->origin);\n\t\twhile (1) {\n\t\t\tlen = strlen(attr_stack->origin);\n\t\t\tif (dirlen <= len)\n\t\t\t\tbreak;\n\t\t\tcp = memchr(path + len + 1, '/', dirlen - len - 1);\n\t\t\tif (!cp)\n\t\t\t\tcp = path + dirlen;\n\t\t\tstrbuf_add(&pathbuf, path, cp - path);\n\t\t\tstrbuf_addch(&pathbuf, '/');\n\t\t\tstrbuf_addstr(&pathbuf, GITATTRIBUTES_FILE);\n\t\t\telem = read_attr(pathbuf.buf, 0);\n\t\t\tstrbuf_setlen(&pathbuf, cp - path);\n\t\t\telem->origin = strbuf_detach(&pathbuf, &elem->originlen);\n\t\t\telem->prev = attr_stack;\n\t\t\tattr_stack = elem;\n\t\t\tdebug_push(elem);\n\t\t}\n\n\t\tstrbuf_release(&pathbuf);\n\t}\n\n\t/*\n\t * Finally push the \"info\" one at the top of the stack.\n\t */\n\tinfo->prev = attr_stack;\n\tattr_stack = info;\n}\n\nstatic int path_matches(const char *pathname, int pathlen,\n\t\t\tint basename_offset,\n\t\t\tconst struct pattern *pat,\n\t\t\tconst char *base, int baselen)\n{\n\tconst char *pattern = pat->pattern;\n\tint prefix = pat->nowildcardlen;\n\tint isdir = (pathlen && pathname[pathlen - 1] == '/');\n\n\tif ((pat->flags & EXC_FLAG_MUSTBEDIR) && !isdir)\n\t\treturn 0;\n\n\tif (pat->flags & EXC_FLAG_NODIR) {\n\t\treturn match_basename(pathname + basename_offset,\n\t\t\t\t      pathlen - basename_offset - isdir,\n\t\t\t\t      pattern, prefix,\n\t\t\t\t      pat->patternlen, pat->flags);\n\t}\n\treturn match_pathname(pathname, pathlen - isdir,\n\t\t\t      base, baselen,\n\t\t\t      pattern, prefix, pat->patternlen, pat->flags);\n}\n\nstatic int macroexpand_one(int attr_nr, int rem);\n\nstatic int fill_one(const char *what, struct match_attr *a, int rem)\n{\n\tstruct git_attr_check *check = check_all_attr;\n\tint i;\n\n\tfor (i = a->num_attr - 1; 0 < rem && 0 <= i; i--) {\n\t\tstruct git_attr *attr = a->state[i].attr;\n\t\tconst char **n = &(check[attr->attr_nr].value);\n\t\tconst char *v = a->state[i].setto;\n\n\t\tif (*n == ATTR__UNKNOWN) {\n\t\t\tdebug_set(what,\n\t\t\t\t  a->is_macro ? a->u.attr->name : a->u.pat.pattern,\n\t\t\t\t  attr, v);\n\t\t\t*n = v;\n\t\t\trem--;\n\t\t\trem = macroexpand_one(attr->attr_nr, rem);\n\t\t}\n\t}\n\treturn rem;\n}\n\nstatic int fill(const char *path, int pathlen, int basename_offset,\n\t\tstruct attr_stack *stk, int rem)\n{\n\tint i;\n\tconst char *base = stk->origin ? stk->origin : \"\";\n\n\tfor (i = stk->num_matches - 1; 0 < rem && 0 <= i; i--) {\n\t\tstruct match_attr *a = stk->attrs[i];\n\t\tif (a->is_macro)\n\t\t\tcontinue;\n\t\tif (path_matches(path, pathlen, basename_offset,\n\t\t\t\t &a->u.pat, base, stk->originlen))\n\t\t\trem = fill_one(\"fill\", a, rem);\n\t}\n\treturn rem;\n}\n\nstatic int macroexpand_one(int nr, int rem)\n{\n\tstruct attr_stack *stk;\n\tstruct match_attr *a = NULL;\n\tint i;\n\n\tif (check_all_attr[nr].value != ATTR__TRUE ||\n\t    !check_all_attr[nr].attr->maybe_macro)\n\t\treturn rem;\n\n\tfor (stk = attr_stack; !a && stk; stk = stk->prev)\n\t\tfor (i = stk->num_matches - 1; !a && 0 <= i; i--) {\n\t\t\tstruct match_attr *ma = stk->attrs[i];\n\t\t\tif (!ma->is_macro)\n\t\t\t\tcontinue;\n\t\t\tif (ma->u.attr->attr_nr == nr)\n\t\t\t\ta = ma;\n\t\t}\n\n\tif (a)\n\t\trem = fill_one(\"expand\", a, rem);\n\n\treturn rem;\n}\n\n/*\n * Collect attributes for path into the array pointed to by\n * check_all_attr. If num is non-zero, only attributes in check[] are\n * collected. Otherwise all attributes are collected.\n */\nstatic void collect_some_attrs(const char *path, int num,\n\t\t\t       struct git_attr_check *check)\n\n{\n\tstruct attr_stack *stk;\n\tint i, pathlen, rem, dirlen;\n\tconst char *cp, *last_slash = NULL;\n\tint basename_offset;\n\n\tfor (cp = path; *cp; cp++) {\n\t\tif (*cp == '/' && cp[1])\n\t\t\tlast_slash = cp;\n\t}\n\tpathlen = cp - path;\n\tif (last_slash) {\n\t\tbasename_offset = last_slash + 1 - path;\n\t\tdirlen = last_slash - path;\n\t} else {\n\t\tbasename_offset = 0;\n\t\tdirlen = 0;\n\t}\n\n\tprepare_attr_stack(path, dirlen);\n\tfor (i = 0; i < attr_nr; i++)\n\t\tcheck_all_attr[i].value = ATTR__UNKNOWN;\n\tif (num && !cannot_trust_maybe_real) {\n\t\trem = 0;\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tif (!check[i].attr->maybe_real) {\n\t\t\t\tstruct git_attr_check *c;\n\t\t\t\tc = check_all_attr + check[i].attr->attr_nr;\n\t\t\t\tc->value = ATTR__UNSET;\n\t\t\t\trem++;\n\t\t\t}\n\t\t}\n\t\tif (rem == num)\n\t\t\treturn;\n\t}\n\n\trem = attr_nr;\n\tfor (stk = attr_stack; 0 < rem && stk; stk = stk->prev)\n\t\trem = fill(path, pathlen, basename_offset, stk, rem);\n}\n\nint git_check_attr(const char *path, int num, struct git_attr_check *check)\n{\n\tint i;\n\n\tcollect_some_attrs(path, num, check);\n\n\tfor (i = 0; i < num; i++) {\n\t\tconst char *value = check_all_attr[check[i].attr->attr_nr].value;\n\t\tif (value == ATTR__UNKNOWN)\n\t\t\tvalue = ATTR__UNSET;\n\t\tcheck[i].value = value;\n\t}\n\n\treturn 0;\n}\n\nint git_all_attrs(const char *path, int *num, struct git_attr_check **check)\n{\n\tint i, count, j;\n\n\tcollect_some_attrs(path, 0, NULL);\n\n\t/* Count the number of attributes that are set. */\n\tcount = 0;\n\tfor (i = 0; i < attr_nr; i++) {\n\t\tconst char *value = check_all_attr[i].value;\n\t\tif (value != ATTR__UNSET && value != ATTR__UNKNOWN)\n\t\t\t++count;\n\t}\n\t*num = count;\n\tALLOC_ARRAY(*check, count);\n\tj = 0;\n\tfor (i = 0; i < attr_nr; i++) {\n\t\tconst char *value = check_all_attr[i].value;\n\t\tif (value != ATTR__UNSET && value != ATTR__UNKNOWN) {\n\t\t\t(*check)[j].attr = check_all_attr[i].attr;\n\t\t\t(*check)[j].value = value;\n\t\t\t++j;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid git_attr_set_direction(enum git_attr_direction new, struct index_state *istate)\n{\n\tenum git_attr_direction old = direction;\n\n\tif (is_bare_repository() && new != GIT_ATTR_INDEX)\n\t\tdie(\"BUG: non-INDEX attr direction in a bare repo\");\n\n\tdirection = new;\n\tif (new != old)\n\t\tdrop_attr_stack();\n\tuse_index = istate;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "007f1a29954b590c5c3f046006e40d88b731aaa4",
  "sha1_ok": true,
  "size": 20165
}
