{
  "content": {
    "base64": "LyoKICogR0lUIC0gVGhlIGluZm9ybWF0aW9uIG1hbmFnZXIgZnJvbSBoZWxsCiAqCiAqIENvcHlyaWdodCAoQykgTGludXMgVG9ydmFsZHMsIDIwMDUKICovCiNkZWZpbmUgTk9fVEhFX0lOREVYX0NPTVBBVElCSUxJVFlfTUFDUk9TCiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAiY2FjaGUtdHJlZS5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJ0cmVlLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgImJsb2IuaCIKI2luY2x1ZGUgInJlc29sdmUtdW5kby5oIgojaW5jbHVkZSAic3RyYnVmLmgiCiNpbmNsdWRlICJ2YXJpbnQuaCIKCnN0YXRpYyBzdHJ1Y3QgY2FjaGVfZW50cnkgKnJlZnJlc2hfY2FjaGVfZW50cnkoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgaW50IHJlYWxseSk7CgovKiBNYXNrIGZvciB0aGUgbmFtZSBsZW5ndGggaW4gY2VfZmxhZ3MgaW4gdGhlIG9uLWRpc2sgaW5kZXggKi8KCiNkZWZpbmUgQ0VfTkFNRU1BU0sgICgweDBmZmYpCgovKiBJbmRleCBleHRlbnNpb25zLgogKgogKiBUaGUgZmlyc3QgbGV0dGVyIHNob3VsZCBiZSAnQScuLidaJyBmb3IgZXh0ZW5zaW9ucyB0aGF0IGFyZSBub3QKICogbmVjZXNzYXJ5IGZvciBhIGNvcnJlY3Qgb3BlcmF0aW9uIChpLmUuIG9wdGltaXphdGlvbiBkYXRhKS4KICogV2hlbiBuZXcgZXh0ZW5zaW9ucyBhcmUgYWRkZWQgdGhhdCBfbmVlZHNfIHRvIGJlIHVuZGVyc3Rvb2QgaW4KICogb3JkZXIgdG8gY29ycmVjdGx5IGludGVycHJldCB0aGUgaW5kZXggZmlsZSwgcGljayBjaGFyYWN0ZXIgdGhhdAogKiBpcyBvdXRzaWRlIHRoZSByYW5nZSwgdG8gY2F1c2UgdGhlIHJlYWRlciB0byBhYm9ydC4KICovCgojZGVmaW5lIENBQ0hFX0VYVChzKSAoIChzWzBdPDwyNCl8KHNbMV08PDE2KXwoc1syXTw8OCl8KHNbM10pICkKI2RlZmluZSBDQUNIRV9FWFRfVFJFRSAweDU0NTI0NTQ1CS8qICJUUkVFIiAqLwojZGVmaW5lIENBQ0hFX0VYVF9SRVNPTFZFX1VORE8gMHg1MjQ1NTU0MyAvKiAiUkVVQyIgKi8KCnN0cnVjdCBpbmRleF9zdGF0ZSB0aGVfaW5kZXg7CgpzdGF0aWMgdm9pZCBzZXRfaW5kZXhfZW50cnkoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIGludCBuciwgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSkKewoJaXN0YXRlLT5jYWNoZVtucl0gPSBjZTsKCWFkZF9uYW1lX2hhc2goaXN0YXRlLCBjZSk7Cn0KCnN0YXRpYyB2b2lkIHJlcGxhY2VfaW5kZXhfZW50cnkoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIGludCBuciwgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSkKewoJc3RydWN0IGNhY2hlX2VudHJ5ICpvbGQgPSBpc3RhdGUtPmNhY2hlW25yXTsKCglyZW1vdmVfbmFtZV9oYXNoKGlzdGF0ZSwgb2xkKTsKCXNldF9pbmRleF9lbnRyeShpc3RhdGUsIG5yLCBjZSk7Cglpc3RhdGUtPmNhY2hlX2NoYW5nZWQgPSAxOwp9Cgp2b2lkIHJlbmFtZV9pbmRleF9lbnRyeV9hdChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgaW50IG5yLCBjb25zdCBjaGFyICpuZXdfbmFtZSkKewoJc3RydWN0IGNhY2hlX2VudHJ5ICpvbGQgPSBpc3RhdGUtPmNhY2hlW25yXSwgKm5ldzsKCWludCBuYW1lbGVuID0gc3RybGVuKG5ld19uYW1lKTsKCgluZXcgPSB4bWFsbG9jKGNhY2hlX2VudHJ5X3NpemUobmFtZWxlbikpOwoJY29weV9jYWNoZV9lbnRyeShuZXcsIG9sZCk7CgluZXctPmNlX2ZsYWdzICY9IH5DRV9IQVNIRUQ7CgluZXctPmNlX25hbWVsZW4gPSBuYW1lbGVuOwoJbWVtY3B5KG5ldy0+bmFtZSwgbmV3X25hbWUsIG5hbWVsZW4gKyAxKTsKCgljYWNoZV90cmVlX2ludmFsaWRhdGVfcGF0aChpc3RhdGUtPmNhY2hlX3RyZWUsIG9sZC0+bmFtZSk7CglyZW1vdmVfaW5kZXhfZW50cnlfYXQoaXN0YXRlLCBucik7CglhZGRfaW5kZXhfZW50cnkoaXN0YXRlLCBuZXcsIEFERF9DQUNIRV9PS19UT19BRER8QUREX0NBQ0hFX09LX1RPX1JFUExBQ0UpOwp9Cgp2b2lkIGZpbGxfc3RhdF9kYXRhKHN0cnVjdCBzdGF0X2RhdGEgKnNkLCBzdHJ1Y3Qgc3RhdCAqc3QpCnsKCXNkLT5zZF9jdGltZS5zZWMgPSAodW5zaWduZWQgaW50KXN0LT5zdF9jdGltZTsKCXNkLT5zZF9tdGltZS5zZWMgPSAodW5zaWduZWQgaW50KXN0LT5zdF9tdGltZTsKCXNkLT5zZF9jdGltZS5uc2VjID0gU1RfQ1RJTUVfTlNFQygqc3QpOwoJc2QtPnNkX210aW1lLm5zZWMgPSBTVF9NVElNRV9OU0VDKCpzdCk7CglzZC0+c2RfZGV2ID0gc3QtPnN0X2RldjsKCXNkLT5zZF9pbm8gPSBzdC0+c3RfaW5vOwoJc2QtPnNkX3VpZCA9IHN0LT5zdF91aWQ7CglzZC0+c2RfZ2lkID0gc3QtPnN0X2dpZDsKCXNkLT5zZF9zaXplID0gc3QtPnN0X3NpemU7Cn0KCmludCBtYXRjaF9zdGF0X2RhdGEoY29uc3Qgc3RydWN0IHN0YXRfZGF0YSAqc2QsIHN0cnVjdCBzdGF0ICpzdCkKewoJaW50IGNoYW5nZWQgPSAwOwoKCWlmIChzZC0+c2RfbXRpbWUuc2VjICE9ICh1bnNpZ25lZCBpbnQpc3QtPnN0X210aW1lKQoJCWNoYW5nZWQgfD0gTVRJTUVfQ0hBTkdFRDsKCWlmICh0cnVzdF9jdGltZSAmJiBjaGVja19zdGF0ICYmCgkgICAgc2QtPnNkX2N0aW1lLnNlYyAhPSAodW5zaWduZWQgaW50KXN0LT5zdF9jdGltZSkKCQljaGFuZ2VkIHw9IENUSU1FX0NIQU5HRUQ7CgojaWZkZWYgVVNFX05TRUMKCWlmIChjaGVja19zdGF0ICYmIHNkLT5zZF9tdGltZS5uc2VjICE9IFNUX01USU1FX05TRUMoKnN0KSkKCQljaGFuZ2VkIHw9IE1USU1FX0NIQU5HRUQ7CglpZiAodHJ1c3RfY3RpbWUgJiYgY2hlY2tfc3RhdCAmJgoJICAgIHNkLT5zZF9jdGltZS5uc2VjICE9IFNUX0NUSU1FX05TRUMoKnN0KSkKCQljaGFuZ2VkIHw9IENUSU1FX0NIQU5HRUQ7CiNlbmRpZgoKCWlmIChjaGVja19zdGF0KSB7CgkJaWYgKHNkLT5zZF91aWQgIT0gKHVuc2lnbmVkIGludCkgc3QtPnN0X3VpZCB8fAoJCQlzZC0+c2RfZ2lkICE9ICh1bnNpZ25lZCBpbnQpIHN0LT5zdF9naWQpCgkJCWNoYW5nZWQgfD0gT1dORVJfQ0hBTkdFRDsKCQlpZiAoc2QtPnNkX2lubyAhPSAodW5zaWduZWQgaW50KSBzdC0+c3RfaW5vKQoJCQljaGFuZ2VkIHw9IElOT0RFX0NIQU5HRUQ7Cgl9CgojaWZkZWYgVVNFX1NUREVWCgkvKgoJICogc3RfZGV2IGJyZWFrcyBvbiBuZXR3b3JrIGZpbGVzeXN0ZW1zIHdoZXJlIGRpZmZlcmVudAoJICogY2xpZW50cyB3aWxsIGhhdmUgZGlmZmVyZW50IHZpZXdzIG9mIHdoYXQgImRldmljZSIKCSAqIHRoZSBmaWxlc3lzdGVtIGlzIG9uCgkgKi8KCWlmIChjaGVja19zdGF0ICYmIHNkLT5zZF9kZXYgIT0gKHVuc2lnbmVkIGludCkgc3QtPnN0X2RldikKCQkJY2hhbmdlZCB8PSBJTk9ERV9DSEFOR0VEOwojZW5kaWYKCglpZiAoc2QtPnNkX3NpemUgIT0gKHVuc2lnbmVkIGludCkgc3QtPnN0X3NpemUpCgkJY2hhbmdlZCB8PSBEQVRBX0NIQU5HRUQ7CgoJcmV0dXJuIGNoYW5nZWQ7Cn0KCi8qCiAqIFRoaXMgb25seSB1cGRhdGVzIHRoZSAibm9uLWNyaXRpY2FsIiBwYXJ0cyBvZiB0aGUgZGlyZWN0b3J5CiAqIGNhY2hlLCBpZSB0aGUgcGFydHMgdGhhdCBhcmVuJ3QgdHJhY2tlZCBieSBHSVQsIGFuZCBvbmx5IHVzZWQKICogdG8gdmFsaWRhdGUgdGhlIGNhY2hlLgogKi8Kdm9pZCBmaWxsX3N0YXRfY2FjaGVfaW5mbyhzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBzdHJ1Y3Qgc3RhdCAqc3QpCnsKCWZpbGxfc3RhdF9kYXRhKCZjZS0+Y2Vfc3RhdF9kYXRhLCBzdCk7CgoJaWYgKGFzc3VtZV91bmNoYW5nZWQpCgkJY2UtPmNlX2ZsYWdzIHw9IENFX1ZBTElEOwoKCWlmIChTX0lTUkVHKHN0LT5zdF9tb2RlKSkKCQljZV9tYXJrX3VwdG9kYXRlKGNlKTsKfQoKc3RhdGljIGludCBjZV9jb21wYXJlX2RhdGEoY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgc3RydWN0IHN0YXQgKnN0KQp7CglpbnQgbWF0Y2ggPSAtMTsKCWludCBmZCA9IG9wZW4oY2UtPm5hbWUsIE9fUkRPTkxZKTsKCglpZiAoZmQgPj0gMCkgewoJCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgkJaWYgKCFpbmRleF9mZChzaGExLCBmZCwgc3QsIE9CSl9CTE9CLCBjZS0+bmFtZSwgMCkpCgkJCW1hdGNoID0gaGFzaGNtcChzaGExLCBjZS0+c2hhMSk7CgkJLyogaW5kZXhfZmQoKSBjbG9zZWQgdGhlIGZpbGUgZGVzY3JpcHRvciBhbHJlYWR5ICovCgl9CglyZXR1cm4gbWF0Y2g7Cn0KCnN0YXRpYyBpbnQgY2VfY29tcGFyZV9saW5rKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIHNpemVfdCBleHBlY3RlZF9zaXplKQp7CglpbnQgbWF0Y2ggPSAtMTsKCXZvaWQgKmJ1ZmZlcjsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCglpZiAoc3RyYnVmX3JlYWRsaW5rKCZzYiwgY2UtPm5hbWUsIGV4cGVjdGVkX3NpemUpKQoJCXJldHVybiAtMTsKCglidWZmZXIgPSByZWFkX3NoYTFfZmlsZShjZS0+c2hhMSwgJnR5cGUsICZzaXplKTsKCWlmIChidWZmZXIpIHsKCQlpZiAoc2l6ZSA9PSBzYi5sZW4pCgkJCW1hdGNoID0gbWVtY21wKGJ1ZmZlciwgc2IuYnVmLCBzaXplKTsKCQlmcmVlKGJ1ZmZlcik7Cgl9CglzdHJidWZfcmVsZWFzZSgmc2IpOwoJcmV0dXJuIG1hdGNoOwp9CgpzdGF0aWMgaW50IGNlX2NvbXBhcmVfZ2l0bGluayhjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKQp7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoKCS8qCgkgKiBXZSBkb24ndCBhY3R1YWxseSByZXF1aXJlIHRoYXQgdGhlIC5naXQgZGlyZWN0b3J5CgkgKiB1bmRlciBHSVRMSU5LIGRpcmVjdG9yeSBiZSBhIHZhbGlkIGdpdCBkaXJlY3RvcnkuIEl0CgkgKiBtaWdodCBldmVuIGJlIG1pc3NpbmcgKGluIGNhc2Ugbm9ib2R5IHBvcHVsYXRlZCB0aGF0CgkgKiBzdWItcHJvamVjdCkuCgkgKgoJICogSWYgc28sIHdlIGNvbnNpZGVyIGl0IGFsd2F5cyB0byBtYXRjaC4KCSAqLwoJaWYgKHJlc29sdmVfZ2l0bGlua19yZWYoY2UtPm5hbWUsICJIRUFEIiwgc2hhMSkgPCAwKQoJCXJldHVybiAwOwoJcmV0dXJuIGhhc2hjbXAoc2hhMSwgY2UtPnNoYTEpOwp9CgpzdGF0aWMgaW50IGNlX21vZGlmaWVkX2NoZWNrX2ZzKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIHN0cnVjdCBzdGF0ICpzdCkKewoJc3dpdGNoIChzdC0+c3RfbW9kZSAmIFNfSUZNVCkgewoJY2FzZSBTX0lGUkVHOgoJCWlmIChjZV9jb21wYXJlX2RhdGEoY2UsIHN0KSkKCQkJcmV0dXJuIERBVEFfQ0hBTkdFRDsKCQlicmVhazsKCWNhc2UgU19JRkxOSzoKCQlpZiAoY2VfY29tcGFyZV9saW5rKGNlLCB4c2l6ZV90KHN0LT5zdF9zaXplKSkpCgkJCXJldHVybiBEQVRBX0NIQU5HRUQ7CgkJYnJlYWs7CgljYXNlIFNfSUZESVI6CgkJaWYgKFNfSVNHSVRMSU5LKGNlLT5jZV9tb2RlKSkKCQkJcmV0dXJuIGNlX2NvbXBhcmVfZ2l0bGluayhjZSkgPyBEQVRBX0NIQU5HRUQgOiAwOwoJZGVmYXVsdDoKCQlyZXR1cm4gVFlQRV9DSEFOR0VEOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgY2VfbWF0Y2hfc3RhdF9iYXNpYyhjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBzdHJ1Y3Qgc3RhdCAqc3QpCnsKCXVuc2lnbmVkIGludCBjaGFuZ2VkID0gMDsKCglpZiAoY2UtPmNlX2ZsYWdzICYgQ0VfUkVNT1ZFKQoJCXJldHVybiBNT0RFX0NIQU5HRUQgfCBEQVRBX0NIQU5HRUQgfCBUWVBFX0NIQU5HRUQ7CgoJc3dpdGNoIChjZS0+Y2VfbW9kZSAmIFNfSUZNVCkgewoJY2FzZSBTX0lGUkVHOgoJCWNoYW5nZWQgfD0gIVNfSVNSRUcoc3QtPnN0X21vZGUpID8gVFlQRV9DSEFOR0VEIDogMDsKCQkvKiBXZSBjb25zaWRlciBvbmx5IHRoZSBvd25lciB4IGJpdCB0byBiZSByZWxldmFudCBmb3IKCQkgKiAibW9kZSBjaGFuZ2VzIgoJCSAqLwoJCWlmICh0cnVzdF9leGVjdXRhYmxlX2JpdCAmJgoJCSAgICAoMDEwMCAmIChjZS0+Y2VfbW9kZSBeIHN0LT5zdF9tb2RlKSkpCgkJCWNoYW5nZWQgfD0gTU9ERV9DSEFOR0VEOwoJCWJyZWFrOwoJY2FzZSBTX0lGTE5LOgoJCWlmICghU19JU0xOSyhzdC0+c3RfbW9kZSkgJiYKCQkgICAgKGhhc19zeW1saW5rcyB8fCAhU19JU1JFRyhzdC0+c3RfbW9kZSkpKQoJCQljaGFuZ2VkIHw9IFRZUEVfQ0hBTkdFRDsKCQlicmVhazsKCWNhc2UgU19JRkdJVExJTks6CgkJLyogV2UgaWdub3JlIG1vc3Qgb2YgdGhlIHN0X3h4eCBmaWVsZHMgZm9yIGdpdGxpbmtzICovCgkJaWYgKCFTX0lTRElSKHN0LT5zdF9tb2RlKSkKCQkJY2hhbmdlZCB8PSBUWVBFX0NIQU5HRUQ7CgkJZWxzZSBpZiAoY2VfY29tcGFyZV9naXRsaW5rKGNlKSkKCQkJY2hhbmdlZCB8PSBEQVRBX0NIQU5HRUQ7CgkJcmV0dXJuIGNoYW5nZWQ7CglkZWZhdWx0OgoJCWRpZSgiaW50ZXJuYWwgZXJyb3I6IGNlX21vZGUgaXMgJW8iLCBjZS0+Y2VfbW9kZSk7Cgl9CgoJY2hhbmdlZCB8PSBtYXRjaF9zdGF0X2RhdGEoJmNlLT5jZV9zdGF0X2RhdGEsIHN0KTsKCgkvKiBSYWNpbHkgc211ZGdlZCBlbnRyeT8gKi8KCWlmICghY2UtPmNlX3N0YXRfZGF0YS5zZF9zaXplKSB7CgkJaWYgKCFpc19lbXB0eV9ibG9iX3NoYTEoY2UtPnNoYTEpKQoJCQljaGFuZ2VkIHw9IERBVEFfQ0hBTkdFRDsKCX0KCglyZXR1cm4gY2hhbmdlZDsKfQoKc3RhdGljIGludCBpc19yYWN5X3RpbWVzdGFtcChjb25zdCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwKCQkJICAgICBjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKQp7CglyZXR1cm4gKCFTX0lTR0lUTElOSyhjZS0+Y2VfbW9kZSkgJiYKCQlpc3RhdGUtPnRpbWVzdGFtcC5zZWMgJiYKI2lmZGVmIFVTRV9OU0VDCgkJIC8qIG5hbm9zZWNvbmQgdGltZXN0YW1wZWQgZmlsZXMgY2FuIGFsc28gYmUgcmFjeSEgKi8KCQkoaXN0YXRlLT50aW1lc3RhbXAuc2VjIDwgY2UtPmNlX3N0YXRfZGF0YS5zZF9tdGltZS5zZWMgfHwKCQkgKGlzdGF0ZS0+dGltZXN0YW1wLnNlYyA9PSBjZS0+Y2Vfc3RhdF9kYXRhLnNkX210aW1lLnNlYyAmJgoJCSAgaXN0YXRlLT50aW1lc3RhbXAubnNlYyA8PSBjZS0+Y2Vfc3RhdF9kYXRhLnNkX210aW1lLm5zZWMpKQojZWxzZQoJCWlzdGF0ZS0+dGltZXN0YW1wLnNlYyA8PSBjZS0+Y2Vfc3RhdF9kYXRhLnNkX210aW1lLnNlYwojZW5kaWYKCQkgKTsKfQoKaW50IGllX21hdGNoX3N0YXQoY29uc3Qgc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsCgkJICBjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBzdHJ1Y3Qgc3RhdCAqc3QsCgkJICB1bnNpZ25lZCBpbnQgb3B0aW9ucykKewoJdW5zaWduZWQgaW50IGNoYW5nZWQ7CglpbnQgaWdub3JlX3ZhbGlkID0gb3B0aW9ucyAmIENFX01BVENIX0lHTk9SRV9WQUxJRDsKCWludCBpZ25vcmVfc2tpcF93b3JrdHJlZSA9IG9wdGlvbnMgJiBDRV9NQVRDSF9JR05PUkVfU0tJUF9XT1JLVFJFRTsKCWludCBhc3N1bWVfcmFjeV9pc19tb2RpZmllZCA9IG9wdGlvbnMgJiBDRV9NQVRDSF9SQUNZX0lTX0RJUlRZOwoKCS8qCgkgKiBJZiBpdCdzIG1hcmtlZCBhcyBhbHdheXMgdmFsaWQgaW4gdGhlIGluZGV4LCBpdCdzCgkgKiB2YWxpZCB3aGF0ZXZlciB0aGUgY2hlY2tlZC1vdXQgY29weSBzYXlzLgoJICoKCSAqIHNraXAtd29ya3RyZWUgaGFzIHRoZSBzYW1lIGVmZmVjdCB3aXRoIGhpZ2hlciBwcmVjZWRlbmNlCgkgKi8KCWlmICghaWdub3JlX3NraXBfd29ya3RyZWUgJiYgY2Vfc2tpcF93b3JrdHJlZShjZSkpCgkJcmV0dXJuIDA7CglpZiAoIWlnbm9yZV92YWxpZCAmJiAoY2UtPmNlX2ZsYWdzICYgQ0VfVkFMSUQpKQoJCXJldHVybiAwOwoKCS8qCgkgKiBJbnRlbnQtdG8tYWRkIGVudHJpZXMgaGF2ZSBub3QgYmVlbiBhZGRlZCwgc28gdGhlIGluZGV4IGVudHJ5CgkgKiBieSBkZWZpbml0aW9uIG5ldmVyIG1hdGNoZXMgd2hhdCBpcyBpbiB0aGUgd29yayB0cmVlIHVudGlsIGl0CgkgKiBhY3R1YWxseSBnZXRzIGFkZGVkLgoJICovCglpZiAoY2UtPmNlX2ZsYWdzICYgQ0VfSU5URU5UX1RPX0FERCkKCQlyZXR1cm4gREFUQV9DSEFOR0VEIHwgVFlQRV9DSEFOR0VEIHwgTU9ERV9DSEFOR0VEOwoKCWNoYW5nZWQgPSBjZV9tYXRjaF9zdGF0X2Jhc2ljKGNlLCBzdCk7CgoJLyoKCSAqIFdpdGhpbiAxIHNlY29uZCBvZiB0aGlzIHNlcXVlbmNlOgoJICogCWVjaG8geHl6enkgPmZpbGUgJiYgZ2l0LXVwZGF0ZS1pbmRleCAtLWFkZCBmaWxlCgkgKiBydW5uaW5nIHRoaXMgY29tbWFuZDoKCSAqIAllY2hvIGZyb3R6ID5maWxlCgkgKiB3b3VsZCBnaXZlIGEgZmFsc2VseSBjbGVhbiBjYWNoZSBlbnRyeS4gIFRoZSBtdGltZSBhbmQKCSAqIGxlbmd0aCBtYXRjaCB0aGUgY2FjaGUsIGFuZCBvdGhlciBzdGF0IGZpZWxkcyBkbyBub3QgY2hhbmdlLgoJICoKCSAqIFdlIGNvdWxkIGRldGVjdCB0aGlzIGF0IHVwZGF0ZS1pbmRleCB0aW1lICh0aGUgY2FjaGUgZW50cnkKCSAqIGJlaW5nIHJlZ2lzdGVyZWQvdXBkYXRlZCByZWNvcmRzIHRoZSBzYW1lIHRpbWUgYXMgIm5vdyIpCgkgKiBhbmQgZGVsYXkgdGhlIHJldHVybiBmcm9tIGdpdC11cGRhdGUtaW5kZXgsIGJ1dCB0aGF0IHdvdWxkCgkgKiBlZmZlY3RpdmVseSBtZWFuIHdlIGNhbiBtYWtlIGF0IG1vc3Qgb25lIGNvbW1pdCBwZXIgc2Vjb25kLAoJICogd2hpY2ggaXMgbm90IGFjY2VwdGFibGUuICBJbnN0ZWFkLCB3ZSBjaGVjayBjYWNoZSBlbnRyaWVzCgkgKiB3aG9zZSBtdGltZSBhcmUgdGhlIHNhbWUgYXMgdGhlIGluZGV4IGZpbGUgdGltZXN0YW1wIG1vcmUKCSAqIGNhcmVmdWxseSB0aGFuIG90aGVycy4KCSAqLwoJaWYgKCFjaGFuZ2VkICYmIGlzX3JhY3lfdGltZXN0YW1wKGlzdGF0ZSwgY2UpKSB7CgkJaWYgKGFzc3VtZV9yYWN5X2lzX21vZGlmaWVkKQoJCQljaGFuZ2VkIHw9IERBVEFfQ0hBTkdFRDsKCQllbHNlCgkJCWNoYW5nZWQgfD0gY2VfbW9kaWZpZWRfY2hlY2tfZnMoY2UsIHN0KTsKCX0KCglyZXR1cm4gY2hhbmdlZDsKfQoKaW50IGllX21vZGlmaWVkKGNvbnN0IHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLAoJCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJc3RydWN0IHN0YXQgKnN0LCB1bnNpZ25lZCBpbnQgb3B0aW9ucykKewoJaW50IGNoYW5nZWQsIGNoYW5nZWRfZnM7CgoJY2hhbmdlZCA9IGllX21hdGNoX3N0YXQoaXN0YXRlLCBjZSwgc3QsIG9wdGlvbnMpOwoJaWYgKCFjaGFuZ2VkKQoJCXJldHVybiAwOwoJLyoKCSAqIElmIHRoZSBtb2RlIG9yIHR5cGUgaGFzIGNoYW5nZWQsIHRoZXJlJ3Mgbm8gcG9pbnQgaW4gdHJ5aW5nCgkgKiB0byByZWZyZXNoIHRoZSBlbnRyeSAtIGl0J3Mgbm90IGdvaW5nIHRvIG1hdGNoCgkgKi8KCWlmIChjaGFuZ2VkICYgKE1PREVfQ0hBTkdFRCB8IFRZUEVfQ0hBTkdFRCkpCgkJcmV0dXJuIGNoYW5nZWQ7CgoJLyoKCSAqIEltbWVkaWF0ZWx5IGFmdGVyIHJlYWQtdHJlZSBvciB1cGRhdGUtaW5kZXggLS1jYWNoZWluZm8sCgkgKiB0aGUgbGVuZ3RoIGZpZWxkIGlzIHplcm8sIGFzIHdlIGhhdmUgbmV2ZXIgZXZlbiByZWFkIHRoZQoJICogbHN0YXQoMikgaW5mb3JtYXRpb24gb25jZSwgYW5kIHdlIGNhbm5vdCB0cnVzdCBEQVRBX0NIQU5HRUQKCSAqIHJldHVybmVkIGJ5IGllX21hdGNoX3N0YXQoKSB3aGljaCBpbiB0dXJuIHdhcyByZXR1cm5lZCBieQoJICogY2VfbWF0Y2hfc3RhdF9iYXNpYygpIHRvIHNpZ25hbCB0aGF0IHRoZSBmaWxlc2l6ZSBvZiB0aGUKCSAqIGJsb2IgY2hhbmdlZC4gIFdlIGhhdmUgdG8gYWN0dWFsbHkgZ28gdG8gdGhlIGZpbGVzeXN0ZW0gdG8KCSAqIHNlZSBpZiB0aGUgY29udGVudHMgbWF0Y2gsIGFuZCBpZiBzbywgc2hvdWxkIGFuc3dlciAidW5jaGFuZ2VkIi4KCSAqCgkgKiBUaGUgbG9naWMgZG9lcyBub3QgYXBwbHkgdG8gZ2l0bGlua3MsIGFzIGNlX21hdGNoX3N0YXRfYmFzaWMoKQoJICogYWxyZWFkeSBoYXMgY2hlY2tlZCB0aGUgYWN0dWFsIEhFQUQgZnJvbSB0aGUgZmlsZXN5c3RlbSBpbiB0aGUKCSAqIHN1YnByb2plY3QuICBJZiBpZV9tYXRjaF9zdGF0KCkgYWxyZWFkeSBzYWlkIGl0IGlzIGRpZmZlcmVudCwKCSAqIHRoZW4gd2Uga25vdyBpdCBpcy4KCSAqLwoJaWYgKChjaGFuZ2VkICYgREFUQV9DSEFOR0VEKSAmJgoJICAgIChTX0lTR0lUTElOSyhjZS0+Y2VfbW9kZSkgfHwgY2UtPmNlX3N0YXRfZGF0YS5zZF9zaXplICE9IDApKQoJCXJldHVybiBjaGFuZ2VkOwoKCWNoYW5nZWRfZnMgPSBjZV9tb2RpZmllZF9jaGVja19mcyhjZSwgc3QpOwoJaWYgKGNoYW5nZWRfZnMpCgkJcmV0dXJuIGNoYW5nZWQgfCBjaGFuZ2VkX2ZzOwoJcmV0dXJuIDA7Cn0KCmludCBiYXNlX25hbWVfY29tcGFyZShjb25zdCBjaGFyICpuYW1lMSwgaW50IGxlbjEsIGludCBtb2RlMSwKCQkgICAgICBjb25zdCBjaGFyICpuYW1lMiwgaW50IGxlbjIsIGludCBtb2RlMikKewoJdW5zaWduZWQgY2hhciBjMSwgYzI7CglpbnQgbGVuID0gbGVuMSA8IGxlbjIgPyBsZW4xIDogbGVuMjsKCWludCBjbXA7CgoJY21wID0gbWVtY21wKG5hbWUxLCBuYW1lMiwgbGVuKTsKCWlmIChjbXApCgkJcmV0dXJuIGNtcDsKCWMxID0gbmFtZTFbbGVuXTsKCWMyID0gbmFtZTJbbGVuXTsKCWlmICghYzEgJiYgU19JU0RJUihtb2RlMSkpCgkJYzEgPSAnLyc7CglpZiAoIWMyICYmIFNfSVNESVIobW9kZTIpKQoJCWMyID0gJy8nOwoJcmV0dXJuIChjMSA8IGMyKSA/IC0xIDogKGMxID4gYzIpID8gMSA6IDA7Cn0KCi8qCiAqIGRmX25hbWVfY29tcGFyZSgpIGlzIGlkZW50aWNhbCB0byBiYXNlX25hbWVfY29tcGFyZSgpLCBleGNlcHQgaXQKICogY29tcGFyZXMgY29uZmxpY3RpbmcgZGlyZWN0b3J5L2ZpbGUgZW50cmllcyBhcyBlcXVhbC4gTm90ZSB0aGF0CiAqIHdoaWxlIGEgZGlyZWN0b3J5IG5hbWUgY29tcGFyZXMgYXMgZXF1YWwgdG8gYSByZWd1bGFyIGZpbGUsIHRoZXkKICogdGhlbiBpbmRpdmlkdWFsbHkgY29tcGFyZSBfZGlmZmVyZW50bHlfIHRvIGEgZmlsZW5hbWUgdGhhdCBoYXMKICogYSBkb3QgYWZ0ZXIgdGhlIGJhc2VuYW1lIChiZWNhdXNlICdcMCcgPCAnLicgPCAnLycpLgogKgogKiBUaGlzIGlzIHVzZWQgYnkgcm91dGluZXMgdGhhdCB3YW50IHRvIHRyYXZlcnNlIHRoZSBnaXQgbmFtZXNwYWNlCiAqIGJ1dCB0aGVuIGhhbmRsZSBjb25mbGljdGluZyBlbnRyaWVzIHRvZ2V0aGVyIHdoZW4gcG9zc2libGUuCiAqLwppbnQgZGZfbmFtZV9jb21wYXJlKGNvbnN0IGNoYXIgKm5hbWUxLCBpbnQgbGVuMSwgaW50IG1vZGUxLAoJCSAgICBjb25zdCBjaGFyICpuYW1lMiwgaW50IGxlbjIsIGludCBtb2RlMikKewoJaW50IGxlbiA9IGxlbjEgPCBsZW4yID8gbGVuMSA6IGxlbjIsIGNtcDsKCXVuc2lnbmVkIGNoYXIgYzEsIGMyOwoKCWNtcCA9IG1lbWNtcChuYW1lMSwgbmFtZTIsIGxlbik7CglpZiAoY21wKQoJCXJldHVybiBjbXA7CgkvKiBEaXJlY3RvcmllcyBhbmQgZmlsZXMgY29tcGFyZSBlcXVhbCAoc2FtZSBsZW5ndGgsIHNhbWUgbmFtZSkgKi8KCWlmIChsZW4xID09IGxlbjIpCgkJcmV0dXJuIDA7CgljMSA9IG5hbWUxW2xlbl07CglpZiAoIWMxICYmIFNfSVNESVIobW9kZTEpKQoJCWMxID0gJy8nOwoJYzIgPSBuYW1lMltsZW5dOwoJaWYgKCFjMiAmJiBTX0lTRElSKG1vZGUyKSkKCQljMiA9ICcvJzsKCWlmIChjMSA9PSAnLycgJiYgIWMyKQoJCXJldHVybiAwOwoJaWYgKGMyID09ICcvJyAmJiAhYzEpCgkJcmV0dXJuIDA7CglyZXR1cm4gYzEgLSBjMjsKfQoKaW50IGNhY2hlX25hbWVfc3RhZ2VfY29tcGFyZShjb25zdCBjaGFyICpuYW1lMSwgaW50IGxlbjEsIGludCBzdGFnZTEsIGNvbnN0IGNoYXIgKm5hbWUyLCBpbnQgbGVuMiwgaW50IHN0YWdlMikKewoJaW50IGxlbiA9IGxlbjEgPCBsZW4yID8gbGVuMSA6IGxlbjI7CglpbnQgY21wOwoKCWNtcCA9IG1lbWNtcChuYW1lMSwgbmFtZTIsIGxlbik7CglpZiAoY21wKQoJCXJldHVybiBjbXA7CglpZiAobGVuMSA8IGxlbjIpCgkJcmV0dXJuIC0xOwoJaWYgKGxlbjEgPiBsZW4yKQoJCXJldHVybiAxOwoKCWlmIChzdGFnZTEgPCBzdGFnZTIpCgkJcmV0dXJuIC0xOwoJaWYgKHN0YWdlMSA+IHN0YWdlMikKCQlyZXR1cm4gMTsKCXJldHVybiAwOwp9CgppbnQgY2FjaGVfbmFtZV9jb21wYXJlKGNvbnN0IGNoYXIgKm5hbWUxLCBpbnQgbGVuMSwgY29uc3QgY2hhciAqbmFtZTIsIGludCBsZW4yKQp7CglyZXR1cm4gY2FjaGVfbmFtZV9zdGFnZV9jb21wYXJlKG5hbWUxLCBsZW4xLCAwLCBuYW1lMiwgbGVuMiwgMCk7Cn0KCnN0YXRpYyBpbnQgaW5kZXhfbmFtZV9zdGFnZV9wb3MoY29uc3Qgc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIGNvbnN0IGNoYXIgKm5hbWUsIGludCBuYW1lbGVuLCBpbnQgc3RhZ2UpCnsKCWludCBmaXJzdCwgbGFzdDsKCglmaXJzdCA9IDA7CglsYXN0ID0gaXN0YXRlLT5jYWNoZV9ucjsKCXdoaWxlIChsYXN0ID4gZmlyc3QpIHsKCQlpbnQgbmV4dCA9IChsYXN0ICsgZmlyc3QpID4+IDE7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGlzdGF0ZS0+Y2FjaGVbbmV4dF07CgkJaW50IGNtcCA9IGNhY2hlX25hbWVfc3RhZ2VfY29tcGFyZShuYW1lLCBuYW1lbGVuLCBzdGFnZSwgY2UtPm5hbWUsIGNlX25hbWVsZW4oY2UpLCBjZV9zdGFnZShjZSkpOwoJCWlmICghY21wKQoJCQlyZXR1cm4gbmV4dDsKCQlpZiAoY21wIDwgMCkgewoJCQlsYXN0ID0gbmV4dDsKCQkJY29udGludWU7CgkJfQoJCWZpcnN0ID0gbmV4dCsxOwoJfQoJcmV0dXJuIC1maXJzdC0xOwp9CgppbnQgaW5kZXhfbmFtZV9wb3MoY29uc3Qgc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIGNvbnN0IGNoYXIgKm5hbWUsIGludCBuYW1lbGVuKQp7CglyZXR1cm4gaW5kZXhfbmFtZV9zdGFnZV9wb3MoaXN0YXRlLCBuYW1lLCBuYW1lbGVuLCAwKTsKfQoKLyogUmVtb3ZlIGVudHJ5LCByZXR1cm4gdHJ1ZSBpZiB0aGVyZSBhcmUgbW9yZSBlbnRyaWVzIHRvIGdvLi4gKi8KaW50IHJlbW92ZV9pbmRleF9lbnRyeV9hdChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgaW50IHBvcykKewoJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGlzdGF0ZS0+Y2FjaGVbcG9zXTsKCglyZWNvcmRfcmVzb2x2ZV91bmRvKGlzdGF0ZSwgY2UpOwoJcmVtb3ZlX25hbWVfaGFzaChpc3RhdGUsIGNlKTsKCWlzdGF0ZS0+Y2FjaGVfY2hhbmdlZCA9IDE7Cglpc3RhdGUtPmNhY2hlX25yLS07CglpZiAocG9zID49IGlzdGF0ZS0+Y2FjaGVfbnIpCgkJcmV0dXJuIDA7CgltZW1tb3ZlKGlzdGF0ZS0+Y2FjaGUgKyBwb3MsCgkJaXN0YXRlLT5jYWNoZSArIHBvcyArIDEsCgkJKGlzdGF0ZS0+Y2FjaGVfbnIgLSBwb3MpICogc2l6ZW9mKHN0cnVjdCBjYWNoZV9lbnRyeSAqKSk7CglyZXR1cm4gMTsKfQoKLyoKICogUmVtb3ZlIGFsbCBjYWNoZSBlbnRyaWVzIG1hcmtlZCBmb3IgcmVtb3ZhbCwgdGhhdCBpcyB3aGVyZQogKiBDRV9SRU1PVkUgaXMgc2V0IGluIGNlX2ZsYWdzLiAgVGhpcyBpcyBtdWNoIG1vcmUgZWZmZWN0aXZlIHRoYW4KICogY2FsbGluZyByZW1vdmVfaW5kZXhfZW50cnlfYXQoKSBmb3IgZWFjaCBlbnRyeSB0byBiZSByZW1vdmVkLgogKi8Kdm9pZCByZW1vdmVfbWFya2VkX2NhY2hlX2VudHJpZXMoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUpCnsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqKmNlX2FycmF5ID0gaXN0YXRlLT5jYWNoZTsKCXVuc2lnbmVkIGludCBpLCBqOwoKCWZvciAoaSA9IGogPSAwOyBpIDwgaXN0YXRlLT5jYWNoZV9ucjsgaSsrKSB7CgkJaWYgKGNlX2FycmF5W2ldLT5jZV9mbGFncyAmIENFX1JFTU9WRSkKCQkJcmVtb3ZlX25hbWVfaGFzaChpc3RhdGUsIGNlX2FycmF5W2ldKTsKCQllbHNlCgkJCWNlX2FycmF5W2orK10gPSBjZV9hcnJheVtpXTsKCX0KCWlzdGF0ZS0+Y2FjaGVfY2hhbmdlZCA9IDE7Cglpc3RhdGUtPmNhY2hlX25yID0gajsKfQoKaW50IHJlbW92ZV9maWxlX2Zyb21faW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIGNvbnN0IGNoYXIgKnBhdGgpCnsKCWludCBwb3MgPSBpbmRleF9uYW1lX3Bvcyhpc3RhdGUsIHBhdGgsIHN0cmxlbihwYXRoKSk7CglpZiAocG9zIDwgMCkKCQlwb3MgPSAtcG9zLTE7CgljYWNoZV90cmVlX2ludmFsaWRhdGVfcGF0aChpc3RhdGUtPmNhY2hlX3RyZWUsIHBhdGgpOwoJd2hpbGUgKHBvcyA8IGlzdGF0ZS0+Y2FjaGVfbnIgJiYgIXN0cmNtcChpc3RhdGUtPmNhY2hlW3Bvc10tPm5hbWUsIHBhdGgpKQoJCXJlbW92ZV9pbmRleF9lbnRyeV9hdChpc3RhdGUsIHBvcyk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBjb21wYXJlX25hbWUoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgY29uc3QgY2hhciAqcGF0aCwgaW50IG5hbWVsZW4pCnsKCXJldHVybiBuYW1lbGVuICE9IGNlX25hbWVsZW4oY2UpIHx8IG1lbWNtcChwYXRoLCBjZS0+bmFtZSwgbmFtZWxlbik7Cn0KCnN0YXRpYyBpbnQgaW5kZXhfbmFtZV9wb3NfYWxzb191bm1lcmdlZChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwKCWNvbnN0IGNoYXIgKnBhdGgsIGludCBuYW1lbGVuKQp7CglpbnQgcG9zID0gaW5kZXhfbmFtZV9wb3MoaXN0YXRlLCBwYXRoLCBuYW1lbGVuKTsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2U7CgoJaWYgKHBvcyA+PSAwKQoJCXJldHVybiBwb3M7CgoJLyogbWF5YmUgdW5tZXJnZWQ/ICovCglwb3MgPSAtMSAtIHBvczsKCWlmIChwb3MgPj0gaXN0YXRlLT5jYWNoZV9uciB8fAoJCQljb21wYXJlX25hbWUoKGNlID0gaXN0YXRlLT5jYWNoZVtwb3NdKSwgcGF0aCwgbmFtZWxlbikpCgkJcmV0dXJuIC0xOwoKCS8qIG9yZGVyIG9mIHByZWZlcmVuY2U6IHN0YWdlIDIsIDEsIDMgKi8KCWlmIChjZV9zdGFnZShjZSkgPT0gMSAmJiBwb3MgKyAxIDwgaXN0YXRlLT5jYWNoZV9uciAmJgoJCQljZV9zdGFnZSgoY2UgPSBpc3RhdGUtPmNhY2hlW3BvcyArIDFdKSkgPT0gMiAmJgoJCQkhY29tcGFyZV9uYW1lKGNlLCBwYXRoLCBuYW1lbGVuKSkKCQlwb3MrKzsKCXJldHVybiBwb3M7Cn0KCnN0YXRpYyBpbnQgZGlmZmVyZW50X25hbWUoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgc3RydWN0IGNhY2hlX2VudHJ5ICphbGlhcykKewoJaW50IGxlbiA9IGNlX25hbWVsZW4oY2UpOwoJcmV0dXJuIGNlX25hbWVsZW4oYWxpYXMpICE9IGxlbiB8fCBtZW1jbXAoY2UtPm5hbWUsIGFsaWFzLT5uYW1lLCBsZW4pOwp9CgovKgogKiBJZiB3ZSBhZGQgYSBmaWxlbmFtZSB0aGF0IGFsaWFzZXMgaW4gdGhlIGNhY2hlLCB3ZSB3aWxsIHVzZSB0aGUKICogbmFtZSB0aGF0IHdlIGFscmVhZHkgaGF2ZSAtIGJ1dCB3ZSBkb24ndCB3YW50IHRvIHVwZGF0ZSB0aGUgc2FtZQogKiBhbGlhcyB0d2ljZSwgYmVjYXVzZSB0aGF0IGltcGxpZXMgdGhhdCB0aGVyZSB3ZXJlIGFjdHVhbGx5IHR3bwogKiBkaWZmZXJlbnQgZmlsZXMgd2l0aCBhbGlhc2luZyBuYW1lcyEKICoKICogU28gd2UgdXNlIHRoZSBDRV9BRERFRCBmbGFnIHRvIHZlcmlmeSB0aGF0IHRoZSBhbGlhcyB3YXMgYW4gb2xkCiAqIG9uZSBiZWZvcmUgd2UgYWNjZXB0IGl0IGFzCiAqLwpzdGF0aWMgc3RydWN0IGNhY2hlX2VudHJ5ICpjcmVhdGVfYWxpYXNfY2Uoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgc3RydWN0IGNhY2hlX2VudHJ5ICphbGlhcykKewoJaW50IGxlbjsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqbmV3OwoKCWlmIChhbGlhcy0+Y2VfZmxhZ3MgJiBDRV9BRERFRCkKCQlkaWUoIldpbGwgbm90IGFkZCBmaWxlIGFsaWFzICclcycgKCclcycgYWxyZWFkeSBleGlzdHMgaW4gaW5kZXgpIiwgY2UtPm5hbWUsIGFsaWFzLT5uYW1lKTsKCgkvKiBPaywgY3JlYXRlIHRoZSBuZXcgZW50cnkgdXNpbmcgdGhlIG5hbWUgb2YgdGhlIGV4aXN0aW5nIGFsaWFzICovCglsZW4gPSBjZV9uYW1lbGVuKGFsaWFzKTsKCW5ldyA9IHhjYWxsb2MoMSwgY2FjaGVfZW50cnlfc2l6ZShsZW4pKTsKCW1lbWNweShuZXctPm5hbWUsIGFsaWFzLT5uYW1lLCBsZW4pOwoJY29weV9jYWNoZV9lbnRyeShuZXcsIGNlKTsKCWZyZWUoY2UpOwoJcmV0dXJuIG5ldzsKfQoKc3RhdGljIHZvaWQgcmVjb3JkX2ludGVudF90b19hZGQoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSkKewoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCWlmICh3cml0ZV9zaGExX2ZpbGUoIiIsIDAsIGJsb2JfdHlwZSwgc2hhMSkpCgkJZGllKCJjYW5ub3QgY3JlYXRlIGFuIGVtcHR5IGJsb2IgaW4gdGhlIG9iamVjdCBkYXRhYmFzZSIpOwoJaGFzaGNweShjZS0+c2hhMSwgc2hhMSk7Cn0KCmludCBhZGRfdG9faW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIGNvbnN0IGNoYXIgKnBhdGgsIHN0cnVjdCBzdGF0ICpzdCwgaW50IGZsYWdzKQp7CglpbnQgc2l6ZSwgbmFtZWxlbiwgd2FzX3NhbWU7Cgltb2RlX3Qgc3RfbW9kZSA9IHN0LT5zdF9tb2RlOwoJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgKmFsaWFzOwoJdW5zaWduZWQgY2Vfb3B0aW9uID0gQ0VfTUFUQ0hfSUdOT1JFX1ZBTElEfENFX01BVENIX0lHTk9SRV9TS0lQX1dPUktUUkVFfENFX01BVENIX1JBQ1lfSVNfRElSVFk7CglpbnQgdmVyYm9zZSA9IGZsYWdzICYgKEFERF9DQUNIRV9WRVJCT1NFIHwgQUREX0NBQ0hFX1BSRVRFTkQpOwoJaW50IHByZXRlbmQgPSBmbGFncyAmIEFERF9DQUNIRV9QUkVURU5EOwoJaW50IGludGVudF9vbmx5ID0gZmxhZ3MgJiBBRERfQ0FDSEVfSU5URU5UOwoJaW50IGFkZF9vcHRpb24gPSAoQUREX0NBQ0hFX09LX1RPX0FERHxBRERfQ0FDSEVfT0tfVE9fUkVQTEFDRXwKCQkJICAoaW50ZW50X29ubHkgPyBBRERfQ0FDSEVfTkVXX09OTFkgOiAwKSk7CgoJaWYgKCFTX0lTUkVHKHN0X21vZGUpICYmICFTX0lTTE5LKHN0X21vZGUpICYmICFTX0lTRElSKHN0X21vZGUpKQoJCXJldHVybiBlcnJvcigiJXM6IGNhbiBvbmx5IGFkZCByZWd1bGFyIGZpbGVzLCBzeW1ib2xpYyBsaW5rcyBvciBnaXQtZGlyZWN0b3JpZXMiLCBwYXRoKTsKCgluYW1lbGVuID0gc3RybGVuKHBhdGgpOwoJaWYgKFNfSVNESVIoc3RfbW9kZSkpIHsKCQl3aGlsZSAobmFtZWxlbiAmJiBwYXRoW25hbWVsZW4tMV0gPT0gJy8nKQoJCQluYW1lbGVuLS07Cgl9CglzaXplID0gY2FjaGVfZW50cnlfc2l6ZShuYW1lbGVuKTsKCWNlID0geGNhbGxvYygxLCBzaXplKTsKCW1lbWNweShjZS0+bmFtZSwgcGF0aCwgbmFtZWxlbik7CgljZS0+Y2VfbmFtZWxlbiA9IG5hbWVsZW47CglpZiAoIWludGVudF9vbmx5KQoJCWZpbGxfc3RhdF9jYWNoZV9pbmZvKGNlLCBzdCk7CgllbHNlCgkJY2UtPmNlX2ZsYWdzIHw9IENFX0lOVEVOVF9UT19BREQ7CgoJaWYgKHRydXN0X2V4ZWN1dGFibGVfYml0ICYmIGhhc19zeW1saW5rcykKCQljZS0+Y2VfbW9kZSA9IGNyZWF0ZV9jZV9tb2RlKHN0X21vZGUpOwoJZWxzZSB7CgkJLyogSWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgZW50cnksIHBpY2sgdGhlIG1vZGUgYml0cyBhbmQgdHlwZQoJCSAqIGZyb20gaXQsIG90aGVyd2lzZSBhc3N1bWUgdW5leGVjdXRhYmxlIHJlZ3VsYXIgZmlsZS4KCQkgKi8KCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmVudDsKCQlpbnQgcG9zID0gaW5kZXhfbmFtZV9wb3NfYWxzb191bm1lcmdlZChpc3RhdGUsIHBhdGgsIG5hbWVsZW4pOwoKCQllbnQgPSAoMCA8PSBwb3MpID8gaXN0YXRlLT5jYWNoZVtwb3NdIDogTlVMTDsKCQljZS0+Y2VfbW9kZSA9IGNlX21vZGVfZnJvbV9zdGF0KGVudCwgc3RfbW9kZSk7Cgl9CgoJLyogV2hlbiBjb3JlLmlnbm9yZWNhc2U9dHJ1ZSwgZGV0ZXJtaW5lIGlmIGEgZGlyZWN0b3J5IG9mIHRoZSBzYW1lIG5hbWUgYnV0IGRpZmZlcmluZwoJICogY2FzZSBhbHJlYWR5IGV4aXN0cyB3aXRoaW4gdGhlIEdpdCByZXBvc2l0b3J5LiAgSWYgaXQgZG9lcywgZW5zdXJlIHRoZSBkaXJlY3RvcnkKCSAqIGNhc2Ugb2YgdGhlIGZpbGUgYmVpbmcgYWRkZWQgdG8gdGhlIHJlcG9zaXRvcnkgbWF0Y2hlcyAoaXMgZm9sZGVkIGludG8pIHRoZSBleGlzdGluZwoJICogZW50cnkncyBkaXJlY3RvcnkgY2FzZS4KCSAqLwoJaWYgKGlnbm9yZV9jYXNlKSB7CgkJY29uc3QgY2hhciAqc3RhcnRQdHIgPSBjZS0+bmFtZTsKCQljb25zdCBjaGFyICpwdHIgPSBzdGFydFB0cjsKCQl3aGlsZSAoKnB0cikgewoJCQl3aGlsZSAoKnB0ciAmJiAqcHRyICE9ICcvJykKCQkJCSsrcHRyOwoJCQlpZiAoKnB0ciA9PSAnLycpIHsKCQkJCXN0cnVjdCBjYWNoZV9lbnRyeSAqZm91bmRjZTsKCQkJCSsrcHRyOwoJCQkJZm91bmRjZSA9IGluZGV4X2Rpcl9leGlzdHMoaXN0YXRlLCBjZS0+bmFtZSwgcHRyIC0gY2UtPm5hbWUgLSAxKTsKCQkJCWlmIChmb3VuZGNlKSB7CgkJCQkJbWVtY3B5KCh2b2lkICopc3RhcnRQdHIsIGZvdW5kY2UtPm5hbWUgKyAoc3RhcnRQdHIgLSBjZS0+bmFtZSksIHB0ciAtIHN0YXJ0UHRyKTsKCQkJCQlzdGFydFB0ciA9IHB0cjsKCQkJCX0KCQkJfQoJCX0KCX0KCglhbGlhcyA9IGluZGV4X2ZpbGVfZXhpc3RzKGlzdGF0ZSwgY2UtPm5hbWUsIGNlX25hbWVsZW4oY2UpLCBpZ25vcmVfY2FzZSk7CglpZiAoYWxpYXMgJiYgIWNlX3N0YWdlKGFsaWFzKSAmJiAhaWVfbWF0Y2hfc3RhdChpc3RhdGUsIGFsaWFzLCBzdCwgY2Vfb3B0aW9uKSkgewoJCS8qIE5vdGhpbmcgY2hhbmdlZCwgcmVhbGx5ICovCgkJZnJlZShjZSk7CgkJaWYgKCFTX0lTR0lUTElOSyhhbGlhcy0+Y2VfbW9kZSkpCgkJCWNlX21hcmtfdXB0b2RhdGUoYWxpYXMpOwoJCWFsaWFzLT5jZV9mbGFncyB8PSBDRV9BRERFRDsKCQlyZXR1cm4gMDsKCX0KCWlmICghaW50ZW50X29ubHkpIHsKCQlpZiAoaW5kZXhfcGF0aChjZS0+c2hhMSwgcGF0aCwgc3QsIEhBU0hfV1JJVEVfT0JKRUNUKSkKCQkJcmV0dXJuIGVycm9yKCJ1bmFibGUgdG8gaW5kZXggZmlsZSAlcyIsIHBhdGgpOwoJfSBlbHNlCgkJcmVjb3JkX2ludGVudF90b19hZGQoY2UpOwoKCWlmIChpZ25vcmVfY2FzZSAmJiBhbGlhcyAmJiBkaWZmZXJlbnRfbmFtZShjZSwgYWxpYXMpKQoJCWNlID0gY3JlYXRlX2FsaWFzX2NlKGNlLCBhbGlhcyk7CgljZS0+Y2VfZmxhZ3MgfD0gQ0VfQURERUQ7CgoJLyogSXQgd2FzIHN1c3BlY3RlZCB0byBiZSByYWNpbHkgY2xlYW4sIGJ1dCBpdCB0dXJucyBvdXQgdG8gYmUgT2sgKi8KCXdhc19zYW1lID0gKGFsaWFzICYmCgkJICAgICFjZV9zdGFnZShhbGlhcykgJiYKCQkgICAgIWhhc2hjbXAoYWxpYXMtPnNoYTEsIGNlLT5zaGExKSAmJgoJCSAgICBjZS0+Y2VfbW9kZSA9PSBhbGlhcy0+Y2VfbW9kZSk7CgoJaWYgKHByZXRlbmQpCgkJOwoJZWxzZSBpZiAoYWRkX2luZGV4X2VudHJ5KGlzdGF0ZSwgY2UsIGFkZF9vcHRpb24pKQoJCXJldHVybiBlcnJvcigidW5hYmxlIHRvIGFkZCAlcyB0byBpbmRleCIscGF0aCk7CglpZiAodmVyYm9zZSAmJiAhd2FzX3NhbWUpCgkJcHJpbnRmKCJhZGQgJyVzJ1xuIiwgcGF0aCk7CglyZXR1cm4gMDsKfQoKaW50IGFkZF9maWxlX3RvX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBjb25zdCBjaGFyICpwYXRoLCBpbnQgZmxhZ3MpCnsKCXN0cnVjdCBzdGF0IHN0OwoJaWYgKGxzdGF0KHBhdGgsICZzdCkpCgkJZGllX2Vycm5vKCJ1bmFibGUgdG8gc3RhdCAnJXMnIiwgcGF0aCk7CglyZXR1cm4gYWRkX3RvX2luZGV4KGlzdGF0ZSwgcGF0aCwgJnN0LCBmbGFncyk7Cn0KCnN0cnVjdCBjYWNoZV9lbnRyeSAqbWFrZV9jYWNoZV9lbnRyeSh1bnNpZ25lZCBpbnQgbW9kZSwKCQljb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBjb25zdCBjaGFyICpwYXRoLCBpbnQgc3RhZ2UsCgkJaW50IHJlZnJlc2gpCnsKCWludCBzaXplLCBsZW47CglzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlOwoKCWlmICghdmVyaWZ5X3BhdGgocGF0aCkpIHsKCQllcnJvcigiSW52YWxpZCBwYXRoICclcyciLCBwYXRoKTsKCQlyZXR1cm4gTlVMTDsKCX0KCglsZW4gPSBzdHJsZW4ocGF0aCk7CglzaXplID0gY2FjaGVfZW50cnlfc2l6ZShsZW4pOwoJY2UgPSB4Y2FsbG9jKDEsIHNpemUpOwoKCWhhc2hjcHkoY2UtPnNoYTEsIHNoYTEpOwoJbWVtY3B5KGNlLT5uYW1lLCBwYXRoLCBsZW4pOwoJY2UtPmNlX2ZsYWdzID0gY3JlYXRlX2NlX2ZsYWdzKHN0YWdlKTsKCWNlLT5jZV9uYW1lbGVuID0gbGVuOwoJY2UtPmNlX21vZGUgPSBjcmVhdGVfY2VfbW9kZShtb2RlKTsKCglpZiAocmVmcmVzaCkKCQlyZXR1cm4gcmVmcmVzaF9jYWNoZV9lbnRyeShjZSwgMCk7CgoJcmV0dXJuIGNlOwp9CgppbnQgY2Vfc2FtZV9uYW1lKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqYSwgY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpiKQp7CglpbnQgbGVuID0gY2VfbmFtZWxlbihhKTsKCXJldHVybiBjZV9uYW1lbGVuKGIpID09IGxlbiAmJiAhbWVtY21wKGEtPm5hbWUsIGItPm5hbWUsIGxlbik7Cn0KCmludCBjZV9wYXRoX21hdGNoKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIGNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcGF0aHNwZWMpCnsKCXJldHVybiBtYXRjaF9wYXRoc3BlY19kZXB0aChwYXRoc3BlYywgY2UtPm5hbWUsIGNlX25hbWVsZW4oY2UpLCAwLCBOVUxMKTsKfQoKLyoKICogV2UgZnVuZGFtZW50YWxseSBkb24ndCBsaWtlIHNvbWUgcGF0aHM6IHdlIGRvbid0IHdhbnQKICogZG90IG9yIGRvdC1kb3QgYW55d2hlcmUsIGFuZCBmb3Igb2J2aW91cyByZWFzb25zIGRvbid0CiAqIHdhbnQgdG8gcmVjdXJzZSBpbnRvICIuZ2l0IiBlaXRoZXIuCiAqCiAqIEFsc28sIHdlIGRvbid0IHdhbnQgZG91YmxlIHNsYXNoZXMgb3Igc2xhc2hlcyBhdCB0aGUKICogZW5kIHRoYXQgY2FuIG1ha2UgcGF0aG5hbWVzIGFtYmlndW91cy4KICovCnN0YXRpYyBpbnQgdmVyaWZ5X2RvdGZpbGUoY29uc3QgY2hhciAqcmVzdCkKewoJLyoKCSAqIFRoZSBmaXJzdCBjaGFyYWN0ZXIgd2FzICcuJywgYnV0IHRoYXQKCSAqIGhhcyBhbHJlYWR5IGJlZW4gZGlzY2FyZGVkLCB3ZSBub3cgdGVzdAoJICogdGhlIHJlc3QuCgkgKi8KCgkvKiAiLiIgaXMgbm90IGFsbG93ZWQgKi8KCWlmICgqcmVzdCA9PSAnXDAnIHx8IGlzX2Rpcl9zZXAoKnJlc3QpKQoJCXJldHVybiAwOwoKCXN3aXRjaCAoKnJlc3QpIHsKCS8qCgkgKiAiLmdpdCIgZm9sbG93ZWQgYnkgIE5VTCBvciBzbGFzaCBpcyBiYWQuIFRoaXMKCSAqIHNoYXJlcyB0aGUgcGF0aCBlbmQgdGVzdCB3aXRoIHRoZSAiLi4iIGNhc2UuCgkgKi8KCWNhc2UgJ2cnOgoJCWlmIChyZXN0WzFdICE9ICdpJykKCQkJYnJlYWs7CgkJaWYgKHJlc3RbMl0gIT0gJ3QnKQoJCQlicmVhazsKCQlyZXN0ICs9IDI7CgkvKiBmYWxsdGhyb3VnaCAqLwoJY2FzZSAnLic6CgkJaWYgKHJlc3RbMV0gPT0gJ1wwJyB8fCBpc19kaXJfc2VwKHJlc3RbMV0pKQoJCQlyZXR1cm4gMDsKCX0KCXJldHVybiAxOwp9CgppbnQgdmVyaWZ5X3BhdGgoY29uc3QgY2hhciAqcGF0aCkKewoJY2hhciBjOwoKCWlmIChoYXNfZG9zX2RyaXZlX3ByZWZpeChwYXRoKSkKCQlyZXR1cm4gMDsKCglnb3RvIGluc2lkZTsKCWZvciAoOzspIHsKCQlpZiAoIWMpCgkJCXJldHVybiAxOwoJCWlmIChpc19kaXJfc2VwKGMpKSB7Cmluc2lkZToKCQkJYyA9ICpwYXRoKys7CgkJCWlmICgoYyA9PSAnLicgJiYgIXZlcmlmeV9kb3RmaWxlKHBhdGgpKSB8fAoJCQkgICAgaXNfZGlyX3NlcChjKSB8fCBjID09ICdcMCcpCgkJCQlyZXR1cm4gMDsKCQl9CgkJYyA9ICpwYXRoKys7Cgl9Cn0KCi8qCiAqIERvIHdlIGhhdmUgYW5vdGhlciBmaWxlIHRoYXQgaGFzIHRoZSBiZWdpbm5pbmcgY29tcG9uZW50cyBiZWluZyBhCiAqIHByb3BlciBzdXBlcnNldCBvZiB0aGUgbmFtZSB3ZSdyZSB0cnlpbmcgdG8gYWRkPwogKi8Kc3RhdGljIGludCBoYXNfZmlsZV9uYW1lKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLAoJCQkgY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgaW50IHBvcywgaW50IG9rX3RvX3JlcGxhY2UpCnsKCWludCByZXR2YWwgPSAwOwoJaW50IGxlbiA9IGNlX25hbWVsZW4oY2UpOwoJaW50IHN0YWdlID0gY2Vfc3RhZ2UoY2UpOwoJY29uc3QgY2hhciAqbmFtZSA9IGNlLT5uYW1lOwoKCXdoaWxlIChwb3MgPCBpc3RhdGUtPmNhY2hlX25yKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpwID0gaXN0YXRlLT5jYWNoZVtwb3MrK107CgoJCWlmIChsZW4gPj0gY2VfbmFtZWxlbihwKSkKCQkJYnJlYWs7CgkJaWYgKG1lbWNtcChuYW1lLCBwLT5uYW1lLCBsZW4pKQoJCQlicmVhazsKCQlpZiAoY2Vfc3RhZ2UocCkgIT0gc3RhZ2UpCgkJCWNvbnRpbnVlOwoJCWlmIChwLT5uYW1lW2xlbl0gIT0gJy8nKQoJCQljb250aW51ZTsKCQlpZiAocC0+Y2VfZmxhZ3MgJiBDRV9SRU1PVkUpCgkJCWNvbnRpbnVlOwoJCXJldHZhbCA9IC0xOwoJCWlmICghb2tfdG9fcmVwbGFjZSkKCQkJYnJlYWs7CgkJcmVtb3ZlX2luZGV4X2VudHJ5X2F0KGlzdGF0ZSwgLS1wb3MpOwoJfQoJcmV0dXJuIHJldHZhbDsKfQoKLyoKICogRG8gd2UgaGF2ZSBhbm90aGVyIGZpbGUgd2l0aCBhIHBhdGhuYW1lIHRoYXQgaXMgYSBwcm9wZXIKICogc3Vic2V0IG9mIHRoZSBuYW1lIHdlJ3JlIHRyeWluZyB0byBhZGQ/CiAqLwpzdGF0aWMgaW50IGhhc19kaXJfbmFtZShzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwKCQkJY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgaW50IHBvcywgaW50IG9rX3RvX3JlcGxhY2UpCnsKCWludCByZXR2YWwgPSAwOwoJaW50IHN0YWdlID0gY2Vfc3RhZ2UoY2UpOwoJY29uc3QgY2hhciAqbmFtZSA9IGNlLT5uYW1lOwoJY29uc3QgY2hhciAqc2xhc2ggPSBuYW1lICsgY2VfbmFtZWxlbihjZSk7CgoJZm9yICg7OykgewoJCWludCBsZW47CgoJCWZvciAoOzspIHsKCQkJaWYgKCotLXNsYXNoID09ICcvJykKCQkJCWJyZWFrOwoJCQlpZiAoc2xhc2ggPD0gY2UtPm5hbWUpCgkJCQlyZXR1cm4gcmV0dmFsOwoJCX0KCQlsZW4gPSBzbGFzaCAtIG5hbWU7CgoJCXBvcyA9IGluZGV4X25hbWVfc3RhZ2VfcG9zKGlzdGF0ZSwgbmFtZSwgbGVuLCBzdGFnZSk7CgkJaWYgKHBvcyA+PSAwKSB7CgkJCS8qCgkJCSAqIEZvdW5kIG9uZSwgYnV0IG5vdCBzbyBmYXN0LiAgVGhpcyBjb3VsZAoJCQkgKiBiZSBhIG1hcmtlciB0aGF0IHNheXMgIkkgd2FzIGhlcmUsIGJ1dAoJCQkgKiBJIGFtIGJlaW5nIHJlbW92ZWQiLiAgU3VjaCBhbiBlbnRyeSBpcwoJCQkgKiBub3QgYSBwYXJ0IG9mIHRoZSByZXN1bHRpbmcgdHJlZSwgYW5kCgkJCSAqIGl0IGlzIE9rIHRvIGhhdmUgYSBkaXJlY3RvcnkgYXQgdGhlIHNhbWUKCQkJICogcGF0aC4KCQkJICovCgkJCWlmICghKGlzdGF0ZS0+Y2FjaGVbcG9zXS0+Y2VfZmxhZ3MgJiBDRV9SRU1PVkUpKSB7CgkJCQlyZXR2YWwgPSAtMTsKCQkJCWlmICghb2tfdG9fcmVwbGFjZSkKCQkJCQlicmVhazsKCQkJCXJlbW92ZV9pbmRleF9lbnRyeV9hdChpc3RhdGUsIHBvcyk7CgkJCQljb250aW51ZTsKCQkJfQoJCX0KCQllbHNlCgkJCXBvcyA9IC1wb3MtMTsKCgkJLyoKCQkgKiBUcml2aWFsIG9wdGltaXphdGlvbjogaWYgd2UgZmluZCBhbiBlbnRyeSB0aGF0CgkJICogYWxyZWFkeSBtYXRjaGVzIHRoZSBzdWItZGlyZWN0b3J5LCB0aGVuIHdlIGtub3cKCQkgKiB3ZSdyZSBvaywgYW5kIHdlIGNhbiBleGl0LgoJCSAqLwoJCXdoaWxlIChwb3MgPCBpc3RhdGUtPmNhY2hlX25yKSB7CgkJCXN0cnVjdCBjYWNoZV9lbnRyeSAqcCA9IGlzdGF0ZS0+Y2FjaGVbcG9zXTsKCQkJaWYgKChjZV9uYW1lbGVuKHApIDw9IGxlbikgfHwKCQkJICAgIChwLT5uYW1lW2xlbl0gIT0gJy8nKSB8fAoJCQkgICAgbWVtY21wKHAtPm5hbWUsIG5hbWUsIGxlbikpCgkJCQlicmVhazsgLyogbm90IG91ciBzdWJkaXJlY3RvcnkgKi8KCQkJaWYgKGNlX3N0YWdlKHApID09IHN0YWdlICYmICEocC0+Y2VfZmxhZ3MgJiBDRV9SRU1PVkUpKQoJCQkJLyoKCQkJCSAqIHAgaXMgYXQgdGhlIHNhbWUgc3RhZ2UgYXMgb3VyIGVudHJ5LCBhbmQKCQkJCSAqIGlzIGEgc3ViZGlyZWN0b3J5IG9mIHdoYXQgd2UgYXJlIGxvb2tpbmcKCQkJCSAqIGF0LCBzbyB3ZSBjYW5ub3QgaGF2ZSBjb25mbGljdHMgYXQgb3VyCgkJCQkgKiBsZXZlbCBvciBhbnl0aGluZyBzaG9ydGVyLgoJCQkJICovCgkJCQlyZXR1cm4gcmV0dmFsOwoJCQlwb3MrKzsKCQl9Cgl9CglyZXR1cm4gcmV0dmFsOwp9CgovKiBXZSBtYXkgYmUgaW4gYSBzaXR1YXRpb24gd2hlcmUgd2UgYWxyZWFkeSBoYXZlIHBhdGgvZmlsZSBhbmQgcGF0aAogKiBpcyBiZWluZyBhZGRlZCwgb3Igd2UgYWxyZWFkeSBoYXZlIHBhdGggYW5kIHBhdGgvZmlsZSBpcyBiZWluZwogKiBhZGRlZC4gIEVpdGhlciBvbmUgd291bGQgcmVzdWx0IGluIGEgbm9uc2Vuc2UgdHJlZSB0aGF0IGhhcyBwYXRoCiAqIHR3aWNlIHdoZW4gZ2l0LXdyaXRlLXRyZWUgdHJpZXMgdG8gd3JpdGUgaXQgb3V0LiAgUHJldmVudCBpdC4KICoKICogSWYgb2stdG8tcmVwbGFjZSBpcyBzcGVjaWZpZWQsIHdlIHJlbW92ZSB0aGUgY29uZmxpY3RpbmcgZW50cmllcwogKiBmcm9tIHRoZSBjYWNoZSBzbyB0aGUgY2FsbGVyIHNob3VsZCByZWNvbXB1dGUgdGhlIGluc2VydCBwb3NpdGlvbi4KICogV2hlbiB0aGlzIGhhcHBlbnMsIHdlIHJldHVybiBub24temVyby4KICovCnN0YXRpYyBpbnQgY2hlY2tfZmlsZV9kaXJlY3RvcnlfY29uZmxpY3Qoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsCgkJCQkJIGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCQkJIGludCBwb3MsIGludCBva190b19yZXBsYWNlKQp7CglpbnQgcmV0dmFsOwoKCS8qCgkgKiBXaGVuIGNlIGlzIGFuICJJIGFtIGdvaW5nIGF3YXkiIGVudHJ5LCB3ZSBhbGxvdyBpdCB0byBiZSBhZGRlZAoJICovCglpZiAoY2UtPmNlX2ZsYWdzICYgQ0VfUkVNT1ZFKQoJCXJldHVybiAwOwoKCS8qCgkgKiBXZSBjaGVjayBpZiB0aGUgcGF0aCBpcyBhIHN1Yi1wYXRoIG9mIGEgc3Vic2VxdWVudCBwYXRobmFtZQoJICogZmlyc3QsIHNpbmNlIHJlbW92aW5nIHRob3NlIHdpbGwgbm90IGNoYW5nZSB0aGUgcG9zaXRpb24KCSAqIGluIHRoZSBhcnJheS4KCSAqLwoJcmV0dmFsID0gaGFzX2ZpbGVfbmFtZShpc3RhdGUsIGNlLCBwb3MsIG9rX3RvX3JlcGxhY2UpOwoKCS8qCgkgKiBUaGVuIGNoZWNrIGlmIHRoZSBwYXRoIG1pZ2h0IGhhdmUgYSBjbGFzaGluZyBzdWItZGlyZWN0b3J5CgkgKiBiZWZvcmUgaXQuCgkgKi8KCXJldHVybiByZXR2YWwgKyBoYXNfZGlyX25hbWUoaXN0YXRlLCBjZSwgcG9zLCBva190b19yZXBsYWNlKTsKfQoKc3RhdGljIGludCBhZGRfaW5kZXhfZW50cnlfd2l0aF9jaGVjayhzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgaW50IG9wdGlvbikKewoJaW50IHBvczsKCWludCBva190b19hZGQgPSBvcHRpb24gJiBBRERfQ0FDSEVfT0tfVE9fQUREOwoJaW50IG9rX3RvX3JlcGxhY2UgPSBvcHRpb24gJiBBRERfQ0FDSEVfT0tfVE9fUkVQTEFDRTsKCWludCBza2lwX2RmX2NoZWNrID0gb3B0aW9uICYgQUREX0NBQ0hFX1NLSVBfREZDSEVDSzsKCWludCBuZXdfb25seSA9IG9wdGlvbiAmIEFERF9DQUNIRV9ORVdfT05MWTsKCgljYWNoZV90cmVlX2ludmFsaWRhdGVfcGF0aChpc3RhdGUtPmNhY2hlX3RyZWUsIGNlLT5uYW1lKTsKCXBvcyA9IGluZGV4X25hbWVfc3RhZ2VfcG9zKGlzdGF0ZSwgY2UtPm5hbWUsIGNlX25hbWVsZW4oY2UpLCBjZV9zdGFnZShjZSkpOwoKCS8qIGV4aXN0aW5nIG1hdGNoPyBKdXN0IHJlcGxhY2UgaXQuICovCglpZiAocG9zID49IDApIHsKCQlpZiAoIW5ld19vbmx5KQoJCQlyZXBsYWNlX2luZGV4X2VudHJ5KGlzdGF0ZSwgcG9zLCBjZSk7CgkJcmV0dXJuIDA7Cgl9Cglwb3MgPSAtcG9zLTE7CgoJLyoKCSAqIEluc2VydGluZyBhIG1lcmdlZCBlbnRyeSAoInN0YWdlIDAiKSBpbnRvIHRoZSBpbmRleAoJICogd2lsbCBhbHdheXMgcmVwbGFjZSBhbGwgbm9uLW1lcmdlZCBlbnRyaWVzLi4KCSAqLwoJaWYgKHBvcyA8IGlzdGF0ZS0+Y2FjaGVfbnIgJiYgY2Vfc3RhZ2UoY2UpID09IDApIHsKCQl3aGlsZSAoY2Vfc2FtZV9uYW1lKGlzdGF0ZS0+Y2FjaGVbcG9zXSwgY2UpKSB7CgkJCW9rX3RvX2FkZCA9IDE7CgkJCWlmICghcmVtb3ZlX2luZGV4X2VudHJ5X2F0KGlzdGF0ZSwgcG9zKSkKCQkJCWJyZWFrOwoJCX0KCX0KCglpZiAoIW9rX3RvX2FkZCkKCQlyZXR1cm4gLTE7CglpZiAoIXZlcmlmeV9wYXRoKGNlLT5uYW1lKSkKCQlyZXR1cm4gZXJyb3IoIkludmFsaWQgcGF0aCAnJXMnIiwgY2UtPm5hbWUpOwoKCWlmICghc2tpcF9kZl9jaGVjayAmJgoJICAgIGNoZWNrX2ZpbGVfZGlyZWN0b3J5X2NvbmZsaWN0KGlzdGF0ZSwgY2UsIHBvcywgb2tfdG9fcmVwbGFjZSkpIHsKCQlpZiAoIW9rX3RvX3JlcGxhY2UpCgkJCXJldHVybiBlcnJvcigiJyVzJyBhcHBlYXJzIGFzIGJvdGggYSBmaWxlIGFuZCBhcyBhIGRpcmVjdG9yeSIsCgkJCQkgICAgIGNlLT5uYW1lKTsKCQlwb3MgPSBpbmRleF9uYW1lX3N0YWdlX3Bvcyhpc3RhdGUsIGNlLT5uYW1lLCBjZV9uYW1lbGVuKGNlKSwgY2Vfc3RhZ2UoY2UpKTsKCQlwb3MgPSAtcG9zLTE7Cgl9CglyZXR1cm4gcG9zICsgMTsKfQoKaW50IGFkZF9pbmRleF9lbnRyeShzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgaW50IG9wdGlvbikKewoJaW50IHBvczsKCglpZiAob3B0aW9uICYgQUREX0NBQ0hFX0pVU1RfQVBQRU5EKQoJCXBvcyA9IGlzdGF0ZS0+Y2FjaGVfbnI7CgllbHNlIHsKCQlpbnQgcmV0OwoJCXJldCA9IGFkZF9pbmRleF9lbnRyeV93aXRoX2NoZWNrKGlzdGF0ZSwgY2UsIG9wdGlvbik7CgkJaWYgKHJldCA8PSAwKQoJCQlyZXR1cm4gcmV0OwoJCXBvcyA9IHJldCAtIDE7Cgl9CgoJLyogTWFrZSBzdXJlIHRoZSBhcnJheSBpcyBiaWcgZW5vdWdoIC4uICovCglpZiAoaXN0YXRlLT5jYWNoZV9uciA9PSBpc3RhdGUtPmNhY2hlX2FsbG9jKSB7CgkJaXN0YXRlLT5jYWNoZV9hbGxvYyA9IGFsbG9jX25yKGlzdGF0ZS0+Y2FjaGVfYWxsb2MpOwoJCWlzdGF0ZS0+Y2FjaGUgPSB4cmVhbGxvYyhpc3RhdGUtPmNhY2hlLAoJCQkJCWlzdGF0ZS0+Y2FjaGVfYWxsb2MgKiBzaXplb2YoKmlzdGF0ZS0+Y2FjaGUpKTsKCX0KCgkvKiBBZGQgaXQgaW4uLiAqLwoJaXN0YXRlLT5jYWNoZV9ucisrOwoJaWYgKGlzdGF0ZS0+Y2FjaGVfbnIgPiBwb3MgKyAxKQoJCW1lbW1vdmUoaXN0YXRlLT5jYWNoZSArIHBvcyArIDEsCgkJCWlzdGF0ZS0+Y2FjaGUgKyBwb3MsCgkJCShpc3RhdGUtPmNhY2hlX25yIC0gcG9zIC0gMSkgKiBzaXplb2YoY2UpKTsKCXNldF9pbmRleF9lbnRyeShpc3RhdGUsIHBvcywgY2UpOwoJaXN0YXRlLT5jYWNoZV9jaGFuZ2VkID0gMTsKCXJldHVybiAwOwp9CgovKgogKiAicmVmcmVzaCIgZG9lcyBub3QgY2FsY3VsYXRlIGEgbmV3IHNoYTEgZmlsZSBvciBicmluZyB0aGUKICogY2FjaGUgdXAtdG8tZGF0ZSBmb3IgbW9kZS9jb250ZW50IGNoYW5nZXMuIEJ1dCB3aGF0IGl0CiAqIF9kb2VzXyBkbyBpcyB0byAicmUtbWF0Y2giIHRoZSBzdGF0IGluZm9ybWF0aW9uIG9mIGEgZmlsZQogKiB3aXRoIHRoZSBjYWNoZSwgc28gdGhhdCB5b3UgY2FuIHJlZnJlc2ggdGhlIGNhY2hlIGZvciBhCiAqIGZpbGUgdGhhdCBoYXNuJ3QgYmVlbiBjaGFuZ2VkIGJ1dCB3aGVyZSB0aGUgc3RhdCBlbnRyeSBpcwogKiBvdXQgb2YgZGF0ZS4KICoKICogRm9yIGV4YW1wbGUsIHlvdSdkIHdhbnQgdG8gZG8gdGhpcyBhZnRlciBkb2luZyBhICJnaXQtcmVhZC10cmVlIiwKICogdG8gbGluayB1cCB0aGUgc3RhdCBjYWNoZSBkZXRhaWxzIHdpdGggdGhlIHByb3BlciBmaWxlcy4KICovCnN0YXRpYyBzdHJ1Y3QgY2FjaGVfZW50cnkgKnJlZnJlc2hfY2FjaGVfZW50KHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLAoJCQkJCSAgICAgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwKCQkJCQkgICAgIHVuc2lnbmVkIGludCBvcHRpb25zLCBpbnQgKmVyciwKCQkJCQkgICAgIGludCAqY2hhbmdlZF9yZXQpCnsKCXN0cnVjdCBzdGF0IHN0OwoJc3RydWN0IGNhY2hlX2VudHJ5ICp1cGRhdGVkOwoJaW50IGNoYW5nZWQsIHNpemU7CglpbnQgaWdub3JlX3ZhbGlkID0gb3B0aW9ucyAmIENFX01BVENIX0lHTk9SRV9WQUxJRDsKCWludCBpZ25vcmVfc2tpcF93b3JrdHJlZSA9IG9wdGlvbnMgJiBDRV9NQVRDSF9JR05PUkVfU0tJUF9XT1JLVFJFRTsKCglpZiAoY2VfdXB0b2RhdGUoY2UpKQoJCXJldHVybiBjZTsKCgkvKgoJICogQ0VfVkFMSUQgb3IgQ0VfU0tJUF9XT1JLVFJFRSBtZWFucyB0aGUgdXNlciBwcm9taXNlZCB1cwoJICogdGhhdCB0aGUgY2hhbmdlIHRvIHRoZSB3b3JrIHRyZWUgZG9lcyBub3QgbWF0dGVyIGFuZCB0b2xkCgkgKiB1cyBub3QgdG8gd29ycnkuCgkgKi8KCWlmICghaWdub3JlX3NraXBfd29ya3RyZWUgJiYgY2Vfc2tpcF93b3JrdHJlZShjZSkpIHsKCQljZV9tYXJrX3VwdG9kYXRlKGNlKTsKCQlyZXR1cm4gY2U7Cgl9CglpZiAoIWlnbm9yZV92YWxpZCAmJiAoY2UtPmNlX2ZsYWdzICYgQ0VfVkFMSUQpKSB7CgkJY2VfbWFya191cHRvZGF0ZShjZSk7CgkJcmV0dXJuIGNlOwoJfQoKCWlmIChsc3RhdChjZS0+bmFtZSwgJnN0KSA8IDApIHsKCQlpZiAoZXJyKQoJCQkqZXJyID0gZXJybm87CgkJcmV0dXJuIE5VTEw7Cgl9CgoJY2hhbmdlZCA9IGllX21hdGNoX3N0YXQoaXN0YXRlLCBjZSwgJnN0LCBvcHRpb25zKTsKCWlmIChjaGFuZ2VkX3JldCkKCQkqY2hhbmdlZF9yZXQgPSBjaGFuZ2VkOwoJaWYgKCFjaGFuZ2VkKSB7CgkJLyoKCQkgKiBUaGUgcGF0aCBpcyB1bmNoYW5nZWQuICBJZiB3ZSB3ZXJlIHRvbGQgdG8gaWdub3JlCgkJICogdmFsaWQgYml0LCB0aGVuIHdlIGRpZCB0aGUgYWN0dWFsIHN0YXQgY2hlY2sgYW5kCgkJICogZm91bmQgdGhhdCB0aGUgZW50cnkgaXMgdW5tb2RpZmllZC4gIElmIHRoZSBlbnRyeQoJCSAqIGlzIG5vdCBtYXJrZWQgVkFMSUQsIHRoaXMgaXMgdGhlIHBsYWNlIHRvIG1hcmsgaXQKCQkgKiB2YWxpZCBhZ2FpbiwgdW5kZXIgImFzc3VtZSB1bmNoYW5nZWQiIG1vZGUuCgkJICovCgkJaWYgKGlnbm9yZV92YWxpZCAmJiBhc3N1bWVfdW5jaGFuZ2VkICYmCgkJICAgICEoY2UtPmNlX2ZsYWdzICYgQ0VfVkFMSUQpKQoJCQk7IC8qIG1hcmsgdGhpcyBvbmUgVkFMSUQgYWdhaW4gKi8KCQllbHNlIHsKCQkJLyoKCQkJICogV2UgZG8gbm90IG1hcmsgdGhlIGluZGV4IGl0c2VsZiAibW9kaWZpZWQiCgkJCSAqIGJlY2F1c2UgQ0VfVVBUT0RBVEUgZmxhZyBpcyBpbi1jb3JlIG9ubHk7CgkJCSAqIHdlIGFyZSBub3QgZ29pbmcgdG8gd3JpdGUgdGhpcyBjaGFuZ2Ugb3V0LgoJCQkgKi8KCQkJaWYgKCFTX0lTR0lUTElOSyhjZS0+Y2VfbW9kZSkpCgkJCQljZV9tYXJrX3VwdG9kYXRlKGNlKTsKCQkJcmV0dXJuIGNlOwoJCX0KCX0KCglpZiAoaWVfbW9kaWZpZWQoaXN0YXRlLCBjZSwgJnN0LCBvcHRpb25zKSkgewoJCWlmIChlcnIpCgkJCSplcnIgPSBFSU5WQUw7CgkJcmV0dXJuIE5VTEw7Cgl9CgoJc2l6ZSA9IGNlX3NpemUoY2UpOwoJdXBkYXRlZCA9IHhtYWxsb2Moc2l6ZSk7CgltZW1jcHkodXBkYXRlZCwgY2UsIHNpemUpOwoJZmlsbF9zdGF0X2NhY2hlX2luZm8odXBkYXRlZCwgJnN0KTsKCS8qCgkgKiBJZiBpZ25vcmVfdmFsaWQgaXMgbm90IHNldCwgd2Ugc2hvdWxkIGxlYXZlIENFX1ZBTElEIGJpdAoJICogYWxvbmUuICBPdGhlcndpc2UsIHBhdGhzIG1hcmtlZCB3aXRoIC0tbm8tYXNzdW1lLXVuY2hhbmdlZAoJICogKGkuZS4gdGhpbmdzIHRvIGJlIGVkaXRlZCkgd2lsbCByZWFjcXVpcmUgQ0VfVkFMSUQgYml0CgkgKiBhdXRvbWF0aWNhbGx5LCB3aGljaCBpcyBub3QgcmVhbGx5IHdoYXQgd2Ugd2FudC4KCSAqLwoJaWYgKCFpZ25vcmVfdmFsaWQgJiYgYXNzdW1lX3VuY2hhbmdlZCAmJgoJICAgICEoY2UtPmNlX2ZsYWdzICYgQ0VfVkFMSUQpKQoJCXVwZGF0ZWQtPmNlX2ZsYWdzICY9IH5DRV9WQUxJRDsKCglyZXR1cm4gdXBkYXRlZDsKfQoKc3RhdGljIHZvaWQgc2hvd19maWxlKGNvbnN0IGNoYXIgKiBmbXQsIGNvbnN0IGNoYXIgKiBuYW1lLCBpbnQgaW5fcG9yY2VsYWluLAoJCSAgICAgIGludCAqIGZpcnN0LCBjb25zdCBjaGFyICpoZWFkZXJfbXNnKQp7CglpZiAoaW5fcG9yY2VsYWluICYmICpmaXJzdCAmJiBoZWFkZXJfbXNnKSB7CgkJcHJpbnRmKCIlc1xuIiwgaGVhZGVyX21zZyk7CgkJKmZpcnN0ID0gMDsKCX0KCXByaW50ZihmbXQsIG5hbWUpOwp9CgppbnQgcmVmcmVzaF9pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgdW5zaWduZWQgaW50IGZsYWdzLAoJCSAgY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwYXRoc3BlYywKCQkgIGNoYXIgKnNlZW4sIGNvbnN0IGNoYXIgKmhlYWRlcl9tc2cpCnsKCWludCBpOwoJaW50IGhhc19lcnJvcnMgPSAwOwoJaW50IHJlYWxseSA9IChmbGFncyAmIFJFRlJFU0hfUkVBTExZKSAhPSAwOwoJaW50IGFsbG93X3VubWVyZ2VkID0gKGZsYWdzICYgUkVGUkVTSF9VTk1FUkdFRCkgIT0gMDsKCWludCBxdWlldCA9IChmbGFncyAmIFJFRlJFU0hfUVVJRVQpICE9IDA7CglpbnQgbm90X25ldyA9IChmbGFncyAmIFJFRlJFU0hfSUdOT1JFX01JU1NJTkcpICE9IDA7CglpbnQgaWdub3JlX3N1Ym1vZHVsZXMgPSAoZmxhZ3MgJiBSRUZSRVNIX0lHTk9SRV9TVUJNT0RVTEVTKSAhPSAwOwoJaW50IGZpcnN0ID0gMTsKCWludCBpbl9wb3JjZWxhaW4gPSAoZmxhZ3MgJiBSRUZSRVNIX0lOX1BPUkNFTEFJTik7Cgl1bnNpZ25lZCBpbnQgb3B0aW9ucyA9IHJlYWxseSA/IENFX01BVENIX0lHTk9SRV9WQUxJRCA6IDA7Cgljb25zdCBjaGFyICptb2RpZmllZF9mbXQ7Cgljb25zdCBjaGFyICpkZWxldGVkX2ZtdDsKCWNvbnN0IGNoYXIgKnR5cGVjaGFuZ2VfZm10OwoJY29uc3QgY2hhciAqYWRkZWRfZm10OwoJY29uc3QgY2hhciAqdW5tZXJnZWRfZm10OwoKCW1vZGlmaWVkX2ZtdCA9IChpbl9wb3JjZWxhaW4gPyAiTVx0JXNcbiIgOiAiJXM6IG5lZWRzIHVwZGF0ZVxuIik7CglkZWxldGVkX2ZtdCA9IChpbl9wb3JjZWxhaW4gPyAiRFx0JXNcbiIgOiAiJXM6IG5lZWRzIHVwZGF0ZVxuIik7Cgl0eXBlY2hhbmdlX2ZtdCA9IChpbl9wb3JjZWxhaW4gPyAiVFx0JXNcbiIgOiAiJXMgbmVlZHMgdXBkYXRlXG4iKTsKCWFkZGVkX2ZtdCA9IChpbl9wb3JjZWxhaW4gPyAiQVx0JXNcbiIgOiAiJXMgbmVlZHMgdXBkYXRlXG4iKTsKCXVubWVyZ2VkX2ZtdCA9IChpbl9wb3JjZWxhaW4gPyAiVVx0JXNcbiIgOiAiJXM6IG5lZWRzIG1lcmdlXG4iKTsKCWZvciAoaSA9IDA7IGkgPCBpc3RhdGUtPmNhY2hlX25yOyBpKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCAqbmV3OwoJCWludCBjYWNoZV9lcnJubyA9IDA7CgkJaW50IGNoYW5nZWQgPSAwOwoJCWludCBmaWx0ZXJlZCA9IDA7CgoJCWNlID0gaXN0YXRlLT5jYWNoZVtpXTsKCQlpZiAoaWdub3JlX3N1Ym1vZHVsZXMgJiYgU19JU0dJVExJTksoY2UtPmNlX21vZGUpKQoJCQljb250aW51ZTsKCgkJaWYgKHBhdGhzcGVjICYmCgkJICAgICFtYXRjaF9wYXRoc3BlY19kZXB0aChwYXRoc3BlYywgY2UtPm5hbWUsIGNlX25hbWVsZW4oY2UpLCAwLCBzZWVuKSkKCQkJZmlsdGVyZWQgPSAxOwoKCQlpZiAoY2Vfc3RhZ2UoY2UpKSB7CgkJCXdoaWxlICgoaSA8IGlzdGF0ZS0+Y2FjaGVfbnIpICYmCgkJCSAgICAgICAhIHN0cmNtcChpc3RhdGUtPmNhY2hlW2ldLT5uYW1lLCBjZS0+bmFtZSkpCgkJCQlpKys7CgkJCWktLTsKCQkJaWYgKGFsbG93X3VubWVyZ2VkKQoJCQkJY29udGludWU7CgkJCWlmICghZmlsdGVyZWQpCgkJCQlzaG93X2ZpbGUodW5tZXJnZWRfZm10LCBjZS0+bmFtZSwgaW5fcG9yY2VsYWluLAoJCQkJCSAgJmZpcnN0LCBoZWFkZXJfbXNnKTsKCQkJaGFzX2Vycm9ycyA9IDE7CgkJCWNvbnRpbnVlOwoJCX0KCgkJaWYgKGZpbHRlcmVkKQoJCQljb250aW51ZTsKCgkJbmV3ID0gcmVmcmVzaF9jYWNoZV9lbnQoaXN0YXRlLCBjZSwgb3B0aW9ucywgJmNhY2hlX2Vycm5vLCAmY2hhbmdlZCk7CgkJaWYgKG5ldyA9PSBjZSkKCQkJY29udGludWU7CgkJaWYgKCFuZXcpIHsKCQkJY29uc3QgY2hhciAqZm10OwoKCQkJaWYgKG5vdF9uZXcgJiYgY2FjaGVfZXJybm8gPT0gRU5PRU5UKQoJCQkJY29udGludWU7CgkJCWlmIChyZWFsbHkgJiYgY2FjaGVfZXJybm8gPT0gRUlOVkFMKSB7CgkJCQkvKiBJZiB3ZSBhcmUgZG9pbmcgLS1yZWFsbHktcmVmcmVzaCB0aGF0CgkJCQkgKiBtZWFucyB0aGUgaW5kZXggaXMgbm90IHZhbGlkIGFueW1vcmUuCgkJCQkgKi8KCQkJCWNlLT5jZV9mbGFncyAmPSB+Q0VfVkFMSUQ7CgkJCQlpc3RhdGUtPmNhY2hlX2NoYW5nZWQgPSAxOwoJCQl9CgkJCWlmIChxdWlldCkKCQkJCWNvbnRpbnVlOwoKCQkJaWYgKGNhY2hlX2Vycm5vID09IEVOT0VOVCkKCQkJCWZtdCA9IGRlbGV0ZWRfZm10OwoJCQllbHNlIGlmIChjZS0+Y2VfZmxhZ3MgJiBDRV9JTlRFTlRfVE9fQUREKQoJCQkJZm10ID0gYWRkZWRfZm10OyAvKiBtdXN0IGJlIGJlZm9yZSBvdGhlciBjaGVja3MgKi8KCQkJZWxzZSBpZiAoY2hhbmdlZCAmIFRZUEVfQ0hBTkdFRCkKCQkJCWZtdCA9IHR5cGVjaGFuZ2VfZm10OwoJCQllbHNlCgkJCQlmbXQgPSBtb2RpZmllZF9mbXQ7CgkJCXNob3dfZmlsZShmbXQsCgkJCQkgIGNlLT5uYW1lLCBpbl9wb3JjZWxhaW4sICZmaXJzdCwgaGVhZGVyX21zZyk7CgkJCWhhc19lcnJvcnMgPSAxOwoJCQljb250aW51ZTsKCQl9CgoJCXJlcGxhY2VfaW5kZXhfZW50cnkoaXN0YXRlLCBpLCBuZXcpOwoJfQoJcmV0dXJuIGhhc19lcnJvcnM7Cn0KCnN0YXRpYyBzdHJ1Y3QgY2FjaGVfZW50cnkgKnJlZnJlc2hfY2FjaGVfZW50cnkoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgaW50IHJlYWxseSkKewoJcmV0dXJuIHJlZnJlc2hfY2FjaGVfZW50KCZ0aGVfaW5kZXgsIGNlLCByZWFsbHksIE5VTEwsIE5VTEwpOwp9CgoKLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqCiAqIEluZGV4IEZpbGUgSS9PCiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8KCiNkZWZpbmUgSU5ERVhfRk9STUFUX0RFRkFVTFQgMwoKLyoKICogZGV2L2luby91aWQvZ2lkL3NpemUgYXJlIGFsc28ganVzdCB0cmFja2VkIHRvIHRoZSBsb3cgMzIgYml0cwogKiBBZ2FpbiAtIHRoaXMgaXMganVzdCBhICh2ZXJ5IHN0cm9uZyBpbiBwcmFjdGljZSkgaGV1cmlzdGljIHRoYXQKICogdGhlIGlub2RlIGhhc24ndCBjaGFuZ2VkLgogKgogKiBXZSBzYXZlIHRoZSBmaWVsZHMgaW4gYmlnLWVuZGlhbiBvcmRlciB0byBhbGxvdyB1c2luZyB0aGUKICogaW5kZXggZmlsZSBvdmVyIE5GUyB0cmFuc3BhcmVudGx5LgogKi8Kc3RydWN0IG9uZGlza19jYWNoZV9lbnRyeSB7CglzdHJ1Y3QgY2FjaGVfdGltZSBjdGltZTsKCXN0cnVjdCBjYWNoZV90aW1lIG10aW1lOwoJdWludDMyX3QgZGV2OwoJdWludDMyX3QgaW5vOwoJdWludDMyX3QgbW9kZTsKCXVpbnQzMl90IHVpZDsKCXVpbnQzMl90IGdpZDsKCXVpbnQzMl90IHNpemU7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJdWludDE2X3QgZmxhZ3M7CgljaGFyIG5hbWVbRkxFWF9BUlJBWV07IC8qIG1vcmUgKi8KfTsKCi8qCiAqIFRoaXMgc3RydWN0IGlzIHVzZWQgd2hlbiBDRV9FWFRFTkRFRCBiaXQgaXMgMQogKiBUaGUgc3RydWN0IG11c3QgbWF0Y2ggb25kaXNrX2NhY2hlX2VudHJ5IGV4YWN0bHkgZnJvbQogKiBjdGltZSB0aWxsIGZsYWdzCiAqLwpzdHJ1Y3Qgb25kaXNrX2NhY2hlX2VudHJ5X2V4dGVuZGVkIHsKCXN0cnVjdCBjYWNoZV90aW1lIGN0aW1lOwoJc3RydWN0IGNhY2hlX3RpbWUgbXRpbWU7Cgl1aW50MzJfdCBkZXY7Cgl1aW50MzJfdCBpbm87Cgl1aW50MzJfdCBtb2RlOwoJdWludDMyX3QgdWlkOwoJdWludDMyX3QgZ2lkOwoJdWludDMyX3Qgc2l6ZTsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07Cgl1aW50MTZfdCBmbGFnczsKCXVpbnQxNl90IGZsYWdzMjsKCWNoYXIgbmFtZVtGTEVYX0FSUkFZXTsgLyogbW9yZSAqLwp9OwoKLyogVGhlc2UgYXJlIG9ubHkgdXNlZCBmb3IgdjMgb3IgbG93ZXIgKi8KI2RlZmluZSBhbGlnbl9mbGV4X25hbWUoU1RSVUNULGxlbikgKChvZmZzZXRvZihzdHJ1Y3QgU1RSVUNULG5hbWUpICsgKGxlbikgKyA4KSAmIH43KQojZGVmaW5lIG9uZGlza19jYWNoZV9lbnRyeV9zaXplKGxlbikgYWxpZ25fZmxleF9uYW1lKG9uZGlza19jYWNoZV9lbnRyeSxsZW4pCiNkZWZpbmUgb25kaXNrX2NhY2hlX2VudHJ5X2V4dGVuZGVkX3NpemUobGVuKSBhbGlnbl9mbGV4X25hbWUob25kaXNrX2NhY2hlX2VudHJ5X2V4dGVuZGVkLGxlbikKI2RlZmluZSBvbmRpc2tfY2Vfc2l6ZShjZSkgKCgoY2UpLT5jZV9mbGFncyAmIENFX0VYVEVOREVEKSA/IFwKCQkJICAgIG9uZGlza19jYWNoZV9lbnRyeV9leHRlbmRlZF9zaXplKGNlX25hbWVsZW4oY2UpKSA6IFwKCQkJICAgIG9uZGlza19jYWNoZV9lbnRyeV9zaXplKGNlX25hbWVsZW4oY2UpKSkKCnN0YXRpYyBpbnQgdmVyaWZ5X2hkcihzdHJ1Y3QgY2FjaGVfaGVhZGVyICpoZHIsIHVuc2lnbmVkIGxvbmcgc2l6ZSkKewoJZ2l0X1NIQV9DVFggYzsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CglpbnQgaGRyX3ZlcnNpb247CgoJaWYgKGhkci0+aGRyX3NpZ25hdHVyZSAhPSBodG9ubChDQUNIRV9TSUdOQVRVUkUpKQoJCXJldHVybiBlcnJvcigiYmFkIHNpZ25hdHVyZSIpOwoJaGRyX3ZlcnNpb24gPSBudG9obChoZHItPmhkcl92ZXJzaW9uKTsKCWlmIChoZHJfdmVyc2lvbiA8IElOREVYX0ZPUk1BVF9MQiB8fCBJTkRFWF9GT1JNQVRfVUIgPCBoZHJfdmVyc2lvbikKCQlyZXR1cm4gZXJyb3IoImJhZCBpbmRleCB2ZXJzaW9uICVkIiwgaGRyX3ZlcnNpb24pOwoJZ2l0X1NIQTFfSW5pdCgmYyk7CglnaXRfU0hBMV9VcGRhdGUoJmMsIGhkciwgc2l6ZSAtIDIwKTsKCWdpdF9TSEExX0ZpbmFsKHNoYTEsICZjKTsKCWlmIChoYXNoY21wKHNoYTEsICh1bnNpZ25lZCBjaGFyICopaGRyICsgc2l6ZSAtIDIwKSkKCQlyZXR1cm4gZXJyb3IoImJhZCBpbmRleCBmaWxlIHNoYTEgc2lnbmF0dXJlIik7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCByZWFkX2luZGV4X2V4dGVuc2lvbihzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwKCQkJCWNvbnN0IGNoYXIgKmV4dCwgdm9pZCAqZGF0YSwgdW5zaWduZWQgbG9uZyBzeikKewoJc3dpdGNoIChDQUNIRV9FWFQoZXh0KSkgewoJY2FzZSBDQUNIRV9FWFRfVFJFRToKCQlpc3RhdGUtPmNhY2hlX3RyZWUgPSBjYWNoZV90cmVlX3JlYWQoZGF0YSwgc3opOwoJCWJyZWFrOwoJY2FzZSBDQUNIRV9FWFRfUkVTT0xWRV9VTkRPOgoJCWlzdGF0ZS0+cmVzb2x2ZV91bmRvID0gcmVzb2x2ZV91bmRvX3JlYWQoZGF0YSwgc3opOwoJCWJyZWFrOwoJZGVmYXVsdDoKCQlpZiAoKmV4dCA8ICdBJyB8fCAnWicgPCAqZXh0KQoJCQlyZXR1cm4gZXJyb3IoImluZGV4IHVzZXMgJS40cyBleHRlbnNpb24sIHdoaWNoIHdlIGRvIG5vdCB1bmRlcnN0YW5kIiwKCQkJCSAgICAgZXh0KTsKCQlmcHJpbnRmKHN0ZGVyciwgImlnbm9yaW5nICUuNHMgZXh0ZW5zaW9uXG4iLCBleHQpOwoJCWJyZWFrOwoJfQoJcmV0dXJuIDA7Cn0KCmludCByZWFkX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlKQp7CglyZXR1cm4gcmVhZF9pbmRleF9mcm9tKGlzdGF0ZSwgZ2V0X2luZGV4X2ZpbGUoKSk7Cn0KCiNpZm5kZWYgTkVFRFNfQUxJR05FRF9BQ0NFU1MKI2RlZmluZSBudG9oX3ModmFyKSBudG9ocyh2YXIpCiNkZWZpbmUgbnRvaF9sKHZhcikgbnRvaGwodmFyKQojZWxzZQpzdGF0aWMgaW5saW5lIHVpbnQxNl90IG50b2hfc19mb3JjZV9hbGlnbih2b2lkICpwKQp7Cgl1aW50MTZfdCB4OwoJbWVtY3B5KCZ4LCBwLCBzaXplb2YoeCkpOwoJcmV0dXJuIG50b2hzKHgpOwp9CnN0YXRpYyBpbmxpbmUgdWludDMyX3QgbnRvaF9sX2ZvcmNlX2FsaWduKHZvaWQgKnApCnsKCXVpbnQzMl90IHg7CgltZW1jcHkoJngsIHAsIHNpemVvZih4KSk7CglyZXR1cm4gbnRvaGwoeCk7Cn0KI2RlZmluZSBudG9oX3ModmFyKSBudG9oX3NfZm9yY2VfYWxpZ24oJih2YXIpKQojZGVmaW5lIG50b2hfbCh2YXIpIG50b2hfbF9mb3JjZV9hbGlnbigmKHZhcikpCiNlbmRpZgoKc3RhdGljIHN0cnVjdCBjYWNoZV9lbnRyeSAqY2FjaGVfZW50cnlfZnJvbV9vbmRpc2soc3RydWN0IG9uZGlza19jYWNoZV9lbnRyeSAqb25kaXNrLAoJCQkJCQkgICB1bnNpZ25lZCBpbnQgZmxhZ3MsCgkJCQkJCSAgIGNvbnN0IGNoYXIgKm5hbWUsCgkJCQkJCSAgIHNpemVfdCBsZW4pCnsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSB4bWFsbG9jKGNhY2hlX2VudHJ5X3NpemUobGVuKSk7CgoJY2UtPmNlX3N0YXRfZGF0YS5zZF9jdGltZS5zZWMgPSBudG9oX2wob25kaXNrLT5jdGltZS5zZWMpOwoJY2UtPmNlX3N0YXRfZGF0YS5zZF9tdGltZS5zZWMgPSBudG9oX2wob25kaXNrLT5tdGltZS5zZWMpOwoJY2UtPmNlX3N0YXRfZGF0YS5zZF9jdGltZS5uc2VjID0gbnRvaF9sKG9uZGlzay0+Y3RpbWUubnNlYyk7CgljZS0+Y2Vfc3RhdF9kYXRhLnNkX210aW1lLm5zZWMgPSBudG9oX2wob25kaXNrLT5tdGltZS5uc2VjKTsKCWNlLT5jZV9zdGF0X2RhdGEuc2RfZGV2ICAgPSBudG9oX2wob25kaXNrLT5kZXYpOwoJY2UtPmNlX3N0YXRfZGF0YS5zZF9pbm8gICA9IG50b2hfbChvbmRpc2stPmlubyk7CgljZS0+Y2VfbW9kZSAgPSBudG9oX2wob25kaXNrLT5tb2RlKTsKCWNlLT5jZV9zdGF0X2RhdGEuc2RfdWlkICAgPSBudG9oX2wob25kaXNrLT51aWQpOwoJY2UtPmNlX3N0YXRfZGF0YS5zZF9naWQgICA9IG50b2hfbChvbmRpc2stPmdpZCk7CgljZS0+Y2Vfc3RhdF9kYXRhLnNkX3NpemUgID0gbnRvaF9sKG9uZGlzay0+c2l6ZSk7CgljZS0+Y2VfZmxhZ3MgPSBmbGFncyAmIH5DRV9OQU1FTUFTSzsKCWNlLT5jZV9uYW1lbGVuID0gbGVuOwoJaGFzaGNweShjZS0+c2hhMSwgb25kaXNrLT5zaGExKTsKCW1lbWNweShjZS0+bmFtZSwgbmFtZSwgbGVuKTsKCWNlLT5uYW1lW2xlbl0gPSAnXDAnOwoJcmV0dXJuIGNlOwp9CgovKgogKiBBZGphY2VudCBjYWNoZSBlbnRyaWVzIHRlbmQgdG8gc2hhcmUgdGhlIGxlYWRpbmcgcGF0aHMsIHNvIGl0IG1ha2VzCiAqIHNlbnNlIHRvIG9ubHkgc3RvcmUgdGhlIGRpZmZlcmVuY2VzIGluIGxhdGVyIGVudHJpZXMuICBJbiB0aGUgdjQKICogb24tZGlzayBmb3JtYXQgb2YgdGhlIGluZGV4LCBlYWNoIG9uLWRpc2sgY2FjaGUgZW50cnkgc3RvcmVzIHRoZQogKiBudW1iZXIgb2YgYnl0ZXMgdG8gYmUgc3RyaXBwZWQgZnJvbSB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyBuYW1lLAogKiBhbmQgdGhlIGJ5dGVzIHRvIGFwcGVuZCB0byB0aGUgcmVzdWx0LCB0byBjb21lIHVwIHdpdGggaXRzIG5hbWUuCiAqLwpzdGF0aWMgdW5zaWduZWQgbG9uZyBleHBhbmRfbmFtZV9maWVsZChzdHJ1Y3Qgc3RyYnVmICpuYW1lLCBjb25zdCBjaGFyICpjcF8pCnsKCWNvbnN0IHVuc2lnbmVkIGNoYXIgKmVwLCAqY3AgPSAoY29uc3QgdW5zaWduZWQgY2hhciAqKWNwXzsKCXNpemVfdCBsZW4gPSBkZWNvZGVfdmFyaW50KCZjcCk7CgoJaWYgKG5hbWUtPmxlbiA8IGxlbikKCQlkaWUoIm1hbGZvcm1lZCBuYW1lIGZpZWxkIGluIHRoZSBpbmRleCIpOwoJc3RyYnVmX3JlbW92ZShuYW1lLCBuYW1lLT5sZW4gLSBsZW4sIGxlbik7Cglmb3IgKGVwID0gY3A7ICplcDsgZXArKykKCQk7IC8qIGZpbmQgdGhlIGVuZCAqLwoJc3RyYnVmX2FkZChuYW1lLCBjcCwgZXAgLSBjcCk7CglyZXR1cm4gKGNvbnN0IGNoYXIgKillcCArIDEgLSBjcF87Cn0KCnN0YXRpYyBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNyZWF0ZV9mcm9tX2Rpc2soc3RydWN0IG9uZGlza19jYWNoZV9lbnRyeSAqb25kaXNrLAoJCQkJCSAgICB1bnNpZ25lZCBsb25nICplbnRfc2l6ZSwKCQkJCQkgICAgc3RydWN0IHN0cmJ1ZiAqcHJldmlvdXNfbmFtZSkKewoJc3RydWN0IGNhY2hlX2VudHJ5ICpjZTsKCXNpemVfdCBsZW47Cgljb25zdCBjaGFyICpuYW1lOwoJdW5zaWduZWQgaW50IGZsYWdzOwoKCS8qIE9uLWRpc2sgZmxhZ3MgYXJlIGp1c3QgMTYgYml0cyAqLwoJZmxhZ3MgPSBudG9oX3Mob25kaXNrLT5mbGFncyk7CglsZW4gPSBmbGFncyAmIENFX05BTUVNQVNLOwoKCWlmIChmbGFncyAmIENFX0VYVEVOREVEKSB7CgkJc3RydWN0IG9uZGlza19jYWNoZV9lbnRyeV9leHRlbmRlZCAqb25kaXNrMjsKCQlpbnQgZXh0ZW5kZWRfZmxhZ3M7CgkJb25kaXNrMiA9IChzdHJ1Y3Qgb25kaXNrX2NhY2hlX2VudHJ5X2V4dGVuZGVkICopb25kaXNrOwoJCWV4dGVuZGVkX2ZsYWdzID0gbnRvaF9zKG9uZGlzazItPmZsYWdzMikgPDwgMTY7CgkJLyogV2UgZG8gbm90IHlldCB1bmRlcnN0YW5kIGFueSBiaXQgb3V0IG9mIENFX0VYVEVOREVEX0ZMQUdTICovCgkJaWYgKGV4dGVuZGVkX2ZsYWdzICYgfkNFX0VYVEVOREVEX0ZMQUdTKQoJCQlkaWUoIlVua25vd24gaW5kZXggZW50cnkgZm9ybWF0ICUwOHgiLCBleHRlbmRlZF9mbGFncyk7CgkJZmxhZ3MgfD0gZXh0ZW5kZWRfZmxhZ3M7CgkJbmFtZSA9IG9uZGlzazItPm5hbWU7Cgl9CgllbHNlCgkJbmFtZSA9IG9uZGlzay0+bmFtZTsKCglpZiAoIXByZXZpb3VzX25hbWUpIHsKCQkvKiB2MyBhbmQgZWFybGllciAqLwoJCWlmIChsZW4gPT0gQ0VfTkFNRU1BU0spCgkJCWxlbiA9IHN0cmxlbihuYW1lKTsKCQljZSA9IGNhY2hlX2VudHJ5X2Zyb21fb25kaXNrKG9uZGlzaywgZmxhZ3MsIG5hbWUsIGxlbik7CgoJCSplbnRfc2l6ZSA9IG9uZGlza19jZV9zaXplKGNlKTsKCX0gZWxzZSB7CgkJdW5zaWduZWQgbG9uZyBjb25zdW1lZDsKCQljb25zdW1lZCA9IGV4cGFuZF9uYW1lX2ZpZWxkKHByZXZpb3VzX25hbWUsIG5hbWUpOwoJCWNlID0gY2FjaGVfZW50cnlfZnJvbV9vbmRpc2sob25kaXNrLCBmbGFncywKCQkJCQkgICAgIHByZXZpb3VzX25hbWUtPmJ1ZiwKCQkJCQkgICAgIHByZXZpb3VzX25hbWUtPmxlbik7CgoJCSplbnRfc2l6ZSA9IChuYW1lIC0gKChjaGFyICopb25kaXNrKSkgKyBjb25zdW1lZDsKCX0KCXJldHVybiBjZTsKfQoKLyogcmVtZW1iZXIgdG8gZGlzY2FyZF9jYWNoZSgpIGJlZm9yZSByZWFkaW5nIGEgZGlmZmVyZW50IGNhY2hlISAqLwppbnQgcmVhZF9pbmRleF9mcm9tKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBjb25zdCBjaGFyICpwYXRoKQp7CglpbnQgZmQsIGk7CglzdHJ1Y3Qgc3RhdCBzdDsKCXVuc2lnbmVkIGxvbmcgc3JjX29mZnNldDsKCXN0cnVjdCBjYWNoZV9oZWFkZXIgKmhkcjsKCXZvaWQgKm1tYXA7CglzaXplX3QgbW1hcF9zaXplOwoJc3RydWN0IHN0cmJ1ZiBwcmV2aW91c19uYW1lX2J1ZiA9IFNUUkJVRl9JTklULCAqcHJldmlvdXNfbmFtZTsKCglpZiAoaXN0YXRlLT5pbml0aWFsaXplZCkKCQlyZXR1cm4gaXN0YXRlLT5jYWNoZV9ucjsKCglpc3RhdGUtPnRpbWVzdGFtcC5zZWMgPSAwOwoJaXN0YXRlLT50aW1lc3RhbXAubnNlYyA9IDA7CglmZCA9IG9wZW4ocGF0aCwgT19SRE9OTFkpOwoJaWYgKGZkIDwgMCkgewoJCWlmIChlcnJubyA9PSBFTk9FTlQpCgkJCXJldHVybiAwOwoJCWRpZV9lcnJubygiaW5kZXggZmlsZSBvcGVuIGZhaWxlZCIpOwoJfQoKCWlmIChmc3RhdChmZCwgJnN0KSkKCQlkaWVfZXJybm8oImNhbm5vdCBzdGF0IHRoZSBvcGVuIGluZGV4Iik7CgoJbW1hcF9zaXplID0geHNpemVfdChzdC5zdF9zaXplKTsKCWlmIChtbWFwX3NpemUgPCBzaXplb2Yoc3RydWN0IGNhY2hlX2hlYWRlcikgKyAyMCkKCQlkaWUoImluZGV4IGZpbGUgc21hbGxlciB0aGFuIGV4cGVjdGVkIik7CgoJbW1hcCA9IHhtbWFwKE5VTEwsIG1tYXBfc2l6ZSwgUFJPVF9SRUFEIHwgUFJPVF9XUklURSwgTUFQX1BSSVZBVEUsIGZkLCAwKTsKCWlmIChtbWFwID09IE1BUF9GQUlMRUQpCgkJZGllX2Vycm5vKCJ1bmFibGUgdG8gbWFwIGluZGV4IGZpbGUiKTsKCWNsb3NlKGZkKTsKCgloZHIgPSBtbWFwOwoJaWYgKHZlcmlmeV9oZHIoaGRyLCBtbWFwX3NpemUpIDwgMCkKCQlnb3RvIHVubWFwOwoKCWlzdGF0ZS0+dmVyc2lvbiA9IG50b2hsKGhkci0+aGRyX3ZlcnNpb24pOwoJaXN0YXRlLT5jYWNoZV9uciA9IG50b2hsKGhkci0+aGRyX2VudHJpZXMpOwoJaXN0YXRlLT5jYWNoZV9hbGxvYyA9IGFsbG9jX25yKGlzdGF0ZS0+Y2FjaGVfbnIpOwoJaXN0YXRlLT5jYWNoZSA9IHhjYWxsb2MoaXN0YXRlLT5jYWNoZV9hbGxvYywgc2l6ZW9mKCppc3RhdGUtPmNhY2hlKSk7Cglpc3RhdGUtPmluaXRpYWxpemVkID0gMTsKCglpZiAoaXN0YXRlLT52ZXJzaW9uID09IDQpCgkJcHJldmlvdXNfbmFtZSA9ICZwcmV2aW91c19uYW1lX2J1ZjsKCWVsc2UKCQlwcmV2aW91c19uYW1lID0gTlVMTDsKCglzcmNfb2Zmc2V0ID0gc2l6ZW9mKCpoZHIpOwoJZm9yIChpID0gMDsgaSA8IGlzdGF0ZS0+Y2FjaGVfbnI7IGkrKykgewoJCXN0cnVjdCBvbmRpc2tfY2FjaGVfZW50cnkgKmRpc2tfY2U7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZTsKCQl1bnNpZ25lZCBsb25nIGNvbnN1bWVkOwoKCQlkaXNrX2NlID0gKHN0cnVjdCBvbmRpc2tfY2FjaGVfZW50cnkgKikoKGNoYXIgKiltbWFwICsgc3JjX29mZnNldCk7CgkJY2UgPSBjcmVhdGVfZnJvbV9kaXNrKGRpc2tfY2UsICZjb25zdW1lZCwgcHJldmlvdXNfbmFtZSk7CgkJc2V0X2luZGV4X2VudHJ5KGlzdGF0ZSwgaSwgY2UpOwoKCQlzcmNfb2Zmc2V0ICs9IGNvbnN1bWVkOwoJfQoJc3RyYnVmX3JlbGVhc2UoJnByZXZpb3VzX25hbWVfYnVmKTsKCWlzdGF0ZS0+dGltZXN0YW1wLnNlYyA9IHN0LnN0X210aW1lOwoJaXN0YXRlLT50aW1lc3RhbXAubnNlYyA9IFNUX01USU1FX05TRUMoc3QpOwoKCXdoaWxlIChzcmNfb2Zmc2V0IDw9IG1tYXBfc2l6ZSAtIDIwIC0gOCkgewoJCS8qIEFmdGVyIGFuIGFycmF5IG9mIGFjdGl2ZV9uciBpbmRleCBlbnRyaWVzLAoJCSAqIHRoZXJlIGNhbiBiZSBhcmJpdHJhcnkgbnVtYmVyIG9mIGV4dGVuZGVkCgkJICogc2VjdGlvbnMsIGVhY2ggb2Ygd2hpY2ggaXMgcHJlZml4ZWQgd2l0aAoJCSAqIGV4dGVuc2lvbiBuYW1lICg0LWJ5dGUpIGFuZCBzZWN0aW9uIGxlbmd0aAoJCSAqIGluIDQtYnl0ZSBuZXR3b3JrIGJ5dGUgb3JkZXIuCgkJICovCgkJdWludDMyX3QgZXh0c2l6ZTsKCQltZW1jcHkoJmV4dHNpemUsIChjaGFyICopbW1hcCArIHNyY19vZmZzZXQgKyA0LCA0KTsKCQlleHRzaXplID0gbnRvaGwoZXh0c2l6ZSk7CgkJaWYgKHJlYWRfaW5kZXhfZXh0ZW5zaW9uKGlzdGF0ZSwKCQkJCQkgKGNvbnN0IGNoYXIgKikgbW1hcCArIHNyY19vZmZzZXQsCgkJCQkJIChjaGFyICopIG1tYXAgKyBzcmNfb2Zmc2V0ICsgOCwKCQkJCQkgZXh0c2l6ZSkgPCAwKQoJCQlnb3RvIHVubWFwOwoJCXNyY19vZmZzZXQgKz0gODsKCQlzcmNfb2Zmc2V0ICs9IGV4dHNpemU7Cgl9CgltdW5tYXAobW1hcCwgbW1hcF9zaXplKTsKCXJldHVybiBpc3RhdGUtPmNhY2hlX25yOwoKdW5tYXA6CgltdW5tYXAobW1hcCwgbW1hcF9zaXplKTsKCWRpZSgiaW5kZXggZmlsZSBjb3JydXB0Iik7Cn0KCmludCBpc19pbmRleF91bmJvcm4oc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUpCnsKCXJldHVybiAoIWlzdGF0ZS0+Y2FjaGVfbnIgJiYgIWlzdGF0ZS0+dGltZXN0YW1wLnNlYyk7Cn0KCmludCBkaXNjYXJkX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlKQp7CglpbnQgaTsKCglmb3IgKGkgPSAwOyBpIDwgaXN0YXRlLT5jYWNoZV9ucjsgaSsrKQoJCWZyZWUoaXN0YXRlLT5jYWNoZVtpXSk7CglyZXNvbHZlX3VuZG9fY2xlYXJfaW5kZXgoaXN0YXRlKTsKCWlzdGF0ZS0+Y2FjaGVfbnIgPSAwOwoJaXN0YXRlLT5jYWNoZV9jaGFuZ2VkID0gMDsKCWlzdGF0ZS0+dGltZXN0YW1wLnNlYyA9IDA7Cglpc3RhdGUtPnRpbWVzdGFtcC5uc2VjID0gMDsKCWZyZWVfbmFtZV9oYXNoKGlzdGF0ZSk7CgljYWNoZV90cmVlX2ZyZWUoJihpc3RhdGUtPmNhY2hlX3RyZWUpKTsKCWlzdGF0ZS0+aW5pdGlhbGl6ZWQgPSAwOwoJZnJlZShpc3RhdGUtPmNhY2hlKTsKCWlzdGF0ZS0+Y2FjaGUgPSBOVUxMOwoJaXN0YXRlLT5jYWNoZV9hbGxvYyA9IDA7CglyZXR1cm4gMDsKfQoKaW50IHVubWVyZ2VkX2luZGV4KGNvbnN0IHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlKQp7CglpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCBpc3RhdGUtPmNhY2hlX25yOyBpKyspIHsKCQlpZiAoY2Vfc3RhZ2UoaXN0YXRlLT5jYWNoZVtpXSkpCgkJCXJldHVybiAxOwoJfQoJcmV0dXJuIDA7Cn0KCiNkZWZpbmUgV1JJVEVfQlVGRkVSX1NJWkUgODE5MgpzdGF0aWMgdW5zaWduZWQgY2hhciB3cml0ZV9idWZmZXJbV1JJVEVfQlVGRkVSX1NJWkVdOwpzdGF0aWMgdW5zaWduZWQgbG9uZyB3cml0ZV9idWZmZXJfbGVuOwoKc3RhdGljIGludCBjZV93cml0ZV9mbHVzaChnaXRfU0hBX0NUWCAqY29udGV4dCwgaW50IGZkKQp7Cgl1bnNpZ25lZCBpbnQgYnVmZmVyZWQgPSB3cml0ZV9idWZmZXJfbGVuOwoJaWYgKGJ1ZmZlcmVkKSB7CgkJZ2l0X1NIQTFfVXBkYXRlKGNvbnRleHQsIHdyaXRlX2J1ZmZlciwgYnVmZmVyZWQpOwoJCWlmICh3cml0ZV9pbl9mdWxsKGZkLCB3cml0ZV9idWZmZXIsIGJ1ZmZlcmVkKSAhPSBidWZmZXJlZCkKCQkJcmV0dXJuIC0xOwoJCXdyaXRlX2J1ZmZlcl9sZW4gPSAwOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgY2Vfd3JpdGUoZ2l0X1NIQV9DVFggKmNvbnRleHQsIGludCBmZCwgdm9pZCAqZGF0YSwgdW5zaWduZWQgaW50IGxlbikKewoJd2hpbGUgKGxlbikgewoJCXVuc2lnbmVkIGludCBidWZmZXJlZCA9IHdyaXRlX2J1ZmZlcl9sZW47CgkJdW5zaWduZWQgaW50IHBhcnRpYWwgPSBXUklURV9CVUZGRVJfU0laRSAtIGJ1ZmZlcmVkOwoJCWlmIChwYXJ0aWFsID4gbGVuKQoJCQlwYXJ0aWFsID0gbGVuOwoJCW1lbWNweSh3cml0ZV9idWZmZXIgKyBidWZmZXJlZCwgZGF0YSwgcGFydGlhbCk7CgkJYnVmZmVyZWQgKz0gcGFydGlhbDsKCQlpZiAoYnVmZmVyZWQgPT0gV1JJVEVfQlVGRkVSX1NJWkUpIHsKCQkJd3JpdGVfYnVmZmVyX2xlbiA9IGJ1ZmZlcmVkOwoJCQlpZiAoY2Vfd3JpdGVfZmx1c2goY29udGV4dCwgZmQpKQoJCQkJcmV0dXJuIC0xOwoJCQlidWZmZXJlZCA9IDA7CgkJfQoJCXdyaXRlX2J1ZmZlcl9sZW4gPSBidWZmZXJlZDsKCQlsZW4gLT0gcGFydGlhbDsKCQlkYXRhID0gKGNoYXIgKikgZGF0YSArIHBhcnRpYWw7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCB3cml0ZV9pbmRleF9leHRfaGVhZGVyKGdpdF9TSEFfQ1RYICpjb250ZXh0LCBpbnQgZmQsCgkJCQkgIHVuc2lnbmVkIGludCBleHQsIHVuc2lnbmVkIGludCBzeikKewoJZXh0ID0gaHRvbmwoZXh0KTsKCXN6ID0gaHRvbmwoc3opOwoJcmV0dXJuICgoY2Vfd3JpdGUoY29udGV4dCwgZmQsICZleHQsIDQpIDwgMCkgfHwKCQkoY2Vfd3JpdGUoY29udGV4dCwgZmQsICZzeiwgNCkgPCAwKSkgPyAtMSA6IDA7Cn0KCnN0YXRpYyBpbnQgY2VfZmx1c2goZ2l0X1NIQV9DVFggKmNvbnRleHQsIGludCBmZCkKewoJdW5zaWduZWQgaW50IGxlZnQgPSB3cml0ZV9idWZmZXJfbGVuOwoKCWlmIChsZWZ0KSB7CgkJd3JpdGVfYnVmZmVyX2xlbiA9IDA7CgkJZ2l0X1NIQTFfVXBkYXRlKGNvbnRleHQsIHdyaXRlX2J1ZmZlciwgbGVmdCk7Cgl9CgoJLyogRmx1c2ggZmlyc3QgaWYgbm90IGVub3VnaCBzcGFjZSBmb3IgU0hBMSBzaWduYXR1cmUgKi8KCWlmIChsZWZ0ICsgMjAgPiBXUklURV9CVUZGRVJfU0laRSkgewoJCWlmICh3cml0ZV9pbl9mdWxsKGZkLCB3cml0ZV9idWZmZXIsIGxlZnQpICE9IGxlZnQpCgkJCXJldHVybiAtMTsKCQlsZWZ0ID0gMDsKCX0KCgkvKiBBcHBlbmQgdGhlIFNIQTEgc2lnbmF0dXJlIGF0IHRoZSBlbmQgKi8KCWdpdF9TSEExX0ZpbmFsKHdyaXRlX2J1ZmZlciArIGxlZnQsIGNvbnRleHQpOwoJbGVmdCArPSAyMDsKCXJldHVybiAod3JpdGVfaW5fZnVsbChmZCwgd3JpdGVfYnVmZmVyLCBsZWZ0KSAhPSBsZWZ0KSA/IC0xIDogMDsKfQoKc3RhdGljIHZvaWQgY2Vfc211ZGdlX3JhY2lseV9jbGVhbl9lbnRyeShzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKQp7CgkvKgoJICogVGhlIG9ubHkgdGhpbmcgd2UgY2FyZSBhYm91dCBpbiB0aGlzIGZ1bmN0aW9uIGlzIHRvIHNtdWRnZSB0aGUKCSAqIGZhbHNlbHkgY2xlYW4gZW50cnkgZHVlIHRvIHRvdWNoLXVwZGF0ZS10b3VjaCByYWNlLCBzbyB3ZSBsZWF2ZQoJICogZXZlcnl0aGluZyBlbHNlIGFzIHRoZXkgYXJlLiAgV2UgYXJlIGNhbGxlZCBmb3IgZW50cmllcyB3aG9zZQoJICogY2Vfc3RhdF9kYXRhLnNkX210aW1lIG1hdGNoIHRoZSBpbmRleCBmaWxlIG10aW1lLgoJICoKCSAqIE5vdGUgdGhhdCB0aGlzIGFjdHVhbGx5IGRvZXMgbm90IGRvIG11Y2ggZm9yIGdpdGxpbmtzLCBmb3IKCSAqIHdoaWNoIGNlX21hdGNoX3N0YXRfYmFzaWMoKSBhbHdheXMgZ29lcyB0byB0aGUgYWN0dWFsCgkgKiBjb250ZW50cy4gIFRoZSBjYWxsZXIgY2hlY2tzIHdpdGggaXNfcmFjeV90aW1lc3RhbXAoKSB3aGljaAoJICogYWx3YXlzIHNheXMgIm5vIiBmb3IgZ2l0bGlua3MsIHNvIHdlIGFyZSBub3QgY2FsbGVkIGZvciB0aGVtIDstKQoJICovCglzdHJ1Y3Qgc3RhdCBzdDsKCglpZiAobHN0YXQoY2UtPm5hbWUsICZzdCkgPCAwKQoJCXJldHVybjsKCWlmIChjZV9tYXRjaF9zdGF0X2Jhc2ljKGNlLCAmc3QpKQoJCXJldHVybjsKCWlmIChjZV9tb2RpZmllZF9jaGVja19mcyhjZSwgJnN0KSkgewoJCS8qIFRoaXMgaXMgInJhY2lseSBjbGVhbiI7IHNtdWRnZSBpdC4gIE5vdGUgdGhhdCB0aGlzCgkJICogaXMgYSB0cmlja3kgY29kZS4gIEF0IGZpcnN0IGdsYW5jZSwgaXQgbWF5IGFwcGVhcgoJCSAqIHRoYXQgaXQgY2FuIGJyZWFrIHdpdGggdGhpcyBzZXF1ZW5jZToKCQkgKgoJCSAqICQgZWNobyB4eXp6eSA+ZnJvdHoKCQkgKiAkIGdpdC11cGRhdGUtaW5kZXggLS1hZGQgZnJvdHoKCQkgKiAkIDogPmZyb3R6CgkJICogJCBzbGVlcCAzCgkJICogJCBlY2hvIGZpbGZyZSA+bml0Zm9sCgkJICogJCBnaXQtdXBkYXRlLWluZGV4IC0tYWRkIG5pdGZvbAoJCSAqCgkJICogYnV0IGl0IGRvZXMgbm90LiAgV2hlbiB0aGUgc2Vjb25kIHVwZGF0ZS1pbmRleCBydW5zLAoJCSAqIGl0IG5vdGljZXMgdGhhdCB0aGUgZW50cnkgImZyb3R6IiBoYXMgdGhlIHNhbWUgdGltZXN0YW1wCgkJICogYXMgaW5kZXgsIGFuZCBpZiB3ZSB3ZXJlIHRvIHNtdWRnZSBpdCBieSByZXNldHRpbmcgaXRzCgkJICogc2l6ZSB0byB6ZXJvIGhlcmUsIHRoZW4gdGhlIG9iamVjdCBuYW1lIHJlY29yZGVkCgkJICogaW4gaW5kZXggaXMgdGhlIDYtYnl0ZSBmaWxlIGJ1dCB0aGUgY2FjaGVkIHN0YXQgaW5mb3JtYXRpb24KCQkgKiBiZWNvbWVzIHplcm8gLS0tIHdoaWNoIHdvdWxkIHRoZW4gbWF0Y2ggd2hhdCB3ZSB3b3VsZAoJCSAqIG9idGFpbiBmcm9tIHRoZSBmaWxlc3lzdGVtIG5leHQgdGltZSB3ZSBzdGF0KCJmcm90eiIpLgoJCSAqCgkJICogSG93ZXZlciwgdGhlIHNlY29uZCB1cGRhdGUtaW5kZXgsIGJlZm9yZSBjYWxsaW5nCgkJICogdGhpcyBmdW5jdGlvbiwgbm90aWNlcyB0aGF0IHRoZSBjYWNoZWQgc2l6ZSBpcyA2CgkJICogYnl0ZXMgYW5kIHdoYXQgaXMgb24gdGhlIGZpbGVzeXN0ZW0gaXMgYW4gZW1wdHkKCQkgKiBmaWxlLCBhbmQgbmV2ZXIgY2FsbHMgdXMsIHNvIHRoZSBjYWNoZWQgc2l6ZSBpbmZvcm1hdGlvbgoJCSAqIGZvciAiZnJvdHoiIHN0YXlzIDYgd2hpY2ggZG9lcyBub3QgbWF0Y2ggdGhlIGZpbGVzeXN0ZW0uCgkJICovCgkJY2UtPmNlX3N0YXRfZGF0YS5zZF9zaXplID0gMDsKCX0KfQoKLyogQ29weSBtaXNjZWxsYW5lb3VzIGZpZWxkcyBidXQgbm90IHRoZSBuYW1lICovCnN0YXRpYyBjaGFyICpjb3B5X2NhY2hlX2VudHJ5X3RvX29uZGlzayhzdHJ1Y3Qgb25kaXNrX2NhY2hlX2VudHJ5ICpvbmRpc2ssCgkJCQkgICAgICAgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSkKewoJc2hvcnQgZmxhZ3M7CgoJb25kaXNrLT5jdGltZS5zZWMgPSBodG9ubChjZS0+Y2Vfc3RhdF9kYXRhLnNkX2N0aW1lLnNlYyk7CglvbmRpc2stPm10aW1lLnNlYyA9IGh0b25sKGNlLT5jZV9zdGF0X2RhdGEuc2RfbXRpbWUuc2VjKTsKCW9uZGlzay0+Y3RpbWUubnNlYyA9IGh0b25sKGNlLT5jZV9zdGF0X2RhdGEuc2RfY3RpbWUubnNlYyk7CglvbmRpc2stPm10aW1lLm5zZWMgPSBodG9ubChjZS0+Y2Vfc3RhdF9kYXRhLnNkX210aW1lLm5zZWMpOwoJb25kaXNrLT5kZXYgID0gaHRvbmwoY2UtPmNlX3N0YXRfZGF0YS5zZF9kZXYpOwoJb25kaXNrLT5pbm8gID0gaHRvbmwoY2UtPmNlX3N0YXRfZGF0YS5zZF9pbm8pOwoJb25kaXNrLT5tb2RlID0gaHRvbmwoY2UtPmNlX21vZGUpOwoJb25kaXNrLT51aWQgID0gaHRvbmwoY2UtPmNlX3N0YXRfZGF0YS5zZF91aWQpOwoJb25kaXNrLT5naWQgID0gaHRvbmwoY2UtPmNlX3N0YXRfZGF0YS5zZF9naWQpOwoJb25kaXNrLT5zaXplID0gaHRvbmwoY2UtPmNlX3N0YXRfZGF0YS5zZF9zaXplKTsKCWhhc2hjcHkob25kaXNrLT5zaGExLCBjZS0+c2hhMSk7CgoJZmxhZ3MgPSBjZS0+Y2VfZmxhZ3M7CglmbGFncyB8PSAoY2VfbmFtZWxlbihjZSkgPj0gQ0VfTkFNRU1BU0sgPyBDRV9OQU1FTUFTSyA6IGNlX25hbWVsZW4oY2UpKTsKCW9uZGlzay0+ZmxhZ3MgPSBodG9ucyhmbGFncyk7CglpZiAoY2UtPmNlX2ZsYWdzICYgQ0VfRVhURU5ERUQpIHsKCQlzdHJ1Y3Qgb25kaXNrX2NhY2hlX2VudHJ5X2V4dGVuZGVkICpvbmRpc2syOwoJCW9uZGlzazIgPSAoc3RydWN0IG9uZGlza19jYWNoZV9lbnRyeV9leHRlbmRlZCAqKW9uZGlzazsKCQlvbmRpc2syLT5mbGFnczIgPSBodG9ucygoY2UtPmNlX2ZsYWdzICYgQ0VfRVhURU5ERURfRkxBR1MpID4+IDE2KTsKCQlyZXR1cm4gb25kaXNrMi0+bmFtZTsKCX0KCWVsc2UgewoJCXJldHVybiBvbmRpc2stPm5hbWU7Cgl9Cn0KCnN0YXRpYyBpbnQgY2Vfd3JpdGVfZW50cnkoZ2l0X1NIQV9DVFggKmMsIGludCBmZCwgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwKCQkJICBzdHJ1Y3Qgc3RyYnVmICpwcmV2aW91c19uYW1lKQp7CglpbnQgc2l6ZTsKCXN0cnVjdCBvbmRpc2tfY2FjaGVfZW50cnkgKm9uZGlzazsKCWNoYXIgKm5hbWU7CglpbnQgcmVzdWx0OwoKCWlmICghcHJldmlvdXNfbmFtZSkgewoJCXNpemUgPSBvbmRpc2tfY2Vfc2l6ZShjZSk7CgkJb25kaXNrID0geGNhbGxvYygxLCBzaXplKTsKCQluYW1lID0gY29weV9jYWNoZV9lbnRyeV90b19vbmRpc2sob25kaXNrLCBjZSk7CgkJbWVtY3B5KG5hbWUsIGNlLT5uYW1lLCBjZV9uYW1lbGVuKGNlKSk7Cgl9IGVsc2UgewoJCWludCBjb21tb24sIHRvX3JlbW92ZSwgcHJlZml4X3NpemU7CgkJdW5zaWduZWQgY2hhciB0b19yZW1vdmVfdmlbMTZdOwoJCWZvciAoY29tbW9uID0gMDsKCQkgICAgIChjZS0+bmFtZVtjb21tb25dICYmCgkJICAgICAgY29tbW9uIDwgcHJldmlvdXNfbmFtZS0+bGVuICYmCgkJICAgICAgY2UtPm5hbWVbY29tbW9uXSA9PSBwcmV2aW91c19uYW1lLT5idWZbY29tbW9uXSk7CgkJICAgICBjb21tb24rKykKCQkJOyAvKiBzdGlsbCBtYXRjaGluZyAqLwoJCXRvX3JlbW92ZSA9IHByZXZpb3VzX25hbWUtPmxlbiAtIGNvbW1vbjsKCQlwcmVmaXhfc2l6ZSA9IGVuY29kZV92YXJpbnQodG9fcmVtb3ZlLCB0b19yZW1vdmVfdmkpOwoKCQlpZiAoY2UtPmNlX2ZsYWdzICYgQ0VfRVhURU5ERUQpCgkJCXNpemUgPSBvZmZzZXRvZihzdHJ1Y3Qgb25kaXNrX2NhY2hlX2VudHJ5X2V4dGVuZGVkLCBuYW1lKTsKCQllbHNlCgkJCXNpemUgPSBvZmZzZXRvZihzdHJ1Y3Qgb25kaXNrX2NhY2hlX2VudHJ5LCBuYW1lKTsKCQlzaXplICs9IHByZWZpeF9zaXplICsgKGNlX25hbWVsZW4oY2UpIC0gY29tbW9uICsgMSk7CgoJCW9uZGlzayA9IHhjYWxsb2MoMSwgc2l6ZSk7CgkJbmFtZSA9IGNvcHlfY2FjaGVfZW50cnlfdG9fb25kaXNrKG9uZGlzaywgY2UpOwoJCW1lbWNweShuYW1lLCB0b19yZW1vdmVfdmksIHByZWZpeF9zaXplKTsKCQltZW1jcHkobmFtZSArIHByZWZpeF9zaXplLCBjZS0+bmFtZSArIGNvbW1vbiwgY2VfbmFtZWxlbihjZSkgLSBjb21tb24pOwoKCQlzdHJidWZfc3BsaWNlKHByZXZpb3VzX25hbWUsIGNvbW1vbiwgdG9fcmVtb3ZlLAoJCQkgICAgICBjZS0+bmFtZSArIGNvbW1vbiwgY2VfbmFtZWxlbihjZSkgLSBjb21tb24pOwoJfQoKCXJlc3VsdCA9IGNlX3dyaXRlKGMsIGZkLCBvbmRpc2ssIHNpemUpOwoJZnJlZShvbmRpc2spOwoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIGludCBoYXNfcmFjeV90aW1lc3RhbXAoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUpCnsKCWludCBlbnRyaWVzID0gaXN0YXRlLT5jYWNoZV9ucjsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBlbnRyaWVzOyBpKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gaXN0YXRlLT5jYWNoZVtpXTsKCQlpZiAoaXNfcmFjeV90aW1lc3RhbXAoaXN0YXRlLCBjZSkpCgkJCXJldHVybiAxOwoJfQoJcmV0dXJuIDA7Cn0KCi8qCiAqIE9wcG9ydHVuaXN0aWNhbGx5IHVwZGF0ZSB0aGUgaW5kZXggYnV0IGRvIG5vdCBjb21wbGFpbiBpZiB3ZSBjYW4ndAogKi8Kdm9pZCB1cGRhdGVfaW5kZXhfaWZfYWJsZShzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgc3RydWN0IGxvY2tfZmlsZSAqbG9ja2ZpbGUpCnsKCWlmICgoaXN0YXRlLT5jYWNoZV9jaGFuZ2VkIHx8IGhhc19yYWN5X3RpbWVzdGFtcChpc3RhdGUpKSAmJgoJICAgICF3cml0ZV9pbmRleChpc3RhdGUsIGxvY2tmaWxlLT5mZCkpCgkJY29tbWl0X2xvY2tlZF9pbmRleChsb2NrZmlsZSk7CgllbHNlCgkJcm9sbGJhY2tfbG9ja19maWxlKGxvY2tmaWxlKTsKfQoKaW50IHdyaXRlX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBpbnQgbmV3ZmQpCnsKCWdpdF9TSEFfQ1RYIGM7CglzdHJ1Y3QgY2FjaGVfaGVhZGVyIGhkcjsKCWludCBpLCBlcnIsIHJlbW92ZWQsIGV4dGVuZGVkLCBoZHJfdmVyc2lvbjsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqKmNhY2hlID0gaXN0YXRlLT5jYWNoZTsKCWludCBlbnRyaWVzID0gaXN0YXRlLT5jYWNoZV9ucjsKCXN0cnVjdCBzdGF0IHN0OwoJc3RydWN0IHN0cmJ1ZiBwcmV2aW91c19uYW1lX2J1ZiA9IFNUUkJVRl9JTklULCAqcHJldmlvdXNfbmFtZTsKCglmb3IgKGkgPSByZW1vdmVkID0gZXh0ZW5kZWQgPSAwOyBpIDwgZW50cmllczsgaSsrKSB7CgkJaWYgKGNhY2hlW2ldLT5jZV9mbGFncyAmIENFX1JFTU9WRSkKCQkJcmVtb3ZlZCsrOwoKCQkvKiByZWR1Y2UgZXh0ZW5kZWQgZW50cmllcyBpZiBwb3NzaWJsZSAqLwoJCWNhY2hlW2ldLT5jZV9mbGFncyAmPSB+Q0VfRVhURU5ERUQ7CgkJaWYgKGNhY2hlW2ldLT5jZV9mbGFncyAmIENFX0VYVEVOREVEX0ZMQUdTKSB7CgkJCWV4dGVuZGVkKys7CgkJCWNhY2hlW2ldLT5jZV9mbGFncyB8PSBDRV9FWFRFTkRFRDsKCQl9Cgl9CgoJaWYgKCFpc3RhdGUtPnZlcnNpb24pCgkJaXN0YXRlLT52ZXJzaW9uID0gSU5ERVhfRk9STUFUX0RFRkFVTFQ7CgoJLyogZGVtb3RlIHZlcnNpb24gMyB0byB2ZXJzaW9uIDIgd2hlbiB0aGUgbGF0dGVyIHN1ZmZpY2VzICovCglpZiAoaXN0YXRlLT52ZXJzaW9uID09IDMgfHwgaXN0YXRlLT52ZXJzaW9uID09IDIpCgkJaXN0YXRlLT52ZXJzaW9uID0gZXh0ZW5kZWQgPyAzIDogMjsKCgloZHJfdmVyc2lvbiA9IGlzdGF0ZS0+dmVyc2lvbjsKCgloZHIuaGRyX3NpZ25hdHVyZSA9IGh0b25sKENBQ0hFX1NJR05BVFVSRSk7CgloZHIuaGRyX3ZlcnNpb24gPSBodG9ubChoZHJfdmVyc2lvbik7CgloZHIuaGRyX2VudHJpZXMgPSBodG9ubChlbnRyaWVzIC0gcmVtb3ZlZCk7CgoJZ2l0X1NIQTFfSW5pdCgmYyk7CglpZiAoY2Vfd3JpdGUoJmMsIG5ld2ZkLCAmaGRyLCBzaXplb2YoaGRyKSkgPCAwKQoJCXJldHVybiAtMTsKCglwcmV2aW91c19uYW1lID0gKGhkcl92ZXJzaW9uID09IDQpID8gJnByZXZpb3VzX25hbWVfYnVmIDogTlVMTDsKCWZvciAoaSA9IDA7IGkgPCBlbnRyaWVzOyBpKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gY2FjaGVbaV07CgkJaWYgKGNlLT5jZV9mbGFncyAmIENFX1JFTU9WRSkKCQkJY29udGludWU7CgkJaWYgKCFjZV91cHRvZGF0ZShjZSkgJiYgaXNfcmFjeV90aW1lc3RhbXAoaXN0YXRlLCBjZSkpCgkJCWNlX3NtdWRnZV9yYWNpbHlfY2xlYW5fZW50cnkoY2UpOwoJCWlmIChpc19udWxsX3NoYTEoY2UtPnNoYTEpKSB7CgkJCXN0YXRpYyBjb25zdCBjaGFyIG1zZ1tdID0gImNhY2hlIGVudHJ5IGhhcyBudWxsIHNoYTE6ICVzIjsKCQkJc3RhdGljIGludCBhbGxvdyA9IC0xOwoKCQkJaWYgKGFsbG93IDwgMCkKCQkJCWFsbG93ID0gZ2l0X2Vudl9ib29sKCJHSVRfQUxMT1dfTlVMTF9TSEExIiwgMCk7CgkJCWlmIChhbGxvdykKCQkJCXdhcm5pbmcobXNnLCBjZS0+bmFtZSk7CgkJCWVsc2UKCQkJCXJldHVybiBlcnJvcihtc2csIGNlLT5uYW1lKTsKCQl9CgkJaWYgKGNlX3dyaXRlX2VudHJ5KCZjLCBuZXdmZCwgY2UsIHByZXZpb3VzX25hbWUpIDwgMCkKCQkJcmV0dXJuIC0xOwoJfQoJc3RyYnVmX3JlbGVhc2UoJnByZXZpb3VzX25hbWVfYnVmKTsKCgkvKiBXcml0ZSBleHRlbnNpb24gZGF0YSBoZXJlICovCglpZiAoaXN0YXRlLT5jYWNoZV90cmVlKSB7CgkJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoKCQljYWNoZV90cmVlX3dyaXRlKCZzYiwgaXN0YXRlLT5jYWNoZV90cmVlKTsKCQllcnIgPSB3cml0ZV9pbmRleF9leHRfaGVhZGVyKCZjLCBuZXdmZCwgQ0FDSEVfRVhUX1RSRUUsIHNiLmxlbikgPCAwCgkJCXx8IGNlX3dyaXRlKCZjLCBuZXdmZCwgc2IuYnVmLCBzYi5sZW4pIDwgMDsKCQlzdHJidWZfcmVsZWFzZSgmc2IpOwoJCWlmIChlcnIpCgkJCXJldHVybiAtMTsKCX0KCWlmIChpc3RhdGUtPnJlc29sdmVfdW5kbykgewoJCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCgkJcmVzb2x2ZV91bmRvX3dyaXRlKCZzYiwgaXN0YXRlLT5yZXNvbHZlX3VuZG8pOwoJCWVyciA9IHdyaXRlX2luZGV4X2V4dF9oZWFkZXIoJmMsIG5ld2ZkLCBDQUNIRV9FWFRfUkVTT0xWRV9VTkRPLAoJCQkJCSAgICAgc2IubGVuKSA8IDAKCQkJfHwgY2Vfd3JpdGUoJmMsIG5ld2ZkLCBzYi5idWYsIHNiLmxlbikgPCAwOwoJCXN0cmJ1Zl9yZWxlYXNlKCZzYik7CgkJaWYgKGVycikKCQkJcmV0dXJuIC0xOwoJfQoKCWlmIChjZV9mbHVzaCgmYywgbmV3ZmQpIHx8IGZzdGF0KG5ld2ZkLCAmc3QpKQoJCXJldHVybiAtMTsKCWlzdGF0ZS0+dGltZXN0YW1wLnNlYyA9ICh1bnNpZ25lZCBpbnQpc3Quc3RfbXRpbWU7Cglpc3RhdGUtPnRpbWVzdGFtcC5uc2VjID0gU1RfTVRJTUVfTlNFQyhzdCk7CglyZXR1cm4gMDsKfQoKLyoKICogUmVhZCB0aGUgaW5kZXggZmlsZSB0aGF0IGlzIHBvdGVudGlhbGx5IHVubWVyZ2VkIGludG8gZ2l2ZW4KICogaW5kZXhfc3RhdGUsIGRyb3BwaW5nIGFueSB1bm1lcmdlZCBlbnRyaWVzLiAgUmV0dXJucyB0cnVlIGlmCiAqIHRoZSBpbmRleCBpcyB1bm1lcmdlZC4gIENhbGxlcnMgd2hvIHdhbnQgdG8gcmVmdXNlIHRvIHdvcmsKICogZnJvbSBhbiB1bm1lcmdlZCBzdGF0ZSBjYW4gY2FsbCB0aGlzIGFuZCBjaGVjayBpdHMgcmV0dXJuIHZhbHVlLAogKiBpbnN0ZWFkIG9mIGNhbGxpbmcgcmVhZF9jYWNoZSgpLgogKi8KaW50IHJlYWRfaW5kZXhfdW5tZXJnZWQoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUpCnsKCWludCBpOwoJaW50IHVubWVyZ2VkID0gMDsKCglyZWFkX2luZGV4KGlzdGF0ZSk7Cglmb3IgKGkgPSAwOyBpIDwgaXN0YXRlLT5jYWNoZV9ucjsgaSsrKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGlzdGF0ZS0+Y2FjaGVbaV07CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpuZXdfY2U7CgkJaW50IHNpemUsIGxlbjsKCgkJaWYgKCFjZV9zdGFnZShjZSkpCgkJCWNvbnRpbnVlOwoJCXVubWVyZ2VkID0gMTsKCQlsZW4gPSBjZV9uYW1lbGVuKGNlKTsKCQlzaXplID0gY2FjaGVfZW50cnlfc2l6ZShsZW4pOwoJCW5ld19jZSA9IHhjYWxsb2MoMSwgc2l6ZSk7CgkJbWVtY3B5KG5ld19jZS0+bmFtZSwgY2UtPm5hbWUsIGxlbik7CgkJbmV3X2NlLT5jZV9mbGFncyA9IGNyZWF0ZV9jZV9mbGFncygwKSB8IENFX0NPTkZMSUNURUQ7CgkJbmV3X2NlLT5jZV9uYW1lbGVuID0gbGVuOwoJCW5ld19jZS0+Y2VfbW9kZSA9IGNlLT5jZV9tb2RlOwoJCWlmIChhZGRfaW5kZXhfZW50cnkoaXN0YXRlLCBuZXdfY2UsIDApKQoJCQlyZXR1cm4gZXJyb3IoIiVzOiBjYW5ub3QgZHJvcCB0byBzdGFnZSAjMCIsCgkJCQkgICAgIGNlLT5uYW1lKTsKCQlpID0gaW5kZXhfbmFtZV9wb3MoaXN0YXRlLCBuZXdfY2UtPm5hbWUsIGxlbik7Cgl9CglyZXR1cm4gdW5tZXJnZWQ7Cn0KCi8qCiAqIFJldHVybnMgMSBpZiB0aGUgcGF0aCBpcyBhbiAib3RoZXIiIHBhdGggd2l0aCByZXNwZWN0IHRvCiAqIHRoZSBpbmRleDsgdGhhdCBpcywgdGhlIHBhdGggaXMgbm90IG1lbnRpb25lZCBpbiB0aGUgaW5kZXggYXQgYWxsLAogKiBlaXRoZXIgYXMgYSBmaWxlLCBhIGRpcmVjdG9yeSB3aXRoIHNvbWUgZmlsZXMgaW4gdGhlIGluZGV4LAogKiBvciBhcyBhbiB1bm1lcmdlZCBlbnRyeS4KICoKICogV2UgaGVscGZ1bGx5IHJlbW92ZSBhIHRyYWlsaW5nICIvIiBmcm9tIGRpcmVjdG9yaWVzIHNvIHRoYXQKICogdGhlIG91dHB1dCBvZiByZWFkX2RpcmVjdG9yeSBjYW4gYmUgdXNlZCBhcy1pcy4KICovCmludCBpbmRleF9uYW1lX2lzX290aGVyKGNvbnN0IHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBjb25zdCBjaGFyICpuYW1lLAoJCWludCBuYW1lbGVuKQp7CglpbnQgcG9zOwoJaWYgKG5hbWVsZW4gJiYgbmFtZVtuYW1lbGVuIC0gMV0gPT0gJy8nKQoJCW5hbWVsZW4tLTsKCXBvcyA9IGluZGV4X25hbWVfcG9zKGlzdGF0ZSwgbmFtZSwgbmFtZWxlbik7CglpZiAoMCA8PSBwb3MpCgkJcmV0dXJuIDA7CS8qIGV4YWN0IG1hdGNoICovCglwb3MgPSAtcG9zIC0gMTsKCWlmIChwb3MgPCBpc3RhdGUtPmNhY2hlX25yKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGlzdGF0ZS0+Y2FjaGVbcG9zXTsKCQlpZiAoY2VfbmFtZWxlbihjZSkgPT0gbmFtZWxlbiAmJgoJCSAgICAhbWVtY21wKGNlLT5uYW1lLCBuYW1lLCBuYW1lbGVuKSkKCQkJcmV0dXJuIDA7IC8qIFl1cCwgdGhpcyBvbmUgZXhpc3RzIHVubWVyZ2VkICovCgl9CglyZXR1cm4gMTsKfQoKdm9pZCAqcmVhZF9ibG9iX2RhdGFfZnJvbV9pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgY29uc3QgY2hhciAqcGF0aCwgdW5zaWduZWQgbG9uZyAqc2l6ZSkKewoJaW50IHBvcywgbGVuOwoJdW5zaWduZWQgbG9uZyBzejsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCXZvaWQgKmRhdGE7CgoJbGVuID0gc3RybGVuKHBhdGgpOwoJcG9zID0gaW5kZXhfbmFtZV9wb3MoaXN0YXRlLCBwYXRoLCBsZW4pOwoJaWYgKHBvcyA8IDApIHsKCQkvKgoJCSAqIFdlIG1pZ2h0IGJlIGluIHRoZSBtaWRkbGUgb2YgYSBtZXJnZSwgaW4gd2hpY2gKCQkgKiBjYXNlIHdlIHdvdWxkIHJlYWQgc3RhZ2UgIzIgKG91cnMpLgoJCSAqLwoJCWludCBpOwoJCWZvciAoaSA9IC1wb3MgLSAxOwoJCSAgICAgKHBvcyA8IDAgJiYgaSA8IGlzdGF0ZS0+Y2FjaGVfbnIgJiYKCQkgICAgICAhc3RyY21wKGlzdGF0ZS0+Y2FjaGVbaV0tPm5hbWUsIHBhdGgpKTsKCQkgICAgIGkrKykKCQkJaWYgKGNlX3N0YWdlKGlzdGF0ZS0+Y2FjaGVbaV0pID09IDIpCgkJCQlwb3MgPSBpOwoJfQoJaWYgKHBvcyA8IDApCgkJcmV0dXJuIE5VTEw7CglkYXRhID0gcmVhZF9zaGExX2ZpbGUoaXN0YXRlLT5jYWNoZVtwb3NdLT5zaGExLCAmdHlwZSwgJnN6KTsKCWlmICghZGF0YSB8fCB0eXBlICE9IE9CSl9CTE9CKSB7CgkJZnJlZShkYXRhKTsKCQlyZXR1cm4gTlVMTDsKCX0KCWlmIChzaXplKQoJCSpzaXplID0gc3o7CglyZXR1cm4gZGF0YTsKfQoKdm9pZCBzdGF0X3ZhbGlkaXR5X2NsZWFyKHN0cnVjdCBzdGF0X3ZhbGlkaXR5ICpzdikKewoJZnJlZShzdi0+c2QpOwoJc3YtPnNkID0gTlVMTDsKfQoKaW50IHN0YXRfdmFsaWRpdHlfY2hlY2soc3RydWN0IHN0YXRfdmFsaWRpdHkgKnN2LCBjb25zdCBjaGFyICpwYXRoKQp7CglzdHJ1Y3Qgc3RhdCBzdDsKCglpZiAoc3RhdChwYXRoLCAmc3QpIDwgMCkKCQlyZXR1cm4gc3YtPnNkID09IE5VTEw7CglpZiAoIXN2LT5zZCkKCQlyZXR1cm4gMDsKCXJldHVybiBTX0lTUkVHKHN0LnN0X21vZGUpICYmICFtYXRjaF9zdGF0X2RhdGEoc3YtPnNkLCAmc3QpOwp9Cgp2b2lkIHN0YXRfdmFsaWRpdHlfdXBkYXRlKHN0cnVjdCBzdGF0X3ZhbGlkaXR5ICpzdiwgaW50IGZkKQp7CglzdHJ1Y3Qgc3RhdCBzdDsKCglpZiAoZnN0YXQoZmQsICZzdCkgPCAwIHx8ICFTX0lTUkVHKHN0LnN0X21vZGUpKQoJCXN0YXRfdmFsaWRpdHlfY2xlYXIoc3YpOwoJZWxzZSB7CgkJaWYgKCFzdi0+c2QpCgkJCXN2LT5zZCA9IHhjYWxsb2MoMSwgc2l6ZW9mKHN0cnVjdCBzdGF0X2RhdGEpKTsKCQlmaWxsX3N0YXRfZGF0YShzdi0+c2QsICZzdCk7Cgl9Cn0K",
    "text": "/*\n * GIT - The information manager from hell\n *\n * Copyright (C) Linus Torvalds, 2005\n */\n#define NO_THE_INDEX_COMPATIBILITY_MACROS\n#include \"cache.h\"\n#include \"cache-tree.h\"\n#include \"refs.h\"\n#include \"dir.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"blob.h\"\n#include \"resolve-undo.h\"\n#include \"strbuf.h\"\n#include \"varint.h\"\n\nstatic struct cache_entry *refresh_cache_entry(struct cache_entry *ce, int really);\n\n/* Mask for the name length in ce_flags in the on-disk index */\n\n#define CE_NAMEMASK  (0x0fff)\n\n/* Index extensions.\n *\n * The first letter should be 'A'..'Z' for extensions that are not\n * necessary for a correct operation (i.e. optimization data).\n * When new extensions are added that _needs_ to be understood in\n * order to correctly interpret the index file, pick character that\n * is outside the range, to cause the reader to abort.\n */\n\n#define CACHE_EXT(s) ( (s[0]<<24)|(s[1]<<16)|(s[2]<<8)|(s[3]) )\n#define CACHE_EXT_TREE 0x54524545\t/* \"TREE\" */\n#define CACHE_EXT_RESOLVE_UNDO 0x52455543 /* \"REUC\" */\n\nstruct index_state the_index;\n\nstatic void set_index_entry(struct index_state *istate, int nr, struct cache_entry *ce)\n{\n\tistate->cache[nr] = ce;\n\tadd_name_hash(istate, ce);\n}\n\nstatic void replace_index_entry(struct index_state *istate, int nr, struct cache_entry *ce)\n{\n\tstruct cache_entry *old = istate->cache[nr];\n\n\tremove_name_hash(istate, old);\n\tset_index_entry(istate, nr, ce);\n\tistate->cache_changed = 1;\n}\n\nvoid rename_index_entry_at(struct index_state *istate, int nr, const char *new_name)\n{\n\tstruct cache_entry *old = istate->cache[nr], *new;\n\tint namelen = strlen(new_name);\n\n\tnew = xmalloc(cache_entry_size(namelen));\n\tcopy_cache_entry(new, old);\n\tnew->ce_flags &= ~CE_HASHED;\n\tnew->ce_namelen = namelen;\n\tmemcpy(new->name, new_name, namelen + 1);\n\n\tcache_tree_invalidate_path(istate->cache_tree, old->name);\n\tremove_index_entry_at(istate, nr);\n\tadd_index_entry(istate, new, ADD_CACHE_OK_TO_ADD|ADD_CACHE_OK_TO_REPLACE);\n}\n\nvoid fill_stat_data(struct stat_data *sd, struct stat *st)\n{\n\tsd->sd_ctime.sec = (unsigned int)st->st_ctime;\n\tsd->sd_mtime.sec = (unsigned int)st->st_mtime;\n\tsd->sd_ctime.nsec = ST_CTIME_NSEC(*st);\n\tsd->sd_mtime.nsec = ST_MTIME_NSEC(*st);\n\tsd->sd_dev = st->st_dev;\n\tsd->sd_ino = st->st_ino;\n\tsd->sd_uid = st->st_uid;\n\tsd->sd_gid = st->st_gid;\n\tsd->sd_size = st->st_size;\n}\n\nint match_stat_data(const struct stat_data *sd, struct stat *st)\n{\n\tint changed = 0;\n\n\tif (sd->sd_mtime.sec != (unsigned int)st->st_mtime)\n\t\tchanged |= MTIME_CHANGED;\n\tif (trust_ctime && check_stat &&\n\t    sd->sd_ctime.sec != (unsigned int)st->st_ctime)\n\t\tchanged |= CTIME_CHANGED;\n\n#ifdef USE_NSEC\n\tif (check_stat && sd->sd_mtime.nsec != ST_MTIME_NSEC(*st))\n\t\tchanged |= MTIME_CHANGED;\n\tif (trust_ctime && check_stat &&\n\t    sd->sd_ctime.nsec != ST_CTIME_NSEC(*st))\n\t\tchanged |= CTIME_CHANGED;\n#endif\n\n\tif (check_stat) {\n\t\tif (sd->sd_uid != (unsigned int) st->st_uid ||\n\t\t\tsd->sd_gid != (unsigned int) st->st_gid)\n\t\t\tchanged |= OWNER_CHANGED;\n\t\tif (sd->sd_ino != (unsigned int) st->st_ino)\n\t\t\tchanged |= INODE_CHANGED;\n\t}\n\n#ifdef USE_STDEV\n\t/*\n\t * st_dev breaks on network filesystems where different\n\t * clients will have different views of what \"device\"\n\t * the filesystem is on\n\t */\n\tif (check_stat && sd->sd_dev != (unsigned int) st->st_dev)\n\t\t\tchanged |= INODE_CHANGED;\n#endif\n\n\tif (sd->sd_size != (unsigned int) st->st_size)\n\t\tchanged |= DATA_CHANGED;\n\n\treturn changed;\n}\n\n/*\n * This only updates the \"non-critical\" parts of the directory\n * cache, ie the parts that aren't tracked by GIT, and only used\n * to validate the cache.\n */\nvoid fill_stat_cache_info(struct cache_entry *ce, struct stat *st)\n{\n\tfill_stat_data(&ce->ce_stat_data, st);\n\n\tif (assume_unchanged)\n\t\tce->ce_flags |= CE_VALID;\n\n\tif (S_ISREG(st->st_mode))\n\t\tce_mark_uptodate(ce);\n}\n\nstatic int ce_compare_data(const struct cache_entry *ce, struct stat *st)\n{\n\tint match = -1;\n\tint fd = open(ce->name, O_RDONLY);\n\n\tif (fd >= 0) {\n\t\tunsigned char sha1[20];\n\t\tif (!index_fd(sha1, fd, st, OBJ_BLOB, ce->name, 0))\n\t\t\tmatch = hashcmp(sha1, ce->sha1);\n\t\t/* index_fd() closed the file descriptor already */\n\t}\n\treturn match;\n}\n\nstatic int ce_compare_link(const struct cache_entry *ce, size_t expected_size)\n{\n\tint match = -1;\n\tvoid *buffer;\n\tunsigned long size;\n\tenum object_type type;\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tif (strbuf_readlink(&sb, ce->name, expected_size))\n\t\treturn -1;\n\n\tbuffer = read_sha1_file(ce->sha1, &type, &size);\n\tif (buffer) {\n\t\tif (size == sb.len)\n\t\t\tmatch = memcmp(buffer, sb.buf, size);\n\t\tfree(buffer);\n\t}\n\tstrbuf_release(&sb);\n\treturn match;\n}\n\nstatic int ce_compare_gitlink(const struct cache_entry *ce)\n{\n\tunsigned char sha1[20];\n\n\t/*\n\t * We don't actually require that the .git directory\n\t * under GITLINK directory be a valid git directory. It\n\t * might even be missing (in case nobody populated that\n\t * sub-project).\n\t *\n\t * If so, we consider it always to match.\n\t */\n\tif (resolve_gitlink_ref(ce->name, \"HEAD\", sha1) < 0)\n\t\treturn 0;\n\treturn hashcmp(sha1, ce->sha1);\n}\n\nstatic int ce_modified_check_fs(const struct cache_entry *ce, struct stat *st)\n{\n\tswitch (st->st_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tif (ce_compare_data(ce, st))\n\t\t\treturn DATA_CHANGED;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (ce_compare_link(ce, xsize_t(st->st_size)))\n\t\t\treturn DATA_CHANGED;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tif (S_ISGITLINK(ce->ce_mode))\n\t\t\treturn ce_compare_gitlink(ce) ? DATA_CHANGED : 0;\n\tdefault:\n\t\treturn TYPE_CHANGED;\n\t}\n\treturn 0;\n}\n\nstatic int ce_match_stat_basic(const struct cache_entry *ce, struct stat *st)\n{\n\tunsigned int changed = 0;\n\n\tif (ce->ce_flags & CE_REMOVE)\n\t\treturn MODE_CHANGED | DATA_CHANGED | TYPE_CHANGED;\n\n\tswitch (ce->ce_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tchanged |= !S_ISREG(st->st_mode) ? TYPE_CHANGED : 0;\n\t\t/* We consider only the owner x bit to be relevant for\n\t\t * \"mode changes\"\n\t\t */\n\t\tif (trust_executable_bit &&\n\t\t    (0100 & (ce->ce_mode ^ st->st_mode)))\n\t\t\tchanged |= MODE_CHANGED;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (!S_ISLNK(st->st_mode) &&\n\t\t    (has_symlinks || !S_ISREG(st->st_mode)))\n\t\t\tchanged |= TYPE_CHANGED;\n\t\tbreak;\n\tcase S_IFGITLINK:\n\t\t/* We ignore most of the st_xxx fields for gitlinks */\n\t\tif (!S_ISDIR(st->st_mode))\n\t\t\tchanged |= TYPE_CHANGED;\n\t\telse if (ce_compare_gitlink(ce))\n\t\t\tchanged |= DATA_CHANGED;\n\t\treturn changed;\n\tdefault:\n\t\tdie(\"internal error: ce_mode is %o\", ce->ce_mode);\n\t}\n\n\tchanged |= match_stat_data(&ce->ce_stat_data, st);\n\n\t/* Racily smudged entry? */\n\tif (!ce->ce_stat_data.sd_size) {\n\t\tif (!is_empty_blob_sha1(ce->sha1))\n\t\t\tchanged |= DATA_CHANGED;\n\t}\n\n\treturn changed;\n}\n\nstatic int is_racy_timestamp(const struct index_state *istate,\n\t\t\t     const struct cache_entry *ce)\n{\n\treturn (!S_ISGITLINK(ce->ce_mode) &&\n\t\tistate->timestamp.sec &&\n#ifdef USE_NSEC\n\t\t /* nanosecond timestamped files can also be racy! */\n\t\t(istate->timestamp.sec < ce->ce_stat_data.sd_mtime.sec ||\n\t\t (istate->timestamp.sec == ce->ce_stat_data.sd_mtime.sec &&\n\t\t  istate->timestamp.nsec <= ce->ce_stat_data.sd_mtime.nsec))\n#else\n\t\tistate->timestamp.sec <= ce->ce_stat_data.sd_mtime.sec\n#endif\n\t\t );\n}\n\nint ie_match_stat(const struct index_state *istate,\n\t\t  const struct cache_entry *ce, struct stat *st,\n\t\t  unsigned int options)\n{\n\tunsigned int changed;\n\tint ignore_valid = options & CE_MATCH_IGNORE_VALID;\n\tint ignore_skip_worktree = options & CE_MATCH_IGNORE_SKIP_WORKTREE;\n\tint assume_racy_is_modified = options & CE_MATCH_RACY_IS_DIRTY;\n\n\t/*\n\t * If it's marked as always valid in the index, it's\n\t * valid whatever the checked-out copy says.\n\t *\n\t * skip-worktree has the same effect with higher precedence\n\t */\n\tif (!ignore_skip_worktree && ce_skip_worktree(ce))\n\t\treturn 0;\n\tif (!ignore_valid && (ce->ce_flags & CE_VALID))\n\t\treturn 0;\n\n\t/*\n\t * Intent-to-add entries have not been added, so the index entry\n\t * by definition never matches what is in the work tree until it\n\t * actually gets added.\n\t */\n\tif (ce->ce_flags & CE_INTENT_TO_ADD)\n\t\treturn DATA_CHANGED | TYPE_CHANGED | MODE_CHANGED;\n\n\tchanged = ce_match_stat_basic(ce, st);\n\n\t/*\n\t * Within 1 second of this sequence:\n\t * \techo xyzzy >file && git-update-index --add file\n\t * running this command:\n\t * \techo frotz >file\n\t * would give a falsely clean cache entry.  The mtime and\n\t * length match the cache, and other stat fields do not change.\n\t *\n\t * We could detect this at update-index time (the cache entry\n\t * being registered/updated records the same time as \"now\")\n\t * and delay the return from git-update-index, but that would\n\t * effectively mean we can make at most one commit per second,\n\t * which is not acceptable.  Instead, we check cache entries\n\t * whose mtime are the same as the index file timestamp more\n\t * carefully than others.\n\t */\n\tif (!changed && is_racy_timestamp(istate, ce)) {\n\t\tif (assume_racy_is_modified)\n\t\t\tchanged |= DATA_CHANGED;\n\t\telse\n\t\t\tchanged |= ce_modified_check_fs(ce, st);\n\t}\n\n\treturn changed;\n}\n\nint ie_modified(const struct index_state *istate,\n\t\tconst struct cache_entry *ce,\n\t\tstruct stat *st, unsigned int options)\n{\n\tint changed, changed_fs;\n\n\tchanged = ie_match_stat(istate, ce, st, options);\n\tif (!changed)\n\t\treturn 0;\n\t/*\n\t * If the mode or type has changed, there's no point in trying\n\t * to refresh the entry - it's not going to match\n\t */\n\tif (changed & (MODE_CHANGED | TYPE_CHANGED))\n\t\treturn changed;\n\n\t/*\n\t * Immediately after read-tree or update-index --cacheinfo,\n\t * the length field is zero, as we have never even read the\n\t * lstat(2) information once, and we cannot trust DATA_CHANGED\n\t * returned by ie_match_stat() which in turn was returned by\n\t * ce_match_stat_basic() to signal that the filesize of the\n\t * blob changed.  We have to actually go to the filesystem to\n\t * see if the contents match, and if so, should answer \"unchanged\".\n\t *\n\t * The logic does not apply to gitlinks, as ce_match_stat_basic()\n\t * already has checked the actual HEAD from the filesystem in the\n\t * subproject.  If ie_match_stat() already said it is different,\n\t * then we know it is.\n\t */\n\tif ((changed & DATA_CHANGED) &&\n\t    (S_ISGITLINK(ce->ce_mode) || ce->ce_stat_data.sd_size != 0))\n\t\treturn changed;\n\n\tchanged_fs = ce_modified_check_fs(ce, st);\n\tif (changed_fs)\n\t\treturn changed | changed_fs;\n\treturn 0;\n}\n\nint base_name_compare(const char *name1, int len1, int mode1,\n\t\t      const char *name2, int len2, int mode2)\n{\n\tunsigned char c1, c2;\n\tint len = len1 < len2 ? len1 : len2;\n\tint cmp;\n\n\tcmp = memcmp(name1, name2, len);\n\tif (cmp)\n\t\treturn cmp;\n\tc1 = name1[len];\n\tc2 = name2[len];\n\tif (!c1 && S_ISDIR(mode1))\n\t\tc1 = '/';\n\tif (!c2 && S_ISDIR(mode2))\n\t\tc2 = '/';\n\treturn (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;\n}\n\n/*\n * df_name_compare() is identical to base_name_compare(), except it\n * compares conflicting directory/file entries as equal. Note that\n * while a directory name compares as equal to a regular file, they\n * then individually compare _differently_ to a filename that has\n * a dot after the basename (because '\\0' < '.' < '/').\n *\n * This is used by routines that want to traverse the git namespace\n * but then handle conflicting entries together when possible.\n */\nint df_name_compare(const char *name1, int len1, int mode1,\n\t\t    const char *name2, int len2, int mode2)\n{\n\tint len = len1 < len2 ? len1 : len2, cmp;\n\tunsigned char c1, c2;\n\n\tcmp = memcmp(name1, name2, len);\n\tif (cmp)\n\t\treturn cmp;\n\t/* Directories and files compare equal (same length, same name) */\n\tif (len1 == len2)\n\t\treturn 0;\n\tc1 = name1[len];\n\tif (!c1 && S_ISDIR(mode1))\n\t\tc1 = '/';\n\tc2 = name2[len];\n\tif (!c2 && S_ISDIR(mode2))\n\t\tc2 = '/';\n\tif (c1 == '/' && !c2)\n\t\treturn 0;\n\tif (c2 == '/' && !c1)\n\t\treturn 0;\n\treturn c1 - c2;\n}\n\nint cache_name_stage_compare(const char *name1, int len1, int stage1, const char *name2, int len2, int stage2)\n{\n\tint len = len1 < len2 ? len1 : len2;\n\tint cmp;\n\n\tcmp = memcmp(name1, name2, len);\n\tif (cmp)\n\t\treturn cmp;\n\tif (len1 < len2)\n\t\treturn -1;\n\tif (len1 > len2)\n\t\treturn 1;\n\n\tif (stage1 < stage2)\n\t\treturn -1;\n\tif (stage1 > stage2)\n\t\treturn 1;\n\treturn 0;\n}\n\nint cache_name_compare(const char *name1, int len1, const char *name2, int len2)\n{\n\treturn cache_name_stage_compare(name1, len1, 0, name2, len2, 0);\n}\n\nstatic int index_name_stage_pos(const struct index_state *istate, const char *name, int namelen, int stage)\n{\n\tint first, last;\n\n\tfirst = 0;\n\tlast = istate->cache_nr;\n\twhile (last > first) {\n\t\tint next = (last + first) >> 1;\n\t\tstruct cache_entry *ce = istate->cache[next];\n\t\tint cmp = cache_name_stage_compare(name, namelen, stage, ce->name, ce_namelen(ce), ce_stage(ce));\n\t\tif (!cmp)\n\t\t\treturn next;\n\t\tif (cmp < 0) {\n\t\t\tlast = next;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst = next+1;\n\t}\n\treturn -first-1;\n}\n\nint index_name_pos(const struct index_state *istate, const char *name, int namelen)\n{\n\treturn index_name_stage_pos(istate, name, namelen, 0);\n}\n\n/* Remove entry, return true if there are more entries to go.. */\nint remove_index_entry_at(struct index_state *istate, int pos)\n{\n\tstruct cache_entry *ce = istate->cache[pos];\n\n\trecord_resolve_undo(istate, ce);\n\tremove_name_hash(istate, ce);\n\tistate->cache_changed = 1;\n\tistate->cache_nr--;\n\tif (pos >= istate->cache_nr)\n\t\treturn 0;\n\tmemmove(istate->cache + pos,\n\t\tistate->cache + pos + 1,\n\t\t(istate->cache_nr - pos) * sizeof(struct cache_entry *));\n\treturn 1;\n}\n\n/*\n * Remove all cache entries marked for removal, that is where\n * CE_REMOVE is set in ce_flags.  This is much more effective than\n * calling remove_index_entry_at() for each entry to be removed.\n */\nvoid remove_marked_cache_entries(struct index_state *istate)\n{\n\tstruct cache_entry **ce_array = istate->cache;\n\tunsigned int i, j;\n\n\tfor (i = j = 0; i < istate->cache_nr; i++) {\n\t\tif (ce_array[i]->ce_flags & CE_REMOVE)\n\t\t\tremove_name_hash(istate, ce_array[i]);\n\t\telse\n\t\t\tce_array[j++] = ce_array[i];\n\t}\n\tistate->cache_changed = 1;\n\tistate->cache_nr = j;\n}\n\nint remove_file_from_index(struct index_state *istate, const char *path)\n{\n\tint pos = index_name_pos(istate, path, strlen(path));\n\tif (pos < 0)\n\t\tpos = -pos-1;\n\tcache_tree_invalidate_path(istate->cache_tree, path);\n\twhile (pos < istate->cache_nr && !strcmp(istate->cache[pos]->name, path))\n\t\tremove_index_entry_at(istate, pos);\n\treturn 0;\n}\n\nstatic int compare_name(struct cache_entry *ce, const char *path, int namelen)\n{\n\treturn namelen != ce_namelen(ce) || memcmp(path, ce->name, namelen);\n}\n\nstatic int index_name_pos_also_unmerged(struct index_state *istate,\n\tconst char *path, int namelen)\n{\n\tint pos = index_name_pos(istate, path, namelen);\n\tstruct cache_entry *ce;\n\n\tif (pos >= 0)\n\t\treturn pos;\n\n\t/* maybe unmerged? */\n\tpos = -1 - pos;\n\tif (pos >= istate->cache_nr ||\n\t\t\tcompare_name((ce = istate->cache[pos]), path, namelen))\n\t\treturn -1;\n\n\t/* order of preference: stage 2, 1, 3 */\n\tif (ce_stage(ce) == 1 && pos + 1 < istate->cache_nr &&\n\t\t\tce_stage((ce = istate->cache[pos + 1])) == 2 &&\n\t\t\t!compare_name(ce, path, namelen))\n\t\tpos++;\n\treturn pos;\n}\n\nstatic int different_name(struct cache_entry *ce, struct cache_entry *alias)\n{\n\tint len = ce_namelen(ce);\n\treturn ce_namelen(alias) != len || memcmp(ce->name, alias->name, len);\n}\n\n/*\n * If we add a filename that aliases in the cache, we will use the\n * name that we already have - but we don't want to update the same\n * alias twice, because that implies that there were actually two\n * different files with aliasing names!\n *\n * So we use the CE_ADDED flag to verify that the alias was an old\n * one before we accept it as\n */\nstatic struct cache_entry *create_alias_ce(struct cache_entry *ce, struct cache_entry *alias)\n{\n\tint len;\n\tstruct cache_entry *new;\n\n\tif (alias->ce_flags & CE_ADDED)\n\t\tdie(\"Will not add file alias '%s' ('%s' already exists in index)\", ce->name, alias->name);\n\n\t/* Ok, create the new entry using the name of the existing alias */\n\tlen = ce_namelen(alias);\n\tnew = xcalloc(1, cache_entry_size(len));\n\tmemcpy(new->name, alias->name, len);\n\tcopy_cache_entry(new, ce);\n\tfree(ce);\n\treturn new;\n}\n\nstatic void record_intent_to_add(struct cache_entry *ce)\n{\n\tunsigned char sha1[20];\n\tif (write_sha1_file(\"\", 0, blob_type, sha1))\n\t\tdie(\"cannot create an empty blob in the object database\");\n\thashcpy(ce->sha1, sha1);\n}\n\nint add_to_index(struct index_state *istate, const char *path, struct stat *st, int flags)\n{\n\tint size, namelen, was_same;\n\tmode_t st_mode = st->st_mode;\n\tstruct cache_entry *ce, *alias;\n\tunsigned ce_option = CE_MATCH_IGNORE_VALID|CE_MATCH_IGNORE_SKIP_WORKTREE|CE_MATCH_RACY_IS_DIRTY;\n\tint verbose = flags & (ADD_CACHE_VERBOSE | ADD_CACHE_PRETEND);\n\tint pretend = flags & ADD_CACHE_PRETEND;\n\tint intent_only = flags & ADD_CACHE_INTENT;\n\tint add_option = (ADD_CACHE_OK_TO_ADD|ADD_CACHE_OK_TO_REPLACE|\n\t\t\t  (intent_only ? ADD_CACHE_NEW_ONLY : 0));\n\n\tif (!S_ISREG(st_mode) && !S_ISLNK(st_mode) && !S_ISDIR(st_mode))\n\t\treturn error(\"%s: can only add regular files, symbolic links or git-directories\", path);\n\n\tnamelen = strlen(path);\n\tif (S_ISDIR(st_mode)) {\n\t\twhile (namelen && path[namelen-1] == '/')\n\t\t\tnamelen--;\n\t}\n\tsize = cache_entry_size(namelen);\n\tce = xcalloc(1, size);\n\tmemcpy(ce->name, path, namelen);\n\tce->ce_namelen = namelen;\n\tif (!intent_only)\n\t\tfill_stat_cache_info(ce, st);\n\telse\n\t\tce->ce_flags |= CE_INTENT_TO_ADD;\n\n\tif (trust_executable_bit && has_symlinks)\n\t\tce->ce_mode = create_ce_mode(st_mode);\n\telse {\n\t\t/* If there is an existing entry, pick the mode bits and type\n\t\t * from it, otherwise assume unexecutable regular file.\n\t\t */\n\t\tstruct cache_entry *ent;\n\t\tint pos = index_name_pos_also_unmerged(istate, path, namelen);\n\n\t\tent = (0 <= pos) ? istate->cache[pos] : NULL;\n\t\tce->ce_mode = ce_mode_from_stat(ent, st_mode);\n\t}\n\n\t/* When core.ignorecase=true, determine if a directory of the same name but differing\n\t * case already exists within the Git repository.  If it does, ensure the directory\n\t * case of the file being added to the repository matches (is folded into) the existing\n\t * entry's directory case.\n\t */\n\tif (ignore_case) {\n\t\tconst char *startPtr = ce->name;\n\t\tconst char *ptr = startPtr;\n\t\twhile (*ptr) {\n\t\t\twhile (*ptr && *ptr != '/')\n\t\t\t\t++ptr;\n\t\t\tif (*ptr == '/') {\n\t\t\t\tstruct cache_entry *foundce;\n\t\t\t\t++ptr;\n\t\t\t\tfoundce = index_dir_exists(istate, ce->name, ptr - ce->name - 1);\n\t\t\t\tif (foundce) {\n\t\t\t\t\tmemcpy((void *)startPtr, foundce->name + (startPtr - ce->name), ptr - startPtr);\n\t\t\t\t\tstartPtr = ptr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\talias = index_file_exists(istate, ce->name, ce_namelen(ce), ignore_case);\n\tif (alias && !ce_stage(alias) && !ie_match_stat(istate, alias, st, ce_option)) {\n\t\t/* Nothing changed, really */\n\t\tfree(ce);\n\t\tif (!S_ISGITLINK(alias->ce_mode))\n\t\t\tce_mark_uptodate(alias);\n\t\talias->ce_flags |= CE_ADDED;\n\t\treturn 0;\n\t}\n\tif (!intent_only) {\n\t\tif (index_path(ce->sha1, path, st, HASH_WRITE_OBJECT))\n\t\t\treturn error(\"unable to index file %s\", path);\n\t} else\n\t\trecord_intent_to_add(ce);\n\n\tif (ignore_case && alias && different_name(ce, alias))\n\t\tce = create_alias_ce(ce, alias);\n\tce->ce_flags |= CE_ADDED;\n\n\t/* It was suspected to be racily clean, but it turns out to be Ok */\n\twas_same = (alias &&\n\t\t    !ce_stage(alias) &&\n\t\t    !hashcmp(alias->sha1, ce->sha1) &&\n\t\t    ce->ce_mode == alias->ce_mode);\n\n\tif (pretend)\n\t\t;\n\telse if (add_index_entry(istate, ce, add_option))\n\t\treturn error(\"unable to add %s to index\",path);\n\tif (verbose && !was_same)\n\t\tprintf(\"add '%s'\\n\", path);\n\treturn 0;\n}\n\nint add_file_to_index(struct index_state *istate, const char *path, int flags)\n{\n\tstruct stat st;\n\tif (lstat(path, &st))\n\t\tdie_errno(\"unable to stat '%s'\", path);\n\treturn add_to_index(istate, path, &st, flags);\n}\n\nstruct cache_entry *make_cache_entry(unsigned int mode,\n\t\tconst unsigned char *sha1, const char *path, int stage,\n\t\tint refresh)\n{\n\tint size, len;\n\tstruct cache_entry *ce;\n\n\tif (!verify_path(path)) {\n\t\terror(\"Invalid path '%s'\", path);\n\t\treturn NULL;\n\t}\n\n\tlen = strlen(path);\n\tsize = cache_entry_size(len);\n\tce = xcalloc(1, size);\n\n\thashcpy(ce->sha1, sha1);\n\tmemcpy(ce->name, path, len);\n\tce->ce_flags = create_ce_flags(stage);\n\tce->ce_namelen = len;\n\tce->ce_mode = create_ce_mode(mode);\n\n\tif (refresh)\n\t\treturn refresh_cache_entry(ce, 0);\n\n\treturn ce;\n}\n\nint ce_same_name(const struct cache_entry *a, const struct cache_entry *b)\n{\n\tint len = ce_namelen(a);\n\treturn ce_namelen(b) == len && !memcmp(a->name, b->name, len);\n}\n\nint ce_path_match(const struct cache_entry *ce, const struct pathspec *pathspec)\n{\n\treturn match_pathspec_depth(pathspec, ce->name, ce_namelen(ce), 0, NULL);\n}\n\n/*\n * We fundamentally don't like some paths: we don't want\n * dot or dot-dot anywhere, and for obvious reasons don't\n * want to recurse into \".git\" either.\n *\n * Also, we don't want double slashes or slashes at the\n * end that can make pathnames ambiguous.\n */\nstatic int verify_dotfile(const char *rest)\n{\n\t/*\n\t * The first character was '.', but that\n\t * has already been discarded, we now test\n\t * the rest.\n\t */\n\n\t/* \".\" is not allowed */\n\tif (*rest == '\\0' || is_dir_sep(*rest))\n\t\treturn 0;\n\n\tswitch (*rest) {\n\t/*\n\t * \".git\" followed by  NUL or slash is bad. This\n\t * shares the path end test with the \"..\" case.\n\t */\n\tcase 'g':\n\t\tif (rest[1] != 'i')\n\t\t\tbreak;\n\t\tif (rest[2] != 't')\n\t\t\tbreak;\n\t\trest += 2;\n\t/* fallthrough */\n\tcase '.':\n\t\tif (rest[1] == '\\0' || is_dir_sep(rest[1]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint verify_path(const char *path)\n{\n\tchar c;\n\n\tif (has_dos_drive_prefix(path))\n\t\treturn 0;\n\n\tgoto inside;\n\tfor (;;) {\n\t\tif (!c)\n\t\t\treturn 1;\n\t\tif (is_dir_sep(c)) {\ninside:\n\t\t\tc = *path++;\n\t\t\tif ((c == '.' && !verify_dotfile(path)) ||\n\t\t\t    is_dir_sep(c) || c == '\\0')\n\t\t\t\treturn 0;\n\t\t}\n\t\tc = *path++;\n\t}\n}\n\n/*\n * Do we have another file that has the beginning components being a\n * proper superset of the name we're trying to add?\n */\nstatic int has_file_name(struct index_state *istate,\n\t\t\t const struct cache_entry *ce, int pos, int ok_to_replace)\n{\n\tint retval = 0;\n\tint len = ce_namelen(ce);\n\tint stage = ce_stage(ce);\n\tconst char *name = ce->name;\n\n\twhile (pos < istate->cache_nr) {\n\t\tstruct cache_entry *p = istate->cache[pos++];\n\n\t\tif (len >= ce_namelen(p))\n\t\t\tbreak;\n\t\tif (memcmp(name, p->name, len))\n\t\t\tbreak;\n\t\tif (ce_stage(p) != stage)\n\t\t\tcontinue;\n\t\tif (p->name[len] != '/')\n\t\t\tcontinue;\n\t\tif (p->ce_flags & CE_REMOVE)\n\t\t\tcontinue;\n\t\tretval = -1;\n\t\tif (!ok_to_replace)\n\t\t\tbreak;\n\t\tremove_index_entry_at(istate, --pos);\n\t}\n\treturn retval;\n}\n\n/*\n * Do we have another file with a pathname that is a proper\n * subset of the name we're trying to add?\n */\nstatic int has_dir_name(struct index_state *istate,\n\t\t\tconst struct cache_entry *ce, int pos, int ok_to_replace)\n{\n\tint retval = 0;\n\tint stage = ce_stage(ce);\n\tconst char *name = ce->name;\n\tconst char *slash = name + ce_namelen(ce);\n\n\tfor (;;) {\n\t\tint len;\n\n\t\tfor (;;) {\n\t\t\tif (*--slash == '/')\n\t\t\t\tbreak;\n\t\t\tif (slash <= ce->name)\n\t\t\t\treturn retval;\n\t\t}\n\t\tlen = slash - name;\n\n\t\tpos = index_name_stage_pos(istate, name, len, stage);\n\t\tif (pos >= 0) {\n\t\t\t/*\n\t\t\t * Found one, but not so fast.  This could\n\t\t\t * be a marker that says \"I was here, but\n\t\t\t * I am being removed\".  Such an entry is\n\t\t\t * not a part of the resulting tree, and\n\t\t\t * it is Ok to have a directory at the same\n\t\t\t * path.\n\t\t\t */\n\t\t\tif (!(istate->cache[pos]->ce_flags & CE_REMOVE)) {\n\t\t\t\tretval = -1;\n\t\t\t\tif (!ok_to_replace)\n\t\t\t\t\tbreak;\n\t\t\t\tremove_index_entry_at(istate, pos);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tpos = -pos-1;\n\n\t\t/*\n\t\t * Trivial optimization: if we find an entry that\n\t\t * already matches the sub-directory, then we know\n\t\t * we're ok, and we can exit.\n\t\t */\n\t\twhile (pos < istate->cache_nr) {\n\t\t\tstruct cache_entry *p = istate->cache[pos];\n\t\t\tif ((ce_namelen(p) <= len) ||\n\t\t\t    (p->name[len] != '/') ||\n\t\t\t    memcmp(p->name, name, len))\n\t\t\t\tbreak; /* not our subdirectory */\n\t\t\tif (ce_stage(p) == stage && !(p->ce_flags & CE_REMOVE))\n\t\t\t\t/*\n\t\t\t\t * p is at the same stage as our entry, and\n\t\t\t\t * is a subdirectory of what we are looking\n\t\t\t\t * at, so we cannot have conflicts at our\n\t\t\t\t * level or anything shorter.\n\t\t\t\t */\n\t\t\t\treturn retval;\n\t\t\tpos++;\n\t\t}\n\t}\n\treturn retval;\n}\n\n/* We may be in a situation where we already have path/file and path\n * is being added, or we already have path and path/file is being\n * added.  Either one would result in a nonsense tree that has path\n * twice when git-write-tree tries to write it out.  Prevent it.\n *\n * If ok-to-replace is specified, we remove the conflicting entries\n * from the cache so the caller should recompute the insert position.\n * When this happens, we return non-zero.\n */\nstatic int check_file_directory_conflict(struct index_state *istate,\n\t\t\t\t\t const struct cache_entry *ce,\n\t\t\t\t\t int pos, int ok_to_replace)\n{\n\tint retval;\n\n\t/*\n\t * When ce is an \"I am going away\" entry, we allow it to be added\n\t */\n\tif (ce->ce_flags & CE_REMOVE)\n\t\treturn 0;\n\n\t/*\n\t * We check if the path is a sub-path of a subsequent pathname\n\t * first, since removing those will not change the position\n\t * in the array.\n\t */\n\tretval = has_file_name(istate, ce, pos, ok_to_replace);\n\n\t/*\n\t * Then check if the path might have a clashing sub-directory\n\t * before it.\n\t */\n\treturn retval + has_dir_name(istate, ce, pos, ok_to_replace);\n}\n\nstatic int add_index_entry_with_check(struct index_state *istate, struct cache_entry *ce, int option)\n{\n\tint pos;\n\tint ok_to_add = option & ADD_CACHE_OK_TO_ADD;\n\tint ok_to_replace = option & ADD_CACHE_OK_TO_REPLACE;\n\tint skip_df_check = option & ADD_CACHE_SKIP_DFCHECK;\n\tint new_only = option & ADD_CACHE_NEW_ONLY;\n\n\tcache_tree_invalidate_path(istate->cache_tree, ce->name);\n\tpos = index_name_stage_pos(istate, ce->name, ce_namelen(ce), ce_stage(ce));\n\n\t/* existing match? Just replace it. */\n\tif (pos >= 0) {\n\t\tif (!new_only)\n\t\t\treplace_index_entry(istate, pos, ce);\n\t\treturn 0;\n\t}\n\tpos = -pos-1;\n\n\t/*\n\t * Inserting a merged entry (\"stage 0\") into the index\n\t * will always replace all non-merged entries..\n\t */\n\tif (pos < istate->cache_nr && ce_stage(ce) == 0) {\n\t\twhile (ce_same_name(istate->cache[pos], ce)) {\n\t\t\tok_to_add = 1;\n\t\t\tif (!remove_index_entry_at(istate, pos))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ok_to_add)\n\t\treturn -1;\n\tif (!verify_path(ce->name))\n\t\treturn error(\"Invalid path '%s'\", ce->name);\n\n\tif (!skip_df_check &&\n\t    check_file_directory_conflict(istate, ce, pos, ok_to_replace)) {\n\t\tif (!ok_to_replace)\n\t\t\treturn error(\"'%s' appears as both a file and as a directory\",\n\t\t\t\t     ce->name);\n\t\tpos = index_name_stage_pos(istate, ce->name, ce_namelen(ce), ce_stage(ce));\n\t\tpos = -pos-1;\n\t}\n\treturn pos + 1;\n}\n\nint add_index_entry(struct index_state *istate, struct cache_entry *ce, int option)\n{\n\tint pos;\n\n\tif (option & ADD_CACHE_JUST_APPEND)\n\t\tpos = istate->cache_nr;\n\telse {\n\t\tint ret;\n\t\tret = add_index_entry_with_check(istate, ce, option);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t\tpos = ret - 1;\n\t}\n\n\t/* Make sure the array is big enough .. */\n\tif (istate->cache_nr == istate->cache_alloc) {\n\t\tistate->cache_alloc = alloc_nr(istate->cache_alloc);\n\t\tistate->cache = xrealloc(istate->cache,\n\t\t\t\t\tistate->cache_alloc * sizeof(*istate->cache));\n\t}\n\n\t/* Add it in.. */\n\tistate->cache_nr++;\n\tif (istate->cache_nr > pos + 1)\n\t\tmemmove(istate->cache + pos + 1,\n\t\t\tistate->cache + pos,\n\t\t\t(istate->cache_nr - pos - 1) * sizeof(ce));\n\tset_index_entry(istate, pos, ce);\n\tistate->cache_changed = 1;\n\treturn 0;\n}\n\n/*\n * \"refresh\" does not calculate a new sha1 file or bring the\n * cache up-to-date for mode/content changes. But what it\n * _does_ do is to \"re-match\" the stat information of a file\n * with the cache, so that you can refresh the cache for a\n * file that hasn't been changed but where the stat entry is\n * out of date.\n *\n * For example, you'd want to do this after doing a \"git-read-tree\",\n * to link up the stat cache details with the proper files.\n */\nstatic struct cache_entry *refresh_cache_ent(struct index_state *istate,\n\t\t\t\t\t     struct cache_entry *ce,\n\t\t\t\t\t     unsigned int options, int *err,\n\t\t\t\t\t     int *changed_ret)\n{\n\tstruct stat st;\n\tstruct cache_entry *updated;\n\tint changed, size;\n\tint ignore_valid = options & CE_MATCH_IGNORE_VALID;\n\tint ignore_skip_worktree = options & CE_MATCH_IGNORE_SKIP_WORKTREE;\n\n\tif (ce_uptodate(ce))\n\t\treturn ce;\n\n\t/*\n\t * CE_VALID or CE_SKIP_WORKTREE means the user promised us\n\t * that the change to the work tree does not matter and told\n\t * us not to worry.\n\t */\n\tif (!ignore_skip_worktree && ce_skip_worktree(ce)) {\n\t\tce_mark_uptodate(ce);\n\t\treturn ce;\n\t}\n\tif (!ignore_valid && (ce->ce_flags & CE_VALID)) {\n\t\tce_mark_uptodate(ce);\n\t\treturn ce;\n\t}\n\n\tif (lstat(ce->name, &st) < 0) {\n\t\tif (err)\n\t\t\t*err = errno;\n\t\treturn NULL;\n\t}\n\n\tchanged = ie_match_stat(istate, ce, &st, options);\n\tif (changed_ret)\n\t\t*changed_ret = changed;\n\tif (!changed) {\n\t\t/*\n\t\t * The path is unchanged.  If we were told to ignore\n\t\t * valid bit, then we did the actual stat check and\n\t\t * found that the entry is unmodified.  If the entry\n\t\t * is not marked VALID, this is the place to mark it\n\t\t * valid again, under \"assume unchanged\" mode.\n\t\t */\n\t\tif (ignore_valid && assume_unchanged &&\n\t\t    !(ce->ce_flags & CE_VALID))\n\t\t\t; /* mark this one VALID again */\n\t\telse {\n\t\t\t/*\n\t\t\t * We do not mark the index itself \"modified\"\n\t\t\t * because CE_UPTODATE flag is in-core only;\n\t\t\t * we are not going to write this change out.\n\t\t\t */\n\t\t\tif (!S_ISGITLINK(ce->ce_mode))\n\t\t\t\tce_mark_uptodate(ce);\n\t\t\treturn ce;\n\t\t}\n\t}\n\n\tif (ie_modified(istate, ce, &st, options)) {\n\t\tif (err)\n\t\t\t*err = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tsize = ce_size(ce);\n\tupdated = xmalloc(size);\n\tmemcpy(updated, ce, size);\n\tfill_stat_cache_info(updated, &st);\n\t/*\n\t * If ignore_valid is not set, we should leave CE_VALID bit\n\t * alone.  Otherwise, paths marked with --no-assume-unchanged\n\t * (i.e. things to be edited) will reacquire CE_VALID bit\n\t * automatically, which is not really what we want.\n\t */\n\tif (!ignore_valid && assume_unchanged &&\n\t    !(ce->ce_flags & CE_VALID))\n\t\tupdated->ce_flags &= ~CE_VALID;\n\n\treturn updated;\n}\n\nstatic void show_file(const char * fmt, const char * name, int in_porcelain,\n\t\t      int * first, const char *header_msg)\n{\n\tif (in_porcelain && *first && header_msg) {\n\t\tprintf(\"%s\\n\", header_msg);\n\t\t*first = 0;\n\t}\n\tprintf(fmt, name);\n}\n\nint refresh_index(struct index_state *istate, unsigned int flags,\n\t\t  const struct pathspec *pathspec,\n\t\t  char *seen, const char *header_msg)\n{\n\tint i;\n\tint has_errors = 0;\n\tint really = (flags & REFRESH_REALLY) != 0;\n\tint allow_unmerged = (flags & REFRESH_UNMERGED) != 0;\n\tint quiet = (flags & REFRESH_QUIET) != 0;\n\tint not_new = (flags & REFRESH_IGNORE_MISSING) != 0;\n\tint ignore_submodules = (flags & REFRESH_IGNORE_SUBMODULES) != 0;\n\tint first = 1;\n\tint in_porcelain = (flags & REFRESH_IN_PORCELAIN);\n\tunsigned int options = really ? CE_MATCH_IGNORE_VALID : 0;\n\tconst char *modified_fmt;\n\tconst char *deleted_fmt;\n\tconst char *typechange_fmt;\n\tconst char *added_fmt;\n\tconst char *unmerged_fmt;\n\n\tmodified_fmt = (in_porcelain ? \"M\\t%s\\n\" : \"%s: needs update\\n\");\n\tdeleted_fmt = (in_porcelain ? \"D\\t%s\\n\" : \"%s: needs update\\n\");\n\ttypechange_fmt = (in_porcelain ? \"T\\t%s\\n\" : \"%s needs update\\n\");\n\tadded_fmt = (in_porcelain ? \"A\\t%s\\n\" : \"%s needs update\\n\");\n\tunmerged_fmt = (in_porcelain ? \"U\\t%s\\n\" : \"%s: needs merge\\n\");\n\tfor (i = 0; i < istate->cache_nr; i++) {\n\t\tstruct cache_entry *ce, *new;\n\t\tint cache_errno = 0;\n\t\tint changed = 0;\n\t\tint filtered = 0;\n\n\t\tce = istate->cache[i];\n\t\tif (ignore_submodules && S_ISGITLINK(ce->ce_mode))\n\t\t\tcontinue;\n\n\t\tif (pathspec &&\n\t\t    !match_pathspec_depth(pathspec, ce->name, ce_namelen(ce), 0, seen))\n\t\t\tfiltered = 1;\n\n\t\tif (ce_stage(ce)) {\n\t\t\twhile ((i < istate->cache_nr) &&\n\t\t\t       ! strcmp(istate->cache[i]->name, ce->name))\n\t\t\t\ti++;\n\t\t\ti--;\n\t\t\tif (allow_unmerged)\n\t\t\t\tcontinue;\n\t\t\tif (!filtered)\n\t\t\t\tshow_file(unmerged_fmt, ce->name, in_porcelain,\n\t\t\t\t\t  &first, header_msg);\n\t\t\thas_errors = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filtered)\n\t\t\tcontinue;\n\n\t\tnew = refresh_cache_ent(istate, ce, options, &cache_errno, &changed);\n\t\tif (new == ce)\n\t\t\tcontinue;\n\t\tif (!new) {\n\t\t\tconst char *fmt;\n\n\t\t\tif (not_new && cache_errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\tif (really && cache_errno == EINVAL) {\n\t\t\t\t/* If we are doing --really-refresh that\n\t\t\t\t * means the index is not valid anymore.\n\t\t\t\t */\n\t\t\t\tce->ce_flags &= ~CE_VALID;\n\t\t\t\tistate->cache_changed = 1;\n\t\t\t}\n\t\t\tif (quiet)\n\t\t\t\tcontinue;\n\n\t\t\tif (cache_errno == ENOENT)\n\t\t\t\tfmt = deleted_fmt;\n\t\t\telse if (ce->ce_flags & CE_INTENT_TO_ADD)\n\t\t\t\tfmt = added_fmt; /* must be before other checks */\n\t\t\telse if (changed & TYPE_CHANGED)\n\t\t\t\tfmt = typechange_fmt;\n\t\t\telse\n\t\t\t\tfmt = modified_fmt;\n\t\t\tshow_file(fmt,\n\t\t\t\t  ce->name, in_porcelain, &first, header_msg);\n\t\t\thas_errors = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\treplace_index_entry(istate, i, new);\n\t}\n\treturn has_errors;\n}\n\nstatic struct cache_entry *refresh_cache_entry(struct cache_entry *ce, int really)\n{\n\treturn refresh_cache_ent(&the_index, ce, really, NULL, NULL);\n}\n\n\n/*****************************************************************\n * Index File I/O\n *****************************************************************/\n\n#define INDEX_FORMAT_DEFAULT 3\n\n/*\n * dev/ino/uid/gid/size are also just tracked to the low 32 bits\n * Again - this is just a (very strong in practice) heuristic that\n * the inode hasn't changed.\n *\n * We save the fields in big-endian order to allow using the\n * index file over NFS transparently.\n */\nstruct ondisk_cache_entry {\n\tstruct cache_time ctime;\n\tstruct cache_time mtime;\n\tuint32_t dev;\n\tuint32_t ino;\n\tuint32_t mode;\n\tuint32_t uid;\n\tuint32_t gid;\n\tuint32_t size;\n\tunsigned char sha1[20];\n\tuint16_t flags;\n\tchar name[FLEX_ARRAY]; /* more */\n};\n\n/*\n * This struct is used when CE_EXTENDED bit is 1\n * The struct must match ondisk_cache_entry exactly from\n * ctime till flags\n */\nstruct ondisk_cache_entry_extended {\n\tstruct cache_time ctime;\n\tstruct cache_time mtime;\n\tuint32_t dev;\n\tuint32_t ino;\n\tuint32_t mode;\n\tuint32_t uid;\n\tuint32_t gid;\n\tuint32_t size;\n\tunsigned char sha1[20];\n\tuint16_t flags;\n\tuint16_t flags2;\n\tchar name[FLEX_ARRAY]; /* more */\n};\n\n/* These are only used for v3 or lower */\n#define align_flex_name(STRUCT,len) ((offsetof(struct STRUCT,name) + (len) + 8) & ~7)\n#define ondisk_cache_entry_size(len) align_flex_name(ondisk_cache_entry,len)\n#define ondisk_cache_entry_extended_size(len) align_flex_name(ondisk_cache_entry_extended,len)\n#define ondisk_ce_size(ce) (((ce)->ce_flags & CE_EXTENDED) ? \\\n\t\t\t    ondisk_cache_entry_extended_size(ce_namelen(ce)) : \\\n\t\t\t    ondisk_cache_entry_size(ce_namelen(ce)))\n\nstatic int verify_hdr(struct cache_header *hdr, unsigned long size)\n{\n\tgit_SHA_CTX c;\n\tunsigned char sha1[20];\n\tint hdr_version;\n\n\tif (hdr->hdr_signature != htonl(CACHE_SIGNATURE))\n\t\treturn error(\"bad signature\");\n\thdr_version = ntohl(hdr->hdr_version);\n\tif (hdr_version < INDEX_FORMAT_LB || INDEX_FORMAT_UB < hdr_version)\n\t\treturn error(\"bad index version %d\", hdr_version);\n\tgit_SHA1_Init(&c);\n\tgit_SHA1_Update(&c, hdr, size - 20);\n\tgit_SHA1_Final(sha1, &c);\n\tif (hashcmp(sha1, (unsigned char *)hdr + size - 20))\n\t\treturn error(\"bad index file sha1 signature\");\n\treturn 0;\n}\n\nstatic int read_index_extension(struct index_state *istate,\n\t\t\t\tconst char *ext, void *data, unsigned long sz)\n{\n\tswitch (CACHE_EXT(ext)) {\n\tcase CACHE_EXT_TREE:\n\t\tistate->cache_tree = cache_tree_read(data, sz);\n\t\tbreak;\n\tcase CACHE_EXT_RESOLVE_UNDO:\n\t\tistate->resolve_undo = resolve_undo_read(data, sz);\n\t\tbreak;\n\tdefault:\n\t\tif (*ext < 'A' || 'Z' < *ext)\n\t\t\treturn error(\"index uses %.4s extension, which we do not understand\",\n\t\t\t\t     ext);\n\t\tfprintf(stderr, \"ignoring %.4s extension\\n\", ext);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint read_index(struct index_state *istate)\n{\n\treturn read_index_from(istate, get_index_file());\n}\n\n#ifndef NEEDS_ALIGNED_ACCESS\n#define ntoh_s(var) ntohs(var)\n#define ntoh_l(var) ntohl(var)\n#else\nstatic inline uint16_t ntoh_s_force_align(void *p)\n{\n\tuint16_t x;\n\tmemcpy(&x, p, sizeof(x));\n\treturn ntohs(x);\n}\nstatic inline uint32_t ntoh_l_force_align(void *p)\n{\n\tuint32_t x;\n\tmemcpy(&x, p, sizeof(x));\n\treturn ntohl(x);\n}\n#define ntoh_s(var) ntoh_s_force_align(&(var))\n#define ntoh_l(var) ntoh_l_force_align(&(var))\n#endif\n\nstatic struct cache_entry *cache_entry_from_ondisk(struct ondisk_cache_entry *ondisk,\n\t\t\t\t\t\t   unsigned int flags,\n\t\t\t\t\t\t   const char *name,\n\t\t\t\t\t\t   size_t len)\n{\n\tstruct cache_entry *ce = xmalloc(cache_entry_size(len));\n\n\tce->ce_stat_data.sd_ctime.sec = ntoh_l(ondisk->ctime.sec);\n\tce->ce_stat_data.sd_mtime.sec = ntoh_l(ondisk->mtime.sec);\n\tce->ce_stat_data.sd_ctime.nsec = ntoh_l(ondisk->ctime.nsec);\n\tce->ce_stat_data.sd_mtime.nsec = ntoh_l(ondisk->mtime.nsec);\n\tce->ce_stat_data.sd_dev   = ntoh_l(ondisk->dev);\n\tce->ce_stat_data.sd_ino   = ntoh_l(ondisk->ino);\n\tce->ce_mode  = ntoh_l(ondisk->mode);\n\tce->ce_stat_data.sd_uid   = ntoh_l(ondisk->uid);\n\tce->ce_stat_data.sd_gid   = ntoh_l(ondisk->gid);\n\tce->ce_stat_data.sd_size  = ntoh_l(ondisk->size);\n\tce->ce_flags = flags & ~CE_NAMEMASK;\n\tce->ce_namelen = len;\n\thashcpy(ce->sha1, ondisk->sha1);\n\tmemcpy(ce->name, name, len);\n\tce->name[len] = '\\0';\n\treturn ce;\n}\n\n/*\n * Adjacent cache entries tend to share the leading paths, so it makes\n * sense to only store the differences in later entries.  In the v4\n * on-disk format of the index, each on-disk cache entry stores the\n * number of bytes to be stripped from the end of the previous name,\n * and the bytes to append to the result, to come up with its name.\n */\nstatic unsigned long expand_name_field(struct strbuf *name, const char *cp_)\n{\n\tconst unsigned char *ep, *cp = (const unsigned char *)cp_;\n\tsize_t len = decode_varint(&cp);\n\n\tif (name->len < len)\n\t\tdie(\"malformed name field in the index\");\n\tstrbuf_remove(name, name->len - len, len);\n\tfor (ep = cp; *ep; ep++)\n\t\t; /* find the end */\n\tstrbuf_add(name, cp, ep - cp);\n\treturn (const char *)ep + 1 - cp_;\n}\n\nstatic struct cache_entry *create_from_disk(struct ondisk_cache_entry *ondisk,\n\t\t\t\t\t    unsigned long *ent_size,\n\t\t\t\t\t    struct strbuf *previous_name)\n{\n\tstruct cache_entry *ce;\n\tsize_t len;\n\tconst char *name;\n\tunsigned int flags;\n\n\t/* On-disk flags are just 16 bits */\n\tflags = ntoh_s(ondisk->flags);\n\tlen = flags & CE_NAMEMASK;\n\n\tif (flags & CE_EXTENDED) {\n\t\tstruct ondisk_cache_entry_extended *ondisk2;\n\t\tint extended_flags;\n\t\tondisk2 = (struct ondisk_cache_entry_extended *)ondisk;\n\t\textended_flags = ntoh_s(ondisk2->flags2) << 16;\n\t\t/* We do not yet understand any bit out of CE_EXTENDED_FLAGS */\n\t\tif (extended_flags & ~CE_EXTENDED_FLAGS)\n\t\t\tdie(\"Unknown index entry format %08x\", extended_flags);\n\t\tflags |= extended_flags;\n\t\tname = ondisk2->name;\n\t}\n\telse\n\t\tname = ondisk->name;\n\n\tif (!previous_name) {\n\t\t/* v3 and earlier */\n\t\tif (len == CE_NAMEMASK)\n\t\t\tlen = strlen(name);\n\t\tce = cache_entry_from_ondisk(ondisk, flags, name, len);\n\n\t\t*ent_size = ondisk_ce_size(ce);\n\t} else {\n\t\tunsigned long consumed;\n\t\tconsumed = expand_name_field(previous_name, name);\n\t\tce = cache_entry_from_ondisk(ondisk, flags,\n\t\t\t\t\t     previous_name->buf,\n\t\t\t\t\t     previous_name->len);\n\n\t\t*ent_size = (name - ((char *)ondisk)) + consumed;\n\t}\n\treturn ce;\n}\n\n/* remember to discard_cache() before reading a different cache! */\nint read_index_from(struct index_state *istate, const char *path)\n{\n\tint fd, i;\n\tstruct stat st;\n\tunsigned long src_offset;\n\tstruct cache_header *hdr;\n\tvoid *mmap;\n\tsize_t mmap_size;\n\tstruct strbuf previous_name_buf = STRBUF_INIT, *previous_name;\n\n\tif (istate->initialized)\n\t\treturn istate->cache_nr;\n\n\tistate->timestamp.sec = 0;\n\tistate->timestamp.nsec = 0;\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tdie_errno(\"index file open failed\");\n\t}\n\n\tif (fstat(fd, &st))\n\t\tdie_errno(\"cannot stat the open index\");\n\n\tmmap_size = xsize_t(st.st_size);\n\tif (mmap_size < sizeof(struct cache_header) + 20)\n\t\tdie(\"index file smaller than expected\");\n\n\tmmap = xmmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n\tif (mmap == MAP_FAILED)\n\t\tdie_errno(\"unable to map index file\");\n\tclose(fd);\n\n\thdr = mmap;\n\tif (verify_hdr(hdr, mmap_size) < 0)\n\t\tgoto unmap;\n\n\tistate->version = ntohl(hdr->hdr_version);\n\tistate->cache_nr = ntohl(hdr->hdr_entries);\n\tistate->cache_alloc = alloc_nr(istate->cache_nr);\n\tistate->cache = xcalloc(istate->cache_alloc, sizeof(*istate->cache));\n\tistate->initialized = 1;\n\n\tif (istate->version == 4)\n\t\tprevious_name = &previous_name_buf;\n\telse\n\t\tprevious_name = NULL;\n\n\tsrc_offset = sizeof(*hdr);\n\tfor (i = 0; i < istate->cache_nr; i++) {\n\t\tstruct ondisk_cache_entry *disk_ce;\n\t\tstruct cache_entry *ce;\n\t\tunsigned long consumed;\n\n\t\tdisk_ce = (struct ondisk_cache_entry *)((char *)mmap + src_offset);\n\t\tce = create_from_disk(disk_ce, &consumed, previous_name);\n\t\tset_index_entry(istate, i, ce);\n\n\t\tsrc_offset += consumed;\n\t}\n\tstrbuf_release(&previous_name_buf);\n\tistate->timestamp.sec = st.st_mtime;\n\tistate->timestamp.nsec = ST_MTIME_NSEC(st);\n\n\twhile (src_offset <= mmap_size - 20 - 8) {\n\t\t/* After an array of active_nr index entries,\n\t\t * there can be arbitrary number of extended\n\t\t * sections, each of which is prefixed with\n\t\t * extension name (4-byte) and section length\n\t\t * in 4-byte network byte order.\n\t\t */\n\t\tuint32_t extsize;\n\t\tmemcpy(&extsize, (char *)mmap + src_offset + 4, 4);\n\t\textsize = ntohl(extsize);\n\t\tif (read_index_extension(istate,\n\t\t\t\t\t (const char *) mmap + src_offset,\n\t\t\t\t\t (char *) mmap + src_offset + 8,\n\t\t\t\t\t extsize) < 0)\n\t\t\tgoto unmap;\n\t\tsrc_offset += 8;\n\t\tsrc_offset += extsize;\n\t}\n\tmunmap(mmap, mmap_size);\n\treturn istate->cache_nr;\n\nunmap:\n\tmunmap(mmap, mmap_size);\n\tdie(\"index file corrupt\");\n}\n\nint is_index_unborn(struct index_state *istate)\n{\n\treturn (!istate->cache_nr && !istate->timestamp.sec);\n}\n\nint discard_index(struct index_state *istate)\n{\n\tint i;\n\n\tfor (i = 0; i < istate->cache_nr; i++)\n\t\tfree(istate->cache[i]);\n\tresolve_undo_clear_index(istate);\n\tistate->cache_nr = 0;\n\tistate->cache_changed = 0;\n\tistate->timestamp.sec = 0;\n\tistate->timestamp.nsec = 0;\n\tfree_name_hash(istate);\n\tcache_tree_free(&(istate->cache_tree));\n\tistate->initialized = 0;\n\tfree(istate->cache);\n\tistate->cache = NULL;\n\tistate->cache_alloc = 0;\n\treturn 0;\n}\n\nint unmerged_index(const struct index_state *istate)\n{\n\tint i;\n\tfor (i = 0; i < istate->cache_nr; i++) {\n\t\tif (ce_stage(istate->cache[i]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#define WRITE_BUFFER_SIZE 8192\nstatic unsigned char write_buffer[WRITE_BUFFER_SIZE];\nstatic unsigned long write_buffer_len;\n\nstatic int ce_write_flush(git_SHA_CTX *context, int fd)\n{\n\tunsigned int buffered = write_buffer_len;\n\tif (buffered) {\n\t\tgit_SHA1_Update(context, write_buffer, buffered);\n\t\tif (write_in_full(fd, write_buffer, buffered) != buffered)\n\t\t\treturn -1;\n\t\twrite_buffer_len = 0;\n\t}\n\treturn 0;\n}\n\nstatic int ce_write(git_SHA_CTX *context, int fd, void *data, unsigned int len)\n{\n\twhile (len) {\n\t\tunsigned int buffered = write_buffer_len;\n\t\tunsigned int partial = WRITE_BUFFER_SIZE - buffered;\n\t\tif (partial > len)\n\t\t\tpartial = len;\n\t\tmemcpy(write_buffer + buffered, data, partial);\n\t\tbuffered += partial;\n\t\tif (buffered == WRITE_BUFFER_SIZE) {\n\t\t\twrite_buffer_len = buffered;\n\t\t\tif (ce_write_flush(context, fd))\n\t\t\t\treturn -1;\n\t\t\tbuffered = 0;\n\t\t}\n\t\twrite_buffer_len = buffered;\n\t\tlen -= partial;\n\t\tdata = (char *) data + partial;\n\t}\n\treturn 0;\n}\n\nstatic int write_index_ext_header(git_SHA_CTX *context, int fd,\n\t\t\t\t  unsigned int ext, unsigned int sz)\n{\n\text = htonl(ext);\n\tsz = htonl(sz);\n\treturn ((ce_write(context, fd, &ext, 4) < 0) ||\n\t\t(ce_write(context, fd, &sz, 4) < 0)) ? -1 : 0;\n}\n\nstatic int ce_flush(git_SHA_CTX *context, int fd)\n{\n\tunsigned int left = write_buffer_len;\n\n\tif (left) {\n\t\twrite_buffer_len = 0;\n\t\tgit_SHA1_Update(context, write_buffer, left);\n\t}\n\n\t/* Flush first if not enough space for SHA1 signature */\n\tif (left + 20 > WRITE_BUFFER_SIZE) {\n\t\tif (write_in_full(fd, write_buffer, left) != left)\n\t\t\treturn -1;\n\t\tleft = 0;\n\t}\n\n\t/* Append the SHA1 signature at the end */\n\tgit_SHA1_Final(write_buffer + left, context);\n\tleft += 20;\n\treturn (write_in_full(fd, write_buffer, left) != left) ? -1 : 0;\n}\n\nstatic void ce_smudge_racily_clean_entry(struct cache_entry *ce)\n{\n\t/*\n\t * The only thing we care about in this function is to smudge the\n\t * falsely clean entry due to touch-update-touch race, so we leave\n\t * everything else as they are.  We are called for entries whose\n\t * ce_stat_data.sd_mtime match the index file mtime.\n\t *\n\t * Note that this actually does not do much for gitlinks, for\n\t * which ce_match_stat_basic() always goes to the actual\n\t * contents.  The caller checks with is_racy_timestamp() which\n\t * always says \"no\" for gitlinks, so we are not called for them ;-)\n\t */\n\tstruct stat st;\n\n\tif (lstat(ce->name, &st) < 0)\n\t\treturn;\n\tif (ce_match_stat_basic(ce, &st))\n\t\treturn;\n\tif (ce_modified_check_fs(ce, &st)) {\n\t\t/* This is \"racily clean\"; smudge it.  Note that this\n\t\t * is a tricky code.  At first glance, it may appear\n\t\t * that it can break with this sequence:\n\t\t *\n\t\t * $ echo xyzzy >frotz\n\t\t * $ git-update-index --add frotz\n\t\t * $ : >frotz\n\t\t * $ sleep 3\n\t\t * $ echo filfre >nitfol\n\t\t * $ git-update-index --add nitfol\n\t\t *\n\t\t * but it does not.  When the second update-index runs,\n\t\t * it notices that the entry \"frotz\" has the same timestamp\n\t\t * as index, and if we were to smudge it by resetting its\n\t\t * size to zero here, then the object name recorded\n\t\t * in index is the 6-byte file but the cached stat information\n\t\t * becomes zero --- which would then match what we would\n\t\t * obtain from the filesystem next time we stat(\"frotz\").\n\t\t *\n\t\t * However, the second update-index, before calling\n\t\t * this function, notices that the cached size is 6\n\t\t * bytes and what is on the filesystem is an empty\n\t\t * file, and never calls us, so the cached size information\n\t\t * for \"frotz\" stays 6 which does not match the filesystem.\n\t\t */\n\t\tce->ce_stat_data.sd_size = 0;\n\t}\n}\n\n/* Copy miscellaneous fields but not the name */\nstatic char *copy_cache_entry_to_ondisk(struct ondisk_cache_entry *ondisk,\n\t\t\t\t       struct cache_entry *ce)\n{\n\tshort flags;\n\n\tondisk->ctime.sec = htonl(ce->ce_stat_data.sd_ctime.sec);\n\tondisk->mtime.sec = htonl(ce->ce_stat_data.sd_mtime.sec);\n\tondisk->ctime.nsec = htonl(ce->ce_stat_data.sd_ctime.nsec);\n\tondisk->mtime.nsec = htonl(ce->ce_stat_data.sd_mtime.nsec);\n\tondisk->dev  = htonl(ce->ce_stat_data.sd_dev);\n\tondisk->ino  = htonl(ce->ce_stat_data.sd_ino);\n\tondisk->mode = htonl(ce->ce_mode);\n\tondisk->uid  = htonl(ce->ce_stat_data.sd_uid);\n\tondisk->gid  = htonl(ce->ce_stat_data.sd_gid);\n\tondisk->size = htonl(ce->ce_stat_data.sd_size);\n\thashcpy(ondisk->sha1, ce->sha1);\n\n\tflags = ce->ce_flags;\n\tflags |= (ce_namelen(ce) >= CE_NAMEMASK ? CE_NAMEMASK : ce_namelen(ce));\n\tondisk->flags = htons(flags);\n\tif (ce->ce_flags & CE_EXTENDED) {\n\t\tstruct ondisk_cache_entry_extended *ondisk2;\n\t\tondisk2 = (struct ondisk_cache_entry_extended *)ondisk;\n\t\tondisk2->flags2 = htons((ce->ce_flags & CE_EXTENDED_FLAGS) >> 16);\n\t\treturn ondisk2->name;\n\t}\n\telse {\n\t\treturn ondisk->name;\n\t}\n}\n\nstatic int ce_write_entry(git_SHA_CTX *c, int fd, struct cache_entry *ce,\n\t\t\t  struct strbuf *previous_name)\n{\n\tint size;\n\tstruct ondisk_cache_entry *ondisk;\n\tchar *name;\n\tint result;\n\n\tif (!previous_name) {\n\t\tsize = ondisk_ce_size(ce);\n\t\tondisk = xcalloc(1, size);\n\t\tname = copy_cache_entry_to_ondisk(ondisk, ce);\n\t\tmemcpy(name, ce->name, ce_namelen(ce));\n\t} else {\n\t\tint common, to_remove, prefix_size;\n\t\tunsigned char to_remove_vi[16];\n\t\tfor (common = 0;\n\t\t     (ce->name[common] &&\n\t\t      common < previous_name->len &&\n\t\t      ce->name[common] == previous_name->buf[common]);\n\t\t     common++)\n\t\t\t; /* still matching */\n\t\tto_remove = previous_name->len - common;\n\t\tprefix_size = encode_varint(to_remove, to_remove_vi);\n\n\t\tif (ce->ce_flags & CE_EXTENDED)\n\t\t\tsize = offsetof(struct ondisk_cache_entry_extended, name);\n\t\telse\n\t\t\tsize = offsetof(struct ondisk_cache_entry, name);\n\t\tsize += prefix_size + (ce_namelen(ce) - common + 1);\n\n\t\tondisk = xcalloc(1, size);\n\t\tname = copy_cache_entry_to_ondisk(ondisk, ce);\n\t\tmemcpy(name, to_remove_vi, prefix_size);\n\t\tmemcpy(name + prefix_size, ce->name + common, ce_namelen(ce) - common);\n\n\t\tstrbuf_splice(previous_name, common, to_remove,\n\t\t\t      ce->name + common, ce_namelen(ce) - common);\n\t}\n\n\tresult = ce_write(c, fd, ondisk, size);\n\tfree(ondisk);\n\treturn result;\n}\n\nstatic int has_racy_timestamp(struct index_state *istate)\n{\n\tint entries = istate->cache_nr;\n\tint i;\n\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct cache_entry *ce = istate->cache[i];\n\t\tif (is_racy_timestamp(istate, ce))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Opportunistically update the index but do not complain if we can't\n */\nvoid update_index_if_able(struct index_state *istate, struct lock_file *lockfile)\n{\n\tif ((istate->cache_changed || has_racy_timestamp(istate)) &&\n\t    !write_index(istate, lockfile->fd))\n\t\tcommit_locked_index(lockfile);\n\telse\n\t\trollback_lock_file(lockfile);\n}\n\nint write_index(struct index_state *istate, int newfd)\n{\n\tgit_SHA_CTX c;\n\tstruct cache_header hdr;\n\tint i, err, removed, extended, hdr_version;\n\tstruct cache_entry **cache = istate->cache;\n\tint entries = istate->cache_nr;\n\tstruct stat st;\n\tstruct strbuf previous_name_buf = STRBUF_INIT, *previous_name;\n\n\tfor (i = removed = extended = 0; i < entries; i++) {\n\t\tif (cache[i]->ce_flags & CE_REMOVE)\n\t\t\tremoved++;\n\n\t\t/* reduce extended entries if possible */\n\t\tcache[i]->ce_flags &= ~CE_EXTENDED;\n\t\tif (cache[i]->ce_flags & CE_EXTENDED_FLAGS) {\n\t\t\textended++;\n\t\t\tcache[i]->ce_flags |= CE_EXTENDED;\n\t\t}\n\t}\n\n\tif (!istate->version)\n\t\tistate->version = INDEX_FORMAT_DEFAULT;\n\n\t/* demote version 3 to version 2 when the latter suffices */\n\tif (istate->version == 3 || istate->version == 2)\n\t\tistate->version = extended ? 3 : 2;\n\n\thdr_version = istate->version;\n\n\thdr.hdr_signature = htonl(CACHE_SIGNATURE);\n\thdr.hdr_version = htonl(hdr_version);\n\thdr.hdr_entries = htonl(entries - removed);\n\n\tgit_SHA1_Init(&c);\n\tif (ce_write(&c, newfd, &hdr, sizeof(hdr)) < 0)\n\t\treturn -1;\n\n\tprevious_name = (hdr_version == 4) ? &previous_name_buf : NULL;\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct cache_entry *ce = cache[i];\n\t\tif (ce->ce_flags & CE_REMOVE)\n\t\t\tcontinue;\n\t\tif (!ce_uptodate(ce) && is_racy_timestamp(istate, ce))\n\t\t\tce_smudge_racily_clean_entry(ce);\n\t\tif (is_null_sha1(ce->sha1)) {\n\t\t\tstatic const char msg[] = \"cache entry has null sha1: %s\";\n\t\t\tstatic int allow = -1;\n\n\t\t\tif (allow < 0)\n\t\t\t\tallow = git_env_bool(\"GIT_ALLOW_NULL_SHA1\", 0);\n\t\t\tif (allow)\n\t\t\t\twarning(msg, ce->name);\n\t\t\telse\n\t\t\t\treturn error(msg, ce->name);\n\t\t}\n\t\tif (ce_write_entry(&c, newfd, ce, previous_name) < 0)\n\t\t\treturn -1;\n\t}\n\tstrbuf_release(&previous_name_buf);\n\n\t/* Write extension data here */\n\tif (istate->cache_tree) {\n\t\tstruct strbuf sb = STRBUF_INIT;\n\n\t\tcache_tree_write(&sb, istate->cache_tree);\n\t\terr = write_index_ext_header(&c, newfd, CACHE_EXT_TREE, sb.len) < 0\n\t\t\t|| ce_write(&c, newfd, sb.buf, sb.len) < 0;\n\t\tstrbuf_release(&sb);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\tif (istate->resolve_undo) {\n\t\tstruct strbuf sb = STRBUF_INIT;\n\n\t\tresolve_undo_write(&sb, istate->resolve_undo);\n\t\terr = write_index_ext_header(&c, newfd, CACHE_EXT_RESOLVE_UNDO,\n\t\t\t\t\t     sb.len) < 0\n\t\t\t|| ce_write(&c, newfd, sb.buf, sb.len) < 0;\n\t\tstrbuf_release(&sb);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\n\tif (ce_flush(&c, newfd) || fstat(newfd, &st))\n\t\treturn -1;\n\tistate->timestamp.sec = (unsigned int)st.st_mtime;\n\tistate->timestamp.nsec = ST_MTIME_NSEC(st);\n\treturn 0;\n}\n\n/*\n * Read the index file that is potentially unmerged into given\n * index_state, dropping any unmerged entries.  Returns true if\n * the index is unmerged.  Callers who want to refuse to work\n * from an unmerged state can call this and check its return value,\n * instead of calling read_cache().\n */\nint read_index_unmerged(struct index_state *istate)\n{\n\tint i;\n\tint unmerged = 0;\n\n\tread_index(istate);\n\tfor (i = 0; i < istate->cache_nr; i++) {\n\t\tstruct cache_entry *ce = istate->cache[i];\n\t\tstruct cache_entry *new_ce;\n\t\tint size, len;\n\n\t\tif (!ce_stage(ce))\n\t\t\tcontinue;\n\t\tunmerged = 1;\n\t\tlen = ce_namelen(ce);\n\t\tsize = cache_entry_size(len);\n\t\tnew_ce = xcalloc(1, size);\n\t\tmemcpy(new_ce->name, ce->name, len);\n\t\tnew_ce->ce_flags = create_ce_flags(0) | CE_CONFLICTED;\n\t\tnew_ce->ce_namelen = len;\n\t\tnew_ce->ce_mode = ce->ce_mode;\n\t\tif (add_index_entry(istate, new_ce, 0))\n\t\t\treturn error(\"%s: cannot drop to stage #0\",\n\t\t\t\t     ce->name);\n\t\ti = index_name_pos(istate, new_ce->name, len);\n\t}\n\treturn unmerged;\n}\n\n/*\n * Returns 1 if the path is an \"other\" path with respect to\n * the index; that is, the path is not mentioned in the index at all,\n * either as a file, a directory with some files in the index,\n * or as an unmerged entry.\n *\n * We helpfully remove a trailing \"/\" from directories so that\n * the output of read_directory can be used as-is.\n */\nint index_name_is_other(const struct index_state *istate, const char *name,\n\t\tint namelen)\n{\n\tint pos;\n\tif (namelen && name[namelen - 1] == '/')\n\t\tnamelen--;\n\tpos = index_name_pos(istate, name, namelen);\n\tif (0 <= pos)\n\t\treturn 0;\t/* exact match */\n\tpos = -pos - 1;\n\tif (pos < istate->cache_nr) {\n\t\tstruct cache_entry *ce = istate->cache[pos];\n\t\tif (ce_namelen(ce) == namelen &&\n\t\t    !memcmp(ce->name, name, namelen))\n\t\t\treturn 0; /* Yup, this one exists unmerged */\n\t}\n\treturn 1;\n}\n\nvoid *read_blob_data_from_index(struct index_state *istate, const char *path, unsigned long *size)\n{\n\tint pos, len;\n\tunsigned long sz;\n\tenum object_type type;\n\tvoid *data;\n\n\tlen = strlen(path);\n\tpos = index_name_pos(istate, path, len);\n\tif (pos < 0) {\n\t\t/*\n\t\t * We might be in the middle of a merge, in which\n\t\t * case we would read stage #2 (ours).\n\t\t */\n\t\tint i;\n\t\tfor (i = -pos - 1;\n\t\t     (pos < 0 && i < istate->cache_nr &&\n\t\t      !strcmp(istate->cache[i]->name, path));\n\t\t     i++)\n\t\t\tif (ce_stage(istate->cache[i]) == 2)\n\t\t\t\tpos = i;\n\t}\n\tif (pos < 0)\n\t\treturn NULL;\n\tdata = read_sha1_file(istate->cache[pos]->sha1, &type, &sz);\n\tif (!data || type != OBJ_BLOB) {\n\t\tfree(data);\n\t\treturn NULL;\n\t}\n\tif (size)\n\t\t*size = sz;\n\treturn data;\n}\n\nvoid stat_validity_clear(struct stat_validity *sv)\n{\n\tfree(sv->sd);\n\tsv->sd = NULL;\n}\n\nint stat_validity_check(struct stat_validity *sv, const char *path)\n{\n\tstruct stat st;\n\n\tif (stat(path, &st) < 0)\n\t\treturn sv->sd == NULL;\n\tif (!sv->sd)\n\t\treturn 0;\n\treturn S_ISREG(st.st_mode) && !match_stat_data(sv->sd, &st);\n}\n\nvoid stat_validity_update(struct stat_validity *sv, int fd)\n{\n\tstruct stat st;\n\n\tif (fstat(fd, &st) < 0 || !S_ISREG(st.st_mode))\n\t\tstat_validity_clear(sv);\n\telse {\n\t\tif (!sv->sd)\n\t\t\tsv->sd = xcalloc(1, sizeof(struct stat_data));\n\t\tfill_stat_data(sv->sd, &st);\n\t}\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00af9addd90d9b44f9134d50708548896deb0e2f",
  "sha1_ok": true,
  "size": 54192
}
