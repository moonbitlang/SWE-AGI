{
  "content": {
    "base64": "I2RlZmluZSBESVNBQkxFX1NJR05fQ09NUEFSRV9XQVJOSU5HUwoKI2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAiYWJzcGF0aC5oIgojaW5jbHVkZSAiY29uZmlnLmgiCiNpbmNsdWRlICJoZXguaCIKI2luY2x1ZGUgImxvY2tmaWxlLmgiCiNpbmNsdWRlICJwYWNrZmlsZS5oIgojaW5jbHVkZSAib2JqZWN0LWZpbGUuaCIKI2luY2x1ZGUgImhhc2gtbG9va3VwLmgiCiNpbmNsdWRlICJtaWR4LmgiCiNpbmNsdWRlICJwcm9ncmVzcy5oIgojaW5jbHVkZSAidHJhY2UyLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAiY2h1bmstZm9ybWF0LmgiCiNpbmNsdWRlICJwYWNrLWJpdG1hcC5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAicmV2aXNpb24uaCIKI2luY2x1ZGUgImxpc3Qtb2JqZWN0cy5oIgojaW5jbHVkZSAicGF0aC5oIgojaW5jbHVkZSAicGFjay1yZXZpbmRleC5oIgoKI2RlZmluZSBQQUNLX0VYUElSRUQgVUlOVF9NQVgKI2RlZmluZSBCSVRNQVBfUE9TX1VOS05PV04gKH4oKHVpbnQzMl90KTApKQojZGVmaW5lIE1JRFhfQ0hVTktfRkFOT1VUX1NJWkUgKHNpemVvZih1aW50MzJfdCkgKiAyNTYpCiNkZWZpbmUgTUlEWF9DSFVOS19MQVJHRV9PRkZTRVRfV0lEVEggKHNpemVvZih1aW50NjRfdCkpCgpleHRlcm4gaW50IG1pZHhfY2hlY2tzdW1fdmFsaWQoc3RydWN0IG11bHRpX3BhY2tfaW5kZXggKm0pOwpleHRlcm4gdm9pZCBjbGVhcl9taWR4X2ZpbGVzX2V4dChjb25zdCBjaGFyICpvYmplY3RfZGlyLCBjb25zdCBjaGFyICpleHQsCgkJCQkgY29uc3QgY2hhciAqa2VlcF9oYXNoKTsKZXh0ZXJuIHZvaWQgY2xlYXJfaW5jcmVtZW50YWxfbWlkeF9maWxlc19leHQoY29uc3QgY2hhciAqb2JqZWN0X2RpciwKCQkJCQkgICAgIGNvbnN0IGNoYXIgKmV4dCwKCQkJCQkgICAgIGNvbnN0IGNoYXIgKiprZWVwX2hhc2hlcywKCQkJCQkgICAgIHVpbnQzMl90IGhhc2hlc19ucik7CmV4dGVybiBpbnQgY21wX2lkeF9vcl9wYWNrX25hbWUoY29uc3QgY2hhciAqaWR4X29yX3BhY2tfbmFtZSwKCQkJCWNvbnN0IGNoYXIgKmlkeF9uYW1lKTsKCnN0YXRpYyBzaXplX3Qgd3JpdGVfbWlkeF9oZWFkZXIoY29uc3Qgc3RydWN0IGdpdF9oYXNoX2FsZ28gKmhhc2hfYWxnbywKCQkJCXN0cnVjdCBoYXNoZmlsZSAqZiwgdW5zaWduZWQgY2hhciBudW1fY2h1bmtzLAoJCQkJdWludDMyX3QgbnVtX3BhY2tzKQp7CgloYXNod3JpdGVfYmUzMihmLCBNSURYX1NJR05BVFVSRSk7CgloYXNod3JpdGVfdTgoZiwgTUlEWF9WRVJTSU9OKTsKCWhhc2h3cml0ZV91OChmLCBvaWRfdmVyc2lvbihoYXNoX2FsZ28pKTsKCWhhc2h3cml0ZV91OChmLCBudW1fY2h1bmtzKTsKCWhhc2h3cml0ZV91OChmLCAwKTsgLyogdW51c2VkICovCgloYXNod3JpdGVfYmUzMihmLCBudW1fcGFja3MpOwoKCXJldHVybiBNSURYX0hFQURFUl9TSVpFOwp9CgpzdHJ1Y3QgcGFja19pbmZvIHsKCXVpbnQzMl90IG9yaWdfcGFja19pbnRfaWQ7CgljaGFyICpwYWNrX25hbWU7CglzdHJ1Y3QgcGFja2VkX2dpdCAqcDsKCgl1aW50MzJfdCBiaXRtYXBfcG9zOwoJdWludDMyX3QgYml0bWFwX25yOwoKCXVuc2lnbmVkIGV4cGlyZWQgOiAxOwp9OwoKc3RhdGljIHZvaWQgZmlsbF9wYWNrX2luZm8oc3RydWN0IHBhY2tfaW5mbyAqaW5mbywKCQkJICAgc3RydWN0IHBhY2tlZF9naXQgKnAsIGNvbnN0IGNoYXIgKnBhY2tfbmFtZSwKCQkJICAgdWludDMyX3Qgb3JpZ19wYWNrX2ludF9pZCkKewoJbWVtc2V0KGluZm8sIDAsIHNpemVvZihzdHJ1Y3QgcGFja19pbmZvKSk7CgoJaW5mby0+b3JpZ19wYWNrX2ludF9pZCA9IG9yaWdfcGFja19pbnRfaWQ7CglpbmZvLT5wYWNrX25hbWUgPSB4c3RyZHVwKHBhY2tfbmFtZSk7CglpbmZvLT5wID0gcDsKCWluZm8tPmJpdG1hcF9wb3MgPSBCSVRNQVBfUE9TX1VOS05PV047Cn0KCnN0YXRpYyBpbnQgcGFja19pbmZvX2NvbXBhcmUoY29uc3Qgdm9pZCAqX2EsIGNvbnN0IHZvaWQgKl9iKQp7CglzdHJ1Y3QgcGFja19pbmZvICphID0gKHN0cnVjdCBwYWNrX2luZm8gKilfYTsKCXN0cnVjdCBwYWNrX2luZm8gKmIgPSAoc3RydWN0IHBhY2tfaW5mbyAqKV9iOwoJcmV0dXJuIHN0cmNtcChhLT5wYWNrX25hbWUsIGItPnBhY2tfbmFtZSk7Cn0KCnN0YXRpYyBpbnQgaWR4X29yX3BhY2tfbmFtZV9jbXAoY29uc3Qgdm9pZCAqX3ZhLCBjb25zdCB2b2lkICpfdmIpCnsKCWNvbnN0IGNoYXIgKnBhY2tfbmFtZSA9IF92YTsKCWNvbnN0IHN0cnVjdCBwYWNrX2luZm8gKmNvbXBhciA9IF92YjsKCglyZXR1cm4gY21wX2lkeF9vcl9wYWNrX25hbWUocGFja19uYW1lLCBjb21wYXItPnBhY2tfbmFtZSk7Cn0KCnN0cnVjdCB3cml0ZV9taWR4X2NvbnRleHQgewoJc3RydWN0IHBhY2tfaW5mbyAqaW5mbzsKCXNpemVfdCBucjsKCXNpemVfdCBhbGxvYzsKCXN0cnVjdCBtdWx0aV9wYWNrX2luZGV4ICptOwoJc3RydWN0IG11bHRpX3BhY2tfaW5kZXggKmJhc2VfbWlkeDsKCXN0cnVjdCBwcm9ncmVzcyAqcHJvZ3Jlc3M7Cgl1bnNpZ25lZCBwYWNrX3BhdGhzX2NoZWNrZWQ7CgoJc3RydWN0IHBhY2tfbWlkeF9lbnRyeSAqZW50cmllczsKCXNpemVfdCBlbnRyaWVzX25yOwoKCXVpbnQzMl90ICpwYWNrX3Blcm07Cgl1aW50MzJfdCAqcGFja19vcmRlcjsKCXVuc2lnbmVkIGxhcmdlX29mZnNldHNfbmVlZGVkOjE7Cgl1aW50MzJfdCBudW1fbGFyZ2Vfb2Zmc2V0czsKCglpbnQgcHJlZmVycmVkX3BhY2tfaWR4OwoKCWludCBpbmNyZW1lbnRhbDsKCXVpbnQzMl90IG51bV9tdWx0aV9wYWNrX2luZGV4ZXNfYmVmb3JlOwoKCXN0cnVjdCBzdHJpbmdfbGlzdCAqdG9faW5jbHVkZTsKCglzdHJ1Y3QgcmVwb3NpdG9yeSAqcmVwbzsKfTsKCnN0YXRpYyBpbnQgc2hvdWxkX2luY2x1ZGVfcGFjayhjb25zdCBzdHJ1Y3Qgd3JpdGVfbWlkeF9jb250ZXh0ICpjdHgsCgkJCSAgICAgICBjb25zdCBjaGFyICpmaWxlX25hbWUpCnsKCS8qCgkgKiBOb3RlIHRoYXQgYXQgbW9zdCBvbmUgb2YgY3R4LT5tIGFuZCBjdHgtPnRvX2luY2x1ZGUgYXJlIHNldCwKCSAqIHNvIHdlIGFyZSB0ZXN0aW5nIG1pZHhfY29udGFpbnNfcGFjaygpIGFuZAoJICogc3RyaW5nX2xpc3RfaGFzX3N0cmluZygpIGluZGVwZW5kZW50bHkgKGd1YXJkZWQgYnkgdGhlCgkgKiBhcHByb3ByaWF0ZSBOVUxMIGNoZWNrcykuCgkgKgoJICogV2UgY291bGQgc3VwcG9ydCBwYXNzaW5nIHRvX2luY2x1ZGUgd2hpbGUgcmV1c2luZyBhbiBleGlzdGluZwoJICogTUlEWCwgYnV0IGRvbid0IGN1cnJlbnRseSBzaW5jZSB0aGUgcmV1c2UgcHJvY2VzcyBkcmFncwoJICogZm9yd2FyZCBhbGwgcGFja3MgZnJvbSBhbiBleGlzdGluZyBNSURYICh3aXRob3V0IGNoZWNraW5nCgkgKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFwcGVhciBpbiB0aGUgdG9faW5jbHVkZSBsaXN0KS4KCSAqCgkgKiBJZiB3ZSBhZGRlZCBzdXBwb3J0IGZvciB0aGF0LCB0aGVzZSBuZXh0IHR3byBjb25kaXRpb25hbAoJICogc2hvdWxkIGJlIHBlcmZvcm1lZCBpbmRlcGVuZGVudGx5IChsaWtlbHkgY2hlY2tpbmcKCSAqIHRvX2luY2x1ZGUgYmVmb3JlIHRoZSBleGlzdGluZyBNSURYKS4KCSAqLwoJaWYgKGN0eC0+bSAmJiBtaWR4X2NvbnRhaW5zX3BhY2soY3R4LT5tLCBmaWxlX25hbWUpKQoJCXJldHVybiAwOwoJZWxzZSBpZiAoY3R4LT5iYXNlX21pZHggJiYgbWlkeF9jb250YWluc19wYWNrKGN0eC0+YmFzZV9taWR4LAoJCQkJCQkgICAgICBmaWxlX25hbWUpKQoJCXJldHVybiAwOwoJZWxzZSBpZiAoY3R4LT50b19pbmNsdWRlICYmCgkJICFzdHJpbmdfbGlzdF9oYXNfc3RyaW5nKGN0eC0+dG9faW5jbHVkZSwgZmlsZV9uYW1lKSkKCQlyZXR1cm4gMDsKCXJldHVybiAxOwp9CgpzdGF0aWMgdm9pZCBhZGRfcGFja190b19taWR4KGNvbnN0IGNoYXIgKmZ1bGxfcGF0aCwgc2l6ZV90IGZ1bGxfcGF0aF9sZW4sCgkJCSAgICAgY29uc3QgY2hhciAqZmlsZV9uYW1lLCB2b2lkICpkYXRhKQp7CglzdHJ1Y3Qgd3JpdGVfbWlkeF9jb250ZXh0ICpjdHggPSBkYXRhOwoJc3RydWN0IHBhY2tlZF9naXQgKnA7CgoJaWYgKGVuZHNfd2l0aChmaWxlX25hbWUsICIuaWR4IikpIHsKCQlkaXNwbGF5X3Byb2dyZXNzKGN0eC0+cHJvZ3Jlc3MsICsrY3R4LT5wYWNrX3BhdGhzX2NoZWNrZWQpOwoKCQlpZiAoIXNob3VsZF9pbmNsdWRlX3BhY2soY3R4LCBmaWxlX25hbWUpKQoJCQlyZXR1cm47CgoJCUFMTE9DX0dST1coY3R4LT5pbmZvLCBjdHgtPm5yICsgMSwgY3R4LT5hbGxvYyk7CgkJcCA9IGFkZF9wYWNrZWRfZ2l0KGN0eC0+cmVwbywgZnVsbF9wYXRoLCBmdWxsX3BhdGhfbGVuLCAwKTsKCQlpZiAoIXApIHsKCQkJd2FybmluZyhfKCJmYWlsZWQgdG8gYWRkIHBhY2tmaWxlICclcyciKSwKCQkJCWZ1bGxfcGF0aCk7CgkJCXJldHVybjsKCQl9CgoJCWlmIChvcGVuX3BhY2tfaW5kZXgocCkpIHsKCQkJd2FybmluZyhfKCJmYWlsZWQgdG8gb3BlbiBwYWNrLWluZGV4ICclcyciKSwKCQkJCWZ1bGxfcGF0aCk7CgkJCWNsb3NlX3BhY2socCk7CgkJCWZyZWUocCk7CgkJCXJldHVybjsKCQl9CgoJCWZpbGxfcGFja19pbmZvKCZjdHgtPmluZm9bY3R4LT5ucl0sIHAsIGZpbGVfbmFtZSwgY3R4LT5ucik7CgkJY3R4LT5ucisrOwoJfQp9CgpzdHJ1Y3QgcGFja19taWR4X2VudHJ5IHsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJdWludDMyX3QgcGFja19pbnRfaWQ7Cgl0aW1lX3QgcGFja19tdGltZTsKCXVpbnQ2NF90IG9mZnNldDsKCXVuc2lnbmVkIHByZWZlcnJlZCA6IDE7Cn07CgpzdGF0aWMgaW50IG1pZHhfb2lkX2NvbXBhcmUoY29uc3Qgdm9pZCAqX2EsIGNvbnN0IHZvaWQgKl9iKQp7Cgljb25zdCBzdHJ1Y3QgcGFja19taWR4X2VudHJ5ICphID0gKGNvbnN0IHN0cnVjdCBwYWNrX21pZHhfZW50cnkgKilfYTsKCWNvbnN0IHN0cnVjdCBwYWNrX21pZHhfZW50cnkgKmIgPSAoY29uc3Qgc3RydWN0IHBhY2tfbWlkeF9lbnRyeSAqKV9iOwoJaW50IGNtcCA9IG9pZGNtcCgmYS0+b2lkLCAmYi0+b2lkKTsKCglpZiAoY21wKQoJCXJldHVybiBjbXA7CgoJLyogU29ydCBvYmplY3RzIGluIGEgcHJlZmVycmVkIHBhY2sgZmlyc3Qgd2hlbiBtdWx0aXBsZSBjb3BpZXMgZXhpc3QuICovCglpZiAoYS0+cHJlZmVycmVkID4gYi0+cHJlZmVycmVkKQoJCXJldHVybiAtMTsKCWlmIChhLT5wcmVmZXJyZWQgPCBiLT5wcmVmZXJyZWQpCgkJcmV0dXJuIDE7CgoJaWYgKGEtPnBhY2tfbXRpbWUgPiBiLT5wYWNrX210aW1lKQoJCXJldHVybiAtMTsKCWVsc2UgaWYgKGEtPnBhY2tfbXRpbWUgPCBiLT5wYWNrX210aW1lKQoJCXJldHVybiAxOwoKCXJldHVybiBhLT5wYWNrX2ludF9pZCAtIGItPnBhY2tfaW50X2lkOwp9CgpzdGF0aWMgaW50IG50aF9taWR4ZWRfcGFja19taWR4X2VudHJ5KHN0cnVjdCBtdWx0aV9wYWNrX2luZGV4ICptLAoJCQkJICAgICAgc3RydWN0IHBhY2tfbWlkeF9lbnRyeSAqZSwKCQkJCSAgICAgIHVpbnQzMl90IHBvcykKewoJaWYgKHBvcyA+PSBtLT5udW1fb2JqZWN0cyArIG0tPm51bV9vYmplY3RzX2luX2Jhc2UpCgkJcmV0dXJuIDE7CgoJbnRoX21pZHhlZF9vYmplY3Rfb2lkKCZlLT5vaWQsIG0sIHBvcyk7CgllLT5wYWNrX2ludF9pZCA9IG50aF9taWR4ZWRfcGFja19pbnRfaWQobSwgcG9zKTsKCWUtPm9mZnNldCA9IG50aF9taWR4ZWRfb2Zmc2V0KG0sIHBvcyk7CgoJLyogY29uc2lkZXIgb2JqZWN0cyBpbiBtaWR4IHRvIGJlIGZyb20gIm9sZCIgcGFja3MgKi8KCWUtPnBhY2tfbXRpbWUgPSAwOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGZpbGxfcGFja19lbnRyeSh1aW50MzJfdCBwYWNrX2ludF9pZCwKCQkJICAgIHN0cnVjdCBwYWNrZWRfZ2l0ICpwLAoJCQkgICAgdWludDMyX3QgY3VyX29iamVjdCwKCQkJICAgIHN0cnVjdCBwYWNrX21pZHhfZW50cnkgKmVudHJ5LAoJCQkgICAgaW50IHByZWZlcnJlZCkKewoJaWYgKG50aF9wYWNrZWRfb2JqZWN0X2lkKCZlbnRyeS0+b2lkLCBwLCBjdXJfb2JqZWN0KSA8IDApCgkJZGllKF8oImZhaWxlZCB0byBsb2NhdGUgb2JqZWN0ICVkIGluIHBhY2tmaWxlIiksIGN1cl9vYmplY3QpOwoKCWVudHJ5LT5wYWNrX2ludF9pZCA9IHBhY2tfaW50X2lkOwoJZW50cnktPnBhY2tfbXRpbWUgPSBwLT5tdGltZTsKCgllbnRyeS0+b2Zmc2V0ID0gbnRoX3BhY2tlZF9vYmplY3Rfb2Zmc2V0KHAsIGN1cl9vYmplY3QpOwoJZW50cnktPnByZWZlcnJlZCA9ICEhcHJlZmVycmVkOwp9CgpzdHJ1Y3QgbWlkeF9mYW5vdXQgewoJc3RydWN0IHBhY2tfbWlkeF9lbnRyeSAqZW50cmllczsKCXNpemVfdCBuciwgYWxsb2M7Cn07CgpzdGF0aWMgdm9pZCBtaWR4X2Zhbm91dF9ncm93KHN0cnVjdCBtaWR4X2Zhbm91dCAqZmFub3V0LCBzaXplX3QgbnIpCnsKCWlmIChuciA8IGZhbm91dC0+bnIpCgkJQlVHKCJuZWdhdGl2ZSBncm93dGggaW4gbWlkeF9mYW5vdXRfZ3JvdygpICglIlBSSXVNQVgiIDwgJSJQUkl1TUFYIikiLAoJCSAgICAodWludG1heF90KW5yLCAodWludG1heF90KWZhbm91dC0+bnIpOwoJQUxMT0NfR1JPVyhmYW5vdXQtPmVudHJpZXMsIG5yLCBmYW5vdXQtPmFsbG9jKTsKfQoKc3RhdGljIHZvaWQgbWlkeF9mYW5vdXRfc29ydChzdHJ1Y3QgbWlkeF9mYW5vdXQgKmZhbm91dCkKewoJUVNPUlQoZmFub3V0LT5lbnRyaWVzLCBmYW5vdXQtPm5yLCBtaWR4X29pZF9jb21wYXJlKTsKfQoKc3RhdGljIHZvaWQgbWlkeF9mYW5vdXRfYWRkX21pZHhfZmFub3V0KHN0cnVjdCBtaWR4X2Zhbm91dCAqZmFub3V0LAoJCQkJCXN0cnVjdCBtdWx0aV9wYWNrX2luZGV4ICptLAoJCQkJCXVpbnQzMl90IGN1cl9mYW5vdXQsCgkJCQkJaW50IHByZWZlcnJlZF9wYWNrKQp7Cgl1aW50MzJfdCBzdGFydCA9IG0tPm51bV9vYmplY3RzX2luX2Jhc2UsIGVuZDsKCXVpbnQzMl90IGN1cl9vYmplY3Q7CgoJaWYgKG0tPmJhc2VfbWlkeCkKCQltaWR4X2Zhbm91dF9hZGRfbWlkeF9mYW5vdXQoZmFub3V0LCBtLT5iYXNlX21pZHgsIGN1cl9mYW5vdXQsCgkJCQkJICAgIHByZWZlcnJlZF9wYWNrKTsKCglpZiAoY3VyX2Zhbm91dCkKCQlzdGFydCArPSBudG9obChtLT5jaHVua19vaWRfZmFub3V0W2N1cl9mYW5vdXQgLSAxXSk7CgllbmQgPSBtLT5udW1fb2JqZWN0c19pbl9iYXNlICsgbnRvaGwobS0+Y2h1bmtfb2lkX2Zhbm91dFtjdXJfZmFub3V0XSk7CgoJZm9yIChjdXJfb2JqZWN0ID0gc3RhcnQ7IGN1cl9vYmplY3QgPCBlbmQ7IGN1cl9vYmplY3QrKykgewoJCWlmICgocHJlZmVycmVkX3BhY2sgPiAtMSkgJiYKCQkgICAgKHByZWZlcnJlZF9wYWNrID09IG50aF9taWR4ZWRfcGFja19pbnRfaWQobSwgY3VyX29iamVjdCkpKSB7CgkJCS8qCgkJCSAqIE9iamVjdHMgZnJvbSBwcmVmZXJyZWQgcGFja3MgYXJlIGFkZGVkCgkJCSAqIHNlcGFyYXRlbHkuCgkJCSAqLwoJCQljb250aW51ZTsKCQl9CgoJCW1pZHhfZmFub3V0X2dyb3coZmFub3V0LCBmYW5vdXQtPm5yICsgMSk7CgkJbnRoX21pZHhlZF9wYWNrX21pZHhfZW50cnkobSwKCQkJCQkgICAmZmFub3V0LT5lbnRyaWVzW2Zhbm91dC0+bnJdLAoJCQkJCSAgIGN1cl9vYmplY3QpOwoJCWZhbm91dC0+ZW50cmllc1tmYW5vdXQtPm5yXS5wcmVmZXJyZWQgPSAwOwoJCWZhbm91dC0+bnIrKzsKCX0KfQoKc3RhdGljIHZvaWQgbWlkeF9mYW5vdXRfYWRkX3BhY2tfZmFub3V0KHN0cnVjdCBtaWR4X2Zhbm91dCAqZmFub3V0LAoJCQkJCXN0cnVjdCBwYWNrX2luZm8gKmluZm8sCgkJCQkJdWludDMyX3QgY3VyX3BhY2ssCgkJCQkJaW50IHByZWZlcnJlZCwKCQkJCQl1aW50MzJfdCBjdXJfZmFub3V0KQp7CglzdHJ1Y3QgcGFja2VkX2dpdCAqcGFjayA9IGluZm9bY3VyX3BhY2tdLnA7Cgl1aW50MzJfdCBzdGFydCA9IDAsIGVuZDsKCXVpbnQzMl90IGN1cl9vYmplY3Q7CgoJaWYgKGN1cl9mYW5vdXQpCgkJc3RhcnQgPSBnZXRfcGFja19mYW5vdXQocGFjaywgY3VyX2Zhbm91dCAtIDEpOwoJZW5kID0gZ2V0X3BhY2tfZmFub3V0KHBhY2ssIGN1cl9mYW5vdXQpOwoKCWZvciAoY3VyX29iamVjdCA9IHN0YXJ0OyBjdXJfb2JqZWN0IDwgZW5kOyBjdXJfb2JqZWN0KyspIHsKCQltaWR4X2Zhbm91dF9ncm93KGZhbm91dCwgZmFub3V0LT5uciArIDEpOwoJCWZpbGxfcGFja19lbnRyeShjdXJfcGFjaywKCQkJCWluZm9bY3VyX3BhY2tdLnAsCgkJCQljdXJfb2JqZWN0LAoJCQkJJmZhbm91dC0+ZW50cmllc1tmYW5vdXQtPm5yXSwKCQkJCXByZWZlcnJlZCk7CgkJZmFub3V0LT5ucisrOwoJfQp9CgovKgogKiBJdCBpcyBwb3NzaWJsZSB0byBhcnRpZmljaWFsbHkgZ2V0IGludG8gYSBzdGF0ZSB3aGVyZSB0aGVyZSBhcmUgbWFueQogKiBkdXBsaWNhdGUgY29waWVzIG9mIG9iamVjdHMuIFRoYXQgY2FuIGNyZWF0ZSBoaWdoIG1lbW9yeSBwcmVzc3VyZSBpZgogKiB3ZSBhcmUgdG8gY3JlYXRlIGEgbGlzdCBvZiBhbGwgb2JqZWN0cyBiZWZvcmUgZGUtZHVwbGljYXRpb24uIFRvIHJlZHVjZQogKiB0aGlzIG1lbW9yeSBwcmVzc3VyZSB3aXRob3V0IGEgc2lnbmlmaWNhbnQgcGVyZm9ybWFuY2UgZHJvcCwgYXV0b21hdGljYWxseQogKiBncm91cCBvYmplY3RzIGJ5IHRoZSBmaXJzdCBieXRlIG9mIHRoZWlyIG9iamVjdCBpZC4gVXNlIHRoZSBJRFggZmFub3V0CiAqIHRhYmxlcyB0byBncm91cCB0aGUgZGF0YSwgY29weSB0byBhIGxvY2FsIGFycmF5LCB0aGVuIHNvcnQuCiAqCiAqIENvcHkgb25seSB0aGUgZGUtZHVwbGljYXRlZCBlbnRyaWVzIChzZWxlY3RlZCBieSBtb3N0LXJlY2VudCBtb2RpZmllZCB0aW1lCiAqIG9mIGEgcGFja2ZpbGUgY29udGFpbmluZyB0aGUgb2JqZWN0KS4KICovCnN0YXRpYyB2b2lkIGNvbXB1dGVfc29ydGVkX2VudHJpZXMoc3RydWN0IHdyaXRlX21pZHhfY29udGV4dCAqY3R4LAoJCQkJICAgdWludDMyX3Qgc3RhcnRfcGFjaykKewoJdWludDMyX3QgY3VyX2Zhbm91dCwgY3VyX3BhY2ssIGN1cl9vYmplY3Q7CglzaXplX3QgYWxsb2Nfb2JqZWN0cywgdG90YWxfb2JqZWN0cyA9IDA7CglzdHJ1Y3QgbWlkeF9mYW5vdXQgZmFub3V0ID0geyAwIH07CgoJZm9yIChjdXJfcGFjayA9IHN0YXJ0X3BhY2s7IGN1cl9wYWNrIDwgY3R4LT5ucjsgY3VyX3BhY2srKykKCQl0b3RhbF9vYmplY3RzID0gc3RfYWRkKHRvdGFsX29iamVjdHMsCgkJCQkgICAgICAgY3R4LT5pbmZvW2N1cl9wYWNrXS5wLT5udW1fb2JqZWN0cyk7CgoJLyoKCSAqIEFzIHdlIGRlLWR1cGxpY2F0ZSBieSBmYW5vdXQgdmFsdWUsIHdlIGV4cGVjdCB0aGUgZmFub3V0CgkgKiBzbGljZXMgdG8gYmUgZXZlbmx5IGRpc3RyaWJ1dGVkLCB3aXRoIHNvbWUgbm9pc2UuIEhlbmNlLAoJICogYWxsb2NhdGUgc2xpZ2h0bHkgbW9yZSB0aGFuIG9uZSAyNTZ0aC4KCSAqLwoJYWxsb2Nfb2JqZWN0cyA9IGZhbm91dC5hbGxvYyA9IHRvdGFsX29iamVjdHMgPiAzMjAwID8gdG90YWxfb2JqZWN0cyAvIDIwMCA6IDE2OwoKCUFMTE9DX0FSUkFZKGZhbm91dC5lbnRyaWVzLCBmYW5vdXQuYWxsb2MpOwoJQUxMT0NfQVJSQVkoY3R4LT5lbnRyaWVzLCBhbGxvY19vYmplY3RzKTsKCWN0eC0+ZW50cmllc19uciA9IDA7CgoJZm9yIChjdXJfZmFub3V0ID0gMDsgY3VyX2Zhbm91dCA8IDI1NjsgY3VyX2Zhbm91dCsrKSB7CgkJZmFub3V0Lm5yID0gMDsKCgkJaWYgKGN0eC0+bSAmJiAhY3R4LT5pbmNyZW1lbnRhbCkKCQkJbWlkeF9mYW5vdXRfYWRkX21pZHhfZmFub3V0KCZmYW5vdXQsIGN0eC0+bSwgY3VyX2Zhbm91dCwKCQkJCQkJICAgIGN0eC0+cHJlZmVycmVkX3BhY2tfaWR4KTsKCgkJZm9yIChjdXJfcGFjayA9IHN0YXJ0X3BhY2s7IGN1cl9wYWNrIDwgY3R4LT5ucjsgY3VyX3BhY2srKykgewoJCQlpbnQgcHJlZmVycmVkID0gY3VyX3BhY2sgPT0gY3R4LT5wcmVmZXJyZWRfcGFja19pZHg7CgkJCW1pZHhfZmFub3V0X2FkZF9wYWNrX2Zhbm91dCgmZmFub3V0LAoJCQkJCQkgICAgY3R4LT5pbmZvLCBjdXJfcGFjaywKCQkJCQkJICAgIHByZWZlcnJlZCwgY3VyX2Zhbm91dCk7CgkJfQoKCQlpZiAoLTEgPCBjdHgtPnByZWZlcnJlZF9wYWNrX2lkeCAmJiBjdHgtPnByZWZlcnJlZF9wYWNrX2lkeCA8IHN0YXJ0X3BhY2spCgkJCW1pZHhfZmFub3V0X2FkZF9wYWNrX2Zhbm91dCgmZmFub3V0LCBjdHgtPmluZm8sCgkJCQkJCSAgICBjdHgtPnByZWZlcnJlZF9wYWNrX2lkeCwgMSwKCQkJCQkJICAgIGN1cl9mYW5vdXQpOwoKCQltaWR4X2Zhbm91dF9zb3J0KCZmYW5vdXQpOwoKCQkvKgoJCSAqIFRoZSBiYXRjaCBpcyBub3cgc29ydGVkIGJ5IE9JRCBhbmQgdGhlbiBtdGltZSAoZGVzY2VuZGluZykuCgkJICogVGFrZSBvbmx5IHRoZSBmaXJzdCBkdXBsaWNhdGUuCgkJICovCgkJZm9yIChjdXJfb2JqZWN0ID0gMDsgY3VyX29iamVjdCA8IGZhbm91dC5ucjsgY3VyX29iamVjdCsrKSB7CgkJCWlmIChjdXJfb2JqZWN0ICYmIG9pZGVxKCZmYW5vdXQuZW50cmllc1tjdXJfb2JqZWN0IC0gMV0ub2lkLAoJCQkJCQkmZmFub3V0LmVudHJpZXNbY3VyX29iamVjdF0ub2lkKSkKCQkJCWNvbnRpbnVlOwoJCQlpZiAoY3R4LT5pbmNyZW1lbnRhbCAmJiBjdHgtPmJhc2VfbWlkeCAmJgoJCQkgICAgbWlkeF9oYXNfb2lkKGN0eC0+YmFzZV9taWR4LAoJCQkJCSAmZmFub3V0LmVudHJpZXNbY3VyX29iamVjdF0ub2lkKSkKCQkJCWNvbnRpbnVlOwoKCQkJQUxMT0NfR1JPVyhjdHgtPmVudHJpZXMsIHN0X2FkZChjdHgtPmVudHJpZXNfbnIsIDEpLAoJCQkJICAgYWxsb2Nfb2JqZWN0cyk7CgkJCW1lbWNweSgmY3R4LT5lbnRyaWVzW2N0eC0+ZW50cmllc19ucl0sCgkJCSAgICAgICAmZmFub3V0LmVudHJpZXNbY3VyX29iamVjdF0sCgkJCSAgICAgICBzaXplb2Yoc3RydWN0IHBhY2tfbWlkeF9lbnRyeSkpOwoJCQljdHgtPmVudHJpZXNfbnIrKzsKCQl9Cgl9CgoJZnJlZShmYW5vdXQuZW50cmllcyk7Cn0KCnN0YXRpYyBpbnQgd3JpdGVfbWlkeF9wYWNrX25hbWVzKHN0cnVjdCBoYXNoZmlsZSAqZiwgdm9pZCAqZGF0YSkKewoJc3RydWN0IHdyaXRlX21pZHhfY29udGV4dCAqY3R4ID0gZGF0YTsKCXVpbnQzMl90IGk7Cgl1bnNpZ25lZCBjaGFyIHBhZGRpbmdbTUlEWF9DSFVOS19BTElHTk1FTlRdOwoJc2l6ZV90IHdyaXR0ZW4gPSAwOwoKCWZvciAoaSA9IDA7IGkgPCBjdHgtPm5yOyBpKyspIHsKCQlzaXplX3Qgd3JpdGVsZW47CgoJCWlmIChjdHgtPmluZm9baV0uZXhwaXJlZCkKCQkJY29udGludWU7CgoJCWlmIChpICYmIHN0cmNtcChjdHgtPmluZm9baV0ucGFja19uYW1lLCBjdHgtPmluZm9baSAtIDFdLnBhY2tfbmFtZSkgPD0gMCkKCQkJQlVHKCJpbmNvcnJlY3QgcGFjay1maWxlIG9yZGVyOiAlcyBiZWZvcmUgJXMiLAoJCQkgICAgY3R4LT5pbmZvW2kgLSAxXS5wYWNrX25hbWUsCgkJCSAgICBjdHgtPmluZm9baV0ucGFja19uYW1lKTsKCgkJd3JpdGVsZW4gPSBzdHJsZW4oY3R4LT5pbmZvW2ldLnBhY2tfbmFtZSkgKyAxOwoJCWhhc2h3cml0ZShmLCBjdHgtPmluZm9baV0ucGFja19uYW1lLCB3cml0ZWxlbik7CgkJd3JpdHRlbiArPSB3cml0ZWxlbjsKCX0KCgkvKiBhZGQgcGFkZGluZyB0byBiZSBhbGlnbmVkICovCglpID0gTUlEWF9DSFVOS19BTElHTk1FTlQgLSAod3JpdHRlbiAlIE1JRFhfQ0hVTktfQUxJR05NRU5UKTsKCWlmIChpIDwgTUlEWF9DSFVOS19BTElHTk1FTlQpIHsKCQltZW1zZXQocGFkZGluZywgMCwgc2l6ZW9mKHBhZGRpbmcpKTsKCQloYXNod3JpdGUoZiwgcGFkZGluZywgaSk7Cgl9CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgd3JpdGVfbWlkeF9iaXRtYXBwZWRfcGFja3Moc3RydWN0IGhhc2hmaWxlICpmLCB2b2lkICpkYXRhKQp7CglzdHJ1Y3Qgd3JpdGVfbWlkeF9jb250ZXh0ICpjdHggPSBkYXRhOwoJc2l6ZV90IGk7CgoJZm9yIChpID0gMDsgaSA8IGN0eC0+bnI7IGkrKykgewoJCXN0cnVjdCBwYWNrX2luZm8gKnBhY2sgPSAmY3R4LT5pbmZvW2ldOwoJCWlmIChwYWNrLT5leHBpcmVkKQoJCQljb250aW51ZTsKCgkJaWYgKHBhY2stPmJpdG1hcF9wb3MgPT0gQklUTUFQX1BPU19VTktOT1dOICYmIHBhY2stPmJpdG1hcF9ucikKCQkJQlVHKCJwYWNrICclcycgaGFzIG5vIGJpdG1hcCBwb3NpdGlvbiwgYnV0IGhhcyAlZCBiaXRtYXBwZWQgb2JqZWN0KHMpIiwKCQkJICAgIHBhY2stPnBhY2tfbmFtZSwgcGFjay0+Yml0bWFwX25yKTsKCgkJaGFzaHdyaXRlX2JlMzIoZiwgcGFjay0+Yml0bWFwX3Bvcyk7CgkJaGFzaHdyaXRlX2JlMzIoZiwgcGFjay0+Yml0bWFwX25yKTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHdyaXRlX21pZHhfb2lkX2Zhbm91dChzdHJ1Y3QgaGFzaGZpbGUgKmYsCgkJCQkgdm9pZCAqZGF0YSkKewoJc3RydWN0IHdyaXRlX21pZHhfY29udGV4dCAqY3R4ID0gZGF0YTsKCXN0cnVjdCBwYWNrX21pZHhfZW50cnkgKmxpc3QgPSBjdHgtPmVudHJpZXM7CglzdHJ1Y3QgcGFja19taWR4X2VudHJ5ICpsYXN0ID0gY3R4LT5lbnRyaWVzICsgY3R4LT5lbnRyaWVzX25yOwoJdWludDMyX3QgY291bnQgPSAwOwoJdWludDMyX3QgaTsKCgkvKgoJKiBXcml0ZSB0aGUgZmlyc3QtbGV2ZWwgdGFibGUgKHRoZSBsaXN0IGlzIHNvcnRlZCwKCSogYnV0IHdlIHVzZSBhIDI1Ni1lbnRyeSBsb29rdXAgdG8gYmUgYWJsZSB0byBhdm9pZAoJKiBoYXZpbmcgdG8gZG8gZWlnaHQgZXh0cmEgYmluYXJ5IHNlYXJjaCBpdGVyYXRpb25zKS4KCSovCglmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHsKCQlzdHJ1Y3QgcGFja19taWR4X2VudHJ5ICpuZXh0ID0gbGlzdDsKCgkJd2hpbGUgKG5leHQgPCBsYXN0ICYmIG5leHQtPm9pZC5oYXNoWzBdID09IGkpIHsKCQkJY291bnQrKzsKCQkJbmV4dCsrOwoJCX0KCgkJaGFzaHdyaXRlX2JlMzIoZiwgY291bnQpOwoJCWxpc3QgPSBuZXh0OwoJfQoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHdyaXRlX21pZHhfb2lkX2xvb2t1cChzdHJ1Y3QgaGFzaGZpbGUgKmYsCgkJCQkgdm9pZCAqZGF0YSkKewoJc3RydWN0IHdyaXRlX21pZHhfY29udGV4dCAqY3R4ID0gZGF0YTsKCXVuc2lnbmVkIGNoYXIgaGFzaF9sZW4gPSBjdHgtPnJlcG8tPmhhc2hfYWxnby0+cmF3c3o7CglzdHJ1Y3QgcGFja19taWR4X2VudHJ5ICpsaXN0ID0gY3R4LT5lbnRyaWVzOwoJdWludDMyX3QgaTsKCglmb3IgKGkgPSAwOyBpIDwgY3R4LT5lbnRyaWVzX25yOyBpKyspIHsKCQlzdHJ1Y3QgcGFja19taWR4X2VudHJ5ICpvYmogPSBsaXN0Kys7CgoJCWlmIChpIDwgY3R4LT5lbnRyaWVzX25yIC0gMSkgewoJCQlzdHJ1Y3QgcGFja19taWR4X2VudHJ5ICpuZXh0ID0gbGlzdDsKCQkJaWYgKG9pZGNtcCgmb2JqLT5vaWQsICZuZXh0LT5vaWQpID49IDApCgkJCQlCVUcoIk9JRHMgbm90IGluIG9yZGVyOiAlcyA+PSAlcyIsCgkJCQkgICAgb2lkX3RvX2hleCgmb2JqLT5vaWQpLAoJCQkJICAgIG9pZF90b19oZXgoJm5leHQtPm9pZCkpOwoJCX0KCgkJaGFzaHdyaXRlKGYsIG9iai0+b2lkLmhhc2gsIChpbnQpaGFzaF9sZW4pOwoJfQoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHdyaXRlX21pZHhfb2JqZWN0X29mZnNldHMoc3RydWN0IGhhc2hmaWxlICpmLAoJCQkJICAgICB2b2lkICpkYXRhKQp7CglzdHJ1Y3Qgd3JpdGVfbWlkeF9jb250ZXh0ICpjdHggPSBkYXRhOwoJc3RydWN0IHBhY2tfbWlkeF9lbnRyeSAqbGlzdCA9IGN0eC0+ZW50cmllczsKCXVpbnQzMl90IGksIG5yX2xhcmdlX29mZnNldCA9IDA7CgoJZm9yIChpID0gMDsgaSA8IGN0eC0+ZW50cmllc19ucjsgaSsrKSB7CgkJc3RydWN0IHBhY2tfbWlkeF9lbnRyeSAqb2JqID0gbGlzdCsrOwoKCQlpZiAoY3R4LT5wYWNrX3Blcm1bb2JqLT5wYWNrX2ludF9pZF0gPT0gUEFDS19FWFBJUkVEKQoJCQlCVUcoIm9iamVjdCAlcyBpcyBpbiBhbiBleHBpcmVkIHBhY2sgd2l0aCBpbnQtaWQgJWQiLAoJCQkgICAgb2lkX3RvX2hleCgmb2JqLT5vaWQpLAoJCQkgICAgb2JqLT5wYWNrX2ludF9pZCk7CgoJCWhhc2h3cml0ZV9iZTMyKGYsIGN0eC0+cGFja19wZXJtW29iai0+cGFja19pbnRfaWRdKTsKCgkJaWYgKGN0eC0+bGFyZ2Vfb2Zmc2V0c19uZWVkZWQgJiYgb2JqLT5vZmZzZXQgPj4gMzEpCgkJCWhhc2h3cml0ZV9iZTMyKGYsIE1JRFhfTEFSR0VfT0ZGU0VUX05FRURFRCB8IG5yX2xhcmdlX29mZnNldCsrKTsKCQllbHNlIGlmICghY3R4LT5sYXJnZV9vZmZzZXRzX25lZWRlZCAmJiBvYmotPm9mZnNldCA+PiAzMikKCQkJQlVHKCJvYmplY3QgJXMgcmVxdWlyZXMgYSBsYXJnZSBvZmZzZXQgKCUiUFJJeDY0IikgYnV0IHRoZSBNSURYIGlzIG5vdCB3cml0aW5nIGxhcmdlIG9mZnNldHMhIiwKCQkJICAgIG9pZF90b19oZXgoJm9iai0+b2lkKSwKCQkJICAgIG9iai0+b2Zmc2V0KTsKCQllbHNlCgkJCWhhc2h3cml0ZV9iZTMyKGYsICh1aW50MzJfdClvYmotPm9mZnNldCk7Cgl9CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgd3JpdGVfbWlkeF9sYXJnZV9vZmZzZXRzKHN0cnVjdCBoYXNoZmlsZSAqZiwKCQkJCSAgICB2b2lkICpkYXRhKQp7CglzdHJ1Y3Qgd3JpdGVfbWlkeF9jb250ZXh0ICpjdHggPSBkYXRhOwoJc3RydWN0IHBhY2tfbWlkeF9lbnRyeSAqbGlzdCA9IGN0eC0+ZW50cmllczsKCXN0cnVjdCBwYWNrX21pZHhfZW50cnkgKmVuZCA9IGN0eC0+ZW50cmllcyArIGN0eC0+ZW50cmllc19ucjsKCXVpbnQzMl90IG5yX2xhcmdlX29mZnNldCA9IGN0eC0+bnVtX2xhcmdlX29mZnNldHM7CgoJd2hpbGUgKG5yX2xhcmdlX29mZnNldCkgewoJCXN0cnVjdCBwYWNrX21pZHhfZW50cnkgKm9iajsKCQl1aW50NjRfdCBvZmZzZXQ7CgoJCWlmIChsaXN0ID49IGVuZCkKCQkJQlVHKCJ0b28gbWFueSBsYXJnZS1vZmZzZXQgb2JqZWN0cyIpOwoKCQlvYmogPSBsaXN0Kys7CgkJb2Zmc2V0ID0gb2JqLT5vZmZzZXQ7CgoJCWlmICghKG9mZnNldCA+PiAzMSkpCgkJCWNvbnRpbnVlOwoKCQloYXNod3JpdGVfYmU2NChmLCBvZmZzZXQpOwoKCQlucl9sYXJnZV9vZmZzZXQtLTsKCX0KCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCB3cml0ZV9taWR4X3JldmluZGV4KHN0cnVjdCBoYXNoZmlsZSAqZiwKCQkJICAgICAgIHZvaWQgKmRhdGEpCnsKCXN0cnVjdCB3cml0ZV9taWR4X2NvbnRleHQgKmN0eCA9IGRhdGE7Cgl1aW50MzJfdCBpLCBucl9iYXNlOwoKCWlmIChjdHgtPmluY3JlbWVudGFsICYmIGN0eC0+YmFzZV9taWR4KQoJCW5yX2Jhc2UgPSBjdHgtPmJhc2VfbWlkeC0+bnVtX29iamVjdHMgKwoJCQljdHgtPmJhc2VfbWlkeC0+bnVtX29iamVjdHNfaW5fYmFzZTsKCWVsc2UKCQlucl9iYXNlID0gMDsKCglmb3IgKGkgPSAwOyBpIDwgY3R4LT5lbnRyaWVzX25yOyBpKyspCgkJaGFzaHdyaXRlX2JlMzIoZiwgY3R4LT5wYWNrX29yZGVyW2ldICsgbnJfYmFzZSk7CgoJcmV0dXJuIDA7Cn0KCnN0cnVjdCBtaWR4X3BhY2tfb3JkZXJfZGF0YSB7Cgl1aW50MzJfdCBucjsKCXVpbnQzMl90IHBhY2s7CglvZmZfdCBvZmZzZXQ7Cn07CgpzdGF0aWMgaW50IG1pZHhfcGFja19vcmRlcl9jbXAoY29uc3Qgdm9pZCAqdmEsIGNvbnN0IHZvaWQgKnZiKQp7Cgljb25zdCBzdHJ1Y3QgbWlkeF9wYWNrX29yZGVyX2RhdGEgKmEgPSB2YSwgKmIgPSB2YjsKCWlmIChhLT5wYWNrIDwgYi0+cGFjaykKCQlyZXR1cm4gLTE7CgllbHNlIGlmIChhLT5wYWNrID4gYi0+cGFjaykKCQlyZXR1cm4gMTsKCWVsc2UgaWYgKGEtPm9mZnNldCA8IGItPm9mZnNldCkKCQlyZXR1cm4gLTE7CgllbHNlIGlmIChhLT5vZmZzZXQgPiBiLT5vZmZzZXQpCgkJcmV0dXJuIDE7CgllbHNlCgkJcmV0dXJuIDA7Cn0KCnN0YXRpYyB1aW50MzJfdCAqbWlkeF9wYWNrX29yZGVyKHN0cnVjdCB3cml0ZV9taWR4X2NvbnRleHQgKmN0eCkKewoJc3RydWN0IG1pZHhfcGFja19vcmRlcl9kYXRhICpkYXRhOwoJdWludDMyX3QgKnBhY2tfb3JkZXIsIGJhc2Vfb2JqZWN0cyA9IDA7Cgl1aW50MzJfdCBpOwoKCXRyYWNlMl9yZWdpb25fZW50ZXIoIm1pZHgiLCAibWlkeF9wYWNrX29yZGVyIiwgY3R4LT5yZXBvKTsKCglpZiAoY3R4LT5pbmNyZW1lbnRhbCAmJiBjdHgtPmJhc2VfbWlkeCkKCQliYXNlX29iamVjdHMgPSBjdHgtPmJhc2VfbWlkeC0+bnVtX29iamVjdHMgKwoJCQljdHgtPmJhc2VfbWlkeC0+bnVtX29iamVjdHNfaW5fYmFzZTsKCglBTExPQ19BUlJBWShwYWNrX29yZGVyLCBjdHgtPmVudHJpZXNfbnIpOwoJQUxMT0NfQVJSQVkoZGF0YSwgY3R4LT5lbnRyaWVzX25yKTsKCglmb3IgKGkgPSAwOyBpIDwgY3R4LT5lbnRyaWVzX25yOyBpKyspIHsKCQlzdHJ1Y3QgcGFja19taWR4X2VudHJ5ICplID0gJmN0eC0+ZW50cmllc1tpXTsKCQlkYXRhW2ldLm5yID0gaTsKCQlkYXRhW2ldLnBhY2sgPSBjdHgtPnBhY2tfcGVybVtlLT5wYWNrX2ludF9pZF07CgkJaWYgKCFlLT5wcmVmZXJyZWQpCgkJCWRhdGFbaV0ucGFjayB8PSAoMVUgPDwgMzEpOwoJCWRhdGFbaV0ub2Zmc2V0ID0gZS0+b2Zmc2V0OwoJfQoKCVFTT1JUKGRhdGEsIGN0eC0+ZW50cmllc19uciwgbWlkeF9wYWNrX29yZGVyX2NtcCk7CgoJZm9yIChpID0gMDsgaSA8IGN0eC0+ZW50cmllc19ucjsgaSsrKSB7CgkJc3RydWN0IHBhY2tfbWlkeF9lbnRyeSAqZSA9ICZjdHgtPmVudHJpZXNbZGF0YVtpXS5ucl07CgkJc3RydWN0IHBhY2tfaW5mbyAqcGFjayA9ICZjdHgtPmluZm9bY3R4LT5wYWNrX3Blcm1bZS0+cGFja19pbnRfaWRdXTsKCQlpZiAocGFjay0+Yml0bWFwX3BvcyA9PSBCSVRNQVBfUE9TX1VOS05PV04pCgkJCXBhY2stPmJpdG1hcF9wb3MgPSBpICsgYmFzZV9vYmplY3RzOwoJCXBhY2stPmJpdG1hcF9ucisrOwoJCXBhY2tfb3JkZXJbaV0gPSBkYXRhW2ldLm5yOwoJfQoJZm9yIChpID0gMDsgaSA8IGN0eC0+bnI7IGkrKykgewoJCXN0cnVjdCBwYWNrX2luZm8gKnBhY2sgPSAmY3R4LT5pbmZvW2N0eC0+cGFja19wZXJtW2ldXTsKCQlpZiAocGFjay0+Yml0bWFwX3BvcyA9PSBCSVRNQVBfUE9TX1VOS05PV04pCgkJCXBhY2stPmJpdG1hcF9wb3MgPSAwOwoJfQoJZnJlZShkYXRhKTsKCgl0cmFjZTJfcmVnaW9uX2xlYXZlKCJtaWR4IiwgIm1pZHhfcGFja19vcmRlciIsIGN0eC0+cmVwbyk7CgoJcmV0dXJuIHBhY2tfb3JkZXI7Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX21pZHhfcmV2ZXJzZV9pbmRleChjaGFyICptaWR4X25hbWUsIHVuc2lnbmVkIGNoYXIgKm1pZHhfaGFzaCwKCQkJCSAgICAgc3RydWN0IHdyaXRlX21pZHhfY29udGV4dCAqY3R4KQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJY2hhciAqdG1wX2ZpbGU7CgoJdHJhY2UyX3JlZ2lvbl9lbnRlcigibWlkeCIsICJ3cml0ZV9taWR4X3JldmVyc2VfaW5kZXgiLCBjdHgtPnJlcG8pOwoKCXN0cmJ1Zl9hZGRmKCZidWYsICIlcy0lcy5yZXYiLCBtaWR4X25hbWUsIGhhc2hfdG9faGV4X2FsZ29wKG1pZHhfaGFzaCwKCQkJCQkJCQkgICAgY3R4LT5yZXBvLT5oYXNoX2FsZ28pKTsKCgl0bXBfZmlsZSA9IHdyaXRlX3Jldl9maWxlX29yZGVyKE5VTEwsIGN0eC0+cGFja19vcmRlciwgY3R4LT5lbnRyaWVzX25yLAoJCQkJCW1pZHhfaGFzaCwgV1JJVEVfUkVWKTsKCglpZiAoZmluYWxpemVfb2JqZWN0X2ZpbGUodG1wX2ZpbGUsIGJ1Zi5idWYpKQoJCWRpZShfKCJjYW5ub3Qgc3RvcmUgcmV2ZXJzZSBpbmRleCBmaWxlIikpOwoKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJZnJlZSh0bXBfZmlsZSk7CgoJdHJhY2UyX3JlZ2lvbl9sZWF2ZSgibWlkeCIsICJ3cml0ZV9taWR4X3JldmVyc2VfaW5kZXgiLCBjdHgtPnJlcG8pOwp9CgpzdGF0aWMgdm9pZCBwcmVwYXJlX21pZHhfcGFja2luZ19kYXRhKHN0cnVjdCBwYWNraW5nX2RhdGEgKnBkYXRhLAoJCQkJICAgICAgc3RydWN0IHdyaXRlX21pZHhfY29udGV4dCAqY3R4KQp7Cgl1aW50MzJfdCBpOwoKCXRyYWNlMl9yZWdpb25fZW50ZXIoIm1pZHgiLCAicHJlcGFyZV9taWR4X3BhY2tpbmdfZGF0YSIsIGN0eC0+cmVwbyk7CgoJbWVtc2V0KHBkYXRhLCAwLCBzaXplb2Yoc3RydWN0IHBhY2tpbmdfZGF0YSkpOwoJcHJlcGFyZV9wYWNraW5nX2RhdGEoY3R4LT5yZXBvLCBwZGF0YSk7CgoJZm9yIChpID0gMDsgaSA8IGN0eC0+ZW50cmllc19ucjsgaSsrKSB7CgkJdWludDMyX3QgcG9zID0gY3R4LT5wYWNrX29yZGVyW2ldOwoJCXN0cnVjdCBwYWNrX21pZHhfZW50cnkgKmZyb20gPSAmY3R4LT5lbnRyaWVzW3Bvc107CgkJc3RydWN0IG9iamVjdF9lbnRyeSAqdG8gPSBwYWNrbGlzdF9hbGxvYyhwZGF0YSwgJmZyb20tPm9pZCk7CgoJCW9lX3NldF9pbl9wYWNrKHBkYXRhLCB0bywKCQkJICAgICAgIGN0eC0+aW5mb1tjdHgtPnBhY2tfcGVybVtmcm9tLT5wYWNrX2ludF9pZF1dLnApOwoJfQoKCXRyYWNlMl9yZWdpb25fbGVhdmUoIm1pZHgiLCAicHJlcGFyZV9taWR4X3BhY2tpbmdfZGF0YSIsIGN0eC0+cmVwbyk7Cn0KCnN0YXRpYyBpbnQgYWRkX3JlZl90b19wZW5kaW5nKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IGNoYXIgKnJlZmVyZW50IFVOVVNFRCwKCQkJICAgICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgICAgICBpbnQgZmxhZywgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IHJldl9pbmZvICpyZXZzID0gKHN0cnVjdCByZXZfaW5mbyopY2JfZGF0YTsKCXN0cnVjdCBvYmplY3RfaWQgcGVlbGVkOwoJc3RydWN0IG9iamVjdCAqb2JqZWN0OwoKCWlmICgoZmxhZyAmIFJFRl9JU1NZTVJFRikgJiYgKGZsYWcgJiBSRUZfSVNCUk9LRU4pKSB7CgkJd2FybmluZygic3ltYm9saWMgcmVmIGlzIGRhbmdsaW5nOiAlcyIsIHJlZm5hbWUpOwoJCXJldHVybiAwOwoJfQoKCWlmICghcGVlbF9pdGVyYXRlZF9vaWQocmV2cy0+cmVwbywgb2lkLCAmcGVlbGVkKSkKCQlvaWQgPSAmcGVlbGVkOwoKCW9iamVjdCA9IHBhcnNlX29iamVjdF9vcl9kaWUob2lkLCByZWZuYW1lKTsKCWlmIChvYmplY3QtPnR5cGUgIT0gT0JKX0NPTU1JVCkKCQlyZXR1cm4gMDsKCglhZGRfcGVuZGluZ19vYmplY3QocmV2cywgb2JqZWN0LCAiIik7CglpZiAoYml0bWFwX2lzX3ByZWZlcnJlZF9yZWZuYW1lKHJldnMtPnJlcG8sIHJlZm5hbWUpKQoJCW9iamVjdC0+ZmxhZ3MgfD0gTkVFRFNfQklUTUFQOwoJcmV0dXJuIDA7Cn0KCnN0cnVjdCBiaXRtYXBfY29tbWl0X2NiIHsKCXN0cnVjdCBjb21taXQgKipjb21taXRzOwoJc2l6ZV90IGNvbW1pdHNfbnIsIGNvbW1pdHNfYWxsb2M7CgoJc3RydWN0IHdyaXRlX21pZHhfY29udGV4dCAqY3R4Owp9OwoKc3RhdGljIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKmJpdG1hcF9vaWRfYWNjZXNzKHNpemVfdCBpbmRleCwKCQkJCQkJIGNvbnN0IHZvaWQgKl9lbnRyaWVzKQp7Cgljb25zdCBzdHJ1Y3QgcGFja19taWR4X2VudHJ5ICplbnRyaWVzID0gX2VudHJpZXM7CglyZXR1cm4gJmVudHJpZXNbaW5kZXhdLm9pZDsKfQoKc3RhdGljIHZvaWQgYml0bWFwX3Nob3dfY29tbWl0KHN0cnVjdCBjb21taXQgKmNvbW1pdCwgdm9pZCAqX2RhdGEpCnsKCXN0cnVjdCBiaXRtYXBfY29tbWl0X2NiICpkYXRhID0gX2RhdGE7CglpbnQgcG9zID0gb2lkX3BvcygmY29tbWl0LT5vYmplY3Qub2lkLCBkYXRhLT5jdHgtPmVudHJpZXMsCgkJCSAgZGF0YS0+Y3R4LT5lbnRyaWVzX25yLAoJCQkgIGJpdG1hcF9vaWRfYWNjZXNzKTsKCWlmIChwb3MgPCAwKQoJCXJldHVybjsKCglBTExPQ19HUk9XKGRhdGEtPmNvbW1pdHMsIGRhdGEtPmNvbW1pdHNfbnIgKyAxLCBkYXRhLT5jb21taXRzX2FsbG9jKTsKCWRhdGEtPmNvbW1pdHNbZGF0YS0+Y29tbWl0c19ucisrXSA9IGNvbW1pdDsKfQoKc3RhdGljIGludCByZWFkX3JlZnNfc25hcHNob3QoY29uc3QgY2hhciAqcmVmc19zbmFwc2hvdCwKCQkJICAgICAgc3RydWN0IHJldl9pbmZvICpyZXZzKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CglGSUxFICpmID0geGZvcGVuKHJlZnNfc25hcHNob3QsICJyIik7CgoJd2hpbGUgKHN0cmJ1Zl9nZXRsaW5lKCZidWYsIGYpICE9IEVPRikgewoJCXN0cnVjdCBvYmplY3QgKm9iamVjdDsKCQlpbnQgcHJlZmVycmVkID0gMDsKCQljaGFyICpoZXggPSBidWYuYnVmOwoJCWNvbnN0IGNoYXIgKmVuZCA9IE5VTEw7CgoJCWlmIChidWYubGVuICYmICpidWYuYnVmID09ICcrJykgewoJCQlwcmVmZXJyZWQgPSAxOwoJCQloZXggPSAmYnVmLmJ1ZlsxXTsKCQl9CgoJCWlmIChwYXJzZV9vaWRfaGV4X2FsZ29wKGhleCwgJm9pZCwgJmVuZCwgcmV2cy0+cmVwby0+aGFzaF9hbGdvKSA8IDApCgkJCWRpZShfKCJjb3VsZCBub3QgcGFyc2UgbGluZTogJXMiKSwgYnVmLmJ1Zik7CgkJaWYgKCplbmQpCgkJCWRpZShfKCJtYWxmb3JtZWQgbGluZTogJXMiKSwgYnVmLmJ1Zik7CgoJCW9iamVjdCA9IHBhcnNlX29iamVjdF9vcl9kaWUoJm9pZCwgTlVMTCk7CgkJaWYgKHByZWZlcnJlZCkKCQkJb2JqZWN0LT5mbGFncyB8PSBORUVEU19CSVRNQVA7CgoJCWFkZF9wZW5kaW5nX29iamVjdChyZXZzLCBvYmplY3QsICIiKTsKCX0KCglmY2xvc2UoZik7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgc3RydWN0IGNvbW1pdCAqKmZpbmRfY29tbWl0c19mb3JfbWlkeF9iaXRtYXAodWludDMyX3QgKmluZGV4ZWRfY29tbWl0c19ucl9wLAoJCQkJCQkgICAgY29uc3QgY2hhciAqcmVmc19zbmFwc2hvdCwKCQkJCQkJICAgIHN0cnVjdCB3cml0ZV9taWR4X2NvbnRleHQgKmN0eCkKewoJc3RydWN0IHJldl9pbmZvIHJldnM7CglzdHJ1Y3QgYml0bWFwX2NvbW1pdF9jYiBjYiA9IHswfTsKCgl0cmFjZTJfcmVnaW9uX2VudGVyKCJtaWR4IiwgImZpbmRfY29tbWl0c19mb3JfbWlkeF9iaXRtYXAiLCBjdHgtPnJlcG8pOwoKCWNiLmN0eCA9IGN0eDsKCglyZXBvX2luaXRfcmV2aXNpb25zKGN0eC0+cmVwbywgJnJldnMsIE5VTEwpOwoJaWYgKHJlZnNfc25hcHNob3QpIHsKCQlyZWFkX3JlZnNfc25hcHNob3QocmVmc19zbmFwc2hvdCwgJnJldnMpOwoJfSBlbHNlIHsKCQlzZXR1cF9yZXZpc2lvbnMoMCwgTlVMTCwgJnJldnMsIE5VTEwpOwoJCXJlZnNfZm9yX2VhY2hfcmVmKGdldF9tYWluX3JlZl9zdG9yZShjdHgtPnJlcG8pLAoJCQkJICBhZGRfcmVmX3RvX3BlbmRpbmcsICZyZXZzKTsKCX0KCgkvKgoJICogU2tpcHBpbmcgcHJvbWlzb3Igb2JqZWN0cyBoZXJlIGlzIGludGVudGlvbmFsLCBzaW5jZSBpdCBvbmx5IGV4Y2x1ZGVzCgkgKiB0aGVtIGZyb20gdGhlIGxpc3Qgb2YgcmVhY2hhYmxlIGNvbW1pdHMgdGhhdCB3ZSB3YW50IHRvIHNlbGVjdCBmcm9tCgkgKiB3aGVuIGNvbXB1dGluZyB0aGUgc2VsZWN0aW9uIG9mIE1JRFgnZCBjb21taXRzIHRvIHJlY2VpdmUgYml0bWFwcy4KCSAqCgkgKiBSZWFjaGFiaWxpdHkgYml0bWFwcyBkbyByZXF1aXJlIHRoYXQgdGhlaXIgb2JqZWN0cyBiZSBjbG9zZWQgdW5kZXIKCSAqIHJlYWNoYWJpbGl0eSwgYnV0IGZldGNoaW5nIGFueSBvYmplY3RzIG1pc3NpbmcgZnJvbSBwcm9taXNvcnMgYXQgdGhpcwoJICogcG9pbnQgaXMgdG9vIGxhdGUuIEJ1dCwgaWYgb25lIG9mIHRob3NlIG9iamVjdHMgY2FuIGJlIHJlYWNoZWQgZnJvbQoJICogYW4gYW5vdGhlciBvYmplY3QgdGhhdCBpcyBpbmNsdWRlZCBpbiB0aGUgYml0bWFwLCB0aGVuIHdlIHdpbGwKCSAqIGNvbXBsYWluIGxhdGVyIHRoYXQgd2UgZG9uJ3QgaGF2ZSByZWFjaGFiaWxpdHkgY2xvc3VyZSAoYW5kIGZhaWwKCSAqIGFwcHJvcHJpYXRlbHkpLgoJICovCglmZXRjaF9pZl9taXNzaW5nID0gMDsKCXJldnMuZXhjbHVkZV9wcm9taXNvcl9vYmplY3RzID0gMTsKCglpZiAocHJlcGFyZV9yZXZpc2lvbl93YWxrKCZyZXZzKSkKCQlkaWUoXygicmV2aXNpb24gd2FsayBzZXR1cCBmYWlsZWQiKSk7CgoJdHJhdmVyc2VfY29tbWl0X2xpc3QoJnJldnMsIGJpdG1hcF9zaG93X2NvbW1pdCwgTlVMTCwgJmNiKTsKCWlmIChpbmRleGVkX2NvbW1pdHNfbnJfcCkKCQkqaW5kZXhlZF9jb21taXRzX25yX3AgPSBjYi5jb21taXRzX25yOwoKCXJlbGVhc2VfcmV2aXNpb25zKCZyZXZzKTsKCgl0cmFjZTJfcmVnaW9uX2xlYXZlKCJtaWR4IiwgImZpbmRfY29tbWl0c19mb3JfbWlkeF9iaXRtYXAiLCBjdHgtPnJlcG8pOwoKCXJldHVybiBjYi5jb21taXRzOwp9CgpzdGF0aWMgaW50IHdyaXRlX21pZHhfYml0bWFwKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBjb25zdCBjaGFyICptaWR4X25hbWUsCgkJCSAgICAgY29uc3QgdW5zaWduZWQgY2hhciAqbWlkeF9oYXNoLAoJCQkgICAgIHN0cnVjdCBwYWNraW5nX2RhdGEgKnBkYXRhLAoJCQkgICAgIHN0cnVjdCBjb21taXQgKipjb21taXRzLAoJCQkgICAgIHVpbnQzMl90IGNvbW1pdHNfbnIsCgkJCSAgICAgdWludDMyX3QgKnBhY2tfb3JkZXIsCgkJCSAgICAgdW5zaWduZWQgZmxhZ3MpCnsKCWludCByZXQsIGk7Cgl1aW50MTZfdCBvcHRpb25zID0gMDsKCXN0cnVjdCBiaXRtYXBfd3JpdGVyIHdyaXRlcjsKCXN0cnVjdCBwYWNrX2lkeF9lbnRyeSAqKmluZGV4OwoJY2hhciAqYml0bWFwX25hbWUgPSB4c3RyZm10KCIlcy0lcy5iaXRtYXAiLCBtaWR4X25hbWUsCgkJCQkgICAgaGFzaF90b19oZXhfYWxnb3AobWlkeF9oYXNoLCByLT5oYXNoX2FsZ28pKTsKCgl0cmFjZTJfcmVnaW9uX2VudGVyKCJtaWR4IiwgIndyaXRlX21pZHhfYml0bWFwIiwgcik7CgoJaWYgKGZsYWdzICYgTUlEWF9XUklURV9CSVRNQVBfSEFTSF9DQUNIRSkKCQlvcHRpb25zIHw9IEJJVE1BUF9PUFRfSEFTSF9DQUNIRTsKCglpZiAoZmxhZ3MgJiBNSURYX1dSSVRFX0JJVE1BUF9MT09LVVBfVEFCTEUpCgkJb3B0aW9ucyB8PSBCSVRNQVBfT1BUX0xPT0tVUF9UQUJMRTsKCgkvKgoJICogQnVpbGQgdGhlIE1JRFgtb3JkZXIgaW5kZXggYmFzZWQgb24gcGRhdGEub2JqZWN0cyAod2hpY2ggaXMgYWxyZWFkeQoJICogaW4gTUlEWCBvcmRlcjsgYy5mLiwgJ21pZHhfcGFja19vcmRlcl9jbXAoKScgZm9yIHRoZSBkZWZpbml0aW9uIG9mCgkgKiB0aGlzIG9yZGVyKS4KCSAqLwoJQUxMT0NfQVJSQVkoaW5kZXgsIHBkYXRhLT5ucl9vYmplY3RzKTsKCWZvciAoaSA9IDA7IGkgPCBwZGF0YS0+bnJfb2JqZWN0czsgaSsrKQoJCWluZGV4W2ldID0gJnBkYXRhLT5vYmplY3RzW2ldLmlkeDsKCgliaXRtYXBfd3JpdGVyX2luaXQoJndyaXRlciwgciwgcGRhdGEpOwoJYml0bWFwX3dyaXRlcl9zaG93X3Byb2dyZXNzKCZ3cml0ZXIsIGZsYWdzICYgTUlEWF9QUk9HUkVTUyk7CgliaXRtYXBfd3JpdGVyX2J1aWxkX3R5cGVfaW5kZXgoJndyaXRlciwgaW5kZXgpOwoKCS8qCgkgKiBiaXRtYXBfd3JpdGVyX2ZpbmlzaCBleHBlY3RzIG9iamVjdHMgaW4gbGV4IG9yZGVyLCBidXQgcGFja19vcmRlcgoJICogZ2l2ZXMgdXMgZXhhY3RseSB0aGF0LiB1c2UgaXQgZGlyZWN0bHkgaW5zdGVhZCBvZiByZS1zb3J0aW5nIHRoZQoJICogYXJyYXkuCgkgKgoJICogVGhpcyBjaGFuZ2VzIHRoZSBvcmRlciBvZiBvYmplY3RzIGluICdpbmRleCcgYmV0d2VlbgoJICogYml0bWFwX3dyaXRlcl9idWlsZF90eXBlX2luZGV4IGFuZCBiaXRtYXBfd3JpdGVyX2ZpbmlzaC4KCSAqCgkgKiBUaGUgc2FtZSByZS1vcmRlcmluZyB0YWtlcyBwbGFjZSBpbiB0aGUgc2luZ2xlLXBhY2sgYml0bWFwIGNvZGUgdmlhCgkgKiB3cml0ZV9pZHhfZmlsZSgpLCB3aGljaCBpcyBjYWxsZWQgYnkgZmluaXNoX3RtcF9wYWNrZmlsZSgpLCB3aGljaAoJICogaGFwcGVucyBiZXR3ZWVuIGJpdG1hcF93cml0ZXJfYnVpbGRfdHlwZV9pbmRleCgpIGFuZAoJICogYml0bWFwX3dyaXRlcl9maW5pc2goKS4KCSAqLwoJZm9yIChpID0gMDsgaSA8IHBkYXRhLT5ucl9vYmplY3RzOyBpKyspCgkJaW5kZXhbcGFja19vcmRlcltpXV0gPSAmcGRhdGEtPm9iamVjdHNbaV0uaWR4OwoKCWJpdG1hcF93cml0ZXJfc2VsZWN0X2NvbW1pdHMoJndyaXRlciwgY29tbWl0cywgY29tbWl0c19ucik7CglyZXQgPSBiaXRtYXBfd3JpdGVyX2J1aWxkKCZ3cml0ZXIpOwoJaWYgKHJldCA8IDApCgkJZ290byBjbGVhbnVwOwoKCWJpdG1hcF93cml0ZXJfc2V0X2NoZWNrc3VtKCZ3cml0ZXIsIG1pZHhfaGFzaCk7CgliaXRtYXBfd3JpdGVyX2ZpbmlzaCgmd3JpdGVyLCBpbmRleCwgYml0bWFwX25hbWUsIG9wdGlvbnMpOwoKY2xlYW51cDoKCWZyZWUoaW5kZXgpOwoJZnJlZShiaXRtYXBfbmFtZSk7CgliaXRtYXBfd3JpdGVyX2ZyZWUoJndyaXRlcik7CgoJdHJhY2UyX3JlZ2lvbl9sZWF2ZSgibWlkeCIsICJ3cml0ZV9taWR4X2JpdG1hcCIsIHIpOwoKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBzdHJ1Y3QgbXVsdGlfcGFja19pbmRleCAqbG9va3VwX211bHRpX3BhY2tfaW5kZXgoc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCQkJCQljb25zdCBjaGFyICpvYmplY3RfZGlyKQp7CglzdHJ1Y3QgbXVsdGlfcGFja19pbmRleCAqcmVzdWx0ID0gTlVMTDsKCXN0cnVjdCBtdWx0aV9wYWNrX2luZGV4ICpjdXI7CgljaGFyICpvYmpfZGlyX3JlYWwgPSByZWFsX3BhdGhkdXAob2JqZWN0X2RpciwgMSk7CglzdHJ1Y3Qgc3RyYnVmIGN1cl9wYXRoX3JlYWwgPSBTVFJCVUZfSU5JVDsKCgkvKiBFbnN1cmUgdGhlIGdpdmVuIG9iamVjdF9kaXIgaXMgbG9jYWwsIG9yIGEga25vd24gYWx0ZXJuYXRlLiAqLwoJZmluZF9vZGIociwgb2JqX2Rpcl9yZWFsKTsKCglmb3IgKGN1ciA9IGdldF9tdWx0aV9wYWNrX2luZGV4KHIpOyBjdXI7IGN1ciA9IGN1ci0+bmV4dCkgewoJCXN0cmJ1Zl9yZWFscGF0aCgmY3VyX3BhdGhfcmVhbCwgY3VyLT5vYmplY3RfZGlyLCAxKTsKCQlpZiAoIXN0cmNtcChvYmpfZGlyX3JlYWwsIGN1cl9wYXRoX3JlYWwuYnVmKSkgewoJCQlyZXN1bHQgPSBjdXI7CgkJCWdvdG8gY2xlYW51cDsKCQl9Cgl9CgpjbGVhbnVwOgoJZnJlZShvYmpfZGlyX3JlYWwpOwoJc3RyYnVmX3JlbGVhc2UoJmN1cl9wYXRoX3JlYWwpOwoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIGludCBmaWxsX3BhY2tzX2Zyb21fbWlkeChzdHJ1Y3Qgd3JpdGVfbWlkeF9jb250ZXh0ICpjdHgsCgkJCQljb25zdCBjaGFyICpwcmVmZXJyZWRfcGFja19uYW1lLCB1aW50MzJfdCBmbGFncykKewoJc3RydWN0IG11bHRpX3BhY2tfaW5kZXggKm07CgoJZm9yIChtID0gY3R4LT5tOyBtOyBtID0gbS0+YmFzZV9taWR4KSB7CgkJdWludDMyX3QgaTsKCgkJZm9yIChpID0gMDsgaSA8IG0tPm51bV9wYWNrczsgaSsrKSB7CgkJCUFMTE9DX0dST1coY3R4LT5pbmZvLCBjdHgtPm5yICsgMSwgY3R4LT5hbGxvYyk7CgoJCQkvKgoJCQkgKiBJZiBnZW5lcmF0aW5nIGEgcmV2ZXJzZSBpbmRleCwgbmVlZCB0byBoYXZlCgkJCSAqIHBhY2tlZF9naXQncyBsb2FkZWQgdG8gY29tcGFyZSB0aGVpcgoJCQkgKiBtdGltZXMgYW5kIG9iamVjdCBjb3VudC4KCQkJICoKCQkJICogSWYgYSBwcmVmZXJyZWQgcGFjayBpcyBzcGVjaWZpZWQsIG5lZWQgdG8KCQkJICogaGF2ZSBwYWNrZWRfZ2l0J3MgbG9hZGVkIHRvIGVuc3VyZSB0aGUgY2hvc2VuCgkJCSAqIHByZWZlcnJlZCBwYWNrIGhhcyBhIG5vbi16ZXJvIG9iamVjdCBjb3VudC4KCQkJICovCgkJCWlmIChmbGFncyAmIE1JRFhfV1JJVEVfUkVWX0lOREVYIHx8CgkJCSAgICBwcmVmZXJyZWRfcGFja19uYW1lKSB7CgkJCQlpZiAocHJlcGFyZV9taWR4X3BhY2soY3R4LT5yZXBvLCBtLAoJCQkJCQkgICAgICBtLT5udW1fcGFja3NfaW5fYmFzZSArIGkpKSB7CgkJCQkJZXJyb3IoXygiY291bGQgbm90IGxvYWQgcGFjayIpKTsKCQkJCQlyZXR1cm4gMTsKCQkJCX0KCgkJCQlpZiAob3Blbl9wYWNrX2luZGV4KG0tPnBhY2tzW2ldKSkKCQkJCQlkaWUoXygiY291bGQgbm90IG9wZW4gaW5kZXggZm9yICVzIiksCgkJCQkJICAgIG0tPnBhY2tzW2ldLT5wYWNrX25hbWUpOwoJCQl9CgoJCQlmaWxsX3BhY2tfaW5mbygmY3R4LT5pbmZvW2N0eC0+bnIrK10sIG0tPnBhY2tzW2ldLAoJCQkJICAgICAgIG0tPnBhY2tfbmFtZXNbaV0sCgkJCQkgICAgICAgbS0+bnVtX3BhY2tzX2luX2Jhc2UgKyBpKTsKCQl9Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIHN0cnVjdCB7Cgljb25zdCBjaGFyICpub25fc3BsaXQ7Cgljb25zdCBjaGFyICpzcGxpdDsKfSBtaWR4X2V4dHNbXSA9IHsKCXtOVUxMLCBNSURYX0VYVF9NSURYfSwKCXtNSURYX0VYVF9CSVRNQVAsIE1JRFhfRVhUX0JJVE1BUH0sCgl7TUlEWF9FWFRfUkVWLCBNSURYX0VYVF9SRVZ9LAp9OwoKc3RhdGljIGludCBsaW5rX21pZHhfdG9fY2hhaW4oc3RydWN0IG11bHRpX3BhY2tfaW5kZXggKm0pCnsKCXN0cnVjdCBzdHJidWYgZnJvbSA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiB0byA9IFNUUkJVRl9JTklUOwoJaW50IHJldCA9IDA7CglzaXplX3QgaTsKCglpZiAoIW0gfHwgbS0+aGFzX2NoYWluKSB7CgkJLyoKCQkgKiBFaXRoZXIgbm8gTUlEWCBwcmV2aW91c2x5IGV4aXN0ZWQsIG9yIGl0IHdhcyBhbHJlYWR5CgkJICogcGFydCBvZiBhIE1JRFggY2hhaW4uIEluIGJvdGggY2FzZXMsIHdlIGhhdmUgbm90aGluZwoJCSAqIHRvIGxpbmssIHNvIHJldHVybiBlYXJseS4KCQkgKi8KCQlnb3RvIGRvbmU7Cgl9CgoJZm9yIChpID0gMDsgaSA8IEFSUkFZX1NJWkUobWlkeF9leHRzKTsgaSsrKSB7CgkJY29uc3QgdW5zaWduZWQgY2hhciAqaGFzaCA9IGdldF9taWR4X2NoZWNrc3VtKG0pOwoKCQlnZXRfbWlkeF9maWxlbmFtZV9leHQobS0+cmVwby0+aGFzaF9hbGdvLCAmZnJvbSwgbS0+b2JqZWN0X2RpciwKCQkJCSAgICAgIGhhc2gsIG1pZHhfZXh0c1tpXS5ub25fc3BsaXQpOwoJCWdldF9zcGxpdF9taWR4X2ZpbGVuYW1lX2V4dChtLT5yZXBvLT5oYXNoX2FsZ28sICZ0bywKCQkJCQkgICAgbS0+b2JqZWN0X2RpciwgaGFzaCwKCQkJCQkgICAgbWlkeF9leHRzW2ldLnNwbGl0KTsKCgkJaWYgKGxpbmsoZnJvbS5idWYsIHRvLmJ1ZikgPCAwICYmIGVycm5vICE9IEVOT0VOVCkgewoJCQlyZXQgPSBlcnJvcl9lcnJubyhfKCJ1bmFibGUgdG8gbGluayAnJXMnIHRvICclcyciKSwKCQkJCQkgIGZyb20uYnVmLCB0by5idWYpOwoJCQlnb3RvIGRvbmU7CgkJfQoKCQlzdHJidWZfcmVzZXQoJmZyb20pOwoJCXN0cmJ1Zl9yZXNldCgmdG8pOwoJfQoKZG9uZToKCXN0cmJ1Zl9yZWxlYXNlKCZmcm9tKTsKCXN0cmJ1Zl9yZWxlYXNlKCZ0byk7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgdm9pZCBjbGVhcl9taWR4X2ZpbGVzKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBjb25zdCBjaGFyICpvYmplY3RfZGlyLAoJCQkgICAgIGNvbnN0IGNoYXIgKipoYXNoZXMsIHVpbnQzMl90IGhhc2hlc19uciwKCQkJICAgICB1bnNpZ25lZCBpbmNyZW1lbnRhbCkKewoJLyoKCSAqIGlmIGluY3JlbWVudGFsOgoJICogICAtIHJlbW92ZSBhbGwgbm9uLWluY3JlbWVudGFsIE1JRFggZmlsZXMKCSAqICAgLSByZW1vdmUgYW55IGluY3JlbWVudGFsIE1JRFggZmlsZXMgbm90IGluIHRoZSBjdXJyZW50IG9uZQoJICoKCSAqIGlmIG5vbi1pbmNyZW1lbnRhbDoKCSAqICAgLSByZW1vdmUgYWxsIGluY3JlbWVudGFsIE1JRFggZmlsZXMKCSAqICAgLSByZW1vdmUgYW55IG5vbi1pbmNyZW1lbnRhbCBNSURYIGZpbGVzIG5vdCBtYXRjaGluZyB0aGUgY3VycmVudAoJICogICAgIGhhc2gKCSAqLwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKmV4dHNbXSA9IHsgTUlEWF9FWFRfQklUTUFQLCBNSURYX0VYVF9SRVYsIE1JRFhfRVhUX01JRFggfTsKCXVpbnQzMl90IGksIGo7CgoJZm9yIChpID0gMDsgaSA8IEFSUkFZX1NJWkUoZXh0cyk7IGkrKykgewoJCWNsZWFyX2luY3JlbWVudGFsX21pZHhfZmlsZXNfZXh0KG9iamVjdF9kaXIsIGV4dHNbaV0sCgkJCQkJCSBoYXNoZXMsIGhhc2hlc19ucik7CgkJZm9yIChqID0gMDsgaiA8IGhhc2hlc19ucjsgaisrKQoJCQljbGVhcl9taWR4X2ZpbGVzX2V4dChvYmplY3RfZGlyLCBleHRzW2ldLCBoYXNoZXNbal0pOwoJfQoKCWlmIChpbmNyZW1lbnRhbCkKCQlnZXRfbWlkeF9maWxlbmFtZShyLT5oYXNoX2FsZ28sICZidWYsIG9iamVjdF9kaXIpOwoJZWxzZQoJCWdldF9taWR4X2NoYWluX2ZpbGVuYW1lKCZidWYsIG9iamVjdF9kaXIpOwoKCWlmICh1bmxpbmsoYnVmLmJ1ZikgJiYgZXJybm8gIT0gRU5PRU5UKQoJCWRpZV9lcnJubyhfKCJmYWlsZWQgdG8gY2xlYXIgbXVsdGktcGFjay1pbmRleCBhdCAlcyIpLCBidWYuYnVmKTsKCglzdHJidWZfcmVsZWFzZSgmYnVmKTsKfQoKc3RhdGljIGludCB3cml0ZV9taWR4X2ludGVybmFsKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBjb25zdCBjaGFyICpvYmplY3RfZGlyLAoJCQkgICAgICAgc3RydWN0IHN0cmluZ19saXN0ICpwYWNrc190b19pbmNsdWRlLAoJCQkgICAgICAgc3RydWN0IHN0cmluZ19saXN0ICpwYWNrc190b19kcm9wLAoJCQkgICAgICAgY29uc3QgY2hhciAqcHJlZmVycmVkX3BhY2tfbmFtZSwKCQkJICAgICAgIGNvbnN0IGNoYXIgKnJlZnNfc25hcHNob3QsCgkJCSAgICAgICB1bnNpZ25lZCBmbGFncykKewoJc3RydWN0IHN0cmJ1ZiBtaWR4X25hbWUgPSBTVFJCVUZfSU5JVDsKCXVuc2lnbmVkIGNoYXIgbWlkeF9oYXNoW0dJVF9NQVhfUkFXU1pdOwoJdWludDMyX3QgaSwgc3RhcnRfcGFjazsKCXN0cnVjdCBoYXNoZmlsZSAqZiA9IE5VTEw7CglzdHJ1Y3QgbG9ja19maWxlIGxrOwoJc3RydWN0IHRlbXBmaWxlICppbmNyOwoJc3RydWN0IHdyaXRlX21pZHhfY29udGV4dCBjdHggPSB7IDAgfTsKCWludCBiaXRtYXBwZWRfcGFja3NfY29uY2F0X2xlbiA9IDA7CglpbnQgcGFja19uYW1lX2NvbmNhdF9sZW4gPSAwOwoJaW50IGRyb3BwZWRfcGFja3MgPSAwOwoJaW50IHJlc3VsdCA9IDA7Cgljb25zdCBjaGFyICoqa2VlcF9oYXNoZXMgPSBOVUxMOwoJc3RydWN0IGNodW5rZmlsZSAqY2Y7CgoJdHJhY2UyX3JlZ2lvbl9lbnRlcigibWlkeCIsICJ3cml0ZV9taWR4X2ludGVybmFsIiwgcik7CgoJY3R4LnJlcG8gPSByOwoKCWN0eC5pbmNyZW1lbnRhbCA9ICEhKGZsYWdzICYgTUlEWF9XUklURV9JTkNSRU1FTlRBTCk7CglpZiAoY3R4LmluY3JlbWVudGFsICYmIChmbGFncyAmIE1JRFhfV1JJVEVfQklUTUFQKSkKCQlkaWUoXygiY2Fubm90IHdyaXRlIGluY3JlbWVudGFsIE1JRFggd2l0aCBiaXRtYXAiKSk7CgoJaWYgKGN0eC5pbmNyZW1lbnRhbCkKCQlzdHJidWZfYWRkZigmbWlkeF9uYW1lLAoJCQkgICAgIiVzL3BhY2svbXVsdGktcGFjay1pbmRleC5kL3RtcF9taWR4X1hYWFhYWCIsCgkJCSAgICBvYmplY3RfZGlyKTsKCWVsc2UKCQlnZXRfbWlkeF9maWxlbmFtZShyLT5oYXNoX2FsZ28sICZtaWR4X25hbWUsIG9iamVjdF9kaXIpOwoJaWYgKHNhZmVfY3JlYXRlX2xlYWRpbmdfZGlyZWN0b3JpZXMobWlkeF9uYW1lLmJ1ZikpCgkJZGllX2Vycm5vKF8oInVuYWJsZSB0byBjcmVhdGUgbGVhZGluZyBkaXJlY3RvcmllcyBvZiAlcyIpLAoJCQkgIG1pZHhfbmFtZS5idWYpOwoKCWlmICghcGFja3NfdG9faW5jbHVkZSB8fCBjdHguaW5jcmVtZW50YWwpIHsKCQlzdHJ1Y3QgbXVsdGlfcGFja19pbmRleCAqbSA9IGxvb2t1cF9tdWx0aV9wYWNrX2luZGV4KHIsIG9iamVjdF9kaXIpOwoJCWlmIChtICYmICFtaWR4X2NoZWNrc3VtX3ZhbGlkKG0pKSB7CgkJCXdhcm5pbmcoXygiaWdub3JpbmcgZXhpc3RpbmcgbXVsdGktcGFjay1pbmRleDsgY2hlY2tzdW0gbWlzbWF0Y2giKSk7CgkJCW0gPSBOVUxMOwoJCX0KCgkJaWYgKG0pIHsKCQkJLyoKCQkJICogT25seSByZWZlcmVuY2UgYW4gZXhpc3RpbmcgTUlEWCB3aGVuIG5vdCBmaWx0ZXJpbmcKCQkJICogd2hpY2ggcGFja3MgdG8gaW5jbHVkZSwgc2luY2UgYWxsIHBhY2tzIGFuZCBvYmplY3RzCgkJCSAqIGFyZSBjb3BpZWQgYmxpbmRseSBmcm9tIGFuIGV4aXN0aW5nIE1JRFggaWYgb25lIGlzCgkJCSAqIHByZXNlbnQuCgkJCSAqLwoJCQlpZiAoY3R4LmluY3JlbWVudGFsKQoJCQkJY3R4LmJhc2VfbWlkeCA9IG07CgkJCWVsc2UgaWYgKCFwYWNrc190b19pbmNsdWRlKQoJCQkJY3R4Lm0gPSBtOwoJCX0KCX0KCgljdHgubnIgPSAwOwoJY3R4LmFsbG9jID0gY3R4Lm0gPyBjdHgubS0+bnVtX3BhY2tzICsgY3R4Lm0tPm51bV9wYWNrc19pbl9iYXNlIDogMTY7CgljdHguaW5mbyA9IE5VTEw7CglBTExPQ19BUlJBWShjdHguaW5mbywgY3R4LmFsbG9jKTsKCglpZiAoY3R4LmluY3JlbWVudGFsKSB7CgkJc3RydWN0IG11bHRpX3BhY2tfaW5kZXggKm0gPSBjdHguYmFzZV9taWR4OwoJCXdoaWxlIChtKSB7CgkJCWN0eC5udW1fbXVsdGlfcGFja19pbmRleGVzX2JlZm9yZSsrOwoJCQltID0gbS0+YmFzZV9taWR4OwoJCX0KCX0gZWxzZSBpZiAoY3R4Lm0gJiYgZmlsbF9wYWNrc19mcm9tX21pZHgoJmN0eCwgcHJlZmVycmVkX3BhY2tfbmFtZSwKCQkJCQkJIGZsYWdzKSA8IDApIHsKCQlnb3RvIGNsZWFudXA7Cgl9CgoJc3RhcnRfcGFjayA9IGN0eC5ucjsKCgljdHgucGFja19wYXRoc19jaGVja2VkID0gMDsKCWlmIChmbGFncyAmIE1JRFhfUFJPR1JFU1MpCgkJY3R4LnByb2dyZXNzID0gc3RhcnRfZGVsYXllZF9wcm9ncmVzcyhfKCJBZGRpbmcgcGFja2ZpbGVzIHRvIG11bHRpLXBhY2staW5kZXgiKSwgMCk7CgllbHNlCgkJY3R4LnByb2dyZXNzID0gTlVMTDsKCgljdHgudG9faW5jbHVkZSA9IHBhY2tzX3RvX2luY2x1ZGU7CgoJZm9yX2VhY2hfZmlsZV9pbl9wYWNrX2RpcihvYmplY3RfZGlyLCBhZGRfcGFja190b19taWR4LCAmY3R4KTsKCXN0b3BfcHJvZ3Jlc3MoJmN0eC5wcm9ncmVzcyk7CgoJaWYgKChjdHgubSAmJiBjdHgubnIgPT0gY3R4Lm0tPm51bV9wYWNrcyArIGN0eC5tLT5udW1fcGFja3NfaW5fYmFzZSkgJiYKCSAgICAhY3R4LmluY3JlbWVudGFsICYmCgkgICAgIShwYWNrc190b19pbmNsdWRlIHx8IHBhY2tzX3RvX2Ryb3ApKSB7CgkJc3RydWN0IGJpdG1hcF9pbmRleCAqYml0bWFwX2dpdDsKCQlpbnQgYml0bWFwX2V4aXN0czsKCQlpbnQgd2FudF9iaXRtYXAgPSBmbGFncyAmIE1JRFhfV1JJVEVfQklUTUFQOwoKCQliaXRtYXBfZ2l0ID0gcHJlcGFyZV9taWR4X2JpdG1hcF9naXQoY3R4Lm0pOwoJCWJpdG1hcF9leGlzdHMgPSBiaXRtYXBfZ2l0ICYmIGJpdG1hcF9pc19taWR4KGJpdG1hcF9naXQpOwoJCWZyZWVfYml0bWFwX2luZGV4KGJpdG1hcF9naXQpOwoKCQlpZiAoYml0bWFwX2V4aXN0cyB8fCAhd2FudF9iaXRtYXApIHsKCQkJLyoKCQkJICogVGhlIGNvcnJlY3QgTUlEWCBhbHJlYWR5IGV4aXN0cywgYW5kIHNvIGRvZXMgYQoJCQkgKiBjb3JyZXNwb25kaW5nIGJpdG1hcCAob3Igb25lIHdhc24ndCByZXF1ZXN0ZWQpLgoJCQkgKi8KCQkJaWYgKCF3YW50X2JpdG1hcCkKCQkJCWNsZWFyX21pZHhfZmlsZXNfZXh0KG9iamVjdF9kaXIsICJiaXRtYXAiLCBOVUxMKTsKCQkJZ290byBjbGVhbnVwOwoJCX0KCX0KCglpZiAoY3R4LmluY3JlbWVudGFsICYmICFjdHgubnIpCgkJZ290byBjbGVhbnVwOyAvKiBub3RoaW5nIHRvIGRvICovCgoJaWYgKHByZWZlcnJlZF9wYWNrX25hbWUpIHsKCQljdHgucHJlZmVycmVkX3BhY2tfaWR4ID0gLTE7CgoJCWZvciAoaSA9IDA7IGkgPCBjdHgubnI7IGkrKykgewoJCQlpZiAoIWNtcF9pZHhfb3JfcGFja19uYW1lKHByZWZlcnJlZF9wYWNrX25hbWUsCgkJCQkJCSAgY3R4LmluZm9baV0ucGFja19uYW1lKSkgewoJCQkJY3R4LnByZWZlcnJlZF9wYWNrX2lkeCA9IGk7CgkJCQlicmVhazsKCQkJfQoJCX0KCgkJaWYgKGN0eC5wcmVmZXJyZWRfcGFja19pZHggPT0gLTEpCgkJCXdhcm5pbmcoXygidW5rbm93biBwcmVmZXJyZWQgcGFjazogJyVzJyIpLAoJCQkJcHJlZmVycmVkX3BhY2tfbmFtZSk7Cgl9IGVsc2UgaWYgKGN0eC5uciAmJgoJCSAgIChmbGFncyAmIChNSURYX1dSSVRFX1JFVl9JTkRFWCB8IE1JRFhfV1JJVEVfQklUTUFQKSkpIHsKCQlzdHJ1Y3QgcGFja2VkX2dpdCAqb2xkZXN0ID0gY3R4LmluZm9bY3R4LnByZWZlcnJlZF9wYWNrX2lkeF0ucDsKCQljdHgucHJlZmVycmVkX3BhY2tfaWR4ID0gMDsKCgkJaWYgKHBhY2tzX3RvX2Ryb3AgJiYgcGFja3NfdG9fZHJvcC0+bnIpCgkJCUJVRygiY2Fubm90IHdyaXRlIGEgTUlEWCBiaXRtYXAgZHVyaW5nIGV4cGlyYXRpb24iKTsKCgkJLyoKCQkgKiBzZXQgYSBwcmVmZXJyZWQgcGFjayB3aGVuIHdyaXRpbmcgYSBiaXRtYXAgdG8gZW5zdXJlIHRoYXQKCQkgKiB0aGUgcGFjayBmcm9tIHdoaWNoIHRoZSBmaXJzdCBvYmplY3QgaXMgc2VsZWN0ZWQgaW4gcHNldWRvCgkJICogcGFjay1vcmRlciBoYXMgYWxsIG9mIGl0cyBvYmplY3RzIHNlbGVjdGVkIGZyb20gdGhhdCBwYWNrCgkJICogKGFuZCBub3QgYW5vdGhlciBwYWNrIGNvbnRhaW5pbmcgYSBkdXBsaWNhdGUpCgkJICovCgkJZm9yIChpID0gMTsgaSA8IGN0eC5ucjsgaSsrKSB7CgkJCXN0cnVjdCBwYWNrZWRfZ2l0ICpwID0gY3R4LmluZm9baV0ucDsKCgkJCWlmICghb2xkZXN0LT5udW1fb2JqZWN0cyB8fCBwLT5tdGltZSA8IG9sZGVzdC0+bXRpbWUpIHsKCQkJCW9sZGVzdCA9IHA7CgkJCQljdHgucHJlZmVycmVkX3BhY2tfaWR4ID0gaTsKCQkJfQoJCX0KCgkJaWYgKCFvbGRlc3QtPm51bV9vYmplY3RzKSB7CgkJCS8qCgkJCSAqIElmIGFsbCBwYWNrcyBhcmUgZW1wdHk7IHVuc2V0IHRoZSBwcmVmZXJyZWQgaW5kZXguCgkJCSAqIFRoaXMgaXMgYWNjZXB0YWJsZSBzaW5jZSB0aGVyZSB3aWxsIGJlIG5vIGR1cGxpY2F0ZQoJCQkgKiBvYmplY3RzIHRvIHJlc29sdmUsIHNvIHRoZSBwcmVmZXJyZWQgdmFsdWUgZG9lc24ndAoJCQkgKiBtYXR0ZXIuCgkJCSAqLwoJCQljdHgucHJlZmVycmVkX3BhY2tfaWR4ID0gLTE7CgkJfQoJfSBlbHNlIHsKCQkvKgoJCSAqIG90aGVyd2lzZSBkb24ndCBtYXJrIGFueSBwYWNrIGFzIHByZWZlcnJlZCB0byBhdm9pZAoJCSAqIGludGVyZmVyaW5nIHdpdGggZXhwaXJhdGlvbiBsb2dpYyBiZWxvdwoJCSAqLwoJCWN0eC5wcmVmZXJyZWRfcGFja19pZHggPSAtMTsKCX0KCglpZiAoY3R4LnByZWZlcnJlZF9wYWNrX2lkeCA+IC0xKSB7CgkJc3RydWN0IHBhY2tlZF9naXQgKnByZWZlcnJlZCA9IGN0eC5pbmZvW2N0eC5wcmVmZXJyZWRfcGFja19pZHhdLnA7CgkJaWYgKCFwcmVmZXJyZWQtPm51bV9vYmplY3RzKSB7CgkJCWVycm9yKF8oImNhbm5vdCBzZWxlY3QgcHJlZmVycmVkIHBhY2sgJXMgd2l0aCBubyBvYmplY3RzIiksCgkJCSAgICAgIHByZWZlcnJlZC0+cGFja19uYW1lKTsKCQkJcmVzdWx0ID0gMTsKCQkJZ290byBjbGVhbnVwOwoJCX0KCX0KCgljb21wdXRlX3NvcnRlZF9lbnRyaWVzKCZjdHgsIHN0YXJ0X3BhY2spOwoKCWN0eC5sYXJnZV9vZmZzZXRzX25lZWRlZCA9IDA7Cglmb3IgKGkgPSAwOyBpIDwgY3R4LmVudHJpZXNfbnI7IGkrKykgewoJCWlmIChjdHguZW50cmllc1tpXS5vZmZzZXQgPiAweDdmZmZmZmZmKQoJCQljdHgubnVtX2xhcmdlX29mZnNldHMrKzsKCQlpZiAoY3R4LmVudHJpZXNbaV0ub2Zmc2V0ID4gMHhmZmZmZmZmZikKCQkJY3R4LmxhcmdlX29mZnNldHNfbmVlZGVkID0gMTsKCX0KCglRU09SVChjdHguaW5mbywgY3R4Lm5yLCBwYWNrX2luZm9fY29tcGFyZSk7CgoJaWYgKHBhY2tzX3RvX2Ryb3AgJiYgcGFja3NfdG9fZHJvcC0+bnIpIHsKCQlpbnQgZHJvcF9pbmRleCA9IDA7CgkJaW50IG1pc3NpbmdfZHJvcHMgPSAwOwoKCQlmb3IgKGkgPSAwOyBpIDwgY3R4Lm5yICYmIGRyb3BfaW5kZXggPCBwYWNrc190b19kcm9wLT5ucjsgaSsrKSB7CgkJCWludCBjbXAgPSBzdHJjbXAoY3R4LmluZm9baV0ucGFja19uYW1lLAoJCQkJCSBwYWNrc190b19kcm9wLT5pdGVtc1tkcm9wX2luZGV4XS5zdHJpbmcpOwoKCQkJaWYgKCFjbXApIHsKCQkJCWRyb3BfaW5kZXgrKzsKCQkJCWN0eC5pbmZvW2ldLmV4cGlyZWQgPSAxOwoJCQl9IGVsc2UgaWYgKGNtcCA+IDApIHsKCQkJCWVycm9yKF8oImRpZCBub3Qgc2VlIHBhY2stZmlsZSAlcyB0byBkcm9wIiksCgkJCQkgICAgICBwYWNrc190b19kcm9wLT5pdGVtc1tkcm9wX2luZGV4XS5zdHJpbmcpOwoJCQkJZHJvcF9pbmRleCsrOwoJCQkJbWlzc2luZ19kcm9wcysrOwoJCQkJaS0tOwoJCQl9IGVsc2UgewoJCQkJY3R4LmluZm9baV0uZXhwaXJlZCA9IDA7CgkJCX0KCQl9CgoJCWlmIChtaXNzaW5nX2Ryb3BzKSB7CgkJCXJlc3VsdCA9IDE7CgkJCWdvdG8gY2xlYW51cDsKCQl9Cgl9CgoJLyoKCSAqIHBhY2tfcGVybSBzdG9yZXMgYSBwZXJtdXRhdGlvbiBiZXR3ZWVuIHBhY2staW50LWlkcyBmcm9tIHRoZQoJICogcHJldmlvdXMgbXVsdGktcGFjay1pbmRleCB0byB0aGUgbmV3IG9uZSB3ZSBhcmUgd3JpdGluZzoKCSAqCgkgKiBwYWNrX3Blcm1bb2xkX2lkXSA9IG5ld19pZAoJICovCglBTExPQ19BUlJBWShjdHgucGFja19wZXJtLCBjdHgubnIpOwoJZm9yIChpID0gMDsgaSA8IGN0eC5ucjsgaSsrKSB7CgkJaWYgKGN0eC5pbmZvW2ldLmV4cGlyZWQpIHsKCQkJZHJvcHBlZF9wYWNrcysrOwoJCQljdHgucGFja19wZXJtW2N0eC5pbmZvW2ldLm9yaWdfcGFja19pbnRfaWRdID0gUEFDS19FWFBJUkVEOwoJCX0gZWxzZSB7CgkJCWN0eC5wYWNrX3Blcm1bY3R4LmluZm9baV0ub3JpZ19wYWNrX2ludF9pZF0gPSBpIC0gZHJvcHBlZF9wYWNrczsKCQl9Cgl9CgoJZm9yIChpID0gMDsgaSA8IGN0eC5ucjsgaSsrKSB7CgkJaWYgKGN0eC5pbmZvW2ldLmV4cGlyZWQpCgkJCWNvbnRpbnVlOwoJCXBhY2tfbmFtZV9jb25jYXRfbGVuICs9IHN0cmxlbihjdHguaW5mb1tpXS5wYWNrX25hbWUpICsgMTsKCQliaXRtYXBwZWRfcGFja3NfY29uY2F0X2xlbiArPSAyICogc2l6ZW9mKHVpbnQzMl90KTsKCX0KCgkvKiBDaGVjayB0aGF0IHRoZSBwcmVmZXJyZWQgcGFjayB3YXNuJ3QgZXhwaXJlZCAoaWYgZ2l2ZW4pLiAqLwoJaWYgKHByZWZlcnJlZF9wYWNrX25hbWUpIHsKCQlzdHJ1Y3QgcGFja19pbmZvICpwcmVmZXJyZWQgPSBic2VhcmNoKHByZWZlcnJlZF9wYWNrX25hbWUsCgkJCQkJCSAgICAgIGN0eC5pbmZvLCBjdHgubnIsCgkJCQkJCSAgICAgIHNpemVvZigqY3R4LmluZm8pLAoJCQkJCQkgICAgICBpZHhfb3JfcGFja19uYW1lX2NtcCk7CgkJaWYgKHByZWZlcnJlZCkgewoJCQl1aW50MzJfdCBwZXJtID0gY3R4LnBhY2tfcGVybVtwcmVmZXJyZWQtPm9yaWdfcGFja19pbnRfaWRdOwoJCQlpZiAocGVybSA9PSBQQUNLX0VYUElSRUQpCgkJCQl3YXJuaW5nKF8oInByZWZlcnJlZCBwYWNrICclcycgaXMgZXhwaXJlZCIpLAoJCQkJCXByZWZlcnJlZF9wYWNrX25hbWUpOwoJCX0KCX0KCglpZiAocGFja19uYW1lX2NvbmNhdF9sZW4gJSBNSURYX0NIVU5LX0FMSUdOTUVOVCkKCQlwYWNrX25hbWVfY29uY2F0X2xlbiArPSBNSURYX0NIVU5LX0FMSUdOTUVOVCAtCgkJCQkJKHBhY2tfbmFtZV9jb25jYXRfbGVuICUgTUlEWF9DSFVOS19BTElHTk1FTlQpOwoKCWlmIChjdHgubnIgLSBkcm9wcGVkX3BhY2tzID09IDApIHsKCQllcnJvcihfKCJubyBwYWNrIGZpbGVzIHRvIGluZGV4LiIpKTsKCQlyZXN1bHQgPSAxOwoJCWdvdG8gY2xlYW51cDsKCX0KCglpZiAoIWN0eC5lbnRyaWVzX25yKSB7CgkJaWYgKGZsYWdzICYgTUlEWF9XUklURV9CSVRNQVApCgkJCXdhcm5pbmcoXygicmVmdXNpbmcgdG8gd3JpdGUgbXVsdGktcGFjayAuYml0bWFwIHdpdGhvdXQgYW55IG9iamVjdHMiKSk7CgkJZmxhZ3MgJj0gfihNSURYX1dSSVRFX1JFVl9JTkRFWCB8IE1JRFhfV1JJVEVfQklUTUFQKTsKCX0KCglpZiAoY3R4LmluY3JlbWVudGFsKSB7CgkJc3RydWN0IHN0cmJ1ZiBsb2NrX25hbWUgPSBTVFJCVUZfSU5JVDsKCgkJZ2V0X21pZHhfY2hhaW5fZmlsZW5hbWUoJmxvY2tfbmFtZSwgb2JqZWN0X2Rpcik7CgkJaG9sZF9sb2NrX2ZpbGVfZm9yX3VwZGF0ZSgmbGssIGxvY2tfbmFtZS5idWYsIExPQ0tfRElFX09OX0VSUk9SKTsKCQlzdHJidWZfcmVsZWFzZSgmbG9ja19uYW1lKTsKCgkJaW5jciA9IG1rc190ZW1wZmlsZV9tKG1pZHhfbmFtZS5idWYsIDA0NDQpOwoJCWlmICghaW5jcikgewoJCQllcnJvcihfKCJ1bmFibGUgdG8gY3JlYXRlIHRlbXBvcmFyeSBNSURYIGxheWVyIikpOwoJCQlyZXR1cm4gLTE7CgkJfQoKCQlpZiAoYWRqdXN0X3NoYXJlZF9wZXJtKGdldF90ZW1wZmlsZV9wYXRoKGluY3IpKSkgewoJCQllcnJvcihfKCJ1bmFibGUgdG8gYWRqdXN0IHNoYXJlZCBwZXJtaXNzaW9ucyBmb3IgJyVzJyIpLAoJCQkgICAgICBnZXRfdGVtcGZpbGVfcGF0aChpbmNyKSk7CgkJCXJldHVybiAtMTsKCQl9CgoJCWYgPSBoYXNoZmQoZ2V0X3RlbXBmaWxlX2ZkKGluY3IpLCBnZXRfdGVtcGZpbGVfcGF0aChpbmNyKSk7Cgl9IGVsc2UgewoJCWhvbGRfbG9ja19maWxlX2Zvcl91cGRhdGUoJmxrLCBtaWR4X25hbWUuYnVmLCBMT0NLX0RJRV9PTl9FUlJPUik7CgkJZiA9IGhhc2hmZChnZXRfbG9ja19maWxlX2ZkKCZsayksIGdldF9sb2NrX2ZpbGVfcGF0aCgmbGspKTsKCX0KCgljZiA9IGluaXRfY2h1bmtmaWxlKGYpOwoKCWFkZF9jaHVuayhjZiwgTUlEWF9DSFVOS0lEX1BBQ0tOQU1FUywgcGFja19uYW1lX2NvbmNhdF9sZW4sCgkJICB3cml0ZV9taWR4X3BhY2tfbmFtZXMpOwoJYWRkX2NodW5rKGNmLCBNSURYX0NIVU5LSURfT0lERkFOT1VULCBNSURYX0NIVU5LX0ZBTk9VVF9TSVpFLAoJCSAgd3JpdGVfbWlkeF9vaWRfZmFub3V0KTsKCWFkZF9jaHVuayhjZiwgTUlEWF9DSFVOS0lEX09JRExPT0tVUCwKCQkgIHN0X211bHQoY3R4LmVudHJpZXNfbnIsIHItPmhhc2hfYWxnby0+cmF3c3opLAoJCSAgd3JpdGVfbWlkeF9vaWRfbG9va3VwKTsKCWFkZF9jaHVuayhjZiwgTUlEWF9DSFVOS0lEX09CSkVDVE9GRlNFVFMsCgkJICBzdF9tdWx0KGN0eC5lbnRyaWVzX25yLCBNSURYX0NIVU5LX09GRlNFVF9XSURUSCksCgkJICB3cml0ZV9taWR4X29iamVjdF9vZmZzZXRzKTsKCglpZiAoY3R4LmxhcmdlX29mZnNldHNfbmVlZGVkKQoJCWFkZF9jaHVuayhjZiwgTUlEWF9DSFVOS0lEX0xBUkdFT0ZGU0VUUywKCQkJc3RfbXVsdChjdHgubnVtX2xhcmdlX29mZnNldHMsCgkJCQlNSURYX0NIVU5LX0xBUkdFX09GRlNFVF9XSURUSCksCgkJCXdyaXRlX21pZHhfbGFyZ2Vfb2Zmc2V0cyk7CgoJaWYgKGZsYWdzICYgKE1JRFhfV1JJVEVfUkVWX0lOREVYIHwgTUlEWF9XUklURV9CSVRNQVApKSB7CgkJY3R4LnBhY2tfb3JkZXIgPSBtaWR4X3BhY2tfb3JkZXIoJmN0eCk7CgkJYWRkX2NodW5rKGNmLCBNSURYX0NIVU5LSURfUkVWSU5ERVgsCgkJCSAgc3RfbXVsdChjdHguZW50cmllc19uciwgc2l6ZW9mKHVpbnQzMl90KSksCgkJCSAgd3JpdGVfbWlkeF9yZXZpbmRleCk7CgkJYWRkX2NodW5rKGNmLCBNSURYX0NIVU5LSURfQklUTUFQUEVEUEFDS1MsCgkJCSAgYml0bWFwcGVkX3BhY2tzX2NvbmNhdF9sZW4sCgkJCSAgd3JpdGVfbWlkeF9iaXRtYXBwZWRfcGFja3MpOwoJfQoKCXdyaXRlX21pZHhfaGVhZGVyKHItPmhhc2hfYWxnbywgZiwgZ2V0X251bV9jaHVua3MoY2YpLAoJCQkgIGN0eC5uciAtIGRyb3BwZWRfcGFja3MpOwoJd3JpdGVfY2h1bmtmaWxlKGNmLCAmY3R4KTsKCglmaW5hbGl6ZV9oYXNoZmlsZShmLCBtaWR4X2hhc2gsIEZTWU5DX0NPTVBPTkVOVF9QQUNLX01FVEFEQVRBLAoJCQkgIENTVU1fRlNZTkMgfCBDU1VNX0hBU0hfSU5fU1RSRUFNKTsKCWZyZWVfY2h1bmtmaWxlKGNmKTsKCglpZiAoZmxhZ3MgJiBNSURYX1dSSVRFX1JFVl9JTkRFWCAmJgoJICAgIGdpdF9lbnZfYm9vbCgiR0lUX1RFU1RfTUlEWF9XUklURV9SRVYiLCAwKSkKCQl3cml0ZV9taWR4X3JldmVyc2VfaW5kZXgobWlkeF9uYW1lLmJ1ZiwgbWlkeF9oYXNoLCAmY3R4KTsKCglpZiAoZmxhZ3MgJiBNSURYX1dSSVRFX0JJVE1BUCkgewoJCXN0cnVjdCBwYWNraW5nX2RhdGEgcGRhdGE7CgkJc3RydWN0IGNvbW1pdCAqKmNvbW1pdHM7CgkJdWludDMyX3QgY29tbWl0c19ucjsKCgkJaWYgKCFjdHguZW50cmllc19ucikKCQkJQlVHKCJjYW5ub3Qgd3JpdGUgYSBiaXRtYXAgd2l0aG91dCBhbnkgb2JqZWN0cyIpOwoKCQlwcmVwYXJlX21pZHhfcGFja2luZ19kYXRhKCZwZGF0YSwgJmN0eCk7CgoJCWNvbW1pdHMgPSBmaW5kX2NvbW1pdHNfZm9yX21pZHhfYml0bWFwKCZjb21taXRzX25yLCByZWZzX3NuYXBzaG90LCAmY3R4KTsKCgkJLyoKCQkgKiBUaGUgcHJldmlvdXMgc3RlcHMgdHJhbnNsYXRlZCB0aGUgaW5mb3JtYXRpb24gZnJvbQoJCSAqICdlbnRyaWVzJyBpbnRvIGluZm9ybWF0aW9uIHN1aXRhYmxlIGZvciBjb25zdHJ1Y3RpbmcKCQkgKiBiaXRtYXBzLiBXZSBubyBsb25nZXIgbmVlZCB0aGF0IGFycmF5LCBzbyBjbGVhciBpdCB0bwoJCSAqIHJlZHVjZSBtZW1vcnkgcHJlc3N1cmUuCgkJICovCgkJRlJFRV9BTkRfTlVMTChjdHguZW50cmllcyk7CgkJY3R4LmVudHJpZXNfbnIgPSAwOwoKCQlpZiAod3JpdGVfbWlkeF9iaXRtYXAociwgbWlkeF9uYW1lLmJ1ZiwgbWlkeF9oYXNoLCAmcGRhdGEsCgkJCQkgICAgICBjb21taXRzLCBjb21taXRzX25yLCBjdHgucGFja19vcmRlciwKCQkJCSAgICAgIGZsYWdzKSA8IDApIHsKCQkJZXJyb3IoXygiY291bGQgbm90IHdyaXRlIG11bHRpLXBhY2sgYml0bWFwIikpOwoJCQlyZXN1bHQgPSAxOwoJCQljbGVhcl9wYWNraW5nX2RhdGEoJnBkYXRhKTsKCQkJZnJlZShjb21taXRzKTsKCQkJZ290byBjbGVhbnVwOwoJCX0KCgkJY2xlYXJfcGFja2luZ19kYXRhKCZwZGF0YSk7CgkJZnJlZShjb21taXRzKTsKCX0KCS8qCgkgKiBOT1RFOiBEbyBub3QgdXNlIGN0eC5lbnRyaWVzIGJleW9uZCB0aGlzIHBvaW50LCBzaW5jZSBpdCBtaWdodAoJICogaGF2ZSBiZWVuIGZyZWVkIGluIHRoZSBwcmV2aW91cyBpZiBibG9jay4KCSAqLwoKCUNBTExPQ19BUlJBWShrZWVwX2hhc2hlcywgY3R4Lm51bV9tdWx0aV9wYWNrX2luZGV4ZXNfYmVmb3JlICsgMSk7CgoJaWYgKGN0eC5pbmNyZW1lbnRhbCkgewoJCUZJTEUgKmNoYWluZiA9IGZkb3Blbl9sb2NrX2ZpbGUoJmxrLCAidyIpOwoJCXN0cnVjdCBzdHJidWYgZmluYWxfbWlkeF9uYW1lID0gU1RSQlVGX0lOSVQ7CgkJc3RydWN0IG11bHRpX3BhY2tfaW5kZXggKm0gPSBjdHguYmFzZV9taWR4OwoKCQlpZiAoIWNoYWluZikgewoJCQllcnJvcl9lcnJubyhfKCJ1bmFibGUgdG8gb3BlbiBtdWx0aS1wYWNrLWluZGV4IGNoYWluIGZpbGUiKSk7CgkJCXJldHVybiAtMTsKCQl9CgoJCWlmIChsaW5rX21pZHhfdG9fY2hhaW4oY3R4LmJhc2VfbWlkeCkgPCAwKQoJCQlyZXR1cm4gLTE7CgoJCWdldF9zcGxpdF9taWR4X2ZpbGVuYW1lX2V4dChyLT5oYXNoX2FsZ28sICZmaW5hbF9taWR4X25hbWUsCgkJCQkJICAgIG9iamVjdF9kaXIsIG1pZHhfaGFzaCwgTUlEWF9FWFRfTUlEWCk7CgoJCWlmIChyZW5hbWVfdGVtcGZpbGUoJmluY3IsIGZpbmFsX21pZHhfbmFtZS5idWYpIDwgMCkgewoJCQllcnJvcl9lcnJubyhfKCJ1bmFibGUgdG8gcmVuYW1lIG5ldyBtdWx0aS1wYWNrLWluZGV4IGxheWVyIikpOwoJCQlyZXR1cm4gLTE7CgkJfQoKCQlzdHJidWZfcmVsZWFzZSgmZmluYWxfbWlkeF9uYW1lKTsKCgkJa2VlcF9oYXNoZXNbY3R4Lm51bV9tdWx0aV9wYWNrX2luZGV4ZXNfYmVmb3JlXSA9CgkJCXhzdHJkdXAoaGFzaF90b19oZXhfYWxnb3AobWlkeF9oYXNoLCByLT5oYXNoX2FsZ28pKTsKCgkJZm9yIChpID0gMDsgaSA8IGN0eC5udW1fbXVsdGlfcGFja19pbmRleGVzX2JlZm9yZTsgaSsrKSB7CgkJCXVpbnQzMl90IGogPSBjdHgubnVtX211bHRpX3BhY2tfaW5kZXhlc19iZWZvcmUgLSBpIC0gMTsKCgkJCWtlZXBfaGFzaGVzW2pdID0geHN0cmR1cChoYXNoX3RvX2hleF9hbGdvcChnZXRfbWlkeF9jaGVja3N1bShtKSwKCQkJCQkJCQkgICByLT5oYXNoX2FsZ28pKTsKCQkJbSA9IG0tPmJhc2VfbWlkeDsKCQl9CgoJCWZvciAoaSA9IDA7IGkgPCBjdHgubnVtX211bHRpX3BhY2tfaW5kZXhlc19iZWZvcmUgKyAxOyBpKyspCgkJCWZwcmludGYoZ2V0X2xvY2tfZmlsZV9mcCgmbGspLCAiJXNcbiIsIGtlZXBfaGFzaGVzW2ldKTsKCX0gZWxzZSB7CgkJa2VlcF9oYXNoZXNbY3R4Lm51bV9tdWx0aV9wYWNrX2luZGV4ZXNfYmVmb3JlXSA9CgkJCXhzdHJkdXAoaGFzaF90b19oZXhfYWxnb3AobWlkeF9oYXNoLCByLT5oYXNoX2FsZ28pKTsKCX0KCglpZiAoY3R4Lm0gfHwgY3R4LmJhc2VfbWlkeCkKCQljbG9zZV9vYmplY3Rfc3RvcmUoY3R4LnJlcG8tPm9iamVjdHMpOwoKCWlmIChjb21taXRfbG9ja19maWxlKCZsaykgPCAwKQoJCWRpZV9lcnJubyhfKCJjb3VsZCBub3Qgd3JpdGUgbXVsdGktcGFjay1pbmRleCIpKTsKCgljbGVhcl9taWR4X2ZpbGVzKHIsIG9iamVjdF9kaXIsIGtlZXBfaGFzaGVzLAoJCQkgY3R4Lm51bV9tdWx0aV9wYWNrX2luZGV4ZXNfYmVmb3JlICsgMSwKCQkJIGN0eC5pbmNyZW1lbnRhbCk7CgpjbGVhbnVwOgoJZm9yIChpID0gMDsgaSA8IGN0eC5ucjsgaSsrKSB7CgkJaWYgKGN0eC5pbmZvW2ldLnApIHsKCQkJY2xvc2VfcGFjayhjdHguaW5mb1tpXS5wKTsKCQkJZnJlZShjdHguaW5mb1tpXS5wKTsKCQl9CgkJZnJlZShjdHguaW5mb1tpXS5wYWNrX25hbWUpOwoJfQoKCWZyZWUoY3R4LmluZm8pOwoJZnJlZShjdHguZW50cmllcyk7CglmcmVlKGN0eC5wYWNrX3Blcm0pOwoJZnJlZShjdHgucGFja19vcmRlcik7CglpZiAoa2VlcF9oYXNoZXMpIHsKCQlmb3IgKGkgPSAwOyBpIDwgY3R4Lm51bV9tdWx0aV9wYWNrX2luZGV4ZXNfYmVmb3JlICsgMTsgaSsrKQoJCQlmcmVlKChjaGFyICopa2VlcF9oYXNoZXNbaV0pOwoJCWZyZWUoa2VlcF9oYXNoZXMpOwoJfQoJc3RyYnVmX3JlbGVhc2UoJm1pZHhfbmFtZSk7CgoJdHJhY2UyX3JlZ2lvbl9sZWF2ZSgibWlkeCIsICJ3cml0ZV9taWR4X2ludGVybmFsIiwgcik7CgoJcmV0dXJuIHJlc3VsdDsKfQoKaW50IHdyaXRlX21pZHhfZmlsZShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgY29uc3QgY2hhciAqb2JqZWN0X2RpciwKCQkgICAgY29uc3QgY2hhciAqcHJlZmVycmVkX3BhY2tfbmFtZSwKCQkgICAgY29uc3QgY2hhciAqcmVmc19zbmFwc2hvdCwgdW5zaWduZWQgZmxhZ3MpCnsKCXJldHVybiB3cml0ZV9taWR4X2ludGVybmFsKHIsIG9iamVjdF9kaXIsIE5VTEwsIE5VTEwsCgkJCQkgICBwcmVmZXJyZWRfcGFja19uYW1lLCByZWZzX3NuYXBzaG90LAoJCQkJICAgZmxhZ3MpOwp9CgppbnQgd3JpdGVfbWlkeF9maWxlX29ubHkoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IGNoYXIgKm9iamVjdF9kaXIsCgkJCSBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnBhY2tzX3RvX2luY2x1ZGUsCgkJCSBjb25zdCBjaGFyICpwcmVmZXJyZWRfcGFja19uYW1lLAoJCQkgY29uc3QgY2hhciAqcmVmc19zbmFwc2hvdCwgdW5zaWduZWQgZmxhZ3MpCnsKCXJldHVybiB3cml0ZV9taWR4X2ludGVybmFsKHIsIG9iamVjdF9kaXIsIHBhY2tzX3RvX2luY2x1ZGUsIE5VTEwsCgkJCQkgICBwcmVmZXJyZWRfcGFja19uYW1lLCByZWZzX3NuYXBzaG90LCBmbGFncyk7Cn0KCmludCBleHBpcmVfbWlkeF9wYWNrcyhzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgY29uc3QgY2hhciAqb2JqZWN0X2RpciwgdW5zaWduZWQgZmxhZ3MpCnsKCXVpbnQzMl90IGksICpjb3VudCwgcmVzdWx0ID0gMDsKCXN0cnVjdCBzdHJpbmdfbGlzdCBwYWNrc190b19kcm9wID0gU1RSSU5HX0xJU1RfSU5JVF9EVVA7CglzdHJ1Y3QgbXVsdGlfcGFja19pbmRleCAqbSA9IGxvb2t1cF9tdWx0aV9wYWNrX2luZGV4KHIsIG9iamVjdF9kaXIpOwoJc3RydWN0IHByb2dyZXNzICpwcm9ncmVzcyA9IE5VTEw7CgoJaWYgKCFtKQoJCXJldHVybiAwOwoKCWlmIChtLT5iYXNlX21pZHgpCgkJZGllKF8oImNhbm5vdCBleHBpcmUgcGFja3MgZnJvbSBhbiBpbmNyZW1lbnRhbCBtdWx0aS1wYWNrLWluZGV4IikpOwoKCUNBTExPQ19BUlJBWShjb3VudCwgbS0+bnVtX3BhY2tzKTsKCglpZiAoZmxhZ3MgJiBNSURYX1BST0dSRVNTKQoJCXByb2dyZXNzID0gc3RhcnRfZGVsYXllZF9wcm9ncmVzcyhfKCJDb3VudGluZyByZWZlcmVuY2VkIG9iamVjdHMiKSwKCQkJCQkgIG0tPm51bV9vYmplY3RzKTsKCWZvciAoaSA9IDA7IGkgPCBtLT5udW1fb2JqZWN0czsgaSsrKSB7CgkJaW50IHBhY2tfaW50X2lkID0gbnRoX21pZHhlZF9wYWNrX2ludF9pZChtLCBpKTsKCQljb3VudFtwYWNrX2ludF9pZF0rKzsKCQlkaXNwbGF5X3Byb2dyZXNzKHByb2dyZXNzLCBpICsgMSk7Cgl9CglzdG9wX3Byb2dyZXNzKCZwcm9ncmVzcyk7CgoJaWYgKGZsYWdzICYgTUlEWF9QUk9HUkVTUykKCQlwcm9ncmVzcyA9IHN0YXJ0X2RlbGF5ZWRfcHJvZ3Jlc3MoXygiRmluZGluZyBhbmQgZGVsZXRpbmcgdW5yZWZlcmVuY2VkIHBhY2tmaWxlcyIpLAoJCQkJCSAgbS0+bnVtX3BhY2tzKTsKCWZvciAoaSA9IDA7IGkgPCBtLT5udW1fcGFja3M7IGkrKykgewoJCWNoYXIgKnBhY2tfbmFtZTsKCQlkaXNwbGF5X3Byb2dyZXNzKHByb2dyZXNzLCBpICsgMSk7CgoJCWlmIChjb3VudFtpXSkKCQkJY29udGludWU7CgoJCWlmIChwcmVwYXJlX21pZHhfcGFjayhyLCBtLCBpKSkKCQkJY29udGludWU7CgoJCWlmIChtLT5wYWNrc1tpXS0+cGFja19rZWVwIHx8IG0tPnBhY2tzW2ldLT5pc19jcnVmdCkKCQkJY29udGludWU7CgoJCXBhY2tfbmFtZSA9IHhzdHJkdXAobS0+cGFja3NbaV0tPnBhY2tfbmFtZSk7CgkJY2xvc2VfcGFjayhtLT5wYWNrc1tpXSk7CgoJCXN0cmluZ19saXN0X2luc2VydCgmcGFja3NfdG9fZHJvcCwgbS0+cGFja19uYW1lc1tpXSk7CgkJdW5saW5rX3BhY2tfcGF0aChwYWNrX25hbWUsIDApOwoJCWZyZWUocGFja19uYW1lKTsKCX0KCXN0b3BfcHJvZ3Jlc3MoJnByb2dyZXNzKTsKCglmcmVlKGNvdW50KTsKCglpZiAocGFja3NfdG9fZHJvcC5ucikKCQlyZXN1bHQgPSB3cml0ZV9taWR4X2ludGVybmFsKHIsIG9iamVjdF9kaXIsIE5VTEwsCgkJCQkJICAgICAmcGFja3NfdG9fZHJvcCwgTlVMTCwgTlVMTCwgZmxhZ3MpOwoKCXN0cmluZ19saXN0X2NsZWFyKCZwYWNrc190b19kcm9wLCAwKTsKCglyZXR1cm4gcmVzdWx0Owp9CgpzdHJ1Y3QgcmVwYWNrX2luZm8gewoJdGltZXN0YW1wX3QgbXRpbWU7Cgl1aW50MzJfdCByZWZlcmVuY2VkX29iamVjdHM7Cgl1aW50MzJfdCBwYWNrX2ludF9pZDsKfTsKCnN0YXRpYyBpbnQgY29tcGFyZV9ieV9tdGltZShjb25zdCB2b2lkICphXywgY29uc3Qgdm9pZCAqYl8pCnsKCWNvbnN0IHN0cnVjdCByZXBhY2tfaW5mbyAqYSwgKmI7CgoJYSA9IChjb25zdCBzdHJ1Y3QgcmVwYWNrX2luZm8gKilhXzsKCWIgPSAoY29uc3Qgc3RydWN0IHJlcGFja19pbmZvICopYl87CgoJaWYgKGEtPm10aW1lIDwgYi0+bXRpbWUpCgkJcmV0dXJuIC0xOwoJaWYgKGEtPm10aW1lID4gYi0+bXRpbWUpCgkJcmV0dXJuIDE7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCB3YW50X2luY2x1ZGVkX3BhY2soc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCSAgICAgIHN0cnVjdCBtdWx0aV9wYWNrX2luZGV4ICptLAoJCQkgICAgICBpbnQgcGFja19rZXB0X29iamVjdHMsCgkJCSAgICAgIHVpbnQzMl90IHBhY2tfaW50X2lkKQp7CglzdHJ1Y3QgcGFja2VkX2dpdCAqcDsKCWlmIChwcmVwYXJlX21pZHhfcGFjayhyLCBtLCBwYWNrX2ludF9pZCkpCgkJcmV0dXJuIDA7CglwID0gbS0+cGFja3NbcGFja19pbnRfaWRdOwoJaWYgKCFwYWNrX2tlcHRfb2JqZWN0cyAmJiBwLT5wYWNrX2tlZXApCgkJcmV0dXJuIDA7CglpZiAocC0+aXNfY3J1ZnQpCgkJcmV0dXJuIDA7CglpZiAob3Blbl9wYWNrX2luZGV4KHApIHx8ICFwLT5udW1fb2JqZWN0cykKCQlyZXR1cm4gMDsKCXJldHVybiAxOwp9CgpzdGF0aWMgdm9pZCBmaWxsX2luY2x1ZGVkX3BhY2tzX2FsbChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJCSAgICBzdHJ1Y3QgbXVsdGlfcGFja19pbmRleCAqbSwKCQkJCSAgICB1bnNpZ25lZCBjaGFyICppbmNsdWRlX3BhY2spCnsKCXVpbnQzMl90IGk7CglpbnQgcGFja19rZXB0X29iamVjdHMgPSAwOwoKCXJlcG9fY29uZmlnX2dldF9ib29sKHIsICJyZXBhY2sucGFja2tlcHRvYmplY3RzIiwgJnBhY2tfa2VwdF9vYmplY3RzKTsKCglmb3IgKGkgPSAwOyBpIDwgbS0+bnVtX3BhY2tzOyBpKyspIHsKCQlpZiAoIXdhbnRfaW5jbHVkZWRfcGFjayhyLCBtLCBwYWNrX2tlcHRfb2JqZWN0cywgaSkpCgkJCWNvbnRpbnVlOwoKCQlpbmNsdWRlX3BhY2tbaV0gPSAxOwoJfQp9CgpzdGF0aWMgdm9pZCBmaWxsX2luY2x1ZGVkX3BhY2tzX2JhdGNoKHN0cnVjdCByZXBvc2l0b3J5ICpyLAoJCQkJICAgICAgc3RydWN0IG11bHRpX3BhY2tfaW5kZXggKm0sCgkJCQkgICAgICB1bnNpZ25lZCBjaGFyICppbmNsdWRlX3BhY2ssCgkJCQkgICAgICBzaXplX3QgYmF0Y2hfc2l6ZSkKewoJdWludDMyX3QgaTsKCXNpemVfdCB0b3RhbF9zaXplOwoJc3RydWN0IHJlcGFja19pbmZvICpwYWNrX2luZm87CglpbnQgcGFja19rZXB0X29iamVjdHMgPSAwOwoKCUNBTExPQ19BUlJBWShwYWNrX2luZm8sIG0tPm51bV9wYWNrcyk7CgoJcmVwb19jb25maWdfZ2V0X2Jvb2wociwgInJlcGFjay5wYWNra2VwdG9iamVjdHMiLCAmcGFja19rZXB0X29iamVjdHMpOwoKCWZvciAoaSA9IDA7IGkgPCBtLT5udW1fcGFja3M7IGkrKykgewoJCXBhY2tfaW5mb1tpXS5wYWNrX2ludF9pZCA9IGk7CgoJCWlmIChwcmVwYXJlX21pZHhfcGFjayhyLCBtLCBpKSkKCQkJY29udGludWU7CgoJCXBhY2tfaW5mb1tpXS5tdGltZSA9IG0tPnBhY2tzW2ldLT5tdGltZTsKCX0KCglmb3IgKGkgPSAwOyBpIDwgbS0+bnVtX29iamVjdHM7IGkrKykgewoJCXVpbnQzMl90IHBhY2tfaW50X2lkID0gbnRoX21pZHhlZF9wYWNrX2ludF9pZChtLCBpKTsKCQlwYWNrX2luZm9bcGFja19pbnRfaWRdLnJlZmVyZW5jZWRfb2JqZWN0cysrOwoJfQoKCVFTT1JUKHBhY2tfaW5mbywgbS0+bnVtX3BhY2tzLCBjb21wYXJlX2J5X210aW1lKTsKCgl0b3RhbF9zaXplID0gMDsKCWZvciAoaSA9IDA7IHRvdGFsX3NpemUgPCBiYXRjaF9zaXplICYmIGkgPCBtLT5udW1fcGFja3M7IGkrKykgewoJCWludCBwYWNrX2ludF9pZCA9IHBhY2tfaW5mb1tpXS5wYWNrX2ludF9pZDsKCQlzdHJ1Y3QgcGFja2VkX2dpdCAqcCA9IG0tPnBhY2tzW3BhY2tfaW50X2lkXTsKCQlzaXplX3QgZXhwZWN0ZWRfc2l6ZTsKCgkJaWYgKCF3YW50X2luY2x1ZGVkX3BhY2sociwgbSwgcGFja19rZXB0X29iamVjdHMsIHBhY2tfaW50X2lkKSkKCQkJY29udGludWU7CgoJCWV4cGVjdGVkX3NpemUgPSBzdF9tdWx0KHAtPnBhY2tfc2l6ZSwKCQkJCQlwYWNrX2luZm9baV0ucmVmZXJlbmNlZF9vYmplY3RzKTsKCQlleHBlY3RlZF9zaXplIC89IHAtPm51bV9vYmplY3RzOwoKCQlpZiAoZXhwZWN0ZWRfc2l6ZSA+PSBiYXRjaF9zaXplKQoJCQljb250aW51ZTsKCgkJdG90YWxfc2l6ZSArPSBleHBlY3RlZF9zaXplOwoJCWluY2x1ZGVfcGFja1twYWNrX2ludF9pZF0gPSAxOwoJfQoKCWZyZWUocGFja19pbmZvKTsKfQoKaW50IG1pZHhfcmVwYWNrKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBjb25zdCBjaGFyICpvYmplY3RfZGlyLCBzaXplX3QgYmF0Y2hfc2l6ZSwgdW5zaWduZWQgZmxhZ3MpCnsKCWludCByZXN1bHQgPSAwOwoJdWludDMyX3QgaSwgcGFja3NfdG9fcmVwYWNrID0gMDsKCXVuc2lnbmVkIGNoYXIgKmluY2x1ZGVfcGFjazsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGNtZCA9IENISUxEX1BST0NFU1NfSU5JVDsKCUZJTEUgKmNtZF9pbjsKCXN0cnVjdCBtdWx0aV9wYWNrX2luZGV4ICptID0gbG9va3VwX211bHRpX3BhY2tfaW5kZXgociwgb2JqZWN0X2Rpcik7CgoJLyoKCSAqIFdoZW4gdXBkYXRpbmcgdGhlIGRlZmF1bHQgZm9yIHRoZXNlIGNvbmZpZ3VyYXRpb24KCSAqIHZhcmlhYmxlcyBpbiBidWlsdGluL3JlcGFjay5jLCB0aGVzZSBtdXN0IGJlIGFkanVzdGVkCgkgKiB0byBtYXRjaC4KCSAqLwoJaW50IGRlbHRhX2Jhc2Vfb2Zmc2V0ID0gMTsKCWludCB1c2VfZGVsdGFfaXNsYW5kcyA9IDA7CgoJaWYgKCFtKQoJCXJldHVybiAwOwoJaWYgKG0tPmJhc2VfbWlkeCkKCQlkaWUoXygiY2Fubm90IHJlcGFjayBhbiBpbmNyZW1lbnRhbCBtdWx0aS1wYWNrLWluZGV4IikpOwoKCUNBTExPQ19BUlJBWShpbmNsdWRlX3BhY2ssIG0tPm51bV9wYWNrcyk7CgoJaWYgKGJhdGNoX3NpemUpCgkJZmlsbF9pbmNsdWRlZF9wYWNrc19iYXRjaChyLCBtLCBpbmNsdWRlX3BhY2ssIGJhdGNoX3NpemUpOwoJZWxzZQoJCWZpbGxfaW5jbHVkZWRfcGFja3NfYWxsKHIsIG0sIGluY2x1ZGVfcGFjayk7CgoJZm9yIChpID0gMDsgaSA8IG0tPm51bV9wYWNrczsgaSsrKSB7CgkJaWYgKGluY2x1ZGVfcGFja1tpXSkKCQkJcGFja3NfdG9fcmVwYWNrKys7Cgl9CglpZiAocGFja3NfdG9fcmVwYWNrIDw9IDEpCgkJZ290byBjbGVhbnVwOwoKCXJlcG9fY29uZmlnX2dldF9ib29sKHIsICJyZXBhY2sudXNlZGVsdGFiYXNlb2Zmc2V0IiwgJmRlbHRhX2Jhc2Vfb2Zmc2V0KTsKCXJlcG9fY29uZmlnX2dldF9ib29sKHIsICJyZXBhY2sudXNlZGVsdGFpc2xhbmRzIiwgJnVzZV9kZWx0YV9pc2xhbmRzKTsKCglzdHJ2ZWNfcHVzaCgmY21kLmFyZ3MsICJwYWNrLW9iamVjdHMiKTsKCglzdHJ2ZWNfcHVzaGYoJmNtZC5hcmdzLCAiJXMvcGFjay9wYWNrIiwgb2JqZWN0X2Rpcik7CgoJaWYgKGRlbHRhX2Jhc2Vfb2Zmc2V0KQoJCXN0cnZlY19wdXNoKCZjbWQuYXJncywgIi0tZGVsdGEtYmFzZS1vZmZzZXQiKTsKCWlmICh1c2VfZGVsdGFfaXNsYW5kcykKCQlzdHJ2ZWNfcHVzaCgmY21kLmFyZ3MsICItLWRlbHRhLWlzbGFuZHMiKTsKCglpZiAoZmxhZ3MgJiBNSURYX1BST0dSRVNTKQoJCXN0cnZlY19wdXNoKCZjbWQuYXJncywgIi0tcHJvZ3Jlc3MiKTsKCWVsc2UKCQlzdHJ2ZWNfcHVzaCgmY21kLmFyZ3MsICItcSIpOwoKCWNtZC5naXRfY21kID0gMTsKCWNtZC5pbiA9IGNtZC5vdXQgPSAtMTsKCglpZiAoc3RhcnRfY29tbWFuZCgmY21kKSkgewoJCWVycm9yKF8oImNvdWxkIG5vdCBzdGFydCBwYWNrLW9iamVjdHMiKSk7CgkJcmVzdWx0ID0gMTsKCQlnb3RvIGNsZWFudXA7Cgl9CgoJY21kX2luID0geGZkb3BlbihjbWQuaW4sICJ3Iik7CgoJZm9yIChpID0gMDsgaSA8IG0tPm51bV9vYmplY3RzOyBpKyspIHsKCQlzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCQl1aW50MzJfdCBwYWNrX2ludF9pZCA9IG50aF9taWR4ZWRfcGFja19pbnRfaWQobSwgaSk7CgoJCWlmICghaW5jbHVkZV9wYWNrW3BhY2tfaW50X2lkXSkKCQkJY29udGludWU7CgoJCW50aF9taWR4ZWRfb2JqZWN0X29pZCgmb2lkLCBtLCBpKTsKCQlmcHJpbnRmKGNtZF9pbiwgIiVzXG4iLCBvaWRfdG9faGV4KCZvaWQpKTsKCX0KCWZjbG9zZShjbWRfaW4pOwoKCWlmIChmaW5pc2hfY29tbWFuZCgmY21kKSkgewoJCWVycm9yKF8oImNvdWxkIG5vdCBmaW5pc2ggcGFjay1vYmplY3RzIikpOwoJCXJlc3VsdCA9IDE7CgkJZ290byBjbGVhbnVwOwoJfQoKCXJlc3VsdCA9IHdyaXRlX21pZHhfaW50ZXJuYWwociwgb2JqZWN0X2RpciwgTlVMTCwgTlVMTCwgTlVMTCwgTlVMTCwKCQkJCSAgICAgZmxhZ3MpOwoKY2xlYW51cDoKCWZyZWUoaW5jbHVkZV9wYWNrKTsKCXJldHVybiByZXN1bHQ7Cn0K",
    "text": "#define DISABLE_SIGN_COMPARE_WARNINGS\n\n#include \"git-compat-util.h\"\n#include \"abspath.h\"\n#include \"config.h\"\n#include \"hex.h\"\n#include \"lockfile.h\"\n#include \"packfile.h\"\n#include \"object-file.h\"\n#include \"hash-lookup.h\"\n#include \"midx.h\"\n#include \"progress.h\"\n#include \"trace2.h\"\n#include \"run-command.h\"\n#include \"chunk-format.h\"\n#include \"pack-bitmap.h\"\n#include \"refs.h\"\n#include \"revision.h\"\n#include \"list-objects.h\"\n#include \"path.h\"\n#include \"pack-revindex.h\"\n\n#define PACK_EXPIRED UINT_MAX\n#define BITMAP_POS_UNKNOWN (~((uint32_t)0))\n#define MIDX_CHUNK_FANOUT_SIZE (sizeof(uint32_t) * 256)\n#define MIDX_CHUNK_LARGE_OFFSET_WIDTH (sizeof(uint64_t))\n\nextern int midx_checksum_valid(struct multi_pack_index *m);\nextern void clear_midx_files_ext(const char *object_dir, const char *ext,\n\t\t\t\t const char *keep_hash);\nextern void clear_incremental_midx_files_ext(const char *object_dir,\n\t\t\t\t\t     const char *ext,\n\t\t\t\t\t     const char **keep_hashes,\n\t\t\t\t\t     uint32_t hashes_nr);\nextern int cmp_idx_or_pack_name(const char *idx_or_pack_name,\n\t\t\t\tconst char *idx_name);\n\nstatic size_t write_midx_header(const struct git_hash_algo *hash_algo,\n\t\t\t\tstruct hashfile *f, unsigned char num_chunks,\n\t\t\t\tuint32_t num_packs)\n{\n\thashwrite_be32(f, MIDX_SIGNATURE);\n\thashwrite_u8(f, MIDX_VERSION);\n\thashwrite_u8(f, oid_version(hash_algo));\n\thashwrite_u8(f, num_chunks);\n\thashwrite_u8(f, 0); /* unused */\n\thashwrite_be32(f, num_packs);\n\n\treturn MIDX_HEADER_SIZE;\n}\n\nstruct pack_info {\n\tuint32_t orig_pack_int_id;\n\tchar *pack_name;\n\tstruct packed_git *p;\n\n\tuint32_t bitmap_pos;\n\tuint32_t bitmap_nr;\n\n\tunsigned expired : 1;\n};\n\nstatic void fill_pack_info(struct pack_info *info,\n\t\t\t   struct packed_git *p, const char *pack_name,\n\t\t\t   uint32_t orig_pack_int_id)\n{\n\tmemset(info, 0, sizeof(struct pack_info));\n\n\tinfo->orig_pack_int_id = orig_pack_int_id;\n\tinfo->pack_name = xstrdup(pack_name);\n\tinfo->p = p;\n\tinfo->bitmap_pos = BITMAP_POS_UNKNOWN;\n}\n\nstatic int pack_info_compare(const void *_a, const void *_b)\n{\n\tstruct pack_info *a = (struct pack_info *)_a;\n\tstruct pack_info *b = (struct pack_info *)_b;\n\treturn strcmp(a->pack_name, b->pack_name);\n}\n\nstatic int idx_or_pack_name_cmp(const void *_va, const void *_vb)\n{\n\tconst char *pack_name = _va;\n\tconst struct pack_info *compar = _vb;\n\n\treturn cmp_idx_or_pack_name(pack_name, compar->pack_name);\n}\n\nstruct write_midx_context {\n\tstruct pack_info *info;\n\tsize_t nr;\n\tsize_t alloc;\n\tstruct multi_pack_index *m;\n\tstruct multi_pack_index *base_midx;\n\tstruct progress *progress;\n\tunsigned pack_paths_checked;\n\n\tstruct pack_midx_entry *entries;\n\tsize_t entries_nr;\n\n\tuint32_t *pack_perm;\n\tuint32_t *pack_order;\n\tunsigned large_offsets_needed:1;\n\tuint32_t num_large_offsets;\n\n\tint preferred_pack_idx;\n\n\tint incremental;\n\tuint32_t num_multi_pack_indexes_before;\n\n\tstruct string_list *to_include;\n\n\tstruct repository *repo;\n};\n\nstatic int should_include_pack(const struct write_midx_context *ctx,\n\t\t\t       const char *file_name)\n{\n\t/*\n\t * Note that at most one of ctx->m and ctx->to_include are set,\n\t * so we are testing midx_contains_pack() and\n\t * string_list_has_string() independently (guarded by the\n\t * appropriate NULL checks).\n\t *\n\t * We could support passing to_include while reusing an existing\n\t * MIDX, but don't currently since the reuse process drags\n\t * forward all packs from an existing MIDX (without checking\n\t * whether or not they appear in the to_include list).\n\t *\n\t * If we added support for that, these next two conditional\n\t * should be performed independently (likely checking\n\t * to_include before the existing MIDX).\n\t */\n\tif (ctx->m && midx_contains_pack(ctx->m, file_name))\n\t\treturn 0;\n\telse if (ctx->base_midx && midx_contains_pack(ctx->base_midx,\n\t\t\t\t\t\t      file_name))\n\t\treturn 0;\n\telse if (ctx->to_include &&\n\t\t !string_list_has_string(ctx->to_include, file_name))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic void add_pack_to_midx(const char *full_path, size_t full_path_len,\n\t\t\t     const char *file_name, void *data)\n{\n\tstruct write_midx_context *ctx = data;\n\tstruct packed_git *p;\n\n\tif (ends_with(file_name, \".idx\")) {\n\t\tdisplay_progress(ctx->progress, ++ctx->pack_paths_checked);\n\n\t\tif (!should_include_pack(ctx, file_name))\n\t\t\treturn;\n\n\t\tALLOC_GROW(ctx->info, ctx->nr + 1, ctx->alloc);\n\t\tp = add_packed_git(ctx->repo, full_path, full_path_len, 0);\n\t\tif (!p) {\n\t\t\twarning(_(\"failed to add packfile '%s'\"),\n\t\t\t\tfull_path);\n\t\t\treturn;\n\t\t}\n\n\t\tif (open_pack_index(p)) {\n\t\t\twarning(_(\"failed to open pack-index '%s'\"),\n\t\t\t\tfull_path);\n\t\t\tclose_pack(p);\n\t\t\tfree(p);\n\t\t\treturn;\n\t\t}\n\n\t\tfill_pack_info(&ctx->info[ctx->nr], p, file_name, ctx->nr);\n\t\tctx->nr++;\n\t}\n}\n\nstruct pack_midx_entry {\n\tstruct object_id oid;\n\tuint32_t pack_int_id;\n\ttime_t pack_mtime;\n\tuint64_t offset;\n\tunsigned preferred : 1;\n};\n\nstatic int midx_oid_compare(const void *_a, const void *_b)\n{\n\tconst struct pack_midx_entry *a = (const struct pack_midx_entry *)_a;\n\tconst struct pack_midx_entry *b = (const struct pack_midx_entry *)_b;\n\tint cmp = oidcmp(&a->oid, &b->oid);\n\n\tif (cmp)\n\t\treturn cmp;\n\n\t/* Sort objects in a preferred pack first when multiple copies exist. */\n\tif (a->preferred > b->preferred)\n\t\treturn -1;\n\tif (a->preferred < b->preferred)\n\t\treturn 1;\n\n\tif (a->pack_mtime > b->pack_mtime)\n\t\treturn -1;\n\telse if (a->pack_mtime < b->pack_mtime)\n\t\treturn 1;\n\n\treturn a->pack_int_id - b->pack_int_id;\n}\n\nstatic int nth_midxed_pack_midx_entry(struct multi_pack_index *m,\n\t\t\t\t      struct pack_midx_entry *e,\n\t\t\t\t      uint32_t pos)\n{\n\tif (pos >= m->num_objects + m->num_objects_in_base)\n\t\treturn 1;\n\n\tnth_midxed_object_oid(&e->oid, m, pos);\n\te->pack_int_id = nth_midxed_pack_int_id(m, pos);\n\te->offset = nth_midxed_offset(m, pos);\n\n\t/* consider objects in midx to be from \"old\" packs */\n\te->pack_mtime = 0;\n\treturn 0;\n}\n\nstatic void fill_pack_entry(uint32_t pack_int_id,\n\t\t\t    struct packed_git *p,\n\t\t\t    uint32_t cur_object,\n\t\t\t    struct pack_midx_entry *entry,\n\t\t\t    int preferred)\n{\n\tif (nth_packed_object_id(&entry->oid, p, cur_object) < 0)\n\t\tdie(_(\"failed to locate object %d in packfile\"), cur_object);\n\n\tentry->pack_int_id = pack_int_id;\n\tentry->pack_mtime = p->mtime;\n\n\tentry->offset = nth_packed_object_offset(p, cur_object);\n\tentry->preferred = !!preferred;\n}\n\nstruct midx_fanout {\n\tstruct pack_midx_entry *entries;\n\tsize_t nr, alloc;\n};\n\nstatic void midx_fanout_grow(struct midx_fanout *fanout, size_t nr)\n{\n\tif (nr < fanout->nr)\n\t\tBUG(\"negative growth in midx_fanout_grow() (%\"PRIuMAX\" < %\"PRIuMAX\")\",\n\t\t    (uintmax_t)nr, (uintmax_t)fanout->nr);\n\tALLOC_GROW(fanout->entries, nr, fanout->alloc);\n}\n\nstatic void midx_fanout_sort(struct midx_fanout *fanout)\n{\n\tQSORT(fanout->entries, fanout->nr, midx_oid_compare);\n}\n\nstatic void midx_fanout_add_midx_fanout(struct midx_fanout *fanout,\n\t\t\t\t\tstruct multi_pack_index *m,\n\t\t\t\t\tuint32_t cur_fanout,\n\t\t\t\t\tint preferred_pack)\n{\n\tuint32_t start = m->num_objects_in_base, end;\n\tuint32_t cur_object;\n\n\tif (m->base_midx)\n\t\tmidx_fanout_add_midx_fanout(fanout, m->base_midx, cur_fanout,\n\t\t\t\t\t    preferred_pack);\n\n\tif (cur_fanout)\n\t\tstart += ntohl(m->chunk_oid_fanout[cur_fanout - 1]);\n\tend = m->num_objects_in_base + ntohl(m->chunk_oid_fanout[cur_fanout]);\n\n\tfor (cur_object = start; cur_object < end; cur_object++) {\n\t\tif ((preferred_pack > -1) &&\n\t\t    (preferred_pack == nth_midxed_pack_int_id(m, cur_object))) {\n\t\t\t/*\n\t\t\t * Objects from preferred packs are added\n\t\t\t * separately.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tmidx_fanout_grow(fanout, fanout->nr + 1);\n\t\tnth_midxed_pack_midx_entry(m,\n\t\t\t\t\t   &fanout->entries[fanout->nr],\n\t\t\t\t\t   cur_object);\n\t\tfanout->entries[fanout->nr].preferred = 0;\n\t\tfanout->nr++;\n\t}\n}\n\nstatic void midx_fanout_add_pack_fanout(struct midx_fanout *fanout,\n\t\t\t\t\tstruct pack_info *info,\n\t\t\t\t\tuint32_t cur_pack,\n\t\t\t\t\tint preferred,\n\t\t\t\t\tuint32_t cur_fanout)\n{\n\tstruct packed_git *pack = info[cur_pack].p;\n\tuint32_t start = 0, end;\n\tuint32_t cur_object;\n\n\tif (cur_fanout)\n\t\tstart = get_pack_fanout(pack, cur_fanout - 1);\n\tend = get_pack_fanout(pack, cur_fanout);\n\n\tfor (cur_object = start; cur_object < end; cur_object++) {\n\t\tmidx_fanout_grow(fanout, fanout->nr + 1);\n\t\tfill_pack_entry(cur_pack,\n\t\t\t\tinfo[cur_pack].p,\n\t\t\t\tcur_object,\n\t\t\t\t&fanout->entries[fanout->nr],\n\t\t\t\tpreferred);\n\t\tfanout->nr++;\n\t}\n}\n\n/*\n * It is possible to artificially get into a state where there are many\n * duplicate copies of objects. That can create high memory pressure if\n * we are to create a list of all objects before de-duplication. To reduce\n * this memory pressure without a significant performance drop, automatically\n * group objects by the first byte of their object id. Use the IDX fanout\n * tables to group the data, copy to a local array, then sort.\n *\n * Copy only the de-duplicated entries (selected by most-recent modified time\n * of a packfile containing the object).\n */\nstatic void compute_sorted_entries(struct write_midx_context *ctx,\n\t\t\t\t   uint32_t start_pack)\n{\n\tuint32_t cur_fanout, cur_pack, cur_object;\n\tsize_t alloc_objects, total_objects = 0;\n\tstruct midx_fanout fanout = { 0 };\n\n\tfor (cur_pack = start_pack; cur_pack < ctx->nr; cur_pack++)\n\t\ttotal_objects = st_add(total_objects,\n\t\t\t\t       ctx->info[cur_pack].p->num_objects);\n\n\t/*\n\t * As we de-duplicate by fanout value, we expect the fanout\n\t * slices to be evenly distributed, with some noise. Hence,\n\t * allocate slightly more than one 256th.\n\t */\n\talloc_objects = fanout.alloc = total_objects > 3200 ? total_objects / 200 : 16;\n\n\tALLOC_ARRAY(fanout.entries, fanout.alloc);\n\tALLOC_ARRAY(ctx->entries, alloc_objects);\n\tctx->entries_nr = 0;\n\n\tfor (cur_fanout = 0; cur_fanout < 256; cur_fanout++) {\n\t\tfanout.nr = 0;\n\n\t\tif (ctx->m && !ctx->incremental)\n\t\t\tmidx_fanout_add_midx_fanout(&fanout, ctx->m, cur_fanout,\n\t\t\t\t\t\t    ctx->preferred_pack_idx);\n\n\t\tfor (cur_pack = start_pack; cur_pack < ctx->nr; cur_pack++) {\n\t\t\tint preferred = cur_pack == ctx->preferred_pack_idx;\n\t\t\tmidx_fanout_add_pack_fanout(&fanout,\n\t\t\t\t\t\t    ctx->info, cur_pack,\n\t\t\t\t\t\t    preferred, cur_fanout);\n\t\t}\n\n\t\tif (-1 < ctx->preferred_pack_idx && ctx->preferred_pack_idx < start_pack)\n\t\t\tmidx_fanout_add_pack_fanout(&fanout, ctx->info,\n\t\t\t\t\t\t    ctx->preferred_pack_idx, 1,\n\t\t\t\t\t\t    cur_fanout);\n\n\t\tmidx_fanout_sort(&fanout);\n\n\t\t/*\n\t\t * The batch is now sorted by OID and then mtime (descending).\n\t\t * Take only the first duplicate.\n\t\t */\n\t\tfor (cur_object = 0; cur_object < fanout.nr; cur_object++) {\n\t\t\tif (cur_object && oideq(&fanout.entries[cur_object - 1].oid,\n\t\t\t\t\t\t&fanout.entries[cur_object].oid))\n\t\t\t\tcontinue;\n\t\t\tif (ctx->incremental && ctx->base_midx &&\n\t\t\t    midx_has_oid(ctx->base_midx,\n\t\t\t\t\t &fanout.entries[cur_object].oid))\n\t\t\t\tcontinue;\n\n\t\t\tALLOC_GROW(ctx->entries, st_add(ctx->entries_nr, 1),\n\t\t\t\t   alloc_objects);\n\t\t\tmemcpy(&ctx->entries[ctx->entries_nr],\n\t\t\t       &fanout.entries[cur_object],\n\t\t\t       sizeof(struct pack_midx_entry));\n\t\t\tctx->entries_nr++;\n\t\t}\n\t}\n\n\tfree(fanout.entries);\n}\n\nstatic int write_midx_pack_names(struct hashfile *f, void *data)\n{\n\tstruct write_midx_context *ctx = data;\n\tuint32_t i;\n\tunsigned char padding[MIDX_CHUNK_ALIGNMENT];\n\tsize_t written = 0;\n\n\tfor (i = 0; i < ctx->nr; i++) {\n\t\tsize_t writelen;\n\n\t\tif (ctx->info[i].expired)\n\t\t\tcontinue;\n\n\t\tif (i && strcmp(ctx->info[i].pack_name, ctx->info[i - 1].pack_name) <= 0)\n\t\t\tBUG(\"incorrect pack-file order: %s before %s\",\n\t\t\t    ctx->info[i - 1].pack_name,\n\t\t\t    ctx->info[i].pack_name);\n\n\t\twritelen = strlen(ctx->info[i].pack_name) + 1;\n\t\thashwrite(f, ctx->info[i].pack_name, writelen);\n\t\twritten += writelen;\n\t}\n\n\t/* add padding to be aligned */\n\ti = MIDX_CHUNK_ALIGNMENT - (written % MIDX_CHUNK_ALIGNMENT);\n\tif (i < MIDX_CHUNK_ALIGNMENT) {\n\t\tmemset(padding, 0, sizeof(padding));\n\t\thashwrite(f, padding, i);\n\t}\n\n\treturn 0;\n}\n\nstatic int write_midx_bitmapped_packs(struct hashfile *f, void *data)\n{\n\tstruct write_midx_context *ctx = data;\n\tsize_t i;\n\n\tfor (i = 0; i < ctx->nr; i++) {\n\t\tstruct pack_info *pack = &ctx->info[i];\n\t\tif (pack->expired)\n\t\t\tcontinue;\n\n\t\tif (pack->bitmap_pos == BITMAP_POS_UNKNOWN && pack->bitmap_nr)\n\t\t\tBUG(\"pack '%s' has no bitmap position, but has %d bitmapped object(s)\",\n\t\t\t    pack->pack_name, pack->bitmap_nr);\n\n\t\thashwrite_be32(f, pack->bitmap_pos);\n\t\thashwrite_be32(f, pack->bitmap_nr);\n\t}\n\treturn 0;\n}\n\nstatic int write_midx_oid_fanout(struct hashfile *f,\n\t\t\t\t void *data)\n{\n\tstruct write_midx_context *ctx = data;\n\tstruct pack_midx_entry *list = ctx->entries;\n\tstruct pack_midx_entry *last = ctx->entries + ctx->entries_nr;\n\tuint32_t count = 0;\n\tuint32_t i;\n\n\t/*\n\t* Write the first-level table (the list is sorted,\n\t* but we use a 256-entry lookup to be able to avoid\n\t* having to do eight extra binary search iterations).\n\t*/\n\tfor (i = 0; i < 256; i++) {\n\t\tstruct pack_midx_entry *next = list;\n\n\t\twhile (next < last && next->oid.hash[0] == i) {\n\t\t\tcount++;\n\t\t\tnext++;\n\t\t}\n\n\t\thashwrite_be32(f, count);\n\t\tlist = next;\n\t}\n\n\treturn 0;\n}\n\nstatic int write_midx_oid_lookup(struct hashfile *f,\n\t\t\t\t void *data)\n{\n\tstruct write_midx_context *ctx = data;\n\tunsigned char hash_len = ctx->repo->hash_algo->rawsz;\n\tstruct pack_midx_entry *list = ctx->entries;\n\tuint32_t i;\n\n\tfor (i = 0; i < ctx->entries_nr; i++) {\n\t\tstruct pack_midx_entry *obj = list++;\n\n\t\tif (i < ctx->entries_nr - 1) {\n\t\t\tstruct pack_midx_entry *next = list;\n\t\t\tif (oidcmp(&obj->oid, &next->oid) >= 0)\n\t\t\t\tBUG(\"OIDs not in order: %s >= %s\",\n\t\t\t\t    oid_to_hex(&obj->oid),\n\t\t\t\t    oid_to_hex(&next->oid));\n\t\t}\n\n\t\thashwrite(f, obj->oid.hash, (int)hash_len);\n\t}\n\n\treturn 0;\n}\n\nstatic int write_midx_object_offsets(struct hashfile *f,\n\t\t\t\t     void *data)\n{\n\tstruct write_midx_context *ctx = data;\n\tstruct pack_midx_entry *list = ctx->entries;\n\tuint32_t i, nr_large_offset = 0;\n\n\tfor (i = 0; i < ctx->entries_nr; i++) {\n\t\tstruct pack_midx_entry *obj = list++;\n\n\t\tif (ctx->pack_perm[obj->pack_int_id] == PACK_EXPIRED)\n\t\t\tBUG(\"object %s is in an expired pack with int-id %d\",\n\t\t\t    oid_to_hex(&obj->oid),\n\t\t\t    obj->pack_int_id);\n\n\t\thashwrite_be32(f, ctx->pack_perm[obj->pack_int_id]);\n\n\t\tif (ctx->large_offsets_needed && obj->offset >> 31)\n\t\t\thashwrite_be32(f, MIDX_LARGE_OFFSET_NEEDED | nr_large_offset++);\n\t\telse if (!ctx->large_offsets_needed && obj->offset >> 32)\n\t\t\tBUG(\"object %s requires a large offset (%\"PRIx64\") but the MIDX is not writing large offsets!\",\n\t\t\t    oid_to_hex(&obj->oid),\n\t\t\t    obj->offset);\n\t\telse\n\t\t\thashwrite_be32(f, (uint32_t)obj->offset);\n\t}\n\n\treturn 0;\n}\n\nstatic int write_midx_large_offsets(struct hashfile *f,\n\t\t\t\t    void *data)\n{\n\tstruct write_midx_context *ctx = data;\n\tstruct pack_midx_entry *list = ctx->entries;\n\tstruct pack_midx_entry *end = ctx->entries + ctx->entries_nr;\n\tuint32_t nr_large_offset = ctx->num_large_offsets;\n\n\twhile (nr_large_offset) {\n\t\tstruct pack_midx_entry *obj;\n\t\tuint64_t offset;\n\n\t\tif (list >= end)\n\t\t\tBUG(\"too many large-offset objects\");\n\n\t\tobj = list++;\n\t\toffset = obj->offset;\n\n\t\tif (!(offset >> 31))\n\t\t\tcontinue;\n\n\t\thashwrite_be64(f, offset);\n\n\t\tnr_large_offset--;\n\t}\n\n\treturn 0;\n}\n\nstatic int write_midx_revindex(struct hashfile *f,\n\t\t\t       void *data)\n{\n\tstruct write_midx_context *ctx = data;\n\tuint32_t i, nr_base;\n\n\tif (ctx->incremental && ctx->base_midx)\n\t\tnr_base = ctx->base_midx->num_objects +\n\t\t\tctx->base_midx->num_objects_in_base;\n\telse\n\t\tnr_base = 0;\n\n\tfor (i = 0; i < ctx->entries_nr; i++)\n\t\thashwrite_be32(f, ctx->pack_order[i] + nr_base);\n\n\treturn 0;\n}\n\nstruct midx_pack_order_data {\n\tuint32_t nr;\n\tuint32_t pack;\n\toff_t offset;\n};\n\nstatic int midx_pack_order_cmp(const void *va, const void *vb)\n{\n\tconst struct midx_pack_order_data *a = va, *b = vb;\n\tif (a->pack < b->pack)\n\t\treturn -1;\n\telse if (a->pack > b->pack)\n\t\treturn 1;\n\telse if (a->offset < b->offset)\n\t\treturn -1;\n\telse if (a->offset > b->offset)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic uint32_t *midx_pack_order(struct write_midx_context *ctx)\n{\n\tstruct midx_pack_order_data *data;\n\tuint32_t *pack_order, base_objects = 0;\n\tuint32_t i;\n\n\ttrace2_region_enter(\"midx\", \"midx_pack_order\", ctx->repo);\n\n\tif (ctx->incremental && ctx->base_midx)\n\t\tbase_objects = ctx->base_midx->num_objects +\n\t\t\tctx->base_midx->num_objects_in_base;\n\n\tALLOC_ARRAY(pack_order, ctx->entries_nr);\n\tALLOC_ARRAY(data, ctx->entries_nr);\n\n\tfor (i = 0; i < ctx->entries_nr; i++) {\n\t\tstruct pack_midx_entry *e = &ctx->entries[i];\n\t\tdata[i].nr = i;\n\t\tdata[i].pack = ctx->pack_perm[e->pack_int_id];\n\t\tif (!e->preferred)\n\t\t\tdata[i].pack |= (1U << 31);\n\t\tdata[i].offset = e->offset;\n\t}\n\n\tQSORT(data, ctx->entries_nr, midx_pack_order_cmp);\n\n\tfor (i = 0; i < ctx->entries_nr; i++) {\n\t\tstruct pack_midx_entry *e = &ctx->entries[data[i].nr];\n\t\tstruct pack_info *pack = &ctx->info[ctx->pack_perm[e->pack_int_id]];\n\t\tif (pack->bitmap_pos == BITMAP_POS_UNKNOWN)\n\t\t\tpack->bitmap_pos = i + base_objects;\n\t\tpack->bitmap_nr++;\n\t\tpack_order[i] = data[i].nr;\n\t}\n\tfor (i = 0; i < ctx->nr; i++) {\n\t\tstruct pack_info *pack = &ctx->info[ctx->pack_perm[i]];\n\t\tif (pack->bitmap_pos == BITMAP_POS_UNKNOWN)\n\t\t\tpack->bitmap_pos = 0;\n\t}\n\tfree(data);\n\n\ttrace2_region_leave(\"midx\", \"midx_pack_order\", ctx->repo);\n\n\treturn pack_order;\n}\n\nstatic void write_midx_reverse_index(char *midx_name, unsigned char *midx_hash,\n\t\t\t\t     struct write_midx_context *ctx)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tchar *tmp_file;\n\n\ttrace2_region_enter(\"midx\", \"write_midx_reverse_index\", ctx->repo);\n\n\tstrbuf_addf(&buf, \"%s-%s.rev\", midx_name, hash_to_hex_algop(midx_hash,\n\t\t\t\t\t\t\t\t    ctx->repo->hash_algo));\n\n\ttmp_file = write_rev_file_order(NULL, ctx->pack_order, ctx->entries_nr,\n\t\t\t\t\tmidx_hash, WRITE_REV);\n\n\tif (finalize_object_file(tmp_file, buf.buf))\n\t\tdie(_(\"cannot store reverse index file\"));\n\n\tstrbuf_release(&buf);\n\tfree(tmp_file);\n\n\ttrace2_region_leave(\"midx\", \"write_midx_reverse_index\", ctx->repo);\n}\n\nstatic void prepare_midx_packing_data(struct packing_data *pdata,\n\t\t\t\t      struct write_midx_context *ctx)\n{\n\tuint32_t i;\n\n\ttrace2_region_enter(\"midx\", \"prepare_midx_packing_data\", ctx->repo);\n\n\tmemset(pdata, 0, sizeof(struct packing_data));\n\tprepare_packing_data(ctx->repo, pdata);\n\n\tfor (i = 0; i < ctx->entries_nr; i++) {\n\t\tuint32_t pos = ctx->pack_order[i];\n\t\tstruct pack_midx_entry *from = &ctx->entries[pos];\n\t\tstruct object_entry *to = packlist_alloc(pdata, &from->oid);\n\n\t\toe_set_in_pack(pdata, to,\n\t\t\t       ctx->info[ctx->pack_perm[from->pack_int_id]].p);\n\t}\n\n\ttrace2_region_leave(\"midx\", \"prepare_midx_packing_data\", ctx->repo);\n}\n\nstatic int add_ref_to_pending(const char *refname, const char *referent UNUSED,\n\t\t\t      const struct object_id *oid,\n\t\t\t      int flag, void *cb_data)\n{\n\tstruct rev_info *revs = (struct rev_info*)cb_data;\n\tstruct object_id peeled;\n\tstruct object *object;\n\n\tif ((flag & REF_ISSYMREF) && (flag & REF_ISBROKEN)) {\n\t\twarning(\"symbolic ref is dangling: %s\", refname);\n\t\treturn 0;\n\t}\n\n\tif (!peel_iterated_oid(revs->repo, oid, &peeled))\n\t\toid = &peeled;\n\n\tobject = parse_object_or_die(oid, refname);\n\tif (object->type != OBJ_COMMIT)\n\t\treturn 0;\n\n\tadd_pending_object(revs, object, \"\");\n\tif (bitmap_is_preferred_refname(revs->repo, refname))\n\t\tobject->flags |= NEEDS_BITMAP;\n\treturn 0;\n}\n\nstruct bitmap_commit_cb {\n\tstruct commit **commits;\n\tsize_t commits_nr, commits_alloc;\n\n\tstruct write_midx_context *ctx;\n};\n\nstatic const struct object_id *bitmap_oid_access(size_t index,\n\t\t\t\t\t\t const void *_entries)\n{\n\tconst struct pack_midx_entry *entries = _entries;\n\treturn &entries[index].oid;\n}\n\nstatic void bitmap_show_commit(struct commit *commit, void *_data)\n{\n\tstruct bitmap_commit_cb *data = _data;\n\tint pos = oid_pos(&commit->object.oid, data->ctx->entries,\n\t\t\t  data->ctx->entries_nr,\n\t\t\t  bitmap_oid_access);\n\tif (pos < 0)\n\t\treturn;\n\n\tALLOC_GROW(data->commits, data->commits_nr + 1, data->commits_alloc);\n\tdata->commits[data->commits_nr++] = commit;\n}\n\nstatic int read_refs_snapshot(const char *refs_snapshot,\n\t\t\t      struct rev_info *revs)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct object_id oid;\n\tFILE *f = xfopen(refs_snapshot, \"r\");\n\n\twhile (strbuf_getline(&buf, f) != EOF) {\n\t\tstruct object *object;\n\t\tint preferred = 0;\n\t\tchar *hex = buf.buf;\n\t\tconst char *end = NULL;\n\n\t\tif (buf.len && *buf.buf == '+') {\n\t\t\tpreferred = 1;\n\t\t\thex = &buf.buf[1];\n\t\t}\n\n\t\tif (parse_oid_hex_algop(hex, &oid, &end, revs->repo->hash_algo) < 0)\n\t\t\tdie(_(\"could not parse line: %s\"), buf.buf);\n\t\tif (*end)\n\t\t\tdie(_(\"malformed line: %s\"), buf.buf);\n\n\t\tobject = parse_object_or_die(&oid, NULL);\n\t\tif (preferred)\n\t\t\tobject->flags |= NEEDS_BITMAP;\n\n\t\tadd_pending_object(revs, object, \"\");\n\t}\n\n\tfclose(f);\n\tstrbuf_release(&buf);\n\treturn 0;\n}\n\nstatic struct commit **find_commits_for_midx_bitmap(uint32_t *indexed_commits_nr_p,\n\t\t\t\t\t\t    const char *refs_snapshot,\n\t\t\t\t\t\t    struct write_midx_context *ctx)\n{\n\tstruct rev_info revs;\n\tstruct bitmap_commit_cb cb = {0};\n\n\ttrace2_region_enter(\"midx\", \"find_commits_for_midx_bitmap\", ctx->repo);\n\n\tcb.ctx = ctx;\n\n\trepo_init_revisions(ctx->repo, &revs, NULL);\n\tif (refs_snapshot) {\n\t\tread_refs_snapshot(refs_snapshot, &revs);\n\t} else {\n\t\tsetup_revisions(0, NULL, &revs, NULL);\n\t\trefs_for_each_ref(get_main_ref_store(ctx->repo),\n\t\t\t\t  add_ref_to_pending, &revs);\n\t}\n\n\t/*\n\t * Skipping promisor objects here is intentional, since it only excludes\n\t * them from the list of reachable commits that we want to select from\n\t * when computing the selection of MIDX'd commits to receive bitmaps.\n\t *\n\t * Reachability bitmaps do require that their objects be closed under\n\t * reachability, but fetching any objects missing from promisors at this\n\t * point is too late. But, if one of those objects can be reached from\n\t * an another object that is included in the bitmap, then we will\n\t * complain later that we don't have reachability closure (and fail\n\t * appropriately).\n\t */\n\tfetch_if_missing = 0;\n\trevs.exclude_promisor_objects = 1;\n\n\tif (prepare_revision_walk(&revs))\n\t\tdie(_(\"revision walk setup failed\"));\n\n\ttraverse_commit_list(&revs, bitmap_show_commit, NULL, &cb);\n\tif (indexed_commits_nr_p)\n\t\t*indexed_commits_nr_p = cb.commits_nr;\n\n\trelease_revisions(&revs);\n\n\ttrace2_region_leave(\"midx\", \"find_commits_for_midx_bitmap\", ctx->repo);\n\n\treturn cb.commits;\n}\n\nstatic int write_midx_bitmap(struct repository *r, const char *midx_name,\n\t\t\t     const unsigned char *midx_hash,\n\t\t\t     struct packing_data *pdata,\n\t\t\t     struct commit **commits,\n\t\t\t     uint32_t commits_nr,\n\t\t\t     uint32_t *pack_order,\n\t\t\t     unsigned flags)\n{\n\tint ret, i;\n\tuint16_t options = 0;\n\tstruct bitmap_writer writer;\n\tstruct pack_idx_entry **index;\n\tchar *bitmap_name = xstrfmt(\"%s-%s.bitmap\", midx_name,\n\t\t\t\t    hash_to_hex_algop(midx_hash, r->hash_algo));\n\n\ttrace2_region_enter(\"midx\", \"write_midx_bitmap\", r);\n\n\tif (flags & MIDX_WRITE_BITMAP_HASH_CACHE)\n\t\toptions |= BITMAP_OPT_HASH_CACHE;\n\n\tif (flags & MIDX_WRITE_BITMAP_LOOKUP_TABLE)\n\t\toptions |= BITMAP_OPT_LOOKUP_TABLE;\n\n\t/*\n\t * Build the MIDX-order index based on pdata.objects (which is already\n\t * in MIDX order; c.f., 'midx_pack_order_cmp()' for the definition of\n\t * this order).\n\t */\n\tALLOC_ARRAY(index, pdata->nr_objects);\n\tfor (i = 0; i < pdata->nr_objects; i++)\n\t\tindex[i] = &pdata->objects[i].idx;\n\n\tbitmap_writer_init(&writer, r, pdata);\n\tbitmap_writer_show_progress(&writer, flags & MIDX_PROGRESS);\n\tbitmap_writer_build_type_index(&writer, index);\n\n\t/*\n\t * bitmap_writer_finish expects objects in lex order, but pack_order\n\t * gives us exactly that. use it directly instead of re-sorting the\n\t * array.\n\t *\n\t * This changes the order of objects in 'index' between\n\t * bitmap_writer_build_type_index and bitmap_writer_finish.\n\t *\n\t * The same re-ordering takes place in the single-pack bitmap code via\n\t * write_idx_file(), which is called by finish_tmp_packfile(), which\n\t * happens between bitmap_writer_build_type_index() and\n\t * bitmap_writer_finish().\n\t */\n\tfor (i = 0; i < pdata->nr_objects; i++)\n\t\tindex[pack_order[i]] = &pdata->objects[i].idx;\n\n\tbitmap_writer_select_commits(&writer, commits, commits_nr);\n\tret = bitmap_writer_build(&writer);\n\tif (ret < 0)\n\t\tgoto cleanup;\n\n\tbitmap_writer_set_checksum(&writer, midx_hash);\n\tbitmap_writer_finish(&writer, index, bitmap_name, options);\n\ncleanup:\n\tfree(index);\n\tfree(bitmap_name);\n\tbitmap_writer_free(&writer);\n\n\ttrace2_region_leave(\"midx\", \"write_midx_bitmap\", r);\n\n\treturn ret;\n}\n\nstatic struct multi_pack_index *lookup_multi_pack_index(struct repository *r,\n\t\t\t\t\t\t\tconst char *object_dir)\n{\n\tstruct multi_pack_index *result = NULL;\n\tstruct multi_pack_index *cur;\n\tchar *obj_dir_real = real_pathdup(object_dir, 1);\n\tstruct strbuf cur_path_real = STRBUF_INIT;\n\n\t/* Ensure the given object_dir is local, or a known alternate. */\n\tfind_odb(r, obj_dir_real);\n\n\tfor (cur = get_multi_pack_index(r); cur; cur = cur->next) {\n\t\tstrbuf_realpath(&cur_path_real, cur->object_dir, 1);\n\t\tif (!strcmp(obj_dir_real, cur_path_real.buf)) {\n\t\t\tresult = cur;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\ncleanup:\n\tfree(obj_dir_real);\n\tstrbuf_release(&cur_path_real);\n\treturn result;\n}\n\nstatic int fill_packs_from_midx(struct write_midx_context *ctx,\n\t\t\t\tconst char *preferred_pack_name, uint32_t flags)\n{\n\tstruct multi_pack_index *m;\n\n\tfor (m = ctx->m; m; m = m->base_midx) {\n\t\tuint32_t i;\n\n\t\tfor (i = 0; i < m->num_packs; i++) {\n\t\t\tALLOC_GROW(ctx->info, ctx->nr + 1, ctx->alloc);\n\n\t\t\t/*\n\t\t\t * If generating a reverse index, need to have\n\t\t\t * packed_git's loaded to compare their\n\t\t\t * mtimes and object count.\n\t\t\t *\n\t\t\t * If a preferred pack is specified, need to\n\t\t\t * have packed_git's loaded to ensure the chosen\n\t\t\t * preferred pack has a non-zero object count.\n\t\t\t */\n\t\t\tif (flags & MIDX_WRITE_REV_INDEX ||\n\t\t\t    preferred_pack_name) {\n\t\t\t\tif (prepare_midx_pack(ctx->repo, m,\n\t\t\t\t\t\t      m->num_packs_in_base + i)) {\n\t\t\t\t\terror(_(\"could not load pack\"));\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tif (open_pack_index(m->packs[i]))\n\t\t\t\t\tdie(_(\"could not open index for %s\"),\n\t\t\t\t\t    m->packs[i]->pack_name);\n\t\t\t}\n\n\t\t\tfill_pack_info(&ctx->info[ctx->nr++], m->packs[i],\n\t\t\t\t       m->pack_names[i],\n\t\t\t\t       m->num_packs_in_base + i);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic struct {\n\tconst char *non_split;\n\tconst char *split;\n} midx_exts[] = {\n\t{NULL, MIDX_EXT_MIDX},\n\t{MIDX_EXT_BITMAP, MIDX_EXT_BITMAP},\n\t{MIDX_EXT_REV, MIDX_EXT_REV},\n};\n\nstatic int link_midx_to_chain(struct multi_pack_index *m)\n{\n\tstruct strbuf from = STRBUF_INIT;\n\tstruct strbuf to = STRBUF_INIT;\n\tint ret = 0;\n\tsize_t i;\n\n\tif (!m || m->has_chain) {\n\t\t/*\n\t\t * Either no MIDX previously existed, or it was already\n\t\t * part of a MIDX chain. In both cases, we have nothing\n\t\t * to link, so return early.\n\t\t */\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(midx_exts); i++) {\n\t\tconst unsigned char *hash = get_midx_checksum(m);\n\n\t\tget_midx_filename_ext(m->repo->hash_algo, &from, m->object_dir,\n\t\t\t\t      hash, midx_exts[i].non_split);\n\t\tget_split_midx_filename_ext(m->repo->hash_algo, &to,\n\t\t\t\t\t    m->object_dir, hash,\n\t\t\t\t\t    midx_exts[i].split);\n\n\t\tif (link(from.buf, to.buf) < 0 && errno != ENOENT) {\n\t\t\tret = error_errno(_(\"unable to link '%s' to '%s'\"),\n\t\t\t\t\t  from.buf, to.buf);\n\t\t\tgoto done;\n\t\t}\n\n\t\tstrbuf_reset(&from);\n\t\tstrbuf_reset(&to);\n\t}\n\ndone:\n\tstrbuf_release(&from);\n\tstrbuf_release(&to);\n\treturn ret;\n}\n\nstatic void clear_midx_files(struct repository *r, const char *object_dir,\n\t\t\t     const char **hashes, uint32_t hashes_nr,\n\t\t\t     unsigned incremental)\n{\n\t/*\n\t * if incremental:\n\t *   - remove all non-incremental MIDX files\n\t *   - remove any incremental MIDX files not in the current one\n\t *\n\t * if non-incremental:\n\t *   - remove all incremental MIDX files\n\t *   - remove any non-incremental MIDX files not matching the current\n\t *     hash\n\t */\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *exts[] = { MIDX_EXT_BITMAP, MIDX_EXT_REV, MIDX_EXT_MIDX };\n\tuint32_t i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(exts); i++) {\n\t\tclear_incremental_midx_files_ext(object_dir, exts[i],\n\t\t\t\t\t\t hashes, hashes_nr);\n\t\tfor (j = 0; j < hashes_nr; j++)\n\t\t\tclear_midx_files_ext(object_dir, exts[i], hashes[j]);\n\t}\n\n\tif (incremental)\n\t\tget_midx_filename(r->hash_algo, &buf, object_dir);\n\telse\n\t\tget_midx_chain_filename(&buf, object_dir);\n\n\tif (unlink(buf.buf) && errno != ENOENT)\n\t\tdie_errno(_(\"failed to clear multi-pack-index at %s\"), buf.buf);\n\n\tstrbuf_release(&buf);\n}\n\nstatic int write_midx_internal(struct repository *r, const char *object_dir,\n\t\t\t       struct string_list *packs_to_include,\n\t\t\t       struct string_list *packs_to_drop,\n\t\t\t       const char *preferred_pack_name,\n\t\t\t       const char *refs_snapshot,\n\t\t\t       unsigned flags)\n{\n\tstruct strbuf midx_name = STRBUF_INIT;\n\tunsigned char midx_hash[GIT_MAX_RAWSZ];\n\tuint32_t i, start_pack;\n\tstruct hashfile *f = NULL;\n\tstruct lock_file lk;\n\tstruct tempfile *incr;\n\tstruct write_midx_context ctx = { 0 };\n\tint bitmapped_packs_concat_len = 0;\n\tint pack_name_concat_len = 0;\n\tint dropped_packs = 0;\n\tint result = 0;\n\tconst char **keep_hashes = NULL;\n\tstruct chunkfile *cf;\n\n\ttrace2_region_enter(\"midx\", \"write_midx_internal\", r);\n\n\tctx.repo = r;\n\n\tctx.incremental = !!(flags & MIDX_WRITE_INCREMENTAL);\n\tif (ctx.incremental && (flags & MIDX_WRITE_BITMAP))\n\t\tdie(_(\"cannot write incremental MIDX with bitmap\"));\n\n\tif (ctx.incremental)\n\t\tstrbuf_addf(&midx_name,\n\t\t\t    \"%s/pack/multi-pack-index.d/tmp_midx_XXXXXX\",\n\t\t\t    object_dir);\n\telse\n\t\tget_midx_filename(r->hash_algo, &midx_name, object_dir);\n\tif (safe_create_leading_directories(midx_name.buf))\n\t\tdie_errno(_(\"unable to create leading directories of %s\"),\n\t\t\t  midx_name.buf);\n\n\tif (!packs_to_include || ctx.incremental) {\n\t\tstruct multi_pack_index *m = lookup_multi_pack_index(r, object_dir);\n\t\tif (m && !midx_checksum_valid(m)) {\n\t\t\twarning(_(\"ignoring existing multi-pack-index; checksum mismatch\"));\n\t\t\tm = NULL;\n\t\t}\n\n\t\tif (m) {\n\t\t\t/*\n\t\t\t * Only reference an existing MIDX when not filtering\n\t\t\t * which packs to include, since all packs and objects\n\t\t\t * are copied blindly from an existing MIDX if one is\n\t\t\t * present.\n\t\t\t */\n\t\t\tif (ctx.incremental)\n\t\t\t\tctx.base_midx = m;\n\t\t\telse if (!packs_to_include)\n\t\t\t\tctx.m = m;\n\t\t}\n\t}\n\n\tctx.nr = 0;\n\tctx.alloc = ctx.m ? ctx.m->num_packs + ctx.m->num_packs_in_base : 16;\n\tctx.info = NULL;\n\tALLOC_ARRAY(ctx.info, ctx.alloc);\n\n\tif (ctx.incremental) {\n\t\tstruct multi_pack_index *m = ctx.base_midx;\n\t\twhile (m) {\n\t\t\tctx.num_multi_pack_indexes_before++;\n\t\t\tm = m->base_midx;\n\t\t}\n\t} else if (ctx.m && fill_packs_from_midx(&ctx, preferred_pack_name,\n\t\t\t\t\t\t flags) < 0) {\n\t\tgoto cleanup;\n\t}\n\n\tstart_pack = ctx.nr;\n\n\tctx.pack_paths_checked = 0;\n\tif (flags & MIDX_PROGRESS)\n\t\tctx.progress = start_delayed_progress(_(\"Adding packfiles to multi-pack-index\"), 0);\n\telse\n\t\tctx.progress = NULL;\n\n\tctx.to_include = packs_to_include;\n\n\tfor_each_file_in_pack_dir(object_dir, add_pack_to_midx, &ctx);\n\tstop_progress(&ctx.progress);\n\n\tif ((ctx.m && ctx.nr == ctx.m->num_packs + ctx.m->num_packs_in_base) &&\n\t    !ctx.incremental &&\n\t    !(packs_to_include || packs_to_drop)) {\n\t\tstruct bitmap_index *bitmap_git;\n\t\tint bitmap_exists;\n\t\tint want_bitmap = flags & MIDX_WRITE_BITMAP;\n\n\t\tbitmap_git = prepare_midx_bitmap_git(ctx.m);\n\t\tbitmap_exists = bitmap_git && bitmap_is_midx(bitmap_git);\n\t\tfree_bitmap_index(bitmap_git);\n\n\t\tif (bitmap_exists || !want_bitmap) {\n\t\t\t/*\n\t\t\t * The correct MIDX already exists, and so does a\n\t\t\t * corresponding bitmap (or one wasn't requested).\n\t\t\t */\n\t\t\tif (!want_bitmap)\n\t\t\t\tclear_midx_files_ext(object_dir, \"bitmap\", NULL);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (ctx.incremental && !ctx.nr)\n\t\tgoto cleanup; /* nothing to do */\n\n\tif (preferred_pack_name) {\n\t\tctx.preferred_pack_idx = -1;\n\n\t\tfor (i = 0; i < ctx.nr; i++) {\n\t\t\tif (!cmp_idx_or_pack_name(preferred_pack_name,\n\t\t\t\t\t\t  ctx.info[i].pack_name)) {\n\t\t\t\tctx.preferred_pack_idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ctx.preferred_pack_idx == -1)\n\t\t\twarning(_(\"unknown preferred pack: '%s'\"),\n\t\t\t\tpreferred_pack_name);\n\t} else if (ctx.nr &&\n\t\t   (flags & (MIDX_WRITE_REV_INDEX | MIDX_WRITE_BITMAP))) {\n\t\tstruct packed_git *oldest = ctx.info[ctx.preferred_pack_idx].p;\n\t\tctx.preferred_pack_idx = 0;\n\n\t\tif (packs_to_drop && packs_to_drop->nr)\n\t\t\tBUG(\"cannot write a MIDX bitmap during expiration\");\n\n\t\t/*\n\t\t * set a preferred pack when writing a bitmap to ensure that\n\t\t * the pack from which the first object is selected in pseudo\n\t\t * pack-order has all of its objects selected from that pack\n\t\t * (and not another pack containing a duplicate)\n\t\t */\n\t\tfor (i = 1; i < ctx.nr; i++) {\n\t\t\tstruct packed_git *p = ctx.info[i].p;\n\n\t\t\tif (!oldest->num_objects || p->mtime < oldest->mtime) {\n\t\t\t\toldest = p;\n\t\t\t\tctx.preferred_pack_idx = i;\n\t\t\t}\n\t\t}\n\n\t\tif (!oldest->num_objects) {\n\t\t\t/*\n\t\t\t * If all packs are empty; unset the preferred index.\n\t\t\t * This is acceptable since there will be no duplicate\n\t\t\t * objects to resolve, so the preferred value doesn't\n\t\t\t * matter.\n\t\t\t */\n\t\t\tctx.preferred_pack_idx = -1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * otherwise don't mark any pack as preferred to avoid\n\t\t * interfering with expiration logic below\n\t\t */\n\t\tctx.preferred_pack_idx = -1;\n\t}\n\n\tif (ctx.preferred_pack_idx > -1) {\n\t\tstruct packed_git *preferred = ctx.info[ctx.preferred_pack_idx].p;\n\t\tif (!preferred->num_objects) {\n\t\t\terror(_(\"cannot select preferred pack %s with no objects\"),\n\t\t\t      preferred->pack_name);\n\t\t\tresult = 1;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tcompute_sorted_entries(&ctx, start_pack);\n\n\tctx.large_offsets_needed = 0;\n\tfor (i = 0; i < ctx.entries_nr; i++) {\n\t\tif (ctx.entries[i].offset > 0x7fffffff)\n\t\t\tctx.num_large_offsets++;\n\t\tif (ctx.entries[i].offset > 0xffffffff)\n\t\t\tctx.large_offsets_needed = 1;\n\t}\n\n\tQSORT(ctx.info, ctx.nr, pack_info_compare);\n\n\tif (packs_to_drop && packs_to_drop->nr) {\n\t\tint drop_index = 0;\n\t\tint missing_drops = 0;\n\n\t\tfor (i = 0; i < ctx.nr && drop_index < packs_to_drop->nr; i++) {\n\t\t\tint cmp = strcmp(ctx.info[i].pack_name,\n\t\t\t\t\t packs_to_drop->items[drop_index].string);\n\n\t\t\tif (!cmp) {\n\t\t\t\tdrop_index++;\n\t\t\t\tctx.info[i].expired = 1;\n\t\t\t} else if (cmp > 0) {\n\t\t\t\terror(_(\"did not see pack-file %s to drop\"),\n\t\t\t\t      packs_to_drop->items[drop_index].string);\n\t\t\t\tdrop_index++;\n\t\t\t\tmissing_drops++;\n\t\t\t\ti--;\n\t\t\t} else {\n\t\t\t\tctx.info[i].expired = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (missing_drops) {\n\t\t\tresult = 1;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/*\n\t * pack_perm stores a permutation between pack-int-ids from the\n\t * previous multi-pack-index to the new one we are writing:\n\t *\n\t * pack_perm[old_id] = new_id\n\t */\n\tALLOC_ARRAY(ctx.pack_perm, ctx.nr);\n\tfor (i = 0; i < ctx.nr; i++) {\n\t\tif (ctx.info[i].expired) {\n\t\t\tdropped_packs++;\n\t\t\tctx.pack_perm[ctx.info[i].orig_pack_int_id] = PACK_EXPIRED;\n\t\t} else {\n\t\t\tctx.pack_perm[ctx.info[i].orig_pack_int_id] = i - dropped_packs;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ctx.nr; i++) {\n\t\tif (ctx.info[i].expired)\n\t\t\tcontinue;\n\t\tpack_name_concat_len += strlen(ctx.info[i].pack_name) + 1;\n\t\tbitmapped_packs_concat_len += 2 * sizeof(uint32_t);\n\t}\n\n\t/* Check that the preferred pack wasn't expired (if given). */\n\tif (preferred_pack_name) {\n\t\tstruct pack_info *preferred = bsearch(preferred_pack_name,\n\t\t\t\t\t\t      ctx.info, ctx.nr,\n\t\t\t\t\t\t      sizeof(*ctx.info),\n\t\t\t\t\t\t      idx_or_pack_name_cmp);\n\t\tif (preferred) {\n\t\t\tuint32_t perm = ctx.pack_perm[preferred->orig_pack_int_id];\n\t\t\tif (perm == PACK_EXPIRED)\n\t\t\t\twarning(_(\"preferred pack '%s' is expired\"),\n\t\t\t\t\tpreferred_pack_name);\n\t\t}\n\t}\n\n\tif (pack_name_concat_len % MIDX_CHUNK_ALIGNMENT)\n\t\tpack_name_concat_len += MIDX_CHUNK_ALIGNMENT -\n\t\t\t\t\t(pack_name_concat_len % MIDX_CHUNK_ALIGNMENT);\n\n\tif (ctx.nr - dropped_packs == 0) {\n\t\terror(_(\"no pack files to index.\"));\n\t\tresult = 1;\n\t\tgoto cleanup;\n\t}\n\n\tif (!ctx.entries_nr) {\n\t\tif (flags & MIDX_WRITE_BITMAP)\n\t\t\twarning(_(\"refusing to write multi-pack .bitmap without any objects\"));\n\t\tflags &= ~(MIDX_WRITE_REV_INDEX | MIDX_WRITE_BITMAP);\n\t}\n\n\tif (ctx.incremental) {\n\t\tstruct strbuf lock_name = STRBUF_INIT;\n\n\t\tget_midx_chain_filename(&lock_name, object_dir);\n\t\thold_lock_file_for_update(&lk, lock_name.buf, LOCK_DIE_ON_ERROR);\n\t\tstrbuf_release(&lock_name);\n\n\t\tincr = mks_tempfile_m(midx_name.buf, 0444);\n\t\tif (!incr) {\n\t\t\terror(_(\"unable to create temporary MIDX layer\"));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (adjust_shared_perm(get_tempfile_path(incr))) {\n\t\t\terror(_(\"unable to adjust shared permissions for '%s'\"),\n\t\t\t      get_tempfile_path(incr));\n\t\t\treturn -1;\n\t\t}\n\n\t\tf = hashfd(get_tempfile_fd(incr), get_tempfile_path(incr));\n\t} else {\n\t\thold_lock_file_for_update(&lk, midx_name.buf, LOCK_DIE_ON_ERROR);\n\t\tf = hashfd(get_lock_file_fd(&lk), get_lock_file_path(&lk));\n\t}\n\n\tcf = init_chunkfile(f);\n\n\tadd_chunk(cf, MIDX_CHUNKID_PACKNAMES, pack_name_concat_len,\n\t\t  write_midx_pack_names);\n\tadd_chunk(cf, MIDX_CHUNKID_OIDFANOUT, MIDX_CHUNK_FANOUT_SIZE,\n\t\t  write_midx_oid_fanout);\n\tadd_chunk(cf, MIDX_CHUNKID_OIDLOOKUP,\n\t\t  st_mult(ctx.entries_nr, r->hash_algo->rawsz),\n\t\t  write_midx_oid_lookup);\n\tadd_chunk(cf, MIDX_CHUNKID_OBJECTOFFSETS,\n\t\t  st_mult(ctx.entries_nr, MIDX_CHUNK_OFFSET_WIDTH),\n\t\t  write_midx_object_offsets);\n\n\tif (ctx.large_offsets_needed)\n\t\tadd_chunk(cf, MIDX_CHUNKID_LARGEOFFSETS,\n\t\t\tst_mult(ctx.num_large_offsets,\n\t\t\t\tMIDX_CHUNK_LARGE_OFFSET_WIDTH),\n\t\t\twrite_midx_large_offsets);\n\n\tif (flags & (MIDX_WRITE_REV_INDEX | MIDX_WRITE_BITMAP)) {\n\t\tctx.pack_order = midx_pack_order(&ctx);\n\t\tadd_chunk(cf, MIDX_CHUNKID_REVINDEX,\n\t\t\t  st_mult(ctx.entries_nr, sizeof(uint32_t)),\n\t\t\t  write_midx_revindex);\n\t\tadd_chunk(cf, MIDX_CHUNKID_BITMAPPEDPACKS,\n\t\t\t  bitmapped_packs_concat_len,\n\t\t\t  write_midx_bitmapped_packs);\n\t}\n\n\twrite_midx_header(r->hash_algo, f, get_num_chunks(cf),\n\t\t\t  ctx.nr - dropped_packs);\n\twrite_chunkfile(cf, &ctx);\n\n\tfinalize_hashfile(f, midx_hash, FSYNC_COMPONENT_PACK_METADATA,\n\t\t\t  CSUM_FSYNC | CSUM_HASH_IN_STREAM);\n\tfree_chunkfile(cf);\n\n\tif (flags & MIDX_WRITE_REV_INDEX &&\n\t    git_env_bool(\"GIT_TEST_MIDX_WRITE_REV\", 0))\n\t\twrite_midx_reverse_index(midx_name.buf, midx_hash, &ctx);\n\n\tif (flags & MIDX_WRITE_BITMAP) {\n\t\tstruct packing_data pdata;\n\t\tstruct commit **commits;\n\t\tuint32_t commits_nr;\n\n\t\tif (!ctx.entries_nr)\n\t\t\tBUG(\"cannot write a bitmap without any objects\");\n\n\t\tprepare_midx_packing_data(&pdata, &ctx);\n\n\t\tcommits = find_commits_for_midx_bitmap(&commits_nr, refs_snapshot, &ctx);\n\n\t\t/*\n\t\t * The previous steps translated the information from\n\t\t * 'entries' into information suitable for constructing\n\t\t * bitmaps. We no longer need that array, so clear it to\n\t\t * reduce memory pressure.\n\t\t */\n\t\tFREE_AND_NULL(ctx.entries);\n\t\tctx.entries_nr = 0;\n\n\t\tif (write_midx_bitmap(r, midx_name.buf, midx_hash, &pdata,\n\t\t\t\t      commits, commits_nr, ctx.pack_order,\n\t\t\t\t      flags) < 0) {\n\t\t\terror(_(\"could not write multi-pack bitmap\"));\n\t\t\tresult = 1;\n\t\t\tclear_packing_data(&pdata);\n\t\t\tfree(commits);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tclear_packing_data(&pdata);\n\t\tfree(commits);\n\t}\n\t/*\n\t * NOTE: Do not use ctx.entries beyond this point, since it might\n\t * have been freed in the previous if block.\n\t */\n\n\tCALLOC_ARRAY(keep_hashes, ctx.num_multi_pack_indexes_before + 1);\n\n\tif (ctx.incremental) {\n\t\tFILE *chainf = fdopen_lock_file(&lk, \"w\");\n\t\tstruct strbuf final_midx_name = STRBUF_INIT;\n\t\tstruct multi_pack_index *m = ctx.base_midx;\n\n\t\tif (!chainf) {\n\t\t\terror_errno(_(\"unable to open multi-pack-index chain file\"));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (link_midx_to_chain(ctx.base_midx) < 0)\n\t\t\treturn -1;\n\n\t\tget_split_midx_filename_ext(r->hash_algo, &final_midx_name,\n\t\t\t\t\t    object_dir, midx_hash, MIDX_EXT_MIDX);\n\n\t\tif (rename_tempfile(&incr, final_midx_name.buf) < 0) {\n\t\t\terror_errno(_(\"unable to rename new multi-pack-index layer\"));\n\t\t\treturn -1;\n\t\t}\n\n\t\tstrbuf_release(&final_midx_name);\n\n\t\tkeep_hashes[ctx.num_multi_pack_indexes_before] =\n\t\t\txstrdup(hash_to_hex_algop(midx_hash, r->hash_algo));\n\n\t\tfor (i = 0; i < ctx.num_multi_pack_indexes_before; i++) {\n\t\t\tuint32_t j = ctx.num_multi_pack_indexes_before - i - 1;\n\n\t\t\tkeep_hashes[j] = xstrdup(hash_to_hex_algop(get_midx_checksum(m),\n\t\t\t\t\t\t\t\t   r->hash_algo));\n\t\t\tm = m->base_midx;\n\t\t}\n\n\t\tfor (i = 0; i < ctx.num_multi_pack_indexes_before + 1; i++)\n\t\t\tfprintf(get_lock_file_fp(&lk), \"%s\\n\", keep_hashes[i]);\n\t} else {\n\t\tkeep_hashes[ctx.num_multi_pack_indexes_before] =\n\t\t\txstrdup(hash_to_hex_algop(midx_hash, r->hash_algo));\n\t}\n\n\tif (ctx.m || ctx.base_midx)\n\t\tclose_object_store(ctx.repo->objects);\n\n\tif (commit_lock_file(&lk) < 0)\n\t\tdie_errno(_(\"could not write multi-pack-index\"));\n\n\tclear_midx_files(r, object_dir, keep_hashes,\n\t\t\t ctx.num_multi_pack_indexes_before + 1,\n\t\t\t ctx.incremental);\n\ncleanup:\n\tfor (i = 0; i < ctx.nr; i++) {\n\t\tif (ctx.info[i].p) {\n\t\t\tclose_pack(ctx.info[i].p);\n\t\t\tfree(ctx.info[i].p);\n\t\t}\n\t\tfree(ctx.info[i].pack_name);\n\t}\n\n\tfree(ctx.info);\n\tfree(ctx.entries);\n\tfree(ctx.pack_perm);\n\tfree(ctx.pack_order);\n\tif (keep_hashes) {\n\t\tfor (i = 0; i < ctx.num_multi_pack_indexes_before + 1; i++)\n\t\t\tfree((char *)keep_hashes[i]);\n\t\tfree(keep_hashes);\n\t}\n\tstrbuf_release(&midx_name);\n\n\ttrace2_region_leave(\"midx\", \"write_midx_internal\", r);\n\n\treturn result;\n}\n\nint write_midx_file(struct repository *r, const char *object_dir,\n\t\t    const char *preferred_pack_name,\n\t\t    const char *refs_snapshot, unsigned flags)\n{\n\treturn write_midx_internal(r, object_dir, NULL, NULL,\n\t\t\t\t   preferred_pack_name, refs_snapshot,\n\t\t\t\t   flags);\n}\n\nint write_midx_file_only(struct repository *r, const char *object_dir,\n\t\t\t struct string_list *packs_to_include,\n\t\t\t const char *preferred_pack_name,\n\t\t\t const char *refs_snapshot, unsigned flags)\n{\n\treturn write_midx_internal(r, object_dir, packs_to_include, NULL,\n\t\t\t\t   preferred_pack_name, refs_snapshot, flags);\n}\n\nint expire_midx_packs(struct repository *r, const char *object_dir, unsigned flags)\n{\n\tuint32_t i, *count, result = 0;\n\tstruct string_list packs_to_drop = STRING_LIST_INIT_DUP;\n\tstruct multi_pack_index *m = lookup_multi_pack_index(r, object_dir);\n\tstruct progress *progress = NULL;\n\n\tif (!m)\n\t\treturn 0;\n\n\tif (m->base_midx)\n\t\tdie(_(\"cannot expire packs from an incremental multi-pack-index\"));\n\n\tCALLOC_ARRAY(count, m->num_packs);\n\n\tif (flags & MIDX_PROGRESS)\n\t\tprogress = start_delayed_progress(_(\"Counting referenced objects\"),\n\t\t\t\t\t  m->num_objects);\n\tfor (i = 0; i < m->num_objects; i++) {\n\t\tint pack_int_id = nth_midxed_pack_int_id(m, i);\n\t\tcount[pack_int_id]++;\n\t\tdisplay_progress(progress, i + 1);\n\t}\n\tstop_progress(&progress);\n\n\tif (flags & MIDX_PROGRESS)\n\t\tprogress = start_delayed_progress(_(\"Finding and deleting unreferenced packfiles\"),\n\t\t\t\t\t  m->num_packs);\n\tfor (i = 0; i < m->num_packs; i++) {\n\t\tchar *pack_name;\n\t\tdisplay_progress(progress, i + 1);\n\n\t\tif (count[i])\n\t\t\tcontinue;\n\n\t\tif (prepare_midx_pack(r, m, i))\n\t\t\tcontinue;\n\n\t\tif (m->packs[i]->pack_keep || m->packs[i]->is_cruft)\n\t\t\tcontinue;\n\n\t\tpack_name = xstrdup(m->packs[i]->pack_name);\n\t\tclose_pack(m->packs[i]);\n\n\t\tstring_list_insert(&packs_to_drop, m->pack_names[i]);\n\t\tunlink_pack_path(pack_name, 0);\n\t\tfree(pack_name);\n\t}\n\tstop_progress(&progress);\n\n\tfree(count);\n\n\tif (packs_to_drop.nr)\n\t\tresult = write_midx_internal(r, object_dir, NULL,\n\t\t\t\t\t     &packs_to_drop, NULL, NULL, flags);\n\n\tstring_list_clear(&packs_to_drop, 0);\n\n\treturn result;\n}\n\nstruct repack_info {\n\ttimestamp_t mtime;\n\tuint32_t referenced_objects;\n\tuint32_t pack_int_id;\n};\n\nstatic int compare_by_mtime(const void *a_, const void *b_)\n{\n\tconst struct repack_info *a, *b;\n\n\ta = (const struct repack_info *)a_;\n\tb = (const struct repack_info *)b_;\n\n\tif (a->mtime < b->mtime)\n\t\treturn -1;\n\tif (a->mtime > b->mtime)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int want_included_pack(struct repository *r,\n\t\t\t      struct multi_pack_index *m,\n\t\t\t      int pack_kept_objects,\n\t\t\t      uint32_t pack_int_id)\n{\n\tstruct packed_git *p;\n\tif (prepare_midx_pack(r, m, pack_int_id))\n\t\treturn 0;\n\tp = m->packs[pack_int_id];\n\tif (!pack_kept_objects && p->pack_keep)\n\t\treturn 0;\n\tif (p->is_cruft)\n\t\treturn 0;\n\tif (open_pack_index(p) || !p->num_objects)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic void fill_included_packs_all(struct repository *r,\n\t\t\t\t    struct multi_pack_index *m,\n\t\t\t\t    unsigned char *include_pack)\n{\n\tuint32_t i;\n\tint pack_kept_objects = 0;\n\n\trepo_config_get_bool(r, \"repack.packkeptobjects\", &pack_kept_objects);\n\n\tfor (i = 0; i < m->num_packs; i++) {\n\t\tif (!want_included_pack(r, m, pack_kept_objects, i))\n\t\t\tcontinue;\n\n\t\tinclude_pack[i] = 1;\n\t}\n}\n\nstatic void fill_included_packs_batch(struct repository *r,\n\t\t\t\t      struct multi_pack_index *m,\n\t\t\t\t      unsigned char *include_pack,\n\t\t\t\t      size_t batch_size)\n{\n\tuint32_t i;\n\tsize_t total_size;\n\tstruct repack_info *pack_info;\n\tint pack_kept_objects = 0;\n\n\tCALLOC_ARRAY(pack_info, m->num_packs);\n\n\trepo_config_get_bool(r, \"repack.packkeptobjects\", &pack_kept_objects);\n\n\tfor (i = 0; i < m->num_packs; i++) {\n\t\tpack_info[i].pack_int_id = i;\n\n\t\tif (prepare_midx_pack(r, m, i))\n\t\t\tcontinue;\n\n\t\tpack_info[i].mtime = m->packs[i]->mtime;\n\t}\n\n\tfor (i = 0; i < m->num_objects; i++) {\n\t\tuint32_t pack_int_id = nth_midxed_pack_int_id(m, i);\n\t\tpack_info[pack_int_id].referenced_objects++;\n\t}\n\n\tQSORT(pack_info, m->num_packs, compare_by_mtime);\n\n\ttotal_size = 0;\n\tfor (i = 0; total_size < batch_size && i < m->num_packs; i++) {\n\t\tint pack_int_id = pack_info[i].pack_int_id;\n\t\tstruct packed_git *p = m->packs[pack_int_id];\n\t\tsize_t expected_size;\n\n\t\tif (!want_included_pack(r, m, pack_kept_objects, pack_int_id))\n\t\t\tcontinue;\n\n\t\texpected_size = st_mult(p->pack_size,\n\t\t\t\t\tpack_info[i].referenced_objects);\n\t\texpected_size /= p->num_objects;\n\n\t\tif (expected_size >= batch_size)\n\t\t\tcontinue;\n\n\t\ttotal_size += expected_size;\n\t\tinclude_pack[pack_int_id] = 1;\n\t}\n\n\tfree(pack_info);\n}\n\nint midx_repack(struct repository *r, const char *object_dir, size_t batch_size, unsigned flags)\n{\n\tint result = 0;\n\tuint32_t i, packs_to_repack = 0;\n\tunsigned char *include_pack;\n\tstruct child_process cmd = CHILD_PROCESS_INIT;\n\tFILE *cmd_in;\n\tstruct multi_pack_index *m = lookup_multi_pack_index(r, object_dir);\n\n\t/*\n\t * When updating the default for these configuration\n\t * variables in builtin/repack.c, these must be adjusted\n\t * to match.\n\t */\n\tint delta_base_offset = 1;\n\tint use_delta_islands = 0;\n\n\tif (!m)\n\t\treturn 0;\n\tif (m->base_midx)\n\t\tdie(_(\"cannot repack an incremental multi-pack-index\"));\n\n\tCALLOC_ARRAY(include_pack, m->num_packs);\n\n\tif (batch_size)\n\t\tfill_included_packs_batch(r, m, include_pack, batch_size);\n\telse\n\t\tfill_included_packs_all(r, m, include_pack);\n\n\tfor (i = 0; i < m->num_packs; i++) {\n\t\tif (include_pack[i])\n\t\t\tpacks_to_repack++;\n\t}\n\tif (packs_to_repack <= 1)\n\t\tgoto cleanup;\n\n\trepo_config_get_bool(r, \"repack.usedeltabaseoffset\", &delta_base_offset);\n\trepo_config_get_bool(r, \"repack.usedeltaislands\", &use_delta_islands);\n\n\tstrvec_push(&cmd.args, \"pack-objects\");\n\n\tstrvec_pushf(&cmd.args, \"%s/pack/pack\", object_dir);\n\n\tif (delta_base_offset)\n\t\tstrvec_push(&cmd.args, \"--delta-base-offset\");\n\tif (use_delta_islands)\n\t\tstrvec_push(&cmd.args, \"--delta-islands\");\n\n\tif (flags & MIDX_PROGRESS)\n\t\tstrvec_push(&cmd.args, \"--progress\");\n\telse\n\t\tstrvec_push(&cmd.args, \"-q\");\n\n\tcmd.git_cmd = 1;\n\tcmd.in = cmd.out = -1;\n\n\tif (start_command(&cmd)) {\n\t\terror(_(\"could not start pack-objects\"));\n\t\tresult = 1;\n\t\tgoto cleanup;\n\t}\n\n\tcmd_in = xfdopen(cmd.in, \"w\");\n\n\tfor (i = 0; i < m->num_objects; i++) {\n\t\tstruct object_id oid;\n\t\tuint32_t pack_int_id = nth_midxed_pack_int_id(m, i);\n\n\t\tif (!include_pack[pack_int_id])\n\t\t\tcontinue;\n\n\t\tnth_midxed_object_oid(&oid, m, i);\n\t\tfprintf(cmd_in, \"%s\\n\", oid_to_hex(&oid));\n\t}\n\tfclose(cmd_in);\n\n\tif (finish_command(&cmd)) {\n\t\terror(_(\"could not finish pack-objects\"));\n\t\tresult = 1;\n\t\tgoto cleanup;\n\t}\n\n\tresult = write_midx_internal(r, object_dir, NULL, NULL, NULL, NULL,\n\t\t\t\t     flags);\n\ncleanup:\n\tfree(include_pack);\n\treturn result;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0066594fa6310b37903972e150c7cd1d7e232c38",
  "sha1_ok": true,
  "size": 47151
}
