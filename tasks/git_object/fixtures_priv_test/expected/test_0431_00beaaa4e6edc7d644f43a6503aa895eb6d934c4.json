{
  "content": {
    "base64": "I2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgInRyZWUuaCIKI2luY2x1ZGUgImJsb2IuaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAicGFjay5oIgojaW5jbHVkZSAiY2FjaGUtdHJlZS5oIgojaW5jbHVkZSAidHJlZS13YWxrLmgiCiNpbmNsdWRlICJmc2NrLmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCiNpbmNsdWRlICJkaXIuaCIKI2luY2x1ZGUgInByb2dyZXNzLmgiCiNpbmNsdWRlICJzdHJlYW1pbmcuaCIKI2luY2x1ZGUgImRlY29yYXRlLmgiCgojZGVmaW5lIFJFQUNIQUJMRSAweDAwMDEKI2RlZmluZSBTRUVOICAgICAgMHgwMDAyCiNkZWZpbmUgSEFTX09CSiAgIDB4MDAwNAoKc3RhdGljIGludCBzaG93X3Jvb3Q7CnN0YXRpYyBpbnQgc2hvd190YWdzOwpzdGF0aWMgaW50IHNob3dfdW5yZWFjaGFibGU7CnN0YXRpYyBpbnQgaW5jbHVkZV9yZWZsb2dzID0gMTsKc3RhdGljIGludCBjaGVja19mdWxsID0gMTsKc3RhdGljIGludCBjb25uZWN0aXZpdHlfb25seTsKc3RhdGljIGludCBjaGVja19zdHJpY3Q7CnN0YXRpYyBpbnQga2VlcF9jYWNoZV9vYmplY3RzOwpzdGF0aWMgc3RydWN0IGZzY2tfb3B0aW9ucyBmc2NrX3dhbGtfb3B0aW9ucyA9IEZTQ0tfT1BUSU9OU19ERUZBVUxUOwpzdGF0aWMgc3RydWN0IGZzY2tfb3B0aW9ucyBmc2NrX29ial9vcHRpb25zID0gRlNDS19PUFRJT05TX0RFRkFVTFQ7CnN0YXRpYyBzdHJ1Y3Qgb2JqZWN0X2lkIGhlYWRfb2lkOwpzdGF0aWMgY29uc3QgY2hhciAqaGVhZF9wb2ludHNfYXQ7CnN0YXRpYyBpbnQgZXJyb3JzX2ZvdW5kOwpzdGF0aWMgaW50IHdyaXRlX2xvc3RfYW5kX2ZvdW5kOwpzdGF0aWMgaW50IHZlcmJvc2U7CnN0YXRpYyBpbnQgc2hvd19wcm9ncmVzcyA9IC0xOwpzdGF0aWMgaW50IHNob3dfZGFuZ2xpbmcgPSAxOwpzdGF0aWMgaW50IG5hbWVfb2JqZWN0czsKI2RlZmluZSBFUlJPUl9PQkpFQ1QgMDEKI2RlZmluZSBFUlJPUl9SRUFDSEFCTEUgMDIKI2RlZmluZSBFUlJPUl9QQUNLIDA0CiNkZWZpbmUgRVJST1JfUkVGUyAwMTAKCnN0YXRpYyBjb25zdCBjaGFyICpkZXNjcmliZV9vYmplY3Qoc3RydWN0IG9iamVjdCAqb2JqKQp7CglzdGF0aWMgc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWNoYXIgKm5hbWUgPSBuYW1lX29iamVjdHMgPwoJCWxvb2t1cF9kZWNvcmF0aW9uKGZzY2tfd2Fsa19vcHRpb25zLm9iamVjdF9uYW1lcywgb2JqKSA6IE5VTEw7CgoJc3RyYnVmX3Jlc2V0KCZidWYpOwoJc3RyYnVmX2FkZHN0cigmYnVmLCBvaWRfdG9faGV4KCZvYmotPm9pZCkpOwoJaWYgKG5hbWUpCgkJc3RyYnVmX2FkZGYoJmJ1ZiwgIiAoJXMpIiwgbmFtZSk7CgoJcmV0dXJuIGJ1Zi5idWY7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpwcmludGFibGVfdHlwZShzdHJ1Y3Qgb2JqZWN0ICpvYmopCnsKCWNvbnN0IGNoYXIgKnJldDsKCglpZiAob2JqLT50eXBlID09IE9CSl9OT05FKSB7CgkJZW51bSBvYmplY3RfdHlwZSB0eXBlID0gc2hhMV9vYmplY3RfaW5mbyhvYmotPm9pZC5oYXNoLCBOVUxMKTsKCQlpZiAodHlwZSA+IDApCgkJCW9iamVjdF9hc190eXBlKG9iaiwgdHlwZSwgMCk7Cgl9CgoJcmV0ID0gdHlwZW5hbWUob2JqLT50eXBlKTsKCWlmICghcmV0KQoJCXJldCA9ICJ1bmtub3duIjsKCglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IGZzY2tfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmNiKQp7CglpZiAoc3RyY21wKHZhciwgImZzY2suc2tpcGxpc3QiKSA9PSAwKSB7CgkJY29uc3QgY2hhciAqcGF0aDsKCQlzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CgoJCWlmIChnaXRfY29uZmlnX3BhdGhuYW1lKCZwYXRoLCB2YXIsIHZhbHVlKSkKCQkJcmV0dXJuIDE7CgkJc3RyYnVmX2FkZGYoJnNiLCAic2tpcGxpc3Q9JXMiLCBwYXRoKTsKCQlmcmVlKChjaGFyICopcGF0aCk7CgkJZnNja19zZXRfbXNnX3R5cGVzKCZmc2NrX29ial9vcHRpb25zLCBzYi5idWYpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZzYik7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKHNraXBfcHJlZml4KHZhciwgImZzY2suIiwgJnZhcikpIHsKCQlmc2NrX3NldF9tc2dfdHlwZSgmZnNja19vYmpfb3B0aW9ucywgdmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CgoJcmV0dXJuIGdpdF9kZWZhdWx0X2NvbmZpZyh2YXIsIHZhbHVlLCBjYik7Cn0KCnN0YXRpYyB2b2lkIG9ianJlcG9ydChzdHJ1Y3Qgb2JqZWN0ICpvYmosIGNvbnN0IGNoYXIgKm1zZ190eXBlLAoJCQljb25zdCBjaGFyICplcnIpCnsKCWZwcmludGYoc3RkZXJyLCAiJXMgaW4gJXMgJXM6ICVzXG4iLAoJCW1zZ190eXBlLCBwcmludGFibGVfdHlwZShvYmopLCBkZXNjcmliZV9vYmplY3Qob2JqKSwgZXJyKTsKfQoKc3RhdGljIGludCBvYmplcnJvcihzdHJ1Y3Qgb2JqZWN0ICpvYmosIGNvbnN0IGNoYXIgKmVycikKewoJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX09CSkVDVDsKCW9ianJlcG9ydChvYmosICJlcnJvciIsIGVycik7CglyZXR1cm4gLTE7Cn0KCnN0YXRpYyBpbnQgZnNja19lcnJvcl9mdW5jKHN0cnVjdCBmc2NrX29wdGlvbnMgKm8sCglzdHJ1Y3Qgb2JqZWN0ICpvYmosIGludCB0eXBlLCBjb25zdCBjaGFyICptZXNzYWdlKQp7CglvYmpyZXBvcnQob2JqLCAodHlwZSA9PSBGU0NLX1dBUk4pID8gIndhcm5pbmciIDogImVycm9yIiwgbWVzc2FnZSk7CglyZXR1cm4gKHR5cGUgPT0gRlNDS19XQVJOKSA/IDAgOiAxOwp9CgpzdGF0aWMgc3RydWN0IG9iamVjdF9hcnJheSBwZW5kaW5nOwoKc3RhdGljIGludCBtYXJrX29iamVjdChzdHJ1Y3Qgb2JqZWN0ICpvYmosIGludCB0eXBlLCB2b2lkICpkYXRhLCBzdHJ1Y3QgZnNja19vcHRpb25zICpvcHRpb25zKQp7CglzdHJ1Y3Qgb2JqZWN0ICpwYXJlbnQgPSBkYXRhOwoKCS8qCgkgKiBUaGUgb25seSBjYXNlIGRhdGEgaXMgTlVMTCBvciB0eXBlIGlzIE9CSl9BTlkgaXMgd2hlbgoJICogbWFya19vYmplY3RfcmVhY2hhYmxlKCkgY2FsbHMgdXMuICBBbGwgdGhlIGNhbGxlcnMgb2YKCSAqIHRoYXQgZnVuY3Rpb24gaGFzIG5vbi1OVUxMIG9iaiBoZW5jZSAuLi4KCSAqLwoJaWYgKCFvYmopIHsKCQkvKiAuLi4gdGhlc2UgcmVmZXJlbmNlcyB0byBwYXJlbnQtPmZsZCBhcmUgc2FmZSBoZXJlICovCgkJcHJpbnRmKCJicm9rZW4gbGluayBmcm9tICU3cyAlc1xuIiwKCQkJICAgcHJpbnRhYmxlX3R5cGUocGFyZW50KSwgZGVzY3JpYmVfb2JqZWN0KHBhcmVudCkpOwoJCXByaW50ZigiYnJva2VuIGxpbmsgZnJvbSAlN3MgJXNcbiIsCgkJCSAgICh0eXBlID09IE9CSl9BTlkgPyAidW5rbm93biIgOiB0eXBlbmFtZSh0eXBlKSksICJ1bmtub3duIik7CgkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX1JFQUNIQUJMRTsKCQlyZXR1cm4gMTsKCX0KCglpZiAodHlwZSAhPSBPQkpfQU5ZICYmIG9iai0+dHlwZSAhPSB0eXBlKQoJCS8qIC4uLiBhbmQgdGhlIHJlZmVyZW5jZSB0byBwYXJlbnQgaXMgc2FmZSBoZXJlICovCgkJb2JqZXJyb3IocGFyZW50LCAid3Jvbmcgb2JqZWN0IHR5cGUgaW4gbGluayIpOwoKCWlmIChvYmotPmZsYWdzICYgUkVBQ0hBQkxFKQoJCXJldHVybiAwOwoJb2JqLT5mbGFncyB8PSBSRUFDSEFCTEU7CglpZiAoIShvYmotPmZsYWdzICYgSEFTX09CSikpIHsKCQlpZiAocGFyZW50ICYmICFoYXNfb2JqZWN0X2ZpbGUoJm9iai0+b2lkKSkgewoJCQlwcmludGYoImJyb2tlbiBsaW5rIGZyb20gJTdzICVzXG4iLAoJCQkJIHByaW50YWJsZV90eXBlKHBhcmVudCksIGRlc2NyaWJlX29iamVjdChwYXJlbnQpKTsKCQkJcHJpbnRmKCIgICAgICAgICAgICAgIHRvICU3cyAlc1xuIiwKCQkJCSBwcmludGFibGVfdHlwZShvYmopLCBkZXNjcmliZV9vYmplY3Qob2JqKSk7CgkJCWVycm9yc19mb3VuZCB8PSBFUlJPUl9SRUFDSEFCTEU7CgkJfQoJCXJldHVybiAxOwoJfQoKCWFkZF9vYmplY3RfYXJyYXkob2JqLCBOVUxMLCAmcGVuZGluZyk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgbWFya19vYmplY3RfcmVhY2hhYmxlKHN0cnVjdCBvYmplY3QgKm9iaikKewoJbWFya19vYmplY3Qob2JqLCBPQkpfQU5ZLCBOVUxMLCBOVUxMKTsKfQoKc3RhdGljIGludCB0cmF2ZXJzZV9vbmVfb2JqZWN0KHN0cnVjdCBvYmplY3QgKm9iaikKewoJaW50IHJlc3VsdDsKCXN0cnVjdCB0cmVlICp0cmVlID0gTlVMTDsKCglpZiAob2JqLT50eXBlID09IE9CSl9UUkVFKSB7CgkJdHJlZSA9IChzdHJ1Y3QgdHJlZSAqKW9iajsKCQlpZiAocGFyc2VfdHJlZSh0cmVlKSA8IDApCgkJCXJldHVybiAxOyAvKiBlcnJvciBhbHJlYWR5IGRpc3BsYXllZCAqLwoJfQoJcmVzdWx0ID0gZnNja193YWxrKG9iaiwgb2JqLCAmZnNja193YWxrX29wdGlvbnMpOwoJaWYgKHRyZWUpCgkJZnJlZV90cmVlX2J1ZmZlcih0cmVlKTsKCXJldHVybiByZXN1bHQ7Cn0KCnN0YXRpYyBpbnQgdHJhdmVyc2VfcmVhY2hhYmxlKHZvaWQpCnsKCXN0cnVjdCBwcm9ncmVzcyAqcHJvZ3Jlc3MgPSBOVUxMOwoJdW5zaWduZWQgaW50IG5yID0gMDsKCWludCByZXN1bHQgPSAwOwoJaWYgKHNob3dfcHJvZ3Jlc3MpCgkJcHJvZ3Jlc3MgPSBzdGFydF9wcm9ncmVzc19kZWxheShfKCJDaGVja2luZyBjb25uZWN0aXZpdHkiKSwgMCwgMCwgMik7Cgl3aGlsZSAocGVuZGluZy5ucikgewoJCXN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKmVudHJ5OwoJCXN0cnVjdCBvYmplY3QgKm9iajsKCgkJZW50cnkgPSBwZW5kaW5nLm9iamVjdHMgKyAtLXBlbmRpbmcubnI7CgkJb2JqID0gZW50cnktPml0ZW07CgkJcmVzdWx0IHw9IHRyYXZlcnNlX29uZV9vYmplY3Qob2JqKTsKCQlkaXNwbGF5X3Byb2dyZXNzKHByb2dyZXNzLCArK25yKTsKCX0KCXN0b3BfcHJvZ3Jlc3MoJnByb2dyZXNzKTsKCXJldHVybiAhIXJlc3VsdDsKfQoKc3RhdGljIGludCBtYXJrX3VzZWQoc3RydWN0IG9iamVjdCAqb2JqLCBpbnQgdHlwZSwgdm9pZCAqZGF0YSwgc3RydWN0IGZzY2tfb3B0aW9ucyAqb3B0aW9ucykKewoJaWYgKCFvYmopCgkJcmV0dXJuIDE7CglvYmotPnVzZWQgPSAxOwoJcmV0dXJuIDA7Cn0KCi8qCiAqIENoZWNrIGEgc2luZ2xlIHJlYWNoYWJsZSBvYmplY3QKICovCnN0YXRpYyB2b2lkIGNoZWNrX3JlYWNoYWJsZV9vYmplY3Qoc3RydWN0IG9iamVjdCAqb2JqKQp7CgkvKgoJICogV2Ugb2J2aW91c2x5IHdhbnQgdGhlIG9iamVjdCB0byBiZSBwYXJzZWQsCgkgKiBleGNlcHQgaWYgaXQgd2FzIGluIGEgcGFjay1maWxlIGFuZCB3ZSBkaWRuJ3QKCSAqIGRvIGEgZnVsbCBmc2NrCgkgKi8KCWlmICghKG9iai0+ZmxhZ3MgJiBIQVNfT0JKKSkgewoJCWlmIChoYXNfc2hhMV9wYWNrKG9iai0+b2lkLmhhc2gpKQoJCQlyZXR1cm47IC8qIGl0IGlzIGluIHBhY2sgLSBmb3JnZXQgYWJvdXQgaXQgKi8KCQlwcmludGYoIm1pc3NpbmcgJXMgJXNcbiIsIHByaW50YWJsZV90eXBlKG9iaiksCgkJCWRlc2NyaWJlX29iamVjdChvYmopKTsKCQllcnJvcnNfZm91bmQgfD0gRVJST1JfUkVBQ0hBQkxFOwoJCXJldHVybjsKCX0KfQoKLyoKICogQ2hlY2sgYSBzaW5nbGUgdW5yZWFjaGFibGUgb2JqZWN0CiAqLwpzdGF0aWMgdm9pZCBjaGVja191bnJlYWNoYWJsZV9vYmplY3Qoc3RydWN0IG9iamVjdCAqb2JqKQp7CgkvKgoJICogTWlzc2luZyB1bnJlYWNoYWJsZSBvYmplY3Q/IElnbm9yZSBpdC4gSXQncyBub3QgbGlrZQoJICogd2UgbWlzcyBpdCAoc2luY2UgaXQgY2FuJ3QgYmUgcmVhY2hlZCksIG5vciBkbyB3ZSB3YW50CgkgKiB0byBjb21wbGFpbiBhYm91dCBpdCBiZWluZyB1bnJlYWNoYWJsZSAoc2luY2UgaXQgZG9lcwoJICogbm90IGV4aXN0KS4KCSAqLwoJaWYgKCEob2JqLT5mbGFncyAmIEhBU19PQkopKQoJCXJldHVybjsKCgkvKgoJICogVW5yZWFjaGFibGUgb2JqZWN0IHRoYXQgZXhpc3RzPyBTaG93IGl0IGlmIGFza2VkIHRvLAoJICogc2luY2UgdGhpcyBpcyBzb21ldGhpbmcgdGhhdCBpcyBwcnVuYWJsZS4KCSAqLwoJaWYgKHNob3dfdW5yZWFjaGFibGUpIHsKCQlwcmludGYoInVucmVhY2hhYmxlICVzICVzXG4iLCBwcmludGFibGVfdHlwZShvYmopLAoJCQlkZXNjcmliZV9vYmplY3Qob2JqKSk7CgkJcmV0dXJuOwoJfQoKCS8qCgkgKiAiIXVzZWQiIG1lYW5zIHRoYXQgbm90aGluZyBhdCBhbGwgcG9pbnRzIHRvIGl0LCBpbmNsdWRpbmcKCSAqIG90aGVyIHVucmVhY2hhYmxlIG9iamVjdHMuIEluIG90aGVyIHdvcmRzLCBpdCdzIHRoZSAidGlwIgoJICogb2Ygc29tZSBzZXQgb2YgdW5yZWFjaGFibGUgb2JqZWN0cywgdXN1YWxseSBhIGNvbW1pdCB0aGF0CgkgKiBnb3QgZHJvcHBlZC4KCSAqCgkgKiBTdWNoIHN0YXJ0aW5nIHBvaW50cyBhcmUgbW9yZSBpbnRlcmVzdGluZyB0aGFuIHNvbWUgcmFuZG9tCgkgKiBzZXQgb2YgdW5yZWFjaGFibGUgb2JqZWN0cywgc28gd2Ugc2hvdyB0aGVtIGV2ZW4gaWYgdGhlIHVzZXIKCSAqIGhhc24ndCBhc2tlZCBmb3IgX2FsbF8gdW5yZWFjaGFibGUgb2JqZWN0cy4gSWYgeW91IGhhdmUKCSAqIGRlbGV0ZWQgYSBicmFuY2ggYnkgbWlzdGFrZSwgdGhpcyBpcyBhIHByaW1lIGNhbmRpZGF0ZSB0bwoJICogc3RhcnQgbG9va2luZyBhdCwgZm9yIGV4YW1wbGUuCgkgKi8KCWlmICghb2JqLT51c2VkKSB7CgkJaWYgKHNob3dfZGFuZ2xpbmcpCgkJCXByaW50ZigiZGFuZ2xpbmcgJXMgJXNcbiIsIHByaW50YWJsZV90eXBlKG9iaiksCgkJCSAgICAgICBkZXNjcmliZV9vYmplY3Qob2JqKSk7CgkJaWYgKHdyaXRlX2xvc3RfYW5kX2ZvdW5kKSB7CgkJCWNoYXIgKmZpbGVuYW1lID0gZ2l0X3BhdGhkdXAoImxvc3QtZm91bmQvJXMvJXMiLAoJCQkJb2JqLT50eXBlID09IE9CSl9DT01NSVQgPyAiY29tbWl0IiA6ICJvdGhlciIsCgkJCQlkZXNjcmliZV9vYmplY3Qob2JqKSk7CgkJCUZJTEUgKmY7CgoJCQlpZiAoc2FmZV9jcmVhdGVfbGVhZGluZ19kaXJlY3Rvcmllc19jb25zdChmaWxlbmFtZSkpIHsKCQkJCWVycm9yKCJDb3VsZCBub3QgY3JlYXRlIGxvc3QtZm91bmQiKTsKCQkJCWZyZWUoZmlsZW5hbWUpOwoJCQkJcmV0dXJuOwoJCQl9CgkJCWYgPSB4Zm9wZW4oZmlsZW5hbWUsICJ3Iik7CgkJCWlmIChvYmotPnR5cGUgPT0gT0JKX0JMT0IpIHsKCQkJCWlmIChzdHJlYW1fYmxvYl90b19mZChmaWxlbm8oZiksICZvYmotPm9pZCwgTlVMTCwgMSkpCgkJCQkJZGllX2Vycm5vKCJDb3VsZCBub3Qgd3JpdGUgJyVzJyIsIGZpbGVuYW1lKTsKCQkJfSBlbHNlCgkJCQlmcHJpbnRmKGYsICIlc1xuIiwgZGVzY3JpYmVfb2JqZWN0KG9iaikpOwoJCQlpZiAoZmNsb3NlKGYpKQoJCQkJZGllX2Vycm5vKCJDb3VsZCBub3QgZmluaXNoICclcyciLAoJCQkJCSAgZmlsZW5hbWUpOwoJCQlmcmVlKGZpbGVuYW1lKTsKCQl9CgkJcmV0dXJuOwoJfQoKCS8qCgkgKiBPdGhlcndpc2U/IEl0J3MgdGhlcmUsIGl0J3MgdW5yZWFjaGFibGUsIGFuZCBzb21lIG90aGVyIHVucmVhY2hhYmxlCgkgKiBvYmplY3QgcG9pbnRzIHRvIGl0LiBJZ25vcmUgaXQgLSBpdCdzIG5vdCBpbnRlcmVzdGluZywgYW5kIHdlIHNob3dlZAoJICogYWxsIHRoZSBpbnRlcmVzdGluZyBjYXNlcyBhYm92ZS4KCSAqLwp9CgpzdGF0aWMgdm9pZCBjaGVja19vYmplY3Qoc3RydWN0IG9iamVjdCAqb2JqKQp7CglpZiAodmVyYm9zZSkKCQlmcHJpbnRmKHN0ZGVyciwgIkNoZWNraW5nICVzXG4iLCBkZXNjcmliZV9vYmplY3Qob2JqKSk7CgoJaWYgKG9iai0+ZmxhZ3MgJiBSRUFDSEFCTEUpCgkJY2hlY2tfcmVhY2hhYmxlX29iamVjdChvYmopOwoJZWxzZQoJCWNoZWNrX3VucmVhY2hhYmxlX29iamVjdChvYmopOwp9CgpzdGF0aWMgdm9pZCBjaGVja19jb25uZWN0aXZpdHkodm9pZCkKewoJaW50IGksIG1heDsKCgkvKiBUcmF2ZXJzZSB0aGUgcGVuZGluZyByZWFjaGFibGUgb2JqZWN0cyAqLwoJdHJhdmVyc2VfcmVhY2hhYmxlKCk7CgoJLyogTG9vayB1cCBhbGwgdGhlIHJlcXVpcmVtZW50cywgd2FybiBhYm91dCBtaXNzaW5nIG9iamVjdHMuLiAqLwoJbWF4ID0gZ2V0X21heF9vYmplY3RfaW5kZXgoKTsKCWlmICh2ZXJib3NlKQoJCWZwcmludGYoc3RkZXJyLCAiQ2hlY2tpbmcgY29ubmVjdGl2aXR5ICglZCBvYmplY3RzKVxuIiwgbWF4KTsKCglmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmogPSBnZXRfaW5kZXhlZF9vYmplY3QoaSk7CgoJCWlmIChvYmopCgkJCWNoZWNrX29iamVjdChvYmopOwoJfQp9CgpzdGF0aWMgaW50IGZzY2tfb2JqKHN0cnVjdCBvYmplY3QgKm9iaikKewoJaWYgKG9iai0+ZmxhZ3MgJiBTRUVOKQoJCXJldHVybiAwOwoJb2JqLT5mbGFncyB8PSBTRUVOOwoKCWlmICh2ZXJib3NlKQoJCWZwcmludGYoc3RkZXJyLCAiQ2hlY2tpbmcgJXMgJXNcbiIsCgkJCXByaW50YWJsZV90eXBlKG9iaiksIGRlc2NyaWJlX29iamVjdChvYmopKTsKCglpZiAoZnNja193YWxrKG9iaiwgTlVMTCwgJmZzY2tfb2JqX29wdGlvbnMpKQoJCW9iamVycm9yKG9iaiwgImJyb2tlbiBsaW5rcyIpOwoJaWYgKGZzY2tfb2JqZWN0KG9iaiwgTlVMTCwgMCwgJmZzY2tfb2JqX29wdGlvbnMpKQoJCXJldHVybiAtMTsKCglpZiAob2JqLT50eXBlID09IE9CSl9UUkVFKSB7CgkJc3RydWN0IHRyZWUgKml0ZW0gPSAoc3RydWN0IHRyZWUgKikgb2JqOwoKCQlmcmVlX3RyZWVfYnVmZmVyKGl0ZW0pOwoJfQoKCWlmIChvYmotPnR5cGUgPT0gT0JKX0NPTU1JVCkgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IChzdHJ1Y3QgY29tbWl0ICopIG9iajsKCgkJZnJlZV9jb21taXRfYnVmZmVyKGNvbW1pdCk7CgoJCWlmICghY29tbWl0LT5wYXJlbnRzICYmIHNob3dfcm9vdCkKCQkJcHJpbnRmKCJyb290ICVzXG4iLCBkZXNjcmliZV9vYmplY3QoJmNvbW1pdC0+b2JqZWN0KSk7Cgl9CgoJaWYgKG9iai0+dHlwZSA9PSBPQkpfVEFHKSB7CgkJc3RydWN0IHRhZyAqdGFnID0gKHN0cnVjdCB0YWcgKikgb2JqOwoKCQlpZiAoc2hvd190YWdzICYmIHRhZy0+dGFnZ2VkKSB7CgkJCXByaW50ZigidGFnZ2VkICVzICVzIiwgcHJpbnRhYmxlX3R5cGUodGFnLT50YWdnZWQpLAoJCQkJZGVzY3JpYmVfb2JqZWN0KHRhZy0+dGFnZ2VkKSk7CgkJCXByaW50ZigiICglcykgaW4gJXNcbiIsIHRhZy0+dGFnLAoJCQkJZGVzY3JpYmVfb2JqZWN0KCZ0YWctPm9iamVjdCkpOwoJCX0KCX0KCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBmc2NrX29ial9idWZmZXIoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgZW51bSBvYmplY3RfdHlwZSB0eXBlLAoJCQkgICB1bnNpZ25lZCBsb25nIHNpemUsIHZvaWQgKmJ1ZmZlciwgaW50ICplYXRlbikKewoJLyoKCSAqIE5vdGUsIGJ1ZmZlciBtYXkgYmUgTlVMTCBpZiB0eXBlIGlzIE9CSl9CTE9CLiBTZWUKCSAqIHZlcmlmeV9wYWNrZmlsZSgpLCBkYXRhX3ZhbGlkIHZhcmlhYmxlIGZvciBkZXRhaWxzLgoJICovCglzdHJ1Y3Qgb2JqZWN0ICpvYmo7CglvYmogPSBwYXJzZV9vYmplY3RfYnVmZmVyKHNoYTEsIHR5cGUsIHNpemUsIGJ1ZmZlciwgZWF0ZW4pOwoJaWYgKCFvYmopIHsKCQllcnJvcnNfZm91bmQgfD0gRVJST1JfT0JKRUNUOwoJCXJldHVybiBlcnJvcigiJXM6IG9iamVjdCBjb3JydXB0IG9yIG1pc3NpbmciLCBzaGExX3RvX2hleChzaGExKSk7Cgl9CglvYmotPmZsYWdzID0gSEFTX09CSjsKCXJldHVybiBmc2NrX29iaihvYmopOwp9CgpzdGF0aWMgaW50IGRlZmF1bHRfcmVmczsKCnN0YXRpYyB2b2lkIGZzY2tfaGFuZGxlX3JlZmxvZ19vaWQoY29uc3QgY2hhciAqcmVmbmFtZSwgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJdW5zaWduZWQgbG9uZyB0aW1lc3RhbXApCnsKCXN0cnVjdCBvYmplY3QgKm9iajsKCglpZiAoIWlzX251bGxfb2lkKG9pZCkpIHsKCQlvYmogPSBsb29rdXBfb2JqZWN0KG9pZC0+aGFzaCk7CgkJaWYgKG9iaiAmJiAob2JqLT5mbGFncyAmIEhBU19PQkopKSB7CgkJCWlmICh0aW1lc3RhbXAgJiYgbmFtZV9vYmplY3RzKQoJCQkJYWRkX2RlY29yYXRpb24oZnNja193YWxrX29wdGlvbnMub2JqZWN0X25hbWVzLAoJCQkJCW9iaiwKCQkJCQl4c3RyZm10KCIlc0B7JWxkfSIsIHJlZm5hbWUsIHRpbWVzdGFtcCkpOwoJCQlvYmotPnVzZWQgPSAxOwoJCQltYXJrX29iamVjdF9yZWFjaGFibGUob2JqKTsKCQl9IGVsc2UgewoJCQllcnJvcigiJXM6IGludmFsaWQgcmVmbG9nIGVudHJ5ICVzIiwgcmVmbmFtZSwgb2lkX3RvX2hleChvaWQpKTsKCQkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX1JFQUNIQUJMRTsKCQl9Cgl9Cn0KCnN0YXRpYyBpbnQgZnNja19oYW5kbGVfcmVmbG9nX2VudChzdHJ1Y3Qgb2JqZWN0X2lkICpvb2lkLCBzdHJ1Y3Qgb2JqZWN0X2lkICpub2lkLAoJCWNvbnN0IGNoYXIgKmVtYWlsLCB1bnNpZ25lZCBsb25nIHRpbWVzdGFtcCwgaW50IHR6LAoJCWNvbnN0IGNoYXIgKm1lc3NhZ2UsIHZvaWQgKmNiX2RhdGEpCnsKCWNvbnN0IGNoYXIgKnJlZm5hbWUgPSBjYl9kYXRhOwoKCWlmICh2ZXJib3NlKQoJCWZwcmludGYoc3RkZXJyLCAiQ2hlY2tpbmcgcmVmbG9nICVzLT4lc1xuIiwKCQkJb2lkX3RvX2hleChvb2lkKSwgb2lkX3RvX2hleChub2lkKSk7CgoJZnNja19oYW5kbGVfcmVmbG9nX29pZChyZWZuYW1lLCBvb2lkLCAwKTsKCWZzY2tfaGFuZGxlX3JlZmxvZ19vaWQocmVmbmFtZSwgbm9pZCwgdGltZXN0YW1wKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGZzY2tfaGFuZGxlX3JlZmxvZyhjb25zdCBjaGFyICpsb2duYW1lLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCSAgICAgIGludCBmbGFnLCB2b2lkICpjYl9kYXRhKQp7Cglmb3JfZWFjaF9yZWZsb2dfZW50KGxvZ25hbWUsIGZzY2tfaGFuZGxlX3JlZmxvZ19lbnQsICh2b2lkICopbG9nbmFtZSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBmc2NrX2hhbmRsZV9yZWYoY29uc3QgY2hhciAqcmVmbmFtZSwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgICBpbnQgZmxhZywgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IG9iamVjdCAqb2JqOwoKCW9iaiA9IHBhcnNlX29iamVjdChvaWQtPmhhc2gpOwoJaWYgKCFvYmopIHsKCQllcnJvcigiJXM6IGludmFsaWQgc2hhMSBwb2ludGVyICVzIiwgcmVmbmFtZSwgb2lkX3RvX2hleChvaWQpKTsKCQllcnJvcnNfZm91bmQgfD0gRVJST1JfUkVBQ0hBQkxFOwoJCS8qIFdlJ2xsIGNvbnRpbnVlIHdpdGggdGhlIHJlc3QgZGVzcGl0ZSB0aGUgZXJyb3IuLiAqLwoJCXJldHVybiAwOwoJfQoJaWYgKG9iai0+dHlwZSAhPSBPQkpfQ09NTUlUICYmIGlzX2JyYW5jaChyZWZuYW1lKSkgewoJCWVycm9yKCIlczogbm90IGEgY29tbWl0IiwgcmVmbmFtZSk7CgkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX1JFRlM7Cgl9CglkZWZhdWx0X3JlZnMrKzsKCW9iai0+dXNlZCA9IDE7CglpZiAobmFtZV9vYmplY3RzKQoJCWFkZF9kZWNvcmF0aW9uKGZzY2tfd2Fsa19vcHRpb25zLm9iamVjdF9uYW1lcywKCQkJb2JqLCB4c3RyZHVwKHJlZm5hbWUpKTsKCW1hcmtfb2JqZWN0X3JlYWNoYWJsZShvYmopOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBnZXRfZGVmYXVsdF9oZWFkcyh2b2lkKQp7CglpZiAoaGVhZF9wb2ludHNfYXQgJiYgIWlzX251bGxfb2lkKCZoZWFkX29pZCkpCgkJZnNja19oYW5kbGVfcmVmKCJIRUFEIiwgJmhlYWRfb2lkLCAwLCBOVUxMKTsKCWZvcl9lYWNoX3Jhd3JlZihmc2NrX2hhbmRsZV9yZWYsIE5VTEwpOwoJaWYgKGluY2x1ZGVfcmVmbG9ncykKCQlmb3JfZWFjaF9yZWZsb2coZnNja19oYW5kbGVfcmVmbG9nLCBOVUxMKTsKCgkvKgoJICogTm90IGhhdmluZyBhbnkgZGVmYXVsdCBoZWFkcyBpc24ndCByZWFsbHkgZmF0YWwsIGJ1dAoJICogaXQgZG9lcyBtZWFuIHRoYXQgIi0tdW5yZWFjaGFibGUiIG5vIGxvbmdlciBtYWtlcyBhbnkKCSAqIHNlbnNlIChzaW5jZSBpbiB0aGlzIGNhc2UgZXZlcnl0aGluZyB3aWxsIG9idmlvdXNseQoJICogYmUgdW5yZWFjaGFibGUgYnkgZGVmaW5pdGlvbi4KCSAqCgkgKiBTaG93aW5nIGRhbmdsaW5nIG9iamVjdHMgaXMgdmFsaWQsIHRob3VnaCAoYXMgdGhvc2UKCSAqIGRhbmdsaW5nIG9iamVjdHMgYXJlIGxpa2VseSBsb3N0IGhlYWRzKS4KCSAqCgkgKiBTbyB3ZSBqdXN0IHByaW50IGEgd2FybmluZyBhYm91dCBpdCwgYW5kIGNsZWFyIHRoZQoJICogInNob3dfdW5yZWFjaGFibGUiIGZsYWcuCgkgKi8KCWlmICghZGVmYXVsdF9yZWZzKSB7CgkJZnByaW50ZihzdGRlcnIsICJub3RpY2U6IE5vIGRlZmF1bHQgcmVmZXJlbmNlc1xuIik7CgkJc2hvd191bnJlYWNoYWJsZSA9IDA7Cgl9Cn0KCnN0YXRpYyBzdHJ1Y3Qgb2JqZWN0ICpwYXJzZV9sb29zZV9vYmplY3QoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkJCSBjb25zdCBjaGFyICpwYXRoKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmo7Cgl2b2lkICpjb250ZW50czsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCWludCBlYXRlbjsKCglpZiAocmVhZF9sb29zZV9vYmplY3QocGF0aCwgb2lkLT5oYXNoLCAmdHlwZSwgJnNpemUsICZjb250ZW50cykgPCAwKQoJCXJldHVybiBOVUxMOwoKCWlmICghY29udGVudHMgJiYgdHlwZSAhPSBPQkpfQkxPQikKCQlkaWUoIkJVRzogcmVhZF9sb29zZV9vYmplY3Qgc3RyZWFtZWQgYSBub24tYmxvYiIpOwoKCW9iaiA9IHBhcnNlX29iamVjdF9idWZmZXIob2lkLT5oYXNoLCB0eXBlLCBzaXplLCBjb250ZW50cywgJmVhdGVuKTsKCglpZiAoIWVhdGVuKQoJCWZyZWUoY29udGVudHMpOwoJcmV0dXJuIG9iajsKfQoKc3RhdGljIGludCBmc2NrX2xvb3NlKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgY29uc3QgY2hhciAqcGF0aCwgdm9pZCAqZGF0YSkKewoJc3RydWN0IG9iamVjdCAqb2JqID0gcGFyc2VfbG9vc2Vfb2JqZWN0KG9pZCwgcGF0aCk7CgoJaWYgKCFvYmopIHsKCQllcnJvcnNfZm91bmQgfD0gRVJST1JfT0JKRUNUOwoJCWVycm9yKCIlczogb2JqZWN0IGNvcnJ1cHQgb3IgbWlzc2luZzogJXMiLAoJCSAgICAgIG9pZF90b19oZXgob2lkKSwgcGF0aCk7CgkJcmV0dXJuIDA7IC8qIGtlZXAgY2hlY2tpbmcgb3RoZXIgb2JqZWN0cyAqLwoJfQoKCW9iai0+ZmxhZ3MgPSBIQVNfT0JKOwoJaWYgKGZzY2tfb2JqKG9iaikpCgkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX09CSkVDVDsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGZzY2tfY3J1ZnQoY29uc3QgY2hhciAqYmFzZW5hbWUsIGNvbnN0IGNoYXIgKnBhdGgsIHZvaWQgKmRhdGEpCnsKCWlmICghc3RhcnRzX3dpdGgoYmFzZW5hbWUsICJ0bXBfb2JqXyIpKQoJCWZwcmludGYoc3RkZXJyLCAiYmFkIHNoYTEgZmlsZTogJXNcbiIsIHBhdGgpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZnNja19zdWJkaXIoaW50IG5yLCBjb25zdCBjaGFyICpwYXRoLCB2b2lkICpwcm9ncmVzcykKewoJZGlzcGxheV9wcm9ncmVzcyhwcm9ncmVzcywgbnIgKyAxKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBmc2NrX29iamVjdF9kaXIoY29uc3QgY2hhciAqcGF0aCkKewoJc3RydWN0IHByb2dyZXNzICpwcm9ncmVzcyA9IE5VTEw7CgoJaWYgKHZlcmJvc2UpCgkJZnByaW50ZihzdGRlcnIsICJDaGVja2luZyBvYmplY3QgZGlyZWN0b3J5XG4iKTsKCglpZiAoc2hvd19wcm9ncmVzcykKCQlwcm9ncmVzcyA9IHN0YXJ0X3Byb2dyZXNzKF8oIkNoZWNraW5nIG9iamVjdCBkaXJlY3RvcmllcyIpLCAyNTYpOwoKCWZvcl9lYWNoX2xvb3NlX2ZpbGVfaW5fb2JqZGlyKHBhdGgsIGZzY2tfbG9vc2UsIGZzY2tfY3J1ZnQsIGZzY2tfc3ViZGlyLAoJCQkJICAgICAgcHJvZ3Jlc3MpOwoJZGlzcGxheV9wcm9ncmVzcyhwcm9ncmVzcywgMjU2KTsKCXN0b3BfcHJvZ3Jlc3MoJnByb2dyZXNzKTsKfQoKc3RhdGljIGludCBmc2NrX2hlYWRfbGluayh2b2lkKQp7CglpbnQgbnVsbF9pc19lcnJvciA9IDA7CgoJaWYgKHZlcmJvc2UpCgkJZnByaW50ZihzdGRlcnIsICJDaGVja2luZyBIRUFEIGxpbmtcbiIpOwoKCWhlYWRfcG9pbnRzX2F0ID0gcmVzb2x2ZV9yZWZfdW5zYWZlKCJIRUFEIiwgMCwgaGVhZF9vaWQuaGFzaCwgTlVMTCk7CglpZiAoIWhlYWRfcG9pbnRzX2F0KSB7CgkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX1JFRlM7CgkJcmV0dXJuIGVycm9yKCJJbnZhbGlkIEhFQUQiKTsKCX0KCWlmICghc3RyY21wKGhlYWRfcG9pbnRzX2F0LCAiSEVBRCIpKQoJCS8qIGRldGFjaGVkIEhFQUQgKi8KCQludWxsX2lzX2Vycm9yID0gMTsKCWVsc2UgaWYgKCFzdGFydHNfd2l0aChoZWFkX3BvaW50c19hdCwgInJlZnMvaGVhZHMvIikpIHsKCQllcnJvcnNfZm91bmQgfD0gRVJST1JfUkVGUzsKCQlyZXR1cm4gZXJyb3IoIkhFQUQgcG9pbnRzIHRvIHNvbWV0aGluZyBzdHJhbmdlICglcykiLAoJCQkgICAgIGhlYWRfcG9pbnRzX2F0KTsKCX0KCWlmIChpc19udWxsX29pZCgmaGVhZF9vaWQpKSB7CgkJaWYgKG51bGxfaXNfZXJyb3IpIHsKCQkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX1JFRlM7CgkJCXJldHVybiBlcnJvcigiSEVBRDogZGV0YWNoZWQgSEVBRCBwb2ludHMgYXQgbm90aGluZyIpOwoJCX0KCQlmcHJpbnRmKHN0ZGVyciwgIm5vdGljZTogSEVBRCBwb2ludHMgdG8gYW4gdW5ib3JuIGJyYW5jaCAoJXMpXG4iLAoJCQloZWFkX3BvaW50c19hdCArIDExKTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGZzY2tfY2FjaGVfdHJlZShzdHJ1Y3QgY2FjaGVfdHJlZSAqaXQpCnsKCWludCBpOwoJaW50IGVyciA9IDA7CgoJaWYgKHZlcmJvc2UpCgkJZnByaW50ZihzdGRlcnIsICJDaGVja2luZyBjYWNoZSB0cmVlXG4iKTsKCglpZiAoMCA8PSBpdC0+ZW50cnlfY291bnQpIHsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmogPSBwYXJzZV9vYmplY3QoaXQtPnNoYTEpOwoJCWlmICghb2JqKSB7CgkJCWVycm9yKCIlczogaW52YWxpZCBzaGExIHBvaW50ZXIgaW4gY2FjaGUtdHJlZSIsCgkJCSAgICAgIHNoYTFfdG9faGV4KGl0LT5zaGExKSk7CgkJCWVycm9yc19mb3VuZCB8PSBFUlJPUl9SRUZTOwoJCQlyZXR1cm4gMTsKCQl9CgkJb2JqLT51c2VkID0gMTsKCQlpZiAobmFtZV9vYmplY3RzKQoJCQlhZGRfZGVjb3JhdGlvbihmc2NrX3dhbGtfb3B0aW9ucy5vYmplY3RfbmFtZXMsCgkJCQlvYmosIHhzdHJkdXAoIjoiKSk7CgkJbWFya19vYmplY3RfcmVhY2hhYmxlKG9iaik7CgkJaWYgKG9iai0+dHlwZSAhPSBPQkpfVFJFRSkKCQkJZXJyIHw9IG9iamVycm9yKG9iaiwgIm5vbi10cmVlIGluIGNhY2hlLXRyZWUiKTsKCX0KCWZvciAoaSA9IDA7IGkgPCBpdC0+c3VidHJlZV9ucjsgaSsrKQoJCWVyciB8PSBmc2NrX2NhY2hlX3RyZWUoaXQtPmRvd25baV0tPmNhY2hlX3RyZWUpOwoJcmV0dXJuIGVycjsKfQoKc3RhdGljIHZvaWQgbWFya19vYmplY3RfZm9yX2Nvbm5lY3Rpdml0eShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXN0cnVjdCBvYmplY3QgKm9iaiA9IGxvb2t1cF91bmtub3duX29iamVjdChvaWQtPmhhc2gpOwoJb2JqLT5mbGFncyB8PSBIQVNfT0JKOwp9CgpzdGF0aWMgaW50IG1hcmtfbG9vc2VfZm9yX2Nvbm5lY3Rpdml0eShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCQkgICAgICAgY29uc3QgY2hhciAqcGF0aCwKCQkJCSAgICAgICB2b2lkICpkYXRhKQp7CgltYXJrX29iamVjdF9mb3JfY29ubmVjdGl2aXR5KG9pZCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBtYXJrX3BhY2tlZF9mb3JfY29ubmVjdGl2aXR5KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCQlzdHJ1Y3QgcGFja2VkX2dpdCAqcGFjaywKCQkJCQl1aW50MzJfdCBwb3MsCgkJCQkJdm9pZCAqZGF0YSkKewoJbWFya19vYmplY3RfZm9yX2Nvbm5lY3Rpdml0eShvaWQpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBjaGFyIGNvbnN0ICogY29uc3QgZnNja191c2FnZVtdID0gewoJTl8oImdpdCBmc2NrIFs8b3B0aW9ucz5dIFs8b2JqZWN0Pi4uLl0iKSwKCU5VTEwKfTsKCnN0YXRpYyBzdHJ1Y3Qgb3B0aW9uIGZzY2tfb3B0c1tdID0gewoJT1BUX19WRVJCT1NFKCZ2ZXJib3NlLCBOXygiYmUgdmVyYm9zZSIpKSwKCU9QVF9CT09MKDAsICJ1bnJlYWNoYWJsZSIsICZzaG93X3VucmVhY2hhYmxlLCBOXygic2hvdyB1bnJlYWNoYWJsZSBvYmplY3RzIikpLAoJT1BUX0JPT0woMCwgImRhbmdsaW5nIiwgJnNob3dfZGFuZ2xpbmcsIE5fKCJzaG93IGRhbmdsaW5nIG9iamVjdHMiKSksCglPUFRfQk9PTCgwLCAidGFncyIsICZzaG93X3RhZ3MsIE5fKCJyZXBvcnQgdGFncyIpKSwKCU9QVF9CT09MKDAsICJyb290IiwgJnNob3dfcm9vdCwgTl8oInJlcG9ydCByb290IG5vZGVzIikpLAoJT1BUX0JPT0woMCwgImNhY2hlIiwgJmtlZXBfY2FjaGVfb2JqZWN0cywgTl8oIm1ha2UgaW5kZXggb2JqZWN0cyBoZWFkIG5vZGVzIikpLAoJT1BUX0JPT0woMCwgInJlZmxvZ3MiLCAmaW5jbHVkZV9yZWZsb2dzLCBOXygibWFrZSByZWZsb2dzIGhlYWQgbm9kZXMgKGRlZmF1bHQpIikpLAoJT1BUX0JPT0woMCwgImZ1bGwiLCAmY2hlY2tfZnVsbCwgTl8oImFsc28gY29uc2lkZXIgcGFja3MgYW5kIGFsdGVybmF0ZSBvYmplY3RzIikpLAoJT1BUX0JPT0woMCwgImNvbm5lY3Rpdml0eS1vbmx5IiwgJmNvbm5lY3Rpdml0eV9vbmx5LCBOXygiY2hlY2sgb25seSBjb25uZWN0aXZpdHkiKSksCglPUFRfQk9PTCgwLCAic3RyaWN0IiwgJmNoZWNrX3N0cmljdCwgTl8oImVuYWJsZSBtb3JlIHN0cmljdCBjaGVja2luZyIpKSwKCU9QVF9CT09MKDAsICJsb3N0LWZvdW5kIiwgJndyaXRlX2xvc3RfYW5kX2ZvdW5kLAoJCQkJTl8oIndyaXRlIGRhbmdsaW5nIG9iamVjdHMgaW4gLmdpdC9sb3N0LWZvdW5kIikpLAoJT1BUX0JPT0woMCwgInByb2dyZXNzIiwgJnNob3dfcHJvZ3Jlc3MsIE5fKCJzaG93IHByb2dyZXNzIikpLAoJT1BUX0JPT0woMCwgIm5hbWUtb2JqZWN0cyIsICZuYW1lX29iamVjdHMsIE5fKCJzaG93IHZlcmJvc2UgbmFtZXMgZm9yIHJlYWNoYWJsZSBvYmplY3RzIikpLAoJT1BUX0VORCgpLAp9OwoKaW50IGNtZF9mc2NrKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglpbnQgaSwgaGVhZHM7CglzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSAqYWx0OwoKCWVycm9yc19mb3VuZCA9IDA7CgljaGVja19yZXBsYWNlX3JlZnMgPSAwOwoKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgZnNja19vcHRzLCBmc2NrX3VzYWdlLCAwKTsKCglmc2NrX3dhbGtfb3B0aW9ucy53YWxrID0gbWFya19vYmplY3Q7Cglmc2NrX29ial9vcHRpb25zLndhbGsgPSBtYXJrX3VzZWQ7Cglmc2NrX29ial9vcHRpb25zLmVycm9yX2Z1bmMgPSBmc2NrX2Vycm9yX2Z1bmM7CglpZiAoY2hlY2tfc3RyaWN0KQoJCWZzY2tfb2JqX29wdGlvbnMuc3RyaWN0ID0gMTsKCglpZiAoc2hvd19wcm9ncmVzcyA9PSAtMSkKCQlzaG93X3Byb2dyZXNzID0gaXNhdHR5KDIpOwoJaWYgKHZlcmJvc2UpCgkJc2hvd19wcm9ncmVzcyA9IDA7CgoJaWYgKHdyaXRlX2xvc3RfYW5kX2ZvdW5kKSB7CgkJY2hlY2tfZnVsbCA9IDE7CgkJaW5jbHVkZV9yZWZsb2dzID0gMDsKCX0KCglpZiAobmFtZV9vYmplY3RzKQoJCWZzY2tfd2Fsa19vcHRpb25zLm9iamVjdF9uYW1lcyA9CgkJCXhjYWxsb2MoMSwgc2l6ZW9mKHN0cnVjdCBkZWNvcmF0aW9uKSk7CgoJZ2l0X2NvbmZpZyhmc2NrX2NvbmZpZywgTlVMTCk7CgoJZnNja19oZWFkX2xpbmsoKTsKCWlmIChjb25uZWN0aXZpdHlfb25seSkgewoJCWZvcl9lYWNoX2xvb3NlX29iamVjdChtYXJrX2xvb3NlX2Zvcl9jb25uZWN0aXZpdHksIE5VTEwsIDApOwoJCWZvcl9lYWNoX3BhY2tlZF9vYmplY3QobWFya19wYWNrZWRfZm9yX2Nvbm5lY3Rpdml0eSwgTlVMTCwgMCk7Cgl9IGVsc2UgewoJCWZzY2tfb2JqZWN0X2RpcihnZXRfb2JqZWN0X2RpcmVjdG9yeSgpKTsKCgkJcHJlcGFyZV9hbHRfb2RiKCk7CgkJZm9yIChhbHQgPSBhbHRfb2RiX2xpc3Q7IGFsdDsgYWx0ID0gYWx0LT5uZXh0KQoJCQlmc2NrX29iamVjdF9kaXIoYWx0LT5wYXRoKTsKCgkJaWYgKGNoZWNrX2Z1bGwpIHsKCQkJc3RydWN0IHBhY2tlZF9naXQgKnA7CgkJCXVpbnQzMl90IHRvdGFsID0gMCwgY291bnQgPSAwOwoJCQlzdHJ1Y3QgcHJvZ3Jlc3MgKnByb2dyZXNzID0gTlVMTDsKCgkJCXByZXBhcmVfcGFja2VkX2dpdCgpOwoKCQkJaWYgKHNob3dfcHJvZ3Jlc3MpIHsKCQkJCWZvciAocCA9IHBhY2tlZF9naXQ7IHA7IHAgPSBwLT5uZXh0KSB7CgkJCQkJaWYgKG9wZW5fcGFja19pbmRleChwKSkKCQkJCQkJY29udGludWU7CgkJCQkJdG90YWwgKz0gcC0+bnVtX29iamVjdHM7CgkJCQl9CgoJCQkJcHJvZ3Jlc3MgPSBzdGFydF9wcm9ncmVzcyhfKCJDaGVja2luZyBvYmplY3RzIiksIHRvdGFsKTsKCQkJfQoJCQlmb3IgKHAgPSBwYWNrZWRfZ2l0OyBwOyBwID0gcC0+bmV4dCkgewoJCQkJLyogdmVyaWZ5IGdpdmVzIGVycm9yIG1lc3NhZ2VzIGl0c2VsZiAqLwoJCQkJaWYgKHZlcmlmeV9wYWNrKHAsIGZzY2tfb2JqX2J1ZmZlciwKCQkJCQkJcHJvZ3Jlc3MsIGNvdW50KSkKCQkJCQllcnJvcnNfZm91bmQgfD0gRVJST1JfUEFDSzsKCQkJCWNvdW50ICs9IHAtPm51bV9vYmplY3RzOwoJCQl9CgkJCXN0b3BfcHJvZ3Jlc3MoJnByb2dyZXNzKTsKCQl9Cgl9CgoJaGVhZHMgPSAwOwoJZm9yIChpID0gMDsgaSA8IGFyZ2M7IGkrKykgewoJCWNvbnN0IGNoYXIgKmFyZyA9IGFyZ3ZbaV07CgkJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCQlpZiAoIWdldF9zaGExKGFyZywgc2hhMSkpIHsKCQkJc3RydWN0IG9iamVjdCAqb2JqID0gbG9va3VwX29iamVjdChzaGExKTsKCgkJCWlmICghb2JqIHx8ICEob2JqLT5mbGFncyAmIEhBU19PQkopKSB7CgkJCQllcnJvcigiJXM6IG9iamVjdCBtaXNzaW5nIiwgc2hhMV90b19oZXgoc2hhMSkpOwoJCQkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX09CSkVDVDsKCQkJCWNvbnRpbnVlOwoJCQl9CgoJCQlvYmotPnVzZWQgPSAxOwoJCQlpZiAobmFtZV9vYmplY3RzKQoJCQkJYWRkX2RlY29yYXRpb24oZnNja193YWxrX29wdGlvbnMub2JqZWN0X25hbWVzLAoJCQkJCW9iaiwgeHN0cmR1cChhcmcpKTsKCQkJbWFya19vYmplY3RfcmVhY2hhYmxlKG9iaik7CgkJCWhlYWRzKys7CgkJCWNvbnRpbnVlOwoJCX0KCQllcnJvcigiaW52YWxpZCBwYXJhbWV0ZXI6IGV4cGVjdGVkIHNoYTEsIGdvdCAnJXMnIiwgYXJnKTsKCQllcnJvcnNfZm91bmQgfD0gRVJST1JfT0JKRUNUOwoJfQoKCS8qCgkgKiBJZiB3ZSd2ZSBub3QgYmVlbiBnaXZlbiBhbnkgZXhwbGljaXQgaGVhZCBpbmZvcm1hdGlvbiwgZG8gdGhlCgkgKiBkZWZhdWx0IG9uZXMgZnJvbSAuZ2l0L3JlZnMuIFdlIGFsc28gY29uc2lkZXIgdGhlIGluZGV4IGZpbGUKCSAqIGluIHRoaXMgY2FzZSAoaWUgdGhpcyBpbXBsaWVzIC0tY2FjaGUpLgoJICovCglpZiAoIWFyZ2MpIHsKCQlnZXRfZGVmYXVsdF9oZWFkcygpOwoJCWtlZXBfY2FjaGVfb2JqZWN0cyA9IDE7Cgl9CgoJaWYgKGtlZXBfY2FjaGVfb2JqZWN0cykgewoJCXZlcmlmeV9pbmRleF9jaGVja3N1bSA9IDE7CgkJcmVhZF9jYWNoZSgpOwoJCWZvciAoaSA9IDA7IGkgPCBhY3RpdmVfbnI7IGkrKykgewoJCQl1bnNpZ25lZCBpbnQgbW9kZTsKCQkJc3RydWN0IGJsb2IgKmJsb2I7CgkJCXN0cnVjdCBvYmplY3QgKm9iajsKCgkJCW1vZGUgPSBhY3RpdmVfY2FjaGVbaV0tPmNlX21vZGU7CgkJCWlmIChTX0lTR0lUTElOSyhtb2RlKSkKCQkJCWNvbnRpbnVlOwoJCQlibG9iID0gbG9va3VwX2Jsb2IoYWN0aXZlX2NhY2hlW2ldLT5vaWQuaGFzaCk7CgkJCWlmICghYmxvYikKCQkJCWNvbnRpbnVlOwoJCQlvYmogPSAmYmxvYi0+b2JqZWN0OwoJCQlvYmotPnVzZWQgPSAxOwoJCQlpZiAobmFtZV9vYmplY3RzKQoJCQkJYWRkX2RlY29yYXRpb24oZnNja193YWxrX29wdGlvbnMub2JqZWN0X25hbWVzLAoJCQkJCW9iaiwKCQkJCQl4c3RyZm10KCI6JXMiLCBhY3RpdmVfY2FjaGVbaV0tPm5hbWUpKTsKCQkJbWFya19vYmplY3RfcmVhY2hhYmxlKG9iaik7CgkJfQoJCWlmIChhY3RpdmVfY2FjaGVfdHJlZSkKCQkJZnNja19jYWNoZV90cmVlKGFjdGl2ZV9jYWNoZV90cmVlKTsKCX0KCgljaGVja19jb25uZWN0aXZpdHkoKTsKCXJldHVybiBlcnJvcnNfZm91bmQ7Cn0K",
    "text": "#include \"builtin.h\"\n#include \"cache.h\"\n#include \"commit.h\"\n#include \"tree.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"refs.h\"\n#include \"pack.h\"\n#include \"cache-tree.h\"\n#include \"tree-walk.h\"\n#include \"fsck.h\"\n#include \"parse-options.h\"\n#include \"dir.h\"\n#include \"progress.h\"\n#include \"streaming.h\"\n#include \"decorate.h\"\n\n#define REACHABLE 0x0001\n#define SEEN      0x0002\n#define HAS_OBJ   0x0004\n\nstatic int show_root;\nstatic int show_tags;\nstatic int show_unreachable;\nstatic int include_reflogs = 1;\nstatic int check_full = 1;\nstatic int connectivity_only;\nstatic int check_strict;\nstatic int keep_cache_objects;\nstatic struct fsck_options fsck_walk_options = FSCK_OPTIONS_DEFAULT;\nstatic struct fsck_options fsck_obj_options = FSCK_OPTIONS_DEFAULT;\nstatic struct object_id head_oid;\nstatic const char *head_points_at;\nstatic int errors_found;\nstatic int write_lost_and_found;\nstatic int verbose;\nstatic int show_progress = -1;\nstatic int show_dangling = 1;\nstatic int name_objects;\n#define ERROR_OBJECT 01\n#define ERROR_REACHABLE 02\n#define ERROR_PACK 04\n#define ERROR_REFS 010\n\nstatic const char *describe_object(struct object *obj)\n{\n\tstatic struct strbuf buf = STRBUF_INIT;\n\tchar *name = name_objects ?\n\t\tlookup_decoration(fsck_walk_options.object_names, obj) : NULL;\n\n\tstrbuf_reset(&buf);\n\tstrbuf_addstr(&buf, oid_to_hex(&obj->oid));\n\tif (name)\n\t\tstrbuf_addf(&buf, \" (%s)\", name);\n\n\treturn buf.buf;\n}\n\nstatic const char *printable_type(struct object *obj)\n{\n\tconst char *ret;\n\n\tif (obj->type == OBJ_NONE) {\n\t\tenum object_type type = sha1_object_info(obj->oid.hash, NULL);\n\t\tif (type > 0)\n\t\t\tobject_as_type(obj, type, 0);\n\t}\n\n\tret = typename(obj->type);\n\tif (!ret)\n\t\tret = \"unknown\";\n\n\treturn ret;\n}\n\nstatic int fsck_config(const char *var, const char *value, void *cb)\n{\n\tif (strcmp(var, \"fsck.skiplist\") == 0) {\n\t\tconst char *path;\n\t\tstruct strbuf sb = STRBUF_INIT;\n\n\t\tif (git_config_pathname(&path, var, value))\n\t\t\treturn 1;\n\t\tstrbuf_addf(&sb, \"skiplist=%s\", path);\n\t\tfree((char *)path);\n\t\tfsck_set_msg_types(&fsck_obj_options, sb.buf);\n\t\tstrbuf_release(&sb);\n\t\treturn 0;\n\t}\n\n\tif (skip_prefix(var, \"fsck.\", &var)) {\n\t\tfsck_set_msg_type(&fsck_obj_options, var, value);\n\t\treturn 0;\n\t}\n\n\treturn git_default_config(var, value, cb);\n}\n\nstatic void objreport(struct object *obj, const char *msg_type,\n\t\t\tconst char *err)\n{\n\tfprintf(stderr, \"%s in %s %s: %s\\n\",\n\t\tmsg_type, printable_type(obj), describe_object(obj), err);\n}\n\nstatic int objerror(struct object *obj, const char *err)\n{\n\terrors_found |= ERROR_OBJECT;\n\tobjreport(obj, \"error\", err);\n\treturn -1;\n}\n\nstatic int fsck_error_func(struct fsck_options *o,\n\tstruct object *obj, int type, const char *message)\n{\n\tobjreport(obj, (type == FSCK_WARN) ? \"warning\" : \"error\", message);\n\treturn (type == FSCK_WARN) ? 0 : 1;\n}\n\nstatic struct object_array pending;\n\nstatic int mark_object(struct object *obj, int type, void *data, struct fsck_options *options)\n{\n\tstruct object *parent = data;\n\n\t/*\n\t * The only case data is NULL or type is OBJ_ANY is when\n\t * mark_object_reachable() calls us.  All the callers of\n\t * that function has non-NULL obj hence ...\n\t */\n\tif (!obj) {\n\t\t/* ... these references to parent->fld are safe here */\n\t\tprintf(\"broken link from %7s %s\\n\",\n\t\t\t   printable_type(parent), describe_object(parent));\n\t\tprintf(\"broken link from %7s %s\\n\",\n\t\t\t   (type == OBJ_ANY ? \"unknown\" : typename(type)), \"unknown\");\n\t\terrors_found |= ERROR_REACHABLE;\n\t\treturn 1;\n\t}\n\n\tif (type != OBJ_ANY && obj->type != type)\n\t\t/* ... and the reference to parent is safe here */\n\t\tobjerror(parent, \"wrong object type in link\");\n\n\tif (obj->flags & REACHABLE)\n\t\treturn 0;\n\tobj->flags |= REACHABLE;\n\tif (!(obj->flags & HAS_OBJ)) {\n\t\tif (parent && !has_object_file(&obj->oid)) {\n\t\t\tprintf(\"broken link from %7s %s\\n\",\n\t\t\t\t printable_type(parent), describe_object(parent));\n\t\t\tprintf(\"              to %7s %s\\n\",\n\t\t\t\t printable_type(obj), describe_object(obj));\n\t\t\terrors_found |= ERROR_REACHABLE;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tadd_object_array(obj, NULL, &pending);\n\treturn 0;\n}\n\nstatic void mark_object_reachable(struct object *obj)\n{\n\tmark_object(obj, OBJ_ANY, NULL, NULL);\n}\n\nstatic int traverse_one_object(struct object *obj)\n{\n\tint result;\n\tstruct tree *tree = NULL;\n\n\tif (obj->type == OBJ_TREE) {\n\t\ttree = (struct tree *)obj;\n\t\tif (parse_tree(tree) < 0)\n\t\t\treturn 1; /* error already displayed */\n\t}\n\tresult = fsck_walk(obj, obj, &fsck_walk_options);\n\tif (tree)\n\t\tfree_tree_buffer(tree);\n\treturn result;\n}\n\nstatic int traverse_reachable(void)\n{\n\tstruct progress *progress = NULL;\n\tunsigned int nr = 0;\n\tint result = 0;\n\tif (show_progress)\n\t\tprogress = start_progress_delay(_(\"Checking connectivity\"), 0, 0, 2);\n\twhile (pending.nr) {\n\t\tstruct object_array_entry *entry;\n\t\tstruct object *obj;\n\n\t\tentry = pending.objects + --pending.nr;\n\t\tobj = entry->item;\n\t\tresult |= traverse_one_object(obj);\n\t\tdisplay_progress(progress, ++nr);\n\t}\n\tstop_progress(&progress);\n\treturn !!result;\n}\n\nstatic int mark_used(struct object *obj, int type, void *data, struct fsck_options *options)\n{\n\tif (!obj)\n\t\treturn 1;\n\tobj->used = 1;\n\treturn 0;\n}\n\n/*\n * Check a single reachable object\n */\nstatic void check_reachable_object(struct object *obj)\n{\n\t/*\n\t * We obviously want the object to be parsed,\n\t * except if it was in a pack-file and we didn't\n\t * do a full fsck\n\t */\n\tif (!(obj->flags & HAS_OBJ)) {\n\t\tif (has_sha1_pack(obj->oid.hash))\n\t\t\treturn; /* it is in pack - forget about it */\n\t\tprintf(\"missing %s %s\\n\", printable_type(obj),\n\t\t\tdescribe_object(obj));\n\t\terrors_found |= ERROR_REACHABLE;\n\t\treturn;\n\t}\n}\n\n/*\n * Check a single unreachable object\n */\nstatic void check_unreachable_object(struct object *obj)\n{\n\t/*\n\t * Missing unreachable object? Ignore it. It's not like\n\t * we miss it (since it can't be reached), nor do we want\n\t * to complain about it being unreachable (since it does\n\t * not exist).\n\t */\n\tif (!(obj->flags & HAS_OBJ))\n\t\treturn;\n\n\t/*\n\t * Unreachable object that exists? Show it if asked to,\n\t * since this is something that is prunable.\n\t */\n\tif (show_unreachable) {\n\t\tprintf(\"unreachable %s %s\\n\", printable_type(obj),\n\t\t\tdescribe_object(obj));\n\t\treturn;\n\t}\n\n\t/*\n\t * \"!used\" means that nothing at all points to it, including\n\t * other unreachable objects. In other words, it's the \"tip\"\n\t * of some set of unreachable objects, usually a commit that\n\t * got dropped.\n\t *\n\t * Such starting points are more interesting than some random\n\t * set of unreachable objects, so we show them even if the user\n\t * hasn't asked for _all_ unreachable objects. If you have\n\t * deleted a branch by mistake, this is a prime candidate to\n\t * start looking at, for example.\n\t */\n\tif (!obj->used) {\n\t\tif (show_dangling)\n\t\t\tprintf(\"dangling %s %s\\n\", printable_type(obj),\n\t\t\t       describe_object(obj));\n\t\tif (write_lost_and_found) {\n\t\t\tchar *filename = git_pathdup(\"lost-found/%s/%s\",\n\t\t\t\tobj->type == OBJ_COMMIT ? \"commit\" : \"other\",\n\t\t\t\tdescribe_object(obj));\n\t\t\tFILE *f;\n\n\t\t\tif (safe_create_leading_directories_const(filename)) {\n\t\t\t\terror(\"Could not create lost-found\");\n\t\t\t\tfree(filename);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tf = xfopen(filename, \"w\");\n\t\t\tif (obj->type == OBJ_BLOB) {\n\t\t\t\tif (stream_blob_to_fd(fileno(f), &obj->oid, NULL, 1))\n\t\t\t\t\tdie_errno(\"Could not write '%s'\", filename);\n\t\t\t} else\n\t\t\t\tfprintf(f, \"%s\\n\", describe_object(obj));\n\t\t\tif (fclose(f))\n\t\t\t\tdie_errno(\"Could not finish '%s'\",\n\t\t\t\t\t  filename);\n\t\t\tfree(filename);\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * Otherwise? It's there, it's unreachable, and some other unreachable\n\t * object points to it. Ignore it - it's not interesting, and we showed\n\t * all the interesting cases above.\n\t */\n}\n\nstatic void check_object(struct object *obj)\n{\n\tif (verbose)\n\t\tfprintf(stderr, \"Checking %s\\n\", describe_object(obj));\n\n\tif (obj->flags & REACHABLE)\n\t\tcheck_reachable_object(obj);\n\telse\n\t\tcheck_unreachable_object(obj);\n}\n\nstatic void check_connectivity(void)\n{\n\tint i, max;\n\n\t/* Traverse the pending reachable objects */\n\ttraverse_reachable();\n\n\t/* Look up all the requirements, warn about missing objects.. */\n\tmax = get_max_object_index();\n\tif (verbose)\n\t\tfprintf(stderr, \"Checking connectivity (%d objects)\\n\", max);\n\n\tfor (i = 0; i < max; i++) {\n\t\tstruct object *obj = get_indexed_object(i);\n\n\t\tif (obj)\n\t\t\tcheck_object(obj);\n\t}\n}\n\nstatic int fsck_obj(struct object *obj)\n{\n\tif (obj->flags & SEEN)\n\t\treturn 0;\n\tobj->flags |= SEEN;\n\n\tif (verbose)\n\t\tfprintf(stderr, \"Checking %s %s\\n\",\n\t\t\tprintable_type(obj), describe_object(obj));\n\n\tif (fsck_walk(obj, NULL, &fsck_obj_options))\n\t\tobjerror(obj, \"broken links\");\n\tif (fsck_object(obj, NULL, 0, &fsck_obj_options))\n\t\treturn -1;\n\n\tif (obj->type == OBJ_TREE) {\n\t\tstruct tree *item = (struct tree *) obj;\n\n\t\tfree_tree_buffer(item);\n\t}\n\n\tif (obj->type == OBJ_COMMIT) {\n\t\tstruct commit *commit = (struct commit *) obj;\n\n\t\tfree_commit_buffer(commit);\n\n\t\tif (!commit->parents && show_root)\n\t\t\tprintf(\"root %s\\n\", describe_object(&commit->object));\n\t}\n\n\tif (obj->type == OBJ_TAG) {\n\t\tstruct tag *tag = (struct tag *) obj;\n\n\t\tif (show_tags && tag->tagged) {\n\t\t\tprintf(\"tagged %s %s\", printable_type(tag->tagged),\n\t\t\t\tdescribe_object(tag->tagged));\n\t\t\tprintf(\" (%s) in %s\\n\", tag->tag,\n\t\t\t\tdescribe_object(&tag->object));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int fsck_obj_buffer(const unsigned char *sha1, enum object_type type,\n\t\t\t   unsigned long size, void *buffer, int *eaten)\n{\n\t/*\n\t * Note, buffer may be NULL if type is OBJ_BLOB. See\n\t * verify_packfile(), data_valid variable for details.\n\t */\n\tstruct object *obj;\n\tobj = parse_object_buffer(sha1, type, size, buffer, eaten);\n\tif (!obj) {\n\t\terrors_found |= ERROR_OBJECT;\n\t\treturn error(\"%s: object corrupt or missing\", sha1_to_hex(sha1));\n\t}\n\tobj->flags = HAS_OBJ;\n\treturn fsck_obj(obj);\n}\n\nstatic int default_refs;\n\nstatic void fsck_handle_reflog_oid(const char *refname, struct object_id *oid,\n\tunsigned long timestamp)\n{\n\tstruct object *obj;\n\n\tif (!is_null_oid(oid)) {\n\t\tobj = lookup_object(oid->hash);\n\t\tif (obj && (obj->flags & HAS_OBJ)) {\n\t\t\tif (timestamp && name_objects)\n\t\t\t\tadd_decoration(fsck_walk_options.object_names,\n\t\t\t\t\tobj,\n\t\t\t\t\txstrfmt(\"%s@{%ld}\", refname, timestamp));\n\t\t\tobj->used = 1;\n\t\t\tmark_object_reachable(obj);\n\t\t} else {\n\t\t\terror(\"%s: invalid reflog entry %s\", refname, oid_to_hex(oid));\n\t\t\terrors_found |= ERROR_REACHABLE;\n\t\t}\n\t}\n}\n\nstatic int fsck_handle_reflog_ent(struct object_id *ooid, struct object_id *noid,\n\t\tconst char *email, unsigned long timestamp, int tz,\n\t\tconst char *message, void *cb_data)\n{\n\tconst char *refname = cb_data;\n\n\tif (verbose)\n\t\tfprintf(stderr, \"Checking reflog %s->%s\\n\",\n\t\t\toid_to_hex(ooid), oid_to_hex(noid));\n\n\tfsck_handle_reflog_oid(refname, ooid, 0);\n\tfsck_handle_reflog_oid(refname, noid, timestamp);\n\treturn 0;\n}\n\nstatic int fsck_handle_reflog(const char *logname, const struct object_id *oid,\n\t\t\t      int flag, void *cb_data)\n{\n\tfor_each_reflog_ent(logname, fsck_handle_reflog_ent, (void *)logname);\n\treturn 0;\n}\n\nstatic int fsck_handle_ref(const char *refname, const struct object_id *oid,\n\t\t\t   int flag, void *cb_data)\n{\n\tstruct object *obj;\n\n\tobj = parse_object(oid->hash);\n\tif (!obj) {\n\t\terror(\"%s: invalid sha1 pointer %s\", refname, oid_to_hex(oid));\n\t\terrors_found |= ERROR_REACHABLE;\n\t\t/* We'll continue with the rest despite the error.. */\n\t\treturn 0;\n\t}\n\tif (obj->type != OBJ_COMMIT && is_branch(refname)) {\n\t\terror(\"%s: not a commit\", refname);\n\t\terrors_found |= ERROR_REFS;\n\t}\n\tdefault_refs++;\n\tobj->used = 1;\n\tif (name_objects)\n\t\tadd_decoration(fsck_walk_options.object_names,\n\t\t\tobj, xstrdup(refname));\n\tmark_object_reachable(obj);\n\n\treturn 0;\n}\n\nstatic void get_default_heads(void)\n{\n\tif (head_points_at && !is_null_oid(&head_oid))\n\t\tfsck_handle_ref(\"HEAD\", &head_oid, 0, NULL);\n\tfor_each_rawref(fsck_handle_ref, NULL);\n\tif (include_reflogs)\n\t\tfor_each_reflog(fsck_handle_reflog, NULL);\n\n\t/*\n\t * Not having any default heads isn't really fatal, but\n\t * it does mean that \"--unreachable\" no longer makes any\n\t * sense (since in this case everything will obviously\n\t * be unreachable by definition.\n\t *\n\t * Showing dangling objects is valid, though (as those\n\t * dangling objects are likely lost heads).\n\t *\n\t * So we just print a warning about it, and clear the\n\t * \"show_unreachable\" flag.\n\t */\n\tif (!default_refs) {\n\t\tfprintf(stderr, \"notice: No default references\\n\");\n\t\tshow_unreachable = 0;\n\t}\n}\n\nstatic struct object *parse_loose_object(const struct object_id *oid,\n\t\t\t\t\t const char *path)\n{\n\tstruct object *obj;\n\tvoid *contents;\n\tenum object_type type;\n\tunsigned long size;\n\tint eaten;\n\n\tif (read_loose_object(path, oid->hash, &type, &size, &contents) < 0)\n\t\treturn NULL;\n\n\tif (!contents && type != OBJ_BLOB)\n\t\tdie(\"BUG: read_loose_object streamed a non-blob\");\n\n\tobj = parse_object_buffer(oid->hash, type, size, contents, &eaten);\n\n\tif (!eaten)\n\t\tfree(contents);\n\treturn obj;\n}\n\nstatic int fsck_loose(const struct object_id *oid, const char *path, void *data)\n{\n\tstruct object *obj = parse_loose_object(oid, path);\n\n\tif (!obj) {\n\t\terrors_found |= ERROR_OBJECT;\n\t\terror(\"%s: object corrupt or missing: %s\",\n\t\t      oid_to_hex(oid), path);\n\t\treturn 0; /* keep checking other objects */\n\t}\n\n\tobj->flags = HAS_OBJ;\n\tif (fsck_obj(obj))\n\t\terrors_found |= ERROR_OBJECT;\n\treturn 0;\n}\n\nstatic int fsck_cruft(const char *basename, const char *path, void *data)\n{\n\tif (!starts_with(basename, \"tmp_obj_\"))\n\t\tfprintf(stderr, \"bad sha1 file: %s\\n\", path);\n\treturn 0;\n}\n\nstatic int fsck_subdir(int nr, const char *path, void *progress)\n{\n\tdisplay_progress(progress, nr + 1);\n\treturn 0;\n}\n\nstatic void fsck_object_dir(const char *path)\n{\n\tstruct progress *progress = NULL;\n\n\tif (verbose)\n\t\tfprintf(stderr, \"Checking object directory\\n\");\n\n\tif (show_progress)\n\t\tprogress = start_progress(_(\"Checking object directories\"), 256);\n\n\tfor_each_loose_file_in_objdir(path, fsck_loose, fsck_cruft, fsck_subdir,\n\t\t\t\t      progress);\n\tdisplay_progress(progress, 256);\n\tstop_progress(&progress);\n}\n\nstatic int fsck_head_link(void)\n{\n\tint null_is_error = 0;\n\n\tif (verbose)\n\t\tfprintf(stderr, \"Checking HEAD link\\n\");\n\n\thead_points_at = resolve_ref_unsafe(\"HEAD\", 0, head_oid.hash, NULL);\n\tif (!head_points_at) {\n\t\terrors_found |= ERROR_REFS;\n\t\treturn error(\"Invalid HEAD\");\n\t}\n\tif (!strcmp(head_points_at, \"HEAD\"))\n\t\t/* detached HEAD */\n\t\tnull_is_error = 1;\n\telse if (!starts_with(head_points_at, \"refs/heads/\")) {\n\t\terrors_found |= ERROR_REFS;\n\t\treturn error(\"HEAD points to something strange (%s)\",\n\t\t\t     head_points_at);\n\t}\n\tif (is_null_oid(&head_oid)) {\n\t\tif (null_is_error) {\n\t\t\terrors_found |= ERROR_REFS;\n\t\t\treturn error(\"HEAD: detached HEAD points at nothing\");\n\t\t}\n\t\tfprintf(stderr, \"notice: HEAD points to an unborn branch (%s)\\n\",\n\t\t\thead_points_at + 11);\n\t}\n\treturn 0;\n}\n\nstatic int fsck_cache_tree(struct cache_tree *it)\n{\n\tint i;\n\tint err = 0;\n\n\tif (verbose)\n\t\tfprintf(stderr, \"Checking cache tree\\n\");\n\n\tif (0 <= it->entry_count) {\n\t\tstruct object *obj = parse_object(it->sha1);\n\t\tif (!obj) {\n\t\t\terror(\"%s: invalid sha1 pointer in cache-tree\",\n\t\t\t      sha1_to_hex(it->sha1));\n\t\t\terrors_found |= ERROR_REFS;\n\t\t\treturn 1;\n\t\t}\n\t\tobj->used = 1;\n\t\tif (name_objects)\n\t\t\tadd_decoration(fsck_walk_options.object_names,\n\t\t\t\tobj, xstrdup(\":\"));\n\t\tmark_object_reachable(obj);\n\t\tif (obj->type != OBJ_TREE)\n\t\t\terr |= objerror(obj, \"non-tree in cache-tree\");\n\t}\n\tfor (i = 0; i < it->subtree_nr; i++)\n\t\terr |= fsck_cache_tree(it->down[i]->cache_tree);\n\treturn err;\n}\n\nstatic void mark_object_for_connectivity(const struct object_id *oid)\n{\n\tstruct object *obj = lookup_unknown_object(oid->hash);\n\tobj->flags |= HAS_OBJ;\n}\n\nstatic int mark_loose_for_connectivity(const struct object_id *oid,\n\t\t\t\t       const char *path,\n\t\t\t\t       void *data)\n{\n\tmark_object_for_connectivity(oid);\n\treturn 0;\n}\n\nstatic int mark_packed_for_connectivity(const struct object_id *oid,\n\t\t\t\t\tstruct packed_git *pack,\n\t\t\t\t\tuint32_t pos,\n\t\t\t\t\tvoid *data)\n{\n\tmark_object_for_connectivity(oid);\n\treturn 0;\n}\n\nstatic char const * const fsck_usage[] = {\n\tN_(\"git fsck [<options>] [<object>...]\"),\n\tNULL\n};\n\nstatic struct option fsck_opts[] = {\n\tOPT__VERBOSE(&verbose, N_(\"be verbose\")),\n\tOPT_BOOL(0, \"unreachable\", &show_unreachable, N_(\"show unreachable objects\")),\n\tOPT_BOOL(0, \"dangling\", &show_dangling, N_(\"show dangling objects\")),\n\tOPT_BOOL(0, \"tags\", &show_tags, N_(\"report tags\")),\n\tOPT_BOOL(0, \"root\", &show_root, N_(\"report root nodes\")),\n\tOPT_BOOL(0, \"cache\", &keep_cache_objects, N_(\"make index objects head nodes\")),\n\tOPT_BOOL(0, \"reflogs\", &include_reflogs, N_(\"make reflogs head nodes (default)\")),\n\tOPT_BOOL(0, \"full\", &check_full, N_(\"also consider packs and alternate objects\")),\n\tOPT_BOOL(0, \"connectivity-only\", &connectivity_only, N_(\"check only connectivity\")),\n\tOPT_BOOL(0, \"strict\", &check_strict, N_(\"enable more strict checking\")),\n\tOPT_BOOL(0, \"lost-found\", &write_lost_and_found,\n\t\t\t\tN_(\"write dangling objects in .git/lost-found\")),\n\tOPT_BOOL(0, \"progress\", &show_progress, N_(\"show progress\")),\n\tOPT_BOOL(0, \"name-objects\", &name_objects, N_(\"show verbose names for reachable objects\")),\n\tOPT_END(),\n};\n\nint cmd_fsck(int argc, const char **argv, const char *prefix)\n{\n\tint i, heads;\n\tstruct alternate_object_database *alt;\n\n\terrors_found = 0;\n\tcheck_replace_refs = 0;\n\n\targc = parse_options(argc, argv, prefix, fsck_opts, fsck_usage, 0);\n\n\tfsck_walk_options.walk = mark_object;\n\tfsck_obj_options.walk = mark_used;\n\tfsck_obj_options.error_func = fsck_error_func;\n\tif (check_strict)\n\t\tfsck_obj_options.strict = 1;\n\n\tif (show_progress == -1)\n\t\tshow_progress = isatty(2);\n\tif (verbose)\n\t\tshow_progress = 0;\n\n\tif (write_lost_and_found) {\n\t\tcheck_full = 1;\n\t\tinclude_reflogs = 0;\n\t}\n\n\tif (name_objects)\n\t\tfsck_walk_options.object_names =\n\t\t\txcalloc(1, sizeof(struct decoration));\n\n\tgit_config(fsck_config, NULL);\n\n\tfsck_head_link();\n\tif (connectivity_only) {\n\t\tfor_each_loose_object(mark_loose_for_connectivity, NULL, 0);\n\t\tfor_each_packed_object(mark_packed_for_connectivity, NULL, 0);\n\t} else {\n\t\tfsck_object_dir(get_object_directory());\n\n\t\tprepare_alt_odb();\n\t\tfor (alt = alt_odb_list; alt; alt = alt->next)\n\t\t\tfsck_object_dir(alt->path);\n\n\t\tif (check_full) {\n\t\t\tstruct packed_git *p;\n\t\t\tuint32_t total = 0, count = 0;\n\t\t\tstruct progress *progress = NULL;\n\n\t\t\tprepare_packed_git();\n\n\t\t\tif (show_progress) {\n\t\t\t\tfor (p = packed_git; p; p = p->next) {\n\t\t\t\t\tif (open_pack_index(p))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ttotal += p->num_objects;\n\t\t\t\t}\n\n\t\t\t\tprogress = start_progress(_(\"Checking objects\"), total);\n\t\t\t}\n\t\t\tfor (p = packed_git; p; p = p->next) {\n\t\t\t\t/* verify gives error messages itself */\n\t\t\t\tif (verify_pack(p, fsck_obj_buffer,\n\t\t\t\t\t\tprogress, count))\n\t\t\t\t\terrors_found |= ERROR_PACK;\n\t\t\t\tcount += p->num_objects;\n\t\t\t}\n\t\t\tstop_progress(&progress);\n\t\t}\n\t}\n\n\theads = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\t\tunsigned char sha1[20];\n\t\tif (!get_sha1(arg, sha1)) {\n\t\t\tstruct object *obj = lookup_object(sha1);\n\n\t\t\tif (!obj || !(obj->flags & HAS_OBJ)) {\n\t\t\t\terror(\"%s: object missing\", sha1_to_hex(sha1));\n\t\t\t\terrors_found |= ERROR_OBJECT;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tobj->used = 1;\n\t\t\tif (name_objects)\n\t\t\t\tadd_decoration(fsck_walk_options.object_names,\n\t\t\t\t\tobj, xstrdup(arg));\n\t\t\tmark_object_reachable(obj);\n\t\t\theads++;\n\t\t\tcontinue;\n\t\t}\n\t\terror(\"invalid parameter: expected sha1, got '%s'\", arg);\n\t\terrors_found |= ERROR_OBJECT;\n\t}\n\n\t/*\n\t * If we've not been given any explicit head information, do the\n\t * default ones from .git/refs. We also consider the index file\n\t * in this case (ie this implies --cache).\n\t */\n\tif (!argc) {\n\t\tget_default_heads();\n\t\tkeep_cache_objects = 1;\n\t}\n\n\tif (keep_cache_objects) {\n\t\tverify_index_checksum = 1;\n\t\tread_cache();\n\t\tfor (i = 0; i < active_nr; i++) {\n\t\t\tunsigned int mode;\n\t\t\tstruct blob *blob;\n\t\t\tstruct object *obj;\n\n\t\t\tmode = active_cache[i]->ce_mode;\n\t\t\tif (S_ISGITLINK(mode))\n\t\t\t\tcontinue;\n\t\t\tblob = lookup_blob(active_cache[i]->oid.hash);\n\t\t\tif (!blob)\n\t\t\t\tcontinue;\n\t\t\tobj = &blob->object;\n\t\t\tobj->used = 1;\n\t\t\tif (name_objects)\n\t\t\t\tadd_decoration(fsck_walk_options.object_names,\n\t\t\t\t\tobj,\n\t\t\t\t\txstrfmt(\":%s\", active_cache[i]->name));\n\t\t\tmark_object_reachable(obj);\n\t\t}\n\t\tif (active_cache_tree)\n\t\t\tfsck_cache_tree(active_cache_tree);\n\t}\n\n\tcheck_connectivity();\n\treturn errors_found;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00beaaa4e6edc7d644f43a6503aa895eb6d934c4",
  "sha1_ok": true,
  "size": 20079
}
