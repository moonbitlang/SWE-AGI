{
  "content": {
    "base64": "LyoKICogcmV2LXBhcnNlLmMKICoKICogQ29weXJpZ2h0IChDKSBMaW51cyBUb3J2YWxkcywgMjAwNQogKi8KI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgInF1b3RlLmgiCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCgojZGVmaW5lIERPX1JFVlMJCTEKI2RlZmluZSBET19OT1JFVgkyCiNkZWZpbmUgRE9fRkxBR1MJNAojZGVmaW5lIERPX05PTkZMQUdTCTgKc3RhdGljIGludCBmaWx0ZXIgPSB+MDsKCnN0YXRpYyBjb25zdCBjaGFyICpkZWY7CgojZGVmaW5lIE5PUk1BTCAwCiNkZWZpbmUgUkVWRVJTRUQgMQpzdGF0aWMgaW50IHNob3dfdHlwZSA9IE5PUk1BTDsKCiNkZWZpbmUgU0hPV19TWU1CT0xJQ19BU0lTIDEKI2RlZmluZSBTSE9XX1NZTUJPTElDX0ZVTEwgMgpzdGF0aWMgaW50IHN5bWJvbGljOwpzdGF0aWMgaW50IGFiYnJldjsKc3RhdGljIGludCBvdXRwdXRfc3E7CgpzdGF0aWMgaW50IHJldnNfY291bnQ7CgovKgogKiBTb21lIGFyZ3VtZW50cyBhcmUgcmVsZXZhbnQgInJldmlzaW9uIiBhcmd1bWVudHMsCiAqIG90aGVycyBhcmUgYWJvdXQgb3V0cHV0IGZvcm1hdCBvciBvdGhlciBkZXRhaWxzLgogKiBUaGlzIHNvcnRzIGl0IGFsbCBvdXQuCiAqLwpzdGF0aWMgaW50IGlzX3Jldl9hcmd1bWVudChjb25zdCBjaGFyICphcmcpCnsKCXN0YXRpYyBjb25zdCBjaGFyICpyZXZfYXJnc1tdID0gewoJCSItLWFsbCIsCgkJIi0tYmlzZWN0IiwKCQkiLS1kZW5zZSIsCgkJIi0tYnJhbmNoZXMiLAoJCSItLWhlYWRlciIsCgkJIi0tbWF4LWFnZT0iLAoJCSItLW1heC1jb3VudD0iLAoJCSItLW1pbi1hZ2U9IiwKCQkiLS1uby1tZXJnZXMiLAoJCSItLW9iamVjdHMiLAoJCSItLW9iamVjdHMtZWRnZSIsCgkJIi0tcGFyZW50cyIsCgkJIi0tcHJldHR5IiwKCQkiLS1yZW1vdGVzIiwKCQkiLS1zcGFyc2UiLAoJCSItLXRhZ3MiLAoJCSItLXRvcG8tb3JkZXIiLAoJCSItLWRhdGUtb3JkZXIiLAoJCSItLXVucGFja2VkIiwKCQlOVUxMCgl9OwoJY29uc3QgY2hhciAqKnAgPSByZXZfYXJnczsKCgkvKiBhY2NlcHQgLTxkaWdpdD4sIGxpa2UgdHJhZGl0aW9uYWwgImhlYWQiICovCglpZiAoKCphcmcgPT0gJy0nKSAmJiBpc2RpZ2l0KGFyZ1sxXSkpCgkJcmV0dXJuIDE7CgoJZm9yICg7OykgewoJCWNvbnN0IGNoYXIgKnN0ciA9ICpwKys7CgkJaW50IGxlbjsKCQlpZiAoIXN0cikKCQkJcmV0dXJuIDA7CgkJbGVuID0gc3RybGVuKHN0cik7CgkJaWYgKCFzdHJjbXAoYXJnLCBzdHIpIHx8CgkJICAgIChzdHJbbGVuLTFdID09ICc9JyAmJiAhc3RybmNtcChhcmcsIHN0ciwgbGVuKSkpCgkJCXJldHVybiAxOwoJfQp9CgovKiBPdXRwdXQgYXJndW1lbnQgYXMgYSBzdHJpbmcsIGVpdGhlciBTUSBvciBub3JtYWwgKi8Kc3RhdGljIHZvaWQgc2hvdyhjb25zdCBjaGFyICphcmcpCnsKCWlmIChvdXRwdXRfc3EpIHsKCQlpbnQgc3EgPSAnXCcnLCBjaDsKCgkJcHV0Y2hhcihzcSk7CgkJd2hpbGUgKChjaCA9ICphcmcrKykpIHsKCQkJaWYgKGNoID09IHNxKQoJCQkJZnB1dHMoIidcXCciLCBzdGRvdXQpOwoJCQlwdXRjaGFyKGNoKTsKCQl9CgkJcHV0Y2hhcihzcSk7CgkJcHV0Y2hhcignICcpOwoJfQoJZWxzZQoJCXB1dHMoYXJnKTsKfQoKLyogTGlrZSBzaG93KCksIGJ1dCB3aXRoIGEgbmVnYXRpb24gcHJlZml4IGFjY29yZGluZyB0byB0eXBlICovCnN0YXRpYyB2b2lkIHNob3dfd2l0aF90eXBlKGludCB0eXBlLCBjb25zdCBjaGFyICphcmcpCnsKCWlmICh0eXBlICE9IHNob3dfdHlwZSkKCQlwdXRjaGFyKCdeJyk7CglzaG93KGFyZyk7Cn0KCi8qIE91dHB1dCBhIHJldmlzaW9uLCBvbmx5IGlmIGZpbHRlciBhbGxvd3MgaXQgKi8Kc3RhdGljIHZvaWQgc2hvd19yZXYoaW50IHR5cGUsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIGNvbnN0IGNoYXIgKm5hbWUpCnsKCWlmICghKGZpbHRlciAmIERPX1JFVlMpKQoJCXJldHVybjsKCWRlZiA9IE5VTEw7CglyZXZzX2NvdW50Kys7CgoJaWYgKHN5bWJvbGljICYmIG5hbWUpIHsKCQlpZiAoc3ltYm9saWMgPT0gU0hPV19TWU1CT0xJQ19GVUxMKSB7CgkJCXVuc2lnbmVkIGNoYXIgZGlzY2FyZFsyMF07CgkJCWNoYXIgKmZ1bGw7CgoJCQlzd2l0Y2ggKGR3aW1fcmVmKG5hbWUsIHN0cmxlbihuYW1lKSwgZGlzY2FyZCwgJmZ1bGwpKSB7CgkJCWNhc2UgMDoKCQkJCS8qCgkJCQkgKiBOb3QgZm91bmQgLS0gbm90IGEgcmVmLiAgV2UgY291bGQKCQkJCSAqIGVtaXQgIm5hbWUiIGhlcmUsIGJ1dCBzeW1ib2xpYy1mdWxsCgkJCQkgKiB1c2VycyBhcmUgaW50ZXJlc3RlZCBpbiBmaW5kaW5nIHRoZQoJCQkJICogcmVmcyBzcGVsbGVkIGluIGZ1bGwsIGFuZCB0aGV5IHdvdWxkCgkJCQkgKiBuZWVkIHRvIGZpbHRlciBub24tcmVmcyBpZiB3ZSBkaWQgc28uCgkJCQkgKi8KCQkJCWJyZWFrOwoJCQljYXNlIDE6IC8qIGhhcHB5ICovCgkJCQlzaG93X3dpdGhfdHlwZSh0eXBlLCBmdWxsKTsKCQkJCWJyZWFrOwoJCQlkZWZhdWx0OiAvKiBhbWJpZ3VvdXMgKi8KCQkJCWVycm9yKCJyZWZuYW1lICclcycgaXMgYW1iaWd1b3VzIiwgbmFtZSk7CgkJCQlicmVhazsKCQkJfQoJCX0gZWxzZSB7CgkJCXNob3dfd2l0aF90eXBlKHR5cGUsIG5hbWUpOwoJCX0KCX0KCWVsc2UgaWYgKGFiYnJldikKCQlzaG93X3dpdGhfdHlwZSh0eXBlLCBmaW5kX3VuaXF1ZV9hYmJyZXYoc2hhMSwgYWJicmV2KSk7CgllbHNlCgkJc2hvd193aXRoX3R5cGUodHlwZSwgc2hhMV90b19oZXgoc2hhMSkpOwp9CgovKiBPdXRwdXQgYSBmbGFnLCBvbmx5IGlmIGZpbHRlciBhbGxvd3MgaXQuICovCnN0YXRpYyBpbnQgc2hvd19mbGFnKGNvbnN0IGNoYXIgKmFyZykKewoJaWYgKCEoZmlsdGVyICYgRE9fRkxBR1MpKQoJCXJldHVybiAwOwoJaWYgKGZpbHRlciAmIChpc19yZXZfYXJndW1lbnQoYXJnKSA/IERPX1JFVlMgOiBET19OT1JFVikpIHsKCQlzaG93KGFyZyk7CgkJcmV0dXJuIDE7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgc2hvd19kZWZhdWx0KHZvaWQpCnsKCWNvbnN0IGNoYXIgKnMgPSBkZWY7CgoJaWYgKHMpIHsKCQl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoKCQlkZWYgPSBOVUxMOwoJCWlmICghZ2V0X3NoYTEocywgc2hhMSkpIHsKCQkJc2hvd19yZXYoTk9STUFMLCBzaGExLCBzKTsKCQkJcmV0dXJuOwoJCX0KCX0KfQoKc3RhdGljIGludCBzaG93X3JlZmVyZW5jZShjb25zdCBjaGFyICpyZWZuYW1lLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBpbnQgZmxhZywgdm9pZCAqY2JfZGF0YSkKewoJc2hvd19yZXYoTk9STUFMLCBzaGExLCByZWZuYW1lKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBzaG93X2RhdGVzdHJpbmcoY29uc3QgY2hhciAqZmxhZywgY29uc3QgY2hhciAqZGF0ZXN0cikKewoJc3RhdGljIGNoYXIgYnVmZmVyWzEwMF07CgoJLyogZGF0ZSBoYW5kbGluZyByZXF1aXJlcyBib3RoIGZsYWdzIGFuZCByZXZzICovCglpZiAoKGZpbHRlciAmIChET19GTEFHUyB8IERPX1JFVlMpKSAhPSAoRE9fRkxBR1MgfCBET19SRVZTKSkKCQlyZXR1cm47CglzbnByaW50ZihidWZmZXIsIHNpemVvZihidWZmZXIpLCAiJXMlbHUiLCBmbGFnLCBhcHByb3hpZGF0ZShkYXRlc3RyKSk7CglzaG93KGJ1ZmZlcik7Cn0KCnN0YXRpYyBpbnQgc2hvd19maWxlKGNvbnN0IGNoYXIgKmFyZykKewoJc2hvd19kZWZhdWx0KCk7CglpZiAoKGZpbHRlciAmIChET19OT05GTEFHU3xET19OT1JFVikpID09IChET19OT05GTEFHU3xET19OT1JFVikpIHsKCQlzaG93KGFyZyk7CgkJcmV0dXJuIDE7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCB0cnlfZGlmZmVyZW5jZShjb25zdCBjaGFyICphcmcpCnsKCWNoYXIgKmRvdGRvdDsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07Cgl1bnNpZ25lZCBjaGFyIGVuZFsyMF07Cgljb25zdCBjaGFyICpuZXh0OwoJY29uc3QgY2hhciAqdGhpczsKCWludCBzeW1tZXRyaWM7CgoJaWYgKCEoZG90ZG90ID0gc3Ryc3RyKGFyZywgIi4uIikpKQoJCXJldHVybiAwOwoJbmV4dCA9IGRvdGRvdCArIDI7Cgl0aGlzID0gYXJnOwoJc3ltbWV0cmljID0gKCpuZXh0ID09ICcuJyk7CgoJKmRvdGRvdCA9IDA7CgluZXh0ICs9IHN5bW1ldHJpYzsKCglpZiAoISpuZXh0KQoJCW5leHQgPSAiSEVBRCI7CglpZiAoZG90ZG90ID09IGFyZykKCQl0aGlzID0gIkhFQUQiOwoJaWYgKCFnZXRfc2hhMSh0aGlzLCBzaGExKSAmJiAhZ2V0X3NoYTEobmV4dCwgZW5kKSkgewoJCXNob3dfcmV2KE5PUk1BTCwgZW5kLCBuZXh0KTsKCQlzaG93X3JldihzeW1tZXRyaWMgPyBOT1JNQUwgOiBSRVZFUlNFRCwgc2hhMSwgdGhpcyk7CgkJaWYgKHN5bW1ldHJpYykgewoJCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKmV4Y2x1ZGU7CgkJCXN0cnVjdCBjb21taXQgKmEsICpiOwoJCQlhID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2Uoc2hhMSk7CgkJCWIgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZShlbmQpOwoJCQlleGNsdWRlID0gZ2V0X21lcmdlX2Jhc2VzKGEsIGIsIDEpOwoJCQl3aGlsZSAoZXhjbHVkZSkgewoJCQkJc3RydWN0IGNvbW1pdF9saXN0ICpuID0gZXhjbHVkZS0+bmV4dDsKCQkJCXNob3dfcmV2KFJFVkVSU0VELAoJCQkJCSBleGNsdWRlLT5pdGVtLT5vYmplY3Quc2hhMSxOVUxMKTsKCQkJCWZyZWUoZXhjbHVkZSk7CgkJCQlleGNsdWRlID0gbjsKCQkJfQoJCX0KCQlyZXR1cm4gMTsKCX0KCSpkb3Rkb3QgPSAnLic7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBwYXJzZW9wdF9kdW1wKGNvbnN0IHN0cnVjdCBvcHRpb24gKm8sIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglzdHJ1Y3Qgc3RyYnVmICpwYXJzZWQgPSBvLT52YWx1ZTsKCWlmICh1bnNldCkKCQlzdHJidWZfYWRkZihwYXJzZWQsICIgLS1uby0lcyIsIG8tPmxvbmdfbmFtZSk7CgllbHNlIGlmIChvLT5zaG9ydF9uYW1lKQoJCXN0cmJ1Zl9hZGRmKHBhcnNlZCwgIiAtJWMiLCBvLT5zaG9ydF9uYW1lKTsKCWVsc2UKCQlzdHJidWZfYWRkZihwYXJzZWQsICIgLS0lcyIsIG8tPmxvbmdfbmFtZSk7CglpZiAoYXJnKSB7CgkJc3RyYnVmX2FkZGNoKHBhcnNlZCwgJyAnKTsKCQlzcV9xdW90ZV9idWYocGFyc2VkLCBhcmcpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpza2lwc3BhY2VzKGNvbnN0IGNoYXIgKnMpCnsKCXdoaWxlIChpc3NwYWNlKCpzKSkKCQlzKys7CglyZXR1cm4gczsKfQoKc3RhdGljIGludCBjbWRfcGFyc2VvcHQoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0YXRpYyBpbnQga2VlcF9kYXNoZGFzaCA9IDA7CglzdGF0aWMgY2hhciBjb25zdCAqIGNvbnN0IHBhcnNlb3B0X3VzYWdlW10gPSB7CgkJImdpdC1yZXYtcGFyc2UgLS1wYXJzZW9wdCBbb3B0aW9uc10gLS0gWzxhcmdzPi4uLl0iLAoJCU5VTEwKCX07CglzdGF0aWMgc3RydWN0IG9wdGlvbiBwYXJzZW9wdF9vcHRzW10gPSB7CgkJT1BUX0JPT0xFQU4oMCwgImtlZXAtZGFzaGRhc2giLCAma2VlcF9kYXNoZGFzaCwKCQkJCQkia2VlcCB0aGUgYC0tYCBwYXNzZWQgYXMgYW4gYXJnIiksCgkJT1BUX0VORCgpLAoJfTsKCglzdHJ1Y3Qgc3RyYnVmIHNiLCBwYXJzZWQ7Cgljb25zdCBjaGFyICoqdXNhZ2UgPSBOVUxMOwoJc3RydWN0IG9wdGlvbiAqb3B0cyA9IE5VTEw7CglpbnQgb25iID0gMCwgb3N6ID0gMCwgdW5iID0gMCwgdXN6ID0gMDsKCglzdHJidWZfaW5pdCgmcGFyc2VkLCAwKTsKCXN0cmJ1Zl9hZGRzdHIoJnBhcnNlZCwgInNldCAtLSIpOwoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcGFyc2VvcHRfb3B0cywgcGFyc2VvcHRfdXNhZ2UsCgkgICAgICAgICAgICAgICAgICAgICBQQVJTRV9PUFRfS0VFUF9EQVNIREFTSCk7CglpZiAoYXJnYyA8IDEgfHwgc3RyY21wKGFyZ3ZbMF0sICItLSIpKQoJCXVzYWdlX3dpdGhfb3B0aW9ucyhwYXJzZW9wdF91c2FnZSwgcGFyc2VvcHRfb3B0cyk7CgoJc3RyYnVmX2luaXQoJnNiLCAwKTsKCS8qIGdldCB0aGUgdXNhZ2UgdXAgdG8gdGhlIGZpcnN0IGxpbmUgd2l0aCBhIC0tIG9uIGl0ICovCglmb3IgKDs7KSB7CgkJaWYgKHN0cmJ1Zl9nZXRsaW5lKCZzYiwgc3RkaW4sICdcbicpID09IEVPRikKCQkJZGllKCJwcmVtYXR1cmUgZW5kIG9mIGlucHV0Iik7CgkJQUxMT0NfR1JPVyh1c2FnZSwgdW5iICsgMSwgdXN6KTsKCQlpZiAoIXN0cmNtcCgiLS0iLCBzYi5idWYpKSB7CgkJCWlmICh1bmIgPCAxKQoJCQkJZGllKCJubyB1c2FnZSBzdHJpbmcgZ2l2ZW4gYmVmb3JlIHRoZSBgLS0nIHNlcGFyYXRvciIpOwoJCQl1c2FnZVt1bmJdID0gTlVMTDsKCQkJYnJlYWs7CgkJfQoJCXVzYWdlW3VuYisrXSA9IHN0cmJ1Zl9kZXRhY2goJnNiLCBOVUxMKTsKCX0KCgkvKiBwYXJzZTogKDxzaG9ydD58PHNob3J0Piw8bG9uZz58PGxvbmc+KVs9P10/IFNQKyA8aGVscD4gKi8KCXdoaWxlIChzdHJidWZfZ2V0bGluZSgmc2IsIHN0ZGluLCAnXG4nKSAhPSBFT0YpIHsKCQljb25zdCBjaGFyICpzOwoJCXN0cnVjdCBvcHRpb24gKm87CgoJCWlmICghc2IubGVuKQoJCQljb250aW51ZTsKCgkJQUxMT0NfR1JPVyhvcHRzLCBvbmIgKyAxLCBvc3opOwoJCW1lbXNldChvcHRzICsgb25iLCAwLCBzaXplb2Yob3B0c1tvbmJdKSk7CgoJCW8gPSAmb3B0c1tvbmIrK107CgkJcyA9IHN0cmNocihzYi5idWYsICcgJyk7CgkJaWYgKCFzIHx8ICpzYi5idWYgPT0gJyAnKSB7CgkJCW8tPnR5cGUgPSBPUFRJT05fR1JPVVA7CgkJCW8tPmhlbHAgPSB4c3RyZHVwKHNraXBzcGFjZXMoc2IuYnVmKSk7CgkJCWNvbnRpbnVlOwoJCX0KCgkJby0+dHlwZSA9IE9QVElPTl9DQUxMQkFDSzsKCQlvLT5oZWxwID0geHN0cmR1cChza2lwc3BhY2VzKHMpKTsKCQlvLT52YWx1ZSA9ICZwYXJzZWQ7CgkJby0+ZmxhZ3MgPSBQQVJTRV9PUFRfTk9BUkc7CgkJby0+Y2FsbGJhY2sgPSAmcGFyc2VvcHRfZHVtcDsKCQl3aGlsZSAocyA+IHNiLmJ1ZiAmJiBzdHJjaHIoIio9PyEiLCBzWy0xXSkpIHsKCQkJc3dpdGNoICgqLS1zKSB7CgkJCWNhc2UgJz0nOgoJCQkJby0+ZmxhZ3MgJj0gflBBUlNFX09QVF9OT0FSRzsKCQkJCWJyZWFrOwoJCQljYXNlICc/JzoKCQkJCW8tPmZsYWdzICY9IH5QQVJTRV9PUFRfTk9BUkc7CgkJCQlvLT5mbGFncyB8PSBQQVJTRV9PUFRfT1BUQVJHOwoJCQkJYnJlYWs7CgkJCWNhc2UgJyEnOgoJCQkJby0+ZmxhZ3MgfD0gUEFSU0VfT1BUX05PTkVHOwoJCQkJYnJlYWs7CgkJCWNhc2UgJyonOgoJCQkJby0+ZmxhZ3MgfD0gUEFSU0VfT1BUX0hJRERFTjsKCQkJCWJyZWFrOwoJCQl9CgkJfQoKCQlpZiAocyAtIHNiLmJ1ZiA9PSAxKSAvKiBzaG9ydCBvcHRpb24gb25seSAqLwoJCQlvLT5zaG9ydF9uYW1lID0gKnNiLmJ1ZjsKCQllbHNlIGlmIChzYi5idWZbMV0gIT0gJywnKSAvKiBsb25nIG9wdGlvbiBvbmx5ICovCgkJCW8tPmxvbmdfbmFtZSA9IHhtZW1kdXB6KHNiLmJ1ZiwgcyAtIHNiLmJ1Zik7CgkJZWxzZSB7CgkJCW8tPnNob3J0X25hbWUgPSAqc2IuYnVmOwoJCQlvLT5sb25nX25hbWUgPSB4bWVtZHVweihzYi5idWYgKyAyLCBzIC0gc2IuYnVmIC0gMik7CgkJfQoJfQoJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCgkvKiBwdXQgYW4gT1BUX0VORCgpICovCglBTExPQ19HUk9XKG9wdHMsIG9uYiArIDEsIG9zeik7CgltZW1zZXQob3B0cyArIG9uYiwgMCwgc2l6ZW9mKG9wdHNbb25iXSkpOwoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgb3B0cywgdXNhZ2UsCgkgICAgICAgICAgICAgICAgICAgICBrZWVwX2Rhc2hkYXNoID8gUEFSU0VfT1BUX0tFRVBfREFTSERBU0ggOiAwKTsKCglzdHJidWZfYWRkZigmcGFyc2VkLCAiIC0tIik7CglzcV9xdW90ZV9hcmd2KCZwYXJzZWQsIGFyZ3YsIDApOwoJcHV0cyhwYXJzZWQuYnVmKTsKCXJldHVybiAwOwp9CgppbnQgY21kX3Jldl9wYXJzZShpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJaW50IGksIGFzX2lzID0gMCwgdmVyaWZ5ID0gMDsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgoJaWYgKGFyZ2MgPiAxICYmICFzdHJjbXAoIi0tcGFyc2VvcHQiLCBhcmd2WzFdKSkKCQlyZXR1cm4gY21kX3BhcnNlb3B0KGFyZ2MgLSAxLCBhcmd2ICsgMSwgcHJlZml4KTsKCglwcmVmaXggPSBzZXR1cF9naXRfZGlyZWN0b3J5KCk7CglnaXRfY29uZmlnKGdpdF9kZWZhdWx0X2NvbmZpZyk7Cglmb3IgKGkgPSAxOyBpIDwgYXJnYzsgaSsrKSB7CgkJY29uc3QgY2hhciAqYXJnID0gYXJndltpXTsKCgkJaWYgKGFzX2lzKSB7CgkJCWlmIChzaG93X2ZpbGUoYXJnKSAmJiBhc19pcyA8IDIpCgkJCQl2ZXJpZnlfZmlsZW5hbWUocHJlZml4LCBhcmcpOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKCFzdHJjbXAoYXJnLCItbiIpKSB7CgkJCWlmICgrK2kgPj0gYXJnYykKCQkJCWRpZSgiLW4gcmVxdWlyZXMgYW4gYXJndW1lbnQiKTsKCQkJaWYgKChmaWx0ZXIgJiBET19GTEFHUykgJiYgKGZpbHRlciAmIERPX1JFVlMpKSB7CgkJCQlzaG93KGFyZyk7CgkJCQlzaG93KGFyZ3ZbaV0pOwoJCQl9CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoIXByZWZpeGNtcChhcmcsICItbiIpKSB7CgkJCWlmICgoZmlsdGVyICYgRE9fRkxBR1MpICYmIChmaWx0ZXIgJiBET19SRVZTKSkKCQkJCXNob3coYXJnKTsKCQkJY29udGludWU7CgkJfQoKCQlpZiAoKmFyZyA9PSAnLScpIHsKCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS0iKSkgewoJCQkJYXNfaXMgPSAyOwoJCQkJLyogUGFzcyBvbiB0aGUgIi0tIiBpZiB3ZSBzaG93IGFueXRoaW5nIGJ1dCBmaWxlcy4uICovCgkJCQlpZiAoZmlsdGVyICYgKERPX0ZMQUdTIHwgRE9fUkVWUykpCgkJCQkJc2hvd19maWxlKGFyZyk7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLWRlZmF1bHQiKSkgewoJCQkJZGVmID0gYXJndltpKzFdOwoJCQkJaSsrOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1yZXZzLW9ubHkiKSkgewoJCQkJZmlsdGVyICY9IH5ET19OT1JFVjsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi0tbm8tcmV2cyIpKSB7CgkJCQlmaWx0ZXIgJj0gfkRPX1JFVlM7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLWZsYWdzIikpIHsKCQkJCWZpbHRlciAmPSB+RE9fTk9ORkxBR1M7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLW5vLWZsYWdzIikpIHsKCQkJCWZpbHRlciAmPSB+RE9fRkxBR1M7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLXZlcmlmeSIpKSB7CgkJCQlmaWx0ZXIgJj0gfihET19GTEFHU3xET19OT1JFVik7CgkJCQl2ZXJpZnkgPSAxOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1zaG9ydCIpIHx8CgkJCSAgICAhcHJlZml4Y21wKGFyZywgIi0tc2hvcnQ9IikpIHsKCQkJCWZpbHRlciAmPSB+KERPX0ZMQUdTfERPX05PUkVWKTsKCQkJCXZlcmlmeSA9IDE7CgkJCQlhYmJyZXYgPSBERUZBVUxUX0FCQlJFVjsKCQkJCWlmIChhcmdbN10gPT0gJz0nKQoJCQkJCWFiYnJldiA9IHN0cnRvdWwoYXJnICsgOCwgTlVMTCwgMTApOwoJCQkJaWYgKGFiYnJldiA8IE1JTklNVU1fQUJCUkVWKQoJCQkJCWFiYnJldiA9IE1JTklNVU1fQUJCUkVWOwoJCQkJZWxzZSBpZiAoNDAgPD0gYWJicmV2KQoJCQkJCWFiYnJldiA9IDQwOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1zcSIpKSB7CgkJCQlvdXRwdXRfc3EgPSAxOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1ub3QiKSkgewoJCQkJc2hvd190eXBlIF49IFJFVkVSU0VEOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1zeW1ib2xpYyIpKSB7CgkJCQlzeW1ib2xpYyA9IFNIT1dfU1lNQk9MSUNfQVNJUzsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi0tc3ltYm9saWMtZnVsbC1uYW1lIikpIHsKCQkJCXN5bWJvbGljID0gU0hPV19TWU1CT0xJQ19GVUxMOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1hbGwiKSkgewoJCQkJZm9yX2VhY2hfcmVmKHNob3dfcmVmZXJlbmNlLCBOVUxMKTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi0tYnJhbmNoZXMiKSkgewoJCQkJZm9yX2VhY2hfYnJhbmNoX3JlZihzaG93X3JlZmVyZW5jZSwgTlVMTCk7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLXRhZ3MiKSkgewoJCQkJZm9yX2VhY2hfdGFnX3JlZihzaG93X3JlZmVyZW5jZSwgTlVMTCk7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLXJlbW90ZXMiKSkgewoJCQkJZm9yX2VhY2hfcmVtb3RlX3JlZihzaG93X3JlZmVyZW5jZSwgTlVMTCk7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLXNob3ctcHJlZml4IikpIHsKCQkJCWlmIChwcmVmaXgpCgkJCQkJcHV0cyhwcmVmaXgpOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS1zaG93LWNkdXAiKSkgewoJCQkJY29uc3QgY2hhciAqcGZ4ID0gcHJlZml4OwoJCQkJaWYgKCFpc19pbnNpZGVfd29ya190cmVlKCkpIHsKCQkJCQljb25zdCBjaGFyICp3b3JrX3RyZWUgPQoJCQkJCQlnZXRfZ2l0X3dvcmtfdHJlZSgpOwoJCQkJCWlmICh3b3JrX3RyZWUpCgkJCQkJCXByaW50ZigiJXNcbiIsIHdvcmtfdHJlZSk7CgkJCQkJY29udGludWU7CgkJCQl9CgkJCQl3aGlsZSAocGZ4KSB7CgkJCQkJcGZ4ID0gc3RyY2hyKHBmeCwgJy8nKTsKCQkJCQlpZiAocGZ4KSB7CgkJCQkJCXBmeCsrOwoJCQkJCQlwcmludGYoIi4uLyIpOwoJCQkJCX0KCQkJCX0KCQkJCXB1dGNoYXIoJ1xuJyk7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLWdpdC1kaXIiKSkgewoJCQkJY29uc3QgY2hhciAqZ2l0ZGlyID0gZ2V0ZW52KEdJVF9ESVJfRU5WSVJPTk1FTlQpOwoJCQkJc3RhdGljIGNoYXIgY3dkW1BBVEhfTUFYXTsKCQkJCWlmIChnaXRkaXIpIHsKCQkJCQlwdXRzKGdpdGRpcik7CgkJCQkJY29udGludWU7CgkJCQl9CgkJCQlpZiAoIXByZWZpeCkgewoJCQkJCXB1dHMoIi5naXQiKTsKCQkJCQljb250aW51ZTsKCQkJCX0KCQkJCWlmICghZ2V0Y3dkKGN3ZCwgUEFUSF9NQVgpKQoJCQkJCWRpZSgidW5hYmxlIHRvIGdldCBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5Iik7CgkJCQlwcmludGYoIiVzLy5naXRcbiIsIGN3ZCk7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXN0cmNtcChhcmcsICItLWlzLWluc2lkZS1naXQtZGlyIikpIHsKCQkJCXByaW50ZigiJXNcbiIsIGlzX2luc2lkZV9naXRfZGlyKCkgPyAidHJ1ZSIKCQkJCQkJOiAiZmFsc2UiKTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi0taXMtaW5zaWRlLXdvcmstdHJlZSIpKSB7CgkJCQlwcmludGYoIiVzXG4iLCBpc19pbnNpZGVfd29ya190cmVlKCkgPyAidHJ1ZSIKCQkJCQkJOiAiZmFsc2UiKTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmICghc3RyY21wKGFyZywgIi0taXMtYmFyZS1yZXBvc2l0b3J5IikpIHsKCQkJCXByaW50ZigiJXNcbiIsIGlzX2JhcmVfcmVwb3NpdG9yeSgpID8gInRydWUiCgkJCQkJCTogImZhbHNlIik7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXByZWZpeGNtcChhcmcsICItLXNpbmNlPSIpKSB7CgkJCQlzaG93X2RhdGVzdHJpbmcoIi0tbWF4LWFnZT0iLCBhcmcrOCk7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXByZWZpeGNtcChhcmcsICItLWFmdGVyPSIpKSB7CgkJCQlzaG93X2RhdGVzdHJpbmcoIi0tbWF4LWFnZT0iLCBhcmcrOCk7CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIXByZWZpeGNtcChhcmcsICItLWJlZm9yZT0iKSkgewoJCQkJc2hvd19kYXRlc3RyaW5nKCItLW1pbi1hZ2U9IiwgYXJnKzkpOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFwcmVmaXhjbXAoYXJnLCAiLS11bnRpbD0iKSkgewoJCQkJc2hvd19kYXRlc3RyaW5nKCItLW1pbi1hZ2U9IiwgYXJnKzgpOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKHNob3dfZmxhZyhhcmcpICYmIHZlcmlmeSkKCQkJCWRpZSgiTmVlZGVkIGEgc2luZ2xlIHJldmlzaW9uIik7CgkJCWNvbnRpbnVlOwoJCX0KCgkJLyogTm90IGEgZmxhZyBhcmd1bWVudCAqLwoJCWlmICh0cnlfZGlmZmVyZW5jZShhcmcpKQoJCQljb250aW51ZTsKCQlpZiAoIWdldF9zaGExKGFyZywgc2hhMSkpIHsKCQkJc2hvd19yZXYoTk9STUFMLCBzaGExLCBhcmcpOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKCphcmcgPT0gJ14nICYmICFnZXRfc2hhMShhcmcrMSwgc2hhMSkpIHsKCQkJc2hvd19yZXYoUkVWRVJTRUQsIHNoYTEsIGFyZysxKTsKCQkJY29udGludWU7CgkJfQoJCWFzX2lzID0gMTsKCQlpZiAoIXNob3dfZmlsZShhcmcpKQoJCQljb250aW51ZTsKCQlpZiAodmVyaWZ5KQoJCQlkaWUoIk5lZWRlZCBhIHNpbmdsZSByZXZpc2lvbiIpOwoJCXZlcmlmeV9maWxlbmFtZShwcmVmaXgsIGFyZyk7Cgl9CglzaG93X2RlZmF1bHQoKTsKCWlmICh2ZXJpZnkgJiYgcmV2c19jb3VudCAhPSAxKQoJCWRpZSgiTmVlZGVkIGEgc2luZ2xlIHJldmlzaW9uIik7CglyZXR1cm4gMDsKfQo=",
    "text": "/*\n * rev-parse.c\n *\n * Copyright (C) Linus Torvalds, 2005\n */\n#include \"cache.h\"\n#include \"commit.h\"\n#include \"refs.h\"\n#include \"quote.h\"\n#include \"builtin.h\"\n#include \"parse-options.h\"\n\n#define DO_REVS\t\t1\n#define DO_NOREV\t2\n#define DO_FLAGS\t4\n#define DO_NONFLAGS\t8\nstatic int filter = ~0;\n\nstatic const char *def;\n\n#define NORMAL 0\n#define REVERSED 1\nstatic int show_type = NORMAL;\n\n#define SHOW_SYMBOLIC_ASIS 1\n#define SHOW_SYMBOLIC_FULL 2\nstatic int symbolic;\nstatic int abbrev;\nstatic int output_sq;\n\nstatic int revs_count;\n\n/*\n * Some arguments are relevant \"revision\" arguments,\n * others are about output format or other details.\n * This sorts it all out.\n */\nstatic int is_rev_argument(const char *arg)\n{\n\tstatic const char *rev_args[] = {\n\t\t\"--all\",\n\t\t\"--bisect\",\n\t\t\"--dense\",\n\t\t\"--branches\",\n\t\t\"--header\",\n\t\t\"--max-age=\",\n\t\t\"--max-count=\",\n\t\t\"--min-age=\",\n\t\t\"--no-merges\",\n\t\t\"--objects\",\n\t\t\"--objects-edge\",\n\t\t\"--parents\",\n\t\t\"--pretty\",\n\t\t\"--remotes\",\n\t\t\"--sparse\",\n\t\t\"--tags\",\n\t\t\"--topo-order\",\n\t\t\"--date-order\",\n\t\t\"--unpacked\",\n\t\tNULL\n\t};\n\tconst char **p = rev_args;\n\n\t/* accept -<digit>, like traditional \"head\" */\n\tif ((*arg == '-') && isdigit(arg[1]))\n\t\treturn 1;\n\n\tfor (;;) {\n\t\tconst char *str = *p++;\n\t\tint len;\n\t\tif (!str)\n\t\t\treturn 0;\n\t\tlen = strlen(str);\n\t\tif (!strcmp(arg, str) ||\n\t\t    (str[len-1] == '=' && !strncmp(arg, str, len)))\n\t\t\treturn 1;\n\t}\n}\n\n/* Output argument as a string, either SQ or normal */\nstatic void show(const char *arg)\n{\n\tif (output_sq) {\n\t\tint sq = '\\'', ch;\n\n\t\tputchar(sq);\n\t\twhile ((ch = *arg++)) {\n\t\t\tif (ch == sq)\n\t\t\t\tfputs(\"'\\\\'\", stdout);\n\t\t\tputchar(ch);\n\t\t}\n\t\tputchar(sq);\n\t\tputchar(' ');\n\t}\n\telse\n\t\tputs(arg);\n}\n\n/* Like show(), but with a negation prefix according to type */\nstatic void show_with_type(int type, const char *arg)\n{\n\tif (type != show_type)\n\t\tputchar('^');\n\tshow(arg);\n}\n\n/* Output a revision, only if filter allows it */\nstatic void show_rev(int type, const unsigned char *sha1, const char *name)\n{\n\tif (!(filter & DO_REVS))\n\t\treturn;\n\tdef = NULL;\n\trevs_count++;\n\n\tif (symbolic && name) {\n\t\tif (symbolic == SHOW_SYMBOLIC_FULL) {\n\t\t\tunsigned char discard[20];\n\t\t\tchar *full;\n\n\t\t\tswitch (dwim_ref(name, strlen(name), discard, &full)) {\n\t\t\tcase 0:\n\t\t\t\t/*\n\t\t\t\t * Not found -- not a ref.  We could\n\t\t\t\t * emit \"name\" here, but symbolic-full\n\t\t\t\t * users are interested in finding the\n\t\t\t\t * refs spelled in full, and they would\n\t\t\t\t * need to filter non-refs if we did so.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\tcase 1: /* happy */\n\t\t\t\tshow_with_type(type, full);\n\t\t\t\tbreak;\n\t\t\tdefault: /* ambiguous */\n\t\t\t\terror(\"refname '%s' is ambiguous\", name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tshow_with_type(type, name);\n\t\t}\n\t}\n\telse if (abbrev)\n\t\tshow_with_type(type, find_unique_abbrev(sha1, abbrev));\n\telse\n\t\tshow_with_type(type, sha1_to_hex(sha1));\n}\n\n/* Output a flag, only if filter allows it. */\nstatic int show_flag(const char *arg)\n{\n\tif (!(filter & DO_FLAGS))\n\t\treturn 0;\n\tif (filter & (is_rev_argument(arg) ? DO_REVS : DO_NOREV)) {\n\t\tshow(arg);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void show_default(void)\n{\n\tconst char *s = def;\n\n\tif (s) {\n\t\tunsigned char sha1[20];\n\n\t\tdef = NULL;\n\t\tif (!get_sha1(s, sha1)) {\n\t\t\tshow_rev(NORMAL, sha1, s);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int show_reference(const char *refname, const unsigned char *sha1, int flag, void *cb_data)\n{\n\tshow_rev(NORMAL, sha1, refname);\n\treturn 0;\n}\n\nstatic void show_datestring(const char *flag, const char *datestr)\n{\n\tstatic char buffer[100];\n\n\t/* date handling requires both flags and revs */\n\tif ((filter & (DO_FLAGS | DO_REVS)) != (DO_FLAGS | DO_REVS))\n\t\treturn;\n\tsnprintf(buffer, sizeof(buffer), \"%s%lu\", flag, approxidate(datestr));\n\tshow(buffer);\n}\n\nstatic int show_file(const char *arg)\n{\n\tshow_default();\n\tif ((filter & (DO_NONFLAGS|DO_NOREV)) == (DO_NONFLAGS|DO_NOREV)) {\n\t\tshow(arg);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int try_difference(const char *arg)\n{\n\tchar *dotdot;\n\tunsigned char sha1[20];\n\tunsigned char end[20];\n\tconst char *next;\n\tconst char *this;\n\tint symmetric;\n\n\tif (!(dotdot = strstr(arg, \"..\")))\n\t\treturn 0;\n\tnext = dotdot + 2;\n\tthis = arg;\n\tsymmetric = (*next == '.');\n\n\t*dotdot = 0;\n\tnext += symmetric;\n\n\tif (!*next)\n\t\tnext = \"HEAD\";\n\tif (dotdot == arg)\n\t\tthis = \"HEAD\";\n\tif (!get_sha1(this, sha1) && !get_sha1(next, end)) {\n\t\tshow_rev(NORMAL, end, next);\n\t\tshow_rev(symmetric ? NORMAL : REVERSED, sha1, this);\n\t\tif (symmetric) {\n\t\t\tstruct commit_list *exclude;\n\t\t\tstruct commit *a, *b;\n\t\t\ta = lookup_commit_reference(sha1);\n\t\t\tb = lookup_commit_reference(end);\n\t\t\texclude = get_merge_bases(a, b, 1);\n\t\t\twhile (exclude) {\n\t\t\t\tstruct commit_list *n = exclude->next;\n\t\t\t\tshow_rev(REVERSED,\n\t\t\t\t\t exclude->item->object.sha1,NULL);\n\t\t\t\tfree(exclude);\n\t\t\t\texclude = n;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\t*dotdot = '.';\n\treturn 0;\n}\n\nstatic int parseopt_dump(const struct option *o, const char *arg, int unset)\n{\n\tstruct strbuf *parsed = o->value;\n\tif (unset)\n\t\tstrbuf_addf(parsed, \" --no-%s\", o->long_name);\n\telse if (o->short_name)\n\t\tstrbuf_addf(parsed, \" -%c\", o->short_name);\n\telse\n\t\tstrbuf_addf(parsed, \" --%s\", o->long_name);\n\tif (arg) {\n\t\tstrbuf_addch(parsed, ' ');\n\t\tsq_quote_buf(parsed, arg);\n\t}\n\treturn 0;\n}\n\nstatic const char *skipspaces(const char *s)\n{\n\twhile (isspace(*s))\n\t\ts++;\n\treturn s;\n}\n\nstatic int cmd_parseopt(int argc, const char **argv, const char *prefix)\n{\n\tstatic int keep_dashdash = 0;\n\tstatic char const * const parseopt_usage[] = {\n\t\t\"git-rev-parse --parseopt [options] -- [<args>...]\",\n\t\tNULL\n\t};\n\tstatic struct option parseopt_opts[] = {\n\t\tOPT_BOOLEAN(0, \"keep-dashdash\", &keep_dashdash,\n\t\t\t\t\t\"keep the `--` passed as an arg\"),\n\t\tOPT_END(),\n\t};\n\n\tstruct strbuf sb, parsed;\n\tconst char **usage = NULL;\n\tstruct option *opts = NULL;\n\tint onb = 0, osz = 0, unb = 0, usz = 0;\n\n\tstrbuf_init(&parsed, 0);\n\tstrbuf_addstr(&parsed, \"set --\");\n\targc = parse_options(argc, argv, parseopt_opts, parseopt_usage,\n\t                     PARSE_OPT_KEEP_DASHDASH);\n\tif (argc < 1 || strcmp(argv[0], \"--\"))\n\t\tusage_with_options(parseopt_usage, parseopt_opts);\n\n\tstrbuf_init(&sb, 0);\n\t/* get the usage up to the first line with a -- on it */\n\tfor (;;) {\n\t\tif (strbuf_getline(&sb, stdin, '\\n') == EOF)\n\t\t\tdie(\"premature end of input\");\n\t\tALLOC_GROW(usage, unb + 1, usz);\n\t\tif (!strcmp(\"--\", sb.buf)) {\n\t\t\tif (unb < 1)\n\t\t\t\tdie(\"no usage string given before the `--' separator\");\n\t\t\tusage[unb] = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tusage[unb++] = strbuf_detach(&sb, NULL);\n\t}\n\n\t/* parse: (<short>|<short>,<long>|<long>)[=?]? SP+ <help> */\n\twhile (strbuf_getline(&sb, stdin, '\\n') != EOF) {\n\t\tconst char *s;\n\t\tstruct option *o;\n\n\t\tif (!sb.len)\n\t\t\tcontinue;\n\n\t\tALLOC_GROW(opts, onb + 1, osz);\n\t\tmemset(opts + onb, 0, sizeof(opts[onb]));\n\n\t\to = &opts[onb++];\n\t\ts = strchr(sb.buf, ' ');\n\t\tif (!s || *sb.buf == ' ') {\n\t\t\to->type = OPTION_GROUP;\n\t\t\to->help = xstrdup(skipspaces(sb.buf));\n\t\t\tcontinue;\n\t\t}\n\n\t\to->type = OPTION_CALLBACK;\n\t\to->help = xstrdup(skipspaces(s));\n\t\to->value = &parsed;\n\t\to->flags = PARSE_OPT_NOARG;\n\t\to->callback = &parseopt_dump;\n\t\twhile (s > sb.buf && strchr(\"*=?!\", s[-1])) {\n\t\t\tswitch (*--s) {\n\t\t\tcase '=':\n\t\t\t\to->flags &= ~PARSE_OPT_NOARG;\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\t\to->flags &= ~PARSE_OPT_NOARG;\n\t\t\t\to->flags |= PARSE_OPT_OPTARG;\n\t\t\t\tbreak;\n\t\t\tcase '!':\n\t\t\t\to->flags |= PARSE_OPT_NONEG;\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\to->flags |= PARSE_OPT_HIDDEN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (s - sb.buf == 1) /* short option only */\n\t\t\to->short_name = *sb.buf;\n\t\telse if (sb.buf[1] != ',') /* long option only */\n\t\t\to->long_name = xmemdupz(sb.buf, s - sb.buf);\n\t\telse {\n\t\t\to->short_name = *sb.buf;\n\t\t\to->long_name = xmemdupz(sb.buf + 2, s - sb.buf - 2);\n\t\t}\n\t}\n\tstrbuf_release(&sb);\n\n\t/* put an OPT_END() */\n\tALLOC_GROW(opts, onb + 1, osz);\n\tmemset(opts + onb, 0, sizeof(opts[onb]));\n\targc = parse_options(argc, argv, opts, usage,\n\t                     keep_dashdash ? PARSE_OPT_KEEP_DASHDASH : 0);\n\n\tstrbuf_addf(&parsed, \" --\");\n\tsq_quote_argv(&parsed, argv, 0);\n\tputs(parsed.buf);\n\treturn 0;\n}\n\nint cmd_rev_parse(int argc, const char **argv, const char *prefix)\n{\n\tint i, as_is = 0, verify = 0;\n\tunsigned char sha1[20];\n\n\tif (argc > 1 && !strcmp(\"--parseopt\", argv[1]))\n\t\treturn cmd_parseopt(argc - 1, argv + 1, prefix);\n\n\tprefix = setup_git_directory();\n\tgit_config(git_default_config);\n\tfor (i = 1; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\n\t\tif (as_is) {\n\t\t\tif (show_file(arg) && as_is < 2)\n\t\t\t\tverify_filename(prefix, arg);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg,\"-n\")) {\n\t\t\tif (++i >= argc)\n\t\t\t\tdie(\"-n requires an argument\");\n\t\t\tif ((filter & DO_FLAGS) && (filter & DO_REVS)) {\n\t\t\t\tshow(arg);\n\t\t\t\tshow(argv[i]);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!prefixcmp(arg, \"-n\")) {\n\t\t\tif ((filter & DO_FLAGS) && (filter & DO_REVS))\n\t\t\t\tshow(arg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (*arg == '-') {\n\t\t\tif (!strcmp(arg, \"--\")) {\n\t\t\t\tas_is = 2;\n\t\t\t\t/* Pass on the \"--\" if we show anything but files.. */\n\t\t\t\tif (filter & (DO_FLAGS | DO_REVS))\n\t\t\t\t\tshow_file(arg);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--default\")) {\n\t\t\t\tdef = argv[i+1];\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--revs-only\")) {\n\t\t\t\tfilter &= ~DO_NOREV;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--no-revs\")) {\n\t\t\t\tfilter &= ~DO_REVS;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--flags\")) {\n\t\t\t\tfilter &= ~DO_NONFLAGS;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--no-flags\")) {\n\t\t\t\tfilter &= ~DO_FLAGS;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--verify\")) {\n\t\t\t\tfilter &= ~(DO_FLAGS|DO_NOREV);\n\t\t\t\tverify = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--short\") ||\n\t\t\t    !prefixcmp(arg, \"--short=\")) {\n\t\t\t\tfilter &= ~(DO_FLAGS|DO_NOREV);\n\t\t\t\tverify = 1;\n\t\t\t\tabbrev = DEFAULT_ABBREV;\n\t\t\t\tif (arg[7] == '=')\n\t\t\t\t\tabbrev = strtoul(arg + 8, NULL, 10);\n\t\t\t\tif (abbrev < MINIMUM_ABBREV)\n\t\t\t\t\tabbrev = MINIMUM_ABBREV;\n\t\t\t\telse if (40 <= abbrev)\n\t\t\t\t\tabbrev = 40;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--sq\")) {\n\t\t\t\toutput_sq = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--not\")) {\n\t\t\t\tshow_type ^= REVERSED;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--symbolic\")) {\n\t\t\t\tsymbolic = SHOW_SYMBOLIC_ASIS;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--symbolic-full-name\")) {\n\t\t\t\tsymbolic = SHOW_SYMBOLIC_FULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--all\")) {\n\t\t\t\tfor_each_ref(show_reference, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--branches\")) {\n\t\t\t\tfor_each_branch_ref(show_reference, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--tags\")) {\n\t\t\t\tfor_each_tag_ref(show_reference, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--remotes\")) {\n\t\t\t\tfor_each_remote_ref(show_reference, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--show-prefix\")) {\n\t\t\t\tif (prefix)\n\t\t\t\t\tputs(prefix);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--show-cdup\")) {\n\t\t\t\tconst char *pfx = prefix;\n\t\t\t\tif (!is_inside_work_tree()) {\n\t\t\t\t\tconst char *work_tree =\n\t\t\t\t\t\tget_git_work_tree();\n\t\t\t\t\tif (work_tree)\n\t\t\t\t\t\tprintf(\"%s\\n\", work_tree);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twhile (pfx) {\n\t\t\t\t\tpfx = strchr(pfx, '/');\n\t\t\t\t\tif (pfx) {\n\t\t\t\t\t\tpfx++;\n\t\t\t\t\t\tprintf(\"../\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tputchar('\\n');\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--git-dir\")) {\n\t\t\t\tconst char *gitdir = getenv(GIT_DIR_ENVIRONMENT);\n\t\t\t\tstatic char cwd[PATH_MAX];\n\t\t\t\tif (gitdir) {\n\t\t\t\t\tputs(gitdir);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!prefix) {\n\t\t\t\t\tputs(\".git\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!getcwd(cwd, PATH_MAX))\n\t\t\t\t\tdie(\"unable to get current working directory\");\n\t\t\t\tprintf(\"%s/.git\\n\", cwd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--is-inside-git-dir\")) {\n\t\t\t\tprintf(\"%s\\n\", is_inside_git_dir() ? \"true\"\n\t\t\t\t\t\t: \"false\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--is-inside-work-tree\")) {\n\t\t\t\tprintf(\"%s\\n\", is_inside_work_tree() ? \"true\"\n\t\t\t\t\t\t: \"false\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(arg, \"--is-bare-repository\")) {\n\t\t\t\tprintf(\"%s\\n\", is_bare_repository() ? \"true\"\n\t\t\t\t\t\t: \"false\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--since=\")) {\n\t\t\t\tshow_datestring(\"--max-age=\", arg+8);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--after=\")) {\n\t\t\t\tshow_datestring(\"--max-age=\", arg+8);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--before=\")) {\n\t\t\t\tshow_datestring(\"--min-age=\", arg+9);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!prefixcmp(arg, \"--until=\")) {\n\t\t\t\tshow_datestring(\"--min-age=\", arg+8);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (show_flag(arg) && verify)\n\t\t\t\tdie(\"Needed a single revision\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Not a flag argument */\n\t\tif (try_difference(arg))\n\t\t\tcontinue;\n\t\tif (!get_sha1(arg, sha1)) {\n\t\t\tshow_rev(NORMAL, sha1, arg);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*arg == '^' && !get_sha1(arg+1, sha1)) {\n\t\t\tshow_rev(REVERSED, sha1, arg+1);\n\t\t\tcontinue;\n\t\t}\n\t\tas_is = 1;\n\t\tif (!show_file(arg))\n\t\t\tcontinue;\n\t\tif (verify)\n\t\t\tdie(\"Needed a single revision\");\n\t\tverify_filename(prefix, arg);\n\t}\n\tshow_default();\n\tif (verify && revs_count != 1)\n\t\tdie(\"Needed a single revision\");\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00b607824dda2dab1c1ffb8bfdbd0972baa44ec5",
  "sha1_ok": true,
  "size": 12677
}
