{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjYWNoZS10cmVlLmgiCiNpbmNsdWRlICJ0cmVlLmgiCiNpbmNsdWRlICJibG9iLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAidHJlZS13YWxrLmgiCgpjb25zdCBjaGFyICp0cmVlX3R5cGUgPSAidHJlZSI7CgpzdGF0aWMgaW50IHJlYWRfb25lX2VudHJ5X29wdChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBjb25zdCBjaGFyICpiYXNlLCBpbnQgYmFzZWxlbiwgY29uc3QgY2hhciAqcGF0aG5hbWUsIHVuc2lnbmVkIG1vZGUsIGludCBzdGFnZSwgaW50IG9wdCkKewoJaW50IGxlbjsKCXVuc2lnbmVkIGludCBzaXplOwoJc3RydWN0IGNhY2hlX2VudHJ5ICpjZTsKCglpZiAoU19JU0RJUihtb2RlKSkKCQlyZXR1cm4gUkVBRF9UUkVFX1JFQ1VSU0lWRTsKCglsZW4gPSBzdHJsZW4ocGF0aG5hbWUpOwoJc2l6ZSA9IGNhY2hlX2VudHJ5X3NpemUoYmFzZWxlbiArIGxlbik7CgljZSA9IHhjYWxsb2MoMSwgc2l6ZSk7CgoJY2UtPmNlX21vZGUgPSBjcmVhdGVfY2VfbW9kZShtb2RlKTsKCWNlLT5jZV9mbGFncyA9IGNyZWF0ZV9jZV9mbGFncyhzdGFnZSk7CgljZS0+Y2VfbmFtZWxlbiA9IGJhc2VsZW4gKyBsZW47CgltZW1jcHkoY2UtPm5hbWUsIGJhc2UsIGJhc2VsZW4pOwoJbWVtY3B5KGNlLT5uYW1lICsgYmFzZWxlbiwgcGF0aG5hbWUsIGxlbisxKTsKCWhhc2hjcHkoY2UtPnNoYTEsIHNoYTEpOwoJcmV0dXJuIGFkZF9jYWNoZV9lbnRyeShjZSwgb3B0KTsKfQoKc3RhdGljIGludCByZWFkX29uZV9lbnRyeShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBzdHJ1Y3Qgc3RyYnVmICpiYXNlLAoJCQkgIGNvbnN0IGNoYXIgKnBhdGhuYW1lLCB1bnNpZ25lZCBtb2RlLCBpbnQgc3RhZ2UsCgkJCSAgdm9pZCAqY29udGV4dCkKewoJcmV0dXJuIHJlYWRfb25lX2VudHJ5X29wdChzaGExLCBiYXNlLT5idWYsIGJhc2UtPmxlbiwgcGF0aG5hbWUsCgkJCQkgIG1vZGUsIHN0YWdlLAoJCQkJICBBRERfQ0FDSEVfT0tfVE9fQUREfEFERF9DQUNIRV9TS0lQX0RGQ0hFQ0spOwp9CgovKgogKiBUaGlzIGlzIHVzZWQgd2hlbiB0aGUgY2FsbGVyIGtub3dzIHRoZXJlIGlzIG5vIGV4aXN0aW5nIGVudHJpZXMgYXQKICogdGhlIHN0YWdlIHRoYXQgd2lsbCBjb25mbGljdCB3aXRoIHRoZSBlbnRyeSBiZWluZyBhZGRlZC4KICovCnN0YXRpYyBpbnQgcmVhZF9vbmVfZW50cnlfcXVpY2soY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgc3RydWN0IHN0cmJ1ZiAqYmFzZSwKCQkJCWNvbnN0IGNoYXIgKnBhdGhuYW1lLCB1bnNpZ25lZCBtb2RlLCBpbnQgc3RhZ2UsCgkJCQl2b2lkICpjb250ZXh0KQp7CglyZXR1cm4gcmVhZF9vbmVfZW50cnlfb3B0KHNoYTEsIGJhc2UtPmJ1ZiwgYmFzZS0+bGVuLCBwYXRobmFtZSwKCQkJCSAgbW9kZSwgc3RhZ2UsCgkJCQkgIEFERF9DQUNIRV9KVVNUX0FQUEVORCk7Cn0KCnN0YXRpYyBpbnQgcmVhZF90cmVlXzEoc3RydWN0IHRyZWUgKnRyZWUsIHN0cnVjdCBzdHJidWYgKmJhc2UsCgkJICAgICAgIGludCBzdGFnZSwgY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwYXRoc3BlYywKCQkgICAgICAgcmVhZF90cmVlX2ZuX3QgZm4sIHZvaWQgKmNvbnRleHQpCnsKCXN0cnVjdCB0cmVlX2Rlc2MgZGVzYzsKCXN0cnVjdCBuYW1lX2VudHJ5IGVudHJ5OwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCWludCBsZW4sIG9sZGxlbiA9IGJhc2UtPmxlbjsKCWVudW0gaW50ZXJlc3RpbmcgcmV0dmFsID0gZW50cnlfbm90X2ludGVyZXN0aW5nOwoKCWlmIChwYXJzZV90cmVlKHRyZWUpKQoJCXJldHVybiAtMTsKCglpbml0X3RyZWVfZGVzYygmZGVzYywgdHJlZS0+YnVmZmVyLCB0cmVlLT5zaXplKTsKCgl3aGlsZSAodHJlZV9lbnRyeSgmZGVzYywgJmVudHJ5KSkgewoJCWlmIChyZXR2YWwgIT0gYWxsX2VudHJpZXNfaW50ZXJlc3RpbmcpIHsKCQkJcmV0dmFsID0gdHJlZV9lbnRyeV9pbnRlcmVzdGluZygmZW50cnksIGJhc2UsIDAsIHBhdGhzcGVjKTsKCQkJaWYgKHJldHZhbCA9PSBhbGxfZW50cmllc19ub3RfaW50ZXJlc3RpbmcpCgkJCQlicmVhazsKCQkJaWYgKHJldHZhbCA9PSBlbnRyeV9ub3RfaW50ZXJlc3RpbmcpCgkJCQljb250aW51ZTsKCQl9CgoJCXN3aXRjaCAoZm4oZW50cnkub2lkLT5oYXNoLCBiYXNlLAoJCQkgICBlbnRyeS5wYXRoLCBlbnRyeS5tb2RlLCBzdGFnZSwgY29udGV4dCkpIHsKCQljYXNlIDA6CgkJCWNvbnRpbnVlOwoJCWNhc2UgUkVBRF9UUkVFX1JFQ1VSU0lWRToKCQkJYnJlYWs7CgkJZGVmYXVsdDoKCQkJcmV0dXJuIC0xOwoJCX0KCgkJaWYgKFNfSVNESVIoZW50cnkubW9kZSkpCgkJCWhhc2hjcHkoc2hhMSwgZW50cnkub2lkLT5oYXNoKTsKCQllbHNlIGlmIChTX0lTR0lUTElOSyhlbnRyeS5tb2RlKSkgewoJCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgoJCQljb21taXQgPSBsb29rdXBfY29tbWl0KGVudHJ5Lm9pZC0+aGFzaCk7CgkJCWlmICghY29tbWl0KQoJCQkJZGllKCJDb21taXQgJXMgaW4gc3VibW9kdWxlIHBhdGggJXMlcyBub3QgZm91bmQiLAoJCQkJICAgIG9pZF90b19oZXgoZW50cnkub2lkKSwKCQkJCSAgICBiYXNlLT5idWYsIGVudHJ5LnBhdGgpOwoKCQkJaWYgKHBhcnNlX2NvbW1pdChjb21taXQpKQoJCQkJZGllKCJJbnZhbGlkIGNvbW1pdCAlcyBpbiBzdWJtb2R1bGUgcGF0aCAlcyVzIiwKCQkJCSAgICBvaWRfdG9faGV4KGVudHJ5Lm9pZCksCgkJCQkgICAgYmFzZS0+YnVmLCBlbnRyeS5wYXRoKTsKCgkJCWhhc2hjcHkoc2hhMSwgY29tbWl0LT50cmVlLT5vYmplY3Qub2lkLmhhc2gpOwoJCX0KCQllbHNlCgkJCWNvbnRpbnVlOwoKCQlsZW4gPSB0cmVlX2VudHJ5X2xlbigmZW50cnkpOwoJCXN0cmJ1Zl9hZGQoYmFzZSwgZW50cnkucGF0aCwgbGVuKTsKCQlzdHJidWZfYWRkY2goYmFzZSwgJy8nKTsKCQlyZXR2YWwgPSByZWFkX3RyZWVfMShsb29rdXBfdHJlZShzaGExKSwKCQkJCSAgICAgYmFzZSwgc3RhZ2UsIHBhdGhzcGVjLAoJCQkJICAgICBmbiwgY29udGV4dCk7CgkJc3RyYnVmX3NldGxlbihiYXNlLCBvbGRsZW4pOwoJCWlmIChyZXR2YWwpCgkJCXJldHVybiAtMTsKCX0KCXJldHVybiAwOwp9CgppbnQgcmVhZF90cmVlX3JlY3Vyc2l2ZShzdHJ1Y3QgdHJlZSAqdHJlZSwKCQkJY29uc3QgY2hhciAqYmFzZSwgaW50IGJhc2VsZW4sCgkJCWludCBzdGFnZSwgY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwYXRoc3BlYywKCQkJcmVhZF90cmVlX2ZuX3QgZm4sIHZvaWQgKmNvbnRleHQpCnsKCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCWludCByZXQ7CgoJc3RyYnVmX2FkZCgmc2IsIGJhc2UsIGJhc2VsZW4pOwoJcmV0ID0gcmVhZF90cmVlXzEodHJlZSwgJnNiLCBzdGFnZSwgcGF0aHNwZWMsIGZuLCBjb250ZXh0KTsKCXN0cmJ1Zl9yZWxlYXNlKCZzYik7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IGNtcF9jYWNoZV9uYW1lX2NvbXBhcmUoY29uc3Qgdm9pZCAqYV8sIGNvbnN0IHZvaWQgKmJfKQp7Cgljb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlMSwgKmNlMjsKCgljZTEgPSAqKChjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKiopYV8pOwoJY2UyID0gKigoY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICoqKWJfKTsKCXJldHVybiBjYWNoZV9uYW1lX3N0YWdlX2NvbXBhcmUoY2UxLT5uYW1lLCBjZTEtPmNlX25hbWVsZW4sIGNlX3N0YWdlKGNlMSksCgkJCQkgIGNlMi0+bmFtZSwgY2UyLT5jZV9uYW1lbGVuLCBjZV9zdGFnZShjZTIpKTsKfQoKaW50IHJlYWRfdHJlZShzdHJ1Y3QgdHJlZSAqdHJlZSwgaW50IHN0YWdlLCBzdHJ1Y3QgcGF0aHNwZWMgKm1hdGNoKQp7CglyZWFkX3RyZWVfZm5fdCBmbiA9IE5VTEw7CglpbnQgaSwgZXJyOwoKCS8qCgkgKiBDdXJyZW50bHkgdGhlIG9ubHkgZXhpc3RpbmcgY2FsbGVycyBvZiB0aGlzIGZ1bmN0aW9uIGFsbAoJICogY2FsbCBpdCB3aXRoIHN0YWdlPTEgYW5kIGFmdGVyIG1ha2luZyBzdXJlIHRoZXJlIGlzIG5vdGhpbmcKCSAqIGF0IHRoYXQgc3RhZ2U7IHdlIGNvdWxkIGFsd2F5cyB1c2UgcmVhZF9vbmVfZW50cnlfcXVpY2soKS4KCSAqCgkgKiBCdXQgd2hlbiB3ZSBkZWNpZGUgdG8gc3RyYWlnaHRlbiBvdXQgZ2l0LXJlYWQtdHJlZSBub3QgdG8KCSAqIHVzZSB1bnBhY2tfdHJlZXMoKSBpbiBzb21lIGNhc2VzLCB0aGlzIHdpbGwgcHJvYmFibHkgc3RhcnQKCSAqIHRvIG1hdHRlci4KCSAqLwoKCS8qCgkgKiBTZWUgaWYgd2UgaGF2ZSBjYWNoZSBlbnRyeSBhdCB0aGUgc3RhZ2UuICBJZiBzbywKCSAqIGRvIGl0IHRoZSBvcmlnaW5hbCBzbG93IHdheSwgb3RoZXJ3aXNlLCBhcHBlbmQgYW5kIHRoZW4KCSAqIHNvcnQgYXQgdGhlIGVuZC4KCSAqLwoJZm9yIChpID0gMDsgIWZuICYmIGkgPCBhY3RpdmVfbnI7IGkrKykgewoJCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBhY3RpdmVfY2FjaGVbaV07CgkJaWYgKGNlX3N0YWdlKGNlKSA9PSBzdGFnZSkKCQkJZm4gPSByZWFkX29uZV9lbnRyeTsKCX0KCglpZiAoIWZuKQoJCWZuID0gcmVhZF9vbmVfZW50cnlfcXVpY2s7CgllcnIgPSByZWFkX3RyZWVfcmVjdXJzaXZlKHRyZWUsICIiLCAwLCBzdGFnZSwgbWF0Y2gsIGZuLCBOVUxMKTsKCWlmIChmbiA9PSByZWFkX29uZV9lbnRyeSB8fCBlcnIpCgkJcmV0dXJuIGVycjsKCgkvKgoJICogU29ydCB0aGUgY2FjaGUgZW50cnkgLS0gd2UgbmVlZCB0byBudWtlIHRoZSBjYWNoZSB0cmVlLCB0aG91Z2guCgkgKi8KCWNhY2hlX3RyZWVfZnJlZSgmYWN0aXZlX2NhY2hlX3RyZWUpOwoJcXNvcnQoYWN0aXZlX2NhY2hlLCBhY3RpdmVfbnIsIHNpemVvZihhY3RpdmVfY2FjaGVbMF0pLAoJICAgICAgY21wX2NhY2hlX25hbWVfY29tcGFyZSk7CglyZXR1cm4gMDsKfQoKc3RydWN0IHRyZWUgKmxvb2t1cF90cmVlKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXN0cnVjdCBvYmplY3QgKm9iaiA9IGxvb2t1cF9vYmplY3Qoc2hhMSk7CglpZiAoIW9iaikKCQlyZXR1cm4gY3JlYXRlX29iamVjdChzaGExLCBhbGxvY190cmVlX25vZGUoKSk7CglyZXR1cm4gb2JqZWN0X2FzX3R5cGUob2JqLCBPQkpfVFJFRSwgMCk7Cn0KCmludCBwYXJzZV90cmVlX2J1ZmZlcihzdHJ1Y3QgdHJlZSAqaXRlbSwgdm9pZCAqYnVmZmVyLCB1bnNpZ25lZCBsb25nIHNpemUpCnsKCWlmIChpdGVtLT5vYmplY3QucGFyc2VkKQoJCXJldHVybiAwOwoJaXRlbS0+b2JqZWN0LnBhcnNlZCA9IDE7CglpdGVtLT5idWZmZXIgPSBidWZmZXI7CglpdGVtLT5zaXplID0gc2l6ZTsKCglyZXR1cm4gMDsKfQoKaW50IHBhcnNlX3RyZWVfZ2VudGx5KHN0cnVjdCB0cmVlICppdGVtLCBpbnQgcXVpZXRfb25fbWlzc2luZykKewoJIGVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCSB2b2lkICpidWZmZXI7CgkgdW5zaWduZWQgbG9uZyBzaXplOwoKCWlmIChpdGVtLT5vYmplY3QucGFyc2VkKQoJCXJldHVybiAwOwoJYnVmZmVyID0gcmVhZF9zaGExX2ZpbGUoaXRlbS0+b2JqZWN0Lm9pZC5oYXNoLCAmdHlwZSwgJnNpemUpOwoJaWYgKCFidWZmZXIpCgkJcmV0dXJuIHF1aWV0X29uX21pc3NpbmcgPyAtMSA6CgkJCWVycm9yKCJDb3VsZCBub3QgcmVhZCAlcyIsCgkJCSAgICAgb2lkX3RvX2hleCgmaXRlbS0+b2JqZWN0Lm9pZCkpOwoJaWYgKHR5cGUgIT0gT0JKX1RSRUUpIHsKCQlmcmVlKGJ1ZmZlcik7CgkJcmV0dXJuIGVycm9yKCJPYmplY3QgJXMgbm90IGEgdHJlZSIsCgkJCSAgICAgb2lkX3RvX2hleCgmaXRlbS0+b2JqZWN0Lm9pZCkpOwoJfQoJcmV0dXJuIHBhcnNlX3RyZWVfYnVmZmVyKGl0ZW0sIGJ1ZmZlciwgc2l6ZSk7Cn0KCnZvaWQgZnJlZV90cmVlX2J1ZmZlcihzdHJ1Y3QgdHJlZSAqdHJlZSkKewoJZnJlZSh0cmVlLT5idWZmZXIpOwoJdHJlZS0+YnVmZmVyID0gTlVMTDsKCXRyZWUtPnNpemUgPSAwOwoJdHJlZS0+b2JqZWN0LnBhcnNlZCA9IDA7Cn0KCnN0cnVjdCB0cmVlICpwYXJzZV90cmVlX2luZGlyZWN0KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXN0cnVjdCBvYmplY3QgKm9iaiA9IHBhcnNlX29iamVjdChzaGExKTsKCWRvIHsKCQlpZiAoIW9iaikKCQkJcmV0dXJuIE5VTEw7CgkJaWYgKG9iai0+dHlwZSA9PSBPQkpfVFJFRSkKCQkJcmV0dXJuIChzdHJ1Y3QgdHJlZSAqKSBvYmo7CgkJZWxzZSBpZiAob2JqLT50eXBlID09IE9CSl9DT01NSVQpCgkJCW9iaiA9ICYoKChzdHJ1Y3QgY29tbWl0ICopIG9iaiktPnRyZWUtPm9iamVjdCk7CgkJZWxzZSBpZiAob2JqLT50eXBlID09IE9CSl9UQUcpCgkJCW9iaiA9ICgoc3RydWN0IHRhZyAqKSBvYmopLT50YWdnZWQ7CgkJZWxzZQoJCQlyZXR1cm4gTlVMTDsKCQlpZiAoIW9iai0+cGFyc2VkKQoJCQlwYXJzZV9vYmplY3Qob2JqLT5vaWQuaGFzaCk7Cgl9IHdoaWxlICgxKTsKfQo=",
    "text": "#include \"cache.h\"\n#include \"cache-tree.h\"\n#include \"tree.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"tree-walk.h\"\n\nconst char *tree_type = \"tree\";\n\nstatic int read_one_entry_opt(const unsigned char *sha1, const char *base, int baselen, const char *pathname, unsigned mode, int stage, int opt)\n{\n\tint len;\n\tunsigned int size;\n\tstruct cache_entry *ce;\n\n\tif (S_ISDIR(mode))\n\t\treturn READ_TREE_RECURSIVE;\n\n\tlen = strlen(pathname);\n\tsize = cache_entry_size(baselen + len);\n\tce = xcalloc(1, size);\n\n\tce->ce_mode = create_ce_mode(mode);\n\tce->ce_flags = create_ce_flags(stage);\n\tce->ce_namelen = baselen + len;\n\tmemcpy(ce->name, base, baselen);\n\tmemcpy(ce->name + baselen, pathname, len+1);\n\thashcpy(ce->sha1, sha1);\n\treturn add_cache_entry(ce, opt);\n}\n\nstatic int read_one_entry(const unsigned char *sha1, struct strbuf *base,\n\t\t\t  const char *pathname, unsigned mode, int stage,\n\t\t\t  void *context)\n{\n\treturn read_one_entry_opt(sha1, base->buf, base->len, pathname,\n\t\t\t\t  mode, stage,\n\t\t\t\t  ADD_CACHE_OK_TO_ADD|ADD_CACHE_SKIP_DFCHECK);\n}\n\n/*\n * This is used when the caller knows there is no existing entries at\n * the stage that will conflict with the entry being added.\n */\nstatic int read_one_entry_quick(const unsigned char *sha1, struct strbuf *base,\n\t\t\t\tconst char *pathname, unsigned mode, int stage,\n\t\t\t\tvoid *context)\n{\n\treturn read_one_entry_opt(sha1, base->buf, base->len, pathname,\n\t\t\t\t  mode, stage,\n\t\t\t\t  ADD_CACHE_JUST_APPEND);\n}\n\nstatic int read_tree_1(struct tree *tree, struct strbuf *base,\n\t\t       int stage, const struct pathspec *pathspec,\n\t\t       read_tree_fn_t fn, void *context)\n{\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tunsigned char sha1[20];\n\tint len, oldlen = base->len;\n\tenum interesting retval = entry_not_interesting;\n\n\tif (parse_tree(tree))\n\t\treturn -1;\n\n\tinit_tree_desc(&desc, tree->buffer, tree->size);\n\n\twhile (tree_entry(&desc, &entry)) {\n\t\tif (retval != all_entries_interesting) {\n\t\t\tretval = tree_entry_interesting(&entry, base, 0, pathspec);\n\t\t\tif (retval == all_entries_not_interesting)\n\t\t\t\tbreak;\n\t\t\tif (retval == entry_not_interesting)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (fn(entry.oid->hash, base,\n\t\t\t   entry.path, entry.mode, stage, context)) {\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tcase READ_TREE_RECURSIVE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (S_ISDIR(entry.mode))\n\t\t\thashcpy(sha1, entry.oid->hash);\n\t\telse if (S_ISGITLINK(entry.mode)) {\n\t\t\tstruct commit *commit;\n\n\t\t\tcommit = lookup_commit(entry.oid->hash);\n\t\t\tif (!commit)\n\t\t\t\tdie(\"Commit %s in submodule path %s%s not found\",\n\t\t\t\t    oid_to_hex(entry.oid),\n\t\t\t\t    base->buf, entry.path);\n\n\t\t\tif (parse_commit(commit))\n\t\t\t\tdie(\"Invalid commit %s in submodule path %s%s\",\n\t\t\t\t    oid_to_hex(entry.oid),\n\t\t\t\t    base->buf, entry.path);\n\n\t\t\thashcpy(sha1, commit->tree->object.oid.hash);\n\t\t}\n\t\telse\n\t\t\tcontinue;\n\n\t\tlen = tree_entry_len(&entry);\n\t\tstrbuf_add(base, entry.path, len);\n\t\tstrbuf_addch(base, '/');\n\t\tretval = read_tree_1(lookup_tree(sha1),\n\t\t\t\t     base, stage, pathspec,\n\t\t\t\t     fn, context);\n\t\tstrbuf_setlen(base, oldlen);\n\t\tif (retval)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint read_tree_recursive(struct tree *tree,\n\t\t\tconst char *base, int baselen,\n\t\t\tint stage, const struct pathspec *pathspec,\n\t\t\tread_tree_fn_t fn, void *context)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tint ret;\n\n\tstrbuf_add(&sb, base, baselen);\n\tret = read_tree_1(tree, &sb, stage, pathspec, fn, context);\n\tstrbuf_release(&sb);\n\treturn ret;\n}\n\nstatic int cmp_cache_name_compare(const void *a_, const void *b_)\n{\n\tconst struct cache_entry *ce1, *ce2;\n\n\tce1 = *((const struct cache_entry **)a_);\n\tce2 = *((const struct cache_entry **)b_);\n\treturn cache_name_stage_compare(ce1->name, ce1->ce_namelen, ce_stage(ce1),\n\t\t\t\t  ce2->name, ce2->ce_namelen, ce_stage(ce2));\n}\n\nint read_tree(struct tree *tree, int stage, struct pathspec *match)\n{\n\tread_tree_fn_t fn = NULL;\n\tint i, err;\n\n\t/*\n\t * Currently the only existing callers of this function all\n\t * call it with stage=1 and after making sure there is nothing\n\t * at that stage; we could always use read_one_entry_quick().\n\t *\n\t * But when we decide to straighten out git-read-tree not to\n\t * use unpack_trees() in some cases, this will probably start\n\t * to matter.\n\t */\n\n\t/*\n\t * See if we have cache entry at the stage.  If so,\n\t * do it the original slow way, otherwise, append and then\n\t * sort at the end.\n\t */\n\tfor (i = 0; !fn && i < active_nr; i++) {\n\t\tconst struct cache_entry *ce = active_cache[i];\n\t\tif (ce_stage(ce) == stage)\n\t\t\tfn = read_one_entry;\n\t}\n\n\tif (!fn)\n\t\tfn = read_one_entry_quick;\n\terr = read_tree_recursive(tree, \"\", 0, stage, match, fn, NULL);\n\tif (fn == read_one_entry || err)\n\t\treturn err;\n\n\t/*\n\t * Sort the cache entry -- we need to nuke the cache tree, though.\n\t */\n\tcache_tree_free(&active_cache_tree);\n\tqsort(active_cache, active_nr, sizeof(active_cache[0]),\n\t      cmp_cache_name_compare);\n\treturn 0;\n}\n\nstruct tree *lookup_tree(const unsigned char *sha1)\n{\n\tstruct object *obj = lookup_object(sha1);\n\tif (!obj)\n\t\treturn create_object(sha1, alloc_tree_node());\n\treturn object_as_type(obj, OBJ_TREE, 0);\n}\n\nint parse_tree_buffer(struct tree *item, void *buffer, unsigned long size)\n{\n\tif (item->object.parsed)\n\t\treturn 0;\n\titem->object.parsed = 1;\n\titem->buffer = buffer;\n\titem->size = size;\n\n\treturn 0;\n}\n\nint parse_tree_gently(struct tree *item, int quiet_on_missing)\n{\n\t enum object_type type;\n\t void *buffer;\n\t unsigned long size;\n\n\tif (item->object.parsed)\n\t\treturn 0;\n\tbuffer = read_sha1_file(item->object.oid.hash, &type, &size);\n\tif (!buffer)\n\t\treturn quiet_on_missing ? -1 :\n\t\t\terror(\"Could not read %s\",\n\t\t\t     oid_to_hex(&item->object.oid));\n\tif (type != OBJ_TREE) {\n\t\tfree(buffer);\n\t\treturn error(\"Object %s not a tree\",\n\t\t\t     oid_to_hex(&item->object.oid));\n\t}\n\treturn parse_tree_buffer(item, buffer, size);\n}\n\nvoid free_tree_buffer(struct tree *tree)\n{\n\tfree(tree->buffer);\n\ttree->buffer = NULL;\n\ttree->size = 0;\n\ttree->object.parsed = 0;\n}\n\nstruct tree *parse_tree_indirect(const unsigned char *sha1)\n{\n\tstruct object *obj = parse_object(sha1);\n\tdo {\n\t\tif (!obj)\n\t\t\treturn NULL;\n\t\tif (obj->type == OBJ_TREE)\n\t\t\treturn (struct tree *) obj;\n\t\telse if (obj->type == OBJ_COMMIT)\n\t\t\tobj = &(((struct commit *) obj)->tree->object);\n\t\telse if (obj->type == OBJ_TAG)\n\t\t\tobj = ((struct tag *) obj)->tagged;\n\t\telse\n\t\t\treturn NULL;\n\t\tif (!obj->parsed)\n\t\t\tparse_object(obj->oid.hash);\n\t} while (1);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0089e52d9dff41bece11056e92625b923515c462",
  "sha1_ok": true,
  "size": 6377
}
