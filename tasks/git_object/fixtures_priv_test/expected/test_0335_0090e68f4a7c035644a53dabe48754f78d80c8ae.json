{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgInJlbW90ZS5oIgojaW5jbHVkZSAiY29ubmVjdC5oIgojaW5jbHVkZSAic3RyYnVmLmgiCiNpbmNsdWRlICJ3YWxrZXIuaCIKI2luY2x1ZGUgImh0dHAuaCIKI2luY2x1ZGUgImV4ZWMtY21kLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAicGt0LWxpbmUuaCIKI2luY2x1ZGUgInN0cmluZy1saXN0LmgiCiNpbmNsdWRlICJzaWRlYmFuZC5oIgojaW5jbHVkZSAiYXJndi1hcnJheS5oIgojaW5jbHVkZSAiY3JlZGVudGlhbC5oIgojaW5jbHVkZSAib2lkLWFycmF5LmgiCiNpbmNsdWRlICJzZW5kLXBhY2suaCIKI2luY2x1ZGUgInByb3RvY29sLmgiCiNpbmNsdWRlICJxdW90ZS5oIgojaW5jbHVkZSAidHJhbnNwb3J0LmgiCgpzdGF0aWMgc3RydWN0IHJlbW90ZSAqcmVtb3RlOwovKiBhbHdheXMgZW5kcyB3aXRoIGEgdHJhaWxpbmcgc2xhc2ggKi8Kc3RhdGljIHN0cnVjdCBzdHJidWYgdXJsID0gU1RSQlVGX0lOSVQ7CgpzdHJ1Y3Qgb3B0aW9ucyB7CglpbnQgdmVyYm9zaXR5OwoJdW5zaWduZWQgbG9uZyBkZXB0aDsKCWNoYXIgKmRlZXBlbl9zaW5jZTsKCXN0cnVjdCBzdHJpbmdfbGlzdCBkZWVwZW5fbm90OwoJc3RydWN0IHN0cmluZ19saXN0IHB1c2hfb3B0aW9uczsKCWNoYXIgKmZpbHRlcjsKCXVuc2lnbmVkIHByb2dyZXNzIDogMSwKCQljaGVja19zZWxmX2NvbnRhaW5lZF9hbmRfY29ubmVjdGVkIDogMSwKCQljbG9uaW5nIDogMSwKCQl1cGRhdGVfc2hhbGxvdyA6IDEsCgkJZm9sbG93dGFncyA6IDEsCgkJZHJ5X3J1biA6IDEsCgkJdGhpbiA6IDEsCgkJLyogT25lIG9mIHRoZSBTRU5EX1BBQ0tfUFVTSF9DRVJUXyogY29uc3RhbnRzLiAqLwoJCXB1c2hfY2VydCA6IDIsCgkJZGVlcGVuX3JlbGF0aXZlIDogMSwKCQlmcm9tX3Byb21pc29yIDogMSwKCQlub19kZXBlbmRlbnRzIDogMSwKCQlhdG9taWMgOiAxLAoJCW9iamVjdF9mb3JtYXQgOiAxOwoJY29uc3Qgc3RydWN0IGdpdF9oYXNoX2FsZ28gKmhhc2hfYWxnbzsKfTsKc3RhdGljIHN0cnVjdCBvcHRpb25zIG9wdGlvbnM7CnN0YXRpYyBzdHJ1Y3Qgc3RyaW5nX2xpc3QgY2FzX29wdGlvbnMgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCnN0YXRpYyBpbnQgc2V0X29wdGlvbihjb25zdCBjaGFyICpuYW1lLCBjb25zdCBjaGFyICp2YWx1ZSkKewoJaWYgKCFzdHJjbXAobmFtZSwgInZlcmJvc2l0eSIpKSB7CgkJY2hhciAqZW5kOwoJCWludCB2ID0gc3RydG9sKHZhbHVlLCAmZW5kLCAxMCk7CgkJaWYgKHZhbHVlID09IGVuZCB8fCAqZW5kKQoJCQlyZXR1cm4gLTE7CgkJb3B0aW9ucy52ZXJib3NpdHkgPSB2OwoJCXJldHVybiAwOwoJfQoJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAicHJvZ3Jlc3MiKSkgewoJCWlmICghc3RyY21wKHZhbHVlLCAidHJ1ZSIpKQoJCQlvcHRpb25zLnByb2dyZXNzID0gMTsKCQllbHNlIGlmICghc3RyY21wKHZhbHVlLCAiZmFsc2UiKSkKCQkJb3B0aW9ucy5wcm9ncmVzcyA9IDA7CgkJZWxzZQoJCQlyZXR1cm4gLTE7CgkJcmV0dXJuIDA7Cgl9CgllbHNlIGlmICghc3RyY21wKG5hbWUsICJkZXB0aCIpKSB7CgkJY2hhciAqZW5kOwoJCXVuc2lnbmVkIGxvbmcgdiA9IHN0cnRvdWwodmFsdWUsICZlbmQsIDEwKTsKCQlpZiAodmFsdWUgPT0gZW5kIHx8ICplbmQpCgkJCXJldHVybiAtMTsKCQlvcHRpb25zLmRlcHRoID0gdjsKCQlyZXR1cm4gMDsKCX0KCWVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImRlZXBlbi1zaW5jZSIpKSB7CgkJb3B0aW9ucy5kZWVwZW5fc2luY2UgPSB4c3RyZHVwKHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCWVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImRlZXBlbi1ub3QiKSkgewoJCXN0cmluZ19saXN0X2FwcGVuZCgmb3B0aW9ucy5kZWVwZW5fbm90LCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CgllbHNlIGlmICghc3RyY21wKG5hbWUsICJkZWVwZW4tcmVsYXRpdmUiKSkgewoJCWlmICghc3RyY21wKHZhbHVlLCAidHJ1ZSIpKQoJCQlvcHRpb25zLmRlZXBlbl9yZWxhdGl2ZSA9IDE7CgkJZWxzZSBpZiAoIXN0cmNtcCh2YWx1ZSwgImZhbHNlIikpCgkJCW9wdGlvbnMuZGVlcGVuX3JlbGF0aXZlID0gMDsKCQllbHNlCgkJCXJldHVybiAtMTsKCQlyZXR1cm4gMDsKCX0KCWVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImZvbGxvd3RhZ3MiKSkgewoJCWlmICghc3RyY21wKHZhbHVlLCAidHJ1ZSIpKQoJCQlvcHRpb25zLmZvbGxvd3RhZ3MgPSAxOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJmYWxzZSIpKQoJCQlvcHRpb25zLmZvbGxvd3RhZ3MgPSAwOwoJCWVsc2UKCQkJcmV0dXJuIC0xOwoJCXJldHVybiAwOwoJfQoJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiZHJ5LXJ1biIpKSB7CgkJaWYgKCFzdHJjbXAodmFsdWUsICJ0cnVlIikpCgkJCW9wdGlvbnMuZHJ5X3J1biA9IDE7CgkJZWxzZSBpZiAoIXN0cmNtcCh2YWx1ZSwgImZhbHNlIikpCgkJCW9wdGlvbnMuZHJ5X3J1biA9IDA7CgkJZWxzZQoJCQlyZXR1cm4gLTE7CgkJcmV0dXJuIDA7Cgl9CgllbHNlIGlmICghc3RyY21wKG5hbWUsICJjaGVjay1jb25uZWN0aXZpdHkiKSkgewoJCWlmICghc3RyY21wKHZhbHVlLCAidHJ1ZSIpKQoJCQlvcHRpb25zLmNoZWNrX3NlbGZfY29udGFpbmVkX2FuZF9jb25uZWN0ZWQgPSAxOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJmYWxzZSIpKQoJCQlvcHRpb25zLmNoZWNrX3NlbGZfY29udGFpbmVkX2FuZF9jb25uZWN0ZWQgPSAwOwoJCWVsc2UKCQkJcmV0dXJuIC0xOwoJCXJldHVybiAwOwoJfQoJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiY2FzIikpIHsKCQlzdHJ1Y3Qgc3RyYnVmIHZhbCA9IFNUUkJVRl9JTklUOwoJCXN0cmJ1Zl9hZGRmKCZ2YWwsICItLSIgQ0FTX09QVF9OQU1FICI9JXMiLCB2YWx1ZSk7CgkJc3RyaW5nX2xpc3RfYXBwZW5kKCZjYXNfb3B0aW9ucywgdmFsLmJ1Zik7CgkJc3RyYnVmX3JlbGVhc2UoJnZhbCk7CgkJcmV0dXJuIDA7Cgl9IGVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImNsb25pbmciKSkgewoJCWlmICghc3RyY21wKHZhbHVlLCAidHJ1ZSIpKQoJCQlvcHRpb25zLmNsb25pbmcgPSAxOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJmYWxzZSIpKQoJCQlvcHRpb25zLmNsb25pbmcgPSAwOwoJCWVsc2UKCQkJcmV0dXJuIC0xOwoJCXJldHVybiAwOwoJfSBlbHNlIGlmICghc3RyY21wKG5hbWUsICJ1cGRhdGUtc2hhbGxvdyIpKSB7CgkJaWYgKCFzdHJjbXAodmFsdWUsICJ0cnVlIikpCgkJCW9wdGlvbnMudXBkYXRlX3NoYWxsb3cgPSAxOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJmYWxzZSIpKQoJCQlvcHRpb25zLnVwZGF0ZV9zaGFsbG93ID0gMDsKCQllbHNlCgkJCXJldHVybiAtMTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAicHVzaGNlcnQiKSkgewoJCWlmICghc3RyY21wKHZhbHVlLCAidHJ1ZSIpKQoJCQlvcHRpb25zLnB1c2hfY2VydCA9IFNFTkRfUEFDS19QVVNIX0NFUlRfQUxXQVlTOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJmYWxzZSIpKQoJCQlvcHRpb25zLnB1c2hfY2VydCA9IFNFTkRfUEFDS19QVVNIX0NFUlRfTkVWRVI7CgkJZWxzZSBpZiAoIXN0cmNtcCh2YWx1ZSwgImlmLWFza2VkIikpCgkJCW9wdGlvbnMucHVzaF9jZXJ0ID0gU0VORF9QQUNLX1BVU0hfQ0VSVF9JRl9BU0tFRDsKCQllbHNlCgkJCXJldHVybiAtMTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiYXRvbWljIikpIHsKCQlpZiAoIXN0cmNtcCh2YWx1ZSwgInRydWUiKSkKCQkJb3B0aW9ucy5hdG9taWMgPSAxOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJmYWxzZSIpKQoJCQlvcHRpb25zLmF0b21pYyA9IDA7CgkJZWxzZQoJCQlyZXR1cm4gLTE7CgkJcmV0dXJuIDA7Cgl9IGVsc2UgaWYgKCFzdHJjbXAobmFtZSwgInB1c2gtb3B0aW9uIikpIHsKCQlpZiAoKnZhbHVlICE9ICciJykKCQkJc3RyaW5nX2xpc3RfYXBwZW5kKCZvcHRpb25zLnB1c2hfb3B0aW9ucywgdmFsdWUpOwoJCWVsc2UgewoJCQlzdHJ1Y3Qgc3RyYnVmIHVucXVvdGVkID0gU1RSQlVGX0lOSVQ7CgkJCWlmICh1bnF1b3RlX2Nfc3R5bGUoJnVucXVvdGVkLCB2YWx1ZSwgTlVMTCkgPCAwKQoJCQkJZGllKF8oImludmFsaWQgcXVvdGluZyBpbiBwdXNoLW9wdGlvbiB2YWx1ZTogJyVzJyIpLCB2YWx1ZSk7CgkJCXN0cmluZ19saXN0X2FwcGVuZF9ub2R1cCgmb3B0aW9ucy5wdXNoX29wdGlvbnMsCgkJCQkJCSBzdHJidWZfZGV0YWNoKCZ1bnF1b3RlZCwgTlVMTCkpOwoJCX0KCQlyZXR1cm4gMDsKCiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwYTA4Cgl9IGVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImZhbWlseSIpKSB7CgkJaWYgKCFzdHJjbXAodmFsdWUsICJpcHY0IikpCgkJCWdpdF9jdXJsX2lwcmVzb2x2ZSA9IENVUkxfSVBSRVNPTFZFX1Y0OwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJpcHY2IikpCgkJCWdpdF9jdXJsX2lwcmVzb2x2ZSA9IENVUkxfSVBSRVNPTFZFX1Y2OwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJhbGwiKSkKCQkJZ2l0X2N1cmxfaXByZXNvbHZlID0gQ1VSTF9JUFJFU09MVkVfV0hBVEVWRVI7CgkJZWxzZQoJCQlyZXR1cm4gLTE7CgkJcmV0dXJuIDA7CiNlbmRpZiAvKiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwYTA4ICovCgl9IGVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImZyb20tcHJvbWlzb3IiKSkgewoJCW9wdGlvbnMuZnJvbV9wcm9taXNvciA9IDE7CgkJcmV0dXJuIDA7Cgl9IGVsc2UgaWYgKCFzdHJjbXAobmFtZSwgIm5vLWRlcGVuZGVudHMiKSkgewoJCW9wdGlvbnMubm9fZGVwZW5kZW50cyA9IDE7CgkJcmV0dXJuIDA7Cgl9IGVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImZpbHRlciIpKSB7CgkJb3B0aW9ucy5maWx0ZXIgPSB4c3RyZHVwKHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAib2JqZWN0LWZvcm1hdCIpKSB7CgkJaW50IGFsZ287CgkJb3B0aW9ucy5vYmplY3RfZm9ybWF0ID0gMTsKCQlpZiAoc3RyY21wKHZhbHVlLCAidHJ1ZSIpKSB7CgkJCWFsZ28gPSBoYXNoX2FsZ29fYnlfbmFtZSh2YWx1ZSk7CgkJCWlmIChhbGdvID09IEdJVF9IQVNIX1VOS05PV04pCgkJCQlkaWUoInVua25vd24gb2JqZWN0IGZvcm1hdCAnJXMnIiwgdmFsdWUpOwoJCQlvcHRpb25zLmhhc2hfYWxnbyA9ICZoYXNoX2FsZ29zW2FsZ29dOwoJCX0KCQlyZXR1cm4gMDsKCX0gZWxzZSB7CgkJcmV0dXJuIDEgLyogdW5zdXBwb3J0ZWQgKi87Cgl9Cn0KCnN0cnVjdCBkaXNjb3ZlcnkgewoJY2hhciAqc2VydmljZTsKCWNoYXIgKmJ1Zl9hbGxvYzsKCWNoYXIgKmJ1ZjsKCXNpemVfdCBsZW47CglzdHJ1Y3QgcmVmICpyZWZzOwoJc3RydWN0IG9pZF9hcnJheSBzaGFsbG93OwoJZW51bSBwcm90b2NvbF92ZXJzaW9uIHZlcnNpb247Cgl1bnNpZ25lZCBwcm90b19naXQgOiAxOwp9OwpzdGF0aWMgc3RydWN0IGRpc2NvdmVyeSAqbGFzdF9kaXNjb3Zlcnk7CgpzdGF0aWMgc3RydWN0IHJlZiAqcGFyc2VfZ2l0X3JlZnMoc3RydWN0IGRpc2NvdmVyeSAqaGVhZHMsIGludCBmb3JfcHVzaCkKewoJc3RydWN0IHJlZiAqbGlzdCA9IE5VTEw7CglzdHJ1Y3QgcGFja2V0X3JlYWRlciByZWFkZXI7CgoJcGFja2V0X3JlYWRlcl9pbml0KCZyZWFkZXIsIC0xLCBoZWFkcy0+YnVmLCBoZWFkcy0+bGVuLAoJCQkgICBQQUNLRVRfUkVBRF9DSE9NUF9ORVdMSU5FIHwKCQkJICAgUEFDS0VUX1JFQURfR0VOVExFX09OX0VPRiB8CgkJCSAgIFBBQ0tFVF9SRUFEX0RJRV9PTl9FUlJfUEFDS0VUKTsKCgloZWFkcy0+dmVyc2lvbiA9IGRpc2NvdmVyX3ZlcnNpb24oJnJlYWRlcik7Cglzd2l0Y2ggKGhlYWRzLT52ZXJzaW9uKSB7CgljYXNlIHByb3RvY29sX3YyOgoJCS8qCgkJICogRG8gbm90aGluZy4gIFRoaXMgaXNuJ3QgYSBsaXN0IG9mIHJlZnMgYnV0IHJhdGhlciBhCgkJICogY2FwYWJpbGl0eSBhZHZlcnRpc2VtZW50LiAgQ2xpZW50IHdvdWxkIGhhdmUgcnVuCgkJICogJ3N0YXRlbGVzcy1jb25uZWN0JyBzbyB3ZSdsbCBkdW1wIHRoaXMgY2FwYWJpbGl0eSBsaXN0aW5nCgkJICogYW5kIGxldCB0aGVtIHJlcXVlc3QgdGhlIHJlZnMgdGhlbXNlbHZlcy4KCQkgKi8KCQlicmVhazsKCWNhc2UgcHJvdG9jb2xfdjE6CgljYXNlIHByb3RvY29sX3YwOgoJCWdldF9yZW1vdGVfaGVhZHMoJnJlYWRlciwgJmxpc3QsIGZvcl9wdXNoID8gUkVGX05PUk1BTCA6IDAsCgkJCQkgTlVMTCwgJmhlYWRzLT5zaGFsbG93KTsKCQlvcHRpb25zLmhhc2hfYWxnbyA9IHJlYWRlci5oYXNoX2FsZ287CgkJYnJlYWs7CgljYXNlIHByb3RvY29sX3Vua25vd25fdmVyc2lvbjoKCQlCVUcoInVua25vd24gcHJvdG9jb2wgdmVyc2lvbiIpOwoJfQoKCXJldHVybiBsaXN0Owp9CgpzdGF0aWMgY29uc3Qgc3RydWN0IGdpdF9oYXNoX2FsZ28gKmRldGVjdF9oYXNoX2FsZ28oc3RydWN0IGRpc2NvdmVyeSAqaGVhZHMpCnsKCWNvbnN0IGNoYXIgKnAgPSBtZW1jaHIoaGVhZHMtPmJ1ZiwgJ1x0JywgaGVhZHMtPmxlbik7CglpbnQgYWxnbzsKCWlmICghcCkKCQlyZXR1cm4gdGhlX2hhc2hfYWxnbzsKCglhbGdvID0gaGFzaF9hbGdvX2J5X2xlbmd0aCgocCAtIGhlYWRzLT5idWYpIC8gMik7CglpZiAoYWxnbyA9PSBHSVRfSEFTSF9VTktOT1dOKQoJCXJldHVybiBOVUxMOwoJcmV0dXJuICZoYXNoX2FsZ29zW2FsZ29dOwp9CgpzdGF0aWMgc3RydWN0IHJlZiAqcGFyc2VfaW5mb19yZWZzKHN0cnVjdCBkaXNjb3ZlcnkgKmhlYWRzKQp7CgljaGFyICpkYXRhLCAqc3RhcnQsICptaWQ7CgljaGFyICpyZWZfbmFtZTsKCWludCBpID0gMDsKCglzdHJ1Y3QgcmVmICpyZWZzID0gTlVMTDsKCXN0cnVjdCByZWYgKnJlZiA9IE5VTEw7CglzdHJ1Y3QgcmVmICpsYXN0X3JlZiA9IE5VTEw7CgoJb3B0aW9ucy5oYXNoX2FsZ28gPSBkZXRlY3RfaGFzaF9hbGdvKGhlYWRzKTsKCWlmICghb3B0aW9ucy5oYXNoX2FsZ28pCgkJZGllKCIlc2luZm8vcmVmcyBub3QgdmFsaWQ6IGNvdWxkIG5vdCBkZXRlcm1pbmUgaGFzaCBhbGdvcml0aG07ICIKCQkgICAgImlzIHRoaXMgYSBnaXQgcmVwb3NpdG9yeT8iLAoJCSAgICB0cmFuc3BvcnRfYW5vbnltaXplX3VybCh1cmwuYnVmKSk7CgoJZGF0YSA9IGhlYWRzLT5idWY7CglzdGFydCA9IE5VTEw7CgltaWQgPSBkYXRhOwoJd2hpbGUgKGkgPCBoZWFkcy0+bGVuKSB7CgkJaWYgKCFzdGFydCkgewoJCQlzdGFydCA9ICZkYXRhW2ldOwoJCX0KCQlpZiAoZGF0YVtpXSA9PSAnXHQnKQoJCQltaWQgPSAmZGF0YVtpXTsKCQlpZiAoZGF0YVtpXSA9PSAnXG4nKSB7CgkJCWlmIChtaWQgLSBzdGFydCAhPSBvcHRpb25zLmhhc2hfYWxnby0+aGV4c3opCgkJCQlkaWUoXygiJXNpbmZvL3JlZnMgbm90IHZhbGlkOiBpcyB0aGlzIGEgZ2l0IHJlcG9zaXRvcnk/IiksCgkJCQkgICAgdHJhbnNwb3J0X2Fub255bWl6ZV91cmwodXJsLmJ1ZikpOwoJCQlkYXRhW2ldID0gMDsKCQkJcmVmX25hbWUgPSBtaWQgKyAxOwoJCQlyZWYgPSBhbGxvY19yZWYocmVmX25hbWUpOwoJCQlnZXRfb2lkX2hleF9hbGdvcChzdGFydCwgJnJlZi0+b2xkX29pZCwgb3B0aW9ucy5oYXNoX2FsZ28pOwoJCQlpZiAoIXJlZnMpCgkJCQlyZWZzID0gcmVmOwoJCQlpZiAobGFzdF9yZWYpCgkJCQlsYXN0X3JlZi0+bmV4dCA9IHJlZjsKCQkJbGFzdF9yZWYgPSByZWY7CgkJCXN0YXJ0ID0gTlVMTDsKCQl9CgkJaSsrOwoJfQoKCXJlZiA9IGFsbG9jX3JlZigiSEVBRCIpOwoJaWYgKCFodHRwX2ZldGNoX3JlZih1cmwuYnVmLCByZWYpICYmCgkgICAgIXJlc29sdmVfcmVtb3RlX3N5bXJlZihyZWYsIHJlZnMpKSB7CgkJcmVmLT5uZXh0ID0gcmVmczsKCQlyZWZzID0gcmVmOwoJfSBlbHNlIHsKCQlmcmVlKHJlZik7Cgl9CgoJcmV0dXJuIHJlZnM7Cn0KCnN0YXRpYyB2b2lkIGZyZWVfZGlzY292ZXJ5KHN0cnVjdCBkaXNjb3ZlcnkgKmQpCnsKCWlmIChkKSB7CgkJaWYgKGQgPT0gbGFzdF9kaXNjb3ZlcnkpCgkJCWxhc3RfZGlzY292ZXJ5ID0gTlVMTDsKCQlmcmVlKGQtPnNoYWxsb3cub2lkKTsKCQlmcmVlKGQtPmJ1Zl9hbGxvYyk7CgkJZnJlZV9yZWZzKGQtPnJlZnMpOwoJCWZyZWUoZC0+c2VydmljZSk7CgkJZnJlZShkKTsKCX0KfQoKc3RhdGljIGludCBzaG93X2h0dHBfbWVzc2FnZShzdHJ1Y3Qgc3RyYnVmICp0eXBlLCBzdHJ1Y3Qgc3RyYnVmICpjaGFyc2V0LAoJCQkgICAgIHN0cnVjdCBzdHJidWYgKm1zZykKewoJY29uc3QgY2hhciAqcCwgKmVvbDsKCgkvKgoJICogV2Ugb25seSBzaG93IHRleHQvcGxhaW4gcGFydHMsIGFzIG90aGVyIHR5cGVzIGFyZSBsaWtlbHkKCSAqIHRvIGJlIHVnbHkgdG8gbG9vayBhdCBvbiB0aGUgdXNlcidzIHRlcm1pbmFsLgoJICovCglpZiAoc3RyY21wKHR5cGUtPmJ1ZiwgInRleHQvcGxhaW4iKSkKCQlyZXR1cm4gLTE7CglpZiAoY2hhcnNldC0+bGVuKQoJCXN0cmJ1Zl9yZWVuY29kZShtc2csIGNoYXJzZXQtPmJ1ZiwgZ2V0X2xvZ19vdXRwdXRfZW5jb2RpbmcoKSk7CgoJc3RyYnVmX3RyaW0obXNnKTsKCWlmICghbXNnLT5sZW4pCgkJcmV0dXJuIC0xOwoKCXAgPSBtc2ctPmJ1ZjsKCWRvIHsKCQllb2wgPSBzdHJjaHJudWwocCwgJ1xuJyk7CgkJZnByaW50ZihzdGRlcnIsICJyZW1vdGU6ICUuKnNcbiIsIChpbnQpKGVvbCAtIHApLCBwKTsKCQlwID0gZW9sICsgMTsKCX0gd2hpbGUoKmVvbCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBnZXRfcHJvdG9jb2xfaHR0cF9oZWFkZXIoZW51bSBwcm90b2NvbF92ZXJzaW9uIHZlcnNpb24sCgkJCQkgICAgc3RydWN0IHN0cmJ1ZiAqaGVhZGVyKQp7CglpZiAodmVyc2lvbiA+IDApIHsKCQlzdHJidWZfYWRkZihoZWFkZXIsIEdJVF9QUk9UT0NPTF9IRUFERVIgIjogdmVyc2lvbj0lZCIsCgkJCSAgICB2ZXJzaW9uKTsKCgkJcmV0dXJuIDE7Cgl9CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGNoZWNrX3NtYXJ0X2h0dHAoc3RydWN0IGRpc2NvdmVyeSAqZCwgY29uc3QgY2hhciAqc2VydmljZSwKCQkJICAgICBzdHJ1Y3Qgc3RyYnVmICp0eXBlKQp7Cgljb25zdCBjaGFyICpwOwoJc3RydWN0IHBhY2tldF9yZWFkZXIgcmVhZGVyOwoKCS8qCgkgKiBJZiB3ZSBkb24ndCBzZWUgeC0kc2VydmljZS1hZHZlcnRpc2VtZW50LCB0aGVuIGl0J3Mgbm90IHNtYXJ0LWh0dHAuCgkgKiBCdXQgb25jZSB3ZSBkbywgd2UgY29tbWl0IHRvIGl0IGFuZCBhc3N1bWUgYW55IG90aGVyIHByb3RvY29sCgkgKiB2aW9sYXRpb25zIGFyZSBoYXJkIGVycm9ycy4KCSAqLwoJaWYgKCFza2lwX3ByZWZpeCh0eXBlLT5idWYsICJhcHBsaWNhdGlvbi94LSIsICZwKSB8fAoJICAgICFza2lwX3ByZWZpeChwLCBzZXJ2aWNlLCAmcCkgfHwKCSAgICBzdHJjbXAocCwgIi1hZHZlcnRpc2VtZW50IikpCgkJcmV0dXJuOwoKCXBhY2tldF9yZWFkZXJfaW5pdCgmcmVhZGVyLCAtMSwgZC0+YnVmLCBkLT5sZW4sCgkJCSAgIFBBQ0tFVF9SRUFEX0NIT01QX05FV0xJTkUgfAoJCQkgICBQQUNLRVRfUkVBRF9ESUVfT05fRVJSX1BBQ0tFVCk7CglpZiAocGFja2V0X3JlYWRlcl9yZWFkKCZyZWFkZXIpICE9IFBBQ0tFVF9SRUFEX05PUk1BTCkKCQlkaWUoXygiaW52YWxpZCBzZXJ2ZXIgcmVzcG9uc2U7IGV4cGVjdGVkIHNlcnZpY2UsIGdvdCBmbHVzaCBwYWNrZXQiKSk7CgoJaWYgKHNraXBfcHJlZml4KHJlYWRlci5saW5lLCAiIyBzZXJ2aWNlPSIsICZwKSAmJiAhc3RyY21wKHAsIHNlcnZpY2UpKSB7CgkJLyoKCQkgKiBUaGUgaGVhZGVyIGNhbiBpbmNsdWRlIGFkZGl0aW9uYWwgbWV0YWRhdGEgbGluZXMsIHVwCgkJICogdW50aWwgYSBwYWNrZXQgZmx1c2ggbWFya2VyLiAgSWdub3JlIHRoZXNlIG5vdywgYnV0CgkJICogaW4gdGhlIGZ1dHVyZSB3ZSBtaWdodCBzdGFydCB0byBzY2FuIHRoZW0uCgkJICovCgkJZm9yICg7OykgewoJCQlwYWNrZXRfcmVhZGVyX3JlYWQoJnJlYWRlcik7CgkJCWlmIChyZWFkZXIucGt0bGVuIDw9IDApIHsKCQkJCWJyZWFrOwoJCQl9CgkJfQoKCQkvKgoJCSAqIHYwIHNtYXJ0IGh0dHA7IGNhbGxlcnMgZXhwZWN0IHVzIHRvIHNvYWsgdXAgdGhlCgkJICogc2VydmljZSBhbmQgaGVhZGVyIHBhY2tldHMKCQkgKi8KCQlkLT5idWYgPSByZWFkZXIuc3JjX2J1ZmZlcjsKCQlkLT5sZW4gPSByZWFkZXIuc3JjX2xlbjsKCQlkLT5wcm90b19naXQgPSAxOwoKCX0gZWxzZSBpZiAoIXN0cmNtcChyZWFkZXIubGluZSwgInZlcnNpb24gMiIpKSB7CgkJLyoKCQkgKiB2MiBzbWFydCBodHRwOyBkbyBub3QgY29uc3VtZSB2ZXJzaW9uIHBhY2tldCwgd2hpY2ggd2lsbAoJCSAqIGJlIGhhbmRsZWQgZWxzZXdoZXJlLgoJCSAqLwoJCWQtPnByb3RvX2dpdCA9IDE7CgoJfSBlbHNlIHsKCQlkaWUoXygiaW52YWxpZCBzZXJ2ZXIgcmVzcG9uc2U7IGdvdCAnJXMnIiksIHJlYWRlci5saW5lKTsKCX0KfQoKc3RhdGljIHN0cnVjdCBkaXNjb3ZlcnkgKmRpc2NvdmVyX3JlZnMoY29uc3QgY2hhciAqc2VydmljZSwgaW50IGZvcl9wdXNoKQp7CglzdHJ1Y3Qgc3RyYnVmIHR5cGUgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgY2hhcnNldCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBidWZmZXIgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgcmVmc191cmwgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgZWZmZWN0aXZlX3VybCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBwcm90b2NvbF9oZWFkZXIgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJpbmdfbGlzdCBleHRyYV9oZWFkZXJzID0gU1RSSU5HX0xJU1RfSU5JVF9EVVA7CglzdHJ1Y3QgZGlzY292ZXJ5ICpsYXN0ID0gbGFzdF9kaXNjb3Zlcnk7CglpbnQgaHR0cF9yZXQsIG1heWJlX3NtYXJ0ID0gMDsKCXN0cnVjdCBodHRwX2dldF9vcHRpb25zIGh0dHBfb3B0aW9uczsKCWVudW0gcHJvdG9jb2xfdmVyc2lvbiB2ZXJzaW9uID0gZ2V0X3Byb3RvY29sX3ZlcnNpb25fY29uZmlnKCk7CgoJaWYgKGxhc3QgJiYgIXN0cmNtcChzZXJ2aWNlLCBsYXN0LT5zZXJ2aWNlKSkKCQlyZXR1cm4gbGFzdDsKCWZyZWVfZGlzY292ZXJ5KGxhc3QpOwoKCXN0cmJ1Zl9hZGRmKCZyZWZzX3VybCwgIiVzaW5mby9yZWZzIiwgdXJsLmJ1Zik7CglpZiAoKHN0YXJ0c193aXRoKHVybC5idWYsICJodHRwOi8vIikgfHwgc3RhcnRzX3dpdGgodXJsLmJ1ZiwgImh0dHBzOi8vIikpICYmCgkgICAgIGdpdF9lbnZfYm9vbCgiR0lUX1NNQVJUX0hUVFAiLCAxKSkgewoJCW1heWJlX3NtYXJ0ID0gMTsKCQlpZiAoIXN0cmNocih1cmwuYnVmLCAnPycpKQoJCQlzdHJidWZfYWRkY2goJnJlZnNfdXJsLCAnPycpOwoJCWVsc2UKCQkJc3RyYnVmX2FkZGNoKCZyZWZzX3VybCwgJyYnKTsKCQlzdHJidWZfYWRkZigmcmVmc191cmwsICJzZXJ2aWNlPSVzIiwgc2VydmljZSk7Cgl9CgoJLyoKCSAqIE5FRURTV09SSzogSWYgd2UgYXJlIHRyeWluZyB0byB1c2UgcHJvdG9jb2wgdjIgYW5kIHdlIGFyZSBwbGFubmluZwoJICogdG8gcGVyZm9ybSBhIHB1c2gsIHRoZW4gZmFsbGJhY2sgdG8gdjAgc2luY2UgdGhlIGNsaWVudCBkb2Vzbid0IGtub3cKCSAqIGhvdyB0byBwdXNoIHlldCB1c2luZyB2Mi4KCSAqLwoJaWYgKHZlcnNpb24gPT0gcHJvdG9jb2xfdjIgJiYgIXN0cmNtcCgiZ2l0LXJlY2VpdmUtcGFjayIsIHNlcnZpY2UpKQoJCXZlcnNpb24gPSBwcm90b2NvbF92MDsKCgkvKiBBZGQgdGhlIGV4dHJhIEdpdC1Qcm90b2NvbCBoZWFkZXIgKi8KCWlmIChnZXRfcHJvdG9jb2xfaHR0cF9oZWFkZXIodmVyc2lvbiwgJnByb3RvY29sX2hlYWRlcikpCgkJc3RyaW5nX2xpc3RfYXBwZW5kKCZleHRyYV9oZWFkZXJzLCBwcm90b2NvbF9oZWFkZXIuYnVmKTsKCgltZW1zZXQoJmh0dHBfb3B0aW9ucywgMCwgc2l6ZW9mKGh0dHBfb3B0aW9ucykpOwoJaHR0cF9vcHRpb25zLmNvbnRlbnRfdHlwZSA9ICZ0eXBlOwoJaHR0cF9vcHRpb25zLmNoYXJzZXQgPSAmY2hhcnNldDsKCWh0dHBfb3B0aW9ucy5lZmZlY3RpdmVfdXJsID0gJmVmZmVjdGl2ZV91cmw7CglodHRwX29wdGlvbnMuYmFzZV91cmwgPSAmdXJsOwoJaHR0cF9vcHRpb25zLmV4dHJhX2hlYWRlcnMgPSAmZXh0cmFfaGVhZGVyczsKCWh0dHBfb3B0aW9ucy5pbml0aWFsX3JlcXVlc3QgPSAxOwoJaHR0cF9vcHRpb25zLm5vX2NhY2hlID0gMTsKCglodHRwX3JldCA9IGh0dHBfZ2V0X3N0cmJ1ZihyZWZzX3VybC5idWYsICZidWZmZXIsICZodHRwX29wdGlvbnMpOwoJc3dpdGNoIChodHRwX3JldCkgewoJY2FzZSBIVFRQX09LOgoJCWJyZWFrOwoJY2FzZSBIVFRQX01JU1NJTkdfVEFSR0VUOgoJCXNob3dfaHR0cF9tZXNzYWdlKCZ0eXBlLCAmY2hhcnNldCwgJmJ1ZmZlcik7CgkJZGllKF8oInJlcG9zaXRvcnkgJyVzJyBub3QgZm91bmQiKSwKCQkgICAgdHJhbnNwb3J0X2Fub255bWl6ZV91cmwodXJsLmJ1ZikpOwoJY2FzZSBIVFRQX05PQVVUSDoKCQlzaG93X2h0dHBfbWVzc2FnZSgmdHlwZSwgJmNoYXJzZXQsICZidWZmZXIpOwoJCWRpZShfKCJBdXRoZW50aWNhdGlvbiBmYWlsZWQgZm9yICclcyciKSwKCQkgICAgdHJhbnNwb3J0X2Fub255bWl6ZV91cmwodXJsLmJ1ZikpOwoJZGVmYXVsdDoKCQlzaG93X2h0dHBfbWVzc2FnZSgmdHlwZSwgJmNoYXJzZXQsICZidWZmZXIpOwoJCWRpZShfKCJ1bmFibGUgdG8gYWNjZXNzICclcyc6ICVzIiksCgkJICAgIHRyYW5zcG9ydF9hbm9ueW1pemVfdXJsKHVybC5idWYpLCBjdXJsX2Vycm9yc3RyKTsKCX0KCglpZiAob3B0aW9ucy52ZXJib3NpdHkgJiYgIXN0YXJ0c193aXRoKHJlZnNfdXJsLmJ1ZiwgdXJsLmJ1ZikpIHsKCQljaGFyICp1ID0gdHJhbnNwb3J0X2Fub255bWl6ZV91cmwodXJsLmJ1Zik7CgkJd2FybmluZyhfKCJyZWRpcmVjdGluZyB0byAlcyIpLCB1KTsKCQlmcmVlKHUpOwoJfQoKCWxhc3Q9IHhjYWxsb2MoMSwgc2l6ZW9mKCpsYXN0X2Rpc2NvdmVyeSkpOwoJbGFzdC0+c2VydmljZSA9IHhzdHJkdXAoc2VydmljZSk7CglsYXN0LT5idWZfYWxsb2MgPSBzdHJidWZfZGV0YWNoKCZidWZmZXIsICZsYXN0LT5sZW4pOwoJbGFzdC0+YnVmID0gbGFzdC0+YnVmX2FsbG9jOwoKCWlmIChtYXliZV9zbWFydCkKCQljaGVja19zbWFydF9odHRwKGxhc3QsIHNlcnZpY2UsICZ0eXBlKTsKCglpZiAobGFzdC0+cHJvdG9fZ2l0KQoJCWxhc3QtPnJlZnMgPSBwYXJzZV9naXRfcmVmcyhsYXN0LCBmb3JfcHVzaCk7CgllbHNlCgkJbGFzdC0+cmVmcyA9IHBhcnNlX2luZm9fcmVmcyhsYXN0KTsKCglzdHJidWZfcmVsZWFzZSgmcmVmc191cmwpOwoJc3RyYnVmX3JlbGVhc2UoJnR5cGUpOwoJc3RyYnVmX3JlbGVhc2UoJmNoYXJzZXQpOwoJc3RyYnVmX3JlbGVhc2UoJmVmZmVjdGl2ZV91cmwpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1ZmZlcik7CglzdHJidWZfcmVsZWFzZSgmcHJvdG9jb2xfaGVhZGVyKTsKCXN0cmluZ19saXN0X2NsZWFyKCZleHRyYV9oZWFkZXJzLCAwKTsKCWxhc3RfZGlzY292ZXJ5ID0gbGFzdDsKCXJldHVybiBsYXN0Owp9CgpzdGF0aWMgc3RydWN0IHJlZiAqZ2V0X3JlZnMoaW50IGZvcl9wdXNoKQp7CglzdHJ1Y3QgZGlzY292ZXJ5ICpoZWFkczsKCglpZiAoZm9yX3B1c2gpCgkJaGVhZHMgPSBkaXNjb3Zlcl9yZWZzKCJnaXQtcmVjZWl2ZS1wYWNrIiwgZm9yX3B1c2gpOwoJZWxzZQoJCWhlYWRzID0gZGlzY292ZXJfcmVmcygiZ2l0LXVwbG9hZC1wYWNrIiwgZm9yX3B1c2gpOwoKCXJldHVybiBoZWFkcy0+cmVmczsKfQoKc3RhdGljIHZvaWQgb3V0cHV0X3JlZnMoc3RydWN0IHJlZiAqcmVmcykKewoJc3RydWN0IHJlZiAqcG9zbjsKCWlmIChvcHRpb25zLm9iamVjdF9mb3JtYXQgJiYgb3B0aW9ucy5oYXNoX2FsZ28pIHsKCQlwcmludGYoIjpvYmplY3QtZm9ybWF0ICVzXG4iLCBvcHRpb25zLmhhc2hfYWxnby0+bmFtZSk7Cgl9Cglmb3IgKHBvc24gPSByZWZzOyBwb3NuOyBwb3NuID0gcG9zbi0+bmV4dCkgewoJCWlmIChwb3NuLT5zeW1yZWYpCgkJCXByaW50ZigiQCVzICVzXG4iLCBwb3NuLT5zeW1yZWYsIHBvc24tPm5hbWUpOwoJCWVsc2UKCQkJcHJpbnRmKCIlcyAlc1xuIiwgaGFzaF90b19oZXhfYWxnb3AocG9zbi0+b2xkX29pZC5oYXNoLAoJCQkJCQkJICAgIG9wdGlvbnMuaGFzaF9hbGdvKSwKCQkJCQkgIHBvc24tPm5hbWUpOwoJfQoJcHJpbnRmKCJcbiIpOwoJZmZsdXNoKHN0ZG91dCk7Cn0KCnN0cnVjdCBycGNfc3RhdGUgewoJY29uc3QgY2hhciAqc2VydmljZV9uYW1lOwoJY2hhciAqc2VydmljZV91cmw7CgljaGFyICpoZHJfY29udGVudF90eXBlOwoJY2hhciAqaGRyX2FjY2VwdDsKCWNoYXIgKnByb3RvY29sX2hlYWRlcjsKCWNoYXIgKmJ1ZjsKCXNpemVfdCBhbGxvYzsKCXNpemVfdCBsZW47CglzaXplX3QgcG9zOwoJaW50IGluOwoJaW50IG91dDsKCWludCBhbnlfd3JpdHRlbjsKCXVuc2lnbmVkIGd6aXBfcmVxdWVzdCA6IDE7Cgl1bnNpZ25lZCBpbml0aWFsX2J1ZmZlciA6IDE7CgoJLyoKCSAqIFdoZW5ldmVyIGEgcGt0LWxpbmUgaXMgcmVhZCBpbnRvIGJ1ZiwgYXBwZW5kIHRoZSA0IGNoYXJhY3RlcnMKCSAqIGRlbm90aW5nIGl0cyBsZW5ndGggYmVmb3JlIGFwcGVuZGluZyB0aGUgcGF5bG9hZC4KCSAqLwoJdW5zaWduZWQgd3JpdGVfbGluZV9sZW5ndGhzIDogMTsKCgkvKgoJICogVXNlZCBieSBycGNfb3V0OyBpbml0aWFsaXplIHRvIDAuIFRoaXMgaXMgdHJ1ZSBpZiBhIGZsdXNoIGhhcyBiZWVuCgkgKiByZWFkLCBidXQgdGhlIGNvcnJlc3BvbmRpbmcgbGluZSBsZW5ndGggKGlmIHdyaXRlX2xpbmVfbGVuZ3RocyBpcwoJICogdHJ1ZSkgYW5kIEVPRiBoYXZlIG5vdCBiZWVuIHNlbnQgdG8gbGliY3VybC4gU2luY2UgZWFjaCBmbHVzaCBtYXJrcwoJICogdGhlIGVuZCBvZiBhIHJlcXVlc3QsIGVhY2ggZmx1c2ggbXVzdCBiZSBjb21wbGV0ZWx5IHNlbnQgYmVmb3JlIGFueQoJICogZnVydGhlciByZWFkaW5nIG9jY3Vycy4KCSAqLwoJdW5zaWduZWQgZmx1c2hfcmVhZF9idXRfbm90X3NlbnQgOiAxOwp9OwoKLyoKICogQXBwZW5kcyB0aGUgcmVzdWx0IG9mIHJlYWRpbmcgZnJvbSBycGMtPm91dCB0byB0aGUgc3RyaW5nIHJlcHJlc2VudGVkIGJ5CiAqIHJwYy0+YnVmIGFuZCBycGMtPmxlbiBpZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2UuIFJldHVybnMgMSBpZiB0aGVyZSB3YXMKICogZW5vdWdoIHNwYWNlLCAwIG90aGVyd2lzZS4KICoKICogSWYgcnBjLT53cml0ZV9saW5lX2xlbmd0aHMgaXMgdHJ1ZSwgYXBwZW5kcyB0aGUgbGluZSBsZW5ndGggYXMgYSA0LWJ5dGUKICogaGV4YWRlY2ltYWwgc3RyaW5nIGJlZm9yZSBhcHBlbmRpbmcgdGhlIHJlc3VsdCBkZXNjcmliZWQgYWJvdmUuCiAqCiAqIFdyaXRlcyB0aGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGFwcGVuZGVkIGludG8gYXBwZW5kZWQuCiAqLwpzdGF0aWMgaW50IHJwY19yZWFkX2Zyb21fb3V0KHN0cnVjdCBycGNfc3RhdGUgKnJwYywgaW50IG9wdGlvbnMsCgkJCSAgICAgc2l6ZV90ICphcHBlbmRlZCwKCQkJICAgICBlbnVtIHBhY2tldF9yZWFkX3N0YXR1cyAqc3RhdHVzKSB7CglzaXplX3QgbGVmdDsKCWNoYXIgKmJ1ZjsKCWludCBwa3RsZW5fcmF3OwoKCWlmIChycGMtPndyaXRlX2xpbmVfbGVuZ3RocykgewoJCWxlZnQgPSBycGMtPmFsbG9jIC0gcnBjLT5sZW4gLSA0OwoJCWJ1ZiA9IHJwYy0+YnVmICsgcnBjLT5sZW4gKyA0OwoJfSBlbHNlIHsKCQlsZWZ0ID0gcnBjLT5hbGxvYyAtIHJwYy0+bGVuOwoJCWJ1ZiA9IHJwYy0+YnVmICsgcnBjLT5sZW47Cgl9CgoJaWYgKGxlZnQgPCBMQVJHRV9QQUNLRVRfTUFYKQoJCXJldHVybiAwOwoKCSpzdGF0dXMgPSBwYWNrZXRfcmVhZF93aXRoX3N0YXR1cyhycGMtPm91dCwgTlVMTCwgTlVMTCwgYnVmLAoJCQlsZWZ0LCAmcGt0bGVuX3Jhdywgb3B0aW9ucyk7CglpZiAoKnN0YXR1cyAhPSBQQUNLRVRfUkVBRF9FT0YpIHsKCQkqYXBwZW5kZWQgPSBwa3RsZW5fcmF3ICsgKHJwYy0+d3JpdGVfbGluZV9sZW5ndGhzID8gNCA6IDApOwoJCXJwYy0+bGVuICs9ICphcHBlbmRlZDsKCX0KCglpZiAocnBjLT53cml0ZV9saW5lX2xlbmd0aHMpIHsKCQlzd2l0Y2ggKCpzdGF0dXMpIHsKCQljYXNlIFBBQ0tFVF9SRUFEX0VPRjoKCQkJaWYgKCEob3B0aW9ucyAmIFBBQ0tFVF9SRUFEX0dFTlRMRV9PTl9FT0YpKQoJCQkJZGllKF8oInNob3VsZG4ndCBoYXZlIEVPRiB3aGVuIG5vdCBnZW50bGUgb24gRU9GIikpOwoJCQlicmVhazsKCQljYXNlIFBBQ0tFVF9SRUFEX05PUk1BTDoKCQkJc2V0X3BhY2tldF9oZWFkZXIoYnVmIC0gNCwgKmFwcGVuZGVkKTsKCQkJYnJlYWs7CgkJY2FzZSBQQUNLRVRfUkVBRF9ERUxJTToKCQkJbWVtY3B5KGJ1ZiAtIDQsICIwMDAxIiwgNCk7CgkJCWJyZWFrOwoJCWNhc2UgUEFDS0VUX1JFQURfRkxVU0g6CgkJCW1lbWNweShidWYgLSA0LCAiMDAwMCIsIDQpOwoJCQlicmVhazsKCQl9Cgl9CgoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBzaXplX3QgcnBjX291dCh2b2lkICpwdHIsIHNpemVfdCBlbHRzaXplLAoJCXNpemVfdCBubWVtYiwgdm9pZCAqYnVmZmVyXykKewoJc2l6ZV90IG1heCA9IGVsdHNpemUgKiBubWVtYjsKCXN0cnVjdCBycGNfc3RhdGUgKnJwYyA9IGJ1ZmZlcl87CglzaXplX3QgYXZhaWwgPSBycGMtPmxlbiAtIHJwYy0+cG9zOwoJZW51bSBwYWNrZXRfcmVhZF9zdGF0dXMgc3RhdHVzOwoKCWlmICghYXZhaWwpIHsKCQlycGMtPmluaXRpYWxfYnVmZmVyID0gMDsKCQlycGMtPmxlbiA9IDA7CgkJcnBjLT5wb3MgPSAwOwoJCWlmICghcnBjLT5mbHVzaF9yZWFkX2J1dF9ub3Rfc2VudCkgewoJCQlpZiAoIXJwY19yZWFkX2Zyb21fb3V0KHJwYywgMCwgJmF2YWlsLCAmc3RhdHVzKSkKCQkJCUJVRygiVGhlIGVudGlyZSBycGMtPmJ1ZiBzaG91bGQgYmUgbGFyZ2VyIHRoYW4gTEFSR0VfUEFDS0VUX01BWCIpOwoJCQlpZiAoc3RhdHVzID09IFBBQ0tFVF9SRUFEX0ZMVVNIKQoJCQkJcnBjLT5mbHVzaF9yZWFkX2J1dF9ub3Rfc2VudCA9IDE7CgkJfQoJCS8qCgkJICogSWYgZmx1c2hfcmVhZF9idXRfbm90X3NlbnQgaXMgdHJ1ZSwgd2UgaGF2ZSBhbHJlYWR5IHJlYWQgb25lCgkJICogZnVsbCByZXF1ZXN0IGJ1dCBoYXZlIG5vdCBmdWxseSBzZW50IGl0ICsgRU9GLCB3aGljaCBpcyB3aHkKCQkgKiB3ZSBuZWVkIHRvIHJlZnJhaW4gZnJvbSByZWFkaW5nLgoJCSAqLwoJfQoJaWYgKHJwYy0+Zmx1c2hfcmVhZF9idXRfbm90X3NlbnQpIHsKCQlpZiAoIWF2YWlsKSB7CgkJCS8qCgkJCSAqIFRoZSBsaW5lIGxlbmd0aCBlaXRoZXIgZG9lcyBub3QgbmVlZCB0byBiZSBzZW50IGF0CgkJCSAqIGFsbCBvciBoYXMgYWxyZWFkeSBiZWVuIGNvbXBsZXRlbHkgc2VudC4gTm93IHdlIGNhbgoJCQkgKiByZXR1cm4gMCwgaW5kaWNhdGluZyBFT0YsIG1lYW5pbmcgdGhhdCB0aGUgZmx1c2ggaGFzCgkJCSAqIGJlZW4gZnVsbHkgc2VudC4KCQkJICovCgkJCXJwYy0+Zmx1c2hfcmVhZF9idXRfbm90X3NlbnQgPSAwOwoJCQlyZXR1cm4gMDsKCQl9CgkJLyoKCQkgKiBJZiBhdmFpbCBpcyBub24temVycCwgdGhlIGxpbmUgbGVuZ3RoIGZvciB0aGUgZmx1c2ggc3RpbGwKCQkgKiBoYXNuJ3QgYmVlbiBmdWxseSBzZW50LiBQcm9jZWVkIHdpdGggc2VuZGluZyB0aGUgbGluZQoJCSAqIGxlbmd0aC4KCQkgKi8KCX0KCglpZiAobWF4IDwgYXZhaWwpCgkJYXZhaWwgPSBtYXg7CgltZW1jcHkocHRyLCBycGMtPmJ1ZiArIHJwYy0+cG9zLCBhdmFpbCk7CglycGMtPnBvcyArPSBhdmFpbDsKCXJldHVybiBhdmFpbDsKfQoKI2lmbmRlZiBOT19DVVJMX0lPQ1RMCnN0YXRpYyBjdXJsaW9lcnIgcnBjX2lvY3RsKENVUkwgKmhhbmRsZSwgaW50IGNtZCwgdm9pZCAqY2xpZW50cCkKewoJc3RydWN0IHJwY19zdGF0ZSAqcnBjID0gY2xpZW50cDsKCglzd2l0Y2ggKGNtZCkgewoJY2FzZSBDVVJMSU9DTURfTk9QOgoJCXJldHVybiBDVVJMSU9FX09LOwoKCWNhc2UgQ1VSTElPQ01EX1JFU1RBUlRSRUFEOgoJCWlmIChycGMtPmluaXRpYWxfYnVmZmVyKSB7CgkJCXJwYy0+cG9zID0gMDsKCQkJcmV0dXJuIENVUkxJT0VfT0s7CgkJfQoJCWVycm9yKF8oInVuYWJsZSB0byByZXdpbmQgcnBjIHBvc3QgZGF0YSAtIHRyeSBpbmNyZWFzaW5nIGh0dHAucG9zdEJ1ZmZlciIpKTsKCQlyZXR1cm4gQ1VSTElPRV9GQUlMUkVTVEFSVDsKCglkZWZhdWx0OgoJCXJldHVybiBDVVJMSU9FX1VOS05PV05DTUQ7Cgl9Cn0KI2VuZGlmCgpzdHJ1Y3QgcnBjX2luX2RhdGEgewoJc3RydWN0IHJwY19zdGF0ZSAqcnBjOwoJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3Q7Cn07CgovKgogKiBBIGNhbGxiYWNrIGZvciBDVVJMT1BUX1dSSVRFRlVOQ1RJT04uIFRoZSByZXR1cm4gdmFsdWUgaXMgdGhlIGJ5dGVzIGNvbnN1bWVkCiAqIGZyb20gcHRyLgogKi8Kc3RhdGljIHNpemVfdCBycGNfaW4oY2hhciAqcHRyLCBzaXplX3QgZWx0c2l6ZSwKCQlzaXplX3Qgbm1lbWIsIHZvaWQgKmJ1ZmZlcl8pCnsKCXNpemVfdCBzaXplID0gZWx0c2l6ZSAqIG5tZW1iOwoJc3RydWN0IHJwY19pbl9kYXRhICpkYXRhID0gYnVmZmVyXzsKCWxvbmcgcmVzcG9uc2VfY29kZTsKCglpZiAoY3VybF9lYXN5X2dldGluZm8oZGF0YS0+c2xvdC0+Y3VybCwgQ1VSTElORk9fUkVTUE9OU0VfQ09ERSwKCQkJICAgICAgJnJlc3BvbnNlX2NvZGUpICE9IENVUkxFX09LKQoJCXJldHVybiBzaXplOwoJaWYgKHJlc3BvbnNlX2NvZGUgPj0gMzAwKQoJCXJldHVybiBzaXplOwoJaWYgKHNpemUpCgkJZGF0YS0+cnBjLT5hbnlfd3JpdHRlbiA9IDE7Cgl3cml0ZV9vcl9kaWUoZGF0YS0+cnBjLT5pbiwgcHRyLCBzaXplKTsKCXJldHVybiBzaXplOwp9CgpzdGF0aWMgaW50IHJ1bl9zbG90KHN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90LAoJCSAgICBzdHJ1Y3Qgc2xvdF9yZXN1bHRzICpyZXN1bHRzKQp7CglpbnQgZXJyOwoJc3RydWN0IHNsb3RfcmVzdWx0cyByZXN1bHRzX2J1ZjsKCglpZiAoIXJlc3VsdHMpCgkJcmVzdWx0cyA9ICZyZXN1bHRzX2J1ZjsKCgllcnIgPSBydW5fb25lX3Nsb3Qoc2xvdCwgcmVzdWx0cyk7CgoJaWYgKGVyciAhPSBIVFRQX09LICYmIGVyciAhPSBIVFRQX1JFQVVUSCkgewoJCXN0cnVjdCBzdHJidWYgbXNnID0gU1RSQlVGX0lOSVQ7CgkJaWYgKHJlc3VsdHMtPmh0dHBfY29kZSAmJiByZXN1bHRzLT5odHRwX2NvZGUgIT0gMjAwKQoJCQlzdHJidWZfYWRkZigmbXNnLCAiSFRUUCAlbGQiLCByZXN1bHRzLT5odHRwX2NvZGUpOwoJCWlmIChyZXN1bHRzLT5jdXJsX3Jlc3VsdCAhPSBDVVJMRV9PSykgewoJCQlpZiAobXNnLmxlbikKCQkJCXN0cmJ1Zl9hZGRjaCgmbXNnLCAnICcpOwoJCQlzdHJidWZfYWRkZigmbXNnLCAiY3VybCAlZCIsIHJlc3VsdHMtPmN1cmxfcmVzdWx0KTsKCQkJaWYgKGN1cmxfZXJyb3JzdHJbMF0pIHsKCQkJCXN0cmJ1Zl9hZGRjaCgmbXNnLCAnICcpOwoJCQkJc3RyYnVmX2FkZHN0cigmbXNnLCBjdXJsX2Vycm9yc3RyKTsKCQkJfQoJCX0KCQllcnJvcihfKCJSUEMgZmFpbGVkOyAlcyIpLCBtc2cuYnVmKTsKCQlzdHJidWZfcmVsZWFzZSgmbXNnKTsKCX0KCglyZXR1cm4gZXJyOwp9CgpzdGF0aWMgaW50IHByb2JlX3JwYyhzdHJ1Y3QgcnBjX3N0YXRlICpycGMsIHN0cnVjdCBzbG90X3Jlc3VsdHMgKnJlc3VsdHMpCnsKCXN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90OwoJc3RydWN0IGN1cmxfc2xpc3QgKmhlYWRlcnMgPSBodHRwX2NvcHlfZGVmYXVsdF9oZWFkZXJzKCk7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaW50IGVycjsKCglzbG90ID0gZ2V0X2FjdGl2ZV9zbG90KCk7CgoJaGVhZGVycyA9IGN1cmxfc2xpc3RfYXBwZW5kKGhlYWRlcnMsIHJwYy0+aGRyX2NvbnRlbnRfdHlwZSk7CgloZWFkZXJzID0gY3VybF9zbGlzdF9hcHBlbmQoaGVhZGVycywgcnBjLT5oZHJfYWNjZXB0KTsKCgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfTk9CT0RZLCAwKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NULCAxKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9VUkwsIHJwYy0+c2VydmljZV91cmwpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0VOQ09ESU5HLCBOVUxMKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NURklFTERTLCAiMDAwMCIpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1BPU1RGSUVMRFNJWkUsIDQpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0hUVFBIRUFERVIsIGhlYWRlcnMpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1dSSVRFRlVOQ1RJT04sIGZ3cml0ZV9idWZmZXIpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0ZJTEUsICZidWYpOwoKCWVyciA9IHJ1bl9zbG90KHNsb3QsIHJlc3VsdHMpOwoKCWN1cmxfc2xpc3RfZnJlZV9hbGwoaGVhZGVycyk7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCXJldHVybiBlcnI7Cn0KCnN0YXRpYyBjdXJsX29mZl90IHhjdXJsX29mZl90KHNpemVfdCBsZW4pCnsKCXVpbnRtYXhfdCBzaXplID0gbGVuOwoJaWYgKHNpemUgPiBtYXhpbXVtX3NpZ25lZF92YWx1ZV9vZl90eXBlKGN1cmxfb2ZmX3QpKQoJCWRpZShfKCJjYW5ub3QgaGFuZGxlIHB1c2hlcyB0aGlzIGJpZyIpKTsKCXJldHVybiAoY3VybF9vZmZfdClzaXplOwp9CgovKgogKiBJZiBmbHVzaF9yZWNlaXZlZCBpcyB0cnVlLCBkbyBub3QgYXR0ZW1wdCB0byByZWFkIGFueSBtb3JlOyBqdXN0IHVzZSB3aGF0J3MKICogaW4gcnBjLT5idWYuCiAqLwpzdGF0aWMgaW50IHBvc3RfcnBjKHN0cnVjdCBycGNfc3RhdGUgKnJwYywgaW50IGZsdXNoX3JlY2VpdmVkKQp7CglzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdDsKCXN0cnVjdCBjdXJsX3NsaXN0ICpoZWFkZXJzID0gaHR0cF9jb3B5X2RlZmF1bHRfaGVhZGVycygpOwoJaW50IHVzZV9nemlwID0gcnBjLT5nemlwX3JlcXVlc3Q7CgljaGFyICpnemlwX2JvZHkgPSBOVUxMOwoJc2l6ZV90IGd6aXBfc2l6ZSA9IDA7CglpbnQgZXJyLCBsYXJnZV9yZXF1ZXN0ID0gMDsKCWludCBuZWVkc18xMDBfY29udGludWUgPSAwOwoJc3RydWN0IHJwY19pbl9kYXRhIHJwY19pbl9kYXRhOwoKCS8qIFRyeSB0byBsb2FkIHRoZSBlbnRpcmUgcmVxdWVzdCwgaWYgd2UgY2FuIGZpdCBpdCBpbnRvIHRoZQoJICogYWxsb2NhdGVkIGJ1ZmZlciBzcGFjZSB3ZSBjYW4gdXNlIEhUVFAvMS4wIGFuZCBhdm9pZCB0aGUKCSAqIGNodW5rZWQgZW5jb2RpbmcgbWVzcy4KCSAqLwoJaWYgKCFmbHVzaF9yZWNlaXZlZCkgewoJCXdoaWxlICgxKSB7CgkJCXNpemVfdCBuOwoJCQllbnVtIHBhY2tldF9yZWFkX3N0YXR1cyBzdGF0dXM7CgoJCQlpZiAoIXJwY19yZWFkX2Zyb21fb3V0KHJwYywgMCwgJm4sICZzdGF0dXMpKSB7CgkJCQlsYXJnZV9yZXF1ZXN0ID0gMTsKCQkJCXVzZV9nemlwID0gMDsKCQkJCWJyZWFrOwoJCQl9CgkJCWlmIChzdGF0dXMgPT0gUEFDS0VUX1JFQURfRkxVU0gpCgkJCQlicmVhazsKCQl9Cgl9CgoJaWYgKGxhcmdlX3JlcXVlc3QpIHsKCQlzdHJ1Y3Qgc2xvdF9yZXN1bHRzIHJlc3VsdHM7CgoJCWRvIHsKCQkJZXJyID0gcHJvYmVfcnBjKHJwYywgJnJlc3VsdHMpOwoJCQlpZiAoZXJyID09IEhUVFBfUkVBVVRIKQoJCQkJY3JlZGVudGlhbF9maWxsKCZodHRwX2F1dGgpOwoJCX0gd2hpbGUgKGVyciA9PSBIVFRQX1JFQVVUSCk7CgkJaWYgKGVyciAhPSBIVFRQX09LKQoJCQlyZXR1cm4gLTE7CgoJCWlmIChyZXN1bHRzLmF1dGhfYXZhaWwgJiBDVVJMQVVUSF9HU1NORUdPVElBVEUpCgkJCW5lZWRzXzEwMF9jb250aW51ZSA9IDE7Cgl9CgoJaGVhZGVycyA9IGN1cmxfc2xpc3RfYXBwZW5kKGhlYWRlcnMsIHJwYy0+aGRyX2NvbnRlbnRfdHlwZSk7CgloZWFkZXJzID0gY3VybF9zbGlzdF9hcHBlbmQoaGVhZGVycywgcnBjLT5oZHJfYWNjZXB0KTsKCWhlYWRlcnMgPSBjdXJsX3NsaXN0X2FwcGVuZChoZWFkZXJzLCBuZWVkc18xMDBfY29udGludWUgPwoJCSJFeHBlY3Q6IDEwMC1jb250aW51ZSIgOiAiRXhwZWN0OiIpOwoKCS8qIEFkZCB0aGUgZXh0cmEgR2l0LVByb3RvY29sIGhlYWRlciAqLwoJaWYgKHJwYy0+cHJvdG9jb2xfaGVhZGVyKQoJCWhlYWRlcnMgPSBjdXJsX3NsaXN0X2FwcGVuZChoZWFkZXJzLCBycGMtPnByb3RvY29sX2hlYWRlcik7CgpyZXRyeToKCXNsb3QgPSBnZXRfYWN0aXZlX3Nsb3QoKTsKCgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfTk9CT0RZLCAwKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NULCAxKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9VUkwsIHJwYy0+c2VydmljZV91cmwpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0VOQ09ESU5HLCAiIik7CgoJaWYgKGxhcmdlX3JlcXVlc3QpIHsKCQkvKiBUaGUgcmVxdWVzdCBib2R5IGlzIGxhcmdlIGFuZCB0aGUgc2l6ZSBjYW5ub3QgYmUgcHJlZGljdGVkLgoJCSAqIFdlIG11c3QgdXNlIGNodW5rZWQgZW5jb2RpbmcgdG8gc2VuZCBpdC4KCQkgKi8KCQloZWFkZXJzID0gY3VybF9zbGlzdF9hcHBlbmQoaGVhZGVycywgIlRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkIik7CgkJcnBjLT5pbml0aWFsX2J1ZmZlciA9IDE7CgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1JFQURGVU5DVElPTiwgcnBjX291dCk7CgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0lORklMRSwgcnBjKTsKI2lmbmRlZiBOT19DVVJMX0lPQ1RMCgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0lPQ1RMRlVOQ1RJT04sIHJwY19pb2N0bCk7CgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0lPQ1RMREFUQSwgcnBjKTsKI2VuZGlmCgkJaWYgKG9wdGlvbnMudmVyYm9zaXR5ID4gMSkgewoJCQlmcHJpbnRmKHN0ZGVyciwgIlBPU1QgJXMgKGNodW5rZWQpXG4iLCBycGMtPnNlcnZpY2VfbmFtZSk7CgkJCWZmbHVzaChzdGRlcnIpOwoJCX0KCgl9IGVsc2UgaWYgKGd6aXBfYm9keSkgewoJCS8qCgkJICogSWYgd2UgYXJlIGxvb3BpbmcgdG8gcmV0cnkgYXV0aGVudGljYXRpb24sIHRoZW4gdGhlIHByZXZpb3VzCgkJICogcnVuIHdpbGwgaGF2ZSBzZXQgdXAgdGhlIGhlYWRlcnMgYW5kIGd6aXAgYnVmZmVyIGFscmVhZHksCgkJICogYW5kIHdlIGp1c3QgbmVlZCB0byBzZW5kIGl0LgoJCSAqLwoJCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NURklFTERTLCBnemlwX2JvZHkpOwoJCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NURklFTERTSVpFX0xBUkdFLCB4Y3VybF9vZmZfdChnemlwX3NpemUpKTsKCgl9IGVsc2UgaWYgKHVzZV9nemlwICYmIDEwMjQgPCBycGMtPmxlbikgewoJCS8qIFRoZSBjbGllbnQgYmFja2VuZCBpc24ndCBnaXZpbmcgdXMgY29tcHJlc3NlZCBkYXRhIHNvCgkJICogd2UgY2FuIHRyeSB0byBkZWZsYXRlIGl0IG91cnNlbHZlcywgdGhpcyBtYXkgc2F2ZSBvbgoJCSAqIHRoZSB0cmFuc2ZlciB0aW1lLgoJCSAqLwoJCWdpdF96c3RyZWFtIHN0cmVhbTsKCQlpbnQgcmV0OwoKCQlnaXRfZGVmbGF0ZV9pbml0X2d6aXAoJnN0cmVhbSwgWl9CRVNUX0NPTVBSRVNTSU9OKTsKCQlnemlwX3NpemUgPSBnaXRfZGVmbGF0ZV9ib3VuZCgmc3RyZWFtLCBycGMtPmxlbik7CgkJZ3ppcF9ib2R5ID0geG1hbGxvYyhnemlwX3NpemUpOwoKCQlzdHJlYW0ubmV4dF9pbiA9ICh1bnNpZ25lZCBjaGFyICopcnBjLT5idWY7CgkJc3RyZWFtLmF2YWlsX2luID0gcnBjLT5sZW47CgkJc3RyZWFtLm5leHRfb3V0ID0gKHVuc2lnbmVkIGNoYXIgKilnemlwX2JvZHk7CgkJc3RyZWFtLmF2YWlsX291dCA9IGd6aXBfc2l6ZTsKCgkJcmV0ID0gZ2l0X2RlZmxhdGUoJnN0cmVhbSwgWl9GSU5JU0gpOwoJCWlmIChyZXQgIT0gWl9TVFJFQU1fRU5EKQoJCQlkaWUoXygiY2Fubm90IGRlZmxhdGUgcmVxdWVzdDsgemxpYiBkZWZsYXRlIGVycm9yICVkIiksIHJldCk7CgoJCXJldCA9IGdpdF9kZWZsYXRlX2VuZF9nZW50bHkoJnN0cmVhbSk7CgkJaWYgKHJldCAhPSBaX09LKQoJCQlkaWUoXygiY2Fubm90IGRlZmxhdGUgcmVxdWVzdDsgemxpYiBlbmQgZXJyb3IgJWQiKSwgcmV0KTsKCgkJZ3ppcF9zaXplID0gc3RyZWFtLnRvdGFsX291dDsKCgkJaGVhZGVycyA9IGN1cmxfc2xpc3RfYXBwZW5kKGhlYWRlcnMsICJDb250ZW50LUVuY29kaW5nOiBnemlwIik7CgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1BPU1RGSUVMRFMsIGd6aXBfYm9keSk7CgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1BPU1RGSUVMRFNJWkVfTEFSR0UsIHhjdXJsX29mZl90KGd6aXBfc2l6ZSkpOwoKCQlpZiAob3B0aW9ucy52ZXJib3NpdHkgPiAxKSB7CgkJCWZwcmludGYoc3RkZXJyLCAiUE9TVCAlcyAoZ3ppcCAlbHUgdG8gJWx1IGJ5dGVzKVxuIiwKCQkJCXJwYy0+c2VydmljZV9uYW1lLAoJCQkJKHVuc2lnbmVkIGxvbmcpcnBjLT5sZW4sICh1bnNpZ25lZCBsb25nKWd6aXBfc2l6ZSk7CgkJCWZmbHVzaChzdGRlcnIpOwoJCX0KCX0gZWxzZSB7CgkJLyogV2Uga25vdyB0aGUgY29tcGxldGUgcmVxdWVzdCBzaXplIGluIGFkdmFuY2UsIHVzZSB0aGUKCQkgKiBtb3JlIG5vcm1hbCBDb250ZW50LUxlbmd0aCBhcHByb2FjaC4KCQkgKi8KCQljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfUE9TVEZJRUxEUywgcnBjLT5idWYpOwoJCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NURklFTERTSVpFX0xBUkdFLCB4Y3VybF9vZmZfdChycGMtPmxlbikpOwoJCWlmIChvcHRpb25zLnZlcmJvc2l0eSA+IDEpIHsKCQkJZnByaW50ZihzdGRlcnIsICJQT1NUICVzICglbHUgYnl0ZXMpXG4iLAoJCQkJcnBjLT5zZXJ2aWNlX25hbWUsICh1bnNpZ25lZCBsb25nKXJwYy0+bGVuKTsKCQkJZmZsdXNoKHN0ZGVycik7CgkJfQoJfQoKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9IVFRQSEVBREVSLCBoZWFkZXJzKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9XUklURUZVTkNUSU9OLCBycGNfaW4pOwoJcnBjX2luX2RhdGEucnBjID0gcnBjOwoJcnBjX2luX2RhdGEuc2xvdCA9IHNsb3Q7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfRklMRSwgJnJwY19pbl9kYXRhKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9GQUlMT05FUlJPUiwgMCk7CgoKCXJwYy0+YW55X3dyaXR0ZW4gPSAwOwoJZXJyID0gcnVuX3Nsb3Qoc2xvdCwgTlVMTCk7CglpZiAoZXJyID09IEhUVFBfUkVBVVRIICYmICFsYXJnZV9yZXF1ZXN0KSB7CgkJY3JlZGVudGlhbF9maWxsKCZodHRwX2F1dGgpOwoJCWdvdG8gcmV0cnk7Cgl9CglpZiAoZXJyICE9IEhUVFBfT0spCgkJZXJyID0gLTE7CgoJaWYgKCFycGMtPmFueV93cml0dGVuKQoJCWVyciA9IC0xOwoKCWN1cmxfc2xpc3RfZnJlZV9hbGwoaGVhZGVycyk7CglmcmVlKGd6aXBfYm9keSk7CglyZXR1cm4gZXJyOwp9CgpzdGF0aWMgaW50IHJwY19zZXJ2aWNlKHN0cnVjdCBycGNfc3RhdGUgKnJwYywgc3RydWN0IGRpc2NvdmVyeSAqaGVhZHMsCgkJICAgICAgIGNvbnN0IGNoYXIgKipjbGllbnRfYXJndiwgY29uc3Qgc3RydWN0IHN0cmJ1ZiAqcHJlYW1ibGUsCgkJICAgICAgIHN0cnVjdCBzdHJidWYgKnJwY19yZXN1bHQpCnsKCWNvbnN0IGNoYXIgKnN2YyA9IHJwYy0+c2VydmljZV9uYW1lOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGNsaWVudCA9IENISUxEX1BST0NFU1NfSU5JVDsKCWludCBlcnIgPSAwOwoKCWNsaWVudC5pbiA9IC0xOwoJY2xpZW50Lm91dCA9IC0xOwoJY2xpZW50LmdpdF9jbWQgPSAxOwoJY2xpZW50LmFyZ3YgPSBjbGllbnRfYXJndjsKCWlmIChzdGFydF9jb21tYW5kKCZjbGllbnQpKQoJCWV4aXQoMSk7Cgl3cml0ZV9vcl9kaWUoY2xpZW50LmluLCBwcmVhbWJsZS0+YnVmLCBwcmVhbWJsZS0+bGVuKTsKCWlmIChoZWFkcykKCQl3cml0ZV9vcl9kaWUoY2xpZW50LmluLCBoZWFkcy0+YnVmLCBoZWFkcy0+bGVuKTsKCglycGMtPmFsbG9jID0gaHR0cF9wb3N0X2J1ZmZlcjsKCXJwYy0+YnVmID0geG1hbGxvYyhycGMtPmFsbG9jKTsKCXJwYy0+aW4gPSBjbGllbnQuaW47CglycGMtPm91dCA9IGNsaWVudC5vdXQ7CgoJc3RyYnVmX2FkZGYoJmJ1ZiwgIiVzJXMiLCB1cmwuYnVmLCBzdmMpOwoJcnBjLT5zZXJ2aWNlX3VybCA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7CgoJc3RyYnVmX2FkZGYoJmJ1ZiwgIkNvbnRlbnQtVHlwZTogYXBwbGljYXRpb24veC0lcy1yZXF1ZXN0Iiwgc3ZjKTsKCXJwYy0+aGRyX2NvbnRlbnRfdHlwZSA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7CgoJc3RyYnVmX2FkZGYoJmJ1ZiwgIkFjY2VwdDogYXBwbGljYXRpb24veC0lcy1yZXN1bHQiLCBzdmMpOwoJcnBjLT5oZHJfYWNjZXB0ID0gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCglpZiAoZ2V0X3Byb3RvY29sX2h0dHBfaGVhZGVyKGhlYWRzLT52ZXJzaW9uLCAmYnVmKSkKCQlycGMtPnByb3RvY29sX2hlYWRlciA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7CgllbHNlCgkJcnBjLT5wcm90b2NvbF9oZWFkZXIgPSBOVUxMOwoKCXdoaWxlICghZXJyKSB7CgkJaW50IG4gPSBwYWNrZXRfcmVhZChycGMtPm91dCwgTlVMTCwgTlVMTCwgcnBjLT5idWYsIHJwYy0+YWxsb2MsIDApOwoJCWlmICghbikKCQkJYnJlYWs7CgkJcnBjLT5wb3MgPSAwOwoJCXJwYy0+bGVuID0gbjsKCQllcnIgfD0gcG9zdF9ycGMocnBjLCAwKTsKCX0KCgljbG9zZShjbGllbnQuaW4pOwoJY2xpZW50LmluID0gLTE7CglpZiAoIWVycikgewoJCXN0cmJ1Zl9yZWFkKHJwY19yZXN1bHQsIGNsaWVudC5vdXQsIDApOwoJfSBlbHNlIHsKCQljaGFyIGJ1Zls0MDk2XTsKCQlmb3IgKDs7KQoJCQlpZiAoeHJlYWQoY2xpZW50Lm91dCwgYnVmLCBzaXplb2YoYnVmKSkgPD0gMCkKCQkJCWJyZWFrOwoJfQoKCWNsb3NlKGNsaWVudC5vdXQpOwoJY2xpZW50Lm91dCA9IC0xOwoKCWVyciB8PSBmaW5pc2hfY29tbWFuZCgmY2xpZW50KTsKCWZyZWUocnBjLT5zZXJ2aWNlX3VybCk7CglmcmVlKHJwYy0+aGRyX2NvbnRlbnRfdHlwZSk7CglmcmVlKHJwYy0+aGRyX2FjY2VwdCk7CglmcmVlKHJwYy0+cHJvdG9jb2xfaGVhZGVyKTsKCWZyZWUocnBjLT5idWYpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CglyZXR1cm4gZXJyOwp9CgpzdGF0aWMgaW50IGZldGNoX2R1bWIoaW50IG5yX2hlYWRzLCBzdHJ1Y3QgcmVmICoqdG9fZmV0Y2gpCnsKCXN0cnVjdCB3YWxrZXIgKndhbGtlcjsKCWNoYXIgKip0YXJnZXRzOwoJaW50IHJldCwgaTsKCglBTExPQ19BUlJBWSh0YXJnZXRzLCBucl9oZWFkcyk7CglpZiAob3B0aW9ucy5kZXB0aCB8fCBvcHRpb25zLmRlZXBlbl9zaW5jZSkKCQlkaWUoXygiZHVtYiBodHRwIHRyYW5zcG9ydCBkb2VzIG5vdCBzdXBwb3J0IHNoYWxsb3cgY2FwYWJpbGl0aWVzIikpOwoJZm9yIChpID0gMDsgaSA8IG5yX2hlYWRzOyBpKyspCgkJdGFyZ2V0c1tpXSA9IHhzdHJkdXAob2lkX3RvX2hleCgmdG9fZmV0Y2hbaV0tPm9sZF9vaWQpKTsKCgl3YWxrZXIgPSBnZXRfaHR0cF93YWxrZXIodXJsLmJ1Zik7Cgl3YWxrZXItPmdldF92ZXJib3NlbHkgPSBvcHRpb25zLnZlcmJvc2l0eSA+PSAzOwoJd2Fsa2VyLT5nZXRfcHJvZ3Jlc3MgPSBvcHRpb25zLnByb2dyZXNzOwoJd2Fsa2VyLT5nZXRfcmVjb3ZlciA9IDA7CglyZXQgPSB3YWxrZXJfZmV0Y2god2Fsa2VyLCBucl9oZWFkcywgdGFyZ2V0cywgTlVMTCwgTlVMTCk7Cgl3YWxrZXJfZnJlZSh3YWxrZXIpOwoKCWZvciAoaSA9IDA7IGkgPCBucl9oZWFkczsgaSsrKQoJCWZyZWUodGFyZ2V0c1tpXSk7CglmcmVlKHRhcmdldHMpOwoKCXJldHVybiByZXQgPyBlcnJvcihfKCJmZXRjaCBmYWlsZWQuIikpIDogMDsKfQoKc3RhdGljIGludCBmZXRjaF9naXQoc3RydWN0IGRpc2NvdmVyeSAqaGVhZHMsCglpbnQgbnJfaGVhZHMsIHN0cnVjdCByZWYgKip0b19mZXRjaCkKewoJc3RydWN0IHJwY19zdGF0ZSBycGM7CglzdHJ1Y3Qgc3RyYnVmIHByZWFtYmxlID0gU1RSQlVGX0lOSVQ7CglpbnQgaSwgZXJyOwoJc3RydWN0IGFyZ3ZfYXJyYXkgYXJncyA9IEFSR1ZfQVJSQVlfSU5JVDsKCXN0cnVjdCBzdHJidWYgcnBjX3Jlc3VsdCA9IFNUUkJVRl9JTklUOwoKCWFyZ3ZfYXJyYXlfcHVzaGwoJmFyZ3MsICJmZXRjaC1wYWNrIiwgIi0tc3RhdGVsZXNzLXJwYyIsCgkJCSAiLS1zdGRpbiIsICItLWxvY2stcGFjayIsIE5VTEwpOwoJaWYgKG9wdGlvbnMuZm9sbG93dGFncykKCQlhcmd2X2FycmF5X3B1c2goJmFyZ3MsICItLWluY2x1ZGUtdGFnIik7CglpZiAob3B0aW9ucy50aGluKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJncywgIi0tdGhpbiIpOwoJaWYgKG9wdGlvbnMudmVyYm9zaXR5ID49IDMpCgkJYXJndl9hcnJheV9wdXNobCgmYXJncywgIi12IiwgIi12IiwgTlVMTCk7CglpZiAob3B0aW9ucy5jaGVja19zZWxmX2NvbnRhaW5lZF9hbmRfY29ubmVjdGVkKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJncywgIi0tY2hlY2stc2VsZi1jb250YWluZWQtYW5kLWNvbm5lY3RlZCIpOwoJaWYgKG9wdGlvbnMuY2xvbmluZykKCQlhcmd2X2FycmF5X3B1c2goJmFyZ3MsICItLWNsb25pbmciKTsKCWlmIChvcHRpb25zLnVwZGF0ZV9zaGFsbG93KQoJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJncywgIi0tdXBkYXRlLXNoYWxsb3ciKTsKCWlmICghb3B0aW9ucy5wcm9ncmVzcykKCQlhcmd2X2FycmF5X3B1c2goJmFyZ3MsICItLW5vLXByb2dyZXNzIik7CglpZiAob3B0aW9ucy5kZXB0aCkKCQlhcmd2X2FycmF5X3B1c2hmKCZhcmdzLCAiLS1kZXB0aD0lbHUiLCBvcHRpb25zLmRlcHRoKTsKCWlmIChvcHRpb25zLmRlZXBlbl9zaW5jZSkKCQlhcmd2X2FycmF5X3B1c2hmKCZhcmdzLCAiLS1zaGFsbG93LXNpbmNlPSVzIiwgb3B0aW9ucy5kZWVwZW5fc2luY2UpOwoJZm9yIChpID0gMDsgaSA8IG9wdGlvbnMuZGVlcGVuX25vdC5ucjsgaSsrKQoJCWFyZ3ZfYXJyYXlfcHVzaGYoJmFyZ3MsICItLXNoYWxsb3ctZXhjbHVkZT0lcyIsCgkJCQkgb3B0aW9ucy5kZWVwZW5fbm90Lml0ZW1zW2ldLnN0cmluZyk7CglpZiAob3B0aW9ucy5kZWVwZW5fcmVsYXRpdmUgJiYgb3B0aW9ucy5kZXB0aCkKCQlhcmd2X2FycmF5X3B1c2goJmFyZ3MsICItLWRlZXBlbi1yZWxhdGl2ZSIpOwoJaWYgKG9wdGlvbnMuZnJvbV9wcm9taXNvcikKCQlhcmd2X2FycmF5X3B1c2goJmFyZ3MsICItLWZyb20tcHJvbWlzb3IiKTsKCWlmIChvcHRpb25zLm5vX2RlcGVuZGVudHMpCgkJYXJndl9hcnJheV9wdXNoKCZhcmdzLCAiLS1uby1kZXBlbmRlbnRzIik7CglpZiAob3B0aW9ucy5maWx0ZXIpCgkJYXJndl9hcnJheV9wdXNoZigmYXJncywgIi0tZmlsdGVyPSVzIiwgb3B0aW9ucy5maWx0ZXIpOwoJYXJndl9hcnJheV9wdXNoKCZhcmdzLCB1cmwuYnVmKTsKCglmb3IgKGkgPSAwOyBpIDwgbnJfaGVhZHM7IGkrKykgewoJCXN0cnVjdCByZWYgKnJlZiA9IHRvX2ZldGNoW2ldOwoJCWlmICghKnJlZi0+bmFtZSkKCQkJZGllKF8oImNhbm5vdCBmZXRjaCBieSBzaGExIG92ZXIgc21hcnQgaHR0cCIpKTsKCQlwYWNrZXRfYnVmX3dyaXRlKCZwcmVhbWJsZSwgIiVzICVzXG4iLAoJCQkJIG9pZF90b19oZXgoJnJlZi0+b2xkX29pZCksIHJlZi0+bmFtZSk7Cgl9CglwYWNrZXRfYnVmX2ZsdXNoKCZwcmVhbWJsZSk7CgoJbWVtc2V0KCZycGMsIDAsIHNpemVvZihycGMpKTsKCXJwYy5zZXJ2aWNlX25hbWUgPSAiZ2l0LXVwbG9hZC1wYWNrIiwKCXJwYy5nemlwX3JlcXVlc3QgPSAxOwoKCWVyciA9IHJwY19zZXJ2aWNlKCZycGMsIGhlYWRzLCBhcmdzLmFyZ3YsICZwcmVhbWJsZSwgJnJwY19yZXN1bHQpOwoJaWYgKHJwY19yZXN1bHQubGVuKQoJCXdyaXRlX29yX2RpZSgxLCBycGNfcmVzdWx0LmJ1ZiwgcnBjX3Jlc3VsdC5sZW4pOwoJc3RyYnVmX3JlbGVhc2UoJnJwY19yZXN1bHQpOwoJc3RyYnVmX3JlbGVhc2UoJnByZWFtYmxlKTsKCWFyZ3ZfYXJyYXlfY2xlYXIoJmFyZ3MpOwoJcmV0dXJuIGVycjsKfQoKc3RhdGljIGludCBmZXRjaChpbnQgbnJfaGVhZHMsIHN0cnVjdCByZWYgKip0b19mZXRjaCkKewoJc3RydWN0IGRpc2NvdmVyeSAqZCA9IGRpc2NvdmVyX3JlZnMoImdpdC11cGxvYWQtcGFjayIsIDApOwoJaWYgKGQtPnByb3RvX2dpdCkKCQlyZXR1cm4gZmV0Y2hfZ2l0KGQsIG5yX2hlYWRzLCB0b19mZXRjaCk7CgllbHNlCgkJcmV0dXJuIGZldGNoX2R1bWIobnJfaGVhZHMsIHRvX2ZldGNoKTsKfQoKc3RhdGljIHZvaWQgcGFyc2VfZmV0Y2goc3RydWN0IHN0cmJ1ZiAqYnVmKQp7CglzdHJ1Y3QgcmVmICoqdG9fZmV0Y2ggPSBOVUxMOwoJc3RydWN0IHJlZiAqbGlzdF9oZWFkID0gTlVMTDsKCXN0cnVjdCByZWYgKipsaXN0ID0gJmxpc3RfaGVhZDsKCWludCBhbGxvY19oZWFkcyA9IDAsIG5yX2hlYWRzID0gMDsKCglkbyB7CgkJY29uc3QgY2hhciAqcDsKCQlpZiAoc2tpcF9wcmVmaXgoYnVmLT5idWYsICJmZXRjaCAiLCAmcCkpIHsKCQkJY29uc3QgY2hhciAqbmFtZTsKCQkJc3RydWN0IHJlZiAqcmVmOwoJCQlzdHJ1Y3Qgb2JqZWN0X2lkIG9sZF9vaWQ7CgkJCWNvbnN0IGNoYXIgKnE7CgoJCQlpZiAocGFyc2Vfb2lkX2hleChwLCAmb2xkX29pZCwgJnEpKQoJCQkJZGllKF8oInByb3RvY29sIGVycm9yOiBleHBlY3RlZCBzaGEvcmVmLCBnb3QgJyVzJyIpLCBwKTsKCQkJaWYgKCpxID09ICcgJykKCQkJCW5hbWUgPSBxICsgMTsKCQkJZWxzZSBpZiAoISpxKQoJCQkJbmFtZSA9ICIiOwoJCQllbHNlCgkJCQlkaWUoXygicHJvdG9jb2wgZXJyb3I6IGV4cGVjdGVkIHNoYS9yZWYsIGdvdCAnJXMnIiksIHApOwoKCQkJcmVmID0gYWxsb2NfcmVmKG5hbWUpOwoJCQlvaWRjcHkoJnJlZi0+b2xkX29pZCwgJm9sZF9vaWQpOwoKCQkJKmxpc3QgPSByZWY7CgkJCWxpc3QgPSAmcmVmLT5uZXh0OwoKCQkJQUxMT0NfR1JPVyh0b19mZXRjaCwgbnJfaGVhZHMgKyAxLCBhbGxvY19oZWFkcyk7CgkJCXRvX2ZldGNoW25yX2hlYWRzKytdID0gcmVmOwoJCX0KCQllbHNlCgkJCWRpZShfKCJodHRwIHRyYW5zcG9ydCBkb2VzIG5vdCBzdXBwb3J0ICVzIiksIGJ1Zi0+YnVmKTsKCgkJc3RyYnVmX3Jlc2V0KGJ1Zik7CgkJaWYgKHN0cmJ1Zl9nZXRsaW5lX2xmKGJ1Ziwgc3RkaW4pID09IEVPRikKCQkJcmV0dXJuOwoJCWlmICghKmJ1Zi0+YnVmKQoJCQlicmVhazsKCX0gd2hpbGUgKDEpOwoKCWlmIChmZXRjaChucl9oZWFkcywgdG9fZmV0Y2gpKQoJCWV4aXQoMTI4KTsgLyogZXJyb3IgYWxyZWFkeSByZXBvcnRlZCAqLwoJZnJlZV9yZWZzKGxpc3RfaGVhZCk7CglmcmVlKHRvX2ZldGNoKTsKCglwcmludGYoIlxuIik7CglmZmx1c2goc3Rkb3V0KTsKCXN0cmJ1Zl9yZXNldChidWYpOwp9CgpzdGF0aWMgaW50IHB1c2hfZGF2KGludCBucl9zcGVjLCBjb25zdCBjaGFyICoqc3BlY3MpCnsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGNoaWxkID0gQ0hJTERfUFJPQ0VTU19JTklUOwoJc2l6ZV90IGk7CgoJY2hpbGQuZ2l0X2NtZCA9IDE7Cglhcmd2X2FycmF5X3B1c2goJmNoaWxkLmFyZ3MsICJodHRwLXB1c2giKTsKCWFyZ3ZfYXJyYXlfcHVzaCgmY2hpbGQuYXJncywgIi0taGVscGVyLXN0YXR1cyIpOwoJaWYgKG9wdGlvbnMuZHJ5X3J1bikKCQlhcmd2X2FycmF5X3B1c2goJmNoaWxkLmFyZ3MsICItLWRyeS1ydW4iKTsKCWlmIChvcHRpb25zLnZlcmJvc2l0eSA+IDEpCgkJYXJndl9hcnJheV9wdXNoKCZjaGlsZC5hcmdzLCAiLS12ZXJib3NlIik7Cglhcmd2X2FycmF5X3B1c2goJmNoaWxkLmFyZ3MsIHVybC5idWYpOwoJZm9yIChpID0gMDsgaSA8IG5yX3NwZWM7IGkrKykKCQlhcmd2X2FycmF5X3B1c2goJmNoaWxkLmFyZ3MsIHNwZWNzW2ldKTsKCglpZiAocnVuX2NvbW1hbmQoJmNoaWxkKSkKCQlkaWUoXygiZ2l0LWh0dHAtcHVzaCBmYWlsZWQiKSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBwdXNoX2dpdChzdHJ1Y3QgZGlzY292ZXJ5ICpoZWFkcywgaW50IG5yX3NwZWMsIGNvbnN0IGNoYXIgKipzcGVjcykKewoJc3RydWN0IHJwY19zdGF0ZSBycGM7CglpbnQgaSwgZXJyOwoJc3RydWN0IGFyZ3ZfYXJyYXkgYXJnczsKCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICpjYXNfb3B0aW9uOwoJc3RydWN0IHN0cmJ1ZiBwcmVhbWJsZSA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBycGNfcmVzdWx0ID0gU1RSQlVGX0lOSVQ7CgoJYXJndl9hcnJheV9pbml0KCZhcmdzKTsKCWFyZ3ZfYXJyYXlfcHVzaGwoJmFyZ3MsICJzZW5kLXBhY2siLCAiLS1zdGF0ZWxlc3MtcnBjIiwgIi0taGVscGVyLXN0YXR1cyIsCgkJCSBOVUxMKTsKCglpZiAob3B0aW9ucy50aGluKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJncywgIi0tdGhpbiIpOwoJaWYgKG9wdGlvbnMuZHJ5X3J1bikKCQlhcmd2X2FycmF5X3B1c2goJmFyZ3MsICItLWRyeS1ydW4iKTsKCWlmIChvcHRpb25zLnB1c2hfY2VydCA9PSBTRU5EX1BBQ0tfUFVTSF9DRVJUX0FMV0FZUykKCQlhcmd2X2FycmF5X3B1c2goJmFyZ3MsICItLXNpZ25lZD15ZXMiKTsKCWVsc2UgaWYgKG9wdGlvbnMucHVzaF9jZXJ0ID09IFNFTkRfUEFDS19QVVNIX0NFUlRfSUZfQVNLRUQpCgkJYXJndl9hcnJheV9wdXNoKCZhcmdzLCAiLS1zaWduZWQ9aWYtYXNrZWQiKTsKCWlmIChvcHRpb25zLmF0b21pYykKCQlhcmd2X2FycmF5X3B1c2goJmFyZ3MsICItLWF0b21pYyIpOwoJaWYgKG9wdGlvbnMudmVyYm9zaXR5ID09IDApCgkJYXJndl9hcnJheV9wdXNoKCZhcmdzLCAiLS1xdWlldCIpOwoJZWxzZSBpZiAob3B0aW9ucy52ZXJib3NpdHkgPiAxKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJncywgIi0tdmVyYm9zZSIpOwoJZm9yIChpID0gMDsgaSA8IG9wdGlvbnMucHVzaF9vcHRpb25zLm5yOyBpKyspCgkJYXJndl9hcnJheV9wdXNoZigmYXJncywgIi0tcHVzaC1vcHRpb249JXMiLAoJCQkJIG9wdGlvbnMucHVzaF9vcHRpb25zLml0ZW1zW2ldLnN0cmluZyk7Cglhcmd2X2FycmF5X3B1c2goJmFyZ3MsIG9wdGlvbnMucHJvZ3Jlc3MgPyAiLS1wcm9ncmVzcyIgOiAiLS1uby1wcm9ncmVzcyIpOwoJZm9yX2VhY2hfc3RyaW5nX2xpc3RfaXRlbShjYXNfb3B0aW9uLCAmY2FzX29wdGlvbnMpCgkJYXJndl9hcnJheV9wdXNoKCZhcmdzLCBjYXNfb3B0aW9uLT5zdHJpbmcpOwoJYXJndl9hcnJheV9wdXNoKCZhcmdzLCB1cmwuYnVmKTsKCglhcmd2X2FycmF5X3B1c2goJmFyZ3MsICItLXN0ZGluIik7Cglmb3IgKGkgPSAwOyBpIDwgbnJfc3BlYzsgaSsrKQoJCXBhY2tldF9idWZfd3JpdGUoJnByZWFtYmxlLCAiJXNcbiIsIHNwZWNzW2ldKTsKCXBhY2tldF9idWZfZmx1c2goJnByZWFtYmxlKTsKCgltZW1zZXQoJnJwYywgMCwgc2l6ZW9mKHJwYykpOwoJcnBjLnNlcnZpY2VfbmFtZSA9ICJnaXQtcmVjZWl2ZS1wYWNrIiwKCgllcnIgPSBycGNfc2VydmljZSgmcnBjLCBoZWFkcywgYXJncy5hcmd2LCAmcHJlYW1ibGUsICZycGNfcmVzdWx0KTsKCWlmIChycGNfcmVzdWx0LmxlbikKCQl3cml0ZV9vcl9kaWUoMSwgcnBjX3Jlc3VsdC5idWYsIHJwY19yZXN1bHQubGVuKTsKCXN0cmJ1Zl9yZWxlYXNlKCZycGNfcmVzdWx0KTsKCXN0cmJ1Zl9yZWxlYXNlKCZwcmVhbWJsZSk7Cglhcmd2X2FycmF5X2NsZWFyKCZhcmdzKTsKCXJldHVybiBlcnI7Cn0KCnN0YXRpYyBpbnQgcHVzaChpbnQgbnJfc3BlYywgY29uc3QgY2hhciAqKnNwZWNzKQp7CglzdHJ1Y3QgZGlzY292ZXJ5ICpoZWFkcyA9IGRpc2NvdmVyX3JlZnMoImdpdC1yZWNlaXZlLXBhY2siLCAxKTsKCWludCByZXQ7CgoJaWYgKGhlYWRzLT5wcm90b19naXQpCgkJcmV0ID0gcHVzaF9naXQoaGVhZHMsIG5yX3NwZWMsIHNwZWNzKTsKCWVsc2UKCQlyZXQgPSBwdXNoX2Rhdihucl9zcGVjLCBzcGVjcyk7CglmcmVlX2Rpc2NvdmVyeShoZWFkcyk7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgdm9pZCBwYXJzZV9wdXNoKHN0cnVjdCBzdHJidWYgKmJ1ZikKewoJc3RydWN0IGFyZ3ZfYXJyYXkgc3BlY3MgPSBBUkdWX0FSUkFZX0lOSVQ7CglpbnQgcmV0OwoKCWRvIHsKCQljb25zdCBjaGFyICphcmc7CgkJaWYgKHNraXBfcHJlZml4KGJ1Zi0+YnVmLCAicHVzaCAiLCAmYXJnKSkKCQkJYXJndl9hcnJheV9wdXNoKCZzcGVjcywgYXJnKTsKCQllbHNlCgkJCWRpZShfKCJodHRwIHRyYW5zcG9ydCBkb2VzIG5vdCBzdXBwb3J0ICVzIiksIGJ1Zi0+YnVmKTsKCgkJc3RyYnVmX3Jlc2V0KGJ1Zik7CgkJaWYgKHN0cmJ1Zl9nZXRsaW5lX2xmKGJ1Ziwgc3RkaW4pID09IEVPRikKCQkJZ290byBmcmVlX3NwZWNzOwoJCWlmICghKmJ1Zi0+YnVmKQoJCQlicmVhazsKCX0gd2hpbGUgKDEpOwoKCXJldCA9IHB1c2goc3BlY3MuYXJnYywgc3BlY3MuYXJndik7CglwcmludGYoIlxuIik7CglmZmx1c2goc3Rkb3V0KTsKCglpZiAocmV0KQoJCWV4aXQoMTI4KTsgLyogZXJyb3IgYWxyZWFkeSByZXBvcnRlZCAqLwoKIGZyZWVfc3BlY3M6Cglhcmd2X2FycmF5X2NsZWFyKCZzcGVjcyk7Cn0KCnN0YXRpYyBpbnQgc3RhdGVsZXNzX2Nvbm5lY3QoY29uc3QgY2hhciAqc2VydmljZV9uYW1lKQp7CglzdHJ1Y3QgZGlzY292ZXJ5ICpkaXNjb3ZlcjsKCXN0cnVjdCBycGNfc3RhdGUgcnBjOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCgkvKgoJICogUnVuIHRoZSBpbmZvL3JlZnMgcmVxdWVzdCBhbmQgc2VlIGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgcHJvdG9jb2wKCSAqIHYyLiAgSWYgYW5kIG9ubHkgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyB2MiBjYW4gd2Ugc3VjY2Vzc2Z1bGx5CgkgKiBlc3RhYmxpc2ggYSBzdGF0ZWxlc3MgY29ubmVjdGlvbiwgb3RoZXJ3aXNlIHdlIG5lZWQgdG8gdGVsbCB0aGUKCSAqIGNsaWVudCB0byBmYWxsYmFjayB0byB1c2luZyBvdGhlciB0cmFuc3BvcnQgaGVscGVyIGZ1bmN0aW9ucyB0bwoJICogY29tcGxldGUgdGhlaXIgcmVxdWVzdC4KCSAqLwoJZGlzY292ZXIgPSBkaXNjb3Zlcl9yZWZzKHNlcnZpY2VfbmFtZSwgMCk7CglpZiAoZGlzY292ZXItPnZlcnNpb24gIT0gcHJvdG9jb2xfdjIpIHsKCQlwcmludGYoImZhbGxiYWNrXG4iKTsKCQlmZmx1c2goc3Rkb3V0KTsKCQlyZXR1cm4gLTE7Cgl9IGVsc2UgewoJCS8qIFN0YXRlbGVzcyBDb25uZWN0aW9uIGVzdGFibGlzaGVkICovCgkJcHJpbnRmKCJcbiIpOwoJCWZmbHVzaChzdGRvdXQpOwoJfQoKCXJwYy5zZXJ2aWNlX25hbWUgPSBzZXJ2aWNlX25hbWU7CglycGMuc2VydmljZV91cmwgPSB4c3RyZm10KCIlcyVzIiwgdXJsLmJ1ZiwgcnBjLnNlcnZpY2VfbmFtZSk7CglycGMuaGRyX2NvbnRlbnRfdHlwZSA9IHhzdHJmbXQoIkNvbnRlbnQtVHlwZTogYXBwbGljYXRpb24veC0lcy1yZXF1ZXN0IiwgcnBjLnNlcnZpY2VfbmFtZSk7CglycGMuaGRyX2FjY2VwdCA9IHhzdHJmbXQoIkFjY2VwdDogYXBwbGljYXRpb24veC0lcy1yZXN1bHQiLCBycGMuc2VydmljZV9uYW1lKTsKCWlmIChnZXRfcHJvdG9jb2xfaHR0cF9oZWFkZXIoZGlzY292ZXItPnZlcnNpb24sICZidWYpKSB7CgkJcnBjLnByb3RvY29sX2hlYWRlciA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7Cgl9IGVsc2UgewoJCXJwYy5wcm90b2NvbF9oZWFkZXIgPSBOVUxMOwoJCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJfQoJcnBjLmJ1ZiA9IHhtYWxsb2MoaHR0cF9wb3N0X2J1ZmZlcik7CglycGMuYWxsb2MgPSBodHRwX3Bvc3RfYnVmZmVyOwoJcnBjLmxlbiA9IDA7CglycGMucG9zID0gMDsKCXJwYy5pbiA9IDE7CglycGMub3V0ID0gMDsKCXJwYy5hbnlfd3JpdHRlbiA9IDA7CglycGMuZ3ppcF9yZXF1ZXN0ID0gMTsKCXJwYy5pbml0aWFsX2J1ZmZlciA9IDA7CglycGMud3JpdGVfbGluZV9sZW5ndGhzID0gMTsKCXJwYy5mbHVzaF9yZWFkX2J1dF9ub3Rfc2VudCA9IDA7CgoJLyoKCSAqIER1bXAgdGhlIGNhcGFiaWxpdHkgbGlzdGluZyB0aGF0IHdlIGdvdCBmcm9tIHRoZSBzZXJ2ZXIgZWFybGllcgoJICogZHVyaW5nIHRoZSBpbmZvL3JlZnMgcmVxdWVzdC4KCSAqLwoJd3JpdGVfb3JfZGllKHJwYy5pbiwgZGlzY292ZXItPmJ1ZiwgZGlzY292ZXItPmxlbik7CgoJLyogVW50aWwgd2Ugc2VlIEVPRiBrZWVwIHNlbmRpbmcgUE9TVHMgKi8KCXdoaWxlICgxKSB7CgkJc2l6ZV90IGF2YWlsOwoJCWVudW0gcGFja2V0X3JlYWRfc3RhdHVzIHN0YXR1czsKCgkJaWYgKCFycGNfcmVhZF9mcm9tX291dCgmcnBjLCBQQUNLRVRfUkVBRF9HRU5UTEVfT05fRU9GLCAmYXZhaWwsCgkJCQkgICAgICAgJnN0YXR1cykpCgkJCUJVRygiVGhlIGVudGlyZSBycGMtPmJ1ZiBzaG91bGQgYmUgbGFyZ2VyIHRoYW4gTEFSR0VfUEFDS0VUX01BWCIpOwoJCWlmIChzdGF0dXMgPT0gUEFDS0VUX1JFQURfRU9GKQoJCQlicmVhazsKCQlpZiAocG9zdF9ycGMoJnJwYywgc3RhdHVzID09IFBBQ0tFVF9SRUFEX0ZMVVNIKSkKCQkJLyogV2Ugd291bGQgaGF2ZSBhbiBlcnIgaGVyZSAqLwoJCQlicmVhazsKCQkvKiBSZXNldCB0aGUgYnVmZmVyIGZvciBuZXh0IHJlcXVlc3QgKi8KCQlycGMubGVuID0gMDsKCX0KCglmcmVlKHJwYy5zZXJ2aWNlX3VybCk7CglmcmVlKHJwYy5oZHJfY29udGVudF90eXBlKTsKCWZyZWUocnBjLmhkcl9hY2NlcHQpOwoJZnJlZShycGMucHJvdG9jb2xfaGVhZGVyKTsKCWZyZWUocnBjLmJ1Zik7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCglyZXR1cm4gMDsKfQoKaW50IGNtZF9tYWluKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndikKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWludCBub25naXQ7CgoJc2V0dXBfZ2l0X2RpcmVjdG9yeV9nZW50bHkoJm5vbmdpdCk7CglpZiAoYXJnYyA8IDIpIHsKCQllcnJvcihfKCJyZW1vdGUtY3VybDogdXNhZ2U6IGdpdCByZW1vdGUtY3VybCA8cmVtb3RlPiBbPHVybD5dIikpOwoJCXJldHVybiAxOwoJfQoKCW9wdGlvbnMudmVyYm9zaXR5ID0gMTsKCW9wdGlvbnMucHJvZ3Jlc3MgPSAhIWlzYXR0eSgyKTsKCW9wdGlvbnMudGhpbiA9IDE7CglzdHJpbmdfbGlzdF9pbml0KCZvcHRpb25zLmRlZXBlbl9ub3QsIDEpOwoJc3RyaW5nX2xpc3RfaW5pdCgmb3B0aW9ucy5wdXNoX29wdGlvbnMsIDEpOwoKCS8qCgkgKiBKdXN0IHJlcG9ydCAicmVtb3RlLWN1cmwiIGhlcmUgKGZvbGRpbmcgYWxsIHRoZSB2YXJpb3VzIGFsaWFzZXMKCSAqICgiZ2l0LXJlbW90ZS1odHRwIiwgImdpdC1yZW1vdGUtaHR0cHMiLCBhbmQgZXRjLikgaGVyZSBzaW5jZSB0aGV5CgkgKiBhcmUgYWxsIGp1c3QgY29waWVzIG9mIHRoZSBzYW1lIGFjdHVhbCBleGVjdXRhYmxlLgoJICovCgl0cmFjZTJfY21kX25hbWUoInJlbW90ZS1jdXJsIik7CgoJcmVtb3RlID0gcmVtb3RlX2dldChhcmd2WzFdKTsKCglpZiAoYXJnYyA+IDIpIHsKCQllbmRfdXJsX3dpdGhfc2xhc2goJnVybCwgYXJndlsyXSk7Cgl9IGVsc2UgewoJCWVuZF91cmxfd2l0aF9zbGFzaCgmdXJsLCByZW1vdGUtPnVybFswXSk7Cgl9CgoJaHR0cF9pbml0KHJlbW90ZSwgdXJsLmJ1ZiwgMCk7CgoJZG8gewoJCWNvbnN0IGNoYXIgKmFyZzsKCgkJaWYgKHN0cmJ1Zl9nZXRsaW5lX2xmKCZidWYsIHN0ZGluKSA9PSBFT0YpIHsKCQkJaWYgKGZlcnJvcihzdGRpbikpCgkJCQllcnJvcihfKCJyZW1vdGUtY3VybDogZXJyb3IgcmVhZGluZyBjb21tYW5kIHN0cmVhbSBmcm9tIGdpdCIpKTsKCQkJcmV0dXJuIDE7CgkJfQoJCWlmIChidWYubGVuID09IDApCgkJCWJyZWFrOwoJCWlmIChzdGFydHNfd2l0aChidWYuYnVmLCAiZmV0Y2ggIikpIHsKCQkJaWYgKG5vbmdpdCkKCQkJCWRpZShfKCJyZW1vdGUtY3VybDogZmV0Y2ggYXR0ZW1wdGVkIHdpdGhvdXQgYSBsb2NhbCByZXBvIikpOwoJCQlwYXJzZV9mZXRjaCgmYnVmKTsKCgkJfSBlbHNlIGlmICghc3RyY21wKGJ1Zi5idWYsICJsaXN0IikgfHwgc3RhcnRzX3dpdGgoYnVmLmJ1ZiwgImxpc3QgIikpIHsKCQkJaW50IGZvcl9wdXNoID0gISFzdHJzdHIoYnVmLmJ1ZiArIDQsICJmb3ItcHVzaCIpOwoJCQlvdXRwdXRfcmVmcyhnZXRfcmVmcyhmb3JfcHVzaCkpOwoKCQl9IGVsc2UgaWYgKHN0YXJ0c193aXRoKGJ1Zi5idWYsICJwdXNoICIpKSB7CgkJCXBhcnNlX3B1c2goJmJ1Zik7CgoJCX0gZWxzZSBpZiAoc2tpcF9wcmVmaXgoYnVmLmJ1ZiwgIm9wdGlvbiAiLCAmYXJnKSkgewoJCQljaGFyICp2YWx1ZSA9IHN0cmNocihhcmcsICcgJyk7CgkJCWludCByZXN1bHQ7CgoJCQlpZiAodmFsdWUpCgkJCQkqdmFsdWUrKyA9ICdcMCc7CgkJCWVsc2UKCQkJCXZhbHVlID0gInRydWUiOwoKCQkJcmVzdWx0ID0gc2V0X29wdGlvbihhcmcsIHZhbHVlKTsKCQkJaWYgKCFyZXN1bHQpCgkJCQlwcmludGYoIm9rXG4iKTsKCQkJZWxzZSBpZiAocmVzdWx0IDwgMCkKCQkJCXByaW50ZigiZXJyb3IgaW52YWxpZCB2YWx1ZVxuIik7CgkJCWVsc2UKCQkJCXByaW50ZigidW5zdXBwb3J0ZWRcbiIpOwoJCQlmZmx1c2goc3Rkb3V0KTsKCgkJfSBlbHNlIGlmICghc3RyY21wKGJ1Zi5idWYsICJjYXBhYmlsaXRpZXMiKSkgewoJCQlwcmludGYoInN0YXRlbGVzcy1jb25uZWN0XG4iKTsKCQkJcHJpbnRmKCJmZXRjaFxuIik7CgkJCXByaW50Zigib3B0aW9uXG4iKTsKCQkJcHJpbnRmKCJwdXNoXG4iKTsKCQkJcHJpbnRmKCJjaGVjay1jb25uZWN0aXZpdHlcbiIpOwoJCQlwcmludGYoIm9iamVjdC1mb3JtYXRcbiIpOwoJCQlwcmludGYoIlxuIik7CgkJCWZmbHVzaChzdGRvdXQpOwoJCX0gZWxzZSBpZiAoc2tpcF9wcmVmaXgoYnVmLmJ1ZiwgInN0YXRlbGVzcy1jb25uZWN0ICIsICZhcmcpKSB7CgkJCWlmICghc3RhdGVsZXNzX2Nvbm5lY3QoYXJnKSkKCQkJCWJyZWFrOwoJCX0gZWxzZSB7CgkJCWVycm9yKF8oInJlbW90ZS1jdXJsOiB1bmtub3duIGNvbW1hbmQgJyVzJyBmcm9tIGdpdCIpLCBidWYuYnVmKTsKCQkJcmV0dXJuIDE7CgkJfQoJCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCX0gd2hpbGUgKDEpOwoKCWh0dHBfY2xlYW51cCgpOwoKCXJldHVybiAwOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"config.h\"\n#include \"remote.h\"\n#include \"connect.h\"\n#include \"strbuf.h\"\n#include \"walker.h\"\n#include \"http.h\"\n#include \"exec-cmd.h\"\n#include \"run-command.h\"\n#include \"pkt-line.h\"\n#include \"string-list.h\"\n#include \"sideband.h\"\n#include \"argv-array.h\"\n#include \"credential.h\"\n#include \"oid-array.h\"\n#include \"send-pack.h\"\n#include \"protocol.h\"\n#include \"quote.h\"\n#include \"transport.h\"\n\nstatic struct remote *remote;\n/* always ends with a trailing slash */\nstatic struct strbuf url = STRBUF_INIT;\n\nstruct options {\n\tint verbosity;\n\tunsigned long depth;\n\tchar *deepen_since;\n\tstruct string_list deepen_not;\n\tstruct string_list push_options;\n\tchar *filter;\n\tunsigned progress : 1,\n\t\tcheck_self_contained_and_connected : 1,\n\t\tcloning : 1,\n\t\tupdate_shallow : 1,\n\t\tfollowtags : 1,\n\t\tdry_run : 1,\n\t\tthin : 1,\n\t\t/* One of the SEND_PACK_PUSH_CERT_* constants. */\n\t\tpush_cert : 2,\n\t\tdeepen_relative : 1,\n\t\tfrom_promisor : 1,\n\t\tno_dependents : 1,\n\t\tatomic : 1,\n\t\tobject_format : 1;\n\tconst struct git_hash_algo *hash_algo;\n};\nstatic struct options options;\nstatic struct string_list cas_options = STRING_LIST_INIT_DUP;\n\nstatic int set_option(const char *name, const char *value)\n{\n\tif (!strcmp(name, \"verbosity\")) {\n\t\tchar *end;\n\t\tint v = strtol(value, &end, 10);\n\t\tif (value == end || *end)\n\t\t\treturn -1;\n\t\toptions.verbosity = v;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"progress\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.progress = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.progress = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"depth\")) {\n\t\tchar *end;\n\t\tunsigned long v = strtoul(value, &end, 10);\n\t\tif (value == end || *end)\n\t\t\treturn -1;\n\t\toptions.depth = v;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"deepen-since\")) {\n\t\toptions.deepen_since = xstrdup(value);\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"deepen-not\")) {\n\t\tstring_list_append(&options.deepen_not, value);\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"deepen-relative\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.deepen_relative = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.deepen_relative = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"followtags\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.followtags = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.followtags = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"dry-run\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.dry_run = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.dry_run = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"check-connectivity\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.check_self_contained_and_connected = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.check_self_contained_and_connected = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"cas\")) {\n\t\tstruct strbuf val = STRBUF_INIT;\n\t\tstrbuf_addf(&val, \"--\" CAS_OPT_NAME \"=%s\", value);\n\t\tstring_list_append(&cas_options, val.buf);\n\t\tstrbuf_release(&val);\n\t\treturn 0;\n\t} else if (!strcmp(name, \"cloning\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.cloning = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.cloning = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"update-shallow\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.update_shallow = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.update_shallow = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"pushcert\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.push_cert = SEND_PACK_PUSH_CERT_ALWAYS;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.push_cert = SEND_PACK_PUSH_CERT_NEVER;\n\t\telse if (!strcmp(value, \"if-asked\"))\n\t\t\toptions.push_cert = SEND_PACK_PUSH_CERT_IF_ASKED;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"atomic\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.atomic = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.atomic = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"push-option\")) {\n\t\tif (*value != '\"')\n\t\t\tstring_list_append(&options.push_options, value);\n\t\telse {\n\t\t\tstruct strbuf unquoted = STRBUF_INIT;\n\t\t\tif (unquote_c_style(&unquoted, value, NULL) < 0)\n\t\t\t\tdie(_(\"invalid quoting in push-option value: '%s'\"), value);\n\t\t\tstring_list_append_nodup(&options.push_options,\n\t\t\t\t\t\t strbuf_detach(&unquoted, NULL));\n\t\t}\n\t\treturn 0;\n\n#if LIBCURL_VERSION_NUM >= 0x070a08\n\t} else if (!strcmp(name, \"family\")) {\n\t\tif (!strcmp(value, \"ipv4\"))\n\t\t\tgit_curl_ipresolve = CURL_IPRESOLVE_V4;\n\t\telse if (!strcmp(value, \"ipv6\"))\n\t\t\tgit_curl_ipresolve = CURL_IPRESOLVE_V6;\n\t\telse if (!strcmp(value, \"all\"))\n\t\t\tgit_curl_ipresolve = CURL_IPRESOLVE_WHATEVER;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n#endif /* LIBCURL_VERSION_NUM >= 0x070a08 */\n\t} else if (!strcmp(name, \"from-promisor\")) {\n\t\toptions.from_promisor = 1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"no-dependents\")) {\n\t\toptions.no_dependents = 1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"filter\")) {\n\t\toptions.filter = xstrdup(value);\n\t\treturn 0;\n\t} else if (!strcmp(name, \"object-format\")) {\n\t\tint algo;\n\t\toptions.object_format = 1;\n\t\tif (strcmp(value, \"true\")) {\n\t\t\talgo = hash_algo_by_name(value);\n\t\t\tif (algo == GIT_HASH_UNKNOWN)\n\t\t\t\tdie(\"unknown object format '%s'\", value);\n\t\t\toptions.hash_algo = &hash_algos[algo];\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\treturn 1 /* unsupported */;\n\t}\n}\n\nstruct discovery {\n\tchar *service;\n\tchar *buf_alloc;\n\tchar *buf;\n\tsize_t len;\n\tstruct ref *refs;\n\tstruct oid_array shallow;\n\tenum protocol_version version;\n\tunsigned proto_git : 1;\n};\nstatic struct discovery *last_discovery;\n\nstatic struct ref *parse_git_refs(struct discovery *heads, int for_push)\n{\n\tstruct ref *list = NULL;\n\tstruct packet_reader reader;\n\n\tpacket_reader_init(&reader, -1, heads->buf, heads->len,\n\t\t\t   PACKET_READ_CHOMP_NEWLINE |\n\t\t\t   PACKET_READ_GENTLE_ON_EOF |\n\t\t\t   PACKET_READ_DIE_ON_ERR_PACKET);\n\n\theads->version = discover_version(&reader);\n\tswitch (heads->version) {\n\tcase protocol_v2:\n\t\t/*\n\t\t * Do nothing.  This isn't a list of refs but rather a\n\t\t * capability advertisement.  Client would have run\n\t\t * 'stateless-connect' so we'll dump this capability listing\n\t\t * and let them request the refs themselves.\n\t\t */\n\t\tbreak;\n\tcase protocol_v1:\n\tcase protocol_v0:\n\t\tget_remote_heads(&reader, &list, for_push ? REF_NORMAL : 0,\n\t\t\t\t NULL, &heads->shallow);\n\t\toptions.hash_algo = reader.hash_algo;\n\t\tbreak;\n\tcase protocol_unknown_version:\n\t\tBUG(\"unknown protocol version\");\n\t}\n\n\treturn list;\n}\n\nstatic const struct git_hash_algo *detect_hash_algo(struct discovery *heads)\n{\n\tconst char *p = memchr(heads->buf, '\\t', heads->len);\n\tint algo;\n\tif (!p)\n\t\treturn the_hash_algo;\n\n\talgo = hash_algo_by_length((p - heads->buf) / 2);\n\tif (algo == GIT_HASH_UNKNOWN)\n\t\treturn NULL;\n\treturn &hash_algos[algo];\n}\n\nstatic struct ref *parse_info_refs(struct discovery *heads)\n{\n\tchar *data, *start, *mid;\n\tchar *ref_name;\n\tint i = 0;\n\n\tstruct ref *refs = NULL;\n\tstruct ref *ref = NULL;\n\tstruct ref *last_ref = NULL;\n\n\toptions.hash_algo = detect_hash_algo(heads);\n\tif (!options.hash_algo)\n\t\tdie(\"%sinfo/refs not valid: could not determine hash algorithm; \"\n\t\t    \"is this a git repository?\",\n\t\t    transport_anonymize_url(url.buf));\n\n\tdata = heads->buf;\n\tstart = NULL;\n\tmid = data;\n\twhile (i < heads->len) {\n\t\tif (!start) {\n\t\t\tstart = &data[i];\n\t\t}\n\t\tif (data[i] == '\\t')\n\t\t\tmid = &data[i];\n\t\tif (data[i] == '\\n') {\n\t\t\tif (mid - start != options.hash_algo->hexsz)\n\t\t\t\tdie(_(\"%sinfo/refs not valid: is this a git repository?\"),\n\t\t\t\t    transport_anonymize_url(url.buf));\n\t\t\tdata[i] = 0;\n\t\t\tref_name = mid + 1;\n\t\t\tref = alloc_ref(ref_name);\n\t\t\tget_oid_hex_algop(start, &ref->old_oid, options.hash_algo);\n\t\t\tif (!refs)\n\t\t\t\trefs = ref;\n\t\t\tif (last_ref)\n\t\t\t\tlast_ref->next = ref;\n\t\t\tlast_ref = ref;\n\t\t\tstart = NULL;\n\t\t}\n\t\ti++;\n\t}\n\n\tref = alloc_ref(\"HEAD\");\n\tif (!http_fetch_ref(url.buf, ref) &&\n\t    !resolve_remote_symref(ref, refs)) {\n\t\tref->next = refs;\n\t\trefs = ref;\n\t} else {\n\t\tfree(ref);\n\t}\n\n\treturn refs;\n}\n\nstatic void free_discovery(struct discovery *d)\n{\n\tif (d) {\n\t\tif (d == last_discovery)\n\t\t\tlast_discovery = NULL;\n\t\tfree(d->shallow.oid);\n\t\tfree(d->buf_alloc);\n\t\tfree_refs(d->refs);\n\t\tfree(d->service);\n\t\tfree(d);\n\t}\n}\n\nstatic int show_http_message(struct strbuf *type, struct strbuf *charset,\n\t\t\t     struct strbuf *msg)\n{\n\tconst char *p, *eol;\n\n\t/*\n\t * We only show text/plain parts, as other types are likely\n\t * to be ugly to look at on the user's terminal.\n\t */\n\tif (strcmp(type->buf, \"text/plain\"))\n\t\treturn -1;\n\tif (charset->len)\n\t\tstrbuf_reencode(msg, charset->buf, get_log_output_encoding());\n\n\tstrbuf_trim(msg);\n\tif (!msg->len)\n\t\treturn -1;\n\n\tp = msg->buf;\n\tdo {\n\t\teol = strchrnul(p, '\\n');\n\t\tfprintf(stderr, \"remote: %.*s\\n\", (int)(eol - p), p);\n\t\tp = eol + 1;\n\t} while(*eol);\n\treturn 0;\n}\n\nstatic int get_protocol_http_header(enum protocol_version version,\n\t\t\t\t    struct strbuf *header)\n{\n\tif (version > 0) {\n\t\tstrbuf_addf(header, GIT_PROTOCOL_HEADER \": version=%d\",\n\t\t\t    version);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void check_smart_http(struct discovery *d, const char *service,\n\t\t\t     struct strbuf *type)\n{\n\tconst char *p;\n\tstruct packet_reader reader;\n\n\t/*\n\t * If we don't see x-$service-advertisement, then it's not smart-http.\n\t * But once we do, we commit to it and assume any other protocol\n\t * violations are hard errors.\n\t */\n\tif (!skip_prefix(type->buf, \"application/x-\", &p) ||\n\t    !skip_prefix(p, service, &p) ||\n\t    strcmp(p, \"-advertisement\"))\n\t\treturn;\n\n\tpacket_reader_init(&reader, -1, d->buf, d->len,\n\t\t\t   PACKET_READ_CHOMP_NEWLINE |\n\t\t\t   PACKET_READ_DIE_ON_ERR_PACKET);\n\tif (packet_reader_read(&reader) != PACKET_READ_NORMAL)\n\t\tdie(_(\"invalid server response; expected service, got flush packet\"));\n\n\tif (skip_prefix(reader.line, \"# service=\", &p) && !strcmp(p, service)) {\n\t\t/*\n\t\t * The header can include additional metadata lines, up\n\t\t * until a packet flush marker.  Ignore these now, but\n\t\t * in the future we might start to scan them.\n\t\t */\n\t\tfor (;;) {\n\t\t\tpacket_reader_read(&reader);\n\t\t\tif (reader.pktlen <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * v0 smart http; callers expect us to soak up the\n\t\t * service and header packets\n\t\t */\n\t\td->buf = reader.src_buffer;\n\t\td->len = reader.src_len;\n\t\td->proto_git = 1;\n\n\t} else if (!strcmp(reader.line, \"version 2\")) {\n\t\t/*\n\t\t * v2 smart http; do not consume version packet, which will\n\t\t * be handled elsewhere.\n\t\t */\n\t\td->proto_git = 1;\n\n\t} else {\n\t\tdie(_(\"invalid server response; got '%s'\"), reader.line);\n\t}\n}\n\nstatic struct discovery *discover_refs(const char *service, int for_push)\n{\n\tstruct strbuf type = STRBUF_INIT;\n\tstruct strbuf charset = STRBUF_INIT;\n\tstruct strbuf buffer = STRBUF_INIT;\n\tstruct strbuf refs_url = STRBUF_INIT;\n\tstruct strbuf effective_url = STRBUF_INIT;\n\tstruct strbuf protocol_header = STRBUF_INIT;\n\tstruct string_list extra_headers = STRING_LIST_INIT_DUP;\n\tstruct discovery *last = last_discovery;\n\tint http_ret, maybe_smart = 0;\n\tstruct http_get_options http_options;\n\tenum protocol_version version = get_protocol_version_config();\n\n\tif (last && !strcmp(service, last->service))\n\t\treturn last;\n\tfree_discovery(last);\n\n\tstrbuf_addf(&refs_url, \"%sinfo/refs\", url.buf);\n\tif ((starts_with(url.buf, \"http://\") || starts_with(url.buf, \"https://\")) &&\n\t     git_env_bool(\"GIT_SMART_HTTP\", 1)) {\n\t\tmaybe_smart = 1;\n\t\tif (!strchr(url.buf, '?'))\n\t\t\tstrbuf_addch(&refs_url, '?');\n\t\telse\n\t\t\tstrbuf_addch(&refs_url, '&');\n\t\tstrbuf_addf(&refs_url, \"service=%s\", service);\n\t}\n\n\t/*\n\t * NEEDSWORK: If we are trying to use protocol v2 and we are planning\n\t * to perform a push, then fallback to v0 since the client doesn't know\n\t * how to push yet using v2.\n\t */\n\tif (version == protocol_v2 && !strcmp(\"git-receive-pack\", service))\n\t\tversion = protocol_v0;\n\n\t/* Add the extra Git-Protocol header */\n\tif (get_protocol_http_header(version, &protocol_header))\n\t\tstring_list_append(&extra_headers, protocol_header.buf);\n\n\tmemset(&http_options, 0, sizeof(http_options));\n\thttp_options.content_type = &type;\n\thttp_options.charset = &charset;\n\thttp_options.effective_url = &effective_url;\n\thttp_options.base_url = &url;\n\thttp_options.extra_headers = &extra_headers;\n\thttp_options.initial_request = 1;\n\thttp_options.no_cache = 1;\n\n\thttp_ret = http_get_strbuf(refs_url.buf, &buffer, &http_options);\n\tswitch (http_ret) {\n\tcase HTTP_OK:\n\t\tbreak;\n\tcase HTTP_MISSING_TARGET:\n\t\tshow_http_message(&type, &charset, &buffer);\n\t\tdie(_(\"repository '%s' not found\"),\n\t\t    transport_anonymize_url(url.buf));\n\tcase HTTP_NOAUTH:\n\t\tshow_http_message(&type, &charset, &buffer);\n\t\tdie(_(\"Authentication failed for '%s'\"),\n\t\t    transport_anonymize_url(url.buf));\n\tdefault:\n\t\tshow_http_message(&type, &charset, &buffer);\n\t\tdie(_(\"unable to access '%s': %s\"),\n\t\t    transport_anonymize_url(url.buf), curl_errorstr);\n\t}\n\n\tif (options.verbosity && !starts_with(refs_url.buf, url.buf)) {\n\t\tchar *u = transport_anonymize_url(url.buf);\n\t\twarning(_(\"redirecting to %s\"), u);\n\t\tfree(u);\n\t}\n\n\tlast= xcalloc(1, sizeof(*last_discovery));\n\tlast->service = xstrdup(service);\n\tlast->buf_alloc = strbuf_detach(&buffer, &last->len);\n\tlast->buf = last->buf_alloc;\n\n\tif (maybe_smart)\n\t\tcheck_smart_http(last, service, &type);\n\n\tif (last->proto_git)\n\t\tlast->refs = parse_git_refs(last, for_push);\n\telse\n\t\tlast->refs = parse_info_refs(last);\n\n\tstrbuf_release(&refs_url);\n\tstrbuf_release(&type);\n\tstrbuf_release(&charset);\n\tstrbuf_release(&effective_url);\n\tstrbuf_release(&buffer);\n\tstrbuf_release(&protocol_header);\n\tstring_list_clear(&extra_headers, 0);\n\tlast_discovery = last;\n\treturn last;\n}\n\nstatic struct ref *get_refs(int for_push)\n{\n\tstruct discovery *heads;\n\n\tif (for_push)\n\t\theads = discover_refs(\"git-receive-pack\", for_push);\n\telse\n\t\theads = discover_refs(\"git-upload-pack\", for_push);\n\n\treturn heads->refs;\n}\n\nstatic void output_refs(struct ref *refs)\n{\n\tstruct ref *posn;\n\tif (options.object_format && options.hash_algo) {\n\t\tprintf(\":object-format %s\\n\", options.hash_algo->name);\n\t}\n\tfor (posn = refs; posn; posn = posn->next) {\n\t\tif (posn->symref)\n\t\t\tprintf(\"@%s %s\\n\", posn->symref, posn->name);\n\t\telse\n\t\t\tprintf(\"%s %s\\n\", hash_to_hex_algop(posn->old_oid.hash,\n\t\t\t\t\t\t\t    options.hash_algo),\n\t\t\t\t\t  posn->name);\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);\n}\n\nstruct rpc_state {\n\tconst char *service_name;\n\tchar *service_url;\n\tchar *hdr_content_type;\n\tchar *hdr_accept;\n\tchar *protocol_header;\n\tchar *buf;\n\tsize_t alloc;\n\tsize_t len;\n\tsize_t pos;\n\tint in;\n\tint out;\n\tint any_written;\n\tunsigned gzip_request : 1;\n\tunsigned initial_buffer : 1;\n\n\t/*\n\t * Whenever a pkt-line is read into buf, append the 4 characters\n\t * denoting its length before appending the payload.\n\t */\n\tunsigned write_line_lengths : 1;\n\n\t/*\n\t * Used by rpc_out; initialize to 0. This is true if a flush has been\n\t * read, but the corresponding line length (if write_line_lengths is\n\t * true) and EOF have not been sent to libcurl. Since each flush marks\n\t * the end of a request, each flush must be completely sent before any\n\t * further reading occurs.\n\t */\n\tunsigned flush_read_but_not_sent : 1;\n};\n\n/*\n * Appends the result of reading from rpc->out to the string represented by\n * rpc->buf and rpc->len if there is enough space. Returns 1 if there was\n * enough space, 0 otherwise.\n *\n * If rpc->write_line_lengths is true, appends the line length as a 4-byte\n * hexadecimal string before appending the result described above.\n *\n * Writes the total number of bytes appended into appended.\n */\nstatic int rpc_read_from_out(struct rpc_state *rpc, int options,\n\t\t\t     size_t *appended,\n\t\t\t     enum packet_read_status *status) {\n\tsize_t left;\n\tchar *buf;\n\tint pktlen_raw;\n\n\tif (rpc->write_line_lengths) {\n\t\tleft = rpc->alloc - rpc->len - 4;\n\t\tbuf = rpc->buf + rpc->len + 4;\n\t} else {\n\t\tleft = rpc->alloc - rpc->len;\n\t\tbuf = rpc->buf + rpc->len;\n\t}\n\n\tif (left < LARGE_PACKET_MAX)\n\t\treturn 0;\n\n\t*status = packet_read_with_status(rpc->out, NULL, NULL, buf,\n\t\t\tleft, &pktlen_raw, options);\n\tif (*status != PACKET_READ_EOF) {\n\t\t*appended = pktlen_raw + (rpc->write_line_lengths ? 4 : 0);\n\t\trpc->len += *appended;\n\t}\n\n\tif (rpc->write_line_lengths) {\n\t\tswitch (*status) {\n\t\tcase PACKET_READ_EOF:\n\t\t\tif (!(options & PACKET_READ_GENTLE_ON_EOF))\n\t\t\t\tdie(_(\"shouldn't have EOF when not gentle on EOF\"));\n\t\t\tbreak;\n\t\tcase PACKET_READ_NORMAL:\n\t\t\tset_packet_header(buf - 4, *appended);\n\t\t\tbreak;\n\t\tcase PACKET_READ_DELIM:\n\t\t\tmemcpy(buf - 4, \"0001\", 4);\n\t\t\tbreak;\n\t\tcase PACKET_READ_FLUSH:\n\t\t\tmemcpy(buf - 4, \"0000\", 4);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic size_t rpc_out(void *ptr, size_t eltsize,\n\t\tsize_t nmemb, void *buffer_)\n{\n\tsize_t max = eltsize * nmemb;\n\tstruct rpc_state *rpc = buffer_;\n\tsize_t avail = rpc->len - rpc->pos;\n\tenum packet_read_status status;\n\n\tif (!avail) {\n\t\trpc->initial_buffer = 0;\n\t\trpc->len = 0;\n\t\trpc->pos = 0;\n\t\tif (!rpc->flush_read_but_not_sent) {\n\t\t\tif (!rpc_read_from_out(rpc, 0, &avail, &status))\n\t\t\t\tBUG(\"The entire rpc->buf should be larger than LARGE_PACKET_MAX\");\n\t\t\tif (status == PACKET_READ_FLUSH)\n\t\t\t\trpc->flush_read_but_not_sent = 1;\n\t\t}\n\t\t/*\n\t\t * If flush_read_but_not_sent is true, we have already read one\n\t\t * full request but have not fully sent it + EOF, which is why\n\t\t * we need to refrain from reading.\n\t\t */\n\t}\n\tif (rpc->flush_read_but_not_sent) {\n\t\tif (!avail) {\n\t\t\t/*\n\t\t\t * The line length either does not need to be sent at\n\t\t\t * all or has already been completely sent. Now we can\n\t\t\t * return 0, indicating EOF, meaning that the flush has\n\t\t\t * been fully sent.\n\t\t\t */\n\t\t\trpc->flush_read_but_not_sent = 0;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * If avail is non-zerp, the line length for the flush still\n\t\t * hasn't been fully sent. Proceed with sending the line\n\t\t * length.\n\t\t */\n\t}\n\n\tif (max < avail)\n\t\tavail = max;\n\tmemcpy(ptr, rpc->buf + rpc->pos, avail);\n\trpc->pos += avail;\n\treturn avail;\n}\n\n#ifndef NO_CURL_IOCTL\nstatic curlioerr rpc_ioctl(CURL *handle, int cmd, void *clientp)\n{\n\tstruct rpc_state *rpc = clientp;\n\n\tswitch (cmd) {\n\tcase CURLIOCMD_NOP:\n\t\treturn CURLIOE_OK;\n\n\tcase CURLIOCMD_RESTARTREAD:\n\t\tif (rpc->initial_buffer) {\n\t\t\trpc->pos = 0;\n\t\t\treturn CURLIOE_OK;\n\t\t}\n\t\terror(_(\"unable to rewind rpc post data - try increasing http.postBuffer\"));\n\t\treturn CURLIOE_FAILRESTART;\n\n\tdefault:\n\t\treturn CURLIOE_UNKNOWNCMD;\n\t}\n}\n#endif\n\nstruct rpc_in_data {\n\tstruct rpc_state *rpc;\n\tstruct active_request_slot *slot;\n};\n\n/*\n * A callback for CURLOPT_WRITEFUNCTION. The return value is the bytes consumed\n * from ptr.\n */\nstatic size_t rpc_in(char *ptr, size_t eltsize,\n\t\tsize_t nmemb, void *buffer_)\n{\n\tsize_t size = eltsize * nmemb;\n\tstruct rpc_in_data *data = buffer_;\n\tlong response_code;\n\n\tif (curl_easy_getinfo(data->slot->curl, CURLINFO_RESPONSE_CODE,\n\t\t\t      &response_code) != CURLE_OK)\n\t\treturn size;\n\tif (response_code >= 300)\n\t\treturn size;\n\tif (size)\n\t\tdata->rpc->any_written = 1;\n\twrite_or_die(data->rpc->in, ptr, size);\n\treturn size;\n}\n\nstatic int run_slot(struct active_request_slot *slot,\n\t\t    struct slot_results *results)\n{\n\tint err;\n\tstruct slot_results results_buf;\n\n\tif (!results)\n\t\tresults = &results_buf;\n\n\terr = run_one_slot(slot, results);\n\n\tif (err != HTTP_OK && err != HTTP_REAUTH) {\n\t\tstruct strbuf msg = STRBUF_INIT;\n\t\tif (results->http_code && results->http_code != 200)\n\t\t\tstrbuf_addf(&msg, \"HTTP %ld\", results->http_code);\n\t\tif (results->curl_result != CURLE_OK) {\n\t\t\tif (msg.len)\n\t\t\t\tstrbuf_addch(&msg, ' ');\n\t\t\tstrbuf_addf(&msg, \"curl %d\", results->curl_result);\n\t\t\tif (curl_errorstr[0]) {\n\t\t\t\tstrbuf_addch(&msg, ' ');\n\t\t\t\tstrbuf_addstr(&msg, curl_errorstr);\n\t\t\t}\n\t\t}\n\t\terror(_(\"RPC failed; %s\"), msg.buf);\n\t\tstrbuf_release(&msg);\n\t}\n\n\treturn err;\n}\n\nstatic int probe_rpc(struct rpc_state *rpc, struct slot_results *results)\n{\n\tstruct active_request_slot *slot;\n\tstruct curl_slist *headers = http_copy_default_headers();\n\tstruct strbuf buf = STRBUF_INIT;\n\tint err;\n\n\tslot = get_active_slot();\n\n\theaders = curl_slist_append(headers, rpc->hdr_content_type);\n\theaders = curl_slist_append(headers, rpc->hdr_accept);\n\n\tcurl_easy_setopt(slot->curl, CURLOPT_NOBODY, 0);\n\tcurl_easy_setopt(slot->curl, CURLOPT_POST, 1);\n\tcurl_easy_setopt(slot->curl, CURLOPT_URL, rpc->service_url);\n\tcurl_easy_setopt(slot->curl, CURLOPT_ENCODING, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, \"0000\");\n\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE, 4);\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, headers);\n\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION, fwrite_buffer);\n\tcurl_easy_setopt(slot->curl, CURLOPT_FILE, &buf);\n\n\terr = run_slot(slot, results);\n\n\tcurl_slist_free_all(headers);\n\tstrbuf_release(&buf);\n\treturn err;\n}\n\nstatic curl_off_t xcurl_off_t(size_t len)\n{\n\tuintmax_t size = len;\n\tif (size > maximum_signed_value_of_type(curl_off_t))\n\t\tdie(_(\"cannot handle pushes this big\"));\n\treturn (curl_off_t)size;\n}\n\n/*\n * If flush_received is true, do not attempt to read any more; just use what's\n * in rpc->buf.\n */\nstatic int post_rpc(struct rpc_state *rpc, int flush_received)\n{\n\tstruct active_request_slot *slot;\n\tstruct curl_slist *headers = http_copy_default_headers();\n\tint use_gzip = rpc->gzip_request;\n\tchar *gzip_body = NULL;\n\tsize_t gzip_size = 0;\n\tint err, large_request = 0;\n\tint needs_100_continue = 0;\n\tstruct rpc_in_data rpc_in_data;\n\n\t/* Try to load the entire request, if we can fit it into the\n\t * allocated buffer space we can use HTTP/1.0 and avoid the\n\t * chunked encoding mess.\n\t */\n\tif (!flush_received) {\n\t\twhile (1) {\n\t\t\tsize_t n;\n\t\t\tenum packet_read_status status;\n\n\t\t\tif (!rpc_read_from_out(rpc, 0, &n, &status)) {\n\t\t\t\tlarge_request = 1;\n\t\t\t\tuse_gzip = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (status == PACKET_READ_FLUSH)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (large_request) {\n\t\tstruct slot_results results;\n\n\t\tdo {\n\t\t\terr = probe_rpc(rpc, &results);\n\t\t\tif (err == HTTP_REAUTH)\n\t\t\t\tcredential_fill(&http_auth);\n\t\t} while (err == HTTP_REAUTH);\n\t\tif (err != HTTP_OK)\n\t\t\treturn -1;\n\n\t\tif (results.auth_avail & CURLAUTH_GSSNEGOTIATE)\n\t\t\tneeds_100_continue = 1;\n\t}\n\n\theaders = curl_slist_append(headers, rpc->hdr_content_type);\n\theaders = curl_slist_append(headers, rpc->hdr_accept);\n\theaders = curl_slist_append(headers, needs_100_continue ?\n\t\t\"Expect: 100-continue\" : \"Expect:\");\n\n\t/* Add the extra Git-Protocol header */\n\tif (rpc->protocol_header)\n\t\theaders = curl_slist_append(headers, rpc->protocol_header);\n\nretry:\n\tslot = get_active_slot();\n\n\tcurl_easy_setopt(slot->curl, CURLOPT_NOBODY, 0);\n\tcurl_easy_setopt(slot->curl, CURLOPT_POST, 1);\n\tcurl_easy_setopt(slot->curl, CURLOPT_URL, rpc->service_url);\n\tcurl_easy_setopt(slot->curl, CURLOPT_ENCODING, \"\");\n\n\tif (large_request) {\n\t\t/* The request body is large and the size cannot be predicted.\n\t\t * We must use chunked encoding to send it.\n\t\t */\n\t\theaders = curl_slist_append(headers, \"Transfer-Encoding: chunked\");\n\t\trpc->initial_buffer = 1;\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_READFUNCTION, rpc_out);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_INFILE, rpc);\n#ifndef NO_CURL_IOCTL\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_IOCTLFUNCTION, rpc_ioctl);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_IOCTLDATA, rpc);\n#endif\n\t\tif (options.verbosity > 1) {\n\t\t\tfprintf(stderr, \"POST %s (chunked)\\n\", rpc->service_name);\n\t\t\tfflush(stderr);\n\t\t}\n\n\t} else if (gzip_body) {\n\t\t/*\n\t\t * If we are looping to retry authentication, then the previous\n\t\t * run will have set up the headers and gzip buffer already,\n\t\t * and we just need to send it.\n\t\t */\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, gzip_body);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE_LARGE, xcurl_off_t(gzip_size));\n\n\t} else if (use_gzip && 1024 < rpc->len) {\n\t\t/* The client backend isn't giving us compressed data so\n\t\t * we can try to deflate it ourselves, this may save on\n\t\t * the transfer time.\n\t\t */\n\t\tgit_zstream stream;\n\t\tint ret;\n\n\t\tgit_deflate_init_gzip(&stream, Z_BEST_COMPRESSION);\n\t\tgzip_size = git_deflate_bound(&stream, rpc->len);\n\t\tgzip_body = xmalloc(gzip_size);\n\n\t\tstream.next_in = (unsigned char *)rpc->buf;\n\t\tstream.avail_in = rpc->len;\n\t\tstream.next_out = (unsigned char *)gzip_body;\n\t\tstream.avail_out = gzip_size;\n\n\t\tret = git_deflate(&stream, Z_FINISH);\n\t\tif (ret != Z_STREAM_END)\n\t\t\tdie(_(\"cannot deflate request; zlib deflate error %d\"), ret);\n\n\t\tret = git_deflate_end_gently(&stream);\n\t\tif (ret != Z_OK)\n\t\t\tdie(_(\"cannot deflate request; zlib end error %d\"), ret);\n\n\t\tgzip_size = stream.total_out;\n\n\t\theaders = curl_slist_append(headers, \"Content-Encoding: gzip\");\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, gzip_body);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE_LARGE, xcurl_off_t(gzip_size));\n\n\t\tif (options.verbosity > 1) {\n\t\t\tfprintf(stderr, \"POST %s (gzip %lu to %lu bytes)\\n\",\n\t\t\t\trpc->service_name,\n\t\t\t\t(unsigned long)rpc->len, (unsigned long)gzip_size);\n\t\t\tfflush(stderr);\n\t\t}\n\t} else {\n\t\t/* We know the complete request size in advance, use the\n\t\t * more normal Content-Length approach.\n\t\t */\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, rpc->buf);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE_LARGE, xcurl_off_t(rpc->len));\n\t\tif (options.verbosity > 1) {\n\t\t\tfprintf(stderr, \"POST %s (%lu bytes)\\n\",\n\t\t\t\trpc->service_name, (unsigned long)rpc->len);\n\t\t\tfflush(stderr);\n\t\t}\n\t}\n\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, headers);\n\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION, rpc_in);\n\trpc_in_data.rpc = rpc;\n\trpc_in_data.slot = slot;\n\tcurl_easy_setopt(slot->curl, CURLOPT_FILE, &rpc_in_data);\n\tcurl_easy_setopt(slot->curl, CURLOPT_FAILONERROR, 0);\n\n\n\trpc->any_written = 0;\n\terr = run_slot(slot, NULL);\n\tif (err == HTTP_REAUTH && !large_request) {\n\t\tcredential_fill(&http_auth);\n\t\tgoto retry;\n\t}\n\tif (err != HTTP_OK)\n\t\terr = -1;\n\n\tif (!rpc->any_written)\n\t\terr = -1;\n\n\tcurl_slist_free_all(headers);\n\tfree(gzip_body);\n\treturn err;\n}\n\nstatic int rpc_service(struct rpc_state *rpc, struct discovery *heads,\n\t\t       const char **client_argv, const struct strbuf *preamble,\n\t\t       struct strbuf *rpc_result)\n{\n\tconst char *svc = rpc->service_name;\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct child_process client = CHILD_PROCESS_INIT;\n\tint err = 0;\n\n\tclient.in = -1;\n\tclient.out = -1;\n\tclient.git_cmd = 1;\n\tclient.argv = client_argv;\n\tif (start_command(&client))\n\t\texit(1);\n\twrite_or_die(client.in, preamble->buf, preamble->len);\n\tif (heads)\n\t\twrite_or_die(client.in, heads->buf, heads->len);\n\n\trpc->alloc = http_post_buffer;\n\trpc->buf = xmalloc(rpc->alloc);\n\trpc->in = client.in;\n\trpc->out = client.out;\n\n\tstrbuf_addf(&buf, \"%s%s\", url.buf, svc);\n\trpc->service_url = strbuf_detach(&buf, NULL);\n\n\tstrbuf_addf(&buf, \"Content-Type: application/x-%s-request\", svc);\n\trpc->hdr_content_type = strbuf_detach(&buf, NULL);\n\n\tstrbuf_addf(&buf, \"Accept: application/x-%s-result\", svc);\n\trpc->hdr_accept = strbuf_detach(&buf, NULL);\n\n\tif (get_protocol_http_header(heads->version, &buf))\n\t\trpc->protocol_header = strbuf_detach(&buf, NULL);\n\telse\n\t\trpc->protocol_header = NULL;\n\n\twhile (!err) {\n\t\tint n = packet_read(rpc->out, NULL, NULL, rpc->buf, rpc->alloc, 0);\n\t\tif (!n)\n\t\t\tbreak;\n\t\trpc->pos = 0;\n\t\trpc->len = n;\n\t\terr |= post_rpc(rpc, 0);\n\t}\n\n\tclose(client.in);\n\tclient.in = -1;\n\tif (!err) {\n\t\tstrbuf_read(rpc_result, client.out, 0);\n\t} else {\n\t\tchar buf[4096];\n\t\tfor (;;)\n\t\t\tif (xread(client.out, buf, sizeof(buf)) <= 0)\n\t\t\t\tbreak;\n\t}\n\n\tclose(client.out);\n\tclient.out = -1;\n\n\terr |= finish_command(&client);\n\tfree(rpc->service_url);\n\tfree(rpc->hdr_content_type);\n\tfree(rpc->hdr_accept);\n\tfree(rpc->protocol_header);\n\tfree(rpc->buf);\n\tstrbuf_release(&buf);\n\treturn err;\n}\n\nstatic int fetch_dumb(int nr_heads, struct ref **to_fetch)\n{\n\tstruct walker *walker;\n\tchar **targets;\n\tint ret, i;\n\n\tALLOC_ARRAY(targets, nr_heads);\n\tif (options.depth || options.deepen_since)\n\t\tdie(_(\"dumb http transport does not support shallow capabilities\"));\n\tfor (i = 0; i < nr_heads; i++)\n\t\ttargets[i] = xstrdup(oid_to_hex(&to_fetch[i]->old_oid));\n\n\twalker = get_http_walker(url.buf);\n\twalker->get_verbosely = options.verbosity >= 3;\n\twalker->get_progress = options.progress;\n\twalker->get_recover = 0;\n\tret = walker_fetch(walker, nr_heads, targets, NULL, NULL);\n\twalker_free(walker);\n\n\tfor (i = 0; i < nr_heads; i++)\n\t\tfree(targets[i]);\n\tfree(targets);\n\n\treturn ret ? error(_(\"fetch failed.\")) : 0;\n}\n\nstatic int fetch_git(struct discovery *heads,\n\tint nr_heads, struct ref **to_fetch)\n{\n\tstruct rpc_state rpc;\n\tstruct strbuf preamble = STRBUF_INIT;\n\tint i, err;\n\tstruct argv_array args = ARGV_ARRAY_INIT;\n\tstruct strbuf rpc_result = STRBUF_INIT;\n\n\targv_array_pushl(&args, \"fetch-pack\", \"--stateless-rpc\",\n\t\t\t \"--stdin\", \"--lock-pack\", NULL);\n\tif (options.followtags)\n\t\targv_array_push(&args, \"--include-tag\");\n\tif (options.thin)\n\t\targv_array_push(&args, \"--thin\");\n\tif (options.verbosity >= 3)\n\t\targv_array_pushl(&args, \"-v\", \"-v\", NULL);\n\tif (options.check_self_contained_and_connected)\n\t\targv_array_push(&args, \"--check-self-contained-and-connected\");\n\tif (options.cloning)\n\t\targv_array_push(&args, \"--cloning\");\n\tif (options.update_shallow)\n\t\targv_array_push(&args, \"--update-shallow\");\n\tif (!options.progress)\n\t\targv_array_push(&args, \"--no-progress\");\n\tif (options.depth)\n\t\targv_array_pushf(&args, \"--depth=%lu\", options.depth);\n\tif (options.deepen_since)\n\t\targv_array_pushf(&args, \"--shallow-since=%s\", options.deepen_since);\n\tfor (i = 0; i < options.deepen_not.nr; i++)\n\t\targv_array_pushf(&args, \"--shallow-exclude=%s\",\n\t\t\t\t options.deepen_not.items[i].string);\n\tif (options.deepen_relative && options.depth)\n\t\targv_array_push(&args, \"--deepen-relative\");\n\tif (options.from_promisor)\n\t\targv_array_push(&args, \"--from-promisor\");\n\tif (options.no_dependents)\n\t\targv_array_push(&args, \"--no-dependents\");\n\tif (options.filter)\n\t\targv_array_pushf(&args, \"--filter=%s\", options.filter);\n\targv_array_push(&args, url.buf);\n\n\tfor (i = 0; i < nr_heads; i++) {\n\t\tstruct ref *ref = to_fetch[i];\n\t\tif (!*ref->name)\n\t\t\tdie(_(\"cannot fetch by sha1 over smart http\"));\n\t\tpacket_buf_write(&preamble, \"%s %s\\n\",\n\t\t\t\t oid_to_hex(&ref->old_oid), ref->name);\n\t}\n\tpacket_buf_flush(&preamble);\n\n\tmemset(&rpc, 0, sizeof(rpc));\n\trpc.service_name = \"git-upload-pack\",\n\trpc.gzip_request = 1;\n\n\terr = rpc_service(&rpc, heads, args.argv, &preamble, &rpc_result);\n\tif (rpc_result.len)\n\t\twrite_or_die(1, rpc_result.buf, rpc_result.len);\n\tstrbuf_release(&rpc_result);\n\tstrbuf_release(&preamble);\n\targv_array_clear(&args);\n\treturn err;\n}\n\nstatic int fetch(int nr_heads, struct ref **to_fetch)\n{\n\tstruct discovery *d = discover_refs(\"git-upload-pack\", 0);\n\tif (d->proto_git)\n\t\treturn fetch_git(d, nr_heads, to_fetch);\n\telse\n\t\treturn fetch_dumb(nr_heads, to_fetch);\n}\n\nstatic void parse_fetch(struct strbuf *buf)\n{\n\tstruct ref **to_fetch = NULL;\n\tstruct ref *list_head = NULL;\n\tstruct ref **list = &list_head;\n\tint alloc_heads = 0, nr_heads = 0;\n\n\tdo {\n\t\tconst char *p;\n\t\tif (skip_prefix(buf->buf, \"fetch \", &p)) {\n\t\t\tconst char *name;\n\t\t\tstruct ref *ref;\n\t\t\tstruct object_id old_oid;\n\t\t\tconst char *q;\n\n\t\t\tif (parse_oid_hex(p, &old_oid, &q))\n\t\t\t\tdie(_(\"protocol error: expected sha/ref, got '%s'\"), p);\n\t\t\tif (*q == ' ')\n\t\t\t\tname = q + 1;\n\t\t\telse if (!*q)\n\t\t\t\tname = \"\";\n\t\t\telse\n\t\t\t\tdie(_(\"protocol error: expected sha/ref, got '%s'\"), p);\n\n\t\t\tref = alloc_ref(name);\n\t\t\toidcpy(&ref->old_oid, &old_oid);\n\n\t\t\t*list = ref;\n\t\t\tlist = &ref->next;\n\n\t\t\tALLOC_GROW(to_fetch, nr_heads + 1, alloc_heads);\n\t\t\tto_fetch[nr_heads++] = ref;\n\t\t}\n\t\telse\n\t\t\tdie(_(\"http transport does not support %s\"), buf->buf);\n\n\t\tstrbuf_reset(buf);\n\t\tif (strbuf_getline_lf(buf, stdin) == EOF)\n\t\t\treturn;\n\t\tif (!*buf->buf)\n\t\t\tbreak;\n\t} while (1);\n\n\tif (fetch(nr_heads, to_fetch))\n\t\texit(128); /* error already reported */\n\tfree_refs(list_head);\n\tfree(to_fetch);\n\n\tprintf(\"\\n\");\n\tfflush(stdout);\n\tstrbuf_reset(buf);\n}\n\nstatic int push_dav(int nr_spec, const char **specs)\n{\n\tstruct child_process child = CHILD_PROCESS_INIT;\n\tsize_t i;\n\n\tchild.git_cmd = 1;\n\targv_array_push(&child.args, \"http-push\");\n\targv_array_push(&child.args, \"--helper-status\");\n\tif (options.dry_run)\n\t\targv_array_push(&child.args, \"--dry-run\");\n\tif (options.verbosity > 1)\n\t\targv_array_push(&child.args, \"--verbose\");\n\targv_array_push(&child.args, url.buf);\n\tfor (i = 0; i < nr_spec; i++)\n\t\targv_array_push(&child.args, specs[i]);\n\n\tif (run_command(&child))\n\t\tdie(_(\"git-http-push failed\"));\n\treturn 0;\n}\n\nstatic int push_git(struct discovery *heads, int nr_spec, const char **specs)\n{\n\tstruct rpc_state rpc;\n\tint i, err;\n\tstruct argv_array args;\n\tstruct string_list_item *cas_option;\n\tstruct strbuf preamble = STRBUF_INIT;\n\tstruct strbuf rpc_result = STRBUF_INIT;\n\n\targv_array_init(&args);\n\targv_array_pushl(&args, \"send-pack\", \"--stateless-rpc\", \"--helper-status\",\n\t\t\t NULL);\n\n\tif (options.thin)\n\t\targv_array_push(&args, \"--thin\");\n\tif (options.dry_run)\n\t\targv_array_push(&args, \"--dry-run\");\n\tif (options.push_cert == SEND_PACK_PUSH_CERT_ALWAYS)\n\t\targv_array_push(&args, \"--signed=yes\");\n\telse if (options.push_cert == SEND_PACK_PUSH_CERT_IF_ASKED)\n\t\targv_array_push(&args, \"--signed=if-asked\");\n\tif (options.atomic)\n\t\targv_array_push(&args, \"--atomic\");\n\tif (options.verbosity == 0)\n\t\targv_array_push(&args, \"--quiet\");\n\telse if (options.verbosity > 1)\n\t\targv_array_push(&args, \"--verbose\");\n\tfor (i = 0; i < options.push_options.nr; i++)\n\t\targv_array_pushf(&args, \"--push-option=%s\",\n\t\t\t\t options.push_options.items[i].string);\n\targv_array_push(&args, options.progress ? \"--progress\" : \"--no-progress\");\n\tfor_each_string_list_item(cas_option, &cas_options)\n\t\targv_array_push(&args, cas_option->string);\n\targv_array_push(&args, url.buf);\n\n\targv_array_push(&args, \"--stdin\");\n\tfor (i = 0; i < nr_spec; i++)\n\t\tpacket_buf_write(&preamble, \"%s\\n\", specs[i]);\n\tpacket_buf_flush(&preamble);\n\n\tmemset(&rpc, 0, sizeof(rpc));\n\trpc.service_name = \"git-receive-pack\",\n\n\terr = rpc_service(&rpc, heads, args.argv, &preamble, &rpc_result);\n\tif (rpc_result.len)\n\t\twrite_or_die(1, rpc_result.buf, rpc_result.len);\n\tstrbuf_release(&rpc_result);\n\tstrbuf_release(&preamble);\n\targv_array_clear(&args);\n\treturn err;\n}\n\nstatic int push(int nr_spec, const char **specs)\n{\n\tstruct discovery *heads = discover_refs(\"git-receive-pack\", 1);\n\tint ret;\n\n\tif (heads->proto_git)\n\t\tret = push_git(heads, nr_spec, specs);\n\telse\n\t\tret = push_dav(nr_spec, specs);\n\tfree_discovery(heads);\n\treturn ret;\n}\n\nstatic void parse_push(struct strbuf *buf)\n{\n\tstruct argv_array specs = ARGV_ARRAY_INIT;\n\tint ret;\n\n\tdo {\n\t\tconst char *arg;\n\t\tif (skip_prefix(buf->buf, \"push \", &arg))\n\t\t\targv_array_push(&specs, arg);\n\t\telse\n\t\t\tdie(_(\"http transport does not support %s\"), buf->buf);\n\n\t\tstrbuf_reset(buf);\n\t\tif (strbuf_getline_lf(buf, stdin) == EOF)\n\t\t\tgoto free_specs;\n\t\tif (!*buf->buf)\n\t\t\tbreak;\n\t} while (1);\n\n\tret = push(specs.argc, specs.argv);\n\tprintf(\"\\n\");\n\tfflush(stdout);\n\n\tif (ret)\n\t\texit(128); /* error already reported */\n\n free_specs:\n\targv_array_clear(&specs);\n}\n\nstatic int stateless_connect(const char *service_name)\n{\n\tstruct discovery *discover;\n\tstruct rpc_state rpc;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\t/*\n\t * Run the info/refs request and see if the server supports protocol\n\t * v2.  If and only if the server supports v2 can we successfully\n\t * establish a stateless connection, otherwise we need to tell the\n\t * client to fallback to using other transport helper functions to\n\t * complete their request.\n\t */\n\tdiscover = discover_refs(service_name, 0);\n\tif (discover->version != protocol_v2) {\n\t\tprintf(\"fallback\\n\");\n\t\tfflush(stdout);\n\t\treturn -1;\n\t} else {\n\t\t/* Stateless Connection established */\n\t\tprintf(\"\\n\");\n\t\tfflush(stdout);\n\t}\n\n\trpc.service_name = service_name;\n\trpc.service_url = xstrfmt(\"%s%s\", url.buf, rpc.service_name);\n\trpc.hdr_content_type = xstrfmt(\"Content-Type: application/x-%s-request\", rpc.service_name);\n\trpc.hdr_accept = xstrfmt(\"Accept: application/x-%s-result\", rpc.service_name);\n\tif (get_protocol_http_header(discover->version, &buf)) {\n\t\trpc.protocol_header = strbuf_detach(&buf, NULL);\n\t} else {\n\t\trpc.protocol_header = NULL;\n\t\tstrbuf_release(&buf);\n\t}\n\trpc.buf = xmalloc(http_post_buffer);\n\trpc.alloc = http_post_buffer;\n\trpc.len = 0;\n\trpc.pos = 0;\n\trpc.in = 1;\n\trpc.out = 0;\n\trpc.any_written = 0;\n\trpc.gzip_request = 1;\n\trpc.initial_buffer = 0;\n\trpc.write_line_lengths = 1;\n\trpc.flush_read_but_not_sent = 0;\n\n\t/*\n\t * Dump the capability listing that we got from the server earlier\n\t * during the info/refs request.\n\t */\n\twrite_or_die(rpc.in, discover->buf, discover->len);\n\n\t/* Until we see EOF keep sending POSTs */\n\twhile (1) {\n\t\tsize_t avail;\n\t\tenum packet_read_status status;\n\n\t\tif (!rpc_read_from_out(&rpc, PACKET_READ_GENTLE_ON_EOF, &avail,\n\t\t\t\t       &status))\n\t\t\tBUG(\"The entire rpc->buf should be larger than LARGE_PACKET_MAX\");\n\t\tif (status == PACKET_READ_EOF)\n\t\t\tbreak;\n\t\tif (post_rpc(&rpc, status == PACKET_READ_FLUSH))\n\t\t\t/* We would have an err here */\n\t\t\tbreak;\n\t\t/* Reset the buffer for next request */\n\t\trpc.len = 0;\n\t}\n\n\tfree(rpc.service_url);\n\tfree(rpc.hdr_content_type);\n\tfree(rpc.hdr_accept);\n\tfree(rpc.protocol_header);\n\tfree(rpc.buf);\n\tstrbuf_release(&buf);\n\n\treturn 0;\n}\n\nint cmd_main(int argc, const char **argv)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tint nongit;\n\n\tsetup_git_directory_gently(&nongit);\n\tif (argc < 2) {\n\t\terror(_(\"remote-curl: usage: git remote-curl <remote> [<url>]\"));\n\t\treturn 1;\n\t}\n\n\toptions.verbosity = 1;\n\toptions.progress = !!isatty(2);\n\toptions.thin = 1;\n\tstring_list_init(&options.deepen_not, 1);\n\tstring_list_init(&options.push_options, 1);\n\n\t/*\n\t * Just report \"remote-curl\" here (folding all the various aliases\n\t * (\"git-remote-http\", \"git-remote-https\", and etc.) here since they\n\t * are all just copies of the same actual executable.\n\t */\n\ttrace2_cmd_name(\"remote-curl\");\n\n\tremote = remote_get(argv[1]);\n\n\tif (argc > 2) {\n\t\tend_url_with_slash(&url, argv[2]);\n\t} else {\n\t\tend_url_with_slash(&url, remote->url[0]);\n\t}\n\n\thttp_init(remote, url.buf, 0);\n\n\tdo {\n\t\tconst char *arg;\n\n\t\tif (strbuf_getline_lf(&buf, stdin) == EOF) {\n\t\t\tif (ferror(stdin))\n\t\t\t\terror(_(\"remote-curl: error reading command stream from git\"));\n\t\t\treturn 1;\n\t\t}\n\t\tif (buf.len == 0)\n\t\t\tbreak;\n\t\tif (starts_with(buf.buf, \"fetch \")) {\n\t\t\tif (nongit)\n\t\t\t\tdie(_(\"remote-curl: fetch attempted without a local repo\"));\n\t\t\tparse_fetch(&buf);\n\n\t\t} else if (!strcmp(buf.buf, \"list\") || starts_with(buf.buf, \"list \")) {\n\t\t\tint for_push = !!strstr(buf.buf + 4, \"for-push\");\n\t\t\toutput_refs(get_refs(for_push));\n\n\t\t} else if (starts_with(buf.buf, \"push \")) {\n\t\t\tparse_push(&buf);\n\n\t\t} else if (skip_prefix(buf.buf, \"option \", &arg)) {\n\t\t\tchar *value = strchr(arg, ' ');\n\t\t\tint result;\n\n\t\t\tif (value)\n\t\t\t\t*value++ = '\\0';\n\t\t\telse\n\t\t\t\tvalue = \"true\";\n\n\t\t\tresult = set_option(arg, value);\n\t\t\tif (!result)\n\t\t\t\tprintf(\"ok\\n\");\n\t\t\telse if (result < 0)\n\t\t\t\tprintf(\"error invalid value\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"unsupported\\n\");\n\t\t\tfflush(stdout);\n\n\t\t} else if (!strcmp(buf.buf, \"capabilities\")) {\n\t\t\tprintf(\"stateless-connect\\n\");\n\t\t\tprintf(\"fetch\\n\");\n\t\t\tprintf(\"option\\n\");\n\t\t\tprintf(\"push\\n\");\n\t\t\tprintf(\"check-connectivity\\n\");\n\t\t\tprintf(\"object-format\\n\");\n\t\t\tprintf(\"\\n\");\n\t\t\tfflush(stdout);\n\t\t} else if (skip_prefix(buf.buf, \"stateless-connect \", &arg)) {\n\t\t\tif (!stateless_connect(arg))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\terror(_(\"remote-curl: unknown command '%s' from git\"), buf.buf);\n\t\t\treturn 1;\n\t\t}\n\t\tstrbuf_reset(&buf);\n\t} while (1);\n\n\thttp_cleanup();\n\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0090e68f4a7c035644a53dabe48754f78d80c8ae",
  "sha1_ok": true,
  "size": 38968
}
