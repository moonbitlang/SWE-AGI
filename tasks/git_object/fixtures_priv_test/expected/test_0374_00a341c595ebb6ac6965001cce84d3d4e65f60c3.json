{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJhdHRyLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAic3RyYnVmLmgiCgovKgogKiBjb252ZXJ0LmMgLSBjb252ZXJ0IGEgZmlsZSB3aGVuIGNoZWNraW5nIGl0IG91dCBhbmQgY2hlY2tpbmcgaXQgaW4uCiAqCiAqIFRoaXMgc2hvdWxkIHVzZSB0aGUgcGF0aG5hbWUgdG8gZGVjaWRlIG9uIHdoZXRoZXIgaXQgd2FudHMgdG8gZG8gc29tZQogKiBtb3JlIGludGVyZXN0aW5nIGNvbnZlcnNpb25zIChhdXRvbWF0aWMgZ3ppcC91bnppcCwgZ2VuZXJhbCBmb3JtYXQKICogY29udmVyc2lvbnMgZXRjIGV0YyksIGJ1dCBieSBkZWZhdWx0IGl0IGp1c3QgZG9lcyBhdXRvbWF0aWMgQ1JMRjwtPkxGCiAqIHRyYW5zbGF0aW9uIHdoZW4gdGhlICJhdXRvX2NybGYiIG9wdGlvbiBpcyBzZXQuCiAqLwoKI2RlZmluZSBDUkxGX0dVRVNTCSgtMSkKI2RlZmluZSBDUkxGX0JJTkFSWQkwCiNkZWZpbmUgQ1JMRl9URVhUCTEKI2RlZmluZSBDUkxGX0lOUFVUCTIKCnN0cnVjdCB0ZXh0X3N0YXQgewoJLyogQ1IsIExGIGFuZCBDUkxGIGNvdW50cyAqLwoJdW5zaWduZWQgY3IsIGxmLCBjcmxmOwoKCS8qIFRoZXNlIGFyZSBqdXN0IGFwcHJveGltYXRpb25zISAqLwoJdW5zaWduZWQgcHJpbnRhYmxlLCBub25wcmludGFibGU7Cn07CgpzdGF0aWMgdm9pZCBnYXRoZXJfc3RhdHMoY29uc3QgY2hhciAqYnVmLCB1bnNpZ25lZCBsb25nIHNpemUsIHN0cnVjdCB0ZXh0X3N0YXQgKnN0YXRzKQp7Cgl1bnNpZ25lZCBsb25nIGk7CgoJbWVtc2V0KHN0YXRzLCAwLCBzaXplb2YoKnN0YXRzKSk7CgoJZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykgewoJCXVuc2lnbmVkIGNoYXIgYyA9IGJ1ZltpXTsKCQlpZiAoYyA9PSAnXHInKSB7CgkJCXN0YXRzLT5jcisrOwoJCQlpZiAoaSsxIDwgc2l6ZSAmJiBidWZbaSsxXSA9PSAnXG4nKQoJCQkJc3RhdHMtPmNybGYrKzsKCQkJY29udGludWU7CgkJfQoJCWlmIChjID09ICdcbicpIHsKCQkJc3RhdHMtPmxmKys7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoYyA9PSAxMjcpCgkJCS8qIERFTCAqLwoJCQlzdGF0cy0+bm9ucHJpbnRhYmxlKys7CgkJZWxzZSBpZiAoYyA8IDMyKSB7CgkJCXN3aXRjaCAoYykgewoJCQkJLyogQlMsIEhULCBFU0MgYW5kIEZGICovCgkJCWNhc2UgJ1xiJzogY2FzZSAnXHQnOiBjYXNlICdcMDMzJzogY2FzZSAnXDAxNCc6CgkJCQlzdGF0cy0+cHJpbnRhYmxlKys7CgkJCQlicmVhazsKCQkJZGVmYXVsdDoKCQkJCXN0YXRzLT5ub25wcmludGFibGUrKzsKCQkJfQoJCX0KCQllbHNlCgkJCXN0YXRzLT5wcmludGFibGUrKzsKCX0KfQoKLyoKICogVGhlIHNhbWUgaGV1cmlzdGljcyBhcyBkaWZmLmM6Om1tZmlsZV9pc19iaW5hcnkoKQogKi8Kc3RhdGljIGludCBpc19iaW5hcnkodW5zaWduZWQgbG9uZyBzaXplLCBzdHJ1Y3QgdGV4dF9zdGF0ICpzdGF0cykKewoKCWlmICgoc3RhdHMtPnByaW50YWJsZSA+PiA3KSA8IHN0YXRzLT5ub25wcmludGFibGUpCgkJcmV0dXJuIDE7CgkvKgoJICogT3RoZXIgaGV1cmlzdGljcz8gQXZlcmFnZSBsaW5lIGxlbmd0aCBtaWdodCBiZSByZWxldmFudCwKCSAqIGFzIG1pZ2h0IExGIHZzIENSIHZzIENSTEYgY291bnRzLi4KCSAqCgkgKiBOT1RFISBJdCBtaWdodCBiZSBub3JtYWwgdG8gaGF2ZSBhIGxvdyByYXRpbyBvZiBDUkxGIHRvIExGCgkgKiAoc29tZWJvZHkgc3RhcnRzIHdpdGggYSBMRi1vbmx5IGZpbGUgYW5kIGVkaXRzIGl0IHdpdGggYW4gZWRpdG9yCgkgKiB0aGF0IGFkZHMgQ1JMRiBvbmx5IHRvIGxpbmVzIHRoYXQgYXJlIGFkZGVkLi4pLiBCdXQgZG8gIHdlCgkgKiB3YW50IHRvIHN1cHBvcnQgQ1Itb25seT8gUHJvYmFibHkgbm90LgoJICovCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBjcmxmX3RvX2dpdChjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFyICpzcmMsIHNpemVfdCBsZW4sCiAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0IHN0cmJ1ZiAqYnVmLCBpbnQgYWN0aW9uKQp7CglzdHJ1Y3QgdGV4dF9zdGF0IHN0YXRzOwoJY2hhciAqZHN0OwoKCWlmICgoYWN0aW9uID09IENSTEZfQklOQVJZKSB8fCAhYXV0b19jcmxmIHx8ICFsZW4pCgkJcmV0dXJuIDA7CgoJZ2F0aGVyX3N0YXRzKHNyYywgbGVuLCAmc3RhdHMpOwoJLyogTm8gQ1I/IE5vdGhpbmcgdG8gY29udmVydCwgcmVnYXJkbGVzcy4gKi8KCWlmICghc3RhdHMuY3IpCgkJcmV0dXJuIDA7CgoJaWYgKGFjdGlvbiA9PSBDUkxGX0dVRVNTKSB7CgkJLyoKCQkgKiBXZSdyZSBjdXJyZW50bHkgbm90IGdvaW5nIHRvIGV2ZW4gdHJ5IHRvIGNvbnZlcnQgc3R1ZmYKCQkgKiB0aGF0IGhhcyBiYXJlIENSIGNoYXJhY3RlcnMuIERvZXMgYW55Ym9keSBkbyB0aGF0IGNyYXp5CgkJICogc3R1ZmY/CgkJICovCgkJaWYgKHN0YXRzLmNyICE9IHN0YXRzLmNybGYpCgkJCXJldHVybiAwOwoKCQkvKgoJCSAqIEFuZCBhZGQgc29tZSBoZXVyaXN0aWNzIGZvciBiaW5hcnkgdnMgdGV4dCwgb2YgY291cnNlLi4uCgkJICovCgkJaWYgKGlzX2JpbmFyeShsZW4sICZzdGF0cykpCgkJCXJldHVybiAwOwoJfQoKCXN0cmJ1Zl9ncm93KGJ1ZiwgbGVuKTsKCWRzdCA9IGJ1Zi0+YnVmOwoJaWYgKGFjdGlvbiA9PSBDUkxGX0dVRVNTKSB7CgkJLyoKCQkgKiBJZiB3ZSBndWVzc2VkLCB3ZSBhbHJlYWR5IGtub3cgd2UgcmVqZWN0ZWQgYSBmaWxlIHdpdGgKCQkgKiBsb25lIENSLCBhbmQgd2UgY2FuIHN0cmlwIGEgQ1Igd2l0aG91dCBsb29raW5nIGF0IHdoYXQKCQkgKiBmb2xsb3cgaXQuCgkJICovCgkJZG8gewoJCQl1bnNpZ25lZCBjaGFyIGMgPSAqc3JjKys7CgkJCWlmIChjICE9ICdccicpCgkJCQkqZHN0KysgPSBjOwoJCX0gd2hpbGUgKC0tbGVuKTsKCX0gZWxzZSB7CgkJZG8gewoJCQl1bnNpZ25lZCBjaGFyIGMgPSAqc3JjKys7CgkJCWlmICghIChjID09ICdccicgJiYgKDEgPCBsZW4gJiYgKnNyYyA9PSAnXG4nKSkpCgkJCQkqZHN0KysgPSBjOwoJCX0gd2hpbGUgKC0tbGVuKTsKCX0KCXN0cmJ1Zl9zZXRsZW4oYnVmLCBkc3QgLSBidWYtPmJ1Zik7CglyZXR1cm4gMTsKfQoKc3RhdGljIGludCBjcmxmX3RvX3dvcmt0cmVlKGNvbnN0IGNoYXIgKnBhdGgsIGNvbnN0IGNoYXIgKnNyYywgc2l6ZV90IGxlbiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cnVjdCBzdHJidWYgKmJ1ZiwgaW50IGFjdGlvbikKewoJY2hhciAqdG9fZnJlZSA9IE5VTEw7CglzdHJ1Y3QgdGV4dF9zdGF0IHN0YXRzOwoKCWlmICgoYWN0aW9uID09IENSTEZfQklOQVJZKSB8fCAoYWN0aW9uID09IENSTEZfSU5QVVQpIHx8CgkgICAgYXV0b19jcmxmIDw9IDApCgkJcmV0dXJuIDA7CgoJaWYgKCFsZW4pCgkJcmV0dXJuIDA7CgoJZ2F0aGVyX3N0YXRzKHNyYywgbGVuLCAmc3RhdHMpOwoKCS8qIE5vIExGPyBOb3RoaW5nIHRvIGNvbnZlcnQsIHJlZ2FyZGxlc3MuICovCglpZiAoIXN0YXRzLmxmKQoJCXJldHVybiAwOwoKCS8qIFdhcyBpdCBhbHJlYWR5IGluIENSTEYgZm9ybWF0PyAqLwoJaWYgKHN0YXRzLmxmID09IHN0YXRzLmNybGYpCgkJcmV0dXJuIDA7CgoJaWYgKGFjdGlvbiA9PSBDUkxGX0dVRVNTKSB7CgkJLyogSWYgd2UgaGF2ZSBhbnkgYmFyZSBDUiBjaGFyYWN0ZXJzLCB3ZSdyZSBub3QgZ29pbmcgdG8gdG91Y2ggaXQgKi8KCQlpZiAoc3RhdHMuY3IgIT0gc3RhdHMuY3JsZikKCQkJcmV0dXJuIDA7CgoJCWlmIChpc19iaW5hcnkobGVuLCAmc3RhdHMpKQoJCQlyZXR1cm4gMDsKCX0KCgkvKiBhcmUgd2UgImZha2luZyIgaW4gcGxhY2UgZWRpdGluZyA/ICovCglpZiAoc3JjID09IGJ1Zi0+YnVmKQoJCXRvX2ZyZWUgPSBzdHJidWZfZGV0YWNoKGJ1Zik7CgoJc3RyYnVmX2dyb3coYnVmLCBsZW4gKyBzdGF0cy5sZiAtIHN0YXRzLmNybGYpOwoJZm9yICg7OykgewoJCWNvbnN0IGNoYXIgKm5sID0gbWVtY2hyKHNyYywgJ1xuJywgbGVuKTsKCQlpZiAoIW5sKQoJCQlicmVhazsKCQlpZiAobmwgPiBzcmMgJiYgbmxbLTFdID09ICdccicpIHsKCQkJc3RyYnVmX2FkZChidWYsIHNyYywgbmwgKyAxIC0gc3JjKTsKCQl9IGVsc2UgewoJCQlzdHJidWZfYWRkKGJ1Ziwgc3JjLCBubCAtIHNyYyk7CgkJCXN0cmJ1Zl9hZGRzdHIoYnVmLCAiXHJcbiIpOwoJCX0KCQlsZW4gLT0gbmwgKyAxIC0gc3JjOwoJCXNyYyAgPSBubCArIDE7Cgl9CglzdHJidWZfYWRkKGJ1Ziwgc3JjLCBsZW4pOwoKCWZyZWUodG9fZnJlZSk7CglyZXR1cm4gMTsKfQoKc3RhdGljIGludCBmaWx0ZXJfYnVmZmVyKGNvbnN0IGNoYXIgKnBhdGgsIGNvbnN0IGNoYXIgKnNyYywKCQkJIHVuc2lnbmVkIGxvbmcgc2l6ZSwgY29uc3QgY2hhciAqY21kKQp7CgkvKgoJICogU3Bhd24gY21kIGFuZCBmZWVkIHRoZSBidWZmZXIgY29udGVudHMgdGhyb3VnaCBpdHMgc3RkaW4uCgkgKi8KCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGNoaWxkX3Byb2Nlc3M7CglpbnQgcGlwZV9mZWVkWzJdOwoJaW50IHdyaXRlX2Vyciwgc3RhdHVzOwoKCW1lbXNldCgmY2hpbGRfcHJvY2VzcywgMCwgc2l6ZW9mKGNoaWxkX3Byb2Nlc3MpKTsKCglpZiAocGlwZShwaXBlX2ZlZWQpIDwgMCkgewoJCWVycm9yKCJjYW5ub3QgY3JlYXRlIHBpcGUgdG8gcnVuIGV4dGVybmFsIGZpbHRlciAlcyIsIGNtZCk7CgkJcmV0dXJuIDE7Cgl9CgoJY2hpbGRfcHJvY2Vzcy5waWQgPSBmb3JrKCk7CglpZiAoY2hpbGRfcHJvY2Vzcy5waWQgPCAwKSB7CgkJZXJyb3IoImNhbm5vdCBmb3JrIHRvIHJ1biBleHRlcm5hbCBmaWx0ZXIgJXMiLCBjbWQpOwoJCWNsb3NlKHBpcGVfZmVlZFswXSk7CgkJY2xvc2UocGlwZV9mZWVkWzFdKTsKCQlyZXR1cm4gMTsKCX0KCWlmICghY2hpbGRfcHJvY2Vzcy5waWQpIHsKCQlkdXAyKHBpcGVfZmVlZFswXSwgMCk7CgkJY2xvc2UocGlwZV9mZWVkWzBdKTsKCQljbG9zZShwaXBlX2ZlZWRbMV0pOwoJCWV4ZWNscCgic2giLCAic2giLCAiLWMiLCBjbWQsIE5VTEwpOwoJCXJldHVybiAxOwoJfQoJY2xvc2UocGlwZV9mZWVkWzBdKTsKCgl3cml0ZV9lcnIgPSAod3JpdGVfaW5fZnVsbChwaXBlX2ZlZWRbMV0sIHNyYywgc2l6ZSkgPCAwKTsKCWlmIChjbG9zZShwaXBlX2ZlZWRbMV0pKQoJCXdyaXRlX2VyciA9IDE7CglpZiAod3JpdGVfZXJyKQoJCWVycm9yKCJjYW5ub3QgZmVlZCB0aGUgaW5wdXQgdG8gZXh0ZXJuYWwgZmlsdGVyICVzIiwgY21kKTsKCglzdGF0dXMgPSBmaW5pc2hfY29tbWFuZCgmY2hpbGRfcHJvY2Vzcyk7CglpZiAoc3RhdHVzKQoJCWVycm9yKCJleHRlcm5hbCBmaWx0ZXIgJXMgZmFpbGVkICVkIiwgY21kLCAtc3RhdHVzKTsKCXJldHVybiAod3JpdGVfZXJyIHx8IHN0YXR1cyk7Cn0KCnN0YXRpYyBpbnQgYXBwbHlfZmlsdGVyKGNvbnN0IGNoYXIgKnBhdGgsIGNvbnN0IGNoYXIgKnNyYywgc2l6ZV90IGxlbiwKICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0IHN0cmJ1ZiAqZHN0LCBjb25zdCBjaGFyICpjbWQpCnsKCS8qCgkgKiBDcmVhdGUgYSBwaXBlbGluZSB0byBoYXZlIHRoZSBjb21tYW5kIGZpbHRlciB0aGUgYnVmZmVyJ3MKCSAqIGNvbnRlbnRzLgoJICoKCSAqIChjaGlsZCAtLT4gY21kKSAtLT4gdXMKCSAqLwoJaW50IHBpcGVfZmVlZFsyXTsKCWludCBzdGF0dXMsIHJldCA9IDE7CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBjaGlsZF9wcm9jZXNzOwoJc3RydWN0IHN0cmJ1ZiBuYnVmOwoKCWlmICghY21kKQoJCXJldHVybiAwOwoKCW1lbXNldCgmY2hpbGRfcHJvY2VzcywgMCwgc2l6ZW9mKGNoaWxkX3Byb2Nlc3MpKTsKCglpZiAocGlwZShwaXBlX2ZlZWQpIDwgMCkgewoJCWVycm9yKCJjYW5ub3QgY3JlYXRlIHBpcGUgdG8gcnVuIGV4dGVybmFsIGZpbHRlciAlcyIsIGNtZCk7CgkJcmV0dXJuIDA7Cgl9CgoJZmZsdXNoKE5VTEwpOwoJY2hpbGRfcHJvY2Vzcy5waWQgPSBmb3JrKCk7CglpZiAoY2hpbGRfcHJvY2Vzcy5waWQgPCAwKSB7CgkJZXJyb3IoImNhbm5vdCBmb3JrIHRvIHJ1biBleHRlcm5hbCBmaWx0ZXIgJXMiLCBjbWQpOwoJCWNsb3NlKHBpcGVfZmVlZFswXSk7CgkJY2xvc2UocGlwZV9mZWVkWzFdKTsKCQlyZXR1cm4gMDsKCX0KCWlmICghY2hpbGRfcHJvY2Vzcy5waWQpIHsKCQlkdXAyKHBpcGVfZmVlZFsxXSwgMSk7CgkJY2xvc2UocGlwZV9mZWVkWzBdKTsKCQljbG9zZShwaXBlX2ZlZWRbMV0pOwoJCWV4aXQoZmlsdGVyX2J1ZmZlcihwYXRoLCBzcmMsIGxlbiwgY21kKSk7Cgl9CgljbG9zZShwaXBlX2ZlZWRbMV0pOwoKCXN0cmJ1Zl9pbml0KCZuYnVmLCAwKTsKCWlmIChzdHJidWZfcmVhZCgmbmJ1ZiwgcGlwZV9mZWVkWzBdLCBsZW4pIDwgMCkgewoJCWVycm9yKCJyZWFkIGZyb20gZXh0ZXJuYWwgZmlsdGVyICVzIGZhaWxlZCIsIGNtZCk7CgkJcmV0ID0gMDsKCX0KCWlmIChjbG9zZShwaXBlX2ZlZWRbMF0pKSB7CgkJcmV0ID0gZXJyb3IoInJlYWQgZnJvbSBleHRlcm5hbCBmaWx0ZXIgJXMgZmFpbGVkIiwgY21kKTsKCQlyZXQgPSAwOwoJfQoJc3RhdHVzID0gZmluaXNoX2NvbW1hbmQoJmNoaWxkX3Byb2Nlc3MpOwoJaWYgKHN0YXR1cykgewoJCXJldCA9IGVycm9yKCJleHRlcm5hbCBmaWx0ZXIgJXMgZmFpbGVkICVkIiwgY21kLCAtc3RhdHVzKTsKCQlyZXQgPSAwOwoJfQoKCWlmIChyZXQpIHsKCQkqZHN0ID0gbmJ1ZjsKCX0gZWxzZSB7CgkJc3RyYnVmX3JlbGVhc2UoJm5idWYpOwoJfQoJcmV0dXJuIHJldDsKfQoKc3RhdGljIHN0cnVjdCBjb252ZXJ0X2RyaXZlciB7Cgljb25zdCBjaGFyICpuYW1lOwoJc3RydWN0IGNvbnZlcnRfZHJpdmVyICpuZXh0OwoJY2hhciAqc211ZGdlOwoJY2hhciAqY2xlYW47Cn0gKnVzZXJfY29udmVydCwgKip1c2VyX2NvbnZlcnRfdGFpbDsKCnN0YXRpYyBpbnQgcmVhZF9jb252ZXJ0X2NvbmZpZyhjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlKQp7Cgljb25zdCBjaGFyICplcCwgKm5hbWU7CglpbnQgbmFtZWxlbjsKCXN0cnVjdCBjb252ZXJ0X2RyaXZlciAqZHJ2OwoKCS8qCgkgKiBFeHRlcm5hbCBjb252ZXJzaW9uIGRyaXZlcnMgYXJlIGNvbmZpZ3VyZWQgdXNpbmcKCSAqICJmaWx0ZXIuPG5hbWU+LnZhcmlhYmxlIi4KCSAqLwoJaWYgKHByZWZpeGNtcCh2YXIsICJmaWx0ZXIuIikgfHwgKGVwID0gc3RycmNocih2YXIsICcuJykpID09IHZhciArIDYpCgkJcmV0dXJuIDA7CgluYW1lID0gdmFyICsgNzsKCW5hbWVsZW4gPSBlcCAtIG5hbWU7Cglmb3IgKGRydiA9IHVzZXJfY29udmVydDsgZHJ2OyBkcnYgPSBkcnYtPm5leHQpCgkJaWYgKCFzdHJuY21wKGRydi0+bmFtZSwgbmFtZSwgbmFtZWxlbikgJiYgIWRydi0+bmFtZVtuYW1lbGVuXSkKCQkJYnJlYWs7CglpZiAoIWRydikgewoJCWNoYXIgKm5hbWVidWY7CgkJZHJ2ID0geGNhbGxvYygxLCBzaXplb2Yoc3RydWN0IGNvbnZlcnRfZHJpdmVyKSk7CgkJbmFtZWJ1ZiA9IHhtYWxsb2MobmFtZWxlbiArIDEpOwoJCW1lbWNweShuYW1lYnVmLCBuYW1lLCBuYW1lbGVuKTsKCQluYW1lYnVmW25hbWVsZW5dID0gMDsKCQlkcnYtPm5hbWUgPSBuYW1lYnVmOwoJCWRydi0+bmV4dCA9IE5VTEw7CgkJKnVzZXJfY29udmVydF90YWlsID0gZHJ2OwoJCXVzZXJfY29udmVydF90YWlsID0gJihkcnYtPm5leHQpOwoJfQoKCWVwKys7CgoJLyoKCSAqIGZpbHRlci48bmFtZT4uc211ZGdlIGFuZCBmaWx0ZXIuPG5hbWU+LmNsZWFuIHNwZWNpZmllcwoJICogdGhlIGNvbW1hbmQgbGluZToKCSAqCgkgKgljb21tYW5kLWxpbmUKCSAqCgkgKiBUaGUgY29tbWFuZC1saW5lIHdpbGwgbm90IGJlIGludGVycG9sYXRlZCBpbiBhbnkgd2F5LgoJICovCgoJaWYgKCFzdHJjbXAoInNtdWRnZSIsIGVwKSkgewoJCWlmICghdmFsdWUpCgkJCXJldHVybiBlcnJvcigiJXM6IGxhY2tzIHZhbHVlIiwgdmFyKTsKCQlkcnYtPnNtdWRnZSA9IHN0cmR1cCh2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKCFzdHJjbXAoImNsZWFuIiwgZXApKSB7CgkJaWYgKCF2YWx1ZSkKCQkJcmV0dXJuIGVycm9yKCIlczogbGFja3MgdmFsdWUiLCB2YXIpOwoJCWRydi0+Y2xlYW4gPSBzdHJkdXAodmFsdWUpOwoJCXJldHVybiAwOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHNldHVwX2NvbnZlcnRfY2hlY2soc3RydWN0IGdpdF9hdHRyX2NoZWNrICpjaGVjaykKewoJc3RhdGljIHN0cnVjdCBnaXRfYXR0ciAqYXR0cl9jcmxmOwoJc3RhdGljIHN0cnVjdCBnaXRfYXR0ciAqYXR0cl9pZGVudDsKCXN0YXRpYyBzdHJ1Y3QgZ2l0X2F0dHIgKmF0dHJfZmlsdGVyOwoKCWlmICghYXR0cl9jcmxmKSB7CgkJYXR0cl9jcmxmID0gZ2l0X2F0dHIoImNybGYiLCA0KTsKCQlhdHRyX2lkZW50ID0gZ2l0X2F0dHIoImlkZW50IiwgNSk7CgkJYXR0cl9maWx0ZXIgPSBnaXRfYXR0cigiZmlsdGVyIiwgNik7CgkJdXNlcl9jb252ZXJ0X3RhaWwgPSAmdXNlcl9jb252ZXJ0OwoJCWdpdF9jb25maWcocmVhZF9jb252ZXJ0X2NvbmZpZyk7Cgl9CgljaGVja1swXS5hdHRyID0gYXR0cl9jcmxmOwoJY2hlY2tbMV0uYXR0ciA9IGF0dHJfaWRlbnQ7CgljaGVja1syXS5hdHRyID0gYXR0cl9maWx0ZXI7Cn0KCnN0YXRpYyBpbnQgY291bnRfaWRlbnQoY29uc3QgY2hhciAqY3AsIHVuc2lnbmVkIGxvbmcgc2l6ZSkKewoJLyoKCSAqICIkSWQ6IDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAgJCIgPD0+ICIkSWQkIgoJICovCglpbnQgY250ID0gMDsKCWNoYXIgY2g7CgoJd2hpbGUgKHNpemUpIHsKCQljaCA9ICpjcCsrOwoJCXNpemUtLTsKCQlpZiAoY2ggIT0gJyQnKQoJCQljb250aW51ZTsKCQlpZiAoc2l6ZSA8IDMpCgkJCWJyZWFrOwoJCWlmIChtZW1jbXAoIklkIiwgY3AsIDIpKQoJCQljb250aW51ZTsKCQljaCA9IGNwWzJdOwoJCWNwICs9IDM7CgkJc2l6ZSAtPSAzOwoJCWlmIChjaCA9PSAnJCcpCgkJCWNudCsrOyAvKiAkSWQkICovCgkJaWYgKGNoICE9ICc6JykKCQkJY29udGludWU7CgoJCS8qCgkJICogIiRJZDogLi4uICI7IHNjYW4gdXAgdG8gdGhlIGNsb3NpbmcgZG9sbGFyIHNpZ24gYW5kIGRpc2NhcmQuCgkJICovCgkJd2hpbGUgKHNpemUpIHsKCQkJY2ggPSAqY3ArKzsKCQkJc2l6ZS0tOwoJCQlpZiAoY2ggPT0gJyQnKSB7CgkJCQljbnQrKzsKCQkJCWJyZWFrOwoJCQl9CgkJfQoJfQoJcmV0dXJuIGNudDsKfQoKc3RhdGljIGludCBpZGVudF90b19naXQoY29uc3QgY2hhciAqcGF0aCwgY29uc3QgY2hhciAqc3JjLCBzaXplX3QgbGVuLAogICAgICAgICAgICAgICAgICAgICAgICBzdHJ1Y3Qgc3RyYnVmICpidWYsIGludCBpZGVudCkKewoJY2hhciAqZHN0LCAqZG9sbGFyOwoKCWlmICghaWRlbnQgfHwgIWNvdW50X2lkZW50KHNyYywgbGVuKSkKCQlyZXR1cm4gMDsKCglzdHJidWZfZ3JvdyhidWYsIGxlbik7Cglkc3QgPSBidWYtPmJ1ZjsKCWZvciAoOzspIHsKCQlkb2xsYXIgPSBtZW1jaHIoc3JjLCAnJCcsIGxlbik7CgkJaWYgKCFkb2xsYXIpCgkJCWJyZWFrOwoJCW1lbWNweShkc3QsIHNyYywgZG9sbGFyICsgMSAtIHNyYyk7CgkJZHN0ICs9IGRvbGxhciArIDEgLSBzcmM7CgkJbGVuIC09IGRvbGxhciArIDEgLSBzcmM7CgkJc3JjICA9IGRvbGxhciArIDE7CgoJCWlmIChsZW4gPiAzICYmICFtZW1jbXAoc3JjLCAiSWQ6IiwgMykpIHsKCQkJZG9sbGFyID0gbWVtY2hyKHNyYyArIDMsICckJywgbGVuIC0gMyk7CgkJCWlmICghZG9sbGFyKQoJCQkJYnJlYWs7CgkJCW1lbWNweShkc3QsICJJZCQiLCAzKTsKCQkJZHN0ICs9IDM7CgkJCWxlbiAtPSBkb2xsYXIgKyAxIC0gc3JjOwoJCQlzcmMgID0gZG9sbGFyICsgMTsKCQl9Cgl9CgltZW1jcHkoZHN0LCBzcmMsIGxlbik7CglzdHJidWZfc2V0bGVuKGJ1ZiwgZHN0ICsgbGVuIC0gYnVmLT5idWYpOwoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBpbnQgaWRlbnRfdG9fd29ya3RyZWUoY29uc3QgY2hhciAqcGF0aCwgY29uc3QgY2hhciAqc3JjLCBzaXplX3QgbGVuLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cnVjdCBzdHJidWYgKmJ1ZiwgaW50IGlkZW50KQp7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJY2hhciAqdG9fZnJlZSA9IE5VTEwsICpkb2xsYXI7CglpbnQgY250OwoKCWlmICghaWRlbnQpCgkJcmV0dXJuIDA7CgoJY250ID0gY291bnRfaWRlbnQoc3JjLCBsZW4pOwoJaWYgKCFjbnQpCgkJcmV0dXJuIDA7CgoJLyogYXJlIHdlICJmYWtpbmciIGluIHBsYWNlIGVkaXRpbmcgPyAqLwoJaWYgKHNyYyA9PSBidWYtPmJ1ZikKCQl0b19mcmVlID0gc3RyYnVmX2RldGFjaChidWYpOwoJaGFzaF9zaGExX2ZpbGUoc3JjLCBsZW4sICJibG9iIiwgc2hhMSk7CgoJc3RyYnVmX2dyb3coYnVmLCBsZW4gKyBjbnQgKiA0Myk7Cglmb3IgKDs7KSB7CgkJLyogc3RlcCAxOiBydW4gdG8gdGhlIG5leHQgJyQnICovCgkJZG9sbGFyID0gbWVtY2hyKHNyYywgJyQnLCBsZW4pOwoJCWlmICghZG9sbGFyKQoJCQlicmVhazsKCQlzdHJidWZfYWRkKGJ1Ziwgc3JjLCBkb2xsYXIgKyAxIC0gc3JjKTsKCQlsZW4gLT0gZG9sbGFyICsgMSAtIHNyYzsKCQlzcmMgID0gZG9sbGFyICsgMTsKCgkJLyogc3RlcCAyOiBkb2VzIGl0IGxvb2tzIGxpa2UgYSBiaXQgbGlrZSBJZDp4eHgkIG9yIElkJCA/ICovCgkJaWYgKGxlbiA8IDMgfHwgbWVtY21wKCJJZCIsIHNyYywgMikpCgkJCWNvbnRpbnVlOwoKCQkvKiBzdGVwIDM6IHNraXAgb3ZlciBJZCQgb3IgSWQ6eHh4eHgkICovCgkJaWYgKHNyY1syXSA9PSAnJCcpIHsKCQkJc3JjICs9IDM7CgkJCWxlbiAtPSAzOwoJCX0gZWxzZSBpZiAoc3JjWzJdID09ICc6JykgewoJCQkvKgoJCQkgKiBJdCdzIHBvc3NpYmxlIHRoYXQgYW4gZXhwYW5kZWQgSWQgaGFzIGNyZXB0IGl0cyB3YXkgaW50byB0aGUKCQkJICogcmVwb3NpdG9yeSwgd2UgY29wZSB3aXRoIHRoYXQgYnkgc3RyaXBwaW5nIHRoZSBleHBhbnNpb24gb3V0CgkJCSAqLwoJCQlkb2xsYXIgPSBtZW1jaHIoc3JjICsgMywgJyQnLCBsZW4gLSAzKTsKCQkJaWYgKCFkb2xsYXIpIHsKCQkJCS8qIGluY29tcGxldGUga2V5d29yZCwgbm8gbW9yZSAnJCcsIHNvIGp1c3QgcXVpdCB0aGUgbG9vcCAqLwoJCQkJYnJlYWs7CgkJCX0KCgkJCWxlbiAtPSBkb2xsYXIgKyAxIC0gc3JjOwoJCQlzcmMgID0gZG9sbGFyICsgMTsKCQl9IGVsc2UgewoJCQkvKiBpdCB3YXNuJ3QgYSAiSWQkIiBvciAiSWQ6eHh4eCQiICovCgkJCWNvbnRpbnVlOwoJCX0KCgkJLyogc3RlcCA0OiBzdWJzdGl0dXRlICovCgkJc3RyYnVmX2FkZHN0cihidWYsICJJZDogIik7CgkJc3RyYnVmX2FkZChidWYsIHNoYTFfdG9faGV4KHNoYTEpLCA0MCk7CgkJc3RyYnVmX2FkZHN0cihidWYsICIgJCIpOwoJfQoJc3RyYnVmX2FkZChidWYsIHNyYywgbGVuKTsKCglmcmVlKHRvX2ZyZWUpOwoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBpbnQgZ2l0X3BhdGhfY2hlY2tfY3JsZihjb25zdCBjaGFyICpwYXRoLCBzdHJ1Y3QgZ2l0X2F0dHJfY2hlY2sgKmNoZWNrKQp7Cgljb25zdCBjaGFyICp2YWx1ZSA9IGNoZWNrLT52YWx1ZTsKCglpZiAoQVRUUl9UUlVFKHZhbHVlKSkKCQlyZXR1cm4gQ1JMRl9URVhUOwoJZWxzZSBpZiAoQVRUUl9GQUxTRSh2YWx1ZSkpCgkJcmV0dXJuIENSTEZfQklOQVJZOwoJZWxzZSBpZiAoQVRUUl9VTlNFVCh2YWx1ZSkpCgkJOwoJZWxzZSBpZiAoIXN0cmNtcCh2YWx1ZSwgImlucHV0IikpCgkJcmV0dXJuIENSTEZfSU5QVVQ7CglyZXR1cm4gQ1JMRl9HVUVTUzsKfQoKc3RhdGljIHN0cnVjdCBjb252ZXJ0X2RyaXZlciAqZ2l0X3BhdGhfY2hlY2tfY29udmVydChjb25zdCBjaGFyICpwYXRoLAoJCQkJCSAgICAgc3RydWN0IGdpdF9hdHRyX2NoZWNrICpjaGVjaykKewoJY29uc3QgY2hhciAqdmFsdWUgPSBjaGVjay0+dmFsdWU7CglzdHJ1Y3QgY29udmVydF9kcml2ZXIgKmRydjsKCglpZiAoQVRUUl9UUlVFKHZhbHVlKSB8fCBBVFRSX0ZBTFNFKHZhbHVlKSB8fCBBVFRSX1VOU0VUKHZhbHVlKSkKCQlyZXR1cm4gTlVMTDsKCWZvciAoZHJ2ID0gdXNlcl9jb252ZXJ0OyBkcnY7IGRydiA9IGRydi0+bmV4dCkKCQlpZiAoIXN0cmNtcCh2YWx1ZSwgZHJ2LT5uYW1lKSkKCQkJcmV0dXJuIGRydjsKCXJldHVybiBOVUxMOwp9CgpzdGF0aWMgaW50IGdpdF9wYXRoX2NoZWNrX2lkZW50KGNvbnN0IGNoYXIgKnBhdGgsIHN0cnVjdCBnaXRfYXR0cl9jaGVjayAqY2hlY2spCnsKCWNvbnN0IGNoYXIgKnZhbHVlID0gY2hlY2stPnZhbHVlOwoKCXJldHVybiAhIUFUVFJfVFJVRSh2YWx1ZSk7Cn0KCmludCBjb252ZXJ0X3RvX2dpdChjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFyICpzcmMsIHNpemVfdCBsZW4sIHN0cnVjdCBzdHJidWYgKmRzdCkKewoJc3RydWN0IGdpdF9hdHRyX2NoZWNrIGNoZWNrWzNdOwoJaW50IGNybGYgPSBDUkxGX0dVRVNTOwoJaW50IGlkZW50ID0gMCwgcmV0ID0gMDsKCWNoYXIgKmZpbHRlciA9IE5VTEw7CgoJc2V0dXBfY29udmVydF9jaGVjayhjaGVjayk7CglpZiAoIWdpdF9jaGVja2F0dHIocGF0aCwgQVJSQVlfU0laRShjaGVjayksIGNoZWNrKSkgewoJCXN0cnVjdCBjb252ZXJ0X2RyaXZlciAqZHJ2OwoJCWNybGYgPSBnaXRfcGF0aF9jaGVja19jcmxmKHBhdGgsIGNoZWNrICsgMCk7CgkJaWRlbnQgPSBnaXRfcGF0aF9jaGVja19pZGVudChwYXRoLCBjaGVjayArIDEpOwoJCWRydiA9IGdpdF9wYXRoX2NoZWNrX2NvbnZlcnQocGF0aCwgY2hlY2sgKyAyKTsKCQlpZiAoZHJ2ICYmIGRydi0+Y2xlYW4pCgkJCWZpbHRlciA9IGRydi0+Y2xlYW47Cgl9CgoJcmV0IHw9IGFwcGx5X2ZpbHRlcihwYXRoLCBzcmMsIGxlbiwgZHN0LCBmaWx0ZXIpOwoJaWYgKHJldCkgewoJCXNyYyA9IGRzdC0+YnVmOwoJCWxlbiA9IGRzdC0+bGVuOwoJfQoJcmV0IHw9IGNybGZfdG9fZ2l0KHBhdGgsIHNyYywgbGVuLCBkc3QsIGNybGYpOwoJaWYgKHJldCkgewoJCXNyYyA9IGRzdC0+YnVmOwoJCWxlbiA9IGRzdC0+bGVuOwoJfQoJcmV0dXJuIHJldCB8IGlkZW50X3RvX2dpdChwYXRoLCBzcmMsIGxlbiwgZHN0LCBpZGVudCk7Cn0KCmludCBjb252ZXJ0X3RvX3dvcmtpbmdfdHJlZShjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFyICpzcmMsIHNpemVfdCBsZW4sIHN0cnVjdCBzdHJidWYgKmRzdCkKewoJc3RydWN0IGdpdF9hdHRyX2NoZWNrIGNoZWNrWzNdOwoJaW50IGNybGYgPSBDUkxGX0dVRVNTOwoJaW50IGlkZW50ID0gMCwgcmV0ID0gMDsKCWNoYXIgKmZpbHRlciA9IE5VTEw7CgoJc2V0dXBfY29udmVydF9jaGVjayhjaGVjayk7CglpZiAoIWdpdF9jaGVja2F0dHIocGF0aCwgQVJSQVlfU0laRShjaGVjayksIGNoZWNrKSkgewoJCXN0cnVjdCBjb252ZXJ0X2RyaXZlciAqZHJ2OwoJCWNybGYgPSBnaXRfcGF0aF9jaGVja19jcmxmKHBhdGgsIGNoZWNrICsgMCk7CgkJaWRlbnQgPSBnaXRfcGF0aF9jaGVja19pZGVudChwYXRoLCBjaGVjayArIDEpOwoJCWRydiA9IGdpdF9wYXRoX2NoZWNrX2NvbnZlcnQocGF0aCwgY2hlY2sgKyAyKTsKCQlpZiAoZHJ2ICYmIGRydi0+c211ZGdlKQoJCQlmaWx0ZXIgPSBkcnYtPnNtdWRnZTsKCX0KCglyZXQgfD0gaWRlbnRfdG9fd29ya3RyZWUocGF0aCwgc3JjLCBsZW4sIGRzdCwgaWRlbnQpOwoJaWYgKHJldCkgewoJCXNyYyA9IGRzdC0+YnVmOwoJCWxlbiA9IGRzdC0+bGVuOwoJfQoJcmV0IHw9IGNybGZfdG9fd29ya3RyZWUocGF0aCwgc3JjLCBsZW4sIGRzdCwgY3JsZik7CglpZiAocmV0KSB7CgkJc3JjID0gZHN0LT5idWY7CgkJbGVuID0gZHN0LT5sZW47Cgl9CglyZXR1cm4gcmV0IHwgYXBwbHlfZmlsdGVyKHBhdGgsIHNyYywgbGVuLCBkc3QsIGZpbHRlcik7Cn0K",
    "text": "#include \"cache.h\"\n#include \"attr.h\"\n#include \"run-command.h\"\n#include \"strbuf.h\"\n\n/*\n * convert.c - convert a file when checking it out and checking it in.\n *\n * This should use the pathname to decide on whether it wants to do some\n * more interesting conversions (automatic gzip/unzip, general format\n * conversions etc etc), but by default it just does automatic CRLF<->LF\n * translation when the \"auto_crlf\" option is set.\n */\n\n#define CRLF_GUESS\t(-1)\n#define CRLF_BINARY\t0\n#define CRLF_TEXT\t1\n#define CRLF_INPUT\t2\n\nstruct text_stat {\n\t/* CR, LF and CRLF counts */\n\tunsigned cr, lf, crlf;\n\n\t/* These are just approximations! */\n\tunsigned printable, nonprintable;\n};\n\nstatic void gather_stats(const char *buf, unsigned long size, struct text_stat *stats)\n{\n\tunsigned long i;\n\n\tmemset(stats, 0, sizeof(*stats));\n\n\tfor (i = 0; i < size; i++) {\n\t\tunsigned char c = buf[i];\n\t\tif (c == '\\r') {\n\t\t\tstats->cr++;\n\t\t\tif (i+1 < size && buf[i+1] == '\\n')\n\t\t\t\tstats->crlf++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (c == '\\n') {\n\t\t\tstats->lf++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (c == 127)\n\t\t\t/* DEL */\n\t\t\tstats->nonprintable++;\n\t\telse if (c < 32) {\n\t\t\tswitch (c) {\n\t\t\t\t/* BS, HT, ESC and FF */\n\t\t\tcase '\\b': case '\\t': case '\\033': case '\\014':\n\t\t\t\tstats->printable++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstats->nonprintable++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstats->printable++;\n\t}\n}\n\n/*\n * The same heuristics as diff.c::mmfile_is_binary()\n */\nstatic int is_binary(unsigned long size, struct text_stat *stats)\n{\n\n\tif ((stats->printable >> 7) < stats->nonprintable)\n\t\treturn 1;\n\t/*\n\t * Other heuristics? Average line length might be relevant,\n\t * as might LF vs CR vs CRLF counts..\n\t *\n\t * NOTE! It might be normal to have a low ratio of CRLF to LF\n\t * (somebody starts with a LF-only file and edits it with an editor\n\t * that adds CRLF only to lines that are added..). But do  we\n\t * want to support CR-only? Probably not.\n\t */\n\treturn 0;\n}\n\nstatic int crlf_to_git(const char *path, const char *src, size_t len,\n                       struct strbuf *buf, int action)\n{\n\tstruct text_stat stats;\n\tchar *dst;\n\n\tif ((action == CRLF_BINARY) || !auto_crlf || !len)\n\t\treturn 0;\n\n\tgather_stats(src, len, &stats);\n\t/* No CR? Nothing to convert, regardless. */\n\tif (!stats.cr)\n\t\treturn 0;\n\n\tif (action == CRLF_GUESS) {\n\t\t/*\n\t\t * We're currently not going to even try to convert stuff\n\t\t * that has bare CR characters. Does anybody do that crazy\n\t\t * stuff?\n\t\t */\n\t\tif (stats.cr != stats.crlf)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * And add some heuristics for binary vs text, of course...\n\t\t */\n\t\tif (is_binary(len, &stats))\n\t\t\treturn 0;\n\t}\n\n\tstrbuf_grow(buf, len);\n\tdst = buf->buf;\n\tif (action == CRLF_GUESS) {\n\t\t/*\n\t\t * If we guessed, we already know we rejected a file with\n\t\t * lone CR, and we can strip a CR without looking at what\n\t\t * follow it.\n\t\t */\n\t\tdo {\n\t\t\tunsigned char c = *src++;\n\t\t\tif (c != '\\r')\n\t\t\t\t*dst++ = c;\n\t\t} while (--len);\n\t} else {\n\t\tdo {\n\t\t\tunsigned char c = *src++;\n\t\t\tif (! (c == '\\r' && (1 < len && *src == '\\n')))\n\t\t\t\t*dst++ = c;\n\t\t} while (--len);\n\t}\n\tstrbuf_setlen(buf, dst - buf->buf);\n\treturn 1;\n}\n\nstatic int crlf_to_worktree(const char *path, const char *src, size_t len,\n                            struct strbuf *buf, int action)\n{\n\tchar *to_free = NULL;\n\tstruct text_stat stats;\n\n\tif ((action == CRLF_BINARY) || (action == CRLF_INPUT) ||\n\t    auto_crlf <= 0)\n\t\treturn 0;\n\n\tif (!len)\n\t\treturn 0;\n\n\tgather_stats(src, len, &stats);\n\n\t/* No LF? Nothing to convert, regardless. */\n\tif (!stats.lf)\n\t\treturn 0;\n\n\t/* Was it already in CRLF format? */\n\tif (stats.lf == stats.crlf)\n\t\treturn 0;\n\n\tif (action == CRLF_GUESS) {\n\t\t/* If we have any bare CR characters, we're not going to touch it */\n\t\tif (stats.cr != stats.crlf)\n\t\t\treturn 0;\n\n\t\tif (is_binary(len, &stats))\n\t\t\treturn 0;\n\t}\n\n\t/* are we \"faking\" in place editing ? */\n\tif (src == buf->buf)\n\t\tto_free = strbuf_detach(buf);\n\n\tstrbuf_grow(buf, len + stats.lf - stats.crlf);\n\tfor (;;) {\n\t\tconst char *nl = memchr(src, '\\n', len);\n\t\tif (!nl)\n\t\t\tbreak;\n\t\tif (nl > src && nl[-1] == '\\r') {\n\t\t\tstrbuf_add(buf, src, nl + 1 - src);\n\t\t} else {\n\t\t\tstrbuf_add(buf, src, nl - src);\n\t\t\tstrbuf_addstr(buf, \"\\r\\n\");\n\t\t}\n\t\tlen -= nl + 1 - src;\n\t\tsrc  = nl + 1;\n\t}\n\tstrbuf_add(buf, src, len);\n\n\tfree(to_free);\n\treturn 1;\n}\n\nstatic int filter_buffer(const char *path, const char *src,\n\t\t\t unsigned long size, const char *cmd)\n{\n\t/*\n\t * Spawn cmd and feed the buffer contents through its stdin.\n\t */\n\tstruct child_process child_process;\n\tint pipe_feed[2];\n\tint write_err, status;\n\n\tmemset(&child_process, 0, sizeof(child_process));\n\n\tif (pipe(pipe_feed) < 0) {\n\t\terror(\"cannot create pipe to run external filter %s\", cmd);\n\t\treturn 1;\n\t}\n\n\tchild_process.pid = fork();\n\tif (child_process.pid < 0) {\n\t\terror(\"cannot fork to run external filter %s\", cmd);\n\t\tclose(pipe_feed[0]);\n\t\tclose(pipe_feed[1]);\n\t\treturn 1;\n\t}\n\tif (!child_process.pid) {\n\t\tdup2(pipe_feed[0], 0);\n\t\tclose(pipe_feed[0]);\n\t\tclose(pipe_feed[1]);\n\t\texeclp(\"sh\", \"sh\", \"-c\", cmd, NULL);\n\t\treturn 1;\n\t}\n\tclose(pipe_feed[0]);\n\n\twrite_err = (write_in_full(pipe_feed[1], src, size) < 0);\n\tif (close(pipe_feed[1]))\n\t\twrite_err = 1;\n\tif (write_err)\n\t\terror(\"cannot feed the input to external filter %s\", cmd);\n\n\tstatus = finish_command(&child_process);\n\tif (status)\n\t\terror(\"external filter %s failed %d\", cmd, -status);\n\treturn (write_err || status);\n}\n\nstatic int apply_filter(const char *path, const char *src, size_t len,\n                        struct strbuf *dst, const char *cmd)\n{\n\t/*\n\t * Create a pipeline to have the command filter the buffer's\n\t * contents.\n\t *\n\t * (child --> cmd) --> us\n\t */\n\tint pipe_feed[2];\n\tint status, ret = 1;\n\tstruct child_process child_process;\n\tstruct strbuf nbuf;\n\n\tif (!cmd)\n\t\treturn 0;\n\n\tmemset(&child_process, 0, sizeof(child_process));\n\n\tif (pipe(pipe_feed) < 0) {\n\t\terror(\"cannot create pipe to run external filter %s\", cmd);\n\t\treturn 0;\n\t}\n\n\tfflush(NULL);\n\tchild_process.pid = fork();\n\tif (child_process.pid < 0) {\n\t\terror(\"cannot fork to run external filter %s\", cmd);\n\t\tclose(pipe_feed[0]);\n\t\tclose(pipe_feed[1]);\n\t\treturn 0;\n\t}\n\tif (!child_process.pid) {\n\t\tdup2(pipe_feed[1], 1);\n\t\tclose(pipe_feed[0]);\n\t\tclose(pipe_feed[1]);\n\t\texit(filter_buffer(path, src, len, cmd));\n\t}\n\tclose(pipe_feed[1]);\n\n\tstrbuf_init(&nbuf, 0);\n\tif (strbuf_read(&nbuf, pipe_feed[0], len) < 0) {\n\t\terror(\"read from external filter %s failed\", cmd);\n\t\tret = 0;\n\t}\n\tif (close(pipe_feed[0])) {\n\t\tret = error(\"read from external filter %s failed\", cmd);\n\t\tret = 0;\n\t}\n\tstatus = finish_command(&child_process);\n\tif (status) {\n\t\tret = error(\"external filter %s failed %d\", cmd, -status);\n\t\tret = 0;\n\t}\n\n\tif (ret) {\n\t\t*dst = nbuf;\n\t} else {\n\t\tstrbuf_release(&nbuf);\n\t}\n\treturn ret;\n}\n\nstatic struct convert_driver {\n\tconst char *name;\n\tstruct convert_driver *next;\n\tchar *smudge;\n\tchar *clean;\n} *user_convert, **user_convert_tail;\n\nstatic int read_convert_config(const char *var, const char *value)\n{\n\tconst char *ep, *name;\n\tint namelen;\n\tstruct convert_driver *drv;\n\n\t/*\n\t * External conversion drivers are configured using\n\t * \"filter.<name>.variable\".\n\t */\n\tif (prefixcmp(var, \"filter.\") || (ep = strrchr(var, '.')) == var + 6)\n\t\treturn 0;\n\tname = var + 7;\n\tnamelen = ep - name;\n\tfor (drv = user_convert; drv; drv = drv->next)\n\t\tif (!strncmp(drv->name, name, namelen) && !drv->name[namelen])\n\t\t\tbreak;\n\tif (!drv) {\n\t\tchar *namebuf;\n\t\tdrv = xcalloc(1, sizeof(struct convert_driver));\n\t\tnamebuf = xmalloc(namelen + 1);\n\t\tmemcpy(namebuf, name, namelen);\n\t\tnamebuf[namelen] = 0;\n\t\tdrv->name = namebuf;\n\t\tdrv->next = NULL;\n\t\t*user_convert_tail = drv;\n\t\tuser_convert_tail = &(drv->next);\n\t}\n\n\tep++;\n\n\t/*\n\t * filter.<name>.smudge and filter.<name>.clean specifies\n\t * the command line:\n\t *\n\t *\tcommand-line\n\t *\n\t * The command-line will not be interpolated in any way.\n\t */\n\n\tif (!strcmp(\"smudge\", ep)) {\n\t\tif (!value)\n\t\t\treturn error(\"%s: lacks value\", var);\n\t\tdrv->smudge = strdup(value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(\"clean\", ep)) {\n\t\tif (!value)\n\t\t\treturn error(\"%s: lacks value\", var);\n\t\tdrv->clean = strdup(value);\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic void setup_convert_check(struct git_attr_check *check)\n{\n\tstatic struct git_attr *attr_crlf;\n\tstatic struct git_attr *attr_ident;\n\tstatic struct git_attr *attr_filter;\n\n\tif (!attr_crlf) {\n\t\tattr_crlf = git_attr(\"crlf\", 4);\n\t\tattr_ident = git_attr(\"ident\", 5);\n\t\tattr_filter = git_attr(\"filter\", 6);\n\t\tuser_convert_tail = &user_convert;\n\t\tgit_config(read_convert_config);\n\t}\n\tcheck[0].attr = attr_crlf;\n\tcheck[1].attr = attr_ident;\n\tcheck[2].attr = attr_filter;\n}\n\nstatic int count_ident(const char *cp, unsigned long size)\n{\n\t/*\n\t * \"$Id: 0000000000000000000000000000000000000000 $\" <=> \"$Id$\"\n\t */\n\tint cnt = 0;\n\tchar ch;\n\n\twhile (size) {\n\t\tch = *cp++;\n\t\tsize--;\n\t\tif (ch != '$')\n\t\t\tcontinue;\n\t\tif (size < 3)\n\t\t\tbreak;\n\t\tif (memcmp(\"Id\", cp, 2))\n\t\t\tcontinue;\n\t\tch = cp[2];\n\t\tcp += 3;\n\t\tsize -= 3;\n\t\tif (ch == '$')\n\t\t\tcnt++; /* $Id$ */\n\t\tif (ch != ':')\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * \"$Id: ... \"; scan up to the closing dollar sign and discard.\n\t\t */\n\t\twhile (size) {\n\t\t\tch = *cp++;\n\t\t\tsize--;\n\t\t\tif (ch == '$') {\n\t\t\t\tcnt++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nstatic int ident_to_git(const char *path, const char *src, size_t len,\n                        struct strbuf *buf, int ident)\n{\n\tchar *dst, *dollar;\n\n\tif (!ident || !count_ident(src, len))\n\t\treturn 0;\n\n\tstrbuf_grow(buf, len);\n\tdst = buf->buf;\n\tfor (;;) {\n\t\tdollar = memchr(src, '$', len);\n\t\tif (!dollar)\n\t\t\tbreak;\n\t\tmemcpy(dst, src, dollar + 1 - src);\n\t\tdst += dollar + 1 - src;\n\t\tlen -= dollar + 1 - src;\n\t\tsrc  = dollar + 1;\n\n\t\tif (len > 3 && !memcmp(src, \"Id:\", 3)) {\n\t\t\tdollar = memchr(src + 3, '$', len - 3);\n\t\t\tif (!dollar)\n\t\t\t\tbreak;\n\t\t\tmemcpy(dst, \"Id$\", 3);\n\t\t\tdst += 3;\n\t\t\tlen -= dollar + 1 - src;\n\t\t\tsrc  = dollar + 1;\n\t\t}\n\t}\n\tmemcpy(dst, src, len);\n\tstrbuf_setlen(buf, dst + len - buf->buf);\n\treturn 1;\n}\n\nstatic int ident_to_worktree(const char *path, const char *src, size_t len,\n                             struct strbuf *buf, int ident)\n{\n\tunsigned char sha1[20];\n\tchar *to_free = NULL, *dollar;\n\tint cnt;\n\n\tif (!ident)\n\t\treturn 0;\n\n\tcnt = count_ident(src, len);\n\tif (!cnt)\n\t\treturn 0;\n\n\t/* are we \"faking\" in place editing ? */\n\tif (src == buf->buf)\n\t\tto_free = strbuf_detach(buf);\n\thash_sha1_file(src, len, \"blob\", sha1);\n\n\tstrbuf_grow(buf, len + cnt * 43);\n\tfor (;;) {\n\t\t/* step 1: run to the next '$' */\n\t\tdollar = memchr(src, '$', len);\n\t\tif (!dollar)\n\t\t\tbreak;\n\t\tstrbuf_add(buf, src, dollar + 1 - src);\n\t\tlen -= dollar + 1 - src;\n\t\tsrc  = dollar + 1;\n\n\t\t/* step 2: does it looks like a bit like Id:xxx$ or Id$ ? */\n\t\tif (len < 3 || memcmp(\"Id\", src, 2))\n\t\t\tcontinue;\n\n\t\t/* step 3: skip over Id$ or Id:xxxxx$ */\n\t\tif (src[2] == '$') {\n\t\t\tsrc += 3;\n\t\t\tlen -= 3;\n\t\t} else if (src[2] == ':') {\n\t\t\t/*\n\t\t\t * It's possible that an expanded Id has crept its way into the\n\t\t\t * repository, we cope with that by stripping the expansion out\n\t\t\t */\n\t\t\tdollar = memchr(src + 3, '$', len - 3);\n\t\t\tif (!dollar) {\n\t\t\t\t/* incomplete keyword, no more '$', so just quit the loop */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlen -= dollar + 1 - src;\n\t\t\tsrc  = dollar + 1;\n\t\t} else {\n\t\t\t/* it wasn't a \"Id$\" or \"Id:xxxx$\" */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* step 4: substitute */\n\t\tstrbuf_addstr(buf, \"Id: \");\n\t\tstrbuf_add(buf, sha1_to_hex(sha1), 40);\n\t\tstrbuf_addstr(buf, \" $\");\n\t}\n\tstrbuf_add(buf, src, len);\n\n\tfree(to_free);\n\treturn 1;\n}\n\nstatic int git_path_check_crlf(const char *path, struct git_attr_check *check)\n{\n\tconst char *value = check->value;\n\n\tif (ATTR_TRUE(value))\n\t\treturn CRLF_TEXT;\n\telse if (ATTR_FALSE(value))\n\t\treturn CRLF_BINARY;\n\telse if (ATTR_UNSET(value))\n\t\t;\n\telse if (!strcmp(value, \"input\"))\n\t\treturn CRLF_INPUT;\n\treturn CRLF_GUESS;\n}\n\nstatic struct convert_driver *git_path_check_convert(const char *path,\n\t\t\t\t\t     struct git_attr_check *check)\n{\n\tconst char *value = check->value;\n\tstruct convert_driver *drv;\n\n\tif (ATTR_TRUE(value) || ATTR_FALSE(value) || ATTR_UNSET(value))\n\t\treturn NULL;\n\tfor (drv = user_convert; drv; drv = drv->next)\n\t\tif (!strcmp(value, drv->name))\n\t\t\treturn drv;\n\treturn NULL;\n}\n\nstatic int git_path_check_ident(const char *path, struct git_attr_check *check)\n{\n\tconst char *value = check->value;\n\n\treturn !!ATTR_TRUE(value);\n}\n\nint convert_to_git(const char *path, const char *src, size_t len, struct strbuf *dst)\n{\n\tstruct git_attr_check check[3];\n\tint crlf = CRLF_GUESS;\n\tint ident = 0, ret = 0;\n\tchar *filter = NULL;\n\n\tsetup_convert_check(check);\n\tif (!git_checkattr(path, ARRAY_SIZE(check), check)) {\n\t\tstruct convert_driver *drv;\n\t\tcrlf = git_path_check_crlf(path, check + 0);\n\t\tident = git_path_check_ident(path, check + 1);\n\t\tdrv = git_path_check_convert(path, check + 2);\n\t\tif (drv && drv->clean)\n\t\t\tfilter = drv->clean;\n\t}\n\n\tret |= apply_filter(path, src, len, dst, filter);\n\tif (ret) {\n\t\tsrc = dst->buf;\n\t\tlen = dst->len;\n\t}\n\tret |= crlf_to_git(path, src, len, dst, crlf);\n\tif (ret) {\n\t\tsrc = dst->buf;\n\t\tlen = dst->len;\n\t}\n\treturn ret | ident_to_git(path, src, len, dst, ident);\n}\n\nint convert_to_working_tree(const char *path, const char *src, size_t len, struct strbuf *dst)\n{\n\tstruct git_attr_check check[3];\n\tint crlf = CRLF_GUESS;\n\tint ident = 0, ret = 0;\n\tchar *filter = NULL;\n\n\tsetup_convert_check(check);\n\tif (!git_checkattr(path, ARRAY_SIZE(check), check)) {\n\t\tstruct convert_driver *drv;\n\t\tcrlf = git_path_check_crlf(path, check + 0);\n\t\tident = git_path_check_ident(path, check + 1);\n\t\tdrv = git_path_check_convert(path, check + 2);\n\t\tif (drv && drv->smudge)\n\t\t\tfilter = drv->smudge;\n\t}\n\n\tret |= ident_to_worktree(path, src, len, dst, ident);\n\tif (ret) {\n\t\tsrc = dst->buf;\n\t\tlen = dst->len;\n\t}\n\tret |= crlf_to_worktree(path, src, len, dst, crlf);\n\tif (ret) {\n\t\tsrc = dst->buf;\n\t\tlen = dst->len;\n\t}\n\treturn ret | apply_filter(path, src, len, dst, filter);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00a341c595ebb6ac6965001cce84d3d4e65f60c3",
  "sha1_ok": true,
  "size": 13677
}
