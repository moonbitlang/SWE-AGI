{
  "content": {
    "base64": "I2RlZmluZSBVU0VfVEhFX1JFUE9TSVRPUllfVkFSSUFCTEUKCiNpbmNsdWRlICJnaXQtY29tcGF0LXV0aWwuaCIKI2luY2x1ZGUgImVudmlyb25tZW50LmgiCiNpbmNsdWRlICJnZXR0ZXh0LmgiCiNpbmNsdWRlICJoZXguaCIKI2luY2x1ZGUgImxpc3QuaCIKI2luY2x1ZGUgInBhY2suaCIKI2luY2x1ZGUgInJlcG9zaXRvcnkuaCIKI2luY2x1ZGUgImRpci5oIgojaW5jbHVkZSAibWVyZ2Vzb3J0LmgiCiNpbmNsdWRlICJwYWNrZmlsZS5oIgojaW5jbHVkZSAiZGVsdGEuaCIKI2luY2x1ZGUgImhhc2gtbG9va3VwLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgIm9iamVjdC5oIgojaW5jbHVkZSAidGFnLmgiCiNpbmNsdWRlICJ0cmFjZS5oIgojaW5jbHVkZSAidHJlZS13YWxrLmgiCiNpbmNsdWRlICJ0cmVlLmgiCiNpbmNsdWRlICJvYmplY3QtZmlsZS5oIgojaW5jbHVkZSAib2JqZWN0LXN0b3JlLWxsLmgiCiNpbmNsdWRlICJtaWR4LmgiCiNpbmNsdWRlICJjb21taXQtZ3JhcGguaCIKI2luY2x1ZGUgInBhY2stcmV2aW5kZXguaCIKI2luY2x1ZGUgInByb21pc29yLXJlbW90ZS5oIgoKY2hhciAqb2RiX3BhY2tfbmFtZShzdHJ1Y3Qgc3RyYnVmICpidWYsCgkJICAgIGNvbnN0IHVuc2lnbmVkIGNoYXIgKmhhc2gsCgkJICAgIGNvbnN0IGNoYXIgKmV4dCkKewoJc3RyYnVmX3Jlc2V0KGJ1Zik7CglzdHJidWZfYWRkZihidWYsICIlcy9wYWNrL3BhY2stJXMuJXMiLCByZXBvX2dldF9vYmplY3RfZGlyZWN0b3J5KHRoZV9yZXBvc2l0b3J5KSwKCQkgICAgaGFzaF90b19oZXgoaGFzaCksIGV4dCk7CglyZXR1cm4gYnVmLT5idWY7Cn0KCnN0YXRpYyB1bnNpZ25lZCBpbnQgcGFja191c2VkX2N0cjsKc3RhdGljIHVuc2lnbmVkIGludCBwYWNrX21tYXBfY2FsbHM7CnN0YXRpYyB1bnNpZ25lZCBpbnQgcGVha19wYWNrX29wZW5fd2luZG93czsKc3RhdGljIHVuc2lnbmVkIGludCBwYWNrX29wZW5fd2luZG93czsKc3RhdGljIHVuc2lnbmVkIGludCBwYWNrX29wZW5fZmRzOwpzdGF0aWMgdW5zaWduZWQgaW50IHBhY2tfbWF4X2ZkczsKc3RhdGljIHNpemVfdCBwZWFrX3BhY2tfbWFwcGVkOwpzdGF0aWMgc2l6ZV90IHBhY2tfbWFwcGVkOwoKI2RlZmluZSBTWl9GTVQgUFJJdU1BWApzdGF0aWMgaW5saW5lIHVpbnRtYXhfdCBzel9mbXQoc2l6ZV90IHMpIHsgcmV0dXJuIHM7IH0KCnZvaWQgcGFja19yZXBvcnQodm9pZCkKewoJZnByaW50ZihzdGRlcnIsCgkJInBhY2tfcmVwb3J0OiBnZXRwYWdlc2l6ZSgpICAgICAgICAgICAgPSAlMTAiIFNaX0ZNVCAiXG4iCgkJInBhY2tfcmVwb3J0OiBjb3JlLnBhY2tlZEdpdFdpbmRvd1NpemUgPSAlMTAiIFNaX0ZNVCAiXG4iCgkJInBhY2tfcmVwb3J0OiBjb3JlLnBhY2tlZEdpdExpbWl0ICAgICAgPSAlMTAiIFNaX0ZNVCAiXG4iLAoJCXN6X2ZtdChnZXRwYWdlc2l6ZSgpKSwKCQlzel9mbXQocGFja2VkX2dpdF93aW5kb3dfc2l6ZSksCgkJc3pfZm10KHBhY2tlZF9naXRfbGltaXQpKTsKCWZwcmludGYoc3RkZXJyLAoJCSJwYWNrX3JlcG9ydDogcGFja191c2VkX2N0ciAgICAgICAgICAgID0gJTEwdVxuIgoJCSJwYWNrX3JlcG9ydDogcGFja19tbWFwX2NhbGxzICAgICAgICAgID0gJTEwdVxuIgoJCSJwYWNrX3JlcG9ydDogcGFja19vcGVuX3dpbmRvd3MgICAgICAgID0gJTEwdSAvICUxMHVcbiIKCQkicGFja19yZXBvcnQ6IHBhY2tfbWFwcGVkICAgICAgICAgICAgICA9ICIKCQkJIiUxMCIgU1pfRk1UICIgLyAlMTAiIFNaX0ZNVCAiXG4iLAoJCXBhY2tfdXNlZF9jdHIsCgkJcGFja19tbWFwX2NhbGxzLAoJCXBhY2tfb3Blbl93aW5kb3dzLCBwZWFrX3BhY2tfb3Blbl93aW5kb3dzLAoJCXN6X2ZtdChwYWNrX21hcHBlZCksIHN6X2ZtdChwZWFrX3BhY2tfbWFwcGVkKSk7Cn0KCi8qCiAqIE9wZW4gYW5kIG1tYXAgdGhlIGluZGV4IGZpbGUgYXQgcGF0aCwgcGVyZm9ybSBhIGNvdXBsZSBvZgogKiBjb25zaXN0ZW5jeSBjaGVja3MsIHRoZW4gcmVjb3JkIGl0cyBpbmZvcm1hdGlvbiB0byBwLiAgUmV0dXJuIDAgb24KICogc3VjY2Vzcy4KICovCnN0YXRpYyBpbnQgY2hlY2tfcGFja2VkX2dpdF9pZHgoY29uc3QgY2hhciAqcGF0aCwgc3RydWN0IHBhY2tlZF9naXQgKnApCnsKCXZvaWQgKmlkeF9tYXA7CglzaXplX3QgaWR4X3NpemU7CglpbnQgZmQgPSBnaXRfb3BlbihwYXRoKSwgcmV0OwoJc3RydWN0IHN0YXQgc3Q7Cgljb25zdCB1bnNpZ25lZCBpbnQgaGFzaHN6ID0gdGhlX2hhc2hfYWxnby0+cmF3c3o7CgoJaWYgKGZkIDwgMCkKCQlyZXR1cm4gLTE7CglpZiAoZnN0YXQoZmQsICZzdCkpIHsKCQljbG9zZShmZCk7CgkJcmV0dXJuIC0xOwoJfQoJaWR4X3NpemUgPSB4c2l6ZV90KHN0LnN0X3NpemUpOwoJaWYgKGlkeF9zaXplIDwgNCAqIDI1NiArIGhhc2hzeiArIGhhc2hzeikgewoJCWNsb3NlKGZkKTsKCQlyZXR1cm4gZXJyb3IoImluZGV4IGZpbGUgJXMgaXMgdG9vIHNtYWxsIiwgcGF0aCk7Cgl9CglpZHhfbWFwID0geG1tYXAoTlVMTCwgaWR4X3NpemUsIFBST1RfUkVBRCwgTUFQX1BSSVZBVEUsIGZkLCAwKTsKCWNsb3NlKGZkKTsKCglyZXQgPSBsb2FkX2lkeChwYXRoLCBoYXNoc3osIGlkeF9tYXAsIGlkeF9zaXplLCBwKTsKCglpZiAocmV0KQoJCW11bm1hcChpZHhfbWFwLCBpZHhfc2l6ZSk7CgoJcmV0dXJuIHJldDsKfQoKaW50IGxvYWRfaWR4KGNvbnN0IGNoYXIgKnBhdGgsIGNvbnN0IHVuc2lnbmVkIGludCBoYXNoc3osIHZvaWQgKmlkeF9tYXAsCgkgICAgIHNpemVfdCBpZHhfc2l6ZSwgc3RydWN0IHBhY2tlZF9naXQgKnApCnsKCXN0cnVjdCBwYWNrX2lkeF9oZWFkZXIgKmhkciA9IGlkeF9tYXA7Cgl1aW50MzJfdCB2ZXJzaW9uLCBuciwgaSwgKmluZGV4OwoKCWlmIChpZHhfc2l6ZSA8IDQgKiAyNTYgKyBoYXNoc3ogKyBoYXNoc3opCgkJcmV0dXJuIGVycm9yKCJpbmRleCBmaWxlICVzIGlzIHRvbyBzbWFsbCIsIHBhdGgpOwoJaWYgKCFpZHhfbWFwKQoJCXJldHVybiBlcnJvcigiZW1wdHkgZGF0YSIpOwoKCWlmIChoZHItPmlkeF9zaWduYXR1cmUgPT0gaHRvbmwoUEFDS19JRFhfU0lHTkFUVVJFKSkgewoJCXZlcnNpb24gPSBudG9obChoZHItPmlkeF92ZXJzaW9uKTsKCQlpZiAodmVyc2lvbiA8IDIgfHwgdmVyc2lvbiA+IDIpCgkJCXJldHVybiBlcnJvcigiaW5kZXggZmlsZSAlcyBpcyB2ZXJzaW9uICUiUFJJdTMyCgkJCQkgICAgICIgYW5kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBiaW5hcnkiCgkJCQkgICAgICIgKHRyeSB1cGdyYWRpbmcgR0lUIHRvIGEgbmV3ZXIgdmVyc2lvbikiLAoJCQkJICAgICBwYXRoLCB2ZXJzaW9uKTsKCX0gZWxzZQoJCXZlcnNpb24gPSAxOwoKCW5yID0gMDsKCWluZGV4ID0gaWR4X21hcDsKCWlmICh2ZXJzaW9uID4gMSkKCQlpbmRleCArPSAyOyAgLyogc2tpcCBpbmRleCBoZWFkZXIgKi8KCWZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykgewoJCXVpbnQzMl90IG4gPSBudG9obChpbmRleFtpXSk7CgkJaWYgKG4gPCBucikKCQkJcmV0dXJuIGVycm9yKCJub24tbW9ub3RvbmljIGluZGV4ICVzIiwgcGF0aCk7CgkJbnIgPSBuOwoJfQoKCWlmICh2ZXJzaW9uID09IDEpIHsKCQkvKgoJCSAqIFRvdGFsIHNpemU6CgkJICogIC0gMjU2IGluZGV4IGVudHJpZXMgNCBieXRlcyBlYWNoCgkJICogIC0gMjQtYnl0ZSBlbnRyaWVzICogbnIgKG9iamVjdCBJRCArIDQtYnl0ZSBvZmZzZXQpCgkJICogIC0gaGFzaCBvZiB0aGUgcGFja2ZpbGUKCQkgKiAgLSBmaWxlIGNoZWNrc3VtCgkJICovCgkJaWYgKGlkeF9zaXplICE9IHN0X2FkZCg0ICogMjU2ICsgaGFzaHN6ICsgaGFzaHN6LCBzdF9tdWx0KG5yLCBoYXNoc3ogKyA0KSkpCgkJCXJldHVybiBlcnJvcigid3JvbmcgaW5kZXggdjEgZmlsZSBzaXplIGluICVzIiwgcGF0aCk7Cgl9IGVsc2UgaWYgKHZlcnNpb24gPT0gMikgewoJCS8qCgkJICogTWluaW11bSBzaXplOgoJCSAqICAtIDggYnl0ZXMgb2YgaGVhZGVyCgkJICogIC0gMjU2IGluZGV4IGVudHJpZXMgNCBieXRlcyBlYWNoCgkJICogIC0gb2JqZWN0IElEIGVudHJ5ICogbnIKCQkgKiAgLSA0LWJ5dGUgY3JjIGVudHJ5ICogbnIKCQkgKiAgLSA0LWJ5dGUgb2Zmc2V0IGVudHJ5ICogbnIKCQkgKiAgLSBoYXNoIG9mIHRoZSBwYWNrZmlsZQoJCSAqICAtIGZpbGUgY2hlY2tzdW0KCQkgKiBBbmQgYWZ0ZXIgdGhlIDQtYnl0ZSBvZmZzZXQgdGFibGUgbWlnaHQgYmUgYQoJCSAqIHZhcmlhYmxlIHNpemVkIHRhYmxlIGNvbnRhaW5pbmcgOC1ieXRlIGVudHJpZXMKCQkgKiBmb3Igb2Zmc2V0cyBsYXJnZXIgdGhhbiAyXjMxLgoJCSAqLwoJCXNpemVfdCBtaW5fc2l6ZSA9IHN0X2FkZCg4ICsgNCoyNTYgKyBoYXNoc3ogKyBoYXNoc3osIHN0X211bHQobnIsIGhhc2hzeiArIDQgKyA0KSk7CgkJc2l6ZV90IG1heF9zaXplID0gbWluX3NpemU7CgkJaWYgKG5yKQoJCQltYXhfc2l6ZSA9IHN0X2FkZChtYXhfc2l6ZSwgc3RfbXVsdChuciAtIDEsIDgpKTsKCQlpZiAoaWR4X3NpemUgPCBtaW5fc2l6ZSB8fCBpZHhfc2l6ZSA+IG1heF9zaXplKQoJCQlyZXR1cm4gZXJyb3IoIndyb25nIGluZGV4IHYyIGZpbGUgc2l6ZSBpbiAlcyIsIHBhdGgpOwoJCWlmIChpZHhfc2l6ZSAhPSBtaW5fc2l6ZSAmJgoJCSAgICAvKgoJCSAgICAgKiBtYWtlIHN1cmUgd2UgY2FuIGRlYWwgd2l0aCBsYXJnZSBwYWNrIG9mZnNldHMuCgkJICAgICAqIDMxLWJpdCBzaWduZWQgb2Zmc2V0IHdvbid0IGJlIGVub3VnaCwgbmVpdGhlcgoJCSAgICAgKiAzMi1iaXQgdW5zaWduZWQgb25lIHdpbGwgYmUuCgkJICAgICAqLwoJCSAgICAoc2l6ZW9mKG9mZl90KSA8PSA0KSkKCQkJcmV0dXJuIGVycm9yKCJwYWNrIHRvbyBsYXJnZSBmb3IgY3VycmVudCBkZWZpbml0aW9uIG9mIG9mZl90IGluICVzIiwgcGF0aCk7CgkJcC0+Y3JjX29mZnNldCA9IHN0X2FkZCg4ICsgNCAqIDI1Niwgc3RfbXVsdChuciwgaGFzaHN6KSk7Cgl9CgoJcC0+aW5kZXhfdmVyc2lvbiA9IHZlcnNpb247CglwLT5pbmRleF9kYXRhID0gaWR4X21hcDsKCXAtPmluZGV4X3NpemUgPSBpZHhfc2l6ZTsKCXAtPm51bV9vYmplY3RzID0gbnI7CglyZXR1cm4gMDsKfQoKaW50IG9wZW5fcGFja19pbmRleChzdHJ1Y3QgcGFja2VkX2dpdCAqcCkKewoJY2hhciAqaWR4X25hbWU7CglzaXplX3QgbGVuOwoJaW50IHJldDsKCglpZiAocC0+aW5kZXhfZGF0YSkKCQlyZXR1cm4gMDsKCglpZiAoIXN0cmlwX3N1ZmZpeChwLT5wYWNrX25hbWUsICIucGFjayIsICZsZW4pKQoJCUJVRygicGFja19uYW1lIGRvZXMgbm90IGVuZCBpbiAucGFjayIpOwoJaWR4X25hbWUgPSB4c3RyZm10KCIlLipzLmlkeCIsIChpbnQpbGVuLCBwLT5wYWNrX25hbWUpOwoJcmV0ID0gY2hlY2tfcGFja2VkX2dpdF9pZHgoaWR4X25hbWUsIHApOwoJZnJlZShpZHhfbmFtZSk7CglyZXR1cm4gcmV0Owp9Cgp1aW50MzJfdCBnZXRfcGFja19mYW5vdXQoc3RydWN0IHBhY2tlZF9naXQgKnAsIHVpbnQzMl90IHZhbHVlKQp7Cgljb25zdCB1aW50MzJfdCAqbGV2ZWwxX29mcyA9IHAtPmluZGV4X2RhdGE7CgoJaWYgKCFsZXZlbDFfb2ZzKSB7CgkJaWYgKG9wZW5fcGFja19pbmRleChwKSkKCQkJcmV0dXJuIDA7CgkJbGV2ZWwxX29mcyA9IHAtPmluZGV4X2RhdGE7Cgl9CgoJaWYgKHAtPmluZGV4X3ZlcnNpb24gPiAxKSB7CgkJbGV2ZWwxX29mcyArPSAyOwoJfQoKCXJldHVybiBudG9obChsZXZlbDFfb2ZzW3ZhbHVlXSk7Cn0KCnN0YXRpYyBzdHJ1Y3QgcGFja2VkX2dpdCAqYWxsb2NfcGFja2VkX2dpdChpbnQgZXh0cmEpCnsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwID0geG1hbGxvYyhzdF9hZGQoc2l6ZW9mKCpwKSwgZXh0cmEpKTsKCW1lbXNldChwLCAwLCBzaXplb2YoKnApKTsKCXAtPnBhY2tfZmQgPSAtMTsKCXJldHVybiBwOwp9CgpzdGF0aWMgY2hhciAqcGFja19wYXRoX2Zyb21faWR4KGNvbnN0IGNoYXIgKmlkeF9wYXRoKQp7CglzaXplX3QgbGVuOwoJaWYgKCFzdHJpcF9zdWZmaXgoaWR4X3BhdGgsICIuaWR4IiwgJmxlbikpCgkJQlVHKCJpZHggcGF0aCBkb2VzIG5vdCBlbmQgaW4gLmlkeDogJXMiLCBpZHhfcGF0aCk7CglyZXR1cm4geHN0cmZtdCgiJS4qcy5wYWNrIiwgKGludClsZW4sIGlkeF9wYXRoKTsKfQoKc3RydWN0IHBhY2tlZF9naXQgKnBhcnNlX3BhY2tfaW5kZXgodW5zaWduZWQgY2hhciAqc2hhMSwgY29uc3QgY2hhciAqaWR4X3BhdGgpCnsKCWNoYXIgKnBhdGggPSBwYWNrX3BhdGhfZnJvbV9pZHgoaWR4X3BhdGgpOwoJc2l6ZV90IGFsbG9jID0gc3RfYWRkKHN0cmxlbihwYXRoKSwgMSk7CglzdHJ1Y3QgcGFja2VkX2dpdCAqcCA9IGFsbG9jX3BhY2tlZF9naXQoYWxsb2MpOwoKCW1lbWNweShwLT5wYWNrX25hbWUsIHBhdGgsIGFsbG9jKTsgLyogaW5jbHVkZXMgTlVMICovCglmcmVlKHBhdGgpOwoJaGFzaGNweShwLT5oYXNoLCBzaGExLCB0aGVfcmVwb3NpdG9yeS0+aGFzaF9hbGdvKTsKCWlmIChjaGVja19wYWNrZWRfZ2l0X2lkeChpZHhfcGF0aCwgcCkpIHsKCQlmcmVlKHApOwoJCXJldHVybiBOVUxMOwoJfQoKCXJldHVybiBwOwp9CgpzdGF0aWMgdm9pZCBzY2FuX3dpbmRvd3Moc3RydWN0IHBhY2tlZF9naXQgKnAsCglzdHJ1Y3QgcGFja2VkX2dpdCAqKmxydV9wLAoJc3RydWN0IHBhY2tfd2luZG93ICoqbHJ1X3csCglzdHJ1Y3QgcGFja193aW5kb3cgKipscnVfbCkKewoJc3RydWN0IHBhY2tfd2luZG93ICp3LCAqd19sOwoKCWZvciAod19sID0gTlVMTCwgdyA9IHAtPndpbmRvd3M7IHc7IHcgPSB3LT5uZXh0KSB7CgkJaWYgKCF3LT5pbnVzZV9jbnQpIHsKCQkJaWYgKCEqbHJ1X3cgfHwgdy0+bGFzdF91c2VkIDwgKCpscnVfdyktPmxhc3RfdXNlZCkgewoJCQkJKmxydV9wID0gcDsKCQkJCSpscnVfdyA9IHc7CgkJCQkqbHJ1X2wgPSB3X2w7CgkJCX0KCQl9CgkJd19sID0gdzsKCX0KfQoKc3RhdGljIGludCB1bnVzZV9vbmVfd2luZG93KHN0cnVjdCBwYWNrZWRfZ2l0ICpjdXJyZW50KQp7CglzdHJ1Y3QgcGFja2VkX2dpdCAqcCwgKmxydV9wID0gTlVMTDsKCXN0cnVjdCBwYWNrX3dpbmRvdyAqbHJ1X3cgPSBOVUxMLCAqbHJ1X2wgPSBOVUxMOwoKCWlmIChjdXJyZW50KQoJCXNjYW5fd2luZG93cyhjdXJyZW50LCAmbHJ1X3AsICZscnVfdywgJmxydV9sKTsKCWZvciAocCA9IHRoZV9yZXBvc2l0b3J5LT5vYmplY3RzLT5wYWNrZWRfZ2l0OyBwOyBwID0gcC0+bmV4dCkKCQlzY2FuX3dpbmRvd3MocCwgJmxydV9wLCAmbHJ1X3csICZscnVfbCk7CglpZiAobHJ1X3ApIHsKCQltdW5tYXAobHJ1X3ctPmJhc2UsIGxydV93LT5sZW4pOwoJCXBhY2tfbWFwcGVkIC09IGxydV93LT5sZW47CgkJaWYgKGxydV9sKQoJCQlscnVfbC0+bmV4dCA9IGxydV93LT5uZXh0OwoJCWVsc2UKCQkJbHJ1X3AtPndpbmRvd3MgPSBscnVfdy0+bmV4dDsKCQlmcmVlKGxydV93KTsKCQlwYWNrX29wZW5fd2luZG93cy0tOwoJCXJldHVybiAxOwoJfQoJcmV0dXJuIDA7Cn0KCnZvaWQgY2xvc2VfcGFja193aW5kb3dzKHN0cnVjdCBwYWNrZWRfZ2l0ICpwKQp7Cgl3aGlsZSAocC0+d2luZG93cykgewoJCXN0cnVjdCBwYWNrX3dpbmRvdyAqdyA9IHAtPndpbmRvd3M7CgoJCWlmICh3LT5pbnVzZV9jbnQpCgkJCWRpZSgicGFjayAnJXMnIHN0aWxsIGhhcyBvcGVuIHdpbmRvd3MgdG8gaXQiLAoJCQkgICAgcC0+cGFja19uYW1lKTsKCQltdW5tYXAody0+YmFzZSwgdy0+bGVuKTsKCQlwYWNrX21hcHBlZCAtPSB3LT5sZW47CgkJcGFja19vcGVuX3dpbmRvd3MtLTsKCQlwLT53aW5kb3dzID0gdy0+bmV4dDsKCQlmcmVlKHcpOwoJfQp9CgppbnQgY2xvc2VfcGFja19mZChzdHJ1Y3QgcGFja2VkX2dpdCAqcCkKewoJaWYgKHAtPnBhY2tfZmQgPCAwKQoJCXJldHVybiAwOwoKCWNsb3NlKHAtPnBhY2tfZmQpOwoJcGFja19vcGVuX2Zkcy0tOwoJcC0+cGFja19mZCA9IC0xOwoKCXJldHVybiAxOwp9Cgp2b2lkIGNsb3NlX3BhY2tfaW5kZXgoc3RydWN0IHBhY2tlZF9naXQgKnApCnsKCWlmIChwLT5pbmRleF9kYXRhKSB7CgkJbXVubWFwKCh2b2lkICopcC0+aW5kZXhfZGF0YSwgcC0+aW5kZXhfc2l6ZSk7CgkJcC0+aW5kZXhfZGF0YSA9IE5VTEw7Cgl9Cn0KCnN0YXRpYyB2b2lkIGNsb3NlX3BhY2tfcmV2aW5kZXgoc3RydWN0IHBhY2tlZF9naXQgKnApCnsKCWlmICghcC0+cmV2aW5kZXhfbWFwKQoJCXJldHVybjsKCgltdW5tYXAoKHZvaWQgKilwLT5yZXZpbmRleF9tYXAsIHAtPnJldmluZGV4X3NpemUpOwoJcC0+cmV2aW5kZXhfbWFwID0gTlVMTDsKCXAtPnJldmluZGV4X2RhdGEgPSBOVUxMOwp9CgpzdGF0aWMgdm9pZCBjbG9zZV9wYWNrX210aW1lcyhzdHJ1Y3QgcGFja2VkX2dpdCAqcCkKewoJaWYgKCFwLT5tdGltZXNfbWFwKQoJCXJldHVybjsKCgltdW5tYXAoKHZvaWQgKilwLT5tdGltZXNfbWFwLCBwLT5tdGltZXNfc2l6ZSk7CglwLT5tdGltZXNfbWFwID0gTlVMTDsKfQoKdm9pZCBjbG9zZV9wYWNrKHN0cnVjdCBwYWNrZWRfZ2l0ICpwKQp7CgljbG9zZV9wYWNrX3dpbmRvd3MocCk7CgljbG9zZV9wYWNrX2ZkKHApOwoJY2xvc2VfcGFja19pbmRleChwKTsKCWNsb3NlX3BhY2tfcmV2aW5kZXgocCk7CgljbG9zZV9wYWNrX210aW1lcyhwKTsKCW9pZHNldF9jbGVhcigmcC0+YmFkX29iamVjdHMpOwp9Cgp2b2lkIGNsb3NlX29iamVjdF9zdG9yZShzdHJ1Y3QgcmF3X29iamVjdF9zdG9yZSAqbykKewoJc3RydWN0IHBhY2tlZF9naXQgKnA7CgoJZm9yIChwID0gby0+cGFja2VkX2dpdDsgcDsgcCA9IHAtPm5leHQpCgkJaWYgKHAtPmRvX25vdF9jbG9zZSkKCQkJQlVHKCJ3YW50IHRvIGNsb3NlIHBhY2sgbWFya2VkICdkby1ub3QtY2xvc2UnIik7CgkJZWxzZQoJCQljbG9zZV9wYWNrKHApOwoKCWlmIChvLT5tdWx0aV9wYWNrX2luZGV4KSB7CgkJY2xvc2VfbWlkeChvLT5tdWx0aV9wYWNrX2luZGV4KTsKCQlvLT5tdWx0aV9wYWNrX2luZGV4ID0gTlVMTDsKCX0KCgljbG9zZV9jb21taXRfZ3JhcGgobyk7Cn0KCnZvaWQgdW5saW5rX3BhY2tfcGF0aChjb25zdCBjaGFyICpwYWNrX25hbWUsIGludCBmb3JjZV9kZWxldGUpCnsKCXN0YXRpYyBjb25zdCBjaGFyICpleHRzW10gPSB7Ii5pZHgiLCAiLnBhY2siLCAiLnJldiIsICIua2VlcCIsICIuYml0bWFwIiwgIi5wcm9taXNvciIsICIubXRpbWVzIn07CglpbnQgaTsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglzaXplX3QgcGxlbjsKCglzdHJidWZfYWRkc3RyKCZidWYsIHBhY2tfbmFtZSk7CglzdHJpcF9zdWZmaXhfbWVtKGJ1Zi5idWYsICZidWYubGVuLCAiLnBhY2siKTsKCXBsZW4gPSBidWYubGVuOwoKCWlmICghZm9yY2VfZGVsZXRlKSB7CgkJc3RyYnVmX2FkZHN0cigmYnVmLCAiLmtlZXAiKTsKCQlpZiAoIWFjY2VzcyhidWYuYnVmLCBGX09LKSkgewoJCQlzdHJidWZfcmVsZWFzZSgmYnVmKTsKCQkJcmV0dXJuOwoJCX0KCX0KCglmb3IgKGkgPSAwOyBpIDwgQVJSQVlfU0laRShleHRzKTsgaSsrKSB7CgkJc3RyYnVmX3NldGxlbigmYnVmLCBwbGVuKTsKCQlzdHJidWZfYWRkc3RyKCZidWYsIGV4dHNbaV0pOwoJCXVubGluayhidWYuYnVmKTsKCX0KCglzdHJidWZfcmVsZWFzZSgmYnVmKTsKfQoKLyoKICogVGhlIExSVSBwYWNrIGlzIHRoZSBvbmUgd2l0aCB0aGUgb2xkZXN0IE1SVSB3aW5kb3csIHByZWZlcnJpbmcgcGFja3MKICogd2l0aCBubyB1c2VkIHdpbmRvd3MsIG9yIHRoZSBvbGRlc3QgbXRpbWUgaWYgaXQgaGFzIG5vIHdpbmRvd3MgYWxsb2NhdGVkLgogKi8Kc3RhdGljIHZvaWQgZmluZF9scnVfcGFjayhzdHJ1Y3QgcGFja2VkX2dpdCAqcCwgc3RydWN0IHBhY2tlZF9naXQgKipscnVfcCwgc3RydWN0IHBhY2tfd2luZG93ICoqbXJ1X3csIGludCAqYWNjZXB0X3dpbmRvd3NfaW51c2UpCnsKCXN0cnVjdCBwYWNrX3dpbmRvdyAqdywgKnRoaXNfbXJ1X3c7CglpbnQgaGFzX3dpbmRvd3NfaW51c2UgPSAwOwoKCS8qCgkgKiBSZWplY3QgdGhpcyBwYWNrIGlmIGl0IGhhcyB3aW5kb3dzIGFuZCB0aGUgcHJldmlvdXNseSBzZWxlY3RlZAoJICogb25lIGRvZXMgbm90LiAgSWYgdGhpcyBwYWNrIGRvZXMgbm90IGhhdmUgd2luZG93cywgcmVqZWN0CgkgKiBpdCBpZiB0aGUgcGFjayBmaWxlIGlzIG5ld2VyIHRoYW4gdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQgb25lLgoJICovCglpZiAoKmxydV9wICYmICEqbXJ1X3cgJiYgKHAtPndpbmRvd3MgfHwgcC0+bXRpbWUgPiAoKmxydV9wKS0+bXRpbWUpKQoJCXJldHVybjsKCglmb3IgKHcgPSB0aGlzX21ydV93ID0gcC0+d2luZG93czsgdzsgdyA9IHctPm5leHQpIHsKCQkvKgoJCSAqIFJlamVjdCB0aGlzIHBhY2sgaWYgYW55IG9mIGl0cyB3aW5kb3dzIGFyZSBpbiB1c2UsCgkJICogYnV0IHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIHBhY2sgZGlkIG5vdCBoYXZlIGFueQoJCSAqIGludXNlIHdpbmRvd3MuICBPdGhlcndpc2UsIHJlY29yZCB0aGF0IHRoaXMgcGFjawoJCSAqIGhhcyB3aW5kb3dzIGluIHVzZS4KCQkgKi8KCQlpZiAody0+aW51c2VfY250KSB7CgkJCWlmICgqYWNjZXB0X3dpbmRvd3NfaW51c2UpCgkJCQloYXNfd2luZG93c19pbnVzZSA9IDE7CgkJCWVsc2UKCQkJCXJldHVybjsKCQl9CgoJCWlmICh3LT5sYXN0X3VzZWQgPiB0aGlzX21ydV93LT5sYXN0X3VzZWQpCgkJCXRoaXNfbXJ1X3cgPSB3OwoKCQkvKgoJCSAqIFJlamVjdCB0aGlzIHBhY2sgaWYgaXQgaGFzIHdpbmRvd3MgdGhhdCBoYXZlIGJlZW4KCQkgKiB1c2VkIG1vcmUgcmVjZW50bHkgdGhhbiB0aGUgcHJldmlvdXNseSBzZWxlY3RlZCBwYWNrLgoJCSAqIElmIHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIHBhY2sgaGFkIHdpbmRvd3MgaW51c2UgYW5kCgkJICogd2UgaGF2ZSBub3QgZW5jb3VudGVyZWQgYSB3aW5kb3cgaW4gdGhpcyBwYWNrIHRoYXQgaXMKCQkgKiBpbnVzZSwgc2tpcCB0aGlzIGNoZWNrIHNpbmNlIHdlIHByZWZlciBhIHBhY2sgd2l0aCBubwoJCSAqIGludXNlIHdpbmRvd3MgdG8gb25lIHRoYXQgaGFzIGludXNlIHdpbmRvd3MuCgkJICovCgkJaWYgKCptcnVfdyAmJiAqYWNjZXB0X3dpbmRvd3NfaW51c2UgPT0gaGFzX3dpbmRvd3NfaW51c2UgJiYKCQkgICAgdGhpc19tcnVfdy0+bGFzdF91c2VkID4gKCptcnVfdyktPmxhc3RfdXNlZCkKCQkJcmV0dXJuOwoJfQoKCS8qCgkgKiBTZWxlY3QgdGhpcyBwYWNrLgoJICovCgkqbXJ1X3cgPSB0aGlzX21ydV93OwoJKmxydV9wID0gcDsKCSphY2NlcHRfd2luZG93c19pbnVzZSA9IGhhc193aW5kb3dzX2ludXNlOwp9CgpzdGF0aWMgaW50IGNsb3NlX29uZV9wYWNrKHZvaWQpCnsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwLCAqbHJ1X3AgPSBOVUxMOwoJc3RydWN0IHBhY2tfd2luZG93ICptcnVfdyA9IE5VTEw7CglpbnQgYWNjZXB0X3dpbmRvd3NfaW51c2UgPSAxOwoKCWZvciAocCA9IHRoZV9yZXBvc2l0b3J5LT5vYmplY3RzLT5wYWNrZWRfZ2l0OyBwOyBwID0gcC0+bmV4dCkgewoJCWlmIChwLT5wYWNrX2ZkID09IC0xKQoJCQljb250aW51ZTsKCQlmaW5kX2xydV9wYWNrKHAsICZscnVfcCwgJm1ydV93LCAmYWNjZXB0X3dpbmRvd3NfaW51c2UpOwoJfQoKCWlmIChscnVfcCkKCQlyZXR1cm4gY2xvc2VfcGFja19mZChscnVfcCk7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB1bnNpZ25lZCBpbnQgZ2V0X21heF9mZF9saW1pdCh2b2lkKQp7CiNpZmRlZiBSTElNSVRfTk9GSUxFCgl7CgkJc3RydWN0IHJsaW1pdCBsaW07CgoJCWlmICghZ2V0cmxpbWl0KFJMSU1JVF9OT0ZJTEUsICZsaW0pKQoJCQlyZXR1cm4gbGltLnJsaW1fY3VyOwoJfQojZW5kaWYKCiNpZmRlZiBfU0NfT1BFTl9NQVgKCXsKCQlsb25nIG9wZW5fbWF4ID0gc3lzY29uZihfU0NfT1BFTl9NQVgpOwoJCWlmICgwIDwgb3Blbl9tYXgpCgkJCXJldHVybiBvcGVuX21heDsKCQkvKgoJCSAqIE90aGVyd2lzZSwgd2UgZ290IC0xIGZvciBvbmUgb2YgdGhlIHR3bwoJCSAqIHJlYXNvbnM6CgkJICoKCQkgKiAoMSkgc3lzY29uZigpIGRpZCBub3QgdW5kZXJzdGFuZCBfU0NfT1BFTl9NQVgKCQkgKiAgICAgYW5kIHNpZ25hbGVkIGFuIGVycm9yIHdpdGggLTE7IG9yCgkJICogKDIpIHN5c2NvbmYoKSBzYWlkIHRoZXJlIGlzIG5vIGxpbWl0LgoJCSAqCgkJICogV2UgX2NvdWxkXyBjbGVhciBlcnJubyBiZWZvcmUgY2FsbGluZyBzeXNjb25mKCkgdG8KCQkgKiB0ZWxsIHRoZXNlIHR3byBjYXNlcyBhcGFydCBhbmQgcmV0dXJuIGEgaHVnZSBudW1iZXIKCQkgKiBpbiB0aGUgbGF0dGVyIGNhc2UgdG8gbGV0IHRoZSBjYWxsZXIgY2FwIGl0IHRvIGEKCQkgKiB2YWx1ZSB0aGF0IGlzIG5vdCBzbyBzZWxmaXNoLCBidXQgbGV0dGluZyB0aGUKCQkgKiBmYWxsYmFjayBPUEVOX01BWCBjb2RlcGF0aCB0YWtlIGNhcmUgb2YgdGhlc2UgY2FzZXMKCQkgKiBpcyBhIGxvdCBzaW1wbGVyLgoJCSAqLwoJfQojZW5kaWYKCiNpZmRlZiBPUEVOX01BWAoJcmV0dXJuIE9QRU5fTUFYOwojZWxzZQoJcmV0dXJuIDE7IC8qIHNlZSB0aGUgY2FsbGVyIDstKSAqLwojZW5kaWYKfQoKY29uc3QgY2hhciAqcGFja19iYXNlbmFtZShzdHJ1Y3QgcGFja2VkX2dpdCAqcCkKewoJY29uc3QgY2hhciAqcmV0ID0gc3RycmNocihwLT5wYWNrX25hbWUsICcvJyk7CglpZiAocmV0KQoJCXJldCA9IHJldCArIDE7IC8qIHNraXAgcGFzdCBzbGFzaCAqLwoJZWxzZQoJCXJldCA9IHAtPnBhY2tfbmFtZTsgLyogd2Ugb25seSBoYXZlIGEgYmFzZSAqLwoJcmV0dXJuIHJldDsKfQoKLyoKICogRG8gbm90IGNhbGwgdGhpcyBkaXJlY3RseSBhcyB0aGlzIGxlYWtzIHAtPnBhY2tfZmQgb24gZXJyb3IgcmV0dXJuOwogKiBjYWxsIG9wZW5fcGFja2VkX2dpdCgpIGluc3RlYWQuCiAqLwpzdGF0aWMgaW50IG9wZW5fcGFja2VkX2dpdF8xKHN0cnVjdCBwYWNrZWRfZ2l0ICpwKQp7CglzdHJ1Y3Qgc3RhdCBzdDsKCXN0cnVjdCBwYWNrX2hlYWRlciBoZHI7Cgl1bnNpZ25lZCBjaGFyIGhhc2hbR0lUX01BWF9SQVdTWl07Cgl1bnNpZ25lZCBjaGFyICppZHhfaGFzaDsKCXNzaXplX3QgcmVhZF9yZXN1bHQ7Cgljb25zdCB1bnNpZ25lZCBoYXNoc3ogPSB0aGVfaGFzaF9hbGdvLT5yYXdzejsKCglpZiAob3Blbl9wYWNrX2luZGV4KHApKQoJCXJldHVybiBlcnJvcigicGFja2ZpbGUgJXMgaW5kZXggdW5hdmFpbGFibGUiLCBwLT5wYWNrX25hbWUpOwoKCWlmICghcGFja19tYXhfZmRzKSB7CgkJdW5zaWduZWQgaW50IG1heF9mZHMgPSBnZXRfbWF4X2ZkX2xpbWl0KCk7CgoJCS8qIFNhdmUgMyBmb3Igc3RkaW4vc3Rkb3V0L3N0ZGVyciwgMjIgZm9yIHdvcmsgKi8KCQlpZiAoMjUgPCBtYXhfZmRzKQoJCQlwYWNrX21heF9mZHMgPSBtYXhfZmRzIC0gMjU7CgkJZWxzZQoJCQlwYWNrX21heF9mZHMgPSAxOwoJfQoKCXdoaWxlIChwYWNrX21heF9mZHMgPD0gcGFja19vcGVuX2ZkcyAmJiBjbG9zZV9vbmVfcGFjaygpKQoJCTsgLyogbm90aGluZyAqLwoKCXAtPnBhY2tfZmQgPSBnaXRfb3BlbihwLT5wYWNrX25hbWUpOwoJaWYgKHAtPnBhY2tfZmQgPCAwIHx8IGZzdGF0KHAtPnBhY2tfZmQsICZzdCkpCgkJcmV0dXJuIC0xOwoJcGFja19vcGVuX2ZkcysrOwoKCS8qIElmIHdlIGNyZWF0ZWQgdGhlIHN0cnVjdCBiZWZvcmUgd2UgaGFkIHRoZSBwYWNrIHdlIGxhY2sgc2l6ZS4gKi8KCWlmICghcC0+cGFja19zaXplKSB7CgkJaWYgKCFTX0lTUkVHKHN0LnN0X21vZGUpKQoJCQlyZXR1cm4gZXJyb3IoInBhY2tmaWxlICVzIG5vdCBhIHJlZ3VsYXIgZmlsZSIsIHAtPnBhY2tfbmFtZSk7CgkJcC0+cGFja19zaXplID0gc3Quc3Rfc2l6ZTsKCX0gZWxzZSBpZiAocC0+cGFja19zaXplICE9IHN0LnN0X3NpemUpCgkJcmV0dXJuIGVycm9yKCJwYWNrZmlsZSAlcyBzaXplIGNoYW5nZWQiLCBwLT5wYWNrX25hbWUpOwoKCS8qIFZlcmlmeSB3ZSByZWNvZ25pemUgdGhpcyBwYWNrIGZpbGUgZm9ybWF0LiAqLwoJcmVhZF9yZXN1bHQgPSByZWFkX2luX2Z1bGwocC0+cGFja19mZCwgJmhkciwgc2l6ZW9mKGhkcikpOwoJaWYgKHJlYWRfcmVzdWx0IDwgMCkKCQlyZXR1cm4gZXJyb3JfZXJybm8oImVycm9yIHJlYWRpbmcgZnJvbSAlcyIsIHAtPnBhY2tfbmFtZSk7CglpZiAocmVhZF9yZXN1bHQgIT0gc2l6ZW9mKGhkcikpCgkJcmV0dXJuIGVycm9yKCJmaWxlICVzIGlzIGZhciB0b28gc2hvcnQgdG8gYmUgYSBwYWNrZmlsZSIsIHAtPnBhY2tfbmFtZSk7CglpZiAoaGRyLmhkcl9zaWduYXR1cmUgIT0gaHRvbmwoUEFDS19TSUdOQVRVUkUpKQoJCXJldHVybiBlcnJvcigiZmlsZSAlcyBpcyBub3QgYSBHSVQgcGFja2ZpbGUiLCBwLT5wYWNrX25hbWUpOwoJaWYgKCFwYWNrX3ZlcnNpb25fb2soaGRyLmhkcl92ZXJzaW9uKSkKCQlyZXR1cm4gZXJyb3IoInBhY2tmaWxlICVzIGlzIHZlcnNpb24gJSJQUkl1MzIiIGFuZCBub3QiCgkJCSIgc3VwcG9ydGVkICh0cnkgdXBncmFkaW5nIEdJVCB0byBhIG5ld2VyIHZlcnNpb24pIiwKCQkJcC0+cGFja19uYW1lLCBudG9obChoZHIuaGRyX3ZlcnNpb24pKTsKCgkvKiBWZXJpZnkgdGhlIHBhY2sgbWF0Y2hlcyBpdHMgaW5kZXguICovCglpZiAocC0+bnVtX29iamVjdHMgIT0gbnRvaGwoaGRyLmhkcl9lbnRyaWVzKSkKCQlyZXR1cm4gZXJyb3IoInBhY2tmaWxlICVzIGNsYWltcyB0byBoYXZlICUiUFJJdTMyIiBvYmplY3RzIgoJCQkgICAgICIgd2hpbGUgaW5kZXggaW5kaWNhdGVzICUiUFJJdTMyIiBvYmplY3RzIiwKCQkJICAgICBwLT5wYWNrX25hbWUsIG50b2hsKGhkci5oZHJfZW50cmllcyksCgkJCSAgICAgcC0+bnVtX29iamVjdHMpOwoJcmVhZF9yZXN1bHQgPSBwcmVhZF9pbl9mdWxsKHAtPnBhY2tfZmQsIGhhc2gsIGhhc2hzeiwKCQkJCQlwLT5wYWNrX3NpemUgLSBoYXNoc3opOwoJaWYgKHJlYWRfcmVzdWx0IDwgMCkKCQlyZXR1cm4gZXJyb3JfZXJybm8oImVycm9yIHJlYWRpbmcgZnJvbSAlcyIsIHAtPnBhY2tfbmFtZSk7CglpZiAocmVhZF9yZXN1bHQgIT0gaGFzaHN6KQoJCXJldHVybiBlcnJvcigicGFja2ZpbGUgJXMgc2lnbmF0dXJlIGlzIHVuYXZhaWxhYmxlIiwgcC0+cGFja19uYW1lKTsKCWlkeF9oYXNoID0gKCh1bnNpZ25lZCBjaGFyICopcC0+aW5kZXhfZGF0YSkgKyBwLT5pbmRleF9zaXplIC0gaGFzaHN6ICogMjsKCWlmICghaGFzaGVxKGhhc2gsIGlkeF9oYXNoLCB0aGVfcmVwb3NpdG9yeS0+aGFzaF9hbGdvKSkKCQlyZXR1cm4gZXJyb3IoInBhY2tmaWxlICVzIGRvZXMgbm90IG1hdGNoIGluZGV4IiwgcC0+cGFja19uYW1lKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IG9wZW5fcGFja2VkX2dpdChzdHJ1Y3QgcGFja2VkX2dpdCAqcCkKewoJaWYgKCFvcGVuX3BhY2tlZF9naXRfMShwKSkKCQlyZXR1cm4gMDsKCWNsb3NlX3BhY2tfZmQocCk7CglyZXR1cm4gLTE7Cn0KCnN0YXRpYyBpbnQgaW5fd2luZG93KHN0cnVjdCBwYWNrX3dpbmRvdyAqd2luLCBvZmZfdCBvZmZzZXQpCnsKCS8qIFdlIG11c3QgcHJvbWlzZSBhdCBsZWFzdCBvbmUgZnVsbCBoYXNoIGFmdGVyIHRoZQoJICogb2Zmc2V0IGlzIGF2YWlsYWJsZSBmcm9tIHRoaXMgd2luZG93LCBvdGhlcndpc2UgdGhlIG9mZnNldAoJICogaXMgbm90IGFjdHVhbGx5IGluIHRoaXMgd2luZG93IGFuZCBhIGRpZmZlcmVudCB3aW5kb3cgKHdoaWNoCgkgKiBoYXMgdGhhdCBvbmUgaGFzaCBleGNlc3MpIG11c3QgYmUgdXNlZC4gIFRoaXMgaXMgdG8gc3VwcG9ydAoJICogdGhlIG9iamVjdCBoZWFkZXIgYW5kIGRlbHRhIGJhc2UgcGFyc2luZyByb3V0aW5lcyBiZWxvdy4KCSAqLwoJb2ZmX3Qgd2luX29mZiA9IHdpbi0+b2Zmc2V0OwoJcmV0dXJuIHdpbl9vZmYgPD0gb2Zmc2V0CgkJJiYgKG9mZnNldCArIHRoZV9oYXNoX2FsZ28tPnJhd3N6KSA8PSAod2luX29mZiArIHdpbi0+bGVuKTsKfQoKdW5zaWduZWQgY2hhciAqdXNlX3BhY2soc3RydWN0IHBhY2tlZF9naXQgKnAsCgkJc3RydWN0IHBhY2tfd2luZG93ICoqd19jdXJzb3IsCgkJb2ZmX3Qgb2Zmc2V0LAoJCXVuc2lnbmVkIGxvbmcgKmxlZnQpCnsKCXN0cnVjdCBwYWNrX3dpbmRvdyAqd2luID0gKndfY3Vyc29yOwoKCS8qIFNpbmNlIHBhY2tmaWxlcyBlbmQgaW4gYSBoYXNoIG9mIHRoZWlyIGNvbnRlbnQgYW5kIGl0J3MKCSAqIHBvaW50bGVzcyB0byBhc2sgZm9yIGFuIG9mZnNldCBpbnRvIHRoZSBtaWRkbGUgb2YgdGhhdAoJICogaGFzaCwgYW5kIHRoZSBpbl93aW5kb3cgZnVuY3Rpb24gYWJvdmUgd291bGRuJ3QgbWF0Y2gKCSAqIGRvbid0IGFsbG93IGFuIG9mZnNldCB0b28gY2xvc2UgdG8gdGhlIGVuZCBvZiB0aGUgZmlsZS4KCSAqLwoJaWYgKCFwLT5wYWNrX3NpemUgJiYgcC0+cGFja19mZCA9PSAtMSAmJiBvcGVuX3BhY2tlZF9naXQocCkpCgkJZGllKCJwYWNrZmlsZSAlcyBjYW5ub3QgYmUgYWNjZXNzZWQiLCBwLT5wYWNrX25hbWUpOwoJaWYgKG9mZnNldCA+IChwLT5wYWNrX3NpemUgLSB0aGVfaGFzaF9hbGdvLT5yYXdzeikpCgkJZGllKCJvZmZzZXQgYmV5b25kIGVuZCBvZiBwYWNrZmlsZSAodHJ1bmNhdGVkIHBhY2s/KSIpOwoJaWYgKG9mZnNldCA8IDApCgkJZGllKF8oIm9mZnNldCBiZWZvcmUgZW5kIG9mIHBhY2tmaWxlIChicm9rZW4gLmlkeD8pIikpOwoKCWlmICghd2luIHx8ICFpbl93aW5kb3cod2luLCBvZmZzZXQpKSB7CgkJaWYgKHdpbikKCQkJd2luLT5pbnVzZV9jbnQtLTsKCQlmb3IgKHdpbiA9IHAtPndpbmRvd3M7IHdpbjsgd2luID0gd2luLT5uZXh0KSB7CgkJCWlmIChpbl93aW5kb3cod2luLCBvZmZzZXQpKQoJCQkJYnJlYWs7CgkJfQoJCWlmICghd2luKSB7CgkJCXNpemVfdCB3aW5kb3dfYWxpZ24gPSBwYWNrZWRfZ2l0X3dpbmRvd19zaXplIC8gMjsKCQkJb2ZmX3QgbGVuOwoKCQkJaWYgKHAtPnBhY2tfZmQgPT0gLTEgJiYgb3Blbl9wYWNrZWRfZ2l0KHApKQoJCQkJZGllKCJwYWNrZmlsZSAlcyBjYW5ub3QgYmUgYWNjZXNzZWQiLCBwLT5wYWNrX25hbWUpOwoKCQkJQ0FMTE9DX0FSUkFZKHdpbiwgMSk7CgkJCXdpbi0+b2Zmc2V0ID0gKG9mZnNldCAvIHdpbmRvd19hbGlnbikgKiB3aW5kb3dfYWxpZ247CgkJCWxlbiA9IHAtPnBhY2tfc2l6ZSAtIHdpbi0+b2Zmc2V0OwoJCQlpZiAobGVuID4gcGFja2VkX2dpdF93aW5kb3dfc2l6ZSkKCQkJCWxlbiA9IHBhY2tlZF9naXRfd2luZG93X3NpemU7CgkJCXdpbi0+bGVuID0gKHNpemVfdClsZW47CgkJCXBhY2tfbWFwcGVkICs9IHdpbi0+bGVuOwoJCQl3aGlsZSAocGFja2VkX2dpdF9saW1pdCA8IHBhY2tfbWFwcGVkCgkJCQkmJiB1bnVzZV9vbmVfd2luZG93KHApKQoJCQkJOyAvKiBub3RoaW5nICovCgkJCXdpbi0+YmFzZSA9IHhtbWFwX2dlbnRseShOVUxMLCB3aW4tPmxlbiwKCQkJCVBST1RfUkVBRCwgTUFQX1BSSVZBVEUsCgkJCQlwLT5wYWNrX2ZkLCB3aW4tPm9mZnNldCk7CgkJCWlmICh3aW4tPmJhc2UgPT0gTUFQX0ZBSUxFRCkKCQkJCWRpZV9lcnJubyhfKCJwYWNrZmlsZSAlcyBjYW5ub3QgYmUgbWFwcGVkJXMiKSwKCQkJCQkgIHAtPnBhY2tfbmFtZSwgbW1hcF9vc19lcnIoKSk7CgkJCWlmICghd2luLT5vZmZzZXQgJiYgd2luLT5sZW4gPT0gcC0+cGFja19zaXplCgkJCQkmJiAhcC0+ZG9fbm90X2Nsb3NlKQoJCQkJY2xvc2VfcGFja19mZChwKTsKCQkJcGFja19tbWFwX2NhbGxzKys7CgkJCXBhY2tfb3Blbl93aW5kb3dzKys7CgkJCWlmIChwYWNrX21hcHBlZCA+IHBlYWtfcGFja19tYXBwZWQpCgkJCQlwZWFrX3BhY2tfbWFwcGVkID0gcGFja19tYXBwZWQ7CgkJCWlmIChwYWNrX29wZW5fd2luZG93cyA+IHBlYWtfcGFja19vcGVuX3dpbmRvd3MpCgkJCQlwZWFrX3BhY2tfb3Blbl93aW5kb3dzID0gcGFja19vcGVuX3dpbmRvd3M7CgkJCXdpbi0+bmV4dCA9IHAtPndpbmRvd3M7CgkJCXAtPndpbmRvd3MgPSB3aW47CgkJfQoJfQoJaWYgKHdpbiAhPSAqd19jdXJzb3IpIHsKCQl3aW4tPmxhc3RfdXNlZCA9IHBhY2tfdXNlZF9jdHIrKzsKCQl3aW4tPmludXNlX2NudCsrOwoJCSp3X2N1cnNvciA9IHdpbjsKCX0KCW9mZnNldCAtPSB3aW4tPm9mZnNldDsKCWlmIChsZWZ0KQoJCSpsZWZ0ID0gd2luLT5sZW4gLSB4c2l6ZV90KG9mZnNldCk7CglyZXR1cm4gd2luLT5iYXNlICsgb2Zmc2V0Owp9Cgp2b2lkIHVudXNlX3BhY2soc3RydWN0IHBhY2tfd2luZG93ICoqd19jdXJzb3IpCnsKCXN0cnVjdCBwYWNrX3dpbmRvdyAqdyA9ICp3X2N1cnNvcjsKCWlmICh3KSB7CgkJdy0+aW51c2VfY250LS07CgkJKndfY3Vyc29yID0gTlVMTDsKCX0KfQoKc3RydWN0IHBhY2tlZF9naXQgKmFkZF9wYWNrZWRfZ2l0KGNvbnN0IGNoYXIgKnBhdGgsIHNpemVfdCBwYXRoX2xlbiwgaW50IGxvY2FsKQp7CglzdHJ1Y3Qgc3RhdCBzdDsKCXNpemVfdCBhbGxvYzsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwOwoKCS8qCgkgKiBNYWtlIHN1cmUgYSBjb3JyZXNwb25kaW5nIC5wYWNrIGZpbGUgZXhpc3RzIGFuZCB0aGF0CgkgKiB0aGUgaW5kZXggbG9va3Mgc2FuZS4KCSAqLwoJaWYgKCFzdHJpcF9zdWZmaXhfbWVtKHBhdGgsICZwYXRoX2xlbiwgIi5pZHgiKSkKCQlyZXR1cm4gTlVMTDsKCgkvKgoJICogIi5wcm9taXNvciIgaXMgbG9uZyBlbm91Z2ggdG8gaG9sZCBhbnkgc3VmZml4IHdlJ3JlIGFkZGluZyAoYW5kCgkgKiB0aGUgdXNlIHhzbnByaW50ZiBkb3VibGUtY2hlY2tzIHRoYXQpCgkgKi8KCWFsbG9jID0gc3RfYWRkMyhwYXRoX2xlbiwgc3RybGVuKCIucHJvbWlzb3IiKSwgMSk7CglwID0gYWxsb2NfcGFja2VkX2dpdChhbGxvYyk7CgltZW1jcHkocC0+cGFja19uYW1lLCBwYXRoLCBwYXRoX2xlbik7CgoJeHNucHJpbnRmKHAtPnBhY2tfbmFtZSArIHBhdGhfbGVuLCBhbGxvYyAtIHBhdGhfbGVuLCAiLmtlZXAiKTsKCWlmICghYWNjZXNzKHAtPnBhY2tfbmFtZSwgRl9PSykpCgkJcC0+cGFja19rZWVwID0gMTsKCgl4c25wcmludGYocC0+cGFja19uYW1lICsgcGF0aF9sZW4sIGFsbG9jIC0gcGF0aF9sZW4sICIucHJvbWlzb3IiKTsKCWlmICghYWNjZXNzKHAtPnBhY2tfbmFtZSwgRl9PSykpCgkJcC0+cGFja19wcm9taXNvciA9IDE7CgoJeHNucHJpbnRmKHAtPnBhY2tfbmFtZSArIHBhdGhfbGVuLCBhbGxvYyAtIHBhdGhfbGVuLCAiLm10aW1lcyIpOwoJaWYgKCFhY2Nlc3MocC0+cGFja19uYW1lLCBGX09LKSkKCQlwLT5pc19jcnVmdCA9IDE7CgoJeHNucHJpbnRmKHAtPnBhY2tfbmFtZSArIHBhdGhfbGVuLCBhbGxvYyAtIHBhdGhfbGVuLCAiLnBhY2siKTsKCWlmIChzdGF0KHAtPnBhY2tfbmFtZSwgJnN0KSB8fCAhU19JU1JFRyhzdC5zdF9tb2RlKSkgewoJCWZyZWUocCk7CgkJcmV0dXJuIE5VTEw7Cgl9CgoJLyogb2ssIGl0IGxvb2tzIHNhbmUgYXMgZmFyIGFzIHdlIGNhbiBjaGVjayB3aXRob3V0CgkgKiBhY3R1YWxseSBtYXBwaW5nIHRoZSBwYWNrIGZpbGUuCgkgKi8KCXAtPnBhY2tfc2l6ZSA9IHN0LnN0X3NpemU7CglwLT5wYWNrX2xvY2FsID0gbG9jYWw7CglwLT5tdGltZSA9IHN0LnN0X210aW1lOwoJaWYgKHBhdGhfbGVuIDwgdGhlX2hhc2hfYWxnby0+aGV4c3ogfHwKCSAgICBnZXRfaGFzaF9oZXgocGF0aCArIHBhdGhfbGVuIC0gdGhlX2hhc2hfYWxnby0+aGV4c3osIHAtPmhhc2gpKQoJCWhhc2hjbHIocC0+aGFzaCwgdGhlX3JlcG9zaXRvcnktPmhhc2hfYWxnbyk7CglyZXR1cm4gcDsKfQoKdm9pZCBpbnN0YWxsX3BhY2tlZF9naXQoc3RydWN0IHJlcG9zaXRvcnkgKnIsIHN0cnVjdCBwYWNrZWRfZ2l0ICpwYWNrKQp7CglpZiAocGFjay0+cGFja19mZCAhPSAtMSkKCQlwYWNrX29wZW5fZmRzKys7CgoJcGFjay0+bmV4dCA9IHItPm9iamVjdHMtPnBhY2tlZF9naXQ7CglyLT5vYmplY3RzLT5wYWNrZWRfZ2l0ID0gcGFjazsKCgloYXNobWFwX2VudHJ5X2luaXQoJnBhY2stPnBhY2ttYXBfZW50LCBzdHJoYXNoKHBhY2stPnBhY2tfbmFtZSkpOwoJaGFzaG1hcF9hZGQoJnItPm9iamVjdHMtPnBhY2tfbWFwLCAmcGFjay0+cGFja21hcF9lbnQpOwp9Cgp2b2lkICgqcmVwb3J0X2dhcmJhZ2UpKHVuc2lnbmVkIHNlZW5fYml0cywgY29uc3QgY2hhciAqcGF0aCk7CgpzdGF0aWMgdm9pZCByZXBvcnRfaGVscGVyKGNvbnN0IHN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCwKCQkJICBpbnQgc2Vlbl9iaXRzLCBpbnQgZmlyc3QsIGludCBsYXN0KQp7CglpZiAoc2Vlbl9iaXRzID09IChQQUNLRElSX0ZJTEVfUEFDS3xQQUNLRElSX0ZJTEVfSURYKSkKCQlyZXR1cm47CgoJZm9yICg7IGZpcnN0IDwgbGFzdDsgZmlyc3QrKykKCQlyZXBvcnRfZ2FyYmFnZShzZWVuX2JpdHMsIGxpc3QtPml0ZW1zW2ZpcnN0XS5zdHJpbmcpOwp9CgpzdGF0aWMgdm9pZCByZXBvcnRfcGFja19nYXJiYWdlKHN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCkKewoJaW50IGksIGJhc2VsZW4gPSAtMSwgZmlyc3QgPSAwLCBzZWVuX2JpdHMgPSAwOwoKCWlmICghcmVwb3J0X2dhcmJhZ2UpCgkJcmV0dXJuOwoKCXN0cmluZ19saXN0X3NvcnQobGlzdCk7CgoJZm9yIChpID0gMDsgaSA8IGxpc3QtPm5yOyBpKyspIHsKCQljb25zdCBjaGFyICpwYXRoID0gbGlzdC0+aXRlbXNbaV0uc3RyaW5nOwoJCWlmIChiYXNlbGVuICE9IC0xICYmCgkJICAgIHN0cm5jbXAocGF0aCwgbGlzdC0+aXRlbXNbZmlyc3RdLnN0cmluZywgYmFzZWxlbikpIHsKCQkJcmVwb3J0X2hlbHBlcihsaXN0LCBzZWVuX2JpdHMsIGZpcnN0LCBpKTsKCQkJYmFzZWxlbiA9IC0xOwoJCQlzZWVuX2JpdHMgPSAwOwoJCX0KCQlpZiAoYmFzZWxlbiA9PSAtMSkgewoJCQljb25zdCBjaGFyICpkb3QgPSBzdHJyY2hyKHBhdGgsICcuJyk7CgkJCWlmICghZG90KSB7CgkJCQlyZXBvcnRfZ2FyYmFnZShQQUNLRElSX0ZJTEVfR0FSQkFHRSwgcGF0aCk7CgkJCQljb250aW51ZTsKCQkJfQoJCQliYXNlbGVuID0gZG90IC0gcGF0aCArIDE7CgkJCWZpcnN0ID0gaTsKCQl9CgkJaWYgKCFzdHJjbXAocGF0aCArIGJhc2VsZW4sICJwYWNrIikpCgkJCXNlZW5fYml0cyB8PSAxOwoJCWVsc2UgaWYgKCFzdHJjbXAocGF0aCArIGJhc2VsZW4sICJpZHgiKSkKCQkJc2Vlbl9iaXRzIHw9IDI7Cgl9CglyZXBvcnRfaGVscGVyKGxpc3QsIHNlZW5fYml0cywgZmlyc3QsIGxpc3QtPm5yKTsKfQoKdm9pZCBmb3JfZWFjaF9maWxlX2luX3BhY2tfc3ViZGlyKGNvbnN0IGNoYXIgKm9iamRpciwKCQkJCSAgY29uc3QgY2hhciAqc3ViZGlyLAoJCQkJICBlYWNoX2ZpbGVfaW5fcGFja19kaXJfZm4gZm4sCgkJCQkgIHZvaWQgKmRhdGEpCnsKCXN0cnVjdCBzdHJidWYgcGF0aCA9IFNUUkJVRl9JTklUOwoJc2l6ZV90IGRpcm5hbWVsZW47CglESVIgKmRpcjsKCXN0cnVjdCBkaXJlbnQgKmRlOwoKCXN0cmJ1Zl9hZGRzdHIoJnBhdGgsIG9iamRpcik7CglzdHJidWZfYWRkc3RyKCZwYXRoLCAiL3BhY2siKTsKCWlmIChzdWJkaXIpCgkJc3RyYnVmX2FkZGYoJnBhdGgsICIvJXMiLCBzdWJkaXIpOwoJZGlyID0gb3BlbmRpcihwYXRoLmJ1Zik7CglpZiAoIWRpcikgewoJCWlmIChlcnJubyAhPSBFTk9FTlQpCgkJCWVycm9yX2Vycm5vKCJ1bmFibGUgdG8gb3BlbiBvYmplY3QgcGFjayBkaXJlY3Rvcnk6ICVzIiwKCQkJCSAgICBwYXRoLmJ1Zik7CgkJc3RyYnVmX3JlbGVhc2UoJnBhdGgpOwoJCXJldHVybjsKCX0KCXN0cmJ1Zl9hZGRjaCgmcGF0aCwgJy8nKTsKCWRpcm5hbWVsZW4gPSBwYXRoLmxlbjsKCXdoaWxlICgoZGUgPSByZWFkZGlyX3NraXBfZG90X2FuZF9kb3Rkb3QoZGlyKSkgIT0gTlVMTCkgewoJCXN0cmJ1Zl9zZXRsZW4oJnBhdGgsIGRpcm5hbWVsZW4pOwoJCXN0cmJ1Zl9hZGRzdHIoJnBhdGgsIGRlLT5kX25hbWUpOwoKCQlmbihwYXRoLmJ1ZiwgcGF0aC5sZW4sIGRlLT5kX25hbWUsIGRhdGEpOwoJfQoKCWNsb3NlZGlyKGRpcik7CglzdHJidWZfcmVsZWFzZSgmcGF0aCk7Cn0KCnZvaWQgZm9yX2VhY2hfZmlsZV9pbl9wYWNrX2Rpcihjb25zdCBjaGFyICpvYmpkaXIsCgkJCSAgICAgICBlYWNoX2ZpbGVfaW5fcGFja19kaXJfZm4gZm4sCgkJCSAgICAgICB2b2lkICpkYXRhKQp7Cglmb3JfZWFjaF9maWxlX2luX3BhY2tfc3ViZGlyKG9iamRpciwgTlVMTCwgZm4sIGRhdGEpOwp9CgpzdHJ1Y3QgcHJlcGFyZV9wYWNrX2RhdGEgewoJc3RydWN0IHJlcG9zaXRvcnkgKnI7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmdhcmJhZ2U7CglpbnQgbG9jYWw7CglzdHJ1Y3QgbXVsdGlfcGFja19pbmRleCAqbTsKfTsKCnN0YXRpYyB2b2lkIHByZXBhcmVfcGFjayhjb25zdCBjaGFyICpmdWxsX25hbWUsIHNpemVfdCBmdWxsX25hbWVfbGVuLAoJCQkgY29uc3QgY2hhciAqZmlsZV9uYW1lLCB2b2lkICpfZGF0YSkKewoJc3RydWN0IHByZXBhcmVfcGFja19kYXRhICpkYXRhID0gKHN0cnVjdCBwcmVwYXJlX3BhY2tfZGF0YSAqKV9kYXRhOwoJc3RydWN0IHBhY2tlZF9naXQgKnA7CglzaXplX3QgYmFzZV9sZW4gPSBmdWxsX25hbWVfbGVuOwoKCWlmIChzdHJpcF9zdWZmaXhfbWVtKGZ1bGxfbmFtZSwgJmJhc2VfbGVuLCAiLmlkeCIpICYmCgkgICAgIShkYXRhLT5tICYmIG1pZHhfY29udGFpbnNfcGFjayhkYXRhLT5tLCBmaWxlX25hbWUpKSkgewoJCXN0cnVjdCBoYXNobWFwX2VudHJ5IGhlbnQ7CgkJY2hhciAqcGFja19uYW1lID0geHN0cmZtdCgiJS4qcy5wYWNrIiwgKGludCliYXNlX2xlbiwgZnVsbF9uYW1lKTsKCQl1bnNpZ25lZCBpbnQgaGFzaCA9IHN0cmhhc2gocGFja19uYW1lKTsKCQloYXNobWFwX2VudHJ5X2luaXQoJmhlbnQsIGhhc2gpOwoKCQkvKiBEb24ndCByZW9wZW4gYSBwYWNrIHdlIGFscmVhZHkgaGF2ZS4gKi8KCQlpZiAoIWhhc2htYXBfZ2V0KCZkYXRhLT5yLT5vYmplY3RzLT5wYWNrX21hcCwgJmhlbnQsIHBhY2tfbmFtZSkpIHsKCQkJcCA9IGFkZF9wYWNrZWRfZ2l0KGZ1bGxfbmFtZSwgZnVsbF9uYW1lX2xlbiwgZGF0YS0+bG9jYWwpOwoJCQlpZiAocCkKCQkJCWluc3RhbGxfcGFja2VkX2dpdChkYXRhLT5yLCBwKTsKCQl9CgkJZnJlZShwYWNrX25hbWUpOwoJfQoKCWlmICghcmVwb3J0X2dhcmJhZ2UpCgkJcmV0dXJuOwoKCWlmICghc3RyY21wKGZpbGVfbmFtZSwgIm11bHRpLXBhY2staW5kZXgiKSB8fAoJICAgICFzdHJjbXAoZmlsZV9uYW1lLCAibXVsdGktcGFjay1pbmRleC5kIikpCgkJcmV0dXJuOwoJaWYgKHN0YXJ0c193aXRoKGZpbGVfbmFtZSwgIm11bHRpLXBhY2staW5kZXgiKSAmJgoJICAgIChlbmRzX3dpdGgoZmlsZV9uYW1lLCAiLmJpdG1hcCIpIHx8IGVuZHNfd2l0aChmaWxlX25hbWUsICIucmV2IikpKQoJCXJldHVybjsKCWlmIChlbmRzX3dpdGgoZmlsZV9uYW1lLCAiLmlkeCIpIHx8CgkgICAgZW5kc193aXRoKGZpbGVfbmFtZSwgIi5yZXYiKSB8fAoJICAgIGVuZHNfd2l0aChmaWxlX25hbWUsICIucGFjayIpIHx8CgkgICAgZW5kc193aXRoKGZpbGVfbmFtZSwgIi5iaXRtYXAiKSB8fAoJICAgIGVuZHNfd2l0aChmaWxlX25hbWUsICIua2VlcCIpIHx8CgkgICAgZW5kc193aXRoKGZpbGVfbmFtZSwgIi5wcm9taXNvciIpIHx8CgkgICAgZW5kc193aXRoKGZpbGVfbmFtZSwgIi5tdGltZXMiKSkKCQlzdHJpbmdfbGlzdF9hcHBlbmQoZGF0YS0+Z2FyYmFnZSwgZnVsbF9uYW1lKTsKCWVsc2UKCQlyZXBvcnRfZ2FyYmFnZShQQUNLRElSX0ZJTEVfR0FSQkFHRSwgZnVsbF9uYW1lKTsKfQoKc3RhdGljIHZvaWQgcHJlcGFyZV9wYWNrZWRfZ2l0X29uZShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgY2hhciAqb2JqZGlyLCBpbnQgbG9jYWwpCnsKCXN0cnVjdCBwcmVwYXJlX3BhY2tfZGF0YSBkYXRhOwoJc3RydWN0IHN0cmluZ19saXN0IGdhcmJhZ2UgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCglkYXRhLm0gPSByLT5vYmplY3RzLT5tdWx0aV9wYWNrX2luZGV4OwoKCS8qIGxvb2sgZm9yIHRoZSBtdWx0aS1wYWNrLWluZGV4IGZvciB0aGlzIG9iamVjdCBkaXJlY3RvcnkgKi8KCXdoaWxlIChkYXRhLm0gJiYgc3RyY21wKGRhdGEubS0+b2JqZWN0X2Rpciwgb2JqZGlyKSkKCQlkYXRhLm0gPSBkYXRhLm0tPm5leHQ7CgoJZGF0YS5yID0gcjsKCWRhdGEuZ2FyYmFnZSA9ICZnYXJiYWdlOwoJZGF0YS5sb2NhbCA9IGxvY2FsOwoKCWZvcl9lYWNoX2ZpbGVfaW5fcGFja19kaXIob2JqZGlyLCBwcmVwYXJlX3BhY2ssICZkYXRhKTsKCglyZXBvcnRfcGFja19nYXJiYWdlKGRhdGEuZ2FyYmFnZSk7CglzdHJpbmdfbGlzdF9jbGVhcihkYXRhLmdhcmJhZ2UsIDApOwp9CgpzdGF0aWMgdm9pZCBwcmVwYXJlX3BhY2tlZF9naXQoc3RydWN0IHJlcG9zaXRvcnkgKnIpOwovKgogKiBHaXZlIGEgZmFzdCwgcm91Z2ggY291bnQgb2YgdGhlIG51bWJlciBvZiBvYmplY3RzIGluIHRoZSByZXBvc2l0b3J5LiBUaGlzCiAqIGlnbm9yZXMgbG9vc2Ugb2JqZWN0cyBjb21wbGV0ZWx5LiBJZiB5b3UgaGF2ZSBhIGxvdCBvZiB0aGVtLCB0aGVuIGVpdGhlcgogKiB5b3Ugc2hvdWxkIHJlcGFjayBiZWNhdXNlIHlvdXIgcGVyZm9ybWFuY2Ugd2lsbCBiZSBhd2Z1bCwgb3IgdGhleSBhcmUKICogYWxsIHVucmVhY2hhYmxlIG9iamVjdHMgYWJvdXQgdG8gYmUgcHJ1bmVkLCBpbiB3aGljaCBjYXNlIHRoZXkncmUgbm90IHJlYWxseQogKiBpbnRlcmVzdGluZyBhcyBhIG1lYXN1cmUgb2YgcmVwbyBzaXplIGluIHRoZSBmaXJzdCBwbGFjZS4KICovCnVuc2lnbmVkIGxvbmcgcmVwb19hcHByb3hpbWF0ZV9vYmplY3RfY291bnQoc3RydWN0IHJlcG9zaXRvcnkgKnIpCnsKCWlmICghci0+b2JqZWN0cy0+YXBwcm94aW1hdGVfb2JqZWN0X2NvdW50X3ZhbGlkKSB7CgkJdW5zaWduZWQgbG9uZyBjb3VudDsKCQlzdHJ1Y3QgbXVsdGlfcGFja19pbmRleCAqbTsKCQlzdHJ1Y3QgcGFja2VkX2dpdCAqcDsKCgkJcHJlcGFyZV9wYWNrZWRfZ2l0KHIpOwoJCWNvdW50ID0gMDsKCQlmb3IgKG0gPSBnZXRfbXVsdGlfcGFja19pbmRleChyKTsgbTsgbSA9IG0tPm5leHQpCgkJCWNvdW50ICs9IG0tPm51bV9vYmplY3RzOwoJCWZvciAocCA9IHItPm9iamVjdHMtPnBhY2tlZF9naXQ7IHA7IHAgPSBwLT5uZXh0KSB7CgkJCWlmIChvcGVuX3BhY2tfaW5kZXgocCkpCgkJCQljb250aW51ZTsKCQkJY291bnQgKz0gcC0+bnVtX29iamVjdHM7CgkJfQoJCXItPm9iamVjdHMtPmFwcHJveGltYXRlX29iamVjdF9jb3VudCA9IGNvdW50OwoJCXItPm9iamVjdHMtPmFwcHJveGltYXRlX29iamVjdF9jb3VudF92YWxpZCA9IDE7Cgl9CglyZXR1cm4gci0+b2JqZWN0cy0+YXBwcm94aW1hdGVfb2JqZWN0X2NvdW50Owp9CgpERUZJTkVfTElTVF9TT1JUKHN0YXRpYywgc29ydF9wYWNrcywgc3RydWN0IHBhY2tlZF9naXQsIG5leHQpOwoKc3RhdGljIGludCBzb3J0X3BhY2soY29uc3Qgc3RydWN0IHBhY2tlZF9naXQgKmEsIGNvbnN0IHN0cnVjdCBwYWNrZWRfZ2l0ICpiKQp7CglpbnQgc3Q7CgoJLyoKCSAqIExvY2FsIHBhY2tzIHRlbmQgdG8gY29udGFpbiBvYmplY3RzIHNwZWNpZmljIHRvIG91cgoJICogdmFyaWFudCBvZiB0aGUgcHJvamVjdCB0aGFuIHJlbW90ZSBvbmVzLiAgSW4gYWRkaXRpb24sCgkgKiByZW1vdGUgb25lcyBjb3VsZCBiZSBvbiBhIG5ldHdvcmsgbW91bnRlZCBmaWxlc3lzdGVtLgoJICogRmF2b3IgbG9jYWwgb25lcyBmb3IgdGhlc2UgcmVhc29ucy4KCSAqLwoJc3QgPSBhLT5wYWNrX2xvY2FsIC0gYi0+cGFja19sb2NhbDsKCWlmIChzdCkKCQlyZXR1cm4gLXN0OwoKCS8qCgkgKiBZb3VuZ2VyIHBhY2tzIHRlbmQgdG8gY29udGFpbiBtb3JlIHJlY2VudCBvYmplY3RzLAoJICogYW5kIG1vcmUgcmVjZW50IG9iamVjdHMgdGVuZCB0byBnZXQgYWNjZXNzZWQgbW9yZQoJICogb2Z0ZW4uCgkgKi8KCWlmIChhLT5tdGltZSA8IGItPm10aW1lKQoJCXJldHVybiAxOwoJZWxzZSBpZiAoYS0+bXRpbWUgPT0gYi0+bXRpbWUpCgkJcmV0dXJuIDA7CglyZXR1cm4gLTE7Cn0KCnN0YXRpYyB2b2lkIHJlYXJyYW5nZV9wYWNrZWRfZ2l0KHN0cnVjdCByZXBvc2l0b3J5ICpyKQp7Cglzb3J0X3BhY2tzKCZyLT5vYmplY3RzLT5wYWNrZWRfZ2l0LCBzb3J0X3BhY2spOwp9CgpzdGF0aWMgdm9pZCBwcmVwYXJlX3BhY2tlZF9naXRfbXJ1KHN0cnVjdCByZXBvc2l0b3J5ICpyKQp7CglzdHJ1Y3QgcGFja2VkX2dpdCAqcDsKCglJTklUX0xJU1RfSEVBRCgmci0+b2JqZWN0cy0+cGFja2VkX2dpdF9tcnUpOwoKCWZvciAocCA9IHItPm9iamVjdHMtPnBhY2tlZF9naXQ7IHA7IHAgPSBwLT5uZXh0KQoJCWxpc3RfYWRkX3RhaWwoJnAtPm1ydSwgJnItPm9iamVjdHMtPnBhY2tlZF9naXRfbXJ1KTsKfQoKc3RhdGljIHZvaWQgcHJlcGFyZV9wYWNrZWRfZ2l0KHN0cnVjdCByZXBvc2l0b3J5ICpyKQp7CglzdHJ1Y3Qgb2JqZWN0X2RpcmVjdG9yeSAqb2RiOwoKCWlmIChyLT5vYmplY3RzLT5wYWNrZWRfZ2l0X2luaXRpYWxpemVkKQoJCXJldHVybjsKCglwcmVwYXJlX2FsdF9vZGIocik7Cglmb3IgKG9kYiA9IHItPm9iamVjdHMtPm9kYjsgb2RiOyBvZGIgPSBvZGItPm5leHQpIHsKCQlpbnQgbG9jYWwgPSAob2RiID09IHItPm9iamVjdHMtPm9kYik7CgkJcHJlcGFyZV9tdWx0aV9wYWNrX2luZGV4X29uZShyLCBvZGItPnBhdGgsIGxvY2FsKTsKCQlwcmVwYXJlX3BhY2tlZF9naXRfb25lKHIsIG9kYi0+cGF0aCwgbG9jYWwpOwoJfQoJcmVhcnJhbmdlX3BhY2tlZF9naXQocik7CgoJcHJlcGFyZV9wYWNrZWRfZ2l0X21ydShyKTsKCXItPm9iamVjdHMtPnBhY2tlZF9naXRfaW5pdGlhbGl6ZWQgPSAxOwp9Cgp2b2lkIHJlcHJlcGFyZV9wYWNrZWRfZ2l0KHN0cnVjdCByZXBvc2l0b3J5ICpyKQp7CglzdHJ1Y3Qgb2JqZWN0X2RpcmVjdG9yeSAqb2RiOwoKCW9ial9yZWFkX2xvY2soKTsKCgkvKgoJICogUmVwcmVwYXJlIGFsdCBvZGJzLCBpbiBjYXNlIHRoZSBhbHRlcm5hdGVzIGZpbGUgd2FzIG1vZGlmaWVkCgkgKiBkdXJpbmcgdGhlIGNvdXJzZSBvZiB0aGlzIHByb2Nlc3MuIFRoaXMgb25seSBfYWRkc18gb2RicyB0bwoJICogdGhlIGxpbmtlZCBsaXN0LCBzbyBleGlzdGluZyBvZGJzIHdpbGwgY29udGludWUgdG8gZXhpc3QgZm9yCgkgKiB0aGUgbGlmZXRpbWUgb2YgdGhlIHByb2Nlc3MuCgkgKi8KCXItPm9iamVjdHMtPmxvYWRlZF9hbHRlcm5hdGVzID0gMDsKCXByZXBhcmVfYWx0X29kYihyKTsKCglmb3IgKG9kYiA9IHItPm9iamVjdHMtPm9kYjsgb2RiOyBvZGIgPSBvZGItPm5leHQpCgkJb2RiX2NsZWFyX2xvb3NlX2NhY2hlKG9kYik7CgoJci0+b2JqZWN0cy0+YXBwcm94aW1hdGVfb2JqZWN0X2NvdW50X3ZhbGlkID0gMDsKCXItPm9iamVjdHMtPnBhY2tlZF9naXRfaW5pdGlhbGl6ZWQgPSAwOwoJcHJlcGFyZV9wYWNrZWRfZ2l0KHIpOwoJb2JqX3JlYWRfdW5sb2NrKCk7Cn0KCnN0cnVjdCBwYWNrZWRfZ2l0ICpnZXRfcGFja2VkX2dpdChzdHJ1Y3QgcmVwb3NpdG9yeSAqcikKewoJcHJlcGFyZV9wYWNrZWRfZ2l0KHIpOwoJcmV0dXJuIHItPm9iamVjdHMtPnBhY2tlZF9naXQ7Cn0KCnN0cnVjdCBtdWx0aV9wYWNrX2luZGV4ICpnZXRfbXVsdGlfcGFja19pbmRleChzdHJ1Y3QgcmVwb3NpdG9yeSAqcikKewoJcHJlcGFyZV9wYWNrZWRfZ2l0KHIpOwoJcmV0dXJuIHItPm9iamVjdHMtPm11bHRpX3BhY2tfaW5kZXg7Cn0KCnN0cnVjdCBtdWx0aV9wYWNrX2luZGV4ICpnZXRfbG9jYWxfbXVsdGlfcGFja19pbmRleChzdHJ1Y3QgcmVwb3NpdG9yeSAqcikKewoJc3RydWN0IG11bHRpX3BhY2tfaW5kZXggKm0gPSBnZXRfbXVsdGlfcGFja19pbmRleChyKTsKCgkvKiBubyBuZWVkIHRvIGl0ZXJhdGU7IHdlIGFsd2F5cyBwdXQgdGhlIGxvY2FsIG9uZSBmaXJzdCAoaWYgYW55KSAqLwoJaWYgKG0gJiYgbS0+bG9jYWwpCgkJcmV0dXJuIG07CgoJcmV0dXJuIE5VTEw7Cn0KCnN0cnVjdCBwYWNrZWRfZ2l0ICpnZXRfYWxsX3BhY2tzKHN0cnVjdCByZXBvc2l0b3J5ICpyKQp7CglzdHJ1Y3QgbXVsdGlfcGFja19pbmRleCAqbTsKCglwcmVwYXJlX3BhY2tlZF9naXQocik7Cglmb3IgKG0gPSByLT5vYmplY3RzLT5tdWx0aV9wYWNrX2luZGV4OyBtOyBtID0gbS0+bmV4dCkgewoJCXVpbnQzMl90IGk7CgkJZm9yIChpID0gMDsgaSA8IG0tPm51bV9wYWNrcyArIG0tPm51bV9wYWNrc19pbl9iYXNlOyBpKyspCgkJCXByZXBhcmVfbWlkeF9wYWNrKHIsIG0sIGkpOwoJfQoKCXJldHVybiByLT5vYmplY3RzLT5wYWNrZWRfZ2l0Owp9CgpzdHJ1Y3QgbGlzdF9oZWFkICpnZXRfcGFja2VkX2dpdF9tcnUoc3RydWN0IHJlcG9zaXRvcnkgKnIpCnsKCXByZXBhcmVfcGFja2VkX2dpdChyKTsKCXJldHVybiAmci0+b2JqZWN0cy0+cGFja2VkX2dpdF9tcnU7Cn0KCnVuc2lnbmVkIGxvbmcgdW5wYWNrX29iamVjdF9oZWFkZXJfYnVmZmVyKGNvbnN0IHVuc2lnbmVkIGNoYXIgKmJ1ZiwKCQl1bnNpZ25lZCBsb25nIGxlbiwgZW51bSBvYmplY3RfdHlwZSAqdHlwZSwgdW5zaWduZWQgbG9uZyAqc2l6ZXApCnsKCXVuc2lnbmVkIHNoaWZ0OwoJc2l6ZV90IHNpemUsIGM7Cgl1bnNpZ25lZCBsb25nIHVzZWQgPSAwOwoKCWMgPSBidWZbdXNlZCsrXTsKCSp0eXBlID0gKGMgPj4gNCkgJiA3OwoJc2l6ZSA9IGMgJiAxNTsKCXNoaWZ0ID0gNDsKCXdoaWxlIChjICYgMHg4MCkgewoJCWlmIChsZW4gPD0gdXNlZCB8fCAoYml0c2l6ZW9mKGxvbmcpIC0gNykgPCBzaGlmdCkgewoJCQllcnJvcigiYmFkIG9iamVjdCBoZWFkZXIiKTsKCQkJc2l6ZSA9IHVzZWQgPSAwOwoJCQlicmVhazsKCQl9CgkJYyA9IGJ1Zlt1c2VkKytdOwoJCXNpemUgPSBzdF9hZGQoc2l6ZSwgc3RfbGVmdF9zaGlmdChjICYgMHg3Ziwgc2hpZnQpKTsKCQlzaGlmdCArPSA3OwoJfQoJKnNpemVwID0gY2FzdF9zaXplX3RfdG9fdWxvbmcoc2l6ZSk7CglyZXR1cm4gdXNlZDsKfQoKdW5zaWduZWQgbG9uZyBnZXRfc2l6ZV9mcm9tX2RlbHRhKHN0cnVjdCBwYWNrZWRfZ2l0ICpwLAoJCQkJICBzdHJ1Y3QgcGFja193aW5kb3cgKip3X2N1cnMsCgkJCQkgIG9mZl90IGN1cnBvcykKewoJY29uc3QgdW5zaWduZWQgY2hhciAqZGF0YTsKCXVuc2lnbmVkIGNoYXIgZGVsdGFfaGVhZFsyMF0sICppbjsKCWdpdF96c3RyZWFtIHN0cmVhbTsKCWludCBzdDsKCgltZW1zZXQoJnN0cmVhbSwgMCwgc2l6ZW9mKHN0cmVhbSkpOwoJc3RyZWFtLm5leHRfb3V0ID0gZGVsdGFfaGVhZDsKCXN0cmVhbS5hdmFpbF9vdXQgPSBzaXplb2YoZGVsdGFfaGVhZCk7CgoJZ2l0X2luZmxhdGVfaW5pdCgmc3RyZWFtKTsKCWRvIHsKCQlpbiA9IHVzZV9wYWNrKHAsIHdfY3VycywgY3VycG9zLCAmc3RyZWFtLmF2YWlsX2luKTsKCQlzdHJlYW0ubmV4dF9pbiA9IGluOwoJCS8qCgkJICogTm90ZTogdGhlIHdpbmRvdyBzZWN0aW9uIHJldHVybmVkIGJ5IHVzZV9wYWNrKCkgbXVzdCBiZQoJCSAqIGF2YWlsYWJsZSB0aHJvdWdob3V0IGdpdF9pbmZsYXRlKCkncyB1bmxvY2tlZCBleGVjdXRpb24uIFRvCgkJICogZW5zdXJlIG5vIG90aGVyIHRocmVhZCB3aWxsIG1vZGlmeSB0aGUgd2luZG93IGluIHRoZQoJCSAqIG1lYW50aW1lLCB3ZSByZWx5IG9uIHRoZSBwYWNrZWRfd2luZG93LmludXNlX2NudC4gVGhpcwoJCSAqIGNvdW50ZXIgaXMgaW5jcmVtZW50ZWQgYmVmb3JlIHdpbmRvdyByZWFkaW5nIGFuZCBjaGVja2VkCgkJICogYmVmb3JlIHdpbmRvdyBkaXNwb3NhbC4KCQkgKgoJCSAqIE90aGVyIHdvcnJ5aW5nIHNlY3Rpb25zIGNvdWxkIGJlIHRoZSBjYWxsIHRvIGNsb3NlX3BhY2tfZmQoKSwKCQkgKiB3aGljaCBjYW4gY2xvc2UgcGFja3MgZXZlbiB3aXRoIGluLXVzZSB3aW5kb3dzLCBhbmQgdG8KCQkgKiByZXByZXBhcmVfcGFja2VkX2dpdCgpLiBSZWdhcmRpbmcgdGhlIGZvcm1lciwgbW1hcCBkb2Mgc2F5czoKCQkgKiAiY2xvc2luZyB0aGUgZmlsZSBkZXNjcmlwdG9yIGRvZXMgbm90IHVubWFwIHRoZSByZWdpb24iLiBBbmQKCQkgKiBmb3IgdGhlIGxhdHRlciwgaXQgd29uJ3QgcmUtb3BlbiBhbHJlYWR5IGF2YWlsYWJsZSBwYWNrcy4KCQkgKi8KCQlvYmpfcmVhZF91bmxvY2soKTsKCQlzdCA9IGdpdF9pbmZsYXRlKCZzdHJlYW0sIFpfRklOSVNIKTsKCQlvYmpfcmVhZF9sb2NrKCk7CgkJY3VycG9zICs9IHN0cmVhbS5uZXh0X2luIC0gaW47Cgl9IHdoaWxlICgoc3QgPT0gWl9PSyB8fCBzdCA9PSBaX0JVRl9FUlJPUikgJiYKCQkgc3RyZWFtLnRvdGFsX291dCA8IHNpemVvZihkZWx0YV9oZWFkKSk7CglnaXRfaW5mbGF0ZV9lbmQoJnN0cmVhbSk7CglpZiAoKHN0ICE9IFpfU1RSRUFNX0VORCkgJiYgc3RyZWFtLnRvdGFsX291dCAhPSBzaXplb2YoZGVsdGFfaGVhZCkpIHsKCQllcnJvcigiZGVsdGEgZGF0YSB1bnBhY2staW5pdGlhbCBmYWlsZWQiKTsKCQlyZXR1cm4gMDsKCX0KCgkvKiBFeGFtaW5lIHRoZSBpbml0aWFsIHBhcnQgb2YgdGhlIGRlbHRhIHRvIGZpZ3VyZSBvdXQKCSAqIHRoZSByZXN1bHQgc2l6ZS4KCSAqLwoJZGF0YSA9IGRlbHRhX2hlYWQ7CgoJLyogaWdub3JlIGJhc2Ugc2l6ZSAqLwoJZ2V0X2RlbHRhX2hkcl9zaXplKCZkYXRhLCBkZWx0YV9oZWFkK3NpemVvZihkZWx0YV9oZWFkKSk7CgoJLyogUmVhZCB0aGUgcmVzdWx0IHNpemUgKi8KCXJldHVybiBnZXRfZGVsdGFfaGRyX3NpemUoJmRhdGEsIGRlbHRhX2hlYWQrc2l6ZW9mKGRlbHRhX2hlYWQpKTsKfQoKaW50IHVucGFja19vYmplY3RfaGVhZGVyKHN0cnVjdCBwYWNrZWRfZ2l0ICpwLAoJCQkgc3RydWN0IHBhY2tfd2luZG93ICoqd19jdXJzLAoJCQkgb2ZmX3QgKmN1cnBvcywKCQkJIHVuc2lnbmVkIGxvbmcgKnNpemVwKQp7Cgl1bnNpZ25lZCBjaGFyICpiYXNlOwoJdW5zaWduZWQgbG9uZyBsZWZ0OwoJdW5zaWduZWQgbG9uZyB1c2VkOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoKCS8qIHVzZV9wYWNrKCkgYXNzdXJlcyB1cyB3ZSBoYXZlIFtiYXNlLCBiYXNlICsgMjApIGF2YWlsYWJsZQoJICogYXMgYSByYW5nZSB0aGF0IHdlIGNhbiBsb29rIGF0LiAgKEl0cyBhY3R1YWxseSB0aGUgaGFzaAoJICogc2l6ZSB0aGF0IGlzIGFzc3VyZWQuKSAgV2l0aCBvdXIgb2JqZWN0IGhlYWRlciBlbmNvZGluZwoJICogdGhlIG1heGltdW0gZGVmbGF0ZWQgb2JqZWN0IHNpemUgaXMgMl4xMzcsIHdoaWNoIGlzIGp1c3QKCSAqIGluc2FuZSwgc28gd2Uga25vdyB3b24ndCBleGNlZWQgd2hhdCB3ZSBoYXZlIGJlZW4gZ2l2ZW4uCgkgKi8KCWJhc2UgPSB1c2VfcGFjayhwLCB3X2N1cnMsICpjdXJwb3MsICZsZWZ0KTsKCXVzZWQgPSB1bnBhY2tfb2JqZWN0X2hlYWRlcl9idWZmZXIoYmFzZSwgbGVmdCwgJnR5cGUsIHNpemVwKTsKCWlmICghdXNlZCkgewoJCXR5cGUgPSBPQkpfQkFEOwoJfSBlbHNlCgkJKmN1cnBvcyArPSB1c2VkOwoKCXJldHVybiB0eXBlOwp9Cgp2b2lkIG1hcmtfYmFkX3BhY2tlZF9vYmplY3Qoc3RydWN0IHBhY2tlZF9naXQgKnAsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJb2lkc2V0X2luc2VydCgmcC0+YmFkX29iamVjdHMsIG9pZCk7Cn0KCmNvbnN0IHN0cnVjdCBwYWNrZWRfZ2l0ICpoYXNfcGFja2VkX2FuZF9iYWQoc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCQkJICAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJc3RydWN0IHBhY2tlZF9naXQgKnA7CgoJZm9yIChwID0gci0+b2JqZWN0cy0+cGFja2VkX2dpdDsgcDsgcCA9IHAtPm5leHQpCgkJaWYgKG9pZHNldF9jb250YWlucygmcC0+YmFkX29iamVjdHMsIG9pZCkpCgkJCXJldHVybiBwOwoJcmV0dXJuIE5VTEw7Cn0KCm9mZl90IGdldF9kZWx0YV9iYXNlKHN0cnVjdCBwYWNrZWRfZ2l0ICpwLAoJCSAgICAgc3RydWN0IHBhY2tfd2luZG93ICoqd19jdXJzLAoJCSAgICAgb2ZmX3QgKmN1cnBvcywKCQkgICAgIGVudW0gb2JqZWN0X3R5cGUgdHlwZSwKCQkgICAgIG9mZl90IGRlbHRhX29ial9vZmZzZXQpCnsKCXVuc2lnbmVkIGNoYXIgKmJhc2VfaW5mbyA9IHVzZV9wYWNrKHAsIHdfY3VycywgKmN1cnBvcywgTlVMTCk7CglvZmZfdCBiYXNlX29mZnNldDsKCgkvKiB1c2VfcGFjaygpIGFzc3VyZWQgdXMgd2UgaGF2ZSBbYmFzZV9pbmZvLCBiYXNlX2luZm8gKyAyMCkKCSAqIGFzIGEgcmFuZ2UgdGhhdCB3ZSBjYW4gbG9vayBhdCB3aXRob3V0IHdhbGtpbmcgb2ZmIHRoZQoJICogZW5kIG9mIHRoZSBtYXBwZWQgd2luZG93LiAgSXRzIGFjdHVhbGx5IHRoZSBoYXNoIHNpemUKCSAqIHRoYXQgaXMgYXNzdXJlZC4gIEFuIE9GU19ERUxUQSBsb25nZXIgdGhhbiB0aGUgaGFzaCBzaXplCgkgKiBpcyBzdHVwaWQsIGFzIHRoZW4gYSBSRUZfREVMVEEgd291bGQgYmUgc21hbGxlciB0byBzdG9yZS4KCSAqLwoJaWYgKHR5cGUgPT0gT0JKX09GU19ERUxUQSkgewoJCXVuc2lnbmVkIHVzZWQgPSAwOwoJCXVuc2lnbmVkIGNoYXIgYyA9IGJhc2VfaW5mb1t1c2VkKytdOwoJCWJhc2Vfb2Zmc2V0ID0gYyAmIDEyNzsKCQl3aGlsZSAoYyAmIDEyOCkgewoJCQliYXNlX29mZnNldCArPSAxOwoJCQlpZiAoIWJhc2Vfb2Zmc2V0IHx8IE1TQihiYXNlX29mZnNldCwgNykpCgkJCQlyZXR1cm4gMDsgIC8qIG92ZXJmbG93ICovCgkJCWMgPSBiYXNlX2luZm9bdXNlZCsrXTsKCQkJYmFzZV9vZmZzZXQgPSAoYmFzZV9vZmZzZXQgPDwgNykgKyAoYyAmIDEyNyk7CgkJfQoJCWJhc2Vfb2Zmc2V0ID0gZGVsdGFfb2JqX29mZnNldCAtIGJhc2Vfb2Zmc2V0OwoJCWlmIChiYXNlX29mZnNldCA8PSAwIHx8IGJhc2Vfb2Zmc2V0ID49IGRlbHRhX29ial9vZmZzZXQpCgkJCXJldHVybiAwOyAgLyogb3V0IG9mIGJvdW5kICovCgkJKmN1cnBvcyArPSB1c2VkOwoJfSBlbHNlIGlmICh0eXBlID09IE9CSl9SRUZfREVMVEEpIHsKCQkvKiBUaGUgYmFzZSBlbnRyeSBfbXVzdF8gYmUgaW4gdGhlIHNhbWUgcGFjayAqLwoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCWhhc2hjcHkob2lkLmhhc2gsIGJhc2VfaW5mbywgdGhlX3JlcG9zaXRvcnktPmhhc2hfYWxnbyk7CgkJYmFzZV9vZmZzZXQgPSBmaW5kX3BhY2tfZW50cnlfb25lKCZvaWQsIHApOwoJCSpjdXJwb3MgKz0gdGhlX2hhc2hfYWxnby0+cmF3c3o7Cgl9IGVsc2UKCQlkaWUoIkkgYW0gdG90YWxseSBzY3Jld2VkIik7CglyZXR1cm4gYmFzZV9vZmZzZXQ7Cn0KCi8qCiAqIExpa2UgZ2V0X2RlbHRhX2Jhc2UgYWJvdmUsIGJ1dCB3ZSByZXR1cm4gdGhlIHNoYTEgaW5zdGVhZCBvZiB0aGUgcGFjawogKiBvZmZzZXQuIFRoaXMgbWVhbnMgaXQgaXMgY2hlYXBlciBmb3IgUkVGIGRlbHRhcyAod2UgZG8gbm90IGhhdmUgdG8gZG8KICogdGhlIGZpbmFsIG9iamVjdCBsb29rdXApLCBidXQgbW9yZSBleHBlbnNpdmUgZm9yIE9GUyBkZWx0YXMgKHdlCiAqIGhhdmUgdG8gbG9hZCB0aGUgcmV2aWR4IHRvIGNvbnZlcnQgdGhlIG9mZnNldCBiYWNrIGludG8gYSBzaGExKS4KICovCnN0YXRpYyBpbnQgZ2V0X2RlbHRhX2Jhc2Vfb2lkKHN0cnVjdCBwYWNrZWRfZ2l0ICpwLAoJCQkgICAgICBzdHJ1Y3QgcGFja193aW5kb3cgKip3X2N1cnMsCgkJCSAgICAgIG9mZl90IGN1cnBvcywKCQkJICAgICAgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgICAgICBlbnVtIG9iamVjdF90eXBlIHR5cGUsCgkJCSAgICAgIG9mZl90IGRlbHRhX29ial9vZmZzZXQpCnsKCWlmICh0eXBlID09IE9CSl9SRUZfREVMVEEpIHsKCQl1bnNpZ25lZCBjaGFyICpiYXNlID0gdXNlX3BhY2socCwgd19jdXJzLCBjdXJwb3MsIE5VTEwpOwoJCW9pZHJlYWQob2lkLCBiYXNlLCB0aGVfcmVwb3NpdG9yeS0+aGFzaF9hbGdvKTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAodHlwZSA9PSBPQkpfT0ZTX0RFTFRBKSB7CgkJdWludDMyX3QgYmFzZV9wb3M7CgkJb2ZmX3QgYmFzZV9vZmZzZXQgPSBnZXRfZGVsdGFfYmFzZShwLCB3X2N1cnMsICZjdXJwb3MsCgkJCQkJCSAgIHR5cGUsIGRlbHRhX29ial9vZmZzZXQpOwoKCQlpZiAoIWJhc2Vfb2Zmc2V0KQoJCQlyZXR1cm4gLTE7CgoJCWlmIChvZmZzZXRfdG9fcGFja19wb3MocCwgYmFzZV9vZmZzZXQsICZiYXNlX3BvcykgPCAwKQoJCQlyZXR1cm4gLTE7CgoJCXJldHVybiBudGhfcGFja2VkX29iamVjdF9pZChvaWQsIHAsCgkJCQkJICAgIHBhY2tfcG9zX3RvX2luZGV4KHAsIGJhc2VfcG9zKSk7Cgl9IGVsc2UKCQlyZXR1cm4gLTE7Cn0KCnN0YXRpYyBpbnQgcmV0cnlfYmFkX3BhY2tlZF9vZmZzZXQoc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCQkgICBzdHJ1Y3QgcGFja2VkX2dpdCAqcCwKCQkJCSAgIG9mZl90IG9ial9vZmZzZXQpCnsKCWludCB0eXBlOwoJdWludDMyX3QgcG9zOwoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CglpZiAob2Zmc2V0X3RvX3BhY2tfcG9zKHAsIG9ial9vZmZzZXQsICZwb3MpIDwgMCkKCQlyZXR1cm4gT0JKX0JBRDsKCW50aF9wYWNrZWRfb2JqZWN0X2lkKCZvaWQsIHAsIHBhY2tfcG9zX3RvX2luZGV4KHAsIHBvcykpOwoJbWFya19iYWRfcGFja2VkX29iamVjdChwLCAmb2lkKTsKCXR5cGUgPSBvaWRfb2JqZWN0X2luZm8ociwgJm9pZCwgTlVMTCk7CglpZiAodHlwZSA8PSBPQkpfTk9ORSkKCQlyZXR1cm4gT0JKX0JBRDsKCXJldHVybiB0eXBlOwp9CgojZGVmaW5lIFBPSV9TVEFDS19QUkVBTExPQyA2NAoKc3RhdGljIGVudW0gb2JqZWN0X3R5cGUgcGFja2VkX3RvX29iamVjdF90eXBlKHN0cnVjdCByZXBvc2l0b3J5ICpyLAoJCQkJCSAgICAgIHN0cnVjdCBwYWNrZWRfZ2l0ICpwLAoJCQkJCSAgICAgIG9mZl90IG9ial9vZmZzZXQsCgkJCQkJICAgICAgZW51bSBvYmplY3RfdHlwZSB0eXBlLAoJCQkJCSAgICAgIHN0cnVjdCBwYWNrX3dpbmRvdyAqKndfY3VycywKCQkJCQkgICAgICBvZmZfdCBjdXJwb3MpCnsKCW9mZl90IHNtYWxsX3BvaV9zdGFja1tQT0lfU1RBQ0tfUFJFQUxMT0NdOwoJb2ZmX3QgKnBvaV9zdGFjayA9IHNtYWxsX3BvaV9zdGFjazsKCWludCBwb2lfc3RhY2tfbnIgPSAwLCBwb2lfc3RhY2tfYWxsb2MgPSBQT0lfU1RBQ0tfUFJFQUxMT0M7CgoJd2hpbGUgKHR5cGUgPT0gT0JKX09GU19ERUxUQSB8fCB0eXBlID09IE9CSl9SRUZfREVMVEEpIHsKCQlvZmZfdCBiYXNlX29mZnNldDsKCQl1bnNpZ25lZCBsb25nIHNpemU7CgkJLyogUHVzaCB0aGUgb2JqZWN0IHdlJ3JlIGdvaW5nIHRvIGxlYXZlIGJlaGluZCAqLwoJCWlmIChwb2lfc3RhY2tfbnIgPj0gcG9pX3N0YWNrX2FsbG9jICYmIHBvaV9zdGFjayA9PSBzbWFsbF9wb2lfc3RhY2spIHsKCQkJcG9pX3N0YWNrX2FsbG9jID0gYWxsb2NfbnIocG9pX3N0YWNrX25yKTsKCQkJQUxMT0NfQVJSQVkocG9pX3N0YWNrLCBwb2lfc3RhY2tfYWxsb2MpOwoJCQlDT1BZX0FSUkFZKHBvaV9zdGFjaywgc21hbGxfcG9pX3N0YWNrLCBwb2lfc3RhY2tfbnIpOwoJCX0gZWxzZSB7CgkJCUFMTE9DX0dST1cocG9pX3N0YWNrLCBwb2lfc3RhY2tfbnIrMSwgcG9pX3N0YWNrX2FsbG9jKTsKCQl9CgkJcG9pX3N0YWNrW3BvaV9zdGFja19ucisrXSA9IG9ial9vZmZzZXQ7CgkJLyogSWYgcGFyc2luZyB0aGUgYmFzZSBvZmZzZXQgZmFpbHMsIGp1c3QgdW53aW5kICovCgkJYmFzZV9vZmZzZXQgPSBnZXRfZGVsdGFfYmFzZShwLCB3X2N1cnMsICZjdXJwb3MsIHR5cGUsIG9ial9vZmZzZXQpOwoJCWlmICghYmFzZV9vZmZzZXQpCgkJCWdvdG8gdW53aW5kOwoJCWN1cnBvcyA9IG9ial9vZmZzZXQgPSBiYXNlX29mZnNldDsKCQl0eXBlID0gdW5wYWNrX29iamVjdF9oZWFkZXIocCwgd19jdXJzLCAmY3VycG9zLCAmc2l6ZSk7CgkJaWYgKHR5cGUgPD0gT0JKX05PTkUpIHsKCQkJLyogSWYgZ2V0dGluZyB0aGUgYmFzZSBpdHNlbGYgZmFpbHMsIHdlIGZpcnN0CgkJCSAqIHJldHJ5IHRoZSBiYXNlLCBvdGhlcndpc2UgdW53aW5kICovCgkJCXR5cGUgPSByZXRyeV9iYWRfcGFja2VkX29mZnNldChyLCBwLCBiYXNlX29mZnNldCk7CgkJCWlmICh0eXBlID4gT0JKX05PTkUpCgkJCQlnb3RvIG91dDsKCQkJZ290byB1bndpbmQ7CgkJfQoJfQoKCXN3aXRjaCAodHlwZSkgewoJY2FzZSBPQkpfQkFEOgoJY2FzZSBPQkpfQ09NTUlUOgoJY2FzZSBPQkpfVFJFRToKCWNhc2UgT0JKX0JMT0I6CgljYXNlIE9CSl9UQUc6CgkJYnJlYWs7CglkZWZhdWx0OgoJCWVycm9yKCJ1bmtub3duIG9iamVjdCB0eXBlICVpIGF0IG9mZnNldCAlIlBSSXVNQVgiIGluICVzIiwKCQkgICAgICB0eXBlLCAodWludG1heF90KW9ial9vZmZzZXQsIHAtPnBhY2tfbmFtZSk7CgkJdHlwZSA9IE9CSl9CQUQ7Cgl9CgpvdXQ6CglpZiAocG9pX3N0YWNrICE9IHNtYWxsX3BvaV9zdGFjaykKCQlmcmVlKHBvaV9zdGFjayk7CglyZXR1cm4gdHlwZTsKCnVud2luZDoKCXdoaWxlIChwb2lfc3RhY2tfbnIpIHsKCQlvYmpfb2Zmc2V0ID0gcG9pX3N0YWNrWy0tcG9pX3N0YWNrX25yXTsKCQl0eXBlID0gcmV0cnlfYmFkX3BhY2tlZF9vZmZzZXQociwgcCwgb2JqX29mZnNldCk7CgkJaWYgKHR5cGUgPiBPQkpfTk9ORSkKCQkJZ290byBvdXQ7Cgl9Cgl0eXBlID0gT0JKX0JBRDsKCWdvdG8gb3V0Owp9CgpzdGF0aWMgc3RydWN0IGhhc2htYXAgZGVsdGFfYmFzZV9jYWNoZTsKc3RhdGljIHNpemVfdCBkZWx0YV9iYXNlX2NhY2hlZDsKCnN0YXRpYyBMSVNUX0hFQUQoZGVsdGFfYmFzZV9jYWNoZV9scnUpOwoKc3RydWN0IGRlbHRhX2Jhc2VfY2FjaGVfa2V5IHsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwOwoJb2ZmX3QgYmFzZV9vZmZzZXQ7Cn07CgpzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9lbnRyeSB7CglzdHJ1Y3QgaGFzaG1hcF9lbnRyeSBlbnQ7CglzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9rZXkga2V5OwoJc3RydWN0IGxpc3RfaGVhZCBscnU7Cgl2b2lkICpkYXRhOwoJdW5zaWduZWQgbG9uZyBzaXplOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwp9OwoKc3RhdGljIHVuc2lnbmVkIGludCBwYWNrX2VudHJ5X2hhc2goc3RydWN0IHBhY2tlZF9naXQgKnAsIG9mZl90IGJhc2Vfb2Zmc2V0KQp7Cgl1bnNpZ25lZCBpbnQgaGFzaDsKCgloYXNoID0gKHVuc2lnbmVkIGludCkoaW50cHRyX3QpcCArICh1bnNpZ25lZCBpbnQpYmFzZV9vZmZzZXQ7CgloYXNoICs9IChoYXNoID4+IDgpICsgKGhhc2ggPj4gMTYpOwoJcmV0dXJuIGhhc2g7Cn0KCnN0YXRpYyBzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9lbnRyeSAqCmdldF9kZWx0YV9iYXNlX2NhY2hlX2VudHJ5KHN0cnVjdCBwYWNrZWRfZ2l0ICpwLCBvZmZfdCBiYXNlX29mZnNldCkKewoJc3RydWN0IGhhc2htYXBfZW50cnkgZW50cnksICplOwoJc3RydWN0IGRlbHRhX2Jhc2VfY2FjaGVfa2V5IGtleTsKCglpZiAoIWRlbHRhX2Jhc2VfY2FjaGUuY21wZm4pCgkJcmV0dXJuIE5VTEw7CgoJaGFzaG1hcF9lbnRyeV9pbml0KCZlbnRyeSwgcGFja19lbnRyeV9oYXNoKHAsIGJhc2Vfb2Zmc2V0KSk7CglrZXkucCA9IHA7CglrZXkuYmFzZV9vZmZzZXQgPSBiYXNlX29mZnNldDsKCWUgPSBoYXNobWFwX2dldCgmZGVsdGFfYmFzZV9jYWNoZSwgJmVudHJ5LCAma2V5KTsKCXJldHVybiBlID8gY29udGFpbmVyX29mKGUsIHN0cnVjdCBkZWx0YV9iYXNlX2NhY2hlX2VudHJ5LCBlbnQpIDogTlVMTDsKfQoKc3RhdGljIGludCBkZWx0YV9iYXNlX2NhY2hlX2tleV9lcShjb25zdCBzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9rZXkgKmEsCgkJCQkgICBjb25zdCBzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9rZXkgKmIpCnsKCXJldHVybiBhLT5wID09IGItPnAgJiYgYS0+YmFzZV9vZmZzZXQgPT0gYi0+YmFzZV9vZmZzZXQ7Cn0KCnN0YXRpYyBpbnQgZGVsdGFfYmFzZV9jYWNoZV9oYXNoX2NtcChjb25zdCB2b2lkICpjbXBfZGF0YSBVTlVTRUQsCgkJCQkgICAgIGNvbnN0IHN0cnVjdCBoYXNobWFwX2VudHJ5ICp2YSwKCQkJCSAgICAgY29uc3Qgc3RydWN0IGhhc2htYXBfZW50cnkgKnZiLAoJCQkJICAgICBjb25zdCB2b2lkICp2a2V5KQp7Cgljb25zdCBzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9lbnRyeSAqYSwgKmI7Cgljb25zdCBzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9rZXkgKmtleSA9IHZrZXk7CgoJYSA9IGNvbnRhaW5lcl9vZih2YSwgY29uc3Qgc3RydWN0IGRlbHRhX2Jhc2VfY2FjaGVfZW50cnksIGVudCk7CgliID0gY29udGFpbmVyX29mKHZiLCBjb25zdCBzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9lbnRyeSwgZW50KTsKCglpZiAoa2V5KQoJCXJldHVybiAhZGVsdGFfYmFzZV9jYWNoZV9rZXlfZXEoJmEtPmtleSwga2V5KTsKCWVsc2UKCQlyZXR1cm4gIWRlbHRhX2Jhc2VfY2FjaGVfa2V5X2VxKCZhLT5rZXksICZiLT5rZXkpOwp9CgpzdGF0aWMgaW50IGluX2RlbHRhX2Jhc2VfY2FjaGUoc3RydWN0IHBhY2tlZF9naXQgKnAsIG9mZl90IGJhc2Vfb2Zmc2V0KQp7CglyZXR1cm4gISFnZXRfZGVsdGFfYmFzZV9jYWNoZV9lbnRyeShwLCBiYXNlX29mZnNldCk7Cn0KCi8qCiAqIFJlbW92ZSB0aGUgZW50cnkgZnJvbSB0aGUgY2FjaGUsIGJ1dCBkbyBfbm90XyBmcmVlIHRoZSBhc3NvY2lhdGVkCiAqIGVudHJ5IGRhdGEuIFRoZSBjYWxsZXIgdGFrZXMgb3duZXJzaGlwIG9mIHRoZSAiZGF0YSIgYnVmZmVyLCBhbmQKICogc2hvdWxkIGNvcHkgb3V0IGFueSBmaWVsZHMgaXQgd2FudHMgYmVmb3JlIGRldGFjaGluZy4KICovCnN0YXRpYyB2b2lkIGRldGFjaF9kZWx0YV9iYXNlX2NhY2hlX2VudHJ5KHN0cnVjdCBkZWx0YV9iYXNlX2NhY2hlX2VudHJ5ICplbnQpCnsKCWhhc2htYXBfcmVtb3ZlKCZkZWx0YV9iYXNlX2NhY2hlLCAmZW50LT5lbnQsICZlbnQtPmtleSk7CglsaXN0X2RlbCgmZW50LT5scnUpOwoJZGVsdGFfYmFzZV9jYWNoZWQgLT0gZW50LT5zaXplOwoJZnJlZShlbnQpOwp9CgpzdGF0aWMgdm9pZCAqY2FjaGVfb3JfdW5wYWNrX2VudHJ5KHN0cnVjdCByZXBvc2l0b3J5ICpyLCBzdHJ1Y3QgcGFja2VkX2dpdCAqcCwKCQkJCSAgIG9mZl90IGJhc2Vfb2Zmc2V0LCB1bnNpZ25lZCBsb25nICpiYXNlX3NpemUsCgkJCQkgICBlbnVtIG9iamVjdF90eXBlICp0eXBlKQp7CglzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9lbnRyeSAqZW50OwoKCWVudCA9IGdldF9kZWx0YV9iYXNlX2NhY2hlX2VudHJ5KHAsIGJhc2Vfb2Zmc2V0KTsKCWlmICghZW50KQoJCXJldHVybiB1bnBhY2tfZW50cnkociwgcCwgYmFzZV9vZmZzZXQsIHR5cGUsIGJhc2Vfc2l6ZSk7CgoJaWYgKHR5cGUpCgkJKnR5cGUgPSBlbnQtPnR5cGU7CglpZiAoYmFzZV9zaXplKQoJCSpiYXNlX3NpemUgPSBlbnQtPnNpemU7CglyZXR1cm4geG1lbWR1cHooZW50LT5kYXRhLCBlbnQtPnNpemUpOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQgcmVsZWFzZV9kZWx0YV9iYXNlX2NhY2hlKHN0cnVjdCBkZWx0YV9iYXNlX2NhY2hlX2VudHJ5ICplbnQpCnsKCWZyZWUoZW50LT5kYXRhKTsKCWRldGFjaF9kZWx0YV9iYXNlX2NhY2hlX2VudHJ5KGVudCk7Cn0KCnZvaWQgY2xlYXJfZGVsdGFfYmFzZV9jYWNoZSh2b2lkKQp7CglzdHJ1Y3QgbGlzdF9oZWFkICpscnUsICp0bXA7CglsaXN0X2Zvcl9lYWNoX3NhZmUobHJ1LCB0bXAsICZkZWx0YV9iYXNlX2NhY2hlX2xydSkgewoJCXN0cnVjdCBkZWx0YV9iYXNlX2NhY2hlX2VudHJ5ICplbnRyeSA9CgkJCWxpc3RfZW50cnkobHJ1LCBzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9lbnRyeSwgbHJ1KTsKCQlyZWxlYXNlX2RlbHRhX2Jhc2VfY2FjaGUoZW50cnkpOwoJfQp9CgpzdGF0aWMgdm9pZCBhZGRfZGVsdGFfYmFzZV9jYWNoZShzdHJ1Y3QgcGFja2VkX2dpdCAqcCwgb2ZmX3QgYmFzZV9vZmZzZXQsCgl2b2lkICpiYXNlLCB1bnNpZ25lZCBsb25nIGJhc2Vfc2l6ZSwgZW51bSBvYmplY3RfdHlwZSB0eXBlKQp7CglzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9lbnRyeSAqZW50OwoJc3RydWN0IGxpc3RfaGVhZCAqbHJ1LCAqdG1wOwoKCS8qCgkgKiBDaGVjayByZXF1aXJlZCB0byBhdm9pZCByZWR1bmRhbnQgZW50cmllcyB3aGVuIG1vcmUgdGhhbiBvbmUgdGhyZWFkCgkgKiBpcyB1bnBhY2tpbmcgdGhlIHNhbWUgb2JqZWN0LCBpbiB1bnBhY2tfZW50cnkoKSAoc2luY2UgaXRzIHBoYXNlcyBJCgkgKiBhbmQgSUlJIG1pZ2h0IHJ1biBjb25jdXJyZW50bHkgYWNyb3NzIG11bHRpcGxlIHRocmVhZHMpLgoJICovCglpZiAoaW5fZGVsdGFfYmFzZV9jYWNoZShwLCBiYXNlX29mZnNldCkpIHsKCQlmcmVlKGJhc2UpOwoJCXJldHVybjsKCX0KCglkZWx0YV9iYXNlX2NhY2hlZCArPSBiYXNlX3NpemU7CgoJbGlzdF9mb3JfZWFjaF9zYWZlKGxydSwgdG1wLCAmZGVsdGFfYmFzZV9jYWNoZV9scnUpIHsKCQlzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9lbnRyeSAqZiA9CgkJCWxpc3RfZW50cnkobHJ1LCBzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9lbnRyeSwgbHJ1KTsKCQlpZiAoZGVsdGFfYmFzZV9jYWNoZWQgPD0gZGVsdGFfYmFzZV9jYWNoZV9saW1pdCkKCQkJYnJlYWs7CgkJcmVsZWFzZV9kZWx0YV9iYXNlX2NhY2hlKGYpOwoJfQoKCWVudCA9IHhtYWxsb2Moc2l6ZW9mKCplbnQpKTsKCWVudC0+a2V5LnAgPSBwOwoJZW50LT5rZXkuYmFzZV9vZmZzZXQgPSBiYXNlX29mZnNldDsKCWVudC0+dHlwZSA9IHR5cGU7CgllbnQtPmRhdGEgPSBiYXNlOwoJZW50LT5zaXplID0gYmFzZV9zaXplOwoJbGlzdF9hZGRfdGFpbCgmZW50LT5scnUsICZkZWx0YV9iYXNlX2NhY2hlX2xydSk7CgoJaWYgKCFkZWx0YV9iYXNlX2NhY2hlLmNtcGZuKQoJCWhhc2htYXBfaW5pdCgmZGVsdGFfYmFzZV9jYWNoZSwgZGVsdGFfYmFzZV9jYWNoZV9oYXNoX2NtcCwgTlVMTCwgMCk7CgloYXNobWFwX2VudHJ5X2luaXQoJmVudC0+ZW50LCBwYWNrX2VudHJ5X2hhc2gocCwgYmFzZV9vZmZzZXQpKTsKCWhhc2htYXBfYWRkKCZkZWx0YV9iYXNlX2NhY2hlLCAmZW50LT5lbnQpOwp9CgppbnQgcGFja2VkX29iamVjdF9pbmZvKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBzdHJ1Y3QgcGFja2VkX2dpdCAqcCwKCQkgICAgICAgb2ZmX3Qgb2JqX29mZnNldCwgc3RydWN0IG9iamVjdF9pbmZvICpvaSkKewoJc3RydWN0IHBhY2tfd2luZG93ICp3X2N1cnMgPSBOVUxMOwoJdW5zaWduZWQgbG9uZyBzaXplOwoJb2ZmX3QgY3VycG9zID0gb2JqX29mZnNldDsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCgkvKgoJICogV2UgYWx3YXlzIGdldCB0aGUgcmVwcmVzZW50YXRpb24gdHlwZSwgYnV0IG9ubHkgY29udmVydCBpdCB0bwoJICogYSAicmVhbCIgdHlwZSBsYXRlciBpZiB0aGUgY2FsbGVyIGlzIGludGVyZXN0ZWQuCgkgKi8KCWlmIChvaS0+Y29udGVudHApIHsKCQkqb2ktPmNvbnRlbnRwID0gY2FjaGVfb3JfdW5wYWNrX2VudHJ5KHIsIHAsIG9ial9vZmZzZXQsIG9pLT5zaXplcCwKCQkJCQkJICAgICAgJnR5cGUpOwoJCWlmICghKm9pLT5jb250ZW50cCkKCQkJdHlwZSA9IE9CSl9CQUQ7Cgl9IGVsc2UgewoJCXR5cGUgPSB1bnBhY2tfb2JqZWN0X2hlYWRlcihwLCAmd19jdXJzLCAmY3VycG9zLCAmc2l6ZSk7Cgl9CgoJaWYgKCFvaS0+Y29udGVudHAgJiYgb2ktPnNpemVwKSB7CgkJaWYgKHR5cGUgPT0gT0JKX09GU19ERUxUQSB8fCB0eXBlID09IE9CSl9SRUZfREVMVEEpIHsKCQkJb2ZmX3QgdG1wX3BvcyA9IGN1cnBvczsKCQkJb2ZmX3QgYmFzZV9vZmZzZXQgPSBnZXRfZGVsdGFfYmFzZShwLCAmd19jdXJzLCAmdG1wX3BvcywKCQkJCQkJCSAgIHR5cGUsIG9ial9vZmZzZXQpOwoJCQlpZiAoIWJhc2Vfb2Zmc2V0KSB7CgkJCQl0eXBlID0gT0JKX0JBRDsKCQkJCWdvdG8gb3V0OwoJCQl9CgkJCSpvaS0+c2l6ZXAgPSBnZXRfc2l6ZV9mcm9tX2RlbHRhKHAsICZ3X2N1cnMsIHRtcF9wb3MpOwoJCQlpZiAoKm9pLT5zaXplcCA9PSAwKSB7CgkJCQl0eXBlID0gT0JKX0JBRDsKCQkJCWdvdG8gb3V0OwoJCQl9CgkJfSBlbHNlIHsKCQkJKm9pLT5zaXplcCA9IHNpemU7CgkJfQoJfQoKCWlmIChvaS0+ZGlza19zaXplcCkgewoJCXVpbnQzMl90IHBvczsKCQlpZiAob2Zmc2V0X3RvX3BhY2tfcG9zKHAsIG9ial9vZmZzZXQsICZwb3MpIDwgMCkgewoJCQllcnJvcigiY291bGQgbm90IGZpbmQgb2JqZWN0IGF0IG9mZnNldCAlIlBSSXVNQVgiICIKCQkJICAgICAgImluIHBhY2sgJXMiLCAodWludG1heF90KW9ial9vZmZzZXQsIHAtPnBhY2tfbmFtZSk7CgkJCXR5cGUgPSBPQkpfQkFEOwoJCQlnb3RvIG91dDsKCQl9CgoJCSpvaS0+ZGlza19zaXplcCA9IHBhY2tfcG9zX3RvX29mZnNldChwLCBwb3MgKyAxKSAtIG9ial9vZmZzZXQ7Cgl9CgoJaWYgKG9pLT50eXBlcCB8fCBvaS0+dHlwZV9uYW1lKSB7CgkJZW51bSBvYmplY3RfdHlwZSBwdG90OwoJCXB0b3QgPSBwYWNrZWRfdG9fb2JqZWN0X3R5cGUociwgcCwgb2JqX29mZnNldCwKCQkJCQkgICAgIHR5cGUsICZ3X2N1cnMsIGN1cnBvcyk7CgkJaWYgKG9pLT50eXBlcCkKCQkJKm9pLT50eXBlcCA9IHB0b3Q7CgkJaWYgKG9pLT50eXBlX25hbWUpIHsKCQkJY29uc3QgY2hhciAqdG4gPSB0eXBlX25hbWUocHRvdCk7CgkJCWlmICh0bikKCQkJCXN0cmJ1Zl9hZGRzdHIob2ktPnR5cGVfbmFtZSwgdG4pOwoJCX0KCQlpZiAocHRvdCA8IDApIHsKCQkJdHlwZSA9IE9CSl9CQUQ7CgkJCWdvdG8gb3V0OwoJCX0KCX0KCglpZiAob2ktPmRlbHRhX2Jhc2Vfb2lkKSB7CgkJaWYgKHR5cGUgPT0gT0JKX09GU19ERUxUQSB8fCB0eXBlID09IE9CSl9SRUZfREVMVEEpIHsKCQkJaWYgKGdldF9kZWx0YV9iYXNlX29pZChwLCAmd19jdXJzLCBjdXJwb3MsCgkJCQkJICAgICAgIG9pLT5kZWx0YV9iYXNlX29pZCwKCQkJCQkgICAgICAgdHlwZSwgb2JqX29mZnNldCkgPCAwKSB7CgkJCQl0eXBlID0gT0JKX0JBRDsKCQkJCWdvdG8gb3V0OwoJCQl9CgkJfSBlbHNlCgkJCW9pZGNscihvaS0+ZGVsdGFfYmFzZV9vaWQsIHRoZV9yZXBvc2l0b3J5LT5oYXNoX2FsZ28pOwoJfQoKCW9pLT53aGVuY2UgPSBpbl9kZWx0YV9iYXNlX2NhY2hlKHAsIG9ial9vZmZzZXQpID8gT0lfREJDQUNIRUQgOgoJCQkJCQkJICBPSV9QQUNLRUQ7CgpvdXQ6Cgl1bnVzZV9wYWNrKCZ3X2N1cnMpOwoJcmV0dXJuIHR5cGU7Cn0KCnN0YXRpYyB2b2lkICp1bnBhY2tfY29tcHJlc3NlZF9lbnRyeShzdHJ1Y3QgcGFja2VkX2dpdCAqcCwKCQkJCSAgICBzdHJ1Y3QgcGFja193aW5kb3cgKip3X2N1cnMsCgkJCQkgICAgb2ZmX3QgY3VycG9zLAoJCQkJICAgIHVuc2lnbmVkIGxvbmcgc2l6ZSkKewoJaW50IHN0OwoJZ2l0X3pzdHJlYW0gc3RyZWFtOwoJdW5zaWduZWQgY2hhciAqYnVmZmVyLCAqaW47CgoJYnVmZmVyID0geG1hbGxvY3pfZ2VudGx5KHNpemUpOwoJaWYgKCFidWZmZXIpCgkJcmV0dXJuIE5VTEw7CgltZW1zZXQoJnN0cmVhbSwgMCwgc2l6ZW9mKHN0cmVhbSkpOwoJc3RyZWFtLm5leHRfb3V0ID0gYnVmZmVyOwoJc3RyZWFtLmF2YWlsX291dCA9IHNpemUgKyAxOwoKCWdpdF9pbmZsYXRlX2luaXQoJnN0cmVhbSk7CglkbyB7CgkJaW4gPSB1c2VfcGFjayhwLCB3X2N1cnMsIGN1cnBvcywgJnN0cmVhbS5hdmFpbF9pbik7CgkJc3RyZWFtLm5leHRfaW4gPSBpbjsKCQkvKgoJCSAqIE5vdGU6IHdlIG11c3QgZW5zdXJlIHRoZSB3aW5kb3cgc2VjdGlvbiByZXR1cm5lZCBieQoJCSAqIHVzZV9wYWNrKCkgd2lsbCBiZSBhdmFpbGFibGUgdGhyb3VnaG91dCBnaXRfaW5mbGF0ZSgpJ3MKCQkgKiB1bmxvY2tlZCBleGVjdXRpb24uIFBsZWFzZSByZWZlciB0byB0aGUgY29tbWVudCBhdAoJCSAqIGdldF9zaXplX2Zyb21fZGVsdGEoKSB0byBzZWUgaG93IHRoaXMgaXMgZG9uZS4KCQkgKi8KCQlvYmpfcmVhZF91bmxvY2soKTsKCQlzdCA9IGdpdF9pbmZsYXRlKCZzdHJlYW0sIFpfRklOSVNIKTsKCQlvYmpfcmVhZF9sb2NrKCk7CgkJaWYgKCFzdHJlYW0uYXZhaWxfb3V0KQoJCQlicmVhazsgLyogdGhlIHBheWxvYWQgaXMgbGFyZ2VyIHRoYW4gaXQgc2hvdWxkIGJlICovCgkJY3VycG9zICs9IHN0cmVhbS5uZXh0X2luIC0gaW47Cgl9IHdoaWxlIChzdCA9PSBaX09LIHx8IHN0ID09IFpfQlVGX0VSUk9SKTsKCWdpdF9pbmZsYXRlX2VuZCgmc3RyZWFtKTsKCWlmICgoc3QgIT0gWl9TVFJFQU1fRU5EKSB8fCBzdHJlYW0udG90YWxfb3V0ICE9IHNpemUpIHsKCQlmcmVlKGJ1ZmZlcik7CgkJcmV0dXJuIE5VTEw7Cgl9CgoJLyogdmVyc2lvbnMgb2YgemxpYiBjYW4gY2xvYmJlciB1bmNvbnN1bWVkIHBvcnRpb24gb2Ygb3V0YnVmICovCglidWZmZXJbc2l6ZV0gPSAnXDAnOwoKCXJldHVybiBidWZmZXI7Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX3BhY2tfYWNjZXNzX2xvZyhzdHJ1Y3QgcGFja2VkX2dpdCAqcCwgb2ZmX3Qgb2JqX29mZnNldCkKewoJc3RhdGljIHN0cnVjdCB0cmFjZV9rZXkgcGFja19hY2Nlc3MgPSBUUkFDRV9LRVlfSU5JVChQQUNLX0FDQ0VTUyk7Cgl0cmFjZV9wcmludGZfa2V5KCZwYWNrX2FjY2VzcywgIiVzICUiUFJJdU1BWCJcbiIsCgkJCSBwLT5wYWNrX25hbWUsICh1aW50bWF4X3Qpb2JqX29mZnNldCk7Cn0KCmludCBkb19jaGVja19wYWNrZWRfb2JqZWN0X2NyYzsKCiNkZWZpbmUgVU5QQUNLX0VOVFJZX1NUQUNLX1BSRUFMTE9DIDY0CnN0cnVjdCB1bnBhY2tfZW50cnlfc3RhY2tfZW50IHsKCW9mZl90IG9ial9vZmZzZXQ7CglvZmZfdCBjdXJwb3M7Cgl1bnNpZ25lZCBsb25nIHNpemU7Cn07Cgp2b2lkICp1bnBhY2tfZW50cnkoc3RydWN0IHJlcG9zaXRvcnkgKnIsIHN0cnVjdCBwYWNrZWRfZ2l0ICpwLCBvZmZfdCBvYmpfb2Zmc2V0LAoJCSAgIGVudW0gb2JqZWN0X3R5cGUgKmZpbmFsX3R5cGUsIHVuc2lnbmVkIGxvbmcgKmZpbmFsX3NpemUpCnsKCXN0cnVjdCBwYWNrX3dpbmRvdyAqd19jdXJzID0gTlVMTDsKCW9mZl90IGN1cnBvcyA9IG9ial9vZmZzZXQ7Cgl2b2lkICpkYXRhID0gTlVMTDsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCXN0cnVjdCB1bnBhY2tfZW50cnlfc3RhY2tfZW50IHNtYWxsX2RlbHRhX3N0YWNrW1VOUEFDS19FTlRSWV9TVEFDS19QUkVBTExPQ107CglzdHJ1Y3QgdW5wYWNrX2VudHJ5X3N0YWNrX2VudCAqZGVsdGFfc3RhY2sgPSBzbWFsbF9kZWx0YV9zdGFjazsKCWludCBkZWx0YV9zdGFja19uciA9IDAsIGRlbHRhX3N0YWNrX2FsbG9jID0gVU5QQUNLX0VOVFJZX1NUQUNLX1BSRUFMTE9DOwoJaW50IGJhc2VfZnJvbV9jYWNoZSA9IDA7CgoJd3JpdGVfcGFja19hY2Nlc3NfbG9nKHAsIG9ial9vZmZzZXQpOwoKCS8qIFBIQVNFIDE6IGRyaWxsIGRvd24gdG8gdGhlIGlubmVybW9zdCBiYXNlIG9iamVjdCAqLwoJZm9yICg7OykgewoJCW9mZl90IGJhc2Vfb2Zmc2V0OwoJCWludCBpOwoJCXN0cnVjdCBkZWx0YV9iYXNlX2NhY2hlX2VudHJ5ICplbnQ7CgoJCWVudCA9IGdldF9kZWx0YV9iYXNlX2NhY2hlX2VudHJ5KHAsIGN1cnBvcyk7CgkJaWYgKGVudCkgewoJCQl0eXBlID0gZW50LT50eXBlOwoJCQlkYXRhID0gZW50LT5kYXRhOwoJCQlzaXplID0gZW50LT5zaXplOwoJCQlkZXRhY2hfZGVsdGFfYmFzZV9jYWNoZV9lbnRyeShlbnQpOwoJCQliYXNlX2Zyb21fY2FjaGUgPSAxOwoJCQlicmVhazsKCQl9CgoJCWlmIChkb19jaGVja19wYWNrZWRfb2JqZWN0X2NyYyAmJiBwLT5pbmRleF92ZXJzaW9uID4gMSkgewoJCQl1aW50MzJfdCBwYWNrX3BvcywgaW5kZXhfcG9zOwoJCQlvZmZfdCBsZW47CgoJCQlpZiAob2Zmc2V0X3RvX3BhY2tfcG9zKHAsIG9ial9vZmZzZXQsICZwYWNrX3BvcykgPCAwKSB7CgkJCQllcnJvcigiY291bGQgbm90IGZpbmQgb2JqZWN0IGF0IG9mZnNldCAlIlBSSXVNQVgiIGluIHBhY2sgJXMiLAoJCQkJICAgICAgKHVpbnRtYXhfdClvYmpfb2Zmc2V0LCBwLT5wYWNrX25hbWUpOwoJCQkJZGF0YSA9IE5VTEw7CgkJCQlnb3RvIG91dDsKCQkJfQoKCQkJbGVuID0gcGFja19wb3NfdG9fb2Zmc2V0KHAsIHBhY2tfcG9zICsgMSkgLSBvYmpfb2Zmc2V0OwoJCQlpbmRleF9wb3MgPSBwYWNrX3Bvc190b19pbmRleChwLCBwYWNrX3Bvcyk7CgkJCWlmIChjaGVja19wYWNrX2NyYyhwLCAmd19jdXJzLCBvYmpfb2Zmc2V0LCBsZW4sIGluZGV4X3BvcykpIHsKCQkJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCQkJbnRoX3BhY2tlZF9vYmplY3RfaWQoJm9pZCwgcCwgaW5kZXhfcG9zKTsKCQkJCWVycm9yKCJiYWQgcGFja2VkIG9iamVjdCBDUkMgZm9yICVzIiwKCQkJCSAgICAgIG9pZF90b19oZXgoJm9pZCkpOwoJCQkJbWFya19iYWRfcGFja2VkX29iamVjdChwLCAmb2lkKTsKCQkJCWRhdGEgPSBOVUxMOwoJCQkJZ290byBvdXQ7CgkJCX0KCQl9CgoJCXR5cGUgPSB1bnBhY2tfb2JqZWN0X2hlYWRlcihwLCAmd19jdXJzLCAmY3VycG9zLCAmc2l6ZSk7CgkJaWYgKHR5cGUgIT0gT0JKX09GU19ERUxUQSAmJiB0eXBlICE9IE9CSl9SRUZfREVMVEEpCgkJCWJyZWFrOwoKCQliYXNlX29mZnNldCA9IGdldF9kZWx0YV9iYXNlKHAsICZ3X2N1cnMsICZjdXJwb3MsIHR5cGUsIG9ial9vZmZzZXQpOwoJCWlmICghYmFzZV9vZmZzZXQpIHsKCQkJZXJyb3IoImZhaWxlZCB0byB2YWxpZGF0ZSBkZWx0YSBiYXNlIHJlZmVyZW5jZSAiCgkJCSAgICAgICJhdCBvZmZzZXQgJSJQUkl1TUFYIiBmcm9tICVzIiwKCQkJICAgICAgKHVpbnRtYXhfdCljdXJwb3MsIHAtPnBhY2tfbmFtZSk7CgkJCS8qIGJhaWwgdG8gcGhhc2UgMiwgaW4gaG9wZXMgb2YgcmVjb3ZlcnkgKi8KCQkJZGF0YSA9IE5VTEw7CgkJCWJyZWFrOwoJCX0KCgkJLyogcHVzaCBvYmplY3QsIHByb2NlZWQgdG8gYmFzZSAqLwoJCWlmIChkZWx0YV9zdGFja19uciA+PSBkZWx0YV9zdGFja19hbGxvYwoJCSAgICAmJiBkZWx0YV9zdGFjayA9PSBzbWFsbF9kZWx0YV9zdGFjaykgewoJCQlkZWx0YV9zdGFja19hbGxvYyA9IGFsbG9jX25yKGRlbHRhX3N0YWNrX25yKTsKCQkJQUxMT0NfQVJSQVkoZGVsdGFfc3RhY2ssIGRlbHRhX3N0YWNrX2FsbG9jKTsKCQkJQ09QWV9BUlJBWShkZWx0YV9zdGFjaywgc21hbGxfZGVsdGFfc3RhY2ssCgkJCQkgICBkZWx0YV9zdGFja19ucik7CgkJfSBlbHNlIHsKCQkJQUxMT0NfR1JPVyhkZWx0YV9zdGFjaywgZGVsdGFfc3RhY2tfbnIrMSwgZGVsdGFfc3RhY2tfYWxsb2MpOwoJCX0KCQlpID0gZGVsdGFfc3RhY2tfbnIrKzsKCQlkZWx0YV9zdGFja1tpXS5vYmpfb2Zmc2V0ID0gb2JqX29mZnNldDsKCQlkZWx0YV9zdGFja1tpXS5jdXJwb3MgPSBjdXJwb3M7CgkJZGVsdGFfc3RhY2tbaV0uc2l6ZSA9IHNpemU7CgoJCWN1cnBvcyA9IG9ial9vZmZzZXQgPSBiYXNlX29mZnNldDsKCX0KCgkvKiBQSEFTRSAyOiBoYW5kbGUgdGhlIGJhc2UgKi8KCXN3aXRjaCAodHlwZSkgewoJY2FzZSBPQkpfT0ZTX0RFTFRBOgoJY2FzZSBPQkpfUkVGX0RFTFRBOgoJCWlmIChkYXRhKQoJCQlCVUcoInVucGFja19lbnRyeTogbGVmdCBsb29wIGF0IGEgdmFsaWQgZGVsdGEiKTsKCQlicmVhazsKCWNhc2UgT0JKX0NPTU1JVDoKCWNhc2UgT0JKX1RSRUU6CgljYXNlIE9CSl9CTE9COgoJY2FzZSBPQkpfVEFHOgoJCWlmICghYmFzZV9mcm9tX2NhY2hlKQoJCQlkYXRhID0gdW5wYWNrX2NvbXByZXNzZWRfZW50cnkocCwgJndfY3VycywgY3VycG9zLCBzaXplKTsKCQlicmVhazsKCWRlZmF1bHQ6CgkJZGF0YSA9IE5VTEw7CgkJZXJyb3IoInVua25vd24gb2JqZWN0IHR5cGUgJWkgYXQgb2Zmc2V0ICUiUFJJdU1BWCIgaW4gJXMiLAoJCSAgICAgIHR5cGUsICh1aW50bWF4X3Qpb2JqX29mZnNldCwgcC0+cGFja19uYW1lKTsKCX0KCgkvKiBQSEFTRSAzOiBhcHBseSBkZWx0YXMgaW4gb3JkZXIgKi8KCgkvKiBpbnZhcmlhbnRzOgoJICogICAnZGF0YScgaG9sZHMgdGhlIGJhc2UgZGF0YSwgb3IgTlVMTCBpZiB0aGVyZSB3YXMgY29ycnVwdGlvbgoJICovCgl3aGlsZSAoZGVsdGFfc3RhY2tfbnIpIHsKCQl2b2lkICpkZWx0YV9kYXRhOwoJCXZvaWQgKmJhc2UgPSBkYXRhOwoJCXZvaWQgKmV4dGVybmFsX2Jhc2UgPSBOVUxMOwoJCXVuc2lnbmVkIGxvbmcgZGVsdGFfc2l6ZSwgYmFzZV9zaXplID0gc2l6ZTsKCQlpbnQgaTsKCQlvZmZfdCBiYXNlX29ial9vZmZzZXQgPSBvYmpfb2Zmc2V0OwoKCQlkYXRhID0gTlVMTDsKCgkJaWYgKCFiYXNlKSB7CgkJCS8qCgkJCSAqIFdlJ3JlIHByb2JhYmx5IGluIGRlZXAgc2hpdCwgYnV0IGxldCdzIHRyeSB0byBmZXRjaAoJCQkgKiB0aGUgcmVxdWlyZWQgYmFzZSBhbnl3YXkgZnJvbSBhbm90aGVyIHBhY2sgb3IgbG9vc2UuCgkJCSAqIFRoaXMgaXMgY29zdGx5IGJ1dCBzaG91bGQgaGFwcGVuIG9ubHkgaW4gdGhlIHByZXNlbmNlCgkJCSAqIG9mIGEgY29ycnVwdGVkIHBhY2ssIGFuZCBpcyBiZXR0ZXIgdGhhbiBmYWlsaW5nIG91dHJpZ2h0LgoJCQkgKi8KCQkJdWludDMyX3QgcG9zOwoJCQlzdHJ1Y3Qgb2JqZWN0X2lkIGJhc2Vfb2lkOwoJCQlpZiAoIShvZmZzZXRfdG9fcGFja19wb3MocCwgb2JqX29mZnNldCwgJnBvcykpKSB7CgkJCQlzdHJ1Y3Qgb2JqZWN0X2luZm8gb2kgPSBPQkpFQ1RfSU5GT19JTklUOwoKCQkJCW50aF9wYWNrZWRfb2JqZWN0X2lkKCZiYXNlX29pZCwgcCwKCQkJCQkJICAgICBwYWNrX3Bvc190b19pbmRleChwLCBwb3MpKTsKCQkJCWVycm9yKCJmYWlsZWQgdG8gcmVhZCBkZWx0YSBiYXNlIG9iamVjdCAlcyIKCQkJCSAgICAgICIgYXQgb2Zmc2V0ICUiUFJJdU1BWCIgZnJvbSAlcyIsCgkJCQkgICAgICBvaWRfdG9faGV4KCZiYXNlX29pZCksICh1aW50bWF4X3Qpb2JqX29mZnNldCwKCQkJCSAgICAgIHAtPnBhY2tfbmFtZSk7CgkJCQltYXJrX2JhZF9wYWNrZWRfb2JqZWN0KHAsICZiYXNlX29pZCk7CgoJCQkJb2kudHlwZXAgPSAmdHlwZTsKCQkJCW9pLnNpemVwID0gJmJhc2Vfc2l6ZTsKCQkJCW9pLmNvbnRlbnRwID0gJmJhc2U7CgkJCQlpZiAob2lkX29iamVjdF9pbmZvX2V4dGVuZGVkKHIsICZiYXNlX29pZCwgJm9pLCAwKSA8IDApCgkJCQkJYmFzZSA9IE5VTEw7CgoJCQkJZXh0ZXJuYWxfYmFzZSA9IGJhc2U7CgkJCX0KCQl9CgoJCWkgPSAtLWRlbHRhX3N0YWNrX25yOwoJCW9ial9vZmZzZXQgPSBkZWx0YV9zdGFja1tpXS5vYmpfb2Zmc2V0OwoJCWN1cnBvcyA9IGRlbHRhX3N0YWNrW2ldLmN1cnBvczsKCQlkZWx0YV9zaXplID0gZGVsdGFfc3RhY2tbaV0uc2l6ZTsKCgkJaWYgKCFiYXNlKQoJCQljb250aW51ZTsKCgkJZGVsdGFfZGF0YSA9IHVucGFja19jb21wcmVzc2VkX2VudHJ5KHAsICZ3X2N1cnMsIGN1cnBvcywgZGVsdGFfc2l6ZSk7CgoJCWlmICghZGVsdGFfZGF0YSkgewoJCQllcnJvcigiZmFpbGVkIHRvIHVucGFjayBjb21wcmVzc2VkIGRlbHRhICIKCQkJICAgICAgImF0IG9mZnNldCAlIlBSSXVNQVgiIGZyb20gJXMiLAoJCQkgICAgICAodWludG1heF90KWN1cnBvcywgcC0+cGFja19uYW1lKTsKCQkJZGF0YSA9IE5VTEw7CgkJfSBlbHNlIHsKCQkJZGF0YSA9IHBhdGNoX2RlbHRhKGJhc2UsIGJhc2Vfc2l6ZSwgZGVsdGFfZGF0YSwKCQkJCQkgICBkZWx0YV9zaXplLCAmc2l6ZSk7CgoJCQkvKgoJCQkgKiBXZSBjb3VsZCBub3QgYXBwbHkgdGhlIGRlbHRhOyB3YXJuIHRoZSB1c2VyLCBidXQKCQkJICoga2VlcCBnb2luZy4gT3VyIGZhaWx1cmUgd2lsbCBiZSBub3RpY2VkIGVpdGhlciBpbgoJCQkgKiB0aGUgbmV4dCBpdGVyYXRpb24gb2YgdGhlIGxvb3AsIG9yIGlmIHRoaXMgaXMgdGhlCgkJCSAqIGZpbmFsIGRlbHRhLCBpbiB0aGUgY2FsbGVyIHdoZW4gd2UgcmV0dXJuIE5VTEwuCgkJCSAqIFRob3NlIGNvZGUgcGF0aHMgd2lsbCB0YWtlIGNhcmUgb2YgbWFraW5nIGEgbW9yZQoJCQkgKiBleHBsaWNpdCB3YXJuaW5nIGFuZCByZXRyeWluZyB3aXRoIGFub3RoZXIgY29weSBvZgoJCQkgKiB0aGUgb2JqZWN0LgoJCQkgKi8KCQkJaWYgKCFkYXRhKQoJCQkJZXJyb3IoImZhaWxlZCB0byBhcHBseSBkZWx0YSIpOwoJCX0KCgkJLyoKCQkgKiBXZSBkZWxheSBhZGRpbmcgYGJhc2VgIHRvIHRoZSBjYWNoZSB1bnRpbCB0aGUgZW5kIG9mIHRoZSBsb29wCgkJICogYmVjYXVzZSB1bnBhY2tfY29tcHJlc3NlZF9lbnRyeSgpIG1vbWVudGFyaWx5IHJlbGVhc2VzIHRoZQoJCSAqIG9ial9yZWFkX211dGV4LCBnaXZpbmcgYW5vdGhlciB0aHJlYWQgdGhlIGNoYW5jZSB0byBhY2Nlc3MKCQkgKiB0aGUgY2FjaGUuIFRoZXJlZm9yZSwgaWYgYGJhc2VgIHdhcyBhbHJlYWR5IHRoZXJlLCB0aGlzIG90aGVyCgkJICogdGhyZWFkIGNvdWxkIGZyZWUoKSBpdCAoZS5nLiB0byBtYWtlIHNwYWNlIGZvciBhbm90aGVyIGVudHJ5KQoJCSAqIGJlZm9yZSB3ZSBhcmUgZG9uZSB1c2luZyBpdC4KCQkgKi8KCQlpZiAoIWV4dGVybmFsX2Jhc2UpCgkJCWFkZF9kZWx0YV9iYXNlX2NhY2hlKHAsIGJhc2Vfb2JqX29mZnNldCwgYmFzZSwgYmFzZV9zaXplLCB0eXBlKTsKCgkJZnJlZShkZWx0YV9kYXRhKTsKCQlmcmVlKGV4dGVybmFsX2Jhc2UpOwoJfQoKCWlmIChmaW5hbF90eXBlKQoJCSpmaW5hbF90eXBlID0gdHlwZTsKCWlmIChmaW5hbF9zaXplKQoJCSpmaW5hbF9zaXplID0gc2l6ZTsKCm91dDoKCXVudXNlX3BhY2soJndfY3Vycyk7CgoJaWYgKGRlbHRhX3N0YWNrICE9IHNtYWxsX2RlbHRhX3N0YWNrKQoJCWZyZWUoZGVsdGFfc3RhY2spOwoKCXJldHVybiBkYXRhOwp9CgppbnQgYnNlYXJjaF9wYWNrKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgY29uc3Qgc3RydWN0IHBhY2tlZF9naXQgKnAsIHVpbnQzMl90ICpyZXN1bHQpCnsKCWNvbnN0IHVuc2lnbmVkIGNoYXIgKmluZGV4X2Zhbm91dCA9IHAtPmluZGV4X2RhdGE7Cgljb25zdCB1bnNpZ25lZCBjaGFyICppbmRleF9sb29rdXA7Cgljb25zdCB1bnNpZ25lZCBpbnQgaGFzaHN6ID0gdGhlX2hhc2hfYWxnby0+cmF3c3o7CglpbnQgaW5kZXhfbG9va3VwX3dpZHRoOwoKCWlmICghaW5kZXhfZmFub3V0KQoJCUJVRygiYnNlYXJjaF9wYWNrIGNhbGxlZCB3aXRob3V0IGEgdmFsaWQgcGFjay1pbmRleCIpOwoKCWluZGV4X2xvb2t1cCA9IGluZGV4X2Zhbm91dCArIDQgKiAyNTY7CglpZiAocC0+aW5kZXhfdmVyc2lvbiA9PSAxKSB7CgkJaW5kZXhfbG9va3VwX3dpZHRoID0gaGFzaHN6ICsgNDsKCQlpbmRleF9sb29rdXAgKz0gNDsKCX0gZWxzZSB7CgkJaW5kZXhfbG9va3VwX3dpZHRoID0gaGFzaHN6OwoJCWluZGV4X2Zhbm91dCArPSA4OwoJCWluZGV4X2xvb2t1cCArPSA4OwoJfQoKCXJldHVybiBic2VhcmNoX2hhc2gob2lkLT5oYXNoLCAoY29uc3QgdWludDMyX3QqKWluZGV4X2Zhbm91dCwKCQkJICAgIGluZGV4X2xvb2t1cCwgaW5kZXhfbG9va3VwX3dpZHRoLCByZXN1bHQpOwp9CgppbnQgbnRoX3BhY2tlZF9vYmplY3RfaWQoc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgc3RydWN0IHBhY2tlZF9naXQgKnAsCgkJCSB1aW50MzJfdCBuKQp7Cgljb25zdCB1bnNpZ25lZCBjaGFyICppbmRleCA9IHAtPmluZGV4X2RhdGE7Cgljb25zdCB1bnNpZ25lZCBpbnQgaGFzaHN6ID0gdGhlX2hhc2hfYWxnby0+cmF3c3o7CglpZiAoIWluZGV4KSB7CgkJaWYgKG9wZW5fcGFja19pbmRleChwKSkKCQkJcmV0dXJuIC0xOwoJCWluZGV4ID0gcC0+aW5kZXhfZGF0YTsKCX0KCWlmIChuID49IHAtPm51bV9vYmplY3RzKQoJCXJldHVybiAtMTsKCWluZGV4ICs9IDQgKiAyNTY7CglpZiAocC0+aW5kZXhfdmVyc2lvbiA9PSAxKSB7CgkJb2lkcmVhZChvaWQsIGluZGV4ICsgc3RfYWRkKHN0X211bHQoaGFzaHN6ICsgNCwgbiksIDQpLAoJCQl0aGVfcmVwb3NpdG9yeS0+aGFzaF9hbGdvKTsKCX0gZWxzZSB7CgkJaW5kZXggKz0gODsKCQlvaWRyZWFkKG9pZCwgaW5kZXggKyBzdF9tdWx0KGhhc2hzeiwgbiksCgkJCXRoZV9yZXBvc2l0b3J5LT5oYXNoX2FsZ28pOwoJfQoJcmV0dXJuIDA7Cn0KCnZvaWQgY2hlY2tfcGFja19pbmRleF9wdHIoY29uc3Qgc3RydWN0IHBhY2tlZF9naXQgKnAsIGNvbnN0IHZvaWQgKnZwdHIpCnsKCWNvbnN0IHVuc2lnbmVkIGNoYXIgKnB0ciA9IHZwdHI7Cgljb25zdCB1bnNpZ25lZCBjaGFyICpzdGFydCA9IHAtPmluZGV4X2RhdGE7Cgljb25zdCB1bnNpZ25lZCBjaGFyICplbmQgPSBzdGFydCArIHAtPmluZGV4X3NpemU7CglpZiAocHRyIDwgc3RhcnQpCgkJZGllKF8oIm9mZnNldCBiZWZvcmUgc3RhcnQgb2YgcGFjayBpbmRleCBmb3IgJXMgKGNvcnJ1cHQgaW5kZXg/KSIpLAoJCSAgICBwLT5wYWNrX25hbWUpOwoJLyogTm8gbmVlZCB0byBjaGVjayBmb3IgdW5kZXJmbG93OyAuaWR4IGZpbGVzIG11c3QgYmUgYXQgbGVhc3QgOCBieXRlcyAqLwoJaWYgKHB0ciA+PSBlbmQgLSA4KQoJCWRpZShfKCJvZmZzZXQgYmV5b25kIGVuZCBvZiBwYWNrIGluZGV4IGZvciAlcyAodHJ1bmNhdGVkIGluZGV4PykiKSwKCQkgICAgcC0+cGFja19uYW1lKTsKfQoKb2ZmX3QgbnRoX3BhY2tlZF9vYmplY3Rfb2Zmc2V0KGNvbnN0IHN0cnVjdCBwYWNrZWRfZ2l0ICpwLCB1aW50MzJfdCBuKQp7Cgljb25zdCB1bnNpZ25lZCBjaGFyICppbmRleCA9IHAtPmluZGV4X2RhdGE7Cgljb25zdCB1bnNpZ25lZCBpbnQgaGFzaHN6ID0gdGhlX2hhc2hfYWxnby0+cmF3c3o7CglpbmRleCArPSA0ICogMjU2OwoJaWYgKHAtPmluZGV4X3ZlcnNpb24gPT0gMSkgewoJCXJldHVybiBudG9obCgqKCh1aW50MzJfdCAqKShpbmRleCArIHN0X211bHQoaGFzaHN6ICsgNCwgbikpKSk7Cgl9IGVsc2UgewoJCXVpbnQzMl90IG9mZjsKCQlpbmRleCArPSBzdF9hZGQoOCwgc3RfbXVsdChwLT5udW1fb2JqZWN0cywgaGFzaHN6ICsgNCkpOwoJCW9mZiA9IG50b2hsKCooKHVpbnQzMl90ICopKGluZGV4ICsgc3RfbXVsdCg0LCBuKSkpKTsKCQlpZiAoIShvZmYgJiAweDgwMDAwMDAwKSkKCQkJcmV0dXJuIG9mZjsKCQlpbmRleCArPSBzdF9hZGQoc3RfbXVsdChwLT5udW1fb2JqZWN0cywgNCksCgkJCQlzdF9tdWx0KG9mZiAmIDB4N2ZmZmZmZmYsIDgpKTsKCQljaGVja19wYWNrX2luZGV4X3B0cihwLCBpbmRleCk7CgkJcmV0dXJuIGdldF9iZTY0KGluZGV4KTsKCX0KfQoKb2ZmX3QgZmluZF9wYWNrX2VudHJ5X29uZShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCSAgc3RydWN0IHBhY2tlZF9naXQgKnApCnsKCWNvbnN0IHVuc2lnbmVkIGNoYXIgKmluZGV4ID0gcC0+aW5kZXhfZGF0YTsKCXVpbnQzMl90IHJlc3VsdDsKCglpZiAoIWluZGV4KSB7CgkJaWYgKG9wZW5fcGFja19pbmRleChwKSkKCQkJcmV0dXJuIDA7Cgl9CgoJaWYgKGJzZWFyY2hfcGFjayhvaWQsIHAsICZyZXN1bHQpKQoJCXJldHVybiBudGhfcGFja2VkX29iamVjdF9vZmZzZXQocCwgcmVzdWx0KTsKCXJldHVybiAwOwp9CgppbnQgaXNfcGFja192YWxpZChzdHJ1Y3QgcGFja2VkX2dpdCAqcCkKewoJLyogQW4gYWxyZWFkeSBvcGVuIHBhY2sgaXMga25vd24gdG8gYmUgdmFsaWQuICovCglpZiAocC0+cGFja19mZCAhPSAtMSkKCQlyZXR1cm4gMTsKCgkvKiBJZiB0aGUgcGFjayBoYXMgb25lIHdpbmRvdyBjb21wbGV0ZWx5IGNvdmVyaW5nIHRoZQoJICogZmlsZSBzaXplLCB0aGUgcGFjayBpcyBrbm93biB0byBiZSB2YWxpZCBldmVuIGlmCgkgKiB0aGUgZGVzY3JpcHRvciBpcyBub3QgY3VycmVudGx5IG9wZW4uCgkgKi8KCWlmIChwLT53aW5kb3dzKSB7CgkJc3RydWN0IHBhY2tfd2luZG93ICp3ID0gcC0+d2luZG93czsKCgkJaWYgKCF3LT5vZmZzZXQgJiYgdy0+bGVuID09IHAtPnBhY2tfc2l6ZSkKCQkJcmV0dXJuIDE7Cgl9CgoJLyogRm9yY2UgdGhlIHBhY2sgdG8gb3BlbiB0byBwcm92ZSBpdHMgdmFsaWQuICovCglyZXR1cm4gIW9wZW5fcGFja2VkX2dpdChwKTsKfQoKc3RydWN0IHBhY2tlZF9naXQgKmZpbmRfb2lkX3BhY2soY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkJIHN0cnVjdCBwYWNrZWRfZ2l0ICpwYWNrcykKewoJc3RydWN0IHBhY2tlZF9naXQgKnA7CgoJZm9yIChwID0gcGFja3M7IHA7IHAgPSBwLT5uZXh0KSB7CgkJaWYgKGZpbmRfcGFja19lbnRyeV9vbmUob2lkLCBwKSkKCQkJcmV0dXJuIHA7Cgl9CglyZXR1cm4gTlVMTDsKCn0KCnN0YXRpYyBpbnQgZmlsbF9wYWNrX2VudHJ5KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJICAgc3RydWN0IHBhY2tfZW50cnkgKmUsCgkJCSAgIHN0cnVjdCBwYWNrZWRfZ2l0ICpwKQp7CglvZmZfdCBvZmZzZXQ7CgoJaWYgKG9pZHNldF9zaXplKCZwLT5iYWRfb2JqZWN0cykgJiYKCSAgICBvaWRzZXRfY29udGFpbnMoJnAtPmJhZF9vYmplY3RzLCBvaWQpKQoJCXJldHVybiAwOwoKCW9mZnNldCA9IGZpbmRfcGFja19lbnRyeV9vbmUob2lkLCBwKTsKCWlmICghb2Zmc2V0KQoJCXJldHVybiAwOwoKCS8qCgkgKiBXZSBhcmUgYWJvdXQgdG8gdGVsbCB0aGUgY2FsbGVyIHdoZXJlIHRoZXkgY2FuIGxvY2F0ZSB0aGUKCSAqIHJlcXVlc3RlZCBvYmplY3QuICBXZSBiZXR0ZXIgbWFrZSBzdXJlIHRoZSBwYWNrZmlsZSBpcwoJICogc3RpbGwgaGVyZSBhbmQgY2FuIGJlIGFjY2Vzc2VkIGJlZm9yZSBzdXBwbHlpbmcgdGhhdAoJICogYW5zd2VyLCBhcyBpdCBtYXkgaGF2ZSBiZWVuIGRlbGV0ZWQgc2luY2UgdGhlIGluZGV4IHdhcwoJICogbG9hZGVkIQoJICovCglpZiAoIWlzX3BhY2tfdmFsaWQocCkpCgkJcmV0dXJuIDA7CgllLT5vZmZzZXQgPSBvZmZzZXQ7CgllLT5wID0gcDsKCXJldHVybiAxOwp9CgppbnQgZmluZF9wYWNrX2VudHJ5KHN0cnVjdCByZXBvc2l0b3J5ICpyLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIHN0cnVjdCBwYWNrX2VudHJ5ICplKQp7CglzdHJ1Y3QgbGlzdF9oZWFkICpwb3M7CglzdHJ1Y3QgbXVsdGlfcGFja19pbmRleCAqbTsKCglwcmVwYXJlX3BhY2tlZF9naXQocik7CglpZiAoIXItPm9iamVjdHMtPnBhY2tlZF9naXQgJiYgIXItPm9iamVjdHMtPm11bHRpX3BhY2tfaW5kZXgpCgkJcmV0dXJuIDA7CgoJZm9yIChtID0gci0+b2JqZWN0cy0+bXVsdGlfcGFja19pbmRleDsgbTsgbSA9IG0tPm5leHQpIHsKCQlpZiAoZmlsbF9taWR4X2VudHJ5KHIsIG9pZCwgZSwgbSkpCgkJCXJldHVybiAxOwoJfQoKCWxpc3RfZm9yX2VhY2gocG9zLCAmci0+b2JqZWN0cy0+cGFja2VkX2dpdF9tcnUpIHsKCQlzdHJ1Y3QgcGFja2VkX2dpdCAqcCA9IGxpc3RfZW50cnkocG9zLCBzdHJ1Y3QgcGFja2VkX2dpdCwgbXJ1KTsKCQlpZiAoIXAtPm11bHRpX3BhY2tfaW5kZXggJiYgZmlsbF9wYWNrX2VudHJ5KG9pZCwgZSwgcCkpIHsKCQkJbGlzdF9tb3ZlKCZwLT5tcnUsICZyLT5vYmplY3RzLT5wYWNrZWRfZ2l0X21ydSk7CgkJCXJldHVybiAxOwoJCX0KCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBtYXliZV9pbnZhbGlkYXRlX2tlcHRfcGFja19jYWNoZShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJCQkgICAgIHVuc2lnbmVkIGZsYWdzKQp7CglpZiAoIXItPm9iamVjdHMtPmtlcHRfcGFja19jYWNoZS5wYWNrcykKCQlyZXR1cm47CglpZiAoci0+b2JqZWN0cy0+a2VwdF9wYWNrX2NhY2hlLmZsYWdzID09IGZsYWdzKQoJCXJldHVybjsKCUZSRUVfQU5EX05VTEwoci0+b2JqZWN0cy0+a2VwdF9wYWNrX2NhY2hlLnBhY2tzKTsKCXItPm9iamVjdHMtPmtlcHRfcGFja19jYWNoZS5mbGFncyA9IDA7Cn0KCnN0YXRpYyBzdHJ1Y3QgcGFja2VkX2dpdCAqKmtlcHRfcGFja19jYWNoZShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgdW5zaWduZWQgZmxhZ3MpCnsKCW1heWJlX2ludmFsaWRhdGVfa2VwdF9wYWNrX2NhY2hlKHIsIGZsYWdzKTsKCglpZiAoIXItPm9iamVjdHMtPmtlcHRfcGFja19jYWNoZS5wYWNrcykgewoJCXN0cnVjdCBwYWNrZWRfZ2l0ICoqcGFja3MgPSBOVUxMOwoJCXNpemVfdCBuciA9IDAsIGFsbG9jID0gMDsKCQlzdHJ1Y3QgcGFja2VkX2dpdCAqcDsKCgkJLyoKCQkgKiBXZSB3YW50ICJhbGwiIHBhY2tzIGhlcmUsIGJlY2F1c2Ugd2UgbmVlZCB0byBjb3ZlciBvbmVzIHRoYXQKCQkgKiBhcmUgdXNlZCBieSBhIG1pZHgsIGFzIHdlbGwuIFdlIG5lZWQgdG8gbG9vayBpbiBldmVyeSBvbmUgb2YKCQkgKiB0aGVtIChpbnN0ZWFkIG9mIHRoZSBtaWR4IGl0c2VsZikgdG8gY292ZXIgZHVwbGljYXRlcy4gSXQncwoJCSAqIHBvc3NpYmxlIHRoYXQgYW4gb2JqZWN0IGlzIGZvdW5kIGluIHR3byBwYWNrcyB0aGF0IHRoZSBtaWR4CgkJICogY292ZXJzLCBvbmUga2VwdCBhbmQgb25lIG5vdCBrZXB0LCBidXQgdGhlIG1pZHggcmV0dXJucyBvbmx5CgkJICogdGhlIG5vbi1rZXB0IHZlcnNpb24uCgkJICovCgkJZm9yIChwID0gZ2V0X2FsbF9wYWNrcyhyKTsgcDsgcCA9IHAtPm5leHQpIHsKCQkJaWYgKChwLT5wYWNrX2tlZXAgJiYgKGZsYWdzICYgT05fRElTS19LRUVQX1BBQ0tTKSkgfHwKCQkJICAgIChwLT5wYWNrX2tlZXBfaW5fY29yZSAmJiAoZmxhZ3MgJiBJTl9DT1JFX0tFRVBfUEFDS1MpKSkgewoJCQkJQUxMT0NfR1JPVyhwYWNrcywgbnIgKyAxLCBhbGxvYyk7CgkJCQlwYWNrc1tucisrXSA9IHA7CgkJCX0KCQl9CgkJQUxMT0NfR1JPVyhwYWNrcywgbnIgKyAxLCBhbGxvYyk7CgkJcGFja3NbbnJdID0gTlVMTDsKCgkJci0+b2JqZWN0cy0+a2VwdF9wYWNrX2NhY2hlLnBhY2tzID0gcGFja3M7CgkJci0+b2JqZWN0cy0+a2VwdF9wYWNrX2NhY2hlLmZsYWdzID0gZmxhZ3M7Cgl9CgoJcmV0dXJuIHItPm9iamVjdHMtPmtlcHRfcGFja19jYWNoZS5wYWNrczsKfQoKaW50IGZpbmRfa2VwdF9wYWNrX2VudHJ5KHN0cnVjdCByZXBvc2l0b3J5ICpyLAoJCQkgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgdW5zaWduZWQgZmxhZ3MsCgkJCSBzdHJ1Y3QgcGFja19lbnRyeSAqZSkKewoJc3RydWN0IHBhY2tlZF9naXQgKipjYWNoZTsKCglmb3IgKGNhY2hlID0ga2VwdF9wYWNrX2NhY2hlKHIsIGZsYWdzKTsgKmNhY2hlOyBjYWNoZSsrKSB7CgkJc3RydWN0IHBhY2tlZF9naXQgKnAgPSAqY2FjaGU7CgkJaWYgKGZpbGxfcGFja19lbnRyeShvaWQsIGUsIHApKQoJCQlyZXR1cm4gMTsKCX0KCglyZXR1cm4gMDsKfQoKaW50IGhhc19vYmplY3RfcGFjayhjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXN0cnVjdCBwYWNrX2VudHJ5IGU7CglyZXR1cm4gZmluZF9wYWNrX2VudHJ5KHRoZV9yZXBvc2l0b3J5LCBvaWQsICZlKTsKfQoKaW50IGhhc19vYmplY3Rfa2VwdF9wYWNrKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgdW5zaWduZWQgZmxhZ3MpCnsKCXN0cnVjdCBwYWNrX2VudHJ5IGU7CglyZXR1cm4gZmluZF9rZXB0X3BhY2tfZW50cnkodGhlX3JlcG9zaXRvcnksIG9pZCwgZmxhZ3MsICZlKTsKfQoKaW50IGZvcl9lYWNoX29iamVjdF9pbl9wYWNrKHN0cnVjdCBwYWNrZWRfZ2l0ICpwLAoJCQkgICAgZWFjaF9wYWNrZWRfb2JqZWN0X2ZuIGNiLCB2b2lkICpkYXRhLAoJCQkgICAgZW51bSBmb3JfZWFjaF9vYmplY3RfZmxhZ3MgZmxhZ3MpCnsKCXVpbnQzMl90IGk7CglpbnQgciA9IDA7CgoJaWYgKGZsYWdzICYgRk9SX0VBQ0hfT0JKRUNUX1BBQ0tfT1JERVIpIHsKCQlpZiAobG9hZF9wYWNrX3JldmluZGV4KHRoZV9yZXBvc2l0b3J5LCBwKSkKCQkJcmV0dXJuIC0xOwoJfQoKCWZvciAoaSA9IDA7IGkgPCBwLT5udW1fb2JqZWN0czsgaSsrKSB7CgkJdWludDMyX3QgaW5kZXhfcG9zOwoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoKCQkvKgoJCSAqIFdlIGFyZSBpdGVyYXRpbmcgImkiIGZyb20gMCB1cCB0byBudW1fb2JqZWN0cywgYnV0IGl0cwoJCSAqIG1lYW5pbmcgbWF5IGJlIGRpZmZlcmVudCwgZGVwZW5kaW5nIG9uIHRoZSByZXF1ZXN0ZWQgb3V0cHV0CgkJICogb3JkZXI6CgkJICoKCQkgKiAgIC0gaW4gb2JqZWN0LW5hbWUgb3JkZXIsIGl0IGlzIHRoZSBzYW1lIGFzIHRoZSBpbmRleCBvcmRlcgoJCSAqICAgICB1c2VkIGJ5IG50aF9wYWNrZWRfb2JqZWN0X2lkKCksIHNvIHdlIGNhbiBwYXNzIGl0CgkJICogICAgIGRpcmVjdGx5CgkJICoKCQkgKiAgIC0gaW4gcGFjay1vcmRlciwgaXQgaXMgcGFjayBwb3NpdGlvbiwgd2hpY2ggd2UgbXVzdAoJCSAqICAgICBjb252ZXJ0IHRvIGFuIGluZGV4IHBvc2l0aW9uIGluIG9yZGVyIHRvIGdldCB0aGUgb2lkLgoJCSAqLwoJCWlmIChmbGFncyAmIEZPUl9FQUNIX09CSkVDVF9QQUNLX09SREVSKQoJCQlpbmRleF9wb3MgPSBwYWNrX3Bvc190b19pbmRleChwLCBpKTsKCQllbHNlCgkJCWluZGV4X3BvcyA9IGk7CgoJCWlmIChudGhfcGFja2VkX29iamVjdF9pZCgmb2lkLCBwLCBpbmRleF9wb3MpIDwgMCkKCQkJcmV0dXJuIGVycm9yKCJ1bmFibGUgdG8gZ2V0IHNoYTEgb2Ygb2JqZWN0ICV1IGluICVzIiwKCQkJCSAgICAgaW5kZXhfcG9zLCBwLT5wYWNrX25hbWUpOwoKCQlyID0gY2IoJm9pZCwgcCwgaW5kZXhfcG9zLCBkYXRhKTsKCQlpZiAocikKCQkJYnJlYWs7Cgl9CglyZXR1cm4gcjsKfQoKaW50IGZvcl9lYWNoX3BhY2tlZF9vYmplY3QoZWFjaF9wYWNrZWRfb2JqZWN0X2ZuIGNiLCB2b2lkICpkYXRhLAoJCQkgICBlbnVtIGZvcl9lYWNoX29iamVjdF9mbGFncyBmbGFncykKewoJc3RydWN0IHBhY2tlZF9naXQgKnA7CglpbnQgciA9IDA7CglpbnQgcGFja19lcnJvcnMgPSAwOwoKCXByZXBhcmVfcGFja2VkX2dpdCh0aGVfcmVwb3NpdG9yeSk7Cglmb3IgKHAgPSBnZXRfYWxsX3BhY2tzKHRoZV9yZXBvc2l0b3J5KTsgcDsgcCA9IHAtPm5leHQpIHsKCQlpZiAoKGZsYWdzICYgRk9SX0VBQ0hfT0JKRUNUX0xPQ0FMX09OTFkpICYmICFwLT5wYWNrX2xvY2FsKQoJCQljb250aW51ZTsKCQlpZiAoKGZsYWdzICYgRk9SX0VBQ0hfT0JKRUNUX1BST01JU09SX09OTFkpICYmCgkJICAgICFwLT5wYWNrX3Byb21pc29yKQoJCQljb250aW51ZTsKCQlpZiAoKGZsYWdzICYgRk9SX0VBQ0hfT0JKRUNUX1NLSVBfSU5fQ09SRV9LRVBUX1BBQ0tTKSAmJgoJCSAgICBwLT5wYWNrX2tlZXBfaW5fY29yZSkKCQkJY29udGludWU7CgkJaWYgKChmbGFncyAmIEZPUl9FQUNIX09CSkVDVF9TS0lQX09OX0RJU0tfS0VQVF9QQUNLUykgJiYKCQkgICAgcC0+cGFja19rZWVwKQoJCQljb250aW51ZTsKCQlpZiAob3Blbl9wYWNrX2luZGV4KHApKSB7CgkJCXBhY2tfZXJyb3JzID0gMTsKCQkJY29udGludWU7CgkJfQoJCXIgPSBmb3JfZWFjaF9vYmplY3RfaW5fcGFjayhwLCBjYiwgZGF0YSwgZmxhZ3MpOwoJCWlmIChyKQoJCQlicmVhazsKCX0KCXJldHVybiByID8gciA6IHBhY2tfZXJyb3JzOwp9CgpzdGF0aWMgaW50IGFkZF9wcm9taXNvcl9vYmplY3QoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgICAgICAgc3RydWN0IHBhY2tlZF9naXQgKnBhY2sgVU5VU0VELAoJCQkgICAgICAgdWludDMyX3QgcG9zIFVOVVNFRCwKCQkJICAgICAgIHZvaWQgKnNldF8pCnsKCXN0cnVjdCBvaWRzZXQgKnNldCA9IHNldF87CglzdHJ1Y3Qgb2JqZWN0ICpvYmo7CglpbnQgd2VfcGFyc2VkX29iamVjdDsKCglvYmogPSBsb29rdXBfb2JqZWN0KHRoZV9yZXBvc2l0b3J5LCBvaWQpOwoJaWYgKG9iaiAmJiBvYmotPnBhcnNlZCkgewoJCXdlX3BhcnNlZF9vYmplY3QgPSAwOwoJfSBlbHNlIHsKCQl3ZV9wYXJzZWRfb2JqZWN0ID0gMTsKCQlvYmogPSBwYXJzZV9vYmplY3QodGhlX3JlcG9zaXRvcnksIG9pZCk7Cgl9CgoJaWYgKCFvYmopCgkJcmV0dXJuIDE7CgoJb2lkc2V0X2luc2VydChzZXQsIG9pZCk7CgoJLyoKCSAqIElmIHRoaXMgaXMgYSB0cmVlLCBjb21taXQsIG9yIHRhZywgdGhlIG9iamVjdHMgaXQgcmVmZXJzCgkgKiB0byBhcmUgYWxzbyBwcm9taXNvciBvYmplY3RzLiAoQmxvYnMgcmVmZXIgdG8gbm8gb2JqZWN0cy0+KQoJICovCglpZiAob2JqLT50eXBlID09IE9CSl9UUkVFKSB7CgkJc3RydWN0IHRyZWUgKnRyZWUgPSAoc3RydWN0IHRyZWUgKilvYmo7CgkJc3RydWN0IHRyZWVfZGVzYyBkZXNjOwoJCXN0cnVjdCBuYW1lX2VudHJ5IGVudHJ5OwoJCWlmIChpbml0X3RyZWVfZGVzY19nZW50bHkoJmRlc2MsICZ0cmVlLT5vYmplY3Qub2lkLAoJCQkJCSAgdHJlZS0+YnVmZmVyLCB0cmVlLT5zaXplLCAwKSkKCQkJLyoKCQkJICogRXJyb3IgbWVzc2FnZXMgYXJlIGdpdmVuIHdoZW4gcGFja3MgYXJlCgkJCSAqIHZlcmlmaWVkLCBzbyBkbyBub3QgcHJpbnQgYW55IGhlcmUuCgkJCSAqLwoJCQlyZXR1cm4gMDsKCQl3aGlsZSAodHJlZV9lbnRyeV9nZW50bHkoJmRlc2MsICZlbnRyeSkpCgkJCW9pZHNldF9pbnNlcnQoc2V0LCAmZW50cnkub2lkKTsKCQlpZiAod2VfcGFyc2VkX29iamVjdCkKCQkJZnJlZV90cmVlX2J1ZmZlcih0cmVlKTsKCX0gZWxzZSBpZiAob2JqLT50eXBlID09IE9CSl9DT01NSVQpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSAoc3RydWN0IGNvbW1pdCAqKSBvYmo7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzID0gY29tbWl0LT5wYXJlbnRzOwoKCQlvaWRzZXRfaW5zZXJ0KHNldCwgZ2V0X2NvbW1pdF90cmVlX29pZChjb21taXQpKTsKCQlmb3IgKDsgcGFyZW50czsgcGFyZW50cyA9IHBhcmVudHMtPm5leHQpCgkJCW9pZHNldF9pbnNlcnQoc2V0LCAmcGFyZW50cy0+aXRlbS0+b2JqZWN0Lm9pZCk7Cgl9IGVsc2UgaWYgKG9iai0+dHlwZSA9PSBPQkpfVEFHKSB7CgkJc3RydWN0IHRhZyAqdGFnID0gKHN0cnVjdCB0YWcgKikgb2JqOwoJCW9pZHNldF9pbnNlcnQoc2V0LCBnZXRfdGFnZ2VkX29pZCh0YWcpKTsKCX0KCXJldHVybiAwOwp9CgppbnQgaXNfcHJvbWlzb3Jfb2JqZWN0KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJc3RhdGljIHN0cnVjdCBvaWRzZXQgcHJvbWlzb3Jfb2JqZWN0czsKCXN0YXRpYyBpbnQgcHJvbWlzb3Jfb2JqZWN0c19wcmVwYXJlZDsKCglpZiAoIXByb21pc29yX29iamVjdHNfcHJlcGFyZWQpIHsKCQlpZiAocmVwb19oYXNfcHJvbWlzb3JfcmVtb3RlKHRoZV9yZXBvc2l0b3J5KSkgewoJCQlmb3JfZWFjaF9wYWNrZWRfb2JqZWN0KGFkZF9wcm9taXNvcl9vYmplY3QsCgkJCQkJICAgICAgICZwcm9taXNvcl9vYmplY3RzLAoJCQkJCSAgICAgICBGT1JfRUFDSF9PQkpFQ1RfUFJPTUlTT1JfT05MWSB8CgkJCQkJICAgICAgIEZPUl9FQUNIX09CSkVDVF9QQUNLX09SREVSKTsKCQl9CgkJcHJvbWlzb3Jfb2JqZWN0c19wcmVwYXJlZCA9IDE7Cgl9CglyZXR1cm4gb2lkc2V0X2NvbnRhaW5zKCZwcm9taXNvcl9vYmplY3RzLCBvaWQpOwp9Cg==",
    "text": "#define USE_THE_REPOSITORY_VARIABLE\n\n#include \"git-compat-util.h\"\n#include \"environment.h\"\n#include \"gettext.h\"\n#include \"hex.h\"\n#include \"list.h\"\n#include \"pack.h\"\n#include \"repository.h\"\n#include \"dir.h\"\n#include \"mergesort.h\"\n#include \"packfile.h\"\n#include \"delta.h\"\n#include \"hash-lookup.h\"\n#include \"commit.h\"\n#include \"object.h\"\n#include \"tag.h\"\n#include \"trace.h\"\n#include \"tree-walk.h\"\n#include \"tree.h\"\n#include \"object-file.h\"\n#include \"object-store-ll.h\"\n#include \"midx.h\"\n#include \"commit-graph.h\"\n#include \"pack-revindex.h\"\n#include \"promisor-remote.h\"\n\nchar *odb_pack_name(struct strbuf *buf,\n\t\t    const unsigned char *hash,\n\t\t    const char *ext)\n{\n\tstrbuf_reset(buf);\n\tstrbuf_addf(buf, \"%s/pack/pack-%s.%s\", repo_get_object_directory(the_repository),\n\t\t    hash_to_hex(hash), ext);\n\treturn buf->buf;\n}\n\nstatic unsigned int pack_used_ctr;\nstatic unsigned int pack_mmap_calls;\nstatic unsigned int peak_pack_open_windows;\nstatic unsigned int pack_open_windows;\nstatic unsigned int pack_open_fds;\nstatic unsigned int pack_max_fds;\nstatic size_t peak_pack_mapped;\nstatic size_t pack_mapped;\n\n#define SZ_FMT PRIuMAX\nstatic inline uintmax_t sz_fmt(size_t s) { return s; }\n\nvoid pack_report(void)\n{\n\tfprintf(stderr,\n\t\t\"pack_report: getpagesize()            = %10\" SZ_FMT \"\\n\"\n\t\t\"pack_report: core.packedGitWindowSize = %10\" SZ_FMT \"\\n\"\n\t\t\"pack_report: core.packedGitLimit      = %10\" SZ_FMT \"\\n\",\n\t\tsz_fmt(getpagesize()),\n\t\tsz_fmt(packed_git_window_size),\n\t\tsz_fmt(packed_git_limit));\n\tfprintf(stderr,\n\t\t\"pack_report: pack_used_ctr            = %10u\\n\"\n\t\t\"pack_report: pack_mmap_calls          = %10u\\n\"\n\t\t\"pack_report: pack_open_windows        = %10u / %10u\\n\"\n\t\t\"pack_report: pack_mapped              = \"\n\t\t\t\"%10\" SZ_FMT \" / %10\" SZ_FMT \"\\n\",\n\t\tpack_used_ctr,\n\t\tpack_mmap_calls,\n\t\tpack_open_windows, peak_pack_open_windows,\n\t\tsz_fmt(pack_mapped), sz_fmt(peak_pack_mapped));\n}\n\n/*\n * Open and mmap the index file at path, perform a couple of\n * consistency checks, then record its information to p.  Return 0 on\n * success.\n */\nstatic int check_packed_git_idx(const char *path, struct packed_git *p)\n{\n\tvoid *idx_map;\n\tsize_t idx_size;\n\tint fd = git_open(path), ret;\n\tstruct stat st;\n\tconst unsigned int hashsz = the_hash_algo->rawsz;\n\n\tif (fd < 0)\n\t\treturn -1;\n\tif (fstat(fd, &st)) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tidx_size = xsize_t(st.st_size);\n\tif (idx_size < 4 * 256 + hashsz + hashsz) {\n\t\tclose(fd);\n\t\treturn error(\"index file %s is too small\", path);\n\t}\n\tidx_map = xmmap(NULL, idx_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\tclose(fd);\n\n\tret = load_idx(path, hashsz, idx_map, idx_size, p);\n\n\tif (ret)\n\t\tmunmap(idx_map, idx_size);\n\n\treturn ret;\n}\n\nint load_idx(const char *path, const unsigned int hashsz, void *idx_map,\n\t     size_t idx_size, struct packed_git *p)\n{\n\tstruct pack_idx_header *hdr = idx_map;\n\tuint32_t version, nr, i, *index;\n\n\tif (idx_size < 4 * 256 + hashsz + hashsz)\n\t\treturn error(\"index file %s is too small\", path);\n\tif (!idx_map)\n\t\treturn error(\"empty data\");\n\n\tif (hdr->idx_signature == htonl(PACK_IDX_SIGNATURE)) {\n\t\tversion = ntohl(hdr->idx_version);\n\t\tif (version < 2 || version > 2)\n\t\t\treturn error(\"index file %s is version %\"PRIu32\n\t\t\t\t     \" and is not supported by this binary\"\n\t\t\t\t     \" (try upgrading GIT to a newer version)\",\n\t\t\t\t     path, version);\n\t} else\n\t\tversion = 1;\n\n\tnr = 0;\n\tindex = idx_map;\n\tif (version > 1)\n\t\tindex += 2;  /* skip index header */\n\tfor (i = 0; i < 256; i++) {\n\t\tuint32_t n = ntohl(index[i]);\n\t\tif (n < nr)\n\t\t\treturn error(\"non-monotonic index %s\", path);\n\t\tnr = n;\n\t}\n\n\tif (version == 1) {\n\t\t/*\n\t\t * Total size:\n\t\t *  - 256 index entries 4 bytes each\n\t\t *  - 24-byte entries * nr (object ID + 4-byte offset)\n\t\t *  - hash of the packfile\n\t\t *  - file checksum\n\t\t */\n\t\tif (idx_size != st_add(4 * 256 + hashsz + hashsz, st_mult(nr, hashsz + 4)))\n\t\t\treturn error(\"wrong index v1 file size in %s\", path);\n\t} else if (version == 2) {\n\t\t/*\n\t\t * Minimum size:\n\t\t *  - 8 bytes of header\n\t\t *  - 256 index entries 4 bytes each\n\t\t *  - object ID entry * nr\n\t\t *  - 4-byte crc entry * nr\n\t\t *  - 4-byte offset entry * nr\n\t\t *  - hash of the packfile\n\t\t *  - file checksum\n\t\t * And after the 4-byte offset table might be a\n\t\t * variable sized table containing 8-byte entries\n\t\t * for offsets larger than 2^31.\n\t\t */\n\t\tsize_t min_size = st_add(8 + 4*256 + hashsz + hashsz, st_mult(nr, hashsz + 4 + 4));\n\t\tsize_t max_size = min_size;\n\t\tif (nr)\n\t\t\tmax_size = st_add(max_size, st_mult(nr - 1, 8));\n\t\tif (idx_size < min_size || idx_size > max_size)\n\t\t\treturn error(\"wrong index v2 file size in %s\", path);\n\t\tif (idx_size != min_size &&\n\t\t    /*\n\t\t     * make sure we can deal with large pack offsets.\n\t\t     * 31-bit signed offset won't be enough, neither\n\t\t     * 32-bit unsigned one will be.\n\t\t     */\n\t\t    (sizeof(off_t) <= 4))\n\t\t\treturn error(\"pack too large for current definition of off_t in %s\", path);\n\t\tp->crc_offset = st_add(8 + 4 * 256, st_mult(nr, hashsz));\n\t}\n\n\tp->index_version = version;\n\tp->index_data = idx_map;\n\tp->index_size = idx_size;\n\tp->num_objects = nr;\n\treturn 0;\n}\n\nint open_pack_index(struct packed_git *p)\n{\n\tchar *idx_name;\n\tsize_t len;\n\tint ret;\n\n\tif (p->index_data)\n\t\treturn 0;\n\n\tif (!strip_suffix(p->pack_name, \".pack\", &len))\n\t\tBUG(\"pack_name does not end in .pack\");\n\tidx_name = xstrfmt(\"%.*s.idx\", (int)len, p->pack_name);\n\tret = check_packed_git_idx(idx_name, p);\n\tfree(idx_name);\n\treturn ret;\n}\n\nuint32_t get_pack_fanout(struct packed_git *p, uint32_t value)\n{\n\tconst uint32_t *level1_ofs = p->index_data;\n\n\tif (!level1_ofs) {\n\t\tif (open_pack_index(p))\n\t\t\treturn 0;\n\t\tlevel1_ofs = p->index_data;\n\t}\n\n\tif (p->index_version > 1) {\n\t\tlevel1_ofs += 2;\n\t}\n\n\treturn ntohl(level1_ofs[value]);\n}\n\nstatic struct packed_git *alloc_packed_git(int extra)\n{\n\tstruct packed_git *p = xmalloc(st_add(sizeof(*p), extra));\n\tmemset(p, 0, sizeof(*p));\n\tp->pack_fd = -1;\n\treturn p;\n}\n\nstatic char *pack_path_from_idx(const char *idx_path)\n{\n\tsize_t len;\n\tif (!strip_suffix(idx_path, \".idx\", &len))\n\t\tBUG(\"idx path does not end in .idx: %s\", idx_path);\n\treturn xstrfmt(\"%.*s.pack\", (int)len, idx_path);\n}\n\nstruct packed_git *parse_pack_index(unsigned char *sha1, const char *idx_path)\n{\n\tchar *path = pack_path_from_idx(idx_path);\n\tsize_t alloc = st_add(strlen(path), 1);\n\tstruct packed_git *p = alloc_packed_git(alloc);\n\n\tmemcpy(p->pack_name, path, alloc); /* includes NUL */\n\tfree(path);\n\thashcpy(p->hash, sha1, the_repository->hash_algo);\n\tif (check_packed_git_idx(idx_path, p)) {\n\t\tfree(p);\n\t\treturn NULL;\n\t}\n\n\treturn p;\n}\n\nstatic void scan_windows(struct packed_git *p,\n\tstruct packed_git **lru_p,\n\tstruct pack_window **lru_w,\n\tstruct pack_window **lru_l)\n{\n\tstruct pack_window *w, *w_l;\n\n\tfor (w_l = NULL, w = p->windows; w; w = w->next) {\n\t\tif (!w->inuse_cnt) {\n\t\t\tif (!*lru_w || w->last_used < (*lru_w)->last_used) {\n\t\t\t\t*lru_p = p;\n\t\t\t\t*lru_w = w;\n\t\t\t\t*lru_l = w_l;\n\t\t\t}\n\t\t}\n\t\tw_l = w;\n\t}\n}\n\nstatic int unuse_one_window(struct packed_git *current)\n{\n\tstruct packed_git *p, *lru_p = NULL;\n\tstruct pack_window *lru_w = NULL, *lru_l = NULL;\n\n\tif (current)\n\t\tscan_windows(current, &lru_p, &lru_w, &lru_l);\n\tfor (p = the_repository->objects->packed_git; p; p = p->next)\n\t\tscan_windows(p, &lru_p, &lru_w, &lru_l);\n\tif (lru_p) {\n\t\tmunmap(lru_w->base, lru_w->len);\n\t\tpack_mapped -= lru_w->len;\n\t\tif (lru_l)\n\t\t\tlru_l->next = lru_w->next;\n\t\telse\n\t\t\tlru_p->windows = lru_w->next;\n\t\tfree(lru_w);\n\t\tpack_open_windows--;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid close_pack_windows(struct packed_git *p)\n{\n\twhile (p->windows) {\n\t\tstruct pack_window *w = p->windows;\n\n\t\tif (w->inuse_cnt)\n\t\t\tdie(\"pack '%s' still has open windows to it\",\n\t\t\t    p->pack_name);\n\t\tmunmap(w->base, w->len);\n\t\tpack_mapped -= w->len;\n\t\tpack_open_windows--;\n\t\tp->windows = w->next;\n\t\tfree(w);\n\t}\n}\n\nint close_pack_fd(struct packed_git *p)\n{\n\tif (p->pack_fd < 0)\n\t\treturn 0;\n\n\tclose(p->pack_fd);\n\tpack_open_fds--;\n\tp->pack_fd = -1;\n\n\treturn 1;\n}\n\nvoid close_pack_index(struct packed_git *p)\n{\n\tif (p->index_data) {\n\t\tmunmap((void *)p->index_data, p->index_size);\n\t\tp->index_data = NULL;\n\t}\n}\n\nstatic void close_pack_revindex(struct packed_git *p)\n{\n\tif (!p->revindex_map)\n\t\treturn;\n\n\tmunmap((void *)p->revindex_map, p->revindex_size);\n\tp->revindex_map = NULL;\n\tp->revindex_data = NULL;\n}\n\nstatic void close_pack_mtimes(struct packed_git *p)\n{\n\tif (!p->mtimes_map)\n\t\treturn;\n\n\tmunmap((void *)p->mtimes_map, p->mtimes_size);\n\tp->mtimes_map = NULL;\n}\n\nvoid close_pack(struct packed_git *p)\n{\n\tclose_pack_windows(p);\n\tclose_pack_fd(p);\n\tclose_pack_index(p);\n\tclose_pack_revindex(p);\n\tclose_pack_mtimes(p);\n\toidset_clear(&p->bad_objects);\n}\n\nvoid close_object_store(struct raw_object_store *o)\n{\n\tstruct packed_git *p;\n\n\tfor (p = o->packed_git; p; p = p->next)\n\t\tif (p->do_not_close)\n\t\t\tBUG(\"want to close pack marked 'do-not-close'\");\n\t\telse\n\t\t\tclose_pack(p);\n\n\tif (o->multi_pack_index) {\n\t\tclose_midx(o->multi_pack_index);\n\t\to->multi_pack_index = NULL;\n\t}\n\n\tclose_commit_graph(o);\n}\n\nvoid unlink_pack_path(const char *pack_name, int force_delete)\n{\n\tstatic const char *exts[] = {\".idx\", \".pack\", \".rev\", \".keep\", \".bitmap\", \".promisor\", \".mtimes\"};\n\tint i;\n\tstruct strbuf buf = STRBUF_INIT;\n\tsize_t plen;\n\n\tstrbuf_addstr(&buf, pack_name);\n\tstrip_suffix_mem(buf.buf, &buf.len, \".pack\");\n\tplen = buf.len;\n\n\tif (!force_delete) {\n\t\tstrbuf_addstr(&buf, \".keep\");\n\t\tif (!access(buf.buf, F_OK)) {\n\t\t\tstrbuf_release(&buf);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(exts); i++) {\n\t\tstrbuf_setlen(&buf, plen);\n\t\tstrbuf_addstr(&buf, exts[i]);\n\t\tunlink(buf.buf);\n\t}\n\n\tstrbuf_release(&buf);\n}\n\n/*\n * The LRU pack is the one with the oldest MRU window, preferring packs\n * with no used windows, or the oldest mtime if it has no windows allocated.\n */\nstatic void find_lru_pack(struct packed_git *p, struct packed_git **lru_p, struct pack_window **mru_w, int *accept_windows_inuse)\n{\n\tstruct pack_window *w, *this_mru_w;\n\tint has_windows_inuse = 0;\n\n\t/*\n\t * Reject this pack if it has windows and the previously selected\n\t * one does not.  If this pack does not have windows, reject\n\t * it if the pack file is newer than the previously selected one.\n\t */\n\tif (*lru_p && !*mru_w && (p->windows || p->mtime > (*lru_p)->mtime))\n\t\treturn;\n\n\tfor (w = this_mru_w = p->windows; w; w = w->next) {\n\t\t/*\n\t\t * Reject this pack if any of its windows are in use,\n\t\t * but the previously selected pack did not have any\n\t\t * inuse windows.  Otherwise, record that this pack\n\t\t * has windows in use.\n\t\t */\n\t\tif (w->inuse_cnt) {\n\t\t\tif (*accept_windows_inuse)\n\t\t\t\thas_windows_inuse = 1;\n\t\t\telse\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (w->last_used > this_mru_w->last_used)\n\t\t\tthis_mru_w = w;\n\n\t\t/*\n\t\t * Reject this pack if it has windows that have been\n\t\t * used more recently than the previously selected pack.\n\t\t * If the previously selected pack had windows inuse and\n\t\t * we have not encountered a window in this pack that is\n\t\t * inuse, skip this check since we prefer a pack with no\n\t\t * inuse windows to one that has inuse windows.\n\t\t */\n\t\tif (*mru_w && *accept_windows_inuse == has_windows_inuse &&\n\t\t    this_mru_w->last_used > (*mru_w)->last_used)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Select this pack.\n\t */\n\t*mru_w = this_mru_w;\n\t*lru_p = p;\n\t*accept_windows_inuse = has_windows_inuse;\n}\n\nstatic int close_one_pack(void)\n{\n\tstruct packed_git *p, *lru_p = NULL;\n\tstruct pack_window *mru_w = NULL;\n\tint accept_windows_inuse = 1;\n\n\tfor (p = the_repository->objects->packed_git; p; p = p->next) {\n\t\tif (p->pack_fd == -1)\n\t\t\tcontinue;\n\t\tfind_lru_pack(p, &lru_p, &mru_w, &accept_windows_inuse);\n\t}\n\n\tif (lru_p)\n\t\treturn close_pack_fd(lru_p);\n\n\treturn 0;\n}\n\nstatic unsigned int get_max_fd_limit(void)\n{\n#ifdef RLIMIT_NOFILE\n\t{\n\t\tstruct rlimit lim;\n\n\t\tif (!getrlimit(RLIMIT_NOFILE, &lim))\n\t\t\treturn lim.rlim_cur;\n\t}\n#endif\n\n#ifdef _SC_OPEN_MAX\n\t{\n\t\tlong open_max = sysconf(_SC_OPEN_MAX);\n\t\tif (0 < open_max)\n\t\t\treturn open_max;\n\t\t/*\n\t\t * Otherwise, we got -1 for one of the two\n\t\t * reasons:\n\t\t *\n\t\t * (1) sysconf() did not understand _SC_OPEN_MAX\n\t\t *     and signaled an error with -1; or\n\t\t * (2) sysconf() said there is no limit.\n\t\t *\n\t\t * We _could_ clear errno before calling sysconf() to\n\t\t * tell these two cases apart and return a huge number\n\t\t * in the latter case to let the caller cap it to a\n\t\t * value that is not so selfish, but letting the\n\t\t * fallback OPEN_MAX codepath take care of these cases\n\t\t * is a lot simpler.\n\t\t */\n\t}\n#endif\n\n#ifdef OPEN_MAX\n\treturn OPEN_MAX;\n#else\n\treturn 1; /* see the caller ;-) */\n#endif\n}\n\nconst char *pack_basename(struct packed_git *p)\n{\n\tconst char *ret = strrchr(p->pack_name, '/');\n\tif (ret)\n\t\tret = ret + 1; /* skip past slash */\n\telse\n\t\tret = p->pack_name; /* we only have a base */\n\treturn ret;\n}\n\n/*\n * Do not call this directly as this leaks p->pack_fd on error return;\n * call open_packed_git() instead.\n */\nstatic int open_packed_git_1(struct packed_git *p)\n{\n\tstruct stat st;\n\tstruct pack_header hdr;\n\tunsigned char hash[GIT_MAX_RAWSZ];\n\tunsigned char *idx_hash;\n\tssize_t read_result;\n\tconst unsigned hashsz = the_hash_algo->rawsz;\n\n\tif (open_pack_index(p))\n\t\treturn error(\"packfile %s index unavailable\", p->pack_name);\n\n\tif (!pack_max_fds) {\n\t\tunsigned int max_fds = get_max_fd_limit();\n\n\t\t/* Save 3 for stdin/stdout/stderr, 22 for work */\n\t\tif (25 < max_fds)\n\t\t\tpack_max_fds = max_fds - 25;\n\t\telse\n\t\t\tpack_max_fds = 1;\n\t}\n\n\twhile (pack_max_fds <= pack_open_fds && close_one_pack())\n\t\t; /* nothing */\n\n\tp->pack_fd = git_open(p->pack_name);\n\tif (p->pack_fd < 0 || fstat(p->pack_fd, &st))\n\t\treturn -1;\n\tpack_open_fds++;\n\n\t/* If we created the struct before we had the pack we lack size. */\n\tif (!p->pack_size) {\n\t\tif (!S_ISREG(st.st_mode))\n\t\t\treturn error(\"packfile %s not a regular file\", p->pack_name);\n\t\tp->pack_size = st.st_size;\n\t} else if (p->pack_size != st.st_size)\n\t\treturn error(\"packfile %s size changed\", p->pack_name);\n\n\t/* Verify we recognize this pack file format. */\n\tread_result = read_in_full(p->pack_fd, &hdr, sizeof(hdr));\n\tif (read_result < 0)\n\t\treturn error_errno(\"error reading from %s\", p->pack_name);\n\tif (read_result != sizeof(hdr))\n\t\treturn error(\"file %s is far too short to be a packfile\", p->pack_name);\n\tif (hdr.hdr_signature != htonl(PACK_SIGNATURE))\n\t\treturn error(\"file %s is not a GIT packfile\", p->pack_name);\n\tif (!pack_version_ok(hdr.hdr_version))\n\t\treturn error(\"packfile %s is version %\"PRIu32\" and not\"\n\t\t\t\" supported (try upgrading GIT to a newer version)\",\n\t\t\tp->pack_name, ntohl(hdr.hdr_version));\n\n\t/* Verify the pack matches its index. */\n\tif (p->num_objects != ntohl(hdr.hdr_entries))\n\t\treturn error(\"packfile %s claims to have %\"PRIu32\" objects\"\n\t\t\t     \" while index indicates %\"PRIu32\" objects\",\n\t\t\t     p->pack_name, ntohl(hdr.hdr_entries),\n\t\t\t     p->num_objects);\n\tread_result = pread_in_full(p->pack_fd, hash, hashsz,\n\t\t\t\t\tp->pack_size - hashsz);\n\tif (read_result < 0)\n\t\treturn error_errno(\"error reading from %s\", p->pack_name);\n\tif (read_result != hashsz)\n\t\treturn error(\"packfile %s signature is unavailable\", p->pack_name);\n\tidx_hash = ((unsigned char *)p->index_data) + p->index_size - hashsz * 2;\n\tif (!hasheq(hash, idx_hash, the_repository->hash_algo))\n\t\treturn error(\"packfile %s does not match index\", p->pack_name);\n\treturn 0;\n}\n\nstatic int open_packed_git(struct packed_git *p)\n{\n\tif (!open_packed_git_1(p))\n\t\treturn 0;\n\tclose_pack_fd(p);\n\treturn -1;\n}\n\nstatic int in_window(struct pack_window *win, off_t offset)\n{\n\t/* We must promise at least one full hash after the\n\t * offset is available from this window, otherwise the offset\n\t * is not actually in this window and a different window (which\n\t * has that one hash excess) must be used.  This is to support\n\t * the object header and delta base parsing routines below.\n\t */\n\toff_t win_off = win->offset;\n\treturn win_off <= offset\n\t\t&& (offset + the_hash_algo->rawsz) <= (win_off + win->len);\n}\n\nunsigned char *use_pack(struct packed_git *p,\n\t\tstruct pack_window **w_cursor,\n\t\toff_t offset,\n\t\tunsigned long *left)\n{\n\tstruct pack_window *win = *w_cursor;\n\n\t/* Since packfiles end in a hash of their content and it's\n\t * pointless to ask for an offset into the middle of that\n\t * hash, and the in_window function above wouldn't match\n\t * don't allow an offset too close to the end of the file.\n\t */\n\tif (!p->pack_size && p->pack_fd == -1 && open_packed_git(p))\n\t\tdie(\"packfile %s cannot be accessed\", p->pack_name);\n\tif (offset > (p->pack_size - the_hash_algo->rawsz))\n\t\tdie(\"offset beyond end of packfile (truncated pack?)\");\n\tif (offset < 0)\n\t\tdie(_(\"offset before end of packfile (broken .idx?)\"));\n\n\tif (!win || !in_window(win, offset)) {\n\t\tif (win)\n\t\t\twin->inuse_cnt--;\n\t\tfor (win = p->windows; win; win = win->next) {\n\t\t\tif (in_window(win, offset))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!win) {\n\t\t\tsize_t window_align = packed_git_window_size / 2;\n\t\t\toff_t len;\n\n\t\t\tif (p->pack_fd == -1 && open_packed_git(p))\n\t\t\t\tdie(\"packfile %s cannot be accessed\", p->pack_name);\n\n\t\t\tCALLOC_ARRAY(win, 1);\n\t\t\twin->offset = (offset / window_align) * window_align;\n\t\t\tlen = p->pack_size - win->offset;\n\t\t\tif (len > packed_git_window_size)\n\t\t\t\tlen = packed_git_window_size;\n\t\t\twin->len = (size_t)len;\n\t\t\tpack_mapped += win->len;\n\t\t\twhile (packed_git_limit < pack_mapped\n\t\t\t\t&& unuse_one_window(p))\n\t\t\t\t; /* nothing */\n\t\t\twin->base = xmmap_gently(NULL, win->len,\n\t\t\t\tPROT_READ, MAP_PRIVATE,\n\t\t\t\tp->pack_fd, win->offset);\n\t\t\tif (win->base == MAP_FAILED)\n\t\t\t\tdie_errno(_(\"packfile %s cannot be mapped%s\"),\n\t\t\t\t\t  p->pack_name, mmap_os_err());\n\t\t\tif (!win->offset && win->len == p->pack_size\n\t\t\t\t&& !p->do_not_close)\n\t\t\t\tclose_pack_fd(p);\n\t\t\tpack_mmap_calls++;\n\t\t\tpack_open_windows++;\n\t\t\tif (pack_mapped > peak_pack_mapped)\n\t\t\t\tpeak_pack_mapped = pack_mapped;\n\t\t\tif (pack_open_windows > peak_pack_open_windows)\n\t\t\t\tpeak_pack_open_windows = pack_open_windows;\n\t\t\twin->next = p->windows;\n\t\t\tp->windows = win;\n\t\t}\n\t}\n\tif (win != *w_cursor) {\n\t\twin->last_used = pack_used_ctr++;\n\t\twin->inuse_cnt++;\n\t\t*w_cursor = win;\n\t}\n\toffset -= win->offset;\n\tif (left)\n\t\t*left = win->len - xsize_t(offset);\n\treturn win->base + offset;\n}\n\nvoid unuse_pack(struct pack_window **w_cursor)\n{\n\tstruct pack_window *w = *w_cursor;\n\tif (w) {\n\t\tw->inuse_cnt--;\n\t\t*w_cursor = NULL;\n\t}\n}\n\nstruct packed_git *add_packed_git(const char *path, size_t path_len, int local)\n{\n\tstruct stat st;\n\tsize_t alloc;\n\tstruct packed_git *p;\n\n\t/*\n\t * Make sure a corresponding .pack file exists and that\n\t * the index looks sane.\n\t */\n\tif (!strip_suffix_mem(path, &path_len, \".idx\"))\n\t\treturn NULL;\n\n\t/*\n\t * \".promisor\" is long enough to hold any suffix we're adding (and\n\t * the use xsnprintf double-checks that)\n\t */\n\talloc = st_add3(path_len, strlen(\".promisor\"), 1);\n\tp = alloc_packed_git(alloc);\n\tmemcpy(p->pack_name, path, path_len);\n\n\txsnprintf(p->pack_name + path_len, alloc - path_len, \".keep\");\n\tif (!access(p->pack_name, F_OK))\n\t\tp->pack_keep = 1;\n\n\txsnprintf(p->pack_name + path_len, alloc - path_len, \".promisor\");\n\tif (!access(p->pack_name, F_OK))\n\t\tp->pack_promisor = 1;\n\n\txsnprintf(p->pack_name + path_len, alloc - path_len, \".mtimes\");\n\tif (!access(p->pack_name, F_OK))\n\t\tp->is_cruft = 1;\n\n\txsnprintf(p->pack_name + path_len, alloc - path_len, \".pack\");\n\tif (stat(p->pack_name, &st) || !S_ISREG(st.st_mode)) {\n\t\tfree(p);\n\t\treturn NULL;\n\t}\n\n\t/* ok, it looks sane as far as we can check without\n\t * actually mapping the pack file.\n\t */\n\tp->pack_size = st.st_size;\n\tp->pack_local = local;\n\tp->mtime = st.st_mtime;\n\tif (path_len < the_hash_algo->hexsz ||\n\t    get_hash_hex(path + path_len - the_hash_algo->hexsz, p->hash))\n\t\thashclr(p->hash, the_repository->hash_algo);\n\treturn p;\n}\n\nvoid install_packed_git(struct repository *r, struct packed_git *pack)\n{\n\tif (pack->pack_fd != -1)\n\t\tpack_open_fds++;\n\n\tpack->next = r->objects->packed_git;\n\tr->objects->packed_git = pack;\n\n\thashmap_entry_init(&pack->packmap_ent, strhash(pack->pack_name));\n\thashmap_add(&r->objects->pack_map, &pack->packmap_ent);\n}\n\nvoid (*report_garbage)(unsigned seen_bits, const char *path);\n\nstatic void report_helper(const struct string_list *list,\n\t\t\t  int seen_bits, int first, int last)\n{\n\tif (seen_bits == (PACKDIR_FILE_PACK|PACKDIR_FILE_IDX))\n\t\treturn;\n\n\tfor (; first < last; first++)\n\t\treport_garbage(seen_bits, list->items[first].string);\n}\n\nstatic void report_pack_garbage(struct string_list *list)\n{\n\tint i, baselen = -1, first = 0, seen_bits = 0;\n\n\tif (!report_garbage)\n\t\treturn;\n\n\tstring_list_sort(list);\n\n\tfor (i = 0; i < list->nr; i++) {\n\t\tconst char *path = list->items[i].string;\n\t\tif (baselen != -1 &&\n\t\t    strncmp(path, list->items[first].string, baselen)) {\n\t\t\treport_helper(list, seen_bits, first, i);\n\t\t\tbaselen = -1;\n\t\t\tseen_bits = 0;\n\t\t}\n\t\tif (baselen == -1) {\n\t\t\tconst char *dot = strrchr(path, '.');\n\t\t\tif (!dot) {\n\t\t\t\treport_garbage(PACKDIR_FILE_GARBAGE, path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbaselen = dot - path + 1;\n\t\t\tfirst = i;\n\t\t}\n\t\tif (!strcmp(path + baselen, \"pack\"))\n\t\t\tseen_bits |= 1;\n\t\telse if (!strcmp(path + baselen, \"idx\"))\n\t\t\tseen_bits |= 2;\n\t}\n\treport_helper(list, seen_bits, first, list->nr);\n}\n\nvoid for_each_file_in_pack_subdir(const char *objdir,\n\t\t\t\t  const char *subdir,\n\t\t\t\t  each_file_in_pack_dir_fn fn,\n\t\t\t\t  void *data)\n{\n\tstruct strbuf path = STRBUF_INIT;\n\tsize_t dirnamelen;\n\tDIR *dir;\n\tstruct dirent *de;\n\n\tstrbuf_addstr(&path, objdir);\n\tstrbuf_addstr(&path, \"/pack\");\n\tif (subdir)\n\t\tstrbuf_addf(&path, \"/%s\", subdir);\n\tdir = opendir(path.buf);\n\tif (!dir) {\n\t\tif (errno != ENOENT)\n\t\t\terror_errno(\"unable to open object pack directory: %s\",\n\t\t\t\t    path.buf);\n\t\tstrbuf_release(&path);\n\t\treturn;\n\t}\n\tstrbuf_addch(&path, '/');\n\tdirnamelen = path.len;\n\twhile ((de = readdir_skip_dot_and_dotdot(dir)) != NULL) {\n\t\tstrbuf_setlen(&path, dirnamelen);\n\t\tstrbuf_addstr(&path, de->d_name);\n\n\t\tfn(path.buf, path.len, de->d_name, data);\n\t}\n\n\tclosedir(dir);\n\tstrbuf_release(&path);\n}\n\nvoid for_each_file_in_pack_dir(const char *objdir,\n\t\t\t       each_file_in_pack_dir_fn fn,\n\t\t\t       void *data)\n{\n\tfor_each_file_in_pack_subdir(objdir, NULL, fn, data);\n}\n\nstruct prepare_pack_data {\n\tstruct repository *r;\n\tstruct string_list *garbage;\n\tint local;\n\tstruct multi_pack_index *m;\n};\n\nstatic void prepare_pack(const char *full_name, size_t full_name_len,\n\t\t\t const char *file_name, void *_data)\n{\n\tstruct prepare_pack_data *data = (struct prepare_pack_data *)_data;\n\tstruct packed_git *p;\n\tsize_t base_len = full_name_len;\n\n\tif (strip_suffix_mem(full_name, &base_len, \".idx\") &&\n\t    !(data->m && midx_contains_pack(data->m, file_name))) {\n\t\tstruct hashmap_entry hent;\n\t\tchar *pack_name = xstrfmt(\"%.*s.pack\", (int)base_len, full_name);\n\t\tunsigned int hash = strhash(pack_name);\n\t\thashmap_entry_init(&hent, hash);\n\n\t\t/* Don't reopen a pack we already have. */\n\t\tif (!hashmap_get(&data->r->objects->pack_map, &hent, pack_name)) {\n\t\t\tp = add_packed_git(full_name, full_name_len, data->local);\n\t\t\tif (p)\n\t\t\t\tinstall_packed_git(data->r, p);\n\t\t}\n\t\tfree(pack_name);\n\t}\n\n\tif (!report_garbage)\n\t\treturn;\n\n\tif (!strcmp(file_name, \"multi-pack-index\") ||\n\t    !strcmp(file_name, \"multi-pack-index.d\"))\n\t\treturn;\n\tif (starts_with(file_name, \"multi-pack-index\") &&\n\t    (ends_with(file_name, \".bitmap\") || ends_with(file_name, \".rev\")))\n\t\treturn;\n\tif (ends_with(file_name, \".idx\") ||\n\t    ends_with(file_name, \".rev\") ||\n\t    ends_with(file_name, \".pack\") ||\n\t    ends_with(file_name, \".bitmap\") ||\n\t    ends_with(file_name, \".keep\") ||\n\t    ends_with(file_name, \".promisor\") ||\n\t    ends_with(file_name, \".mtimes\"))\n\t\tstring_list_append(data->garbage, full_name);\n\telse\n\t\treport_garbage(PACKDIR_FILE_GARBAGE, full_name);\n}\n\nstatic void prepare_packed_git_one(struct repository *r, char *objdir, int local)\n{\n\tstruct prepare_pack_data data;\n\tstruct string_list garbage = STRING_LIST_INIT_DUP;\n\n\tdata.m = r->objects->multi_pack_index;\n\n\t/* look for the multi-pack-index for this object directory */\n\twhile (data.m && strcmp(data.m->object_dir, objdir))\n\t\tdata.m = data.m->next;\n\n\tdata.r = r;\n\tdata.garbage = &garbage;\n\tdata.local = local;\n\n\tfor_each_file_in_pack_dir(objdir, prepare_pack, &data);\n\n\treport_pack_garbage(data.garbage);\n\tstring_list_clear(data.garbage, 0);\n}\n\nstatic void prepare_packed_git(struct repository *r);\n/*\n * Give a fast, rough count of the number of objects in the repository. This\n * ignores loose objects completely. If you have a lot of them, then either\n * you should repack because your performance will be awful, or they are\n * all unreachable objects about to be pruned, in which case they're not really\n * interesting as a measure of repo size in the first place.\n */\nunsigned long repo_approximate_object_count(struct repository *r)\n{\n\tif (!r->objects->approximate_object_count_valid) {\n\t\tunsigned long count;\n\t\tstruct multi_pack_index *m;\n\t\tstruct packed_git *p;\n\n\t\tprepare_packed_git(r);\n\t\tcount = 0;\n\t\tfor (m = get_multi_pack_index(r); m; m = m->next)\n\t\t\tcount += m->num_objects;\n\t\tfor (p = r->objects->packed_git; p; p = p->next) {\n\t\t\tif (open_pack_index(p))\n\t\t\t\tcontinue;\n\t\t\tcount += p->num_objects;\n\t\t}\n\t\tr->objects->approximate_object_count = count;\n\t\tr->objects->approximate_object_count_valid = 1;\n\t}\n\treturn r->objects->approximate_object_count;\n}\n\nDEFINE_LIST_SORT(static, sort_packs, struct packed_git, next);\n\nstatic int sort_pack(const struct packed_git *a, const struct packed_git *b)\n{\n\tint st;\n\n\t/*\n\t * Local packs tend to contain objects specific to our\n\t * variant of the project than remote ones.  In addition,\n\t * remote ones could be on a network mounted filesystem.\n\t * Favor local ones for these reasons.\n\t */\n\tst = a->pack_local - b->pack_local;\n\tif (st)\n\t\treturn -st;\n\n\t/*\n\t * Younger packs tend to contain more recent objects,\n\t * and more recent objects tend to get accessed more\n\t * often.\n\t */\n\tif (a->mtime < b->mtime)\n\t\treturn 1;\n\telse if (a->mtime == b->mtime)\n\t\treturn 0;\n\treturn -1;\n}\n\nstatic void rearrange_packed_git(struct repository *r)\n{\n\tsort_packs(&r->objects->packed_git, sort_pack);\n}\n\nstatic void prepare_packed_git_mru(struct repository *r)\n{\n\tstruct packed_git *p;\n\n\tINIT_LIST_HEAD(&r->objects->packed_git_mru);\n\n\tfor (p = r->objects->packed_git; p; p = p->next)\n\t\tlist_add_tail(&p->mru, &r->objects->packed_git_mru);\n}\n\nstatic void prepare_packed_git(struct repository *r)\n{\n\tstruct object_directory *odb;\n\n\tif (r->objects->packed_git_initialized)\n\t\treturn;\n\n\tprepare_alt_odb(r);\n\tfor (odb = r->objects->odb; odb; odb = odb->next) {\n\t\tint local = (odb == r->objects->odb);\n\t\tprepare_multi_pack_index_one(r, odb->path, local);\n\t\tprepare_packed_git_one(r, odb->path, local);\n\t}\n\trearrange_packed_git(r);\n\n\tprepare_packed_git_mru(r);\n\tr->objects->packed_git_initialized = 1;\n}\n\nvoid reprepare_packed_git(struct repository *r)\n{\n\tstruct object_directory *odb;\n\n\tobj_read_lock();\n\n\t/*\n\t * Reprepare alt odbs, in case the alternates file was modified\n\t * during the course of this process. This only _adds_ odbs to\n\t * the linked list, so existing odbs will continue to exist for\n\t * the lifetime of the process.\n\t */\n\tr->objects->loaded_alternates = 0;\n\tprepare_alt_odb(r);\n\n\tfor (odb = r->objects->odb; odb; odb = odb->next)\n\t\todb_clear_loose_cache(odb);\n\n\tr->objects->approximate_object_count_valid = 0;\n\tr->objects->packed_git_initialized = 0;\n\tprepare_packed_git(r);\n\tobj_read_unlock();\n}\n\nstruct packed_git *get_packed_git(struct repository *r)\n{\n\tprepare_packed_git(r);\n\treturn r->objects->packed_git;\n}\n\nstruct multi_pack_index *get_multi_pack_index(struct repository *r)\n{\n\tprepare_packed_git(r);\n\treturn r->objects->multi_pack_index;\n}\n\nstruct multi_pack_index *get_local_multi_pack_index(struct repository *r)\n{\n\tstruct multi_pack_index *m = get_multi_pack_index(r);\n\n\t/* no need to iterate; we always put the local one first (if any) */\n\tif (m && m->local)\n\t\treturn m;\n\n\treturn NULL;\n}\n\nstruct packed_git *get_all_packs(struct repository *r)\n{\n\tstruct multi_pack_index *m;\n\n\tprepare_packed_git(r);\n\tfor (m = r->objects->multi_pack_index; m; m = m->next) {\n\t\tuint32_t i;\n\t\tfor (i = 0; i < m->num_packs + m->num_packs_in_base; i++)\n\t\t\tprepare_midx_pack(r, m, i);\n\t}\n\n\treturn r->objects->packed_git;\n}\n\nstruct list_head *get_packed_git_mru(struct repository *r)\n{\n\tprepare_packed_git(r);\n\treturn &r->objects->packed_git_mru;\n}\n\nunsigned long unpack_object_header_buffer(const unsigned char *buf,\n\t\tunsigned long len, enum object_type *type, unsigned long *sizep)\n{\n\tunsigned shift;\n\tsize_t size, c;\n\tunsigned long used = 0;\n\n\tc = buf[used++];\n\t*type = (c >> 4) & 7;\n\tsize = c & 15;\n\tshift = 4;\n\twhile (c & 0x80) {\n\t\tif (len <= used || (bitsizeof(long) - 7) < shift) {\n\t\t\terror(\"bad object header\");\n\t\t\tsize = used = 0;\n\t\t\tbreak;\n\t\t}\n\t\tc = buf[used++];\n\t\tsize = st_add(size, st_left_shift(c & 0x7f, shift));\n\t\tshift += 7;\n\t}\n\t*sizep = cast_size_t_to_ulong(size);\n\treturn used;\n}\n\nunsigned long get_size_from_delta(struct packed_git *p,\n\t\t\t\t  struct pack_window **w_curs,\n\t\t\t\t  off_t curpos)\n{\n\tconst unsigned char *data;\n\tunsigned char delta_head[20], *in;\n\tgit_zstream stream;\n\tint st;\n\n\tmemset(&stream, 0, sizeof(stream));\n\tstream.next_out = delta_head;\n\tstream.avail_out = sizeof(delta_head);\n\n\tgit_inflate_init(&stream);\n\tdo {\n\t\tin = use_pack(p, w_curs, curpos, &stream.avail_in);\n\t\tstream.next_in = in;\n\t\t/*\n\t\t * Note: the window section returned by use_pack() must be\n\t\t * available throughout git_inflate()'s unlocked execution. To\n\t\t * ensure no other thread will modify the window in the\n\t\t * meantime, we rely on the packed_window.inuse_cnt. This\n\t\t * counter is incremented before window reading and checked\n\t\t * before window disposal.\n\t\t *\n\t\t * Other worrying sections could be the call to close_pack_fd(),\n\t\t * which can close packs even with in-use windows, and to\n\t\t * reprepare_packed_git(). Regarding the former, mmap doc says:\n\t\t * \"closing the file descriptor does not unmap the region\". And\n\t\t * for the latter, it won't re-open already available packs.\n\t\t */\n\t\tobj_read_unlock();\n\t\tst = git_inflate(&stream, Z_FINISH);\n\t\tobj_read_lock();\n\t\tcurpos += stream.next_in - in;\n\t} while ((st == Z_OK || st == Z_BUF_ERROR) &&\n\t\t stream.total_out < sizeof(delta_head));\n\tgit_inflate_end(&stream);\n\tif ((st != Z_STREAM_END) && stream.total_out != sizeof(delta_head)) {\n\t\terror(\"delta data unpack-initial failed\");\n\t\treturn 0;\n\t}\n\n\t/* Examine the initial part of the delta to figure out\n\t * the result size.\n\t */\n\tdata = delta_head;\n\n\t/* ignore base size */\n\tget_delta_hdr_size(&data, delta_head+sizeof(delta_head));\n\n\t/* Read the result size */\n\treturn get_delta_hdr_size(&data, delta_head+sizeof(delta_head));\n}\n\nint unpack_object_header(struct packed_git *p,\n\t\t\t struct pack_window **w_curs,\n\t\t\t off_t *curpos,\n\t\t\t unsigned long *sizep)\n{\n\tunsigned char *base;\n\tunsigned long left;\n\tunsigned long used;\n\tenum object_type type;\n\n\t/* use_pack() assures us we have [base, base + 20) available\n\t * as a range that we can look at.  (Its actually the hash\n\t * size that is assured.)  With our object header encoding\n\t * the maximum deflated object size is 2^137, which is just\n\t * insane, so we know won't exceed what we have been given.\n\t */\n\tbase = use_pack(p, w_curs, *curpos, &left);\n\tused = unpack_object_header_buffer(base, left, &type, sizep);\n\tif (!used) {\n\t\ttype = OBJ_BAD;\n\t} else\n\t\t*curpos += used;\n\n\treturn type;\n}\n\nvoid mark_bad_packed_object(struct packed_git *p, const struct object_id *oid)\n{\n\toidset_insert(&p->bad_objects, oid);\n}\n\nconst struct packed_git *has_packed_and_bad(struct repository *r,\n\t\t\t\t\t    const struct object_id *oid)\n{\n\tstruct packed_git *p;\n\n\tfor (p = r->objects->packed_git; p; p = p->next)\n\t\tif (oidset_contains(&p->bad_objects, oid))\n\t\t\treturn p;\n\treturn NULL;\n}\n\noff_t get_delta_base(struct packed_git *p,\n\t\t     struct pack_window **w_curs,\n\t\t     off_t *curpos,\n\t\t     enum object_type type,\n\t\t     off_t delta_obj_offset)\n{\n\tunsigned char *base_info = use_pack(p, w_curs, *curpos, NULL);\n\toff_t base_offset;\n\n\t/* use_pack() assured us we have [base_info, base_info + 20)\n\t * as a range that we can look at without walking off the\n\t * end of the mapped window.  Its actually the hash size\n\t * that is assured.  An OFS_DELTA longer than the hash size\n\t * is stupid, as then a REF_DELTA would be smaller to store.\n\t */\n\tif (type == OBJ_OFS_DELTA) {\n\t\tunsigned used = 0;\n\t\tunsigned char c = base_info[used++];\n\t\tbase_offset = c & 127;\n\t\twhile (c & 128) {\n\t\t\tbase_offset += 1;\n\t\t\tif (!base_offset || MSB(base_offset, 7))\n\t\t\t\treturn 0;  /* overflow */\n\t\t\tc = base_info[used++];\n\t\t\tbase_offset = (base_offset << 7) + (c & 127);\n\t\t}\n\t\tbase_offset = delta_obj_offset - base_offset;\n\t\tif (base_offset <= 0 || base_offset >= delta_obj_offset)\n\t\t\treturn 0;  /* out of bound */\n\t\t*curpos += used;\n\t} else if (type == OBJ_REF_DELTA) {\n\t\t/* The base entry _must_ be in the same pack */\n\t\tstruct object_id oid;\n\t\thashcpy(oid.hash, base_info, the_repository->hash_algo);\n\t\tbase_offset = find_pack_entry_one(&oid, p);\n\t\t*curpos += the_hash_algo->rawsz;\n\t} else\n\t\tdie(\"I am totally screwed\");\n\treturn base_offset;\n}\n\n/*\n * Like get_delta_base above, but we return the sha1 instead of the pack\n * offset. This means it is cheaper for REF deltas (we do not have to do\n * the final object lookup), but more expensive for OFS deltas (we\n * have to load the revidx to convert the offset back into a sha1).\n */\nstatic int get_delta_base_oid(struct packed_git *p,\n\t\t\t      struct pack_window **w_curs,\n\t\t\t      off_t curpos,\n\t\t\t      struct object_id *oid,\n\t\t\t      enum object_type type,\n\t\t\t      off_t delta_obj_offset)\n{\n\tif (type == OBJ_REF_DELTA) {\n\t\tunsigned char *base = use_pack(p, w_curs, curpos, NULL);\n\t\toidread(oid, base, the_repository->hash_algo);\n\t\treturn 0;\n\t} else if (type == OBJ_OFS_DELTA) {\n\t\tuint32_t base_pos;\n\t\toff_t base_offset = get_delta_base(p, w_curs, &curpos,\n\t\t\t\t\t\t   type, delta_obj_offset);\n\n\t\tif (!base_offset)\n\t\t\treturn -1;\n\n\t\tif (offset_to_pack_pos(p, base_offset, &base_pos) < 0)\n\t\t\treturn -1;\n\n\t\treturn nth_packed_object_id(oid, p,\n\t\t\t\t\t    pack_pos_to_index(p, base_pos));\n\t} else\n\t\treturn -1;\n}\n\nstatic int retry_bad_packed_offset(struct repository *r,\n\t\t\t\t   struct packed_git *p,\n\t\t\t\t   off_t obj_offset)\n{\n\tint type;\n\tuint32_t pos;\n\tstruct object_id oid;\n\tif (offset_to_pack_pos(p, obj_offset, &pos) < 0)\n\t\treturn OBJ_BAD;\n\tnth_packed_object_id(&oid, p, pack_pos_to_index(p, pos));\n\tmark_bad_packed_object(p, &oid);\n\ttype = oid_object_info(r, &oid, NULL);\n\tif (type <= OBJ_NONE)\n\t\treturn OBJ_BAD;\n\treturn type;\n}\n\n#define POI_STACK_PREALLOC 64\n\nstatic enum object_type packed_to_object_type(struct repository *r,\n\t\t\t\t\t      struct packed_git *p,\n\t\t\t\t\t      off_t obj_offset,\n\t\t\t\t\t      enum object_type type,\n\t\t\t\t\t      struct pack_window **w_curs,\n\t\t\t\t\t      off_t curpos)\n{\n\toff_t small_poi_stack[POI_STACK_PREALLOC];\n\toff_t *poi_stack = small_poi_stack;\n\tint poi_stack_nr = 0, poi_stack_alloc = POI_STACK_PREALLOC;\n\n\twhile (type == OBJ_OFS_DELTA || type == OBJ_REF_DELTA) {\n\t\toff_t base_offset;\n\t\tunsigned long size;\n\t\t/* Push the object we're going to leave behind */\n\t\tif (poi_stack_nr >= poi_stack_alloc && poi_stack == small_poi_stack) {\n\t\t\tpoi_stack_alloc = alloc_nr(poi_stack_nr);\n\t\t\tALLOC_ARRAY(poi_stack, poi_stack_alloc);\n\t\t\tCOPY_ARRAY(poi_stack, small_poi_stack, poi_stack_nr);\n\t\t} else {\n\t\t\tALLOC_GROW(poi_stack, poi_stack_nr+1, poi_stack_alloc);\n\t\t}\n\t\tpoi_stack[poi_stack_nr++] = obj_offset;\n\t\t/* If parsing the base offset fails, just unwind */\n\t\tbase_offset = get_delta_base(p, w_curs, &curpos, type, obj_offset);\n\t\tif (!base_offset)\n\t\t\tgoto unwind;\n\t\tcurpos = obj_offset = base_offset;\n\t\ttype = unpack_object_header(p, w_curs, &curpos, &size);\n\t\tif (type <= OBJ_NONE) {\n\t\t\t/* If getting the base itself fails, we first\n\t\t\t * retry the base, otherwise unwind */\n\t\t\ttype = retry_bad_packed_offset(r, p, base_offset);\n\t\t\tif (type > OBJ_NONE)\n\t\t\t\tgoto out;\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase OBJ_BAD:\n\tcase OBJ_COMMIT:\n\tcase OBJ_TREE:\n\tcase OBJ_BLOB:\n\tcase OBJ_TAG:\n\t\tbreak;\n\tdefault:\n\t\terror(\"unknown object type %i at offset %\"PRIuMAX\" in %s\",\n\t\t      type, (uintmax_t)obj_offset, p->pack_name);\n\t\ttype = OBJ_BAD;\n\t}\n\nout:\n\tif (poi_stack != small_poi_stack)\n\t\tfree(poi_stack);\n\treturn type;\n\nunwind:\n\twhile (poi_stack_nr) {\n\t\tobj_offset = poi_stack[--poi_stack_nr];\n\t\ttype = retry_bad_packed_offset(r, p, obj_offset);\n\t\tif (type > OBJ_NONE)\n\t\t\tgoto out;\n\t}\n\ttype = OBJ_BAD;\n\tgoto out;\n}\n\nstatic struct hashmap delta_base_cache;\nstatic size_t delta_base_cached;\n\nstatic LIST_HEAD(delta_base_cache_lru);\n\nstruct delta_base_cache_key {\n\tstruct packed_git *p;\n\toff_t base_offset;\n};\n\nstruct delta_base_cache_entry {\n\tstruct hashmap_entry ent;\n\tstruct delta_base_cache_key key;\n\tstruct list_head lru;\n\tvoid *data;\n\tunsigned long size;\n\tenum object_type type;\n};\n\nstatic unsigned int pack_entry_hash(struct packed_git *p, off_t base_offset)\n{\n\tunsigned int hash;\n\n\thash = (unsigned int)(intptr_t)p + (unsigned int)base_offset;\n\thash += (hash >> 8) + (hash >> 16);\n\treturn hash;\n}\n\nstatic struct delta_base_cache_entry *\nget_delta_base_cache_entry(struct packed_git *p, off_t base_offset)\n{\n\tstruct hashmap_entry entry, *e;\n\tstruct delta_base_cache_key key;\n\n\tif (!delta_base_cache.cmpfn)\n\t\treturn NULL;\n\n\thashmap_entry_init(&entry, pack_entry_hash(p, base_offset));\n\tkey.p = p;\n\tkey.base_offset = base_offset;\n\te = hashmap_get(&delta_base_cache, &entry, &key);\n\treturn e ? container_of(e, struct delta_base_cache_entry, ent) : NULL;\n}\n\nstatic int delta_base_cache_key_eq(const struct delta_base_cache_key *a,\n\t\t\t\t   const struct delta_base_cache_key *b)\n{\n\treturn a->p == b->p && a->base_offset == b->base_offset;\n}\n\nstatic int delta_base_cache_hash_cmp(const void *cmp_data UNUSED,\n\t\t\t\t     const struct hashmap_entry *va,\n\t\t\t\t     const struct hashmap_entry *vb,\n\t\t\t\t     const void *vkey)\n{\n\tconst struct delta_base_cache_entry *a, *b;\n\tconst struct delta_base_cache_key *key = vkey;\n\n\ta = container_of(va, const struct delta_base_cache_entry, ent);\n\tb = container_of(vb, const struct delta_base_cache_entry, ent);\n\n\tif (key)\n\t\treturn !delta_base_cache_key_eq(&a->key, key);\n\telse\n\t\treturn !delta_base_cache_key_eq(&a->key, &b->key);\n}\n\nstatic int in_delta_base_cache(struct packed_git *p, off_t base_offset)\n{\n\treturn !!get_delta_base_cache_entry(p, base_offset);\n}\n\n/*\n * Remove the entry from the cache, but do _not_ free the associated\n * entry data. The caller takes ownership of the \"data\" buffer, and\n * should copy out any fields it wants before detaching.\n */\nstatic void detach_delta_base_cache_entry(struct delta_base_cache_entry *ent)\n{\n\thashmap_remove(&delta_base_cache, &ent->ent, &ent->key);\n\tlist_del(&ent->lru);\n\tdelta_base_cached -= ent->size;\n\tfree(ent);\n}\n\nstatic void *cache_or_unpack_entry(struct repository *r, struct packed_git *p,\n\t\t\t\t   off_t base_offset, unsigned long *base_size,\n\t\t\t\t   enum object_type *type)\n{\n\tstruct delta_base_cache_entry *ent;\n\n\tent = get_delta_base_cache_entry(p, base_offset);\n\tif (!ent)\n\t\treturn unpack_entry(r, p, base_offset, type, base_size);\n\n\tif (type)\n\t\t*type = ent->type;\n\tif (base_size)\n\t\t*base_size = ent->size;\n\treturn xmemdupz(ent->data, ent->size);\n}\n\nstatic inline void release_delta_base_cache(struct delta_base_cache_entry *ent)\n{\n\tfree(ent->data);\n\tdetach_delta_base_cache_entry(ent);\n}\n\nvoid clear_delta_base_cache(void)\n{\n\tstruct list_head *lru, *tmp;\n\tlist_for_each_safe(lru, tmp, &delta_base_cache_lru) {\n\t\tstruct delta_base_cache_entry *entry =\n\t\t\tlist_entry(lru, struct delta_base_cache_entry, lru);\n\t\trelease_delta_base_cache(entry);\n\t}\n}\n\nstatic void add_delta_base_cache(struct packed_git *p, off_t base_offset,\n\tvoid *base, unsigned long base_size, enum object_type type)\n{\n\tstruct delta_base_cache_entry *ent;\n\tstruct list_head *lru, *tmp;\n\n\t/*\n\t * Check required to avoid redundant entries when more than one thread\n\t * is unpacking the same object, in unpack_entry() (since its phases I\n\t * and III might run concurrently across multiple threads).\n\t */\n\tif (in_delta_base_cache(p, base_offset)) {\n\t\tfree(base);\n\t\treturn;\n\t}\n\n\tdelta_base_cached += base_size;\n\n\tlist_for_each_safe(lru, tmp, &delta_base_cache_lru) {\n\t\tstruct delta_base_cache_entry *f =\n\t\t\tlist_entry(lru, struct delta_base_cache_entry, lru);\n\t\tif (delta_base_cached <= delta_base_cache_limit)\n\t\t\tbreak;\n\t\trelease_delta_base_cache(f);\n\t}\n\n\tent = xmalloc(sizeof(*ent));\n\tent->key.p = p;\n\tent->key.base_offset = base_offset;\n\tent->type = type;\n\tent->data = base;\n\tent->size = base_size;\n\tlist_add_tail(&ent->lru, &delta_base_cache_lru);\n\n\tif (!delta_base_cache.cmpfn)\n\t\thashmap_init(&delta_base_cache, delta_base_cache_hash_cmp, NULL, 0);\n\thashmap_entry_init(&ent->ent, pack_entry_hash(p, base_offset));\n\thashmap_add(&delta_base_cache, &ent->ent);\n}\n\nint packed_object_info(struct repository *r, struct packed_git *p,\n\t\t       off_t obj_offset, struct object_info *oi)\n{\n\tstruct pack_window *w_curs = NULL;\n\tunsigned long size;\n\toff_t curpos = obj_offset;\n\tenum object_type type;\n\n\t/*\n\t * We always get the representation type, but only convert it to\n\t * a \"real\" type later if the caller is interested.\n\t */\n\tif (oi->contentp) {\n\t\t*oi->contentp = cache_or_unpack_entry(r, p, obj_offset, oi->sizep,\n\t\t\t\t\t\t      &type);\n\t\tif (!*oi->contentp)\n\t\t\ttype = OBJ_BAD;\n\t} else {\n\t\ttype = unpack_object_header(p, &w_curs, &curpos, &size);\n\t}\n\n\tif (!oi->contentp && oi->sizep) {\n\t\tif (type == OBJ_OFS_DELTA || type == OBJ_REF_DELTA) {\n\t\t\toff_t tmp_pos = curpos;\n\t\t\toff_t base_offset = get_delta_base(p, &w_curs, &tmp_pos,\n\t\t\t\t\t\t\t   type, obj_offset);\n\t\t\tif (!base_offset) {\n\t\t\t\ttype = OBJ_BAD;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*oi->sizep = get_size_from_delta(p, &w_curs, tmp_pos);\n\t\t\tif (*oi->sizep == 0) {\n\t\t\t\ttype = OBJ_BAD;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t*oi->sizep = size;\n\t\t}\n\t}\n\n\tif (oi->disk_sizep) {\n\t\tuint32_t pos;\n\t\tif (offset_to_pack_pos(p, obj_offset, &pos) < 0) {\n\t\t\terror(\"could not find object at offset %\"PRIuMAX\" \"\n\t\t\t      \"in pack %s\", (uintmax_t)obj_offset, p->pack_name);\n\t\t\ttype = OBJ_BAD;\n\t\t\tgoto out;\n\t\t}\n\n\t\t*oi->disk_sizep = pack_pos_to_offset(p, pos + 1) - obj_offset;\n\t}\n\n\tif (oi->typep || oi->type_name) {\n\t\tenum object_type ptot;\n\t\tptot = packed_to_object_type(r, p, obj_offset,\n\t\t\t\t\t     type, &w_curs, curpos);\n\t\tif (oi->typep)\n\t\t\t*oi->typep = ptot;\n\t\tif (oi->type_name) {\n\t\t\tconst char *tn = type_name(ptot);\n\t\t\tif (tn)\n\t\t\t\tstrbuf_addstr(oi->type_name, tn);\n\t\t}\n\t\tif (ptot < 0) {\n\t\t\ttype = OBJ_BAD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (oi->delta_base_oid) {\n\t\tif (type == OBJ_OFS_DELTA || type == OBJ_REF_DELTA) {\n\t\t\tif (get_delta_base_oid(p, &w_curs, curpos,\n\t\t\t\t\t       oi->delta_base_oid,\n\t\t\t\t\t       type, obj_offset) < 0) {\n\t\t\t\ttype = OBJ_BAD;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else\n\t\t\toidclr(oi->delta_base_oid, the_repository->hash_algo);\n\t}\n\n\toi->whence = in_delta_base_cache(p, obj_offset) ? OI_DBCACHED :\n\t\t\t\t\t\t\t  OI_PACKED;\n\nout:\n\tunuse_pack(&w_curs);\n\treturn type;\n}\n\nstatic void *unpack_compressed_entry(struct packed_git *p,\n\t\t\t\t    struct pack_window **w_curs,\n\t\t\t\t    off_t curpos,\n\t\t\t\t    unsigned long size)\n{\n\tint st;\n\tgit_zstream stream;\n\tunsigned char *buffer, *in;\n\n\tbuffer = xmallocz_gently(size);\n\tif (!buffer)\n\t\treturn NULL;\n\tmemset(&stream, 0, sizeof(stream));\n\tstream.next_out = buffer;\n\tstream.avail_out = size + 1;\n\n\tgit_inflate_init(&stream);\n\tdo {\n\t\tin = use_pack(p, w_curs, curpos, &stream.avail_in);\n\t\tstream.next_in = in;\n\t\t/*\n\t\t * Note: we must ensure the window section returned by\n\t\t * use_pack() will be available throughout git_inflate()'s\n\t\t * unlocked execution. Please refer to the comment at\n\t\t * get_size_from_delta() to see how this is done.\n\t\t */\n\t\tobj_read_unlock();\n\t\tst = git_inflate(&stream, Z_FINISH);\n\t\tobj_read_lock();\n\t\tif (!stream.avail_out)\n\t\t\tbreak; /* the payload is larger than it should be */\n\t\tcurpos += stream.next_in - in;\n\t} while (st == Z_OK || st == Z_BUF_ERROR);\n\tgit_inflate_end(&stream);\n\tif ((st != Z_STREAM_END) || stream.total_out != size) {\n\t\tfree(buffer);\n\t\treturn NULL;\n\t}\n\n\t/* versions of zlib can clobber unconsumed portion of outbuf */\n\tbuffer[size] = '\\0';\n\n\treturn buffer;\n}\n\nstatic void write_pack_access_log(struct packed_git *p, off_t obj_offset)\n{\n\tstatic struct trace_key pack_access = TRACE_KEY_INIT(PACK_ACCESS);\n\ttrace_printf_key(&pack_access, \"%s %\"PRIuMAX\"\\n\",\n\t\t\t p->pack_name, (uintmax_t)obj_offset);\n}\n\nint do_check_packed_object_crc;\n\n#define UNPACK_ENTRY_STACK_PREALLOC 64\nstruct unpack_entry_stack_ent {\n\toff_t obj_offset;\n\toff_t curpos;\n\tunsigned long size;\n};\n\nvoid *unpack_entry(struct repository *r, struct packed_git *p, off_t obj_offset,\n\t\t   enum object_type *final_type, unsigned long *final_size)\n{\n\tstruct pack_window *w_curs = NULL;\n\toff_t curpos = obj_offset;\n\tvoid *data = NULL;\n\tunsigned long size;\n\tenum object_type type;\n\tstruct unpack_entry_stack_ent small_delta_stack[UNPACK_ENTRY_STACK_PREALLOC];\n\tstruct unpack_entry_stack_ent *delta_stack = small_delta_stack;\n\tint delta_stack_nr = 0, delta_stack_alloc = UNPACK_ENTRY_STACK_PREALLOC;\n\tint base_from_cache = 0;\n\n\twrite_pack_access_log(p, obj_offset);\n\n\t/* PHASE 1: drill down to the innermost base object */\n\tfor (;;) {\n\t\toff_t base_offset;\n\t\tint i;\n\t\tstruct delta_base_cache_entry *ent;\n\n\t\tent = get_delta_base_cache_entry(p, curpos);\n\t\tif (ent) {\n\t\t\ttype = ent->type;\n\t\t\tdata = ent->data;\n\t\t\tsize = ent->size;\n\t\t\tdetach_delta_base_cache_entry(ent);\n\t\t\tbase_from_cache = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (do_check_packed_object_crc && p->index_version > 1) {\n\t\t\tuint32_t pack_pos, index_pos;\n\t\t\toff_t len;\n\n\t\t\tif (offset_to_pack_pos(p, obj_offset, &pack_pos) < 0) {\n\t\t\t\terror(\"could not find object at offset %\"PRIuMAX\" in pack %s\",\n\t\t\t\t      (uintmax_t)obj_offset, p->pack_name);\n\t\t\t\tdata = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlen = pack_pos_to_offset(p, pack_pos + 1) - obj_offset;\n\t\t\tindex_pos = pack_pos_to_index(p, pack_pos);\n\t\t\tif (check_pack_crc(p, &w_curs, obj_offset, len, index_pos)) {\n\t\t\t\tstruct object_id oid;\n\t\t\t\tnth_packed_object_id(&oid, p, index_pos);\n\t\t\t\terror(\"bad packed object CRC for %s\",\n\t\t\t\t      oid_to_hex(&oid));\n\t\t\t\tmark_bad_packed_object(p, &oid);\n\t\t\t\tdata = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\ttype = unpack_object_header(p, &w_curs, &curpos, &size);\n\t\tif (type != OBJ_OFS_DELTA && type != OBJ_REF_DELTA)\n\t\t\tbreak;\n\n\t\tbase_offset = get_delta_base(p, &w_curs, &curpos, type, obj_offset);\n\t\tif (!base_offset) {\n\t\t\terror(\"failed to validate delta base reference \"\n\t\t\t      \"at offset %\"PRIuMAX\" from %s\",\n\t\t\t      (uintmax_t)curpos, p->pack_name);\n\t\t\t/* bail to phase 2, in hopes of recovery */\n\t\t\tdata = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* push object, proceed to base */\n\t\tif (delta_stack_nr >= delta_stack_alloc\n\t\t    && delta_stack == small_delta_stack) {\n\t\t\tdelta_stack_alloc = alloc_nr(delta_stack_nr);\n\t\t\tALLOC_ARRAY(delta_stack, delta_stack_alloc);\n\t\t\tCOPY_ARRAY(delta_stack, small_delta_stack,\n\t\t\t\t   delta_stack_nr);\n\t\t} else {\n\t\t\tALLOC_GROW(delta_stack, delta_stack_nr+1, delta_stack_alloc);\n\t\t}\n\t\ti = delta_stack_nr++;\n\t\tdelta_stack[i].obj_offset = obj_offset;\n\t\tdelta_stack[i].curpos = curpos;\n\t\tdelta_stack[i].size = size;\n\n\t\tcurpos = obj_offset = base_offset;\n\t}\n\n\t/* PHASE 2: handle the base */\n\tswitch (type) {\n\tcase OBJ_OFS_DELTA:\n\tcase OBJ_REF_DELTA:\n\t\tif (data)\n\t\t\tBUG(\"unpack_entry: left loop at a valid delta\");\n\t\tbreak;\n\tcase OBJ_COMMIT:\n\tcase OBJ_TREE:\n\tcase OBJ_BLOB:\n\tcase OBJ_TAG:\n\t\tif (!base_from_cache)\n\t\t\tdata = unpack_compressed_entry(p, &w_curs, curpos, size);\n\t\tbreak;\n\tdefault:\n\t\tdata = NULL;\n\t\terror(\"unknown object type %i at offset %\"PRIuMAX\" in %s\",\n\t\t      type, (uintmax_t)obj_offset, p->pack_name);\n\t}\n\n\t/* PHASE 3: apply deltas in order */\n\n\t/* invariants:\n\t *   'data' holds the base data, or NULL if there was corruption\n\t */\n\twhile (delta_stack_nr) {\n\t\tvoid *delta_data;\n\t\tvoid *base = data;\n\t\tvoid *external_base = NULL;\n\t\tunsigned long delta_size, base_size = size;\n\t\tint i;\n\t\toff_t base_obj_offset = obj_offset;\n\n\t\tdata = NULL;\n\n\t\tif (!base) {\n\t\t\t/*\n\t\t\t * We're probably in deep shit, but let's try to fetch\n\t\t\t * the required base anyway from another pack or loose.\n\t\t\t * This is costly but should happen only in the presence\n\t\t\t * of a corrupted pack, and is better than failing outright.\n\t\t\t */\n\t\t\tuint32_t pos;\n\t\t\tstruct object_id base_oid;\n\t\t\tif (!(offset_to_pack_pos(p, obj_offset, &pos))) {\n\t\t\t\tstruct object_info oi = OBJECT_INFO_INIT;\n\n\t\t\t\tnth_packed_object_id(&base_oid, p,\n\t\t\t\t\t\t     pack_pos_to_index(p, pos));\n\t\t\t\terror(\"failed to read delta base object %s\"\n\t\t\t\t      \" at offset %\"PRIuMAX\" from %s\",\n\t\t\t\t      oid_to_hex(&base_oid), (uintmax_t)obj_offset,\n\t\t\t\t      p->pack_name);\n\t\t\t\tmark_bad_packed_object(p, &base_oid);\n\n\t\t\t\toi.typep = &type;\n\t\t\t\toi.sizep = &base_size;\n\t\t\t\toi.contentp = &base;\n\t\t\t\tif (oid_object_info_extended(r, &base_oid, &oi, 0) < 0)\n\t\t\t\t\tbase = NULL;\n\n\t\t\t\texternal_base = base;\n\t\t\t}\n\t\t}\n\n\t\ti = --delta_stack_nr;\n\t\tobj_offset = delta_stack[i].obj_offset;\n\t\tcurpos = delta_stack[i].curpos;\n\t\tdelta_size = delta_stack[i].size;\n\n\t\tif (!base)\n\t\t\tcontinue;\n\n\t\tdelta_data = unpack_compressed_entry(p, &w_curs, curpos, delta_size);\n\n\t\tif (!delta_data) {\n\t\t\terror(\"failed to unpack compressed delta \"\n\t\t\t      \"at offset %\"PRIuMAX\" from %s\",\n\t\t\t      (uintmax_t)curpos, p->pack_name);\n\t\t\tdata = NULL;\n\t\t} else {\n\t\t\tdata = patch_delta(base, base_size, delta_data,\n\t\t\t\t\t   delta_size, &size);\n\n\t\t\t/*\n\t\t\t * We could not apply the delta; warn the user, but\n\t\t\t * keep going. Our failure will be noticed either in\n\t\t\t * the next iteration of the loop, or if this is the\n\t\t\t * final delta, in the caller when we return NULL.\n\t\t\t * Those code paths will take care of making a more\n\t\t\t * explicit warning and retrying with another copy of\n\t\t\t * the object.\n\t\t\t */\n\t\t\tif (!data)\n\t\t\t\terror(\"failed to apply delta\");\n\t\t}\n\n\t\t/*\n\t\t * We delay adding `base` to the cache until the end of the loop\n\t\t * because unpack_compressed_entry() momentarily releases the\n\t\t * obj_read_mutex, giving another thread the chance to access\n\t\t * the cache. Therefore, if `base` was already there, this other\n\t\t * thread could free() it (e.g. to make space for another entry)\n\t\t * before we are done using it.\n\t\t */\n\t\tif (!external_base)\n\t\t\tadd_delta_base_cache(p, base_obj_offset, base, base_size, type);\n\n\t\tfree(delta_data);\n\t\tfree(external_base);\n\t}\n\n\tif (final_type)\n\t\t*final_type = type;\n\tif (final_size)\n\t\t*final_size = size;\n\nout:\n\tunuse_pack(&w_curs);\n\n\tif (delta_stack != small_delta_stack)\n\t\tfree(delta_stack);\n\n\treturn data;\n}\n\nint bsearch_pack(const struct object_id *oid, const struct packed_git *p, uint32_t *result)\n{\n\tconst unsigned char *index_fanout = p->index_data;\n\tconst unsigned char *index_lookup;\n\tconst unsigned int hashsz = the_hash_algo->rawsz;\n\tint index_lookup_width;\n\n\tif (!index_fanout)\n\t\tBUG(\"bsearch_pack called without a valid pack-index\");\n\n\tindex_lookup = index_fanout + 4 * 256;\n\tif (p->index_version == 1) {\n\t\tindex_lookup_width = hashsz + 4;\n\t\tindex_lookup += 4;\n\t} else {\n\t\tindex_lookup_width = hashsz;\n\t\tindex_fanout += 8;\n\t\tindex_lookup += 8;\n\t}\n\n\treturn bsearch_hash(oid->hash, (const uint32_t*)index_fanout,\n\t\t\t    index_lookup, index_lookup_width, result);\n}\n\nint nth_packed_object_id(struct object_id *oid,\n\t\t\t struct packed_git *p,\n\t\t\t uint32_t n)\n{\n\tconst unsigned char *index = p->index_data;\n\tconst unsigned int hashsz = the_hash_algo->rawsz;\n\tif (!index) {\n\t\tif (open_pack_index(p))\n\t\t\treturn -1;\n\t\tindex = p->index_data;\n\t}\n\tif (n >= p->num_objects)\n\t\treturn -1;\n\tindex += 4 * 256;\n\tif (p->index_version == 1) {\n\t\toidread(oid, index + st_add(st_mult(hashsz + 4, n), 4),\n\t\t\tthe_repository->hash_algo);\n\t} else {\n\t\tindex += 8;\n\t\toidread(oid, index + st_mult(hashsz, n),\n\t\t\tthe_repository->hash_algo);\n\t}\n\treturn 0;\n}\n\nvoid check_pack_index_ptr(const struct packed_git *p, const void *vptr)\n{\n\tconst unsigned char *ptr = vptr;\n\tconst unsigned char *start = p->index_data;\n\tconst unsigned char *end = start + p->index_size;\n\tif (ptr < start)\n\t\tdie(_(\"offset before start of pack index for %s (corrupt index?)\"),\n\t\t    p->pack_name);\n\t/* No need to check for underflow; .idx files must be at least 8 bytes */\n\tif (ptr >= end - 8)\n\t\tdie(_(\"offset beyond end of pack index for %s (truncated index?)\"),\n\t\t    p->pack_name);\n}\n\noff_t nth_packed_object_offset(const struct packed_git *p, uint32_t n)\n{\n\tconst unsigned char *index = p->index_data;\n\tconst unsigned int hashsz = the_hash_algo->rawsz;\n\tindex += 4 * 256;\n\tif (p->index_version == 1) {\n\t\treturn ntohl(*((uint32_t *)(index + st_mult(hashsz + 4, n))));\n\t} else {\n\t\tuint32_t off;\n\t\tindex += st_add(8, st_mult(p->num_objects, hashsz + 4));\n\t\toff = ntohl(*((uint32_t *)(index + st_mult(4, n))));\n\t\tif (!(off & 0x80000000))\n\t\t\treturn off;\n\t\tindex += st_add(st_mult(p->num_objects, 4),\n\t\t\t\tst_mult(off & 0x7fffffff, 8));\n\t\tcheck_pack_index_ptr(p, index);\n\t\treturn get_be64(index);\n\t}\n}\n\noff_t find_pack_entry_one(const struct object_id *oid,\n\t\t\t  struct packed_git *p)\n{\n\tconst unsigned char *index = p->index_data;\n\tuint32_t result;\n\n\tif (!index) {\n\t\tif (open_pack_index(p))\n\t\t\treturn 0;\n\t}\n\n\tif (bsearch_pack(oid, p, &result))\n\t\treturn nth_packed_object_offset(p, result);\n\treturn 0;\n}\n\nint is_pack_valid(struct packed_git *p)\n{\n\t/* An already open pack is known to be valid. */\n\tif (p->pack_fd != -1)\n\t\treturn 1;\n\n\t/* If the pack has one window completely covering the\n\t * file size, the pack is known to be valid even if\n\t * the descriptor is not currently open.\n\t */\n\tif (p->windows) {\n\t\tstruct pack_window *w = p->windows;\n\n\t\tif (!w->offset && w->len == p->pack_size)\n\t\t\treturn 1;\n\t}\n\n\t/* Force the pack to open to prove its valid. */\n\treturn !open_packed_git(p);\n}\n\nstruct packed_git *find_oid_pack(const struct object_id *oid,\n\t\t\t\t struct packed_git *packs)\n{\n\tstruct packed_git *p;\n\n\tfor (p = packs; p; p = p->next) {\n\t\tif (find_pack_entry_one(oid, p))\n\t\t\treturn p;\n\t}\n\treturn NULL;\n\n}\n\nstatic int fill_pack_entry(const struct object_id *oid,\n\t\t\t   struct pack_entry *e,\n\t\t\t   struct packed_git *p)\n{\n\toff_t offset;\n\n\tif (oidset_size(&p->bad_objects) &&\n\t    oidset_contains(&p->bad_objects, oid))\n\t\treturn 0;\n\n\toffset = find_pack_entry_one(oid, p);\n\tif (!offset)\n\t\treturn 0;\n\n\t/*\n\t * We are about to tell the caller where they can locate the\n\t * requested object.  We better make sure the packfile is\n\t * still here and can be accessed before supplying that\n\t * answer, as it may have been deleted since the index was\n\t * loaded!\n\t */\n\tif (!is_pack_valid(p))\n\t\treturn 0;\n\te->offset = offset;\n\te->p = p;\n\treturn 1;\n}\n\nint find_pack_entry(struct repository *r, const struct object_id *oid, struct pack_entry *e)\n{\n\tstruct list_head *pos;\n\tstruct multi_pack_index *m;\n\n\tprepare_packed_git(r);\n\tif (!r->objects->packed_git && !r->objects->multi_pack_index)\n\t\treturn 0;\n\n\tfor (m = r->objects->multi_pack_index; m; m = m->next) {\n\t\tif (fill_midx_entry(r, oid, e, m))\n\t\t\treturn 1;\n\t}\n\n\tlist_for_each(pos, &r->objects->packed_git_mru) {\n\t\tstruct packed_git *p = list_entry(pos, struct packed_git, mru);\n\t\tif (!p->multi_pack_index && fill_pack_entry(oid, e, p)) {\n\t\t\tlist_move(&p->mru, &r->objects->packed_git_mru);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void maybe_invalidate_kept_pack_cache(struct repository *r,\n\t\t\t\t\t     unsigned flags)\n{\n\tif (!r->objects->kept_pack_cache.packs)\n\t\treturn;\n\tif (r->objects->kept_pack_cache.flags == flags)\n\t\treturn;\n\tFREE_AND_NULL(r->objects->kept_pack_cache.packs);\n\tr->objects->kept_pack_cache.flags = 0;\n}\n\nstatic struct packed_git **kept_pack_cache(struct repository *r, unsigned flags)\n{\n\tmaybe_invalidate_kept_pack_cache(r, flags);\n\n\tif (!r->objects->kept_pack_cache.packs) {\n\t\tstruct packed_git **packs = NULL;\n\t\tsize_t nr = 0, alloc = 0;\n\t\tstruct packed_git *p;\n\n\t\t/*\n\t\t * We want \"all\" packs here, because we need to cover ones that\n\t\t * are used by a midx, as well. We need to look in every one of\n\t\t * them (instead of the midx itself) to cover duplicates. It's\n\t\t * possible that an object is found in two packs that the midx\n\t\t * covers, one kept and one not kept, but the midx returns only\n\t\t * the non-kept version.\n\t\t */\n\t\tfor (p = get_all_packs(r); p; p = p->next) {\n\t\t\tif ((p->pack_keep && (flags & ON_DISK_KEEP_PACKS)) ||\n\t\t\t    (p->pack_keep_in_core && (flags & IN_CORE_KEEP_PACKS))) {\n\t\t\t\tALLOC_GROW(packs, nr + 1, alloc);\n\t\t\t\tpacks[nr++] = p;\n\t\t\t}\n\t\t}\n\t\tALLOC_GROW(packs, nr + 1, alloc);\n\t\tpacks[nr] = NULL;\n\n\t\tr->objects->kept_pack_cache.packs = packs;\n\t\tr->objects->kept_pack_cache.flags = flags;\n\t}\n\n\treturn r->objects->kept_pack_cache.packs;\n}\n\nint find_kept_pack_entry(struct repository *r,\n\t\t\t const struct object_id *oid,\n\t\t\t unsigned flags,\n\t\t\t struct pack_entry *e)\n{\n\tstruct packed_git **cache;\n\n\tfor (cache = kept_pack_cache(r, flags); *cache; cache++) {\n\t\tstruct packed_git *p = *cache;\n\t\tif (fill_pack_entry(oid, e, p))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint has_object_pack(const struct object_id *oid)\n{\n\tstruct pack_entry e;\n\treturn find_pack_entry(the_repository, oid, &e);\n}\n\nint has_object_kept_pack(const struct object_id *oid, unsigned flags)\n{\n\tstruct pack_entry e;\n\treturn find_kept_pack_entry(the_repository, oid, flags, &e);\n}\n\nint for_each_object_in_pack(struct packed_git *p,\n\t\t\t    each_packed_object_fn cb, void *data,\n\t\t\t    enum for_each_object_flags flags)\n{\n\tuint32_t i;\n\tint r = 0;\n\n\tif (flags & FOR_EACH_OBJECT_PACK_ORDER) {\n\t\tif (load_pack_revindex(the_repository, p))\n\t\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < p->num_objects; i++) {\n\t\tuint32_t index_pos;\n\t\tstruct object_id oid;\n\n\t\t/*\n\t\t * We are iterating \"i\" from 0 up to num_objects, but its\n\t\t * meaning may be different, depending on the requested output\n\t\t * order:\n\t\t *\n\t\t *   - in object-name order, it is the same as the index order\n\t\t *     used by nth_packed_object_id(), so we can pass it\n\t\t *     directly\n\t\t *\n\t\t *   - in pack-order, it is pack position, which we must\n\t\t *     convert to an index position in order to get the oid.\n\t\t */\n\t\tif (flags & FOR_EACH_OBJECT_PACK_ORDER)\n\t\t\tindex_pos = pack_pos_to_index(p, i);\n\t\telse\n\t\t\tindex_pos = i;\n\n\t\tif (nth_packed_object_id(&oid, p, index_pos) < 0)\n\t\t\treturn error(\"unable to get sha1 of object %u in %s\",\n\t\t\t\t     index_pos, p->pack_name);\n\n\t\tr = cb(&oid, p, index_pos, data);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\treturn r;\n}\n\nint for_each_packed_object(each_packed_object_fn cb, void *data,\n\t\t\t   enum for_each_object_flags flags)\n{\n\tstruct packed_git *p;\n\tint r = 0;\n\tint pack_errors = 0;\n\n\tprepare_packed_git(the_repository);\n\tfor (p = get_all_packs(the_repository); p; p = p->next) {\n\t\tif ((flags & FOR_EACH_OBJECT_LOCAL_ONLY) && !p->pack_local)\n\t\t\tcontinue;\n\t\tif ((flags & FOR_EACH_OBJECT_PROMISOR_ONLY) &&\n\t\t    !p->pack_promisor)\n\t\t\tcontinue;\n\t\tif ((flags & FOR_EACH_OBJECT_SKIP_IN_CORE_KEPT_PACKS) &&\n\t\t    p->pack_keep_in_core)\n\t\t\tcontinue;\n\t\tif ((flags & FOR_EACH_OBJECT_SKIP_ON_DISK_KEPT_PACKS) &&\n\t\t    p->pack_keep)\n\t\t\tcontinue;\n\t\tif (open_pack_index(p)) {\n\t\t\tpack_errors = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tr = for_each_object_in_pack(p, cb, data, flags);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\treturn r ? r : pack_errors;\n}\n\nstatic int add_promisor_object(const struct object_id *oid,\n\t\t\t       struct packed_git *pack UNUSED,\n\t\t\t       uint32_t pos UNUSED,\n\t\t\t       void *set_)\n{\n\tstruct oidset *set = set_;\n\tstruct object *obj;\n\tint we_parsed_object;\n\n\tobj = lookup_object(the_repository, oid);\n\tif (obj && obj->parsed) {\n\t\twe_parsed_object = 0;\n\t} else {\n\t\twe_parsed_object = 1;\n\t\tobj = parse_object(the_repository, oid);\n\t}\n\n\tif (!obj)\n\t\treturn 1;\n\n\toidset_insert(set, oid);\n\n\t/*\n\t * If this is a tree, commit, or tag, the objects it refers\n\t * to are also promisor objects. (Blobs refer to no objects->)\n\t */\n\tif (obj->type == OBJ_TREE) {\n\t\tstruct tree *tree = (struct tree *)obj;\n\t\tstruct tree_desc desc;\n\t\tstruct name_entry entry;\n\t\tif (init_tree_desc_gently(&desc, &tree->object.oid,\n\t\t\t\t\t  tree->buffer, tree->size, 0))\n\t\t\t/*\n\t\t\t * Error messages are given when packs are\n\t\t\t * verified, so do not print any here.\n\t\t\t */\n\t\t\treturn 0;\n\t\twhile (tree_entry_gently(&desc, &entry))\n\t\t\toidset_insert(set, &entry.oid);\n\t\tif (we_parsed_object)\n\t\t\tfree_tree_buffer(tree);\n\t} else if (obj->type == OBJ_COMMIT) {\n\t\tstruct commit *commit = (struct commit *) obj;\n\t\tstruct commit_list *parents = commit->parents;\n\n\t\toidset_insert(set, get_commit_tree_oid(commit));\n\t\tfor (; parents; parents = parents->next)\n\t\t\toidset_insert(set, &parents->item->object.oid);\n\t} else if (obj->type == OBJ_TAG) {\n\t\tstruct tag *tag = (struct tag *) obj;\n\t\toidset_insert(set, get_tagged_oid(tag));\n\t}\n\treturn 0;\n}\n\nint is_promisor_object(const struct object_id *oid)\n{\n\tstatic struct oidset promisor_objects;\n\tstatic int promisor_objects_prepared;\n\n\tif (!promisor_objects_prepared) {\n\t\tif (repo_has_promisor_remote(the_repository)) {\n\t\t\tfor_each_packed_object(add_promisor_object,\n\t\t\t\t\t       &promisor_objects,\n\t\t\t\t\t       FOR_EACH_OBJECT_PROMISOR_ONLY |\n\t\t\t\t\t       FOR_EACH_OBJECT_PACK_ORDER);\n\t\t}\n\t\tpromisor_objects_prepared = 1;\n\t}\n\treturn oidset_contains(&promisor_objects, oid);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "005ca670b4b495887e6b591208e0c88229a40af6",
  "sha1_ok": true,
  "size": 60337
}
