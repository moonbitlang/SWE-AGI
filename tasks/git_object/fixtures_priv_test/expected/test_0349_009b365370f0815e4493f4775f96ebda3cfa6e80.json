{
  "content": {
    "base64": "I2lmbmRlZiBDQUNIRV9ICiNkZWZpbmUgQ0FDSEVfSAoKI2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAic3RyYnVmLmgiCiNpbmNsdWRlICJoYXNoLmgiCiNpbmNsdWRlICJhZHZpY2UuaCIKI2luY2x1ZGUgImdldHRleHQuaCIKCiNpbmNsdWRlIFNIQTFfSEVBREVSCiNpZm5kZWYgZ2l0X1NIQV9DVFgKI2RlZmluZSBnaXRfU0hBX0NUWAlTSEFfQ1RYCiNkZWZpbmUgZ2l0X1NIQTFfSW5pdAlTSEExX0luaXQKI2RlZmluZSBnaXRfU0hBMV9VcGRhdGUJU0hBMV9VcGRhdGUKI2RlZmluZSBnaXRfU0hBMV9GaW5hbAlTSEExX0ZpbmFsCiNlbmRpZgoKI2luY2x1ZGUgPHpsaWIuaD4KI2lmIGRlZmluZWQoTk9fREVGTEFURV9CT1VORCkgfHwgWkxJQl9WRVJOVU0gPCAweDEyMDAKI2RlZmluZSBkZWZsYXRlQm91bmQoYyxzKSAgKChzKSArICgoKHMpICsgNykgPj4gMykgKyAoKChzKSArIDYzKSA+PiA2KSArIDExKQojZW5kaWYKCnZvaWQgZ2l0X2luZmxhdGVfaW5pdCh6X3N0cmVhbXAgc3RybSk7CnZvaWQgZ2l0X2luZmxhdGVfZW5kKHpfc3RyZWFtcCBzdHJtKTsKaW50IGdpdF9pbmZsYXRlKHpfc3RyZWFtcCBzdHJtLCBpbnQgZmx1c2gpOwoKI2lmIGRlZmluZWQoRFRfVU5LTk9XTikgJiYgIWRlZmluZWQoTk9fRF9UWVBFX0lOX0RJUkVOVCkKI2RlZmluZSBEVFlQRShkZSkJKChkZSktPmRfdHlwZSkKI2Vsc2UKI3VuZGVmIERUX1VOS05PV04KI3VuZGVmIERUX0RJUgojdW5kZWYgRFRfUkVHCiN1bmRlZiBEVF9MTksKI2RlZmluZSBEVF9VTktOT1dOCTAKI2RlZmluZSBEVF9ESVIJCTEKI2RlZmluZSBEVF9SRUcJCTIKI2RlZmluZSBEVF9MTksJCTMKI2RlZmluZSBEVFlQRShkZSkJRFRfVU5LTk9XTgojZW5kaWYKCi8qIHVua25vd24gbW9kZSAoaW1wb3NzaWJsZSBjb21iaW5hdGlvbiBTX0lGSUZPfFNfSUZDSFIpICovCiNkZWZpbmUgU19JRklOVkFMSUQgICAgIDAwMzAwMDAKCi8qCiAqIEEgImRpcmVjdG9yeSBsaW5rIiBpcyBhIGxpbmsgdG8gYW5vdGhlciBnaXQgZGlyZWN0b3J5LgogKgogKiBUaGUgdmFsdWUgMDE2MDAwMCBpcyBub3Qgbm9ybWFsbHkgYSB2YWxpZCBtb2RlLCBhbmQKICogYWxzbyBqdXN0IGhhcHBlbnMgdG8gYmUgU19JRkRJUiArIFNfSUZMTksKICoKICogTk9URSEgV2UgKnJlYWxseSogc2hvdWxkbid0IGRlcGVuZCBvbiB0aGUgU19JRnh4eCBtYWNyb3MKICogYWx3YXlzIGhhdmluZyB0aGUgc2FtZSB2YWx1ZXMgZXZlcnl3aGVyZS4gV2Ugc2hvdWxkIHVzZQogKiBvdXIgaW50ZXJuYWwgZ2l0IHZhbHVlcyBmb3IgdGhlc2UgdGhpbmdzLCBhbmQgdGhlbiB3ZSBjYW4KICogdHJhbnNsYXRlIHRoYXQgdG8gdGhlIE9TLXNwZWNpZmljIHZhbHVlLiBJdCBqdXN0IHNvCiAqIGhhcHBlbnMgdGhhdCBldmVyeWJvZHkgc2hhcmVzIHRoZSBzYW1lIGJpdCByZXByZXNlbnRhdGlvbgogKiBpbiB0aGUgVU5JWCB3b3JsZCAoYW5kIGFwcGFyZW50bHkgd2lkZXIgdG9vLi4pCiAqLwojZGVmaW5lIFNfSUZHSVRMSU5LCTAxNjAwMDAKI2RlZmluZSBTX0lTR0lUTElOSyhtKQkoKChtKSAmIFNfSUZNVCkgPT0gU19JRkdJVExJTkspCgovKgogKiBJbnRlbnNpdmUgcmVzZWFyY2ggb3ZlciB0aGUgY291cnNlIG9mIG1hbnkgeWVhcnMgaGFzIHNob3duIHRoYXQKICogcG9ydCA5NDE4IGlzIHRvdGFsbHkgdW51c2VkIGJ5IGFueXRoaW5nIGVsc2UuIE9yCiAqCiAqCVlvdXIgc2VhcmNoIC0gInBvcnQgOTQxOCIgLSBkaWQgbm90IG1hdGNoIGFueSBkb2N1bWVudHMuCiAqCiAqIGFzIHd3dy5nb29nbGUuY29tIHB1dHMgaXQuCiAqCiAqIFRoaXMgcG9ydCBoYXMgYmVlbiBwcm9wZXJseSBhc3NpZ25lZCBmb3IgZ2l0IHVzZSBieSBJQU5BOgogKiBnaXQgKEFzc2lnbmVkLTk0MTgpIFtJMDYtMDUwNzI4LTAwMDFdLgogKgogKglnaXQgIDk0MTgvdGNwICAgZ2l0IHBhY2sgdHJhbnNmZXIgc2VydmljZQogKglnaXQgIDk0MTgvdWRwICAgZ2l0IHBhY2sgdHJhbnNmZXIgc2VydmljZQogKgogKiB3aXRoIExpbnVzIFRvcnZhbGRzIDx0b3J2YWxkc0Bvc2RsLm9yZz4gYXMgdGhlIHBvaW50IG9mCiAqIGNvbnRhY3QuIFNlcHRlbWJlciAyMDA1LgogKgogKiBTZWUgaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9wb3J0LW51bWJlcnMKICovCiNkZWZpbmUgREVGQVVMVF9HSVRfUE9SVCA5NDE4CgovKgogKiBCYXNpYyBkYXRhIHN0cnVjdHVyZXMgZm9yIHRoZSBkaXJlY3RvcnkgY2FjaGUKICovCgojZGVmaW5lIENBQ0hFX1NJR05BVFVSRSAweDQ0NDk1MjQzCS8qICJESVJDIiAqLwpzdHJ1Y3QgY2FjaGVfaGVhZGVyIHsKCXVuc2lnbmVkIGludCBoZHJfc2lnbmF0dXJlOwoJdW5zaWduZWQgaW50IGhkcl92ZXJzaW9uOwoJdW5zaWduZWQgaW50IGhkcl9lbnRyaWVzOwp9OwoKLyoKICogVGhlICJjYWNoZV90aW1lIiBpcyBqdXN0IHRoZSBsb3cgMzIgYml0cyBvZiB0aGUKICogdGltZS4gSXQgZG9lc24ndCBtYXR0ZXIgaWYgaXQgb3ZlcmZsb3dzIC0gd2Ugb25seQogKiBjaGVjayBpdCBmb3IgZXF1YWxpdHkgaW4gdGhlIDMyIGJpdHMgd2Ugc2F2ZS4KICovCnN0cnVjdCBjYWNoZV90aW1lIHsKCXVuc2lnbmVkIGludCBzZWM7Cgl1bnNpZ25lZCBpbnQgbnNlYzsKfTsKCi8qCiAqIGRldi9pbm8vdWlkL2dpZC9zaXplIGFyZSBhbHNvIGp1c3QgdHJhY2tlZCB0byB0aGUgbG93IDMyIGJpdHMKICogQWdhaW4gLSB0aGlzIGlzIGp1c3QgYSAodmVyeSBzdHJvbmcgaW4gcHJhY3RpY2UpIGhldXJpc3RpYyB0aGF0CiAqIHRoZSBpbm9kZSBoYXNuJ3QgY2hhbmdlZC4KICoKICogV2Ugc2F2ZSB0aGUgZmllbGRzIGluIGJpZy1lbmRpYW4gb3JkZXIgdG8gYWxsb3cgdXNpbmcgdGhlCiAqIGluZGV4IGZpbGUgb3ZlciBORlMgdHJhbnNwYXJlbnRseS4KICovCnN0cnVjdCBvbmRpc2tfY2FjaGVfZW50cnkgewoJc3RydWN0IGNhY2hlX3RpbWUgY3RpbWU7CglzdHJ1Y3QgY2FjaGVfdGltZSBtdGltZTsKCXVuc2lnbmVkIGludCBkZXY7Cgl1bnNpZ25lZCBpbnQgaW5vOwoJdW5zaWduZWQgaW50IG1vZGU7Cgl1bnNpZ25lZCBpbnQgdWlkOwoJdW5zaWduZWQgaW50IGdpZDsKCXVuc2lnbmVkIGludCBzaXplOwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCXVuc2lnbmVkIHNob3J0IGZsYWdzOwoJY2hhciBuYW1lW0ZMRVhfQVJSQVldOyAvKiBtb3JlICovCn07CgovKgogKiBUaGlzIHN0cnVjdCBpcyB1c2VkIHdoZW4gQ0VfRVhURU5ERUQgYml0IGlzIDEKICogVGhlIHN0cnVjdCBtdXN0IG1hdGNoIG9uZGlza19jYWNoZV9lbnRyeSBleGFjdGx5IGZyb20KICogY3RpbWUgdGlsbCBmbGFncwogKi8Kc3RydWN0IG9uZGlza19jYWNoZV9lbnRyeV9leHRlbmRlZCB7CglzdHJ1Y3QgY2FjaGVfdGltZSBjdGltZTsKCXN0cnVjdCBjYWNoZV90aW1lIG10aW1lOwoJdW5zaWduZWQgaW50IGRldjsKCXVuc2lnbmVkIGludCBpbm87Cgl1bnNpZ25lZCBpbnQgbW9kZTsKCXVuc2lnbmVkIGludCB1aWQ7Cgl1bnNpZ25lZCBpbnQgZ2lkOwoJdW5zaWduZWQgaW50IHNpemU7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJdW5zaWduZWQgc2hvcnQgZmxhZ3M7Cgl1bnNpZ25lZCBzaG9ydCBmbGFnczI7CgljaGFyIG5hbWVbRkxFWF9BUlJBWV07IC8qIG1vcmUgKi8KfTsKCnN0cnVjdCBjYWNoZV9lbnRyeSB7CglzdHJ1Y3QgY2FjaGVfdGltZSBjZV9jdGltZTsKCXN0cnVjdCBjYWNoZV90aW1lIGNlX210aW1lOwoJdW5zaWduZWQgaW50IGNlX2RldjsKCXVuc2lnbmVkIGludCBjZV9pbm87Cgl1bnNpZ25lZCBpbnQgY2VfbW9kZTsKCXVuc2lnbmVkIGludCBjZV91aWQ7Cgl1bnNpZ25lZCBpbnQgY2VfZ2lkOwoJdW5zaWduZWQgaW50IGNlX3NpemU7Cgl1bnNpZ25lZCBpbnQgY2VfZmxhZ3M7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJc3RydWN0IGNhY2hlX2VudHJ5ICpuZXh0OwoJY2hhciBuYW1lW0ZMRVhfQVJSQVldOyAvKiBtb3JlICovCn07CgojZGVmaW5lIENFX05BTUVNQVNLICAoMHgwZmZmKQojZGVmaW5lIENFX1NUQUdFTUFTSyAoMHgzMDAwKQojZGVmaW5lIENFX0VYVEVOREVEICAoMHg0MDAwKQojZGVmaW5lIENFX1ZBTElEICAgICAoMHg4MDAwKQojZGVmaW5lIENFX1NUQUdFU0hJRlQgMTIKCi8qCiAqIFJhbmdlIDB4RkZGRjAwMDAgaW4gY2VfZmxhZ3MgaXMgZGl2aWRlZCBpbnRvCiAqIHR3byBwYXJ0czogaW4tbWVtb3J5IGZsYWdzIGFuZCBvbi1kaXNrIG9uZXMuCiAqIEZsYWdzIGluIENFX0VYVEVOREVEX0ZMQUdTIHdpbGwgZ2V0IHNhdmVkIG9uLWRpc2sKICogaWYgeW91IHdhbnQgdG8gc2F2ZSBhIG5ldyBmbGFnLCBhZGQgaXQgaW4KICogQ0VfRVhURU5ERURfRkxBR1MKICoKICogSW4tbWVtb3J5IG9ubHkgZmxhZ3MKICovCiNkZWZpbmUgQ0VfVVBEQVRFICAgICAgICAgICAgKDEgPDwgMTYpCiNkZWZpbmUgQ0VfUkVNT1ZFICAgICAgICAgICAgKDEgPDwgMTcpCiNkZWZpbmUgQ0VfVVBUT0RBVEUgICAgICAgICAgKDEgPDwgMTgpCiNkZWZpbmUgQ0VfQURERUQgICAgICAgICAgICAgKDEgPDwgMTkpCgojZGVmaW5lIENFX0hBU0hFRCAgICAgICAgICAgICgxIDw8IDIwKQojZGVmaW5lIENFX1VOSEFTSEVEICAgICAgICAgICgxIDw8IDIxKQojZGVmaW5lIENFX1dUX1JFTU9WRSAgICAgICAgICgxIDw8IDIyKSAvKiByZW1vdmUgaW4gd29yayBkaXJlY3RvcnkgKi8KI2RlZmluZSBDRV9DT05GTElDVEVEICAgICAgICAoMSA8PCAyMykKCiNkZWZpbmUgQ0VfVU5QQUNLRUQgICAgICAgICAgKDEgPDwgMjQpCiNkZWZpbmUgQ0VfTkVXX1NLSVBfV09SS1RSRUUgKDEgPDwgMjUpCgovKgogKiBFeHRlbmRlZCBvbi1kaXNrIGZsYWdzCiAqLwojZGVmaW5lIENFX0lOVEVOVF9UT19BREQgICAgICgxIDw8IDI5KQojZGVmaW5lIENFX1NLSVBfV09SS1RSRUUgICAgICgxIDw8IDMwKQovKiBDRV9FWFRFTkRFRDIgaXMgZm9yIGZ1dHVyZSBleHRlbnNpb24gKi8KI2RlZmluZSBDRV9FWFRFTkRFRDIgICAgICAgICAoMSA8PCAzMSkKCiNkZWZpbmUgQ0VfRVhURU5ERURfRkxBR1MgKENFX0lOVEVOVF9UT19BREQgfCBDRV9TS0lQX1dPUktUUkVFKQoKLyoKICogU2FmZWd1YXJkIHRvIGF2b2lkIHNhdmluZyB3cm9uZyBmbGFnczoKICogIC0gQ0VfRVhURU5ERUQyIHdvbid0IGdldCBzYXZlZCB1bnRpbCBpdHMgc2VtYW50aWMgaXMga25vd24KICogIC0gQml0cyBpbiAweDAwMDBGRkZGIGhhdmUgYmVlbiBzYXZlZCBpbiBjZV9mbGFncyBhbHJlYWR5CiAqICAtIEJpdHMgaW4gMHgwMDNGMDAwMCBhcmUgY3VycmVudGx5IGluLW1lbW9yeSBmbGFncwogKi8KI2lmIENFX0VYVEVOREVEX0ZMQUdTICYgMHg4MDNGRkZGRgojZXJyb3IgIkNFX0VYVEVOREVEX0ZMQUdTIG91dCBvZiByYW5nZSIKI2VuZGlmCgovKgogKiBDb3B5IHRoZSBzaGExIGFuZCBzdGF0IHN0YXRlIG9mIGEgY2FjaGUgZW50cnkgZnJvbSBvbmUgdG8KICogYW5vdGhlci4gQnV0IHdlIG5ldmVyIGNoYW5nZSB0aGUgbmFtZSwgb3IgdGhlIGhhc2ggc3RhdGUhCiAqLwojZGVmaW5lIENFX1NUQVRFX01BU0sgKENFX0hBU0hFRCB8IENFX1VOSEFTSEVEKQpzdGF0aWMgaW5saW5lIHZvaWQgY29weV9jYWNoZV9lbnRyeShzdHJ1Y3QgY2FjaGVfZW50cnkgKmRzdCwgc3RydWN0IGNhY2hlX2VudHJ5ICpzcmMpCnsKCXVuc2lnbmVkIGludCBzdGF0ZSA9IGRzdC0+Y2VfZmxhZ3MgJiBDRV9TVEFURV9NQVNLOwoKCS8qIERvbid0IGNvcHkgaGFzaCBjaGFpbiBhbmQgbmFtZSAqLwoJbWVtY3B5KGRzdCwgc3JjLCBvZmZzZXRvZihzdHJ1Y3QgY2FjaGVfZW50cnksIG5leHQpKTsKCgkvKiBSZXN0b3JlIHRoZSBoYXNoIHN0YXRlICovCglkc3QtPmNlX2ZsYWdzID0gKGRzdC0+Y2VfZmxhZ3MgJiB+Q0VfU1RBVEVfTUFTSykgfCBzdGF0ZTsKfQoKc3RhdGljIGlubGluZSB1bnNpZ25lZCBjcmVhdGVfY2VfZmxhZ3Moc2l6ZV90IGxlbiwgdW5zaWduZWQgc3RhZ2UpCnsKCWlmIChsZW4gPj0gQ0VfTkFNRU1BU0spCgkJbGVuID0gQ0VfTkFNRU1BU0s7CglyZXR1cm4gKGxlbiB8IChzdGFnZSA8PCBDRV9TVEFHRVNISUZUKSk7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90IGNlX25hbWVsZW4oY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSkKewoJc2l6ZV90IGxlbiA9IGNlLT5jZV9mbGFncyAmIENFX05BTUVNQVNLOwoJaWYgKGxlbiA8IENFX05BTUVNQVNLKQoJCXJldHVybiBsZW47CglyZXR1cm4gc3RybGVuKGNlLT5uYW1lICsgQ0VfTkFNRU1BU0spICsgQ0VfTkFNRU1BU0s7Cn0KCiNkZWZpbmUgY2Vfc2l6ZShjZSkgY2FjaGVfZW50cnlfc2l6ZShjZV9uYW1lbGVuKGNlKSkKI2RlZmluZSBvbmRpc2tfY2Vfc2l6ZShjZSkgKCgoY2UpLT5jZV9mbGFncyAmIENFX0VYVEVOREVEKSA/IFwKCQkJICAgIG9uZGlza19jYWNoZV9lbnRyeV9leHRlbmRlZF9zaXplKGNlX25hbWVsZW4oY2UpKSA6IFwKCQkJICAgIG9uZGlza19jYWNoZV9lbnRyeV9zaXplKGNlX25hbWVsZW4oY2UpKSkKI2RlZmluZSBjZV9zdGFnZShjZSkgKChDRV9TVEFHRU1BU0sgJiAoY2UpLT5jZV9mbGFncykgPj4gQ0VfU1RBR0VTSElGVCkKI2RlZmluZSBjZV91cHRvZGF0ZShjZSkgKChjZSktPmNlX2ZsYWdzICYgQ0VfVVBUT0RBVEUpCiNkZWZpbmUgY2Vfc2tpcF93b3JrdHJlZShjZSkgKChjZSktPmNlX2ZsYWdzICYgQ0VfU0tJUF9XT1JLVFJFRSkKI2RlZmluZSBjZV9tYXJrX3VwdG9kYXRlKGNlKSAoKGNlKS0+Y2VfZmxhZ3MgfD0gQ0VfVVBUT0RBVEUpCgojZGVmaW5lIGNlX3Blcm1pc3Npb25zKG1vZGUpICgoKG1vZGUpICYgMDEwMCkgPyAwNzU1IDogMDY0NCkKc3RhdGljIGlubGluZSB1bnNpZ25lZCBpbnQgY3JlYXRlX2NlX21vZGUodW5zaWduZWQgaW50IG1vZGUpCnsKCWlmIChTX0lTTE5LKG1vZGUpKQoJCXJldHVybiBTX0lGTE5LOwoJaWYgKFNfSVNESVIobW9kZSkgfHwgU19JU0dJVExJTksobW9kZSkpCgkJcmV0dXJuIFNfSUZHSVRMSU5LOwoJcmV0dXJuIFNfSUZSRUcgfCBjZV9wZXJtaXNzaW9ucyhtb2RlKTsKfQpzdGF0aWMgaW5saW5lIHVuc2lnbmVkIGludCBjZV9tb2RlX2Zyb21fc3RhdChzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCB1bnNpZ25lZCBpbnQgbW9kZSkKewoJZXh0ZXJuIGludCB0cnVzdF9leGVjdXRhYmxlX2JpdCwgaGFzX3N5bWxpbmtzOwoJaWYgKCFoYXNfc3ltbGlua3MgJiYgU19JU1JFRyhtb2RlKSAmJgoJICAgIGNlICYmIFNfSVNMTksoY2UtPmNlX21vZGUpKQoJCXJldHVybiBjZS0+Y2VfbW9kZTsKCWlmICghdHJ1c3RfZXhlY3V0YWJsZV9iaXQgJiYgU19JU1JFRyhtb2RlKSkgewoJCWlmIChjZSAmJiBTX0lTUkVHKGNlLT5jZV9tb2RlKSkKCQkJcmV0dXJuIGNlLT5jZV9tb2RlOwoJCXJldHVybiBjcmVhdGVfY2VfbW9kZSgwNjY2KTsKCX0KCXJldHVybiBjcmVhdGVfY2VfbW9kZShtb2RlKTsKfQpzdGF0aWMgaW5saW5lIGludCBjZV90b19kdHlwZShjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKQp7Cgl1bnNpZ25lZCBjZV9tb2RlID0gbnRvaGwoY2UtPmNlX21vZGUpOwoJaWYgKFNfSVNSRUcoY2VfbW9kZSkpCgkJcmV0dXJuIERUX1JFRzsKCWVsc2UgaWYgKFNfSVNESVIoY2VfbW9kZSkgfHwgU19JU0dJVExJTksoY2VfbW9kZSkpCgkJcmV0dXJuIERUX0RJUjsKCWVsc2UgaWYgKFNfSVNMTksoY2VfbW9kZSkpCgkJcmV0dXJuIERUX0xOSzsKCWVsc2UKCQlyZXR1cm4gRFRfVU5LTk9XTjsKfQpzdGF0aWMgaW5saW5lIHVuc2lnbmVkIGludCBjYW5vbl9tb2RlKHVuc2lnbmVkIGludCBtb2RlKQp7CglpZiAoU19JU1JFRyhtb2RlKSkKCQlyZXR1cm4gU19JRlJFRyB8IGNlX3Blcm1pc3Npb25zKG1vZGUpOwoJaWYgKFNfSVNMTksobW9kZSkpCgkJcmV0dXJuIFNfSUZMTks7CglpZiAoU19JU0RJUihtb2RlKSkKCQlyZXR1cm4gU19JRkRJUjsKCXJldHVybiBTX0lGR0lUTElOSzsKfQoKI2RlZmluZSBmbGV4aWJsZV9zaXplKFNUUlVDVCxsZW4pICgob2Zmc2V0b2Yoc3RydWN0IFNUUlVDVCxuYW1lKSArIChsZW4pICsgOCkgJiB+NykKI2RlZmluZSBjYWNoZV9lbnRyeV9zaXplKGxlbikgZmxleGlibGVfc2l6ZShjYWNoZV9lbnRyeSxsZW4pCiNkZWZpbmUgb25kaXNrX2NhY2hlX2VudHJ5X3NpemUobGVuKSBmbGV4aWJsZV9zaXplKG9uZGlza19jYWNoZV9lbnRyeSxsZW4pCiNkZWZpbmUgb25kaXNrX2NhY2hlX2VudHJ5X2V4dGVuZGVkX3NpemUobGVuKSBmbGV4aWJsZV9zaXplKG9uZGlza19jYWNoZV9lbnRyeV9leHRlbmRlZCxsZW4pCgpzdHJ1Y3QgaW5kZXhfc3RhdGUgewoJc3RydWN0IGNhY2hlX2VudHJ5ICoqY2FjaGU7Cgl1bnNpZ25lZCBpbnQgY2FjaGVfbnIsIGNhY2hlX2FsbG9jLCBjYWNoZV9jaGFuZ2VkOwoJc3RydWN0IHN0cmluZ19saXN0ICpyZXNvbHZlX3VuZG87CglzdHJ1Y3QgY2FjaGVfdHJlZSAqY2FjaGVfdHJlZTsKCXN0cnVjdCBjYWNoZV90aW1lIHRpbWVzdGFtcDsKCXZvaWQgKmFsbG9jOwoJdW5zaWduZWQgbmFtZV9oYXNoX2luaXRpYWxpemVkIDogMSwKCQkgaW5pdGlhbGl6ZWQgOiAxOwoJc3RydWN0IGhhc2hfdGFibGUgbmFtZV9oYXNoOwp9OwoKZXh0ZXJuIHN0cnVjdCBpbmRleF9zdGF0ZSB0aGVfaW5kZXg7CgovKiBOYW1lIGhhc2hpbmcgKi8KZXh0ZXJuIHZvaWQgYWRkX25hbWVfaGFzaChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSk7Ci8qCiAqIFdlIGRvbid0IGFjdHVhbGx5ICpyZW1vdmUqIGl0LCB3ZSBjYW4ganVzdCBtYXJrIGl0IGludmFsaWQgc28gdGhhdAogKiB3ZSB3b24ndCBmaW5kIGl0IGluIGxvb2t1cHMuCiAqCiAqIE5vdCBvbmx5IHdvdWxkIHdlIGhhdmUgdG8gc2VhcmNoIHRoZSBsaXN0cyAoc2ltcGxlIGVub3VnaCksIGJ1dAogKiB3ZSdkIGFsc28gaGF2ZSB0byByZWhhc2ggb3RoZXIgaGFzaCBidWNrZXRzIGluIGNhc2UgdGhpcyBtYWtlcyB0aGUKICogaGFzaCBidWNrZXQgZW1wdHkgKGNvbW1vbikuIFNvIGl0J3MgbXVjaCBiZXR0ZXIgdG8ganVzdCBtYXJrCiAqIGl0LgogKi8Kc3RhdGljIGlubGluZSB2b2lkIHJlbW92ZV9uYW1lX2hhc2goc3RydWN0IGNhY2hlX2VudHJ5ICpjZSkKewoJY2UtPmNlX2ZsYWdzIHw9IENFX1VOSEFTSEVEOwp9CgoKI2lmbmRlZiBOT19USEVfSU5ERVhfQ09NUEFUSUJJTElUWV9NQUNST1MKI2RlZmluZSBhY3RpdmVfY2FjaGUgKHRoZV9pbmRleC5jYWNoZSkKI2RlZmluZSBhY3RpdmVfbnIgKHRoZV9pbmRleC5jYWNoZV9ucikKI2RlZmluZSBhY3RpdmVfYWxsb2MgKHRoZV9pbmRleC5jYWNoZV9hbGxvYykKI2RlZmluZSBhY3RpdmVfY2FjaGVfY2hhbmdlZCAodGhlX2luZGV4LmNhY2hlX2NoYW5nZWQpCiNkZWZpbmUgYWN0aXZlX2NhY2hlX3RyZWUgKHRoZV9pbmRleC5jYWNoZV90cmVlKQoKI2RlZmluZSByZWFkX2NhY2hlKCkgcmVhZF9pbmRleCgmdGhlX2luZGV4KQojZGVmaW5lIHJlYWRfY2FjaGVfZnJvbShwYXRoKSByZWFkX2luZGV4X2Zyb20oJnRoZV9pbmRleCwgKHBhdGgpKQojZGVmaW5lIHJlYWRfY2FjaGVfcHJlbG9hZChwYXRoc3BlYykgcmVhZF9pbmRleF9wcmVsb2FkKCZ0aGVfaW5kZXgsIChwYXRoc3BlYykpCiNkZWZpbmUgaXNfY2FjaGVfdW5ib3JuKCkgaXNfaW5kZXhfdW5ib3JuKCZ0aGVfaW5kZXgpCiNkZWZpbmUgcmVhZF9jYWNoZV91bm1lcmdlZCgpIHJlYWRfaW5kZXhfdW5tZXJnZWQoJnRoZV9pbmRleCkKI2RlZmluZSB3cml0ZV9jYWNoZShuZXdmZCwgY2FjaGUsIGVudHJpZXMpIHdyaXRlX2luZGV4KCZ0aGVfaW5kZXgsIChuZXdmZCkpCiNkZWZpbmUgZGlzY2FyZF9jYWNoZSgpIGRpc2NhcmRfaW5kZXgoJnRoZV9pbmRleCkKI2RlZmluZSB1bm1lcmdlZF9jYWNoZSgpIHVubWVyZ2VkX2luZGV4KCZ0aGVfaW5kZXgpCiNkZWZpbmUgY2FjaGVfbmFtZV9wb3MobmFtZSwgbmFtZWxlbikgaW5kZXhfbmFtZV9wb3MoJnRoZV9pbmRleCwobmFtZSksKG5hbWVsZW4pKQojZGVmaW5lIGFkZF9jYWNoZV9lbnRyeShjZSwgb3B0aW9uKSBhZGRfaW5kZXhfZW50cnkoJnRoZV9pbmRleCwgKGNlKSwgKG9wdGlvbikpCiNkZWZpbmUgcmVuYW1lX2NhY2hlX2VudHJ5X2F0KHBvcywgbmV3X25hbWUpIHJlbmFtZV9pbmRleF9lbnRyeV9hdCgmdGhlX2luZGV4LCAocG9zKSwgKG5ld19uYW1lKSkKI2RlZmluZSByZW1vdmVfY2FjaGVfZW50cnlfYXQocG9zKSByZW1vdmVfaW5kZXhfZW50cnlfYXQoJnRoZV9pbmRleCwgKHBvcykpCiNkZWZpbmUgcmVtb3ZlX2ZpbGVfZnJvbV9jYWNoZShwYXRoKSByZW1vdmVfZmlsZV9mcm9tX2luZGV4KCZ0aGVfaW5kZXgsIChwYXRoKSkKI2RlZmluZSBhZGRfdG9fY2FjaGUocGF0aCwgc3QsIGZsYWdzKSBhZGRfdG9faW5kZXgoJnRoZV9pbmRleCwgKHBhdGgpLCAoc3QpLCAoZmxhZ3MpKQojZGVmaW5lIGFkZF9maWxlX3RvX2NhY2hlKHBhdGgsIGZsYWdzKSBhZGRfZmlsZV90b19pbmRleCgmdGhlX2luZGV4LCAocGF0aCksIChmbGFncykpCiNkZWZpbmUgcmVmcmVzaF9jYWNoZShmbGFncykgcmVmcmVzaF9pbmRleCgmdGhlX2luZGV4LCAoZmxhZ3MpLCBOVUxMLCBOVUxMLCBOVUxMKQojZGVmaW5lIGNlX21hdGNoX3N0YXQoY2UsIHN0LCBvcHRpb25zKSBpZV9tYXRjaF9zdGF0KCZ0aGVfaW5kZXgsIChjZSksIChzdCksIChvcHRpb25zKSkKI2RlZmluZSBjZV9tb2RpZmllZChjZSwgc3QsIG9wdGlvbnMpIGllX21vZGlmaWVkKCZ0aGVfaW5kZXgsIChjZSksIChzdCksIChvcHRpb25zKSkKI2RlZmluZSBjYWNoZV9uYW1lX2V4aXN0cyhuYW1lLCBuYW1lbGVuLCBpZ25jYXNlKSBpbmRleF9uYW1lX2V4aXN0cygmdGhlX2luZGV4LCAobmFtZSksIChuYW1lbGVuKSwgKGlnbmNhc2UpKQojZGVmaW5lIGNhY2hlX25hbWVfaXNfb3RoZXIobmFtZSwgbmFtZWxlbikgaW5kZXhfbmFtZV9pc19vdGhlcigmdGhlX2luZGV4LCAobmFtZSksIChuYW1lbGVuKSkKI2RlZmluZSByZXNvbHZlX3VuZG9fY2xlYXIoKSByZXNvbHZlX3VuZG9fY2xlYXJfaW5kZXgoJnRoZV9pbmRleCkKI2RlZmluZSB1bm1lcmdlX2NhY2hlX2VudHJ5X2F0KGF0KSB1bm1lcmdlX2luZGV4X2VudHJ5X2F0KCZ0aGVfaW5kZXgsIGF0KQojZGVmaW5lIHVubWVyZ2VfY2FjaGUocGF0aHNwZWMpIHVubWVyZ2VfaW5kZXgoJnRoZV9pbmRleCwgcGF0aHNwZWMpCiNlbmRpZgoKZW51bSBvYmplY3RfdHlwZSB7CglPQkpfQkFEID0gLTEsCglPQkpfTk9ORSA9IDAsCglPQkpfQ09NTUlUID0gMSwKCU9CSl9UUkVFID0gMiwKCU9CSl9CTE9CID0gMywKCU9CSl9UQUcgPSA0LAoJLyogNSBmb3IgZnV0dXJlIGV4cGFuc2lvbiAqLwoJT0JKX09GU19ERUxUQSA9IDYsCglPQkpfUkVGX0RFTFRBID0gNywKCU9CSl9BTlksCglPQkpfTUFYCn07CgpzdGF0aWMgaW5saW5lIGVudW0gb2JqZWN0X3R5cGUgb2JqZWN0X3R5cGUodW5zaWduZWQgaW50IG1vZGUpCnsKCXJldHVybiBTX0lTRElSKG1vZGUpID8gT0JKX1RSRUUgOgoJCVNfSVNHSVRMSU5LKG1vZGUpID8gT0JKX0NPTU1JVCA6CgkJT0JKX0JMT0I7Cn0KCiNkZWZpbmUgR0lUX0RJUl9FTlZJUk9OTUVOVCAiR0lUX0RJUiIKI2RlZmluZSBHSVRfV09SS19UUkVFX0VOVklST05NRU5UICJHSVRfV09SS19UUkVFIgojZGVmaW5lIERFRkFVTFRfR0lUX0RJUl9FTlZJUk9OTUVOVCAiLmdpdCIKI2RlZmluZSBEQl9FTlZJUk9OTUVOVCAiR0lUX09CSkVDVF9ESVJFQ1RPUlkiCiNkZWZpbmUgSU5ERVhfRU5WSVJPTk1FTlQgIkdJVF9JTkRFWF9GSUxFIgojZGVmaW5lIEdSQUZUX0VOVklST05NRU5UICJHSVRfR1JBRlRfRklMRSIKI2RlZmluZSBURU1QTEFURV9ESVJfRU5WSVJPTk1FTlQgIkdJVF9URU1QTEFURV9ESVIiCiNkZWZpbmUgQ09ORklHX0VOVklST05NRU5UICJHSVRfQ09ORklHIgojZGVmaW5lIENPTkZJR19EQVRBX0VOVklST05NRU5UICJHSVRfQ09ORklHX1BBUkFNRVRFUlMiCiNkZWZpbmUgRVhFQ19QQVRIX0VOVklST05NRU5UICJHSVRfRVhFQ19QQVRIIgojZGVmaW5lIENFSUxJTkdfRElSRUNUT1JJRVNfRU5WSVJPTk1FTlQgIkdJVF9DRUlMSU5HX0RJUkVDVE9SSUVTIgojZGVmaW5lIE5PX1JFUExBQ0VfT0JKRUNUU19FTlZJUk9OTUVOVCAiR0lUX05PX1JFUExBQ0VfT0JKRUNUUyIKI2RlZmluZSBHSVRBVFRSSUJVVEVTX0ZJTEUgIi5naXRhdHRyaWJ1dGVzIgojZGVmaW5lIElORk9BVFRSSUJVVEVTX0ZJTEUgImluZm8vYXR0cmlidXRlcyIKI2RlZmluZSBBVFRSSUJVVEVfTUFDUk9fUFJFRklYICJbYXR0cl0iCiNkZWZpbmUgR0lUX05PVEVTX1JFRl9FTlZJUk9OTUVOVCAiR0lUX05PVEVTX1JFRiIKI2RlZmluZSBHSVRfTk9URVNfREVGQVVMVF9SRUYgInJlZnMvbm90ZXMvY29tbWl0cyIKI2RlZmluZSBHSVRfTk9URVNfRElTUExBWV9SRUZfRU5WSVJPTk1FTlQgIkdJVF9OT1RFU19ESVNQTEFZX1JFRiIKI2RlZmluZSBHSVRfTk9URVNfUkVXUklURV9SRUZfRU5WSVJPTk1FTlQgIkdJVF9OT1RFU19SRVdSSVRFX1JFRiIKI2RlZmluZSBHSVRfTk9URVNfUkVXUklURV9NT0RFX0VOVklST05NRU5UICJHSVRfTk9URVNfUkVXUklURV9NT0RFIgoKLyoKICogUmVwb3NpdG9yeS1sb2NhbCBHSVRfKiBlbnZpcm9ubWVudCB2YXJpYWJsZXMKICogVGhlIGFycmF5IGlzIE5VTEwtdGVybWluYXRlZCB0byBzaW1wbGlmeSBpdHMgdXNhZ2UgaW4gY29udGV4dHMgc3VjaAogKiBlbnZpcm9ubWVudCBjcmVhdGlvbiBvciBzaW1wbGUgd2FsayBvZiB0aGUgbGlzdC4KICogVGhlIG51bWJlciBvZiBub24tTlVMTCBlbnRyaWVzIGlzIGF2YWlsYWJsZSBhcyBhIG1hY3JvLgogKi8KI2RlZmluZSBMT0NBTF9SRVBPX0VOVl9TSVpFIDkKZXh0ZXJuIGNvbnN0IGNoYXIgKmNvbnN0IGxvY2FsX3JlcG9fZW52W0xPQ0FMX1JFUE9fRU5WX1NJWkUgKyAxXTsKCmV4dGVybiBpbnQgaXNfYmFyZV9yZXBvc2l0b3J5X2NmZzsKZXh0ZXJuIGludCBpc19iYXJlX3JlcG9zaXRvcnkodm9pZCk7CmV4dGVybiBpbnQgaXNfaW5zaWRlX2dpdF9kaXIodm9pZCk7CmV4dGVybiBjaGFyICpnaXRfd29ya190cmVlX2NmZzsKZXh0ZXJuIGludCBpc19pbnNpZGVfd29ya190cmVlKHZvaWQpOwpleHRlcm4gaW50IGhhdmVfZ2l0X2Rpcih2b2lkKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdldF9naXRfZGlyKHZvaWQpOwpleHRlcm4gY2hhciAqZ2V0X29iamVjdF9kaXJlY3Rvcnkodm9pZCk7CmV4dGVybiBjaGFyICpnZXRfaW5kZXhfZmlsZSh2b2lkKTsKZXh0ZXJuIGNoYXIgKmdldF9ncmFmdF9maWxlKHZvaWQpOwpleHRlcm4gaW50IHNldF9naXRfZGlyKGNvbnN0IGNoYXIgKnBhdGgpOwpleHRlcm4gY29uc3QgY2hhciAqZ2V0X2dpdF93b3JrX3RyZWUodm9pZCk7CmV4dGVybiBjb25zdCBjaGFyICpyZWFkX2dpdGZpbGVfZ2VudGx5KGNvbnN0IGNoYXIgKnBhdGgpOwpleHRlcm4gdm9pZCBzZXRfZ2l0X3dvcmtfdHJlZShjb25zdCBjaGFyICp0cmVlKTsKCiNkZWZpbmUgQUxURVJOQVRFX0RCX0VOVklST05NRU5UICJHSVRfQUxURVJOQVRFX09CSkVDVF9ESVJFQ1RPUklFUyIKCmV4dGVybiBjb25zdCBjaGFyICoqZ2V0X3BhdGhzcGVjKGNvbnN0IGNoYXIgKnByZWZpeCwgY29uc3QgY2hhciAqKnBhdGhzcGVjKTsKZXh0ZXJuIHZvaWQgc2V0dXBfd29ya190cmVlKHZvaWQpOwpleHRlcm4gY29uc3QgY2hhciAqc2V0dXBfZ2l0X2RpcmVjdG9yeV9nZW50bHkoaW50ICopOwpleHRlcm4gY29uc3QgY2hhciAqc2V0dXBfZ2l0X2RpcmVjdG9yeSh2b2lkKTsKZXh0ZXJuIGNoYXIgKnByZWZpeF9wYXRoKGNvbnN0IGNoYXIgKnByZWZpeCwgaW50IGxlbiwgY29uc3QgY2hhciAqcGF0aCk7CmV4dGVybiBjb25zdCBjaGFyICpwcmVmaXhfZmlsZW5hbWUoY29uc3QgY2hhciAqcHJlZml4LCBpbnQgbGVuLCBjb25zdCBjaGFyICpwYXRoKTsKZXh0ZXJuIGludCBjaGVja19maWxlbmFtZShjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IGNoYXIgKm5hbWUpOwpleHRlcm4gdm9pZCB2ZXJpZnlfZmlsZW5hbWUoY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCBjaGFyICpuYW1lKTsKZXh0ZXJuIHZvaWQgdmVyaWZ5X25vbl9maWxlbmFtZShjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IGNoYXIgKm5hbWUpOwoKI2RlZmluZSBJTklUX0RCX1FVSUVUIDB4MDAwMQoKZXh0ZXJuIGludCBzZXRfZ2l0X2Rpcl9pbml0KGNvbnN0IGNoYXIgKmdpdF9kaXIsIGNvbnN0IGNoYXIgKnJlYWxfZ2l0X2RpciwgaW50KTsKZXh0ZXJuIGludCBpbml0X2RiKGNvbnN0IGNoYXIgKnRlbXBsYXRlX2RpciwgdW5zaWduZWQgaW50IGZsYWdzKTsKCiNkZWZpbmUgYWxsb2NfbnIoeCkgKCgoeCkrMTYpKjMvMikKCi8qCiAqIFJlYWxsb2MgdGhlIGJ1ZmZlciBwb2ludGVkIGF0IGJ5IHZhcmlhYmxlICd4JyBzbyB0aGF0IGl0IGNhbiBob2xkCiAqIGF0IGxlYXN0ICducicgZW50cmllczsgdGhlIG51bWJlciBvZiBlbnRyaWVzIGN1cnJlbnRseSBhbGxvY2F0ZWQKICogaXMgJ2FsbG9jJywgdXNpbmcgdGhlIHN0YW5kYXJkIGdyb3dpbmcgZmFjdG9yIGFsbG9jX25yKCkgbWFjcm8uCiAqCiAqIERPIE5PVCBVU0UgYW55IGV4cHJlc3Npb24gd2l0aCBzaWRlLWVmZmVjdCBmb3IgJ3gnLCAnbnInLCBvciAnYWxsb2MnLgogKi8KI2RlZmluZSBBTExPQ19HUk9XKHgsIG5yLCBhbGxvYykgXAoJZG8geyBcCgkJaWYgKChucikgPiBhbGxvYykgeyBcCgkJCWlmIChhbGxvY19ucihhbGxvYykgPCAobnIpKSBcCgkJCQlhbGxvYyA9IChucik7IFwKCQkJZWxzZSBcCgkJCQlhbGxvYyA9IGFsbG9jX25yKGFsbG9jKTsgXAoJCQl4ID0geHJlYWxsb2MoKHgpLCBhbGxvYyAqIHNpemVvZigqKHgpKSk7IFwKCQl9IFwKCX0gd2hpbGUgKDApCgovKiBJbml0aWFsaXplIGFuZCB1c2UgdGhlIGNhY2hlIGluZm9ybWF0aW9uICovCmV4dGVybiBpbnQgcmVhZF9pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKik7CmV4dGVybiBpbnQgcmVhZF9pbmRleF9wcmVsb2FkKHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBjb25zdCBjaGFyICoqcGF0aHNwZWMpOwpleHRlcm4gaW50IHJlYWRfaW5kZXhfZnJvbShzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgY29uc3QgY2hhciAqcGF0aCk7CmV4dGVybiBpbnQgaXNfaW5kZXhfdW5ib3JuKHN0cnVjdCBpbmRleF9zdGF0ZSAqKTsKZXh0ZXJuIGludCByZWFkX2luZGV4X3VubWVyZ2VkKHN0cnVjdCBpbmRleF9zdGF0ZSAqKTsKZXh0ZXJuIGludCB3cml0ZV9pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgaW50IG5ld2ZkKTsKZXh0ZXJuIGludCBkaXNjYXJkX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqKTsKZXh0ZXJuIGludCB1bm1lcmdlZF9pbmRleChjb25zdCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKik7CmV4dGVybiBpbnQgdmVyaWZ5X3BhdGgoY29uc3QgY2hhciAqcGF0aCk7CmV4dGVybiBzdHJ1Y3QgY2FjaGVfZW50cnkgKmluZGV4X25hbWVfZXhpc3RzKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbiwgaW50IGlnbmNhc2UpOwpleHRlcm4gaW50IGluZGV4X25hbWVfcG9zKGNvbnN0IHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbik7CiNkZWZpbmUgQUREX0NBQ0hFX09LX1RPX0FERCAxCQkvKiBPayB0byBhZGQgKi8KI2RlZmluZSBBRERfQ0FDSEVfT0tfVE9fUkVQTEFDRSAyCS8qIE9rIHRvIHJlcGxhY2UgZmlsZS9kaXJlY3RvcnkgKi8KI2RlZmluZSBBRERfQ0FDSEVfU0tJUF9ERkNIRUNLIDQJLyogT2sgdG8gc2tpcCBERiBjb25mbGljdCBjaGVja3MgKi8KI2RlZmluZSBBRERfQ0FDSEVfSlVTVF9BUFBFTkQgOAkJLyogQXBwZW5kIG9ubHk7IHRyZWUuYzo6cmVhZF90cmVlKCkgKi8KI2RlZmluZSBBRERfQ0FDSEVfTkVXX09OTFkgMTYJCS8qIERvIG5vdCByZXBsYWNlIGV4aXN0aW5nIG9uZXMgKi8KZXh0ZXJuIGludCBhZGRfaW5kZXhfZW50cnkoc3RydWN0IGluZGV4X3N0YXRlICosIHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIGludCBvcHRpb24pOwpleHRlcm4gdm9pZCByZW5hbWVfaW5kZXhfZW50cnlfYXQoc3RydWN0IGluZGV4X3N0YXRlICosIGludCBwb3MsIGNvbnN0IGNoYXIgKm5ld19uYW1lKTsKZXh0ZXJuIGludCByZW1vdmVfaW5kZXhfZW50cnlfYXQoc3RydWN0IGluZGV4X3N0YXRlICosIGludCBwb3MpOwpleHRlcm4gdm9pZCByZW1vdmVfbWFya2VkX2NhY2hlX2VudHJpZXMoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUpOwpleHRlcm4gaW50IHJlbW92ZV9maWxlX2Zyb21faW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICosIGNvbnN0IGNoYXIgKnBhdGgpOwojZGVmaW5lIEFERF9DQUNIRV9WRVJCT1NFIDEKI2RlZmluZSBBRERfQ0FDSEVfUFJFVEVORCAyCiNkZWZpbmUgQUREX0NBQ0hFX0lHTk9SRV9FUlJPUlMJNAojZGVmaW5lIEFERF9DQUNIRV9JR05PUkVfUkVNT1ZBTCA4CiNkZWZpbmUgQUREX0NBQ0hFX0lOVEVOVCAxNgpleHRlcm4gaW50IGFkZF90b19pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgY29uc3QgY2hhciAqcGF0aCwgc3RydWN0IHN0YXQgKiwgaW50IGZsYWdzKTsKZXh0ZXJuIGludCBhZGRfZmlsZV90b19pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgY29uc3QgY2hhciAqcGF0aCwgaW50IGZsYWdzKTsKZXh0ZXJuIHN0cnVjdCBjYWNoZV9lbnRyeSAqbWFrZV9jYWNoZV9lbnRyeSh1bnNpZ25lZCBpbnQgbW9kZSwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgY29uc3QgY2hhciAqcGF0aCwgaW50IHN0YWdlLCBpbnQgcmVmcmVzaCk7CmV4dGVybiBpbnQgY2Vfc2FtZV9uYW1lKHN0cnVjdCBjYWNoZV9lbnRyeSAqYSwgc3RydWN0IGNhY2hlX2VudHJ5ICpiKTsKZXh0ZXJuIGludCBpbmRleF9uYW1lX2lzX290aGVyKGNvbnN0IHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBjb25zdCBjaGFyICosIGludCk7CgovKiBkbyBzdGF0IGNvbXBhcmlzb24gZXZlbiBpZiBDRV9WQUxJRCBpcyB0cnVlICovCiNkZWZpbmUgQ0VfTUFUQ0hfSUdOT1JFX1ZBTElECQkwMQovKiBkbyBub3QgY2hlY2sgdGhlIGNvbnRlbnRzIGJ1dCByZXBvcnQgZGlydHkgb24gcmFjaWx5LWNsZWFuIGVudHJpZXMgKi8KI2RlZmluZSBDRV9NQVRDSF9SQUNZX0lTX0RJUlRZCQkwMgovKiBkbyBzdGF0IGNvbXBhcmlzb24gZXZlbiBpZiBDRV9TS0lQX1dPUktUUkVFIGlzIHRydWUgKi8KI2RlZmluZSBDRV9NQVRDSF9JR05PUkVfU0tJUF9XT1JLVFJFRQkwNApleHRlcm4gaW50IGllX21hdGNoX3N0YXQoY29uc3Qgc3RydWN0IGluZGV4X3N0YXRlICosIHN0cnVjdCBjYWNoZV9lbnRyeSAqLCBzdHJ1Y3Qgc3RhdCAqLCB1bnNpZ25lZCBpbnQpOwpleHRlcm4gaW50IGllX21vZGlmaWVkKGNvbnN0IHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBzdHJ1Y3QgY2FjaGVfZW50cnkgKiwgc3RydWN0IHN0YXQgKiwgdW5zaWduZWQgaW50KTsKCnN0cnVjdCBwYXRoc3BlYyB7Cgljb25zdCBjaGFyICoqcmF3OyAvKiBnZXRfcGF0aHNwZWMoKSByZXN1bHQsIG5vdCBmcmVlZCBieSBmcmVlX3BhdGhzcGVjKCkgKi8KCWludCBucjsKCXVuc2lnbmVkIGludCBoYXNfd2lsZGNhcmQ6MTsKCXVuc2lnbmVkIGludCByZWN1cnNpdmU6MTsKCWludCBtYXhfZGVwdGg7CglzdHJ1Y3QgcGF0aHNwZWNfaXRlbSB7CgkJY29uc3QgY2hhciAqbWF0Y2g7CgkJaW50IGxlbjsKCQl1bnNpZ25lZCBpbnQgdXNlX3dpbGRjYXJkOjE7Cgl9ICppdGVtczsKfTsKCmV4dGVybiBpbnQgaW5pdF9wYXRoc3BlYyhzdHJ1Y3QgcGF0aHNwZWMgKiwgY29uc3QgY2hhciAqKik7CmV4dGVybiB2b2lkIGZyZWVfcGF0aHNwZWMoc3RydWN0IHBhdGhzcGVjICopOwpleHRlcm4gaW50IGNlX3BhdGhfbWF0Y2goY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwYXRoc3BlYyk7CgojZGVmaW5lIEhBU0hfV1JJVEVfT0JKRUNUIDEKI2RlZmluZSBIQVNIX0ZPUk1BVF9DSEVDSyAyCmV4dGVybiBpbnQgaW5kZXhfZmQodW5zaWduZWQgY2hhciAqc2hhMSwgaW50IGZkLCBzdHJ1Y3Qgc3RhdCAqc3QsIGVudW0gb2JqZWN0X3R5cGUgdHlwZSwgY29uc3QgY2hhciAqcGF0aCwgdW5zaWduZWQgZmxhZ3MpOwpleHRlcm4gaW50IGluZGV4X3BhdGgodW5zaWduZWQgY2hhciAqc2hhMSwgY29uc3QgY2hhciAqcGF0aCwgc3RydWN0IHN0YXQgKnN0LCB1bnNpZ25lZCBmbGFncyk7CmV4dGVybiB2b2lkIGZpbGxfc3RhdF9jYWNoZV9pbmZvKHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIHN0cnVjdCBzdGF0ICpzdCk7CgojZGVmaW5lIFJFRlJFU0hfUkVBTExZCQkweDAwMDEJLyogaWdub3JlX3ZhbGlkICovCiNkZWZpbmUgUkVGUkVTSF9VTk1FUkdFRAkweDAwMDIJLyogYWxsb3cgdW5tZXJnZWQgKi8KI2RlZmluZSBSRUZSRVNIX1FVSUVUCQkweDAwMDQJLyogYmUgcXVpZXQgYWJvdXQgaXQgKi8KI2RlZmluZSBSRUZSRVNIX0lHTk9SRV9NSVNTSU5HCTB4MDAwOAkvKiBpZ25vcmUgbm9uLWV4aXN0ZW50ICovCiNkZWZpbmUgUkVGUkVTSF9JR05PUkVfU1VCTU9EVUxFUwkweDAwMTAJLyogaWdub3JlIHN1Ym1vZHVsZXMgKi8KI2RlZmluZSBSRUZSRVNIX0lOX1BPUkNFTEFJTgkweDAwMjAJLyogdXNlciBmcmllbmRseSBvdXRwdXQsIG5vdCAibmVlZHMgdXBkYXRlIiAqLwpleHRlcm4gaW50IHJlZnJlc2hfaW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICosIHVuc2lnbmVkIGludCBmbGFncywgY29uc3QgY2hhciAqKnBhdGhzcGVjLCBjaGFyICpzZWVuLCBjb25zdCBjaGFyICpoZWFkZXJfbXNnKTsKCnN0cnVjdCBsb2NrX2ZpbGUgewoJc3RydWN0IGxvY2tfZmlsZSAqbmV4dDsKCWludCBmZDsKCXBpZF90IG93bmVyOwoJY2hhciBvbl9saXN0OwoJY2hhciBmaWxlbmFtZVtQQVRIX01BWF07Cn07CiNkZWZpbmUgTE9DS19ESUVfT05fRVJST1IgMQojZGVmaW5lIExPQ0tfTk9ERVJFRiAyCmV4dGVybiBpbnQgdW5hYmxlX3RvX2xvY2tfZXJyb3IoY29uc3QgY2hhciAqcGF0aCwgaW50IGVycik7CmV4dGVybiBOT1JFVFVSTiB2b2lkIHVuYWJsZV90b19sb2NrX2luZGV4X2RpZShjb25zdCBjaGFyICpwYXRoLCBpbnQgZXJyKTsKZXh0ZXJuIGludCBob2xkX2xvY2tfZmlsZV9mb3JfdXBkYXRlKHN0cnVjdCBsb2NrX2ZpbGUgKiwgY29uc3QgY2hhciAqcGF0aCwgaW50KTsKZXh0ZXJuIGludCBob2xkX2xvY2tfZmlsZV9mb3JfYXBwZW5kKHN0cnVjdCBsb2NrX2ZpbGUgKiwgY29uc3QgY2hhciAqcGF0aCwgaW50KTsKZXh0ZXJuIGludCBjb21taXRfbG9ja19maWxlKHN0cnVjdCBsb2NrX2ZpbGUgKik7CmV4dGVybiB2b2lkIHVwZGF0ZV9pbmRleF9pZl9hYmxlKHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBzdHJ1Y3QgbG9ja19maWxlICopOwoKZXh0ZXJuIGludCBob2xkX2xvY2tlZF9pbmRleChzdHJ1Y3QgbG9ja19maWxlICosIGludCk7CmV4dGVybiBpbnQgY29tbWl0X2xvY2tlZF9pbmRleChzdHJ1Y3QgbG9ja19maWxlICopOwpleHRlcm4gdm9pZCBzZXRfYWx0ZXJuYXRlX2luZGV4X291dHB1dChjb25zdCBjaGFyICopOwpleHRlcm4gaW50IGNsb3NlX2xvY2tfZmlsZShzdHJ1Y3QgbG9ja19maWxlICopOwpleHRlcm4gdm9pZCByb2xsYmFja19sb2NrX2ZpbGUoc3RydWN0IGxvY2tfZmlsZSAqKTsKZXh0ZXJuIGludCBkZWxldGVfcmVmKGNvbnN0IGNoYXIgKiwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgaW50IGRlbG9wdCk7CgovKiBFbnZpcm9ubWVudCBiaXRzIGZyb20gY29uZmlndXJhdGlvbiBtZWNoYW5pc20gKi8KZXh0ZXJuIGludCB0cnVzdF9leGVjdXRhYmxlX2JpdDsKZXh0ZXJuIGludCB0cnVzdF9jdGltZTsKZXh0ZXJuIGludCBxdW90ZV9wYXRoX2Z1bGx5OwpleHRlcm4gaW50IGhhc19zeW1saW5rczsKZXh0ZXJuIGludCBtaW5pbXVtX2FiYnJldiwgZGVmYXVsdF9hYmJyZXY7CmV4dGVybiBpbnQgaWdub3JlX2Nhc2U7CmV4dGVybiBpbnQgYXNzdW1lX3VuY2hhbmdlZDsKZXh0ZXJuIGludCBwcmVmZXJfc3ltbGlua19yZWZzOwpleHRlcm4gaW50IGxvZ19hbGxfcmVmX3VwZGF0ZXM7CmV4dGVybiBpbnQgd2Fybl9hbWJpZ3VvdXNfcmVmczsKZXh0ZXJuIGludCBzaGFyZWRfcmVwb3NpdG9yeTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmFwcGx5X2RlZmF1bHRfd2hpdGVzcGFjZTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmFwcGx5X2RlZmF1bHRfaWdub3Jld2hpdGVzcGFjZTsKZXh0ZXJuIGludCB6bGliX2NvbXByZXNzaW9uX2xldmVsOwpleHRlcm4gaW50IGNvcmVfY29tcHJlc3Npb25fbGV2ZWw7CmV4dGVybiBpbnQgY29yZV9jb21wcmVzc2lvbl9zZWVuOwpleHRlcm4gc2l6ZV90IHBhY2tlZF9naXRfd2luZG93X3NpemU7CmV4dGVybiBzaXplX3QgcGFja2VkX2dpdF9saW1pdDsKZXh0ZXJuIHNpemVfdCBkZWx0YV9iYXNlX2NhY2hlX2xpbWl0OwpleHRlcm4gdW5zaWduZWQgbG9uZyBiaWdfZmlsZV90aHJlc2hvbGQ7CmV4dGVybiBpbnQgcmVhZF9yZXBsYWNlX3JlZnM7CmV4dGVybiBpbnQgZnN5bmNfb2JqZWN0X2ZpbGVzOwpleHRlcm4gaW50IGNvcmVfcHJlbG9hZF9pbmRleDsKZXh0ZXJuIGludCBjb3JlX2FwcGx5X3NwYXJzZV9jaGVja291dDsKCmVudW0gc2FmZV9jcmxmIHsKCVNBRkVfQ1JMRl9GQUxTRSA9IDAsCglTQUZFX0NSTEZfRkFJTCA9IDEsCglTQUZFX0NSTEZfV0FSTiA9IDIKfTsKCmV4dGVybiBlbnVtIHNhZmVfY3JsZiBzYWZlX2NybGY7CgplbnVtIGF1dG9fY3JsZiB7CglBVVRPX0NSTEZfRkFMU0UgPSAwLAoJQVVUT19DUkxGX1RSVUUgPSAxLAoJQVVUT19DUkxGX0lOUFVUID0gLTEKfTsKCmV4dGVybiBlbnVtIGF1dG9fY3JsZiBhdXRvX2NybGY7CgplbnVtIGVvbCB7CglFT0xfVU5TRVQsCglFT0xfQ1JMRiwKCUVPTF9MRiwKI2lmZGVmIE5BVElWRV9DUkxGCglFT0xfTkFUSVZFID0gRU9MX0NSTEYKI2Vsc2UKCUVPTF9OQVRJVkUgPSBFT0xfTEYKI2VuZGlmCn07CgpleHRlcm4gZW51bSBlb2wgY29yZV9lb2w7CgplbnVtIGJyYW5jaF90cmFjayB7CglCUkFOQ0hfVFJBQ0tfVU5TUEVDSUZJRUQgPSAtMSwKCUJSQU5DSF9UUkFDS19ORVZFUiA9IDAsCglCUkFOQ0hfVFJBQ0tfUkVNT1RFLAoJQlJBTkNIX1RSQUNLX0FMV0FZUywKCUJSQU5DSF9UUkFDS19FWFBMSUNJVCwKCUJSQU5DSF9UUkFDS19PVkVSUklERQp9OwoKZW51bSByZWJhc2Vfc2V0dXBfdHlwZSB7CglBVVRPUkVCQVNFX05FVkVSID0gMCwKCUFVVE9SRUJBU0VfTE9DQUwsCglBVVRPUkVCQVNFX1JFTU9URSwKCUFVVE9SRUJBU0VfQUxXQVlTCn07CgplbnVtIHB1c2hfZGVmYXVsdF90eXBlIHsKCVBVU0hfREVGQVVMVF9OT1RISU5HID0gMCwKCVBVU0hfREVGQVVMVF9NQVRDSElORywKCVBVU0hfREVGQVVMVF9VUFNUUkVBTSwKCVBVU0hfREVGQVVMVF9DVVJSRU5UCn07CgpleHRlcm4gZW51bSBicmFuY2hfdHJhY2sgZ2l0X2JyYW5jaF90cmFjazsKZXh0ZXJuIGVudW0gcmViYXNlX3NldHVwX3R5cGUgYXV0b3JlYmFzZTsKZXh0ZXJuIGVudW0gcHVzaF9kZWZhdWx0X3R5cGUgcHVzaF9kZWZhdWx0OwoKZW51bSBvYmplY3RfY3JlYXRpb25fbW9kZSB7CglPQkpFQ1RfQ1JFQVRJT05fVVNFU19IQVJETElOS1MgPSAwLAoJT0JKRUNUX0NSRUFUSU9OX1VTRVNfUkVOQU1FUyA9IDEKfTsKCmV4dGVybiBlbnVtIG9iamVjdF9jcmVhdGlvbl9tb2RlIG9iamVjdF9jcmVhdGlvbl9tb2RlOwoKZXh0ZXJuIGNoYXIgKm5vdGVzX3JlZl9uYW1lOwoKZXh0ZXJuIGludCBncmFmdHNfcmVwbGFjZV9wYXJlbnRzOwoKI2RlZmluZSBHSVRfUkVQT19WRVJTSU9OIDAKZXh0ZXJuIGludCByZXBvc2l0b3J5X2Zvcm1hdF92ZXJzaW9uOwpleHRlcm4gaW50IGNoZWNrX3JlcG9zaXRvcnlfZm9ybWF0KHZvaWQpOwoKI2RlZmluZSBNVElNRV9DSEFOR0VECTB4MDAwMQojZGVmaW5lIENUSU1FX0NIQU5HRUQJMHgwMDAyCiNkZWZpbmUgT1dORVJfQ0hBTkdFRAkweDAwMDQKI2RlZmluZSBNT0RFX0NIQU5HRUQgICAgMHgwMDA4CiNkZWZpbmUgSU5PREVfQ0hBTkdFRCAgIDB4MDAxMAojZGVmaW5lIERBVEFfQ0hBTkdFRCAgICAweDAwMjAKI2RlZmluZSBUWVBFX0NIQU5HRUQgICAgMHgwMDQwCgpleHRlcm4gY2hhciAqbWtzbnBhdGgoY2hhciAqYnVmLCBzaXplX3QgbiwgY29uc3QgY2hhciAqZm10LCAuLi4pCglfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMywgNCkpKTsKZXh0ZXJuIGNoYXIgKmdpdF9zbnBhdGgoY2hhciAqYnVmLCBzaXplX3QgbiwgY29uc3QgY2hhciAqZm10LCAuLi4pCglfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMywgNCkpKTsKZXh0ZXJuIGNoYXIgKmdpdF9wYXRoZHVwKGNvbnN0IGNoYXIgKmZtdCwgLi4uKQoJX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsIDEsIDIpKSk7CgovKiBSZXR1cm4gYSBzdGF0aWNhbGx5IGFsbG9jYXRlZCBmaWxlbmFtZSBtYXRjaGluZyB0aGUgc2hhMSBzaWduYXR1cmUgKi8KZXh0ZXJuIGNoYXIgKm1rcGF0aChjb25zdCBjaGFyICpmbXQsIC4uLikgX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsIDEsIDIpKSk7CmV4dGVybiBjaGFyICpnaXRfcGF0aChjb25zdCBjaGFyICpmbXQsIC4uLikgX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsIDEsIDIpKSk7CmV4dGVybiBjaGFyICpnaXRfcGF0aF9zdWJtb2R1bGUoY29uc3QgY2hhciAqcGF0aCwgY29uc3QgY2hhciAqZm10LCAuLi4pCglfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMiwgMykpKTsKCmV4dGVybiBjaGFyICpzaGExX2ZpbGVfbmFtZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKTsKZXh0ZXJuIGNoYXIgKnNoYTFfcGFja19uYW1lKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpleHRlcm4gY2hhciAqc2hhMV9wYWNrX2luZGV4X25hbWUoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSk7CmV4dGVybiBjb25zdCBjaGFyICpmaW5kX3VuaXF1ZV9hYmJyZXYoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgaW50KTsKZXh0ZXJuIGNvbnN0IHVuc2lnbmVkIGNoYXIgbnVsbF9zaGExWzIwXTsKCnN0YXRpYyBpbmxpbmUgaW50IGhhc2hjbXAoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMikKewoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IDIwOyBpKyssIHNoYTErKywgc2hhMisrKSB7CgkJaWYgKCpzaGExICE9ICpzaGEyKQoJCQlyZXR1cm4gKnNoYTEgLSAqc2hhMjsKCX0KCglyZXR1cm4gMDsKfQoKc3RhdGljIGlubGluZSBpbnQgaXNfbnVsbF9zaGExKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXJldHVybiAhaGFzaGNtcChzaGExLCBudWxsX3NoYTEpOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQgaGFzaGNweSh1bnNpZ25lZCBjaGFyICpzaGFfZHN0LCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGFfc3JjKQp7CgltZW1jcHkoc2hhX2RzdCwgc2hhX3NyYywgMjApOwp9CnN0YXRpYyBpbmxpbmUgdm9pZCBoYXNoY2xyKHVuc2lnbmVkIGNoYXIgKmhhc2gpCnsKCW1lbXNldChoYXNoLCAwLCAyMCk7Cn0KCiNkZWZpbmUgRU1QVFlfVFJFRV9TSEExX0hFWCBcCgkiNGI4MjVkYzY0MmNiNmViOWEwNjBlNTRiZjhkNjkyODhmYmVlNDkwNCIKI2RlZmluZSBFTVBUWV9UUkVFX1NIQTFfQklOX0xJVEVSQUwgXAoJICJceDRiXHg4Mlx4NWRceGM2XHg0Mlx4Y2JceDZlXHhiOVx4YTBceDYwIiBcCgkgIlx4ZTVceDRiXHhmOFx4ZDZceDkyXHg4OFx4ZmJceGVlXHg0OVx4MDQiCiNkZWZpbmUgRU1QVFlfVFJFRV9TSEExX0JJTiBcCgkgKChjb25zdCB1bnNpZ25lZCBjaGFyICopIEVNUFRZX1RSRUVfU0hBMV9CSU5fTElURVJBTCkKCmludCBnaXRfbWtzdGVtcChjaGFyICpwYXRoLCBzaXplX3QgbiwgY29uc3QgY2hhciAqdGVtcGxhdGUpOwoKaW50IGdpdF9ta3N0ZW1wcyhjaGFyICpwYXRoLCBzaXplX3QgbiwgY29uc3QgY2hhciAqdGVtcGxhdGUsIGludCBzdWZmaXhfbGVuKTsKCi8qIHNldCBkZWZhdWx0IHBlcm1pc3Npb25zIGJ5IHBhc3NpbmcgbW9kZSBhcmd1bWVudHMgdG8gb3BlbigyKSAqLwppbnQgZ2l0X21rc3RlbXBzX21vZGUoY2hhciAqcGF0dGVybiwgaW50IHN1ZmZpeF9sZW4sIGludCBtb2RlKTsKaW50IGdpdF9ta3N0ZW1wX21vZGUoY2hhciAqcGF0dGVybiwgaW50IG1vZGUpOwoKLyoKICogTk9URSBOT1RFIE5PVEUhIQogKgogKiBQRVJNX1VNQVNLLCBPTERfUEVSTV9HUk9VUCBhbmQgT0xEX1BFUk1fRVZFUllCT0RZIGVudW1lcmF0aW9ucyBtdXN0CiAqIG5vdCBiZSBjaGFuZ2VkLiBPbGQgcmVwb3NpdG9yaWVzIGhhdmUgY29yZS5zaGFyZWRyZXBvc2l0b3J5IHdyaXR0ZW4gaW4KICogbnVtZXJpYyBmb3JtYXQsIGFuZCB0aGVyZWZvcmUgdGhlc2UgdmFsdWVzIGFyZSBwcmVzZXJ2ZWQgZm9yIGNvbXBhdGliaWxpdHkKICogcmVhc29ucy4KICovCmVudW0gc2hhcmVkcmVwbyB7CglQRVJNX1VNQVNLICAgICAgICAgID0gMCwKCU9MRF9QRVJNX0dST1VQICAgICAgPSAxLAoJT0xEX1BFUk1fRVZFUllCT0RZICA9IDIsCglQRVJNX0dST1VQICAgICAgICAgID0gMDY2MCwKCVBFUk1fRVZFUllCT0RZICAgICAgPSAwNjY0Cn07CmludCBnaXRfY29uZmlnX3Blcm0oY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSk7CmludCBzZXRfc2hhcmVkX3Blcm0oY29uc3QgY2hhciAqcGF0aCwgaW50IG1vZGUpOwojZGVmaW5lIGFkanVzdF9zaGFyZWRfcGVybShwYXRoKSBzZXRfc2hhcmVkX3Blcm0oKHBhdGgpLCAwKQppbnQgc2FmZV9jcmVhdGVfbGVhZGluZ19kaXJlY3RvcmllcyhjaGFyICpwYXRoKTsKaW50IHNhZmVfY3JlYXRlX2xlYWRpbmdfZGlyZWN0b3JpZXNfY29uc3QoY29uc3QgY2hhciAqcGF0aCk7CmludCBta2Rpcl9pbl9naXRkaXIoY29uc3QgY2hhciAqcGF0aCk7CmV4dGVybiBjaGFyICpleHBhbmRfdXNlcl9wYXRoKGNvbnN0IGNoYXIgKnBhdGgpOwpjaGFyICplbnRlcl9yZXBvKGNoYXIgKnBhdGgsIGludCBzdHJpY3QpOwpzdGF0aWMgaW5saW5lIGludCBpc19hYnNvbHV0ZV9wYXRoKGNvbnN0IGNoYXIgKnBhdGgpCnsKCXJldHVybiBwYXRoWzBdID09ICcvJyB8fCBoYXNfZG9zX2RyaXZlX3ByZWZpeChwYXRoKTsKfQppbnQgaXNfZGlyZWN0b3J5KGNvbnN0IGNoYXIgKik7CmNvbnN0IGNoYXIgKnJlYWxfcGF0aChjb25zdCBjaGFyICpwYXRoKTsKY29uc3QgY2hhciAqYWJzb2x1dGVfcGF0aChjb25zdCBjaGFyICpwYXRoKTsKY29uc3QgY2hhciAqcmVsYXRpdmVfcGF0aChjb25zdCBjaGFyICphYnMsIGNvbnN0IGNoYXIgKmJhc2UpOwppbnQgbm9ybWFsaXplX3BhdGhfY29weShjaGFyICpkc3QsIGNvbnN0IGNoYXIgKnNyYyk7CmludCBsb25nZXN0X2FuY2VzdG9yX2xlbmd0aChjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFyICpwcmVmaXhfbGlzdCk7CmNoYXIgKnN0cmlwX3BhdGhfc3VmZml4KGNvbnN0IGNoYXIgKnBhdGgsIGNvbnN0IGNoYXIgKnN1ZmZpeCk7CmludCBkYWVtb25fYXZvaWRfYWxpYXMoY29uc3QgY2hhciAqcGF0aCk7CmludCBvZmZzZXRfMXN0X2NvbXBvbmVudChjb25zdCBjaGFyICpwYXRoKTsKCi8qIG9iamVjdCByZXBsYWNlbWVudCAqLwojZGVmaW5lIFJFQURfU0hBMV9GSUxFX1JFUExBQ0UgMQpleHRlcm4gdm9pZCAqcmVhZF9zaGExX2ZpbGVfZXh0ZW5kZWQoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgZW51bSBvYmplY3RfdHlwZSAqdHlwZSwgdW5zaWduZWQgbG9uZyAqc2l6ZSwgdW5zaWduZWQgZmxhZyk7CnN0YXRpYyBpbmxpbmUgdm9pZCAqcmVhZF9zaGExX2ZpbGUoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgZW51bSBvYmplY3RfdHlwZSAqdHlwZSwgdW5zaWduZWQgbG9uZyAqc2l6ZSkKewoJcmV0dXJuIHJlYWRfc2hhMV9maWxlX2V4dGVuZGVkKHNoYTEsIHR5cGUsIHNpemUsIFJFQURfU0hBMV9GSUxFX1JFUExBQ0UpOwp9CmV4dGVybiBjb25zdCB1bnNpZ25lZCBjaGFyICpkb19sb29rdXBfcmVwbGFjZV9vYmplY3QoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSk7CnN0YXRpYyBpbmxpbmUgY29uc3QgdW5zaWduZWQgY2hhciAqbG9va3VwX3JlcGxhY2Vfb2JqZWN0KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCWlmICghcmVhZF9yZXBsYWNlX3JlZnMpCgkJcmV0dXJuIHNoYTE7CglyZXR1cm4gZG9fbG9va3VwX3JlcGxhY2Vfb2JqZWN0KHNoYTEpOwp9CgovKiBSZWFkIGFuZCB1bnBhY2sgYSBzaGExIGZpbGUgaW50byBtZW1vcnksIHdyaXRlIG1lbW9yeSB0byBhIHNoYTEgZmlsZSAqLwpleHRlcm4gaW50IHNoYTFfb2JqZWN0X2luZm8oY29uc3QgdW5zaWduZWQgY2hhciAqLCB1bnNpZ25lZCBsb25nICopOwpleHRlcm4gaW50IGhhc2hfc2hhMV9maWxlKGNvbnN0IHZvaWQgKmJ1ZiwgdW5zaWduZWQgbG9uZyBsZW4sIGNvbnN0IGNoYXIgKnR5cGUsIHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpleHRlcm4gaW50IHdyaXRlX3NoYTFfZmlsZShjb25zdCB2b2lkICpidWYsIHVuc2lnbmVkIGxvbmcgbGVuLCBjb25zdCBjaGFyICp0eXBlLCB1bnNpZ25lZCBjaGFyICpyZXR1cm5fc2hhMSk7CmV4dGVybiBpbnQgcHJldGVuZF9zaGExX2ZpbGUodm9pZCAqLCB1bnNpZ25lZCBsb25nLCBlbnVtIG9iamVjdF90eXBlLCB1bnNpZ25lZCBjaGFyICopOwpleHRlcm4gaW50IGZvcmNlX29iamVjdF9sb29zZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCB0aW1lX3QgbXRpbWUpOwoKLyogZ2xvYmFsIGZsYWcgdG8gZW5hYmxlIGV4dHJhIGNoZWNrcyB3aGVuIGFjY2Vzc2luZyBwYWNrZWQgb2JqZWN0cyAqLwpleHRlcm4gaW50IGRvX2NoZWNrX3BhY2tlZF9vYmplY3RfY3JjOwoKZXh0ZXJuIGludCBjaGVja19zaGExX3NpZ25hdHVyZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCB2b2lkICpidWYsIHVuc2lnbmVkIGxvbmcgc2l6ZSwgY29uc3QgY2hhciAqdHlwZSk7CgpleHRlcm4gaW50IG1vdmVfdGVtcF90b19maWxlKGNvbnN0IGNoYXIgKnRtcGZpbGUsIGNvbnN0IGNoYXIgKmZpbGVuYW1lKTsKCmV4dGVybiBpbnQgaGFzX3NoYTFfcGFjayhjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKTsKZXh0ZXJuIGludCBoYXNfc2hhMV9maWxlKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpleHRlcm4gaW50IGhhc19sb29zZV9vYmplY3Rfbm9ubG9jYWwoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSk7CgpleHRlcm4gaW50IGhhc19wYWNrX2luZGV4KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpOwoKZXh0ZXJuIHZvaWQgYXNzZXJ0X3NoYTFfdHlwZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBlbnVtIG9iamVjdF90eXBlIGV4cGVjdCk7CgpleHRlcm4gY29uc3Qgc2lnbmVkIGNoYXIgaGV4dmFsX3RhYmxlWzI1Nl07CnN0YXRpYyBpbmxpbmUgdW5zaWduZWQgaW50IGhleHZhbCh1bnNpZ25lZCBjaGFyIGMpCnsKCXJldHVybiBoZXh2YWxfdGFibGVbY107Cn0KCi8qIENvbnZlcnQgdG8vZnJvbSBoZXgvc2hhMSByZXByZXNlbnRhdGlvbiAqLwojZGVmaW5lIE1JTklNVU1fQUJCUkVWIG1pbmltdW1fYWJicmV2CiNkZWZpbmUgREVGQVVMVF9BQkJSRVYgZGVmYXVsdF9hYmJyZXYKCnN0cnVjdCBvYmplY3RfY29udGV4dCB7Cgl1bnNpZ25lZCBjaGFyIHRyZWVbMjBdOwoJY2hhciBwYXRoW1BBVEhfTUFYXTsKCXVuc2lnbmVkIG1vZGU7Cn07CgpleHRlcm4gaW50IGdldF9zaGExKGNvbnN0IGNoYXIgKnN0ciwgdW5zaWduZWQgY2hhciAqc2hhMSk7CmV4dGVybiBpbnQgZ2V0X3NoYTFfd2l0aF9tb2RlXzEoY29uc3QgY2hhciAqc3RyLCB1bnNpZ25lZCBjaGFyICpzaGExLCB1bnNpZ25lZCAqbW9kZSwgaW50IG9ubHlfdG9fZGllLCBjb25zdCBjaGFyICpwcmVmaXgpOwpzdGF0aWMgaW5saW5lIGludCBnZXRfc2hhMV93aXRoX21vZGUoY29uc3QgY2hhciAqc3RyLCB1bnNpZ25lZCBjaGFyICpzaGExLCB1bnNpZ25lZCAqbW9kZSkKewoJcmV0dXJuIGdldF9zaGExX3dpdGhfbW9kZV8xKHN0ciwgc2hhMSwgbW9kZSwgMCwgTlVMTCk7Cn0KZXh0ZXJuIGludCBnZXRfc2hhMV93aXRoX2NvbnRleHRfMShjb25zdCBjaGFyICpuYW1lLCB1bnNpZ25lZCBjaGFyICpzaGExLCBzdHJ1Y3Qgb2JqZWN0X2NvbnRleHQgKm9yYywgaW50IG9ubHlfdG9fZGllLCBjb25zdCBjaGFyICpwcmVmaXgpOwpzdGF0aWMgaW5saW5lIGludCBnZXRfc2hhMV93aXRoX2NvbnRleHQoY29uc3QgY2hhciAqc3RyLCB1bnNpZ25lZCBjaGFyICpzaGExLCBzdHJ1Y3Qgb2JqZWN0X2NvbnRleHQgKm9yYykKewoJcmV0dXJuIGdldF9zaGExX3dpdGhfY29udGV4dF8xKHN0ciwgc2hhMSwgb3JjLCAwLCBOVUxMKTsKfQpleHRlcm4gaW50IGdldF9zaGExX2hleChjb25zdCBjaGFyICpoZXgsIHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpleHRlcm4gY2hhciAqc2hhMV90b19oZXgoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSk7CS8qIHN0YXRpYyBidWZmZXIgcmVzdWx0ISAqLwpleHRlcm4gaW50IHJlYWRfcmVmKGNvbnN0IGNoYXIgKmZpbGVuYW1lLCB1bnNpZ25lZCBjaGFyICpzaGExKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKnJlc29sdmVfcmVmKGNvbnN0IGNoYXIgKnBhdGgsIHVuc2lnbmVkIGNoYXIgKnNoYTEsIGludCwgaW50ICopOwpleHRlcm4gaW50IGR3aW1fcmVmKGNvbnN0IGNoYXIgKnN0ciwgaW50IGxlbiwgdW5zaWduZWQgY2hhciAqc2hhMSwgY2hhciAqKnJlZik7CmV4dGVybiBpbnQgZHdpbV9sb2coY29uc3QgY2hhciAqc3RyLCBpbnQgbGVuLCB1bnNpZ25lZCBjaGFyICpzaGExLCBjaGFyICoqcmVmKTsKZXh0ZXJuIGludCBpbnRlcnByZXRfYnJhbmNoX25hbWUoY29uc3QgY2hhciAqc3RyLCBzdHJ1Y3Qgc3RyYnVmICopOwpleHRlcm4gaW50IGdldF9zaGExX21iKGNvbnN0IGNoYXIgKnN0ciwgdW5zaWduZWQgY2hhciAqc2hhMSk7CgpleHRlcm4gaW50IHJlZm5hbWVfbWF0Y2goY29uc3QgY2hhciAqYWJicmV2X25hbWUsIGNvbnN0IGNoYXIgKmZ1bGxfbmFtZSwgY29uc3QgY2hhciAqKnJ1bGVzKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKnJlZl9yZXZfcGFyc2VfcnVsZXNbXTsKZXh0ZXJuIGNvbnN0IGNoYXIgKnJlZl9mZXRjaF9ydWxlc1tdOwoKZXh0ZXJuIGludCBjcmVhdGVfc3ltcmVmKGNvbnN0IGNoYXIgKnJlZiwgY29uc3QgY2hhciAqcmVmc19oZWFkc19tYXN0ZXIsIGNvbnN0IGNoYXIgKmxvZ21zZyk7CmV4dGVybiBpbnQgdmFsaWRhdGVfaGVhZHJlZihjb25zdCBjaGFyICpyZWYpOwoKZXh0ZXJuIGludCBiYXNlX25hbWVfY29tcGFyZShjb25zdCBjaGFyICpuYW1lMSwgaW50IGxlbjEsIGludCBtb2RlMSwgY29uc3QgY2hhciAqbmFtZTIsIGludCBsZW4yLCBpbnQgbW9kZTIpOwpleHRlcm4gaW50IGRmX25hbWVfY29tcGFyZShjb25zdCBjaGFyICpuYW1lMSwgaW50IGxlbjEsIGludCBtb2RlMSwgY29uc3QgY2hhciAqbmFtZTIsIGludCBsZW4yLCBpbnQgbW9kZTIpOwpleHRlcm4gaW50IGNhY2hlX25hbWVfY29tcGFyZShjb25zdCBjaGFyICpuYW1lMSwgaW50IGxlbjEsIGNvbnN0IGNoYXIgKm5hbWUyLCBpbnQgbGVuMik7CgpleHRlcm4gdm9pZCAqcmVhZF9vYmplY3Rfd2l0aF9yZWZlcmVuY2UoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkJCQljb25zdCBjaGFyICpyZXF1aXJlZF90eXBlLAoJCQkJCXVuc2lnbmVkIGxvbmcgKnNpemUsCgkJCQkJdW5zaWduZWQgY2hhciAqc2hhMV9yZXQpOwoKZXh0ZXJuIHN0cnVjdCBvYmplY3QgKnBlZWxfdG9fdHlwZShjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbiwKCQkJCSAgIHN0cnVjdCBvYmplY3QgKm8sIGVudW0gb2JqZWN0X3R5cGUpOwoKZW51bSBkYXRlX21vZGUgewoJREFURV9OT1JNQUwgPSAwLAoJREFURV9SRUxBVElWRSwKCURBVEVfU0hPUlQsCglEQVRFX0xPQ0FMLAoJREFURV9JU084NjAxLAoJREFURV9SRkMyODIyLAoJREFURV9SQVcKfTsKCmNvbnN0IGNoYXIgKnNob3dfZGF0ZSh1bnNpZ25lZCBsb25nIHRpbWUsIGludCB0aW1lem9uZSwgZW51bSBkYXRlX21vZGUgbW9kZSk7CmNvbnN0IGNoYXIgKnNob3dfZGF0ZV9yZWxhdGl2ZSh1bnNpZ25lZCBsb25nIHRpbWUsIGludCB0eiwKCQkJICAgICAgIGNvbnN0IHN0cnVjdCB0aW1ldmFsICpub3csCgkJCSAgICAgICBjaGFyICp0aW1lYnVmLAoJCQkgICAgICAgc2l6ZV90IHRpbWVidWZfc2l6ZSk7CmludCBwYXJzZV9kYXRlKGNvbnN0IGNoYXIgKmRhdGUsIGNoYXIgKmJ1ZiwgaW50IGJ1ZnNpemUpOwppbnQgcGFyc2VfZGF0ZV9iYXNpYyhjb25zdCBjaGFyICpkYXRlLCB1bnNpZ25lZCBsb25nICp0aW1lc3RhbXAsIGludCAqb2Zmc2V0KTsKdm9pZCBkYXRlc3RhbXAoY2hhciAqYnVmLCBpbnQgYnVmc2l6ZSk7CiNkZWZpbmUgYXBwcm94aWRhdGUocykgYXBwcm94aWRhdGVfY2FyZWZ1bCgocyksIE5VTEwpCnVuc2lnbmVkIGxvbmcgYXBwcm94aWRhdGVfY2FyZWZ1bChjb25zdCBjaGFyICosIGludCAqKTsKdW5zaWduZWQgbG9uZyBhcHByb3hpZGF0ZV9yZWxhdGl2ZShjb25zdCBjaGFyICpkYXRlLCBjb25zdCBzdHJ1Y3QgdGltZXZhbCAqbm93KTsKZW51bSBkYXRlX21vZGUgcGFyc2VfZGF0ZV9mb3JtYXQoY29uc3QgY2hhciAqZm9ybWF0KTsKCiNkZWZpbmUgSURFTlRfV0FSTl9PTl9OT19OQU1FICAxCiNkZWZpbmUgSURFTlRfRVJST1JfT05fTk9fTkFNRSAyCiNkZWZpbmUgSURFTlRfTk9fREFURQkgICAgICAgNApleHRlcm4gY29uc3QgY2hhciAqZ2l0X2F1dGhvcl9pbmZvKGludCk7CmV4dGVybiBjb25zdCBjaGFyICpnaXRfY29tbWl0dGVyX2luZm8oaW50KTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmZtdF9pZGVudChjb25zdCBjaGFyICpuYW1lLCBjb25zdCBjaGFyICplbWFpbCwgY29uc3QgY2hhciAqZGF0ZV9zdHIsIGludCk7CmV4dGVybiBjb25zdCBjaGFyICpmbXRfbmFtZShjb25zdCBjaGFyICpuYW1lLCBjb25zdCBjaGFyICplbWFpbCk7CmV4dGVybiBjb25zdCBjaGFyICpnaXRfZWRpdG9yKHZvaWQpOwpleHRlcm4gY29uc3QgY2hhciAqZ2l0X3BhZ2VyKGludCBzdGRvdXRfaXNfdHR5KTsKCnN0cnVjdCBjaGVja291dCB7Cgljb25zdCBjaGFyICpiYXNlX2RpcjsKCWludCBiYXNlX2Rpcl9sZW47Cgl1bnNpZ25lZCBmb3JjZToxLAoJCSBxdWlldDoxLAoJCSBub3RfbmV3OjEsCgkJIHJlZnJlc2hfY2FjaGU6MTsKfTsKCmV4dGVybiBpbnQgY2hlY2tvdXRfZW50cnkoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgY29uc3Qgc3RydWN0IGNoZWNrb3V0ICpzdGF0ZSwgY2hhciAqdG9wYXRoKTsKCnN0cnVjdCBjYWNoZV9kZWYgewoJY2hhciBwYXRoW1BBVEhfTUFYICsgMV07CglpbnQgbGVuOwoJaW50IGZsYWdzOwoJaW50IHRyYWNrX2ZsYWdzOwoJaW50IHByZWZpeF9sZW5fc3RhdF9mdW5jOwp9OwoKZXh0ZXJuIGludCBoYXNfc3ltbGlua19sZWFkaW5nX3BhdGgoY29uc3QgY2hhciAqbmFtZSwgaW50IGxlbik7CmV4dGVybiBpbnQgdGhyZWFkZWRfaGFzX3N5bWxpbmtfbGVhZGluZ19wYXRoKHN0cnVjdCBjYWNoZV9kZWYgKiwgY29uc3QgY2hhciAqLCBpbnQpOwpleHRlcm4gaW50IGNoZWNrX2xlYWRpbmdfcGF0aChjb25zdCBjaGFyICpuYW1lLCBpbnQgbGVuKTsKZXh0ZXJuIGludCBoYXNfZGlyc19vbmx5X3BhdGgoY29uc3QgY2hhciAqbmFtZSwgaW50IGxlbiwgaW50IHByZWZpeF9sZW4pOwpleHRlcm4gdm9pZCBzY2hlZHVsZV9kaXJfZm9yX3JlbW92YWwoY29uc3QgY2hhciAqbmFtZSwgaW50IGxlbik7CmV4dGVybiB2b2lkIHJlbW92ZV9zY2hlZHVsZWRfZGlycyh2b2lkKTsKCmV4dGVybiBzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSB7CglzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSAqbmV4dDsKCWNoYXIgKm5hbWU7CgljaGFyIGJhc2VbRkxFWF9BUlJBWV07IC8qIG1vcmUgKi8KfSAqYWx0X29kYl9saXN0OwpleHRlcm4gdm9pZCBwcmVwYXJlX2FsdF9vZGIodm9pZCk7CmV4dGVybiB2b2lkIGFkZF90b19hbHRlcm5hdGVzX2ZpbGUoY29uc3QgY2hhciAqcmVmZXJlbmNlKTsKdHlwZWRlZiBpbnQgYWx0X29kYl9mbihzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSAqLCB2b2lkICopOwpleHRlcm4gdm9pZCBmb3JlYWNoX2FsdF9vZGIoYWx0X29kYl9mbiwgdm9pZCopOwoKc3RydWN0IHBhY2tfd2luZG93IHsKCXN0cnVjdCBwYWNrX3dpbmRvdyAqbmV4dDsKCXVuc2lnbmVkIGNoYXIgKmJhc2U7CglvZmZfdCBvZmZzZXQ7CglzaXplX3QgbGVuOwoJdW5zaWduZWQgaW50IGxhc3RfdXNlZDsKCXVuc2lnbmVkIGludCBpbnVzZV9jbnQ7Cn07CgpleHRlcm4gc3RydWN0IHBhY2tlZF9naXQgewoJc3RydWN0IHBhY2tlZF9naXQgKm5leHQ7CglzdHJ1Y3QgcGFja193aW5kb3cgKndpbmRvd3M7CglvZmZfdCBwYWNrX3NpemU7Cgljb25zdCB2b2lkICppbmRleF9kYXRhOwoJc2l6ZV90IGluZGV4X3NpemU7Cgl1aW50MzJfdCBudW1fb2JqZWN0czsKCXVpbnQzMl90IG51bV9iYWRfb2JqZWN0czsKCXVuc2lnbmVkIGNoYXIgKmJhZF9vYmplY3Rfc2hhMTsKCWludCBpbmRleF92ZXJzaW9uOwoJdGltZV90IG10aW1lOwoJaW50IHBhY2tfZmQ7Cgl1bnNpZ25lZCBwYWNrX2xvY2FsOjEsCgkJIHBhY2tfa2VlcDoxLAoJCSBkb19ub3RfY2xvc2U6MTsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgkvKiBzb21ldGhpbmcgbGlrZSAiLmdpdC9vYmplY3RzL3BhY2sveHh4eHgucGFjayIgKi8KCWNoYXIgcGFja19uYW1lW0ZMRVhfQVJSQVldOyAvKiBtb3JlICovCn0gKnBhY2tlZF9naXQ7CgpzdHJ1Y3QgcGFja19lbnRyeSB7CglvZmZfdCBvZmZzZXQ7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJc3RydWN0IHBhY2tlZF9naXQgKnA7Cn07CgpzdHJ1Y3QgcmVmIHsKCXN0cnVjdCByZWYgKm5leHQ7Cgl1bnNpZ25lZCBjaGFyIG9sZF9zaGExWzIwXTsKCXVuc2lnbmVkIGNoYXIgbmV3X3NoYTFbMjBdOwoJY2hhciAqc3ltcmVmOwoJdW5zaWduZWQgaW50IGZvcmNlOjEsCgkJbWVyZ2U6MSwKCQlub25mYXN0Zm9yd2FyZDoxLAoJCWRlbGV0aW9uOjE7CgllbnVtIHsKCQlSRUZfU1RBVFVTX05PTkUgPSAwLAoJCVJFRl9TVEFUVVNfT0ssCgkJUkVGX1NUQVRVU19SRUpFQ1RfTk9ORkFTVEZPUldBUkQsCgkJUkVGX1NUQVRVU19SRUpFQ1RfTk9ERUxFVEUsCgkJUkVGX1NUQVRVU19VUFRPREFURSwKCQlSRUZfU1RBVFVTX1JFTU9URV9SRUpFQ1QsCgkJUkVGX1NUQVRVU19FWFBFQ1RJTkdfUkVQT1JUCgl9IHN0YXR1czsKCWNoYXIgKnJlbW90ZV9zdGF0dXM7CglzdHJ1Y3QgcmVmICpwZWVyX3JlZjsgLyogd2hlbiByZW5hbWluZyAqLwoJY2hhciBuYW1lW0ZMRVhfQVJSQVldOyAvKiBtb3JlICovCn07CgojZGVmaW5lIFJFRl9OT1JNQUwJKDF1IDw8IDApCiNkZWZpbmUgUkVGX0hFQURTCSgxdSA8PCAxKQojZGVmaW5lIFJFRl9UQUdTCSgxdSA8PCAyKQoKZXh0ZXJuIHN0cnVjdCByZWYgKmZpbmRfcmVmX2J5X25hbWUoY29uc3Qgc3RydWN0IHJlZiAqbGlzdCwgY29uc3QgY2hhciAqbmFtZSk7CgojZGVmaW5lIENPTk5FQ1RfVkVSQk9TRSAgICAgICAoMXUgPDwgMCkKZXh0ZXJuIGNoYXIgKmdpdF9nZXRwYXNzKGNvbnN0IGNoYXIgKnByb21wdCk7CmV4dGVybiBzdHJ1Y3QgY2hpbGRfcHJvY2VzcyAqZ2l0X2Nvbm5lY3QoaW50IGZkWzJdLCBjb25zdCBjaGFyICp1cmwsIGNvbnN0IGNoYXIgKnByb2csIGludCBmbGFncyk7CmV4dGVybiBpbnQgZmluaXNoX2Nvbm5lY3Qoc3RydWN0IGNoaWxkX3Byb2Nlc3MgKmNvbm4pOwpleHRlcm4gaW50IGdpdF9jb25uZWN0aW9uX2lzX3NvY2tldChzdHJ1Y3QgY2hpbGRfcHJvY2VzcyAqY29ubik7CmV4dGVybiBpbnQgcGF0aF9tYXRjaChjb25zdCBjaGFyICpwYXRoLCBpbnQgbnIsIGNoYXIgKiptYXRjaCk7CnN0cnVjdCBleHRyYV9oYXZlX29iamVjdHMgewoJaW50IG5yLCBhbGxvYzsKCXVuc2lnbmVkIGNoYXIgKCphcnJheSlbMjBdOwp9OwpleHRlcm4gc3RydWN0IHJlZiAqKmdldF9yZW1vdGVfaGVhZHMoaW50IGluLCBzdHJ1Y3QgcmVmICoqbGlzdCwgaW50IG5yX21hdGNoLCBjaGFyICoqbWF0Y2gsIHVuc2lnbmVkIGludCBmbGFncywgc3RydWN0IGV4dHJhX2hhdmVfb2JqZWN0cyAqKTsKZXh0ZXJuIGludCBzZXJ2ZXJfc3VwcG9ydHMoY29uc3QgY2hhciAqZmVhdHVyZSk7CgpleHRlcm4gc3RydWN0IHBhY2tlZF9naXQgKnBhcnNlX3BhY2tfaW5kZXgodW5zaWduZWQgY2hhciAqc2hhMSwgY29uc3QgY2hhciAqaWR4X3BhdGgpOwoKZXh0ZXJuIHZvaWQgcHJlcGFyZV9wYWNrZWRfZ2l0KHZvaWQpOwpleHRlcm4gdm9pZCByZXByZXBhcmVfcGFja2VkX2dpdCh2b2lkKTsKZXh0ZXJuIHZvaWQgaW5zdGFsbF9wYWNrZWRfZ2l0KHN0cnVjdCBwYWNrZWRfZ2l0ICpwYWNrKTsKCmV4dGVybiBzdHJ1Y3QgcGFja2VkX2dpdCAqZmluZF9zaGExX3BhY2soY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkJCQkgc3RydWN0IHBhY2tlZF9naXQgKnBhY2tzKTsKCmV4dGVybiB2b2lkIHBhY2tfcmVwb3J0KHZvaWQpOwpleHRlcm4gaW50IG9wZW5fcGFja19pbmRleChzdHJ1Y3QgcGFja2VkX2dpdCAqKTsKZXh0ZXJuIHZvaWQgY2xvc2VfcGFja19pbmRleChzdHJ1Y3QgcGFja2VkX2dpdCAqKTsKZXh0ZXJuIHVuc2lnbmVkIGNoYXIgKnVzZV9wYWNrKHN0cnVjdCBwYWNrZWRfZ2l0ICosIHN0cnVjdCBwYWNrX3dpbmRvdyAqKiwgb2ZmX3QsIHVuc2lnbmVkIGludCAqKTsKZXh0ZXJuIHZvaWQgY2xvc2VfcGFja193aW5kb3dzKHN0cnVjdCBwYWNrZWRfZ2l0ICopOwpleHRlcm4gdm9pZCB1bnVzZV9wYWNrKHN0cnVjdCBwYWNrX3dpbmRvdyAqKik7CmV4dGVybiB2b2lkIGZyZWVfcGFja19ieV9uYW1lKGNvbnN0IGNoYXIgKik7CmV4dGVybiB2b2lkIGNsZWFyX2RlbHRhX2Jhc2VfY2FjaGUodm9pZCk7CmV4dGVybiBzdHJ1Y3QgcGFja2VkX2dpdCAqYWRkX3BhY2tlZF9naXQoY29uc3QgY2hhciAqLCBpbnQsIGludCk7CmV4dGVybiBjb25zdCB1bnNpZ25lZCBjaGFyICpudGhfcGFja2VkX29iamVjdF9zaGExKHN0cnVjdCBwYWNrZWRfZ2l0ICosIHVpbnQzMl90KTsKZXh0ZXJuIG9mZl90IG50aF9wYWNrZWRfb2JqZWN0X29mZnNldChjb25zdCBzdHJ1Y3QgcGFja2VkX2dpdCAqLCB1aW50MzJfdCk7CmV4dGVybiBvZmZfdCBmaW5kX3BhY2tfZW50cnlfb25lKGNvbnN0IHVuc2lnbmVkIGNoYXIgKiwgc3RydWN0IHBhY2tlZF9naXQgKik7CmV4dGVybiB2b2lkICp1bnBhY2tfZW50cnkoc3RydWN0IHBhY2tlZF9naXQgKiwgb2ZmX3QsIGVudW0gb2JqZWN0X3R5cGUgKiwgdW5zaWduZWQgbG9uZyAqKTsKZXh0ZXJuIHVuc2lnbmVkIGxvbmcgdW5wYWNrX29iamVjdF9oZWFkZXJfYnVmZmVyKGNvbnN0IHVuc2lnbmVkIGNoYXIgKmJ1ZiwgdW5zaWduZWQgbG9uZyBsZW4sIGVudW0gb2JqZWN0X3R5cGUgKnR5cGUsIHVuc2lnbmVkIGxvbmcgKnNpemVwKTsKZXh0ZXJuIHVuc2lnbmVkIGxvbmcgZ2V0X3NpemVfZnJvbV9kZWx0YShzdHJ1Y3QgcGFja2VkX2dpdCAqLCBzdHJ1Y3QgcGFja193aW5kb3cgKiosIG9mZl90KTsKZXh0ZXJuIGNvbnN0IGNoYXIgKnBhY2tlZF9vYmplY3RfaW5mb19kZXRhaWwoc3RydWN0IHBhY2tlZF9naXQgKiwgb2ZmX3QsIHVuc2lnbmVkIGxvbmcgKiwgdW5zaWduZWQgbG9uZyAqLCB1bnNpZ25lZCBpbnQgKiwgdW5zaWduZWQgY2hhciAqKTsKCi8qIER1bWIgc2VydmVycyBzdXBwb3J0ICovCmV4dGVybiBpbnQgdXBkYXRlX3NlcnZlcl9pbmZvKGludCk7CgovKiBnaXRfY29uZmlnX3BhcnNlX2tleSgpIHJldHVybnMgdGhlc2UgbmVnYXRlZDogKi8KI2RlZmluZSBDT05GSUdfSU5WQUxJRF9LRVkgMQojZGVmaW5lIENPTkZJR19OT19TRUNUSU9OX09SX05BTUUgMgovKiBnaXRfY29uZmlnX3NldCgpLCBnaXRfY29uZmlnX3NldF9tdWx0aXZhcigpIHJldHVybiB0aGUgYWJvdmUgb3IgdGhlc2U6ICovCiNkZWZpbmUgQ09ORklHX05PX0xPQ0sgLTEKI2RlZmluZSBDT05GSUdfSU5WQUxJRF9GSUxFIDMKI2RlZmluZSBDT05GSUdfTk9fV1JJVEUgNAojZGVmaW5lIENPTkZJR19OT1RISU5HX1NFVCA1CiNkZWZpbmUgQ09ORklHX0lOVkFMSURfUEFUVEVSTiA2Cgp0eXBlZGVmIGludCAoKmNvbmZpZ19mbl90KShjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKiwgdm9pZCAqKTsKZXh0ZXJuIGludCBnaXRfZGVmYXVsdF9jb25maWcoY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICosIHZvaWQgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19mcm9tX2ZpbGUoY29uZmlnX2ZuX3QgZm4sIGNvbnN0IGNoYXIgKiwgdm9pZCAqKTsKZXh0ZXJuIHZvaWQgZ2l0X2NvbmZpZ19wdXNoX3BhcmFtZXRlcihjb25zdCBjaGFyICp0ZXh0KTsKZXh0ZXJuIGludCBnaXRfY29uZmlnX3BhcnNlX3BhcmFtZXRlcihjb25zdCBjaGFyICp0ZXh0KTsKZXh0ZXJuIGludCBnaXRfY29uZmlnX3BhcnNlX2Vudmlyb25tZW50KHZvaWQpOwpleHRlcm4gaW50IGdpdF9jb25maWdfZnJvbV9wYXJhbWV0ZXJzKGNvbmZpZ19mbl90IGZuLCB2b2lkICpkYXRhKTsKZXh0ZXJuIGludCBnaXRfY29uZmlnKGNvbmZpZ19mbl90IGZuLCB2b2lkICopOwpleHRlcm4gaW50IGdpdF9jb25maWdfZWFybHkoY29uZmlnX2ZuX3QgZm4sIHZvaWQgKiwgY29uc3QgY2hhciAqcmVwb19jb25maWcpOwpleHRlcm4gaW50IGdpdF9wYXJzZV91bG9uZyhjb25zdCBjaGFyICosIHVuc2lnbmVkIGxvbmcgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19pbnQoY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICopOwpleHRlcm4gdW5zaWduZWQgbG9uZyBnaXRfY29uZmlnX3Vsb25nKGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqKTsKZXh0ZXJuIGludCBnaXRfY29uZmlnX2Jvb2xfb3JfaW50KGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqLCBpbnQgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19ib29sKGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqKTsKZXh0ZXJuIGludCBnaXRfY29uZmlnX21heWJlX2Jvb2woY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICopOwpleHRlcm4gaW50IGdpdF9jb25maWdfc3RyaW5nKGNvbnN0IGNoYXIgKiosIGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqKTsKZXh0ZXJuIGludCBnaXRfY29uZmlnX3BhdGhuYW1lKGNvbnN0IGNoYXIgKiosIGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqKTsKZXh0ZXJuIGludCBnaXRfY29uZmlnX3NldChjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19wYXJzZV9rZXkoY29uc3QgY2hhciAqLCBjaGFyICoqLCBpbnQgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19zZXRfbXVsdGl2YXIoY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKiwgaW50KTsKZXh0ZXJuIGludCBnaXRfY29uZmlnX3JlbmFtZV9zZWN0aW9uKGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdpdF9ldGNfZ2l0Y29uZmlnKHZvaWQpOwpleHRlcm4gaW50IGNoZWNrX3JlcG9zaXRvcnlfZm9ybWF0X3ZlcnNpb24oY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSwgdm9pZCAqY2IpOwpleHRlcm4gaW50IGdpdF9lbnZfYm9vbChjb25zdCBjaGFyICosIGludCk7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19zeXN0ZW0odm9pZCk7CmV4dGVybiBpbnQgY29uZmlnX2Vycm9yX25vbmJvb2woY29uc3QgY2hhciAqKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdldF9sb2dfb3V0cHV0X2VuY29kaW5nKHZvaWQpOwpleHRlcm4gY29uc3QgY2hhciAqZ2V0X2NvbW1pdF9vdXRwdXRfZW5jb2Rpbmcodm9pZCk7CgpleHRlcm4gY29uc3QgY2hhciAqY29uZmlnX2V4Y2x1c2l2ZV9maWxlbmFtZTsKCiNkZWZpbmUgTUFYX0dJVE5BTUUgKDEwMDApCmV4dGVybiBjaGFyIGdpdF9kZWZhdWx0X2VtYWlsW01BWF9HSVROQU1FXTsKZXh0ZXJuIGNoYXIgZ2l0X2RlZmF1bHRfbmFtZVtNQVhfR0lUTkFNRV07CiNkZWZpbmUgSURFTlRfTkFNRV9HSVZFTiAwMQojZGVmaW5lIElERU5UX01BSUxfR0lWRU4gMDIKI2RlZmluZSBJREVOVF9BTExfR0lWRU4gKElERU5UX05BTUVfR0lWRU58SURFTlRfTUFJTF9HSVZFTikKZXh0ZXJuIGludCB1c2VyX2lkZW50X2V4cGxpY2l0bHlfZ2l2ZW47CmV4dGVybiBpbnQgdXNlcl9pZGVudF9zdWZmaWNpZW50bHlfZ2l2ZW4odm9pZCk7CgpleHRlcm4gY29uc3QgY2hhciAqZ2l0X2NvbW1pdF9lbmNvZGluZzsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdpdF9sb2dfb3V0cHV0X2VuY29kaW5nOwpleHRlcm4gY29uc3QgY2hhciAqZ2l0X21haWxtYXBfZmlsZTsKCi8qIElPIGhlbHBlciBmdW5jdGlvbnMgKi8KZXh0ZXJuIHZvaWQgbWF5YmVfZmx1c2hfb3JfZGllKEZJTEUgKiwgY29uc3QgY2hhciAqKTsKZXh0ZXJuIGludCBjb3B5X2ZkKGludCBpZmQsIGludCBvZmQpOwpleHRlcm4gaW50IGNvcHlfZmlsZShjb25zdCBjaGFyICpkc3QsIGNvbnN0IGNoYXIgKnNyYywgaW50IG1vZGUpOwpleHRlcm4gaW50IGNvcHlfZmlsZV93aXRoX3RpbWUoY29uc3QgY2hhciAqZHN0LCBjb25zdCBjaGFyICpzcmMsIGludCBtb2RlKTsKZXh0ZXJuIHZvaWQgd3JpdGVfb3JfZGllKGludCBmZCwgY29uc3Qgdm9pZCAqYnVmLCBzaXplX3QgY291bnQpOwpleHRlcm4gaW50IHdyaXRlX29yX3doaW5lKGludCBmZCwgY29uc3Qgdm9pZCAqYnVmLCBzaXplX3QgY291bnQsIGNvbnN0IGNoYXIgKm1zZyk7CmV4dGVybiBpbnQgd3JpdGVfb3Jfd2hpbmVfcGlwZShpbnQgZmQsIGNvbnN0IHZvaWQgKmJ1Ziwgc2l6ZV90IGNvdW50LCBjb25zdCBjaGFyICptc2cpOwpleHRlcm4gdm9pZCBmc3luY19vcl9kaWUoaW50IGZkLCBjb25zdCBjaGFyICopOwoKZXh0ZXJuIHNzaXplX3QgcmVhZF9pbl9mdWxsKGludCBmZCwgdm9pZCAqYnVmLCBzaXplX3QgY291bnQpOwpleHRlcm4gc3NpemVfdCB3cml0ZV9pbl9mdWxsKGludCBmZCwgY29uc3Qgdm9pZCAqYnVmLCBzaXplX3QgY291bnQpOwpzdGF0aWMgaW5saW5lIHNzaXplX3Qgd3JpdGVfc3RyX2luX2Z1bGwoaW50IGZkLCBjb25zdCBjaGFyICpzdHIpCnsKCXJldHVybiB3cml0ZV9pbl9mdWxsKGZkLCBzdHIsIHN0cmxlbihzdHIpKTsKfQoKLyogcGFnZXIuYyAqLwpleHRlcm4gdm9pZCBzZXR1cF9wYWdlcih2b2lkKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKnBhZ2VyX3Byb2dyYW07CmV4dGVybiBpbnQgcGFnZXJfaW5fdXNlKHZvaWQpOwpleHRlcm4gaW50IHBhZ2VyX3VzZV9jb2xvcjsKCmV4dGVybiBjb25zdCBjaGFyICplZGl0b3JfcHJvZ3JhbTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmFza3Bhc3NfcHJvZ3JhbTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmV4Y2x1ZGVzX2ZpbGU7CgovKiBiYXNlODUgKi8KaW50IGRlY29kZV84NShjaGFyICpkc3QsIGNvbnN0IGNoYXIgKmxpbmUsIGludCBsaW5lbGVuKTsKdm9pZCBlbmNvZGVfODUoY2hhciAqYnVmLCBjb25zdCB1bnNpZ25lZCBjaGFyICpkYXRhLCBpbnQgYnl0ZXMpOwoKLyogYWxsb2MuYyAqLwpleHRlcm4gdm9pZCAqYWxsb2NfYmxvYl9ub2RlKHZvaWQpOwpleHRlcm4gdm9pZCAqYWxsb2NfdHJlZV9ub2RlKHZvaWQpOwpleHRlcm4gdm9pZCAqYWxsb2NfY29tbWl0X25vZGUodm9pZCk7CmV4dGVybiB2b2lkICphbGxvY190YWdfbm9kZSh2b2lkKTsKZXh0ZXJuIHZvaWQgKmFsbG9jX29iamVjdF9ub2RlKHZvaWQpOwpleHRlcm4gdm9pZCBhbGxvY19yZXBvcnQodm9pZCk7CgovKiB0cmFjZS5jICovCl9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpCmV4dGVybiB2b2lkIHRyYWNlX3ByaW50Zihjb25zdCBjaGFyICpmb3JtYXQsIC4uLik7CmV4dGVybiB2b2lkIHRyYWNlX3ZwcmludGYoY29uc3QgY2hhciAqa2V5LCBjb25zdCBjaGFyICpmb3JtYXQsIHZhX2xpc3QgYXApOwpfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMiwgMykpKQpleHRlcm4gdm9pZCB0cmFjZV9hcmd2X3ByaW50Zihjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqZm9ybWF0LCAuLi4pOwpleHRlcm4gdm9pZCB0cmFjZV9yZXBvX3NldHVwKGNvbnN0IGNoYXIgKnByZWZpeCk7CmV4dGVybiBpbnQgdHJhY2Vfd2FudChjb25zdCBjaGFyICprZXkpOwpleHRlcm4gdm9pZCB0cmFjZV9zdHJidWYoY29uc3QgY2hhciAqa2V5LCBjb25zdCBzdHJ1Y3Qgc3RyYnVmICpidWYpOwoKdm9pZCBwYWNrZXRfdHJhY2VfaWRlbnRpdHkoY29uc3QgY2hhciAqcHJvZyk7CgovKiBjb252ZXJ0LmMgKi8KLyogcmV0dXJucyAxIGlmICpkc3Qgd2FzIHVzZWQgKi8KZXh0ZXJuIGludCBjb252ZXJ0X3RvX2dpdChjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFyICpzcmMsIHNpemVfdCBsZW4sCiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0IHN0cmJ1ZiAqZHN0LCBlbnVtIHNhZmVfY3JsZiBjaGVja3NhZmUpOwpleHRlcm4gaW50IGNvbnZlcnRfdG9fd29ya2luZ190cmVlKGNvbnN0IGNoYXIgKnBhdGgsIGNvbnN0IGNoYXIgKnNyYywgc2l6ZV90IGxlbiwgc3RydWN0IHN0cmJ1ZiAqZHN0KTsKZXh0ZXJuIGludCByZW5vcm1hbGl6ZV9idWZmZXIoY29uc3QgY2hhciAqcGF0aCwgY29uc3QgY2hhciAqc3JjLCBzaXplX3QgbGVuLCBzdHJ1Y3Qgc3RyYnVmICpkc3QpOwoKLyogYWRkICovCi8qCiAqIHJldHVybiAwIGlmIHN1Y2Nlc3MsIDEgLSBpZiBhZGRpdGlvbiBvZiBhIGZpbGUgZmFpbGVkIGFuZAogKiBBRERfRklMRVNfSUdOT1JFX0VSUk9SUyB3YXMgc3BlY2lmaWVkIGluIGZsYWdzCiAqLwppbnQgYWRkX2ZpbGVzX3RvX2NhY2hlKGNvbnN0IGNoYXIgKnByZWZpeCwgY29uc3QgY2hhciAqKnBhdGhzcGVjLCBpbnQgZmxhZ3MpOwoKLyogZGlmZi5jICovCmV4dGVybiBpbnQgZGlmZl9hdXRvX3JlZnJlc2hfaW5kZXg7CgovKiBtYXRjaC10cmVlcy5jICovCnZvaWQgc2hpZnRfdHJlZShjb25zdCB1bnNpZ25lZCBjaGFyICosIGNvbnN0IHVuc2lnbmVkIGNoYXIgKiwgdW5zaWduZWQgY2hhciAqLCBpbnQpOwp2b2lkIHNoaWZ0X3RyZWVfYnkoY29uc3QgdW5zaWduZWQgY2hhciAqLCBjb25zdCB1bnNpZ25lZCBjaGFyICosIHVuc2lnbmVkIGNoYXIgKiwgY29uc3QgY2hhciAqKTsKCi8qCiAqIHdoaXRlc3BhY2UgcnVsZXMuCiAqIHVzZWQgYnkgYm90aCBkaWZmIGFuZCBhcHBseQogKiBsYXN0IHR3byBkaWdpdHMgYXJlIHRhYiB3aWR0aAogKi8KI2RlZmluZSBXU19CTEFOS19BVF9FT0wgICAgICAgICAwMTAwCiNkZWZpbmUgV1NfU1BBQ0VfQkVGT1JFX1RBQiAgICAgMDIwMAojZGVmaW5lIFdTX0lOREVOVF9XSVRIX05PTl9UQUIgIDA0MDAKI2RlZmluZSBXU19DUl9BVF9FT0wgICAgICAgICAgIDAxMDAwCiNkZWZpbmUgV1NfQkxBTktfQVRfRU9GICAgICAgICAwMjAwMAojZGVmaW5lIFdTX1RBQl9JTl9JTkRFTlQgICAgICAgMDQwMDAKI2RlZmluZSBXU19UUkFJTElOR19TUEFDRSAgICAgIChXU19CTEFOS19BVF9FT0x8V1NfQkxBTktfQVRfRU9GKQojZGVmaW5lIFdTX0RFRkFVTFRfUlVMRSAoV1NfVFJBSUxJTkdfU1BBQ0V8V1NfU1BBQ0VfQkVGT1JFX1RBQnw4KQojZGVmaW5lIFdTX1RBQl9XSURUSF9NQVNLICAgICAgICAwNzcKZXh0ZXJuIHVuc2lnbmVkIHdoaXRlc3BhY2VfcnVsZV9jZmc7CmV4dGVybiB1bnNpZ25lZCB3aGl0ZXNwYWNlX3J1bGUoY29uc3QgY2hhciAqKTsKZXh0ZXJuIHVuc2lnbmVkIHBhcnNlX3doaXRlc3BhY2VfcnVsZShjb25zdCBjaGFyICopOwpleHRlcm4gdW5zaWduZWQgd3NfY2hlY2soY29uc3QgY2hhciAqbGluZSwgaW50IGxlbiwgdW5zaWduZWQgd3NfcnVsZSk7CmV4dGVybiB2b2lkIHdzX2NoZWNrX2VtaXQoY29uc3QgY2hhciAqbGluZSwgaW50IGxlbiwgdW5zaWduZWQgd3NfcnVsZSwgRklMRSAqc3RyZWFtLCBjb25zdCBjaGFyICpzZXQsIGNvbnN0IGNoYXIgKnJlc2V0LCBjb25zdCBjaGFyICp3cyk7CmV4dGVybiBjaGFyICp3aGl0ZXNwYWNlX2Vycm9yX3N0cmluZyh1bnNpZ25lZCB3cyk7CmV4dGVybiB2b2lkIHdzX2ZpeF9jb3B5KHN0cnVjdCBzdHJidWYgKiwgY29uc3QgY2hhciAqLCBpbnQsIHVuc2lnbmVkLCBpbnQgKik7CmV4dGVybiBpbnQgd3NfYmxhbmtfbGluZShjb25zdCBjaGFyICpsaW5lLCBpbnQgbGVuLCB1bnNpZ25lZCB3c19ydWxlKTsKI2RlZmluZSB3c190YWJfd2lkdGgocnVsZSkgICAgICgocnVsZSkgJiBXU19UQUJfV0lEVEhfTUFTSykKCi8qIGxzLWZpbGVzICovCmludCByZXBvcnRfcGF0aF9lcnJvcihjb25zdCBjaGFyICpwc19tYXRjaGVkLCBjb25zdCBjaGFyICoqcGF0aHNwZWMsIGludCBwcmVmaXhfb2Zmc2V0KTsKdm9pZCBvdmVybGF5X3RyZWVfb25fY2FjaGUoY29uc3QgY2hhciAqdHJlZV9uYW1lLCBjb25zdCBjaGFyICpwcmVmaXgpOwoKY2hhciAqYWxpYXNfbG9va3VwKGNvbnN0IGNoYXIgKmFsaWFzKTsKaW50IHNwbGl0X2NtZGxpbmUoY2hhciAqY21kbGluZSwgY29uc3QgY2hhciAqKiphcmd2KTsKLyogVGFrZXMgYSBuZWdhdGl2ZSB2YWx1ZSByZXR1cm5lZCBieSBzcGxpdF9jbWRsaW5lICovCmNvbnN0IGNoYXIgKnNwbGl0X2NtZGxpbmVfc3RyZXJyb3IoaW50IGNtZGxpbmVfZXJybm8pOwoKLyogZ2l0LmMgKi8Kc3RydWN0IHN0YXJ0dXBfaW5mbyB7CglpbnQgaGF2ZV9yZXBvc2l0b3J5OwoJY29uc3QgY2hhciAqcHJlZml4Owp9OwpleHRlcm4gc3RydWN0IHN0YXJ0dXBfaW5mbyAqc3RhcnR1cF9pbmZvOwoKLyogYnVpbHRpbi9tZXJnZS5jICovCmludCBjaGVja291dF9mYXN0X2ZvcndhcmQoY29uc3QgdW5zaWduZWQgY2hhciAqZnJvbSwgY29uc3QgdW5zaWduZWQgY2hhciAqdG8pOwoKI2VuZGlmIC8qIENBQ0hFX0ggKi8K",
    "text": "#ifndef CACHE_H\n#define CACHE_H\n\n#include \"git-compat-util.h\"\n#include \"strbuf.h\"\n#include \"hash.h\"\n#include \"advice.h\"\n#include \"gettext.h\"\n\n#include SHA1_HEADER\n#ifndef git_SHA_CTX\n#define git_SHA_CTX\tSHA_CTX\n#define git_SHA1_Init\tSHA1_Init\n#define git_SHA1_Update\tSHA1_Update\n#define git_SHA1_Final\tSHA1_Final\n#endif\n\n#include <zlib.h>\n#if defined(NO_DEFLATE_BOUND) || ZLIB_VERNUM < 0x1200\n#define deflateBound(c,s)  ((s) + (((s) + 7) >> 3) + (((s) + 63) >> 6) + 11)\n#endif\n\nvoid git_inflate_init(z_streamp strm);\nvoid git_inflate_end(z_streamp strm);\nint git_inflate(z_streamp strm, int flush);\n\n#if defined(DT_UNKNOWN) && !defined(NO_D_TYPE_IN_DIRENT)\n#define DTYPE(de)\t((de)->d_type)\n#else\n#undef DT_UNKNOWN\n#undef DT_DIR\n#undef DT_REG\n#undef DT_LNK\n#define DT_UNKNOWN\t0\n#define DT_DIR\t\t1\n#define DT_REG\t\t2\n#define DT_LNK\t\t3\n#define DTYPE(de)\tDT_UNKNOWN\n#endif\n\n/* unknown mode (impossible combination S_IFIFO|S_IFCHR) */\n#define S_IFINVALID     0030000\n\n/*\n * A \"directory link\" is a link to another git directory.\n *\n * The value 0160000 is not normally a valid mode, and\n * also just happens to be S_IFDIR + S_IFLNK\n *\n * NOTE! We *really* shouldn't depend on the S_IFxxx macros\n * always having the same values everywhere. We should use\n * our internal git values for these things, and then we can\n * translate that to the OS-specific value. It just so\n * happens that everybody shares the same bit representation\n * in the UNIX world (and apparently wider too..)\n */\n#define S_IFGITLINK\t0160000\n#define S_ISGITLINK(m)\t(((m) & S_IFMT) == S_IFGITLINK)\n\n/*\n * Intensive research over the course of many years has shown that\n * port 9418 is totally unused by anything else. Or\n *\n *\tYour search - \"port 9418\" - did not match any documents.\n *\n * as www.google.com puts it.\n *\n * This port has been properly assigned for git use by IANA:\n * git (Assigned-9418) [I06-050728-0001].\n *\n *\tgit  9418/tcp   git pack transfer service\n *\tgit  9418/udp   git pack transfer service\n *\n * with Linus Torvalds <torvalds@osdl.org> as the point of\n * contact. September 2005.\n *\n * See http://www.iana.org/assignments/port-numbers\n */\n#define DEFAULT_GIT_PORT 9418\n\n/*\n * Basic data structures for the directory cache\n */\n\n#define CACHE_SIGNATURE 0x44495243\t/* \"DIRC\" */\nstruct cache_header {\n\tunsigned int hdr_signature;\n\tunsigned int hdr_version;\n\tunsigned int hdr_entries;\n};\n\n/*\n * The \"cache_time\" is just the low 32 bits of the\n * time. It doesn't matter if it overflows - we only\n * check it for equality in the 32 bits we save.\n */\nstruct cache_time {\n\tunsigned int sec;\n\tunsigned int nsec;\n};\n\n/*\n * dev/ino/uid/gid/size are also just tracked to the low 32 bits\n * Again - this is just a (very strong in practice) heuristic that\n * the inode hasn't changed.\n *\n * We save the fields in big-endian order to allow using the\n * index file over NFS transparently.\n */\nstruct ondisk_cache_entry {\n\tstruct cache_time ctime;\n\tstruct cache_time mtime;\n\tunsigned int dev;\n\tunsigned int ino;\n\tunsigned int mode;\n\tunsigned int uid;\n\tunsigned int gid;\n\tunsigned int size;\n\tunsigned char sha1[20];\n\tunsigned short flags;\n\tchar name[FLEX_ARRAY]; /* more */\n};\n\n/*\n * This struct is used when CE_EXTENDED bit is 1\n * The struct must match ondisk_cache_entry exactly from\n * ctime till flags\n */\nstruct ondisk_cache_entry_extended {\n\tstruct cache_time ctime;\n\tstruct cache_time mtime;\n\tunsigned int dev;\n\tunsigned int ino;\n\tunsigned int mode;\n\tunsigned int uid;\n\tunsigned int gid;\n\tunsigned int size;\n\tunsigned char sha1[20];\n\tunsigned short flags;\n\tunsigned short flags2;\n\tchar name[FLEX_ARRAY]; /* more */\n};\n\nstruct cache_entry {\n\tstruct cache_time ce_ctime;\n\tstruct cache_time ce_mtime;\n\tunsigned int ce_dev;\n\tunsigned int ce_ino;\n\tunsigned int ce_mode;\n\tunsigned int ce_uid;\n\tunsigned int ce_gid;\n\tunsigned int ce_size;\n\tunsigned int ce_flags;\n\tunsigned char sha1[20];\n\tstruct cache_entry *next;\n\tchar name[FLEX_ARRAY]; /* more */\n};\n\n#define CE_NAMEMASK  (0x0fff)\n#define CE_STAGEMASK (0x3000)\n#define CE_EXTENDED  (0x4000)\n#define CE_VALID     (0x8000)\n#define CE_STAGESHIFT 12\n\n/*\n * Range 0xFFFF0000 in ce_flags is divided into\n * two parts: in-memory flags and on-disk ones.\n * Flags in CE_EXTENDED_FLAGS will get saved on-disk\n * if you want to save a new flag, add it in\n * CE_EXTENDED_FLAGS\n *\n * In-memory only flags\n */\n#define CE_UPDATE            (1 << 16)\n#define CE_REMOVE            (1 << 17)\n#define CE_UPTODATE          (1 << 18)\n#define CE_ADDED             (1 << 19)\n\n#define CE_HASHED            (1 << 20)\n#define CE_UNHASHED          (1 << 21)\n#define CE_WT_REMOVE         (1 << 22) /* remove in work directory */\n#define CE_CONFLICTED        (1 << 23)\n\n#define CE_UNPACKED          (1 << 24)\n#define CE_NEW_SKIP_WORKTREE (1 << 25)\n\n/*\n * Extended on-disk flags\n */\n#define CE_INTENT_TO_ADD     (1 << 29)\n#define CE_SKIP_WORKTREE     (1 << 30)\n/* CE_EXTENDED2 is for future extension */\n#define CE_EXTENDED2         (1 << 31)\n\n#define CE_EXTENDED_FLAGS (CE_INTENT_TO_ADD | CE_SKIP_WORKTREE)\n\n/*\n * Safeguard to avoid saving wrong flags:\n *  - CE_EXTENDED2 won't get saved until its semantic is known\n *  - Bits in 0x0000FFFF have been saved in ce_flags already\n *  - Bits in 0x003F0000 are currently in-memory flags\n */\n#if CE_EXTENDED_FLAGS & 0x803FFFFF\n#error \"CE_EXTENDED_FLAGS out of range\"\n#endif\n\n/*\n * Copy the sha1 and stat state of a cache entry from one to\n * another. But we never change the name, or the hash state!\n */\n#define CE_STATE_MASK (CE_HASHED | CE_UNHASHED)\nstatic inline void copy_cache_entry(struct cache_entry *dst, struct cache_entry *src)\n{\n\tunsigned int state = dst->ce_flags & CE_STATE_MASK;\n\n\t/* Don't copy hash chain and name */\n\tmemcpy(dst, src, offsetof(struct cache_entry, next));\n\n\t/* Restore the hash state */\n\tdst->ce_flags = (dst->ce_flags & ~CE_STATE_MASK) | state;\n}\n\nstatic inline unsigned create_ce_flags(size_t len, unsigned stage)\n{\n\tif (len >= CE_NAMEMASK)\n\t\tlen = CE_NAMEMASK;\n\treturn (len | (stage << CE_STAGESHIFT));\n}\n\nstatic inline size_t ce_namelen(const struct cache_entry *ce)\n{\n\tsize_t len = ce->ce_flags & CE_NAMEMASK;\n\tif (len < CE_NAMEMASK)\n\t\treturn len;\n\treturn strlen(ce->name + CE_NAMEMASK) + CE_NAMEMASK;\n}\n\n#define ce_size(ce) cache_entry_size(ce_namelen(ce))\n#define ondisk_ce_size(ce) (((ce)->ce_flags & CE_EXTENDED) ? \\\n\t\t\t    ondisk_cache_entry_extended_size(ce_namelen(ce)) : \\\n\t\t\t    ondisk_cache_entry_size(ce_namelen(ce)))\n#define ce_stage(ce) ((CE_STAGEMASK & (ce)->ce_flags) >> CE_STAGESHIFT)\n#define ce_uptodate(ce) ((ce)->ce_flags & CE_UPTODATE)\n#define ce_skip_worktree(ce) ((ce)->ce_flags & CE_SKIP_WORKTREE)\n#define ce_mark_uptodate(ce) ((ce)->ce_flags |= CE_UPTODATE)\n\n#define ce_permissions(mode) (((mode) & 0100) ? 0755 : 0644)\nstatic inline unsigned int create_ce_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\tif (S_ISDIR(mode) || S_ISGITLINK(mode))\n\t\treturn S_IFGITLINK;\n\treturn S_IFREG | ce_permissions(mode);\n}\nstatic inline unsigned int ce_mode_from_stat(struct cache_entry *ce, unsigned int mode)\n{\n\textern int trust_executable_bit, has_symlinks;\n\tif (!has_symlinks && S_ISREG(mode) &&\n\t    ce && S_ISLNK(ce->ce_mode))\n\t\treturn ce->ce_mode;\n\tif (!trust_executable_bit && S_ISREG(mode)) {\n\t\tif (ce && S_ISREG(ce->ce_mode))\n\t\t\treturn ce->ce_mode;\n\t\treturn create_ce_mode(0666);\n\t}\n\treturn create_ce_mode(mode);\n}\nstatic inline int ce_to_dtype(const struct cache_entry *ce)\n{\n\tunsigned ce_mode = ntohl(ce->ce_mode);\n\tif (S_ISREG(ce_mode))\n\t\treturn DT_REG;\n\telse if (S_ISDIR(ce_mode) || S_ISGITLINK(ce_mode))\n\t\treturn DT_DIR;\n\telse if (S_ISLNK(ce_mode))\n\t\treturn DT_LNK;\n\telse\n\t\treturn DT_UNKNOWN;\n}\nstatic inline unsigned int canon_mode(unsigned int mode)\n{\n\tif (S_ISREG(mode))\n\t\treturn S_IFREG | ce_permissions(mode);\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\tif (S_ISDIR(mode))\n\t\treturn S_IFDIR;\n\treturn S_IFGITLINK;\n}\n\n#define flexible_size(STRUCT,len) ((offsetof(struct STRUCT,name) + (len) + 8) & ~7)\n#define cache_entry_size(len) flexible_size(cache_entry,len)\n#define ondisk_cache_entry_size(len) flexible_size(ondisk_cache_entry,len)\n#define ondisk_cache_entry_extended_size(len) flexible_size(ondisk_cache_entry_extended,len)\n\nstruct index_state {\n\tstruct cache_entry **cache;\n\tunsigned int cache_nr, cache_alloc, cache_changed;\n\tstruct string_list *resolve_undo;\n\tstruct cache_tree *cache_tree;\n\tstruct cache_time timestamp;\n\tvoid *alloc;\n\tunsigned name_hash_initialized : 1,\n\t\t initialized : 1;\n\tstruct hash_table name_hash;\n};\n\nextern struct index_state the_index;\n\n/* Name hashing */\nextern void add_name_hash(struct index_state *istate, struct cache_entry *ce);\n/*\n * We don't actually *remove* it, we can just mark it invalid so that\n * we won't find it in lookups.\n *\n * Not only would we have to search the lists (simple enough), but\n * we'd also have to rehash other hash buckets in case this makes the\n * hash bucket empty (common). So it's much better to just mark\n * it.\n */\nstatic inline void remove_name_hash(struct cache_entry *ce)\n{\n\tce->ce_flags |= CE_UNHASHED;\n}\n\n\n#ifndef NO_THE_INDEX_COMPATIBILITY_MACROS\n#define active_cache (the_index.cache)\n#define active_nr (the_index.cache_nr)\n#define active_alloc (the_index.cache_alloc)\n#define active_cache_changed (the_index.cache_changed)\n#define active_cache_tree (the_index.cache_tree)\n\n#define read_cache() read_index(&the_index)\n#define read_cache_from(path) read_index_from(&the_index, (path))\n#define read_cache_preload(pathspec) read_index_preload(&the_index, (pathspec))\n#define is_cache_unborn() is_index_unborn(&the_index)\n#define read_cache_unmerged() read_index_unmerged(&the_index)\n#define write_cache(newfd, cache, entries) write_index(&the_index, (newfd))\n#define discard_cache() discard_index(&the_index)\n#define unmerged_cache() unmerged_index(&the_index)\n#define cache_name_pos(name, namelen) index_name_pos(&the_index,(name),(namelen))\n#define add_cache_entry(ce, option) add_index_entry(&the_index, (ce), (option))\n#define rename_cache_entry_at(pos, new_name) rename_index_entry_at(&the_index, (pos), (new_name))\n#define remove_cache_entry_at(pos) remove_index_entry_at(&the_index, (pos))\n#define remove_file_from_cache(path) remove_file_from_index(&the_index, (path))\n#define add_to_cache(path, st, flags) add_to_index(&the_index, (path), (st), (flags))\n#define add_file_to_cache(path, flags) add_file_to_index(&the_index, (path), (flags))\n#define refresh_cache(flags) refresh_index(&the_index, (flags), NULL, NULL, NULL)\n#define ce_match_stat(ce, st, options) ie_match_stat(&the_index, (ce), (st), (options))\n#define ce_modified(ce, st, options) ie_modified(&the_index, (ce), (st), (options))\n#define cache_name_exists(name, namelen, igncase) index_name_exists(&the_index, (name), (namelen), (igncase))\n#define cache_name_is_other(name, namelen) index_name_is_other(&the_index, (name), (namelen))\n#define resolve_undo_clear() resolve_undo_clear_index(&the_index)\n#define unmerge_cache_entry_at(at) unmerge_index_entry_at(&the_index, at)\n#define unmerge_cache(pathspec) unmerge_index(&the_index, pathspec)\n#endif\n\nenum object_type {\n\tOBJ_BAD = -1,\n\tOBJ_NONE = 0,\n\tOBJ_COMMIT = 1,\n\tOBJ_TREE = 2,\n\tOBJ_BLOB = 3,\n\tOBJ_TAG = 4,\n\t/* 5 for future expansion */\n\tOBJ_OFS_DELTA = 6,\n\tOBJ_REF_DELTA = 7,\n\tOBJ_ANY,\n\tOBJ_MAX\n};\n\nstatic inline enum object_type object_type(unsigned int mode)\n{\n\treturn S_ISDIR(mode) ? OBJ_TREE :\n\t\tS_ISGITLINK(mode) ? OBJ_COMMIT :\n\t\tOBJ_BLOB;\n}\n\n#define GIT_DIR_ENVIRONMENT \"GIT_DIR\"\n#define GIT_WORK_TREE_ENVIRONMENT \"GIT_WORK_TREE\"\n#define DEFAULT_GIT_DIR_ENVIRONMENT \".git\"\n#define DB_ENVIRONMENT \"GIT_OBJECT_DIRECTORY\"\n#define INDEX_ENVIRONMENT \"GIT_INDEX_FILE\"\n#define GRAFT_ENVIRONMENT \"GIT_GRAFT_FILE\"\n#define TEMPLATE_DIR_ENVIRONMENT \"GIT_TEMPLATE_DIR\"\n#define CONFIG_ENVIRONMENT \"GIT_CONFIG\"\n#define CONFIG_DATA_ENVIRONMENT \"GIT_CONFIG_PARAMETERS\"\n#define EXEC_PATH_ENVIRONMENT \"GIT_EXEC_PATH\"\n#define CEILING_DIRECTORIES_ENVIRONMENT \"GIT_CEILING_DIRECTORIES\"\n#define NO_REPLACE_OBJECTS_ENVIRONMENT \"GIT_NO_REPLACE_OBJECTS\"\n#define GITATTRIBUTES_FILE \".gitattributes\"\n#define INFOATTRIBUTES_FILE \"info/attributes\"\n#define ATTRIBUTE_MACRO_PREFIX \"[attr]\"\n#define GIT_NOTES_REF_ENVIRONMENT \"GIT_NOTES_REF\"\n#define GIT_NOTES_DEFAULT_REF \"refs/notes/commits\"\n#define GIT_NOTES_DISPLAY_REF_ENVIRONMENT \"GIT_NOTES_DISPLAY_REF\"\n#define GIT_NOTES_REWRITE_REF_ENVIRONMENT \"GIT_NOTES_REWRITE_REF\"\n#define GIT_NOTES_REWRITE_MODE_ENVIRONMENT \"GIT_NOTES_REWRITE_MODE\"\n\n/*\n * Repository-local GIT_* environment variables\n * The array is NULL-terminated to simplify its usage in contexts such\n * environment creation or simple walk of the list.\n * The number of non-NULL entries is available as a macro.\n */\n#define LOCAL_REPO_ENV_SIZE 9\nextern const char *const local_repo_env[LOCAL_REPO_ENV_SIZE + 1];\n\nextern int is_bare_repository_cfg;\nextern int is_bare_repository(void);\nextern int is_inside_git_dir(void);\nextern char *git_work_tree_cfg;\nextern int is_inside_work_tree(void);\nextern int have_git_dir(void);\nextern const char *get_git_dir(void);\nextern char *get_object_directory(void);\nextern char *get_index_file(void);\nextern char *get_graft_file(void);\nextern int set_git_dir(const char *path);\nextern const char *get_git_work_tree(void);\nextern const char *read_gitfile_gently(const char *path);\nextern void set_git_work_tree(const char *tree);\n\n#define ALTERNATE_DB_ENVIRONMENT \"GIT_ALTERNATE_OBJECT_DIRECTORIES\"\n\nextern const char **get_pathspec(const char *prefix, const char **pathspec);\nextern void setup_work_tree(void);\nextern const char *setup_git_directory_gently(int *);\nextern const char *setup_git_directory(void);\nextern char *prefix_path(const char *prefix, int len, const char *path);\nextern const char *prefix_filename(const char *prefix, int len, const char *path);\nextern int check_filename(const char *prefix, const char *name);\nextern void verify_filename(const char *prefix, const char *name);\nextern void verify_non_filename(const char *prefix, const char *name);\n\n#define INIT_DB_QUIET 0x0001\n\nextern int set_git_dir_init(const char *git_dir, const char *real_git_dir, int);\nextern int init_db(const char *template_dir, unsigned int flags);\n\n#define alloc_nr(x) (((x)+16)*3/2)\n\n/*\n * Realloc the buffer pointed at by variable 'x' so that it can hold\n * at least 'nr' entries; the number of entries currently allocated\n * is 'alloc', using the standard growing factor alloc_nr() macro.\n *\n * DO NOT USE any expression with side-effect for 'x', 'nr', or 'alloc'.\n */\n#define ALLOC_GROW(x, nr, alloc) \\\n\tdo { \\\n\t\tif ((nr) > alloc) { \\\n\t\t\tif (alloc_nr(alloc) < (nr)) \\\n\t\t\t\talloc = (nr); \\\n\t\t\telse \\\n\t\t\t\talloc = alloc_nr(alloc); \\\n\t\t\tx = xrealloc((x), alloc * sizeof(*(x))); \\\n\t\t} \\\n\t} while (0)\n\n/* Initialize and use the cache information */\nextern int read_index(struct index_state *);\nextern int read_index_preload(struct index_state *, const char **pathspec);\nextern int read_index_from(struct index_state *, const char *path);\nextern int is_index_unborn(struct index_state *);\nextern int read_index_unmerged(struct index_state *);\nextern int write_index(struct index_state *, int newfd);\nextern int discard_index(struct index_state *);\nextern int unmerged_index(const struct index_state *);\nextern int verify_path(const char *path);\nextern struct cache_entry *index_name_exists(struct index_state *istate, const char *name, int namelen, int igncase);\nextern int index_name_pos(const struct index_state *, const char *name, int namelen);\n#define ADD_CACHE_OK_TO_ADD 1\t\t/* Ok to add */\n#define ADD_CACHE_OK_TO_REPLACE 2\t/* Ok to replace file/directory */\n#define ADD_CACHE_SKIP_DFCHECK 4\t/* Ok to skip DF conflict checks */\n#define ADD_CACHE_JUST_APPEND 8\t\t/* Append only; tree.c::read_tree() */\n#define ADD_CACHE_NEW_ONLY 16\t\t/* Do not replace existing ones */\nextern int add_index_entry(struct index_state *, struct cache_entry *ce, int option);\nextern void rename_index_entry_at(struct index_state *, int pos, const char *new_name);\nextern int remove_index_entry_at(struct index_state *, int pos);\nextern void remove_marked_cache_entries(struct index_state *istate);\nextern int remove_file_from_index(struct index_state *, const char *path);\n#define ADD_CACHE_VERBOSE 1\n#define ADD_CACHE_PRETEND 2\n#define ADD_CACHE_IGNORE_ERRORS\t4\n#define ADD_CACHE_IGNORE_REMOVAL 8\n#define ADD_CACHE_INTENT 16\nextern int add_to_index(struct index_state *, const char *path, struct stat *, int flags);\nextern int add_file_to_index(struct index_state *, const char *path, int flags);\nextern struct cache_entry *make_cache_entry(unsigned int mode, const unsigned char *sha1, const char *path, int stage, int refresh);\nextern int ce_same_name(struct cache_entry *a, struct cache_entry *b);\nextern int index_name_is_other(const struct index_state *, const char *, int);\n\n/* do stat comparison even if CE_VALID is true */\n#define CE_MATCH_IGNORE_VALID\t\t01\n/* do not check the contents but report dirty on racily-clean entries */\n#define CE_MATCH_RACY_IS_DIRTY\t\t02\n/* do stat comparison even if CE_SKIP_WORKTREE is true */\n#define CE_MATCH_IGNORE_SKIP_WORKTREE\t04\nextern int ie_match_stat(const struct index_state *, struct cache_entry *, struct stat *, unsigned int);\nextern int ie_modified(const struct index_state *, struct cache_entry *, struct stat *, unsigned int);\n\nstruct pathspec {\n\tconst char **raw; /* get_pathspec() result, not freed by free_pathspec() */\n\tint nr;\n\tunsigned int has_wildcard:1;\n\tunsigned int recursive:1;\n\tint max_depth;\n\tstruct pathspec_item {\n\t\tconst char *match;\n\t\tint len;\n\t\tunsigned int use_wildcard:1;\n\t} *items;\n};\n\nextern int init_pathspec(struct pathspec *, const char **);\nextern void free_pathspec(struct pathspec *);\nextern int ce_path_match(const struct cache_entry *ce, const struct pathspec *pathspec);\n\n#define HASH_WRITE_OBJECT 1\n#define HASH_FORMAT_CHECK 2\nextern int index_fd(unsigned char *sha1, int fd, struct stat *st, enum object_type type, const char *path, unsigned flags);\nextern int index_path(unsigned char *sha1, const char *path, struct stat *st, unsigned flags);\nextern void fill_stat_cache_info(struct cache_entry *ce, struct stat *st);\n\n#define REFRESH_REALLY\t\t0x0001\t/* ignore_valid */\n#define REFRESH_UNMERGED\t0x0002\t/* allow unmerged */\n#define REFRESH_QUIET\t\t0x0004\t/* be quiet about it */\n#define REFRESH_IGNORE_MISSING\t0x0008\t/* ignore non-existent */\n#define REFRESH_IGNORE_SUBMODULES\t0x0010\t/* ignore submodules */\n#define REFRESH_IN_PORCELAIN\t0x0020\t/* user friendly output, not \"needs update\" */\nextern int refresh_index(struct index_state *, unsigned int flags, const char **pathspec, char *seen, const char *header_msg);\n\nstruct lock_file {\n\tstruct lock_file *next;\n\tint fd;\n\tpid_t owner;\n\tchar on_list;\n\tchar filename[PATH_MAX];\n};\n#define LOCK_DIE_ON_ERROR 1\n#define LOCK_NODEREF 2\nextern int unable_to_lock_error(const char *path, int err);\nextern NORETURN void unable_to_lock_index_die(const char *path, int err);\nextern int hold_lock_file_for_update(struct lock_file *, const char *path, int);\nextern int hold_lock_file_for_append(struct lock_file *, const char *path, int);\nextern int commit_lock_file(struct lock_file *);\nextern void update_index_if_able(struct index_state *, struct lock_file *);\n\nextern int hold_locked_index(struct lock_file *, int);\nextern int commit_locked_index(struct lock_file *);\nextern void set_alternate_index_output(const char *);\nextern int close_lock_file(struct lock_file *);\nextern void rollback_lock_file(struct lock_file *);\nextern int delete_ref(const char *, const unsigned char *sha1, int delopt);\n\n/* Environment bits from configuration mechanism */\nextern int trust_executable_bit;\nextern int trust_ctime;\nextern int quote_path_fully;\nextern int has_symlinks;\nextern int minimum_abbrev, default_abbrev;\nextern int ignore_case;\nextern int assume_unchanged;\nextern int prefer_symlink_refs;\nextern int log_all_ref_updates;\nextern int warn_ambiguous_refs;\nextern int shared_repository;\nextern const char *apply_default_whitespace;\nextern const char *apply_default_ignorewhitespace;\nextern int zlib_compression_level;\nextern int core_compression_level;\nextern int core_compression_seen;\nextern size_t packed_git_window_size;\nextern size_t packed_git_limit;\nextern size_t delta_base_cache_limit;\nextern unsigned long big_file_threshold;\nextern int read_replace_refs;\nextern int fsync_object_files;\nextern int core_preload_index;\nextern int core_apply_sparse_checkout;\n\nenum safe_crlf {\n\tSAFE_CRLF_FALSE = 0,\n\tSAFE_CRLF_FAIL = 1,\n\tSAFE_CRLF_WARN = 2\n};\n\nextern enum safe_crlf safe_crlf;\n\nenum auto_crlf {\n\tAUTO_CRLF_FALSE = 0,\n\tAUTO_CRLF_TRUE = 1,\n\tAUTO_CRLF_INPUT = -1\n};\n\nextern enum auto_crlf auto_crlf;\n\nenum eol {\n\tEOL_UNSET,\n\tEOL_CRLF,\n\tEOL_LF,\n#ifdef NATIVE_CRLF\n\tEOL_NATIVE = EOL_CRLF\n#else\n\tEOL_NATIVE = EOL_LF\n#endif\n};\n\nextern enum eol core_eol;\n\nenum branch_track {\n\tBRANCH_TRACK_UNSPECIFIED = -1,\n\tBRANCH_TRACK_NEVER = 0,\n\tBRANCH_TRACK_REMOTE,\n\tBRANCH_TRACK_ALWAYS,\n\tBRANCH_TRACK_EXPLICIT,\n\tBRANCH_TRACK_OVERRIDE\n};\n\nenum rebase_setup_type {\n\tAUTOREBASE_NEVER = 0,\n\tAUTOREBASE_LOCAL,\n\tAUTOREBASE_REMOTE,\n\tAUTOREBASE_ALWAYS\n};\n\nenum push_default_type {\n\tPUSH_DEFAULT_NOTHING = 0,\n\tPUSH_DEFAULT_MATCHING,\n\tPUSH_DEFAULT_UPSTREAM,\n\tPUSH_DEFAULT_CURRENT\n};\n\nextern enum branch_track git_branch_track;\nextern enum rebase_setup_type autorebase;\nextern enum push_default_type push_default;\n\nenum object_creation_mode {\n\tOBJECT_CREATION_USES_HARDLINKS = 0,\n\tOBJECT_CREATION_USES_RENAMES = 1\n};\n\nextern enum object_creation_mode object_creation_mode;\n\nextern char *notes_ref_name;\n\nextern int grafts_replace_parents;\n\n#define GIT_REPO_VERSION 0\nextern int repository_format_version;\nextern int check_repository_format(void);\n\n#define MTIME_CHANGED\t0x0001\n#define CTIME_CHANGED\t0x0002\n#define OWNER_CHANGED\t0x0004\n#define MODE_CHANGED    0x0008\n#define INODE_CHANGED   0x0010\n#define DATA_CHANGED    0x0020\n#define TYPE_CHANGED    0x0040\n\nextern char *mksnpath(char *buf, size_t n, const char *fmt, ...)\n\t__attribute__((format (printf, 3, 4)));\nextern char *git_snpath(char *buf, size_t n, const char *fmt, ...)\n\t__attribute__((format (printf, 3, 4)));\nextern char *git_pathdup(const char *fmt, ...)\n\t__attribute__((format (printf, 1, 2)));\n\n/* Return a statically allocated filename matching the sha1 signature */\nextern char *mkpath(const char *fmt, ...) __attribute__((format (printf, 1, 2)));\nextern char *git_path(const char *fmt, ...) __attribute__((format (printf, 1, 2)));\nextern char *git_path_submodule(const char *path, const char *fmt, ...)\n\t__attribute__((format (printf, 2, 3)));\n\nextern char *sha1_file_name(const unsigned char *sha1);\nextern char *sha1_pack_name(const unsigned char *sha1);\nextern char *sha1_pack_index_name(const unsigned char *sha1);\nextern const char *find_unique_abbrev(const unsigned char *sha1, int);\nextern const unsigned char null_sha1[20];\n\nstatic inline int hashcmp(const unsigned char *sha1, const unsigned char *sha2)\n{\n\tint i;\n\n\tfor (i = 0; i < 20; i++, sha1++, sha2++) {\n\t\tif (*sha1 != *sha2)\n\t\t\treturn *sha1 - *sha2;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int is_null_sha1(const unsigned char *sha1)\n{\n\treturn !hashcmp(sha1, null_sha1);\n}\n\nstatic inline void hashcpy(unsigned char *sha_dst, const unsigned char *sha_src)\n{\n\tmemcpy(sha_dst, sha_src, 20);\n}\nstatic inline void hashclr(unsigned char *hash)\n{\n\tmemset(hash, 0, 20);\n}\n\n#define EMPTY_TREE_SHA1_HEX \\\n\t\"4b825dc642cb6eb9a060e54bf8d69288fbee4904\"\n#define EMPTY_TREE_SHA1_BIN_LITERAL \\\n\t \"\\x4b\\x82\\x5d\\xc6\\x42\\xcb\\x6e\\xb9\\xa0\\x60\" \\\n\t \"\\xe5\\x4b\\xf8\\xd6\\x92\\x88\\xfb\\xee\\x49\\x04\"\n#define EMPTY_TREE_SHA1_BIN \\\n\t ((const unsigned char *) EMPTY_TREE_SHA1_BIN_LITERAL)\n\nint git_mkstemp(char *path, size_t n, const char *template);\n\nint git_mkstemps(char *path, size_t n, const char *template, int suffix_len);\n\n/* set default permissions by passing mode arguments to open(2) */\nint git_mkstemps_mode(char *pattern, int suffix_len, int mode);\nint git_mkstemp_mode(char *pattern, int mode);\n\n/*\n * NOTE NOTE NOTE!!\n *\n * PERM_UMASK, OLD_PERM_GROUP and OLD_PERM_EVERYBODY enumerations must\n * not be changed. Old repositories have core.sharedrepository written in\n * numeric format, and therefore these values are preserved for compatibility\n * reasons.\n */\nenum sharedrepo {\n\tPERM_UMASK          = 0,\n\tOLD_PERM_GROUP      = 1,\n\tOLD_PERM_EVERYBODY  = 2,\n\tPERM_GROUP          = 0660,\n\tPERM_EVERYBODY      = 0664\n};\nint git_config_perm(const char *var, const char *value);\nint set_shared_perm(const char *path, int mode);\n#define adjust_shared_perm(path) set_shared_perm((path), 0)\nint safe_create_leading_directories(char *path);\nint safe_create_leading_directories_const(const char *path);\nint mkdir_in_gitdir(const char *path);\nextern char *expand_user_path(const char *path);\nchar *enter_repo(char *path, int strict);\nstatic inline int is_absolute_path(const char *path)\n{\n\treturn path[0] == '/' || has_dos_drive_prefix(path);\n}\nint is_directory(const char *);\nconst char *real_path(const char *path);\nconst char *absolute_path(const char *path);\nconst char *relative_path(const char *abs, const char *base);\nint normalize_path_copy(char *dst, const char *src);\nint longest_ancestor_length(const char *path, const char *prefix_list);\nchar *strip_path_suffix(const char *path, const char *suffix);\nint daemon_avoid_alias(const char *path);\nint offset_1st_component(const char *path);\n\n/* object replacement */\n#define READ_SHA1_FILE_REPLACE 1\nextern void *read_sha1_file_extended(const unsigned char *sha1, enum object_type *type, unsigned long *size, unsigned flag);\nstatic inline void *read_sha1_file(const unsigned char *sha1, enum object_type *type, unsigned long *size)\n{\n\treturn read_sha1_file_extended(sha1, type, size, READ_SHA1_FILE_REPLACE);\n}\nextern const unsigned char *do_lookup_replace_object(const unsigned char *sha1);\nstatic inline const unsigned char *lookup_replace_object(const unsigned char *sha1)\n{\n\tif (!read_replace_refs)\n\t\treturn sha1;\n\treturn do_lookup_replace_object(sha1);\n}\n\n/* Read and unpack a sha1 file into memory, write memory to a sha1 file */\nextern int sha1_object_info(const unsigned char *, unsigned long *);\nextern int hash_sha1_file(const void *buf, unsigned long len, const char *type, unsigned char *sha1);\nextern int write_sha1_file(const void *buf, unsigned long len, const char *type, unsigned char *return_sha1);\nextern int pretend_sha1_file(void *, unsigned long, enum object_type, unsigned char *);\nextern int force_object_loose(const unsigned char *sha1, time_t mtime);\n\n/* global flag to enable extra checks when accessing packed objects */\nextern int do_check_packed_object_crc;\n\nextern int check_sha1_signature(const unsigned char *sha1, void *buf, unsigned long size, const char *type);\n\nextern int move_temp_to_file(const char *tmpfile, const char *filename);\n\nextern int has_sha1_pack(const unsigned char *sha1);\nextern int has_sha1_file(const unsigned char *sha1);\nextern int has_loose_object_nonlocal(const unsigned char *sha1);\n\nextern int has_pack_index(const unsigned char *sha1);\n\nextern void assert_sha1_type(const unsigned char *sha1, enum object_type expect);\n\nextern const signed char hexval_table[256];\nstatic inline unsigned int hexval(unsigned char c)\n{\n\treturn hexval_table[c];\n}\n\n/* Convert to/from hex/sha1 representation */\n#define MINIMUM_ABBREV minimum_abbrev\n#define DEFAULT_ABBREV default_abbrev\n\nstruct object_context {\n\tunsigned char tree[20];\n\tchar path[PATH_MAX];\n\tunsigned mode;\n};\n\nextern int get_sha1(const char *str, unsigned char *sha1);\nextern int get_sha1_with_mode_1(const char *str, unsigned char *sha1, unsigned *mode, int only_to_die, const char *prefix);\nstatic inline int get_sha1_with_mode(const char *str, unsigned char *sha1, unsigned *mode)\n{\n\treturn get_sha1_with_mode_1(str, sha1, mode, 0, NULL);\n}\nextern int get_sha1_with_context_1(const char *name, unsigned char *sha1, struct object_context *orc, int only_to_die, const char *prefix);\nstatic inline int get_sha1_with_context(const char *str, unsigned char *sha1, struct object_context *orc)\n{\n\treturn get_sha1_with_context_1(str, sha1, orc, 0, NULL);\n}\nextern int get_sha1_hex(const char *hex, unsigned char *sha1);\nextern char *sha1_to_hex(const unsigned char *sha1);\t/* static buffer result! */\nextern int read_ref(const char *filename, unsigned char *sha1);\nextern const char *resolve_ref(const char *path, unsigned char *sha1, int, int *);\nextern int dwim_ref(const char *str, int len, unsigned char *sha1, char **ref);\nextern int dwim_log(const char *str, int len, unsigned char *sha1, char **ref);\nextern int interpret_branch_name(const char *str, struct strbuf *);\nextern int get_sha1_mb(const char *str, unsigned char *sha1);\n\nextern int refname_match(const char *abbrev_name, const char *full_name, const char **rules);\nextern const char *ref_rev_parse_rules[];\nextern const char *ref_fetch_rules[];\n\nextern int create_symref(const char *ref, const char *refs_heads_master, const char *logmsg);\nextern int validate_headref(const char *ref);\n\nextern int base_name_compare(const char *name1, int len1, int mode1, const char *name2, int len2, int mode2);\nextern int df_name_compare(const char *name1, int len1, int mode1, const char *name2, int len2, int mode2);\nextern int cache_name_compare(const char *name1, int len1, const char *name2, int len2);\n\nextern void *read_object_with_reference(const unsigned char *sha1,\n\t\t\t\t\tconst char *required_type,\n\t\t\t\t\tunsigned long *size,\n\t\t\t\t\tunsigned char *sha1_ret);\n\nextern struct object *peel_to_type(const char *name, int namelen,\n\t\t\t\t   struct object *o, enum object_type);\n\nenum date_mode {\n\tDATE_NORMAL = 0,\n\tDATE_RELATIVE,\n\tDATE_SHORT,\n\tDATE_LOCAL,\n\tDATE_ISO8601,\n\tDATE_RFC2822,\n\tDATE_RAW\n};\n\nconst char *show_date(unsigned long time, int timezone, enum date_mode mode);\nconst char *show_date_relative(unsigned long time, int tz,\n\t\t\t       const struct timeval *now,\n\t\t\t       char *timebuf,\n\t\t\t       size_t timebuf_size);\nint parse_date(const char *date, char *buf, int bufsize);\nint parse_date_basic(const char *date, unsigned long *timestamp, int *offset);\nvoid datestamp(char *buf, int bufsize);\n#define approxidate(s) approxidate_careful((s), NULL)\nunsigned long approxidate_careful(const char *, int *);\nunsigned long approxidate_relative(const char *date, const struct timeval *now);\nenum date_mode parse_date_format(const char *format);\n\n#define IDENT_WARN_ON_NO_NAME  1\n#define IDENT_ERROR_ON_NO_NAME 2\n#define IDENT_NO_DATE\t       4\nextern const char *git_author_info(int);\nextern const char *git_committer_info(int);\nextern const char *fmt_ident(const char *name, const char *email, const char *date_str, int);\nextern const char *fmt_name(const char *name, const char *email);\nextern const char *git_editor(void);\nextern const char *git_pager(int stdout_is_tty);\n\nstruct checkout {\n\tconst char *base_dir;\n\tint base_dir_len;\n\tunsigned force:1,\n\t\t quiet:1,\n\t\t not_new:1,\n\t\t refresh_cache:1;\n};\n\nextern int checkout_entry(struct cache_entry *ce, const struct checkout *state, char *topath);\n\nstruct cache_def {\n\tchar path[PATH_MAX + 1];\n\tint len;\n\tint flags;\n\tint track_flags;\n\tint prefix_len_stat_func;\n};\n\nextern int has_symlink_leading_path(const char *name, int len);\nextern int threaded_has_symlink_leading_path(struct cache_def *, const char *, int);\nextern int check_leading_path(const char *name, int len);\nextern int has_dirs_only_path(const char *name, int len, int prefix_len);\nextern void schedule_dir_for_removal(const char *name, int len);\nextern void remove_scheduled_dirs(void);\n\nextern struct alternate_object_database {\n\tstruct alternate_object_database *next;\n\tchar *name;\n\tchar base[FLEX_ARRAY]; /* more */\n} *alt_odb_list;\nextern void prepare_alt_odb(void);\nextern void add_to_alternates_file(const char *reference);\ntypedef int alt_odb_fn(struct alternate_object_database *, void *);\nextern void foreach_alt_odb(alt_odb_fn, void*);\n\nstruct pack_window {\n\tstruct pack_window *next;\n\tunsigned char *base;\n\toff_t offset;\n\tsize_t len;\n\tunsigned int last_used;\n\tunsigned int inuse_cnt;\n};\n\nextern struct packed_git {\n\tstruct packed_git *next;\n\tstruct pack_window *windows;\n\toff_t pack_size;\n\tconst void *index_data;\n\tsize_t index_size;\n\tuint32_t num_objects;\n\tuint32_t num_bad_objects;\n\tunsigned char *bad_object_sha1;\n\tint index_version;\n\ttime_t mtime;\n\tint pack_fd;\n\tunsigned pack_local:1,\n\t\t pack_keep:1,\n\t\t do_not_close:1;\n\tunsigned char sha1[20];\n\t/* something like \".git/objects/pack/xxxxx.pack\" */\n\tchar pack_name[FLEX_ARRAY]; /* more */\n} *packed_git;\n\nstruct pack_entry {\n\toff_t offset;\n\tunsigned char sha1[20];\n\tstruct packed_git *p;\n};\n\nstruct ref {\n\tstruct ref *next;\n\tunsigned char old_sha1[20];\n\tunsigned char new_sha1[20];\n\tchar *symref;\n\tunsigned int force:1,\n\t\tmerge:1,\n\t\tnonfastforward:1,\n\t\tdeletion:1;\n\tenum {\n\t\tREF_STATUS_NONE = 0,\n\t\tREF_STATUS_OK,\n\t\tREF_STATUS_REJECT_NONFASTFORWARD,\n\t\tREF_STATUS_REJECT_NODELETE,\n\t\tREF_STATUS_UPTODATE,\n\t\tREF_STATUS_REMOTE_REJECT,\n\t\tREF_STATUS_EXPECTING_REPORT\n\t} status;\n\tchar *remote_status;\n\tstruct ref *peer_ref; /* when renaming */\n\tchar name[FLEX_ARRAY]; /* more */\n};\n\n#define REF_NORMAL\t(1u << 0)\n#define REF_HEADS\t(1u << 1)\n#define REF_TAGS\t(1u << 2)\n\nextern struct ref *find_ref_by_name(const struct ref *list, const char *name);\n\n#define CONNECT_VERBOSE       (1u << 0)\nextern char *git_getpass(const char *prompt);\nextern struct child_process *git_connect(int fd[2], const char *url, const char *prog, int flags);\nextern int finish_connect(struct child_process *conn);\nextern int git_connection_is_socket(struct child_process *conn);\nextern int path_match(const char *path, int nr, char **match);\nstruct extra_have_objects {\n\tint nr, alloc;\n\tunsigned char (*array)[20];\n};\nextern struct ref **get_remote_heads(int in, struct ref **list, int nr_match, char **match, unsigned int flags, struct extra_have_objects *);\nextern int server_supports(const char *feature);\n\nextern struct packed_git *parse_pack_index(unsigned char *sha1, const char *idx_path);\n\nextern void prepare_packed_git(void);\nextern void reprepare_packed_git(void);\nextern void install_packed_git(struct packed_git *pack);\n\nextern struct packed_git *find_sha1_pack(const unsigned char *sha1,\n\t\t\t\t\t struct packed_git *packs);\n\nextern void pack_report(void);\nextern int open_pack_index(struct packed_git *);\nextern void close_pack_index(struct packed_git *);\nextern unsigned char *use_pack(struct packed_git *, struct pack_window **, off_t, unsigned int *);\nextern void close_pack_windows(struct packed_git *);\nextern void unuse_pack(struct pack_window **);\nextern void free_pack_by_name(const char *);\nextern void clear_delta_base_cache(void);\nextern struct packed_git *add_packed_git(const char *, int, int);\nextern const unsigned char *nth_packed_object_sha1(struct packed_git *, uint32_t);\nextern off_t nth_packed_object_offset(const struct packed_git *, uint32_t);\nextern off_t find_pack_entry_one(const unsigned char *, struct packed_git *);\nextern void *unpack_entry(struct packed_git *, off_t, enum object_type *, unsigned long *);\nextern unsigned long unpack_object_header_buffer(const unsigned char *buf, unsigned long len, enum object_type *type, unsigned long *sizep);\nextern unsigned long get_size_from_delta(struct packed_git *, struct pack_window **, off_t);\nextern const char *packed_object_info_detail(struct packed_git *, off_t, unsigned long *, unsigned long *, unsigned int *, unsigned char *);\n\n/* Dumb servers support */\nextern int update_server_info(int);\n\n/* git_config_parse_key() returns these negated: */\n#define CONFIG_INVALID_KEY 1\n#define CONFIG_NO_SECTION_OR_NAME 2\n/* git_config_set(), git_config_set_multivar() return the above or these: */\n#define CONFIG_NO_LOCK -1\n#define CONFIG_INVALID_FILE 3\n#define CONFIG_NO_WRITE 4\n#define CONFIG_NOTHING_SET 5\n#define CONFIG_INVALID_PATTERN 6\n\ntypedef int (*config_fn_t)(const char *, const char *, void *);\nextern int git_default_config(const char *, const char *, void *);\nextern int git_config_from_file(config_fn_t fn, const char *, void *);\nextern void git_config_push_parameter(const char *text);\nextern int git_config_parse_parameter(const char *text);\nextern int git_config_parse_environment(void);\nextern int git_config_from_parameters(config_fn_t fn, void *data);\nextern int git_config(config_fn_t fn, void *);\nextern int git_config_early(config_fn_t fn, void *, const char *repo_config);\nextern int git_parse_ulong(const char *, unsigned long *);\nextern int git_config_int(const char *, const char *);\nextern unsigned long git_config_ulong(const char *, const char *);\nextern int git_config_bool_or_int(const char *, const char *, int *);\nextern int git_config_bool(const char *, const char *);\nextern int git_config_maybe_bool(const char *, const char *);\nextern int git_config_string(const char **, const char *, const char *);\nextern int git_config_pathname(const char **, const char *, const char *);\nextern int git_config_set(const char *, const char *);\nextern int git_config_parse_key(const char *, char **, int *);\nextern int git_config_set_multivar(const char *, const char *, const char *, int);\nextern int git_config_rename_section(const char *, const char *);\nextern const char *git_etc_gitconfig(void);\nextern int check_repository_format_version(const char *var, const char *value, void *cb);\nextern int git_env_bool(const char *, int);\nextern int git_config_system(void);\nextern int config_error_nonbool(const char *);\nextern const char *get_log_output_encoding(void);\nextern const char *get_commit_output_encoding(void);\n\nextern const char *config_exclusive_filename;\n\n#define MAX_GITNAME (1000)\nextern char git_default_email[MAX_GITNAME];\nextern char git_default_name[MAX_GITNAME];\n#define IDENT_NAME_GIVEN 01\n#define IDENT_MAIL_GIVEN 02\n#define IDENT_ALL_GIVEN (IDENT_NAME_GIVEN|IDENT_MAIL_GIVEN)\nextern int user_ident_explicitly_given;\nextern int user_ident_sufficiently_given(void);\n\nextern const char *git_commit_encoding;\nextern const char *git_log_output_encoding;\nextern const char *git_mailmap_file;\n\n/* IO helper functions */\nextern void maybe_flush_or_die(FILE *, const char *);\nextern int copy_fd(int ifd, int ofd);\nextern int copy_file(const char *dst, const char *src, int mode);\nextern int copy_file_with_time(const char *dst, const char *src, int mode);\nextern void write_or_die(int fd, const void *buf, size_t count);\nextern int write_or_whine(int fd, const void *buf, size_t count, const char *msg);\nextern int write_or_whine_pipe(int fd, const void *buf, size_t count, const char *msg);\nextern void fsync_or_die(int fd, const char *);\n\nextern ssize_t read_in_full(int fd, void *buf, size_t count);\nextern ssize_t write_in_full(int fd, const void *buf, size_t count);\nstatic inline ssize_t write_str_in_full(int fd, const char *str)\n{\n\treturn write_in_full(fd, str, strlen(str));\n}\n\n/* pager.c */\nextern void setup_pager(void);\nextern const char *pager_program;\nextern int pager_in_use(void);\nextern int pager_use_color;\n\nextern const char *editor_program;\nextern const char *askpass_program;\nextern const char *excludes_file;\n\n/* base85 */\nint decode_85(char *dst, const char *line, int linelen);\nvoid encode_85(char *buf, const unsigned char *data, int bytes);\n\n/* alloc.c */\nextern void *alloc_blob_node(void);\nextern void *alloc_tree_node(void);\nextern void *alloc_commit_node(void);\nextern void *alloc_tag_node(void);\nextern void *alloc_object_node(void);\nextern void alloc_report(void);\n\n/* trace.c */\n__attribute__((format (printf, 1, 2)))\nextern void trace_printf(const char *format, ...);\nextern void trace_vprintf(const char *key, const char *format, va_list ap);\n__attribute__((format (printf, 2, 3)))\nextern void trace_argv_printf(const char **argv, const char *format, ...);\nextern void trace_repo_setup(const char *prefix);\nextern int trace_want(const char *key);\nextern void trace_strbuf(const char *key, const struct strbuf *buf);\n\nvoid packet_trace_identity(const char *prog);\n\n/* convert.c */\n/* returns 1 if *dst was used */\nextern int convert_to_git(const char *path, const char *src, size_t len,\n                          struct strbuf *dst, enum safe_crlf checksafe);\nextern int convert_to_working_tree(const char *path, const char *src, size_t len, struct strbuf *dst);\nextern int renormalize_buffer(const char *path, const char *src, size_t len, struct strbuf *dst);\n\n/* add */\n/*\n * return 0 if success, 1 - if addition of a file failed and\n * ADD_FILES_IGNORE_ERRORS was specified in flags\n */\nint add_files_to_cache(const char *prefix, const char **pathspec, int flags);\n\n/* diff.c */\nextern int diff_auto_refresh_index;\n\n/* match-trees.c */\nvoid shift_tree(const unsigned char *, const unsigned char *, unsigned char *, int);\nvoid shift_tree_by(const unsigned char *, const unsigned char *, unsigned char *, const char *);\n\n/*\n * whitespace rules.\n * used by both diff and apply\n * last two digits are tab width\n */\n#define WS_BLANK_AT_EOL         0100\n#define WS_SPACE_BEFORE_TAB     0200\n#define WS_INDENT_WITH_NON_TAB  0400\n#define WS_CR_AT_EOL           01000\n#define WS_BLANK_AT_EOF        02000\n#define WS_TAB_IN_INDENT       04000\n#define WS_TRAILING_SPACE      (WS_BLANK_AT_EOL|WS_BLANK_AT_EOF)\n#define WS_DEFAULT_RULE (WS_TRAILING_SPACE|WS_SPACE_BEFORE_TAB|8)\n#define WS_TAB_WIDTH_MASK        077\nextern unsigned whitespace_rule_cfg;\nextern unsigned whitespace_rule(const char *);\nextern unsigned parse_whitespace_rule(const char *);\nextern unsigned ws_check(const char *line, int len, unsigned ws_rule);\nextern void ws_check_emit(const char *line, int len, unsigned ws_rule, FILE *stream, const char *set, const char *reset, const char *ws);\nextern char *whitespace_error_string(unsigned ws);\nextern void ws_fix_copy(struct strbuf *, const char *, int, unsigned, int *);\nextern int ws_blank_line(const char *line, int len, unsigned ws_rule);\n#define ws_tab_width(rule)     ((rule) & WS_TAB_WIDTH_MASK)\n\n/* ls-files */\nint report_path_error(const char *ps_matched, const char **pathspec, int prefix_offset);\nvoid overlay_tree_on_cache(const char *tree_name, const char *prefix);\n\nchar *alias_lookup(const char *alias);\nint split_cmdline(char *cmdline, const char ***argv);\n/* Takes a negative value returned by split_cmdline */\nconst char *split_cmdline_strerror(int cmdline_errno);\n\n/* git.c */\nstruct startup_info {\n\tint have_repository;\n\tconst char *prefix;\n};\nextern struct startup_info *startup_info;\n\n/* builtin/merge.c */\nint checkout_fast_forward(const unsigned char *from, const unsigned char *to);\n\n#endif /* CACHE_H */\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "009b365370f0815e4493f4775f96ebda3cfa6e80",
  "sha1_ok": true,
  "size": 42291
}
