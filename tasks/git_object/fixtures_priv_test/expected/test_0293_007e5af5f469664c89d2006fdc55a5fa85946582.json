{
  "content": {
    "base64": "IyEvYmluL3NoCiMKIyBDb3B5cmlnaHQgKGMpIDIwMDcgU2hhd24gUGVhcmNlCiMKCnRlc3RfZGVzY3JpcHRpb249J3Rlc3QgZ2l0IGZhc3QtaW1wb3J0IHV0aWxpdHknCi4gLi90ZXN0LWxpYi5zaAouICIkVEVTVF9ESVJFQ1RPUlkiL2RpZmYtbGliLnNoIDsjIHRlc3QtbGliIGNoZGlyJ3MgaW50byB0cmFzaAoKIyBQcmludCAkMSBieXRlcyBmcm9tIHN0ZGluIHRvIHN0ZG91dC4KIwojIFRoaXMgY291bGQgYmUgd3JpdHRlbiBhcyAiaGVhZCAtYyAkMSIsIGJ1dCBJUklYICJoZWFkIiBkb2VzIG5vdAojIHN1cHBvcnQgdGhlIC1jIG9wdGlvbi4KaGVhZF9jICgpIHsKCSRQRVJMX1BBVEggLWUgJwoJCW15ICRsZW4gPSAkQVJHVlsxXTsKCQl3aGlsZSAoJGxlbiA+IDApIHsKCQkJbXkgJHM7CgkJCW15ICRucmVhZCA9IHN5c3JlYWQoU1RESU4sICRzLCAkbGVuKTsKCQkJZGllICJjYW5ub3QgcmVhZDogJCEiIHVubGVzcyBkZWZpbmVkKCRucmVhZCk7CgkJCXByaW50ICRzOwoJCQkkbGVuIC09ICRucmVhZDsKCQl9CgknIC0gIiQxIgp9Cgp2ZXJpZnlfcGFja3MgKCkgewoJZm9yIHAgaW4gLmdpdC9vYmplY3RzL3BhY2svKi5wYWNrCglkbwoJCWdpdCB2ZXJpZnktcGFjayAiJEAiICIkcCIgfHwgcmV0dXJuCglkb25lCn0KCmZpbGUyX2RhdGE9J2ZpbGUyCnNlY29uZCBsaW5lIG9mIEVPRicKCmZpbGUzX2RhdGE9J0VPRgppbiAzcmQgZmlsZQogRU5EJwoKZmlsZTRfZGF0YT1hYmNkCmZpbGU0X2xlbj00CgpmaWxlNV9kYXRhPSdhbiBpbmxpbmUgZmlsZS4KICB3ZSBzaG91bGQgc2VlIGl0IGxhdGVyLicKCmZpbGU2X2RhdGE9JyMhL2Jpbi9zaAplY2hvICIkQCInCgo+ZW1wdHkKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3NldHVwOiBoYXZlIHBpcGVzPycgJwoJcm0gLWYgZnJvYiAmJgoJaWYgbWtmaWZvIGZyb2IKCXRoZW4KCQl0ZXN0X3NldF9wcmVyZXEgUElQRQoJZmkKJwoKIyMjCiMjIyBzZXJpZXMgQQojIyMKCnRlc3RfdGljawoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnZW1wdHkgc3RyZWFtIHN1Y2NlZWRzJyAnCglnaXQgZmFzdC1pbXBvcnQgPC9kZXYvbnVsbAonCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmJsb2IKbWFyayA6MgpkYXRhIDw8RU9GCiRmaWxlMl9kYXRhCkVPRgoKYmxvYgptYXJrIDozCmRhdGEgPDxFTkQKJGZpbGUzX2RhdGEKRU5ECgpibG9iCm1hcmsgOjQKZGF0YSAkZmlsZTRfbGVuCiRmaWxlNF9kYXRhCmNvbW1pdCByZWZzL2hlYWRzL21hc3RlcgptYXJrIDo1CmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCmluaXRpYWwKQ09NTUlUCgpNIDY0NCA6MiBmaWxlMgpNIDY0NCA6MyBmaWxlMwpNIDc1NSA6NCBmaWxlNAoKdGFnIHNlcmllcy1BCmZyb20gOjUKZGF0YSA8PEVPRgpBbiBhbm5vdGF0ZWQgdGFnIHdpdGhvdXQgYSB0YWdnZXIKRU9GCgp0YWcgc2VyaWVzLUEtYmxvYgpmcm9tIDozCmRhdGEgPDxFT0YKQW4gYW5ub3RhdGVkIHRhZyB0aGF0IGFubm90YXRlcyBhIGJsb2IuCkVPRgoKSU5QVVRfRU5ECnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAogICAgJ0E6IGNyZWF0ZSBwYWNrIGZyb20gc3RkaW4nIFwKICAgICdnaXQgZmFzdC1pbXBvcnQgLS1leHBvcnQtbWFya3M9bWFya3Mub3V0IDxpbnB1dCAmJgoJIGdpdCB3aGF0Y2hhbmdlZCBtYXN0ZXInCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdBOiB2ZXJpZnkgcGFjaycgJwoJdmVyaWZ5X3BhY2tzCicKCmNhdCA+ZXhwZWN0IDw8RU9GCmF1dGhvciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCmluaXRpYWwKRU9GCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ0E6IHZlcmlmeSBjb21taXQnIFwKCSdnaXQgY2F0LWZpbGUgY29tbWl0IG1hc3RlciB8IHNlZCAxZCA+YWN0dWFsICYmCgl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsJwoKY2F0ID5leHBlY3QgPDxFT0YKMTAwNjQ0IGJsb2IgZmlsZTIKMTAwNjQ0IGJsb2IgZmlsZTMKMTAwNzU1IGJsb2IgZmlsZTQKRU9GCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ0E6IHZlcmlmeSB0cmVlJyBcCgknZ2l0IGNhdC1maWxlIC1wIG1hc3Rlcl57dHJlZX0gfCBzZWQgInMvIFswLTlhLWZdKgkvIC8iID5hY3R1YWwgJiYKCSB0ZXN0X2NtcCBleHBlY3QgYWN0dWFsJwoKZWNobyAiJGZpbGUyX2RhdGEiID5leHBlY3QKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknQTogdmVyaWZ5IGZpbGUyJyBcCgknZ2l0IGNhdC1maWxlIGJsb2IgbWFzdGVyOmZpbGUyID5hY3R1YWwgJiYgdGVzdF9jbXAgZXhwZWN0IGFjdHVhbCcKCmVjaG8gIiRmaWxlM19kYXRhIiA+ZXhwZWN0CnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ0E6IHZlcmlmeSBmaWxlMycgXAoJJ2dpdCBjYXQtZmlsZSBibG9iIG1hc3RlcjpmaWxlMyA+YWN0dWFsICYmIHRlc3RfY21wIGV4cGVjdCBhY3R1YWwnCgpwcmludGYgIiRmaWxlNF9kYXRhIiA+ZXhwZWN0CnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ0E6IHZlcmlmeSBmaWxlNCcgXAoJJ2dpdCBjYXQtZmlsZSBibG9iIG1hc3RlcjpmaWxlNCA+YWN0dWFsICYmIHRlc3RfY21wIGV4cGVjdCBhY3R1YWwnCgpjYXQgPmV4cGVjdCA8PEVPRgpvYmplY3QgJChnaXQgcmV2LXBhcnNlIHJlZnMvaGVhZHMvbWFzdGVyKQp0eXBlIGNvbW1pdAp0YWcgc2VyaWVzLUEKCkFuIGFubm90YXRlZCB0YWcgd2l0aG91dCBhIHRhZ2dlcgpFT0YKdGVzdF9leHBlY3Rfc3VjY2VzcyAnQTogdmVyaWZ5IHRhZy9zZXJpZXMtQScgJwoJZ2l0IGNhdC1maWxlIHRhZyB0YWdzL3Nlcmllcy1BID5hY3R1YWwgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwKJwoKY2F0ID5leHBlY3QgPDxFT0YKb2JqZWN0ICQoZ2l0IHJldi1wYXJzZSByZWZzL2hlYWRzL21hc3RlcjpmaWxlMykKdHlwZSBibG9iCnRhZyBzZXJpZXMtQS1ibG9iCgpBbiBhbm5vdGF0ZWQgdGFnIHRoYXQgYW5ub3RhdGVzIGEgYmxvYi4KRU9GCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ0E6IHZlcmlmeSB0YWcvc2VyaWVzLUEtYmxvYicgJwoJZ2l0IGNhdC1maWxlIHRhZyB0YWdzL3Nlcmllcy1BLWJsb2IgPmFjdHVhbCAmJgoJdGVzdF9jbXAgZXhwZWN0IGFjdHVhbAonCgpjYXQgPmV4cGVjdCA8PEVPRgo6MiBgZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSBtYXN0ZXI6ZmlsZTJgCjozIGBnaXQgcmV2LXBhcnNlIC0tdmVyaWZ5IG1hc3RlcjpmaWxlM2AKOjQgYGdpdCByZXYtcGFyc2UgLS12ZXJpZnkgbWFzdGVyOmZpbGU0YAo6NSBgZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSBtYXN0ZXJeMGAKRU9GCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ0E6IHZlcmlmeSBtYXJrcyBvdXRwdXQnIFwKCSd0ZXN0X2NtcCBleHBlY3QgbWFya3Mub3V0JwoKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknQTogdmVyaWZ5IG1hcmtzIGltcG9ydCcgXAoJJ2dpdCBmYXN0LWltcG9ydCBcCgkJLS1pbXBvcnQtbWFya3M9bWFya3Mub3V0IFwKCQktLWV4cG9ydC1tYXJrcz1tYXJrcy5uZXcgXAoJCTwvZGV2L251bGwgJiYKCXRlc3RfY21wIGV4cGVjdCBtYXJrcy5uZXcnCgp0ZXN0X3RpY2sKbmV3X2Jsb2I9JChlY2hvIHRlc3RpbmcgfCBnaXQgaGFzaC1vYmplY3QgLS1zdGRpbikKY2F0ID5pbnB1dCA8PElOUFVUX0VORAp0YWcgc2VyaWVzLUEtYmxvYi0yCmZyb20gJChnaXQgcmV2LXBhcnNlIHJlZnMvaGVhZHMvbWFzdGVyOmZpbGUzKQpkYXRhIDw8RU9GClRhZyBibG9iIGJ5IHNoYTEuCkVPRgoKYmxvYgptYXJrIDo2CmRhdGEgPDxFT0YKdGVzdGluZwpFT0YKCmNvbW1pdCByZWZzL2hlYWRzL25ld19ibG9iCmNvbW1pdHRlciAgPD4gMCArMDAwMApkYXRhIDAKTSA2NDQgOjYgbmV3X2Jsb2IKI3ByZXRlbmQgd2UgZ290IHNoYTEgZnJvbSBmYXN0LWltcG9ydApscyAibmV3X2Jsb2IiCgp0YWcgc2VyaWVzLUEtYmxvYi0zCmZyb20gJG5ld19ibG9iCmRhdGEgPDxFT0YKVGFnIG5ld19ibG9iLgpFT0YKSU5QVVRfRU5ECgpjYXQgPmV4cGVjdCA8PEVPRgpvYmplY3QgJChnaXQgcmV2LXBhcnNlIHJlZnMvaGVhZHMvbWFzdGVyOmZpbGUzKQp0eXBlIGJsb2IKdGFnIHNlcmllcy1BLWJsb2ItMgoKVGFnIGJsb2IgYnkgc2hhMS4Kb2JqZWN0ICRuZXdfYmxvYgp0eXBlIGJsb2IKdGFnIHNlcmllcy1BLWJsb2ItMwoKVGFnIG5ld19ibG9iLgpFT0YKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ0E6IHRhZyBibG9iIGJ5IHNoYTEnIFwKCSdnaXQgZmFzdC1pbXBvcnQgPGlucHV0ICYmCglnaXQgY2F0LWZpbGUgdGFnIHRhZ3Mvc2VyaWVzLUEtYmxvYi0yID5hY3R1YWwgJiYKCWdpdCBjYXQtZmlsZSB0YWcgdGFncy9zZXJpZXMtQS1ibG9iLTMgPj5hY3R1YWwgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwnCgp0ZXN0X3RpY2sKY2F0ID5pbnB1dCA8PElOUFVUX0VORApjb21taXQgcmVmcy9oZWFkcy92ZXJpZnktLWltcG9ydC1tYXJrcwpjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSA8PENPTU1JVApyZWNyZWF0ZSBmcm9tIDo1CkNPTU1JVAoKZnJvbSA6NQpNIDc1NSA6MiBjb3B5LW9mLWZpbGUyCgpJTlBVVF9FTkQKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknQTogdmVyaWZ5IG1hcmtzIGltcG9ydCBkb2VzIG5vdCBjcmFzaCcgXAoJJ2dpdCBmYXN0LWltcG9ydCAtLWltcG9ydC1tYXJrcz1tYXJrcy5vdXQgPGlucHV0ICYmCgkgZ2l0IHdoYXRjaGFuZ2VkIHZlcmlmeS0taW1wb3J0LW1hcmtzJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnQTogdmVyaWZ5IHBhY2snICcKCXZlcmlmeV9wYWNrcwonCgpjYXQgPmV4cGVjdCA8PEVPRgo6MDAwMDAwIDEwMDc1NSAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIDcxMjNmN2Y0NGUzOWJlMTI3YzVlYjcwMWU1OTY4MTc2ZWU5ZDc4YjEgQQljb3B5LW9mLWZpbGUyCkVPRgpnaXQgZGlmZi10cmVlIC1NIC1yIG1hc3RlciB2ZXJpZnktLWltcG9ydC1tYXJrcyA+YWN0dWFsCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ0E6IHZlcmlmeSBkaWZmJyBcCgknY29tcGFyZV9kaWZmX3JhdyBleHBlY3QgYWN0dWFsICYmCgkgdGVzdCBgZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSBtYXN0ZXI6ZmlsZTJgIFwKCSAgICA9IGBnaXQgcmV2LXBhcnNlIC0tdmVyaWZ5IHZlcmlmeS0taW1wb3J0LW1hcmtzOmNvcHktb2YtZmlsZTJgJwoKdGVzdF90aWNrCm10PSQoZ2l0IGhhc2gtb2JqZWN0IC0tc3RkaW4gPCAvZGV2L251bGwpCjogPmlucHV0LmJsb2IKOiA+bWFya3MuZXhwCjogPnRyZWUuZXhwCgpjYXQgPmlucHV0LmNvbW1pdCA8PEVPRgpjb21taXQgcmVmcy9oZWFkcy92ZXJpZnktLWR1bXAtbWFya3MKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgPDxDT01NSVQKdGVzdCB0aGUgc3BhcnNlIGFycmF5IGR1bXBpbmcgcm91dGluZXMgd2l0aCBleHBvbmVudGlhbGx5IGdyb3dpbmcgbWFya3MKQ09NTUlUCkVPRgoKaT0wCmw9NAptPTYKbj03CndoaWxlIHRlc3QgIiRpIiAtbHQgMjc7IGRvCiAgICBjYXQgPj5pbnB1dC5ibG9iIDw8RU9GCmJsb2IKbWFyayA6JGwKZGF0YSAwCmJsb2IKbWFyayA6JG0KZGF0YSAwCmJsb2IKbWFyayA6JG4KZGF0YSAwCkVPRgogICAgZWNobyAiTSAxMDA2NDQgOiRsIGwkaSIgPj5pbnB1dC5jb21taXQKICAgIGVjaG8gIk0gMTAwNjQ0IDokbSBtJGkiID4+aW5wdXQuY29tbWl0CiAgICBlY2hvICJNIDEwMDY0NCA6JG4gbiRpIiA+PmlucHV0LmNvbW1pdAoKICAgIGVjaG8gIjokbCAkbXQiID4+bWFya3MuZXhwCiAgICBlY2hvICI6JG0gJG10IiA+Pm1hcmtzLmV4cAogICAgZWNobyAiOiRuICRtdCIgPj5tYXJrcy5leHAKCiAgICBwcmludGYgIjEwMDY0NCBibG9iICRtdFx0bCRpXG4iID4+dHJlZS5leHAKICAgIHByaW50ZiAiMTAwNjQ0IGJsb2IgJG10XHRtJGlcbiIgPj50cmVlLmV4cAogICAgcHJpbnRmICIxMDA2NDQgYmxvYiAkbXRcdG4kaVxuIiA+PnRyZWUuZXhwCgogICAgbD0kKCgkbCArICRsKSkKICAgIG09JCgoJG0gKyAkbSkpCiAgICBuPSQoKCRsICsgJG4pKQoKICAgIGk9JCgoMSArICRpKSkKZG9uZQoKc29ydCB0cmVlLmV4cCA+IHRyZWUuZXhwX3MKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ0E6IGV4cG9ydCBtYXJrcyB3aXRoIGxhcmdlIHZhbHVlcycgJwoJY2F0IGlucHV0LmJsb2IgaW5wdXQuY29tbWl0IHwgZ2l0IGZhc3QtaW1wb3J0IC0tZXhwb3J0LW1hcmtzPW1hcmtzLmxhcmdlICYmCglnaXQgbHMtdHJlZSByZWZzL2hlYWRzL3ZlcmlmeS0tZHVtcC1tYXJrcyA+dHJlZS5vdXQgJiYKCXRlc3RfY21wIHRyZWUuZXhwX3MgdHJlZS5vdXQgJiYKCXRlc3RfY21wIG1hcmtzLmV4cCBtYXJrcy5sYXJnZScKCiMjIwojIyMgc2VyaWVzIEIKIyMjCgp0ZXN0X3RpY2sKY2F0ID5pbnB1dCA8PElOUFVUX0VORApjb21taXQgcmVmcy9oZWFkcy9icmFuY2gKbWFyayA6MQpjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSA8PENPTU1JVApjb3JydXB0CkNPTU1JVAoKZnJvbSByZWZzL2hlYWRzL21hc3RlcgpNIDc1NSAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxIHplcm8xCgpJTlBVVF9FTkQKdGVzdF9leHBlY3Rfc3VjY2VzcyAnQjogZmFpbCBvbiBpbnZhbGlkIGJsb2Igc2hhMScgJwogICAgdGVzdF9tdXN0X2ZhaWwgZ2l0IGZhc3QtaW1wb3J0IDxpbnB1dAonCnJtIC1mIC5naXQvb2JqZWN0cy9wYWNrXyogLmdpdC9vYmplY3RzL2luZGV4XyoKCmNhdCA+aW5wdXQgPDxJTlBVVF9FTkQKY29tbWl0IC5iYWRicmFuY2huYW1lCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCmNvcnJ1cHQKQ09NTUlUCgpmcm9tIHJlZnMvaGVhZHMvbWFzdGVyCgpJTlBVVF9FTkQKdGVzdF9leHBlY3Rfc3VjY2VzcyAnQjogZmFpbCBvbiBpbnZhbGlkIGJyYW5jaCBuYW1lICIuYmFkYnJhbmNobmFtZSInICcKICAgIHRlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCA8aW5wdXQKJwpybSAtZiAuZ2l0L29iamVjdHMvcGFja18qIC5naXQvb2JqZWN0cy9pbmRleF8qCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmNvbW1pdCBiYWRbYnJhbmNoXW5hbWUKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgPDxDT01NSVQKY29ycnVwdApDT01NSVQKCmZyb20gcmVmcy9oZWFkcy9tYXN0ZXIKCklOUFVUX0VORAp0ZXN0X2V4cGVjdF9zdWNjZXNzICdCOiBmYWlsIG9uIGludmFsaWQgYnJhbmNoIG5hbWUgImJhZFticmFuY2hdbmFtZSInICcKICAgIHRlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCA8aW5wdXQKJwpybSAtZiAuZ2l0L29iamVjdHMvcGFja18qIC5naXQvb2JqZWN0cy9pbmRleF8qCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmNvbW1pdCBURU1QX1RBRwpjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSA8PENPTU1JVAp0YWcgYmFzZQpDT01NSVQKCmZyb20gcmVmcy9oZWFkcy9tYXN0ZXIKCklOUFVUX0VORAp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKICAgICdCOiBhY2NlcHQgYnJhbmNoIG5hbWUgIlRFTVBfVEFHIicgXAogICAgJ2dpdCBmYXN0LWltcG9ydCA8aW5wdXQgJiYKCSB0ZXN0IC1mIC5naXQvVEVNUF9UQUcgJiYKCSB0ZXN0IGBnaXQgcmV2LXBhcnNlIG1hc3RlcmAgPSBgZ2l0IHJldi1wYXJzZSBURU1QX1RBR15gJwpybSAtZiAuZ2l0L1RFTVBfVEFHCgpnaXQgZ2MgMj4vZGV2L251bGwgPi9kZXYvbnVsbApnaXQgcHJ1bmUgMj4vZGV2L251bGwgPi9kZXYvbnVsbAoKY2F0ID5pbnB1dCA8PElOUFVUX0VORApjb21taXQgcmVmcy9oZWFkcy9lbXB0eS1jb21taXR0ZXItMQpjb21taXR0ZXIgIDw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSA8PENPTU1JVAplbXB0eSBjb21taXQKQ09NTUlUCklOUFVUX0VORAp0ZXN0X2V4cGVjdF9zdWNjZXNzICdCOiBhY2NlcHQgZW1wdHkgY29tbWl0dGVyJyAnCglnaXQgZmFzdC1pbXBvcnQgPGlucHV0ICYmCglvdXQ9JChnaXQgZnNjaykgJiYKCWVjaG8gIiRvdXQiICYmCgl0ZXN0IC16ICIkb3V0IgonCmdpdCB1cGRhdGUtcmVmIC1kIHJlZnMvaGVhZHMvZW1wdHktY29tbWl0dGVyLTEgfHwgdHJ1ZQoKZ2l0IGdjIDI+L2Rldi9udWxsID4vZGV2L251bGwKZ2l0IHBydW5lIDI+L2Rldi9udWxsID4vZGV2L251bGwKCmNhdCA+aW5wdXQgPDxJTlBVVF9FTkQKY29tbWl0IHJlZnMvaGVhZHMvZW1wdHktY29tbWl0dGVyLTIKY29tbWl0dGVyIDxhQGIuY29tPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgPDxDT01NSVQKZW1wdHkgY29tbWl0CkNPTU1JVApJTlBVVF9FTkQKdGVzdF9leHBlY3Rfc3VjY2VzcyAnQjogYWNjZXB0IGFuZCBmaXh1cCBjb21taXR0ZXIgd2l0aCBubyBuYW1lJyAnCglnaXQgZmFzdC1pbXBvcnQgPGlucHV0ICYmCglvdXQ9JChnaXQgZnNjaykgJiYKCWVjaG8gIiRvdXQiICYmCgl0ZXN0IC16ICIkb3V0IgonCmdpdCB1cGRhdGUtcmVmIC1kIHJlZnMvaGVhZHMvZW1wdHktY29tbWl0dGVyLTIgfHwgdHJ1ZQoKZ2l0IGdjIDI+L2Rldi9udWxsID4vZGV2L251bGwKZ2l0IHBydW5lIDI+L2Rldi9udWxsID4vZGV2L251bGwKCmNhdCA+aW5wdXQgPDxJTlBVVF9FTkQKY29tbWl0IHJlZnMvaGVhZHMvaW52YWxpZC1jb21taXR0ZXIKY29tbWl0dGVyIE5hbWUgZW1haWw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSA8PENPTU1JVAplbXB0eSBjb21taXQKQ09NTUlUCklOUFVUX0VORAp0ZXN0X2V4cGVjdF9zdWNjZXNzICdCOiBmYWlsIG9uIGludmFsaWQgY29tbWl0dGVyICgxKScgJwoJdGVzdF9tdXN0X2ZhaWwgZ2l0IGZhc3QtaW1wb3J0IDxpbnB1dAonCmdpdCB1cGRhdGUtcmVmIC1kIHJlZnMvaGVhZHMvaW52YWxpZC1jb21taXR0ZXIgfHwgdHJ1ZQoKY2F0ID5pbnB1dCA8PElOUFVUX0VORApjb21taXQgcmVmcy9oZWFkcy9pbnZhbGlkLWNvbW1pdHRlcgpjb21taXR0ZXIgTmFtZSA8ZTxtYWlsPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgPDxDT01NSVQKZW1wdHkgY29tbWl0CkNPTU1JVApJTlBVVF9FTkQKdGVzdF9leHBlY3Rfc3VjY2VzcyAnQjogZmFpbCBvbiBpbnZhbGlkIGNvbW1pdHRlciAoMiknICcKCXRlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCA8aW5wdXQKJwpnaXQgdXBkYXRlLXJlZiAtZCByZWZzL2hlYWRzL2ludmFsaWQtY29tbWl0dGVyIHx8IHRydWUKCmNhdCA+aW5wdXQgPDxJTlBVVF9FTkQKY29tbWl0IHJlZnMvaGVhZHMvaW52YWxpZC1jb21taXR0ZXIKY29tbWl0dGVyIE5hbWUgPGVtYWlsPj4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCmVtcHR5IGNvbW1pdApDT01NSVQKSU5QVVRfRU5ECnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ0I6IGZhaWwgb24gaW52YWxpZCBjb21taXR0ZXIgKDMpJyAnCgl0ZXN0X211c3RfZmFpbCBnaXQgZmFzdC1pbXBvcnQgPGlucHV0CicKZ2l0IHVwZGF0ZS1yZWYgLWQgcmVmcy9oZWFkcy9pbnZhbGlkLWNvbW1pdHRlciB8fCB0cnVlCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmNvbW1pdCByZWZzL2hlYWRzL2ludmFsaWQtY29tbWl0dGVyCmNvbW1pdHRlciBOYW1lIDxlbWFpbCAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgPDxDT01NSVQKZW1wdHkgY29tbWl0CkNPTU1JVApJTlBVVF9FTkQKdGVzdF9leHBlY3Rfc3VjY2VzcyAnQjogZmFpbCBvbiBpbnZhbGlkIGNvbW1pdHRlciAoNCknICcKCXRlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCA8aW5wdXQKJwpnaXQgdXBkYXRlLXJlZiAtZCByZWZzL2hlYWRzL2ludmFsaWQtY29tbWl0dGVyIHx8IHRydWUKCmNhdCA+aW5wdXQgPDxJTlBVVF9FTkQKY29tbWl0IHJlZnMvaGVhZHMvaW52YWxpZC1jb21taXR0ZXIKY29tbWl0dGVyIE5hbWU8ZW1haWw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSA8PENPTU1JVAplbXB0eSBjb21taXQKQ09NTUlUCklOUFVUX0VORAp0ZXN0X2V4cGVjdF9zdWNjZXNzICdCOiBmYWlsIG9uIGludmFsaWQgY29tbWl0dGVyICg1KScgJwoJdGVzdF9tdXN0X2ZhaWwgZ2l0IGZhc3QtaW1wb3J0IDxpbnB1dAonCmdpdCB1cGRhdGUtcmVmIC1kIHJlZnMvaGVhZHMvaW52YWxpZC1jb21taXR0ZXIgfHwgdHJ1ZQoKIyMjCiMjIyBzZXJpZXMgQwojIyMKCm5ld2Y9YGVjaG8gaGkgbmV3ZiB8IGdpdCBoYXNoLW9iamVjdCAtdyAtLXN0ZGluYApvbGRmPWBnaXQgcmV2LXBhcnNlIC0tdmVyaWZ5IG1hc3RlcjpmaWxlMmAKdGVzdF90aWNrCmNhdCA+aW5wdXQgPDxJTlBVVF9FTkQKY29tbWl0IHJlZnMvaGVhZHMvYnJhbmNoCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCnNlY29uZApDT01NSVQKCmZyb20gcmVmcy9oZWFkcy9tYXN0ZXIKTSA2NDQgJG9sZGYgZmlsZTIvb2xkZgpNIDc1NSAkbmV3ZiBmaWxlMi9uZXdmCkQgZmlsZTMKCklOUFVUX0VORAp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKICAgICdDOiBpbmNyZW1lbnRhbCBpbXBvcnQgY3JlYXRlIHBhY2sgZnJvbSBzdGRpbicgXAogICAgJ2dpdCBmYXN0LWltcG9ydCA8aW5wdXQgJiYKCSBnaXQgd2hhdGNoYW5nZWQgYnJhbmNoJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnQzogdmVyaWZ5IHBhY2snICcKCXZlcmlmeV9wYWNrcwonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdDOiB2YWxpZGF0ZSByZXVzZSBleGlzdGluZyBibG9iJyBcCgkndGVzdCAkbmV3ZiA9IGBnaXQgcmV2LXBhcnNlIC0tdmVyaWZ5IGJyYW5jaDpmaWxlMi9uZXdmYCAmJgoJIHRlc3QgJG9sZGYgPSBgZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSBicmFuY2g6ZmlsZTIvb2xkZmAnCgpjYXQgPmV4cGVjdCA8PEVPRgpwYXJlbnQgYGdpdCByZXYtcGFyc2UgLS12ZXJpZnkgbWFzdGVyXjBgCmF1dGhvciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCnNlY29uZApFT0YKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknQzogdmVyaWZ5IGNvbW1pdCcgXAoJJ2dpdCBjYXQtZmlsZSBjb21taXQgYnJhbmNoIHwgc2VkIDFkID5hY3R1YWwgJiYKCSB0ZXN0X2NtcCBleHBlY3QgYWN0dWFsJwoKY2F0ID5leHBlY3QgPDxFT0YKOjAwMDAwMCAxMDA3NTUgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCBmMWZiNWRhNzE4MzkyNjk0ZDAwNzZkNjc3ZDZkMGUzNjRjNzliMGJjIEEJZmlsZTIvbmV3Zgo6MTAwNjQ0IDEwMDY0NCA3MTIzZjdmNDRlMzliZTEyN2M1ZWI3MDFlNTk2ODE3NmVlOWQ3OGIxIDcxMjNmN2Y0NGUzOWJlMTI3YzVlYjcwMWU1OTY4MTc2ZWU5ZDc4YjEgUjEwMAlmaWxlMglmaWxlMi9vbGRmCjoxMDA2NDQgMDAwMDAwIDBkOTJlOWYzMzc0YWUyOTQ3YzIzYWE0NzdjYmM2OGNlNTk4MTM1ZjEgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCBECWZpbGUzCkVPRgpnaXQgZGlmZi10cmVlIC1NIC1yIG1hc3RlciBicmFuY2ggPmFjdHVhbAp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdDOiB2YWxpZGF0ZSByZW5hbWUgcmVzdWx0JyBcCgknY29tcGFyZV9kaWZmX3JhdyBleHBlY3QgYWN0dWFsJwoKIyMjCiMjIyBzZXJpZXMgRAojIyMKCnRlc3RfdGljawpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmNvbW1pdCByZWZzL2hlYWRzL2JyYW5jaApjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSA8PENPTU1JVAp0aGlyZApDT01NSVQKCmZyb20gcmVmcy9oZWFkcy9icmFuY2heMApNIDY0NCBpbmxpbmUgbmV3ZGlyL2ludGVyZXN0aW5nCmRhdGEgPDxFT0YKJGZpbGU1X2RhdGEKRU9GCgpNIDc1NSBpbmxpbmUgbmV3ZGlyL2V4ZWMuc2gKZGF0YSA8PEVPRgokZmlsZTZfZGF0YQpFT0YKCklOUFVUX0VORAp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKICAgICdEOiBpbmxpbmUgZGF0YSBpbiBjb21taXQnIFwKICAgICdnaXQgZmFzdC1pbXBvcnQgPGlucHV0ICYmCgkgZ2l0IHdoYXRjaGFuZ2VkIGJyYW5jaCcKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ0Q6IHZlcmlmeSBwYWNrJyAnCgl2ZXJpZnlfcGFja3MKJwoKY2F0ID5leHBlY3QgPDxFT0YKOjAwMDAwMCAxMDA3NTUgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCAzNWE1OTAyNmEzM2JlYWMxNTY5YjFjN2Y2NmYzMDkwY2U5YzA5YWZjIEEJbmV3ZGlyL2V4ZWMuc2gKOjAwMDAwMCAxMDA2NDQgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCAwNDZkMDM3MWU5MjIwMTA3OTE3ZGIwZDBlMDMwNjI4ZGU4YTFkZTliIEEJbmV3ZGlyL2ludGVyZXN0aW5nCkVPRgpnaXQgZGlmZi10cmVlIC1NIC1yIGJyYW5jaF4gYnJhbmNoID5hY3R1YWwKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknRDogdmFsaWRhdGUgbmV3IGZpbGVzIGFkZGVkJyBcCgknY29tcGFyZV9kaWZmX3JhdyBleHBlY3QgYWN0dWFsJwoKZWNobyAiJGZpbGU1X2RhdGEiID5leHBlY3QKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknRDogdmVyaWZ5IGZpbGU1JyBcCgknZ2l0IGNhdC1maWxlIGJsb2IgYnJhbmNoOm5ld2Rpci9pbnRlcmVzdGluZyA+YWN0dWFsICYmCgkgdGVzdF9jbXAgZXhwZWN0IGFjdHVhbCcKCmVjaG8gIiRmaWxlNl9kYXRhIiA+ZXhwZWN0CnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ0Q6IHZlcmlmeSBmaWxlNicgXAoJJ2dpdCBjYXQtZmlsZSBibG9iIGJyYW5jaDpuZXdkaXIvZXhlYy5zaCA+YWN0dWFsICYmCgkgdGVzdF9jbXAgZXhwZWN0IGFjdHVhbCcKCiMjIwojIyMgc2VyaWVzIEUKIyMjCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmNvbW1pdCByZWZzL2hlYWRzL2JyYW5jaAphdXRob3IgJEdJVF9BVVRIT1JfTkFNRSA8JEdJVF9BVVRIT1JfRU1BSUw+IFR1ZSBGZWIgNiAxMToyMjoxOCAyMDA3IC0wNTAwCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gVHVlIEZlYiA2IDEyOjM1OjAyIDIwMDcgLTA1MDAKZGF0YSA8PENPTU1JVApSRkMgMjgyMiB0eXBlIGRhdGUKQ09NTUlUCgpmcm9tIHJlZnMvaGVhZHMvYnJhbmNoXjAKCklOUFVUX0VORAp0ZXN0X2V4cGVjdF9zdWNjZXNzICdFOiByZmMyODIyIGRhdGUsIC0tZGF0ZS1mb3JtYXQ9cmF3JyAnCiAgICB0ZXN0X211c3RfZmFpbCBnaXQgZmFzdC1pbXBvcnQgLS1kYXRlLWZvcm1hdD1yYXcgPGlucHV0CicKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCiAgICAnRTogcmZjMjgyMiBkYXRlLCAtLWRhdGUtZm9ybWF0PXJmYzI4MjInIFwKICAgICdnaXQgZmFzdC1pbXBvcnQgLS1kYXRlLWZvcm1hdD1yZmMyODIyIDxpbnB1dCcKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ0U6IHZlcmlmeSBwYWNrJyAnCgl2ZXJpZnlfcGFja3MKJwoKY2F0ID5leHBlY3QgPDxFT0YKYXV0aG9yICRHSVRfQVVUSE9SX05BTUUgPCRHSVRfQVVUSE9SX0VNQUlMPiAxMTcwNzc4OTM4IC0wNTAwCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gMTE3MDc4MzMwMiAtMDUwMAoKUkZDIDI4MjIgdHlwZSBkYXRlCkVPRgp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdFOiB2ZXJpZnkgY29tbWl0JyBcCgknZ2l0IGNhdC1maWxlIGNvbW1pdCBicmFuY2ggfCBzZWQgMSwyZCA+YWN0dWFsICYmCgl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsJwoKIyMjCiMjIyBzZXJpZXMgRgojIyMKCm9sZF9icmFuY2g9YGdpdCByZXYtcGFyc2UgLS12ZXJpZnkgYnJhbmNoXjBgCnRlc3RfdGljawpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmNvbW1pdCByZWZzL2hlYWRzL2JyYW5jaApjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSA8PENPTU1JVApsb3NpbmcgdGhpbmdzIGFscmVhZHk/CkNPTU1JVAoKZnJvbSByZWZzL2hlYWRzL2JyYW5jaH4xCgpyZXNldCByZWZzL2hlYWRzL290aGVyCmZyb20gcmVmcy9oZWFkcy9icmFuY2gKCklOUFVUX0VORAp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKICAgICdGOiBub24tZmFzdC1mb3J3YXJkIHVwZGF0ZSBza2lwcycgXAogICAgJ2lmIGdpdCBmYXN0LWltcG9ydCA8aW5wdXQKCSB0aGVuCgkJZWNobyBCQUQgZ2ZpIGRpZCBub3QgZmFpbAoJCXJldHVybiAxCgkgZWxzZQoJCWlmIHRlc3QgJG9sZF9icmFuY2ggPSBgZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSBicmFuY2heMGAKCQl0aGVuCgkJCTogYnJhbmNoIHVuYWZmZWN0ZWQgYW5kIGZhaWx1cmUgcmV0dXJuZWQKCQkJcmV0dXJuIDAKCQllbHNlCgkJCWVjaG8gQkFEIGdmaSBjaGFuZ2VkIGJyYW5jaCAkb2xkX2JyYW5jaAoJCQlyZXR1cm4gMQoJCWZpCgkgZmkKCScKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ0Y6IHZlcmlmeSBwYWNrJyAnCgl2ZXJpZnlfcGFja3MKJwoKY2F0ID5leHBlY3QgPDxFT0YKdHJlZSBgZ2l0IHJldi1wYXJzZSBicmFuY2h+MV57dHJlZX1gCnBhcmVudCBgZ2l0IHJldi1wYXJzZSBicmFuY2h+MWAKYXV0aG9yICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQoKbG9zaW5nIHRoaW5ncyBhbHJlYWR5PwpFT0YKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknRjogdmVyaWZ5IG90aGVyIGNvbW1pdCcgXAoJJ2dpdCBjYXQtZmlsZSBjb21taXQgb3RoZXIgPmFjdHVhbCAmJgoJdGVzdF9jbXAgZXhwZWN0IGFjdHVhbCcKCiMjIwojIyMgc2VyaWVzIEcKIyMjCgpvbGRfYnJhbmNoPWBnaXQgcmV2LXBhcnNlIC0tdmVyaWZ5IGJyYW5jaF4wYAp0ZXN0X3RpY2sKY2F0ID5pbnB1dCA8PElOUFVUX0VORApjb21taXQgcmVmcy9oZWFkcy9icmFuY2gKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgPDxDT01NSVQKbG9zaW5nIHRoaW5ncyBhbHJlYWR5PwpDT01NSVQKCmZyb20gcmVmcy9oZWFkcy9icmFuY2h+MQoKSU5QVVRfRU5ECnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAogICAgJ0c6IG5vbi1mYXN0LWZvcndhcmQgdXBkYXRlIGZvcmNlZCcgXAogICAgJ2dpdCBmYXN0LWltcG9ydCAtLWZvcmNlIDxpbnB1dCcKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ0c6IHZlcmlmeSBwYWNrJyAnCgl2ZXJpZnlfcGFja3MKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknRzogYnJhbmNoIGNoYW5nZWQsIGJ1dCBsb2dnZWQnIFwKCSd0ZXN0ICRvbGRfYnJhbmNoICE9IGBnaXQgcmV2LXBhcnNlIC0tdmVyaWZ5IGJyYW5jaF4wYCAmJgoJIHRlc3QgJG9sZF9icmFuY2ggPSBgZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSBicmFuY2hAezF9YCcKCiMjIwojIyMgc2VyaWVzIEgKIyMjCgp0ZXN0X3RpY2sKY2F0ID5pbnB1dCA8PElOUFVUX0VORApjb21taXQgcmVmcy9oZWFkcy9ICmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCnRoaXJkCkNPTU1JVAoKZnJvbSByZWZzL2hlYWRzL2JyYW5jaF4wCk0gNjQ0IGlubGluZSBpLXdpbGwtZGllCmRhdGEgPDxFT0YKdGhpcyBmaWxlIHdpbGwgbmV2ZXIgZXhpc3QuCkVPRgoKZGVsZXRlYWxsCk0gNjQ0IGlubGluZSBoL2UvbC9sbwpkYXRhIDw8RU9GCiRmaWxlNV9kYXRhCkVPRgoKSU5QVVRfRU5ECnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAogICAgJ0g6IGRlbGV0YWxsLCBhZGQgMScgXAogICAgJ2dpdCBmYXN0LWltcG9ydCA8aW5wdXQgJiYKCSBnaXQgd2hhdGNoYW5nZWQgSCcKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ0g6IHZlcmlmeSBwYWNrJyAnCgl2ZXJpZnlfcGFja3MKJwoKY2F0ID5leHBlY3QgPDxFT0YKOjEwMDc1NSAwMDAwMDAgZjFmYjVkYTcxODM5MjY5NGQwMDc2ZDY3N2Q2ZDBlMzY0Yzc5YjBiYyAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIEQJZmlsZTIvbmV3Zgo6MTAwNjQ0IDAwMDAwMCA3MTIzZjdmNDRlMzliZTEyN2M1ZWI3MDFlNTk2ODE3NmVlOWQ3OGIxIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAgRAlmaWxlMi9vbGRmCjoxMDA3NTUgMDAwMDAwIDg1ZGY1MDc4NWQ2MmQzYjA1YWIwM2Q5Y2JmN2U0YTBiNDk0NDk3MzAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCBECWZpbGU0CjoxMDA2NDQgMTAwNjQ0IGZjZjc3OGNkYTE4MWVhYTFjYmM5ZTljZTNhMmUxNWVlOWY5ZmU3OTEgZmNmNzc4Y2RhMTgxZWFhMWNiYzllOWNlM2EyZTE1ZWU5ZjlmZTc5MSBSMTAwCW5ld2Rpci9pbnRlcmVzdGluZwloL2UvbC9sbwo6MTAwNzU1IDAwMDAwMCBlNzRiN2Q0NjVlNTI3NDZiZTJiNGJhZTk4MzY3MDcxMWU2ZTY2NjU3IDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAgRAluZXdkaXIvZXhlYy5zaApFT0YKZ2l0IGRpZmYtdHJlZSAtTSAtciBIXiBIID5hY3R1YWwKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknSDogdmFsaWRhdGUgb2xkIGZpbGVzIHJlbW92ZWQsIG5ldyBmaWxlcyBhZGRlZCcgXAoJJ2NvbXBhcmVfZGlmZl9yYXcgZXhwZWN0IGFjdHVhbCcKCmVjaG8gIiRmaWxlNV9kYXRhIiA+ZXhwZWN0CnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ0g6IHZlcmlmeSBmaWxlJyBcCgknZ2l0IGNhdC1maWxlIGJsb2IgSDpoL2UvbC9sbyA+YWN0dWFsICYmCgkgdGVzdF9jbXAgZXhwZWN0IGFjdHVhbCcKCiMjIwojIyMgc2VyaWVzIEkKIyMjCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmNvbW1pdCByZWZzL2hlYWRzL2V4cG9ydC1ib3VuZGFyeQpjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSA8PENPTU1JVAp3ZSBoYXZlIGEgYm9yZGVyLiAgaXRzIG9ubHkgNDAgY2hhcmFjdGVycyB3aWRlLgpDT01NSVQKCmZyb20gcmVmcy9oZWFkcy9icmFuY2gKCklOUFVUX0VORAp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKICAgICdJOiBleHBvcnQtcGFjay1lZGdlcycgXAogICAgJ2dpdCBmYXN0LWltcG9ydCAtLWV4cG9ydC1wYWNrLWVkZ2VzPWVkZ2VzLmxpc3QgPGlucHV0JwoKY2F0ID5leHBlY3QgPDxFT0YKLmdpdC9vYmplY3RzL3BhY2svcGFjay0ucGFjazogYGdpdCByZXYtcGFyc2UgLS12ZXJpZnkgZXhwb3J0LWJvdW5kYXJ5YApFT0YKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknSTogdmVyaWZ5IGVkZ2UgbGlzdCcgXAoJJ3NlZCAtZSBzL3BhY2stLipwYWNrL3BhY2stLnBhY2svIGVkZ2VzLmxpc3QgPmFjdHVhbCAmJgoJIHRlc3RfY21wIGV4cGVjdCBhY3R1YWwnCgojIyMKIyMjIHNlcmllcyBKCiMjIwoKY2F0ID5pbnB1dCA8PElOUFVUX0VORApjb21taXQgcmVmcy9oZWFkcy9KCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCmNyZWF0ZSBKCkNPTU1JVAoKZnJvbSByZWZzL2hlYWRzL2JyYW5jaAoKcmVzZXQgcmVmcy9oZWFkcy9KCgpjb21taXQgcmVmcy9oZWFkcy9KCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCmluaXRpYWxpemUgSgpDT01NSVQKCklOUFVUX0VORAp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKICAgICdKOiByZXNldCBleGlzdGluZyBicmFuY2ggY3JlYXRlcyBlbXB0eSBjb21taXQnIFwKICAgICdnaXQgZmFzdC1pbXBvcnQgPGlucHV0Jwp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdKOiBicmFuY2ggaGFzIDEgY29tbWl0LCBlbXB0eSB0cmVlJyBcCgkndGVzdCAxID0gYGdpdCByZXYtbGlzdCBKIHwgd2MgLWxgICYmCgkgdGVzdCAwID0gYGdpdCBscy10cmVlIEogfCB3YyAtbGAnCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECnJlc2V0IHJlZnMvaGVhZHMvSjIKCnRhZyB3cm9uZ190YWcKZnJvbSByZWZzL2hlYWRzL0oyCmRhdGEgPDxFT0YKVGFnIGJyYW5jaCB0aGF0IHdhcyByZXNldC4KRU9GCklOUFVUX0VORAp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdKOiB0YWcgbXVzdCBmYWlsIG9uIGVtcHR5IGJyYW5jaCcgXAoJJ3Rlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCA8aW5wdXQnCiMjIwojIyMgc2VyaWVzIEsKIyMjCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmNvbW1pdCByZWZzL2hlYWRzL0sKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgPDxDT01NSVQKY3JlYXRlIEsKQ09NTUlUCgpmcm9tIHJlZnMvaGVhZHMvYnJhbmNoCgpjb21taXQgcmVmcy9oZWFkcy9LCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCnJlZG8gSwpDT01NSVQKCmZyb20gcmVmcy9oZWFkcy9icmFuY2heMQoKSU5QVVRfRU5ECnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAogICAgJ0s6IHJlaW5pdCBicmFuY2ggd2l0aCBmcm9tJyBcCiAgICAnZ2l0IGZhc3QtaW1wb3J0IDxpbnB1dCcKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCiAgICAnSzogdmVyaWZ5IEteMSA9IGJyYW5jaF4xJyBcCiAgICAndGVzdCBgZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSBicmFuY2heMWAgXAoJCT0gYGdpdCByZXYtcGFyc2UgLS12ZXJpZnkgS14xYCcKCiMjIwojIyMgc2VyaWVzIEwKIyMjCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmJsb2IKbWFyayA6MQpkYXRhIDw8RU9GCnNvbWUgZGF0YQpFT0YKCmJsb2IKbWFyayA6MgpkYXRhIDw8RU9GCm90aGVyIGRhdGEKRU9GCgpjb21taXQgcmVmcy9oZWFkcy9MCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCmNyZWF0ZSBMCkNPTU1JVAoKTSA2NDQgOjEgYi4KTSA2NDQgOjEgYi9vdGhlcgpNIDY0NCA6MSBiYQoKY29tbWl0IHJlZnMvaGVhZHMvTApjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSA8PENPTU1JVAp1cGRhdGUgTApDT01NSVQKCk0gNjQ0IDoyIGIuCk0gNjQ0IDoyIGIvb3RoZXIKTSA2NDQgOjIgYmEKSU5QVVRfRU5ECgpjYXQgPmV4cGVjdCA8PEVYUEVDVF9FTkQKOjEwMDY0NCAxMDA2NDQgNDI2ODYzMi4uLiA1NWQzYTUyLi4uIE0JYi4KOjA0MDAwMCAwNDAwMDAgMGFlNWNhYy4uLiA0NDNjNzY4Li4uIE0JYgo6MTAwNjQ0IDEwMDY0NCA0MjY4NjMyLi4uIDU1ZDNhNTIuLi4gTQliYQpFWFBFQ1RfRU5ECgp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKICAgICdMOiB2ZXJpZnkgaW50ZXJuYWwgdHJlZSBzb3J0aW5nJyBcCgknZ2l0IGZhc3QtaW1wb3J0IDxpbnB1dCAmJgoJIGdpdCBkaWZmLXRyZWUgLS1hYmJyZXYgLS1yYXcgTF4gTCA+b3V0cHV0ICYmCgkgdGVzdF9jbXAgZXhwZWN0IG91dHB1dCcKCmNhdCA+aW5wdXQgPDxJTlBVVF9FTkQKYmxvYgptYXJrIDoxCmRhdGEgPDxFT0YKdGhlIGRhdGEKRU9GCgpjb21taXQgcmVmcy9oZWFkcy9MMgpjb21taXR0ZXIgQyBPIE1pdHRlciA8Y29tbWl0dGVyQGV4YW1wbGUuY29tPiAxMTEyOTEyNDczIC0wNzAwCmRhdGEgPDxDT01NSVQKaW5pdCBMMgpDT01NSVQKTSA2NDQgOjEgYS9iL2MKTSA2NDQgOjEgYS9iL2QKTSA2NDQgOjEgYS9lL2YKCmNvbW1pdCByZWZzL2hlYWRzL0wyCmNvbW1pdHRlciBDIE8gTWl0dGVyIDxjb21taXR0ZXJAZXhhbXBsZS5jb20+IDExMTI5MTI0NzMgLTA3MDAKZGF0YSA8PENPTU1JVAp1cGRhdGUgTDIKQ09NTUlUCkMgYSBnCkMgYS9lIGcvYgpNIDY0NCA6MSBnL2IvaApJTlBVVF9FTkQKCmNhdCA8PEVPRiA+ZXhwZWN0CmcvYi9mCmcvYi9oCkVPRgoKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCiAgICAnTDogbmVzdGVkIHRyZWUgY29weSBkb2VzIG5vdCBjb3JydXB0IGRlbHRhcycgXAoJJ2dpdCBmYXN0LWltcG9ydCA8aW5wdXQgJiYKCWdpdCBscy10cmVlIEwyIGcvYi8gPnRtcCAmJgoJY2F0IHRtcCB8IGN1dCAtZiAyID5hY3R1YWwgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwgJiYKCWdpdCBmc2NrIGBnaXQgcmV2LXBhcnNlIEwyYCcKCmdpdCB1cGRhdGUtcmVmIC1kIHJlZnMvaGVhZHMvTDIKCiMjIwojIyMgc2VyaWVzIE0KIyMjCgp0ZXN0X3RpY2sKY2F0ID5pbnB1dCA8PElOUFVUX0VORApjb21taXQgcmVmcy9oZWFkcy9NMQpjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSA8PENPTU1JVApmaWxlIHJlbmFtZQpDT01NSVQKCmZyb20gcmVmcy9oZWFkcy9icmFuY2heMApSIGZpbGUyL25ld2YgZmlsZTIvbi5lLncuZgoKSU5QVVRfRU5ECgpjYXQgPmV4cGVjdCA8PEVPRgo6MTAwNzU1IDEwMDc1NSBmMWZiNWRhNzE4MzkyNjk0ZDAwNzZkNjc3ZDZkMGUzNjRjNzliMGJjIGYxZmI1ZGE3MTgzOTI2OTRkMDA3NmQ2NzdkNmQwZTM2NGM3OWIwYmMgUjEwMAlmaWxlMi9uZXdmCWZpbGUyL24uZS53LmYKRU9GCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ006IHJlbmFtZSBmaWxlIGluIHNhbWUgc3ViZGlyZWN0b3J5JyBcCgknZ2l0IGZhc3QtaW1wb3J0IDxpbnB1dCAmJgoJIGdpdCBkaWZmLXRyZWUgLU0gLXIgTTFeIE0xID5hY3R1YWwgJiYKCSBjb21wYXJlX2RpZmZfcmF3IGV4cGVjdCBhY3R1YWwnCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmNvbW1pdCByZWZzL2hlYWRzL00yCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCmZpbGUgcmVuYW1lCkNPTU1JVAoKZnJvbSByZWZzL2hlYWRzL2JyYW5jaF4wClIgZmlsZTIvbmV3ZiBpL2FtL25ldy90by95b3UKCklOUFVUX0VORAoKY2F0ID5leHBlY3QgPDxFT0YKOjEwMDc1NSAxMDA3NTUgZjFmYjVkYTcxODM5MjY5NGQwMDc2ZDY3N2Q2ZDBlMzY0Yzc5YjBiYyBmMWZiNWRhNzE4MzkyNjk0ZDAwNzZkNjc3ZDZkMGUzNjRjNzliMGJjIFIxMDAJZmlsZTIvbmV3ZglpL2FtL25ldy90by95b3UKRU9GCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ006IHJlbmFtZSBmaWxlIHRvIG5ldyBzdWJkaXJlY3RvcnknIFwKCSdnaXQgZmFzdC1pbXBvcnQgPGlucHV0ICYmCgkgZ2l0IGRpZmYtdHJlZSAtTSAtciBNMl4gTTIgPmFjdHVhbCAmJgoJIGNvbXBhcmVfZGlmZl9yYXcgZXhwZWN0IGFjdHVhbCcKCmNhdCA+aW5wdXQgPDxJTlBVVF9FTkQKY29tbWl0IHJlZnMvaGVhZHMvTTMKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgPDxDT01NSVQKZmlsZSByZW5hbWUKQ09NTUlUCgpmcm9tIHJlZnMvaGVhZHMvTTJeMApSIGkgb3RoZXIvc3ViCgpJTlBVVF9FTkQKCmNhdCA+ZXhwZWN0IDw8RU9GCjoxMDA3NTUgMTAwNzU1IGYxZmI1ZGE3MTgzOTI2OTRkMDA3NmQ2NzdkNmQwZTM2NGM3OWIwYmMgZjFmYjVkYTcxODM5MjY5NGQwMDc2ZDY3N2Q2ZDBlMzY0Yzc5YjBiYyBSMTAwCWkvYW0vbmV3L3RvL3lvdQlvdGhlci9zdWIvYW0vbmV3L3RvL3lvdQpFT0YKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknTTogcmVuYW1lIHN1YmRpcmVjdG9yeSB0byBuZXcgc3ViZGlyZWN0b3J5JyBcCgknZ2l0IGZhc3QtaW1wb3J0IDxpbnB1dCAmJgoJIGdpdCBkaWZmLXRyZWUgLU0gLXIgTTNeIE0zID5hY3R1YWwgJiYKCSBjb21wYXJlX2RpZmZfcmF3IGV4cGVjdCBhY3R1YWwnCgojIyMKIyMjIHNlcmllcyBOCiMjIwoKdGVzdF90aWNrCmNhdCA+aW5wdXQgPDxJTlBVVF9FTkQKY29tbWl0IHJlZnMvaGVhZHMvTjEKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgPDxDT01NSVQKZmlsZSBjb3B5CkNPTU1JVAoKZnJvbSByZWZzL2hlYWRzL2JyYW5jaF4wCkMgZmlsZTIvbmV3ZiBmaWxlMi9uLmUudy5mCgpJTlBVVF9FTkQKCmNhdCA+ZXhwZWN0IDw8RU9GCjoxMDA3NTUgMTAwNzU1IGYxZmI1ZGE3MTgzOTI2OTRkMDA3NmQ2NzdkNmQwZTM2NGM3OWIwYmMgZjFmYjVkYTcxODM5MjY5NGQwMDc2ZDY3N2Q2ZDBlMzY0Yzc5YjBiYyBDMTAwCWZpbGUyL25ld2YJZmlsZTIvbi5lLncuZgpFT0YKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknTjogY29weSBmaWxlIGluIHNhbWUgc3ViZGlyZWN0b3J5JyBcCgknZ2l0IGZhc3QtaW1wb3J0IDxpbnB1dCAmJgoJIGdpdCBkaWZmLXRyZWUgLUMgLS1maW5kLWNvcGllcy1oYXJkZXIgLXIgTjFeIE4xID5hY3R1YWwgJiYKCSBjb21wYXJlX2RpZmZfcmF3IGV4cGVjdCBhY3R1YWwnCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmNvbW1pdCByZWZzL2hlYWRzL04yCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCmNsZWFuIGRpcmVjdG9yeSBjb3B5CkNPTU1JVAoKZnJvbSByZWZzL2hlYWRzL2JyYW5jaF4wCkMgZmlsZTIgZmlsZTMKCmNvbW1pdCByZWZzL2hlYWRzL04yCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCm1vZGlmeSBkaXJlY3RvcnkgY29weQpDT01NSVQKCk0gNjQ0IGlubGluZSBmaWxlMy9maWxlNQpkYXRhIDw8RU9GCiRmaWxlNV9kYXRhCkVPRgoKSU5QVVRfRU5ECgpjYXQgPmV4cGVjdCA8PEVPRgo6MTAwNjQ0IDEwMDY0NCBmY2Y3NzhjZGExODFlYWExY2JjOWU5Y2UzYTJlMTVlZTlmOWZlNzkxIGZjZjc3OGNkYTE4MWVhYTFjYmM5ZTljZTNhMmUxNWVlOWY5ZmU3OTEgQzEwMAluZXdkaXIvaW50ZXJlc3RpbmcJZmlsZTMvZmlsZTUKOjEwMDc1NSAxMDA3NTUgZjFmYjVkYTcxODM5MjY5NGQwMDc2ZDY3N2Q2ZDBlMzY0Yzc5YjBiYyBmMWZiNWRhNzE4MzkyNjk0ZDAwNzZkNjc3ZDZkMGUzNjRjNzliMGJjIEMxMDAJZmlsZTIvbmV3ZglmaWxlMy9uZXdmCjoxMDA2NDQgMTAwNjQ0IDcxMjNmN2Y0NGUzOWJlMTI3YzVlYjcwMWU1OTY4MTc2ZWU5ZDc4YjEgNzEyM2Y3ZjQ0ZTM5YmUxMjdjNWViNzAxZTU5NjgxNzZlZTlkNzhiMSBDMTAwCWZpbGUyL29sZGYJZmlsZTMvb2xkZgpFT0YKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknTjogY29weSB0aGVuIG1vZGlmeSBzdWJkaXJlY3RvcnknIFwKCSdnaXQgZmFzdC1pbXBvcnQgPGlucHV0ICYmCgkgZ2l0IGRpZmYtdHJlZSAtQyAtLWZpbmQtY29waWVzLWhhcmRlciAtciBOMl5eIE4yID5hY3R1YWwgJiYKCSBjb21wYXJlX2RpZmZfcmF3IGV4cGVjdCBhY3R1YWwnCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmNvbW1pdCByZWZzL2hlYWRzL04zCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCmRpcnR5IGRpcmVjdG9yeSBjb3B5CkNPTU1JVAoKZnJvbSByZWZzL2hlYWRzL2JyYW5jaF4wCk0gNjQ0IGlubGluZSBmaWxlMi9maWxlNQpkYXRhIDw8RU9GCiRmaWxlNV9kYXRhCkVPRgoKQyBmaWxlMiBmaWxlMwpEIGZpbGUyL2ZpbGU1CgpJTlBVVF9FTkQKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ046IGNvcHkgZGlydHkgc3ViZGlyZWN0b3J5JyBcCgknZ2l0IGZhc3QtaW1wb3J0IDxpbnB1dCAmJgoJIHRlc3QgYGdpdCByZXYtcGFyc2UgTjJee3RyZWV9YCA9IGBnaXQgcmV2LXBhcnNlIE4zXnt0cmVlfWAnCgp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdOOiBjb3B5IGRpcmVjdG9yeSBieSBpZCcgXAoJJ2NhdCA+ZXhwZWN0IDw8LVxFT0YgJiYKCToxMDA3NTUgMTAwNzU1IGYxZmI1ZGE3MTgzOTI2OTRkMDA3NmQ2NzdkNmQwZTM2NGM3OWIwYmMgZjFmYjVkYTcxODM5MjY5NGQwMDc2ZDY3N2Q2ZDBlMzY0Yzc5YjBiYyBDMTAwCWZpbGUyL25ld2YJZmlsZTMvbmV3ZgoJOjEwMDY0NCAxMDA2NDQgNzEyM2Y3ZjQ0ZTM5YmUxMjdjNWViNzAxZTU5NjgxNzZlZTlkNzhiMSA3MTIzZjdmNDRlMzliZTEyN2M1ZWI3MDFlNTk2ODE3NmVlOWQ3OGIxIEMxMDAJZmlsZTIvb2xkZglmaWxlMy9vbGRmCglFT0YKCSBzdWJkaXI9JChnaXQgcmV2LXBhcnNlIHJlZnMvaGVhZHMvYnJhbmNoXjA6ZmlsZTIpICYmCgkgY2F0ID5pbnB1dCA8PC1JTlBVVF9FTkQgJiYKCWNvbW1pdCByZWZzL2hlYWRzL040Cgljb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCWRhdGEgPDxDT01NSVQKCWNvcHkgYnkgdHJlZSBoYXNoCglDT01NSVQKCglmcm9tIHJlZnMvaGVhZHMvYnJhbmNoXjAKCU0gMDQwMDAwICRzdWJkaXIgZmlsZTMKCUlOUFVUX0VORAoJIGdpdCBmYXN0LWltcG9ydCA8aW5wdXQgJiYKCSBnaXQgZGlmZi10cmVlIC1DIC0tZmluZC1jb3BpZXMtaGFyZGVyIC1yIE40XiBONCA+YWN0dWFsICYmCgkgY29tcGFyZV9kaWZmX3JhdyBleHBlY3QgYWN0dWFsJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyBQSVBFICdOOiByZWFkIGFuZCBjb3B5IGRpcmVjdG9yeScgJwoJY2F0ID5leHBlY3QgPDwtXEVPRgoJOjEwMDc1NSAxMDA3NTUgZjFmYjVkYTcxODM5MjY5NGQwMDc2ZDY3N2Q2ZDBlMzY0Yzc5YjBiYyBmMWZiNWRhNzE4MzkyNjk0ZDAwNzZkNjc3ZDZkMGUzNjRjNzliMGJjIEMxMDAJZmlsZTIvbmV3ZglmaWxlMy9uZXdmCgk6MTAwNjQ0IDEwMDY0NCA3MTIzZjdmNDRlMzliZTEyN2M1ZWI3MDFlNTk2ODE3NmVlOWQ3OGIxIDcxMjNmN2Y0NGUzOWJlMTI3YzVlYjcwMWU1OTY4MTc2ZWU5ZDc4YjEgQzEwMAlmaWxlMi9vbGRmCWZpbGUzL29sZGYKCUVPRgoJZ2l0IHVwZGF0ZS1yZWYgLWQgcmVmcy9oZWFkcy9ONCAmJgoJcm0gLWYgYmFja2Zsb3cgJiYKCW1rZmlmbyBiYWNrZmxvdyAmJgoJKAoJCWV4ZWMgPGJhY2tmbG93ICYmCgkJY2F0IDw8LUVPRiAmJgoJCWNvbW1pdCByZWZzL2hlYWRzL040CgkJY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCgkJZGF0YSA8PENPTU1JVAoJCWNvcHkgYnkgdHJlZSBoYXNoLCBwYXJ0IDIKCQlDT01NSVQKCgkJZnJvbSByZWZzL2hlYWRzL2JyYW5jaF4wCgkJbHMgImZpbGUyIgoJCUVPRgoJCXJlYWQgbW9kZSB0eXBlIHRyZWUgZmlsZW5hbWUgJiYKCQllY2hvICJNIDA0MDAwMCAkdHJlZSBmaWxlMyIKCSkgfAoJZ2l0IGZhc3QtaW1wb3J0IC0tY2F0LWJsb2ItZmQ9MyAzPmJhY2tmbG93ICYmCglnaXQgZGlmZi10cmVlIC1DIC0tZmluZC1jb3BpZXMtaGFyZGVyIC1yIE40XiBONCA+YWN0dWFsICYmCgljb21wYXJlX2RpZmZfcmF3IGV4cGVjdCBhY3R1YWwKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyBQSVBFICdOOiBlbXB0eSBkaXJlY3RvcnkgcmVhZHMgYXMgbWlzc2luZycgJwoJY2F0IDw8LVxFT0YgPmV4cGVjdCAmJgoJT0JKTkFNRQoJOjAwMDAwMCAxMDA2NDQgT0JKTkFNRSBPQkpOQU1FIEEJdW5yZWxhdGVkCglFT0YKCWVjaG8gIm1pc3Npbmcgc3JjIiA+ZXhwZWN0LnJlc3BvbnNlICYmCglnaXQgdXBkYXRlLXJlZiAtZCByZWZzL2hlYWRzL3JlYWQtZW1wdHkgJiYKCXJtIC1mIGJhY2tmbG93ICYmCglta2ZpZm8gYmFja2Zsb3cgJiYKCSgKCQlleGVjIDxiYWNrZmxvdyAmJgoJCWNhdCA8PC1FT0YgJiYKCQljb21taXQgcmVmcy9oZWFkcy9yZWFkLWVtcHR5CgkJY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCgkJZGF0YSA8PENPTU1JVAoJCXJlYWQgImVtcHR5IiAobWlzc2luZykgZGlyZWN0b3J5CgkJQ09NTUlUCgoJCU0gMTAwNjQ0IGlubGluZSBzcmMvZ3JlZXRpbmcKCQlkYXRhIDw8QkxPQgoJCWhlbGxvCgkJQkxPQgoJCUMgc3JjL2dyZWV0aW5nIGRzdDEvbm9uLWdyZWV0aW5nCgkJQyBzcmMvZ3JlZXRpbmcgdW5yZWxhdGVkCgkJIyBsZWF2ZSBiZWhpbmQgImVtcHR5IiBzcmMgZGlyZWN0b3J5CgkJRCBzcmMvZ3JlZXRpbmcKCQlscyAic3JjIgoJCUVPRgoJCXJlYWQgLXIgbGluZSAmJgoJCXByaW50ZiAiJXNcbiIgIiRsaW5lIiA+cmVzcG9uc2UgJiYKCQljYXQgPDwtXEVPRgoJCUQgZHN0MQoJCUQgZHN0MgoJCUVPRgoJKSB8CglnaXQgZmFzdC1pbXBvcnQgLS1jYXQtYmxvYi1mZD0zIDM+YmFja2Zsb3cgJiYKCXRlc3RfY21wIGV4cGVjdC5yZXNwb25zZSByZXNwb25zZSAmJgoJZ2l0IHJldi1saXN0IHJlYWQtZW1wdHkgfAoJZ2l0IGRpZmYtdHJlZSAtciAtLXJvb3QgLS1zdGRpbiB8CglzZWQgInMvJF94NDAvT0JKTkFNRS9nIiA+YWN0dWFsICYmCgl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ046IGNvcHkgcm9vdCBkaXJlY3RvcnkgYnkgdHJlZSBoYXNoJyBcCgknY2F0ID5leHBlY3QgPDwtXEVPRiAmJgoJOjEwMDc1NSAwMDAwMDAgZjFmYjVkYTcxODM5MjY5NGQwMDc2ZDY3N2Q2ZDBlMzY0Yzc5YjBiYyAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIEQJZmlsZTMvbmV3ZgoJOjEwMDY0NCAwMDAwMDAgNzEyM2Y3ZjQ0ZTM5YmUxMjdjNWViNzAxZTU5NjgxNzZlZTlkNzhiMSAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIEQJZmlsZTMvb2xkZgoJRU9GCgkgcm9vdD0kKGdpdCByZXYtcGFyc2UgcmVmcy9oZWFkcy9icmFuY2heMF57dHJlZX0pICYmCgkgY2F0ID5pbnB1dCA8PC1JTlBVVF9FTkQgJiYKCWNvbW1pdCByZWZzL2hlYWRzL042Cgljb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCWRhdGEgPDxDT01NSVQKCWNvcHkgcm9vdCBkaXJlY3RvcnkgYnkgdHJlZSBoYXNoCglDT01NSVQKCglmcm9tIHJlZnMvaGVhZHMvYnJhbmNoXjAKCU0gMDQwMDAwICRyb290ICIiCglJTlBVVF9FTkQKCSBnaXQgZmFzdC1pbXBvcnQgPGlucHV0ICYmCgkgZ2l0IGRpZmYtdHJlZSAtQyAtLWZpbmQtY29waWVzLWhhcmRlciAtciBONCBONiA+YWN0dWFsICYmCgkgY29tcGFyZV9kaWZmX3JhdyBleHBlY3QgYWN0dWFsJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknTjogZGVsZXRlIGRpcmVjdG9yeSBieSBjb3B5aW5nJyBcCgknY2F0ID5leHBlY3QgPDwtXEVPRiAmJgoJT0JKSUQKCToxMDA2NDQgMDAwMDAwIE9CSklEIE9CSklEIEQJZm9vL2Jhci9xdXgKCU9CSklECgk6MDAwMDAwIDEwMDY0NCBPQkpJRCBPQkpJRCBBCWZvby9iYXIvYmF6Cgk6MDAwMDAwIDEwMDY0NCBPQkpJRCBPQkpJRCBBCWZvby9iYXIvcXV4CglFT0YKCSBlbXB0eV90cmVlPSQoZ2l0IG1rdHJlZSA8L2Rldi9udWxsKSAmJgoJIGNhdCA+aW5wdXQgPDwtSU5QVVRfRU5EICYmCgljb21taXQgcmVmcy9oZWFkcy9OLWRlbGV0ZQoJY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCglkYXRhIDw8Q09NTUlUCgljb2xsZWN0IGRhdGEgdG8gYmUgZGVsZXRlZAoJQ09NTUlUCgoJZGVsZXRlYWxsCglNIDEwMDY0NCBpbmxpbmUgZm9vL2Jhci9iYXoKCWRhdGEgPDxEQVRBX0VORAoJaGVsbG8KCURBVEFfRU5ECglDICJmb28vYmFyL2JheiIgImZvby9iYXIvcXV4IgoJQyAiZm9vL2Jhci9iYXoiICJmb28vYmFyL3F1dXgvMSIKCUMgImZvby9iYXIvYmF6IiAiZm9vL2Jhci9xdXV1eCIKCU0gMDQwMDAwICRlbXB0eV90cmVlIGZvby9iYXIvcXV1eAoJTSAwNDAwMDAgJGVtcHR5X3RyZWUgZm9vL2Jhci9xdXV1eAoKCWNvbW1pdCByZWZzL2hlYWRzL04tZGVsZXRlCgljb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCWRhdGEgPDxDT01NSVQKCWRlbGV0ZSBzdWJkaXJlY3RvcnkKCUNPTU1JVAoKCU0gMDQwMDAwICRlbXB0eV90cmVlIGZvby9iYXIvcXV4CglJTlBVVF9FTkQKCSBnaXQgZmFzdC1pbXBvcnQgPGlucHV0ICYmCgkgZ2l0IHJldi1saXN0IE4tZGVsZXRlIHwKCQlnaXQgZGlmZi10cmVlIC1yIC0tc3RkaW4gLS1yb290IC0tYWx3YXlzIHwKCQlzZWQgLWUgInMvJF94NDAvT0JKSUQvZyIgPmFjdHVhbCAmJgoJIHRlc3RfY21wIGV4cGVjdCBhY3R1YWwnCgp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdOOiBtb2RpZnkgY29waWVkIHRyZWUnIFwKCSdjYXQgPmV4cGVjdCA8PC1cRU9GICYmCgk6MTAwNjQ0IDEwMDY0NCBmY2Y3NzhjZGExODFlYWExY2JjOWU5Y2UzYTJlMTVlZTlmOWZlNzkxIGZjZjc3OGNkYTE4MWVhYTFjYmM5ZTljZTNhMmUxNWVlOWY5ZmU3OTEgQzEwMAluZXdkaXIvaW50ZXJlc3RpbmcJZmlsZTMvZmlsZTUKCToxMDA3NTUgMTAwNzU1IGYxZmI1ZGE3MTgzOTI2OTRkMDA3NmQ2NzdkNmQwZTM2NGM3OWIwYmMgZjFmYjVkYTcxODM5MjY5NGQwMDc2ZDY3N2Q2ZDBlMzY0Yzc5YjBiYyBDMTAwCWZpbGUyL25ld2YJZmlsZTMvbmV3ZgoJOjEwMDY0NCAxMDA2NDQgNzEyM2Y3ZjQ0ZTM5YmUxMjdjNWViNzAxZTU5NjgxNzZlZTlkNzhiMSA3MTIzZjdmNDRlMzliZTEyN2M1ZWI3MDFlNTk2ODE3NmVlOWQ3OGIxIEMxMDAJZmlsZTIvb2xkZglmaWxlMy9vbGRmCglFT0YKCSBzdWJkaXI9JChnaXQgcmV2LXBhcnNlIHJlZnMvaGVhZHMvYnJhbmNoXjA6ZmlsZTIpICYmCgkgY2F0ID5pbnB1dCA8PC1JTlBVVF9FTkQgJiYKCWNvbW1pdCByZWZzL2hlYWRzL041Cgljb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCWRhdGEgPDxDT01NSVQKCWNvcHkgYnkgdHJlZSBoYXNoCglDT01NSVQKCglmcm9tIHJlZnMvaGVhZHMvYnJhbmNoXjAKCU0gMDQwMDAwICRzdWJkaXIgZmlsZTMKCgljb21taXQgcmVmcy9oZWFkcy9ONQoJY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCglkYXRhIDw8Q09NTUlUCgltb2RpZnkgZGlyZWN0b3J5IGNvcHkKCUNPTU1JVAoKCU0gNjQ0IGlubGluZSBmaWxlMy9maWxlNQoJZGF0YSA8PEVPRgoJJGZpbGU1X2RhdGEKCUVPRgoJSU5QVVRfRU5ECgkgZ2l0IGZhc3QtaW1wb3J0IDxpbnB1dCAmJgoJIGdpdCBkaWZmLXRyZWUgLUMgLS1maW5kLWNvcGllcy1oYXJkZXIgLXIgTjVeXiBONSA+YWN0dWFsICYmCgkgY29tcGFyZV9kaWZmX3JhdyBleHBlY3QgYWN0dWFsJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknTjogcmVqZWN0IGZvby8gc3ludGF4JyBcCgknc3ViZGlyPSQoZ2l0IHJldi1wYXJzZSByZWZzL2hlYWRzL2JyYW5jaF4wOmZpbGUyKSAmJgoJIHRlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCA8PC1JTlBVVF9FTkQKCWNvbW1pdCByZWZzL2hlYWRzL041QgoJY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCglkYXRhIDw8Q09NTUlUCgljb3B5IHdpdGggaW52YWxpZCBzeW50YXgKCUNPTU1JVAoKCWZyb20gcmVmcy9oZWFkcy9icmFuY2heMAoJTSAwNDAwMDAgJHN1YmRpciBmaWxlMy8KCUlOUFVUX0VORCcKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ046IHJlamVjdCBmb28vIHN5bnRheCBpbiBjb3B5IHNvdXJjZScgXAoJJ3Rlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCA8PC1JTlBVVF9FTkQKCWNvbW1pdCByZWZzL2hlYWRzL041QwoJY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCglkYXRhIDw8Q09NTUlUCgljb3B5IHdpdGggaW52YWxpZCBzeW50YXgKCUNPTU1JVAoKCWZyb20gcmVmcy9oZWFkcy9icmFuY2heMAoJQyBmaWxlMi8gZmlsZTMKCUlOUFVUX0VORCcKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ046IHJlamVjdCBmb28vIHN5bnRheCBpbiByZW5hbWUgc291cmNlJyBcCgkndGVzdF9tdXN0X2ZhaWwgZ2l0IGZhc3QtaW1wb3J0IDw8LUlOUFVUX0VORAoJY29tbWl0IHJlZnMvaGVhZHMvTjVECgljb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCWRhdGEgPDxDT01NSVQKCXJlbmFtZSB3aXRoIGludmFsaWQgc3ludGF4CglDT01NSVQKCglmcm9tIHJlZnMvaGVhZHMvYnJhbmNoXjAKCVIgZmlsZTIvIGZpbGUzCglJTlBVVF9FTkQnCgp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdOOiByZWplY3QgZm9vLyBzeW50YXggaW4gbHMgYXJndW1lbnQnIFwKCSd0ZXN0X211c3RfZmFpbCBnaXQgZmFzdC1pbXBvcnQgPDwtSU5QVVRfRU5ECgljb21taXQgcmVmcy9oZWFkcy9ONUUKCWNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQoJZGF0YSA8PENPTU1JVAoJY29weSB3aXRoIGludmFsaWQgc3ludGF4CglDT01NSVQKCglmcm9tIHJlZnMvaGVhZHMvYnJhbmNoXjAKCWxzICJmaWxlMi8iCglJTlBVVF9FTkQnCgp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdOOiBjb3B5IHRvIHJvb3QgYnkgaWQgYW5kIG1vZGlmeScgXAoJJ2VjaG8gImhlbGxvLCB3b3JsZCIgPmV4cGVjdC5mb28gJiYKCSBlY2hvIGhlbGxvID5leHBlY3QuYmFyICYmCgkgZ2l0IGZhc3QtaW1wb3J0IDw8LVNFVFVQX0VORCAmJgoJY29tbWl0IHJlZnMvaGVhZHMvTjcKCWNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQoJZGF0YSA8PENPTU1JVAoJaGVsbG8sIHRyZWUKCUNPTU1JVAoKCWRlbGV0ZWFsbAoJTSA2NDQgaW5saW5lIGZvby9iYXIKCWRhdGEgPDxFT0YKCWhlbGxvCglFT0YKCVNFVFVQX0VORAoKCSB0cmVlPSQoZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSBONzopICYmCgkgZ2l0IGZhc3QtaW1wb3J0IDw8LUlOUFVUX0VORCAmJgoJY29tbWl0IHJlZnMvaGVhZHMvTjgKCWNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQoJZGF0YSA8PENPTU1JVAoJY29weSB0byByb290IGJ5IGlkIGFuZCBtb2RpZnkKCUNPTU1JVAoKCU0gMDQwMDAwICR0cmVlICIiCglNIDY0NCBpbmxpbmUgZm9vL2ZvbwoJZGF0YSA8PEVPRgoJaGVsbG8sIHdvcmxkCglFT0YKCUlOUFVUX0VORAoJIGdpdCBzaG93IE44OmZvby9mb28gPmFjdHVhbC5mb28gJiYKCSBnaXQgc2hvdyBOODpmb28vYmFyID5hY3R1YWwuYmFyICYmCgkgdGVzdF9jbXAgZXhwZWN0LmZvbyBhY3R1YWwuZm9vICYmCgkgdGVzdF9jbXAgZXhwZWN0LmJhciBhY3R1YWwuYmFyJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknTjogZXh0cmFjdCBzdWJ0cmVlJyBcCgknYnJhbmNoPSQoZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSByZWZzL2hlYWRzL2JyYW5jaF57dHJlZX0pICYmCgkgY2F0ID5pbnB1dCA8PC1JTlBVVF9FTkQgJiYKCWNvbW1pdCByZWZzL2hlYWRzL045Cgljb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCWRhdGEgPDxDT01NSVQKCWV4dHJhY3Qgc3VidHJlZSBicmFuY2g6bmV3ZGlyCglDT01NSVQKCglNIDA0MDAwMCAkYnJhbmNoICIiCglDICJuZXdkaXIiICIiCglJTlBVVF9FTkQKCSBnaXQgZmFzdC1pbXBvcnQgPGlucHV0ICYmCgkgZ2l0IGRpZmYgLS1leGl0LWNvZGUgYnJhbmNoOm5ld2RpciBOOScKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ046IG1vZGlmeSBzdWJ0cmVlLCBleHRyYWN0IGl0LCBhbmQgbW9kaWZ5IGFnYWluJyBcCgknZWNobyBoZWxsbyA+ZXhwZWN0LmJheiAmJgoJIGVjaG8gaGVsbG8sIHdvcmxkID5leHBlY3QucXV4ICYmCgkgZ2l0IGZhc3QtaW1wb3J0IDw8LVNFVFVQX0VORCAmJgoJY29tbWl0IHJlZnMvaGVhZHMvTjEwCgljb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCWRhdGEgPDxDT01NSVQKCWhlbGxvLCB0cmVlCglDT01NSVQKCglkZWxldGVhbGwKCU0gNjQ0IGlubGluZSBmb28vYmFyL2JhegoJZGF0YSA8PEVPRgoJaGVsbG8KCUVPRgoJU0VUVVBfRU5ECgoJIHRyZWU9JChnaXQgcmV2LXBhcnNlIC0tdmVyaWZ5IE4xMDopICYmCgkgZ2l0IGZhc3QtaW1wb3J0IDw8LUlOUFVUX0VORCAmJgoJY29tbWl0IHJlZnMvaGVhZHMvTjExCgljb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCWRhdGEgPDxDT01NSVQKCWNvcHkgdG8gcm9vdCBieSBpZCBhbmQgbW9kaWZ5CglDT01NSVQKCglNIDA0MDAwMCAkdHJlZSAiIgoJTSAxMDA2NDQgaW5saW5lIGZvby9iYXIvcXV4CglkYXRhIDw8RU9GCgloZWxsbywgd29ybGQKCUVPRgoJUiAiZm9vIiAiIgoJQyAiYmFyL3F1eCIgImJhci9xdXV4IgoJSU5QVVRfRU5ECgkgZ2l0IHNob3cgTjExOmJhci9iYXogPmFjdHVhbC5iYXogJiYKCSBnaXQgc2hvdyBOMTE6YmFyL3F1eCA+YWN0dWFsLnF1eCAmJgoJIGdpdCBzaG93IE4xMTpiYXIvcXV1eCA+YWN0dWFsLnF1dXggJiYKCSB0ZXN0X2NtcCBleHBlY3QuYmF6IGFjdHVhbC5iYXogJiYKCSB0ZXN0X2NtcCBleHBlY3QucXV4IGFjdHVhbC5xdXggJiYKCSB0ZXN0X2NtcCBleHBlY3QucXV4IGFjdHVhbC5xdXV4JwoKIyMjCiMjIyBzZXJpZXMgTwojIyMKCmNhdCA+aW5wdXQgPDxJTlBVVF9FTkQKI3dlIHdpbGwKY29tbWl0IHJlZnMvaGVhZHMvTzEKIyAtLSBpZ25vcmUgYWxsIG9mIHRoaXMgdGV4dApjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKIyAkR0lUX0NPTU1JVFRFUl9OQU1FIGhhcyBpbnNlcnRlZCBoZXJlIGZvciBoaXMgYmVuZWZpdC4KZGF0YSA8PENPTU1JVApkaXJ0eSBkaXJlY3RvcnkgY29weQpDT01NSVQKCiMgZG9uJ3QgZm9yZ2V0IHRoZSBpbXBvcnQgYmxhbmsgbGluZSEKIwojIHllcywgd2Ugc3RhcnRlZCBmcm9tIG91ciB1c3VhbCBiYXNlIG9mIGJyYW5jaF4wLgojIGkgbGlrZSBicmFuY2heMC4KZnJvbSByZWZzL2hlYWRzL2JyYW5jaF4wCiMgYW5kIHdlIG5lZWQgdG8gcmV1c2UgZmlsZTIvZmlsZTUgZnJvbSBOMyBhYm92ZS4KTSA2NDQgaW5saW5lIGZpbGUyL2ZpbGU1CiMgb3RoZXJ3aXNlIHRoZSB0cmVlIHdpbGwgYmUgZGlmZmVyZW50CmRhdGEgPDxFT0YKJGZpbGU1X2RhdGEKRU9GCgojIGRvbid0IGZvcmdldCB0byBjb3B5IGZpbGUyIHRvIGZpbGUzCkMgZmlsZTIgZmlsZTMKIwojIG9yIHRvIGRlbGV0ZSBmaWxlNSBmcm9tIGZpbGUyLgpEIGZpbGUyL2ZpbGU1CiMgYXJlIHdlIGRvbmUgeWV0PwoKSU5QVVRfRU5ECgp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdPOiBjb21tZW50cyBhcmUgYWxsIHNraXBwZWQnIFwKCSdnaXQgZmFzdC1pbXBvcnQgPGlucHV0ICYmCgkgdGVzdCBgZ2l0IHJldi1wYXJzZSBOM2AgPSBgZ2l0IHJldi1wYXJzZSBPMWAnCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmNvbW1pdCByZWZzL2hlYWRzL08yCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCmRpcnR5IGRpcmVjdG9yeSBjb3B5CkNPTU1JVApmcm9tIHJlZnMvaGVhZHMvYnJhbmNoXjAKTSA2NDQgaW5saW5lIGZpbGUyL2ZpbGU1CmRhdGEgPDxFT0YKJGZpbGU1X2RhdGEKRU9GCkMgZmlsZTIgZmlsZTMKRCBmaWxlMi9maWxlNQoKSU5QVVRfRU5ECgp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdPOiBibGFuayBsaW5lcyBub3QgbmVjZXNzYXJ5IGFmdGVyIGRhdGEgY29tbWFuZHMnIFwKCSdnaXQgZmFzdC1pbXBvcnQgPGlucHV0ICYmCgkgdGVzdCBgZ2l0IHJldi1wYXJzZSBOM2AgPSBgZ2l0IHJldi1wYXJzZSBPMmAnCgp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdPOiByZXBhY2sgYmVmb3JlIG5leHQgdGVzdCcgXAoJJ2dpdCByZXBhY2sgLWEgLWQnCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmNvbW1pdCByZWZzL2hlYWRzL08zCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCnpzdHJpbmcKQ09NTUlUCmNvbW1pdCByZWZzL2hlYWRzL08zCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCnpvZgpDT01NSVQKY2hlY2twb2ludApjb21taXQgcmVmcy9oZWFkcy9PMwptYXJrIDo1CmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCnplbXB0eQpDT01NSVQKY2hlY2twb2ludApjb21taXQgcmVmcy9oZWFkcy9PMwpjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSA8PENPTU1JVAp6Y29tbWl0cwpDT01NSVQKcmVzZXQgcmVmcy90YWdzL08zLTJuZApmcm9tIDo1CnJlc2V0IHJlZnMvdGFncy9PMy0zcmQKZnJvbSA6NQpJTlBVVF9FTkQKCmNhdCA+ZXhwZWN0IDw8SU5QVVRfRU5ECnN0cmluZwpvZgplbXB0eQpjb21taXRzCklOUFVUX0VORAp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdPOiBibGFuayBsaW5lcyBub3QgbmVjZXNzYXJ5IGFmdGVyIG90aGVyIGNvbW1hbmRzJyBcCgknZ2l0IGZhc3QtaW1wb3J0IDxpbnB1dCAmJgoJIHRlc3QgOCA9IGBmaW5kIC5naXQvb2JqZWN0cy9wYWNrIC10eXBlIGYgfCB3YyAtbGAgJiYKCSB0ZXN0IGBnaXQgcmV2LXBhcnNlIHJlZnMvdGFncy9PMy0ybmRgID0gYGdpdCByZXYtcGFyc2UgTzNeYCAmJgoJIGdpdCBsb2cgLS1yZXZlcnNlIC0tcHJldHR5PW9uZWxpbmUgTzMgfCBzZWQgcy9eLip6Ly8gPmFjdHVhbCAmJgoJIHRlc3RfY21wIGV4cGVjdCBhY3R1YWwnCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmNvbW1pdCByZWZzL2hlYWRzL080CmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCnpzdHJpbmcKQ09NTUlUCmNvbW1pdCByZWZzL2hlYWRzL080CmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCnpvZgpDT01NSVQKcHJvZ3Jlc3MgVHdvIGNvbW1pdHMgZG93biwgMiB0byBnbyEKY29tbWl0IHJlZnMvaGVhZHMvTzQKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgPDxDT01NSVQKemVtcHR5CkNPTU1JVApwcm9ncmVzcyBUaHJlZSBjb21taXRzIGRvd24sIDEgdG8gZ28hCmNvbW1pdCByZWZzL2hlYWRzL080CmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCnpjb21taXRzCkNPTU1JVApwcm9ncmVzcyBJJ20gZG9uZSEKSU5QVVRfRU5ECnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ086IHByb2dyZXNzIG91dHB1dHMgYXMgcmVxdWVzdGVkIGJ5IGlucHV0JyBcCgknZ2l0IGZhc3QtaW1wb3J0IDxpbnB1dCA+YWN0dWFsICYmCgkgZ3JlcCAicHJvZ3Jlc3MgIiA8aW5wdXQgPmV4cGVjdCAmJgoJIHRlc3RfY21wIGV4cGVjdCBhY3R1YWwnCgojIyMKIyMjIHNlcmllcyBQIChnaXRsaW5rcykKIyMjCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmJsb2IKbWFyayA6MQpkYXRhIDEwCnRlc3QgZmlsZQoKcmVzZXQgcmVmcy9oZWFkcy9zdWIKY29tbWl0IHJlZnMvaGVhZHMvc3ViCm1hcmsgOjIKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgMTIKc3ViX2luaXRpYWwKTSAxMDA2NDQgOjEgZmlsZQoKYmxvYgptYXJrIDozCmRhdGEgPDxEQVRBRU5ECltzdWJtb2R1bGUgInN1YiJdCglwYXRoID0gc3ViCgl1cmwgPSAiYHB3ZGAvc3ViIgpEQVRBRU5ECgpjb21taXQgcmVmcy9oZWFkcy9zdWJ1c2UxCm1hcmsgOjQKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgOAppbml0aWFsCmZyb20gcmVmcy9oZWFkcy9tYXN0ZXIKTSAxMDA2NDQgOjMgLmdpdG1vZHVsZXMKTSAxNjAwMDAgOjIgc3ViCgpibG9iCm1hcmsgOjUKZGF0YSAyMAp0ZXN0IGZpbGUKbW9yZSBkYXRhCgpjb21taXQgcmVmcy9oZWFkcy9zdWIKbWFyayA6Ngpjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSAxMQpzdWJfc2Vjb25kCmZyb20gOjIKTSAxMDA2NDQgOjUgZmlsZQoKY29tbWl0IHJlZnMvaGVhZHMvc3VidXNlMQptYXJrIDo3CmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDcKc2Vjb25kCmZyb20gOjQKTSAxNjAwMDAgOjYgc3ViCgpJTlBVVF9FTkQKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ1A6IHN1cGVycHJvamVjdCAmIHN1Ym1vZHVsZSBtaXgnIFwKCSdnaXQgZmFzdC1pbXBvcnQgPGlucHV0ICYmCgkgZ2l0IGNoZWNrb3V0IHN1YnVzZTEgJiYKCSBybSAtcmYgc3ViICYmIG1rZGlyIHN1YiAmJiAoY2Qgc3ViICYmCgkgZ2l0IGluaXQgJiYKCSBnaXQgZmV0Y2ggLS11cGRhdGUtaGVhZC1vayAuLiByZWZzL2hlYWRzL3N1YjpyZWZzL2hlYWRzL21hc3RlciAmJgoJIGdpdCBjaGVja291dCBtYXN0ZXIpICYmCgkgZ2l0IHN1Ym1vZHVsZSBpbml0ICYmCgkgZ2l0IHN1Ym1vZHVsZSB1cGRhdGUnCgpTVUJMQVNUPSQoZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSBzdWIpClNVQlBSRVY9JChnaXQgcmV2LXBhcnNlIC0tdmVyaWZ5IHN1Yl4pCgpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmJsb2IKbWFyayA6MQpkYXRhIDw8REFUQUVORApbc3VibW9kdWxlICJzdWIiXQoJcGF0aCA9IHN1YgoJdXJsID0gImBwd2RgL3N1YiIKREFUQUVORAoKY29tbWl0IHJlZnMvaGVhZHMvc3VidXNlMgptYXJrIDoyCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDgKaW5pdGlhbApmcm9tIHJlZnMvaGVhZHMvbWFzdGVyCk0gMTAwNjQ0IDoxIC5naXRtb2R1bGVzCk0gMTYwMDAwICRTVUJQUkVWIHN1YgoKY29tbWl0IHJlZnMvaGVhZHMvc3VidXNlMgptYXJrIDozCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDcKc2Vjb25kCmZyb20gOjIKTSAxNjAwMDAgJFNVQkxBU1Qgc3ViCgpJTlBVVF9FTkQKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ1A6IHZlcmJhdGltIFNIQSBnaXRsaW5rcycgXAoJJ2dpdCBicmFuY2ggLUQgc3ViICYmCgkgZ2l0IGdjICYmIGdpdCBwcnVuZSAmJgoJIGdpdCBmYXN0LWltcG9ydCA8aW5wdXQgJiYKCSB0ZXN0ICQoZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSBzdWJ1c2UyKSA9ICQoZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSBzdWJ1c2UxKScKCnRlc3RfdGljawpjYXQgPmlucHV0IDw8SU5QVVRfRU5ECmNvbW1pdCByZWZzL2hlYWRzL3N1YnVzZTMKbWFyayA6MQpjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSA8PENPTU1JVApjb3JydXB0CkNPTU1JVAoKZnJvbSByZWZzL2hlYWRzL3N1YnVzZTIKTSAxNjAwMDAgaW5saW5lIHN1YgpkYXRhIDw8REFUQQokU1VCUFJFVgpEQVRBCgpJTlBVVF9FTkQKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1A6IGZhaWwgb24gaW5saW5lIGdpdGxpbmsnICcKICAgIHRlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCA8aW5wdXQnCgp0ZXN0X3RpY2sKY2F0ID5pbnB1dCA8PElOUFVUX0VORApibG9iCm1hcmsgOjEKZGF0YSA8PERBVEEKJFNVQlBSRVYKREFUQQoKY29tbWl0IHJlZnMvaGVhZHMvc3VidXNlMwptYXJrIDoyCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCmNvcnJ1cHQKQ09NTUlUCgpmcm9tIHJlZnMvaGVhZHMvc3VidXNlMgpNIDE2MDAwMCA6MSBzdWIKCklOUFVUX0VORAoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnUDogZmFpbCBvbiBibG9iIG1hcmsgaW4gZ2l0bGluaycgJwogICAgdGVzdF9tdXN0X2ZhaWwgZ2l0IGZhc3QtaW1wb3J0IDxpbnB1dCcKCiMjIwojIyMgc2VyaWVzIFEgKG5vdGVzKQojIyMKCm5vdGUxX2RhdGE9IlRoZSBmaXJzdCBub3RlIGZvciB0aGUgZmlyc3QgY29tbWl0Igpub3RlMl9kYXRhPSJUaGUgZmlyc3Qgbm90ZSBmb3IgdGhlIHNlY29uZCBjb21taXQiCm5vdGUzX2RhdGE9IlRoZSBmaXJzdCBub3RlIGZvciB0aGUgdGhpcmQgY29tbWl0Igpub3RlMWJfZGF0YT0iVGhlIHNlY29uZCBub3RlIGZvciB0aGUgZmlyc3QgY29tbWl0Igpub3RlMWNfZGF0YT0iVGhlIHRoaXJkIG5vdGUgZm9yIHRoZSBmaXJzdCBjb21taXQiCm5vdGUyYl9kYXRhPSJUaGUgc2Vjb25kIG5vdGUgZm9yIHRoZSBzZWNvbmQgY29tbWl0IgoKdGVzdF90aWNrCmNhdCA+aW5wdXQgPDxJTlBVVF9FTkQKYmxvYgptYXJrIDoyCmRhdGEgPDxFT0YKJGZpbGUyX2RhdGEKRU9GCgpjb21taXQgcmVmcy9oZWFkcy9ub3Rlcy10ZXN0Cm1hcmsgOjMKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgPDxDT01NSVQKZmlyc3QgKDozKQpDT01NSVQKCk0gNjQ0IDoyIGZpbGUyCgpibG9iCm1hcmsgOjQKZGF0YSAkZmlsZTRfbGVuCiRmaWxlNF9kYXRhCmNvbW1pdCByZWZzL2hlYWRzL25vdGVzLXRlc3QKbWFyayA6NQpjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSA8PENPTU1JVApzZWNvbmQgKDo1KQpDT01NSVQKCk0gNjQ0IDo0IGZpbGU0Cgpjb21taXQgcmVmcy9oZWFkcy9ub3Rlcy10ZXN0Cm1hcmsgOjYKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgPDxDT01NSVQKdGhpcmQgKDo2KQpDT01NSVQKCk0gNjQ0IGlubGluZSBmaWxlNQpkYXRhIDw8RU9GCiRmaWxlNV9kYXRhCkVPRgoKTSA3NTUgaW5saW5lIGZpbGU2CmRhdGEgPDxFT0YKJGZpbGU2X2RhdGEKRU9GCgpibG9iCm1hcmsgOjcKZGF0YSA8PEVPRgokbm90ZTFfZGF0YQpFT0YKCmJsb2IKbWFyayA6OApkYXRhIDw8RU9GCiRub3RlMl9kYXRhCkVPRgoKY29tbWl0IHJlZnMvbm90ZXMvZm9vYmFyCm1hcmsgOjkKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgPDxDT01NSVQKbm90ZXMgKDo5KQpDT01NSVQKCk4gOjcgOjMKTiA6OCA6NQpOIGlubGluZSA6NgpkYXRhIDw8RU9GCiRub3RlM19kYXRhCkVPRgoKY29tbWl0IHJlZnMvbm90ZXMvZm9vYmFyCm1hcmsgOjEwCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCm5vdGVzICg6MTApCkNPTU1JVAoKTiBpbmxpbmUgOjMKZGF0YSA8PEVPRgokbm90ZTFiX2RhdGEKRU9GCgpjb21taXQgcmVmcy9ub3Rlcy9mb29iYXIyCm1hcmsgOjExCmNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpkYXRhIDw8Q09NTUlUCm5vdGVzICg6MTEpCkNPTU1JVAoKTiBpbmxpbmUgOjMKZGF0YSA8PEVPRgokbm90ZTFjX2RhdGEKRU9GCgpjb21taXQgcmVmcy9ub3Rlcy9mb29iYXIKbWFyayA6MTIKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgPDxDT01NSVQKbm90ZXMgKDoxMikKQ09NTUlUCgpkZWxldGVhbGwKTiBpbmxpbmUgOjUKZGF0YSA8PEVPRgokbm90ZTJiX2RhdGEKRU9GCgpJTlBVVF9FTkQKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ1E6IGNvbW1pdCBub3RlcycgXAoJJ2dpdCBmYXN0LWltcG9ydCA8aW5wdXQgJiYKCSBnaXQgd2hhdGNoYW5nZWQgbm90ZXMtdGVzdCcKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1E6IHZlcmlmeSBwYWNrJyAnCgl2ZXJpZnlfcGFja3MKJwoKY29tbWl0MT0kKGdpdCByZXYtcGFyc2Ugbm90ZXMtdGVzdH4yKQpjb21taXQyPSQoZ2l0IHJldi1wYXJzZSBub3Rlcy10ZXN0XikKY29tbWl0Mz0kKGdpdCByZXYtcGFyc2Ugbm90ZXMtdGVzdCkKCmNhdCA+ZXhwZWN0IDw8RU9GCmF1dGhvciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCmZpcnN0ICg6MykKRU9GCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ1E6IHZlcmlmeSBmaXJzdCBjb21taXQnIFwKCSdnaXQgY2F0LWZpbGUgY29tbWl0IG5vdGVzLXRlc3R+MiB8IHNlZCAxZCA+YWN0dWFsICYmCgl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsJwoKY2F0ID5leHBlY3QgPDxFT0YKcGFyZW50ICRjb21taXQxCmF1dGhvciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCnNlY29uZCAoOjUpCkVPRgp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdROiB2ZXJpZnkgc2Vjb25kIGNvbW1pdCcgXAoJJ2dpdCBjYXQtZmlsZSBjb21taXQgbm90ZXMtdGVzdF4gfCBzZWQgMWQgPmFjdHVhbCAmJgoJdGVzdF9jbXAgZXhwZWN0IGFjdHVhbCcKCmNhdCA+ZXhwZWN0IDw8RU9GCnBhcmVudCAkY29tbWl0MgphdXRob3IgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCgp0aGlyZCAoOjYpCkVPRgp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdROiB2ZXJpZnkgdGhpcmQgY29tbWl0JyBcCgknZ2l0IGNhdC1maWxlIGNvbW1pdCBub3Rlcy10ZXN0IHwgc2VkIDFkID5hY3R1YWwgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwnCgpjYXQgPmV4cGVjdCA8PEVPRgphdXRob3IgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCgpub3RlcyAoOjkpCkVPRgp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdROiB2ZXJpZnkgZmlyc3Qgbm90ZXMgY29tbWl0JyBcCgknZ2l0IGNhdC1maWxlIGNvbW1pdCByZWZzL25vdGVzL2Zvb2Jhcn4yIHwgc2VkIDFkID5hY3R1YWwgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwnCgpjYXQgPmV4cGVjdC51bnNvcnRlZCA8PEVPRgoxMDA2NDQgYmxvYiAkY29tbWl0MQoxMDA2NDQgYmxvYiAkY29tbWl0MgoxMDA2NDQgYmxvYiAkY29tbWl0MwpFT0YKY2F0IGV4cGVjdC51bnNvcnRlZCB8IHNvcnQgPmV4cGVjdAp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdROiB2ZXJpZnkgZmlyc3Qgbm90ZXMgdHJlZScgXAoJJ2dpdCBjYXQtZmlsZSAtcCByZWZzL25vdGVzL2Zvb2Jhcn4yXnt0cmVlfSB8IHNlZCAicy8gWzAtOWEtZl0qCS8gLyIgPmFjdHVhbCAmJgoJIHRlc3RfY21wIGV4cGVjdCBhY3R1YWwnCgplY2hvICIkbm90ZTFfZGF0YSIgPmV4cGVjdAp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdROiB2ZXJpZnkgZmlyc3Qgbm90ZSBmb3IgZmlyc3QgY29tbWl0JyBcCgknZ2l0IGNhdC1maWxlIGJsb2IgcmVmcy9ub3Rlcy9mb29iYXJ+MjokY29tbWl0MSA+YWN0dWFsICYmIHRlc3RfY21wIGV4cGVjdCBhY3R1YWwnCgplY2hvICIkbm90ZTJfZGF0YSIgPmV4cGVjdAp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdROiB2ZXJpZnkgZmlyc3Qgbm90ZSBmb3Igc2Vjb25kIGNvbW1pdCcgXAoJJ2dpdCBjYXQtZmlsZSBibG9iIHJlZnMvbm90ZXMvZm9vYmFyfjI6JGNvbW1pdDIgPmFjdHVhbCAmJiB0ZXN0X2NtcCBleHBlY3QgYWN0dWFsJwoKZWNobyAiJG5vdGUzX2RhdGEiID5leHBlY3QKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknUTogdmVyaWZ5IGZpcnN0IG5vdGUgZm9yIHRoaXJkIGNvbW1pdCcgXAoJJ2dpdCBjYXQtZmlsZSBibG9iIHJlZnMvbm90ZXMvZm9vYmFyfjI6JGNvbW1pdDMgPmFjdHVhbCAmJiB0ZXN0X2NtcCBleHBlY3QgYWN0dWFsJwoKY2F0ID5leHBlY3QgPDxFT0YKcGFyZW50IGBnaXQgcmV2LXBhcnNlIC0tdmVyaWZ5IHJlZnMvbm90ZXMvZm9vYmFyfjJgCmF1dGhvciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCm5vdGVzICg6MTApCkVPRgp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdROiB2ZXJpZnkgc2Vjb25kIG5vdGVzIGNvbW1pdCcgXAoJJ2dpdCBjYXQtZmlsZSBjb21taXQgcmVmcy9ub3Rlcy9mb29iYXJeIHwgc2VkIDFkID5hY3R1YWwgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwnCgpjYXQgPmV4cGVjdC51bnNvcnRlZCA8PEVPRgoxMDA2NDQgYmxvYiAkY29tbWl0MQoxMDA2NDQgYmxvYiAkY29tbWl0MgoxMDA2NDQgYmxvYiAkY29tbWl0MwpFT0YKY2F0IGV4cGVjdC51bnNvcnRlZCB8IHNvcnQgPmV4cGVjdAp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdROiB2ZXJpZnkgc2Vjb25kIG5vdGVzIHRyZWUnIFwKCSdnaXQgY2F0LWZpbGUgLXAgcmVmcy9ub3Rlcy9mb29iYXJeXnt0cmVlfSB8IHNlZCAicy8gWzAtOWEtZl0qCS8gLyIgPmFjdHVhbCAmJgoJIHRlc3RfY21wIGV4cGVjdCBhY3R1YWwnCgplY2hvICIkbm90ZTFiX2RhdGEiID5leHBlY3QKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknUTogdmVyaWZ5IHNlY29uZCBub3RlIGZvciBmaXJzdCBjb21taXQnIFwKCSdnaXQgY2F0LWZpbGUgYmxvYiByZWZzL25vdGVzL2Zvb2Jhcl46JGNvbW1pdDEgPmFjdHVhbCAmJiB0ZXN0X2NtcCBleHBlY3QgYWN0dWFsJwoKZWNobyAiJG5vdGUyX2RhdGEiID5leHBlY3QKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknUTogdmVyaWZ5IGZpcnN0IG5vdGUgZm9yIHNlY29uZCBjb21taXQnIFwKCSdnaXQgY2F0LWZpbGUgYmxvYiByZWZzL25vdGVzL2Zvb2Jhcl46JGNvbW1pdDIgPmFjdHVhbCAmJiB0ZXN0X2NtcCBleHBlY3QgYWN0dWFsJwoKZWNobyAiJG5vdGUzX2RhdGEiID5leHBlY3QKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknUTogdmVyaWZ5IGZpcnN0IG5vdGUgZm9yIHRoaXJkIGNvbW1pdCcgXAoJJ2dpdCBjYXQtZmlsZSBibG9iIHJlZnMvbm90ZXMvZm9vYmFyXjokY29tbWl0MyA+YWN0dWFsICYmIHRlc3RfY21wIGV4cGVjdCBhY3R1YWwnCgpjYXQgPmV4cGVjdCA8PEVPRgphdXRob3IgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCgpub3RlcyAoOjExKQpFT0YKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknUTogdmVyaWZ5IHRoaXJkIG5vdGVzIGNvbW1pdCcgXAoJJ2dpdCBjYXQtZmlsZSBjb21taXQgcmVmcy9ub3Rlcy9mb29iYXIyIHwgc2VkIDFkID5hY3R1YWwgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwnCgpjYXQgPmV4cGVjdC51bnNvcnRlZCA8PEVPRgoxMDA2NDQgYmxvYiAkY29tbWl0MQpFT0YKY2F0IGV4cGVjdC51bnNvcnRlZCB8IHNvcnQgPmV4cGVjdAp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdROiB2ZXJpZnkgdGhpcmQgbm90ZXMgdHJlZScgXAoJJ2dpdCBjYXQtZmlsZSAtcCByZWZzL25vdGVzL2Zvb2JhcjJee3RyZWV9IHwgc2VkICJzLyBbMC05YS1mXSoJLyAvIiA+YWN0dWFsICYmCgkgdGVzdF9jbXAgZXhwZWN0IGFjdHVhbCcKCmVjaG8gIiRub3RlMWNfZGF0YSIgPmV4cGVjdAp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdROiB2ZXJpZnkgdGhpcmQgbm90ZSBmb3IgZmlyc3QgY29tbWl0JyBcCgknZ2l0IGNhdC1maWxlIGJsb2IgcmVmcy9ub3Rlcy9mb29iYXIyOiRjb21taXQxID5hY3R1YWwgJiYgdGVzdF9jbXAgZXhwZWN0IGFjdHVhbCcKCmNhdCA+ZXhwZWN0IDw8RU9GCnBhcmVudCBgZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSByZWZzL25vdGVzL2Zvb2Jhcl5gCmF1dGhvciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQpjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCm5vdGVzICg6MTIpCkVPRgp0ZXN0X2V4cGVjdF9zdWNjZXNzIFwKCSdROiB2ZXJpZnkgZm91cnRoIG5vdGVzIGNvbW1pdCcgXAoJJ2dpdCBjYXQtZmlsZSBjb21taXQgcmVmcy9ub3Rlcy9mb29iYXIgfCBzZWQgMWQgPmFjdHVhbCAmJgoJdGVzdF9jbXAgZXhwZWN0IGFjdHVhbCcKCmNhdCA+ZXhwZWN0LnVuc29ydGVkIDw8RU9GCjEwMDY0NCBibG9iICRjb21taXQyCkVPRgpjYXQgZXhwZWN0LnVuc29ydGVkIHwgc29ydCA+ZXhwZWN0CnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ1E6IHZlcmlmeSBmb3VydGggbm90ZXMgdHJlZScgXAoJJ2dpdCBjYXQtZmlsZSAtcCByZWZzL25vdGVzL2Zvb2Jhcl57dHJlZX0gfCBzZWQgInMvIFswLTlhLWZdKgkvIC8iID5hY3R1YWwgJiYKCSB0ZXN0X2NtcCBleHBlY3QgYWN0dWFsJwoKZWNobyAiJG5vdGUyYl9kYXRhIiA+ZXhwZWN0CnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ1E6IHZlcmlmeSBzZWNvbmQgbm90ZSBmb3Igc2Vjb25kIGNvbW1pdCcgXAoJJ2dpdCBjYXQtZmlsZSBibG9iIHJlZnMvbm90ZXMvZm9vYmFyOiRjb21taXQyID5hY3R1YWwgJiYgdGVzdF9jbXAgZXhwZWN0IGFjdHVhbCcKCmNhdCA+aW5wdXQgPDxFT0YKcmVzZXQgcmVmcy9oZWFkcy9RMAoKY29tbWl0IHJlZnMvaGVhZHMvbm90ZS1RMApjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSA8PENPTU1JVApOb3RlIGZvciBhbiBlbXB0eSBicmFuY2guCkNPTU1JVAoKTiBpbmxpbmUgcmVmcy9oZWFkcy9RMApkYXRhIDw8Tk9URQpzb21lIG5vdGUKTk9URQpFT0YKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknUTogZGVueSBub3RlIG9uIGVtcHR5IGJyYW5jaCcgXAoJJ3Rlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCA8aW5wdXQnCiMjIwojIyMgc2VyaWVzIFIgKGZlYXR1cmUgYW5kIG9wdGlvbikKIyMjCgpjYXQgPmlucHV0IDw8RU9GCmZlYXR1cmUgbm8tc3VjaC1mZWF0dXJlLWV4aXN0cwpFT0YKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1I6IGFib3J0IG9uIHVuc3VwcG9ydGVkIGZlYXR1cmUnICcKCXRlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCA8aW5wdXQKJwoKY2F0ID5pbnB1dCA8PEVPRgpmZWF0dXJlIGRhdGUtZm9ybWF0PW5vdwpFT0YKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1I6IHN1cHBvcnRlZCBmZWF0dXJlIGlzIGFjY2VwdGVkJyAnCglnaXQgZmFzdC1pbXBvcnQgPGlucHV0CicKCmNhdCA+aW5wdXQgPDwgRU9GCmJsb2IKZGF0YSAzCmhpCmZlYXR1cmUgZGF0ZS1mb3JtYXQ9bm93CkVPRgoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnUjogYWJvcnQgb24gcmVjZWl2aW5nIGZlYXR1cmUgYWZ0ZXIgZGF0YSBjb21tYW5kJyAnCgl0ZXN0X211c3RfZmFpbCBnaXQgZmFzdC1pbXBvcnQgPGlucHV0CicKCmNhdCA+aW5wdXQgPDwgRU9GCmZlYXR1cmUgaW1wb3J0LW1hcmtzPWdpdC5tYXJrcwpmZWF0dXJlIGltcG9ydC1tYXJrcz1naXQyLm1hcmtzCkVPRgoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnUjogb25seSBvbmUgaW1wb3J0LW1hcmtzIGZlYXR1cmUgYWxsb3dlZCBwZXIgc3RyZWFtJyAnCgl0ZXN0X211c3RfZmFpbCBnaXQgZmFzdC1pbXBvcnQgPGlucHV0CicKCmNhdCA+aW5wdXQgPDwgRU9GCmZlYXR1cmUgZXhwb3J0LW1hcmtzPWdpdC5tYXJrcwpibG9iCm1hcmsgOjEKZGF0YSAzCmhpCgpFT0YKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAogICAgJ1I6IGV4cG9ydC1tYXJrcyBmZWF0dXJlIHJlc3VsdHMgaW4gYSBtYXJrcyBmaWxlIGJlaW5nIGNyZWF0ZWQnIFwKICAgICdjYXQgaW5wdXQgfCBnaXQgZmFzdC1pbXBvcnQgJiYKICAgIGdyZXAgOjEgZ2l0Lm1hcmtzJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCiAgICAnUjogZXhwb3J0LW1hcmtzIG9wdGlvbnMgY2FuIGJlIG92ZXJyaWRlbiBieSBjb21tYW5kbGluZSBvcHRpb25zJyBcCiAgICAnY2F0IGlucHV0IHwgZ2l0IGZhc3QtaW1wb3J0IC0tZXhwb3J0LW1hcmtzPW90aGVyLm1hcmtzICYmCiAgICBncmVwIDoxIG90aGVyLm1hcmtzJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnUjogY2F0Y2ggdHlwbyBpbiBtYXJrcyBmaWxlIG5hbWUnICcKCXRlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCAtLWltcG9ydC1tYXJrcz1ub25leGlzdGVudC5tYXJrcyA8L2Rldi9udWxsICYmCgllY2hvICJmZWF0dXJlIGltcG9ydC1tYXJrcz1ub25leGlzdGVudC5tYXJrcyIgfAoJdGVzdF9tdXN0X2ZhaWwgZ2l0IGZhc3QtaW1wb3J0CicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1I6IGltcG9ydCBhbmQgb3V0cHV0IG1hcmtzIGNhbiBiZSB0aGUgc2FtZSBmaWxlJyAnCglybSAtZiBpby5tYXJrcyAmJgoJYmxvYj0kKGVjaG8gaGkgfCBnaXQgaGFzaC1vYmplY3QgLS1zdGRpbikgJiYKCWNhdCA+ZXhwZWN0IDw8LUVPRiAmJgoJOjEgJGJsb2IKCToyICRibG9iCglFT0YKCWdpdCBmYXN0LWltcG9ydCAtLWV4cG9ydC1tYXJrcz1pby5tYXJrcyA8PC1cRU9GICYmCglibG9iCgltYXJrIDoxCglkYXRhIDMKCWhpCgoJRU9GCglnaXQgZmFzdC1pbXBvcnQgLS1pbXBvcnQtbWFya3M9aW8ubWFya3MgLS1leHBvcnQtbWFya3M9aW8ubWFya3MgPDwtXEVPRiAmJgoJYmxvYgoJbWFyayA6MgoJZGF0YSAzCgloaQoKCUVPRgoJdGVzdF9jbXAgZXhwZWN0IGlvLm1hcmtzCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1I6IC0taW1wb3J0LW1hcmtzPWZvbyAtLW91dHB1dC1tYXJrcz1mb28gdG8gY3JlYXRlIGZvbyBmYWlscycgJwoJcm0gLWYgaW8ubWFya3MgJiYKCXRlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCAtLWltcG9ydC1tYXJrcz1pby5tYXJrcyAtLWV4cG9ydC1tYXJrcz1pby5tYXJrcyA8PC1cRU9GCglibG9iCgltYXJrIDoxCglkYXRhIDMKCWhpCgoJRU9GCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1I6IC0taW1wb3J0LW1hcmtzLWlmLWV4aXN0cycgJwoJcm0gLWYgaW8ubWFya3MgJiYKCWJsb2I9JChlY2hvIGhpIHwgZ2l0IGhhc2gtb2JqZWN0IC0tc3RkaW4pICYmCgllY2hvICI6MSAkYmxvYiIgPmV4cGVjdCAmJgoJZ2l0IGZhc3QtaW1wb3J0IC0taW1wb3J0LW1hcmtzLWlmLWV4aXN0cz1pby5tYXJrcyAtLWV4cG9ydC1tYXJrcz1pby5tYXJrcyA8PC1cRU9GICYmCglibG9iCgltYXJrIDoxCglkYXRhIDMKCWhpCgoJRU9GCgl0ZXN0X2NtcCBleHBlY3QgaW8ubWFya3MKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnUjogZmVhdHVyZSBpbXBvcnQtbWFya3MtaWYtZXhpc3RzJyAnCglybSAtZiBpby5tYXJrcyAmJgoJPmV4cGVjdCAmJgoKCWdpdCBmYXN0LWltcG9ydCAtLWV4cG9ydC1tYXJrcz1pby5tYXJrcyA8PC1cRU9GICYmCglmZWF0dXJlIGltcG9ydC1tYXJrcy1pZi1leGlzdHM9bm90X2lvLm1hcmtzCglFT0YKCXRlc3RfY21wIGV4cGVjdCBpby5tYXJrcyAmJgoKCWJsb2I9JChlY2hvIGhpIHwgZ2l0IGhhc2gtb2JqZWN0IC0tc3RkaW4pICYmCgoJZWNobyAiOjEgJGJsb2IiID5pby5tYXJrcyAmJgoJZWNobyAiOjEgJGJsb2IiID5leHBlY3QgJiYKCWVjaG8gIjoyICRibG9iIiA+PmV4cGVjdCAmJgoKCWdpdCBmYXN0LWltcG9ydCAtLWV4cG9ydC1tYXJrcz1pby5tYXJrcyA8PC1cRU9GICYmCglmZWF0dXJlIGltcG9ydC1tYXJrcy1pZi1leGlzdHM9aW8ubWFya3MKCWJsb2IKCW1hcmsgOjIKCWRhdGEgMwoJaGkKCglFT0YKCXRlc3RfY21wIGV4cGVjdCBpby5tYXJrcyAmJgoKCWVjaG8gIjozICRibG9iIiA+PmV4cGVjdCAmJgoKCWdpdCBmYXN0LWltcG9ydCAtLWltcG9ydC1tYXJrcz1pby5tYXJrcyBcCgkJCS0tZXhwb3J0LW1hcmtzPWlvLm1hcmtzIDw8LVxFT0YgJiYKCWZlYXR1cmUgaW1wb3J0LW1hcmtzLWlmLWV4aXN0cz1ub3RfaW8ubWFya3MKCWJsb2IKCW1hcmsgOjMKCWRhdGEgMwoJaGkKCglFT0YKCXRlc3RfY21wIGV4cGVjdCBpby5tYXJrcyAmJgoKCT5leHBlY3QgJiYKCglnaXQgZmFzdC1pbXBvcnQgLS1pbXBvcnQtbWFya3MtaWYtZXhpc3RzPW5vdF9pby5tYXJrcyBcCgkJCS0tZXhwb3J0LW1hcmtzPWlvLm1hcmtzIDw8LVxFT0YKCWZlYXR1cmUgaW1wb3J0LW1hcmtzLWlmLWV4aXN0cz1pby5tYXJrcwoJRU9GCgl0ZXN0X2NtcCBleHBlY3QgaW8ubWFya3MKJwoKY2F0ID5pbnB1dCA8PCBFT0YKZmVhdHVyZSBpbXBvcnQtbWFya3M9bWFya3Mub3V0CmZlYXR1cmUgZXhwb3J0LW1hcmtzPW1hcmtzLm5ldwpFT0YKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAogICAgJ1I6IGltcG9ydCB0byBvdXRwdXQgbWFya3Mgd29ya3Mgd2l0aG91dCBhbnkgY29udGVudCcgXAogICAgJ2NhdCBpbnB1dCB8IGdpdCBmYXN0LWltcG9ydCAmJgogICAgdGVzdF9jbXAgbWFya3Mub3V0IG1hcmtzLm5ldycKCmNhdCA+aW5wdXQgPDxFT0YKZmVhdHVyZSBpbXBvcnQtbWFya3M9bm9uZXhpc3RlbnQubWFya3MKZmVhdHVyZSBleHBvcnQtbWFya3M9bWFya3MubmV3CkVPRgoKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCiAgICAnUjogaW1wb3J0IG1hcmtzIHByZWZlcnMgY29tbWFuZGxpbmUgbWFya3MgZmlsZSBvdmVyIHRoZSBzdHJlYW0nIFwKICAgICdjYXQgaW5wdXQgfCBnaXQgZmFzdC1pbXBvcnQgLS1pbXBvcnQtbWFya3M9bWFya3Mub3V0ICYmCiAgICB0ZXN0X2NtcCBtYXJrcy5vdXQgbWFya3MubmV3JwoKCmNhdCA+aW5wdXQgPDxFT0YKZmVhdHVyZSBpbXBvcnQtbWFya3M9bm9uZXhpc3RlbnQubWFya3MKZmVhdHVyZSBleHBvcnQtbWFya3M9Y29tYmluZWQubWFya3MKRU9GCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdSOiBtdWx0aXBsZSAtLWltcG9ydC1tYXJrcz0gc2hvdWxkIGJlIGhvbm91cmVkJyAnCiAgICBoZWFkIC1uMiBtYXJrcy5vdXQgPiBvbmUubWFya3MgJiYKICAgIHRhaWwgLW4gKzMgbWFya3Mub3V0ID4gdHdvLm1hcmtzICYmCiAgICBnaXQgZmFzdC1pbXBvcnQgLS1pbXBvcnQtbWFya3M9b25lLm1hcmtzIC0taW1wb3J0LW1hcmtzPXR3by5tYXJrcyA8aW5wdXQgJiYKICAgIHRlc3RfY21wIG1hcmtzLm91dCBjb21iaW5lZC5tYXJrcwonCgpjYXQgPmlucHV0IDw8RU9GCmZlYXR1cmUgcmVsYXRpdmUtbWFya3MKZmVhdHVyZSBpbXBvcnQtbWFya3M9cmVsYXRpdmUuaW4KZmVhdHVyZSBleHBvcnQtbWFya3M9cmVsYXRpdmUub3V0CkVPRgoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnUjogZmVhdHVyZSByZWxhdGl2ZS1tYXJrcyBzaG91bGQgYmUgaG9ub3VyZWQnICcKICAgIG1rZGlyIC1wIC5naXQvaW5mby9mYXN0LWltcG9ydC8gJiYKICAgIGNwIG1hcmtzLm5ldyAuZ2l0L2luZm8vZmFzdC1pbXBvcnQvcmVsYXRpdmUuaW4gJiYKICAgIGdpdCBmYXN0LWltcG9ydCA8aW5wdXQgJiYKICAgIHRlc3RfY21wIG1hcmtzLm5ldyAuZ2l0L2luZm8vZmFzdC1pbXBvcnQvcmVsYXRpdmUub3V0CicKCmNhdCA+aW5wdXQgPDxFT0YKZmVhdHVyZSByZWxhdGl2ZS1tYXJrcwpmZWF0dXJlIGltcG9ydC1tYXJrcz1yZWxhdGl2ZS5pbgpmZWF0dXJlIG5vLXJlbGF0aXZlLW1hcmtzCmZlYXR1cmUgZXhwb3J0LW1hcmtzPW5vbi1yZWxhdGl2ZS5vdXQKRU9GCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdSOiBmZWF0dXJlIG5vLXJlbGF0aXZlLW1hcmtzIHNob3VsZCBiZSBob25vdXJlZCcgJwogICAgZ2l0IGZhc3QtaW1wb3J0IDxpbnB1dCAmJgogICAgdGVzdF9jbXAgbWFya3MubmV3IG5vbi1yZWxhdGl2ZS5vdXQKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnUjogZmVhdHVyZSBscyBzdXBwb3J0ZWQnICcKCWVjaG8gImZlYXR1cmUgbHMiIHwKCWdpdCBmYXN0LWltcG9ydAonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdSOiBmZWF0dXJlIGNhdC1ibG9iIHN1cHBvcnRlZCcgJwoJZWNobyAiZmVhdHVyZSBjYXQtYmxvYiIgfAoJZ2l0IGZhc3QtaW1wb3J0CicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1I6IGNhdC1ibG9iLWZkIG11c3QgYmUgYSBub25uZWdhdGl2ZSBpbnRlZ2VyJyAnCgl0ZXN0X211c3RfZmFpbCBnaXQgZmFzdC1pbXBvcnQgLS1jYXQtYmxvYi1mZD0tMSA8L2Rldi9udWxsCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgTk9UX01JTkdXICdSOiBwcmludCBvbGQgYmxvYicgJwoJYmxvYj0kKGVjaG8gInllcyBpdCBjYW4iIHwgZ2l0IGhhc2gtb2JqZWN0IC13IC0tc3RkaW4pICYmCgljYXQgPmV4cGVjdCA8PC1FT0YgJiYKCSR7YmxvYn0gYmxvYiAxMQoJeWVzIGl0IGNhbgoKCUVPRgoJZWNobyAiY2F0LWJsb2IgJGJsb2IiIHwKCWdpdCBmYXN0LWltcG9ydCAtLWNhdC1ibG9iLWZkPTYgNj5hY3R1YWwgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyBOT1RfTUlOR1cgJ1I6IGluLXN0cmVhbSBjYXQtYmxvYi1mZCBub3QgcmVzcGVjdGVkJyAnCgllY2hvIGhlbGxvID5ncmVldGluZyAmJgoJYmxvYj0kKGdpdCBoYXNoLW9iamVjdCAtdyBncmVldGluZykgJiYKCWNhdCA+ZXhwZWN0IDw8LUVPRiAmJgoJJHtibG9ifSBibG9iIDYKCWhlbGxvCgoJRU9GCglnaXQgZmFzdC1pbXBvcnQgLS1jYXQtYmxvYi1mZD0zIDM+YWN0dWFsLjMgPmFjdHVhbC4xIDw8LUVPRiAmJgoJY2F0LWJsb2IgJGJsb2IKCUVPRgoJdGVzdF9jbXAgZXhwZWN0IGFjdHVhbC4zICYmCgl0ZXN0X2NtcCBlbXB0eSBhY3R1YWwuMSAmJgoJZ2l0IGZhc3QtaW1wb3J0IDM+YWN0dWFsLjMgPmFjdHVhbC4xIDw8LUVPRiAmJgoJb3B0aW9uIGNhdC1ibG9iLWZkPTMKCWNhdC1ibG9iICRibG9iCglFT0YKCXRlc3RfY21wIGVtcHR5IGFjdHVhbC4zICYmCgl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsLjEKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyBOT1RfTUlOR1cgJ1I6IHByaW50IG5ldyBibG9iJyAnCglibG9iPSQoZWNobyAieWVwIHllcCB5ZXAiIHwgZ2l0IGhhc2gtb2JqZWN0IC0tc3RkaW4pICYmCgljYXQgPmV4cGVjdCA8PC1FT0YgJiYKCSR7YmxvYn0gYmxvYiAxMgoJeWVwIHllcCB5ZXAKCglFT0YKCWdpdCBmYXN0LWltcG9ydCAtLWNhdC1ibG9iLWZkPTYgNj5hY3R1YWwgPDwtXEVPRiAmJgoJYmxvYgoJbWFyayA6MQoJZGF0YSA8PEJMT0JfRU5ECgl5ZXAgeWVwIHllcAoJQkxPQl9FTkQKCWNhdC1ibG9iIDoxCglFT0YKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyBOT1RfTUlOR1cgJ1I6IHByaW50IG5ldyBibG9iIGJ5IHNoYTEnICcKCWJsb2I9JChlY2hvICJhIG5ldyBibG9iIG5hbWVkIGJ5IHNoYTEiIHwgZ2l0IGhhc2gtb2JqZWN0IC0tc3RkaW4pICYmCgljYXQgPmV4cGVjdCA8PC1FT0YgJiYKCSR7YmxvYn0gYmxvYiAyNQoJYSBuZXcgYmxvYiBuYW1lZCBieSBzaGExCgoJRU9GCglnaXQgZmFzdC1pbXBvcnQgLS1jYXQtYmxvYi1mZD02IDY+YWN0dWFsIDw8LUVPRiAmJgoJYmxvYgoJZGF0YSA8PEJMT0JfRU5ECglhIG5ldyBibG9iIG5hbWVkIGJ5IHNoYTEKCUJMT0JfRU5ECgljYXQtYmxvYiAkYmxvYgoJRU9GCgl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3NldHVwOiBiaWcgZmlsZScgJwoJKAoJCWVjaG8gInRoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2ciID5iaWcgJiYKCQlmb3IgaSBpbiAxIDIgMwoJCWRvCgkJCWNhdCBiaWcgYmlnIGJpZyBiaWcgPmJpZ2dlciAmJgoJCQljYXQgYmlnZ2VyIGJpZ2dlciBiaWdnZXIgYmlnZ2VyID5iaWcgfHwKCQkJZXhpdAoJCWRvbmUKCSkKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnUjogcHJpbnQgdHdvIGJsb2JzIHRvIHN0ZG91dCcgJwoJYmxvYjE9JChnaXQgaGFzaC1vYmplY3QgYmlnKSAmJgoJYmxvYjFfbGVuPSQod2MgLWMgPGJpZykgJiYKCWJsb2IyPSQoZWNobyBoZWxsbyB8IGdpdCBoYXNoLW9iamVjdCAtLXN0ZGluKSAmJgoJewoJCWVjaG8gJHtibG9iMX0gYmxvYiAkYmxvYjFfbGVuICYmCgkJY2F0IGJpZyAmJgoJCWNhdCA8PC1FT0YKCgkJJHtibG9iMn0gYmxvYiA2CgkJaGVsbG8KCgkJRU9GCgl9ID5leHBlY3QgJiYKCXsKCQljYXQgPDwtXEVORF9QQVJUMSAmJgoJCQlibG9iCgkJCW1hcmsgOjEKCQkJZGF0YSA8PGRhdGFfZW5kCgkJRU5EX1BBUlQxCgkJY2F0IGJpZyAmJgoJCWNhdCA8PC1cRU9GCgkJCWRhdGFfZW5kCgkJCWJsb2IKCQkJbWFyayA6MgoJCQlkYXRhIDw8ZGF0YV9lbmQKCQkJaGVsbG8KCQkJZGF0YV9lbmQKCQkJY2F0LWJsb2IgOjEKCQkJY2F0LWJsb2IgOjIKCQlFT0YKCX0gfAoJZ2l0IGZhc3QtaW1wb3J0ID5hY3R1YWwgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyBQSVBFICdSOiBjb3B5IHVzaW5nIGNhdC1maWxlJyAnCglleHBlY3RfaWQ9JChnaXQgaGFzaC1vYmplY3QgYmlnKSAmJgoJZXhwZWN0X2xlbj0kKHdjIC1jIDxiaWcpICYmCgllY2hvICRleHBlY3RfaWQgYmxvYiAkZXhwZWN0X2xlbiA+ZXhwZWN0LnJlc3BvbnNlICYmCgoJcm0gLWYgYmxvYnMgJiYKCWNhdCA+ZnJvbnRlbmQgPDwtXEZST05URU5EX0VORCAmJgoJIyEvYmluL3NoCglGUk9OVEVORF9FTkQKCglta2ZpZm8gYmxvYnMgJiYKCSgKCQlleHBvcnQgR0lUX0NPTU1JVFRFUl9OQU1FIEdJVF9DT01NSVRURVJfRU1BSUwgR0lUX0NPTU1JVFRFUl9EQVRFICYmCgkJY2F0IDw8LVxFT0YgJiYKCQlmZWF0dXJlIGNhdC1ibG9iCgkJYmxvYgoJCW1hcmsgOjEKCQlkYXRhIDw8QkxPQgoJCUVPRgoJCWNhdCBiaWcgJiYKCQljYXQgPDwtXEVPRiAmJgoJCUJMT0IKCQljYXQtYmxvYiA6MQoJCUVPRgoKCQlyZWFkIGJsb2JfaWQgdHlwZSBzaXplIDwmMyAmJgoJCWVjaG8gIiRibG9iX2lkICR0eXBlICRzaXplIiA+cmVzcG9uc2UgJiYKCQloZWFkX2MgJHNpemUgPmJsb2IgPCYzICYmCgkJcmVhZCBuZXdsaW5lIDwmMyAmJgoKCQljYXQgPDwtRU9GICYmCgkJY29tbWl0IHJlZnMvaGVhZHMvY29waWVkCgkJY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCgkJZGF0YSA8PENPTU1JVAoJCWNvcHkgYmlnIGZpbGUgYXMgZmlsZTMKCQlDT01NSVQKCQlNIDY0NCBpbmxpbmUgZmlsZTMKCQlkYXRhIDw8QkxPQgoJCUVPRgoJCWNhdCBibG9iICYmCgkJZWNobyBCTE9CCgkpIDM8YmxvYnMgfAoJZ2l0IGZhc3QtaW1wb3J0IC0tY2F0LWJsb2ItZmQ9MyAzPmJsb2JzICYmCglnaXQgc2hvdyBjb3BpZWQ6ZmlsZTMgPmFjdHVhbCAmJgoJdGVzdF9jbXAgZXhwZWN0LnJlc3BvbnNlIHJlc3BvbnNlICYmCgl0ZXN0X2NtcCBiaWcgYWN0dWFsCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgUElQRSAnUjogcHJpbnQgYmxvYiBtaWQtY29tbWl0JyAnCglybSAtZiBibG9icyAmJgoJZWNobyAiQSBibG9iIGZyb20gX2JlZm9yZV8gdGhlIGNvbW1pdC4iID5leHBlY3QgJiYKCW1rZmlmbyBibG9icyAmJgoJKAoJCWV4ZWMgMzxibG9icyAmJgoJCWNhdCA8PC1FT0YgJiYKCQlmZWF0dXJlIGNhdC1ibG9iCgkJYmxvYgoJCW1hcmsgOjEKCQlkYXRhIDw8QkxPQgoJCUEgYmxvYiBmcm9tIF9iZWZvcmVfIHRoZSBjb21taXQuCgkJQkxPQgoJCWNvbW1pdCByZWZzL2hlYWRzL3RlbXBvcmFyeQoJCWNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQoJCWRhdGEgPDxDT01NSVQKCQlFbXB0eSBjb21taXQKCQlDT01NSVQKCQljYXQtYmxvYiA6MQoJCUVPRgoKCQlyZWFkIGJsb2JfaWQgdHlwZSBzaXplIDwmMyAmJgoJCWhlYWRfYyAkc2l6ZSA+YWN0dWFsIDwmMyAmJgoJCXJlYWQgbmV3bGluZSA8JjMgJiYKCgkJZWNobwoJKSB8CglnaXQgZmFzdC1pbXBvcnQgLS1jYXQtYmxvYi1mZD0zIDM+YmxvYnMgJiYKCXRlc3RfY21wIGV4cGVjdCBhY3R1YWwKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyBQSVBFICdSOiBwcmludCBzdGFnZWQgYmxvYiB3aXRoaW4gY29tbWl0JyAnCglybSAtZiBibG9icyAmJgoJZWNobyAiQSBibG9iIGZyb20gX3dpdGhpbl8gdGhlIGNvbW1pdC4iID5leHBlY3QgJiYKCW1rZmlmbyBibG9icyAmJgoJKAoJCWV4ZWMgMzxibG9icyAmJgoJCWNhdCA8PC1FT0YgJiYKCQlmZWF0dXJlIGNhdC1ibG9iCgkJY29tbWl0IHJlZnMvaGVhZHMvd2l0aGluCgkJY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCgkJZGF0YSA8PENPTU1JVAoJCUVtcHR5IGNvbW1pdAoJCUNPTU1JVAoJCU0gNjQ0IGlubGluZSB3aXRoaW4KCQlkYXRhIDw8QkxPQgoJCUEgYmxvYiBmcm9tIF93aXRoaW5fIHRoZSBjb21taXQuCgkJQkxPQgoJCUVPRgoKCQl0b19nZXQ9JCgKCQkJZWNobyAiQSBibG9iIGZyb20gX3dpdGhpbl8gdGhlIGNvbW1pdC4iIHwKCQkJZ2l0IGhhc2gtb2JqZWN0IC0tc3RkaW4KCQkpICYmCgkJZWNobyAiY2F0LWJsb2IgJHRvX2dldCIgJiYKCgkJcmVhZCBibG9iX2lkIHR5cGUgc2l6ZSA8JjMgJiYKCQloZWFkX2MgJHNpemUgPmFjdHVhbCA8JjMgJiYKCQlyZWFkIG5ld2xpbmUgPCYzICYmCgoJCWVjaG8gZGVsZXRlYWxsCgkpIHwKCWdpdCBmYXN0LWltcG9ydCAtLWNhdC1ibG9iLWZkPTMgMz5ibG9icyAmJgoJdGVzdF9jbXAgZXhwZWN0IGFjdHVhbAonCgpjYXQgPmlucHV0IDw8IEVPRgpvcHRpb24gZ2l0IHF1aWV0CmJsb2IKZGF0YSAzCmhpCgpFT0YKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1I6IHF1aWV0IG9wdGlvbiByZXN1bHRzIGluIG5vIHN0YXRzIGJlaW5nIG91dHB1dCcgJwogICAgY2F0IGlucHV0IHwgZ2l0IGZhc3QtaW1wb3J0IDI+IG91dHB1dCAmJgogICAgdGVzdF9jbXAgZW1wdHkgb3V0cHV0CicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1I6IGZlYXR1cmUgZG9uZSBtZWFucyB0ZXJtaW5hdGluZyAiZG9uZSIgaXMgbWFuZGF0b3J5JyAnCgllY2hvIGZlYXR1cmUgZG9uZSB8IHRlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCAmJgoJdGVzdF9tdXN0X2ZhaWwgZ2l0IGZhc3QtaW1wb3J0IC0tZG9uZSA8L2Rldi9udWxsCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1I6IHRlcm1pbmF0aW5nICJkb25lIiB3aXRoIHRyYWlsaW5nIGdpYmJlcmlzaCBpcyBvaycgJwoJZ2l0IGZhc3QtaW1wb3J0IDw8LVxFT0YgJiYKCWZlYXR1cmUgZG9uZQoJZG9uZQoJdHJhaWxpbmcgZ2liYmVyaXNoCglFT0YKCWdpdCBmYXN0LWltcG9ydCA8PC1cRU9GCglkb25lCgltb3JlIHRyYWlsaW5nIGdpYmJlcmlzaAoJRU9GCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1I6IHRlcm1pbmF0aW5nICJkb25lIiB3aXRoaW4gY29tbWl0JyAnCgljYXQgPmV4cGVjdCA8PC1cRU9GICYmCglPQkpJRAoJOjAwMDAwMCAxMDA2NDQgT0JKSUQgT0JKSUQgQQloZWxsby5jCgk6MDAwMDAwIDEwMDY0NCBPQkpJRCBPQkpJRCBBCWhlbGxvMi5jCglFT0YKCWdpdCBmYXN0LWltcG9ydCA8PC1FT0YgJiYKCWNvbW1pdCByZWZzL2hlYWRzL2RvbmUtZW5kcwoJY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCglkYXRhIDw8RU9UCglDb21taXQgdGVybWluYXRlZCBieSAiZG9uZSIgY29tbWFuZAoJRU9UCglNIDEwMDY0NCBpbmxpbmUgaGVsbG8uYwoJZGF0YSA8PEVPVAoJSGVsbG8sIHdvcmxkLgoJRU9UCglDIGhlbGxvLmMgaGVsbG8yLmMKCWRvbmUKCUVPRgoJZ2l0IHJldi1saXN0IGRvbmUtZW5kcyB8CglnaXQgZGlmZi10cmVlIC1yIC0tc3RkaW4gLS1yb290IC0tYWx3YXlzIHwKCXNlZCAtZSAicy8kX3g0MC9PQkpJRC9nIiA+YWN0dWFsICYmCgl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsCicKCmNhdCA+aW5wdXQgPDxFT0YKb3B0aW9uIGdpdCBub24tZXhpc3Rpbmctb3B0aW9uCkVPRgoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnUjogZGllIG9uIHVua25vd24gb3B0aW9uJyAnCiAgICB0ZXN0X211c3RfZmFpbCBnaXQgZmFzdC1pbXBvcnQgPGlucHV0CicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1I6IHVua25vd24gY29tbWFuZGxpbmUgb3B0aW9ucyBhcmUgcmVqZWN0ZWQnICdcCiAgICB0ZXN0X211c3RfZmFpbCBnaXQgZmFzdC1pbXBvcnQgLS1ub24tZXhpc3Rpbmctb3B0aW9uIDwgL2Rldi9udWxsCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1I6IGRpZSBvbiBpbnZhbGlkIG9wdGlvbiBhcmd1bWVudCcgJwoJZWNobyAib3B0aW9uIGdpdCBhY3RpdmUtYnJhbmNoZXM9LTUiIHwKCXRlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCAmJgoJZWNobyAib3B0aW9uIGdpdCBkZXB0aD0iIHwKCXRlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCAmJgoJdGVzdF9tdXN0X2ZhaWwgZ2l0IGZhc3QtaW1wb3J0IC0tZGVwdGg9IjUgZWxlcGhhbnRzIiA8L2Rldi9udWxsCicKCmNhdCA+aW5wdXQgPDxFT0YKb3B0aW9uIG5vbi1leGlzdGluZy12Y3Mgbm9uLWV4aXN0aW5nLW9wdGlvbgpFT0YKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1I6IGlnbm9yZSBub24tZ2l0IG9wdGlvbnMnICcKICAgIGdpdCBmYXN0LWltcG9ydCA8aW5wdXQKJwoKIyMKIyMgUjogdmVyeSBsYXJnZSBibG9icwojIwpibG9ic2l6ZT0kKCgyKjEwMjQqMTAyNCArIDUzKSkKdGVzdC1nZW5yYW5kb20gYmFyICRibG9ic2l6ZSA+ZXhwZWN0CmNhdCA+aW5wdXQgPDxJTlBVVF9FTkQKY29tbWl0IHJlZnMvaGVhZHMvYmlnLWZpbGUKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgPDxDT01NSVQKUiAtIGJpZyBmaWxlCkNPTU1JVAoKTSA2NDQgaW5saW5lIGJpZzEKZGF0YSAkYmxvYnNpemUKSU5QVVRfRU5ECmNhdCBleHBlY3QgPj5pbnB1dApjYXQgPj5pbnB1dCA8PElOUFVUX0VORApNIDY0NCBpbmxpbmUgYmlnMgpkYXRhICRibG9ic2l6ZQpJTlBVVF9FTkQKY2F0IGV4cGVjdCA+PmlucHV0CmVjaG8gPj5pbnB1dAoKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknUjogYmxvYiBiaWdnZXIgdGhhbiB0aHJlc2hvbGQnIFwKCSd0ZXN0X2NyZWF0ZV9yZXBvIFIgJiYKCSBnaXQgLS1naXQtZGlyPVIvLmdpdCBmYXN0LWltcG9ydCAtLWJpZy1maWxlLXRocmVzaG9sZD0xIDxpbnB1dCcKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1I6IHZlcmlmeSBjcmVhdGVkIHBhY2snICcKCSgKCQljZCBSICYmCgkJdmVyaWZ5X3BhY2tzIC12ID4gLi4vdmVyaWZ5CgkpCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgXAoJJ1I6IHZlcmlmeSB3cml0dGVuIG9iamVjdHMnIFwKCSdnaXQgLS1naXQtZGlyPVIvLmdpdCBjYXQtZmlsZSBibG9iIGJpZy1maWxlOmJpZzEgPmFjdHVhbCAmJgoJIHRlc3RfY21wIGV4cGVjdCBhY3R1YWwgJiYKCSBhPSQoZ2l0IC0tZ2l0LWRpcj1SLy5naXQgcmV2LXBhcnNlIGJpZy1maWxlOmJpZzEpICYmCgkgYj0kKGdpdCAtLWdpdC1kaXI9Ui8uZ2l0IHJldi1wYXJzZSBiaWctZmlsZTpiaWcyKSAmJgoJIHRlc3QgJGEgPSAkYicKdGVzdF9leHBlY3Rfc3VjY2VzcyBcCgknUjogYmxvYiBhcHBlYXJzIG9ubHkgb25jZScgXAoJJ249JChncmVwICRhIHZlcmlmeSB8IHdjIC1sKSAmJgoJIHRlc3QgMSA9ICRuJwoKIyMjCiMjIyBzZXJpZXMgUwojIyMKIwojIE1ha2Ugc3VyZSBtaXNzaW5nIHNwYWNlcyBhbmQgRU9McyBhZnRlciBtYXJrIHJlZmVyZW5jZXMKIyBjYXVzZSBlcnJvcnMuCiMKIyBTZXR1cDoKIwojICAgMS0tMi0tNAojICAgIFwgICAvCiMgICAgIC0zLQojCiMgICBjb21taXQgbWFya3M6ICAzMDEsIDMwMiwgMzAzLCAzMDQKIyAgIGJsb2IgbWFya3M6ICAgICAgICAgICAgICA0MDMsIDQwNCwgcmVzcC4KIyAgIG5vdGUgbWFyazogICAgICAgICAgMjAyCiMKIyBUaGUgZXJyb3IgbWVzc2FnZSB3aGVuIGEgc3BhY2UgaXMgbWlzc2luZyBub3QgYXQgdGhlCiMgZW5kIG9mIHRoZSBsaW5lIGlzOgojCiMgICBNaXNzaW5nIHNwYWNlIGFmdGVyIC4uCiMKIyBvciB3aGVuIGV4dHJhIGNoYXJhY3RlcnMgY29tZSBhZnRlciB0aGUgbWFyayBhdCB0aGUgZW5kCiMgb2YgdGhlIGxpbmU6CiMKIyAgIEdhcmJhZ2UgYWZ0ZXIgLi4KIwojIG9yIHdoZW4gdGhlIGRhdGFyZWYgaXMgbmVpdGhlciAiaW5saW5lICIgb3IgYSBrbm93biBTSEExLAojCiMgICBJbnZhbGlkIGRhdGFyZWYgLi4KIwp0ZXN0X3RpY2sKCmNhdCA+aW5wdXQgPDxJTlBVVF9FTkQKY29tbWl0IHJlZnMvaGVhZHMvUwptYXJrIDozMDEKY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCmRhdGEgPDxDT01NSVQKY29tbWl0IDEKQ09NTUlUCk0gMTAwNjQ0IGlubGluZSBoZWxsby5jCmRhdGEgPDxCTE9CCmJsb2IgMQpCTE9CCgpjb21taXQgcmVmcy9oZWFkcy9TCm1hcmsgOjMwMgpjb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKZGF0YSA8PENPTU1JVApjb21taXQgMgpDT01NSVQKZnJvbSA6MzAxCk0gMTAwNjQ0IGlubGluZSBoZWxsby5jCmRhdGEgPDxCTE9CCmJsb2IgMgpCTE9CCgpibG9iCm1hcmsgOjQwMwpkYXRhIDw8QkxPQgpibG9iIDMKQkxPQgoKYmxvYgptYXJrIDoyMDIKZGF0YSA8PEJMT0IKbm90ZSAyCkJMT0IKSU5QVVRfRU5ECgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdTOiBpbml0aWFsaXplIGZvciBTIHRlc3RzJyAnCglnaXQgZmFzdC1pbXBvcnQgLS1leHBvcnQtbWFya3M9bWFya3MgPGlucHV0CicKCiMKIyBmaWxlbW9kaWZ5LCB0aHJlZSBkYXRhcmVmcwojCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1M6IGZpbGVtb2RpZnkgd2l0aCBnYXJiYWdlIGFmdGVyIG1hcmsgbXVzdCBmYWlsJyAnCgl0ZXN0X211c3RfZmFpbCBnaXQgZmFzdC1pbXBvcnQgLS1pbXBvcnQtbWFya3M9bWFya3MgPDwtRU9GIDI+ZXJyICYmCgljb21taXQgcmVmcy9oZWFkcy9TCgljb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCWRhdGEgPDxDT01NSVQKCWNvbW1pdCBOCglDT01NSVQKCU0gMTAwNjQ0IDo0MDN4IGhlbGxvLmMKCUVPRgoJY2F0IGVyciAmJgoJdGVzdF9pMThuZ3JlcCAic3BhY2UgYWZ0ZXIgbWFyayIgZXJyCicKCiMgaW5saW5lIGlzIG1pc3NwZWxsZWQ7IGZhc3QtaW1wb3J0IHRoaW5rcyBpdCBpcyBzb21lIHVua25vd24gZGF0YXJlZgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdTOiBmaWxlbW9kaWZ5IHdpdGggZ2FyYmFnZSBhZnRlciBpbmxpbmUgbXVzdCBmYWlsJyAnCgl0ZXN0X211c3RfZmFpbCBnaXQgZmFzdC1pbXBvcnQgLS1pbXBvcnQtbWFya3M9bWFya3MgPDwtRU9GIDI+ZXJyICYmCgljb21taXQgcmVmcy9oZWFkcy9TCgljb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCWRhdGEgPDxDT01NSVQKCWNvbW1pdCBOCglDT01NSVQKCU0gMTAwNjQ0IGlubGluZVggaGVsbG8uYwoJZGF0YSA8PEJMT0IKCWlubGluZQoJQkxPQgoJRU9GCgljYXQgZXJyICYmCgl0ZXN0X2kxOG5ncmVwICJudmFsaWQgZGF0YXJlZiIgZXJyCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1M6IGZpbGVtb2RpZnkgd2l0aCBnYXJiYWdlIGFmdGVyIHNoYTEgbXVzdCBmYWlsJyAnCglzaGExPSQoZ3JlcCA6NDAzIG1hcmtzIHwgY3V0IC1kXCAgLWYyKSAmJgoJdGVzdF9tdXN0X2ZhaWwgZ2l0IGZhc3QtaW1wb3J0IC0taW1wb3J0LW1hcmtzPW1hcmtzIDw8LUVPRiAyPmVyciAmJgoJY29tbWl0IHJlZnMvaGVhZHMvUwoJY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCglkYXRhIDw8Q09NTUlUCgljb21taXQgTgoJQ09NTUlUCglNIDEwMDY0NCAke3NoYTF9eCBoZWxsby5jCglFT0YKCWNhdCBlcnIgJiYKCXRlc3RfaTE4bmdyZXAgInNwYWNlIGFmdGVyIFNIQTEiIGVycgonCgojCiMgbm90ZW1vZGlmeSwgdGhyZWUgd2F5cyB0byBzYXkgZGF0YXJlZgojCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1M6IG5vdGVtb2RpZnkgd2l0aCBnYXJhYmdlIGFmdGVyIG1hcmsgZGF0YXJlZiBtdXN0IGZhaWwnICcKCXRlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCAtLWltcG9ydC1tYXJrcz1tYXJrcyA8PC1FT0YgMj5lcnIgJiYKCWNvbW1pdCByZWZzL2hlYWRzL1MKCWNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQoJZGF0YSA8PENPTU1JVAoJY29tbWl0IFMgbm90ZSBkYXRhcmVmIG1hcmtyZWYKCUNPTU1JVAoJTiA6MjAyeCA6MzAyCglFT0YKCWNhdCBlcnIgJiYKCXRlc3RfaTE4bmdyZXAgInNwYWNlIGFmdGVyIG1hcmsiIGVycgonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdTOiBub3RlbW9kaWZ5IHdpdGggZ2FyYmFnZSBhZnRlciBpbmxpbmUgZGF0YXJlZiBtdXN0IGZhaWwnICcKCXRlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCAtLWltcG9ydC1tYXJrcz1tYXJrcyA8PC1FT0YgMj5lcnIgJiYKCWNvbW1pdCByZWZzL2hlYWRzL1MKCWNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQoJZGF0YSA8PENPTU1JVAoJY29tbWl0IFMgbm90ZSBkYXRhcmVmIGlubGluZQoJQ09NTUlUCglOIGlubGluZVggOjMwMgoJZGF0YSA8PEJMT0IKCW5vdGUgYmxvYgoJQkxPQgoJRU9GCgljYXQgZXJyICYmCgl0ZXN0X2kxOG5ncmVwICJudmFsaWQgZGF0YXJlZiIgZXJyCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1M6IG5vdGVtb2RpZnkgd2l0aCBnYXJiYWdlIGFmdGVyIHNoYTEgZGF0YXJlZiBtdXN0IGZhaWwnICcKCXNoYTE9JChncmVwIDoyMDIgbWFya3MgfCBjdXQgLWRcICAtZjIpICYmCgl0ZXN0X211c3RfZmFpbCBnaXQgZmFzdC1pbXBvcnQgLS1pbXBvcnQtbWFya3M9bWFya3MgPDwtRU9GIDI+ZXJyICYmCgljb21taXQgcmVmcy9oZWFkcy9TCgljb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCWRhdGEgPDxDT01NSVQKCWNvbW1pdCBTIG5vdGUgZGF0YXJlZiBzaGExCglDT01NSVQKCU4gJHtzaGExfXggOjMwMgoJRU9GCgljYXQgZXJyICYmCgl0ZXN0X2kxOG5ncmVwICJzcGFjZSBhZnRlciBTSEExIiBlcnIKJwoKIwojIG5vdGVtb2RpZnksIG1hcmsgaW4gY29tbWl0dGlzaAojCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1M6IG5vdGVtb2RpZnkgd2l0aCBnYXJiYXJnZSBhZnRlciBtYXJrIGNvbW1pdHRpc2ggbXVzdCBmYWlsJyAnCgl0ZXN0X211c3RfZmFpbCBnaXQgZmFzdC1pbXBvcnQgLS1pbXBvcnQtbWFya3M9bWFya3MgPDwtRU9GIDI+ZXJyICYmCgljb21taXQgcmVmcy9oZWFkcy9Tbm90ZXMKCWNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQoJZGF0YSA8PENPTU1JVAoJY29tbWl0IFMgbm90ZSBjb21taXR0aXNoCglDT01NSVQKCU4gOjIwMiA6MzAyeAoJRU9GCgljYXQgZXJyICYmCgl0ZXN0X2kxOG5ncmVwICJhZnRlciBtYXJrIiBlcnIKJwoKIwojIGZyb20KIwp0ZXN0X2V4cGVjdF9zdWNjZXNzICdTOiBmcm9tIHdpdGggZ2FyYmFnZSBhZnRlciBtYXJrIG11c3QgZmFpbCcgJwoJIyBubyAmJgoJZ2l0IGZhc3QtaW1wb3J0IC0taW1wb3J0LW1hcmtzPW1hcmtzIC0tZXhwb3J0LW1hcmtzPW1hcmtzIDw8LUVPRiAyPmVycgoJY29tbWl0IHJlZnMvaGVhZHMvUzIKCW1hcmsgOjMwMwoJY29tbWl0dGVyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCglkYXRhIDw8Q09NTUlUCgljb21taXQgMwoJQ09NTUlUCglmcm9tIDozMDF4CglNIDEwMDY0NCA6NDAzIGhlbGxvLmMKCUVPRgoKCXJldD0kPyAmJgoJZWNobyByZXR1cm5lZCAkcmV0ICYmCgl0ZXN0ICRyZXQgLW5lIDAgJiYgIyBmYWlsZWQsIGJ1dCBpdCBjcmVhdGVkIHRoZSBjb21taXQKCgkjIGdvIGNyZWF0ZSB0aGUgY29tbWl0LCBuZWVkIGl0IGZvciBtZXJnZSB0ZXN0CglnaXQgZmFzdC1pbXBvcnQgLS1pbXBvcnQtbWFya3M9bWFya3MgLS1leHBvcnQtbWFya3M9bWFya3MgPDwtRU9GICYmCgljb21taXQgcmVmcy9oZWFkcy9TMgoJbWFyayA6MzAzCgljb21taXR0ZXIgJEdJVF9DT01NSVRURVJfTkFNRSA8JEdJVF9DT01NSVRURVJfRU1BSUw+ICRHSVRfQ09NTUlUVEVSX0RBVEUKCWRhdGEgPDxDT01NSVQKCWNvbW1pdCAzCglDT01NSVQKCWZyb20gOjMwMQoJTSAxMDA2NDQgOjQwMyBoZWxsby5jCglFT0YKCgkjIG5vdyBldmFsdWF0ZSB0aGUgZXJyb3IKCWNhdCBlcnIgJiYKCXRlc3RfaTE4bmdyZXAgImFmdGVyIG1hcmsiIGVycgonCgoKIwojIG1lcmdlCiMKdGVzdF9leHBlY3Rfc3VjY2VzcyAnUzogbWVyZ2Ugd2l0aCBnYXJiYWdlIGFmdGVyIG1hcmsgbXVzdCBmYWlsJyAnCgl0ZXN0X211c3RfZmFpbCBnaXQgZmFzdC1pbXBvcnQgLS1pbXBvcnQtbWFya3M9bWFya3MgPDwtRU9GIDI+ZXJyICYmCgljb21taXQgcmVmcy9oZWFkcy9TCgltYXJrIDozMDQKCWNvbW1pdHRlciAkR0lUX0NPTU1JVFRFUl9OQU1FIDwkR0lUX0NPTU1JVFRFUl9FTUFJTD4gJEdJVF9DT01NSVRURVJfREFURQoJZGF0YSA8PENPTU1JVAoJbWVyZ2UgNAoJQ09NTUlUCglmcm9tIDozMDIKCW1lcmdlIDozMDN4CglNIDEwMDY0NCA6NDAzIGhlbGxvLmMKCUVPRgoJY2F0IGVyciAmJgoJdGVzdF9pMThuZ3JlcCAiYWZ0ZXIgbWFyayIgZXJyCicKCiMKIyB0YWcsIGZyb20gbWFya3JlZgojCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1M6IHRhZyB3aXRoIGdhcmJhZ2UgYWZ0ZXIgbWFyayBtdXN0IGZhaWwnICcKCXRlc3RfbXVzdF9mYWlsIGdpdCBmYXN0LWltcG9ydCAtLWltcG9ydC1tYXJrcz1tYXJrcyA8PC1FT0YgMj5lcnIgJiYKCXRhZyByZWZzL3RhZ3MvU3RhZwoJZnJvbSA6MzAyeAoJdGFnZ2VyICRHSVRfQ09NTUlUVEVSX05BTUUgPCRHSVRfQ09NTUlUVEVSX0VNQUlMPiAkR0lUX0NPTU1JVFRFUl9EQVRFCglkYXRhIDw8VEFHCgl0YWcgUwoJVEFHCglFT0YKCWNhdCBlcnIgJiYKCXRlc3RfaTE4bmdyZXAgImFmdGVyIG1hcmsiIGVycgonCgojCiMgY2F0LWJsb2IgbWFya3JlZgojCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ1M6IGNhdC1ibG9iIHdpdGggZ2FyYmFnZSBhZnRlciBtYXJrIG11c3QgZmFpbCcgJwoJdGVzdF9tdXN0X2ZhaWwgZ2l0IGZhc3QtaW1wb3J0IC0taW1wb3J0LW1hcmtzPW1hcmtzIDw8LUVPRiAyPmVyciAmJgoJY2F0LWJsb2IgOjQwM3gKCUVPRgoJY2F0IGVyciAmJgoJdGVzdF9pMThuZ3JlcCAiYWZ0ZXIgbWFyayIgZXJyCicKCiMKIyBscyBtYXJrcmVmCiMKdGVzdF9leHBlY3Rfc3VjY2VzcyAnUzogbHMgd2l0aCBnYXJiYWdlIGFmdGVyIG1hcmsgbXVzdCBmYWlsJyAnCgl0ZXN0X211c3RfZmFpbCBnaXQgZmFzdC1pbXBvcnQgLS1pbXBvcnQtbWFya3M9bWFya3MgPDwtRU9GIDI+ZXJyICYmCglscyA6MzAyeCBoZWxsby5jCglFT0YKCWNhdCBlcnIgJiYKCXRlc3RfaTE4bmdyZXAgInNwYWNlIGFmdGVyIG1hcmsiIGVycgonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdTOiBscyB3aXRoIGdhcmJhZ2UgYWZ0ZXIgc2hhMSBtdXN0IGZhaWwnICcKCXNoYTE9JChncmVwIDozMDIgbWFya3MgfCBjdXQgLWRcICAtZjIpICYmCgl0ZXN0X211c3RfZmFpbCBnaXQgZmFzdC1pbXBvcnQgLS1pbXBvcnQtbWFya3M9bWFya3MgPDwtRU9GIDI+ZXJyICYmCglscyAke3NoYTF9eCBoZWxsby5jCglFT0YKCWNhdCBlcnIgJiYKCXRlc3RfaTE4bmdyZXAgInNwYWNlIGFmdGVyIHRyZWUtaXNoIiBlcnIKJwoKdGVzdF9kb25lCg==",
    "text": "#!/bin/sh\n#\n# Copyright (c) 2007 Shawn Pearce\n#\n\ntest_description='test git fast-import utility'\n. ./test-lib.sh\n. \"$TEST_DIRECTORY\"/diff-lib.sh ;# test-lib chdir's into trash\n\n# Print $1 bytes from stdin to stdout.\n#\n# This could be written as \"head -c $1\", but IRIX \"head\" does not\n# support the -c option.\nhead_c () {\n\t$PERL_PATH -e '\n\t\tmy $len = $ARGV[1];\n\t\twhile ($len > 0) {\n\t\t\tmy $s;\n\t\t\tmy $nread = sysread(STDIN, $s, $len);\n\t\t\tdie \"cannot read: $!\" unless defined($nread);\n\t\t\tprint $s;\n\t\t\t$len -= $nread;\n\t\t}\n\t' - \"$1\"\n}\n\nverify_packs () {\n\tfor p in .git/objects/pack/*.pack\n\tdo\n\t\tgit verify-pack \"$@\" \"$p\" || return\n\tdone\n}\n\nfile2_data='file2\nsecond line of EOF'\n\nfile3_data='EOF\nin 3rd file\n END'\n\nfile4_data=abcd\nfile4_len=4\n\nfile5_data='an inline file.\n  we should see it later.'\n\nfile6_data='#!/bin/sh\necho \"$@\"'\n\n>empty\n\ntest_expect_success 'setup: have pipes?' '\n\trm -f frob &&\n\tif mkfifo frob\n\tthen\n\t\ttest_set_prereq PIPE\n\tfi\n'\n\n###\n### series A\n###\n\ntest_tick\n\ntest_expect_success 'empty stream succeeds' '\n\tgit fast-import </dev/null\n'\n\ncat >input <<INPUT_END\nblob\nmark :2\ndata <<EOF\n$file2_data\nEOF\n\nblob\nmark :3\ndata <<END\n$file3_data\nEND\n\nblob\nmark :4\ndata $file4_len\n$file4_data\ncommit refs/heads/master\nmark :5\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\ninitial\nCOMMIT\n\nM 644 :2 file2\nM 644 :3 file3\nM 755 :4 file4\n\ntag series-A\nfrom :5\ndata <<EOF\nAn annotated tag without a tagger\nEOF\n\ntag series-A-blob\nfrom :3\ndata <<EOF\nAn annotated tag that annotates a blob.\nEOF\n\nINPUT_END\ntest_expect_success \\\n    'A: create pack from stdin' \\\n    'git fast-import --export-marks=marks.out <input &&\n\t git whatchanged master'\n\ntest_expect_success 'A: verify pack' '\n\tverify_packs\n'\n\ncat >expect <<EOF\nauthor $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\ninitial\nEOF\ntest_expect_success \\\n\t'A: verify commit' \\\n\t'git cat-file commit master | sed 1d >actual &&\n\ttest_cmp expect actual'\n\ncat >expect <<EOF\n100644 blob file2\n100644 blob file3\n100755 blob file4\nEOF\ntest_expect_success \\\n\t'A: verify tree' \\\n\t'git cat-file -p master^{tree} | sed \"s/ [0-9a-f]*\t/ /\" >actual &&\n\t test_cmp expect actual'\n\necho \"$file2_data\" >expect\ntest_expect_success \\\n\t'A: verify file2' \\\n\t'git cat-file blob master:file2 >actual && test_cmp expect actual'\n\necho \"$file3_data\" >expect\ntest_expect_success \\\n\t'A: verify file3' \\\n\t'git cat-file blob master:file3 >actual && test_cmp expect actual'\n\nprintf \"$file4_data\" >expect\ntest_expect_success \\\n\t'A: verify file4' \\\n\t'git cat-file blob master:file4 >actual && test_cmp expect actual'\n\ncat >expect <<EOF\nobject $(git rev-parse refs/heads/master)\ntype commit\ntag series-A\n\nAn annotated tag without a tagger\nEOF\ntest_expect_success 'A: verify tag/series-A' '\n\tgit cat-file tag tags/series-A >actual &&\n\ttest_cmp expect actual\n'\n\ncat >expect <<EOF\nobject $(git rev-parse refs/heads/master:file3)\ntype blob\ntag series-A-blob\n\nAn annotated tag that annotates a blob.\nEOF\ntest_expect_success 'A: verify tag/series-A-blob' '\n\tgit cat-file tag tags/series-A-blob >actual &&\n\ttest_cmp expect actual\n'\n\ncat >expect <<EOF\n:2 `git rev-parse --verify master:file2`\n:3 `git rev-parse --verify master:file3`\n:4 `git rev-parse --verify master:file4`\n:5 `git rev-parse --verify master^0`\nEOF\ntest_expect_success \\\n\t'A: verify marks output' \\\n\t'test_cmp expect marks.out'\n\ntest_expect_success \\\n\t'A: verify marks import' \\\n\t'git fast-import \\\n\t\t--import-marks=marks.out \\\n\t\t--export-marks=marks.new \\\n\t\t</dev/null &&\n\ttest_cmp expect marks.new'\n\ntest_tick\nnew_blob=$(echo testing | git hash-object --stdin)\ncat >input <<INPUT_END\ntag series-A-blob-2\nfrom $(git rev-parse refs/heads/master:file3)\ndata <<EOF\nTag blob by sha1.\nEOF\n\nblob\nmark :6\ndata <<EOF\ntesting\nEOF\n\ncommit refs/heads/new_blob\ncommitter  <> 0 +0000\ndata 0\nM 644 :6 new_blob\n#pretend we got sha1 from fast-import\nls \"new_blob\"\n\ntag series-A-blob-3\nfrom $new_blob\ndata <<EOF\nTag new_blob.\nEOF\nINPUT_END\n\ncat >expect <<EOF\nobject $(git rev-parse refs/heads/master:file3)\ntype blob\ntag series-A-blob-2\n\nTag blob by sha1.\nobject $new_blob\ntype blob\ntag series-A-blob-3\n\nTag new_blob.\nEOF\n\ntest_expect_success \\\n\t'A: tag blob by sha1' \\\n\t'git fast-import <input &&\n\tgit cat-file tag tags/series-A-blob-2 >actual &&\n\tgit cat-file tag tags/series-A-blob-3 >>actual &&\n\ttest_cmp expect actual'\n\ntest_tick\ncat >input <<INPUT_END\ncommit refs/heads/verify--import-marks\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nrecreate from :5\nCOMMIT\n\nfrom :5\nM 755 :2 copy-of-file2\n\nINPUT_END\ntest_expect_success \\\n\t'A: verify marks import does not crash' \\\n\t'git fast-import --import-marks=marks.out <input &&\n\t git whatchanged verify--import-marks'\n\ntest_expect_success 'A: verify pack' '\n\tverify_packs\n'\n\ncat >expect <<EOF\n:000000 100755 0000000000000000000000000000000000000000 7123f7f44e39be127c5eb701e5968176ee9d78b1 A\tcopy-of-file2\nEOF\ngit diff-tree -M -r master verify--import-marks >actual\ntest_expect_success \\\n\t'A: verify diff' \\\n\t'compare_diff_raw expect actual &&\n\t test `git rev-parse --verify master:file2` \\\n\t    = `git rev-parse --verify verify--import-marks:copy-of-file2`'\n\ntest_tick\nmt=$(git hash-object --stdin < /dev/null)\n: >input.blob\n: >marks.exp\n: >tree.exp\n\ncat >input.commit <<EOF\ncommit refs/heads/verify--dump-marks\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\ntest the sparse array dumping routines with exponentially growing marks\nCOMMIT\nEOF\n\ni=0\nl=4\nm=6\nn=7\nwhile test \"$i\" -lt 27; do\n    cat >>input.blob <<EOF\nblob\nmark :$l\ndata 0\nblob\nmark :$m\ndata 0\nblob\nmark :$n\ndata 0\nEOF\n    echo \"M 100644 :$l l$i\" >>input.commit\n    echo \"M 100644 :$m m$i\" >>input.commit\n    echo \"M 100644 :$n n$i\" >>input.commit\n\n    echo \":$l $mt\" >>marks.exp\n    echo \":$m $mt\" >>marks.exp\n    echo \":$n $mt\" >>marks.exp\n\n    printf \"100644 blob $mt\\tl$i\\n\" >>tree.exp\n    printf \"100644 blob $mt\\tm$i\\n\" >>tree.exp\n    printf \"100644 blob $mt\\tn$i\\n\" >>tree.exp\n\n    l=$(($l + $l))\n    m=$(($m + $m))\n    n=$(($l + $n))\n\n    i=$((1 + $i))\ndone\n\nsort tree.exp > tree.exp_s\n\ntest_expect_success 'A: export marks with large values' '\n\tcat input.blob input.commit | git fast-import --export-marks=marks.large &&\n\tgit ls-tree refs/heads/verify--dump-marks >tree.out &&\n\ttest_cmp tree.exp_s tree.out &&\n\ttest_cmp marks.exp marks.large'\n\n###\n### series B\n###\n\ntest_tick\ncat >input <<INPUT_END\ncommit refs/heads/branch\nmark :1\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\ncorrupt\nCOMMIT\n\nfrom refs/heads/master\nM 755 0000000000000000000000000000000000000001 zero1\n\nINPUT_END\ntest_expect_success 'B: fail on invalid blob sha1' '\n    test_must_fail git fast-import <input\n'\nrm -f .git/objects/pack_* .git/objects/index_*\n\ncat >input <<INPUT_END\ncommit .badbranchname\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\ncorrupt\nCOMMIT\n\nfrom refs/heads/master\n\nINPUT_END\ntest_expect_success 'B: fail on invalid branch name \".badbranchname\"' '\n    test_must_fail git fast-import <input\n'\nrm -f .git/objects/pack_* .git/objects/index_*\n\ncat >input <<INPUT_END\ncommit bad[branch]name\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\ncorrupt\nCOMMIT\n\nfrom refs/heads/master\n\nINPUT_END\ntest_expect_success 'B: fail on invalid branch name \"bad[branch]name\"' '\n    test_must_fail git fast-import <input\n'\nrm -f .git/objects/pack_* .git/objects/index_*\n\ncat >input <<INPUT_END\ncommit TEMP_TAG\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\ntag base\nCOMMIT\n\nfrom refs/heads/master\n\nINPUT_END\ntest_expect_success \\\n    'B: accept branch name \"TEMP_TAG\"' \\\n    'git fast-import <input &&\n\t test -f .git/TEMP_TAG &&\n\t test `git rev-parse master` = `git rev-parse TEMP_TAG^`'\nrm -f .git/TEMP_TAG\n\ngit gc 2>/dev/null >/dev/null\ngit prune 2>/dev/null >/dev/null\n\ncat >input <<INPUT_END\ncommit refs/heads/empty-committer-1\ncommitter  <> $GIT_COMMITTER_DATE\ndata <<COMMIT\nempty commit\nCOMMIT\nINPUT_END\ntest_expect_success 'B: accept empty committer' '\n\tgit fast-import <input &&\n\tout=$(git fsck) &&\n\techo \"$out\" &&\n\ttest -z \"$out\"\n'\ngit update-ref -d refs/heads/empty-committer-1 || true\n\ngit gc 2>/dev/null >/dev/null\ngit prune 2>/dev/null >/dev/null\n\ncat >input <<INPUT_END\ncommit refs/heads/empty-committer-2\ncommitter <a@b.com> $GIT_COMMITTER_DATE\ndata <<COMMIT\nempty commit\nCOMMIT\nINPUT_END\ntest_expect_success 'B: accept and fixup committer with no name' '\n\tgit fast-import <input &&\n\tout=$(git fsck) &&\n\techo \"$out\" &&\n\ttest -z \"$out\"\n'\ngit update-ref -d refs/heads/empty-committer-2 || true\n\ngit gc 2>/dev/null >/dev/null\ngit prune 2>/dev/null >/dev/null\n\ncat >input <<INPUT_END\ncommit refs/heads/invalid-committer\ncommitter Name email> $GIT_COMMITTER_DATE\ndata <<COMMIT\nempty commit\nCOMMIT\nINPUT_END\ntest_expect_success 'B: fail on invalid committer (1)' '\n\ttest_must_fail git fast-import <input\n'\ngit update-ref -d refs/heads/invalid-committer || true\n\ncat >input <<INPUT_END\ncommit refs/heads/invalid-committer\ncommitter Name <e<mail> $GIT_COMMITTER_DATE\ndata <<COMMIT\nempty commit\nCOMMIT\nINPUT_END\ntest_expect_success 'B: fail on invalid committer (2)' '\n\ttest_must_fail git fast-import <input\n'\ngit update-ref -d refs/heads/invalid-committer || true\n\ncat >input <<INPUT_END\ncommit refs/heads/invalid-committer\ncommitter Name <email>> $GIT_COMMITTER_DATE\ndata <<COMMIT\nempty commit\nCOMMIT\nINPUT_END\ntest_expect_success 'B: fail on invalid committer (3)' '\n\ttest_must_fail git fast-import <input\n'\ngit update-ref -d refs/heads/invalid-committer || true\n\ncat >input <<INPUT_END\ncommit refs/heads/invalid-committer\ncommitter Name <email $GIT_COMMITTER_DATE\ndata <<COMMIT\nempty commit\nCOMMIT\nINPUT_END\ntest_expect_success 'B: fail on invalid committer (4)' '\n\ttest_must_fail git fast-import <input\n'\ngit update-ref -d refs/heads/invalid-committer || true\n\ncat >input <<INPUT_END\ncommit refs/heads/invalid-committer\ncommitter Name<email> $GIT_COMMITTER_DATE\ndata <<COMMIT\nempty commit\nCOMMIT\nINPUT_END\ntest_expect_success 'B: fail on invalid committer (5)' '\n\ttest_must_fail git fast-import <input\n'\ngit update-ref -d refs/heads/invalid-committer || true\n\n###\n### series C\n###\n\nnewf=`echo hi newf | git hash-object -w --stdin`\noldf=`git rev-parse --verify master:file2`\ntest_tick\ncat >input <<INPUT_END\ncommit refs/heads/branch\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nsecond\nCOMMIT\n\nfrom refs/heads/master\nM 644 $oldf file2/oldf\nM 755 $newf file2/newf\nD file3\n\nINPUT_END\ntest_expect_success \\\n    'C: incremental import create pack from stdin' \\\n    'git fast-import <input &&\n\t git whatchanged branch'\n\ntest_expect_success 'C: verify pack' '\n\tverify_packs\n'\n\ntest_expect_success \\\n\t'C: validate reuse existing blob' \\\n\t'test $newf = `git rev-parse --verify branch:file2/newf` &&\n\t test $oldf = `git rev-parse --verify branch:file2/oldf`'\n\ncat >expect <<EOF\nparent `git rev-parse --verify master^0`\nauthor $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\nsecond\nEOF\ntest_expect_success \\\n\t'C: verify commit' \\\n\t'git cat-file commit branch | sed 1d >actual &&\n\t test_cmp expect actual'\n\ncat >expect <<EOF\n:000000 100755 0000000000000000000000000000000000000000 f1fb5da718392694d0076d677d6d0e364c79b0bc A\tfile2/newf\n:100644 100644 7123f7f44e39be127c5eb701e5968176ee9d78b1 7123f7f44e39be127c5eb701e5968176ee9d78b1 R100\tfile2\tfile2/oldf\n:100644 000000 0d92e9f3374ae2947c23aa477cbc68ce598135f1 0000000000000000000000000000000000000000 D\tfile3\nEOF\ngit diff-tree -M -r master branch >actual\ntest_expect_success \\\n\t'C: validate rename result' \\\n\t'compare_diff_raw expect actual'\n\n###\n### series D\n###\n\ntest_tick\ncat >input <<INPUT_END\ncommit refs/heads/branch\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nthird\nCOMMIT\n\nfrom refs/heads/branch^0\nM 644 inline newdir/interesting\ndata <<EOF\n$file5_data\nEOF\n\nM 755 inline newdir/exec.sh\ndata <<EOF\n$file6_data\nEOF\n\nINPUT_END\ntest_expect_success \\\n    'D: inline data in commit' \\\n    'git fast-import <input &&\n\t git whatchanged branch'\n\ntest_expect_success 'D: verify pack' '\n\tverify_packs\n'\n\ncat >expect <<EOF\n:000000 100755 0000000000000000000000000000000000000000 35a59026a33beac1569b1c7f66f3090ce9c09afc A\tnewdir/exec.sh\n:000000 100644 0000000000000000000000000000000000000000 046d0371e9220107917db0d0e030628de8a1de9b A\tnewdir/interesting\nEOF\ngit diff-tree -M -r branch^ branch >actual\ntest_expect_success \\\n\t'D: validate new files added' \\\n\t'compare_diff_raw expect actual'\n\necho \"$file5_data\" >expect\ntest_expect_success \\\n\t'D: verify file5' \\\n\t'git cat-file blob branch:newdir/interesting >actual &&\n\t test_cmp expect actual'\n\necho \"$file6_data\" >expect\ntest_expect_success \\\n\t'D: verify file6' \\\n\t'git cat-file blob branch:newdir/exec.sh >actual &&\n\t test_cmp expect actual'\n\n###\n### series E\n###\n\ncat >input <<INPUT_END\ncommit refs/heads/branch\nauthor $GIT_AUTHOR_NAME <$GIT_AUTHOR_EMAIL> Tue Feb 6 11:22:18 2007 -0500\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> Tue Feb 6 12:35:02 2007 -0500\ndata <<COMMIT\nRFC 2822 type date\nCOMMIT\n\nfrom refs/heads/branch^0\n\nINPUT_END\ntest_expect_success 'E: rfc2822 date, --date-format=raw' '\n    test_must_fail git fast-import --date-format=raw <input\n'\ntest_expect_success \\\n    'E: rfc2822 date, --date-format=rfc2822' \\\n    'git fast-import --date-format=rfc2822 <input'\n\ntest_expect_success 'E: verify pack' '\n\tverify_packs\n'\n\ncat >expect <<EOF\nauthor $GIT_AUTHOR_NAME <$GIT_AUTHOR_EMAIL> 1170778938 -0500\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> 1170783302 -0500\n\nRFC 2822 type date\nEOF\ntest_expect_success \\\n\t'E: verify commit' \\\n\t'git cat-file commit branch | sed 1,2d >actual &&\n\ttest_cmp expect actual'\n\n###\n### series F\n###\n\nold_branch=`git rev-parse --verify branch^0`\ntest_tick\ncat >input <<INPUT_END\ncommit refs/heads/branch\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nlosing things already?\nCOMMIT\n\nfrom refs/heads/branch~1\n\nreset refs/heads/other\nfrom refs/heads/branch\n\nINPUT_END\ntest_expect_success \\\n    'F: non-fast-forward update skips' \\\n    'if git fast-import <input\n\t then\n\t\techo BAD gfi did not fail\n\t\treturn 1\n\t else\n\t\tif test $old_branch = `git rev-parse --verify branch^0`\n\t\tthen\n\t\t\t: branch unaffected and failure returned\n\t\t\treturn 0\n\t\telse\n\t\t\techo BAD gfi changed branch $old_branch\n\t\t\treturn 1\n\t\tfi\n\t fi\n\t'\n\ntest_expect_success 'F: verify pack' '\n\tverify_packs\n'\n\ncat >expect <<EOF\ntree `git rev-parse branch~1^{tree}`\nparent `git rev-parse branch~1`\nauthor $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\nlosing things already?\nEOF\ntest_expect_success \\\n\t'F: verify other commit' \\\n\t'git cat-file commit other >actual &&\n\ttest_cmp expect actual'\n\n###\n### series G\n###\n\nold_branch=`git rev-parse --verify branch^0`\ntest_tick\ncat >input <<INPUT_END\ncommit refs/heads/branch\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nlosing things already?\nCOMMIT\n\nfrom refs/heads/branch~1\n\nINPUT_END\ntest_expect_success \\\n    'G: non-fast-forward update forced' \\\n    'git fast-import --force <input'\n\ntest_expect_success 'G: verify pack' '\n\tverify_packs\n'\n\ntest_expect_success \\\n\t'G: branch changed, but logged' \\\n\t'test $old_branch != `git rev-parse --verify branch^0` &&\n\t test $old_branch = `git rev-parse --verify branch@{1}`'\n\n###\n### series H\n###\n\ntest_tick\ncat >input <<INPUT_END\ncommit refs/heads/H\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nthird\nCOMMIT\n\nfrom refs/heads/branch^0\nM 644 inline i-will-die\ndata <<EOF\nthis file will never exist.\nEOF\n\ndeleteall\nM 644 inline h/e/l/lo\ndata <<EOF\n$file5_data\nEOF\n\nINPUT_END\ntest_expect_success \\\n    'H: deletall, add 1' \\\n    'git fast-import <input &&\n\t git whatchanged H'\n\ntest_expect_success 'H: verify pack' '\n\tverify_packs\n'\n\ncat >expect <<EOF\n:100755 000000 f1fb5da718392694d0076d677d6d0e364c79b0bc 0000000000000000000000000000000000000000 D\tfile2/newf\n:100644 000000 7123f7f44e39be127c5eb701e5968176ee9d78b1 0000000000000000000000000000000000000000 D\tfile2/oldf\n:100755 000000 85df50785d62d3b05ab03d9cbf7e4a0b49449730 0000000000000000000000000000000000000000 D\tfile4\n:100644 100644 fcf778cda181eaa1cbc9e9ce3a2e15ee9f9fe791 fcf778cda181eaa1cbc9e9ce3a2e15ee9f9fe791 R100\tnewdir/interesting\th/e/l/lo\n:100755 000000 e74b7d465e52746be2b4bae983670711e6e66657 0000000000000000000000000000000000000000 D\tnewdir/exec.sh\nEOF\ngit diff-tree -M -r H^ H >actual\ntest_expect_success \\\n\t'H: validate old files removed, new files added' \\\n\t'compare_diff_raw expect actual'\n\necho \"$file5_data\" >expect\ntest_expect_success \\\n\t'H: verify file' \\\n\t'git cat-file blob H:h/e/l/lo >actual &&\n\t test_cmp expect actual'\n\n###\n### series I\n###\n\ncat >input <<INPUT_END\ncommit refs/heads/export-boundary\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nwe have a border.  its only 40 characters wide.\nCOMMIT\n\nfrom refs/heads/branch\n\nINPUT_END\ntest_expect_success \\\n    'I: export-pack-edges' \\\n    'git fast-import --export-pack-edges=edges.list <input'\n\ncat >expect <<EOF\n.git/objects/pack/pack-.pack: `git rev-parse --verify export-boundary`\nEOF\ntest_expect_success \\\n\t'I: verify edge list' \\\n\t'sed -e s/pack-.*pack/pack-.pack/ edges.list >actual &&\n\t test_cmp expect actual'\n\n###\n### series J\n###\n\ncat >input <<INPUT_END\ncommit refs/heads/J\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\ncreate J\nCOMMIT\n\nfrom refs/heads/branch\n\nreset refs/heads/J\n\ncommit refs/heads/J\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\ninitialize J\nCOMMIT\n\nINPUT_END\ntest_expect_success \\\n    'J: reset existing branch creates empty commit' \\\n    'git fast-import <input'\ntest_expect_success \\\n\t'J: branch has 1 commit, empty tree' \\\n\t'test 1 = `git rev-list J | wc -l` &&\n\t test 0 = `git ls-tree J | wc -l`'\n\ncat >input <<INPUT_END\nreset refs/heads/J2\n\ntag wrong_tag\nfrom refs/heads/J2\ndata <<EOF\nTag branch that was reset.\nEOF\nINPUT_END\ntest_expect_success \\\n\t'J: tag must fail on empty branch' \\\n\t'test_must_fail git fast-import <input'\n###\n### series K\n###\n\ncat >input <<INPUT_END\ncommit refs/heads/K\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\ncreate K\nCOMMIT\n\nfrom refs/heads/branch\n\ncommit refs/heads/K\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nredo K\nCOMMIT\n\nfrom refs/heads/branch^1\n\nINPUT_END\ntest_expect_success \\\n    'K: reinit branch with from' \\\n    'git fast-import <input'\ntest_expect_success \\\n    'K: verify K^1 = branch^1' \\\n    'test `git rev-parse --verify branch^1` \\\n\t\t= `git rev-parse --verify K^1`'\n\n###\n### series L\n###\n\ncat >input <<INPUT_END\nblob\nmark :1\ndata <<EOF\nsome data\nEOF\n\nblob\nmark :2\ndata <<EOF\nother data\nEOF\n\ncommit refs/heads/L\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\ncreate L\nCOMMIT\n\nM 644 :1 b.\nM 644 :1 b/other\nM 644 :1 ba\n\ncommit refs/heads/L\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nupdate L\nCOMMIT\n\nM 644 :2 b.\nM 644 :2 b/other\nM 644 :2 ba\nINPUT_END\n\ncat >expect <<EXPECT_END\n:100644 100644 4268632... 55d3a52... M\tb.\n:040000 040000 0ae5cac... 443c768... M\tb\n:100644 100644 4268632... 55d3a52... M\tba\nEXPECT_END\n\ntest_expect_success \\\n    'L: verify internal tree sorting' \\\n\t'git fast-import <input &&\n\t git diff-tree --abbrev --raw L^ L >output &&\n\t test_cmp expect output'\n\ncat >input <<INPUT_END\nblob\nmark :1\ndata <<EOF\nthe data\nEOF\n\ncommit refs/heads/L2\ncommitter C O Mitter <committer@example.com> 1112912473 -0700\ndata <<COMMIT\ninit L2\nCOMMIT\nM 644 :1 a/b/c\nM 644 :1 a/b/d\nM 644 :1 a/e/f\n\ncommit refs/heads/L2\ncommitter C O Mitter <committer@example.com> 1112912473 -0700\ndata <<COMMIT\nupdate L2\nCOMMIT\nC a g\nC a/e g/b\nM 644 :1 g/b/h\nINPUT_END\n\ncat <<EOF >expect\ng/b/f\ng/b/h\nEOF\n\ntest_expect_success \\\n    'L: nested tree copy does not corrupt deltas' \\\n\t'git fast-import <input &&\n\tgit ls-tree L2 g/b/ >tmp &&\n\tcat tmp | cut -f 2 >actual &&\n\ttest_cmp expect actual &&\n\tgit fsck `git rev-parse L2`'\n\ngit update-ref -d refs/heads/L2\n\n###\n### series M\n###\n\ntest_tick\ncat >input <<INPUT_END\ncommit refs/heads/M1\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nfile rename\nCOMMIT\n\nfrom refs/heads/branch^0\nR file2/newf file2/n.e.w.f\n\nINPUT_END\n\ncat >expect <<EOF\n:100755 100755 f1fb5da718392694d0076d677d6d0e364c79b0bc f1fb5da718392694d0076d677d6d0e364c79b0bc R100\tfile2/newf\tfile2/n.e.w.f\nEOF\ntest_expect_success \\\n\t'M: rename file in same subdirectory' \\\n\t'git fast-import <input &&\n\t git diff-tree -M -r M1^ M1 >actual &&\n\t compare_diff_raw expect actual'\n\ncat >input <<INPUT_END\ncommit refs/heads/M2\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nfile rename\nCOMMIT\n\nfrom refs/heads/branch^0\nR file2/newf i/am/new/to/you\n\nINPUT_END\n\ncat >expect <<EOF\n:100755 100755 f1fb5da718392694d0076d677d6d0e364c79b0bc f1fb5da718392694d0076d677d6d0e364c79b0bc R100\tfile2/newf\ti/am/new/to/you\nEOF\ntest_expect_success \\\n\t'M: rename file to new subdirectory' \\\n\t'git fast-import <input &&\n\t git diff-tree -M -r M2^ M2 >actual &&\n\t compare_diff_raw expect actual'\n\ncat >input <<INPUT_END\ncommit refs/heads/M3\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nfile rename\nCOMMIT\n\nfrom refs/heads/M2^0\nR i other/sub\n\nINPUT_END\n\ncat >expect <<EOF\n:100755 100755 f1fb5da718392694d0076d677d6d0e364c79b0bc f1fb5da718392694d0076d677d6d0e364c79b0bc R100\ti/am/new/to/you\tother/sub/am/new/to/you\nEOF\ntest_expect_success \\\n\t'M: rename subdirectory to new subdirectory' \\\n\t'git fast-import <input &&\n\t git diff-tree -M -r M3^ M3 >actual &&\n\t compare_diff_raw expect actual'\n\n###\n### series N\n###\n\ntest_tick\ncat >input <<INPUT_END\ncommit refs/heads/N1\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nfile copy\nCOMMIT\n\nfrom refs/heads/branch^0\nC file2/newf file2/n.e.w.f\n\nINPUT_END\n\ncat >expect <<EOF\n:100755 100755 f1fb5da718392694d0076d677d6d0e364c79b0bc f1fb5da718392694d0076d677d6d0e364c79b0bc C100\tfile2/newf\tfile2/n.e.w.f\nEOF\ntest_expect_success \\\n\t'N: copy file in same subdirectory' \\\n\t'git fast-import <input &&\n\t git diff-tree -C --find-copies-harder -r N1^ N1 >actual &&\n\t compare_diff_raw expect actual'\n\ncat >input <<INPUT_END\ncommit refs/heads/N2\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nclean directory copy\nCOMMIT\n\nfrom refs/heads/branch^0\nC file2 file3\n\ncommit refs/heads/N2\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nmodify directory copy\nCOMMIT\n\nM 644 inline file3/file5\ndata <<EOF\n$file5_data\nEOF\n\nINPUT_END\n\ncat >expect <<EOF\n:100644 100644 fcf778cda181eaa1cbc9e9ce3a2e15ee9f9fe791 fcf778cda181eaa1cbc9e9ce3a2e15ee9f9fe791 C100\tnewdir/interesting\tfile3/file5\n:100755 100755 f1fb5da718392694d0076d677d6d0e364c79b0bc f1fb5da718392694d0076d677d6d0e364c79b0bc C100\tfile2/newf\tfile3/newf\n:100644 100644 7123f7f44e39be127c5eb701e5968176ee9d78b1 7123f7f44e39be127c5eb701e5968176ee9d78b1 C100\tfile2/oldf\tfile3/oldf\nEOF\ntest_expect_success \\\n\t'N: copy then modify subdirectory' \\\n\t'git fast-import <input &&\n\t git diff-tree -C --find-copies-harder -r N2^^ N2 >actual &&\n\t compare_diff_raw expect actual'\n\ncat >input <<INPUT_END\ncommit refs/heads/N3\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\ndirty directory copy\nCOMMIT\n\nfrom refs/heads/branch^0\nM 644 inline file2/file5\ndata <<EOF\n$file5_data\nEOF\n\nC file2 file3\nD file2/file5\n\nINPUT_END\n\ntest_expect_success \\\n\t'N: copy dirty subdirectory' \\\n\t'git fast-import <input &&\n\t test `git rev-parse N2^{tree}` = `git rev-parse N3^{tree}`'\n\ntest_expect_success \\\n\t'N: copy directory by id' \\\n\t'cat >expect <<-\\EOF &&\n\t:100755 100755 f1fb5da718392694d0076d677d6d0e364c79b0bc f1fb5da718392694d0076d677d6d0e364c79b0bc C100\tfile2/newf\tfile3/newf\n\t:100644 100644 7123f7f44e39be127c5eb701e5968176ee9d78b1 7123f7f44e39be127c5eb701e5968176ee9d78b1 C100\tfile2/oldf\tfile3/oldf\n\tEOF\n\t subdir=$(git rev-parse refs/heads/branch^0:file2) &&\n\t cat >input <<-INPUT_END &&\n\tcommit refs/heads/N4\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcopy by tree hash\n\tCOMMIT\n\n\tfrom refs/heads/branch^0\n\tM 040000 $subdir file3\n\tINPUT_END\n\t git fast-import <input &&\n\t git diff-tree -C --find-copies-harder -r N4^ N4 >actual &&\n\t compare_diff_raw expect actual'\n\ntest_expect_success PIPE 'N: read and copy directory' '\n\tcat >expect <<-\\EOF\n\t:100755 100755 f1fb5da718392694d0076d677d6d0e364c79b0bc f1fb5da718392694d0076d677d6d0e364c79b0bc C100\tfile2/newf\tfile3/newf\n\t:100644 100644 7123f7f44e39be127c5eb701e5968176ee9d78b1 7123f7f44e39be127c5eb701e5968176ee9d78b1 C100\tfile2/oldf\tfile3/oldf\n\tEOF\n\tgit update-ref -d refs/heads/N4 &&\n\trm -f backflow &&\n\tmkfifo backflow &&\n\t(\n\t\texec <backflow &&\n\t\tcat <<-EOF &&\n\t\tcommit refs/heads/N4\n\t\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\t\tdata <<COMMIT\n\t\tcopy by tree hash, part 2\n\t\tCOMMIT\n\n\t\tfrom refs/heads/branch^0\n\t\tls \"file2\"\n\t\tEOF\n\t\tread mode type tree filename &&\n\t\techo \"M 040000 $tree file3\"\n\t) |\n\tgit fast-import --cat-blob-fd=3 3>backflow &&\n\tgit diff-tree -C --find-copies-harder -r N4^ N4 >actual &&\n\tcompare_diff_raw expect actual\n'\n\ntest_expect_success PIPE 'N: empty directory reads as missing' '\n\tcat <<-\\EOF >expect &&\n\tOBJNAME\n\t:000000 100644 OBJNAME OBJNAME A\tunrelated\n\tEOF\n\techo \"missing src\" >expect.response &&\n\tgit update-ref -d refs/heads/read-empty &&\n\trm -f backflow &&\n\tmkfifo backflow &&\n\t(\n\t\texec <backflow &&\n\t\tcat <<-EOF &&\n\t\tcommit refs/heads/read-empty\n\t\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\t\tdata <<COMMIT\n\t\tread \"empty\" (missing) directory\n\t\tCOMMIT\n\n\t\tM 100644 inline src/greeting\n\t\tdata <<BLOB\n\t\thello\n\t\tBLOB\n\t\tC src/greeting dst1/non-greeting\n\t\tC src/greeting unrelated\n\t\t# leave behind \"empty\" src directory\n\t\tD src/greeting\n\t\tls \"src\"\n\t\tEOF\n\t\tread -r line &&\n\t\tprintf \"%s\\n\" \"$line\" >response &&\n\t\tcat <<-\\EOF\n\t\tD dst1\n\t\tD dst2\n\t\tEOF\n\t) |\n\tgit fast-import --cat-blob-fd=3 3>backflow &&\n\ttest_cmp expect.response response &&\n\tgit rev-list read-empty |\n\tgit diff-tree -r --root --stdin |\n\tsed \"s/$_x40/OBJNAME/g\" >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success \\\n\t'N: copy root directory by tree hash' \\\n\t'cat >expect <<-\\EOF &&\n\t:100755 000000 f1fb5da718392694d0076d677d6d0e364c79b0bc 0000000000000000000000000000000000000000 D\tfile3/newf\n\t:100644 000000 7123f7f44e39be127c5eb701e5968176ee9d78b1 0000000000000000000000000000000000000000 D\tfile3/oldf\n\tEOF\n\t root=$(git rev-parse refs/heads/branch^0^{tree}) &&\n\t cat >input <<-INPUT_END &&\n\tcommit refs/heads/N6\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcopy root directory by tree hash\n\tCOMMIT\n\n\tfrom refs/heads/branch^0\n\tM 040000 $root \"\"\n\tINPUT_END\n\t git fast-import <input &&\n\t git diff-tree -C --find-copies-harder -r N4 N6 >actual &&\n\t compare_diff_raw expect actual'\n\ntest_expect_success \\\n\t'N: delete directory by copying' \\\n\t'cat >expect <<-\\EOF &&\n\tOBJID\n\t:100644 000000 OBJID OBJID D\tfoo/bar/qux\n\tOBJID\n\t:000000 100644 OBJID OBJID A\tfoo/bar/baz\n\t:000000 100644 OBJID OBJID A\tfoo/bar/qux\n\tEOF\n\t empty_tree=$(git mktree </dev/null) &&\n\t cat >input <<-INPUT_END &&\n\tcommit refs/heads/N-delete\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcollect data to be deleted\n\tCOMMIT\n\n\tdeleteall\n\tM 100644 inline foo/bar/baz\n\tdata <<DATA_END\n\thello\n\tDATA_END\n\tC \"foo/bar/baz\" \"foo/bar/qux\"\n\tC \"foo/bar/baz\" \"foo/bar/quux/1\"\n\tC \"foo/bar/baz\" \"foo/bar/quuux\"\n\tM 040000 $empty_tree foo/bar/quux\n\tM 040000 $empty_tree foo/bar/quuux\n\n\tcommit refs/heads/N-delete\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tdelete subdirectory\n\tCOMMIT\n\n\tM 040000 $empty_tree foo/bar/qux\n\tINPUT_END\n\t git fast-import <input &&\n\t git rev-list N-delete |\n\t\tgit diff-tree -r --stdin --root --always |\n\t\tsed -e \"s/$_x40/OBJID/g\" >actual &&\n\t test_cmp expect actual'\n\ntest_expect_success \\\n\t'N: modify copied tree' \\\n\t'cat >expect <<-\\EOF &&\n\t:100644 100644 fcf778cda181eaa1cbc9e9ce3a2e15ee9f9fe791 fcf778cda181eaa1cbc9e9ce3a2e15ee9f9fe791 C100\tnewdir/interesting\tfile3/file5\n\t:100755 100755 f1fb5da718392694d0076d677d6d0e364c79b0bc f1fb5da718392694d0076d677d6d0e364c79b0bc C100\tfile2/newf\tfile3/newf\n\t:100644 100644 7123f7f44e39be127c5eb701e5968176ee9d78b1 7123f7f44e39be127c5eb701e5968176ee9d78b1 C100\tfile2/oldf\tfile3/oldf\n\tEOF\n\t subdir=$(git rev-parse refs/heads/branch^0:file2) &&\n\t cat >input <<-INPUT_END &&\n\tcommit refs/heads/N5\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcopy by tree hash\n\tCOMMIT\n\n\tfrom refs/heads/branch^0\n\tM 040000 $subdir file3\n\n\tcommit refs/heads/N5\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tmodify directory copy\n\tCOMMIT\n\n\tM 644 inline file3/file5\n\tdata <<EOF\n\t$file5_data\n\tEOF\n\tINPUT_END\n\t git fast-import <input &&\n\t git diff-tree -C --find-copies-harder -r N5^^ N5 >actual &&\n\t compare_diff_raw expect actual'\n\ntest_expect_success \\\n\t'N: reject foo/ syntax' \\\n\t'subdir=$(git rev-parse refs/heads/branch^0:file2) &&\n\t test_must_fail git fast-import <<-INPUT_END\n\tcommit refs/heads/N5B\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcopy with invalid syntax\n\tCOMMIT\n\n\tfrom refs/heads/branch^0\n\tM 040000 $subdir file3/\n\tINPUT_END'\n\ntest_expect_success \\\n\t'N: reject foo/ syntax in copy source' \\\n\t'test_must_fail git fast-import <<-INPUT_END\n\tcommit refs/heads/N5C\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcopy with invalid syntax\n\tCOMMIT\n\n\tfrom refs/heads/branch^0\n\tC file2/ file3\n\tINPUT_END'\n\ntest_expect_success \\\n\t'N: reject foo/ syntax in rename source' \\\n\t'test_must_fail git fast-import <<-INPUT_END\n\tcommit refs/heads/N5D\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\trename with invalid syntax\n\tCOMMIT\n\n\tfrom refs/heads/branch^0\n\tR file2/ file3\n\tINPUT_END'\n\ntest_expect_success \\\n\t'N: reject foo/ syntax in ls argument' \\\n\t'test_must_fail git fast-import <<-INPUT_END\n\tcommit refs/heads/N5E\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcopy with invalid syntax\n\tCOMMIT\n\n\tfrom refs/heads/branch^0\n\tls \"file2/\"\n\tINPUT_END'\n\ntest_expect_success \\\n\t'N: copy to root by id and modify' \\\n\t'echo \"hello, world\" >expect.foo &&\n\t echo hello >expect.bar &&\n\t git fast-import <<-SETUP_END &&\n\tcommit refs/heads/N7\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\thello, tree\n\tCOMMIT\n\n\tdeleteall\n\tM 644 inline foo/bar\n\tdata <<EOF\n\thello\n\tEOF\n\tSETUP_END\n\n\t tree=$(git rev-parse --verify N7:) &&\n\t git fast-import <<-INPUT_END &&\n\tcommit refs/heads/N8\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcopy to root by id and modify\n\tCOMMIT\n\n\tM 040000 $tree \"\"\n\tM 644 inline foo/foo\n\tdata <<EOF\n\thello, world\n\tEOF\n\tINPUT_END\n\t git show N8:foo/foo >actual.foo &&\n\t git show N8:foo/bar >actual.bar &&\n\t test_cmp expect.foo actual.foo &&\n\t test_cmp expect.bar actual.bar'\n\ntest_expect_success \\\n\t'N: extract subtree' \\\n\t'branch=$(git rev-parse --verify refs/heads/branch^{tree}) &&\n\t cat >input <<-INPUT_END &&\n\tcommit refs/heads/N9\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\textract subtree branch:newdir\n\tCOMMIT\n\n\tM 040000 $branch \"\"\n\tC \"newdir\" \"\"\n\tINPUT_END\n\t git fast-import <input &&\n\t git diff --exit-code branch:newdir N9'\n\ntest_expect_success \\\n\t'N: modify subtree, extract it, and modify again' \\\n\t'echo hello >expect.baz &&\n\t echo hello, world >expect.qux &&\n\t git fast-import <<-SETUP_END &&\n\tcommit refs/heads/N10\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\thello, tree\n\tCOMMIT\n\n\tdeleteall\n\tM 644 inline foo/bar/baz\n\tdata <<EOF\n\thello\n\tEOF\n\tSETUP_END\n\n\t tree=$(git rev-parse --verify N10:) &&\n\t git fast-import <<-INPUT_END &&\n\tcommit refs/heads/N11\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcopy to root by id and modify\n\tCOMMIT\n\n\tM 040000 $tree \"\"\n\tM 100644 inline foo/bar/qux\n\tdata <<EOF\n\thello, world\n\tEOF\n\tR \"foo\" \"\"\n\tC \"bar/qux\" \"bar/quux\"\n\tINPUT_END\n\t git show N11:bar/baz >actual.baz &&\n\t git show N11:bar/qux >actual.qux &&\n\t git show N11:bar/quux >actual.quux &&\n\t test_cmp expect.baz actual.baz &&\n\t test_cmp expect.qux actual.qux &&\n\t test_cmp expect.qux actual.quux'\n\n###\n### series O\n###\n\ncat >input <<INPUT_END\n#we will\ncommit refs/heads/O1\n# -- ignore all of this text\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n# $GIT_COMMITTER_NAME has inserted here for his benefit.\ndata <<COMMIT\ndirty directory copy\nCOMMIT\n\n# don't forget the import blank line!\n#\n# yes, we started from our usual base of branch^0.\n# i like branch^0.\nfrom refs/heads/branch^0\n# and we need to reuse file2/file5 from N3 above.\nM 644 inline file2/file5\n# otherwise the tree will be different\ndata <<EOF\n$file5_data\nEOF\n\n# don't forget to copy file2 to file3\nC file2 file3\n#\n# or to delete file5 from file2.\nD file2/file5\n# are we done yet?\n\nINPUT_END\n\ntest_expect_success \\\n\t'O: comments are all skipped' \\\n\t'git fast-import <input &&\n\t test `git rev-parse N3` = `git rev-parse O1`'\n\ncat >input <<INPUT_END\ncommit refs/heads/O2\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\ndirty directory copy\nCOMMIT\nfrom refs/heads/branch^0\nM 644 inline file2/file5\ndata <<EOF\n$file5_data\nEOF\nC file2 file3\nD file2/file5\n\nINPUT_END\n\ntest_expect_success \\\n\t'O: blank lines not necessary after data commands' \\\n\t'git fast-import <input &&\n\t test `git rev-parse N3` = `git rev-parse O2`'\n\ntest_expect_success \\\n\t'O: repack before next test' \\\n\t'git repack -a -d'\n\ncat >input <<INPUT_END\ncommit refs/heads/O3\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nzstring\nCOMMIT\ncommit refs/heads/O3\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nzof\nCOMMIT\ncheckpoint\ncommit refs/heads/O3\nmark :5\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nzempty\nCOMMIT\ncheckpoint\ncommit refs/heads/O3\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nzcommits\nCOMMIT\nreset refs/tags/O3-2nd\nfrom :5\nreset refs/tags/O3-3rd\nfrom :5\nINPUT_END\n\ncat >expect <<INPUT_END\nstring\nof\nempty\ncommits\nINPUT_END\ntest_expect_success \\\n\t'O: blank lines not necessary after other commands' \\\n\t'git fast-import <input &&\n\t test 8 = `find .git/objects/pack -type f | wc -l` &&\n\t test `git rev-parse refs/tags/O3-2nd` = `git rev-parse O3^` &&\n\t git log --reverse --pretty=oneline O3 | sed s/^.*z// >actual &&\n\t test_cmp expect actual'\n\ncat >input <<INPUT_END\ncommit refs/heads/O4\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nzstring\nCOMMIT\ncommit refs/heads/O4\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nzof\nCOMMIT\nprogress Two commits down, 2 to go!\ncommit refs/heads/O4\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nzempty\nCOMMIT\nprogress Three commits down, 1 to go!\ncommit refs/heads/O4\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nzcommits\nCOMMIT\nprogress I'm done!\nINPUT_END\ntest_expect_success \\\n\t'O: progress outputs as requested by input' \\\n\t'git fast-import <input >actual &&\n\t grep \"progress \" <input >expect &&\n\t test_cmp expect actual'\n\n###\n### series P (gitlinks)\n###\n\ncat >input <<INPUT_END\nblob\nmark :1\ndata 10\ntest file\n\nreset refs/heads/sub\ncommit refs/heads/sub\nmark :2\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata 12\nsub_initial\nM 100644 :1 file\n\nblob\nmark :3\ndata <<DATAEND\n[submodule \"sub\"]\n\tpath = sub\n\turl = \"`pwd`/sub\"\nDATAEND\n\ncommit refs/heads/subuse1\nmark :4\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata 8\ninitial\nfrom refs/heads/master\nM 100644 :3 .gitmodules\nM 160000 :2 sub\n\nblob\nmark :5\ndata 20\ntest file\nmore data\n\ncommit refs/heads/sub\nmark :6\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata 11\nsub_second\nfrom :2\nM 100644 :5 file\n\ncommit refs/heads/subuse1\nmark :7\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata 7\nsecond\nfrom :4\nM 160000 :6 sub\n\nINPUT_END\n\ntest_expect_success \\\n\t'P: superproject & submodule mix' \\\n\t'git fast-import <input &&\n\t git checkout subuse1 &&\n\t rm -rf sub && mkdir sub && (cd sub &&\n\t git init &&\n\t git fetch --update-head-ok .. refs/heads/sub:refs/heads/master &&\n\t git checkout master) &&\n\t git submodule init &&\n\t git submodule update'\n\nSUBLAST=$(git rev-parse --verify sub)\nSUBPREV=$(git rev-parse --verify sub^)\n\ncat >input <<INPUT_END\nblob\nmark :1\ndata <<DATAEND\n[submodule \"sub\"]\n\tpath = sub\n\turl = \"`pwd`/sub\"\nDATAEND\n\ncommit refs/heads/subuse2\nmark :2\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata 8\ninitial\nfrom refs/heads/master\nM 100644 :1 .gitmodules\nM 160000 $SUBPREV sub\n\ncommit refs/heads/subuse2\nmark :3\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata 7\nsecond\nfrom :2\nM 160000 $SUBLAST sub\n\nINPUT_END\n\ntest_expect_success \\\n\t'P: verbatim SHA gitlinks' \\\n\t'git branch -D sub &&\n\t git gc && git prune &&\n\t git fast-import <input &&\n\t test $(git rev-parse --verify subuse2) = $(git rev-parse --verify subuse1)'\n\ntest_tick\ncat >input <<INPUT_END\ncommit refs/heads/subuse3\nmark :1\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\ncorrupt\nCOMMIT\n\nfrom refs/heads/subuse2\nM 160000 inline sub\ndata <<DATA\n$SUBPREV\nDATA\n\nINPUT_END\n\ntest_expect_success 'P: fail on inline gitlink' '\n    test_must_fail git fast-import <input'\n\ntest_tick\ncat >input <<INPUT_END\nblob\nmark :1\ndata <<DATA\n$SUBPREV\nDATA\n\ncommit refs/heads/subuse3\nmark :2\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\ncorrupt\nCOMMIT\n\nfrom refs/heads/subuse2\nM 160000 :1 sub\n\nINPUT_END\n\ntest_expect_success 'P: fail on blob mark in gitlink' '\n    test_must_fail git fast-import <input'\n\n###\n### series Q (notes)\n###\n\nnote1_data=\"The first note for the first commit\"\nnote2_data=\"The first note for the second commit\"\nnote3_data=\"The first note for the third commit\"\nnote1b_data=\"The second note for the first commit\"\nnote1c_data=\"The third note for the first commit\"\nnote2b_data=\"The second note for the second commit\"\n\ntest_tick\ncat >input <<INPUT_END\nblob\nmark :2\ndata <<EOF\n$file2_data\nEOF\n\ncommit refs/heads/notes-test\nmark :3\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nfirst (:3)\nCOMMIT\n\nM 644 :2 file2\n\nblob\nmark :4\ndata $file4_len\n$file4_data\ncommit refs/heads/notes-test\nmark :5\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nsecond (:5)\nCOMMIT\n\nM 644 :4 file4\n\ncommit refs/heads/notes-test\nmark :6\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nthird (:6)\nCOMMIT\n\nM 644 inline file5\ndata <<EOF\n$file5_data\nEOF\n\nM 755 inline file6\ndata <<EOF\n$file6_data\nEOF\n\nblob\nmark :7\ndata <<EOF\n$note1_data\nEOF\n\nblob\nmark :8\ndata <<EOF\n$note2_data\nEOF\n\ncommit refs/notes/foobar\nmark :9\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nnotes (:9)\nCOMMIT\n\nN :7 :3\nN :8 :5\nN inline :6\ndata <<EOF\n$note3_data\nEOF\n\ncommit refs/notes/foobar\nmark :10\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nnotes (:10)\nCOMMIT\n\nN inline :3\ndata <<EOF\n$note1b_data\nEOF\n\ncommit refs/notes/foobar2\nmark :11\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nnotes (:11)\nCOMMIT\n\nN inline :3\ndata <<EOF\n$note1c_data\nEOF\n\ncommit refs/notes/foobar\nmark :12\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nnotes (:12)\nCOMMIT\n\ndeleteall\nN inline :5\ndata <<EOF\n$note2b_data\nEOF\n\nINPUT_END\n\ntest_expect_success \\\n\t'Q: commit notes' \\\n\t'git fast-import <input &&\n\t git whatchanged notes-test'\n\ntest_expect_success 'Q: verify pack' '\n\tverify_packs\n'\n\ncommit1=$(git rev-parse notes-test~2)\ncommit2=$(git rev-parse notes-test^)\ncommit3=$(git rev-parse notes-test)\n\ncat >expect <<EOF\nauthor $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\nfirst (:3)\nEOF\ntest_expect_success \\\n\t'Q: verify first commit' \\\n\t'git cat-file commit notes-test~2 | sed 1d >actual &&\n\ttest_cmp expect actual'\n\ncat >expect <<EOF\nparent $commit1\nauthor $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\nsecond (:5)\nEOF\ntest_expect_success \\\n\t'Q: verify second commit' \\\n\t'git cat-file commit notes-test^ | sed 1d >actual &&\n\ttest_cmp expect actual'\n\ncat >expect <<EOF\nparent $commit2\nauthor $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\nthird (:6)\nEOF\ntest_expect_success \\\n\t'Q: verify third commit' \\\n\t'git cat-file commit notes-test | sed 1d >actual &&\n\ttest_cmp expect actual'\n\ncat >expect <<EOF\nauthor $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\nnotes (:9)\nEOF\ntest_expect_success \\\n\t'Q: verify first notes commit' \\\n\t'git cat-file commit refs/notes/foobar~2 | sed 1d >actual &&\n\ttest_cmp expect actual'\n\ncat >expect.unsorted <<EOF\n100644 blob $commit1\n100644 blob $commit2\n100644 blob $commit3\nEOF\ncat expect.unsorted | sort >expect\ntest_expect_success \\\n\t'Q: verify first notes tree' \\\n\t'git cat-file -p refs/notes/foobar~2^{tree} | sed \"s/ [0-9a-f]*\t/ /\" >actual &&\n\t test_cmp expect actual'\n\necho \"$note1_data\" >expect\ntest_expect_success \\\n\t'Q: verify first note for first commit' \\\n\t'git cat-file blob refs/notes/foobar~2:$commit1 >actual && test_cmp expect actual'\n\necho \"$note2_data\" >expect\ntest_expect_success \\\n\t'Q: verify first note for second commit' \\\n\t'git cat-file blob refs/notes/foobar~2:$commit2 >actual && test_cmp expect actual'\n\necho \"$note3_data\" >expect\ntest_expect_success \\\n\t'Q: verify first note for third commit' \\\n\t'git cat-file blob refs/notes/foobar~2:$commit3 >actual && test_cmp expect actual'\n\ncat >expect <<EOF\nparent `git rev-parse --verify refs/notes/foobar~2`\nauthor $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\nnotes (:10)\nEOF\ntest_expect_success \\\n\t'Q: verify second notes commit' \\\n\t'git cat-file commit refs/notes/foobar^ | sed 1d >actual &&\n\ttest_cmp expect actual'\n\ncat >expect.unsorted <<EOF\n100644 blob $commit1\n100644 blob $commit2\n100644 blob $commit3\nEOF\ncat expect.unsorted | sort >expect\ntest_expect_success \\\n\t'Q: verify second notes tree' \\\n\t'git cat-file -p refs/notes/foobar^^{tree} | sed \"s/ [0-9a-f]*\t/ /\" >actual &&\n\t test_cmp expect actual'\n\necho \"$note1b_data\" >expect\ntest_expect_success \\\n\t'Q: verify second note for first commit' \\\n\t'git cat-file blob refs/notes/foobar^:$commit1 >actual && test_cmp expect actual'\n\necho \"$note2_data\" >expect\ntest_expect_success \\\n\t'Q: verify first note for second commit' \\\n\t'git cat-file blob refs/notes/foobar^:$commit2 >actual && test_cmp expect actual'\n\necho \"$note3_data\" >expect\ntest_expect_success \\\n\t'Q: verify first note for third commit' \\\n\t'git cat-file blob refs/notes/foobar^:$commit3 >actual && test_cmp expect actual'\n\ncat >expect <<EOF\nauthor $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\nnotes (:11)\nEOF\ntest_expect_success \\\n\t'Q: verify third notes commit' \\\n\t'git cat-file commit refs/notes/foobar2 | sed 1d >actual &&\n\ttest_cmp expect actual'\n\ncat >expect.unsorted <<EOF\n100644 blob $commit1\nEOF\ncat expect.unsorted | sort >expect\ntest_expect_success \\\n\t'Q: verify third notes tree' \\\n\t'git cat-file -p refs/notes/foobar2^{tree} | sed \"s/ [0-9a-f]*\t/ /\" >actual &&\n\t test_cmp expect actual'\n\necho \"$note1c_data\" >expect\ntest_expect_success \\\n\t'Q: verify third note for first commit' \\\n\t'git cat-file blob refs/notes/foobar2:$commit1 >actual && test_cmp expect actual'\n\ncat >expect <<EOF\nparent `git rev-parse --verify refs/notes/foobar^`\nauthor $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\nnotes (:12)\nEOF\ntest_expect_success \\\n\t'Q: verify fourth notes commit' \\\n\t'git cat-file commit refs/notes/foobar | sed 1d >actual &&\n\ttest_cmp expect actual'\n\ncat >expect.unsorted <<EOF\n100644 blob $commit2\nEOF\ncat expect.unsorted | sort >expect\ntest_expect_success \\\n\t'Q: verify fourth notes tree' \\\n\t'git cat-file -p refs/notes/foobar^{tree} | sed \"s/ [0-9a-f]*\t/ /\" >actual &&\n\t test_cmp expect actual'\n\necho \"$note2b_data\" >expect\ntest_expect_success \\\n\t'Q: verify second note for second commit' \\\n\t'git cat-file blob refs/notes/foobar:$commit2 >actual && test_cmp expect actual'\n\ncat >input <<EOF\nreset refs/heads/Q0\n\ncommit refs/heads/note-Q0\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nNote for an empty branch.\nCOMMIT\n\nN inline refs/heads/Q0\ndata <<NOTE\nsome note\nNOTE\nEOF\ntest_expect_success \\\n\t'Q: deny note on empty branch' \\\n\t'test_must_fail git fast-import <input'\n###\n### series R (feature and option)\n###\n\ncat >input <<EOF\nfeature no-such-feature-exists\nEOF\n\ntest_expect_success 'R: abort on unsupported feature' '\n\ttest_must_fail git fast-import <input\n'\n\ncat >input <<EOF\nfeature date-format=now\nEOF\n\ntest_expect_success 'R: supported feature is accepted' '\n\tgit fast-import <input\n'\n\ncat >input << EOF\nblob\ndata 3\nhi\nfeature date-format=now\nEOF\n\ntest_expect_success 'R: abort on receiving feature after data command' '\n\ttest_must_fail git fast-import <input\n'\n\ncat >input << EOF\nfeature import-marks=git.marks\nfeature import-marks=git2.marks\nEOF\n\ntest_expect_success 'R: only one import-marks feature allowed per stream' '\n\ttest_must_fail git fast-import <input\n'\n\ncat >input << EOF\nfeature export-marks=git.marks\nblob\nmark :1\ndata 3\nhi\n\nEOF\n\ntest_expect_success \\\n    'R: export-marks feature results in a marks file being created' \\\n    'cat input | git fast-import &&\n    grep :1 git.marks'\n\ntest_expect_success \\\n    'R: export-marks options can be overriden by commandline options' \\\n    'cat input | git fast-import --export-marks=other.marks &&\n    grep :1 other.marks'\n\ntest_expect_success 'R: catch typo in marks file name' '\n\ttest_must_fail git fast-import --import-marks=nonexistent.marks </dev/null &&\n\techo \"feature import-marks=nonexistent.marks\" |\n\ttest_must_fail git fast-import\n'\n\ntest_expect_success 'R: import and output marks can be the same file' '\n\trm -f io.marks &&\n\tblob=$(echo hi | git hash-object --stdin) &&\n\tcat >expect <<-EOF &&\n\t:1 $blob\n\t:2 $blob\n\tEOF\n\tgit fast-import --export-marks=io.marks <<-\\EOF &&\n\tblob\n\tmark :1\n\tdata 3\n\thi\n\n\tEOF\n\tgit fast-import --import-marks=io.marks --export-marks=io.marks <<-\\EOF &&\n\tblob\n\tmark :2\n\tdata 3\n\thi\n\n\tEOF\n\ttest_cmp expect io.marks\n'\n\ntest_expect_success 'R: --import-marks=foo --output-marks=foo to create foo fails' '\n\trm -f io.marks &&\n\ttest_must_fail git fast-import --import-marks=io.marks --export-marks=io.marks <<-\\EOF\n\tblob\n\tmark :1\n\tdata 3\n\thi\n\n\tEOF\n'\n\ntest_expect_success 'R: --import-marks-if-exists' '\n\trm -f io.marks &&\n\tblob=$(echo hi | git hash-object --stdin) &&\n\techo \":1 $blob\" >expect &&\n\tgit fast-import --import-marks-if-exists=io.marks --export-marks=io.marks <<-\\EOF &&\n\tblob\n\tmark :1\n\tdata 3\n\thi\n\n\tEOF\n\ttest_cmp expect io.marks\n'\n\ntest_expect_success 'R: feature import-marks-if-exists' '\n\trm -f io.marks &&\n\t>expect &&\n\n\tgit fast-import --export-marks=io.marks <<-\\EOF &&\n\tfeature import-marks-if-exists=not_io.marks\n\tEOF\n\ttest_cmp expect io.marks &&\n\n\tblob=$(echo hi | git hash-object --stdin) &&\n\n\techo \":1 $blob\" >io.marks &&\n\techo \":1 $blob\" >expect &&\n\techo \":2 $blob\" >>expect &&\n\n\tgit fast-import --export-marks=io.marks <<-\\EOF &&\n\tfeature import-marks-if-exists=io.marks\n\tblob\n\tmark :2\n\tdata 3\n\thi\n\n\tEOF\n\ttest_cmp expect io.marks &&\n\n\techo \":3 $blob\" >>expect &&\n\n\tgit fast-import --import-marks=io.marks \\\n\t\t\t--export-marks=io.marks <<-\\EOF &&\n\tfeature import-marks-if-exists=not_io.marks\n\tblob\n\tmark :3\n\tdata 3\n\thi\n\n\tEOF\n\ttest_cmp expect io.marks &&\n\n\t>expect &&\n\n\tgit fast-import --import-marks-if-exists=not_io.marks \\\n\t\t\t--export-marks=io.marks <<-\\EOF\n\tfeature import-marks-if-exists=io.marks\n\tEOF\n\ttest_cmp expect io.marks\n'\n\ncat >input << EOF\nfeature import-marks=marks.out\nfeature export-marks=marks.new\nEOF\n\ntest_expect_success \\\n    'R: import to output marks works without any content' \\\n    'cat input | git fast-import &&\n    test_cmp marks.out marks.new'\n\ncat >input <<EOF\nfeature import-marks=nonexistent.marks\nfeature export-marks=marks.new\nEOF\n\ntest_expect_success \\\n    'R: import marks prefers commandline marks file over the stream' \\\n    'cat input | git fast-import --import-marks=marks.out &&\n    test_cmp marks.out marks.new'\n\n\ncat >input <<EOF\nfeature import-marks=nonexistent.marks\nfeature export-marks=combined.marks\nEOF\n\ntest_expect_success 'R: multiple --import-marks= should be honoured' '\n    head -n2 marks.out > one.marks &&\n    tail -n +3 marks.out > two.marks &&\n    git fast-import --import-marks=one.marks --import-marks=two.marks <input &&\n    test_cmp marks.out combined.marks\n'\n\ncat >input <<EOF\nfeature relative-marks\nfeature import-marks=relative.in\nfeature export-marks=relative.out\nEOF\n\ntest_expect_success 'R: feature relative-marks should be honoured' '\n    mkdir -p .git/info/fast-import/ &&\n    cp marks.new .git/info/fast-import/relative.in &&\n    git fast-import <input &&\n    test_cmp marks.new .git/info/fast-import/relative.out\n'\n\ncat >input <<EOF\nfeature relative-marks\nfeature import-marks=relative.in\nfeature no-relative-marks\nfeature export-marks=non-relative.out\nEOF\n\ntest_expect_success 'R: feature no-relative-marks should be honoured' '\n    git fast-import <input &&\n    test_cmp marks.new non-relative.out\n'\n\ntest_expect_success 'R: feature ls supported' '\n\techo \"feature ls\" |\n\tgit fast-import\n'\n\ntest_expect_success 'R: feature cat-blob supported' '\n\techo \"feature cat-blob\" |\n\tgit fast-import\n'\n\ntest_expect_success 'R: cat-blob-fd must be a nonnegative integer' '\n\ttest_must_fail git fast-import --cat-blob-fd=-1 </dev/null\n'\n\ntest_expect_success NOT_MINGW 'R: print old blob' '\n\tblob=$(echo \"yes it can\" | git hash-object -w --stdin) &&\n\tcat >expect <<-EOF &&\n\t${blob} blob 11\n\tyes it can\n\n\tEOF\n\techo \"cat-blob $blob\" |\n\tgit fast-import --cat-blob-fd=6 6>actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success NOT_MINGW 'R: in-stream cat-blob-fd not respected' '\n\techo hello >greeting &&\n\tblob=$(git hash-object -w greeting) &&\n\tcat >expect <<-EOF &&\n\t${blob} blob 6\n\thello\n\n\tEOF\n\tgit fast-import --cat-blob-fd=3 3>actual.3 >actual.1 <<-EOF &&\n\tcat-blob $blob\n\tEOF\n\ttest_cmp expect actual.3 &&\n\ttest_cmp empty actual.1 &&\n\tgit fast-import 3>actual.3 >actual.1 <<-EOF &&\n\toption cat-blob-fd=3\n\tcat-blob $blob\n\tEOF\n\ttest_cmp empty actual.3 &&\n\ttest_cmp expect actual.1\n'\n\ntest_expect_success NOT_MINGW 'R: print new blob' '\n\tblob=$(echo \"yep yep yep\" | git hash-object --stdin) &&\n\tcat >expect <<-EOF &&\n\t${blob} blob 12\n\tyep yep yep\n\n\tEOF\n\tgit fast-import --cat-blob-fd=6 6>actual <<-\\EOF &&\n\tblob\n\tmark :1\n\tdata <<BLOB_END\n\tyep yep yep\n\tBLOB_END\n\tcat-blob :1\n\tEOF\n\ttest_cmp expect actual\n'\n\ntest_expect_success NOT_MINGW 'R: print new blob by sha1' '\n\tblob=$(echo \"a new blob named by sha1\" | git hash-object --stdin) &&\n\tcat >expect <<-EOF &&\n\t${blob} blob 25\n\ta new blob named by sha1\n\n\tEOF\n\tgit fast-import --cat-blob-fd=6 6>actual <<-EOF &&\n\tblob\n\tdata <<BLOB_END\n\ta new blob named by sha1\n\tBLOB_END\n\tcat-blob $blob\n\tEOF\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'setup: big file' '\n\t(\n\t\techo \"the quick brown fox jumps over the lazy dog\" >big &&\n\t\tfor i in 1 2 3\n\t\tdo\n\t\t\tcat big big big big >bigger &&\n\t\t\tcat bigger bigger bigger bigger >big ||\n\t\t\texit\n\t\tdone\n\t)\n'\n\ntest_expect_success 'R: print two blobs to stdout' '\n\tblob1=$(git hash-object big) &&\n\tblob1_len=$(wc -c <big) &&\n\tblob2=$(echo hello | git hash-object --stdin) &&\n\t{\n\t\techo ${blob1} blob $blob1_len &&\n\t\tcat big &&\n\t\tcat <<-EOF\n\n\t\t${blob2} blob 6\n\t\thello\n\n\t\tEOF\n\t} >expect &&\n\t{\n\t\tcat <<-\\END_PART1 &&\n\t\t\tblob\n\t\t\tmark :1\n\t\t\tdata <<data_end\n\t\tEND_PART1\n\t\tcat big &&\n\t\tcat <<-\\EOF\n\t\t\tdata_end\n\t\t\tblob\n\t\t\tmark :2\n\t\t\tdata <<data_end\n\t\t\thello\n\t\t\tdata_end\n\t\t\tcat-blob :1\n\t\t\tcat-blob :2\n\t\tEOF\n\t} |\n\tgit fast-import >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success PIPE 'R: copy using cat-file' '\n\texpect_id=$(git hash-object big) &&\n\texpect_len=$(wc -c <big) &&\n\techo $expect_id blob $expect_len >expect.response &&\n\n\trm -f blobs &&\n\tcat >frontend <<-\\FRONTEND_END &&\n\t#!/bin/sh\n\tFRONTEND_END\n\n\tmkfifo blobs &&\n\t(\n\t\texport GIT_COMMITTER_NAME GIT_COMMITTER_EMAIL GIT_COMMITTER_DATE &&\n\t\tcat <<-\\EOF &&\n\t\tfeature cat-blob\n\t\tblob\n\t\tmark :1\n\t\tdata <<BLOB\n\t\tEOF\n\t\tcat big &&\n\t\tcat <<-\\EOF &&\n\t\tBLOB\n\t\tcat-blob :1\n\t\tEOF\n\n\t\tread blob_id type size <&3 &&\n\t\techo \"$blob_id $type $size\" >response &&\n\t\thead_c $size >blob <&3 &&\n\t\tread newline <&3 &&\n\n\t\tcat <<-EOF &&\n\t\tcommit refs/heads/copied\n\t\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\t\tdata <<COMMIT\n\t\tcopy big file as file3\n\t\tCOMMIT\n\t\tM 644 inline file3\n\t\tdata <<BLOB\n\t\tEOF\n\t\tcat blob &&\n\t\techo BLOB\n\t) 3<blobs |\n\tgit fast-import --cat-blob-fd=3 3>blobs &&\n\tgit show copied:file3 >actual &&\n\ttest_cmp expect.response response &&\n\ttest_cmp big actual\n'\n\ntest_expect_success PIPE 'R: print blob mid-commit' '\n\trm -f blobs &&\n\techo \"A blob from _before_ the commit.\" >expect &&\n\tmkfifo blobs &&\n\t(\n\t\texec 3<blobs &&\n\t\tcat <<-EOF &&\n\t\tfeature cat-blob\n\t\tblob\n\t\tmark :1\n\t\tdata <<BLOB\n\t\tA blob from _before_ the commit.\n\t\tBLOB\n\t\tcommit refs/heads/temporary\n\t\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\t\tdata <<COMMIT\n\t\tEmpty commit\n\t\tCOMMIT\n\t\tcat-blob :1\n\t\tEOF\n\n\t\tread blob_id type size <&3 &&\n\t\thead_c $size >actual <&3 &&\n\t\tread newline <&3 &&\n\n\t\techo\n\t) |\n\tgit fast-import --cat-blob-fd=3 3>blobs &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success PIPE 'R: print staged blob within commit' '\n\trm -f blobs &&\n\techo \"A blob from _within_ the commit.\" >expect &&\n\tmkfifo blobs &&\n\t(\n\t\texec 3<blobs &&\n\t\tcat <<-EOF &&\n\t\tfeature cat-blob\n\t\tcommit refs/heads/within\n\t\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\t\tdata <<COMMIT\n\t\tEmpty commit\n\t\tCOMMIT\n\t\tM 644 inline within\n\t\tdata <<BLOB\n\t\tA blob from _within_ the commit.\n\t\tBLOB\n\t\tEOF\n\n\t\tto_get=$(\n\t\t\techo \"A blob from _within_ the commit.\" |\n\t\t\tgit hash-object --stdin\n\t\t) &&\n\t\techo \"cat-blob $to_get\" &&\n\n\t\tread blob_id type size <&3 &&\n\t\thead_c $size >actual <&3 &&\n\t\tread newline <&3 &&\n\n\t\techo deleteall\n\t) |\n\tgit fast-import --cat-blob-fd=3 3>blobs &&\n\ttest_cmp expect actual\n'\n\ncat >input << EOF\noption git quiet\nblob\ndata 3\nhi\n\nEOF\n\ntest_expect_success 'R: quiet option results in no stats being output' '\n    cat input | git fast-import 2> output &&\n    test_cmp empty output\n'\n\ntest_expect_success 'R: feature done means terminating \"done\" is mandatory' '\n\techo feature done | test_must_fail git fast-import &&\n\ttest_must_fail git fast-import --done </dev/null\n'\n\ntest_expect_success 'R: terminating \"done\" with trailing gibberish is ok' '\n\tgit fast-import <<-\\EOF &&\n\tfeature done\n\tdone\n\ttrailing gibberish\n\tEOF\n\tgit fast-import <<-\\EOF\n\tdone\n\tmore trailing gibberish\n\tEOF\n'\n\ntest_expect_success 'R: terminating \"done\" within commit' '\n\tcat >expect <<-\\EOF &&\n\tOBJID\n\t:000000 100644 OBJID OBJID A\thello.c\n\t:000000 100644 OBJID OBJID A\thello2.c\n\tEOF\n\tgit fast-import <<-EOF &&\n\tcommit refs/heads/done-ends\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<EOT\n\tCommit terminated by \"done\" command\n\tEOT\n\tM 100644 inline hello.c\n\tdata <<EOT\n\tHello, world.\n\tEOT\n\tC hello.c hello2.c\n\tdone\n\tEOF\n\tgit rev-list done-ends |\n\tgit diff-tree -r --stdin --root --always |\n\tsed -e \"s/$_x40/OBJID/g\" >actual &&\n\ttest_cmp expect actual\n'\n\ncat >input <<EOF\noption git non-existing-option\nEOF\n\ntest_expect_success 'R: die on unknown option' '\n    test_must_fail git fast-import <input\n'\n\ntest_expect_success 'R: unknown commandline options are rejected' '\\\n    test_must_fail git fast-import --non-existing-option < /dev/null\n'\n\ntest_expect_success 'R: die on invalid option argument' '\n\techo \"option git active-branches=-5\" |\n\ttest_must_fail git fast-import &&\n\techo \"option git depth=\" |\n\ttest_must_fail git fast-import &&\n\ttest_must_fail git fast-import --depth=\"5 elephants\" </dev/null\n'\n\ncat >input <<EOF\noption non-existing-vcs non-existing-option\nEOF\n\ntest_expect_success 'R: ignore non-git options' '\n    git fast-import <input\n'\n\n##\n## R: very large blobs\n##\nblobsize=$((2*1024*1024 + 53))\ntest-genrandom bar $blobsize >expect\ncat >input <<INPUT_END\ncommit refs/heads/big-file\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\nR - big file\nCOMMIT\n\nM 644 inline big1\ndata $blobsize\nINPUT_END\ncat expect >>input\ncat >>input <<INPUT_END\nM 644 inline big2\ndata $blobsize\nINPUT_END\ncat expect >>input\necho >>input\n\ntest_expect_success \\\n\t'R: blob bigger than threshold' \\\n\t'test_create_repo R &&\n\t git --git-dir=R/.git fast-import --big-file-threshold=1 <input'\n\ntest_expect_success 'R: verify created pack' '\n\t(\n\t\tcd R &&\n\t\tverify_packs -v > ../verify\n\t)\n'\n\ntest_expect_success \\\n\t'R: verify written objects' \\\n\t'git --git-dir=R/.git cat-file blob big-file:big1 >actual &&\n\t test_cmp expect actual &&\n\t a=$(git --git-dir=R/.git rev-parse big-file:big1) &&\n\t b=$(git --git-dir=R/.git rev-parse big-file:big2) &&\n\t test $a = $b'\ntest_expect_success \\\n\t'R: blob appears only once' \\\n\t'n=$(grep $a verify | wc -l) &&\n\t test 1 = $n'\n\n###\n### series S\n###\n#\n# Make sure missing spaces and EOLs after mark references\n# cause errors.\n#\n# Setup:\n#\n#   1--2--4\n#    \\   /\n#     -3-\n#\n#   commit marks:  301, 302, 303, 304\n#   blob marks:              403, 404, resp.\n#   note mark:          202\n#\n# The error message when a space is missing not at the\n# end of the line is:\n#\n#   Missing space after ..\n#\n# or when extra characters come after the mark at the end\n# of the line:\n#\n#   Garbage after ..\n#\n# or when the dataref is neither \"inline \" or a known SHA1,\n#\n#   Invalid dataref ..\n#\ntest_tick\n\ncat >input <<INPUT_END\ncommit refs/heads/S\nmark :301\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\ncommit 1\nCOMMIT\nM 100644 inline hello.c\ndata <<BLOB\nblob 1\nBLOB\n\ncommit refs/heads/S\nmark :302\ncommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\ndata <<COMMIT\ncommit 2\nCOMMIT\nfrom :301\nM 100644 inline hello.c\ndata <<BLOB\nblob 2\nBLOB\n\nblob\nmark :403\ndata <<BLOB\nblob 3\nBLOB\n\nblob\nmark :202\ndata <<BLOB\nnote 2\nBLOB\nINPUT_END\n\ntest_expect_success 'S: initialize for S tests' '\n\tgit fast-import --export-marks=marks <input\n'\n\n#\n# filemodify, three datarefs\n#\ntest_expect_success 'S: filemodify with garbage after mark must fail' '\n\ttest_must_fail git fast-import --import-marks=marks <<-EOF 2>err &&\n\tcommit refs/heads/S\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcommit N\n\tCOMMIT\n\tM 100644 :403x hello.c\n\tEOF\n\tcat err &&\n\ttest_i18ngrep \"space after mark\" err\n'\n\n# inline is misspelled; fast-import thinks it is some unknown dataref\ntest_expect_success 'S: filemodify with garbage after inline must fail' '\n\ttest_must_fail git fast-import --import-marks=marks <<-EOF 2>err &&\n\tcommit refs/heads/S\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcommit N\n\tCOMMIT\n\tM 100644 inlineX hello.c\n\tdata <<BLOB\n\tinline\n\tBLOB\n\tEOF\n\tcat err &&\n\ttest_i18ngrep \"nvalid dataref\" err\n'\n\ntest_expect_success 'S: filemodify with garbage after sha1 must fail' '\n\tsha1=$(grep :403 marks | cut -d\\  -f2) &&\n\ttest_must_fail git fast-import --import-marks=marks <<-EOF 2>err &&\n\tcommit refs/heads/S\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcommit N\n\tCOMMIT\n\tM 100644 ${sha1}x hello.c\n\tEOF\n\tcat err &&\n\ttest_i18ngrep \"space after SHA1\" err\n'\n\n#\n# notemodify, three ways to say dataref\n#\ntest_expect_success 'S: notemodify with garabge after mark dataref must fail' '\n\ttest_must_fail git fast-import --import-marks=marks <<-EOF 2>err &&\n\tcommit refs/heads/S\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcommit S note dataref markref\n\tCOMMIT\n\tN :202x :302\n\tEOF\n\tcat err &&\n\ttest_i18ngrep \"space after mark\" err\n'\n\ntest_expect_success 'S: notemodify with garbage after inline dataref must fail' '\n\ttest_must_fail git fast-import --import-marks=marks <<-EOF 2>err &&\n\tcommit refs/heads/S\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcommit S note dataref inline\n\tCOMMIT\n\tN inlineX :302\n\tdata <<BLOB\n\tnote blob\n\tBLOB\n\tEOF\n\tcat err &&\n\ttest_i18ngrep \"nvalid dataref\" err\n'\n\ntest_expect_success 'S: notemodify with garbage after sha1 dataref must fail' '\n\tsha1=$(grep :202 marks | cut -d\\  -f2) &&\n\ttest_must_fail git fast-import --import-marks=marks <<-EOF 2>err &&\n\tcommit refs/heads/S\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcommit S note dataref sha1\n\tCOMMIT\n\tN ${sha1}x :302\n\tEOF\n\tcat err &&\n\ttest_i18ngrep \"space after SHA1\" err\n'\n\n#\n# notemodify, mark in committish\n#\ntest_expect_success 'S: notemodify with garbarge after mark committish must fail' '\n\ttest_must_fail git fast-import --import-marks=marks <<-EOF 2>err &&\n\tcommit refs/heads/Snotes\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcommit S note committish\n\tCOMMIT\n\tN :202 :302x\n\tEOF\n\tcat err &&\n\ttest_i18ngrep \"after mark\" err\n'\n\n#\n# from\n#\ntest_expect_success 'S: from with garbage after mark must fail' '\n\t# no &&\n\tgit fast-import --import-marks=marks --export-marks=marks <<-EOF 2>err\n\tcommit refs/heads/S2\n\tmark :303\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcommit 3\n\tCOMMIT\n\tfrom :301x\n\tM 100644 :403 hello.c\n\tEOF\n\n\tret=$? &&\n\techo returned $ret &&\n\ttest $ret -ne 0 && # failed, but it created the commit\n\n\t# go create the commit, need it for merge test\n\tgit fast-import --import-marks=marks --export-marks=marks <<-EOF &&\n\tcommit refs/heads/S2\n\tmark :303\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tcommit 3\n\tCOMMIT\n\tfrom :301\n\tM 100644 :403 hello.c\n\tEOF\n\n\t# now evaluate the error\n\tcat err &&\n\ttest_i18ngrep \"after mark\" err\n'\n\n\n#\n# merge\n#\ntest_expect_success 'S: merge with garbage after mark must fail' '\n\ttest_must_fail git fast-import --import-marks=marks <<-EOF 2>err &&\n\tcommit refs/heads/S\n\tmark :304\n\tcommitter $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<COMMIT\n\tmerge 4\n\tCOMMIT\n\tfrom :302\n\tmerge :303x\n\tM 100644 :403 hello.c\n\tEOF\n\tcat err &&\n\ttest_i18ngrep \"after mark\" err\n'\n\n#\n# tag, from markref\n#\ntest_expect_success 'S: tag with garbage after mark must fail' '\n\ttest_must_fail git fast-import --import-marks=marks <<-EOF 2>err &&\n\ttag refs/tags/Stag\n\tfrom :302x\n\ttagger $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE\n\tdata <<TAG\n\ttag S\n\tTAG\n\tEOF\n\tcat err &&\n\ttest_i18ngrep \"after mark\" err\n'\n\n#\n# cat-blob markref\n#\ntest_expect_success 'S: cat-blob with garbage after mark must fail' '\n\ttest_must_fail git fast-import --import-marks=marks <<-EOF 2>err &&\n\tcat-blob :403x\n\tEOF\n\tcat err &&\n\ttest_i18ngrep \"after mark\" err\n'\n\n#\n# ls markref\n#\ntest_expect_success 'S: ls with garbage after mark must fail' '\n\ttest_must_fail git fast-import --import-marks=marks <<-EOF 2>err &&\n\tls :302x hello.c\n\tEOF\n\tcat err &&\n\ttest_i18ngrep \"space after mark\" err\n'\n\ntest_expect_success 'S: ls with garbage after sha1 must fail' '\n\tsha1=$(grep :302 marks | cut -d\\  -f2) &&\n\ttest_must_fail git fast-import --import-marks=marks <<-EOF 2>err &&\n\tls ${sha1}x hello.c\n\tEOF\n\tcat err &&\n\ttest_i18ngrep \"space after tree-ish\" err\n'\n\ntest_done\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "007e5af5f469664c89d2006fdc55a5fa85946582",
  "sha1_ok": true,
  "size": 64729
}
