{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgInJlbW90ZS5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAicmVmc3BlYy5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJkaWZmLmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgInN0cmluZy1saXN0LmgiCiNpbmNsdWRlICJtZXJnZXNvcnQuaCIKI2luY2x1ZGUgImFyZ3YtYXJyYXkuaCIKCmVudW0gbWFwX2RpcmVjdGlvbiB7IEZST01fU1JDLCBGUk9NX0RTVCB9OwoKc3RydWN0IGNvdW50ZWRfc3RyaW5nIHsKCXNpemVfdCBsZW47Cgljb25zdCBjaGFyICpzOwp9OwpzdHJ1Y3QgcmV3cml0ZSB7Cgljb25zdCBjaGFyICpiYXNlOwoJc2l6ZV90IGJhc2VsZW47CglzdHJ1Y3QgY291bnRlZF9zdHJpbmcgKmluc3RlYWRfb2Y7CglpbnQgaW5zdGVhZF9vZl9ucjsKCWludCBpbnN0ZWFkX29mX2FsbG9jOwp9OwpzdHJ1Y3QgcmV3cml0ZXMgewoJc3RydWN0IHJld3JpdGUgKipyZXdyaXRlOwoJaW50IHJld3JpdGVfYWxsb2M7CglpbnQgcmV3cml0ZV9ucjsKfTsKCnN0YXRpYyBzdHJ1Y3QgcmVtb3RlICoqcmVtb3RlczsKc3RhdGljIGludCByZW1vdGVzX2FsbG9jOwpzdGF0aWMgaW50IHJlbW90ZXNfbnI7CnN0YXRpYyBzdHJ1Y3QgaGFzaG1hcCByZW1vdGVzX2hhc2g7CgpzdGF0aWMgc3RydWN0IGJyYW5jaCAqKmJyYW5jaGVzOwpzdGF0aWMgaW50IGJyYW5jaGVzX2FsbG9jOwpzdGF0aWMgaW50IGJyYW5jaGVzX25yOwoKc3RhdGljIHN0cnVjdCBicmFuY2ggKmN1cnJlbnRfYnJhbmNoOwpzdGF0aWMgY29uc3QgY2hhciAqcHVzaHJlbW90ZV9uYW1lOwoKc3RhdGljIHN0cnVjdCByZXdyaXRlcyByZXdyaXRlczsKc3RhdGljIHN0cnVjdCByZXdyaXRlcyByZXdyaXRlc19wdXNoOwoKc3RhdGljIGludCB2YWxpZF9yZW1vdGUoY29uc3Qgc3RydWN0IHJlbW90ZSAqcmVtb3RlKQp7CglyZXR1cm4gKCEhcmVtb3RlLT51cmwpIHx8ICghIXJlbW90ZS0+Zm9yZWlnbl92Y3MpOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqYWxpYXNfdXJsKGNvbnN0IGNoYXIgKnVybCwgc3RydWN0IHJld3JpdGVzICpyKQp7CglpbnQgaSwgajsKCXN0cnVjdCBjb3VudGVkX3N0cmluZyAqbG9uZ2VzdDsKCWludCBsb25nZXN0X2k7CgoJbG9uZ2VzdCA9IE5VTEw7Cglsb25nZXN0X2kgPSAtMTsKCWZvciAoaSA9IDA7IGkgPCByLT5yZXdyaXRlX25yOyBpKyspIHsKCQlpZiAoIXItPnJld3JpdGVbaV0pCgkJCWNvbnRpbnVlOwoJCWZvciAoaiA9IDA7IGogPCByLT5yZXdyaXRlW2ldLT5pbnN0ZWFkX29mX25yOyBqKyspIHsKCQkJaWYgKHN0YXJ0c193aXRoKHVybCwgci0+cmV3cml0ZVtpXS0+aW5zdGVhZF9vZltqXS5zKSAmJgoJCQkgICAgKCFsb25nZXN0IHx8CgkJCSAgICAgbG9uZ2VzdC0+bGVuIDwgci0+cmV3cml0ZVtpXS0+aW5zdGVhZF9vZltqXS5sZW4pKSB7CgkJCQlsb25nZXN0ID0gJihyLT5yZXdyaXRlW2ldLT5pbnN0ZWFkX29mW2pdKTsKCQkJCWxvbmdlc3RfaSA9IGk7CgkJCX0KCQl9Cgl9CglpZiAoIWxvbmdlc3QpCgkJcmV0dXJuIHVybDsKCglyZXR1cm4geHN0cmZtdCgiJXMlcyIsIHItPnJld3JpdGVbbG9uZ2VzdF9pXS0+YmFzZSwgdXJsICsgbG9uZ2VzdC0+bGVuKTsKfQoKc3RhdGljIHZvaWQgYWRkX3VybChzdHJ1Y3QgcmVtb3RlICpyZW1vdGUsIGNvbnN0IGNoYXIgKnVybCkKewoJQUxMT0NfR1JPVyhyZW1vdGUtPnVybCwgcmVtb3RlLT51cmxfbnIgKyAxLCByZW1vdGUtPnVybF9hbGxvYyk7CglyZW1vdGUtPnVybFtyZW1vdGUtPnVybF9ucisrXSA9IHVybDsKfQoKc3RhdGljIHZvaWQgYWRkX3B1c2h1cmwoc3RydWN0IHJlbW90ZSAqcmVtb3RlLCBjb25zdCBjaGFyICpwdXNodXJsKQp7CglBTExPQ19HUk9XKHJlbW90ZS0+cHVzaHVybCwgcmVtb3RlLT5wdXNodXJsX25yICsgMSwgcmVtb3RlLT5wdXNodXJsX2FsbG9jKTsKCXJlbW90ZS0+cHVzaHVybFtyZW1vdGUtPnB1c2h1cmxfbnIrK10gPSBwdXNodXJsOwp9CgpzdGF0aWMgdm9pZCBhZGRfcHVzaHVybF9hbGlhcyhzdHJ1Y3QgcmVtb3RlICpyZW1vdGUsIGNvbnN0IGNoYXIgKnVybCkKewoJY29uc3QgY2hhciAqcHVzaHVybCA9IGFsaWFzX3VybCh1cmwsICZyZXdyaXRlc19wdXNoKTsKCWlmIChwdXNodXJsICE9IHVybCkKCQlhZGRfcHVzaHVybChyZW1vdGUsIHB1c2h1cmwpOwp9CgpzdGF0aWMgdm9pZCBhZGRfdXJsX2FsaWFzKHN0cnVjdCByZW1vdGUgKnJlbW90ZSwgY29uc3QgY2hhciAqdXJsKQp7CglhZGRfdXJsKHJlbW90ZSwgYWxpYXNfdXJsKHVybCwgJnJld3JpdGVzKSk7CglhZGRfcHVzaHVybF9hbGlhcyhyZW1vdGUsIHVybCk7Cn0KCnN0cnVjdCByZW1vdGVzX2hhc2hfa2V5IHsKCWNvbnN0IGNoYXIgKnN0cjsKCWludCBsZW47Cn07CgpzdGF0aWMgaW50IHJlbW90ZXNfaGFzaF9jbXAoY29uc3Qgdm9pZCAqdW51c2VkX2NtcF9kYXRhLAoJCQkgICAgY29uc3Qgdm9pZCAqZW50cnksCgkJCSAgICBjb25zdCB2b2lkICplbnRyeV9vcl9rZXksCgkJCSAgICBjb25zdCB2b2lkICprZXlkYXRhKQp7Cgljb25zdCBzdHJ1Y3QgcmVtb3RlICphID0gZW50cnk7Cgljb25zdCBzdHJ1Y3QgcmVtb3RlICpiID0gZW50cnlfb3Jfa2V5OwoJY29uc3Qgc3RydWN0IHJlbW90ZXNfaGFzaF9rZXkgKmtleSA9IGtleWRhdGE7CgoJaWYgKGtleSkKCQlyZXR1cm4gc3RybmNtcChhLT5uYW1lLCBrZXktPnN0ciwga2V5LT5sZW4pIHx8IGEtPm5hbWVba2V5LT5sZW5dOwoJZWxzZQoJCXJldHVybiBzdHJjbXAoYS0+bmFtZSwgYi0+bmFtZSk7Cn0KCnN0YXRpYyBpbmxpbmUgdm9pZCBpbml0X3JlbW90ZXNfaGFzaCh2b2lkKQp7CglpZiAoIXJlbW90ZXNfaGFzaC5jbXBmbikKCQloYXNobWFwX2luaXQoJnJlbW90ZXNfaGFzaCwgcmVtb3Rlc19oYXNoX2NtcCwgTlVMTCwgMCk7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVtb3RlICptYWtlX3JlbW90ZShjb25zdCBjaGFyICpuYW1lLCBpbnQgbGVuKQp7CglzdHJ1Y3QgcmVtb3RlICpyZXQsICpyZXBsYWNlZDsKCXN0cnVjdCByZW1vdGVzX2hhc2hfa2V5IGxvb2t1cDsKCXN0cnVjdCBoYXNobWFwX2VudHJ5IGxvb2t1cF9lbnRyeTsKCglpZiAoIWxlbikKCQlsZW4gPSBzdHJsZW4obmFtZSk7CgoJaW5pdF9yZW1vdGVzX2hhc2goKTsKCWxvb2t1cC5zdHIgPSBuYW1lOwoJbG9va3VwLmxlbiA9IGxlbjsKCWhhc2htYXBfZW50cnlfaW5pdCgmbG9va3VwX2VudHJ5LCBtZW1oYXNoKG5hbWUsIGxlbikpOwoKCWlmICgocmV0ID0gaGFzaG1hcF9nZXQoJnJlbW90ZXNfaGFzaCwgJmxvb2t1cF9lbnRyeSwgJmxvb2t1cCkpICE9IE5VTEwpCgkJcmV0dXJuIHJldDsKCglyZXQgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3QgcmVtb3RlKSk7CglyZXQtPnBydW5lID0gLTE7ICAvKiB1bnNwZWNpZmllZCAqLwoJcmV0LT5wcnVuZV90YWdzID0gLTE7ICAvKiB1bnNwZWNpZmllZCAqLwoJcmV0LT5uYW1lID0geHN0cm5kdXAobmFtZSwgbGVuKTsKCXJlZnNwZWNfaW5pdCgmcmV0LT5wdXNoLCBSRUZTUEVDX1BVU0gpOwoJcmVmc3BlY19pbml0KCZyZXQtPmZldGNoLCBSRUZTUEVDX0ZFVENIKTsKCglBTExPQ19HUk9XKHJlbW90ZXMsIHJlbW90ZXNfbnIgKyAxLCByZW1vdGVzX2FsbG9jKTsKCXJlbW90ZXNbcmVtb3Rlc19ucisrXSA9IHJldDsKCgloYXNobWFwX2VudHJ5X2luaXQocmV0LCBsb29rdXBfZW50cnkuaGFzaCk7CglyZXBsYWNlZCA9IGhhc2htYXBfcHV0KCZyZW1vdGVzX2hhc2gsIHJldCk7Cglhc3NlcnQocmVwbGFjZWQgPT0gTlVMTCk7ICAvKiBubyBwcmV2aW91cyBlbnRyeSBvdmVyd3JpdHRlbiAqLwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIHZvaWQgYWRkX21lcmdlKHN0cnVjdCBicmFuY2ggKmJyYW5jaCwgY29uc3QgY2hhciAqbmFtZSkKewoJQUxMT0NfR1JPVyhicmFuY2gtPm1lcmdlX25hbWUsIGJyYW5jaC0+bWVyZ2VfbnIgKyAxLAoJCSAgIGJyYW5jaC0+bWVyZ2VfYWxsb2MpOwoJYnJhbmNoLT5tZXJnZV9uYW1lW2JyYW5jaC0+bWVyZ2VfbnIrK10gPSBuYW1lOwp9CgpzdGF0aWMgc3RydWN0IGJyYW5jaCAqbWFrZV9icmFuY2goY29uc3QgY2hhciAqbmFtZSwgaW50IGxlbikKewoJc3RydWN0IGJyYW5jaCAqcmV0OwoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IGJyYW5jaGVzX25yOyBpKyspIHsKCQlpZiAobGVuID8gKCFzdHJuY21wKG5hbWUsIGJyYW5jaGVzW2ldLT5uYW1lLCBsZW4pICYmCgkJCSAgICFicmFuY2hlc1tpXS0+bmFtZVtsZW5dKSA6CgkJICAgICFzdHJjbXAobmFtZSwgYnJhbmNoZXNbaV0tPm5hbWUpKQoJCQlyZXR1cm4gYnJhbmNoZXNbaV07Cgl9CgoJQUxMT0NfR1JPVyhicmFuY2hlcywgYnJhbmNoZXNfbnIgKyAxLCBicmFuY2hlc19hbGxvYyk7CglyZXQgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3QgYnJhbmNoKSk7CglicmFuY2hlc1ticmFuY2hlc19ucisrXSA9IHJldDsKCWlmIChsZW4pCgkJcmV0LT5uYW1lID0geHN0cm5kdXAobmFtZSwgbGVuKTsKCWVsc2UKCQlyZXQtPm5hbWUgPSB4c3RyZHVwKG5hbWUpOwoJcmV0LT5yZWZuYW1lID0geHN0cmZtdCgicmVmcy9oZWFkcy8lcyIsIHJldC0+bmFtZSk7CgoJcmV0dXJuIHJldDsKfQoKc3RhdGljIHN0cnVjdCByZXdyaXRlICptYWtlX3Jld3JpdGUoc3RydWN0IHJld3JpdGVzICpyLCBjb25zdCBjaGFyICpiYXNlLCBpbnQgbGVuKQp7CglzdHJ1Y3QgcmV3cml0ZSAqcmV0OwoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IHItPnJld3JpdGVfbnI7IGkrKykgewoJCWlmIChsZW4KCQkgICAgPyAobGVuID09IHItPnJld3JpdGVbaV0tPmJhc2VsZW4gJiYKCQkgICAgICAgIXN0cm5jbXAoYmFzZSwgci0+cmV3cml0ZVtpXS0+YmFzZSwgbGVuKSkKCQkgICAgOiAhc3RyY21wKGJhc2UsIHItPnJld3JpdGVbaV0tPmJhc2UpKQoJCQlyZXR1cm4gci0+cmV3cml0ZVtpXTsKCX0KCglBTExPQ19HUk9XKHItPnJld3JpdGUsIHItPnJld3JpdGVfbnIgKyAxLCByLT5yZXdyaXRlX2FsbG9jKTsKCXJldCA9IHhjYWxsb2MoMSwgc2l6ZW9mKHN0cnVjdCByZXdyaXRlKSk7CglyLT5yZXdyaXRlW3ItPnJld3JpdGVfbnIrK10gPSByZXQ7CglpZiAobGVuKSB7CgkJcmV0LT5iYXNlID0geHN0cm5kdXAoYmFzZSwgbGVuKTsKCQlyZXQtPmJhc2VsZW4gPSBsZW47Cgl9CgllbHNlIHsKCQlyZXQtPmJhc2UgPSB4c3RyZHVwKGJhc2UpOwoJCXJldC0+YmFzZWxlbiA9IHN0cmxlbihiYXNlKTsKCX0KCXJldHVybiByZXQ7Cn0KCnN0YXRpYyB2b2lkIGFkZF9pbnN0ZWFkX29mKHN0cnVjdCByZXdyaXRlICpyZXdyaXRlLCBjb25zdCBjaGFyICppbnN0ZWFkX29mKQp7CglBTExPQ19HUk9XKHJld3JpdGUtPmluc3RlYWRfb2YsIHJld3JpdGUtPmluc3RlYWRfb2ZfbnIgKyAxLCByZXdyaXRlLT5pbnN0ZWFkX29mX2FsbG9jKTsKCXJld3JpdGUtPmluc3RlYWRfb2ZbcmV3cml0ZS0+aW5zdGVhZF9vZl9ucl0ucyA9IGluc3RlYWRfb2Y7CglyZXdyaXRlLT5pbnN0ZWFkX29mW3Jld3JpdGUtPmluc3RlYWRfb2ZfbnJdLmxlbiA9IHN0cmxlbihpbnN0ZWFkX29mKTsKCXJld3JpdGUtPmluc3RlYWRfb2ZfbnIrKzsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnNraXBfc3BhY2VzKGNvbnN0IGNoYXIgKnMpCnsKCXdoaWxlIChpc3NwYWNlKCpzKSkKCQlzKys7CglyZXR1cm4gczsKfQoKc3RhdGljIHZvaWQgcmVhZF9yZW1vdGVzX2ZpbGUoc3RydWN0IHJlbW90ZSAqcmVtb3RlKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJRklMRSAqZiA9IGZvcGVuX29yX3dhcm4oZ2l0X3BhdGgoInJlbW90ZXMvJXMiLCByZW1vdGUtPm5hbWUpLCAiciIpOwoKCWlmICghZikKCQlyZXR1cm47CglyZW1vdGUtPmNvbmZpZ3VyZWRfaW5fcmVwbyA9IDE7CglyZW1vdGUtPm9yaWdpbiA9IFJFTU9URV9SRU1PVEVTOwoJd2hpbGUgKHN0cmJ1Zl9nZXRsaW5lKCZidWYsIGYpICE9IEVPRikgewoJCWNvbnN0IGNoYXIgKnY7CgoJCXN0cmJ1Zl9ydHJpbSgmYnVmKTsKCgkJaWYgKHNraXBfcHJlZml4KGJ1Zi5idWYsICJVUkw6IiwgJnYpKQoJCQlhZGRfdXJsX2FsaWFzKHJlbW90ZSwgeHN0cmR1cChza2lwX3NwYWNlcyh2KSkpOwoJCWVsc2UgaWYgKHNraXBfcHJlZml4KGJ1Zi5idWYsICJQdXNoOiIsICZ2KSkKCQkJcmVmc3BlY19hcHBlbmQoJnJlbW90ZS0+cHVzaCwgc2tpcF9zcGFjZXModikpOwoJCWVsc2UgaWYgKHNraXBfcHJlZml4KGJ1Zi5idWYsICJQdWxsOiIsICZ2KSkKCQkJcmVmc3BlY19hcHBlbmQoJnJlbW90ZS0+ZmV0Y2gsIHNraXBfc3BhY2VzKHYpKTsKCX0KCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJZmNsb3NlKGYpOwp9CgpzdGF0aWMgdm9pZCByZWFkX2JyYW5jaGVzX2ZpbGUoc3RydWN0IHJlbW90ZSAqcmVtb3RlKQp7CgljaGFyICpmcmFnOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCUZJTEUgKmYgPSBmb3Blbl9vcl93YXJuKGdpdF9wYXRoKCJicmFuY2hlcy8lcyIsIHJlbW90ZS0+bmFtZSksICJyIik7CgoJaWYgKCFmKQoJCXJldHVybjsKCglzdHJidWZfZ2V0bGluZV9sZigmYnVmLCBmKTsKCWZjbG9zZShmKTsKCXN0cmJ1Zl90cmltKCZidWYpOwoJaWYgKCFidWYubGVuKSB7CgkJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CgkJcmV0dXJuOwoJfQoKCXJlbW90ZS0+Y29uZmlndXJlZF9pbl9yZXBvID0gMTsKCXJlbW90ZS0+b3JpZ2luID0gUkVNT1RFX0JSQU5DSEVTOwoKCS8qCgkgKiBUaGUgYnJhbmNoZXMgZmlsZSB3b3VsZCBoYXZlIFVSTCBhbmQgb3B0aW9uYWxseQoJICogI2JyYW5jaCBzcGVjaWZpZWQuICBUaGUgIm1hc3RlciIgKG9yIHNwZWNpZmllZCkgYnJhbmNoIGlzCgkgKiBmZXRjaGVkIGFuZCBzdG9yZWQgaW4gdGhlIGxvY2FsIGJyYW5jaCBtYXRjaGluZyB0aGUKCSAqIHJlbW90ZSBuYW1lLgoJICovCglmcmFnID0gc3RyY2hyKGJ1Zi5idWYsICcjJyk7CglpZiAoZnJhZykKCQkqKGZyYWcrKykgPSAnXDAnOwoJZWxzZQoJCWZyYWcgPSAibWFzdGVyIjsKCglhZGRfdXJsX2FsaWFzKHJlbW90ZSwgc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKSk7CglzdHJidWZfYWRkZigmYnVmLCAicmVmcy9oZWFkcy8lczpyZWZzL2hlYWRzLyVzIiwKCQkgICAgZnJhZywgcmVtb3RlLT5uYW1lKTsKCXJlZnNwZWNfYXBwZW5kKCZyZW1vdGUtPmZldGNoLCBidWYuYnVmKTsKCgkvKgoJICogQ29naXRvIGNvbXBhdGlibGUgcHVzaDogcHVzaCBjdXJyZW50IEhFQUQgdG8gcmVtb3RlICNicmFuY2gKCSAqIChtYXN0ZXIgaWYgbWlzc2luZykKCSAqLwoJc3RyYnVmX3Jlc2V0KCZidWYpOwoJc3RyYnVmX2FkZGYoJmJ1ZiwgIkhFQUQ6cmVmcy9oZWFkcy8lcyIsIGZyYWcpOwoJcmVmc3BlY19hcHBlbmQoJnJlbW90ZS0+cHVzaCwgYnVmLmJ1Zik7CglyZW1vdGUtPmZldGNoX3RhZ3MgPSAxOyAvKiBhbHdheXMgYXV0by1mb2xsb3cgKi8KCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwp9CgpzdGF0aWMgaW50IGhhbmRsZV9jb25maWcoY29uc3QgY2hhciAqa2V5LCBjb25zdCBjaGFyICp2YWx1ZSwgdm9pZCAqY2IpCnsKCWNvbnN0IGNoYXIgKm5hbWU7CglpbnQgbmFtZWxlbjsKCWNvbnN0IGNoYXIgKnN1YmtleTsKCXN0cnVjdCByZW1vdGUgKnJlbW90ZTsKCXN0cnVjdCBicmFuY2ggKmJyYW5jaDsKCWlmIChwYXJzZV9jb25maWdfa2V5KGtleSwgImJyYW5jaCIsICZuYW1lLCAmbmFtZWxlbiwgJnN1YmtleSkgPj0gMCkgewoJCWlmICghbmFtZSkKCQkJcmV0dXJuIDA7CgkJYnJhbmNoID0gbWFrZV9icmFuY2gobmFtZSwgbmFtZWxlbik7CgkJaWYgKCFzdHJjbXAoc3Via2V5LCAicmVtb3RlIikpIHsKCQkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZicmFuY2gtPnJlbW90ZV9uYW1lLCBrZXksIHZhbHVlKTsKCQl9IGVsc2UgaWYgKCFzdHJjbXAoc3Via2V5LCAicHVzaHJlbW90ZSIpKSB7CgkJCXJldHVybiBnaXRfY29uZmlnX3N0cmluZygmYnJhbmNoLT5wdXNocmVtb3RlX25hbWUsIGtleSwgdmFsdWUpOwoJCX0gZWxzZSBpZiAoIXN0cmNtcChzdWJrZXksICJtZXJnZSIpKSB7CgkJCWlmICghdmFsdWUpCgkJCQlyZXR1cm4gY29uZmlnX2Vycm9yX25vbmJvb2woa2V5KTsKCQkJYWRkX21lcmdlKGJyYW5jaCwgeHN0cmR1cCh2YWx1ZSkpOwoJCX0KCQlyZXR1cm4gMDsKCX0KCWlmIChwYXJzZV9jb25maWdfa2V5KGtleSwgInVybCIsICZuYW1lLCAmbmFtZWxlbiwgJnN1YmtleSkgPj0gMCkgewoJCXN0cnVjdCByZXdyaXRlICpyZXdyaXRlOwoJCWlmICghbmFtZSkKCQkJcmV0dXJuIDA7CgkJaWYgKCFzdHJjbXAoc3Via2V5LCAiaW5zdGVhZG9mIikpIHsKCQkJcmV3cml0ZSA9IG1ha2VfcmV3cml0ZSgmcmV3cml0ZXMsIG5hbWUsIG5hbWVsZW4pOwoJCQlpZiAoIXZhbHVlKQoJCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKGtleSk7CgkJCWFkZF9pbnN0ZWFkX29mKHJld3JpdGUsIHhzdHJkdXAodmFsdWUpKTsKCQl9IGVsc2UgaWYgKCFzdHJjbXAoc3Via2V5LCAicHVzaGluc3RlYWRvZiIpKSB7CgkJCXJld3JpdGUgPSBtYWtlX3Jld3JpdGUoJnJld3JpdGVzX3B1c2gsIG5hbWUsIG5hbWVsZW4pOwoJCQlpZiAoIXZhbHVlKQoJCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKGtleSk7CgkJCWFkZF9pbnN0ZWFkX29mKHJld3JpdGUsIHhzdHJkdXAodmFsdWUpKTsKCQl9Cgl9CgoJaWYgKHBhcnNlX2NvbmZpZ19rZXkoa2V5LCAicmVtb3RlIiwgJm5hbWUsICZuYW1lbGVuLCAmc3Via2V5KSA8IDApCgkJcmV0dXJuIDA7CgoJLyogSGFuZGxlIHJlbW90ZS4qIHZhcmlhYmxlcyAqLwoJaWYgKCFuYW1lICYmICFzdHJjbXAoc3Via2V5LCAicHVzaGRlZmF1bHQiKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJnB1c2hyZW1vdGVfbmFtZSwga2V5LCB2YWx1ZSk7CgoJaWYgKCFuYW1lKQoJCXJldHVybiAwOwoJLyogSGFuZGxlIHJlbW90ZS48bmFtZT4uKiB2YXJpYWJsZXMgKi8KCWlmICgqbmFtZSA9PSAnLycpIHsKCQl3YXJuaW5nKCJDb25maWcgcmVtb3RlIHNob3J0aGFuZCBjYW5ub3QgYmVnaW4gd2l0aCAnLyc6ICVzIiwKCQkJbmFtZSk7CgkJcmV0dXJuIDA7Cgl9CglyZW1vdGUgPSBtYWtlX3JlbW90ZShuYW1lLCBuYW1lbGVuKTsKCXJlbW90ZS0+b3JpZ2luID0gUkVNT1RFX0NPTkZJRzsKCWlmIChjdXJyZW50X2NvbmZpZ19zY29wZSgpID09IENPTkZJR19TQ09QRV9SRVBPKQoJCXJlbW90ZS0+Y29uZmlndXJlZF9pbl9yZXBvID0gMTsKCWlmICghc3RyY21wKHN1YmtleSwgIm1pcnJvciIpKQoJCXJlbW90ZS0+bWlycm9yID0gZ2l0X2NvbmZpZ19ib29sKGtleSwgdmFsdWUpOwoJZWxzZSBpZiAoIXN0cmNtcChzdWJrZXksICJza2lwZGVmYXVsdHVwZGF0ZSIpKQoJCXJlbW90ZS0+c2tpcF9kZWZhdWx0X3VwZGF0ZSA9IGdpdF9jb25maWdfYm9vbChrZXksIHZhbHVlKTsKCWVsc2UgaWYgKCFzdHJjbXAoc3Via2V5LCAic2tpcGZldGNoYWxsIikpCgkJcmVtb3RlLT5za2lwX2RlZmF1bHRfdXBkYXRlID0gZ2l0X2NvbmZpZ19ib29sKGtleSwgdmFsdWUpOwoJZWxzZSBpZiAoIXN0cmNtcChzdWJrZXksICJwcnVuZSIpKQoJCXJlbW90ZS0+cHJ1bmUgPSBnaXRfY29uZmlnX2Jvb2woa2V5LCB2YWx1ZSk7CgllbHNlIGlmICghc3RyY21wKHN1YmtleSwgInBydW5ldGFncyIpKQoJCXJlbW90ZS0+cHJ1bmVfdGFncyA9IGdpdF9jb25maWdfYm9vbChrZXksIHZhbHVlKTsKCWVsc2UgaWYgKCFzdHJjbXAoc3Via2V5LCAidXJsIikpIHsKCQljb25zdCBjaGFyICp2OwoJCWlmIChnaXRfY29uZmlnX3N0cmluZygmdiwga2V5LCB2YWx1ZSkpCgkJCXJldHVybiAtMTsKCQlhZGRfdXJsKHJlbW90ZSwgdik7Cgl9IGVsc2UgaWYgKCFzdHJjbXAoc3Via2V5LCAicHVzaHVybCIpKSB7CgkJY29uc3QgY2hhciAqdjsKCQlpZiAoZ2l0X2NvbmZpZ19zdHJpbmcoJnYsIGtleSwgdmFsdWUpKQoJCQlyZXR1cm4gLTE7CgkJYWRkX3B1c2h1cmwocmVtb3RlLCB2KTsKCX0gZWxzZSBpZiAoIXN0cmNtcChzdWJrZXksICJwdXNoIikpIHsKCQljb25zdCBjaGFyICp2OwoJCWlmIChnaXRfY29uZmlnX3N0cmluZygmdiwga2V5LCB2YWx1ZSkpCgkJCXJldHVybiAtMTsKCQlyZWZzcGVjX2FwcGVuZCgmcmVtb3RlLT5wdXNoLCB2KTsKCQlmcmVlKChjaGFyICopdik7Cgl9IGVsc2UgaWYgKCFzdHJjbXAoc3Via2V5LCAiZmV0Y2giKSkgewoJCWNvbnN0IGNoYXIgKnY7CgkJaWYgKGdpdF9jb25maWdfc3RyaW5nKCZ2LCBrZXksIHZhbHVlKSkKCQkJcmV0dXJuIC0xOwoJCXJlZnNwZWNfYXBwZW5kKCZyZW1vdGUtPmZldGNoLCB2KTsKCQlmcmVlKChjaGFyICopdik7Cgl9IGVsc2UgaWYgKCFzdHJjbXAoc3Via2V5LCAicmVjZWl2ZXBhY2siKSkgewoJCWNvbnN0IGNoYXIgKnY7CgkJaWYgKGdpdF9jb25maWdfc3RyaW5nKCZ2LCBrZXksIHZhbHVlKSkKCQkJcmV0dXJuIC0xOwoJCWlmICghcmVtb3RlLT5yZWNlaXZlcGFjaykKCQkJcmVtb3RlLT5yZWNlaXZlcGFjayA9IHY7CgkJZWxzZQoJCQllcnJvcigibW9yZSB0aGFuIG9uZSByZWNlaXZlcGFjayBnaXZlbiwgdXNpbmcgdGhlIGZpcnN0Iik7Cgl9IGVsc2UgaWYgKCFzdHJjbXAoc3Via2V5LCAidXBsb2FkcGFjayIpKSB7CgkJY29uc3QgY2hhciAqdjsKCQlpZiAoZ2l0X2NvbmZpZ19zdHJpbmcoJnYsIGtleSwgdmFsdWUpKQoJCQlyZXR1cm4gLTE7CgkJaWYgKCFyZW1vdGUtPnVwbG9hZHBhY2spCgkJCXJlbW90ZS0+dXBsb2FkcGFjayA9IHY7CgkJZWxzZQoJCQllcnJvcigibW9yZSB0aGFuIG9uZSB1cGxvYWRwYWNrIGdpdmVuLCB1c2luZyB0aGUgZmlyc3QiKTsKCX0gZWxzZSBpZiAoIXN0cmNtcChzdWJrZXksICJ0YWdvcHQiKSkgewoJCWlmICghc3RyY21wKHZhbHVlLCAiLS1uby10YWdzIikpCgkJCXJlbW90ZS0+ZmV0Y2hfdGFncyA9IC0xOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICItLXRhZ3MiKSkKCQkJcmVtb3RlLT5mZXRjaF90YWdzID0gMjsKCX0gZWxzZSBpZiAoIXN0cmNtcChzdWJrZXksICJwcm94eSIpKSB7CgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKChjb25zdCBjaGFyICoqKSZyZW1vdGUtPmh0dHBfcHJveHksCgkJCQkJIGtleSwgdmFsdWUpOwoJfSBlbHNlIGlmICghc3RyY21wKHN1YmtleSwgInByb3h5YXV0aG1ldGhvZCIpKSB7CgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKChjb25zdCBjaGFyICoqKSZyZW1vdGUtPmh0dHBfcHJveHlfYXV0aG1ldGhvZCwKCQkJCQkga2V5LCB2YWx1ZSk7Cgl9IGVsc2UgaWYgKCFzdHJjbXAoc3Via2V5LCAidmNzIikpIHsKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJnJlbW90ZS0+Zm9yZWlnbl92Y3MsIGtleSwgdmFsdWUpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGFsaWFzX2FsbF91cmxzKHZvaWQpCnsKCWludCBpLCBqOwoJZm9yIChpID0gMDsgaSA8IHJlbW90ZXNfbnI7IGkrKykgewoJCWludCBhZGRfcHVzaHVybF9hbGlhc2VzOwoJCWlmICghcmVtb3Rlc1tpXSkKCQkJY29udGludWU7CgkJZm9yIChqID0gMDsgaiA8IHJlbW90ZXNbaV0tPnB1c2h1cmxfbnI7IGorKykgewoJCQlyZW1vdGVzW2ldLT5wdXNodXJsW2pdID0gYWxpYXNfdXJsKHJlbW90ZXNbaV0tPnB1c2h1cmxbal0sICZyZXdyaXRlcyk7CgkJfQoJCWFkZF9wdXNodXJsX2FsaWFzZXMgPSByZW1vdGVzW2ldLT5wdXNodXJsX25yID09IDA7CgkJZm9yIChqID0gMDsgaiA8IHJlbW90ZXNbaV0tPnVybF9ucjsgaisrKSB7CgkJCWlmIChhZGRfcHVzaHVybF9hbGlhc2VzKQoJCQkJYWRkX3B1c2h1cmxfYWxpYXMocmVtb3Rlc1tpXSwgcmVtb3Rlc1tpXS0+dXJsW2pdKTsKCQkJcmVtb3Rlc1tpXS0+dXJsW2pdID0gYWxpYXNfdXJsKHJlbW90ZXNbaV0tPnVybFtqXSwgJnJld3JpdGVzKTsKCQl9Cgl9Cn0KCnN0YXRpYyB2b2lkIHJlYWRfY29uZmlnKHZvaWQpCnsKCXN0YXRpYyBpbnQgbG9hZGVkOwoJaW50IGZsYWc7CgoJaWYgKGxvYWRlZCkKCQlyZXR1cm47Cglsb2FkZWQgPSAxOwoKCWN1cnJlbnRfYnJhbmNoID0gTlVMTDsKCWlmIChzdGFydHVwX2luZm8tPmhhdmVfcmVwb3NpdG9yeSkgewoJCWNvbnN0IGNoYXIgKmhlYWRfcmVmID0gcmVzb2x2ZV9yZWZfdW5zYWZlKCJIRUFEIiwgMCwgTlVMTCwgJmZsYWcpOwoJCWlmIChoZWFkX3JlZiAmJiAoZmxhZyAmIFJFRl9JU1NZTVJFRikgJiYKCQkgICAgc2tpcF9wcmVmaXgoaGVhZF9yZWYsICJyZWZzL2hlYWRzLyIsICZoZWFkX3JlZikpIHsKCQkJY3VycmVudF9icmFuY2ggPSBtYWtlX2JyYW5jaChoZWFkX3JlZiwgMCk7CgkJfQoJfQoJZ2l0X2NvbmZpZyhoYW5kbGVfY29uZmlnLCBOVUxMKTsKCWFsaWFzX2FsbF91cmxzKCk7Cn0KCnN0YXRpYyBpbnQgdmFsaWRfcmVtb3RlX25pY2soY29uc3QgY2hhciAqbmFtZSkKewoJaWYgKCFuYW1lWzBdIHx8IGlzX2RvdF9vcl9kb3Rkb3QobmFtZSkpCgkJcmV0dXJuIDA7CgoJLyogcmVtb3RlIG5pY2tuYW1lcyBjYW5ub3QgY29udGFpbiBzbGFzaGVzICovCgl3aGlsZSAoKm5hbWUpCgkJaWYgKGlzX2Rpcl9zZXAoKm5hbWUrKykpCgkJCXJldHVybiAwOwoJcmV0dXJuIDE7Cn0KCmNvbnN0IGNoYXIgKnJlbW90ZV9mb3JfYnJhbmNoKHN0cnVjdCBicmFuY2ggKmJyYW5jaCwgaW50ICpleHBsaWNpdCkKewoJaWYgKGJyYW5jaCAmJiBicmFuY2gtPnJlbW90ZV9uYW1lKSB7CgkJaWYgKGV4cGxpY2l0KQoJCQkqZXhwbGljaXQgPSAxOwoJCXJldHVybiBicmFuY2gtPnJlbW90ZV9uYW1lOwoJfQoJaWYgKGV4cGxpY2l0KQoJCSpleHBsaWNpdCA9IDA7CglyZXR1cm4gIm9yaWdpbiI7Cn0KCmNvbnN0IGNoYXIgKnB1c2hyZW1vdGVfZm9yX2JyYW5jaChzdHJ1Y3QgYnJhbmNoICpicmFuY2gsIGludCAqZXhwbGljaXQpCnsKCWlmIChicmFuY2ggJiYgYnJhbmNoLT5wdXNocmVtb3RlX25hbWUpIHsKCQlpZiAoZXhwbGljaXQpCgkJCSpleHBsaWNpdCA9IDE7CgkJcmV0dXJuIGJyYW5jaC0+cHVzaHJlbW90ZV9uYW1lOwoJfQoJaWYgKHB1c2hyZW1vdGVfbmFtZSkgewoJCWlmIChleHBsaWNpdCkKCQkJKmV4cGxpY2l0ID0gMTsKCQlyZXR1cm4gcHVzaHJlbW90ZV9uYW1lOwoJfQoJcmV0dXJuIHJlbW90ZV9mb3JfYnJhbmNoKGJyYW5jaCwgZXhwbGljaXQpOwp9Cgpjb25zdCBjaGFyICpyZW1vdGVfcmVmX2Zvcl9icmFuY2goc3RydWN0IGJyYW5jaCAqYnJhbmNoLCBpbnQgZm9yX3B1c2gsCgkJCQkgIGludCAqZXhwbGljaXQpCnsKCWlmIChicmFuY2gpIHsKCQlpZiAoIWZvcl9wdXNoKSB7CgkJCWlmIChicmFuY2gtPm1lcmdlX25yKSB7CgkJCQlpZiAoZXhwbGljaXQpCgkJCQkJKmV4cGxpY2l0ID0gMTsKCQkJCXJldHVybiBicmFuY2gtPm1lcmdlX25hbWVbMF07CgkJCX0KCQl9IGVsc2UgewoJCQljb25zdCBjaGFyICpkc3QsICpyZW1vdGVfbmFtZSA9CgkJCQlwdXNocmVtb3RlX2Zvcl9icmFuY2goYnJhbmNoLCBOVUxMKTsKCQkJc3RydWN0IHJlbW90ZSAqcmVtb3RlID0gcmVtb3RlX2dldChyZW1vdGVfbmFtZSk7CgoJCQlpZiAocmVtb3RlICYmIHJlbW90ZS0+cHVzaC5uciAmJgoJCQkgICAgKGRzdCA9IGFwcGx5X3JlZnNwZWNzKCZyZW1vdGUtPnB1c2gsCgkJCQkJCSAgYnJhbmNoLT5yZWZuYW1lKSkpIHsKCQkJCWlmIChleHBsaWNpdCkKCQkJCQkqZXhwbGljaXQgPSAxOwoJCQkJcmV0dXJuIGRzdDsKCQkJfQoJCX0KCX0KCWlmIChleHBsaWNpdCkKCQkqZXhwbGljaXQgPSAwOwoJcmV0dXJuICIiOwp9CgpzdGF0aWMgc3RydWN0IHJlbW90ZSAqcmVtb3RlX2dldF8xKGNvbnN0IGNoYXIgKm5hbWUsCgkJCQkgICBjb25zdCBjaGFyICooKmdldF9kZWZhdWx0KShzdHJ1Y3QgYnJhbmNoICosIGludCAqKSkKewoJc3RydWN0IHJlbW90ZSAqcmV0OwoJaW50IG5hbWVfZ2l2ZW4gPSAwOwoKCXJlYWRfY29uZmlnKCk7CgoJaWYgKG5hbWUpCgkJbmFtZV9naXZlbiA9IDE7CgllbHNlCgkJbmFtZSA9IGdldF9kZWZhdWx0KGN1cnJlbnRfYnJhbmNoLCAmbmFtZV9naXZlbik7CgoJcmV0ID0gbWFrZV9yZW1vdGUobmFtZSwgMCk7CglpZiAodmFsaWRfcmVtb3RlX25pY2sobmFtZSkgJiYgaGF2ZV9naXRfZGlyKCkpIHsKCQlpZiAoIXZhbGlkX3JlbW90ZShyZXQpKQoJCQlyZWFkX3JlbW90ZXNfZmlsZShyZXQpOwoJCWlmICghdmFsaWRfcmVtb3RlKHJldCkpCgkJCXJlYWRfYnJhbmNoZXNfZmlsZShyZXQpOwoJfQoJaWYgKG5hbWVfZ2l2ZW4gJiYgIXZhbGlkX3JlbW90ZShyZXQpKQoJCWFkZF91cmxfYWxpYXMocmV0LCBuYW1lKTsKCWlmICghdmFsaWRfcmVtb3RlKHJldCkpCgkJcmV0dXJuIE5VTEw7CglyZXR1cm4gcmV0Owp9CgpzdHJ1Y3QgcmVtb3RlICpyZW1vdGVfZ2V0KGNvbnN0IGNoYXIgKm5hbWUpCnsKCXJldHVybiByZW1vdGVfZ2V0XzEobmFtZSwgcmVtb3RlX2Zvcl9icmFuY2gpOwp9CgpzdHJ1Y3QgcmVtb3RlICpwdXNocmVtb3RlX2dldChjb25zdCBjaGFyICpuYW1lKQp7CglyZXR1cm4gcmVtb3RlX2dldF8xKG5hbWUsIHB1c2hyZW1vdGVfZm9yX2JyYW5jaCk7Cn0KCmludCByZW1vdGVfaXNfY29uZmlndXJlZChzdHJ1Y3QgcmVtb3RlICpyZW1vdGUsIGludCBpbl9yZXBvKQp7CglpZiAoIXJlbW90ZSkKCQlyZXR1cm4gMDsKCWlmIChpbl9yZXBvKQoJCXJldHVybiByZW1vdGUtPmNvbmZpZ3VyZWRfaW5fcmVwbzsKCXJldHVybiAhIXJlbW90ZS0+b3JpZ2luOwp9CgppbnQgZm9yX2VhY2hfcmVtb3RlKGVhY2hfcmVtb3RlX2ZuIGZuLCB2b2lkICpwcml2KQp7CglpbnQgaSwgcmVzdWx0ID0gMDsKCXJlYWRfY29uZmlnKCk7Cglmb3IgKGkgPSAwOyBpIDwgcmVtb3Rlc19uciAmJiAhcmVzdWx0OyBpKyspIHsKCQlzdHJ1Y3QgcmVtb3RlICpyID0gcmVtb3Rlc1tpXTsKCQlpZiAoIXIpCgkJCWNvbnRpbnVlOwoJCXJlc3VsdCA9IGZuKHIsIHByaXYpOwoJfQoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIHZvaWQgaGFuZGxlX2R1cGxpY2F0ZShzdHJ1Y3QgcmVmICpyZWYxLCBzdHJ1Y3QgcmVmICpyZWYyKQp7CglpZiAoc3RyY21wKHJlZjEtPm5hbWUsIHJlZjItPm5hbWUpKSB7CgkJaWYgKHJlZjEtPmZldGNoX2hlYWRfc3RhdHVzICE9IEZFVENIX0hFQURfSUdOT1JFICYmCgkJICAgIHJlZjItPmZldGNoX2hlYWRfc3RhdHVzICE9IEZFVENIX0hFQURfSUdOT1JFKSB7CgkJCWRpZShfKCJDYW5ub3QgZmV0Y2ggYm90aCAlcyBhbmQgJXMgdG8gJXMiKSwKCQkJICAgIHJlZjEtPm5hbWUsIHJlZjItPm5hbWUsIHJlZjItPnBlZXJfcmVmLT5uYW1lKTsKCQl9IGVsc2UgaWYgKHJlZjEtPmZldGNoX2hlYWRfc3RhdHVzICE9IEZFVENIX0hFQURfSUdOT1JFICYmCgkJCSAgIHJlZjItPmZldGNoX2hlYWRfc3RhdHVzID09IEZFVENIX0hFQURfSUdOT1JFKSB7CgkJCXdhcm5pbmcoXygiJXMgdXN1YWxseSB0cmFja3MgJXMsIG5vdCAlcyIpLAoJCQkJcmVmMi0+cGVlcl9yZWYtPm5hbWUsIHJlZjItPm5hbWUsIHJlZjEtPm5hbWUpOwoJCX0gZWxzZSBpZiAocmVmMS0+ZmV0Y2hfaGVhZF9zdGF0dXMgPT0gRkVUQ0hfSEVBRF9JR05PUkUgJiYKCQkJICAgcmVmMi0+ZmV0Y2hfaGVhZF9zdGF0dXMgPT0gRkVUQ0hfSEVBRF9JR05PUkUpIHsKCQkJZGllKF8oIiVzIHRyYWNrcyBib3RoICVzIGFuZCAlcyIpLAoJCQkgICAgcmVmMi0+cGVlcl9yZWYtPm5hbWUsIHJlZjEtPm5hbWUsIHJlZjItPm5hbWUpOwoJCX0gZWxzZSB7CgkJCS8qCgkJCSAqIFRoaXMgbGFzdCBwb3NzaWJpbGl0eSBkb2Vzbid0IG9jY3VyIGJlY2F1c2UKCQkJICogRkVUQ0hfSEVBRF9JR05PUkUgZW50cmllcyBhbHdheXMgYXBwZWFyIGF0CgkJCSAqIHRoZSBlbmQgb2YgdGhlIGxpc3QuCgkJCSAqLwoJCQlkaWUoXygiSW50ZXJuYWwgZXJyb3IiKSk7CgkJfQoJfQoJZnJlZShyZWYyLT5wZWVyX3JlZik7CglmcmVlKHJlZjIpOwp9CgpzdHJ1Y3QgcmVmICpyZWZfcmVtb3ZlX2R1cGxpY2F0ZXMoc3RydWN0IHJlZiAqcmVmX21hcCkKewoJc3RydWN0IHN0cmluZ19saXN0IHJlZnMgPSBTVFJJTkdfTElTVF9JTklUX05PRFVQOwoJc3RydWN0IHJlZiAqcmV0dmFsID0gTlVMTDsKCXN0cnVjdCByZWYgKipwID0gJnJldHZhbDsKCgl3aGlsZSAocmVmX21hcCkgewoJCXN0cnVjdCByZWYgKnJlZiA9IHJlZl9tYXA7CgoJCXJlZl9tYXAgPSByZWZfbWFwLT5uZXh0OwoJCXJlZi0+bmV4dCA9IE5VTEw7CgoJCWlmICghcmVmLT5wZWVyX3JlZikgewoJCQkqcCA9IHJlZjsKCQkJcCA9ICZyZWYtPm5leHQ7CgkJfSBlbHNlIHsKCQkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW0gPQoJCQkJc3RyaW5nX2xpc3RfaW5zZXJ0KCZyZWZzLCByZWYtPnBlZXJfcmVmLT5uYW1lKTsKCgkJCWlmIChpdGVtLT51dGlsKSB7CgkJCQkvKiBFbnRyeSBhbHJlYWR5IGV4aXN0ZWQgKi8KCQkJCWhhbmRsZV9kdXBsaWNhdGUoKHN0cnVjdCByZWYgKilpdGVtLT51dGlsLCByZWYpOwoJCQl9IGVsc2UgewoJCQkJKnAgPSByZWY7CgkJCQlwID0gJnJlZi0+bmV4dDsKCQkJCWl0ZW0tPnV0aWwgPSByZWY7CgkJCX0KCQl9Cgl9CgoJc3RyaW5nX2xpc3RfY2xlYXIoJnJlZnMsIDApOwoJcmV0dXJuIHJldHZhbDsKfQoKaW50IHJlbW90ZV9oYXNfdXJsKHN0cnVjdCByZW1vdGUgKnJlbW90ZSwgY29uc3QgY2hhciAqdXJsKQp7CglpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCByZW1vdGUtPnVybF9ucjsgaSsrKSB7CgkJaWYgKCFzdHJjbXAocmVtb3RlLT51cmxbaV0sIHVybCkpCgkJCXJldHVybiAxOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgbWF0Y2hfbmFtZV93aXRoX3BhdHRlcm4oY29uc3QgY2hhciAqa2V5LCBjb25zdCBjaGFyICpuYW1lLAoJCQkJICAgY29uc3QgY2hhciAqdmFsdWUsIGNoYXIgKipyZXN1bHQpCnsKCWNvbnN0IGNoYXIgKmtzdGFyID0gc3RyY2hyKGtleSwgJyonKTsKCXNpemVfdCBrbGVuOwoJc2l6ZV90IGtzdWZmaXhsZW47CglzaXplX3QgbmFtZWxlbjsKCWludCByZXQ7CglpZiAoIWtzdGFyKQoJCWRpZSgiS2V5ICclcycgb2YgcGF0dGVybiBoYWQgbm8gJyonIiwga2V5KTsKCWtsZW4gPSBrc3RhciAtIGtleTsKCWtzdWZmaXhsZW4gPSBzdHJsZW4oa3N0YXIgKyAxKTsKCW5hbWVsZW4gPSBzdHJsZW4obmFtZSk7CglyZXQgPSAhc3RybmNtcChuYW1lLCBrZXksIGtsZW4pICYmIG5hbWVsZW4gPj0ga2xlbiArIGtzdWZmaXhsZW4gJiYKCQkhbWVtY21wKG5hbWUgKyBuYW1lbGVuIC0ga3N1ZmZpeGxlbiwga3N0YXIgKyAxLCBrc3VmZml4bGVuKTsKCWlmIChyZXQgJiYgdmFsdWUpIHsKCQlzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CgkJY29uc3QgY2hhciAqdnN0YXIgPSBzdHJjaHIodmFsdWUsICcqJyk7CgkJaWYgKCF2c3RhcikKCQkJZGllKCJWYWx1ZSAnJXMnIG9mIHBhdHRlcm4gaGFzIG5vICcqJyIsIHZhbHVlKTsKCQlzdHJidWZfYWRkKCZzYiwgdmFsdWUsIHZzdGFyIC0gdmFsdWUpOwoJCXN0cmJ1Zl9hZGQoJnNiLCBuYW1lICsga2xlbiwgbmFtZWxlbiAtIGtsZW4gLSBrc3VmZml4bGVuKTsKCQlzdHJidWZfYWRkc3RyKCZzYiwgdnN0YXIgKyAxKTsKCQkqcmVzdWx0ID0gc3RyYnVmX2RldGFjaCgmc2IsIE5VTEwpOwoJfQoJcmV0dXJuIHJldDsKfQoKc3RhdGljIHZvaWQgcXVlcnlfcmVmc3BlY3NfbXVsdGlwbGUoc3RydWN0IHJlZnNwZWMgKnJzLAoJCQkJICAgIHN0cnVjdCByZWZzcGVjX2l0ZW0gKnF1ZXJ5LAoJCQkJICAgIHN0cnVjdCBzdHJpbmdfbGlzdCAqcmVzdWx0cykKewoJaW50IGk7CglpbnQgZmluZF9zcmMgPSAhcXVlcnktPnNyYzsKCglpZiAoZmluZF9zcmMgJiYgIXF1ZXJ5LT5kc3QpCgkJZXJyb3IoInF1ZXJ5X3JlZnNwZWNzX211bHRpcGxlOiBuZWVkIGVpdGhlciBzcmMgb3IgZHN0Iik7CgoJZm9yIChpID0gMDsgaSA8IHJzLT5ucjsgaSsrKSB7CgkJc3RydWN0IHJlZnNwZWNfaXRlbSAqcmVmc3BlYyA9ICZycy0+aXRlbXNbaV07CgkJY29uc3QgY2hhciAqa2V5ID0gZmluZF9zcmMgPyByZWZzcGVjLT5kc3QgOiByZWZzcGVjLT5zcmM7CgkJY29uc3QgY2hhciAqdmFsdWUgPSBmaW5kX3NyYyA/IHJlZnNwZWMtPnNyYyA6IHJlZnNwZWMtPmRzdDsKCQljb25zdCBjaGFyICpuZWVkbGUgPSBmaW5kX3NyYyA/IHF1ZXJ5LT5kc3QgOiBxdWVyeS0+c3JjOwoJCWNoYXIgKipyZXN1bHQgPSBmaW5kX3NyYyA/ICZxdWVyeS0+c3JjIDogJnF1ZXJ5LT5kc3Q7CgoJCWlmICghcmVmc3BlYy0+ZHN0KQoJCQljb250aW51ZTsKCQlpZiAocmVmc3BlYy0+cGF0dGVybikgewoJCQlpZiAobWF0Y2hfbmFtZV93aXRoX3BhdHRlcm4oa2V5LCBuZWVkbGUsIHZhbHVlLCByZXN1bHQpKQoJCQkJc3RyaW5nX2xpc3RfYXBwZW5kX25vZHVwKHJlc3VsdHMsICpyZXN1bHQpOwoJCX0gZWxzZSBpZiAoIXN0cmNtcChuZWVkbGUsIGtleSkpIHsKCQkJc3RyaW5nX2xpc3RfYXBwZW5kKHJlc3VsdHMsIHZhbHVlKTsKCQl9Cgl9Cn0KCmludCBxdWVyeV9yZWZzcGVjcyhzdHJ1Y3QgcmVmc3BlYyAqcnMsIHN0cnVjdCByZWZzcGVjX2l0ZW0gKnF1ZXJ5KQp7CglpbnQgaTsKCWludCBmaW5kX3NyYyA9ICFxdWVyeS0+c3JjOwoJY29uc3QgY2hhciAqbmVlZGxlID0gZmluZF9zcmMgPyBxdWVyeS0+ZHN0IDogcXVlcnktPnNyYzsKCWNoYXIgKipyZXN1bHQgPSBmaW5kX3NyYyA/ICZxdWVyeS0+c3JjIDogJnF1ZXJ5LT5kc3Q7CgoJaWYgKGZpbmRfc3JjICYmICFxdWVyeS0+ZHN0KQoJCXJldHVybiBlcnJvcigicXVlcnlfcmVmc3BlY3M6IG5lZWQgZWl0aGVyIHNyYyBvciBkc3QiKTsKCglmb3IgKGkgPSAwOyBpIDwgcnMtPm5yOyBpKyspIHsKCQlzdHJ1Y3QgcmVmc3BlY19pdGVtICpyZWZzcGVjID0gJnJzLT5pdGVtc1tpXTsKCQljb25zdCBjaGFyICprZXkgPSBmaW5kX3NyYyA/IHJlZnNwZWMtPmRzdCA6IHJlZnNwZWMtPnNyYzsKCQljb25zdCBjaGFyICp2YWx1ZSA9IGZpbmRfc3JjID8gcmVmc3BlYy0+c3JjIDogcmVmc3BlYy0+ZHN0OwoKCQlpZiAoIXJlZnNwZWMtPmRzdCkKCQkJY29udGludWU7CgkJaWYgKHJlZnNwZWMtPnBhdHRlcm4pIHsKCQkJaWYgKG1hdGNoX25hbWVfd2l0aF9wYXR0ZXJuKGtleSwgbmVlZGxlLCB2YWx1ZSwgcmVzdWx0KSkgewoJCQkJcXVlcnktPmZvcmNlID0gcmVmc3BlYy0+Zm9yY2U7CgkJCQlyZXR1cm4gMDsKCQkJfQoJCX0gZWxzZSBpZiAoIXN0cmNtcChuZWVkbGUsIGtleSkpIHsKCQkJKnJlc3VsdCA9IHhzdHJkdXAodmFsdWUpOwoJCQlxdWVyeS0+Zm9yY2UgPSByZWZzcGVjLT5mb3JjZTsKCQkJcmV0dXJuIDA7CgkJfQoJfQoJcmV0dXJuIC0xOwp9CgpjaGFyICphcHBseV9yZWZzcGVjcyhzdHJ1Y3QgcmVmc3BlYyAqcnMsIGNvbnN0IGNoYXIgKm5hbWUpCnsKCXN0cnVjdCByZWZzcGVjX2l0ZW0gcXVlcnk7CgoJbWVtc2V0KCZxdWVyeSwgMCwgc2l6ZW9mKHN0cnVjdCByZWZzcGVjX2l0ZW0pKTsKCXF1ZXJ5LnNyYyA9IChjaGFyICopbmFtZTsKCglpZiAocXVlcnlfcmVmc3BlY3MocnMsICZxdWVyeSkpCgkJcmV0dXJuIE5VTEw7CgoJcmV0dXJuIHF1ZXJ5LmRzdDsKfQoKaW50IHJlbW90ZV9maW5kX3RyYWNraW5nKHN0cnVjdCByZW1vdGUgKnJlbW90ZSwgc3RydWN0IHJlZnNwZWNfaXRlbSAqcmVmc3BlYykKewoJcmV0dXJuIHF1ZXJ5X3JlZnNwZWNzKCZyZW1vdGUtPmZldGNoLCByZWZzcGVjKTsKfQoKc3RhdGljIHN0cnVjdCByZWYgKmFsbG9jX3JlZl93aXRoX3ByZWZpeChjb25zdCBjaGFyICpwcmVmaXgsIHNpemVfdCBwcmVmaXhsZW4sCgkJY29uc3QgY2hhciAqbmFtZSkKewoJc2l6ZV90IGxlbiA9IHN0cmxlbihuYW1lKTsKCXN0cnVjdCByZWYgKnJlZiA9IHhjYWxsb2MoMSwgc3RfYWRkNChzaXplb2YoKnJlZiksIHByZWZpeGxlbiwgbGVuLCAxKSk7CgltZW1jcHkocmVmLT5uYW1lLCBwcmVmaXgsIHByZWZpeGxlbik7CgltZW1jcHkocmVmLT5uYW1lICsgcHJlZml4bGVuLCBuYW1lLCBsZW4pOwoJcmV0dXJuIHJlZjsKfQoKc3RydWN0IHJlZiAqYWxsb2NfcmVmKGNvbnN0IGNoYXIgKm5hbWUpCnsKCXJldHVybiBhbGxvY19yZWZfd2l0aF9wcmVmaXgoIiIsIDAsIG5hbWUpOwp9CgpzdHJ1Y3QgcmVmICpjb3B5X3JlZihjb25zdCBzdHJ1Y3QgcmVmICpyZWYpCnsKCXN0cnVjdCByZWYgKmNweTsKCXNpemVfdCBsZW47CglpZiAoIXJlZikKCQlyZXR1cm4gTlVMTDsKCWxlbiA9IHN0X2FkZDMoc2l6ZW9mKHN0cnVjdCByZWYpLCBzdHJsZW4ocmVmLT5uYW1lKSwgMSk7CgljcHkgPSB4bWFsbG9jKGxlbik7CgltZW1jcHkoY3B5LCByZWYsIGxlbik7CgljcHktPm5leHQgPSBOVUxMOwoJY3B5LT5zeW1yZWYgPSB4c3RyZHVwX29yX251bGwocmVmLT5zeW1yZWYpOwoJY3B5LT5yZW1vdGVfc3RhdHVzID0geHN0cmR1cF9vcl9udWxsKHJlZi0+cmVtb3RlX3N0YXR1cyk7CgljcHktPnBlZXJfcmVmID0gY29weV9yZWYocmVmLT5wZWVyX3JlZik7CglyZXR1cm4gY3B5Owp9CgpzdHJ1Y3QgcmVmICpjb3B5X3JlZl9saXN0KGNvbnN0IHN0cnVjdCByZWYgKnJlZikKewoJc3RydWN0IHJlZiAqcmV0ID0gTlVMTDsKCXN0cnVjdCByZWYgKip0YWlsID0gJnJldDsKCXdoaWxlIChyZWYpIHsKCQkqdGFpbCA9IGNvcHlfcmVmKHJlZik7CgkJcmVmID0gcmVmLT5uZXh0OwoJCXRhaWwgPSAmKCgqdGFpbCktPm5leHQpOwoJfQoJcmV0dXJuIHJldDsKfQoKc3RhdGljIHZvaWQgZnJlZV9yZWYoc3RydWN0IHJlZiAqcmVmKQp7CglpZiAoIXJlZikKCQlyZXR1cm47CglmcmVlX3JlZihyZWYtPnBlZXJfcmVmKTsKCWZyZWUocmVmLT5yZW1vdGVfc3RhdHVzKTsKCWZyZWUocmVmLT5zeW1yZWYpOwoJZnJlZShyZWYpOwp9Cgp2b2lkIGZyZWVfcmVmcyhzdHJ1Y3QgcmVmICpyZWYpCnsKCXN0cnVjdCByZWYgKm5leHQ7Cgl3aGlsZSAocmVmKSB7CgkJbmV4dCA9IHJlZi0+bmV4dDsKCQlmcmVlX3JlZihyZWYpOwoJCXJlZiA9IG5leHQ7Cgl9Cn0KCmludCByZWZfY29tcGFyZV9uYW1lKGNvbnN0IHZvaWQgKnZhLCBjb25zdCB2b2lkICp2YikKewoJY29uc3Qgc3RydWN0IHJlZiAqYSA9IHZhLCAqYiA9IHZiOwoJcmV0dXJuIHN0cmNtcChhLT5uYW1lLCBiLT5uYW1lKTsKfQoKc3RhdGljIHZvaWQgKnJlZl9saXN0X2dldF9uZXh0KGNvbnN0IHZvaWQgKmEpCnsKCXJldHVybiAoKGNvbnN0IHN0cnVjdCByZWYgKilhKS0+bmV4dDsKfQoKc3RhdGljIHZvaWQgcmVmX2xpc3Rfc2V0X25leHQodm9pZCAqYSwgdm9pZCAqbmV4dCkKewoJKChzdHJ1Y3QgcmVmICopYSktPm5leHQgPSBuZXh0Owp9Cgp2b2lkIHNvcnRfcmVmX2xpc3Qoc3RydWN0IHJlZiAqKmwsIGludCAoKmNtcCkoY29uc3Qgdm9pZCAqLCBjb25zdCB2b2lkICopKQp7CgkqbCA9IGxsaXN0X21lcmdlc29ydCgqbCwgcmVmX2xpc3RfZ2V0X25leHQsIHJlZl9saXN0X3NldF9uZXh0LCBjbXApOwp9CgppbnQgY291bnRfcmVmc3BlY19tYXRjaChjb25zdCBjaGFyICpwYXR0ZXJuLAoJCQlzdHJ1Y3QgcmVmICpyZWZzLAoJCQlzdHJ1Y3QgcmVmICoqbWF0Y2hlZF9yZWYpCnsKCWludCBwYXRsZW4gPSBzdHJsZW4ocGF0dGVybik7CglzdHJ1Y3QgcmVmICptYXRjaGVkX3dlYWsgPSBOVUxMOwoJc3RydWN0IHJlZiAqbWF0Y2hlZCA9IE5VTEw7CglpbnQgd2Vha19tYXRjaCA9IDA7CglpbnQgbWF0Y2ggPSAwOwoKCWZvciAod2Vha19tYXRjaCA9IG1hdGNoID0gMDsgcmVmczsgcmVmcyA9IHJlZnMtPm5leHQpIHsKCQljaGFyICpuYW1lID0gcmVmcy0+bmFtZTsKCQlpbnQgbmFtZWxlbiA9IHN0cmxlbihuYW1lKTsKCgkJaWYgKCFyZWZuYW1lX21hdGNoKHBhdHRlcm4sIG5hbWUpKQoJCQljb250aW51ZTsKCgkJLyogQSBtYXRjaCBpcyAid2VhayIgaWYgaXQgaXMgd2l0aCByZWZzIG91dHNpZGUKCQkgKiBoZWFkcyBvciB0YWdzLCBhbmQgZGlkIG5vdCBzcGVjaWZ5IHRoZSBwYXR0ZXJuCgkJICogaW4gZnVsbCAoZS5nLiAicmVmcy9yZW1vdGVzL29yaWdpbi9tYXN0ZXIiKSBvciBhdAoJCSAqIGxlYXN0IGZyb20gdGhlIHRvcGxldmVsIChlLmcuICJyZW1vdGVzL29yaWdpbi9tYXN0ZXIiKTsKCQkgKiBvdGhlcndpc2UgImdpdCBwdXNoICRVUkwgbWFzdGVyIiB3b3VsZCByZXN1bHQgaW4KCQkgKiBhbWJpZ3VpdHkgYmV0d2VlbiByZW1vdGVzL29yaWdpbi9tYXN0ZXIgYW5kIGhlYWRzL21hc3RlcgoJCSAqIGF0IHRoZSByZW1vdGUgc2l0ZS4KCQkgKi8KCQlpZiAobmFtZWxlbiAhPSBwYXRsZW4gJiYKCQkgICAgcGF0bGVuICE9IG5hbWVsZW4gLSA1ICYmCgkJICAgICFzdGFydHNfd2l0aChuYW1lLCAicmVmcy9oZWFkcy8iKSAmJgoJCSAgICAhc3RhcnRzX3dpdGgobmFtZSwgInJlZnMvdGFncy8iKSkgewoJCQkvKiBXZSB3YW50IHRvIGNhdGNoIHRoZSBjYXNlIHdoZXJlIG9ubHkgd2VhawoJCQkgKiBtYXRjaGVzIGFyZSBmb3VuZCBhbmQgdGhlcmUgYXJlIG11bHRpcGxlCgkJCSAqIG1hdGNoZXMsIGFuZCB3aGVyZSBtb3JlIHRoYW4gb25lIHN0cm9uZwoJCQkgKiBtYXRjaGVzIGFyZSBmb3VuZCwgYXMgYW1iaWd1b3VzLiAgT25lCgkJCSAqIHN0cm9uZyBtYXRjaCB3aXRoIHplcm8gb3IgbW9yZSB3ZWFrIG1hdGNoZXMKCQkJICogYXJlIGFjY2VwdGFibGUgYXMgYSB1bmlxdWUgbWF0Y2guCgkJCSAqLwoJCQltYXRjaGVkX3dlYWsgPSByZWZzOwoJCQl3ZWFrX21hdGNoKys7CgkJfQoJCWVsc2UgewoJCQltYXRjaGVkID0gcmVmczsKCQkJbWF0Y2grKzsKCQl9Cgl9CglpZiAoIW1hdGNoZWQpIHsKCQlpZiAobWF0Y2hlZF9yZWYpCgkJCSptYXRjaGVkX3JlZiA9IG1hdGNoZWRfd2VhazsKCQlyZXR1cm4gd2Vha19tYXRjaDsKCX0KCWVsc2UgewoJCWlmIChtYXRjaGVkX3JlZikKCQkJKm1hdGNoZWRfcmVmID0gbWF0Y2hlZDsKCQlyZXR1cm4gbWF0Y2g7Cgl9Cn0KCnN0YXRpYyB2b2lkIHRhaWxfbGlua19yZWYoc3RydWN0IHJlZiAqcmVmLCBzdHJ1Y3QgcmVmICoqKnRhaWwpCnsKCSoqdGFpbCA9IHJlZjsKCXdoaWxlIChyZWYtPm5leHQpCgkJcmVmID0gcmVmLT5uZXh0OwoJKnRhaWwgPSAmcmVmLT5uZXh0Owp9CgpzdGF0aWMgc3RydWN0IHJlZiAqYWxsb2NfZGVsZXRlX3JlZih2b2lkKQp7CglzdHJ1Y3QgcmVmICpyZWYgPSBhbGxvY19yZWYoIihkZWxldGUpIik7CglvaWRjbHIoJnJlZi0+bmV3X29pZCk7CglyZXR1cm4gcmVmOwp9CgpzdGF0aWMgaW50IHRyeV9leHBsaWNpdF9vYmplY3RfbmFtZShjb25zdCBjaGFyICpuYW1lLAoJCQkJICAgIHN0cnVjdCByZWYgKiptYXRjaCkKewoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CgoJaWYgKCEqbmFtZSkgewoJCWlmIChtYXRjaCkKCQkJKm1hdGNoID0gYWxsb2NfZGVsZXRlX3JlZigpOwoJCXJldHVybiAwOwoJfQoKCWlmIChnZXRfb2lkKG5hbWUsICZvaWQpKQoJCXJldHVybiAtMTsKCglpZiAobWF0Y2gpIHsKCQkqbWF0Y2ggPSBhbGxvY19yZWYobmFtZSk7CgkJb2lkY3B5KCYoKm1hdGNoKS0+bmV3X29pZCwgJm9pZCk7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIHN0cnVjdCByZWYgKm1ha2VfbGlua2VkX3JlZihjb25zdCBjaGFyICpuYW1lLCBzdHJ1Y3QgcmVmICoqKnRhaWwpCnsKCXN0cnVjdCByZWYgKnJldCA9IGFsbG9jX3JlZihuYW1lKTsKCXRhaWxfbGlua19yZWYocmV0LCB0YWlsKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBjaGFyICpndWVzc19yZWYoY29uc3QgY2hhciAqbmFtZSwgc3RydWN0IHJlZiAqcGVlcikKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCgljb25zdCBjaGFyICpyID0gcmVzb2x2ZV9yZWZfdW5zYWZlKHBlZXItPm5hbWUsIFJFU09MVkVfUkVGX1JFQURJTkcsCgkJCQkJICAgTlVMTCwgTlVMTCk7CglpZiAoIXIpCgkJcmV0dXJuIE5VTEw7CgoJaWYgKHN0YXJ0c193aXRoKHIsICJyZWZzL2hlYWRzLyIpKQoJCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgInJlZnMvaGVhZHMvIik7CgllbHNlIGlmIChzdGFydHNfd2l0aChyLCAicmVmcy90YWdzLyIpKQoJCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgInJlZnMvdGFncy8iKTsKCWVsc2UKCQlyZXR1cm4gTlVMTDsKCglzdHJidWZfYWRkc3RyKCZidWYsIG5hbWUpOwoJcmV0dXJuIHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7Cn0KCnN0YXRpYyBpbnQgbWF0Y2hfZXhwbGljaXRfbGhzKHN0cnVjdCByZWYgKnNyYywKCQkJICAgICAgc3RydWN0IHJlZnNwZWNfaXRlbSAqcnMsCgkJCSAgICAgIHN0cnVjdCByZWYgKiptYXRjaCwKCQkJICAgICAgaW50ICphbGxvY2F0ZWRfbWF0Y2gpCnsKCXN3aXRjaCAoY291bnRfcmVmc3BlY19tYXRjaChycy0+c3JjLCBzcmMsIG1hdGNoKSkgewoJY2FzZSAxOgoJCWlmIChhbGxvY2F0ZWRfbWF0Y2gpCgkJCSphbGxvY2F0ZWRfbWF0Y2ggPSAwOwoJCXJldHVybiAwOwoJY2FzZSAwOgoJCS8qIFRoZSBzb3VyY2UgY291bGQgYmUgaW4gdGhlIGdldF9zaGExKCkgZm9ybWF0CgkJICogbm90IGEgcmVmZXJlbmNlIG5hbWUuICA6cmVmcy9vdGhlciBpcyBhCgkJICogd2F5IHRvIGRlbGV0ZSAnb3RoZXInIHJlZiBhdCB0aGUgcmVtb3RlIGVuZC4KCQkgKi8KCQlpZiAodHJ5X2V4cGxpY2l0X29iamVjdF9uYW1lKHJzLT5zcmMsIG1hdGNoKSA8IDApCgkJCXJldHVybiBlcnJvcigic3JjIHJlZnNwZWMgJXMgZG9lcyBub3QgbWF0Y2ggYW55LiIsIHJzLT5zcmMpOwoJCWlmIChhbGxvY2F0ZWRfbWF0Y2gpCgkJCSphbGxvY2F0ZWRfbWF0Y2ggPSAxOwoJCXJldHVybiAwOwoJZGVmYXVsdDoKCQlyZXR1cm4gZXJyb3IoInNyYyByZWZzcGVjICVzIG1hdGNoZXMgbW9yZSB0aGFuIG9uZS4iLCBycy0+c3JjKTsKCX0KfQoKc3RhdGljIGludCBtYXRjaF9leHBsaWNpdChzdHJ1Y3QgcmVmICpzcmMsIHN0cnVjdCByZWYgKmRzdCwKCQkJICBzdHJ1Y3QgcmVmICoqKmRzdF90YWlsLAoJCQkgIHN0cnVjdCByZWZzcGVjX2l0ZW0gKnJzKQp7CglzdHJ1Y3QgcmVmICptYXRjaGVkX3NyYywgKm1hdGNoZWRfZHN0OwoJaW50IGFsbG9jYXRlZF9zcmM7CgoJY29uc3QgY2hhciAqZHN0X3ZhbHVlID0gcnMtPmRzdDsKCWNoYXIgKmRzdF9ndWVzczsKCglpZiAocnMtPnBhdHRlcm4gfHwgcnMtPm1hdGNoaW5nKQoJCXJldHVybiAwOwoKCW1hdGNoZWRfc3JjID0gbWF0Y2hlZF9kc3QgPSBOVUxMOwoJaWYgKG1hdGNoX2V4cGxpY2l0X2xocyhzcmMsIHJzLCAmbWF0Y2hlZF9zcmMsICZhbGxvY2F0ZWRfc3JjKSA8IDApCgkJcmV0dXJuIC0xOwoKCWlmICghZHN0X3ZhbHVlKSB7CgkJaW50IGZsYWc7CgoJCWRzdF92YWx1ZSA9IHJlc29sdmVfcmVmX3Vuc2FmZShtYXRjaGVkX3NyYy0+bmFtZSwKCQkJCQkgICAgICAgUkVTT0xWRV9SRUZfUkVBRElORywKCQkJCQkgICAgICAgTlVMTCwgJmZsYWcpOwoJCWlmICghZHN0X3ZhbHVlIHx8CgkJICAgICgoZmxhZyAmIFJFRl9JU1NZTVJFRikgJiYKCQkgICAgICFzdGFydHNfd2l0aChkc3RfdmFsdWUsICJyZWZzL2hlYWRzLyIpKSkKCQkJZGllKCIlcyBjYW5ub3QgYmUgcmVzb2x2ZWQgdG8gYnJhbmNoLiIsCgkJCSAgICBtYXRjaGVkX3NyYy0+bmFtZSk7Cgl9CgoJc3dpdGNoIChjb3VudF9yZWZzcGVjX21hdGNoKGRzdF92YWx1ZSwgZHN0LCAmbWF0Y2hlZF9kc3QpKSB7CgljYXNlIDE6CgkJYnJlYWs7CgljYXNlIDA6CgkJaWYgKHN0YXJ0c193aXRoKGRzdF92YWx1ZSwgInJlZnMvIikpCgkJCW1hdGNoZWRfZHN0ID0gbWFrZV9saW5rZWRfcmVmKGRzdF92YWx1ZSwgZHN0X3RhaWwpOwoJCWVsc2UgaWYgKGlzX251bGxfb2lkKCZtYXRjaGVkX3NyYy0+bmV3X29pZCkpCgkJCWVycm9yKCJ1bmFibGUgdG8gZGVsZXRlICclcyc6IHJlbW90ZSByZWYgZG9lcyBub3QgZXhpc3QiLAoJCQkgICAgICBkc3RfdmFsdWUpOwoJCWVsc2UgaWYgKChkc3RfZ3Vlc3MgPSBndWVzc19yZWYoZHN0X3ZhbHVlLCBtYXRjaGVkX3NyYykpKSB7CgkJCW1hdGNoZWRfZHN0ID0gbWFrZV9saW5rZWRfcmVmKGRzdF9ndWVzcywgZHN0X3RhaWwpOwoJCQlmcmVlKGRzdF9ndWVzcyk7CgkJfSBlbHNlCgkJCWVycm9yKCJ1bmFibGUgdG8gcHVzaCB0byB1bnF1YWxpZmllZCBkZXN0aW5hdGlvbjogJXNcbiIKCQkJICAgICAgIlRoZSBkZXN0aW5hdGlvbiByZWZzcGVjIG5laXRoZXIgbWF0Y2hlcyBhbiAiCgkJCSAgICAgICJleGlzdGluZyByZWYgb24gdGhlIHJlbW90ZSBub3JcbiIKCQkJICAgICAgImJlZ2lucyB3aXRoIHJlZnMvLCBhbmQgd2UgYXJlIHVuYWJsZSB0byAiCgkJCSAgICAgICJndWVzcyBhIHByZWZpeCBiYXNlZCBvbiB0aGUgc291cmNlIHJlZi4iLAoJCQkgICAgICBkc3RfdmFsdWUpOwoJCWJyZWFrOwoJZGVmYXVsdDoKCQltYXRjaGVkX2RzdCA9IE5VTEw7CgkJZXJyb3IoImRzdCByZWZzcGVjICVzIG1hdGNoZXMgbW9yZSB0aGFuIG9uZS4iLAoJCSAgICAgIGRzdF92YWx1ZSk7CgkJYnJlYWs7Cgl9CglpZiAoIW1hdGNoZWRfZHN0KQoJCXJldHVybiAtMTsKCWlmIChtYXRjaGVkX2RzdC0+cGVlcl9yZWYpCgkJcmV0dXJuIGVycm9yKCJkc3QgcmVmICVzIHJlY2VpdmVzIGZyb20gbW9yZSB0aGFuIG9uZSBzcmMuIiwKCQkgICAgICBtYXRjaGVkX2RzdC0+bmFtZSk7CgllbHNlIHsKCQltYXRjaGVkX2RzdC0+cGVlcl9yZWYgPSBhbGxvY2F0ZWRfc3JjID8KCQkJCQltYXRjaGVkX3NyYyA6CgkJCQkJY29weV9yZWYobWF0Y2hlZF9zcmMpOwoJCW1hdGNoZWRfZHN0LT5mb3JjZSA9IHJzLT5mb3JjZTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IG1hdGNoX2V4cGxpY2l0X3JlZnMoc3RydWN0IHJlZiAqc3JjLCBzdHJ1Y3QgcmVmICpkc3QsCgkJCSAgICAgICBzdHJ1Y3QgcmVmICoqKmRzdF90YWlsLCBzdHJ1Y3QgcmVmc3BlYyAqcnMpCnsKCWludCBpLCBlcnJzOwoJZm9yIChpID0gZXJycyA9IDA7IGkgPCBycy0+bnI7IGkrKykKCQllcnJzICs9IG1hdGNoX2V4cGxpY2l0KHNyYywgZHN0LCBkc3RfdGFpbCwgJnJzLT5pdGVtc1tpXSk7CglyZXR1cm4gZXJyczsKfQoKc3RhdGljIGNoYXIgKmdldF9yZWZfbWF0Y2goY29uc3Qgc3RydWN0IHJlZnNwZWMgKnJzLCBjb25zdCBzdHJ1Y3QgcmVmICpyZWYsCgkJCSAgIGludCBzZW5kX21pcnJvciwgaW50IGRpcmVjdGlvbiwKCQkJICAgY29uc3Qgc3RydWN0IHJlZnNwZWNfaXRlbSAqKnJldF9wYXQpCnsKCWNvbnN0IHN0cnVjdCByZWZzcGVjX2l0ZW0gKnBhdDsKCWNoYXIgKm5hbWU7CglpbnQgaTsKCWludCBtYXRjaGluZ19yZWZzID0gLTE7Cglmb3IgKGkgPSAwOyBpIDwgcnMtPm5yOyBpKyspIHsKCQljb25zdCBzdHJ1Y3QgcmVmc3BlY19pdGVtICppdGVtID0gJnJzLT5pdGVtc1tpXTsKCQlpZiAoaXRlbS0+bWF0Y2hpbmcgJiYKCQkgICAgKG1hdGNoaW5nX3JlZnMgPT0gLTEgfHwgaXRlbS0+Zm9yY2UpKSB7CgkJCW1hdGNoaW5nX3JlZnMgPSBpOwoJCQljb250aW51ZTsKCQl9CgoJCWlmIChpdGVtLT5wYXR0ZXJuKSB7CgkJCWNvbnN0IGNoYXIgKmRzdF9zaWRlID0gaXRlbS0+ZHN0ID8gaXRlbS0+ZHN0IDogaXRlbS0+c3JjOwoJCQlpbnQgbWF0Y2g7CgkJCWlmIChkaXJlY3Rpb24gPT0gRlJPTV9TUkMpCgkJCQltYXRjaCA9IG1hdGNoX25hbWVfd2l0aF9wYXR0ZXJuKGl0ZW0tPnNyYywgcmVmLT5uYW1lLCBkc3Rfc2lkZSwgJm5hbWUpOwoJCQllbHNlCgkJCQltYXRjaCA9IG1hdGNoX25hbWVfd2l0aF9wYXR0ZXJuKGRzdF9zaWRlLCByZWYtPm5hbWUsIGl0ZW0tPnNyYywgJm5hbWUpOwoJCQlpZiAobWF0Y2gpIHsKCQkJCW1hdGNoaW5nX3JlZnMgPSBpOwoJCQkJYnJlYWs7CgkJCX0KCQl9Cgl9CglpZiAobWF0Y2hpbmdfcmVmcyA9PSAtMSkKCQlyZXR1cm4gTlVMTDsKCglwYXQgPSAmcnMtPml0ZW1zW21hdGNoaW5nX3JlZnNdOwoJaWYgKHBhdC0+bWF0Y2hpbmcpIHsKCQkvKgoJCSAqICJtYXRjaGluZyByZWZzIjsgdHJhZGl0aW9uYWxseSB3ZSBwdXNoZWQgZXZlcnl0aGluZwoJCSAqIGluY2x1ZGluZyByZWZzIG91dHNpZGUgcmVmcy9oZWFkcy8gaGllcmFyY2h5LCBidXQKCQkgKiB0aGF0IGRvZXMgbm90IG1ha2UgbXVjaCBzZW5zZSB0aGVzZSBkYXlzLgoJCSAqLwoJCWlmICghc2VuZF9taXJyb3IgJiYgIXN0YXJ0c193aXRoKHJlZi0+bmFtZSwgInJlZnMvaGVhZHMvIikpCgkJCXJldHVybiBOVUxMOwoJCW5hbWUgPSB4c3RyZHVwKHJlZi0+bmFtZSk7Cgl9CglpZiAocmV0X3BhdCkKCQkqcmV0X3BhdCA9IHBhdDsKCXJldHVybiBuYW1lOwp9CgpzdGF0aWMgc3RydWN0IHJlZiAqKnRhaWxfcmVmKHN0cnVjdCByZWYgKipoZWFkKQp7CglzdHJ1Y3QgcmVmICoqdGFpbCA9IGhlYWQ7Cgl3aGlsZSAoKnRhaWwpCgkJdGFpbCA9ICYoKCp0YWlsKS0+bmV4dCk7CglyZXR1cm4gdGFpbDsKfQoKc3RydWN0IHRpcHMgewoJc3RydWN0IGNvbW1pdCAqKnRpcDsKCWludCBuciwgYWxsb2M7Cn07CgpzdGF0aWMgdm9pZCBhZGRfdG9fdGlwcyhzdHJ1Y3QgdGlwcyAqdGlwcywgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgoJaWYgKGlzX251bGxfb2lkKG9pZCkpCgkJcmV0dXJuOwoJY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfZ2VudGx5KG9pZCwgMSk7CglpZiAoIWNvbW1pdCB8fCAoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBUTVBfTUFSSykpCgkJcmV0dXJuOwoJY29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gVE1QX01BUks7CglBTExPQ19HUk9XKHRpcHMtPnRpcCwgdGlwcy0+bnIgKyAxLCB0aXBzLT5hbGxvYyk7Cgl0aXBzLT50aXBbdGlwcy0+bnIrK10gPSBjb21taXQ7Cn0KCnN0YXRpYyB2b2lkIGFkZF9taXNzaW5nX3RhZ3Moc3RydWN0IHJlZiAqc3JjLCBzdHJ1Y3QgcmVmICoqZHN0LCBzdHJ1Y3QgcmVmICoqKmRzdF90YWlsKQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgZHN0X3RhZyA9IFNUUklOR19MSVNUX0lOSVRfTk9EVVA7CglzdHJ1Y3Qgc3RyaW5nX2xpc3Qgc3JjX3RhZyA9IFNUUklOR19MSVNUX0lOSVRfTk9EVVA7CglzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbTsKCXN0cnVjdCByZWYgKnJlZjsKCXN0cnVjdCB0aXBzIHNlbnRfdGlwczsKCgkvKgoJICogQ29sbGVjdCBldmVyeXRoaW5nIHdlIGtub3cgdGhleSB3b3VsZCBoYXZlIGF0IHRoZSBlbmQgb2YKCSAqIHRoaXMgcHVzaCwgYW5kIGNvbGxlY3QgYWxsIHRhZ3MgdGhleSBoYXZlLgoJICovCgltZW1zZXQoJnNlbnRfdGlwcywgMCwgc2l6ZW9mKHNlbnRfdGlwcykpOwoJZm9yIChyZWYgPSAqZHN0OyByZWY7IHJlZiA9IHJlZi0+bmV4dCkgewoJCWlmIChyZWYtPnBlZXJfcmVmICYmCgkJICAgICFpc19udWxsX29pZCgmcmVmLT5wZWVyX3JlZi0+bmV3X29pZCkpCgkJCWFkZF90b190aXBzKCZzZW50X3RpcHMsICZyZWYtPnBlZXJfcmVmLT5uZXdfb2lkKTsKCQllbHNlCgkJCWFkZF90b190aXBzKCZzZW50X3RpcHMsICZyZWYtPm9sZF9vaWQpOwoJCWlmIChzdGFydHNfd2l0aChyZWYtPm5hbWUsICJyZWZzL3RhZ3MvIikpCgkJCXN0cmluZ19saXN0X2FwcGVuZCgmZHN0X3RhZywgcmVmLT5uYW1lKTsKCX0KCWNsZWFyX2NvbW1pdF9tYXJrc19tYW55KHNlbnRfdGlwcy5uciwgc2VudF90aXBzLnRpcCwgVE1QX01BUkspOwoKCXN0cmluZ19saXN0X3NvcnQoJmRzdF90YWcpOwoKCS8qIENvbGxlY3QgdGFncyB0aGV5IGRvIG5vdCBoYXZlLiAqLwoJZm9yIChyZWYgPSBzcmM7IHJlZjsgcmVmID0gcmVmLT5uZXh0KSB7CgkJaWYgKCFzdGFydHNfd2l0aChyZWYtPm5hbWUsICJyZWZzL3RhZ3MvIikpCgkJCWNvbnRpbnVlOyAvKiBub3QgYSB0YWcgKi8KCQlpZiAoc3RyaW5nX2xpc3RfaGFzX3N0cmluZygmZHN0X3RhZywgcmVmLT5uYW1lKSkKCQkJY29udGludWU7IC8qIHRoZXkgYWxyZWFkeSBoYXZlIGl0ICovCgkJaWYgKG9pZF9vYmplY3RfaW5mbygmcmVmLT5uZXdfb2lkLCBOVUxMKSAhPSBPQkpfVEFHKQoJCQljb250aW51ZTsgLyogYmUgY29uc2VydmF0aXZlICovCgkJaXRlbSA9IHN0cmluZ19saXN0X2FwcGVuZCgmc3JjX3RhZywgcmVmLT5uYW1lKTsKCQlpdGVtLT51dGlsID0gcmVmOwoJfQoJc3RyaW5nX2xpc3RfY2xlYXIoJmRzdF90YWcsIDApOwoKCS8qCgkgKiBBdCB0aGlzIHBvaW50LCBzcmNfdGFnIGxpc3RzIHRhZ3MgdGhhdCBhcmUgbWlzc2luZyBmcm9tCgkgKiBkc3QsIGFuZCBzZW50X3RpcHMgbGlzdHMgdGhlIHRpcHMgd2UgYXJlIHB1c2hpbmcgb3IgdGhvc2UKCSAqIHRoYXQgd2Uga25vdyB0aGV5IGFscmVhZHkgaGF2ZS4gQW4gZWxlbWVudCBpbiB0aGUgc3JjX3RhZwoJICogdGhhdCBpcyBhbiBhbmNlc3RvciBvZiBhbnkgb2YgdGhlIHNlbnRfdGlwcyBuZWVkcyB0byBiZQoJICogc2VudCB0byB0aGUgb3RoZXIgc2lkZS4KCSAqLwoJaWYgKHNlbnRfdGlwcy5ucikgewoJCWZvcl9lYWNoX3N0cmluZ19saXN0X2l0ZW0oaXRlbSwgJnNyY190YWcpIHsKCQkJc3RydWN0IHJlZiAqcmVmID0gaXRlbS0+dXRpbDsKCQkJc3RydWN0IHJlZiAqZHN0X3JlZjsKCQkJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoKCQkJaWYgKGlzX251bGxfb2lkKCZyZWYtPm5ld19vaWQpKQoJCQkJY29udGludWU7CgkJCWNvbW1pdCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseSgmcmVmLT5uZXdfb2lkLAoJCQkJCQkJCTEpOwoJCQlpZiAoIWNvbW1pdCkKCQkJCS8qIG5vdCBwdXNoaW5nIGEgY29tbWl0LCB3aGljaCBpcyBub3QgYW4gZXJyb3IgKi8KCQkJCWNvbnRpbnVlOwoKCQkJLyoKCQkJICogSXMgdGhpcyB0YWcsIHdoaWNoIHRoZXkgZG8gbm90IGhhdmUsIHJlYWNoYWJsZSBmcm9tCgkJCSAqIGFueSBvZiB0aGUgY29tbWl0cyB3ZSBhcmUgc2VuZGluZz8KCQkJICovCgkJCWlmICghaW5fbWVyZ2VfYmFzZXNfbWFueShjb21taXQsIHNlbnRfdGlwcy5uciwgc2VudF90aXBzLnRpcCkpCgkJCQljb250aW51ZTsKCgkJCS8qIEFkZCBpdCBpbiAqLwoJCQlkc3RfcmVmID0gbWFrZV9saW5rZWRfcmVmKHJlZi0+bmFtZSwgZHN0X3RhaWwpOwoJCQlvaWRjcHkoJmRzdF9yZWYtPm5ld19vaWQsICZyZWYtPm5ld19vaWQpOwoJCQlkc3RfcmVmLT5wZWVyX3JlZiA9IGNvcHlfcmVmKHJlZik7CgkJfQoJfQoJc3RyaW5nX2xpc3RfY2xlYXIoJnNyY190YWcsIDApOwoJZnJlZShzZW50X3RpcHMudGlwKTsKfQoKc3RydWN0IHJlZiAqZmluZF9yZWZfYnlfbmFtZShjb25zdCBzdHJ1Y3QgcmVmICpsaXN0LCBjb25zdCBjaGFyICpuYW1lKQp7Cglmb3IgKCA7IGxpc3Q7IGxpc3QgPSBsaXN0LT5uZXh0KQoJCWlmICghc3RyY21wKGxpc3QtPm5hbWUsIG5hbWUpKQoJCQlyZXR1cm4gKHN0cnVjdCByZWYgKilsaXN0OwoJcmV0dXJuIE5VTEw7Cn0KCnN0YXRpYyB2b2lkIHByZXBhcmVfcmVmX2luZGV4KHN0cnVjdCBzdHJpbmdfbGlzdCAqcmVmX2luZGV4LCBzdHJ1Y3QgcmVmICpyZWYpCnsKCWZvciAoIDsgcmVmOyByZWYgPSByZWYtPm5leHQpCgkJc3RyaW5nX2xpc3RfYXBwZW5kX25vZHVwKHJlZl9pbmRleCwgcmVmLT5uYW1lKS0+dXRpbCA9IHJlZjsKCglzdHJpbmdfbGlzdF9zb3J0KHJlZl9pbmRleCk7Cn0KCi8qCiAqIEdpdmVuIG9ubHkgdGhlIHNldCBvZiBsb2NhbCByZWZzLCBzYW5pdHktY2hlY2sgdGhlIHNldCBvZiBwdXNoCiAqIHJlZnNwZWNzLiBXZSBjYW4ndCBjYXRjaCBhbGwgZXJyb3JzIHRoYXQgbWF0Y2hfcHVzaF9yZWZzIHdvdWxkLAogKiBidXQgd2UgY2FuIGNhdGNoIHNvbWUgZXJyb3JzIGVhcmx5IGJlZm9yZSBldmVuIHRhbGtpbmcgdG8gdGhlCiAqIHJlbW90ZSBzaWRlLgogKi8KaW50IGNoZWNrX3B1c2hfcmVmcyhzdHJ1Y3QgcmVmICpzcmMsIGludCBucl9yZWZzcGVjLCBjb25zdCBjaGFyICoqcmVmc3BlY19uYW1lcykKewoJc3RydWN0IHJlZnNwZWMgcmVmc3BlYyA9IFJFRlNQRUNfSU5JVF9QVVNIOwoJaW50IHJldCA9IDA7CglpbnQgaTsKCglyZWZzcGVjX2FwcGVuZG4oJnJlZnNwZWMsIHJlZnNwZWNfbmFtZXMsIG5yX3JlZnNwZWMpOwoKCWZvciAoaSA9IDA7IGkgPCByZWZzcGVjLm5yOyBpKyspIHsKCQlzdHJ1Y3QgcmVmc3BlY19pdGVtICpycyA9ICZyZWZzcGVjLml0ZW1zW2ldOwoKCQlpZiAocnMtPnBhdHRlcm4gfHwgcnMtPm1hdGNoaW5nKQoJCQljb250aW51ZTsKCgkJcmV0IHw9IG1hdGNoX2V4cGxpY2l0X2xocyhzcmMsIHJzLCBOVUxMLCBOVUxMKTsKCX0KCglyZWZzcGVjX2NsZWFyKCZyZWZzcGVjKTsKCXJldHVybiByZXQ7Cn0KCi8qCiAqIEdpdmVuIHRoZSBzZXQgb2YgcmVmcyB0aGUgbG9jYWwgcmVwb3NpdG9yeSBoYXMsIHRoZSBzZXQgb2YgcmVmcyB0aGUKICogcmVtb3RlIHJlcG9zaXRvcnkgaGFzLCBhbmQgdGhlIHJlZnNwZWMgdXNlZCBmb3IgcHVzaCwgZGV0ZXJtaW5lCiAqIHdoYXQgcmVtb3RlIHJlZnMgd2Ugd2lsbCB1cGRhdGUgYW5kIHdpdGggd2hhdCB2YWx1ZSBieSBzZXR0aW5nCiAqIHBlZXJfcmVmICh3aGljaCBvYmplY3QgaXMgYmVpbmcgcHVzaGVkKSBhbmQgZm9yY2UgKGlmIHRoZSBwdXNoIGlzCiAqIGZvcmNlZCkgaW4gZWxlbWVudHMgb2YgImRzdCIuIFRoZSBmdW5jdGlvbiBtYXkgYWRkIG5ldyBlbGVtZW50cyB0bwogKiBkc3QgKGUuZy4gcHVzaGluZyB0byBhIG5ldyBicmFuY2gsIGRvbmUgaW4gbWF0Y2hfZXhwbGljaXRfcmVmcykuCiAqLwppbnQgbWF0Y2hfcHVzaF9yZWZzKHN0cnVjdCByZWYgKnNyYywgc3RydWN0IHJlZiAqKmRzdCwKCQkgICAgc3RydWN0IHJlZnNwZWMgKnJzLCBpbnQgZmxhZ3MpCnsKCWludCBzZW5kX2FsbCA9IGZsYWdzICYgTUFUQ0hfUkVGU19BTEw7CglpbnQgc2VuZF9taXJyb3IgPSBmbGFncyAmIE1BVENIX1JFRlNfTUlSUk9SOwoJaW50IHNlbmRfcHJ1bmUgPSBmbGFncyAmIE1BVENIX1JFRlNfUFJVTkU7CglpbnQgZXJyczsKCXN0cnVjdCByZWYgKnJlZiwgKipkc3RfdGFpbCA9IHRhaWxfcmVmKGRzdCk7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgZHN0X3JlZl9pbmRleCA9IFNUUklOR19MSVNUX0lOSVRfTk9EVVA7CgoJLyogSWYgbm8gcmVmc3BlYyBpcyBwcm92aWRlZCwgdXNlIHRoZSBkZWZhdWx0ICI6IiAqLwoJaWYgKCFycy0+bnIpCgkJcmVmc3BlY19hcHBlbmQocnMsICI6Iik7CgoJZXJycyA9IG1hdGNoX2V4cGxpY2l0X3JlZnMoc3JjLCAqZHN0LCAmZHN0X3RhaWwsIHJzKTsKCgkvKiBwaWNrIHRoZSByZW1haW5kZXIgKi8KCWZvciAocmVmID0gc3JjOyByZWY7IHJlZiA9IHJlZi0+bmV4dCkgewoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICpkc3RfaXRlbTsKCQlzdHJ1Y3QgcmVmICpkc3RfcGVlcjsKCQljb25zdCBzdHJ1Y3QgcmVmc3BlY19pdGVtICpwYXQgPSBOVUxMOwoJCWNoYXIgKmRzdF9uYW1lOwoKCQlkc3RfbmFtZSA9IGdldF9yZWZfbWF0Y2gocnMsIHJlZiwgc2VuZF9taXJyb3IsIEZST01fU1JDLCAmcGF0KTsKCQlpZiAoIWRzdF9uYW1lKQoJCQljb250aW51ZTsKCgkJaWYgKCFkc3RfcmVmX2luZGV4Lm5yKQoJCQlwcmVwYXJlX3JlZl9pbmRleCgmZHN0X3JlZl9pbmRleCwgKmRzdCk7CgoJCWRzdF9pdGVtID0gc3RyaW5nX2xpc3RfbG9va3VwKCZkc3RfcmVmX2luZGV4LCBkc3RfbmFtZSk7CgkJZHN0X3BlZXIgPSBkc3RfaXRlbSA/IGRzdF9pdGVtLT51dGlsIDogTlVMTDsKCQlpZiAoZHN0X3BlZXIpIHsKCQkJaWYgKGRzdF9wZWVyLT5wZWVyX3JlZikKCQkJCS8qIFdlJ3JlIGFscmVhZHkgc2VuZGluZyBzb21ldGhpbmcgdG8gdGhpcyByZWYuICovCgkJCQlnb3RvIGZyZWVfbmFtZTsKCQl9IGVsc2UgewoJCQlpZiAocGF0LT5tYXRjaGluZyAmJiAhKHNlbmRfYWxsIHx8IHNlbmRfbWlycm9yKSkKCQkJCS8qCgkJCQkgKiBSZW1vdGUgZG9lc24ndCBoYXZlIGl0LCBhbmQgd2UgaGF2ZSBubwoJCQkJICogZXhwbGljaXQgcGF0dGVybiwgYW5kIHdlIGRvbid0IGhhdmUKCQkJCSAqIC0tYWxsIG9yIC0tbWlycm9yLgoJCQkJICovCgkJCQlnb3RvIGZyZWVfbmFtZTsKCgkJCS8qIENyZWF0ZSBhIG5ldyBvbmUgYW5kIGxpbmsgaXQgKi8KCQkJZHN0X3BlZXIgPSBtYWtlX2xpbmtlZF9yZWYoZHN0X25hbWUsICZkc3RfdGFpbCk7CgkJCW9pZGNweSgmZHN0X3BlZXItPm5ld19vaWQsICZyZWYtPm5ld19vaWQpOwoJCQlzdHJpbmdfbGlzdF9pbnNlcnQoJmRzdF9yZWZfaW5kZXgsCgkJCQlkc3RfcGVlci0+bmFtZSktPnV0aWwgPSBkc3RfcGVlcjsKCQl9CgkJZHN0X3BlZXItPnBlZXJfcmVmID0gY29weV9yZWYocmVmKTsKCQlkc3RfcGVlci0+Zm9yY2UgPSBwYXQtPmZvcmNlOwoJZnJlZV9uYW1lOgoJCWZyZWUoZHN0X25hbWUpOwoJfQoKCXN0cmluZ19saXN0X2NsZWFyKCZkc3RfcmVmX2luZGV4LCAwKTsKCglpZiAoZmxhZ3MgJiBNQVRDSF9SRUZTX0ZPTExPV19UQUdTKQoJCWFkZF9taXNzaW5nX3RhZ3Moc3JjLCBkc3QsICZkc3RfdGFpbCk7CgoJaWYgKHNlbmRfcHJ1bmUpIHsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3Qgc3JjX3JlZl9pbmRleCA9IFNUUklOR19MSVNUX0lOSVRfTk9EVVA7CgkJLyogY2hlY2sgZm9yIG1pc3NpbmcgcmVmcyBvbiB0aGUgcmVtb3RlICovCgkJZm9yIChyZWYgPSAqZHN0OyByZWY7IHJlZiA9IHJlZi0+bmV4dCkgewoJCQljaGFyICpzcmNfbmFtZTsKCgkJCWlmIChyZWYtPnBlZXJfcmVmKQoJCQkJLyogV2UncmUgYWxyZWFkeSBzZW5kaW5nIHNvbWV0aGluZyB0byB0aGlzIHJlZi4gKi8KCQkJCWNvbnRpbnVlOwoKCQkJc3JjX25hbWUgPSBnZXRfcmVmX21hdGNoKHJzLCByZWYsIHNlbmRfbWlycm9yLCBGUk9NX0RTVCwgTlVMTCk7CgkJCWlmIChzcmNfbmFtZSkgewoJCQkJaWYgKCFzcmNfcmVmX2luZGV4Lm5yKQoJCQkJCXByZXBhcmVfcmVmX2luZGV4KCZzcmNfcmVmX2luZGV4LCBzcmMpOwoJCQkJaWYgKCFzdHJpbmdfbGlzdF9oYXNfc3RyaW5nKCZzcmNfcmVmX2luZGV4LAoJCQkJCSAgICBzcmNfbmFtZSkpCgkJCQkJcmVmLT5wZWVyX3JlZiA9IGFsbG9jX2RlbGV0ZV9yZWYoKTsKCQkJCWZyZWUoc3JjX25hbWUpOwoJCQl9CgkJfQoJCXN0cmluZ19saXN0X2NsZWFyKCZzcmNfcmVmX2luZGV4LCAwKTsKCX0KCglpZiAoZXJycykKCQlyZXR1cm4gLTE7CglyZXR1cm4gMDsKfQoKdm9pZCBzZXRfcmVmX3N0YXR1c19mb3JfcHVzaChzdHJ1Y3QgcmVmICpyZW1vdGVfcmVmcywgaW50IHNlbmRfbWlycm9yLAoJCQkgICAgIGludCBmb3JjZV91cGRhdGUpCnsKCXN0cnVjdCByZWYgKnJlZjsKCglmb3IgKHJlZiA9IHJlbW90ZV9yZWZzOyByZWY7IHJlZiA9IHJlZi0+bmV4dCkgewoJCWludCBmb3JjZV9yZWZfdXBkYXRlID0gcmVmLT5mb3JjZSB8fCBmb3JjZV91cGRhdGU7CgkJaW50IHJlamVjdF9yZWFzb24gPSAwOwoKCQlpZiAocmVmLT5wZWVyX3JlZikKCQkJb2lkY3B5KCZyZWYtPm5ld19vaWQsICZyZWYtPnBlZXJfcmVmLT5uZXdfb2lkKTsKCQllbHNlIGlmICghc2VuZF9taXJyb3IpCgkJCWNvbnRpbnVlOwoKCQlyZWYtPmRlbGV0aW9uID0gaXNfbnVsbF9vaWQoJnJlZi0+bmV3X29pZCk7CgkJaWYgKCFyZWYtPmRlbGV0aW9uICYmCgkJCSFvaWRjbXAoJnJlZi0+b2xkX29pZCwgJnJlZi0+bmV3X29pZCkpIHsKCQkJcmVmLT5zdGF0dXMgPSBSRUZfU1RBVFVTX1VQVE9EQVRFOwoJCQljb250aW51ZTsKCQl9CgoJCS8qCgkJICogSWYgdGhlIHJlbW90ZSByZWYgaGFzIG1vdmVkIGFuZCBpcyBub3cgZGlmZmVyZW50CgkJICogZnJvbSB3aGF0IHdlIGV4cGVjdCwgcmVqZWN0IGFueSBwdXNoLgoJCSAqCgkJICogSXQgYWxzbyBpcyBhbiBlcnJvciBpZiB0aGUgdXNlciB0b2xkIHVzIHRvIGNoZWNrCgkJICogd2l0aCB0aGUgcmVtb3RlLXRyYWNraW5nIGJyYW5jaCB0byBmaW5kIHRoZSB2YWx1ZQoJCSAqIHRvIGV4cGVjdCwgYnV0IHdlIGRpZCBub3QgaGF2ZSBzdWNoIGEgdHJhY2tpbmcKCQkgKiBicmFuY2guCgkJICovCgkJaWYgKHJlZi0+ZXhwZWN0X29sZF9zaGExKSB7CgkJCWlmIChvaWRjbXAoJnJlZi0+b2xkX29pZCwgJnJlZi0+b2xkX29pZF9leHBlY3QpKQoJCQkJcmVqZWN0X3JlYXNvbiA9IFJFRl9TVEFUVVNfUkVKRUNUX1NUQUxFOwoJCQllbHNlCgkJCQkvKiBJZiB0aGUgcmVmIGlzbid0IHN0YWxlIHRoZW4gZm9yY2UgdGhlIHVwZGF0ZS4gKi8KCQkJCWZvcmNlX3JlZl91cGRhdGUgPSAxOwoJCX0KCgkJLyoKCQkgKiBJZiB0aGUgdXBkYXRlIGlzbid0IGFscmVhZHkgcmVqZWN0ZWQgdGhlbiBjaGVjawoJCSAqIHRoZSB1c3VhbCAibXVzdCBmYXN0LWZvcndhcmQiIHJ1bGVzLgoJCSAqCgkJICogRGVjaWRlIHdoZXRoZXIgYW4gaW5kaXZpZHVhbCByZWZzcGVjIEE6QiBjYW4gYmUKCQkgKiBwdXNoZWQuICBUaGUgcHVzaCB3aWxsIHN1Y2NlZWQgaWYgYW55IG9mIHRoZQoJCSAqIGZvbGxvd2luZyBhcmUgdHJ1ZToKCQkgKgoJCSAqICgxKSB0aGUgcmVtb3RlIHJlZmVyZW5jZSBCIGRvZXMgbm90IGV4aXN0CgkJICoKCQkgKiAoMikgdGhlIHJlbW90ZSByZWZlcmVuY2UgQiBpcyBiZWluZyByZW1vdmVkIChpLmUuLAoJCSAqICAgICBwdXNoaW5nIDpCIHdoZXJlIG5vIHNvdXJjZSBpcyBzcGVjaWZpZWQpCgkJICoKCQkgKiAoMykgdGhlIGRlc3RpbmF0aW9uIGlzIG5vdCB1bmRlciByZWZzL3RhZ3MvLCBhbmQKCQkgKiAgICAgaWYgdGhlIG9sZCBhbmQgbmV3IHZhbHVlIGlzIGEgY29tbWl0LCB0aGUgbmV3CgkJICogICAgIGlzIGEgZGVzY2VuZGFudCBvZiB0aGUgb2xkLgoJCSAqCgkJICogKDQpIGl0IGlzIGZvcmNlZCB1c2luZyB0aGUgK0E6QiBub3RhdGlvbiwgb3IgYnkKCQkgKiAgICAgcGFzc2luZyB0aGUgLS1mb3JjZSBhcmd1bWVudAoJCSAqLwoKCQlpZiAoIXJlamVjdF9yZWFzb24gJiYgIXJlZi0+ZGVsZXRpb24gJiYgIWlzX251bGxfb2lkKCZyZWYtPm9sZF9vaWQpKSB7CgkJCWlmIChzdGFydHNfd2l0aChyZWYtPm5hbWUsICJyZWZzL3RhZ3MvIikpCgkJCQlyZWplY3RfcmVhc29uID0gUkVGX1NUQVRVU19SRUpFQ1RfQUxSRUFEWV9FWElTVFM7CgkJCWVsc2UgaWYgKCFoYXNfb2JqZWN0X2ZpbGUoJnJlZi0+b2xkX29pZCkpCgkJCQlyZWplY3RfcmVhc29uID0gUkVGX1NUQVRVU19SRUpFQ1RfRkVUQ0hfRklSU1Q7CgkJCWVsc2UgaWYgKCFsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkoJnJlZi0+b2xkX29pZCwgMSkgfHwKCQkJCSAhbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfZ2VudGx5KCZyZWYtPm5ld19vaWQsIDEpKQoJCQkJcmVqZWN0X3JlYXNvbiA9IFJFRl9TVEFUVVNfUkVKRUNUX05FRURTX0ZPUkNFOwoJCQllbHNlIGlmICghcmVmX25ld2VyKCZyZWYtPm5ld19vaWQsICZyZWYtPm9sZF9vaWQpKQoJCQkJcmVqZWN0X3JlYXNvbiA9IFJFRl9TVEFUVVNfUkVKRUNUX05PTkZBU1RGT1JXQVJEOwoJCX0KCgkJLyoKCQkgKiAiLS1mb3JjZSIgd2lsbCBkZWZlYXQgYW55IHJlamVjdGlvbiBpbXBsZW1lbnRlZAoJCSAqIGJ5IHRoZSBydWxlcyBhYm92ZS4KCQkgKi8KCQlpZiAoIWZvcmNlX3JlZl91cGRhdGUpCgkJCXJlZi0+c3RhdHVzID0gcmVqZWN0X3JlYXNvbjsKCQllbHNlIGlmIChyZWplY3RfcmVhc29uKQoJCQlyZWYtPmZvcmNlZF91cGRhdGUgPSAxOwoJfQp9CgpzdGF0aWMgdm9pZCBzZXRfbWVyZ2Uoc3RydWN0IGJyYW5jaCAqcmV0KQp7CglzdHJ1Y3QgcmVtb3RlICpyZW1vdGU7CgljaGFyICpyZWY7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCWludCBpOwoKCWlmICghcmV0KQoJCXJldHVybjsgLyogbm8gYnJhbmNoICovCglpZiAocmV0LT5tZXJnZSkKCQlyZXR1cm47IC8qIGFscmVhZHkgcnVuICovCglpZiAoIXJldC0+cmVtb3RlX25hbWUgfHwgIXJldC0+bWVyZ2VfbnIpIHsKCQkvKgoJCSAqIG5vIG1lcmdlIGNvbmZpZzsgbGV0J3MgbWFrZSBzdXJlIHdlIGRvbid0IGNvbmZ1c2UgY2FsbGVycwoJCSAqIHdpdGggYSBub24temVybyBtZXJnZV9uciBidXQgYSBOVUxMIG1lcmdlCgkJICovCgkJcmV0LT5tZXJnZV9uciA9IDA7CgkJcmV0dXJuOwoJfQoKCXJlbW90ZSA9IHJlbW90ZV9nZXQocmV0LT5yZW1vdGVfbmFtZSk7CgoJcmV0LT5tZXJnZSA9IHhjYWxsb2MocmV0LT5tZXJnZV9uciwgc2l6ZW9mKCpyZXQtPm1lcmdlKSk7Cglmb3IgKGkgPSAwOyBpIDwgcmV0LT5tZXJnZV9ucjsgaSsrKSB7CgkJcmV0LT5tZXJnZVtpXSA9IHhjYWxsb2MoMSwgc2l6ZW9mKCoqcmV0LT5tZXJnZSkpOwoJCXJldC0+bWVyZ2VbaV0tPnNyYyA9IHhzdHJkdXAocmV0LT5tZXJnZV9uYW1lW2ldKTsKCQlpZiAoIXJlbW90ZV9maW5kX3RyYWNraW5nKHJlbW90ZSwgcmV0LT5tZXJnZVtpXSkgfHwKCQkgICAgc3RyY21wKHJldC0+cmVtb3RlX25hbWUsICIuIikpCgkJCWNvbnRpbnVlOwoJCWlmIChkd2ltX3JlZihyZXQtPm1lcmdlX25hbWVbaV0sIHN0cmxlbihyZXQtPm1lcmdlX25hbWVbaV0pLAoJCQkgICAgICZvaWQsICZyZWYpID09IDEpCgkJCXJldC0+bWVyZ2VbaV0tPmRzdCA9IHJlZjsKCQllbHNlCgkJCXJldC0+bWVyZ2VbaV0tPmRzdCA9IHhzdHJkdXAocmV0LT5tZXJnZV9uYW1lW2ldKTsKCX0KfQoKc3RydWN0IGJyYW5jaCAqYnJhbmNoX2dldChjb25zdCBjaGFyICpuYW1lKQp7CglzdHJ1Y3QgYnJhbmNoICpyZXQ7CgoJcmVhZF9jb25maWcoKTsKCWlmICghbmFtZSB8fCAhKm5hbWUgfHwgIXN0cmNtcChuYW1lLCAiSEVBRCIpKQoJCXJldCA9IGN1cnJlbnRfYnJhbmNoOwoJZWxzZQoJCXJldCA9IG1ha2VfYnJhbmNoKG5hbWUsIDApOwoJc2V0X21lcmdlKHJldCk7CglyZXR1cm4gcmV0Owp9CgppbnQgYnJhbmNoX2hhc19tZXJnZV9jb25maWcoc3RydWN0IGJyYW5jaCAqYnJhbmNoKQp7CglyZXR1cm4gYnJhbmNoICYmICEhYnJhbmNoLT5tZXJnZTsKfQoKaW50IGJyYW5jaF9tZXJnZV9tYXRjaGVzKHN0cnVjdCBicmFuY2ggKmJyYW5jaCwKCQkgICAgICAgICAgICAgICAgIGludCBpLAoJCSAgICAgICAgICAgICAgICAgY29uc3QgY2hhciAqcmVmbmFtZSkKewoJaWYgKCFicmFuY2ggfHwgaSA8IDAgfHwgaSA+PSBicmFuY2gtPm1lcmdlX25yKQoJCXJldHVybiAwOwoJcmV0dXJuIHJlZm5hbWVfbWF0Y2goYnJhbmNoLT5tZXJnZVtpXS0+c3JjLCByZWZuYW1lKTsKfQoKX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsMiwzKSkpCnN0YXRpYyBjb25zdCBjaGFyICplcnJvcl9idWYoc3RydWN0IHN0cmJ1ZiAqZXJyLCBjb25zdCBjaGFyICpmbXQsIC4uLikKewoJaWYgKGVycikgewoJCXZhX2xpc3QgYXA7CgkJdmFfc3RhcnQoYXAsIGZtdCk7CgkJc3RyYnVmX3ZhZGRmKGVyciwgZm10LCBhcCk7CgkJdmFfZW5kKGFwKTsKCX0KCXJldHVybiBOVUxMOwp9Cgpjb25zdCBjaGFyICpicmFuY2hfZ2V0X3Vwc3RyZWFtKHN0cnVjdCBicmFuY2ggKmJyYW5jaCwgc3RydWN0IHN0cmJ1ZiAqZXJyKQp7CglpZiAoIWJyYW5jaCkKCQlyZXR1cm4gZXJyb3JfYnVmKGVyciwgXygiSEVBRCBkb2VzIG5vdCBwb2ludCB0byBhIGJyYW5jaCIpKTsKCglpZiAoIWJyYW5jaC0+bWVyZ2UgfHwgIWJyYW5jaC0+bWVyZ2VbMF0pIHsKCQkvKgoJCSAqIG5vIG1lcmdlIGNvbmZpZzsgaXMgaXQgYmVjYXVzZSB0aGUgdXNlciBkaWRuJ3QgZGVmaW5lIGFueSwKCQkgKiBvciBiZWNhdXNlIGl0IGlzIG5vdCBhIHJlYWwgYnJhbmNoLCBhbmQgZ2V0X2JyYW5jaAoJCSAqIGF1dG8tdml2aWZpZWQgaXQ/CgkJICovCgkJaWYgKCFyZWZfZXhpc3RzKGJyYW5jaC0+cmVmbmFtZSkpCgkJCXJldHVybiBlcnJvcl9idWYoZXJyLCBfKCJubyBzdWNoIGJyYW5jaDogJyVzJyIpLAoJCQkJCSBicmFuY2gtPm5hbWUpOwoJCXJldHVybiBlcnJvcl9idWYoZXJyLAoJCQkJIF8oIm5vIHVwc3RyZWFtIGNvbmZpZ3VyZWQgZm9yIGJyYW5jaCAnJXMnIiksCgkJCQkgYnJhbmNoLT5uYW1lKTsKCX0KCglpZiAoIWJyYW5jaC0+bWVyZ2VbMF0tPmRzdCkKCQlyZXR1cm4gZXJyb3JfYnVmKGVyciwKCQkJCSBfKCJ1cHN0cmVhbSBicmFuY2ggJyVzJyBub3Qgc3RvcmVkIGFzIGEgcmVtb3RlLXRyYWNraW5nIGJyYW5jaCIpLAoJCQkJIGJyYW5jaC0+bWVyZ2VbMF0tPnNyYyk7CgoJcmV0dXJuIGJyYW5jaC0+bWVyZ2VbMF0tPmRzdDsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnRyYWNraW5nX2Zvcl9wdXNoX2Rlc3Qoc3RydWN0IHJlbW90ZSAqcmVtb3RlLAoJCQkJCSAgY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJCQkgIHN0cnVjdCBzdHJidWYgKmVycikKewoJY2hhciAqcmV0OwoKCXJldCA9IGFwcGx5X3JlZnNwZWNzKCZyZW1vdGUtPmZldGNoLCByZWZuYW1lKTsKCWlmICghcmV0KQoJCXJldHVybiBlcnJvcl9idWYoZXJyLAoJCQkJIF8oInB1c2ggZGVzdGluYXRpb24gJyVzJyBvbiByZW1vdGUgJyVzJyBoYXMgbm8gbG9jYWwgdHJhY2tpbmcgYnJhbmNoIiksCgkJCQkgcmVmbmFtZSwgcmVtb3RlLT5uYW1lKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpicmFuY2hfZ2V0X3B1c2hfMShzdHJ1Y3QgYnJhbmNoICpicmFuY2gsIHN0cnVjdCBzdHJidWYgKmVycikKewoJc3RydWN0IHJlbW90ZSAqcmVtb3RlOwoKCXJlbW90ZSA9IHJlbW90ZV9nZXQocHVzaHJlbW90ZV9mb3JfYnJhbmNoKGJyYW5jaCwgTlVMTCkpOwoJaWYgKCFyZW1vdGUpCgkJcmV0dXJuIGVycm9yX2J1ZihlcnIsCgkJCQkgXygiYnJhbmNoICclcycgaGFzIG5vIHJlbW90ZSBmb3IgcHVzaGluZyIpLAoJCQkJIGJyYW5jaC0+bmFtZSk7CgoJaWYgKHJlbW90ZS0+cHVzaC5ucikgewoJCWNoYXIgKmRzdDsKCQljb25zdCBjaGFyICpyZXQ7CgoJCWRzdCA9IGFwcGx5X3JlZnNwZWNzKCZyZW1vdGUtPnB1c2gsIGJyYW5jaC0+cmVmbmFtZSk7CgkJaWYgKCFkc3QpCgkJCXJldHVybiBlcnJvcl9idWYoZXJyLAoJCQkJCSBfKCJwdXNoIHJlZnNwZWNzIGZvciAnJXMnIGRvIG5vdCBpbmNsdWRlICclcyciKSwKCQkJCQkgcmVtb3RlLT5uYW1lLCBicmFuY2gtPm5hbWUpOwoKCQlyZXQgPSB0cmFja2luZ19mb3JfcHVzaF9kZXN0KHJlbW90ZSwgZHN0LCBlcnIpOwoJCWZyZWUoZHN0KTsKCQlyZXR1cm4gcmV0OwoJfQoKCWlmIChyZW1vdGUtPm1pcnJvcikKCQlyZXR1cm4gdHJhY2tpbmdfZm9yX3B1c2hfZGVzdChyZW1vdGUsIGJyYW5jaC0+cmVmbmFtZSwgZXJyKTsKCglzd2l0Y2ggKHB1c2hfZGVmYXVsdCkgewoJY2FzZSBQVVNIX0RFRkFVTFRfTk9USElORzoKCQlyZXR1cm4gZXJyb3JfYnVmKGVyciwgXygicHVzaCBoYXMgbm8gZGVzdGluYXRpb24gKHB1c2guZGVmYXVsdCBpcyAnbm90aGluZycpIikpOwoKCWNhc2UgUFVTSF9ERUZBVUxUX01BVENISU5HOgoJY2FzZSBQVVNIX0RFRkFVTFRfQ1VSUkVOVDoKCQlyZXR1cm4gdHJhY2tpbmdfZm9yX3B1c2hfZGVzdChyZW1vdGUsIGJyYW5jaC0+cmVmbmFtZSwgZXJyKTsKCgljYXNlIFBVU0hfREVGQVVMVF9VUFNUUkVBTToKCQlyZXR1cm4gYnJhbmNoX2dldF91cHN0cmVhbShicmFuY2gsIGVycik7CgoJY2FzZSBQVVNIX0RFRkFVTFRfVU5TUEVDSUZJRUQ6CgljYXNlIFBVU0hfREVGQVVMVF9TSU1QTEU6CgkJewoJCQljb25zdCBjaGFyICp1cCwgKmN1cjsKCgkJCXVwID0gYnJhbmNoX2dldF91cHN0cmVhbShicmFuY2gsIGVycik7CgkJCWlmICghdXApCgkJCQlyZXR1cm4gTlVMTDsKCQkJY3VyID0gdHJhY2tpbmdfZm9yX3B1c2hfZGVzdChyZW1vdGUsIGJyYW5jaC0+cmVmbmFtZSwgZXJyKTsKCQkJaWYgKCFjdXIpCgkJCQlyZXR1cm4gTlVMTDsKCQkJaWYgKHN0cmNtcChjdXIsIHVwKSkKCQkJCXJldHVybiBlcnJvcl9idWYoZXJyLAoJCQkJCQkgXygiY2Fubm90IHJlc29sdmUgJ3NpbXBsZScgcHVzaCB0byBhIHNpbmdsZSBkZXN0aW5hdGlvbiIpKTsKCQkJcmV0dXJuIGN1cjsKCQl9Cgl9CgoJZGllKCJCVUc6IHVuaGFuZGxlZCBwdXNoIHNpdHVhdGlvbiIpOwp9Cgpjb25zdCBjaGFyICpicmFuY2hfZ2V0X3B1c2goc3RydWN0IGJyYW5jaCAqYnJhbmNoLCBzdHJ1Y3Qgc3RyYnVmICplcnIpCnsKCWlmICghYnJhbmNoKQoJCXJldHVybiBlcnJvcl9idWYoZXJyLCBfKCJIRUFEIGRvZXMgbm90IHBvaW50IHRvIGEgYnJhbmNoIikpOwoKCWlmICghYnJhbmNoLT5wdXNoX3RyYWNraW5nX3JlZikKCQlicmFuY2gtPnB1c2hfdHJhY2tpbmdfcmVmID0gYnJhbmNoX2dldF9wdXNoXzEoYnJhbmNoLCBlcnIpOwoJcmV0dXJuIGJyYW5jaC0+cHVzaF90cmFja2luZ19yZWY7Cn0KCnN0YXRpYyBpbnQgaWdub3JlX3N5bXJlZl91cGRhdGUoY29uc3QgY2hhciAqcmVmbmFtZSkKewoJaW50IGZsYWc7CgoJaWYgKCFyZXNvbHZlX3JlZl91bnNhZmUocmVmbmFtZSwgMCwgTlVMTCwgJmZsYWcpKQoJCXJldHVybiAwOyAvKiBub24tZXhpc3RpbmcgcmVmcyBhcmUgT0sgKi8KCXJldHVybiAoZmxhZyAmIFJFRl9JU1NZTVJFRik7Cn0KCi8qCiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbGlzdCBvZiAoc3RydWN0IHJlZikgY29uc2lzdGluZyBvZiBjb3BpZXMgb2YKICogZWFjaCByZW1vdGVfcmVmIHRoYXQgbWF0Y2hlcyByZWZzcGVjLiAgcmVmc3BlYyBtdXN0IGJlIGEgcGF0dGVybi4KICogRmlsbCBpbiB0aGUgY29waWVzJyBwZWVyX3JlZiB0byBkZXNjcmliZSB0aGUgbG9jYWwgdHJhY2tpbmcgcmVmcyB0bwogKiB3aGljaCB0aGV5IG1hcC4gIE9taXQgYW55IHJlZmVyZW5jZXMgdGhhdCB3b3VsZCBtYXAgdG8gYW4gZXhpc3RpbmcKICogbG9jYWwgc3ltYm9saWMgcmVmLgogKi8Kc3RhdGljIHN0cnVjdCByZWYgKmdldF9leHBhbmRlZF9tYXAoY29uc3Qgc3RydWN0IHJlZiAqcmVtb3RlX3JlZnMsCgkJCQkgICAgY29uc3Qgc3RydWN0IHJlZnNwZWNfaXRlbSAqcmVmc3BlYykKewoJY29uc3Qgc3RydWN0IHJlZiAqcmVmOwoJc3RydWN0IHJlZiAqcmV0ID0gTlVMTDsKCXN0cnVjdCByZWYgKip0YWlsID0gJnJldDsKCglmb3IgKHJlZiA9IHJlbW90ZV9yZWZzOyByZWY7IHJlZiA9IHJlZi0+bmV4dCkgewoJCWNoYXIgKmV4cG5fbmFtZSA9IE5VTEw7CgoJCWlmIChzdHJjaHIocmVmLT5uYW1lLCAnXicpKQoJCQljb250aW51ZTsgLyogYSBkZXJlZmVyZW5jZSBpdGVtICovCgkJaWYgKG1hdGNoX25hbWVfd2l0aF9wYXR0ZXJuKHJlZnNwZWMtPnNyYywgcmVmLT5uYW1lLAoJCQkJCSAgICByZWZzcGVjLT5kc3QsICZleHBuX25hbWUpICYmCgkJICAgICFpZ25vcmVfc3ltcmVmX3VwZGF0ZShleHBuX25hbWUpKSB7CgkJCXN0cnVjdCByZWYgKmNweSA9IGNvcHlfcmVmKHJlZik7CgoJCQljcHktPnBlZXJfcmVmID0gYWxsb2NfcmVmKGV4cG5fbmFtZSk7CgkJCWlmIChyZWZzcGVjLT5mb3JjZSkKCQkJCWNweS0+cGVlcl9yZWYtPmZvcmNlID0gMTsKCQkJKnRhaWwgPSBjcHk7CgkJCXRhaWwgPSAmY3B5LT5uZXh0OwoJCX0KCQlmcmVlKGV4cG5fbmFtZSk7Cgl9CgoJcmV0dXJuIHJldDsKfQoKc3RhdGljIGNvbnN0IHN0cnVjdCByZWYgKmZpbmRfcmVmX2J5X25hbWVfYWJicmV2KGNvbnN0IHN0cnVjdCByZWYgKnJlZnMsIGNvbnN0IGNoYXIgKm5hbWUpCnsKCWNvbnN0IHN0cnVjdCByZWYgKnJlZjsKCWZvciAocmVmID0gcmVmczsgcmVmOyByZWYgPSByZWYtPm5leHQpIHsKCQlpZiAocmVmbmFtZV9tYXRjaChuYW1lLCByZWYtPm5hbWUpKQoJCQlyZXR1cm4gcmVmOwoJfQoJcmV0dXJuIE5VTEw7Cn0KCnN0cnVjdCByZWYgKmdldF9yZW1vdGVfcmVmKGNvbnN0IHN0cnVjdCByZWYgKnJlbW90ZV9yZWZzLCBjb25zdCBjaGFyICpuYW1lKQp7Cgljb25zdCBzdHJ1Y3QgcmVmICpyZWYgPSBmaW5kX3JlZl9ieV9uYW1lX2FiYnJldihyZW1vdGVfcmVmcywgbmFtZSk7CgoJaWYgKCFyZWYpCgkJcmV0dXJuIE5VTEw7CgoJcmV0dXJuIGNvcHlfcmVmKHJlZik7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVmICpnZXRfbG9jYWxfcmVmKGNvbnN0IGNoYXIgKm5hbWUpCnsKCWlmICghbmFtZSB8fCBuYW1lWzBdID09ICdcMCcpCgkJcmV0dXJuIE5VTEw7CgoJaWYgKHN0YXJ0c193aXRoKG5hbWUsICJyZWZzLyIpKQoJCXJldHVybiBhbGxvY19yZWYobmFtZSk7CgoJaWYgKHN0YXJ0c193aXRoKG5hbWUsICJoZWFkcy8iKSB8fAoJICAgIHN0YXJ0c193aXRoKG5hbWUsICJ0YWdzLyIpIHx8CgkgICAgc3RhcnRzX3dpdGgobmFtZSwgInJlbW90ZXMvIikpCgkJcmV0dXJuIGFsbG9jX3JlZl93aXRoX3ByZWZpeCgicmVmcy8iLCA1LCBuYW1lKTsKCglyZXR1cm4gYWxsb2NfcmVmX3dpdGhfcHJlZml4KCJyZWZzL2hlYWRzLyIsIDExLCBuYW1lKTsKfQoKaW50IGdldF9mZXRjaF9tYXAoY29uc3Qgc3RydWN0IHJlZiAqcmVtb3RlX3JlZnMsCgkJICBjb25zdCBzdHJ1Y3QgcmVmc3BlY19pdGVtICpyZWZzcGVjLAoJCSAgc3RydWN0IHJlZiAqKip0YWlsLAoJCSAgaW50IG1pc3Npbmdfb2spCnsKCXN0cnVjdCByZWYgKnJlZl9tYXAsICoqcm1wOwoKCWlmIChyZWZzcGVjLT5wYXR0ZXJuKSB7CgkJcmVmX21hcCA9IGdldF9leHBhbmRlZF9tYXAocmVtb3RlX3JlZnMsIHJlZnNwZWMpOwoJfSBlbHNlIHsKCQljb25zdCBjaGFyICpuYW1lID0gcmVmc3BlYy0+c3JjWzBdID8gcmVmc3BlYy0+c3JjIDogIkhFQUQiOwoKCQlpZiAocmVmc3BlYy0+ZXhhY3Rfc2hhMSkgewoJCQlyZWZfbWFwID0gYWxsb2NfcmVmKG5hbWUpOwoJCQlnZXRfb2lkX2hleChuYW1lLCAmcmVmX21hcC0+b2xkX29pZCk7CgkJfSBlbHNlIHsKCQkJcmVmX21hcCA9IGdldF9yZW1vdGVfcmVmKHJlbW90ZV9yZWZzLCBuYW1lKTsKCQl9CgkJaWYgKCFtaXNzaW5nX29rICYmICFyZWZfbWFwKQoJCQlkaWUoIkNvdWxkbid0IGZpbmQgcmVtb3RlIHJlZiAlcyIsIG5hbWUpOwoJCWlmIChyZWZfbWFwKSB7CgkJCXJlZl9tYXAtPnBlZXJfcmVmID0gZ2V0X2xvY2FsX3JlZihyZWZzcGVjLT5kc3QpOwoJCQlpZiAocmVmX21hcC0+cGVlcl9yZWYgJiYgcmVmc3BlYy0+Zm9yY2UpCgkJCQlyZWZfbWFwLT5wZWVyX3JlZi0+Zm9yY2UgPSAxOwoJCX0KCX0KCglmb3IgKHJtcCA9ICZyZWZfbWFwOyAqcm1wOyApIHsKCQlpZiAoKCpybXApLT5wZWVyX3JlZikgewoJCQlpZiAoIXN0YXJ0c193aXRoKCgqcm1wKS0+cGVlcl9yZWYtPm5hbWUsICJyZWZzLyIpIHx8CgkJCSAgICBjaGVja19yZWZuYW1lX2Zvcm1hdCgoKnJtcCktPnBlZXJfcmVmLT5uYW1lLCAwKSkgewoJCQkJc3RydWN0IHJlZiAqaWdub3JlID0gKnJtcDsKCQkJCWVycm9yKCIqIElnbm9yaW5nIGZ1bm55IHJlZiAnJXMnIGxvY2FsbHkiLAoJCQkJICAgICAgKCpybXApLT5wZWVyX3JlZi0+bmFtZSk7CgkJCQkqcm1wID0gKCpybXApLT5uZXh0OwoJCQkJZnJlZShpZ25vcmUtPnBlZXJfcmVmKTsKCQkJCWZyZWUoaWdub3JlKTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJfQoJCXJtcCA9ICYoKCpybXApLT5uZXh0KTsKCX0KCglpZiAocmVmX21hcCkKCQl0YWlsX2xpbmtfcmVmKHJlZl9tYXAsIHRhaWwpOwoKCXJldHVybiAwOwp9CgppbnQgcmVzb2x2ZV9yZW1vdGVfc3ltcmVmKHN0cnVjdCByZWYgKnJlZiwgc3RydWN0IHJlZiAqbGlzdCkKewoJaWYgKCFyZWYtPnN5bXJlZikKCQlyZXR1cm4gMDsKCWZvciAoOyBsaXN0OyBsaXN0ID0gbGlzdC0+bmV4dCkKCQlpZiAoIXN0cmNtcChyZWYtPnN5bXJlZiwgbGlzdC0+bmFtZSkpIHsKCQkJb2lkY3B5KCZyZWYtPm9sZF9vaWQsICZsaXN0LT5vbGRfb2lkKTsKCQkJcmV0dXJuIDA7CgkJfQoJcmV0dXJuIDE7Cn0KCnN0YXRpYyB2b2lkIHVubWFya19hbmRfZnJlZShzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QsIHVuc2lnbmVkIGludCBtYXJrKQp7Cgl3aGlsZSAobGlzdCkgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IHBvcF9jb21taXQoJmxpc3QpOwoJCWNvbW1pdC0+b2JqZWN0LmZsYWdzICY9IH5tYXJrOwoJfQp9CgppbnQgcmVmX25ld2VyKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm5ld19vaWQsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9sZF9vaWQpCnsKCXN0cnVjdCBvYmplY3QgKm87CglzdHJ1Y3QgY29tbWl0ICpvbGRfY29tbWl0LCAqbmV3X2NvbW1pdDsKCXN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCwgKnVzZWQ7CglpbnQgZm91bmQgPSAwOwoKCS8qCgkgKiBCb3RoIG5ld19jb21taXQgYW5kIG9sZF9jb21taXQgbXVzdCBiZSBjb21taXQtaXNoIGFuZCBuZXdfY29tbWl0IGlzIGRlc2NlbmRhbnQgb2YKCSAqIG9sZF9jb21taXQuICBPdGhlcndpc2Ugd2UgcmVxdWlyZSAtLWZvcmNlLgoJICovCglvID0gZGVyZWZfdGFnKHBhcnNlX29iamVjdChvbGRfb2lkKSwgTlVMTCwgMCk7CglpZiAoIW8gfHwgby0+dHlwZSAhPSBPQkpfQ09NTUlUKQoJCXJldHVybiAwOwoJb2xkX2NvbW1pdCA9IChzdHJ1Y3QgY29tbWl0ICopIG87CgoJbyA9IGRlcmVmX3RhZyhwYXJzZV9vYmplY3QobmV3X29pZCksIE5VTEwsIDApOwoJaWYgKCFvIHx8IG8tPnR5cGUgIT0gT0JKX0NPTU1JVCkKCQlyZXR1cm4gMDsKCW5ld19jb21taXQgPSAoc3RydWN0IGNvbW1pdCAqKSBvOwoKCWlmIChwYXJzZV9jb21taXQobmV3X2NvbW1pdCkgPCAwKQoJCXJldHVybiAwOwoKCXVzZWQgPSBsaXN0ID0gTlVMTDsKCWNvbW1pdF9saXN0X2luc2VydChuZXdfY29tbWl0LCAmbGlzdCk7Cgl3aGlsZSAobGlzdCkgewoJCW5ld19jb21taXQgPSBwb3BfbW9zdF9yZWNlbnRfY29tbWl0KCZsaXN0LCBUTVBfTUFSSyk7CgkJY29tbWl0X2xpc3RfaW5zZXJ0KG5ld19jb21taXQsICZ1c2VkKTsKCQlpZiAobmV3X2NvbW1pdCA9PSBvbGRfY29tbWl0KSB7CgkJCWZvdW5kID0gMTsKCQkJYnJlYWs7CgkJfQoJfQoJdW5tYXJrX2FuZF9mcmVlKGxpc3QsIFRNUF9NQVJLKTsKCXVubWFya19hbmRfZnJlZSh1c2VkLCBUTVBfTUFSSyk7CglyZXR1cm4gZm91bmQ7Cn0KCi8qCiAqIExvb2t1cCB0aGUgdXBzdHJlYW0gYnJhbmNoIGZvciB0aGUgZ2l2ZW4gYnJhbmNoIGFuZCBpZiBwcmVzZW50LCBvcHRpb25hbGx5CiAqIGNvbXB1dGUgdGhlIGNvbW1pdCBhaGVhZC9iZWhpbmQgdmFsdWVzIGZvciB0aGUgcGFpci4KICoKICogSWYgYWJmIGlzIEFIRUFEX0JFSElORF9GVUxMLCBjb21wdXRlIHRoZSBmdWxsIGFoZWFkL2JlaGluZCBhbmQgcmV0dXJuIHRoZQogKiBjb3VudHMgaW4gKm51bV9vdXJzIGFuZCAqbnVtX3RoZWlycy4gIElmIGFiZiBpcyBBSEVBRF9CRUhJTkRfUVVJQ0ssIHNraXAKICogdGhlIChwb3RlbnRpYWxseSBleHBlbnNpdmUpIGEvYiBjb21wdXRhdGlvbiAoKm51bV9vdXJzIGFuZCAqbnVtX3RoZWlycyBhcmUKICogc2V0IHRvIHplcm8pLgogKgogKiBUaGUgbmFtZSBvZiB0aGUgdXBzdHJlYW0gYnJhbmNoIChvciBOVUxMIGlmIG5vIHVwc3RyZWFtIGlzIGRlZmluZWQpIGlzCiAqIHJldHVybmVkIHZpYSAqdXBzdHJlYW1fbmFtZSwgaWYgaXQgaXMgbm90IGl0c2VsZiBOVUxMLgogKgogKiBSZXR1cm5zIC0xIGlmIG51bV9vdXJzIGFuZCBudW1fdGhlaXJzIGNvdWxkIG5vdCBiZSBmaWxsZWQgaW4gKGUuZy4sIG5vCiAqIHVwc3RyZWFtIGRlZmluZWQsIG9yIHJlZiBkb2VzIG5vdCBleGlzdCkuICBSZXR1cm5zIDAgaWYgdGhlIGNvbW1pdHMgYXJlCiAqIGlkZW50aWNhbC4gIFJldHVybnMgMSBpZiBjb21taXRzIGFyZSBkaWZmZXJlbnQuCiAqLwppbnQgc3RhdF90cmFja2luZ19pbmZvKHN0cnVjdCBicmFuY2ggKmJyYW5jaCwgaW50ICpudW1fb3VycywgaW50ICpudW1fdGhlaXJzLAoJCSAgICAgICBjb25zdCBjaGFyICoqdXBzdHJlYW1fbmFtZSwgZW51bSBhaGVhZF9iZWhpbmRfZmxhZ3MgYWJmKQp7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCXN0cnVjdCBjb21taXQgKm91cnMsICp0aGVpcnM7CglzdHJ1Y3QgcmV2X2luZm8gcmV2czsKCWNvbnN0IGNoYXIgKmJhc2U7CglzdHJ1Y3QgYXJndl9hcnJheSBhcmd2ID0gQVJHVl9BUlJBWV9JTklUOwoKCS8qIENhbm5vdCBzdGF0IHVubGVzcyB3ZSBhcmUgbWFya2VkIHRvIGJ1aWxkIG9uIHRvcCBvZiBzb21lYm9keSBlbHNlLiAqLwoJYmFzZSA9IGJyYW5jaF9nZXRfdXBzdHJlYW0oYnJhbmNoLCBOVUxMKTsKCWlmICh1cHN0cmVhbV9uYW1lKQoJCSp1cHN0cmVhbV9uYW1lID0gYmFzZTsKCWlmICghYmFzZSkKCQlyZXR1cm4gLTE7CgoJLyogQ2Fubm90IHN0YXQgaWYgd2hhdCB3ZSB1c2VkIHRvIGJ1aWxkIG9uIG5vIGxvbmdlciBleGlzdHMgKi8KCWlmIChyZWFkX3JlZihiYXNlLCAmb2lkKSkKCQlyZXR1cm4gLTE7Cgl0aGVpcnMgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZSgmb2lkKTsKCWlmICghdGhlaXJzKQoJCXJldHVybiAtMTsKCglpZiAocmVhZF9yZWYoYnJhbmNoLT5yZWZuYW1lLCAmb2lkKSkKCQlyZXR1cm4gLTE7CglvdXJzID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2UoJm9pZCk7CglpZiAoIW91cnMpCgkJcmV0dXJuIC0xOwoKCSpudW1fdGhlaXJzID0gKm51bV9vdXJzID0gMDsKCgkvKiBhcmUgd2UgdGhlIHNhbWU/ICovCglpZiAodGhlaXJzID09IG91cnMpCgkJcmV0dXJuIDA7CglpZiAoYWJmID09IEFIRUFEX0JFSElORF9RVUlDSykKCQlyZXR1cm4gMTsKCWlmIChhYmYgIT0gQUhFQURfQkVISU5EX0ZVTEwpCgkJQlVHKCJzdGF0X3RyYWNraW5nX2luZm86IGludmFsaWQgYWJmICclZCciLCBhYmYpOwoKCS8qIFJ1biAicmV2LWxpc3QgLS1sZWZ0LXJpZ2h0IG91cnMuLi50aGVpcnMiIGludGVybmFsbHkuLi4gKi8KCWFyZ3ZfYXJyYXlfcHVzaCgmYXJndiwgIiIpOyAvKiBpZ25vcmVkICovCglhcmd2X2FycmF5X3B1c2goJmFyZ3YsICItLWxlZnQtcmlnaHQiKTsKCWFyZ3ZfYXJyYXlfcHVzaGYoJmFyZ3YsICIlcy4uLiVzIiwKCQkJIG9pZF90b19oZXgoJm91cnMtPm9iamVjdC5vaWQpLAoJCQkgb2lkX3RvX2hleCgmdGhlaXJzLT5vYmplY3Qub2lkKSk7Cglhcmd2X2FycmF5X3B1c2goJmFyZ3YsICItLSIpOwoKCWluaXRfcmV2aXNpb25zKCZyZXZzLCBOVUxMKTsKCXNldHVwX3JldmlzaW9ucyhhcmd2LmFyZ2MsIGFyZ3YuYXJndiwgJnJldnMsIE5VTEwpOwoJaWYgKHByZXBhcmVfcmV2aXNpb25fd2FsaygmcmV2cykpCgkJZGllKCJyZXZpc2lvbiB3YWxrIHNldHVwIGZhaWxlZCIpOwoKCS8qIC4uLiBhbmQgY291bnQgdGhlIGNvbW1pdHMgb24gZWFjaCBzaWRlLiAqLwoJd2hpbGUgKDEpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjID0gZ2V0X3JldmlzaW9uKCZyZXZzKTsKCQlpZiAoIWMpCgkJCWJyZWFrOwoJCWlmIChjLT5vYmplY3QuZmxhZ3MgJiBTWU1NRVRSSUNfTEVGVCkKCQkJKCpudW1fb3VycykrKzsKCQllbHNlCgkJCSgqbnVtX3RoZWlycykrKzsKCX0KCgkvKiBjbGVhciBvYmplY3QgZmxhZ3Mgc211ZGdlZCBieSB0aGUgYWJvdmUgdHJhdmVyc2FsICovCgljbGVhcl9jb21taXRfbWFya3Mob3VycywgQUxMX1JFVl9GTEFHUyk7CgljbGVhcl9jb21taXRfbWFya3ModGhlaXJzLCBBTExfUkVWX0ZMQUdTKTsKCglhcmd2X2FycmF5X2NsZWFyKCZhcmd2KTsKCXJldHVybiAxOwp9CgovKgogKiBSZXR1cm4gdHJ1ZSB3aGVuIHRoZXJlIGlzIGFueXRoaW5nIHRvIHJlcG9ydCwgb3RoZXJ3aXNlIGZhbHNlLgogKi8KaW50IGZvcm1hdF90cmFja2luZ19pbmZvKHN0cnVjdCBicmFuY2ggKmJyYW5jaCwgc3RydWN0IHN0cmJ1ZiAqc2IsCgkJCSBlbnVtIGFoZWFkX2JlaGluZF9mbGFncyBhYmYpCnsKCWludCBvdXJzLCB0aGVpcnMsIHN0aTsKCWNvbnN0IGNoYXIgKmZ1bGxfYmFzZTsKCWNoYXIgKmJhc2U7CglpbnQgdXBzdHJlYW1faXNfZ29uZSA9IDA7CgoJc3RpID0gc3RhdF90cmFja2luZ19pbmZvKGJyYW5jaCwgJm91cnMsICZ0aGVpcnMsICZmdWxsX2Jhc2UsIGFiZik7CglpZiAoc3RpIDwgMCkgewoJCWlmICghZnVsbF9iYXNlKQoJCQlyZXR1cm4gMDsKCQl1cHN0cmVhbV9pc19nb25lID0gMTsKCX0KCgliYXNlID0gc2hvcnRlbl91bmFtYmlndW91c19yZWYoZnVsbF9iYXNlLCAwKTsKCWlmICh1cHN0cmVhbV9pc19nb25lKSB7CgkJc3RyYnVmX2FkZGYoc2IsCgkJCV8oIllvdXIgYnJhbmNoIGlzIGJhc2VkIG9uICclcycsIGJ1dCB0aGUgdXBzdHJlYW0gaXMgZ29uZS5cbiIpLAoJCQliYXNlKTsKCQlpZiAoYWR2aWNlX3N0YXR1c19oaW50cykKCQkJc3RyYnVmX2FkZHN0cihzYiwKCQkJCV8oIiAgKHVzZSBcImdpdCBicmFuY2ggLS11bnNldC11cHN0cmVhbVwiIHRvIGZpeHVwKVxuIikpOwoJfSBlbHNlIGlmICghc3RpKSB7CgkJc3RyYnVmX2FkZGYoc2IsCgkJCV8oIllvdXIgYnJhbmNoIGlzIHVwIHRvIGRhdGUgd2l0aCAnJXMnLlxuIiksCgkJCWJhc2UpOwoJfSBlbHNlIGlmIChhYmYgPT0gQUhFQURfQkVISU5EX1FVSUNLKSB7CgkJc3RyYnVmX2FkZGYoc2IsCgkJCSAgICBfKCJZb3VyIGJyYW5jaCBhbmQgJyVzJyByZWZlciB0byBkaWZmZXJlbnQgY29tbWl0cy5cbiIpLAoJCQkgICAgYmFzZSk7CgkJaWYgKGFkdmljZV9zdGF0dXNfaGludHMpCgkJCXN0cmJ1Zl9hZGRmKHNiLCBfKCIgICh1c2UgXCIlc1wiIGZvciBkZXRhaWxzKVxuIiksCgkJCQkgICAgImdpdCBzdGF0dXMgLS1haGVhZC1iZWhpbmQiKTsKCX0gZWxzZSBpZiAoIXRoZWlycykgewoJCXN0cmJ1Zl9hZGRmKHNiLAoJCQlRXygiWW91ciBicmFuY2ggaXMgYWhlYWQgb2YgJyVzJyBieSAlZCBjb21taXQuXG4iLAoJCQkgICAiWW91ciBicmFuY2ggaXMgYWhlYWQgb2YgJyVzJyBieSAlZCBjb21taXRzLlxuIiwKCQkJICAgb3VycyksCgkJCWJhc2UsIG91cnMpOwoJCWlmIChhZHZpY2Vfc3RhdHVzX2hpbnRzKQoJCQlzdHJidWZfYWRkc3RyKHNiLAoJCQkJXygiICAodXNlIFwiZ2l0IHB1c2hcIiB0byBwdWJsaXNoIHlvdXIgbG9jYWwgY29tbWl0cylcbiIpKTsKCX0gZWxzZSBpZiAoIW91cnMpIHsKCQlzdHJidWZfYWRkZihzYiwKCQkJUV8oIllvdXIgYnJhbmNoIGlzIGJlaGluZCAnJXMnIGJ5ICVkIGNvbW1pdCwgIgoJCQkgICAgICAgImFuZCBjYW4gYmUgZmFzdC1mb3J3YXJkZWQuXG4iLAoJCQkgICAiWW91ciBicmFuY2ggaXMgYmVoaW5kICclcycgYnkgJWQgY29tbWl0cywgIgoJCQkgICAgICAgImFuZCBjYW4gYmUgZmFzdC1mb3J3YXJkZWQuXG4iLAoJCQkgICB0aGVpcnMpLAoJCQliYXNlLCB0aGVpcnMpOwoJCWlmIChhZHZpY2Vfc3RhdHVzX2hpbnRzKQoJCQlzdHJidWZfYWRkc3RyKHNiLAoJCQkJXygiICAodXNlIFwiZ2l0IHB1bGxcIiB0byB1cGRhdGUgeW91ciBsb2NhbCBicmFuY2gpXG4iKSk7Cgl9IGVsc2UgewoJCXN0cmJ1Zl9hZGRmKHNiLAoJCQlRXygiWW91ciBicmFuY2ggYW5kICclcycgaGF2ZSBkaXZlcmdlZCxcbiIKCQkJICAgICAgICJhbmQgaGF2ZSAlZCBhbmQgJWQgZGlmZmVyZW50IGNvbW1pdCBlYWNoLCAiCgkJCSAgICAgICAicmVzcGVjdGl2ZWx5LlxuIiwKCQkJICAgIllvdXIgYnJhbmNoIGFuZCAnJXMnIGhhdmUgZGl2ZXJnZWQsXG4iCgkJCSAgICAgICAiYW5kIGhhdmUgJWQgYW5kICVkIGRpZmZlcmVudCBjb21taXRzIGVhY2gsICIKCQkJICAgICAgICJyZXNwZWN0aXZlbHkuXG4iLAoJCQkgICBvdXJzICsgdGhlaXJzKSwKCQkJYmFzZSwgb3VycywgdGhlaXJzKTsKCQlpZiAoYWR2aWNlX3N0YXR1c19oaW50cykKCQkJc3RyYnVmX2FkZHN0cihzYiwKCQkJCV8oIiAgKHVzZSBcImdpdCBwdWxsXCIgdG8gbWVyZ2UgdGhlIHJlbW90ZSBicmFuY2ggaW50byB5b3VycylcbiIpKTsKCX0KCWZyZWUoYmFzZSk7CglyZXR1cm4gMTsKfQoKc3RhdGljIGludCBvbmVfbG9jYWxfcmVmKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJIGludCBmbGFnLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3QgcmVmICoqKmxvY2FsX3RhaWwgPSBjYl9kYXRhOwoJc3RydWN0IHJlZiAqcmVmOwoKCS8qIHdlIGFscmVhZHkga25vdyBpdCBzdGFydHMgd2l0aCByZWZzLyB0byBnZXQgaGVyZSAqLwoJaWYgKGNoZWNrX3JlZm5hbWVfZm9ybWF0KHJlZm5hbWUgKyA1LCAwKSkKCQlyZXR1cm4gMDsKCglyZWYgPSBhbGxvY19yZWYocmVmbmFtZSk7CglvaWRjcHkoJnJlZi0+bmV3X29pZCwgb2lkKTsKCSoqbG9jYWxfdGFpbCA9IHJlZjsKCSpsb2NhbF90YWlsID0gJnJlZi0+bmV4dDsKCXJldHVybiAwOwp9CgpzdHJ1Y3QgcmVmICpnZXRfbG9jYWxfaGVhZHModm9pZCkKewoJc3RydWN0IHJlZiAqbG9jYWxfcmVmcyA9IE5VTEwsICoqbG9jYWxfdGFpbCA9ICZsb2NhbF9yZWZzOwoKCWZvcl9lYWNoX3JlZihvbmVfbG9jYWxfcmVmLCAmbG9jYWxfdGFpbCk7CglyZXR1cm4gbG9jYWxfcmVmczsKfQoKc3RydWN0IHJlZiAqZ3Vlc3NfcmVtb3RlX2hlYWQoY29uc3Qgc3RydWN0IHJlZiAqaGVhZCwKCQkJICAgICAgY29uc3Qgc3RydWN0IHJlZiAqcmVmcywKCQkJICAgICAgaW50IGFsbCkKewoJY29uc3Qgc3RydWN0IHJlZiAqcjsKCXN0cnVjdCByZWYgKmxpc3QgPSBOVUxMOwoJc3RydWN0IHJlZiAqKnRhaWwgPSAmbGlzdDsKCglpZiAoIWhlYWQpCgkJcmV0dXJuIE5VTEw7CgoJLyoKCSAqIFNvbWUgdHJhbnNwb3J0cyBzdXBwb3J0IGRpcmVjdGx5IHBlZWtpbmcgYXQKCSAqIHdoZXJlIEhFQUQgcG9pbnRzOyBpZiB0aGF0IGlzIHRoZSBjYXNlLCB0aGVuCgkgKiB3ZSBkb24ndCBoYXZlIHRvIGd1ZXNzLgoJICovCglpZiAoaGVhZC0+c3ltcmVmKQoJCXJldHVybiBjb3B5X3JlZihmaW5kX3JlZl9ieV9uYW1lKHJlZnMsIGhlYWQtPnN5bXJlZikpOwoKCS8qIElmIHJlZnMvaGVhZHMvbWFzdGVyIGNvdWxkIGJlIHJpZ2h0LCBpdCBpcy4gKi8KCWlmICghYWxsKSB7CgkJciA9IGZpbmRfcmVmX2J5X25hbWUocmVmcywgInJlZnMvaGVhZHMvbWFzdGVyIik7CgkJaWYgKHIgJiYgIW9pZGNtcCgmci0+b2xkX29pZCwgJmhlYWQtPm9sZF9vaWQpKQoJCQlyZXR1cm4gY29weV9yZWYocik7Cgl9CgoJLyogTG9vayBmb3IgYW5vdGhlciByZWYgdGhhdCBwb2ludHMgdGhlcmUgKi8KCWZvciAociA9IHJlZnM7IHI7IHIgPSByLT5uZXh0KSB7CgkJaWYgKHIgIT0gaGVhZCAmJgoJCSAgICBzdGFydHNfd2l0aChyLT5uYW1lLCAicmVmcy9oZWFkcy8iKSAmJgoJCSAgICAhb2lkY21wKCZyLT5vbGRfb2lkLCAmaGVhZC0+b2xkX29pZCkpIHsKCQkJKnRhaWwgPSBjb3B5X3JlZihyKTsKCQkJdGFpbCA9ICYoKCp0YWlsKS0+bmV4dCk7CgkJCWlmICghYWxsKQoJCQkJYnJlYWs7CgkJfQoJfQoKCXJldHVybiBsaXN0Owp9CgpzdHJ1Y3Qgc3RhbGVfaGVhZHNfaW5mbyB7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnJlZl9uYW1lczsKCXN0cnVjdCByZWYgKipzdGFsZV9yZWZzX3RhaWw7CglzdHJ1Y3QgcmVmc3BlYyAqcnM7Cn07CgpzdGF0aWMgaW50IGdldF9zdGFsZV9oZWFkc19jYihjb25zdCBjaGFyICpyZWZuYW1lLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCSAgICAgIGludCBmbGFncywgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IHN0YWxlX2hlYWRzX2luZm8gKmluZm8gPSBjYl9kYXRhOwoJc3RydWN0IHN0cmluZ19saXN0IG1hdGNoZXMgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCXN0cnVjdCByZWZzcGVjX2l0ZW0gcXVlcnk7CglpbnQgaSwgc3RhbGUgPSAxOwoJbWVtc2V0KCZxdWVyeSwgMCwgc2l6ZW9mKHN0cnVjdCByZWZzcGVjX2l0ZW0pKTsKCXF1ZXJ5LmRzdCA9IChjaGFyICopcmVmbmFtZTsKCglxdWVyeV9yZWZzcGVjc19tdWx0aXBsZShpbmZvLT5ycywgJnF1ZXJ5LCAmbWF0Y2hlcyk7CglpZiAobWF0Y2hlcy5uciA9PSAwKQoJCWdvdG8gY2xlYW5fZXhpdDsgLyogTm8gbWF0Y2hlcyAqLwoKCS8qCgkgKiBJZiB3ZSBkaWQgZmluZCBhIHN1aXRhYmxlIHJlZnNwZWMgYW5kIGl0J3Mgbm90IGEgc3ltcmVmIGFuZAoJICogaXQncyBub3QgaW4gdGhlIGxpc3Qgb2YgcmVmcyB0aGF0IGN1cnJlbnRseSBleGlzdCBpbiB0aGF0CgkgKiByZW1vdGUsIHdlIGNvbnNpZGVyIGl0IHRvIGJlIHN0YWxlLiBJbiBvcmRlciB0byBkZWFsIHdpdGgKCSAqIG92ZXJsYXBwaW5nIHJlZnNwZWNzLCB3ZSBuZWVkIHRvIGdvIG92ZXIgYWxsIG9mIHRoZQoJICogbWF0Y2hpbmcgcmVmcy4KCSAqLwoJaWYgKGZsYWdzICYgUkVGX0lTU1lNUkVGKQoJCWdvdG8gY2xlYW5fZXhpdDsKCglmb3IgKGkgPSAwOyBzdGFsZSAmJiBpIDwgbWF0Y2hlcy5ucjsgaSsrKQoJCWlmIChzdHJpbmdfbGlzdF9oYXNfc3RyaW5nKGluZm8tPnJlZl9uYW1lcywgbWF0Y2hlcy5pdGVtc1tpXS5zdHJpbmcpKQoJCQlzdGFsZSA9IDA7CgoJaWYgKHN0YWxlKSB7CgkJc3RydWN0IHJlZiAqcmVmID0gbWFrZV9saW5rZWRfcmVmKHJlZm5hbWUsICZpbmZvLT5zdGFsZV9yZWZzX3RhaWwpOwoJCW9pZGNweSgmcmVmLT5uZXdfb2lkLCBvaWQpOwoJfQoKY2xlYW5fZXhpdDoKCXN0cmluZ19saXN0X2NsZWFyKCZtYXRjaGVzLCAwKTsKCXJldHVybiAwOwp9CgpzdHJ1Y3QgcmVmICpnZXRfc3RhbGVfaGVhZHMoc3RydWN0IHJlZnNwZWMgKnJzLCBzdHJ1Y3QgcmVmICpmZXRjaF9tYXApCnsKCXN0cnVjdCByZWYgKnJlZiwgKnN0YWxlX3JlZnMgPSBOVUxMOwoJc3RydWN0IHN0cmluZ19saXN0IHJlZl9uYW1lcyA9IFNUUklOR19MSVNUX0lOSVRfTk9EVVA7CglzdHJ1Y3Qgc3RhbGVfaGVhZHNfaW5mbyBpbmZvOwoKCWluZm8ucmVmX25hbWVzID0gJnJlZl9uYW1lczsKCWluZm8uc3RhbGVfcmVmc190YWlsID0gJnN0YWxlX3JlZnM7CglpbmZvLnJzID0gcnM7Cglmb3IgKHJlZiA9IGZldGNoX21hcDsgcmVmOyByZWYgPSByZWYtPm5leHQpCgkJc3RyaW5nX2xpc3RfYXBwZW5kKCZyZWZfbmFtZXMsIHJlZi0+bmFtZSk7CglzdHJpbmdfbGlzdF9zb3J0KCZyZWZfbmFtZXMpOwoJZm9yX2VhY2hfcmVmKGdldF9zdGFsZV9oZWFkc19jYiwgJmluZm8pOwoJc3RyaW5nX2xpc3RfY2xlYXIoJnJlZl9uYW1lcywgMCk7CglyZXR1cm4gc3RhbGVfcmVmczsKfQoKLyoKICogQ29tcGFyZS1hbmQtc3dhcAogKi8Kc3RhdGljIHZvaWQgY2xlYXJfY2FzX29wdGlvbihzdHJ1Y3QgcHVzaF9jYXNfb3B0aW9uICpjYXMpCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBjYXMtPm5yOyBpKyspCgkJZnJlZShjYXMtPmVudHJ5W2ldLnJlZm5hbWUpOwoJZnJlZShjYXMtPmVudHJ5KTsKCW1lbXNldChjYXMsIDAsIHNpemVvZigqY2FzKSk7Cn0KCnN0YXRpYyBzdHJ1Y3QgcHVzaF9jYXMgKmFkZF9jYXNfZW50cnkoc3RydWN0IHB1c2hfY2FzX29wdGlvbiAqY2FzLAoJCQkJICAgICAgY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJCSAgICAgIHNpemVfdCByZWZuYW1lbGVuKQp7CglzdHJ1Y3QgcHVzaF9jYXMgKmVudHJ5OwoJQUxMT0NfR1JPVyhjYXMtPmVudHJ5LCBjYXMtPm5yICsgMSwgY2FzLT5hbGxvYyk7CgllbnRyeSA9ICZjYXMtPmVudHJ5W2Nhcy0+bnIrK107CgltZW1zZXQoZW50cnksIDAsIHNpemVvZigqZW50cnkpKTsKCWVudHJ5LT5yZWZuYW1lID0geG1lbWR1cHoocmVmbmFtZSwgcmVmbmFtZWxlbik7CglyZXR1cm4gZW50cnk7Cn0KCnN0YXRpYyBpbnQgcGFyc2VfcHVzaF9jYXNfb3B0aW9uKHN0cnVjdCBwdXNoX2Nhc19vcHRpb24gKmNhcywgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCWNvbnN0IGNoYXIgKmNvbG9uOwoJc3RydWN0IHB1c2hfY2FzICplbnRyeTsKCglpZiAodW5zZXQpIHsKCQkvKiAiLS1uby08b3B0aW9uPiIgKi8KCQljbGVhcl9jYXNfb3B0aW9uKGNhcyk7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKCFhcmcpIHsKCQkvKiBqdXN0ICItLTxvcHRpb24+IiAqLwoJCWNhcy0+dXNlX3RyYWNraW5nX2Zvcl9yZXN0ID0gMTsKCQlyZXR1cm4gMDsKCX0KCgkvKiAiLS08b3B0aW9uPj1yZWZuYW1lIiBvciAiLS08b3B0aW9uPj1yZWZuYW1lOnZhbHVlIiAqLwoJY29sb24gPSBzdHJjaHJudWwoYXJnLCAnOicpOwoJZW50cnkgPSBhZGRfY2FzX2VudHJ5KGNhcywgYXJnLCBjb2xvbiAtIGFyZyk7CglpZiAoISpjb2xvbikKCQllbnRyeS0+dXNlX3RyYWNraW5nID0gMTsKCWVsc2UgaWYgKCFjb2xvblsxXSkKCQlvaWRjbHIoJmVudHJ5LT5leHBlY3QpOwoJZWxzZSBpZiAoZ2V0X29pZChjb2xvbiArIDEsICZlbnRyeS0+ZXhwZWN0KSkKCQlyZXR1cm4gZXJyb3IoImNhbm5vdCBwYXJzZSBleHBlY3RlZCBvYmplY3QgbmFtZSAnJXMnIiwgY29sb24gKyAxKTsKCXJldHVybiAwOwp9CgppbnQgcGFyc2VvcHRfcHVzaF9jYXNfb3B0aW9uKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCXJldHVybiBwYXJzZV9wdXNoX2Nhc19vcHRpb24ob3B0LT52YWx1ZSwgYXJnLCB1bnNldCk7Cn0KCmludCBpc19lbXB0eV9jYXMoY29uc3Qgc3RydWN0IHB1c2hfY2FzX29wdGlvbiAqY2FzKQp7CglyZXR1cm4gIWNhcy0+dXNlX3RyYWNraW5nX2Zvcl9yZXN0ICYmICFjYXMtPm5yOwp9CgovKgogKiBMb29rIGF0IHJlbW90ZS5mZXRjaCByZWZzcGVjIGFuZCBzZWUgaWYgd2UgaGF2ZSBhIHJlbW90ZQogKiB0cmFja2luZyBicmFuY2ggZm9yIHRoZSByZWZuYW1lIHRoZXJlLiAgRmlsbCBpdHMgY3VycmVudAogKiB2YWx1ZSBpbiBzaGExW10uCiAqIElmIHdlIGNhbm5vdCBkbyBzbywgcmV0dXJuIG5lZ2F0aXZlIHRvIHNpZ25hbCBhbiBlcnJvci4KICovCnN0YXRpYyBpbnQgcmVtb3RlX3RyYWNraW5nKHN0cnVjdCByZW1vdGUgKnJlbW90ZSwgY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJICAgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CgljaGFyICpkc3Q7CgoJZHN0ID0gYXBwbHlfcmVmc3BlY3MoJnJlbW90ZS0+ZmV0Y2gsIHJlZm5hbWUpOwoJaWYgKCFkc3QpCgkJcmV0dXJuIC0xOyAvKiBubyB0cmFja2luZyByZWYgZm9yIHJlZm5hbWUgYXQgcmVtb3RlICovCglpZiAocmVhZF9yZWYoZHN0LCBvaWQpKQoJCXJldHVybiAtMTsgLyogd2Uga25vdyB3aGF0IHRoZSB0cmFja2luZyByZWYgaXMgYnV0IHdlIGNhbm5vdCByZWFkIGl0ICovCglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgYXBwbHlfY2FzKHN0cnVjdCBwdXNoX2Nhc19vcHRpb24gKmNhcywKCQkgICAgICBzdHJ1Y3QgcmVtb3RlICpyZW1vdGUsCgkJICAgICAgc3RydWN0IHJlZiAqcmVmKQp7CglpbnQgaTsKCgkvKiBGaW5kIGFuIGV4cGxpY2l0IC0tPG9wdGlvbj49PG5hbWU+Wzo8dmFsdWU+XSBlbnRyeSAqLwoJZm9yIChpID0gMDsgaSA8IGNhcy0+bnI7IGkrKykgewoJCXN0cnVjdCBwdXNoX2NhcyAqZW50cnkgPSAmY2FzLT5lbnRyeVtpXTsKCQlpZiAoIXJlZm5hbWVfbWF0Y2goZW50cnktPnJlZm5hbWUsIHJlZi0+bmFtZSkpCgkJCWNvbnRpbnVlOwoJCXJlZi0+ZXhwZWN0X29sZF9zaGExID0gMTsKCQlpZiAoIWVudHJ5LT51c2VfdHJhY2tpbmcpCgkJCW9pZGNweSgmcmVmLT5vbGRfb2lkX2V4cGVjdCwgJmVudHJ5LT5leHBlY3QpOwoJCWVsc2UgaWYgKHJlbW90ZV90cmFja2luZyhyZW1vdGUsIHJlZi0+bmFtZSwgJnJlZi0+b2xkX29pZF9leHBlY3QpKQoJCQlvaWRjbHIoJnJlZi0+b2xkX29pZF9leHBlY3QpOwoJCXJldHVybjsKCX0KCgkvKiBBcmUgd2UgdXNpbmcgIi0tPG9wdGlvbj4iIHRvIGNvdmVyIGFsbD8gKi8KCWlmICghY2FzLT51c2VfdHJhY2tpbmdfZm9yX3Jlc3QpCgkJcmV0dXJuOwoKCXJlZi0+ZXhwZWN0X29sZF9zaGExID0gMTsKCWlmIChyZW1vdGVfdHJhY2tpbmcocmVtb3RlLCByZWYtPm5hbWUsICZyZWYtPm9sZF9vaWRfZXhwZWN0KSkKCQlvaWRjbHIoJnJlZi0+b2xkX29pZF9leHBlY3QpOwp9Cgp2b2lkIGFwcGx5X3B1c2hfY2FzKHN0cnVjdCBwdXNoX2Nhc19vcHRpb24gKmNhcywKCQkgICAgc3RydWN0IHJlbW90ZSAqcmVtb3RlLAoJCSAgICBzdHJ1Y3QgcmVmICpyZW1vdGVfcmVmcykKewoJc3RydWN0IHJlZiAqcmVmOwoJZm9yIChyZWYgPSByZW1vdGVfcmVmczsgcmVmOyByZWYgPSByZWYtPm5leHQpCgkJYXBwbHlfY2FzKGNhcywgcmVtb3RlLCByZWYpOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"config.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"commit.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"dir.h\"\n#include \"tag.h\"\n#include \"string-list.h\"\n#include \"mergesort.h\"\n#include \"argv-array.h\"\n\nenum map_direction { FROM_SRC, FROM_DST };\n\nstruct counted_string {\n\tsize_t len;\n\tconst char *s;\n};\nstruct rewrite {\n\tconst char *base;\n\tsize_t baselen;\n\tstruct counted_string *instead_of;\n\tint instead_of_nr;\n\tint instead_of_alloc;\n};\nstruct rewrites {\n\tstruct rewrite **rewrite;\n\tint rewrite_alloc;\n\tint rewrite_nr;\n};\n\nstatic struct remote **remotes;\nstatic int remotes_alloc;\nstatic int remotes_nr;\nstatic struct hashmap remotes_hash;\n\nstatic struct branch **branches;\nstatic int branches_alloc;\nstatic int branches_nr;\n\nstatic struct branch *current_branch;\nstatic const char *pushremote_name;\n\nstatic struct rewrites rewrites;\nstatic struct rewrites rewrites_push;\n\nstatic int valid_remote(const struct remote *remote)\n{\n\treturn (!!remote->url) || (!!remote->foreign_vcs);\n}\n\nstatic const char *alias_url(const char *url, struct rewrites *r)\n{\n\tint i, j;\n\tstruct counted_string *longest;\n\tint longest_i;\n\n\tlongest = NULL;\n\tlongest_i = -1;\n\tfor (i = 0; i < r->rewrite_nr; i++) {\n\t\tif (!r->rewrite[i])\n\t\t\tcontinue;\n\t\tfor (j = 0; j < r->rewrite[i]->instead_of_nr; j++) {\n\t\t\tif (starts_with(url, r->rewrite[i]->instead_of[j].s) &&\n\t\t\t    (!longest ||\n\t\t\t     longest->len < r->rewrite[i]->instead_of[j].len)) {\n\t\t\t\tlongest = &(r->rewrite[i]->instead_of[j]);\n\t\t\t\tlongest_i = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (!longest)\n\t\treturn url;\n\n\treturn xstrfmt(\"%s%s\", r->rewrite[longest_i]->base, url + longest->len);\n}\n\nstatic void add_url(struct remote *remote, const char *url)\n{\n\tALLOC_GROW(remote->url, remote->url_nr + 1, remote->url_alloc);\n\tremote->url[remote->url_nr++] = url;\n}\n\nstatic void add_pushurl(struct remote *remote, const char *pushurl)\n{\n\tALLOC_GROW(remote->pushurl, remote->pushurl_nr + 1, remote->pushurl_alloc);\n\tremote->pushurl[remote->pushurl_nr++] = pushurl;\n}\n\nstatic void add_pushurl_alias(struct remote *remote, const char *url)\n{\n\tconst char *pushurl = alias_url(url, &rewrites_push);\n\tif (pushurl != url)\n\t\tadd_pushurl(remote, pushurl);\n}\n\nstatic void add_url_alias(struct remote *remote, const char *url)\n{\n\tadd_url(remote, alias_url(url, &rewrites));\n\tadd_pushurl_alias(remote, url);\n}\n\nstruct remotes_hash_key {\n\tconst char *str;\n\tint len;\n};\n\nstatic int remotes_hash_cmp(const void *unused_cmp_data,\n\t\t\t    const void *entry,\n\t\t\t    const void *entry_or_key,\n\t\t\t    const void *keydata)\n{\n\tconst struct remote *a = entry;\n\tconst struct remote *b = entry_or_key;\n\tconst struct remotes_hash_key *key = keydata;\n\n\tif (key)\n\t\treturn strncmp(a->name, key->str, key->len) || a->name[key->len];\n\telse\n\t\treturn strcmp(a->name, b->name);\n}\n\nstatic inline void init_remotes_hash(void)\n{\n\tif (!remotes_hash.cmpfn)\n\t\thashmap_init(&remotes_hash, remotes_hash_cmp, NULL, 0);\n}\n\nstatic struct remote *make_remote(const char *name, int len)\n{\n\tstruct remote *ret, *replaced;\n\tstruct remotes_hash_key lookup;\n\tstruct hashmap_entry lookup_entry;\n\n\tif (!len)\n\t\tlen = strlen(name);\n\n\tinit_remotes_hash();\n\tlookup.str = name;\n\tlookup.len = len;\n\thashmap_entry_init(&lookup_entry, memhash(name, len));\n\n\tif ((ret = hashmap_get(&remotes_hash, &lookup_entry, &lookup)) != NULL)\n\t\treturn ret;\n\n\tret = xcalloc(1, sizeof(struct remote));\n\tret->prune = -1;  /* unspecified */\n\tret->prune_tags = -1;  /* unspecified */\n\tret->name = xstrndup(name, len);\n\trefspec_init(&ret->push, REFSPEC_PUSH);\n\trefspec_init(&ret->fetch, REFSPEC_FETCH);\n\n\tALLOC_GROW(remotes, remotes_nr + 1, remotes_alloc);\n\tremotes[remotes_nr++] = ret;\n\n\thashmap_entry_init(ret, lookup_entry.hash);\n\treplaced = hashmap_put(&remotes_hash, ret);\n\tassert(replaced == NULL);  /* no previous entry overwritten */\n\treturn ret;\n}\n\nstatic void add_merge(struct branch *branch, const char *name)\n{\n\tALLOC_GROW(branch->merge_name, branch->merge_nr + 1,\n\t\t   branch->merge_alloc);\n\tbranch->merge_name[branch->merge_nr++] = name;\n}\n\nstatic struct branch *make_branch(const char *name, int len)\n{\n\tstruct branch *ret;\n\tint i;\n\n\tfor (i = 0; i < branches_nr; i++) {\n\t\tif (len ? (!strncmp(name, branches[i]->name, len) &&\n\t\t\t   !branches[i]->name[len]) :\n\t\t    !strcmp(name, branches[i]->name))\n\t\t\treturn branches[i];\n\t}\n\n\tALLOC_GROW(branches, branches_nr + 1, branches_alloc);\n\tret = xcalloc(1, sizeof(struct branch));\n\tbranches[branches_nr++] = ret;\n\tif (len)\n\t\tret->name = xstrndup(name, len);\n\telse\n\t\tret->name = xstrdup(name);\n\tret->refname = xstrfmt(\"refs/heads/%s\", ret->name);\n\n\treturn ret;\n}\n\nstatic struct rewrite *make_rewrite(struct rewrites *r, const char *base, int len)\n{\n\tstruct rewrite *ret;\n\tint i;\n\n\tfor (i = 0; i < r->rewrite_nr; i++) {\n\t\tif (len\n\t\t    ? (len == r->rewrite[i]->baselen &&\n\t\t       !strncmp(base, r->rewrite[i]->base, len))\n\t\t    : !strcmp(base, r->rewrite[i]->base))\n\t\t\treturn r->rewrite[i];\n\t}\n\n\tALLOC_GROW(r->rewrite, r->rewrite_nr + 1, r->rewrite_alloc);\n\tret = xcalloc(1, sizeof(struct rewrite));\n\tr->rewrite[r->rewrite_nr++] = ret;\n\tif (len) {\n\t\tret->base = xstrndup(base, len);\n\t\tret->baselen = len;\n\t}\n\telse {\n\t\tret->base = xstrdup(base);\n\t\tret->baselen = strlen(base);\n\t}\n\treturn ret;\n}\n\nstatic void add_instead_of(struct rewrite *rewrite, const char *instead_of)\n{\n\tALLOC_GROW(rewrite->instead_of, rewrite->instead_of_nr + 1, rewrite->instead_of_alloc);\n\trewrite->instead_of[rewrite->instead_of_nr].s = instead_of;\n\trewrite->instead_of[rewrite->instead_of_nr].len = strlen(instead_of);\n\trewrite->instead_of_nr++;\n}\n\nstatic const char *skip_spaces(const char *s)\n{\n\twhile (isspace(*s))\n\t\ts++;\n\treturn s;\n}\n\nstatic void read_remotes_file(struct remote *remote)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tFILE *f = fopen_or_warn(git_path(\"remotes/%s\", remote->name), \"r\");\n\n\tif (!f)\n\t\treturn;\n\tremote->configured_in_repo = 1;\n\tremote->origin = REMOTE_REMOTES;\n\twhile (strbuf_getline(&buf, f) != EOF) {\n\t\tconst char *v;\n\n\t\tstrbuf_rtrim(&buf);\n\n\t\tif (skip_prefix(buf.buf, \"URL:\", &v))\n\t\t\tadd_url_alias(remote, xstrdup(skip_spaces(v)));\n\t\telse if (skip_prefix(buf.buf, \"Push:\", &v))\n\t\t\trefspec_append(&remote->push, skip_spaces(v));\n\t\telse if (skip_prefix(buf.buf, \"Pull:\", &v))\n\t\t\trefspec_append(&remote->fetch, skip_spaces(v));\n\t}\n\tstrbuf_release(&buf);\n\tfclose(f);\n}\n\nstatic void read_branches_file(struct remote *remote)\n{\n\tchar *frag;\n\tstruct strbuf buf = STRBUF_INIT;\n\tFILE *f = fopen_or_warn(git_path(\"branches/%s\", remote->name), \"r\");\n\n\tif (!f)\n\t\treturn;\n\n\tstrbuf_getline_lf(&buf, f);\n\tfclose(f);\n\tstrbuf_trim(&buf);\n\tif (!buf.len) {\n\t\tstrbuf_release(&buf);\n\t\treturn;\n\t}\n\n\tremote->configured_in_repo = 1;\n\tremote->origin = REMOTE_BRANCHES;\n\n\t/*\n\t * The branches file would have URL and optionally\n\t * #branch specified.  The \"master\" (or specified) branch is\n\t * fetched and stored in the local branch matching the\n\t * remote name.\n\t */\n\tfrag = strchr(buf.buf, '#');\n\tif (frag)\n\t\t*(frag++) = '\\0';\n\telse\n\t\tfrag = \"master\";\n\n\tadd_url_alias(remote, strbuf_detach(&buf, NULL));\n\tstrbuf_addf(&buf, \"refs/heads/%s:refs/heads/%s\",\n\t\t    frag, remote->name);\n\trefspec_append(&remote->fetch, buf.buf);\n\n\t/*\n\t * Cogito compatible push: push current HEAD to remote #branch\n\t * (master if missing)\n\t */\n\tstrbuf_reset(&buf);\n\tstrbuf_addf(&buf, \"HEAD:refs/heads/%s\", frag);\n\trefspec_append(&remote->push, buf.buf);\n\tremote->fetch_tags = 1; /* always auto-follow */\n\tstrbuf_release(&buf);\n}\n\nstatic int handle_config(const char *key, const char *value, void *cb)\n{\n\tconst char *name;\n\tint namelen;\n\tconst char *subkey;\n\tstruct remote *remote;\n\tstruct branch *branch;\n\tif (parse_config_key(key, \"branch\", &name, &namelen, &subkey) >= 0) {\n\t\tif (!name)\n\t\t\treturn 0;\n\t\tbranch = make_branch(name, namelen);\n\t\tif (!strcmp(subkey, \"remote\")) {\n\t\t\treturn git_config_string(&branch->remote_name, key, value);\n\t\t} else if (!strcmp(subkey, \"pushremote\")) {\n\t\t\treturn git_config_string(&branch->pushremote_name, key, value);\n\t\t} else if (!strcmp(subkey, \"merge\")) {\n\t\t\tif (!value)\n\t\t\t\treturn config_error_nonbool(key);\n\t\t\tadd_merge(branch, xstrdup(value));\n\t\t}\n\t\treturn 0;\n\t}\n\tif (parse_config_key(key, \"url\", &name, &namelen, &subkey) >= 0) {\n\t\tstruct rewrite *rewrite;\n\t\tif (!name)\n\t\t\treturn 0;\n\t\tif (!strcmp(subkey, \"insteadof\")) {\n\t\t\trewrite = make_rewrite(&rewrites, name, namelen);\n\t\t\tif (!value)\n\t\t\t\treturn config_error_nonbool(key);\n\t\t\tadd_instead_of(rewrite, xstrdup(value));\n\t\t} else if (!strcmp(subkey, \"pushinsteadof\")) {\n\t\t\trewrite = make_rewrite(&rewrites_push, name, namelen);\n\t\t\tif (!value)\n\t\t\t\treturn config_error_nonbool(key);\n\t\t\tadd_instead_of(rewrite, xstrdup(value));\n\t\t}\n\t}\n\n\tif (parse_config_key(key, \"remote\", &name, &namelen, &subkey) < 0)\n\t\treturn 0;\n\n\t/* Handle remote.* variables */\n\tif (!name && !strcmp(subkey, \"pushdefault\"))\n\t\treturn git_config_string(&pushremote_name, key, value);\n\n\tif (!name)\n\t\treturn 0;\n\t/* Handle remote.<name>.* variables */\n\tif (*name == '/') {\n\t\twarning(\"Config remote shorthand cannot begin with '/': %s\",\n\t\t\tname);\n\t\treturn 0;\n\t}\n\tremote = make_remote(name, namelen);\n\tremote->origin = REMOTE_CONFIG;\n\tif (current_config_scope() == CONFIG_SCOPE_REPO)\n\t\tremote->configured_in_repo = 1;\n\tif (!strcmp(subkey, \"mirror\"))\n\t\tremote->mirror = git_config_bool(key, value);\n\telse if (!strcmp(subkey, \"skipdefaultupdate\"))\n\t\tremote->skip_default_update = git_config_bool(key, value);\n\telse if (!strcmp(subkey, \"skipfetchall\"))\n\t\tremote->skip_default_update = git_config_bool(key, value);\n\telse if (!strcmp(subkey, \"prune\"))\n\t\tremote->prune = git_config_bool(key, value);\n\telse if (!strcmp(subkey, \"prunetags\"))\n\t\tremote->prune_tags = git_config_bool(key, value);\n\telse if (!strcmp(subkey, \"url\")) {\n\t\tconst char *v;\n\t\tif (git_config_string(&v, key, value))\n\t\t\treturn -1;\n\t\tadd_url(remote, v);\n\t} else if (!strcmp(subkey, \"pushurl\")) {\n\t\tconst char *v;\n\t\tif (git_config_string(&v, key, value))\n\t\t\treturn -1;\n\t\tadd_pushurl(remote, v);\n\t} else if (!strcmp(subkey, \"push\")) {\n\t\tconst char *v;\n\t\tif (git_config_string(&v, key, value))\n\t\t\treturn -1;\n\t\trefspec_append(&remote->push, v);\n\t\tfree((char *)v);\n\t} else if (!strcmp(subkey, \"fetch\")) {\n\t\tconst char *v;\n\t\tif (git_config_string(&v, key, value))\n\t\t\treturn -1;\n\t\trefspec_append(&remote->fetch, v);\n\t\tfree((char *)v);\n\t} else if (!strcmp(subkey, \"receivepack\")) {\n\t\tconst char *v;\n\t\tif (git_config_string(&v, key, value))\n\t\t\treturn -1;\n\t\tif (!remote->receivepack)\n\t\t\tremote->receivepack = v;\n\t\telse\n\t\t\terror(\"more than one receivepack given, using the first\");\n\t} else if (!strcmp(subkey, \"uploadpack\")) {\n\t\tconst char *v;\n\t\tif (git_config_string(&v, key, value))\n\t\t\treturn -1;\n\t\tif (!remote->uploadpack)\n\t\t\tremote->uploadpack = v;\n\t\telse\n\t\t\terror(\"more than one uploadpack given, using the first\");\n\t} else if (!strcmp(subkey, \"tagopt\")) {\n\t\tif (!strcmp(value, \"--no-tags\"))\n\t\t\tremote->fetch_tags = -1;\n\t\telse if (!strcmp(value, \"--tags\"))\n\t\t\tremote->fetch_tags = 2;\n\t} else if (!strcmp(subkey, \"proxy\")) {\n\t\treturn git_config_string((const char **)&remote->http_proxy,\n\t\t\t\t\t key, value);\n\t} else if (!strcmp(subkey, \"proxyauthmethod\")) {\n\t\treturn git_config_string((const char **)&remote->http_proxy_authmethod,\n\t\t\t\t\t key, value);\n\t} else if (!strcmp(subkey, \"vcs\")) {\n\t\treturn git_config_string(&remote->foreign_vcs, key, value);\n\t}\n\treturn 0;\n}\n\nstatic void alias_all_urls(void)\n{\n\tint i, j;\n\tfor (i = 0; i < remotes_nr; i++) {\n\t\tint add_pushurl_aliases;\n\t\tif (!remotes[i])\n\t\t\tcontinue;\n\t\tfor (j = 0; j < remotes[i]->pushurl_nr; j++) {\n\t\t\tremotes[i]->pushurl[j] = alias_url(remotes[i]->pushurl[j], &rewrites);\n\t\t}\n\t\tadd_pushurl_aliases = remotes[i]->pushurl_nr == 0;\n\t\tfor (j = 0; j < remotes[i]->url_nr; j++) {\n\t\t\tif (add_pushurl_aliases)\n\t\t\t\tadd_pushurl_alias(remotes[i], remotes[i]->url[j]);\n\t\t\tremotes[i]->url[j] = alias_url(remotes[i]->url[j], &rewrites);\n\t\t}\n\t}\n}\n\nstatic void read_config(void)\n{\n\tstatic int loaded;\n\tint flag;\n\n\tif (loaded)\n\t\treturn;\n\tloaded = 1;\n\n\tcurrent_branch = NULL;\n\tif (startup_info->have_repository) {\n\t\tconst char *head_ref = resolve_ref_unsafe(\"HEAD\", 0, NULL, &flag);\n\t\tif (head_ref && (flag & REF_ISSYMREF) &&\n\t\t    skip_prefix(head_ref, \"refs/heads/\", &head_ref)) {\n\t\t\tcurrent_branch = make_branch(head_ref, 0);\n\t\t}\n\t}\n\tgit_config(handle_config, NULL);\n\talias_all_urls();\n}\n\nstatic int valid_remote_nick(const char *name)\n{\n\tif (!name[0] || is_dot_or_dotdot(name))\n\t\treturn 0;\n\n\t/* remote nicknames cannot contain slashes */\n\twhile (*name)\n\t\tif (is_dir_sep(*name++))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nconst char *remote_for_branch(struct branch *branch, int *explicit)\n{\n\tif (branch && branch->remote_name) {\n\t\tif (explicit)\n\t\t\t*explicit = 1;\n\t\treturn branch->remote_name;\n\t}\n\tif (explicit)\n\t\t*explicit = 0;\n\treturn \"origin\";\n}\n\nconst char *pushremote_for_branch(struct branch *branch, int *explicit)\n{\n\tif (branch && branch->pushremote_name) {\n\t\tif (explicit)\n\t\t\t*explicit = 1;\n\t\treturn branch->pushremote_name;\n\t}\n\tif (pushremote_name) {\n\t\tif (explicit)\n\t\t\t*explicit = 1;\n\t\treturn pushremote_name;\n\t}\n\treturn remote_for_branch(branch, explicit);\n}\n\nconst char *remote_ref_for_branch(struct branch *branch, int for_push,\n\t\t\t\t  int *explicit)\n{\n\tif (branch) {\n\t\tif (!for_push) {\n\t\t\tif (branch->merge_nr) {\n\t\t\t\tif (explicit)\n\t\t\t\t\t*explicit = 1;\n\t\t\t\treturn branch->merge_name[0];\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *dst, *remote_name =\n\t\t\t\tpushremote_for_branch(branch, NULL);\n\t\t\tstruct remote *remote = remote_get(remote_name);\n\n\t\t\tif (remote && remote->push.nr &&\n\t\t\t    (dst = apply_refspecs(&remote->push,\n\t\t\t\t\t\t  branch->refname))) {\n\t\t\t\tif (explicit)\n\t\t\t\t\t*explicit = 1;\n\t\t\t\treturn dst;\n\t\t\t}\n\t\t}\n\t}\n\tif (explicit)\n\t\t*explicit = 0;\n\treturn \"\";\n}\n\nstatic struct remote *remote_get_1(const char *name,\n\t\t\t\t   const char *(*get_default)(struct branch *, int *))\n{\n\tstruct remote *ret;\n\tint name_given = 0;\n\n\tread_config();\n\n\tif (name)\n\t\tname_given = 1;\n\telse\n\t\tname = get_default(current_branch, &name_given);\n\n\tret = make_remote(name, 0);\n\tif (valid_remote_nick(name) && have_git_dir()) {\n\t\tif (!valid_remote(ret))\n\t\t\tread_remotes_file(ret);\n\t\tif (!valid_remote(ret))\n\t\t\tread_branches_file(ret);\n\t}\n\tif (name_given && !valid_remote(ret))\n\t\tadd_url_alias(ret, name);\n\tif (!valid_remote(ret))\n\t\treturn NULL;\n\treturn ret;\n}\n\nstruct remote *remote_get(const char *name)\n{\n\treturn remote_get_1(name, remote_for_branch);\n}\n\nstruct remote *pushremote_get(const char *name)\n{\n\treturn remote_get_1(name, pushremote_for_branch);\n}\n\nint remote_is_configured(struct remote *remote, int in_repo)\n{\n\tif (!remote)\n\t\treturn 0;\n\tif (in_repo)\n\t\treturn remote->configured_in_repo;\n\treturn !!remote->origin;\n}\n\nint for_each_remote(each_remote_fn fn, void *priv)\n{\n\tint i, result = 0;\n\tread_config();\n\tfor (i = 0; i < remotes_nr && !result; i++) {\n\t\tstruct remote *r = remotes[i];\n\t\tif (!r)\n\t\t\tcontinue;\n\t\tresult = fn(r, priv);\n\t}\n\treturn result;\n}\n\nstatic void handle_duplicate(struct ref *ref1, struct ref *ref2)\n{\n\tif (strcmp(ref1->name, ref2->name)) {\n\t\tif (ref1->fetch_head_status != FETCH_HEAD_IGNORE &&\n\t\t    ref2->fetch_head_status != FETCH_HEAD_IGNORE) {\n\t\t\tdie(_(\"Cannot fetch both %s and %s to %s\"),\n\t\t\t    ref1->name, ref2->name, ref2->peer_ref->name);\n\t\t} else if (ref1->fetch_head_status != FETCH_HEAD_IGNORE &&\n\t\t\t   ref2->fetch_head_status == FETCH_HEAD_IGNORE) {\n\t\t\twarning(_(\"%s usually tracks %s, not %s\"),\n\t\t\t\tref2->peer_ref->name, ref2->name, ref1->name);\n\t\t} else if (ref1->fetch_head_status == FETCH_HEAD_IGNORE &&\n\t\t\t   ref2->fetch_head_status == FETCH_HEAD_IGNORE) {\n\t\t\tdie(_(\"%s tracks both %s and %s\"),\n\t\t\t    ref2->peer_ref->name, ref1->name, ref2->name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * This last possibility doesn't occur because\n\t\t\t * FETCH_HEAD_IGNORE entries always appear at\n\t\t\t * the end of the list.\n\t\t\t */\n\t\t\tdie(_(\"Internal error\"));\n\t\t}\n\t}\n\tfree(ref2->peer_ref);\n\tfree(ref2);\n}\n\nstruct ref *ref_remove_duplicates(struct ref *ref_map)\n{\n\tstruct string_list refs = STRING_LIST_INIT_NODUP;\n\tstruct ref *retval = NULL;\n\tstruct ref **p = &retval;\n\n\twhile (ref_map) {\n\t\tstruct ref *ref = ref_map;\n\n\t\tref_map = ref_map->next;\n\t\tref->next = NULL;\n\n\t\tif (!ref->peer_ref) {\n\t\t\t*p = ref;\n\t\t\tp = &ref->next;\n\t\t} else {\n\t\t\tstruct string_list_item *item =\n\t\t\t\tstring_list_insert(&refs, ref->peer_ref->name);\n\n\t\t\tif (item->util) {\n\t\t\t\t/* Entry already existed */\n\t\t\t\thandle_duplicate((struct ref *)item->util, ref);\n\t\t\t} else {\n\t\t\t\t*p = ref;\n\t\t\t\tp = &ref->next;\n\t\t\t\titem->util = ref;\n\t\t\t}\n\t\t}\n\t}\n\n\tstring_list_clear(&refs, 0);\n\treturn retval;\n}\n\nint remote_has_url(struct remote *remote, const char *url)\n{\n\tint i;\n\tfor (i = 0; i < remote->url_nr; i++) {\n\t\tif (!strcmp(remote->url[i], url))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int match_name_with_pattern(const char *key, const char *name,\n\t\t\t\t   const char *value, char **result)\n{\n\tconst char *kstar = strchr(key, '*');\n\tsize_t klen;\n\tsize_t ksuffixlen;\n\tsize_t namelen;\n\tint ret;\n\tif (!kstar)\n\t\tdie(\"Key '%s' of pattern had no '*'\", key);\n\tklen = kstar - key;\n\tksuffixlen = strlen(kstar + 1);\n\tnamelen = strlen(name);\n\tret = !strncmp(name, key, klen) && namelen >= klen + ksuffixlen &&\n\t\t!memcmp(name + namelen - ksuffixlen, kstar + 1, ksuffixlen);\n\tif (ret && value) {\n\t\tstruct strbuf sb = STRBUF_INIT;\n\t\tconst char *vstar = strchr(value, '*');\n\t\tif (!vstar)\n\t\t\tdie(\"Value '%s' of pattern has no '*'\", value);\n\t\tstrbuf_add(&sb, value, vstar - value);\n\t\tstrbuf_add(&sb, name + klen, namelen - klen - ksuffixlen);\n\t\tstrbuf_addstr(&sb, vstar + 1);\n\t\t*result = strbuf_detach(&sb, NULL);\n\t}\n\treturn ret;\n}\n\nstatic void query_refspecs_multiple(struct refspec *rs,\n\t\t\t\t    struct refspec_item *query,\n\t\t\t\t    struct string_list *results)\n{\n\tint i;\n\tint find_src = !query->src;\n\n\tif (find_src && !query->dst)\n\t\terror(\"query_refspecs_multiple: need either src or dst\");\n\n\tfor (i = 0; i < rs->nr; i++) {\n\t\tstruct refspec_item *refspec = &rs->items[i];\n\t\tconst char *key = find_src ? refspec->dst : refspec->src;\n\t\tconst char *value = find_src ? refspec->src : refspec->dst;\n\t\tconst char *needle = find_src ? query->dst : query->src;\n\t\tchar **result = find_src ? &query->src : &query->dst;\n\n\t\tif (!refspec->dst)\n\t\t\tcontinue;\n\t\tif (refspec->pattern) {\n\t\t\tif (match_name_with_pattern(key, needle, value, result))\n\t\t\t\tstring_list_append_nodup(results, *result);\n\t\t} else if (!strcmp(needle, key)) {\n\t\t\tstring_list_append(results, value);\n\t\t}\n\t}\n}\n\nint query_refspecs(struct refspec *rs, struct refspec_item *query)\n{\n\tint i;\n\tint find_src = !query->src;\n\tconst char *needle = find_src ? query->dst : query->src;\n\tchar **result = find_src ? &query->src : &query->dst;\n\n\tif (find_src && !query->dst)\n\t\treturn error(\"query_refspecs: need either src or dst\");\n\n\tfor (i = 0; i < rs->nr; i++) {\n\t\tstruct refspec_item *refspec = &rs->items[i];\n\t\tconst char *key = find_src ? refspec->dst : refspec->src;\n\t\tconst char *value = find_src ? refspec->src : refspec->dst;\n\n\t\tif (!refspec->dst)\n\t\t\tcontinue;\n\t\tif (refspec->pattern) {\n\t\t\tif (match_name_with_pattern(key, needle, value, result)) {\n\t\t\t\tquery->force = refspec->force;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if (!strcmp(needle, key)) {\n\t\t\t*result = xstrdup(value);\n\t\t\tquery->force = refspec->force;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nchar *apply_refspecs(struct refspec *rs, const char *name)\n{\n\tstruct refspec_item query;\n\n\tmemset(&query, 0, sizeof(struct refspec_item));\n\tquery.src = (char *)name;\n\n\tif (query_refspecs(rs, &query))\n\t\treturn NULL;\n\n\treturn query.dst;\n}\n\nint remote_find_tracking(struct remote *remote, struct refspec_item *refspec)\n{\n\treturn query_refspecs(&remote->fetch, refspec);\n}\n\nstatic struct ref *alloc_ref_with_prefix(const char *prefix, size_t prefixlen,\n\t\tconst char *name)\n{\n\tsize_t len = strlen(name);\n\tstruct ref *ref = xcalloc(1, st_add4(sizeof(*ref), prefixlen, len, 1));\n\tmemcpy(ref->name, prefix, prefixlen);\n\tmemcpy(ref->name + prefixlen, name, len);\n\treturn ref;\n}\n\nstruct ref *alloc_ref(const char *name)\n{\n\treturn alloc_ref_with_prefix(\"\", 0, name);\n}\n\nstruct ref *copy_ref(const struct ref *ref)\n{\n\tstruct ref *cpy;\n\tsize_t len;\n\tif (!ref)\n\t\treturn NULL;\n\tlen = st_add3(sizeof(struct ref), strlen(ref->name), 1);\n\tcpy = xmalloc(len);\n\tmemcpy(cpy, ref, len);\n\tcpy->next = NULL;\n\tcpy->symref = xstrdup_or_null(ref->symref);\n\tcpy->remote_status = xstrdup_or_null(ref->remote_status);\n\tcpy->peer_ref = copy_ref(ref->peer_ref);\n\treturn cpy;\n}\n\nstruct ref *copy_ref_list(const struct ref *ref)\n{\n\tstruct ref *ret = NULL;\n\tstruct ref **tail = &ret;\n\twhile (ref) {\n\t\t*tail = copy_ref(ref);\n\t\tref = ref->next;\n\t\ttail = &((*tail)->next);\n\t}\n\treturn ret;\n}\n\nstatic void free_ref(struct ref *ref)\n{\n\tif (!ref)\n\t\treturn;\n\tfree_ref(ref->peer_ref);\n\tfree(ref->remote_status);\n\tfree(ref->symref);\n\tfree(ref);\n}\n\nvoid free_refs(struct ref *ref)\n{\n\tstruct ref *next;\n\twhile (ref) {\n\t\tnext = ref->next;\n\t\tfree_ref(ref);\n\t\tref = next;\n\t}\n}\n\nint ref_compare_name(const void *va, const void *vb)\n{\n\tconst struct ref *a = va, *b = vb;\n\treturn strcmp(a->name, b->name);\n}\n\nstatic void *ref_list_get_next(const void *a)\n{\n\treturn ((const struct ref *)a)->next;\n}\n\nstatic void ref_list_set_next(void *a, void *next)\n{\n\t((struct ref *)a)->next = next;\n}\n\nvoid sort_ref_list(struct ref **l, int (*cmp)(const void *, const void *))\n{\n\t*l = llist_mergesort(*l, ref_list_get_next, ref_list_set_next, cmp);\n}\n\nint count_refspec_match(const char *pattern,\n\t\t\tstruct ref *refs,\n\t\t\tstruct ref **matched_ref)\n{\n\tint patlen = strlen(pattern);\n\tstruct ref *matched_weak = NULL;\n\tstruct ref *matched = NULL;\n\tint weak_match = 0;\n\tint match = 0;\n\n\tfor (weak_match = match = 0; refs; refs = refs->next) {\n\t\tchar *name = refs->name;\n\t\tint namelen = strlen(name);\n\n\t\tif (!refname_match(pattern, name))\n\t\t\tcontinue;\n\n\t\t/* A match is \"weak\" if it is with refs outside\n\t\t * heads or tags, and did not specify the pattern\n\t\t * in full (e.g. \"refs/remotes/origin/master\") or at\n\t\t * least from the toplevel (e.g. \"remotes/origin/master\");\n\t\t * otherwise \"git push $URL master\" would result in\n\t\t * ambiguity between remotes/origin/master and heads/master\n\t\t * at the remote site.\n\t\t */\n\t\tif (namelen != patlen &&\n\t\t    patlen != namelen - 5 &&\n\t\t    !starts_with(name, \"refs/heads/\") &&\n\t\t    !starts_with(name, \"refs/tags/\")) {\n\t\t\t/* We want to catch the case where only weak\n\t\t\t * matches are found and there are multiple\n\t\t\t * matches, and where more than one strong\n\t\t\t * matches are found, as ambiguous.  One\n\t\t\t * strong match with zero or more weak matches\n\t\t\t * are acceptable as a unique match.\n\t\t\t */\n\t\t\tmatched_weak = refs;\n\t\t\tweak_match++;\n\t\t}\n\t\telse {\n\t\t\tmatched = refs;\n\t\t\tmatch++;\n\t\t}\n\t}\n\tif (!matched) {\n\t\tif (matched_ref)\n\t\t\t*matched_ref = matched_weak;\n\t\treturn weak_match;\n\t}\n\telse {\n\t\tif (matched_ref)\n\t\t\t*matched_ref = matched;\n\t\treturn match;\n\t}\n}\n\nstatic void tail_link_ref(struct ref *ref, struct ref ***tail)\n{\n\t**tail = ref;\n\twhile (ref->next)\n\t\tref = ref->next;\n\t*tail = &ref->next;\n}\n\nstatic struct ref *alloc_delete_ref(void)\n{\n\tstruct ref *ref = alloc_ref(\"(delete)\");\n\toidclr(&ref->new_oid);\n\treturn ref;\n}\n\nstatic int try_explicit_object_name(const char *name,\n\t\t\t\t    struct ref **match)\n{\n\tstruct object_id oid;\n\n\tif (!*name) {\n\t\tif (match)\n\t\t\t*match = alloc_delete_ref();\n\t\treturn 0;\n\t}\n\n\tif (get_oid(name, &oid))\n\t\treturn -1;\n\n\tif (match) {\n\t\t*match = alloc_ref(name);\n\t\toidcpy(&(*match)->new_oid, &oid);\n\t}\n\treturn 0;\n}\n\nstatic struct ref *make_linked_ref(const char *name, struct ref ***tail)\n{\n\tstruct ref *ret = alloc_ref(name);\n\ttail_link_ref(ret, tail);\n\treturn ret;\n}\n\nstatic char *guess_ref(const char *name, struct ref *peer)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tconst char *r = resolve_ref_unsafe(peer->name, RESOLVE_REF_READING,\n\t\t\t\t\t   NULL, NULL);\n\tif (!r)\n\t\treturn NULL;\n\n\tif (starts_with(r, \"refs/heads/\"))\n\t\tstrbuf_addstr(&buf, \"refs/heads/\");\n\telse if (starts_with(r, \"refs/tags/\"))\n\t\tstrbuf_addstr(&buf, \"refs/tags/\");\n\telse\n\t\treturn NULL;\n\n\tstrbuf_addstr(&buf, name);\n\treturn strbuf_detach(&buf, NULL);\n}\n\nstatic int match_explicit_lhs(struct ref *src,\n\t\t\t      struct refspec_item *rs,\n\t\t\t      struct ref **match,\n\t\t\t      int *allocated_match)\n{\n\tswitch (count_refspec_match(rs->src, src, match)) {\n\tcase 1:\n\t\tif (allocated_match)\n\t\t\t*allocated_match = 0;\n\t\treturn 0;\n\tcase 0:\n\t\t/* The source could be in the get_sha1() format\n\t\t * not a reference name.  :refs/other is a\n\t\t * way to delete 'other' ref at the remote end.\n\t\t */\n\t\tif (try_explicit_object_name(rs->src, match) < 0)\n\t\t\treturn error(\"src refspec %s does not match any.\", rs->src);\n\t\tif (allocated_match)\n\t\t\t*allocated_match = 1;\n\t\treturn 0;\n\tdefault:\n\t\treturn error(\"src refspec %s matches more than one.\", rs->src);\n\t}\n}\n\nstatic int match_explicit(struct ref *src, struct ref *dst,\n\t\t\t  struct ref ***dst_tail,\n\t\t\t  struct refspec_item *rs)\n{\n\tstruct ref *matched_src, *matched_dst;\n\tint allocated_src;\n\n\tconst char *dst_value = rs->dst;\n\tchar *dst_guess;\n\n\tif (rs->pattern || rs->matching)\n\t\treturn 0;\n\n\tmatched_src = matched_dst = NULL;\n\tif (match_explicit_lhs(src, rs, &matched_src, &allocated_src) < 0)\n\t\treturn -1;\n\n\tif (!dst_value) {\n\t\tint flag;\n\n\t\tdst_value = resolve_ref_unsafe(matched_src->name,\n\t\t\t\t\t       RESOLVE_REF_READING,\n\t\t\t\t\t       NULL, &flag);\n\t\tif (!dst_value ||\n\t\t    ((flag & REF_ISSYMREF) &&\n\t\t     !starts_with(dst_value, \"refs/heads/\")))\n\t\t\tdie(\"%s cannot be resolved to branch.\",\n\t\t\t    matched_src->name);\n\t}\n\n\tswitch (count_refspec_match(dst_value, dst, &matched_dst)) {\n\tcase 1:\n\t\tbreak;\n\tcase 0:\n\t\tif (starts_with(dst_value, \"refs/\"))\n\t\t\tmatched_dst = make_linked_ref(dst_value, dst_tail);\n\t\telse if (is_null_oid(&matched_src->new_oid))\n\t\t\terror(\"unable to delete '%s': remote ref does not exist\",\n\t\t\t      dst_value);\n\t\telse if ((dst_guess = guess_ref(dst_value, matched_src))) {\n\t\t\tmatched_dst = make_linked_ref(dst_guess, dst_tail);\n\t\t\tfree(dst_guess);\n\t\t} else\n\t\t\terror(\"unable to push to unqualified destination: %s\\n\"\n\t\t\t      \"The destination refspec neither matches an \"\n\t\t\t      \"existing ref on the remote nor\\n\"\n\t\t\t      \"begins with refs/, and we are unable to \"\n\t\t\t      \"guess a prefix based on the source ref.\",\n\t\t\t      dst_value);\n\t\tbreak;\n\tdefault:\n\t\tmatched_dst = NULL;\n\t\terror(\"dst refspec %s matches more than one.\",\n\t\t      dst_value);\n\t\tbreak;\n\t}\n\tif (!matched_dst)\n\t\treturn -1;\n\tif (matched_dst->peer_ref)\n\t\treturn error(\"dst ref %s receives from more than one src.\",\n\t\t      matched_dst->name);\n\telse {\n\t\tmatched_dst->peer_ref = allocated_src ?\n\t\t\t\t\tmatched_src :\n\t\t\t\t\tcopy_ref(matched_src);\n\t\tmatched_dst->force = rs->force;\n\t}\n\treturn 0;\n}\n\nstatic int match_explicit_refs(struct ref *src, struct ref *dst,\n\t\t\t       struct ref ***dst_tail, struct refspec *rs)\n{\n\tint i, errs;\n\tfor (i = errs = 0; i < rs->nr; i++)\n\t\terrs += match_explicit(src, dst, dst_tail, &rs->items[i]);\n\treturn errs;\n}\n\nstatic char *get_ref_match(const struct refspec *rs, const struct ref *ref,\n\t\t\t   int send_mirror, int direction,\n\t\t\t   const struct refspec_item **ret_pat)\n{\n\tconst struct refspec_item *pat;\n\tchar *name;\n\tint i;\n\tint matching_refs = -1;\n\tfor (i = 0; i < rs->nr; i++) {\n\t\tconst struct refspec_item *item = &rs->items[i];\n\t\tif (item->matching &&\n\t\t    (matching_refs == -1 || item->force)) {\n\t\t\tmatching_refs = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (item->pattern) {\n\t\t\tconst char *dst_side = item->dst ? item->dst : item->src;\n\t\t\tint match;\n\t\t\tif (direction == FROM_SRC)\n\t\t\t\tmatch = match_name_with_pattern(item->src, ref->name, dst_side, &name);\n\t\t\telse\n\t\t\t\tmatch = match_name_with_pattern(dst_side, ref->name, item->src, &name);\n\t\t\tif (match) {\n\t\t\t\tmatching_refs = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (matching_refs == -1)\n\t\treturn NULL;\n\n\tpat = &rs->items[matching_refs];\n\tif (pat->matching) {\n\t\t/*\n\t\t * \"matching refs\"; traditionally we pushed everything\n\t\t * including refs outside refs/heads/ hierarchy, but\n\t\t * that does not make much sense these days.\n\t\t */\n\t\tif (!send_mirror && !starts_with(ref->name, \"refs/heads/\"))\n\t\t\treturn NULL;\n\t\tname = xstrdup(ref->name);\n\t}\n\tif (ret_pat)\n\t\t*ret_pat = pat;\n\treturn name;\n}\n\nstatic struct ref **tail_ref(struct ref **head)\n{\n\tstruct ref **tail = head;\n\twhile (*tail)\n\t\ttail = &((*tail)->next);\n\treturn tail;\n}\n\nstruct tips {\n\tstruct commit **tip;\n\tint nr, alloc;\n};\n\nstatic void add_to_tips(struct tips *tips, const struct object_id *oid)\n{\n\tstruct commit *commit;\n\n\tif (is_null_oid(oid))\n\t\treturn;\n\tcommit = lookup_commit_reference_gently(oid, 1);\n\tif (!commit || (commit->object.flags & TMP_MARK))\n\t\treturn;\n\tcommit->object.flags |= TMP_MARK;\n\tALLOC_GROW(tips->tip, tips->nr + 1, tips->alloc);\n\ttips->tip[tips->nr++] = commit;\n}\n\nstatic void add_missing_tags(struct ref *src, struct ref **dst, struct ref ***dst_tail)\n{\n\tstruct string_list dst_tag = STRING_LIST_INIT_NODUP;\n\tstruct string_list src_tag = STRING_LIST_INIT_NODUP;\n\tstruct string_list_item *item;\n\tstruct ref *ref;\n\tstruct tips sent_tips;\n\n\t/*\n\t * Collect everything we know they would have at the end of\n\t * this push, and collect all tags they have.\n\t */\n\tmemset(&sent_tips, 0, sizeof(sent_tips));\n\tfor (ref = *dst; ref; ref = ref->next) {\n\t\tif (ref->peer_ref &&\n\t\t    !is_null_oid(&ref->peer_ref->new_oid))\n\t\t\tadd_to_tips(&sent_tips, &ref->peer_ref->new_oid);\n\t\telse\n\t\t\tadd_to_tips(&sent_tips, &ref->old_oid);\n\t\tif (starts_with(ref->name, \"refs/tags/\"))\n\t\t\tstring_list_append(&dst_tag, ref->name);\n\t}\n\tclear_commit_marks_many(sent_tips.nr, sent_tips.tip, TMP_MARK);\n\n\tstring_list_sort(&dst_tag);\n\n\t/* Collect tags they do not have. */\n\tfor (ref = src; ref; ref = ref->next) {\n\t\tif (!starts_with(ref->name, \"refs/tags/\"))\n\t\t\tcontinue; /* not a tag */\n\t\tif (string_list_has_string(&dst_tag, ref->name))\n\t\t\tcontinue; /* they already have it */\n\t\tif (oid_object_info(&ref->new_oid, NULL) != OBJ_TAG)\n\t\t\tcontinue; /* be conservative */\n\t\titem = string_list_append(&src_tag, ref->name);\n\t\titem->util = ref;\n\t}\n\tstring_list_clear(&dst_tag, 0);\n\n\t/*\n\t * At this point, src_tag lists tags that are missing from\n\t * dst, and sent_tips lists the tips we are pushing or those\n\t * that we know they already have. An element in the src_tag\n\t * that is an ancestor of any of the sent_tips needs to be\n\t * sent to the other side.\n\t */\n\tif (sent_tips.nr) {\n\t\tfor_each_string_list_item(item, &src_tag) {\n\t\t\tstruct ref *ref = item->util;\n\t\t\tstruct ref *dst_ref;\n\t\t\tstruct commit *commit;\n\n\t\t\tif (is_null_oid(&ref->new_oid))\n\t\t\t\tcontinue;\n\t\t\tcommit = lookup_commit_reference_gently(&ref->new_oid,\n\t\t\t\t\t\t\t\t1);\n\t\t\tif (!commit)\n\t\t\t\t/* not pushing a commit, which is not an error */\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Is this tag, which they do not have, reachable from\n\t\t\t * any of the commits we are sending?\n\t\t\t */\n\t\t\tif (!in_merge_bases_many(commit, sent_tips.nr, sent_tips.tip))\n\t\t\t\tcontinue;\n\n\t\t\t/* Add it in */\n\t\t\tdst_ref = make_linked_ref(ref->name, dst_tail);\n\t\t\toidcpy(&dst_ref->new_oid, &ref->new_oid);\n\t\t\tdst_ref->peer_ref = copy_ref(ref);\n\t\t}\n\t}\n\tstring_list_clear(&src_tag, 0);\n\tfree(sent_tips.tip);\n}\n\nstruct ref *find_ref_by_name(const struct ref *list, const char *name)\n{\n\tfor ( ; list; list = list->next)\n\t\tif (!strcmp(list->name, name))\n\t\t\treturn (struct ref *)list;\n\treturn NULL;\n}\n\nstatic void prepare_ref_index(struct string_list *ref_index, struct ref *ref)\n{\n\tfor ( ; ref; ref = ref->next)\n\t\tstring_list_append_nodup(ref_index, ref->name)->util = ref;\n\n\tstring_list_sort(ref_index);\n}\n\n/*\n * Given only the set of local refs, sanity-check the set of push\n * refspecs. We can't catch all errors that match_push_refs would,\n * but we can catch some errors early before even talking to the\n * remote side.\n */\nint check_push_refs(struct ref *src, int nr_refspec, const char **refspec_names)\n{\n\tstruct refspec refspec = REFSPEC_INIT_PUSH;\n\tint ret = 0;\n\tint i;\n\n\trefspec_appendn(&refspec, refspec_names, nr_refspec);\n\n\tfor (i = 0; i < refspec.nr; i++) {\n\t\tstruct refspec_item *rs = &refspec.items[i];\n\n\t\tif (rs->pattern || rs->matching)\n\t\t\tcontinue;\n\n\t\tret |= match_explicit_lhs(src, rs, NULL, NULL);\n\t}\n\n\trefspec_clear(&refspec);\n\treturn ret;\n}\n\n/*\n * Given the set of refs the local repository has, the set of refs the\n * remote repository has, and the refspec used for push, determine\n * what remote refs we will update and with what value by setting\n * peer_ref (which object is being pushed) and force (if the push is\n * forced) in elements of \"dst\". The function may add new elements to\n * dst (e.g. pushing to a new branch, done in match_explicit_refs).\n */\nint match_push_refs(struct ref *src, struct ref **dst,\n\t\t    struct refspec *rs, int flags)\n{\n\tint send_all = flags & MATCH_REFS_ALL;\n\tint send_mirror = flags & MATCH_REFS_MIRROR;\n\tint send_prune = flags & MATCH_REFS_PRUNE;\n\tint errs;\n\tstruct ref *ref, **dst_tail = tail_ref(dst);\n\tstruct string_list dst_ref_index = STRING_LIST_INIT_NODUP;\n\n\t/* If no refspec is provided, use the default \":\" */\n\tif (!rs->nr)\n\t\trefspec_append(rs, \":\");\n\n\terrs = match_explicit_refs(src, *dst, &dst_tail, rs);\n\n\t/* pick the remainder */\n\tfor (ref = src; ref; ref = ref->next) {\n\t\tstruct string_list_item *dst_item;\n\t\tstruct ref *dst_peer;\n\t\tconst struct refspec_item *pat = NULL;\n\t\tchar *dst_name;\n\n\t\tdst_name = get_ref_match(rs, ref, send_mirror, FROM_SRC, &pat);\n\t\tif (!dst_name)\n\t\t\tcontinue;\n\n\t\tif (!dst_ref_index.nr)\n\t\t\tprepare_ref_index(&dst_ref_index, *dst);\n\n\t\tdst_item = string_list_lookup(&dst_ref_index, dst_name);\n\t\tdst_peer = dst_item ? dst_item->util : NULL;\n\t\tif (dst_peer) {\n\t\t\tif (dst_peer->peer_ref)\n\t\t\t\t/* We're already sending something to this ref. */\n\t\t\t\tgoto free_name;\n\t\t} else {\n\t\t\tif (pat->matching && !(send_all || send_mirror))\n\t\t\t\t/*\n\t\t\t\t * Remote doesn't have it, and we have no\n\t\t\t\t * explicit pattern, and we don't have\n\t\t\t\t * --all or --mirror.\n\t\t\t\t */\n\t\t\t\tgoto free_name;\n\n\t\t\t/* Create a new one and link it */\n\t\t\tdst_peer = make_linked_ref(dst_name, &dst_tail);\n\t\t\toidcpy(&dst_peer->new_oid, &ref->new_oid);\n\t\t\tstring_list_insert(&dst_ref_index,\n\t\t\t\tdst_peer->name)->util = dst_peer;\n\t\t}\n\t\tdst_peer->peer_ref = copy_ref(ref);\n\t\tdst_peer->force = pat->force;\n\tfree_name:\n\t\tfree(dst_name);\n\t}\n\n\tstring_list_clear(&dst_ref_index, 0);\n\n\tif (flags & MATCH_REFS_FOLLOW_TAGS)\n\t\tadd_missing_tags(src, dst, &dst_tail);\n\n\tif (send_prune) {\n\t\tstruct string_list src_ref_index = STRING_LIST_INIT_NODUP;\n\t\t/* check for missing refs on the remote */\n\t\tfor (ref = *dst; ref; ref = ref->next) {\n\t\t\tchar *src_name;\n\n\t\t\tif (ref->peer_ref)\n\t\t\t\t/* We're already sending something to this ref. */\n\t\t\t\tcontinue;\n\n\t\t\tsrc_name = get_ref_match(rs, ref, send_mirror, FROM_DST, NULL);\n\t\t\tif (src_name) {\n\t\t\t\tif (!src_ref_index.nr)\n\t\t\t\t\tprepare_ref_index(&src_ref_index, src);\n\t\t\t\tif (!string_list_has_string(&src_ref_index,\n\t\t\t\t\t    src_name))\n\t\t\t\t\tref->peer_ref = alloc_delete_ref();\n\t\t\t\tfree(src_name);\n\t\t\t}\n\t\t}\n\t\tstring_list_clear(&src_ref_index, 0);\n\t}\n\n\tif (errs)\n\t\treturn -1;\n\treturn 0;\n}\n\nvoid set_ref_status_for_push(struct ref *remote_refs, int send_mirror,\n\t\t\t     int force_update)\n{\n\tstruct ref *ref;\n\n\tfor (ref = remote_refs; ref; ref = ref->next) {\n\t\tint force_ref_update = ref->force || force_update;\n\t\tint reject_reason = 0;\n\n\t\tif (ref->peer_ref)\n\t\t\toidcpy(&ref->new_oid, &ref->peer_ref->new_oid);\n\t\telse if (!send_mirror)\n\t\t\tcontinue;\n\n\t\tref->deletion = is_null_oid(&ref->new_oid);\n\t\tif (!ref->deletion &&\n\t\t\t!oidcmp(&ref->old_oid, &ref->new_oid)) {\n\t\t\tref->status = REF_STATUS_UPTODATE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the remote ref has moved and is now different\n\t\t * from what we expect, reject any push.\n\t\t *\n\t\t * It also is an error if the user told us to check\n\t\t * with the remote-tracking branch to find the value\n\t\t * to expect, but we did not have such a tracking\n\t\t * branch.\n\t\t */\n\t\tif (ref->expect_old_sha1) {\n\t\t\tif (oidcmp(&ref->old_oid, &ref->old_oid_expect))\n\t\t\t\treject_reason = REF_STATUS_REJECT_STALE;\n\t\t\telse\n\t\t\t\t/* If the ref isn't stale then force the update. */\n\t\t\t\tforce_ref_update = 1;\n\t\t}\n\n\t\t/*\n\t\t * If the update isn't already rejected then check\n\t\t * the usual \"must fast-forward\" rules.\n\t\t *\n\t\t * Decide whether an individual refspec A:B can be\n\t\t * pushed.  The push will succeed if any of the\n\t\t * following are true:\n\t\t *\n\t\t * (1) the remote reference B does not exist\n\t\t *\n\t\t * (2) the remote reference B is being removed (i.e.,\n\t\t *     pushing :B where no source is specified)\n\t\t *\n\t\t * (3) the destination is not under refs/tags/, and\n\t\t *     if the old and new value is a commit, the new\n\t\t *     is a descendant of the old.\n\t\t *\n\t\t * (4) it is forced using the +A:B notation, or by\n\t\t *     passing the --force argument\n\t\t */\n\n\t\tif (!reject_reason && !ref->deletion && !is_null_oid(&ref->old_oid)) {\n\t\t\tif (starts_with(ref->name, \"refs/tags/\"))\n\t\t\t\treject_reason = REF_STATUS_REJECT_ALREADY_EXISTS;\n\t\t\telse if (!has_object_file(&ref->old_oid))\n\t\t\t\treject_reason = REF_STATUS_REJECT_FETCH_FIRST;\n\t\t\telse if (!lookup_commit_reference_gently(&ref->old_oid, 1) ||\n\t\t\t\t !lookup_commit_reference_gently(&ref->new_oid, 1))\n\t\t\t\treject_reason = REF_STATUS_REJECT_NEEDS_FORCE;\n\t\t\telse if (!ref_newer(&ref->new_oid, &ref->old_oid))\n\t\t\t\treject_reason = REF_STATUS_REJECT_NONFASTFORWARD;\n\t\t}\n\n\t\t/*\n\t\t * \"--force\" will defeat any rejection implemented\n\t\t * by the rules above.\n\t\t */\n\t\tif (!force_ref_update)\n\t\t\tref->status = reject_reason;\n\t\telse if (reject_reason)\n\t\t\tref->forced_update = 1;\n\t}\n}\n\nstatic void set_merge(struct branch *ret)\n{\n\tstruct remote *remote;\n\tchar *ref;\n\tstruct object_id oid;\n\tint i;\n\n\tif (!ret)\n\t\treturn; /* no branch */\n\tif (ret->merge)\n\t\treturn; /* already run */\n\tif (!ret->remote_name || !ret->merge_nr) {\n\t\t/*\n\t\t * no merge config; let's make sure we don't confuse callers\n\t\t * with a non-zero merge_nr but a NULL merge\n\t\t */\n\t\tret->merge_nr = 0;\n\t\treturn;\n\t}\n\n\tremote = remote_get(ret->remote_name);\n\n\tret->merge = xcalloc(ret->merge_nr, sizeof(*ret->merge));\n\tfor (i = 0; i < ret->merge_nr; i++) {\n\t\tret->merge[i] = xcalloc(1, sizeof(**ret->merge));\n\t\tret->merge[i]->src = xstrdup(ret->merge_name[i]);\n\t\tif (!remote_find_tracking(remote, ret->merge[i]) ||\n\t\t    strcmp(ret->remote_name, \".\"))\n\t\t\tcontinue;\n\t\tif (dwim_ref(ret->merge_name[i], strlen(ret->merge_name[i]),\n\t\t\t     &oid, &ref) == 1)\n\t\t\tret->merge[i]->dst = ref;\n\t\telse\n\t\t\tret->merge[i]->dst = xstrdup(ret->merge_name[i]);\n\t}\n}\n\nstruct branch *branch_get(const char *name)\n{\n\tstruct branch *ret;\n\n\tread_config();\n\tif (!name || !*name || !strcmp(name, \"HEAD\"))\n\t\tret = current_branch;\n\telse\n\t\tret = make_branch(name, 0);\n\tset_merge(ret);\n\treturn ret;\n}\n\nint branch_has_merge_config(struct branch *branch)\n{\n\treturn branch && !!branch->merge;\n}\n\nint branch_merge_matches(struct branch *branch,\n\t\t                 int i,\n\t\t                 const char *refname)\n{\n\tif (!branch || i < 0 || i >= branch->merge_nr)\n\t\treturn 0;\n\treturn refname_match(branch->merge[i]->src, refname);\n}\n\n__attribute__((format (printf,2,3)))\nstatic const char *error_buf(struct strbuf *err, const char *fmt, ...)\n{\n\tif (err) {\n\t\tva_list ap;\n\t\tva_start(ap, fmt);\n\t\tstrbuf_vaddf(err, fmt, ap);\n\t\tva_end(ap);\n\t}\n\treturn NULL;\n}\n\nconst char *branch_get_upstream(struct branch *branch, struct strbuf *err)\n{\n\tif (!branch)\n\t\treturn error_buf(err, _(\"HEAD does not point to a branch\"));\n\n\tif (!branch->merge || !branch->merge[0]) {\n\t\t/*\n\t\t * no merge config; is it because the user didn't define any,\n\t\t * or because it is not a real branch, and get_branch\n\t\t * auto-vivified it?\n\t\t */\n\t\tif (!ref_exists(branch->refname))\n\t\t\treturn error_buf(err, _(\"no such branch: '%s'\"),\n\t\t\t\t\t branch->name);\n\t\treturn error_buf(err,\n\t\t\t\t _(\"no upstream configured for branch '%s'\"),\n\t\t\t\t branch->name);\n\t}\n\n\tif (!branch->merge[0]->dst)\n\t\treturn error_buf(err,\n\t\t\t\t _(\"upstream branch '%s' not stored as a remote-tracking branch\"),\n\t\t\t\t branch->merge[0]->src);\n\n\treturn branch->merge[0]->dst;\n}\n\nstatic const char *tracking_for_push_dest(struct remote *remote,\n\t\t\t\t\t  const char *refname,\n\t\t\t\t\t  struct strbuf *err)\n{\n\tchar *ret;\n\n\tret = apply_refspecs(&remote->fetch, refname);\n\tif (!ret)\n\t\treturn error_buf(err,\n\t\t\t\t _(\"push destination '%s' on remote '%s' has no local tracking branch\"),\n\t\t\t\t refname, remote->name);\n\treturn ret;\n}\n\nstatic const char *branch_get_push_1(struct branch *branch, struct strbuf *err)\n{\n\tstruct remote *remote;\n\n\tremote = remote_get(pushremote_for_branch(branch, NULL));\n\tif (!remote)\n\t\treturn error_buf(err,\n\t\t\t\t _(\"branch '%s' has no remote for pushing\"),\n\t\t\t\t branch->name);\n\n\tif (remote->push.nr) {\n\t\tchar *dst;\n\t\tconst char *ret;\n\n\t\tdst = apply_refspecs(&remote->push, branch->refname);\n\t\tif (!dst)\n\t\t\treturn error_buf(err,\n\t\t\t\t\t _(\"push refspecs for '%s' do not include '%s'\"),\n\t\t\t\t\t remote->name, branch->name);\n\n\t\tret = tracking_for_push_dest(remote, dst, err);\n\t\tfree(dst);\n\t\treturn ret;\n\t}\n\n\tif (remote->mirror)\n\t\treturn tracking_for_push_dest(remote, branch->refname, err);\n\n\tswitch (push_default) {\n\tcase PUSH_DEFAULT_NOTHING:\n\t\treturn error_buf(err, _(\"push has no destination (push.default is 'nothing')\"));\n\n\tcase PUSH_DEFAULT_MATCHING:\n\tcase PUSH_DEFAULT_CURRENT:\n\t\treturn tracking_for_push_dest(remote, branch->refname, err);\n\n\tcase PUSH_DEFAULT_UPSTREAM:\n\t\treturn branch_get_upstream(branch, err);\n\n\tcase PUSH_DEFAULT_UNSPECIFIED:\n\tcase PUSH_DEFAULT_SIMPLE:\n\t\t{\n\t\t\tconst char *up, *cur;\n\n\t\t\tup = branch_get_upstream(branch, err);\n\t\t\tif (!up)\n\t\t\t\treturn NULL;\n\t\t\tcur = tracking_for_push_dest(remote, branch->refname, err);\n\t\t\tif (!cur)\n\t\t\t\treturn NULL;\n\t\t\tif (strcmp(cur, up))\n\t\t\t\treturn error_buf(err,\n\t\t\t\t\t\t _(\"cannot resolve 'simple' push to a single destination\"));\n\t\t\treturn cur;\n\t\t}\n\t}\n\n\tdie(\"BUG: unhandled push situation\");\n}\n\nconst char *branch_get_push(struct branch *branch, struct strbuf *err)\n{\n\tif (!branch)\n\t\treturn error_buf(err, _(\"HEAD does not point to a branch\"));\n\n\tif (!branch->push_tracking_ref)\n\t\tbranch->push_tracking_ref = branch_get_push_1(branch, err);\n\treturn branch->push_tracking_ref;\n}\n\nstatic int ignore_symref_update(const char *refname)\n{\n\tint flag;\n\n\tif (!resolve_ref_unsafe(refname, 0, NULL, &flag))\n\t\treturn 0; /* non-existing refs are OK */\n\treturn (flag & REF_ISSYMREF);\n}\n\n/*\n * Create and return a list of (struct ref) consisting of copies of\n * each remote_ref that matches refspec.  refspec must be a pattern.\n * Fill in the copies' peer_ref to describe the local tracking refs to\n * which they map.  Omit any references that would map to an existing\n * local symbolic ref.\n */\nstatic struct ref *get_expanded_map(const struct ref *remote_refs,\n\t\t\t\t    const struct refspec_item *refspec)\n{\n\tconst struct ref *ref;\n\tstruct ref *ret = NULL;\n\tstruct ref **tail = &ret;\n\n\tfor (ref = remote_refs; ref; ref = ref->next) {\n\t\tchar *expn_name = NULL;\n\n\t\tif (strchr(ref->name, '^'))\n\t\t\tcontinue; /* a dereference item */\n\t\tif (match_name_with_pattern(refspec->src, ref->name,\n\t\t\t\t\t    refspec->dst, &expn_name) &&\n\t\t    !ignore_symref_update(expn_name)) {\n\t\t\tstruct ref *cpy = copy_ref(ref);\n\n\t\t\tcpy->peer_ref = alloc_ref(expn_name);\n\t\t\tif (refspec->force)\n\t\t\t\tcpy->peer_ref->force = 1;\n\t\t\t*tail = cpy;\n\t\t\ttail = &cpy->next;\n\t\t}\n\t\tfree(expn_name);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct ref *find_ref_by_name_abbrev(const struct ref *refs, const char *name)\n{\n\tconst struct ref *ref;\n\tfor (ref = refs; ref; ref = ref->next) {\n\t\tif (refname_match(name, ref->name))\n\t\t\treturn ref;\n\t}\n\treturn NULL;\n}\n\nstruct ref *get_remote_ref(const struct ref *remote_refs, const char *name)\n{\n\tconst struct ref *ref = find_ref_by_name_abbrev(remote_refs, name);\n\n\tif (!ref)\n\t\treturn NULL;\n\n\treturn copy_ref(ref);\n}\n\nstatic struct ref *get_local_ref(const char *name)\n{\n\tif (!name || name[0] == '\\0')\n\t\treturn NULL;\n\n\tif (starts_with(name, \"refs/\"))\n\t\treturn alloc_ref(name);\n\n\tif (starts_with(name, \"heads/\") ||\n\t    starts_with(name, \"tags/\") ||\n\t    starts_with(name, \"remotes/\"))\n\t\treturn alloc_ref_with_prefix(\"refs/\", 5, name);\n\n\treturn alloc_ref_with_prefix(\"refs/heads/\", 11, name);\n}\n\nint get_fetch_map(const struct ref *remote_refs,\n\t\t  const struct refspec_item *refspec,\n\t\t  struct ref ***tail,\n\t\t  int missing_ok)\n{\n\tstruct ref *ref_map, **rmp;\n\n\tif (refspec->pattern) {\n\t\tref_map = get_expanded_map(remote_refs, refspec);\n\t} else {\n\t\tconst char *name = refspec->src[0] ? refspec->src : \"HEAD\";\n\n\t\tif (refspec->exact_sha1) {\n\t\t\tref_map = alloc_ref(name);\n\t\t\tget_oid_hex(name, &ref_map->old_oid);\n\t\t} else {\n\t\t\tref_map = get_remote_ref(remote_refs, name);\n\t\t}\n\t\tif (!missing_ok && !ref_map)\n\t\t\tdie(\"Couldn't find remote ref %s\", name);\n\t\tif (ref_map) {\n\t\t\tref_map->peer_ref = get_local_ref(refspec->dst);\n\t\t\tif (ref_map->peer_ref && refspec->force)\n\t\t\t\tref_map->peer_ref->force = 1;\n\t\t}\n\t}\n\n\tfor (rmp = &ref_map; *rmp; ) {\n\t\tif ((*rmp)->peer_ref) {\n\t\t\tif (!starts_with((*rmp)->peer_ref->name, \"refs/\") ||\n\t\t\t    check_refname_format((*rmp)->peer_ref->name, 0)) {\n\t\t\t\tstruct ref *ignore = *rmp;\n\t\t\t\terror(\"* Ignoring funny ref '%s' locally\",\n\t\t\t\t      (*rmp)->peer_ref->name);\n\t\t\t\t*rmp = (*rmp)->next;\n\t\t\t\tfree(ignore->peer_ref);\n\t\t\t\tfree(ignore);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\trmp = &((*rmp)->next);\n\t}\n\n\tif (ref_map)\n\t\ttail_link_ref(ref_map, tail);\n\n\treturn 0;\n}\n\nint resolve_remote_symref(struct ref *ref, struct ref *list)\n{\n\tif (!ref->symref)\n\t\treturn 0;\n\tfor (; list; list = list->next)\n\t\tif (!strcmp(ref->symref, list->name)) {\n\t\t\toidcpy(&ref->old_oid, &list->old_oid);\n\t\t\treturn 0;\n\t\t}\n\treturn 1;\n}\n\nstatic void unmark_and_free(struct commit_list *list, unsigned int mark)\n{\n\twhile (list) {\n\t\tstruct commit *commit = pop_commit(&list);\n\t\tcommit->object.flags &= ~mark;\n\t}\n}\n\nint ref_newer(const struct object_id *new_oid, const struct object_id *old_oid)\n{\n\tstruct object *o;\n\tstruct commit *old_commit, *new_commit;\n\tstruct commit_list *list, *used;\n\tint found = 0;\n\n\t/*\n\t * Both new_commit and old_commit must be commit-ish and new_commit is descendant of\n\t * old_commit.  Otherwise we require --force.\n\t */\n\to = deref_tag(parse_object(old_oid), NULL, 0);\n\tif (!o || o->type != OBJ_COMMIT)\n\t\treturn 0;\n\told_commit = (struct commit *) o;\n\n\to = deref_tag(parse_object(new_oid), NULL, 0);\n\tif (!o || o->type != OBJ_COMMIT)\n\t\treturn 0;\n\tnew_commit = (struct commit *) o;\n\n\tif (parse_commit(new_commit) < 0)\n\t\treturn 0;\n\n\tused = list = NULL;\n\tcommit_list_insert(new_commit, &list);\n\twhile (list) {\n\t\tnew_commit = pop_most_recent_commit(&list, TMP_MARK);\n\t\tcommit_list_insert(new_commit, &used);\n\t\tif (new_commit == old_commit) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tunmark_and_free(list, TMP_MARK);\n\tunmark_and_free(used, TMP_MARK);\n\treturn found;\n}\n\n/*\n * Lookup the upstream branch for the given branch and if present, optionally\n * compute the commit ahead/behind values for the pair.\n *\n * If abf is AHEAD_BEHIND_FULL, compute the full ahead/behind and return the\n * counts in *num_ours and *num_theirs.  If abf is AHEAD_BEHIND_QUICK, skip\n * the (potentially expensive) a/b computation (*num_ours and *num_theirs are\n * set to zero).\n *\n * The name of the upstream branch (or NULL if no upstream is defined) is\n * returned via *upstream_name, if it is not itself NULL.\n *\n * Returns -1 if num_ours and num_theirs could not be filled in (e.g., no\n * upstream defined, or ref does not exist).  Returns 0 if the commits are\n * identical.  Returns 1 if commits are different.\n */\nint stat_tracking_info(struct branch *branch, int *num_ours, int *num_theirs,\n\t\t       const char **upstream_name, enum ahead_behind_flags abf)\n{\n\tstruct object_id oid;\n\tstruct commit *ours, *theirs;\n\tstruct rev_info revs;\n\tconst char *base;\n\tstruct argv_array argv = ARGV_ARRAY_INIT;\n\n\t/* Cannot stat unless we are marked to build on top of somebody else. */\n\tbase = branch_get_upstream(branch, NULL);\n\tif (upstream_name)\n\t\t*upstream_name = base;\n\tif (!base)\n\t\treturn -1;\n\n\t/* Cannot stat if what we used to build on no longer exists */\n\tif (read_ref(base, &oid))\n\t\treturn -1;\n\ttheirs = lookup_commit_reference(&oid);\n\tif (!theirs)\n\t\treturn -1;\n\n\tif (read_ref(branch->refname, &oid))\n\t\treturn -1;\n\tours = lookup_commit_reference(&oid);\n\tif (!ours)\n\t\treturn -1;\n\n\t*num_theirs = *num_ours = 0;\n\n\t/* are we the same? */\n\tif (theirs == ours)\n\t\treturn 0;\n\tif (abf == AHEAD_BEHIND_QUICK)\n\t\treturn 1;\n\tif (abf != AHEAD_BEHIND_FULL)\n\t\tBUG(\"stat_tracking_info: invalid abf '%d'\", abf);\n\n\t/* Run \"rev-list --left-right ours...theirs\" internally... */\n\targv_array_push(&argv, \"\"); /* ignored */\n\targv_array_push(&argv, \"--left-right\");\n\targv_array_pushf(&argv, \"%s...%s\",\n\t\t\t oid_to_hex(&ours->object.oid),\n\t\t\t oid_to_hex(&theirs->object.oid));\n\targv_array_push(&argv, \"--\");\n\n\tinit_revisions(&revs, NULL);\n\tsetup_revisions(argv.argc, argv.argv, &revs, NULL);\n\tif (prepare_revision_walk(&revs))\n\t\tdie(\"revision walk setup failed\");\n\n\t/* ... and count the commits on each side. */\n\twhile (1) {\n\t\tstruct commit *c = get_revision(&revs);\n\t\tif (!c)\n\t\t\tbreak;\n\t\tif (c->object.flags & SYMMETRIC_LEFT)\n\t\t\t(*num_ours)++;\n\t\telse\n\t\t\t(*num_theirs)++;\n\t}\n\n\t/* clear object flags smudged by the above traversal */\n\tclear_commit_marks(ours, ALL_REV_FLAGS);\n\tclear_commit_marks(theirs, ALL_REV_FLAGS);\n\n\targv_array_clear(&argv);\n\treturn 1;\n}\n\n/*\n * Return true when there is anything to report, otherwise false.\n */\nint format_tracking_info(struct branch *branch, struct strbuf *sb,\n\t\t\t enum ahead_behind_flags abf)\n{\n\tint ours, theirs, sti;\n\tconst char *full_base;\n\tchar *base;\n\tint upstream_is_gone = 0;\n\n\tsti = stat_tracking_info(branch, &ours, &theirs, &full_base, abf);\n\tif (sti < 0) {\n\t\tif (!full_base)\n\t\t\treturn 0;\n\t\tupstream_is_gone = 1;\n\t}\n\n\tbase = shorten_unambiguous_ref(full_base, 0);\n\tif (upstream_is_gone) {\n\t\tstrbuf_addf(sb,\n\t\t\t_(\"Your branch is based on '%s', but the upstream is gone.\\n\"),\n\t\t\tbase);\n\t\tif (advice_status_hints)\n\t\t\tstrbuf_addstr(sb,\n\t\t\t\t_(\"  (use \\\"git branch --unset-upstream\\\" to fixup)\\n\"));\n\t} else if (!sti) {\n\t\tstrbuf_addf(sb,\n\t\t\t_(\"Your branch is up to date with '%s'.\\n\"),\n\t\t\tbase);\n\t} else if (abf == AHEAD_BEHIND_QUICK) {\n\t\tstrbuf_addf(sb,\n\t\t\t    _(\"Your branch and '%s' refer to different commits.\\n\"),\n\t\t\t    base);\n\t\tif (advice_status_hints)\n\t\t\tstrbuf_addf(sb, _(\"  (use \\\"%s\\\" for details)\\n\"),\n\t\t\t\t    \"git status --ahead-behind\");\n\t} else if (!theirs) {\n\t\tstrbuf_addf(sb,\n\t\t\tQ_(\"Your branch is ahead of '%s' by %d commit.\\n\",\n\t\t\t   \"Your branch is ahead of '%s' by %d commits.\\n\",\n\t\t\t   ours),\n\t\t\tbase, ours);\n\t\tif (advice_status_hints)\n\t\t\tstrbuf_addstr(sb,\n\t\t\t\t_(\"  (use \\\"git push\\\" to publish your local commits)\\n\"));\n\t} else if (!ours) {\n\t\tstrbuf_addf(sb,\n\t\t\tQ_(\"Your branch is behind '%s' by %d commit, \"\n\t\t\t       \"and can be fast-forwarded.\\n\",\n\t\t\t   \"Your branch is behind '%s' by %d commits, \"\n\t\t\t       \"and can be fast-forwarded.\\n\",\n\t\t\t   theirs),\n\t\t\tbase, theirs);\n\t\tif (advice_status_hints)\n\t\t\tstrbuf_addstr(sb,\n\t\t\t\t_(\"  (use \\\"git pull\\\" to update your local branch)\\n\"));\n\t} else {\n\t\tstrbuf_addf(sb,\n\t\t\tQ_(\"Your branch and '%s' have diverged,\\n\"\n\t\t\t       \"and have %d and %d different commit each, \"\n\t\t\t       \"respectively.\\n\",\n\t\t\t   \"Your branch and '%s' have diverged,\\n\"\n\t\t\t       \"and have %d and %d different commits each, \"\n\t\t\t       \"respectively.\\n\",\n\t\t\t   ours + theirs),\n\t\t\tbase, ours, theirs);\n\t\tif (advice_status_hints)\n\t\t\tstrbuf_addstr(sb,\n\t\t\t\t_(\"  (use \\\"git pull\\\" to merge the remote branch into yours)\\n\"));\n\t}\n\tfree(base);\n\treturn 1;\n}\n\nstatic int one_local_ref(const char *refname, const struct object_id *oid,\n\t\t\t int flag, void *cb_data)\n{\n\tstruct ref ***local_tail = cb_data;\n\tstruct ref *ref;\n\n\t/* we already know it starts with refs/ to get here */\n\tif (check_refname_format(refname + 5, 0))\n\t\treturn 0;\n\n\tref = alloc_ref(refname);\n\toidcpy(&ref->new_oid, oid);\n\t**local_tail = ref;\n\t*local_tail = &ref->next;\n\treturn 0;\n}\n\nstruct ref *get_local_heads(void)\n{\n\tstruct ref *local_refs = NULL, **local_tail = &local_refs;\n\n\tfor_each_ref(one_local_ref, &local_tail);\n\treturn local_refs;\n}\n\nstruct ref *guess_remote_head(const struct ref *head,\n\t\t\t      const struct ref *refs,\n\t\t\t      int all)\n{\n\tconst struct ref *r;\n\tstruct ref *list = NULL;\n\tstruct ref **tail = &list;\n\n\tif (!head)\n\t\treturn NULL;\n\n\t/*\n\t * Some transports support directly peeking at\n\t * where HEAD points; if that is the case, then\n\t * we don't have to guess.\n\t */\n\tif (head->symref)\n\t\treturn copy_ref(find_ref_by_name(refs, head->symref));\n\n\t/* If refs/heads/master could be right, it is. */\n\tif (!all) {\n\t\tr = find_ref_by_name(refs, \"refs/heads/master\");\n\t\tif (r && !oidcmp(&r->old_oid, &head->old_oid))\n\t\t\treturn copy_ref(r);\n\t}\n\n\t/* Look for another ref that points there */\n\tfor (r = refs; r; r = r->next) {\n\t\tif (r != head &&\n\t\t    starts_with(r->name, \"refs/heads/\") &&\n\t\t    !oidcmp(&r->old_oid, &head->old_oid)) {\n\t\t\t*tail = copy_ref(r);\n\t\t\ttail = &((*tail)->next);\n\t\t\tif (!all)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn list;\n}\n\nstruct stale_heads_info {\n\tstruct string_list *ref_names;\n\tstruct ref **stale_refs_tail;\n\tstruct refspec *rs;\n};\n\nstatic int get_stale_heads_cb(const char *refname, const struct object_id *oid,\n\t\t\t      int flags, void *cb_data)\n{\n\tstruct stale_heads_info *info = cb_data;\n\tstruct string_list matches = STRING_LIST_INIT_DUP;\n\tstruct refspec_item query;\n\tint i, stale = 1;\n\tmemset(&query, 0, sizeof(struct refspec_item));\n\tquery.dst = (char *)refname;\n\n\tquery_refspecs_multiple(info->rs, &query, &matches);\n\tif (matches.nr == 0)\n\t\tgoto clean_exit; /* No matches */\n\n\t/*\n\t * If we did find a suitable refspec and it's not a symref and\n\t * it's not in the list of refs that currently exist in that\n\t * remote, we consider it to be stale. In order to deal with\n\t * overlapping refspecs, we need to go over all of the\n\t * matching refs.\n\t */\n\tif (flags & REF_ISSYMREF)\n\t\tgoto clean_exit;\n\n\tfor (i = 0; stale && i < matches.nr; i++)\n\t\tif (string_list_has_string(info->ref_names, matches.items[i].string))\n\t\t\tstale = 0;\n\n\tif (stale) {\n\t\tstruct ref *ref = make_linked_ref(refname, &info->stale_refs_tail);\n\t\toidcpy(&ref->new_oid, oid);\n\t}\n\nclean_exit:\n\tstring_list_clear(&matches, 0);\n\treturn 0;\n}\n\nstruct ref *get_stale_heads(struct refspec *rs, struct ref *fetch_map)\n{\n\tstruct ref *ref, *stale_refs = NULL;\n\tstruct string_list ref_names = STRING_LIST_INIT_NODUP;\n\tstruct stale_heads_info info;\n\n\tinfo.ref_names = &ref_names;\n\tinfo.stale_refs_tail = &stale_refs;\n\tinfo.rs = rs;\n\tfor (ref = fetch_map; ref; ref = ref->next)\n\t\tstring_list_append(&ref_names, ref->name);\n\tstring_list_sort(&ref_names);\n\tfor_each_ref(get_stale_heads_cb, &info);\n\tstring_list_clear(&ref_names, 0);\n\treturn stale_refs;\n}\n\n/*\n * Compare-and-swap\n */\nstatic void clear_cas_option(struct push_cas_option *cas)\n{\n\tint i;\n\n\tfor (i = 0; i < cas->nr; i++)\n\t\tfree(cas->entry[i].refname);\n\tfree(cas->entry);\n\tmemset(cas, 0, sizeof(*cas));\n}\n\nstatic struct push_cas *add_cas_entry(struct push_cas_option *cas,\n\t\t\t\t      const char *refname,\n\t\t\t\t      size_t refnamelen)\n{\n\tstruct push_cas *entry;\n\tALLOC_GROW(cas->entry, cas->nr + 1, cas->alloc);\n\tentry = &cas->entry[cas->nr++];\n\tmemset(entry, 0, sizeof(*entry));\n\tentry->refname = xmemdupz(refname, refnamelen);\n\treturn entry;\n}\n\nstatic int parse_push_cas_option(struct push_cas_option *cas, const char *arg, int unset)\n{\n\tconst char *colon;\n\tstruct push_cas *entry;\n\n\tif (unset) {\n\t\t/* \"--no-<option>\" */\n\t\tclear_cas_option(cas);\n\t\treturn 0;\n\t}\n\n\tif (!arg) {\n\t\t/* just \"--<option>\" */\n\t\tcas->use_tracking_for_rest = 1;\n\t\treturn 0;\n\t}\n\n\t/* \"--<option>=refname\" or \"--<option>=refname:value\" */\n\tcolon = strchrnul(arg, ':');\n\tentry = add_cas_entry(cas, arg, colon - arg);\n\tif (!*colon)\n\t\tentry->use_tracking = 1;\n\telse if (!colon[1])\n\t\toidclr(&entry->expect);\n\telse if (get_oid(colon + 1, &entry->expect))\n\t\treturn error(\"cannot parse expected object name '%s'\", colon + 1);\n\treturn 0;\n}\n\nint parseopt_push_cas_option(const struct option *opt, const char *arg, int unset)\n{\n\treturn parse_push_cas_option(opt->value, arg, unset);\n}\n\nint is_empty_cas(const struct push_cas_option *cas)\n{\n\treturn !cas->use_tracking_for_rest && !cas->nr;\n}\n\n/*\n * Look at remote.fetch refspec and see if we have a remote\n * tracking branch for the refname there.  Fill its current\n * value in sha1[].\n * If we cannot do so, return negative to signal an error.\n */\nstatic int remote_tracking(struct remote *remote, const char *refname,\n\t\t\t   struct object_id *oid)\n{\n\tchar *dst;\n\n\tdst = apply_refspecs(&remote->fetch, refname);\n\tif (!dst)\n\t\treturn -1; /* no tracking ref for refname at remote */\n\tif (read_ref(dst, oid))\n\t\treturn -1; /* we know what the tracking ref is but we cannot read it */\n\treturn 0;\n}\n\nstatic void apply_cas(struct push_cas_option *cas,\n\t\t      struct remote *remote,\n\t\t      struct ref *ref)\n{\n\tint i;\n\n\t/* Find an explicit --<option>=<name>[:<value>] entry */\n\tfor (i = 0; i < cas->nr; i++) {\n\t\tstruct push_cas *entry = &cas->entry[i];\n\t\tif (!refname_match(entry->refname, ref->name))\n\t\t\tcontinue;\n\t\tref->expect_old_sha1 = 1;\n\t\tif (!entry->use_tracking)\n\t\t\toidcpy(&ref->old_oid_expect, &entry->expect);\n\t\telse if (remote_tracking(remote, ref->name, &ref->old_oid_expect))\n\t\t\toidclr(&ref->old_oid_expect);\n\t\treturn;\n\t}\n\n\t/* Are we using \"--<option>\" to cover all? */\n\tif (!cas->use_tracking_for_rest)\n\t\treturn;\n\n\tref->expect_old_sha1 = 1;\n\tif (remote_tracking(remote, ref->name, &ref->old_oid_expect))\n\t\toidclr(&ref->old_oid_expect);\n}\n\nvoid apply_push_cas(struct push_cas_option *cas,\n\t\t    struct remote *remote,\n\t\t    struct ref *remote_refs)\n{\n\tstruct ref *ref;\n\tfor (ref = remote_refs; ref; ref = ref->next)\n\t\tapply_cas(cas, remote, ref);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0046d4e28fad8401109dffb326bb7fdc1659ea2c",
  "sha1_ok": true,
  "size": 56887
}
