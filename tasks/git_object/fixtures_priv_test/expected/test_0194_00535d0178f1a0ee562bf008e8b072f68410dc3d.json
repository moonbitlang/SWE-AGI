{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGNsb25lIgogKgogKiBDb3B5cmlnaHQgKGMpIDIwMDcgS3Jpc3RpYW4gSMO4Z3NiZXJnIDxrcmhAcmVkaGF0LmNvbT4sCiAqCQkgMjAwOCBEYW5pZWwgQmFya2Fsb3cgPGJhcmthbG93QGlhYmVydm9uLm9yZz4KICogQmFzZWQgb24gZ2l0LWNvbW1pdC5zaCBieSBKdW5pbyBDIEhhbWFubyBhbmQgTGludXMgVG9ydmFsZHMKICoKICogQ2xvbmUgYSByZXBvc2l0b3J5IGludG8gYSBkaWZmZXJlbnQgZGlyZWN0b3J5IHRoYXQgZG9lcyBub3QgeWV0IGV4aXN0LgogKi8KCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJsb2NrZmlsZS5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAiZmV0Y2gtcGFjay5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAidHJlZS5oIgojaW5jbHVkZSAidHJlZS13YWxrLmgiCiNpbmNsdWRlICJ1bnBhY2stdHJlZXMuaCIKI2luY2x1ZGUgInRyYW5zcG9ydC5oIgojaW5jbHVkZSAic3RyYnVmLmgiCiNpbmNsdWRlICJkaXIuaCIKI2luY2x1ZGUgInNpZ2NoYWluLmgiCiNpbmNsdWRlICJicmFuY2guaCIKI2luY2x1ZGUgInJlbW90ZS5oIgojaW5jbHVkZSAicnVuLWNvbW1hbmQuaCIKI2luY2x1ZGUgImNvbm5lY3RlZC5oIgoKLyoKICogT3ZlcmFsbCBGSVhNRXM6CiAqICAtIHJlc3BlY3QgREJfRU5WSVJPTk1FTlQgZm9yIC5naXQvb2JqZWN0cy4KICoKICogSW1wbGVtZW50YXRpb24gbm90ZXM6CiAqICAtIGRyb3BwaW5nIHVzZS1zZXBhcmF0ZS1yZW1vdGUgYW5kIG5vLXNlcGFyYXRlLXJlbW90ZSBjb21wYXRpYmlsaXR5CiAqCiAqLwpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGJ1aWx0aW5fY2xvbmVfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgY2xvbmUgWzxvcHRpb25zPl0gWy0tXSA8cmVwbz4gWzxkaXI+XSIpLAoJTlVMTAp9OwoKc3RhdGljIGludCBvcHRpb25fbm9fY2hlY2tvdXQsIG9wdGlvbl9iYXJlLCBvcHRpb25fbWlycm9yLCBvcHRpb25fc2luZ2xlX2JyYW5jaCA9IC0xOwpzdGF0aWMgaW50IG9wdGlvbl9sb2NhbCA9IC0xLCBvcHRpb25fbm9faGFyZGxpbmtzLCBvcHRpb25fc2hhcmVkLCBvcHRpb25fcmVjdXJzaXZlOwpzdGF0aWMgY2hhciAqb3B0aW9uX3RlbXBsYXRlLCAqb3B0aW9uX2RlcHRoOwpzdGF0aWMgY2hhciAqb3B0aW9uX29yaWdpbiA9IE5VTEw7CnN0YXRpYyBjaGFyICpvcHRpb25fYnJhbmNoID0gTlVMTDsKc3RhdGljIGNvbnN0IGNoYXIgKnJlYWxfZ2l0X2RpcjsKc3RhdGljIGNoYXIgKm9wdGlvbl91cGxvYWRfcGFjayA9ICJnaXQtdXBsb2FkLXBhY2siOwpzdGF0aWMgaW50IG9wdGlvbl92ZXJib3NpdHk7CnN0YXRpYyBpbnQgb3B0aW9uX3Byb2dyZXNzID0gLTE7CnN0YXRpYyBzdHJ1Y3Qgc3RyaW5nX2xpc3Qgb3B0aW9uX2NvbmZpZzsKc3RhdGljIHN0cnVjdCBzdHJpbmdfbGlzdCBvcHRpb25fcmVmZXJlbmNlOwpzdGF0aWMgaW50IG9wdGlvbl9kaXNzb2NpYXRlOwoKc3RhdGljIHN0cnVjdCBvcHRpb24gYnVpbHRpbl9jbG9uZV9vcHRpb25zW10gPSB7CglPUFRfX1ZFUkJPU0lUWSgmb3B0aW9uX3ZlcmJvc2l0eSksCglPUFRfQk9PTCgwLCAicHJvZ3Jlc3MiLCAmb3B0aW9uX3Byb2dyZXNzLAoJCSBOXygiZm9yY2UgcHJvZ3Jlc3MgcmVwb3J0aW5nIikpLAoJT1BUX0JPT0woJ24nLCAibm8tY2hlY2tvdXQiLCAmb3B0aW9uX25vX2NoZWNrb3V0LAoJCSBOXygiZG9uJ3QgY3JlYXRlIGEgY2hlY2tvdXQiKSksCglPUFRfQk9PTCgwLCAiYmFyZSIsICZvcHRpb25fYmFyZSwgTl8oImNyZWF0ZSBhIGJhcmUgcmVwb3NpdG9yeSIpKSwKCU9QVF9ISURERU5fQk9PTCgwLCAibmFrZWQiLCAmb3B0aW9uX2JhcmUsCgkJCU5fKCJjcmVhdGUgYSBiYXJlIHJlcG9zaXRvcnkiKSksCglPUFRfQk9PTCgwLCAibWlycm9yIiwgJm9wdGlvbl9taXJyb3IsCgkJIE5fKCJjcmVhdGUgYSBtaXJyb3IgcmVwb3NpdG9yeSAoaW1wbGllcyBiYXJlKSIpKSwKCU9QVF9CT09MKCdsJywgImxvY2FsIiwgJm9wdGlvbl9sb2NhbCwKCQlOXygidG8gY2xvbmUgZnJvbSBhIGxvY2FsIHJlcG9zaXRvcnkiKSksCglPUFRfQk9PTCgwLCAibm8taGFyZGxpbmtzIiwgJm9wdGlvbl9ub19oYXJkbGlua3MsCgkJICAgIE5fKCJkb24ndCB1c2UgbG9jYWwgaGFyZGxpbmtzLCBhbHdheXMgY29weSIpKSwKCU9QVF9CT09MKCdzJywgInNoYXJlZCIsICZvcHRpb25fc2hhcmVkLAoJCSAgICBOXygic2V0dXAgYXMgc2hhcmVkIHJlcG9zaXRvcnkiKSksCglPUFRfQk9PTCgwLCAicmVjdXJzaXZlIiwgJm9wdGlvbl9yZWN1cnNpdmUsCgkJICAgIE5fKCJpbml0aWFsaXplIHN1Ym1vZHVsZXMgaW4gdGhlIGNsb25lIikpLAoJT1BUX0JPT0woMCwgInJlY3Vyc2Utc3VibW9kdWxlcyIsICZvcHRpb25fcmVjdXJzaXZlLAoJCSAgICBOXygiaW5pdGlhbGl6ZSBzdWJtb2R1bGVzIGluIHRoZSBjbG9uZSIpKSwKCU9QVF9TVFJJTkcoMCwgInRlbXBsYXRlIiwgJm9wdGlvbl90ZW1wbGF0ZSwgTl8oInRlbXBsYXRlLWRpcmVjdG9yeSIpLAoJCSAgIE5fKCJkaXJlY3RvcnkgZnJvbSB3aGljaCB0ZW1wbGF0ZXMgd2lsbCBiZSB1c2VkIikpLAoJT1BUX1NUUklOR19MSVNUKDAsICJyZWZlcmVuY2UiLCAmb3B0aW9uX3JlZmVyZW5jZSwgTl8oInJlcG8iKSwKCQkJTl8oInJlZmVyZW5jZSByZXBvc2l0b3J5IikpLAoJT1BUX0JPT0woMCwgImRpc3NvY2lhdGUiLCAmb3B0aW9uX2Rpc3NvY2lhdGUsCgkJIE5fKCJ1c2UgLS1yZWZlcmVuY2Ugb25seSB3aGlsZSBjbG9uaW5nIikpLAoJT1BUX1NUUklORygnbycsICJvcmlnaW4iLCAmb3B0aW9uX29yaWdpbiwgTl8oIm5hbWUiKSwKCQkgICBOXygidXNlIDxuYW1lPiBpbnN0ZWFkIG9mICdvcmlnaW4nIHRvIHRyYWNrIHVwc3RyZWFtIikpLAoJT1BUX1NUUklORygnYicsICJicmFuY2giLCAmb3B0aW9uX2JyYW5jaCwgTl8oImJyYW5jaCIpLAoJCSAgIE5fKCJjaGVja291dCA8YnJhbmNoPiBpbnN0ZWFkIG9mIHRoZSByZW1vdGUncyBIRUFEIikpLAoJT1BUX1NUUklORygndScsICJ1cGxvYWQtcGFjayIsICZvcHRpb25fdXBsb2FkX3BhY2ssIE5fKCJwYXRoIiksCgkJICAgTl8oInBhdGggdG8gZ2l0LXVwbG9hZC1wYWNrIG9uIHRoZSByZW1vdGUiKSksCglPUFRfU1RSSU5HKDAsICJkZXB0aCIsICZvcHRpb25fZGVwdGgsIE5fKCJkZXB0aCIpLAoJCSAgICBOXygiY3JlYXRlIGEgc2hhbGxvdyBjbG9uZSBvZiB0aGF0IGRlcHRoIikpLAoJT1BUX0JPT0woMCwgInNpbmdsZS1icmFuY2giLCAmb3B0aW9uX3NpbmdsZV9icmFuY2gsCgkJICAgIE5fKCJjbG9uZSBvbmx5IG9uZSBicmFuY2gsIEhFQUQgb3IgLS1icmFuY2giKSksCglPUFRfU1RSSU5HKDAsICJzZXBhcmF0ZS1naXQtZGlyIiwgJnJlYWxfZ2l0X2RpciwgTl8oImdpdGRpciIpLAoJCSAgIE5fKCJzZXBhcmF0ZSBnaXQgZGlyIGZyb20gd29ya2luZyB0cmVlIikpLAoJT1BUX1NUUklOR19MSVNUKCdjJywgImNvbmZpZyIsICZvcHRpb25fY29uZmlnLCBOXygia2V5PXZhbHVlIiksCgkJCU5fKCJzZXQgY29uZmlnIGluc2lkZSB0aGUgbmV3IHJlcG9zaXRvcnkiKSksCglPUFRfRU5EKCkKfTsKCnN0YXRpYyBjb25zdCBjaGFyICphcmd2X3N1Ym1vZHVsZVtdID0gewoJInN1Ym1vZHVsZSIsICJ1cGRhdGUiLCAiLS1pbml0IiwgIi0tcmVjdXJzaXZlIiwgTlVMTAp9OwoKc3RhdGljIGNoYXIgKmdldF9yZXBvX3BhdGgoY29uc3QgY2hhciAqcmVwbywgaW50ICppc19idW5kbGUpCnsKCXN0YXRpYyBjaGFyICpzdWZmaXhbXSA9IHsgIi8uZ2l0IiwgIiIsICIuZ2l0Ly5naXQiLCAiLmdpdCIgfTsKCXN0YXRpYyBjaGFyICpidW5kbGVfc3VmZml4W10gPSB7ICIuYnVuZGxlIiwgIiIgfTsKCXN0cnVjdCBzdGF0IHN0OwoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IEFSUkFZX1NJWkUoc3VmZml4KTsgaSsrKSB7CgkJY29uc3QgY2hhciAqcGF0aDsKCQlwYXRoID0gbWtwYXRoKCIlcyVzIiwgcmVwbywgc3VmZml4W2ldKTsKCQlpZiAoc3RhdChwYXRoLCAmc3QpKQoJCQljb250aW51ZTsKCQlpZiAoU19JU0RJUihzdC5zdF9tb2RlKSAmJiBpc19naXRfZGlyZWN0b3J5KHBhdGgpKSB7CgkJCSppc19idW5kbGUgPSAwOwoJCQlyZXR1cm4geHN0cmR1cChhYnNvbHV0ZV9wYXRoKHBhdGgpKTsKCQl9IGVsc2UgaWYgKFNfSVNSRUcoc3Quc3RfbW9kZSkgJiYgc3Quc3Rfc2l6ZSA+IDgpIHsKCQkJLyogSXMgaXQgYSAiZ2l0ZmlsZSI/ICovCgkJCWNoYXIgc2lnbmF0dXJlWzhdOwoJCQlpbnQgbGVuLCBmZCA9IG9wZW4ocGF0aCwgT19SRE9OTFkpOwoJCQlpZiAoZmQgPCAwKQoJCQkJY29udGludWU7CgkJCWxlbiA9IHJlYWRfaW5fZnVsbChmZCwgc2lnbmF0dXJlLCA4KTsKCQkJY2xvc2UoZmQpOwoJCQlpZiAobGVuICE9IDggfHwgc3RybmNtcChzaWduYXR1cmUsICJnaXRkaXI6ICIsIDgpKQoJCQkJY29udGludWU7CgkJCXBhdGggPSByZWFkX2dpdGZpbGUocGF0aCk7CgkJCWlmIChwYXRoKSB7CgkJCQkqaXNfYnVuZGxlID0gMDsKCQkJCXJldHVybiB4c3RyZHVwKGFic29sdXRlX3BhdGgocGF0aCkpOwoJCQl9CgkJfQoJfQoKCWZvciAoaSA9IDA7IGkgPCBBUlJBWV9TSVpFKGJ1bmRsZV9zdWZmaXgpOyBpKyspIHsKCQljb25zdCBjaGFyICpwYXRoOwoJCXBhdGggPSBta3BhdGgoIiVzJXMiLCByZXBvLCBidW5kbGVfc3VmZml4W2ldKTsKCQlpZiAoIXN0YXQocGF0aCwgJnN0KSAmJiBTX0lTUkVHKHN0LnN0X21vZGUpKSB7CgkJCSppc19idW5kbGUgPSAxOwoJCQlyZXR1cm4geHN0cmR1cChhYnNvbHV0ZV9wYXRoKHBhdGgpKTsKCQl9Cgl9CgoJcmV0dXJuIE5VTEw7Cn0KCnN0YXRpYyBjaGFyICpndWVzc19kaXJfbmFtZShjb25zdCBjaGFyICpyZXBvLCBpbnQgaXNfYnVuZGxlLCBpbnQgaXNfYmFyZSkKewoJY29uc3QgY2hhciAqZW5kID0gcmVwbyArIHN0cmxlbihyZXBvKSwgKnN0YXJ0OwoJY2hhciAqZGlyOwoKCS8qCgkgKiBTdHJpcCB0cmFpbGluZyBzcGFjZXMsIHNsYXNoZXMgYW5kIC8uZ2l0CgkgKi8KCXdoaWxlIChyZXBvIDwgZW5kICYmIChpc19kaXJfc2VwKGVuZFstMV0pIHx8IGlzc3BhY2UoZW5kWy0xXSkpKQoJCWVuZC0tOwoJaWYgKGVuZCAtIHJlcG8gPiA1ICYmIGlzX2Rpcl9zZXAoZW5kWy01XSkgJiYKCSAgICAhc3RybmNtcChlbmQgLSA0LCAiLmdpdCIsIDQpKSB7CgkJZW5kIC09IDU7CgkJd2hpbGUgKHJlcG8gPCBlbmQgJiYgaXNfZGlyX3NlcChlbmRbLTFdKSkKCQkJZW5kLS07Cgl9CgoJLyoKCSAqIEZpbmQgbGFzdCBjb21wb25lbnQsIGJ1dCBiZSBwcmVwYXJlZCB0aGF0IHJlcG8gY291bGQgaGF2ZQoJICogdGhlIGZvcm0gICJyZW1vdGUuZXhhbXBsZS5jb206Zm9vLmdpdCIsIGkuZS4gbm8gc2xhc2gKCSAqIGluIHRoZSBkaXJlY3RvcnkgcGFydC4KCSAqLwoJc3RhcnQgPSBlbmQ7Cgl3aGlsZSAocmVwbyA8IHN0YXJ0ICYmICFpc19kaXJfc2VwKHN0YXJ0Wy0xXSkgJiYgc3RhcnRbLTFdICE9ICc6JykKCQlzdGFydC0tOwoKCS8qCgkgKiBTdHJpcCAue2J1bmRsZSxnaXR9LgoJICovCglpZiAoaXNfYnVuZGxlKSB7CgkJaWYgKGVuZCAtIHN0YXJ0ID4gNyAmJiAhc3RybmNtcChlbmQgLSA3LCAiLmJ1bmRsZSIsIDcpKQoJCQllbmQgLT0gNzsKCX0gZWxzZSB7CgkJaWYgKGVuZCAtIHN0YXJ0ID4gNCAmJiAhc3RybmNtcChlbmQgLSA0LCAiLmdpdCIsIDQpKQoJCQllbmQgLT0gNDsKCX0KCglpZiAoaXNfYmFyZSkgewoJCXN0cnVjdCBzdHJidWYgcmVzdWx0ID0gU1RSQlVGX0lOSVQ7CgkJc3RyYnVmX2FkZGYoJnJlc3VsdCwgIiUuKnMuZ2l0IiwgKGludCkoZW5kIC0gc3RhcnQpLCBzdGFydCk7CgkJZGlyID0gc3RyYnVmX2RldGFjaCgmcmVzdWx0LCBOVUxMKTsKCX0gZWxzZQoJCWRpciA9IHhzdHJuZHVwKHN0YXJ0LCBlbmQgLSBzdGFydCk7CgkvKgoJICogUmVwbGFjZSBzZXF1ZW5jZXMgb2YgJ2NvbnRyb2wnIGNoYXJhY3RlcnMgYW5kIHdoaXRlc3BhY2UKCSAqIHdpdGggb25lIGFzY2lpIHNwYWNlLCByZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzLgoJICovCglpZiAoKmRpcikgewoJCWNoYXIgKm91dCA9IGRpcjsKCQlpbnQgcHJldl9zcGFjZSA9IDEgLyogc3RyaXAgbGVhZGluZyB3aGl0ZXNwYWNlICovOwoJCWZvciAoZW5kID0gZGlyOyAqZW5kOyArK2VuZCkgewoJCQljaGFyIGNoID0gKmVuZDsKCQkJaWYgKCh1bnNpZ25lZCBjaGFyKWNoIDwgJ1x4MjAnKQoJCQkJY2ggPSAnXHgyMCc7CgkJCWlmIChpc3NwYWNlKGNoKSkgewoJCQkJaWYgKHByZXZfc3BhY2UpCgkJCQkJY29udGludWU7CgkJCQlwcmV2X3NwYWNlID0gMTsKCQkJfSBlbHNlCgkJCQlwcmV2X3NwYWNlID0gMDsKCQkJKm91dCsrID0gY2g7CgkJfQoJCSpvdXQgPSAnXDAnOwoJCWlmIChvdXQgPiBkaXIgJiYgcHJldl9zcGFjZSkKCQkJb3V0Wy0xXSA9ICdcMCc7Cgl9CglyZXR1cm4gZGlyOwp9CgpzdGF0aWMgdm9pZCBzdHJpcF90cmFpbGluZ19zbGFzaGVzKGNoYXIgKmRpcikKewoJY2hhciAqZW5kID0gZGlyICsgc3RybGVuKGRpcik7CgoJd2hpbGUgKGRpciA8IGVuZCAtIDEgJiYgaXNfZGlyX3NlcChlbmRbLTFdKSkKCQllbmQtLTsKCSplbmQgPSAnXDAnOwp9CgpzdGF0aWMgaW50IGFkZF9vbmVfcmVmZXJlbmNlKHN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtLCB2b2lkICpjYl9kYXRhKQp7CgljaGFyICpyZWZfZ2l0OwoJY29uc3QgY2hhciAqcmVwbzsKCXN0cnVjdCBzdHJidWYgYWx0ZXJuYXRlID0gU1RSQlVGX0lOSVQ7CgoJLyogQmV3YXJlOiByZWFkX2dpdGZpbGUoKSwgcmVhbF9wYXRoKCkgYW5kIG1rcGF0aCgpIHJldHVybiBzdGF0aWMgYnVmZmVyICovCglyZWZfZ2l0ID0geHN0cmR1cChyZWFsX3BhdGgoaXRlbS0+c3RyaW5nKSk7CgoJcmVwbyA9IHJlYWRfZ2l0ZmlsZShyZWZfZ2l0KTsKCWlmICghcmVwbykKCQlyZXBvID0gcmVhZF9naXRmaWxlKG1rcGF0aCgiJXMvLmdpdCIsIHJlZl9naXQpKTsKCWlmIChyZXBvKSB7CgkJZnJlZShyZWZfZ2l0KTsKCQlyZWZfZ2l0ID0geHN0cmR1cChyZXBvKTsKCX0KCglpZiAoIXJlcG8gJiYgaXNfZGlyZWN0b3J5KG1rcGF0aCgiJXMvLmdpdC9vYmplY3RzIiwgcmVmX2dpdCkpKSB7CgkJY2hhciAqcmVmX2dpdF9naXQgPSBta3BhdGhkdXAoIiVzLy5naXQiLCByZWZfZ2l0KTsKCQlmcmVlKHJlZl9naXQpOwoJCXJlZl9naXQgPSByZWZfZ2l0X2dpdDsKCX0gZWxzZSBpZiAoIWlzX2RpcmVjdG9yeShta3BhdGgoIiVzL29iamVjdHMiLCByZWZfZ2l0KSkpCgkJZGllKF8oInJlZmVyZW5jZSByZXBvc2l0b3J5ICclcycgaXMgbm90IGEgbG9jYWwgcmVwb3NpdG9yeS4iKSwKCQkgICAgaXRlbS0+c3RyaW5nKTsKCglpZiAoIWFjY2Vzcyhta3BhdGgoIiVzL3NoYWxsb3ciLCByZWZfZ2l0KSwgRl9PSykpCgkJZGllKF8oInJlZmVyZW5jZSByZXBvc2l0b3J5ICclcycgaXMgc2hhbGxvdyIpLCBpdGVtLT5zdHJpbmcpOwoKCWlmICghYWNjZXNzKG1rcGF0aCgiJXMvaW5mby9ncmFmdHMiLCByZWZfZ2l0KSwgRl9PSykpCgkJZGllKF8oInJlZmVyZW5jZSByZXBvc2l0b3J5ICclcycgaXMgZ3JhZnRlZCIpLCBpdGVtLT5zdHJpbmcpOwoKCXN0cmJ1Zl9hZGRmKCZhbHRlcm5hdGUsICIlcy9vYmplY3RzIiwgcmVmX2dpdCk7CglhZGRfdG9fYWx0ZXJuYXRlc19maWxlKGFsdGVybmF0ZS5idWYpOwoJc3RyYnVmX3JlbGVhc2UoJmFsdGVybmF0ZSk7CglmcmVlKHJlZl9naXQpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHNldHVwX3JlZmVyZW5jZSh2b2lkKQp7Cglmb3JfZWFjaF9zdHJpbmdfbGlzdCgmb3B0aW9uX3JlZmVyZW5jZSwgYWRkX29uZV9yZWZlcmVuY2UsIE5VTEwpOwp9CgpzdGF0aWMgdm9pZCBjb3B5X2FsdGVybmF0ZXMoc3RydWN0IHN0cmJ1ZiAqc3JjLCBzdHJ1Y3Qgc3RyYnVmICpkc3QsCgkJCSAgICBjb25zdCBjaGFyICpzcmNfcmVwbykKewoJLyoKCSAqIFJlYWQgZnJvbSB0aGUgc291cmNlIG9iamVjdHMvaW5mby9hbHRlcm5hdGVzIGZpbGUKCSAqIGFuZCBjb3B5IHRoZSBlbnRyaWVzIHRvIGNvcnJlc3BvbmRpbmcgZmlsZSBpbiB0aGUKCSAqIGRlc3RpbmF0aW9uIHJlcG9zaXRvcnkgd2l0aCBhZGRfdG9fYWx0ZXJuYXRlc19maWxlKCkuCgkgKiBCb3RoIHNyYyBhbmQgZHN0IGhhdmUgIiRwYXRoL29iamVjdHMvaW5mby9hbHRlcm5hdGVzIi4KCSAqCgkgKiBJbnN0ZWFkIG9mIGNvcHlpbmcgYml0LWZvci1iaXQgZnJvbSB0aGUgb3JpZ2luYWwsCgkgKiB3ZSBuZWVkIHRvIGFwcGVuZCB0byBleGlzdGluZyBvbmUgc28gdGhhdCB0aGUgYWxyZWFkeQoJICogY3JlYXRlZCBlbnRyeSB2aWEgImNsb25lIC1zIiBpcyBub3QgbG9zdCwgYW5kIGFsc28KCSAqIHRvIHR1cm4gZW50cmllcyB3aXRoIHBhdGhzIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5hbAoJICogYWJzb2x1dGUsIHNvIHRoYXQgdGhleSBjYW4gYmUgdXNlZCBpbiB0aGUgbmV3IHJlcG9zaXRvcnkuCgkgKi8KCUZJTEUgKmluID0gZm9wZW4oc3JjLT5idWYsICJyIik7CglzdHJ1Y3Qgc3RyYnVmIGxpbmUgPSBTVFJCVUZfSU5JVDsKCgl3aGlsZSAoc3RyYnVmX2dldGxpbmUoJmxpbmUsIGluLCAnXG4nKSAhPSBFT0YpIHsKCQljaGFyICphYnNfcGF0aDsKCQlpZiAoIWxpbmUubGVuIHx8IGxpbmUuYnVmWzBdID09ICcjJykKCQkJY29udGludWU7CgkJaWYgKGlzX2Fic29sdXRlX3BhdGgobGluZS5idWYpKSB7CgkJCWFkZF90b19hbHRlcm5hdGVzX2ZpbGUobGluZS5idWYpOwoJCQljb250aW51ZTsKCQl9CgkJYWJzX3BhdGggPSBta3BhdGhkdXAoIiVzL29iamVjdHMvJXMiLCBzcmNfcmVwbywgbGluZS5idWYpOwoJCW5vcm1hbGl6ZV9wYXRoX2NvcHkoYWJzX3BhdGgsIGFic19wYXRoKTsKCQlhZGRfdG9fYWx0ZXJuYXRlc19maWxlKGFic19wYXRoKTsKCQlmcmVlKGFic19wYXRoKTsKCX0KCXN0cmJ1Zl9yZWxlYXNlKCZsaW5lKTsKCWZjbG9zZShpbik7Cn0KCnN0YXRpYyB2b2lkIGNvcHlfb3JfbGlua19kaXJlY3Rvcnkoc3RydWN0IHN0cmJ1ZiAqc3JjLCBzdHJ1Y3Qgc3RyYnVmICpkZXN0LAoJCQkJICAgY29uc3QgY2hhciAqc3JjX3JlcG8sIGludCBzcmNfYmFzZWxlbikKewoJc3RydWN0IGRpcmVudCAqZGU7CglzdHJ1Y3Qgc3RhdCBidWY7CglpbnQgc3JjX2xlbiwgZGVzdF9sZW47CglESVIgKmRpcjsKCglkaXIgPSBvcGVuZGlyKHNyYy0+YnVmKTsKCWlmICghZGlyKQoJCWRpZV9lcnJubyhfKCJmYWlsZWQgdG8gb3BlbiAnJXMnIiksIHNyYy0+YnVmKTsKCglpZiAobWtkaXIoZGVzdC0+YnVmLCAwNzc3KSkgewoJCWlmIChlcnJubyAhPSBFRVhJU1QpCgkJCWRpZV9lcnJubyhfKCJmYWlsZWQgdG8gY3JlYXRlIGRpcmVjdG9yeSAnJXMnIiksIGRlc3QtPmJ1Zik7CgkJZWxzZSBpZiAoc3RhdChkZXN0LT5idWYsICZidWYpKQoJCQlkaWVfZXJybm8oXygiZmFpbGVkIHRvIHN0YXQgJyVzJyIpLCBkZXN0LT5idWYpOwoJCWVsc2UgaWYgKCFTX0lTRElSKGJ1Zi5zdF9tb2RlKSkKCQkJZGllKF8oIiVzIGV4aXN0cyBhbmQgaXMgbm90IGEgZGlyZWN0b3J5IiksIGRlc3QtPmJ1Zik7Cgl9CgoJc3RyYnVmX2FkZGNoKHNyYywgJy8nKTsKCXNyY19sZW4gPSBzcmMtPmxlbjsKCXN0cmJ1Zl9hZGRjaChkZXN0LCAnLycpOwoJZGVzdF9sZW4gPSBkZXN0LT5sZW47CgoJd2hpbGUgKChkZSA9IHJlYWRkaXIoZGlyKSkgIT0gTlVMTCkgewoJCXN0cmJ1Zl9zZXRsZW4oc3JjLCBzcmNfbGVuKTsKCQlzdHJidWZfYWRkc3RyKHNyYywgZGUtPmRfbmFtZSk7CgkJc3RyYnVmX3NldGxlbihkZXN0LCBkZXN0X2xlbik7CgkJc3RyYnVmX2FkZHN0cihkZXN0LCBkZS0+ZF9uYW1lKTsKCQlpZiAoc3RhdChzcmMtPmJ1ZiwgJmJ1ZikpIHsKCQkJd2FybmluZyAoXygiZmFpbGVkIHRvIHN0YXQgJXNcbiIpLCBzcmMtPmJ1Zik7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoU19JU0RJUihidWYuc3RfbW9kZSkpIHsKCQkJaWYgKGRlLT5kX25hbWVbMF0gIT0gJy4nKQoJCQkJY29weV9vcl9saW5rX2RpcmVjdG9yeShzcmMsIGRlc3QsCgkJCQkJCSAgICAgICBzcmNfcmVwbywgc3JjX2Jhc2VsZW4pOwoJCQljb250aW51ZTsKCQl9CgoJCS8qIEZpbGVzIHRoYXQgY2Fubm90IGJlIGNvcGllZCBiaXQtZm9yLWJpdC4uLiAqLwoJCWlmICghc3RyY21wKHNyYy0+YnVmICsgc3JjX2Jhc2VsZW4sICIvaW5mby9hbHRlcm5hdGVzIikpIHsKCQkJY29weV9hbHRlcm5hdGVzKHNyYywgZGVzdCwgc3JjX3JlcG8pOwoJCQljb250aW51ZTsKCQl9CgoJCWlmICh1bmxpbmsoZGVzdC0+YnVmKSAmJiBlcnJubyAhPSBFTk9FTlQpCgkJCWRpZV9lcnJubyhfKCJmYWlsZWQgdG8gdW5saW5rICclcyciKSwgZGVzdC0+YnVmKTsKCQlpZiAoIW9wdGlvbl9ub19oYXJkbGlua3MpIHsKCQkJaWYgKCFsaW5rKHNyYy0+YnVmLCBkZXN0LT5idWYpKQoJCQkJY29udGludWU7CgkJCWlmIChvcHRpb25fbG9jYWwgPiAwKQoJCQkJZGllX2Vycm5vKF8oImZhaWxlZCB0byBjcmVhdGUgbGluayAnJXMnIiksIGRlc3QtPmJ1Zik7CgkJCW9wdGlvbl9ub19oYXJkbGlua3MgPSAxOwoJCX0KCQlpZiAoY29weV9maWxlX3dpdGhfdGltZShkZXN0LT5idWYsIHNyYy0+YnVmLCAwNjY2KSkKCQkJZGllX2Vycm5vKF8oImZhaWxlZCB0byBjb3B5IGZpbGUgdG8gJyVzJyIpLCBkZXN0LT5idWYpOwoJfQoJY2xvc2VkaXIoZGlyKTsKfQoKc3RhdGljIHZvaWQgY2xvbmVfbG9jYWwoY29uc3QgY2hhciAqc3JjX3JlcG8sIGNvbnN0IGNoYXIgKmRlc3RfcmVwbykKewoJaWYgKG9wdGlvbl9zaGFyZWQpIHsKCQlzdHJ1Y3Qgc3RyYnVmIGFsdCA9IFNUUkJVRl9JTklUOwoJCXN0cmJ1Zl9hZGRmKCZhbHQsICIlcy9vYmplY3RzIiwgc3JjX3JlcG8pOwoJCWFkZF90b19hbHRlcm5hdGVzX2ZpbGUoYWx0LmJ1Zik7CgkJc3RyYnVmX3JlbGVhc2UoJmFsdCk7Cgl9IGVsc2UgewoJCXN0cnVjdCBzdHJidWYgc3JjID0gU1RSQlVGX0lOSVQ7CgkJc3RydWN0IHN0cmJ1ZiBkZXN0ID0gU1RSQlVGX0lOSVQ7CgkJc3RyYnVmX2FkZGYoJnNyYywgIiVzL29iamVjdHMiLCBzcmNfcmVwbyk7CgkJc3RyYnVmX2FkZGYoJmRlc3QsICIlcy9vYmplY3RzIiwgZGVzdF9yZXBvKTsKCQljb3B5X29yX2xpbmtfZGlyZWN0b3J5KCZzcmMsICZkZXN0LCBzcmNfcmVwbywgc3JjLmxlbik7CgkJc3RyYnVmX3JlbGVhc2UoJnNyYyk7CgkJc3RyYnVmX3JlbGVhc2UoJmRlc3QpOwoJfQoKCWlmICgwIDw9IG9wdGlvbl92ZXJib3NpdHkpCgkJZnByaW50ZihzdGRlcnIsIF8oImRvbmUuXG4iKSk7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpqdW5rX3dvcmtfdHJlZTsKc3RhdGljIGNvbnN0IGNoYXIgKmp1bmtfZ2l0X2RpcjsKc3RhdGljIGVudW0gewoJSlVOS19MRUFWRV9OT05FLAoJSlVOS19MRUFWRV9SRVBPLAoJSlVOS19MRUFWRV9BTEwKfSBqdW5rX21vZGUgPSBKVU5LX0xFQVZFX05PTkU7CgpzdGF0aWMgY29uc3QgY2hhciBqdW5rX2xlYXZlX3JlcG9fbXNnW10gPQpOXygiQ2xvbmUgc3VjY2VlZGVkLCBidXQgY2hlY2tvdXQgZmFpbGVkLlxuIgogICAiWW91IGNhbiBpbnNwZWN0IHdoYXQgd2FzIGNoZWNrZWQgb3V0IHdpdGggJ2dpdCBzdGF0dXMnXG4iCiAgICJhbmQgcmV0cnkgdGhlIGNoZWNrb3V0IHdpdGggJ2dpdCBjaGVja291dCAtZiBIRUFEJ1xuIik7CgpzdGF0aWMgdm9pZCByZW1vdmVfanVuayh2b2lkKQp7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CgoJc3dpdGNoIChqdW5rX21vZGUpIHsKCWNhc2UgSlVOS19MRUFWRV9SRVBPOgoJCXdhcm5pbmcoIiVzIiwgXyhqdW5rX2xlYXZlX3JlcG9fbXNnKSk7CgkJLyogZmFsbC10aHJvdWdoICovCgljYXNlIEpVTktfTEVBVkVfQUxMOgoJCXJldHVybjsKCWRlZmF1bHQ6CgkJLyogcHJvY2VlZCB0byByZW1vdmFsICovCgkJYnJlYWs7Cgl9CgoJaWYgKGp1bmtfZ2l0X2RpcikgewoJCXN0cmJ1Zl9hZGRzdHIoJnNiLCBqdW5rX2dpdF9kaXIpOwoJCXJlbW92ZV9kaXJfcmVjdXJzaXZlbHkoJnNiLCAwKTsKCQlzdHJidWZfcmVzZXQoJnNiKTsKCX0KCWlmIChqdW5rX3dvcmtfdHJlZSkgewoJCXN0cmJ1Zl9hZGRzdHIoJnNiLCBqdW5rX3dvcmtfdHJlZSk7CgkJcmVtb3ZlX2Rpcl9yZWN1cnNpdmVseSgmc2IsIDApOwoJCXN0cmJ1Zl9yZXNldCgmc2IpOwoJfQp9CgpzdGF0aWMgdm9pZCByZW1vdmVfanVua19vbl9zaWduYWwoaW50IHNpZ25vKQp7CglyZW1vdmVfanVuaygpOwoJc2lnY2hhaW5fcG9wKHNpZ25vKTsKCXJhaXNlKHNpZ25vKTsKfQoKc3RhdGljIHN0cnVjdCByZWYgKmZpbmRfcmVtb3RlX2JyYW5jaChjb25zdCBzdHJ1Y3QgcmVmICpyZWZzLCBjb25zdCBjaGFyICpicmFuY2gpCnsKCXN0cnVjdCByZWYgKnJlZjsKCXN0cnVjdCBzdHJidWYgaGVhZCA9IFNUUkJVRl9JTklUOwoJc3RyYnVmX2FkZHN0cigmaGVhZCwgInJlZnMvaGVhZHMvIik7CglzdHJidWZfYWRkc3RyKCZoZWFkLCBicmFuY2gpOwoJcmVmID0gZmluZF9yZWZfYnlfbmFtZShyZWZzLCBoZWFkLmJ1Zik7CglzdHJidWZfcmVsZWFzZSgmaGVhZCk7CgoJaWYgKHJlZikKCQlyZXR1cm4gcmVmOwoKCXN0cmJ1Zl9hZGRzdHIoJmhlYWQsICJyZWZzL3RhZ3MvIik7CglzdHJidWZfYWRkc3RyKCZoZWFkLCBicmFuY2gpOwoJcmVmID0gZmluZF9yZWZfYnlfbmFtZShyZWZzLCBoZWFkLmJ1Zik7CglzdHJidWZfcmVsZWFzZSgmaGVhZCk7CgoJcmV0dXJuIHJlZjsKfQoKc3RhdGljIHN0cnVjdCByZWYgKndhbnRlZF9wZWVyX3JlZnMoY29uc3Qgc3RydWN0IHJlZiAqcmVmcywKCQlzdHJ1Y3QgcmVmc3BlYyAqcmVmc3BlYykKewoJc3RydWN0IHJlZiAqaGVhZCA9IGNvcHlfcmVmKGZpbmRfcmVmX2J5X25hbWUocmVmcywgIkhFQUQiKSk7CglzdHJ1Y3QgcmVmICpsb2NhbF9yZWZzID0gaGVhZDsKCXN0cnVjdCByZWYgKip0YWlsID0gaGVhZCA/ICZoZWFkLT5uZXh0IDogJmxvY2FsX3JlZnM7CgoJaWYgKG9wdGlvbl9zaW5nbGVfYnJhbmNoKSB7CgkJc3RydWN0IHJlZiAqcmVtb3RlX2hlYWQgPSBOVUxMOwoKCQlpZiAoIW9wdGlvbl9icmFuY2gpCgkJCXJlbW90ZV9oZWFkID0gZ3Vlc3NfcmVtb3RlX2hlYWQoaGVhZCwgcmVmcywgMCk7CgkJZWxzZSB7CgkJCWxvY2FsX3JlZnMgPSBOVUxMOwoJCQl0YWlsID0gJmxvY2FsX3JlZnM7CgkJCXJlbW90ZV9oZWFkID0gY29weV9yZWYoZmluZF9yZW1vdGVfYnJhbmNoKHJlZnMsIG9wdGlvbl9icmFuY2gpKTsKCQl9CgoJCWlmICghcmVtb3RlX2hlYWQgJiYgb3B0aW9uX2JyYW5jaCkKCQkJd2FybmluZyhfKCJDb3VsZCBub3QgZmluZCByZW1vdGUgYnJhbmNoICVzIHRvIGNsb25lLiIpLAoJCQkJb3B0aW9uX2JyYW5jaCk7CgkJZWxzZSB7CgkJCWdldF9mZXRjaF9tYXAocmVtb3RlX2hlYWQsIHJlZnNwZWMsICZ0YWlsLCAwKTsKCgkJCS8qIGlmIC0tYnJhbmNoPXRhZywgcHVsbCB0aGUgcmVxdWVzdGVkIHRhZyBleHBsaWNpdGx5ICovCgkJCWdldF9mZXRjaF9tYXAocmVtb3RlX2hlYWQsIHRhZ19yZWZzcGVjLCAmdGFpbCwgMCk7CgkJfQoJfSBlbHNlCgkJZ2V0X2ZldGNoX21hcChyZWZzLCByZWZzcGVjLCAmdGFpbCwgMCk7CgoJaWYgKCFvcHRpb25fbWlycm9yICYmICFvcHRpb25fc2luZ2xlX2JyYW5jaCkKCQlnZXRfZmV0Y2hfbWFwKHJlZnMsIHRhZ19yZWZzcGVjLCAmdGFpbCwgMCk7CgoJcmV0dXJuIGxvY2FsX3JlZnM7Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX3JlbW90ZV9yZWZzKGNvbnN0IHN0cnVjdCByZWYgKmxvY2FsX3JlZnMpCnsKCWNvbnN0IHN0cnVjdCByZWYgKnI7CgoJbG9ja19wYWNrZWRfcmVmcyhMT0NLX0RJRV9PTl9FUlJPUik7CgoJZm9yIChyID0gbG9jYWxfcmVmczsgcjsgciA9IHItPm5leHQpIHsKCQlpZiAoIXItPnBlZXJfcmVmKQoJCQljb250aW51ZTsKCQlhZGRfcGFja2VkX3JlZihyLT5wZWVyX3JlZi0+bmFtZSwgci0+b2xkX3NoYTEpOwoJfQoKCWlmIChjb21taXRfcGFja2VkX3JlZnMoKSkKCQlkaWVfZXJybm8oInVuYWJsZSB0byBvdmVyd3JpdGUgb2xkIHJlZi1wYWNrIGZpbGUiKTsKfQoKc3RhdGljIHZvaWQgd3JpdGVfZm9sbG93dGFncyhjb25zdCBzdHJ1Y3QgcmVmICpyZWZzLCBjb25zdCBjaGFyICptc2cpCnsKCWNvbnN0IHN0cnVjdCByZWYgKnJlZjsKCWZvciAocmVmID0gcmVmczsgcmVmOyByZWYgPSByZWYtPm5leHQpIHsKCQlpZiAoIXN0YXJ0c193aXRoKHJlZi0+bmFtZSwgInJlZnMvdGFncy8iKSkKCQkJY29udGludWU7CgkJaWYgKGVuZHNfd2l0aChyZWYtPm5hbWUsICJee30iKSkKCQkJY29udGludWU7CgkJaWYgKCFoYXNfc2hhMV9maWxlKHJlZi0+b2xkX3NoYTEpKQoJCQljb250aW51ZTsKCQl1cGRhdGVfcmVmKG1zZywgcmVmLT5uYW1lLCByZWYtPm9sZF9zaGExLAoJCQkgICBOVUxMLCAwLCBVUERBVEVfUkVGU19ESUVfT05fRVJSKTsKCX0KfQoKc3RhdGljIGludCBpdGVyYXRlX3JlZl9tYXAodm9pZCAqY2JfZGF0YSwgdW5zaWduZWQgY2hhciBzaGExWzIwXSkKewoJc3RydWN0IHJlZiAqKnJtID0gY2JfZGF0YTsKCXN0cnVjdCByZWYgKnJlZiA9ICpybTsKCgkvKgoJICogU2tpcCBhbnl0aGluZyBtaXNzaW5nIGEgcGVlcl9yZWYsIHdoaWNoIHdlIGFyZSBub3QKCSAqIGFjdHVhbGx5IGdvaW5nIHRvIHdyaXRlIGEgcmVmIGZvci4KCSAqLwoJd2hpbGUgKHJlZiAmJiAhcmVmLT5wZWVyX3JlZikKCQlyZWYgPSByZWYtPm5leHQ7CgkvKiBSZXR1cm5pbmcgLTEgbm90ZXMgImVuZCBvZiBsaXN0IiB0byB0aGUgY2FsbGVyLiAqLwoJaWYgKCFyZWYpCgkJcmV0dXJuIC0xOwoKCWhhc2hjcHkoc2hhMSwgcmVmLT5vbGRfc2hhMSk7Cgkqcm0gPSByZWYtPm5leHQ7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgdXBkYXRlX3JlbW90ZV9yZWZzKGNvbnN0IHN0cnVjdCByZWYgKnJlZnMsCgkJCSAgICAgICBjb25zdCBzdHJ1Y3QgcmVmICptYXBwZWRfcmVmcywKCQkJICAgICAgIGNvbnN0IHN0cnVjdCByZWYgKnJlbW90ZV9oZWFkX3BvaW50c19hdCwKCQkJICAgICAgIGNvbnN0IGNoYXIgKmJyYW5jaF90b3AsCgkJCSAgICAgICBjb25zdCBjaGFyICptc2csCgkJCSAgICAgICBzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsCgkJCSAgICAgICBpbnQgY2hlY2tfY29ubmVjdGl2aXR5KQp7Cgljb25zdCBzdHJ1Y3QgcmVmICpybSA9IG1hcHBlZF9yZWZzOwoKCWlmIChjaGVja19jb25uZWN0aXZpdHkpIHsKCQlpZiAodHJhbnNwb3J0LT5wcm9ncmVzcykKCQkJZnByaW50ZihzdGRlcnIsIF8oIkNoZWNraW5nIGNvbm5lY3Rpdml0eS4uLiAiKSk7CgkJaWYgKGNoZWNrX2V2ZXJ5dGhpbmdfY29ubmVjdGVkX3dpdGhfdHJhbnNwb3J0KGl0ZXJhdGVfcmVmX21hcCwKCQkJCQkJCSAgICAgIDAsICZybSwgdHJhbnNwb3J0KSkKCQkJZGllKF8oInJlbW90ZSBkaWQgbm90IHNlbmQgYWxsIG5lY2Vzc2FyeSBvYmplY3RzIikpOwoJCWlmICh0cmFuc3BvcnQtPnByb2dyZXNzKQoJCQlmcHJpbnRmKHN0ZGVyciwgXygiZG9uZS5cbiIpKTsKCX0KCglpZiAocmVmcykgewoJCXdyaXRlX3JlbW90ZV9yZWZzKG1hcHBlZF9yZWZzKTsKCQlpZiAob3B0aW9uX3NpbmdsZV9icmFuY2gpCgkJCXdyaXRlX2ZvbGxvd3RhZ3MocmVmcywgbXNnKTsKCX0KCglpZiAocmVtb3RlX2hlYWRfcG9pbnRzX2F0ICYmICFvcHRpb25fYmFyZSkgewoJCXN0cnVjdCBzdHJidWYgaGVhZF9yZWYgPSBTVFJCVUZfSU5JVDsKCQlzdHJidWZfYWRkc3RyKCZoZWFkX3JlZiwgYnJhbmNoX3RvcCk7CgkJc3RyYnVmX2FkZHN0cigmaGVhZF9yZWYsICJIRUFEIik7CgkJY3JlYXRlX3N5bXJlZihoZWFkX3JlZi5idWYsCgkJCSAgICAgIHJlbW90ZV9oZWFkX3BvaW50c19hdC0+cGVlcl9yZWYtPm5hbWUsCgkJCSAgICAgIG1zZyk7Cgl9Cn0KCnN0YXRpYyB2b2lkIHVwZGF0ZV9oZWFkKGNvbnN0IHN0cnVjdCByZWYgKm91ciwgY29uc3Qgc3RydWN0IHJlZiAqcmVtb3RlLAoJCQljb25zdCBjaGFyICptc2cpCnsKCWNvbnN0IGNoYXIgKmhlYWQ7CglpZiAob3VyICYmIHNraXBfcHJlZml4KG91ci0+bmFtZSwgInJlZnMvaGVhZHMvIiwgJmhlYWQpKSB7CgkJLyogTG9jYWwgZGVmYXVsdCBicmFuY2ggbGluayAqLwoJCWNyZWF0ZV9zeW1yZWYoIkhFQUQiLCBvdXItPm5hbWUsIE5VTEwpOwoJCWlmICghb3B0aW9uX2JhcmUpIHsKCQkJdXBkYXRlX3JlZihtc2csICJIRUFEIiwgb3VyLT5vbGRfc2hhMSwgTlVMTCwgMCwKCQkJCSAgIFVQREFURV9SRUZTX0RJRV9PTl9FUlIpOwoJCQlpbnN0YWxsX2JyYW5jaF9jb25maWcoMCwgaGVhZCwgb3B0aW9uX29yaWdpbiwgb3VyLT5uYW1lKTsKCQl9Cgl9IGVsc2UgaWYgKG91cikgewoJCXN0cnVjdCBjb21taXQgKmMgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZShvdXItPm9sZF9zaGExKTsKCQkvKiAtLWJyYW5jaCBzcGVjaWZpZXMgYSBub24tYnJhbmNoIChpLmUuIHRhZ3MpLCBkZXRhY2ggSEVBRCAqLwoJCXVwZGF0ZV9yZWYobXNnLCAiSEVBRCIsIGMtPm9iamVjdC5zaGExLAoJCQkgICBOVUxMLCBSRUZfTk9ERVJFRiwgVVBEQVRFX1JFRlNfRElFX09OX0VSUik7Cgl9IGVsc2UgaWYgKHJlbW90ZSkgewoJCS8qCgkJICogV2Uga25vdyByZW1vdGUgSEVBRCBwb2ludHMgdG8gYSBub24tYnJhbmNoLCBvcgoJCSAqIEhFQUQgcG9pbnRzIHRvIGEgYnJhbmNoIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIG9uZS4KCQkgKiBEZXRhY2ggSEVBRCBpbiBhbGwgdGhlc2UgY2FzZXMuCgkJICovCgkJdXBkYXRlX3JlZihtc2csICJIRUFEIiwgcmVtb3RlLT5vbGRfc2hhMSwKCQkJICAgTlVMTCwgUkVGX05PREVSRUYsIFVQREFURV9SRUZTX0RJRV9PTl9FUlIpOwoJfQp9CgpzdGF0aWMgaW50IGNoZWNrb3V0KHZvaWQpCnsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgljaGFyICpoZWFkOwoJc3RydWN0IGxvY2tfZmlsZSAqbG9ja19maWxlOwoJc3RydWN0IHVucGFja190cmVlc19vcHRpb25zIG9wdHM7CglzdHJ1Y3QgdHJlZSAqdHJlZTsKCXN0cnVjdCB0cmVlX2Rlc2MgdDsKCWludCBlcnIgPSAwOwoKCWlmIChvcHRpb25fbm9fY2hlY2tvdXQpCgkJcmV0dXJuIDA7CgoJaGVhZCA9IHJlc29sdmVfcmVmZHVwKCJIRUFEIiwgUkVTT0xWRV9SRUZfUkVBRElORywgc2hhMSwgTlVMTCk7CglpZiAoIWhlYWQpIHsKCQl3YXJuaW5nKF8oInJlbW90ZSBIRUFEIHJlZmVycyB0byBub25leGlzdGVudCByZWYsICIKCQkJICAidW5hYmxlIHRvIGNoZWNrb3V0LlxuIikpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaGVhZCwgIkhFQUQiKSkgewoJCWlmIChhZHZpY2VfZGV0YWNoZWRfaGVhZCkKCQkJZGV0YWNoX2FkdmljZShzaGExX3RvX2hleChzaGExKSk7Cgl9IGVsc2UgewoJCWlmICghc3RhcnRzX3dpdGgoaGVhZCwgInJlZnMvaGVhZHMvIikpCgkJCWRpZShfKCJIRUFEIG5vdCBmb3VuZCBiZWxvdyByZWZzL2hlYWRzISIpKTsKCX0KCWZyZWUoaGVhZCk7CgoJLyogV2UgbmVlZCB0byBiZSBpbiB0aGUgbmV3IHdvcmsgdHJlZSBmb3IgdGhlIGNoZWNrb3V0ICovCglzZXR1cF93b3JrX3RyZWUoKTsKCglsb2NrX2ZpbGUgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3QgbG9ja19maWxlKSk7Cglob2xkX2xvY2tlZF9pbmRleChsb2NrX2ZpbGUsIDEpOwoKCW1lbXNldCgmb3B0cywgMCwgc2l6ZW9mIG9wdHMpOwoJb3B0cy51cGRhdGUgPSAxOwoJb3B0cy5tZXJnZSA9IDE7CglvcHRzLmZuID0gb25ld2F5X21lcmdlOwoJb3B0cy52ZXJib3NlX3VwZGF0ZSA9IChvcHRpb25fdmVyYm9zaXR5ID49IDApOwoJb3B0cy5zcmNfaW5kZXggPSAmdGhlX2luZGV4OwoJb3B0cy5kc3RfaW5kZXggPSAmdGhlX2luZGV4OwoKCXRyZWUgPSBwYXJzZV90cmVlX2luZGlyZWN0KHNoYTEpOwoJcGFyc2VfdHJlZSh0cmVlKTsKCWluaXRfdHJlZV9kZXNjKCZ0LCB0cmVlLT5idWZmZXIsIHRyZWUtPnNpemUpOwoJaWYgKHVucGFja190cmVlcygxLCAmdCwgJm9wdHMpIDwgMCkKCQlkaWUoXygidW5hYmxlIHRvIGNoZWNrb3V0IHdvcmtpbmcgdHJlZSIpKTsKCglpZiAod3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsIGxvY2tfZmlsZSwgQ09NTUlUX0xPQ0spKQoJCWRpZShfKCJ1bmFibGUgdG8gd3JpdGUgbmV3IGluZGV4IGZpbGUiKSk7CgoJZXJyIHw9IHJ1bl9ob29rX2xlKE5VTEwsICJwb3N0LWNoZWNrb3V0Iiwgc2hhMV90b19oZXgobnVsbF9zaGExKSwKCQkJICAgc2hhMV90b19oZXgoc2hhMSksICIxIiwgTlVMTCk7CgoJaWYgKCFlcnIgJiYgb3B0aW9uX3JlY3Vyc2l2ZSkKCQllcnIgPSBydW5fY29tbWFuZF92X29wdChhcmd2X3N1Ym1vZHVsZSwgUlVOX0dJVF9DTUQpOwoKCXJldHVybiBlcnI7Cn0KCnN0YXRpYyBpbnQgd3JpdGVfb25lX2NvbmZpZyhjb25zdCBjaGFyICprZXksIGNvbnN0IGNoYXIgKnZhbHVlLCB2b2lkICpkYXRhKQp7CglyZXR1cm4gZ2l0X2NvbmZpZ19zZXRfbXVsdGl2YXIoa2V5LCB2YWx1ZSA/IHZhbHVlIDogInRydWUiLCAiXiQiLCAwKTsKfQoKc3RhdGljIHZvaWQgd3JpdGVfY29uZmlnKHN0cnVjdCBzdHJpbmdfbGlzdCAqY29uZmlnKQp7CglpbnQgaTsKCglmb3IgKGkgPSAwOyBpIDwgY29uZmlnLT5ucjsgaSsrKSB7CgkJaWYgKGdpdF9jb25maWdfcGFyc2VfcGFyYW1ldGVyKGNvbmZpZy0+aXRlbXNbaV0uc3RyaW5nLAoJCQkJCSAgICAgICB3cml0ZV9vbmVfY29uZmlnLCBOVUxMKSA8IDApCgkJCWRpZSgidW5hYmxlIHRvIHdyaXRlIHBhcmFtZXRlcnMgdG8gY29uZmlnIGZpbGUiKTsKCX0KfQoKc3RhdGljIHZvaWQgd3JpdGVfcmVmc3BlY19jb25maWcoY29uc3QgY2hhciAqc3JjX3JlZl9wcmVmaXgsCgkJY29uc3Qgc3RydWN0IHJlZiAqb3VyX2hlYWRfcG9pbnRzX2F0LAoJCWNvbnN0IHN0cnVjdCByZWYgKnJlbW90ZV9oZWFkX3BvaW50c19hdCwKCQlzdHJ1Y3Qgc3RyYnVmICpicmFuY2hfdG9wKQp7CglzdHJ1Y3Qgc3RyYnVmIGtleSA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiB2YWx1ZSA9IFNUUkJVRl9JTklUOwoKCWlmIChvcHRpb25fbWlycm9yIHx8ICFvcHRpb25fYmFyZSkgewoJCWlmIChvcHRpb25fc2luZ2xlX2JyYW5jaCAmJiAhb3B0aW9uX21pcnJvcikgewoJCQlpZiAob3B0aW9uX2JyYW5jaCkgewoJCQkJaWYgKHN0YXJ0c193aXRoKG91cl9oZWFkX3BvaW50c19hdC0+bmFtZSwgInJlZnMvdGFncy8iKSkKCQkJCQlzdHJidWZfYWRkZigmdmFsdWUsICIrJXM6JXMiLCBvdXJfaGVhZF9wb2ludHNfYXQtPm5hbWUsCgkJCQkJCW91cl9oZWFkX3BvaW50c19hdC0+bmFtZSk7CgkJCQllbHNlCgkJCQkJc3RyYnVmX2FkZGYoJnZhbHVlLCAiKyVzOiVzJXMiLCBvdXJfaGVhZF9wb2ludHNfYXQtPm5hbWUsCgkJCQkJCWJyYW5jaF90b3AtPmJ1Ziwgb3B0aW9uX2JyYW5jaCk7CgkJCX0gZWxzZSBpZiAocmVtb3RlX2hlYWRfcG9pbnRzX2F0KSB7CgkJCQljb25zdCBjaGFyICpoZWFkID0gcmVtb3RlX2hlYWRfcG9pbnRzX2F0LT5uYW1lOwoJCQkJaWYgKCFza2lwX3ByZWZpeChoZWFkLCAicmVmcy9oZWFkcy8iLCAmaGVhZCkpCgkJCQkJZGllKCJCVUc6IHJlbW90ZSBIRUFEIHBvaW50cyBhdCBub24taGVhZD8iKTsKCgkJCQlzdHJidWZfYWRkZigmdmFsdWUsICIrJXM6JXMlcyIsIHJlbW90ZV9oZWFkX3BvaW50c19hdC0+bmFtZSwKCQkJCQkJYnJhbmNoX3RvcC0+YnVmLCBoZWFkKTsKCQkJfQoJCQkvKgoJCQkgKiBvdGhlcndpc2UsIHRoZSBuZXh0ICJnaXQgZmV0Y2giIHdpbGwKCQkJICogc2ltcGx5IGZldGNoIGZyb20gSEVBRCB3aXRob3V0IHVwZGF0aW5nCgkJCSAqIGFueSByZW1vdGUtdHJhY2tpbmcgYnJhbmNoLCB3aGljaCBpcyB3aGF0CgkJCSAqIHdlIHdhbnQuCgkJCSAqLwoJCX0gZWxzZSB7CgkJCXN0cmJ1Zl9hZGRmKCZ2YWx1ZSwgIislcyo6JXMqIiwgc3JjX3JlZl9wcmVmaXgsIGJyYW5jaF90b3AtPmJ1Zik7CgkJfQoJCS8qIENvbmZpZ3VyZSB0aGUgcmVtb3RlICovCgkJaWYgKHZhbHVlLmxlbikgewoJCQlzdHJidWZfYWRkZigma2V5LCAicmVtb3RlLiVzLmZldGNoIiwgb3B0aW9uX29yaWdpbik7CgkJCWdpdF9jb25maWdfc2V0X211bHRpdmFyKGtleS5idWYsIHZhbHVlLmJ1ZiwgIl4kIiwgMCk7CgkJCXN0cmJ1Zl9yZXNldCgma2V5KTsKCgkJCWlmIChvcHRpb25fbWlycm9yKSB7CgkJCQlzdHJidWZfYWRkZigma2V5LCAicmVtb3RlLiVzLm1pcnJvciIsIG9wdGlvbl9vcmlnaW4pOwoJCQkJZ2l0X2NvbmZpZ19zZXQoa2V5LmJ1ZiwgInRydWUiKTsKCQkJCXN0cmJ1Zl9yZXNldCgma2V5KTsKCQkJfQoJCX0KCX0KCglzdHJidWZfcmVsZWFzZSgma2V5KTsKCXN0cmJ1Zl9yZWxlYXNlKCZ2YWx1ZSk7Cn0KCnN0YXRpYyB2b2lkIGRpc3NvY2lhdGVfZnJvbV9yZWZlcmVuY2VzKHZvaWQpCnsKCXN0YXRpYyBjb25zdCBjaGFyKiBhcmd2W10gPSB7ICJyZXBhY2siLCAiLWEiLCAiLWQiLCBOVUxMIH07CgoJaWYgKHJ1bl9jb21tYW5kX3Zfb3B0KGFyZ3YsIFJVTl9HSVRfQ01EfFJVTl9DT01NQU5EX05PX1NURElOKSkKCQlkaWUoXygiY2Fubm90IHJlcGFjayB0byBjbGVhbiB1cCIpKTsKCWlmICh1bmxpbmsoZ2l0X3BhdGgoIm9iamVjdHMvaW5mby9hbHRlcm5hdGVzIikpICYmIGVycm5vICE9IEVOT0VOVCkKCQlkaWVfZXJybm8oXygiY2Fubm90IHVubGluayB0ZW1wb3JhcnkgYWx0ZXJuYXRlcyBmaWxlIikpOwp9CgppbnQgY21kX2Nsb25lKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglpbnQgaXNfYnVuZGxlID0gMCwgaXNfbG9jYWw7CglzdHJ1Y3Qgc3RhdCBidWY7Cgljb25zdCBjaGFyICpyZXBvX25hbWUsICpyZXBvLCAqd29ya190cmVlLCAqZ2l0X2RpcjsKCWNoYXIgKnBhdGgsICpkaXI7CglpbnQgZGVzdF9leGlzdHM7Cgljb25zdCBzdHJ1Y3QgcmVmICpyZWZzLCAqcmVtb3RlX2hlYWQ7Cgljb25zdCBzdHJ1Y3QgcmVmICpyZW1vdGVfaGVhZF9wb2ludHNfYXQ7Cgljb25zdCBzdHJ1Y3QgcmVmICpvdXJfaGVhZF9wb2ludHNfYXQ7CglzdHJ1Y3QgcmVmICptYXBwZWRfcmVmczsKCWNvbnN0IHN0cnVjdCByZWYgKnJlZjsKCXN0cnVjdCBzdHJidWYga2V5ID0gU1RSQlVGX0lOSVQsIHZhbHVlID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGJyYW5jaF90b3AgPSBTVFJCVUZfSU5JVCwgcmVmbG9nX21zZyA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0ID0gTlVMTDsKCWNvbnN0IGNoYXIgKnNyY19yZWZfcHJlZml4ID0gInJlZnMvaGVhZHMvIjsKCXN0cnVjdCByZW1vdGUgKnJlbW90ZTsKCWludCBlcnIgPSAwLCBjb21wbGV0ZV9yZWZzX2JlZm9yZV9mZXRjaCA9IDE7CgoJc3RydWN0IHJlZnNwZWMgKnJlZnNwZWM7Cgljb25zdCBjaGFyICpmZXRjaF9wYXR0ZXJuOwoKCXBhY2tldF90cmFjZV9pZGVudGl0eSgiY2xvbmUiKTsKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgYnVpbHRpbl9jbG9uZV9vcHRpb25zLAoJCQkgICAgIGJ1aWx0aW5fY2xvbmVfdXNhZ2UsIDApOwoKCWlmIChhcmdjID4gMikKCQl1c2FnZV9tc2dfb3B0KF8oIlRvbyBtYW55IGFyZ3VtZW50cy4iKSwKCQkJYnVpbHRpbl9jbG9uZV91c2FnZSwgYnVpbHRpbl9jbG9uZV9vcHRpb25zKTsKCglpZiAoYXJnYyA9PSAwKQoJCXVzYWdlX21zZ19vcHQoXygiWW91IG11c3Qgc3BlY2lmeSBhIHJlcG9zaXRvcnkgdG8gY2xvbmUuIiksCgkJCWJ1aWx0aW5fY2xvbmVfdXNhZ2UsIGJ1aWx0aW5fY2xvbmVfb3B0aW9ucyk7CgoJaWYgKG9wdGlvbl9zaW5nbGVfYnJhbmNoID09IC0xKQoJCW9wdGlvbl9zaW5nbGVfYnJhbmNoID0gb3B0aW9uX2RlcHRoID8gMSA6IDA7CgoJaWYgKG9wdGlvbl9taXJyb3IpCgkJb3B0aW9uX2JhcmUgPSAxOwoKCWlmIChvcHRpb25fYmFyZSkgewoJCWlmIChvcHRpb25fb3JpZ2luKQoJCQlkaWUoXygiLS1iYXJlIGFuZCAtLW9yaWdpbiAlcyBvcHRpb25zIGFyZSBpbmNvbXBhdGlibGUuIiksCgkJCSAgICBvcHRpb25fb3JpZ2luKTsKCQlpZiAocmVhbF9naXRfZGlyKQoJCQlkaWUoXygiLS1iYXJlIGFuZCAtLXNlcGFyYXRlLWdpdC1kaXIgYXJlIGluY29tcGF0aWJsZS4iKSk7CgkJb3B0aW9uX25vX2NoZWNrb3V0ID0gMTsKCX0KCglpZiAoIW9wdGlvbl9vcmlnaW4pCgkJb3B0aW9uX29yaWdpbiA9ICJvcmlnaW4iOwoKCXJlcG9fbmFtZSA9IGFyZ3ZbMF07CgoJcGF0aCA9IGdldF9yZXBvX3BhdGgocmVwb19uYW1lLCAmaXNfYnVuZGxlKTsKCWlmIChwYXRoKQoJCXJlcG8gPSB4c3RyZHVwKGFic29sdXRlX3BhdGgocmVwb19uYW1lKSk7CgllbHNlIGlmICghc3RyY2hyKHJlcG9fbmFtZSwgJzonKSkKCQlkaWUoXygicmVwb3NpdG9yeSAnJXMnIGRvZXMgbm90IGV4aXN0IiksIHJlcG9fbmFtZSk7CgllbHNlCgkJcmVwbyA9IHJlcG9fbmFtZTsKCgkvKiBubyBuZWVkIHRvIGJlIHN0cmljdCwgdHJhbnNwb3J0X3NldF9vcHRpb24oKSB3aWxsIHZhbGlkYXRlIGl0IGFnYWluICovCglpZiAob3B0aW9uX2RlcHRoICYmIGF0b2kob3B0aW9uX2RlcHRoKSA8IDEpCgkJZGllKF8oImRlcHRoICVzIGlzIG5vdCBhIHBvc2l0aXZlIG51bWJlciIpLCBvcHRpb25fZGVwdGgpOwoKCWlmIChhcmdjID09IDIpCgkJZGlyID0geHN0cmR1cChhcmd2WzFdKTsKCWVsc2UKCQlkaXIgPSBndWVzc19kaXJfbmFtZShyZXBvX25hbWUsIGlzX2J1bmRsZSwgb3B0aW9uX2JhcmUpOwoJc3RyaXBfdHJhaWxpbmdfc2xhc2hlcyhkaXIpOwoKCWRlc3RfZXhpc3RzID0gIXN0YXQoZGlyLCAmYnVmKTsKCWlmIChkZXN0X2V4aXN0cyAmJiAhaXNfZW1wdHlfZGlyKGRpcikpCgkJZGllKF8oImRlc3RpbmF0aW9uIHBhdGggJyVzJyBhbHJlYWR5IGV4aXN0cyBhbmQgaXMgbm90ICIKCQkJImFuIGVtcHR5IGRpcmVjdG9yeS4iKSwgZGlyKTsKCglzdHJidWZfYWRkZigmcmVmbG9nX21zZywgImNsb25lOiBmcm9tICVzIiwgcmVwbyk7CgoJaWYgKG9wdGlvbl9iYXJlKQoJCXdvcmtfdHJlZSA9IE5VTEw7CgllbHNlIHsKCQl3b3JrX3RyZWUgPSBnZXRlbnYoIkdJVF9XT1JLX1RSRUUiKTsKCQlpZiAod29ya190cmVlICYmICFzdGF0KHdvcmtfdHJlZSwgJmJ1ZikpCgkJCWRpZShfKCJ3b3JraW5nIHRyZWUgJyVzJyBhbHJlYWR5IGV4aXN0cy4iKSwgd29ya190cmVlKTsKCX0KCglpZiAob3B0aW9uX2JhcmUgfHwgd29ya190cmVlKQoJCWdpdF9kaXIgPSB4c3RyZHVwKGRpcik7CgllbHNlIHsKCQl3b3JrX3RyZWUgPSBkaXI7CgkJZ2l0X2RpciA9IG1rcGF0aGR1cCgiJXMvLmdpdCIsIGRpcik7Cgl9CgoJYXRleGl0KHJlbW92ZV9qdW5rKTsKCXNpZ2NoYWluX3B1c2hfY29tbW9uKHJlbW92ZV9qdW5rX29uX3NpZ25hbCk7CgoJaWYgKCFvcHRpb25fYmFyZSkgewoJCWlmIChzYWZlX2NyZWF0ZV9sZWFkaW5nX2RpcmVjdG9yaWVzX2NvbnN0KHdvcmtfdHJlZSkgPCAwKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IGNyZWF0ZSBsZWFkaW5nIGRpcmVjdG9yaWVzIG9mICclcyciKSwKCQkJCSAgd29ya190cmVlKTsKCQlpZiAoIWRlc3RfZXhpc3RzICYmIG1rZGlyKHdvcmtfdHJlZSwgMDc3NykpCgkJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgY3JlYXRlIHdvcmsgdHJlZSBkaXIgJyVzJyIpLAoJCQkJICB3b3JrX3RyZWUpOwoJCWp1bmtfd29ya190cmVlID0gd29ya190cmVlOwoJCXNldF9naXRfd29ya190cmVlKHdvcmtfdHJlZSk7Cgl9CgoJanVua19naXRfZGlyID0gZ2l0X2RpcjsKCWlmIChzYWZlX2NyZWF0ZV9sZWFkaW5nX2RpcmVjdG9yaWVzX2NvbnN0KGdpdF9kaXIpIDwgMCkKCQlkaWUoXygiY291bGQgbm90IGNyZWF0ZSBsZWFkaW5nIGRpcmVjdG9yaWVzIG9mICclcyciKSwgZ2l0X2Rpcik7CgoJc2V0X2dpdF9kaXJfaW5pdChnaXRfZGlyLCByZWFsX2dpdF9kaXIsIDApOwoJaWYgKHJlYWxfZ2l0X2RpcikgewoJCWdpdF9kaXIgPSByZWFsX2dpdF9kaXI7CgkJanVua19naXRfZGlyID0gcmVhbF9naXRfZGlyOwoJfQoKCWlmICgwIDw9IG9wdGlvbl92ZXJib3NpdHkpIHsKCQlpZiAob3B0aW9uX2JhcmUpCgkJCWZwcmludGYoc3RkZXJyLCBfKCJDbG9uaW5nIGludG8gYmFyZSByZXBvc2l0b3J5ICclcycuLi5cbiIpLCBkaXIpOwoJCWVsc2UKCQkJZnByaW50ZihzdGRlcnIsIF8oIkNsb25pbmcgaW50byAnJXMnLi4uXG4iKSwgZGlyKTsKCX0KCWluaXRfZGIob3B0aW9uX3RlbXBsYXRlLCBJTklUX0RCX1FVSUVUKTsKCXdyaXRlX2NvbmZpZygmb3B0aW9uX2NvbmZpZyk7CgoJZ2l0X2NvbmZpZyhnaXRfZGVmYXVsdF9jb25maWcsIE5VTEwpOwoKCWlmIChvcHRpb25fYmFyZSkgewoJCWlmIChvcHRpb25fbWlycm9yKQoJCQlzcmNfcmVmX3ByZWZpeCA9ICJyZWZzLyI7CgkJc3RyYnVmX2FkZHN0cigmYnJhbmNoX3RvcCwgc3JjX3JlZl9wcmVmaXgpOwoKCQlnaXRfY29uZmlnX3NldCgiY29yZS5iYXJlIiwgInRydWUiKTsKCX0gZWxzZSB7CgkJc3RyYnVmX2FkZGYoJmJyYW5jaF90b3AsICJyZWZzL3JlbW90ZXMvJXMvIiwgb3B0aW9uX29yaWdpbik7Cgl9CgoJc3RyYnVmX2FkZGYoJnZhbHVlLCAiKyVzKjolcyoiLCBzcmNfcmVmX3ByZWZpeCwgYnJhbmNoX3RvcC5idWYpOwoJc3RyYnVmX2FkZGYoJmtleSwgInJlbW90ZS4lcy51cmwiLCBvcHRpb25fb3JpZ2luKTsKCWdpdF9jb25maWdfc2V0KGtleS5idWYsIHJlcG8pOwoJc3RyYnVmX3Jlc2V0KCZrZXkpOwoKCWlmIChvcHRpb25fcmVmZXJlbmNlLm5yKQoJCXNldHVwX3JlZmVyZW5jZSgpOwoJZWxzZSBpZiAob3B0aW9uX2Rpc3NvY2lhdGUpIHsKCQl3YXJuaW5nKF8oIi0tZGlzc29jaWF0ZSBnaXZlbiwgYnV0IHRoZXJlIGlzIG5vIC0tcmVmZXJlbmNlIikpOwoJCW9wdGlvbl9kaXNzb2NpYXRlID0gMDsKCX0KCglmZXRjaF9wYXR0ZXJuID0gdmFsdWUuYnVmOwoJcmVmc3BlYyA9IHBhcnNlX2ZldGNoX3JlZnNwZWMoMSwgJmZldGNoX3BhdHRlcm4pOwoKCXN0cmJ1Zl9yZXNldCgmdmFsdWUpOwoKCXJlbW90ZSA9IHJlbW90ZV9nZXQob3B0aW9uX29yaWdpbik7Cgl0cmFuc3BvcnQgPSB0cmFuc3BvcnRfZ2V0KHJlbW90ZSwgcmVtb3RlLT51cmxbMF0pOwoJdHJhbnNwb3J0X3NldF92ZXJib3NpdHkodHJhbnNwb3J0LCBvcHRpb25fdmVyYm9zaXR5LCBvcHRpb25fcHJvZ3Jlc3MpOwoKCXBhdGggPSBnZXRfcmVwb19wYXRoKHJlbW90ZS0+dXJsWzBdLCAmaXNfYnVuZGxlKTsKCWlzX2xvY2FsID0gb3B0aW9uX2xvY2FsICE9IDAgJiYgcGF0aCAmJiAhaXNfYnVuZGxlOwoJaWYgKGlzX2xvY2FsKSB7CgkJaWYgKG9wdGlvbl9kZXB0aCkKCQkJd2FybmluZyhfKCItLWRlcHRoIGlzIGlnbm9yZWQgaW4gbG9jYWwgY2xvbmVzOyB1c2UgZmlsZTovLyBpbnN0ZWFkLiIpKTsKCQlpZiAoIWFjY2Vzcyhta3BhdGgoIiVzL3NoYWxsb3ciLCBwYXRoKSwgRl9PSykpIHsKCQkJaWYgKG9wdGlvbl9sb2NhbCA+IDApCgkJCQl3YXJuaW5nKF8oInNvdXJjZSByZXBvc2l0b3J5IGlzIHNoYWxsb3csIGlnbm9yaW5nIC0tbG9jYWwiKSk7CgkJCWlzX2xvY2FsID0gMDsKCQl9Cgl9CglpZiAob3B0aW9uX2xvY2FsID4gMCAmJiAhaXNfbG9jYWwpCgkJd2FybmluZyhfKCItLWxvY2FsIGlzIGlnbm9yZWQiKSk7Cgl0cmFuc3BvcnQtPmNsb25pbmcgPSAxOwoKCWlmICghdHJhbnNwb3J0LT5nZXRfcmVmc19saXN0IHx8ICghaXNfbG9jYWwgJiYgIXRyYW5zcG9ydC0+ZmV0Y2gpKQoJCWRpZShfKCJEb24ndCBrbm93IGhvdyB0byBjbG9uZSAlcyIpLCB0cmFuc3BvcnQtPnVybCk7CgoJdHJhbnNwb3J0X3NldF9vcHRpb24odHJhbnNwb3J0LCBUUkFOU19PUFRfS0VFUCwgInllcyIpOwoKCWlmIChvcHRpb25fZGVwdGgpCgkJdHJhbnNwb3J0X3NldF9vcHRpb24odHJhbnNwb3J0LCBUUkFOU19PUFRfREVQVEgsCgkJCQkgICAgIG9wdGlvbl9kZXB0aCk7CglpZiAob3B0aW9uX3NpbmdsZV9icmFuY2gpCgkJdHJhbnNwb3J0X3NldF9vcHRpb24odHJhbnNwb3J0LCBUUkFOU19PUFRfRk9MTE9XVEFHUywgIjEiKTsKCglpZiAob3B0aW9uX3VwbG9hZF9wYWNrKQoJCXRyYW5zcG9ydF9zZXRfb3B0aW9uKHRyYW5zcG9ydCwgVFJBTlNfT1BUX1VQTE9BRFBBQ0ssCgkJCQkgICAgIG9wdGlvbl91cGxvYWRfcGFjayk7CgoJaWYgKHRyYW5zcG9ydC0+c21hcnRfb3B0aW9ucyAmJiAhb3B0aW9uX2RlcHRoKQoJCXRyYW5zcG9ydC0+c21hcnRfb3B0aW9ucy0+Y2hlY2tfc2VsZl9jb250YWluZWRfYW5kX2Nvbm5lY3RlZCA9IDE7CgoJcmVmcyA9IHRyYW5zcG9ydF9nZXRfcmVtb3RlX3JlZnModHJhbnNwb3J0KTsKCglpZiAocmVmcykgewoJCW1hcHBlZF9yZWZzID0gd2FudGVkX3BlZXJfcmVmcyhyZWZzLCByZWZzcGVjKTsKCQkvKgoJCSAqIHRyYW5zcG9ydF9nZXRfcmVtb3RlX3JlZnMoKSBtYXkgcmV0dXJuIHJlZnMgd2l0aCBudWxsIHNoYS0xCgkJICogaW4gbWFwcGVkX3JlZnMgKHNlZSBzdHJ1Y3QgdHJhbnNwb3J0LT5nZXRfcmVmc19saXN0CgkJICogY29tbWVudCkuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIGZldGNoIGl0IGVhcmx5IGJlY2F1c2UKCQkgKiByZW1vdGVfaGVhZCBjb2RlIGJlbG93IHJlbGllcyBvbiBpdC4KCQkgKgoJCSAqIGZvciBub3JtYWwgY2xvbmVzLCB0cmFuc3BvcnRfZ2V0X3JlbW90ZV9yZWZzKCkgc2hvdWxkCgkJICogcmV0dXJuIHJlbGlhYmxlIHJlZiBzZXQsIHdlIGNhbiBkZWxheSBjbG9uaW5nIHVudGlsIGFmdGVyCgkJICogcmVtb3RlIEhFQUQgY2hlY2suCgkJICovCgkJZm9yIChyZWYgPSByZWZzOyByZWY7IHJlZiA9IHJlZi0+bmV4dCkKCQkJaWYgKGlzX251bGxfc2hhMShyZWYtPm9sZF9zaGExKSkgewoJCQkJY29tcGxldGVfcmVmc19iZWZvcmVfZmV0Y2ggPSAwOwoJCQkJYnJlYWs7CgkJCX0KCgkJaWYgKCFpc19sb2NhbCAmJiAhY29tcGxldGVfcmVmc19iZWZvcmVfZmV0Y2gpCgkJCXRyYW5zcG9ydF9mZXRjaF9yZWZzKHRyYW5zcG9ydCwgbWFwcGVkX3JlZnMpOwoKCQlyZW1vdGVfaGVhZCA9IGZpbmRfcmVmX2J5X25hbWUocmVmcywgIkhFQUQiKTsKCQlyZW1vdGVfaGVhZF9wb2ludHNfYXQgPQoJCQlndWVzc19yZW1vdGVfaGVhZChyZW1vdGVfaGVhZCwgbWFwcGVkX3JlZnMsIDApOwoKCQlpZiAob3B0aW9uX2JyYW5jaCkgewoJCQlvdXJfaGVhZF9wb2ludHNfYXQgPQoJCQkJZmluZF9yZW1vdGVfYnJhbmNoKG1hcHBlZF9yZWZzLCBvcHRpb25fYnJhbmNoKTsKCgkJCWlmICghb3VyX2hlYWRfcG9pbnRzX2F0KQoJCQkJZGllKF8oIlJlbW90ZSBicmFuY2ggJXMgbm90IGZvdW5kIGluIHVwc3RyZWFtICVzIiksCgkJCQkgICAgb3B0aW9uX2JyYW5jaCwgb3B0aW9uX29yaWdpbik7CgkJfQoJCWVsc2UKCQkJb3VyX2hlYWRfcG9pbnRzX2F0ID0gcmVtb3RlX2hlYWRfcG9pbnRzX2F0OwoJfQoJZWxzZSB7CgkJaWYgKG9wdGlvbl9icmFuY2gpCgkJCWRpZShfKCJSZW1vdGUgYnJhbmNoICVzIG5vdCBmb3VuZCBpbiB1cHN0cmVhbSAlcyIpLAoJCQkJCW9wdGlvbl9icmFuY2gsIG9wdGlvbl9vcmlnaW4pOwoKCQl3YXJuaW5nKF8oIllvdSBhcHBlYXIgdG8gaGF2ZSBjbG9uZWQgYW4gZW1wdHkgcmVwb3NpdG9yeS4iKSk7CgkJbWFwcGVkX3JlZnMgPSBOVUxMOwoJCW91cl9oZWFkX3BvaW50c19hdCA9IE5VTEw7CgkJcmVtb3RlX2hlYWRfcG9pbnRzX2F0ID0gTlVMTDsKCQlyZW1vdGVfaGVhZCA9IE5VTEw7CgkJb3B0aW9uX25vX2NoZWNrb3V0ID0gMTsKCQlpZiAoIW9wdGlvbl9iYXJlKQoJCQlpbnN0YWxsX2JyYW5jaF9jb25maWcoMCwgIm1hc3RlciIsIG9wdGlvbl9vcmlnaW4sCgkJCQkJICAgICAgInJlZnMvaGVhZHMvbWFzdGVyIik7Cgl9CgoJd3JpdGVfcmVmc3BlY19jb25maWcoc3JjX3JlZl9wcmVmaXgsIG91cl9oZWFkX3BvaW50c19hdCwKCQkJcmVtb3RlX2hlYWRfcG9pbnRzX2F0LCAmYnJhbmNoX3RvcCk7CgoJaWYgKGlzX2xvY2FsKQoJCWNsb25lX2xvY2FsKHBhdGgsIGdpdF9kaXIpOwoJZWxzZSBpZiAocmVmcyAmJiBjb21wbGV0ZV9yZWZzX2JlZm9yZV9mZXRjaCkKCQl0cmFuc3BvcnRfZmV0Y2hfcmVmcyh0cmFuc3BvcnQsIG1hcHBlZF9yZWZzKTsKCgl1cGRhdGVfcmVtb3RlX3JlZnMocmVmcywgbWFwcGVkX3JlZnMsIHJlbW90ZV9oZWFkX3BvaW50c19hdCwKCQkJICAgYnJhbmNoX3RvcC5idWYsIHJlZmxvZ19tc2cuYnVmLCB0cmFuc3BvcnQsICFpc19sb2NhbCk7CgoJdXBkYXRlX2hlYWQob3VyX2hlYWRfcG9pbnRzX2F0LCByZW1vdGVfaGVhZCwgcmVmbG9nX21zZy5idWYpOwoKCXRyYW5zcG9ydF91bmxvY2tfcGFjayh0cmFuc3BvcnQpOwoJdHJhbnNwb3J0X2Rpc2Nvbm5lY3QodHJhbnNwb3J0KTsKCglpZiAob3B0aW9uX2Rpc3NvY2lhdGUpCgkJZGlzc29jaWF0ZV9mcm9tX3JlZmVyZW5jZXMoKTsKCglqdW5rX21vZGUgPSBKVU5LX0xFQVZFX1JFUE87CgllcnIgPSBjaGVja291dCgpOwoKCXN0cmJ1Zl9yZWxlYXNlKCZyZWZsb2dfbXNnKTsKCXN0cmJ1Zl9yZWxlYXNlKCZicmFuY2hfdG9wKTsKCXN0cmJ1Zl9yZWxlYXNlKCZrZXkpOwoJc3RyYnVmX3JlbGVhc2UoJnZhbHVlKTsKCWp1bmtfbW9kZSA9IEpVTktfTEVBVkVfQUxMOwoKCWZyZWUocmVmc3BlYyk7CglyZXR1cm4gZXJyOwp9Cg==",
    "text": "/*\n * Builtin \"git clone\"\n *\n * Copyright (c) 2007 Kristian H\u00f8gsberg <krh@redhat.com>,\n *\t\t 2008 Daniel Barkalow <barkalow@iabervon.org>\n * Based on git-commit.sh by Junio C Hamano and Linus Torvalds\n *\n * Clone a repository into a different directory that does not yet exist.\n */\n\n#include \"builtin.h\"\n#include \"lockfile.h\"\n#include \"parse-options.h\"\n#include \"fetch-pack.h\"\n#include \"refs.h\"\n#include \"tree.h\"\n#include \"tree-walk.h\"\n#include \"unpack-trees.h\"\n#include \"transport.h\"\n#include \"strbuf.h\"\n#include \"dir.h\"\n#include \"sigchain.h\"\n#include \"branch.h\"\n#include \"remote.h\"\n#include \"run-command.h\"\n#include \"connected.h\"\n\n/*\n * Overall FIXMEs:\n *  - respect DB_ENVIRONMENT for .git/objects.\n *\n * Implementation notes:\n *  - dropping use-separate-remote and no-separate-remote compatibility\n *\n */\nstatic const char * const builtin_clone_usage[] = {\n\tN_(\"git clone [<options>] [--] <repo> [<dir>]\"),\n\tNULL\n};\n\nstatic int option_no_checkout, option_bare, option_mirror, option_single_branch = -1;\nstatic int option_local = -1, option_no_hardlinks, option_shared, option_recursive;\nstatic char *option_template, *option_depth;\nstatic char *option_origin = NULL;\nstatic char *option_branch = NULL;\nstatic const char *real_git_dir;\nstatic char *option_upload_pack = \"git-upload-pack\";\nstatic int option_verbosity;\nstatic int option_progress = -1;\nstatic struct string_list option_config;\nstatic struct string_list option_reference;\nstatic int option_dissociate;\n\nstatic struct option builtin_clone_options[] = {\n\tOPT__VERBOSITY(&option_verbosity),\n\tOPT_BOOL(0, \"progress\", &option_progress,\n\t\t N_(\"force progress reporting\")),\n\tOPT_BOOL('n', \"no-checkout\", &option_no_checkout,\n\t\t N_(\"don't create a checkout\")),\n\tOPT_BOOL(0, \"bare\", &option_bare, N_(\"create a bare repository\")),\n\tOPT_HIDDEN_BOOL(0, \"naked\", &option_bare,\n\t\t\tN_(\"create a bare repository\")),\n\tOPT_BOOL(0, \"mirror\", &option_mirror,\n\t\t N_(\"create a mirror repository (implies bare)\")),\n\tOPT_BOOL('l', \"local\", &option_local,\n\t\tN_(\"to clone from a local repository\")),\n\tOPT_BOOL(0, \"no-hardlinks\", &option_no_hardlinks,\n\t\t    N_(\"don't use local hardlinks, always copy\")),\n\tOPT_BOOL('s', \"shared\", &option_shared,\n\t\t    N_(\"setup as shared repository\")),\n\tOPT_BOOL(0, \"recursive\", &option_recursive,\n\t\t    N_(\"initialize submodules in the clone\")),\n\tOPT_BOOL(0, \"recurse-submodules\", &option_recursive,\n\t\t    N_(\"initialize submodules in the clone\")),\n\tOPT_STRING(0, \"template\", &option_template, N_(\"template-directory\"),\n\t\t   N_(\"directory from which templates will be used\")),\n\tOPT_STRING_LIST(0, \"reference\", &option_reference, N_(\"repo\"),\n\t\t\tN_(\"reference repository\")),\n\tOPT_BOOL(0, \"dissociate\", &option_dissociate,\n\t\t N_(\"use --reference only while cloning\")),\n\tOPT_STRING('o', \"origin\", &option_origin, N_(\"name\"),\n\t\t   N_(\"use <name> instead of 'origin' to track upstream\")),\n\tOPT_STRING('b', \"branch\", &option_branch, N_(\"branch\"),\n\t\t   N_(\"checkout <branch> instead of the remote's HEAD\")),\n\tOPT_STRING('u', \"upload-pack\", &option_upload_pack, N_(\"path\"),\n\t\t   N_(\"path to git-upload-pack on the remote\")),\n\tOPT_STRING(0, \"depth\", &option_depth, N_(\"depth\"),\n\t\t    N_(\"create a shallow clone of that depth\")),\n\tOPT_BOOL(0, \"single-branch\", &option_single_branch,\n\t\t    N_(\"clone only one branch, HEAD or --branch\")),\n\tOPT_STRING(0, \"separate-git-dir\", &real_git_dir, N_(\"gitdir\"),\n\t\t   N_(\"separate git dir from working tree\")),\n\tOPT_STRING_LIST('c', \"config\", &option_config, N_(\"key=value\"),\n\t\t\tN_(\"set config inside the new repository\")),\n\tOPT_END()\n};\n\nstatic const char *argv_submodule[] = {\n\t\"submodule\", \"update\", \"--init\", \"--recursive\", NULL\n};\n\nstatic char *get_repo_path(const char *repo, int *is_bundle)\n{\n\tstatic char *suffix[] = { \"/.git\", \"\", \".git/.git\", \".git\" };\n\tstatic char *bundle_suffix[] = { \".bundle\", \"\" };\n\tstruct stat st;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(suffix); i++) {\n\t\tconst char *path;\n\t\tpath = mkpath(\"%s%s\", repo, suffix[i]);\n\t\tif (stat(path, &st))\n\t\t\tcontinue;\n\t\tif (S_ISDIR(st.st_mode) && is_git_directory(path)) {\n\t\t\t*is_bundle = 0;\n\t\t\treturn xstrdup(absolute_path(path));\n\t\t} else if (S_ISREG(st.st_mode) && st.st_size > 8) {\n\t\t\t/* Is it a \"gitfile\"? */\n\t\t\tchar signature[8];\n\t\t\tint len, fd = open(path, O_RDONLY);\n\t\t\tif (fd < 0)\n\t\t\t\tcontinue;\n\t\t\tlen = read_in_full(fd, signature, 8);\n\t\t\tclose(fd);\n\t\t\tif (len != 8 || strncmp(signature, \"gitdir: \", 8))\n\t\t\t\tcontinue;\n\t\t\tpath = read_gitfile(path);\n\t\t\tif (path) {\n\t\t\t\t*is_bundle = 0;\n\t\t\t\treturn xstrdup(absolute_path(path));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(bundle_suffix); i++) {\n\t\tconst char *path;\n\t\tpath = mkpath(\"%s%s\", repo, bundle_suffix[i]);\n\t\tif (!stat(path, &st) && S_ISREG(st.st_mode)) {\n\t\t\t*is_bundle = 1;\n\t\t\treturn xstrdup(absolute_path(path));\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic char *guess_dir_name(const char *repo, int is_bundle, int is_bare)\n{\n\tconst char *end = repo + strlen(repo), *start;\n\tchar *dir;\n\n\t/*\n\t * Strip trailing spaces, slashes and /.git\n\t */\n\twhile (repo < end && (is_dir_sep(end[-1]) || isspace(end[-1])))\n\t\tend--;\n\tif (end - repo > 5 && is_dir_sep(end[-5]) &&\n\t    !strncmp(end - 4, \".git\", 4)) {\n\t\tend -= 5;\n\t\twhile (repo < end && is_dir_sep(end[-1]))\n\t\t\tend--;\n\t}\n\n\t/*\n\t * Find last component, but be prepared that repo could have\n\t * the form  \"remote.example.com:foo.git\", i.e. no slash\n\t * in the directory part.\n\t */\n\tstart = end;\n\twhile (repo < start && !is_dir_sep(start[-1]) && start[-1] != ':')\n\t\tstart--;\n\n\t/*\n\t * Strip .{bundle,git}.\n\t */\n\tif (is_bundle) {\n\t\tif (end - start > 7 && !strncmp(end - 7, \".bundle\", 7))\n\t\t\tend -= 7;\n\t} else {\n\t\tif (end - start > 4 && !strncmp(end - 4, \".git\", 4))\n\t\t\tend -= 4;\n\t}\n\n\tif (is_bare) {\n\t\tstruct strbuf result = STRBUF_INIT;\n\t\tstrbuf_addf(&result, \"%.*s.git\", (int)(end - start), start);\n\t\tdir = strbuf_detach(&result, NULL);\n\t} else\n\t\tdir = xstrndup(start, end - start);\n\t/*\n\t * Replace sequences of 'control' characters and whitespace\n\t * with one ascii space, remove leading and trailing spaces.\n\t */\n\tif (*dir) {\n\t\tchar *out = dir;\n\t\tint prev_space = 1 /* strip leading whitespace */;\n\t\tfor (end = dir; *end; ++end) {\n\t\t\tchar ch = *end;\n\t\t\tif ((unsigned char)ch < '\\x20')\n\t\t\t\tch = '\\x20';\n\t\t\tif (isspace(ch)) {\n\t\t\t\tif (prev_space)\n\t\t\t\t\tcontinue;\n\t\t\t\tprev_space = 1;\n\t\t\t} else\n\t\t\t\tprev_space = 0;\n\t\t\t*out++ = ch;\n\t\t}\n\t\t*out = '\\0';\n\t\tif (out > dir && prev_space)\n\t\t\tout[-1] = '\\0';\n\t}\n\treturn dir;\n}\n\nstatic void strip_trailing_slashes(char *dir)\n{\n\tchar *end = dir + strlen(dir);\n\n\twhile (dir < end - 1 && is_dir_sep(end[-1]))\n\t\tend--;\n\t*end = '\\0';\n}\n\nstatic int add_one_reference(struct string_list_item *item, void *cb_data)\n{\n\tchar *ref_git;\n\tconst char *repo;\n\tstruct strbuf alternate = STRBUF_INIT;\n\n\t/* Beware: read_gitfile(), real_path() and mkpath() return static buffer */\n\tref_git = xstrdup(real_path(item->string));\n\n\trepo = read_gitfile(ref_git);\n\tif (!repo)\n\t\trepo = read_gitfile(mkpath(\"%s/.git\", ref_git));\n\tif (repo) {\n\t\tfree(ref_git);\n\t\tref_git = xstrdup(repo);\n\t}\n\n\tif (!repo && is_directory(mkpath(\"%s/.git/objects\", ref_git))) {\n\t\tchar *ref_git_git = mkpathdup(\"%s/.git\", ref_git);\n\t\tfree(ref_git);\n\t\tref_git = ref_git_git;\n\t} else if (!is_directory(mkpath(\"%s/objects\", ref_git)))\n\t\tdie(_(\"reference repository '%s' is not a local repository.\"),\n\t\t    item->string);\n\n\tif (!access(mkpath(\"%s/shallow\", ref_git), F_OK))\n\t\tdie(_(\"reference repository '%s' is shallow\"), item->string);\n\n\tif (!access(mkpath(\"%s/info/grafts\", ref_git), F_OK))\n\t\tdie(_(\"reference repository '%s' is grafted\"), item->string);\n\n\tstrbuf_addf(&alternate, \"%s/objects\", ref_git);\n\tadd_to_alternates_file(alternate.buf);\n\tstrbuf_release(&alternate);\n\tfree(ref_git);\n\treturn 0;\n}\n\nstatic void setup_reference(void)\n{\n\tfor_each_string_list(&option_reference, add_one_reference, NULL);\n}\n\nstatic void copy_alternates(struct strbuf *src, struct strbuf *dst,\n\t\t\t    const char *src_repo)\n{\n\t/*\n\t * Read from the source objects/info/alternates file\n\t * and copy the entries to corresponding file in the\n\t * destination repository with add_to_alternates_file().\n\t * Both src and dst have \"$path/objects/info/alternates\".\n\t *\n\t * Instead of copying bit-for-bit from the original,\n\t * we need to append to existing one so that the already\n\t * created entry via \"clone -s\" is not lost, and also\n\t * to turn entries with paths relative to the original\n\t * absolute, so that they can be used in the new repository.\n\t */\n\tFILE *in = fopen(src->buf, \"r\");\n\tstruct strbuf line = STRBUF_INIT;\n\n\twhile (strbuf_getline(&line, in, '\\n') != EOF) {\n\t\tchar *abs_path;\n\t\tif (!line.len || line.buf[0] == '#')\n\t\t\tcontinue;\n\t\tif (is_absolute_path(line.buf)) {\n\t\t\tadd_to_alternates_file(line.buf);\n\t\t\tcontinue;\n\t\t}\n\t\tabs_path = mkpathdup(\"%s/objects/%s\", src_repo, line.buf);\n\t\tnormalize_path_copy(abs_path, abs_path);\n\t\tadd_to_alternates_file(abs_path);\n\t\tfree(abs_path);\n\t}\n\tstrbuf_release(&line);\n\tfclose(in);\n}\n\nstatic void copy_or_link_directory(struct strbuf *src, struct strbuf *dest,\n\t\t\t\t   const char *src_repo, int src_baselen)\n{\n\tstruct dirent *de;\n\tstruct stat buf;\n\tint src_len, dest_len;\n\tDIR *dir;\n\n\tdir = opendir(src->buf);\n\tif (!dir)\n\t\tdie_errno(_(\"failed to open '%s'\"), src->buf);\n\n\tif (mkdir(dest->buf, 0777)) {\n\t\tif (errno != EEXIST)\n\t\t\tdie_errno(_(\"failed to create directory '%s'\"), dest->buf);\n\t\telse if (stat(dest->buf, &buf))\n\t\t\tdie_errno(_(\"failed to stat '%s'\"), dest->buf);\n\t\telse if (!S_ISDIR(buf.st_mode))\n\t\t\tdie(_(\"%s exists and is not a directory\"), dest->buf);\n\t}\n\n\tstrbuf_addch(src, '/');\n\tsrc_len = src->len;\n\tstrbuf_addch(dest, '/');\n\tdest_len = dest->len;\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tstrbuf_setlen(src, src_len);\n\t\tstrbuf_addstr(src, de->d_name);\n\t\tstrbuf_setlen(dest, dest_len);\n\t\tstrbuf_addstr(dest, de->d_name);\n\t\tif (stat(src->buf, &buf)) {\n\t\t\twarning (_(\"failed to stat %s\\n\"), src->buf);\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(buf.st_mode)) {\n\t\t\tif (de->d_name[0] != '.')\n\t\t\t\tcopy_or_link_directory(src, dest,\n\t\t\t\t\t\t       src_repo, src_baselen);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Files that cannot be copied bit-for-bit... */\n\t\tif (!strcmp(src->buf + src_baselen, \"/info/alternates\")) {\n\t\t\tcopy_alternates(src, dest, src_repo);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlink(dest->buf) && errno != ENOENT)\n\t\t\tdie_errno(_(\"failed to unlink '%s'\"), dest->buf);\n\t\tif (!option_no_hardlinks) {\n\t\t\tif (!link(src->buf, dest->buf))\n\t\t\t\tcontinue;\n\t\t\tif (option_local > 0)\n\t\t\t\tdie_errno(_(\"failed to create link '%s'\"), dest->buf);\n\t\t\toption_no_hardlinks = 1;\n\t\t}\n\t\tif (copy_file_with_time(dest->buf, src->buf, 0666))\n\t\t\tdie_errno(_(\"failed to copy file to '%s'\"), dest->buf);\n\t}\n\tclosedir(dir);\n}\n\nstatic void clone_local(const char *src_repo, const char *dest_repo)\n{\n\tif (option_shared) {\n\t\tstruct strbuf alt = STRBUF_INIT;\n\t\tstrbuf_addf(&alt, \"%s/objects\", src_repo);\n\t\tadd_to_alternates_file(alt.buf);\n\t\tstrbuf_release(&alt);\n\t} else {\n\t\tstruct strbuf src = STRBUF_INIT;\n\t\tstruct strbuf dest = STRBUF_INIT;\n\t\tstrbuf_addf(&src, \"%s/objects\", src_repo);\n\t\tstrbuf_addf(&dest, \"%s/objects\", dest_repo);\n\t\tcopy_or_link_directory(&src, &dest, src_repo, src.len);\n\t\tstrbuf_release(&src);\n\t\tstrbuf_release(&dest);\n\t}\n\n\tif (0 <= option_verbosity)\n\t\tfprintf(stderr, _(\"done.\\n\"));\n}\n\nstatic const char *junk_work_tree;\nstatic const char *junk_git_dir;\nstatic enum {\n\tJUNK_LEAVE_NONE,\n\tJUNK_LEAVE_REPO,\n\tJUNK_LEAVE_ALL\n} junk_mode = JUNK_LEAVE_NONE;\n\nstatic const char junk_leave_repo_msg[] =\nN_(\"Clone succeeded, but checkout failed.\\n\"\n   \"You can inspect what was checked out with 'git status'\\n\"\n   \"and retry the checkout with 'git checkout -f HEAD'\\n\");\n\nstatic void remove_junk(void)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tswitch (junk_mode) {\n\tcase JUNK_LEAVE_REPO:\n\t\twarning(\"%s\", _(junk_leave_repo_msg));\n\t\t/* fall-through */\n\tcase JUNK_LEAVE_ALL:\n\t\treturn;\n\tdefault:\n\t\t/* proceed to removal */\n\t\tbreak;\n\t}\n\n\tif (junk_git_dir) {\n\t\tstrbuf_addstr(&sb, junk_git_dir);\n\t\tremove_dir_recursively(&sb, 0);\n\t\tstrbuf_reset(&sb);\n\t}\n\tif (junk_work_tree) {\n\t\tstrbuf_addstr(&sb, junk_work_tree);\n\t\tremove_dir_recursively(&sb, 0);\n\t\tstrbuf_reset(&sb);\n\t}\n}\n\nstatic void remove_junk_on_signal(int signo)\n{\n\tremove_junk();\n\tsigchain_pop(signo);\n\traise(signo);\n}\n\nstatic struct ref *find_remote_branch(const struct ref *refs, const char *branch)\n{\n\tstruct ref *ref;\n\tstruct strbuf head = STRBUF_INIT;\n\tstrbuf_addstr(&head, \"refs/heads/\");\n\tstrbuf_addstr(&head, branch);\n\tref = find_ref_by_name(refs, head.buf);\n\tstrbuf_release(&head);\n\n\tif (ref)\n\t\treturn ref;\n\n\tstrbuf_addstr(&head, \"refs/tags/\");\n\tstrbuf_addstr(&head, branch);\n\tref = find_ref_by_name(refs, head.buf);\n\tstrbuf_release(&head);\n\n\treturn ref;\n}\n\nstatic struct ref *wanted_peer_refs(const struct ref *refs,\n\t\tstruct refspec *refspec)\n{\n\tstruct ref *head = copy_ref(find_ref_by_name(refs, \"HEAD\"));\n\tstruct ref *local_refs = head;\n\tstruct ref **tail = head ? &head->next : &local_refs;\n\n\tif (option_single_branch) {\n\t\tstruct ref *remote_head = NULL;\n\n\t\tif (!option_branch)\n\t\t\tremote_head = guess_remote_head(head, refs, 0);\n\t\telse {\n\t\t\tlocal_refs = NULL;\n\t\t\ttail = &local_refs;\n\t\t\tremote_head = copy_ref(find_remote_branch(refs, option_branch));\n\t\t}\n\n\t\tif (!remote_head && option_branch)\n\t\t\twarning(_(\"Could not find remote branch %s to clone.\"),\n\t\t\t\toption_branch);\n\t\telse {\n\t\t\tget_fetch_map(remote_head, refspec, &tail, 0);\n\n\t\t\t/* if --branch=tag, pull the requested tag explicitly */\n\t\t\tget_fetch_map(remote_head, tag_refspec, &tail, 0);\n\t\t}\n\t} else\n\t\tget_fetch_map(refs, refspec, &tail, 0);\n\n\tif (!option_mirror && !option_single_branch)\n\t\tget_fetch_map(refs, tag_refspec, &tail, 0);\n\n\treturn local_refs;\n}\n\nstatic void write_remote_refs(const struct ref *local_refs)\n{\n\tconst struct ref *r;\n\n\tlock_packed_refs(LOCK_DIE_ON_ERROR);\n\n\tfor (r = local_refs; r; r = r->next) {\n\t\tif (!r->peer_ref)\n\t\t\tcontinue;\n\t\tadd_packed_ref(r->peer_ref->name, r->old_sha1);\n\t}\n\n\tif (commit_packed_refs())\n\t\tdie_errno(\"unable to overwrite old ref-pack file\");\n}\n\nstatic void write_followtags(const struct ref *refs, const char *msg)\n{\n\tconst struct ref *ref;\n\tfor (ref = refs; ref; ref = ref->next) {\n\t\tif (!starts_with(ref->name, \"refs/tags/\"))\n\t\t\tcontinue;\n\t\tif (ends_with(ref->name, \"^{}\"))\n\t\t\tcontinue;\n\t\tif (!has_sha1_file(ref->old_sha1))\n\t\t\tcontinue;\n\t\tupdate_ref(msg, ref->name, ref->old_sha1,\n\t\t\t   NULL, 0, UPDATE_REFS_DIE_ON_ERR);\n\t}\n}\n\nstatic int iterate_ref_map(void *cb_data, unsigned char sha1[20])\n{\n\tstruct ref **rm = cb_data;\n\tstruct ref *ref = *rm;\n\n\t/*\n\t * Skip anything missing a peer_ref, which we are not\n\t * actually going to write a ref for.\n\t */\n\twhile (ref && !ref->peer_ref)\n\t\tref = ref->next;\n\t/* Returning -1 notes \"end of list\" to the caller. */\n\tif (!ref)\n\t\treturn -1;\n\n\thashcpy(sha1, ref->old_sha1);\n\t*rm = ref->next;\n\treturn 0;\n}\n\nstatic void update_remote_refs(const struct ref *refs,\n\t\t\t       const struct ref *mapped_refs,\n\t\t\t       const struct ref *remote_head_points_at,\n\t\t\t       const char *branch_top,\n\t\t\t       const char *msg,\n\t\t\t       struct transport *transport,\n\t\t\t       int check_connectivity)\n{\n\tconst struct ref *rm = mapped_refs;\n\n\tif (check_connectivity) {\n\t\tif (transport->progress)\n\t\t\tfprintf(stderr, _(\"Checking connectivity... \"));\n\t\tif (check_everything_connected_with_transport(iterate_ref_map,\n\t\t\t\t\t\t\t      0, &rm, transport))\n\t\t\tdie(_(\"remote did not send all necessary objects\"));\n\t\tif (transport->progress)\n\t\t\tfprintf(stderr, _(\"done.\\n\"));\n\t}\n\n\tif (refs) {\n\t\twrite_remote_refs(mapped_refs);\n\t\tif (option_single_branch)\n\t\t\twrite_followtags(refs, msg);\n\t}\n\n\tif (remote_head_points_at && !option_bare) {\n\t\tstruct strbuf head_ref = STRBUF_INIT;\n\t\tstrbuf_addstr(&head_ref, branch_top);\n\t\tstrbuf_addstr(&head_ref, \"HEAD\");\n\t\tcreate_symref(head_ref.buf,\n\t\t\t      remote_head_points_at->peer_ref->name,\n\t\t\t      msg);\n\t}\n}\n\nstatic void update_head(const struct ref *our, const struct ref *remote,\n\t\t\tconst char *msg)\n{\n\tconst char *head;\n\tif (our && skip_prefix(our->name, \"refs/heads/\", &head)) {\n\t\t/* Local default branch link */\n\t\tcreate_symref(\"HEAD\", our->name, NULL);\n\t\tif (!option_bare) {\n\t\t\tupdate_ref(msg, \"HEAD\", our->old_sha1, NULL, 0,\n\t\t\t\t   UPDATE_REFS_DIE_ON_ERR);\n\t\t\tinstall_branch_config(0, head, option_origin, our->name);\n\t\t}\n\t} else if (our) {\n\t\tstruct commit *c = lookup_commit_reference(our->old_sha1);\n\t\t/* --branch specifies a non-branch (i.e. tags), detach HEAD */\n\t\tupdate_ref(msg, \"HEAD\", c->object.sha1,\n\t\t\t   NULL, REF_NODEREF, UPDATE_REFS_DIE_ON_ERR);\n\t} else if (remote) {\n\t\t/*\n\t\t * We know remote HEAD points to a non-branch, or\n\t\t * HEAD points to a branch but we don't know which one.\n\t\t * Detach HEAD in all these cases.\n\t\t */\n\t\tupdate_ref(msg, \"HEAD\", remote->old_sha1,\n\t\t\t   NULL, REF_NODEREF, UPDATE_REFS_DIE_ON_ERR);\n\t}\n}\n\nstatic int checkout(void)\n{\n\tunsigned char sha1[20];\n\tchar *head;\n\tstruct lock_file *lock_file;\n\tstruct unpack_trees_options opts;\n\tstruct tree *tree;\n\tstruct tree_desc t;\n\tint err = 0;\n\n\tif (option_no_checkout)\n\t\treturn 0;\n\n\thead = resolve_refdup(\"HEAD\", RESOLVE_REF_READING, sha1, NULL);\n\tif (!head) {\n\t\twarning(_(\"remote HEAD refers to nonexistent ref, \"\n\t\t\t  \"unable to checkout.\\n\"));\n\t\treturn 0;\n\t}\n\tif (!strcmp(head, \"HEAD\")) {\n\t\tif (advice_detached_head)\n\t\t\tdetach_advice(sha1_to_hex(sha1));\n\t} else {\n\t\tif (!starts_with(head, \"refs/heads/\"))\n\t\t\tdie(_(\"HEAD not found below refs/heads!\"));\n\t}\n\tfree(head);\n\n\t/* We need to be in the new work tree for the checkout */\n\tsetup_work_tree();\n\n\tlock_file = xcalloc(1, sizeof(struct lock_file));\n\thold_locked_index(lock_file, 1);\n\n\tmemset(&opts, 0, sizeof opts);\n\topts.update = 1;\n\topts.merge = 1;\n\topts.fn = oneway_merge;\n\topts.verbose_update = (option_verbosity >= 0);\n\topts.src_index = &the_index;\n\topts.dst_index = &the_index;\n\n\ttree = parse_tree_indirect(sha1);\n\tparse_tree(tree);\n\tinit_tree_desc(&t, tree->buffer, tree->size);\n\tif (unpack_trees(1, &t, &opts) < 0)\n\t\tdie(_(\"unable to checkout working tree\"));\n\n\tif (write_locked_index(&the_index, lock_file, COMMIT_LOCK))\n\t\tdie(_(\"unable to write new index file\"));\n\n\terr |= run_hook_le(NULL, \"post-checkout\", sha1_to_hex(null_sha1),\n\t\t\t   sha1_to_hex(sha1), \"1\", NULL);\n\n\tif (!err && option_recursive)\n\t\terr = run_command_v_opt(argv_submodule, RUN_GIT_CMD);\n\n\treturn err;\n}\n\nstatic int write_one_config(const char *key, const char *value, void *data)\n{\n\treturn git_config_set_multivar(key, value ? value : \"true\", \"^$\", 0);\n}\n\nstatic void write_config(struct string_list *config)\n{\n\tint i;\n\n\tfor (i = 0; i < config->nr; i++) {\n\t\tif (git_config_parse_parameter(config->items[i].string,\n\t\t\t\t\t       write_one_config, NULL) < 0)\n\t\t\tdie(\"unable to write parameters to config file\");\n\t}\n}\n\nstatic void write_refspec_config(const char *src_ref_prefix,\n\t\tconst struct ref *our_head_points_at,\n\t\tconst struct ref *remote_head_points_at,\n\t\tstruct strbuf *branch_top)\n{\n\tstruct strbuf key = STRBUF_INIT;\n\tstruct strbuf value = STRBUF_INIT;\n\n\tif (option_mirror || !option_bare) {\n\t\tif (option_single_branch && !option_mirror) {\n\t\t\tif (option_branch) {\n\t\t\t\tif (starts_with(our_head_points_at->name, \"refs/tags/\"))\n\t\t\t\t\tstrbuf_addf(&value, \"+%s:%s\", our_head_points_at->name,\n\t\t\t\t\t\tour_head_points_at->name);\n\t\t\t\telse\n\t\t\t\t\tstrbuf_addf(&value, \"+%s:%s%s\", our_head_points_at->name,\n\t\t\t\t\t\tbranch_top->buf, option_branch);\n\t\t\t} else if (remote_head_points_at) {\n\t\t\t\tconst char *head = remote_head_points_at->name;\n\t\t\t\tif (!skip_prefix(head, \"refs/heads/\", &head))\n\t\t\t\t\tdie(\"BUG: remote HEAD points at non-head?\");\n\n\t\t\t\tstrbuf_addf(&value, \"+%s:%s%s\", remote_head_points_at->name,\n\t\t\t\t\t\tbranch_top->buf, head);\n\t\t\t}\n\t\t\t/*\n\t\t\t * otherwise, the next \"git fetch\" will\n\t\t\t * simply fetch from HEAD without updating\n\t\t\t * any remote-tracking branch, which is what\n\t\t\t * we want.\n\t\t\t */\n\t\t} else {\n\t\t\tstrbuf_addf(&value, \"+%s*:%s*\", src_ref_prefix, branch_top->buf);\n\t\t}\n\t\t/* Configure the remote */\n\t\tif (value.len) {\n\t\t\tstrbuf_addf(&key, \"remote.%s.fetch\", option_origin);\n\t\t\tgit_config_set_multivar(key.buf, value.buf, \"^$\", 0);\n\t\t\tstrbuf_reset(&key);\n\n\t\t\tif (option_mirror) {\n\t\t\t\tstrbuf_addf(&key, \"remote.%s.mirror\", option_origin);\n\t\t\t\tgit_config_set(key.buf, \"true\");\n\t\t\t\tstrbuf_reset(&key);\n\t\t\t}\n\t\t}\n\t}\n\n\tstrbuf_release(&key);\n\tstrbuf_release(&value);\n}\n\nstatic void dissociate_from_references(void)\n{\n\tstatic const char* argv[] = { \"repack\", \"-a\", \"-d\", NULL };\n\n\tif (run_command_v_opt(argv, RUN_GIT_CMD|RUN_COMMAND_NO_STDIN))\n\t\tdie(_(\"cannot repack to clean up\"));\n\tif (unlink(git_path(\"objects/info/alternates\")) && errno != ENOENT)\n\t\tdie_errno(_(\"cannot unlink temporary alternates file\"));\n}\n\nint cmd_clone(int argc, const char **argv, const char *prefix)\n{\n\tint is_bundle = 0, is_local;\n\tstruct stat buf;\n\tconst char *repo_name, *repo, *work_tree, *git_dir;\n\tchar *path, *dir;\n\tint dest_exists;\n\tconst struct ref *refs, *remote_head;\n\tconst struct ref *remote_head_points_at;\n\tconst struct ref *our_head_points_at;\n\tstruct ref *mapped_refs;\n\tconst struct ref *ref;\n\tstruct strbuf key = STRBUF_INIT, value = STRBUF_INIT;\n\tstruct strbuf branch_top = STRBUF_INIT, reflog_msg = STRBUF_INIT;\n\tstruct transport *transport = NULL;\n\tconst char *src_ref_prefix = \"refs/heads/\";\n\tstruct remote *remote;\n\tint err = 0, complete_refs_before_fetch = 1;\n\n\tstruct refspec *refspec;\n\tconst char *fetch_pattern;\n\n\tpacket_trace_identity(\"clone\");\n\targc = parse_options(argc, argv, prefix, builtin_clone_options,\n\t\t\t     builtin_clone_usage, 0);\n\n\tif (argc > 2)\n\t\tusage_msg_opt(_(\"Too many arguments.\"),\n\t\t\tbuiltin_clone_usage, builtin_clone_options);\n\n\tif (argc == 0)\n\t\tusage_msg_opt(_(\"You must specify a repository to clone.\"),\n\t\t\tbuiltin_clone_usage, builtin_clone_options);\n\n\tif (option_single_branch == -1)\n\t\toption_single_branch = option_depth ? 1 : 0;\n\n\tif (option_mirror)\n\t\toption_bare = 1;\n\n\tif (option_bare) {\n\t\tif (option_origin)\n\t\t\tdie(_(\"--bare and --origin %s options are incompatible.\"),\n\t\t\t    option_origin);\n\t\tif (real_git_dir)\n\t\t\tdie(_(\"--bare and --separate-git-dir are incompatible.\"));\n\t\toption_no_checkout = 1;\n\t}\n\n\tif (!option_origin)\n\t\toption_origin = \"origin\";\n\n\trepo_name = argv[0];\n\n\tpath = get_repo_path(repo_name, &is_bundle);\n\tif (path)\n\t\trepo = xstrdup(absolute_path(repo_name));\n\telse if (!strchr(repo_name, ':'))\n\t\tdie(_(\"repository '%s' does not exist\"), repo_name);\n\telse\n\t\trepo = repo_name;\n\n\t/* no need to be strict, transport_set_option() will validate it again */\n\tif (option_depth && atoi(option_depth) < 1)\n\t\tdie(_(\"depth %s is not a positive number\"), option_depth);\n\n\tif (argc == 2)\n\t\tdir = xstrdup(argv[1]);\n\telse\n\t\tdir = guess_dir_name(repo_name, is_bundle, option_bare);\n\tstrip_trailing_slashes(dir);\n\n\tdest_exists = !stat(dir, &buf);\n\tif (dest_exists && !is_empty_dir(dir))\n\t\tdie(_(\"destination path '%s' already exists and is not \"\n\t\t\t\"an empty directory.\"), dir);\n\n\tstrbuf_addf(&reflog_msg, \"clone: from %s\", repo);\n\n\tif (option_bare)\n\t\twork_tree = NULL;\n\telse {\n\t\twork_tree = getenv(\"GIT_WORK_TREE\");\n\t\tif (work_tree && !stat(work_tree, &buf))\n\t\t\tdie(_(\"working tree '%s' already exists.\"), work_tree);\n\t}\n\n\tif (option_bare || work_tree)\n\t\tgit_dir = xstrdup(dir);\n\telse {\n\t\twork_tree = dir;\n\t\tgit_dir = mkpathdup(\"%s/.git\", dir);\n\t}\n\n\tatexit(remove_junk);\n\tsigchain_push_common(remove_junk_on_signal);\n\n\tif (!option_bare) {\n\t\tif (safe_create_leading_directories_const(work_tree) < 0)\n\t\t\tdie_errno(_(\"could not create leading directories of '%s'\"),\n\t\t\t\t  work_tree);\n\t\tif (!dest_exists && mkdir(work_tree, 0777))\n\t\t\tdie_errno(_(\"could not create work tree dir '%s'\"),\n\t\t\t\t  work_tree);\n\t\tjunk_work_tree = work_tree;\n\t\tset_git_work_tree(work_tree);\n\t}\n\n\tjunk_git_dir = git_dir;\n\tif (safe_create_leading_directories_const(git_dir) < 0)\n\t\tdie(_(\"could not create leading directories of '%s'\"), git_dir);\n\n\tset_git_dir_init(git_dir, real_git_dir, 0);\n\tif (real_git_dir) {\n\t\tgit_dir = real_git_dir;\n\t\tjunk_git_dir = real_git_dir;\n\t}\n\n\tif (0 <= option_verbosity) {\n\t\tif (option_bare)\n\t\t\tfprintf(stderr, _(\"Cloning into bare repository '%s'...\\n\"), dir);\n\t\telse\n\t\t\tfprintf(stderr, _(\"Cloning into '%s'...\\n\"), dir);\n\t}\n\tinit_db(option_template, INIT_DB_QUIET);\n\twrite_config(&option_config);\n\n\tgit_config(git_default_config, NULL);\n\n\tif (option_bare) {\n\t\tif (option_mirror)\n\t\t\tsrc_ref_prefix = \"refs/\";\n\t\tstrbuf_addstr(&branch_top, src_ref_prefix);\n\n\t\tgit_config_set(\"core.bare\", \"true\");\n\t} else {\n\t\tstrbuf_addf(&branch_top, \"refs/remotes/%s/\", option_origin);\n\t}\n\n\tstrbuf_addf(&value, \"+%s*:%s*\", src_ref_prefix, branch_top.buf);\n\tstrbuf_addf(&key, \"remote.%s.url\", option_origin);\n\tgit_config_set(key.buf, repo);\n\tstrbuf_reset(&key);\n\n\tif (option_reference.nr)\n\t\tsetup_reference();\n\telse if (option_dissociate) {\n\t\twarning(_(\"--dissociate given, but there is no --reference\"));\n\t\toption_dissociate = 0;\n\t}\n\n\tfetch_pattern = value.buf;\n\trefspec = parse_fetch_refspec(1, &fetch_pattern);\n\n\tstrbuf_reset(&value);\n\n\tremote = remote_get(option_origin);\n\ttransport = transport_get(remote, remote->url[0]);\n\ttransport_set_verbosity(transport, option_verbosity, option_progress);\n\n\tpath = get_repo_path(remote->url[0], &is_bundle);\n\tis_local = option_local != 0 && path && !is_bundle;\n\tif (is_local) {\n\t\tif (option_depth)\n\t\t\twarning(_(\"--depth is ignored in local clones; use file:// instead.\"));\n\t\tif (!access(mkpath(\"%s/shallow\", path), F_OK)) {\n\t\t\tif (option_local > 0)\n\t\t\t\twarning(_(\"source repository is shallow, ignoring --local\"));\n\t\t\tis_local = 0;\n\t\t}\n\t}\n\tif (option_local > 0 && !is_local)\n\t\twarning(_(\"--local is ignored\"));\n\ttransport->cloning = 1;\n\n\tif (!transport->get_refs_list || (!is_local && !transport->fetch))\n\t\tdie(_(\"Don't know how to clone %s\"), transport->url);\n\n\ttransport_set_option(transport, TRANS_OPT_KEEP, \"yes\");\n\n\tif (option_depth)\n\t\ttransport_set_option(transport, TRANS_OPT_DEPTH,\n\t\t\t\t     option_depth);\n\tif (option_single_branch)\n\t\ttransport_set_option(transport, TRANS_OPT_FOLLOWTAGS, \"1\");\n\n\tif (option_upload_pack)\n\t\ttransport_set_option(transport, TRANS_OPT_UPLOADPACK,\n\t\t\t\t     option_upload_pack);\n\n\tif (transport->smart_options && !option_depth)\n\t\ttransport->smart_options->check_self_contained_and_connected = 1;\n\n\trefs = transport_get_remote_refs(transport);\n\n\tif (refs) {\n\t\tmapped_refs = wanted_peer_refs(refs, refspec);\n\t\t/*\n\t\t * transport_get_remote_refs() may return refs with null sha-1\n\t\t * in mapped_refs (see struct transport->get_refs_list\n\t\t * comment). In that case we need fetch it early because\n\t\t * remote_head code below relies on it.\n\t\t *\n\t\t * for normal clones, transport_get_remote_refs() should\n\t\t * return reliable ref set, we can delay cloning until after\n\t\t * remote HEAD check.\n\t\t */\n\t\tfor (ref = refs; ref; ref = ref->next)\n\t\t\tif (is_null_sha1(ref->old_sha1)) {\n\t\t\t\tcomplete_refs_before_fetch = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!is_local && !complete_refs_before_fetch)\n\t\t\ttransport_fetch_refs(transport, mapped_refs);\n\n\t\tremote_head = find_ref_by_name(refs, \"HEAD\");\n\t\tremote_head_points_at =\n\t\t\tguess_remote_head(remote_head, mapped_refs, 0);\n\n\t\tif (option_branch) {\n\t\t\tour_head_points_at =\n\t\t\t\tfind_remote_branch(mapped_refs, option_branch);\n\n\t\t\tif (!our_head_points_at)\n\t\t\t\tdie(_(\"Remote branch %s not found in upstream %s\"),\n\t\t\t\t    option_branch, option_origin);\n\t\t}\n\t\telse\n\t\t\tour_head_points_at = remote_head_points_at;\n\t}\n\telse {\n\t\tif (option_branch)\n\t\t\tdie(_(\"Remote branch %s not found in upstream %s\"),\n\t\t\t\t\toption_branch, option_origin);\n\n\t\twarning(_(\"You appear to have cloned an empty repository.\"));\n\t\tmapped_refs = NULL;\n\t\tour_head_points_at = NULL;\n\t\tremote_head_points_at = NULL;\n\t\tremote_head = NULL;\n\t\toption_no_checkout = 1;\n\t\tif (!option_bare)\n\t\t\tinstall_branch_config(0, \"master\", option_origin,\n\t\t\t\t\t      \"refs/heads/master\");\n\t}\n\n\twrite_refspec_config(src_ref_prefix, our_head_points_at,\n\t\t\tremote_head_points_at, &branch_top);\n\n\tif (is_local)\n\t\tclone_local(path, git_dir);\n\telse if (refs && complete_refs_before_fetch)\n\t\ttransport_fetch_refs(transport, mapped_refs);\n\n\tupdate_remote_refs(refs, mapped_refs, remote_head_points_at,\n\t\t\t   branch_top.buf, reflog_msg.buf, transport, !is_local);\n\n\tupdate_head(our_head_points_at, remote_head, reflog_msg.buf);\n\n\ttransport_unlock_pack(transport);\n\ttransport_disconnect(transport);\n\n\tif (option_dissociate)\n\t\tdissociate_from_references();\n\n\tjunk_mode = JUNK_LEAVE_REPO;\n\terr = checkout();\n\n\tstrbuf_release(&reflog_msg);\n\tstrbuf_release(&branch_top);\n\tstrbuf_release(&key);\n\tstrbuf_release(&value);\n\tjunk_mode = JUNK_LEAVE_ALL;\n\n\tfree(refspec);\n\treturn err;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00535d0178f1a0ee562bf008e8b072f68410dc3d",
  "sha1_ok": true,
  "size": 28210
}
