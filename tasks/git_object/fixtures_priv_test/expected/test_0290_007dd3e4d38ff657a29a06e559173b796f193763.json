{
  "content": {
    "base64": "LyoKICogTG93IGxldmVsIDMtd2F5IGluLWNvcmUgZmlsZSBtZXJnZS4KICoKICogQ29weXJpZ2h0IChjKSAyMDA3IEp1bmlvIEMgSGFtYW5vCiAqLwoKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJhdHRyLmgiCiNpbmNsdWRlICJ4ZGlmZi1pbnRlcmZhY2UuaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJsbC1tZXJnZS5oIgoKc3RydWN0IGxsX21lcmdlX2RyaXZlcjsKCnR5cGVkZWYgaW50ICgqbGxfbWVyZ2VfZm4pKGNvbnN0IHN0cnVjdCBsbF9tZXJnZV9kcml2ZXIgKiwKCQkJICAgbW1idWZmZXJfdCAqcmVzdWx0LAoJCQkgICBjb25zdCBjaGFyICpwYXRoLAoJCQkgICBtbWZpbGVfdCAqb3JpZywgY29uc3QgY2hhciAqb3JpZ19uYW1lLAoJCQkgICBtbWZpbGVfdCAqc3JjMSwgY29uc3QgY2hhciAqbmFtZTEsCgkJCSAgIG1tZmlsZV90ICpzcmMyLCBjb25zdCBjaGFyICpuYW1lMiwKCQkJICAgY29uc3Qgc3RydWN0IGxsX21lcmdlX29wdGlvbnMgKm9wdHMsCgkJCSAgIGludCBtYXJrZXJfc2l6ZSk7CgpzdHJ1Y3QgbGxfbWVyZ2VfZHJpdmVyIHsKCWNvbnN0IGNoYXIgKm5hbWU7Cgljb25zdCBjaGFyICpkZXNjcmlwdGlvbjsKCWxsX21lcmdlX2ZuIGZuOwoJY29uc3QgY2hhciAqcmVjdXJzaXZlOwoJc3RydWN0IGxsX21lcmdlX2RyaXZlciAqbmV4dDsKCWNoYXIgKmNtZGxpbmU7Cn07CgovKgogKiBCdWlsdC1pbiBsb3ctbGV2ZWxzCiAqLwpzdGF0aWMgaW50IGxsX2JpbmFyeV9tZXJnZShjb25zdCBzdHJ1Y3QgbGxfbWVyZ2VfZHJpdmVyICpkcnZfdW51c2VkLAoJCQkgICBtbWJ1ZmZlcl90ICpyZXN1bHQsCgkJCSAgIGNvbnN0IGNoYXIgKnBhdGhfdW51c2VkLAoJCQkgICBtbWZpbGVfdCAqb3JpZywgY29uc3QgY2hhciAqb3JpZ19uYW1lLAoJCQkgICBtbWZpbGVfdCAqc3JjMSwgY29uc3QgY2hhciAqbmFtZTEsCgkJCSAgIG1tZmlsZV90ICpzcmMyLCBjb25zdCBjaGFyICpuYW1lMiwKCQkJICAgY29uc3Qgc3RydWN0IGxsX21lcmdlX29wdGlvbnMgKm9wdHMsCgkJCSAgIGludCBtYXJrZXJfc2l6ZSkKewoJbW1maWxlX3QgKnN0b2xlbjsKCWFzc2VydChvcHRzKTsKCgkvKgoJICogVGhlIHRlbnRhdGl2ZSBtZXJnZSByZXN1bHQgaXMgIm91cnMiIGZvciB0aGUgZmluYWwgcm91bmQsCgkgKiBvciBjb21tb24gYW5jZXN0b3IgZm9yIGFuIGludGVybmFsIG1lcmdlLiAgU3RpbGwgcmV0dXJuCgkgKiAiY29uZmxpY3RlZCBtZXJnZSIgc3RhdHVzLgoJICovCglzdG9sZW4gPSBvcHRzLT52aXJ0dWFsX2FuY2VzdG9yID8gb3JpZyA6IHNyYzE7CgoJcmVzdWx0LT5wdHIgPSBzdG9sZW4tPnB0cjsKCXJlc3VsdC0+c2l6ZSA9IHN0b2xlbi0+c2l6ZTsKCXN0b2xlbi0+cHRyID0gTlVMTDsKCXJldHVybiAxOwp9CgpzdGF0aWMgaW50IGxsX3hkbF9tZXJnZShjb25zdCBzdHJ1Y3QgbGxfbWVyZ2VfZHJpdmVyICpkcnZfdW51c2VkLAoJCQltbWJ1ZmZlcl90ICpyZXN1bHQsCgkJCWNvbnN0IGNoYXIgKnBhdGgsCgkJCW1tZmlsZV90ICpvcmlnLCBjb25zdCBjaGFyICpvcmlnX25hbWUsCgkJCW1tZmlsZV90ICpzcmMxLCBjb25zdCBjaGFyICpuYW1lMSwKCQkJbW1maWxlX3QgKnNyYzIsIGNvbnN0IGNoYXIgKm5hbWUyLAoJCQljb25zdCBzdHJ1Y3QgbGxfbWVyZ2Vfb3B0aW9ucyAqb3B0cywKCQkJaW50IG1hcmtlcl9zaXplKQp7Cgl4bXBhcmFtX3QgeG1wOwoJYXNzZXJ0KG9wdHMpOwoKCWlmIChidWZmZXJfaXNfYmluYXJ5KG9yaWctPnB0ciwgb3JpZy0+c2l6ZSkgfHwKCSAgICBidWZmZXJfaXNfYmluYXJ5KHNyYzEtPnB0ciwgc3JjMS0+c2l6ZSkgfHwKCSAgICBidWZmZXJfaXNfYmluYXJ5KHNyYzItPnB0ciwgc3JjMi0+c2l6ZSkpIHsKCQl3YXJuaW5nKCJDYW5ub3QgbWVyZ2UgYmluYXJ5IGZpbGVzOiAlcyAoJXMgdnMuICVzKVxuIiwKCQkJcGF0aCwgbmFtZTEsIG5hbWUyKTsKCQlyZXR1cm4gbGxfYmluYXJ5X21lcmdlKGRydl91bnVzZWQsIHJlc3VsdCwKCQkJCSAgICAgICBwYXRoLAoJCQkJICAgICAgIG9yaWcsIG9yaWdfbmFtZSwKCQkJCSAgICAgICBzcmMxLCBuYW1lMSwKCQkJCSAgICAgICBzcmMyLCBuYW1lMiwKCQkJCSAgICAgICBvcHRzLCBtYXJrZXJfc2l6ZSk7Cgl9CgoJbWVtc2V0KCZ4bXAsIDAsIHNpemVvZih4bXApKTsKCXhtcC5sZXZlbCA9IFhETF9NRVJHRV9aRUFMT1VTOwoJeG1wLmZhdm9yID0gb3B0cy0+dmFyaWFudDsKCXhtcC54cHAuZmxhZ3MgPSBvcHRzLT54ZGxfb3B0czsKCWlmIChnaXRfeG1lcmdlX3N0eWxlID49IDApCgkJeG1wLnN0eWxlID0gZ2l0X3htZXJnZV9zdHlsZTsKCWlmIChtYXJrZXJfc2l6ZSA+IDApCgkJeG1wLm1hcmtlcl9zaXplID0gbWFya2VyX3NpemU7Cgl4bXAuYW5jZXN0b3IgPSBvcmlnX25hbWU7Cgl4bXAuZmlsZTEgPSBuYW1lMTsKCXhtcC5maWxlMiA9IG5hbWUyOwoJcmV0dXJuIHhkbF9tZXJnZShvcmlnLCBzcmMxLCBzcmMyLCAmeG1wLCByZXN1bHQpOwp9CgpzdGF0aWMgaW50IGxsX3VuaW9uX21lcmdlKGNvbnN0IHN0cnVjdCBsbF9tZXJnZV9kcml2ZXIgKmRydl91bnVzZWQsCgkJCSAgbW1idWZmZXJfdCAqcmVzdWx0LAoJCQkgIGNvbnN0IGNoYXIgKnBhdGhfdW51c2VkLAoJCQkgIG1tZmlsZV90ICpvcmlnLCBjb25zdCBjaGFyICpvcmlnX25hbWUsCgkJCSAgbW1maWxlX3QgKnNyYzEsIGNvbnN0IGNoYXIgKm5hbWUxLAoJCQkgIG1tZmlsZV90ICpzcmMyLCBjb25zdCBjaGFyICpuYW1lMiwKCQkJICBjb25zdCBzdHJ1Y3QgbGxfbWVyZ2Vfb3B0aW9ucyAqb3B0cywKCQkJICBpbnQgbWFya2VyX3NpemUpCnsKCS8qIFVzZSB1bmlvbiBmYXZvciAqLwoJc3RydWN0IGxsX21lcmdlX29wdGlvbnMgbzsKCWFzc2VydChvcHRzKTsKCW8gPSAqb3B0czsKCW8udmFyaWFudCA9IFhETF9NRVJHRV9GQVZPUl9VTklPTjsKCXJldHVybiBsbF94ZGxfbWVyZ2UoZHJ2X3VudXNlZCwgcmVzdWx0LCBwYXRoX3VudXNlZCwKCQkJICAgIG9yaWcsIE5VTEwsIHNyYzEsIE5VTEwsIHNyYzIsIE5VTEwsCgkJCSAgICAmbywgbWFya2VyX3NpemUpOwp9CgojZGVmaW5lIExMX0JJTkFSWV9NRVJHRSAwCiNkZWZpbmUgTExfVEVYVF9NRVJHRSAxCiNkZWZpbmUgTExfVU5JT05fTUVSR0UgMgpzdGF0aWMgc3RydWN0IGxsX21lcmdlX2RyaXZlciBsbF9tZXJnZV9kcnZbXSA9IHsKCXsgImJpbmFyeSIsICJidWlsdC1pbiBiaW5hcnkgbWVyZ2UiLCBsbF9iaW5hcnlfbWVyZ2UgfSwKCXsgInRleHQiLCAiYnVpbHQtaW4gMy13YXkgdGV4dCBtZXJnZSIsIGxsX3hkbF9tZXJnZSB9LAoJeyAidW5pb24iLCAiYnVpbHQtaW4gdW5pb24gbWVyZ2UiLCBsbF91bmlvbl9tZXJnZSB9LAp9OwoKc3RhdGljIHZvaWQgY3JlYXRlX3RlbXAobW1maWxlX3QgKnNyYywgY2hhciAqcGF0aCkKewoJaW50IGZkOwoKCXN0cmNweShwYXRoLCAiLm1lcmdlX2ZpbGVfWFhYWFhYIik7CglmZCA9IHhta3N0ZW1wKHBhdGgpOwoJaWYgKHdyaXRlX2luX2Z1bGwoZmQsIHNyYy0+cHRyLCBzcmMtPnNpemUpICE9IHNyYy0+c2l6ZSkKCQlkaWVfZXJybm8oInVuYWJsZSB0byB3cml0ZSB0ZW1wLWZpbGUiKTsKCWNsb3NlKGZkKTsKfQoKLyoKICogVXNlciBkZWZpbmVkIGxvdy1sZXZlbCBtZXJnZSBkcml2ZXIgc3VwcG9ydC4KICovCnN0YXRpYyBpbnQgbGxfZXh0X21lcmdlKGNvbnN0IHN0cnVjdCBsbF9tZXJnZV9kcml2ZXIgKmZuLAoJCQltbWJ1ZmZlcl90ICpyZXN1bHQsCgkJCWNvbnN0IGNoYXIgKnBhdGgsCgkJCW1tZmlsZV90ICpvcmlnLCBjb25zdCBjaGFyICpvcmlnX25hbWUsCgkJCW1tZmlsZV90ICpzcmMxLCBjb25zdCBjaGFyICpuYW1lMSwKCQkJbW1maWxlX3QgKnNyYzIsIGNvbnN0IGNoYXIgKm5hbWUyLAoJCQljb25zdCBzdHJ1Y3QgbGxfbWVyZ2Vfb3B0aW9ucyAqb3B0cywKCQkJaW50IG1hcmtlcl9zaXplKQp7CgljaGFyIHRlbXBbNF1bNTBdOwoJc3RydWN0IHN0cmJ1ZiBjbWQgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWZfZXhwYW5kX2RpY3RfZW50cnkgZGljdFs1XTsKCWNvbnN0IGNoYXIgKmFyZ3NbXSA9IHsgTlVMTCwgTlVMTCB9OwoJaW50IHN0YXR1cywgZmQsIGk7CglzdHJ1Y3Qgc3RhdCBzdDsKCWFzc2VydChvcHRzKTsKCglkaWN0WzBdLnBsYWNlaG9sZGVyID0gIk8iOyBkaWN0WzBdLnZhbHVlID0gdGVtcFswXTsKCWRpY3RbMV0ucGxhY2Vob2xkZXIgPSAiQSI7IGRpY3RbMV0udmFsdWUgPSB0ZW1wWzFdOwoJZGljdFsyXS5wbGFjZWhvbGRlciA9ICJCIjsgZGljdFsyXS52YWx1ZSA9IHRlbXBbMl07CglkaWN0WzNdLnBsYWNlaG9sZGVyID0gIkwiOyBkaWN0WzNdLnZhbHVlID0gdGVtcFszXTsKCWRpY3RbNF0ucGxhY2Vob2xkZXIgPSBOVUxMOyBkaWN0WzRdLnZhbHVlID0gTlVMTDsKCglpZiAoZm4tPmNtZGxpbmUgPT0gTlVMTCkKCQlkaWUoImN1c3RvbSBtZXJnZSBkcml2ZXIgJXMgbGFja3MgY29tbWFuZCBsaW5lLiIsIGZuLT5uYW1lKTsKCglyZXN1bHQtPnB0ciA9IE5VTEw7CglyZXN1bHQtPnNpemUgPSAwOwoJY3JlYXRlX3RlbXAob3JpZywgdGVtcFswXSk7CgljcmVhdGVfdGVtcChzcmMxLCB0ZW1wWzFdKTsKCWNyZWF0ZV90ZW1wKHNyYzIsIHRlbXBbMl0pOwoJc3ByaW50Zih0ZW1wWzNdLCAiJWQiLCBtYXJrZXJfc2l6ZSk7CgoJc3RyYnVmX2V4cGFuZCgmY21kLCBmbi0+Y21kbGluZSwgc3RyYnVmX2V4cGFuZF9kaWN0X2NiLCAmZGljdCk7CgoJYXJnc1swXSA9IGNtZC5idWY7CglzdGF0dXMgPSBydW5fY29tbWFuZF92X29wdChhcmdzLCBSVU5fVVNJTkdfU0hFTEwpOwoJZmQgPSBvcGVuKHRlbXBbMV0sIE9fUkRPTkxZKTsKCWlmIChmZCA8IDApCgkJZ290byBiYWQ7CglpZiAoZnN0YXQoZmQsICZzdCkpCgkJZ290byBjbG9zZV9iYWQ7CglyZXN1bHQtPnNpemUgPSBzdC5zdF9zaXplOwoJcmVzdWx0LT5wdHIgPSB4bWFsbG9jKHJlc3VsdC0+c2l6ZSArIDEpOwoJaWYgKHJlYWRfaW5fZnVsbChmZCwgcmVzdWx0LT5wdHIsIHJlc3VsdC0+c2l6ZSkgIT0gcmVzdWx0LT5zaXplKSB7CgkJZnJlZShyZXN1bHQtPnB0cik7CgkJcmVzdWx0LT5wdHIgPSBOVUxMOwoJCXJlc3VsdC0+c2l6ZSA9IDA7Cgl9CiBjbG9zZV9iYWQ6CgljbG9zZShmZCk7CiBiYWQ6Cglmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKQoJCXVubGlua19vcl93YXJuKHRlbXBbaV0pOwoJc3RyYnVmX3JlbGVhc2UoJmNtZCk7CglyZXR1cm4gc3RhdHVzOwp9CgovKgogKiBtZXJnZS5kZWZhdWx0IGFuZCBtZXJnZS5kcml2ZXIgY29uZmlndXJhdGlvbiBpdGVtcwogKi8Kc3RhdGljIHN0cnVjdCBsbF9tZXJnZV9kcml2ZXIgKmxsX3VzZXJfbWVyZ2UsICoqbGxfdXNlcl9tZXJnZV90YWlsOwpzdGF0aWMgY29uc3QgY2hhciAqZGVmYXVsdF9sbF9tZXJnZTsKCnN0YXRpYyBpbnQgcmVhZF9tZXJnZV9jb25maWcoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSwgdm9pZCAqY2IpCnsKCXN0cnVjdCBsbF9tZXJnZV9kcml2ZXIgKmZuOwoJY29uc3QgY2hhciAqZXAsICpuYW1lOwoJaW50IG5hbWVsZW47CgoJaWYgKCFzdHJjbXAodmFyLCAibWVyZ2UuZGVmYXVsdCIpKSB7CgkJaWYgKHZhbHVlKQoJCQlkZWZhdWx0X2xsX21lcmdlID0geHN0cmR1cCh2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CgoJLyoKCSAqIFdlIGFyZSBub3QgaW50ZXJlc3RlZCBpbiBhbnl0aGluZyBidXQgIm1lcmdlLjxuYW1lPi52YXJpYWJsZSI7CgkgKiBlc3BlY2lhbGx5LCB3ZSBkbyBub3Qgd2FudCB0byBsb29rIGF0IHZhcmlhYmxlcyBzdWNoIGFzCgkgKiAibWVyZ2Uuc3VtbWFyeSIsICJtZXJnZS50b29sIiwgYW5kICJtZXJnZS52ZXJib3NpdHkiLgoJICovCglpZiAocHJlZml4Y21wKHZhciwgIm1lcmdlLiIpIHx8IChlcCA9IHN0cnJjaHIodmFyLCAnLicpKSA9PSB2YXIgKyA1KQoJCXJldHVybiAwOwoKCS8qCgkgKiBGaW5kIGV4aXN0aW5nIG9uZSBhcyB3ZSBtaWdodCBiZSBwcm9jZXNzaW5nIG1lcmdlLjxuYW1lPi52YXIyCgkgKiBhZnRlciBzZWVpbmcgbWVyZ2UuPG5hbWU+LnZhcjEuCgkgKi8KCW5hbWUgPSB2YXIgKyA2OwoJbmFtZWxlbiA9IGVwIC0gbmFtZTsKCWZvciAoZm4gPSBsbF91c2VyX21lcmdlOyBmbjsgZm4gPSBmbi0+bmV4dCkKCQlpZiAoIXN0cm5jbXAoZm4tPm5hbWUsIG5hbWUsIG5hbWVsZW4pICYmICFmbi0+bmFtZVtuYW1lbGVuXSkKCQkJYnJlYWs7CglpZiAoIWZuKSB7CgkJZm4gPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3QgbGxfbWVyZ2VfZHJpdmVyKSk7CgkJZm4tPm5hbWUgPSB4bWVtZHVweihuYW1lLCBuYW1lbGVuKTsKCQlmbi0+Zm4gPSBsbF9leHRfbWVyZ2U7CgkJKmxsX3VzZXJfbWVyZ2VfdGFpbCA9IGZuOwoJCWxsX3VzZXJfbWVyZ2VfdGFpbCA9ICYoZm4tPm5leHQpOwoJfQoKCWVwKys7CgoJaWYgKCFzdHJjbXAoIm5hbWUiLCBlcCkpIHsKCQlpZiAoIXZhbHVlKQoJCQlyZXR1cm4gZXJyb3IoIiVzOiBsYWNrcyB2YWx1ZSIsIHZhcik7CgkJZm4tPmRlc2NyaXB0aW9uID0geHN0cmR1cCh2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKCFzdHJjbXAoImRyaXZlciIsIGVwKSkgewoJCWlmICghdmFsdWUpCgkJCXJldHVybiBlcnJvcigiJXM6IGxhY2tzIHZhbHVlIiwgdmFyKTsKCQkvKgoJCSAqIG1lcmdlLjxuYW1lPi5kcml2ZXIgc3BlY2lmaWVzIHRoZSBjb21tYW5kIGxpbmU6CgkJICoKCQkgKgljb21tYW5kLWxpbmUKCQkgKgoJCSAqIFRoZSBjb21tYW5kLWxpbmUgd2lsbCBiZSBpbnRlcnBvbGF0ZWQgd2l0aCB0aGUgZm9sbG93aW5nCgkJICogdG9rZW5zIGFuZCBpcyBnaXZlbiB0byB0aGUgc2hlbGw6CgkJICoKCQkgKiAgICAlTyAtIHRlbXBvcmFyeSBmaWxlIG5hbWUgZm9yIHRoZSBtZXJnZSBiYXNlLgoJCSAqICAgICVBIC0gdGVtcG9yYXJ5IGZpbGUgbmFtZSBmb3Igb3VyIHZlcnNpb24uCgkJICogICAgJUIgLSB0ZW1wb3JhcnkgZmlsZSBuYW1lIGZvciB0aGUgb3RoZXIgYnJhbmNoZXMnIHZlcnNpb24uCgkJICogICAgJUwgLSBjb25mbGljdCBtYXJrZXIgbGVuZ3RoCgkJICoKCQkgKiBUaGUgZXh0ZXJuYWwgbWVyZ2UgZHJpdmVyIHNob3VsZCB3cml0ZSB0aGUgcmVzdWx0cyBpbiB0aGUKCQkgKiBmaWxlIG5hbWVkIGJ5ICVBLCBhbmQgc2lnbmFsIHRoYXQgaXQgaGFzIGRvbmUgd2l0aCB6ZXJvIGV4aXQKCQkgKiBzdGF0dXMuCgkJICovCgkJZm4tPmNtZGxpbmUgPSB4c3RyZHVwKHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCglpZiAoIXN0cmNtcCgicmVjdXJzaXZlIiwgZXApKSB7CgkJaWYgKCF2YWx1ZSkKCQkJcmV0dXJuIGVycm9yKCIlczogbGFja3MgdmFsdWUiLCB2YXIpOwoJCWZuLT5yZWN1cnNpdmUgPSB4c3RyZHVwKHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgaW5pdGlhbGl6ZV9sbF9tZXJnZSh2b2lkKQp7CglpZiAobGxfdXNlcl9tZXJnZV90YWlsKQoJCXJldHVybjsKCWxsX3VzZXJfbWVyZ2VfdGFpbCA9ICZsbF91c2VyX21lcmdlOwoJZ2l0X2NvbmZpZyhyZWFkX21lcmdlX2NvbmZpZywgTlVMTCk7Cn0KCnN0YXRpYyBjb25zdCBzdHJ1Y3QgbGxfbWVyZ2VfZHJpdmVyICpmaW5kX2xsX21lcmdlX2RyaXZlcihjb25zdCBjaGFyICptZXJnZV9hdHRyKQp7CglzdHJ1Y3QgbGxfbWVyZ2VfZHJpdmVyICpmbjsKCWNvbnN0IGNoYXIgKm5hbWU7CglpbnQgaTsKCglpbml0aWFsaXplX2xsX21lcmdlKCk7CgoJaWYgKEFUVFJfVFJVRShtZXJnZV9hdHRyKSkKCQlyZXR1cm4gJmxsX21lcmdlX2RydltMTF9URVhUX01FUkdFXTsKCWVsc2UgaWYgKEFUVFJfRkFMU0UobWVyZ2VfYXR0cikpCgkJcmV0dXJuICZsbF9tZXJnZV9kcnZbTExfQklOQVJZX01FUkdFXTsKCWVsc2UgaWYgKEFUVFJfVU5TRVQobWVyZ2VfYXR0cikpIHsKCQlpZiAoIWRlZmF1bHRfbGxfbWVyZ2UpCgkJCXJldHVybiAmbGxfbWVyZ2VfZHJ2W0xMX1RFWFRfTUVSR0VdOwoJCWVsc2UKCQkJbmFtZSA9IGRlZmF1bHRfbGxfbWVyZ2U7Cgl9CgllbHNlCgkJbmFtZSA9IG1lcmdlX2F0dHI7CgoJZm9yIChmbiA9IGxsX3VzZXJfbWVyZ2U7IGZuOyBmbiA9IGZuLT5uZXh0KQoJCWlmICghc3RyY21wKGZuLT5uYW1lLCBuYW1lKSkKCQkJcmV0dXJuIGZuOwoKCWZvciAoaSA9IDA7IGkgPCBBUlJBWV9TSVpFKGxsX21lcmdlX2Rydik7IGkrKykKCQlpZiAoIXN0cmNtcChsbF9tZXJnZV9kcnZbaV0ubmFtZSwgbmFtZSkpCgkJCXJldHVybiAmbGxfbWVyZ2VfZHJ2W2ldOwoKCS8qIGRlZmF1bHQgdG8gdGhlIDMtd2F5ICovCglyZXR1cm4gJmxsX21lcmdlX2RydltMTF9URVhUX01FUkdFXTsKfQoKc3RhdGljIGludCBnaXRfcGF0aF9jaGVja19tZXJnZShjb25zdCBjaGFyICpwYXRoLCBzdHJ1Y3QgZ2l0X2F0dHJfY2hlY2sgY2hlY2tbMl0pCnsKCWlmICghY2hlY2tbMF0uYXR0cikgewoJCWNoZWNrWzBdLmF0dHIgPSBnaXRfYXR0cigibWVyZ2UiKTsKCQljaGVja1sxXS5hdHRyID0gZ2l0X2F0dHIoImNvbmZsaWN0LW1hcmtlci1zaXplIik7Cgl9CglyZXR1cm4gZ2l0X2NoZWNrYXR0cihwYXRoLCAyLCBjaGVjayk7Cn0KCnN0YXRpYyB2b2lkIG5vcm1hbGl6ZV9maWxlKG1tZmlsZV90ICptbSwgY29uc3QgY2hhciAqcGF0aCkKewoJc3RydWN0IHN0cmJ1ZiBzdHJidWYgPSBTVFJCVUZfSU5JVDsKCWlmIChyZW5vcm1hbGl6ZV9idWZmZXIocGF0aCwgbW0tPnB0ciwgbW0tPnNpemUsICZzdHJidWYpKSB7CgkJZnJlZShtbS0+cHRyKTsKCQltbS0+c2l6ZSA9IHN0cmJ1Zi5sZW47CgkJbW0tPnB0ciA9IHN0cmJ1Zl9kZXRhY2goJnN0cmJ1ZiwgTlVMTCk7Cgl9Cn0KCmludCBsbF9tZXJnZShtbWJ1ZmZlcl90ICpyZXN1bHRfYnVmLAoJICAgICBjb25zdCBjaGFyICpwYXRoLAoJICAgICBtbWZpbGVfdCAqYW5jZXN0b3IsIGNvbnN0IGNoYXIgKmFuY2VzdG9yX2xhYmVsLAoJICAgICBtbWZpbGVfdCAqb3VycywgY29uc3QgY2hhciAqb3VyX2xhYmVsLAoJICAgICBtbWZpbGVfdCAqdGhlaXJzLCBjb25zdCBjaGFyICp0aGVpcl9sYWJlbCwKCSAgICAgY29uc3Qgc3RydWN0IGxsX21lcmdlX29wdGlvbnMgKm9wdHMpCnsKCXN0YXRpYyBzdHJ1Y3QgZ2l0X2F0dHJfY2hlY2sgY2hlY2tbMl07Cgljb25zdCBjaGFyICpsbF9kcml2ZXJfbmFtZSA9IE5VTEw7CglpbnQgbWFya2VyX3NpemUgPSBERUZBVUxUX0NPTkZMSUNUX01BUktFUl9TSVpFOwoJY29uc3Qgc3RydWN0IGxsX21lcmdlX2RyaXZlciAqZHJpdmVyOwoKCWlmICghb3B0cykgewoJCXN0cnVjdCBsbF9tZXJnZV9vcHRpb25zIGRlZmF1bHRfb3B0cyA9IHswfTsKCQlyZXR1cm4gbGxfbWVyZ2UocmVzdWx0X2J1ZiwgcGF0aCwgYW5jZXN0b3IsIGFuY2VzdG9yX2xhYmVsLAoJCQkJb3Vycywgb3VyX2xhYmVsLCB0aGVpcnMsIHRoZWlyX2xhYmVsLAoJCQkJJmRlZmF1bHRfb3B0cyk7Cgl9CgoJaWYgKG9wdHMtPnJlbm9ybWFsaXplKSB7CgkJbm9ybWFsaXplX2ZpbGUoYW5jZXN0b3IsIHBhdGgpOwoJCW5vcm1hbGl6ZV9maWxlKG91cnMsIHBhdGgpOwoJCW5vcm1hbGl6ZV9maWxlKHRoZWlycywgcGF0aCk7Cgl9CglpZiAoIWdpdF9wYXRoX2NoZWNrX21lcmdlKHBhdGgsIGNoZWNrKSkgewoJCWxsX2RyaXZlcl9uYW1lID0gY2hlY2tbMF0udmFsdWU7CgkJaWYgKGNoZWNrWzFdLnZhbHVlKSB7CgkJCW1hcmtlcl9zaXplID0gYXRvaShjaGVja1sxXS52YWx1ZSk7CgkJCWlmIChtYXJrZXJfc2l6ZSA8PSAwKQoJCQkJbWFya2VyX3NpemUgPSBERUZBVUxUX0NPTkZMSUNUX01BUktFUl9TSVpFOwoJCX0KCX0KCWRyaXZlciA9IGZpbmRfbGxfbWVyZ2VfZHJpdmVyKGxsX2RyaXZlcl9uYW1lKTsKCWlmIChvcHRzLT52aXJ0dWFsX2FuY2VzdG9yICYmIGRyaXZlci0+cmVjdXJzaXZlKQoJCWRyaXZlciA9IGZpbmRfbGxfbWVyZ2VfZHJpdmVyKGRyaXZlci0+cmVjdXJzaXZlKTsKCXJldHVybiBkcml2ZXItPmZuKGRyaXZlciwgcmVzdWx0X2J1ZiwgcGF0aCwgYW5jZXN0b3IsIGFuY2VzdG9yX2xhYmVsLAoJCQkgIG91cnMsIG91cl9sYWJlbCwgdGhlaXJzLCB0aGVpcl9sYWJlbCwKCQkJICBvcHRzLCBtYXJrZXJfc2l6ZSk7Cn0KCmludCBsbF9tZXJnZV9tYXJrZXJfc2l6ZShjb25zdCBjaGFyICpwYXRoKQp7CglzdGF0aWMgc3RydWN0IGdpdF9hdHRyX2NoZWNrIGNoZWNrOwoJaW50IG1hcmtlcl9zaXplID0gREVGQVVMVF9DT05GTElDVF9NQVJLRVJfU0laRTsKCglpZiAoIWNoZWNrLmF0dHIpCgkJY2hlY2suYXR0ciA9IGdpdF9hdHRyKCJjb25mbGljdC1tYXJrZXItc2l6ZSIpOwoJaWYgKCFnaXRfY2hlY2thdHRyKHBhdGgsIDEsICZjaGVjaykgJiYgY2hlY2sudmFsdWUpIHsKCQltYXJrZXJfc2l6ZSA9IGF0b2koY2hlY2sudmFsdWUpOwoJCWlmIChtYXJrZXJfc2l6ZSA8PSAwKQoJCQltYXJrZXJfc2l6ZSA9IERFRkFVTFRfQ09ORkxJQ1RfTUFSS0VSX1NJWkU7Cgl9CglyZXR1cm4gbWFya2VyX3NpemU7Cn0K",
    "text": "/*\n * Low level 3-way in-core file merge.\n *\n * Copyright (c) 2007 Junio C Hamano\n */\n\n#include \"cache.h\"\n#include \"attr.h\"\n#include \"xdiff-interface.h\"\n#include \"run-command.h\"\n#include \"ll-merge.h\"\n\nstruct ll_merge_driver;\n\ntypedef int (*ll_merge_fn)(const struct ll_merge_driver *,\n\t\t\t   mmbuffer_t *result,\n\t\t\t   const char *path,\n\t\t\t   mmfile_t *orig, const char *orig_name,\n\t\t\t   mmfile_t *src1, const char *name1,\n\t\t\t   mmfile_t *src2, const char *name2,\n\t\t\t   const struct ll_merge_options *opts,\n\t\t\t   int marker_size);\n\nstruct ll_merge_driver {\n\tconst char *name;\n\tconst char *description;\n\tll_merge_fn fn;\n\tconst char *recursive;\n\tstruct ll_merge_driver *next;\n\tchar *cmdline;\n};\n\n/*\n * Built-in low-levels\n */\nstatic int ll_binary_merge(const struct ll_merge_driver *drv_unused,\n\t\t\t   mmbuffer_t *result,\n\t\t\t   const char *path_unused,\n\t\t\t   mmfile_t *orig, const char *orig_name,\n\t\t\t   mmfile_t *src1, const char *name1,\n\t\t\t   mmfile_t *src2, const char *name2,\n\t\t\t   const struct ll_merge_options *opts,\n\t\t\t   int marker_size)\n{\n\tmmfile_t *stolen;\n\tassert(opts);\n\n\t/*\n\t * The tentative merge result is \"ours\" for the final round,\n\t * or common ancestor for an internal merge.  Still return\n\t * \"conflicted merge\" status.\n\t */\n\tstolen = opts->virtual_ancestor ? orig : src1;\n\n\tresult->ptr = stolen->ptr;\n\tresult->size = stolen->size;\n\tstolen->ptr = NULL;\n\treturn 1;\n}\n\nstatic int ll_xdl_merge(const struct ll_merge_driver *drv_unused,\n\t\t\tmmbuffer_t *result,\n\t\t\tconst char *path,\n\t\t\tmmfile_t *orig, const char *orig_name,\n\t\t\tmmfile_t *src1, const char *name1,\n\t\t\tmmfile_t *src2, const char *name2,\n\t\t\tconst struct ll_merge_options *opts,\n\t\t\tint marker_size)\n{\n\txmparam_t xmp;\n\tassert(opts);\n\n\tif (buffer_is_binary(orig->ptr, orig->size) ||\n\t    buffer_is_binary(src1->ptr, src1->size) ||\n\t    buffer_is_binary(src2->ptr, src2->size)) {\n\t\twarning(\"Cannot merge binary files: %s (%s vs. %s)\\n\",\n\t\t\tpath, name1, name2);\n\t\treturn ll_binary_merge(drv_unused, result,\n\t\t\t\t       path,\n\t\t\t\t       orig, orig_name,\n\t\t\t\t       src1, name1,\n\t\t\t\t       src2, name2,\n\t\t\t\t       opts, marker_size);\n\t}\n\n\tmemset(&xmp, 0, sizeof(xmp));\n\txmp.level = XDL_MERGE_ZEALOUS;\n\txmp.favor = opts->variant;\n\txmp.xpp.flags = opts->xdl_opts;\n\tif (git_xmerge_style >= 0)\n\t\txmp.style = git_xmerge_style;\n\tif (marker_size > 0)\n\t\txmp.marker_size = marker_size;\n\txmp.ancestor = orig_name;\n\txmp.file1 = name1;\n\txmp.file2 = name2;\n\treturn xdl_merge(orig, src1, src2, &xmp, result);\n}\n\nstatic int ll_union_merge(const struct ll_merge_driver *drv_unused,\n\t\t\t  mmbuffer_t *result,\n\t\t\t  const char *path_unused,\n\t\t\t  mmfile_t *orig, const char *orig_name,\n\t\t\t  mmfile_t *src1, const char *name1,\n\t\t\t  mmfile_t *src2, const char *name2,\n\t\t\t  const struct ll_merge_options *opts,\n\t\t\t  int marker_size)\n{\n\t/* Use union favor */\n\tstruct ll_merge_options o;\n\tassert(opts);\n\to = *opts;\n\to.variant = XDL_MERGE_FAVOR_UNION;\n\treturn ll_xdl_merge(drv_unused, result, path_unused,\n\t\t\t    orig, NULL, src1, NULL, src2, NULL,\n\t\t\t    &o, marker_size);\n}\n\n#define LL_BINARY_MERGE 0\n#define LL_TEXT_MERGE 1\n#define LL_UNION_MERGE 2\nstatic struct ll_merge_driver ll_merge_drv[] = {\n\t{ \"binary\", \"built-in binary merge\", ll_binary_merge },\n\t{ \"text\", \"built-in 3-way text merge\", ll_xdl_merge },\n\t{ \"union\", \"built-in union merge\", ll_union_merge },\n};\n\nstatic void create_temp(mmfile_t *src, char *path)\n{\n\tint fd;\n\n\tstrcpy(path, \".merge_file_XXXXXX\");\n\tfd = xmkstemp(path);\n\tif (write_in_full(fd, src->ptr, src->size) != src->size)\n\t\tdie_errno(\"unable to write temp-file\");\n\tclose(fd);\n}\n\n/*\n * User defined low-level merge driver support.\n */\nstatic int ll_ext_merge(const struct ll_merge_driver *fn,\n\t\t\tmmbuffer_t *result,\n\t\t\tconst char *path,\n\t\t\tmmfile_t *orig, const char *orig_name,\n\t\t\tmmfile_t *src1, const char *name1,\n\t\t\tmmfile_t *src2, const char *name2,\n\t\t\tconst struct ll_merge_options *opts,\n\t\t\tint marker_size)\n{\n\tchar temp[4][50];\n\tstruct strbuf cmd = STRBUF_INIT;\n\tstruct strbuf_expand_dict_entry dict[5];\n\tconst char *args[] = { NULL, NULL };\n\tint status, fd, i;\n\tstruct stat st;\n\tassert(opts);\n\n\tdict[0].placeholder = \"O\"; dict[0].value = temp[0];\n\tdict[1].placeholder = \"A\"; dict[1].value = temp[1];\n\tdict[2].placeholder = \"B\"; dict[2].value = temp[2];\n\tdict[3].placeholder = \"L\"; dict[3].value = temp[3];\n\tdict[4].placeholder = NULL; dict[4].value = NULL;\n\n\tif (fn->cmdline == NULL)\n\t\tdie(\"custom merge driver %s lacks command line.\", fn->name);\n\n\tresult->ptr = NULL;\n\tresult->size = 0;\n\tcreate_temp(orig, temp[0]);\n\tcreate_temp(src1, temp[1]);\n\tcreate_temp(src2, temp[2]);\n\tsprintf(temp[3], \"%d\", marker_size);\n\n\tstrbuf_expand(&cmd, fn->cmdline, strbuf_expand_dict_cb, &dict);\n\n\targs[0] = cmd.buf;\n\tstatus = run_command_v_opt(args, RUN_USING_SHELL);\n\tfd = open(temp[1], O_RDONLY);\n\tif (fd < 0)\n\t\tgoto bad;\n\tif (fstat(fd, &st))\n\t\tgoto close_bad;\n\tresult->size = st.st_size;\n\tresult->ptr = xmalloc(result->size + 1);\n\tif (read_in_full(fd, result->ptr, result->size) != result->size) {\n\t\tfree(result->ptr);\n\t\tresult->ptr = NULL;\n\t\tresult->size = 0;\n\t}\n close_bad:\n\tclose(fd);\n bad:\n\tfor (i = 0; i < 3; i++)\n\t\tunlink_or_warn(temp[i]);\n\tstrbuf_release(&cmd);\n\treturn status;\n}\n\n/*\n * merge.default and merge.driver configuration items\n */\nstatic struct ll_merge_driver *ll_user_merge, **ll_user_merge_tail;\nstatic const char *default_ll_merge;\n\nstatic int read_merge_config(const char *var, const char *value, void *cb)\n{\n\tstruct ll_merge_driver *fn;\n\tconst char *ep, *name;\n\tint namelen;\n\n\tif (!strcmp(var, \"merge.default\")) {\n\t\tif (value)\n\t\t\tdefault_ll_merge = xstrdup(value);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We are not interested in anything but \"merge.<name>.variable\";\n\t * especially, we do not want to look at variables such as\n\t * \"merge.summary\", \"merge.tool\", and \"merge.verbosity\".\n\t */\n\tif (prefixcmp(var, \"merge.\") || (ep = strrchr(var, '.')) == var + 5)\n\t\treturn 0;\n\n\t/*\n\t * Find existing one as we might be processing merge.<name>.var2\n\t * after seeing merge.<name>.var1.\n\t */\n\tname = var + 6;\n\tnamelen = ep - name;\n\tfor (fn = ll_user_merge; fn; fn = fn->next)\n\t\tif (!strncmp(fn->name, name, namelen) && !fn->name[namelen])\n\t\t\tbreak;\n\tif (!fn) {\n\t\tfn = xcalloc(1, sizeof(struct ll_merge_driver));\n\t\tfn->name = xmemdupz(name, namelen);\n\t\tfn->fn = ll_ext_merge;\n\t\t*ll_user_merge_tail = fn;\n\t\tll_user_merge_tail = &(fn->next);\n\t}\n\n\tep++;\n\n\tif (!strcmp(\"name\", ep)) {\n\t\tif (!value)\n\t\t\treturn error(\"%s: lacks value\", var);\n\t\tfn->description = xstrdup(value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(\"driver\", ep)) {\n\t\tif (!value)\n\t\t\treturn error(\"%s: lacks value\", var);\n\t\t/*\n\t\t * merge.<name>.driver specifies the command line:\n\t\t *\n\t\t *\tcommand-line\n\t\t *\n\t\t * The command-line will be interpolated with the following\n\t\t * tokens and is given to the shell:\n\t\t *\n\t\t *    %O - temporary file name for the merge base.\n\t\t *    %A - temporary file name for our version.\n\t\t *    %B - temporary file name for the other branches' version.\n\t\t *    %L - conflict marker length\n\t\t *\n\t\t * The external merge driver should write the results in the\n\t\t * file named by %A, and signal that it has done with zero exit\n\t\t * status.\n\t\t */\n\t\tfn->cmdline = xstrdup(value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(\"recursive\", ep)) {\n\t\tif (!value)\n\t\t\treturn error(\"%s: lacks value\", var);\n\t\tfn->recursive = xstrdup(value);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void initialize_ll_merge(void)\n{\n\tif (ll_user_merge_tail)\n\t\treturn;\n\tll_user_merge_tail = &ll_user_merge;\n\tgit_config(read_merge_config, NULL);\n}\n\nstatic const struct ll_merge_driver *find_ll_merge_driver(const char *merge_attr)\n{\n\tstruct ll_merge_driver *fn;\n\tconst char *name;\n\tint i;\n\n\tinitialize_ll_merge();\n\n\tif (ATTR_TRUE(merge_attr))\n\t\treturn &ll_merge_drv[LL_TEXT_MERGE];\n\telse if (ATTR_FALSE(merge_attr))\n\t\treturn &ll_merge_drv[LL_BINARY_MERGE];\n\telse if (ATTR_UNSET(merge_attr)) {\n\t\tif (!default_ll_merge)\n\t\t\treturn &ll_merge_drv[LL_TEXT_MERGE];\n\t\telse\n\t\t\tname = default_ll_merge;\n\t}\n\telse\n\t\tname = merge_attr;\n\n\tfor (fn = ll_user_merge; fn; fn = fn->next)\n\t\tif (!strcmp(fn->name, name))\n\t\t\treturn fn;\n\n\tfor (i = 0; i < ARRAY_SIZE(ll_merge_drv); i++)\n\t\tif (!strcmp(ll_merge_drv[i].name, name))\n\t\t\treturn &ll_merge_drv[i];\n\n\t/* default to the 3-way */\n\treturn &ll_merge_drv[LL_TEXT_MERGE];\n}\n\nstatic int git_path_check_merge(const char *path, struct git_attr_check check[2])\n{\n\tif (!check[0].attr) {\n\t\tcheck[0].attr = git_attr(\"merge\");\n\t\tcheck[1].attr = git_attr(\"conflict-marker-size\");\n\t}\n\treturn git_checkattr(path, 2, check);\n}\n\nstatic void normalize_file(mmfile_t *mm, const char *path)\n{\n\tstruct strbuf strbuf = STRBUF_INIT;\n\tif (renormalize_buffer(path, mm->ptr, mm->size, &strbuf)) {\n\t\tfree(mm->ptr);\n\t\tmm->size = strbuf.len;\n\t\tmm->ptr = strbuf_detach(&strbuf, NULL);\n\t}\n}\n\nint ll_merge(mmbuffer_t *result_buf,\n\t     const char *path,\n\t     mmfile_t *ancestor, const char *ancestor_label,\n\t     mmfile_t *ours, const char *our_label,\n\t     mmfile_t *theirs, const char *their_label,\n\t     const struct ll_merge_options *opts)\n{\n\tstatic struct git_attr_check check[2];\n\tconst char *ll_driver_name = NULL;\n\tint marker_size = DEFAULT_CONFLICT_MARKER_SIZE;\n\tconst struct ll_merge_driver *driver;\n\n\tif (!opts) {\n\t\tstruct ll_merge_options default_opts = {0};\n\t\treturn ll_merge(result_buf, path, ancestor, ancestor_label,\n\t\t\t\tours, our_label, theirs, their_label,\n\t\t\t\t&default_opts);\n\t}\n\n\tif (opts->renormalize) {\n\t\tnormalize_file(ancestor, path);\n\t\tnormalize_file(ours, path);\n\t\tnormalize_file(theirs, path);\n\t}\n\tif (!git_path_check_merge(path, check)) {\n\t\tll_driver_name = check[0].value;\n\t\tif (check[1].value) {\n\t\t\tmarker_size = atoi(check[1].value);\n\t\t\tif (marker_size <= 0)\n\t\t\t\tmarker_size = DEFAULT_CONFLICT_MARKER_SIZE;\n\t\t}\n\t}\n\tdriver = find_ll_merge_driver(ll_driver_name);\n\tif (opts->virtual_ancestor && driver->recursive)\n\t\tdriver = find_ll_merge_driver(driver->recursive);\n\treturn driver->fn(driver, result_buf, path, ancestor, ancestor_label,\n\t\t\t  ours, our_label, theirs, their_label,\n\t\t\t  opts, marker_size);\n}\n\nint ll_merge_marker_size(const char *path)\n{\n\tstatic struct git_attr_check check;\n\tint marker_size = DEFAULT_CONFLICT_MARKER_SIZE;\n\n\tif (!check.attr)\n\t\tcheck.attr = git_attr(\"conflict-marker-size\");\n\tif (!git_checkattr(path, 1, &check) && check.value) {\n\t\tmarker_size = atoi(check.value);\n\t\tif (marker_size <= 0)\n\t\t\tmarker_size = DEFAULT_CONFLICT_MARKER_SIZE;\n\t}\n\treturn marker_size;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "007dd3e4d38ff657a29a06e559173b796f193763",
  "sha1_ok": true,
  "size": 10314
}
