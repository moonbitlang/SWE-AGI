{
  "content": {
    "base64": "I2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImNvbmZpZy5oIgojaW5jbHVkZSAibG9ja2ZpbGUuaCIKI2luY2x1ZGUgIm9iamVjdC1zdG9yZS5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJkaXIuaCIKI2luY2x1ZGUgInRyZWUtd2Fsay5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAicmV2aXNpb24uaCIKI2luY2x1ZGUgInJlYWNoYWJsZS5oIgoKLyogTkVFRFNXT1JLOiBzd2l0Y2ggdG8gdXNpbmcgcGFyc2Vfb3B0aW9ucyAqLwpzdGF0aWMgY29uc3QgY2hhciByZWZsb2dfZXhwaXJlX3VzYWdlW10gPQoiZ2l0IHJlZmxvZyBleHBpcmUgWy0tZXhwaXJlPTx0aW1lPl0gWy0tZXhwaXJlLXVucmVhY2hhYmxlPTx0aW1lPl0gWy0tcmV3cml0ZV0gWy0tdXBkYXRlcmVmXSBbLS1zdGFsZS1maXhdIFstLWRyeS1ydW4gfCAtbl0gWy0tdmVyYm9zZV0gWy0tYWxsXSA8cmVmcz4uLi4iOwpzdGF0aWMgY29uc3QgY2hhciByZWZsb2dfZGVsZXRlX3VzYWdlW10gPQoiZ2l0IHJlZmxvZyBkZWxldGUgWy0tcmV3cml0ZV0gWy0tdXBkYXRlcmVmXSBbLS1kcnktcnVuIHwgLW5dIFstLXZlcmJvc2VdIDxyZWZzPi4uLiI7CnN0YXRpYyBjb25zdCBjaGFyIHJlZmxvZ19leGlzdHNfdXNhZ2VbXSA9CiJnaXQgcmVmbG9nIGV4aXN0cyA8cmVmPiI7CgpzdGF0aWMgdGltZXN0YW1wX3QgZGVmYXVsdF9yZWZsb2dfZXhwaXJlOwpzdGF0aWMgdGltZXN0YW1wX3QgZGVmYXVsdF9yZWZsb2dfZXhwaXJlX3VucmVhY2hhYmxlOwoKc3RydWN0IGNtZF9yZWZsb2dfZXhwaXJlX2NiIHsKCXN0cnVjdCByZXZfaW5mbyByZXZzOwoJaW50IHN0YWxlZml4OwoJdGltZXN0YW1wX3QgZXhwaXJlX3RvdGFsOwoJdGltZXN0YW1wX3QgZXhwaXJlX3VucmVhY2hhYmxlOwoJaW50IHJlY25vOwp9OwoKc3RydWN0IGV4cGlyZV9yZWZsb2dfcG9saWN5X2NiIHsKCWVudW0gewoJCVVFX05PUk1BTCwKCQlVRV9BTFdBWVMsCgkJVUVfSEVBRAoJfSB1bnJlYWNoYWJsZV9leHBpcmVfa2luZDsKCXN0cnVjdCBjb21taXRfbGlzdCAqbWFya19saXN0OwoJdW5zaWduZWQgbG9uZyBtYXJrX2xpbWl0OwoJc3RydWN0IGNtZF9yZWZsb2dfZXhwaXJlX2NiIGNtZDsKCXN0cnVjdCBjb21taXQgKnRpcF9jb21taXQ7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnRpcHM7Cn07CgpzdHJ1Y3QgY29sbGVjdGVkX3JlZmxvZyB7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCWNoYXIgcmVmbG9nW0ZMRVhfQVJSQVldOwp9OwoKc3RydWN0IGNvbGxlY3RfcmVmbG9nX2NiIHsKCXN0cnVjdCBjb2xsZWN0ZWRfcmVmbG9nICoqZTsKCWludCBhbGxvYzsKCWludCBucjsKfTsKCi8qIFJlbWVtYmVyIHRvIHVwZGF0ZSBvYmplY3QgZmxhZyBhbGxvY2F0aW9uIGluIG9iamVjdC5oICovCiNkZWZpbmUgSU5DT01QTEVURQkoMXU8PDEwKQojZGVmaW5lIFNUVURZSU5HCSgxdTw8MTEpCiNkZWZpbmUgUkVBQ0hBQkxFCSgxdTw8MTIpCgpzdGF0aWMgaW50IHRyZWVfaXNfY29tcGxldGUoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglzdHJ1Y3QgdHJlZV9kZXNjIGRlc2M7CglzdHJ1Y3QgbmFtZV9lbnRyeSBlbnRyeTsKCWludCBjb21wbGV0ZTsKCXN0cnVjdCB0cmVlICp0cmVlOwoKCXRyZWUgPSBsb29rdXBfdHJlZShvaWQpOwoJaWYgKCF0cmVlKQoJCXJldHVybiAwOwoJaWYgKHRyZWUtPm9iamVjdC5mbGFncyAmIFNFRU4pCgkJcmV0dXJuIDE7CglpZiAodHJlZS0+b2JqZWN0LmZsYWdzICYgSU5DT01QTEVURSkKCQlyZXR1cm4gMDsKCglpZiAoIXRyZWUtPmJ1ZmZlcikgewoJCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCQl1bnNpZ25lZCBsb25nIHNpemU7CgkJdm9pZCAqZGF0YSA9IHJlYWRfb2JqZWN0X2ZpbGUob2lkLCAmdHlwZSwgJnNpemUpOwoJCWlmICghZGF0YSkgewoJCQl0cmVlLT5vYmplY3QuZmxhZ3MgfD0gSU5DT01QTEVURTsKCQkJcmV0dXJuIDA7CgkJfQoJCXRyZWUtPmJ1ZmZlciA9IGRhdGE7CgkJdHJlZS0+c2l6ZSA9IHNpemU7Cgl9Cglpbml0X3RyZWVfZGVzYygmZGVzYywgdHJlZS0+YnVmZmVyLCB0cmVlLT5zaXplKTsKCWNvbXBsZXRlID0gMTsKCXdoaWxlICh0cmVlX2VudHJ5KCZkZXNjLCAmZW50cnkpKSB7CgkJaWYgKCFoYXNfc2hhMV9maWxlKGVudHJ5Lm9pZC0+aGFzaCkgfHwKCQkgICAgKFNfSVNESVIoZW50cnkubW9kZSkgJiYgIXRyZWVfaXNfY29tcGxldGUoZW50cnkub2lkKSkpIHsKCQkJdHJlZS0+b2JqZWN0LmZsYWdzIHw9IElOQ09NUExFVEU7CgkJCWNvbXBsZXRlID0gMDsKCQl9Cgl9CglmcmVlX3RyZWVfYnVmZmVyKHRyZWUpOwoKCWlmIChjb21wbGV0ZSkKCQl0cmVlLT5vYmplY3QuZmxhZ3MgfD0gU0VFTjsKCXJldHVybiBjb21wbGV0ZTsKfQoKc3RhdGljIGludCBjb21taXRfaXNfY29tcGxldGUoc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglzdHJ1Y3Qgb2JqZWN0X2FycmF5IHN0dWR5OwoJc3RydWN0IG9iamVjdF9hcnJheSBmb3VuZDsKCWludCBpc19pbmNvbXBsZXRlID0gMDsKCWludCBpOwoKCS8qIGVhcmx5IHJldHVybiAqLwoJaWYgKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgU0VFTikKCQlyZXR1cm4gMTsKCWlmIChjb21taXQtPm9iamVjdC5mbGFncyAmIElOQ09NUExFVEUpCgkJcmV0dXJuIDA7CgkvKgoJICogRmluZCBhbGwgY29tbWl0cyB0aGF0IGFyZSByZWFjaGFibGUgYW5kIGFyZSBub3QgbWFya2VkIGFzCgkgKiBTRUVOLiAgVGhlbiBtYWtlIHN1cmUgdGhlIHRyZWVzIGFuZCBibG9icyBjb250YWluZWQgYXJlCgkgKiBjb21wbGV0ZS4gIEFmdGVyIHRoYXQsIG1hcmsgdGhlc2UgY29tbWl0cyBhbHNvIGFzIFNFRU4uCgkgKiBJZiBzb21lIG9mIHRoZSBvYmplY3RzIHRoYXQgYXJlIG5lZWRlZCB0byBjb21wbGV0ZSB0aGlzCgkgKiBjb21taXQgYXJlIG1pc3NpbmcsIG1hcmsgdGhpcyBjb21taXQgYXMgSU5DT01QTEVURS4KCSAqLwoJbWVtc2V0KCZzdHVkeSwgMCwgc2l6ZW9mKHN0dWR5KSk7CgltZW1zZXQoJmZvdW5kLCAwLCBzaXplb2YoZm91bmQpKTsKCWFkZF9vYmplY3RfYXJyYXkoJmNvbW1pdC0+b2JqZWN0LCBOVUxMLCAmc3R1ZHkpOwoJYWRkX29iamVjdF9hcnJheSgmY29tbWl0LT5vYmplY3QsIE5VTEwsICZmb3VuZCk7Cgljb21taXQtPm9iamVjdC5mbGFncyB8PSBTVFVEWUlORzsKCXdoaWxlIChzdHVkeS5ucikgewoJCXN0cnVjdCBjb21taXQgKmM7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnQ7CgoJCWMgPSAoc3RydWN0IGNvbW1pdCAqKW9iamVjdF9hcnJheV9wb3AoJnN0dWR5KTsKCQlpZiAoIWMtPm9iamVjdC5wYXJzZWQgJiYgIXBhcnNlX29iamVjdCgmYy0+b2JqZWN0Lm9pZCkpCgkJCWMtPm9iamVjdC5mbGFncyB8PSBJTkNPTVBMRVRFOwoKCQlpZiAoYy0+b2JqZWN0LmZsYWdzICYgSU5DT01QTEVURSkgewoJCQlpc19pbmNvbXBsZXRlID0gMTsKCQkJYnJlYWs7CgkJfQoJCWVsc2UgaWYgKGMtPm9iamVjdC5mbGFncyAmIFNFRU4pCgkJCWNvbnRpbnVlOwoJCWZvciAocGFyZW50ID0gYy0+cGFyZW50czsgcGFyZW50OyBwYXJlbnQgPSBwYXJlbnQtPm5leHQpIHsKCQkJc3RydWN0IGNvbW1pdCAqcCA9IHBhcmVudC0+aXRlbTsKCQkJaWYgKHAtPm9iamVjdC5mbGFncyAmIFNUVURZSU5HKQoJCQkJY29udGludWU7CgkJCXAtPm9iamVjdC5mbGFncyB8PSBTVFVEWUlORzsKCQkJYWRkX29iamVjdF9hcnJheSgmcC0+b2JqZWN0LCBOVUxMLCAmc3R1ZHkpOwoJCQlhZGRfb2JqZWN0X2FycmF5KCZwLT5vYmplY3QsIE5VTEwsICZmb3VuZCk7CgkJfQoJfQoJaWYgKCFpc19pbmNvbXBsZXRlKSB7CgkJLyoKCQkgKiBtYWtlIHN1cmUgYWxsIGNvbW1pdHMgaW4gImZvdW5kIiBhcnJheSBoYXZlIGFsbCB0aGUKCQkgKiBuZWNlc3Nhcnkgb2JqZWN0cy4KCQkgKi8KCQlmb3IgKGkgPSAwOyBpIDwgZm91bmQubnI7IGkrKykgewoJCQlzdHJ1Y3QgY29tbWl0ICpjID0KCQkJCShzdHJ1Y3QgY29tbWl0ICopZm91bmQub2JqZWN0c1tpXS5pdGVtOwoJCQlpZiAoIXRyZWVfaXNfY29tcGxldGUoZ2V0X2NvbW1pdF90cmVlX29pZChjKSkpIHsKCQkJCWlzX2luY29tcGxldGUgPSAxOwoJCQkJYy0+b2JqZWN0LmZsYWdzIHw9IElOQ09NUExFVEU7CgkJCX0KCQl9CgkJaWYgKCFpc19pbmNvbXBsZXRlKSB7CgkJCS8qIG1hcmsgYWxsIGZvdW5kIGNvbW1pdHMgYXMgY29tcGxldGUsIGlvdyBTRUVOICovCgkJCWZvciAoaSA9IDA7IGkgPCBmb3VuZC5ucjsgaSsrKQoJCQkJZm91bmQub2JqZWN0c1tpXS5pdGVtLT5mbGFncyB8PSBTRUVOOwoJCX0KCX0KCS8qIGNsZWFyIGZsYWdzIGZyb20gdGhlIG9iamVjdHMgd2UgdHJhdmVyc2VkICovCglmb3IgKGkgPSAwOyBpIDwgZm91bmQubnI7IGkrKykKCQlmb3VuZC5vYmplY3RzW2ldLml0ZW0tPmZsYWdzICY9IH5TVFVEWUlORzsKCWlmIChpc19pbmNvbXBsZXRlKQoJCWNvbW1pdC0+b2JqZWN0LmZsYWdzIHw9IElOQ09NUExFVEU7CgllbHNlIHsKCQkvKgoJCSAqIElmIHdlIGNvbWUgaGVyZSwgd2UgaGF2ZSAoMSkgdHJhdmVyc2VkIHRoZSBhbmNlc3RyeSBjaGFpbgoJCSAqIGZyb20gdGhlICJjb21taXQiIHVudGlsIHdlIHJlYWNoIFNFRU4gY29tbWl0cyAod2hpY2ggYXJlCgkJICoga25vd24gdG8gYmUgY29tcGxldGUpLCBhbmQgKDIpIG1hZGUgc3VyZSB0aGF0IHRoZSBjb21taXRzCgkJICogZW5jb3VudGVyZWQgZHVyaW5nIHRoZSBhYm92ZSB0cmF2ZXJzYWwgcmVmZXIgdG8gdHJlZXMgdGhhdAoJCSAqIGFyZSBjb21wbGV0ZS4gIFdoaWNoIG1lYW5zIHRoYXQgd2Uga25vdyAqYWxsKiB0aGUgY29tbWl0cwoJCSAqIHdlIGhhdmUgc2VlbiBkdXJpbmcgdGhpcyBwcm9jZXNzIGFyZSBjb21wbGV0ZS4KCQkgKi8KCQlmb3IgKGkgPSAwOyBpIDwgZm91bmQubnI7IGkrKykKCQkJZm91bmQub2JqZWN0c1tpXS5pdGVtLT5mbGFncyB8PSBTRUVOOwoJfQoJLyogZnJlZSBvYmplY3QgYXJyYXlzICovCglvYmplY3RfYXJyYXlfY2xlYXIoJnN0dWR5KTsKCW9iamVjdF9hcnJheV9jbGVhcigmZm91bmQpOwoJcmV0dXJuICFpc19pbmNvbXBsZXRlOwp9CgpzdGF0aWMgaW50IGtlZXBfZW50cnkoc3RydWN0IGNvbW1pdCAqKml0LCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCglpZiAoaXNfbnVsbF9vaWQob2lkKSkKCQlyZXR1cm4gMTsKCWNvbW1pdCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseShvaWQsIDEpOwoJaWYgKCFjb21taXQpCgkJcmV0dXJuIDA7CgoJLyoKCSAqIE1ha2Ugc3VyZSBldmVyeXRoaW5nIGluIHRoaXMgY29tbWl0IGV4aXN0cy4KCSAqCgkgKiBXZSBoYXZlIHdhbGtlZCBhbGwgdGhlIG9iamVjdHMgcmVhY2hhYmxlIGZyb20gdGhlIHJlZnMKCSAqIGFuZCBjYWNoZSBlYXJsaWVyLiAgVGhlIGNvbW1pdHMgcmVhY2hhYmxlIGJ5IHRoaXMgY29tbWl0CgkgKiBtdXN0IG1lZXQgU0VFTiBjb21taXRzIC0tIGFuZCB0aGVuIHdlIHNob3VsZCBtYXJrIHRoZW0gYXMKCSAqIFNFRU4gYXMgd2VsbC4KCSAqLwoJaWYgKCFjb21taXRfaXNfY29tcGxldGUoY29tbWl0KSkKCQlyZXR1cm4gMDsKCSppdCA9IGNvbW1pdDsKCXJldHVybiAxOwp9CgovKgogKiBTdGFydGluZyBmcm9tIGNvbW1pdHMgaW4gdGhlIGNiLT5tYXJrX2xpc3QsIG1hcmsgY29tbWl0cyB0aGF0IGFyZQogKiByZWFjaGFibGUgZnJvbSB0aGVtLiAgU3RvcCB0aGUgdHJhdmVyc2FsIGF0IGNvbW1pdHMgb2xkZXIgdGhhbgogKiB0aGUgZXhwaXJlX2xpbWl0IGFuZCBxdWV1ZSB0aGVtIGJhY2ssIHNvIHRoYXQgdGhlIGNhbGxlciBjYW4gY2FsbAogKiB1cyBhZ2FpbiB0byByZXN0YXJ0IHRoZSB0cmF2ZXJzYWwgd2l0aCBsb25nZXIgZXhwaXJlX2xpbWl0LgogKi8Kc3RhdGljIHZvaWQgbWFya19yZWFjaGFibGUoc3RydWN0IGV4cGlyZV9yZWZsb2dfcG9saWN5X2NiICpjYikKewoJc3RydWN0IGNvbW1pdF9saXN0ICpwZW5kaW5nOwoJdGltZXN0YW1wX3QgZXhwaXJlX2xpbWl0ID0gY2ItPm1hcmtfbGltaXQ7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKmxlZnRvdmVyID0gTlVMTDsKCglmb3IgKHBlbmRpbmcgPSBjYi0+bWFya19saXN0OyBwZW5kaW5nOyBwZW5kaW5nID0gcGVuZGluZy0+bmV4dCkKCQlwZW5kaW5nLT5pdGVtLT5vYmplY3QuZmxhZ3MgJj0gflJFQUNIQUJMRTsKCglwZW5kaW5nID0gY2ItPm1hcmtfbGlzdDsKCXdoaWxlIChwZW5kaW5nKSB7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnQ7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gcG9wX2NvbW1pdCgmcGVuZGluZyk7CgkJaWYgKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgUkVBQ0hBQkxFKQoJCQljb250aW51ZTsKCQlpZiAocGFyc2VfY29tbWl0KGNvbW1pdCkpCgkJCWNvbnRpbnVlOwoJCWNvbW1pdC0+b2JqZWN0LmZsYWdzIHw9IFJFQUNIQUJMRTsKCQlpZiAoY29tbWl0LT5kYXRlIDwgZXhwaXJlX2xpbWl0KSB7CgkJCWNvbW1pdF9saXN0X2luc2VydChjb21taXQsICZsZWZ0b3Zlcik7CgkJCWNvbnRpbnVlOwoJCX0KCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBSRUFDSEFCTEU7CgkJcGFyZW50ID0gY29tbWl0LT5wYXJlbnRzOwoJCXdoaWxlIChwYXJlbnQpIHsKCQkJY29tbWl0ID0gcGFyZW50LT5pdGVtOwoJCQlwYXJlbnQgPSBwYXJlbnQtPm5leHQ7CgkJCWlmIChjb21taXQtPm9iamVjdC5mbGFncyAmIFJFQUNIQUJMRSkKCQkJCWNvbnRpbnVlOwoJCQljb21taXRfbGlzdF9pbnNlcnQoY29tbWl0LCAmcGVuZGluZyk7CgkJfQoJfQoJY2ItPm1hcmtfbGlzdCA9IGxlZnRvdmVyOwp9CgpzdGF0aWMgaW50IHVucmVhY2hhYmxlKHN0cnVjdCBleHBpcmVfcmVmbG9nX3BvbGljeV9jYiAqY2IsIHN0cnVjdCBjb21taXQgKmNvbW1pdCwgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CgkvKgoJICogV2UgbWF5IG9yIG1heSBub3QgaGF2ZSB0aGUgY29tbWl0IHlldCAtIGlmIG5vdCwgbG9vayBpdAoJICogdXAgdXNpbmcgdGhlIHN1cHBsaWVkIHNoYTEuCgkgKi8KCWlmICghY29tbWl0KSB7CgkJaWYgKGlzX251bGxfb2lkKG9pZCkpCgkJCXJldHVybiAwOwoKCQljb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkob2lkLCAxKTsKCgkJLyogTm90IGEgY29tbWl0IC0tIGtlZXAgaXQgKi8KCQlpZiAoIWNvbW1pdCkKCQkJcmV0dXJuIDA7Cgl9CgoJLyogUmVhY2hhYmxlIGZyb20gdGhlIGN1cnJlbnQgcmVmPyAgRG9uJ3QgcHJ1bmUuICovCglpZiAoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBSRUFDSEFCTEUpCgkJcmV0dXJuIDA7CgoJaWYgKGNiLT5tYXJrX2xpc3QgJiYgY2ItPm1hcmtfbGltaXQpIHsKCQljYi0+bWFya19saW1pdCA9IDA7IC8qIGRpZyBkb3duIHRvIHRoZSByb290ICovCgkJbWFya19yZWFjaGFibGUoY2IpOwoJfQoKCXJldHVybiAhKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgUkVBQ0hBQkxFKTsKfQoKLyoKICogUmV0dXJuIHRydWUgaWZmIHRoZSBzcGVjaWZpZWQgcmVmbG9nIGVudHJ5IHNob3VsZCBiZSBleHBpcmVkLgogKi8Kc3RhdGljIGludCBzaG91bGRfZXhwaXJlX3JlZmxvZ19lbnQoc3RydWN0IG9iamVjdF9pZCAqb29pZCwgc3RydWN0IG9iamVjdF9pZCAqbm9pZCwKCQkJCSAgICBjb25zdCBjaGFyICplbWFpbCwgdGltZXN0YW1wX3QgdGltZXN0YW1wLCBpbnQgdHosCgkJCQkgICAgY29uc3QgY2hhciAqbWVzc2FnZSwgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IGV4cGlyZV9yZWZsb2dfcG9saWN5X2NiICpjYiA9IGNiX2RhdGE7CglzdHJ1Y3QgY29tbWl0ICpvbGRfY29tbWl0LCAqbmV3X2NvbW1pdDsKCglpZiAodGltZXN0YW1wIDwgY2ItPmNtZC5leHBpcmVfdG90YWwpCgkJcmV0dXJuIDE7CgoJb2xkX2NvbW1pdCA9IG5ld19jb21taXQgPSBOVUxMOwoJaWYgKGNiLT5jbWQuc3RhbGVmaXggJiYKCSAgICAoIWtlZXBfZW50cnkoJm9sZF9jb21taXQsIG9vaWQpIHx8ICFrZWVwX2VudHJ5KCZuZXdfY29tbWl0LCBub2lkKSkpCgkJcmV0dXJuIDE7CgoJaWYgKHRpbWVzdGFtcCA8IGNiLT5jbWQuZXhwaXJlX3VucmVhY2hhYmxlKSB7CgkJaWYgKGNiLT51bnJlYWNoYWJsZV9leHBpcmVfa2luZCA9PSBVRV9BTFdBWVMpCgkJCXJldHVybiAxOwoJCWlmICh1bnJlYWNoYWJsZShjYiwgb2xkX2NvbW1pdCwgb29pZCkgfHwgdW5yZWFjaGFibGUoY2IsIG5ld19jb21taXQsIG5vaWQpKQoJCQlyZXR1cm4gMTsKCX0KCglpZiAoY2ItPmNtZC5yZWNubyAmJiAtLShjYi0+Y21kLnJlY25vKSA9PSAwKQoJCXJldHVybiAxOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHB1c2hfdGlwX3RvX2xpc3QoY29uc3QgY2hhciAqcmVmbmFtZSwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgICAgaW50IGZsYWdzLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKipsaXN0ID0gY2JfZGF0YTsKCXN0cnVjdCBjb21taXQgKnRpcF9jb21taXQ7CglpZiAoZmxhZ3MgJiBSRUZfSVNTWU1SRUYpCgkJcmV0dXJuIDA7Cgl0aXBfY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfZ2VudGx5KG9pZCwgMSk7CglpZiAoIXRpcF9jb21taXQpCgkJcmV0dXJuIDA7Cgljb21taXRfbGlzdF9pbnNlcnQodGlwX2NvbW1pdCwgbGlzdCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgcmVmbG9nX2V4cGlyeV9wcmVwYXJlKGNvbnN0IGNoYXIgKnJlZm5hbWUsCgkJCQkgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCSAgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IGV4cGlyZV9yZWZsb2dfcG9saWN5X2NiICpjYiA9IGNiX2RhdGE7CgoJaWYgKCFjYi0+Y21kLmV4cGlyZV91bnJlYWNoYWJsZSB8fCAhc3RyY21wKHJlZm5hbWUsICJIRUFEIikpIHsKCQljYi0+dGlwX2NvbW1pdCA9IE5VTEw7CgkJY2ItPnVucmVhY2hhYmxlX2V4cGlyZV9raW5kID0gVUVfSEVBRDsKCX0gZWxzZSB7CgkJY2ItPnRpcF9jb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkob2lkLCAxKTsKCQlpZiAoIWNiLT50aXBfY29tbWl0KQoJCQljYi0+dW5yZWFjaGFibGVfZXhwaXJlX2tpbmQgPSBVRV9BTFdBWVM7CgkJZWxzZQoJCQljYi0+dW5yZWFjaGFibGVfZXhwaXJlX2tpbmQgPSBVRV9OT1JNQUw7Cgl9CgoJaWYgKGNiLT5jbWQuZXhwaXJlX3VucmVhY2hhYmxlIDw9IGNiLT5jbWQuZXhwaXJlX3RvdGFsKQoJCWNiLT51bnJlYWNoYWJsZV9leHBpcmVfa2luZCA9IFVFX0FMV0FZUzsKCgljYi0+bWFya19saXN0ID0gTlVMTDsKCWNiLT50aXBzID0gTlVMTDsKCWlmIChjYi0+dW5yZWFjaGFibGVfZXhwaXJlX2tpbmQgIT0gVUVfQUxXQVlTKSB7CgkJaWYgKGNiLT51bnJlYWNoYWJsZV9leHBpcmVfa2luZCA9PSBVRV9IRUFEKSB7CgkJCXN0cnVjdCBjb21taXRfbGlzdCAqZWxlbTsKCgkJCWZvcl9lYWNoX3JlZihwdXNoX3RpcF90b19saXN0LCAmY2ItPnRpcHMpOwoJCQlmb3IgKGVsZW0gPSBjYi0+dGlwczsgZWxlbTsgZWxlbSA9IGVsZW0tPm5leHQpCgkJCQljb21taXRfbGlzdF9pbnNlcnQoZWxlbS0+aXRlbSwgJmNiLT5tYXJrX2xpc3QpOwoJCX0gZWxzZSB7CgkJCWNvbW1pdF9saXN0X2luc2VydChjYi0+dGlwX2NvbW1pdCwgJmNiLT5tYXJrX2xpc3QpOwoJCX0KCQljYi0+bWFya19saW1pdCA9IGNiLT5jbWQuZXhwaXJlX3RvdGFsOwoJCW1hcmtfcmVhY2hhYmxlKGNiKTsKCX0KfQoKc3RhdGljIHZvaWQgcmVmbG9nX2V4cGlyeV9jbGVhbnVwKHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBleHBpcmVfcmVmbG9nX3BvbGljeV9jYiAqY2IgPSBjYl9kYXRhOwoKCWlmIChjYi0+dW5yZWFjaGFibGVfZXhwaXJlX2tpbmQgIT0gVUVfQUxXQVlTKSB7CgkJaWYgKGNiLT51bnJlYWNoYWJsZV9leHBpcmVfa2luZCA9PSBVRV9IRUFEKSB7CgkJCXN0cnVjdCBjb21taXRfbGlzdCAqZWxlbTsKCQkJZm9yIChlbGVtID0gY2ItPnRpcHM7IGVsZW07IGVsZW0gPSBlbGVtLT5uZXh0KQoJCQkJY2xlYXJfY29tbWl0X21hcmtzKGVsZW0tPml0ZW0sIFJFQUNIQUJMRSk7CgkJCWZyZWVfY29tbWl0X2xpc3QoY2ItPnRpcHMpOwoJCX0gZWxzZSB7CgkJCWNsZWFyX2NvbW1pdF9tYXJrcyhjYi0+dGlwX2NvbW1pdCwgUkVBQ0hBQkxFKTsKCQl9Cgl9Cn0KCnN0YXRpYyBpbnQgY29sbGVjdF9yZWZsb2coY29uc3QgY2hhciAqcmVmLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGludCB1bnVzZWQsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBjb2xsZWN0ZWRfcmVmbG9nICplOwoJc3RydWN0IGNvbGxlY3RfcmVmbG9nX2NiICpjYiA9IGNiX2RhdGE7CgoJRkxFWF9BTExPQ19TVFIoZSwgcmVmbG9nLCByZWYpOwoJb2lkY3B5KCZlLT5vaWQsIG9pZCk7CglBTExPQ19HUk9XKGNiLT5lLCBjYi0+bnIgKyAxLCBjYi0+YWxsb2MpOwoJY2ItPmVbY2ItPm5yKytdID0gZTsKCXJldHVybiAwOwp9CgpzdGF0aWMgc3RydWN0IHJlZmxvZ19leHBpcmVfY2ZnIHsKCXN0cnVjdCByZWZsb2dfZXhwaXJlX2NmZyAqbmV4dDsKCXRpbWVzdGFtcF90IGV4cGlyZV90b3RhbDsKCXRpbWVzdGFtcF90IGV4cGlyZV91bnJlYWNoYWJsZTsKCWNoYXIgcGF0dGVybltGTEVYX0FSUkFZXTsKfSAqcmVmbG9nX2V4cGlyZV9jZmcsICoqcmVmbG9nX2V4cGlyZV9jZmdfdGFpbDsKCnN0YXRpYyBzdHJ1Y3QgcmVmbG9nX2V4cGlyZV9jZmcgKmZpbmRfY2ZnX2VudChjb25zdCBjaGFyICpwYXR0ZXJuLCBzaXplX3QgbGVuKQp7CglzdHJ1Y3QgcmVmbG9nX2V4cGlyZV9jZmcgKmVudDsKCglpZiAoIXJlZmxvZ19leHBpcmVfY2ZnX3RhaWwpCgkJcmVmbG9nX2V4cGlyZV9jZmdfdGFpbCA9ICZyZWZsb2dfZXhwaXJlX2NmZzsKCglmb3IgKGVudCA9IHJlZmxvZ19leHBpcmVfY2ZnOyBlbnQ7IGVudCA9IGVudC0+bmV4dCkKCQlpZiAoIXN0cm5jbXAoZW50LT5wYXR0ZXJuLCBwYXR0ZXJuLCBsZW4pICYmCgkJICAgIGVudC0+cGF0dGVybltsZW5dID09ICdcMCcpCgkJCXJldHVybiBlbnQ7CgoJRkxFWF9BTExPQ19NRU0oZW50LCBwYXR0ZXJuLCBwYXR0ZXJuLCBsZW4pOwoJKnJlZmxvZ19leHBpcmVfY2ZnX3RhaWwgPSBlbnQ7CglyZWZsb2dfZXhwaXJlX2NmZ190YWlsID0gJihlbnQtPm5leHQpOwoJcmV0dXJuIGVudDsKfQoKLyogZXhwaXJ5IHRpbWVyIHNsb3QgKi8KI2RlZmluZSBFWFBJUkVfVE9UQUwgICAwMQojZGVmaW5lIEVYUElSRV9VTlJFQUNIIDAyCgpzdGF0aWMgaW50IHJlZmxvZ19leHBpcmVfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmNiKQp7Cgljb25zdCBjaGFyICpwYXR0ZXJuLCAqa2V5OwoJaW50IHBhdHRlcm5fbGVuOwoJdGltZXN0YW1wX3QgZXhwaXJlOwoJaW50IHNsb3Q7CglzdHJ1Y3QgcmVmbG9nX2V4cGlyZV9jZmcgKmVudDsKCglpZiAocGFyc2VfY29uZmlnX2tleSh2YXIsICJnYyIsICZwYXR0ZXJuLCAmcGF0dGVybl9sZW4sICZrZXkpIDwgMCkKCQlyZXR1cm4gZ2l0X2RlZmF1bHRfY29uZmlnKHZhciwgdmFsdWUsIGNiKTsKCglpZiAoIXN0cmNtcChrZXksICJyZWZsb2dleHBpcmUiKSkgewoJCXNsb3QgPSBFWFBJUkVfVE9UQUw7CgkJaWYgKGdpdF9jb25maWdfZXhwaXJ5X2RhdGUoJmV4cGlyZSwgdmFyLCB2YWx1ZSkpCgkJCXJldHVybiAtMTsKCX0gZWxzZSBpZiAoIXN0cmNtcChrZXksICJyZWZsb2dleHBpcmV1bnJlYWNoYWJsZSIpKSB7CgkJc2xvdCA9IEVYUElSRV9VTlJFQUNIOwoJCWlmIChnaXRfY29uZmlnX2V4cGlyeV9kYXRlKCZleHBpcmUsIHZhciwgdmFsdWUpKQoJCQlyZXR1cm4gLTE7Cgl9IGVsc2UKCQlyZXR1cm4gZ2l0X2RlZmF1bHRfY29uZmlnKHZhciwgdmFsdWUsIGNiKTsKCglpZiAoIXBhdHRlcm4pIHsKCQlzd2l0Y2ggKHNsb3QpIHsKCQljYXNlIEVYUElSRV9UT1RBTDoKCQkJZGVmYXVsdF9yZWZsb2dfZXhwaXJlID0gZXhwaXJlOwoJCQlicmVhazsKCQljYXNlIEVYUElSRV9VTlJFQUNIOgoJCQlkZWZhdWx0X3JlZmxvZ19leHBpcmVfdW5yZWFjaGFibGUgPSBleHBpcmU7CgkJCWJyZWFrOwoJCX0KCQlyZXR1cm4gMDsKCX0KCgllbnQgPSBmaW5kX2NmZ19lbnQocGF0dGVybiwgcGF0dGVybl9sZW4pOwoJaWYgKCFlbnQpCgkJcmV0dXJuIC0xOwoJc3dpdGNoIChzbG90KSB7CgljYXNlIEVYUElSRV9UT1RBTDoKCQllbnQtPmV4cGlyZV90b3RhbCA9IGV4cGlyZTsKCQlicmVhazsKCWNhc2UgRVhQSVJFX1VOUkVBQ0g6CgkJZW50LT5leHBpcmVfdW5yZWFjaGFibGUgPSBleHBpcmU7CgkJYnJlYWs7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgc2V0X3JlZmxvZ19leHBpcnlfcGFyYW0oc3RydWN0IGNtZF9yZWZsb2dfZXhwaXJlX2NiICpjYiwgaW50IHNsb3QsIGNvbnN0IGNoYXIgKnJlZikKewoJc3RydWN0IHJlZmxvZ19leHBpcmVfY2ZnICplbnQ7CgoJaWYgKHNsb3QgPT0gKEVYUElSRV9UT1RBTHxFWFBJUkVfVU5SRUFDSCkpCgkJcmV0dXJuOyAvKiBib3RoIGdpdmVuIGV4cGxpY2l0bHkgLS0gbm90aGluZyB0byB0d2VhayAqLwoKCWZvciAoZW50ID0gcmVmbG9nX2V4cGlyZV9jZmc7IGVudDsgZW50ID0gZW50LT5uZXh0KSB7CgkJaWYgKCF3aWxkbWF0Y2goZW50LT5wYXR0ZXJuLCByZWYsIDApKSB7CgkJCWlmICghKHNsb3QgJiBFWFBJUkVfVE9UQUwpKQoJCQkJY2ItPmV4cGlyZV90b3RhbCA9IGVudC0+ZXhwaXJlX3RvdGFsOwoJCQlpZiAoIShzbG90ICYgRVhQSVJFX1VOUkVBQ0gpKQoJCQkJY2ItPmV4cGlyZV91bnJlYWNoYWJsZSA9IGVudC0+ZXhwaXJlX3VucmVhY2hhYmxlOwoJCQlyZXR1cm47CgkJfQoJfQoKCS8qCgkgKiBJZiB1bmNvbmZpZ3VyZWQsIG1ha2Ugc3Rhc2ggbmV2ZXIgZXhwaXJlCgkgKi8KCWlmICghc3RyY21wKHJlZiwgInJlZnMvc3Rhc2giKSkgewoJCWlmICghKHNsb3QgJiBFWFBJUkVfVE9UQUwpKQoJCQljYi0+ZXhwaXJlX3RvdGFsID0gMDsKCQlpZiAoIShzbG90ICYgRVhQSVJFX1VOUkVBQ0gpKQoJCQljYi0+ZXhwaXJlX3VucmVhY2hhYmxlID0gMDsKCQlyZXR1cm47Cgl9CgoJLyogTm90aGluZyBtYXRjaGVkIC0tIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSAqLwoJaWYgKCEoc2xvdCAmIEVYUElSRV9UT1RBTCkpCgkJY2ItPmV4cGlyZV90b3RhbCA9IGRlZmF1bHRfcmVmbG9nX2V4cGlyZTsKCWlmICghKHNsb3QgJiBFWFBJUkVfVU5SRUFDSCkpCgkJY2ItPmV4cGlyZV91bnJlYWNoYWJsZSA9IGRlZmF1bHRfcmVmbG9nX2V4cGlyZV91bnJlYWNoYWJsZTsKfQoKc3RhdGljIGludCBjbWRfcmVmbG9nX2V4cGlyZShpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IGV4cGlyZV9yZWZsb2dfcG9saWN5X2NiIGNiOwoJdGltZXN0YW1wX3Qgbm93ID0gdGltZShOVUxMKTsKCWludCBpLCBzdGF0dXMsIGRvX2FsbDsKCWludCBleHBsaWNpdF9leHBpcnkgPSAwOwoJdW5zaWduZWQgaW50IGZsYWdzID0gMDsKCglkZWZhdWx0X3JlZmxvZ19leHBpcmVfdW5yZWFjaGFibGUgPSBub3cgLSAzMCAqIDI0ICogMzYwMDsKCWRlZmF1bHRfcmVmbG9nX2V4cGlyZSA9IG5vdyAtIDkwICogMjQgKiAzNjAwOwoJZ2l0X2NvbmZpZyhyZWZsb2dfZXhwaXJlX2NvbmZpZywgTlVMTCk7CgoJc2F2ZV9jb21taXRfYnVmZmVyID0gMDsKCWRvX2FsbCA9IHN0YXR1cyA9IDA7CgltZW1zZXQoJmNiLCAwLCBzaXplb2YoY2IpKTsKCgljYi5jbWQuZXhwaXJlX3RvdGFsID0gZGVmYXVsdF9yZWZsb2dfZXhwaXJlOwoJY2IuY21kLmV4cGlyZV91bnJlYWNoYWJsZSA9IGRlZmF1bHRfcmVmbG9nX2V4cGlyZV91bnJlYWNoYWJsZTsKCglmb3IgKGkgPSAxOyBpIDwgYXJnYzsgaSsrKSB7CgkJY29uc3QgY2hhciAqYXJnID0gYXJndltpXTsKCQlpZiAoIXN0cmNtcChhcmcsICItLWRyeS1ydW4iKSB8fCAhc3RyY21wKGFyZywgIi1uIikpCgkJCWZsYWdzIHw9IEVYUElSRV9SRUZMT0dTX0RSWV9SVU47CgkJZWxzZSBpZiAoc3RhcnRzX3dpdGgoYXJnLCAiLS1leHBpcmU9IikpIHsKCQkJaWYgKHBhcnNlX2V4cGlyeV9kYXRlKGFyZyArIDksICZjYi5jbWQuZXhwaXJlX3RvdGFsKSkKCQkJCWRpZShfKCInJXMnIGlzIG5vdCBhIHZhbGlkIHRpbWVzdGFtcCIpLCBhcmcpOwoJCQlleHBsaWNpdF9leHBpcnkgfD0gRVhQSVJFX1RPVEFMOwoJCX0KCQllbHNlIGlmIChzdGFydHNfd2l0aChhcmcsICItLWV4cGlyZS11bnJlYWNoYWJsZT0iKSkgewoJCQlpZiAocGFyc2VfZXhwaXJ5X2RhdGUoYXJnICsgMjEsICZjYi5jbWQuZXhwaXJlX3VucmVhY2hhYmxlKSkKCQkJCWRpZShfKCInJXMnIGlzIG5vdCBhIHZhbGlkIHRpbWVzdGFtcCIpLCBhcmcpOwoJCQlleHBsaWNpdF9leHBpcnkgfD0gRVhQSVJFX1VOUkVBQ0g7CgkJfQoJCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS1zdGFsZS1maXgiKSkKCQkJY2IuY21kLnN0YWxlZml4ID0gMTsKCQllbHNlIGlmICghc3RyY21wKGFyZywgIi0tcmV3cml0ZSIpKQoJCQlmbGFncyB8PSBFWFBJUkVfUkVGTE9HU19SRVdSSVRFOwoJCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS11cGRhdGVyZWYiKSkKCQkJZmxhZ3MgfD0gRVhQSVJFX1JFRkxPR1NfVVBEQVRFX1JFRjsKCQllbHNlIGlmICghc3RyY21wKGFyZywgIi0tYWxsIikpCgkJCWRvX2FsbCA9IDE7CgkJZWxzZSBpZiAoIXN0cmNtcChhcmcsICItLXZlcmJvc2UiKSkKCQkJZmxhZ3MgfD0gRVhQSVJFX1JFRkxPR1NfVkVSQk9TRTsKCQllbHNlIGlmICghc3RyY21wKGFyZywgIi0tIikpIHsKCQkJaSsrOwoJCQlicmVhazsKCQl9CgkJZWxzZSBpZiAoYXJnWzBdID09ICctJykKCQkJdXNhZ2UocmVmbG9nX2V4cGlyZV91c2FnZSk7CgkJZWxzZQoJCQlicmVhazsKCX0KCgkvKgoJICogV2UgY2FuIHRydXN0IHRoZSBjb21taXRzIGFuZCBvYmplY3RzIHJlYWNoYWJsZSBmcm9tIHJlZnMKCSAqIGV2ZW4gaW4gb2xkZXIgcmVwb3NpdG9yeS4gIFdlIGNhbm5vdCB0cnVzdCB3aGF0J3MgcmVhY2hhYmxlCgkgKiBmcm9tIHJlZmxvZyBpZiB0aGUgcmVwb3NpdG9yeSB3YXMgcHJ1bmVkIHdpdGggb2xkZXIgZ2l0LgoJICovCglpZiAoY2IuY21kLnN0YWxlZml4KSB7CgkJaW5pdF9yZXZpc2lvbnMoJmNiLmNtZC5yZXZzLCBwcmVmaXgpOwoJCWlmIChmbGFncyAmIEVYUElSRV9SRUZMT0dTX1ZFUkJPU0UpCgkJCXByaW50ZigiTWFya2luZyByZWFjaGFibGUgb2JqZWN0cy4uLiIpOwoJCW1hcmtfcmVhY2hhYmxlX29iamVjdHMoJmNiLmNtZC5yZXZzLCAwLCAwLCBOVUxMKTsKCQlpZiAoZmxhZ3MgJiBFWFBJUkVfUkVGTE9HU19WRVJCT1NFKQoJCQlwdXRjaGFyKCdcbicpOwoJfQoKCWlmIChkb19hbGwpIHsKCQlzdHJ1Y3QgY29sbGVjdF9yZWZsb2dfY2IgY29sbGVjdGVkOwoJCWludCBpOwoKCQltZW1zZXQoJmNvbGxlY3RlZCwgMCwgc2l6ZW9mKGNvbGxlY3RlZCkpOwoJCWZvcl9lYWNoX3JlZmxvZyhjb2xsZWN0X3JlZmxvZywgJmNvbGxlY3RlZCk7CgkJZm9yIChpID0gMDsgaSA8IGNvbGxlY3RlZC5ucjsgaSsrKSB7CgkJCXN0cnVjdCBjb2xsZWN0ZWRfcmVmbG9nICplID0gY29sbGVjdGVkLmVbaV07CgkJCXNldF9yZWZsb2dfZXhwaXJ5X3BhcmFtKCZjYi5jbWQsIGV4cGxpY2l0X2V4cGlyeSwgZS0+cmVmbG9nKTsKCQkJc3RhdHVzIHw9IHJlZmxvZ19leHBpcmUoZS0+cmVmbG9nLCAmZS0+b2lkLCBmbGFncywKCQkJCQkJcmVmbG9nX2V4cGlyeV9wcmVwYXJlLAoJCQkJCQlzaG91bGRfZXhwaXJlX3JlZmxvZ19lbnQsCgkJCQkJCXJlZmxvZ19leHBpcnlfY2xlYW51cCwKCQkJCQkJJmNiKTsKCQkJZnJlZShlKTsKCQl9CgkJZnJlZShjb2xsZWN0ZWQuZSk7Cgl9CgoJZm9yICg7IGkgPCBhcmdjOyBpKyspIHsKCQljaGFyICpyZWY7CgkJc3RydWN0IG9iamVjdF9pZCBvaWQ7CgkJaWYgKCFkd2ltX2xvZyhhcmd2W2ldLCBzdHJsZW4oYXJndltpXSksICZvaWQsICZyZWYpKSB7CgkJCXN0YXR1cyB8PSBlcnJvcigiJXMgcG9pbnRzIG5vd2hlcmUhIiwgYXJndltpXSk7CgkJCWNvbnRpbnVlOwoJCX0KCQlzZXRfcmVmbG9nX2V4cGlyeV9wYXJhbSgmY2IuY21kLCBleHBsaWNpdF9leHBpcnksIHJlZik7CgkJc3RhdHVzIHw9IHJlZmxvZ19leHBpcmUocmVmLCAmb2lkLCBmbGFncywKCQkJCQlyZWZsb2dfZXhwaXJ5X3ByZXBhcmUsCgkJCQkJc2hvdWxkX2V4cGlyZV9yZWZsb2dfZW50LAoJCQkJCXJlZmxvZ19leHBpcnlfY2xlYW51cCwKCQkJCQkmY2IpOwoJfQoJcmV0dXJuIHN0YXR1czsKfQoKc3RhdGljIGludCBjb3VudF9yZWZsb2dfZW50KHN0cnVjdCBvYmplY3RfaWQgKm9vaWQsIHN0cnVjdCBvYmplY3RfaWQgKm5vaWQsCgkJY29uc3QgY2hhciAqZW1haWwsIHRpbWVzdGFtcF90IHRpbWVzdGFtcCwgaW50IHR6LAoJCWNvbnN0IGNoYXIgKm1lc3NhZ2UsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBleHBpcmVfcmVmbG9nX3BvbGljeV9jYiAqY2IgPSBjYl9kYXRhOwoJaWYgKCFjYi0+Y21kLmV4cGlyZV90b3RhbCB8fCB0aW1lc3RhbXAgPCBjYi0+Y21kLmV4cGlyZV90b3RhbCkKCQljYi0+Y21kLnJlY25vKys7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBjbWRfcmVmbG9nX2RlbGV0ZShpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IGV4cGlyZV9yZWZsb2dfcG9saWN5X2NiIGNiOwoJaW50IGksIHN0YXR1cyA9IDA7Cgl1bnNpZ25lZCBpbnQgZmxhZ3MgPSAwOwoKCW1lbXNldCgmY2IsIDAsIHNpemVvZihjYikpOwoKCWZvciAoaSA9IDE7IGkgPCBhcmdjOyBpKyspIHsKCQljb25zdCBjaGFyICphcmcgPSBhcmd2W2ldOwoJCWlmICghc3RyY21wKGFyZywgIi0tZHJ5LXJ1biIpIHx8ICFzdHJjbXAoYXJnLCAiLW4iKSkKCQkJZmxhZ3MgfD0gRVhQSVJFX1JFRkxPR1NfRFJZX1JVTjsKCQllbHNlIGlmICghc3RyY21wKGFyZywgIi0tcmV3cml0ZSIpKQoJCQlmbGFncyB8PSBFWFBJUkVfUkVGTE9HU19SRVdSSVRFOwoJCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS11cGRhdGVyZWYiKSkKCQkJZmxhZ3MgfD0gRVhQSVJFX1JFRkxPR1NfVVBEQVRFX1JFRjsKCQllbHNlIGlmICghc3RyY21wKGFyZywgIi0tdmVyYm9zZSIpKQoJCQlmbGFncyB8PSBFWFBJUkVfUkVGTE9HU19WRVJCT1NFOwoJCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS0iKSkgewoJCQlpKys7CgkJCWJyZWFrOwoJCX0KCQllbHNlIGlmIChhcmdbMF0gPT0gJy0nKQoJCQl1c2FnZShyZWZsb2dfZGVsZXRlX3VzYWdlKTsKCQllbHNlCgkJCWJyZWFrOwoJfQoKCWlmIChhcmdjIC0gaSA8IDEpCgkJcmV0dXJuIGVycm9yKCJOb3RoaW5nIHRvIGRlbGV0ZT8iKTsKCglmb3IgKCA7IGkgPCBhcmdjOyBpKyspIHsKCQljb25zdCBjaGFyICpzcGVjID0gc3Ryc3RyKGFyZ3ZbaV0sICJAeyIpOwoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCWNoYXIgKmVwLCAqcmVmOwoJCWludCByZWNubzsKCgkJaWYgKCFzcGVjKSB7CgkJCXN0YXR1cyB8PSBlcnJvcigiTm90IGEgcmVmbG9nOiAlcyIsIGFyZ3ZbaV0pOwoJCQljb250aW51ZTsKCQl9CgoJCWlmICghZHdpbV9sb2coYXJndltpXSwgc3BlYyAtIGFyZ3ZbaV0sICZvaWQsICZyZWYpKSB7CgkJCXN0YXR1cyB8PSBlcnJvcigibm8gcmVmbG9nIGZvciAnJXMnIiwgYXJndltpXSk7CgkJCWNvbnRpbnVlOwoJCX0KCgkJcmVjbm8gPSBzdHJ0b3VsKHNwZWMgKyAyLCAmZXAsIDEwKTsKCQlpZiAoKmVwID09ICd9JykgewoJCQljYi5jbWQucmVjbm8gPSAtcmVjbm87CgkJCWZvcl9lYWNoX3JlZmxvZ19lbnQocmVmLCBjb3VudF9yZWZsb2dfZW50LCAmY2IpOwoJCX0gZWxzZSB7CgkJCWNiLmNtZC5leHBpcmVfdG90YWwgPSBhcHByb3hpZGF0ZShzcGVjICsgMik7CgkJCWZvcl9lYWNoX3JlZmxvZ19lbnQocmVmLCBjb3VudF9yZWZsb2dfZW50LCAmY2IpOwoJCQljYi5jbWQuZXhwaXJlX3RvdGFsID0gMDsKCQl9CgoJCXN0YXR1cyB8PSByZWZsb2dfZXhwaXJlKHJlZiwgJm9pZCwgZmxhZ3MsCgkJCQkJcmVmbG9nX2V4cGlyeV9wcmVwYXJlLAoJCQkJCXNob3VsZF9leHBpcmVfcmVmbG9nX2VudCwKCQkJCQlyZWZsb2dfZXhwaXJ5X2NsZWFudXAsCgkJCQkJJmNiKTsKCQlmcmVlKHJlZik7Cgl9CglyZXR1cm4gc3RhdHVzOwp9CgpzdGF0aWMgaW50IGNtZF9yZWZsb2dfZXhpc3RzKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglpbnQgaSwgc3RhcnQgPSAwOwoKCWZvciAoaSA9IDE7IGkgPCBhcmdjOyBpKyspIHsKCQljb25zdCBjaGFyICphcmcgPSBhcmd2W2ldOwoJCWlmICghc3RyY21wKGFyZywgIi0tIikpIHsKCQkJaSsrOwoJCQlicmVhazsKCQl9CgkJZWxzZSBpZiAoYXJnWzBdID09ICctJykKCQkJdXNhZ2UocmVmbG9nX2V4aXN0c191c2FnZSk7CgkJZWxzZQoJCQlicmVhazsKCX0KCglzdGFydCA9IGk7CgoJaWYgKGFyZ2MgLSBzdGFydCAhPSAxKQoJCXVzYWdlKHJlZmxvZ19leGlzdHNfdXNhZ2UpOwoKCWlmIChjaGVja19yZWZuYW1lX2Zvcm1hdChhcmd2W3N0YXJ0XSwgUkVGTkFNRV9BTExPV19PTkVMRVZFTCkpCgkJZGllKCJpbnZhbGlkIHJlZiBmb3JtYXQ6ICVzIiwgYXJndltzdGFydF0pOwoJcmV0dXJuICFyZWZsb2dfZXhpc3RzKGFyZ3Zbc3RhcnRdKTsKfQoKLyoKICogbWFpbiAicmVmbG9nIgogKi8KCnN0YXRpYyBjb25zdCBjaGFyIHJlZmxvZ191c2FnZVtdID0KImdpdCByZWZsb2cgWyBzaG93IHwgZXhwaXJlIHwgZGVsZXRlIHwgZXhpc3RzIF0iOwoKaW50IGNtZF9yZWZsb2coaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCWlmIChhcmdjID4gMSAmJiAhc3RyY21wKGFyZ3ZbMV0sICItaCIpKQoJCXVzYWdlKHJlZmxvZ191c2FnZSk7CgoJLyogV2l0aCBubyBjb21tYW5kLCB3ZSBkZWZhdWx0IHRvIHNob3dpbmcgaXQuICovCglpZiAoYXJnYyA8IDIgfHwgKmFyZ3ZbMV0gPT0gJy0nKQoJCXJldHVybiBjbWRfbG9nX3JlZmxvZyhhcmdjLCBhcmd2LCBwcmVmaXgpOwoKCWlmICghc3RyY21wKGFyZ3ZbMV0sICJzaG93IikpCgkJcmV0dXJuIGNtZF9sb2dfcmVmbG9nKGFyZ2MgLSAxLCBhcmd2ICsgMSwgcHJlZml4KTsKCglpZiAoIXN0cmNtcChhcmd2WzFdLCAiZXhwaXJlIikpCgkJcmV0dXJuIGNtZF9yZWZsb2dfZXhwaXJlKGFyZ2MgLSAxLCBhcmd2ICsgMSwgcHJlZml4KTsKCglpZiAoIXN0cmNtcChhcmd2WzFdLCAiZGVsZXRlIikpCgkJcmV0dXJuIGNtZF9yZWZsb2dfZGVsZXRlKGFyZ2MgLSAxLCBhcmd2ICsgMSwgcHJlZml4KTsKCglpZiAoIXN0cmNtcChhcmd2WzFdLCAiZXhpc3RzIikpCgkJcmV0dXJuIGNtZF9yZWZsb2dfZXhpc3RzKGFyZ2MgLSAxLCBhcmd2ICsgMSwgcHJlZml4KTsKCglyZXR1cm4gY21kX2xvZ19yZWZsb2coYXJnYywgYXJndiwgcHJlZml4KTsKfQo=",
    "text": "#include \"builtin.h\"\n#include \"config.h\"\n#include \"lockfile.h\"\n#include \"object-store.h\"\n#include \"commit.h\"\n#include \"refs.h\"\n#include \"dir.h\"\n#include \"tree-walk.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"reachable.h\"\n\n/* NEEDSWORK: switch to using parse_options */\nstatic const char reflog_expire_usage[] =\n\"git reflog expire [--expire=<time>] [--expire-unreachable=<time>] [--rewrite] [--updateref] [--stale-fix] [--dry-run | -n] [--verbose] [--all] <refs>...\";\nstatic const char reflog_delete_usage[] =\n\"git reflog delete [--rewrite] [--updateref] [--dry-run | -n] [--verbose] <refs>...\";\nstatic const char reflog_exists_usage[] =\n\"git reflog exists <ref>\";\n\nstatic timestamp_t default_reflog_expire;\nstatic timestamp_t default_reflog_expire_unreachable;\n\nstruct cmd_reflog_expire_cb {\n\tstruct rev_info revs;\n\tint stalefix;\n\ttimestamp_t expire_total;\n\ttimestamp_t expire_unreachable;\n\tint recno;\n};\n\nstruct expire_reflog_policy_cb {\n\tenum {\n\t\tUE_NORMAL,\n\t\tUE_ALWAYS,\n\t\tUE_HEAD\n\t} unreachable_expire_kind;\n\tstruct commit_list *mark_list;\n\tunsigned long mark_limit;\n\tstruct cmd_reflog_expire_cb cmd;\n\tstruct commit *tip_commit;\n\tstruct commit_list *tips;\n};\n\nstruct collected_reflog {\n\tstruct object_id oid;\n\tchar reflog[FLEX_ARRAY];\n};\n\nstruct collect_reflog_cb {\n\tstruct collected_reflog **e;\n\tint alloc;\n\tint nr;\n};\n\n/* Remember to update object flag allocation in object.h */\n#define INCOMPLETE\t(1u<<10)\n#define STUDYING\t(1u<<11)\n#define REACHABLE\t(1u<<12)\n\nstatic int tree_is_complete(const struct object_id *oid)\n{\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tint complete;\n\tstruct tree *tree;\n\n\ttree = lookup_tree(oid);\n\tif (!tree)\n\t\treturn 0;\n\tif (tree->object.flags & SEEN)\n\t\treturn 1;\n\tif (tree->object.flags & INCOMPLETE)\n\t\treturn 0;\n\n\tif (!tree->buffer) {\n\t\tenum object_type type;\n\t\tunsigned long size;\n\t\tvoid *data = read_object_file(oid, &type, &size);\n\t\tif (!data) {\n\t\t\ttree->object.flags |= INCOMPLETE;\n\t\t\treturn 0;\n\t\t}\n\t\ttree->buffer = data;\n\t\ttree->size = size;\n\t}\n\tinit_tree_desc(&desc, tree->buffer, tree->size);\n\tcomplete = 1;\n\twhile (tree_entry(&desc, &entry)) {\n\t\tif (!has_sha1_file(entry.oid->hash) ||\n\t\t    (S_ISDIR(entry.mode) && !tree_is_complete(entry.oid))) {\n\t\t\ttree->object.flags |= INCOMPLETE;\n\t\t\tcomplete = 0;\n\t\t}\n\t}\n\tfree_tree_buffer(tree);\n\n\tif (complete)\n\t\ttree->object.flags |= SEEN;\n\treturn complete;\n}\n\nstatic int commit_is_complete(struct commit *commit)\n{\n\tstruct object_array study;\n\tstruct object_array found;\n\tint is_incomplete = 0;\n\tint i;\n\n\t/* early return */\n\tif (commit->object.flags & SEEN)\n\t\treturn 1;\n\tif (commit->object.flags & INCOMPLETE)\n\t\treturn 0;\n\t/*\n\t * Find all commits that are reachable and are not marked as\n\t * SEEN.  Then make sure the trees and blobs contained are\n\t * complete.  After that, mark these commits also as SEEN.\n\t * If some of the objects that are needed to complete this\n\t * commit are missing, mark this commit as INCOMPLETE.\n\t */\n\tmemset(&study, 0, sizeof(study));\n\tmemset(&found, 0, sizeof(found));\n\tadd_object_array(&commit->object, NULL, &study);\n\tadd_object_array(&commit->object, NULL, &found);\n\tcommit->object.flags |= STUDYING;\n\twhile (study.nr) {\n\t\tstruct commit *c;\n\t\tstruct commit_list *parent;\n\n\t\tc = (struct commit *)object_array_pop(&study);\n\t\tif (!c->object.parsed && !parse_object(&c->object.oid))\n\t\t\tc->object.flags |= INCOMPLETE;\n\n\t\tif (c->object.flags & INCOMPLETE) {\n\t\t\tis_incomplete = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (c->object.flags & SEEN)\n\t\t\tcontinue;\n\t\tfor (parent = c->parents; parent; parent = parent->next) {\n\t\t\tstruct commit *p = parent->item;\n\t\t\tif (p->object.flags & STUDYING)\n\t\t\t\tcontinue;\n\t\t\tp->object.flags |= STUDYING;\n\t\t\tadd_object_array(&p->object, NULL, &study);\n\t\t\tadd_object_array(&p->object, NULL, &found);\n\t\t}\n\t}\n\tif (!is_incomplete) {\n\t\t/*\n\t\t * make sure all commits in \"found\" array have all the\n\t\t * necessary objects.\n\t\t */\n\t\tfor (i = 0; i < found.nr; i++) {\n\t\t\tstruct commit *c =\n\t\t\t\t(struct commit *)found.objects[i].item;\n\t\t\tif (!tree_is_complete(get_commit_tree_oid(c))) {\n\t\t\t\tis_incomplete = 1;\n\t\t\t\tc->object.flags |= INCOMPLETE;\n\t\t\t}\n\t\t}\n\t\tif (!is_incomplete) {\n\t\t\t/* mark all found commits as complete, iow SEEN */\n\t\t\tfor (i = 0; i < found.nr; i++)\n\t\t\t\tfound.objects[i].item->flags |= SEEN;\n\t\t}\n\t}\n\t/* clear flags from the objects we traversed */\n\tfor (i = 0; i < found.nr; i++)\n\t\tfound.objects[i].item->flags &= ~STUDYING;\n\tif (is_incomplete)\n\t\tcommit->object.flags |= INCOMPLETE;\n\telse {\n\t\t/*\n\t\t * If we come here, we have (1) traversed the ancestry chain\n\t\t * from the \"commit\" until we reach SEEN commits (which are\n\t\t * known to be complete), and (2) made sure that the commits\n\t\t * encountered during the above traversal refer to trees that\n\t\t * are complete.  Which means that we know *all* the commits\n\t\t * we have seen during this process are complete.\n\t\t */\n\t\tfor (i = 0; i < found.nr; i++)\n\t\t\tfound.objects[i].item->flags |= SEEN;\n\t}\n\t/* free object arrays */\n\tobject_array_clear(&study);\n\tobject_array_clear(&found);\n\treturn !is_incomplete;\n}\n\nstatic int keep_entry(struct commit **it, struct object_id *oid)\n{\n\tstruct commit *commit;\n\n\tif (is_null_oid(oid))\n\t\treturn 1;\n\tcommit = lookup_commit_reference_gently(oid, 1);\n\tif (!commit)\n\t\treturn 0;\n\n\t/*\n\t * Make sure everything in this commit exists.\n\t *\n\t * We have walked all the objects reachable from the refs\n\t * and cache earlier.  The commits reachable by this commit\n\t * must meet SEEN commits -- and then we should mark them as\n\t * SEEN as well.\n\t */\n\tif (!commit_is_complete(commit))\n\t\treturn 0;\n\t*it = commit;\n\treturn 1;\n}\n\n/*\n * Starting from commits in the cb->mark_list, mark commits that are\n * reachable from them.  Stop the traversal at commits older than\n * the expire_limit and queue them back, so that the caller can call\n * us again to restart the traversal with longer expire_limit.\n */\nstatic void mark_reachable(struct expire_reflog_policy_cb *cb)\n{\n\tstruct commit_list *pending;\n\ttimestamp_t expire_limit = cb->mark_limit;\n\tstruct commit_list *leftover = NULL;\n\n\tfor (pending = cb->mark_list; pending; pending = pending->next)\n\t\tpending->item->object.flags &= ~REACHABLE;\n\n\tpending = cb->mark_list;\n\twhile (pending) {\n\t\tstruct commit_list *parent;\n\t\tstruct commit *commit = pop_commit(&pending);\n\t\tif (commit->object.flags & REACHABLE)\n\t\t\tcontinue;\n\t\tif (parse_commit(commit))\n\t\t\tcontinue;\n\t\tcommit->object.flags |= REACHABLE;\n\t\tif (commit->date < expire_limit) {\n\t\t\tcommit_list_insert(commit, &leftover);\n\t\t\tcontinue;\n\t\t}\n\t\tcommit->object.flags |= REACHABLE;\n\t\tparent = commit->parents;\n\t\twhile (parent) {\n\t\t\tcommit = parent->item;\n\t\t\tparent = parent->next;\n\t\t\tif (commit->object.flags & REACHABLE)\n\t\t\t\tcontinue;\n\t\t\tcommit_list_insert(commit, &pending);\n\t\t}\n\t}\n\tcb->mark_list = leftover;\n}\n\nstatic int unreachable(struct expire_reflog_policy_cb *cb, struct commit *commit, struct object_id *oid)\n{\n\t/*\n\t * We may or may not have the commit yet - if not, look it\n\t * up using the supplied sha1.\n\t */\n\tif (!commit) {\n\t\tif (is_null_oid(oid))\n\t\t\treturn 0;\n\n\t\tcommit = lookup_commit_reference_gently(oid, 1);\n\n\t\t/* Not a commit -- keep it */\n\t\tif (!commit)\n\t\t\treturn 0;\n\t}\n\n\t/* Reachable from the current ref?  Don't prune. */\n\tif (commit->object.flags & REACHABLE)\n\t\treturn 0;\n\n\tif (cb->mark_list && cb->mark_limit) {\n\t\tcb->mark_limit = 0; /* dig down to the root */\n\t\tmark_reachable(cb);\n\t}\n\n\treturn !(commit->object.flags & REACHABLE);\n}\n\n/*\n * Return true iff the specified reflog entry should be expired.\n */\nstatic int should_expire_reflog_ent(struct object_id *ooid, struct object_id *noid,\n\t\t\t\t    const char *email, timestamp_t timestamp, int tz,\n\t\t\t\t    const char *message, void *cb_data)\n{\n\tstruct expire_reflog_policy_cb *cb = cb_data;\n\tstruct commit *old_commit, *new_commit;\n\n\tif (timestamp < cb->cmd.expire_total)\n\t\treturn 1;\n\n\told_commit = new_commit = NULL;\n\tif (cb->cmd.stalefix &&\n\t    (!keep_entry(&old_commit, ooid) || !keep_entry(&new_commit, noid)))\n\t\treturn 1;\n\n\tif (timestamp < cb->cmd.expire_unreachable) {\n\t\tif (cb->unreachable_expire_kind == UE_ALWAYS)\n\t\t\treturn 1;\n\t\tif (unreachable(cb, old_commit, ooid) || unreachable(cb, new_commit, noid))\n\t\t\treturn 1;\n\t}\n\n\tif (cb->cmd.recno && --(cb->cmd.recno) == 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int push_tip_to_list(const char *refname, const struct object_id *oid,\n\t\t\t    int flags, void *cb_data)\n{\n\tstruct commit_list **list = cb_data;\n\tstruct commit *tip_commit;\n\tif (flags & REF_ISSYMREF)\n\t\treturn 0;\n\ttip_commit = lookup_commit_reference_gently(oid, 1);\n\tif (!tip_commit)\n\t\treturn 0;\n\tcommit_list_insert(tip_commit, list);\n\treturn 0;\n}\n\nstatic void reflog_expiry_prepare(const char *refname,\n\t\t\t\t  const struct object_id *oid,\n\t\t\t\t  void *cb_data)\n{\n\tstruct expire_reflog_policy_cb *cb = cb_data;\n\n\tif (!cb->cmd.expire_unreachable || !strcmp(refname, \"HEAD\")) {\n\t\tcb->tip_commit = NULL;\n\t\tcb->unreachable_expire_kind = UE_HEAD;\n\t} else {\n\t\tcb->tip_commit = lookup_commit_reference_gently(oid, 1);\n\t\tif (!cb->tip_commit)\n\t\t\tcb->unreachable_expire_kind = UE_ALWAYS;\n\t\telse\n\t\t\tcb->unreachable_expire_kind = UE_NORMAL;\n\t}\n\n\tif (cb->cmd.expire_unreachable <= cb->cmd.expire_total)\n\t\tcb->unreachable_expire_kind = UE_ALWAYS;\n\n\tcb->mark_list = NULL;\n\tcb->tips = NULL;\n\tif (cb->unreachable_expire_kind != UE_ALWAYS) {\n\t\tif (cb->unreachable_expire_kind == UE_HEAD) {\n\t\t\tstruct commit_list *elem;\n\n\t\t\tfor_each_ref(push_tip_to_list, &cb->tips);\n\t\t\tfor (elem = cb->tips; elem; elem = elem->next)\n\t\t\t\tcommit_list_insert(elem->item, &cb->mark_list);\n\t\t} else {\n\t\t\tcommit_list_insert(cb->tip_commit, &cb->mark_list);\n\t\t}\n\t\tcb->mark_limit = cb->cmd.expire_total;\n\t\tmark_reachable(cb);\n\t}\n}\n\nstatic void reflog_expiry_cleanup(void *cb_data)\n{\n\tstruct expire_reflog_policy_cb *cb = cb_data;\n\n\tif (cb->unreachable_expire_kind != UE_ALWAYS) {\n\t\tif (cb->unreachable_expire_kind == UE_HEAD) {\n\t\t\tstruct commit_list *elem;\n\t\t\tfor (elem = cb->tips; elem; elem = elem->next)\n\t\t\t\tclear_commit_marks(elem->item, REACHABLE);\n\t\t\tfree_commit_list(cb->tips);\n\t\t} else {\n\t\t\tclear_commit_marks(cb->tip_commit, REACHABLE);\n\t\t}\n\t}\n}\n\nstatic int collect_reflog(const char *ref, const struct object_id *oid, int unused, void *cb_data)\n{\n\tstruct collected_reflog *e;\n\tstruct collect_reflog_cb *cb = cb_data;\n\n\tFLEX_ALLOC_STR(e, reflog, ref);\n\toidcpy(&e->oid, oid);\n\tALLOC_GROW(cb->e, cb->nr + 1, cb->alloc);\n\tcb->e[cb->nr++] = e;\n\treturn 0;\n}\n\nstatic struct reflog_expire_cfg {\n\tstruct reflog_expire_cfg *next;\n\ttimestamp_t expire_total;\n\ttimestamp_t expire_unreachable;\n\tchar pattern[FLEX_ARRAY];\n} *reflog_expire_cfg, **reflog_expire_cfg_tail;\n\nstatic struct reflog_expire_cfg *find_cfg_ent(const char *pattern, size_t len)\n{\n\tstruct reflog_expire_cfg *ent;\n\n\tif (!reflog_expire_cfg_tail)\n\t\treflog_expire_cfg_tail = &reflog_expire_cfg;\n\n\tfor (ent = reflog_expire_cfg; ent; ent = ent->next)\n\t\tif (!strncmp(ent->pattern, pattern, len) &&\n\t\t    ent->pattern[len] == '\\0')\n\t\t\treturn ent;\n\n\tFLEX_ALLOC_MEM(ent, pattern, pattern, len);\n\t*reflog_expire_cfg_tail = ent;\n\treflog_expire_cfg_tail = &(ent->next);\n\treturn ent;\n}\n\n/* expiry timer slot */\n#define EXPIRE_TOTAL   01\n#define EXPIRE_UNREACH 02\n\nstatic int reflog_expire_config(const char *var, const char *value, void *cb)\n{\n\tconst char *pattern, *key;\n\tint pattern_len;\n\ttimestamp_t expire;\n\tint slot;\n\tstruct reflog_expire_cfg *ent;\n\n\tif (parse_config_key(var, \"gc\", &pattern, &pattern_len, &key) < 0)\n\t\treturn git_default_config(var, value, cb);\n\n\tif (!strcmp(key, \"reflogexpire\")) {\n\t\tslot = EXPIRE_TOTAL;\n\t\tif (git_config_expiry_date(&expire, var, value))\n\t\t\treturn -1;\n\t} else if (!strcmp(key, \"reflogexpireunreachable\")) {\n\t\tslot = EXPIRE_UNREACH;\n\t\tif (git_config_expiry_date(&expire, var, value))\n\t\t\treturn -1;\n\t} else\n\t\treturn git_default_config(var, value, cb);\n\n\tif (!pattern) {\n\t\tswitch (slot) {\n\t\tcase EXPIRE_TOTAL:\n\t\t\tdefault_reflog_expire = expire;\n\t\t\tbreak;\n\t\tcase EXPIRE_UNREACH:\n\t\t\tdefault_reflog_expire_unreachable = expire;\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tent = find_cfg_ent(pattern, pattern_len);\n\tif (!ent)\n\t\treturn -1;\n\tswitch (slot) {\n\tcase EXPIRE_TOTAL:\n\t\tent->expire_total = expire;\n\t\tbreak;\n\tcase EXPIRE_UNREACH:\n\t\tent->expire_unreachable = expire;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void set_reflog_expiry_param(struct cmd_reflog_expire_cb *cb, int slot, const char *ref)\n{\n\tstruct reflog_expire_cfg *ent;\n\n\tif (slot == (EXPIRE_TOTAL|EXPIRE_UNREACH))\n\t\treturn; /* both given explicitly -- nothing to tweak */\n\n\tfor (ent = reflog_expire_cfg; ent; ent = ent->next) {\n\t\tif (!wildmatch(ent->pattern, ref, 0)) {\n\t\t\tif (!(slot & EXPIRE_TOTAL))\n\t\t\t\tcb->expire_total = ent->expire_total;\n\t\t\tif (!(slot & EXPIRE_UNREACH))\n\t\t\t\tcb->expire_unreachable = ent->expire_unreachable;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * If unconfigured, make stash never expire\n\t */\n\tif (!strcmp(ref, \"refs/stash\")) {\n\t\tif (!(slot & EXPIRE_TOTAL))\n\t\t\tcb->expire_total = 0;\n\t\tif (!(slot & EXPIRE_UNREACH))\n\t\t\tcb->expire_unreachable = 0;\n\t\treturn;\n\t}\n\n\t/* Nothing matched -- use the default value */\n\tif (!(slot & EXPIRE_TOTAL))\n\t\tcb->expire_total = default_reflog_expire;\n\tif (!(slot & EXPIRE_UNREACH))\n\t\tcb->expire_unreachable = default_reflog_expire_unreachable;\n}\n\nstatic int cmd_reflog_expire(int argc, const char **argv, const char *prefix)\n{\n\tstruct expire_reflog_policy_cb cb;\n\ttimestamp_t now = time(NULL);\n\tint i, status, do_all;\n\tint explicit_expiry = 0;\n\tunsigned int flags = 0;\n\n\tdefault_reflog_expire_unreachable = now - 30 * 24 * 3600;\n\tdefault_reflog_expire = now - 90 * 24 * 3600;\n\tgit_config(reflog_expire_config, NULL);\n\n\tsave_commit_buffer = 0;\n\tdo_all = status = 0;\n\tmemset(&cb, 0, sizeof(cb));\n\n\tcb.cmd.expire_total = default_reflog_expire;\n\tcb.cmd.expire_unreachable = default_reflog_expire_unreachable;\n\n\tfor (i = 1; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\t\tif (!strcmp(arg, \"--dry-run\") || !strcmp(arg, \"-n\"))\n\t\t\tflags |= EXPIRE_REFLOGS_DRY_RUN;\n\t\telse if (starts_with(arg, \"--expire=\")) {\n\t\t\tif (parse_expiry_date(arg + 9, &cb.cmd.expire_total))\n\t\t\t\tdie(_(\"'%s' is not a valid timestamp\"), arg);\n\t\t\texplicit_expiry |= EXPIRE_TOTAL;\n\t\t}\n\t\telse if (starts_with(arg, \"--expire-unreachable=\")) {\n\t\t\tif (parse_expiry_date(arg + 21, &cb.cmd.expire_unreachable))\n\t\t\t\tdie(_(\"'%s' is not a valid timestamp\"), arg);\n\t\t\texplicit_expiry |= EXPIRE_UNREACH;\n\t\t}\n\t\telse if (!strcmp(arg, \"--stale-fix\"))\n\t\t\tcb.cmd.stalefix = 1;\n\t\telse if (!strcmp(arg, \"--rewrite\"))\n\t\t\tflags |= EXPIRE_REFLOGS_REWRITE;\n\t\telse if (!strcmp(arg, \"--updateref\"))\n\t\t\tflags |= EXPIRE_REFLOGS_UPDATE_REF;\n\t\telse if (!strcmp(arg, \"--all\"))\n\t\t\tdo_all = 1;\n\t\telse if (!strcmp(arg, \"--verbose\"))\n\t\t\tflags |= EXPIRE_REFLOGS_VERBOSE;\n\t\telse if (!strcmp(arg, \"--\")) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\telse if (arg[0] == '-')\n\t\t\tusage(reflog_expire_usage);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * We can trust the commits and objects reachable from refs\n\t * even in older repository.  We cannot trust what's reachable\n\t * from reflog if the repository was pruned with older git.\n\t */\n\tif (cb.cmd.stalefix) {\n\t\tinit_revisions(&cb.cmd.revs, prefix);\n\t\tif (flags & EXPIRE_REFLOGS_VERBOSE)\n\t\t\tprintf(\"Marking reachable objects...\");\n\t\tmark_reachable_objects(&cb.cmd.revs, 0, 0, NULL);\n\t\tif (flags & EXPIRE_REFLOGS_VERBOSE)\n\t\t\tputchar('\\n');\n\t}\n\n\tif (do_all) {\n\t\tstruct collect_reflog_cb collected;\n\t\tint i;\n\n\t\tmemset(&collected, 0, sizeof(collected));\n\t\tfor_each_reflog(collect_reflog, &collected);\n\t\tfor (i = 0; i < collected.nr; i++) {\n\t\t\tstruct collected_reflog *e = collected.e[i];\n\t\t\tset_reflog_expiry_param(&cb.cmd, explicit_expiry, e->reflog);\n\t\t\tstatus |= reflog_expire(e->reflog, &e->oid, flags,\n\t\t\t\t\t\treflog_expiry_prepare,\n\t\t\t\t\t\tshould_expire_reflog_ent,\n\t\t\t\t\t\treflog_expiry_cleanup,\n\t\t\t\t\t\t&cb);\n\t\t\tfree(e);\n\t\t}\n\t\tfree(collected.e);\n\t}\n\n\tfor (; i < argc; i++) {\n\t\tchar *ref;\n\t\tstruct object_id oid;\n\t\tif (!dwim_log(argv[i], strlen(argv[i]), &oid, &ref)) {\n\t\t\tstatus |= error(\"%s points nowhere!\", argv[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tset_reflog_expiry_param(&cb.cmd, explicit_expiry, ref);\n\t\tstatus |= reflog_expire(ref, &oid, flags,\n\t\t\t\t\treflog_expiry_prepare,\n\t\t\t\t\tshould_expire_reflog_ent,\n\t\t\t\t\treflog_expiry_cleanup,\n\t\t\t\t\t&cb);\n\t}\n\treturn status;\n}\n\nstatic int count_reflog_ent(struct object_id *ooid, struct object_id *noid,\n\t\tconst char *email, timestamp_t timestamp, int tz,\n\t\tconst char *message, void *cb_data)\n{\n\tstruct expire_reflog_policy_cb *cb = cb_data;\n\tif (!cb->cmd.expire_total || timestamp < cb->cmd.expire_total)\n\t\tcb->cmd.recno++;\n\treturn 0;\n}\n\nstatic int cmd_reflog_delete(int argc, const char **argv, const char *prefix)\n{\n\tstruct expire_reflog_policy_cb cb;\n\tint i, status = 0;\n\tunsigned int flags = 0;\n\n\tmemset(&cb, 0, sizeof(cb));\n\n\tfor (i = 1; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\t\tif (!strcmp(arg, \"--dry-run\") || !strcmp(arg, \"-n\"))\n\t\t\tflags |= EXPIRE_REFLOGS_DRY_RUN;\n\t\telse if (!strcmp(arg, \"--rewrite\"))\n\t\t\tflags |= EXPIRE_REFLOGS_REWRITE;\n\t\telse if (!strcmp(arg, \"--updateref\"))\n\t\t\tflags |= EXPIRE_REFLOGS_UPDATE_REF;\n\t\telse if (!strcmp(arg, \"--verbose\"))\n\t\t\tflags |= EXPIRE_REFLOGS_VERBOSE;\n\t\telse if (!strcmp(arg, \"--\")) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\telse if (arg[0] == '-')\n\t\t\tusage(reflog_delete_usage);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (argc - i < 1)\n\t\treturn error(\"Nothing to delete?\");\n\n\tfor ( ; i < argc; i++) {\n\t\tconst char *spec = strstr(argv[i], \"@{\");\n\t\tstruct object_id oid;\n\t\tchar *ep, *ref;\n\t\tint recno;\n\n\t\tif (!spec) {\n\t\t\tstatus |= error(\"Not a reflog: %s\", argv[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!dwim_log(argv[i], spec - argv[i], &oid, &ref)) {\n\t\t\tstatus |= error(\"no reflog for '%s'\", argv[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\trecno = strtoul(spec + 2, &ep, 10);\n\t\tif (*ep == '}') {\n\t\t\tcb.cmd.recno = -recno;\n\t\t\tfor_each_reflog_ent(ref, count_reflog_ent, &cb);\n\t\t} else {\n\t\t\tcb.cmd.expire_total = approxidate(spec + 2);\n\t\t\tfor_each_reflog_ent(ref, count_reflog_ent, &cb);\n\t\t\tcb.cmd.expire_total = 0;\n\t\t}\n\n\t\tstatus |= reflog_expire(ref, &oid, flags,\n\t\t\t\t\treflog_expiry_prepare,\n\t\t\t\t\tshould_expire_reflog_ent,\n\t\t\t\t\treflog_expiry_cleanup,\n\t\t\t\t\t&cb);\n\t\tfree(ref);\n\t}\n\treturn status;\n}\n\nstatic int cmd_reflog_exists(int argc, const char **argv, const char *prefix)\n{\n\tint i, start = 0;\n\n\tfor (i = 1; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\t\tif (!strcmp(arg, \"--\")) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\telse if (arg[0] == '-')\n\t\t\tusage(reflog_exists_usage);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tstart = i;\n\n\tif (argc - start != 1)\n\t\tusage(reflog_exists_usage);\n\n\tif (check_refname_format(argv[start], REFNAME_ALLOW_ONELEVEL))\n\t\tdie(\"invalid ref format: %s\", argv[start]);\n\treturn !reflog_exists(argv[start]);\n}\n\n/*\n * main \"reflog\"\n */\n\nstatic const char reflog_usage[] =\n\"git reflog [ show | expire | delete | exists ]\";\n\nint cmd_reflog(int argc, const char **argv, const char *prefix)\n{\n\tif (argc > 1 && !strcmp(argv[1], \"-h\"))\n\t\tusage(reflog_usage);\n\n\t/* With no command, we default to showing it. */\n\tif (argc < 2 || *argv[1] == '-')\n\t\treturn cmd_log_reflog(argc, argv, prefix);\n\n\tif (!strcmp(argv[1], \"show\"))\n\t\treturn cmd_log_reflog(argc - 1, argv + 1, prefix);\n\n\tif (!strcmp(argv[1], \"expire\"))\n\t\treturn cmd_reflog_expire(argc - 1, argv + 1, prefix);\n\n\tif (!strcmp(argv[1], \"delete\"))\n\t\treturn cmd_reflog_delete(argc - 1, argv + 1, prefix);\n\n\tif (!strcmp(argv[1], \"exists\"))\n\t\treturn cmd_reflog_exists(argc - 1, argv + 1, prefix);\n\n\treturn cmd_log_reflog(argc, argv, prefix);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "009119299529d5c93f02d5f8dc2363f6e29f0f9c",
  "sha1_ok": true,
  "size": 19163
}
