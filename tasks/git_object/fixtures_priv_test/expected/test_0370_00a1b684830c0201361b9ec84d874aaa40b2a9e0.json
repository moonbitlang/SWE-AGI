{
  "content": {
    "base64": "LyoKICogImdpdCBwdXNoIgogKi8KI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAicmVtb3RlLmgiCiNpbmNsdWRlICJ0cmFuc3BvcnQuaCIKI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCIKI2luY2x1ZGUgInN1Ym1vZHVsZS5oIgojaW5jbHVkZSAic3VibW9kdWxlLWNvbmZpZy5oIgojaW5jbHVkZSAic2VuZC1wYWNrLmgiCgpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IHB1c2hfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgcHVzaCBbPG9wdGlvbnM+XSBbPHJlcG9zaXRvcnk+IFs8cmVmc3BlYz4uLi5dXSIpLAoJTlVMTCwKfTsKCnN0YXRpYyBpbnQgdGhpbiA9IDE7CnN0YXRpYyBpbnQgZGVsZXRlcmVmczsKc3RhdGljIGNvbnN0IGNoYXIgKnJlY2VpdmVwYWNrOwpzdGF0aWMgaW50IHZlcmJvc2l0eTsKc3RhdGljIGludCBwcm9ncmVzcyA9IC0xOwpzdGF0aWMgaW50IHJlY3Vyc2Vfc3VibW9kdWxlcyA9IFJFQ1VSU0VfU1VCTU9EVUxFU19ERUZBVUxUOwpzdGF0aWMgZW51bSB0cmFuc3BvcnRfZmFtaWx5IGZhbWlseTsKCnN0YXRpYyBzdHJ1Y3QgcHVzaF9jYXNfb3B0aW9uIGNhczsKCnN0YXRpYyBjb25zdCBjaGFyICoqcmVmc3BlYzsKc3RhdGljIGludCByZWZzcGVjX25yOwpzdGF0aWMgaW50IHJlZnNwZWNfYWxsb2M7CgpzdGF0aWMgdm9pZCBhZGRfcmVmc3BlYyhjb25zdCBjaGFyICpyZWYpCnsKCXJlZnNwZWNfbnIrKzsKCUFMTE9DX0dST1cocmVmc3BlYywgcmVmc3BlY19uciwgcmVmc3BlY19hbGxvYyk7CglyZWZzcGVjW3JlZnNwZWNfbnItMV0gPSByZWY7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICptYXBfcmVmc3BlYyhjb25zdCBjaGFyICpyZWYsCgkJCSAgICAgICBzdHJ1Y3QgcmVtb3RlICpyZW1vdGUsIHN0cnVjdCByZWYgKmxvY2FsX3JlZnMpCnsKCXN0cnVjdCByZWYgKm1hdGNoZWQgPSBOVUxMOwoKCS8qIERvZXMgInJlZiIgdW5pcXVlbHkgbmFtZSBvdXIgcmVmPyAqLwoJaWYgKGNvdW50X3JlZnNwZWNfbWF0Y2gocmVmLCBsb2NhbF9yZWZzLCAmbWF0Y2hlZCkgIT0gMSkKCQlyZXR1cm4gcmVmOwoKCWlmIChyZW1vdGUtPnB1c2gpIHsKCQlzdHJ1Y3QgcmVmc3BlYyBxdWVyeTsKCQltZW1zZXQoJnF1ZXJ5LCAwLCBzaXplb2Yoc3RydWN0IHJlZnNwZWMpKTsKCQlxdWVyeS5zcmMgPSBtYXRjaGVkLT5uYW1lOwoJCWlmICghcXVlcnlfcmVmc3BlY3MocmVtb3RlLT5wdXNoLCByZW1vdGUtPnB1c2hfcmVmc3BlY19uciwgJnF1ZXJ5KSAmJgoJCSAgICBxdWVyeS5kc3QpIHsKCQkJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCQkJc3RyYnVmX2FkZGYoJmJ1ZiwgIiVzJXM6JXMiLAoJCQkJICAgIHF1ZXJ5LmZvcmNlID8gIisiIDogIiIsCgkJCQkgICAgcXVlcnkuc3JjLCBxdWVyeS5kc3QpOwoJCQlyZXR1cm4gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCQl9Cgl9CgoJaWYgKHB1c2hfZGVmYXVsdCA9PSBQVVNIX0RFRkFVTFRfVVBTVFJFQU0gJiYKCSAgICBzdGFydHNfd2l0aChtYXRjaGVkLT5uYW1lLCAicmVmcy9oZWFkcy8iKSkgewoJCXN0cnVjdCBicmFuY2ggKmJyYW5jaCA9IGJyYW5jaF9nZXQobWF0Y2hlZC0+bmFtZSArIDExKTsKCQlpZiAoYnJhbmNoLT5tZXJnZV9uciA9PSAxICYmIGJyYW5jaC0+bWVyZ2VbMF0tPnNyYykgewoJCQlzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJCQlzdHJidWZfYWRkZigmYnVmLCAiJXM6JXMiLAoJCQkJICAgIHJlZiwgYnJhbmNoLT5tZXJnZVswXS0+c3JjKTsKCQkJcmV0dXJuIHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7CgkJfQoJfQoKCXJldHVybiByZWY7Cn0KCnN0YXRpYyB2b2lkIHNldF9yZWZzcGVjcyhjb25zdCBjaGFyICoqcmVmcywgaW50IG5yLCBjb25zdCBjaGFyICpyZXBvKQp7CglzdHJ1Y3QgcmVtb3RlICpyZW1vdGUgPSBOVUxMOwoJc3RydWN0IHJlZiAqbG9jYWxfcmVmcyA9IE5VTEw7CglpbnQgaTsKCglmb3IgKGkgPSAwOyBpIDwgbnI7IGkrKykgewoJCWNvbnN0IGNoYXIgKnJlZiA9IHJlZnNbaV07CgkJaWYgKCFzdHJjbXAoInRhZyIsIHJlZikpIHsKCQkJc3RydWN0IHN0cmJ1ZiB0YWdyZWYgPSBTVFJCVUZfSU5JVDsKCQkJaWYgKG5yIDw9ICsraSkKCQkJCWRpZShfKCJ0YWcgc2hvcnRoYW5kIHdpdGhvdXQgPHRhZz4iKSk7CgkJCXJlZiA9IHJlZnNbaV07CgkJCWlmIChkZWxldGVyZWZzKQoJCQkJc3RyYnVmX2FkZGYoJnRhZ3JlZiwgIjpyZWZzL3RhZ3MvJXMiLCByZWYpOwoJCQllbHNlCgkJCQlzdHJidWZfYWRkZigmdGFncmVmLCAicmVmcy90YWdzLyVzIiwgcmVmKTsKCQkJcmVmID0gc3RyYnVmX2RldGFjaCgmdGFncmVmLCBOVUxMKTsKCQl9IGVsc2UgaWYgKGRlbGV0ZXJlZnMpIHsKCQkJc3RydWN0IHN0cmJ1ZiBkZWxyZWYgPSBTVFJCVUZfSU5JVDsKCQkJaWYgKHN0cmNocihyZWYsICc6JykpCgkJCQlkaWUoXygiLS1kZWxldGUgb25seSBhY2NlcHRzIHBsYWluIHRhcmdldCByZWYgbmFtZXMiKSk7CgkJCXN0cmJ1Zl9hZGRmKCZkZWxyZWYsICI6JXMiLCByZWYpOwoJCQlyZWYgPSBzdHJidWZfZGV0YWNoKCZkZWxyZWYsIE5VTEwpOwoJCX0gZWxzZSBpZiAoIXN0cmNocihyZWYsICc6JykpIHsKCQkJaWYgKCFyZW1vdGUpIHsKCQkJCS8qIGxhemlseSBncmFiIHJlbW90ZSBhbmQgbG9jYWxfcmVmcyAqLwoJCQkJcmVtb3RlID0gcmVtb3RlX2dldChyZXBvKTsKCQkJCWxvY2FsX3JlZnMgPSBnZXRfbG9jYWxfaGVhZHMoKTsKCQkJfQoJCQlyZWYgPSBtYXBfcmVmc3BlYyhyZWYsIHJlbW90ZSwgbG9jYWxfcmVmcyk7CgkJfQoJCWFkZF9yZWZzcGVjKHJlZik7Cgl9Cn0KCnN0YXRpYyBpbnQgcHVzaF91cmxfb2ZfcmVtb3RlKHN0cnVjdCByZW1vdGUgKnJlbW90ZSwgY29uc3QgY2hhciAqKip1cmxfcCkKewoJaWYgKHJlbW90ZS0+cHVzaHVybF9ucikgewoJCSp1cmxfcCA9IHJlbW90ZS0+cHVzaHVybDsKCQlyZXR1cm4gcmVtb3RlLT5wdXNodXJsX25yOwoJfQoJKnVybF9wID0gcmVtb3RlLT51cmw7CglyZXR1cm4gcmVtb3RlLT51cmxfbnI7Cn0KCnN0YXRpYyBOT1JFVFVSTiBpbnQgZGllX3B1c2hfc2ltcGxlKHN0cnVjdCBicmFuY2ggKmJyYW5jaCwgc3RydWN0IHJlbW90ZSAqcmVtb3RlKSB7CgkvKgoJICogVGhlcmUncyBubyBwb2ludCBpbiB1c2luZyBzaG9ydGVuX3VuYW1iaWd1b3VzX3JlZiBoZXJlLAoJICogYXMgdGhlIGFtYmlndWl0eSB3b3VsZCBiZSBvbiB0aGUgcmVtb3RlIHNpZGUsIG5vdCB3aGF0CgkgKiB3ZSBoYXZlIGxvY2FsbHkuIFBsdXMsIHRoaXMgaXMgc3VwcG9zZWQgdG8gYmUgdGhlIHNpbXBsZQoJICogbW9kZS4gSWYgdGhlIHVzZXIgaXMgZG9pbmcgc29tZXRoaW5nIGNyYXp5IGxpa2Ugc2V0dGluZwoJICogdXBzdHJlYW0gdG8gYSBub24tYnJhbmNoLCB3ZSBzaG91bGQgcHJvYmFibHkgYmUgc2hvd2luZwoJICogdGhlbSB0aGUgYmlnIHVnbHkgZnVsbHkgcXVhbGlmaWVkIHJlZi4KCSAqLwoJY29uc3QgY2hhciAqYWR2aWNlX21heWJlID0gIiI7Cgljb25zdCBjaGFyICpzaG9ydF91cHN0cmVhbSA9IGJyYW5jaC0+bWVyZ2VbMF0tPnNyYzsKCglza2lwX3ByZWZpeChzaG9ydF91cHN0cmVhbSwgInJlZnMvaGVhZHMvIiwgJnNob3J0X3Vwc3RyZWFtKTsKCgkvKgoJICogRG9uJ3Qgc2hvdyBhZHZpY2UgZm9yIHBlb3BsZSB3aG8gZXhwbGljaXRseSBzZXQKCSAqIHB1c2guZGVmYXVsdC4KCSAqLwoJaWYgKHB1c2hfZGVmYXVsdCA9PSBQVVNIX0RFRkFVTFRfVU5TUEVDSUZJRUQpCgkJYWR2aWNlX21heWJlID0gXygiXG4iCgkJCQkgIlRvIGNob29zZSBlaXRoZXIgb3B0aW9uIHBlcm1hbmVudGx5LCAiCgkJCQkgInNlZSBwdXNoLmRlZmF1bHQgaW4gJ2dpdCBoZWxwIGNvbmZpZycuIik7CglkaWUoXygiVGhlIHVwc3RyZWFtIGJyYW5jaCBvZiB5b3VyIGN1cnJlbnQgYnJhbmNoIGRvZXMgbm90IG1hdGNoXG4iCgkgICAgICAidGhlIG5hbWUgb2YgeW91ciBjdXJyZW50IGJyYW5jaC4gIFRvIHB1c2ggdG8gdGhlIHVwc3RyZWFtIGJyYW5jaFxuIgoJICAgICAgIm9uIHRoZSByZW1vdGUsIHVzZVxuIgoJICAgICAgIlxuIgoJICAgICAgIiAgICBnaXQgcHVzaCAlcyBIRUFEOiVzXG4iCgkgICAgICAiXG4iCgkgICAgICAiVG8gcHVzaCB0byB0aGUgYnJhbmNoIG9mIHRoZSBzYW1lIG5hbWUgb24gdGhlIHJlbW90ZSwgdXNlXG4iCgkgICAgICAiXG4iCgkgICAgICAiICAgIGdpdCBwdXNoICVzICVzXG4iCgkgICAgICAiJXMiKSwKCSAgICByZW1vdGUtPm5hbWUsIHNob3J0X3Vwc3RyZWFtLAoJICAgIHJlbW90ZS0+bmFtZSwgYnJhbmNoLT5uYW1lLCBhZHZpY2VfbWF5YmUpOwp9CgpzdGF0aWMgY29uc3QgY2hhciBtZXNzYWdlX2RldGFjaGVkX2hlYWRfZGllW10gPQoJTl8oIllvdSBhcmUgbm90IGN1cnJlbnRseSBvbiBhIGJyYW5jaC5cbiIKCSAgICJUbyBwdXNoIHRoZSBoaXN0b3J5IGxlYWRpbmcgdG8gdGhlIGN1cnJlbnQgKGRldGFjaGVkIEhFQUQpXG4iCgkgICAic3RhdGUgbm93LCB1c2VcbiIKCSAgICJcbiIKCSAgICIgICAgZ2l0IHB1c2ggJXMgSEVBRDo8bmFtZS1vZi1yZW1vdGUtYnJhbmNoPlxuIik7CgpzdGF0aWMgdm9pZCBzZXR1cF9wdXNoX3Vwc3RyZWFtKHN0cnVjdCByZW1vdGUgKnJlbW90ZSwgc3RydWN0IGJyYW5jaCAqYnJhbmNoLAoJCQkJaW50IHRyaWFuZ3VsYXIsIGludCBzaW1wbGUpCnsKCXN0cnVjdCBzdHJidWYgcmVmc3BlYyA9IFNUUkJVRl9JTklUOwoKCWlmICghYnJhbmNoKQoJCWRpZShfKG1lc3NhZ2VfZGV0YWNoZWRfaGVhZF9kaWUpLCByZW1vdGUtPm5hbWUpOwoJaWYgKCFicmFuY2gtPm1lcmdlX25yIHx8ICFicmFuY2gtPm1lcmdlIHx8ICFicmFuY2gtPnJlbW90ZV9uYW1lKQoJCWRpZShfKCJUaGUgY3VycmVudCBicmFuY2ggJXMgaGFzIG5vIHVwc3RyZWFtIGJyYW5jaC5cbiIKCQkgICAgIlRvIHB1c2ggdGhlIGN1cnJlbnQgYnJhbmNoIGFuZCBzZXQgdGhlIHJlbW90ZSBhcyB1cHN0cmVhbSwgdXNlXG4iCgkJICAgICJcbiIKCQkgICAgIiAgICBnaXQgcHVzaCAtLXNldC11cHN0cmVhbSAlcyAlc1xuIiksCgkJICAgIGJyYW5jaC0+bmFtZSwKCQkgICAgcmVtb3RlLT5uYW1lLAoJCSAgICBicmFuY2gtPm5hbWUpOwoJaWYgKGJyYW5jaC0+bWVyZ2VfbnIgIT0gMSkKCQlkaWUoXygiVGhlIGN1cnJlbnQgYnJhbmNoICVzIGhhcyBtdWx0aXBsZSB1cHN0cmVhbSBicmFuY2hlcywgIgoJCSAgICAicmVmdXNpbmcgdG8gcHVzaC4iKSwgYnJhbmNoLT5uYW1lKTsKCWlmICh0cmlhbmd1bGFyKQoJCWRpZShfKCJZb3UgYXJlIHB1c2hpbmcgdG8gcmVtb3RlICclcycsIHdoaWNoIGlzIG5vdCB0aGUgdXBzdHJlYW0gb2ZcbiIKCQkgICAgICAieW91ciBjdXJyZW50IGJyYW5jaCAnJXMnLCB3aXRob3V0IHRlbGxpbmcgbWUgd2hhdCB0byBwdXNoXG4iCgkJICAgICAgInRvIHVwZGF0ZSB3aGljaCByZW1vdGUgYnJhbmNoLiIpLAoJCSAgICByZW1vdGUtPm5hbWUsIGJyYW5jaC0+bmFtZSk7CgoJaWYgKHNpbXBsZSkgewoJCS8qIEFkZGl0aW9uYWwgc2FmZXR5ICovCgkJaWYgKHN0cmNtcChicmFuY2gtPnJlZm5hbWUsIGJyYW5jaC0+bWVyZ2VbMF0tPnNyYykpCgkJCWRpZV9wdXNoX3NpbXBsZShicmFuY2gsIHJlbW90ZSk7Cgl9CgoJc3RyYnVmX2FkZGYoJnJlZnNwZWMsICIlczolcyIsIGJyYW5jaC0+cmVmbmFtZSwgYnJhbmNoLT5tZXJnZVswXS0+c3JjKTsKCWFkZF9yZWZzcGVjKHJlZnNwZWMuYnVmKTsKfQoKc3RhdGljIHZvaWQgc2V0dXBfcHVzaF9jdXJyZW50KHN0cnVjdCByZW1vdGUgKnJlbW90ZSwgc3RydWN0IGJyYW5jaCAqYnJhbmNoKQp7CglzdHJ1Y3Qgc3RyYnVmIHJlZnNwZWMgPSBTVFJCVUZfSU5JVDsKCglpZiAoIWJyYW5jaCkKCQlkaWUoXyhtZXNzYWdlX2RldGFjaGVkX2hlYWRfZGllKSwgcmVtb3RlLT5uYW1lKTsKCXN0cmJ1Zl9hZGRmKCZyZWZzcGVjLCAiJXM6JXMiLCBicmFuY2gtPnJlZm5hbWUsIGJyYW5jaC0+cmVmbmFtZSk7CglhZGRfcmVmc3BlYyhyZWZzcGVjLmJ1Zik7Cn0KCnN0YXRpYyBpbnQgaXNfd29ya2Zsb3dfdHJpYW5ndWxhcihzdHJ1Y3QgcmVtb3RlICpyZW1vdGUpCnsKCXN0cnVjdCByZW1vdGUgKmZldGNoX3JlbW90ZSA9IHJlbW90ZV9nZXQoTlVMTCk7CglyZXR1cm4gKGZldGNoX3JlbW90ZSAmJiBmZXRjaF9yZW1vdGUgIT0gcmVtb3RlKTsKfQoKc3RhdGljIHZvaWQgc2V0dXBfZGVmYXVsdF9wdXNoX3JlZnNwZWNzKHN0cnVjdCByZW1vdGUgKnJlbW90ZSkKewoJc3RydWN0IGJyYW5jaCAqYnJhbmNoID0gYnJhbmNoX2dldChOVUxMKTsKCWludCB0cmlhbmd1bGFyID0gaXNfd29ya2Zsb3dfdHJpYW5ndWxhcihyZW1vdGUpOwoKCXN3aXRjaCAocHVzaF9kZWZhdWx0KSB7CglkZWZhdWx0OgoJY2FzZSBQVVNIX0RFRkFVTFRfTUFUQ0hJTkc6CgkJYWRkX3JlZnNwZWMoIjoiKTsKCQlicmVhazsKCgljYXNlIFBVU0hfREVGQVVMVF9VTlNQRUNJRklFRDoKCWNhc2UgUFVTSF9ERUZBVUxUX1NJTVBMRToKCQlpZiAodHJpYW5ndWxhcikKCQkJc2V0dXBfcHVzaF9jdXJyZW50KHJlbW90ZSwgYnJhbmNoKTsKCQllbHNlCgkJCXNldHVwX3B1c2hfdXBzdHJlYW0ocmVtb3RlLCBicmFuY2gsIHRyaWFuZ3VsYXIsIDEpOwoJCWJyZWFrOwoKCWNhc2UgUFVTSF9ERUZBVUxUX1VQU1RSRUFNOgoJCXNldHVwX3B1c2hfdXBzdHJlYW0ocmVtb3RlLCBicmFuY2gsIHRyaWFuZ3VsYXIsIDApOwoJCWJyZWFrOwoKCWNhc2UgUFVTSF9ERUZBVUxUX0NVUlJFTlQ6CgkJc2V0dXBfcHVzaF9jdXJyZW50KHJlbW90ZSwgYnJhbmNoKTsKCQlicmVhazsKCgljYXNlIFBVU0hfREVGQVVMVF9OT1RISU5HOgoJCWRpZShfKCJZb3UgZGlkbid0IHNwZWNpZnkgYW55IHJlZnNwZWNzIHRvIHB1c2gsIGFuZCAiCgkJICAgICJwdXNoLmRlZmF1bHQgaXMgXCJub3RoaW5nXCIuIikpOwoJCWJyZWFrOwoJfQp9CgpzdGF0aWMgY29uc3QgY2hhciBtZXNzYWdlX2FkdmljZV9wdWxsX2JlZm9yZV9wdXNoW10gPQoJTl8oIlVwZGF0ZXMgd2VyZSByZWplY3RlZCBiZWNhdXNlIHRoZSB0aXAgb2YgeW91ciBjdXJyZW50IGJyYW5jaCBpcyBiZWhpbmRcbiIKCSAgICJpdHMgcmVtb3RlIGNvdW50ZXJwYXJ0LiBJbnRlZ3JhdGUgdGhlIHJlbW90ZSBjaGFuZ2VzIChlLmcuXG4iCgkgICAiJ2dpdCBwdWxsIC4uLicpIGJlZm9yZSBwdXNoaW5nIGFnYWluLlxuIgoJICAgIlNlZSB0aGUgJ05vdGUgYWJvdXQgZmFzdC1mb3J3YXJkcycgaW4gJ2dpdCBwdXNoIC0taGVscCcgZm9yIGRldGFpbHMuIik7CgpzdGF0aWMgY29uc3QgY2hhciBtZXNzYWdlX2FkdmljZV9jaGVja291dF9wdWxsX3B1c2hbXSA9CglOXygiVXBkYXRlcyB3ZXJlIHJlamVjdGVkIGJlY2F1c2UgYSBwdXNoZWQgYnJhbmNoIHRpcCBpcyBiZWhpbmQgaXRzIHJlbW90ZVxuIgoJICAgImNvdW50ZXJwYXJ0LiBDaGVjayBvdXQgdGhpcyBicmFuY2ggYW5kIGludGVncmF0ZSB0aGUgcmVtb3RlIGNoYW5nZXNcbiIKCSAgICIoZS5nLiAnZ2l0IHB1bGwgLi4uJykgYmVmb3JlIHB1c2hpbmcgYWdhaW4uXG4iCgkgICAiU2VlIHRoZSAnTm90ZSBhYm91dCBmYXN0LWZvcndhcmRzJyBpbiAnZ2l0IHB1c2ggLS1oZWxwJyBmb3IgZGV0YWlscy4iKTsKCnN0YXRpYyBjb25zdCBjaGFyIG1lc3NhZ2VfYWR2aWNlX3JlZl9mZXRjaF9maXJzdFtdID0KCU5fKCJVcGRhdGVzIHdlcmUgcmVqZWN0ZWQgYmVjYXVzZSB0aGUgcmVtb3RlIGNvbnRhaW5zIHdvcmsgdGhhdCB5b3UgZG9cbiIKCSAgICJub3QgaGF2ZSBsb2NhbGx5LiBUaGlzIGlzIHVzdWFsbHkgY2F1c2VkIGJ5IGFub3RoZXIgcmVwb3NpdG9yeSBwdXNoaW5nXG4iCgkgICAidG8gdGhlIHNhbWUgcmVmLiBZb3UgbWF5IHdhbnQgdG8gZmlyc3QgaW50ZWdyYXRlIHRoZSByZW1vdGUgY2hhbmdlc1xuIgoJICAgIihlLmcuLCAnZ2l0IHB1bGwgLi4uJykgYmVmb3JlIHB1c2hpbmcgYWdhaW4uXG4iCgkgICAiU2VlIHRoZSAnTm90ZSBhYm91dCBmYXN0LWZvcndhcmRzJyBpbiAnZ2l0IHB1c2ggLS1oZWxwJyBmb3IgZGV0YWlscy4iKTsKCnN0YXRpYyBjb25zdCBjaGFyIG1lc3NhZ2VfYWR2aWNlX3JlZl9hbHJlYWR5X2V4aXN0c1tdID0KCU5fKCJVcGRhdGVzIHdlcmUgcmVqZWN0ZWQgYmVjYXVzZSB0aGUgdGFnIGFscmVhZHkgZXhpc3RzIGluIHRoZSByZW1vdGUuIik7CgpzdGF0aWMgY29uc3QgY2hhciBtZXNzYWdlX2FkdmljZV9yZWZfbmVlZHNfZm9yY2VbXSA9CglOXygiWW91IGNhbm5vdCB1cGRhdGUgYSByZW1vdGUgcmVmIHRoYXQgcG9pbnRzIGF0IGEgbm9uLWNvbW1pdCBvYmplY3QsXG4iCgkgICAib3IgdXBkYXRlIGEgcmVtb3RlIHJlZiB0byBtYWtlIGl0IHBvaW50IGF0IGEgbm9uLWNvbW1pdCBvYmplY3QsXG4iCgkgICAid2l0aG91dCB1c2luZyB0aGUgJy0tZm9yY2UnIG9wdGlvbi5cbiIpOwoKc3RhdGljIHZvaWQgYWR2aXNlX3B1bGxfYmVmb3JlX3B1c2godm9pZCkKewoJaWYgKCFhZHZpY2VfcHVzaF9ub25fZmZfY3VycmVudCB8fCAhYWR2aWNlX3B1c2hfdXBkYXRlX3JlamVjdGVkKQoJCXJldHVybjsKCWFkdmlzZShfKG1lc3NhZ2VfYWR2aWNlX3B1bGxfYmVmb3JlX3B1c2gpKTsKfQoKc3RhdGljIHZvaWQgYWR2aXNlX2NoZWNrb3V0X3B1bGxfcHVzaCh2b2lkKQp7CglpZiAoIWFkdmljZV9wdXNoX25vbl9mZl9tYXRjaGluZyB8fCAhYWR2aWNlX3B1c2hfdXBkYXRlX3JlamVjdGVkKQoJCXJldHVybjsKCWFkdmlzZShfKG1lc3NhZ2VfYWR2aWNlX2NoZWNrb3V0X3B1bGxfcHVzaCkpOwp9CgpzdGF0aWMgdm9pZCBhZHZpc2VfcmVmX2FscmVhZHlfZXhpc3RzKHZvaWQpCnsKCWlmICghYWR2aWNlX3B1c2hfYWxyZWFkeV9leGlzdHMgfHwgIWFkdmljZV9wdXNoX3VwZGF0ZV9yZWplY3RlZCkKCQlyZXR1cm47CglhZHZpc2UoXyhtZXNzYWdlX2FkdmljZV9yZWZfYWxyZWFkeV9leGlzdHMpKTsKfQoKc3RhdGljIHZvaWQgYWR2aXNlX3JlZl9mZXRjaF9maXJzdCh2b2lkKQp7CglpZiAoIWFkdmljZV9wdXNoX2ZldGNoX2ZpcnN0IHx8ICFhZHZpY2VfcHVzaF91cGRhdGVfcmVqZWN0ZWQpCgkJcmV0dXJuOwoJYWR2aXNlKF8obWVzc2FnZV9hZHZpY2VfcmVmX2ZldGNoX2ZpcnN0KSk7Cn0KCnN0YXRpYyB2b2lkIGFkdmlzZV9yZWZfbmVlZHNfZm9yY2Uodm9pZCkKewoJaWYgKCFhZHZpY2VfcHVzaF9uZWVkc19mb3JjZSB8fCAhYWR2aWNlX3B1c2hfdXBkYXRlX3JlamVjdGVkKQoJCXJldHVybjsKCWFkdmlzZShfKG1lc3NhZ2VfYWR2aWNlX3JlZl9uZWVkc19mb3JjZSkpOwp9CgpzdGF0aWMgaW50IHB1c2hfd2l0aF9vcHRpb25zKHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCwgaW50IGZsYWdzKQp7CglpbnQgZXJyOwoJdW5zaWduZWQgaW50IHJlamVjdF9yZWFzb25zOwoKCXRyYW5zcG9ydF9zZXRfdmVyYm9zaXR5KHRyYW5zcG9ydCwgdmVyYm9zaXR5LCBwcm9ncmVzcyk7Cgl0cmFuc3BvcnQtPmZhbWlseSA9IGZhbWlseTsKCglpZiAocmVjZWl2ZXBhY2spCgkJdHJhbnNwb3J0X3NldF9vcHRpb24odHJhbnNwb3J0LAoJCQkJICAgICBUUkFOU19PUFRfUkVDRUlWRVBBQ0ssIHJlY2VpdmVwYWNrKTsKCXRyYW5zcG9ydF9zZXRfb3B0aW9uKHRyYW5zcG9ydCwgVFJBTlNfT1BUX1RISU4sIHRoaW4gPyAieWVzIiA6IE5VTEwpOwoKCWlmICghaXNfZW1wdHlfY2FzKCZjYXMpKSB7CgkJaWYgKCF0cmFuc3BvcnQtPnNtYXJ0X29wdGlvbnMpCgkJCWRpZSgidW5kZXJseWluZyB0cmFuc3BvcnQgZG9lcyBub3Qgc3VwcG9ydCAtLSVzIG9wdGlvbiIsCgkJCSAgICBDQVNfT1BUX05BTUUpOwoJCXRyYW5zcG9ydC0+c21hcnRfb3B0aW9ucy0+Y2FzID0gJmNhczsKCX0KCglpZiAodmVyYm9zaXR5ID4gMCkKCQlmcHJpbnRmKHN0ZGVyciwgXygiUHVzaGluZyB0byAlc1xuIiksIHRyYW5zcG9ydC0+dXJsKTsKCWVyciA9IHRyYW5zcG9ydF9wdXNoKHRyYW5zcG9ydCwgcmVmc3BlY19uciwgcmVmc3BlYywgZmxhZ3MsCgkJCSAgICAgJnJlamVjdF9yZWFzb25zKTsKCWlmIChlcnIgIT0gMCkKCQllcnJvcihfKCJmYWlsZWQgdG8gcHVzaCBzb21lIHJlZnMgdG8gJyVzJyIpLCB0cmFuc3BvcnQtPnVybCk7CgoJZXJyIHw9IHRyYW5zcG9ydF9kaXNjb25uZWN0KHRyYW5zcG9ydCk7CglpZiAoIWVycikKCQlyZXR1cm4gMDsKCglpZiAocmVqZWN0X3JlYXNvbnMgJiBSRUpFQ1RfTk9OX0ZGX0hFQUQpIHsKCQlhZHZpc2VfcHVsbF9iZWZvcmVfcHVzaCgpOwoJfSBlbHNlIGlmIChyZWplY3RfcmVhc29ucyAmIFJFSkVDVF9OT05fRkZfT1RIRVIpIHsKCQlhZHZpc2VfY2hlY2tvdXRfcHVsbF9wdXNoKCk7Cgl9IGVsc2UgaWYgKHJlamVjdF9yZWFzb25zICYgUkVKRUNUX0FMUkVBRFlfRVhJU1RTKSB7CgkJYWR2aXNlX3JlZl9hbHJlYWR5X2V4aXN0cygpOwoJfSBlbHNlIGlmIChyZWplY3RfcmVhc29ucyAmIFJFSkVDVF9GRVRDSF9GSVJTVCkgewoJCWFkdmlzZV9yZWZfZmV0Y2hfZmlyc3QoKTsKCX0gZWxzZSBpZiAocmVqZWN0X3JlYXNvbnMgJiBSRUpFQ1RfTkVFRFNfRk9SQ0UpIHsKCQlhZHZpc2VfcmVmX25lZWRzX2ZvcmNlKCk7Cgl9CgoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBpbnQgZG9fcHVzaChjb25zdCBjaGFyICpyZXBvLCBpbnQgZmxhZ3MpCnsKCWludCBpLCBlcnJzOwoJc3RydWN0IHJlbW90ZSAqcmVtb3RlID0gcHVzaHJlbW90ZV9nZXQocmVwbyk7Cgljb25zdCBjaGFyICoqdXJsOwoJaW50IHVybF9ucjsKCglpZiAoIXJlbW90ZSkgewoJCWlmIChyZXBvKQoJCQlkaWUoXygiYmFkIHJlcG9zaXRvcnkgJyVzJyIpLCByZXBvKTsKCQlkaWUoXygiTm8gY29uZmlndXJlZCBwdXNoIGRlc3RpbmF0aW9uLlxuIgoJCSAgICAiRWl0aGVyIHNwZWNpZnkgdGhlIFVSTCBmcm9tIHRoZSBjb21tYW5kLWxpbmUgb3IgY29uZmlndXJlIGEgcmVtb3RlIHJlcG9zaXRvcnkgdXNpbmdcbiIKCQkgICAgIlxuIgoJCSAgICAiICAgIGdpdCByZW1vdGUgYWRkIDxuYW1lPiA8dXJsPlxuIgoJCSAgICAiXG4iCgkJICAgICJhbmQgdGhlbiBwdXNoIHVzaW5nIHRoZSByZW1vdGUgbmFtZVxuIgoJCSAgICAiXG4iCgkJICAgICIgICAgZ2l0IHB1c2ggPG5hbWU+XG4iKSk7Cgl9CgoJaWYgKHJlbW90ZS0+bWlycm9yKQoJCWZsYWdzIHw9IChUUkFOU1BPUlRfUFVTSF9NSVJST1J8VFJBTlNQT1JUX1BVU0hfRk9SQ0UpOwoKCWlmICgoZmxhZ3MgJiBUUkFOU1BPUlRfUFVTSF9BTEwpICYmIHJlZnNwZWMpIHsKCQlpZiAoIXN0cmNtcCgqcmVmc3BlYywgInJlZnMvdGFncy8qIikpCgkJCXJldHVybiBlcnJvcihfKCItLWFsbCBhbmQgLS10YWdzIGFyZSBpbmNvbXBhdGlibGUiKSk7CgkJcmV0dXJuIGVycm9yKF8oIi0tYWxsIGNhbid0IGJlIGNvbWJpbmVkIHdpdGggcmVmc3BlY3MiKSk7Cgl9CgoJaWYgKChmbGFncyAmIFRSQU5TUE9SVF9QVVNIX01JUlJPUikgJiYgcmVmc3BlYykgewoJCWlmICghc3RyY21wKCpyZWZzcGVjLCAicmVmcy90YWdzLyoiKSkKCQkJcmV0dXJuIGVycm9yKF8oIi0tbWlycm9yIGFuZCAtLXRhZ3MgYXJlIGluY29tcGF0aWJsZSIpKTsKCQlyZXR1cm4gZXJyb3IoXygiLS1taXJyb3IgY2FuJ3QgYmUgY29tYmluZWQgd2l0aCByZWZzcGVjcyIpKTsKCX0KCglpZiAoKGZsYWdzICYgKFRSQU5TUE9SVF9QVVNIX0FMTHxUUkFOU1BPUlRfUFVTSF9NSVJST1IpKSA9PQoJCQkJKFRSQU5TUE9SVF9QVVNIX0FMTHxUUkFOU1BPUlRfUFVTSF9NSVJST1IpKSB7CgkJcmV0dXJuIGVycm9yKF8oIi0tYWxsIGFuZCAtLW1pcnJvciBhcmUgaW5jb21wYXRpYmxlIikpOwoJfQoKCWlmICghcmVmc3BlYyAmJiAhKGZsYWdzICYgVFJBTlNQT1JUX1BVU0hfQUxMKSkgewoJCWlmIChyZW1vdGUtPnB1c2hfcmVmc3BlY19ucikgewoJCQlyZWZzcGVjID0gcmVtb3RlLT5wdXNoX3JlZnNwZWM7CgkJCXJlZnNwZWNfbnIgPSByZW1vdGUtPnB1c2hfcmVmc3BlY19ucjsKCQl9IGVsc2UgaWYgKCEoZmxhZ3MgJiBUUkFOU1BPUlRfUFVTSF9NSVJST1IpKQoJCQlzZXR1cF9kZWZhdWx0X3B1c2hfcmVmc3BlY3MocmVtb3RlKTsKCX0KCWVycnMgPSAwOwoJdXJsX25yID0gcHVzaF91cmxfb2ZfcmVtb3RlKHJlbW90ZSwgJnVybCk7CglpZiAodXJsX25yKSB7CgkJZm9yIChpID0gMDsgaSA8IHVybF9ucjsgaSsrKSB7CgkJCXN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCA9CgkJCQl0cmFuc3BvcnRfZ2V0KHJlbW90ZSwgdXJsW2ldKTsKCQkJaWYgKHB1c2hfd2l0aF9vcHRpb25zKHRyYW5zcG9ydCwgZmxhZ3MpKQoJCQkJZXJycysrOwoJCX0KCX0gZWxzZSB7CgkJc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0ID0KCQkJdHJhbnNwb3J0X2dldChyZW1vdGUsIE5VTEwpOwoKCQlpZiAocHVzaF93aXRoX29wdGlvbnModHJhbnNwb3J0LCBmbGFncykpCgkJCWVycnMrKzsKCX0KCXJldHVybiAhIWVycnM7Cn0KCnN0YXRpYyBpbnQgb3B0aW9uX3BhcnNlX3JlY3Vyc2Vfc3VibW9kdWxlcyhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsCgkJCQkgICBjb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJaW50ICpyZWN1cnNlX3N1Ym1vZHVsZXMgPSBvcHQtPnZhbHVlOwoKCWlmICh1bnNldCkKCQkqcmVjdXJzZV9zdWJtb2R1bGVzID0gUkVDVVJTRV9TVUJNT0RVTEVTX09GRjsKCWVsc2UgaWYgKGFyZykKCQkqcmVjdXJzZV9zdWJtb2R1bGVzID0gcGFyc2VfcHVzaF9yZWN1cnNlX3N1Ym1vZHVsZXNfYXJnKG9wdC0+bG9uZ19uYW1lLCBhcmcpOwoJZWxzZQoJCWRpZSgiJXMgbWlzc2luZyBwYXJhbWV0ZXIiLCBvcHQtPmxvbmdfbmFtZSk7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHNldF9wdXNoX2NlcnRfZmxhZ3MoaW50ICpmbGFncywgaW50IHYpCnsKCXN3aXRjaCAodikgewoJY2FzZSBTRU5EX1BBQ0tfUFVTSF9DRVJUX05FVkVSOgoJCSpmbGFncyAmPSB+KFRSQU5TUE9SVF9QVVNIX0NFUlRfQUxXQVlTIHwgVFJBTlNQT1JUX1BVU0hfQ0VSVF9JRl9BU0tFRCk7CgkJYnJlYWs7CgljYXNlIFNFTkRfUEFDS19QVVNIX0NFUlRfQUxXQVlTOgoJCSpmbGFncyB8PSBUUkFOU1BPUlRfUFVTSF9DRVJUX0FMV0FZUzsKCQkqZmxhZ3MgJj0gflRSQU5TUE9SVF9QVVNIX0NFUlRfSUZfQVNLRUQ7CgkJYnJlYWs7CgljYXNlIFNFTkRfUEFDS19QVVNIX0NFUlRfSUZfQVNLRUQ6CgkJKmZsYWdzIHw9IFRSQU5TUE9SVF9QVVNIX0NFUlRfSUZfQVNLRUQ7CgkJKmZsYWdzICY9IH5UUkFOU1BPUlRfUFVTSF9DRVJUX0FMV0FZUzsKCQlicmVhazsKCX0KfQoKCnN0YXRpYyBpbnQgZ2l0X3B1c2hfY29uZmlnKGNvbnN0IGNoYXIgKmssIGNvbnN0IGNoYXIgKnYsIHZvaWQgKmNiKQp7CglpbnQgKmZsYWdzID0gY2I7CglpbnQgc3RhdHVzOwoKCXN0YXR1cyA9IGdpdF9ncGdfY29uZmlnKGssIHYsIE5VTEwpOwoJaWYgKHN0YXR1cykKCQlyZXR1cm4gc3RhdHVzOwoKCWlmICghc3RyY21wKGssICJwdXNoLmZvbGxvd3RhZ3MiKSkgewoJCWlmIChnaXRfY29uZmlnX2Jvb2woaywgdikpCgkJCSpmbGFncyB8PSBUUkFOU1BPUlRfUFVTSF9GT0xMT1dfVEFHUzsKCQllbHNlCgkJCSpmbGFncyAmPSB+VFJBTlNQT1JUX1BVU0hfRk9MTE9XX1RBR1M7CgkJcmV0dXJuIDA7Cgl9IGVsc2UgaWYgKCFzdHJjbXAoaywgInB1c2guZ3Bnc2lnbiIpKSB7CgkJY29uc3QgY2hhciAqdmFsdWU7CgkJaWYgKCFnaXRfY29uZmlnX2dldF92YWx1ZSgicHVzaC5ncGdzaWduIiwgJnZhbHVlKSkgewoJCQlzd2l0Y2ggKGdpdF9jb25maWdfbWF5YmVfYm9vbCgicHVzaC5ncGdzaWduIiwgdmFsdWUpKSB7CgkJCWNhc2UgMDoKCQkJCXNldF9wdXNoX2NlcnRfZmxhZ3MoZmxhZ3MsIFNFTkRfUEFDS19QVVNIX0NFUlRfTkVWRVIpOwoJCQkJYnJlYWs7CgkJCWNhc2UgMToKCQkJCXNldF9wdXNoX2NlcnRfZmxhZ3MoZmxhZ3MsIFNFTkRfUEFDS19QVVNIX0NFUlRfQUxXQVlTKTsKCQkJCWJyZWFrOwoJCQlkZWZhdWx0OgoJCQkJaWYgKHZhbHVlICYmICFzdHJjYXNlY21wKHZhbHVlLCAiaWYtYXNrZWQiKSkKCQkJCQlzZXRfcHVzaF9jZXJ0X2ZsYWdzKGZsYWdzLCBTRU5EX1BBQ0tfUFVTSF9DRVJUX0lGX0FTS0VEKTsKCQkJCWVsc2UKCQkJCQlyZXR1cm4gZXJyb3IoIkludmFsaWQgdmFsdWUgZm9yICclcyciLCBrKTsKCQkJfQoJCX0KCX0gZWxzZSBpZiAoIXN0cmNtcChrLCAicHVzaC5yZWN1cnNlc3VibW9kdWxlcyIpKSB7CgkJY29uc3QgY2hhciAqdmFsdWU7CgkJaWYgKCFnaXRfY29uZmlnX2dldF92YWx1ZSgicHVzaC5yZWN1cnNlc3VibW9kdWxlcyIsICZ2YWx1ZSkpCgkJCXJlY3Vyc2Vfc3VibW9kdWxlcyA9IHBhcnNlX3B1c2hfcmVjdXJzZV9zdWJtb2R1bGVzX2FyZyhrLCB2YWx1ZSk7Cgl9CgoJcmV0dXJuIGdpdF9kZWZhdWx0X2NvbmZpZyhrLCB2LCBOVUxMKTsKfQoKaW50IGNtZF9wdXNoKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglpbnQgZmxhZ3MgPSAwOwoJaW50IHRhZ3MgPSAwOwoJaW50IHB1c2hfY2VydCA9IC0xOwoJaW50IHJjOwoJY29uc3QgY2hhciAqcmVwbyA9IE5VTEw7CS8qIGRlZmF1bHQgcmVwb3NpdG9yeSAqLwoJc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJT1BUX19WRVJCT1NJVFkoJnZlcmJvc2l0eSksCgkJT1BUX1NUUklORyggMCAsICJyZXBvIiwgJnJlcG8sIE5fKCJyZXBvc2l0b3J5IiksIE5fKCJyZXBvc2l0b3J5IikpLAoJCU9QVF9CSVQoIDAgLCAiYWxsIiwgJmZsYWdzLCBOXygicHVzaCBhbGwgcmVmcyIpLCBUUkFOU1BPUlRfUFVTSF9BTEwpLAoJCU9QVF9CSVQoIDAgLCAibWlycm9yIiwgJmZsYWdzLCBOXygibWlycm9yIGFsbCByZWZzIiksCgkJCSAgICAoVFJBTlNQT1JUX1BVU0hfTUlSUk9SfFRSQU5TUE9SVF9QVVNIX0ZPUkNFKSksCgkJT1BUX0JPT0woJ2QnLCAiZGVsZXRlIiwgJmRlbGV0ZXJlZnMsIE5fKCJkZWxldGUgcmVmcyIpKSwKCQlPUFRfQk9PTCggMCAsICJ0YWdzIiwgJnRhZ3MsIE5fKCJwdXNoIHRhZ3MgKGNhbid0IGJlIHVzZWQgd2l0aCAtLWFsbCBvciAtLW1pcnJvcikiKSksCgkJT1BUX0JJVCgnbicgLCAiZHJ5LXJ1biIsICZmbGFncywgTl8oImRyeSBydW4iKSwgVFJBTlNQT1JUX1BVU0hfRFJZX1JVTiksCgkJT1BUX0JJVCggMCwgICJwb3JjZWxhaW4iLCAmZmxhZ3MsIE5fKCJtYWNoaW5lLXJlYWRhYmxlIG91dHB1dCIpLCBUUkFOU1BPUlRfUFVTSF9QT1JDRUxBSU4pLAoJCU9QVF9CSVQoJ2YnLCAiZm9yY2UiLCAmZmxhZ3MsIE5fKCJmb3JjZSB1cGRhdGVzIiksIFRSQU5TUE9SVF9QVVNIX0ZPUkNFKSwKCQl7IE9QVElPTl9DQUxMQkFDSywKCQkgIDAsIENBU19PUFRfTkFNRSwgJmNhcywgTl8oInJlZm5hbWU+OjxleHBlY3QiKSwKCQkgIE5fKCJyZXF1aXJlIG9sZCB2YWx1ZSBvZiByZWYgdG8gYmUgYXQgdGhpcyB2YWx1ZSIpLAoJCSAgUEFSU0VfT1BUX09QVEFSRywgcGFyc2VvcHRfcHVzaF9jYXNfb3B0aW9uIH0sCgkJeyBPUFRJT05fQ0FMTEJBQ0ssIDAsICJyZWN1cnNlLXN1Ym1vZHVsZXMiLCAmcmVjdXJzZV9zdWJtb2R1bGVzLCAiY2hlY2t8b24tZGVtYW5kfG5vIiwKCQkJTl8oImNvbnRyb2wgcmVjdXJzaXZlIHB1c2hpbmcgb2Ygc3VibW9kdWxlcyIpLAoJCQlQQVJTRV9PUFRfT1BUQVJHLCBvcHRpb25fcGFyc2VfcmVjdXJzZV9zdWJtb2R1bGVzIH0sCgkJT1BUX0JPT0woIDAgLCAidGhpbiIsICZ0aGluLCBOXygidXNlIHRoaW4gcGFjayIpKSwKCQlPUFRfU1RSSU5HKCAwICwgInJlY2VpdmUtcGFjayIsICZyZWNlaXZlcGFjaywgInJlY2VpdmUtcGFjayIsIE5fKCJyZWNlaXZlIHBhY2sgcHJvZ3JhbSIpKSwKCQlPUFRfU1RSSU5HKCAwICwgImV4ZWMiLCAmcmVjZWl2ZXBhY2ssICJyZWNlaXZlLXBhY2siLCBOXygicmVjZWl2ZSBwYWNrIHByb2dyYW0iKSksCgkJT1BUX0JJVCgndScsICJzZXQtdXBzdHJlYW0iLCAmZmxhZ3MsIE5fKCJzZXQgdXBzdHJlYW0gZm9yIGdpdCBwdWxsL3N0YXR1cyIpLAoJCQlUUkFOU1BPUlRfUFVTSF9TRVRfVVBTVFJFQU0pLAoJCU9QVF9CT09MKDAsICJwcm9ncmVzcyIsICZwcm9ncmVzcywgTl8oImZvcmNlIHByb2dyZXNzIHJlcG9ydGluZyIpKSwKCQlPUFRfQklUKDAsICJwcnVuZSIsICZmbGFncywgTl8oInBydW5lIGxvY2FsbHkgcmVtb3ZlZCByZWZzIiksCgkJCVRSQU5TUE9SVF9QVVNIX1BSVU5FKSwKCQlPUFRfQklUKDAsICJuby12ZXJpZnkiLCAmZmxhZ3MsIE5fKCJieXBhc3MgcHJlLXB1c2ggaG9vayIpLCBUUkFOU1BPUlRfUFVTSF9OT19IT09LKSwKCQlPUFRfQklUKDAsICJmb2xsb3ctdGFncyIsICZmbGFncywgTl8oInB1c2ggbWlzc2luZyBidXQgcmVsZXZhbnQgdGFncyIpLAoJCQlUUkFOU1BPUlRfUFVTSF9GT0xMT1dfVEFHUyksCgkJeyBPUFRJT05fQ0FMTEJBQ0ssCgkJICAwLCAic2lnbmVkIiwgJnB1c2hfY2VydCwgInllc3xub3xpZi1hc2tlZCIsIE5fKCJHUEcgc2lnbiB0aGUgcHVzaCIpLAoJCSAgUEFSU0VfT1BUX09QVEFSRywgb3B0aW9uX3BhcnNlX3B1c2hfc2lnbmVkIH0sCgkJT1BUX0JJVCgwLCAiYXRvbWljIiwgJmZsYWdzLCBOXygicmVxdWVzdCBhdG9taWMgdHJhbnNhY3Rpb24gb24gcmVtb3RlIHNpZGUiKSwgVFJBTlNQT1JUX1BVU0hfQVRPTUlDKSwKCQlPUFRfU0VUX0lOVCgnNCcsICJpcHY0IiwgJmZhbWlseSwgTl8oInVzZSBJUHY0IGFkZHJlc3NlcyBvbmx5IiksCgkJCQlUUkFOU1BPUlRfRkFNSUxZX0lQVjQpLAoJCU9QVF9TRVRfSU5UKCc2JywgImlwdjYiLCAmZmFtaWx5LCBOXygidXNlIElQdjYgYWRkcmVzc2VzIG9ubHkiKSwKCQkJCVRSQU5TUE9SVF9GQU1JTFlfSVBWNiksCgkJT1BUX0VORCgpCgl9OwoKCXBhY2tldF90cmFjZV9pZGVudGl0eSgicHVzaCIpOwoJZ2l0X2NvbmZpZyhnaXRfcHVzaF9jb25maWcsICZmbGFncyk7CglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIG9wdGlvbnMsIHB1c2hfdXNhZ2UsIDApOwoJc2V0X3B1c2hfY2VydF9mbGFncygmZmxhZ3MsIHB1c2hfY2VydCk7CgoJaWYgKGRlbGV0ZXJlZnMgJiYgKHRhZ3MgfHwgKGZsYWdzICYgKFRSQU5TUE9SVF9QVVNIX0FMTCB8IFRSQU5TUE9SVF9QVVNIX01JUlJPUikpKSkKCQlkaWUoXygiLS1kZWxldGUgaXMgaW5jb21wYXRpYmxlIHdpdGggLS1hbGwsIC0tbWlycm9yIGFuZCAtLXRhZ3MiKSk7CglpZiAoZGVsZXRlcmVmcyAmJiBhcmdjIDwgMikKCQlkaWUoXygiLS1kZWxldGUgZG9lc24ndCBtYWtlIHNlbnNlIHdpdGhvdXQgYW55IHJlZnMiKSk7CgoJaWYgKHJlY3Vyc2Vfc3VibW9kdWxlcyA9PSBSRUNVUlNFX1NVQk1PRFVMRVNfQ0hFQ0spCgkJZmxhZ3MgfD0gVFJBTlNQT1JUX1JFQ1VSU0VfU1VCTU9EVUxFU19DSEVDSzsKCWVsc2UgaWYgKHJlY3Vyc2Vfc3VibW9kdWxlcyA9PSBSRUNVUlNFX1NVQk1PRFVMRVNfT05fREVNQU5EKQoJCWZsYWdzIHw9IFRSQU5TUE9SVF9SRUNVUlNFX1NVQk1PRFVMRVNfT05fREVNQU5EOwoKCWlmICh0YWdzKQoJCWFkZF9yZWZzcGVjKCJyZWZzL3RhZ3MvKiIpOwoKCWlmIChhcmdjID4gMCkgewoJCXJlcG8gPSBhcmd2WzBdOwoJCXNldF9yZWZzcGVjcyhhcmd2ICsgMSwgYXJnYyAtIDEsIHJlcG8pOwoJfQoKCXJjID0gZG9fcHVzaChyZXBvLCBmbGFncyk7CglpZiAocmMgPT0gLTEpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKHB1c2hfdXNhZ2UsIG9wdGlvbnMpOwoJZWxzZQoJCXJldHVybiByYzsKfQo=",
    "text": "/*\n * \"git push\"\n */\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"run-command.h\"\n#include \"builtin.h\"\n#include \"remote.h\"\n#include \"transport.h\"\n#include \"parse-options.h\"\n#include \"submodule.h\"\n#include \"submodule-config.h\"\n#include \"send-pack.h\"\n\nstatic const char * const push_usage[] = {\n\tN_(\"git push [<options>] [<repository> [<refspec>...]]\"),\n\tNULL,\n};\n\nstatic int thin = 1;\nstatic int deleterefs;\nstatic const char *receivepack;\nstatic int verbosity;\nstatic int progress = -1;\nstatic int recurse_submodules = RECURSE_SUBMODULES_DEFAULT;\nstatic enum transport_family family;\n\nstatic struct push_cas_option cas;\n\nstatic const char **refspec;\nstatic int refspec_nr;\nstatic int refspec_alloc;\n\nstatic void add_refspec(const char *ref)\n{\n\trefspec_nr++;\n\tALLOC_GROW(refspec, refspec_nr, refspec_alloc);\n\trefspec[refspec_nr-1] = ref;\n}\n\nstatic const char *map_refspec(const char *ref,\n\t\t\t       struct remote *remote, struct ref *local_refs)\n{\n\tstruct ref *matched = NULL;\n\n\t/* Does \"ref\" uniquely name our ref? */\n\tif (count_refspec_match(ref, local_refs, &matched) != 1)\n\t\treturn ref;\n\n\tif (remote->push) {\n\t\tstruct refspec query;\n\t\tmemset(&query, 0, sizeof(struct refspec));\n\t\tquery.src = matched->name;\n\t\tif (!query_refspecs(remote->push, remote->push_refspec_nr, &query) &&\n\t\t    query.dst) {\n\t\t\tstruct strbuf buf = STRBUF_INIT;\n\t\t\tstrbuf_addf(&buf, \"%s%s:%s\",\n\t\t\t\t    query.force ? \"+\" : \"\",\n\t\t\t\t    query.src, query.dst);\n\t\t\treturn strbuf_detach(&buf, NULL);\n\t\t}\n\t}\n\n\tif (push_default == PUSH_DEFAULT_UPSTREAM &&\n\t    starts_with(matched->name, \"refs/heads/\")) {\n\t\tstruct branch *branch = branch_get(matched->name + 11);\n\t\tif (branch->merge_nr == 1 && branch->merge[0]->src) {\n\t\t\tstruct strbuf buf = STRBUF_INIT;\n\t\t\tstrbuf_addf(&buf, \"%s:%s\",\n\t\t\t\t    ref, branch->merge[0]->src);\n\t\t\treturn strbuf_detach(&buf, NULL);\n\t\t}\n\t}\n\n\treturn ref;\n}\n\nstatic void set_refspecs(const char **refs, int nr, const char *repo)\n{\n\tstruct remote *remote = NULL;\n\tstruct ref *local_refs = NULL;\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tconst char *ref = refs[i];\n\t\tif (!strcmp(\"tag\", ref)) {\n\t\t\tstruct strbuf tagref = STRBUF_INIT;\n\t\t\tif (nr <= ++i)\n\t\t\t\tdie(_(\"tag shorthand without <tag>\"));\n\t\t\tref = refs[i];\n\t\t\tif (deleterefs)\n\t\t\t\tstrbuf_addf(&tagref, \":refs/tags/%s\", ref);\n\t\t\telse\n\t\t\t\tstrbuf_addf(&tagref, \"refs/tags/%s\", ref);\n\t\t\tref = strbuf_detach(&tagref, NULL);\n\t\t} else if (deleterefs) {\n\t\t\tstruct strbuf delref = STRBUF_INIT;\n\t\t\tif (strchr(ref, ':'))\n\t\t\t\tdie(_(\"--delete only accepts plain target ref names\"));\n\t\t\tstrbuf_addf(&delref, \":%s\", ref);\n\t\t\tref = strbuf_detach(&delref, NULL);\n\t\t} else if (!strchr(ref, ':')) {\n\t\t\tif (!remote) {\n\t\t\t\t/* lazily grab remote and local_refs */\n\t\t\t\tremote = remote_get(repo);\n\t\t\t\tlocal_refs = get_local_heads();\n\t\t\t}\n\t\t\tref = map_refspec(ref, remote, local_refs);\n\t\t}\n\t\tadd_refspec(ref);\n\t}\n}\n\nstatic int push_url_of_remote(struct remote *remote, const char ***url_p)\n{\n\tif (remote->pushurl_nr) {\n\t\t*url_p = remote->pushurl;\n\t\treturn remote->pushurl_nr;\n\t}\n\t*url_p = remote->url;\n\treturn remote->url_nr;\n}\n\nstatic NORETURN int die_push_simple(struct branch *branch, struct remote *remote) {\n\t/*\n\t * There's no point in using shorten_unambiguous_ref here,\n\t * as the ambiguity would be on the remote side, not what\n\t * we have locally. Plus, this is supposed to be the simple\n\t * mode. If the user is doing something crazy like setting\n\t * upstream to a non-branch, we should probably be showing\n\t * them the big ugly fully qualified ref.\n\t */\n\tconst char *advice_maybe = \"\";\n\tconst char *short_upstream = branch->merge[0]->src;\n\n\tskip_prefix(short_upstream, \"refs/heads/\", &short_upstream);\n\n\t/*\n\t * Don't show advice for people who explicitly set\n\t * push.default.\n\t */\n\tif (push_default == PUSH_DEFAULT_UNSPECIFIED)\n\t\tadvice_maybe = _(\"\\n\"\n\t\t\t\t \"To choose either option permanently, \"\n\t\t\t\t \"see push.default in 'git help config'.\");\n\tdie(_(\"The upstream branch of your current branch does not match\\n\"\n\t      \"the name of your current branch.  To push to the upstream branch\\n\"\n\t      \"on the remote, use\\n\"\n\t      \"\\n\"\n\t      \"    git push %s HEAD:%s\\n\"\n\t      \"\\n\"\n\t      \"To push to the branch of the same name on the remote, use\\n\"\n\t      \"\\n\"\n\t      \"    git push %s %s\\n\"\n\t      \"%s\"),\n\t    remote->name, short_upstream,\n\t    remote->name, branch->name, advice_maybe);\n}\n\nstatic const char message_detached_head_die[] =\n\tN_(\"You are not currently on a branch.\\n\"\n\t   \"To push the history leading to the current (detached HEAD)\\n\"\n\t   \"state now, use\\n\"\n\t   \"\\n\"\n\t   \"    git push %s HEAD:<name-of-remote-branch>\\n\");\n\nstatic void setup_push_upstream(struct remote *remote, struct branch *branch,\n\t\t\t\tint triangular, int simple)\n{\n\tstruct strbuf refspec = STRBUF_INIT;\n\n\tif (!branch)\n\t\tdie(_(message_detached_head_die), remote->name);\n\tif (!branch->merge_nr || !branch->merge || !branch->remote_name)\n\t\tdie(_(\"The current branch %s has no upstream branch.\\n\"\n\t\t    \"To push the current branch and set the remote as upstream, use\\n\"\n\t\t    \"\\n\"\n\t\t    \"    git push --set-upstream %s %s\\n\"),\n\t\t    branch->name,\n\t\t    remote->name,\n\t\t    branch->name);\n\tif (branch->merge_nr != 1)\n\t\tdie(_(\"The current branch %s has multiple upstream branches, \"\n\t\t    \"refusing to push.\"), branch->name);\n\tif (triangular)\n\t\tdie(_(\"You are pushing to remote '%s', which is not the upstream of\\n\"\n\t\t      \"your current branch '%s', without telling me what to push\\n\"\n\t\t      \"to update which remote branch.\"),\n\t\t    remote->name, branch->name);\n\n\tif (simple) {\n\t\t/* Additional safety */\n\t\tif (strcmp(branch->refname, branch->merge[0]->src))\n\t\t\tdie_push_simple(branch, remote);\n\t}\n\n\tstrbuf_addf(&refspec, \"%s:%s\", branch->refname, branch->merge[0]->src);\n\tadd_refspec(refspec.buf);\n}\n\nstatic void setup_push_current(struct remote *remote, struct branch *branch)\n{\n\tstruct strbuf refspec = STRBUF_INIT;\n\n\tif (!branch)\n\t\tdie(_(message_detached_head_die), remote->name);\n\tstrbuf_addf(&refspec, \"%s:%s\", branch->refname, branch->refname);\n\tadd_refspec(refspec.buf);\n}\n\nstatic int is_workflow_triangular(struct remote *remote)\n{\n\tstruct remote *fetch_remote = remote_get(NULL);\n\treturn (fetch_remote && fetch_remote != remote);\n}\n\nstatic void setup_default_push_refspecs(struct remote *remote)\n{\n\tstruct branch *branch = branch_get(NULL);\n\tint triangular = is_workflow_triangular(remote);\n\n\tswitch (push_default) {\n\tdefault:\n\tcase PUSH_DEFAULT_MATCHING:\n\t\tadd_refspec(\":\");\n\t\tbreak;\n\n\tcase PUSH_DEFAULT_UNSPECIFIED:\n\tcase PUSH_DEFAULT_SIMPLE:\n\t\tif (triangular)\n\t\t\tsetup_push_current(remote, branch);\n\t\telse\n\t\t\tsetup_push_upstream(remote, branch, triangular, 1);\n\t\tbreak;\n\n\tcase PUSH_DEFAULT_UPSTREAM:\n\t\tsetup_push_upstream(remote, branch, triangular, 0);\n\t\tbreak;\n\n\tcase PUSH_DEFAULT_CURRENT:\n\t\tsetup_push_current(remote, branch);\n\t\tbreak;\n\n\tcase PUSH_DEFAULT_NOTHING:\n\t\tdie(_(\"You didn't specify any refspecs to push, and \"\n\t\t    \"push.default is \\\"nothing\\\".\"));\n\t\tbreak;\n\t}\n}\n\nstatic const char message_advice_pull_before_push[] =\n\tN_(\"Updates were rejected because the tip of your current branch is behind\\n\"\n\t   \"its remote counterpart. Integrate the remote changes (e.g.\\n\"\n\t   \"'git pull ...') before pushing again.\\n\"\n\t   \"See the 'Note about fast-forwards' in 'git push --help' for details.\");\n\nstatic const char message_advice_checkout_pull_push[] =\n\tN_(\"Updates were rejected because a pushed branch tip is behind its remote\\n\"\n\t   \"counterpart. Check out this branch and integrate the remote changes\\n\"\n\t   \"(e.g. 'git pull ...') before pushing again.\\n\"\n\t   \"See the 'Note about fast-forwards' in 'git push --help' for details.\");\n\nstatic const char message_advice_ref_fetch_first[] =\n\tN_(\"Updates were rejected because the remote contains work that you do\\n\"\n\t   \"not have locally. This is usually caused by another repository pushing\\n\"\n\t   \"to the same ref. You may want to first integrate the remote changes\\n\"\n\t   \"(e.g., 'git pull ...') before pushing again.\\n\"\n\t   \"See the 'Note about fast-forwards' in 'git push --help' for details.\");\n\nstatic const char message_advice_ref_already_exists[] =\n\tN_(\"Updates were rejected because the tag already exists in the remote.\");\n\nstatic const char message_advice_ref_needs_force[] =\n\tN_(\"You cannot update a remote ref that points at a non-commit object,\\n\"\n\t   \"or update a remote ref to make it point at a non-commit object,\\n\"\n\t   \"without using the '--force' option.\\n\");\n\nstatic void advise_pull_before_push(void)\n{\n\tif (!advice_push_non_ff_current || !advice_push_update_rejected)\n\t\treturn;\n\tadvise(_(message_advice_pull_before_push));\n}\n\nstatic void advise_checkout_pull_push(void)\n{\n\tif (!advice_push_non_ff_matching || !advice_push_update_rejected)\n\t\treturn;\n\tadvise(_(message_advice_checkout_pull_push));\n}\n\nstatic void advise_ref_already_exists(void)\n{\n\tif (!advice_push_already_exists || !advice_push_update_rejected)\n\t\treturn;\n\tadvise(_(message_advice_ref_already_exists));\n}\n\nstatic void advise_ref_fetch_first(void)\n{\n\tif (!advice_push_fetch_first || !advice_push_update_rejected)\n\t\treturn;\n\tadvise(_(message_advice_ref_fetch_first));\n}\n\nstatic void advise_ref_needs_force(void)\n{\n\tif (!advice_push_needs_force || !advice_push_update_rejected)\n\t\treturn;\n\tadvise(_(message_advice_ref_needs_force));\n}\n\nstatic int push_with_options(struct transport *transport, int flags)\n{\n\tint err;\n\tunsigned int reject_reasons;\n\n\ttransport_set_verbosity(transport, verbosity, progress);\n\ttransport->family = family;\n\n\tif (receivepack)\n\t\ttransport_set_option(transport,\n\t\t\t\t     TRANS_OPT_RECEIVEPACK, receivepack);\n\ttransport_set_option(transport, TRANS_OPT_THIN, thin ? \"yes\" : NULL);\n\n\tif (!is_empty_cas(&cas)) {\n\t\tif (!transport->smart_options)\n\t\t\tdie(\"underlying transport does not support --%s option\",\n\t\t\t    CAS_OPT_NAME);\n\t\ttransport->smart_options->cas = &cas;\n\t}\n\n\tif (verbosity > 0)\n\t\tfprintf(stderr, _(\"Pushing to %s\\n\"), transport->url);\n\terr = transport_push(transport, refspec_nr, refspec, flags,\n\t\t\t     &reject_reasons);\n\tif (err != 0)\n\t\terror(_(\"failed to push some refs to '%s'\"), transport->url);\n\n\terr |= transport_disconnect(transport);\n\tif (!err)\n\t\treturn 0;\n\n\tif (reject_reasons & REJECT_NON_FF_HEAD) {\n\t\tadvise_pull_before_push();\n\t} else if (reject_reasons & REJECT_NON_FF_OTHER) {\n\t\tadvise_checkout_pull_push();\n\t} else if (reject_reasons & REJECT_ALREADY_EXISTS) {\n\t\tadvise_ref_already_exists();\n\t} else if (reject_reasons & REJECT_FETCH_FIRST) {\n\t\tadvise_ref_fetch_first();\n\t} else if (reject_reasons & REJECT_NEEDS_FORCE) {\n\t\tadvise_ref_needs_force();\n\t}\n\n\treturn 1;\n}\n\nstatic int do_push(const char *repo, int flags)\n{\n\tint i, errs;\n\tstruct remote *remote = pushremote_get(repo);\n\tconst char **url;\n\tint url_nr;\n\n\tif (!remote) {\n\t\tif (repo)\n\t\t\tdie(_(\"bad repository '%s'\"), repo);\n\t\tdie(_(\"No configured push destination.\\n\"\n\t\t    \"Either specify the URL from the command-line or configure a remote repository using\\n\"\n\t\t    \"\\n\"\n\t\t    \"    git remote add <name> <url>\\n\"\n\t\t    \"\\n\"\n\t\t    \"and then push using the remote name\\n\"\n\t\t    \"\\n\"\n\t\t    \"    git push <name>\\n\"));\n\t}\n\n\tif (remote->mirror)\n\t\tflags |= (TRANSPORT_PUSH_MIRROR|TRANSPORT_PUSH_FORCE);\n\n\tif ((flags & TRANSPORT_PUSH_ALL) && refspec) {\n\t\tif (!strcmp(*refspec, \"refs/tags/*\"))\n\t\t\treturn error(_(\"--all and --tags are incompatible\"));\n\t\treturn error(_(\"--all can't be combined with refspecs\"));\n\t}\n\n\tif ((flags & TRANSPORT_PUSH_MIRROR) && refspec) {\n\t\tif (!strcmp(*refspec, \"refs/tags/*\"))\n\t\t\treturn error(_(\"--mirror and --tags are incompatible\"));\n\t\treturn error(_(\"--mirror can't be combined with refspecs\"));\n\t}\n\n\tif ((flags & (TRANSPORT_PUSH_ALL|TRANSPORT_PUSH_MIRROR)) ==\n\t\t\t\t(TRANSPORT_PUSH_ALL|TRANSPORT_PUSH_MIRROR)) {\n\t\treturn error(_(\"--all and --mirror are incompatible\"));\n\t}\n\n\tif (!refspec && !(flags & TRANSPORT_PUSH_ALL)) {\n\t\tif (remote->push_refspec_nr) {\n\t\t\trefspec = remote->push_refspec;\n\t\t\trefspec_nr = remote->push_refspec_nr;\n\t\t} else if (!(flags & TRANSPORT_PUSH_MIRROR))\n\t\t\tsetup_default_push_refspecs(remote);\n\t}\n\terrs = 0;\n\turl_nr = push_url_of_remote(remote, &url);\n\tif (url_nr) {\n\t\tfor (i = 0; i < url_nr; i++) {\n\t\t\tstruct transport *transport =\n\t\t\t\ttransport_get(remote, url[i]);\n\t\t\tif (push_with_options(transport, flags))\n\t\t\t\terrs++;\n\t\t}\n\t} else {\n\t\tstruct transport *transport =\n\t\t\ttransport_get(remote, NULL);\n\n\t\tif (push_with_options(transport, flags))\n\t\t\terrs++;\n\t}\n\treturn !!errs;\n}\n\nstatic int option_parse_recurse_submodules(const struct option *opt,\n\t\t\t\t   const char *arg, int unset)\n{\n\tint *recurse_submodules = opt->value;\n\n\tif (unset)\n\t\t*recurse_submodules = RECURSE_SUBMODULES_OFF;\n\telse if (arg)\n\t\t*recurse_submodules = parse_push_recurse_submodules_arg(opt->long_name, arg);\n\telse\n\t\tdie(\"%s missing parameter\", opt->long_name);\n\n\treturn 0;\n}\n\nstatic void set_push_cert_flags(int *flags, int v)\n{\n\tswitch (v) {\n\tcase SEND_PACK_PUSH_CERT_NEVER:\n\t\t*flags &= ~(TRANSPORT_PUSH_CERT_ALWAYS | TRANSPORT_PUSH_CERT_IF_ASKED);\n\t\tbreak;\n\tcase SEND_PACK_PUSH_CERT_ALWAYS:\n\t\t*flags |= TRANSPORT_PUSH_CERT_ALWAYS;\n\t\t*flags &= ~TRANSPORT_PUSH_CERT_IF_ASKED;\n\t\tbreak;\n\tcase SEND_PACK_PUSH_CERT_IF_ASKED:\n\t\t*flags |= TRANSPORT_PUSH_CERT_IF_ASKED;\n\t\t*flags &= ~TRANSPORT_PUSH_CERT_ALWAYS;\n\t\tbreak;\n\t}\n}\n\n\nstatic int git_push_config(const char *k, const char *v, void *cb)\n{\n\tint *flags = cb;\n\tint status;\n\n\tstatus = git_gpg_config(k, v, NULL);\n\tif (status)\n\t\treturn status;\n\n\tif (!strcmp(k, \"push.followtags\")) {\n\t\tif (git_config_bool(k, v))\n\t\t\t*flags |= TRANSPORT_PUSH_FOLLOW_TAGS;\n\t\telse\n\t\t\t*flags &= ~TRANSPORT_PUSH_FOLLOW_TAGS;\n\t\treturn 0;\n\t} else if (!strcmp(k, \"push.gpgsign\")) {\n\t\tconst char *value;\n\t\tif (!git_config_get_value(\"push.gpgsign\", &value)) {\n\t\t\tswitch (git_config_maybe_bool(\"push.gpgsign\", value)) {\n\t\t\tcase 0:\n\t\t\t\tset_push_cert_flags(flags, SEND_PACK_PUSH_CERT_NEVER);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tset_push_cert_flags(flags, SEND_PACK_PUSH_CERT_ALWAYS);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (value && !strcasecmp(value, \"if-asked\"))\n\t\t\t\t\tset_push_cert_flags(flags, SEND_PACK_PUSH_CERT_IF_ASKED);\n\t\t\t\telse\n\t\t\t\t\treturn error(\"Invalid value for '%s'\", k);\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(k, \"push.recursesubmodules\")) {\n\t\tconst char *value;\n\t\tif (!git_config_get_value(\"push.recursesubmodules\", &value))\n\t\t\trecurse_submodules = parse_push_recurse_submodules_arg(k, value);\n\t}\n\n\treturn git_default_config(k, v, NULL);\n}\n\nint cmd_push(int argc, const char **argv, const char *prefix)\n{\n\tint flags = 0;\n\tint tags = 0;\n\tint push_cert = -1;\n\tint rc;\n\tconst char *repo = NULL;\t/* default repository */\n\tstruct option options[] = {\n\t\tOPT__VERBOSITY(&verbosity),\n\t\tOPT_STRING( 0 , \"repo\", &repo, N_(\"repository\"), N_(\"repository\")),\n\t\tOPT_BIT( 0 , \"all\", &flags, N_(\"push all refs\"), TRANSPORT_PUSH_ALL),\n\t\tOPT_BIT( 0 , \"mirror\", &flags, N_(\"mirror all refs\"),\n\t\t\t    (TRANSPORT_PUSH_MIRROR|TRANSPORT_PUSH_FORCE)),\n\t\tOPT_BOOL('d', \"delete\", &deleterefs, N_(\"delete refs\")),\n\t\tOPT_BOOL( 0 , \"tags\", &tags, N_(\"push tags (can't be used with --all or --mirror)\")),\n\t\tOPT_BIT('n' , \"dry-run\", &flags, N_(\"dry run\"), TRANSPORT_PUSH_DRY_RUN),\n\t\tOPT_BIT( 0,  \"porcelain\", &flags, N_(\"machine-readable output\"), TRANSPORT_PUSH_PORCELAIN),\n\t\tOPT_BIT('f', \"force\", &flags, N_(\"force updates\"), TRANSPORT_PUSH_FORCE),\n\t\t{ OPTION_CALLBACK,\n\t\t  0, CAS_OPT_NAME, &cas, N_(\"refname>:<expect\"),\n\t\t  N_(\"require old value of ref to be at this value\"),\n\t\t  PARSE_OPT_OPTARG, parseopt_push_cas_option },\n\t\t{ OPTION_CALLBACK, 0, \"recurse-submodules\", &recurse_submodules, \"check|on-demand|no\",\n\t\t\tN_(\"control recursive pushing of submodules\"),\n\t\t\tPARSE_OPT_OPTARG, option_parse_recurse_submodules },\n\t\tOPT_BOOL( 0 , \"thin\", &thin, N_(\"use thin pack\")),\n\t\tOPT_STRING( 0 , \"receive-pack\", &receivepack, \"receive-pack\", N_(\"receive pack program\")),\n\t\tOPT_STRING( 0 , \"exec\", &receivepack, \"receive-pack\", N_(\"receive pack program\")),\n\t\tOPT_BIT('u', \"set-upstream\", &flags, N_(\"set upstream for git pull/status\"),\n\t\t\tTRANSPORT_PUSH_SET_UPSTREAM),\n\t\tOPT_BOOL(0, \"progress\", &progress, N_(\"force progress reporting\")),\n\t\tOPT_BIT(0, \"prune\", &flags, N_(\"prune locally removed refs\"),\n\t\t\tTRANSPORT_PUSH_PRUNE),\n\t\tOPT_BIT(0, \"no-verify\", &flags, N_(\"bypass pre-push hook\"), TRANSPORT_PUSH_NO_HOOK),\n\t\tOPT_BIT(0, \"follow-tags\", &flags, N_(\"push missing but relevant tags\"),\n\t\t\tTRANSPORT_PUSH_FOLLOW_TAGS),\n\t\t{ OPTION_CALLBACK,\n\t\t  0, \"signed\", &push_cert, \"yes|no|if-asked\", N_(\"GPG sign the push\"),\n\t\t  PARSE_OPT_OPTARG, option_parse_push_signed },\n\t\tOPT_BIT(0, \"atomic\", &flags, N_(\"request atomic transaction on remote side\"), TRANSPORT_PUSH_ATOMIC),\n\t\tOPT_SET_INT('4', \"ipv4\", &family, N_(\"use IPv4 addresses only\"),\n\t\t\t\tTRANSPORT_FAMILY_IPV4),\n\t\tOPT_SET_INT('6', \"ipv6\", &family, N_(\"use IPv6 addresses only\"),\n\t\t\t\tTRANSPORT_FAMILY_IPV6),\n\t\tOPT_END()\n\t};\n\n\tpacket_trace_identity(\"push\");\n\tgit_config(git_push_config, &flags);\n\targc = parse_options(argc, argv, prefix, options, push_usage, 0);\n\tset_push_cert_flags(&flags, push_cert);\n\n\tif (deleterefs && (tags || (flags & (TRANSPORT_PUSH_ALL | TRANSPORT_PUSH_MIRROR))))\n\t\tdie(_(\"--delete is incompatible with --all, --mirror and --tags\"));\n\tif (deleterefs && argc < 2)\n\t\tdie(_(\"--delete doesn't make sense without any refs\"));\n\n\tif (recurse_submodules == RECURSE_SUBMODULES_CHECK)\n\t\tflags |= TRANSPORT_RECURSE_SUBMODULES_CHECK;\n\telse if (recurse_submodules == RECURSE_SUBMODULES_ON_DEMAND)\n\t\tflags |= TRANSPORT_RECURSE_SUBMODULES_ON_DEMAND;\n\n\tif (tags)\n\t\tadd_refspec(\"refs/tags/*\");\n\n\tif (argc > 0) {\n\t\trepo = argv[0];\n\t\tset_refspecs(argv + 1, argc - 1, repo);\n\t}\n\n\trc = do_push(repo, flags);\n\tif (rc == -1)\n\t\tusage_with_options(push_usage, options);\n\telse\n\t\treturn rc;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00a1b684830c0201361b9ec84d874aaa40b2a9e0",
  "sha1_ok": true,
  "size": 17501
}
