{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGRpZmYiCiAqCiAqIENvcHlyaWdodCAoYykgMjAwNiBKdW5pbyBDIEhhbWFubwogKi8KI2RlZmluZSBVU0VfVEhFX0lOREVYX1ZBUklBQkxFCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImV3YWgvZXdvay5oIgojaW5jbHVkZSAibG9ja2ZpbGUuaCIKI2luY2x1ZGUgImNvbG9yLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgImJsb2IuaCIKI2luY2x1ZGUgImdldHRleHQuaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAiZGlmZi1tZXJnZXMuaCIKI2luY2x1ZGUgImRpZmZjb3JlLmgiCiNpbmNsdWRlICJwcmVsb2FkLWluZGV4LmgiCiNpbmNsdWRlICJyZWFkLWNhY2hlLWxsLmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAibG9nLXRyZWUuaCIKI2luY2x1ZGUgInNldHVwLmgiCiNpbmNsdWRlICJzdWJtb2R1bGUuaCIKI2luY2x1ZGUgIm9pZC1hcnJheS5oIgojaW5jbHVkZSAidHJlZS5oIgoKI2RlZmluZSBESUZGX05PX0lOREVYX0VYUExJQ0lUIDEKI2RlZmluZSBESUZGX05PX0lOREVYX0lNUExJQ0lUIDIKCnN0YXRpYyBjb25zdCBjaGFyIGJ1aWx0aW5fZGlmZl91c2FnZVtdID0KImdpdCBkaWZmIFs8b3B0aW9ucz5dIFs8Y29tbWl0Pl0gWy0tXSBbPHBhdGg+Li4uXVxuIgoiICAgb3I6IGdpdCBkaWZmIFs8b3B0aW9ucz5dIC0tY2FjaGVkIFstLW1lcmdlLWJhc2VdIFs8Y29tbWl0Pl0gWy0tXSBbPHBhdGg+Li4uXVxuIgoiICAgb3I6IGdpdCBkaWZmIFs8b3B0aW9ucz5dIFstLW1lcmdlLWJhc2VdIDxjb21taXQ+IFs8Y29tbWl0Pi4uLl0gPGNvbW1pdD4gWy0tXSBbPHBhdGg+Li4uXVxuIgoiICAgb3I6IGdpdCBkaWZmIFs8b3B0aW9ucz5dIDxjb21taXQ+Li4uPGNvbW1pdD4gWy0tXSBbPHBhdGg+Li4uXVxuIgoiICAgb3I6IGdpdCBkaWZmIFs8b3B0aW9ucz5dIDxibG9iPiA8YmxvYj5cbiIKIiAgIG9yOiBnaXQgZGlmZiBbPG9wdGlvbnM+XSAtLW5vLWluZGV4IFstLV0gPHBhdGg+IDxwYXRoPiIKIlxuIgpDT01NT05fRElGRl9PUFRJT05TX0hFTFA7CgpzdGF0aWMgY29uc3QgY2hhciAqYmxvYl9wYXRoKHN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKmVudHJ5KQp7CglyZXR1cm4gZW50cnktPnBhdGggPyBlbnRyeS0+cGF0aCA6IGVudHJ5LT5uYW1lOwp9CgpzdGF0aWMgdm9pZCBzdHVmZl9jaGFuZ2Uoc3RydWN0IGRpZmZfb3B0aW9ucyAqb3B0LAoJCQkgdW5zaWduZWQgb2xkX21vZGUsIHVuc2lnbmVkIG5ld19tb2RlLAoJCQkgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2xkX29pZCwKCQkJIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm5ld19vaWQsCgkJCSBpbnQgb2xkX29pZF92YWxpZCwKCQkJIGludCBuZXdfb2lkX3ZhbGlkLAoJCQkgY29uc3QgY2hhciAqb2xkX3BhdGgsCgkJCSBjb25zdCBjaGFyICpuZXdfcGF0aCkKewoJc3RydWN0IGRpZmZfZmlsZXNwZWMgKm9uZSwgKnR3bzsKCglpZiAoIWlzX251bGxfb2lkKG9sZF9vaWQpICYmICFpc19udWxsX29pZChuZXdfb2lkKSAmJgoJICAgIG9pZGVxKG9sZF9vaWQsIG5ld19vaWQpICYmIChvbGRfbW9kZSA9PSBuZXdfbW9kZSkpCgkJcmV0dXJuOwoKCWlmIChvcHQtPmZsYWdzLnJldmVyc2VfZGlmZikgewoJCVNXQVAob2xkX21vZGUsIG5ld19tb2RlKTsKCQlTV0FQKG9sZF9vaWQsIG5ld19vaWQpOwoJCVNXQVAob2xkX3BhdGgsIG5ld19wYXRoKTsKCX0KCglpZiAob3B0LT5wcmVmaXggJiYKCSAgICAoc3RybmNtcChvbGRfcGF0aCwgb3B0LT5wcmVmaXgsIG9wdC0+cHJlZml4X2xlbmd0aCkgfHwKCSAgICAgc3RybmNtcChuZXdfcGF0aCwgb3B0LT5wcmVmaXgsIG9wdC0+cHJlZml4X2xlbmd0aCkpKQoJCXJldHVybjsKCglvbmUgPSBhbGxvY19maWxlc3BlYyhvbGRfcGF0aCk7Cgl0d28gPSBhbGxvY19maWxlc3BlYyhuZXdfcGF0aCk7CglmaWxsX2ZpbGVzcGVjKG9uZSwgb2xkX29pZCwgb2xkX29pZF92YWxpZCwgb2xkX21vZGUpOwoJZmlsbF9maWxlc3BlYyh0d28sIG5ld19vaWQsIG5ld19vaWRfdmFsaWQsIG5ld19tb2RlKTsKCglkaWZmX3F1ZXVlKCZkaWZmX3F1ZXVlZF9kaWZmLCBvbmUsIHR3byk7Cn0KCnN0YXRpYyBpbnQgYnVpbHRpbl9kaWZmX2JfZihzdHJ1Y3QgcmV2X2luZm8gKnJldnMsCgkJCSAgICBpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YgVU5VU0VELAoJCQkgICAgc3RydWN0IG9iamVjdF9hcnJheV9lbnRyeSAqKmJsb2IpCnsKCS8qIEJsb2IgdnMgZmlsZSBpbiB0aGUgd29ya2luZyB0cmVlKi8KCXN0cnVjdCBzdGF0IHN0OwoJY29uc3QgY2hhciAqcGF0aDsKCglpZiAoYXJnYyA+IDEpCgkJdXNhZ2UoYnVpbHRpbl9kaWZmX3VzYWdlKTsKCglHVUFSRF9QQVRIU1BFQygmcmV2cy0+cHJ1bmVfZGF0YSwgUEFUSFNQRUNfRlJPTVRPUCB8IFBBVEhTUEVDX0xJVEVSQUwpOwoJcGF0aCA9IHJldnMtPnBydW5lX2RhdGEuaXRlbXNbMF0ubWF0Y2g7CgoJaWYgKGxzdGF0KHBhdGgsICZzdCkpCgkJZGllX2Vycm5vKF8oImZhaWxlZCB0byBzdGF0ICclcyciKSwgcGF0aCk7CglpZiAoIShTX0lTUkVHKHN0LnN0X21vZGUpIHx8IFNfSVNMTksoc3Quc3RfbW9kZSkpKQoJCWRpZShfKCInJXMnOiBub3QgYSByZWd1bGFyIGZpbGUgb3Igc3ltbGluayIpLCBwYXRoKTsKCglkaWZmX3NldF9tbmVtb25pY19wcmVmaXgoJnJldnMtPmRpZmZvcHQsICJvLyIsICJ3LyIpOwoKCWlmIChibG9iWzBdLT5tb2RlID09IFNfSUZJTlZBTElEKQoJCWJsb2JbMF0tPm1vZGUgPSBjYW5vbl9tb2RlKHN0LnN0X21vZGUpOwoKCXN0dWZmX2NoYW5nZSgmcmV2cy0+ZGlmZm9wdCwKCQkgICAgIGJsb2JbMF0tPm1vZGUsIGNhbm9uX21vZGUoc3Quc3RfbW9kZSksCgkJICAgICAmYmxvYlswXS0+aXRlbS0+b2lkLCBudWxsX29pZCgpLAoJCSAgICAgMSwgMCwKCQkgICAgIGJsb2JbMF0tPnBhdGggPyBibG9iWzBdLT5wYXRoIDogcGF0aCwKCQkgICAgIHBhdGgpOwoJZGlmZmNvcmVfc3RkKCZyZXZzLT5kaWZmb3B0KTsKCWRpZmZfZmx1c2goJnJldnMtPmRpZmZvcHQpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgYnVpbHRpbl9kaWZmX2Jsb2JzKHN0cnVjdCByZXZfaW5mbyAqcmV2cywKCQkJICAgICAgaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2IFVOVVNFRCwKCQkJICAgICAgc3RydWN0IG9iamVjdF9hcnJheV9lbnRyeSAqKmJsb2IpCnsKCWNvbnN0IHVuc2lnbmVkIG1vZGUgPSBjYW5vbl9tb2RlKFNfSUZSRUcgfCAwNjQ0KTsKCglpZiAoYXJnYyA+IDEpCgkJdXNhZ2UoYnVpbHRpbl9kaWZmX3VzYWdlKTsKCglpZiAoYmxvYlswXS0+bW9kZSA9PSBTX0lGSU5WQUxJRCkKCQlibG9iWzBdLT5tb2RlID0gbW9kZTsKCglpZiAoYmxvYlsxXS0+bW9kZSA9PSBTX0lGSU5WQUxJRCkKCQlibG9iWzFdLT5tb2RlID0gbW9kZTsKCglzdHVmZl9jaGFuZ2UoJnJldnMtPmRpZmZvcHQsCgkJICAgICBibG9iWzBdLT5tb2RlLCBibG9iWzFdLT5tb2RlLAoJCSAgICAgJmJsb2JbMF0tPml0ZW0tPm9pZCwgJmJsb2JbMV0tPml0ZW0tPm9pZCwKCQkgICAgIDEsIDEsCgkJICAgICBibG9iX3BhdGgoYmxvYlswXSksIGJsb2JfcGF0aChibG9iWzFdKSk7CglkaWZmY29yZV9zdGQoJnJldnMtPmRpZmZvcHQpOwoJZGlmZl9mbHVzaCgmcmV2cy0+ZGlmZm9wdCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBidWlsdGluX2RpZmZfaW5kZXgoc3RydWN0IHJldl9pbmZvICpyZXZzLAoJCQkgICAgICBpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YpCnsKCXVuc2lnbmVkIGludCBvcHRpb24gPSAwOwoJd2hpbGUgKDEgPCBhcmdjKSB7CgkJY29uc3QgY2hhciAqYXJnID0gYXJndlsxXTsKCQlpZiAoIXN0cmNtcChhcmcsICItLWNhY2hlZCIpIHx8ICFzdHJjbXAoYXJnLCAiLS1zdGFnZWQiKSkKCQkJb3B0aW9uIHw9IERJRkZfSU5ERVhfQ0FDSEVEOwoJCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS1tZXJnZS1iYXNlIikpCgkJCW9wdGlvbiB8PSBESUZGX0lOREVYX01FUkdFX0JBU0U7CgkJZWxzZQoJCQl1c2FnZShidWlsdGluX2RpZmZfdXNhZ2UpOwoJCWFyZ3YrKzsgYXJnYy0tOwoJfQoJLyoKCSAqIE1ha2Ugc3VyZSB0aGVyZSBpcyBvbmUgcmV2aXNpb24gKGkuZS4gcGVuZGluZyBvYmplY3QpLAoJICogYW5kIHRoZXJlIGlzIG5vIHJldmlzaW9uIGZpbHRlcmluZyBwYXJhbWV0ZXJzLgoJICovCglpZiAocmV2cy0+cGVuZGluZy5uciAhPSAxIHx8CgkgICAgcmV2cy0+bWF4X2NvdW50ICE9IC0xIHx8IHJldnMtPm1pbl9hZ2UgIT0gLTEgfHwKCSAgICByZXZzLT5tYXhfYWdlICE9IC0xKQoJCXVzYWdlKGJ1aWx0aW5fZGlmZl91c2FnZSk7CglpZiAoIShvcHRpb24gJiBESUZGX0lOREVYX0NBQ0hFRCkpIHsKCQlzZXR1cF93b3JrX3RyZWUoKTsKCQlpZiAocmVwb19yZWFkX2luZGV4X3ByZWxvYWQodGhlX3JlcG9zaXRvcnksCgkJCQkJICAgICZyZXZzLT5kaWZmb3B0LnBhdGhzcGVjLCAwKSA8IDApIHsKCQkJZGllX2Vycm5vKCJyZXBvX3JlYWRfaW5kZXhfcHJlbG9hZCIpOwoJCX0KCX0gZWxzZSBpZiAocmVwb19yZWFkX2luZGV4KHRoZV9yZXBvc2l0b3J5KSA8IDApIHsKCQlkaWVfZXJybm8oInJlcG9fcmVhZF9jYWNoZSIpOwoJfQoJcmV0dXJuIHJ1bl9kaWZmX2luZGV4KHJldnMsIG9wdGlvbik7Cn0KCnN0YXRpYyBpbnQgYnVpbHRpbl9kaWZmX3RyZWUoc3RydWN0IHJldl9pbmZvICpyZXZzLAoJCQkgICAgIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwKCQkJICAgICBzdHJ1Y3Qgb2JqZWN0X2FycmF5X2VudHJ5ICplbnQwLAoJCQkgICAgIHN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKmVudDEpCnsKCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKihvaWRbMl0pOwoJc3RydWN0IG9iamVjdF9pZCBtYl9vaWQ7CglpbnQgbWVyZ2VfYmFzZSA9IDA7CgoJd2hpbGUgKDEgPCBhcmdjKSB7CgkJY29uc3QgY2hhciAqYXJnID0gYXJndlsxXTsKCQlpZiAoIXN0cmNtcChhcmcsICItLW1lcmdlLWJhc2UiKSkKCQkJbWVyZ2VfYmFzZSA9IDE7CgkJZWxzZQoJCQl1c2FnZShidWlsdGluX2RpZmZfdXNhZ2UpOwoJCWFyZ3YrKzsgYXJnYy0tOwoJfQoKCWlmIChtZXJnZV9iYXNlKSB7CgkJZGlmZl9nZXRfbWVyZ2VfYmFzZShyZXZzLCAmbWJfb2lkKTsKCQlvaWRbMF0gPSAmbWJfb2lkOwoJCW9pZFsxXSA9ICZyZXZzLT5wZW5kaW5nLm9iamVjdHNbMV0uaXRlbS0+b2lkOwoJfSBlbHNlIHsKCQlpbnQgc3dhcCA9IDA7CgoJCS8qCgkJICogV2Ugc2F3IHR3byB0cmVlcywgZW50MCBhbmQgZW50MS4gIElmIGVudDEgaXMgdW5pbnRlcmVzdGluZywKCQkgKiBzd2FwIHRoZW0uCgkJICovCgkJaWYgKGVudDEtPml0ZW0tPmZsYWdzICYgVU5JTlRFUkVTVElORykKCQkJc3dhcCA9IDE7CgkJb2lkW3N3YXBdID0gJmVudDAtPml0ZW0tPm9pZDsKCQlvaWRbMSAtIHN3YXBdID0gJmVudDEtPml0ZW0tPm9pZDsKCX0KCWRpZmZfdHJlZV9vaWQob2lkWzBdLCBvaWRbMV0sICIiLCAmcmV2cy0+ZGlmZm9wdCk7Cglsb2dfdHJlZV9kaWZmX2ZsdXNoKHJldnMpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgYnVpbHRpbl9kaWZmX2NvbWJpbmVkKHN0cnVjdCByZXZfaW5mbyAqcmV2cywKCQkJCSBpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YgVU5VU0VELAoJCQkJIHN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKmVudCwKCQkJCSBpbnQgZW50cywgaW50IGZpcnN0X25vbl9wYXJlbnQpCnsKCXN0cnVjdCBvaWRfYXJyYXkgcGFyZW50cyA9IE9JRF9BUlJBWV9JTklUOwoJaW50IGk7CgoJaWYgKGFyZ2MgPiAxKQoJCXVzYWdlKGJ1aWx0aW5fZGlmZl91c2FnZSk7CgoJaWYgKGZpcnN0X25vbl9wYXJlbnQgPCAwKQoJCWRpZShfKCJubyBtZXJnZSBnaXZlbiwgb25seSBwYXJlbnRzLiIpKTsKCWlmIChmaXJzdF9ub25fcGFyZW50ID49IGVudHMpCgkJQlVHKCJmaXJzdF9ub25fcGFyZW50IG91dCBvZiByYW5nZTogJWQiLCBmaXJzdF9ub25fcGFyZW50KTsKCglkaWZmX21lcmdlc19zZXRfZGVuc2VfY29tYmluZWRfaWZfdW5zZXQocmV2cyk7CgoJZm9yIChpID0gMDsgaSA8IGVudHM7IGkrKykgewoJCWlmIChpICE9IGZpcnN0X25vbl9wYXJlbnQpCgkJCW9pZF9hcnJheV9hcHBlbmQoJnBhcmVudHMsICZlbnRbaV0uaXRlbS0+b2lkKTsKCX0KCWRpZmZfdHJlZV9jb21iaW5lZCgmZW50W2ZpcnN0X25vbl9wYXJlbnRdLml0ZW0tPm9pZCwgJnBhcmVudHMsIHJldnMpOwoJb2lkX2FycmF5X2NsZWFyKCZwYXJlbnRzKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCByZWZyZXNoX2luZGV4X3F1aWV0bHkodm9pZCkKewoJc3RydWN0IGxvY2tfZmlsZSBsb2NrX2ZpbGUgPSBMT0NLX0lOSVQ7CglpbnQgZmQ7CgoJZmQgPSByZXBvX2hvbGRfbG9ja2VkX2luZGV4KHRoZV9yZXBvc2l0b3J5LCAmbG9ja19maWxlLCAwKTsKCWlmIChmZCA8IDApCgkJcmV0dXJuOwoJZGlzY2FyZF9pbmRleCgmdGhlX2luZGV4KTsKCXJlcG9fcmVhZF9pbmRleCh0aGVfcmVwb3NpdG9yeSk7CglyZWZyZXNoX2luZGV4KCZ0aGVfaW5kZXgsIFJFRlJFU0hfUVVJRVR8UkVGUkVTSF9VTk1FUkdFRCwgTlVMTCwgTlVMTCwKCQkgICAgICBOVUxMKTsKCXJlcG9fdXBkYXRlX2luZGV4X2lmX2FibGUodGhlX3JlcG9zaXRvcnksICZsb2NrX2ZpbGUpOwp9CgpzdGF0aWMgaW50IGJ1aWx0aW5fZGlmZl9maWxlcyhzdHJ1Y3QgcmV2X2luZm8gKnJldnMsIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndikKewoJdW5zaWduZWQgaW50IG9wdGlvbnMgPSAwOwoKCXdoaWxlICgxIDwgYXJnYyAmJiBhcmd2WzFdWzBdID09ICctJykgewoJCWlmICghc3RyY21wKGFyZ3ZbMV0sICItLWJhc2UiKSkKCQkJcmV2cy0+bWF4X2NvdW50ID0gMTsKCQllbHNlIGlmICghc3RyY21wKGFyZ3ZbMV0sICItLW91cnMiKSkKCQkJcmV2cy0+bWF4X2NvdW50ID0gMjsKCQllbHNlIGlmICghc3RyY21wKGFyZ3ZbMV0sICItLXRoZWlycyIpKQoJCQlyZXZzLT5tYXhfY291bnQgPSAzOwoJCWVsc2UgaWYgKCFzdHJjbXAoYXJndlsxXSwgIi1xIikpCgkJCW9wdGlvbnMgfD0gRElGRl9TSUxFTlRfT05fUkVNT1ZFRDsKCQllbHNlIGlmICghc3RyY21wKGFyZ3ZbMV0sICItaCIpKQoJCQl1c2FnZShidWlsdGluX2RpZmZfdXNhZ2UpOwoJCWVsc2UgewoJCQllcnJvcihfKCJpbnZhbGlkIG9wdGlvbjogJXMiKSwgYXJndlsxXSk7CgkJCXVzYWdlKGJ1aWx0aW5fZGlmZl91c2FnZSk7CgkJfQoJCWFyZ3YrKzsgYXJnYy0tOwoJfQoKCS8qCgkgKiAiZGlmZiAtLWJhc2UiIHNob3VsZCBub3QgY29tYmluZSBtZXJnZXMgYmVjYXVzZSBpdCB3YXMgbm90CgkgKiBhc2tlZCB0by4gICJkaWZmIC1jIiBzaG91bGQgbm90IGRlbnNpZnkgKGlmIHRoZSB1c2VyIHdhbnRzCgkgKiBkZW5zZSBvbmUsIC0tY2MgY2FuIGJlIGV4cGxpY2l0bHkgYXNrZWQgZm9yLCBvciBqdXN0IHJlbHkKCSAqIG9uIHRoZSBkZWZhdWx0KS4KCSAqLwoJaWYgKHJldnMtPm1heF9jb3VudCA9PSAtMSAmJgoJICAgIChyZXZzLT5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgJiBESUZGX0ZPUk1BVF9QQVRDSCkpCgkJZGlmZl9tZXJnZXNfc2V0X2RlbnNlX2NvbWJpbmVkX2lmX3Vuc2V0KHJldnMpOwoKCXNldHVwX3dvcmtfdHJlZSgpOwoJaWYgKHJlcG9fcmVhZF9pbmRleF9wcmVsb2FkKHRoZV9yZXBvc2l0b3J5LCAmcmV2cy0+ZGlmZm9wdC5wYXRoc3BlYywKCQkJCSAgICAwKSA8IDApIHsKCQlkaWVfZXJybm8oInJlcG9fcmVhZF9pbmRleF9wcmVsb2FkIik7Cgl9CglyZXR1cm4gcnVuX2RpZmZfZmlsZXMocmV2cywgb3B0aW9ucyk7Cn0KCnN0cnVjdCBzeW1kaWZmIHsKCXN0cnVjdCBiaXRtYXAgKnNraXA7CglpbnQgd2FybjsKCWNvbnN0IGNoYXIgKmJhc2UsICpsZWZ0LCAqcmlnaHQ7Cn07CgovKgogKiBDaGVjayBmb3Igc3ltbWV0cmljLWRpZmZlcmVuY2UgYXJndW1lbnRzLCBhbmQgaWYgcHJlc2VudCwgYXJyYW5nZQogKiBldmVyeXRoaW5nIHdlIG5lZWQgdG8ga25vdyB0byBoYW5kbGUgdGhlbSBjb3JyZWN0bHkuICBBcyBhIGJvbnVzLAogKiB3ZWVkIG91dCBhbGwgYm9ndXMgcmFuZ2UtYmFzZWQgcmV2aXNpb24gc3BlY2lmaWNhdGlvbnMsIGUuZy4sCiAqICJnaXQgZGlmZiBBLi5CIEMuLkQiIG9yICJnaXQgZGlmZiBBLi5CIEMiIGdldCByZWplY3RlZC4KICoKICogRm9yIGFuIGFjdHVhbCBzeW1tZXRyaWMgZGlmZiwgKnN5bWRpZmYgaXMgc2V0IHRoaXMgd2F5OgogKgogKiAgLSBpdHMgc2tpcCBpcyBub24tTlVMTCBhbmQgbWFya3MgKmFsbCogcmV2LT5wZW5kaW5nLm9iamVjdHNbaV0KICogICAgaW5kaWNlcyB0aGF0IHRoZSBjYWxsZXIgc2hvdWxkIGlnbm9yZSAoZXh0cmEgbWVyZ2UgYmFzZXMsIG9mCiAqICAgIHdoaWNoIHRoZXJlIG1pZ2h0IGJlIG1hbnksIGFuZCBBIGluIEEuLi5CKS4gIE5vdGUgdGhhdCB0aGUKICogICAgY2hvc2VuIG1lcmdlIGJhc2UgYW5kIHJpZ2h0IHNpZGUgYXJlIE5PVCBtYXJrZWQuCiAqICAtIHdhcm4gaXMgc2V0IGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtZXJnZSBiYXNlcy4KICogIC0gYmFzZSwgbGVmdCwgYW5kIHJpZ2h0IHBvaW50IHRvIHRoZSBuYW1lcyB0byB1c2UgaW4gYQogKiAgICB3YXJuaW5nIGFib3V0IG11bHRpcGxlIG1lcmdlIGJhc2VzLgogKgogKiBJZiB0aGVyZSBpcyBubyBzeW1tZXRyaWMgZGlmZiBhcmd1bWVudCwgc3ltLT5za2lwIGlzIE5VTEwgYW5kCiAqIHN5bS0+d2FybiBpcyBjbGVhcmVkLiAgVGhlIHJlbWFpbmluZyBmaWVsZHMgYXJlIG5vdCBzZXQuCiAqLwpzdGF0aWMgdm9pZCBzeW1kaWZmX3ByZXBhcmUoc3RydWN0IHJldl9pbmZvICpyZXYsIHN0cnVjdCBzeW1kaWZmICpzeW0pCnsKCWludCBpLCBpc19zeW1kaWZmID0gMCwgYmFzZWNvdW50ID0gMCwgb3RoZXJjb3VudCA9IDA7CglpbnQgbHBvcyA9IC0xLCBycG9zID0gLTEsIGJhc2Vwb3MgPSAtMTsKCXN0cnVjdCBiaXRtYXAgKm1hcCA9IE5VTEw7CgoJLyoKCSAqIFVzZSB0aGUgd2hlbmNlIGZpZWxkcyB0byBmaW5kIG1lcmdlIGJhc2VzIGFuZCBsZWZ0IGFuZAoJICogcmlnaHQgcGFydHMgb2Ygc3ltbWV0cmljIGRpZmZlcmVuY2UsIHNvIHRoYXQgd2UgZG8gbm90CgkgKiBkZXBlbmQgb24gdGhlIG9yZGVyIHRoYXQgcmV2aXNpb25zIGFyZSBwYXJzZWQuICBJZiB0aGVyZQoJICogYXJlIGFueSByZXZzIHRoYXQgYXJlbid0IGZyb20gdGhlc2Ugc291cmNlcywgd2UgaGF2ZSBhCgkgKiAiZ2l0IGRpZmYgQyBBLi4uQiIgb3IgImdpdCBkaWZmIEEuLi5CIEMiIGNhc2UuICBPciB3ZQoJICogY291bGQgZXZlbiBnZXQgImdpdCBkaWZmIEEuLi5CIEMuLi5FIiwgZm9yIGluc3RhbmNlLgoJICoKCSAqIElmIHdlIGRvbid0IGhhdmUganVzdCBvbmUgbWVyZ2UgYmFzZSwgd2UgcGljayBvbmUKCSAqIGF0IHJhbmRvbS4KCSAqCgkgKiBOQjogUkVWX0NNRF9MRUZULCBSRVZfQ01EX1JJR0hUIGFyZSBhbHNvIHVzZWQgZm9yIEEuLkIsCgkgKiBzbyB3ZSBtdXN0IGNoZWNrIGZvciBTWU1NRVRSSUNfTEVGVCB0b28uICBUaGUgdHdvIGFycmF5cwoJICogcmV2LT5wZW5kaW5nLm9iamVjdHMgYW5kIHJldi0+Y21kbGluZS5yZXYgYXJlIHBhcmFsbGVsLgoJICovCglmb3IgKGkgPSAwOyBpIDwgcmV2LT5jbWRsaW5lLm5yOyBpKyspIHsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmogPSByZXYtPnBlbmRpbmcub2JqZWN0c1tpXS5pdGVtOwoJCXN3aXRjaCAocmV2LT5jbWRsaW5lLnJldltpXS53aGVuY2UpIHsKCQljYXNlIFJFVl9DTURfTUVSR0VfQkFTRToKCQkJaWYgKGJhc2Vwb3MgPCAwKQoJCQkJYmFzZXBvcyA9IGk7CgkJCWJhc2Vjb3VudCsrOwoJCQlicmVhazsJCS8qIGRvIG1hcmsgYWxsIGJhc2VzICovCgkJY2FzZSBSRVZfQ01EX0xFRlQ6CgkJCWlmIChscG9zID49IDApCgkJCQl1c2FnZShidWlsdGluX2RpZmZfdXNhZ2UpOwoJCQlscG9zID0gaTsKCQkJaWYgKG9iai0+ZmxhZ3MgJiBTWU1NRVRSSUNfTEVGVCkgewoJCQkJaXNfc3ltZGlmZiA9IDE7CgkJCQlicmVhazsJLyogZG8gbWFyayBBICovCgkJCX0KCQkJY29udGludWU7CgkJY2FzZSBSRVZfQ01EX1JJR0hUOgoJCQlpZiAocnBvcyA+PSAwKQoJCQkJdXNhZ2UoYnVpbHRpbl9kaWZmX3VzYWdlKTsKCQkJcnBvcyA9IGk7CgkJCWNvbnRpbnVlOwkvKiBkb24ndCBtYXJrIEIgKi8KCQljYXNlIFJFVl9DTURfUEFSRU5UU19PTkxZOgoJCWNhc2UgUkVWX0NNRF9SRUY6CgkJY2FzZSBSRVZfQ01EX1JFVjoKCQkJb3RoZXJjb3VudCsrOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKCFtYXApCgkJCW1hcCA9IGJpdG1hcF9uZXcoKTsKCQliaXRtYXBfc2V0KG1hcCwgaSk7Cgl9CgoJLyoKCSAqIEZvcmJpZCBhbnkgYWRkaXRpb25hbCByZXZzIGZvciBib3RoIEEuLi5CIGFuZCBBLi5CLgoJICovCglpZiAobHBvcyA+PSAwICYmIG90aGVyY291bnQgPiAwKQoJCXVzYWdlKGJ1aWx0aW5fZGlmZl91c2FnZSk7CgoJaWYgKCFpc19zeW1kaWZmKSB7CgkJYml0bWFwX2ZyZWUobWFwKTsKCQlzeW0tPndhcm4gPSAwOwoJCXN5bS0+c2tpcCA9IE5VTEw7CgkJcmV0dXJuOwoJfQoKCXN5bS0+bGVmdCA9IHJldi0+cGVuZGluZy5vYmplY3RzW2xwb3NdLm5hbWU7CglzeW0tPnJpZ2h0ID0gcmV2LT5wZW5kaW5nLm9iamVjdHNbcnBvc10ubmFtZTsKCWlmIChiYXNlY291bnQgPT0gMCkKCQlkaWUoXygiJXMuLi4lczogbm8gbWVyZ2UgYmFzZSIpLCBzeW0tPmxlZnQsIHN5bS0+cmlnaHQpOwoJc3ltLT5iYXNlID0gcmV2LT5wZW5kaW5nLm9iamVjdHNbYmFzZXBvc10ubmFtZTsKCWJpdG1hcF91bnNldChtYXAsIGJhc2Vwb3MpOwkvKiB1bm1hcmsgdGhlIGJhc2Ugd2Ugd2FudCAqLwoJc3ltLT53YXJuID0gYmFzZWNvdW50ID4gMTsKCXN5bS0+c2tpcCA9IG1hcDsKfQoKaW50IGNtZF9kaWZmKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglpbnQgaTsKCXN0cnVjdCByZXZfaW5mbyByZXY7CglzdHJ1Y3Qgb2JqZWN0X2FycmF5IGVudCA9IE9CSkVDVF9BUlJBWV9JTklUOwoJaW50IGZpcnN0X25vbl9wYXJlbnQgPSAtMTsKCWludCBibG9icyA9IDAsIHBhdGhzID0gMDsKCXN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKmJsb2JbMl07CglpbnQgbm9uZ2l0ID0gMCwgbm9faW5kZXggPSAwOwoJaW50IHJlc3VsdCA9IDA7CglzdHJ1Y3Qgc3ltZGlmZiBzZGlmZjsKCgkvKgoJICogV2UgY291bGQgZ2V0IE4gdHJlZS1pc2ggaW4gdGhlIHJldi5wZW5kaW5nX29iamVjdHMgbGlzdC4KCSAqIEFsc28gdGhlcmUgY291bGQgYmUgTSBibG9icyB0aGVyZSwgYW5kIFAgcGF0aHNwZWNzLiAtLWNhY2hlZCBtYXkKCSAqIGFsc28gYmUgcHJlc2VudC4KCSAqCgkgKiBOPTAsIE09MDoKCSAqICAgICAgY2FjaGUgdnMgZmlsZXMgKGRpZmYtZmlsZXMpCgkgKgoJICogTj0wLCBNPTAsIC0tY2FjaGVkOgoJICogICAgICBIRUFEIHZzIGNhY2hlIChkaWZmLWluZGV4IC0tY2FjaGVkKQoJICoKCSAqIE49MCwgTT0yOgoJICogICAgICBjb21wYXJlIHR3byByYW5kb20gYmxvYnMuICBQIG11c3QgYmUgemVyby4KCSAqCgkgKiBOPTAsIE09MSwgUD0xOgoJICogICAgICBjb21wYXJlIGEgYmxvYiB3aXRoIGEgd29ya2luZyB0cmVlIGZpbGUuCgkgKgoJICogTj0xLCBNPTA6CgkgKiAgICAgIHRyZWUgdnMgZmlsZXMgKGRpZmYtaW5kZXgpCgkgKgoJICogTj0xLCBNPTAsIC0tY2FjaGVkOgoJICogICAgICB0cmVlIHZzIGNhY2hlIChkaWZmLWluZGV4IC0tY2FjaGVkKQoJICoKCSAqIE49MiwgTT0wOgoJICogICAgICB0cmVlIHZzIHRyZWUgKGRpZmYtdHJlZSkKCSAqCgkgKiBOPTAsIE09MCwgUD0yOgoJICogICAgICBjb21wYXJlIHR3byBmaWxlc3lzdGVtIGVudGl0aWVzIChha2EgLS1uby1pbmRleCkuCgkgKgoJICogT3RoZXIgY2FzZXMgYXJlIGVycm9ycy4KCSAqLwoKCS8qIFdlcmUgd2UgYXNrZWQgdG8gZG8gLS1uby1pbmRleCBleHBsaWNpdGx5PyAqLwoJZm9yIChpID0gMTsgaSA8IGFyZ2M7IGkrKykgewoJCWlmICghc3RyY21wKGFyZ3ZbaV0sICItLSIpKSB7CgkJCWkrKzsKCQkJYnJlYWs7CgkJfQoJCWlmICghc3RyY21wKGFyZ3ZbaV0sICItLW5vLWluZGV4IikpCgkJCW5vX2luZGV4ID0gRElGRl9OT19JTkRFWF9FWFBMSUNJVDsKCQlpZiAoYXJndltpXVswXSAhPSAnLScpCgkJCWJyZWFrOwoJfQoKCXByZWZpeCA9IHNldHVwX2dpdF9kaXJlY3RvcnlfZ2VudGx5KCZub25naXQpOwoKCWlmICghbm9uZ2l0KSB7CgkJcHJlcGFyZV9yZXBvX3NldHRpbmdzKHRoZV9yZXBvc2l0b3J5KTsKCQl0aGVfcmVwb3NpdG9yeS0+c2V0dGluZ3MuY29tbWFuZF9yZXF1aXJlc19mdWxsX2luZGV4ID0gMDsKCX0KCglpZiAoIW5vX2luZGV4KSB7CgkJLyoKCQkgKiBUcmVhdCBnaXQgZGlmZiB3aXRoIGF0IGxlYXN0IG9uZSBwYXRoIG91dHNpZGUgb2YgdGhlCgkJICogcmVwbyB0aGUgc2FtZSBhcyBpZiB0aGUgY29tbWFuZCB3b3VsZCBoYXZlIGJlZW4gZXhlY3V0ZWQKCQkgKiBvdXRzaWRlIG9mIGEgZ2l0IHJlcG9zaXRvcnkuICBJbiB0aGlzIGNhc2UgaXQgYmVoYXZlcwoJCSAqIHRoZSBzYW1lIHdheSBhcyAiZ2l0IGRpZmYgLS1uby1pbmRleCA8YT4gPGI+Iiwgd2hpY2ggYWN0cwoJCSAqIGFzIGEgY29sb3VyZnVsICJkaWZmIiByZXBsYWNlbWVudC4KCQkgKi8KCQlpZiAobm9uZ2l0IHx8ICgoYXJnYyA9PSBpICsgMikgJiYKCQkJICAgICAgICghcGF0aF9pbnNpZGVfcmVwbyhwcmVmaXgsIGFyZ3ZbaV0pIHx8CgkJCQkhcGF0aF9pbnNpZGVfcmVwbyhwcmVmaXgsIGFyZ3ZbaSArIDFdKSkpKQoJCQlub19pbmRleCA9IERJRkZfTk9fSU5ERVhfSU1QTElDSVQ7Cgl9CgoJaW5pdF9kaWZmX3VpX2RlZmF1bHRzKCk7CglnaXRfY29uZmlnKGdpdF9kaWZmX3VpX2NvbmZpZywgTlVMTCk7CglwcmVmaXggPSBwcmVjb21wb3NlX2FyZ3ZfcHJlZml4KGFyZ2MsIGFyZ3YsIHByZWZpeCk7CgoJcmVwb19pbml0X3JldmlzaW9ucyh0aGVfcmVwb3NpdG9yeSwgJnJldiwgcHJlZml4KTsKCgkvKiBTZXQgdXAgZGVmYXVsdHMgdGhhdCB3aWxsIGFwcGx5IHRvIGJvdGggbm8taW5kZXggYW5kIHJlZ3VsYXIgZGlmZnMuICovCglyZXYuZGlmZm9wdC5zdGF0X3dpZHRoID0gLTE7CglyZXYuZGlmZm9wdC5zdGF0X2dyYXBoX3dpZHRoID0gLTE7CglyZXYuZGlmZm9wdC5mbGFncy5hbGxvd19leHRlcm5hbCA9IDE7CglyZXYuZGlmZm9wdC5mbGFncy5hbGxvd190ZXh0Y29udiA9IDE7CgoJLyogSWYgdGhpcyBpcyBhIG5vLWluZGV4IGRpZmYsIGp1c3QgcnVuIGl0IGFuZCBleGl0IHRoZXJlLiAqLwoJaWYgKG5vX2luZGV4KQoJCWV4aXQoZGlmZl9ub19pbmRleCgmcmV2LCBub19pbmRleCA9PSBESUZGX05PX0lOREVYX0lNUExJQ0lULAoJCQkJICAgYXJnYywgYXJndikpOwoKCgkvKgoJICogT3RoZXJ3aXNlLCB3ZSBhcmUgZG9pbmcgdGhlIHVzdWFsICJnaXQiIGRpZmY7IHNldCB1cCBhbnkKCSAqIGZ1cnRoZXIgZGVmYXVsdHMgdGhhdCBhcHBseSB0byByZWd1bGFyIGRpZmZzLgoJICovCglyZXYuZGlmZm9wdC5za2lwX3N0YXRfdW5tYXRjaCA9ICEhZGlmZl9hdXRvX3JlZnJlc2hfaW5kZXg7CgoJLyoKCSAqIERlZmF1bHQgdG8gaW50ZW50LXRvLWFkZCBlbnRyaWVzIGludmlzaWJsZSBpbiB0aGUKCSAqIGluZGV4LiBUaGlzIG1ha2VzIHRoZW0gc2hvdyB1cCBhcyBuZXcgZmlsZXMgaW4gZGlmZi1maWxlcwoJICogYW5kIG5vdCBhdCBhbGwgaW4gZGlmZi1jYWNoZWQuCgkgKi8KCXJldi5kaWZmb3B0Lml0YV9pbnZpc2libGVfaW5faW5kZXggPSAxOwoKCWlmIChub25naXQpCgkJZGllKF8oIk5vdCBhIGdpdCByZXBvc2l0b3J5IikpOwoJYXJnYyA9IHNldHVwX3JldmlzaW9ucyhhcmdjLCBhcmd2LCAmcmV2LCBOVUxMKTsKCWlmICghcmV2LmRpZmZvcHQub3V0cHV0X2Zvcm1hdCkgewoJCXJldi5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9QQVRDSDsKCQlkaWZmX3NldHVwX2RvbmUoJnJldi5kaWZmb3B0KTsKCX0KCglyZXYuZGlmZm9wdC5mbGFncy5yZWN1cnNpdmUgPSAxOwoJcmV2LmRpZmZvcHQucm90YXRlX3RvX3N0cmljdCA9IDE7CgoJc2V0dXBfZGlmZl9wYWdlcigmcmV2LmRpZmZvcHQpOwoKCS8qCgkgKiBEbyB3ZSBoYXZlIC0tY2FjaGVkIGFuZCBub3QgaGF2ZSBhIHBlbmRpbmcgb2JqZWN0LCB0aGVuCgkgKiBkZWZhdWx0IHRvIEhFQUQgYnkgaGFuZC4gIEVlay4KCSAqLwoJaWYgKCFyZXYucGVuZGluZy5ucikgewoJCWludCBpOwoJCWZvciAoaSA9IDE7IGkgPCBhcmdjOyBpKyspIHsKCQkJY29uc3QgY2hhciAqYXJnID0gYXJndltpXTsKCQkJaWYgKCFzdHJjbXAoYXJnLCAiLS0iKSkKCQkJCWJyZWFrOwoJCQllbHNlIGlmICghc3RyY21wKGFyZywgIi0tY2FjaGVkIikgfHwKCQkJCSAhc3RyY21wKGFyZywgIi0tc3RhZ2VkIikpIHsKCQkJCWFkZF9oZWFkX3RvX3BlbmRpbmcoJnJldik7CgkJCQlpZiAoIXJldi5wZW5kaW5nLm5yKSB7CgkJCQkJc3RydWN0IHRyZWUgKnRyZWU7CgkJCQkJdHJlZSA9IGxvb2t1cF90cmVlKHRoZV9yZXBvc2l0b3J5LAoJCQkJCQkJICAgdGhlX3JlcG9zaXRvcnktPmhhc2hfYWxnby0+ZW1wdHlfdHJlZSk7CgkJCQkJYWRkX3BlbmRpbmdfb2JqZWN0KCZyZXYsICZ0cmVlLT5vYmplY3QsICJIRUFEIik7CgkJCQl9CgkJCQlicmVhazsKCQkJfQoJCX0KCX0KCglzeW1kaWZmX3ByZXBhcmUoJnJldiwgJnNkaWZmKTsKCWZvciAoaSA9IDA7IGkgPCByZXYucGVuZGluZy5ucjsgaSsrKSB7CgkJc3RydWN0IG9iamVjdF9hcnJheV9lbnRyeSAqZW50cnkgPSAmcmV2LnBlbmRpbmcub2JqZWN0c1tpXTsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmogPSBlbnRyeS0+aXRlbTsKCQljb25zdCBjaGFyICpuYW1lID0gZW50cnktPm5hbWU7CgkJaW50IGZsYWdzID0gKG9iai0+ZmxhZ3MgJiBVTklOVEVSRVNUSU5HKTsKCQlpZiAoIW9iai0+cGFyc2VkKQoJCQlvYmogPSBwYXJzZV9vYmplY3QodGhlX3JlcG9zaXRvcnksICZvYmotPm9pZCk7CgkJb2JqID0gZGVyZWZfdGFnKHRoZV9yZXBvc2l0b3J5LCBvYmosIE5VTEwsIDApOwoJCWlmICghb2JqKQoJCQlkaWUoXygiaW52YWxpZCBvYmplY3QgJyVzJyBnaXZlbi4iKSwgbmFtZSk7CgkJaWYgKG9iai0+dHlwZSA9PSBPQkpfQ09NTUlUKQoJCQlvYmogPSAmcmVwb19nZXRfY29tbWl0X3RyZWUodGhlX3JlcG9zaXRvcnksCgkJCQkJCSAgICAoKHN0cnVjdCBjb21taXQgKilvYmopKS0+b2JqZWN0OwoKCQlpZiAob2JqLT50eXBlID09IE9CSl9UUkVFKSB7CgkJCWlmIChzZGlmZi5za2lwICYmIGJpdG1hcF9nZXQoc2RpZmYuc2tpcCwgaSkpCgkJCQljb250aW51ZTsKCQkJb2JqLT5mbGFncyB8PSBmbGFnczsKCQkJYWRkX29iamVjdF9hcnJheShvYmosIG5hbWUsICZlbnQpOwoJCQlpZiAoZmlyc3Rfbm9uX3BhcmVudCA8IDAgJiYKCQkJICAgIChpID49IHJldi5jbWRsaW5lLm5yIHx8IC8qIEhFQUQgYnkgaGFuZC4gKi8KCQkJICAgICByZXYuY21kbGluZS5yZXZbaV0ud2hlbmNlICE9IFJFVl9DTURfUEFSRU5UU19PTkxZKSkKCQkJCWZpcnN0X25vbl9wYXJlbnQgPSBlbnQubnIgLSAxOwoJCX0gZWxzZSBpZiAob2JqLT50eXBlID09IE9CSl9CTE9CKSB7CgkJCWlmICgyIDw9IGJsb2JzKQoJCQkJZGllKF8oIm1vcmUgdGhhbiB0d28gYmxvYnMgZ2l2ZW46ICclcyciKSwgbmFtZSk7CgkJCWJsb2JbYmxvYnNdID0gZW50cnk7CgkJCWJsb2JzKys7CgoJCX0gZWxzZSB7CgkJCWRpZShfKCJ1bmhhbmRsZWQgb2JqZWN0ICclcycgZ2l2ZW4uIiksIG5hbWUpOwoJCX0KCX0KCWlmIChyZXYucHJ1bmVfZGF0YS5ucikKCQlwYXRocyArPSByZXYucHJ1bmVfZGF0YS5ucjsKCgkvKgoJICogTm93LCBkbyB0aGUgYXJndW1lbnRzIGxvb2sgcmVhc29uYWJsZT8KCSAqLwoJaWYgKCFlbnQubnIpIHsKCQlzd2l0Y2ggKGJsb2JzKSB7CgkJY2FzZSAwOgoJCQlyZXN1bHQgPSBidWlsdGluX2RpZmZfZmlsZXMoJnJldiwgYXJnYywgYXJndik7CgkJCWJyZWFrOwoJCWNhc2UgMToKCQkJaWYgKHBhdGhzICE9IDEpCgkJCQl1c2FnZShidWlsdGluX2RpZmZfdXNhZ2UpOwoJCQlyZXN1bHQgPSBidWlsdGluX2RpZmZfYl9mKCZyZXYsIGFyZ2MsIGFyZ3YsIGJsb2IpOwoJCQlicmVhazsKCQljYXNlIDI6CgkJCWlmIChwYXRocykKCQkJCXVzYWdlKGJ1aWx0aW5fZGlmZl91c2FnZSk7CgkJCXJlc3VsdCA9IGJ1aWx0aW5fZGlmZl9ibG9icygmcmV2LCBhcmdjLCBhcmd2LCBibG9iKTsKCQkJYnJlYWs7CgkJZGVmYXVsdDoKCQkJdXNhZ2UoYnVpbHRpbl9kaWZmX3VzYWdlKTsKCQl9Cgl9CgllbHNlIGlmIChibG9icykKCQl1c2FnZShidWlsdGluX2RpZmZfdXNhZ2UpOwoJZWxzZSBpZiAoZW50Lm5yID09IDEpCgkJcmVzdWx0ID0gYnVpbHRpbl9kaWZmX2luZGV4KCZyZXYsIGFyZ2MsIGFyZ3YpOwoJZWxzZSBpZiAoZW50Lm5yID09IDIpIHsKCQlpZiAoc2RpZmYud2FybikKCQkJd2FybmluZyhfKCIlcy4uLiVzOiBtdWx0aXBsZSBtZXJnZSBiYXNlcywgdXNpbmcgJXMiKSwKCQkJCXNkaWZmLmxlZnQsIHNkaWZmLnJpZ2h0LCBzZGlmZi5iYXNlKTsKCQlyZXN1bHQgPSBidWlsdGluX2RpZmZfdHJlZSgmcmV2LCBhcmdjLCBhcmd2LAoJCQkJCSAgICZlbnQub2JqZWN0c1swXSwgJmVudC5vYmplY3RzWzFdKTsKCX0gZWxzZQoJCXJlc3VsdCA9IGJ1aWx0aW5fZGlmZl9jb21iaW5lZCgmcmV2LCBhcmdjLCBhcmd2LAoJCQkJCSAgICAgICBlbnQub2JqZWN0cywgZW50Lm5yLAoJCQkJCSAgICAgICBmaXJzdF9ub25fcGFyZW50KTsKCXJlc3VsdCA9IGRpZmZfcmVzdWx0X2NvZGUoJnJldi5kaWZmb3B0LCByZXN1bHQpOwoJaWYgKDEgPCByZXYuZGlmZm9wdC5za2lwX3N0YXRfdW5tYXRjaCkKCQlyZWZyZXNoX2luZGV4X3F1aWV0bHkoKTsKCXJlbGVhc2VfcmV2aXNpb25zKCZyZXYpOwoJb2JqZWN0X2FycmF5X2NsZWFyKCZlbnQpOwoJVU5MRUFLKGJsb2IpOwoJcmV0dXJuIHJlc3VsdDsKfQo=",
    "text": "/*\n * Builtin \"git diff\"\n *\n * Copyright (c) 2006 Junio C Hamano\n */\n#define USE_THE_INDEX_VARIABLE\n#include \"builtin.h\"\n#include \"config.h\"\n#include \"ewah/ewok.h\"\n#include \"lockfile.h\"\n#include \"color.h\"\n#include \"commit.h\"\n#include \"blob.h\"\n#include \"gettext.h\"\n#include \"tag.h\"\n#include \"diff.h\"\n#include \"diff-merges.h\"\n#include \"diffcore.h\"\n#include \"preload-index.h\"\n#include \"read-cache-ll.h\"\n#include \"revision.h\"\n#include \"log-tree.h\"\n#include \"setup.h\"\n#include \"submodule.h\"\n#include \"oid-array.h\"\n#include \"tree.h\"\n\n#define DIFF_NO_INDEX_EXPLICIT 1\n#define DIFF_NO_INDEX_IMPLICIT 2\n\nstatic const char builtin_diff_usage[] =\n\"git diff [<options>] [<commit>] [--] [<path>...]\\n\"\n\"   or: git diff [<options>] --cached [--merge-base] [<commit>] [--] [<path>...]\\n\"\n\"   or: git diff [<options>] [--merge-base] <commit> [<commit>...] <commit> [--] [<path>...]\\n\"\n\"   or: git diff [<options>] <commit>...<commit> [--] [<path>...]\\n\"\n\"   or: git diff [<options>] <blob> <blob>\\n\"\n\"   or: git diff [<options>] --no-index [--] <path> <path>\"\n\"\\n\"\nCOMMON_DIFF_OPTIONS_HELP;\n\nstatic const char *blob_path(struct object_array_entry *entry)\n{\n\treturn entry->path ? entry->path : entry->name;\n}\n\nstatic void stuff_change(struct diff_options *opt,\n\t\t\t unsigned old_mode, unsigned new_mode,\n\t\t\t const struct object_id *old_oid,\n\t\t\t const struct object_id *new_oid,\n\t\t\t int old_oid_valid,\n\t\t\t int new_oid_valid,\n\t\t\t const char *old_path,\n\t\t\t const char *new_path)\n{\n\tstruct diff_filespec *one, *two;\n\n\tif (!is_null_oid(old_oid) && !is_null_oid(new_oid) &&\n\t    oideq(old_oid, new_oid) && (old_mode == new_mode))\n\t\treturn;\n\n\tif (opt->flags.reverse_diff) {\n\t\tSWAP(old_mode, new_mode);\n\t\tSWAP(old_oid, new_oid);\n\t\tSWAP(old_path, new_path);\n\t}\n\n\tif (opt->prefix &&\n\t    (strncmp(old_path, opt->prefix, opt->prefix_length) ||\n\t     strncmp(new_path, opt->prefix, opt->prefix_length)))\n\t\treturn;\n\n\tone = alloc_filespec(old_path);\n\ttwo = alloc_filespec(new_path);\n\tfill_filespec(one, old_oid, old_oid_valid, old_mode);\n\tfill_filespec(two, new_oid, new_oid_valid, new_mode);\n\n\tdiff_queue(&diff_queued_diff, one, two);\n}\n\nstatic int builtin_diff_b_f(struct rev_info *revs,\n\t\t\t    int argc, const char **argv UNUSED,\n\t\t\t    struct object_array_entry **blob)\n{\n\t/* Blob vs file in the working tree*/\n\tstruct stat st;\n\tconst char *path;\n\n\tif (argc > 1)\n\t\tusage(builtin_diff_usage);\n\n\tGUARD_PATHSPEC(&revs->prune_data, PATHSPEC_FROMTOP | PATHSPEC_LITERAL);\n\tpath = revs->prune_data.items[0].match;\n\n\tif (lstat(path, &st))\n\t\tdie_errno(_(\"failed to stat '%s'\"), path);\n\tif (!(S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)))\n\t\tdie(_(\"'%s': not a regular file or symlink\"), path);\n\n\tdiff_set_mnemonic_prefix(&revs->diffopt, \"o/\", \"w/\");\n\n\tif (blob[0]->mode == S_IFINVALID)\n\t\tblob[0]->mode = canon_mode(st.st_mode);\n\n\tstuff_change(&revs->diffopt,\n\t\t     blob[0]->mode, canon_mode(st.st_mode),\n\t\t     &blob[0]->item->oid, null_oid(),\n\t\t     1, 0,\n\t\t     blob[0]->path ? blob[0]->path : path,\n\t\t     path);\n\tdiffcore_std(&revs->diffopt);\n\tdiff_flush(&revs->diffopt);\n\treturn 0;\n}\n\nstatic int builtin_diff_blobs(struct rev_info *revs,\n\t\t\t      int argc, const char **argv UNUSED,\n\t\t\t      struct object_array_entry **blob)\n{\n\tconst unsigned mode = canon_mode(S_IFREG | 0644);\n\n\tif (argc > 1)\n\t\tusage(builtin_diff_usage);\n\n\tif (blob[0]->mode == S_IFINVALID)\n\t\tblob[0]->mode = mode;\n\n\tif (blob[1]->mode == S_IFINVALID)\n\t\tblob[1]->mode = mode;\n\n\tstuff_change(&revs->diffopt,\n\t\t     blob[0]->mode, blob[1]->mode,\n\t\t     &blob[0]->item->oid, &blob[1]->item->oid,\n\t\t     1, 1,\n\t\t     blob_path(blob[0]), blob_path(blob[1]));\n\tdiffcore_std(&revs->diffopt);\n\tdiff_flush(&revs->diffopt);\n\treturn 0;\n}\n\nstatic int builtin_diff_index(struct rev_info *revs,\n\t\t\t      int argc, const char **argv)\n{\n\tunsigned int option = 0;\n\twhile (1 < argc) {\n\t\tconst char *arg = argv[1];\n\t\tif (!strcmp(arg, \"--cached\") || !strcmp(arg, \"--staged\"))\n\t\t\toption |= DIFF_INDEX_CACHED;\n\t\telse if (!strcmp(arg, \"--merge-base\"))\n\t\t\toption |= DIFF_INDEX_MERGE_BASE;\n\t\telse\n\t\t\tusage(builtin_diff_usage);\n\t\targv++; argc--;\n\t}\n\t/*\n\t * Make sure there is one revision (i.e. pending object),\n\t * and there is no revision filtering parameters.\n\t */\n\tif (revs->pending.nr != 1 ||\n\t    revs->max_count != -1 || revs->min_age != -1 ||\n\t    revs->max_age != -1)\n\t\tusage(builtin_diff_usage);\n\tif (!(option & DIFF_INDEX_CACHED)) {\n\t\tsetup_work_tree();\n\t\tif (repo_read_index_preload(the_repository,\n\t\t\t\t\t    &revs->diffopt.pathspec, 0) < 0) {\n\t\t\tdie_errno(\"repo_read_index_preload\");\n\t\t}\n\t} else if (repo_read_index(the_repository) < 0) {\n\t\tdie_errno(\"repo_read_cache\");\n\t}\n\treturn run_diff_index(revs, option);\n}\n\nstatic int builtin_diff_tree(struct rev_info *revs,\n\t\t\t     int argc, const char **argv,\n\t\t\t     struct object_array_entry *ent0,\n\t\t\t     struct object_array_entry *ent1)\n{\n\tconst struct object_id *(oid[2]);\n\tstruct object_id mb_oid;\n\tint merge_base = 0;\n\n\twhile (1 < argc) {\n\t\tconst char *arg = argv[1];\n\t\tif (!strcmp(arg, \"--merge-base\"))\n\t\t\tmerge_base = 1;\n\t\telse\n\t\t\tusage(builtin_diff_usage);\n\t\targv++; argc--;\n\t}\n\n\tif (merge_base) {\n\t\tdiff_get_merge_base(revs, &mb_oid);\n\t\toid[0] = &mb_oid;\n\t\toid[1] = &revs->pending.objects[1].item->oid;\n\t} else {\n\t\tint swap = 0;\n\n\t\t/*\n\t\t * We saw two trees, ent0 and ent1.  If ent1 is uninteresting,\n\t\t * swap them.\n\t\t */\n\t\tif (ent1->item->flags & UNINTERESTING)\n\t\t\tswap = 1;\n\t\toid[swap] = &ent0->item->oid;\n\t\toid[1 - swap] = &ent1->item->oid;\n\t}\n\tdiff_tree_oid(oid[0], oid[1], \"\", &revs->diffopt);\n\tlog_tree_diff_flush(revs);\n\treturn 0;\n}\n\nstatic int builtin_diff_combined(struct rev_info *revs,\n\t\t\t\t int argc, const char **argv UNUSED,\n\t\t\t\t struct object_array_entry *ent,\n\t\t\t\t int ents, int first_non_parent)\n{\n\tstruct oid_array parents = OID_ARRAY_INIT;\n\tint i;\n\n\tif (argc > 1)\n\t\tusage(builtin_diff_usage);\n\n\tif (first_non_parent < 0)\n\t\tdie(_(\"no merge given, only parents.\"));\n\tif (first_non_parent >= ents)\n\t\tBUG(\"first_non_parent out of range: %d\", first_non_parent);\n\n\tdiff_merges_set_dense_combined_if_unset(revs);\n\n\tfor (i = 0; i < ents; i++) {\n\t\tif (i != first_non_parent)\n\t\t\toid_array_append(&parents, &ent[i].item->oid);\n\t}\n\tdiff_tree_combined(&ent[first_non_parent].item->oid, &parents, revs);\n\toid_array_clear(&parents);\n\treturn 0;\n}\n\nstatic void refresh_index_quietly(void)\n{\n\tstruct lock_file lock_file = LOCK_INIT;\n\tint fd;\n\n\tfd = repo_hold_locked_index(the_repository, &lock_file, 0);\n\tif (fd < 0)\n\t\treturn;\n\tdiscard_index(&the_index);\n\trepo_read_index(the_repository);\n\trefresh_index(&the_index, REFRESH_QUIET|REFRESH_UNMERGED, NULL, NULL,\n\t\t      NULL);\n\trepo_update_index_if_able(the_repository, &lock_file);\n}\n\nstatic int builtin_diff_files(struct rev_info *revs, int argc, const char **argv)\n{\n\tunsigned int options = 0;\n\n\twhile (1 < argc && argv[1][0] == '-') {\n\t\tif (!strcmp(argv[1], \"--base\"))\n\t\t\trevs->max_count = 1;\n\t\telse if (!strcmp(argv[1], \"--ours\"))\n\t\t\trevs->max_count = 2;\n\t\telse if (!strcmp(argv[1], \"--theirs\"))\n\t\t\trevs->max_count = 3;\n\t\telse if (!strcmp(argv[1], \"-q\"))\n\t\t\toptions |= DIFF_SILENT_ON_REMOVED;\n\t\telse if (!strcmp(argv[1], \"-h\"))\n\t\t\tusage(builtin_diff_usage);\n\t\telse {\n\t\t\terror(_(\"invalid option: %s\"), argv[1]);\n\t\t\tusage(builtin_diff_usage);\n\t\t}\n\t\targv++; argc--;\n\t}\n\n\t/*\n\t * \"diff --base\" should not combine merges because it was not\n\t * asked to.  \"diff -c\" should not densify (if the user wants\n\t * dense one, --cc can be explicitly asked for, or just rely\n\t * on the default).\n\t */\n\tif (revs->max_count == -1 &&\n\t    (revs->diffopt.output_format & DIFF_FORMAT_PATCH))\n\t\tdiff_merges_set_dense_combined_if_unset(revs);\n\n\tsetup_work_tree();\n\tif (repo_read_index_preload(the_repository, &revs->diffopt.pathspec,\n\t\t\t\t    0) < 0) {\n\t\tdie_errno(\"repo_read_index_preload\");\n\t}\n\treturn run_diff_files(revs, options);\n}\n\nstruct symdiff {\n\tstruct bitmap *skip;\n\tint warn;\n\tconst char *base, *left, *right;\n};\n\n/*\n * Check for symmetric-difference arguments, and if present, arrange\n * everything we need to know to handle them correctly.  As a bonus,\n * weed out all bogus range-based revision specifications, e.g.,\n * \"git diff A..B C..D\" or \"git diff A..B C\" get rejected.\n *\n * For an actual symmetric diff, *symdiff is set this way:\n *\n *  - its skip is non-NULL and marks *all* rev->pending.objects[i]\n *    indices that the caller should ignore (extra merge bases, of\n *    which there might be many, and A in A...B).  Note that the\n *    chosen merge base and right side are NOT marked.\n *  - warn is set if there are multiple merge bases.\n *  - base, left, and right point to the names to use in a\n *    warning about multiple merge bases.\n *\n * If there is no symmetric diff argument, sym->skip is NULL and\n * sym->warn is cleared.  The remaining fields are not set.\n */\nstatic void symdiff_prepare(struct rev_info *rev, struct symdiff *sym)\n{\n\tint i, is_symdiff = 0, basecount = 0, othercount = 0;\n\tint lpos = -1, rpos = -1, basepos = -1;\n\tstruct bitmap *map = NULL;\n\n\t/*\n\t * Use the whence fields to find merge bases and left and\n\t * right parts of symmetric difference, so that we do not\n\t * depend on the order that revisions are parsed.  If there\n\t * are any revs that aren't from these sources, we have a\n\t * \"git diff C A...B\" or \"git diff A...B C\" case.  Or we\n\t * could even get \"git diff A...B C...E\", for instance.\n\t *\n\t * If we don't have just one merge base, we pick one\n\t * at random.\n\t *\n\t * NB: REV_CMD_LEFT, REV_CMD_RIGHT are also used for A..B,\n\t * so we must check for SYMMETRIC_LEFT too.  The two arrays\n\t * rev->pending.objects and rev->cmdline.rev are parallel.\n\t */\n\tfor (i = 0; i < rev->cmdline.nr; i++) {\n\t\tstruct object *obj = rev->pending.objects[i].item;\n\t\tswitch (rev->cmdline.rev[i].whence) {\n\t\tcase REV_CMD_MERGE_BASE:\n\t\t\tif (basepos < 0)\n\t\t\t\tbasepos = i;\n\t\t\tbasecount++;\n\t\t\tbreak;\t\t/* do mark all bases */\n\t\tcase REV_CMD_LEFT:\n\t\t\tif (lpos >= 0)\n\t\t\t\tusage(builtin_diff_usage);\n\t\t\tlpos = i;\n\t\t\tif (obj->flags & SYMMETRIC_LEFT) {\n\t\t\t\tis_symdiff = 1;\n\t\t\t\tbreak;\t/* do mark A */\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase REV_CMD_RIGHT:\n\t\t\tif (rpos >= 0)\n\t\t\t\tusage(builtin_diff_usage);\n\t\t\trpos = i;\n\t\t\tcontinue;\t/* don't mark B */\n\t\tcase REV_CMD_PARENTS_ONLY:\n\t\tcase REV_CMD_REF:\n\t\tcase REV_CMD_REV:\n\t\t\tothercount++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!map)\n\t\t\tmap = bitmap_new();\n\t\tbitmap_set(map, i);\n\t}\n\n\t/*\n\t * Forbid any additional revs for both A...B and A..B.\n\t */\n\tif (lpos >= 0 && othercount > 0)\n\t\tusage(builtin_diff_usage);\n\n\tif (!is_symdiff) {\n\t\tbitmap_free(map);\n\t\tsym->warn = 0;\n\t\tsym->skip = NULL;\n\t\treturn;\n\t}\n\n\tsym->left = rev->pending.objects[lpos].name;\n\tsym->right = rev->pending.objects[rpos].name;\n\tif (basecount == 0)\n\t\tdie(_(\"%s...%s: no merge base\"), sym->left, sym->right);\n\tsym->base = rev->pending.objects[basepos].name;\n\tbitmap_unset(map, basepos);\t/* unmark the base we want */\n\tsym->warn = basecount > 1;\n\tsym->skip = map;\n}\n\nint cmd_diff(int argc, const char **argv, const char *prefix)\n{\n\tint i;\n\tstruct rev_info rev;\n\tstruct object_array ent = OBJECT_ARRAY_INIT;\n\tint first_non_parent = -1;\n\tint blobs = 0, paths = 0;\n\tstruct object_array_entry *blob[2];\n\tint nongit = 0, no_index = 0;\n\tint result = 0;\n\tstruct symdiff sdiff;\n\n\t/*\n\t * We could get N tree-ish in the rev.pending_objects list.\n\t * Also there could be M blobs there, and P pathspecs. --cached may\n\t * also be present.\n\t *\n\t * N=0, M=0:\n\t *      cache vs files (diff-files)\n\t *\n\t * N=0, M=0, --cached:\n\t *      HEAD vs cache (diff-index --cached)\n\t *\n\t * N=0, M=2:\n\t *      compare two random blobs.  P must be zero.\n\t *\n\t * N=0, M=1, P=1:\n\t *      compare a blob with a working tree file.\n\t *\n\t * N=1, M=0:\n\t *      tree vs files (diff-index)\n\t *\n\t * N=1, M=0, --cached:\n\t *      tree vs cache (diff-index --cached)\n\t *\n\t * N=2, M=0:\n\t *      tree vs tree (diff-tree)\n\t *\n\t * N=0, M=0, P=2:\n\t *      compare two filesystem entities (aka --no-index).\n\t *\n\t * Other cases are errors.\n\t */\n\n\t/* Were we asked to do --no-index explicitly? */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"--\")) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\tif (!strcmp(argv[i], \"--no-index\"))\n\t\t\tno_index = DIFF_NO_INDEX_EXPLICIT;\n\t\tif (argv[i][0] != '-')\n\t\t\tbreak;\n\t}\n\n\tprefix = setup_git_directory_gently(&nongit);\n\n\tif (!nongit) {\n\t\tprepare_repo_settings(the_repository);\n\t\tthe_repository->settings.command_requires_full_index = 0;\n\t}\n\n\tif (!no_index) {\n\t\t/*\n\t\t * Treat git diff with at least one path outside of the\n\t\t * repo the same as if the command would have been executed\n\t\t * outside of a git repository.  In this case it behaves\n\t\t * the same way as \"git diff --no-index <a> <b>\", which acts\n\t\t * as a colourful \"diff\" replacement.\n\t\t */\n\t\tif (nongit || ((argc == i + 2) &&\n\t\t\t       (!path_inside_repo(prefix, argv[i]) ||\n\t\t\t\t!path_inside_repo(prefix, argv[i + 1]))))\n\t\t\tno_index = DIFF_NO_INDEX_IMPLICIT;\n\t}\n\n\tinit_diff_ui_defaults();\n\tgit_config(git_diff_ui_config, NULL);\n\tprefix = precompose_argv_prefix(argc, argv, prefix);\n\n\trepo_init_revisions(the_repository, &rev, prefix);\n\n\t/* Set up defaults that will apply to both no-index and regular diffs. */\n\trev.diffopt.stat_width = -1;\n\trev.diffopt.stat_graph_width = -1;\n\trev.diffopt.flags.allow_external = 1;\n\trev.diffopt.flags.allow_textconv = 1;\n\n\t/* If this is a no-index diff, just run it and exit there. */\n\tif (no_index)\n\t\texit(diff_no_index(&rev, no_index == DIFF_NO_INDEX_IMPLICIT,\n\t\t\t\t   argc, argv));\n\n\n\t/*\n\t * Otherwise, we are doing the usual \"git\" diff; set up any\n\t * further defaults that apply to regular diffs.\n\t */\n\trev.diffopt.skip_stat_unmatch = !!diff_auto_refresh_index;\n\n\t/*\n\t * Default to intent-to-add entries invisible in the\n\t * index. This makes them show up as new files in diff-files\n\t * and not at all in diff-cached.\n\t */\n\trev.diffopt.ita_invisible_in_index = 1;\n\n\tif (nongit)\n\t\tdie(_(\"Not a git repository\"));\n\targc = setup_revisions(argc, argv, &rev, NULL);\n\tif (!rev.diffopt.output_format) {\n\t\trev.diffopt.output_format = DIFF_FORMAT_PATCH;\n\t\tdiff_setup_done(&rev.diffopt);\n\t}\n\n\trev.diffopt.flags.recursive = 1;\n\trev.diffopt.rotate_to_strict = 1;\n\n\tsetup_diff_pager(&rev.diffopt);\n\n\t/*\n\t * Do we have --cached and not have a pending object, then\n\t * default to HEAD by hand.  Eek.\n\t */\n\tif (!rev.pending.nr) {\n\t\tint i;\n\t\tfor (i = 1; i < argc; i++) {\n\t\t\tconst char *arg = argv[i];\n\t\t\tif (!strcmp(arg, \"--\"))\n\t\t\t\tbreak;\n\t\t\telse if (!strcmp(arg, \"--cached\") ||\n\t\t\t\t !strcmp(arg, \"--staged\")) {\n\t\t\t\tadd_head_to_pending(&rev);\n\t\t\t\tif (!rev.pending.nr) {\n\t\t\t\t\tstruct tree *tree;\n\t\t\t\t\ttree = lookup_tree(the_repository,\n\t\t\t\t\t\t\t   the_repository->hash_algo->empty_tree);\n\t\t\t\t\tadd_pending_object(&rev, &tree->object, \"HEAD\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tsymdiff_prepare(&rev, &sdiff);\n\tfor (i = 0; i < rev.pending.nr; i++) {\n\t\tstruct object_array_entry *entry = &rev.pending.objects[i];\n\t\tstruct object *obj = entry->item;\n\t\tconst char *name = entry->name;\n\t\tint flags = (obj->flags & UNINTERESTING);\n\t\tif (!obj->parsed)\n\t\t\tobj = parse_object(the_repository, &obj->oid);\n\t\tobj = deref_tag(the_repository, obj, NULL, 0);\n\t\tif (!obj)\n\t\t\tdie(_(\"invalid object '%s' given.\"), name);\n\t\tif (obj->type == OBJ_COMMIT)\n\t\t\tobj = &repo_get_commit_tree(the_repository,\n\t\t\t\t\t\t    ((struct commit *)obj))->object;\n\n\t\tif (obj->type == OBJ_TREE) {\n\t\t\tif (sdiff.skip && bitmap_get(sdiff.skip, i))\n\t\t\t\tcontinue;\n\t\t\tobj->flags |= flags;\n\t\t\tadd_object_array(obj, name, &ent);\n\t\t\tif (first_non_parent < 0 &&\n\t\t\t    (i >= rev.cmdline.nr || /* HEAD by hand. */\n\t\t\t     rev.cmdline.rev[i].whence != REV_CMD_PARENTS_ONLY))\n\t\t\t\tfirst_non_parent = ent.nr - 1;\n\t\t} else if (obj->type == OBJ_BLOB) {\n\t\t\tif (2 <= blobs)\n\t\t\t\tdie(_(\"more than two blobs given: '%s'\"), name);\n\t\t\tblob[blobs] = entry;\n\t\t\tblobs++;\n\n\t\t} else {\n\t\t\tdie(_(\"unhandled object '%s' given.\"), name);\n\t\t}\n\t}\n\tif (rev.prune_data.nr)\n\t\tpaths += rev.prune_data.nr;\n\n\t/*\n\t * Now, do the arguments look reasonable?\n\t */\n\tif (!ent.nr) {\n\t\tswitch (blobs) {\n\t\tcase 0:\n\t\t\tresult = builtin_diff_files(&rev, argc, argv);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (paths != 1)\n\t\t\t\tusage(builtin_diff_usage);\n\t\t\tresult = builtin_diff_b_f(&rev, argc, argv, blob);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (paths)\n\t\t\t\tusage(builtin_diff_usage);\n\t\t\tresult = builtin_diff_blobs(&rev, argc, argv, blob);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(builtin_diff_usage);\n\t\t}\n\t}\n\telse if (blobs)\n\t\tusage(builtin_diff_usage);\n\telse if (ent.nr == 1)\n\t\tresult = builtin_diff_index(&rev, argc, argv);\n\telse if (ent.nr == 2) {\n\t\tif (sdiff.warn)\n\t\t\twarning(_(\"%s...%s: multiple merge bases, using %s\"),\n\t\t\t\tsdiff.left, sdiff.right, sdiff.base);\n\t\tresult = builtin_diff_tree(&rev, argc, argv,\n\t\t\t\t\t   &ent.objects[0], &ent.objects[1]);\n\t} else\n\t\tresult = builtin_diff_combined(&rev, argc, argv,\n\t\t\t\t\t       ent.objects, ent.nr,\n\t\t\t\t\t       first_non_parent);\n\tresult = diff_result_code(&rev.diffopt, result);\n\tif (1 < rev.diffopt.skip_stat_unmatch)\n\t\trefresh_index_quietly();\n\trelease_revisions(&rev);\n\tobject_array_clear(&ent);\n\tUNLEAK(blob);\n\treturn result;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "005f415d368d7bd9202a9b06fcf0ebcdd6199635",
  "sha1_ok": true,
  "size": 16817
}
