{
  "content": {
    "base64": "I2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAiYWJzcGF0aC5oIgojaW5jbHVkZSAicGFyc2UuaCIKI2luY2x1ZGUgImdldHRleHQuaCIKI2luY2x1ZGUgInN0cmJ1Zi5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgInV0ZjguaCIKCnN0YXRpYyBpbnQgZGlzYWxsb3dfYWJicmV2aWF0ZWRfb3B0aW9uczsKCmVudW0gb3B0X3BhcnNlZCB7CglPUFRfTE9ORyAgPSAwLAoJT1BUX1NIT1JUID0gMTw8MCwKCU9QVF9VTlNFVCA9IDE8PDEsCn07CgpzdGF0aWMgdm9pZCBvcHRidWcoY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICpyZWFzb24pCnsKCWlmIChvcHQtPmxvbmdfbmFtZSAmJiBvcHQtPnNob3J0X25hbWUpCgkJYnVnKCJzd2l0Y2ggJyVjJyAoLS0lcykgJXMiLCBvcHQtPnNob3J0X25hbWUsCgkJICAgIG9wdC0+bG9uZ19uYW1lLCByZWFzb24pOwoJZWxzZSBpZiAob3B0LT5sb25nX25hbWUpCgkJYnVnKCJvcHRpb24gJyVzJyAlcyIsIG9wdC0+bG9uZ19uYW1lLCByZWFzb24pOwoJZWxzZQoJCWJ1Zygic3dpdGNoICclYycgJXMiLCBvcHQtPnNob3J0X25hbWUsIHJlYXNvbik7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpvcHRuYW1lKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgZW51bSBvcHRfcGFyc2VkIGZsYWdzKQp7CglzdGF0aWMgc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoKCXN0cmJ1Zl9yZXNldCgmc2IpOwoJaWYgKGZsYWdzICYgT1BUX1NIT1JUKQoJCXN0cmJ1Zl9hZGRmKCZzYiwgInN3aXRjaCBgJWMnIiwgb3B0LT5zaG9ydF9uYW1lKTsKCWVsc2UgaWYgKGZsYWdzICYgT1BUX1VOU0VUKQoJCXN0cmJ1Zl9hZGRmKCZzYiwgIm9wdGlvbiBgbm8tJXMnIiwgb3B0LT5sb25nX25hbWUpOwoJZWxzZSBpZiAoZmxhZ3MgPT0gT1BUX0xPTkcpCgkJc3RyYnVmX2FkZGYoJnNiLCAib3B0aW9uIGAlcyciLCBvcHQtPmxvbmdfbmFtZSk7CgllbHNlCgkJQlVHKCJvcHRuYW1lKCkgZ290IHVua25vd24gZmxhZ3MgJWQiLCBmbGFncyk7CgoJcmV0dXJuIHNiLmJ1ZjsKfQoKc3RhdGljIGVudW0gcGFyc2Vfb3B0X3Jlc3VsdCBnZXRfYXJnKHN0cnVjdCBwYXJzZV9vcHRfY3R4X3QgKnAsCgkJCQkgICAgIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwKCQkJCSAgICAgZW51bSBvcHRfcGFyc2VkIGZsYWdzLCBjb25zdCBjaGFyICoqYXJnKQp7CglpZiAocC0+b3B0KSB7CgkJKmFyZyA9IHAtPm9wdDsKCQlwLT5vcHQgPSBOVUxMOwoJfSBlbHNlIGlmIChwLT5hcmdjID09IDEgJiYgKG9wdC0+ZmxhZ3MgJiBQQVJTRV9PUFRfTEFTVEFSR19ERUZBVUxUKSkgewoJCSphcmcgPSAoY29uc3QgY2hhciAqKW9wdC0+ZGVmdmFsOwoJfSBlbHNlIGlmIChwLT5hcmdjID4gMSkgewoJCXAtPmFyZ2MtLTsKCQkqYXJnID0gKisrcC0+YXJndjsKCX0gZWxzZQoJCXJldHVybiBlcnJvcihfKCIlcyByZXF1aXJlcyBhIHZhbHVlIiksIG9wdG5hbWUob3B0LCBmbGFncykpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGZpeF9maWxlbmFtZShjb25zdCBjaGFyICpwcmVmaXgsIGNoYXIgKipmaWxlKQp7CglpZiAoIWZpbGUgfHwgISpmaWxlKQoJCTsgLyogbGVhdmUgYXMgTlVMTCAqLwoJZWxzZQoJCSpmaWxlID0gcHJlZml4X2ZpbGVuYW1lX2V4Y2VwdF9mb3JfZGFzaChwcmVmaXgsICpmaWxlKTsKfQoKc3RhdGljIGVudW0gcGFyc2Vfb3B0X3Jlc3VsdCBkb19nZXRfdmFsdWUoc3RydWN0IHBhcnNlX29wdF9jdHhfdCAqcCwKCQkJCQkgIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwKCQkJCQkgIGVudW0gb3B0X3BhcnNlZCBmbGFncywKCQkJCQkgIGNvbnN0IGNoYXIgKiphcmdwKQp7Cgljb25zdCBjaGFyICpzLCAqYXJnOwoJY29uc3QgaW50IHVuc2V0ID0gZmxhZ3MgJiBPUFRfVU5TRVQ7CglpbnQgZXJyOwoKCWlmICh1bnNldCAmJiBwLT5vcHQpCgkJcmV0dXJuIGVycm9yKF8oIiVzIHRha2VzIG5vIHZhbHVlIiksIG9wdG5hbWUob3B0LCBmbGFncykpOwoJaWYgKHVuc2V0ICYmIChvcHQtPmZsYWdzICYgUEFSU0VfT1BUX05PTkVHKSkKCQlyZXR1cm4gZXJyb3IoXygiJXMgaXNuJ3QgYXZhaWxhYmxlIiksIG9wdG5hbWUob3B0LCBmbGFncykpOwoJaWYgKCEoZmxhZ3MgJiBPUFRfU0hPUlQpICYmIHAtPm9wdCAmJiAob3B0LT5mbGFncyAmIFBBUlNFX09QVF9OT0FSRykpCgkJcmV0dXJuIGVycm9yKF8oIiVzIHRha2VzIG5vIHZhbHVlIiksIG9wdG5hbWUob3B0LCBmbGFncykpOwoKCXN3aXRjaCAob3B0LT50eXBlKSB7CgljYXNlIE9QVElPTl9MT1dMRVZFTF9DQUxMQkFDSzoKCQlyZXR1cm4gb3B0LT5sbF9jYWxsYmFjayhwLCBvcHQsIE5VTEwsIHVuc2V0KTsKCgljYXNlIE9QVElPTl9CSVQ6CgkJaWYgKHVuc2V0KQoJCQkqKGludCAqKW9wdC0+dmFsdWUgJj0gfm9wdC0+ZGVmdmFsOwoJCWVsc2UKCQkJKihpbnQgKilvcHQtPnZhbHVlIHw9IG9wdC0+ZGVmdmFsOwoJCXJldHVybiAwOwoKCWNhc2UgT1BUSU9OX05FR0JJVDoKCQlpZiAodW5zZXQpCgkJCSooaW50ICopb3B0LT52YWx1ZSB8PSBvcHQtPmRlZnZhbDsKCQllbHNlCgkJCSooaW50ICopb3B0LT52YWx1ZSAmPSB+b3B0LT5kZWZ2YWw7CgkJcmV0dXJuIDA7CgoJY2FzZSBPUFRJT05fQklUT1A6CgkJaWYgKHVuc2V0KQoJCQlCVUcoIkJJVE9QIGNhbid0IGhhdmUgdW5zZXQgZm9ybSIpOwoJCSooaW50ICopb3B0LT52YWx1ZSAmPSB+b3B0LT5leHRyYTsKCQkqKGludCAqKW9wdC0+dmFsdWUgfD0gb3B0LT5kZWZ2YWw7CgkJcmV0dXJuIDA7CgoJY2FzZSBPUFRJT05fQ09VTlRVUDoKCQlpZiAoKihpbnQgKilvcHQtPnZhbHVlIDwgMCkKCQkJKihpbnQgKilvcHQtPnZhbHVlID0gMDsKCQkqKGludCAqKW9wdC0+dmFsdWUgPSB1bnNldCA/IDAgOiAqKGludCAqKW9wdC0+dmFsdWUgKyAxOwoJCXJldHVybiAwOwoKCWNhc2UgT1BUSU9OX1NFVF9JTlQ6CgkJKihpbnQgKilvcHQtPnZhbHVlID0gdW5zZXQgPyAwIDogb3B0LT5kZWZ2YWw7CgkJcmV0dXJuIDA7CgoJY2FzZSBPUFRJT05fU1RSSU5HOgoJCWlmICh1bnNldCkKCQkJKihjb25zdCBjaGFyICoqKW9wdC0+dmFsdWUgPSBOVUxMOwoJCWVsc2UgaWYgKG9wdC0+ZmxhZ3MgJiBQQVJTRV9PUFRfT1BUQVJHICYmICFwLT5vcHQpCgkJCSooY29uc3QgY2hhciAqKilvcHQtPnZhbHVlID0gKGNvbnN0IGNoYXIgKilvcHQtPmRlZnZhbDsKCQllbHNlCgkJCXJldHVybiBnZXRfYXJnKHAsIG9wdCwgZmxhZ3MsIChjb25zdCBjaGFyICoqKW9wdC0+dmFsdWUpOwoJCXJldHVybiAwOwoKCWNhc2UgT1BUSU9OX0ZJTEVOQU1FOgoJCWVyciA9IDA7CgkJaWYgKHVuc2V0KQoJCQkqKGNvbnN0IGNoYXIgKiopb3B0LT52YWx1ZSA9IE5VTEw7CgkJZWxzZSBpZiAob3B0LT5mbGFncyAmIFBBUlNFX09QVF9PUFRBUkcgJiYgIXAtPm9wdCkKCQkJKihjb25zdCBjaGFyICoqKW9wdC0+dmFsdWUgPSAoY29uc3QgY2hhciAqKW9wdC0+ZGVmdmFsOwoJCWVsc2UKCQkJZXJyID0gZ2V0X2FyZyhwLCBvcHQsIGZsYWdzLCAoY29uc3QgY2hhciAqKilvcHQtPnZhbHVlKTsKCgkJaWYgKCFlcnIpCgkJCWZpeF9maWxlbmFtZShwLT5wcmVmaXgsIChjaGFyICoqKW9wdC0+dmFsdWUpOwoJCXJldHVybiBlcnI7CgoJY2FzZSBPUFRJT05fQ0FMTEJBQ0s6Cgl7CgkJY29uc3QgY2hhciAqcF9hcmcgPSBOVUxMOwoJCWludCBwX3Vuc2V0OwoKCQlpZiAodW5zZXQpCgkJCXBfdW5zZXQgPSAxOwoJCWVsc2UgaWYgKG9wdC0+ZmxhZ3MgJiBQQVJTRV9PUFRfTk9BUkcpCgkJCXBfdW5zZXQgPSAwOwoJCWVsc2UgaWYgKG9wdC0+ZmxhZ3MgJiBQQVJTRV9PUFRfT1BUQVJHICYmICFwLT5vcHQpCgkJCXBfdW5zZXQgPSAwOwoJCWVsc2UgaWYgKGdldF9hcmcocCwgb3B0LCBmbGFncywgJmFyZykpCgkJCXJldHVybiAtMTsKCQllbHNlIHsKCQkJcF91bnNldCA9IDA7CgkJCXBfYXJnID0gYXJnOwoJCX0KCQlpZiAob3B0LT5mbGFncyAmIFBBUlNFX09QVF9DTURNT0RFKQoJCQkqYXJncCA9IHBfYXJnOwoJCWlmIChvcHQtPmNhbGxiYWNrKQoJCQlyZXR1cm4gKCpvcHQtPmNhbGxiYWNrKShvcHQsIHBfYXJnLCBwX3Vuc2V0KSA/ICgtMSkgOiAwOwoJCWVsc2UKCQkJcmV0dXJuICgqb3B0LT5sbF9jYWxsYmFjaykocCwgb3B0LCBwX2FyZywgcF91bnNldCk7Cgl9CgljYXNlIE9QVElPTl9JTlRFR0VSOgoJCWlmICh1bnNldCkgewoJCQkqKGludCAqKW9wdC0+dmFsdWUgPSAwOwoJCQlyZXR1cm4gMDsKCQl9CgkJaWYgKG9wdC0+ZmxhZ3MgJiBQQVJTRV9PUFRfT1BUQVJHICYmICFwLT5vcHQpIHsKCQkJKihpbnQgKilvcHQtPnZhbHVlID0gb3B0LT5kZWZ2YWw7CgkJCXJldHVybiAwOwoJCX0KCQlpZiAoZ2V0X2FyZyhwLCBvcHQsIGZsYWdzLCAmYXJnKSkKCQkJcmV0dXJuIC0xOwoJCWlmICghKmFyZykKCQkJcmV0dXJuIGVycm9yKF8oIiVzIGV4cGVjdHMgYSBudW1lcmljYWwgdmFsdWUiKSwKCQkJCSAgICAgb3B0bmFtZShvcHQsIGZsYWdzKSk7CgkJKihpbnQgKilvcHQtPnZhbHVlID0gc3RydG9sKGFyZywgKGNoYXIgKiopJnMsIDEwKTsKCQlpZiAoKnMpCgkJCXJldHVybiBlcnJvcihfKCIlcyBleHBlY3RzIGEgbnVtZXJpY2FsIHZhbHVlIiksCgkJCQkgICAgIG9wdG5hbWUob3B0LCBmbGFncykpOwoJCXJldHVybiAwOwoKCWNhc2UgT1BUSU9OX01BR05JVFVERToKCQlpZiAodW5zZXQpIHsKCQkJKih1bnNpZ25lZCBsb25nICopb3B0LT52YWx1ZSA9IDA7CgkJCXJldHVybiAwOwoJCX0KCQlpZiAob3B0LT5mbGFncyAmIFBBUlNFX09QVF9PUFRBUkcgJiYgIXAtPm9wdCkgewoJCQkqKHVuc2lnbmVkIGxvbmcgKilvcHQtPnZhbHVlID0gb3B0LT5kZWZ2YWw7CgkJCXJldHVybiAwOwoJCX0KCQlpZiAoZ2V0X2FyZyhwLCBvcHQsIGZsYWdzLCAmYXJnKSkKCQkJcmV0dXJuIC0xOwoJCWlmICghZ2l0X3BhcnNlX3Vsb25nKGFyZywgb3B0LT52YWx1ZSkpCgkJCXJldHVybiBlcnJvcihfKCIlcyBleHBlY3RzIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgdmFsdWUiCgkJCQkgICAgICAgIiB3aXRoIGFuIG9wdGlvbmFsIGsvbS9nIHN1ZmZpeCIpLAoJCQkJICAgICBvcHRuYW1lKG9wdCwgZmxhZ3MpKTsKCQlyZXR1cm4gMDsKCglkZWZhdWx0OgoJCUJVRygib3B0LT50eXBlICVkIHNob3VsZCBub3QgaGFwcGVuIiwgb3B0LT50eXBlKTsKCX0KfQoKc3RydWN0IHBhcnNlX29wdF9jbWRtb2RlX2xpc3QgewoJaW50IHZhbHVlLCAqdmFsdWVfcHRyOwoJY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0OwoJY29uc3QgY2hhciAqYXJnOwoJZW51bSBvcHRfcGFyc2VkIGZsYWdzOwoJc3RydWN0IHBhcnNlX29wdF9jbWRtb2RlX2xpc3QgKm5leHQ7Cn07CgpzdGF0aWMgdm9pZCBidWlsZF9jbWRtb2RlX2xpc3Qoc3RydWN0IHBhcnNlX29wdF9jdHhfdCAqY3R4LAoJCQkgICAgICAgY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0cykKewoJY3R4LT5jbWRtb2RlX2xpc3QgPSBOVUxMOwoKCWZvciAoOyBvcHRzLT50eXBlICE9IE9QVElPTl9FTkQ7IG9wdHMrKykgewoJCXN0cnVjdCBwYXJzZV9vcHRfY21kbW9kZV9saXN0ICplbGVtID0gY3R4LT5jbWRtb2RlX2xpc3Q7CgkJaW50ICp2YWx1ZV9wdHIgPSBvcHRzLT52YWx1ZTsKCgkJaWYgKCEob3B0cy0+ZmxhZ3MgJiBQQVJTRV9PUFRfQ01ETU9ERSkgfHwgIXZhbHVlX3B0cikKCQkJY29udGludWU7CgoJCXdoaWxlIChlbGVtICYmIGVsZW0tPnZhbHVlX3B0ciAhPSB2YWx1ZV9wdHIpCgkJCWVsZW0gPSBlbGVtLT5uZXh0OwoJCWlmIChlbGVtKQoJCQljb250aW51ZTsKCgkJQ0FMTE9DX0FSUkFZKGVsZW0sIDEpOwoJCWVsZW0tPnZhbHVlX3B0ciA9IHZhbHVlX3B0cjsKCQllbGVtLT52YWx1ZSA9ICp2YWx1ZV9wdHI7CgkJZWxlbS0+bmV4dCA9IGN0eC0+Y21kbW9kZV9saXN0OwoJCWN0eC0+Y21kbW9kZV9saXN0ID0gZWxlbTsKCX0KfQoKc3RhdGljIGNoYXIgKm9wdG5hbWVhcmcoY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsCgkJCWVudW0gb3B0X3BhcnNlZCBmbGFncykKewoJaWYgKGZsYWdzICYgT1BUX1NIT1JUKQoJCXJldHVybiB4c3RyZm10KCItJWMlcyIsIG9wdC0+c2hvcnRfbmFtZSwgYXJnID8gYXJnIDogIiIpOwoJcmV0dXJuIHhzdHJmbXQoIi0tJXMlcyVzJXMiLCBmbGFncyAmIE9QVF9VTlNFVCA/ICJuby0iIDogIiIsCgkJICAgICAgIG9wdC0+bG9uZ19uYW1lLCBhcmcgPyAiPSIgOiAiIiwgYXJnID8gYXJnIDogIiIpOwp9CgpzdGF0aWMgZW51bSBwYXJzZV9vcHRfcmVzdWx0IGdldF92YWx1ZShzdHJ1Y3QgcGFyc2Vfb3B0X2N0eF90ICpwLAoJCQkJICAgICAgIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwKCQkJCSAgICAgICBlbnVtIG9wdF9wYXJzZWQgZmxhZ3MpCnsKCWNvbnN0IGNoYXIgKmFyZyA9IE5VTEw7CgllbnVtIHBhcnNlX29wdF9yZXN1bHQgcmVzdWx0ID0gZG9fZ2V0X3ZhbHVlKHAsIG9wdCwgZmxhZ3MsICZhcmcpOwoJc3RydWN0IHBhcnNlX29wdF9jbWRtb2RlX2xpc3QgKmVsZW0gPSBwLT5jbWRtb2RlX2xpc3Q7CgljaGFyICpvcHRfbmFtZSwgKm90aGVyX29wdF9uYW1lOwoKCWZvciAoOyBlbGVtOyBlbGVtID0gZWxlbS0+bmV4dCkgewoJCWlmICgqZWxlbS0+dmFsdWVfcHRyID09IGVsZW0tPnZhbHVlKQoJCQljb250aW51ZTsKCgkJaWYgKGVsZW0tPm9wdCAmJgoJCSAgICAoZWxlbS0+b3B0LT5mbGFncyB8IG9wdC0+ZmxhZ3MpICYgUEFSU0VfT1BUX0NNRE1PREUpCgkJCWJyZWFrOwoKCQllbGVtLT5vcHQgPSBvcHQ7CgkJZWxlbS0+YXJnID0gYXJnOwoJCWVsZW0tPmZsYWdzID0gZmxhZ3M7CgkJZWxlbS0+dmFsdWUgPSAqZWxlbS0+dmFsdWVfcHRyOwoJfQoKCWlmIChyZXN1bHQgfHwgIWVsZW0pCgkJcmV0dXJuIHJlc3VsdDsKCglvcHRfbmFtZSA9IG9wdG5hbWVhcmcob3B0LCBhcmcsIGZsYWdzKTsKCW90aGVyX29wdF9uYW1lID0gb3B0bmFtZWFyZyhlbGVtLT5vcHQsIGVsZW0tPmFyZywgZWxlbS0+ZmxhZ3MpOwoJZXJyb3IoXygib3B0aW9ucyAnJXMnIGFuZCAnJXMnIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIiksCgkgICAgICBvcHRfbmFtZSwgb3RoZXJfb3B0X25hbWUpOwoJZnJlZShvcHRfbmFtZSk7CglmcmVlKG90aGVyX29wdF9uYW1lKTsKCXJldHVybiAtMTsKfQoKc3RhdGljIGVudW0gcGFyc2Vfb3B0X3Jlc3VsdCBwYXJzZV9zaG9ydF9vcHQoc3RydWN0IHBhcnNlX29wdF9jdHhfdCAqcCwKCQkJCQkgICAgIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdGlvbnMpCnsKCWNvbnN0IHN0cnVjdCBvcHRpb24gKm51bW9wdCA9IE5VTEw7CgoJZm9yICg7IG9wdGlvbnMtPnR5cGUgIT0gT1BUSU9OX0VORDsgb3B0aW9ucysrKSB7CgkJaWYgKG9wdGlvbnMtPnNob3J0X25hbWUgPT0gKnAtPm9wdCkgewoJCQlwLT5vcHQgPSBwLT5vcHRbMV0gPyBwLT5vcHQgKyAxIDogTlVMTDsKCQkJcmV0dXJuIGdldF92YWx1ZShwLCBvcHRpb25zLCBPUFRfU0hPUlQpOwoJCX0KCgkJLyoKCQkgKiBIYW5kbGUgdGhlIG51bWVyaWNhbCBvcHRpb24gbGF0ZXIsIGV4cGxpY2l0IG9uZS1kaWdpdAoJCSAqIG9wdGlvbnMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgaXQuCgkJICovCgkJaWYgKG9wdGlvbnMtPnR5cGUgPT0gT1BUSU9OX05VTUJFUikKCQkJbnVtb3B0ID0gb3B0aW9uczsKCX0KCWlmIChudW1vcHQgJiYgaXNkaWdpdCgqcC0+b3B0KSkgewoJCXNpemVfdCBsZW4gPSAxOwoJCWNoYXIgKmFyZzsKCQlpbnQgcmM7CgoJCXdoaWxlIChpc2RpZ2l0KHAtPm9wdFtsZW5dKSkKCQkJbGVuKys7CgkJYXJnID0geG1lbWR1cHoocC0+b3B0LCBsZW4pOwoJCXAtPm9wdCA9IHAtPm9wdFtsZW5dID8gcC0+b3B0ICsgbGVuIDogTlVMTDsKCQlpZiAobnVtb3B0LT5jYWxsYmFjaykKCQkJcmMgPSAoKm51bW9wdC0+Y2FsbGJhY2spKG51bW9wdCwgYXJnLCAwKSA/ICgtMSkgOiAwOwoJCWVsc2UKCQkJcmMgPSAoKm51bW9wdC0+bGxfY2FsbGJhY2spKHAsIG51bW9wdCwgYXJnLCAwKTsKCQlmcmVlKGFyZyk7CgkJcmV0dXJuIHJjOwoJfQoJcmV0dXJuIFBBUlNFX09QVF9VTktOT1dOOwp9CgpzdGF0aWMgaW50IGhhc19zdHJpbmcoY29uc3QgY2hhciAqaXQsIGNvbnN0IGNoYXIgKiphcnJheSkKewoJd2hpbGUgKCphcnJheSkKCQlpZiAoIXN0cmNtcChpdCwgKihhcnJheSsrKSkpCgkJCXJldHVybiAxOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgaXNfYWxpYXMoc3RydWN0IHBhcnNlX29wdF9jdHhfdCAqY3R4LAoJCSAgICBjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvbmVfb3B0LAoJCSAgICBjb25zdCBzdHJ1Y3Qgb3B0aW9uICphbm90aGVyX29wdCkKewoJY29uc3QgY2hhciAqKmdyb3VwOwoKCWlmICghY3R4LT5hbGlhc19ncm91cHMpCgkJcmV0dXJuIDA7CgoJaWYgKCFvbmVfb3B0LT5sb25nX25hbWUgfHwgIWFub3RoZXJfb3B0LT5sb25nX25hbWUpCgkJcmV0dXJuIDA7CgoJZm9yIChncm91cCA9IGN0eC0+YWxpYXNfZ3JvdXBzOyAqZ3JvdXA7IGdyb3VwICs9IDMpIHsKCQkvKiBpdCBhbmQgb3RoZXIgYXJlIGZyb20gdGhlIHNhbWUgZmFtaWx5PyAqLwoJCWlmIChoYXNfc3RyaW5nKG9uZV9vcHQtPmxvbmdfbmFtZSwgZ3JvdXApICYmCgkJICAgIGhhc19zdHJpbmcoYW5vdGhlcl9vcHQtPmxvbmdfbmFtZSwgZ3JvdXApKQoJCQlyZXR1cm4gMTsKCX0KCXJldHVybiAwOwp9CgpzdHJ1Y3QgcGFyc2VkX29wdGlvbiB7Cgljb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRpb247CgllbnVtIG9wdF9wYXJzZWQgZmxhZ3M7Cn07CgpzdGF0aWMgdm9pZCByZWdpc3Rlcl9hYmJyZXYoc3RydWN0IHBhcnNlX29wdF9jdHhfdCAqcCwKCQkJICAgIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdGlvbiwgZW51bSBvcHRfcGFyc2VkIGZsYWdzLAoJCQkgICAgc3RydWN0IHBhcnNlZF9vcHRpb24gKmFiYnJldiwKCQkJICAgIHN0cnVjdCBwYXJzZWRfb3B0aW9uICphbWJpZ3VvdXMpCnsKCWlmIChwLT5mbGFncyAmIFBBUlNFX09QVF9LRUVQX1VOS05PV05fT1BUKQoJCXJldHVybjsKCWlmIChhYmJyZXYtPm9wdGlvbiAmJgoJICAgICEoYWJicmV2LT5mbGFncyA9PSBmbGFncyAmJiBpc19hbGlhcyhwLCBhYmJyZXYtPm9wdGlvbiwgb3B0aW9uKSkpIHsKCQkvKgoJCSAqIElmIHRoaXMgaXMgYWJicmV2aWF0ZWQsIGl0IGlzCgkJICogYW1iaWd1b3VzLiBTbyB3aGVuIHRoZXJlIGlzIG5vCgkJICogZXhhY3QgbWF0Y2ggbGF0ZXIsIHdlIG5lZWQgdG8KCQkgKiBlcnJvciBvdXQuCgkJICovCgkJYW1iaWd1b3VzLT5vcHRpb24gPSBhYmJyZXYtPm9wdGlvbjsKCQlhbWJpZ3VvdXMtPmZsYWdzID0gYWJicmV2LT5mbGFnczsKCX0KCWFiYnJldi0+b3B0aW9uID0gb3B0aW9uOwoJYWJicmV2LT5mbGFncyA9IGZsYWdzOwp9CgpzdGF0aWMgZW51bSBwYXJzZV9vcHRfcmVzdWx0IHBhcnNlX2xvbmdfb3B0KAoJc3RydWN0IHBhcnNlX29wdF9jdHhfdCAqcCwgY29uc3QgY2hhciAqYXJnLAoJY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0aW9ucykKewoJY29uc3QgY2hhciAqYXJnX2VuZCA9IHN0cmNocm51bChhcmcsICc9Jyk7CglzdHJ1Y3QgcGFyc2VkX29wdGlvbiBhYmJyZXYgPSB7IC5vcHRpb24gPSBOVUxMLCAuZmxhZ3MgPSBPUFRfTE9ORyB9OwoJc3RydWN0IHBhcnNlZF9vcHRpb24gYW1iaWd1b3VzID0geyAub3B0aW9uID0gTlVMTCwgLmZsYWdzID0gT1BUX0xPTkcgfTsKCglmb3IgKDsgb3B0aW9ucy0+dHlwZSAhPSBPUFRJT05fRU5EOyBvcHRpb25zKyspIHsKCQljb25zdCBjaGFyICpyZXN0LCAqbG9uZ19uYW1lID0gb3B0aW9ucy0+bG9uZ19uYW1lOwoJCWVudW0gb3B0X3BhcnNlZCBmbGFncyA9IE9QVF9MT05HLCBvcHRfZmxhZ3MgPSBPUFRfTE9ORzsKCgkJaWYgKG9wdGlvbnMtPnR5cGUgPT0gT1BUSU9OX1NVQkNPTU1BTkQpCgkJCWNvbnRpbnVlOwoJCWlmICghbG9uZ19uYW1lKQoJCQljb250aW51ZTsKCgkJaWYgKCFzdGFydHNfd2l0aChhcmcsICJuby0iKSAmJgoJCSAgICAhKG9wdGlvbnMtPmZsYWdzICYgUEFSU0VfT1BUX05PTkVHKSAmJgoJCSAgICBza2lwX3ByZWZpeChsb25nX25hbWUsICJuby0iLCAmbG9uZ19uYW1lKSkKCQkJb3B0X2ZsYWdzIHw9IE9QVF9VTlNFVDsKCgkJaWYgKCFza2lwX3ByZWZpeChhcmcsIGxvbmdfbmFtZSwgJnJlc3QpKQoJCQlyZXN0ID0gTlVMTDsKCQlpZiAoIXJlc3QpIHsKCQkJLyogYWJicmV2aWF0ZWQ/ICovCgkJCWlmICghc3RybmNtcChsb25nX25hbWUsIGFyZywgYXJnX2VuZCAtIGFyZykpIHsKCQkJCXJlZ2lzdGVyX2FiYnJldihwLCBvcHRpb25zLCBmbGFncyBeIG9wdF9mbGFncywKCQkJCQkJJmFiYnJldiwgJmFtYmlndW91cyk7CgkJCX0KCQkJLyogbmVnYXRpb24gYWxsb3dlZD8gKi8KCQkJaWYgKG9wdGlvbnMtPmZsYWdzICYgUEFSU0VfT1BUX05PTkVHKQoJCQkJY29udGludWU7CgkJCS8qIG5lZ2F0ZWQgYW5kIGFiYnJldmlhdGVkIHZlcnkgbXVjaD8gKi8KCQkJaWYgKHN0YXJ0c193aXRoKCJuby0iLCBhcmcpKSB7CgkJCQlmbGFncyB8PSBPUFRfVU5TRVQ7CgkJCQlyZWdpc3Rlcl9hYmJyZXYocCwgb3B0aW9ucywgZmxhZ3MgXiBvcHRfZmxhZ3MsCgkJCQkJCSZhYmJyZXYsICZhbWJpZ3VvdXMpOwoJCQkJY29udGludWU7CgkJCX0KCQkJLyogbmVnYXRlZD8gKi8KCQkJaWYgKCFzdGFydHNfd2l0aChhcmcsICJuby0iKSkKCQkJCWNvbnRpbnVlOwoJCQlmbGFncyB8PSBPUFRfVU5TRVQ7CgkJCWlmICghc2tpcF9wcmVmaXgoYXJnICsgMywgbG9uZ19uYW1lLCAmcmVzdCkpIHsKCQkJCS8qIGFiYnJldmlhdGVkIGFuZCBuZWdhdGVkPyAqLwoJCQkJaWYgKCFzdHJuY21wKGxvbmdfbmFtZSwgYXJnICsgMywKCQkJCQkgICAgIGFyZ19lbmQgLSBhcmcgLSAzKSkKCQkJCQlyZWdpc3Rlcl9hYmJyZXYocCwgb3B0aW9ucywKCQkJCQkJCWZsYWdzIF4gb3B0X2ZsYWdzLAoJCQkJCQkJJmFiYnJldiwgJmFtYmlndW91cyk7CgkJCQljb250aW51ZTsKCQkJfQoJCX0KCQlpZiAoKnJlc3QpIHsKCQkJaWYgKCpyZXN0ICE9ICc9JykKCQkJCWNvbnRpbnVlOwoJCQlwLT5vcHQgPSByZXN0ICsgMTsKCQl9CgkJcmV0dXJuIGdldF92YWx1ZShwLCBvcHRpb25zLCBmbGFncyBeIG9wdF9mbGFncyk7Cgl9CgoJaWYgKGRpc2FsbG93X2FiYnJldmlhdGVkX29wdGlvbnMgJiYgKGFtYmlndW91cy5vcHRpb24gfHwgYWJicmV2Lm9wdGlvbikpCgkJZGllKCJkaXNhbGxvd2VkIGFiYnJldmlhdGVkIG9yIGFtYmlndW91cyBvcHRpb24gJyUuKnMnIiwKCQkgICAgKGludCkoYXJnX2VuZCAtIGFyZyksIGFyZyk7CgoJaWYgKGFtYmlndW91cy5vcHRpb24pIHsKCQllcnJvcihfKCJhbWJpZ3VvdXMgb3B0aW9uOiAlcyAiCgkJCSIoY291bGQgYmUgLS0lcyVzIG9yIC0tJXMlcykiKSwKCQkJYXJnLAoJCQkoYW1iaWd1b3VzLmZsYWdzICYgT1BUX1VOU0VUKSA/ICAibm8tIiA6ICIiLAoJCQlhbWJpZ3VvdXMub3B0aW9uLT5sb25nX25hbWUsCgkJCShhYmJyZXYuZmxhZ3MgJiBPUFRfVU5TRVQpID8gICJuby0iIDogIiIsCgkJCWFiYnJldi5vcHRpb24tPmxvbmdfbmFtZSk7CgkJcmV0dXJuIFBBUlNFX09QVF9IRUxQOwoJfQoJaWYgKGFiYnJldi5vcHRpb24pIHsKCQlpZiAoKmFyZ19lbmQpCgkJCXAtPm9wdCA9IGFyZ19lbmQgKyAxOwoJCXJldHVybiBnZXRfdmFsdWUocCwgYWJicmV2Lm9wdGlvbiwgYWJicmV2LmZsYWdzKTsKCX0KCXJldHVybiBQQVJTRV9PUFRfVU5LTk9XTjsKfQoKc3RhdGljIGVudW0gcGFyc2Vfb3B0X3Jlc3VsdCBwYXJzZV9ub2Rhc2hfb3B0KHN0cnVjdCBwYXJzZV9vcHRfY3R4X3QgKnAsCgkJCQkJICAgICAgY29uc3QgY2hhciAqYXJnLAoJCQkJCSAgICAgIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdGlvbnMpCnsKCWZvciAoOyBvcHRpb25zLT50eXBlICE9IE9QVElPTl9FTkQ7IG9wdGlvbnMrKykgewoJCWlmICghKG9wdGlvbnMtPmZsYWdzICYgUEFSU0VfT1BUX05PREFTSCkpCgkJCWNvbnRpbnVlOwoJCWlmIChvcHRpb25zLT5zaG9ydF9uYW1lID09IGFyZ1swXSAmJiBhcmdbMV0gPT0gJ1wwJykKCQkJcmV0dXJuIGdldF92YWx1ZShwLCBvcHRpb25zLCBPUFRfU0hPUlQpOwoJfQoJcmV0dXJuIFBBUlNFX09QVF9FUlJPUjsKfQoKc3RhdGljIGVudW0gcGFyc2Vfb3B0X3Jlc3VsdCBwYXJzZV9zdWJjb21tYW5kKGNvbnN0IGNoYXIgKmFyZywKCQkJCQkgICAgICBjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRpb25zKQp7Cglmb3IgKDsgb3B0aW9ucy0+dHlwZSAhPSBPUFRJT05fRU5EOyBvcHRpb25zKyspCgkJaWYgKG9wdGlvbnMtPnR5cGUgPT0gT1BUSU9OX1NVQkNPTU1BTkQgJiYKCQkgICAgIXN0cmNtcChvcHRpb25zLT5sb25nX25hbWUsIGFyZykpIHsKCQkJKihwYXJzZV9vcHRfc3ViY29tbWFuZF9mbiAqKilvcHRpb25zLT52YWx1ZSA9IG9wdGlvbnMtPnN1YmNvbW1hbmRfZm47CgkJCXJldHVybiBQQVJTRV9PUFRfU1VCQ09NTUFORDsKCQl9CgoJcmV0dXJuIFBBUlNFX09QVF9VTktOT1dOOwp9CgpzdGF0aWMgdm9pZCBjaGVja190eXBvcyhjb25zdCBjaGFyICphcmcsIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdGlvbnMpCnsKCWlmIChzdHJsZW4oYXJnKSA8IDMpCgkJcmV0dXJuOwoKCWlmIChzdGFydHNfd2l0aChhcmcsICJuby0iKSkgewoJCWVycm9yKF8oImRpZCB5b3UgbWVhbiBgLS0lc2AgKHdpdGggdHdvIGRhc2hlcyk/IiksIGFyZyk7CgkJZXhpdCgxMjkpOwoJfQoKCWZvciAoOyBvcHRpb25zLT50eXBlICE9IE9QVElPTl9FTkQ7IG9wdGlvbnMrKykgewoJCWlmICghb3B0aW9ucy0+bG9uZ19uYW1lKQoJCQljb250aW51ZTsKCQlpZiAoc3RhcnRzX3dpdGgob3B0aW9ucy0+bG9uZ19uYW1lLCBhcmcpKSB7CgkJCWVycm9yKF8oImRpZCB5b3UgbWVhbiBgLS0lc2AgKHdpdGggdHdvIGRhc2hlcyk/IiksIGFyZyk7CgkJCWV4aXQoMTI5KTsKCQl9Cgl9Cn0KCnN0YXRpYyB2b2lkIHBhcnNlX29wdGlvbnNfY2hlY2soY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0cykKewoJY2hhciBzaG9ydF9vcHRzWzEyOF07Cgl2b2lkICpzdWJjb21tYW5kX3ZhbHVlID0gTlVMTDsKCgltZW1zZXQoc2hvcnRfb3B0cywgJ1wwJywgc2l6ZW9mKHNob3J0X29wdHMpKTsKCWZvciAoOyBvcHRzLT50eXBlICE9IE9QVElPTl9FTkQ7IG9wdHMrKykgewoJCWlmICgob3B0cy0+ZmxhZ3MgJiBQQVJTRV9PUFRfTEFTVEFSR19ERUZBVUxUKSAmJgoJCSAgICAob3B0cy0+ZmxhZ3MgJiBQQVJTRV9PUFRfT1BUQVJHKSkKCQkJb3B0YnVnKG9wdHMsICJ1c2VzIGluY29tcGF0aWJsZSBmbGFncyAiCgkJCSAgICAgICAiTEFTVEFSR19ERUZBVUxUIGFuZCBPUFRBUkciKTsKCQlpZiAob3B0cy0+c2hvcnRfbmFtZSkgewoJCQlpZiAoMHg3RiA8PSBvcHRzLT5zaG9ydF9uYW1lKQoJCQkJb3B0YnVnKG9wdHMsICJpbnZhbGlkIHNob3J0IG5hbWUiKTsKCQkJZWxzZSBpZiAoc2hvcnRfb3B0c1tvcHRzLT5zaG9ydF9uYW1lXSsrKQoJCQkJb3B0YnVnKG9wdHMsICJzaG9ydCBuYW1lIGFscmVhZHkgdXNlZCIpOwoJCX0KCQlpZiAob3B0cy0+ZmxhZ3MgJiBQQVJTRV9PUFRfTk9EQVNIICYmCgkJICAgICgob3B0cy0+ZmxhZ3MgJiBQQVJTRV9PUFRfT1BUQVJHKSB8fAoJCSAgICAgIShvcHRzLT5mbGFncyAmIFBBUlNFX09QVF9OT0FSRykgfHwKCQkgICAgICEob3B0cy0+ZmxhZ3MgJiBQQVJTRV9PUFRfTk9ORUcpIHx8CgkJICAgICBvcHRzLT5sb25nX25hbWUpKQoJCQlvcHRidWcob3B0cywgInVzZXMgZmVhdHVyZSAiCgkJCSAgICAgICAibm90IHN1cHBvcnRlZCBmb3IgZGFzaGxlc3Mgb3B0aW9ucyIpOwoJCWlmIChvcHRzLT50eXBlID09IE9QVElPTl9TRVRfSU5UICYmICFvcHRzLT5kZWZ2YWwgJiYKCQkgICAgb3B0cy0+bG9uZ19uYW1lICYmICEob3B0cy0+ZmxhZ3MgJiBQQVJTRV9PUFRfTk9ORUcpKQoJCQlvcHRidWcob3B0cywgIk9QVElPTl9TRVRfSU5UIDAgc2hvdWxkIG5vdCBiZSBuZWdhdGFibGUiKTsKCQlzd2l0Y2ggKG9wdHMtPnR5cGUpIHsKCQljYXNlIE9QVElPTl9DT1VOVFVQOgoJCWNhc2UgT1BUSU9OX0JJVDoKCQljYXNlIE9QVElPTl9ORUdCSVQ6CgkJY2FzZSBPUFRJT05fU0VUX0lOVDoKCQljYXNlIE9QVElPTl9OVU1CRVI6CgkJCWlmICgob3B0cy0+ZmxhZ3MgJiBQQVJTRV9PUFRfT1BUQVJHKSB8fAoJCQkgICAgIShvcHRzLT5mbGFncyAmIFBBUlNFX09QVF9OT0FSRykpCgkJCQlvcHRidWcob3B0cywgInNob3VsZCBub3QgYWNjZXB0IGFuIGFyZ3VtZW50Iik7CgkJCWJyZWFrOwoJCWNhc2UgT1BUSU9OX0NBTExCQUNLOgoJCQlpZiAoIW9wdHMtPmNhbGxiYWNrICYmICFvcHRzLT5sbF9jYWxsYmFjaykKCQkJCW9wdGJ1ZyhvcHRzLCAiT1BUSU9OX0NBTExCQUNLIG5lZWRzIG9uZSBjYWxsYmFjayIpOwoJCQllbHNlIGlmIChvcHRzLT5jYWxsYmFjayAmJiBvcHRzLT5sbF9jYWxsYmFjaykKCQkJCW9wdGJ1ZyhvcHRzLCAiT1BUSU9OX0NBTExCQUNLIGNhbid0IGhhdmUgdHdvIGNhbGxiYWNrcyIpOwoJCQlicmVhazsKCQljYXNlIE9QVElPTl9MT1dMRVZFTF9DQUxMQkFDSzoKCQkJaWYgKCFvcHRzLT5sbF9jYWxsYmFjaykKCQkJCW9wdGJ1ZyhvcHRzLCAiT1BUSU9OX0xPV0xFVkVMX0NBTExCQUNLIG5lZWRzIGEgY2FsbGJhY2siKTsKCQkJaWYgKG9wdHMtPmNhbGxiYWNrKQoJCQkJb3B0YnVnKG9wdHMsICJPUFRJT05fTE9XTEVWRUxfQ0FMTEJBQ0sgbmVlZHMgbm8gaGlnaCBsZXZlbCBjYWxsYmFjayIpOwoJCQlicmVhazsKCQljYXNlIE9QVElPTl9BTElBUzoKCQkJb3B0YnVnKG9wdHMsICJPUFRfQUxJQVMoKSBzaG91bGQgbm90IHJlbWFpbiBhdCB0aGlzIHBvaW50LiAiCgkJCSAgICAgICAiQXJlIHlvdSB1c2luZyBwYXJzZV9vcHRpb25zX3N0ZXAoKSBkaXJlY3RseT9cbiIKCQkJICAgICAgICJUaGF0IGNhc2UgaXMgbm90IHN1cHBvcnRlZCB5ZXQuIik7CgkJCWJyZWFrOwoJCWNhc2UgT1BUSU9OX1NVQkNPTU1BTkQ6CgkJCWlmICghb3B0cy0+dmFsdWUgfHwgIW9wdHMtPnN1YmNvbW1hbmRfZm4pCgkJCQlvcHRidWcob3B0cywgIk9QVElPTl9TVUJDT01NQU5EIG5lZWRzIGEgdmFsdWUgYW5kIGEgc3ViY29tbWFuZCBmdW5jdGlvbiIpOwoJCQlpZiAoIXN1YmNvbW1hbmRfdmFsdWUpCgkJCQlzdWJjb21tYW5kX3ZhbHVlID0gb3B0cy0+dmFsdWU7CgkJCWVsc2UgaWYgKHN1YmNvbW1hbmRfdmFsdWUgIT0gb3B0cy0+dmFsdWUpCgkJCQlvcHRidWcob3B0cywgImFsbCBPUFRJT05fU1VCQ09NTUFORHMgbmVlZCB0aGUgc2FtZSB2YWx1ZSIpOwoJCQlicmVhazsKCQlkZWZhdWx0OgoJCQk7IC8qIG9rLiAodXN1YWxseSBhY2NlcHRzIGFuIGFyZ3VtZW50KSAqLwoJCX0KCQlpZiAob3B0cy0+YXJnaCAmJgoJCSAgICBzdHJjc3BuKG9wdHMtPmFyZ2gsICIgXyIpICE9IHN0cmxlbihvcHRzLT5hcmdoKSkKCQkJb3B0YnVnKG9wdHMsICJtdWx0aS13b3JkIGFyZ2ggc2hvdWxkIHVzZSBkYXNoIHRvIHNlcGFyYXRlIHdvcmRzIik7Cgl9CglCVUdfaWZfYnVnKCJpbnZhbGlkICdzdHJ1Y3Qgb3B0aW9uJyIpOwp9CgpzdGF0aWMgaW50IGhhc19zdWJjb21tYW5kcyhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRpb25zKQp7Cglmb3IgKDsgb3B0aW9ucy0+dHlwZSAhPSBPUFRJT05fRU5EOyBvcHRpb25zKyspCgkJaWYgKG9wdGlvbnMtPnR5cGUgPT0gT1BUSU9OX1NVQkNPTU1BTkQpCgkJCXJldHVybiAxOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHBhcnNlX29wdGlvbnNfc3RhcnRfMShzdHJ1Y3QgcGFyc2Vfb3B0X2N0eF90ICpjdHgsCgkJCQkgIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4LAoJCQkJICBjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRpb25zLAoJCQkJICBlbnVtIHBhcnNlX29wdF9mbGFncyBmbGFncykKewoJY3R4LT5hcmdjID0gYXJnYzsKCWN0eC0+YXJndiA9IGFyZ3Y7CglpZiAoIShmbGFncyAmIFBBUlNFX09QVF9PTkVfU0hPVCkpIHsKCQljdHgtPmFyZ2MtLTsKCQljdHgtPmFyZ3YrKzsKCX0KCWN0eC0+dG90YWwgPSBjdHgtPmFyZ2M7CgljdHgtPm91dCAgID0gYXJndjsKCWN0eC0+cHJlZml4ID0gcHJlZml4OwoJY3R4LT5jcGlkeCA9ICgoZmxhZ3MgJiBQQVJTRV9PUFRfS0VFUF9BUkdWMCkgIT0gMCk7CgljdHgtPmZsYWdzID0gZmxhZ3M7CgljdHgtPmhhc19zdWJjb21tYW5kcyA9IGhhc19zdWJjb21tYW5kcyhvcHRpb25zKTsKCWlmICghY3R4LT5oYXNfc3ViY29tbWFuZHMgJiYgKGZsYWdzICYgUEFSU0VfT1BUX1NVQkNPTU1BTkRfT1BUSU9OQUwpKQoJCUJVRygiVXNpbmcgUEFSU0VfT1BUX1NVQkNPTU1BTkRfT1BUSU9OQUwgd2l0aG91dCBzdWJjb21tYW5kcyIpOwoJaWYgKGN0eC0+aGFzX3N1YmNvbW1hbmRzKSB7CgkJaWYgKGZsYWdzICYgUEFSU0VfT1BUX1NUT1BfQVRfTk9OX09QVElPTikKCQkJQlVHKCJzdWJjb21tYW5kcyBhcmUgaW5jb21wYXRpYmxlIHdpdGggUEFSU0VfT1BUX1NUT1BfQVRfTk9OX09QVElPTiIpOwoJCWlmICghKGZsYWdzICYgUEFSU0VfT1BUX1NVQkNPTU1BTkRfT1BUSU9OQUwpKSB7CgkJCWlmIChmbGFncyAmIFBBUlNFX09QVF9LRUVQX1VOS05PV05fT1BUKQoJCQkJQlVHKCJzdWJjb21tYW5kcyBhcmUgaW5jb21wYXRpYmxlIHdpdGggUEFSU0VfT1BUX0tFRVBfVU5LTk9XTl9PUFQgdW5sZXNzIGluIGNvbWJpbmF0aW9uIHdpdGggUEFSU0VfT1BUX1NVQkNPTU1BTkRfT1BUSU9OQUwiKTsKCQkJaWYgKGZsYWdzICYgUEFSU0VfT1BUX0tFRVBfREFTSERBU0gpCgkJCQlCVUcoInN1YmNvbW1hbmRzIGFyZSBpbmNvbXBhdGlibGUgd2l0aCBQQVJTRV9PUFRfS0VFUF9EQVNIREFTSCB1bmxlc3MgaW4gY29tYmluYXRpb24gd2l0aCBQQVJTRV9PUFRfU1VCQ09NTUFORF9PUFRJT05BTCIpOwoJCX0KCX0KCWlmICgoZmxhZ3MgJiBQQVJTRV9PUFRfS0VFUF9VTktOT1dOX09QVCkgJiYKCSAgICAoZmxhZ3MgJiBQQVJTRV9PUFRfU1RPUF9BVF9OT05fT1BUSU9OKSAmJgoJICAgICEoZmxhZ3MgJiBQQVJTRV9PUFRfT05FX1NIT1QpKQoJCUJVRygiU1RPUF9BVF9OT05fT1BUSU9OIGFuZCBLRUVQX1VOS05PV04gZG9uJ3QgZ28gdG9nZXRoZXIiKTsKCWlmICgoZmxhZ3MgJiBQQVJTRV9PUFRfT05FX1NIT1QpICYmCgkgICAgKGZsYWdzICYgUEFSU0VfT1BUX0tFRVBfQVJHVjApKQoJCUJVRygiQ2FuJ3Qga2VlcCBhcmd2MCBpZiB5b3UgZG9uJ3QgaGF2ZSBpdCIpOwoJcGFyc2Vfb3B0aW9uc19jaGVjayhvcHRpb25zKTsKCWJ1aWxkX2NtZG1vZGVfbGlzdChjdHgsIG9wdGlvbnMpOwp9Cgp2b2lkIHBhcnNlX29wdGlvbnNfc3RhcnQoc3RydWN0IHBhcnNlX29wdF9jdHhfdCAqY3R4LAoJCQkgaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgsCgkJCSBjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRpb25zLAoJCQkgZW51bSBwYXJzZV9vcHRfZmxhZ3MgZmxhZ3MpCnsKCW1lbXNldChjdHgsIDAsIHNpemVvZigqY3R4KSk7CglwYXJzZV9vcHRpb25zX3N0YXJ0XzEoY3R4LCBhcmdjLCBhcmd2LCBwcmVmaXgsIG9wdGlvbnMsIGZsYWdzKTsKfQoKc3RhdGljIHZvaWQgc2hvd19uZWdhdGVkX2dpdGNvbXAoY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0cywgaW50IHNob3dfYWxsLAoJCQkJIGludCBucl9ub29wdHMpCnsKCWludCBwcmludGVkX2Rhc2hkYXNoID0gMDsKCglmb3IgKDsgb3B0cy0+dHlwZSAhPSBPUFRJT05fRU5EOyBvcHRzKyspIHsKCQlpbnQgaGFzX3Vuc2V0X2Zvcm0gPSAwOwoJCWNvbnN0IGNoYXIgKm5hbWU7CgoJCWlmICghb3B0cy0+bG9uZ19uYW1lKQoJCQljb250aW51ZTsKCQlpZiAoIXNob3dfYWxsICYmCgkJCShvcHRzLT5mbGFncyAmIChQQVJTRV9PUFRfSElEREVOIHwgUEFSU0VfT1BUX05PQ09NUExFVEUpKSkKCQkJY29udGludWU7CgkJaWYgKG9wdHMtPmZsYWdzICYgUEFSU0VfT1BUX05PTkVHKQoJCQljb250aW51ZTsKCgkJc3dpdGNoIChvcHRzLT50eXBlKSB7CgkJY2FzZSBPUFRJT05fU1RSSU5HOgoJCWNhc2UgT1BUSU9OX0ZJTEVOQU1FOgoJCWNhc2UgT1BUSU9OX0lOVEVHRVI6CgkJY2FzZSBPUFRJT05fTUFHTklUVURFOgoJCWNhc2UgT1BUSU9OX0NBTExCQUNLOgoJCWNhc2UgT1BUSU9OX0JJVDoKCQljYXNlIE9QVElPTl9ORUdCSVQ6CgkJY2FzZSBPUFRJT05fQ09VTlRVUDoKCQljYXNlIE9QVElPTl9TRVRfSU5UOgoJCQloYXNfdW5zZXRfZm9ybSA9IDE7CgkJCWJyZWFrOwoJCWRlZmF1bHQ6CgkJCWJyZWFrOwoJCX0KCQlpZiAoIWhhc191bnNldF9mb3JtKQoJCQljb250aW51ZTsKCgkJaWYgKHNraXBfcHJlZml4KG9wdHMtPmxvbmdfbmFtZSwgIm5vLSIsICZuYW1lKSkgewoJCQlpZiAobnJfbm9vcHRzIDwgMCkKCQkJCXByaW50ZigiIC0tJXMiLCBuYW1lKTsKCQl9IGVsc2UgaWYgKG5yX25vb3B0cyA+PSAwKSB7CgkJCWlmIChucl9ub29wdHMgJiYgIXByaW50ZWRfZGFzaGRhc2gpIHsKCQkJCXByaW50ZigiIC0tIik7CgkJCQlwcmludGVkX2Rhc2hkYXNoID0gMTsKCQkJfQoJCQlwcmludGYoIiAtLW5vLSVzIiwgb3B0cy0+bG9uZ19uYW1lKTsKCQkJbnJfbm9vcHRzKys7CgkJfQoJfQp9CgpzdGF0aWMgaW50IHNob3dfZ2l0Y29tcChjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRzLCBpbnQgc2hvd19hbGwpCnsKCWNvbnN0IHN0cnVjdCBvcHRpb24gKm9yaWdpbmFsX29wdHMgPSBvcHRzOwoJaW50IG5yX25vb3B0cyA9IDA7CgoJZm9yICg7IG9wdHMtPnR5cGUgIT0gT1BUSU9OX0VORDsgb3B0cysrKSB7CgkJY29uc3QgY2hhciAqcHJlZml4ID0gIi0tIjsKCQljb25zdCBjaGFyICpzdWZmaXggPSAiIjsKCgkJaWYgKCFvcHRzLT5sb25nX25hbWUpCgkJCWNvbnRpbnVlOwoJCWlmICghc2hvd19hbGwgJiYKCQkJKG9wdHMtPmZsYWdzICYgKFBBUlNFX09QVF9ISURERU4gfCBQQVJTRV9PUFRfTk9DT01QTEVURSB8IFBBUlNFX09QVF9GUk9NX0FMSUFTKSkpCgkJCWNvbnRpbnVlOwoKCQlzd2l0Y2ggKG9wdHMtPnR5cGUpIHsKCQljYXNlIE9QVElPTl9TVUJDT01NQU5EOgoJCQlwcmVmaXggPSAiIjsKCQkJYnJlYWs7CgkJY2FzZSBPUFRJT05fR1JPVVA6CgkJCWNvbnRpbnVlOwoJCWNhc2UgT1BUSU9OX1NUUklORzoKCQljYXNlIE9QVElPTl9GSUxFTkFNRToKCQljYXNlIE9QVElPTl9JTlRFR0VSOgoJCWNhc2UgT1BUSU9OX01BR05JVFVERToKCQljYXNlIE9QVElPTl9DQUxMQkFDSzoKCQkJaWYgKG9wdHMtPmZsYWdzICYgUEFSU0VfT1BUX05PQVJHKQoJCQkJYnJlYWs7CgkJCWlmIChvcHRzLT5mbGFncyAmIFBBUlNFX09QVF9PUFRBUkcpCgkJCQlicmVhazsKCQkJaWYgKG9wdHMtPmZsYWdzICYgUEFSU0VfT1BUX0xBU1RBUkdfREVGQVVMVCkKCQkJCWJyZWFrOwoJCQlzdWZmaXggPSAiPSI7CgkJCWJyZWFrOwoJCWRlZmF1bHQ6CgkJCWJyZWFrOwoJCX0KCQlpZiAob3B0cy0+ZmxhZ3MgJiBQQVJTRV9PUFRfQ09NUF9BUkcpCgkJCXN1ZmZpeCA9ICI9IjsKCQlpZiAoc3RhcnRzX3dpdGgob3B0cy0+bG9uZ19uYW1lLCAibm8tIikpCgkJCW5yX25vb3B0cysrOwoJCXByaW50ZigiJXMlcyVzJXMiLCBvcHRzID09IG9yaWdpbmFsX29wdHMgPyAiIiA6ICIgIiwKCQkgICAgICAgcHJlZml4LCBvcHRzLT5sb25nX25hbWUsIHN1ZmZpeCk7Cgl9CglzaG93X25lZ2F0ZWRfZ2l0Y29tcChvcmlnaW5hbF9vcHRzLCBzaG93X2FsbCwgLTEpOwoJc2hvd19uZWdhdGVkX2dpdGNvbXAob3JpZ2luYWxfb3B0cywgc2hvd19hbGwsIG5yX25vb3B0cyk7CglmcHV0YygnXG4nLCBzdGRvdXQpOwoJcmV0dXJuIFBBUlNFX09QVF9DT01QTEVURTsKfQoKLyoKICogU2NhbiBhbmQgbWF5IHByb2R1Y2UgYSBuZXcgb3B0aW9uW10gYXJyYXksIHdoaWNoIHNob3VsZCBiZSB1c2VkCiAqIGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsICdvcHRpb25zJy4KICoKICogUmlnaHQgbm93IHRoaXMgaXMgb25seSB1c2VkIHRvIHByZXByb2Nlc3MgYW5kIHN1YnN0aXR1dGUKICogT1BUSU9OX0FMSUFTLgogKgogKiBUaGUgcmV0dXJuZWQgb3B0aW9ucyBzaG91bGQgYmUgZnJlZWQgdXNpbmcgZnJlZV9wcmVwcm9jZXNzZWRfb3B0aW9ucy4KICovCnN0YXRpYyBzdHJ1Y3Qgb3B0aW9uICpwcmVwcm9jZXNzX29wdGlvbnMoc3RydWN0IHBhcnNlX29wdF9jdHhfdCAqY3R4LAoJCQkJCSBjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRpb25zKQp7CglzdHJ1Y3Qgb3B0aW9uICpuZXdvcHQ7CglpbnQgaSwgbnIsIGFsaWFzOwoJaW50IG5yX2FsaWFzZXMgPSAwOwoKCWZvciAobnIgPSAwOyBvcHRpb25zW25yXS50eXBlICE9IE9QVElPTl9FTkQ7IG5yKyspIHsKCQlpZiAob3B0aW9uc1tucl0udHlwZSA9PSBPUFRJT05fQUxJQVMpCgkJCW5yX2FsaWFzZXMrKzsKCX0KCglpZiAoIW5yX2FsaWFzZXMpCgkJcmV0dXJuIE5VTEw7CgoJRFVQX0FSUkFZKG5ld29wdCwgb3B0aW9ucywgbnIgKyAxKTsKCgkvKiBlYWNoIGFsaWFzIGhhcyB0d28gc3RyaW5nIHBvaW50ZXJzIGFuZCBOVUxMICovCglDQUxMT0NfQVJSQVkoY3R4LT5hbGlhc19ncm91cHMsIDMgKiAobnJfYWxpYXNlcyArIDEpKTsKCglmb3IgKGFsaWFzID0gMCwgaSA9IDA7IGkgPCBucjsgaSsrKSB7CgkJaW50IHNob3J0X25hbWU7CgkJY29uc3QgY2hhciAqbG9uZ19uYW1lOwoJCWNvbnN0IGNoYXIgKnNvdXJjZTsKCQlzdHJ1Y3Qgc3RyYnVmIGhlbHAgPSBTVFJCVUZfSU5JVDsKCQlpbnQgajsKCgkJaWYgKG5ld29wdFtpXS50eXBlICE9IE9QVElPTl9BTElBUykKCQkJY29udGludWU7CgoJCXNob3J0X25hbWUgPSBuZXdvcHRbaV0uc2hvcnRfbmFtZTsKCQlsb25nX25hbWUgPSBuZXdvcHRbaV0ubG9uZ19uYW1lOwoJCXNvdXJjZSA9IG5ld29wdFtpXS52YWx1ZTsKCgkJaWYgKCFsb25nX25hbWUpCgkJCUJVRygiQW4gYWxpYXMgbXVzdCBoYXZlIGxvbmcgb3B0aW9uIG5hbWUiKTsKCQlzdHJidWZfYWRkZigmaGVscCwgXygiYWxpYXMgb2YgLS0lcyIpLCBzb3VyY2UpOwoKCQlmb3IgKGogPSAwOyBqIDwgbnI7IGorKykgewoJCQljb25zdCBjaGFyICpuYW1lID0gb3B0aW9uc1tqXS5sb25nX25hbWU7CgoJCQlpZiAoIW5hbWUgfHwgc3RyY21wKG5hbWUsIHNvdXJjZSkpCgkJCQljb250aW51ZTsKCgkJCWlmIChvcHRpb25zW2pdLnR5cGUgPT0gT1BUSU9OX0FMSUFTKQoJCQkJQlVHKCJObyBwbGVhc2UuIE5lc3RlZCBhbGlhc2VzIGFyZSBub3Qgc3VwcG9ydGVkLiIpOwoKCQkJbWVtY3B5KG5ld29wdCArIGksIG9wdGlvbnMgKyBqLCBzaXplb2YoKm5ld29wdCkpOwoJCQluZXdvcHRbaV0uc2hvcnRfbmFtZSA9IHNob3J0X25hbWU7CgkJCW5ld29wdFtpXS5sb25nX25hbWUgPSBsb25nX25hbWU7CgkJCW5ld29wdFtpXS5oZWxwID0gc3RyYnVmX2RldGFjaCgmaGVscCwgTlVMTCk7CgkJCW5ld29wdFtpXS5mbGFncyB8PSBQQVJTRV9PUFRfRlJPTV9BTElBUzsKCQkJYnJlYWs7CgkJfQoKCQlpZiAoaiA9PSBucikKCQkJQlVHKCJjb3VsZCBub3QgZmluZCBzb3VyY2Ugb3B0aW9uICclcycgb2YgYWxpYXMgJyVzJyIsCgkJCSAgICBzb3VyY2UsIG5ld29wdFtpXS5sb25nX25hbWUpOwoJCWN0eC0+YWxpYXNfZ3JvdXBzW2FsaWFzICogMyArIDBdID0gbmV3b3B0W2ldLmxvbmdfbmFtZTsKCQljdHgtPmFsaWFzX2dyb3Vwc1thbGlhcyAqIDMgKyAxXSA9IG9wdGlvbnNbal0ubG9uZ19uYW1lOwoJCWN0eC0+YWxpYXNfZ3JvdXBzW2FsaWFzICogMyArIDJdID0gTlVMTDsKCQlhbGlhcysrOwoJfQoKCXJldHVybiBuZXdvcHQ7Cn0KCnN0YXRpYyB2b2lkIGZyZWVfcHJlcHJvY2Vzc2VkX29wdGlvbnMoc3RydWN0IG9wdGlvbiAqb3B0aW9ucykKewoJaW50IGk7CgoJaWYgKCFvcHRpb25zKQoJCXJldHVybjsKCglmb3IgKGkgPSAwOyBvcHRpb25zW2ldLnR5cGUgIT0gT1BUSU9OX0VORDsgaSsrKSB7CgkJaWYgKG9wdGlvbnNbaV0uZmxhZ3MgJiBQQVJTRV9PUFRfRlJPTV9BTElBUykKCQkJZnJlZSgodm9pZCAqKW9wdGlvbnNbaV0uaGVscCk7Cgl9CglmcmVlKG9wdGlvbnMpOwp9CgpzdGF0aWMgZW51bSBwYXJzZV9vcHRfcmVzdWx0IHVzYWdlX3dpdGhfb3B0aW9uc19pbnRlcm5hbChzdHJ1Y3QgcGFyc2Vfb3B0X2N0eF90ICosCgkJCQkJCQkgY29uc3QgY2hhciAqIGNvbnN0ICosCgkJCQkJCQkgY29uc3Qgc3RydWN0IG9wdGlvbiAqLAoJCQkJCQkJIGludCwgaW50KTsKCmVudW0gcGFyc2Vfb3B0X3Jlc3VsdCBwYXJzZV9vcHRpb25zX3N0ZXAoc3RydWN0IHBhcnNlX29wdF9jdHhfdCAqY3R4LAoJCQkJCSBjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRpb25zLAoJCQkJCSBjb25zdCBjaGFyICogY29uc3QgdXNhZ2VzdHJbXSkKewoJaW50IGludGVybmFsX2hlbHAgPSAhKGN0eC0+ZmxhZ3MgJiBQQVJTRV9PUFRfTk9fSU5URVJOQUxfSEVMUCk7CgoJLyogd2UgbXVzdCByZXNldCAtPm9wdCwgdW5rbm93biBzaG9ydCBvcHRpb24gbGVhdmUgaXQgZGFuZ2xpbmcgKi8KCWN0eC0+b3B0ID0gTlVMTDsKCglmb3IgKDsgY3R4LT5hcmdjOyBjdHgtPmFyZ2MtLSwgY3R4LT5hcmd2KyspIHsKCQljb25zdCBjaGFyICphcmcgPSBjdHgtPmFyZ3ZbMF07CgoJCWlmIChjdHgtPmZsYWdzICYgUEFSU0VfT1BUX09ORV9TSE9UICYmCgkJICAgIGN0eC0+YXJnYyAhPSBjdHgtPnRvdGFsKQoJCQlicmVhazsKCgkJaWYgKCphcmcgIT0gJy0nIHx8ICFhcmdbMV0pIHsKCQkJaWYgKHBhcnNlX25vZGFzaF9vcHQoY3R4LCBhcmcsIG9wdGlvbnMpID09IDApCgkJCQljb250aW51ZTsKCQkJaWYgKCFjdHgtPmhhc19zdWJjb21tYW5kcykgewoJCQkJaWYgKGN0eC0+ZmxhZ3MgJiBQQVJTRV9PUFRfU1RPUF9BVF9OT05fT1BUSU9OKQoJCQkJCXJldHVybiBQQVJTRV9PUFRfTk9OX09QVElPTjsKCQkJCWN0eC0+b3V0W2N0eC0+Y3BpZHgrK10gPSBjdHgtPmFyZ3ZbMF07CgkJCQljb250aW51ZTsKCQkJfQoJCQlzd2l0Y2ggKHBhcnNlX3N1YmNvbW1hbmQoYXJnLCBvcHRpb25zKSkgewoJCQljYXNlIFBBUlNFX09QVF9TVUJDT01NQU5EOgoJCQkJcmV0dXJuIFBBUlNFX09QVF9TVUJDT01NQU5EOwoJCQljYXNlIFBBUlNFX09QVF9VTktOT1dOOgoJCQkJaWYgKGN0eC0+ZmxhZ3MgJiBQQVJTRV9PUFRfU1VCQ09NTUFORF9PUFRJT05BTCkKCQkJCQkvKgoJCQkJCSAqIGFyZyBpcyBuZWl0aGVyIGEgc2hvcnQgb3IgbG9uZwoJCQkJCSAqIG9wdGlvbiBub3IgYSBzdWJjb21tYW5kLiAgU2luY2UKCQkJCQkgKiB0aGlzIGNvbW1hbmQgaGFzIGEgZGVmYXVsdAoJCQkJCSAqIG9wZXJhdGlvbiBtb2RlLCB3ZSBoYXZlIHRvIHRyZWF0CgkJCQkJICogdGhpcyBhcmcgYW5kIGFsbCByZW1haW5pbmcgYXJncwoJCQkJCSAqIGFzIGFyZ3MgbWVhbnQgdG8gdGhhdCBkZWZhdWx0CgkJCQkJICogb3BlcmF0aW9uIG1vZGUuCgkJCQkJICogU28gd2UgYXJlIGRvbmUgcGFyc2luZy4KCQkJCQkgKi8KCQkJCQlyZXR1cm4gUEFSU0VfT1BUX0RPTkU7CgkJCQllcnJvcihfKCJ1bmtub3duIHN1YmNvbW1hbmQ6IGAlcyciKSwgYXJnKTsKCQkJCXVzYWdlX3dpdGhfb3B0aW9ucyh1c2FnZXN0ciwgb3B0aW9ucyk7CgkJCWNhc2UgUEFSU0VfT1BUX0NPTVBMRVRFOgoJCQljYXNlIFBBUlNFX09QVF9IRUxQOgoJCQljYXNlIFBBUlNFX09QVF9FUlJPUjoKCQkJY2FzZSBQQVJTRV9PUFRfRE9ORToKCQkJY2FzZSBQQVJTRV9PUFRfTk9OX09QVElPTjoKCQkJCS8qIEltcG9zc2libGUuICovCgkJCQlCVUcoInBhcnNlX3N1YmNvbW1hbmQoKSBjYW5ub3QgcmV0dXJuIHRoZXNlIik7CgkJCX0KCQl9CgoJCS8qIGxvbmUgLWggYXNrcyBmb3IgaGVscCAqLwoJCWlmIChpbnRlcm5hbF9oZWxwICYmIGN0eC0+dG90YWwgPT0gMSAmJiAhc3RyY21wKGFyZyArIDEsICJoIikpCgkJCWdvdG8gc2hvd191c2FnZTsKCgkJLyoKCQkgKiBsb25lIC0tZ2l0LWNvbXBsZXRpb24taGVscGVyIGFuZCAtLWdpdC1jb21wbGV0aW9uLWhlbHBlci1hbGwKCQkgKiBhcmUgYXNrZWQgYnkgZ2l0LWNvbXBsZXRpb24uYmFzaAoJCSAqLwoJCWlmIChjdHgtPnRvdGFsID09IDEgJiYgIXN0cmNtcChhcmcsICItLWdpdC1jb21wbGV0aW9uLWhlbHBlciIpKQoJCQlyZXR1cm4gc2hvd19naXRjb21wKG9wdGlvbnMsIDApOwoJCWlmIChjdHgtPnRvdGFsID09IDEgJiYgIXN0cmNtcChhcmcsICItLWdpdC1jb21wbGV0aW9uLWhlbHBlci1hbGwiKSkKCQkJcmV0dXJuIHNob3dfZ2l0Y29tcChvcHRpb25zLCAxKTsKCgkJaWYgKGFyZ1sxXSAhPSAnLScpIHsKCQkJY3R4LT5vcHQgPSBhcmcgKyAxOwoJCQlzd2l0Y2ggKHBhcnNlX3Nob3J0X29wdChjdHgsIG9wdGlvbnMpKSB7CgkJCWNhc2UgUEFSU0VfT1BUX0VSUk9SOgoJCQkJcmV0dXJuIFBBUlNFX09QVF9FUlJPUjsKCQkJY2FzZSBQQVJTRV9PUFRfVU5LTk9XTjoKCQkJCWlmIChjdHgtPm9wdCkKCQkJCQljaGVja190eXBvcyhhcmcgKyAxLCBvcHRpb25zKTsKCQkJCWlmIChpbnRlcm5hbF9oZWxwICYmICpjdHgtPm9wdCA9PSAnaCcpCgkJCQkJZ290byBzaG93X3VzYWdlOwoJCQkJZ290byB1bmtub3duOwoJCQljYXNlIFBBUlNFX09QVF9OT05fT1BUSU9OOgoJCQljYXNlIFBBUlNFX09QVF9TVUJDT01NQU5EOgoJCQljYXNlIFBBUlNFX09QVF9IRUxQOgoJCQljYXNlIFBBUlNFX09QVF9DT01QTEVURToKCQkJCUJVRygicGFyc2Vfc2hvcnRfb3B0KCkgY2Fubm90IHJldHVybiB0aGVzZSIpOwoJCQljYXNlIFBBUlNFX09QVF9ET05FOgoJCQkJYnJlYWs7CgkJCX0KCQkJaWYgKGN0eC0+b3B0KQoJCQkJY2hlY2tfdHlwb3MoYXJnICsgMSwgb3B0aW9ucyk7CgkJCXdoaWxlIChjdHgtPm9wdCkgewoJCQkJc3dpdGNoIChwYXJzZV9zaG9ydF9vcHQoY3R4LCBvcHRpb25zKSkgewoJCQkJY2FzZSBQQVJTRV9PUFRfRVJST1I6CgkJCQkJcmV0dXJuIFBBUlNFX09QVF9FUlJPUjsKCQkJCWNhc2UgUEFSU0VfT1BUX1VOS05PV046CgkJCQkJaWYgKGludGVybmFsX2hlbHAgJiYgKmN0eC0+b3B0ID09ICdoJykKCQkJCQkJZ290byBzaG93X3VzYWdlOwoKCQkJCQkvKiBmYWtlIGEgc2hvcnQgb3B0aW9uIHRoaW5nIHRvIGhpZGUgdGhlIGZhY3QgdGhhdCB3ZSBtYXkgaGF2ZQoJCQkJCSAqIHN0YXJ0ZWQgdG8gcGFyc2UgYWdncmVnYXRlZCBzdHVmZgoJCQkJCSAqCgkJCQkJICogVGhpcyBpcyBsZWFreSwgdG9vIGJhZC4KCQkJCQkgKi8KCQkJCQljdHgtPmFyZ3ZbMF0gPSB4c3RyZHVwKGN0eC0+b3B0IC0gMSk7CgkJCQkJKihjaGFyICopY3R4LT5hcmd2WzBdID0gJy0nOwoJCQkJCWdvdG8gdW5rbm93bjsKCQkJCWNhc2UgUEFSU0VfT1BUX05PTl9PUFRJT046CgkJCQljYXNlIFBBUlNFX09QVF9TVUJDT01NQU5EOgoJCQkJY2FzZSBQQVJTRV9PUFRfQ09NUExFVEU6CgkJCQljYXNlIFBBUlNFX09QVF9IRUxQOgoJCQkJCUJVRygicGFyc2Vfc2hvcnRfb3B0KCkgY2Fubm90IHJldHVybiB0aGVzZSIpOwoJCQkJY2FzZSBQQVJTRV9PUFRfRE9ORToKCQkJCQlicmVhazsKCQkJCX0KCQkJfQoJCQljb250aW51ZTsKCQl9CgoJCWlmICghYXJnWzJdIC8qICItLSIgKi8pIHsKCQkJaWYgKCEoY3R4LT5mbGFncyAmIFBBUlNFX09QVF9LRUVQX0RBU0hEQVNIKSkgewoJCQkJY3R4LT5hcmdjLS07CgkJCQljdHgtPmFyZ3YrKzsKCQkJfQoJCQlicmVhazsKCQl9IGVsc2UgaWYgKCFzdHJjbXAoYXJnICsgMiwgImVuZC1vZi1vcHRpb25zIikpIHsKCQkJaWYgKCEoY3R4LT5mbGFncyAmIFBBUlNFX09QVF9LRUVQX1VOS05PV05fT1BUKSkgewoJCQkJY3R4LT5hcmdjLS07CgkJCQljdHgtPmFyZ3YrKzsKCQkJfQoJCQlicmVhazsKCQl9CgoJCWlmIChpbnRlcm5hbF9oZWxwICYmICFzdHJjbXAoYXJnICsgMiwgImhlbHAtYWxsIikpCgkJCXJldHVybiB1c2FnZV93aXRoX29wdGlvbnNfaW50ZXJuYWwoY3R4LCB1c2FnZXN0ciwgb3B0aW9ucywgMSwgMCk7CgkJaWYgKGludGVybmFsX2hlbHAgJiYgIXN0cmNtcChhcmcgKyAyLCAiaGVscCIpKQoJCQlnb3RvIHNob3dfdXNhZ2U7CgkJc3dpdGNoIChwYXJzZV9sb25nX29wdChjdHgsIGFyZyArIDIsIG9wdGlvbnMpKSB7CgkJY2FzZSBQQVJTRV9PUFRfRVJST1I6CgkJCXJldHVybiBQQVJTRV9PUFRfRVJST1I7CgkJY2FzZSBQQVJTRV9PUFRfVU5LTk9XTjoKCQkJZ290byB1bmtub3duOwoJCWNhc2UgUEFSU0VfT1BUX0hFTFA6CgkJCWdvdG8gc2hvd191c2FnZTsKCQljYXNlIFBBUlNFX09QVF9OT05fT1BUSU9OOgoJCWNhc2UgUEFSU0VfT1BUX1NVQkNPTU1BTkQ6CgkJY2FzZSBQQVJTRV9PUFRfQ09NUExFVEU6CgkJCUJVRygicGFyc2VfbG9uZ19vcHQoKSBjYW5ub3QgcmV0dXJuIHRoZXNlIik7CgkJY2FzZSBQQVJTRV9PUFRfRE9ORToKCQkJYnJlYWs7CgkJfQoJCWNvbnRpbnVlOwp1bmtub3duOgoJCWlmIChjdHgtPmZsYWdzICYgUEFSU0VfT1BUX09ORV9TSE9UKQoJCQlicmVhazsKCQlpZiAoY3R4LT5oYXNfc3ViY29tbWFuZHMgJiYKCQkgICAgKGN0eC0+ZmxhZ3MgJiBQQVJTRV9PUFRfU1VCQ09NTUFORF9PUFRJT05BTCkgJiYKCQkgICAgKGN0eC0+ZmxhZ3MgJiBQQVJTRV9PUFRfS0VFUF9VTktOT1dOX09QVCkpIHsKCQkJLyoKCQkJICogRm91bmQgYW4gdW5rbm93biBvcHRpb24gZ2l2ZW4gdG8gYSBjb21tYW5kIHdpdGgKCQkJICogc3ViY29tbWFuZHMgdGhhdCBoYXMgYSBkZWZhdWx0IG9wZXJhdGlvbiBtb2RlOgoJCQkgKiB3ZSB0cmVhdCB0aGlzIG9wdGlvbiBhbmQgYWxsIHJlbWFpbmluZyBhcmdzIGFzCgkJCSAqIGFyZ3VtZW50cyBtZWFudCB0byB0aGF0IGRlZmF1bHQgb3BlcmF0aW9uIG1vZGUuCgkJCSAqIFNvIHdlIGFyZSBkb25lIHBhcnNpbmcuCgkJCSAqLwoJCQlyZXR1cm4gUEFSU0VfT1BUX0RPTkU7CgkJfQoJCWlmICghKGN0eC0+ZmxhZ3MgJiBQQVJTRV9PUFRfS0VFUF9VTktOT1dOX09QVCkpCgkJCXJldHVybiBQQVJTRV9PUFRfVU5LTk9XTjsKCQljdHgtPm91dFtjdHgtPmNwaWR4KytdID0gY3R4LT5hcmd2WzBdOwoJCWN0eC0+b3B0ID0gTlVMTDsKCX0KCXJldHVybiBQQVJTRV9PUFRfRE9ORTsKCiBzaG93X3VzYWdlOgoJcmV0dXJuIHVzYWdlX3dpdGhfb3B0aW9uc19pbnRlcm5hbChjdHgsIHVzYWdlc3RyLCBvcHRpb25zLCAwLCAwKTsKfQoKaW50IHBhcnNlX29wdGlvbnNfZW5kKHN0cnVjdCBwYXJzZV9vcHRfY3R4X3QgKmN0eCkKewoJaWYgKGN0eC0+ZmxhZ3MgJiBQQVJTRV9PUFRfT05FX1NIT1QpCgkJcmV0dXJuIGN0eC0+dG90YWwgLSBjdHgtPmFyZ2M7CgoJTU9WRV9BUlJBWShjdHgtPm91dCArIGN0eC0+Y3BpZHgsIGN0eC0+YXJndiwgY3R4LT5hcmdjKTsKCWN0eC0+b3V0W2N0eC0+Y3BpZHggKyBjdHgtPmFyZ2NdID0gTlVMTDsKCXJldHVybiBjdHgtPmNwaWR4ICsgY3R4LT5hcmdjOwp9CgppbnQgcGFyc2Vfb3B0aW9ucyhpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsCgkJICBjb25zdCBjaGFyICpwcmVmaXgsCgkJICBjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRpb25zLAoJCSAgY29uc3QgY2hhciAqIGNvbnN0IHVzYWdlc3RyW10sCgkJICBlbnVtIHBhcnNlX29wdF9mbGFncyBmbGFncykKewoJc3RydWN0IHBhcnNlX29wdF9jdHhfdCBjdHg7CglzdHJ1Y3Qgb3B0aW9uICpyZWFsX29wdGlvbnM7CgoJZGlzYWxsb3dfYWJicmV2aWF0ZWRfb3B0aW9ucyA9CgkJZ2l0X2Vudl9ib29sKCJHSVRfVEVTVF9ESVNBTExPV19BQkJSRVZJQVRFRF9PUFRJT05TIiwgMCk7CgoJbWVtc2V0KCZjdHgsIDAsIHNpemVvZihjdHgpKTsKCXJlYWxfb3B0aW9ucyA9IHByZXByb2Nlc3Nfb3B0aW9ucygmY3R4LCBvcHRpb25zKTsKCWlmIChyZWFsX29wdGlvbnMpCgkJb3B0aW9ucyA9IHJlYWxfb3B0aW9uczsKCXBhcnNlX29wdGlvbnNfc3RhcnRfMSgmY3R4LCBhcmdjLCBhcmd2LCBwcmVmaXgsIG9wdGlvbnMsIGZsYWdzKTsKCXN3aXRjaCAocGFyc2Vfb3B0aW9uc19zdGVwKCZjdHgsIG9wdGlvbnMsIHVzYWdlc3RyKSkgewoJY2FzZSBQQVJTRV9PUFRfSEVMUDoKCWNhc2UgUEFSU0VfT1BUX0VSUk9SOgoJCWV4aXQoMTI5KTsKCWNhc2UgUEFSU0VfT1BUX0NPTVBMRVRFOgoJCWV4aXQoMCk7CgljYXNlIFBBUlNFX09QVF9OT05fT1BUSU9OOgoJY2FzZSBQQVJTRV9PUFRfU1VCQ09NTUFORDoKCQlicmVhazsKCWNhc2UgUEFSU0VfT1BUX0RPTkU6CgkJaWYgKGN0eC5oYXNfc3ViY29tbWFuZHMgJiYKCQkgICAgIShmbGFncyAmIFBBUlNFX09QVF9TVUJDT01NQU5EX09QVElPTkFMKSkgewoJCQllcnJvcihfKCJuZWVkIGEgc3ViY29tbWFuZCIpKTsKCQkJdXNhZ2Vfd2l0aF9vcHRpb25zKHVzYWdlc3RyLCBvcHRpb25zKTsKCQl9CgkJYnJlYWs7CgljYXNlIFBBUlNFX09QVF9VTktOT1dOOgoJCWlmIChjdHguYXJndlswXVsxXSA9PSAnLScpIHsKCQkJZXJyb3IoXygidW5rbm93biBvcHRpb24gYCVzJyIpLCBjdHguYXJndlswXSArIDIpOwoJCX0gZWxzZSBpZiAoaXNhc2NpaSgqY3R4Lm9wdCkpIHsKCQkJZXJyb3IoXygidW5rbm93biBzd2l0Y2ggYCVjJyIpLCAqY3R4Lm9wdCk7CgkJfSBlbHNlIHsKCQkJZXJyb3IoXygidW5rbm93biBub24tYXNjaWkgb3B0aW9uIGluIHN0cmluZzogYCVzJyIpLAoJCQkgICAgICBjdHguYXJndlswXSk7CgkJfQoJCXVzYWdlX3dpdGhfb3B0aW9ucyh1c2FnZXN0ciwgb3B0aW9ucyk7Cgl9CgoJcHJlY29tcG9zZV9hcmd2X3ByZWZpeChhcmdjLCBhcmd2LCBOVUxMKTsKCWZyZWVfcHJlcHJvY2Vzc2VkX29wdGlvbnMocmVhbF9vcHRpb25zKTsKCWZyZWUoY3R4LmFsaWFzX2dyb3Vwcyk7Cglmb3IgKHN0cnVjdCBwYXJzZV9vcHRfY21kbW9kZV9saXN0ICplbGVtID0gY3R4LmNtZG1vZGVfbGlzdDsgZWxlbTspIHsKCQlzdHJ1Y3QgcGFyc2Vfb3B0X2NtZG1vZGVfbGlzdCAqbmV4dCA9IGVsZW0tPm5leHQ7CgkJZnJlZShlbGVtKTsKCQllbGVtID0gbmV4dDsKCX0KCXJldHVybiBwYXJzZV9vcHRpb25zX2VuZCgmY3R4KTsKfQoKc3RhdGljIGludCB1c2FnZV9hcmdoKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdHMsIEZJTEUgKm91dGZpbGUpCnsKCWNvbnN0IGNoYXIgKnM7CglpbnQgbGl0ZXJhbCA9IChvcHRzLT5mbGFncyAmIFBBUlNFX09QVF9MSVRFUkFMX0FSR0hFTFApIHx8CgkJIW9wdHMtPmFyZ2ggfHwgISFzdHJwYnJrKG9wdHMtPmFyZ2gsICIoKTw+W118Iik7CglpZiAob3B0cy0+ZmxhZ3MgJiBQQVJTRV9PUFRfT1BUQVJHKQoJCWlmIChvcHRzLT5sb25nX25hbWUpCgkJCXMgPSBsaXRlcmFsID8gIls9JXNdIiA6ICJbPTwlcz5dIjsKCQllbHNlCgkJCXMgPSBsaXRlcmFsID8gIlslc10iIDogIls8JXM+XSI7CgllbHNlCgkJcyA9IGxpdGVyYWwgPyAiICVzIiA6ICIgPCVzPiI7CglyZXR1cm4gdXRmOF9mcHJpbnRmKG91dGZpbGUsIHMsIG9wdHMtPmFyZ2ggPyBfKG9wdHMtPmFyZ2gpIDogXygiLi4uIikpOwp9CgpzdGF0aWMgaW50IHVzYWdlX2luZGVudChGSUxFICpvdXRmaWxlKQp7CglyZXR1cm4gZnByaW50ZihvdXRmaWxlLCAiICAgICIpOwp9CgojZGVmaW5lIFVTQUdFX09QVFNfV0lEVEggMjYKCnN0YXRpYyB2b2lkIHVzYWdlX3BhZGRpbmcoRklMRSAqb3V0ZmlsZSwgc2l6ZV90IHBvcykKewoJaWYgKHBvcyA8IFVTQUdFX09QVFNfV0lEVEgpCgkJZnByaW50ZihvdXRmaWxlLCAiJSpzIiwgVVNBR0VfT1BUU19XSURUSCAtIChpbnQpcG9zLCAiIik7CgllbHNlCgkJZnByaW50ZihvdXRmaWxlLCAiXG4lKnMiLCBVU0FHRV9PUFRTX1dJRFRILCAiIik7Cn0KCnN0YXRpYyBjb25zdCBzdHJ1Y3Qgb3B0aW9uICpmaW5kX29wdGlvbl9ieV9sb25nX25hbWUoY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0cywKCQkJCQkJICAgICBjb25zdCBjaGFyICpsb25nX25hbWUpCnsKCWZvciAoOyBvcHRzLT50eXBlICE9IE9QVElPTl9FTkQ7IG9wdHMrKykgewoJCWlmIChvcHRzLT5sb25nX25hbWUgJiYgIXN0cmNtcChvcHRzLT5sb25nX25hbWUsIGxvbmdfbmFtZSkpCgkJCXJldHVybiBvcHRzOwoJfQoJcmV0dXJuIE5VTEw7Cn0KCnN0YXRpYyBlbnVtIHBhcnNlX29wdF9yZXN1bHQgdXNhZ2Vfd2l0aF9vcHRpb25zX2ludGVybmFsKHN0cnVjdCBwYXJzZV9vcHRfY3R4X3QgKmN0eCwKCQkJCQkJCSBjb25zdCBjaGFyICogY29uc3QgKnVzYWdlc3RyLAoJCQkJCQkJIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdHMsCgkJCQkJCQkgaW50IGZ1bGwsIGludCBlcnIpCnsKCWNvbnN0IHN0cnVjdCBvcHRpb24gKmFsbF9vcHRzID0gb3B0czsKCUZJTEUgKm91dGZpbGUgPSBlcnIgPyBzdGRlcnIgOiBzdGRvdXQ7CglpbnQgbmVlZF9uZXdsaW5lOwoKCWNvbnN0IGNoYXIgKnVzYWdlX3ByZWZpeCA9IF8oInVzYWdlOiAlcyIpOwoJLyoKCSAqIFRoZSB0cmFuc2xhdGlvbiBjb3VsZCBiZSBhbnl0aGluZywgYnV0IHdlIGNhbiBjb3VudCBvbgoJICogbXNnZm10KDEpJ3MgLS1jaGVjayBvcHRpb24gdG8gaGF2ZSBhc3NlcnRlZCB0aGF0ICIlcyIgaXMgaW4KCSAqIHRoZSB0cmFuc2xhdGlvbi4gU28gY29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSAidXNhZ2U6ICIKCSAqIHBhcnQuIFdlIGFyZSBhc3N1bWluZyB0aGF0IHRoZSB0cmFuc2xhdG9yIHdhc24ndCBvdmVybHkKCSAqIGNsZXZlciBhbmQgdXNlZCBlLmcuICIlMSRzIiBpbnN0ZWFkIG9mICIlcyIsIHRoZXJlJ3Mgb25seQoJICogb25lICIlcyIgaW4gInVzYWdlX3ByZWZpeCIgYWJvdmUsIHNvIHRoZXJlJ3Mgbm8gcmVhc29uIHRvCgkgKiBkbyBzbyBldmVuIHdpdGggYSBSVEwgbGFuZ3VhZ2UuCgkgKi8KCXNpemVfdCB1c2FnZV9sZW4gPSBzdHJsZW4odXNhZ2VfcHJlZml4KSAtIHN0cmxlbigiJXMiKTsKCS8qCgkgKiBUUkFOU0xBVE9SUzogdGhlIGNvbG9uIGhlcmUgc2hvdWxkIGFsaWduIHdpdGggdGhlCgkgKiBvbmUgaW4gInVzYWdlOiAlcyIgdHJhbnNsYXRpb24uCgkgKi8KCWNvbnN0IGNoYXIgKm9yX3ByZWZpeCA9IF8oIiAgIG9yOiAlcyIpOwoJLyoKCSAqIFRSQU5TTEFUT1JTOiBZb3Ugc2hvdWxkIG9ubHkgbmVlZCB0byB0cmFuc2xhdGUgdGhpcyBmb3JtYXQKCSAqIHN0cmluZyBpZiB5b3VyIGxhbmd1YWdlIGlzIGEgUlRMIGxhbmd1YWdlIChlLmcuIEFyYWJpYywKCSAqIEhlYnJldyBldGMuKSwgbm90IGlmIGl0J3MgYSBMVFIgbGFuZ3VhZ2UgKGUuZy4gR2VybWFuLAoJICogUnVzc2lhbiwgQ2hpbmVzZSBldGMuKS4KCSAqCgkgKiBXaGVuIGEgdHJhbnNsYXRlZCB1c2FnZSBzdHJpbmcgaGFzIGFuIGVtYmVkZGVkICJcbiIgaXQncwoJICogYmVjYXVzZSBvcHRpb25zIGhhdmUgd3JhcHBlZCB0byB0aGUgbmV4dCBsaW5lLiBUaGUgbGluZQoJICogYWZ0ZXIgdGhlICJcbiIgd2lsbCB0aGVuIGJlIHBhZGRlZCB0byBhbGlnbiB3aXRoIHRoZQoJICogY29tbWFuZCBuYW1lLCBzdWNoIGFzIE5fKCJnaXQgY21kIFtvcHRdXG48OAoJICogc3BhY2VzPltvcHQyXSIpLCB3aGVyZSB0aGUgOCBzcGFjZXMgYXJlIHRoZSBzYW1lIGxlbmd0aCBhcwoJICogImdpdCBjbWQgIi4KCSAqCgkgKiBUaGlzIGZvcm1hdCBzdHJpbmcgcHJpbnRzIG91dCB0aGF0IGFscmVhZHktdHJhbnNsYXRlZAoJICogbGluZS4gVGhlICIlKnMiIGlzIHdoaXRlc3BhY2UgcGFkZGluZyB0byBhY2NvdW50IGZvciB0aGUKCSAqIHBhZGRpbmcgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lIHRoYXQgd2UgYWRkIGluIHRoaXMKCSAqIGZ1bmN0aW9uLiBUaGUgIiVzIiBpcyBhIGxpbmUgaW4gdGhlIChob3BlZnVsbHkgYWxyZWFkeQoJICogdHJhbnNsYXRlZCkgTl8oKSB1c2FnZSBzdHJpbmcsIHdoaWNoIGNvbnRhaW5lZCBlbWJlZGRlZAoJICogbmV3bGluZXMgYmVmb3JlIHdlIHNwbGl0IGl0IHVwLgoJICovCgljb25zdCBjaGFyICp1c2FnZV9jb250aW51ZWQgPSBfKCIlKnMlcyIpOwoJY29uc3QgY2hhciAqcHJlZml4ID0gdXNhZ2VfcHJlZml4OwoJaW50IHNhd19lbXB0eV9saW5lID0gMDsKCglpZiAoIXVzYWdlc3RyKQoJCXJldHVybiBQQVJTRV9PUFRfSEVMUDsKCglpZiAoIWVyciAmJiBjdHggJiYgY3R4LT5mbGFncyAmIFBBUlNFX09QVF9TSEVMTF9FVkFMKQoJCWZwcmludGYob3V0ZmlsZSwgImNhdCA8PFxcRU9GXG4iKTsKCgl3aGlsZSAoKnVzYWdlc3RyKSB7CgkJY29uc3QgY2hhciAqc3RyID0gXygqdXNhZ2VzdHIrKyk7CgkJc3RydWN0IHN0cmluZ19saXN0IGxpc3QgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCQl1bnNpZ25lZCBpbnQgajsKCgkJaWYgKCFzYXdfZW1wdHlfbGluZSAmJiAhKnN0cikKCQkJc2F3X2VtcHR5X2xpbmUgPSAxOwoKCQlzdHJpbmdfbGlzdF9zcGxpdCgmbGlzdCwgc3RyLCAnXG4nLCAtMSk7CgkJZm9yIChqID0gMDsgaiA8IGxpc3QubnI7IGorKykgewoJCQljb25zdCBjaGFyICpsaW5lID0gbGlzdC5pdGVtc1tqXS5zdHJpbmc7CgoJCQlpZiAoc2F3X2VtcHR5X2xpbmUgJiYgKmxpbmUpCgkJCQlmcHJpbnRmX2xuKG91dGZpbGUsIF8oIiAgICAlcyIpLCBsaW5lKTsKCQkJZWxzZSBpZiAoc2F3X2VtcHR5X2xpbmUpCgkJCQlmcHV0YygnXG4nLCBvdXRmaWxlKTsKCQkJZWxzZSBpZiAoIWopCgkJCQlmcHJpbnRmX2xuKG91dGZpbGUsIHByZWZpeCwgbGluZSk7CgkJCWVsc2UKCQkJCWZwcmludGZfbG4ob3V0ZmlsZSwgdXNhZ2VfY29udGludWVkLAoJCQkJCSAgIChpbnQpdXNhZ2VfbGVuLCAiIiwgbGluZSk7CgkJfQoJCXN0cmluZ19saXN0X2NsZWFyKCZsaXN0LCAwKTsKCgkJcHJlZml4ID0gb3JfcHJlZml4OwoJfQoKCW5lZWRfbmV3bGluZSA9IDE7CgoJZm9yICg7IG9wdHMtPnR5cGUgIT0gT1BUSU9OX0VORDsgb3B0cysrKSB7CgkJc2l6ZV90IHBvczsKCQljb25zdCBjaGFyICpjcCwgKm5wOwoJCWNvbnN0IGNoYXIgKnBvc2l0aXZlX25hbWUgPSBOVUxMOwoKCQlpZiAob3B0cy0+dHlwZSA9PSBPUFRJT05fU1VCQ09NTUFORCkKCQkJY29udGludWU7CgkJaWYgKG9wdHMtPnR5cGUgPT0gT1BUSU9OX0dST1VQKSB7CgkJCWZwdXRjKCdcbicsIG91dGZpbGUpOwoJCQluZWVkX25ld2xpbmUgPSAwOwoJCQlpZiAoKm9wdHMtPmhlbHApCgkJCQlmcHJpbnRmKG91dGZpbGUsICIlc1xuIiwgXyhvcHRzLT5oZWxwKSk7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoIWZ1bGwgJiYgKG9wdHMtPmZsYWdzICYgUEFSU0VfT1BUX0hJRERFTikpCgkJCWNvbnRpbnVlOwoKCQlpZiAobmVlZF9uZXdsaW5lKSB7CgkJCWZwdXRjKCdcbicsIG91dGZpbGUpOwoJCQluZWVkX25ld2xpbmUgPSAwOwoJCX0KCgkJcG9zID0gdXNhZ2VfaW5kZW50KG91dGZpbGUpOwoJCWlmIChvcHRzLT5zaG9ydF9uYW1lKSB7CgkJCWlmIChvcHRzLT5mbGFncyAmIFBBUlNFX09QVF9OT0RBU0gpCgkJCQlwb3MgKz0gZnByaW50ZihvdXRmaWxlLCAiJWMiLCBvcHRzLT5zaG9ydF9uYW1lKTsKCQkJZWxzZQoJCQkJcG9zICs9IGZwcmludGYob3V0ZmlsZSwgIi0lYyIsIG9wdHMtPnNob3J0X25hbWUpOwoJCX0KCQlpZiAob3B0cy0+bG9uZ19uYW1lICYmIG9wdHMtPnNob3J0X25hbWUpCgkJCXBvcyArPSBmcHJpbnRmKG91dGZpbGUsICIsICIpOwoJCWlmIChvcHRzLT5sb25nX25hbWUpIHsKCQkJY29uc3QgY2hhciAqbG9uZ19uYW1lID0gb3B0cy0+bG9uZ19uYW1lOwoJCQlpZiAoKG9wdHMtPmZsYWdzICYgUEFSU0VfT1BUX05PTkVHKSB8fAoJCQkgICAgc2tpcF9wcmVmaXgobG9uZ19uYW1lLCAibm8tIiwgJnBvc2l0aXZlX25hbWUpKQoJCQkJcG9zICs9IGZwcmludGYob3V0ZmlsZSwgIi0tJXMiLCBsb25nX25hbWUpOwoJCQllbHNlCgkJCQlwb3MgKz0gZnByaW50ZihvdXRmaWxlLCAiLS1bbm8tXSVzIiwgbG9uZ19uYW1lKTsKCQl9CgoJCWlmIChvcHRzLT50eXBlID09IE9QVElPTl9OVU1CRVIpCgkJCXBvcyArPSB1dGY4X2ZwcmludGYob3V0ZmlsZSwgXygiLU5VTSIpKTsKCgkJaWYgKChvcHRzLT5mbGFncyAmIFBBUlNFX09QVF9MSVRFUkFMX0FSR0hFTFApIHx8CgkJICAgICEob3B0cy0+ZmxhZ3MgJiBQQVJTRV9PUFRfTk9BUkcpKQoJCQlwb3MgKz0gdXNhZ2VfYXJnaChvcHRzLCBvdXRmaWxlKTsKCgkJaWYgKG9wdHMtPnR5cGUgPT0gT1BUSU9OX0FMSUFTKSB7CgkJCXVzYWdlX3BhZGRpbmcob3V0ZmlsZSwgcG9zKTsKCQkJZnByaW50Zl9sbihvdXRmaWxlLCBfKCJhbGlhcyBvZiAtLSVzIiksCgkJCQkgICAoY29uc3QgY2hhciAqKW9wdHMtPnZhbHVlKTsKCQkJY29udGludWU7CgkJfQoKCQlmb3IgKGNwID0gb3B0cy0+aGVscCA/IF8ob3B0cy0+aGVscCkgOiAiIjsgKmNwOyBjcCA9IG5wKSB7CgkJCW5wID0gc3RyY2hybnVsKGNwLCAnXG4nKTsKCQkJaWYgKCpucCkKCQkJCW5wKys7CgkJCXVzYWdlX3BhZGRpbmcob3V0ZmlsZSwgcG9zKTsKCQkJZndyaXRlKGNwLCAxLCBucCAtIGNwLCBvdXRmaWxlKTsKCQkJcG9zID0gMDsKCQl9CgkJZnB1dGMoJ1xuJywgb3V0ZmlsZSk7CgoJCWlmIChwb3NpdGl2ZV9uYW1lKSB7CgkJCWlmIChmaW5kX29wdGlvbl9ieV9sb25nX25hbWUoYWxsX29wdHMsIHBvc2l0aXZlX25hbWUpKQoJCQkJY29udGludWU7CgkJCXBvcyA9IHVzYWdlX2luZGVudChvdXRmaWxlKTsKCQkJcG9zICs9IGZwcmludGYob3V0ZmlsZSwgIi0tJXMiLCBwb3NpdGl2ZV9uYW1lKTsKCQkJdXNhZ2VfcGFkZGluZyhvdXRmaWxlLCBwb3MpOwoJCQlmcHJpbnRmX2xuKG91dGZpbGUsIF8oIm9wcG9zaXRlIG9mIC0tbm8tJXMiKSwKCQkJCSAgIHBvc2l0aXZlX25hbWUpOwoJCX0KCX0KCWZwdXRjKCdcbicsIG91dGZpbGUpOwoKCWlmICghZXJyICYmIGN0eCAmJiBjdHgtPmZsYWdzICYgUEFSU0VfT1BUX1NIRUxMX0VWQUwpCgkJZnB1dHMoIkVPRlxuIiwgb3V0ZmlsZSk7CgoJcmV0dXJuIFBBUlNFX09QVF9IRUxQOwp9Cgp2b2lkIE5PUkVUVVJOIHVzYWdlX3dpdGhfb3B0aW9ucyhjb25zdCBjaGFyICogY29uc3QgKnVzYWdlc3RyLAoJCQljb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRzKQp7Cgl1c2FnZV93aXRoX29wdGlvbnNfaW50ZXJuYWwoTlVMTCwgdXNhZ2VzdHIsIG9wdHMsIDAsIDEpOwoJZXhpdCgxMjkpOwp9Cgp2b2lkIE5PUkVUVVJOIHVzYWdlX21zZ19vcHQoY29uc3QgY2hhciAqbXNnLAoJCSAgIGNvbnN0IGNoYXIgKiBjb25zdCAqdXNhZ2VzdHIsCgkJICAgY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0aW9ucykKewoJZGllX21lc3NhZ2UoIiVzXG4iLCBtc2cpOyAvKiBUaGUgZXh0cmEgXG4gaXMgaW50ZW50aW9uYWwgKi8KCXVzYWdlX3dpdGhfb3B0aW9ucyh1c2FnZXN0ciwgb3B0aW9ucyk7Cn0KCnZvaWQgTk9SRVRVUk4gdXNhZ2VfbXNnX29wdGYoY29uc3QgY2hhciAqIGNvbnN0IGZtdCwKCQkJICAgICBjb25zdCBjaGFyICogY29uc3QgKnVzYWdlc3RyLAoJCQkgICAgIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdGlvbnMsIC4uLikKewoJc3RydWN0IHN0cmJ1ZiBtc2cgPSBTVFJCVUZfSU5JVDsKCXZhX2xpc3QgYXA7Cgl2YV9zdGFydChhcCwgb3B0aW9ucyk7CglzdHJidWZfdmFkZGYoJm1zZywgZm10LCBhcCk7Cgl2YV9lbmQoYXApOwoKCXVzYWdlX21zZ19vcHQobXNnLmJ1ZiwgdXNhZ2VzdHIsIG9wdGlvbnMpOwp9Cgp2b2lkIGRpZV9mb3JfaW5jb21wYXRpYmxlX29wdDQoaW50IG9wdDEsIGNvbnN0IGNoYXIgKm9wdDFfbmFtZSwKCQkJICAgICAgIGludCBvcHQyLCBjb25zdCBjaGFyICpvcHQyX25hbWUsCgkJCSAgICAgICBpbnQgb3B0MywgY29uc3QgY2hhciAqb3B0M19uYW1lLAoJCQkgICAgICAgaW50IG9wdDQsIGNvbnN0IGNoYXIgKm9wdDRfbmFtZSkKewoJaW50IGNvdW50ID0gMDsKCWNvbnN0IGNoYXIgKm9wdGlvbnNbNF07CgoJaWYgKG9wdDEpCgkJb3B0aW9uc1tjb3VudCsrXSA9IG9wdDFfbmFtZTsKCWlmIChvcHQyKQoJCW9wdGlvbnNbY291bnQrK10gPSBvcHQyX25hbWU7CglpZiAob3B0MykKCQlvcHRpb25zW2NvdW50KytdID0gb3B0M19uYW1lOwoJaWYgKG9wdDQpCgkJb3B0aW9uc1tjb3VudCsrXSA9IG9wdDRfbmFtZTsKCXN3aXRjaCAoY291bnQpIHsKCWNhc2UgNDoKCQlkaWUoXygib3B0aW9ucyAnJXMnLCAnJXMnLCAnJXMnLCBhbmQgJyVzJyBjYW5ub3QgYmUgdXNlZCB0b2dldGhlciIpLAoJCSAgICBvcHQxX25hbWUsIG9wdDJfbmFtZSwgb3B0M19uYW1lLCBvcHQ0X25hbWUpOwoJCWJyZWFrOwoJY2FzZSAzOgoJCWRpZShfKCJvcHRpb25zICclcycsICclcycsIGFuZCAnJXMnIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIiksCgkJICAgIG9wdGlvbnNbMF0sIG9wdGlvbnNbMV0sIG9wdGlvbnNbMl0pOwoJCWJyZWFrOwoJY2FzZSAyOgoJCWRpZShfKCJvcHRpb25zICclcycgYW5kICclcycgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIiKSwKCQkgICAgb3B0aW9uc1swXSwgb3B0aW9uc1sxXSk7CgkJYnJlYWs7CglkZWZhdWx0OgoJCWJyZWFrOwoJfQp9Cg==",
    "text": "#include \"git-compat-util.h\"\n#include \"parse-options.h\"\n#include \"abspath.h\"\n#include \"parse.h\"\n#include \"gettext.h\"\n#include \"strbuf.h\"\n#include \"string-list.h\"\n#include \"utf8.h\"\n\nstatic int disallow_abbreviated_options;\n\nenum opt_parsed {\n\tOPT_LONG  = 0,\n\tOPT_SHORT = 1<<0,\n\tOPT_UNSET = 1<<1,\n};\n\nstatic void optbug(const struct option *opt, const char *reason)\n{\n\tif (opt->long_name && opt->short_name)\n\t\tbug(\"switch '%c' (--%s) %s\", opt->short_name,\n\t\t    opt->long_name, reason);\n\telse if (opt->long_name)\n\t\tbug(\"option '%s' %s\", opt->long_name, reason);\n\telse\n\t\tbug(\"switch '%c' %s\", opt->short_name, reason);\n}\n\nstatic const char *optname(const struct option *opt, enum opt_parsed flags)\n{\n\tstatic struct strbuf sb = STRBUF_INIT;\n\n\tstrbuf_reset(&sb);\n\tif (flags & OPT_SHORT)\n\t\tstrbuf_addf(&sb, \"switch `%c'\", opt->short_name);\n\telse if (flags & OPT_UNSET)\n\t\tstrbuf_addf(&sb, \"option `no-%s'\", opt->long_name);\n\telse if (flags == OPT_LONG)\n\t\tstrbuf_addf(&sb, \"option `%s'\", opt->long_name);\n\telse\n\t\tBUG(\"optname() got unknown flags %d\", flags);\n\n\treturn sb.buf;\n}\n\nstatic enum parse_opt_result get_arg(struct parse_opt_ctx_t *p,\n\t\t\t\t     const struct option *opt,\n\t\t\t\t     enum opt_parsed flags, const char **arg)\n{\n\tif (p->opt) {\n\t\t*arg = p->opt;\n\t\tp->opt = NULL;\n\t} else if (p->argc == 1 && (opt->flags & PARSE_OPT_LASTARG_DEFAULT)) {\n\t\t*arg = (const char *)opt->defval;\n\t} else if (p->argc > 1) {\n\t\tp->argc--;\n\t\t*arg = *++p->argv;\n\t} else\n\t\treturn error(_(\"%s requires a value\"), optname(opt, flags));\n\treturn 0;\n}\n\nstatic void fix_filename(const char *prefix, char **file)\n{\n\tif (!file || !*file)\n\t\t; /* leave as NULL */\n\telse\n\t\t*file = prefix_filename_except_for_dash(prefix, *file);\n}\n\nstatic enum parse_opt_result do_get_value(struct parse_opt_ctx_t *p,\n\t\t\t\t\t  const struct option *opt,\n\t\t\t\t\t  enum opt_parsed flags,\n\t\t\t\t\t  const char **argp)\n{\n\tconst char *s, *arg;\n\tconst int unset = flags & OPT_UNSET;\n\tint err;\n\n\tif (unset && p->opt)\n\t\treturn error(_(\"%s takes no value\"), optname(opt, flags));\n\tif (unset && (opt->flags & PARSE_OPT_NONEG))\n\t\treturn error(_(\"%s isn't available\"), optname(opt, flags));\n\tif (!(flags & OPT_SHORT) && p->opt && (opt->flags & PARSE_OPT_NOARG))\n\t\treturn error(_(\"%s takes no value\"), optname(opt, flags));\n\n\tswitch (opt->type) {\n\tcase OPTION_LOWLEVEL_CALLBACK:\n\t\treturn opt->ll_callback(p, opt, NULL, unset);\n\n\tcase OPTION_BIT:\n\t\tif (unset)\n\t\t\t*(int *)opt->value &= ~opt->defval;\n\t\telse\n\t\t\t*(int *)opt->value |= opt->defval;\n\t\treturn 0;\n\n\tcase OPTION_NEGBIT:\n\t\tif (unset)\n\t\t\t*(int *)opt->value |= opt->defval;\n\t\telse\n\t\t\t*(int *)opt->value &= ~opt->defval;\n\t\treturn 0;\n\n\tcase OPTION_BITOP:\n\t\tif (unset)\n\t\t\tBUG(\"BITOP can't have unset form\");\n\t\t*(int *)opt->value &= ~opt->extra;\n\t\t*(int *)opt->value |= opt->defval;\n\t\treturn 0;\n\n\tcase OPTION_COUNTUP:\n\t\tif (*(int *)opt->value < 0)\n\t\t\t*(int *)opt->value = 0;\n\t\t*(int *)opt->value = unset ? 0 : *(int *)opt->value + 1;\n\t\treturn 0;\n\n\tcase OPTION_SET_INT:\n\t\t*(int *)opt->value = unset ? 0 : opt->defval;\n\t\treturn 0;\n\n\tcase OPTION_STRING:\n\t\tif (unset)\n\t\t\t*(const char **)opt->value = NULL;\n\t\telse if (opt->flags & PARSE_OPT_OPTARG && !p->opt)\n\t\t\t*(const char **)opt->value = (const char *)opt->defval;\n\t\telse\n\t\t\treturn get_arg(p, opt, flags, (const char **)opt->value);\n\t\treturn 0;\n\n\tcase OPTION_FILENAME:\n\t\terr = 0;\n\t\tif (unset)\n\t\t\t*(const char **)opt->value = NULL;\n\t\telse if (opt->flags & PARSE_OPT_OPTARG && !p->opt)\n\t\t\t*(const char **)opt->value = (const char *)opt->defval;\n\t\telse\n\t\t\terr = get_arg(p, opt, flags, (const char **)opt->value);\n\n\t\tif (!err)\n\t\t\tfix_filename(p->prefix, (char **)opt->value);\n\t\treturn err;\n\n\tcase OPTION_CALLBACK:\n\t{\n\t\tconst char *p_arg = NULL;\n\t\tint p_unset;\n\n\t\tif (unset)\n\t\t\tp_unset = 1;\n\t\telse if (opt->flags & PARSE_OPT_NOARG)\n\t\t\tp_unset = 0;\n\t\telse if (opt->flags & PARSE_OPT_OPTARG && !p->opt)\n\t\t\tp_unset = 0;\n\t\telse if (get_arg(p, opt, flags, &arg))\n\t\t\treturn -1;\n\t\telse {\n\t\t\tp_unset = 0;\n\t\t\tp_arg = arg;\n\t\t}\n\t\tif (opt->flags & PARSE_OPT_CMDMODE)\n\t\t\t*argp = p_arg;\n\t\tif (opt->callback)\n\t\t\treturn (*opt->callback)(opt, p_arg, p_unset) ? (-1) : 0;\n\t\telse\n\t\t\treturn (*opt->ll_callback)(p, opt, p_arg, p_unset);\n\t}\n\tcase OPTION_INTEGER:\n\t\tif (unset) {\n\t\t\t*(int *)opt->value = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\n\t\t\t*(int *)opt->value = opt->defval;\n\t\t\treturn 0;\n\t\t}\n\t\tif (get_arg(p, opt, flags, &arg))\n\t\t\treturn -1;\n\t\tif (!*arg)\n\t\t\treturn error(_(\"%s expects a numerical value\"),\n\t\t\t\t     optname(opt, flags));\n\t\t*(int *)opt->value = strtol(arg, (char **)&s, 10);\n\t\tif (*s)\n\t\t\treturn error(_(\"%s expects a numerical value\"),\n\t\t\t\t     optname(opt, flags));\n\t\treturn 0;\n\n\tcase OPTION_MAGNITUDE:\n\t\tif (unset) {\n\t\t\t*(unsigned long *)opt->value = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\n\t\t\t*(unsigned long *)opt->value = opt->defval;\n\t\t\treturn 0;\n\t\t}\n\t\tif (get_arg(p, opt, flags, &arg))\n\t\t\treturn -1;\n\t\tif (!git_parse_ulong(arg, opt->value))\n\t\t\treturn error(_(\"%s expects a non-negative integer value\"\n\t\t\t\t       \" with an optional k/m/g suffix\"),\n\t\t\t\t     optname(opt, flags));\n\t\treturn 0;\n\n\tdefault:\n\t\tBUG(\"opt->type %d should not happen\", opt->type);\n\t}\n}\n\nstruct parse_opt_cmdmode_list {\n\tint value, *value_ptr;\n\tconst struct option *opt;\n\tconst char *arg;\n\tenum opt_parsed flags;\n\tstruct parse_opt_cmdmode_list *next;\n};\n\nstatic void build_cmdmode_list(struct parse_opt_ctx_t *ctx,\n\t\t\t       const struct option *opts)\n{\n\tctx->cmdmode_list = NULL;\n\n\tfor (; opts->type != OPTION_END; opts++) {\n\t\tstruct parse_opt_cmdmode_list *elem = ctx->cmdmode_list;\n\t\tint *value_ptr = opts->value;\n\n\t\tif (!(opts->flags & PARSE_OPT_CMDMODE) || !value_ptr)\n\t\t\tcontinue;\n\n\t\twhile (elem && elem->value_ptr != value_ptr)\n\t\t\telem = elem->next;\n\t\tif (elem)\n\t\t\tcontinue;\n\n\t\tCALLOC_ARRAY(elem, 1);\n\t\telem->value_ptr = value_ptr;\n\t\telem->value = *value_ptr;\n\t\telem->next = ctx->cmdmode_list;\n\t\tctx->cmdmode_list = elem;\n\t}\n}\n\nstatic char *optnamearg(const struct option *opt, const char *arg,\n\t\t\tenum opt_parsed flags)\n{\n\tif (flags & OPT_SHORT)\n\t\treturn xstrfmt(\"-%c%s\", opt->short_name, arg ? arg : \"\");\n\treturn xstrfmt(\"--%s%s%s%s\", flags & OPT_UNSET ? \"no-\" : \"\",\n\t\t       opt->long_name, arg ? \"=\" : \"\", arg ? arg : \"\");\n}\n\nstatic enum parse_opt_result get_value(struct parse_opt_ctx_t *p,\n\t\t\t\t       const struct option *opt,\n\t\t\t\t       enum opt_parsed flags)\n{\n\tconst char *arg = NULL;\n\tenum parse_opt_result result = do_get_value(p, opt, flags, &arg);\n\tstruct parse_opt_cmdmode_list *elem = p->cmdmode_list;\n\tchar *opt_name, *other_opt_name;\n\n\tfor (; elem; elem = elem->next) {\n\t\tif (*elem->value_ptr == elem->value)\n\t\t\tcontinue;\n\n\t\tif (elem->opt &&\n\t\t    (elem->opt->flags | opt->flags) & PARSE_OPT_CMDMODE)\n\t\t\tbreak;\n\n\t\telem->opt = opt;\n\t\telem->arg = arg;\n\t\telem->flags = flags;\n\t\telem->value = *elem->value_ptr;\n\t}\n\n\tif (result || !elem)\n\t\treturn result;\n\n\topt_name = optnamearg(opt, arg, flags);\n\tother_opt_name = optnamearg(elem->opt, elem->arg, elem->flags);\n\terror(_(\"options '%s' and '%s' cannot be used together\"),\n\t      opt_name, other_opt_name);\n\tfree(opt_name);\n\tfree(other_opt_name);\n\treturn -1;\n}\n\nstatic enum parse_opt_result parse_short_opt(struct parse_opt_ctx_t *p,\n\t\t\t\t\t     const struct option *options)\n{\n\tconst struct option *numopt = NULL;\n\n\tfor (; options->type != OPTION_END; options++) {\n\t\tif (options->short_name == *p->opt) {\n\t\t\tp->opt = p->opt[1] ? p->opt + 1 : NULL;\n\t\t\treturn get_value(p, options, OPT_SHORT);\n\t\t}\n\n\t\t/*\n\t\t * Handle the numerical option later, explicit one-digit\n\t\t * options take precedence over it.\n\t\t */\n\t\tif (options->type == OPTION_NUMBER)\n\t\t\tnumopt = options;\n\t}\n\tif (numopt && isdigit(*p->opt)) {\n\t\tsize_t len = 1;\n\t\tchar *arg;\n\t\tint rc;\n\n\t\twhile (isdigit(p->opt[len]))\n\t\t\tlen++;\n\t\targ = xmemdupz(p->opt, len);\n\t\tp->opt = p->opt[len] ? p->opt + len : NULL;\n\t\tif (numopt->callback)\n\t\t\trc = (*numopt->callback)(numopt, arg, 0) ? (-1) : 0;\n\t\telse\n\t\t\trc = (*numopt->ll_callback)(p, numopt, arg, 0);\n\t\tfree(arg);\n\t\treturn rc;\n\t}\n\treturn PARSE_OPT_UNKNOWN;\n}\n\nstatic int has_string(const char *it, const char **array)\n{\n\twhile (*array)\n\t\tif (!strcmp(it, *(array++)))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic int is_alias(struct parse_opt_ctx_t *ctx,\n\t\t    const struct option *one_opt,\n\t\t    const struct option *another_opt)\n{\n\tconst char **group;\n\n\tif (!ctx->alias_groups)\n\t\treturn 0;\n\n\tif (!one_opt->long_name || !another_opt->long_name)\n\t\treturn 0;\n\n\tfor (group = ctx->alias_groups; *group; group += 3) {\n\t\t/* it and other are from the same family? */\n\t\tif (has_string(one_opt->long_name, group) &&\n\t\t    has_string(another_opt->long_name, group))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstruct parsed_option {\n\tconst struct option *option;\n\tenum opt_parsed flags;\n};\n\nstatic void register_abbrev(struct parse_opt_ctx_t *p,\n\t\t\t    const struct option *option, enum opt_parsed flags,\n\t\t\t    struct parsed_option *abbrev,\n\t\t\t    struct parsed_option *ambiguous)\n{\n\tif (p->flags & PARSE_OPT_KEEP_UNKNOWN_OPT)\n\t\treturn;\n\tif (abbrev->option &&\n\t    !(abbrev->flags == flags && is_alias(p, abbrev->option, option))) {\n\t\t/*\n\t\t * If this is abbreviated, it is\n\t\t * ambiguous. So when there is no\n\t\t * exact match later, we need to\n\t\t * error out.\n\t\t */\n\t\tambiguous->option = abbrev->option;\n\t\tambiguous->flags = abbrev->flags;\n\t}\n\tabbrev->option = option;\n\tabbrev->flags = flags;\n}\n\nstatic enum parse_opt_result parse_long_opt(\n\tstruct parse_opt_ctx_t *p, const char *arg,\n\tconst struct option *options)\n{\n\tconst char *arg_end = strchrnul(arg, '=');\n\tstruct parsed_option abbrev = { .option = NULL, .flags = OPT_LONG };\n\tstruct parsed_option ambiguous = { .option = NULL, .flags = OPT_LONG };\n\n\tfor (; options->type != OPTION_END; options++) {\n\t\tconst char *rest, *long_name = options->long_name;\n\t\tenum opt_parsed flags = OPT_LONG, opt_flags = OPT_LONG;\n\n\t\tif (options->type == OPTION_SUBCOMMAND)\n\t\t\tcontinue;\n\t\tif (!long_name)\n\t\t\tcontinue;\n\n\t\tif (!starts_with(arg, \"no-\") &&\n\t\t    !(options->flags & PARSE_OPT_NONEG) &&\n\t\t    skip_prefix(long_name, \"no-\", &long_name))\n\t\t\topt_flags |= OPT_UNSET;\n\n\t\tif (!skip_prefix(arg, long_name, &rest))\n\t\t\trest = NULL;\n\t\tif (!rest) {\n\t\t\t/* abbreviated? */\n\t\t\tif (!strncmp(long_name, arg, arg_end - arg)) {\n\t\t\t\tregister_abbrev(p, options, flags ^ opt_flags,\n\t\t\t\t\t\t&abbrev, &ambiguous);\n\t\t\t}\n\t\t\t/* negation allowed? */\n\t\t\tif (options->flags & PARSE_OPT_NONEG)\n\t\t\t\tcontinue;\n\t\t\t/* negated and abbreviated very much? */\n\t\t\tif (starts_with(\"no-\", arg)) {\n\t\t\t\tflags |= OPT_UNSET;\n\t\t\t\tregister_abbrev(p, options, flags ^ opt_flags,\n\t\t\t\t\t\t&abbrev, &ambiguous);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* negated? */\n\t\t\tif (!starts_with(arg, \"no-\"))\n\t\t\t\tcontinue;\n\t\t\tflags |= OPT_UNSET;\n\t\t\tif (!skip_prefix(arg + 3, long_name, &rest)) {\n\t\t\t\t/* abbreviated and negated? */\n\t\t\t\tif (!strncmp(long_name, arg + 3,\n\t\t\t\t\t     arg_end - arg - 3))\n\t\t\t\t\tregister_abbrev(p, options,\n\t\t\t\t\t\t\tflags ^ opt_flags,\n\t\t\t\t\t\t\t&abbrev, &ambiguous);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (*rest) {\n\t\t\tif (*rest != '=')\n\t\t\t\tcontinue;\n\t\t\tp->opt = rest + 1;\n\t\t}\n\t\treturn get_value(p, options, flags ^ opt_flags);\n\t}\n\n\tif (disallow_abbreviated_options && (ambiguous.option || abbrev.option))\n\t\tdie(\"disallowed abbreviated or ambiguous option '%.*s'\",\n\t\t    (int)(arg_end - arg), arg);\n\n\tif (ambiguous.option) {\n\t\terror(_(\"ambiguous option: %s \"\n\t\t\t\"(could be --%s%s or --%s%s)\"),\n\t\t\targ,\n\t\t\t(ambiguous.flags & OPT_UNSET) ?  \"no-\" : \"\",\n\t\t\tambiguous.option->long_name,\n\t\t\t(abbrev.flags & OPT_UNSET) ?  \"no-\" : \"\",\n\t\t\tabbrev.option->long_name);\n\t\treturn PARSE_OPT_HELP;\n\t}\n\tif (abbrev.option) {\n\t\tif (*arg_end)\n\t\t\tp->opt = arg_end + 1;\n\t\treturn get_value(p, abbrev.option, abbrev.flags);\n\t}\n\treturn PARSE_OPT_UNKNOWN;\n}\n\nstatic enum parse_opt_result parse_nodash_opt(struct parse_opt_ctx_t *p,\n\t\t\t\t\t      const char *arg,\n\t\t\t\t\t      const struct option *options)\n{\n\tfor (; options->type != OPTION_END; options++) {\n\t\tif (!(options->flags & PARSE_OPT_NODASH))\n\t\t\tcontinue;\n\t\tif (options->short_name == arg[0] && arg[1] == '\\0')\n\t\t\treturn get_value(p, options, OPT_SHORT);\n\t}\n\treturn PARSE_OPT_ERROR;\n}\n\nstatic enum parse_opt_result parse_subcommand(const char *arg,\n\t\t\t\t\t      const struct option *options)\n{\n\tfor (; options->type != OPTION_END; options++)\n\t\tif (options->type == OPTION_SUBCOMMAND &&\n\t\t    !strcmp(options->long_name, arg)) {\n\t\t\t*(parse_opt_subcommand_fn **)options->value = options->subcommand_fn;\n\t\t\treturn PARSE_OPT_SUBCOMMAND;\n\t\t}\n\n\treturn PARSE_OPT_UNKNOWN;\n}\n\nstatic void check_typos(const char *arg, const struct option *options)\n{\n\tif (strlen(arg) < 3)\n\t\treturn;\n\n\tif (starts_with(arg, \"no-\")) {\n\t\terror(_(\"did you mean `--%s` (with two dashes)?\"), arg);\n\t\texit(129);\n\t}\n\n\tfor (; options->type != OPTION_END; options++) {\n\t\tif (!options->long_name)\n\t\t\tcontinue;\n\t\tif (starts_with(options->long_name, arg)) {\n\t\t\terror(_(\"did you mean `--%s` (with two dashes)?\"), arg);\n\t\t\texit(129);\n\t\t}\n\t}\n}\n\nstatic void parse_options_check(const struct option *opts)\n{\n\tchar short_opts[128];\n\tvoid *subcommand_value = NULL;\n\n\tmemset(short_opts, '\\0', sizeof(short_opts));\n\tfor (; opts->type != OPTION_END; opts++) {\n\t\tif ((opts->flags & PARSE_OPT_LASTARG_DEFAULT) &&\n\t\t    (opts->flags & PARSE_OPT_OPTARG))\n\t\t\toptbug(opts, \"uses incompatible flags \"\n\t\t\t       \"LASTARG_DEFAULT and OPTARG\");\n\t\tif (opts->short_name) {\n\t\t\tif (0x7F <= opts->short_name)\n\t\t\t\toptbug(opts, \"invalid short name\");\n\t\t\telse if (short_opts[opts->short_name]++)\n\t\t\t\toptbug(opts, \"short name already used\");\n\t\t}\n\t\tif (opts->flags & PARSE_OPT_NODASH &&\n\t\t    ((opts->flags & PARSE_OPT_OPTARG) ||\n\t\t     !(opts->flags & PARSE_OPT_NOARG) ||\n\t\t     !(opts->flags & PARSE_OPT_NONEG) ||\n\t\t     opts->long_name))\n\t\t\toptbug(opts, \"uses feature \"\n\t\t\t       \"not supported for dashless options\");\n\t\tif (opts->type == OPTION_SET_INT && !opts->defval &&\n\t\t    opts->long_name && !(opts->flags & PARSE_OPT_NONEG))\n\t\t\toptbug(opts, \"OPTION_SET_INT 0 should not be negatable\");\n\t\tswitch (opts->type) {\n\t\tcase OPTION_COUNTUP:\n\t\tcase OPTION_BIT:\n\t\tcase OPTION_NEGBIT:\n\t\tcase OPTION_SET_INT:\n\t\tcase OPTION_NUMBER:\n\t\t\tif ((opts->flags & PARSE_OPT_OPTARG) ||\n\t\t\t    !(opts->flags & PARSE_OPT_NOARG))\n\t\t\t\toptbug(opts, \"should not accept an argument\");\n\t\t\tbreak;\n\t\tcase OPTION_CALLBACK:\n\t\t\tif (!opts->callback && !opts->ll_callback)\n\t\t\t\toptbug(opts, \"OPTION_CALLBACK needs one callback\");\n\t\t\telse if (opts->callback && opts->ll_callback)\n\t\t\t\toptbug(opts, \"OPTION_CALLBACK can't have two callbacks\");\n\t\t\tbreak;\n\t\tcase OPTION_LOWLEVEL_CALLBACK:\n\t\t\tif (!opts->ll_callback)\n\t\t\t\toptbug(opts, \"OPTION_LOWLEVEL_CALLBACK needs a callback\");\n\t\t\tif (opts->callback)\n\t\t\t\toptbug(opts, \"OPTION_LOWLEVEL_CALLBACK needs no high level callback\");\n\t\t\tbreak;\n\t\tcase OPTION_ALIAS:\n\t\t\toptbug(opts, \"OPT_ALIAS() should not remain at this point. \"\n\t\t\t       \"Are you using parse_options_step() directly?\\n\"\n\t\t\t       \"That case is not supported yet.\");\n\t\t\tbreak;\n\t\tcase OPTION_SUBCOMMAND:\n\t\t\tif (!opts->value || !opts->subcommand_fn)\n\t\t\t\toptbug(opts, \"OPTION_SUBCOMMAND needs a value and a subcommand function\");\n\t\t\tif (!subcommand_value)\n\t\t\t\tsubcommand_value = opts->value;\n\t\t\telse if (subcommand_value != opts->value)\n\t\t\t\toptbug(opts, \"all OPTION_SUBCOMMANDs need the same value\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t; /* ok. (usually accepts an argument) */\n\t\t}\n\t\tif (opts->argh &&\n\t\t    strcspn(opts->argh, \" _\") != strlen(opts->argh))\n\t\t\toptbug(opts, \"multi-word argh should use dash to separate words\");\n\t}\n\tBUG_if_bug(\"invalid 'struct option'\");\n}\n\nstatic int has_subcommands(const struct option *options)\n{\n\tfor (; options->type != OPTION_END; options++)\n\t\tif (options->type == OPTION_SUBCOMMAND)\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic void parse_options_start_1(struct parse_opt_ctx_t *ctx,\n\t\t\t\t  int argc, const char **argv, const char *prefix,\n\t\t\t\t  const struct option *options,\n\t\t\t\t  enum parse_opt_flags flags)\n{\n\tctx->argc = argc;\n\tctx->argv = argv;\n\tif (!(flags & PARSE_OPT_ONE_SHOT)) {\n\t\tctx->argc--;\n\t\tctx->argv++;\n\t}\n\tctx->total = ctx->argc;\n\tctx->out   = argv;\n\tctx->prefix = prefix;\n\tctx->cpidx = ((flags & PARSE_OPT_KEEP_ARGV0) != 0);\n\tctx->flags = flags;\n\tctx->has_subcommands = has_subcommands(options);\n\tif (!ctx->has_subcommands && (flags & PARSE_OPT_SUBCOMMAND_OPTIONAL))\n\t\tBUG(\"Using PARSE_OPT_SUBCOMMAND_OPTIONAL without subcommands\");\n\tif (ctx->has_subcommands) {\n\t\tif (flags & PARSE_OPT_STOP_AT_NON_OPTION)\n\t\t\tBUG(\"subcommands are incompatible with PARSE_OPT_STOP_AT_NON_OPTION\");\n\t\tif (!(flags & PARSE_OPT_SUBCOMMAND_OPTIONAL)) {\n\t\t\tif (flags & PARSE_OPT_KEEP_UNKNOWN_OPT)\n\t\t\t\tBUG(\"subcommands are incompatible with PARSE_OPT_KEEP_UNKNOWN_OPT unless in combination with PARSE_OPT_SUBCOMMAND_OPTIONAL\");\n\t\t\tif (flags & PARSE_OPT_KEEP_DASHDASH)\n\t\t\t\tBUG(\"subcommands are incompatible with PARSE_OPT_KEEP_DASHDASH unless in combination with PARSE_OPT_SUBCOMMAND_OPTIONAL\");\n\t\t}\n\t}\n\tif ((flags & PARSE_OPT_KEEP_UNKNOWN_OPT) &&\n\t    (flags & PARSE_OPT_STOP_AT_NON_OPTION) &&\n\t    !(flags & PARSE_OPT_ONE_SHOT))\n\t\tBUG(\"STOP_AT_NON_OPTION and KEEP_UNKNOWN don't go together\");\n\tif ((flags & PARSE_OPT_ONE_SHOT) &&\n\t    (flags & PARSE_OPT_KEEP_ARGV0))\n\t\tBUG(\"Can't keep argv0 if you don't have it\");\n\tparse_options_check(options);\n\tbuild_cmdmode_list(ctx, options);\n}\n\nvoid parse_options_start(struct parse_opt_ctx_t *ctx,\n\t\t\t int argc, const char **argv, const char *prefix,\n\t\t\t const struct option *options,\n\t\t\t enum parse_opt_flags flags)\n{\n\tmemset(ctx, 0, sizeof(*ctx));\n\tparse_options_start_1(ctx, argc, argv, prefix, options, flags);\n}\n\nstatic void show_negated_gitcomp(const struct option *opts, int show_all,\n\t\t\t\t int nr_noopts)\n{\n\tint printed_dashdash = 0;\n\n\tfor (; opts->type != OPTION_END; opts++) {\n\t\tint has_unset_form = 0;\n\t\tconst char *name;\n\n\t\tif (!opts->long_name)\n\t\t\tcontinue;\n\t\tif (!show_all &&\n\t\t\t(opts->flags & (PARSE_OPT_HIDDEN | PARSE_OPT_NOCOMPLETE)))\n\t\t\tcontinue;\n\t\tif (opts->flags & PARSE_OPT_NONEG)\n\t\t\tcontinue;\n\n\t\tswitch (opts->type) {\n\t\tcase OPTION_STRING:\n\t\tcase OPTION_FILENAME:\n\t\tcase OPTION_INTEGER:\n\t\tcase OPTION_MAGNITUDE:\n\t\tcase OPTION_CALLBACK:\n\t\tcase OPTION_BIT:\n\t\tcase OPTION_NEGBIT:\n\t\tcase OPTION_COUNTUP:\n\t\tcase OPTION_SET_INT:\n\t\t\thas_unset_form = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (!has_unset_form)\n\t\t\tcontinue;\n\n\t\tif (skip_prefix(opts->long_name, \"no-\", &name)) {\n\t\t\tif (nr_noopts < 0)\n\t\t\t\tprintf(\" --%s\", name);\n\t\t} else if (nr_noopts >= 0) {\n\t\t\tif (nr_noopts && !printed_dashdash) {\n\t\t\t\tprintf(\" --\");\n\t\t\t\tprinted_dashdash = 1;\n\t\t\t}\n\t\t\tprintf(\" --no-%s\", opts->long_name);\n\t\t\tnr_noopts++;\n\t\t}\n\t}\n}\n\nstatic int show_gitcomp(const struct option *opts, int show_all)\n{\n\tconst struct option *original_opts = opts;\n\tint nr_noopts = 0;\n\n\tfor (; opts->type != OPTION_END; opts++) {\n\t\tconst char *prefix = \"--\";\n\t\tconst char *suffix = \"\";\n\n\t\tif (!opts->long_name)\n\t\t\tcontinue;\n\t\tif (!show_all &&\n\t\t\t(opts->flags & (PARSE_OPT_HIDDEN | PARSE_OPT_NOCOMPLETE | PARSE_OPT_FROM_ALIAS)))\n\t\t\tcontinue;\n\n\t\tswitch (opts->type) {\n\t\tcase OPTION_SUBCOMMAND:\n\t\t\tprefix = \"\";\n\t\t\tbreak;\n\t\tcase OPTION_GROUP:\n\t\t\tcontinue;\n\t\tcase OPTION_STRING:\n\t\tcase OPTION_FILENAME:\n\t\tcase OPTION_INTEGER:\n\t\tcase OPTION_MAGNITUDE:\n\t\tcase OPTION_CALLBACK:\n\t\t\tif (opts->flags & PARSE_OPT_NOARG)\n\t\t\t\tbreak;\n\t\t\tif (opts->flags & PARSE_OPT_OPTARG)\n\t\t\t\tbreak;\n\t\t\tif (opts->flags & PARSE_OPT_LASTARG_DEFAULT)\n\t\t\t\tbreak;\n\t\t\tsuffix = \"=\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (opts->flags & PARSE_OPT_COMP_ARG)\n\t\t\tsuffix = \"=\";\n\t\tif (starts_with(opts->long_name, \"no-\"))\n\t\t\tnr_noopts++;\n\t\tprintf(\"%s%s%s%s\", opts == original_opts ? \"\" : \" \",\n\t\t       prefix, opts->long_name, suffix);\n\t}\n\tshow_negated_gitcomp(original_opts, show_all, -1);\n\tshow_negated_gitcomp(original_opts, show_all, nr_noopts);\n\tfputc('\\n', stdout);\n\treturn PARSE_OPT_COMPLETE;\n}\n\n/*\n * Scan and may produce a new option[] array, which should be used\n * instead of the original 'options'.\n *\n * Right now this is only used to preprocess and substitute\n * OPTION_ALIAS.\n *\n * The returned options should be freed using free_preprocessed_options.\n */\nstatic struct option *preprocess_options(struct parse_opt_ctx_t *ctx,\n\t\t\t\t\t const struct option *options)\n{\n\tstruct option *newopt;\n\tint i, nr, alias;\n\tint nr_aliases = 0;\n\n\tfor (nr = 0; options[nr].type != OPTION_END; nr++) {\n\t\tif (options[nr].type == OPTION_ALIAS)\n\t\t\tnr_aliases++;\n\t}\n\n\tif (!nr_aliases)\n\t\treturn NULL;\n\n\tDUP_ARRAY(newopt, options, nr + 1);\n\n\t/* each alias has two string pointers and NULL */\n\tCALLOC_ARRAY(ctx->alias_groups, 3 * (nr_aliases + 1));\n\n\tfor (alias = 0, i = 0; i < nr; i++) {\n\t\tint short_name;\n\t\tconst char *long_name;\n\t\tconst char *source;\n\t\tstruct strbuf help = STRBUF_INIT;\n\t\tint j;\n\n\t\tif (newopt[i].type != OPTION_ALIAS)\n\t\t\tcontinue;\n\n\t\tshort_name = newopt[i].short_name;\n\t\tlong_name = newopt[i].long_name;\n\t\tsource = newopt[i].value;\n\n\t\tif (!long_name)\n\t\t\tBUG(\"An alias must have long option name\");\n\t\tstrbuf_addf(&help, _(\"alias of --%s\"), source);\n\n\t\tfor (j = 0; j < nr; j++) {\n\t\t\tconst char *name = options[j].long_name;\n\n\t\t\tif (!name || strcmp(name, source))\n\t\t\t\tcontinue;\n\n\t\t\tif (options[j].type == OPTION_ALIAS)\n\t\t\t\tBUG(\"No please. Nested aliases are not supported.\");\n\n\t\t\tmemcpy(newopt + i, options + j, sizeof(*newopt));\n\t\t\tnewopt[i].short_name = short_name;\n\t\t\tnewopt[i].long_name = long_name;\n\t\t\tnewopt[i].help = strbuf_detach(&help, NULL);\n\t\t\tnewopt[i].flags |= PARSE_OPT_FROM_ALIAS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j == nr)\n\t\t\tBUG(\"could not find source option '%s' of alias '%s'\",\n\t\t\t    source, newopt[i].long_name);\n\t\tctx->alias_groups[alias * 3 + 0] = newopt[i].long_name;\n\t\tctx->alias_groups[alias * 3 + 1] = options[j].long_name;\n\t\tctx->alias_groups[alias * 3 + 2] = NULL;\n\t\talias++;\n\t}\n\n\treturn newopt;\n}\n\nstatic void free_preprocessed_options(struct option *options)\n{\n\tint i;\n\n\tif (!options)\n\t\treturn;\n\n\tfor (i = 0; options[i].type != OPTION_END; i++) {\n\t\tif (options[i].flags & PARSE_OPT_FROM_ALIAS)\n\t\t\tfree((void *)options[i].help);\n\t}\n\tfree(options);\n}\n\nstatic enum parse_opt_result usage_with_options_internal(struct parse_opt_ctx_t *,\n\t\t\t\t\t\t\t const char * const *,\n\t\t\t\t\t\t\t const struct option *,\n\t\t\t\t\t\t\t int, int);\n\nenum parse_opt_result parse_options_step(struct parse_opt_ctx_t *ctx,\n\t\t\t\t\t const struct option *options,\n\t\t\t\t\t const char * const usagestr[])\n{\n\tint internal_help = !(ctx->flags & PARSE_OPT_NO_INTERNAL_HELP);\n\n\t/* we must reset ->opt, unknown short option leave it dangling */\n\tctx->opt = NULL;\n\n\tfor (; ctx->argc; ctx->argc--, ctx->argv++) {\n\t\tconst char *arg = ctx->argv[0];\n\n\t\tif (ctx->flags & PARSE_OPT_ONE_SHOT &&\n\t\t    ctx->argc != ctx->total)\n\t\t\tbreak;\n\n\t\tif (*arg != '-' || !arg[1]) {\n\t\t\tif (parse_nodash_opt(ctx, arg, options) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (!ctx->has_subcommands) {\n\t\t\t\tif (ctx->flags & PARSE_OPT_STOP_AT_NON_OPTION)\n\t\t\t\t\treturn PARSE_OPT_NON_OPTION;\n\t\t\t\tctx->out[ctx->cpidx++] = ctx->argv[0];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (parse_subcommand(arg, options)) {\n\t\t\tcase PARSE_OPT_SUBCOMMAND:\n\t\t\t\treturn PARSE_OPT_SUBCOMMAND;\n\t\t\tcase PARSE_OPT_UNKNOWN:\n\t\t\t\tif (ctx->flags & PARSE_OPT_SUBCOMMAND_OPTIONAL)\n\t\t\t\t\t/*\n\t\t\t\t\t * arg is neither a short or long\n\t\t\t\t\t * option nor a subcommand.  Since\n\t\t\t\t\t * this command has a default\n\t\t\t\t\t * operation mode, we have to treat\n\t\t\t\t\t * this arg and all remaining args\n\t\t\t\t\t * as args meant to that default\n\t\t\t\t\t * operation mode.\n\t\t\t\t\t * So we are done parsing.\n\t\t\t\t\t */\n\t\t\t\t\treturn PARSE_OPT_DONE;\n\t\t\t\terror(_(\"unknown subcommand: `%s'\"), arg);\n\t\t\t\tusage_with_options(usagestr, options);\n\t\t\tcase PARSE_OPT_COMPLETE:\n\t\t\tcase PARSE_OPT_HELP:\n\t\t\tcase PARSE_OPT_ERROR:\n\t\t\tcase PARSE_OPT_DONE:\n\t\t\tcase PARSE_OPT_NON_OPTION:\n\t\t\t\t/* Impossible. */\n\t\t\t\tBUG(\"parse_subcommand() cannot return these\");\n\t\t\t}\n\t\t}\n\n\t\t/* lone -h asks for help */\n\t\tif (internal_help && ctx->total == 1 && !strcmp(arg + 1, \"h\"))\n\t\t\tgoto show_usage;\n\n\t\t/*\n\t\t * lone --git-completion-helper and --git-completion-helper-all\n\t\t * are asked by git-completion.bash\n\t\t */\n\t\tif (ctx->total == 1 && !strcmp(arg, \"--git-completion-helper\"))\n\t\t\treturn show_gitcomp(options, 0);\n\t\tif (ctx->total == 1 && !strcmp(arg, \"--git-completion-helper-all\"))\n\t\t\treturn show_gitcomp(options, 1);\n\n\t\tif (arg[1] != '-') {\n\t\t\tctx->opt = arg + 1;\n\t\t\tswitch (parse_short_opt(ctx, options)) {\n\t\t\tcase PARSE_OPT_ERROR:\n\t\t\t\treturn PARSE_OPT_ERROR;\n\t\t\tcase PARSE_OPT_UNKNOWN:\n\t\t\t\tif (ctx->opt)\n\t\t\t\t\tcheck_typos(arg + 1, options);\n\t\t\t\tif (internal_help && *ctx->opt == 'h')\n\t\t\t\t\tgoto show_usage;\n\t\t\t\tgoto unknown;\n\t\t\tcase PARSE_OPT_NON_OPTION:\n\t\t\tcase PARSE_OPT_SUBCOMMAND:\n\t\t\tcase PARSE_OPT_HELP:\n\t\t\tcase PARSE_OPT_COMPLETE:\n\t\t\t\tBUG(\"parse_short_opt() cannot return these\");\n\t\t\tcase PARSE_OPT_DONE:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ctx->opt)\n\t\t\t\tcheck_typos(arg + 1, options);\n\t\t\twhile (ctx->opt) {\n\t\t\t\tswitch (parse_short_opt(ctx, options)) {\n\t\t\t\tcase PARSE_OPT_ERROR:\n\t\t\t\t\treturn PARSE_OPT_ERROR;\n\t\t\t\tcase PARSE_OPT_UNKNOWN:\n\t\t\t\t\tif (internal_help && *ctx->opt == 'h')\n\t\t\t\t\t\tgoto show_usage;\n\n\t\t\t\t\t/* fake a short option thing to hide the fact that we may have\n\t\t\t\t\t * started to parse aggregated stuff\n\t\t\t\t\t *\n\t\t\t\t\t * This is leaky, too bad.\n\t\t\t\t\t */\n\t\t\t\t\tctx->argv[0] = xstrdup(ctx->opt - 1);\n\t\t\t\t\t*(char *)ctx->argv[0] = '-';\n\t\t\t\t\tgoto unknown;\n\t\t\t\tcase PARSE_OPT_NON_OPTION:\n\t\t\t\tcase PARSE_OPT_SUBCOMMAND:\n\t\t\t\tcase PARSE_OPT_COMPLETE:\n\t\t\t\tcase PARSE_OPT_HELP:\n\t\t\t\t\tBUG(\"parse_short_opt() cannot return these\");\n\t\t\t\tcase PARSE_OPT_DONE:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!arg[2] /* \"--\" */) {\n\t\t\tif (!(ctx->flags & PARSE_OPT_KEEP_DASHDASH)) {\n\t\t\t\tctx->argc--;\n\t\t\t\tctx->argv++;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (!strcmp(arg + 2, \"end-of-options\")) {\n\t\t\tif (!(ctx->flags & PARSE_OPT_KEEP_UNKNOWN_OPT)) {\n\t\t\t\tctx->argc--;\n\t\t\t\tctx->argv++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (internal_help && !strcmp(arg + 2, \"help-all\"))\n\t\t\treturn usage_with_options_internal(ctx, usagestr, options, 1, 0);\n\t\tif (internal_help && !strcmp(arg + 2, \"help\"))\n\t\t\tgoto show_usage;\n\t\tswitch (parse_long_opt(ctx, arg + 2, options)) {\n\t\tcase PARSE_OPT_ERROR:\n\t\t\treturn PARSE_OPT_ERROR;\n\t\tcase PARSE_OPT_UNKNOWN:\n\t\t\tgoto unknown;\n\t\tcase PARSE_OPT_HELP:\n\t\t\tgoto show_usage;\n\t\tcase PARSE_OPT_NON_OPTION:\n\t\tcase PARSE_OPT_SUBCOMMAND:\n\t\tcase PARSE_OPT_COMPLETE:\n\t\t\tBUG(\"parse_long_opt() cannot return these\");\n\t\tcase PARSE_OPT_DONE:\n\t\t\tbreak;\n\t\t}\n\t\tcontinue;\nunknown:\n\t\tif (ctx->flags & PARSE_OPT_ONE_SHOT)\n\t\t\tbreak;\n\t\tif (ctx->has_subcommands &&\n\t\t    (ctx->flags & PARSE_OPT_SUBCOMMAND_OPTIONAL) &&\n\t\t    (ctx->flags & PARSE_OPT_KEEP_UNKNOWN_OPT)) {\n\t\t\t/*\n\t\t\t * Found an unknown option given to a command with\n\t\t\t * subcommands that has a default operation mode:\n\t\t\t * we treat this option and all remaining args as\n\t\t\t * arguments meant to that default operation mode.\n\t\t\t * So we are done parsing.\n\t\t\t */\n\t\t\treturn PARSE_OPT_DONE;\n\t\t}\n\t\tif (!(ctx->flags & PARSE_OPT_KEEP_UNKNOWN_OPT))\n\t\t\treturn PARSE_OPT_UNKNOWN;\n\t\tctx->out[ctx->cpidx++] = ctx->argv[0];\n\t\tctx->opt = NULL;\n\t}\n\treturn PARSE_OPT_DONE;\n\n show_usage:\n\treturn usage_with_options_internal(ctx, usagestr, options, 0, 0);\n}\n\nint parse_options_end(struct parse_opt_ctx_t *ctx)\n{\n\tif (ctx->flags & PARSE_OPT_ONE_SHOT)\n\t\treturn ctx->total - ctx->argc;\n\n\tMOVE_ARRAY(ctx->out + ctx->cpidx, ctx->argv, ctx->argc);\n\tctx->out[ctx->cpidx + ctx->argc] = NULL;\n\treturn ctx->cpidx + ctx->argc;\n}\n\nint parse_options(int argc, const char **argv,\n\t\t  const char *prefix,\n\t\t  const struct option *options,\n\t\t  const char * const usagestr[],\n\t\t  enum parse_opt_flags flags)\n{\n\tstruct parse_opt_ctx_t ctx;\n\tstruct option *real_options;\n\n\tdisallow_abbreviated_options =\n\t\tgit_env_bool(\"GIT_TEST_DISALLOW_ABBREVIATED_OPTIONS\", 0);\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\treal_options = preprocess_options(&ctx, options);\n\tif (real_options)\n\t\toptions = real_options;\n\tparse_options_start_1(&ctx, argc, argv, prefix, options, flags);\n\tswitch (parse_options_step(&ctx, options, usagestr)) {\n\tcase PARSE_OPT_HELP:\n\tcase PARSE_OPT_ERROR:\n\t\texit(129);\n\tcase PARSE_OPT_COMPLETE:\n\t\texit(0);\n\tcase PARSE_OPT_NON_OPTION:\n\tcase PARSE_OPT_SUBCOMMAND:\n\t\tbreak;\n\tcase PARSE_OPT_DONE:\n\t\tif (ctx.has_subcommands &&\n\t\t    !(flags & PARSE_OPT_SUBCOMMAND_OPTIONAL)) {\n\t\t\terror(_(\"need a subcommand\"));\n\t\t\tusage_with_options(usagestr, options);\n\t\t}\n\t\tbreak;\n\tcase PARSE_OPT_UNKNOWN:\n\t\tif (ctx.argv[0][1] == '-') {\n\t\t\terror(_(\"unknown option `%s'\"), ctx.argv[0] + 2);\n\t\t} else if (isascii(*ctx.opt)) {\n\t\t\terror(_(\"unknown switch `%c'\"), *ctx.opt);\n\t\t} else {\n\t\t\terror(_(\"unknown non-ascii option in string: `%s'\"),\n\t\t\t      ctx.argv[0]);\n\t\t}\n\t\tusage_with_options(usagestr, options);\n\t}\n\n\tprecompose_argv_prefix(argc, argv, NULL);\n\tfree_preprocessed_options(real_options);\n\tfree(ctx.alias_groups);\n\tfor (struct parse_opt_cmdmode_list *elem = ctx.cmdmode_list; elem;) {\n\t\tstruct parse_opt_cmdmode_list *next = elem->next;\n\t\tfree(elem);\n\t\telem = next;\n\t}\n\treturn parse_options_end(&ctx);\n}\n\nstatic int usage_argh(const struct option *opts, FILE *outfile)\n{\n\tconst char *s;\n\tint literal = (opts->flags & PARSE_OPT_LITERAL_ARGHELP) ||\n\t\t!opts->argh || !!strpbrk(opts->argh, \"()<>[]|\");\n\tif (opts->flags & PARSE_OPT_OPTARG)\n\t\tif (opts->long_name)\n\t\t\ts = literal ? \"[=%s]\" : \"[=<%s>]\";\n\t\telse\n\t\t\ts = literal ? \"[%s]\" : \"[<%s>]\";\n\telse\n\t\ts = literal ? \" %s\" : \" <%s>\";\n\treturn utf8_fprintf(outfile, s, opts->argh ? _(opts->argh) : _(\"...\"));\n}\n\nstatic int usage_indent(FILE *outfile)\n{\n\treturn fprintf(outfile, \"    \");\n}\n\n#define USAGE_OPTS_WIDTH 26\n\nstatic void usage_padding(FILE *outfile, size_t pos)\n{\n\tif (pos < USAGE_OPTS_WIDTH)\n\t\tfprintf(outfile, \"%*s\", USAGE_OPTS_WIDTH - (int)pos, \"\");\n\telse\n\t\tfprintf(outfile, \"\\n%*s\", USAGE_OPTS_WIDTH, \"\");\n}\n\nstatic const struct option *find_option_by_long_name(const struct option *opts,\n\t\t\t\t\t\t     const char *long_name)\n{\n\tfor (; opts->type != OPTION_END; opts++) {\n\t\tif (opts->long_name && !strcmp(opts->long_name, long_name))\n\t\t\treturn opts;\n\t}\n\treturn NULL;\n}\n\nstatic enum parse_opt_result usage_with_options_internal(struct parse_opt_ctx_t *ctx,\n\t\t\t\t\t\t\t const char * const *usagestr,\n\t\t\t\t\t\t\t const struct option *opts,\n\t\t\t\t\t\t\t int full, int err)\n{\n\tconst struct option *all_opts = opts;\n\tFILE *outfile = err ? stderr : stdout;\n\tint need_newline;\n\n\tconst char *usage_prefix = _(\"usage: %s\");\n\t/*\n\t * The translation could be anything, but we can count on\n\t * msgfmt(1)'s --check option to have asserted that \"%s\" is in\n\t * the translation. So compute the length of the \"usage: \"\n\t * part. We are assuming that the translator wasn't overly\n\t * clever and used e.g. \"%1$s\" instead of \"%s\", there's only\n\t * one \"%s\" in \"usage_prefix\" above, so there's no reason to\n\t * do so even with a RTL language.\n\t */\n\tsize_t usage_len = strlen(usage_prefix) - strlen(\"%s\");\n\t/*\n\t * TRANSLATORS: the colon here should align with the\n\t * one in \"usage: %s\" translation.\n\t */\n\tconst char *or_prefix = _(\"   or: %s\");\n\t/*\n\t * TRANSLATORS: You should only need to translate this format\n\t * string if your language is a RTL language (e.g. Arabic,\n\t * Hebrew etc.), not if it's a LTR language (e.g. German,\n\t * Russian, Chinese etc.).\n\t *\n\t * When a translated usage string has an embedded \"\\n\" it's\n\t * because options have wrapped to the next line. The line\n\t * after the \"\\n\" will then be padded to align with the\n\t * command name, such as N_(\"git cmd [opt]\\n<8\n\t * spaces>[opt2]\"), where the 8 spaces are the same length as\n\t * \"git cmd \".\n\t *\n\t * This format string prints out that already-translated\n\t * line. The \"%*s\" is whitespace padding to account for the\n\t * padding at the start of the line that we add in this\n\t * function. The \"%s\" is a line in the (hopefully already\n\t * translated) N_() usage string, which contained embedded\n\t * newlines before we split it up.\n\t */\n\tconst char *usage_continued = _(\"%*s%s\");\n\tconst char *prefix = usage_prefix;\n\tint saw_empty_line = 0;\n\n\tif (!usagestr)\n\t\treturn PARSE_OPT_HELP;\n\n\tif (!err && ctx && ctx->flags & PARSE_OPT_SHELL_EVAL)\n\t\tfprintf(outfile, \"cat <<\\\\EOF\\n\");\n\n\twhile (*usagestr) {\n\t\tconst char *str = _(*usagestr++);\n\t\tstruct string_list list = STRING_LIST_INIT_DUP;\n\t\tunsigned int j;\n\n\t\tif (!saw_empty_line && !*str)\n\t\t\tsaw_empty_line = 1;\n\n\t\tstring_list_split(&list, str, '\\n', -1);\n\t\tfor (j = 0; j < list.nr; j++) {\n\t\t\tconst char *line = list.items[j].string;\n\n\t\t\tif (saw_empty_line && *line)\n\t\t\t\tfprintf_ln(outfile, _(\"    %s\"), line);\n\t\t\telse if (saw_empty_line)\n\t\t\t\tfputc('\\n', outfile);\n\t\t\telse if (!j)\n\t\t\t\tfprintf_ln(outfile, prefix, line);\n\t\t\telse\n\t\t\t\tfprintf_ln(outfile, usage_continued,\n\t\t\t\t\t   (int)usage_len, \"\", line);\n\t\t}\n\t\tstring_list_clear(&list, 0);\n\n\t\tprefix = or_prefix;\n\t}\n\n\tneed_newline = 1;\n\n\tfor (; opts->type != OPTION_END; opts++) {\n\t\tsize_t pos;\n\t\tconst char *cp, *np;\n\t\tconst char *positive_name = NULL;\n\n\t\tif (opts->type == OPTION_SUBCOMMAND)\n\t\t\tcontinue;\n\t\tif (opts->type == OPTION_GROUP) {\n\t\t\tfputc('\\n', outfile);\n\t\t\tneed_newline = 0;\n\t\t\tif (*opts->help)\n\t\t\t\tfprintf(outfile, \"%s\\n\", _(opts->help));\n\t\t\tcontinue;\n\t\t}\n\t\tif (!full && (opts->flags & PARSE_OPT_HIDDEN))\n\t\t\tcontinue;\n\n\t\tif (need_newline) {\n\t\t\tfputc('\\n', outfile);\n\t\t\tneed_newline = 0;\n\t\t}\n\n\t\tpos = usage_indent(outfile);\n\t\tif (opts->short_name) {\n\t\t\tif (opts->flags & PARSE_OPT_NODASH)\n\t\t\t\tpos += fprintf(outfile, \"%c\", opts->short_name);\n\t\t\telse\n\t\t\t\tpos += fprintf(outfile, \"-%c\", opts->short_name);\n\t\t}\n\t\tif (opts->long_name && opts->short_name)\n\t\t\tpos += fprintf(outfile, \", \");\n\t\tif (opts->long_name) {\n\t\t\tconst char *long_name = opts->long_name;\n\t\t\tif ((opts->flags & PARSE_OPT_NONEG) ||\n\t\t\t    skip_prefix(long_name, \"no-\", &positive_name))\n\t\t\t\tpos += fprintf(outfile, \"--%s\", long_name);\n\t\t\telse\n\t\t\t\tpos += fprintf(outfile, \"--[no-]%s\", long_name);\n\t\t}\n\n\t\tif (opts->type == OPTION_NUMBER)\n\t\t\tpos += utf8_fprintf(outfile, _(\"-NUM\"));\n\n\t\tif ((opts->flags & PARSE_OPT_LITERAL_ARGHELP) ||\n\t\t    !(opts->flags & PARSE_OPT_NOARG))\n\t\t\tpos += usage_argh(opts, outfile);\n\n\t\tif (opts->type == OPTION_ALIAS) {\n\t\t\tusage_padding(outfile, pos);\n\t\t\tfprintf_ln(outfile, _(\"alias of --%s\"),\n\t\t\t\t   (const char *)opts->value);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (cp = opts->help ? _(opts->help) : \"\"; *cp; cp = np) {\n\t\t\tnp = strchrnul(cp, '\\n');\n\t\t\tif (*np)\n\t\t\t\tnp++;\n\t\t\tusage_padding(outfile, pos);\n\t\t\tfwrite(cp, 1, np - cp, outfile);\n\t\t\tpos = 0;\n\t\t}\n\t\tfputc('\\n', outfile);\n\n\t\tif (positive_name) {\n\t\t\tif (find_option_by_long_name(all_opts, positive_name))\n\t\t\t\tcontinue;\n\t\t\tpos = usage_indent(outfile);\n\t\t\tpos += fprintf(outfile, \"--%s\", positive_name);\n\t\t\tusage_padding(outfile, pos);\n\t\t\tfprintf_ln(outfile, _(\"opposite of --no-%s\"),\n\t\t\t\t   positive_name);\n\t\t}\n\t}\n\tfputc('\\n', outfile);\n\n\tif (!err && ctx && ctx->flags & PARSE_OPT_SHELL_EVAL)\n\t\tfputs(\"EOF\\n\", outfile);\n\n\treturn PARSE_OPT_HELP;\n}\n\nvoid NORETURN usage_with_options(const char * const *usagestr,\n\t\t\tconst struct option *opts)\n{\n\tusage_with_options_internal(NULL, usagestr, opts, 0, 1);\n\texit(129);\n}\n\nvoid NORETURN usage_msg_opt(const char *msg,\n\t\t   const char * const *usagestr,\n\t\t   const struct option *options)\n{\n\tdie_message(\"%s\\n\", msg); /* The extra \\n is intentional */\n\tusage_with_options(usagestr, options);\n}\n\nvoid NORETURN usage_msg_optf(const char * const fmt,\n\t\t\t     const char * const *usagestr,\n\t\t\t     const struct option *options, ...)\n{\n\tstruct strbuf msg = STRBUF_INIT;\n\tva_list ap;\n\tva_start(ap, options);\n\tstrbuf_vaddf(&msg, fmt, ap);\n\tva_end(ap);\n\n\tusage_msg_opt(msg.buf, usagestr, options);\n}\n\nvoid die_for_incompatible_opt4(int opt1, const char *opt1_name,\n\t\t\t       int opt2, const char *opt2_name,\n\t\t\t       int opt3, const char *opt3_name,\n\t\t\t       int opt4, const char *opt4_name)\n{\n\tint count = 0;\n\tconst char *options[4];\n\n\tif (opt1)\n\t\toptions[count++] = opt1_name;\n\tif (opt2)\n\t\toptions[count++] = opt2_name;\n\tif (opt3)\n\t\toptions[count++] = opt3_name;\n\tif (opt4)\n\t\toptions[count++] = opt4_name;\n\tswitch (count) {\n\tcase 4:\n\t\tdie(_(\"options '%s', '%s', '%s', and '%s' cannot be used together\"),\n\t\t    opt1_name, opt2_name, opt3_name, opt4_name);\n\t\tbreak;\n\tcase 3:\n\t\tdie(_(\"options '%s', '%s', and '%s' cannot be used together\"),\n\t\t    options[0], options[1], options[2]);\n\t\tbreak;\n\tcase 2:\n\t\tdie(_(\"options '%s' and '%s' cannot be used together\"),\n\t\t    options[0], options[1]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "008c0f32cfb3a72fbfb2218fe9ad97d0530b11b6",
  "sha1_ok": true,
  "size": 35854
}
