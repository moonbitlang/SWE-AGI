{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJsb2NrZmlsZS5oIgojaW5jbHVkZSAiYnVuZGxlLmgiCiNpbmNsdWRlICJvYmplY3Qtc3RvcmUuaCIKI2luY2x1ZGUgIm9iamVjdC5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJkaWZmLmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAibGlzdC1vYmplY3RzLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAiYXJndi1hcnJheS5oIgoKc3RhdGljIGNvbnN0IGNoYXIgYnVuZGxlX3NpZ25hdHVyZVtdID0gIiMgdjIgZ2l0IGJ1bmRsZVxuIjsKCnN0YXRpYyB2b2lkIGFkZF90b19yZWZfbGlzdChjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGNvbnN0IGNoYXIgKm5hbWUsCgkJc3RydWN0IHJlZl9saXN0ICpsaXN0KQp7CglBTExPQ19HUk9XKGxpc3QtPmxpc3QsIGxpc3QtPm5yICsgMSwgbGlzdC0+YWxsb2MpOwoJb2lkY3B5KCZsaXN0LT5saXN0W2xpc3QtPm5yXS5vaWQsIG9pZCk7CglsaXN0LT5saXN0W2xpc3QtPm5yXS5uYW1lID0geHN0cmR1cChuYW1lKTsKCWxpc3QtPm5yKys7Cn0KCnN0YXRpYyBpbnQgcGFyc2VfYnVuZGxlX2hlYWRlcihpbnQgZmQsIHN0cnVjdCBidW5kbGVfaGVhZGVyICpoZWFkZXIsCgkJCSAgICAgICBjb25zdCBjaGFyICpyZXBvcnRfcGF0aCkKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWludCBzdGF0dXMgPSAwOwoKCS8qIFRoZSBidW5kbGUgaGVhZGVyIGJlZ2lucyB3aXRoIHRoZSBzaWduYXR1cmUgKi8KCWlmIChzdHJidWZfZ2V0d2hvbGVsaW5lX2ZkKCZidWYsIGZkLCAnXG4nKSB8fAoJICAgIHN0cmNtcChidWYuYnVmLCBidW5kbGVfc2lnbmF0dXJlKSkgewoJCWlmIChyZXBvcnRfcGF0aCkKCQkJZXJyb3IoXygiJyVzJyBkb2VzIG5vdCBsb29rIGxpa2UgYSB2MiBidW5kbGUgZmlsZSIpLAoJCQkgICAgICByZXBvcnRfcGF0aCk7CgkJc3RhdHVzID0gLTE7CgkJZ290byBhYm9ydDsKCX0KCgkvKiBUaGUgYnVuZGxlIGhlYWRlciBlbmRzIHdpdGggYW4gZW1wdHkgbGluZSAqLwoJd2hpbGUgKCFzdHJidWZfZ2V0d2hvbGVsaW5lX2ZkKCZidWYsIGZkLCAnXG4nKSAmJgoJICAgICAgIGJ1Zi5sZW4gJiYgYnVmLmJ1ZlswXSAhPSAnXG4nKSB7CgkJc3RydWN0IG9iamVjdF9pZCBvaWQ7CgkJaW50IGlzX3ByZXJlcSA9IDA7CgkJY29uc3QgY2hhciAqcDsKCgkJaWYgKCpidWYuYnVmID09ICctJykgewoJCQlpc19wcmVyZXEgPSAxOwoJCQlzdHJidWZfcmVtb3ZlKCZidWYsIDAsIDEpOwoJCX0KCQlzdHJidWZfcnRyaW0oJmJ1Zik7CgoJCS8qCgkJICogVGlwIGxpbmVzIGhhdmUgb2JqZWN0IG5hbWUsIFNQLCBhbmQgcmVmbmFtZS4KCQkgKiBQcmVyZXF1aXNpdGVzIGhhdmUgb2JqZWN0IG5hbWUgdGhhdCBpcyBvcHRpb25hbGx5CgkJICogZm9sbG93ZWQgYnkgU1AgYW5kIHN1YmplY3QgbGluZS4KCQkgKi8KCQlpZiAocGFyc2Vfb2lkX2hleChidWYuYnVmLCAmb2lkLCAmcCkgfHwKCQkgICAgKCpwICYmICFpc3NwYWNlKCpwKSkgfHwKCQkgICAgKCFpc19wcmVyZXEgJiYgISpwKSkgewoJCQlpZiAocmVwb3J0X3BhdGgpCgkJCQllcnJvcihfKCJ1bnJlY29nbml6ZWQgaGVhZGVyOiAlcyVzICglZCkiKSwKCQkJCSAgICAgIChpc19wcmVyZXEgPyAiLSIgOiAiIiksIGJ1Zi5idWYsIChpbnQpYnVmLmxlbik7CgkJCXN0YXR1cyA9IC0xOwoJCQlicmVhazsKCQl9IGVsc2UgewoJCQlpZiAoaXNfcHJlcmVxKQoJCQkJYWRkX3RvX3JlZl9saXN0KCZvaWQsICIiLCAmaGVhZGVyLT5wcmVyZXF1aXNpdGVzKTsKCQkJZWxzZQoJCQkJYWRkX3RvX3JlZl9saXN0KCZvaWQsIHAgKyAxLCAmaGVhZGVyLT5yZWZlcmVuY2VzKTsKCQl9Cgl9CgogYWJvcnQ6CglpZiAoc3RhdHVzKSB7CgkJY2xvc2UoZmQpOwoJCWZkID0gLTE7Cgl9CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCXJldHVybiBmZDsKfQoKaW50IHJlYWRfYnVuZGxlX2hlYWRlcihjb25zdCBjaGFyICpwYXRoLCBzdHJ1Y3QgYnVuZGxlX2hlYWRlciAqaGVhZGVyKQp7CglpbnQgZmQgPSBvcGVuKHBhdGgsIE9fUkRPTkxZKTsKCglpZiAoZmQgPCAwKQoJCXJldHVybiBlcnJvcihfKCJjb3VsZCBub3Qgb3BlbiAnJXMnIiksIHBhdGgpOwoJcmV0dXJuIHBhcnNlX2J1bmRsZV9oZWFkZXIoZmQsIGhlYWRlciwgcGF0aCk7Cn0KCmludCBpc19idW5kbGUoY29uc3QgY2hhciAqcGF0aCwgaW50IHF1aWV0KQp7CglzdHJ1Y3QgYnVuZGxlX2hlYWRlciBoZWFkZXI7CglpbnQgZmQgPSBvcGVuKHBhdGgsIE9fUkRPTkxZKTsKCglpZiAoZmQgPCAwKQoJCXJldHVybiAwOwoJbWVtc2V0KCZoZWFkZXIsIDAsIHNpemVvZihoZWFkZXIpKTsKCWZkID0gcGFyc2VfYnVuZGxlX2hlYWRlcihmZCwgJmhlYWRlciwgcXVpZXQgPyBOVUxMIDogcGF0aCk7CglpZiAoZmQgPj0gMCkKCQljbG9zZShmZCk7CglyZXR1cm4gKGZkID49IDApOwp9CgpzdGF0aWMgaW50IGxpc3RfcmVmcyhzdHJ1Y3QgcmVmX2xpc3QgKnIsIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndikKewoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IHItPm5yOyBpKyspIHsKCQlpZiAoYXJnYyA+IDEpIHsKCQkJaW50IGo7CgkJCWZvciAoaiA9IDE7IGogPCBhcmdjOyBqKyspCgkJCQlpZiAoIXN0cmNtcChyLT5saXN0W2ldLm5hbWUsIGFyZ3Zbal0pKQoJCQkJCWJyZWFrOwoJCQlpZiAoaiA9PSBhcmdjKQoJCQkJY29udGludWU7CgkJfQoJCXByaW50ZigiJXMgJXNcbiIsIG9pZF90b19oZXgoJnItPmxpc3RbaV0ub2lkKSwKCQkJCXItPmxpc3RbaV0ubmFtZSk7Cgl9CglyZXR1cm4gMDsKfQoKLyogUmVtZW1iZXIgdG8gdXBkYXRlIG9iamVjdCBmbGFnIGFsbG9jYXRpb24gaW4gb2JqZWN0LmggKi8KI2RlZmluZSBQUkVSRVFfTUFSSyAoMXU8PDE2KQoKaW50IHZlcmlmeV9idW5kbGUoc3RydWN0IGJ1bmRsZV9oZWFkZXIgKmhlYWRlciwgaW50IHZlcmJvc2UpCnsKCS8qCgkgKiBEbyBmYXN0IGNoZWNrLCB0aGVuIGlmIGFueSBwcmVyZXFzIGFyZSBtaXNzaW5nIHRoZW4gZ28gbGluZSBieSBsaW5lCgkgKiB0byBiZSB2ZXJib3NlIGFib3V0IHRoZSBlcnJvcnMKCSAqLwoJc3RydWN0IHJlZl9saXN0ICpwID0gJmhlYWRlci0+cHJlcmVxdWlzaXRlczsKCXN0cnVjdCByZXZfaW5mbyByZXZzOwoJY29uc3QgY2hhciAqYXJndltdID0ge05VTEwsICItLWFsbCIsIE5VTEx9OwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJaW50IGksIHJldCA9IDAsIHJlcV9ucjsKCWNvbnN0IGNoYXIgKm1lc3NhZ2UgPSBfKCJSZXBvc2l0b3J5IGxhY2tzIHRoZXNlIHByZXJlcXVpc2l0ZSBjb21taXRzOiIpOwoKCWluaXRfcmV2aXNpb25zKCZyZXZzLCBOVUxMKTsKCWZvciAoaSA9IDA7IGkgPCBwLT5ucjsgaSsrKSB7CgkJc3RydWN0IHJlZl9saXN0X2VudHJ5ICplID0gcC0+bGlzdCArIGk7CgkJc3RydWN0IG9iamVjdCAqbyA9IHBhcnNlX29iamVjdCgmZS0+b2lkKTsKCQlpZiAobykgewoJCQlvLT5mbGFncyB8PSBQUkVSRVFfTUFSSzsKCQkJYWRkX3BlbmRpbmdfb2JqZWN0KCZyZXZzLCBvLCBlLT5uYW1lKTsKCQkJY29udGludWU7CgkJfQoJCWlmICgrK3JldCA9PSAxKQoJCQllcnJvcigiJXMiLCBtZXNzYWdlKTsKCQllcnJvcigiJXMgJXMiLCBvaWRfdG9faGV4KCZlLT5vaWQpLCBlLT5uYW1lKTsKCX0KCWlmIChyZXZzLnBlbmRpbmcubnIgIT0gcC0+bnIpCgkJcmV0dXJuIHJldDsKCXJlcV9uciA9IHJldnMucGVuZGluZy5ucjsKCXNldHVwX3JldmlzaW9ucygyLCBhcmd2LCAmcmV2cywgTlVMTCk7CgoJaWYgKHByZXBhcmVfcmV2aXNpb25fd2FsaygmcmV2cykpCgkJZGllKF8oInJldmlzaW9uIHdhbGsgc2V0dXAgZmFpbGVkIikpOwoKCWkgPSByZXFfbnI7Cgl3aGlsZSAoaSAmJiAoY29tbWl0ID0gZ2V0X3JldmlzaW9uKCZyZXZzKSkpCgkJaWYgKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgUFJFUkVRX01BUkspCgkJCWktLTsKCglmb3IgKGkgPSAwOyBpIDwgcC0+bnI7IGkrKykgewoJCXN0cnVjdCByZWZfbGlzdF9lbnRyeSAqZSA9IHAtPmxpc3QgKyBpOwoJCXN0cnVjdCBvYmplY3QgKm8gPSBwYXJzZV9vYmplY3QoJmUtPm9pZCk7CgkJYXNzZXJ0KG8pOyAvKiBvdGhlcndpc2Ugd2UnZCBoYXZlIHJldHVybmVkIGVhcmx5ICovCgkJaWYgKG8tPmZsYWdzICYgU0hPV04pCgkJCWNvbnRpbnVlOwoJCWlmICgrK3JldCA9PSAxKQoJCQllcnJvcigiJXMiLCBtZXNzYWdlKTsKCQllcnJvcigiJXMgJXMiLCBvaWRfdG9faGV4KCZlLT5vaWQpLCBlLT5uYW1lKTsKCX0KCgkvKiBDbGVhbiB1cCBvYmplY3RzIHVzZWQsIGFzIHRoZXkgd2lsbCBiZSByZXVzZWQuICovCglmb3IgKGkgPSAwOyBpIDwgcC0+bnI7IGkrKykgewoJCXN0cnVjdCByZWZfbGlzdF9lbnRyeSAqZSA9IHAtPmxpc3QgKyBpOwoJCWNvbW1pdCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseSgmZS0+b2lkLCAxKTsKCQlpZiAoY29tbWl0KQoJCQljbGVhcl9jb21taXRfbWFya3MoY29tbWl0LCBBTExfUkVWX0ZMQUdTKTsKCX0KCglpZiAodmVyYm9zZSkgewoJCXN0cnVjdCByZWZfbGlzdCAqcjsKCgkJciA9ICZoZWFkZXItPnJlZmVyZW5jZXM7CgkJcHJpbnRmX2xuKFFfKCJUaGUgYnVuZGxlIGNvbnRhaW5zIHRoaXMgcmVmOiIsCgkJCSAgICAgIlRoZSBidW5kbGUgY29udGFpbnMgdGhlc2UgJWQgcmVmczoiLAoJCQkgICAgIHItPm5yKSwKCQkJICByLT5ucik7CgkJbGlzdF9yZWZzKHIsIDAsIE5VTEwpOwoJCXIgPSAmaGVhZGVyLT5wcmVyZXF1aXNpdGVzOwoJCWlmICghci0+bnIpIHsKCQkJcHJpbnRmX2xuKF8oIlRoZSBidW5kbGUgcmVjb3JkcyBhIGNvbXBsZXRlIGhpc3RvcnkuIikpOwoJCX0gZWxzZSB7CgkJCXByaW50Zl9sbihRXygiVGhlIGJ1bmRsZSByZXF1aXJlcyB0aGlzIHJlZjoiLAoJCQkJICAgICAiVGhlIGJ1bmRsZSByZXF1aXJlcyB0aGVzZSAlZCByZWZzOiIsCgkJCQkgICAgIHItPm5yKSwKCQkJCSAgci0+bnIpOwoJCQlsaXN0X3JlZnMociwgMCwgTlVMTCk7CgkJfQoJfQoJcmV0dXJuIHJldDsKfQoKaW50IGxpc3RfYnVuZGxlX3JlZnMoc3RydWN0IGJ1bmRsZV9oZWFkZXIgKmhlYWRlciwgaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2KQp7CglyZXR1cm4gbGlzdF9yZWZzKCZoZWFkZXItPnJlZmVyZW5jZXMsIGFyZ2MsIGFyZ3YpOwp9CgpzdGF0aWMgaW50IGlzX3RhZ19pbl9kYXRlX3JhbmdlKHN0cnVjdCBvYmplY3QgKnRhZywgc3RydWN0IHJldl9pbmZvICpyZXZzKQp7Cgl1bnNpZ25lZCBsb25nIHNpemU7CgllbnVtIG9iamVjdF90eXBlIHR5cGU7CgljaGFyICpidWYgPSBOVUxMLCAqbGluZSwgKmxpbmVlbmQ7Cgl0aW1lc3RhbXBfdCBkYXRlOwoJaW50IHJlc3VsdCA9IDE7CgoJaWYgKHJldnMtPm1heF9hZ2UgPT0gLTEgJiYgcmV2cy0+bWluX2FnZSA9PSAtMSkKCQlnb3RvIG91dDsKCglidWYgPSByZWFkX29iamVjdF9maWxlKCZ0YWctPm9pZCwgJnR5cGUsICZzaXplKTsKCWlmICghYnVmKQoJCWdvdG8gb3V0OwoJbGluZSA9IG1lbW1lbShidWYsIHNpemUsICJcbnRhZ2dlciAiLCA4KTsKCWlmICghbGluZSsrKQoJCWdvdG8gb3V0OwoJbGluZWVuZCA9IG1lbWNocihsaW5lLCAnXG4nLCBidWYgKyBzaXplIC0gbGluZSk7CglsaW5lID0gbWVtY2hyKGxpbmUsICc+JywgbGluZWVuZCA/IGxpbmVlbmQgLSBsaW5lIDogYnVmICsgc2l6ZSAtIGxpbmUpOwoJaWYgKCFsaW5lKyspCgkJZ290byBvdXQ7CglkYXRlID0gcGFyc2VfdGltZXN0YW1wKGxpbmUsIE5VTEwsIDEwKTsKCXJlc3VsdCA9IChyZXZzLT5tYXhfYWdlID09IC0xIHx8IHJldnMtPm1heF9hZ2UgPCBkYXRlKSAmJgoJCShyZXZzLT5taW5fYWdlID09IC0xIHx8IHJldnMtPm1pbl9hZ2UgPiBkYXRlKTsKb3V0OgoJZnJlZShidWYpOwoJcmV0dXJuIHJlc3VsdDsKfQoKCi8qIFdyaXRlIHRoZSBwYWNrIGRhdGEgdG8gYnVuZGxlX2ZkLCB0aGVuIGNsb3NlIGl0IGlmIGl0IGlzID4gMS4gKi8Kc3RhdGljIGludCB3cml0ZV9wYWNrX2RhdGEoaW50IGJ1bmRsZV9mZCwgc3RydWN0IHJldl9pbmZvICpyZXZzKQp7CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBwYWNrX29iamVjdHMgPSBDSElMRF9QUk9DRVNTX0lOSVQ7CglpbnQgaTsKCglhcmd2X2FycmF5X3B1c2hsKCZwYWNrX29iamVjdHMuYXJncywKCQkJICJwYWNrLW9iamVjdHMiLCAiLS1hbGwtcHJvZ3Jlc3MtaW1wbGllZCIsCgkJCSAiLS1zdGRvdXQiLCAiLS10aGluIiwgIi0tZGVsdGEtYmFzZS1vZmZzZXQiLAoJCQkgTlVMTCk7CglwYWNrX29iamVjdHMuaW4gPSAtMTsKCXBhY2tfb2JqZWN0cy5vdXQgPSBidW5kbGVfZmQ7CglwYWNrX29iamVjdHMuZ2l0X2NtZCA9IDE7CglpZiAoc3RhcnRfY29tbWFuZCgmcGFja19vYmplY3RzKSkKCQlyZXR1cm4gZXJyb3IoXygiQ291bGQgbm90IHNwYXduIHBhY2stb2JqZWN0cyIpKTsKCglmb3IgKGkgPSAwOyBpIDwgcmV2cy0+cGVuZGluZy5ucjsgaSsrKSB7CgkJc3RydWN0IG9iamVjdCAqb2JqZWN0ID0gcmV2cy0+cGVuZGluZy5vYmplY3RzW2ldLml0ZW07CgkJaWYgKG9iamVjdC0+ZmxhZ3MgJiBVTklOVEVSRVNUSU5HKQoJCQl3cml0ZV9vcl9kaWUocGFja19vYmplY3RzLmluLCAiXiIsIDEpOwoJCXdyaXRlX29yX2RpZShwYWNrX29iamVjdHMuaW4sIG9pZF90b19oZXgoJm9iamVjdC0+b2lkKSwgR0lUX1NIQTFfSEVYU1opOwoJCXdyaXRlX29yX2RpZShwYWNrX29iamVjdHMuaW4sICJcbiIsIDEpOwoJfQoJY2xvc2UocGFja19vYmplY3RzLmluKTsKCWlmIChmaW5pc2hfY29tbWFuZCgmcGFja19vYmplY3RzKSkKCQlyZXR1cm4gZXJyb3IoXygicGFjay1vYmplY3RzIGRpZWQiKSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBjb21wdXRlX2FuZF93cml0ZV9wcmVyZXF1aXNpdGVzKGludCBidW5kbGVfZmQsCgkJCQkJICAgc3RydWN0IHJldl9pbmZvICpyZXZzLAoJCQkJCSAgIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndikKewoJc3RydWN0IGNoaWxkX3Byb2Nlc3MgcmxzID0gQ0hJTERfUFJPQ0VTU19JTklUOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCUZJTEUgKnJsc19mb3V0OwoJaW50IGk7CgoJYXJndl9hcnJheV9wdXNobCgmcmxzLmFyZ3MsCgkJCSAicmV2LWxpc3QiLCAiLS1ib3VuZGFyeSIsICItLXByZXR0eT1vbmVsaW5lIiwKCQkJIE5VTEwpOwoJZm9yIChpID0gMTsgaSA8IGFyZ2M7IGkrKykKCQlhcmd2X2FycmF5X3B1c2goJnJscy5hcmdzLCBhcmd2W2ldKTsKCXJscy5vdXQgPSAtMTsKCXJscy5naXRfY21kID0gMTsKCWlmIChzdGFydF9jb21tYW5kKCZybHMpKQoJCXJldHVybiAtMTsKCXJsc19mb3V0ID0geGZkb3BlbihybHMub3V0LCAiciIpOwoJd2hpbGUgKHN0cmJ1Zl9nZXR3aG9sZWxpbmUoJmJ1ZiwgcmxzX2ZvdXQsICdcbicpICE9IEVPRikgewoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCWlmIChidWYubGVuID4gMCAmJiBidWYuYnVmWzBdID09ICctJykgewoJCQl3cml0ZV9vcl9kaWUoYnVuZGxlX2ZkLCBidWYuYnVmLCBidWYubGVuKTsKCQkJaWYgKCFnZXRfb2lkX2hleChidWYuYnVmICsgMSwgJm9pZCkpIHsKCQkJCXN0cnVjdCBvYmplY3QgKm9iamVjdCA9IHBhcnNlX29iamVjdF9vcl9kaWUoJm9pZCwKCQkJCQkJCQkJICAgIGJ1Zi5idWYpOwoJCQkJb2JqZWN0LT5mbGFncyB8PSBVTklOVEVSRVNUSU5HOwoJCQkJYWRkX3BlbmRpbmdfb2JqZWN0KHJldnMsIG9iamVjdCwgYnVmLmJ1Zik7CgkJCX0KCQl9IGVsc2UgaWYgKCFnZXRfb2lkX2hleChidWYuYnVmLCAmb2lkKSkgewoJCQlzdHJ1Y3Qgb2JqZWN0ICpvYmplY3QgPSBwYXJzZV9vYmplY3Rfb3JfZGllKCZvaWQsCgkJCQkJCQkJICAgIGJ1Zi5idWYpOwoJCQlvYmplY3QtPmZsYWdzIHw9IFNIT1dOOwoJCX0KCX0KCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJZmNsb3NlKHJsc19mb3V0KTsKCWlmIChmaW5pc2hfY29tbWFuZCgmcmxzKSkKCQlyZXR1cm4gZXJyb3IoXygicmV2LWxpc3QgZGllZCIpKTsKCXJldHVybiAwOwp9CgovKgogKiBXcml0ZSBvdXQgYnVuZGxlIHJlZnMgYmFzZWQgb24gdGhlIHRpcHMgYWxyZWFkeQogKiBwYXJzZWQgaW50byByZXZzLnBlbmRpbmcuIEFzIGEgc2lkZSBlZmZlY3QsIG1heQogKiBtYW5pcHVsYXRlIHJldnMucGVuZGluZyB0byBpbmNsdWRlIGFkZGl0aW9uYWwKICogbmVjZXNzYXJ5IG9iamVjdHMgKGxpa2UgdGFncykuCiAqCiAqIFJldHVybnMgdGhlIG51bWJlciBvZiByZWZzIHdyaXR0ZW4sIG9yIG5lZ2F0aXZlCiAqIG9uIGVycm9yLgogKi8Kc3RhdGljIGludCB3cml0ZV9idW5kbGVfcmVmcyhpbnQgYnVuZGxlX2ZkLCBzdHJ1Y3QgcmV2X2luZm8gKnJldnMpCnsKCWludCBpOwoJaW50IHJlZl9jb3VudCA9IDA7CgoJZm9yIChpID0gMDsgaSA8IHJldnMtPnBlbmRpbmcubnI7IGkrKykgewoJCXN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKmUgPSByZXZzLT5wZW5kaW5nLm9iamVjdHMgKyBpOwoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCWNoYXIgKnJlZjsKCQljb25zdCBjaGFyICpkaXNwbGF5X3JlZjsKCQlpbnQgZmxhZzsKCgkJaWYgKGUtPml0ZW0tPmZsYWdzICYgVU5JTlRFUkVTVElORykKCQkJY29udGludWU7CgkJaWYgKGR3aW1fcmVmKGUtPm5hbWUsIHN0cmxlbihlLT5uYW1lKSwgJm9pZCwgJnJlZikgIT0gMSkKCQkJZ290byBza2lwX3dyaXRlX3JlZjsKCQlpZiAocmVhZF9yZWZfZnVsbChlLT5uYW1lLCBSRVNPTFZFX1JFRl9SRUFESU5HLCAmb2lkLCAmZmxhZykpCgkJCWZsYWcgPSAwOwoJCWRpc3BsYXlfcmVmID0gKGZsYWcgJiBSRUZfSVNTWU1SRUYpID8gZS0+bmFtZSA6IHJlZjsKCgkJaWYgKGUtPml0ZW0tPnR5cGUgPT0gT0JKX1RBRyAmJgoJCQkJIWlzX3RhZ19pbl9kYXRlX3JhbmdlKGUtPml0ZW0sIHJldnMpKSB7CgkJCWUtPml0ZW0tPmZsYWdzIHw9IFVOSU5URVJFU1RJTkc7CgkJCWdvdG8gc2tpcF93cml0ZV9yZWY7CgkJfQoKCQkvKgoJCSAqIE1ha2Ugc3VyZSB0aGUgcmVmcyB3ZSB3cm90ZSBvdXQgaXMgY29ycmVjdDsgLS1tYXgtY291bnQgYW5kCgkJICogb3RoZXIgbGltaXRpbmcgb3B0aW9ucyBjb3VsZCBoYXZlIHByZXZlbnRlZCBhbGwgdGhlIHRpcHMKCQkgKiBmcm9tIGdldHRpbmcgb3V0cHV0LgoJCSAqCgkJICogTm9uIGNvbW1pdCBvYmplY3RzIHN1Y2ggYXMgdGFncyBhbmQgYmxvYnMgZG8gbm90IGhhdmUKCQkgKiB0aGlzIGlzc3VlIGFzIHRoZXkgYXJlIG5vdCBhZmZlY3RlZCBieSB0aG9zZSBleHRyYQoJCSAqIGNvbnN0cmFpbnRzLgoJCSAqLwoJCWlmICghKGUtPml0ZW0tPmZsYWdzICYgU0hPV04pICYmIGUtPml0ZW0tPnR5cGUgPT0gT0JKX0NPTU1JVCkgewoJCQl3YXJuaW5nKF8oInJlZiAnJXMnIGlzIGV4Y2x1ZGVkIGJ5IHRoZSByZXYtbGlzdCBvcHRpb25zIiksCgkJCQllLT5uYW1lKTsKCQkJZ290byBza2lwX3dyaXRlX3JlZjsKCQl9CgkJLyoKCQkgKiBJZiB5b3UgcnVuICJnaXQgYnVuZGxlIGNyZWF0ZSBibmRsIHYxLjAuLnYyLjAiLCB0aGUKCQkgKiBuYW1lIG9mIHRoZSBwb3NpdGl2ZSByZWYgaXMgInYyLjAiIGJ1dCB0aGF0IGlzIHRoZQoJCSAqIGNvbW1pdCB0aGF0IGlzIHJlZmVyZW5jZWQgYnkgdGhlIHRhZywgYW5kIG5vdCB0aGUgdGFnCgkJICogaXRzZWxmLgoJCSAqLwoJCWlmIChvaWRjbXAoJm9pZCwgJmUtPml0ZW0tPm9pZCkpIHsKCQkJLyoKCQkJICogSXMgdGhpcyB0aGUgcG9zaXRpdmUgZW5kIG9mIGEgcmFuZ2UgZXhwcmVzc2VkCgkJCSAqIGluIHRlcm1zIG9mIGEgdGFnIChlLmcuIHYyLjAgZnJvbSB0aGUgcmFuZ2UKCQkJICogInYxLjAuLnYyLjAiKT8KCQkJICovCgkJCXN0cnVjdCBjb21taXQgKm9uZSA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlKCZvaWQpOwoJCQlzdHJ1Y3Qgb2JqZWN0ICpvYmo7CgoJCQlpZiAoZS0+aXRlbSA9PSAmKG9uZS0+b2JqZWN0KSkgewoJCQkJLyoKCQkJCSAqIE5lZWQgdG8gaW5jbHVkZSBlLT5uYW1lIGFzIGFuCgkJCQkgKiBpbmRlcGVuZGVudCByZWYgdG8gdGhlIHBhY2stb2JqZWN0cwoJCQkJICogaW5wdXQsIHNvIHRoYXQgdGhlIHRhZyBpcyBpbmNsdWRlZAoJCQkJICogaW4gdGhlIG91dHB1dDsgb3RoZXJ3aXNlIHdlIHdvdWxkCgkJCQkgKiBlbmQgdXAgdHJpZ2dlcmluZyAiZW1wdHkgYnVuZGxlIgoJCQkJICogZXJyb3IuCgkJCQkgKi8KCQkJCW9iaiA9IHBhcnNlX29iamVjdF9vcl9kaWUoJm9pZCwgZS0+bmFtZSk7CgkJCQlvYmotPmZsYWdzIHw9IFNIT1dOOwoJCQkJYWRkX3BlbmRpbmdfb2JqZWN0KHJldnMsIG9iaiwgZS0+bmFtZSk7CgkJCX0KCQkJZ290byBza2lwX3dyaXRlX3JlZjsKCQl9CgoJCXJlZl9jb3VudCsrOwoJCXdyaXRlX29yX2RpZShidW5kbGVfZmQsIG9pZF90b19oZXgoJmUtPml0ZW0tPm9pZCksIDQwKTsKCQl3cml0ZV9vcl9kaWUoYnVuZGxlX2ZkLCAiICIsIDEpOwoJCXdyaXRlX29yX2RpZShidW5kbGVfZmQsIGRpc3BsYXlfcmVmLCBzdHJsZW4oZGlzcGxheV9yZWYpKTsKCQl3cml0ZV9vcl9kaWUoYnVuZGxlX2ZkLCAiXG4iLCAxKTsKIHNraXBfd3JpdGVfcmVmOgoJCWZyZWUocmVmKTsKCX0KCgkvKiBlbmQgaGVhZGVyICovCgl3cml0ZV9vcl9kaWUoYnVuZGxlX2ZkLCAiXG4iLCAxKTsKCXJldHVybiByZWZfY291bnQ7Cn0KCmludCBjcmVhdGVfYnVuZGxlKHN0cnVjdCBidW5kbGVfaGVhZGVyICpoZWFkZXIsIGNvbnN0IGNoYXIgKnBhdGgsCgkJICBpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YpCnsKCXN0YXRpYyBzdHJ1Y3QgbG9ja19maWxlIGxvY2s7CglpbnQgYnVuZGxlX2ZkID0gLTE7CglpbnQgYnVuZGxlX3RvX3N0ZG91dDsKCWludCByZWZfY291bnQgPSAwOwoJc3RydWN0IHJldl9pbmZvIHJldnM7CgoJYnVuZGxlX3RvX3N0ZG91dCA9ICFzdHJjbXAocGF0aCwgIi0iKTsKCWlmIChidW5kbGVfdG9fc3Rkb3V0KQoJCWJ1bmRsZV9mZCA9IDE7CgllbHNlIHsKCQlidW5kbGVfZmQgPSBob2xkX2xvY2tfZmlsZV9mb3JfdXBkYXRlKCZsb2NrLCBwYXRoLAoJCQkJCQkgICAgICBMT0NLX0RJRV9PTl9FUlJPUik7CgoJCS8qCgkJICogd3JpdGVfcGFja19kYXRhKCkgd2lsbCBjbG9zZSB0aGUgZmQgcGFzc2VkIHRvIGl0LAoJCSAqIGJ1dCBjb21taXRfbG9ja19maWxlKCkgd2lsbCBhbHNvIHRyeSB0byBjbG9zZSB0aGUKCQkgKiBsb2NrZmlsZSdzIGZkLiBTbyBtYWtlIGEgY29weSBvZiB0aGUgZmlsZQoJCSAqIGRlc2NyaXB0b3IgdG8gYXZvaWQgdHJ5aW5nIHRvIGNsb3NlIGl0IHR3aWNlLgoJCSAqLwoJCWJ1bmRsZV9mZCA9IGR1cChidW5kbGVfZmQpOwoJCWlmIChidW5kbGVfZmQgPCAwKQoJCQlkaWVfZXJybm8oInVuYWJsZSB0byBkdXAgZmlsZSBkZXNjcmlwdG9yIik7Cgl9CgoJLyogd3JpdGUgc2lnbmF0dXJlICovCgl3cml0ZV9vcl9kaWUoYnVuZGxlX2ZkLCBidW5kbGVfc2lnbmF0dXJlLCBzdHJsZW4oYnVuZGxlX3NpZ25hdHVyZSkpOwoKCS8qIGluaXQgcmV2cyB0byBsaXN0IG9iamVjdHMgZm9yIHBhY2stb2JqZWN0cyBsYXRlciAqLwoJc2F2ZV9jb21taXRfYnVmZmVyID0gMDsKCWluaXRfcmV2aXNpb25zKCZyZXZzLCBOVUxMKTsKCgkvKiB3cml0ZSBwcmVyZXF1aXNpdGVzICovCglpZiAoY29tcHV0ZV9hbmRfd3JpdGVfcHJlcmVxdWlzaXRlcyhidW5kbGVfZmQsICZyZXZzLCBhcmdjLCBhcmd2KSkKCQlnb3RvIGVycjsKCglhcmdjID0gc2V0dXBfcmV2aXNpb25zKGFyZ2MsIGFyZ3YsICZyZXZzLCBOVUxMKTsKCglpZiAoYXJnYyA+IDEpIHsKCQllcnJvcihfKCJ1bnJlY29nbml6ZWQgYXJndW1lbnQ6ICVzIiksIGFyZ3ZbMV0pOwoJCWdvdG8gZXJyOwoJfQoKCW9iamVjdF9hcnJheV9yZW1vdmVfZHVwbGljYXRlcygmcmV2cy5wZW5kaW5nKTsKCglyZWZfY291bnQgPSB3cml0ZV9idW5kbGVfcmVmcyhidW5kbGVfZmQsICZyZXZzKTsKCWlmICghcmVmX2NvdW50KQoJCWRpZShfKCJSZWZ1c2luZyB0byBjcmVhdGUgZW1wdHkgYnVuZGxlLiIpKTsKCWVsc2UgaWYgKHJlZl9jb3VudCA8IDApCgkJZ290byBlcnI7CgoJLyogd3JpdGUgcGFjayAqLwoJaWYgKHdyaXRlX3BhY2tfZGF0YShidW5kbGVfZmQsICZyZXZzKSkgewoJCWJ1bmRsZV9mZCA9IC0xOyAvKiBhbHJlYWR5IGNsb3NlZCBieSB0aGUgYWJvdmUgY2FsbCAqLwoJCWdvdG8gZXJyOwoJfQoKCWlmICghYnVuZGxlX3RvX3N0ZG91dCkgewoJCWlmIChjb21taXRfbG9ja19maWxlKCZsb2NrKSkKCQkJZGllX2Vycm5vKF8oImNhbm5vdCBjcmVhdGUgJyVzJyIpLCBwYXRoKTsKCX0KCXJldHVybiAwOwplcnI6CglpZiAoIWJ1bmRsZV90b19zdGRvdXQpIHsKCQlpZiAoMCA8PSBidW5kbGVfZmQpCgkJCWNsb3NlKGJ1bmRsZV9mZCk7CgkJcm9sbGJhY2tfbG9ja19maWxlKCZsb2NrKTsKCX0KCXJldHVybiAtMTsKfQoKaW50IHVuYnVuZGxlKHN0cnVjdCBidW5kbGVfaGVhZGVyICpoZWFkZXIsIGludCBidW5kbGVfZmQsIGludCBmbGFncykKewoJY29uc3QgY2hhciAqYXJndl9pbmRleF9wYWNrW10gPSB7ImluZGV4LXBhY2siLAoJCQkJCSAiLS1maXgtdGhpbiIsICItLXN0ZGluIiwgTlVMTCwgTlVMTH07CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBpcCA9IENISUxEX1BST0NFU1NfSU5JVDsKCglpZiAoZmxhZ3MgJiBCVU5ETEVfVkVSQk9TRSkKCQlhcmd2X2luZGV4X3BhY2tbM10gPSAiLXYiOwoKCWlmICh2ZXJpZnlfYnVuZGxlKGhlYWRlciwgMCkpCgkJcmV0dXJuIC0xOwoJaXAuYXJndiA9IGFyZ3ZfaW5kZXhfcGFjazsKCWlwLmluID0gYnVuZGxlX2ZkOwoJaXAubm9fc3Rkb3V0ID0gMTsKCWlwLmdpdF9jbWQgPSAxOwoJaWYgKHJ1bl9jb21tYW5kKCZpcCkpCgkJcmV0dXJuIGVycm9yKF8oImluZGV4LXBhY2sgZGllZCIpKTsKCXJldHVybiAwOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"lockfile.h\"\n#include \"bundle.h\"\n#include \"object-store.h\"\n#include \"object.h\"\n#include \"commit.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"list-objects.h\"\n#include \"run-command.h\"\n#include \"refs.h\"\n#include \"argv-array.h\"\n\nstatic const char bundle_signature[] = \"# v2 git bundle\\n\";\n\nstatic void add_to_ref_list(const struct object_id *oid, const char *name,\n\t\tstruct ref_list *list)\n{\n\tALLOC_GROW(list->list, list->nr + 1, list->alloc);\n\toidcpy(&list->list[list->nr].oid, oid);\n\tlist->list[list->nr].name = xstrdup(name);\n\tlist->nr++;\n}\n\nstatic int parse_bundle_header(int fd, struct bundle_header *header,\n\t\t\t       const char *report_path)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tint status = 0;\n\n\t/* The bundle header begins with the signature */\n\tif (strbuf_getwholeline_fd(&buf, fd, '\\n') ||\n\t    strcmp(buf.buf, bundle_signature)) {\n\t\tif (report_path)\n\t\t\terror(_(\"'%s' does not look like a v2 bundle file\"),\n\t\t\t      report_path);\n\t\tstatus = -1;\n\t\tgoto abort;\n\t}\n\n\t/* The bundle header ends with an empty line */\n\twhile (!strbuf_getwholeline_fd(&buf, fd, '\\n') &&\n\t       buf.len && buf.buf[0] != '\\n') {\n\t\tstruct object_id oid;\n\t\tint is_prereq = 0;\n\t\tconst char *p;\n\n\t\tif (*buf.buf == '-') {\n\t\t\tis_prereq = 1;\n\t\t\tstrbuf_remove(&buf, 0, 1);\n\t\t}\n\t\tstrbuf_rtrim(&buf);\n\n\t\t/*\n\t\t * Tip lines have object name, SP, and refname.\n\t\t * Prerequisites have object name that is optionally\n\t\t * followed by SP and subject line.\n\t\t */\n\t\tif (parse_oid_hex(buf.buf, &oid, &p) ||\n\t\t    (*p && !isspace(*p)) ||\n\t\t    (!is_prereq && !*p)) {\n\t\t\tif (report_path)\n\t\t\t\terror(_(\"unrecognized header: %s%s (%d)\"),\n\t\t\t\t      (is_prereq ? \"-\" : \"\"), buf.buf, (int)buf.len);\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (is_prereq)\n\t\t\t\tadd_to_ref_list(&oid, \"\", &header->prerequisites);\n\t\t\telse\n\t\t\t\tadd_to_ref_list(&oid, p + 1, &header->references);\n\t\t}\n\t}\n\n abort:\n\tif (status) {\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\n\tstrbuf_release(&buf);\n\treturn fd;\n}\n\nint read_bundle_header(const char *path, struct bundle_header *header)\n{\n\tint fd = open(path, O_RDONLY);\n\n\tif (fd < 0)\n\t\treturn error(_(\"could not open '%s'\"), path);\n\treturn parse_bundle_header(fd, header, path);\n}\n\nint is_bundle(const char *path, int quiet)\n{\n\tstruct bundle_header header;\n\tint fd = open(path, O_RDONLY);\n\n\tif (fd < 0)\n\t\treturn 0;\n\tmemset(&header, 0, sizeof(header));\n\tfd = parse_bundle_header(fd, &header, quiet ? NULL : path);\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn (fd >= 0);\n}\n\nstatic int list_refs(struct ref_list *r, int argc, const char **argv)\n{\n\tint i;\n\n\tfor (i = 0; i < r->nr; i++) {\n\t\tif (argc > 1) {\n\t\t\tint j;\n\t\t\tfor (j = 1; j < argc; j++)\n\t\t\t\tif (!strcmp(r->list[i].name, argv[j]))\n\t\t\t\t\tbreak;\n\t\t\tif (j == argc)\n\t\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"%s %s\\n\", oid_to_hex(&r->list[i].oid),\n\t\t\t\tr->list[i].name);\n\t}\n\treturn 0;\n}\n\n/* Remember to update object flag allocation in object.h */\n#define PREREQ_MARK (1u<<16)\n\nint verify_bundle(struct bundle_header *header, int verbose)\n{\n\t/*\n\t * Do fast check, then if any prereqs are missing then go line by line\n\t * to be verbose about the errors\n\t */\n\tstruct ref_list *p = &header->prerequisites;\n\tstruct rev_info revs;\n\tconst char *argv[] = {NULL, \"--all\", NULL};\n\tstruct commit *commit;\n\tint i, ret = 0, req_nr;\n\tconst char *message = _(\"Repository lacks these prerequisite commits:\");\n\n\tinit_revisions(&revs, NULL);\n\tfor (i = 0; i < p->nr; i++) {\n\t\tstruct ref_list_entry *e = p->list + i;\n\t\tstruct object *o = parse_object(&e->oid);\n\t\tif (o) {\n\t\t\to->flags |= PREREQ_MARK;\n\t\t\tadd_pending_object(&revs, o, e->name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (++ret == 1)\n\t\t\terror(\"%s\", message);\n\t\terror(\"%s %s\", oid_to_hex(&e->oid), e->name);\n\t}\n\tif (revs.pending.nr != p->nr)\n\t\treturn ret;\n\treq_nr = revs.pending.nr;\n\tsetup_revisions(2, argv, &revs, NULL);\n\n\tif (prepare_revision_walk(&revs))\n\t\tdie(_(\"revision walk setup failed\"));\n\n\ti = req_nr;\n\twhile (i && (commit = get_revision(&revs)))\n\t\tif (commit->object.flags & PREREQ_MARK)\n\t\t\ti--;\n\n\tfor (i = 0; i < p->nr; i++) {\n\t\tstruct ref_list_entry *e = p->list + i;\n\t\tstruct object *o = parse_object(&e->oid);\n\t\tassert(o); /* otherwise we'd have returned early */\n\t\tif (o->flags & SHOWN)\n\t\t\tcontinue;\n\t\tif (++ret == 1)\n\t\t\terror(\"%s\", message);\n\t\terror(\"%s %s\", oid_to_hex(&e->oid), e->name);\n\t}\n\n\t/* Clean up objects used, as they will be reused. */\n\tfor (i = 0; i < p->nr; i++) {\n\t\tstruct ref_list_entry *e = p->list + i;\n\t\tcommit = lookup_commit_reference_gently(&e->oid, 1);\n\t\tif (commit)\n\t\t\tclear_commit_marks(commit, ALL_REV_FLAGS);\n\t}\n\n\tif (verbose) {\n\t\tstruct ref_list *r;\n\n\t\tr = &header->references;\n\t\tprintf_ln(Q_(\"The bundle contains this ref:\",\n\t\t\t     \"The bundle contains these %d refs:\",\n\t\t\t     r->nr),\n\t\t\t  r->nr);\n\t\tlist_refs(r, 0, NULL);\n\t\tr = &header->prerequisites;\n\t\tif (!r->nr) {\n\t\t\tprintf_ln(_(\"The bundle records a complete history.\"));\n\t\t} else {\n\t\t\tprintf_ln(Q_(\"The bundle requires this ref:\",\n\t\t\t\t     \"The bundle requires these %d refs:\",\n\t\t\t\t     r->nr),\n\t\t\t\t  r->nr);\n\t\t\tlist_refs(r, 0, NULL);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint list_bundle_refs(struct bundle_header *header, int argc, const char **argv)\n{\n\treturn list_refs(&header->references, argc, argv);\n}\n\nstatic int is_tag_in_date_range(struct object *tag, struct rev_info *revs)\n{\n\tunsigned long size;\n\tenum object_type type;\n\tchar *buf = NULL, *line, *lineend;\n\ttimestamp_t date;\n\tint result = 1;\n\n\tif (revs->max_age == -1 && revs->min_age == -1)\n\t\tgoto out;\n\n\tbuf = read_object_file(&tag->oid, &type, &size);\n\tif (!buf)\n\t\tgoto out;\n\tline = memmem(buf, size, \"\\ntagger \", 8);\n\tif (!line++)\n\t\tgoto out;\n\tlineend = memchr(line, '\\n', buf + size - line);\n\tline = memchr(line, '>', lineend ? lineend - line : buf + size - line);\n\tif (!line++)\n\t\tgoto out;\n\tdate = parse_timestamp(line, NULL, 10);\n\tresult = (revs->max_age == -1 || revs->max_age < date) &&\n\t\t(revs->min_age == -1 || revs->min_age > date);\nout:\n\tfree(buf);\n\treturn result;\n}\n\n\n/* Write the pack data to bundle_fd, then close it if it is > 1. */\nstatic int write_pack_data(int bundle_fd, struct rev_info *revs)\n{\n\tstruct child_process pack_objects = CHILD_PROCESS_INIT;\n\tint i;\n\n\targv_array_pushl(&pack_objects.args,\n\t\t\t \"pack-objects\", \"--all-progress-implied\",\n\t\t\t \"--stdout\", \"--thin\", \"--delta-base-offset\",\n\t\t\t NULL);\n\tpack_objects.in = -1;\n\tpack_objects.out = bundle_fd;\n\tpack_objects.git_cmd = 1;\n\tif (start_command(&pack_objects))\n\t\treturn error(_(\"Could not spawn pack-objects\"));\n\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object *object = revs->pending.objects[i].item;\n\t\tif (object->flags & UNINTERESTING)\n\t\t\twrite_or_die(pack_objects.in, \"^\", 1);\n\t\twrite_or_die(pack_objects.in, oid_to_hex(&object->oid), GIT_SHA1_HEXSZ);\n\t\twrite_or_die(pack_objects.in, \"\\n\", 1);\n\t}\n\tclose(pack_objects.in);\n\tif (finish_command(&pack_objects))\n\t\treturn error(_(\"pack-objects died\"));\n\treturn 0;\n}\n\nstatic int compute_and_write_prerequisites(int bundle_fd,\n\t\t\t\t\t   struct rev_info *revs,\n\t\t\t\t\t   int argc, const char **argv)\n{\n\tstruct child_process rls = CHILD_PROCESS_INIT;\n\tstruct strbuf buf = STRBUF_INIT;\n\tFILE *rls_fout;\n\tint i;\n\n\targv_array_pushl(&rls.args,\n\t\t\t \"rev-list\", \"--boundary\", \"--pretty=oneline\",\n\t\t\t NULL);\n\tfor (i = 1; i < argc; i++)\n\t\targv_array_push(&rls.args, argv[i]);\n\trls.out = -1;\n\trls.git_cmd = 1;\n\tif (start_command(&rls))\n\t\treturn -1;\n\trls_fout = xfdopen(rls.out, \"r\");\n\twhile (strbuf_getwholeline(&buf, rls_fout, '\\n') != EOF) {\n\t\tstruct object_id oid;\n\t\tif (buf.len > 0 && buf.buf[0] == '-') {\n\t\t\twrite_or_die(bundle_fd, buf.buf, buf.len);\n\t\t\tif (!get_oid_hex(buf.buf + 1, &oid)) {\n\t\t\t\tstruct object *object = parse_object_or_die(&oid,\n\t\t\t\t\t\t\t\t\t    buf.buf);\n\t\t\t\tobject->flags |= UNINTERESTING;\n\t\t\t\tadd_pending_object(revs, object, buf.buf);\n\t\t\t}\n\t\t} else if (!get_oid_hex(buf.buf, &oid)) {\n\t\t\tstruct object *object = parse_object_or_die(&oid,\n\t\t\t\t\t\t\t\t    buf.buf);\n\t\t\tobject->flags |= SHOWN;\n\t\t}\n\t}\n\tstrbuf_release(&buf);\n\tfclose(rls_fout);\n\tif (finish_command(&rls))\n\t\treturn error(_(\"rev-list died\"));\n\treturn 0;\n}\n\n/*\n * Write out bundle refs based on the tips already\n * parsed into revs.pending. As a side effect, may\n * manipulate revs.pending to include additional\n * necessary objects (like tags).\n *\n * Returns the number of refs written, or negative\n * on error.\n */\nstatic int write_bundle_refs(int bundle_fd, struct rev_info *revs)\n{\n\tint i;\n\tint ref_count = 0;\n\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object_array_entry *e = revs->pending.objects + i;\n\t\tstruct object_id oid;\n\t\tchar *ref;\n\t\tconst char *display_ref;\n\t\tint flag;\n\n\t\tif (e->item->flags & UNINTERESTING)\n\t\t\tcontinue;\n\t\tif (dwim_ref(e->name, strlen(e->name), &oid, &ref) != 1)\n\t\t\tgoto skip_write_ref;\n\t\tif (read_ref_full(e->name, RESOLVE_REF_READING, &oid, &flag))\n\t\t\tflag = 0;\n\t\tdisplay_ref = (flag & REF_ISSYMREF) ? e->name : ref;\n\n\t\tif (e->item->type == OBJ_TAG &&\n\t\t\t\t!is_tag_in_date_range(e->item, revs)) {\n\t\t\te->item->flags |= UNINTERESTING;\n\t\t\tgoto skip_write_ref;\n\t\t}\n\n\t\t/*\n\t\t * Make sure the refs we wrote out is correct; --max-count and\n\t\t * other limiting options could have prevented all the tips\n\t\t * from getting output.\n\t\t *\n\t\t * Non commit objects such as tags and blobs do not have\n\t\t * this issue as they are not affected by those extra\n\t\t * constraints.\n\t\t */\n\t\tif (!(e->item->flags & SHOWN) && e->item->type == OBJ_COMMIT) {\n\t\t\twarning(_(\"ref '%s' is excluded by the rev-list options\"),\n\t\t\t\te->name);\n\t\t\tgoto skip_write_ref;\n\t\t}\n\t\t/*\n\t\t * If you run \"git bundle create bndl v1.0..v2.0\", the\n\t\t * name of the positive ref is \"v2.0\" but that is the\n\t\t * commit that is referenced by the tag, and not the tag\n\t\t * itself.\n\t\t */\n\t\tif (oidcmp(&oid, &e->item->oid)) {\n\t\t\t/*\n\t\t\t * Is this the positive end of a range expressed\n\t\t\t * in terms of a tag (e.g. v2.0 from the range\n\t\t\t * \"v1.0..v2.0\")?\n\t\t\t */\n\t\t\tstruct commit *one = lookup_commit_reference(&oid);\n\t\t\tstruct object *obj;\n\n\t\t\tif (e->item == &(one->object)) {\n\t\t\t\t/*\n\t\t\t\t * Need to include e->name as an\n\t\t\t\t * independent ref to the pack-objects\n\t\t\t\t * input, so that the tag is included\n\t\t\t\t * in the output; otherwise we would\n\t\t\t\t * end up triggering \"empty bundle\"\n\t\t\t\t * error.\n\t\t\t\t */\n\t\t\t\tobj = parse_object_or_die(&oid, e->name);\n\t\t\t\tobj->flags |= SHOWN;\n\t\t\t\tadd_pending_object(revs, obj, e->name);\n\t\t\t}\n\t\t\tgoto skip_write_ref;\n\t\t}\n\n\t\tref_count++;\n\t\twrite_or_die(bundle_fd, oid_to_hex(&e->item->oid), 40);\n\t\twrite_or_die(bundle_fd, \" \", 1);\n\t\twrite_or_die(bundle_fd, display_ref, strlen(display_ref));\n\t\twrite_or_die(bundle_fd, \"\\n\", 1);\n skip_write_ref:\n\t\tfree(ref);\n\t}\n\n\t/* end header */\n\twrite_or_die(bundle_fd, \"\\n\", 1);\n\treturn ref_count;\n}\n\nint create_bundle(struct bundle_header *header, const char *path,\n\t\t  int argc, const char **argv)\n{\n\tstatic struct lock_file lock;\n\tint bundle_fd = -1;\n\tint bundle_to_stdout;\n\tint ref_count = 0;\n\tstruct rev_info revs;\n\n\tbundle_to_stdout = !strcmp(path, \"-\");\n\tif (bundle_to_stdout)\n\t\tbundle_fd = 1;\n\telse {\n\t\tbundle_fd = hold_lock_file_for_update(&lock, path,\n\t\t\t\t\t\t      LOCK_DIE_ON_ERROR);\n\n\t\t/*\n\t\t * write_pack_data() will close the fd passed to it,\n\t\t * but commit_lock_file() will also try to close the\n\t\t * lockfile's fd. So make a copy of the file\n\t\t * descriptor to avoid trying to close it twice.\n\t\t */\n\t\tbundle_fd = dup(bundle_fd);\n\t\tif (bundle_fd < 0)\n\t\t\tdie_errno(\"unable to dup file descriptor\");\n\t}\n\n\t/* write signature */\n\twrite_or_die(bundle_fd, bundle_signature, strlen(bundle_signature));\n\n\t/* init revs to list objects for pack-objects later */\n\tsave_commit_buffer = 0;\n\tinit_revisions(&revs, NULL);\n\n\t/* write prerequisites */\n\tif (compute_and_write_prerequisites(bundle_fd, &revs, argc, argv))\n\t\tgoto err;\n\n\targc = setup_revisions(argc, argv, &revs, NULL);\n\n\tif (argc > 1) {\n\t\terror(_(\"unrecognized argument: %s\"), argv[1]);\n\t\tgoto err;\n\t}\n\n\tobject_array_remove_duplicates(&revs.pending);\n\n\tref_count = write_bundle_refs(bundle_fd, &revs);\n\tif (!ref_count)\n\t\tdie(_(\"Refusing to create empty bundle.\"));\n\telse if (ref_count < 0)\n\t\tgoto err;\n\n\t/* write pack */\n\tif (write_pack_data(bundle_fd, &revs)) {\n\t\tbundle_fd = -1; /* already closed by the above call */\n\t\tgoto err;\n\t}\n\n\tif (!bundle_to_stdout) {\n\t\tif (commit_lock_file(&lock))\n\t\t\tdie_errno(_(\"cannot create '%s'\"), path);\n\t}\n\treturn 0;\nerr:\n\tif (!bundle_to_stdout) {\n\t\tif (0 <= bundle_fd)\n\t\t\tclose(bundle_fd);\n\t\trollback_lock_file(&lock);\n\t}\n\treturn -1;\n}\n\nint unbundle(struct bundle_header *header, int bundle_fd, int flags)\n{\n\tconst char *argv_index_pack[] = {\"index-pack\",\n\t\t\t\t\t \"--fix-thin\", \"--stdin\", NULL, NULL};\n\tstruct child_process ip = CHILD_PROCESS_INIT;\n\n\tif (flags & BUNDLE_VERBOSE)\n\t\targv_index_pack[3] = \"-v\";\n\n\tif (verify_bundle(header, 0))\n\t\treturn -1;\n\tip.argv = argv_index_pack;\n\tip.in = bundle_fd;\n\tip.no_stdout = 1;\n\tip.git_cmd = 1;\n\tif (run_command(&ip))\n\t\treturn error(_(\"index-pack died\"));\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00ada05f46c80c959253b418bc25a40478721654",
  "sha1_ok": true,
  "size": 12754
}
