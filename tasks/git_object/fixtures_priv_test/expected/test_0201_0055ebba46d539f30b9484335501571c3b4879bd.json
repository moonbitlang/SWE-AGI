{
  "content": {
    "base64": "IyBUZXN0IGZyYW1ld29yayBmb3IgZ2l0LiAgU2VlIHQvUkVBRE1FIGZvciB1c2FnZS4KIwojIENvcHlyaWdodCAoYykgMjAwNSBKdW5pbyBDIEhhbWFubwojCiMgVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkKIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieQojIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDIgb2YgdGhlIExpY2Vuc2UsIG9yCiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi4KIwojIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLAojIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mCiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZQojIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuCiMKIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQojIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiAgSWYgbm90LCBzZWUgaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLyAuCgojIFRlc3QgdGhlIGJpbmFyaWVzIHdlIGhhdmUganVzdCBidWlsdC4gIFRoZSB0ZXN0cyBhcmUga2VwdCBpbgojIHQvIHN1YmRpcmVjdG9yeSBhbmQgYXJlIHJ1biBpbiAndHJhc2ggZGlyZWN0b3J5JyBzdWJkaXJlY3RvcnkuCmlmIHRlc3QgLXogIiRURVNUX0RJUkVDVE9SWSIKdGhlbgoJIyBXZSBhbGxvdyB0ZXN0cyB0byBvdmVycmlkZSB0aGlzLCBpbiBjYXNlIHRoZXkgd2FudCB0byBydW4gdGVzdHMKCSMgb3V0c2lkZSBvZiB0LywgZS5nLiBmb3IgcnVubmluZyB0ZXN0cyBvbiB0aGUgdGVzdCBsaWJyYXJ5CgkjIGl0c2VsZi4KCVRFU1RfRElSRUNUT1JZPSQocHdkKQplbHNlCgkjIGVuc3VyZSB0aGF0IFRFU1RfRElSRUNUT1JZIGlzIGFuIGFic29sdXRlIHBhdGggc28gdGhhdCBpdAoJIyBpcyB2YWxpZCBldmVuIGlmIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5IGlzIGNoYW5nZWQKCVRFU1RfRElSRUNUT1JZPSQoY2QgIiRURVNUX0RJUkVDVE9SWSIgJiYgcHdkKSB8fCBleGl0IDEKZmkKaWYgdGVzdCAteiAiJFRFU1RfT1VUUFVUX0RJUkVDVE9SWSIKdGhlbgoJIyBTaW1pbGFybHksIG92ZXJyaWRlIHRoaXMgdG8gc3RvcmUgdGhlIHRlc3QtcmVzdWx0cyBzdWJkaXIKCSMgZWxzZXdoZXJlCglURVNUX09VVFBVVF9ESVJFQ1RPUlk9JFRFU1RfRElSRUNUT1JZCmZpCkdJVF9CVUlMRF9ESVI9IiRURVNUX0RJUkVDVE9SWSIvLi4KCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKIyBJdCBhcHBlYXJzIHRoYXQgcGVvcGxlIHRyeSB0byBydW4gdGVzdHMgd2l0aG91dCBidWlsZGluZy4uLgoiJEdJVF9CVUlMRF9ESVIvZ2l0IiA+L2Rldi9udWxsCmlmIHRlc3QgJD8gIT0gMQp0aGVuCgllY2hvID4mMiAnZXJyb3I6IHlvdSBkbyBub3Qgc2VlbSB0byBoYXZlIGJ1aWx0IGdpdCB5ZXQuJwoJZXhpdCAxCmZpCgouICIkR0lUX0JVSUxEX0RJUiIvR0lULUJVSUxELU9QVElPTlMKZXhwb3J0IFBFUkxfUEFUSCBTSEVMTF9QQVRICgojIGlmIC0tdGVlIHdhcyBwYXNzZWQsIHdyaXRlIHRoZSBvdXRwdXQgbm90IG9ubHkgdG8gdGhlIHRlcm1pbmFsLCBidXQKIyBhZGRpdGlvbmFsbHkgdG8gdGhlIGZpbGUgdGVzdC1yZXN1bHRzLyRCQVNFTkFNRS5vdXQsIHRvby4KY2FzZSAiJEdJVF9URVNUX1RFRV9TVEFSVEVELCAkKiAiIGluCmRvbmUsKikKCSMgZG8gbm90IHJlZGlyZWN0IGFnYWluCgk7OwoqJyAtLXRlZSAnKnwqJyAtLXZhJyopCglta2RpciAtcCAiJFRFU1RfT1VUUFVUX0RJUkVDVE9SWS90ZXN0LXJlc3VsdHMiCglCQVNFPSIkVEVTVF9PVVRQVVRfRElSRUNUT1JZL3Rlc3QtcmVzdWx0cy8kKGJhc2VuYW1lICIkMCIgLnNoKSIKCShHSVRfVEVTVF9URUVfU1RBUlRFRD1kb25lICR7U0hFTExfUEFUSH0gIiQwIiAiJEAiIDI+JjE7CgkgZWNobyAkPyA+ICRCQVNFLmV4aXQpIHwgdGVlICRCQVNFLm91dAoJdGVzdCAiJChjYXQgJEJBU0UuZXhpdCkiID0gMAoJZXhpdAoJOzsKZXNhYwoKIyBGb3IgcmVwZWF0YWJpbGl0eSwgcmVzZXQgdGhlIGVudmlyb25tZW50IHRvIGtub3duIHZhbHVlLgojIFRFUk0gaXMgc2FuaXRpemVkIGJlbG93LCBhZnRlciBzYXZpbmcgY29sb3IgY29udHJvbCBzZXF1ZW5jZXMuCkxBTkc9QwpMQ19BTEw9QwpQQUdFUj1jYXQKVFo9VVRDCmV4cG9ydCBMQU5HIExDX0FMTCBQQUdFUiBUWgpFRElUT1I9OgojIEEgY2FsbCB0byAidW5zZXQiIHdpdGggbm8gYXJndW1lbnRzIGNhdXNlcyBhdCBsZWFzdCBTb2xhcmlzIDEwCiMgL3Vzci94cGc0L2Jpbi9zaCBhbmQgL2Jpbi9rc2ggdG8gYmFpbCBvdXQuICBTbyBrZWVwIHRoZSB1bnNldHMKIyBkZXJpdmluZyBmcm9tIHRoZSBjb21tYW5kIHN1YnN0aXR1dGlvbiBjbHVzdGVyZWQgd2l0aCB0aGUgb3RoZXIKIyBvbmVzLgp1bnNldCBWSVNVQUwgRU1BSUwgTEFOR1VBR0UgQ09MVU1OUyAkKCIkUEVSTF9QQVRIIiAtZSAnCglteSBAZW52ID0ga2V5cyAlRU5WOwoJbXkgJG9rID0gam9pbigifCIsIHF3KAoJCVRSQUNFCgkJREVCVUcKCQlVU0VfTE9PS1VQCgkJVEVTVAoJCS4qX1RFU1QKCQlQUk9WRQoJCVZBTEdSSU5ECgkJVU5aSVAKCQlQRVJGXwoJCUNVUkxfVkVSQk9TRQoJKSk7CglteSBAdmFycyA9IGdyZXAoL15HSVRfLyAmJiAhL15HSVRfKCRvaykvbywgQGVudik7CglwcmludCBqb2luKCJcbiIsIEB2YXJzKTsKJykKdW5zZXQgWERHX0NPTkZJR19IT01FCnVuc2V0IEdJVFBFUkxMSUIKR0lUX0FVVEhPUl9FTUFJTD1hdXRob3JAZXhhbXBsZS5jb20KR0lUX0FVVEhPUl9OQU1FPSdBIFUgVGhvcicKR0lUX0NPTU1JVFRFUl9FTUFJTD1jb21taXR0ZXJAZXhhbXBsZS5jb20KR0lUX0NPTU1JVFRFUl9OQU1FPSdDIE8gTWl0dGVyJwpHSVRfTUVSR0VfVkVSQk9TSVRZPTUKR0lUX01FUkdFX0FVVE9FRElUPW5vCmV4cG9ydCBHSVRfTUVSR0VfVkVSQk9TSVRZIEdJVF9NRVJHRV9BVVRPRURJVApleHBvcnQgR0lUX0FVVEhPUl9FTUFJTCBHSVRfQVVUSE9SX05BTUUKZXhwb3J0IEdJVF9DT01NSVRURVJfRU1BSUwgR0lUX0NPTU1JVFRFUl9OQU1FCmV4cG9ydCBFRElUT1IKCiMgVGVzdHMgdXNpbmcgR0lUX1RSQUNFIHR5cGljYWxseSBkb24ndCB3YW50IDx0aW1lc3RhbXA+IDxmaWxlPjo8bGluZT4gb3V0cHV0CkdJVF9UUkFDRV9CQVJFPTEKZXhwb3J0IEdJVF9UUkFDRV9CQVJFCgppZiB0ZXN0IC1uICIke1RFU1RfR0lUX0lOREVYX1ZFUlNJT046K2lzc2V0fSIKdGhlbgoJR0lUX0lOREVYX1ZFUlNJT049IiRURVNUX0dJVF9JTkRFWF9WRVJTSU9OIgoJZXhwb3J0IEdJVF9JTkRFWF9WRVJTSU9OCmZpCgojIEFkZCBsaWJjIE1BTExPQyBhbmQgTUFMTE9DX1BFUlRVUkIgdGVzdAojIG9ubHkgaWYgd2UgYXJlIG5vdCBleGVjdXRpbmcgdGhlIHRlc3Qgd2l0aCB2YWxncmluZAppZiBleHByICIgJEdJVF9URVNUX09QVFMgIiA6ICIuKiAtLXZhbGdyaW5kICIgPi9kZXYvbnVsbCB8fAogICB0ZXN0IC1uICIkVEVTVF9OT19NQUxMT0NfQ0hFQ0siCnRoZW4KCXNldHVwX21hbGxvY19jaGVjayAoKSB7CgkJOiBub3RoaW5nCgl9Cgl0ZWFyZG93bl9tYWxsb2NfY2hlY2sgKCkgewoJCTogbm90aGluZwoJfQplbHNlCglzZXR1cF9tYWxsb2NfY2hlY2sgKCkgewoJCU1BTExPQ19DSEVDS189MwlNQUxMT0NfUEVSVFVSQl89MTY1CgkJZXhwb3J0IE1BTExPQ19DSEVDS18gTUFMTE9DX1BFUlRVUkJfCgl9Cgl0ZWFyZG93bl9tYWxsb2NfY2hlY2sgKCkgewoJCXVuc2V0IE1BTExPQ19DSEVDS18gTUFMTE9DX1BFUlRVUkJfCgl9CmZpCgo6ICR7QVNBTl9PUFRJT05TPWRldGVjdF9sZWFrcz0wfQpleHBvcnQgQVNBTl9PUFRJT05TCgojIFByb3RlY3Qgb3Vyc2VsdmVzIGZyb20gY29tbW9uIG1pc2NvbmZpZ3VyYXRpb24gdG8gZXhwb3J0CiMgQ0RQQVRIIGludG8gdGhlIGVudmlyb25tZW50CnVuc2V0IENEUEFUSAoKdW5zZXQgR1JFUF9PUFRJT05TCnVuc2V0IFVOWklQCgpjYXNlICQoZWNobyAkR0lUX1RSQUNFIHx0ciAiW0EtWl0iICJbYS16XSIpIGluCjF8Mnx0cnVlKQoJR0lUX1RSQUNFPTQKCTs7CmVzYWMKCiMgQ29udmVuaWVuY2UKIwojIEEgcmVnZXhwIHRvIG1hdGNoIDUgYW5kIDQwIGhleGRpZ2l0cwpfeDA1PSdbMC05YS1mXVswLTlhLWZdWzAtOWEtZl1bMC05YS1mXVswLTlhLWZdJwpfeDQwPSIkX3gwNSRfeDA1JF94MDUkX3gwNSRfeDA1JF94MDUkX3gwNSRfeDA1IgoKIyBaZXJvIFNIQS0xCl96NDA9MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAoKIyBMaW5lIGZlZWQKTEY9JwonCgojIFVURi04IFpFUk8gV0lEVEggTk9OLUpPSU5FUiwgd2hpY2ggSEZTKyBpZ25vcmVzCiMgd2hlbiBjYXNlLWZvbGRpbmcgZmlsZW5hbWVzCnUyMDBjPSQocHJpbnRmICdcMzQyXDIwMFwyMTQnKQoKZXhwb3J0IF94MDUgX3g0MCBfejQwIExGIHUyMDBjCgojIEVhY2ggdGVzdCBzaG91bGQgc3RhcnQgd2l0aCBzb21ldGhpbmcgbGlrZSB0aGlzLCBhZnRlciBjb3B5cmlnaHQgbm90aWNlczoKIwojIHRlc3RfZGVzY3JpcHRpb249J0Rlc2NyaXB0aW9uIG9mIHRoaXMgdGVzdC4uLgojIFRoaXMgdGVzdCBjaGVja3MgaWYgY29tbWFuZCB4eXp6eSBkb2VzIHRoZSByaWdodCB0aGluZy4uLgojICcKIyAuIC4vdGVzdC1saWIuc2gKdGVzdCAieCRURVJNIiAhPSAieGR1bWIiICYmICgKCQl0ZXN0IC10IDEgJiYKCQl0cHV0IGJvbGQgPi9kZXYvbnVsbCAyPiYxICYmCgkJdHB1dCBzZXRhZiAxID4vZGV2L251bGwgMj4mMSAmJgoJCXRwdXQgc2dyMCA+L2Rldi9udWxsIDI+JjEKCSkgJiYKCWNvbG9yPXQKCndoaWxlIHRlc3QgIiQjIiAtbmUgMApkbwoJY2FzZSAiJDEiIGluCgktZHwtLWR8LS1kZXwtLWRlYnwtLWRlYnV8LS1kZWJ1ZykKCQlkZWJ1Zz10OyBzaGlmdCA7OwoJLWl8LS1pfC0taW18LS1pbW18LS1pbW1lfC0taW1tZWR8LS1pbW1lZGl8LS1pbW1lZGlhfC0taW1tZWRpYXR8LS1pbW1lZGlhdGUpCgkJaW1tZWRpYXRlPXQ7IHNoaWZ0IDs7CgktbHwtLWx8LS1sb3wtLWxvbnwtLWxvbmd8LS1sb25nLXwtLWxvbmctdHwtLWxvbmctdGV8LS1sb25nLXRlc3wtLWxvbmctdGVzdHwtLWxvbmctdGVzdHMpCgkJR0lUX1RFU1RfTE9ORz10OyBleHBvcnQgR0lUX1RFU1RfTE9ORzsgc2hpZnQgOzsKCS1yKQoJCXNoaWZ0OyB0ZXN0ICIkIyIgLW5lIDAgfHwgewoJCQllY2hvICdlcnJvcjogLXIgcmVxdWlyZXMgYW4gYXJndW1lbnQnID4mMjsKCQkJZXhpdCAxOwoJCX0KCQlydW5fbGlzdD0kMTsgc2hpZnQgOzsKCS0tcnVuPSopCgkJcnVuX2xpc3Q9JHsxIy0tKj19OyBzaGlmdCA7OwoJLWh8LS1ofC0taGV8LS1oZWx8LS1oZWxwKQoJCWhlbHA9dDsgc2hpZnQgOzsKCS12fC0tdnwtLXZlfC0tdmVyfC0tdmVyYnwtLXZlcmJvfC0tdmVyYm9zfC0tdmVyYm9zZSkKCQl2ZXJib3NlPXQ7IHNoaWZ0IDs7CgktLXZlcmJvc2Utb25seT0qKQoJCXZlcmJvc2Vfb25seT0kezEjLS0qPX0KCQlzaGlmdCA7OwoJLXF8LS1xfC0tcXV8LS1xdWl8LS1xdWllfC0tcXVpZXQpCgkJIyBJZ25vcmUgLS1xdWlldCB1bmRlciBhIFRBUDo6SGFybmVzcy4gU2F5aW5nIGhvdyBtYW55IHRlc3RzCgkJIyBwYXNzZWQgd2l0aG91dCB0aGUgb2svbm90IG9rIGRldGFpbHMgaXMgYWx3YXlzIGFuIGVycm9yLgoJCXRlc3QgLXogIiRIQVJORVNTX0FDVElWRSIgJiYgcXVpZXQ9dDsgc2hpZnQgOzsKCS0td2l0aC1kYXNoZXMpCgkJd2l0aF9kYXNoZXM9dDsgc2hpZnQgOzsKCS0tbm8tY29sb3IpCgkJY29sb3I9OyBzaGlmdCA7OwoJLS12YXwtLXZhbHwtLXZhbGd8LS12YWxncnwtLXZhbGdyaXwtLXZhbGdyaW58LS12YWxncmluZCkKCQl2YWxncmluZD1tZW1jaGVjawoJCXNoaWZ0IDs7CgktLXZhbGdyaW5kPSopCgkJdmFsZ3JpbmQ9JHsxIy0tKj19CgkJc2hpZnQgOzsKCS0tdmFsZ3JpbmQtb25seT0qKQoJCXZhbGdyaW5kX29ubHk9JHsxIy0tKj19CgkJc2hpZnQgOzsKCS0tdGVlKQoJCXNoaWZ0IDs7ICMgd2FzIGhhbmRsZWQgYWxyZWFkeQoJLS1yb290PSopCgkJcm9vdD0kezEjLS0qPX0KCQlzaGlmdCA7OwoJLS1jaGFpbi1saW50KQoJCUdJVF9URVNUX0NIQUlOX0xJTlQ9MQoJCXNoaWZ0IDs7CgktLW5vLWNoYWluLWxpbnQpCgkJR0lUX1RFU1RfQ0hBSU5fTElOVD0wCgkJc2hpZnQgOzsKCS14KQoJCXRyYWNlPXQKCQl2ZXJib3NlPXQKCQlzaGlmdCA7OwoJKikKCQllY2hvICJlcnJvcjogdW5rbm93biB0ZXN0IG9wdGlvbiAnJDEnIiA+JjI7IGV4aXQgMSA7OwoJZXNhYwpkb25lCgppZiB0ZXN0IC1uICIkdmFsZ3JpbmRfb25seSIKdGhlbgoJdGVzdCAteiAiJHZhbGdyaW5kIiAmJiB2YWxncmluZD1tZW1jaGVjawoJdGVzdCAteiAiJHZlcmJvc2UiICYmIHZlcmJvc2Vfb25seT0iJHZhbGdyaW5kX29ubHkiCmVsaWYgdGVzdCAtbiAiJHZhbGdyaW5kIgp0aGVuCgl2ZXJib3NlPXQKZmkKCmlmIHRlc3QgLW4gIiRjb2xvciIKdGhlbgoJIyBTYXZlIHRoZSBjb2xvciBjb250cm9sIHNlcXVlbmNlcyBub3cgcmF0aGVyIHRoYW4gcnVuIHRwdXQKCSMgZWFjaCB0aW1lIHNheV9jb2xvcigpIGlzIGNhbGxlZC4gIFRoaXMgaXMgZG9uZSBmb3IgdHdvCgkjIHJlYXNvbnM6CgkjICAgKiBURVJNIHdpbGwgYmUgY2hhbmdlZCB0byBkdW1iCgkjICAgKiBIT01FIHdpbGwgYmUgY2hhbmdlZCB0byBhIHRlbXBvcmFyeSBkaXJlY3RvcnkgYW5kIHRwdXQKCSMgICAgIG1pZ2h0IG5lZWQgdG8gcmVhZCB+Ly50ZXJtaW5mbyBmcm9tIHRoZSBvcmlnaW5hbCBIT01FCgkjICAgICBkaXJlY3RvcnkgdG8gZ2V0IHRoZSBjb250cm9sIHNlcXVlbmNlcwoJIyBOb3RlOiAgVGhpcyBhcHByb2FjaCBhc3N1bWVzIHRoZSBjb250cm9sIHNlcXVlbmNlcyBkb24ndCBlbmQKCSMgaW4gYSBuZXdsaW5lIGZvciBhbnkgdGVybWluYWwgb2YgaW50ZXJlc3QgKGNvbW1hbmQKCSMgc3Vic3RpdHV0aW9ucyBzdHJpcCB0cmFpbGluZyBuZXdsaW5lcykuICBHaXZlbiB0aGF0IG1vc3QKCSMgKGFsbD8pIHRlcm1pbmFscyBpbiBjb21tb24gdXNlIGFyZSByZWxhdGVkIHRvIEVDTUEtNDgsIHRoaXMKCSMgc2hvdWxkbid0IGJlIGEgcHJvYmxlbS4KCXNheV9jb2xvcl9lcnJvcj0kKHRwdXQgYm9sZDsgdHB1dCBzZXRhZiAxKSAjIGJvbGQgcmVkCglzYXlfY29sb3Jfc2tpcD0kKHRwdXQgc2V0YWYgNCkgIyBibHVlCglzYXlfY29sb3Jfd2Fybj0kKHRwdXQgc2V0YWYgMykgIyBicm93bi95ZWxsb3cKCXNheV9jb2xvcl9wYXNzPSQodHB1dCBzZXRhZiAyKSAjIGdyZWVuCglzYXlfY29sb3JfaW5mbz0kKHRwdXQgc2V0YWYgNikgIyBjeWFuCglzYXlfY29sb3JfcmVzZXQ9JCh0cHV0IHNncjApCglzYXlfY29sb3JfPSIiICMgbm8gZm9ybWF0dGluZyBmb3Igbm9ybWFsIHRleHQKCXNheV9jb2xvciAoKSB7CgkJdGVzdCAteiAiJDEiICYmIHRlc3QgLW4gIiRxdWlldCIgJiYgcmV0dXJuCgkJZXZhbCAic2F5X2NvbG9yX2NvbG9yPVwkc2F5X2NvbG9yXyQxIgoJCXNoaWZ0CgkJcHJpbnRmICIlc1xcbiIgIiRzYXlfY29sb3JfY29sb3IkKiRzYXlfY29sb3JfcmVzZXQiCgl9CmVsc2UKCXNheV9jb2xvcigpIHsKCQl0ZXN0IC16ICIkMSIgJiYgdGVzdCAtbiAiJHF1aWV0IiAmJiByZXR1cm4KCQlzaGlmdAoJCXByaW50ZiAiJXNcbiIgIiQqIgoJfQpmaQoKVEVSTT1kdW1iCmV4cG9ydCBURVJNCgplcnJvciAoKSB7CglzYXlfY29sb3IgZXJyb3IgImVycm9yOiAkKiIKCUdJVF9FWElUX09LPXQKCWV4aXQgMQp9CgpzYXkgKCkgewoJc2F5X2NvbG9yIGluZm8gIiQqIgp9Cgp0ZXN0ICIke3Rlc3RfZGVzY3JpcHRpb259IiAhPSAiIiB8fAplcnJvciAiVGVzdCBzY3JpcHQgZGlkIG5vdCBzZXQgdGVzdF9kZXNjcmlwdGlvbi4iCgppZiB0ZXN0ICIkaGVscCIgPSAidCIKdGhlbgoJcHJpbnRmICclc1xuJyAiJHRlc3RfZGVzY3JpcHRpb24iCglleGl0IDAKZmkKCmV4ZWMgNT4mMQpleGVjIDY8JjAKaWYgdGVzdCAiJHZlcmJvc2UiID0gInQiCnRoZW4KCWV4ZWMgND4mMiAzPiYxCmVsc2UKCWV4ZWMgND4vZGV2L251bGwgMz4vZGV2L251bGwKZmkKCiMgU2VuZCBhbnkgIi14IiBvdXRwdXQgZGlyZWN0bHkgdG8gc3RkZXJyIHRvIGF2b2lkIHBvbGx1dGluZyB0ZXN0cwojIHdoaWNoIGNhcHR1cmUgc3RkZXJyLiBXZSBjYW4gZG8gdGhpcyB1bmNvbmRpdGlvbmFsbHkgc2luY2UgaXQKIyBoYXMgbm8gZWZmZWN0IGlmIHRyYWNpbmcgaXNuJ3QgdHVybmVkIG9uLgojCiMgTm90ZSB0aGF0IHRoaXMgc2V0cyB1cCB0aGUgdHJhY2UgZmQgYXMgc29vbiBhcyB3ZSBhc3NpZ24gdGhlIHZhcmlhYmxlLCBzbyBpdAojIG11c3QgY29tZSBhZnRlciB0aGUgY3JlYXRpb24gb2YgZGVzY3JpcHRvciA0IGFib3ZlLiBMaWtld2lzZSwgd2UgbXVzdCBuZXZlcgojIHVuc2V0IHRoaXMsIGFzIGl0IGhhcyB0aGUgc2lkZSBlZmZlY3Qgb2YgY2xvc2luZyBkZXNjcmlwdG9yIDQsIHdoaWNoIHdlCiMgdXNlIHRvIHNob3cgdmVyYm9zZSB0ZXN0cyB0byB0aGUgdXNlci4KIwojIE5vdGUgYWxzbyB0aGF0IHdlIGRvbid0IG5lZWQgb3Igd2FudCB0byBleHBvcnQgaXQuIFRoZSB0cmFjaW5nIGlzIGxvY2FsIHRvCiMgdGhpcyBzaGVsbCwgYW5kIHdlIHdvdWxkIG5vdCB3YW50IHRvIGluZmx1ZW5jZSBhbnkgc2hlbGxzIHdlIGV4ZWMuCkJBU0hfWFRSQUNFRkQ9NAoKdGVzdF9mYWlsdXJlPTAKdGVzdF9jb3VudD0wCnRlc3RfZml4ZWQ9MAp0ZXN0X2Jyb2tlbj0wCnRlc3Rfc3VjY2Vzcz0wCgp0ZXN0X2V4dGVybmFsX2hhc190YXA9MAoKZGllICgpIHsKCWNvZGU9JD8KCWlmIHRlc3QgLW4gIiRHSVRfRVhJVF9PSyIKCXRoZW4KCQlleGl0ICRjb2RlCgllbHNlCgkJZWNobyA+JjUgIkZBVEFMOiBVbmV4cGVjdGVkIGV4aXQgd2l0aCBjb2RlICRjb2RlIgoJCWV4aXQgMQoJZmkKfQoKR0lUX0VYSVRfT0s9CnRyYXAgJ2RpZScgRVhJVAp0cmFwICdleGl0ICQ/JyBJTlQKCiMgVGhlIHVzZXItZmFjaW5nIGZ1bmN0aW9ucyBhcmUgbG9hZGVkIGZyb20gYSBzZXBhcmF0ZSBmaWxlIHNvIHRoYXQKIyB0ZXN0X3BlcmYgc3Vic2hlbGxzIGNhbiBoYXZlIHRoZW0gdG9vCi4gIiRURVNUX0RJUkVDVE9SWS90ZXN0LWxpYi1mdW5jdGlvbnMuc2giCgojIFlvdSBhcmUgbm90IGV4cGVjdGVkIHRvIGNhbGwgdGVzdF9va18gYW5kIHRlc3RfZmFpbHVyZV8gZGlyZWN0bHksIHVzZQojIHRoZSB0ZXN0X2V4cGVjdF8qIGZ1bmN0aW9ucyBpbnN0ZWFkLgoKdGVzdF9va18gKCkgewoJdGVzdF9zdWNjZXNzPSQoKCR0ZXN0X3N1Y2Nlc3MgKyAxKSkKCXNheV9jb2xvciAiIiAib2sgJHRlc3RfY291bnQgLSAkQCIKfQoKdGVzdF9mYWlsdXJlXyAoKSB7Cgl0ZXN0X2ZhaWx1cmU9JCgoJHRlc3RfZmFpbHVyZSArIDEpKQoJc2F5X2NvbG9yIGVycm9yICJub3Qgb2sgJHRlc3RfY291bnQgLSAkMSIKCXNoaWZ0CglwcmludGYgJyVzXG4nICIkKiIgfCBzZWQgLWUgJ3MvXi8jCS8nCgl0ZXN0ICIkaW1tZWRpYXRlIiA9ICIiIHx8IHsgR0lUX0VYSVRfT0s9dDsgZXhpdCAxOyB9Cn0KCnRlc3Rfa25vd25fYnJva2VuX29rXyAoKSB7Cgl0ZXN0X2ZpeGVkPSQoKCR0ZXN0X2ZpeGVkKzEpKQoJc2F5X2NvbG9yIGVycm9yICJvayAkdGVzdF9jb3VudCAtICRAICMgVE9ETyBrbm93biBicmVha2FnZSB2YW5pc2hlZCIKfQoKdGVzdF9rbm93bl9icm9rZW5fZmFpbHVyZV8gKCkgewoJdGVzdF9icm9rZW49JCgoJHRlc3RfYnJva2VuKzEpKQoJc2F5X2NvbG9yIHdhcm4gIm5vdCBvayAkdGVzdF9jb3VudCAtICRAICMgVE9ETyBrbm93biBicmVha2FnZSIKfQoKdGVzdF9kZWJ1ZyAoKSB7Cgl0ZXN0ICIkZGVidWciID0gIiIgfHwgZXZhbCAiJDEiCn0KCm1hdGNoX3BhdHRlcm5fbGlzdCAoKSB7Cglhcmc9IiQxIgoJc2hpZnQKCXRlc3QgLXogIiQqIiAmJiByZXR1cm4gMQoJZm9yIHBhdHRlcm5fCglkbwoJCWNhc2UgIiRhcmciIGluCgkJJHBhdHRlcm5fKQoJCQlyZXR1cm4gMAoJCWVzYWMKCWRvbmUKCXJldHVybiAxCn0KCm1hdGNoX3Rlc3Rfc2VsZWN0b3JfbGlzdCAoKSB7Cgl0aXRsZT0iJDEiCglzaGlmdAoJYXJnPSIkMSIKCXNoaWZ0Cgl0ZXN0IC16ICIkMSIgJiYgcmV0dXJuIDAKCgkjIEJvdGggY29tbWFzIGFuZCB3aGl0ZXNwYWNlIGFyZSBhY2NlcHRlZCBhcyBzZXBhcmF0b3JzLgoJT0xESUZTPSRJRlMKCUlGUz0nIAksJwoJc2V0IC0tICQxCglJRlM9JE9MRElGUwoKCSMgSWYgdGhlIGZpcnN0IHNlbGVjdG9yIGlzIG5lZ2F0aXZlIHdlIGluY2x1ZGUgYnkgZGVmYXVsdC4KCWluY2x1ZGU9CgljYXNlICIkMSIgaW4KCQkhKikgaW5jbHVkZT10IDs7Cgllc2FjCgoJZm9yIHNlbGVjdG9yCglkbwoJCW9yaWdfc2VsZWN0b3I9JHNlbGVjdG9yCgoJCXBvc2l0aXZlPXQKCQljYXNlICIkc2VsZWN0b3IiIGluCgkJCSEqKQoJCQkJcG9zaXRpdmU9CgkJCQlzZWxlY3Rvcj0ke3NlbGVjdG9yIyM/fQoJCQkJOzsKCQllc2FjCgoJCXRlc3QgLXogIiRzZWxlY3RvciIgJiYgY29udGludWUKCgkJY2FzZSAiJHNlbGVjdG9yIiBpbgoJCQkqLSopCgkJCQlpZiBleHByICJ6JHtzZWxlY3RvciUlLSp9IiA6ICJ6WzAtOV0qW14wLTldIiA+L2Rldi9udWxsCgkJCQl0aGVuCgkJCQkJZWNobyAiZXJyb3I6ICR0aXRsZTogaW52YWxpZCBub24tbnVtZXJpYyBpbiByYW5nZSIgXAoJCQkJCQkic3RhcnQ6ICckb3JpZ19zZWxlY3RvciciID4mMgoJCQkJCWV4aXQgMQoJCQkJZmkKCQkJCWlmIGV4cHIgInoke3NlbGVjdG9yIyotfSIgOiAielswLTldKlteMC05XSIgPi9kZXYvbnVsbAoJCQkJdGhlbgoJCQkJCWVjaG8gImVycm9yOiAkdGl0bGU6IGludmFsaWQgbm9uLW51bWVyaWMgaW4gcmFuZ2UiIFwKCQkJCQkJImVuZDogJyRvcmlnX3NlbGVjdG9yJyIgPiYyCgkJCQkJZXhpdCAxCgkJCQlmaQoJCQkJOzsKCQkJKikKCQkJCWlmIGV4cHIgInokc2VsZWN0b3IiIDogInpbMC05XSpbXjAtOV0iID4vZGV2L251bGwKCQkJCXRoZW4KCQkJCQllY2hvICJlcnJvcjogJHRpdGxlOiBpbnZhbGlkIG5vbi1udW1lcmljIGluIHRlc3QiIFwKCQkJCQkJInNlbGVjdG9yOiAnJG9yaWdfc2VsZWN0b3InIiA+JjIKCQkJCQlleGl0IDEKCQkJCWZpCgkJZXNhYwoKCQkjIFNob3J0IGN1dCBmb3IgIm9idmlvdXMiIGNhc2VzCgkJdGVzdCAteiAiJGluY2x1ZGUiICYmIHRlc3QgLXogIiRwb3NpdGl2ZSIgJiYgY29udGludWUKCQl0ZXN0IC1uICIkaW5jbHVkZSIgJiYgdGVzdCAtbiAiJHBvc2l0aXZlIiAmJiBjb250aW51ZQoKCQljYXNlICIkc2VsZWN0b3IiIGluCgkJCS0qKQoJCQkJaWYgdGVzdCAkYXJnIC1sZSAke3NlbGVjdG9yIy19CgkJCQl0aGVuCgkJCQkJaW5jbHVkZT0kcG9zaXRpdmUKCQkJCWZpCgkJCQk7OwoJCQkqLSkKCQkJCWlmIHRlc3QgJGFyZyAtZ2UgJHtzZWxlY3RvciUtfQoJCQkJdGhlbgoJCQkJCWluY2x1ZGU9JHBvc2l0aXZlCgkJCQlmaQoJCQkJOzsKCQkJKi0qKQoJCQkJaWYgdGVzdCAke3NlbGVjdG9yJSUtKn0gLWxlICRhcmcgXAoJCQkJCSYmIHRlc3QgJGFyZyAtbGUgJHtzZWxlY3RvciMqLX0KCQkJCXRoZW4KCQkJCQlpbmNsdWRlPSRwb3NpdGl2ZQoJCQkJZmkKCQkJCTs7CgkJCSopCgkJCQlpZiB0ZXN0ICRhcmcgLWVxICRzZWxlY3RvcgoJCQkJdGhlbgoJCQkJCWluY2x1ZGU9JHBvc2l0aXZlCgkJCQlmaQoJCQkJOzsKCQllc2FjCglkb25lCgoJdGVzdCAtbiAiJGluY2x1ZGUiCn0KCm1heWJlX3RlYXJkb3duX3ZlcmJvc2UgKCkgewoJdGVzdCAteiAiJHZlcmJvc2Vfb25seSIgJiYgcmV0dXJuCglleGVjIDQ+L2Rldi9udWxsIDM+L2Rldi9udWxsCgl2ZXJib3NlPQp9CgpsYXN0X3ZlcmJvc2U9dAptYXliZV9zZXR1cF92ZXJib3NlICgpIHsKCXRlc3QgLXogIiR2ZXJib3NlX29ubHkiICYmIHJldHVybgoJaWYgbWF0Y2hfcGF0dGVybl9saXN0ICR0ZXN0X2NvdW50ICR2ZXJib3NlX29ubHkKCXRoZW4KCQlleGVjIDQ+JjIgMz4mMQoJCSMgRW1pdCBhIGRlbGltaXRpbmcgYmxhbmsgbGluZSB3aGVuIGdvaW5nIGZyb20KCQkjIG5vbi12ZXJib3NlIHRvIHZlcmJvc2UuICBXaXRoaW4gdmVyYm9zZSBtb2RlIHRoZQoJCSMgZGVsaW1pdGVyIGlzIHByaW50ZWQgYnkgdGVzdF9leHBlY3RfKi4gIFRoZSBjaG9pY2UKCQkjIG9mIHRoZSBpbml0aWFsICRsYXN0X3ZlcmJvc2UgaXMgc3VjaCB0aGF0IGJlZm9yZQoJCSMgdGVzdCAxLCB3ZSBkbyBub3QgcHJpbnQgaXQuCgkJdGVzdCAteiAiJGxhc3RfdmVyYm9zZSIgJiYgZWNobyA+JjMgIiIKCQl2ZXJib3NlPXQKCWVsc2UKCQlleGVjIDQ+L2Rldi9udWxsIDM+L2Rldi9udWxsCgkJdmVyYm9zZT0KCWZpCglsYXN0X3ZlcmJvc2U9JHZlcmJvc2UKfQoKbWF5YmVfdGVhcmRvd25fdmFsZ3JpbmQgKCkgewoJdGVzdCAteiAiJEdJVF9WQUxHUklORCIgJiYgcmV0dXJuCglHSVRfVkFMR1JJTkRfRU5BQkxFRD0KfQoKbWF5YmVfc2V0dXBfdmFsZ3JpbmQgKCkgewoJdGVzdCAteiAiJEdJVF9WQUxHUklORCIgJiYgcmV0dXJuCglpZiB0ZXN0IC16ICIkdmFsZ3JpbmRfb25seSIKCXRoZW4KCQlHSVRfVkFMR1JJTkRfRU5BQkxFRD10CgkJcmV0dXJuCglmaQoJR0lUX1ZBTEdSSU5EX0VOQUJMRUQ9CglpZiBtYXRjaF9wYXR0ZXJuX2xpc3QgJHRlc3RfY291bnQgJHZhbGdyaW5kX29ubHkKCXRoZW4KCQlHSVRfVkFMR1JJTkRfRU5BQkxFRD10CglmaQp9Cgp3YW50X3RyYWNlICgpIHsKCXRlc3QgIiR0cmFjZSIgPSB0ICYmIHRlc3QgIiR2ZXJib3NlIiA9IHQKfQoKIyBUaGlzIGlzIGEgc2VwYXJhdGUgZnVuY3Rpb24gYmVjYXVzZSBzb21lIHRlc3RzIHVzZQojICJyZXR1cm4iIHRvIGVuZCBhIHRlc3RfZXhwZWN0X3N1Y2Nlc3MgYmxvY2sgZWFybHkKIyAoYW5kIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIHJ1biBhbnkgY2xlYW51cCBsaWtlCiMgInNldCAreCIpLgp0ZXN0X2V2YWxfaW5uZXJfICgpIHsKCSMgRG8gbm90IGFkZCBhbnl0aGluZyBleHRyYSAoaW5jbHVkaW5nIExGKSBhZnRlciAnJConCglldmFsICIKCQl3YW50X3RyYWNlICYmIHNldCAteAoJCSQqIgp9Cgp0ZXN0X2V2YWxfICgpIHsKCSMgV2UgcnVuIHRoaXMgYmxvY2sgd2l0aCBzdGRlcnIgcmVkaXJlY3RlZCB0byBhdm9pZCBleHRyYSBjcnVmdAoJIyBkdXJpbmcgYSAiLXgiIHRyYWNlLiBPbmNlIGluICJzZXQgLXgiIG1vZGUsIHdlIGNhbm5vdCBwcmV2ZW50CgkjIHRoZSBzaGVsbCBmcm9tIHByaW50aW5nIHRoZSAic2V0ICt4IiB0byB0dXJuIGl0IG9mZiAobm9yIHRoZSBzYXZpbmcKCSMgb2YgJD8gYmVmb3JlIHRoYXQpLiBCdXQgd2UgY2FuIG1ha2Ugc3VyZSB0aGF0IHRoZSBvdXRwdXQgZ29lcyB0bwoJIyAvZGV2L251bGwuCgkjCgkjIFRoZSB0ZXN0IGl0c2VsZiBpcyBydW4gd2l0aCBzdGRlcnIgcHV0IGJhY2sgdG8gJjQgKHNvIGVpdGhlciB0bwoJIyAvZGV2L251bGwsIG9yIHRvIHRoZSBvcmlnaW5hbCBzdGRlcnIgaWYgLS12ZXJib3NlIHdhcyB1c2VkKS4KCXsKCQl0ZXN0X2V2YWxfaW5uZXJfICIkQCIgPC9kZXYvbnVsbCA+JjMgMj4mNAoJCXRlc3RfZXZhbF9yZXRfPSQ/CgkJaWYgd2FudF90cmFjZQoJCXRoZW4KCQkJc2V0ICt4CgkJCWlmIHRlc3QgIiR0ZXN0X2V2YWxfcmV0XyIgIT0gMAoJCQl0aGVuCgkJCQlzYXlfY29sb3IgZXJyb3IgPiY0ICJlcnJvcjogbGFzdCBjb21tYW5kIGV4aXRlZCB3aXRoIFwkPz0kdGVzdF9ldmFsX3JldF8iCgkJCWZpCgkJZmkKCX0gMj4vZGV2L251bGwKCXJldHVybiAkdGVzdF9ldmFsX3JldF8KfQoKdGVzdF9ydW5fICgpIHsKCXRlc3RfY2xlYW51cD06CglleHBlY3RpbmdfZmFpbHVyZT0kMgoKCWlmIHRlc3QgIiR7R0lUX1RFU1RfQ0hBSU5fTElOVDotMX0iICE9IDA7IHRoZW4KCQkjIHR1cm4gb2ZmIHRyYWNpbmcgZm9yIHRoaXMgdGVzdC1ldmFsLCBhcyBpdCBzaW1wbHkgY3JlYXRlcwoJCSMgY29uZnVzaW5nIG5vaXNlIGluIHRoZSAiLXgiIG91dHB1dAoJCXRyYWNlX3RtcD0kdHJhY2UKCQl0cmFjZT0KCQkjIDExNyBpcyBtYWdpYyBiZWNhdXNlIGl0IGlzIHVubGlrZWx5IHRvIG1hdGNoIHRoZSBleGl0CgkJIyBjb2RlIG9mIG90aGVyIHByb2dyYW1zCgkJdGVzdF9ldmFsXyAiKGV4aXQgMTE3KSAmJiAkMSIKCQlpZiB0ZXN0ICIkPyIgIT0gMTE3OyB0aGVuCgkJCWVycm9yICJidWcgaW4gdGhlIHRlc3Qgc2NyaXB0OiBicm9rZW4gJiYtY2hhaW46ICQxIgoJCWZpCgkJdHJhY2U9JHRyYWNlX3RtcAoJZmkKCglzZXR1cF9tYWxsb2NfY2hlY2sKCXRlc3RfZXZhbF8gIiQxIgoJZXZhbF9yZXQ9JD8KCXRlYXJkb3duX21hbGxvY19jaGVjawoKCWlmIHRlc3QgLXogIiRpbW1lZGlhdGUiIHx8IHRlc3QgJGV2YWxfcmV0ID0gMCB8fAoJICAgdGVzdCAtbiAiJGV4cGVjdGluZ19mYWlsdXJlIiAmJiB0ZXN0ICIkdGVzdF9jbGVhbnVwIiAhPSAiOiIKCXRoZW4KCQlzZXR1cF9tYWxsb2NfY2hlY2sKCQl0ZXN0X2V2YWxfICIkdGVzdF9jbGVhbnVwIgoJCXRlYXJkb3duX21hbGxvY19jaGVjawoJZmkKCWlmIHRlc3QgIiR2ZXJib3NlIiA9ICJ0IiAmJiB0ZXN0IC1uICIkSEFSTkVTU19BQ1RJVkUiCgl0aGVuCgkJZWNobyAiIgoJZmkKCXJldHVybiAiJGV2YWxfcmV0Igp9Cgp0ZXN0X3N0YXJ0XyAoKSB7Cgl0ZXN0X2NvdW50PSQoKCR0ZXN0X2NvdW50KzEpKQoJbWF5YmVfc2V0dXBfdmVyYm9zZQoJbWF5YmVfc2V0dXBfdmFsZ3JpbmQKfQoKdGVzdF9maW5pc2hfICgpIHsKCWVjaG8gPiYzICIiCgltYXliZV90ZWFyZG93bl92YWxncmluZAoJbWF5YmVfdGVhcmRvd25fdmVyYm9zZQp9Cgp0ZXN0X3NraXAgKCkgewoJdG9fc2tpcD0KCXNraXBwZWRfcmVhc29uPQoJaWYgbWF0Y2hfcGF0dGVybl9saXN0ICR0aGlzX3Rlc3QuJHRlc3RfY291bnQgJEdJVF9TS0lQX1RFU1RTCgl0aGVuCgkJdG9fc2tpcD10CgkJc2tpcHBlZF9yZWFzb249IkdJVF9TS0lQX1RFU1RTIgoJZmkKCWlmIHRlc3QgLXogIiR0b19za2lwIiAmJiB0ZXN0IC1uICIkdGVzdF9wcmVyZXEiICYmCgkgICAhIHRlc3RfaGF2ZV9wcmVyZXEgIiR0ZXN0X3ByZXJlcSIKCXRoZW4KCQl0b19za2lwPXQKCgkJb2ZfcHJlcmVxPQoJCWlmIHRlc3QgIiRtaXNzaW5nX3ByZXJlcSIgIT0gIiR0ZXN0X3ByZXJlcSIKCQl0aGVuCgkJCW9mX3ByZXJlcT0iIG9mICR0ZXN0X3ByZXJlcSIKCQlmaQoJCXNraXBwZWRfcmVhc29uPSJtaXNzaW5nICRtaXNzaW5nX3ByZXJlcSR7b2ZfcHJlcmVxfSIKCWZpCglpZiB0ZXN0IC16ICIkdG9fc2tpcCIgJiYgdGVzdCAtbiAiJHJ1bl9saXN0IiAmJgoJCSEgbWF0Y2hfdGVzdF9zZWxlY3Rvcl9saXN0ICctLXJ1bicgJHRlc3RfY291bnQgIiRydW5fbGlzdCIKCXRoZW4KCQl0b19za2lwPXQKCQlza2lwcGVkX3JlYXNvbj0iLS1ydW4iCglmaQoKCWNhc2UgIiR0b19za2lwIiBpbgoJdCkKCQlzYXlfY29sb3Igc2tpcCA+JjMgInNraXBwaW5nIHRlc3Q6ICRAIgoJCXNheV9jb2xvciBza2lwICJvayAkdGVzdF9jb3VudCAjIHNraXAgJDEgKCRza2lwcGVkX3JlYXNvbikiCgkJOiB0cnVlCgkJOzsKCSopCgkJZmFsc2UKCQk7OwoJZXNhYwp9CgojIHN0dWI7IHBlcmYtbGliIG92ZXJyaWRlcyBpdAp0ZXN0X2F0X2VuZF9ob29rXyAoKSB7Cgk6Cn0KCnRlc3RfZG9uZSAoKSB7CglHSVRfRVhJVF9PSz10CgoJaWYgdGVzdCAteiAiJEhBUk5FU1NfQUNUSVZFIgoJdGhlbgoJCXRlc3RfcmVzdWx0c19kaXI9IiRURVNUX09VVFBVVF9ESVJFQ1RPUlkvdGVzdC1yZXN1bHRzIgoJCW1rZGlyIC1wICIkdGVzdF9yZXN1bHRzX2RpciIKCQliYXNlPSR7MCMjKi99CgkJdGVzdF9yZXN1bHRzX3BhdGg9IiR0ZXN0X3Jlc3VsdHNfZGlyLyR7YmFzZSUuc2h9LSQkLmNvdW50cyIKCgkJY2F0ID4+IiR0ZXN0X3Jlc3VsdHNfcGF0aCIgPDwtRU9GCgkJdG90YWwgJHRlc3RfY291bnQKCQlzdWNjZXNzICR0ZXN0X3N1Y2Nlc3MKCQlmaXhlZCAkdGVzdF9maXhlZAoJCWJyb2tlbiAkdGVzdF9icm9rZW4KCQlmYWlsZWQgJHRlc3RfZmFpbHVyZQoKCQlFT0YKCWZpCgoJaWYgdGVzdCAiJHRlc3RfZml4ZWQiICE9IDAKCXRoZW4KCQlzYXlfY29sb3IgZXJyb3IgIiMgJHRlc3RfZml4ZWQga25vd24gYnJlYWthZ2UocykgdmFuaXNoZWQ7IHBsZWFzZSB1cGRhdGUgdGVzdChzKSIKCWZpCglpZiB0ZXN0ICIkdGVzdF9icm9rZW4iICE9IDAKCXRoZW4KCQlzYXlfY29sb3Igd2FybiAiIyBzdGlsbCBoYXZlICR0ZXN0X2Jyb2tlbiBrbm93biBicmVha2FnZShzKSIKCWZpCglpZiB0ZXN0ICIkdGVzdF9icm9rZW4iICE9IDAgfHwgdGVzdCAiJHRlc3RfZml4ZWQiICE9IDAKCXRoZW4KCQl0ZXN0X3JlbWFpbmluZz0kKCggJHRlc3RfY291bnQgLSAkdGVzdF9icm9rZW4gLSAkdGVzdF9maXhlZCApKQoJCW1zZz0icmVtYWluaW5nICR0ZXN0X3JlbWFpbmluZyB0ZXN0KHMpIgoJZWxzZQoJCXRlc3RfcmVtYWluaW5nPSR0ZXN0X2NvdW50CgkJbXNnPSIkdGVzdF9jb3VudCB0ZXN0KHMpIgoJZmkKCWNhc2UgIiR0ZXN0X2ZhaWx1cmUiIGluCgkwKQoJCSMgTWF5YmUgcHJpbnQgU0tJUCBtZXNzYWdlCgkJaWYgdGVzdCAtbiAiJHNraXBfYWxsIiAmJiB0ZXN0ICR0ZXN0X2NvdW50IC1ndCAwCgkJdGhlbgoJCQllcnJvciAiQ2FuJ3QgdXNlIHNraXBfYWxsIGFmdGVyIHJ1bm5pbmcgc29tZSB0ZXN0cyIKCQlmaQoJCXRlc3QgLXogIiRza2lwX2FsbCIgfHwgc2tpcF9hbGw9IiAjIFNLSVAgJHNraXBfYWxsIgoKCQlpZiB0ZXN0ICR0ZXN0X2V4dGVybmFsX2hhc190YXAgLWVxIDAKCQl0aGVuCgkJCWlmIHRlc3QgJHRlc3RfcmVtYWluaW5nIC1ndCAwCgkJCXRoZW4KCQkJCXNheV9jb2xvciBwYXNzICIjIHBhc3NlZCBhbGwgJG1zZyIKCQkJZmkKCQkJc2F5ICIxLi4kdGVzdF9jb3VudCRza2lwX2FsbCIKCQlmaQoKCQl0ZXN0IC1kICIkcmVtb3ZlX3RyYXNoIiAmJgoJCWNkICIkKGRpcm5hbWUgIiRyZW1vdmVfdHJhc2giKSIgJiYKCQlybSAtcmYgIiQoYmFzZW5hbWUgIiRyZW1vdmVfdHJhc2giKSIKCgkJdGVzdF9hdF9lbmRfaG9va18KCgkJZXhpdCAwIDs7CgoJKikKCQlpZiB0ZXN0ICR0ZXN0X2V4dGVybmFsX2hhc190YXAgLWVxIDAKCQl0aGVuCgkJCXNheV9jb2xvciBlcnJvciAiIyBmYWlsZWQgJHRlc3RfZmFpbHVyZSBhbW9uZyAkbXNnIgoJCQlzYXkgIjEuLiR0ZXN0X2NvdW50IgoJCWZpCgoJCWV4aXQgMSA7OwoKCWVzYWMKfQoKaWYgdGVzdCAtbiAiJHZhbGdyaW5kIgp0aGVuCgltYWtlX3N5bWxpbmsgKCkgewoJCXRlc3QgLWggIiQyIiAmJgoJCXRlc3QgIiQxIiA9ICIkKHJlYWRsaW5rICIkMiIpIiB8fCB7CgkJCSMgYmUgc3VwZXIgcGFyYW5vaWQKCQkJaWYgbWtkaXIgIiQyIi5sb2NrCgkJCXRoZW4KCQkJCXJtIC1mICIkMiIgJiYKCQkJCWxuIC1zICIkMSIgIiQyIiAmJgoJCQkJcm0gLXIgIiQyIi5sb2NrCgkJCWVsc2UKCQkJCXdoaWxlIHRlc3QgLWQgIiQyIi5sb2NrCgkJCQlkbwoJCQkJCXNheSAiV2FpdGluZyBmb3IgbG9jayBvbiAkMi4iCgkJCQkJc2xlZXAgMQoJCQkJZG9uZQoJCQlmaQoJCX0KCX0KCgltYWtlX3ZhbGdyaW5kX3N5bWxpbmsgKCkgewoJCSMgaGFuZGxlIG9ubHkgZXhlY3V0YWJsZXMsIHVubGVzcyB0aGV5IGFyZSBzaGVsbCBsaWJyYXJpZXMgdGhhdAoJCSMgbmVlZCB0byBiZSBpbiB0aGUgZXhlYy1wYXRoLgoJCXRlc3QgLXggIiQxIiB8fAoJCXRlc3QgIiMgIiA9ICIkKGhlYWQgLWMgMiA8IiQxIikiIHx8CgkJcmV0dXJuOwoKCQliYXNlPSQoYmFzZW5hbWUgIiQxIikKCQlzeW1saW5rX3RhcmdldD0kR0lUX0JVSUxEX0RJUi8kYmFzZQoJCSMgZG8gbm90IG92ZXJyaWRlIHNjcmlwdHMKCQlpZiB0ZXN0IC14ICIkc3ltbGlua190YXJnZXQiICYmCgkJICAgIHRlc3QgISAtZCAiJHN5bWxpbmtfdGFyZ2V0IiAmJgoJCSAgICB0ZXN0ICIjISIgIT0gIiQoaGVhZCAtYyAyIDwgIiRzeW1saW5rX3RhcmdldCIpIgoJCXRoZW4KCQkJc3ltbGlua190YXJnZXQ9Li4vdmFsZ3JpbmQuc2gKCQlmaQoJCWNhc2UgIiRiYXNlIiBpbgoJCSouc2h8Ki5wZXJsKQoJCQlzeW1saW5rX3RhcmdldD0uLi91bnByb2Nlc3NlZC1zY3JpcHQKCQllc2FjCgkJIyBjcmVhdGUgdGhlIGxpbmssIG9yIHJlcGxhY2UgaXQgaWYgaXQgaXMgb3V0IG9mIGRhdGUKCQltYWtlX3N5bWxpbmsgIiRzeW1saW5rX3RhcmdldCIgIiRHSVRfVkFMR1JJTkQvYmluLyRiYXNlIiB8fCBleGl0Cgl9CgoJIyBvdmVycmlkZSBhbGwgZ2l0IGV4ZWN1dGFibGVzIGluIFRFU1RfRElSRUNUT1JZLy4uCglHSVRfVkFMR1JJTkQ9JFRFU1RfRElSRUNUT1JZL3ZhbGdyaW5kCglta2RpciAtcCAiJEdJVF9WQUxHUklORCIvYmluCglmb3IgZmlsZSBpbiAkR0lUX0JVSUxEX0RJUi9naXQqICRHSVRfQlVJTERfRElSL3Rlc3QtKgoJZG8KCQltYWtlX3ZhbGdyaW5kX3N5bWxpbmsgJGZpbGUKCWRvbmUKCSMgc3BlY2lhbC1jYXNlIHRoZSBtZXJnZXRvb2xzIGxvYWRhYmxlcwoJbWFrZV9zeW1saW5rICIkR0lUX0JVSUxEX0RJUiIvbWVyZ2V0b29scyAiJEdJVF9WQUxHUklORC9iaW4vbWVyZ2V0b29scyIKCU9MRElGUz0kSUZTCglJRlM9OgoJZm9yIHBhdGggaW4gJFBBVEgKCWRvCgkJbHMgIiRwYXRoIi9naXQtKiAyPiAvZGV2L251bGwgfAoJCXdoaWxlIHJlYWQgZmlsZQoJCWRvCgkJCW1ha2VfdmFsZ3JpbmRfc3ltbGluayAiJGZpbGUiCgkJZG9uZQoJZG9uZQoJSUZTPSRPTERJRlMKCVBBVEg9JEdJVF9WQUxHUklORC9iaW46JFBBVEgKCUdJVF9FWEVDX1BBVEg9JEdJVF9WQUxHUklORC9iaW4KCWV4cG9ydCBHSVRfVkFMR1JJTkQKCUdJVF9WQUxHUklORF9NT0RFPSIkdmFsZ3JpbmQiCglleHBvcnQgR0lUX1ZBTEdSSU5EX01PREUKCUdJVF9WQUxHUklORF9FTkFCTEVEPXQKCXRlc3QgLW4gIiR2YWxncmluZF9vbmx5IiAmJiBHSVRfVkFMR1JJTkRfRU5BQkxFRD0KCWV4cG9ydCBHSVRfVkFMR1JJTkRfRU5BQkxFRAplbGlmIHRlc3QgLW4gIiRHSVRfVEVTVF9JTlNUQUxMRUQiCnRoZW4KCUdJVF9FWEVDX1BBVEg9JCgkR0lUX1RFU1RfSU5TVEFMTEVEL2dpdCAtLWV4ZWMtcGF0aCkgIHx8CgllcnJvciAiQ2Fubm90IHJ1biBnaXQgZnJvbSAkR0lUX1RFU1RfSU5TVEFMTEVELiIKCVBBVEg9JEdJVF9URVNUX0lOU1RBTExFRDokR0lUX0JVSUxEX0RJUjokUEFUSAoJR0lUX0VYRUNfUEFUSD0ke0dJVF9URVNUX0VYRUNfUEFUSDotJEdJVF9FWEVDX1BBVEh9CmVsc2UgIyBub3JtYWwgY2FzZSwgdXNlIC4uL2Jpbi13cmFwcGVycyBvbmx5IHVubGVzcyAkd2l0aF9kYXNoZXM6CglnaXRfYmluX2Rpcj0iJEdJVF9CVUlMRF9ESVIvYmluLXdyYXBwZXJzIgoJaWYgISB0ZXN0IC14ICIkZ2l0X2Jpbl9kaXIvZ2l0IgoJdGhlbgoJCWlmIHRlc3QgLXogIiR3aXRoX2Rhc2hlcyIKCQl0aGVuCgkJCXNheSAiJGdpdF9iaW5fZGlyL2dpdCBpcyBub3QgZXhlY3V0YWJsZTsgdXNpbmcgR0lUX0VYRUNfUEFUSCIKCQlmaQoJCXdpdGhfZGFzaGVzPXQKCWZpCglQQVRIPSIkZ2l0X2Jpbl9kaXI6JFBBVEgiCglHSVRfRVhFQ19QQVRIPSRHSVRfQlVJTERfRElSCglpZiB0ZXN0IC1uICIkd2l0aF9kYXNoZXMiCgl0aGVuCgkJUEFUSD0iJEdJVF9CVUlMRF9ESVI6JFBBVEgiCglmaQpmaQpHSVRfVEVNUExBVEVfRElSPSIkR0lUX0JVSUxEX0RJUiIvdGVtcGxhdGVzL2JsdApHSVRfQ09ORklHX05PU1lTVEVNPTEKR0lUX0FUVFJfTk9TWVNURU09MQpleHBvcnQgUEFUSCBHSVRfRVhFQ19QQVRIIEdJVF9URU1QTEFURV9ESVIgR0lUX0NPTkZJR19OT1NZU1RFTSBHSVRfQVRUUl9OT1NZU1RFTQoKaWYgdGVzdCAteiAiJEdJVF9URVNUX0NNUCIKdGhlbgoJaWYgdGVzdCAtbiAiJEdJVF9URVNUX0NNUF9VU0VfQ09QSUVEX0NPTlRFWFQiCgl0aGVuCgkJR0lUX1RFU1RfQ01QPSIkRElGRiAtYyIKCWVsc2UKCQlHSVRfVEVTVF9DTVA9IiRESUZGIC11IgoJZmkKZmkKCkdJVFBFUkxMSUI9IiRHSVRfQlVJTERfRElSIi9wZXJsL2JsaWIvbGliOiIkR0lUX0JVSUxEX0RJUiIvcGVybC9ibGliL2FyY2gvYXV0by9HaXQKZXhwb3J0IEdJVFBFUkxMSUIKdGVzdCAtZCAiJEdJVF9CVUlMRF9ESVIiL3RlbXBsYXRlcy9ibHQgfHwgewoJZXJyb3IgIllvdSBoYXZlbid0IGJ1aWx0IHRoaW5ncyB5ZXQsIGhhdmUgeW91PyIKfQoKaWYgISB0ZXN0IC14ICIkR0lUX0JVSUxEX0RJUiIvdC9oZWxwZXIvdGVzdC1jaG10aW1lCnRoZW4KCWVjaG8gPiYyICdZb3UgbmVlZCB0byBidWlsZCB0ZXN0LWNobXRpbWU6JwoJZWNobyA+JjIgJ1J1biAibWFrZSB0L2hlbHBlci90ZXN0LWNobXRpbWUiIGluIHRoZSBzb3VyY2UgKHRvcGxldmVsKSBkaXJlY3RvcnknCglleGl0IDEKZmkKCiMgVGVzdCByZXBvc2l0b3J5ClRSQVNIX0RJUkVDVE9SWT0idHJhc2ggZGlyZWN0b3J5LiQoYmFzZW5hbWUgIiQwIiAuc2gpIgp0ZXN0IC1uICIkcm9vdCIgJiYgVFJBU0hfRElSRUNUT1JZPSIkcm9vdC8kVFJBU0hfRElSRUNUT1JZIgpjYXNlICIkVFJBU0hfRElSRUNUT1JZIiBpbgovKikgOzsgIyBhYnNvbHV0ZSBwYXRoIGlzIGdvb2QKICopIFRSQVNIX0RJUkVDVE9SWT0iJFRFU1RfT1VUUFVUX0RJUkVDVE9SWS8kVFJBU0hfRElSRUNUT1JZIiA7Owplc2FjCnRlc3QgISAteiAiJGRlYnVnIiB8fCByZW1vdmVfdHJhc2g9JFRSQVNIX0RJUkVDVE9SWQpybSAtZnIgIiRUUkFTSF9ESVJFQ1RPUlkiIHx8IHsKCUdJVF9FWElUX09LPXQKCWVjaG8gPiY1ICJGQVRBTDogQ2Fubm90IHByZXBhcmUgdGVzdCBhcmVhIgoJZXhpdCAxCn0KCkhPTUU9IiRUUkFTSF9ESVJFQ1RPUlkiCkdOVVBHSE9NRT0iJEhPTUUvZ251cGctaG9tZS1ub3QtdXNlZCIKZXhwb3J0IEhPTUUgR05VUEdIT01FCgppZiB0ZXN0IC16ICIkVEVTVF9OT19DUkVBVEVfUkVQTyIKdGhlbgoJdGVzdF9jcmVhdGVfcmVwbyAiJFRSQVNIX0RJUkVDVE9SWSIKZWxzZQoJbWtkaXIgLXAgIiRUUkFTSF9ESVJFQ1RPUlkiCmZpCiMgVXNlIC1QIHRvIHJlc29sdmUgc3ltbGlua3MgaW4gb3VyIHdvcmtpbmcgZGlyZWN0b3J5IHNvIHRoYXQgdGhlIGN3ZAojIGluIHN1YnByb2Nlc3NlcyBsaWtlIGdpdCBlcXVhbHMgb3VyICRQV0QgKGZvciBwYXRobmFtZSBjb21wYXJpc29ucykuCmNkIC1QICIkVFJBU0hfRElSRUNUT1JZIiB8fCBleGl0IDEKCnRoaXNfdGVzdD0kezAjIyovfQp0aGlzX3Rlc3Q9JHt0aGlzX3Rlc3QlJS0qfQppZiBtYXRjaF9wYXR0ZXJuX2xpc3QgIiR0aGlzX3Rlc3QiICRHSVRfU0tJUF9URVNUUwp0aGVuCglzYXlfY29sb3IgaW5mbyA+JjMgInNraXBwaW5nIHRlc3QgJHRoaXNfdGVzdCBhbHRvZ2V0aGVyIgoJc2tpcF9hbGw9InNraXAgYWxsIHRlc3RzIGluICR0aGlzX3Rlc3QiCgl0ZXN0X2RvbmUKZmkKCiMgUHJvdmlkZSBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgJ3llcycgdXRpbGl0eQp5ZXMgKCkgewoJaWYgdGVzdCAkIyA9IDAKCXRoZW4KCQl5PXkKCWVsc2UKCQl5PSIkKiIKCWZpCgoJaT0wCgl3aGlsZSB0ZXN0ICRpIC1sdCA5OQoJZG8KCQllY2hvICIkeSIKCQlpPSQoKCRpKzEpKQoJZG9uZQp9CgojIEZpeCBzb21lIGNvbW1hbmRzIG9uIFdpbmRvd3MKY2FzZSAkKHVuYW1lIC1zKSBpbgoqTUlOR1cqKQoJIyBXaW5kb3dzIGhhcyBpdHMgb3duIChpbmNvbXBhdGlibGUpIHNvcnQgYW5kIGZpbmQKCXNvcnQgKCkgewoJCS91c3IvYmluL3NvcnQgIiRAIgoJfQoJZmluZCAoKSB7CgkJL3Vzci9iaW4vZmluZCAiJEAiCgl9CglzdW0gKCkgewoJCW1kNXN1bSAiJEAiCgl9CgkjIGdpdCBzZWVzIFdpbmRvd3Mtc3R5bGUgcHdkCglwd2QgKCkgewoJCWJ1aWx0aW4gcHdkIC1XCgl9CgkjIG5vIFBPU0lYIHBlcm1pc3Npb25zCgkjIGJhY2tzbGFzaGVzIGluIHBhdGhzcGVjIGFyZSBjb252ZXJ0ZWQgdG8gJy8nCgkjIGV4ZWMgZG9lcyBub3QgaW5oZXJpdCB0aGUgUElECgl0ZXN0X3NldF9wcmVyZXEgTUlOR1cKCXRlc3Rfc2V0X3ByZXJlcSBOQVRJVkVfQ1JMRgoJdGVzdF9zZXRfcHJlcmVxIFNFRF9TVFJJUFNfQ1IKCXRlc3Rfc2V0X3ByZXJlcSBHUkVQX1NUUklQU19DUgoJR0lUX1RFU1RfQ01QPW1pbmd3X3Rlc3RfY21wCgk7OwoqQ1lHV0lOKikKCXRlc3Rfc2V0X3ByZXJlcSBQT1NJWFBFUk0KCXRlc3Rfc2V0X3ByZXJlcSBFWEVDS0VFUFNQSUQKCXRlc3Rfc2V0X3ByZXJlcSBDWUdXSU4KCXRlc3Rfc2V0X3ByZXJlcSBTRURfU1RSSVBTX0NSCgl0ZXN0X3NldF9wcmVyZXEgR1JFUF9TVFJJUFNfQ1IKCTs7CiopCgl0ZXN0X3NldF9wcmVyZXEgUE9TSVhQRVJNCgl0ZXN0X3NldF9wcmVyZXEgQlNMQVNIUFNQRUMKCXRlc3Rfc2V0X3ByZXJlcSBFWEVDS0VFUFNQSUQKCTs7CmVzYWMKCiggQ09MVU1OUz0xICYmIHRlc3QgJENPTFVNTlMgPSAxICkgJiYgdGVzdF9zZXRfcHJlcmVxIENPTFVNTlNfQ0FOX0JFXzEKdGVzdCAteiAiJE5PX1BFUkwiICYmIHRlc3Rfc2V0X3ByZXJlcSBQRVJMCnRlc3QgLXogIiROT19QWVRIT04iICYmIHRlc3Rfc2V0X3ByZXJlcSBQWVRIT04KdGVzdCAtbiAiJFVTRV9MSUJQQ1JFIiAmJiB0ZXN0X3NldF9wcmVyZXEgTElCUENSRQp0ZXN0IC16ICIkTk9fR0VUVEVYVCIgJiYgdGVzdF9zZXRfcHJlcmVxIEdFVFRFWFQKCiMgQ2FuIHdlIHJlbHkgb24gZ2l0J3Mgb3V0cHV0IGluIHRoZSBDIGxvY2FsZT8KaWYgdGVzdCAtbiAiJEdFVFRFWFRfUE9JU09OIgp0aGVuCglHSVRfR0VUVEVYVF9QT0lTT049WWVzUGxlYXNlCglleHBvcnQgR0lUX0dFVFRFWFRfUE9JU09OCgl0ZXN0X3NldF9wcmVyZXEgR0VUVEVYVF9QT0lTT04KZWxzZQoJdGVzdF9zZXRfcHJlcmVxIENfTE9DQUxFX09VVFBVVApmaQoKIyBVc2UgdGhpcyBpbnN0ZWFkIG9mIHRlc3RfY21wIHRvIGNvbXBhcmUgZmlsZXMgdGhhdCBjb250YWluIGV4cGVjdGVkIGFuZAojIGFjdHVhbCBvdXRwdXQgZnJvbSBnaXQgY29tbWFuZHMgdGhhdCBjYW4gYmUgdHJhbnNsYXRlZC4gIFdoZW4gcnVubmluZwojIHVuZGVyIEdFVFRFWFRfUE9JU09OIHRoaXMgcHJldGVuZHMgdGhhdCB0aGUgY29tbWFuZCBwcm9kdWNlZCBleHBlY3RlZAojIHJlc3VsdHMuCnRlc3RfaTE4bmNtcCAoKSB7Cgl0ZXN0IC1uICIkR0VUVEVYVF9QT0lTT04iIHx8IHRlc3RfY21wICIkQCIKfQoKIyBVc2UgdGhpcyBpbnN0ZWFkIG9mICJncmVwIGV4cGVjdGVkLXN0cmluZyBhY3R1YWwiIHRvIHNlZSBpZiB0aGUKIyBvdXRwdXQgZnJvbSBhIGdpdCBjb21tYW5kIHRoYXQgY2FuIGJlIHRyYW5zbGF0ZWQgZWl0aGVyIGNvbnRhaW5zIGFuCiMgZXhwZWN0ZWQgc3RyaW5nLCBvciBkb2VzIG5vdCBjb250YWluIGFuIHVud2FudGVkIG9uZS4gIFdoZW4gcnVubmluZwojIHVuZGVyIEdFVFRFWFRfUE9JU09OIHRoaXMgcHJldGVuZHMgdGhhdCB0aGUgY29tbWFuZCBwcm9kdWNlZCBleHBlY3RlZAojIHJlc3VsdHMuCnRlc3RfaTE4bmdyZXAgKCkgewoJaWYgdGVzdCAtbiAiJEdFVFRFWFRfUE9JU09OIgoJdGhlbgoJICAgIDogIyBwcmV0ZW5kIHN1Y2Nlc3MKCWVsaWYgdGVzdCAieCEiID0gIngkMSIKCXRoZW4KCQlzaGlmdAoJCSEgZ3JlcCAiJEAiCgllbHNlCgkJZ3JlcCAiJEAiCglmaQp9Cgp0ZXN0X2xhenlfcHJlcmVxIFBJUEUgJwoJIyB0ZXN0IHdoZXRoZXIgdGhlIGZpbGVzeXN0ZW0gc3VwcG9ydHMgRklGT3MKCWNhc2UgJCh1bmFtZSAtcykgaW4KCUNZR1dJTip8TUlOR1cqKQoJCWZhbHNlCgkJOzsKCSopCgkJcm0gLWYgdGVzdGZpZm8gJiYgbWtmaWZvIHRlc3RmaWZvCgkJOzsKCWVzYWMKJwoKdGVzdF9sYXp5X3ByZXJlcSBTWU1MSU5LUyAnCgkjIHRlc3Qgd2hldGhlciB0aGUgZmlsZXN5c3RlbSBzdXBwb3J0cyBzeW1ib2xpYyBsaW5rcwoJbG4gLXMgeCB5ICYmIHRlc3QgLWggeQonCgp0ZXN0X2xhenlfcHJlcmVxIEZJTEVNT0RFICcKCXRlc3QgIiQoZ2l0IGNvbmZpZyAtLWJvb2wgY29yZS5maWxlbW9kZSkiID0gdHJ1ZQonCgp0ZXN0X2xhenlfcHJlcmVxIENBU0VfSU5TRU5TSVRJVkVfRlMgJwoJZWNobyBnb29kID5DYW1lbENhc2UgJiYKCWVjaG8gYmFkID5jYW1lbGNhc2UgJiYKCXRlc3QgIiQoY2F0IENhbWVsQ2FzZSkiICE9IGdvb2QKJwoKdGVzdF9sYXp5X3ByZXJlcSBVVEY4X05GRF9UT19ORkMgJwoJIyBjaGVjayB3aGV0aGVyIEZTIGNvbnZlcnRzIG5mZCB1bmljb2RlIHRvIG5mYwoJYXVtbD0kKHByaW50ZiAiXDMwM1wyNDQiKQoJYXVtbGNkaWFyPSQocHJpbnRmICJcMTQxXDMxNFwyMTAiKQoJPiIkYXVtbCIgJiYKCWNhc2UgIiQoZWNobyAqKSIgaW4KCSIkYXVtbGNkaWFyIikKCQl0cnVlIDs7CgkqKQoJCWZhbHNlIDs7Cgllc2FjCicKCnRlc3RfbGF6eV9wcmVyZXEgQVVUT0lERU5UICcKCXNhbmVfdW5zZXQgR0lUX0FVVEhPUl9OQU1FICYmCglzYW5lX3Vuc2V0IEdJVF9BVVRIT1JfRU1BSUwgJiYKCWdpdCB2YXIgR0lUX0FVVEhPUl9JREVOVAonCgp0ZXN0X2xhenlfcHJlcmVxIEVYUEVOU0lWRSAnCgl0ZXN0IC1uICIkR0lUX1RFU1RfTE9ORyIKJwoKdGVzdF9sYXp5X3ByZXJlcSBVU1JfQklOX1RJTUUgJwoJdGVzdCAteCAvdXNyL2Jpbi90aW1lCicKCnRlc3RfbGF6eV9wcmVyZXEgTk9UX1JPT1QgJwoJdWlkPSQoaWQgLXUpICYmCgl0ZXN0ICIkdWlkIiAhPSAwCicKCiMgU0FOSVRZIGlzIGFib3V0ICJjYW4geW91IGNvcnJlY3RseSBwcmVkaWN0IHdoYXQgdGhlIGZpbGVzeXN0ZW0gd291bGQKIyBkbyBieSBvbmx5IGxvb2tpbmcgYXQgdGhlIHBlcm1pc3Npb24gYml0cyBvZiB0aGUgZmlsZXMgYW5kCiMgZGlyZWN0b3JpZXM/IiAgQSB0eXBpY2FsIGV4YW1wbGUgb2YgIVNBTklUWSBpcyBydW5uaW5nIHRoZSB0ZXN0CiMgc3VpdGUgYXMgcm9vdCwgd2hlcmUgYSB0ZXN0IG1heSBleHBlY3QgImNobW9kIC1yIGZpbGUgJiYgY2F0IGZpbGUiCiMgdG8gZmFpbCBiZWNhdXNlIGZpbGUgaXMgc3VwcG9zZWQgdG8gYmUgdW5yZWFkYWJsZSBhZnRlciBhIHN1Y2Nlc3NmdWwKIyBjaG1vZC4gIEluIGFuIGVudmlyb25tZW50IChpLmUuIGNvbWJpbmF0aW9uIG9mIHdoYXQgZmlsZXN5c3RlbSBpcwojIGJlaW5nIHVzZWQgYW5kIHdobyBpcyBydW5uaW5nIHRoZSB0ZXN0cykgdGhhdCBsYWNrcyBTQU5JVFksIHlvdSBtYXkKIyBiZSBhYmxlIHRvIGRlbGV0ZSBvciBjcmVhdGUgYSBmaWxlIHdoZW4gdGhlIGNvbnRhaW5pbmcgZGlyZWN0b3J5CiMgZG9lc24ndCBoYXZlIHdyaXRlIHBlcm1pc3Npb25zLCBvciBhY2Nlc3MgYSBmaWxlIGV2ZW4gaWYgdGhlCiMgY29udGFpbmluZyBkaXJlY3RvcnkgZG9lc24ndCBoYXZlIHJlYWQgb3IgZXhlY3V0ZSBwZXJtaXNzaW9ucy4KCnRlc3RfbGF6eV9wcmVyZXEgU0FOSVRZICcKCW1rZGlyIFNBTkVURVNURC4xIFNBTkVURVNURC4yICYmCgoJY2htb2QgK3cgU0FORVRFU1RELjEgU0FORVRFU1RELjIgJiYKCT5TQU5FVEVTVEQuMS94IDI+U0FORVRFU1RELjIveCAmJgoJY2htb2QgLXcgU0FORVRFU1RELjEgJiYKCWNobW9kIC1yIFNBTkVURVNURC4xL3ggJiYKCWNobW9kIC1yeCBTQU5FVEVTVEQuMiB8fAoJZXJyb3IgImJ1ZyBpbiB0ZXN0IHNyaXB0OiBjYW5ub3QgcHJlcGFyZSBTQU5FVEVTVEQiCgoJISB0ZXN0IC1yIFNBTkVURVNURC4xL3ggJiYKCSEgcm0gU0FORVRFU1RELjEveCAmJiAhIHRlc3QgLWYgU0FORVRFU1RELjIveAoJc3RhdHVzPSQ/CgoJY2htb2QgK3J3eCBTQU5FVEVTVEQuMSBTQU5FVEVTVEQuMiAmJgoJcm0gLXJmIFNBTkVURVNURC4xIFNBTkVURVNURC4yIHx8CgllcnJvciAiYnVnIGluIHRlc3Qgc3JpcHQ6IGNhbm5vdCBjbGVhbiBTQU5FVEVTVEQiCglyZXR1cm4gJHN0YXR1cwonCgpHSVRfVU5aSVA9JHtHSVRfVU5aSVA6LXVuemlwfQp0ZXN0X2xhenlfcHJlcmVxIFVOWklQICcKCSIkR0lUX1VOWklQIiAtdgoJdGVzdCAkPyAtbmUgMTI3CicKCnJ1bl93aXRoX2xpbWl0ZWRfY21kbGluZSAoKSB7CgkodWxpbWl0IC1zIDEyOCAmJiAiJEAiKQp9Cgp0ZXN0X2xhenlfcHJlcmVxIENNRExJTkVfTElNSVQgJ3J1bl93aXRoX2xpbWl0ZWRfY21kbGluZSB0cnVlJwo=",
    "text": "# Test framework for git.  See t/README for usage.\n#\n# Copyright (c) 2005 Junio C Hamano\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see http://www.gnu.org/licenses/ .\n\n# Test the binaries we have just built.  The tests are kept in\n# t/ subdirectory and are run in 'trash directory' subdirectory.\nif test -z \"$TEST_DIRECTORY\"\nthen\n\t# We allow tests to override this, in case they want to run tests\n\t# outside of t/, e.g. for running tests on the test library\n\t# itself.\n\tTEST_DIRECTORY=$(pwd)\nelse\n\t# ensure that TEST_DIRECTORY is an absolute path so that it\n\t# is valid even if the current working directory is changed\n\tTEST_DIRECTORY=$(cd \"$TEST_DIRECTORY\" && pwd) || exit 1\nfi\nif test -z \"$TEST_OUTPUT_DIRECTORY\"\nthen\n\t# Similarly, override this to store the test-results subdir\n\t# elsewhere\n\tTEST_OUTPUT_DIRECTORY=$TEST_DIRECTORY\nfi\nGIT_BUILD_DIR=\"$TEST_DIRECTORY\"/..\n\n################################################################\n# It appears that people try to run tests without building...\n\"$GIT_BUILD_DIR/git\" >/dev/null\nif test $? != 1\nthen\n\techo >&2 'error: you do not seem to have built git yet.'\n\texit 1\nfi\n\n. \"$GIT_BUILD_DIR\"/GIT-BUILD-OPTIONS\nexport PERL_PATH SHELL_PATH\n\n# if --tee was passed, write the output not only to the terminal, but\n# additionally to the file test-results/$BASENAME.out, too.\ncase \"$GIT_TEST_TEE_STARTED, $* \" in\ndone,*)\n\t# do not redirect again\n\t;;\n*' --tee '*|*' --va'*)\n\tmkdir -p \"$TEST_OUTPUT_DIRECTORY/test-results\"\n\tBASE=\"$TEST_OUTPUT_DIRECTORY/test-results/$(basename \"$0\" .sh)\"\n\t(GIT_TEST_TEE_STARTED=done ${SHELL_PATH} \"$0\" \"$@\" 2>&1;\n\t echo $? > $BASE.exit) | tee $BASE.out\n\ttest \"$(cat $BASE.exit)\" = 0\n\texit\n\t;;\nesac\n\n# For repeatability, reset the environment to known value.\n# TERM is sanitized below, after saving color control sequences.\nLANG=C\nLC_ALL=C\nPAGER=cat\nTZ=UTC\nexport LANG LC_ALL PAGER TZ\nEDITOR=:\n# A call to \"unset\" with no arguments causes at least Solaris 10\n# /usr/xpg4/bin/sh and /bin/ksh to bail out.  So keep the unsets\n# deriving from the command substitution clustered with the other\n# ones.\nunset VISUAL EMAIL LANGUAGE COLUMNS $(\"$PERL_PATH\" -e '\n\tmy @env = keys %ENV;\n\tmy $ok = join(\"|\", qw(\n\t\tTRACE\n\t\tDEBUG\n\t\tUSE_LOOKUP\n\t\tTEST\n\t\t.*_TEST\n\t\tPROVE\n\t\tVALGRIND\n\t\tUNZIP\n\t\tPERF_\n\t\tCURL_VERBOSE\n\t));\n\tmy @vars = grep(/^GIT_/ && !/^GIT_($ok)/o, @env);\n\tprint join(\"\\n\", @vars);\n')\nunset XDG_CONFIG_HOME\nunset GITPERLLIB\nGIT_AUTHOR_EMAIL=author@example.com\nGIT_AUTHOR_NAME='A U Thor'\nGIT_COMMITTER_EMAIL=committer@example.com\nGIT_COMMITTER_NAME='C O Mitter'\nGIT_MERGE_VERBOSITY=5\nGIT_MERGE_AUTOEDIT=no\nexport GIT_MERGE_VERBOSITY GIT_MERGE_AUTOEDIT\nexport GIT_AUTHOR_EMAIL GIT_AUTHOR_NAME\nexport GIT_COMMITTER_EMAIL GIT_COMMITTER_NAME\nexport EDITOR\n\n# Tests using GIT_TRACE typically don't want <timestamp> <file>:<line> output\nGIT_TRACE_BARE=1\nexport GIT_TRACE_BARE\n\nif test -n \"${TEST_GIT_INDEX_VERSION:+isset}\"\nthen\n\tGIT_INDEX_VERSION=\"$TEST_GIT_INDEX_VERSION\"\n\texport GIT_INDEX_VERSION\nfi\n\n# Add libc MALLOC and MALLOC_PERTURB test\n# only if we are not executing the test with valgrind\nif expr \" $GIT_TEST_OPTS \" : \".* --valgrind \" >/dev/null ||\n   test -n \"$TEST_NO_MALLOC_CHECK\"\nthen\n\tsetup_malloc_check () {\n\t\t: nothing\n\t}\n\tteardown_malloc_check () {\n\t\t: nothing\n\t}\nelse\n\tsetup_malloc_check () {\n\t\tMALLOC_CHECK_=3\tMALLOC_PERTURB_=165\n\t\texport MALLOC_CHECK_ MALLOC_PERTURB_\n\t}\n\tteardown_malloc_check () {\n\t\tunset MALLOC_CHECK_ MALLOC_PERTURB_\n\t}\nfi\n\n: ${ASAN_OPTIONS=detect_leaks=0}\nexport ASAN_OPTIONS\n\n# Protect ourselves from common misconfiguration to export\n# CDPATH into the environment\nunset CDPATH\n\nunset GREP_OPTIONS\nunset UNZIP\n\ncase $(echo $GIT_TRACE |tr \"[A-Z]\" \"[a-z]\") in\n1|2|true)\n\tGIT_TRACE=4\n\t;;\nesac\n\n# Convenience\n#\n# A regexp to match 5 and 40 hexdigits\n_x05='[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]'\n_x40=\"$_x05$_x05$_x05$_x05$_x05$_x05$_x05$_x05\"\n\n# Zero SHA-1\n_z40=0000000000000000000000000000000000000000\n\n# Line feed\nLF='\n'\n\n# UTF-8 ZERO WIDTH NON-JOINER, which HFS+ ignores\n# when case-folding filenames\nu200c=$(printf '\\342\\200\\214')\n\nexport _x05 _x40 _z40 LF u200c\n\n# Each test should start with something like this, after copyright notices:\n#\n# test_description='Description of this test...\n# This test checks if command xyzzy does the right thing...\n# '\n# . ./test-lib.sh\ntest \"x$TERM\" != \"xdumb\" && (\n\t\ttest -t 1 &&\n\t\ttput bold >/dev/null 2>&1 &&\n\t\ttput setaf 1 >/dev/null 2>&1 &&\n\t\ttput sgr0 >/dev/null 2>&1\n\t) &&\n\tcolor=t\n\nwhile test \"$#\" -ne 0\ndo\n\tcase \"$1\" in\n\t-d|--d|--de|--deb|--debu|--debug)\n\t\tdebug=t; shift ;;\n\t-i|--i|--im|--imm|--imme|--immed|--immedi|--immedia|--immediat|--immediate)\n\t\timmediate=t; shift ;;\n\t-l|--l|--lo|--lon|--long|--long-|--long-t|--long-te|--long-tes|--long-test|--long-tests)\n\t\tGIT_TEST_LONG=t; export GIT_TEST_LONG; shift ;;\n\t-r)\n\t\tshift; test \"$#\" -ne 0 || {\n\t\t\techo 'error: -r requires an argument' >&2;\n\t\t\texit 1;\n\t\t}\n\t\trun_list=$1; shift ;;\n\t--run=*)\n\t\trun_list=${1#--*=}; shift ;;\n\t-h|--h|--he|--hel|--help)\n\t\thelp=t; shift ;;\n\t-v|--v|--ve|--ver|--verb|--verbo|--verbos|--verbose)\n\t\tverbose=t; shift ;;\n\t--verbose-only=*)\n\t\tverbose_only=${1#--*=}\n\t\tshift ;;\n\t-q|--q|--qu|--qui|--quie|--quiet)\n\t\t# Ignore --quiet under a TAP::Harness. Saying how many tests\n\t\t# passed without the ok/not ok details is always an error.\n\t\ttest -z \"$HARNESS_ACTIVE\" && quiet=t; shift ;;\n\t--with-dashes)\n\t\twith_dashes=t; shift ;;\n\t--no-color)\n\t\tcolor=; shift ;;\n\t--va|--val|--valg|--valgr|--valgri|--valgrin|--valgrind)\n\t\tvalgrind=memcheck\n\t\tshift ;;\n\t--valgrind=*)\n\t\tvalgrind=${1#--*=}\n\t\tshift ;;\n\t--valgrind-only=*)\n\t\tvalgrind_only=${1#--*=}\n\t\tshift ;;\n\t--tee)\n\t\tshift ;; # was handled already\n\t--root=*)\n\t\troot=${1#--*=}\n\t\tshift ;;\n\t--chain-lint)\n\t\tGIT_TEST_CHAIN_LINT=1\n\t\tshift ;;\n\t--no-chain-lint)\n\t\tGIT_TEST_CHAIN_LINT=0\n\t\tshift ;;\n\t-x)\n\t\ttrace=t\n\t\tverbose=t\n\t\tshift ;;\n\t*)\n\t\techo \"error: unknown test option '$1'\" >&2; exit 1 ;;\n\tesac\ndone\n\nif test -n \"$valgrind_only\"\nthen\n\ttest -z \"$valgrind\" && valgrind=memcheck\n\ttest -z \"$verbose\" && verbose_only=\"$valgrind_only\"\nelif test -n \"$valgrind\"\nthen\n\tverbose=t\nfi\n\nif test -n \"$color\"\nthen\n\t# Save the color control sequences now rather than run tput\n\t# each time say_color() is called.  This is done for two\n\t# reasons:\n\t#   * TERM will be changed to dumb\n\t#   * HOME will be changed to a temporary directory and tput\n\t#     might need to read ~/.terminfo from the original HOME\n\t#     directory to get the control sequences\n\t# Note:  This approach assumes the control sequences don't end\n\t# in a newline for any terminal of interest (command\n\t# substitutions strip trailing newlines).  Given that most\n\t# (all?) terminals in common use are related to ECMA-48, this\n\t# shouldn't be a problem.\n\tsay_color_error=$(tput bold; tput setaf 1) # bold red\n\tsay_color_skip=$(tput setaf 4) # blue\n\tsay_color_warn=$(tput setaf 3) # brown/yellow\n\tsay_color_pass=$(tput setaf 2) # green\n\tsay_color_info=$(tput setaf 6) # cyan\n\tsay_color_reset=$(tput sgr0)\n\tsay_color_=\"\" # no formatting for normal text\n\tsay_color () {\n\t\ttest -z \"$1\" && test -n \"$quiet\" && return\n\t\teval \"say_color_color=\\$say_color_$1\"\n\t\tshift\n\t\tprintf \"%s\\\\n\" \"$say_color_color$*$say_color_reset\"\n\t}\nelse\n\tsay_color() {\n\t\ttest -z \"$1\" && test -n \"$quiet\" && return\n\t\tshift\n\t\tprintf \"%s\\n\" \"$*\"\n\t}\nfi\n\nTERM=dumb\nexport TERM\n\nerror () {\n\tsay_color error \"error: $*\"\n\tGIT_EXIT_OK=t\n\texit 1\n}\n\nsay () {\n\tsay_color info \"$*\"\n}\n\ntest \"${test_description}\" != \"\" ||\nerror \"Test script did not set test_description.\"\n\nif test \"$help\" = \"t\"\nthen\n\tprintf '%s\\n' \"$test_description\"\n\texit 0\nfi\n\nexec 5>&1\nexec 6<&0\nif test \"$verbose\" = \"t\"\nthen\n\texec 4>&2 3>&1\nelse\n\texec 4>/dev/null 3>/dev/null\nfi\n\n# Send any \"-x\" output directly to stderr to avoid polluting tests\n# which capture stderr. We can do this unconditionally since it\n# has no effect if tracing isn't turned on.\n#\n# Note that this sets up the trace fd as soon as we assign the variable, so it\n# must come after the creation of descriptor 4 above. Likewise, we must never\n# unset this, as it has the side effect of closing descriptor 4, which we\n# use to show verbose tests to the user.\n#\n# Note also that we don't need or want to export it. The tracing is local to\n# this shell, and we would not want to influence any shells we exec.\nBASH_XTRACEFD=4\n\ntest_failure=0\ntest_count=0\ntest_fixed=0\ntest_broken=0\ntest_success=0\n\ntest_external_has_tap=0\n\ndie () {\n\tcode=$?\n\tif test -n \"$GIT_EXIT_OK\"\n\tthen\n\t\texit $code\n\telse\n\t\techo >&5 \"FATAL: Unexpected exit with code $code\"\n\t\texit 1\n\tfi\n}\n\nGIT_EXIT_OK=\ntrap 'die' EXIT\ntrap 'exit $?' INT\n\n# The user-facing functions are loaded from a separate file so that\n# test_perf subshells can have them too\n. \"$TEST_DIRECTORY/test-lib-functions.sh\"\n\n# You are not expected to call test_ok_ and test_failure_ directly, use\n# the test_expect_* functions instead.\n\ntest_ok_ () {\n\ttest_success=$(($test_success + 1))\n\tsay_color \"\" \"ok $test_count - $@\"\n}\n\ntest_failure_ () {\n\ttest_failure=$(($test_failure + 1))\n\tsay_color error \"not ok $test_count - $1\"\n\tshift\n\tprintf '%s\\n' \"$*\" | sed -e 's/^/#\t/'\n\ttest \"$immediate\" = \"\" || { GIT_EXIT_OK=t; exit 1; }\n}\n\ntest_known_broken_ok_ () {\n\ttest_fixed=$(($test_fixed+1))\n\tsay_color error \"ok $test_count - $@ # TODO known breakage vanished\"\n}\n\ntest_known_broken_failure_ () {\n\ttest_broken=$(($test_broken+1))\n\tsay_color warn \"not ok $test_count - $@ # TODO known breakage\"\n}\n\ntest_debug () {\n\ttest \"$debug\" = \"\" || eval \"$1\"\n}\n\nmatch_pattern_list () {\n\targ=\"$1\"\n\tshift\n\ttest -z \"$*\" && return 1\n\tfor pattern_\n\tdo\n\t\tcase \"$arg\" in\n\t\t$pattern_)\n\t\t\treturn 0\n\t\tesac\n\tdone\n\treturn 1\n}\n\nmatch_test_selector_list () {\n\ttitle=\"$1\"\n\tshift\n\targ=\"$1\"\n\tshift\n\ttest -z \"$1\" && return 0\n\n\t# Both commas and whitespace are accepted as separators.\n\tOLDIFS=$IFS\n\tIFS=' \t,'\n\tset -- $1\n\tIFS=$OLDIFS\n\n\t# If the first selector is negative we include by default.\n\tinclude=\n\tcase \"$1\" in\n\t\t!*) include=t ;;\n\tesac\n\n\tfor selector\n\tdo\n\t\torig_selector=$selector\n\n\t\tpositive=t\n\t\tcase \"$selector\" in\n\t\t\t!*)\n\t\t\t\tpositive=\n\t\t\t\tselector=${selector##?}\n\t\t\t\t;;\n\t\tesac\n\n\t\ttest -z \"$selector\" && continue\n\n\t\tcase \"$selector\" in\n\t\t\t*-*)\n\t\t\t\tif expr \"z${selector%%-*}\" : \"z[0-9]*[^0-9]\" >/dev/null\n\t\t\t\tthen\n\t\t\t\t\techo \"error: $title: invalid non-numeric in range\" \\\n\t\t\t\t\t\t\"start: '$orig_selector'\" >&2\n\t\t\t\t\texit 1\n\t\t\t\tfi\n\t\t\t\tif expr \"z${selector#*-}\" : \"z[0-9]*[^0-9]\" >/dev/null\n\t\t\t\tthen\n\t\t\t\t\techo \"error: $title: invalid non-numeric in range\" \\\n\t\t\t\t\t\t\"end: '$orig_selector'\" >&2\n\t\t\t\t\texit 1\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tif expr \"z$selector\" : \"z[0-9]*[^0-9]\" >/dev/null\n\t\t\t\tthen\n\t\t\t\t\techo \"error: $title: invalid non-numeric in test\" \\\n\t\t\t\t\t\t\"selector: '$orig_selector'\" >&2\n\t\t\t\t\texit 1\n\t\t\t\tfi\n\t\tesac\n\n\t\t# Short cut for \"obvious\" cases\n\t\ttest -z \"$include\" && test -z \"$positive\" && continue\n\t\ttest -n \"$include\" && test -n \"$positive\" && continue\n\n\t\tcase \"$selector\" in\n\t\t\t-*)\n\t\t\t\tif test $arg -le ${selector#-}\n\t\t\t\tthen\n\t\t\t\t\tinclude=$positive\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*-)\n\t\t\t\tif test $arg -ge ${selector%-}\n\t\t\t\tthen\n\t\t\t\t\tinclude=$positive\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*-*)\n\t\t\t\tif test ${selector%%-*} -le $arg \\\n\t\t\t\t\t&& test $arg -le ${selector#*-}\n\t\t\t\tthen\n\t\t\t\t\tinclude=$positive\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tif test $arg -eq $selector\n\t\t\t\tthen\n\t\t\t\t\tinclude=$positive\n\t\t\t\tfi\n\t\t\t\t;;\n\t\tesac\n\tdone\n\n\ttest -n \"$include\"\n}\n\nmaybe_teardown_verbose () {\n\ttest -z \"$verbose_only\" && return\n\texec 4>/dev/null 3>/dev/null\n\tverbose=\n}\n\nlast_verbose=t\nmaybe_setup_verbose () {\n\ttest -z \"$verbose_only\" && return\n\tif match_pattern_list $test_count $verbose_only\n\tthen\n\t\texec 4>&2 3>&1\n\t\t# Emit a delimiting blank line when going from\n\t\t# non-verbose to verbose.  Within verbose mode the\n\t\t# delimiter is printed by test_expect_*.  The choice\n\t\t# of the initial $last_verbose is such that before\n\t\t# test 1, we do not print it.\n\t\ttest -z \"$last_verbose\" && echo >&3 \"\"\n\t\tverbose=t\n\telse\n\t\texec 4>/dev/null 3>/dev/null\n\t\tverbose=\n\tfi\n\tlast_verbose=$verbose\n}\n\nmaybe_teardown_valgrind () {\n\ttest -z \"$GIT_VALGRIND\" && return\n\tGIT_VALGRIND_ENABLED=\n}\n\nmaybe_setup_valgrind () {\n\ttest -z \"$GIT_VALGRIND\" && return\n\tif test -z \"$valgrind_only\"\n\tthen\n\t\tGIT_VALGRIND_ENABLED=t\n\t\treturn\n\tfi\n\tGIT_VALGRIND_ENABLED=\n\tif match_pattern_list $test_count $valgrind_only\n\tthen\n\t\tGIT_VALGRIND_ENABLED=t\n\tfi\n}\n\nwant_trace () {\n\ttest \"$trace\" = t && test \"$verbose\" = t\n}\n\n# This is a separate function because some tests use\n# \"return\" to end a test_expect_success block early\n# (and we want to make sure we run any cleanup like\n# \"set +x\").\ntest_eval_inner_ () {\n\t# Do not add anything extra (including LF) after '$*'\n\teval \"\n\t\twant_trace && set -x\n\t\t$*\"\n}\n\ntest_eval_ () {\n\t# We run this block with stderr redirected to avoid extra cruft\n\t# during a \"-x\" trace. Once in \"set -x\" mode, we cannot prevent\n\t# the shell from printing the \"set +x\" to turn it off (nor the saving\n\t# of $? before that). But we can make sure that the output goes to\n\t# /dev/null.\n\t#\n\t# The test itself is run with stderr put back to &4 (so either to\n\t# /dev/null, or to the original stderr if --verbose was used).\n\t{\n\t\ttest_eval_inner_ \"$@\" </dev/null >&3 2>&4\n\t\ttest_eval_ret_=$?\n\t\tif want_trace\n\t\tthen\n\t\t\tset +x\n\t\t\tif test \"$test_eval_ret_\" != 0\n\t\t\tthen\n\t\t\t\tsay_color error >&4 \"error: last command exited with \\$?=$test_eval_ret_\"\n\t\t\tfi\n\t\tfi\n\t} 2>/dev/null\n\treturn $test_eval_ret_\n}\n\ntest_run_ () {\n\ttest_cleanup=:\n\texpecting_failure=$2\n\n\tif test \"${GIT_TEST_CHAIN_LINT:-1}\" != 0; then\n\t\t# turn off tracing for this test-eval, as it simply creates\n\t\t# confusing noise in the \"-x\" output\n\t\ttrace_tmp=$trace\n\t\ttrace=\n\t\t# 117 is magic because it is unlikely to match the exit\n\t\t# code of other programs\n\t\ttest_eval_ \"(exit 117) && $1\"\n\t\tif test \"$?\" != 117; then\n\t\t\terror \"bug in the test script: broken &&-chain: $1\"\n\t\tfi\n\t\ttrace=$trace_tmp\n\tfi\n\n\tsetup_malloc_check\n\ttest_eval_ \"$1\"\n\teval_ret=$?\n\tteardown_malloc_check\n\n\tif test -z \"$immediate\" || test $eval_ret = 0 ||\n\t   test -n \"$expecting_failure\" && test \"$test_cleanup\" != \":\"\n\tthen\n\t\tsetup_malloc_check\n\t\ttest_eval_ \"$test_cleanup\"\n\t\tteardown_malloc_check\n\tfi\n\tif test \"$verbose\" = \"t\" && test -n \"$HARNESS_ACTIVE\"\n\tthen\n\t\techo \"\"\n\tfi\n\treturn \"$eval_ret\"\n}\n\ntest_start_ () {\n\ttest_count=$(($test_count+1))\n\tmaybe_setup_verbose\n\tmaybe_setup_valgrind\n}\n\ntest_finish_ () {\n\techo >&3 \"\"\n\tmaybe_teardown_valgrind\n\tmaybe_teardown_verbose\n}\n\ntest_skip () {\n\tto_skip=\n\tskipped_reason=\n\tif match_pattern_list $this_test.$test_count $GIT_SKIP_TESTS\n\tthen\n\t\tto_skip=t\n\t\tskipped_reason=\"GIT_SKIP_TESTS\"\n\tfi\n\tif test -z \"$to_skip\" && test -n \"$test_prereq\" &&\n\t   ! test_have_prereq \"$test_prereq\"\n\tthen\n\t\tto_skip=t\n\n\t\tof_prereq=\n\t\tif test \"$missing_prereq\" != \"$test_prereq\"\n\t\tthen\n\t\t\tof_prereq=\" of $test_prereq\"\n\t\tfi\n\t\tskipped_reason=\"missing $missing_prereq${of_prereq}\"\n\tfi\n\tif test -z \"$to_skip\" && test -n \"$run_list\" &&\n\t\t! match_test_selector_list '--run' $test_count \"$run_list\"\n\tthen\n\t\tto_skip=t\n\t\tskipped_reason=\"--run\"\n\tfi\n\n\tcase \"$to_skip\" in\n\tt)\n\t\tsay_color skip >&3 \"skipping test: $@\"\n\t\tsay_color skip \"ok $test_count # skip $1 ($skipped_reason)\"\n\t\t: true\n\t\t;;\n\t*)\n\t\tfalse\n\t\t;;\n\tesac\n}\n\n# stub; perf-lib overrides it\ntest_at_end_hook_ () {\n\t:\n}\n\ntest_done () {\n\tGIT_EXIT_OK=t\n\n\tif test -z \"$HARNESS_ACTIVE\"\n\tthen\n\t\ttest_results_dir=\"$TEST_OUTPUT_DIRECTORY/test-results\"\n\t\tmkdir -p \"$test_results_dir\"\n\t\tbase=${0##*/}\n\t\ttest_results_path=\"$test_results_dir/${base%.sh}-$$.counts\"\n\n\t\tcat >>\"$test_results_path\" <<-EOF\n\t\ttotal $test_count\n\t\tsuccess $test_success\n\t\tfixed $test_fixed\n\t\tbroken $test_broken\n\t\tfailed $test_failure\n\n\t\tEOF\n\tfi\n\n\tif test \"$test_fixed\" != 0\n\tthen\n\t\tsay_color error \"# $test_fixed known breakage(s) vanished; please update test(s)\"\n\tfi\n\tif test \"$test_broken\" != 0\n\tthen\n\t\tsay_color warn \"# still have $test_broken known breakage(s)\"\n\tfi\n\tif test \"$test_broken\" != 0 || test \"$test_fixed\" != 0\n\tthen\n\t\ttest_remaining=$(( $test_count - $test_broken - $test_fixed ))\n\t\tmsg=\"remaining $test_remaining test(s)\"\n\telse\n\t\ttest_remaining=$test_count\n\t\tmsg=\"$test_count test(s)\"\n\tfi\n\tcase \"$test_failure\" in\n\t0)\n\t\t# Maybe print SKIP message\n\t\tif test -n \"$skip_all\" && test $test_count -gt 0\n\t\tthen\n\t\t\terror \"Can't use skip_all after running some tests\"\n\t\tfi\n\t\ttest -z \"$skip_all\" || skip_all=\" # SKIP $skip_all\"\n\n\t\tif test $test_external_has_tap -eq 0\n\t\tthen\n\t\t\tif test $test_remaining -gt 0\n\t\t\tthen\n\t\t\t\tsay_color pass \"# passed all $msg\"\n\t\t\tfi\n\t\t\tsay \"1..$test_count$skip_all\"\n\t\tfi\n\n\t\ttest -d \"$remove_trash\" &&\n\t\tcd \"$(dirname \"$remove_trash\")\" &&\n\t\trm -rf \"$(basename \"$remove_trash\")\"\n\n\t\ttest_at_end_hook_\n\n\t\texit 0 ;;\n\n\t*)\n\t\tif test $test_external_has_tap -eq 0\n\t\tthen\n\t\t\tsay_color error \"# failed $test_failure among $msg\"\n\t\t\tsay \"1..$test_count\"\n\t\tfi\n\n\t\texit 1 ;;\n\n\tesac\n}\n\nif test -n \"$valgrind\"\nthen\n\tmake_symlink () {\n\t\ttest -h \"$2\" &&\n\t\ttest \"$1\" = \"$(readlink \"$2\")\" || {\n\t\t\t# be super paranoid\n\t\t\tif mkdir \"$2\".lock\n\t\t\tthen\n\t\t\t\trm -f \"$2\" &&\n\t\t\t\tln -s \"$1\" \"$2\" &&\n\t\t\t\trm -r \"$2\".lock\n\t\t\telse\n\t\t\t\twhile test -d \"$2\".lock\n\t\t\t\tdo\n\t\t\t\t\tsay \"Waiting for lock on $2.\"\n\t\t\t\t\tsleep 1\n\t\t\t\tdone\n\t\t\tfi\n\t\t}\n\t}\n\n\tmake_valgrind_symlink () {\n\t\t# handle only executables, unless they are shell libraries that\n\t\t# need to be in the exec-path.\n\t\ttest -x \"$1\" ||\n\t\ttest \"# \" = \"$(head -c 2 <\"$1\")\" ||\n\t\treturn;\n\n\t\tbase=$(basename \"$1\")\n\t\tsymlink_target=$GIT_BUILD_DIR/$base\n\t\t# do not override scripts\n\t\tif test -x \"$symlink_target\" &&\n\t\t    test ! -d \"$symlink_target\" &&\n\t\t    test \"#!\" != \"$(head -c 2 < \"$symlink_target\")\"\n\t\tthen\n\t\t\tsymlink_target=../valgrind.sh\n\t\tfi\n\t\tcase \"$base\" in\n\t\t*.sh|*.perl)\n\t\t\tsymlink_target=../unprocessed-script\n\t\tesac\n\t\t# create the link, or replace it if it is out of date\n\t\tmake_symlink \"$symlink_target\" \"$GIT_VALGRIND/bin/$base\" || exit\n\t}\n\n\t# override all git executables in TEST_DIRECTORY/..\n\tGIT_VALGRIND=$TEST_DIRECTORY/valgrind\n\tmkdir -p \"$GIT_VALGRIND\"/bin\n\tfor file in $GIT_BUILD_DIR/git* $GIT_BUILD_DIR/test-*\n\tdo\n\t\tmake_valgrind_symlink $file\n\tdone\n\t# special-case the mergetools loadables\n\tmake_symlink \"$GIT_BUILD_DIR\"/mergetools \"$GIT_VALGRIND/bin/mergetools\"\n\tOLDIFS=$IFS\n\tIFS=:\n\tfor path in $PATH\n\tdo\n\t\tls \"$path\"/git-* 2> /dev/null |\n\t\twhile read file\n\t\tdo\n\t\t\tmake_valgrind_symlink \"$file\"\n\t\tdone\n\tdone\n\tIFS=$OLDIFS\n\tPATH=$GIT_VALGRIND/bin:$PATH\n\tGIT_EXEC_PATH=$GIT_VALGRIND/bin\n\texport GIT_VALGRIND\n\tGIT_VALGRIND_MODE=\"$valgrind\"\n\texport GIT_VALGRIND_MODE\n\tGIT_VALGRIND_ENABLED=t\n\ttest -n \"$valgrind_only\" && GIT_VALGRIND_ENABLED=\n\texport GIT_VALGRIND_ENABLED\nelif test -n \"$GIT_TEST_INSTALLED\"\nthen\n\tGIT_EXEC_PATH=$($GIT_TEST_INSTALLED/git --exec-path)  ||\n\terror \"Cannot run git from $GIT_TEST_INSTALLED.\"\n\tPATH=$GIT_TEST_INSTALLED:$GIT_BUILD_DIR:$PATH\n\tGIT_EXEC_PATH=${GIT_TEST_EXEC_PATH:-$GIT_EXEC_PATH}\nelse # normal case, use ../bin-wrappers only unless $with_dashes:\n\tgit_bin_dir=\"$GIT_BUILD_DIR/bin-wrappers\"\n\tif ! test -x \"$git_bin_dir/git\"\n\tthen\n\t\tif test -z \"$with_dashes\"\n\t\tthen\n\t\t\tsay \"$git_bin_dir/git is not executable; using GIT_EXEC_PATH\"\n\t\tfi\n\t\twith_dashes=t\n\tfi\n\tPATH=\"$git_bin_dir:$PATH\"\n\tGIT_EXEC_PATH=$GIT_BUILD_DIR\n\tif test -n \"$with_dashes\"\n\tthen\n\t\tPATH=\"$GIT_BUILD_DIR:$PATH\"\n\tfi\nfi\nGIT_TEMPLATE_DIR=\"$GIT_BUILD_DIR\"/templates/blt\nGIT_CONFIG_NOSYSTEM=1\nGIT_ATTR_NOSYSTEM=1\nexport PATH GIT_EXEC_PATH GIT_TEMPLATE_DIR GIT_CONFIG_NOSYSTEM GIT_ATTR_NOSYSTEM\n\nif test -z \"$GIT_TEST_CMP\"\nthen\n\tif test -n \"$GIT_TEST_CMP_USE_COPIED_CONTEXT\"\n\tthen\n\t\tGIT_TEST_CMP=\"$DIFF -c\"\n\telse\n\t\tGIT_TEST_CMP=\"$DIFF -u\"\n\tfi\nfi\n\nGITPERLLIB=\"$GIT_BUILD_DIR\"/perl/blib/lib:\"$GIT_BUILD_DIR\"/perl/blib/arch/auto/Git\nexport GITPERLLIB\ntest -d \"$GIT_BUILD_DIR\"/templates/blt || {\n\terror \"You haven't built things yet, have you?\"\n}\n\nif ! test -x \"$GIT_BUILD_DIR\"/t/helper/test-chmtime\nthen\n\techo >&2 'You need to build test-chmtime:'\n\techo >&2 'Run \"make t/helper/test-chmtime\" in the source (toplevel) directory'\n\texit 1\nfi\n\n# Test repository\nTRASH_DIRECTORY=\"trash directory.$(basename \"$0\" .sh)\"\ntest -n \"$root\" && TRASH_DIRECTORY=\"$root/$TRASH_DIRECTORY\"\ncase \"$TRASH_DIRECTORY\" in\n/*) ;; # absolute path is good\n *) TRASH_DIRECTORY=\"$TEST_OUTPUT_DIRECTORY/$TRASH_DIRECTORY\" ;;\nesac\ntest ! -z \"$debug\" || remove_trash=$TRASH_DIRECTORY\nrm -fr \"$TRASH_DIRECTORY\" || {\n\tGIT_EXIT_OK=t\n\techo >&5 \"FATAL: Cannot prepare test area\"\n\texit 1\n}\n\nHOME=\"$TRASH_DIRECTORY\"\nGNUPGHOME=\"$HOME/gnupg-home-not-used\"\nexport HOME GNUPGHOME\n\nif test -z \"$TEST_NO_CREATE_REPO\"\nthen\n\ttest_create_repo \"$TRASH_DIRECTORY\"\nelse\n\tmkdir -p \"$TRASH_DIRECTORY\"\nfi\n# Use -P to resolve symlinks in our working directory so that the cwd\n# in subprocesses like git equals our $PWD (for pathname comparisons).\ncd -P \"$TRASH_DIRECTORY\" || exit 1\n\nthis_test=${0##*/}\nthis_test=${this_test%%-*}\nif match_pattern_list \"$this_test\" $GIT_SKIP_TESTS\nthen\n\tsay_color info >&3 \"skipping test $this_test altogether\"\n\tskip_all=\"skip all tests in $this_test\"\n\ttest_done\nfi\n\n# Provide an implementation of the 'yes' utility\nyes () {\n\tif test $# = 0\n\tthen\n\t\ty=y\n\telse\n\t\ty=\"$*\"\n\tfi\n\n\ti=0\n\twhile test $i -lt 99\n\tdo\n\t\techo \"$y\"\n\t\ti=$(($i+1))\n\tdone\n}\n\n# Fix some commands on Windows\ncase $(uname -s) in\n*MINGW*)\n\t# Windows has its own (incompatible) sort and find\n\tsort () {\n\t\t/usr/bin/sort \"$@\"\n\t}\n\tfind () {\n\t\t/usr/bin/find \"$@\"\n\t}\n\tsum () {\n\t\tmd5sum \"$@\"\n\t}\n\t# git sees Windows-style pwd\n\tpwd () {\n\t\tbuiltin pwd -W\n\t}\n\t# no POSIX permissions\n\t# backslashes in pathspec are converted to '/'\n\t# exec does not inherit the PID\n\ttest_set_prereq MINGW\n\ttest_set_prereq NATIVE_CRLF\n\ttest_set_prereq SED_STRIPS_CR\n\ttest_set_prereq GREP_STRIPS_CR\n\tGIT_TEST_CMP=mingw_test_cmp\n\t;;\n*CYGWIN*)\n\ttest_set_prereq POSIXPERM\n\ttest_set_prereq EXECKEEPSPID\n\ttest_set_prereq CYGWIN\n\ttest_set_prereq SED_STRIPS_CR\n\ttest_set_prereq GREP_STRIPS_CR\n\t;;\n*)\n\ttest_set_prereq POSIXPERM\n\ttest_set_prereq BSLASHPSPEC\n\ttest_set_prereq EXECKEEPSPID\n\t;;\nesac\n\n( COLUMNS=1 && test $COLUMNS = 1 ) && test_set_prereq COLUMNS_CAN_BE_1\ntest -z \"$NO_PERL\" && test_set_prereq PERL\ntest -z \"$NO_PYTHON\" && test_set_prereq PYTHON\ntest -n \"$USE_LIBPCRE\" && test_set_prereq LIBPCRE\ntest -z \"$NO_GETTEXT\" && test_set_prereq GETTEXT\n\n# Can we rely on git's output in the C locale?\nif test -n \"$GETTEXT_POISON\"\nthen\n\tGIT_GETTEXT_POISON=YesPlease\n\texport GIT_GETTEXT_POISON\n\ttest_set_prereq GETTEXT_POISON\nelse\n\ttest_set_prereq C_LOCALE_OUTPUT\nfi\n\n# Use this instead of test_cmp to compare files that contain expected and\n# actual output from git commands that can be translated.  When running\n# under GETTEXT_POISON this pretends that the command produced expected\n# results.\ntest_i18ncmp () {\n\ttest -n \"$GETTEXT_POISON\" || test_cmp \"$@\"\n}\n\n# Use this instead of \"grep expected-string actual\" to see if the\n# output from a git command that can be translated either contains an\n# expected string, or does not contain an unwanted one.  When running\n# under GETTEXT_POISON this pretends that the command produced expected\n# results.\ntest_i18ngrep () {\n\tif test -n \"$GETTEXT_POISON\"\n\tthen\n\t    : # pretend success\n\telif test \"x!\" = \"x$1\"\n\tthen\n\t\tshift\n\t\t! grep \"$@\"\n\telse\n\t\tgrep \"$@\"\n\tfi\n}\n\ntest_lazy_prereq PIPE '\n\t# test whether the filesystem supports FIFOs\n\tcase $(uname -s) in\n\tCYGWIN*|MINGW*)\n\t\tfalse\n\t\t;;\n\t*)\n\t\trm -f testfifo && mkfifo testfifo\n\t\t;;\n\tesac\n'\n\ntest_lazy_prereq SYMLINKS '\n\t# test whether the filesystem supports symbolic links\n\tln -s x y && test -h y\n'\n\ntest_lazy_prereq FILEMODE '\n\ttest \"$(git config --bool core.filemode)\" = true\n'\n\ntest_lazy_prereq CASE_INSENSITIVE_FS '\n\techo good >CamelCase &&\n\techo bad >camelcase &&\n\ttest \"$(cat CamelCase)\" != good\n'\n\ntest_lazy_prereq UTF8_NFD_TO_NFC '\n\t# check whether FS converts nfd unicode to nfc\n\tauml=$(printf \"\\303\\244\")\n\taumlcdiar=$(printf \"\\141\\314\\210\")\n\t>\"$auml\" &&\n\tcase \"$(echo *)\" in\n\t\"$aumlcdiar\")\n\t\ttrue ;;\n\t*)\n\t\tfalse ;;\n\tesac\n'\n\ntest_lazy_prereq AUTOIDENT '\n\tsane_unset GIT_AUTHOR_NAME &&\n\tsane_unset GIT_AUTHOR_EMAIL &&\n\tgit var GIT_AUTHOR_IDENT\n'\n\ntest_lazy_prereq EXPENSIVE '\n\ttest -n \"$GIT_TEST_LONG\"\n'\n\ntest_lazy_prereq USR_BIN_TIME '\n\ttest -x /usr/bin/time\n'\n\ntest_lazy_prereq NOT_ROOT '\n\tuid=$(id -u) &&\n\ttest \"$uid\" != 0\n'\n\n# SANITY is about \"can you correctly predict what the filesystem would\n# do by only looking at the permission bits of the files and\n# directories?\"  A typical example of !SANITY is running the test\n# suite as root, where a test may expect \"chmod -r file && cat file\"\n# to fail because file is supposed to be unreadable after a successful\n# chmod.  In an environment (i.e. combination of what filesystem is\n# being used and who is running the tests) that lacks SANITY, you may\n# be able to delete or create a file when the containing directory\n# doesn't have write permissions, or access a file even if the\n# containing directory doesn't have read or execute permissions.\n\ntest_lazy_prereq SANITY '\n\tmkdir SANETESTD.1 SANETESTD.2 &&\n\n\tchmod +w SANETESTD.1 SANETESTD.2 &&\n\t>SANETESTD.1/x 2>SANETESTD.2/x &&\n\tchmod -w SANETESTD.1 &&\n\tchmod -r SANETESTD.1/x &&\n\tchmod -rx SANETESTD.2 ||\n\terror \"bug in test sript: cannot prepare SANETESTD\"\n\n\t! test -r SANETESTD.1/x &&\n\t! rm SANETESTD.1/x && ! test -f SANETESTD.2/x\n\tstatus=$?\n\n\tchmod +rwx SANETESTD.1 SANETESTD.2 &&\n\trm -rf SANETESTD.1 SANETESTD.2 ||\n\terror \"bug in test sript: cannot clean SANETESTD\"\n\treturn $status\n'\n\nGIT_UNZIP=${GIT_UNZIP:-unzip}\ntest_lazy_prereq UNZIP '\n\t\"$GIT_UNZIP\" -v\n\ttest $? -ne 127\n'\n\nrun_with_limited_cmdline () {\n\t(ulimit -s 128 && \"$@\")\n}\n\ntest_lazy_prereq CMDLINE_LIMIT 'run_with_limited_cmdline true'\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0055ebba46d539f30b9484335501571c3b4879bd",
  "sha1_ok": true,
  "size": 25826
}
