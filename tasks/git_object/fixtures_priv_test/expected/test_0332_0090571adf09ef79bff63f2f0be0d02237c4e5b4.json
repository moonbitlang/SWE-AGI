{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGNvbW1pdCIKICoKICogQ29weXJpZ2h0IChjKSAyMDA3IEtyaXN0aWFuIEjDuGdzYmVyZyA8a3JoQHJlZGhhdC5jb20+CiAqIEJhc2VkIG9uIGdpdC1jb21taXQuc2ggYnkgSnVuaW8gQyBIYW1hbm8gYW5kIExpbnVzIFRvcnZhbGRzCiAqLwoKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjYWNoZS10cmVlLmgiCiNpbmNsdWRlICJjb2xvci5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJkaWZmLmgiCiNpbmNsdWRlICJkaWZmY29yZS5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAid3Qtc3RhdHVzLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAibG9nLXRyZWUuaCIKI2luY2x1ZGUgInN0cmJ1Zi5oIgojaW5jbHVkZSAidXRmOC5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgInJlcmVyZS5oIgojaW5jbHVkZSAidW5wYWNrLXRyZWVzLmgiCiNpbmNsdWRlICJxdW90ZS5oIgojaW5jbHVkZSAic3VibW9kdWxlLmgiCgpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGJ1aWx0aW5fY29tbWl0X3VzYWdlW10gPSB7CgkiZ2l0IGNvbW1pdCBbb3B0aW9uc10gWy0tXSA8ZmlsZXBhdHRlcm4+Li4uIiwKCU5VTEwKfTsKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgYnVpbHRpbl9zdGF0dXNfdXNhZ2VbXSA9IHsKCSJnaXQgc3RhdHVzIFtvcHRpb25zXSBbLS1dIDxmaWxlcGF0dGVybj4uLi4iLAoJTlVMTAp9OwoKc3RhdGljIGNvbnN0IGNoYXIgaW1wbGljaXRfaWRlbnRfYWR2aWNlW10gPQoiWW91ciBuYW1lIGFuZCBlbWFpbCBhZGRyZXNzIHdlcmUgY29uZmlndXJlZCBhdXRvbWF0aWNhbGx5IGJhc2VkXG4iCiJvbiB5b3VyIHVzZXJuYW1lIGFuZCBob3N0bmFtZS4gUGxlYXNlIGNoZWNrIHRoYXQgdGhleSBhcmUgYWNjdXJhdGUuXG4iCiJZb3UgY2FuIHN1cHByZXNzIHRoaXMgbWVzc2FnZSBieSBzZXR0aW5nIHRoZW0gZXhwbGljaXRseTpcbiIKIlxuIgoiICAgIGdpdCBjb25maWcgLS1nbG9iYWwgdXNlci5uYW1lIFwiWW91ciBOYW1lXCJcbiIKIiAgICBnaXQgY29uZmlnIC0tZ2xvYmFsIHVzZXIuZW1haWwgeW91QGV4YW1wbGUuY29tXG4iCiJcbiIKIkFmdGVyIGRvaW5nIHRoaXMsIHlvdSBtYXkgZml4IHRoZSBpZGVudGl0eSB1c2VkIGZvciB0aGlzIGNvbW1pdCB3aXRoOlxuIgoiXG4iCiIgICAgZ2l0IGNvbW1pdCAtLWFtZW5kIC0tcmVzZXQtYXV0aG9yXG4iOwoKc3RhdGljIGNvbnN0IGNoYXIgZW1wdHlfYW1lbmRfYWR2aWNlW10gPQoiWW91IGFza2VkIHRvIGFtZW5kIHRoZSBtb3N0IHJlY2VudCBjb21taXQsIGJ1dCBkb2luZyBzbyB3b3VsZCBtYWtlXG4iCiJpdCBlbXB0eS4gWW91IGNhbiByZXBlYXQgeW91ciBjb21tYW5kIHdpdGggLS1hbGxvdy1lbXB0eSwgb3IgeW91IGNhblxuIgoicmVtb3ZlIHRoZSBjb21taXQgZW50aXJlbHkgd2l0aCBcImdpdCByZXNldCBIRUFEXlwiLlxuIjsKCnN0YXRpYyB1bnNpZ25lZCBjaGFyIGhlYWRfc2hhMVsyMF07CgpzdGF0aWMgY2hhciAqdXNlX21lc3NhZ2VfYnVmZmVyOwpzdGF0aWMgY29uc3QgY2hhciBjb21taXRfZWRpdG1zZ1tdID0gIkNPTU1JVF9FRElUTVNHIjsKc3RhdGljIHN0cnVjdCBsb2NrX2ZpbGUgaW5kZXhfbG9jazsgLyogcmVhbCBpbmRleCAqLwpzdGF0aWMgc3RydWN0IGxvY2tfZmlsZSBmYWxzZV9sb2NrOyAvKiB1c2VkIG9ubHkgZm9yIHBhcnRpYWwgY29tbWl0cyAqLwpzdGF0aWMgZW51bSB7CglDT01NSVRfQVNfSVMgPSAxLAoJQ09NTUlUX05PUk1BTCwKCUNPTU1JVF9QQVJUSUFMCn0gY29tbWl0X3N0eWxlOwoKc3RhdGljIGNvbnN0IGNoYXIgKmxvZ2ZpbGUsICpmb3JjZV9hdXRob3I7CnN0YXRpYyBjb25zdCBjaGFyICp0ZW1wbGF0ZV9maWxlOwpzdGF0aWMgY2hhciAqZWRpdF9tZXNzYWdlLCAqdXNlX21lc3NhZ2U7CnN0YXRpYyBjaGFyICpmaXh1cF9tZXNzYWdlLCAqc3F1YXNoX21lc3NhZ2U7CnN0YXRpYyBpbnQgYWxsLCBlZGl0X2ZsYWcsIGFsc28sIGludGVyYWN0aXZlLCBvbmx5LCBhbWVuZCwgc2lnbm9mZjsKc3RhdGljIGludCBxdWlldCwgdmVyYm9zZSwgbm9fdmVyaWZ5LCBhbGxvd19lbXB0eSwgZHJ5X3J1biwgcmVuZXdfYXV0aG9yc2hpcDsKc3RhdGljIGludCBub19wb3N0X3Jld3JpdGUsIGFsbG93X2VtcHR5X21lc3NhZ2U7CnN0YXRpYyBjaGFyICp1bnRyYWNrZWRfZmlsZXNfYXJnLCAqZm9yY2VfZGF0ZSwgKmlnbm9yZV9zdWJtb2R1bGVfYXJnOwovKgogKiBUaGUgZGVmYXVsdCBjb21taXQgbWVzc2FnZSBjbGVhbnVwIG1vZGUgd2lsbCByZW1vdmUgdGhlIGxpbmVzCiAqIGJlZ2lubmluZyB3aXRoICMgKHNoZWxsIGNvbW1lbnRzKSBhbmQgbGVhZGluZyBhbmQgdHJhaWxpbmcKICogd2hpdGVzcGFjZXMgKGVtcHR5IGxpbmVzIG9yIGNvbnRhaW5pbmcgb25seSB3aGl0ZXNwYWNlcykKICogaWYgZWRpdG9yIGlzIHVzZWQsIGFuZCBvbmx5IHRoZSB3aGl0ZXNwYWNlcyBpZiB0aGUgbWVzc2FnZQogKiBpcyBzcGVjaWZpZWQgZXhwbGljaXRseS4KICovCnN0YXRpYyBlbnVtIHsKCUNMRUFOVVBfU1BBQ0UsCglDTEVBTlVQX05PTkUsCglDTEVBTlVQX0FMTAp9IGNsZWFudXBfbW9kZTsKc3RhdGljIGNoYXIgKmNsZWFudXBfYXJnOwoKc3RhdGljIGludCB1c2VfZWRpdG9yID0gMSwgaW5pdGlhbF9jb21taXQsIGluX21lcmdlLCBpbmNsdWRlX3N0YXR1cyA9IDE7CnN0YXRpYyBpbnQgc2hvd19pZ25vcmVkX2luX3N0YXR1czsKc3RhdGljIGNvbnN0IGNoYXIgKm9ubHlfaW5jbHVkZV9hc3N1bWVkOwpzdGF0aWMgc3RydWN0IHN0cmJ1ZiBtZXNzYWdlOwoKc3RhdGljIGludCBudWxsX3Rlcm1pbmF0aW9uOwpzdGF0aWMgZW51bSB7CglTVEFUVVNfRk9STUFUX0xPTkcsCglTVEFUVVNfRk9STUFUX1NIT1JULAoJU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU4KfSBzdGF0dXNfZm9ybWF0ID0gU1RBVFVTX0ZPUk1BVF9MT05HOwpzdGF0aWMgaW50IHN0YXR1c19zaG93X2JyYW5jaDsKCnN0YXRpYyBpbnQgb3B0X3BhcnNlX20oY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJc3RydWN0IHN0cmJ1ZiAqYnVmID0gb3B0LT52YWx1ZTsKCWlmICh1bnNldCkKCQlzdHJidWZfc2V0bGVuKGJ1ZiwgMCk7CgllbHNlIHsKCQlzdHJidWZfYWRkc3RyKGJ1ZiwgYXJnKTsKCQlzdHJidWZfYWRkc3RyKGJ1ZiwgIlxuXG4iKTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgc3RydWN0IG9wdGlvbiBidWlsdGluX2NvbW1pdF9vcHRpb25zW10gPSB7CglPUFRfX1FVSUVUKCZxdWlldCwgInN1cHByZXNzIHN1bW1hcnkgYWZ0ZXIgc3VjY2Vzc2Z1bCBjb21taXQiKSwKCU9QVF9fVkVSQk9TRSgmdmVyYm9zZSwgInNob3cgZGlmZiBpbiBjb21taXQgbWVzc2FnZSB0ZW1wbGF0ZSIpLAoKCU9QVF9HUk9VUCgiQ29tbWl0IG1lc3NhZ2Ugb3B0aW9ucyIpLAoJT1BUX0ZJTEVOQU1FKCdGJywgImZpbGUiLCAmbG9nZmlsZSwgInJlYWQgbWVzc2FnZSBmcm9tIGZpbGUiKSwKCU9QVF9TVFJJTkcoMCwgImF1dGhvciIsICZmb3JjZV9hdXRob3IsICJBVVRIT1IiLCAib3ZlcnJpZGUgYXV0aG9yIGZvciBjb21taXQiKSwKCU9QVF9TVFJJTkcoMCwgImRhdGUiLCAmZm9yY2VfZGF0ZSwgIkRBVEUiLCAib3ZlcnJpZGUgZGF0ZSBmb3IgY29tbWl0IiksCglPUFRfQ0FMTEJBQ0soJ20nLCAibWVzc2FnZSIsICZtZXNzYWdlLCAiTUVTU0FHRSIsICJjb21taXQgbWVzc2FnZSIsIG9wdF9wYXJzZV9tKSwKCU9QVF9TVFJJTkcoJ2MnLCAicmVlZGl0LW1lc3NhZ2UiLCAmZWRpdF9tZXNzYWdlLCAiQ09NTUlUIiwgInJldXNlIGFuZCBlZGl0IG1lc3NhZ2UgZnJvbSBzcGVjaWZpZWQgY29tbWl0IiksCglPUFRfU1RSSU5HKCdDJywgInJldXNlLW1lc3NhZ2UiLCAmdXNlX21lc3NhZ2UsICJDT01NSVQiLCAicmV1c2UgbWVzc2FnZSBmcm9tIHNwZWNpZmllZCBjb21taXQiKSwKCU9QVF9TVFJJTkcoMCwgImZpeHVwIiwgJmZpeHVwX21lc3NhZ2UsICJDT01NSVQiLCAidXNlIGF1dG9zcXVhc2ggZm9ybWF0dGVkIG1lc3NhZ2UgdG8gZml4dXAgc3BlY2lmaWVkIGNvbW1pdCIpLAoJT1BUX1NUUklORygwLCAic3F1YXNoIiwgJnNxdWFzaF9tZXNzYWdlLCAiQ09NTUlUIiwgInVzZSBhdXRvc3F1YXNoIGZvcm1hdHRlZCBtZXNzYWdlIHRvIHNxdWFzaCBzcGVjaWZpZWQgY29tbWl0IiksCglPUFRfQk9PTEVBTigwLCAicmVzZXQtYXV0aG9yIiwgJnJlbmV3X2F1dGhvcnNoaXAsICJ0aGUgY29tbWl0IGlzIGF1dGhvcmVkIGJ5IG1lIG5vdyAodXNlZCB3aXRoIC1DLWMvLS1hbWVuZCkiKSwKCU9QVF9CT09MRUFOKCdzJywgInNpZ25vZmYiLCAmc2lnbm9mZiwgImFkZCBTaWduZWQtb2ZmLWJ5OiIpLAoJT1BUX0ZJTEVOQU1FKCd0JywgInRlbXBsYXRlIiwgJnRlbXBsYXRlX2ZpbGUsICJ1c2Ugc3BlY2lmaWVkIHRlbXBsYXRlIGZpbGUiKSwKCU9QVF9CT09MRUFOKCdlJywgImVkaXQiLCAmZWRpdF9mbGFnLCAiZm9yY2UgZWRpdCBvZiBjb21taXQiKSwKCU9QVF9TVFJJTkcoMCwgImNsZWFudXAiLCAmY2xlYW51cF9hcmcsICJkZWZhdWx0IiwgImhvdyB0byBzdHJpcCBzcGFjZXMgYW5kICNjb21tZW50cyBmcm9tIG1lc3NhZ2UiKSwKCU9QVF9CT09MRUFOKDAsICJzdGF0dXMiLCAmaW5jbHVkZV9zdGF0dXMsICJpbmNsdWRlIHN0YXR1cyBpbiBjb21taXQgbWVzc2FnZSB0ZW1wbGF0ZSIpLAoJLyogZW5kIGNvbW1pdCBtZXNzYWdlIG9wdGlvbnMgKi8KCglPUFRfR1JPVVAoIkNvbW1pdCBjb250ZW50cyBvcHRpb25zIiksCglPUFRfQk9PTEVBTignYScsICJhbGwiLCAmYWxsLCAiY29tbWl0IGFsbCBjaGFuZ2VkIGZpbGVzIiksCglPUFRfQk9PTEVBTignaScsICJpbmNsdWRlIiwgJmFsc28sICJhZGQgc3BlY2lmaWVkIGZpbGVzIHRvIGluZGV4IGZvciBjb21taXQiKSwKCU9QVF9CT09MRUFOKDAsICJpbnRlcmFjdGl2ZSIsICZpbnRlcmFjdGl2ZSwgImludGVyYWN0aXZlbHkgYWRkIGZpbGVzIiksCglPUFRfQk9PTEVBTignbycsICJvbmx5IiwgJm9ubHksICJjb21taXQgb25seSBzcGVjaWZpZWQgZmlsZXMiKSwKCU9QVF9CT09MRUFOKCduJywgIm5vLXZlcmlmeSIsICZub192ZXJpZnksICJieXBhc3MgcHJlLWNvbW1pdCBob29rIiksCglPUFRfQk9PTEVBTigwLCAiZHJ5LXJ1biIsICZkcnlfcnVuLCAic2hvdyB3aGF0IHdvdWxkIGJlIGNvbW1pdHRlZCIpLAoJT1BUX1NFVF9JTlQoMCwgInNob3J0IiwgJnN0YXR1c19mb3JtYXQsICJzaG93IHN0YXR1cyBjb25jaXNlbHkiLAoJCSAgICBTVEFUVVNfRk9STUFUX1NIT1JUKSwKCU9QVF9CT09MRUFOKDAsICJicmFuY2giLCAmc3RhdHVzX3Nob3dfYnJhbmNoLCAic2hvdyBicmFuY2ggaW5mb3JtYXRpb24iKSwKCU9QVF9TRVRfSU5UKDAsICJwb3JjZWxhaW4iLCAmc3RhdHVzX2Zvcm1hdCwKCQkgICAgIm1hY2hpbmUtcmVhZGFibGUgb3V0cHV0IiwgU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU4pLAoJT1BUX0JPT0xFQU4oJ3onLCAibnVsbCIsICZudWxsX3Rlcm1pbmF0aW9uLAoJCSAgICAidGVybWluYXRlIGVudHJpZXMgd2l0aCBOVUwiKSwKCU9QVF9CT09MRUFOKDAsICJhbWVuZCIsICZhbWVuZCwgImFtZW5kIHByZXZpb3VzIGNvbW1pdCIpLAoJT1BUX0JPT0xFQU4oMCwgIm5vLXBvc3QtcmV3cml0ZSIsICZub19wb3N0X3Jld3JpdGUsICJieXBhc3MgcG9zdC1yZXdyaXRlIGhvb2siKSwKCXsgT1BUSU9OX1NUUklORywgJ3UnLCAidW50cmFja2VkLWZpbGVzIiwgJnVudHJhY2tlZF9maWxlc19hcmcsICJtb2RlIiwgInNob3cgdW50cmFja2VkIGZpbGVzLCBvcHRpb25hbCBtb2RlczogYWxsLCBub3JtYWwsIG5vIChEZWZhdWx0OiBhbGwpIiwgUEFSU0VfT1BUX09QVEFSRywgTlVMTCwgKGludHB0cl90KSJhbGwiIH0sCgkvKiBlbmQgY29tbWl0IGNvbnRlbnRzIG9wdGlvbnMgKi8KCgl7IE9QVElPTl9CT09MRUFOLCAwLCAiYWxsb3ctZW1wdHkiLCAmYWxsb3dfZW1wdHksIE5VTEwsCgkgICJvayB0byByZWNvcmQgYW4gZW1wdHkgY2hhbmdlIiwKCSAgUEFSU0VfT1BUX05PQVJHIHwgUEFSU0VfT1BUX0hJRERFTiB9LAoJeyBPUFRJT05fQk9PTEVBTiwgMCwgImFsbG93LWVtcHR5LW1lc3NhZ2UiLCAmYWxsb3dfZW1wdHlfbWVzc2FnZSwgTlVMTCwKCSAgIm9rIHRvIHJlY29yZCBhIGNoYW5nZSB3aXRoIGFuIGVtcHR5IG1lc3NhZ2UiLAoJICBQQVJTRV9PUFRfTk9BUkcgfCBQQVJTRV9PUFRfSElEREVOIH0sCgoJT1BUX0VORCgpCn07CgpzdGF0aWMgdm9pZCByb2xsYmFja19pbmRleF9maWxlcyh2b2lkKQp7Cglzd2l0Y2ggKGNvbW1pdF9zdHlsZSkgewoJY2FzZSBDT01NSVRfQVNfSVM6CgkJYnJlYWs7IC8qIG5vdGhpbmcgdG8gZG8gKi8KCWNhc2UgQ09NTUlUX05PUk1BTDoKCQlyb2xsYmFja19sb2NrX2ZpbGUoJmluZGV4X2xvY2spOwoJCWJyZWFrOwoJY2FzZSBDT01NSVRfUEFSVElBTDoKCQlyb2xsYmFja19sb2NrX2ZpbGUoJmluZGV4X2xvY2spOwoJCXJvbGxiYWNrX2xvY2tfZmlsZSgmZmFsc2VfbG9jayk7CgkJYnJlYWs7Cgl9Cn0KCnN0YXRpYyBpbnQgY29tbWl0X2luZGV4X2ZpbGVzKHZvaWQpCnsKCWludCBlcnIgPSAwOwoKCXN3aXRjaCAoY29tbWl0X3N0eWxlKSB7CgljYXNlIENPTU1JVF9BU19JUzoKCQlicmVhazsgLyogbm90aGluZyB0byBkbyAqLwoJY2FzZSBDT01NSVRfTk9STUFMOgoJCWVyciA9IGNvbW1pdF9sb2NrX2ZpbGUoJmluZGV4X2xvY2spOwoJCWJyZWFrOwoJY2FzZSBDT01NSVRfUEFSVElBTDoKCQllcnIgPSBjb21taXRfbG9ja19maWxlKCZpbmRleF9sb2NrKTsKCQlyb2xsYmFja19sb2NrX2ZpbGUoJmZhbHNlX2xvY2spOwoJCWJyZWFrOwoJfQoKCXJldHVybiBlcnI7Cn0KCi8qCiAqIFRha2UgYSB1bmlvbiBvZiBwYXRocyBpbiB0aGUgaW5kZXggYW5kIHRoZSBuYW1lZCB0cmVlICh0eXBpY2FsbHksICJIRUFEIiksCiAqIGFuZCByZXR1cm4gdGhlIHBhdGhzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHBhdHRlcm4gaW4gbGlzdC4KICovCnN0YXRpYyBpbnQgbGlzdF9wYXRocyhzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QsIGNvbnN0IGNoYXIgKndpdGhfdHJlZSwKCQkgICAgICBjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IGNoYXIgKipwYXR0ZXJuKQp7CglpbnQgaTsKCWNoYXIgKm07CgoJZm9yIChpID0gMDsgcGF0dGVybltpXTsgaSsrKQoJCTsKCW0gPSB4Y2FsbG9jKDEsIGkpOwoKCWlmICh3aXRoX3RyZWUpCgkJb3ZlcmxheV90cmVlX29uX2NhY2hlKHdpdGhfdHJlZSwgcHJlZml4KTsKCglmb3IgKGkgPSAwOyBpIDwgYWN0aXZlX25yOyBpKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gYWN0aXZlX2NhY2hlW2ldOwoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoKCQlpZiAoY2UtPmNlX2ZsYWdzICYgQ0VfVVBEQVRFKQoJCQljb250aW51ZTsKCQlpZiAoIW1hdGNoX3BhdGhzcGVjKHBhdHRlcm4sIGNlLT5uYW1lLCBjZV9uYW1lbGVuKGNlKSwgMCwgbSkpCgkJCWNvbnRpbnVlOwoJCWl0ZW0gPSBzdHJpbmdfbGlzdF9pbnNlcnQobGlzdCwgY2UtPm5hbWUpOwoJCWlmIChjZV9za2lwX3dvcmt0cmVlKGNlKSkKCQkJaXRlbS0+dXRpbCA9IGl0ZW07IC8qIGJldHRlciBhIHZhbGlkIHBvaW50ZXIgdGhhbiBhIGZha2Ugb25lICovCgl9CgoJcmV0dXJuIHJlcG9ydF9wYXRoX2Vycm9yKG0sIHBhdHRlcm4sIHByZWZpeCA/IHN0cmxlbihwcmVmaXgpIDogMCk7Cn0KCnN0YXRpYyB2b2lkIGFkZF9yZW1vdmVfZmlsZXMoc3RydWN0IHN0cmluZ19saXN0ICpsaXN0KQp7CglpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCBsaXN0LT5ucjsgaSsrKSB7CgkJc3RydWN0IHN0YXQgc3Q7CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKnAgPSAmKGxpc3QtPml0ZW1zW2ldKTsKCgkJLyogcC0+dXRpbCBpcyBza2lwLXdvcmt0cmVlICovCgkJaWYgKHAtPnV0aWwpCgkJCWNvbnRpbnVlOwoKCQlpZiAoIWxzdGF0KHAtPnN0cmluZywgJnN0KSkgewoJCQlpZiAoYWRkX3RvX2NhY2hlKHAtPnN0cmluZywgJnN0LCAwKSkKCQkJCWRpZSgidXBkYXRpbmcgZmlsZXMgZmFpbGVkIik7CgkJfSBlbHNlCgkJCXJlbW92ZV9maWxlX2Zyb21fY2FjaGUocC0+c3RyaW5nKTsKCX0KfQoKc3RhdGljIHZvaWQgY3JlYXRlX2Jhc2VfaW5kZXgodm9pZCkKewoJc3RydWN0IHRyZWUgKnRyZWU7CglzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgb3B0czsKCXN0cnVjdCB0cmVlX2Rlc2MgdDsKCglpZiAoaW5pdGlhbF9jb21taXQpIHsKCQlkaXNjYXJkX2NhY2hlKCk7CgkJcmV0dXJuOwoJfQoKCW1lbXNldCgmb3B0cywgMCwgc2l6ZW9mKG9wdHMpKTsKCW9wdHMuaGVhZF9pZHggPSAxOwoJb3B0cy5pbmRleF9vbmx5ID0gMTsKCW9wdHMubWVyZ2UgPSAxOwoJb3B0cy5zcmNfaW5kZXggPSAmdGhlX2luZGV4OwoJb3B0cy5kc3RfaW5kZXggPSAmdGhlX2luZGV4OwoKCW9wdHMuZm4gPSBvbmV3YXlfbWVyZ2U7Cgl0cmVlID0gcGFyc2VfdHJlZV9pbmRpcmVjdChoZWFkX3NoYTEpOwoJaWYgKCF0cmVlKQoJCWRpZSgiZmFpbGVkIHRvIHVucGFjayBIRUFEIHRyZWUgb2JqZWN0Iik7CglwYXJzZV90cmVlKHRyZWUpOwoJaW5pdF90cmVlX2Rlc2MoJnQsIHRyZWUtPmJ1ZmZlciwgdHJlZS0+c2l6ZSk7CglpZiAodW5wYWNrX3RyZWVzKDEsICZ0LCAmb3B0cykpCgkJZXhpdCgxMjgpOyAvKiBXZSd2ZSBhbHJlYWR5IHJlcG9ydGVkIHRoZSBlcnJvciwgZmluaXNoIGR5aW5nICovCn0KCnN0YXRpYyB2b2lkIHJlZnJlc2hfY2FjaGVfb3JfZGllKGludCByZWZyZXNoX2ZsYWdzKQp7CgkvKgoJICogcmVmcmVzaF9mbGFncyBjb250YWlucyBSRUZSRVNIX1FVSUVULCBzbyB0aGUgb25seSBlcnJvcnMKCSAqIGFyZSBmb3IgdW5tZXJnZWQgZW50cmllcy4KCSAqLwoJaWYgKHJlZnJlc2hfY2FjaGUocmVmcmVzaF9mbGFncyB8IFJFRlJFU0hfSU5fUE9SQ0VMQUlOKSkKCQlkaWVfcmVzb2x2ZV9jb25mbGljdCgiY29tbWl0Iik7Cn0KCnN0YXRpYyBjaGFyICpwcmVwYXJlX2luZGV4KGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4LCBpbnQgaXNfc3RhdHVzKQp7CglpbnQgZmQ7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgcGFydGlhbDsKCWNvbnN0IGNoYXIgKipwYXRoc3BlYyA9IE5VTEw7CglpbnQgcmVmcmVzaF9mbGFncyA9IFJFRlJFU0hfUVVJRVQ7CgoJaWYgKGlzX3N0YXR1cykKCQlyZWZyZXNoX2ZsYWdzIHw9IFJFRlJFU0hfVU5NRVJHRUQ7CglpZiAoaW50ZXJhY3RpdmUpIHsKCQlpZiAoaW50ZXJhY3RpdmVfYWRkKGFyZ2MsIGFyZ3YsIHByZWZpeCkgIT0gMCkKCQkJZGllKCJpbnRlcmFjdGl2ZSBhZGQgZmFpbGVkIik7CgkJaWYgKHJlYWRfY2FjaGVfcHJlbG9hZChOVUxMKSA8IDApCgkJCWRpZSgiaW5kZXggZmlsZSBjb3JydXB0Iik7CgkJY29tbWl0X3N0eWxlID0gQ09NTUlUX0FTX0lTOwoJCXJldHVybiBnZXRfaW5kZXhfZmlsZSgpOwoJfQoKCWlmICgqYXJndikKCQlwYXRoc3BlYyA9IGdldF9wYXRoc3BlYyhwcmVmaXgsIGFyZ3YpOwoKCWlmIChyZWFkX2NhY2hlX3ByZWxvYWQocGF0aHNwZWMpIDwgMCkKCQlkaWUoImluZGV4IGZpbGUgY29ycnVwdCIpOwoKCS8qCgkgKiBOb24gcGFydGlhbCwgbm9uIGFzLWlzIGNvbW1pdC4KCSAqCgkgKiAoMSkgZ2V0IHRoZSByZWFsIGluZGV4OwoJICogKDIpIHVwZGF0ZSB0aGVfaW5kZXggYXMgbmVjZXNzYXJ5OwoJICogKDMpIHdyaXRlIHRoZV9pbmRleCBvdXQgdG8gdGhlIHJlYWwgaW5kZXggKHN0aWxsIGxvY2tlZCk7CgkgKiAoNCkgcmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBsb2NrZWQgaW5kZXggZmlsZS4KCSAqCgkgKiBUaGUgY2FsbGVyIHNob3VsZCBydW4gaG9va3Mgb24gdGhlIGxvY2tlZCByZWFsIGluZGV4LCBhbmQKCSAqIChBKSBpZiBhbGwgZ29lcyB3ZWxsLCBjb21taXQgdGhlIHJlYWwgaW5kZXg7CgkgKiAoQikgb24gZmFpbHVyZSwgcm9sbGJhY2sgdGhlIHJlYWwgaW5kZXguCgkgKi8KCWlmIChhbGwgfHwgKGFsc28gJiYgcGF0aHNwZWMgJiYgKnBhdGhzcGVjKSkgewoJCWZkID0gaG9sZF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2ssIDEpOwoJCWFkZF9maWxlc190b19jYWNoZShhbHNvID8gcHJlZml4IDogTlVMTCwgcGF0aHNwZWMsIDApOwoJCXJlZnJlc2hfY2FjaGVfb3JfZGllKHJlZnJlc2hfZmxhZ3MpOwoJCWlmICh3cml0ZV9jYWNoZShmZCwgYWN0aXZlX2NhY2hlLCBhY3RpdmVfbnIpIHx8CgkJICAgIGNsb3NlX2xvY2tfZmlsZSgmaW5kZXhfbG9jaykpCgkJCWRpZSgidW5hYmxlIHRvIHdyaXRlIG5ld19pbmRleCBmaWxlIik7CgkJY29tbWl0X3N0eWxlID0gQ09NTUlUX05PUk1BTDsKCQlyZXR1cm4gaW5kZXhfbG9jay5maWxlbmFtZTsKCX0KCgkvKgoJICogQXMtaXMgY29tbWl0LgoJICoKCSAqICgxKSByZXR1cm4gdGhlIG5hbWUgb2YgdGhlIHJlYWwgaW5kZXggZmlsZS4KCSAqCgkgKiBUaGUgY2FsbGVyIHNob3VsZCBydW4gaG9va3Mgb24gdGhlIHJlYWwgaW5kZXgsCgkgKiBhbmQgY3JlYXRlIGNvbW1pdCBmcm9tIHRoZV9pbmRleC4KCSAqIFdlIHN0aWxsIG5lZWQgdG8gcmVmcmVzaCB0aGUgaW5kZXggaGVyZS4KCSAqLwoJaWYgKCFwYXRoc3BlYyB8fCAhKnBhdGhzcGVjKSB7CgkJZmQgPSBob2xkX2xvY2tlZF9pbmRleCgmaW5kZXhfbG9jaywgMSk7CgkJcmVmcmVzaF9jYWNoZV9vcl9kaWUocmVmcmVzaF9mbGFncyk7CgkJaWYgKGFjdGl2ZV9jYWNoZV9jaGFuZ2VkKSB7CgkJCWlmICh3cml0ZV9jYWNoZShmZCwgYWN0aXZlX2NhY2hlLCBhY3RpdmVfbnIpIHx8CgkJCSAgICBjb21taXRfbG9ja2VkX2luZGV4KCZpbmRleF9sb2NrKSkKCQkJCWRpZSgidW5hYmxlIHRvIHdyaXRlIG5ld19pbmRleCBmaWxlIik7CgkJfSBlbHNlIHsKCQkJcm9sbGJhY2tfbG9ja19maWxlKCZpbmRleF9sb2NrKTsKCQl9CgkJY29tbWl0X3N0eWxlID0gQ09NTUlUX0FTX0lTOwoJCXJldHVybiBnZXRfaW5kZXhfZmlsZSgpOwoJfQoKCS8qCgkgKiBBIHBhcnRpYWwgY29tbWl0LgoJICoKCSAqICgwKSBmaW5kIHRoZSBzZXQgb2YgYWZmZWN0ZWQgcGF0aHM7CgkgKiAoMSkgZ2V0IGxvY2sgb24gdGhlIHJlYWwgaW5kZXggZmlsZTsKCSAqICgyKSB1cGRhdGUgdGhlX2luZGV4IHdpdGggdGhlIGdpdmVuIHBhdGhzOwoJICogKDMpIHdyaXRlIHRoZV9pbmRleCBvdXQgdG8gdGhlIHJlYWwgaW5kZXggKHN0aWxsIGxvY2tlZCk7CgkgKiAoNCkgZ2V0IGxvY2sgb24gdGhlIGZhbHNlIGluZGV4IGZpbGU7CgkgKiAoNSkgcmVzZXQgdGhlX2luZGV4IGZyb20gSEVBRDsKCSAqICg2KSB1cGRhdGUgdGhlX2luZGV4IHRoZSBzYW1lIHdheSBhcyAoMik7CgkgKiAoNykgd3JpdGUgdGhlX2luZGV4IG91dCB0byB0aGUgZmFsc2UgaW5kZXggZmlsZTsKCSAqICg4KSByZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGZhbHNlIGluZGV4IGZpbGUgKHN0aWxsIGxvY2tlZCk7CgkgKgoJICogVGhlIGNhbGxlciBzaG91bGQgcnVuIGhvb2tzIG9uIHRoZSBsb2NrZWQgZmFsc2UgaW5kZXgsIGFuZAoJICogY3JlYXRlIGNvbW1pdCBmcm9tIGl0LiAgVGhlbgoJICogKEEpIGlmIGFsbCBnb2VzIHdlbGwsIGNvbW1pdCB0aGUgcmVhbCBpbmRleDsKCSAqIChCKSBvbiBmYWlsdXJlLCByb2xsYmFjayB0aGUgcmVhbCBpbmRleDsKCSAqIEluIGVpdGhlciBjYXNlLCByb2xsYmFjayB0aGUgZmFsc2UgaW5kZXguCgkgKi8KCWNvbW1pdF9zdHlsZSA9IENPTU1JVF9QQVJUSUFMOwoKCWlmIChpbl9tZXJnZSkKCQlkaWUoImNhbm5vdCBkbyBhIHBhcnRpYWwgY29tbWl0IGR1cmluZyBhIG1lcmdlLiIpOwoKCW1lbXNldCgmcGFydGlhbCwgMCwgc2l6ZW9mKHBhcnRpYWwpKTsKCXBhcnRpYWwuc3RyZHVwX3N0cmluZ3MgPSAxOwoJaWYgKGxpc3RfcGF0aHMoJnBhcnRpYWwsIGluaXRpYWxfY29tbWl0ID8gTlVMTCA6ICJIRUFEIiwgcHJlZml4LCBwYXRoc3BlYykpCgkJZXhpdCgxKTsKCglkaXNjYXJkX2NhY2hlKCk7CglpZiAocmVhZF9jYWNoZSgpIDwgMCkKCQlkaWUoImNhbm5vdCByZWFkIHRoZSBpbmRleCIpOwoKCWZkID0gaG9sZF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2ssIDEpOwoJYWRkX3JlbW92ZV9maWxlcygmcGFydGlhbCk7CglyZWZyZXNoX2NhY2hlKFJFRlJFU0hfUVVJRVQpOwoJaWYgKHdyaXRlX2NhY2hlKGZkLCBhY3RpdmVfY2FjaGUsIGFjdGl2ZV9ucikgfHwKCSAgICBjbG9zZV9sb2NrX2ZpbGUoJmluZGV4X2xvY2spKQoJCWRpZSgidW5hYmxlIHRvIHdyaXRlIG5ld19pbmRleCBmaWxlIik7CgoJZmQgPSBob2xkX2xvY2tfZmlsZV9mb3JfdXBkYXRlKCZmYWxzZV9sb2NrLAoJCQkJICAgICAgIGdpdF9wYXRoKCJuZXh0LWluZGV4LSUiUFJJdU1BWCwKCQkJCQkJKHVpbnRtYXhfdCkgZ2V0cGlkKCkpLAoJCQkJICAgICAgIExPQ0tfRElFX09OX0VSUk9SKTsKCgljcmVhdGVfYmFzZV9pbmRleCgpOwoJYWRkX3JlbW92ZV9maWxlcygmcGFydGlhbCk7CglyZWZyZXNoX2NhY2hlKFJFRlJFU0hfUVVJRVQpOwoKCWlmICh3cml0ZV9jYWNoZShmZCwgYWN0aXZlX2NhY2hlLCBhY3RpdmVfbnIpIHx8CgkgICAgY2xvc2VfbG9ja19maWxlKCZmYWxzZV9sb2NrKSkKCQlkaWUoInVuYWJsZSB0byB3cml0ZSB0ZW1wb3JhcnkgaW5kZXggZmlsZSIpOwoKCWRpc2NhcmRfY2FjaGUoKTsKCXJlYWRfY2FjaGVfZnJvbShmYWxzZV9sb2NrLmZpbGVuYW1lKTsKCglyZXR1cm4gZmFsc2VfbG9jay5maWxlbmFtZTsKfQoKc3RhdGljIGludCBydW5fc3RhdHVzKEZJTEUgKmZwLCBjb25zdCBjaGFyICppbmRleF9maWxlLCBjb25zdCBjaGFyICpwcmVmaXgsIGludCBub3dhcm4sCgkJICAgICAgc3RydWN0IHd0X3N0YXR1cyAqcykKewoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCglpZiAocy0+cmVsYXRpdmVfcGF0aHMpCgkJcy0+cHJlZml4ID0gcHJlZml4OwoKCWlmIChhbWVuZCkgewoJCXMtPmFtZW5kID0gMTsKCQlzLT5yZWZlcmVuY2UgPSAiSEVBRF4xIjsKCX0KCXMtPnZlcmJvc2UgPSB2ZXJib3NlOwoJcy0+aW5kZXhfZmlsZSA9IGluZGV4X2ZpbGU7CglzLT5mcCA9IGZwOwoJcy0+bm93YXJuID0gbm93YXJuOwoJcy0+aXNfaW5pdGlhbCA9IGdldF9zaGExKHMtPnJlZmVyZW5jZSwgc2hhMSkgPyAxIDogMDsKCgl3dF9zdGF0dXNfY29sbGVjdChzKTsKCglzd2l0Y2ggKHN0YXR1c19mb3JtYXQpIHsKCWNhc2UgU1RBVFVTX0ZPUk1BVF9TSE9SVDoKCQl3dF9zaG9ydHN0YXR1c19wcmludChzLCBudWxsX3Rlcm1pbmF0aW9uLCBzdGF0dXNfc2hvd19icmFuY2gpOwoJCWJyZWFrOwoJY2FzZSBTVEFUVVNfRk9STUFUX1BPUkNFTEFJTjoKCQl3dF9wb3JjZWxhaW5fcHJpbnQocywgbnVsbF90ZXJtaW5hdGlvbik7CgkJYnJlYWs7CgljYXNlIFNUQVRVU19GT1JNQVRfTE9ORzoKCQl3dF9zdGF0dXNfcHJpbnQocyk7CgkJYnJlYWs7Cgl9CgoJcmV0dXJuIHMtPmNvbW1pdGFibGU7Cn0KCnN0YXRpYyBpbnQgaXNfYV9tZXJnZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBsb29rdXBfY29tbWl0KHNoYTEpOwoJaWYgKCFjb21taXQgfHwgcGFyc2VfY29tbWl0KGNvbW1pdCkpCgkJZGllKCJjb3VsZCBub3QgcGFyc2UgSEVBRCBjb21taXQiKTsKCXJldHVybiAhIShjb21taXQtPnBhcmVudHMgJiYgY29tbWl0LT5wYXJlbnRzLT5uZXh0KTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgc2lnbl9vZmZfaGVhZGVyW10gPSAiU2lnbmVkLW9mZi1ieTogIjsKCnN0YXRpYyB2b2lkIGRldGVybWluZV9hdXRob3JfaW5mbyhzdHJ1Y3Qgc3RyYnVmICphdXRob3JfaWRlbnQpCnsKCWNoYXIgKm5hbWUsICplbWFpbCwgKmRhdGU7CgoJbmFtZSA9IGdldGVudigiR0lUX0FVVEhPUl9OQU1FIik7CgllbWFpbCA9IGdldGVudigiR0lUX0FVVEhPUl9FTUFJTCIpOwoJZGF0ZSA9IGdldGVudigiR0lUX0FVVEhPUl9EQVRFIik7CgoJaWYgKHVzZV9tZXNzYWdlICYmICFyZW5ld19hdXRob3JzaGlwKSB7CgkJY29uc3QgY2hhciAqYSwgKmxiLCAqcmIsICplb2w7CgoJCWEgPSBzdHJzdHIodXNlX21lc3NhZ2VfYnVmZmVyLCAiXG5hdXRob3IgIik7CgkJaWYgKCFhKQoJCQlkaWUoImludmFsaWQgY29tbWl0OiAlcyIsIHVzZV9tZXNzYWdlKTsKCgkJbGIgPSBzdHJjaHJudWwoYSArIHN0cmxlbigiXG5hdXRob3IgIiksICc8Jyk7CgkJcmIgPSBzdHJjaHJudWwobGIsICc+Jyk7CgkJZW9sID0gc3RyY2hybnVsKHJiLCAnXG4nKTsKCQlpZiAoISpsYiB8fCAhKnJiIHx8ICEqZW9sKQoJCQlkaWUoImludmFsaWQgY29tbWl0OiAlcyIsIHVzZV9tZXNzYWdlKTsKCgkJaWYgKGxiID09IGEgKyBzdHJsZW4oIlxuYXV0aG9yICIpKQoJCQkvKiBcbmF1dGhvciA8Zm9vQGV4YW1wbGUuY29tPiAqLwoJCQluYW1lID0geGNhbGxvYygxLCAxKTsKCQllbHNlCgkJCW5hbWUgPSB4bWVtZHVweihhICsgc3RybGVuKCJcbmF1dGhvciAiKSwKCQkJCQkobGIgLSBzdHJsZW4oIiAiKSAtCgkJCQkJIChhICsgc3RybGVuKCJcbmF1dGhvciAiKSkpKTsKCQllbWFpbCA9IHhtZW1kdXB6KGxiICsgc3RybGVuKCI8IiksIHJiIC0gKGxiICsgc3RybGVuKCI8IikpKTsKCQlkYXRlID0geG1lbWR1cHoocmIgKyBzdHJsZW4oIj4gIiksIGVvbCAtIChyYiArIHN0cmxlbigiPiAiKSkpOwoJfQoKCWlmIChmb3JjZV9hdXRob3IpIHsKCQljb25zdCBjaGFyICpsYiA9IHN0cnN0cihmb3JjZV9hdXRob3IsICIgPCIpOwoJCWNvbnN0IGNoYXIgKnJiID0gc3RyY2hyKGZvcmNlX2F1dGhvciwgJz4nKTsKCgkJaWYgKCFsYiB8fCAhcmIpCgkJCWRpZSgibWFsZm9ybWVkIC0tYXV0aG9yIHBhcmFtZXRlciIpOwoJCW5hbWUgPSB4c3RybmR1cChmb3JjZV9hdXRob3IsIGxiIC0gZm9yY2VfYXV0aG9yKTsKCQllbWFpbCA9IHhzdHJuZHVwKGxiICsgMiwgcmIgLSAobGIgKyAyKSk7Cgl9CgoJaWYgKGZvcmNlX2RhdGUpCgkJZGF0ZSA9IGZvcmNlX2RhdGU7CglzdHJidWZfYWRkc3RyKGF1dGhvcl9pZGVudCwgZm10X2lkZW50KG5hbWUsIGVtYWlsLCBkYXRlLAoJCQkJCSAgICAgIElERU5UX0VSUk9SX09OX05PX05BTUUpKTsKfQoKc3RhdGljIGludCBlbmRzX3JmYzI4MjJfZm9vdGVyKHN0cnVjdCBzdHJidWYgKnNiKQp7CglpbnQgY2g7CglpbnQgaGl0ID0gMDsKCWludCBpLCBqLCBrOwoJaW50IGxlbiA9IHNiLT5sZW47CglpbnQgZmlyc3QgPSAxOwoJY29uc3QgY2hhciAqYnVmID0gc2ItPmJ1ZjsKCglmb3IgKGkgPSBsZW4gLSAxOyBpID4gMDsgaS0tKSB7CgkJaWYgKGhpdCAmJiBidWZbaV0gPT0gJ1xuJykKCQkJYnJlYWs7CgkJaGl0ID0gKGJ1ZltpXSA9PSAnXG4nKTsKCX0KCgl3aGlsZSAoaSA8IGxlbiAtIDEgJiYgYnVmW2ldID09ICdcbicpCgkJaSsrOwoKCWZvciAoOyBpIDwgbGVuOyBpID0gaykgewoJCWZvciAoayA9IGk7IGsgPCBsZW4gJiYgYnVmW2tdICE9ICdcbic7IGsrKykKCQkJOyAvKiBkbyBub3RoaW5nICovCgkJaysrOwoKCQlpZiAoKGJ1ZltrXSA9PSAnICcgfHwgYnVmW2tdID09ICdcdCcpICYmICFmaXJzdCkKCQkJY29udGludWU7CgoJCWZpcnN0ID0gMDsKCgkJZm9yIChqID0gMDsgaSArIGogPCBsZW47IGorKykgewoJCQljaCA9IGJ1ZltpICsgal07CgkJCWlmIChjaCA9PSAnOicpCgkJCQlicmVhazsKCQkJaWYgKGlzYWxudW0oY2gpIHx8CgkJCSAgICAoY2ggPT0gJy0nKSkKCQkJCWNvbnRpbnVlOwoJCQlyZXR1cm4gMDsKCQl9Cgl9CglyZXR1cm4gMTsKfQoKc3RhdGljIGNoYXIgKmN1dF9pZGVudF90aW1lc3RhbXBfcGFydChjaGFyICpzdHJpbmcpCnsKCWNoYXIgKmtldCA9IHN0cnJjaHIoc3RyaW5nLCAnPicpOwoJaWYgKCFrZXQgfHwga2V0WzFdICE9ICcgJykKCQlkaWUoIk1hbGZvcm1lZCBpZGVudCBzdHJpbmc6ICclcyciLCBzdHJpbmcpOwoJKisra2V0ID0gJ1wwJzsKCXJldHVybiBrZXQ7Cn0KCnN0YXRpYyBpbnQgcHJlcGFyZV90b19jb21taXQoY29uc3QgY2hhciAqaW5kZXhfZmlsZSwgY29uc3QgY2hhciAqcHJlZml4LAoJCQkgICAgIHN0cnVjdCB3dF9zdGF0dXMgKnMsCgkJCSAgICAgc3RydWN0IHN0cmJ1ZiAqYXV0aG9yX2lkZW50KQp7CglzdHJ1Y3Qgc3RhdCBzdGF0YnVmOwoJc3RydWN0IHN0cmJ1ZiBjb21taXR0ZXJfaWRlbnQgPSBTVFJCVUZfSU5JVDsKCWludCBjb21taXRhYmxlLCBzYXZlZF9jb2xvcl9zZXR0aW5nOwoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJY2hhciAqYnVmZmVyOwoJRklMRSAqZnA7Cgljb25zdCBjaGFyICpob29rX2FyZzEgPSBOVUxMOwoJY29uc3QgY2hhciAqaG9va19hcmcyID0gTlVMTDsKCWludCBpZGVudF9zaG93biA9IDA7CgoJaWYgKCFub192ZXJpZnkgJiYgcnVuX2hvb2soaW5kZXhfZmlsZSwgInByZS1jb21taXQiLCBOVUxMKSkKCQlyZXR1cm4gMDsKCglpZiAoc3F1YXNoX21lc3NhZ2UpIHsKCQkvKgoJCSAqIEluc2VydCB0aGUgcHJvcGVyIHN1YmplY3QgbGluZSBiZWZvcmUgb3RoZXIgY29tbWl0CgkJICogbWVzc2FnZSBvcHRpb25zIGFkZCB0aGVpciBjb250ZW50LgoJCSAqLwoJCWlmICh1c2VfbWVzc2FnZSAmJiAhc3RyY21wKHVzZV9tZXNzYWdlLCBzcXVhc2hfbWVzc2FnZSkpCgkJCXN0cmJ1Zl9hZGRzdHIoJnNiLCAic3F1YXNoISAiKTsKCQllbHNlIHsKCQkJc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0IGN0eCA9IHswfTsKCQkJc3RydWN0IGNvbW1pdCAqYzsKCQkJYyA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2J5X25hbWUoc3F1YXNoX21lc3NhZ2UpOwoJCQlpZiAoIWMpCgkJCQlkaWUoImNvdWxkIG5vdCBsb29rdXAgY29tbWl0ICVzIiwgc3F1YXNoX21lc3NhZ2UpOwoJCQljdHgub3V0cHV0X2VuY29kaW5nID0gZ2V0X2NvbW1pdF9vdXRwdXRfZW5jb2RpbmcoKTsKCQkJZm9ybWF0X2NvbW1pdF9tZXNzYWdlKGMsICJzcXVhc2ghICVzXG5cbiIsICZzYiwKCQkJCQkgICAgICAmY3R4KTsKCQl9Cgl9CgoJaWYgKG1lc3NhZ2UubGVuKSB7CgkJc3RyYnVmX2FkZGJ1Zigmc2IsICZtZXNzYWdlKTsKCQlob29rX2FyZzEgPSAibWVzc2FnZSI7Cgl9IGVsc2UgaWYgKGxvZ2ZpbGUgJiYgIXN0cmNtcChsb2dmaWxlLCAiLSIpKSB7CgkJaWYgKGlzYXR0eSgwKSkKCQkJZnByaW50ZihzdGRlcnIsICIocmVhZGluZyBsb2cgbWVzc2FnZSBmcm9tIHN0YW5kYXJkIGlucHV0KVxuIik7CgkJaWYgKHN0cmJ1Zl9yZWFkKCZzYiwgMCwgMCkgPCAwKQoJCQlkaWVfZXJybm8oImNvdWxkIG5vdCByZWFkIGxvZyBmcm9tIHN0YW5kYXJkIGlucHV0Iik7CgkJaG9va19hcmcxID0gIm1lc3NhZ2UiOwoJfSBlbHNlIGlmIChsb2dmaWxlKSB7CgkJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJnNiLCBsb2dmaWxlLCAwKSA8IDApCgkJCWRpZV9lcnJubygiY291bGQgbm90IHJlYWQgbG9nIGZpbGUgJyVzJyIsCgkJCQkgIGxvZ2ZpbGUpOwoJCWhvb2tfYXJnMSA9ICJtZXNzYWdlIjsKCX0gZWxzZSBpZiAodXNlX21lc3NhZ2UpIHsKCQlidWZmZXIgPSBzdHJzdHIodXNlX21lc3NhZ2VfYnVmZmVyLCAiXG5cbiIpOwoJCWlmICghYnVmZmVyIHx8IGJ1ZmZlclsyXSA9PSAnXDAnKQoJCQlkaWUoImNvbW1pdCBoYXMgZW1wdHkgbWVzc2FnZSIpOwoJCXN0cmJ1Zl9hZGQoJnNiLCBidWZmZXIgKyAyLCBzdHJsZW4oYnVmZmVyICsgMikpOwoJCWhvb2tfYXJnMSA9ICJjb21taXQiOwoJCWhvb2tfYXJnMiA9IHVzZV9tZXNzYWdlOwoJfSBlbHNlIGlmIChmaXh1cF9tZXNzYWdlKSB7CgkJc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0IGN0eCA9IHswfTsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgkJY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfYnlfbmFtZShmaXh1cF9tZXNzYWdlKTsKCQlpZiAoIWNvbW1pdCkKCQkJZGllKCJjb3VsZCBub3QgbG9va3VwIGNvbW1pdCAlcyIsIGZpeHVwX21lc3NhZ2UpOwoJCWN0eC5vdXRwdXRfZW5jb2RpbmcgPSBnZXRfY29tbWl0X291dHB1dF9lbmNvZGluZygpOwoJCWZvcm1hdF9jb21taXRfbWVzc2FnZShjb21taXQsICJmaXh1cCEgJXNcblxuIiwKCQkJCSAgICAgICZzYiwgJmN0eCk7CgkJaG9va19hcmcxID0gIm1lc3NhZ2UiOwoJfSBlbHNlIGlmICghc3RhdChnaXRfcGF0aCgiTUVSR0VfTVNHIiksICZzdGF0YnVmKSkgewoJCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgZ2l0X3BhdGgoIk1FUkdFX01TRyIpLCAwKSA8IDApCgkJCWRpZV9lcnJubygiY291bGQgbm90IHJlYWQgTUVSR0VfTVNHIik7CgkJaG9va19hcmcxID0gIm1lcmdlIjsKCX0gZWxzZSBpZiAoIXN0YXQoZ2l0X3BhdGgoIlNRVUFTSF9NU0ciKSwgJnN0YXRidWYpKSB7CgkJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJnNiLCBnaXRfcGF0aCgiU1FVQVNIX01TRyIpLCAwKSA8IDApCgkJCWRpZV9lcnJubygiY291bGQgbm90IHJlYWQgU1FVQVNIX01TRyIpOwoJCWhvb2tfYXJnMSA9ICJzcXVhc2giOwoJfSBlbHNlIGlmICh0ZW1wbGF0ZV9maWxlICYmICFzdGF0KHRlbXBsYXRlX2ZpbGUsICZzdGF0YnVmKSkgewoJCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgdGVtcGxhdGVfZmlsZSwgMCkgPCAwKQoJCQlkaWVfZXJybm8oImNvdWxkIG5vdCByZWFkICclcyciLCB0ZW1wbGF0ZV9maWxlKTsKCQlob29rX2FyZzEgPSAidGVtcGxhdGUiOwoJfQoKCS8qCgkgKiBUaGlzIGZpbmFsIGNhc2UgZG9lcyBub3QgbW9kaWZ5IHRoZSB0ZW1wbGF0ZSBtZXNzYWdlLAoJICogaXQganVzdCBzZXRzIHRoZSBhcmd1bWVudCB0byB0aGUgcHJlcGFyZS1jb21taXQtbXNnIGhvb2suCgkgKi8KCWVsc2UgaWYgKGluX21lcmdlKQoJCWhvb2tfYXJnMSA9ICJtZXJnZSI7CgoJaWYgKHNxdWFzaF9tZXNzYWdlKSB7CgkJLyoKCQkgKiBJZiBzcXVhc2hfY29tbWl0IHdhcyB1c2VkIGZvciB0aGUgY29tbWl0IHN1YmplY3QsCgkJICogdGhlbiB3ZSdyZSBwb3NzaWJseSBoaWphY2tpbmcgb3RoZXIgY29tbWl0IGxvZyBvcHRpb25zLgoJCSAqIFJlc2V0IHRoZSBob29rIGFyZ3MgdG8gdGVsbCB0aGUgcmVhbCBzdG9yeS4KCQkgKi8KCQlob29rX2FyZzEgPSAibWVzc2FnZSI7CgkJaG9va19hcmcyID0gIiI7Cgl9CgoJZnAgPSBmb3BlbihnaXRfcGF0aChjb21taXRfZWRpdG1zZyksICJ3Iik7CglpZiAoZnAgPT0gTlVMTCkKCQlkaWVfZXJybm8oImNvdWxkIG5vdCBvcGVuICclcyciLCBnaXRfcGF0aChjb21taXRfZWRpdG1zZykpOwoKCWlmIChjbGVhbnVwX21vZGUgIT0gQ0xFQU5VUF9OT05FKQoJCXN0cmlwc3BhY2UoJnNiLCAwKTsKCglpZiAoc2lnbm9mZikgewoJCXN0cnVjdCBzdHJidWYgc29iID0gU1RSQlVGX0lOSVQ7CgkJaW50IGk7CgoJCXN0cmJ1Zl9hZGRzdHIoJnNvYiwgc2lnbl9vZmZfaGVhZGVyKTsKCQlzdHJidWZfYWRkc3RyKCZzb2IsIGZtdF9uYW1lKGdldGVudigiR0lUX0NPTU1JVFRFUl9OQU1FIiksCgkJCQkJICAgICBnZXRlbnYoIkdJVF9DT01NSVRURVJfRU1BSUwiKSkpOwoJCXN0cmJ1Zl9hZGRjaCgmc29iLCAnXG4nKTsKCQlmb3IgKGkgPSBzYi5sZW4gLSAxOyBpID4gMCAmJiBzYi5idWZbaSAtIDFdICE9ICdcbic7IGktLSkKCQkJOyAvKiBkbyBub3RoaW5nICovCgkJaWYgKHByZWZpeGNtcChzYi5idWYgKyBpLCBzb2IuYnVmKSkgewoJCQlpZiAoIWkgfHwgIWVuZHNfcmZjMjgyMl9mb290ZXIoJnNiKSkKCQkJCXN0cmJ1Zl9hZGRjaCgmc2IsICdcbicpOwoJCQlzdHJidWZfYWRkYnVmKCZzYiwgJnNvYik7CgkJfQoJCXN0cmJ1Zl9yZWxlYXNlKCZzb2IpOwoJfQoKCWlmIChmd3JpdGUoc2IuYnVmLCAxLCBzYi5sZW4sIGZwKSA8IHNiLmxlbikKCQlkaWVfZXJybm8oImNvdWxkIG5vdCB3cml0ZSBjb21taXQgdGVtcGxhdGUiKTsKCglzdHJidWZfcmVsZWFzZSgmc2IpOwoKCS8qIFRoaXMgY2hlY2tzIGFuZCBiYXJmcyBpZiBhdXRob3IgaXMgYmFkbHkgc3BlY2lmaWVkICovCglkZXRlcm1pbmVfYXV0aG9yX2luZm8oYXV0aG9yX2lkZW50KTsKCgkvKiBUaGlzIGNoZWNrcyBpZiBjb21taXR0ZXIgaWRlbnQgaXMgZXhwbGljaXRseSBnaXZlbiAqLwoJc3RyYnVmX2FkZHN0cigmY29tbWl0dGVyX2lkZW50LCBnaXRfY29tbWl0dGVyX2luZm8oMCkpOwoJaWYgKHVzZV9lZGl0b3IgJiYgaW5jbHVkZV9zdGF0dXMpIHsKCQljaGFyICphaV90bXAsICpjaV90bXA7CgkJaWYgKGluX21lcmdlKQoJCQlmcHJpbnRmKGZwLAoJCQkJIiNcbiIKCQkJCSIjIEl0IGxvb2tzIGxpa2UgeW91IG1heSBiZSBjb21taXR0aW5nIGEgTUVSR0UuXG4iCgkJCQkiIyBJZiB0aGlzIGlzIG5vdCBjb3JyZWN0LCBwbGVhc2UgcmVtb3ZlIHRoZSBmaWxlXG4iCgkJCQkiIwklc1xuIgoJCQkJIiMgYW5kIHRyeSBhZ2Fpbi5cbiIKCQkJCSIjXG4iLAoJCQkJZ2l0X3BhdGgoIk1FUkdFX0hFQUQiKSk7CgoJCWZwcmludGYoZnAsCgkJCSJcbiIKCQkJIiMgUGxlYXNlIGVudGVyIHRoZSBjb21taXQgbWVzc2FnZSBmb3IgeW91ciBjaGFuZ2VzLiIpOwoJCWlmIChjbGVhbnVwX21vZGUgPT0gQ0xFQU5VUF9BTEwpCgkJCWZwcmludGYoZnAsCgkJCQkiIExpbmVzIHN0YXJ0aW5nXG4iCgkJCQkiIyB3aXRoICcjJyB3aWxsIGJlIGlnbm9yZWQsIGFuZCBhbiBlbXB0eSIKCQkJCSIgbWVzc2FnZSBhYm9ydHMgdGhlIGNvbW1pdC5cbiIpOwoJCWVsc2UgLyogQ0xFQU5VUF9TUEFDRSwgdGhhdCBpcy4gKi8KCQkJZnByaW50ZihmcCwKCQkJCSIgTGluZXMgc3RhcnRpbmdcbiIKCQkJCSIjIHdpdGggJyMnIHdpbGwgYmUga2VwdDsgeW91IG1heSByZW1vdmUgdGhlbSIKCQkJCSIgeW91cnNlbGYgaWYgeW91IHdhbnQgdG8uXG4iCgkJCQkiIyBBbiBlbXB0eSBtZXNzYWdlIGFib3J0cyB0aGUgY29tbWl0LlxuIik7CgkJaWYgKG9ubHlfaW5jbHVkZV9hc3N1bWVkKQoJCQlmcHJpbnRmKGZwLCAiIyAlc1xuIiwgb25seV9pbmNsdWRlX2Fzc3VtZWQpOwoKCQlhaV90bXAgPSBjdXRfaWRlbnRfdGltZXN0YW1wX3BhcnQoYXV0aG9yX2lkZW50LT5idWYpOwoJCWNpX3RtcCA9IGN1dF9pZGVudF90aW1lc3RhbXBfcGFydChjb21taXR0ZXJfaWRlbnQuYnVmKTsKCQlpZiAoc3RyY21wKGF1dGhvcl9pZGVudC0+YnVmLCBjb21taXR0ZXJfaWRlbnQuYnVmKSkKCQkJZnByaW50ZihmcCwKCQkJCSIlcyIKCQkJCSIjIEF1dGhvcjogICAgJXNcbiIsCgkJCQlpZGVudF9zaG93bisrID8gIiIgOiAiI1xuIiwKCQkJCWF1dGhvcl9pZGVudC0+YnVmKTsKCgkJaWYgKCF1c2VyX2lkZW50X3N1ZmZpY2llbnRseV9naXZlbigpKQoJCQlmcHJpbnRmKGZwLAoJCQkJIiVzIgoJCQkJIiMgQ29tbWl0dGVyOiAlc1xuIiwKCQkJCWlkZW50X3Nob3duKysgPyAiIiA6ICIjXG4iLAoJCQkJY29tbWl0dGVyX2lkZW50LmJ1Zik7CgoJCWlmIChpZGVudF9zaG93bikKCQkJZnByaW50ZihmcCwgIiNcbiIpOwoKCQlzYXZlZF9jb2xvcl9zZXR0aW5nID0gcy0+dXNlX2NvbG9yOwoJCXMtPnVzZV9jb2xvciA9IDA7CgkJY29tbWl0YWJsZSA9IHJ1bl9zdGF0dXMoZnAsIGluZGV4X2ZpbGUsIHByZWZpeCwgMSwgcyk7CgkJcy0+dXNlX2NvbG9yID0gc2F2ZWRfY29sb3Jfc2V0dGluZzsKCgkJKmFpX3RtcCA9ICcgJzsKCQkqY2lfdG1wID0gJyAnOwoJfSBlbHNlIHsKCQl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJCWNvbnN0IGNoYXIgKnBhcmVudCA9ICJIRUFEIjsKCgkJaWYgKCFhY3RpdmVfbnIgJiYgcmVhZF9jYWNoZSgpIDwgMCkKCQkJZGllKCJDYW5ub3QgcmVhZCBpbmRleCIpOwoKCQlpZiAoYW1lbmQpCgkJCXBhcmVudCA9ICJIRUFEXjEiOwoKCQlpZiAoZ2V0X3NoYTEocGFyZW50LCBzaGExKSkKCQkJY29tbWl0YWJsZSA9ICEhYWN0aXZlX25yOwoJCWVsc2UKCQkJY29tbWl0YWJsZSA9IGluZGV4X2RpZmZlcnNfZnJvbShwYXJlbnQsIDApOwoJfQoJc3RyYnVmX3JlbGVhc2UoJmNvbW1pdHRlcl9pZGVudCk7CgoJZmNsb3NlKGZwKTsKCglpZiAoIWNvbW1pdGFibGUgJiYgIWluX21lcmdlICYmICFhbGxvd19lbXB0eSAmJgoJICAgICEoYW1lbmQgJiYgaXNfYV9tZXJnZShoZWFkX3NoYTEpKSkgewoJCXJ1bl9zdGF0dXMoc3Rkb3V0LCBpbmRleF9maWxlLCBwcmVmaXgsIDAsIHMpOwoJCWlmIChhbWVuZCkKCQkJZnB1dHMoZW1wdHlfYW1lbmRfYWR2aWNlLCBzdGRlcnIpOwoJCXJldHVybiAwOwoJfQoKCS8qCgkgKiBSZS1yZWFkIHRoZSBpbmRleCBhcyBwcmUtY29tbWl0IGhvb2sgY291bGQgaGF2ZSB1cGRhdGVkIGl0LAoJICogYW5kIHdyaXRlIGl0IG91dCBhcyBhIHRyZWUuICBXZSBtdXN0IGRvIHRoaXMgYmVmb3JlIHdlIGludm9rZQoJICogdGhlIGVkaXRvciBhbmQgYWZ0ZXIgd2UgaW52b2tlIHJ1bl9zdGF0dXMgYWJvdmUuCgkgKi8KCWRpc2NhcmRfY2FjaGUoKTsKCXJlYWRfY2FjaGVfZnJvbShpbmRleF9maWxlKTsKCWlmICghYWN0aXZlX2NhY2hlX3RyZWUpCgkJYWN0aXZlX2NhY2hlX3RyZWUgPSBjYWNoZV90cmVlKCk7CglpZiAoY2FjaGVfdHJlZV91cGRhdGUoYWN0aXZlX2NhY2hlX3RyZWUsCgkJCSAgICAgIGFjdGl2ZV9jYWNoZSwgYWN0aXZlX25yLCAwLCAwKSA8IDApIHsKCQllcnJvcigiRXJyb3IgYnVpbGRpbmcgdHJlZXMiKTsKCQlyZXR1cm4gMDsKCX0KCglpZiAocnVuX2hvb2soaW5kZXhfZmlsZSwgInByZXBhcmUtY29tbWl0LW1zZyIsCgkJICAgICBnaXRfcGF0aChjb21taXRfZWRpdG1zZyksIGhvb2tfYXJnMSwgaG9va19hcmcyLCBOVUxMKSkKCQlyZXR1cm4gMDsKCglpZiAodXNlX2VkaXRvcikgewoJCWNoYXIgaW5kZXhbUEFUSF9NQVhdOwoJCWNvbnN0IGNoYXIgKmVudlsyXSA9IHsgTlVMTCB9OwoJCWVudlswXSA9ICBpbmRleDsKCQlzbnByaW50ZihpbmRleCwgc2l6ZW9mKGluZGV4KSwgIkdJVF9JTkRFWF9GSUxFPSVzIiwgaW5kZXhfZmlsZSk7CgkJaWYgKGxhdW5jaF9lZGl0b3IoZ2l0X3BhdGgoY29tbWl0X2VkaXRtc2cpLCBOVUxMLCBlbnYpKSB7CgkJCWZwcmludGYoc3RkZXJyLAoJCQkiUGxlYXNlIHN1cHBseSB0aGUgbWVzc2FnZSB1c2luZyBlaXRoZXIgLW0gb3IgLUYgb3B0aW9uLlxuIik7CgkJCWV4aXQoMSk7CgkJfQoJfQoKCWlmICghbm9fdmVyaWZ5ICYmCgkgICAgcnVuX2hvb2soaW5kZXhfZmlsZSwgImNvbW1pdC1tc2ciLCBnaXRfcGF0aChjb21taXRfZWRpdG1zZyksIE5VTEwpKSB7CgkJcmV0dXJuIDA7Cgl9CgoJcmV0dXJuIDE7Cn0KCi8qCiAqIEZpbmQgb3V0IGlmIHRoZSBtZXNzYWdlIGluIHRoZSBzdHJidWYgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlIGFuZAogKiBTaWduZWQtb2ZmLWJ5IGxpbmVzLgogKi8Kc3RhdGljIGludCBtZXNzYWdlX2lzX2VtcHR5KHN0cnVjdCBzdHJidWYgKnNiKQp7CglzdHJ1Y3Qgc3RyYnVmIHRtcGwgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKm5sOwoJaW50IGVvbCwgaSwgc3RhcnQgPSAwOwoKCWlmIChjbGVhbnVwX21vZGUgPT0gQ0xFQU5VUF9OT05FICYmIHNiLT5sZW4pCgkJcmV0dXJuIDA7CgoJLyogU2VlIGlmIHRoZSB0ZW1wbGF0ZSBpcyBqdXN0IGEgcHJlZml4IG9mIHRoZSBtZXNzYWdlLiAqLwoJaWYgKHRlbXBsYXRlX2ZpbGUgJiYgc3RyYnVmX3JlYWRfZmlsZSgmdG1wbCwgdGVtcGxhdGVfZmlsZSwgMCkgPiAwKSB7CgkJc3RyaXBzcGFjZSgmdG1wbCwgY2xlYW51cF9tb2RlID09IENMRUFOVVBfQUxMKTsKCQlpZiAoc3RhcnQgKyB0bXBsLmxlbiA8PSBzYi0+bGVuICYmCgkJICAgIG1lbWNtcCh0bXBsLmJ1Ziwgc2ItPmJ1ZiArIHN0YXJ0LCB0bXBsLmxlbikgPT0gMCkKCQkJc3RhcnQgKz0gdG1wbC5sZW47Cgl9CglzdHJidWZfcmVsZWFzZSgmdG1wbCk7CgoJLyogQ2hlY2sgaWYgdGhlIHJlc3QgaXMganVzdCB3aGl0ZXNwYWNlIGFuZCBTaWduZWQtb2YtYnkncy4gKi8KCWZvciAoaSA9IHN0YXJ0OyBpIDwgc2ItPmxlbjsgaSsrKSB7CgkJbmwgPSBtZW1jaHIoc2ItPmJ1ZiArIGksICdcbicsIHNiLT5sZW4gLSBpKTsKCQlpZiAobmwpCgkJCWVvbCA9IG5sIC0gc2ItPmJ1ZjsKCQllbHNlCgkJCWVvbCA9IHNiLT5sZW47CgoJCWlmIChzdHJsZW4oc2lnbl9vZmZfaGVhZGVyKSA8PSBlb2wgLSBpICYmCgkJICAgICFwcmVmaXhjbXAoc2ItPmJ1ZiArIGksIHNpZ25fb2ZmX2hlYWRlcikpIHsKCQkJaSA9IGVvbDsKCQkJY29udGludWU7CgkJfQoJCXdoaWxlIChpIDwgZW9sKQoJCQlpZiAoIWlzc3BhY2Uoc2ItPmJ1ZltpKytdKSkKCQkJCXJldHVybiAwOwoJfQoKCXJldHVybiAxOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqZmluZF9hdXRob3JfYnlfbmlja25hbWUoY29uc3QgY2hhciAqbmFtZSkKewoJc3RydWN0IHJldl9pbmZvIHJldnM7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJY29uc3QgY2hhciAqYXZbMjBdOwoJaW50IGFjID0gMDsKCglpbml0X3JldmlzaW9ucygmcmV2cywgTlVMTCk7CglzdHJidWZfYWRkZigmYnVmLCAiLS1hdXRob3I9JXMiLCBuYW1lKTsKCWF2WysrYWNdID0gIi0tYWxsIjsKCWF2WysrYWNdID0gIi1pIjsKCWF2WysrYWNdID0gYnVmLmJ1ZjsKCWF2WysrYWNdID0gTlVMTDsKCXNldHVwX3JldmlzaW9ucyhhYywgYXYsICZyZXZzLCBOVUxMKTsKCXByZXBhcmVfcmV2aXNpb25fd2FsaygmcmV2cyk7Cgljb21taXQgPSBnZXRfcmV2aXNpb24oJnJldnMpOwoJaWYgKGNvbW1pdCkgewoJCXN0cnVjdCBwcmV0dHlfcHJpbnRfY29udGV4dCBjdHggPSB7MH07CgkJY3R4LmRhdGVfbW9kZSA9IERBVEVfTk9STUFMOwoJCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJCWZvcm1hdF9jb21taXRfbWVzc2FnZShjb21taXQsICIlYW4gPCVhZT4iLCAmYnVmLCAmY3R4KTsKCQlyZXR1cm4gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCX0KCWRpZSgiTm8gZXhpc3RpbmcgYXV0aG9yIGZvdW5kIHdpdGggJyVzJyIsIG5hbWUpOwp9CgoKc3RhdGljIHZvaWQgaGFuZGxlX3VudHJhY2tlZF9maWxlc19hcmcoc3RydWN0IHd0X3N0YXR1cyAqcykKewoJaWYgKCF1bnRyYWNrZWRfZmlsZXNfYXJnKQoJCTsgLyogZGVmYXVsdCBhbHJlYWR5IGluaXRpYWxpemVkICovCgllbHNlIGlmICghc3RyY21wKHVudHJhY2tlZF9maWxlc19hcmcsICJubyIpKQoJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19OT19VTlRSQUNLRURfRklMRVM7CgllbHNlIGlmICghc3RyY21wKHVudHJhY2tlZF9maWxlc19hcmcsICJub3JtYWwiKSkKCQlzLT5zaG93X3VudHJhY2tlZF9maWxlcyA9IFNIT1dfTk9STUFMX1VOVFJBQ0tFRF9GSUxFUzsKCWVsc2UgaWYgKCFzdHJjbXAodW50cmFja2VkX2ZpbGVzX2FyZywgImFsbCIpKQoJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19BTExfVU5UUkFDS0VEX0ZJTEVTOwoJZWxzZQoJCWRpZSgiSW52YWxpZCB1bnRyYWNrZWQgZmlsZXMgbW9kZSAnJXMnIiwgdW50cmFja2VkX2ZpbGVzX2FyZyk7Cn0KCnN0YXRpYyBpbnQgcGFyc2VfYW5kX3ZhbGlkYXRlX29wdGlvbnMoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKmFyZ3ZbXSwKCQkJCSAgICAgIGNvbnN0IGNoYXIgKiBjb25zdCB1c2FnZVtdLAoJCQkJICAgICAgY29uc3QgY2hhciAqcHJlZml4LAoJCQkJICAgICAgc3RydWN0IHd0X3N0YXR1cyAqcykKewoJaW50IGYgPSAwOwoKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgYnVpbHRpbl9jb21taXRfb3B0aW9ucywgdXNhZ2UsCgkJCSAgICAgMCk7CgoJaWYgKGZvcmNlX2F1dGhvciAmJiAhc3RyY2hyKGZvcmNlX2F1dGhvciwgJz4nKSkKCQlmb3JjZV9hdXRob3IgPSBmaW5kX2F1dGhvcl9ieV9uaWNrbmFtZShmb3JjZV9hdXRob3IpOwoKCWlmIChmb3JjZV9hdXRob3IgJiYgcmVuZXdfYXV0aG9yc2hpcCkKCQlkaWUoIlVzaW5nIGJvdGggLS1yZXNldC1hdXRob3IgYW5kIC0tYXV0aG9yIGRvZXMgbm90IG1ha2Ugc2Vuc2UiKTsKCglpZiAobG9nZmlsZSB8fCBtZXNzYWdlLmxlbiB8fCB1c2VfbWVzc2FnZSB8fCBmaXh1cF9tZXNzYWdlKQoJCXVzZV9lZGl0b3IgPSAwOwoJaWYgKGVkaXRfZmxhZykKCQl1c2VfZWRpdG9yID0gMTsKCWlmICghdXNlX2VkaXRvcikKCQlzZXRlbnYoIkdJVF9FRElUT1IiLCAiOiIsIDEpOwoKCWlmIChnZXRfc2hhMSgiSEVBRCIsIGhlYWRfc2hhMSkpCgkJaW5pdGlhbF9jb21taXQgPSAxOwoKCS8qIFNhbml0eSBjaGVjayBvcHRpb25zICovCglpZiAoYW1lbmQgJiYgaW5pdGlhbF9jb21taXQpCgkJZGllKCJZb3UgaGF2ZSBub3RoaW5nIHRvIGFtZW5kLiIpOwoJaWYgKGFtZW5kICYmIGluX21lcmdlKQoJCWRpZSgiWW91IGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgbWVyZ2UgLS0gY2Fubm90IGFtZW5kLiIpOwoJaWYgKGZpeHVwX21lc3NhZ2UgJiYgc3F1YXNoX21lc3NhZ2UpCgkJZGllKCJPcHRpb25zIC0tc3F1YXNoIGFuZCAtLWZpeHVwIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIik7CglpZiAodXNlX21lc3NhZ2UpCgkJZisrOwoJaWYgKGVkaXRfbWVzc2FnZSkKCQlmKys7CglpZiAoZml4dXBfbWVzc2FnZSkKCQlmKys7CglpZiAobG9nZmlsZSkKCQlmKys7CglpZiAoZiA+IDEpCgkJZGllKCJPbmx5IG9uZSBvZiAtYy8tQy8tRi8tLWZpeHVwIGNhbiBiZSB1c2VkLiIpOwoJaWYgKG1lc3NhZ2UubGVuICYmIGYgPiAwKQoJCWRpZSgiT3B0aW9uIC1tIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIC1jLy1DLy1GLy0tZml4dXAuIik7CglpZiAoZWRpdF9tZXNzYWdlKQoJCXVzZV9tZXNzYWdlID0gZWRpdF9tZXNzYWdlOwoJaWYgKGFtZW5kICYmICF1c2VfbWVzc2FnZSAmJiAhZml4dXBfbWVzc2FnZSkKCQl1c2VfbWVzc2FnZSA9ICJIRUFEIjsKCWlmICghdXNlX21lc3NhZ2UgJiYgcmVuZXdfYXV0aG9yc2hpcCkKCQlkaWUoIi0tcmVzZXQtYXV0aG9yIGNhbiBiZSB1c2VkIG9ubHkgd2l0aCAtQywgLWMgb3IgLS1hbWVuZC4iKTsKCWlmICh1c2VfbWVzc2FnZSkgewoJCWNvbnN0IGNoYXIgKm91dF9lbmM7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoKCQljb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9ieV9uYW1lKHVzZV9tZXNzYWdlKTsKCQlpZiAoIWNvbW1pdCkKCQkJZGllKCJjb3VsZCBub3QgbG9va3VwIGNvbW1pdCAlcyIsIHVzZV9tZXNzYWdlKTsKCQlvdXRfZW5jID0gZ2V0X2NvbW1pdF9vdXRwdXRfZW5jb2RpbmcoKTsKCQl1c2VfbWVzc2FnZV9idWZmZXIgPSBsb2dtc2dfcmVlbmNvZGUoY29tbWl0LCBvdXRfZW5jKTsKCgkJLyoKCQkgKiBJZiB3ZSBmYWlsZWQgdG8gcmVlbmNvZGUgdGhlIGJ1ZmZlciwganVzdCBjb3B5IGl0CgkJICogYnl0ZSBmb3IgYnl0ZSBzbyB0aGUgdXNlciBjYW4gdHJ5IHRvIGZpeCBpdCB1cC4KCQkgKiBUaGlzIGFsc28gaGFuZGxlcyB0aGUgY2FzZSB3aGVyZSBpbnB1dCBhbmQgb3V0cHV0CgkJICogZW5jb2RpbmdzIGFyZSBpZGVudGljYWwuCgkJICovCgkJaWYgKHVzZV9tZXNzYWdlX2J1ZmZlciA9PSBOVUxMKQoJCQl1c2VfbWVzc2FnZV9idWZmZXIgPSB4c3RyZHVwKGNvbW1pdC0+YnVmZmVyKTsKCX0KCglpZiAoISFhbHNvICsgISFvbmx5ICsgISFhbGwgKyAhIWludGVyYWN0aXZlID4gMSkKCQlkaWUoIk9ubHkgb25lIG9mIC0taW5jbHVkZS8tLW9ubHkvLS1hbGwvLS1pbnRlcmFjdGl2ZSBjYW4gYmUgdXNlZC4iKTsKCWlmIChhcmdjID09IDAgJiYgKGFsc28gfHwgKG9ubHkgJiYgIWFtZW5kKSkpCgkJZGllKCJObyBwYXRocyB3aXRoIC0taW5jbHVkZS8tLW9ubHkgZG9lcyBub3QgbWFrZSBzZW5zZS4iKTsKCWlmIChhcmdjID09IDAgJiYgb25seSAmJiBhbWVuZCkKCQlvbmx5X2luY2x1ZGVfYXNzdW1lZCA9ICJDbGV2ZXIuLi4gYW1lbmRpbmcgdGhlIGxhc3Qgb25lIHdpdGggZGlydHkgaW5kZXguIjsKCWlmIChhcmdjID4gMCAmJiAhYWxzbyAmJiAhb25seSkKCQlvbmx5X2luY2x1ZGVfYXNzdW1lZCA9ICJFeHBsaWNpdCBwYXRocyBzcGVjaWZpZWQgd2l0aG91dCAtaSBub3IgLW87IGFzc3VtaW5nIC0tb25seSBwYXRocy4uLiI7CglpZiAoIWNsZWFudXBfYXJnIHx8ICFzdHJjbXAoY2xlYW51cF9hcmcsICJkZWZhdWx0IikpCgkJY2xlYW51cF9tb2RlID0gdXNlX2VkaXRvciA/IENMRUFOVVBfQUxMIDogQ0xFQU5VUF9TUEFDRTsKCWVsc2UgaWYgKCFzdHJjbXAoY2xlYW51cF9hcmcsICJ2ZXJiYXRpbSIpKQoJCWNsZWFudXBfbW9kZSA9IENMRUFOVVBfTk9ORTsKCWVsc2UgaWYgKCFzdHJjbXAoY2xlYW51cF9hcmcsICJ3aGl0ZXNwYWNlIikpCgkJY2xlYW51cF9tb2RlID0gQ0xFQU5VUF9TUEFDRTsKCWVsc2UgaWYgKCFzdHJjbXAoY2xlYW51cF9hcmcsICJzdHJpcCIpKQoJCWNsZWFudXBfbW9kZSA9IENMRUFOVVBfQUxMOwoJZWxzZQoJCWRpZSgiSW52YWxpZCBjbGVhbnVwIG1vZGUgJXMiLCBjbGVhbnVwX2FyZyk7CgoJaGFuZGxlX3VudHJhY2tlZF9maWxlc19hcmcocyk7CgoJaWYgKGFsbCAmJiBhcmdjID4gMCkKCQlkaWUoIlBhdGhzIHdpdGggLWEgZG9lcyBub3QgbWFrZSBzZW5zZS4iKTsKCWVsc2UgaWYgKGludGVyYWN0aXZlICYmIGFyZ2MgPiAwKQoJCWRpZSgiUGF0aHMgd2l0aCAtLWludGVyYWN0aXZlIGRvZXMgbm90IG1ha2Ugc2Vuc2UuIik7CgoJaWYgKG51bGxfdGVybWluYXRpb24gJiYgc3RhdHVzX2Zvcm1hdCA9PSBTVEFUVVNfRk9STUFUX0xPTkcpCgkJc3RhdHVzX2Zvcm1hdCA9IFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOOwoJaWYgKHN0YXR1c19mb3JtYXQgIT0gU1RBVFVTX0ZPUk1BVF9MT05HKQoJCWRyeV9ydW4gPSAxOwoKCXJldHVybiBhcmdjOwp9CgpzdGF0aWMgaW50IGRyeV9ydW5fY29tbWl0KGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4LAoJCQkgIHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWludCBjb21taXRhYmxlOwoJY29uc3QgY2hhciAqaW5kZXhfZmlsZTsKCglpbmRleF9maWxlID0gcHJlcGFyZV9pbmRleChhcmdjLCBhcmd2LCBwcmVmaXgsIDEpOwoJY29tbWl0YWJsZSA9IHJ1bl9zdGF0dXMoc3Rkb3V0LCBpbmRleF9maWxlLCBwcmVmaXgsIDAsIHMpOwoJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCglyZXR1cm4gY29tbWl0YWJsZSA/IDAgOiAxOwp9CgpzdGF0aWMgaW50IHBhcnNlX3N0YXR1c19zbG90KGNvbnN0IGNoYXIgKnZhciwgaW50IG9mZnNldCkKewoJaWYgKCFzdHJjYXNlY21wKHZhcitvZmZzZXQsICJoZWFkZXIiKSkKCQlyZXR1cm4gV1RfU1RBVFVTX0hFQURFUjsKCWlmICghc3RyY2FzZWNtcCh2YXIrb2Zmc2V0LCAiYnJhbmNoIikpCgkJcmV0dXJuIFdUX1NUQVRVU19PTkJSQU5DSDsKCWlmICghc3RyY2FzZWNtcCh2YXIrb2Zmc2V0LCAidXBkYXRlZCIpCgkJfHwgIXN0cmNhc2VjbXAodmFyK29mZnNldCwgImFkZGVkIikpCgkJcmV0dXJuIFdUX1NUQVRVU19VUERBVEVEOwoJaWYgKCFzdHJjYXNlY21wKHZhcitvZmZzZXQsICJjaGFuZ2VkIikpCgkJcmV0dXJuIFdUX1NUQVRVU19DSEFOR0VEOwoJaWYgKCFzdHJjYXNlY21wKHZhcitvZmZzZXQsICJ1bnRyYWNrZWQiKSkKCQlyZXR1cm4gV1RfU1RBVFVTX1VOVFJBQ0tFRDsKCWlmICghc3RyY2FzZWNtcCh2YXIrb2Zmc2V0LCAibm9icmFuY2giKSkKCQlyZXR1cm4gV1RfU1RBVFVTX05PQlJBTkNIOwoJaWYgKCFzdHJjYXNlY21wKHZhcitvZmZzZXQsICJ1bm1lcmdlZCIpKQoJCXJldHVybiBXVF9TVEFUVVNfVU5NRVJHRUQ7CglyZXR1cm4gLTE7Cn0KCnN0YXRpYyBpbnQgZ2l0X3N0YXR1c19jb25maWcoY29uc3QgY2hhciAqaywgY29uc3QgY2hhciAqdiwgdm9pZCAqY2IpCnsKCXN0cnVjdCB3dF9zdGF0dXMgKnMgPSBjYjsKCglpZiAoIXN0cmNtcChrLCAic3RhdHVzLnN1Ym1vZHVsZXN1bW1hcnkiKSkgewoJCWludCBpc19ib29sOwoJCXMtPnN1Ym1vZHVsZV9zdW1tYXJ5ID0gZ2l0X2NvbmZpZ19ib29sX29yX2ludChrLCB2LCAmaXNfYm9vbCk7CgkJaWYgKGlzX2Jvb2wgJiYgcy0+c3VibW9kdWxlX3N1bW1hcnkpCgkJCXMtPnN1Ym1vZHVsZV9zdW1tYXJ5ID0gLTE7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAic3RhdHVzLmNvbG9yIikgfHwgIXN0cmNtcChrLCAiY29sb3Iuc3RhdHVzIikpIHsKCQlzLT51c2VfY29sb3IgPSBnaXRfY29uZmlnX2NvbG9yYm9vbChrLCB2LCAtMSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXByZWZpeGNtcChrLCAic3RhdHVzLmNvbG9yLiIpIHx8ICFwcmVmaXhjbXAoaywgImNvbG9yLnN0YXR1cy4iKSkgewoJCWludCBzbG90ID0gcGFyc2Vfc3RhdHVzX3Nsb3QoaywgMTMpOwoJCWlmIChzbG90IDwgMCkKCQkJcmV0dXJuIDA7CgkJaWYgKCF2KQoJCQlyZXR1cm4gY29uZmlnX2Vycm9yX25vbmJvb2woayk7CgkJY29sb3JfcGFyc2Uodiwgaywgcy0+Y29sb3JfcGFsZXR0ZVtzbG90XSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAic3RhdHVzLnJlbGF0aXZlcGF0aHMiKSkgewoJCXMtPnJlbGF0aXZlX3BhdGhzID0gZ2l0X2NvbmZpZ19ib29sKGssIHYpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaywgInN0YXR1cy5zaG93dW50cmFja2VkZmlsZXMiKSkgewoJCWlmICghdikKCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKGspOwoJCWVsc2UgaWYgKCFzdHJjbXAodiwgIm5vIikpCgkJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19OT19VTlRSQUNLRURfRklMRVM7CgkJZWxzZSBpZiAoIXN0cmNtcCh2LCAibm9ybWFsIikpCgkJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19OT1JNQUxfVU5UUkFDS0VEX0ZJTEVTOwoJCWVsc2UgaWYgKCFzdHJjbXAodiwgImFsbCIpKQoJCQlzLT5zaG93X3VudHJhY2tlZF9maWxlcyA9IFNIT1dfQUxMX1VOVFJBQ0tFRF9GSUxFUzsKCQllbHNlCgkJCXJldHVybiBlcnJvcigiSW52YWxpZCB1bnRyYWNrZWQgZmlsZXMgbW9kZSAnJXMnIiwgdik7CgkJcmV0dXJuIDA7Cgl9CglyZXR1cm4gZ2l0X2RpZmZfdWlfY29uZmlnKGssIHYsIE5VTEwpOwp9CgppbnQgY21kX3N0YXR1cyhpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IHd0X3N0YXR1cyBzOwoJaW50IGZkOwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCXN0YXRpYyBzdHJ1Y3Qgb3B0aW9uIGJ1aWx0aW5fc3RhdHVzX29wdGlvbnNbXSA9IHsKCQlPUFRfX1ZFUkJPU0UoJnZlcmJvc2UsICJiZSB2ZXJib3NlIiksCgkJT1BUX1NFVF9JTlQoJ3MnLCAic2hvcnQiLCAmc3RhdHVzX2Zvcm1hdCwKCQkJICAgICJzaG93IHN0YXR1cyBjb25jaXNlbHkiLCBTVEFUVVNfRk9STUFUX1NIT1JUKSwKCQlPUFRfQk9PTEVBTignYicsICJicmFuY2giLCAmc3RhdHVzX3Nob3dfYnJhbmNoLAoJCQkgICAgInNob3cgYnJhbmNoIGluZm9ybWF0aW9uIiksCgkJT1BUX1NFVF9JTlQoMCwgInBvcmNlbGFpbiIsICZzdGF0dXNfZm9ybWF0LAoJCQkgICAgIm1hY2hpbmUtcmVhZGFibGUgb3V0cHV0IiwKCQkJICAgIFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOKSwKCQlPUFRfQk9PTEVBTigneicsICJudWxsIiwgJm51bGxfdGVybWluYXRpb24sCgkJCSAgICAidGVybWluYXRlIGVudHJpZXMgd2l0aCBOVUwiKSwKCQl7IE9QVElPTl9TVFJJTkcsICd1JywgInVudHJhY2tlZC1maWxlcyIsICZ1bnRyYWNrZWRfZmlsZXNfYXJnLAoJCSAgIm1vZGUiLAoJCSAgInNob3cgdW50cmFja2VkIGZpbGVzLCBvcHRpb25hbCBtb2RlczogYWxsLCBub3JtYWwsIG5vLiAoRGVmYXVsdDogYWxsKSIsCgkJICBQQVJTRV9PUFRfT1BUQVJHLCBOVUxMLCAoaW50cHRyX3QpImFsbCIgfSwKCQlPUFRfQk9PTEVBTigwLCAiaWdub3JlZCIsICZzaG93X2lnbm9yZWRfaW5fc3RhdHVzLAoJCQkgICAgInNob3cgaWdub3JlZCBmaWxlcyIpLAoJCXsgT1BUSU9OX1NUUklORywgMCwgImlnbm9yZS1zdWJtb2R1bGVzIiwgJmlnbm9yZV9zdWJtb2R1bGVfYXJnLCAid2hlbiIsCgkJICAiaWdub3JlIGNoYW5nZXMgdG8gc3VibW9kdWxlcywgb3B0aW9uYWwgd2hlbjogYWxsLCBkaXJ0eSwgdW50cmFja2VkLiAoRGVmYXVsdDogYWxsKSIsCgkJICBQQVJTRV9PUFRfT1BUQVJHLCBOVUxMLCAoaW50cHRyX3QpImFsbCIgfSwKCQlPUFRfRU5EKCksCgl9OwoKCWlmIChhcmdjID09IDIgJiYgIXN0cmNtcChhcmd2WzFdLCAiLWgiKSkKCQl1c2FnZV93aXRoX29wdGlvbnMoYnVpbHRpbl9zdGF0dXNfdXNhZ2UsIGJ1aWx0aW5fc3RhdHVzX29wdGlvbnMpOwoKCWlmIChudWxsX3Rlcm1pbmF0aW9uICYmIHN0YXR1c19mb3JtYXQgPT0gU1RBVFVTX0ZPUk1BVF9MT05HKQoJCXN0YXR1c19mb3JtYXQgPSBTVEFUVVNfRk9STUFUX1BPUkNFTEFJTjsKCgl3dF9zdGF0dXNfcHJlcGFyZSgmcyk7CglnaXRtb2R1bGVzX2NvbmZpZygpOwoJZ2l0X2NvbmZpZyhnaXRfc3RhdHVzX2NvbmZpZywgJnMpOwoJaW5fbWVyZ2UgPSBmaWxlX2V4aXN0cyhnaXRfcGF0aCgiTUVSR0VfSEVBRCIpKTsKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwKCQkJICAgICBidWlsdGluX3N0YXR1c19vcHRpb25zLAoJCQkgICAgIGJ1aWx0aW5fc3RhdHVzX3VzYWdlLCAwKTsKCWhhbmRsZV91bnRyYWNrZWRfZmlsZXNfYXJnKCZzKTsKCWlmIChzaG93X2lnbm9yZWRfaW5fc3RhdHVzKQoJCXMuc2hvd19pZ25vcmVkX2ZpbGVzID0gMTsKCWlmICgqYXJndikKCQlzLnBhdGhzcGVjID0gZ2V0X3BhdGhzcGVjKHByZWZpeCwgYXJndik7CgoJcmVhZF9jYWNoZV9wcmVsb2FkKHMucGF0aHNwZWMpOwoJcmVmcmVzaF9pbmRleCgmdGhlX2luZGV4LCBSRUZSRVNIX1FVSUVUfFJFRlJFU0hfVU5NRVJHRUQsIHMucGF0aHNwZWMsIE5VTEwsIE5VTEwpOwoKCWZkID0gaG9sZF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2ssIDApOwoJaWYgKDAgPD0gZmQpIHsKCQlpZiAoYWN0aXZlX2NhY2hlX2NoYW5nZWQgJiYKCQkgICAgIXdyaXRlX2NhY2hlKGZkLCBhY3RpdmVfY2FjaGUsIGFjdGl2ZV9ucikpCgkJCWNvbW1pdF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2spOwoJCWVsc2UKCQkJcm9sbGJhY2tfbG9ja19maWxlKCZpbmRleF9sb2NrKTsKCX0KCglzLmlzX2luaXRpYWwgPSBnZXRfc2hhMShzLnJlZmVyZW5jZSwgc2hhMSkgPyAxIDogMDsKCXMuaW5fbWVyZ2UgPSBpbl9tZXJnZTsKCXMuaWdub3JlX3N1Ym1vZHVsZV9hcmcgPSBpZ25vcmVfc3VibW9kdWxlX2FyZzsKCXd0X3N0YXR1c19jb2xsZWN0KCZzKTsKCglpZiAocy5yZWxhdGl2ZV9wYXRocykKCQlzLnByZWZpeCA9IHByZWZpeDsKCWlmIChzLnVzZV9jb2xvciA9PSAtMSkKCQlzLnVzZV9jb2xvciA9IGdpdF91c2VfY29sb3JfZGVmYXVsdDsKCWlmIChkaWZmX3VzZV9jb2xvcl9kZWZhdWx0ID09IC0xKQoJCWRpZmZfdXNlX2NvbG9yX2RlZmF1bHQgPSBnaXRfdXNlX2NvbG9yX2RlZmF1bHQ7CgoJc3dpdGNoIChzdGF0dXNfZm9ybWF0KSB7CgljYXNlIFNUQVRVU19GT1JNQVRfU0hPUlQ6CgkJd3Rfc2hvcnRzdGF0dXNfcHJpbnQoJnMsIG51bGxfdGVybWluYXRpb24sIHN0YXR1c19zaG93X2JyYW5jaCk7CgkJYnJlYWs7CgljYXNlIFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOOgoJCXd0X3BvcmNlbGFpbl9wcmludCgmcywgbnVsbF90ZXJtaW5hdGlvbik7CgkJYnJlYWs7CgljYXNlIFNUQVRVU19GT1JNQVRfTE9ORzoKCQlzLnZlcmJvc2UgPSB2ZXJib3NlOwoJCXMuaWdub3JlX3N1Ym1vZHVsZV9hcmcgPSBpZ25vcmVfc3VibW9kdWxlX2FyZzsKCQl3dF9zdGF0dXNfcHJpbnQoJnMpOwoJCWJyZWFrOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHByaW50X3N1bW1hcnkoY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglzdHJ1Y3QgcmV2X2luZm8gcmV2OwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJc3RydWN0IHN0cmJ1ZiBmb3JtYXQgPSBTVFJCVUZfSU5JVDsKCXVuc2lnbmVkIGNoYXIganVua19zaGExWzIwXTsKCWNvbnN0IGNoYXIgKmhlYWQgPSByZXNvbHZlX3JlZigiSEVBRCIsIGp1bmtfc2hhMSwgMCwgTlVMTCk7CglzdHJ1Y3QgcHJldHR5X3ByaW50X2NvbnRleHQgcGN0eCA9IHswfTsKCXN0cnVjdCBzdHJidWYgYXV0aG9yX2lkZW50ID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGNvbW1pdHRlcl9pZGVudCA9IFNUUkJVRl9JTklUOwoKCWNvbW1pdCA9IGxvb2t1cF9jb21taXQoc2hhMSk7CglpZiAoIWNvbW1pdCkKCQlkaWUoImNvdWxkbid0IGxvb2sgdXAgbmV3bHkgY3JlYXRlZCBjb21taXQiKTsKCWlmICghY29tbWl0IHx8IHBhcnNlX2NvbW1pdChjb21taXQpKQoJCWRpZSgiY291bGQgbm90IHBhcnNlIG5ld2x5IGNyZWF0ZWQgY29tbWl0Iik7CgoJc3RyYnVmX2FkZHN0cigmZm9ybWF0LCAiZm9ybWF0OiVoXSAlcyIpOwoKCWZvcm1hdF9jb21taXRfbWVzc2FnZShjb21taXQsICIlYW4gPCVhZT4iLCAmYXV0aG9yX2lkZW50LCAmcGN0eCk7Cglmb3JtYXRfY29tbWl0X21lc3NhZ2UoY29tbWl0LCAiJWNuIDwlY2U+IiwgJmNvbW1pdHRlcl9pZGVudCwgJnBjdHgpOwoJaWYgKHN0cmJ1Zl9jbXAoJmF1dGhvcl9pZGVudCwgJmNvbW1pdHRlcl9pZGVudCkpIHsKCQlzdHJidWZfYWRkc3RyKCZmb3JtYXQsICJcbiBBdXRob3I6ICIpOwoJCXN0cmJ1Zl9hZGRidWZfcGVyY2VudHF1b3RlKCZmb3JtYXQsICZhdXRob3JfaWRlbnQpOwoJfQoJaWYgKCF1c2VyX2lkZW50X3N1ZmZpY2llbnRseV9naXZlbigpKSB7CgkJc3RyYnVmX2FkZHN0cigmZm9ybWF0LCAiXG4gQ29tbWl0dGVyOiAiKTsKCQlzdHJidWZfYWRkYnVmX3BlcmNlbnRxdW90ZSgmZm9ybWF0LCAmY29tbWl0dGVyX2lkZW50KTsKCQlpZiAoYWR2aWNlX2ltcGxpY2l0X2lkZW50aXR5KSB7CgkJCXN0cmJ1Zl9hZGRjaCgmZm9ybWF0LCAnXG4nKTsKCQkJc3RyYnVmX2FkZHN0cigmZm9ybWF0LCBpbXBsaWNpdF9pZGVudF9hZHZpY2UpOwoJCX0KCX0KCXN0cmJ1Zl9yZWxlYXNlKCZhdXRob3JfaWRlbnQpOwoJc3RyYnVmX3JlbGVhc2UoJmNvbW1pdHRlcl9pZGVudCk7CgoJaW5pdF9yZXZpc2lvbnMoJnJldiwgcHJlZml4KTsKCXNldHVwX3JldmlzaW9ucygwLCBOVUxMLCAmcmV2LCBOVUxMKTsKCglyZXYuZGlmZiA9IDE7CglyZXYuZGlmZm9wdC5vdXRwdXRfZm9ybWF0ID0KCQlESUZGX0ZPUk1BVF9TSE9SVFNUQVQgfCBESUZGX0ZPUk1BVF9TVU1NQVJZOwoKCXJldi52ZXJib3NlX2hlYWRlciA9IDE7CglyZXYuc2hvd19yb290X2RpZmYgPSAxOwoJZ2V0X2NvbW1pdF9mb3JtYXQoZm9ybWF0LmJ1ZiwgJnJldik7CglyZXYuYWx3YXlzX3Nob3dfaGVhZGVyID0gMDsKCXJldi5kaWZmb3B0LmRldGVjdF9yZW5hbWUgPSAxOwoJcmV2LmRpZmZvcHQucmVuYW1lX2xpbWl0ID0gMTAwOwoJcmV2LmRpZmZvcHQuYnJlYWtfb3B0ID0gMDsKCWRpZmZfc2V0dXBfZG9uZSgmcmV2LmRpZmZvcHQpOwoKCXByaW50ZigiWyVzJXMgIiwKCQkhcHJlZml4Y21wKGhlYWQsICJyZWZzL2hlYWRzLyIpID8KCQkJaGVhZCArIDExIDoKCQkJIXN0cmNtcChoZWFkLCAiSEVBRCIpID8KCQkJCSJkZXRhY2hlZCBIRUFEIiA6CgkJCQloZWFkLAoJCWluaXRpYWxfY29tbWl0ID8gIiAocm9vdC1jb21taXQpIiA6ICIiKTsKCglpZiAoIWxvZ190cmVlX2NvbW1pdCgmcmV2LCBjb21taXQpKSB7CgkJcmV2LmFsd2F5c19zaG93X2hlYWRlciA9IDE7CgkJcmV2LnVzZV90ZXJtaW5hdG9yID0gMTsKCQlsb2dfdHJlZV9jb21taXQoJnJldiwgY29tbWl0KTsKCX0KCglzdHJidWZfcmVsZWFzZSgmZm9ybWF0KTsKfQoKc3RhdGljIGludCBnaXRfY29tbWl0X2NvbmZpZyhjb25zdCBjaGFyICprLCBjb25zdCBjaGFyICp2LCB2b2lkICpjYikKewoJc3RydWN0IHd0X3N0YXR1cyAqcyA9IGNiOwoKCWlmICghc3RyY21wKGssICJjb21taXQudGVtcGxhdGUiKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19wYXRobmFtZSgmdGVtcGxhdGVfZmlsZSwgaywgdik7CglpZiAoIXN0cmNtcChrLCAiY29tbWl0LnN0YXR1cyIpKSB7CgkJaW5jbHVkZV9zdGF0dXMgPSBnaXRfY29uZmlnX2Jvb2woaywgdik7CgkJcmV0dXJuIDA7Cgl9CgoJcmV0dXJuIGdpdF9zdGF0dXNfY29uZmlnKGssIHYsIHMpOwp9CgpzdGF0aWMgY29uc3QgY2hhciBwb3N0X3Jld3JpdGVfaG9va1tdID0gImhvb2tzL3Bvc3QtcmV3cml0ZSI7CgpzdGF0aWMgaW50IHJ1bl9yZXdyaXRlX2hvb2soY29uc3QgdW5zaWduZWQgY2hhciAqb2xkc2hhMSwKCQkJICAgIGNvbnN0IHVuc2lnbmVkIGNoYXIgKm5ld3NoYTEpCnsKCS8qIG9sZHNoYTEgU1AgbmV3c2hhMSBMRiBOVUwgKi8KCXN0YXRpYyBjaGFyIGJ1ZlsyKjQwICsgM107CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBwcm9jOwoJY29uc3QgY2hhciAqYXJndlszXTsKCWludCBjb2RlOwoJc2l6ZV90IG47CgoJaWYgKGFjY2VzcyhnaXRfcGF0aChwb3N0X3Jld3JpdGVfaG9vayksIFhfT0spIDwgMCkKCQlyZXR1cm4gMDsKCglhcmd2WzBdID0gZ2l0X3BhdGgocG9zdF9yZXdyaXRlX2hvb2spOwoJYXJndlsxXSA9ICJhbWVuZCI7Cglhcmd2WzJdID0gTlVMTDsKCgltZW1zZXQoJnByb2MsIDAsIHNpemVvZihwcm9jKSk7Cglwcm9jLmFyZ3YgPSBhcmd2OwoJcHJvYy5pbiA9IC0xOwoJcHJvYy5zdGRvdXRfdG9fc3RkZXJyID0gMTsKCgljb2RlID0gc3RhcnRfY29tbWFuZCgmcHJvYyk7CglpZiAoY29kZSkKCQlyZXR1cm4gY29kZTsKCW4gPSBzbnByaW50ZihidWYsIHNpemVvZihidWYpLCAiJXMgJXNcbiIsCgkJICAgICBzaGExX3RvX2hleChvbGRzaGExKSwgc2hhMV90b19oZXgobmV3c2hhMSkpOwoJd3JpdGVfaW5fZnVsbChwcm9jLmluLCBidWYsIG4pOwoJY2xvc2UocHJvYy5pbik7CglyZXR1cm4gZmluaXNoX2NvbW1hbmQoJnByb2MpOwp9CgppbnQgY21kX2NvbW1pdChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBhdXRob3JfaWRlbnQgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKmluZGV4X2ZpbGUsICpyZWZsb2dfbXNnOwoJY2hhciAqbmwsICpwOwoJdW5zaWduZWQgY2hhciBjb21taXRfc2hhMVsyMF07CglzdHJ1Y3QgcmVmX2xvY2sgKnJlZl9sb2NrOwoJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzID0gTlVMTCwgKipwcHRyID0gJnBhcmVudHM7CglzdHJ1Y3Qgc3RhdCBzdGF0YnVmOwoJaW50IGFsbG93X2Zhc3RfZm9yd2FyZCA9IDE7CglzdHJ1Y3Qgd3Rfc3RhdHVzIHM7CgoJaWYgKGFyZ2MgPT0gMiAmJiAhc3RyY21wKGFyZ3ZbMV0sICItaCIpKQoJCXVzYWdlX3dpdGhfb3B0aW9ucyhidWlsdGluX2NvbW1pdF91c2FnZSwgYnVpbHRpbl9jb21taXRfb3B0aW9ucyk7CgoJd3Rfc3RhdHVzX3ByZXBhcmUoJnMpOwoJZ2l0X2NvbmZpZyhnaXRfY29tbWl0X2NvbmZpZywgJnMpOwoJaW5fbWVyZ2UgPSBmaWxlX2V4aXN0cyhnaXRfcGF0aCgiTUVSR0VfSEVBRCIpKTsKCXMuaW5fbWVyZ2UgPSBpbl9tZXJnZTsKCglpZiAocy51c2VfY29sb3IgPT0gLTEpCgkJcy51c2VfY29sb3IgPSBnaXRfdXNlX2NvbG9yX2RlZmF1bHQ7CglhcmdjID0gcGFyc2VfYW5kX3ZhbGlkYXRlX29wdGlvbnMoYXJnYywgYXJndiwgYnVpbHRpbl9jb21taXRfdXNhZ2UsCgkJCQkJICBwcmVmaXgsICZzKTsKCWlmIChkcnlfcnVuKSB7CgkJaWYgKGRpZmZfdXNlX2NvbG9yX2RlZmF1bHQgPT0gLTEpCgkJCWRpZmZfdXNlX2NvbG9yX2RlZmF1bHQgPSBnaXRfdXNlX2NvbG9yX2RlZmF1bHQ7CgkJcmV0dXJuIGRyeV9ydW5fY29tbWl0KGFyZ2MsIGFyZ3YsIHByZWZpeCwgJnMpOwoJfQoJaW5kZXhfZmlsZSA9IHByZXBhcmVfaW5kZXgoYXJnYywgYXJndiwgcHJlZml4LCAwKTsKCgkvKiBTZXQgdXAgZXZlcnl0aGluZyBmb3Igd3JpdGluZyB0aGUgY29tbWl0IG9iamVjdC4gIFRoaXMgaW5jbHVkZXMKCSAgIHJ1bm5pbmcgaG9va3MsIHdyaXRpbmcgdGhlIHRyZWVzLCBhbmQgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdXNlci4gICovCglpZiAoIXByZXBhcmVfdG9fY29tbWl0KGluZGV4X2ZpbGUsIHByZWZpeCwgJnMsICZhdXRob3JfaWRlbnQpKSB7CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlyZXR1cm4gMTsKCX0KCgkvKiBEZXRlcm1pbmUgcGFyZW50cyAqLwoJcmVmbG9nX21zZyA9IGdldGVudigiR0lUX1JFRkxPR19BQ1RJT04iKTsKCWlmIChpbml0aWFsX2NvbW1pdCkgewoJCWlmICghcmVmbG9nX21zZykKCQkJcmVmbG9nX21zZyA9ICJjb21taXQgKGluaXRpYWwpIjsKCX0gZWxzZSBpZiAoYW1lbmQpIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKmM7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoKCQlpZiAoIXJlZmxvZ19tc2cpCgkJCXJlZmxvZ19tc2cgPSAiY29tbWl0IChhbWVuZCkiOwoJCWNvbW1pdCA9IGxvb2t1cF9jb21taXQoaGVhZF9zaGExKTsKCQlpZiAoIWNvbW1pdCB8fCBwYXJzZV9jb21taXQoY29tbWl0KSkKCQkJZGllKCJjb3VsZCBub3QgcGFyc2UgSEVBRCBjb21taXQiKTsKCgkJZm9yIChjID0gY29tbWl0LT5wYXJlbnRzOyBjOyBjID0gYy0+bmV4dCkKCQkJcHB0ciA9ICZjb21taXRfbGlzdF9pbnNlcnQoYy0+aXRlbSwgcHB0ciktPm5leHQ7Cgl9IGVsc2UgaWYgKGluX21lcmdlKSB7CgkJc3RydWN0IHN0cmJ1ZiBtID0gU1RSQlVGX0lOSVQ7CgkJRklMRSAqZnA7CgoJCWlmICghcmVmbG9nX21zZykKCQkJcmVmbG9nX21zZyA9ICJjb21taXQgKG1lcmdlKSI7CgkJcHB0ciA9ICZjb21taXRfbGlzdF9pbnNlcnQobG9va3VwX2NvbW1pdChoZWFkX3NoYTEpLCBwcHRyKS0+bmV4dDsKCQlmcCA9IGZvcGVuKGdpdF9wYXRoKCJNRVJHRV9IRUFEIiksICJyIik7CgkJaWYgKGZwID09IE5VTEwpCgkJCWRpZV9lcnJubygiY291bGQgbm90IG9wZW4gJyVzJyBmb3IgcmVhZGluZyIsCgkJCQkgIGdpdF9wYXRoKCJNRVJHRV9IRUFEIikpOwoJCXdoaWxlIChzdHJidWZfZ2V0bGluZSgmbSwgZnAsICdcbicpICE9IEVPRikgewoJCQl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJCQlpZiAoZ2V0X3NoYTFfaGV4KG0uYnVmLCBzaGExKSA8IDApCgkJCQlkaWUoIkNvcnJ1cHQgTUVSR0VfSEVBRCBmaWxlICglcykiLCBtLmJ1Zik7CgkJCXBwdHIgPSAmY29tbWl0X2xpc3RfaW5zZXJ0KGxvb2t1cF9jb21taXQoc2hhMSksIHBwdHIpLT5uZXh0OwoJCX0KCQlmY2xvc2UoZnApOwoJCXN0cmJ1Zl9yZWxlYXNlKCZtKTsKCQlpZiAoIXN0YXQoZ2l0X3BhdGgoIk1FUkdFX01PREUiKSwgJnN0YXRidWYpKSB7CgkJCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgZ2l0X3BhdGgoIk1FUkdFX01PREUiKSwgMCkgPCAwKQoJCQkJZGllX2Vycm5vKCJjb3VsZCBub3QgcmVhZCBNRVJHRV9NT0RFIik7CgkJCWlmICghc3RyY21wKHNiLmJ1ZiwgIm5vLWZmIikpCgkJCQlhbGxvd19mYXN0X2ZvcndhcmQgPSAwOwoJCX0KCQlpZiAoYWxsb3dfZmFzdF9mb3J3YXJkKQoJCQlwYXJlbnRzID0gcmVkdWNlX2hlYWRzKHBhcmVudHMpOwoJfSBlbHNlIHsKCQlpZiAoIXJlZmxvZ19tc2cpCgkJCXJlZmxvZ19tc2cgPSAiY29tbWl0IjsKCQlwcHRyID0gJmNvbW1pdF9saXN0X2luc2VydChsb29rdXBfY29tbWl0KGhlYWRfc2hhMSksIHBwdHIpLT5uZXh0OwoJfQoKCS8qIEZpbmFsbHksIGdldCB0aGUgY29tbWl0IG1lc3NhZ2UgKi8KCXN0cmJ1Zl9yZXNldCgmc2IpOwoJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJnNiLCBnaXRfcGF0aChjb21taXRfZWRpdG1zZyksIDApIDwgMCkgewoJCWludCBzYXZlZF9lcnJubyA9IGVycm5vOwoJCXJvbGxiYWNrX2luZGV4X2ZpbGVzKCk7CgkJZGllKCJjb3VsZCBub3QgcmVhZCBjb21taXQgbWVzc2FnZTogJXMiLCBzdHJlcnJvcihzYXZlZF9lcnJubykpOwoJfQoKCS8qIFRydW5jYXRlIHRoZSBtZXNzYWdlIGp1c3QgYmVmb3JlIHRoZSBkaWZmLCBpZiBhbnkuICovCglpZiAodmVyYm9zZSkgewoJCXAgPSBzdHJzdHIoc2IuYnVmLCAiXG5kaWZmIC0tZ2l0ICIpOwoJCWlmIChwICE9IE5VTEwpCgkJCXN0cmJ1Zl9zZXRsZW4oJnNiLCBwIC0gc2IuYnVmICsgMSk7Cgl9CgoJaWYgKGNsZWFudXBfbW9kZSAhPSBDTEVBTlVQX05PTkUpCgkJc3RyaXBzcGFjZSgmc2IsIGNsZWFudXBfbW9kZSA9PSBDTEVBTlVQX0FMTCk7CglpZiAobWVzc2FnZV9pc19lbXB0eSgmc2IpICYmICFhbGxvd19lbXB0eV9tZXNzYWdlKSB7CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlmcHJpbnRmKHN0ZGVyciwgIkFib3J0aW5nIGNvbW1pdCBkdWUgdG8gZW1wdHkgY29tbWl0IG1lc3NhZ2UuXG4iKTsKCQlleGl0KDEpOwoJfQoKCWlmIChjb21taXRfdHJlZShzYi5idWYsIGFjdGl2ZV9jYWNoZV90cmVlLT5zaGExLCBwYXJlbnRzLCBjb21taXRfc2hhMSwKCQkJYXV0aG9yX2lkZW50LmJ1ZikpIHsKCQlyb2xsYmFja19pbmRleF9maWxlcygpOwoJCWRpZSgiZmFpbGVkIHRvIHdyaXRlIGNvbW1pdCBvYmplY3QiKTsKCX0KCXN0cmJ1Zl9yZWxlYXNlKCZhdXRob3JfaWRlbnQpOwoKCXJlZl9sb2NrID0gbG9ja19hbnlfcmVmX2Zvcl91cGRhdGUoIkhFQUQiLAoJCQkJCSAgIGluaXRpYWxfY29tbWl0ID8gTlVMTCA6IGhlYWRfc2hhMSwKCQkJCQkgICAwKTsKCglubCA9IHN0cmNocihzYi5idWYsICdcbicpOwoJaWYgKG5sKQoJCXN0cmJ1Zl9zZXRsZW4oJnNiLCBubCArIDEgLSBzYi5idWYpOwoJZWxzZQoJCXN0cmJ1Zl9hZGRjaCgmc2IsICdcbicpOwoJc3RyYnVmX2luc2VydCgmc2IsIDAsIHJlZmxvZ19tc2csIHN0cmxlbihyZWZsb2dfbXNnKSk7CglzdHJidWZfaW5zZXJ0KCZzYiwgc3RybGVuKHJlZmxvZ19tc2cpLCAiOiAiLCAyKTsKCglpZiAoIXJlZl9sb2NrKSB7CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlkaWUoImNhbm5vdCBsb2NrIEhFQUQgcmVmIik7Cgl9CglpZiAod3JpdGVfcmVmX3NoYTEocmVmX2xvY2ssIGNvbW1pdF9zaGExLCBzYi5idWYpIDwgMCkgewoJCXJvbGxiYWNrX2luZGV4X2ZpbGVzKCk7CgkJZGllKCJjYW5ub3QgdXBkYXRlIEhFQUQgcmVmIik7Cgl9CgoJdW5saW5rKGdpdF9wYXRoKCJNRVJHRV9IRUFEIikpOwoJdW5saW5rKGdpdF9wYXRoKCJNRVJHRV9NU0ciKSk7Cgl1bmxpbmsoZ2l0X3BhdGgoIk1FUkdFX01PREUiKSk7Cgl1bmxpbmsoZ2l0X3BhdGgoIlNRVUFTSF9NU0ciKSk7CgoJaWYgKGNvbW1pdF9pbmRleF9maWxlcygpKQoJCWRpZSAoIlJlcG9zaXRvcnkgaGFzIGJlZW4gdXBkYXRlZCwgYnV0IHVuYWJsZSB0byB3cml0ZVxuIgoJCSAgICAgIm5ld19pbmRleCBmaWxlLiBDaGVjayB0aGF0IGRpc2sgaXMgbm90IGZ1bGwgb3IgcXVvdGEgaXNcbiIKCQkgICAgICJub3QgZXhjZWVkZWQsIGFuZCB0aGVuIFwiZ2l0IHJlc2V0IEhFQURcIiB0byByZWNvdmVyLiIpOwoKCXJlcmVyZSgwKTsKCXJ1bl9ob29rKGdldF9pbmRleF9maWxlKCksICJwb3N0LWNvbW1pdCIsIE5VTEwpOwoJaWYgKGFtZW5kICYmICFub19wb3N0X3Jld3JpdGUpIHsKCQlzdHJ1Y3Qgbm90ZXNfcmV3cml0ZV9jZmcgKmNmZzsKCQljZmcgPSBpbml0X2NvcHlfbm90ZXNfZm9yX3Jld3JpdGUoImFtZW5kIik7CgkJaWYgKGNmZykgewoJCQljb3B5X25vdGVfZm9yX3Jld3JpdGUoY2ZnLCBoZWFkX3NoYTEsIGNvbW1pdF9zaGExKTsKCQkJZmluaXNoX2NvcHlfbm90ZXNfZm9yX3Jld3JpdGUoY2ZnKTsKCQl9CgkJcnVuX3Jld3JpdGVfaG9vayhoZWFkX3NoYTEsIGNvbW1pdF9zaGExKTsKCX0KCWlmICghcXVpZXQpCgkJcHJpbnRfc3VtbWFyeShwcmVmaXgsIGNvbW1pdF9zaGExKTsKCglyZXR1cm4gMDsKfQo=",
    "text": "/*\n * Builtin \"git commit\"\n *\n * Copyright (c) 2007 Kristian H\u00f8gsberg <krh@redhat.com>\n * Based on git-commit.sh by Junio C Hamano and Linus Torvalds\n */\n\n#include \"cache.h\"\n#include \"cache-tree.h\"\n#include \"color.h\"\n#include \"dir.h\"\n#include \"builtin.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"commit.h\"\n#include \"revision.h\"\n#include \"wt-status.h\"\n#include \"run-command.h\"\n#include \"refs.h\"\n#include \"log-tree.h\"\n#include \"strbuf.h\"\n#include \"utf8.h\"\n#include \"parse-options.h\"\n#include \"string-list.h\"\n#include \"rerere.h\"\n#include \"unpack-trees.h\"\n#include \"quote.h\"\n#include \"submodule.h\"\n\nstatic const char * const builtin_commit_usage[] = {\n\t\"git commit [options] [--] <filepattern>...\",\n\tNULL\n};\n\nstatic const char * const builtin_status_usage[] = {\n\t\"git status [options] [--] <filepattern>...\",\n\tNULL\n};\n\nstatic const char implicit_ident_advice[] =\n\"Your name and email address were configured automatically based\\n\"\n\"on your username and hostname. Please check that they are accurate.\\n\"\n\"You can suppress this message by setting them explicitly:\\n\"\n\"\\n\"\n\"    git config --global user.name \\\"Your Name\\\"\\n\"\n\"    git config --global user.email you@example.com\\n\"\n\"\\n\"\n\"After doing this, you may fix the identity used for this commit with:\\n\"\n\"\\n\"\n\"    git commit --amend --reset-author\\n\";\n\nstatic const char empty_amend_advice[] =\n\"You asked to amend the most recent commit, but doing so would make\\n\"\n\"it empty. You can repeat your command with --allow-empty, or you can\\n\"\n\"remove the commit entirely with \\\"git reset HEAD^\\\".\\n\";\n\nstatic unsigned char head_sha1[20];\n\nstatic char *use_message_buffer;\nstatic const char commit_editmsg[] = \"COMMIT_EDITMSG\";\nstatic struct lock_file index_lock; /* real index */\nstatic struct lock_file false_lock; /* used only for partial commits */\nstatic enum {\n\tCOMMIT_AS_IS = 1,\n\tCOMMIT_NORMAL,\n\tCOMMIT_PARTIAL\n} commit_style;\n\nstatic const char *logfile, *force_author;\nstatic const char *template_file;\nstatic char *edit_message, *use_message;\nstatic char *fixup_message, *squash_message;\nstatic int all, edit_flag, also, interactive, only, amend, signoff;\nstatic int quiet, verbose, no_verify, allow_empty, dry_run, renew_authorship;\nstatic int no_post_rewrite, allow_empty_message;\nstatic char *untracked_files_arg, *force_date, *ignore_submodule_arg;\n/*\n * The default commit message cleanup mode will remove the lines\n * beginning with # (shell comments) and leading and trailing\n * whitespaces (empty lines or containing only whitespaces)\n * if editor is used, and only the whitespaces if the message\n * is specified explicitly.\n */\nstatic enum {\n\tCLEANUP_SPACE,\n\tCLEANUP_NONE,\n\tCLEANUP_ALL\n} cleanup_mode;\nstatic char *cleanup_arg;\n\nstatic int use_editor = 1, initial_commit, in_merge, include_status = 1;\nstatic int show_ignored_in_status;\nstatic const char *only_include_assumed;\nstatic struct strbuf message;\n\nstatic int null_termination;\nstatic enum {\n\tSTATUS_FORMAT_LONG,\n\tSTATUS_FORMAT_SHORT,\n\tSTATUS_FORMAT_PORCELAIN\n} status_format = STATUS_FORMAT_LONG;\nstatic int status_show_branch;\n\nstatic int opt_parse_m(const struct option *opt, const char *arg, int unset)\n{\n\tstruct strbuf *buf = opt->value;\n\tif (unset)\n\t\tstrbuf_setlen(buf, 0);\n\telse {\n\t\tstrbuf_addstr(buf, arg);\n\t\tstrbuf_addstr(buf, \"\\n\\n\");\n\t}\n\treturn 0;\n}\n\nstatic struct option builtin_commit_options[] = {\n\tOPT__QUIET(&quiet, \"suppress summary after successful commit\"),\n\tOPT__VERBOSE(&verbose, \"show diff in commit message template\"),\n\n\tOPT_GROUP(\"Commit message options\"),\n\tOPT_FILENAME('F', \"file\", &logfile, \"read message from file\"),\n\tOPT_STRING(0, \"author\", &force_author, \"AUTHOR\", \"override author for commit\"),\n\tOPT_STRING(0, \"date\", &force_date, \"DATE\", \"override date for commit\"),\n\tOPT_CALLBACK('m', \"message\", &message, \"MESSAGE\", \"commit message\", opt_parse_m),\n\tOPT_STRING('c', \"reedit-message\", &edit_message, \"COMMIT\", \"reuse and edit message from specified commit\"),\n\tOPT_STRING('C', \"reuse-message\", &use_message, \"COMMIT\", \"reuse message from specified commit\"),\n\tOPT_STRING(0, \"fixup\", &fixup_message, \"COMMIT\", \"use autosquash formatted message to fixup specified commit\"),\n\tOPT_STRING(0, \"squash\", &squash_message, \"COMMIT\", \"use autosquash formatted message to squash specified commit\"),\n\tOPT_BOOLEAN(0, \"reset-author\", &renew_authorship, \"the commit is authored by me now (used with -C-c/--amend)\"),\n\tOPT_BOOLEAN('s', \"signoff\", &signoff, \"add Signed-off-by:\"),\n\tOPT_FILENAME('t', \"template\", &template_file, \"use specified template file\"),\n\tOPT_BOOLEAN('e', \"edit\", &edit_flag, \"force edit of commit\"),\n\tOPT_STRING(0, \"cleanup\", &cleanup_arg, \"default\", \"how to strip spaces and #comments from message\"),\n\tOPT_BOOLEAN(0, \"status\", &include_status, \"include status in commit message template\"),\n\t/* end commit message options */\n\n\tOPT_GROUP(\"Commit contents options\"),\n\tOPT_BOOLEAN('a', \"all\", &all, \"commit all changed files\"),\n\tOPT_BOOLEAN('i', \"include\", &also, \"add specified files to index for commit\"),\n\tOPT_BOOLEAN(0, \"interactive\", &interactive, \"interactively add files\"),\n\tOPT_BOOLEAN('o', \"only\", &only, \"commit only specified files\"),\n\tOPT_BOOLEAN('n', \"no-verify\", &no_verify, \"bypass pre-commit hook\"),\n\tOPT_BOOLEAN(0, \"dry-run\", &dry_run, \"show what would be committed\"),\n\tOPT_SET_INT(0, \"short\", &status_format, \"show status concisely\",\n\t\t    STATUS_FORMAT_SHORT),\n\tOPT_BOOLEAN(0, \"branch\", &status_show_branch, \"show branch information\"),\n\tOPT_SET_INT(0, \"porcelain\", &status_format,\n\t\t    \"machine-readable output\", STATUS_FORMAT_PORCELAIN),\n\tOPT_BOOLEAN('z', \"null\", &null_termination,\n\t\t    \"terminate entries with NUL\"),\n\tOPT_BOOLEAN(0, \"amend\", &amend, \"amend previous commit\"),\n\tOPT_BOOLEAN(0, \"no-post-rewrite\", &no_post_rewrite, \"bypass post-rewrite hook\"),\n\t{ OPTION_STRING, 'u', \"untracked-files\", &untracked_files_arg, \"mode\", \"show untracked files, optional modes: all, normal, no (Default: all)\", PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t/* end commit contents options */\n\n\t{ OPTION_BOOLEAN, 0, \"allow-empty\", &allow_empty, NULL,\n\t  \"ok to record an empty change\",\n\t  PARSE_OPT_NOARG | PARSE_OPT_HIDDEN },\n\t{ OPTION_BOOLEAN, 0, \"allow-empty-message\", &allow_empty_message, NULL,\n\t  \"ok to record a change with an empty message\",\n\t  PARSE_OPT_NOARG | PARSE_OPT_HIDDEN },\n\n\tOPT_END()\n};\n\nstatic void rollback_index_files(void)\n{\n\tswitch (commit_style) {\n\tcase COMMIT_AS_IS:\n\t\tbreak; /* nothing to do */\n\tcase COMMIT_NORMAL:\n\t\trollback_lock_file(&index_lock);\n\t\tbreak;\n\tcase COMMIT_PARTIAL:\n\t\trollback_lock_file(&index_lock);\n\t\trollback_lock_file(&false_lock);\n\t\tbreak;\n\t}\n}\n\nstatic int commit_index_files(void)\n{\n\tint err = 0;\n\n\tswitch (commit_style) {\n\tcase COMMIT_AS_IS:\n\t\tbreak; /* nothing to do */\n\tcase COMMIT_NORMAL:\n\t\terr = commit_lock_file(&index_lock);\n\t\tbreak;\n\tcase COMMIT_PARTIAL:\n\t\terr = commit_lock_file(&index_lock);\n\t\trollback_lock_file(&false_lock);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/*\n * Take a union of paths in the index and the named tree (typically, \"HEAD\"),\n * and return the paths that match the given pattern in list.\n */\nstatic int list_paths(struct string_list *list, const char *with_tree,\n\t\t      const char *prefix, const char **pattern)\n{\n\tint i;\n\tchar *m;\n\n\tfor (i = 0; pattern[i]; i++)\n\t\t;\n\tm = xcalloc(1, i);\n\n\tif (with_tree)\n\t\toverlay_tree_on_cache(with_tree, prefix);\n\n\tfor (i = 0; i < active_nr; i++) {\n\t\tstruct cache_entry *ce = active_cache[i];\n\t\tstruct string_list_item *item;\n\n\t\tif (ce->ce_flags & CE_UPDATE)\n\t\t\tcontinue;\n\t\tif (!match_pathspec(pattern, ce->name, ce_namelen(ce), 0, m))\n\t\t\tcontinue;\n\t\titem = string_list_insert(list, ce->name);\n\t\tif (ce_skip_worktree(ce))\n\t\t\titem->util = item; /* better a valid pointer than a fake one */\n\t}\n\n\treturn report_path_error(m, pattern, prefix ? strlen(prefix) : 0);\n}\n\nstatic void add_remove_files(struct string_list *list)\n{\n\tint i;\n\tfor (i = 0; i < list->nr; i++) {\n\t\tstruct stat st;\n\t\tstruct string_list_item *p = &(list->items[i]);\n\n\t\t/* p->util is skip-worktree */\n\t\tif (p->util)\n\t\t\tcontinue;\n\n\t\tif (!lstat(p->string, &st)) {\n\t\t\tif (add_to_cache(p->string, &st, 0))\n\t\t\t\tdie(\"updating files failed\");\n\t\t} else\n\t\t\tremove_file_from_cache(p->string);\n\t}\n}\n\nstatic void create_base_index(void)\n{\n\tstruct tree *tree;\n\tstruct unpack_trees_options opts;\n\tstruct tree_desc t;\n\n\tif (initial_commit) {\n\t\tdiscard_cache();\n\t\treturn;\n\t}\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.head_idx = 1;\n\topts.index_only = 1;\n\topts.merge = 1;\n\topts.src_index = &the_index;\n\topts.dst_index = &the_index;\n\n\topts.fn = oneway_merge;\n\ttree = parse_tree_indirect(head_sha1);\n\tif (!tree)\n\t\tdie(\"failed to unpack HEAD tree object\");\n\tparse_tree(tree);\n\tinit_tree_desc(&t, tree->buffer, tree->size);\n\tif (unpack_trees(1, &t, &opts))\n\t\texit(128); /* We've already reported the error, finish dying */\n}\n\nstatic void refresh_cache_or_die(int refresh_flags)\n{\n\t/*\n\t * refresh_flags contains REFRESH_QUIET, so the only errors\n\t * are for unmerged entries.\n\t */\n\tif (refresh_cache(refresh_flags | REFRESH_IN_PORCELAIN))\n\t\tdie_resolve_conflict(\"commit\");\n}\n\nstatic char *prepare_index(int argc, const char **argv, const char *prefix, int is_status)\n{\n\tint fd;\n\tstruct string_list partial;\n\tconst char **pathspec = NULL;\n\tint refresh_flags = REFRESH_QUIET;\n\n\tif (is_status)\n\t\trefresh_flags |= REFRESH_UNMERGED;\n\tif (interactive) {\n\t\tif (interactive_add(argc, argv, prefix) != 0)\n\t\t\tdie(\"interactive add failed\");\n\t\tif (read_cache_preload(NULL) < 0)\n\t\t\tdie(\"index file corrupt\");\n\t\tcommit_style = COMMIT_AS_IS;\n\t\treturn get_index_file();\n\t}\n\n\tif (*argv)\n\t\tpathspec = get_pathspec(prefix, argv);\n\n\tif (read_cache_preload(pathspec) < 0)\n\t\tdie(\"index file corrupt\");\n\n\t/*\n\t * Non partial, non as-is commit.\n\t *\n\t * (1) get the real index;\n\t * (2) update the_index as necessary;\n\t * (3) write the_index out to the real index (still locked);\n\t * (4) return the name of the locked index file.\n\t *\n\t * The caller should run hooks on the locked real index, and\n\t * (A) if all goes well, commit the real index;\n\t * (B) on failure, rollback the real index.\n\t */\n\tif (all || (also && pathspec && *pathspec)) {\n\t\tfd = hold_locked_index(&index_lock, 1);\n\t\tadd_files_to_cache(also ? prefix : NULL, pathspec, 0);\n\t\trefresh_cache_or_die(refresh_flags);\n\t\tif (write_cache(fd, active_cache, active_nr) ||\n\t\t    close_lock_file(&index_lock))\n\t\t\tdie(\"unable to write new_index file\");\n\t\tcommit_style = COMMIT_NORMAL;\n\t\treturn index_lock.filename;\n\t}\n\n\t/*\n\t * As-is commit.\n\t *\n\t * (1) return the name of the real index file.\n\t *\n\t * The caller should run hooks on the real index,\n\t * and create commit from the_index.\n\t * We still need to refresh the index here.\n\t */\n\tif (!pathspec || !*pathspec) {\n\t\tfd = hold_locked_index(&index_lock, 1);\n\t\trefresh_cache_or_die(refresh_flags);\n\t\tif (active_cache_changed) {\n\t\t\tif (write_cache(fd, active_cache, active_nr) ||\n\t\t\t    commit_locked_index(&index_lock))\n\t\t\t\tdie(\"unable to write new_index file\");\n\t\t} else {\n\t\t\trollback_lock_file(&index_lock);\n\t\t}\n\t\tcommit_style = COMMIT_AS_IS;\n\t\treturn get_index_file();\n\t}\n\n\t/*\n\t * A partial commit.\n\t *\n\t * (0) find the set of affected paths;\n\t * (1) get lock on the real index file;\n\t * (2) update the_index with the given paths;\n\t * (3) write the_index out to the real index (still locked);\n\t * (4) get lock on the false index file;\n\t * (5) reset the_index from HEAD;\n\t * (6) update the_index the same way as (2);\n\t * (7) write the_index out to the false index file;\n\t * (8) return the name of the false index file (still locked);\n\t *\n\t * The caller should run hooks on the locked false index, and\n\t * create commit from it.  Then\n\t * (A) if all goes well, commit the real index;\n\t * (B) on failure, rollback the real index;\n\t * In either case, rollback the false index.\n\t */\n\tcommit_style = COMMIT_PARTIAL;\n\n\tif (in_merge)\n\t\tdie(\"cannot do a partial commit during a merge.\");\n\n\tmemset(&partial, 0, sizeof(partial));\n\tpartial.strdup_strings = 1;\n\tif (list_paths(&partial, initial_commit ? NULL : \"HEAD\", prefix, pathspec))\n\t\texit(1);\n\n\tdiscard_cache();\n\tif (read_cache() < 0)\n\t\tdie(\"cannot read the index\");\n\n\tfd = hold_locked_index(&index_lock, 1);\n\tadd_remove_files(&partial);\n\trefresh_cache(REFRESH_QUIET);\n\tif (write_cache(fd, active_cache, active_nr) ||\n\t    close_lock_file(&index_lock))\n\t\tdie(\"unable to write new_index file\");\n\n\tfd = hold_lock_file_for_update(&false_lock,\n\t\t\t\t       git_path(\"next-index-%\"PRIuMAX,\n\t\t\t\t\t\t(uintmax_t) getpid()),\n\t\t\t\t       LOCK_DIE_ON_ERROR);\n\n\tcreate_base_index();\n\tadd_remove_files(&partial);\n\trefresh_cache(REFRESH_QUIET);\n\n\tif (write_cache(fd, active_cache, active_nr) ||\n\t    close_lock_file(&false_lock))\n\t\tdie(\"unable to write temporary index file\");\n\n\tdiscard_cache();\n\tread_cache_from(false_lock.filename);\n\n\treturn false_lock.filename;\n}\n\nstatic int run_status(FILE *fp, const char *index_file, const char *prefix, int nowarn,\n\t\t      struct wt_status *s)\n{\n\tunsigned char sha1[20];\n\n\tif (s->relative_paths)\n\t\ts->prefix = prefix;\n\n\tif (amend) {\n\t\ts->amend = 1;\n\t\ts->reference = \"HEAD^1\";\n\t}\n\ts->verbose = verbose;\n\ts->index_file = index_file;\n\ts->fp = fp;\n\ts->nowarn = nowarn;\n\ts->is_initial = get_sha1(s->reference, sha1) ? 1 : 0;\n\n\twt_status_collect(s);\n\n\tswitch (status_format) {\n\tcase STATUS_FORMAT_SHORT:\n\t\twt_shortstatus_print(s, null_termination, status_show_branch);\n\t\tbreak;\n\tcase STATUS_FORMAT_PORCELAIN:\n\t\twt_porcelain_print(s, null_termination);\n\t\tbreak;\n\tcase STATUS_FORMAT_LONG:\n\t\twt_status_print(s);\n\t\tbreak;\n\t}\n\n\treturn s->commitable;\n}\n\nstatic int is_a_merge(const unsigned char *sha1)\n{\n\tstruct commit *commit = lookup_commit(sha1);\n\tif (!commit || parse_commit(commit))\n\t\tdie(\"could not parse HEAD commit\");\n\treturn !!(commit->parents && commit->parents->next);\n}\n\nstatic const char sign_off_header[] = \"Signed-off-by: \";\n\nstatic void determine_author_info(struct strbuf *author_ident)\n{\n\tchar *name, *email, *date;\n\n\tname = getenv(\"GIT_AUTHOR_NAME\");\n\temail = getenv(\"GIT_AUTHOR_EMAIL\");\n\tdate = getenv(\"GIT_AUTHOR_DATE\");\n\n\tif (use_message && !renew_authorship) {\n\t\tconst char *a, *lb, *rb, *eol;\n\n\t\ta = strstr(use_message_buffer, \"\\nauthor \");\n\t\tif (!a)\n\t\t\tdie(\"invalid commit: %s\", use_message);\n\n\t\tlb = strchrnul(a + strlen(\"\\nauthor \"), '<');\n\t\trb = strchrnul(lb, '>');\n\t\teol = strchrnul(rb, '\\n');\n\t\tif (!*lb || !*rb || !*eol)\n\t\t\tdie(\"invalid commit: %s\", use_message);\n\n\t\tif (lb == a + strlen(\"\\nauthor \"))\n\t\t\t/* \\nauthor <foo@example.com> */\n\t\t\tname = xcalloc(1, 1);\n\t\telse\n\t\t\tname = xmemdupz(a + strlen(\"\\nauthor \"),\n\t\t\t\t\t(lb - strlen(\" \") -\n\t\t\t\t\t (a + strlen(\"\\nauthor \"))));\n\t\temail = xmemdupz(lb + strlen(\"<\"), rb - (lb + strlen(\"<\")));\n\t\tdate = xmemdupz(rb + strlen(\"> \"), eol - (rb + strlen(\"> \")));\n\t}\n\n\tif (force_author) {\n\t\tconst char *lb = strstr(force_author, \" <\");\n\t\tconst char *rb = strchr(force_author, '>');\n\n\t\tif (!lb || !rb)\n\t\t\tdie(\"malformed --author parameter\");\n\t\tname = xstrndup(force_author, lb - force_author);\n\t\temail = xstrndup(lb + 2, rb - (lb + 2));\n\t}\n\n\tif (force_date)\n\t\tdate = force_date;\n\tstrbuf_addstr(author_ident, fmt_ident(name, email, date,\n\t\t\t\t\t      IDENT_ERROR_ON_NO_NAME));\n}\n\nstatic int ends_rfc2822_footer(struct strbuf *sb)\n{\n\tint ch;\n\tint hit = 0;\n\tint i, j, k;\n\tint len = sb->len;\n\tint first = 1;\n\tconst char *buf = sb->buf;\n\n\tfor (i = len - 1; i > 0; i--) {\n\t\tif (hit && buf[i] == '\\n')\n\t\t\tbreak;\n\t\thit = (buf[i] == '\\n');\n\t}\n\n\twhile (i < len - 1 && buf[i] == '\\n')\n\t\ti++;\n\n\tfor (; i < len; i = k) {\n\t\tfor (k = i; k < len && buf[k] != '\\n'; k++)\n\t\t\t; /* do nothing */\n\t\tk++;\n\n\t\tif ((buf[k] == ' ' || buf[k] == '\\t') && !first)\n\t\t\tcontinue;\n\n\t\tfirst = 0;\n\n\t\tfor (j = 0; i + j < len; j++) {\n\t\t\tch = buf[i + j];\n\t\t\tif (ch == ':')\n\t\t\t\tbreak;\n\t\t\tif (isalnum(ch) ||\n\t\t\t    (ch == '-'))\n\t\t\t\tcontinue;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic char *cut_ident_timestamp_part(char *string)\n{\n\tchar *ket = strrchr(string, '>');\n\tif (!ket || ket[1] != ' ')\n\t\tdie(\"Malformed ident string: '%s'\", string);\n\t*++ket = '\\0';\n\treturn ket;\n}\n\nstatic int prepare_to_commit(const char *index_file, const char *prefix,\n\t\t\t     struct wt_status *s,\n\t\t\t     struct strbuf *author_ident)\n{\n\tstruct stat statbuf;\n\tstruct strbuf committer_ident = STRBUF_INIT;\n\tint commitable, saved_color_setting;\n\tstruct strbuf sb = STRBUF_INIT;\n\tchar *buffer;\n\tFILE *fp;\n\tconst char *hook_arg1 = NULL;\n\tconst char *hook_arg2 = NULL;\n\tint ident_shown = 0;\n\n\tif (!no_verify && run_hook(index_file, \"pre-commit\", NULL))\n\t\treturn 0;\n\n\tif (squash_message) {\n\t\t/*\n\t\t * Insert the proper subject line before other commit\n\t\t * message options add their content.\n\t\t */\n\t\tif (use_message && !strcmp(use_message, squash_message))\n\t\t\tstrbuf_addstr(&sb, \"squash! \");\n\t\telse {\n\t\t\tstruct pretty_print_context ctx = {0};\n\t\t\tstruct commit *c;\n\t\t\tc = lookup_commit_reference_by_name(squash_message);\n\t\t\tif (!c)\n\t\t\t\tdie(\"could not lookup commit %s\", squash_message);\n\t\t\tctx.output_encoding = get_commit_output_encoding();\n\t\t\tformat_commit_message(c, \"squash! %s\\n\\n\", &sb,\n\t\t\t\t\t      &ctx);\n\t\t}\n\t}\n\n\tif (message.len) {\n\t\tstrbuf_addbuf(&sb, &message);\n\t\thook_arg1 = \"message\";\n\t} else if (logfile && !strcmp(logfile, \"-\")) {\n\t\tif (isatty(0))\n\t\t\tfprintf(stderr, \"(reading log message from standard input)\\n\");\n\t\tif (strbuf_read(&sb, 0, 0) < 0)\n\t\t\tdie_errno(\"could not read log from standard input\");\n\t\thook_arg1 = \"message\";\n\t} else if (logfile) {\n\t\tif (strbuf_read_file(&sb, logfile, 0) < 0)\n\t\t\tdie_errno(\"could not read log file '%s'\",\n\t\t\t\t  logfile);\n\t\thook_arg1 = \"message\";\n\t} else if (use_message) {\n\t\tbuffer = strstr(use_message_buffer, \"\\n\\n\");\n\t\tif (!buffer || buffer[2] == '\\0')\n\t\t\tdie(\"commit has empty message\");\n\t\tstrbuf_add(&sb, buffer + 2, strlen(buffer + 2));\n\t\thook_arg1 = \"commit\";\n\t\thook_arg2 = use_message;\n\t} else if (fixup_message) {\n\t\tstruct pretty_print_context ctx = {0};\n\t\tstruct commit *commit;\n\t\tcommit = lookup_commit_reference_by_name(fixup_message);\n\t\tif (!commit)\n\t\t\tdie(\"could not lookup commit %s\", fixup_message);\n\t\tctx.output_encoding = get_commit_output_encoding();\n\t\tformat_commit_message(commit, \"fixup! %s\\n\\n\",\n\t\t\t\t      &sb, &ctx);\n\t\thook_arg1 = \"message\";\n\t} else if (!stat(git_path(\"MERGE_MSG\"), &statbuf)) {\n\t\tif (strbuf_read_file(&sb, git_path(\"MERGE_MSG\"), 0) < 0)\n\t\t\tdie_errno(\"could not read MERGE_MSG\");\n\t\thook_arg1 = \"merge\";\n\t} else if (!stat(git_path(\"SQUASH_MSG\"), &statbuf)) {\n\t\tif (strbuf_read_file(&sb, git_path(\"SQUASH_MSG\"), 0) < 0)\n\t\t\tdie_errno(\"could not read SQUASH_MSG\");\n\t\thook_arg1 = \"squash\";\n\t} else if (template_file && !stat(template_file, &statbuf)) {\n\t\tif (strbuf_read_file(&sb, template_file, 0) < 0)\n\t\t\tdie_errno(\"could not read '%s'\", template_file);\n\t\thook_arg1 = \"template\";\n\t}\n\n\t/*\n\t * This final case does not modify the template message,\n\t * it just sets the argument to the prepare-commit-msg hook.\n\t */\n\telse if (in_merge)\n\t\thook_arg1 = \"merge\";\n\n\tif (squash_message) {\n\t\t/*\n\t\t * If squash_commit was used for the commit subject,\n\t\t * then we're possibly hijacking other commit log options.\n\t\t * Reset the hook args to tell the real story.\n\t\t */\n\t\thook_arg1 = \"message\";\n\t\thook_arg2 = \"\";\n\t}\n\n\tfp = fopen(git_path(commit_editmsg), \"w\");\n\tif (fp == NULL)\n\t\tdie_errno(\"could not open '%s'\", git_path(commit_editmsg));\n\n\tif (cleanup_mode != CLEANUP_NONE)\n\t\tstripspace(&sb, 0);\n\n\tif (signoff) {\n\t\tstruct strbuf sob = STRBUF_INIT;\n\t\tint i;\n\n\t\tstrbuf_addstr(&sob, sign_off_header);\n\t\tstrbuf_addstr(&sob, fmt_name(getenv(\"GIT_COMMITTER_NAME\"),\n\t\t\t\t\t     getenv(\"GIT_COMMITTER_EMAIL\")));\n\t\tstrbuf_addch(&sob, '\\n');\n\t\tfor (i = sb.len - 1; i > 0 && sb.buf[i - 1] != '\\n'; i--)\n\t\t\t; /* do nothing */\n\t\tif (prefixcmp(sb.buf + i, sob.buf)) {\n\t\t\tif (!i || !ends_rfc2822_footer(&sb))\n\t\t\t\tstrbuf_addch(&sb, '\\n');\n\t\t\tstrbuf_addbuf(&sb, &sob);\n\t\t}\n\t\tstrbuf_release(&sob);\n\t}\n\n\tif (fwrite(sb.buf, 1, sb.len, fp) < sb.len)\n\t\tdie_errno(\"could not write commit template\");\n\n\tstrbuf_release(&sb);\n\n\t/* This checks and barfs if author is badly specified */\n\tdetermine_author_info(author_ident);\n\n\t/* This checks if committer ident is explicitly given */\n\tstrbuf_addstr(&committer_ident, git_committer_info(0));\n\tif (use_editor && include_status) {\n\t\tchar *ai_tmp, *ci_tmp;\n\t\tif (in_merge)\n\t\t\tfprintf(fp,\n\t\t\t\t\"#\\n\"\n\t\t\t\t\"# It looks like you may be committing a MERGE.\\n\"\n\t\t\t\t\"# If this is not correct, please remove the file\\n\"\n\t\t\t\t\"#\t%s\\n\"\n\t\t\t\t\"# and try again.\\n\"\n\t\t\t\t\"#\\n\",\n\t\t\t\tgit_path(\"MERGE_HEAD\"));\n\n\t\tfprintf(fp,\n\t\t\t\"\\n\"\n\t\t\t\"# Please enter the commit message for your changes.\");\n\t\tif (cleanup_mode == CLEANUP_ALL)\n\t\t\tfprintf(fp,\n\t\t\t\t\" Lines starting\\n\"\n\t\t\t\t\"# with '#' will be ignored, and an empty\"\n\t\t\t\t\" message aborts the commit.\\n\");\n\t\telse /* CLEANUP_SPACE, that is. */\n\t\t\tfprintf(fp,\n\t\t\t\t\" Lines starting\\n\"\n\t\t\t\t\"# with '#' will be kept; you may remove them\"\n\t\t\t\t\" yourself if you want to.\\n\"\n\t\t\t\t\"# An empty message aborts the commit.\\n\");\n\t\tif (only_include_assumed)\n\t\t\tfprintf(fp, \"# %s\\n\", only_include_assumed);\n\n\t\tai_tmp = cut_ident_timestamp_part(author_ident->buf);\n\t\tci_tmp = cut_ident_timestamp_part(committer_ident.buf);\n\t\tif (strcmp(author_ident->buf, committer_ident.buf))\n\t\t\tfprintf(fp,\n\t\t\t\t\"%s\"\n\t\t\t\t\"# Author:    %s\\n\",\n\t\t\t\tident_shown++ ? \"\" : \"#\\n\",\n\t\t\t\tauthor_ident->buf);\n\n\t\tif (!user_ident_sufficiently_given())\n\t\t\tfprintf(fp,\n\t\t\t\t\"%s\"\n\t\t\t\t\"# Committer: %s\\n\",\n\t\t\t\tident_shown++ ? \"\" : \"#\\n\",\n\t\t\t\tcommitter_ident.buf);\n\n\t\tif (ident_shown)\n\t\t\tfprintf(fp, \"#\\n\");\n\n\t\tsaved_color_setting = s->use_color;\n\t\ts->use_color = 0;\n\t\tcommitable = run_status(fp, index_file, prefix, 1, s);\n\t\ts->use_color = saved_color_setting;\n\n\t\t*ai_tmp = ' ';\n\t\t*ci_tmp = ' ';\n\t} else {\n\t\tunsigned char sha1[20];\n\t\tconst char *parent = \"HEAD\";\n\n\t\tif (!active_nr && read_cache() < 0)\n\t\t\tdie(\"Cannot read index\");\n\n\t\tif (amend)\n\t\t\tparent = \"HEAD^1\";\n\n\t\tif (get_sha1(parent, sha1))\n\t\t\tcommitable = !!active_nr;\n\t\telse\n\t\t\tcommitable = index_differs_from(parent, 0);\n\t}\n\tstrbuf_release(&committer_ident);\n\n\tfclose(fp);\n\n\tif (!commitable && !in_merge && !allow_empty &&\n\t    !(amend && is_a_merge(head_sha1))) {\n\t\trun_status(stdout, index_file, prefix, 0, s);\n\t\tif (amend)\n\t\t\tfputs(empty_amend_advice, stderr);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Re-read the index as pre-commit hook could have updated it,\n\t * and write it out as a tree.  We must do this before we invoke\n\t * the editor and after we invoke run_status above.\n\t */\n\tdiscard_cache();\n\tread_cache_from(index_file);\n\tif (!active_cache_tree)\n\t\tactive_cache_tree = cache_tree();\n\tif (cache_tree_update(active_cache_tree,\n\t\t\t      active_cache, active_nr, 0, 0) < 0) {\n\t\terror(\"Error building trees\");\n\t\treturn 0;\n\t}\n\n\tif (run_hook(index_file, \"prepare-commit-msg\",\n\t\t     git_path(commit_editmsg), hook_arg1, hook_arg2, NULL))\n\t\treturn 0;\n\n\tif (use_editor) {\n\t\tchar index[PATH_MAX];\n\t\tconst char *env[2] = { NULL };\n\t\tenv[0] =  index;\n\t\tsnprintf(index, sizeof(index), \"GIT_INDEX_FILE=%s\", index_file);\n\t\tif (launch_editor(git_path(commit_editmsg), NULL, env)) {\n\t\t\tfprintf(stderr,\n\t\t\t\"Please supply the message using either -m or -F option.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (!no_verify &&\n\t    run_hook(index_file, \"commit-msg\", git_path(commit_editmsg), NULL)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/*\n * Find out if the message in the strbuf contains only whitespace and\n * Signed-off-by lines.\n */\nstatic int message_is_empty(struct strbuf *sb)\n{\n\tstruct strbuf tmpl = STRBUF_INIT;\n\tconst char *nl;\n\tint eol, i, start = 0;\n\n\tif (cleanup_mode == CLEANUP_NONE && sb->len)\n\t\treturn 0;\n\n\t/* See if the template is just a prefix of the message. */\n\tif (template_file && strbuf_read_file(&tmpl, template_file, 0) > 0) {\n\t\tstripspace(&tmpl, cleanup_mode == CLEANUP_ALL);\n\t\tif (start + tmpl.len <= sb->len &&\n\t\t    memcmp(tmpl.buf, sb->buf + start, tmpl.len) == 0)\n\t\t\tstart += tmpl.len;\n\t}\n\tstrbuf_release(&tmpl);\n\n\t/* Check if the rest is just whitespace and Signed-of-by's. */\n\tfor (i = start; i < sb->len; i++) {\n\t\tnl = memchr(sb->buf + i, '\\n', sb->len - i);\n\t\tif (nl)\n\t\t\teol = nl - sb->buf;\n\t\telse\n\t\t\teol = sb->len;\n\n\t\tif (strlen(sign_off_header) <= eol - i &&\n\t\t    !prefixcmp(sb->buf + i, sign_off_header)) {\n\t\t\ti = eol;\n\t\t\tcontinue;\n\t\t}\n\t\twhile (i < eol)\n\t\t\tif (!isspace(sb->buf[i++]))\n\t\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic const char *find_author_by_nickname(const char *name)\n{\n\tstruct rev_info revs;\n\tstruct commit *commit;\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *av[20];\n\tint ac = 0;\n\n\tinit_revisions(&revs, NULL);\n\tstrbuf_addf(&buf, \"--author=%s\", name);\n\tav[++ac] = \"--all\";\n\tav[++ac] = \"-i\";\n\tav[++ac] = buf.buf;\n\tav[++ac] = NULL;\n\tsetup_revisions(ac, av, &revs, NULL);\n\tprepare_revision_walk(&revs);\n\tcommit = get_revision(&revs);\n\tif (commit) {\n\t\tstruct pretty_print_context ctx = {0};\n\t\tctx.date_mode = DATE_NORMAL;\n\t\tstrbuf_release(&buf);\n\t\tformat_commit_message(commit, \"%an <%ae>\", &buf, &ctx);\n\t\treturn strbuf_detach(&buf, NULL);\n\t}\n\tdie(\"No existing author found with '%s'\", name);\n}\n\n\nstatic void handle_untracked_files_arg(struct wt_status *s)\n{\n\tif (!untracked_files_arg)\n\t\t; /* default already initialized */\n\telse if (!strcmp(untracked_files_arg, \"no\"))\n\t\ts->show_untracked_files = SHOW_NO_UNTRACKED_FILES;\n\telse if (!strcmp(untracked_files_arg, \"normal\"))\n\t\ts->show_untracked_files = SHOW_NORMAL_UNTRACKED_FILES;\n\telse if (!strcmp(untracked_files_arg, \"all\"))\n\t\ts->show_untracked_files = SHOW_ALL_UNTRACKED_FILES;\n\telse\n\t\tdie(\"Invalid untracked files mode '%s'\", untracked_files_arg);\n}\n\nstatic int parse_and_validate_options(int argc, const char *argv[],\n\t\t\t\t      const char * const usage[],\n\t\t\t\t      const char *prefix,\n\t\t\t\t      struct wt_status *s)\n{\n\tint f = 0;\n\n\targc = parse_options(argc, argv, prefix, builtin_commit_options, usage,\n\t\t\t     0);\n\n\tif (force_author && !strchr(force_author, '>'))\n\t\tforce_author = find_author_by_nickname(force_author);\n\n\tif (force_author && renew_authorship)\n\t\tdie(\"Using both --reset-author and --author does not make sense\");\n\n\tif (logfile || message.len || use_message || fixup_message)\n\t\tuse_editor = 0;\n\tif (edit_flag)\n\t\tuse_editor = 1;\n\tif (!use_editor)\n\t\tsetenv(\"GIT_EDITOR\", \":\", 1);\n\n\tif (get_sha1(\"HEAD\", head_sha1))\n\t\tinitial_commit = 1;\n\n\t/* Sanity check options */\n\tif (amend && initial_commit)\n\t\tdie(\"You have nothing to amend.\");\n\tif (amend && in_merge)\n\t\tdie(\"You are in the middle of a merge -- cannot amend.\");\n\tif (fixup_message && squash_message)\n\t\tdie(\"Options --squash and --fixup cannot be used together\");\n\tif (use_message)\n\t\tf++;\n\tif (edit_message)\n\t\tf++;\n\tif (fixup_message)\n\t\tf++;\n\tif (logfile)\n\t\tf++;\n\tif (f > 1)\n\t\tdie(\"Only one of -c/-C/-F/--fixup can be used.\");\n\tif (message.len && f > 0)\n\t\tdie(\"Option -m cannot be combined with -c/-C/-F/--fixup.\");\n\tif (edit_message)\n\t\tuse_message = edit_message;\n\tif (amend && !use_message && !fixup_message)\n\t\tuse_message = \"HEAD\";\n\tif (!use_message && renew_authorship)\n\t\tdie(\"--reset-author can be used only with -C, -c or --amend.\");\n\tif (use_message) {\n\t\tconst char *out_enc;\n\t\tstruct commit *commit;\n\n\t\tcommit = lookup_commit_reference_by_name(use_message);\n\t\tif (!commit)\n\t\t\tdie(\"could not lookup commit %s\", use_message);\n\t\tout_enc = get_commit_output_encoding();\n\t\tuse_message_buffer = logmsg_reencode(commit, out_enc);\n\n\t\t/*\n\t\t * If we failed to reencode the buffer, just copy it\n\t\t * byte for byte so the user can try to fix it up.\n\t\t * This also handles the case where input and output\n\t\t * encodings are identical.\n\t\t */\n\t\tif (use_message_buffer == NULL)\n\t\t\tuse_message_buffer = xstrdup(commit->buffer);\n\t}\n\n\tif (!!also + !!only + !!all + !!interactive > 1)\n\t\tdie(\"Only one of --include/--only/--all/--interactive can be used.\");\n\tif (argc == 0 && (also || (only && !amend)))\n\t\tdie(\"No paths with --include/--only does not make sense.\");\n\tif (argc == 0 && only && amend)\n\t\tonly_include_assumed = \"Clever... amending the last one with dirty index.\";\n\tif (argc > 0 && !also && !only)\n\t\tonly_include_assumed = \"Explicit paths specified without -i nor -o; assuming --only paths...\";\n\tif (!cleanup_arg || !strcmp(cleanup_arg, \"default\"))\n\t\tcleanup_mode = use_editor ? CLEANUP_ALL : CLEANUP_SPACE;\n\telse if (!strcmp(cleanup_arg, \"verbatim\"))\n\t\tcleanup_mode = CLEANUP_NONE;\n\telse if (!strcmp(cleanup_arg, \"whitespace\"))\n\t\tcleanup_mode = CLEANUP_SPACE;\n\telse if (!strcmp(cleanup_arg, \"strip\"))\n\t\tcleanup_mode = CLEANUP_ALL;\n\telse\n\t\tdie(\"Invalid cleanup mode %s\", cleanup_arg);\n\n\thandle_untracked_files_arg(s);\n\n\tif (all && argc > 0)\n\t\tdie(\"Paths with -a does not make sense.\");\n\telse if (interactive && argc > 0)\n\t\tdie(\"Paths with --interactive does not make sense.\");\n\n\tif (null_termination && status_format == STATUS_FORMAT_LONG)\n\t\tstatus_format = STATUS_FORMAT_PORCELAIN;\n\tif (status_format != STATUS_FORMAT_LONG)\n\t\tdry_run = 1;\n\n\treturn argc;\n}\n\nstatic int dry_run_commit(int argc, const char **argv, const char *prefix,\n\t\t\t  struct wt_status *s)\n{\n\tint commitable;\n\tconst char *index_file;\n\n\tindex_file = prepare_index(argc, argv, prefix, 1);\n\tcommitable = run_status(stdout, index_file, prefix, 0, s);\n\trollback_index_files();\n\n\treturn commitable ? 0 : 1;\n}\n\nstatic int parse_status_slot(const char *var, int offset)\n{\n\tif (!strcasecmp(var+offset, \"header\"))\n\t\treturn WT_STATUS_HEADER;\n\tif (!strcasecmp(var+offset, \"branch\"))\n\t\treturn WT_STATUS_ONBRANCH;\n\tif (!strcasecmp(var+offset, \"updated\")\n\t\t|| !strcasecmp(var+offset, \"added\"))\n\t\treturn WT_STATUS_UPDATED;\n\tif (!strcasecmp(var+offset, \"changed\"))\n\t\treturn WT_STATUS_CHANGED;\n\tif (!strcasecmp(var+offset, \"untracked\"))\n\t\treturn WT_STATUS_UNTRACKED;\n\tif (!strcasecmp(var+offset, \"nobranch\"))\n\t\treturn WT_STATUS_NOBRANCH;\n\tif (!strcasecmp(var+offset, \"unmerged\"))\n\t\treturn WT_STATUS_UNMERGED;\n\treturn -1;\n}\n\nstatic int git_status_config(const char *k, const char *v, void *cb)\n{\n\tstruct wt_status *s = cb;\n\n\tif (!strcmp(k, \"status.submodulesummary\")) {\n\t\tint is_bool;\n\t\ts->submodule_summary = git_config_bool_or_int(k, v, &is_bool);\n\t\tif (is_bool && s->submodule_summary)\n\t\t\ts->submodule_summary = -1;\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.color\") || !strcmp(k, \"color.status\")) {\n\t\ts->use_color = git_config_colorbool(k, v, -1);\n\t\treturn 0;\n\t}\n\tif (!prefixcmp(k, \"status.color.\") || !prefixcmp(k, \"color.status.\")) {\n\t\tint slot = parse_status_slot(k, 13);\n\t\tif (slot < 0)\n\t\t\treturn 0;\n\t\tif (!v)\n\t\t\treturn config_error_nonbool(k);\n\t\tcolor_parse(v, k, s->color_palette[slot]);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.relativepaths\")) {\n\t\ts->relative_paths = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.showuntrackedfiles\")) {\n\t\tif (!v)\n\t\t\treturn config_error_nonbool(k);\n\t\telse if (!strcmp(v, \"no\"))\n\t\t\ts->show_untracked_files = SHOW_NO_UNTRACKED_FILES;\n\t\telse if (!strcmp(v, \"normal\"))\n\t\t\ts->show_untracked_files = SHOW_NORMAL_UNTRACKED_FILES;\n\t\telse if (!strcmp(v, \"all\"))\n\t\t\ts->show_untracked_files = SHOW_ALL_UNTRACKED_FILES;\n\t\telse\n\t\t\treturn error(\"Invalid untracked files mode '%s'\", v);\n\t\treturn 0;\n\t}\n\treturn git_diff_ui_config(k, v, NULL);\n}\n\nint cmd_status(int argc, const char **argv, const char *prefix)\n{\n\tstruct wt_status s;\n\tint fd;\n\tunsigned char sha1[20];\n\tstatic struct option builtin_status_options[] = {\n\t\tOPT__VERBOSE(&verbose, \"be verbose\"),\n\t\tOPT_SET_INT('s', \"short\", &status_format,\n\t\t\t    \"show status concisely\", STATUS_FORMAT_SHORT),\n\t\tOPT_BOOLEAN('b', \"branch\", &status_show_branch,\n\t\t\t    \"show branch information\"),\n\t\tOPT_SET_INT(0, \"porcelain\", &status_format,\n\t\t\t    \"machine-readable output\",\n\t\t\t    STATUS_FORMAT_PORCELAIN),\n\t\tOPT_BOOLEAN('z', \"null\", &null_termination,\n\t\t\t    \"terminate entries with NUL\"),\n\t\t{ OPTION_STRING, 'u', \"untracked-files\", &untracked_files_arg,\n\t\t  \"mode\",\n\t\t  \"show untracked files, optional modes: all, normal, no. (Default: all)\",\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\tOPT_BOOLEAN(0, \"ignored\", &show_ignored_in_status,\n\t\t\t    \"show ignored files\"),\n\t\t{ OPTION_STRING, 0, \"ignore-submodules\", &ignore_submodule_arg, \"when\",\n\t\t  \"ignore changes to submodules, optional when: all, dirty, untracked. (Default: all)\",\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\tOPT_END(),\n\t};\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_status_usage, builtin_status_options);\n\n\tif (null_termination && status_format == STATUS_FORMAT_LONG)\n\t\tstatus_format = STATUS_FORMAT_PORCELAIN;\n\n\twt_status_prepare(&s);\n\tgitmodules_config();\n\tgit_config(git_status_config, &s);\n\tin_merge = file_exists(git_path(\"MERGE_HEAD\"));\n\targc = parse_options(argc, argv, prefix,\n\t\t\t     builtin_status_options,\n\t\t\t     builtin_status_usage, 0);\n\thandle_untracked_files_arg(&s);\n\tif (show_ignored_in_status)\n\t\ts.show_ignored_files = 1;\n\tif (*argv)\n\t\ts.pathspec = get_pathspec(prefix, argv);\n\n\tread_cache_preload(s.pathspec);\n\trefresh_index(&the_index, REFRESH_QUIET|REFRESH_UNMERGED, s.pathspec, NULL, NULL);\n\n\tfd = hold_locked_index(&index_lock, 0);\n\tif (0 <= fd) {\n\t\tif (active_cache_changed &&\n\t\t    !write_cache(fd, active_cache, active_nr))\n\t\t\tcommit_locked_index(&index_lock);\n\t\telse\n\t\t\trollback_lock_file(&index_lock);\n\t}\n\n\ts.is_initial = get_sha1(s.reference, sha1) ? 1 : 0;\n\ts.in_merge = in_merge;\n\ts.ignore_submodule_arg = ignore_submodule_arg;\n\twt_status_collect(&s);\n\n\tif (s.relative_paths)\n\t\ts.prefix = prefix;\n\tif (s.use_color == -1)\n\t\ts.use_color = git_use_color_default;\n\tif (diff_use_color_default == -1)\n\t\tdiff_use_color_default = git_use_color_default;\n\n\tswitch (status_format) {\n\tcase STATUS_FORMAT_SHORT:\n\t\twt_shortstatus_print(&s, null_termination, status_show_branch);\n\t\tbreak;\n\tcase STATUS_FORMAT_PORCELAIN:\n\t\twt_porcelain_print(&s, null_termination);\n\t\tbreak;\n\tcase STATUS_FORMAT_LONG:\n\t\ts.verbose = verbose;\n\t\ts.ignore_submodule_arg = ignore_submodule_arg;\n\t\twt_status_print(&s);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void print_summary(const char *prefix, const unsigned char *sha1)\n{\n\tstruct rev_info rev;\n\tstruct commit *commit;\n\tstruct strbuf format = STRBUF_INIT;\n\tunsigned char junk_sha1[20];\n\tconst char *head = resolve_ref(\"HEAD\", junk_sha1, 0, NULL);\n\tstruct pretty_print_context pctx = {0};\n\tstruct strbuf author_ident = STRBUF_INIT;\n\tstruct strbuf committer_ident = STRBUF_INIT;\n\n\tcommit = lookup_commit(sha1);\n\tif (!commit)\n\t\tdie(\"couldn't look up newly created commit\");\n\tif (!commit || parse_commit(commit))\n\t\tdie(\"could not parse newly created commit\");\n\n\tstrbuf_addstr(&format, \"format:%h] %s\");\n\n\tformat_commit_message(commit, \"%an <%ae>\", &author_ident, &pctx);\n\tformat_commit_message(commit, \"%cn <%ce>\", &committer_ident, &pctx);\n\tif (strbuf_cmp(&author_ident, &committer_ident)) {\n\t\tstrbuf_addstr(&format, \"\\n Author: \");\n\t\tstrbuf_addbuf_percentquote(&format, &author_ident);\n\t}\n\tif (!user_ident_sufficiently_given()) {\n\t\tstrbuf_addstr(&format, \"\\n Committer: \");\n\t\tstrbuf_addbuf_percentquote(&format, &committer_ident);\n\t\tif (advice_implicit_identity) {\n\t\t\tstrbuf_addch(&format, '\\n');\n\t\t\tstrbuf_addstr(&format, implicit_ident_advice);\n\t\t}\n\t}\n\tstrbuf_release(&author_ident);\n\tstrbuf_release(&committer_ident);\n\n\tinit_revisions(&rev, prefix);\n\tsetup_revisions(0, NULL, &rev, NULL);\n\n\trev.diff = 1;\n\trev.diffopt.output_format =\n\t\tDIFF_FORMAT_SHORTSTAT | DIFF_FORMAT_SUMMARY;\n\n\trev.verbose_header = 1;\n\trev.show_root_diff = 1;\n\tget_commit_format(format.buf, &rev);\n\trev.always_show_header = 0;\n\trev.diffopt.detect_rename = 1;\n\trev.diffopt.rename_limit = 100;\n\trev.diffopt.break_opt = 0;\n\tdiff_setup_done(&rev.diffopt);\n\n\tprintf(\"[%s%s \",\n\t\t!prefixcmp(head, \"refs/heads/\") ?\n\t\t\thead + 11 :\n\t\t\t!strcmp(head, \"HEAD\") ?\n\t\t\t\t\"detached HEAD\" :\n\t\t\t\thead,\n\t\tinitial_commit ? \" (root-commit)\" : \"\");\n\n\tif (!log_tree_commit(&rev, commit)) {\n\t\trev.always_show_header = 1;\n\t\trev.use_terminator = 1;\n\t\tlog_tree_commit(&rev, commit);\n\t}\n\n\tstrbuf_release(&format);\n}\n\nstatic int git_commit_config(const char *k, const char *v, void *cb)\n{\n\tstruct wt_status *s = cb;\n\n\tif (!strcmp(k, \"commit.template\"))\n\t\treturn git_config_pathname(&template_file, k, v);\n\tif (!strcmp(k, \"commit.status\")) {\n\t\tinclude_status = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\n\treturn git_status_config(k, v, s);\n}\n\nstatic const char post_rewrite_hook[] = \"hooks/post-rewrite\";\n\nstatic int run_rewrite_hook(const unsigned char *oldsha1,\n\t\t\t    const unsigned char *newsha1)\n{\n\t/* oldsha1 SP newsha1 LF NUL */\n\tstatic char buf[2*40 + 3];\n\tstruct child_process proc;\n\tconst char *argv[3];\n\tint code;\n\tsize_t n;\n\n\tif (access(git_path(post_rewrite_hook), X_OK) < 0)\n\t\treturn 0;\n\n\targv[0] = git_path(post_rewrite_hook);\n\targv[1] = \"amend\";\n\targv[2] = NULL;\n\n\tmemset(&proc, 0, sizeof(proc));\n\tproc.argv = argv;\n\tproc.in = -1;\n\tproc.stdout_to_stderr = 1;\n\n\tcode = start_command(&proc);\n\tif (code)\n\t\treturn code;\n\tn = snprintf(buf, sizeof(buf), \"%s %s\\n\",\n\t\t     sha1_to_hex(oldsha1), sha1_to_hex(newsha1));\n\twrite_in_full(proc.in, buf, n);\n\tclose(proc.in);\n\treturn finish_command(&proc);\n}\n\nint cmd_commit(int argc, const char **argv, const char *prefix)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tstruct strbuf author_ident = STRBUF_INIT;\n\tconst char *index_file, *reflog_msg;\n\tchar *nl, *p;\n\tunsigned char commit_sha1[20];\n\tstruct ref_lock *ref_lock;\n\tstruct commit_list *parents = NULL, **pptr = &parents;\n\tstruct stat statbuf;\n\tint allow_fast_forward = 1;\n\tstruct wt_status s;\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_commit_usage, builtin_commit_options);\n\n\twt_status_prepare(&s);\n\tgit_config(git_commit_config, &s);\n\tin_merge = file_exists(git_path(\"MERGE_HEAD\"));\n\ts.in_merge = in_merge;\n\n\tif (s.use_color == -1)\n\t\ts.use_color = git_use_color_default;\n\targc = parse_and_validate_options(argc, argv, builtin_commit_usage,\n\t\t\t\t\t  prefix, &s);\n\tif (dry_run) {\n\t\tif (diff_use_color_default == -1)\n\t\t\tdiff_use_color_default = git_use_color_default;\n\t\treturn dry_run_commit(argc, argv, prefix, &s);\n\t}\n\tindex_file = prepare_index(argc, argv, prefix, 0);\n\n\t/* Set up everything for writing the commit object.  This includes\n\t   running hooks, writing the trees, and interacting with the user.  */\n\tif (!prepare_to_commit(index_file, prefix, &s, &author_ident)) {\n\t\trollback_index_files();\n\t\treturn 1;\n\t}\n\n\t/* Determine parents */\n\treflog_msg = getenv(\"GIT_REFLOG_ACTION\");\n\tif (initial_commit) {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (initial)\";\n\t} else if (amend) {\n\t\tstruct commit_list *c;\n\t\tstruct commit *commit;\n\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (amend)\";\n\t\tcommit = lookup_commit(head_sha1);\n\t\tif (!commit || parse_commit(commit))\n\t\t\tdie(\"could not parse HEAD commit\");\n\n\t\tfor (c = commit->parents; c; c = c->next)\n\t\t\tpptr = &commit_list_insert(c->item, pptr)->next;\n\t} else if (in_merge) {\n\t\tstruct strbuf m = STRBUF_INIT;\n\t\tFILE *fp;\n\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (merge)\";\n\t\tpptr = &commit_list_insert(lookup_commit(head_sha1), pptr)->next;\n\t\tfp = fopen(git_path(\"MERGE_HEAD\"), \"r\");\n\t\tif (fp == NULL)\n\t\t\tdie_errno(\"could not open '%s' for reading\",\n\t\t\t\t  git_path(\"MERGE_HEAD\"));\n\t\twhile (strbuf_getline(&m, fp, '\\n') != EOF) {\n\t\t\tunsigned char sha1[20];\n\t\t\tif (get_sha1_hex(m.buf, sha1) < 0)\n\t\t\t\tdie(\"Corrupt MERGE_HEAD file (%s)\", m.buf);\n\t\t\tpptr = &commit_list_insert(lookup_commit(sha1), pptr)->next;\n\t\t}\n\t\tfclose(fp);\n\t\tstrbuf_release(&m);\n\t\tif (!stat(git_path(\"MERGE_MODE\"), &statbuf)) {\n\t\t\tif (strbuf_read_file(&sb, git_path(\"MERGE_MODE\"), 0) < 0)\n\t\t\t\tdie_errno(\"could not read MERGE_MODE\");\n\t\t\tif (!strcmp(sb.buf, \"no-ff\"))\n\t\t\t\tallow_fast_forward = 0;\n\t\t}\n\t\tif (allow_fast_forward)\n\t\t\tparents = reduce_heads(parents);\n\t} else {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit\";\n\t\tpptr = &commit_list_insert(lookup_commit(head_sha1), pptr)->next;\n\t}\n\n\t/* Finally, get the commit message */\n\tstrbuf_reset(&sb);\n\tif (strbuf_read_file(&sb, git_path(commit_editmsg), 0) < 0) {\n\t\tint saved_errno = errno;\n\t\trollback_index_files();\n\t\tdie(\"could not read commit message: %s\", strerror(saved_errno));\n\t}\n\n\t/* Truncate the message just before the diff, if any. */\n\tif (verbose) {\n\t\tp = strstr(sb.buf, \"\\ndiff --git \");\n\t\tif (p != NULL)\n\t\t\tstrbuf_setlen(&sb, p - sb.buf + 1);\n\t}\n\n\tif (cleanup_mode != CLEANUP_NONE)\n\t\tstripspace(&sb, cleanup_mode == CLEANUP_ALL);\n\tif (message_is_empty(&sb) && !allow_empty_message) {\n\t\trollback_index_files();\n\t\tfprintf(stderr, \"Aborting commit due to empty commit message.\\n\");\n\t\texit(1);\n\t}\n\n\tif (commit_tree(sb.buf, active_cache_tree->sha1, parents, commit_sha1,\n\t\t\tauthor_ident.buf)) {\n\t\trollback_index_files();\n\t\tdie(\"failed to write commit object\");\n\t}\n\tstrbuf_release(&author_ident);\n\n\tref_lock = lock_any_ref_for_update(\"HEAD\",\n\t\t\t\t\t   initial_commit ? NULL : head_sha1,\n\t\t\t\t\t   0);\n\n\tnl = strchr(sb.buf, '\\n');\n\tif (nl)\n\t\tstrbuf_setlen(&sb, nl + 1 - sb.buf);\n\telse\n\t\tstrbuf_addch(&sb, '\\n');\n\tstrbuf_insert(&sb, 0, reflog_msg, strlen(reflog_msg));\n\tstrbuf_insert(&sb, strlen(reflog_msg), \": \", 2);\n\n\tif (!ref_lock) {\n\t\trollback_index_files();\n\t\tdie(\"cannot lock HEAD ref\");\n\t}\n\tif (write_ref_sha1(ref_lock, commit_sha1, sb.buf) < 0) {\n\t\trollback_index_files();\n\t\tdie(\"cannot update HEAD ref\");\n\t}\n\n\tunlink(git_path(\"MERGE_HEAD\"));\n\tunlink(git_path(\"MERGE_MSG\"));\n\tunlink(git_path(\"MERGE_MODE\"));\n\tunlink(git_path(\"SQUASH_MSG\"));\n\n\tif (commit_index_files())\n\t\tdie (\"Repository has been updated, but unable to write\\n\"\n\t\t     \"new_index file. Check that disk is not full or quota is\\n\"\n\t\t     \"not exceeded, and then \\\"git reset HEAD\\\" to recover.\");\n\n\trerere(0);\n\trun_hook(get_index_file(), \"post-commit\", NULL);\n\tif (amend && !no_post_rewrite) {\n\t\tstruct notes_rewrite_cfg *cfg;\n\t\tcfg = init_copy_notes_for_rewrite(\"amend\");\n\t\tif (cfg) {\n\t\t\tcopy_note_for_rewrite(cfg, head_sha1, commit_sha1);\n\t\t\tfinish_copy_notes_for_rewrite(cfg);\n\t\t}\n\t\trun_rewrite_hook(head_sha1, commit_sha1);\n\t}\n\tif (!quiet)\n\t\tprint_summary(prefix, commit_sha1);\n\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0090571adf09ef79bff63f2f0be0d02237c4e5b4",
  "sha1_ok": true,
  "size": 41291
}
