{
  "content": {
    "base64": "I2lmbmRlZiBPQkpFQ1RfU1RPUkVfSAojZGVmaW5lIE9CSkVDVF9TVE9SRV9ICgojaW5jbHVkZSAiY2FjaGUuaCIKI2luY2x1ZGUgIm9pZG1hcC5oIgojaW5jbHVkZSAibGlzdC5oIgojaW5jbHVkZSAic2hhMS1hcnJheS5oIgojaW5jbHVkZSAic3RyYnVmLmgiCgpzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSB7CglzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSAqbmV4dDsKCgkvKiBzZWUgYWx0X3NjcmF0Y2hfYnVmKCkgKi8KCXN0cnVjdCBzdHJidWYgc2NyYXRjaDsKCXNpemVfdCBiYXNlX2xlbjsKCgkvKgoJICogVXNlZCB0byBzdG9yZSB0aGUgcmVzdWx0cyBvZiByZWFkZGlyKDMpIGNhbGxzIHdoZW4gc2VhcmNoaW5nCgkgKiBmb3IgdW5pcXVlIGFiYnJldmlhdGVkIGhhc2hlcy4gIFRoaXMgY2FjaGUgaXMgbmV2ZXIKCSAqIGludmFsaWRhdGVkLCB0aHVzIGl0J3MgcmFjeSBhbmQgbm90IG5lY2Vzc2FyaWx5IGFjY3VyYXRlLgoJICogVGhhdCdzIGZpbmUgZm9yIGl0cyBwdXJwb3NlOyBkb24ndCB1c2UgaXQgZm9yIHRhc2tzIHJlcXVpcmluZwoJICogZ3JlYXRlciBhY2N1cmFjeSEKCSAqLwoJY2hhciBsb29zZV9vYmplY3RzX3N1YmRpcl9zZWVuWzI1Nl07CglzdHJ1Y3Qgb2lkX2FycmF5IGxvb3NlX29iamVjdHNfY2FjaGU7CgoJLyoKCSAqIFBhdGggdG8gdGhlIGFsdGVybmF0aXZlIG9iamVjdCBzdG9yZS4gSWYgdGhpcyBpcyBhIHJlbGF0aXZlIHBhdGgsCgkgKiBpdCBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS4KCSAqLwoJY2hhciBwYXRoW0ZMRVhfQVJSQVldOwp9Owp2b2lkIHByZXBhcmVfYWx0X29kYihzdHJ1Y3QgcmVwb3NpdG9yeSAqcik7CmNoYXIgKmNvbXB1dGVfYWx0ZXJuYXRlX3BhdGgoY29uc3QgY2hhciAqcGF0aCwgc3RydWN0IHN0cmJ1ZiAqZXJyKTsKdHlwZWRlZiBpbnQgYWx0X29kYl9mbihzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSAqLCB2b2lkICopOwppbnQgZm9yZWFjaF9hbHRfb2RiKGFsdF9vZGJfZm4sIHZvaWQqKTsKCi8qCiAqIEFsbG9jYXRlIGEgInN0cnVjdCBhbHRlcm5hdGVfb2JqZWN0X2RhdGFiYXNlIiBidXQgZG8gX25vdF8gYWN0dWFsbHkKICogYWRkIGl0IHRvIHRoZSBsaXN0IG9mIGFsdGVybmF0ZXMuCiAqLwpzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSAqYWxsb2NfYWx0X29kYihjb25zdCBjaGFyICpkaXIpOwoKLyoKICogQWRkIHRoZSBkaXJlY3RvcnkgdG8gdGhlIG9uLWRpc2sgYWx0ZXJuYXRlcyBmaWxlOyB0aGUgbmV3IGVudHJ5IHdpbGwgYWxzbwogKiB0YWtlIGVmZmVjdCBpbiB0aGUgY3VycmVudCBwcm9jZXNzLgogKi8Kdm9pZCBhZGRfdG9fYWx0ZXJuYXRlc19maWxlKGNvbnN0IGNoYXIgKmRpcik7CgovKgogKiBBZGQgdGhlIGRpcmVjdG9yeSB0byB0aGUgaW4tbWVtb3J5IGxpc3Qgb2YgYWx0ZXJuYXRlcyAoYWxvbmcgd2l0aCBhbnkKICogcmVjdXJzaXZlIGFsdGVybmF0ZXMgaXQgcG9pbnRzIHRvKSwgYnV0IGRvIG5vdCBtb2RpZnkgdGhlIG9uLWRpc2sgYWx0ZXJuYXRlcwogKiBmaWxlLgogKi8Kdm9pZCBhZGRfdG9fYWx0ZXJuYXRlc19tZW1vcnkoY29uc3QgY2hhciAqZGlyKTsKCi8qCiAqIFJldHVybnMgYSBzY3JhdGNoIHN0cmJ1ZiBwcmUtZmlsbGVkIHdpdGggdGhlIGFsdGVybmF0ZSBvYmplY3QgZGlyZWN0b3J5LAogKiBpbmNsdWRpbmcgYSB0cmFpbGluZyBzbGFzaCwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gYWNjZXNzIHBhdGhzIGluIHRoZQogKiBhbHRlcm5hdGUuIEFsd2F5cyB1c2UgdGhpcyBvdmVyIGRpcmVjdCBhY2Nlc3MgdG8gYWx0LT5zY3JhdGNoLCBhcyBpdAogKiBjbGVhbnMgdXAgYW55IHByZXZpb3VzIHVzZSBvZiB0aGUgc2NyYXRjaCBidWZmZXIuCiAqLwpzdHJ1Y3Qgc3RyYnVmICphbHRfc2NyYXRjaF9idWYoc3RydWN0IGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UgKmFsdCk7CgpzdHJ1Y3QgcGFja2VkX2dpdCB7CglzdHJ1Y3QgcGFja2VkX2dpdCAqbmV4dDsKCXN0cnVjdCBsaXN0X2hlYWQgbXJ1OwoJc3RydWN0IHBhY2tfd2luZG93ICp3aW5kb3dzOwoJb2ZmX3QgcGFja19zaXplOwoJY29uc3Qgdm9pZCAqaW5kZXhfZGF0YTsKCXNpemVfdCBpbmRleF9zaXplOwoJdWludDMyX3QgbnVtX29iamVjdHM7Cgl1aW50MzJfdCBudW1fYmFkX29iamVjdHM7Cgl1bnNpZ25lZCBjaGFyICpiYWRfb2JqZWN0X3NoYTE7CglpbnQgaW5kZXhfdmVyc2lvbjsKCXRpbWVfdCBtdGltZTsKCWludCBwYWNrX2ZkOwoJaW50IGluZGV4OyAgICAgICAgICAgICAgLyogZm9yIGJ1aWx0aW4vcGFjay1vYmplY3RzLmMgKi8KCXVuc2lnbmVkIHBhY2tfbG9jYWw6MSwKCQkgcGFja19rZWVwOjEsCgkJIHBhY2tfa2VlcF9pbl9jb3JlOjEsCgkJIGZyZXNoZW5lZDoxLAoJCSBkb19ub3RfY2xvc2U6MSwKCQkgcGFja19wcm9taXNvcjoxOwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCXN0cnVjdCByZXZpbmRleF9lbnRyeSAqcmV2aW5kZXg7CgkvKiBzb21ldGhpbmcgbGlrZSAiLmdpdC9vYmplY3RzL3BhY2sveHh4eHgucGFjayIgKi8KCWNoYXIgcGFja19uYW1lW0ZMRVhfQVJSQVldOyAvKiBtb3JlICovCn07CgpzdHJ1Y3QgbXVsdGlfcGFja19pbmRleDsKCnN0cnVjdCByYXdfb2JqZWN0X3N0b3JlIHsKCS8qCgkgKiBQYXRoIHRvIHRoZSByZXBvc2l0b3J5J3Mgb2JqZWN0IHN0b3JlLgoJICogQ2Fubm90IGJlIE5VTEwgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uCgkgKi8KCWNoYXIgKm9iamVjdGRpcjsKCgkvKiBQYXRoIHRvIGV4dHJhIGFsdGVybmF0ZSBvYmplY3QgZGF0YWJhc2UgaWYgbm90IE5VTEwgKi8KCWNoYXIgKmFsdGVybmF0ZV9kYjsKCglzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSAqYWx0X29kYl9saXN0OwoJc3RydWN0IGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UgKiphbHRfb2RiX3RhaWw7CgoJLyoKCSAqIE9iamVjdHMgdGhhdCBzaG91bGQgYmUgc3Vic3RpdHV0ZWQgYnkgb3RoZXIgb2JqZWN0cwoJICogKHNlZSBnaXQtcmVwbGFjZSgxKSkuCgkgKi8KCXN0cnVjdCBvaWRtYXAgKnJlcGxhY2VfbWFwOwoKCXN0cnVjdCBjb21taXRfZ3JhcGggKmNvbW1pdF9ncmFwaDsKCXVuc2lnbmVkIGNvbW1pdF9ncmFwaF9hdHRlbXB0ZWQgOiAxOyAvKiBpZiBsb2FkaW5nIGhhcyBiZWVuIGF0dGVtcHRlZCAqLwoKCS8qCgkgKiBwcml2YXRlIGRhdGEKCSAqCgkgKiBzaG91bGQgb25seSBiZSBhY2Nlc3NlZCBkaXJlY3RseSBieSBwYWNrZmlsZS5jIGFuZCBtaWR4LmMKCSAqLwoJc3RydWN0IG11bHRpX3BhY2tfaW5kZXggKm11bHRpX3BhY2tfaW5kZXg7CgoJLyoKCSAqIHByaXZhdGUgZGF0YQoJICoKCSAqIHNob3VsZCBvbmx5IGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGJ5IHBhY2tmaWxlLmMKCSAqLwoKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwYWNrZWRfZ2l0OwoJLyogQSBtb3N0LXJlY2VudGx5LXVzZWQgb3JkZXJlZCB2ZXJzaW9uIG9mIHRoZSBwYWNrZWRfZ2l0IGxpc3QuICovCglzdHJ1Y3QgbGlzdF9oZWFkIHBhY2tlZF9naXRfbXJ1OwoKCS8qCgkgKiBBIGxpbmtlZCBsaXN0IGNvbnRhaW5pbmcgYWxsIHBhY2tmaWxlcywgc3RhcnRpbmcgd2l0aCB0aG9zZQoJICogY29udGFpbmVkIGluIHRoZSBtdWx0aV9wYWNrX2luZGV4LgoJICovCglzdHJ1Y3QgcGFja2VkX2dpdCAqYWxsX3BhY2tzOwoKCS8qCgkgKiBBIGZhc3QsIHJvdWdoIGNvdW50IG9mIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyBpbiB0aGUgcmVwb3NpdG9yeS4KCSAqIFRoZXNlIHR3byBmaWVsZHMgYXJlIG5vdCBtZWFudCBmb3IgZGlyZWN0IGFjY2Vzcy4gVXNlCgkgKiBhcHByb3hpbWF0ZV9vYmplY3RfY291bnQoKSBpbnN0ZWFkLgoJICovCgl1bnNpZ25lZCBsb25nIGFwcHJveGltYXRlX29iamVjdF9jb3VudDsKCXVuc2lnbmVkIGFwcHJveGltYXRlX29iamVjdF9jb3VudF92YWxpZCA6IDE7CgoJLyoKCSAqIFdoZXRoZXIgcGFja2VkX2dpdCBoYXMgYWxyZWFkeSBiZWVuIHBvcHVsYXRlZCB3aXRoIHRoaXMgcmVwb3NpdG9yeSdzCgkgKiBwYWNrcy4KCSAqLwoJdW5zaWduZWQgcGFja2VkX2dpdF9pbml0aWFsaXplZCA6IDE7Cn07CgpzdHJ1Y3QgcmF3X29iamVjdF9zdG9yZSAqcmF3X29iamVjdF9zdG9yZV9uZXcodm9pZCk7CnZvaWQgcmF3X29iamVjdF9zdG9yZV9jbGVhcihzdHJ1Y3QgcmF3X29iamVjdF9zdG9yZSAqbyk7CgovKgogKiBQdXQgaW4gYGJ1ZmAgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaW4gdGhlIGxvY2FsIG9iamVjdCBkYXRhYmFzZSB0aGF0CiAqIHdvdWxkIGJlIHVzZWQgdG8gc3RvcmUgYSBsb29zZSBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIHNoYTEuCiAqLwp2b2lkIHNoYTFfZmlsZV9uYW1lKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBzdHJ1Y3Qgc3RyYnVmICpidWYsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpOwoKdm9pZCAqbWFwX3NoYTFfZmlsZShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgdW5zaWduZWQgbG9uZyAqc2l6ZSk7CgpleHRlcm4gdm9pZCAqcmVhZF9vYmplY3RfZmlsZV9leHRlbmRlZChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJCSAgICAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCQkgICAgICAgZW51bSBvYmplY3RfdHlwZSAqdHlwZSwKCQkJCSAgICAgICB1bnNpZ25lZCBsb25nICpzaXplLCBpbnQgbG9va3VwX3JlcGxhY2UpOwpzdGF0aWMgaW5saW5lIHZvaWQgKnJlcG9fcmVhZF9vYmplY3RfZmlsZShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJCQkgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCQkgIGVudW0gb2JqZWN0X3R5cGUgKnR5cGUsCgkJCQkJICB1bnNpZ25lZCBsb25nICpzaXplKQp7CglyZXR1cm4gcmVhZF9vYmplY3RfZmlsZV9leHRlbmRlZChyLCBvaWQsIHR5cGUsIHNpemUsIDEpOwp9CiNpZm5kZWYgTk9fVEhFX1JFUE9TSVRPUllfQ09NUEFUSUJJTElUWV9NQUNST1MKI2RlZmluZSByZWFkX29iamVjdF9maWxlKG9pZCwgdHlwZSwgc2l6ZSkgcmVwb19yZWFkX29iamVjdF9maWxlKHRoZV9yZXBvc2l0b3J5LCBvaWQsIHR5cGUsIHNpemUpCiNlbmRpZgoKLyogUmVhZCBhbmQgdW5wYWNrIGFuIG9iamVjdCBmaWxlIGludG8gbWVtb3J5LCB3cml0ZSBtZW1vcnkgdG8gYW4gb2JqZWN0IGZpbGUgKi8KaW50IG9pZF9vYmplY3RfaW5mbyhzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqLCB1bnNpZ25lZCBsb25nICopOwoKZXh0ZXJuIGludCBoYXNoX29iamVjdF9maWxlKGNvbnN0IHZvaWQgKmJ1ZiwgdW5zaWduZWQgbG9uZyBsZW4sCgkJCSAgICBjb25zdCBjaGFyICp0eXBlLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpOwoKZXh0ZXJuIGludCB3cml0ZV9vYmplY3RfZmlsZShjb25zdCB2b2lkICpidWYsIHVuc2lnbmVkIGxvbmcgbGVuLAoJCQkgICAgIGNvbnN0IGNoYXIgKnR5cGUsIHN0cnVjdCBvYmplY3RfaWQgKm9pZCk7CgpleHRlcm4gaW50IGhhc2hfb2JqZWN0X2ZpbGVfbGl0ZXJhbGx5KGNvbnN0IHZvaWQgKmJ1ZiwgdW5zaWduZWQgbG9uZyBsZW4sCgkJCQkgICAgICBjb25zdCBjaGFyICp0eXBlLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCQkgICAgICB1bnNpZ25lZCBmbGFncyk7CgpleHRlcm4gaW50IHByZXRlbmRfb2JqZWN0X2ZpbGUodm9pZCAqLCB1bnNpZ25lZCBsb25nLCBlbnVtIG9iamVjdF90eXBlLAoJCQkgICAgICAgc3RydWN0IG9iamVjdF9pZCAqb2lkKTsKCmV4dGVybiBpbnQgZm9yY2Vfb2JqZWN0X2xvb3NlKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgdGltZV90IG10aW1lKTsKCi8qCiAqIE9wZW4gdGhlIGxvb3NlIG9iamVjdCBhdCBwYXRoLCBjaGVjayBpdHMgaGFzaCwgYW5kIHJldHVybiB0aGUgY29udGVudHMsCiAqIHR5cGUsIGFuZCBzaXplLiBJZiB0aGUgb2JqZWN0IGlzIGEgYmxvYiwgdGhlbiAiY29udGVudHMiIG1heSByZXR1cm4gTlVMTCwKICogdG8gYWxsb3cgc3RyZWFtaW5nIG9mIGxhcmdlIGJsb2JzLgogKgogKiBSZXR1cm5zIDAgb24gc3VjY2VzcywgbmVnYXRpdmUgb24gZXJyb3IgKGRldGFpbHMgbWF5IGJlIHdyaXR0ZW4gdG8gc3RkZXJyKS4KICovCmludCByZWFkX2xvb3NlX29iamVjdChjb25zdCBjaGFyICpwYXRoLAoJCSAgICAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKmV4cGVjdGVkX29pZCwKCQkgICAgICBlbnVtIG9iamVjdF90eXBlICp0eXBlLAoJCSAgICAgIHVuc2lnbmVkIGxvbmcgKnNpemUsCgkJICAgICAgdm9pZCAqKmNvbnRlbnRzKTsKCi8qCiAqIENvbnZlbmllbmNlIGZvciBzaGExX29iamVjdF9pbmZvX2V4dGVuZGVkKCkgd2l0aCBhIE5VTEwgc3RydWN0CiAqIG9iamVjdF9pbmZvLiBPQkpFQ1RfSU5GT19TS0lQX0NBQ0hFRCBpcyBhdXRvbWF0aWNhbGx5IHNldDsgcGFzcwogKiBub256ZXJvIGZsYWdzIHRvIGFsc28gc2V0IG90aGVyIGZsYWdzLgogKi8KZXh0ZXJuIGludCBoYXNfc2hhMV9maWxlX3dpdGhfZmxhZ3MoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgaW50IGZsYWdzKTsKc3RhdGljIGlubGluZSBpbnQgaGFzX3NoYTFfZmlsZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglyZXR1cm4gaGFzX3NoYTFfZmlsZV93aXRoX2ZsYWdzKHNoYTEsIDApOwp9CgovKiBTYW1lIGFzIHRoZSBhYm92ZSwgZXhjZXB0IGZvciBzdHJ1Y3Qgb2JqZWN0X2lkLiAqLwpleHRlcm4gaW50IGhhc19vYmplY3RfZmlsZShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpOwpleHRlcm4gaW50IGhhc19vYmplY3RfZmlsZV93aXRoX2ZsYWdzKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgaW50IGZsYWdzKTsKCi8qCiAqIFJldHVybiB0cnVlIGlmZiBhbiBhbHRlcm5hdGUgb2JqZWN0IGRhdGFiYXNlIGhhcyBhIGxvb3NlIG9iamVjdAogKiB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS4gIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcmVzcGVjdCByZXBsYWNlCiAqIHJlZmVyZW5jZXMuCiAqLwpleHRlcm4gaW50IGhhc19sb29zZV9vYmplY3Rfbm9ubG9jYWwoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqKTsKCmV4dGVybiB2b2lkIGFzc2VydF9vaWRfdHlwZShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGVudW0gb2JqZWN0X3R5cGUgZXhwZWN0KTsKCnN0cnVjdCBvYmplY3RfaW5mbyB7CgkvKiBSZXF1ZXN0ICovCgllbnVtIG9iamVjdF90eXBlICp0eXBlcDsKCXVuc2lnbmVkIGxvbmcgKnNpemVwOwoJb2ZmX3QgKmRpc2tfc2l6ZXA7Cgl1bnNpZ25lZCBjaGFyICpkZWx0YV9iYXNlX3NoYTE7CglzdHJ1Y3Qgc3RyYnVmICp0eXBlX25hbWU7Cgl2b2lkICoqY29udGVudHA7CgoJLyogUmVzcG9uc2UgKi8KCWVudW0gewoJCU9JX0NBQ0hFRCwKCQlPSV9MT09TRSwKCQlPSV9QQUNLRUQsCgkJT0lfREJDQUNIRUQKCX0gd2hlbmNlOwoJdW5pb24gewoJCS8qCgkJICogc3RydWN0IHsKCQkgKiAJLi4uIE5vdGhpbmcgdG8gZXhwb3NlIGluIHRoaXMgY2FzZQoJCSAqIH0gY2FjaGVkOwoJCSAqIHN0cnVjdCB7CgkJICogCS4uLiBOb3RoaW5nIHRvIGV4cG9zZSBpbiB0aGlzIGNhc2UKCQkgKiB9IGxvb3NlOwoJCSAqLwoJCXN0cnVjdCB7CgkJCXN0cnVjdCBwYWNrZWRfZ2l0ICpwYWNrOwoJCQlvZmZfdCBvZmZzZXQ7CgkJCXVuc2lnbmVkIGludCBpc19kZWx0YTsKCQl9IHBhY2tlZDsKCX0gdTsKfTsKCi8qCiAqIEluaXRpYWxpemVyIGZvciBhICJzdHJ1Y3Qgb2JqZWN0X2luZm8iIHRoYXQgd2FudHMgbm8gaXRlbXMuIFlvdSBtYXkKICogYWxzbyBtZW1zZXQoKSB0aGUgbWVtb3J5IHRvIGFsbC16ZXJvZXMuCiAqLwojZGVmaW5lIE9CSkVDVF9JTkZPX0lOSVQge05VTEx9CgovKiBJbnZva2UgbG9va3VwX3JlcGxhY2Vfb2JqZWN0KCkgb24gdGhlIGdpdmVuIGhhc2ggKi8KI2RlZmluZSBPQkpFQ1RfSU5GT19MT09LVVBfUkVQTEFDRSAxCi8qIEFsbG93IHJlYWRpbmcgZnJvbSBhIGxvb3NlIG9iamVjdCBmaWxlIG9mIHVua25vd24vYm9ndXMgdHlwZSAqLwojZGVmaW5lIE9CSkVDVF9JTkZPX0FMTE9XX1VOS05PV05fVFlQRSAyCi8qIERvIG5vdCBjaGVjayBjYWNoZWQgc3RvcmFnZSAqLwojZGVmaW5lIE9CSkVDVF9JTkZPX1NLSVBfQ0FDSEVEIDQKLyogRG8gbm90IHJldHJ5IHBhY2tlZCBzdG9yYWdlIGFmdGVyIGNoZWNraW5nIHBhY2tlZCBhbmQgbG9vc2Ugc3RvcmFnZSAqLwojZGVmaW5lIE9CSkVDVF9JTkZPX1FVSUNLIDgKLyogRG8gbm90IGNoZWNrIGxvb3NlIG9iamVjdCAqLwojZGVmaW5lIE9CSkVDVF9JTkZPX0lHTk9SRV9MT09TRSAxNgoKaW50IG9pZF9vYmplY3RfaW5mb19leHRlbmRlZChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJICAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICosCgkJCSAgICAgc3RydWN0IG9iamVjdF9pbmZvICosIHVuc2lnbmVkIGZsYWdzKTsKCi8qCiAqIEl0ZXJhdGUgb3ZlciB0aGUgZmlsZXMgaW4gdGhlIGxvb3NlLW9iamVjdCBwYXJ0cyBvZiB0aGUgb2JqZWN0CiAqIGRpcmVjdG9yeSAicGF0aCIsIHRyaWdnZXJpbmcgdGhlIGZvbGxvd2luZyBjYWxsYmFja3M6CiAqCiAqICAtIGxvb3NlX29iamVjdCBpcyBjYWxsZWQgZm9yIGVhY2ggbG9vc2Ugb2JqZWN0IHdlIGZpbmQuCiAqCiAqICAtIGxvb3NlX2NydWZ0IGlzIGNhbGxlZCBmb3IgYW55IGZpbGVzIHRoYXQgZG8gbm90IGFwcGVhciB0byBiZQogKiAgICBsb29zZSBvYmplY3RzLiBOb3RlIHRoYXQgd2Ugb25seSBsb29rIGluIHRoZSBsb29zZSBvYmplY3QKICogICAgZGlyZWN0b3JpZXMgIm9iamVjdHMvWzAtOWEtZl17Mn0vIiwgc28gd2Ugd2lsbCBub3QgcmVwb3J0CiAqICAgICJvYmplY3RzL2Zvb2JhciIgYXMgY3J1ZnQuCiAqCiAqICAtIGxvb3NlX3N1YmRpciBpcyBjYWxsZWQgZm9yIGVhY2ggdG9wLWxldmVsIGhhc2hlZCBzdWJkaXJlY3RvcnkKICogICAgb2YgdGhlIG9iamVjdCBkaXJlY3RvcnkgKGUuZy4sICIkT0JKRElSL2YwIikuIEl0IGlzIGNhbGxlZAogKiAgICBhZnRlciB0aGUgb2JqZWN0cyBpbiB0aGUgZGlyZWN0b3J5IGFyZSBwcm9jZXNzZWQuCiAqCiAqIEFueSBjYWxsYmFjayB0aGF0IGlzIE5VTEwgd2lsbCBiZSBpZ25vcmVkLiBDYWxsYmFja3MgcmV0dXJuaW5nIG5vbi16ZXJvCiAqIHdpbGwgZW5kIHRoZSBpdGVyYXRpb24uCiAqCiAqIEluIHRoZSAiYnVmIiB2YXJpYW50LCAicGF0aCIgaXMgYSBzdHJidWYgd2hpY2ggd2lsbCBhbHNvIGJlIHVzZWQgYXMgYQogKiBzY3JhdGNoIGJ1ZmZlciwgYnV0IHJlc3RvcmVkIHRvIGl0cyBvcmlnaW5hbCBjb250ZW50cyBiZWZvcmUKICogdGhlIGZ1bmN0aW9uIHJldHVybnMuCiAqLwp0eXBlZGVmIGludCBlYWNoX2xvb3NlX29iamVjdF9mbihjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCQkgY29uc3QgY2hhciAqcGF0aCwKCQkJCSB2b2lkICpkYXRhKTsKdHlwZWRlZiBpbnQgZWFjaF9sb29zZV9jcnVmdF9mbihjb25zdCBjaGFyICpiYXNlbmFtZSwKCQkJCWNvbnN0IGNoYXIgKnBhdGgsCgkJCQl2b2lkICpkYXRhKTsKdHlwZWRlZiBpbnQgZWFjaF9sb29zZV9zdWJkaXJfZm4odW5zaWduZWQgaW50IG5yLAoJCQkJIGNvbnN0IGNoYXIgKnBhdGgsCgkJCQkgdm9pZCAqZGF0YSk7CmludCBmb3JfZWFjaF9maWxlX2luX29ial9zdWJkaXIodW5zaWduZWQgaW50IHN1YmRpcl9uciwKCQkJCXN0cnVjdCBzdHJidWYgKnBhdGgsCgkJCQllYWNoX2xvb3NlX29iamVjdF9mbiBvYmpfY2IsCgkJCQllYWNoX2xvb3NlX2NydWZ0X2ZuIGNydWZ0X2NiLAoJCQkJZWFjaF9sb29zZV9zdWJkaXJfZm4gc3ViZGlyX2NiLAoJCQkJdm9pZCAqZGF0YSk7CmludCBmb3JfZWFjaF9sb29zZV9maWxlX2luX29iamRpcihjb25zdCBjaGFyICpwYXRoLAoJCQkJICBlYWNoX2xvb3NlX29iamVjdF9mbiBvYmpfY2IsCgkJCQkgIGVhY2hfbG9vc2VfY3J1ZnRfZm4gY3J1ZnRfY2IsCgkJCQkgIGVhY2hfbG9vc2Vfc3ViZGlyX2ZuIHN1YmRpcl9jYiwKCQkJCSAgdm9pZCAqZGF0YSk7CmludCBmb3JfZWFjaF9sb29zZV9maWxlX2luX29iamRpcl9idWYoc3RydWN0IHN0cmJ1ZiAqcGF0aCwKCQkJCSAgICAgIGVhY2hfbG9vc2Vfb2JqZWN0X2ZuIG9ial9jYiwKCQkJCSAgICAgIGVhY2hfbG9vc2VfY3J1ZnRfZm4gY3J1ZnRfY2IsCgkJCQkgICAgICBlYWNoX2xvb3NlX3N1YmRpcl9mbiBzdWJkaXJfY2IsCgkJCQkgICAgICB2b2lkICpkYXRhKTsKCi8qIEZsYWdzIGZvciBmb3JfZWFjaF8qX29iamVjdCgpIGJlbG93LiAqLwplbnVtIGZvcl9lYWNoX29iamVjdF9mbGFncyB7CgkvKiBJdGVyYXRlIG9ubHkgb3ZlciBsb2NhbCBvYmplY3RzLCBub3QgYWx0ZXJuYXRlcy4gKi8KCUZPUl9FQUNIX09CSkVDVF9MT0NBTF9PTkxZID0gKDE8PDApLAoKCS8qIE9ubHkgaXRlcmF0ZSBvdmVyIHBhY2tzIG9idGFpbmVkIGZyb20gdGhlIHByb21pc29yIHJlbW90ZS4gKi8KCUZPUl9FQUNIX09CSkVDVF9QUk9NSVNPUl9PTkxZID0gKDE8PDEpLAoKCS8qCgkgKiBWaXNpdCBvYmplY3RzIHdpdGhpbiBhIHBhY2sgaW4gcGFja2ZpbGUgb3JkZXIgcmF0aGVyIHRoYW4gLmlkeCBvcmRlcgoJICovCglGT1JfRUFDSF9PQkpFQ1RfUEFDS19PUkRFUiA9ICgxPDwyKSwKfTsKCi8qCiAqIEl0ZXJhdGUgb3ZlciBhbGwgYWNjZXNzaWJsZSBsb29zZSBvYmplY3RzIHdpdGhvdXQgcmVzcGVjdCB0bwogKiByZWFjaGFiaWxpdHkuIEJ5IGRlZmF1bHQsIHRoaXMgaW5jbHVkZXMgYm90aCBsb2NhbCBhbmQgYWx0ZXJuYXRlIG9iamVjdHMuCiAqIFRoZSBvcmRlciBpbiB3aGljaCBvYmplY3RzIGFyZSB2aXNpdGVkIGlzIHVuc3BlY2lmaWVkLgogKgogKiBBbnkgZmxhZ3Mgc3BlY2lmaWMgdG8gcGFja3MgYXJlIGlnbm9yZWQuCiAqLwppbnQgZm9yX2VhY2hfbG9vc2Vfb2JqZWN0KGVhY2hfbG9vc2Vfb2JqZWN0X2ZuLCB2b2lkICosCgkJCSAgZW51bSBmb3JfZWFjaF9vYmplY3RfZmxhZ3MgZmxhZ3MpOwoKLyoKICogSXRlcmF0ZSBvdmVyIGFsbCBhY2Nlc3NpYmxlIHBhY2tlZCBvYmplY3RzIHdpdGhvdXQgcmVzcGVjdCB0byByZWFjaGFiaWxpdHkuCiAqIEJ5IGRlZmF1bHQsIHRoaXMgaW5jbHVkZXMgYm90aCBsb2NhbCBhbmQgYWx0ZXJuYXRlIHBhY2tzLgogKgogKiBOb3RlIHRoYXQgc29tZSBvYmplY3RzIG1heSBhcHBlYXIgdHdpY2UgaWYgdGhleSBhcmUgZm91bmQgaW4gbXVsdGlwbGUgcGFja3MuCiAqIEVhY2ggcGFjayBpcyB2aXNpdGVkIGluIGFuIHVuc3BlY2lmaWVkIG9yZGVyLiBCeSBkZWZhdWx0LCBvYmplY3RzIHdpdGhpbiBhCiAqIHBhY2sgYXJlIHZpc2l0ZWQgaW4gcGFjay1pZHggb3JkZXIgKGkuZS4sIHNvcnRlZCBieSBvaWQpLgogKi8KdHlwZWRlZiBpbnQgZWFjaF9wYWNrZWRfb2JqZWN0X2ZuKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCSAgc3RydWN0IHBhY2tlZF9naXQgKnBhY2ssCgkJCQkgIHVpbnQzMl90IHBvcywKCQkJCSAgdm9pZCAqZGF0YSk7CmludCBmb3JfZWFjaF9vYmplY3RfaW5fcGFjayhzdHJ1Y3QgcGFja2VkX2dpdCAqcCwKCQkJICAgIGVhY2hfcGFja2VkX29iamVjdF9mbiwgdm9pZCAqZGF0YSwKCQkJICAgIGVudW0gZm9yX2VhY2hfb2JqZWN0X2ZsYWdzIGZsYWdzKTsKaW50IGZvcl9lYWNoX3BhY2tlZF9vYmplY3QoZWFjaF9wYWNrZWRfb2JqZWN0X2ZuLCB2b2lkICosCgkJCSAgIGVudW0gZm9yX2VhY2hfb2JqZWN0X2ZsYWdzIGZsYWdzKTsKCiNlbmRpZiAvKiBPQkpFQ1RfU1RPUkVfSCAqLwo=",
    "text": "#ifndef OBJECT_STORE_H\n#define OBJECT_STORE_H\n\n#include \"cache.h\"\n#include \"oidmap.h\"\n#include \"list.h\"\n#include \"sha1-array.h\"\n#include \"strbuf.h\"\n\nstruct alternate_object_database {\n\tstruct alternate_object_database *next;\n\n\t/* see alt_scratch_buf() */\n\tstruct strbuf scratch;\n\tsize_t base_len;\n\n\t/*\n\t * Used to store the results of readdir(3) calls when searching\n\t * for unique abbreviated hashes.  This cache is never\n\t * invalidated, thus it's racy and not necessarily accurate.\n\t * That's fine for its purpose; don't use it for tasks requiring\n\t * greater accuracy!\n\t */\n\tchar loose_objects_subdir_seen[256];\n\tstruct oid_array loose_objects_cache;\n\n\t/*\n\t * Path to the alternative object store. If this is a relative path,\n\t * it is relative to the current working directory.\n\t */\n\tchar path[FLEX_ARRAY];\n};\nvoid prepare_alt_odb(struct repository *r);\nchar *compute_alternate_path(const char *path, struct strbuf *err);\ntypedef int alt_odb_fn(struct alternate_object_database *, void *);\nint foreach_alt_odb(alt_odb_fn, void*);\n\n/*\n * Allocate a \"struct alternate_object_database\" but do _not_ actually\n * add it to the list of alternates.\n */\nstruct alternate_object_database *alloc_alt_odb(const char *dir);\n\n/*\n * Add the directory to the on-disk alternates file; the new entry will also\n * take effect in the current process.\n */\nvoid add_to_alternates_file(const char *dir);\n\n/*\n * Add the directory to the in-memory list of alternates (along with any\n * recursive alternates it points to), but do not modify the on-disk alternates\n * file.\n */\nvoid add_to_alternates_memory(const char *dir);\n\n/*\n * Returns a scratch strbuf pre-filled with the alternate object directory,\n * including a trailing slash, which can be used to access paths in the\n * alternate. Always use this over direct access to alt->scratch, as it\n * cleans up any previous use of the scratch buffer.\n */\nstruct strbuf *alt_scratch_buf(struct alternate_object_database *alt);\n\nstruct packed_git {\n\tstruct packed_git *next;\n\tstruct list_head mru;\n\tstruct pack_window *windows;\n\toff_t pack_size;\n\tconst void *index_data;\n\tsize_t index_size;\n\tuint32_t num_objects;\n\tuint32_t num_bad_objects;\n\tunsigned char *bad_object_sha1;\n\tint index_version;\n\ttime_t mtime;\n\tint pack_fd;\n\tint index;              /* for builtin/pack-objects.c */\n\tunsigned pack_local:1,\n\t\t pack_keep:1,\n\t\t pack_keep_in_core:1,\n\t\t freshened:1,\n\t\t do_not_close:1,\n\t\t pack_promisor:1;\n\tunsigned char sha1[20];\n\tstruct revindex_entry *revindex;\n\t/* something like \".git/objects/pack/xxxxx.pack\" */\n\tchar pack_name[FLEX_ARRAY]; /* more */\n};\n\nstruct multi_pack_index;\n\nstruct raw_object_store {\n\t/*\n\t * Path to the repository's object store.\n\t * Cannot be NULL after initialization.\n\t */\n\tchar *objectdir;\n\n\t/* Path to extra alternate object database if not NULL */\n\tchar *alternate_db;\n\n\tstruct alternate_object_database *alt_odb_list;\n\tstruct alternate_object_database **alt_odb_tail;\n\n\t/*\n\t * Objects that should be substituted by other objects\n\t * (see git-replace(1)).\n\t */\n\tstruct oidmap *replace_map;\n\n\tstruct commit_graph *commit_graph;\n\tunsigned commit_graph_attempted : 1; /* if loading has been attempted */\n\n\t/*\n\t * private data\n\t *\n\t * should only be accessed directly by packfile.c and midx.c\n\t */\n\tstruct multi_pack_index *multi_pack_index;\n\n\t/*\n\t * private data\n\t *\n\t * should only be accessed directly by packfile.c\n\t */\n\n\tstruct packed_git *packed_git;\n\t/* A most-recently-used ordered version of the packed_git list. */\n\tstruct list_head packed_git_mru;\n\n\t/*\n\t * A linked list containing all packfiles, starting with those\n\t * contained in the multi_pack_index.\n\t */\n\tstruct packed_git *all_packs;\n\n\t/*\n\t * A fast, rough count of the number of objects in the repository.\n\t * These two fields are not meant for direct access. Use\n\t * approximate_object_count() instead.\n\t */\n\tunsigned long approximate_object_count;\n\tunsigned approximate_object_count_valid : 1;\n\n\t/*\n\t * Whether packed_git has already been populated with this repository's\n\t * packs.\n\t */\n\tunsigned packed_git_initialized : 1;\n};\n\nstruct raw_object_store *raw_object_store_new(void);\nvoid raw_object_store_clear(struct raw_object_store *o);\n\n/*\n * Put in `buf` the name of the file in the local object database that\n * would be used to store a loose object with the specified sha1.\n */\nvoid sha1_file_name(struct repository *r, struct strbuf *buf, const unsigned char *sha1);\n\nvoid *map_sha1_file(struct repository *r, const unsigned char *sha1, unsigned long *size);\n\nextern void *read_object_file_extended(struct repository *r,\n\t\t\t\t       const struct object_id *oid,\n\t\t\t\t       enum object_type *type,\n\t\t\t\t       unsigned long *size, int lookup_replace);\nstatic inline void *repo_read_object_file(struct repository *r,\n\t\t\t\t\t  const struct object_id *oid,\n\t\t\t\t\t  enum object_type *type,\n\t\t\t\t\t  unsigned long *size)\n{\n\treturn read_object_file_extended(r, oid, type, size, 1);\n}\n#ifndef NO_THE_REPOSITORY_COMPATIBILITY_MACROS\n#define read_object_file(oid, type, size) repo_read_object_file(the_repository, oid, type, size)\n#endif\n\n/* Read and unpack an object file into memory, write memory to an object file */\nint oid_object_info(struct repository *r, const struct object_id *, unsigned long *);\n\nextern int hash_object_file(const void *buf, unsigned long len,\n\t\t\t    const char *type, struct object_id *oid);\n\nextern int write_object_file(const void *buf, unsigned long len,\n\t\t\t     const char *type, struct object_id *oid);\n\nextern int hash_object_file_literally(const void *buf, unsigned long len,\n\t\t\t\t      const char *type, struct object_id *oid,\n\t\t\t\t      unsigned flags);\n\nextern int pretend_object_file(void *, unsigned long, enum object_type,\n\t\t\t       struct object_id *oid);\n\nextern int force_object_loose(const struct object_id *oid, time_t mtime);\n\n/*\n * Open the loose object at path, check its hash, and return the contents,\n * type, and size. If the object is a blob, then \"contents\" may return NULL,\n * to allow streaming of large blobs.\n *\n * Returns 0 on success, negative on error (details may be written to stderr).\n */\nint read_loose_object(const char *path,\n\t\t      const struct object_id *expected_oid,\n\t\t      enum object_type *type,\n\t\t      unsigned long *size,\n\t\t      void **contents);\n\n/*\n * Convenience for sha1_object_info_extended() with a NULL struct\n * object_info. OBJECT_INFO_SKIP_CACHED is automatically set; pass\n * nonzero flags to also set other flags.\n */\nextern int has_sha1_file_with_flags(const unsigned char *sha1, int flags);\nstatic inline int has_sha1_file(const unsigned char *sha1)\n{\n\treturn has_sha1_file_with_flags(sha1, 0);\n}\n\n/* Same as the above, except for struct object_id. */\nextern int has_object_file(const struct object_id *oid);\nextern int has_object_file_with_flags(const struct object_id *oid, int flags);\n\n/*\n * Return true iff an alternate object database has a loose object\n * with the specified name.  This function does not respect replace\n * references.\n */\nextern int has_loose_object_nonlocal(const struct object_id *);\n\nextern void assert_oid_type(const struct object_id *oid, enum object_type expect);\n\nstruct object_info {\n\t/* Request */\n\tenum object_type *typep;\n\tunsigned long *sizep;\n\toff_t *disk_sizep;\n\tunsigned char *delta_base_sha1;\n\tstruct strbuf *type_name;\n\tvoid **contentp;\n\n\t/* Response */\n\tenum {\n\t\tOI_CACHED,\n\t\tOI_LOOSE,\n\t\tOI_PACKED,\n\t\tOI_DBCACHED\n\t} whence;\n\tunion {\n\t\t/*\n\t\t * struct {\n\t\t * \t... Nothing to expose in this case\n\t\t * } cached;\n\t\t * struct {\n\t\t * \t... Nothing to expose in this case\n\t\t * } loose;\n\t\t */\n\t\tstruct {\n\t\t\tstruct packed_git *pack;\n\t\t\toff_t offset;\n\t\t\tunsigned int is_delta;\n\t\t} packed;\n\t} u;\n};\n\n/*\n * Initializer for a \"struct object_info\" that wants no items. You may\n * also memset() the memory to all-zeroes.\n */\n#define OBJECT_INFO_INIT {NULL}\n\n/* Invoke lookup_replace_object() on the given hash */\n#define OBJECT_INFO_LOOKUP_REPLACE 1\n/* Allow reading from a loose object file of unknown/bogus type */\n#define OBJECT_INFO_ALLOW_UNKNOWN_TYPE 2\n/* Do not check cached storage */\n#define OBJECT_INFO_SKIP_CACHED 4\n/* Do not retry packed storage after checking packed and loose storage */\n#define OBJECT_INFO_QUICK 8\n/* Do not check loose object */\n#define OBJECT_INFO_IGNORE_LOOSE 16\n\nint oid_object_info_extended(struct repository *r,\n\t\t\t     const struct object_id *,\n\t\t\t     struct object_info *, unsigned flags);\n\n/*\n * Iterate over the files in the loose-object parts of the object\n * directory \"path\", triggering the following callbacks:\n *\n *  - loose_object is called for each loose object we find.\n *\n *  - loose_cruft is called for any files that do not appear to be\n *    loose objects. Note that we only look in the loose object\n *    directories \"objects/[0-9a-f]{2}/\", so we will not report\n *    \"objects/foobar\" as cruft.\n *\n *  - loose_subdir is called for each top-level hashed subdirectory\n *    of the object directory (e.g., \"$OBJDIR/f0\"). It is called\n *    after the objects in the directory are processed.\n *\n * Any callback that is NULL will be ignored. Callbacks returning non-zero\n * will end the iteration.\n *\n * In the \"buf\" variant, \"path\" is a strbuf which will also be used as a\n * scratch buffer, but restored to its original contents before\n * the function returns.\n */\ntypedef int each_loose_object_fn(const struct object_id *oid,\n\t\t\t\t const char *path,\n\t\t\t\t void *data);\ntypedef int each_loose_cruft_fn(const char *basename,\n\t\t\t\tconst char *path,\n\t\t\t\tvoid *data);\ntypedef int each_loose_subdir_fn(unsigned int nr,\n\t\t\t\t const char *path,\n\t\t\t\t void *data);\nint for_each_file_in_obj_subdir(unsigned int subdir_nr,\n\t\t\t\tstruct strbuf *path,\n\t\t\t\teach_loose_object_fn obj_cb,\n\t\t\t\teach_loose_cruft_fn cruft_cb,\n\t\t\t\teach_loose_subdir_fn subdir_cb,\n\t\t\t\tvoid *data);\nint for_each_loose_file_in_objdir(const char *path,\n\t\t\t\t  each_loose_object_fn obj_cb,\n\t\t\t\t  each_loose_cruft_fn cruft_cb,\n\t\t\t\t  each_loose_subdir_fn subdir_cb,\n\t\t\t\t  void *data);\nint for_each_loose_file_in_objdir_buf(struct strbuf *path,\n\t\t\t\t      each_loose_object_fn obj_cb,\n\t\t\t\t      each_loose_cruft_fn cruft_cb,\n\t\t\t\t      each_loose_subdir_fn subdir_cb,\n\t\t\t\t      void *data);\n\n/* Flags for for_each_*_object() below. */\nenum for_each_object_flags {\n\t/* Iterate only over local objects, not alternates. */\n\tFOR_EACH_OBJECT_LOCAL_ONLY = (1<<0),\n\n\t/* Only iterate over packs obtained from the promisor remote. */\n\tFOR_EACH_OBJECT_PROMISOR_ONLY = (1<<1),\n\n\t/*\n\t * Visit objects within a pack in packfile order rather than .idx order\n\t */\n\tFOR_EACH_OBJECT_PACK_ORDER = (1<<2),\n};\n\n/*\n * Iterate over all accessible loose objects without respect to\n * reachability. By default, this includes both local and alternate objects.\n * The order in which objects are visited is unspecified.\n *\n * Any flags specific to packs are ignored.\n */\nint for_each_loose_object(each_loose_object_fn, void *,\n\t\t\t  enum for_each_object_flags flags);\n\n/*\n * Iterate over all accessible packed objects without respect to reachability.\n * By default, this includes both local and alternate packs.\n *\n * Note that some objects may appear twice if they are found in multiple packs.\n * Each pack is visited in an unspecified order. By default, objects within a\n * pack are visited in pack-idx order (i.e., sorted by oid).\n */\ntypedef int each_packed_object_fn(const struct object_id *oid,\n\t\t\t\t  struct packed_git *pack,\n\t\t\t\t  uint32_t pos,\n\t\t\t\t  void *data);\nint for_each_object_in_pack(struct packed_git *p,\n\t\t\t    each_packed_object_fn, void *data,\n\t\t\t    enum for_each_object_flags flags);\nint for_each_packed_object(each_packed_object_fn, void *,\n\t\t\t   enum for_each_object_flags flags);\n\n#endif /* OBJECT_STORE_H */\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00a64622e664a5aeb4d16bb785a334c7b9ca0f10",
  "sha1_ok": true,
  "size": 11636
}
