{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAicGt0LWxpbmUuaCIKI2luY2x1ZGUgInV0ZjguaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgInJldmlzaW9uLmgiCiNpbmNsdWRlICJub3Rlcy5oIgojaW5jbHVkZSAiZ3BnLWludGVyZmFjZS5oIgojaW5jbHVkZSAibWVyZ2Vzb3J0LmgiCiNpbmNsdWRlICJjb21taXQtc2xhYi5oIgojaW5jbHVkZSAicHJpby1xdWV1ZS5oIgojaW5jbHVkZSAic2hhMS1sb29rdXAuaCIKI2luY2x1ZGUgInd0LXN0YXR1cy5oIgoKc3RhdGljIHN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpyZWFkX2NvbW1pdF9leHRyYV9oZWFkZXJfbGluZXMoY29uc3QgY2hhciAqYnVmLCBzaXplX3QgbGVuLCBjb25zdCBjaGFyICoqKTsKCmludCBzYXZlX2NvbW1pdF9idWZmZXIgPSAxOwoKY29uc3QgY2hhciAqY29tbWl0X3R5cGUgPSAiY29tbWl0IjsKCnN0cnVjdCBjb21taXQgKmxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCQkJICAgICAgaW50IHF1aWV0KQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmogPSBkZXJlZl90YWcocGFyc2Vfb2JqZWN0KG9pZCksIE5VTEwsIDApOwoKCWlmICghb2JqKQoJCXJldHVybiBOVUxMOwoJcmV0dXJuIG9iamVjdF9hc190eXBlKG9iaiwgT0JKX0NPTU1JVCwgcXVpZXQpOwp9CgpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0X3JlZmVyZW5jZShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXJldHVybiBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkob2lkLCAwKTsKfQoKc3RydWN0IGNvbW1pdCAqbG9va3VwX2NvbW1pdF9vcl9kaWUoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBjb25zdCBjaGFyICpyZWZfbmFtZSkKewoJc3RydWN0IGNvbW1pdCAqYyA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlKG9pZCk7CglpZiAoIWMpCgkJZGllKF8oImNvdWxkIG5vdCBwYXJzZSAlcyIpLCByZWZfbmFtZSk7CglpZiAob2lkY21wKG9pZCwgJmMtPm9iamVjdC5vaWQpKSB7CgkJd2FybmluZyhfKCIlcyAlcyBpcyBub3QgYSBjb21taXQhIiksCgkJCXJlZl9uYW1lLCBvaWRfdG9faGV4KG9pZCkpOwoJfQoJcmV0dXJuIGM7Cn0KCnN0cnVjdCBjb21taXQgKmxvb2t1cF9jb21taXQoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmogPSBsb29rdXBfb2JqZWN0KG9pZC0+aGFzaCk7CglpZiAoIW9iaikKCQlyZXR1cm4gY3JlYXRlX29iamVjdChvaWQtPmhhc2gsIGFsbG9jX2NvbW1pdF9ub2RlKCkpOwoJcmV0dXJuIG9iamVjdF9hc190eXBlKG9iaiwgT0JKX0NPTU1JVCwgMCk7Cn0KCnN0cnVjdCBjb21taXQgKmxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2J5X25hbWUoY29uc3QgY2hhciAqbmFtZSkKewoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgoJaWYgKGdldF9vaWRfY29tbWl0dGlzaChuYW1lLCAmb2lkKSkKCQlyZXR1cm4gTlVMTDsKCWNvbW1pdCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlKCZvaWQpOwoJaWYgKHBhcnNlX2NvbW1pdChjb21taXQpKQoJCXJldHVybiBOVUxMOwoJcmV0dXJuIGNvbW1pdDsKfQoKc3RhdGljIHRpbWVzdGFtcF90IHBhcnNlX2NvbW1pdF9kYXRlKGNvbnN0IGNoYXIgKmJ1ZiwgY29uc3QgY2hhciAqdGFpbCkKewoJY29uc3QgY2hhciAqZGF0ZXB0cjsKCglpZiAoYnVmICsgNiA+PSB0YWlsKQoJCXJldHVybiAwOwoJaWYgKG1lbWNtcChidWYsICJhdXRob3IiLCA2KSkKCQlyZXR1cm4gMDsKCXdoaWxlIChidWYgPCB0YWlsICYmICpidWYrKyAhPSAnXG4nKQoJCS8qIG5hZGEgKi87CglpZiAoYnVmICsgOSA+PSB0YWlsKQoJCXJldHVybiAwOwoJaWYgKG1lbWNtcChidWYsICJjb21taXR0ZXIiLCA5KSkKCQlyZXR1cm4gMDsKCXdoaWxlIChidWYgPCB0YWlsICYmICpidWYrKyAhPSAnPicpCgkJLyogbmFkYSAqLzsKCWlmIChidWYgPj0gdGFpbCkKCQlyZXR1cm4gMDsKCWRhdGVwdHIgPSBidWY7Cgl3aGlsZSAoYnVmIDwgdGFpbCAmJiAqYnVmKysgIT0gJ1xuJykKCQkvKiBuYWRhICovOwoJaWYgKGJ1ZiA+PSB0YWlsKQoJCXJldHVybiAwOwoJLyogZGF0ZXB0ciA8IGJ1ZiAmJiBidWZbLTFdID09ICdcbicsIHNvIHBhcnNpbmcgd2lsbCBzdG9wIGF0IGJ1Zi0xICovCglyZXR1cm4gcGFyc2VfdGltZXN0YW1wKGRhdGVwdHIsIE5VTEwsIDEwKTsKfQoKc3RhdGljIHN0cnVjdCBjb21taXRfZ3JhZnQgKipjb21taXRfZ3JhZnQ7CnN0YXRpYyBpbnQgY29tbWl0X2dyYWZ0X2FsbG9jLCBjb21taXRfZ3JhZnRfbnI7CgpzdGF0aWMgY29uc3QgdW5zaWduZWQgY2hhciAqY29tbWl0X2dyYWZ0X3NoYTFfYWNjZXNzKHNpemVfdCBpbmRleCwgdm9pZCAqdGFibGUpCnsKCXN0cnVjdCBjb21taXRfZ3JhZnQgKipjb21taXRfZ3JhZnRfdGFibGUgPSB0YWJsZTsKCXJldHVybiBjb21taXRfZ3JhZnRfdGFibGVbaW5kZXhdLT5vaWQuaGFzaDsKfQoKc3RhdGljIGludCBjb21taXRfZ3JhZnRfcG9zKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXJldHVybiBzaGExX3BvcyhzaGExLCBjb21taXRfZ3JhZnQsIGNvbW1pdF9ncmFmdF9uciwKCQkJY29tbWl0X2dyYWZ0X3NoYTFfYWNjZXNzKTsKfQoKaW50IHJlZ2lzdGVyX2NvbW1pdF9ncmFmdChzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpncmFmdCwgaW50IGlnbm9yZV9kdXBzKQp7CglpbnQgcG9zID0gY29tbWl0X2dyYWZ0X3BvcyhncmFmdC0+b2lkLmhhc2gpOwoKCWlmICgwIDw9IHBvcykgewoJCWlmIChpZ25vcmVfZHVwcykKCQkJZnJlZShncmFmdCk7CgkJZWxzZSB7CgkJCWZyZWUoY29tbWl0X2dyYWZ0W3Bvc10pOwoJCQljb21taXRfZ3JhZnRbcG9zXSA9IGdyYWZ0OwoJCX0KCQlyZXR1cm4gMTsKCX0KCXBvcyA9IC1wb3MgLSAxOwoJQUxMT0NfR1JPVyhjb21taXRfZ3JhZnQsIGNvbW1pdF9ncmFmdF9uciArIDEsIGNvbW1pdF9ncmFmdF9hbGxvYyk7Cgljb21taXRfZ3JhZnRfbnIrKzsKCWlmIChwb3MgPCBjb21taXRfZ3JhZnRfbnIpCgkJTU9WRV9BUlJBWShjb21taXRfZ3JhZnQgKyBwb3MgKyAxLCBjb21taXRfZ3JhZnQgKyBwb3MsCgkJCSAgIGNvbW1pdF9ncmFmdF9uciAtIHBvcyAtIDEpOwoJY29tbWl0X2dyYWZ0W3Bvc10gPSBncmFmdDsKCXJldHVybiAwOwp9CgpzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpyZWFkX2dyYWZ0X2xpbmUoc3RydWN0IHN0cmJ1ZiAqbGluZSkKewoJLyogVGhlIGZvcm1hdCBpcyBqdXN0ICJDb21taXQgUGFyZW50MSBQYXJlbnQyIC4uLlxuIiAqLwoJaW50IGksIHBoYXNlOwoJY29uc3QgY2hhciAqdGFpbCA9IE5VTEw7CglzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpncmFmdCA9IE5VTEw7CglzdHJ1Y3Qgb2JqZWN0X2lkIGR1bW15X29pZCwgKm9pZDsKCglzdHJidWZfcnRyaW0obGluZSk7CglpZiAoIWxpbmUtPmxlbiB8fCBsaW5lLT5idWZbMF0gPT0gJyMnKQoJCXJldHVybiBOVUxMOwoJLyoKCSAqIHBoYXNlIDAgdmVyaWZpZXMgbGluZSwgY291bnRzIGhhc2hlcyBpbiBsaW5lIGFuZCBhbGxvY2F0ZXMgZ3JhZnQKCSAqIHBoYXNlIDEgZmlsbHMgZ3JhZnQKCSAqLwoJZm9yIChwaGFzZSA9IDA7IHBoYXNlIDwgMjsgcGhhc2UrKykgewoJCW9pZCA9IGdyYWZ0ID8gJmdyYWZ0LT5vaWQgOiAmZHVtbXlfb2lkOwoJCWlmIChwYXJzZV9vaWRfaGV4KGxpbmUtPmJ1Ziwgb2lkLCAmdGFpbCkpCgkJCWdvdG8gYmFkX2dyYWZ0X2RhdGE7CgkJZm9yIChpID0gMDsgKnRhaWwgIT0gJ1wwJzsgaSsrKSB7CgkJCW9pZCA9IGdyYWZ0ID8gJmdyYWZ0LT5wYXJlbnRbaV0gOiAmZHVtbXlfb2lkOwoJCQlpZiAoIWlzc3BhY2UoKnRhaWwrKykgfHwgcGFyc2Vfb2lkX2hleCh0YWlsLCBvaWQsICZ0YWlsKSkKCQkJCWdvdG8gYmFkX2dyYWZ0X2RhdGE7CgkJfQoJCWlmICghZ3JhZnQpIHsKCQkJZ3JhZnQgPSB4bWFsbG9jKHN0X2FkZChzaXplb2YoKmdyYWZ0KSwKCQkJCQkgICAgICAgc3RfbXVsdChzaXplb2Yoc3RydWN0IG9iamVjdF9pZCksIGkpKSk7CgkJCWdyYWZ0LT5ucl9wYXJlbnQgPSBpOwoJCX0KCX0KCXJldHVybiBncmFmdDsKCmJhZF9ncmFmdF9kYXRhOgoJZXJyb3IoImJhZCBncmFmdCBkYXRhOiAlcyIsIGxpbmUtPmJ1Zik7Cglhc3NlcnQoIWdyYWZ0KTsKCXJldHVybiBOVUxMOwp9CgpzdGF0aWMgaW50IHJlYWRfZ3JhZnRfZmlsZShjb25zdCBjaGFyICpncmFmdF9maWxlKQp7CglGSUxFICpmcCA9IGZvcGVuX29yX3dhcm4oZ3JhZnRfZmlsZSwgInIiKTsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglpZiAoIWZwKQoJCXJldHVybiAtMTsKCXdoaWxlICghc3RyYnVmX2dldHdob2xlbGluZSgmYnVmLCBmcCwgJ1xuJykpIHsKCQkvKiBUaGUgZm9ybWF0IGlzIGp1c3QgIkNvbW1pdCBQYXJlbnQxIFBhcmVudDIgLi4uXG4iICovCgkJc3RydWN0IGNvbW1pdF9ncmFmdCAqZ3JhZnQgPSByZWFkX2dyYWZ0X2xpbmUoJmJ1Zik7CgkJaWYgKCFncmFmdCkKCQkJY29udGludWU7CgkJaWYgKHJlZ2lzdGVyX2NvbW1pdF9ncmFmdChncmFmdCwgMSkpCgkJCWVycm9yKCJkdXBsaWNhdGUgZ3JhZnQgZGF0YTogJXMiLCBidWYuYnVmKTsKCX0KCWZjbG9zZShmcCk7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBwcmVwYXJlX2NvbW1pdF9ncmFmdCh2b2lkKQp7CglzdGF0aWMgaW50IGNvbW1pdF9ncmFmdF9wcmVwYXJlZDsKCWNoYXIgKmdyYWZ0X2ZpbGU7CgoJaWYgKGNvbW1pdF9ncmFmdF9wcmVwYXJlZCkKCQlyZXR1cm47CglncmFmdF9maWxlID0gZ2V0X2dyYWZ0X2ZpbGUoKTsKCXJlYWRfZ3JhZnRfZmlsZShncmFmdF9maWxlKTsKCS8qIG1ha2Ugc3VyZSBzaGFsbG93cyBhcmUgcmVhZCAqLwoJaXNfcmVwb3NpdG9yeV9zaGFsbG93KCk7Cgljb21taXRfZ3JhZnRfcHJlcGFyZWQgPSAxOwp9CgpzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpsb29rdXBfY29tbWl0X2dyYWZ0KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJaW50IHBvczsKCXByZXBhcmVfY29tbWl0X2dyYWZ0KCk7Cglwb3MgPSBjb21taXRfZ3JhZnRfcG9zKG9pZC0+aGFzaCk7CglpZiAocG9zIDwgMCkKCQlyZXR1cm4gTlVMTDsKCXJldHVybiBjb21taXRfZ3JhZnRbcG9zXTsKfQoKaW50IGZvcl9lYWNoX2NvbW1pdF9ncmFmdChlYWNoX2NvbW1pdF9ncmFmdF9mbiBmbiwgdm9pZCAqY2JfZGF0YSkKewoJaW50IGksIHJldDsKCWZvciAoaSA9IHJldCA9IDA7IGkgPCBjb21taXRfZ3JhZnRfbnIgJiYgIXJldDsgaSsrKQoJCXJldCA9IGZuKGNvbW1pdF9ncmFmdFtpXSwgY2JfZGF0YSk7CglyZXR1cm4gcmV0Owp9CgppbnQgdW5yZWdpc3Rlcl9zaGFsbG93KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJaW50IHBvcyA9IGNvbW1pdF9ncmFmdF9wb3Mob2lkLT5oYXNoKTsKCWlmIChwb3MgPCAwKQoJCXJldHVybiAtMTsKCWlmIChwb3MgKyAxIDwgY29tbWl0X2dyYWZ0X25yKQoJCU1PVkVfQVJSQVkoY29tbWl0X2dyYWZ0ICsgcG9zLCBjb21taXRfZ3JhZnQgKyBwb3MgKyAxLAoJCQkgICBjb21taXRfZ3JhZnRfbnIgLSBwb3MgLSAxKTsKCWNvbW1pdF9ncmFmdF9uci0tOwoJcmV0dXJuIDA7Cn0KCnN0cnVjdCBjb21taXRfYnVmZmVyIHsKCXZvaWQgKmJ1ZmZlcjsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKfTsKZGVmaW5lX2NvbW1pdF9zbGFiKGJ1ZmZlcl9zbGFiLCBzdHJ1Y3QgY29tbWl0X2J1ZmZlcik7CnN0YXRpYyBzdHJ1Y3QgYnVmZmVyX3NsYWIgYnVmZmVyX3NsYWIgPSBDT01NSVRfU0xBQl9JTklUKDEsIGJ1ZmZlcl9zbGFiKTsKCnZvaWQgc2V0X2NvbW1pdF9idWZmZXIoc3RydWN0IGNvbW1pdCAqY29tbWl0LCB2b2lkICpidWZmZXIsIHVuc2lnbmVkIGxvbmcgc2l6ZSkKewoJc3RydWN0IGNvbW1pdF9idWZmZXIgKnYgPSBidWZmZXJfc2xhYl9hdCgmYnVmZmVyX3NsYWIsIGNvbW1pdCk7Cgl2LT5idWZmZXIgPSBidWZmZXI7Cgl2LT5zaXplID0gc2l6ZTsKfQoKY29uc3Qgdm9pZCAqZ2V0X2NhY2hlZF9jb21taXRfYnVmZmVyKGNvbnN0IHN0cnVjdCBjb21taXQgKmNvbW1pdCwgdW5zaWduZWQgbG9uZyAqc2l6ZXApCnsKCXN0cnVjdCBjb21taXRfYnVmZmVyICp2ID0gYnVmZmVyX3NsYWJfcGVlaygmYnVmZmVyX3NsYWIsIGNvbW1pdCk7CglpZiAoIXYpIHsKCQlpZiAoc2l6ZXApCgkJCSpzaXplcCA9IDA7CgkJcmV0dXJuIE5VTEw7Cgl9CglpZiAoc2l6ZXApCgkJKnNpemVwID0gdi0+c2l6ZTsKCXJldHVybiB2LT5idWZmZXI7Cn0KCmNvbnN0IHZvaWQgKmdldF9jb21taXRfYnVmZmVyKGNvbnN0IHN0cnVjdCBjb21taXQgKmNvbW1pdCwgdW5zaWduZWQgbG9uZyAqc2l6ZXApCnsKCWNvbnN0IHZvaWQgKnJldCA9IGdldF9jYWNoZWRfY29tbWl0X2J1ZmZlcihjb21taXQsIHNpemVwKTsKCWlmICghcmV0KSB7CgkJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCQlyZXQgPSByZWFkX3NoYTFfZmlsZShjb21taXQtPm9iamVjdC5vaWQuaGFzaCwgJnR5cGUsICZzaXplKTsKCQlpZiAoIXJldCkKCQkJZGllKCJjYW5ub3QgcmVhZCBjb21taXQgb2JqZWN0ICVzIiwKCQkJICAgIG9pZF90b19oZXgoJmNvbW1pdC0+b2JqZWN0Lm9pZCkpOwoJCWlmICh0eXBlICE9IE9CSl9DT01NSVQpCgkJCWRpZSgiZXhwZWN0ZWQgY29tbWl0IGZvciAlcywgZ290ICVzIiwKCQkJICAgIG9pZF90b19oZXgoJmNvbW1pdC0+b2JqZWN0Lm9pZCksIHR5cGVfbmFtZSh0eXBlKSk7CgkJaWYgKHNpemVwKQoJCQkqc2l6ZXAgPSBzaXplOwoJfQoJcmV0dXJuIHJldDsKfQoKdm9pZCB1bnVzZV9jb21taXRfYnVmZmVyKGNvbnN0IHN0cnVjdCBjb21taXQgKmNvbW1pdCwgY29uc3Qgdm9pZCAqYnVmZmVyKQp7CglzdHJ1Y3QgY29tbWl0X2J1ZmZlciAqdiA9IGJ1ZmZlcl9zbGFiX3BlZWsoJmJ1ZmZlcl9zbGFiLCBjb21taXQpOwoJaWYgKCEodiAmJiB2LT5idWZmZXIgPT0gYnVmZmVyKSkKCQlmcmVlKCh2b2lkICopYnVmZmVyKTsKfQoKdm9pZCBmcmVlX2NvbW1pdF9idWZmZXIoc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglzdHJ1Y3QgY29tbWl0X2J1ZmZlciAqdiA9IGJ1ZmZlcl9zbGFiX3BlZWsoJmJ1ZmZlcl9zbGFiLCBjb21taXQpOwoJaWYgKHYpIHsKCQlGUkVFX0FORF9OVUxMKHYtPmJ1ZmZlcik7CgkJdi0+c2l6ZSA9IDA7Cgl9Cn0KCmNvbnN0IHZvaWQgKmRldGFjaF9jb21taXRfYnVmZmVyKHN0cnVjdCBjb21taXQgKmNvbW1pdCwgdW5zaWduZWQgbG9uZyAqc2l6ZXApCnsKCXN0cnVjdCBjb21taXRfYnVmZmVyICp2ID0gYnVmZmVyX3NsYWJfcGVlaygmYnVmZmVyX3NsYWIsIGNvbW1pdCk7Cgl2b2lkICpyZXQ7CgoJaWYgKCF2KSB7CgkJaWYgKHNpemVwKQoJCQkqc2l6ZXAgPSAwOwoJCXJldHVybiBOVUxMOwoJfQoJcmV0ID0gdi0+YnVmZmVyOwoJaWYgKHNpemVwKQoJCSpzaXplcCA9IHYtPnNpemU7CgoJdi0+YnVmZmVyID0gTlVMTDsKCXYtPnNpemUgPSAwOwoJcmV0dXJuIHJldDsKfQoKaW50IHBhcnNlX2NvbW1pdF9idWZmZXIoc3RydWN0IGNvbW1pdCAqaXRlbSwgY29uc3Qgdm9pZCAqYnVmZmVyLCB1bnNpZ25lZCBsb25nIHNpemUpCnsKCWNvbnN0IGNoYXIgKnRhaWwgPSBidWZmZXI7Cgljb25zdCBjaGFyICpidWZwdHIgPSBidWZmZXI7CglzdHJ1Y3Qgb2JqZWN0X2lkIHBhcmVudDsKCXN0cnVjdCBjb21taXRfbGlzdCAqKnBwdHI7CglzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpncmFmdDsKCWNvbnN0IGludCB0cmVlX2VudHJ5X2xlbiA9IEdJVF9TSEExX0hFWFNaICsgNTsKCWNvbnN0IGludCBwYXJlbnRfZW50cnlfbGVuID0gR0lUX1NIQTFfSEVYU1ogKyA3OwoKCWlmIChpdGVtLT5vYmplY3QucGFyc2VkKQoJCXJldHVybiAwOwoJaXRlbS0+b2JqZWN0LnBhcnNlZCA9IDE7Cgl0YWlsICs9IHNpemU7CglpZiAodGFpbCA8PSBidWZwdHIgKyB0cmVlX2VudHJ5X2xlbiArIDEgfHwgbWVtY21wKGJ1ZnB0ciwgInRyZWUgIiwgNSkgfHwKCQkJYnVmcHRyW3RyZWVfZW50cnlfbGVuXSAhPSAnXG4nKQoJCXJldHVybiBlcnJvcigiYm9ndXMgY29tbWl0IG9iamVjdCAlcyIsIG9pZF90b19oZXgoJml0ZW0tPm9iamVjdC5vaWQpKTsKCWlmIChnZXRfc2hhMV9oZXgoYnVmcHRyICsgNSwgcGFyZW50Lmhhc2gpIDwgMCkKCQlyZXR1cm4gZXJyb3IoImJhZCB0cmVlIHBvaW50ZXIgaW4gY29tbWl0ICVzIiwKCQkJICAgICBvaWRfdG9faGV4KCZpdGVtLT5vYmplY3Qub2lkKSk7CglpdGVtLT50cmVlID0gbG9va3VwX3RyZWUoJnBhcmVudCk7CglidWZwdHIgKz0gdHJlZV9lbnRyeV9sZW4gKyAxOyAvKiAidHJlZSAiICsgImhleCBzaGExIiArICJcbiIgKi8KCXBwdHIgPSAmaXRlbS0+cGFyZW50czsKCglncmFmdCA9IGxvb2t1cF9jb21taXRfZ3JhZnQoJml0ZW0tPm9iamVjdC5vaWQpOwoJd2hpbGUgKGJ1ZnB0ciArIHBhcmVudF9lbnRyeV9sZW4gPCB0YWlsICYmICFtZW1jbXAoYnVmcHRyLCAicGFyZW50ICIsIDcpKSB7CgkJc3RydWN0IGNvbW1pdCAqbmV3X3BhcmVudDsKCgkJaWYgKHRhaWwgPD0gYnVmcHRyICsgcGFyZW50X2VudHJ5X2xlbiArIDEgfHwKCQkgICAgZ2V0X3NoYTFfaGV4KGJ1ZnB0ciArIDcsIHBhcmVudC5oYXNoKSB8fAoJCSAgICBidWZwdHJbcGFyZW50X2VudHJ5X2xlbl0gIT0gJ1xuJykKCQkJcmV0dXJuIGVycm9yKCJiYWQgcGFyZW50cyBpbiBjb21taXQgJXMiLCBvaWRfdG9faGV4KCZpdGVtLT5vYmplY3Qub2lkKSk7CgkJYnVmcHRyICs9IHBhcmVudF9lbnRyeV9sZW4gKyAxOwoJCS8qCgkJICogVGhlIGNsb25lIGlzIHNoYWxsb3cgaWYgbnJfcGFyZW50IDwgMCwgYW5kIHdlIG11c3QKCQkgKiBub3QgdHJhdmVyc2UgaXRzIHJlYWwgcGFyZW50cyBldmVuIHdoZW4gd2UgdW5oaWRlIHRoZW0uCgkJICovCgkJaWYgKGdyYWZ0ICYmIChncmFmdC0+bnJfcGFyZW50IDwgMCB8fCBncmFmdHNfcmVwbGFjZV9wYXJlbnRzKSkKCQkJY29udGludWU7CgkJbmV3X3BhcmVudCA9IGxvb2t1cF9jb21taXQoJnBhcmVudCk7CgkJaWYgKG5ld19wYXJlbnQpCgkJCXBwdHIgPSAmY29tbWl0X2xpc3RfaW5zZXJ0KG5ld19wYXJlbnQsIHBwdHIpLT5uZXh0OwoJfQoJaWYgKGdyYWZ0KSB7CgkJaW50IGk7CgkJc3RydWN0IGNvbW1pdCAqbmV3X3BhcmVudDsKCQlmb3IgKGkgPSAwOyBpIDwgZ3JhZnQtPm5yX3BhcmVudDsgaSsrKSB7CgkJCW5ld19wYXJlbnQgPSBsb29rdXBfY29tbWl0KCZncmFmdC0+cGFyZW50W2ldKTsKCQkJaWYgKCFuZXdfcGFyZW50KQoJCQkJY29udGludWU7CgkJCXBwdHIgPSAmY29tbWl0X2xpc3RfaW5zZXJ0KG5ld19wYXJlbnQsIHBwdHIpLT5uZXh0OwoJCX0KCX0KCWl0ZW0tPmRhdGUgPSBwYXJzZV9jb21taXRfZGF0ZShidWZwdHIsIHRhaWwpOwoKCXJldHVybiAwOwp9CgppbnQgcGFyc2VfY29tbWl0X2dlbnRseShzdHJ1Y3QgY29tbWl0ICppdGVtLCBpbnQgcXVpZXRfb25fbWlzc2luZykKewoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJdm9pZCAqYnVmZmVyOwoJdW5zaWduZWQgbG9uZyBzaXplOwoJaW50IHJldDsKCglpZiAoIWl0ZW0pCgkJcmV0dXJuIC0xOwoJaWYgKGl0ZW0tPm9iamVjdC5wYXJzZWQpCgkJcmV0dXJuIDA7CglidWZmZXIgPSByZWFkX3NoYTFfZmlsZShpdGVtLT5vYmplY3Qub2lkLmhhc2gsICZ0eXBlLCAmc2l6ZSk7CglpZiAoIWJ1ZmZlcikKCQlyZXR1cm4gcXVpZXRfb25fbWlzc2luZyA/IC0xIDoKCQkJZXJyb3IoIkNvdWxkIG5vdCByZWFkICVzIiwKCQkJICAgICBvaWRfdG9faGV4KCZpdGVtLT5vYmplY3Qub2lkKSk7CglpZiAodHlwZSAhPSBPQkpfQ09NTUlUKSB7CgkJZnJlZShidWZmZXIpOwoJCXJldHVybiBlcnJvcigiT2JqZWN0ICVzIG5vdCBhIGNvbW1pdCIsCgkJCSAgICAgb2lkX3RvX2hleCgmaXRlbS0+b2JqZWN0Lm9pZCkpOwoJfQoJcmV0ID0gcGFyc2VfY29tbWl0X2J1ZmZlcihpdGVtLCBidWZmZXIsIHNpemUpOwoJaWYgKHNhdmVfY29tbWl0X2J1ZmZlciAmJiAhcmV0KSB7CgkJc2V0X2NvbW1pdF9idWZmZXIoaXRlbSwgYnVmZmVyLCBzaXplKTsKCQlyZXR1cm4gMDsKCX0KCWZyZWUoYnVmZmVyKTsKCXJldHVybiByZXQ7Cn0KCnZvaWQgcGFyc2VfY29tbWl0X29yX2RpZShzdHJ1Y3QgY29tbWl0ICppdGVtKQp7CglpZiAocGFyc2VfY29tbWl0KGl0ZW0pKQoJCWRpZSgidW5hYmxlIHRvIHBhcnNlIGNvbW1pdCAlcyIsCgkJICAgIGl0ZW0gPyBvaWRfdG9faGV4KCZpdGVtLT5vYmplY3Qub2lkKSA6ICIobnVsbCkiKTsKfQoKaW50IGZpbmRfY29tbWl0X3N1YmplY3QoY29uc3QgY2hhciAqY29tbWl0X2J1ZmZlciwgY29uc3QgY2hhciAqKnN1YmplY3QpCnsKCWNvbnN0IGNoYXIgKmVvbDsKCWNvbnN0IGNoYXIgKnAgPSBjb21taXRfYnVmZmVyOwoKCXdoaWxlICgqcCAmJiAoKnAgIT0gJ1xuJyB8fCBwWzFdICE9ICdcbicpKQoJCXArKzsKCWlmICgqcCkgewoJCXAgPSBza2lwX2JsYW5rX2xpbmVzKHAgKyAyKTsKCQllb2wgPSBzdHJjaHJudWwocCwgJ1xuJyk7Cgl9IGVsc2UKCQllb2wgPSBwOwoKCSpzdWJqZWN0ID0gcDsKCglyZXR1cm4gZW9sIC0gcDsKfQoKc3RydWN0IGNvbW1pdF9saXN0ICpjb21taXRfbGlzdF9pbnNlcnQoc3RydWN0IGNvbW1pdCAqaXRlbSwgc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdF9wKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKm5ld19saXN0ID0geG1hbGxvYyhzaXplb2Yoc3RydWN0IGNvbW1pdF9saXN0KSk7CgluZXdfbGlzdC0+aXRlbSA9IGl0ZW07CgluZXdfbGlzdC0+bmV4dCA9ICpsaXN0X3A7CgkqbGlzdF9wID0gbmV3X2xpc3Q7CglyZXR1cm4gbmV3X2xpc3Q7Cn0KCnVuc2lnbmVkIGNvbW1pdF9saXN0X2NvdW50KGNvbnN0IHN0cnVjdCBjb21taXRfbGlzdCAqbCkKewoJdW5zaWduZWQgYyA9IDA7Cglmb3IgKDsgbDsgbCA9IGwtPm5leHQgKQoJCWMrKzsKCXJldHVybiBjOwp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKmNvcHlfY29tbWl0X2xpc3Qoc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0KQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKmhlYWQgPSBOVUxMOwoJc3RydWN0IGNvbW1pdF9saXN0ICoqcHAgPSAmaGVhZDsKCXdoaWxlIChsaXN0KSB7CgkJcHAgPSBjb21taXRfbGlzdF9hcHBlbmQobGlzdC0+aXRlbSwgcHApOwoJCWxpc3QgPSBsaXN0LT5uZXh0OwoJfQoJcmV0dXJuIGhlYWQ7Cn0KCnZvaWQgZnJlZV9jb21taXRfbGlzdChzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QpCnsKCXdoaWxlIChsaXN0KQoJCXBvcF9jb21taXQoJmxpc3QpOwp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKiBjb21taXRfbGlzdF9pbnNlcnRfYnlfZGF0ZShzdHJ1Y3QgY29tbWl0ICppdGVtLCBzdHJ1Y3QgY29tbWl0X2xpc3QgKipsaXN0KQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKipwcCA9IGxpc3Q7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnA7Cgl3aGlsZSAoKHAgPSAqcHApICE9IE5VTEwpIHsKCQlpZiAocC0+aXRlbS0+ZGF0ZSA8IGl0ZW0tPmRhdGUpIHsKCQkJYnJlYWs7CgkJfQoJCXBwID0gJnAtPm5leHQ7Cgl9CglyZXR1cm4gY29tbWl0X2xpc3RfaW5zZXJ0KGl0ZW0sIHBwKTsKfQoKc3RhdGljIGludCBjb21taXRfbGlzdF9jb21wYXJlX2J5X2RhdGUoY29uc3Qgdm9pZCAqYSwgY29uc3Qgdm9pZCAqYikKewoJdGltZXN0YW1wX3QgYV9kYXRlID0gKChjb25zdCBzdHJ1Y3QgY29tbWl0X2xpc3QgKilhKS0+aXRlbS0+ZGF0ZTsKCXRpbWVzdGFtcF90IGJfZGF0ZSA9ICgoY29uc3Qgc3RydWN0IGNvbW1pdF9saXN0ICopYiktPml0ZW0tPmRhdGU7CglpZiAoYV9kYXRlIDwgYl9kYXRlKQoJCXJldHVybiAxOwoJaWYgKGFfZGF0ZSA+IGJfZGF0ZSkKCQlyZXR1cm4gLTE7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgKmNvbW1pdF9saXN0X2dldF9uZXh0KGNvbnN0IHZvaWQgKmEpCnsKCXJldHVybiAoKGNvbnN0IHN0cnVjdCBjb21taXRfbGlzdCAqKWEpLT5uZXh0Owp9CgpzdGF0aWMgdm9pZCBjb21taXRfbGlzdF9zZXRfbmV4dCh2b2lkICphLCB2b2lkICpuZXh0KQp7CgkoKHN0cnVjdCBjb21taXRfbGlzdCAqKWEpLT5uZXh0ID0gbmV4dDsKfQoKdm9pZCBjb21taXRfbGlzdF9zb3J0X2J5X2RhdGUoc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCkKewoJKmxpc3QgPSBsbGlzdF9tZXJnZXNvcnQoKmxpc3QsIGNvbW1pdF9saXN0X2dldF9uZXh0LCBjb21taXRfbGlzdF9zZXRfbmV4dCwKCQkJCWNvbW1pdF9saXN0X2NvbXBhcmVfYnlfZGF0ZSk7Cn0KCnN0cnVjdCBjb21taXQgKnBvcF9tb3N0X3JlY2VudF9jb21taXQoc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCwKCQkJCSAgICAgIHVuc2lnbmVkIGludCBtYXJrKQp7CglzdHJ1Y3QgY29tbWl0ICpyZXQgPSBwb3BfY29tbWl0KGxpc3QpOwoJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzID0gcmV0LT5wYXJlbnRzOwoKCXdoaWxlIChwYXJlbnRzKSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gcGFyZW50cy0+aXRlbTsKCQlpZiAoIXBhcnNlX2NvbW1pdChjb21taXQpICYmICEoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBtYXJrKSkgewoJCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBtYXJrOwoJCQljb21taXRfbGlzdF9pbnNlcnRfYnlfZGF0ZShjb21taXQsIGxpc3QpOwoJCX0KCQlwYXJlbnRzID0gcGFyZW50cy0+bmV4dDsKCX0KCXJldHVybiByZXQ7Cn0KCnN0YXRpYyB2b2lkIGNsZWFyX2NvbW1pdF9tYXJrc18xKHN0cnVjdCBjb21taXRfbGlzdCAqKnBsaXN0LAoJCQkJIHN0cnVjdCBjb21taXQgKmNvbW1pdCwgdW5zaWduZWQgaW50IG1hcmspCnsKCXdoaWxlIChjb21taXQpIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHM7CgoJCWlmICghKG1hcmsgJiBjb21taXQtPm9iamVjdC5mbGFncykpCgkJCXJldHVybjsKCgkJY29tbWl0LT5vYmplY3QuZmxhZ3MgJj0gfm1hcms7CgoJCXBhcmVudHMgPSBjb21taXQtPnBhcmVudHM7CgkJaWYgKCFwYXJlbnRzKQoJCQlyZXR1cm47CgoJCXdoaWxlICgocGFyZW50cyA9IHBhcmVudHMtPm5leHQpKQoJCQljb21taXRfbGlzdF9pbnNlcnQocGFyZW50cy0+aXRlbSwgcGxpc3QpOwoKCQljb21taXQgPSBjb21taXQtPnBhcmVudHMtPml0ZW07Cgl9Cn0KCnZvaWQgY2xlYXJfY29tbWl0X21hcmtzX21hbnkoaW50IG5yLCBzdHJ1Y3QgY29tbWl0ICoqY29tbWl0LCB1bnNpZ25lZCBpbnQgbWFyaykKewoJc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0ID0gTlVMTDsKCgl3aGlsZSAobnItLSkgewoJCWNsZWFyX2NvbW1pdF9tYXJrc18xKCZsaXN0LCAqY29tbWl0LCBtYXJrKTsKCQljb21taXQrKzsKCX0KCXdoaWxlIChsaXN0KQoJCWNsZWFyX2NvbW1pdF9tYXJrc18xKCZsaXN0LCBwb3BfY29tbWl0KCZsaXN0KSwgbWFyayk7Cn0KCnZvaWQgY2xlYXJfY29tbWl0X21hcmtzKHN0cnVjdCBjb21taXQgKmNvbW1pdCwgdW5zaWduZWQgaW50IG1hcmspCnsKCWNsZWFyX2NvbW1pdF9tYXJrc19tYW55KDEsICZjb21taXQsIG1hcmspOwp9CgpzdHJ1Y3QgY29tbWl0ICpwb3BfY29tbWl0KHN0cnVjdCBjb21taXRfbGlzdCAqKnN0YWNrKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnRvcCA9ICpzdGFjazsKCXN0cnVjdCBjb21taXQgKml0ZW0gPSB0b3AgPyB0b3AtPml0ZW0gOiBOVUxMOwoKCWlmICh0b3ApIHsKCQkqc3RhY2sgPSB0b3AtPm5leHQ7CgkJZnJlZSh0b3ApOwoJfQoJcmV0dXJuIGl0ZW07Cn0KCi8qCiAqIFRvcG9sb2dpY2FsIHNvcnQgc3VwcG9ydAogKi8KCi8qIGNvdW50IG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGhhdmUgbm90IGJlZW4gZW1pdHRlZCAqLwpkZWZpbmVfY29tbWl0X3NsYWIoaW5kZWdyZWVfc2xhYiwgaW50KTsKCi8qIHJlY29yZCBhdXRob3ItZGF0ZSBmb3IgZWFjaCBjb21taXQgb2JqZWN0ICovCmRlZmluZV9jb21taXRfc2xhYihhdXRob3JfZGF0ZV9zbGFiLCB1bnNpZ25lZCBsb25nKTsKCnN0YXRpYyB2b2lkIHJlY29yZF9hdXRob3JfZGF0ZShzdHJ1Y3QgYXV0aG9yX2RhdGVfc2xhYiAqYXV0aG9yX2RhdGUsCgkJCSAgICAgICBzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCWNvbnN0IGNoYXIgKmJ1ZmZlciA9IGdldF9jb21taXRfYnVmZmVyKGNvbW1pdCwgTlVMTCk7CglzdHJ1Y3QgaWRlbnRfc3BsaXQgaWRlbnQ7Cgljb25zdCBjaGFyICppZGVudF9saW5lOwoJc2l6ZV90IGlkZW50X2xlbjsKCWNoYXIgKmRhdGVfZW5kOwoJdGltZXN0YW1wX3QgZGF0ZTsKCglpZGVudF9saW5lID0gZmluZF9jb21taXRfaGVhZGVyKGJ1ZmZlciwgImF1dGhvciIsICZpZGVudF9sZW4pOwoJaWYgKCFpZGVudF9saW5lKQoJCWdvdG8gZmFpbF9leGl0OyAvKiBubyBhdXRob3IgbGluZSAqLwoJaWYgKHNwbGl0X2lkZW50X2xpbmUoJmlkZW50LCBpZGVudF9saW5lLCBpZGVudF9sZW4pIHx8CgkgICAgIWlkZW50LmRhdGVfYmVnaW4gfHwgIWlkZW50LmRhdGVfZW5kKQoJCWdvdG8gZmFpbF9leGl0OyAvKiBtYWxmb3JtZWQgImF1dGhvciIgbGluZSAqLwoKCWRhdGUgPSBwYXJzZV90aW1lc3RhbXAoaWRlbnQuZGF0ZV9iZWdpbiwgJmRhdGVfZW5kLCAxMCk7CglpZiAoZGF0ZV9lbmQgIT0gaWRlbnQuZGF0ZV9lbmQpCgkJZ290byBmYWlsX2V4aXQ7IC8qIG1hbGZvcm1lZCBkYXRlICovCgkqKGF1dGhvcl9kYXRlX3NsYWJfYXQoYXV0aG9yX2RhdGUsIGNvbW1pdCkpID0gZGF0ZTsKCmZhaWxfZXhpdDoKCXVudXNlX2NvbW1pdF9idWZmZXIoY29tbWl0LCBidWZmZXIpOwp9CgpzdGF0aWMgaW50IGNvbXBhcmVfY29tbWl0c19ieV9hdXRob3JfZGF0ZShjb25zdCB2b2lkICphXywgY29uc3Qgdm9pZCAqYl8sCgkJCQkJICB2b2lkICpjYl9kYXRhKQp7Cgljb25zdCBzdHJ1Y3QgY29tbWl0ICphID0gYV8sICpiID0gYl87CglzdHJ1Y3QgYXV0aG9yX2RhdGVfc2xhYiAqYXV0aG9yX2RhdGUgPSBjYl9kYXRhOwoJdGltZXN0YW1wX3QgYV9kYXRlID0gKihhdXRob3JfZGF0ZV9zbGFiX2F0KGF1dGhvcl9kYXRlLCBhKSk7Cgl0aW1lc3RhbXBfdCBiX2RhdGUgPSAqKGF1dGhvcl9kYXRlX3NsYWJfYXQoYXV0aG9yX2RhdGUsIGIpKTsKCgkvKiBuZXdlciBjb21taXRzIHdpdGggbGFyZ2VyIGRhdGUgZmlyc3QgKi8KCWlmIChhX2RhdGUgPCBiX2RhdGUpCgkJcmV0dXJuIDE7CgllbHNlIGlmIChhX2RhdGUgPiBiX2RhdGUpCgkJcmV0dXJuIC0xOwoJcmV0dXJuIDA7Cn0KCmludCBjb21wYXJlX2NvbW1pdHNfYnlfY29tbWl0X2RhdGUoY29uc3Qgdm9pZCAqYV8sIGNvbnN0IHZvaWQgKmJfLCB2b2lkICp1bnVzZWQpCnsKCWNvbnN0IHN0cnVjdCBjb21taXQgKmEgPSBhXywgKmIgPSBiXzsKCS8qIG5ld2VyIGNvbW1pdHMgd2l0aCBsYXJnZXIgZGF0ZSBmaXJzdCAqLwoJaWYgKGEtPmRhdGUgPCBiLT5kYXRlKQoJCXJldHVybiAxOwoJZWxzZSBpZiAoYS0+ZGF0ZSA+IGItPmRhdGUpCgkJcmV0dXJuIC0xOwoJcmV0dXJuIDA7Cn0KCi8qCiAqIFBlcmZvcm1zIGFuIGluLXBsYWNlIHRvcG9sb2dpY2FsIHNvcnQgb24gdGhlIGxpc3Qgc3VwcGxpZWQuCiAqLwp2b2lkIHNvcnRfaW5fdG9wb2xvZ2ljYWxfb3JkZXIoc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCwgZW51bSByZXZfc29ydF9vcmRlciBzb3J0X29yZGVyKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKm5leHQsICpvcmlnID0gKmxpc3Q7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKipwcHRyOwoJc3RydWN0IGluZGVncmVlX3NsYWIgaW5kZWdyZWU7CglzdHJ1Y3QgcHJpb19xdWV1ZSBxdWV1ZTsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCXN0cnVjdCBhdXRob3JfZGF0ZV9zbGFiIGF1dGhvcl9kYXRlOwoKCWlmICghb3JpZykKCQlyZXR1cm47CgkqbGlzdCA9IE5VTEw7CgoJaW5pdF9pbmRlZ3JlZV9zbGFiKCZpbmRlZ3JlZSk7CgltZW1zZXQoJnF1ZXVlLCAnXDAnLCBzaXplb2YocXVldWUpKTsKCglzd2l0Y2ggKHNvcnRfb3JkZXIpIHsKCWRlZmF1bHQ6IC8qIFJFVl9TT1JUX0lOX0dSQVBIX09SREVSICovCgkJcXVldWUuY29tcGFyZSA9IE5VTEw7CgkJYnJlYWs7CgljYXNlIFJFVl9TT1JUX0JZX0NPTU1JVF9EQVRFOgoJCXF1ZXVlLmNvbXBhcmUgPSBjb21wYXJlX2NvbW1pdHNfYnlfY29tbWl0X2RhdGU7CgkJYnJlYWs7CgljYXNlIFJFVl9TT1JUX0JZX0FVVEhPUl9EQVRFOgoJCWluaXRfYXV0aG9yX2RhdGVfc2xhYigmYXV0aG9yX2RhdGUpOwoJCXF1ZXVlLmNvbXBhcmUgPSBjb21wYXJlX2NvbW1pdHNfYnlfYXV0aG9yX2RhdGU7CgkJcXVldWUuY2JfZGF0YSA9ICZhdXRob3JfZGF0ZTsKCQlicmVhazsKCX0KCgkvKiBNYXJrIHRoZW0gYW5kIGNsZWFyIHRoZSBpbmRlZ3JlZSAqLwoJZm9yIChuZXh0ID0gb3JpZzsgbmV4dDsgbmV4dCA9IG5leHQtPm5leHQpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBuZXh0LT5pdGVtOwoJCSooaW5kZWdyZWVfc2xhYl9hdCgmaW5kZWdyZWUsIGNvbW1pdCkpID0gMTsKCQkvKiBhbHNvIHJlY29yZCB0aGUgYXV0aG9yIGRhdGVzLCBpZiBuZWVkZWQgKi8KCQlpZiAoc29ydF9vcmRlciA9PSBSRVZfU09SVF9CWV9BVVRIT1JfREFURSkKCQkJcmVjb3JkX2F1dGhvcl9kYXRlKCZhdXRob3JfZGF0ZSwgY29tbWl0KTsKCX0KCgkvKiB1cGRhdGUgdGhlIGluZGVncmVlICovCglmb3IgKG5leHQgPSBvcmlnOyBuZXh0OyBuZXh0ID0gbmV4dC0+bmV4dCkgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50cyA9IG5leHQtPml0ZW0tPnBhcmVudHM7CgkJd2hpbGUgKHBhcmVudHMpIHsKCQkJc3RydWN0IGNvbW1pdCAqcGFyZW50ID0gcGFyZW50cy0+aXRlbTsKCQkJaW50ICpwaSA9IGluZGVncmVlX3NsYWJfYXQoJmluZGVncmVlLCBwYXJlbnQpOwoKCQkJaWYgKCpwaSkKCQkJCSgqcGkpKys7CgkJCXBhcmVudHMgPSBwYXJlbnRzLT5uZXh0OwoJCX0KCX0KCgkvKgoJICogZmluZCB0aGUgdGlwcwoJICoKCSAqIHRpcHMgYXJlIG5vZGVzIG5vdCByZWFjaGFibGUgZnJvbSBhbnkgb3RoZXIgbm9kZSBpbiB0aGUgbGlzdAoJICoKCSAqIHRoZSB0aXBzIHNlcnZlIGFzIGEgc3RhcnRpbmcgc2V0IGZvciB0aGUgd29yayBxdWV1ZS4KCSAqLwoJZm9yIChuZXh0ID0gb3JpZzsgbmV4dDsgbmV4dCA9IG5leHQtPm5leHQpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBuZXh0LT5pdGVtOwoKCQlpZiAoKihpbmRlZ3JlZV9zbGFiX2F0KCZpbmRlZ3JlZSwgY29tbWl0KSkgPT0gMSkKCQkJcHJpb19xdWV1ZV9wdXQoJnF1ZXVlLCBjb21taXQpOwoJfQoKCS8qCgkgKiBUaGlzIGlzIHVuZm9ydHVuYXRlOyB0aGUgaW5pdGlhbCB0aXBzIG5lZWQgdG8gYmUgc2hvd24KCSAqIGluIHRoZSBvcmRlciBnaXZlbiBmcm9tIHRoZSByZXZpc2lvbiB0cmF2ZXJzYWwgbWFjaGluZXJ5LgoJICovCglpZiAoc29ydF9vcmRlciA9PSBSRVZfU09SVF9JTl9HUkFQSF9PUkRFUikKCQlwcmlvX3F1ZXVlX3JldmVyc2UoJnF1ZXVlKTsKCgkvKiBXZSBubyBsb25nZXIgbmVlZCB0aGUgY29tbWl0IGxpc3QgKi8KCWZyZWVfY29tbWl0X2xpc3Qob3JpZyk7CgoJcHB0ciA9IGxpc3Q7CgkqbGlzdCA9IE5VTEw7Cgl3aGlsZSAoKGNvbW1pdCA9IHByaW9fcXVldWVfZ2V0KCZxdWV1ZSkpICE9IE5VTEwpIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHM7CgoJCWZvciAocGFyZW50cyA9IGNvbW1pdC0+cGFyZW50czsgcGFyZW50cyA7IHBhcmVudHMgPSBwYXJlbnRzLT5uZXh0KSB7CgkJCXN0cnVjdCBjb21taXQgKnBhcmVudCA9IHBhcmVudHMtPml0ZW07CgkJCWludCAqcGkgPSBpbmRlZ3JlZV9zbGFiX2F0KCZpbmRlZ3JlZSwgcGFyZW50KTsKCgkJCWlmICghKnBpKQoJCQkJY29udGludWU7CgoJCQkvKgoJCQkgKiBwYXJlbnRzIGFyZSBvbmx5IGVucXVldWVkIGZvciBlbWlzc2lvbgoJCQkgKiB3aGVuIGFsbCB0aGVpciBjaGlsZHJlbiBoYXZlIGJlZW4gZW1pdHRlZCB0aGVyZWJ5CgkJCSAqIGd1YXJhbnRlZWluZyB0b3BvbG9naWNhbCBvcmRlci4KCQkJICovCgkJCWlmICgtLSgqcGkpID09IDEpCgkJCQlwcmlvX3F1ZXVlX3B1dCgmcXVldWUsIHBhcmVudCk7CgkJfQoJCS8qCgkJICogYWxsIGNoaWxkcmVuIG9mIGNvbW1pdCBoYXZlIGFscmVhZHkgYmVlbgoJCSAqIGVtaXR0ZWQuIHdlIGNhbiBlbWl0IGl0IG5vdy4KCQkgKi8KCQkqKGluZGVncmVlX3NsYWJfYXQoJmluZGVncmVlLCBjb21taXQpKSA9IDA7CgoJCXBwdHIgPSAmY29tbWl0X2xpc3RfaW5zZXJ0KGNvbW1pdCwgcHB0ciktPm5leHQ7Cgl9CgoJY2xlYXJfaW5kZWdyZWVfc2xhYigmaW5kZWdyZWUpOwoJY2xlYXJfcHJpb19xdWV1ZSgmcXVldWUpOwoJaWYgKHNvcnRfb3JkZXIgPT0gUkVWX1NPUlRfQllfQVVUSE9SX0RBVEUpCgkJY2xlYXJfYXV0aG9yX2RhdGVfc2xhYigmYXV0aG9yX2RhdGUpOwp9CgovKiBtZXJnZS1iYXNlIHN0dWZmICovCgovKiBSZW1lbWJlciB0byB1cGRhdGUgb2JqZWN0IGZsYWcgYWxsb2NhdGlvbiBpbiBvYmplY3QuaCAqLwojZGVmaW5lIFBBUkVOVDEJCSgxdTw8MTYpCiNkZWZpbmUgUEFSRU5UMgkJKDF1PDwxNykKI2RlZmluZSBTVEFMRQkJKDF1PDwxOCkKI2RlZmluZSBSRVNVTFQJCSgxdTw8MTkpCgpzdGF0aWMgY29uc3QgdW5zaWduZWQgYWxsX2ZsYWdzID0gKFBBUkVOVDEgfCBQQVJFTlQyIHwgU1RBTEUgfCBSRVNVTFQpOwoKc3RhdGljIGludCBxdWV1ZV9oYXNfbm9uc3RhbGUoc3RydWN0IHByaW9fcXVldWUgKnF1ZXVlKQp7CglpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCBxdWV1ZS0+bnI7IGkrKykgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IHF1ZXVlLT5hcnJheVtpXS5kYXRhOwoJCWlmICghKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgU1RBTEUpKQoJCQlyZXR1cm4gMTsKCX0KCXJldHVybiAwOwp9CgovKiBhbGwgaW5wdXQgY29tbWl0cyBpbiBvbmUgYW5kIHR3b3NbXSBtdXN0IGhhdmUgYmVlbiBwYXJzZWQhICovCnN0YXRpYyBzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhaW50X2Rvd25fdG9fY29tbW9uKHN0cnVjdCBjb21taXQgKm9uZSwgaW50IG4sIHN0cnVjdCBjb21taXQgKip0d29zKQp7CglzdHJ1Y3QgcHJpb19xdWV1ZSBxdWV1ZSA9IHsgY29tcGFyZV9jb21taXRzX2J5X2NvbW1pdF9kYXRlIH07CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlc3VsdCA9IE5VTEw7CglpbnQgaTsKCglvbmUtPm9iamVjdC5mbGFncyB8PSBQQVJFTlQxOwoJaWYgKCFuKSB7CgkJY29tbWl0X2xpc3RfYXBwZW5kKG9uZSwgJnJlc3VsdCk7CgkJcmV0dXJuIHJlc3VsdDsKCX0KCXByaW9fcXVldWVfcHV0KCZxdWV1ZSwgb25lKTsKCglmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7CgkJdHdvc1tpXS0+b2JqZWN0LmZsYWdzIHw9IFBBUkVOVDI7CgkJcHJpb19xdWV1ZV9wdXQoJnF1ZXVlLCB0d29zW2ldKTsKCX0KCgl3aGlsZSAocXVldWVfaGFzX25vbnN0YWxlKCZxdWV1ZSkpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBwcmlvX3F1ZXVlX2dldCgmcXVldWUpOwoJCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50czsKCQlpbnQgZmxhZ3M7CgoJCWZsYWdzID0gY29tbWl0LT5vYmplY3QuZmxhZ3MgJiAoUEFSRU5UMSB8IFBBUkVOVDIgfCBTVEFMRSk7CgkJaWYgKGZsYWdzID09IChQQVJFTlQxIHwgUEFSRU5UMikpIHsKCQkJaWYgKCEoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBSRVNVTFQpKSB7CgkJCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBSRVNVTFQ7CgkJCQljb21taXRfbGlzdF9pbnNlcnRfYnlfZGF0ZShjb21taXQsICZyZXN1bHQpOwoJCQl9CgkJCS8qIE1hcmsgcGFyZW50cyBvZiBhIGZvdW5kIG1lcmdlIHN0YWxlICovCgkJCWZsYWdzIHw9IFNUQUxFOwoJCX0KCQlwYXJlbnRzID0gY29tbWl0LT5wYXJlbnRzOwoJCXdoaWxlIChwYXJlbnRzKSB7CgkJCXN0cnVjdCBjb21taXQgKnAgPSBwYXJlbnRzLT5pdGVtOwoJCQlwYXJlbnRzID0gcGFyZW50cy0+bmV4dDsKCQkJaWYgKChwLT5vYmplY3QuZmxhZ3MgJiBmbGFncykgPT0gZmxhZ3MpCgkJCQljb250aW51ZTsKCQkJaWYgKHBhcnNlX2NvbW1pdChwKSkKCQkJCXJldHVybiBOVUxMOwoJCQlwLT5vYmplY3QuZmxhZ3MgfD0gZmxhZ3M7CgkJCXByaW9fcXVldWVfcHV0KCZxdWV1ZSwgcCk7CgkJfQoJfQoKCWNsZWFyX3ByaW9fcXVldWUoJnF1ZXVlKTsKCXJldHVybiByZXN1bHQ7Cn0KCnN0YXRpYyBzdHJ1Y3QgY29tbWl0X2xpc3QgKm1lcmdlX2Jhc2VzX21hbnkoc3RydWN0IGNvbW1pdCAqb25lLCBpbnQgbiwgc3RydWN0IGNvbW1pdCAqKnR3b3MpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCA9IE5VTEw7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlc3VsdCA9IE5VTEw7CglpbnQgaTsKCglmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7CgkJaWYgKG9uZSA9PSB0d29zW2ldKQoJCQkvKgoJCQkgKiBXZSBkbyBub3QgbWFyayB0aGlzIGV2ZW4gd2l0aCBSRVNVTFQgc28gd2UgZG8gbm90CgkJCSAqIGhhdmUgdG8gY2xlYW4gaXQgdXAuCgkJCSAqLwoJCQlyZXR1cm4gY29tbWl0X2xpc3RfaW5zZXJ0KG9uZSwgJnJlc3VsdCk7Cgl9CgoJaWYgKHBhcnNlX2NvbW1pdChvbmUpKQoJCXJldHVybiBOVUxMOwoJZm9yIChpID0gMDsgaSA8IG47IGkrKykgewoJCWlmIChwYXJzZV9jb21taXQodHdvc1tpXSkpCgkJCXJldHVybiBOVUxMOwoJfQoKCWxpc3QgPSBwYWludF9kb3duX3RvX2NvbW1vbihvbmUsIG4sIHR3b3MpOwoKCXdoaWxlIChsaXN0KSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gcG9wX2NvbW1pdCgmbGlzdCk7CgkJaWYgKCEoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBTVEFMRSkpCgkJCWNvbW1pdF9saXN0X2luc2VydF9ieV9kYXRlKGNvbW1pdCwgJnJlc3VsdCk7Cgl9CglyZXR1cm4gcmVzdWx0Owp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9vY3RvcHVzX21lcmdlX2Jhc2VzKHN0cnVjdCBjb21taXRfbGlzdCAqaW4pCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqaSwgKmosICprLCAqcmV0ID0gTlVMTDsKCglpZiAoIWluKQoJCXJldHVybiByZXQ7CgoJY29tbWl0X2xpc3RfaW5zZXJ0KGluLT5pdGVtLCAmcmV0KTsKCglmb3IgKGkgPSBpbi0+bmV4dDsgaTsgaSA9IGktPm5leHQpIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKm5ld19jb21taXRzID0gTlVMTCwgKmVuZCA9IE5VTEw7CgoJCWZvciAoaiA9IHJldDsgajsgaiA9IGotPm5leHQpIHsKCQkJc3RydWN0IGNvbW1pdF9saXN0ICpiYXNlczsKCQkJYmFzZXMgPSBnZXRfbWVyZ2VfYmFzZXMoaS0+aXRlbSwgai0+aXRlbSk7CgkJCWlmICghbmV3X2NvbW1pdHMpCgkJCQluZXdfY29tbWl0cyA9IGJhc2VzOwoJCQllbHNlCgkJCQllbmQtPm5leHQgPSBiYXNlczsKCQkJZm9yIChrID0gYmFzZXM7IGs7IGsgPSBrLT5uZXh0KQoJCQkJZW5kID0gazsKCQl9CgkJcmV0ID0gbmV3X2NvbW1pdHM7Cgl9CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IHJlbW92ZV9yZWR1bmRhbnQoc3RydWN0IGNvbW1pdCAqKmFycmF5LCBpbnQgY250KQp7CgkvKgoJICogU29tZSBjb21taXQgaW4gdGhlIGFycmF5IG1heSBiZSBhbiBhbmNlc3RvciBvZgoJICogYW5vdGhlciBjb21taXQuICBNb3ZlIHN1Y2ggY29tbWl0IHRvIHRoZSBlbmQgb2YKCSAqIHRoZSBhcnJheSwgYW5kIHJldHVybiB0aGUgbnVtYmVyIG9mIGNvbW1pdHMgdGhhdAoJICogYXJlIGluZGVwZW5kZW50IGZyb20gZWFjaCBvdGhlci4KCSAqLwoJc3RydWN0IGNvbW1pdCAqKndvcms7Cgl1bnNpZ25lZCBjaGFyICpyZWR1bmRhbnQ7CglpbnQgKmZpbGxlZF9pbmRleDsKCWludCBpLCBqLCBmaWxsZWQ7CgoJd29yayA9IHhjYWxsb2MoY250LCBzaXplb2YoKndvcmspKTsKCXJlZHVuZGFudCA9IHhjYWxsb2MoY250LCAxKTsKCUFMTE9DX0FSUkFZKGZpbGxlZF9pbmRleCwgY250IC0gMSk7CgoJZm9yIChpID0gMDsgaSA8IGNudDsgaSsrKQoJCXBhcnNlX2NvbW1pdChhcnJheVtpXSk7Cglmb3IgKGkgPSAwOyBpIDwgY250OyBpKyspIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKmNvbW1vbjsKCgkJaWYgKHJlZHVuZGFudFtpXSkKCQkJY29udGludWU7CgkJZm9yIChqID0gZmlsbGVkID0gMDsgaiA8IGNudDsgaisrKSB7CgkJCWlmIChpID09IGogfHwgcmVkdW5kYW50W2pdKQoJCQkJY29udGludWU7CgkJCWZpbGxlZF9pbmRleFtmaWxsZWRdID0gajsKCQkJd29ya1tmaWxsZWQrK10gPSBhcnJheVtqXTsKCQl9CgkJY29tbW9uID0gcGFpbnRfZG93bl90b19jb21tb24oYXJyYXlbaV0sIGZpbGxlZCwgd29yayk7CgkJaWYgKGFycmF5W2ldLT5vYmplY3QuZmxhZ3MgJiBQQVJFTlQyKQoJCQlyZWR1bmRhbnRbaV0gPSAxOwoJCWZvciAoaiA9IDA7IGogPCBmaWxsZWQ7IGorKykKCQkJaWYgKHdvcmtbal0tPm9iamVjdC5mbGFncyAmIFBBUkVOVDEpCgkJCQlyZWR1bmRhbnRbZmlsbGVkX2luZGV4W2pdXSA9IDE7CgkJY2xlYXJfY29tbWl0X21hcmtzKGFycmF5W2ldLCBhbGxfZmxhZ3MpOwoJCWNsZWFyX2NvbW1pdF9tYXJrc19tYW55KGZpbGxlZCwgd29yaywgYWxsX2ZsYWdzKTsKCQlmcmVlX2NvbW1pdF9saXN0KGNvbW1vbik7Cgl9CgoJLyogTm93IGNvbGxlY3QgdGhlIHJlc3VsdCAqLwoJQ09QWV9BUlJBWSh3b3JrLCBhcnJheSwgY250KTsKCWZvciAoaSA9IGZpbGxlZCA9IDA7IGkgPCBjbnQ7IGkrKykKCQlpZiAoIXJlZHVuZGFudFtpXSkKCQkJYXJyYXlbZmlsbGVkKytdID0gd29ya1tpXTsKCWZvciAoaiA9IGZpbGxlZCwgaSA9IDA7IGkgPCBjbnQ7IGkrKykKCQlpZiAocmVkdW5kYW50W2ldKQoJCQlhcnJheVtqKytdID0gd29ya1tpXTsKCWZyZWUod29yayk7CglmcmVlKHJlZHVuZGFudCk7CglmcmVlKGZpbGxlZF9pbmRleCk7CglyZXR1cm4gZmlsbGVkOwp9CgpzdGF0aWMgc3RydWN0IGNvbW1pdF9saXN0ICpnZXRfbWVyZ2VfYmFzZXNfbWFueV8wKHN0cnVjdCBjb21taXQgKm9uZSwKCQkJCQkJICBpbnQgbiwKCQkJCQkJICBzdHJ1Y3QgY29tbWl0ICoqdHdvcywKCQkJCQkJICBpbnQgY2xlYW51cCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0OwoJc3RydWN0IGNvbW1pdCAqKnJzbHQ7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlc3VsdDsKCWludCBjbnQsIGk7CgoJcmVzdWx0ID0gbWVyZ2VfYmFzZXNfbWFueShvbmUsIG4sIHR3b3MpOwoJZm9yIChpID0gMDsgaSA8IG47IGkrKykgewoJCWlmIChvbmUgPT0gdHdvc1tpXSkKCQkJcmV0dXJuIHJlc3VsdDsKCX0KCWlmICghcmVzdWx0IHx8ICFyZXN1bHQtPm5leHQpIHsKCQlpZiAoY2xlYW51cCkgewoJCQljbGVhcl9jb21taXRfbWFya3Mob25lLCBhbGxfZmxhZ3MpOwoJCQljbGVhcl9jb21taXRfbWFya3NfbWFueShuLCB0d29zLCBhbGxfZmxhZ3MpOwoJCX0KCQlyZXR1cm4gcmVzdWx0OwoJfQoKCS8qIFRoZXJlIGFyZSBtb3JlIHRoYW4gb25lICovCgljbnQgPSBjb21taXRfbGlzdF9jb3VudChyZXN1bHQpOwoJcnNsdCA9IHhjYWxsb2MoY250LCBzaXplb2YoKnJzbHQpKTsKCWZvciAobGlzdCA9IHJlc3VsdCwgaSA9IDA7IGxpc3Q7IGxpc3QgPSBsaXN0LT5uZXh0KQoJCXJzbHRbaSsrXSA9IGxpc3QtPml0ZW07CglmcmVlX2NvbW1pdF9saXN0KHJlc3VsdCk7CgoJY2xlYXJfY29tbWl0X21hcmtzKG9uZSwgYWxsX2ZsYWdzKTsKCWNsZWFyX2NvbW1pdF9tYXJrc19tYW55KG4sIHR3b3MsIGFsbF9mbGFncyk7CgoJY250ID0gcmVtb3ZlX3JlZHVuZGFudChyc2x0LCBjbnQpOwoJcmVzdWx0ID0gTlVMTDsKCWZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykKCQljb21taXRfbGlzdF9pbnNlcnRfYnlfZGF0ZShyc2x0W2ldLCAmcmVzdWx0KTsKCWZyZWUocnNsdCk7CglyZXR1cm4gcmVzdWx0Owp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9tZXJnZV9iYXNlc19tYW55KHN0cnVjdCBjb21taXQgKm9uZSwKCQkJCQkgaW50IG4sCgkJCQkJIHN0cnVjdCBjb21taXQgKip0d29zKQp7CglyZXR1cm4gZ2V0X21lcmdlX2Jhc2VzX21hbnlfMChvbmUsIG4sIHR3b3MsIDEpOwp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9tZXJnZV9iYXNlc19tYW55X2RpcnR5KHN0cnVjdCBjb21taXQgKm9uZSwKCQkJCQkgICAgICAgaW50IG4sCgkJCQkJICAgICAgIHN0cnVjdCBjb21taXQgKip0d29zKQp7CglyZXR1cm4gZ2V0X21lcmdlX2Jhc2VzX21hbnlfMChvbmUsIG4sIHR3b3MsIDApOwp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9tZXJnZV9iYXNlcyhzdHJ1Y3QgY29tbWl0ICpvbmUsIHN0cnVjdCBjb21taXQgKnR3bykKewoJcmV0dXJuIGdldF9tZXJnZV9iYXNlc19tYW55XzAob25lLCAxLCAmdHdvLCAxKTsKfQoKLyoKICogSXMgImNvbW1pdCIgYSBkZXNjZW5kYW50IG9mIG9uZSBvZiB0aGUgZWxlbWVudHMgb24gdGhlICJ3aXRoX2NvbW1pdCIgbGlzdD8KICovCmludCBpc19kZXNjZW5kYW50X29mKHN0cnVjdCBjb21taXQgKmNvbW1pdCwgc3RydWN0IGNvbW1pdF9saXN0ICp3aXRoX2NvbW1pdCkKewoJaWYgKCF3aXRoX2NvbW1pdCkKCQlyZXR1cm4gMTsKCXdoaWxlICh3aXRoX2NvbW1pdCkgewoJCXN0cnVjdCBjb21taXQgKm90aGVyOwoKCQlvdGhlciA9IHdpdGhfY29tbWl0LT5pdGVtOwoJCXdpdGhfY29tbWl0ID0gd2l0aF9jb21taXQtPm5leHQ7CgkJaWYgKGluX21lcmdlX2Jhc2VzKG90aGVyLCBjb21taXQpKQoJCQlyZXR1cm4gMTsKCX0KCXJldHVybiAwOwp9CgovKgogKiBJcyAiY29tbWl0IiBhbiBhbmNlc3RvciBvZiBvbmUgb2YgdGhlICJyZWZlcmVuY2VzIj8KICovCmludCBpbl9tZXJnZV9iYXNlc19tYW55KHN0cnVjdCBjb21taXQgKmNvbW1pdCwgaW50IG5yX3JlZmVyZW5jZSwgc3RydWN0IGNvbW1pdCAqKnJlZmVyZW5jZSkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpiYXNlczsKCWludCByZXQgPSAwLCBpOwoKCWlmIChwYXJzZV9jb21taXQoY29tbWl0KSkKCQlyZXR1cm4gcmV0OwoJZm9yIChpID0gMDsgaSA8IG5yX3JlZmVyZW5jZTsgaSsrKQoJCWlmIChwYXJzZV9jb21taXQocmVmZXJlbmNlW2ldKSkKCQkJcmV0dXJuIHJldDsKCgliYXNlcyA9IHBhaW50X2Rvd25fdG9fY29tbW9uKGNvbW1pdCwgbnJfcmVmZXJlbmNlLCByZWZlcmVuY2UpOwoJaWYgKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgUEFSRU5UMikKCQlyZXQgPSAxOwoJY2xlYXJfY29tbWl0X21hcmtzKGNvbW1pdCwgYWxsX2ZsYWdzKTsKCWNsZWFyX2NvbW1pdF9tYXJrc19tYW55KG5yX3JlZmVyZW5jZSwgcmVmZXJlbmNlLCBhbGxfZmxhZ3MpOwoJZnJlZV9jb21taXRfbGlzdChiYXNlcyk7CglyZXR1cm4gcmV0Owp9CgovKgogKiBJcyAiY29tbWl0IiBhbiBhbmNlc3RvciBvZiAoaS5lLiByZWFjaGFibGUgZnJvbSkgdGhlICJyZWZlcmVuY2UiPwogKi8KaW50IGluX21lcmdlX2Jhc2VzKHN0cnVjdCBjb21taXQgKmNvbW1pdCwgc3RydWN0IGNvbW1pdCAqcmVmZXJlbmNlKQp7CglyZXR1cm4gaW5fbWVyZ2VfYmFzZXNfbWFueShjb21taXQsIDEsICZyZWZlcmVuY2UpOwp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlZHVjZV9oZWFkcyhzdHJ1Y3QgY29tbWl0X2xpc3QgKmhlYWRzKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnA7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlc3VsdCA9IE5VTEwsICoqdGFpbCA9ICZyZXN1bHQ7CglzdHJ1Y3QgY29tbWl0ICoqYXJyYXk7CglpbnQgbnVtX2hlYWQsIGk7CgoJaWYgKCFoZWFkcykKCQlyZXR1cm4gTlVMTDsKCgkvKiBVbmlxdWlmeSAqLwoJZm9yIChwID0gaGVhZHM7IHA7IHAgPSBwLT5uZXh0KQoJCXAtPml0ZW0tPm9iamVjdC5mbGFncyAmPSB+U1RBTEU7Cglmb3IgKHAgPSBoZWFkcywgbnVtX2hlYWQgPSAwOyBwOyBwID0gcC0+bmV4dCkgewoJCWlmIChwLT5pdGVtLT5vYmplY3QuZmxhZ3MgJiBTVEFMRSkKCQkJY29udGludWU7CgkJcC0+aXRlbS0+b2JqZWN0LmZsYWdzIHw9IFNUQUxFOwoJCW51bV9oZWFkKys7Cgl9CglhcnJheSA9IHhjYWxsb2MobnVtX2hlYWQsIHNpemVvZigqYXJyYXkpKTsKCWZvciAocCA9IGhlYWRzLCBpID0gMDsgcDsgcCA9IHAtPm5leHQpIHsKCQlpZiAocC0+aXRlbS0+b2JqZWN0LmZsYWdzICYgU1RBTEUpIHsKCQkJYXJyYXlbaSsrXSA9IHAtPml0ZW07CgkJCXAtPml0ZW0tPm9iamVjdC5mbGFncyAmPSB+U1RBTEU7CgkJfQoJfQoJbnVtX2hlYWQgPSByZW1vdmVfcmVkdW5kYW50KGFycmF5LCBudW1faGVhZCk7Cglmb3IgKGkgPSAwOyBpIDwgbnVtX2hlYWQ7IGkrKykKCQl0YWlsID0gJmNvbW1pdF9saXN0X2luc2VydChhcnJheVtpXSwgdGFpbCktPm5leHQ7CglmcmVlKGFycmF5KTsKCXJldHVybiByZXN1bHQ7Cn0KCnZvaWQgcmVkdWNlX2hlYWRzX3JlcGxhY2Uoc3RydWN0IGNvbW1pdF9saXN0ICoqaGVhZHMpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqcmVzdWx0ID0gcmVkdWNlX2hlYWRzKCpoZWFkcyk7CglmcmVlX2NvbW1pdF9saXN0KCpoZWFkcyk7CgkqaGVhZHMgPSByZXN1bHQ7Cn0KCnN0YXRpYyBjb25zdCBjaGFyIGdwZ19zaWdfaGVhZGVyW10gPSAiZ3Bnc2lnIjsKc3RhdGljIGNvbnN0IGludCBncGdfc2lnX2hlYWRlcl9sZW4gPSBzaXplb2YoZ3BnX3NpZ19oZWFkZXIpIC0gMTsKCnN0YXRpYyBpbnQgZG9fc2lnbl9jb21taXQoc3RydWN0IHN0cmJ1ZiAqYnVmLCBjb25zdCBjaGFyICprZXlpZCkKewoJc3RydWN0IHN0cmJ1ZiBzaWcgPSBTVFJCVUZfSU5JVDsKCWludCBpbnNwb3MsIGNvcHlwb3M7Cgljb25zdCBjaGFyICplb2g7CgoJLyogZmluZCB0aGUgZW5kIG9mIHRoZSBoZWFkZXIgKi8KCWVvaCA9IHN0cnN0cihidWYtPmJ1ZiwgIlxuXG4iKTsKCWlmICghZW9oKQoJCWluc3BvcyA9IGJ1Zi0+bGVuOwoJZWxzZQoJCWluc3BvcyA9IGVvaCAtIGJ1Zi0+YnVmICsgMTsKCglpZiAoIWtleWlkIHx8ICEqa2V5aWQpCgkJa2V5aWQgPSBnZXRfc2lnbmluZ19rZXkoKTsKCWlmIChzaWduX2J1ZmZlcihidWYsICZzaWcsIGtleWlkKSkgewoJCXN0cmJ1Zl9yZWxlYXNlKCZzaWcpOwoJCXJldHVybiAtMTsKCX0KCglmb3IgKGNvcHlwb3MgPSAwOyBzaWcuYnVmW2NvcHlwb3NdOyApIHsKCQljb25zdCBjaGFyICpib2wgPSBzaWcuYnVmICsgY29weXBvczsKCQljb25zdCBjaGFyICplb2wgPSBzdHJjaHJudWwoYm9sLCAnXG4nKTsKCQlpbnQgbGVuID0gKGVvbCAtIGJvbCkgKyAhISplb2w7CgoJCWlmICghY29weXBvcykgewoJCQlzdHJidWZfaW5zZXJ0KGJ1ZiwgaW5zcG9zLCBncGdfc2lnX2hlYWRlciwgZ3BnX3NpZ19oZWFkZXJfbGVuKTsKCQkJaW5zcG9zICs9IGdwZ19zaWdfaGVhZGVyX2xlbjsKCQl9CgkJc3RyYnVmX2luc2VydChidWYsIGluc3BvcysrLCAiICIsIDEpOwoJCXN0cmJ1Zl9pbnNlcnQoYnVmLCBpbnNwb3MsIGJvbCwgbGVuKTsKCQlpbnNwb3MgKz0gbGVuOwoJCWNvcHlwb3MgKz0gbGVuOwoJfQoJc3RyYnVmX3JlbGVhc2UoJnNpZyk7CglyZXR1cm4gMDsKfQoKaW50IHBhcnNlX3NpZ25lZF9jb21taXQoY29uc3Qgc3RydWN0IGNvbW1pdCAqY29tbWl0LAoJCQlzdHJ1Y3Qgc3RyYnVmICpwYXlsb2FkLCBzdHJ1Y3Qgc3RyYnVmICpzaWduYXR1cmUpCnsKCgl1bnNpZ25lZCBsb25nIHNpemU7Cgljb25zdCBjaGFyICpidWZmZXIgPSBnZXRfY29tbWl0X2J1ZmZlcihjb21taXQsICZzaXplKTsKCWludCBpbl9zaWduYXR1cmUsIHNhd19zaWduYXR1cmUgPSAtMTsKCWNvbnN0IGNoYXIgKmxpbmUsICp0YWlsOwoKCWxpbmUgPSBidWZmZXI7Cgl0YWlsID0gYnVmZmVyICsgc2l6ZTsKCWluX3NpZ25hdHVyZSA9IDA7CglzYXdfc2lnbmF0dXJlID0gMDsKCXdoaWxlIChsaW5lIDwgdGFpbCkgewoJCWNvbnN0IGNoYXIgKnNpZyA9IE5VTEw7CgkJY29uc3QgY2hhciAqbmV4dCA9IG1lbWNocihsaW5lLCAnXG4nLCB0YWlsIC0gbGluZSk7CgoJCW5leHQgPSBuZXh0ID8gbmV4dCArIDEgOiB0YWlsOwoJCWlmIChpbl9zaWduYXR1cmUgJiYgbGluZVswXSA9PSAnICcpCgkJCXNpZyA9IGxpbmUgKyAxOwoJCWVsc2UgaWYgKHN0YXJ0c193aXRoKGxpbmUsIGdwZ19zaWdfaGVhZGVyKSAmJgoJCQkgbGluZVtncGdfc2lnX2hlYWRlcl9sZW5dID09ICcgJykKCQkJc2lnID0gbGluZSArIGdwZ19zaWdfaGVhZGVyX2xlbiArIDE7CgkJaWYgKHNpZykgewoJCQlzdHJidWZfYWRkKHNpZ25hdHVyZSwgc2lnLCBuZXh0IC0gc2lnKTsKCQkJc2F3X3NpZ25hdHVyZSA9IDE7CgkJCWluX3NpZ25hdHVyZSA9IDE7CgkJfSBlbHNlIHsKCQkJaWYgKCpsaW5lID09ICdcbicpCgkJCQkvKiBkdW1wIHRoZSB3aG9sZSByZW1haW5kZXIgb2YgdGhlIGJ1ZmZlciAqLwoJCQkJbmV4dCA9IHRhaWw7CgkJCXN0cmJ1Zl9hZGQocGF5bG9hZCwgbGluZSwgbmV4dCAtIGxpbmUpOwoJCQlpbl9zaWduYXR1cmUgPSAwOwoJCX0KCQlsaW5lID0gbmV4dDsKCX0KCXVudXNlX2NvbW1pdF9idWZmZXIoY29tbWl0LCBidWZmZXIpOwoJcmV0dXJuIHNhd19zaWduYXR1cmU7Cn0KCmludCByZW1vdmVfc2lnbmF0dXJlKHN0cnVjdCBzdHJidWYgKmJ1ZikKewoJY29uc3QgY2hhciAqbGluZSA9IGJ1Zi0+YnVmOwoJY29uc3QgY2hhciAqdGFpbCA9IGJ1Zi0+YnVmICsgYnVmLT5sZW47CglpbnQgaW5fc2lnbmF0dXJlID0gMDsKCWNvbnN0IGNoYXIgKnNpZ19zdGFydCA9IE5VTEw7Cgljb25zdCBjaGFyICpzaWdfZW5kID0gTlVMTDsKCgl3aGlsZSAobGluZSA8IHRhaWwpIHsKCQljb25zdCBjaGFyICpuZXh0ID0gbWVtY2hyKGxpbmUsICdcbicsIHRhaWwgLSBsaW5lKTsKCQluZXh0ID0gbmV4dCA/IG5leHQgKyAxIDogdGFpbDsKCgkJaWYgKGluX3NpZ25hdHVyZSAmJiBsaW5lWzBdID09ICcgJykKCQkJc2lnX2VuZCA9IG5leHQ7CgkJZWxzZSBpZiAoc3RhcnRzX3dpdGgobGluZSwgZ3BnX3NpZ19oZWFkZXIpICYmCgkJCSBsaW5lW2dwZ19zaWdfaGVhZGVyX2xlbl0gPT0gJyAnKSB7CgkJCXNpZ19zdGFydCA9IGxpbmU7CgkJCXNpZ19lbmQgPSBuZXh0OwoJCQlpbl9zaWduYXR1cmUgPSAxOwoJCX0gZWxzZSB7CgkJCWlmICgqbGluZSA9PSAnXG4nKQoJCQkJLyogZHVtcCB0aGUgd2hvbGUgcmVtYWluZGVyIG9mIHRoZSBidWZmZXIgKi8KCQkJCW5leHQgPSB0YWlsOwoJCQlpbl9zaWduYXR1cmUgPSAwOwoJCX0KCQlsaW5lID0gbmV4dDsKCX0KCglpZiAoc2lnX3N0YXJ0KQoJCXN0cmJ1Zl9yZW1vdmUoYnVmLCBzaWdfc3RhcnQgLSBidWYtPmJ1Ziwgc2lnX2VuZCAtIHNpZ19zdGFydCk7CgoJcmV0dXJuIHNpZ19zdGFydCAhPSBOVUxMOwp9CgpzdGF0aWMgdm9pZCBoYW5kbGVfc2lnbmVkX3RhZyhzdHJ1Y3QgY29tbWl0ICpwYXJlbnQsIHN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICoqKnRhaWwpCnsKCXN0cnVjdCBtZXJnZV9yZW1vdGVfZGVzYyAqZGVzYzsKCXN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICptZXJnZXRhZzsKCWNoYXIgKmJ1ZjsKCXVuc2lnbmVkIGxvbmcgc2l6ZSwgbGVuOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoKCWRlc2MgPSBtZXJnZV9yZW1vdGVfdXRpbChwYXJlbnQpOwoJaWYgKCFkZXNjIHx8ICFkZXNjLT5vYmopCgkJcmV0dXJuOwoJYnVmID0gcmVhZF9zaGExX2ZpbGUoZGVzYy0+b2JqLT5vaWQuaGFzaCwgJnR5cGUsICZzaXplKTsKCWlmICghYnVmIHx8IHR5cGUgIT0gT0JKX1RBRykKCQlnb3RvIGZyZWVfcmV0dXJuOwoJbGVuID0gcGFyc2Vfc2lnbmF0dXJlKGJ1Ziwgc2l6ZSk7CglpZiAoc2l6ZSA9PSBsZW4pCgkJZ290byBmcmVlX3JldHVybjsKCS8qCgkgKiBXZSBjb3VsZCB2ZXJpZnkgdGhpcyBzaWduYXR1cmUgYW5kIGVpdGhlciBvbWl0IHRoZSB0YWcgd2hlbgoJICogaXQgZG9lcyBub3QgdmFsaWRhdGUsIGJ1dCB0aGUgaW50ZWdyYXRvciBtYXkgbm90IGhhdmUgdGhlCgkgKiBwdWJsaWMga2V5IG9mIHRoZSBzaWduZXIgb2YgdGhlIHRhZyBoZSBpcyBtZXJnaW5nLCB3aGlsZSBhCgkgKiBsYXRlciBhdWRpdG9yIG1heSBoYXZlIGl0IHdoaWxlIGF1ZGl0aW5nLCBzbyBsZXQncyBub3QgcnVuCgkgKiB2ZXJpZnktc2lnbmVkLWJ1ZmZlciBoZXJlIGZvciBub3cuLi4KCSAqCgkgKiBpZiAodmVyaWZ5X3NpZ25lZF9idWZmZXIoYnVmLCBsZW4sIGJ1ZiArIGxlbiwgc2l6ZSAtIGxlbiwgLi4uKSkKCSAqCXdhcm4oIndhcm5pbmc6IHNpZ25lZCB0YWcgdW52ZXJpZmllZC4iKTsKCSAqLwoJbWVyZ2V0YWcgPSB4Y2FsbG9jKDEsIHNpemVvZigqbWVyZ2V0YWcpKTsKCW1lcmdldGFnLT5rZXkgPSB4c3RyZHVwKCJtZXJnZXRhZyIpOwoJbWVyZ2V0YWctPnZhbHVlID0gYnVmOwoJbWVyZ2V0YWctPmxlbiA9IHNpemU7CgoJKip0YWlsID0gbWVyZ2V0YWc7CgkqdGFpbCA9ICZtZXJnZXRhZy0+bmV4dDsKCXJldHVybjsKCmZyZWVfcmV0dXJuOgoJZnJlZShidWYpOwp9CgppbnQgY2hlY2tfY29tbWl0X3NpZ25hdHVyZShjb25zdCBzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHN0cnVjdCBzaWduYXR1cmVfY2hlY2sgKnNpZ2MpCnsKCXN0cnVjdCBzdHJidWYgcGF5bG9hZCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBzaWduYXR1cmUgPSBTVFJCVUZfSU5JVDsKCWludCByZXQgPSAxOwoKCXNpZ2MtPnJlc3VsdCA9ICdOJzsKCglpZiAocGFyc2Vfc2lnbmVkX2NvbW1pdChjb21taXQsICZwYXlsb2FkLCAmc2lnbmF0dXJlKSA8PSAwKQoJCWdvdG8gb3V0OwoJcmV0ID0gY2hlY2tfc2lnbmF0dXJlKHBheWxvYWQuYnVmLCBwYXlsb2FkLmxlbiwgc2lnbmF0dXJlLmJ1ZiwKCQlzaWduYXR1cmUubGVuLCBzaWdjKTsKCiBvdXQ6CglzdHJidWZfcmVsZWFzZSgmcGF5bG9hZCk7CglzdHJidWZfcmVsZWFzZSgmc2lnbmF0dXJlKTsKCglyZXR1cm4gcmV0Owp9CgoKCnZvaWQgYXBwZW5kX21lcmdlX3RhZ19oZWFkZXJzKHN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50cywKCQkJICAgICAgc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKioqdGFpbCkKewoJd2hpbGUgKHBhcmVudHMpIHsKCQlzdHJ1Y3QgY29tbWl0ICpwYXJlbnQgPSBwYXJlbnRzLT5pdGVtOwoJCWhhbmRsZV9zaWduZWRfdGFnKHBhcmVudCwgdGFpbCk7CgkJcGFyZW50cyA9IHBhcmVudHMtPm5leHQ7Cgl9Cn0KCnN0YXRpYyB2b2lkIGFkZF9leHRyYV9oZWFkZXIoc3RydWN0IHN0cmJ1ZiAqYnVmZmVyLAoJCQkgICAgIHN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpleHRyYSkKewoJc3RyYnVmX2FkZHN0cihidWZmZXIsIGV4dHJhLT5rZXkpOwoJaWYgKGV4dHJhLT5sZW4pCgkJc3RyYnVmX2FkZF9saW5lcyhidWZmZXIsICIgIiwgZXh0cmEtPnZhbHVlLCBleHRyYS0+bGVuKTsKCWVsc2UKCQlzdHJidWZfYWRkY2goYnVmZmVyLCAnXG4nKTsKfQoKc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKnJlYWRfY29tbWl0X2V4dHJhX2hlYWRlcnMoc3RydWN0IGNvbW1pdCAqY29tbWl0LAoJCQkJCQkgICAgICBjb25zdCBjaGFyICoqZXhjbHVkZSkKewoJc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKmV4dHJhID0gTlVMTDsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCWNvbnN0IGNoYXIgKmJ1ZmZlciA9IGdldF9jb21taXRfYnVmZmVyKGNvbW1pdCwgJnNpemUpOwoJZXh0cmEgPSByZWFkX2NvbW1pdF9leHRyYV9oZWFkZXJfbGluZXMoYnVmZmVyLCBzaXplLCBleGNsdWRlKTsKCXVudXNlX2NvbW1pdF9idWZmZXIoY29tbWl0LCBidWZmZXIpOwoJcmV0dXJuIGV4dHJhOwp9Cgp2b2lkIGZvcl9lYWNoX21lcmdldGFnKGVhY2hfbWVyZ2V0YWdfZm4gZm4sIHN0cnVjdCBjb21taXQgKmNvbW1pdCwgdm9pZCAqZGF0YSkKewoJc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKmV4dHJhLCAqdG9fZnJlZTsKCgl0b19mcmVlID0gcmVhZF9jb21taXRfZXh0cmFfaGVhZGVycyhjb21taXQsIE5VTEwpOwoJZm9yIChleHRyYSA9IHRvX2ZyZWU7IGV4dHJhOyBleHRyYSA9IGV4dHJhLT5uZXh0KSB7CgkJaWYgKHN0cmNtcChleHRyYS0+a2V5LCAibWVyZ2V0YWciKSkKCQkJY29udGludWU7IC8qIG5vdCBhIG1lcmdlIHRhZyAqLwoJCWZuKGNvbW1pdCwgZXh0cmEsIGRhdGEpOwoJfQoJZnJlZV9jb21taXRfZXh0cmFfaGVhZGVycyh0b19mcmVlKTsKfQoKc3RhdGljIGlubGluZSBpbnQgc3RhbmRhcmRfaGVhZGVyX2ZpZWxkKGNvbnN0IGNoYXIgKmZpZWxkLCBzaXplX3QgbGVuKQp7CglyZXR1cm4gKChsZW4gPT0gNCAmJiAhbWVtY21wKGZpZWxkLCAidHJlZSIsIDQpKSB8fAoJCShsZW4gPT0gNiAmJiAhbWVtY21wKGZpZWxkLCAicGFyZW50IiwgNikpIHx8CgkJKGxlbiA9PSA2ICYmICFtZW1jbXAoZmllbGQsICJhdXRob3IiLCA2KSkgfHwKCQkobGVuID09IDkgJiYgIW1lbWNtcChmaWVsZCwgImNvbW1pdHRlciIsIDkpKSB8fAoJCShsZW4gPT0gOCAmJiAhbWVtY21wKGZpZWxkLCAiZW5jb2RpbmciLCA4KSkpOwp9CgpzdGF0aWMgaW50IGV4Y2x1ZGVkX2hlYWRlcl9maWVsZChjb25zdCBjaGFyICpmaWVsZCwgc2l6ZV90IGxlbiwgY29uc3QgY2hhciAqKmV4Y2x1ZGUpCnsKCWlmICghZXhjbHVkZSkKCQlyZXR1cm4gMDsKCgl3aGlsZSAoKmV4Y2x1ZGUpIHsKCQlzaXplX3QgeGxlbiA9IHN0cmxlbigqZXhjbHVkZSk7CgkJaWYgKGxlbiA9PSB4bGVuICYmICFtZW1jbXAoZmllbGQsICpleGNsdWRlLCB4bGVuKSkKCQkJcmV0dXJuIDE7CgkJZXhjbHVkZSsrOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqcmVhZF9jb21taXRfZXh0cmFfaGVhZGVyX2xpbmVzKAoJY29uc3QgY2hhciAqYnVmZmVyLCBzaXplX3Qgc2l6ZSwKCWNvbnN0IGNoYXIgKipleGNsdWRlKQp7CglzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqZXh0cmEgPSBOVUxMLCAqKnRhaWwgPSAmZXh0cmEsICppdCA9IE5VTEw7Cgljb25zdCBjaGFyICpsaW5lLCAqbmV4dCwgKmVvZiwgKmVvYjsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJZm9yIChsaW5lID0gYnVmZmVyLCBlb2IgPSBsaW5lICsgc2l6ZTsKCSAgICAgbGluZSA8IGVvYiAmJiAqbGluZSAhPSAnXG4nOwoJICAgICBsaW5lID0gbmV4dCkgewoJCW5leHQgPSBtZW1jaHIobGluZSwgJ1xuJywgZW9iIC0gbGluZSk7CgkJbmV4dCA9IG5leHQgPyBuZXh0ICsgMSA6IGVvYjsKCQlpZiAoKmxpbmUgPT0gJyAnKSB7CgkJCS8qIGNvbnRpbnVhdGlvbiAqLwoJCQlpZiAoaXQpCgkJCQlzdHJidWZfYWRkKCZidWYsIGxpbmUgKyAxLCBuZXh0IC0gKGxpbmUgKyAxKSk7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoaXQpCgkJCWl0LT52YWx1ZSA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgJml0LT5sZW4pOwoJCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCQlpdCA9IE5VTEw7CgoJCWVvZiA9IG1lbWNocihsaW5lLCAnICcsIG5leHQgLSBsaW5lKTsKCQlpZiAoIWVvZikKCQkJZW9mID0gbmV4dDsKCQllbHNlIGlmIChzdGFuZGFyZF9oZWFkZXJfZmllbGQobGluZSwgZW9mIC0gbGluZSkgfHwKCQkJIGV4Y2x1ZGVkX2hlYWRlcl9maWVsZChsaW5lLCBlb2YgLSBsaW5lLCBleGNsdWRlKSkKCQkJY29udGludWU7CgoJCWl0ID0geGNhbGxvYygxLCBzaXplb2YoKml0KSk7CgkJaXQtPmtleSA9IHhtZW1kdXB6KGxpbmUsIGVvZi1saW5lKTsKCQkqdGFpbCA9IGl0OwoJCXRhaWwgPSAmaXQtPm5leHQ7CgkJaWYgKGVvZiArIDEgPCBuZXh0KQoJCQlzdHJidWZfYWRkKCZidWYsIGVvZiArIDEsIG5leHQgLSAoZW9mICsgMSkpOwoJfQoJaWYgKGl0KQoJCWl0LT52YWx1ZSA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgJml0LT5sZW4pOwoJcmV0dXJuIGV4dHJhOwp9Cgp2b2lkIGZyZWVfY29tbWl0X2V4dHJhX2hlYWRlcnMoc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKmV4dHJhKQp7Cgl3aGlsZSAoZXh0cmEpIHsKCQlzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqbmV4dCA9IGV4dHJhLT5uZXh0OwoJCWZyZWUoZXh0cmEtPmtleSk7CgkJZnJlZShleHRyYS0+dmFsdWUpOwoJCWZyZWUoZXh0cmEpOwoJCWV4dHJhID0gbmV4dDsKCX0KfQoKaW50IGNvbW1pdF90cmVlKGNvbnN0IGNoYXIgKm1zZywgc2l6ZV90IG1zZ19sZW4sIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKnRyZWUsCgkJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzLCBzdHJ1Y3Qgb2JqZWN0X2lkICpyZXQsCgkJY29uc3QgY2hhciAqYXV0aG9yLCBjb25zdCBjaGFyICpzaWduX2NvbW1pdCkKewoJc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKmV4dHJhID0gTlVMTCwgKip0YWlsID0gJmV4dHJhOwoJaW50IHJlc3VsdDsKCglhcHBlbmRfbWVyZ2VfdGFnX2hlYWRlcnMocGFyZW50cywgJnRhaWwpOwoJcmVzdWx0ID0gY29tbWl0X3RyZWVfZXh0ZW5kZWQobXNnLCBtc2dfbGVuLCB0cmVlLCBwYXJlbnRzLCByZXQsCgkJCQkgICAgICBhdXRob3IsIHNpZ25fY29tbWl0LCBleHRyYSk7CglmcmVlX2NvbW1pdF9leHRyYV9oZWFkZXJzKGV4dHJhKTsKCXJldHVybiByZXN1bHQ7Cn0KCnN0YXRpYyBpbnQgZmluZF9pbnZhbGlkX3V0ZjgoY29uc3QgY2hhciAqYnVmLCBpbnQgbGVuKQp7CglpbnQgb2Zmc2V0ID0gMDsKCXN0YXRpYyBjb25zdCB1bnNpZ25lZCBpbnQgbWF4X2NvZGVwb2ludFtdID0gewoJCTB4N2YsIDB4N2ZmLCAweGZmZmYsIDB4MTBmZmZmCgl9OwoKCXdoaWxlIChsZW4pIHsKCQl1bnNpZ25lZCBjaGFyIGMgPSAqYnVmKys7CgkJaW50IGJ5dGVzLCBiYWRfb2Zmc2V0OwoJCXVuc2lnbmVkIGludCBjb2RlcG9pbnQ7CgkJdW5zaWduZWQgaW50IG1pbl92YWwsIG1heF92YWw7CgoJCWxlbi0tOwoJCW9mZnNldCsrOwoKCQkvKiBTaW1wbGUgVVMtQVNDSUk/IE5vIHdvcnJpZXMuICovCgkJaWYgKGMgPCAweDgwKQoJCQljb250aW51ZTsKCgkJYmFkX29mZnNldCA9IG9mZnNldC0xOwoKCQkvKgoJCSAqIENvdW50IGhvdyBtYW55IG1vcmUgaGlnaCBiaXRzIHNldDogdGhhdCdzIGhvdwoJCSAqIG1hbnkgbW9yZSBieXRlcyB0aGlzIHNlcXVlbmNlIHNob3VsZCBoYXZlLgoJCSAqLwoJCWJ5dGVzID0gMDsKCQl3aGlsZSAoYyAmIDB4NDApIHsKCQkJYyA8PD0gMTsKCQkJYnl0ZXMrKzsKCQl9CgoJCS8qCgkJICogTXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDMgbW9yZSBieXRlcy4gIExvbmdlciBzZXF1ZW5jZXMgcmVzdWx0IGluCgkJICogY29kZXBvaW50cyBiZXlvbmQgVSsxMEZGRkYsIHdoaWNoIGFyZSBndWFyYW50ZWVkIG5ldmVyIHRvIGV4aXN0LgoJCSAqLwoJCWlmIChieXRlcyA8IDEgfHwgMyA8IGJ5dGVzKQoJCQlyZXR1cm4gYmFkX29mZnNldDsKCgkJLyogRG8gd2UgKmhhdmUqIHRoYXQgbWFueSBieXRlcz8gKi8KCQlpZiAobGVuIDwgYnl0ZXMpCgkJCXJldHVybiBiYWRfb2Zmc2V0OwoKCQkvKgoJCSAqIFBsYWNlIHRoZSBlbmNvZGVkIGJpdHMgYXQgdGhlIGJvdHRvbSBvZiB0aGUgdmFsdWUgYW5kIGNvbXB1dGUgdGhlCgkJICogdmFsaWQgcmFuZ2UuCgkJICovCgkJY29kZXBvaW50ID0gKGMgJiAweDdmKSA+PiBieXRlczsKCQltaW5fdmFsID0gbWF4X2NvZGVwb2ludFtieXRlcy0xXSArIDE7CgkJbWF4X3ZhbCA9IG1heF9jb2RlcG9pbnRbYnl0ZXNdOwoKCQlvZmZzZXQgKz0gYnl0ZXM7CgkJbGVuIC09IGJ5dGVzOwoKCQkvKiBBbmQgdmVyaWZ5IHRoYXQgdGhleSBhcmUgZ29vZCBjb250aW51YXRpb24gYnl0ZXMgKi8KCQlkbyB7CgkJCWNvZGVwb2ludCA8PD0gNjsKCQkJY29kZXBvaW50IHw9ICpidWYgJiAweDNmOwoJCQlpZiAoKCpidWYrKyAmIDB4YzApICE9IDB4ODApCgkJCQlyZXR1cm4gYmFkX29mZnNldDsKCQl9IHdoaWxlICgtLWJ5dGVzKTsKCgkJLyogUmVqZWN0IGNvZGVwb2ludHMgdGhhdCBhcmUgb3V0IG9mIHJhbmdlIGZvciB0aGUgc2VxdWVuY2UgbGVuZ3RoLiAqLwoJCWlmIChjb2RlcG9pbnQgPCBtaW5fdmFsIHx8IGNvZGVwb2ludCA+IG1heF92YWwpCgkJCXJldHVybiBiYWRfb2Zmc2V0OwoJCS8qIFN1cnJvZ2F0ZXMgYXJlIG9ubHkgZm9yIFVURi0xNiBhbmQgY2Fubm90IGJlIGVuY29kZWQgaW4gVVRGLTguICovCgkJaWYgKChjb2RlcG9pbnQgJiAweDFmZjgwMCkgPT0gMHhkODAwKQoJCQlyZXR1cm4gYmFkX29mZnNldDsKCQkvKiBVK3h4RkZGRSBhbmQgVSt4eEZGRkYgYXJlIGd1YXJhbnRlZWQgbm9uLWNoYXJhY3RlcnMuICovCgkJaWYgKChjb2RlcG9pbnQgJiAweGZmZmUpID09IDB4ZmZmZSkKCQkJcmV0dXJuIGJhZF9vZmZzZXQ7CgkJLyogU28gYXJlIGFueXRoaW5nIGluIHRoZSByYW5nZSBVK0ZERDAuLlUrRkRFRi4gKi8KCQlpZiAoY29kZXBvaW50ID49IDB4ZmRkMCAmJiBjb2RlcG9pbnQgPD0gMHhmZGVmKQoJCQlyZXR1cm4gYmFkX29mZnNldDsKCX0KCXJldHVybiAtMTsKfQoKLyoKICogVGhpcyB2ZXJpZmllcyB0aGF0IHRoZSBidWZmZXIgaXMgaW4gcHJvcGVyIHV0ZjggZm9ybWF0LgogKgogKiBJZiBpdCBpc24ndCwgaXQgYXNzdW1lcyBhbnkgbm9uLXV0ZjggY2hhcmFjdGVycyBhcmUgTGF0aW4xLAogKiBhbmQgZG9lcyB0aGUgY29udmVyc2lvbi4KICovCnN0YXRpYyBpbnQgdmVyaWZ5X3V0Zjgoc3RydWN0IHN0cmJ1ZiAqYnVmKQp7CglpbnQgb2sgPSAxOwoJbG9uZyBwb3MgPSAwOwoKCWZvciAoOzspIHsKCQlpbnQgYmFkOwoJCXVuc2lnbmVkIGNoYXIgYzsKCQl1bnNpZ25lZCBjaGFyIHJlcGxhY2VbMl07CgoJCWJhZCA9IGZpbmRfaW52YWxpZF91dGY4KGJ1Zi0+YnVmICsgcG9zLCBidWYtPmxlbiAtIHBvcyk7CgkJaWYgKGJhZCA8IDApCgkJCXJldHVybiBvazsKCQlwb3MgKz0gYmFkOwoJCW9rID0gMDsKCQljID0gYnVmLT5idWZbcG9zXTsKCQlzdHJidWZfcmVtb3ZlKGJ1ZiwgcG9zLCAxKTsKCgkJLyogV2Uga25vdyAnYycgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgMTI4LTI1NSAqLwoJCXJlcGxhY2VbMF0gPSAweGMwICsgKGMgPj4gNik7CgkJcmVwbGFjZVsxXSA9IDB4ODAgKyAoYyAmIDB4M2YpOwoJCXN0cmJ1Zl9pbnNlcnQoYnVmLCBwb3MsIHJlcGxhY2UsIDIpOwoJCXBvcyArPSAyOwoJfQp9CgpzdGF0aWMgY29uc3QgY2hhciBjb21taXRfdXRmOF93YXJuW10gPQpOXygiV2FybmluZzogY29tbWl0IG1lc3NhZ2UgZGlkIG5vdCBjb25mb3JtIHRvIFVURi04LlxuIgogICAiWW91IG1heSB3YW50IHRvIGFtZW5kIGl0IGFmdGVyIGZpeGluZyB0aGUgbWVzc2FnZSwgb3Igc2V0IHRoZSBjb25maWdcbiIKICAgInZhcmlhYmxlIGkxOG4uY29tbWl0ZW5jb2RpbmcgdG8gdGhlIGVuY29kaW5nIHlvdXIgcHJvamVjdCB1c2VzLlxuIik7CgppbnQgY29tbWl0X3RyZWVfZXh0ZW5kZWQoY29uc3QgY2hhciAqbXNnLCBzaXplX3QgbXNnX2xlbiwKCQkJIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKnRyZWUsCgkJCSBzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMsIHN0cnVjdCBvYmplY3RfaWQgKnJldCwKCQkJIGNvbnN0IGNoYXIgKmF1dGhvciwgY29uc3QgY2hhciAqc2lnbl9jb21taXQsCgkJCSBzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqZXh0cmEpCnsKCWludCByZXN1bHQ7CglpbnQgZW5jb2RpbmdfaXNfdXRmODsKCXN0cnVjdCBzdHJidWYgYnVmZmVyOwoKCWFzc2VydF9zaGExX3R5cGUodHJlZS0+aGFzaCwgT0JKX1RSRUUpOwoKCWlmIChtZW1jaHIobXNnLCAnXDAnLCBtc2dfbGVuKSkKCQlyZXR1cm4gZXJyb3IoImEgTlVMIGJ5dGUgaW4gY29tbWl0IGxvZyBtZXNzYWdlIG5vdCBhbGxvd2VkLiIpOwoKCS8qIE5vdCBoYXZpbmcgaTE4bi5jb21taXRlbmNvZGluZyBpcyB0aGUgc2FtZSBhcyBoYXZpbmcgdXRmLTggKi8KCWVuY29kaW5nX2lzX3V0ZjggPSBpc19lbmNvZGluZ191dGY4KGdpdF9jb21taXRfZW5jb2RpbmcpOwoKCXN0cmJ1Zl9pbml0KCZidWZmZXIsIDgxOTIpOyAvKiBzaG91bGQgYXZvaWQgcmVhbGxvY3MgZm9yIHRoZSBoZWFkZXJzICovCglzdHJidWZfYWRkZigmYnVmZmVyLCAidHJlZSAlc1xuIiwgb2lkX3RvX2hleCh0cmVlKSk7CgoJLyoKCSAqIE5PVEUhIFRoaXMgb3JkZXJpbmcgbWVhbnMgdGhhdCB0aGUgc2FtZSBleGFjdCB0cmVlIG1lcmdlZCB3aXRoIGEKCSAqIGRpZmZlcmVudCBvcmRlciBvZiBwYXJlbnRzIHdpbGwgYmUgYSBfZGlmZmVyZW50XyBjaGFuZ2VzZXQgZXZlbgoJICogaWYgZXZlcnl0aGluZyBlbHNlIHN0YXlzIHRoZSBzYW1lLgoJICovCgl3aGlsZSAocGFyZW50cykgewoJCXN0cnVjdCBjb21taXQgKnBhcmVudCA9IHBvcF9jb21taXQoJnBhcmVudHMpOwoJCXN0cmJ1Zl9hZGRmKCZidWZmZXIsICJwYXJlbnQgJXNcbiIsCgkJCSAgICBvaWRfdG9faGV4KCZwYXJlbnQtPm9iamVjdC5vaWQpKTsKCX0KCgkvKiBQZXJzb24vZGF0ZSBpbmZvcm1hdGlvbiAqLwoJaWYgKCFhdXRob3IpCgkJYXV0aG9yID0gZ2l0X2F1dGhvcl9pbmZvKElERU5UX1NUUklDVCk7CglzdHJidWZfYWRkZigmYnVmZmVyLCAiYXV0aG9yICVzXG4iLCBhdXRob3IpOwoJc3RyYnVmX2FkZGYoJmJ1ZmZlciwgImNvbW1pdHRlciAlc1xuIiwgZ2l0X2NvbW1pdHRlcl9pbmZvKElERU5UX1NUUklDVCkpOwoJaWYgKCFlbmNvZGluZ19pc191dGY4KQoJCXN0cmJ1Zl9hZGRmKCZidWZmZXIsICJlbmNvZGluZyAlc1xuIiwgZ2l0X2NvbW1pdF9lbmNvZGluZyk7CgoJd2hpbGUgKGV4dHJhKSB7CgkJYWRkX2V4dHJhX2hlYWRlcigmYnVmZmVyLCBleHRyYSk7CgkJZXh0cmEgPSBleHRyYS0+bmV4dDsKCX0KCXN0cmJ1Zl9hZGRjaCgmYnVmZmVyLCAnXG4nKTsKCgkvKiBBbmQgYWRkIHRoZSBjb21tZW50ICovCglzdHJidWZfYWRkKCZidWZmZXIsIG1zZywgbXNnX2xlbik7CgoJLyogQW5kIGNoZWNrIHRoZSBlbmNvZGluZyAqLwoJaWYgKGVuY29kaW5nX2lzX3V0ZjggJiYgIXZlcmlmeV91dGY4KCZidWZmZXIpKQoJCWZwcmludGYoc3RkZXJyLCBfKGNvbW1pdF91dGY4X3dhcm4pKTsKCglpZiAoc2lnbl9jb21taXQgJiYgZG9fc2lnbl9jb21taXQoJmJ1ZmZlciwgc2lnbl9jb21taXQpKSB7CgkJcmVzdWx0ID0gLTE7CgkJZ290byBvdXQ7Cgl9CgoJcmVzdWx0ID0gd3JpdGVfb2JqZWN0X2ZpbGUoYnVmZmVyLmJ1ZiwgYnVmZmVyLmxlbiwgY29tbWl0X3R5cGUsIHJldCk7Cm91dDoKCXN0cmJ1Zl9yZWxlYXNlKCZidWZmZXIpOwoJcmV0dXJuIHJlc3VsdDsKfQoKdm9pZCBzZXRfbWVyZ2VfcmVtb3RlX2Rlc2Moc3RydWN0IGNvbW1pdCAqY29tbWl0LAoJCQkgICBjb25zdCBjaGFyICpuYW1lLCBzdHJ1Y3Qgb2JqZWN0ICpvYmopCnsKCXN0cnVjdCBtZXJnZV9yZW1vdGVfZGVzYyAqZGVzYzsKCUZMRVhfQUxMT0NfU1RSKGRlc2MsIG5hbWUsIG5hbWUpOwoJZGVzYy0+b2JqID0gb2JqOwoJY29tbWl0LT51dGlsID0gZGVzYzsKfQoKc3RydWN0IGNvbW1pdCAqZ2V0X21lcmdlX3BhcmVudChjb25zdCBjaGFyICpuYW1lKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmo7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCWlmIChnZXRfb2lkKG5hbWUsICZvaWQpKQoJCXJldHVybiBOVUxMOwoJb2JqID0gcGFyc2Vfb2JqZWN0KCZvaWQpOwoJY29tbWl0ID0gKHN0cnVjdCBjb21taXQgKilwZWVsX3RvX3R5cGUobmFtZSwgMCwgb2JqLCBPQkpfQ09NTUlUKTsKCWlmIChjb21taXQgJiYgIWNvbW1pdC0+dXRpbCkKCQlzZXRfbWVyZ2VfcmVtb3RlX2Rlc2MoY29tbWl0LCBuYW1lLCBvYmopOwoJcmV0dXJuIGNvbW1pdDsKfQoKLyoKICogQXBwZW5kIGEgY29tbWl0IHRvIHRoZSBlbmQgb2YgdGhlIGNvbW1pdF9saXN0LgogKgogKiBuZXh0IHN0YXJ0cyBieSBwb2ludGluZyB0byB0aGUgdmFyaWFibGUgdGhhdCBob2xkcyB0aGUgaGVhZCBvZiBhbgogKiBlbXB0eSBjb21taXRfbGlzdCwgYW5kIGlzIHVwZGF0ZWQgdG8gcG9pbnQgdG8gdGhlICJuZXh0IiBmaWVsZCBvZgogKiB0aGUgbGFzdCBpdGVtIG9uIHRoZSBsaXN0IGFzIG5ldyBjb21taXRzIGFyZSBhcHBlbmRlZC4KICoKICogVXNhZ2UgZXhhbXBsZToKICoKICogICAgIHN0cnVjdCBjb21taXRfbGlzdCAqbGlzdDsKICogICAgIHN0cnVjdCBjb21taXRfbGlzdCAqKm5leHQgPSAmbGlzdDsKICoKICogICAgIG5leHQgPSBjb21taXRfbGlzdF9hcHBlbmQoYzEsIG5leHQpOwogKiAgICAgbmV4dCA9IGNvbW1pdF9saXN0X2FwcGVuZChjMiwgbmV4dCk7CiAqICAgICBhc3NlcnQoY29tbWl0X2xpc3RfY291bnQobGlzdCkgPT0gMik7CiAqICAgICByZXR1cm4gbGlzdDsKICovCnN0cnVjdCBjb21taXRfbGlzdCAqKmNvbW1pdF9saXN0X2FwcGVuZChzdHJ1Y3QgY29tbWl0ICpjb21taXQsCgkJCQkJc3RydWN0IGNvbW1pdF9saXN0ICoqbmV4dCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpuZXdfY29tbWl0ID0geG1hbGxvYyhzaXplb2Yoc3RydWN0IGNvbW1pdF9saXN0KSk7CgluZXdfY29tbWl0LT5pdGVtID0gY29tbWl0OwoJKm5leHQgPSBuZXdfY29tbWl0OwoJbmV3X2NvbW1pdC0+bmV4dCA9IE5VTEw7CglyZXR1cm4gJm5ld19jb21taXQtPm5leHQ7Cn0KCmNvbnN0IGNoYXIgKmZpbmRfY29tbWl0X2hlYWRlcihjb25zdCBjaGFyICptc2csIGNvbnN0IGNoYXIgKmtleSwgc2l6ZV90ICpvdXRfbGVuKQp7CglpbnQga2V5X2xlbiA9IHN0cmxlbihrZXkpOwoJY29uc3QgY2hhciAqbGluZSA9IG1zZzsKCgl3aGlsZSAobGluZSkgewoJCWNvbnN0IGNoYXIgKmVvbCA9IHN0cmNocm51bChsaW5lLCAnXG4nKTsKCgkJaWYgKGxpbmUgPT0gZW9sKQoJCQlyZXR1cm4gTlVMTDsKCgkJaWYgKGVvbCAtIGxpbmUgPiBrZXlfbGVuICYmCgkJICAgICFzdHJuY21wKGxpbmUsIGtleSwga2V5X2xlbikgJiYKCQkgICAgbGluZVtrZXlfbGVuXSA9PSAnICcpIHsKCQkJKm91dF9sZW4gPSBlb2wgLSBsaW5lIC0ga2V5X2xlbiAtIDE7CgkJCXJldHVybiBsaW5lICsga2V5X2xlbiArIDE7CgkJfQoJCWxpbmUgPSAqZW9sID8gZW9sICsgMSA6IE5VTEw7Cgl9CglyZXR1cm4gTlVMTDsKfQoKLyoKICogSW5zcGVjdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCBkZXRlcm1pbmUgdGhlIHRydWUgImVuZCIgb2YgdGhlIGxvZyBtZXNzYWdlLCBpbgogKiBvcmRlciB0byBmaW5kIHdoZXJlIHRvIHB1dCBhIG5ldyBTaWduZWQtb2ZmLWJ5OiBsaW5lLiAgSWdub3JlZCBhcmUKICogdHJhaWxpbmcgY29tbWVudCBsaW5lcyBhbmQgYmxhbmsgbGluZXMuICBUbyBzdXBwb3J0ICJnaXQgY29tbWl0IC1zCiAqIC0tYW1lbmQiIG9uIGFuIGV4aXN0aW5nIGNvbW1pdCwgd2UgYWxzbyBpZ25vcmUgIkNvbmZsaWN0czoiLiAgVG8KICogc3VwcG9ydCAiZ2l0IGNvbW1pdCAtdiIsIHdlIHRydW5jYXRlIGF0IGN1dCBsaW5lcy4KICoKICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGZyb20gdGhlIHRhaWwgdG8gaWdub3JlLCB0byBiZSBmZWQgYXMKICogdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gYXBwZW5kX3NpZ25vZmYoKS4KICovCmludCBpZ25vcmVfbm9uX3RyYWlsZXIoY29uc3QgY2hhciAqYnVmLCBzaXplX3QgbGVuKQp7CglpbnQgYm9jID0gMDsKCWludCBib2wgPSAwOwoJaW50IGluX29sZF9jb25mbGljdHNfYmxvY2sgPSAwOwoJc2l6ZV90IGN1dG9mZiA9IHd0X3N0YXR1c19sb2NhdGVfZW5kKGJ1ZiwgbGVuKTsKCgl3aGlsZSAoYm9sIDwgY3V0b2ZmKSB7CgkJY29uc3QgY2hhciAqbmV4dF9saW5lID0gbWVtY2hyKGJ1ZiArIGJvbCwgJ1xuJywgbGVuIC0gYm9sKTsKCgkJaWYgKCFuZXh0X2xpbmUpCgkJCW5leHRfbGluZSA9IGJ1ZiArIGxlbjsKCQllbHNlCgkJCW5leHRfbGluZSsrOwoKCQlpZiAoYnVmW2JvbF0gPT0gY29tbWVudF9saW5lX2NoYXIgfHwgYnVmW2JvbF0gPT0gJ1xuJykgewoJCQkvKiBpcyB0aGlzIHRoZSBmaXJzdCBvZiB0aGUgcnVuIG9mIGNvbW1lbnRzPyAqLwoJCQlpZiAoIWJvYykKCQkJCWJvYyA9IGJvbDsKCQkJLyogb3RoZXJ3aXNlLCBpdCBpcyBqdXN0IGNvbnRpbnVpbmcgKi8KCQl9IGVsc2UgaWYgKHN0YXJ0c193aXRoKGJ1ZiArIGJvbCwgIkNvbmZsaWN0czpcbiIpKSB7CgkJCWluX29sZF9jb25mbGljdHNfYmxvY2sgPSAxOwoJCQlpZiAoIWJvYykKCQkJCWJvYyA9IGJvbDsKCQl9IGVsc2UgaWYgKGluX29sZF9jb25mbGljdHNfYmxvY2sgJiYgYnVmW2JvbF0gPT0gJ1x0JykgewoJCQk7IC8qIGEgcGF0aG5hbWUgaW4gdGhlIGNvbmZsaWN0cyBibG9jayAqLwoJCX0gZWxzZSBpZiAoYm9jKSB7CgkJCS8qIHRoZSBwcmV2aW91cyB3YXMgbm90IHRyYWlsaW5nIGNvbW1lbnQgKi8KCQkJYm9jID0gMDsKCQkJaW5fb2xkX2NvbmZsaWN0c19ibG9jayA9IDA7CgkJfQoJCWJvbCA9IG5leHRfbGluZSAtIGJ1ZjsKCX0KCXJldHVybiBib2MgPyBsZW4gLSBib2MgOiBsZW4gLSBjdXRvZmY7Cn0K",
    "text": "#include \"cache.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"pkt-line.h\"\n#include \"utf8.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"notes.h\"\n#include \"gpg-interface.h\"\n#include \"mergesort.h\"\n#include \"commit-slab.h\"\n#include \"prio-queue.h\"\n#include \"sha1-lookup.h\"\n#include \"wt-status.h\"\n\nstatic struct commit_extra_header *read_commit_extra_header_lines(const char *buf, size_t len, const char **);\n\nint save_commit_buffer = 1;\n\nconst char *commit_type = \"commit\";\n\nstruct commit *lookup_commit_reference_gently(const struct object_id *oid,\n\t\t\t\t\t      int quiet)\n{\n\tstruct object *obj = deref_tag(parse_object(oid), NULL, 0);\n\n\tif (!obj)\n\t\treturn NULL;\n\treturn object_as_type(obj, OBJ_COMMIT, quiet);\n}\n\nstruct commit *lookup_commit_reference(const struct object_id *oid)\n{\n\treturn lookup_commit_reference_gently(oid, 0);\n}\n\nstruct commit *lookup_commit_or_die(const struct object_id *oid, const char *ref_name)\n{\n\tstruct commit *c = lookup_commit_reference(oid);\n\tif (!c)\n\t\tdie(_(\"could not parse %s\"), ref_name);\n\tif (oidcmp(oid, &c->object.oid)) {\n\t\twarning(_(\"%s %s is not a commit!\"),\n\t\t\tref_name, oid_to_hex(oid));\n\t}\n\treturn c;\n}\n\nstruct commit *lookup_commit(const struct object_id *oid)\n{\n\tstruct object *obj = lookup_object(oid->hash);\n\tif (!obj)\n\t\treturn create_object(oid->hash, alloc_commit_node());\n\treturn object_as_type(obj, OBJ_COMMIT, 0);\n}\n\nstruct commit *lookup_commit_reference_by_name(const char *name)\n{\n\tstruct object_id oid;\n\tstruct commit *commit;\n\n\tif (get_oid_committish(name, &oid))\n\t\treturn NULL;\n\tcommit = lookup_commit_reference(&oid);\n\tif (parse_commit(commit))\n\t\treturn NULL;\n\treturn commit;\n}\n\nstatic timestamp_t parse_commit_date(const char *buf, const char *tail)\n{\n\tconst char *dateptr;\n\n\tif (buf + 6 >= tail)\n\t\treturn 0;\n\tif (memcmp(buf, \"author\", 6))\n\t\treturn 0;\n\twhile (buf < tail && *buf++ != '\\n')\n\t\t/* nada */;\n\tif (buf + 9 >= tail)\n\t\treturn 0;\n\tif (memcmp(buf, \"committer\", 9))\n\t\treturn 0;\n\twhile (buf < tail && *buf++ != '>')\n\t\t/* nada */;\n\tif (buf >= tail)\n\t\treturn 0;\n\tdateptr = buf;\n\twhile (buf < tail && *buf++ != '\\n')\n\t\t/* nada */;\n\tif (buf >= tail)\n\t\treturn 0;\n\t/* dateptr < buf && buf[-1] == '\\n', so parsing will stop at buf-1 */\n\treturn parse_timestamp(dateptr, NULL, 10);\n}\n\nstatic struct commit_graft **commit_graft;\nstatic int commit_graft_alloc, commit_graft_nr;\n\nstatic const unsigned char *commit_graft_sha1_access(size_t index, void *table)\n{\n\tstruct commit_graft **commit_graft_table = table;\n\treturn commit_graft_table[index]->oid.hash;\n}\n\nstatic int commit_graft_pos(const unsigned char *sha1)\n{\n\treturn sha1_pos(sha1, commit_graft, commit_graft_nr,\n\t\t\tcommit_graft_sha1_access);\n}\n\nint register_commit_graft(struct commit_graft *graft, int ignore_dups)\n{\n\tint pos = commit_graft_pos(graft->oid.hash);\n\n\tif (0 <= pos) {\n\t\tif (ignore_dups)\n\t\t\tfree(graft);\n\t\telse {\n\t\t\tfree(commit_graft[pos]);\n\t\t\tcommit_graft[pos] = graft;\n\t\t}\n\t\treturn 1;\n\t}\n\tpos = -pos - 1;\n\tALLOC_GROW(commit_graft, commit_graft_nr + 1, commit_graft_alloc);\n\tcommit_graft_nr++;\n\tif (pos < commit_graft_nr)\n\t\tMOVE_ARRAY(commit_graft + pos + 1, commit_graft + pos,\n\t\t\t   commit_graft_nr - pos - 1);\n\tcommit_graft[pos] = graft;\n\treturn 0;\n}\n\nstruct commit_graft *read_graft_line(struct strbuf *line)\n{\n\t/* The format is just \"Commit Parent1 Parent2 ...\\n\" */\n\tint i, phase;\n\tconst char *tail = NULL;\n\tstruct commit_graft *graft = NULL;\n\tstruct object_id dummy_oid, *oid;\n\n\tstrbuf_rtrim(line);\n\tif (!line->len || line->buf[0] == '#')\n\t\treturn NULL;\n\t/*\n\t * phase 0 verifies line, counts hashes in line and allocates graft\n\t * phase 1 fills graft\n\t */\n\tfor (phase = 0; phase < 2; phase++) {\n\t\toid = graft ? &graft->oid : &dummy_oid;\n\t\tif (parse_oid_hex(line->buf, oid, &tail))\n\t\t\tgoto bad_graft_data;\n\t\tfor (i = 0; *tail != '\\0'; i++) {\n\t\t\toid = graft ? &graft->parent[i] : &dummy_oid;\n\t\t\tif (!isspace(*tail++) || parse_oid_hex(tail, oid, &tail))\n\t\t\t\tgoto bad_graft_data;\n\t\t}\n\t\tif (!graft) {\n\t\t\tgraft = xmalloc(st_add(sizeof(*graft),\n\t\t\t\t\t       st_mult(sizeof(struct object_id), i)));\n\t\t\tgraft->nr_parent = i;\n\t\t}\n\t}\n\treturn graft;\n\nbad_graft_data:\n\terror(\"bad graft data: %s\", line->buf);\n\tassert(!graft);\n\treturn NULL;\n}\n\nstatic int read_graft_file(const char *graft_file)\n{\n\tFILE *fp = fopen_or_warn(graft_file, \"r\");\n\tstruct strbuf buf = STRBUF_INIT;\n\tif (!fp)\n\t\treturn -1;\n\twhile (!strbuf_getwholeline(&buf, fp, '\\n')) {\n\t\t/* The format is just \"Commit Parent1 Parent2 ...\\n\" */\n\t\tstruct commit_graft *graft = read_graft_line(&buf);\n\t\tif (!graft)\n\t\t\tcontinue;\n\t\tif (register_commit_graft(graft, 1))\n\t\t\terror(\"duplicate graft data: %s\", buf.buf);\n\t}\n\tfclose(fp);\n\tstrbuf_release(&buf);\n\treturn 0;\n}\n\nstatic void prepare_commit_graft(void)\n{\n\tstatic int commit_graft_prepared;\n\tchar *graft_file;\n\n\tif (commit_graft_prepared)\n\t\treturn;\n\tgraft_file = get_graft_file();\n\tread_graft_file(graft_file);\n\t/* make sure shallows are read */\n\tis_repository_shallow();\n\tcommit_graft_prepared = 1;\n}\n\nstruct commit_graft *lookup_commit_graft(const struct object_id *oid)\n{\n\tint pos;\n\tprepare_commit_graft();\n\tpos = commit_graft_pos(oid->hash);\n\tif (pos < 0)\n\t\treturn NULL;\n\treturn commit_graft[pos];\n}\n\nint for_each_commit_graft(each_commit_graft_fn fn, void *cb_data)\n{\n\tint i, ret;\n\tfor (i = ret = 0; i < commit_graft_nr && !ret; i++)\n\t\tret = fn(commit_graft[i], cb_data);\n\treturn ret;\n}\n\nint unregister_shallow(const struct object_id *oid)\n{\n\tint pos = commit_graft_pos(oid->hash);\n\tif (pos < 0)\n\t\treturn -1;\n\tif (pos + 1 < commit_graft_nr)\n\t\tMOVE_ARRAY(commit_graft + pos, commit_graft + pos + 1,\n\t\t\t   commit_graft_nr - pos - 1);\n\tcommit_graft_nr--;\n\treturn 0;\n}\n\nstruct commit_buffer {\n\tvoid *buffer;\n\tunsigned long size;\n};\ndefine_commit_slab(buffer_slab, struct commit_buffer);\nstatic struct buffer_slab buffer_slab = COMMIT_SLAB_INIT(1, buffer_slab);\n\nvoid set_commit_buffer(struct commit *commit, void *buffer, unsigned long size)\n{\n\tstruct commit_buffer *v = buffer_slab_at(&buffer_slab, commit);\n\tv->buffer = buffer;\n\tv->size = size;\n}\n\nconst void *get_cached_commit_buffer(const struct commit *commit, unsigned long *sizep)\n{\n\tstruct commit_buffer *v = buffer_slab_peek(&buffer_slab, commit);\n\tif (!v) {\n\t\tif (sizep)\n\t\t\t*sizep = 0;\n\t\treturn NULL;\n\t}\n\tif (sizep)\n\t\t*sizep = v->size;\n\treturn v->buffer;\n}\n\nconst void *get_commit_buffer(const struct commit *commit, unsigned long *sizep)\n{\n\tconst void *ret = get_cached_commit_buffer(commit, sizep);\n\tif (!ret) {\n\t\tenum object_type type;\n\t\tunsigned long size;\n\t\tret = read_sha1_file(commit->object.oid.hash, &type, &size);\n\t\tif (!ret)\n\t\t\tdie(\"cannot read commit object %s\",\n\t\t\t    oid_to_hex(&commit->object.oid));\n\t\tif (type != OBJ_COMMIT)\n\t\t\tdie(\"expected commit for %s, got %s\",\n\t\t\t    oid_to_hex(&commit->object.oid), type_name(type));\n\t\tif (sizep)\n\t\t\t*sizep = size;\n\t}\n\treturn ret;\n}\n\nvoid unuse_commit_buffer(const struct commit *commit, const void *buffer)\n{\n\tstruct commit_buffer *v = buffer_slab_peek(&buffer_slab, commit);\n\tif (!(v && v->buffer == buffer))\n\t\tfree((void *)buffer);\n}\n\nvoid free_commit_buffer(struct commit *commit)\n{\n\tstruct commit_buffer *v = buffer_slab_peek(&buffer_slab, commit);\n\tif (v) {\n\t\tFREE_AND_NULL(v->buffer);\n\t\tv->size = 0;\n\t}\n}\n\nconst void *detach_commit_buffer(struct commit *commit, unsigned long *sizep)\n{\n\tstruct commit_buffer *v = buffer_slab_peek(&buffer_slab, commit);\n\tvoid *ret;\n\n\tif (!v) {\n\t\tif (sizep)\n\t\t\t*sizep = 0;\n\t\treturn NULL;\n\t}\n\tret = v->buffer;\n\tif (sizep)\n\t\t*sizep = v->size;\n\n\tv->buffer = NULL;\n\tv->size = 0;\n\treturn ret;\n}\n\nint parse_commit_buffer(struct commit *item, const void *buffer, unsigned long size)\n{\n\tconst char *tail = buffer;\n\tconst char *bufptr = buffer;\n\tstruct object_id parent;\n\tstruct commit_list **pptr;\n\tstruct commit_graft *graft;\n\tconst int tree_entry_len = GIT_SHA1_HEXSZ + 5;\n\tconst int parent_entry_len = GIT_SHA1_HEXSZ + 7;\n\n\tif (item->object.parsed)\n\t\treturn 0;\n\titem->object.parsed = 1;\n\ttail += size;\n\tif (tail <= bufptr + tree_entry_len + 1 || memcmp(bufptr, \"tree \", 5) ||\n\t\t\tbufptr[tree_entry_len] != '\\n')\n\t\treturn error(\"bogus commit object %s\", oid_to_hex(&item->object.oid));\n\tif (get_sha1_hex(bufptr + 5, parent.hash) < 0)\n\t\treturn error(\"bad tree pointer in commit %s\",\n\t\t\t     oid_to_hex(&item->object.oid));\n\titem->tree = lookup_tree(&parent);\n\tbufptr += tree_entry_len + 1; /* \"tree \" + \"hex sha1\" + \"\\n\" */\n\tpptr = &item->parents;\n\n\tgraft = lookup_commit_graft(&item->object.oid);\n\twhile (bufptr + parent_entry_len < tail && !memcmp(bufptr, \"parent \", 7)) {\n\t\tstruct commit *new_parent;\n\n\t\tif (tail <= bufptr + parent_entry_len + 1 ||\n\t\t    get_sha1_hex(bufptr + 7, parent.hash) ||\n\t\t    bufptr[parent_entry_len] != '\\n')\n\t\t\treturn error(\"bad parents in commit %s\", oid_to_hex(&item->object.oid));\n\t\tbufptr += parent_entry_len + 1;\n\t\t/*\n\t\t * The clone is shallow if nr_parent < 0, and we must\n\t\t * not traverse its real parents even when we unhide them.\n\t\t */\n\t\tif (graft && (graft->nr_parent < 0 || grafts_replace_parents))\n\t\t\tcontinue;\n\t\tnew_parent = lookup_commit(&parent);\n\t\tif (new_parent)\n\t\t\tpptr = &commit_list_insert(new_parent, pptr)->next;\n\t}\n\tif (graft) {\n\t\tint i;\n\t\tstruct commit *new_parent;\n\t\tfor (i = 0; i < graft->nr_parent; i++) {\n\t\t\tnew_parent = lookup_commit(&graft->parent[i]);\n\t\t\tif (!new_parent)\n\t\t\t\tcontinue;\n\t\t\tpptr = &commit_list_insert(new_parent, pptr)->next;\n\t\t}\n\t}\n\titem->date = parse_commit_date(bufptr, tail);\n\n\treturn 0;\n}\n\nint parse_commit_gently(struct commit *item, int quiet_on_missing)\n{\n\tenum object_type type;\n\tvoid *buffer;\n\tunsigned long size;\n\tint ret;\n\n\tif (!item)\n\t\treturn -1;\n\tif (item->object.parsed)\n\t\treturn 0;\n\tbuffer = read_sha1_file(item->object.oid.hash, &type, &size);\n\tif (!buffer)\n\t\treturn quiet_on_missing ? -1 :\n\t\t\terror(\"Could not read %s\",\n\t\t\t     oid_to_hex(&item->object.oid));\n\tif (type != OBJ_COMMIT) {\n\t\tfree(buffer);\n\t\treturn error(\"Object %s not a commit\",\n\t\t\t     oid_to_hex(&item->object.oid));\n\t}\n\tret = parse_commit_buffer(item, buffer, size);\n\tif (save_commit_buffer && !ret) {\n\t\tset_commit_buffer(item, buffer, size);\n\t\treturn 0;\n\t}\n\tfree(buffer);\n\treturn ret;\n}\n\nvoid parse_commit_or_die(struct commit *item)\n{\n\tif (parse_commit(item))\n\t\tdie(\"unable to parse commit %s\",\n\t\t    item ? oid_to_hex(&item->object.oid) : \"(null)\");\n}\n\nint find_commit_subject(const char *commit_buffer, const char **subject)\n{\n\tconst char *eol;\n\tconst char *p = commit_buffer;\n\n\twhile (*p && (*p != '\\n' || p[1] != '\\n'))\n\t\tp++;\n\tif (*p) {\n\t\tp = skip_blank_lines(p + 2);\n\t\teol = strchrnul(p, '\\n');\n\t} else\n\t\teol = p;\n\n\t*subject = p;\n\n\treturn eol - p;\n}\n\nstruct commit_list *commit_list_insert(struct commit *item, struct commit_list **list_p)\n{\n\tstruct commit_list *new_list = xmalloc(sizeof(struct commit_list));\n\tnew_list->item = item;\n\tnew_list->next = *list_p;\n\t*list_p = new_list;\n\treturn new_list;\n}\n\nunsigned commit_list_count(const struct commit_list *l)\n{\n\tunsigned c = 0;\n\tfor (; l; l = l->next )\n\t\tc++;\n\treturn c;\n}\n\nstruct commit_list *copy_commit_list(struct commit_list *list)\n{\n\tstruct commit_list *head = NULL;\n\tstruct commit_list **pp = &head;\n\twhile (list) {\n\t\tpp = commit_list_append(list->item, pp);\n\t\tlist = list->next;\n\t}\n\treturn head;\n}\n\nvoid free_commit_list(struct commit_list *list)\n{\n\twhile (list)\n\t\tpop_commit(&list);\n}\n\nstruct commit_list * commit_list_insert_by_date(struct commit *item, struct commit_list **list)\n{\n\tstruct commit_list **pp = list;\n\tstruct commit_list *p;\n\twhile ((p = *pp) != NULL) {\n\t\tif (p->item->date < item->date) {\n\t\t\tbreak;\n\t\t}\n\t\tpp = &p->next;\n\t}\n\treturn commit_list_insert(item, pp);\n}\n\nstatic int commit_list_compare_by_date(const void *a, const void *b)\n{\n\ttimestamp_t a_date = ((const struct commit_list *)a)->item->date;\n\ttimestamp_t b_date = ((const struct commit_list *)b)->item->date;\n\tif (a_date < b_date)\n\t\treturn 1;\n\tif (a_date > b_date)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void *commit_list_get_next(const void *a)\n{\n\treturn ((const struct commit_list *)a)->next;\n}\n\nstatic void commit_list_set_next(void *a, void *next)\n{\n\t((struct commit_list *)a)->next = next;\n}\n\nvoid commit_list_sort_by_date(struct commit_list **list)\n{\n\t*list = llist_mergesort(*list, commit_list_get_next, commit_list_set_next,\n\t\t\t\tcommit_list_compare_by_date);\n}\n\nstruct commit *pop_most_recent_commit(struct commit_list **list,\n\t\t\t\t      unsigned int mark)\n{\n\tstruct commit *ret = pop_commit(list);\n\tstruct commit_list *parents = ret->parents;\n\n\twhile (parents) {\n\t\tstruct commit *commit = parents->item;\n\t\tif (!parse_commit(commit) && !(commit->object.flags & mark)) {\n\t\t\tcommit->object.flags |= mark;\n\t\t\tcommit_list_insert_by_date(commit, list);\n\t\t}\n\t\tparents = parents->next;\n\t}\n\treturn ret;\n}\n\nstatic void clear_commit_marks_1(struct commit_list **plist,\n\t\t\t\t struct commit *commit, unsigned int mark)\n{\n\twhile (commit) {\n\t\tstruct commit_list *parents;\n\n\t\tif (!(mark & commit->object.flags))\n\t\t\treturn;\n\n\t\tcommit->object.flags &= ~mark;\n\n\t\tparents = commit->parents;\n\t\tif (!parents)\n\t\t\treturn;\n\n\t\twhile ((parents = parents->next))\n\t\t\tcommit_list_insert(parents->item, plist);\n\n\t\tcommit = commit->parents->item;\n\t}\n}\n\nvoid clear_commit_marks_many(int nr, struct commit **commit, unsigned int mark)\n{\n\tstruct commit_list *list = NULL;\n\n\twhile (nr--) {\n\t\tclear_commit_marks_1(&list, *commit, mark);\n\t\tcommit++;\n\t}\n\twhile (list)\n\t\tclear_commit_marks_1(&list, pop_commit(&list), mark);\n}\n\nvoid clear_commit_marks(struct commit *commit, unsigned int mark)\n{\n\tclear_commit_marks_many(1, &commit, mark);\n}\n\nstruct commit *pop_commit(struct commit_list **stack)\n{\n\tstruct commit_list *top = *stack;\n\tstruct commit *item = top ? top->item : NULL;\n\n\tif (top) {\n\t\t*stack = top->next;\n\t\tfree(top);\n\t}\n\treturn item;\n}\n\n/*\n * Topological sort support\n */\n\n/* count number of children that have not been emitted */\ndefine_commit_slab(indegree_slab, int);\n\n/* record author-date for each commit object */\ndefine_commit_slab(author_date_slab, unsigned long);\n\nstatic void record_author_date(struct author_date_slab *author_date,\n\t\t\t       struct commit *commit)\n{\n\tconst char *buffer = get_commit_buffer(commit, NULL);\n\tstruct ident_split ident;\n\tconst char *ident_line;\n\tsize_t ident_len;\n\tchar *date_end;\n\ttimestamp_t date;\n\n\tident_line = find_commit_header(buffer, \"author\", &ident_len);\n\tif (!ident_line)\n\t\tgoto fail_exit; /* no author line */\n\tif (split_ident_line(&ident, ident_line, ident_len) ||\n\t    !ident.date_begin || !ident.date_end)\n\t\tgoto fail_exit; /* malformed \"author\" line */\n\n\tdate = parse_timestamp(ident.date_begin, &date_end, 10);\n\tif (date_end != ident.date_end)\n\t\tgoto fail_exit; /* malformed date */\n\t*(author_date_slab_at(author_date, commit)) = date;\n\nfail_exit:\n\tunuse_commit_buffer(commit, buffer);\n}\n\nstatic int compare_commits_by_author_date(const void *a_, const void *b_,\n\t\t\t\t\t  void *cb_data)\n{\n\tconst struct commit *a = a_, *b = b_;\n\tstruct author_date_slab *author_date = cb_data;\n\ttimestamp_t a_date = *(author_date_slab_at(author_date, a));\n\ttimestamp_t b_date = *(author_date_slab_at(author_date, b));\n\n\t/* newer commits with larger date first */\n\tif (a_date < b_date)\n\t\treturn 1;\n\telse if (a_date > b_date)\n\t\treturn -1;\n\treturn 0;\n}\n\nint compare_commits_by_commit_date(const void *a_, const void *b_, void *unused)\n{\n\tconst struct commit *a = a_, *b = b_;\n\t/* newer commits with larger date first */\n\tif (a->date < b->date)\n\t\treturn 1;\n\telse if (a->date > b->date)\n\t\treturn -1;\n\treturn 0;\n}\n\n/*\n * Performs an in-place topological sort on the list supplied.\n */\nvoid sort_in_topological_order(struct commit_list **list, enum rev_sort_order sort_order)\n{\n\tstruct commit_list *next, *orig = *list;\n\tstruct commit_list **pptr;\n\tstruct indegree_slab indegree;\n\tstruct prio_queue queue;\n\tstruct commit *commit;\n\tstruct author_date_slab author_date;\n\n\tif (!orig)\n\t\treturn;\n\t*list = NULL;\n\n\tinit_indegree_slab(&indegree);\n\tmemset(&queue, '\\0', sizeof(queue));\n\n\tswitch (sort_order) {\n\tdefault: /* REV_SORT_IN_GRAPH_ORDER */\n\t\tqueue.compare = NULL;\n\t\tbreak;\n\tcase REV_SORT_BY_COMMIT_DATE:\n\t\tqueue.compare = compare_commits_by_commit_date;\n\t\tbreak;\n\tcase REV_SORT_BY_AUTHOR_DATE:\n\t\tinit_author_date_slab(&author_date);\n\t\tqueue.compare = compare_commits_by_author_date;\n\t\tqueue.cb_data = &author_date;\n\t\tbreak;\n\t}\n\n\t/* Mark them and clear the indegree */\n\tfor (next = orig; next; next = next->next) {\n\t\tstruct commit *commit = next->item;\n\t\t*(indegree_slab_at(&indegree, commit)) = 1;\n\t\t/* also record the author dates, if needed */\n\t\tif (sort_order == REV_SORT_BY_AUTHOR_DATE)\n\t\t\trecord_author_date(&author_date, commit);\n\t}\n\n\t/* update the indegree */\n\tfor (next = orig; next; next = next->next) {\n\t\tstruct commit_list *parents = next->item->parents;\n\t\twhile (parents) {\n\t\t\tstruct commit *parent = parents->item;\n\t\t\tint *pi = indegree_slab_at(&indegree, parent);\n\n\t\t\tif (*pi)\n\t\t\t\t(*pi)++;\n\t\t\tparents = parents->next;\n\t\t}\n\t}\n\n\t/*\n\t * find the tips\n\t *\n\t * tips are nodes not reachable from any other node in the list\n\t *\n\t * the tips serve as a starting set for the work queue.\n\t */\n\tfor (next = orig; next; next = next->next) {\n\t\tstruct commit *commit = next->item;\n\n\t\tif (*(indegree_slab_at(&indegree, commit)) == 1)\n\t\t\tprio_queue_put(&queue, commit);\n\t}\n\n\t/*\n\t * This is unfortunate; the initial tips need to be shown\n\t * in the order given from the revision traversal machinery.\n\t */\n\tif (sort_order == REV_SORT_IN_GRAPH_ORDER)\n\t\tprio_queue_reverse(&queue);\n\n\t/* We no longer need the commit list */\n\tfree_commit_list(orig);\n\n\tpptr = list;\n\t*list = NULL;\n\twhile ((commit = prio_queue_get(&queue)) != NULL) {\n\t\tstruct commit_list *parents;\n\n\t\tfor (parents = commit->parents; parents ; parents = parents->next) {\n\t\t\tstruct commit *parent = parents->item;\n\t\t\tint *pi = indegree_slab_at(&indegree, parent);\n\n\t\t\tif (!*pi)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * parents are only enqueued for emission\n\t\t\t * when all their children have been emitted thereby\n\t\t\t * guaranteeing topological order.\n\t\t\t */\n\t\t\tif (--(*pi) == 1)\n\t\t\t\tprio_queue_put(&queue, parent);\n\t\t}\n\t\t/*\n\t\t * all children of commit have already been\n\t\t * emitted. we can emit it now.\n\t\t */\n\t\t*(indegree_slab_at(&indegree, commit)) = 0;\n\n\t\tpptr = &commit_list_insert(commit, pptr)->next;\n\t}\n\n\tclear_indegree_slab(&indegree);\n\tclear_prio_queue(&queue);\n\tif (sort_order == REV_SORT_BY_AUTHOR_DATE)\n\t\tclear_author_date_slab(&author_date);\n}\n\n/* merge-base stuff */\n\n/* Remember to update object flag allocation in object.h */\n#define PARENT1\t\t(1u<<16)\n#define PARENT2\t\t(1u<<17)\n#define STALE\t\t(1u<<18)\n#define RESULT\t\t(1u<<19)\n\nstatic const unsigned all_flags = (PARENT1 | PARENT2 | STALE | RESULT);\n\nstatic int queue_has_nonstale(struct prio_queue *queue)\n{\n\tint i;\n\tfor (i = 0; i < queue->nr; i++) {\n\t\tstruct commit *commit = queue->array[i].data;\n\t\tif (!(commit->object.flags & STALE))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* all input commits in one and twos[] must have been parsed! */\nstatic struct commit_list *paint_down_to_common(struct commit *one, int n, struct commit **twos)\n{\n\tstruct prio_queue queue = { compare_commits_by_commit_date };\n\tstruct commit_list *result = NULL;\n\tint i;\n\n\tone->object.flags |= PARENT1;\n\tif (!n) {\n\t\tcommit_list_append(one, &result);\n\t\treturn result;\n\t}\n\tprio_queue_put(&queue, one);\n\n\tfor (i = 0; i < n; i++) {\n\t\ttwos[i]->object.flags |= PARENT2;\n\t\tprio_queue_put(&queue, twos[i]);\n\t}\n\n\twhile (queue_has_nonstale(&queue)) {\n\t\tstruct commit *commit = prio_queue_get(&queue);\n\t\tstruct commit_list *parents;\n\t\tint flags;\n\n\t\tflags = commit->object.flags & (PARENT1 | PARENT2 | STALE);\n\t\tif (flags == (PARENT1 | PARENT2)) {\n\t\t\tif (!(commit->object.flags & RESULT)) {\n\t\t\t\tcommit->object.flags |= RESULT;\n\t\t\t\tcommit_list_insert_by_date(commit, &result);\n\t\t\t}\n\t\t\t/* Mark parents of a found merge stale */\n\t\t\tflags |= STALE;\n\t\t}\n\t\tparents = commit->parents;\n\t\twhile (parents) {\n\t\t\tstruct commit *p = parents->item;\n\t\t\tparents = parents->next;\n\t\t\tif ((p->object.flags & flags) == flags)\n\t\t\t\tcontinue;\n\t\t\tif (parse_commit(p))\n\t\t\t\treturn NULL;\n\t\t\tp->object.flags |= flags;\n\t\t\tprio_queue_put(&queue, p);\n\t\t}\n\t}\n\n\tclear_prio_queue(&queue);\n\treturn result;\n}\n\nstatic struct commit_list *merge_bases_many(struct commit *one, int n, struct commit **twos)\n{\n\tstruct commit_list *list = NULL;\n\tstruct commit_list *result = NULL;\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (one == twos[i])\n\t\t\t/*\n\t\t\t * We do not mark this even with RESULT so we do not\n\t\t\t * have to clean it up.\n\t\t\t */\n\t\t\treturn commit_list_insert(one, &result);\n\t}\n\n\tif (parse_commit(one))\n\t\treturn NULL;\n\tfor (i = 0; i < n; i++) {\n\t\tif (parse_commit(twos[i]))\n\t\t\treturn NULL;\n\t}\n\n\tlist = paint_down_to_common(one, n, twos);\n\n\twhile (list) {\n\t\tstruct commit *commit = pop_commit(&list);\n\t\tif (!(commit->object.flags & STALE))\n\t\t\tcommit_list_insert_by_date(commit, &result);\n\t}\n\treturn result;\n}\n\nstruct commit_list *get_octopus_merge_bases(struct commit_list *in)\n{\n\tstruct commit_list *i, *j, *k, *ret = NULL;\n\n\tif (!in)\n\t\treturn ret;\n\n\tcommit_list_insert(in->item, &ret);\n\n\tfor (i = in->next; i; i = i->next) {\n\t\tstruct commit_list *new_commits = NULL, *end = NULL;\n\n\t\tfor (j = ret; j; j = j->next) {\n\t\t\tstruct commit_list *bases;\n\t\t\tbases = get_merge_bases(i->item, j->item);\n\t\t\tif (!new_commits)\n\t\t\t\tnew_commits = bases;\n\t\t\telse\n\t\t\t\tend->next = bases;\n\t\t\tfor (k = bases; k; k = k->next)\n\t\t\t\tend = k;\n\t\t}\n\t\tret = new_commits;\n\t}\n\treturn ret;\n}\n\nstatic int remove_redundant(struct commit **array, int cnt)\n{\n\t/*\n\t * Some commit in the array may be an ancestor of\n\t * another commit.  Move such commit to the end of\n\t * the array, and return the number of commits that\n\t * are independent from each other.\n\t */\n\tstruct commit **work;\n\tunsigned char *redundant;\n\tint *filled_index;\n\tint i, j, filled;\n\n\twork = xcalloc(cnt, sizeof(*work));\n\tredundant = xcalloc(cnt, 1);\n\tALLOC_ARRAY(filled_index, cnt - 1);\n\n\tfor (i = 0; i < cnt; i++)\n\t\tparse_commit(array[i]);\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct commit_list *common;\n\n\t\tif (redundant[i])\n\t\t\tcontinue;\n\t\tfor (j = filled = 0; j < cnt; j++) {\n\t\t\tif (i == j || redundant[j])\n\t\t\t\tcontinue;\n\t\t\tfilled_index[filled] = j;\n\t\t\twork[filled++] = array[j];\n\t\t}\n\t\tcommon = paint_down_to_common(array[i], filled, work);\n\t\tif (array[i]->object.flags & PARENT2)\n\t\t\tredundant[i] = 1;\n\t\tfor (j = 0; j < filled; j++)\n\t\t\tif (work[j]->object.flags & PARENT1)\n\t\t\t\tredundant[filled_index[j]] = 1;\n\t\tclear_commit_marks(array[i], all_flags);\n\t\tclear_commit_marks_many(filled, work, all_flags);\n\t\tfree_commit_list(common);\n\t}\n\n\t/* Now collect the result */\n\tCOPY_ARRAY(work, array, cnt);\n\tfor (i = filled = 0; i < cnt; i++)\n\t\tif (!redundant[i])\n\t\t\tarray[filled++] = work[i];\n\tfor (j = filled, i = 0; i < cnt; i++)\n\t\tif (redundant[i])\n\t\t\tarray[j++] = work[i];\n\tfree(work);\n\tfree(redundant);\n\tfree(filled_index);\n\treturn filled;\n}\n\nstatic struct commit_list *get_merge_bases_many_0(struct commit *one,\n\t\t\t\t\t\t  int n,\n\t\t\t\t\t\t  struct commit **twos,\n\t\t\t\t\t\t  int cleanup)\n{\n\tstruct commit_list *list;\n\tstruct commit **rslt;\n\tstruct commit_list *result;\n\tint cnt, i;\n\n\tresult = merge_bases_many(one, n, twos);\n\tfor (i = 0; i < n; i++) {\n\t\tif (one == twos[i])\n\t\t\treturn result;\n\t}\n\tif (!result || !result->next) {\n\t\tif (cleanup) {\n\t\t\tclear_commit_marks(one, all_flags);\n\t\t\tclear_commit_marks_many(n, twos, all_flags);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/* There are more than one */\n\tcnt = commit_list_count(result);\n\trslt = xcalloc(cnt, sizeof(*rslt));\n\tfor (list = result, i = 0; list; list = list->next)\n\t\trslt[i++] = list->item;\n\tfree_commit_list(result);\n\n\tclear_commit_marks(one, all_flags);\n\tclear_commit_marks_many(n, twos, all_flags);\n\n\tcnt = remove_redundant(rslt, cnt);\n\tresult = NULL;\n\tfor (i = 0; i < cnt; i++)\n\t\tcommit_list_insert_by_date(rslt[i], &result);\n\tfree(rslt);\n\treturn result;\n}\n\nstruct commit_list *get_merge_bases_many(struct commit *one,\n\t\t\t\t\t int n,\n\t\t\t\t\t struct commit **twos)\n{\n\treturn get_merge_bases_many_0(one, n, twos, 1);\n}\n\nstruct commit_list *get_merge_bases_many_dirty(struct commit *one,\n\t\t\t\t\t       int n,\n\t\t\t\t\t       struct commit **twos)\n{\n\treturn get_merge_bases_many_0(one, n, twos, 0);\n}\n\nstruct commit_list *get_merge_bases(struct commit *one, struct commit *two)\n{\n\treturn get_merge_bases_many_0(one, 1, &two, 1);\n}\n\n/*\n * Is \"commit\" a descendant of one of the elements on the \"with_commit\" list?\n */\nint is_descendant_of(struct commit *commit, struct commit_list *with_commit)\n{\n\tif (!with_commit)\n\t\treturn 1;\n\twhile (with_commit) {\n\t\tstruct commit *other;\n\n\t\tother = with_commit->item;\n\t\twith_commit = with_commit->next;\n\t\tif (in_merge_bases(other, commit))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Is \"commit\" an ancestor of one of the \"references\"?\n */\nint in_merge_bases_many(struct commit *commit, int nr_reference, struct commit **reference)\n{\n\tstruct commit_list *bases;\n\tint ret = 0, i;\n\n\tif (parse_commit(commit))\n\t\treturn ret;\n\tfor (i = 0; i < nr_reference; i++)\n\t\tif (parse_commit(reference[i]))\n\t\t\treturn ret;\n\n\tbases = paint_down_to_common(commit, nr_reference, reference);\n\tif (commit->object.flags & PARENT2)\n\t\tret = 1;\n\tclear_commit_marks(commit, all_flags);\n\tclear_commit_marks_many(nr_reference, reference, all_flags);\n\tfree_commit_list(bases);\n\treturn ret;\n}\n\n/*\n * Is \"commit\" an ancestor of (i.e. reachable from) the \"reference\"?\n */\nint in_merge_bases(struct commit *commit, struct commit *reference)\n{\n\treturn in_merge_bases_many(commit, 1, &reference);\n}\n\nstruct commit_list *reduce_heads(struct commit_list *heads)\n{\n\tstruct commit_list *p;\n\tstruct commit_list *result = NULL, **tail = &result;\n\tstruct commit **array;\n\tint num_head, i;\n\n\tif (!heads)\n\t\treturn NULL;\n\n\t/* Uniquify */\n\tfor (p = heads; p; p = p->next)\n\t\tp->item->object.flags &= ~STALE;\n\tfor (p = heads, num_head = 0; p; p = p->next) {\n\t\tif (p->item->object.flags & STALE)\n\t\t\tcontinue;\n\t\tp->item->object.flags |= STALE;\n\t\tnum_head++;\n\t}\n\tarray = xcalloc(num_head, sizeof(*array));\n\tfor (p = heads, i = 0; p; p = p->next) {\n\t\tif (p->item->object.flags & STALE) {\n\t\t\tarray[i++] = p->item;\n\t\t\tp->item->object.flags &= ~STALE;\n\t\t}\n\t}\n\tnum_head = remove_redundant(array, num_head);\n\tfor (i = 0; i < num_head; i++)\n\t\ttail = &commit_list_insert(array[i], tail)->next;\n\tfree(array);\n\treturn result;\n}\n\nvoid reduce_heads_replace(struct commit_list **heads)\n{\n\tstruct commit_list *result = reduce_heads(*heads);\n\tfree_commit_list(*heads);\n\t*heads = result;\n}\n\nstatic const char gpg_sig_header[] = \"gpgsig\";\nstatic const int gpg_sig_header_len = sizeof(gpg_sig_header) - 1;\n\nstatic int do_sign_commit(struct strbuf *buf, const char *keyid)\n{\n\tstruct strbuf sig = STRBUF_INIT;\n\tint inspos, copypos;\n\tconst char *eoh;\n\n\t/* find the end of the header */\n\teoh = strstr(buf->buf, \"\\n\\n\");\n\tif (!eoh)\n\t\tinspos = buf->len;\n\telse\n\t\tinspos = eoh - buf->buf + 1;\n\n\tif (!keyid || !*keyid)\n\t\tkeyid = get_signing_key();\n\tif (sign_buffer(buf, &sig, keyid)) {\n\t\tstrbuf_release(&sig);\n\t\treturn -1;\n\t}\n\n\tfor (copypos = 0; sig.buf[copypos]; ) {\n\t\tconst char *bol = sig.buf + copypos;\n\t\tconst char *eol = strchrnul(bol, '\\n');\n\t\tint len = (eol - bol) + !!*eol;\n\n\t\tif (!copypos) {\n\t\t\tstrbuf_insert(buf, inspos, gpg_sig_header, gpg_sig_header_len);\n\t\t\tinspos += gpg_sig_header_len;\n\t\t}\n\t\tstrbuf_insert(buf, inspos++, \" \", 1);\n\t\tstrbuf_insert(buf, inspos, bol, len);\n\t\tinspos += len;\n\t\tcopypos += len;\n\t}\n\tstrbuf_release(&sig);\n\treturn 0;\n}\n\nint parse_signed_commit(const struct commit *commit,\n\t\t\tstruct strbuf *payload, struct strbuf *signature)\n{\n\n\tunsigned long size;\n\tconst char *buffer = get_commit_buffer(commit, &size);\n\tint in_signature, saw_signature = -1;\n\tconst char *line, *tail;\n\n\tline = buffer;\n\ttail = buffer + size;\n\tin_signature = 0;\n\tsaw_signature = 0;\n\twhile (line < tail) {\n\t\tconst char *sig = NULL;\n\t\tconst char *next = memchr(line, '\\n', tail - line);\n\n\t\tnext = next ? next + 1 : tail;\n\t\tif (in_signature && line[0] == ' ')\n\t\t\tsig = line + 1;\n\t\telse if (starts_with(line, gpg_sig_header) &&\n\t\t\t line[gpg_sig_header_len] == ' ')\n\t\t\tsig = line + gpg_sig_header_len + 1;\n\t\tif (sig) {\n\t\t\tstrbuf_add(signature, sig, next - sig);\n\t\t\tsaw_signature = 1;\n\t\t\tin_signature = 1;\n\t\t} else {\n\t\t\tif (*line == '\\n')\n\t\t\t\t/* dump the whole remainder of the buffer */\n\t\t\t\tnext = tail;\n\t\t\tstrbuf_add(payload, line, next - line);\n\t\t\tin_signature = 0;\n\t\t}\n\t\tline = next;\n\t}\n\tunuse_commit_buffer(commit, buffer);\n\treturn saw_signature;\n}\n\nint remove_signature(struct strbuf *buf)\n{\n\tconst char *line = buf->buf;\n\tconst char *tail = buf->buf + buf->len;\n\tint in_signature = 0;\n\tconst char *sig_start = NULL;\n\tconst char *sig_end = NULL;\n\n\twhile (line < tail) {\n\t\tconst char *next = memchr(line, '\\n', tail - line);\n\t\tnext = next ? next + 1 : tail;\n\n\t\tif (in_signature && line[0] == ' ')\n\t\t\tsig_end = next;\n\t\telse if (starts_with(line, gpg_sig_header) &&\n\t\t\t line[gpg_sig_header_len] == ' ') {\n\t\t\tsig_start = line;\n\t\t\tsig_end = next;\n\t\t\tin_signature = 1;\n\t\t} else {\n\t\t\tif (*line == '\\n')\n\t\t\t\t/* dump the whole remainder of the buffer */\n\t\t\t\tnext = tail;\n\t\t\tin_signature = 0;\n\t\t}\n\t\tline = next;\n\t}\n\n\tif (sig_start)\n\t\tstrbuf_remove(buf, sig_start - buf->buf, sig_end - sig_start);\n\n\treturn sig_start != NULL;\n}\n\nstatic void handle_signed_tag(struct commit *parent, struct commit_extra_header ***tail)\n{\n\tstruct merge_remote_desc *desc;\n\tstruct commit_extra_header *mergetag;\n\tchar *buf;\n\tunsigned long size, len;\n\tenum object_type type;\n\n\tdesc = merge_remote_util(parent);\n\tif (!desc || !desc->obj)\n\t\treturn;\n\tbuf = read_sha1_file(desc->obj->oid.hash, &type, &size);\n\tif (!buf || type != OBJ_TAG)\n\t\tgoto free_return;\n\tlen = parse_signature(buf, size);\n\tif (size == len)\n\t\tgoto free_return;\n\t/*\n\t * We could verify this signature and either omit the tag when\n\t * it does not validate, but the integrator may not have the\n\t * public key of the signer of the tag he is merging, while a\n\t * later auditor may have it while auditing, so let's not run\n\t * verify-signed-buffer here for now...\n\t *\n\t * if (verify_signed_buffer(buf, len, buf + len, size - len, ...))\n\t *\twarn(\"warning: signed tag unverified.\");\n\t */\n\tmergetag = xcalloc(1, sizeof(*mergetag));\n\tmergetag->key = xstrdup(\"mergetag\");\n\tmergetag->value = buf;\n\tmergetag->len = size;\n\n\t**tail = mergetag;\n\t*tail = &mergetag->next;\n\treturn;\n\nfree_return:\n\tfree(buf);\n}\n\nint check_commit_signature(const struct commit *commit, struct signature_check *sigc)\n{\n\tstruct strbuf payload = STRBUF_INIT;\n\tstruct strbuf signature = STRBUF_INIT;\n\tint ret = 1;\n\n\tsigc->result = 'N';\n\n\tif (parse_signed_commit(commit, &payload, &signature) <= 0)\n\t\tgoto out;\n\tret = check_signature(payload.buf, payload.len, signature.buf,\n\t\tsignature.len, sigc);\n\n out:\n\tstrbuf_release(&payload);\n\tstrbuf_release(&signature);\n\n\treturn ret;\n}\n\n\n\nvoid append_merge_tag_headers(struct commit_list *parents,\n\t\t\t      struct commit_extra_header ***tail)\n{\n\twhile (parents) {\n\t\tstruct commit *parent = parents->item;\n\t\thandle_signed_tag(parent, tail);\n\t\tparents = parents->next;\n\t}\n}\n\nstatic void add_extra_header(struct strbuf *buffer,\n\t\t\t     struct commit_extra_header *extra)\n{\n\tstrbuf_addstr(buffer, extra->key);\n\tif (extra->len)\n\t\tstrbuf_add_lines(buffer, \" \", extra->value, extra->len);\n\telse\n\t\tstrbuf_addch(buffer, '\\n');\n}\n\nstruct commit_extra_header *read_commit_extra_headers(struct commit *commit,\n\t\t\t\t\t\t      const char **exclude)\n{\n\tstruct commit_extra_header *extra = NULL;\n\tunsigned long size;\n\tconst char *buffer = get_commit_buffer(commit, &size);\n\textra = read_commit_extra_header_lines(buffer, size, exclude);\n\tunuse_commit_buffer(commit, buffer);\n\treturn extra;\n}\n\nvoid for_each_mergetag(each_mergetag_fn fn, struct commit *commit, void *data)\n{\n\tstruct commit_extra_header *extra, *to_free;\n\n\tto_free = read_commit_extra_headers(commit, NULL);\n\tfor (extra = to_free; extra; extra = extra->next) {\n\t\tif (strcmp(extra->key, \"mergetag\"))\n\t\t\tcontinue; /* not a merge tag */\n\t\tfn(commit, extra, data);\n\t}\n\tfree_commit_extra_headers(to_free);\n}\n\nstatic inline int standard_header_field(const char *field, size_t len)\n{\n\treturn ((len == 4 && !memcmp(field, \"tree\", 4)) ||\n\t\t(len == 6 && !memcmp(field, \"parent\", 6)) ||\n\t\t(len == 6 && !memcmp(field, \"author\", 6)) ||\n\t\t(len == 9 && !memcmp(field, \"committer\", 9)) ||\n\t\t(len == 8 && !memcmp(field, \"encoding\", 8)));\n}\n\nstatic int excluded_header_field(const char *field, size_t len, const char **exclude)\n{\n\tif (!exclude)\n\t\treturn 0;\n\n\twhile (*exclude) {\n\t\tsize_t xlen = strlen(*exclude);\n\t\tif (len == xlen && !memcmp(field, *exclude, xlen))\n\t\t\treturn 1;\n\t\texclude++;\n\t}\n\treturn 0;\n}\n\nstatic struct commit_extra_header *read_commit_extra_header_lines(\n\tconst char *buffer, size_t size,\n\tconst char **exclude)\n{\n\tstruct commit_extra_header *extra = NULL, **tail = &extra, *it = NULL;\n\tconst char *line, *next, *eof, *eob;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tfor (line = buffer, eob = line + size;\n\t     line < eob && *line != '\\n';\n\t     line = next) {\n\t\tnext = memchr(line, '\\n', eob - line);\n\t\tnext = next ? next + 1 : eob;\n\t\tif (*line == ' ') {\n\t\t\t/* continuation */\n\t\t\tif (it)\n\t\t\t\tstrbuf_add(&buf, line + 1, next - (line + 1));\n\t\t\tcontinue;\n\t\t}\n\t\tif (it)\n\t\t\tit->value = strbuf_detach(&buf, &it->len);\n\t\tstrbuf_reset(&buf);\n\t\tit = NULL;\n\n\t\teof = memchr(line, ' ', next - line);\n\t\tif (!eof)\n\t\t\teof = next;\n\t\telse if (standard_header_field(line, eof - line) ||\n\t\t\t excluded_header_field(line, eof - line, exclude))\n\t\t\tcontinue;\n\n\t\tit = xcalloc(1, sizeof(*it));\n\t\tit->key = xmemdupz(line, eof-line);\n\t\t*tail = it;\n\t\ttail = &it->next;\n\t\tif (eof + 1 < next)\n\t\t\tstrbuf_add(&buf, eof + 1, next - (eof + 1));\n\t}\n\tif (it)\n\t\tit->value = strbuf_detach(&buf, &it->len);\n\treturn extra;\n}\n\nvoid free_commit_extra_headers(struct commit_extra_header *extra)\n{\n\twhile (extra) {\n\t\tstruct commit_extra_header *next = extra->next;\n\t\tfree(extra->key);\n\t\tfree(extra->value);\n\t\tfree(extra);\n\t\textra = next;\n\t}\n}\n\nint commit_tree(const char *msg, size_t msg_len, const struct object_id *tree,\n\t\tstruct commit_list *parents, struct object_id *ret,\n\t\tconst char *author, const char *sign_commit)\n{\n\tstruct commit_extra_header *extra = NULL, **tail = &extra;\n\tint result;\n\n\tappend_merge_tag_headers(parents, &tail);\n\tresult = commit_tree_extended(msg, msg_len, tree, parents, ret,\n\t\t\t\t      author, sign_commit, extra);\n\tfree_commit_extra_headers(extra);\n\treturn result;\n}\n\nstatic int find_invalid_utf8(const char *buf, int len)\n{\n\tint offset = 0;\n\tstatic const unsigned int max_codepoint[] = {\n\t\t0x7f, 0x7ff, 0xffff, 0x10ffff\n\t};\n\n\twhile (len) {\n\t\tunsigned char c = *buf++;\n\t\tint bytes, bad_offset;\n\t\tunsigned int codepoint;\n\t\tunsigned int min_val, max_val;\n\n\t\tlen--;\n\t\toffset++;\n\n\t\t/* Simple US-ASCII? No worries. */\n\t\tif (c < 0x80)\n\t\t\tcontinue;\n\n\t\tbad_offset = offset-1;\n\n\t\t/*\n\t\t * Count how many more high bits set: that's how\n\t\t * many more bytes this sequence should have.\n\t\t */\n\t\tbytes = 0;\n\t\twhile (c & 0x40) {\n\t\t\tc <<= 1;\n\t\t\tbytes++;\n\t\t}\n\n\t\t/*\n\t\t * Must be between 1 and 3 more bytes.  Longer sequences result in\n\t\t * codepoints beyond U+10FFFF, which are guaranteed never to exist.\n\t\t */\n\t\tif (bytes < 1 || 3 < bytes)\n\t\t\treturn bad_offset;\n\n\t\t/* Do we *have* that many bytes? */\n\t\tif (len < bytes)\n\t\t\treturn bad_offset;\n\n\t\t/*\n\t\t * Place the encoded bits at the bottom of the value and compute the\n\t\t * valid range.\n\t\t */\n\t\tcodepoint = (c & 0x7f) >> bytes;\n\t\tmin_val = max_codepoint[bytes-1] + 1;\n\t\tmax_val = max_codepoint[bytes];\n\n\t\toffset += bytes;\n\t\tlen -= bytes;\n\n\t\t/* And verify that they are good continuation bytes */\n\t\tdo {\n\t\t\tcodepoint <<= 6;\n\t\t\tcodepoint |= *buf & 0x3f;\n\t\t\tif ((*buf++ & 0xc0) != 0x80)\n\t\t\t\treturn bad_offset;\n\t\t} while (--bytes);\n\n\t\t/* Reject codepoints that are out of range for the sequence length. */\n\t\tif (codepoint < min_val || codepoint > max_val)\n\t\t\treturn bad_offset;\n\t\t/* Surrogates are only for UTF-16 and cannot be encoded in UTF-8. */\n\t\tif ((codepoint & 0x1ff800) == 0xd800)\n\t\t\treturn bad_offset;\n\t\t/* U+xxFFFE and U+xxFFFF are guaranteed non-characters. */\n\t\tif ((codepoint & 0xfffe) == 0xfffe)\n\t\t\treturn bad_offset;\n\t\t/* So are anything in the range U+FDD0..U+FDEF. */\n\t\tif (codepoint >= 0xfdd0 && codepoint <= 0xfdef)\n\t\t\treturn bad_offset;\n\t}\n\treturn -1;\n}\n\n/*\n * This verifies that the buffer is in proper utf8 format.\n *\n * If it isn't, it assumes any non-utf8 characters are Latin1,\n * and does the conversion.\n */\nstatic int verify_utf8(struct strbuf *buf)\n{\n\tint ok = 1;\n\tlong pos = 0;\n\n\tfor (;;) {\n\t\tint bad;\n\t\tunsigned char c;\n\t\tunsigned char replace[2];\n\n\t\tbad = find_invalid_utf8(buf->buf + pos, buf->len - pos);\n\t\tif (bad < 0)\n\t\t\treturn ok;\n\t\tpos += bad;\n\t\tok = 0;\n\t\tc = buf->buf[pos];\n\t\tstrbuf_remove(buf, pos, 1);\n\n\t\t/* We know 'c' must be in the range 128-255 */\n\t\treplace[0] = 0xc0 + (c >> 6);\n\t\treplace[1] = 0x80 + (c & 0x3f);\n\t\tstrbuf_insert(buf, pos, replace, 2);\n\t\tpos += 2;\n\t}\n}\n\nstatic const char commit_utf8_warn[] =\nN_(\"Warning: commit message did not conform to UTF-8.\\n\"\n   \"You may want to amend it after fixing the message, or set the config\\n\"\n   \"variable i18n.commitencoding to the encoding your project uses.\\n\");\n\nint commit_tree_extended(const char *msg, size_t msg_len,\n\t\t\t const struct object_id *tree,\n\t\t\t struct commit_list *parents, struct object_id *ret,\n\t\t\t const char *author, const char *sign_commit,\n\t\t\t struct commit_extra_header *extra)\n{\n\tint result;\n\tint encoding_is_utf8;\n\tstruct strbuf buffer;\n\n\tassert_sha1_type(tree->hash, OBJ_TREE);\n\n\tif (memchr(msg, '\\0', msg_len))\n\t\treturn error(\"a NUL byte in commit log message not allowed.\");\n\n\t/* Not having i18n.commitencoding is the same as having utf-8 */\n\tencoding_is_utf8 = is_encoding_utf8(git_commit_encoding);\n\n\tstrbuf_init(&buffer, 8192); /* should avoid reallocs for the headers */\n\tstrbuf_addf(&buffer, \"tree %s\\n\", oid_to_hex(tree));\n\n\t/*\n\t * NOTE! This ordering means that the same exact tree merged with a\n\t * different order of parents will be a _different_ changeset even\n\t * if everything else stays the same.\n\t */\n\twhile (parents) {\n\t\tstruct commit *parent = pop_commit(&parents);\n\t\tstrbuf_addf(&buffer, \"parent %s\\n\",\n\t\t\t    oid_to_hex(&parent->object.oid));\n\t}\n\n\t/* Person/date information */\n\tif (!author)\n\t\tauthor = git_author_info(IDENT_STRICT);\n\tstrbuf_addf(&buffer, \"author %s\\n\", author);\n\tstrbuf_addf(&buffer, \"committer %s\\n\", git_committer_info(IDENT_STRICT));\n\tif (!encoding_is_utf8)\n\t\tstrbuf_addf(&buffer, \"encoding %s\\n\", git_commit_encoding);\n\n\twhile (extra) {\n\t\tadd_extra_header(&buffer, extra);\n\t\textra = extra->next;\n\t}\n\tstrbuf_addch(&buffer, '\\n');\n\n\t/* And add the comment */\n\tstrbuf_add(&buffer, msg, msg_len);\n\n\t/* And check the encoding */\n\tif (encoding_is_utf8 && !verify_utf8(&buffer))\n\t\tfprintf(stderr, _(commit_utf8_warn));\n\n\tif (sign_commit && do_sign_commit(&buffer, sign_commit)) {\n\t\tresult = -1;\n\t\tgoto out;\n\t}\n\n\tresult = write_object_file(buffer.buf, buffer.len, commit_type, ret);\nout:\n\tstrbuf_release(&buffer);\n\treturn result;\n}\n\nvoid set_merge_remote_desc(struct commit *commit,\n\t\t\t   const char *name, struct object *obj)\n{\n\tstruct merge_remote_desc *desc;\n\tFLEX_ALLOC_STR(desc, name, name);\n\tdesc->obj = obj;\n\tcommit->util = desc;\n}\n\nstruct commit *get_merge_parent(const char *name)\n{\n\tstruct object *obj;\n\tstruct commit *commit;\n\tstruct object_id oid;\n\tif (get_oid(name, &oid))\n\t\treturn NULL;\n\tobj = parse_object(&oid);\n\tcommit = (struct commit *)peel_to_type(name, 0, obj, OBJ_COMMIT);\n\tif (commit && !commit->util)\n\t\tset_merge_remote_desc(commit, name, obj);\n\treturn commit;\n}\n\n/*\n * Append a commit to the end of the commit_list.\n *\n * next starts by pointing to the variable that holds the head of an\n * empty commit_list, and is updated to point to the \"next\" field of\n * the last item on the list as new commits are appended.\n *\n * Usage example:\n *\n *     struct commit_list *list;\n *     struct commit_list **next = &list;\n *\n *     next = commit_list_append(c1, next);\n *     next = commit_list_append(c2, next);\n *     assert(commit_list_count(list) == 2);\n *     return list;\n */\nstruct commit_list **commit_list_append(struct commit *commit,\n\t\t\t\t\tstruct commit_list **next)\n{\n\tstruct commit_list *new_commit = xmalloc(sizeof(struct commit_list));\n\tnew_commit->item = commit;\n\t*next = new_commit;\n\tnew_commit->next = NULL;\n\treturn &new_commit->next;\n}\n\nconst char *find_commit_header(const char *msg, const char *key, size_t *out_len)\n{\n\tint key_len = strlen(key);\n\tconst char *line = msg;\n\n\twhile (line) {\n\t\tconst char *eol = strchrnul(line, '\\n');\n\n\t\tif (line == eol)\n\t\t\treturn NULL;\n\n\t\tif (eol - line > key_len &&\n\t\t    !strncmp(line, key, key_len) &&\n\t\t    line[key_len] == ' ') {\n\t\t\t*out_len = eol - line - key_len - 1;\n\t\t\treturn line + key_len + 1;\n\t\t}\n\t\tline = *eol ? eol + 1 : NULL;\n\t}\n\treturn NULL;\n}\n\n/*\n * Inspect the given string and determine the true \"end\" of the log message, in\n * order to find where to put a new Signed-off-by: line.  Ignored are\n * trailing comment lines and blank lines.  To support \"git commit -s\n * --amend\" on an existing commit, we also ignore \"Conflicts:\".  To\n * support \"git commit -v\", we truncate at cut lines.\n *\n * Returns the number of bytes from the tail to ignore, to be fed as\n * the second parameter to append_signoff().\n */\nint ignore_non_trailer(const char *buf, size_t len)\n{\n\tint boc = 0;\n\tint bol = 0;\n\tint in_old_conflicts_block = 0;\n\tsize_t cutoff = wt_status_locate_end(buf, len);\n\n\twhile (bol < cutoff) {\n\t\tconst char *next_line = memchr(buf + bol, '\\n', len - bol);\n\n\t\tif (!next_line)\n\t\t\tnext_line = buf + len;\n\t\telse\n\t\t\tnext_line++;\n\n\t\tif (buf[bol] == comment_line_char || buf[bol] == '\\n') {\n\t\t\t/* is this the first of the run of comments? */\n\t\t\tif (!boc)\n\t\t\t\tboc = bol;\n\t\t\t/* otherwise, it is just continuing */\n\t\t} else if (starts_with(buf + bol, \"Conflicts:\\n\")) {\n\t\t\tin_old_conflicts_block = 1;\n\t\t\tif (!boc)\n\t\t\t\tboc = bol;\n\t\t} else if (in_old_conflicts_block && buf[bol] == '\\t') {\n\t\t\t; /* a pathname in the conflicts block */\n\t\t} else if (boc) {\n\t\t\t/* the previous was not trailing comment */\n\t\t\tboc = 0;\n\t\t\tin_old_conflicts_block = 0;\n\t\t}\n\t\tbol = next_line - buf;\n\t}\n\treturn boc ? len - boc : len - cutoff;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00c99c7272badc2d5a8f16c29db7d4040f5eb4d3",
  "sha1_ok": true,
  "size": 41688
}
