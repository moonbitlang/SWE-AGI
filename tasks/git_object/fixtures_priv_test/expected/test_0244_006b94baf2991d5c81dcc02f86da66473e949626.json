{
  "content": {
    "base64": "LyoKICogUmVjdXJzaXZlIE1lcmdlIGFsZ29yaXRobSBzdG9sZW4gZnJvbSBnaXQtbWVyZ2UtcmVjdXJzaXZlLnB5IGJ5CiAqIEZyZWRyaWsgS3VpdmluZW4uCiAqIFRoZSB0aGlldmVzIHdlcmUgQWxleCBSaWVzZW4gYW5kIEpvaGFubmVzIFNjaGluZGVsaW4sIGluIEp1bmUvSnVseSAyMDA2CiAqLwojaW5jbHVkZSAiY2FjaGUuaCIKI2luY2x1ZGUgImFkdmljZS5oIgojaW5jbHVkZSAibG9ja2ZpbGUuaCIKI2luY2x1ZGUgImNhY2hlLXRyZWUuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAiYmxvYi5oIgojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAidHJlZS13YWxrLmgiCiNpbmNsdWRlICJkaWZmLmgiCiNpbmNsdWRlICJkaWZmY29yZS5oIgojaW5jbHVkZSAidGFnLmgiCiNpbmNsdWRlICJ1bnBhY2stdHJlZXMuaCIKI2luY2x1ZGUgInN0cmluZy1saXN0LmgiCiNpbmNsdWRlICJ4ZGlmZi1pbnRlcmZhY2UuaCIKI2luY2x1ZGUgImxsLW1lcmdlLmgiCiNpbmNsdWRlICJhdHRyLmgiCiNpbmNsdWRlICJtZXJnZS1yZWN1cnNpdmUuaCIKI2luY2x1ZGUgImRpci5oIgojaW5jbHVkZSAic3VibW9kdWxlLmgiCgpzdGF0aWMgdm9pZCBmbHVzaF9vdXRwdXQoc3RydWN0IG1lcmdlX29wdGlvbnMgKm8pCnsKCWlmIChvLT5idWZmZXJfb3V0cHV0IDwgMiAmJiBvLT5vYnVmLmxlbikgewoJCWZwdXRzKG8tPm9idWYuYnVmLCBzdGRvdXQpOwoJCXN0cmJ1Zl9yZXNldCgmby0+b2J1Zik7Cgl9Cn0KCnN0YXRpYyBpbnQgZXJyKHN0cnVjdCBtZXJnZV9vcHRpb25zICpvLCBjb25zdCBjaGFyICplcnIsIC4uLikKewoJdmFfbGlzdCBwYXJhbXM7CgoJaWYgKG8tPmJ1ZmZlcl9vdXRwdXQgPCAyKQoJCWZsdXNoX291dHB1dChvKTsKCWVsc2UgewoJCXN0cmJ1Zl9jb21wbGV0ZSgmby0+b2J1ZiwgJ1xuJyk7CgkJc3RyYnVmX2FkZHN0cigmby0+b2J1ZiwgImVycm9yOiAiKTsKCX0KCXZhX3N0YXJ0KHBhcmFtcywgZXJyKTsKCXN0cmJ1Zl92YWRkZigmby0+b2J1ZiwgZXJyLCBwYXJhbXMpOwoJdmFfZW5kKHBhcmFtcyk7CglpZiAoby0+YnVmZmVyX291dHB1dCA+IDEpCgkJc3RyYnVmX2FkZGNoKCZvLT5vYnVmLCAnXG4nKTsKCWVsc2UgewoJCWVycm9yKCIlcyIsIG8tPm9idWYuYnVmKTsKCQlzdHJidWZfcmVzZXQoJm8tPm9idWYpOwoJfQoKCXJldHVybiAtMTsKfQoKc3RhdGljIHN0cnVjdCB0cmVlICpzaGlmdF90cmVlX29iamVjdChzdHJ1Y3QgdHJlZSAqb25lLCBzdHJ1Y3QgdHJlZSAqdHdvLAoJCQkJICAgICAgY29uc3QgY2hhciAqc3VidHJlZV9zaGlmdCkKewoJc3RydWN0IG9iamVjdF9pZCBzaGlmdGVkOwoKCWlmICghKnN1YnRyZWVfc2hpZnQpIHsKCQlzaGlmdF90cmVlKCZvbmUtPm9iamVjdC5vaWQsICZ0d28tPm9iamVjdC5vaWQsICZzaGlmdGVkLCAwKTsKCX0gZWxzZSB7CgkJc2hpZnRfdHJlZV9ieSgmb25lLT5vYmplY3Qub2lkLCAmdHdvLT5vYmplY3Qub2lkLCAmc2hpZnRlZCwKCQkJICAgICAgc3VidHJlZV9zaGlmdCk7Cgl9CglpZiAoIW9pZGNtcCgmdHdvLT5vYmplY3Qub2lkLCAmc2hpZnRlZCkpCgkJcmV0dXJuIHR3bzsKCXJldHVybiBsb29rdXBfdHJlZShzaGlmdGVkLmhhc2gpOwp9CgpzdGF0aWMgc3RydWN0IGNvbW1pdCAqbWFrZV92aXJ0dWFsX2NvbW1pdChzdHJ1Y3QgdHJlZSAqdHJlZSwgY29uc3QgY2hhciAqY29tbWVudCkKewoJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gYWxsb2NfY29tbWl0X25vZGUoKTsKCglzZXRfbWVyZ2VfcmVtb3RlX2Rlc2MoY29tbWl0LCBjb21tZW50LCAoc3RydWN0IG9iamVjdCAqKWNvbW1pdCk7Cgljb21taXQtPnRyZWUgPSB0cmVlOwoJY29tbWl0LT5vYmplY3QucGFyc2VkID0gMTsKCXJldHVybiBjb21taXQ7Cn0KCi8qCiAqIFNpbmNlIHdlIHVzZSBnZXRfdHJlZV9lbnRyeSgpLCB3aGljaCBkb2VzIG5vdCBwdXQgdGhlIHJlYWQgb2JqZWN0IGludG8KICogdGhlIG9iamVjdCBwb29sLCB3ZSBjYW5ub3QgcmVseSBvbiBhID09IGIuCiAqLwpzdGF0aWMgaW50IG9pZF9lcShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICphLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpiKQp7CglpZiAoIWEgJiYgIWIpCgkJcmV0dXJuIDI7CglyZXR1cm4gYSAmJiBiICYmIG9pZGNtcChhLCBiKSA9PSAwOwp9CgplbnVtIHJlbmFtZV90eXBlIHsKCVJFTkFNRV9OT1JNQUwgPSAwLAoJUkVOQU1FX0RFTEVURSwKCVJFTkFNRV9PTkVfRklMRV9UT19PTkUsCglSRU5BTUVfT05FX0ZJTEVfVE9fVFdPLAoJUkVOQU1FX1RXT19GSUxFU19UT19PTkUKfTsKCnN0cnVjdCByZW5hbWVfY29uZmxpY3RfaW5mbyB7CgllbnVtIHJlbmFtZV90eXBlIHJlbmFtZV90eXBlOwoJc3RydWN0IGRpZmZfZmlsZXBhaXIgKnBhaXIxOwoJc3RydWN0IGRpZmZfZmlsZXBhaXIgKnBhaXIyOwoJY29uc3QgY2hhciAqYnJhbmNoMTsKCWNvbnN0IGNoYXIgKmJyYW5jaDI7CglzdHJ1Y3Qgc3RhZ2VfZGF0YSAqZHN0X2VudHJ5MTsKCXN0cnVjdCBzdGFnZV9kYXRhICpkc3RfZW50cnkyOwoJc3RydWN0IGRpZmZfZmlsZXNwZWMgcmVuMV9vdGhlcjsKCXN0cnVjdCBkaWZmX2ZpbGVzcGVjIHJlbjJfb3RoZXI7Cn07CgovKgogKiBTaW5jZSB3ZSB3YW50IHRvIHdyaXRlIHRoZSBpbmRleCBldmVudHVhbGx5LCB3ZSBjYW5ub3QgcmV1c2UgdGhlIGluZGV4CiAqIGZvciB0aGVzZSAodGVtcG9yYXJ5KSBkYXRhLgogKi8Kc3RydWN0IHN0YWdlX2RhdGEgewoJc3RydWN0IHsKCQl1bnNpZ25lZCBtb2RlOwoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJfSBzdGFnZXNbNF07CglzdHJ1Y3QgcmVuYW1lX2NvbmZsaWN0X2luZm8gKnJlbmFtZV9jb25mbGljdF9pbmZvOwoJdW5zaWduZWQgcHJvY2Vzc2VkOjE7Cn07CgpzdGF0aWMgaW5saW5lIHZvaWQgc2V0dXBfcmVuYW1lX2NvbmZsaWN0X2luZm8oZW51bSByZW5hbWVfdHlwZSByZW5hbWVfdHlwZSwKCQkJCQkgICAgICBzdHJ1Y3QgZGlmZl9maWxlcGFpciAqcGFpcjEsCgkJCQkJICAgICAgc3RydWN0IGRpZmZfZmlsZXBhaXIgKnBhaXIyLAoJCQkJCSAgICAgIGNvbnN0IGNoYXIgKmJyYW5jaDEsCgkJCQkJICAgICAgY29uc3QgY2hhciAqYnJhbmNoMiwKCQkJCQkgICAgICBzdHJ1Y3Qgc3RhZ2VfZGF0YSAqZHN0X2VudHJ5MSwKCQkJCQkgICAgICBzdHJ1Y3Qgc3RhZ2VfZGF0YSAqZHN0X2VudHJ5MiwKCQkJCQkgICAgICBzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyAqbywKCQkJCQkgICAgICBzdHJ1Y3Qgc3RhZ2VfZGF0YSAqc3JjX2VudHJ5MSwKCQkJCQkgICAgICBzdHJ1Y3Qgc3RhZ2VfZGF0YSAqc3JjX2VudHJ5MikKewoJc3RydWN0IHJlbmFtZV9jb25mbGljdF9pbmZvICpjaSA9IHhjYWxsb2MoMSwgc2l6ZW9mKHN0cnVjdCByZW5hbWVfY29uZmxpY3RfaW5mbykpOwoJY2ktPnJlbmFtZV90eXBlID0gcmVuYW1lX3R5cGU7CgljaS0+cGFpcjEgPSBwYWlyMTsKCWNpLT5icmFuY2gxID0gYnJhbmNoMTsKCWNpLT5icmFuY2gyID0gYnJhbmNoMjsKCgljaS0+ZHN0X2VudHJ5MSA9IGRzdF9lbnRyeTE7Cglkc3RfZW50cnkxLT5yZW5hbWVfY29uZmxpY3RfaW5mbyA9IGNpOwoJZHN0X2VudHJ5MS0+cHJvY2Vzc2VkID0gMDsKCglhc3NlcnQoIXBhaXIyID09ICFkc3RfZW50cnkyKTsKCWlmIChkc3RfZW50cnkyKSB7CgkJY2ktPmRzdF9lbnRyeTIgPSBkc3RfZW50cnkyOwoJCWNpLT5wYWlyMiA9IHBhaXIyOwoJCWRzdF9lbnRyeTItPnJlbmFtZV9jb25mbGljdF9pbmZvID0gY2k7Cgl9CgoJaWYgKHJlbmFtZV90eXBlID09IFJFTkFNRV9UV09fRklMRVNfVE9fT05FKSB7CgkJLyoKCQkgKiBGb3IgZWFjaCByZW5hbWUsIHRoZXJlIGNvdWxkIGhhdmUgYmVlbgoJCSAqIG1vZGlmaWNhdGlvbnMgb24gdGhlIHNpZGUgb2YgaGlzdG9yeSB3aGVyZSB0aGF0CgkJICogZmlsZSB3YXMgbm90IHJlbmFtZWQuCgkJICovCgkJaW50IG9zdGFnZTEgPSBvLT5icmFuY2gxID09IGJyYW5jaDEgPyAzIDogMjsKCQlpbnQgb3N0YWdlMiA9IG9zdGFnZTEgXiAxOwoKCQljaS0+cmVuMV9vdGhlci5wYXRoID0gcGFpcjEtPm9uZS0+cGF0aDsKCQlvaWRjcHkoJmNpLT5yZW4xX290aGVyLm9pZCwgJnNyY19lbnRyeTEtPnN0YWdlc1tvc3RhZ2UxXS5vaWQpOwoJCWNpLT5yZW4xX290aGVyLm1vZGUgPSBzcmNfZW50cnkxLT5zdGFnZXNbb3N0YWdlMV0ubW9kZTsKCgkJY2ktPnJlbjJfb3RoZXIucGF0aCA9IHBhaXIyLT5vbmUtPnBhdGg7CgkJb2lkY3B5KCZjaS0+cmVuMl9vdGhlci5vaWQsICZzcmNfZW50cnkyLT5zdGFnZXNbb3N0YWdlMl0ub2lkKTsKCQljaS0+cmVuMl9vdGhlci5tb2RlID0gc3JjX2VudHJ5Mi0+c3RhZ2VzW29zdGFnZTJdLm1vZGU7Cgl9Cn0KCnN0YXRpYyBpbnQgc2hvdyhzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyAqbywgaW50IHYpCnsKCXJldHVybiAoIW8tPmNhbGxfZGVwdGggJiYgby0+dmVyYm9zaXR5ID49IHYpIHx8IG8tPnZlcmJvc2l0eSA+PSA1Owp9CgpfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMywgNCkpKQpzdGF0aWMgdm9pZCBvdXRwdXQoc3RydWN0IG1lcmdlX29wdGlvbnMgKm8sIGludCB2LCBjb25zdCBjaGFyICpmbXQsIC4uLikKewoJdmFfbGlzdCBhcDsKCglpZiAoIXNob3cobywgdikpCgkJcmV0dXJuOwoKCXN0cmJ1Zl9hZGRjaGFycygmby0+b2J1ZiwgJyAnLCBvLT5jYWxsX2RlcHRoICogMik7CgoJdmFfc3RhcnQoYXAsIGZtdCk7CglzdHJidWZfdmFkZGYoJm8tPm9idWYsIGZtdCwgYXApOwoJdmFfZW5kKGFwKTsKCglzdHJidWZfYWRkY2goJm8tPm9idWYsICdcbicpOwoJaWYgKCFvLT5idWZmZXJfb3V0cHV0KQoJCWZsdXNoX291dHB1dChvKTsKfQoKc3RhdGljIHZvaWQgb3V0cHV0X2NvbW1pdF90aXRsZShzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyAqbywgc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglzdHJidWZfYWRkY2hhcnMoJm8tPm9idWYsICcgJywgby0+Y2FsbF9kZXB0aCAqIDIpOwoJaWYgKGNvbW1pdC0+dXRpbCkKCQlzdHJidWZfYWRkZigmby0+b2J1ZiwgInZpcnR1YWwgJXNcbiIsCgkJCW1lcmdlX3JlbW90ZV91dGlsKGNvbW1pdCktPm5hbWUpOwoJZWxzZSB7CgkJc3RyYnVmX2FkZF91bmlxdWVfYWJicmV2KCZvLT5vYnVmLCBjb21taXQtPm9iamVjdC5vaWQuaGFzaCwKCQkJCQkgREVGQVVMVF9BQkJSRVYpOwoJCXN0cmJ1Zl9hZGRjaCgmby0+b2J1ZiwgJyAnKTsKCQlpZiAocGFyc2VfY29tbWl0KGNvbW1pdCkgIT0gMCkKCQkJc3RyYnVmX2FkZHN0cigmby0+b2J1ZiwgXygiKGJhZCBjb21taXQpXG4iKSk7CgkJZWxzZSB7CgkJCWNvbnN0IGNoYXIgKnRpdGxlOwoJCQljb25zdCBjaGFyICptc2cgPSBnZXRfY29tbWl0X2J1ZmZlcihjb21taXQsIE5VTEwpOwoJCQlpbnQgbGVuID0gZmluZF9jb21taXRfc3ViamVjdChtc2csICZ0aXRsZSk7CgkJCWlmIChsZW4pCgkJCQlzdHJidWZfYWRkZigmby0+b2J1ZiwgIiUuKnNcbiIsIGxlbiwgdGl0bGUpOwoJCQl1bnVzZV9jb21taXRfYnVmZmVyKGNvbW1pdCwgbXNnKTsKCQl9Cgl9CglmbHVzaF9vdXRwdXQobyk7Cn0KCnN0YXRpYyBpbnQgYWRkX2NhY2hlaW5mbyhzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyAqbywKCQl1bnNpZ25lZCBpbnQgbW9kZSwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCWNvbnN0IGNoYXIgKnBhdGgsIGludCBzdGFnZSwgaW50IHJlZnJlc2gsIGludCBvcHRpb25zKQp7CglzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlOwoJaW50IHJldDsKCgljZSA9IG1ha2VfY2FjaGVfZW50cnkobW9kZSwgb2lkID8gb2lkLT5oYXNoIDogbnVsbF9zaGExLCBwYXRoLCBzdGFnZSwgMCk7CglpZiAoIWNlKQoJCXJldHVybiBlcnIobywgXygiYWRkaW5mb19jYWNoZSBmYWlsZWQgZm9yIHBhdGggJyVzJyIpLCBwYXRoKTsKCglyZXQgPSBhZGRfY2FjaGVfZW50cnkoY2UsIG9wdGlvbnMpOwoJaWYgKHJlZnJlc2gpIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKm5jZTsKCgkJbmNlID0gcmVmcmVzaF9jYWNoZV9lbnRyeShjZSwgQ0VfTUFUQ0hfUkVGUkVTSCB8IENFX01BVENIX0lHTk9SRV9NSVNTSU5HKTsKCQlpZiAoIW5jZSkKCQkJcmV0dXJuIGVycihvLCBfKCJhZGRpbmZvX2NhY2hlIGZhaWxlZCBmb3IgcGF0aCAnJXMnIiksIHBhdGgpOwoJCWlmIChuY2UgIT0gY2UpCgkJCXJldCA9IGFkZF9jYWNoZV9lbnRyeShuY2UsIG9wdGlvbnMpOwoJfQoJcmV0dXJuIHJldDsKfQoKc3RhdGljIHZvaWQgaW5pdF90cmVlX2Rlc2NfZnJvbV90cmVlKHN0cnVjdCB0cmVlX2Rlc2MgKmRlc2MsIHN0cnVjdCB0cmVlICp0cmVlKQp7CglwYXJzZV90cmVlKHRyZWUpOwoJaW5pdF90cmVlX2Rlc2MoZGVzYywgdHJlZS0+YnVmZmVyLCB0cmVlLT5zaXplKTsKfQoKc3RhdGljIGludCBnaXRfbWVyZ2VfdHJlZXMoaW50IGluZGV4X29ubHksCgkJCSAgIHN0cnVjdCB0cmVlICpjb21tb24sCgkJCSAgIHN0cnVjdCB0cmVlICpoZWFkLAoJCQkgICBzdHJ1Y3QgdHJlZSAqbWVyZ2UpCnsKCWludCByYzsKCXN0cnVjdCB0cmVlX2Rlc2MgdFszXTsKCXN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyBvcHRzOwoKCW1lbXNldCgmb3B0cywgMCwgc2l6ZW9mKG9wdHMpKTsKCWlmIChpbmRleF9vbmx5KQoJCW9wdHMuaW5kZXhfb25seSA9IDE7CgllbHNlCgkJb3B0cy51cGRhdGUgPSAxOwoJb3B0cy5tZXJnZSA9IDE7CglvcHRzLmhlYWRfaWR4ID0gMjsKCW9wdHMuZm4gPSB0aHJlZXdheV9tZXJnZTsKCW9wdHMuc3JjX2luZGV4ID0gJnRoZV9pbmRleDsKCW9wdHMuZHN0X2luZGV4ID0gJnRoZV9pbmRleDsKCXNldHVwX3VucGFja190cmVlc19wb3JjZWxhaW4oJm9wdHMsICJtZXJnZSIpOwoKCWluaXRfdHJlZV9kZXNjX2Zyb21fdHJlZSh0KzAsIGNvbW1vbik7Cglpbml0X3RyZWVfZGVzY19mcm9tX3RyZWUodCsxLCBoZWFkKTsKCWluaXRfdHJlZV9kZXNjX2Zyb21fdHJlZSh0KzIsIG1lcmdlKTsKCglyYyA9IHVucGFja190cmVlcygzLCB0LCAmb3B0cyk7CgljYWNoZV90cmVlX2ZyZWUoJmFjdGl2ZV9jYWNoZV90cmVlKTsKCXJldHVybiByYzsKfQoKc3RydWN0IHRyZWUgKndyaXRlX3RyZWVfZnJvbV9tZW1vcnkoc3RydWN0IG1lcmdlX29wdGlvbnMgKm8pCnsKCXN0cnVjdCB0cmVlICpyZXN1bHQgPSBOVUxMOwoKCWlmICh1bm1lcmdlZF9jYWNoZSgpKSB7CgkJaW50IGk7CgkJZnByaW50ZihzdGRlcnIsICJCVUc6IFRoZXJlIGFyZSB1bm1lcmdlZCBpbmRleCBlbnRyaWVzOlxuIik7CgkJZm9yIChpID0gMDsgaSA8IGFjdGl2ZV9ucjsgaSsrKSB7CgkJCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBhY3RpdmVfY2FjaGVbaV07CgkJCWlmIChjZV9zdGFnZShjZSkpCgkJCQlmcHJpbnRmKHN0ZGVyciwgIkJVRzogJWQgJS4qc1xuIiwgY2Vfc3RhZ2UoY2UpLAoJCQkJCShpbnQpY2VfbmFtZWxlbihjZSksIGNlLT5uYW1lKTsKCQl9CgkJZGllKCJCVUc6IHVubWVyZ2VkIGluZGV4IGVudHJpZXMgaW4gbWVyZ2UtcmVjdXJzaXZlLmMiKTsKCX0KCglpZiAoIWFjdGl2ZV9jYWNoZV90cmVlKQoJCWFjdGl2ZV9jYWNoZV90cmVlID0gY2FjaGVfdHJlZSgpOwoKCWlmICghY2FjaGVfdHJlZV9mdWxseV92YWxpZChhY3RpdmVfY2FjaGVfdHJlZSkgJiYKCSAgICBjYWNoZV90cmVlX3VwZGF0ZSgmdGhlX2luZGV4LCAwKSA8IDApIHsKCQllcnIobywgXygiZXJyb3IgYnVpbGRpbmcgdHJlZXMiKSk7CgkJcmV0dXJuIE5VTEw7Cgl9CgoJcmVzdWx0ID0gbG9va3VwX3RyZWUoYWN0aXZlX2NhY2hlX3RyZWUtPnNoYTEpOwoKCXJldHVybiByZXN1bHQ7Cn0KCnN0YXRpYyBpbnQgc2F2ZV9maWxlc19kaXJzKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsCgkJc3RydWN0IHN0cmJ1ZiAqYmFzZSwgY29uc3QgY2hhciAqcGF0aCwKCQl1bnNpZ25lZCBpbnQgbW9kZSwgaW50IHN0YWdlLCB2b2lkICpjb250ZXh0KQp7CglpbnQgYmFzZWxlbiA9IGJhc2UtPmxlbjsKCXN0cnVjdCBtZXJnZV9vcHRpb25zICpvID0gY29udGV4dDsKCglzdHJidWZfYWRkc3RyKGJhc2UsIHBhdGgpOwoKCWlmIChTX0lTRElSKG1vZGUpKQoJCXN0cmluZ19saXN0X2luc2VydCgmby0+Y3VycmVudF9kaXJlY3Rvcnlfc2V0LCBiYXNlLT5idWYpOwoJZWxzZQoJCXN0cmluZ19saXN0X2luc2VydCgmby0+Y3VycmVudF9maWxlX3NldCwgYmFzZS0+YnVmKTsKCglzdHJidWZfc2V0bGVuKGJhc2UsIGJhc2VsZW4pOwoJcmV0dXJuIChTX0lTRElSKG1vZGUpID8gUkVBRF9UUkVFX1JFQ1VSU0lWRSA6IDApOwp9CgpzdGF0aWMgaW50IGdldF9maWxlc19kaXJzKHN0cnVjdCBtZXJnZV9vcHRpb25zICpvLCBzdHJ1Y3QgdHJlZSAqdHJlZSkKewoJaW50IG47CglzdHJ1Y3QgcGF0aHNwZWMgbWF0Y2hfYWxsOwoJbWVtc2V0KCZtYXRjaF9hbGwsIDAsIHNpemVvZihtYXRjaF9hbGwpKTsKCWlmIChyZWFkX3RyZWVfcmVjdXJzaXZlKHRyZWUsICIiLCAwLCAwLCAmbWF0Y2hfYWxsLCBzYXZlX2ZpbGVzX2RpcnMsIG8pKQoJCXJldHVybiAwOwoJbiA9IG8tPmN1cnJlbnRfZmlsZV9zZXQubnIgKyBvLT5jdXJyZW50X2RpcmVjdG9yeV9zZXQubnI7CglyZXR1cm4gbjsKfQoKLyoKICogUmV0dXJucyBhbiBpbmRleF9lbnRyeSBpbnN0YW5jZSB3aGljaCBkb2Vzbid0IGhhdmUgdG8gY29ycmVzcG9uZCB0bwogKiBhIHJlYWwgY2FjaGUgZW50cnkgaW4gR2l0J3MgaW5kZXguCiAqLwpzdGF0aWMgc3RydWN0IHN0YWdlX2RhdGEgKmluc2VydF9zdGFnZV9kYXRhKGNvbnN0IGNoYXIgKnBhdGgsCgkJc3RydWN0IHRyZWUgKm8sIHN0cnVjdCB0cmVlICphLCBzdHJ1Y3QgdHJlZSAqYiwKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmVudHJpZXMpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoJc3RydWN0IHN0YWdlX2RhdGEgKmUgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3Qgc3RhZ2VfZGF0YSkpOwoJZ2V0X3RyZWVfZW50cnkoby0+b2JqZWN0Lm9pZC5oYXNoLCBwYXRoLAoJCQllLT5zdGFnZXNbMV0ub2lkLmhhc2gsICZlLT5zdGFnZXNbMV0ubW9kZSk7CglnZXRfdHJlZV9lbnRyeShhLT5vYmplY3Qub2lkLmhhc2gsIHBhdGgsCgkJCWUtPnN0YWdlc1syXS5vaWQuaGFzaCwgJmUtPnN0YWdlc1syXS5tb2RlKTsKCWdldF90cmVlX2VudHJ5KGItPm9iamVjdC5vaWQuaGFzaCwgcGF0aCwKCQkJZS0+c3RhZ2VzWzNdLm9pZC5oYXNoLCAmZS0+c3RhZ2VzWzNdLm1vZGUpOwoJaXRlbSA9IHN0cmluZ19saXN0X2luc2VydChlbnRyaWVzLCBwYXRoKTsKCWl0ZW0tPnV0aWwgPSBlOwoJcmV0dXJuIGU7Cn0KCi8qCiAqIENyZWF0ZSBhIGRpY3Rpb25hcnkgbWFwcGluZyBmaWxlIG5hbWVzIHRvIHN0YWdlX2RhdGEgb2JqZWN0cy4gVGhlCiAqIGRpY3Rpb25hcnkgY29udGFpbnMgb25lIGVudHJ5IGZvciBldmVyeSBwYXRoIHdpdGggYSBub24temVybyBzdGFnZSBlbnRyeS4KICovCnN0YXRpYyBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmdldF91bm1lcmdlZCh2b2lkKQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnVubWVyZ2VkID0geGNhbGxvYygxLCBzaXplb2Yoc3RydWN0IHN0cmluZ19saXN0KSk7CglpbnQgaTsKCgl1bm1lcmdlZC0+c3RyZHVwX3N0cmluZ3MgPSAxOwoKCWZvciAoaSA9IDA7IGkgPCBhY3RpdmVfbnI7IGkrKykgewoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoJCXN0cnVjdCBzdGFnZV9kYXRhICplOwoJCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBhY3RpdmVfY2FjaGVbaV07CgkJaWYgKCFjZV9zdGFnZShjZSkpCgkJCWNvbnRpbnVlOwoKCQlpdGVtID0gc3RyaW5nX2xpc3RfbG9va3VwKHVubWVyZ2VkLCBjZS0+bmFtZSk7CgkJaWYgKCFpdGVtKSB7CgkJCWl0ZW0gPSBzdHJpbmdfbGlzdF9pbnNlcnQodW5tZXJnZWQsIGNlLT5uYW1lKTsKCQkJaXRlbS0+dXRpbCA9IHhjYWxsb2MoMSwgc2l6ZW9mKHN0cnVjdCBzdGFnZV9kYXRhKSk7CgkJfQoJCWUgPSBpdGVtLT51dGlsOwoJCWUtPnN0YWdlc1tjZV9zdGFnZShjZSldLm1vZGUgPSBjZS0+Y2VfbW9kZTsKCQlvaWRjcHkoJmUtPnN0YWdlc1tjZV9zdGFnZShjZSldLm9pZCwgJmNlLT5vaWQpOwoJfQoKCXJldHVybiB1bm1lcmdlZDsKfQoKc3RhdGljIGludCBzdHJpbmdfbGlzdF9kZl9uYW1lX2NvbXBhcmUoY29uc3QgY2hhciAqb25lLCBjb25zdCBjaGFyICp0d28pCnsKCWludCBvbmVsZW4gPSBzdHJsZW4ob25lKTsKCWludCB0d29sZW4gPSBzdHJsZW4odHdvKTsKCS8qCgkgKiBIZXJlIHdlIG9ubHkgY2FyZSB0aGF0IGVudHJpZXMgZm9yIEQvRiBjb25mbGljdHMgYXJlCgkgKiBhZGphY2VudCwgaW4gcGFydGljdWxhciB3aXRoIHRoZSBmaWxlIG9mIHRoZSBEL0YgY29uZmxpY3QKCSAqIGFwcGVhcmluZyBiZWZvcmUgZmlsZXMgYmVsb3cgdGhlIGNvcnJlc3BvbmRpbmcgZGlyZWN0b3J5LgoJICogVGhlIG9yZGVyIG9mIHRoZSByZXN0IG9mIHRoZSBsaXN0IGlzIGlycmVsZXZhbnQgZm9yIHVzLgoJICoKCSAqIFRvIGFjaGlldmUgdGhpcywgd2Ugc29ydCB3aXRoIGRmX25hbWVfY29tcGFyZSBhbmQgcHJvdmlkZQoJICogdGhlIG1vZGUgU19JRkRJUiBzbyB0aGF0IEQvRiBjb25mbGljdHMgd2lsbCBzb3J0IGNvcnJlY3RseS4KCSAqIFdlIHVzZSB0aGUgbW9kZSBTX0lGRElSIGZvciBldmVyeXRoaW5nIGVsc2UgZm9yIHNpbXBsaWNpdHksCgkgKiBzaW5jZSBpbiBvdGhlciBjYXNlcyBhbnkgY2hhbmdlcyBpbiB0aGVpciBvcmRlciBkdWUgdG8KCSAqIHNvcnRpbmcgY2F1c2Ugbm8gcHJvYmxlbXMgZm9yIHVzLgoJICovCglpbnQgY21wID0gZGZfbmFtZV9jb21wYXJlKG9uZSwgb25lbGVuLCBTX0lGRElSLAoJCQkJICB0d28sIHR3b2xlbiwgU19JRkRJUik7CgkvKgoJICogTm93IHRoYXQgJ2ZvbycgYW5kICdmb28vYmFyJyBjb21wYXJlIGVxdWFsLCB3ZSBoYXZlIHRvIG1ha2Ugc3VyZQoJICogdGhhdCAnZm9vJyBjb21lcyBiZWZvcmUgJ2Zvby9iYXInLgoJICovCglpZiAoY21wKQoJCXJldHVybiBjbXA7CglyZXR1cm4gb25lbGVuIC0gdHdvbGVuOwp9CgpzdGF0aWMgdm9pZCByZWNvcmRfZGZfY29uZmxpY3RfZmlsZXMoc3RydWN0IG1lcmdlX29wdGlvbnMgKm8sCgkJCQkgICAgIHN0cnVjdCBzdHJpbmdfbGlzdCAqZW50cmllcykKewoJLyogSWYgdGhlcmUgaXMgYSBEL0YgY29uZmxpY3QgYW5kIHRoZSBmaWxlIGZvciBzdWNoIGEgY29uZmxpY3QKCSAqIGN1cnJlbnRseSBleGlzdCBpbiB0aGUgd29ya2luZyB0cmVlLCB3ZSB3YW50IHRvIGFsbG93IGl0IHRvIGJlCgkgKiByZW1vdmVkIHRvIG1ha2Ugcm9vbSBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgZGlyZWN0b3J5IGlmIG5lZWRlZC4KCSAqIFRoZSBmaWxlcyB1bmRlcm5lYXRoIHRoZSBkaXJlY3RvcmllcyBvZiBzdWNoIEQvRiBjb25mbGljdHMgd2lsbAoJICogYmUgcHJvY2Vzc2VkIGJlZm9yZSB0aGUgY29ycmVzcG9uZGluZyBmaWxlIGludm9sdmVkIGluIHRoZSBEL0YKCSAqIGNvbmZsaWN0LiAgSWYgdGhlIEQvRiBkaXJlY3RvcnkgZW5kcyB1cCBiZWluZyByZW1vdmVkIGJ5IHRoZQoJICogbWVyZ2UsIHRoZW4gd2Ugd29uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgRC9GIGZpbGUuICBJZiB0aGUgRC9GCgkgKiBkaXJlY3RvcnkgbmVlZHMgdG8gYmUgd3JpdHRlbiB0byB0aGUgd29ya2luZyBjb3B5LCB0aGVuIHRoZSBEL0YKCSAqIGZpbGUgd2lsbCBzaW1wbHkgYmUgcmVtb3ZlZCAoaW4gbWFrZV9yb29tX2Zvcl9wYXRoKCkpIHRvIG1ha2UKCSAqIHJvb20gZm9yIHRoZSBuZWNlc3NhcnkgcGF0aHMuICBOb3RlIHRoYXQgaWYgYm90aCB0aGUgZGlyZWN0b3J5CgkgKiBhbmQgdGhlIGZpbGUgbmVlZCB0byBiZSBwcmVzZW50LCB0aGVuIHRoZSBEL0YgZmlsZSB3aWxsIGJlCgkgKiByZWluc3RhdGVkIHdpdGggYSBuZXcgdW5pcXVlIG5hbWUgYXQgdGhlIHRpbWUgaXQgaXMgcHJvY2Vzc2VkLgoJICovCglzdHJ1Y3Qgc3RyaW5nX2xpc3QgZGZfc29ydGVkX2VudHJpZXMgPSBTVFJJTkdfTElTVF9JTklUX05PRFVQOwoJY29uc3QgY2hhciAqbGFzdF9maWxlID0gTlVMTDsKCWludCBsYXN0X2xlbiA9IDA7CglpbnQgaTsKCgkvKgoJICogSWYgd2UncmUgbWVyZ2luZyBtZXJnZS1iYXNlcywgd2UgZG9uJ3Qgd2FudCB0byBib3RoZXIgd2l0aAoJICogYW55IHdvcmtpbmcgZGlyZWN0b3J5IGNoYW5nZXMuCgkgKi8KCWlmIChvLT5jYWxsX2RlcHRoKQoJCXJldHVybjsKCgkvKiBFbnN1cmUgRC9GIGNvbmZsaWN0cyBhcmUgYWRqYWNlbnQgaW4gdGhlIGVudHJpZXMgbGlzdC4gKi8KCWZvciAoaSA9IDA7IGkgPCBlbnRyaWVzLT5ucjsgaSsrKSB7CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKm5leHQgPSAmZW50cmllcy0+aXRlbXNbaV07CgkJc3RyaW5nX2xpc3RfYXBwZW5kKCZkZl9zb3J0ZWRfZW50cmllcywgbmV4dC0+c3RyaW5nKS0+dXRpbCA9CgkJCQkgICBuZXh0LT51dGlsOwoJfQoJZGZfc29ydGVkX2VudHJpZXMuY21wID0gc3RyaW5nX2xpc3RfZGZfbmFtZV9jb21wYXJlOwoJc3RyaW5nX2xpc3Rfc29ydCgmZGZfc29ydGVkX2VudHJpZXMpOwoKCXN0cmluZ19saXN0X2NsZWFyKCZvLT5kZl9jb25mbGljdF9maWxlX3NldCwgMSk7Cglmb3IgKGkgPSAwOyBpIDwgZGZfc29ydGVkX2VudHJpZXMubnI7IGkrKykgewoJCWNvbnN0IGNoYXIgKnBhdGggPSBkZl9zb3J0ZWRfZW50cmllcy5pdGVtc1tpXS5zdHJpbmc7CgkJaW50IGxlbiA9IHN0cmxlbihwYXRoKTsKCQlzdHJ1Y3Qgc3RhZ2VfZGF0YSAqZSA9IGRmX3NvcnRlZF9lbnRyaWVzLml0ZW1zW2ldLnV0aWw7CgoJCS8qCgkJICogQ2hlY2sgaWYgbGFzdF9maWxlICYgcGF0aCBjb3JyZXNwb25kIHRvIGEgRC9GIGNvbmZsaWN0OwoJCSAqIGkuZS4gd2hldGhlciBwYXRoIGlzIGxhc3RfZmlsZSsnLycrPHNvbWV0aGluZz4uCgkJICogSWYgc28sIHJlY29yZCB0aGF0IGl0J3Mgb2theSB0byByZW1vdmUgbGFzdF9maWxlIHRvIG1ha2UKCQkgKiByb29tIGZvciBwYXRoIGFuZCBmcmllbmRzIGlmIG5lZWRlZC4KCQkgKi8KCQlpZiAobGFzdF9maWxlICYmCgkJICAgIGxlbiA+IGxhc3RfbGVuICYmCgkJICAgIG1lbWNtcChwYXRoLCBsYXN0X2ZpbGUsIGxhc3RfbGVuKSA9PSAwICYmCgkJICAgIHBhdGhbbGFzdF9sZW5dID09ICcvJykgewoJCQlzdHJpbmdfbGlzdF9pbnNlcnQoJm8tPmRmX2NvbmZsaWN0X2ZpbGVfc2V0LCBsYXN0X2ZpbGUpOwoJCX0KCgkJLyoKCQkgKiBEZXRlcm1pbmUgd2hldGhlciBwYXRoIGNvdWxkIGV4aXN0IGFzIGEgZmlsZSBpbiB0aGUKCQkgKiB3b3JraW5nIGRpcmVjdG9yeSBhcyBhIHBvc3NpYmxlIEQvRiBjb25mbGljdC4gIFRoaXMKCQkgKiB3aWxsIG9ubHkgb2NjdXIgd2hlbiBpdCBleGlzdHMgaW4gc3RhZ2UgMiBhcyBhCgkJICogZmlsZS4KCQkgKi8KCQlpZiAoU19JU1JFRyhlLT5zdGFnZXNbMl0ubW9kZSkgfHwgU19JU0xOSyhlLT5zdGFnZXNbMl0ubW9kZSkpIHsKCQkJbGFzdF9maWxlID0gcGF0aDsKCQkJbGFzdF9sZW4gPSBsZW47CgkJfSBlbHNlIHsKCQkJbGFzdF9maWxlID0gTlVMTDsKCQl9Cgl9CglzdHJpbmdfbGlzdF9jbGVhcigmZGZfc29ydGVkX2VudHJpZXMsIDApOwp9CgpzdHJ1Y3QgcmVuYW1lIHsKCXN0cnVjdCBkaWZmX2ZpbGVwYWlyICpwYWlyOwoJc3RydWN0IHN0YWdlX2RhdGEgKnNyY19lbnRyeTsKCXN0cnVjdCBzdGFnZV9kYXRhICpkc3RfZW50cnk7Cgl1bnNpZ25lZCBwcm9jZXNzZWQ6MTsKfTsKCi8qCiAqIEdldCBpbmZvcm1hdGlvbiBvZiBhbGwgcmVuYW1lcyB3aGljaCBvY2N1cnJlZCBiZXR3ZWVuICdvX3RyZWUnIGFuZAogKiAndHJlZScuIFdlIG5lZWQgdGhlIHRocmVlIHRyZWVzIGluIHRoZSBtZXJnZSAoJ29fdHJlZScsICdhX3RyZWUnIGFuZAogKiAnYl90cmVlJykgdG8gYmUgYWJsZSB0byBhc3NvY2lhdGUgdGhlIGNvcnJlY3QgY2FjaGUgZW50cmllcyB3aXRoCiAqIHRoZSByZW5hbWUgaW5mb3JtYXRpb24uICd0cmVlJyBpcyBhbHdheXMgZXF1YWwgdG8gZWl0aGVyIGFfdHJlZSBvciBiX3RyZWUuCiAqLwpzdGF0aWMgc3RydWN0IHN0cmluZ19saXN0ICpnZXRfcmVuYW1lcyhzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyAqbywKCQkJCSAgICAgICBzdHJ1Y3QgdHJlZSAqdHJlZSwKCQkJCSAgICAgICBzdHJ1Y3QgdHJlZSAqb190cmVlLAoJCQkJICAgICAgIHN0cnVjdCB0cmVlICphX3RyZWUsCgkJCQkgICAgICAgc3RydWN0IHRyZWUgKmJfdHJlZSwKCQkJCSAgICAgICBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmVudHJpZXMpCnsKCWludCBpOwoJc3RydWN0IHN0cmluZ19saXN0ICpyZW5hbWVzOwoJc3RydWN0IGRpZmZfb3B0aW9ucyBvcHRzOwoKCXJlbmFtZXMgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3Qgc3RyaW5nX2xpc3QpKTsKCWlmICghby0+ZGV0ZWN0X3JlbmFtZSkKCQlyZXR1cm4gcmVuYW1lczsKCglkaWZmX3NldHVwKCZvcHRzKTsKCURJRkZfT1BUX1NFVCgmb3B0cywgUkVDVVJTSVZFKTsKCURJRkZfT1BUX0NMUigmb3B0cywgUkVOQU1FX0VNUFRZKTsKCW9wdHMuZGV0ZWN0X3JlbmFtZSA9IERJRkZfREVURUNUX1JFTkFNRTsKCW9wdHMucmVuYW1lX2xpbWl0ID0gby0+bWVyZ2VfcmVuYW1lX2xpbWl0ID49IDAgPyBvLT5tZXJnZV9yZW5hbWVfbGltaXQgOgoJCQkgICAgby0+ZGlmZl9yZW5hbWVfbGltaXQgPj0gMCA/IG8tPmRpZmZfcmVuYW1lX2xpbWl0IDoKCQkJICAgIDEwMDA7CglvcHRzLnJlbmFtZV9zY29yZSA9IG8tPnJlbmFtZV9zY29yZTsKCW9wdHMuc2hvd19yZW5hbWVfcHJvZ3Jlc3MgPSBvLT5zaG93X3JlbmFtZV9wcm9ncmVzczsKCW9wdHMub3V0cHV0X2Zvcm1hdCA9IERJRkZfRk9STUFUX05PX09VVFBVVDsKCWRpZmZfc2V0dXBfZG9uZSgmb3B0cyk7CglkaWZmX3RyZWVfc2hhMShvX3RyZWUtPm9iamVjdC5vaWQuaGFzaCwgdHJlZS0+b2JqZWN0Lm9pZC5oYXNoLCAiIiwgJm9wdHMpOwoJZGlmZmNvcmVfc3RkKCZvcHRzKTsKCWlmIChvcHRzLm5lZWRlZF9yZW5hbWVfbGltaXQgPiBvLT5uZWVkZWRfcmVuYW1lX2xpbWl0KQoJCW8tPm5lZWRlZF9yZW5hbWVfbGltaXQgPSBvcHRzLm5lZWRlZF9yZW5hbWVfbGltaXQ7Cglmb3IgKGkgPSAwOyBpIDwgZGlmZl9xdWV1ZWRfZGlmZi5ucjsgKytpKSB7CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW07CgkJc3RydWN0IHJlbmFtZSAqcmU7CgkJc3RydWN0IGRpZmZfZmlsZXBhaXIgKnBhaXIgPSBkaWZmX3F1ZXVlZF9kaWZmLnF1ZXVlW2ldOwoJCWlmIChwYWlyLT5zdGF0dXMgIT0gJ1InKSB7CgkJCWRpZmZfZnJlZV9maWxlcGFpcihwYWlyKTsKCQkJY29udGludWU7CgkJfQoJCXJlID0geG1hbGxvYyhzaXplb2YoKnJlKSk7CgkJcmUtPnByb2Nlc3NlZCA9IDA7CgkJcmUtPnBhaXIgPSBwYWlyOwoJCWl0ZW0gPSBzdHJpbmdfbGlzdF9sb29rdXAoZW50cmllcywgcmUtPnBhaXItPm9uZS0+cGF0aCk7CgkJaWYgKCFpdGVtKQoJCQlyZS0+c3JjX2VudHJ5ID0gaW5zZXJ0X3N0YWdlX2RhdGEocmUtPnBhaXItPm9uZS0+cGF0aCwKCQkJCQlvX3RyZWUsIGFfdHJlZSwgYl90cmVlLCBlbnRyaWVzKTsKCQllbHNlCgkJCXJlLT5zcmNfZW50cnkgPSBpdGVtLT51dGlsOwoKCQlpdGVtID0gc3RyaW5nX2xpc3RfbG9va3VwKGVudHJpZXMsIHJlLT5wYWlyLT50d28tPnBhdGgpOwoJCWlmICghaXRlbSkKCQkJcmUtPmRzdF9lbnRyeSA9IGluc2VydF9zdGFnZV9kYXRhKHJlLT5wYWlyLT50d28tPnBhdGgsCgkJCQkJb190cmVlLCBhX3RyZWUsIGJfdHJlZSwgZW50cmllcyk7CgkJZWxzZQoJCQlyZS0+ZHN0X2VudHJ5ID0gaXRlbS0+dXRpbDsKCQlpdGVtID0gc3RyaW5nX2xpc3RfaW5zZXJ0KHJlbmFtZXMsIHBhaXItPm9uZS0+cGF0aCk7CgkJaXRlbS0+dXRpbCA9IHJlOwoJfQoJb3B0cy5vdXRwdXRfZm9ybWF0ID0gRElGRl9GT1JNQVRfTk9fT1VUUFVUOwoJZGlmZl9xdWV1ZWRfZGlmZi5uciA9IDA7CglkaWZmX2ZsdXNoKCZvcHRzKTsKCXJldHVybiByZW5hbWVzOwp9CgpzdGF0aWMgaW50IHVwZGF0ZV9zdGFnZXMoc3RydWN0IG1lcmdlX29wdGlvbnMgKm9wdCwgY29uc3QgY2hhciAqcGF0aCwKCQkJIGNvbnN0IHN0cnVjdCBkaWZmX2ZpbGVzcGVjICpvLAoJCQkgY29uc3Qgc3RydWN0IGRpZmZfZmlsZXNwZWMgKmEsCgkJCSBjb25zdCBzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqYikKewoKCS8qCgkgKiBOT1RFOiBJdCBpcyB1c3VhbGx5IGEgYmFkIGlkZWEgdG8gY2FsbCB1cGRhdGVfc3RhZ2VzIG9uIGEgcGF0aAoJICogYmVmb3JlIGNhbGxpbmcgdXBkYXRlX2ZpbGUgb24gdGhhdCBzYW1lIHBhdGgsIHNpbmNlIGl0IGNhbgoJICogc29tZXRpbWVzIGxlYWQgdG8gc3B1cmlvdXMgInJlZnVzaW5nIHRvIGxvc2UgdW50cmFja2VkIGZpbGUuLi4iCgkgKiBtZXNzYWdlcyBmcm9tIHVwZGF0ZV9maWxlICh2aWEgbWFrZV9yb29tX2ZvciBwYXRoIHZpYQoJICogd291bGRfbG9zZV91bnRyYWNrZWQpLiAgSW5zdGVhZCwgcmV2ZXJzZSB0aGUgb3JkZXIgb2YgdGhlIGNhbGxzCgkgKiAoZXhlY3V0aW5nIHVwZGF0ZV9maWxlIGZpcnN0IGFuZCB0aGVuIHVwZGF0ZV9zdGFnZXMpLgoJICovCglpbnQgY2xlYXIgPSAxOwoJaW50IG9wdGlvbnMgPSBBRERfQ0FDSEVfT0tfVE9fQUREIHwgQUREX0NBQ0hFX1NLSVBfREZDSEVDSzsKCWlmIChjbGVhcikKCQlpZiAocmVtb3ZlX2ZpbGVfZnJvbV9jYWNoZShwYXRoKSkKCQkJcmV0dXJuIC0xOwoJaWYgKG8pCgkJaWYgKGFkZF9jYWNoZWluZm8ob3B0LCBvLT5tb2RlLCAmby0+b2lkLCBwYXRoLCAxLCAwLCBvcHRpb25zKSkKCQkJcmV0dXJuIC0xOwoJaWYgKGEpCgkJaWYgKGFkZF9jYWNoZWluZm8ob3B0LCBhLT5tb2RlLCAmYS0+b2lkLCBwYXRoLCAyLCAwLCBvcHRpb25zKSkKCQkJcmV0dXJuIC0xOwoJaWYgKGIpCgkJaWYgKGFkZF9jYWNoZWluZm8ob3B0LCBiLT5tb2RlLCAmYi0+b2lkLCBwYXRoLCAzLCAwLCBvcHRpb25zKSkKCQkJcmV0dXJuIC0xOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHVwZGF0ZV9lbnRyeShzdHJ1Y3Qgc3RhZ2VfZGF0YSAqZW50cnksCgkJCSBzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqbywKCQkJIHN0cnVjdCBkaWZmX2ZpbGVzcGVjICphLAoJCQkgc3RydWN0IGRpZmZfZmlsZXNwZWMgKmIpCnsKCWVudHJ5LT5wcm9jZXNzZWQgPSAwOwoJZW50cnktPnN0YWdlc1sxXS5tb2RlID0gby0+bW9kZTsKCWVudHJ5LT5zdGFnZXNbMl0ubW9kZSA9IGEtPm1vZGU7CgllbnRyeS0+c3RhZ2VzWzNdLm1vZGUgPSBiLT5tb2RlOwoJb2lkY3B5KCZlbnRyeS0+c3RhZ2VzWzFdLm9pZCwgJm8tPm9pZCk7CglvaWRjcHkoJmVudHJ5LT5zdGFnZXNbMl0ub2lkLCAmYS0+b2lkKTsKCW9pZGNweSgmZW50cnktPnN0YWdlc1szXS5vaWQsICZiLT5vaWQpOwp9CgpzdGF0aWMgaW50IHJlbW92ZV9maWxlKHN0cnVjdCBtZXJnZV9vcHRpb25zICpvLCBpbnQgY2xlYW4sCgkJICAgICAgIGNvbnN0IGNoYXIgKnBhdGgsIGludCBub193ZCkKewoJaW50IHVwZGF0ZV9jYWNoZSA9IG8tPmNhbGxfZGVwdGggfHwgY2xlYW47CglpbnQgdXBkYXRlX3dvcmtpbmdfZGlyZWN0b3J5ID0gIW8tPmNhbGxfZGVwdGggJiYgIW5vX3dkOwoKCWlmICh1cGRhdGVfY2FjaGUpIHsKCQlpZiAocmVtb3ZlX2ZpbGVfZnJvbV9jYWNoZShwYXRoKSkKCQkJcmV0dXJuIC0xOwoJfQoJaWYgKHVwZGF0ZV93b3JraW5nX2RpcmVjdG9yeSkgewoJCWlmIChpZ25vcmVfY2FzZSkgewoJCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlOwoJCQljZSA9IGNhY2hlX2ZpbGVfZXhpc3RzKHBhdGgsIHN0cmxlbihwYXRoKSwgaWdub3JlX2Nhc2UpOwoJCQlpZiAoY2UgJiYgY2Vfc3RhZ2UoY2UpID09IDApCgkJCQlyZXR1cm4gMDsKCQl9CgkJaWYgKHJlbW92ZV9wYXRoKHBhdGgpKQoJCQlyZXR1cm4gLTE7Cgl9CglyZXR1cm4gMDsKfQoKLyogYWRkIGEgc3RyaW5nIHRvIGEgc3RyYnVmLCBidXQgY29udmVydGluZyAiLyIgdG8gIl8iICovCnN0YXRpYyB2b2lkIGFkZF9mbGF0dGVuZWRfcGF0aChzdHJ1Y3Qgc3RyYnVmICpvdXQsIGNvbnN0IGNoYXIgKnMpCnsKCXNpemVfdCBpID0gb3V0LT5sZW47CglzdHJidWZfYWRkc3RyKG91dCwgcyk7Cglmb3IgKDsgaSA8IG91dC0+bGVuOyBpKyspCgkJaWYgKG91dC0+YnVmW2ldID09ICcvJykKCQkJb3V0LT5idWZbaV0gPSAnXyc7Cn0KCnN0YXRpYyBjaGFyICp1bmlxdWVfcGF0aChzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyAqbywgY29uc3QgY2hhciAqcGF0aCwgY29uc3QgY2hhciAqYnJhbmNoKQp7CglzdHJ1Y3Qgc3RyYnVmIG5ld3BhdGggPSBTVFJCVUZfSU5JVDsKCWludCBzdWZmaXggPSAwOwoJc2l6ZV90IGJhc2VfbGVuOwoKCXN0cmJ1Zl9hZGRmKCZuZXdwYXRoLCAiJXN+IiwgcGF0aCk7CglhZGRfZmxhdHRlbmVkX3BhdGgoJm5ld3BhdGgsIGJyYW5jaCk7CgoJYmFzZV9sZW4gPSBuZXdwYXRoLmxlbjsKCXdoaWxlIChzdHJpbmdfbGlzdF9oYXNfc3RyaW5nKCZvLT5jdXJyZW50X2ZpbGVfc2V0LCBuZXdwYXRoLmJ1ZikgfHwKCSAgICAgICBzdHJpbmdfbGlzdF9oYXNfc3RyaW5nKCZvLT5jdXJyZW50X2RpcmVjdG9yeV9zZXQsIG5ld3BhdGguYnVmKSB8fAoJICAgICAgICghby0+Y2FsbF9kZXB0aCAmJiBmaWxlX2V4aXN0cyhuZXdwYXRoLmJ1ZikpKSB7CgkJc3RyYnVmX3NldGxlbigmbmV3cGF0aCwgYmFzZV9sZW4pOwoJCXN0cmJ1Zl9hZGRmKCZuZXdwYXRoLCAiXyVkIiwgc3VmZml4KyspOwoJfQoKCXN0cmluZ19saXN0X2luc2VydCgmby0+Y3VycmVudF9maWxlX3NldCwgbmV3cGF0aC5idWYpOwoJcmV0dXJuIHN0cmJ1Zl9kZXRhY2goJm5ld3BhdGgsIE5VTEwpOwp9CgovKioKICogQ2hlY2sgd2hldGhlciBhIGRpcmVjdG9yeSBpbiB0aGUgaW5kZXggaXMgaW4gdGhlIHdheSBvZiBhbiBpbmNvbWluZwogKiBmaWxlLiAgUmV0dXJuIDEgaWYgc28uICBJZiBjaGVja193b3JraW5nX2NvcHkgaXMgbm9uLXplcm8sIGFsc28KICogY2hlY2sgdGhlIHdvcmtpbmcgZGlyZWN0b3J5LiAgSWYgZW1wdHlfb2sgaXMgbm9uLXplcm8sIGFsc28gcmV0dXJuCiAqIDAgaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHdvcmtpbmctdHJlZSBkaXIgZXhpc3RzIGJ1dCBpcyBlbXB0eS4KICovCnN0YXRpYyBpbnQgZGlyX2luX3dheShjb25zdCBjaGFyICpwYXRoLCBpbnQgY2hlY2tfd29ya2luZ19jb3B5LCBpbnQgZW1wdHlfb2spCnsKCWludCBwb3M7CglzdHJ1Y3Qgc3RyYnVmIGRpcnBhdGggPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdGF0IHN0OwoKCXN0cmJ1Zl9hZGRzdHIoJmRpcnBhdGgsIHBhdGgpOwoJc3RyYnVmX2FkZGNoKCZkaXJwYXRoLCAnLycpOwoKCXBvcyA9IGNhY2hlX25hbWVfcG9zKGRpcnBhdGguYnVmLCBkaXJwYXRoLmxlbik7CgoJaWYgKHBvcyA8IDApCgkJcG9zID0gLTEgLSBwb3M7CglpZiAocG9zIDwgYWN0aXZlX25yICYmCgkgICAgIXN0cm5jbXAoZGlycGF0aC5idWYsIGFjdGl2ZV9jYWNoZVtwb3NdLT5uYW1lLCBkaXJwYXRoLmxlbikpIHsKCQlzdHJidWZfcmVsZWFzZSgmZGlycGF0aCk7CgkJcmV0dXJuIDE7Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJmRpcnBhdGgpOwoJcmV0dXJuIGNoZWNrX3dvcmtpbmdfY29weSAmJiAhbHN0YXQocGF0aCwgJnN0KSAmJiBTX0lTRElSKHN0LnN0X21vZGUpICYmCgkJIShlbXB0eV9vayAmJiBpc19lbXB0eV9kaXIocGF0aCkpOwp9CgpzdGF0aWMgaW50IHdhc190cmFja2VkKGNvbnN0IGNoYXIgKnBhdGgpCnsKCWludCBwb3MgPSBjYWNoZV9uYW1lX3BvcyhwYXRoLCBzdHJsZW4ocGF0aCkpOwoKCWlmICgwIDw9IHBvcykKCQkvKiB3ZSBoYXZlIGJlZW4gdHJhY2tpbmcgdGhpcyBwYXRoICovCgkJcmV0dXJuIDE7CgoJLyoKCSAqIExvb2sgZm9yIGFuIHVubWVyZ2VkIGVudHJ5IGZvciB0aGUgcGF0aCwKCSAqIHNwZWNpZmljYWxseSBzdGFnZSAjMiwgd2hpY2ggd291bGQgaW5kaWNhdGUKCSAqIHRoYXQgIm91ciIgc2lkZSBiZWZvcmUgdGhlIG1lcmdlIHN0YXJ0ZWQKCSAqIGhhZCB0aGUgcGF0aCB0cmFja2VkIChhbmQgcmVzdWx0ZWQgaW4gYSBjb25mbGljdCkuCgkgKi8KCWZvciAocG9zID0gLTEgLSBwb3M7CgkgICAgIHBvcyA8IGFjdGl2ZV9uciAmJiAhc3RyY21wKHBhdGgsIGFjdGl2ZV9jYWNoZVtwb3NdLT5uYW1lKTsKCSAgICAgcG9zKyspCgkJaWYgKGNlX3N0YWdlKGFjdGl2ZV9jYWNoZVtwb3NdKSA9PSAyKQoJCQlyZXR1cm4gMTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHdvdWxkX2xvc2VfdW50cmFja2VkKGNvbnN0IGNoYXIgKnBhdGgpCnsKCXJldHVybiAhd2FzX3RyYWNrZWQocGF0aCkgJiYgZmlsZV9leGlzdHMocGF0aCk7Cn0KCnN0YXRpYyBpbnQgbWFrZV9yb29tX2Zvcl9wYXRoKHN0cnVjdCBtZXJnZV9vcHRpb25zICpvLCBjb25zdCBjaGFyICpwYXRoKQp7CglpbnQgc3RhdHVzLCBpOwoJY29uc3QgY2hhciAqbXNnID0gXygiZmFpbGVkIHRvIGNyZWF0ZSBwYXRoICclcyclcyIpOwoKCS8qIFVubGluayBhbnkgRC9GIGNvbmZsaWN0IGZpbGVzIHRoYXQgYXJlIGluIHRoZSB3YXkgKi8KCWZvciAoaSA9IDA7IGkgPCBvLT5kZl9jb25mbGljdF9maWxlX3NldC5ucjsgaSsrKSB7CgkJY29uc3QgY2hhciAqZGZfcGF0aCA9IG8tPmRmX2NvbmZsaWN0X2ZpbGVfc2V0Lml0ZW1zW2ldLnN0cmluZzsKCQlzaXplX3QgcGF0aGxlbiA9IHN0cmxlbihwYXRoKTsKCQlzaXplX3QgZGZfcGF0aGxlbiA9IHN0cmxlbihkZl9wYXRoKTsKCQlpZiAoZGZfcGF0aGxlbiA8IHBhdGhsZW4gJiYKCQkgICAgcGF0aFtkZl9wYXRobGVuXSA9PSAnLycgJiYKCQkgICAgc3RybmNtcChwYXRoLCBkZl9wYXRoLCBkZl9wYXRobGVuKSA9PSAwKSB7CgkJCW91dHB1dChvLCAzLAoJCQkgICAgICAgXygiUmVtb3ZpbmcgJXMgdG8gbWFrZSByb29tIGZvciBzdWJkaXJlY3RvcnlcbiIpLAoJCQkgICAgICAgZGZfcGF0aCk7CgkJCXVubGluayhkZl9wYXRoKTsKCQkJdW5zb3J0ZWRfc3RyaW5nX2xpc3RfZGVsZXRlX2l0ZW0oJm8tPmRmX2NvbmZsaWN0X2ZpbGVfc2V0LAoJCQkJCQkJIGksIDApOwoJCQlicmVhazsKCQl9Cgl9CgoJLyogTWFrZSBzdXJlIGxlYWRpbmcgZGlyZWN0b3JpZXMgYXJlIGNyZWF0ZWQgKi8KCXN0YXR1cyA9IHNhZmVfY3JlYXRlX2xlYWRpbmdfZGlyZWN0b3JpZXNfY29uc3QocGF0aCk7CglpZiAoc3RhdHVzKSB7CgkJaWYgKHN0YXR1cyA9PSBTQ0xEX0VYSVNUUykKCQkJLyogc29tZXRoaW5nIGVsc2UgZXhpc3RzICovCgkJCXJldHVybiBlcnIobywgbXNnLCBwYXRoLCBfKCI6IHBlcmhhcHMgYSBEL0YgY29uZmxpY3Q/IikpOwoJCXJldHVybiBlcnIobywgbXNnLCBwYXRoLCAiIik7Cgl9CgoJLyoKCSAqIERvIG5vdCB1bmxpbmsgYSBmaWxlIGluIHRoZSB3b3JrIHRyZWUgaWYgd2UgYXJlIG5vdAoJICogdHJhY2tpbmcgaXQuCgkgKi8KCWlmICh3b3VsZF9sb3NlX3VudHJhY2tlZChwYXRoKSkKCQlyZXR1cm4gZXJyKG8sIF8oInJlZnVzaW5nIHRvIGxvc2UgdW50cmFja2VkIGZpbGUgYXQgJyVzJyIpLAoJCQkgICAgIHBhdGgpOwoKCS8qIFN1Y2Nlc3NmdWwgdW5saW5rIGlzIGdvb2QuLiAqLwoJaWYgKCF1bmxpbmsocGF0aCkpCgkJcmV0dXJuIDA7CgkvKiAuLiBhbmQgc28gaXMgbm8gZXhpc3RpbmcgZmlsZSAqLwoJaWYgKGVycm5vID09IEVOT0VOVCkKCQlyZXR1cm4gMDsKCS8qIC4uIGJ1dCBub3Qgc29tZSBvdGhlciBlcnJvciAod2hvIHJlYWxseSBjYXJlcyB3aGF0PykgKi8KCXJldHVybiBlcnIobywgbXNnLCBwYXRoLCBfKCI6IHBlcmhhcHMgYSBEL0YgY29uZmxpY3Q/IikpOwp9CgpzdGF0aWMgaW50IHVwZGF0ZV9maWxlX2ZsYWdzKHN0cnVjdCBtZXJnZV9vcHRpb25zICpvLAoJCQkgICAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJICAgICB1bnNpZ25lZCBtb2RlLAoJCQkgICAgIGNvbnN0IGNoYXIgKnBhdGgsCgkJCSAgICAgaW50IHVwZGF0ZV9jYWNoZSwKCQkJICAgICBpbnQgdXBkYXRlX3dkKQp7CglpbnQgcmV0ID0gMDsKCglpZiAoby0+Y2FsbF9kZXB0aCkKCQl1cGRhdGVfd2QgPSAwOwoKCWlmICh1cGRhdGVfd2QpIHsKCQllbnVtIG9iamVjdF90eXBlIHR5cGU7CgkJdm9pZCAqYnVmOwoJCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCgkJaWYgKFNfSVNHSVRMSU5LKG1vZGUpKSB7CgkJCS8qCgkJCSAqIFdlIG1heSBsYXRlciBkZWNpZGUgdG8gcmVjdXJzaXZlbHkgZGVzY2VuZCBpbnRvCgkJCSAqIHRoZSBzdWJtb2R1bGUgZGlyZWN0b3J5IGFuZCB1cGRhdGUgaXRzIGluZGV4CgkJCSAqIGFuZC9vciB3b3JrIHRyZWUsIGJ1dCB3ZSBkbyBub3QgZG8gdGhhdCBub3cuCgkJCSAqLwoJCQl1cGRhdGVfd2QgPSAwOwoJCQlnb3RvIHVwZGF0ZV9pbmRleDsKCQl9CgoJCWJ1ZiA9IHJlYWRfc2hhMV9maWxlKG9pZC0+aGFzaCwgJnR5cGUsICZzaXplKTsKCQlpZiAoIWJ1ZikKCQkJcmV0dXJuIGVycihvLCBfKCJjYW5ub3QgcmVhZCBvYmplY3QgJXMgJyVzJyIpLCBvaWRfdG9faGV4KG9pZCksIHBhdGgpOwoJCWlmICh0eXBlICE9IE9CSl9CTE9CKSB7CgkJCXJldCA9IGVycihvLCBfKCJibG9iIGV4cGVjdGVkIGZvciAlcyAnJXMnIiksIG9pZF90b19oZXgob2lkKSwgcGF0aCk7CgkJCWdvdG8gZnJlZV9idWY7CgkJfQoJCWlmIChTX0lTUkVHKG1vZGUpKSB7CgkJCXN0cnVjdCBzdHJidWYgc3RyYnVmID0gU1RSQlVGX0lOSVQ7CgkJCWlmIChjb252ZXJ0X3RvX3dvcmtpbmdfdHJlZShwYXRoLCBidWYsIHNpemUsICZzdHJidWYpKSB7CgkJCQlmcmVlKGJ1Zik7CgkJCQlzaXplID0gc3RyYnVmLmxlbjsKCQkJCWJ1ZiA9IHN0cmJ1Zl9kZXRhY2goJnN0cmJ1ZiwgTlVMTCk7CgkJCX0KCQl9CgoJCWlmIChtYWtlX3Jvb21fZm9yX3BhdGgobywgcGF0aCkgPCAwKSB7CgkJCXVwZGF0ZV93ZCA9IDA7CgkJCWdvdG8gZnJlZV9idWY7CgkJfQoJCWlmIChTX0lTUkVHKG1vZGUpIHx8ICghaGFzX3N5bWxpbmtzICYmIFNfSVNMTksobW9kZSkpKSB7CgkJCWludCBmZDsKCQkJaWYgKG1vZGUgJiAwMTAwKQoJCQkJbW9kZSA9IDA3Nzc7CgkJCWVsc2UKCQkJCW1vZGUgPSAwNjY2OwoJCQlmZCA9IG9wZW4ocGF0aCwgT19XUk9OTFkgfCBPX1RSVU5DIHwgT19DUkVBVCwgbW9kZSk7CgkJCWlmIChmZCA8IDApIHsKCQkJCXJldCA9IGVycihvLCBfKCJmYWlsZWQgdG8gb3BlbiAnJXMnOiAlcyIpLAoJCQkJCSAgcGF0aCwgc3RyZXJyb3IoZXJybm8pKTsKCQkJCWdvdG8gZnJlZV9idWY7CgkJCX0KCQkJd3JpdGVfaW5fZnVsbChmZCwgYnVmLCBzaXplKTsKCQkJY2xvc2UoZmQpOwoJCX0gZWxzZSBpZiAoU19JU0xOSyhtb2RlKSkgewoJCQljaGFyICpsbmsgPSB4bWVtZHVweihidWYsIHNpemUpOwoJCQlzYWZlX2NyZWF0ZV9sZWFkaW5nX2RpcmVjdG9yaWVzX2NvbnN0KHBhdGgpOwoJCQl1bmxpbmsocGF0aCk7CgkJCWlmIChzeW1saW5rKGxuaywgcGF0aCkpCgkJCQlyZXQgPSBlcnIobywgXygiZmFpbGVkIHRvIHN5bWxpbmsgJyVzJzogJXMiKSwKCQkJCQlwYXRoLCBzdHJlcnJvcihlcnJubykpOwoJCQlmcmVlKGxuayk7CgkJfSBlbHNlCgkJCXJldCA9IGVycihvLAoJCQkJICBfKCJkbyBub3Qga25vdyB3aGF0IHRvIGRvIHdpdGggJTA2byAlcyAnJXMnIiksCgkJCQkgIG1vZGUsIG9pZF90b19oZXgob2lkKSwgcGF0aCk7CiBmcmVlX2J1ZjoKCQlmcmVlKGJ1Zik7Cgl9CiB1cGRhdGVfaW5kZXg6CglpZiAoIXJldCAmJiB1cGRhdGVfY2FjaGUpCgkJYWRkX2NhY2hlaW5mbyhvLCBtb2RlLCBvaWQsIHBhdGgsIDAsIHVwZGF0ZV93ZCwgQUREX0NBQ0hFX09LX1RPX0FERCk7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IHVwZGF0ZV9maWxlKHN0cnVjdCBtZXJnZV9vcHRpb25zICpvLAoJCSAgICAgICBpbnQgY2xlYW4sCgkJICAgICAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkgICAgICAgdW5zaWduZWQgbW9kZSwKCQkgICAgICAgY29uc3QgY2hhciAqcGF0aCkKewoJcmV0dXJuIHVwZGF0ZV9maWxlX2ZsYWdzKG8sIG9pZCwgbW9kZSwgcGF0aCwgby0+Y2FsbF9kZXB0aCB8fCBjbGVhbiwgIW8tPmNhbGxfZGVwdGgpOwp9CgovKiBMb3cgbGV2ZWwgZmlsZSBtZXJnaW5nLCB1cGRhdGUgYW5kIHJlbW92YWwgKi8KCnN0cnVjdCBtZXJnZV9maWxlX2luZm8gewoJc3RydWN0IG9iamVjdF9pZCBvaWQ7Cgl1bnNpZ25lZCBtb2RlOwoJdW5zaWduZWQgY2xlYW46MSwKCQkgbWVyZ2U6MTsKfTsKCnN0YXRpYyBpbnQgbWVyZ2VfM3dheShzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyAqbywKCQkgICAgICBtbWJ1ZmZlcl90ICpyZXN1bHRfYnVmLAoJCSAgICAgIGNvbnN0IHN0cnVjdCBkaWZmX2ZpbGVzcGVjICpvbmUsCgkJICAgICAgY29uc3Qgc3RydWN0IGRpZmZfZmlsZXNwZWMgKmEsCgkJICAgICAgY29uc3Qgc3RydWN0IGRpZmZfZmlsZXNwZWMgKmIsCgkJICAgICAgY29uc3QgY2hhciAqYnJhbmNoMSwKCQkgICAgICBjb25zdCBjaGFyICpicmFuY2gyKQp7CgltbWZpbGVfdCBvcmlnLCBzcmMxLCBzcmMyOwoJc3RydWN0IGxsX21lcmdlX29wdGlvbnMgbGxfb3B0cyA9IHswfTsKCWNoYXIgKmJhc2VfbmFtZSwgKm5hbWUxLCAqbmFtZTI7CglpbnQgbWVyZ2Vfc3RhdHVzOwoKCWxsX29wdHMucmVub3JtYWxpemUgPSBvLT5yZW5vcm1hbGl6ZTsKCWxsX29wdHMueGRsX29wdHMgPSBvLT54ZGxfb3B0czsKCglpZiAoby0+Y2FsbF9kZXB0aCkgewoJCWxsX29wdHMudmlydHVhbF9hbmNlc3RvciA9IDE7CgkJbGxfb3B0cy52YXJpYW50ID0gMDsKCX0gZWxzZSB7CgkJc3dpdGNoIChvLT5yZWN1cnNpdmVfdmFyaWFudCkgewoJCWNhc2UgTUVSR0VfUkVDVVJTSVZFX09VUlM6CgkJCWxsX29wdHMudmFyaWFudCA9IFhETF9NRVJHRV9GQVZPUl9PVVJTOwoJCQlicmVhazsKCQljYXNlIE1FUkdFX1JFQ1VSU0lWRV9USEVJUlM6CgkJCWxsX29wdHMudmFyaWFudCA9IFhETF9NRVJHRV9GQVZPUl9USEVJUlM7CgkJCWJyZWFrOwoJCWRlZmF1bHQ6CgkJCWxsX29wdHMudmFyaWFudCA9IDA7CgkJCWJyZWFrOwoJCX0KCX0KCglpZiAoc3RyY21wKGEtPnBhdGgsIGItPnBhdGgpIHx8CgkgICAgKG8tPmFuY2VzdG9yICE9IE5VTEwgJiYgc3RyY21wKGEtPnBhdGgsIG9uZS0+cGF0aCkgIT0gMCkpIHsKCQliYXNlX25hbWUgPSBvLT5hbmNlc3RvciA9PSBOVUxMID8gTlVMTCA6CgkJCW1rcGF0aGR1cCgiJXM6JXMiLCBvLT5hbmNlc3Rvciwgb25lLT5wYXRoKTsKCQluYW1lMSA9IG1rcGF0aGR1cCgiJXM6JXMiLCBicmFuY2gxLCBhLT5wYXRoKTsKCQluYW1lMiA9IG1rcGF0aGR1cCgiJXM6JXMiLCBicmFuY2gyLCBiLT5wYXRoKTsKCX0gZWxzZSB7CgkJYmFzZV9uYW1lID0gby0+YW5jZXN0b3IgPT0gTlVMTCA/IE5VTEwgOgoJCQlta3BhdGhkdXAoIiVzIiwgby0+YW5jZXN0b3IpOwoJCW5hbWUxID0gbWtwYXRoZHVwKCIlcyIsIGJyYW5jaDEpOwoJCW5hbWUyID0gbWtwYXRoZHVwKCIlcyIsIGJyYW5jaDIpOwoJfQoKCXJlYWRfbW1ibG9iKCZvcmlnLCAmb25lLT5vaWQpOwoJcmVhZF9tbWJsb2IoJnNyYzEsICZhLT5vaWQpOwoJcmVhZF9tbWJsb2IoJnNyYzIsICZiLT5vaWQpOwoKCW1lcmdlX3N0YXR1cyA9IGxsX21lcmdlKHJlc3VsdF9idWYsIGEtPnBhdGgsICZvcmlnLCBiYXNlX25hbWUsCgkJCQkmc3JjMSwgbmFtZTEsICZzcmMyLCBuYW1lMiwgJmxsX29wdHMpOwoKCWZyZWUoYmFzZV9uYW1lKTsKCWZyZWUobmFtZTEpOwoJZnJlZShuYW1lMik7CglmcmVlKG9yaWcucHRyKTsKCWZyZWUoc3JjMS5wdHIpOwoJZnJlZShzcmMyLnB0cik7CglyZXR1cm4gbWVyZ2Vfc3RhdHVzOwp9CgpzdGF0aWMgaW50IG1lcmdlX2ZpbGVfMShzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyAqbywKCQkJCQkgICBjb25zdCBzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqb25lLAoJCQkJCSAgIGNvbnN0IHN0cnVjdCBkaWZmX2ZpbGVzcGVjICphLAoJCQkJCSAgIGNvbnN0IHN0cnVjdCBkaWZmX2ZpbGVzcGVjICpiLAoJCQkJCSAgIGNvbnN0IGNoYXIgKmJyYW5jaDEsCgkJCQkJICAgY29uc3QgY2hhciAqYnJhbmNoMiwKCQkJCQkgICBzdHJ1Y3QgbWVyZ2VfZmlsZV9pbmZvICpyZXN1bHQpCnsKCXJlc3VsdC0+bWVyZ2UgPSAwOwoJcmVzdWx0LT5jbGVhbiA9IDE7CgoJaWYgKChTX0lGTVQgJiBhLT5tb2RlKSAhPSAoU19JRk1UICYgYi0+bW9kZSkpIHsKCQlyZXN1bHQtPmNsZWFuID0gMDsKCQlpZiAoU19JU1JFRyhhLT5tb2RlKSkgewoJCQlyZXN1bHQtPm1vZGUgPSBhLT5tb2RlOwoJCQlvaWRjcHkoJnJlc3VsdC0+b2lkLCAmYS0+b2lkKTsKCQl9IGVsc2UgewoJCQlyZXN1bHQtPm1vZGUgPSBiLT5tb2RlOwoJCQlvaWRjcHkoJnJlc3VsdC0+b2lkLCAmYi0+b2lkKTsKCQl9Cgl9IGVsc2UgewoJCWlmICghb2lkX2VxKCZhLT5vaWQsICZvbmUtPm9pZCkgJiYgIW9pZF9lcSgmYi0+b2lkLCAmb25lLT5vaWQpKQoJCQlyZXN1bHQtPm1lcmdlID0gMTsKCgkJLyoKCQkgKiBNZXJnZSBtb2RlcwoJCSAqLwoJCWlmIChhLT5tb2RlID09IGItPm1vZGUgfHwgYS0+bW9kZSA9PSBvbmUtPm1vZGUpCgkJCXJlc3VsdC0+bW9kZSA9IGItPm1vZGU7CgkJZWxzZSB7CgkJCXJlc3VsdC0+bW9kZSA9IGEtPm1vZGU7CgkJCWlmIChiLT5tb2RlICE9IG9uZS0+bW9kZSkgewoJCQkJcmVzdWx0LT5jbGVhbiA9IDA7CgkJCQlyZXN1bHQtPm1lcmdlID0gMTsKCQkJfQoJCX0KCgkJaWYgKG9pZF9lcSgmYS0+b2lkLCAmYi0+b2lkKSB8fCBvaWRfZXEoJmEtPm9pZCwgJm9uZS0+b2lkKSkKCQkJb2lkY3B5KCZyZXN1bHQtPm9pZCwgJmItPm9pZCk7CgkJZWxzZSBpZiAob2lkX2VxKCZiLT5vaWQsICZvbmUtPm9pZCkpCgkJCW9pZGNweSgmcmVzdWx0LT5vaWQsICZhLT5vaWQpOwoJCWVsc2UgaWYgKFNfSVNSRUcoYS0+bW9kZSkpIHsKCQkJbW1idWZmZXJfdCByZXN1bHRfYnVmOwoJCQlpbnQgcmV0ID0gMCwgbWVyZ2Vfc3RhdHVzOwoKCQkJbWVyZ2Vfc3RhdHVzID0gbWVyZ2VfM3dheShvLCAmcmVzdWx0X2J1Ziwgb25lLCBhLCBiLAoJCQkJCQkgIGJyYW5jaDEsIGJyYW5jaDIpOwoKCQkJaWYgKChtZXJnZV9zdGF0dXMgPCAwKSB8fCAhcmVzdWx0X2J1Zi5wdHIpCgkJCQlyZXQgPSBlcnIobywgXygiRmFpbGVkIHRvIGV4ZWN1dGUgaW50ZXJuYWwgbWVyZ2UiKSk7CgoJCQlpZiAoIXJldCAmJiB3cml0ZV9zaGExX2ZpbGUocmVzdWx0X2J1Zi5wdHIsIHJlc3VsdF9idWYuc2l6ZSwKCQkJCQkJICAgIGJsb2JfdHlwZSwgcmVzdWx0LT5vaWQuaGFzaCkpCgkJCQlyZXQgPSBlcnIobywgXygiVW5hYmxlIHRvIGFkZCAlcyB0byBkYXRhYmFzZSIpLAoJCQkJCSAgYS0+cGF0aCk7CgoJCQlmcmVlKHJlc3VsdF9idWYucHRyKTsKCQkJaWYgKHJldCkKCQkJCXJldHVybiByZXQ7CgkJCXJlc3VsdC0+Y2xlYW4gPSAobWVyZ2Vfc3RhdHVzID09IDApOwoJCX0gZWxzZSBpZiAoU19JU0dJVExJTksoYS0+bW9kZSkpIHsKCQkJcmVzdWx0LT5jbGVhbiA9IG1lcmdlX3N1Ym1vZHVsZShyZXN1bHQtPm9pZC5oYXNoLAoJCQkJCQkgICAgICAgb25lLT5wYXRoLAoJCQkJCQkgICAgICAgb25lLT5vaWQuaGFzaCwKCQkJCQkJICAgICAgIGEtPm9pZC5oYXNoLAoJCQkJCQkgICAgICAgYi0+b2lkLmhhc2gsCgkJCQkJCSAgICAgICAhby0+Y2FsbF9kZXB0aCk7CgkJfSBlbHNlIGlmIChTX0lTTE5LKGEtPm1vZGUpKSB7CgkJCW9pZGNweSgmcmVzdWx0LT5vaWQsICZhLT5vaWQpOwoKCQkJaWYgKCFvaWRfZXEoJmEtPm9pZCwgJmItPm9pZCkpCgkJCQlyZXN1bHQtPmNsZWFuID0gMDsKCQl9IGVsc2UKCQkJZGllKCJCVUc6IHVuc3VwcG9ydGVkIG9iamVjdCB0eXBlIGluIHRoZSB0cmVlIik7Cgl9CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgbWVyZ2VfZmlsZV9zcGVjaWFsX21hcmtlcnMoc3RydWN0IG1lcmdlX29wdGlvbnMgKm8sCgkJCSAgIGNvbnN0IHN0cnVjdCBkaWZmX2ZpbGVzcGVjICpvbmUsCgkJCSAgIGNvbnN0IHN0cnVjdCBkaWZmX2ZpbGVzcGVjICphLAoJCQkgICBjb25zdCBzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqYiwKCQkJICAgY29uc3QgY2hhciAqYnJhbmNoMSwKCQkJICAgY29uc3QgY2hhciAqZmlsZW5hbWUxLAoJCQkgICBjb25zdCBjaGFyICpicmFuY2gyLAoJCQkgICBjb25zdCBjaGFyICpmaWxlbmFtZTIsCgkJCSAgIHN0cnVjdCBtZXJnZV9maWxlX2luZm8gKm1maSkKewoJY2hhciAqc2lkZTEgPSBOVUxMOwoJY2hhciAqc2lkZTIgPSBOVUxMOwoJaW50IHJldDsKCglpZiAoZmlsZW5hbWUxKQoJCXNpZGUxID0geHN0cmZtdCgiJXM6JXMiLCBicmFuY2gxLCBmaWxlbmFtZTEpOwoJaWYgKGZpbGVuYW1lMikKCQlzaWRlMiA9IHhzdHJmbXQoIiVzOiVzIiwgYnJhbmNoMiwgZmlsZW5hbWUyKTsKCglyZXQgPSBtZXJnZV9maWxlXzEobywgb25lLCBhLCBiLAoJCQkgICBzaWRlMSA/IHNpZGUxIDogYnJhbmNoMSwKCQkJICAgc2lkZTIgPyBzaWRlMiA6IGJyYW5jaDIsIG1maSk7CglmcmVlKHNpZGUxKTsKCWZyZWUoc2lkZTIpOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIGludCBtZXJnZV9maWxlX29uZShzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyAqbywKCQkJCQkgY29uc3QgY2hhciAqcGF0aCwKCQkJCQkgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb19vaWQsIGludCBvX21vZGUsCgkJCQkJIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKmFfb2lkLCBpbnQgYV9tb2RlLAoJCQkJCSBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpiX29pZCwgaW50IGJfbW9kZSwKCQkJCQkgY29uc3QgY2hhciAqYnJhbmNoMSwKCQkJCQkgY29uc3QgY2hhciAqYnJhbmNoMiwKCQkJCQkgc3RydWN0IG1lcmdlX2ZpbGVfaW5mbyAqbWZpKQp7CglzdHJ1Y3QgZGlmZl9maWxlc3BlYyBvbmUsIGEsIGI7CgoJb25lLnBhdGggPSBhLnBhdGggPSBiLnBhdGggPSAoY2hhciAqKXBhdGg7CglvaWRjcHkoJm9uZS5vaWQsIG9fb2lkKTsKCW9uZS5tb2RlID0gb19tb2RlOwoJb2lkY3B5KCZhLm9pZCwgYV9vaWQpOwoJYS5tb2RlID0gYV9tb2RlOwoJb2lkY3B5KCZiLm9pZCwgYl9vaWQpOwoJYi5tb2RlID0gYl9tb2RlOwoJcmV0dXJuIG1lcmdlX2ZpbGVfMShvLCAmb25lLCAmYSwgJmIsIGJyYW5jaDEsIGJyYW5jaDIsIG1maSk7Cn0KCnN0YXRpYyBpbnQgaGFuZGxlX2NoYW5nZV9kZWxldGUoc3RydWN0IG1lcmdlX29wdGlvbnMgKm8sCgkJCQkgY29uc3QgY2hhciAqcGF0aCwgY29uc3QgY2hhciAqb2xkX3BhdGgsCgkJCQkgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb19vaWQsIGludCBvX21vZGUsCgkJCQkgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqY2hhbmdlZF9vaWQsCgkJCQkgaW50IGNoYW5nZWRfbW9kZSwKCQkJCSBjb25zdCBjaGFyICpjaGFuZ2VfYnJhbmNoLAoJCQkJIGNvbnN0IGNoYXIgKmRlbGV0ZV9icmFuY2gsCgkJCQkgY29uc3QgY2hhciAqY2hhbmdlLCBjb25zdCBjaGFyICpjaGFuZ2VfcGFzdCkKewoJY2hhciAqYWx0X3BhdGggPSBOVUxMOwoJY29uc3QgY2hhciAqdXBkYXRlX3BhdGggPSBwYXRoOwoJaW50IHJldCA9IDA7CgoJaWYgKGRpcl9pbl93YXkocGF0aCwgIW8tPmNhbGxfZGVwdGgsIDApKSB7CgkJdXBkYXRlX3BhdGggPSBhbHRfcGF0aCA9IHVuaXF1ZV9wYXRoKG8sIHBhdGgsIGNoYW5nZV9icmFuY2gpOwoJfQoKCWlmIChvLT5jYWxsX2RlcHRoKSB7CgkJLyoKCQkgKiBXZSBjYW5ub3QgYXJiaXRyYXJpbHkgYWNjZXB0IGVpdGhlciBhX3NoYSBvciBiX3NoYSBhcwoJCSAqIGNvcnJlY3Q7IHNpbmNlIHRoZXJlIGlzIG5vIHRydWUgIm1pZGRsZSBwb2ludCIgYmV0d2VlbgoJCSAqIHRoZW0sIHNpbXBseSByZXVzZSB0aGUgYmFzZSB2ZXJzaW9uIGZvciB2aXJ0dWFsIG1lcmdlIGJhc2UuCgkJICovCgkJcmV0ID0gcmVtb3ZlX2ZpbGVfZnJvbV9jYWNoZShwYXRoKTsKCQlpZiAoIXJldCkKCQkJcmV0ID0gdXBkYXRlX2ZpbGUobywgMCwgb19vaWQsIG9fbW9kZSwgdXBkYXRlX3BhdGgpOwoJfSBlbHNlIHsKCQlpZiAoIWFsdF9wYXRoKSB7CgkJCWlmICghb2xkX3BhdGgpIHsKCQkJCW91dHB1dChvLCAxLCBfKCJDT05GTElDVCAoJXMvZGVsZXRlKTogJXMgZGVsZXRlZCBpbiAlcyAiCgkJCQkgICAgICAgImFuZCAlcyBpbiAlcy4gVmVyc2lvbiAlcyBvZiAlcyBsZWZ0IGluIHRyZWUuIiksCgkJCQkgICAgICAgY2hhbmdlLCBwYXRoLCBkZWxldGVfYnJhbmNoLCBjaGFuZ2VfcGFzdCwKCQkJCSAgICAgICBjaGFuZ2VfYnJhbmNoLCBjaGFuZ2VfYnJhbmNoLCBwYXRoKTsKCQkJfSBlbHNlIHsKCQkJCW91dHB1dChvLCAxLCBfKCJDT05GTElDVCAoJXMvZGVsZXRlKTogJXMgZGVsZXRlZCBpbiAlcyAiCgkJCQkgICAgICAgImFuZCAlcyB0byAlcyBpbiAlcy4gVmVyc2lvbiAlcyBvZiAlcyBsZWZ0IGluIHRyZWUuIiksCgkJCQkgICAgICAgY2hhbmdlLCBvbGRfcGF0aCwgZGVsZXRlX2JyYW5jaCwgY2hhbmdlX3Bhc3QsIHBhdGgsCgkJCQkgICAgICAgY2hhbmdlX2JyYW5jaCwgY2hhbmdlX2JyYW5jaCwgcGF0aCk7CgkJCX0KCQl9IGVsc2UgewoJCQlpZiAoIW9sZF9wYXRoKSB7CgkJCQlvdXRwdXQobywgMSwgXygiQ09ORkxJQ1QgKCVzL2RlbGV0ZSk6ICVzIGRlbGV0ZWQgaW4gJXMgIgoJCQkJICAgICAgICJhbmQgJXMgaW4gJXMuIFZlcnNpb24gJXMgb2YgJXMgbGVmdCBpbiB0cmVlIGF0ICVzLiIpLAoJCQkJICAgICAgIGNoYW5nZSwgcGF0aCwgZGVsZXRlX2JyYW5jaCwgY2hhbmdlX3Bhc3QsCgkJCQkgICAgICAgY2hhbmdlX2JyYW5jaCwgY2hhbmdlX2JyYW5jaCwgcGF0aCwgYWx0X3BhdGgpOwoJCQl9IGVsc2UgewoJCQkJb3V0cHV0KG8sIDEsIF8oIkNPTkZMSUNUICglcy9kZWxldGUpOiAlcyBkZWxldGVkIGluICVzICIKCQkJCSAgICAgICAiYW5kICVzIHRvICVzIGluICVzLiBWZXJzaW9uICVzIG9mICVzIGxlZnQgaW4gdHJlZSBhdCAlcy4iKSwKCQkJCSAgICAgICBjaGFuZ2UsIG9sZF9wYXRoLCBkZWxldGVfYnJhbmNoLCBjaGFuZ2VfcGFzdCwgcGF0aCwKCQkJCSAgICAgICBjaGFuZ2VfYnJhbmNoLCBjaGFuZ2VfYnJhbmNoLCBwYXRoLCBhbHRfcGF0aCk7CgkJCX0KCQl9CgkJLyoKCQkgKiBObyBuZWVkIHRvIGNhbGwgdXBkYXRlX2ZpbGUoKSBvbiBwYXRoIHdoZW4gY2hhbmdlX2JyYW5jaCA9PQoJCSAqIG8tPmJyYW5jaDEgJiYgIWFsdF9wYXRoLCBzaW5jZSB0aGF0IHdvdWxkIG5lZWRsZXNzbHkgdG91Y2gKCQkgKiBwYXRoLiAgV2UgY291bGQgY2FsbCB1cGRhdGVfZmlsZV9mbGFncygpIHdpdGggdXBkYXRlX2NhY2hlPTAKCQkgKiBhbmQgdXBkYXRlX3dkPTAsIGJ1dCB0aGF0J3MgYSBuby1vcC4KCQkgKi8KCQlpZiAoY2hhbmdlX2JyYW5jaCAhPSBvLT5icmFuY2gxIHx8IGFsdF9wYXRoKQoJCQlyZXQgPSB1cGRhdGVfZmlsZShvLCAwLCBjaGFuZ2VkX29pZCwgY2hhbmdlZF9tb2RlLCB1cGRhdGVfcGF0aCk7Cgl9CglmcmVlKGFsdF9wYXRoKTsKCglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IGNvbmZsaWN0X3JlbmFtZV9kZWxldGUoc3RydWN0IG1lcmdlX29wdGlvbnMgKm8sCgkJCQkgICBzdHJ1Y3QgZGlmZl9maWxlcGFpciAqcGFpciwKCQkJCSAgIGNvbnN0IGNoYXIgKnJlbmFtZV9icmFuY2gsCgkJCQkgICBjb25zdCBjaGFyICpkZWxldGVfYnJhbmNoKQp7Cgljb25zdCBzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqb3JpZyA9IHBhaXItPm9uZTsKCWNvbnN0IHN0cnVjdCBkaWZmX2ZpbGVzcGVjICpkZXN0ID0gcGFpci0+dHdvOwoKCWlmIChoYW5kbGVfY2hhbmdlX2RlbGV0ZShvLAoJCQkJIG8tPmNhbGxfZGVwdGggPyBvcmlnLT5wYXRoIDogZGVzdC0+cGF0aCwKCQkJCSBvLT5jYWxsX2RlcHRoID8gTlVMTCA6IG9yaWctPnBhdGgsCgkJCQkgJm9yaWctPm9pZCwgb3JpZy0+bW9kZSwKCQkJCSAmZGVzdC0+b2lkLCBkZXN0LT5tb2RlLAoJCQkJIHJlbmFtZV9icmFuY2gsIGRlbGV0ZV9icmFuY2gsCgkJCQkgXygicmVuYW1lIiksIF8oInJlbmFtZWQiKSkpCgkJcmV0dXJuIC0xOwoKCWlmIChvLT5jYWxsX2RlcHRoKQoJCXJldHVybiByZW1vdmVfZmlsZV9mcm9tX2NhY2hlKGRlc3QtPnBhdGgpOwoJZWxzZQoJCXJldHVybiB1cGRhdGVfc3RhZ2VzKG8sIGRlc3QtPnBhdGgsIE5VTEwsCgkJCQkgICAgIHJlbmFtZV9icmFuY2ggPT0gby0+YnJhbmNoMSA/IGRlc3QgOiBOVUxMLAoJCQkJICAgICByZW5hbWVfYnJhbmNoID09IG8tPmJyYW5jaDEgPyBOVUxMIDogZGVzdCk7Cn0KCnN0YXRpYyBzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqZmlsZXNwZWNfZnJvbV9lbnRyeShzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqdGFyZ2V0LAoJCQkJCQkgc3RydWN0IHN0YWdlX2RhdGEgKmVudHJ5LAoJCQkJCQkgaW50IHN0YWdlKQp7CglzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQgPSAmZW50cnktPnN0YWdlc1tzdGFnZV0ub2lkOwoJdW5zaWduZWQgbW9kZSA9IGVudHJ5LT5zdGFnZXNbc3RhZ2VdLm1vZGU7CglpZiAobW9kZSA9PSAwIHx8IGlzX251bGxfb2lkKG9pZCkpCgkJcmV0dXJuIE5VTEw7CglvaWRjcHkoJnRhcmdldC0+b2lkLCBvaWQpOwoJdGFyZ2V0LT5tb2RlID0gbW9kZTsKCXJldHVybiB0YXJnZXQ7Cn0KCnN0YXRpYyBpbnQgaGFuZGxlX2ZpbGUoc3RydWN0IG1lcmdlX29wdGlvbnMgKm8sCgkJCXN0cnVjdCBkaWZmX2ZpbGVzcGVjICpyZW5hbWUsCgkJCWludCBzdGFnZSwKCQkJc3RydWN0IHJlbmFtZV9jb25mbGljdF9pbmZvICpjaSkKewoJY2hhciAqZHN0X25hbWUgPSByZW5hbWUtPnBhdGg7CglzdHJ1Y3Qgc3RhZ2VfZGF0YSAqZHN0X2VudHJ5OwoJY29uc3QgY2hhciAqY3VyX2JyYW5jaCwgKm90aGVyX2JyYW5jaDsKCXN0cnVjdCBkaWZmX2ZpbGVzcGVjIG90aGVyOwoJc3RydWN0IGRpZmZfZmlsZXNwZWMgKmFkZDsKCWludCByZXQ7CgoJaWYgKHN0YWdlID09IDIpIHsKCQlkc3RfZW50cnkgPSBjaS0+ZHN0X2VudHJ5MTsKCQljdXJfYnJhbmNoID0gY2ktPmJyYW5jaDE7CgkJb3RoZXJfYnJhbmNoID0gY2ktPmJyYW5jaDI7Cgl9IGVsc2UgewoJCWRzdF9lbnRyeSA9IGNpLT5kc3RfZW50cnkyOwoJCWN1cl9icmFuY2ggPSBjaS0+YnJhbmNoMjsKCQlvdGhlcl9icmFuY2ggPSBjaS0+YnJhbmNoMTsKCX0KCglhZGQgPSBmaWxlc3BlY19mcm9tX2VudHJ5KCZvdGhlciwgZHN0X2VudHJ5LCBzdGFnZSBeIDEpOwoJaWYgKGFkZCkgewoJCWNoYXIgKmFkZF9uYW1lID0gdW5pcXVlX3BhdGgobywgcmVuYW1lLT5wYXRoLCBvdGhlcl9icmFuY2gpOwoJCWlmICh1cGRhdGVfZmlsZShvLCAwLCAmYWRkLT5vaWQsIGFkZC0+bW9kZSwgYWRkX25hbWUpKQoJCQlyZXR1cm4gLTE7CgoJCXJlbW92ZV9maWxlKG8sIDAsIHJlbmFtZS0+cGF0aCwgMCk7CgkJZHN0X25hbWUgPSB1bmlxdWVfcGF0aChvLCByZW5hbWUtPnBhdGgsIGN1cl9icmFuY2gpOwoJfSBlbHNlIHsKCQlpZiAoZGlyX2luX3dheShyZW5hbWUtPnBhdGgsICFvLT5jYWxsX2RlcHRoLCAwKSkgewoJCQlkc3RfbmFtZSA9IHVuaXF1ZV9wYXRoKG8sIHJlbmFtZS0+cGF0aCwgY3VyX2JyYW5jaCk7CgkJCW91dHB1dChvLCAxLCBfKCIlcyBpcyBhIGRpcmVjdG9yeSBpbiAlcyBhZGRpbmcgYXMgJXMgaW5zdGVhZCIpLAoJCQkgICAgICAgcmVuYW1lLT5wYXRoLCBvdGhlcl9icmFuY2gsIGRzdF9uYW1lKTsKCQl9Cgl9CglpZiAoKHJldCA9IHVwZGF0ZV9maWxlKG8sIDAsICZyZW5hbWUtPm9pZCwgcmVuYW1lLT5tb2RlLCBkc3RfbmFtZSkpKQoJCTsgLyogZmFsbCB0aHJvdWdoLCBkbyBhbGxvdyBkc3RfbmFtZSB0byBiZSByZWxlYXNlZCAqLwoJZWxzZSBpZiAoc3RhZ2UgPT0gMikKCQlyZXQgPSB1cGRhdGVfc3RhZ2VzKG8sIHJlbmFtZS0+cGF0aCwgTlVMTCwgcmVuYW1lLCBhZGQpOwoJZWxzZQoJCXJldCA9IHVwZGF0ZV9zdGFnZXMobywgcmVuYW1lLT5wYXRoLCBOVUxMLCBhZGQsIHJlbmFtZSk7CgoJaWYgKGRzdF9uYW1lICE9IHJlbmFtZS0+cGF0aCkKCQlmcmVlKGRzdF9uYW1lKTsKCglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IGNvbmZsaWN0X3JlbmFtZV9yZW5hbWVfMXRvMihzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyAqbywKCQkJCQlzdHJ1Y3QgcmVuYW1lX2NvbmZsaWN0X2luZm8gKmNpKQp7CgkvKiBPbmUgZmlsZSB3YXMgcmVuYW1lZCBpbiBib3RoIGJyYW5jaGVzLCBidXQgdG8gZGlmZmVyZW50IG5hbWVzLiAqLwoJc3RydWN0IGRpZmZfZmlsZXNwZWMgKm9uZSA9IGNpLT5wYWlyMS0+b25lOwoJc3RydWN0IGRpZmZfZmlsZXNwZWMgKmEgPSBjaS0+cGFpcjEtPnR3bzsKCXN0cnVjdCBkaWZmX2ZpbGVzcGVjICpiID0gY2ktPnBhaXIyLT50d287CgoJb3V0cHV0KG8sIDEsIF8oIkNPTkZMSUNUIChyZW5hbWUvcmVuYW1lKTogIgoJICAgICAgICJSZW5hbWUgXCIlc1wiLT5cIiVzXCIgaW4gYnJhbmNoIFwiJXNcIiAiCgkgICAgICAgInJlbmFtZSBcIiVzXCItPlwiJXNcIiBpbiBcIiVzXCIlcyIpLAoJICAgICAgIG9uZS0+cGF0aCwgYS0+cGF0aCwgY2ktPmJyYW5jaDEsCgkgICAgICAgb25lLT5wYXRoLCBiLT5wYXRoLCBjaS0+YnJhbmNoMiwKCSAgICAgICBvLT5jYWxsX2RlcHRoID8gXygiIChsZWZ0IHVucmVzb2x2ZWQpIikgOiAiIik7CglpZiAoby0+Y2FsbF9kZXB0aCkgewoJCXN0cnVjdCBtZXJnZV9maWxlX2luZm8gbWZpOwoJCXN0cnVjdCBkaWZmX2ZpbGVzcGVjIG90aGVyOwoJCXN0cnVjdCBkaWZmX2ZpbGVzcGVjICphZGQ7CgkJaWYgKG1lcmdlX2ZpbGVfb25lKG8sIG9uZS0+cGF0aCwKCQkJCSAmb25lLT5vaWQsIG9uZS0+bW9kZSwKCQkJCSAmYS0+b2lkLCBhLT5tb2RlLAoJCQkJICZiLT5vaWQsIGItPm1vZGUsCgkJCQkgY2ktPmJyYW5jaDEsIGNpLT5icmFuY2gyLCAmbWZpKSkKCQkJcmV0dXJuIC0xOwoKCQkvKgoJCSAqIEZJWE1FOiBGb3IgcmVuYW1lL2FkZC1zb3VyY2UgY29uZmxpY3RzIChpZiB3ZSBjb3VsZCBkZXRlY3QKCQkgKiBzdWNoKSwgdGhpcyBpcyB3cm9uZy4gIFdlIHNob3VsZCBpbnN0ZWFkIGZpbmQgYSB1bmlxdWUKCQkgKiBwYXRobmFtZSBhbmQgdGhlbiBlaXRoZXIgcmVuYW1lIHRoZSBhZGQtc291cmNlIGZpbGUgdG8gdGhhdAoJCSAqIHVuaXF1ZSBwYXRoLCBvciB1c2UgdGhhdCB1bmlxdWUgcGF0aCBpbnN0ZWFkIG9mIHNyYyBoZXJlLgoJCSAqLwoJCWlmICh1cGRhdGVfZmlsZShvLCAwLCAmbWZpLm9pZCwgbWZpLm1vZGUsIG9uZS0+cGF0aCkpCgkJCXJldHVybiAtMTsKCgkJLyoKCQkgKiBBYm92ZSwgd2UgcHV0IHRoZSBtZXJnZWQgY29udGVudCBhdCB0aGUgbWVyZ2UtYmFzZSdzCgkJICogcGF0aC4gIE5vdyB3ZSB1c3VhbGx5IG5lZWQgdG8gZGVsZXRlIGJvdGggYS0+cGF0aCBhbmQKCQkgKiBiLT5wYXRoLiAgSG93ZXZlciwgdGhlIHJlbmFtZSBvbiBlYWNoIHNpZGUgb2YgdGhlIG1lcmdlCgkJICogY291bGQgYWxzbyBiZSBpbnZvbHZlZCBpbiBhIHJlbmFtZS9hZGQgY29uZmxpY3QuICBJbgoJCSAqIHN1Y2ggY2FzZXMsIHdlIHNob3VsZCBrZWVwIHRoZSBhZGRlZCBmaWxlIGFyb3VuZCwKCQkgKiByZXNvbHZpbmcgdGhlIGNvbmZsaWN0IGF0IHRoYXQgcGF0aCBpbiBpdHMgZmF2b3IuCgkJICovCgkJYWRkID0gZmlsZXNwZWNfZnJvbV9lbnRyeSgmb3RoZXIsIGNpLT5kc3RfZW50cnkxLCAyIF4gMSk7CgkJaWYgKGFkZCkgewoJCQlpZiAodXBkYXRlX2ZpbGUobywgMCwgJmFkZC0+b2lkLCBhZGQtPm1vZGUsIGEtPnBhdGgpKQoJCQkJcmV0dXJuIC0xOwoJCX0KCQllbHNlCgkJCXJlbW92ZV9maWxlX2Zyb21fY2FjaGUoYS0+cGF0aCk7CgkJYWRkID0gZmlsZXNwZWNfZnJvbV9lbnRyeSgmb3RoZXIsIGNpLT5kc3RfZW50cnkyLCAzIF4gMSk7CgkJaWYgKGFkZCkgewoJCQlpZiAodXBkYXRlX2ZpbGUobywgMCwgJmFkZC0+b2lkLCBhZGQtPm1vZGUsIGItPnBhdGgpKQoJCQkJcmV0dXJuIC0xOwoJCX0KCQllbHNlCgkJCXJlbW92ZV9maWxlX2Zyb21fY2FjaGUoYi0+cGF0aCk7Cgl9IGVsc2UgaWYgKGhhbmRsZV9maWxlKG8sIGEsIDIsIGNpKSB8fCBoYW5kbGVfZmlsZShvLCBiLCAzLCBjaSkpCgkJcmV0dXJuIC0xOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGNvbmZsaWN0X3JlbmFtZV9yZW5hbWVfMnRvMShzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyAqbywKCQkJCQlzdHJ1Y3QgcmVuYW1lX2NvbmZsaWN0X2luZm8gKmNpKQp7CgkvKiBUd28gZmlsZXMsIGEgJiBiLCB3ZXJlIHJlbmFtZWQgdG8gdGhlIHNhbWUgdGhpbmcsIGMuICovCglzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqYSA9IGNpLT5wYWlyMS0+b25lOwoJc3RydWN0IGRpZmZfZmlsZXNwZWMgKmIgPSBjaS0+cGFpcjItPm9uZTsKCXN0cnVjdCBkaWZmX2ZpbGVzcGVjICpjMSA9IGNpLT5wYWlyMS0+dHdvOwoJc3RydWN0IGRpZmZfZmlsZXNwZWMgKmMyID0gY2ktPnBhaXIyLT50d287CgljaGFyICpwYXRoID0gYzEtPnBhdGg7IC8qID09IGMyLT5wYXRoICovCglzdHJ1Y3QgbWVyZ2VfZmlsZV9pbmZvIG1maV9jMTsKCXN0cnVjdCBtZXJnZV9maWxlX2luZm8gbWZpX2MyOwoJaW50IHJldDsKCglvdXRwdXQobywgMSwgXygiQ09ORkxJQ1QgKHJlbmFtZS9yZW5hbWUpOiAiCgkgICAgICAgIlJlbmFtZSAlcy0+JXMgaW4gJXMuICIKCSAgICAgICAiUmVuYW1lICVzLT4lcyBpbiAlcyIpLAoJICAgICAgIGEtPnBhdGgsIGMxLT5wYXRoLCBjaS0+YnJhbmNoMSwKCSAgICAgICBiLT5wYXRoLCBjMi0+cGF0aCwgY2ktPmJyYW5jaDIpOwoKCXJlbW92ZV9maWxlKG8sIDEsIGEtPnBhdGgsIG8tPmNhbGxfZGVwdGggfHwgd291bGRfbG9zZV91bnRyYWNrZWQoYS0+cGF0aCkpOwoJcmVtb3ZlX2ZpbGUobywgMSwgYi0+cGF0aCwgby0+Y2FsbF9kZXB0aCB8fCB3b3VsZF9sb3NlX3VudHJhY2tlZChiLT5wYXRoKSk7CgoJaWYgKG1lcmdlX2ZpbGVfc3BlY2lhbF9tYXJrZXJzKG8sIGEsIGMxLCAmY2ktPnJlbjFfb3RoZXIsCgkJCQkgICAgICAgby0+YnJhbmNoMSwgYzEtPnBhdGgsCgkJCQkgICAgICAgby0+YnJhbmNoMiwgY2ktPnJlbjFfb3RoZXIucGF0aCwgJm1maV9jMSkgfHwKCSAgICBtZXJnZV9maWxlX3NwZWNpYWxfbWFya2VycyhvLCBiLCAmY2ktPnJlbjJfb3RoZXIsIGMyLAoJCQkJICAgICAgIG8tPmJyYW5jaDEsIGNpLT5yZW4yX290aGVyLnBhdGgsCgkJCQkgICAgICAgby0+YnJhbmNoMiwgYzItPnBhdGgsICZtZmlfYzIpKQoJCXJldHVybiAtMTsKCglpZiAoby0+Y2FsbF9kZXB0aCkgewoJCS8qCgkJICogSWYgbWZpX2MxLmNsZWFuICYmIG1maV9jMi5jbGVhbiwgdGhlbiBpdCBtaWdodCBtYWtlCgkJICogc2Vuc2UgdG8gZG8gYSB0d28td2F5IG1lcmdlIG9mIHRob3NlIHJlc3VsdHMuICBCdXQsIEkKCQkgKiB0aGluayBpbiBhbGwgY2FzZXMsIGl0IG1ha2VzIHNlbnNlIHRvIGhhdmUgdGhlIHZpcnR1YWwKCQkgKiBtZXJnZSBiYXNlIGp1c3QgdW5kbyB0aGUgcmVuYW1lczsgdGhleSBjYW4gYmUgZGV0ZWN0ZWQKCQkgKiBhZ2FpbiBsYXRlciBmb3IgdGhlIG5vbi1yZWN1cnNpdmUgbWVyZ2UuCgkJICovCgkJcmVtb3ZlX2ZpbGUobywgMCwgcGF0aCwgMCk7CgkJcmV0ID0gdXBkYXRlX2ZpbGUobywgMCwgJm1maV9jMS5vaWQsIG1maV9jMS5tb2RlLCBhLT5wYXRoKTsKCQlpZiAoIXJldCkKCQkJcmV0ID0gdXBkYXRlX2ZpbGUobywgMCwgJm1maV9jMi5vaWQsIG1maV9jMi5tb2RlLAoJCQkJCSAgYi0+cGF0aCk7Cgl9IGVsc2UgewoJCWNoYXIgKm5ld19wYXRoMSA9IHVuaXF1ZV9wYXRoKG8sIHBhdGgsIGNpLT5icmFuY2gxKTsKCQljaGFyICpuZXdfcGF0aDIgPSB1bmlxdWVfcGF0aChvLCBwYXRoLCBjaS0+YnJhbmNoMik7CgkJb3V0cHV0KG8sIDEsIF8oIlJlbmFtaW5nICVzIHRvICVzIGFuZCAlcyB0byAlcyBpbnN0ZWFkIiksCgkJICAgICAgIGEtPnBhdGgsIG5ld19wYXRoMSwgYi0+cGF0aCwgbmV3X3BhdGgyKTsKCQlyZW1vdmVfZmlsZShvLCAwLCBwYXRoLCAwKTsKCQlyZXQgPSB1cGRhdGVfZmlsZShvLCAwLCAmbWZpX2MxLm9pZCwgbWZpX2MxLm1vZGUsIG5ld19wYXRoMSk7CgkJaWYgKCFyZXQpCgkJCXJldCA9IHVwZGF0ZV9maWxlKG8sIDAsICZtZmlfYzIub2lkLCBtZmlfYzIubW9kZSwKCQkJCQkgIG5ld19wYXRoMik7CgkJZnJlZShuZXdfcGF0aDIpOwoJCWZyZWUobmV3X3BhdGgxKTsKCX0KCglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IHByb2Nlc3NfcmVuYW1lcyhzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyAqbywKCQkJICAgc3RydWN0IHN0cmluZ19saXN0ICphX3JlbmFtZXMsCgkJCSAgIHN0cnVjdCBzdHJpbmdfbGlzdCAqYl9yZW5hbWVzKQp7CglpbnQgY2xlYW5fbWVyZ2UgPSAxLCBpLCBqOwoJc3RydWN0IHN0cmluZ19saXN0IGFfYnlfZHN0ID0gU1RSSU5HX0xJU1RfSU5JVF9OT0RVUDsKCXN0cnVjdCBzdHJpbmdfbGlzdCBiX2J5X2RzdCA9IFNUUklOR19MSVNUX0lOSVRfTk9EVVA7Cgljb25zdCBzdHJ1Y3QgcmVuYW1lICpzcmU7CgoJZm9yIChpID0gMDsgaSA8IGFfcmVuYW1lcy0+bnI7IGkrKykgewoJCXNyZSA9IGFfcmVuYW1lcy0+aXRlbXNbaV0udXRpbDsKCQlzdHJpbmdfbGlzdF9pbnNlcnQoJmFfYnlfZHN0LCBzcmUtPnBhaXItPnR3by0+cGF0aCktPnV0aWwKCQkJPSAodm9pZCAqKXNyZTsKCX0KCWZvciAoaSA9IDA7IGkgPCBiX3JlbmFtZXMtPm5yOyBpKyspIHsKCQlzcmUgPSBiX3JlbmFtZXMtPml0ZW1zW2ldLnV0aWw7CgkJc3RyaW5nX2xpc3RfaW5zZXJ0KCZiX2J5X2RzdCwgc3JlLT5wYWlyLT50d28tPnBhdGgpLT51dGlsCgkJCT0gKHZvaWQgKilzcmU7Cgl9CgoJZm9yIChpID0gMCwgaiA9IDA7IGkgPCBhX3JlbmFtZXMtPm5yIHx8IGogPCBiX3JlbmFtZXMtPm5yOykgewoJCXN0cnVjdCBzdHJpbmdfbGlzdCAqcmVuYW1lczEsICpyZW5hbWVzMkRzdDsKCQlzdHJ1Y3QgcmVuYW1lICpyZW4xID0gTlVMTCwgKnJlbjIgPSBOVUxMOwoJCWNvbnN0IGNoYXIgKmJyYW5jaDEsICpicmFuY2gyOwoJCWNvbnN0IGNoYXIgKnJlbjFfc3JjLCAqcmVuMV9kc3Q7CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKmxvb2t1cDsKCgkJaWYgKGkgPj0gYV9yZW5hbWVzLT5ucikgewoJCQlyZW4yID0gYl9yZW5hbWVzLT5pdGVtc1tqKytdLnV0aWw7CgkJfSBlbHNlIGlmIChqID49IGJfcmVuYW1lcy0+bnIpIHsKCQkJcmVuMSA9IGFfcmVuYW1lcy0+aXRlbXNbaSsrXS51dGlsOwoJCX0gZWxzZSB7CgkJCWludCBjb21wYXJlID0gc3RyY21wKGFfcmVuYW1lcy0+aXRlbXNbaV0uc3RyaW5nLAoJCQkJCSAgICAgYl9yZW5hbWVzLT5pdGVtc1tqXS5zdHJpbmcpOwoJCQlpZiAoY29tcGFyZSA8PSAwKQoJCQkJcmVuMSA9IGFfcmVuYW1lcy0+aXRlbXNbaSsrXS51dGlsOwoJCQlpZiAoY29tcGFyZSA+PSAwKQoJCQkJcmVuMiA9IGJfcmVuYW1lcy0+aXRlbXNbaisrXS51dGlsOwoJCX0KCgkJLyogVE9ETzogcmVmYWN0b3IsIHNvIHRoYXQgMS8yIGFyZSBub3QgbmVlZGVkICovCgkJaWYgKHJlbjEpIHsKCQkJcmVuYW1lczEgPSBhX3JlbmFtZXM7CgkJCXJlbmFtZXMyRHN0ID0gJmJfYnlfZHN0OwoJCQlicmFuY2gxID0gby0+YnJhbmNoMTsKCQkJYnJhbmNoMiA9IG8tPmJyYW5jaDI7CgkJfSBlbHNlIHsKCQkJcmVuYW1lczEgPSBiX3JlbmFtZXM7CgkJCXJlbmFtZXMyRHN0ID0gJmFfYnlfZHN0OwoJCQlicmFuY2gxID0gby0+YnJhbmNoMjsKCQkJYnJhbmNoMiA9IG8tPmJyYW5jaDE7CgkJCVNXQVAocmVuMiwgcmVuMSk7CgkJfQoKCQlpZiAocmVuMS0+cHJvY2Vzc2VkKQoJCQljb250aW51ZTsKCQlyZW4xLT5wcm9jZXNzZWQgPSAxOwoJCXJlbjEtPmRzdF9lbnRyeS0+cHJvY2Vzc2VkID0gMTsKCQkvKiBCVUc6IFdlIHNob3VsZCBvbmx5IG1hcmsgc3JjX2VudHJ5IGFzIHByb2Nlc3NlZCBpZiB3ZQoJCSAqIGFyZSBub3QgZGVhbGluZyB3aXRoIGEgcmVuYW1lICsgYWRkLXNvdXJjZSBjYXNlLgoJCSAqLwoJCXJlbjEtPnNyY19lbnRyeS0+cHJvY2Vzc2VkID0gMTsKCgkJcmVuMV9zcmMgPSByZW4xLT5wYWlyLT5vbmUtPnBhdGg7CgkJcmVuMV9kc3QgPSByZW4xLT5wYWlyLT50d28tPnBhdGg7CgoJCWlmIChyZW4yKSB7CgkJCS8qIE9uZSBmaWxlIHJlbmFtZWQgb24gYm90aCBzaWRlcyAqLwoJCQljb25zdCBjaGFyICpyZW4yX3NyYyA9IHJlbjItPnBhaXItPm9uZS0+cGF0aDsKCQkJY29uc3QgY2hhciAqcmVuMl9kc3QgPSByZW4yLT5wYWlyLT50d28tPnBhdGg7CgkJCWVudW0gcmVuYW1lX3R5cGUgcmVuYW1lX3R5cGU7CgkJCWlmIChzdHJjbXAocmVuMV9zcmMsIHJlbjJfc3JjKSAhPSAwKQoJCQkJZGllKCJCVUc6IHJlbjFfc3JjICE9IHJlbjJfc3JjIik7CgkJCXJlbjItPmRzdF9lbnRyeS0+cHJvY2Vzc2VkID0gMTsKCQkJcmVuMi0+cHJvY2Vzc2VkID0gMTsKCQkJaWYgKHN0cmNtcChyZW4xX2RzdCwgcmVuMl9kc3QpICE9IDApIHsKCQkJCXJlbmFtZV90eXBlID0gUkVOQU1FX09ORV9GSUxFX1RPX1RXTzsKCQkJCWNsZWFuX21lcmdlID0gMDsKCQkJfSBlbHNlIHsKCQkJCXJlbmFtZV90eXBlID0gUkVOQU1FX09ORV9GSUxFX1RPX09ORTsKCQkJCS8qIEJVRzogV2Ugc2hvdWxkIG9ubHkgcmVtb3ZlIHJlbjFfc3JjIGluCgkJCQkgKiB0aGUgYmFzZSBzdGFnZSAodGhpbmsgb2YgcmVuYW1lICsKCQkJCSAqIGFkZC1zb3VyY2UgY2FzZXMpLgoJCQkJICovCgkJCQlyZW1vdmVfZmlsZShvLCAxLCByZW4xX3NyYywgMSk7CgkJCQl1cGRhdGVfZW50cnkocmVuMS0+ZHN0X2VudHJ5LAoJCQkJCSAgICAgcmVuMS0+cGFpci0+b25lLAoJCQkJCSAgICAgcmVuMS0+cGFpci0+dHdvLAoJCQkJCSAgICAgcmVuMi0+cGFpci0+dHdvKTsKCQkJfQoJCQlzZXR1cF9yZW5hbWVfY29uZmxpY3RfaW5mbyhyZW5hbWVfdHlwZSwKCQkJCQkJICAgcmVuMS0+cGFpciwKCQkJCQkJICAgcmVuMi0+cGFpciwKCQkJCQkJICAgYnJhbmNoMSwKCQkJCQkJICAgYnJhbmNoMiwKCQkJCQkJICAgcmVuMS0+ZHN0X2VudHJ5LAoJCQkJCQkgICByZW4yLT5kc3RfZW50cnksCgkJCQkJCSAgIG8sCgkJCQkJCSAgIE5VTEwsCgkJCQkJCSAgIE5VTEwpOwoJCX0gZWxzZSBpZiAoKGxvb2t1cCA9IHN0cmluZ19saXN0X2xvb2t1cChyZW5hbWVzMkRzdCwgcmVuMV9kc3QpKSkgewoJCQkvKiBUd28gZGlmZmVyZW50IGZpbGVzIHJlbmFtZWQgdG8gdGhlIHNhbWUgdGhpbmcgKi8KCQkJY2hhciAqcmVuMl9kc3Q7CgkJCXJlbjIgPSBsb29rdXAtPnV0aWw7CgkJCXJlbjJfZHN0ID0gcmVuMi0+cGFpci0+dHdvLT5wYXRoOwoJCQlpZiAoc3RyY21wKHJlbjFfZHN0LCByZW4yX2RzdCkgIT0gMCkKCQkJCWRpZSgiQlVHOiByZW4xX2RzdCAhPSByZW4yX2RzdCIpOwoKCQkJY2xlYW5fbWVyZ2UgPSAwOwoJCQlyZW4yLT5wcm9jZXNzZWQgPSAxOwoJCQkvKgoJCQkgKiBCVUc6IFdlIHNob3VsZCBvbmx5IG1hcmsgc3JjX2VudHJ5IGFzIHByb2Nlc3NlZAoJCQkgKiBpZiB3ZSBhcmUgbm90IGRlYWxpbmcgd2l0aCBhIHJlbmFtZSArIGFkZC1zb3VyY2UKCQkJICogY2FzZS4KCQkJICovCgkJCXJlbjItPnNyY19lbnRyeS0+cHJvY2Vzc2VkID0gMTsKCgkJCXNldHVwX3JlbmFtZV9jb25mbGljdF9pbmZvKFJFTkFNRV9UV09fRklMRVNfVE9fT05FLAoJCQkJCQkgICByZW4xLT5wYWlyLAoJCQkJCQkgICByZW4yLT5wYWlyLAoJCQkJCQkgICBicmFuY2gxLAoJCQkJCQkgICBicmFuY2gyLAoJCQkJCQkgICByZW4xLT5kc3RfZW50cnksCgkJCQkJCSAgIHJlbjItPmRzdF9lbnRyeSwKCQkJCQkJICAgbywKCQkJCQkJICAgcmVuMS0+c3JjX2VudHJ5LAoJCQkJCQkgICByZW4yLT5zcmNfZW50cnkpOwoKCQl9IGVsc2UgewoJCQkvKiBSZW5hbWVkIGluIDEsIG1heWJlIGNoYW5nZWQgaW4gMiAqLwoJCQkvKiB3ZSBvbmx5IHVzZSBzaGExIGFuZCBtb2RlIG9mIHRoZXNlICovCgkJCXN0cnVjdCBkaWZmX2ZpbGVzcGVjIHNyY19vdGhlciwgZHN0X290aGVyOwoJCQlpbnQgdHJ5X21lcmdlOwoKCQkJLyoKCQkJICogdW5wYWNrX3RyZWVzIGxvYWRzIGVudHJpZXMgZnJvbSBjb21tb24tY29tbWl0CgkJCSAqIGludG8gc3RhZ2UgMSwgZnJvbSBoZWFkLWNvbW1pdCBpbnRvIHN0YWdlIDIsIGFuZAoJCQkgKiBmcm9tIG1lcmdlLWNvbW1pdCBpbnRvIHN0YWdlIDMuICBXZSBrZWVwIHRyYWNrCgkJCSAqIG9mIHdoaWNoIHNpZGUgY29ycmVzcG9uZHMgdG8gdGhlIHJlbmFtZS4KCQkJICovCgkJCWludCByZW5hbWVkX3N0YWdlID0gYV9yZW5hbWVzID09IHJlbmFtZXMxID8gMiA6IDM7CgkJCWludCBvdGhlcl9zdGFnZSA9ICAgYV9yZW5hbWVzID09IHJlbmFtZXMxID8gMyA6IDI7CgoJCQkvKiBCVUc6IFdlIHNob3VsZCBvbmx5IHJlbW92ZSByZW4xX3NyYyBpbiB0aGUgYmFzZQoJCQkgKiBzdGFnZSBhbmQgaW4gb3RoZXJfc3RhZ2UgKHRoaW5rIG9mIHJlbmFtZSArCgkJCSAqIGFkZC1zb3VyY2UgY2FzZSkuCgkJCSAqLwoJCQlyZW1vdmVfZmlsZShvLCAxLCByZW4xX3NyYywKCQkJCSAgICByZW5hbWVkX3N0YWdlID09IDIgfHwgIXdhc190cmFja2VkKHJlbjFfc3JjKSk7CgoJCQlvaWRjcHkoJnNyY19vdGhlci5vaWQsCgkJCSAgICAgICAmcmVuMS0+c3JjX2VudHJ5LT5zdGFnZXNbb3RoZXJfc3RhZ2VdLm9pZCk7CgkJCXNyY19vdGhlci5tb2RlID0gcmVuMS0+c3JjX2VudHJ5LT5zdGFnZXNbb3RoZXJfc3RhZ2VdLm1vZGU7CgkJCW9pZGNweSgmZHN0X290aGVyLm9pZCwKCQkJICAgICAgICZyZW4xLT5kc3RfZW50cnktPnN0YWdlc1tvdGhlcl9zdGFnZV0ub2lkKTsKCQkJZHN0X290aGVyLm1vZGUgPSByZW4xLT5kc3RfZW50cnktPnN0YWdlc1tvdGhlcl9zdGFnZV0ubW9kZTsKCQkJdHJ5X21lcmdlID0gMDsKCgkJCWlmIChvaWRfZXEoJnNyY19vdGhlci5vaWQsICZudWxsX29pZCkpIHsKCQkJCXNldHVwX3JlbmFtZV9jb25mbGljdF9pbmZvKFJFTkFNRV9ERUxFVEUsCgkJCQkJCQkgICByZW4xLT5wYWlyLAoJCQkJCQkJICAgTlVMTCwKCQkJCQkJCSAgIGJyYW5jaDEsCgkJCQkJCQkgICBicmFuY2gyLAoJCQkJCQkJICAgcmVuMS0+ZHN0X2VudHJ5LAoJCQkJCQkJICAgTlVMTCwKCQkJCQkJCSAgIG8sCgkJCQkJCQkgICBOVUxMLAoJCQkJCQkJICAgTlVMTCk7CgkJCX0gZWxzZSBpZiAoKGRzdF9vdGhlci5tb2RlID09IHJlbjEtPnBhaXItPnR3by0+bW9kZSkgJiYKCQkJCSAgIG9pZF9lcSgmZHN0X290aGVyLm9pZCwgJnJlbjEtPnBhaXItPnR3by0+b2lkKSkgewoJCQkJLyoKCQkJCSAqIEFkZGVkIGZpbGUgb24gdGhlIG90aGVyIHNpZGUgaWRlbnRpY2FsIHRvCgkJCQkgKiB0aGUgZmlsZSBiZWluZyByZW5hbWVkOiBjbGVhbiBtZXJnZS4KCQkJCSAqIEFsc28sIHRoZXJlIGlzIG5vIG5lZWQgdG8gb3ZlcndyaXRlIHRoZQoJCQkJICogZmlsZSBhbHJlYWR5IGluIHRoZSB3b3JraW5nIGNvcHksIHNvIGNhbGwKCQkJCSAqIHVwZGF0ZV9maWxlX2ZsYWdzKCkgaW5zdGVhZCBvZgoJCQkJICogdXBkYXRlX2ZpbGUoKS4KCQkJCSAqLwoJCQkJaWYgKHVwZGF0ZV9maWxlX2ZsYWdzKG8sCgkJCQkJCSAgICAgICZyZW4xLT5wYWlyLT50d28tPm9pZCwKCQkJCQkJICAgICAgcmVuMS0+cGFpci0+dHdvLT5tb2RlLAoJCQkJCQkgICAgICByZW4xX2RzdCwKCQkJCQkJICAgICAgMSwgLyogdXBkYXRlX2NhY2hlICovCgkJCQkJCSAgICAgIDAgIC8qIHVwZGF0ZV93ZCAgICAqLykpCgkJCQkJY2xlYW5fbWVyZ2UgPSAtMTsKCQkJfSBlbHNlIGlmICghb2lkX2VxKCZkc3Rfb3RoZXIub2lkLCAmbnVsbF9vaWQpKSB7CgkJCQljbGVhbl9tZXJnZSA9IDA7CgkJCQl0cnlfbWVyZ2UgPSAxOwoJCQkJb3V0cHV0KG8sIDEsIF8oIkNPTkZMSUNUIChyZW5hbWUvYWRkKTogUmVuYW1lICVzLT4lcyBpbiAlcy4gIgoJCQkJICAgICAgICIlcyBhZGRlZCBpbiAlcyIpLAoJCQkJICAgICAgIHJlbjFfc3JjLCByZW4xX2RzdCwgYnJhbmNoMSwKCQkJCSAgICAgICByZW4xX2RzdCwgYnJhbmNoMik7CgkJCQlpZiAoby0+Y2FsbF9kZXB0aCkgewoJCQkJCXN0cnVjdCBtZXJnZV9maWxlX2luZm8gbWZpOwoJCQkJCWlmIChtZXJnZV9maWxlX29uZShvLCByZW4xX2RzdCwgJm51bGxfb2lkLCAwLAoJCQkJCQkJICAgJnJlbjEtPnBhaXItPnR3by0+b2lkLAoJCQkJCQkJICAgcmVuMS0+cGFpci0+dHdvLT5tb2RlLAoJCQkJCQkJICAgJmRzdF9vdGhlci5vaWQsCgkJCQkJCQkgICBkc3Rfb3RoZXIubW9kZSwKCQkJCQkJCSAgIGJyYW5jaDEsIGJyYW5jaDIsICZtZmkpKSB7CgkJCQkJCWNsZWFuX21lcmdlID0gLTE7CgkJCQkJCWdvdG8gY2xlYW51cF9hbmRfcmV0dXJuOwoJCQkJCX0KCQkJCQlvdXRwdXQobywgMSwgXygiQWRkaW5nIG1lcmdlZCAlcyIpLCByZW4xX2RzdCk7CgkJCQkJaWYgKHVwZGF0ZV9maWxlKG8sIDAsICZtZmkub2lkLAoJCQkJCQkJbWZpLm1vZGUsIHJlbjFfZHN0KSkKCQkJCQkJY2xlYW5fbWVyZ2UgPSAtMTsKCQkJCQl0cnlfbWVyZ2UgPSAwOwoJCQkJfSBlbHNlIHsKCQkJCQljaGFyICpuZXdfcGF0aCA9IHVuaXF1ZV9wYXRoKG8sIHJlbjFfZHN0LCBicmFuY2gyKTsKCQkJCQlvdXRwdXQobywgMSwgXygiQWRkaW5nIGFzICVzIGluc3RlYWQiKSwgbmV3X3BhdGgpOwoJCQkJCWlmICh1cGRhdGVfZmlsZShvLCAwLCAmZHN0X290aGVyLm9pZCwKCQkJCQkJCWRzdF9vdGhlci5tb2RlLCBuZXdfcGF0aCkpCgkJCQkJCWNsZWFuX21lcmdlID0gLTE7CgkJCQkJZnJlZShuZXdfcGF0aCk7CgkJCQl9CgkJCX0gZWxzZQoJCQkJdHJ5X21lcmdlID0gMTsKCgkJCWlmIChjbGVhbl9tZXJnZSA8IDApCgkJCQlnb3RvIGNsZWFudXBfYW5kX3JldHVybjsKCQkJaWYgKHRyeV9tZXJnZSkgewoJCQkJc3RydWN0IGRpZmZfZmlsZXNwZWMgKm9uZSwgKmEsICpiOwoJCQkJc3JjX290aGVyLnBhdGggPSAoY2hhciAqKXJlbjFfc3JjOwoKCQkJCW9uZSA9IHJlbjEtPnBhaXItPm9uZTsKCQkJCWlmIChhX3JlbmFtZXMgPT0gcmVuYW1lczEpIHsKCQkJCQlhID0gcmVuMS0+cGFpci0+dHdvOwoJCQkJCWIgPSAmc3JjX290aGVyOwoJCQkJfSBlbHNlIHsKCQkJCQliID0gcmVuMS0+cGFpci0+dHdvOwoJCQkJCWEgPSAmc3JjX290aGVyOwoJCQkJfQoJCQkJdXBkYXRlX2VudHJ5KHJlbjEtPmRzdF9lbnRyeSwgb25lLCBhLCBiKTsKCQkJCXNldHVwX3JlbmFtZV9jb25mbGljdF9pbmZvKFJFTkFNRV9OT1JNQUwsCgkJCQkJCQkgICByZW4xLT5wYWlyLAoJCQkJCQkJICAgTlVMTCwKCQkJCQkJCSAgIGJyYW5jaDEsCgkJCQkJCQkgICBOVUxMLAoJCQkJCQkJICAgcmVuMS0+ZHN0X2VudHJ5LAoJCQkJCQkJICAgTlVMTCwKCQkJCQkJCSAgIG8sCgkJCQkJCQkgICBOVUxMLAoJCQkJCQkJICAgTlVMTCk7CgkJCX0KCQl9Cgl9CmNsZWFudXBfYW5kX3JldHVybjoKCXN0cmluZ19saXN0X2NsZWFyKCZhX2J5X2RzdCwgMCk7CglzdHJpbmdfbGlzdF9jbGVhcigmYl9ieV9kc3QsIDApOwoKCXJldHVybiBjbGVhbl9tZXJnZTsKfQoKc3RhdGljIHN0cnVjdCBvYmplY3RfaWQgKnN0YWdlX29pZChjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIHVuc2lnbmVkIG1vZGUpCnsKCXJldHVybiAoaXNfbnVsbF9vaWQob2lkKSB8fCBtb2RlID09IDApID8gTlVMTDogKHN0cnVjdCBvYmplY3RfaWQgKilvaWQ7Cn0KCnN0YXRpYyBpbnQgcmVhZF9vaWRfc3RyYnVmKHN0cnVjdCBtZXJnZV9vcHRpb25zICpvLAoJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBzdHJ1Y3Qgc3RyYnVmICpkc3QpCnsKCXZvaWQgKmJ1ZjsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCWJ1ZiA9IHJlYWRfc2hhMV9maWxlKG9pZC0+aGFzaCwgJnR5cGUsICZzaXplKTsKCWlmICghYnVmKQoJCXJldHVybiBlcnIobywgXygiY2Fubm90IHJlYWQgb2JqZWN0ICVzIiksIG9pZF90b19oZXgob2lkKSk7CglpZiAodHlwZSAhPSBPQkpfQkxPQikgewoJCWZyZWUoYnVmKTsKCQlyZXR1cm4gZXJyKG8sIF8oIm9iamVjdCAlcyBpcyBub3QgYSBibG9iIiksIG9pZF90b19oZXgob2lkKSk7Cgl9CglzdHJidWZfYXR0YWNoKGRzdCwgYnVmLCBzaXplLCBzaXplICsgMSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBibG9iX3VuY2hhbmdlZChzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyAqb3B0LAoJCQkgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9fb2lkLAoJCQkgIHVuc2lnbmVkIG9fbW9kZSwKCQkJICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICphX29pZCwKCQkJICB1bnNpZ25lZCBhX21vZGUsCgkJCSAgaW50IHJlbm9ybWFsaXplLCBjb25zdCBjaGFyICpwYXRoKQp7CglzdHJ1Y3Qgc3RyYnVmIG8gPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgYSA9IFNUUkJVRl9JTklUOwoJaW50IHJldCA9IDA7IC8qIGFzc3VtZSBjaGFuZ2VkIGZvciBzYWZldHkgKi8KCglpZiAoYV9tb2RlICE9IG9fbW9kZSkKCQlyZXR1cm4gMDsKCWlmIChvaWRfZXEob19vaWQsIGFfb2lkKSkKCQlyZXR1cm4gMTsKCWlmICghcmVub3JtYWxpemUpCgkJcmV0dXJuIDA7CgoJYXNzZXJ0KG9fb2lkICYmIGFfb2lkKTsKCWlmIChyZWFkX29pZF9zdHJidWYob3B0LCBvX29pZCwgJm8pIHx8IHJlYWRfb2lkX3N0cmJ1ZihvcHQsIGFfb2lkLCAmYSkpCgkJZ290byBlcnJvcl9yZXR1cm47CgkvKgoJICogTm90ZTogYmluYXJ5IHwgaXMgdXNlZCBzbyB0aGF0IGJvdGggcmVub3JtYWxpemF0aW9ucyBhcmUKCSAqIHBlcmZvcm1lZC4gIENvbXBhcmlzb24gY2FuIGJlIHNraXBwZWQgaWYgYm90aCBmaWxlcyBhcmUKCSAqIHVuY2hhbmdlZCBzaW5jZSB0aGVpciBzaGExcyBoYXZlIGFscmVhZHkgYmVlbiBjb21wYXJlZC4KCSAqLwoJaWYgKHJlbm9ybWFsaXplX2J1ZmZlcihwYXRoLCBvLmJ1Ziwgby5sZW4sICZvKSB8CgkgICAgcmVub3JtYWxpemVfYnVmZmVyKHBhdGgsIGEuYnVmLCBhLmxlbiwgJmEpKQoJCXJldCA9IChvLmxlbiA9PSBhLmxlbiAmJiAhbWVtY21wKG8uYnVmLCBhLmJ1Ziwgby5sZW4pKTsKCmVycm9yX3JldHVybjoKCXN0cmJ1Zl9yZWxlYXNlKCZvKTsKCXN0cmJ1Zl9yZWxlYXNlKCZhKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQgaGFuZGxlX21vZGlmeV9kZWxldGUoc3RydWN0IG1lcmdlX29wdGlvbnMgKm8sCgkJCQkgY29uc3QgY2hhciAqcGF0aCwKCQkJCSBzdHJ1Y3Qgb2JqZWN0X2lkICpvX29pZCwgaW50IG9fbW9kZSwKCQkJCSBzdHJ1Y3Qgb2JqZWN0X2lkICphX29pZCwgaW50IGFfbW9kZSwKCQkJCSBzdHJ1Y3Qgb2JqZWN0X2lkICpiX29pZCwgaW50IGJfbW9kZSkKewoJY29uc3QgY2hhciAqbW9kaWZ5X2JyYW5jaCwgKmRlbGV0ZV9icmFuY2g7CglzdHJ1Y3Qgb2JqZWN0X2lkICpjaGFuZ2VkX29pZDsKCWludCBjaGFuZ2VkX21vZGU7CgoJaWYgKGFfb2lkKSB7CgkJbW9kaWZ5X2JyYW5jaCA9IG8tPmJyYW5jaDE7CgkJZGVsZXRlX2JyYW5jaCA9IG8tPmJyYW5jaDI7CgkJY2hhbmdlZF9vaWQgPSBhX29pZDsKCQljaGFuZ2VkX21vZGUgPSBhX21vZGU7Cgl9IGVsc2UgewoJCW1vZGlmeV9icmFuY2ggPSBvLT5icmFuY2gyOwoJCWRlbGV0ZV9icmFuY2ggPSBvLT5icmFuY2gxOwoJCWNoYW5nZWRfb2lkID0gYl9vaWQ7CgkJY2hhbmdlZF9tb2RlID0gYl9tb2RlOwoJfQoKCXJldHVybiBoYW5kbGVfY2hhbmdlX2RlbGV0ZShvLAoJCQkJICAgIHBhdGgsIE5VTEwsCgkJCQkgICAgb19vaWQsIG9fbW9kZSwKCQkJCSAgICBjaGFuZ2VkX29pZCwgY2hhbmdlZF9tb2RlLAoJCQkJICAgIG1vZGlmeV9icmFuY2gsIGRlbGV0ZV9icmFuY2gsCgkJCQkgICAgXygibW9kaWZ5IiksIF8oIm1vZGlmaWVkIikpOwp9CgpzdGF0aWMgaW50IG1lcmdlX2NvbnRlbnQoc3RydWN0IG1lcmdlX29wdGlvbnMgKm8sCgkJCSBjb25zdCBjaGFyICpwYXRoLAoJCQkgc3RydWN0IG9iamVjdF9pZCAqb19vaWQsIGludCBvX21vZGUsCgkJCSBzdHJ1Y3Qgb2JqZWN0X2lkICphX29pZCwgaW50IGFfbW9kZSwKCQkJIHN0cnVjdCBvYmplY3RfaWQgKmJfb2lkLCBpbnQgYl9tb2RlLAoJCQkgc3RydWN0IHJlbmFtZV9jb25mbGljdF9pbmZvICpyZW5hbWVfY29uZmxpY3RfaW5mbykKewoJY29uc3QgY2hhciAqcmVhc29uID0gXygiY29udGVudCIpOwoJY29uc3QgY2hhciAqcGF0aDEgPSBOVUxMLCAqcGF0aDIgPSBOVUxMOwoJc3RydWN0IG1lcmdlX2ZpbGVfaW5mbyBtZmk7CglzdHJ1Y3QgZGlmZl9maWxlc3BlYyBvbmUsIGEsIGI7Cgl1bnNpZ25lZCBkZl9jb25mbGljdF9yZW1haW5zID0gMDsKCglpZiAoIW9fb2lkKSB7CgkJcmVhc29uID0gXygiYWRkL2FkZCIpOwoJCW9fb2lkID0gKHN0cnVjdCBvYmplY3RfaWQgKikmbnVsbF9vaWQ7Cgl9CglvbmUucGF0aCA9IGEucGF0aCA9IGIucGF0aCA9IChjaGFyICopcGF0aDsKCW9pZGNweSgmb25lLm9pZCwgb19vaWQpOwoJb25lLm1vZGUgPSBvX21vZGU7CglvaWRjcHkoJmEub2lkLCBhX29pZCk7CglhLm1vZGUgPSBhX21vZGU7CglvaWRjcHkoJmIub2lkLCBiX29pZCk7CgliLm1vZGUgPSBiX21vZGU7CgoJaWYgKHJlbmFtZV9jb25mbGljdF9pbmZvKSB7CgkJc3RydWN0IGRpZmZfZmlsZXBhaXIgKnBhaXIxID0gcmVuYW1lX2NvbmZsaWN0X2luZm8tPnBhaXIxOwoKCQlwYXRoMSA9IChvLT5icmFuY2gxID09IHJlbmFtZV9jb25mbGljdF9pbmZvLT5icmFuY2gxKSA/CgkJCXBhaXIxLT50d28tPnBhdGggOiBwYWlyMS0+b25lLT5wYXRoOwoJCS8qIElmIHJlbmFtZV9jb25mbGljdF9pbmZvLT5wYWlyMiAhPSBOVUxMLCB3ZSBhcmUgaW4KCQkgKiBSRU5BTUVfT05FX0ZJTEVfVE9fT05FIGNhc2UuICBPdGhlcndpc2UsIHdlIGhhdmUgYQoJCSAqIG5vcm1hbCByZW5hbWUuCgkJICovCgkJcGF0aDIgPSAocmVuYW1lX2NvbmZsaWN0X2luZm8tPnBhaXIyIHx8CgkJCSBvLT5icmFuY2gyID09IHJlbmFtZV9jb25mbGljdF9pbmZvLT5icmFuY2gxKSA/CgkJCXBhaXIxLT50d28tPnBhdGggOiBwYWlyMS0+b25lLT5wYXRoOwoKCQlpZiAoZGlyX2luX3dheShwYXRoLCAhby0+Y2FsbF9kZXB0aCwKCQkJICAgICAgIFNfSVNHSVRMSU5LKHBhaXIxLT50d28tPm1vZGUpKSkKCQkJZGZfY29uZmxpY3RfcmVtYWlucyA9IDE7Cgl9CglpZiAobWVyZ2VfZmlsZV9zcGVjaWFsX21hcmtlcnMobywgJm9uZSwgJmEsICZiLAoJCQkJICAgICAgIG8tPmJyYW5jaDEsIHBhdGgxLAoJCQkJICAgICAgIG8tPmJyYW5jaDIsIHBhdGgyLCAmbWZpKSkKCQlyZXR1cm4gLTE7CgoJaWYgKG1maS5jbGVhbiAmJiAhZGZfY29uZmxpY3RfcmVtYWlucyAmJgoJICAgIG9pZF9lcSgmbWZpLm9pZCwgYV9vaWQpICYmIG1maS5tb2RlID09IGFfbW9kZSkgewoJCWludCBwYXRoX3JlbmFtZWRfb3V0c2lkZV9IRUFEOwoJCW91dHB1dChvLCAzLCBfKCJTa2lwcGVkICVzIChtZXJnZWQgc2FtZSBhcyBleGlzdGluZykiKSwgcGF0aCk7CgkJLyoKCQkgKiBUaGUgY29udGVudCBtZXJnZSByZXN1bHRlZCBpbiB0aGUgc2FtZSBmaWxlIGNvbnRlbnRzIHdlCgkJICogYWxyZWFkeSBoYWQuICBXZSBjYW4gcmV0dXJuIGVhcmx5IGlmIHRob3NlIGZpbGUgY29udGVudHMKCQkgKiBhcmUgcmVjb3JkZWQgYXQgdGhlIGNvcnJlY3QgcGF0aCAod2hpY2ggbWF5IG5vdCBiZSB0cnVlCgkJICogaWYgdGhlIG1lcmdlIGludm9sdmVzIGEgcmVuYW1lKS4KCQkgKi8KCQlwYXRoX3JlbmFtZWRfb3V0c2lkZV9IRUFEID0gIXBhdGgyIHx8ICFzdHJjbXAocGF0aCwgcGF0aDIpOwoJCWlmICghcGF0aF9yZW5hbWVkX291dHNpZGVfSEVBRCkgewoJCQlhZGRfY2FjaGVpbmZvKG8sIG1maS5tb2RlLCAmbWZpLm9pZCwgcGF0aCwKCQkJCSAgICAgIDAsICghby0+Y2FsbF9kZXB0aCksIDApOwoJCQlyZXR1cm4gbWZpLmNsZWFuOwoJCX0KCX0gZWxzZQoJCW91dHB1dChvLCAyLCBfKCJBdXRvLW1lcmdpbmcgJXMiKSwgcGF0aCk7CgoJaWYgKCFtZmkuY2xlYW4pIHsKCQlpZiAoU19JU0dJVExJTksobWZpLm1vZGUpKQoJCQlyZWFzb24gPSBfKCJzdWJtb2R1bGUiKTsKCQlvdXRwdXQobywgMSwgXygiQ09ORkxJQ1QgKCVzKTogTWVyZ2UgY29uZmxpY3QgaW4gJXMiKSwKCQkJCXJlYXNvbiwgcGF0aCk7CgkJaWYgKHJlbmFtZV9jb25mbGljdF9pbmZvICYmICFkZl9jb25mbGljdF9yZW1haW5zKQoJCQlpZiAodXBkYXRlX3N0YWdlcyhvLCBwYXRoLCAmb25lLCAmYSwgJmIpKQoJCQkJcmV0dXJuIC0xOwoJfQoKCWlmIChkZl9jb25mbGljdF9yZW1haW5zKSB7CgkJY2hhciAqbmV3X3BhdGg7CgkJaWYgKG8tPmNhbGxfZGVwdGgpIHsKCQkJcmVtb3ZlX2ZpbGVfZnJvbV9jYWNoZShwYXRoKTsKCQl9IGVsc2UgewoJCQlpZiAoIW1maS5jbGVhbikgewoJCQkJaWYgKHVwZGF0ZV9zdGFnZXMobywgcGF0aCwgJm9uZSwgJmEsICZiKSkKCQkJCQlyZXR1cm4gLTE7CgkJCX0gZWxzZSB7CgkJCQlpbnQgZmlsZV9mcm9tX3N0YWdlMiA9IHdhc190cmFja2VkKHBhdGgpOwoJCQkJc3RydWN0IGRpZmZfZmlsZXNwZWMgbWVyZ2VkOwoJCQkJb2lkY3B5KCZtZXJnZWQub2lkLCAmbWZpLm9pZCk7CgkJCQltZXJnZWQubW9kZSA9IG1maS5tb2RlOwoKCQkJCWlmICh1cGRhdGVfc3RhZ2VzKG8sIHBhdGgsIE5VTEwsCgkJCQkJCSAgZmlsZV9mcm9tX3N0YWdlMiA/ICZtZXJnZWQgOiBOVUxMLAoJCQkJCQkgIGZpbGVfZnJvbV9zdGFnZTIgPyBOVUxMIDogJm1lcmdlZCkpCgkJCQkJcmV0dXJuIC0xOwoJCQl9CgoJCX0KCQluZXdfcGF0aCA9IHVuaXF1ZV9wYXRoKG8sIHBhdGgsIHJlbmFtZV9jb25mbGljdF9pbmZvLT5icmFuY2gxKTsKCQlvdXRwdXQobywgMSwgXygiQWRkaW5nIGFzICVzIGluc3RlYWQiKSwgbmV3X3BhdGgpOwoJCWlmICh1cGRhdGVfZmlsZShvLCAwLCAmbWZpLm9pZCwgbWZpLm1vZGUsIG5ld19wYXRoKSkgewoJCQlmcmVlKG5ld19wYXRoKTsKCQkJcmV0dXJuIC0xOwoJCX0KCQlmcmVlKG5ld19wYXRoKTsKCQltZmkuY2xlYW4gPSAwOwoJfSBlbHNlIGlmICh1cGRhdGVfZmlsZShvLCBtZmkuY2xlYW4sICZtZmkub2lkLCBtZmkubW9kZSwgcGF0aCkpCgkJcmV0dXJuIC0xOwoJcmV0dXJuIG1maS5jbGVhbjsKfQoKLyogUGVyIGVudHJ5IG1lcmdlIGZ1bmN0aW9uICovCnN0YXRpYyBpbnQgcHJvY2Vzc19lbnRyeShzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyAqbywKCQkJIGNvbnN0IGNoYXIgKnBhdGgsIHN0cnVjdCBzdGFnZV9kYXRhICplbnRyeSkKewoJaW50IGNsZWFuX21lcmdlID0gMTsKCWludCBub3JtYWxpemUgPSBvLT5yZW5vcm1hbGl6ZTsKCXVuc2lnbmVkIG9fbW9kZSA9IGVudHJ5LT5zdGFnZXNbMV0ubW9kZTsKCXVuc2lnbmVkIGFfbW9kZSA9IGVudHJ5LT5zdGFnZXNbMl0ubW9kZTsKCXVuc2lnbmVkIGJfbW9kZSA9IGVudHJ5LT5zdGFnZXNbM10ubW9kZTsKCXN0cnVjdCBvYmplY3RfaWQgKm9fb2lkID0gc3RhZ2Vfb2lkKCZlbnRyeS0+c3RhZ2VzWzFdLm9pZCwgb19tb2RlKTsKCXN0cnVjdCBvYmplY3RfaWQgKmFfb2lkID0gc3RhZ2Vfb2lkKCZlbnRyeS0+c3RhZ2VzWzJdLm9pZCwgYV9tb2RlKTsKCXN0cnVjdCBvYmplY3RfaWQgKmJfb2lkID0gc3RhZ2Vfb2lkKCZlbnRyeS0+c3RhZ2VzWzNdLm9pZCwgYl9tb2RlKTsKCgllbnRyeS0+cHJvY2Vzc2VkID0gMTsKCWlmIChlbnRyeS0+cmVuYW1lX2NvbmZsaWN0X2luZm8pIHsKCQlzdHJ1Y3QgcmVuYW1lX2NvbmZsaWN0X2luZm8gKmNvbmZsaWN0X2luZm8gPSBlbnRyeS0+cmVuYW1lX2NvbmZsaWN0X2luZm87CgkJc3dpdGNoIChjb25mbGljdF9pbmZvLT5yZW5hbWVfdHlwZSkgewoJCWNhc2UgUkVOQU1FX05PUk1BTDoKCQljYXNlIFJFTkFNRV9PTkVfRklMRV9UT19PTkU6CgkJCWNsZWFuX21lcmdlID0gbWVyZ2VfY29udGVudChvLCBwYXRoLAoJCQkJCQkgICAgb19vaWQsIG9fbW9kZSwgYV9vaWQsIGFfbW9kZSwgYl9vaWQsIGJfbW9kZSwKCQkJCQkJICAgIGNvbmZsaWN0X2luZm8pOwoJCQlicmVhazsKCQljYXNlIFJFTkFNRV9ERUxFVEU6CgkJCWNsZWFuX21lcmdlID0gMDsKCQkJaWYgKGNvbmZsaWN0X3JlbmFtZV9kZWxldGUobywKCQkJCQkJICAgY29uZmxpY3RfaW5mby0+cGFpcjEsCgkJCQkJCSAgIGNvbmZsaWN0X2luZm8tPmJyYW5jaDEsCgkJCQkJCSAgIGNvbmZsaWN0X2luZm8tPmJyYW5jaDIpKQoJCQkJY2xlYW5fbWVyZ2UgPSAtMTsKCQkJYnJlYWs7CgkJY2FzZSBSRU5BTUVfT05FX0ZJTEVfVE9fVFdPOgoJCQljbGVhbl9tZXJnZSA9IDA7CgkJCWlmIChjb25mbGljdF9yZW5hbWVfcmVuYW1lXzF0bzIobywgY29uZmxpY3RfaW5mbykpCgkJCQljbGVhbl9tZXJnZSA9IC0xOwoJCQlicmVhazsKCQljYXNlIFJFTkFNRV9UV09fRklMRVNfVE9fT05FOgoJCQljbGVhbl9tZXJnZSA9IDA7CgkJCWlmIChjb25mbGljdF9yZW5hbWVfcmVuYW1lXzJ0bzEobywgY29uZmxpY3RfaW5mbykpCgkJCQljbGVhbl9tZXJnZSA9IC0xOwoJCQlicmVhazsKCQlkZWZhdWx0OgoJCQllbnRyeS0+cHJvY2Vzc2VkID0gMDsKCQkJYnJlYWs7CgkJfQoJfSBlbHNlIGlmIChvX29pZCAmJiAoIWFfb2lkIHx8ICFiX29pZCkpIHsKCQkvKiBDYXNlIEE6IERlbGV0ZWQgaW4gb25lICovCgkJaWYgKCghYV9vaWQgJiYgIWJfb2lkKSB8fAoJCSAgICAoIWJfb2lkICYmIGJsb2JfdW5jaGFuZ2VkKG8sIG9fb2lkLCBvX21vZGUsIGFfb2lkLCBhX21vZGUsIG5vcm1hbGl6ZSwgcGF0aCkpIHx8CgkJICAgICghYV9vaWQgJiYgYmxvYl91bmNoYW5nZWQobywgb19vaWQsIG9fbW9kZSwgYl9vaWQsIGJfbW9kZSwgbm9ybWFsaXplLCBwYXRoKSkpIHsKCQkJLyogRGVsZXRlZCBpbiBib3RoIG9yIGRlbGV0ZWQgaW4gb25lIGFuZAoJCQkgKiB1bmNoYW5nZWQgaW4gdGhlIG90aGVyICovCgkJCWlmIChhX29pZCkKCQkJCW91dHB1dChvLCAyLCBfKCJSZW1vdmluZyAlcyIpLCBwYXRoKTsKCQkJLyogZG8gbm90IHRvdWNoIHdvcmtpbmcgZmlsZSBpZiBpdCBkaWQgbm90IGV4aXN0ICovCgkJCXJlbW92ZV9maWxlKG8sIDEsIHBhdGgsICFhX29pZCk7CgkJfSBlbHNlIHsKCQkJLyogTW9kaWZ5L2RlbGV0ZTsgZGVsZXRlZCBzaWRlIG1heSBoYXZlIHB1dCBhIGRpcmVjdG9yeSBpbiB0aGUgd2F5ICovCgkJCWNsZWFuX21lcmdlID0gMDsKCQkJaWYgKGhhbmRsZV9tb2RpZnlfZGVsZXRlKG8sIHBhdGgsIG9fb2lkLCBvX21vZGUsCgkJCQkJCSBhX29pZCwgYV9tb2RlLCBiX29pZCwgYl9tb2RlKSkKCQkJCWNsZWFuX21lcmdlID0gLTE7CgkJfQoJfSBlbHNlIGlmICgoIW9fb2lkICYmIGFfb2lkICYmICFiX29pZCkgfHwKCQkgICAoIW9fb2lkICYmICFhX29pZCAmJiBiX29pZCkpIHsKCQkvKiBDYXNlIEI6IEFkZGVkIGluIG9uZS4gKi8KCQkvKiBbbm90aGluZ3xkaXJlY3RvcnldIC0+IChbbm90aGluZ3xkaXJlY3RvcnldLCBmaWxlKSAqLwoKCQljb25zdCBjaGFyICphZGRfYnJhbmNoOwoJCWNvbnN0IGNoYXIgKm90aGVyX2JyYW5jaDsKCQl1bnNpZ25lZCBtb2RlOwoJCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZDsKCQljb25zdCBjaGFyICpjb25mOwoKCQlpZiAoYV9vaWQpIHsKCQkJYWRkX2JyYW5jaCA9IG8tPmJyYW5jaDE7CgkJCW90aGVyX2JyYW5jaCA9IG8tPmJyYW5jaDI7CgkJCW1vZGUgPSBhX21vZGU7CgkJCW9pZCA9IGFfb2lkOwoJCQljb25mID0gXygiZmlsZS9kaXJlY3RvcnkiKTsKCQl9IGVsc2UgewoJCQlhZGRfYnJhbmNoID0gby0+YnJhbmNoMjsKCQkJb3RoZXJfYnJhbmNoID0gby0+YnJhbmNoMTsKCQkJbW9kZSA9IGJfbW9kZTsKCQkJb2lkID0gYl9vaWQ7CgkJCWNvbmYgPSBfKCJkaXJlY3RvcnkvZmlsZSIpOwoJCX0KCQlpZiAoZGlyX2luX3dheShwYXRoLCAhby0+Y2FsbF9kZXB0aCwKCQkJICAgICAgIFNfSVNHSVRMSU5LKGFfbW9kZSkpKSB7CgkJCWNoYXIgKm5ld19wYXRoID0gdW5pcXVlX3BhdGgobywgcGF0aCwgYWRkX2JyYW5jaCk7CgkJCWNsZWFuX21lcmdlID0gMDsKCQkJb3V0cHV0KG8sIDEsIF8oIkNPTkZMSUNUICglcyk6IFRoZXJlIGlzIGEgZGlyZWN0b3J5IHdpdGggbmFtZSAlcyBpbiAlcy4gIgoJCQkgICAgICAgIkFkZGluZyAlcyBhcyAlcyIpLAoJCQkgICAgICAgY29uZiwgcGF0aCwgb3RoZXJfYnJhbmNoLCBwYXRoLCBuZXdfcGF0aCk7CgkJCWlmICh1cGRhdGVfZmlsZShvLCAwLCBvaWQsIG1vZGUsIG5ld19wYXRoKSkKCQkJCWNsZWFuX21lcmdlID0gLTE7CgkJCWVsc2UgaWYgKG8tPmNhbGxfZGVwdGgpCgkJCQlyZW1vdmVfZmlsZV9mcm9tX2NhY2hlKHBhdGgpOwoJCQlmcmVlKG5ld19wYXRoKTsKCQl9IGVsc2UgewoJCQlvdXRwdXQobywgMiwgXygiQWRkaW5nICVzIiksIHBhdGgpOwoJCQkvKiBkbyBub3Qgb3ZlcndyaXRlIGZpbGUgaWYgYWxyZWFkeSBwcmVzZW50ICovCgkJCWlmICh1cGRhdGVfZmlsZV9mbGFncyhvLCBvaWQsIG1vZGUsIHBhdGgsIDEsICFhX29pZCkpCgkJCQljbGVhbl9tZXJnZSA9IC0xOwoJCX0KCX0gZWxzZSBpZiAoYV9vaWQgJiYgYl9vaWQpIHsKCQkvKiBDYXNlIEM6IEFkZGVkIGluIGJvdGggKGNoZWNrIGZvciBzYW1lIHBlcm1pc3Npb25zKSBhbmQgKi8KCQkvKiBjYXNlIEQ6IE1vZGlmaWVkIGluIGJvdGgsIGJ1dCBkaWZmZXJlbnRseS4gKi8KCQljbGVhbl9tZXJnZSA9IG1lcmdlX2NvbnRlbnQobywgcGF0aCwKCQkJCQkgICAgb19vaWQsIG9fbW9kZSwgYV9vaWQsIGFfbW9kZSwgYl9vaWQsIGJfbW9kZSwKCQkJCQkgICAgTlVMTCk7Cgl9IGVsc2UgaWYgKCFvX29pZCAmJiAhYV9vaWQgJiYgIWJfb2lkKSB7CgkJLyoKCQkgKiB0aGlzIGVudHJ5IHdhcyBkZWxldGVkIGFsdG9nZXRoZXIuIGFfbW9kZSA9PSAwIG1lYW5zCgkJICogd2UgaGFkIHRoYXQgcGF0aCBhbmQgd2FudCB0byBhY3RpdmVseSByZW1vdmUgaXQuCgkJICovCgkJcmVtb3ZlX2ZpbGUobywgMSwgcGF0aCwgIWFfbW9kZSk7Cgl9IGVsc2UKCQlkaWUoIkJVRzogZmF0YWwgbWVyZ2UgZmFpbHVyZSwgc2hvdWxkbid0IGhhcHBlbi4iKTsKCglyZXR1cm4gY2xlYW5fbWVyZ2U7Cn0KCmludCBtZXJnZV90cmVlcyhzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyAqbywKCQlzdHJ1Y3QgdHJlZSAqaGVhZCwKCQlzdHJ1Y3QgdHJlZSAqbWVyZ2UsCgkJc3RydWN0IHRyZWUgKmNvbW1vbiwKCQlzdHJ1Y3QgdHJlZSAqKnJlc3VsdCkKewoJaW50IGNvZGUsIGNsZWFuOwoKCWlmIChvLT5zdWJ0cmVlX3NoaWZ0KSB7CgkJbWVyZ2UgPSBzaGlmdF90cmVlX29iamVjdChoZWFkLCBtZXJnZSwgby0+c3VidHJlZV9zaGlmdCk7CgkJY29tbW9uID0gc2hpZnRfdHJlZV9vYmplY3QoaGVhZCwgY29tbW9uLCBvLT5zdWJ0cmVlX3NoaWZ0KTsKCX0KCglpZiAob2lkX2VxKCZjb21tb24tPm9iamVjdC5vaWQsICZtZXJnZS0+b2JqZWN0Lm9pZCkpIHsKCQlvdXRwdXQobywgMCwgXygiQWxyZWFkeSB1cC10by1kYXRlISIpKTsKCQkqcmVzdWx0ID0gaGVhZDsKCQlyZXR1cm4gMTsKCX0KCgljb2RlID0gZ2l0X21lcmdlX3RyZWVzKG8tPmNhbGxfZGVwdGgsIGNvbW1vbiwgaGVhZCwgbWVyZ2UpOwoKCWlmIChjb2RlICE9IDApIHsKCQlpZiAoc2hvdyhvLCA0KSB8fCBvLT5jYWxsX2RlcHRoKQoJCQllcnIobywgXygibWVyZ2luZyBvZiB0cmVlcyAlcyBhbmQgJXMgZmFpbGVkIiksCgkJCSAgICBvaWRfdG9faGV4KCZoZWFkLT5vYmplY3Qub2lkKSwKCQkJICAgIG9pZF90b19oZXgoJm1lcmdlLT5vYmplY3Qub2lkKSk7CgkJcmV0dXJuIC0xOwoJfQoKCWlmICh1bm1lcmdlZF9jYWNoZSgpKSB7CgkJc3RydWN0IHN0cmluZ19saXN0ICplbnRyaWVzLCAqcmVfaGVhZCwgKnJlX21lcmdlOwoJCWludCBpOwoJCXN0cmluZ19saXN0X2NsZWFyKCZvLT5jdXJyZW50X2ZpbGVfc2V0LCAxKTsKCQlzdHJpbmdfbGlzdF9jbGVhcigmby0+Y3VycmVudF9kaXJlY3Rvcnlfc2V0LCAxKTsKCQlnZXRfZmlsZXNfZGlycyhvLCBoZWFkKTsKCQlnZXRfZmlsZXNfZGlycyhvLCBtZXJnZSk7CgoJCWVudHJpZXMgPSBnZXRfdW5tZXJnZWQoKTsKCQlyZWNvcmRfZGZfY29uZmxpY3RfZmlsZXMobywgZW50cmllcyk7CgkJcmVfaGVhZCAgPSBnZXRfcmVuYW1lcyhvLCBoZWFkLCBjb21tb24sIGhlYWQsIG1lcmdlLCBlbnRyaWVzKTsKCQlyZV9tZXJnZSA9IGdldF9yZW5hbWVzKG8sIG1lcmdlLCBjb21tb24sIGhlYWQsIG1lcmdlLCBlbnRyaWVzKTsKCQljbGVhbiA9IHByb2Nlc3NfcmVuYW1lcyhvLCByZV9oZWFkLCByZV9tZXJnZSk7CgkJaWYgKGNsZWFuIDwgMCkKCQkJcmV0dXJuIGNsZWFuOwoJCWZvciAoaSA9IGVudHJpZXMtPm5yLTE7IDAgPD0gaTsgaS0tKSB7CgkJCWNvbnN0IGNoYXIgKnBhdGggPSBlbnRyaWVzLT5pdGVtc1tpXS5zdHJpbmc7CgkJCXN0cnVjdCBzdGFnZV9kYXRhICplID0gZW50cmllcy0+aXRlbXNbaV0udXRpbDsKCQkJaWYgKCFlLT5wcm9jZXNzZWQpIHsKCQkJCWludCByZXQgPSBwcm9jZXNzX2VudHJ5KG8sIHBhdGgsIGUpOwoJCQkJaWYgKCFyZXQpCgkJCQkJY2xlYW4gPSAwOwoJCQkJZWxzZSBpZiAocmV0IDwgMCkKCQkJCQlyZXR1cm4gcmV0OwoJCQl9CgkJfQoJCWZvciAoaSA9IDA7IGkgPCBlbnRyaWVzLT5ucjsgaSsrKSB7CgkJCXN0cnVjdCBzdGFnZV9kYXRhICplID0gZW50cmllcy0+aXRlbXNbaV0udXRpbDsKCQkJaWYgKCFlLT5wcm9jZXNzZWQpCgkJCQlkaWUoIkJVRzogdW5wcm9jZXNzZWQgcGF0aD8/PyAlcyIsCgkJCQkgICAgZW50cmllcy0+aXRlbXNbaV0uc3RyaW5nKTsKCQl9CgoJCXN0cmluZ19saXN0X2NsZWFyKHJlX21lcmdlLCAwKTsKCQlzdHJpbmdfbGlzdF9jbGVhcihyZV9oZWFkLCAwKTsKCQlzdHJpbmdfbGlzdF9jbGVhcihlbnRyaWVzLCAxKTsKCgkJZnJlZShyZV9tZXJnZSk7CgkJZnJlZShyZV9oZWFkKTsKCQlmcmVlKGVudHJpZXMpOwoJfQoJZWxzZQoJCWNsZWFuID0gMTsKCglpZiAoby0+Y2FsbF9kZXB0aCAmJiAhKCpyZXN1bHQgPSB3cml0ZV90cmVlX2Zyb21fbWVtb3J5KG8pKSkKCQlyZXR1cm4gLTE7CgoJcmV0dXJuIGNsZWFuOwp9CgpzdGF0aWMgc3RydWN0IGNvbW1pdF9saXN0ICpyZXZlcnNlX2NvbW1pdF9saXN0KHN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpuZXh0ID0gTlVMTCwgKmN1cnJlbnQsICpiYWNrdXA7Cglmb3IgKGN1cnJlbnQgPSBsaXN0OyBjdXJyZW50OyBjdXJyZW50ID0gYmFja3VwKSB7CgkJYmFja3VwID0gY3VycmVudC0+bmV4dDsKCQljdXJyZW50LT5uZXh0ID0gbmV4dDsKCQluZXh0ID0gY3VycmVudDsKCX0KCXJldHVybiBuZXh0Owp9CgovKgogKiBNZXJnZSB0aGUgY29tbWl0cyBoMSBhbmQgaDIsIHJldHVybiB0aGUgcmVzdWx0aW5nIHZpcnR1YWwKICogY29tbWl0IG9iamVjdCBhbmQgYSBmbGFnIGluZGljYXRpbmcgdGhlIGNsZWFubmVzcyBvZiB0aGUgbWVyZ2UuCiAqLwppbnQgbWVyZ2VfcmVjdXJzaXZlKHN0cnVjdCBtZXJnZV9vcHRpb25zICpvLAoJCSAgICBzdHJ1Y3QgY29tbWl0ICpoMSwKCQkgICAgc3RydWN0IGNvbW1pdCAqaDIsCgkJICAgIHN0cnVjdCBjb21taXRfbGlzdCAqY2EsCgkJICAgIHN0cnVjdCBjb21taXQgKipyZXN1bHQpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqaXRlcjsKCXN0cnVjdCBjb21taXQgKm1lcmdlZF9jb21tb25fYW5jZXN0b3JzOwoJc3RydWN0IHRyZWUgKm1ydHJlZSA9IG1ydHJlZTsKCWludCBjbGVhbjsKCglpZiAoc2hvdyhvLCA0KSkgewoJCW91dHB1dChvLCA0LCBfKCJNZXJnaW5nOiIpKTsKCQlvdXRwdXRfY29tbWl0X3RpdGxlKG8sIGgxKTsKCQlvdXRwdXRfY29tbWl0X3RpdGxlKG8sIGgyKTsKCX0KCglpZiAoIWNhKSB7CgkJY2EgPSBnZXRfbWVyZ2VfYmFzZXMoaDEsIGgyKTsKCQljYSA9IHJldmVyc2VfY29tbWl0X2xpc3QoY2EpOwoJfQoKCWlmIChzaG93KG8sIDUpKSB7CgkJdW5zaWduZWQgY250ID0gY29tbWl0X2xpc3RfY291bnQoY2EpOwoKCQlvdXRwdXQobywgNSwgUV8oImZvdW5kICV1IGNvbW1vbiBhbmNlc3RvcjoiLAoJCQkJImZvdW5kICV1IGNvbW1vbiBhbmNlc3RvcnM6IiwgY250KSwgY250KTsKCQlmb3IgKGl0ZXIgPSBjYTsgaXRlcjsgaXRlciA9IGl0ZXItPm5leHQpCgkJCW91dHB1dF9jb21taXRfdGl0bGUobywgaXRlci0+aXRlbSk7Cgl9CgoJbWVyZ2VkX2NvbW1vbl9hbmNlc3RvcnMgPSBwb3BfY29tbWl0KCZjYSk7CglpZiAobWVyZ2VkX2NvbW1vbl9hbmNlc3RvcnMgPT0gTlVMTCkgewoJCS8qIGlmIHRoZXJlIGlzIG5vIGNvbW1vbiBhbmNlc3RvciwgdXNlIGFuIGVtcHR5IHRyZWUgKi8KCQlzdHJ1Y3QgdHJlZSAqdHJlZTsKCgkJdHJlZSA9IGxvb2t1cF90cmVlKEVNUFRZX1RSRUVfU0hBMV9CSU4pOwoJCW1lcmdlZF9jb21tb25fYW5jZXN0b3JzID0gbWFrZV92aXJ0dWFsX2NvbW1pdCh0cmVlLCAiYW5jZXN0b3IiKTsKCX0KCglmb3IgKGl0ZXIgPSBjYTsgaXRlcjsgaXRlciA9IGl0ZXItPm5leHQpIHsKCQljb25zdCBjaGFyICpzYXZlZF9iMSwgKnNhdmVkX2IyOwoJCW8tPmNhbGxfZGVwdGgrKzsKCQkvKgoJCSAqIFdoZW4gdGhlIG1lcmdlIGZhaWxzLCB0aGUgcmVzdWx0IGNvbnRhaW5zIGZpbGVzCgkJICogd2l0aCBjb25mbGljdCBtYXJrZXJzLiBUaGUgY2xlYW5uZXNzIGZsYWcgaXMKCQkgKiBpZ25vcmVkICh1bmxlc3MgaW5kaWNhdGluZyBhbiBlcnJvciksIGl0IHdhcyBuZXZlcgoJCSAqIGFjdHVhbGx5IHVzZWQsIGFzIHJlc3VsdCBvZiBtZXJnZV90cmVlcyBoYXMgYWx3YXlzCgkJICogb3ZlcndyaXR0ZW4gaXQ6IHRoZSBjb21taXR0ZWQgImNvbmZsaWN0cyIgd2VyZQoJCSAqIGFscmVhZHkgcmVzb2x2ZWQuCgkJICovCgkJZGlzY2FyZF9jYWNoZSgpOwoJCXNhdmVkX2IxID0gby0+YnJhbmNoMTsKCQlzYXZlZF9iMiA9IG8tPmJyYW5jaDI7CgkJby0+YnJhbmNoMSA9ICJUZW1wb3JhcnkgbWVyZ2UgYnJhbmNoIDEiOwoJCW8tPmJyYW5jaDIgPSAiVGVtcG9yYXJ5IG1lcmdlIGJyYW5jaCAyIjsKCQlpZiAobWVyZ2VfcmVjdXJzaXZlKG8sIG1lcmdlZF9jb21tb25fYW5jZXN0b3JzLCBpdGVyLT5pdGVtLAoJCQkJICAgIE5VTEwsICZtZXJnZWRfY29tbW9uX2FuY2VzdG9ycykgPCAwKQoJCQlyZXR1cm4gLTE7CgkJby0+YnJhbmNoMSA9IHNhdmVkX2IxOwoJCW8tPmJyYW5jaDIgPSBzYXZlZF9iMjsKCQlvLT5jYWxsX2RlcHRoLS07CgoJCWlmICghbWVyZ2VkX2NvbW1vbl9hbmNlc3RvcnMpCgkJCXJldHVybiBlcnIobywgXygibWVyZ2UgcmV0dXJuZWQgbm8gY29tbWl0IikpOwoJfQoKCWRpc2NhcmRfY2FjaGUoKTsKCWlmICghby0+Y2FsbF9kZXB0aCkKCQlyZWFkX2NhY2hlKCk7CgoJby0+YW5jZXN0b3IgPSAibWVyZ2VkIGNvbW1vbiBhbmNlc3RvcnMiOwoJY2xlYW4gPSBtZXJnZV90cmVlcyhvLCBoMS0+dHJlZSwgaDItPnRyZWUsIG1lcmdlZF9jb21tb25fYW5jZXN0b3JzLT50cmVlLAoJCQkgICAgJm1ydHJlZSk7CglpZiAoY2xlYW4gPCAwKSB7CgkJZmx1c2hfb3V0cHV0KG8pOwoJCXJldHVybiBjbGVhbjsKCX0KCglpZiAoby0+Y2FsbF9kZXB0aCkgewoJCSpyZXN1bHQgPSBtYWtlX3ZpcnR1YWxfY29tbWl0KG1ydHJlZSwgIm1lcmdlZCB0cmVlIik7CgkJY29tbWl0X2xpc3RfaW5zZXJ0KGgxLCAmKCpyZXN1bHQpLT5wYXJlbnRzKTsKCQljb21taXRfbGlzdF9pbnNlcnQoaDIsICYoKnJlc3VsdCktPnBhcmVudHMtPm5leHQpOwoJfQoJZmx1c2hfb3V0cHV0KG8pOwoJaWYgKCFvLT5jYWxsX2RlcHRoICYmIG8tPmJ1ZmZlcl9vdXRwdXQgPCAyKQoJCXN0cmJ1Zl9yZWxlYXNlKCZvLT5vYnVmKTsKCWlmIChzaG93KG8sIDIpKQoJCWRpZmZfd2Fybl9yZW5hbWVfbGltaXQoIm1lcmdlLnJlbmFtZWxpbWl0IiwKCQkJCSAgICAgICBvLT5uZWVkZWRfcmVuYW1lX2xpbWl0LCAwKTsKCXJldHVybiBjbGVhbjsKfQoKc3RhdGljIHN0cnVjdCBjb21taXQgKmdldF9yZWYoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBjb25zdCBjaGFyICpuYW1lKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmplY3Q7CgoJb2JqZWN0ID0gZGVyZWZfdGFnKHBhcnNlX29iamVjdChvaWQtPmhhc2gpLCBuYW1lLCBzdHJsZW4obmFtZSkpOwoJaWYgKCFvYmplY3QpCgkJcmV0dXJuIE5VTEw7CglpZiAob2JqZWN0LT50eXBlID09IE9CSl9UUkVFKQoJCXJldHVybiBtYWtlX3ZpcnR1YWxfY29tbWl0KChzdHJ1Y3QgdHJlZSopb2JqZWN0LCBuYW1lKTsKCWlmIChvYmplY3QtPnR5cGUgIT0gT0JKX0NPTU1JVCkKCQlyZXR1cm4gTlVMTDsKCWlmIChwYXJzZV9jb21taXQoKHN0cnVjdCBjb21taXQgKilvYmplY3QpKQoJCXJldHVybiBOVUxMOwoJcmV0dXJuIChzdHJ1Y3QgY29tbWl0ICopb2JqZWN0Owp9CgppbnQgbWVyZ2VfcmVjdXJzaXZlX2dlbmVyaWMoc3RydWN0IG1lcmdlX29wdGlvbnMgKm8sCgkJCSAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpoZWFkLAoJCQkgICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqbWVyZ2UsCgkJCSAgICBpbnQgbnVtX2Jhc2VfbGlzdCwKCQkJICAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKipiYXNlX2xpc3QsCgkJCSAgICBzdHJ1Y3QgY29tbWl0ICoqcmVzdWx0KQp7CglpbnQgY2xlYW47CglzdHJ1Y3QgbG9ja19maWxlICpsb2NrID0geGNhbGxvYygxLCBzaXplb2Yoc3RydWN0IGxvY2tfZmlsZSkpOwoJc3RydWN0IGNvbW1pdCAqaGVhZF9jb21taXQgPSBnZXRfcmVmKGhlYWQsIG8tPmJyYW5jaDEpOwoJc3RydWN0IGNvbW1pdCAqbmV4dF9jb21taXQgPSBnZXRfcmVmKG1lcmdlLCBvLT5icmFuY2gyKTsKCXN0cnVjdCBjb21taXRfbGlzdCAqY2EgPSBOVUxMOwoKCWlmIChiYXNlX2xpc3QpIHsKCQlpbnQgaTsKCQlmb3IgKGkgPSAwOyBpIDwgbnVtX2Jhc2VfbGlzdDsgKytpKSB7CgkJCXN0cnVjdCBjb21taXQgKmJhc2U7CgkJCWlmICghKGJhc2UgPSBnZXRfcmVmKGJhc2VfbGlzdFtpXSwgb2lkX3RvX2hleChiYXNlX2xpc3RbaV0pKSkpCgkJCQlyZXR1cm4gZXJyKG8sIF8oIkNvdWxkIG5vdCBwYXJzZSBvYmplY3QgJyVzJyIpLAoJCQkJCW9pZF90b19oZXgoYmFzZV9saXN0W2ldKSk7CgkJCWNvbW1pdF9saXN0X2luc2VydChiYXNlLCAmY2EpOwoJCX0KCX0KCglob2xkX2xvY2tlZF9pbmRleChsb2NrLCBMT0NLX0RJRV9PTl9FUlJPUik7CgljbGVhbiA9IG1lcmdlX3JlY3Vyc2l2ZShvLCBoZWFkX2NvbW1pdCwgbmV4dF9jb21taXQsIGNhLAoJCQlyZXN1bHQpOwoJaWYgKGNsZWFuIDwgMCkKCQlyZXR1cm4gY2xlYW47CgoJaWYgKGFjdGl2ZV9jYWNoZV9jaGFuZ2VkICYmCgkgICAgd3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsIGxvY2ssIENPTU1JVF9MT0NLKSkKCQlyZXR1cm4gZXJyKG8sIF8oIlVuYWJsZSB0byB3cml0ZSBpbmRleC4iKSk7CgoJcmV0dXJuIGNsZWFuID8gMCA6IDE7Cn0KCnN0YXRpYyB2b2lkIG1lcmdlX3JlY3Vyc2l2ZV9jb25maWcoc3RydWN0IG1lcmdlX29wdGlvbnMgKm8pCnsKCWdpdF9jb25maWdfZ2V0X2ludCgibWVyZ2UudmVyYm9zaXR5IiwgJm8tPnZlcmJvc2l0eSk7CglnaXRfY29uZmlnX2dldF9pbnQoImRpZmYucmVuYW1lbGltaXQiLCAmby0+ZGlmZl9yZW5hbWVfbGltaXQpOwoJZ2l0X2NvbmZpZ19nZXRfaW50KCJtZXJnZS5yZW5hbWVsaW1pdCIsICZvLT5tZXJnZV9yZW5hbWVfbGltaXQpOwoJZ2l0X2NvbmZpZyhnaXRfeG1lcmdlX2NvbmZpZywgTlVMTCk7Cn0KCnZvaWQgaW5pdF9tZXJnZV9vcHRpb25zKHN0cnVjdCBtZXJnZV9vcHRpb25zICpvKQp7CgltZW1zZXQobywgMCwgc2l6ZW9mKHN0cnVjdCBtZXJnZV9vcHRpb25zKSk7CglvLT52ZXJib3NpdHkgPSAyOwoJby0+YnVmZmVyX291dHB1dCA9IDE7CglvLT5kaWZmX3JlbmFtZV9saW1pdCA9IC0xOwoJby0+bWVyZ2VfcmVuYW1lX2xpbWl0ID0gLTE7CglvLT5yZW5vcm1hbGl6ZSA9IDA7CglvLT5kZXRlY3RfcmVuYW1lID0gMTsKCW1lcmdlX3JlY3Vyc2l2ZV9jb25maWcobyk7CglpZiAoZ2V0ZW52KCJHSVRfTUVSR0VfVkVSQk9TSVRZIikpCgkJby0+dmVyYm9zaXR5ID0KCQkJc3RydG9sKGdldGVudigiR0lUX01FUkdFX1ZFUkJPU0lUWSIpLCBOVUxMLCAxMCk7CglpZiAoby0+dmVyYm9zaXR5ID49IDUpCgkJby0+YnVmZmVyX291dHB1dCA9IDA7CglzdHJidWZfaW5pdCgmby0+b2J1ZiwgMCk7CglzdHJpbmdfbGlzdF9pbml0KCZvLT5jdXJyZW50X2ZpbGVfc2V0LCAxKTsKCXN0cmluZ19saXN0X2luaXQoJm8tPmN1cnJlbnRfZGlyZWN0b3J5X3NldCwgMSk7CglzdHJpbmdfbGlzdF9pbml0KCZvLT5kZl9jb25mbGljdF9maWxlX3NldCwgMSk7Cn0KCmludCBwYXJzZV9tZXJnZV9vcHQoc3RydWN0IG1lcmdlX29wdGlvbnMgKm8sIGNvbnN0IGNoYXIgKnMpCnsKCWNvbnN0IGNoYXIgKmFyZzsKCglpZiAoIXMgfHwgISpzKQoJCXJldHVybiAtMTsKCWlmICghc3RyY21wKHMsICJvdXJzIikpCgkJby0+cmVjdXJzaXZlX3ZhcmlhbnQgPSBNRVJHRV9SRUNVUlNJVkVfT1VSUzsKCWVsc2UgaWYgKCFzdHJjbXAocywgInRoZWlycyIpKQoJCW8tPnJlY3Vyc2l2ZV92YXJpYW50ID0gTUVSR0VfUkVDVVJTSVZFX1RIRUlSUzsKCWVsc2UgaWYgKCFzdHJjbXAocywgInN1YnRyZWUiKSkKCQlvLT5zdWJ0cmVlX3NoaWZ0ID0gIiI7CgllbHNlIGlmIChza2lwX3ByZWZpeChzLCAic3VidHJlZT0iLCAmYXJnKSkKCQlvLT5zdWJ0cmVlX3NoaWZ0ID0gYXJnOwoJZWxzZSBpZiAoIXN0cmNtcChzLCAicGF0aWVuY2UiKSkKCQlvLT54ZGxfb3B0cyA9IERJRkZfV0lUSF9BTEcobywgUEFUSUVOQ0VfRElGRik7CgllbHNlIGlmICghc3RyY21wKHMsICJoaXN0b2dyYW0iKSkKCQlvLT54ZGxfb3B0cyA9IERJRkZfV0lUSF9BTEcobywgSElTVE9HUkFNX0RJRkYpOwoJZWxzZSBpZiAoc2tpcF9wcmVmaXgocywgImRpZmYtYWxnb3JpdGhtPSIsICZhcmcpKSB7CgkJbG9uZyB2YWx1ZSA9IHBhcnNlX2FsZ29yaXRobV92YWx1ZShhcmcpOwoJCWlmICh2YWx1ZSA8IDApCgkJCXJldHVybiAtMTsKCQkvKiBjbGVhciBvdXQgcHJldmlvdXMgc2V0dGluZ3MgKi8KCQlESUZGX1hETF9DTFIobywgTkVFRF9NSU5JTUFMKTsKCQlvLT54ZGxfb3B0cyAmPSB+WERGX0RJRkZfQUxHT1JJVEhNX01BU0s7CgkJby0+eGRsX29wdHMgfD0gdmFsdWU7Cgl9CgllbHNlIGlmICghc3RyY21wKHMsICJpZ25vcmUtc3BhY2UtY2hhbmdlIikpCgkJRElGRl9YRExfU0VUKG8sIElHTk9SRV9XSElURVNQQUNFX0NIQU5HRSk7CgllbHNlIGlmICghc3RyY21wKHMsICJpZ25vcmUtYWxsLXNwYWNlIikpCgkJRElGRl9YRExfU0VUKG8sIElHTk9SRV9XSElURVNQQUNFKTsKCWVsc2UgaWYgKCFzdHJjbXAocywgImlnbm9yZS1zcGFjZS1hdC1lb2wiKSkKCQlESUZGX1hETF9TRVQobywgSUdOT1JFX1dISVRFU1BBQ0VfQVRfRU9MKTsKCWVsc2UgaWYgKCFzdHJjbXAocywgImlnbm9yZS1jci1hdC1lb2wiKSkKCQlESUZGX1hETF9TRVQobywgSUdOT1JFX0NSX0FUX0VPTCk7CgllbHNlIGlmICghc3RyY21wKHMsICJyZW5vcm1hbGl6ZSIpKQoJCW8tPnJlbm9ybWFsaXplID0gMTsKCWVsc2UgaWYgKCFzdHJjbXAocywgIm5vLXJlbm9ybWFsaXplIikpCgkJby0+cmVub3JtYWxpemUgPSAwOwoJZWxzZSBpZiAoIXN0cmNtcChzLCAibm8tcmVuYW1lcyIpKQoJCW8tPmRldGVjdF9yZW5hbWUgPSAwOwoJZWxzZSBpZiAoIXN0cmNtcChzLCAiZmluZC1yZW5hbWVzIikpIHsKCQlvLT5kZXRlY3RfcmVuYW1lID0gMTsKCQlvLT5yZW5hbWVfc2NvcmUgPSAwOwoJfQoJZWxzZSBpZiAoc2tpcF9wcmVmaXgocywgImZpbmQtcmVuYW1lcz0iLCAmYXJnKSB8fAoJCSBza2lwX3ByZWZpeChzLCAicmVuYW1lLXRocmVzaG9sZD0iLCAmYXJnKSkgewoJCWlmICgoby0+cmVuYW1lX3Njb3JlID0gcGFyc2VfcmVuYW1lX3Njb3JlKCZhcmcpKSA9PSAtMSB8fCAqYXJnICE9IDApCgkJCXJldHVybiAtMTsKCQlvLT5kZXRlY3RfcmVuYW1lID0gMTsKCX0KCWVsc2UKCQlyZXR1cm4gLTE7CglyZXR1cm4gMDsKfQo=",
    "text": "/*\n * Recursive Merge algorithm stolen from git-merge-recursive.py by\n * Fredrik Kuivinen.\n * The thieves were Alex Riesen and Johannes Schindelin, in June/July 2006\n */\n#include \"cache.h\"\n#include \"advice.h\"\n#include \"lockfile.h\"\n#include \"cache-tree.h\"\n#include \"commit.h\"\n#include \"blob.h\"\n#include \"builtin.h\"\n#include \"tree-walk.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"tag.h\"\n#include \"unpack-trees.h\"\n#include \"string-list.h\"\n#include \"xdiff-interface.h\"\n#include \"ll-merge.h\"\n#include \"attr.h\"\n#include \"merge-recursive.h\"\n#include \"dir.h\"\n#include \"submodule.h\"\n\nstatic void flush_output(struct merge_options *o)\n{\n\tif (o->buffer_output < 2 && o->obuf.len) {\n\t\tfputs(o->obuf.buf, stdout);\n\t\tstrbuf_reset(&o->obuf);\n\t}\n}\n\nstatic int err(struct merge_options *o, const char *err, ...)\n{\n\tva_list params;\n\n\tif (o->buffer_output < 2)\n\t\tflush_output(o);\n\telse {\n\t\tstrbuf_complete(&o->obuf, '\\n');\n\t\tstrbuf_addstr(&o->obuf, \"error: \");\n\t}\n\tva_start(params, err);\n\tstrbuf_vaddf(&o->obuf, err, params);\n\tva_end(params);\n\tif (o->buffer_output > 1)\n\t\tstrbuf_addch(&o->obuf, '\\n');\n\telse {\n\t\terror(\"%s\", o->obuf.buf);\n\t\tstrbuf_reset(&o->obuf);\n\t}\n\n\treturn -1;\n}\n\nstatic struct tree *shift_tree_object(struct tree *one, struct tree *two,\n\t\t\t\t      const char *subtree_shift)\n{\n\tstruct object_id shifted;\n\n\tif (!*subtree_shift) {\n\t\tshift_tree(&one->object.oid, &two->object.oid, &shifted, 0);\n\t} else {\n\t\tshift_tree_by(&one->object.oid, &two->object.oid, &shifted,\n\t\t\t      subtree_shift);\n\t}\n\tif (!oidcmp(&two->object.oid, &shifted))\n\t\treturn two;\n\treturn lookup_tree(shifted.hash);\n}\n\nstatic struct commit *make_virtual_commit(struct tree *tree, const char *comment)\n{\n\tstruct commit *commit = alloc_commit_node();\n\n\tset_merge_remote_desc(commit, comment, (struct object *)commit);\n\tcommit->tree = tree;\n\tcommit->object.parsed = 1;\n\treturn commit;\n}\n\n/*\n * Since we use get_tree_entry(), which does not put the read object into\n * the object pool, we cannot rely on a == b.\n */\nstatic int oid_eq(const struct object_id *a, const struct object_id *b)\n{\n\tif (!a && !b)\n\t\treturn 2;\n\treturn a && b && oidcmp(a, b) == 0;\n}\n\nenum rename_type {\n\tRENAME_NORMAL = 0,\n\tRENAME_DELETE,\n\tRENAME_ONE_FILE_TO_ONE,\n\tRENAME_ONE_FILE_TO_TWO,\n\tRENAME_TWO_FILES_TO_ONE\n};\n\nstruct rename_conflict_info {\n\tenum rename_type rename_type;\n\tstruct diff_filepair *pair1;\n\tstruct diff_filepair *pair2;\n\tconst char *branch1;\n\tconst char *branch2;\n\tstruct stage_data *dst_entry1;\n\tstruct stage_data *dst_entry2;\n\tstruct diff_filespec ren1_other;\n\tstruct diff_filespec ren2_other;\n};\n\n/*\n * Since we want to write the index eventually, we cannot reuse the index\n * for these (temporary) data.\n */\nstruct stage_data {\n\tstruct {\n\t\tunsigned mode;\n\t\tstruct object_id oid;\n\t} stages[4];\n\tstruct rename_conflict_info *rename_conflict_info;\n\tunsigned processed:1;\n};\n\nstatic inline void setup_rename_conflict_info(enum rename_type rename_type,\n\t\t\t\t\t      struct diff_filepair *pair1,\n\t\t\t\t\t      struct diff_filepair *pair2,\n\t\t\t\t\t      const char *branch1,\n\t\t\t\t\t      const char *branch2,\n\t\t\t\t\t      struct stage_data *dst_entry1,\n\t\t\t\t\t      struct stage_data *dst_entry2,\n\t\t\t\t\t      struct merge_options *o,\n\t\t\t\t\t      struct stage_data *src_entry1,\n\t\t\t\t\t      struct stage_data *src_entry2)\n{\n\tstruct rename_conflict_info *ci = xcalloc(1, sizeof(struct rename_conflict_info));\n\tci->rename_type = rename_type;\n\tci->pair1 = pair1;\n\tci->branch1 = branch1;\n\tci->branch2 = branch2;\n\n\tci->dst_entry1 = dst_entry1;\n\tdst_entry1->rename_conflict_info = ci;\n\tdst_entry1->processed = 0;\n\n\tassert(!pair2 == !dst_entry2);\n\tif (dst_entry2) {\n\t\tci->dst_entry2 = dst_entry2;\n\t\tci->pair2 = pair2;\n\t\tdst_entry2->rename_conflict_info = ci;\n\t}\n\n\tif (rename_type == RENAME_TWO_FILES_TO_ONE) {\n\t\t/*\n\t\t * For each rename, there could have been\n\t\t * modifications on the side of history where that\n\t\t * file was not renamed.\n\t\t */\n\t\tint ostage1 = o->branch1 == branch1 ? 3 : 2;\n\t\tint ostage2 = ostage1 ^ 1;\n\n\t\tci->ren1_other.path = pair1->one->path;\n\t\toidcpy(&ci->ren1_other.oid, &src_entry1->stages[ostage1].oid);\n\t\tci->ren1_other.mode = src_entry1->stages[ostage1].mode;\n\n\t\tci->ren2_other.path = pair2->one->path;\n\t\toidcpy(&ci->ren2_other.oid, &src_entry2->stages[ostage2].oid);\n\t\tci->ren2_other.mode = src_entry2->stages[ostage2].mode;\n\t}\n}\n\nstatic int show(struct merge_options *o, int v)\n{\n\treturn (!o->call_depth && o->verbosity >= v) || o->verbosity >= 5;\n}\n\n__attribute__((format (printf, 3, 4)))\nstatic void output(struct merge_options *o, int v, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tif (!show(o, v))\n\t\treturn;\n\n\tstrbuf_addchars(&o->obuf, ' ', o->call_depth * 2);\n\n\tva_start(ap, fmt);\n\tstrbuf_vaddf(&o->obuf, fmt, ap);\n\tva_end(ap);\n\n\tstrbuf_addch(&o->obuf, '\\n');\n\tif (!o->buffer_output)\n\t\tflush_output(o);\n}\n\nstatic void output_commit_title(struct merge_options *o, struct commit *commit)\n{\n\tstrbuf_addchars(&o->obuf, ' ', o->call_depth * 2);\n\tif (commit->util)\n\t\tstrbuf_addf(&o->obuf, \"virtual %s\\n\",\n\t\t\tmerge_remote_util(commit)->name);\n\telse {\n\t\tstrbuf_add_unique_abbrev(&o->obuf, commit->object.oid.hash,\n\t\t\t\t\t DEFAULT_ABBREV);\n\t\tstrbuf_addch(&o->obuf, ' ');\n\t\tif (parse_commit(commit) != 0)\n\t\t\tstrbuf_addstr(&o->obuf, _(\"(bad commit)\\n\"));\n\t\telse {\n\t\t\tconst char *title;\n\t\t\tconst char *msg = get_commit_buffer(commit, NULL);\n\t\t\tint len = find_commit_subject(msg, &title);\n\t\t\tif (len)\n\t\t\t\tstrbuf_addf(&o->obuf, \"%.*s\\n\", len, title);\n\t\t\tunuse_commit_buffer(commit, msg);\n\t\t}\n\t}\n\tflush_output(o);\n}\n\nstatic int add_cacheinfo(struct merge_options *o,\n\t\tunsigned int mode, const struct object_id *oid,\n\t\tconst char *path, int stage, int refresh, int options)\n{\n\tstruct cache_entry *ce;\n\tint ret;\n\n\tce = make_cache_entry(mode, oid ? oid->hash : null_sha1, path, stage, 0);\n\tif (!ce)\n\t\treturn err(o, _(\"addinfo_cache failed for path '%s'\"), path);\n\n\tret = add_cache_entry(ce, options);\n\tif (refresh) {\n\t\tstruct cache_entry *nce;\n\n\t\tnce = refresh_cache_entry(ce, CE_MATCH_REFRESH | CE_MATCH_IGNORE_MISSING);\n\t\tif (!nce)\n\t\t\treturn err(o, _(\"addinfo_cache failed for path '%s'\"), path);\n\t\tif (nce != ce)\n\t\t\tret = add_cache_entry(nce, options);\n\t}\n\treturn ret;\n}\n\nstatic void init_tree_desc_from_tree(struct tree_desc *desc, struct tree *tree)\n{\n\tparse_tree(tree);\n\tinit_tree_desc(desc, tree->buffer, tree->size);\n}\n\nstatic int git_merge_trees(int index_only,\n\t\t\t   struct tree *common,\n\t\t\t   struct tree *head,\n\t\t\t   struct tree *merge)\n{\n\tint rc;\n\tstruct tree_desc t[3];\n\tstruct unpack_trees_options opts;\n\n\tmemset(&opts, 0, sizeof(opts));\n\tif (index_only)\n\t\topts.index_only = 1;\n\telse\n\t\topts.update = 1;\n\topts.merge = 1;\n\topts.head_idx = 2;\n\topts.fn = threeway_merge;\n\topts.src_index = &the_index;\n\topts.dst_index = &the_index;\n\tsetup_unpack_trees_porcelain(&opts, \"merge\");\n\n\tinit_tree_desc_from_tree(t+0, common);\n\tinit_tree_desc_from_tree(t+1, head);\n\tinit_tree_desc_from_tree(t+2, merge);\n\n\trc = unpack_trees(3, t, &opts);\n\tcache_tree_free(&active_cache_tree);\n\treturn rc;\n}\n\nstruct tree *write_tree_from_memory(struct merge_options *o)\n{\n\tstruct tree *result = NULL;\n\n\tif (unmerged_cache()) {\n\t\tint i;\n\t\tfprintf(stderr, \"BUG: There are unmerged index entries:\\n\");\n\t\tfor (i = 0; i < active_nr; i++) {\n\t\t\tconst struct cache_entry *ce = active_cache[i];\n\t\t\tif (ce_stage(ce))\n\t\t\t\tfprintf(stderr, \"BUG: %d %.*s\\n\", ce_stage(ce),\n\t\t\t\t\t(int)ce_namelen(ce), ce->name);\n\t\t}\n\t\tdie(\"BUG: unmerged index entries in merge-recursive.c\");\n\t}\n\n\tif (!active_cache_tree)\n\t\tactive_cache_tree = cache_tree();\n\n\tif (!cache_tree_fully_valid(active_cache_tree) &&\n\t    cache_tree_update(&the_index, 0) < 0) {\n\t\terr(o, _(\"error building trees\"));\n\t\treturn NULL;\n\t}\n\n\tresult = lookup_tree(active_cache_tree->sha1);\n\n\treturn result;\n}\n\nstatic int save_files_dirs(const unsigned char *sha1,\n\t\tstruct strbuf *base, const char *path,\n\t\tunsigned int mode, int stage, void *context)\n{\n\tint baselen = base->len;\n\tstruct merge_options *o = context;\n\n\tstrbuf_addstr(base, path);\n\n\tif (S_ISDIR(mode))\n\t\tstring_list_insert(&o->current_directory_set, base->buf);\n\telse\n\t\tstring_list_insert(&o->current_file_set, base->buf);\n\n\tstrbuf_setlen(base, baselen);\n\treturn (S_ISDIR(mode) ? READ_TREE_RECURSIVE : 0);\n}\n\nstatic int get_files_dirs(struct merge_options *o, struct tree *tree)\n{\n\tint n;\n\tstruct pathspec match_all;\n\tmemset(&match_all, 0, sizeof(match_all));\n\tif (read_tree_recursive(tree, \"\", 0, 0, &match_all, save_files_dirs, o))\n\t\treturn 0;\n\tn = o->current_file_set.nr + o->current_directory_set.nr;\n\treturn n;\n}\n\n/*\n * Returns an index_entry instance which doesn't have to correspond to\n * a real cache entry in Git's index.\n */\nstatic struct stage_data *insert_stage_data(const char *path,\n\t\tstruct tree *o, struct tree *a, struct tree *b,\n\t\tstruct string_list *entries)\n{\n\tstruct string_list_item *item;\n\tstruct stage_data *e = xcalloc(1, sizeof(struct stage_data));\n\tget_tree_entry(o->object.oid.hash, path,\n\t\t\te->stages[1].oid.hash, &e->stages[1].mode);\n\tget_tree_entry(a->object.oid.hash, path,\n\t\t\te->stages[2].oid.hash, &e->stages[2].mode);\n\tget_tree_entry(b->object.oid.hash, path,\n\t\t\te->stages[3].oid.hash, &e->stages[3].mode);\n\titem = string_list_insert(entries, path);\n\titem->util = e;\n\treturn e;\n}\n\n/*\n * Create a dictionary mapping file names to stage_data objects. The\n * dictionary contains one entry for every path with a non-zero stage entry.\n */\nstatic struct string_list *get_unmerged(void)\n{\n\tstruct string_list *unmerged = xcalloc(1, sizeof(struct string_list));\n\tint i;\n\n\tunmerged->strdup_strings = 1;\n\n\tfor (i = 0; i < active_nr; i++) {\n\t\tstruct string_list_item *item;\n\t\tstruct stage_data *e;\n\t\tconst struct cache_entry *ce = active_cache[i];\n\t\tif (!ce_stage(ce))\n\t\t\tcontinue;\n\n\t\titem = string_list_lookup(unmerged, ce->name);\n\t\tif (!item) {\n\t\t\titem = string_list_insert(unmerged, ce->name);\n\t\t\titem->util = xcalloc(1, sizeof(struct stage_data));\n\t\t}\n\t\te = item->util;\n\t\te->stages[ce_stage(ce)].mode = ce->ce_mode;\n\t\toidcpy(&e->stages[ce_stage(ce)].oid, &ce->oid);\n\t}\n\n\treturn unmerged;\n}\n\nstatic int string_list_df_name_compare(const char *one, const char *two)\n{\n\tint onelen = strlen(one);\n\tint twolen = strlen(two);\n\t/*\n\t * Here we only care that entries for D/F conflicts are\n\t * adjacent, in particular with the file of the D/F conflict\n\t * appearing before files below the corresponding directory.\n\t * The order of the rest of the list is irrelevant for us.\n\t *\n\t * To achieve this, we sort with df_name_compare and provide\n\t * the mode S_IFDIR so that D/F conflicts will sort correctly.\n\t * We use the mode S_IFDIR for everything else for simplicity,\n\t * since in other cases any changes in their order due to\n\t * sorting cause no problems for us.\n\t */\n\tint cmp = df_name_compare(one, onelen, S_IFDIR,\n\t\t\t\t  two, twolen, S_IFDIR);\n\t/*\n\t * Now that 'foo' and 'foo/bar' compare equal, we have to make sure\n\t * that 'foo' comes before 'foo/bar'.\n\t */\n\tif (cmp)\n\t\treturn cmp;\n\treturn onelen - twolen;\n}\n\nstatic void record_df_conflict_files(struct merge_options *o,\n\t\t\t\t     struct string_list *entries)\n{\n\t/* If there is a D/F conflict and the file for such a conflict\n\t * currently exist in the working tree, we want to allow it to be\n\t * removed to make room for the corresponding directory if needed.\n\t * The files underneath the directories of such D/F conflicts will\n\t * be processed before the corresponding file involved in the D/F\n\t * conflict.  If the D/F directory ends up being removed by the\n\t * merge, then we won't have to touch the D/F file.  If the D/F\n\t * directory needs to be written to the working copy, then the D/F\n\t * file will simply be removed (in make_room_for_path()) to make\n\t * room for the necessary paths.  Note that if both the directory\n\t * and the file need to be present, then the D/F file will be\n\t * reinstated with a new unique name at the time it is processed.\n\t */\n\tstruct string_list df_sorted_entries = STRING_LIST_INIT_NODUP;\n\tconst char *last_file = NULL;\n\tint last_len = 0;\n\tint i;\n\n\t/*\n\t * If we're merging merge-bases, we don't want to bother with\n\t * any working directory changes.\n\t */\n\tif (o->call_depth)\n\t\treturn;\n\n\t/* Ensure D/F conflicts are adjacent in the entries list. */\n\tfor (i = 0; i < entries->nr; i++) {\n\t\tstruct string_list_item *next = &entries->items[i];\n\t\tstring_list_append(&df_sorted_entries, next->string)->util =\n\t\t\t\t   next->util;\n\t}\n\tdf_sorted_entries.cmp = string_list_df_name_compare;\n\tstring_list_sort(&df_sorted_entries);\n\n\tstring_list_clear(&o->df_conflict_file_set, 1);\n\tfor (i = 0; i < df_sorted_entries.nr; i++) {\n\t\tconst char *path = df_sorted_entries.items[i].string;\n\t\tint len = strlen(path);\n\t\tstruct stage_data *e = df_sorted_entries.items[i].util;\n\n\t\t/*\n\t\t * Check if last_file & path correspond to a D/F conflict;\n\t\t * i.e. whether path is last_file+'/'+<something>.\n\t\t * If so, record that it's okay to remove last_file to make\n\t\t * room for path and friends if needed.\n\t\t */\n\t\tif (last_file &&\n\t\t    len > last_len &&\n\t\t    memcmp(path, last_file, last_len) == 0 &&\n\t\t    path[last_len] == '/') {\n\t\t\tstring_list_insert(&o->df_conflict_file_set, last_file);\n\t\t}\n\n\t\t/*\n\t\t * Determine whether path could exist as a file in the\n\t\t * working directory as a possible D/F conflict.  This\n\t\t * will only occur when it exists in stage 2 as a\n\t\t * file.\n\t\t */\n\t\tif (S_ISREG(e->stages[2].mode) || S_ISLNK(e->stages[2].mode)) {\n\t\t\tlast_file = path;\n\t\t\tlast_len = len;\n\t\t} else {\n\t\t\tlast_file = NULL;\n\t\t}\n\t}\n\tstring_list_clear(&df_sorted_entries, 0);\n}\n\nstruct rename {\n\tstruct diff_filepair *pair;\n\tstruct stage_data *src_entry;\n\tstruct stage_data *dst_entry;\n\tunsigned processed:1;\n};\n\n/*\n * Get information of all renames which occurred between 'o_tree' and\n * 'tree'. We need the three trees in the merge ('o_tree', 'a_tree' and\n * 'b_tree') to be able to associate the correct cache entries with\n * the rename information. 'tree' is always equal to either a_tree or b_tree.\n */\nstatic struct string_list *get_renames(struct merge_options *o,\n\t\t\t\t       struct tree *tree,\n\t\t\t\t       struct tree *o_tree,\n\t\t\t\t       struct tree *a_tree,\n\t\t\t\t       struct tree *b_tree,\n\t\t\t\t       struct string_list *entries)\n{\n\tint i;\n\tstruct string_list *renames;\n\tstruct diff_options opts;\n\n\trenames = xcalloc(1, sizeof(struct string_list));\n\tif (!o->detect_rename)\n\t\treturn renames;\n\n\tdiff_setup(&opts);\n\tDIFF_OPT_SET(&opts, RECURSIVE);\n\tDIFF_OPT_CLR(&opts, RENAME_EMPTY);\n\topts.detect_rename = DIFF_DETECT_RENAME;\n\topts.rename_limit = o->merge_rename_limit >= 0 ? o->merge_rename_limit :\n\t\t\t    o->diff_rename_limit >= 0 ? o->diff_rename_limit :\n\t\t\t    1000;\n\topts.rename_score = o->rename_score;\n\topts.show_rename_progress = o->show_rename_progress;\n\topts.output_format = DIFF_FORMAT_NO_OUTPUT;\n\tdiff_setup_done(&opts);\n\tdiff_tree_sha1(o_tree->object.oid.hash, tree->object.oid.hash, \"\", &opts);\n\tdiffcore_std(&opts);\n\tif (opts.needed_rename_limit > o->needed_rename_limit)\n\t\to->needed_rename_limit = opts.needed_rename_limit;\n\tfor (i = 0; i < diff_queued_diff.nr; ++i) {\n\t\tstruct string_list_item *item;\n\t\tstruct rename *re;\n\t\tstruct diff_filepair *pair = diff_queued_diff.queue[i];\n\t\tif (pair->status != 'R') {\n\t\t\tdiff_free_filepair(pair);\n\t\t\tcontinue;\n\t\t}\n\t\tre = xmalloc(sizeof(*re));\n\t\tre->processed = 0;\n\t\tre->pair = pair;\n\t\titem = string_list_lookup(entries, re->pair->one->path);\n\t\tif (!item)\n\t\t\tre->src_entry = insert_stage_data(re->pair->one->path,\n\t\t\t\t\to_tree, a_tree, b_tree, entries);\n\t\telse\n\t\t\tre->src_entry = item->util;\n\n\t\titem = string_list_lookup(entries, re->pair->two->path);\n\t\tif (!item)\n\t\t\tre->dst_entry = insert_stage_data(re->pair->two->path,\n\t\t\t\t\to_tree, a_tree, b_tree, entries);\n\t\telse\n\t\t\tre->dst_entry = item->util;\n\t\titem = string_list_insert(renames, pair->one->path);\n\t\titem->util = re;\n\t}\n\topts.output_format = DIFF_FORMAT_NO_OUTPUT;\n\tdiff_queued_diff.nr = 0;\n\tdiff_flush(&opts);\n\treturn renames;\n}\n\nstatic int update_stages(struct merge_options *opt, const char *path,\n\t\t\t const struct diff_filespec *o,\n\t\t\t const struct diff_filespec *a,\n\t\t\t const struct diff_filespec *b)\n{\n\n\t/*\n\t * NOTE: It is usually a bad idea to call update_stages on a path\n\t * before calling update_file on that same path, since it can\n\t * sometimes lead to spurious \"refusing to lose untracked file...\"\n\t * messages from update_file (via make_room_for path via\n\t * would_lose_untracked).  Instead, reverse the order of the calls\n\t * (executing update_file first and then update_stages).\n\t */\n\tint clear = 1;\n\tint options = ADD_CACHE_OK_TO_ADD | ADD_CACHE_SKIP_DFCHECK;\n\tif (clear)\n\t\tif (remove_file_from_cache(path))\n\t\t\treturn -1;\n\tif (o)\n\t\tif (add_cacheinfo(opt, o->mode, &o->oid, path, 1, 0, options))\n\t\t\treturn -1;\n\tif (a)\n\t\tif (add_cacheinfo(opt, a->mode, &a->oid, path, 2, 0, options))\n\t\t\treturn -1;\n\tif (b)\n\t\tif (add_cacheinfo(opt, b->mode, &b->oid, path, 3, 0, options))\n\t\t\treturn -1;\n\treturn 0;\n}\n\nstatic void update_entry(struct stage_data *entry,\n\t\t\t struct diff_filespec *o,\n\t\t\t struct diff_filespec *a,\n\t\t\t struct diff_filespec *b)\n{\n\tentry->processed = 0;\n\tentry->stages[1].mode = o->mode;\n\tentry->stages[2].mode = a->mode;\n\tentry->stages[3].mode = b->mode;\n\toidcpy(&entry->stages[1].oid, &o->oid);\n\toidcpy(&entry->stages[2].oid, &a->oid);\n\toidcpy(&entry->stages[3].oid, &b->oid);\n}\n\nstatic int remove_file(struct merge_options *o, int clean,\n\t\t       const char *path, int no_wd)\n{\n\tint update_cache = o->call_depth || clean;\n\tint update_working_directory = !o->call_depth && !no_wd;\n\n\tif (update_cache) {\n\t\tif (remove_file_from_cache(path))\n\t\t\treturn -1;\n\t}\n\tif (update_working_directory) {\n\t\tif (ignore_case) {\n\t\t\tstruct cache_entry *ce;\n\t\t\tce = cache_file_exists(path, strlen(path), ignore_case);\n\t\t\tif (ce && ce_stage(ce) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\tif (remove_path(path))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/* add a string to a strbuf, but converting \"/\" to \"_\" */\nstatic void add_flattened_path(struct strbuf *out, const char *s)\n{\n\tsize_t i = out->len;\n\tstrbuf_addstr(out, s);\n\tfor (; i < out->len; i++)\n\t\tif (out->buf[i] == '/')\n\t\t\tout->buf[i] = '_';\n}\n\nstatic char *unique_path(struct merge_options *o, const char *path, const char *branch)\n{\n\tstruct strbuf newpath = STRBUF_INIT;\n\tint suffix = 0;\n\tsize_t base_len;\n\n\tstrbuf_addf(&newpath, \"%s~\", path);\n\tadd_flattened_path(&newpath, branch);\n\n\tbase_len = newpath.len;\n\twhile (string_list_has_string(&o->current_file_set, newpath.buf) ||\n\t       string_list_has_string(&o->current_directory_set, newpath.buf) ||\n\t       (!o->call_depth && file_exists(newpath.buf))) {\n\t\tstrbuf_setlen(&newpath, base_len);\n\t\tstrbuf_addf(&newpath, \"_%d\", suffix++);\n\t}\n\n\tstring_list_insert(&o->current_file_set, newpath.buf);\n\treturn strbuf_detach(&newpath, NULL);\n}\n\n/**\n * Check whether a directory in the index is in the way of an incoming\n * file.  Return 1 if so.  If check_working_copy is non-zero, also\n * check the working directory.  If empty_ok is non-zero, also return\n * 0 in the case where the working-tree dir exists but is empty.\n */\nstatic int dir_in_way(const char *path, int check_working_copy, int empty_ok)\n{\n\tint pos;\n\tstruct strbuf dirpath = STRBUF_INIT;\n\tstruct stat st;\n\n\tstrbuf_addstr(&dirpath, path);\n\tstrbuf_addch(&dirpath, '/');\n\n\tpos = cache_name_pos(dirpath.buf, dirpath.len);\n\n\tif (pos < 0)\n\t\tpos = -1 - pos;\n\tif (pos < active_nr &&\n\t    !strncmp(dirpath.buf, active_cache[pos]->name, dirpath.len)) {\n\t\tstrbuf_release(&dirpath);\n\t\treturn 1;\n\t}\n\n\tstrbuf_release(&dirpath);\n\treturn check_working_copy && !lstat(path, &st) && S_ISDIR(st.st_mode) &&\n\t\t!(empty_ok && is_empty_dir(path));\n}\n\nstatic int was_tracked(const char *path)\n{\n\tint pos = cache_name_pos(path, strlen(path));\n\n\tif (0 <= pos)\n\t\t/* we have been tracking this path */\n\t\treturn 1;\n\n\t/*\n\t * Look for an unmerged entry for the path,\n\t * specifically stage #2, which would indicate\n\t * that \"our\" side before the merge started\n\t * had the path tracked (and resulted in a conflict).\n\t */\n\tfor (pos = -1 - pos;\n\t     pos < active_nr && !strcmp(path, active_cache[pos]->name);\n\t     pos++)\n\t\tif (ce_stage(active_cache[pos]) == 2)\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic int would_lose_untracked(const char *path)\n{\n\treturn !was_tracked(path) && file_exists(path);\n}\n\nstatic int make_room_for_path(struct merge_options *o, const char *path)\n{\n\tint status, i;\n\tconst char *msg = _(\"failed to create path '%s'%s\");\n\n\t/* Unlink any D/F conflict files that are in the way */\n\tfor (i = 0; i < o->df_conflict_file_set.nr; i++) {\n\t\tconst char *df_path = o->df_conflict_file_set.items[i].string;\n\t\tsize_t pathlen = strlen(path);\n\t\tsize_t df_pathlen = strlen(df_path);\n\t\tif (df_pathlen < pathlen &&\n\t\t    path[df_pathlen] == '/' &&\n\t\t    strncmp(path, df_path, df_pathlen) == 0) {\n\t\t\toutput(o, 3,\n\t\t\t       _(\"Removing %s to make room for subdirectory\\n\"),\n\t\t\t       df_path);\n\t\t\tunlink(df_path);\n\t\t\tunsorted_string_list_delete_item(&o->df_conflict_file_set,\n\t\t\t\t\t\t\t i, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Make sure leading directories are created */\n\tstatus = safe_create_leading_directories_const(path);\n\tif (status) {\n\t\tif (status == SCLD_EXISTS)\n\t\t\t/* something else exists */\n\t\t\treturn err(o, msg, path, _(\": perhaps a D/F conflict?\"));\n\t\treturn err(o, msg, path, \"\");\n\t}\n\n\t/*\n\t * Do not unlink a file in the work tree if we are not\n\t * tracking it.\n\t */\n\tif (would_lose_untracked(path))\n\t\treturn err(o, _(\"refusing to lose untracked file at '%s'\"),\n\t\t\t     path);\n\n\t/* Successful unlink is good.. */\n\tif (!unlink(path))\n\t\treturn 0;\n\t/* .. and so is no existing file */\n\tif (errno == ENOENT)\n\t\treturn 0;\n\t/* .. but not some other error (who really cares what?) */\n\treturn err(o, msg, path, _(\": perhaps a D/F conflict?\"));\n}\n\nstatic int update_file_flags(struct merge_options *o,\n\t\t\t     const struct object_id *oid,\n\t\t\t     unsigned mode,\n\t\t\t     const char *path,\n\t\t\t     int update_cache,\n\t\t\t     int update_wd)\n{\n\tint ret = 0;\n\n\tif (o->call_depth)\n\t\tupdate_wd = 0;\n\n\tif (update_wd) {\n\t\tenum object_type type;\n\t\tvoid *buf;\n\t\tunsigned long size;\n\n\t\tif (S_ISGITLINK(mode)) {\n\t\t\t/*\n\t\t\t * We may later decide to recursively descend into\n\t\t\t * the submodule directory and update its index\n\t\t\t * and/or work tree, but we do not do that now.\n\t\t\t */\n\t\t\tupdate_wd = 0;\n\t\t\tgoto update_index;\n\t\t}\n\n\t\tbuf = read_sha1_file(oid->hash, &type, &size);\n\t\tif (!buf)\n\t\t\treturn err(o, _(\"cannot read object %s '%s'\"), oid_to_hex(oid), path);\n\t\tif (type != OBJ_BLOB) {\n\t\t\tret = err(o, _(\"blob expected for %s '%s'\"), oid_to_hex(oid), path);\n\t\t\tgoto free_buf;\n\t\t}\n\t\tif (S_ISREG(mode)) {\n\t\t\tstruct strbuf strbuf = STRBUF_INIT;\n\t\t\tif (convert_to_working_tree(path, buf, size, &strbuf)) {\n\t\t\t\tfree(buf);\n\t\t\t\tsize = strbuf.len;\n\t\t\t\tbuf = strbuf_detach(&strbuf, NULL);\n\t\t\t}\n\t\t}\n\n\t\tif (make_room_for_path(o, path) < 0) {\n\t\t\tupdate_wd = 0;\n\t\t\tgoto free_buf;\n\t\t}\n\t\tif (S_ISREG(mode) || (!has_symlinks && S_ISLNK(mode))) {\n\t\t\tint fd;\n\t\t\tif (mode & 0100)\n\t\t\t\tmode = 0777;\n\t\t\telse\n\t\t\t\tmode = 0666;\n\t\t\tfd = open(path, O_WRONLY | O_TRUNC | O_CREAT, mode);\n\t\t\tif (fd < 0) {\n\t\t\t\tret = err(o, _(\"failed to open '%s': %s\"),\n\t\t\t\t\t  path, strerror(errno));\n\t\t\t\tgoto free_buf;\n\t\t\t}\n\t\t\twrite_in_full(fd, buf, size);\n\t\t\tclose(fd);\n\t\t} else if (S_ISLNK(mode)) {\n\t\t\tchar *lnk = xmemdupz(buf, size);\n\t\t\tsafe_create_leading_directories_const(path);\n\t\t\tunlink(path);\n\t\t\tif (symlink(lnk, path))\n\t\t\t\tret = err(o, _(\"failed to symlink '%s': %s\"),\n\t\t\t\t\tpath, strerror(errno));\n\t\t\tfree(lnk);\n\t\t} else\n\t\t\tret = err(o,\n\t\t\t\t  _(\"do not know what to do with %06o %s '%s'\"),\n\t\t\t\t  mode, oid_to_hex(oid), path);\n free_buf:\n\t\tfree(buf);\n\t}\n update_index:\n\tif (!ret && update_cache)\n\t\tadd_cacheinfo(o, mode, oid, path, 0, update_wd, ADD_CACHE_OK_TO_ADD);\n\treturn ret;\n}\n\nstatic int update_file(struct merge_options *o,\n\t\t       int clean,\n\t\t       const struct object_id *oid,\n\t\t       unsigned mode,\n\t\t       const char *path)\n{\n\treturn update_file_flags(o, oid, mode, path, o->call_depth || clean, !o->call_depth);\n}\n\n/* Low level file merging, update and removal */\n\nstruct merge_file_info {\n\tstruct object_id oid;\n\tunsigned mode;\n\tunsigned clean:1,\n\t\t merge:1;\n};\n\nstatic int merge_3way(struct merge_options *o,\n\t\t      mmbuffer_t *result_buf,\n\t\t      const struct diff_filespec *one,\n\t\t      const struct diff_filespec *a,\n\t\t      const struct diff_filespec *b,\n\t\t      const char *branch1,\n\t\t      const char *branch2)\n{\n\tmmfile_t orig, src1, src2;\n\tstruct ll_merge_options ll_opts = {0};\n\tchar *base_name, *name1, *name2;\n\tint merge_status;\n\n\tll_opts.renormalize = o->renormalize;\n\tll_opts.xdl_opts = o->xdl_opts;\n\n\tif (o->call_depth) {\n\t\tll_opts.virtual_ancestor = 1;\n\t\tll_opts.variant = 0;\n\t} else {\n\t\tswitch (o->recursive_variant) {\n\t\tcase MERGE_RECURSIVE_OURS:\n\t\t\tll_opts.variant = XDL_MERGE_FAVOR_OURS;\n\t\t\tbreak;\n\t\tcase MERGE_RECURSIVE_THEIRS:\n\t\t\tll_opts.variant = XDL_MERGE_FAVOR_THEIRS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tll_opts.variant = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (strcmp(a->path, b->path) ||\n\t    (o->ancestor != NULL && strcmp(a->path, one->path) != 0)) {\n\t\tbase_name = o->ancestor == NULL ? NULL :\n\t\t\tmkpathdup(\"%s:%s\", o->ancestor, one->path);\n\t\tname1 = mkpathdup(\"%s:%s\", branch1, a->path);\n\t\tname2 = mkpathdup(\"%s:%s\", branch2, b->path);\n\t} else {\n\t\tbase_name = o->ancestor == NULL ? NULL :\n\t\t\tmkpathdup(\"%s\", o->ancestor);\n\t\tname1 = mkpathdup(\"%s\", branch1);\n\t\tname2 = mkpathdup(\"%s\", branch2);\n\t}\n\n\tread_mmblob(&orig, &one->oid);\n\tread_mmblob(&src1, &a->oid);\n\tread_mmblob(&src2, &b->oid);\n\n\tmerge_status = ll_merge(result_buf, a->path, &orig, base_name,\n\t\t\t\t&src1, name1, &src2, name2, &ll_opts);\n\n\tfree(base_name);\n\tfree(name1);\n\tfree(name2);\n\tfree(orig.ptr);\n\tfree(src1.ptr);\n\tfree(src2.ptr);\n\treturn merge_status;\n}\n\nstatic int merge_file_1(struct merge_options *o,\n\t\t\t\t\t   const struct diff_filespec *one,\n\t\t\t\t\t   const struct diff_filespec *a,\n\t\t\t\t\t   const struct diff_filespec *b,\n\t\t\t\t\t   const char *branch1,\n\t\t\t\t\t   const char *branch2,\n\t\t\t\t\t   struct merge_file_info *result)\n{\n\tresult->merge = 0;\n\tresult->clean = 1;\n\n\tif ((S_IFMT & a->mode) != (S_IFMT & b->mode)) {\n\t\tresult->clean = 0;\n\t\tif (S_ISREG(a->mode)) {\n\t\t\tresult->mode = a->mode;\n\t\t\toidcpy(&result->oid, &a->oid);\n\t\t} else {\n\t\t\tresult->mode = b->mode;\n\t\t\toidcpy(&result->oid, &b->oid);\n\t\t}\n\t} else {\n\t\tif (!oid_eq(&a->oid, &one->oid) && !oid_eq(&b->oid, &one->oid))\n\t\t\tresult->merge = 1;\n\n\t\t/*\n\t\t * Merge modes\n\t\t */\n\t\tif (a->mode == b->mode || a->mode == one->mode)\n\t\t\tresult->mode = b->mode;\n\t\telse {\n\t\t\tresult->mode = a->mode;\n\t\t\tif (b->mode != one->mode) {\n\t\t\t\tresult->clean = 0;\n\t\t\t\tresult->merge = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (oid_eq(&a->oid, &b->oid) || oid_eq(&a->oid, &one->oid))\n\t\t\toidcpy(&result->oid, &b->oid);\n\t\telse if (oid_eq(&b->oid, &one->oid))\n\t\t\toidcpy(&result->oid, &a->oid);\n\t\telse if (S_ISREG(a->mode)) {\n\t\t\tmmbuffer_t result_buf;\n\t\t\tint ret = 0, merge_status;\n\n\t\t\tmerge_status = merge_3way(o, &result_buf, one, a, b,\n\t\t\t\t\t\t  branch1, branch2);\n\n\t\t\tif ((merge_status < 0) || !result_buf.ptr)\n\t\t\t\tret = err(o, _(\"Failed to execute internal merge\"));\n\n\t\t\tif (!ret && write_sha1_file(result_buf.ptr, result_buf.size,\n\t\t\t\t\t\t    blob_type, result->oid.hash))\n\t\t\t\tret = err(o, _(\"Unable to add %s to database\"),\n\t\t\t\t\t  a->path);\n\n\t\t\tfree(result_buf.ptr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tresult->clean = (merge_status == 0);\n\t\t} else if (S_ISGITLINK(a->mode)) {\n\t\t\tresult->clean = merge_submodule(result->oid.hash,\n\t\t\t\t\t\t       one->path,\n\t\t\t\t\t\t       one->oid.hash,\n\t\t\t\t\t\t       a->oid.hash,\n\t\t\t\t\t\t       b->oid.hash,\n\t\t\t\t\t\t       !o->call_depth);\n\t\t} else if (S_ISLNK(a->mode)) {\n\t\t\toidcpy(&result->oid, &a->oid);\n\n\t\t\tif (!oid_eq(&a->oid, &b->oid))\n\t\t\t\tresult->clean = 0;\n\t\t} else\n\t\t\tdie(\"BUG: unsupported object type in the tree\");\n\t}\n\n\treturn 0;\n}\n\nstatic int merge_file_special_markers(struct merge_options *o,\n\t\t\t   const struct diff_filespec *one,\n\t\t\t   const struct diff_filespec *a,\n\t\t\t   const struct diff_filespec *b,\n\t\t\t   const char *branch1,\n\t\t\t   const char *filename1,\n\t\t\t   const char *branch2,\n\t\t\t   const char *filename2,\n\t\t\t   struct merge_file_info *mfi)\n{\n\tchar *side1 = NULL;\n\tchar *side2 = NULL;\n\tint ret;\n\n\tif (filename1)\n\t\tside1 = xstrfmt(\"%s:%s\", branch1, filename1);\n\tif (filename2)\n\t\tside2 = xstrfmt(\"%s:%s\", branch2, filename2);\n\n\tret = merge_file_1(o, one, a, b,\n\t\t\t   side1 ? side1 : branch1,\n\t\t\t   side2 ? side2 : branch2, mfi);\n\tfree(side1);\n\tfree(side2);\n\treturn ret;\n}\n\nstatic int merge_file_one(struct merge_options *o,\n\t\t\t\t\t const char *path,\n\t\t\t\t\t const struct object_id *o_oid, int o_mode,\n\t\t\t\t\t const struct object_id *a_oid, int a_mode,\n\t\t\t\t\t const struct object_id *b_oid, int b_mode,\n\t\t\t\t\t const char *branch1,\n\t\t\t\t\t const char *branch2,\n\t\t\t\t\t struct merge_file_info *mfi)\n{\n\tstruct diff_filespec one, a, b;\n\n\tone.path = a.path = b.path = (char *)path;\n\toidcpy(&one.oid, o_oid);\n\tone.mode = o_mode;\n\toidcpy(&a.oid, a_oid);\n\ta.mode = a_mode;\n\toidcpy(&b.oid, b_oid);\n\tb.mode = b_mode;\n\treturn merge_file_1(o, &one, &a, &b, branch1, branch2, mfi);\n}\n\nstatic int handle_change_delete(struct merge_options *o,\n\t\t\t\t const char *path, const char *old_path,\n\t\t\t\t const struct object_id *o_oid, int o_mode,\n\t\t\t\t const struct object_id *changed_oid,\n\t\t\t\t int changed_mode,\n\t\t\t\t const char *change_branch,\n\t\t\t\t const char *delete_branch,\n\t\t\t\t const char *change, const char *change_past)\n{\n\tchar *alt_path = NULL;\n\tconst char *update_path = path;\n\tint ret = 0;\n\n\tif (dir_in_way(path, !o->call_depth, 0)) {\n\t\tupdate_path = alt_path = unique_path(o, path, change_branch);\n\t}\n\n\tif (o->call_depth) {\n\t\t/*\n\t\t * We cannot arbitrarily accept either a_sha or b_sha as\n\t\t * correct; since there is no true \"middle point\" between\n\t\t * them, simply reuse the base version for virtual merge base.\n\t\t */\n\t\tret = remove_file_from_cache(path);\n\t\tif (!ret)\n\t\t\tret = update_file(o, 0, o_oid, o_mode, update_path);\n\t} else {\n\t\tif (!alt_path) {\n\t\t\tif (!old_path) {\n\t\t\t\toutput(o, 1, _(\"CONFLICT (%s/delete): %s deleted in %s \"\n\t\t\t\t       \"and %s in %s. Version %s of %s left in tree.\"),\n\t\t\t\t       change, path, delete_branch, change_past,\n\t\t\t\t       change_branch, change_branch, path);\n\t\t\t} else {\n\t\t\t\toutput(o, 1, _(\"CONFLICT (%s/delete): %s deleted in %s \"\n\t\t\t\t       \"and %s to %s in %s. Version %s of %s left in tree.\"),\n\t\t\t\t       change, old_path, delete_branch, change_past, path,\n\t\t\t\t       change_branch, change_branch, path);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!old_path) {\n\t\t\t\toutput(o, 1, _(\"CONFLICT (%s/delete): %s deleted in %s \"\n\t\t\t\t       \"and %s in %s. Version %s of %s left in tree at %s.\"),\n\t\t\t\t       change, path, delete_branch, change_past,\n\t\t\t\t       change_branch, change_branch, path, alt_path);\n\t\t\t} else {\n\t\t\t\toutput(o, 1, _(\"CONFLICT (%s/delete): %s deleted in %s \"\n\t\t\t\t       \"and %s to %s in %s. Version %s of %s left in tree at %s.\"),\n\t\t\t\t       change, old_path, delete_branch, change_past, path,\n\t\t\t\t       change_branch, change_branch, path, alt_path);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * No need to call update_file() on path when change_branch ==\n\t\t * o->branch1 && !alt_path, since that would needlessly touch\n\t\t * path.  We could call update_file_flags() with update_cache=0\n\t\t * and update_wd=0, but that's a no-op.\n\t\t */\n\t\tif (change_branch != o->branch1 || alt_path)\n\t\t\tret = update_file(o, 0, changed_oid, changed_mode, update_path);\n\t}\n\tfree(alt_path);\n\n\treturn ret;\n}\n\nstatic int conflict_rename_delete(struct merge_options *o,\n\t\t\t\t   struct diff_filepair *pair,\n\t\t\t\t   const char *rename_branch,\n\t\t\t\t   const char *delete_branch)\n{\n\tconst struct diff_filespec *orig = pair->one;\n\tconst struct diff_filespec *dest = pair->two;\n\n\tif (handle_change_delete(o,\n\t\t\t\t o->call_depth ? orig->path : dest->path,\n\t\t\t\t o->call_depth ? NULL : orig->path,\n\t\t\t\t &orig->oid, orig->mode,\n\t\t\t\t &dest->oid, dest->mode,\n\t\t\t\t rename_branch, delete_branch,\n\t\t\t\t _(\"rename\"), _(\"renamed\")))\n\t\treturn -1;\n\n\tif (o->call_depth)\n\t\treturn remove_file_from_cache(dest->path);\n\telse\n\t\treturn update_stages(o, dest->path, NULL,\n\t\t\t\t     rename_branch == o->branch1 ? dest : NULL,\n\t\t\t\t     rename_branch == o->branch1 ? NULL : dest);\n}\n\nstatic struct diff_filespec *filespec_from_entry(struct diff_filespec *target,\n\t\t\t\t\t\t struct stage_data *entry,\n\t\t\t\t\t\t int stage)\n{\n\tstruct object_id *oid = &entry->stages[stage].oid;\n\tunsigned mode = entry->stages[stage].mode;\n\tif (mode == 0 || is_null_oid(oid))\n\t\treturn NULL;\n\toidcpy(&target->oid, oid);\n\ttarget->mode = mode;\n\treturn target;\n}\n\nstatic int handle_file(struct merge_options *o,\n\t\t\tstruct diff_filespec *rename,\n\t\t\tint stage,\n\t\t\tstruct rename_conflict_info *ci)\n{\n\tchar *dst_name = rename->path;\n\tstruct stage_data *dst_entry;\n\tconst char *cur_branch, *other_branch;\n\tstruct diff_filespec other;\n\tstruct diff_filespec *add;\n\tint ret;\n\n\tif (stage == 2) {\n\t\tdst_entry = ci->dst_entry1;\n\t\tcur_branch = ci->branch1;\n\t\tother_branch = ci->branch2;\n\t} else {\n\t\tdst_entry = ci->dst_entry2;\n\t\tcur_branch = ci->branch2;\n\t\tother_branch = ci->branch1;\n\t}\n\n\tadd = filespec_from_entry(&other, dst_entry, stage ^ 1);\n\tif (add) {\n\t\tchar *add_name = unique_path(o, rename->path, other_branch);\n\t\tif (update_file(o, 0, &add->oid, add->mode, add_name))\n\t\t\treturn -1;\n\n\t\tremove_file(o, 0, rename->path, 0);\n\t\tdst_name = unique_path(o, rename->path, cur_branch);\n\t} else {\n\t\tif (dir_in_way(rename->path, !o->call_depth, 0)) {\n\t\t\tdst_name = unique_path(o, rename->path, cur_branch);\n\t\t\toutput(o, 1, _(\"%s is a directory in %s adding as %s instead\"),\n\t\t\t       rename->path, other_branch, dst_name);\n\t\t}\n\t}\n\tif ((ret = update_file(o, 0, &rename->oid, rename->mode, dst_name)))\n\t\t; /* fall through, do allow dst_name to be released */\n\telse if (stage == 2)\n\t\tret = update_stages(o, rename->path, NULL, rename, add);\n\telse\n\t\tret = update_stages(o, rename->path, NULL, add, rename);\n\n\tif (dst_name != rename->path)\n\t\tfree(dst_name);\n\n\treturn ret;\n}\n\nstatic int conflict_rename_rename_1to2(struct merge_options *o,\n\t\t\t\t\tstruct rename_conflict_info *ci)\n{\n\t/* One file was renamed in both branches, but to different names. */\n\tstruct diff_filespec *one = ci->pair1->one;\n\tstruct diff_filespec *a = ci->pair1->two;\n\tstruct diff_filespec *b = ci->pair2->two;\n\n\toutput(o, 1, _(\"CONFLICT (rename/rename): \"\n\t       \"Rename \\\"%s\\\"->\\\"%s\\\" in branch \\\"%s\\\" \"\n\t       \"rename \\\"%s\\\"->\\\"%s\\\" in \\\"%s\\\"%s\"),\n\t       one->path, a->path, ci->branch1,\n\t       one->path, b->path, ci->branch2,\n\t       o->call_depth ? _(\" (left unresolved)\") : \"\");\n\tif (o->call_depth) {\n\t\tstruct merge_file_info mfi;\n\t\tstruct diff_filespec other;\n\t\tstruct diff_filespec *add;\n\t\tif (merge_file_one(o, one->path,\n\t\t\t\t &one->oid, one->mode,\n\t\t\t\t &a->oid, a->mode,\n\t\t\t\t &b->oid, b->mode,\n\t\t\t\t ci->branch1, ci->branch2, &mfi))\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * FIXME: For rename/add-source conflicts (if we could detect\n\t\t * such), this is wrong.  We should instead find a unique\n\t\t * pathname and then either rename the add-source file to that\n\t\t * unique path, or use that unique path instead of src here.\n\t\t */\n\t\tif (update_file(o, 0, &mfi.oid, mfi.mode, one->path))\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Above, we put the merged content at the merge-base's\n\t\t * path.  Now we usually need to delete both a->path and\n\t\t * b->path.  However, the rename on each side of the merge\n\t\t * could also be involved in a rename/add conflict.  In\n\t\t * such cases, we should keep the added file around,\n\t\t * resolving the conflict at that path in its favor.\n\t\t */\n\t\tadd = filespec_from_entry(&other, ci->dst_entry1, 2 ^ 1);\n\t\tif (add) {\n\t\t\tif (update_file(o, 0, &add->oid, add->mode, a->path))\n\t\t\t\treturn -1;\n\t\t}\n\t\telse\n\t\t\tremove_file_from_cache(a->path);\n\t\tadd = filespec_from_entry(&other, ci->dst_entry2, 3 ^ 1);\n\t\tif (add) {\n\t\t\tif (update_file(o, 0, &add->oid, add->mode, b->path))\n\t\t\t\treturn -1;\n\t\t}\n\t\telse\n\t\t\tremove_file_from_cache(b->path);\n\t} else if (handle_file(o, a, 2, ci) || handle_file(o, b, 3, ci))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int conflict_rename_rename_2to1(struct merge_options *o,\n\t\t\t\t\tstruct rename_conflict_info *ci)\n{\n\t/* Two files, a & b, were renamed to the same thing, c. */\n\tstruct diff_filespec *a = ci->pair1->one;\n\tstruct diff_filespec *b = ci->pair2->one;\n\tstruct diff_filespec *c1 = ci->pair1->two;\n\tstruct diff_filespec *c2 = ci->pair2->two;\n\tchar *path = c1->path; /* == c2->path */\n\tstruct merge_file_info mfi_c1;\n\tstruct merge_file_info mfi_c2;\n\tint ret;\n\n\toutput(o, 1, _(\"CONFLICT (rename/rename): \"\n\t       \"Rename %s->%s in %s. \"\n\t       \"Rename %s->%s in %s\"),\n\t       a->path, c1->path, ci->branch1,\n\t       b->path, c2->path, ci->branch2);\n\n\tremove_file(o, 1, a->path, o->call_depth || would_lose_untracked(a->path));\n\tremove_file(o, 1, b->path, o->call_depth || would_lose_untracked(b->path));\n\n\tif (merge_file_special_markers(o, a, c1, &ci->ren1_other,\n\t\t\t\t       o->branch1, c1->path,\n\t\t\t\t       o->branch2, ci->ren1_other.path, &mfi_c1) ||\n\t    merge_file_special_markers(o, b, &ci->ren2_other, c2,\n\t\t\t\t       o->branch1, ci->ren2_other.path,\n\t\t\t\t       o->branch2, c2->path, &mfi_c2))\n\t\treturn -1;\n\n\tif (o->call_depth) {\n\t\t/*\n\t\t * If mfi_c1.clean && mfi_c2.clean, then it might make\n\t\t * sense to do a two-way merge of those results.  But, I\n\t\t * think in all cases, it makes sense to have the virtual\n\t\t * merge base just undo the renames; they can be detected\n\t\t * again later for the non-recursive merge.\n\t\t */\n\t\tremove_file(o, 0, path, 0);\n\t\tret = update_file(o, 0, &mfi_c1.oid, mfi_c1.mode, a->path);\n\t\tif (!ret)\n\t\t\tret = update_file(o, 0, &mfi_c2.oid, mfi_c2.mode,\n\t\t\t\t\t  b->path);\n\t} else {\n\t\tchar *new_path1 = unique_path(o, path, ci->branch1);\n\t\tchar *new_path2 = unique_path(o, path, ci->branch2);\n\t\toutput(o, 1, _(\"Renaming %s to %s and %s to %s instead\"),\n\t\t       a->path, new_path1, b->path, new_path2);\n\t\tremove_file(o, 0, path, 0);\n\t\tret = update_file(o, 0, &mfi_c1.oid, mfi_c1.mode, new_path1);\n\t\tif (!ret)\n\t\t\tret = update_file(o, 0, &mfi_c2.oid, mfi_c2.mode,\n\t\t\t\t\t  new_path2);\n\t\tfree(new_path2);\n\t\tfree(new_path1);\n\t}\n\n\treturn ret;\n}\n\nstatic int process_renames(struct merge_options *o,\n\t\t\t   struct string_list *a_renames,\n\t\t\t   struct string_list *b_renames)\n{\n\tint clean_merge = 1, i, j;\n\tstruct string_list a_by_dst = STRING_LIST_INIT_NODUP;\n\tstruct string_list b_by_dst = STRING_LIST_INIT_NODUP;\n\tconst struct rename *sre;\n\n\tfor (i = 0; i < a_renames->nr; i++) {\n\t\tsre = a_renames->items[i].util;\n\t\tstring_list_insert(&a_by_dst, sre->pair->two->path)->util\n\t\t\t= (void *)sre;\n\t}\n\tfor (i = 0; i < b_renames->nr; i++) {\n\t\tsre = b_renames->items[i].util;\n\t\tstring_list_insert(&b_by_dst, sre->pair->two->path)->util\n\t\t\t= (void *)sre;\n\t}\n\n\tfor (i = 0, j = 0; i < a_renames->nr || j < b_renames->nr;) {\n\t\tstruct string_list *renames1, *renames2Dst;\n\t\tstruct rename *ren1 = NULL, *ren2 = NULL;\n\t\tconst char *branch1, *branch2;\n\t\tconst char *ren1_src, *ren1_dst;\n\t\tstruct string_list_item *lookup;\n\n\t\tif (i >= a_renames->nr) {\n\t\t\tren2 = b_renames->items[j++].util;\n\t\t} else if (j >= b_renames->nr) {\n\t\t\tren1 = a_renames->items[i++].util;\n\t\t} else {\n\t\t\tint compare = strcmp(a_renames->items[i].string,\n\t\t\t\t\t     b_renames->items[j].string);\n\t\t\tif (compare <= 0)\n\t\t\t\tren1 = a_renames->items[i++].util;\n\t\t\tif (compare >= 0)\n\t\t\t\tren2 = b_renames->items[j++].util;\n\t\t}\n\n\t\t/* TODO: refactor, so that 1/2 are not needed */\n\t\tif (ren1) {\n\t\t\trenames1 = a_renames;\n\t\t\trenames2Dst = &b_by_dst;\n\t\t\tbranch1 = o->branch1;\n\t\t\tbranch2 = o->branch2;\n\t\t} else {\n\t\t\trenames1 = b_renames;\n\t\t\trenames2Dst = &a_by_dst;\n\t\t\tbranch1 = o->branch2;\n\t\t\tbranch2 = o->branch1;\n\t\t\tSWAP(ren2, ren1);\n\t\t}\n\n\t\tif (ren1->processed)\n\t\t\tcontinue;\n\t\tren1->processed = 1;\n\t\tren1->dst_entry->processed = 1;\n\t\t/* BUG: We should only mark src_entry as processed if we\n\t\t * are not dealing with a rename + add-source case.\n\t\t */\n\t\tren1->src_entry->processed = 1;\n\n\t\tren1_src = ren1->pair->one->path;\n\t\tren1_dst = ren1->pair->two->path;\n\n\t\tif (ren2) {\n\t\t\t/* One file renamed on both sides */\n\t\t\tconst char *ren2_src = ren2->pair->one->path;\n\t\t\tconst char *ren2_dst = ren2->pair->two->path;\n\t\t\tenum rename_type rename_type;\n\t\t\tif (strcmp(ren1_src, ren2_src) != 0)\n\t\t\t\tdie(\"BUG: ren1_src != ren2_src\");\n\t\t\tren2->dst_entry->processed = 1;\n\t\t\tren2->processed = 1;\n\t\t\tif (strcmp(ren1_dst, ren2_dst) != 0) {\n\t\t\t\trename_type = RENAME_ONE_FILE_TO_TWO;\n\t\t\t\tclean_merge = 0;\n\t\t\t} else {\n\t\t\t\trename_type = RENAME_ONE_FILE_TO_ONE;\n\t\t\t\t/* BUG: We should only remove ren1_src in\n\t\t\t\t * the base stage (think of rename +\n\t\t\t\t * add-source cases).\n\t\t\t\t */\n\t\t\t\tremove_file(o, 1, ren1_src, 1);\n\t\t\t\tupdate_entry(ren1->dst_entry,\n\t\t\t\t\t     ren1->pair->one,\n\t\t\t\t\t     ren1->pair->two,\n\t\t\t\t\t     ren2->pair->two);\n\t\t\t}\n\t\t\tsetup_rename_conflict_info(rename_type,\n\t\t\t\t\t\t   ren1->pair,\n\t\t\t\t\t\t   ren2->pair,\n\t\t\t\t\t\t   branch1,\n\t\t\t\t\t\t   branch2,\n\t\t\t\t\t\t   ren1->dst_entry,\n\t\t\t\t\t\t   ren2->dst_entry,\n\t\t\t\t\t\t   o,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   NULL);\n\t\t} else if ((lookup = string_list_lookup(renames2Dst, ren1_dst))) {\n\t\t\t/* Two different files renamed to the same thing */\n\t\t\tchar *ren2_dst;\n\t\t\tren2 = lookup->util;\n\t\t\tren2_dst = ren2->pair->two->path;\n\t\t\tif (strcmp(ren1_dst, ren2_dst) != 0)\n\t\t\t\tdie(\"BUG: ren1_dst != ren2_dst\");\n\n\t\t\tclean_merge = 0;\n\t\t\tren2->processed = 1;\n\t\t\t/*\n\t\t\t * BUG: We should only mark src_entry as processed\n\t\t\t * if we are not dealing with a rename + add-source\n\t\t\t * case.\n\t\t\t */\n\t\t\tren2->src_entry->processed = 1;\n\n\t\t\tsetup_rename_conflict_info(RENAME_TWO_FILES_TO_ONE,\n\t\t\t\t\t\t   ren1->pair,\n\t\t\t\t\t\t   ren2->pair,\n\t\t\t\t\t\t   branch1,\n\t\t\t\t\t\t   branch2,\n\t\t\t\t\t\t   ren1->dst_entry,\n\t\t\t\t\t\t   ren2->dst_entry,\n\t\t\t\t\t\t   o,\n\t\t\t\t\t\t   ren1->src_entry,\n\t\t\t\t\t\t   ren2->src_entry);\n\n\t\t} else {\n\t\t\t/* Renamed in 1, maybe changed in 2 */\n\t\t\t/* we only use sha1 and mode of these */\n\t\t\tstruct diff_filespec src_other, dst_other;\n\t\t\tint try_merge;\n\n\t\t\t/*\n\t\t\t * unpack_trees loads entries from common-commit\n\t\t\t * into stage 1, from head-commit into stage 2, and\n\t\t\t * from merge-commit into stage 3.  We keep track\n\t\t\t * of which side corresponds to the rename.\n\t\t\t */\n\t\t\tint renamed_stage = a_renames == renames1 ? 2 : 3;\n\t\t\tint other_stage =   a_renames == renames1 ? 3 : 2;\n\n\t\t\t/* BUG: We should only remove ren1_src in the base\n\t\t\t * stage and in other_stage (think of rename +\n\t\t\t * add-source case).\n\t\t\t */\n\t\t\tremove_file(o, 1, ren1_src,\n\t\t\t\t    renamed_stage == 2 || !was_tracked(ren1_src));\n\n\t\t\toidcpy(&src_other.oid,\n\t\t\t       &ren1->src_entry->stages[other_stage].oid);\n\t\t\tsrc_other.mode = ren1->src_entry->stages[other_stage].mode;\n\t\t\toidcpy(&dst_other.oid,\n\t\t\t       &ren1->dst_entry->stages[other_stage].oid);\n\t\t\tdst_other.mode = ren1->dst_entry->stages[other_stage].mode;\n\t\t\ttry_merge = 0;\n\n\t\t\tif (oid_eq(&src_other.oid, &null_oid)) {\n\t\t\t\tsetup_rename_conflict_info(RENAME_DELETE,\n\t\t\t\t\t\t\t   ren1->pair,\n\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t   branch1,\n\t\t\t\t\t\t\t   branch2,\n\t\t\t\t\t\t\t   ren1->dst_entry,\n\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t   o,\n\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t   NULL);\n\t\t\t} else if ((dst_other.mode == ren1->pair->two->mode) &&\n\t\t\t\t   oid_eq(&dst_other.oid, &ren1->pair->two->oid)) {\n\t\t\t\t/*\n\t\t\t\t * Added file on the other side identical to\n\t\t\t\t * the file being renamed: clean merge.\n\t\t\t\t * Also, there is no need to overwrite the\n\t\t\t\t * file already in the working copy, so call\n\t\t\t\t * update_file_flags() instead of\n\t\t\t\t * update_file().\n\t\t\t\t */\n\t\t\t\tif (update_file_flags(o,\n\t\t\t\t\t\t      &ren1->pair->two->oid,\n\t\t\t\t\t\t      ren1->pair->two->mode,\n\t\t\t\t\t\t      ren1_dst,\n\t\t\t\t\t\t      1, /* update_cache */\n\t\t\t\t\t\t      0  /* update_wd    */))\n\t\t\t\t\tclean_merge = -1;\n\t\t\t} else if (!oid_eq(&dst_other.oid, &null_oid)) {\n\t\t\t\tclean_merge = 0;\n\t\t\t\ttry_merge = 1;\n\t\t\t\toutput(o, 1, _(\"CONFLICT (rename/add): Rename %s->%s in %s. \"\n\t\t\t\t       \"%s added in %s\"),\n\t\t\t\t       ren1_src, ren1_dst, branch1,\n\t\t\t\t       ren1_dst, branch2);\n\t\t\t\tif (o->call_depth) {\n\t\t\t\t\tstruct merge_file_info mfi;\n\t\t\t\t\tif (merge_file_one(o, ren1_dst, &null_oid, 0,\n\t\t\t\t\t\t\t   &ren1->pair->two->oid,\n\t\t\t\t\t\t\t   ren1->pair->two->mode,\n\t\t\t\t\t\t\t   &dst_other.oid,\n\t\t\t\t\t\t\t   dst_other.mode,\n\t\t\t\t\t\t\t   branch1, branch2, &mfi)) {\n\t\t\t\t\t\tclean_merge = -1;\n\t\t\t\t\t\tgoto cleanup_and_return;\n\t\t\t\t\t}\n\t\t\t\t\toutput(o, 1, _(\"Adding merged %s\"), ren1_dst);\n\t\t\t\t\tif (update_file(o, 0, &mfi.oid,\n\t\t\t\t\t\t\tmfi.mode, ren1_dst))\n\t\t\t\t\t\tclean_merge = -1;\n\t\t\t\t\ttry_merge = 0;\n\t\t\t\t} else {\n\t\t\t\t\tchar *new_path = unique_path(o, ren1_dst, branch2);\n\t\t\t\t\toutput(o, 1, _(\"Adding as %s instead\"), new_path);\n\t\t\t\t\tif (update_file(o, 0, &dst_other.oid,\n\t\t\t\t\t\t\tdst_other.mode, new_path))\n\t\t\t\t\t\tclean_merge = -1;\n\t\t\t\t\tfree(new_path);\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry_merge = 1;\n\n\t\t\tif (clean_merge < 0)\n\t\t\t\tgoto cleanup_and_return;\n\t\t\tif (try_merge) {\n\t\t\t\tstruct diff_filespec *one, *a, *b;\n\t\t\t\tsrc_other.path = (char *)ren1_src;\n\n\t\t\t\tone = ren1->pair->one;\n\t\t\t\tif (a_renames == renames1) {\n\t\t\t\t\ta = ren1->pair->two;\n\t\t\t\t\tb = &src_other;\n\t\t\t\t} else {\n\t\t\t\t\tb = ren1->pair->two;\n\t\t\t\t\ta = &src_other;\n\t\t\t\t}\n\t\t\t\tupdate_entry(ren1->dst_entry, one, a, b);\n\t\t\t\tsetup_rename_conflict_info(RENAME_NORMAL,\n\t\t\t\t\t\t\t   ren1->pair,\n\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t   branch1,\n\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t   ren1->dst_entry,\n\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t   o,\n\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t   NULL);\n\t\t\t}\n\t\t}\n\t}\ncleanup_and_return:\n\tstring_list_clear(&a_by_dst, 0);\n\tstring_list_clear(&b_by_dst, 0);\n\n\treturn clean_merge;\n}\n\nstatic struct object_id *stage_oid(const struct object_id *oid, unsigned mode)\n{\n\treturn (is_null_oid(oid) || mode == 0) ? NULL: (struct object_id *)oid;\n}\n\nstatic int read_oid_strbuf(struct merge_options *o,\n\tconst struct object_id *oid, struct strbuf *dst)\n{\n\tvoid *buf;\n\tenum object_type type;\n\tunsigned long size;\n\tbuf = read_sha1_file(oid->hash, &type, &size);\n\tif (!buf)\n\t\treturn err(o, _(\"cannot read object %s\"), oid_to_hex(oid));\n\tif (type != OBJ_BLOB) {\n\t\tfree(buf);\n\t\treturn err(o, _(\"object %s is not a blob\"), oid_to_hex(oid));\n\t}\n\tstrbuf_attach(dst, buf, size, size + 1);\n\treturn 0;\n}\n\nstatic int blob_unchanged(struct merge_options *opt,\n\t\t\t  const struct object_id *o_oid,\n\t\t\t  unsigned o_mode,\n\t\t\t  const struct object_id *a_oid,\n\t\t\t  unsigned a_mode,\n\t\t\t  int renormalize, const char *path)\n{\n\tstruct strbuf o = STRBUF_INIT;\n\tstruct strbuf a = STRBUF_INIT;\n\tint ret = 0; /* assume changed for safety */\n\n\tif (a_mode != o_mode)\n\t\treturn 0;\n\tif (oid_eq(o_oid, a_oid))\n\t\treturn 1;\n\tif (!renormalize)\n\t\treturn 0;\n\n\tassert(o_oid && a_oid);\n\tif (read_oid_strbuf(opt, o_oid, &o) || read_oid_strbuf(opt, a_oid, &a))\n\t\tgoto error_return;\n\t/*\n\t * Note: binary | is used so that both renormalizations are\n\t * performed.  Comparison can be skipped if both files are\n\t * unchanged since their sha1s have already been compared.\n\t */\n\tif (renormalize_buffer(path, o.buf, o.len, &o) |\n\t    renormalize_buffer(path, a.buf, a.len, &a))\n\t\tret = (o.len == a.len && !memcmp(o.buf, a.buf, o.len));\n\nerror_return:\n\tstrbuf_release(&o);\n\tstrbuf_release(&a);\n\treturn ret;\n}\n\nstatic int handle_modify_delete(struct merge_options *o,\n\t\t\t\t const char *path,\n\t\t\t\t struct object_id *o_oid, int o_mode,\n\t\t\t\t struct object_id *a_oid, int a_mode,\n\t\t\t\t struct object_id *b_oid, int b_mode)\n{\n\tconst char *modify_branch, *delete_branch;\n\tstruct object_id *changed_oid;\n\tint changed_mode;\n\n\tif (a_oid) {\n\t\tmodify_branch = o->branch1;\n\t\tdelete_branch = o->branch2;\n\t\tchanged_oid = a_oid;\n\t\tchanged_mode = a_mode;\n\t} else {\n\t\tmodify_branch = o->branch2;\n\t\tdelete_branch = o->branch1;\n\t\tchanged_oid = b_oid;\n\t\tchanged_mode = b_mode;\n\t}\n\n\treturn handle_change_delete(o,\n\t\t\t\t    path, NULL,\n\t\t\t\t    o_oid, o_mode,\n\t\t\t\t    changed_oid, changed_mode,\n\t\t\t\t    modify_branch, delete_branch,\n\t\t\t\t    _(\"modify\"), _(\"modified\"));\n}\n\nstatic int merge_content(struct merge_options *o,\n\t\t\t const char *path,\n\t\t\t struct object_id *o_oid, int o_mode,\n\t\t\t struct object_id *a_oid, int a_mode,\n\t\t\t struct object_id *b_oid, int b_mode,\n\t\t\t struct rename_conflict_info *rename_conflict_info)\n{\n\tconst char *reason = _(\"content\");\n\tconst char *path1 = NULL, *path2 = NULL;\n\tstruct merge_file_info mfi;\n\tstruct diff_filespec one, a, b;\n\tunsigned df_conflict_remains = 0;\n\n\tif (!o_oid) {\n\t\treason = _(\"add/add\");\n\t\to_oid = (struct object_id *)&null_oid;\n\t}\n\tone.path = a.path = b.path = (char *)path;\n\toidcpy(&one.oid, o_oid);\n\tone.mode = o_mode;\n\toidcpy(&a.oid, a_oid);\n\ta.mode = a_mode;\n\toidcpy(&b.oid, b_oid);\n\tb.mode = b_mode;\n\n\tif (rename_conflict_info) {\n\t\tstruct diff_filepair *pair1 = rename_conflict_info->pair1;\n\n\t\tpath1 = (o->branch1 == rename_conflict_info->branch1) ?\n\t\t\tpair1->two->path : pair1->one->path;\n\t\t/* If rename_conflict_info->pair2 != NULL, we are in\n\t\t * RENAME_ONE_FILE_TO_ONE case.  Otherwise, we have a\n\t\t * normal rename.\n\t\t */\n\t\tpath2 = (rename_conflict_info->pair2 ||\n\t\t\t o->branch2 == rename_conflict_info->branch1) ?\n\t\t\tpair1->two->path : pair1->one->path;\n\n\t\tif (dir_in_way(path, !o->call_depth,\n\t\t\t       S_ISGITLINK(pair1->two->mode)))\n\t\t\tdf_conflict_remains = 1;\n\t}\n\tif (merge_file_special_markers(o, &one, &a, &b,\n\t\t\t\t       o->branch1, path1,\n\t\t\t\t       o->branch2, path2, &mfi))\n\t\treturn -1;\n\n\tif (mfi.clean && !df_conflict_remains &&\n\t    oid_eq(&mfi.oid, a_oid) && mfi.mode == a_mode) {\n\t\tint path_renamed_outside_HEAD;\n\t\toutput(o, 3, _(\"Skipped %s (merged same as existing)\"), path);\n\t\t/*\n\t\t * The content merge resulted in the same file contents we\n\t\t * already had.  We can return early if those file contents\n\t\t * are recorded at the correct path (which may not be true\n\t\t * if the merge involves a rename).\n\t\t */\n\t\tpath_renamed_outside_HEAD = !path2 || !strcmp(path, path2);\n\t\tif (!path_renamed_outside_HEAD) {\n\t\t\tadd_cacheinfo(o, mfi.mode, &mfi.oid, path,\n\t\t\t\t      0, (!o->call_depth), 0);\n\t\t\treturn mfi.clean;\n\t\t}\n\t} else\n\t\toutput(o, 2, _(\"Auto-merging %s\"), path);\n\n\tif (!mfi.clean) {\n\t\tif (S_ISGITLINK(mfi.mode))\n\t\t\treason = _(\"submodule\");\n\t\toutput(o, 1, _(\"CONFLICT (%s): Merge conflict in %s\"),\n\t\t\t\treason, path);\n\t\tif (rename_conflict_info && !df_conflict_remains)\n\t\t\tif (update_stages(o, path, &one, &a, &b))\n\t\t\t\treturn -1;\n\t}\n\n\tif (df_conflict_remains) {\n\t\tchar *new_path;\n\t\tif (o->call_depth) {\n\t\t\tremove_file_from_cache(path);\n\t\t} else {\n\t\t\tif (!mfi.clean) {\n\t\t\t\tif (update_stages(o, path, &one, &a, &b))\n\t\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tint file_from_stage2 = was_tracked(path);\n\t\t\t\tstruct diff_filespec merged;\n\t\t\t\toidcpy(&merged.oid, &mfi.oid);\n\t\t\t\tmerged.mode = mfi.mode;\n\n\t\t\t\tif (update_stages(o, path, NULL,\n\t\t\t\t\t\t  file_from_stage2 ? &merged : NULL,\n\t\t\t\t\t\t  file_from_stage2 ? NULL : &merged))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t}\n\t\tnew_path = unique_path(o, path, rename_conflict_info->branch1);\n\t\toutput(o, 1, _(\"Adding as %s instead\"), new_path);\n\t\tif (update_file(o, 0, &mfi.oid, mfi.mode, new_path)) {\n\t\t\tfree(new_path);\n\t\t\treturn -1;\n\t\t}\n\t\tfree(new_path);\n\t\tmfi.clean = 0;\n\t} else if (update_file(o, mfi.clean, &mfi.oid, mfi.mode, path))\n\t\treturn -1;\n\treturn mfi.clean;\n}\n\n/* Per entry merge function */\nstatic int process_entry(struct merge_options *o,\n\t\t\t const char *path, struct stage_data *entry)\n{\n\tint clean_merge = 1;\n\tint normalize = o->renormalize;\n\tunsigned o_mode = entry->stages[1].mode;\n\tunsigned a_mode = entry->stages[2].mode;\n\tunsigned b_mode = entry->stages[3].mode;\n\tstruct object_id *o_oid = stage_oid(&entry->stages[1].oid, o_mode);\n\tstruct object_id *a_oid = stage_oid(&entry->stages[2].oid, a_mode);\n\tstruct object_id *b_oid = stage_oid(&entry->stages[3].oid, b_mode);\n\n\tentry->processed = 1;\n\tif (entry->rename_conflict_info) {\n\t\tstruct rename_conflict_info *conflict_info = entry->rename_conflict_info;\n\t\tswitch (conflict_info->rename_type) {\n\t\tcase RENAME_NORMAL:\n\t\tcase RENAME_ONE_FILE_TO_ONE:\n\t\t\tclean_merge = merge_content(o, path,\n\t\t\t\t\t\t    o_oid, o_mode, a_oid, a_mode, b_oid, b_mode,\n\t\t\t\t\t\t    conflict_info);\n\t\t\tbreak;\n\t\tcase RENAME_DELETE:\n\t\t\tclean_merge = 0;\n\t\t\tif (conflict_rename_delete(o,\n\t\t\t\t\t\t   conflict_info->pair1,\n\t\t\t\t\t\t   conflict_info->branch1,\n\t\t\t\t\t\t   conflict_info->branch2))\n\t\t\t\tclean_merge = -1;\n\t\t\tbreak;\n\t\tcase RENAME_ONE_FILE_TO_TWO:\n\t\t\tclean_merge = 0;\n\t\t\tif (conflict_rename_rename_1to2(o, conflict_info))\n\t\t\t\tclean_merge = -1;\n\t\t\tbreak;\n\t\tcase RENAME_TWO_FILES_TO_ONE:\n\t\t\tclean_merge = 0;\n\t\t\tif (conflict_rename_rename_2to1(o, conflict_info))\n\t\t\t\tclean_merge = -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tentry->processed = 0;\n\t\t\tbreak;\n\t\t}\n\t} else if (o_oid && (!a_oid || !b_oid)) {\n\t\t/* Case A: Deleted in one */\n\t\tif ((!a_oid && !b_oid) ||\n\t\t    (!b_oid && blob_unchanged(o, o_oid, o_mode, a_oid, a_mode, normalize, path)) ||\n\t\t    (!a_oid && blob_unchanged(o, o_oid, o_mode, b_oid, b_mode, normalize, path))) {\n\t\t\t/* Deleted in both or deleted in one and\n\t\t\t * unchanged in the other */\n\t\t\tif (a_oid)\n\t\t\t\toutput(o, 2, _(\"Removing %s\"), path);\n\t\t\t/* do not touch working file if it did not exist */\n\t\t\tremove_file(o, 1, path, !a_oid);\n\t\t} else {\n\t\t\t/* Modify/delete; deleted side may have put a directory in the way */\n\t\t\tclean_merge = 0;\n\t\t\tif (handle_modify_delete(o, path, o_oid, o_mode,\n\t\t\t\t\t\t a_oid, a_mode, b_oid, b_mode))\n\t\t\t\tclean_merge = -1;\n\t\t}\n\t} else if ((!o_oid && a_oid && !b_oid) ||\n\t\t   (!o_oid && !a_oid && b_oid)) {\n\t\t/* Case B: Added in one. */\n\t\t/* [nothing|directory] -> ([nothing|directory], file) */\n\n\t\tconst char *add_branch;\n\t\tconst char *other_branch;\n\t\tunsigned mode;\n\t\tconst struct object_id *oid;\n\t\tconst char *conf;\n\n\t\tif (a_oid) {\n\t\t\tadd_branch = o->branch1;\n\t\t\tother_branch = o->branch2;\n\t\t\tmode = a_mode;\n\t\t\toid = a_oid;\n\t\t\tconf = _(\"file/directory\");\n\t\t} else {\n\t\t\tadd_branch = o->branch2;\n\t\t\tother_branch = o->branch1;\n\t\t\tmode = b_mode;\n\t\t\toid = b_oid;\n\t\t\tconf = _(\"directory/file\");\n\t\t}\n\t\tif (dir_in_way(path, !o->call_depth,\n\t\t\t       S_ISGITLINK(a_mode))) {\n\t\t\tchar *new_path = unique_path(o, path, add_branch);\n\t\t\tclean_merge = 0;\n\t\t\toutput(o, 1, _(\"CONFLICT (%s): There is a directory with name %s in %s. \"\n\t\t\t       \"Adding %s as %s\"),\n\t\t\t       conf, path, other_branch, path, new_path);\n\t\t\tif (update_file(o, 0, oid, mode, new_path))\n\t\t\t\tclean_merge = -1;\n\t\t\telse if (o->call_depth)\n\t\t\t\tremove_file_from_cache(path);\n\t\t\tfree(new_path);\n\t\t} else {\n\t\t\toutput(o, 2, _(\"Adding %s\"), path);\n\t\t\t/* do not overwrite file if already present */\n\t\t\tif (update_file_flags(o, oid, mode, path, 1, !a_oid))\n\t\t\t\tclean_merge = -1;\n\t\t}\n\t} else if (a_oid && b_oid) {\n\t\t/* Case C: Added in both (check for same permissions) and */\n\t\t/* case D: Modified in both, but differently. */\n\t\tclean_merge = merge_content(o, path,\n\t\t\t\t\t    o_oid, o_mode, a_oid, a_mode, b_oid, b_mode,\n\t\t\t\t\t    NULL);\n\t} else if (!o_oid && !a_oid && !b_oid) {\n\t\t/*\n\t\t * this entry was deleted altogether. a_mode == 0 means\n\t\t * we had that path and want to actively remove it.\n\t\t */\n\t\tremove_file(o, 1, path, !a_mode);\n\t} else\n\t\tdie(\"BUG: fatal merge failure, shouldn't happen.\");\n\n\treturn clean_merge;\n}\n\nint merge_trees(struct merge_options *o,\n\t\tstruct tree *head,\n\t\tstruct tree *merge,\n\t\tstruct tree *common,\n\t\tstruct tree **result)\n{\n\tint code, clean;\n\n\tif (o->subtree_shift) {\n\t\tmerge = shift_tree_object(head, merge, o->subtree_shift);\n\t\tcommon = shift_tree_object(head, common, o->subtree_shift);\n\t}\n\n\tif (oid_eq(&common->object.oid, &merge->object.oid)) {\n\t\toutput(o, 0, _(\"Already up-to-date!\"));\n\t\t*result = head;\n\t\treturn 1;\n\t}\n\n\tcode = git_merge_trees(o->call_depth, common, head, merge);\n\n\tif (code != 0) {\n\t\tif (show(o, 4) || o->call_depth)\n\t\t\terr(o, _(\"merging of trees %s and %s failed\"),\n\t\t\t    oid_to_hex(&head->object.oid),\n\t\t\t    oid_to_hex(&merge->object.oid));\n\t\treturn -1;\n\t}\n\n\tif (unmerged_cache()) {\n\t\tstruct string_list *entries, *re_head, *re_merge;\n\t\tint i;\n\t\tstring_list_clear(&o->current_file_set, 1);\n\t\tstring_list_clear(&o->current_directory_set, 1);\n\t\tget_files_dirs(o, head);\n\t\tget_files_dirs(o, merge);\n\n\t\tentries = get_unmerged();\n\t\trecord_df_conflict_files(o, entries);\n\t\tre_head  = get_renames(o, head, common, head, merge, entries);\n\t\tre_merge = get_renames(o, merge, common, head, merge, entries);\n\t\tclean = process_renames(o, re_head, re_merge);\n\t\tif (clean < 0)\n\t\t\treturn clean;\n\t\tfor (i = entries->nr-1; 0 <= i; i--) {\n\t\t\tconst char *path = entries->items[i].string;\n\t\t\tstruct stage_data *e = entries->items[i].util;\n\t\t\tif (!e->processed) {\n\t\t\t\tint ret = process_entry(o, path, e);\n\t\t\t\tif (!ret)\n\t\t\t\t\tclean = 0;\n\t\t\t\telse if (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < entries->nr; i++) {\n\t\t\tstruct stage_data *e = entries->items[i].util;\n\t\t\tif (!e->processed)\n\t\t\t\tdie(\"BUG: unprocessed path??? %s\",\n\t\t\t\t    entries->items[i].string);\n\t\t}\n\n\t\tstring_list_clear(re_merge, 0);\n\t\tstring_list_clear(re_head, 0);\n\t\tstring_list_clear(entries, 1);\n\n\t\tfree(re_merge);\n\t\tfree(re_head);\n\t\tfree(entries);\n\t}\n\telse\n\t\tclean = 1;\n\n\tif (o->call_depth && !(*result = write_tree_from_memory(o)))\n\t\treturn -1;\n\n\treturn clean;\n}\n\nstatic struct commit_list *reverse_commit_list(struct commit_list *list)\n{\n\tstruct commit_list *next = NULL, *current, *backup;\n\tfor (current = list; current; current = backup) {\n\t\tbackup = current->next;\n\t\tcurrent->next = next;\n\t\tnext = current;\n\t}\n\treturn next;\n}\n\n/*\n * Merge the commits h1 and h2, return the resulting virtual\n * commit object and a flag indicating the cleanness of the merge.\n */\nint merge_recursive(struct merge_options *o,\n\t\t    struct commit *h1,\n\t\t    struct commit *h2,\n\t\t    struct commit_list *ca,\n\t\t    struct commit **result)\n{\n\tstruct commit_list *iter;\n\tstruct commit *merged_common_ancestors;\n\tstruct tree *mrtree = mrtree;\n\tint clean;\n\n\tif (show(o, 4)) {\n\t\toutput(o, 4, _(\"Merging:\"));\n\t\toutput_commit_title(o, h1);\n\t\toutput_commit_title(o, h2);\n\t}\n\n\tif (!ca) {\n\t\tca = get_merge_bases(h1, h2);\n\t\tca = reverse_commit_list(ca);\n\t}\n\n\tif (show(o, 5)) {\n\t\tunsigned cnt = commit_list_count(ca);\n\n\t\toutput(o, 5, Q_(\"found %u common ancestor:\",\n\t\t\t\t\"found %u common ancestors:\", cnt), cnt);\n\t\tfor (iter = ca; iter; iter = iter->next)\n\t\t\toutput_commit_title(o, iter->item);\n\t}\n\n\tmerged_common_ancestors = pop_commit(&ca);\n\tif (merged_common_ancestors == NULL) {\n\t\t/* if there is no common ancestor, use an empty tree */\n\t\tstruct tree *tree;\n\n\t\ttree = lookup_tree(EMPTY_TREE_SHA1_BIN);\n\t\tmerged_common_ancestors = make_virtual_commit(tree, \"ancestor\");\n\t}\n\n\tfor (iter = ca; iter; iter = iter->next) {\n\t\tconst char *saved_b1, *saved_b2;\n\t\to->call_depth++;\n\t\t/*\n\t\t * When the merge fails, the result contains files\n\t\t * with conflict markers. The cleanness flag is\n\t\t * ignored (unless indicating an error), it was never\n\t\t * actually used, as result of merge_trees has always\n\t\t * overwritten it: the committed \"conflicts\" were\n\t\t * already resolved.\n\t\t */\n\t\tdiscard_cache();\n\t\tsaved_b1 = o->branch1;\n\t\tsaved_b2 = o->branch2;\n\t\to->branch1 = \"Temporary merge branch 1\";\n\t\to->branch2 = \"Temporary merge branch 2\";\n\t\tif (merge_recursive(o, merged_common_ancestors, iter->item,\n\t\t\t\t    NULL, &merged_common_ancestors) < 0)\n\t\t\treturn -1;\n\t\to->branch1 = saved_b1;\n\t\to->branch2 = saved_b2;\n\t\to->call_depth--;\n\n\t\tif (!merged_common_ancestors)\n\t\t\treturn err(o, _(\"merge returned no commit\"));\n\t}\n\n\tdiscard_cache();\n\tif (!o->call_depth)\n\t\tread_cache();\n\n\to->ancestor = \"merged common ancestors\";\n\tclean = merge_trees(o, h1->tree, h2->tree, merged_common_ancestors->tree,\n\t\t\t    &mrtree);\n\tif (clean < 0) {\n\t\tflush_output(o);\n\t\treturn clean;\n\t}\n\n\tif (o->call_depth) {\n\t\t*result = make_virtual_commit(mrtree, \"merged tree\");\n\t\tcommit_list_insert(h1, &(*result)->parents);\n\t\tcommit_list_insert(h2, &(*result)->parents->next);\n\t}\n\tflush_output(o);\n\tif (!o->call_depth && o->buffer_output < 2)\n\t\tstrbuf_release(&o->obuf);\n\tif (show(o, 2))\n\t\tdiff_warn_rename_limit(\"merge.renamelimit\",\n\t\t\t\t       o->needed_rename_limit, 0);\n\treturn clean;\n}\n\nstatic struct commit *get_ref(const struct object_id *oid, const char *name)\n{\n\tstruct object *object;\n\n\tobject = deref_tag(parse_object(oid->hash), name, strlen(name));\n\tif (!object)\n\t\treturn NULL;\n\tif (object->type == OBJ_TREE)\n\t\treturn make_virtual_commit((struct tree*)object, name);\n\tif (object->type != OBJ_COMMIT)\n\t\treturn NULL;\n\tif (parse_commit((struct commit *)object))\n\t\treturn NULL;\n\treturn (struct commit *)object;\n}\n\nint merge_recursive_generic(struct merge_options *o,\n\t\t\t    const struct object_id *head,\n\t\t\t    const struct object_id *merge,\n\t\t\t    int num_base_list,\n\t\t\t    const struct object_id **base_list,\n\t\t\t    struct commit **result)\n{\n\tint clean;\n\tstruct lock_file *lock = xcalloc(1, sizeof(struct lock_file));\n\tstruct commit *head_commit = get_ref(head, o->branch1);\n\tstruct commit *next_commit = get_ref(merge, o->branch2);\n\tstruct commit_list *ca = NULL;\n\n\tif (base_list) {\n\t\tint i;\n\t\tfor (i = 0; i < num_base_list; ++i) {\n\t\t\tstruct commit *base;\n\t\t\tif (!(base = get_ref(base_list[i], oid_to_hex(base_list[i]))))\n\t\t\t\treturn err(o, _(\"Could not parse object '%s'\"),\n\t\t\t\t\toid_to_hex(base_list[i]));\n\t\t\tcommit_list_insert(base, &ca);\n\t\t}\n\t}\n\n\thold_locked_index(lock, LOCK_DIE_ON_ERROR);\n\tclean = merge_recursive(o, head_commit, next_commit, ca,\n\t\t\tresult);\n\tif (clean < 0)\n\t\treturn clean;\n\n\tif (active_cache_changed &&\n\t    write_locked_index(&the_index, lock, COMMIT_LOCK))\n\t\treturn err(o, _(\"Unable to write index.\"));\n\n\treturn clean ? 0 : 1;\n}\n\nstatic void merge_recursive_config(struct merge_options *o)\n{\n\tgit_config_get_int(\"merge.verbosity\", &o->verbosity);\n\tgit_config_get_int(\"diff.renamelimit\", &o->diff_rename_limit);\n\tgit_config_get_int(\"merge.renamelimit\", &o->merge_rename_limit);\n\tgit_config(git_xmerge_config, NULL);\n}\n\nvoid init_merge_options(struct merge_options *o)\n{\n\tmemset(o, 0, sizeof(struct merge_options));\n\to->verbosity = 2;\n\to->buffer_output = 1;\n\to->diff_rename_limit = -1;\n\to->merge_rename_limit = -1;\n\to->renormalize = 0;\n\to->detect_rename = 1;\n\tmerge_recursive_config(o);\n\tif (getenv(\"GIT_MERGE_VERBOSITY\"))\n\t\to->verbosity =\n\t\t\tstrtol(getenv(\"GIT_MERGE_VERBOSITY\"), NULL, 10);\n\tif (o->verbosity >= 5)\n\t\to->buffer_output = 0;\n\tstrbuf_init(&o->obuf, 0);\n\tstring_list_init(&o->current_file_set, 1);\n\tstring_list_init(&o->current_directory_set, 1);\n\tstring_list_init(&o->df_conflict_file_set, 1);\n}\n\nint parse_merge_opt(struct merge_options *o, const char *s)\n{\n\tconst char *arg;\n\n\tif (!s || !*s)\n\t\treturn -1;\n\tif (!strcmp(s, \"ours\"))\n\t\to->recursive_variant = MERGE_RECURSIVE_OURS;\n\telse if (!strcmp(s, \"theirs\"))\n\t\to->recursive_variant = MERGE_RECURSIVE_THEIRS;\n\telse if (!strcmp(s, \"subtree\"))\n\t\to->subtree_shift = \"\";\n\telse if (skip_prefix(s, \"subtree=\", &arg))\n\t\to->subtree_shift = arg;\n\telse if (!strcmp(s, \"patience\"))\n\t\to->xdl_opts = DIFF_WITH_ALG(o, PATIENCE_DIFF);\n\telse if (!strcmp(s, \"histogram\"))\n\t\to->xdl_opts = DIFF_WITH_ALG(o, HISTOGRAM_DIFF);\n\telse if (skip_prefix(s, \"diff-algorithm=\", &arg)) {\n\t\tlong value = parse_algorithm_value(arg);\n\t\tif (value < 0)\n\t\t\treturn -1;\n\t\t/* clear out previous settings */\n\t\tDIFF_XDL_CLR(o, NEED_MINIMAL);\n\t\to->xdl_opts &= ~XDF_DIFF_ALGORITHM_MASK;\n\t\to->xdl_opts |= value;\n\t}\n\telse if (!strcmp(s, \"ignore-space-change\"))\n\t\tDIFF_XDL_SET(o, IGNORE_WHITESPACE_CHANGE);\n\telse if (!strcmp(s, \"ignore-all-space\"))\n\t\tDIFF_XDL_SET(o, IGNORE_WHITESPACE);\n\telse if (!strcmp(s, \"ignore-space-at-eol\"))\n\t\tDIFF_XDL_SET(o, IGNORE_WHITESPACE_AT_EOL);\n\telse if (!strcmp(s, \"ignore-cr-at-eol\"))\n\t\tDIFF_XDL_SET(o, IGNORE_CR_AT_EOL);\n\telse if (!strcmp(s, \"renormalize\"))\n\t\to->renormalize = 1;\n\telse if (!strcmp(s, \"no-renormalize\"))\n\t\to->renormalize = 0;\n\telse if (!strcmp(s, \"no-renames\"))\n\t\to->detect_rename = 0;\n\telse if (!strcmp(s, \"find-renames\")) {\n\t\to->detect_rename = 1;\n\t\to->rename_score = 0;\n\t}\n\telse if (skip_prefix(s, \"find-renames=\", &arg) ||\n\t\t skip_prefix(s, \"rename-threshold=\", &arg)) {\n\t\tif ((o->rename_score = parse_rename_score(&arg)) == -1 || *arg != 0)\n\t\t\treturn -1;\n\t\to->detect_rename = 1;\n\t}\n\telse\n\t\treturn -1;\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "006b94baf2991d5c81dcc02f86da66473e949626",
  "sha1_ok": true,
  "size": 62933
}
