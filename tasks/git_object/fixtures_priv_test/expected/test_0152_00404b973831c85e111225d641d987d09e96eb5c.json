{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJjYWNoZS10cmVlLmgiCiNpbmNsdWRlICJtZXJnZXNvcnQuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgImRpZmZjb3JlLmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgImJsYW1lLmgiCgp2b2lkIGJsYW1lX29yaWdpbl9kZWNyZWYoc3RydWN0IGJsYW1lX29yaWdpbiAqbykKewoJaWYgKG8gJiYgLS1vLT5yZWZjbnQgPD0gMCkgewoJCXN0cnVjdCBibGFtZV9vcmlnaW4gKnAsICpsID0gTlVMTDsKCQlpZiAoby0+cHJldmlvdXMpCgkJCWJsYW1lX29yaWdpbl9kZWNyZWYoby0+cHJldmlvdXMpOwoJCWZyZWUoby0+ZmlsZS5wdHIpOwoJCS8qIFNob3VsZCBiZSBwcmVzZW50IGV4YWN0bHkgb25jZSBpbiBjb21taXQgY2hhaW4gKi8KCQlmb3IgKHAgPSBvLT5jb21taXQtPnV0aWw7IHA7IGwgPSBwLCBwID0gcC0+bmV4dCkgewoJCQlpZiAocCA9PSBvKSB7CgkJCQlpZiAobCkKCQkJCQlsLT5uZXh0ID0gcC0+bmV4dDsKCQkJCWVsc2UKCQkJCQlvLT5jb21taXQtPnV0aWwgPSBwLT5uZXh0OwoJCQkJZnJlZShvKTsKCQkJCXJldHVybjsKCQkJfQoJCX0KCQlkaWUoImludGVybmFsIGVycm9yIGluIGJsYW1lX29yaWdpbl9kZWNyZWYiKTsKCX0KfQoKLyoKICogR2l2ZW4gYSBjb21taXQgYW5kIGEgcGF0aCBpbiBpdCwgY3JlYXRlIGEgbmV3IG9yaWdpbiBzdHJ1Y3R1cmUuCiAqIFRoZSBjYWxsZXJzIHRoYXQgYWRkIGJsYW1lIHRvIHRoZSBzY29yZWJvYXJkIHNob3VsZCB1c2UKICogZ2V0X29yaWdpbigpIHRvIG9idGFpbiBzaGFyZWQsIHJlZmNvdW50ZWQgY29weSBpbnN0ZWFkIG9mIGNhbGxpbmcKICogdGhpcyBmdW5jdGlvbiBkaXJlY3RseS4KICovCnN0YXRpYyBzdHJ1Y3QgYmxhbWVfb3JpZ2luICptYWtlX29yaWdpbihzdHJ1Y3QgY29tbWl0ICpjb21taXQsIGNvbnN0IGNoYXIgKnBhdGgpCnsKCXN0cnVjdCBibGFtZV9vcmlnaW4gKm87CglGTEVYX0FMTE9DX1NUUihvLCBwYXRoLCBwYXRoKTsKCW8tPmNvbW1pdCA9IGNvbW1pdDsKCW8tPnJlZmNudCA9IDE7CglvLT5uZXh0ID0gY29tbWl0LT51dGlsOwoJY29tbWl0LT51dGlsID0gbzsKCXJldHVybiBvOwp9CgovKgogKiBMb2NhdGUgYW4gZXhpc3Rpbmcgb3JpZ2luIG9yIGNyZWF0ZSBhIG5ldyBvbmUuCiAqIFRoaXMgbW92ZXMgdGhlIG9yaWdpbiB0byBmcm9udCBwb3NpdGlvbiBpbiB0aGUgY29tbWl0IHV0aWwgbGlzdC4KICovCnN0YXRpYyBzdHJ1Y3QgYmxhbWVfb3JpZ2luICpnZXRfb3JpZ2luKHN0cnVjdCBjb21taXQgKmNvbW1pdCwgY29uc3QgY2hhciAqcGF0aCkKewoJc3RydWN0IGJsYW1lX29yaWdpbiAqbywgKmw7CgoJZm9yIChvID0gY29tbWl0LT51dGlsLCBsID0gTlVMTDsgbzsgbCA9IG8sIG8gPSBvLT5uZXh0KSB7CgkJaWYgKCFzdHJjbXAoby0+cGF0aCwgcGF0aCkpIHsKCQkJLyogYnVtcCB0byBmcm9udCAqLwoJCQlpZiAobCkgewoJCQkJbC0+bmV4dCA9IG8tPm5leHQ7CgkJCQlvLT5uZXh0ID0gY29tbWl0LT51dGlsOwoJCQkJY29tbWl0LT51dGlsID0gbzsKCQkJfQoJCQlyZXR1cm4gYmxhbWVfb3JpZ2luX2luY3JlZihvKTsKCQl9Cgl9CglyZXR1cm4gbWFrZV9vcmlnaW4oY29tbWl0LCBwYXRoKTsKfQoKCgpzdGF0aWMgdm9pZCB2ZXJpZnlfd29ya2luZ190cmVlX3BhdGgoc3RydWN0IGNvbW1pdCAqd29ya190cmVlLCBjb25zdCBjaGFyICpwYXRoKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHM7CglpbnQgcG9zOwoKCWZvciAocGFyZW50cyA9IHdvcmtfdHJlZS0+cGFyZW50czsgcGFyZW50czsgcGFyZW50cyA9IHBhcmVudHMtPm5leHQpIHsKCQljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpjb21taXRfb2lkID0gJnBhcmVudHMtPml0ZW0tPm9iamVjdC5vaWQ7CgkJc3RydWN0IG9iamVjdF9pZCBibG9iX29pZDsKCQl1bnNpZ25lZCBtb2RlOwoKCQlpZiAoIWdldF90cmVlX2VudHJ5KGNvbW1pdF9vaWQtPmhhc2gsIHBhdGgsIGJsb2Jfb2lkLmhhc2gsICZtb2RlKSAmJgoJCSAgICBzaGExX29iamVjdF9pbmZvKGJsb2Jfb2lkLmhhc2gsIE5VTEwpID09IE9CSl9CTE9CKQoJCQlyZXR1cm47Cgl9CgoJcG9zID0gY2FjaGVfbmFtZV9wb3MocGF0aCwgc3RybGVuKHBhdGgpKTsKCWlmIChwb3MgPj0gMCkKCQk7IC8qIHBhdGggaXMgaW4gdGhlIGluZGV4ICovCgllbHNlIGlmICgtMSAtIHBvcyA8IGFjdGl2ZV9uciAmJgoJCSAhc3RyY21wKGFjdGl2ZV9jYWNoZVstMSAtIHBvc10tPm5hbWUsIHBhdGgpKQoJCTsgLyogcGF0aCBpcyBpbiB0aGUgaW5kZXgsIHVubWVyZ2VkICovCgllbHNlCgkJZGllKCJubyBzdWNoIHBhdGggJyVzJyBpbiBIRUFEIiwgcGF0aCk7Cn0KCnN0YXRpYyBzdHJ1Y3QgY29tbWl0X2xpc3QgKiphcHBlbmRfcGFyZW50KHN0cnVjdCBjb21taXRfbGlzdCAqKnRhaWwsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJc3RydWN0IGNvbW1pdCAqcGFyZW50OwoKCXBhcmVudCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlKG9pZC0+aGFzaCk7CglpZiAoIXBhcmVudCkKCQlkaWUoIm5vIHN1Y2ggY29tbWl0ICVzIiwgb2lkX3RvX2hleChvaWQpKTsKCXJldHVybiAmY29tbWl0X2xpc3RfaW5zZXJ0KHBhcmVudCwgdGFpbCktPm5leHQ7Cn0KCnN0YXRpYyB2b2lkIGFwcGVuZF9tZXJnZV9wYXJlbnRzKHN0cnVjdCBjb21taXRfbGlzdCAqKnRhaWwpCnsKCWludCBtZXJnZV9oZWFkOwoJc3RydWN0IHN0cmJ1ZiBsaW5lID0gU1RSQlVGX0lOSVQ7CgoJbWVyZ2VfaGVhZCA9IG9wZW4oZ2l0X3BhdGhfbWVyZ2VfaGVhZCgpLCBPX1JET05MWSk7CglpZiAobWVyZ2VfaGVhZCA8IDApIHsKCQlpZiAoZXJybm8gPT0gRU5PRU5UKQoJCQlyZXR1cm47CgkJZGllKCJjYW5ub3Qgb3BlbiAnJXMnIGZvciByZWFkaW5nIiwgZ2l0X3BhdGhfbWVyZ2VfaGVhZCgpKTsKCX0KCgl3aGlsZSAoIXN0cmJ1Zl9nZXR3aG9sZWxpbmVfZmQoJmxpbmUsIG1lcmdlX2hlYWQsICdcbicpKSB7CgkJc3RydWN0IG9iamVjdF9pZCBvaWQ7CgkJaWYgKGxpbmUubGVuIDwgR0lUX1NIQTFfSEVYU1ogfHwgZ2V0X29pZF9oZXgobGluZS5idWYsICZvaWQpKQoJCQlkaWUoInVua25vd24gbGluZSBpbiAnJXMnOiAlcyIsIGdpdF9wYXRoX21lcmdlX2hlYWQoKSwgbGluZS5idWYpOwoJCXRhaWwgPSBhcHBlbmRfcGFyZW50KHRhaWwsICZvaWQpOwoJfQoJY2xvc2UobWVyZ2VfaGVhZCk7CglzdHJidWZfcmVsZWFzZSgmbGluZSk7Cn0KCi8qCiAqIFRoaXMgaXNuJ3QgYXMgc2ltcGxlIGFzIHBhc3Npbmcgc2ItPmJ1ZiBhbmQgc2ItPmxlbiwgYmVjYXVzZSB3ZQogKiB3YW50IHRvIHRyYW5zZmVyIG93bmVyc2hpcCBvZiB0aGUgYnVmZmVyIHRvIHRoZSBjb21taXQgKHNvIHdlCiAqIG11c3QgdXNlIGRldGFjaCkuCiAqLwpzdGF0aWMgdm9pZCBzZXRfY29tbWl0X2J1ZmZlcl9mcm9tX3N0cmJ1ZihzdHJ1Y3QgY29tbWl0ICpjLCBzdHJ1Y3Qgc3RyYnVmICpzYikKewoJc2l6ZV90IGxlbjsKCXZvaWQgKmJ1ZiA9IHN0cmJ1Zl9kZXRhY2goc2IsICZsZW4pOwoJc2V0X2NvbW1pdF9idWZmZXIoYywgYnVmLCBsZW4pOwp9CgovKgogKiBQcmVwYXJlIGEgZHVtbXkgY29tbWl0IHRoYXQgcmVwcmVzZW50cyB0aGUgd29yayB0cmVlIChvciBzdGFnZWQpIGl0ZW0uCiAqIE5vdGUgdGhhdCBhbm5vdGF0aW5nIHdvcmsgdHJlZSBpdGVtIG5ldmVyIHdvcmtzIGluIHRoZSByZXZlcnNlLgogKi8Kc3RhdGljIHN0cnVjdCBjb21taXQgKmZha2Vfd29ya2luZ190cmVlX2NvbW1pdChzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHQsCgkJCQkJICAgICAgIGNvbnN0IGNoYXIgKnBhdGgsCgkJCQkJICAgICAgIGNvbnN0IGNoYXIgKmNvbnRlbnRzX2Zyb20pCnsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCXN0cnVjdCBibGFtZV9vcmlnaW4gKm9yaWdpbjsKCXN0cnVjdCBjb21taXRfbGlzdCAqKnBhcmVudF90YWlsLCAqcGFyZW50OwoJc3RydWN0IG9iamVjdF9pZCBoZWFkX29pZDsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICppZGVudDsKCXRpbWVfdCBub3c7CglpbnQgc2l6ZSwgbGVuOwoJc3RydWN0IGNhY2hlX2VudHJ5ICpjZTsKCXVuc2lnbmVkIG1vZGU7CglzdHJ1Y3Qgc3RyYnVmIG1zZyA9IFNUUkJVRl9JTklUOwoKCXJlYWRfY2FjaGUoKTsKCXRpbWUoJm5vdyk7Cgljb21taXQgPSBhbGxvY19jb21taXRfbm9kZSgpOwoJY29tbWl0LT5vYmplY3QucGFyc2VkID0gMTsKCWNvbW1pdC0+ZGF0ZSA9IG5vdzsKCXBhcmVudF90YWlsID0gJmNvbW1pdC0+cGFyZW50czsKCglpZiAoIXJlc29sdmVfcmVmX3Vuc2FmZSgiSEVBRCIsIFJFU09MVkVfUkVGX1JFQURJTkcsIGhlYWRfb2lkLmhhc2gsIE5VTEwpKQoJCWRpZSgibm8gc3VjaCByZWY6IEhFQUQiKTsKCglwYXJlbnRfdGFpbCA9IGFwcGVuZF9wYXJlbnQocGFyZW50X3RhaWwsICZoZWFkX29pZCk7CglhcHBlbmRfbWVyZ2VfcGFyZW50cyhwYXJlbnRfdGFpbCk7Cgl2ZXJpZnlfd29ya2luZ190cmVlX3BhdGgoY29tbWl0LCBwYXRoKTsKCglvcmlnaW4gPSBtYWtlX29yaWdpbihjb21taXQsIHBhdGgpOwoKCWlkZW50ID0gZm10X2lkZW50KCJOb3QgQ29tbWl0dGVkIFlldCIsICJub3QuY29tbWl0dGVkLnlldCIsIE5VTEwsIDApOwoJc3RyYnVmX2FkZHN0cigmbXNnLCAidHJlZSAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXG4iKTsKCWZvciAocGFyZW50ID0gY29tbWl0LT5wYXJlbnRzOyBwYXJlbnQ7IHBhcmVudCA9IHBhcmVudC0+bmV4dCkKCQlzdHJidWZfYWRkZigmbXNnLCAicGFyZW50ICVzXG4iLAoJCQkgICAgb2lkX3RvX2hleCgmcGFyZW50LT5pdGVtLT5vYmplY3Qub2lkKSk7CglzdHJidWZfYWRkZigmbXNnLAoJCSAgICAiYXV0aG9yICVzXG4iCgkJICAgICJjb21taXR0ZXIgJXNcblxuIgoJCSAgICAiVmVyc2lvbiBvZiAlcyBmcm9tICVzXG4iLAoJCSAgICBpZGVudCwgaWRlbnQsIHBhdGgsCgkJICAgICghY29udGVudHNfZnJvbSA/IHBhdGggOgoJCSAgICAgKCFzdHJjbXAoY29udGVudHNfZnJvbSwgIi0iKSA/ICJzdGFuZGFyZCBpbnB1dCIgOiBjb250ZW50c19mcm9tKSkpOwoJc2V0X2NvbW1pdF9idWZmZXJfZnJvbV9zdHJidWYoY29tbWl0LCAmbXNnKTsKCglpZiAoIWNvbnRlbnRzX2Zyb20gfHwgc3RyY21wKCItIiwgY29udGVudHNfZnJvbSkpIHsKCQlzdHJ1Y3Qgc3RhdCBzdDsKCQljb25zdCBjaGFyICpyZWFkX2Zyb207CgkJY2hhciAqYnVmX3B0cjsKCQl1bnNpZ25lZCBsb25nIGJ1Zl9sZW47CgoJCWlmIChjb250ZW50c19mcm9tKSB7CgkJCWlmIChzdGF0KGNvbnRlbnRzX2Zyb20sICZzdCkgPCAwKQoJCQkJZGllX2Vycm5vKCJDYW5ub3Qgc3RhdCAnJXMnIiwgY29udGVudHNfZnJvbSk7CgkJCXJlYWRfZnJvbSA9IGNvbnRlbnRzX2Zyb207CgkJfQoJCWVsc2UgewoJCQlpZiAobHN0YXQocGF0aCwgJnN0KSA8IDApCgkJCQlkaWVfZXJybm8oIkNhbm5vdCBsc3RhdCAnJXMnIiwgcGF0aCk7CgkJCXJlYWRfZnJvbSA9IHBhdGg7CgkJfQoJCW1vZGUgPSBjYW5vbl9tb2RlKHN0LnN0X21vZGUpOwoKCQlzd2l0Y2ggKHN0LnN0X21vZGUgJiBTX0lGTVQpIHsKCQljYXNlIFNfSUZSRUc6CgkJCWlmIChESUZGX09QVF9UU1Qob3B0LCBBTExPV19URVhUQ09OVikgJiYKCQkJICAgIHRleHRjb252X29iamVjdChyZWFkX2Zyb20sIG1vZGUsICZudWxsX29pZCwgMCwgJmJ1Zl9wdHIsICZidWZfbGVuKSkKCQkJCXN0cmJ1Zl9hdHRhY2goJmJ1ZiwgYnVmX3B0ciwgYnVmX2xlbiwgYnVmX2xlbiArIDEpOwoJCQllbHNlIGlmIChzdHJidWZfcmVhZF9maWxlKCZidWYsIHJlYWRfZnJvbSwgc3Quc3Rfc2l6ZSkgIT0gc3Quc3Rfc2l6ZSkKCQkJCWRpZV9lcnJubygiY2Fubm90IG9wZW4gb3IgcmVhZCAnJXMnIiwgcmVhZF9mcm9tKTsKCQkJYnJlYWs7CgkJY2FzZSBTX0lGTE5LOgoJCQlpZiAoc3RyYnVmX3JlYWRsaW5rKCZidWYsIHJlYWRfZnJvbSwgc3Quc3Rfc2l6ZSkgPCAwKQoJCQkJZGllX2Vycm5vKCJjYW5ub3QgcmVhZGxpbmsgJyVzJyIsIHJlYWRfZnJvbSk7CgkJCWJyZWFrOwoJCWRlZmF1bHQ6CgkJCWRpZSgidW5zdXBwb3J0ZWQgZmlsZSB0eXBlICVzIiwgcmVhZF9mcm9tKTsKCQl9Cgl9CgllbHNlIHsKCQkvKiBSZWFkaW5nIGZyb20gc3RkaW4gKi8KCQltb2RlID0gMDsKCQlpZiAoc3RyYnVmX3JlYWQoJmJ1ZiwgMCwgMCkgPCAwKQoJCQlkaWVfZXJybm8oImZhaWxlZCB0byByZWFkIGZyb20gc3RkaW4iKTsKCX0KCWNvbnZlcnRfdG9fZ2l0KHBhdGgsIGJ1Zi5idWYsIGJ1Zi5sZW4sICZidWYsIDApOwoJb3JpZ2luLT5maWxlLnB0ciA9IGJ1Zi5idWY7CglvcmlnaW4tPmZpbGUuc2l6ZSA9IGJ1Zi5sZW47CglwcmV0ZW5kX3NoYTFfZmlsZShidWYuYnVmLCBidWYubGVuLCBPQkpfQkxPQiwgb3JpZ2luLT5ibG9iX29pZC5oYXNoKTsKCgkvKgoJICogUmVhZCB0aGUgY3VycmVudCBpbmRleCwgcmVwbGFjZSB0aGUgcGF0aCBlbnRyeSB3aXRoCgkgKiBvcmlnaW4tPmJsb2Jfc2hhMSB3aXRob3V0IG11Y2tpbmcgd2l0aCBpdHMgbW9kZSBvciB0eXBlCgkgKiBiaXRzOyB3ZSBhcmUgbm90IGdvaW5nIHRvIHdyaXRlIHRoaXMgaW5kZXggb3V0IC0tIHdlIGp1c3QKCSAqIHdhbnQgdG8gcnVuICJkaWZmLWluZGV4IC0tY2FjaGVkIi4KCSAqLwoJZGlzY2FyZF9jYWNoZSgpOwoJcmVhZF9jYWNoZSgpOwoKCWxlbiA9IHN0cmxlbihwYXRoKTsKCWlmICghbW9kZSkgewoJCWludCBwb3MgPSBjYWNoZV9uYW1lX3BvcyhwYXRoLCBsZW4pOwoJCWlmICgwIDw9IHBvcykKCQkJbW9kZSA9IGFjdGl2ZV9jYWNoZVtwb3NdLT5jZV9tb2RlOwoJCWVsc2UKCQkJLyogTGV0J3Mgbm90IGJvdGhlciByZWFkaW5nIGZyb20gSEVBRCB0cmVlICovCgkJCW1vZGUgPSBTX0lGUkVHIHwgMDY0NDsKCX0KCXNpemUgPSBjYWNoZV9lbnRyeV9zaXplKGxlbik7CgljZSA9IHhjYWxsb2MoMSwgc2l6ZSk7CglvaWRjcHkoJmNlLT5vaWQsICZvcmlnaW4tPmJsb2Jfb2lkKTsKCW1lbWNweShjZS0+bmFtZSwgcGF0aCwgbGVuKTsKCWNlLT5jZV9mbGFncyA9IGNyZWF0ZV9jZV9mbGFncygwKTsKCWNlLT5jZV9uYW1lbGVuID0gbGVuOwoJY2UtPmNlX21vZGUgPSBjcmVhdGVfY2VfbW9kZShtb2RlKTsKCWFkZF9jYWNoZV9lbnRyeShjZSwgQUREX0NBQ0hFX09LX1RPX0FERHxBRERfQ0FDSEVfT0tfVE9fUkVQTEFDRSk7CgoJY2FjaGVfdHJlZV9pbnZhbGlkYXRlX3BhdGgoJnRoZV9pbmRleCwgcGF0aCk7CgoJcmV0dXJuIGNvbW1pdDsKfQoKCgpzdGF0aWMgaW50IGRpZmZfaHVua3MobW1maWxlX3QgKmZpbGVfYSwgbW1maWxlX3QgKmZpbGVfYiwKCQkgICAgICB4ZGxfZW1pdF9odW5rX2NvbnN1bWVfZnVuY190IGh1bmtfZnVuYywgdm9pZCAqY2JfZGF0YSwgaW50IHhkbF9vcHRzKQp7Cgl4cHBhcmFtX3QgeHBwID0gezB9OwoJeGRlbWl0Y29uZl90IHhlY2ZnID0gezB9OwoJeGRlbWl0Y2JfdCBlY2IgPSB7TlVMTH07CgoJeHBwLmZsYWdzID0geGRsX29wdHM7Cgl4ZWNmZy5odW5rX2Z1bmMgPSBodW5rX2Z1bmM7CgllY2IucHJpdiA9IGNiX2RhdGE7CglyZXR1cm4geGRpX2RpZmYoZmlsZV9hLCBmaWxlX2IsICZ4cHAsICZ4ZWNmZywgJmVjYik7Cn0KCi8qCiAqIEdpdmVuIGFuIG9yaWdpbiwgcHJlcGFyZSBtbWZpbGVfdCBzdHJ1Y3R1cmUgdG8gYmUgdXNlZCBieSB0aGUKICogZGlmZiBtYWNoaW5lcnkKICovCnN0YXRpYyB2b2lkIGZpbGxfb3JpZ2luX2Jsb2Ioc3RydWN0IGRpZmZfb3B0aW9ucyAqb3B0LAoJCQkgICAgIHN0cnVjdCBibGFtZV9vcmlnaW4gKm8sIG1tZmlsZV90ICpmaWxlLCBpbnQgKm51bV9yZWFkX2Jsb2IpCnsKCWlmICghby0+ZmlsZS5wdHIpIHsKCQllbnVtIG9iamVjdF90eXBlIHR5cGU7CgkJdW5zaWduZWQgbG9uZyBmaWxlX3NpemU7CgoJCSgqbnVtX3JlYWRfYmxvYikrKzsKCQlpZiAoRElGRl9PUFRfVFNUKG9wdCwgQUxMT1dfVEVYVENPTlYpICYmCgkJICAgIHRleHRjb252X29iamVjdChvLT5wYXRoLCBvLT5tb2RlLCAmby0+YmxvYl9vaWQsIDEsICZmaWxlLT5wdHIsICZmaWxlX3NpemUpKQoJCQk7CgkJZWxzZQoJCQlmaWxlLT5wdHIgPSByZWFkX3NoYTFfZmlsZShvLT5ibG9iX29pZC5oYXNoLCAmdHlwZSwKCQkJCQkJICAgJmZpbGVfc2l6ZSk7CgkJZmlsZS0+c2l6ZSA9IGZpbGVfc2l6ZTsKCgkJaWYgKCFmaWxlLT5wdHIpCgkJCWRpZSgiQ2Fubm90IHJlYWQgYmxvYiAlcyBmb3IgcGF0aCAlcyIsCgkJCSAgICBvaWRfdG9faGV4KCZvLT5ibG9iX29pZCksCgkJCSAgICBvLT5wYXRoKTsKCQlvLT5maWxlID0gKmZpbGU7Cgl9CgllbHNlCgkJKmZpbGUgPSBvLT5maWxlOwp9CgpzdGF0aWMgdm9pZCBkcm9wX29yaWdpbl9ibG9iKHN0cnVjdCBibGFtZV9vcmlnaW4gKm8pCnsKCWlmIChvLT5maWxlLnB0cikgewoJCWZyZWUoby0+ZmlsZS5wdHIpOwoJCW8tPmZpbGUucHRyID0gTlVMTDsKCX0KfQoKLyoKICogQW55IG1lcmdlIG9mIGJsYW1lcyBoYXBwZW5zIG9uIGxpc3RzIG9mIGJsYW1lcyB0aGF0IGFycml2ZWQgdmlhCiAqIGRpZmZlcmVudCBwYXJlbnRzIGluIGEgc2luZ2xlIHN1c3BlY3QuICBJbiB0aGlzIGNhc2UsIHdlIHdhbnQgdG8KICogc29ydCBhY2NvcmRpbmcgdG8gdGhlIHN1c3BlY3QgbGluZSBudW1iZXJzIGFzIG9wcG9zZWQgdG8gdGhlIGZpbmFsCiAqIGltYWdlIGxpbmUgbnVtYmVycy4gIFRoZSBmdW5jdGlvbiBib2R5IGlzIHNvbWV3aGF0IGxvbmdpc2ggYmVjYXVzZQogKiBpdCBhdm9pZHMgdW5uZWNlc3Nhcnkgd3JpdGVzLgogKi8KCnN0YXRpYyBzdHJ1Y3QgYmxhbWVfZW50cnkgKmJsYW1lX21lcmdlKHN0cnVjdCBibGFtZV9lbnRyeSAqbGlzdDEsCgkJCQkgICAgICAgc3RydWN0IGJsYW1lX2VudHJ5ICpsaXN0MikKewoJc3RydWN0IGJsYW1lX2VudHJ5ICpwMSA9IGxpc3QxLCAqcDIgPSBsaXN0MiwKCQkqKnRhaWwgPSAmbGlzdDE7CgoJaWYgKCFwMSkKCQlyZXR1cm4gcDI7CglpZiAoIXAyKQoJCXJldHVybiBwMTsKCglpZiAocDEtPnNfbG5vIDw9IHAyLT5zX2xubykgewoJCWRvIHsKCQkJdGFpbCA9ICZwMS0+bmV4dDsKCQkJaWYgKChwMSA9ICp0YWlsKSA9PSBOVUxMKSB7CgkJCQkqdGFpbCA9IHAyOwoJCQkJcmV0dXJuIGxpc3QxOwoJCQl9CgkJfSB3aGlsZSAocDEtPnNfbG5vIDw9IHAyLT5zX2xubyk7Cgl9Cglmb3IgKDs7KSB7CgkJKnRhaWwgPSBwMjsKCQlkbyB7CgkJCXRhaWwgPSAmcDItPm5leHQ7CgkJCWlmICgocDIgPSAqdGFpbCkgPT0gTlVMTCkgIHsKCQkJCSp0YWlsID0gcDE7CgkJCQlyZXR1cm4gbGlzdDE7CgkJCX0KCQl9IHdoaWxlIChwMS0+c19sbm8gPiBwMi0+c19sbm8pOwoJCSp0YWlsID0gcDE7CgkJZG8gewoJCQl0YWlsID0gJnAxLT5uZXh0OwoJCQlpZiAoKHAxID0gKnRhaWwpID09IE5VTEwpIHsKCQkJCSp0YWlsID0gcDI7CgkJCQlyZXR1cm4gbGlzdDE7CgkJCX0KCQl9IHdoaWxlIChwMS0+c19sbm8gPD0gcDItPnNfbG5vKTsKCX0KfQoKc3RhdGljIHZvaWQgKmdldF9uZXh0X2JsYW1lKGNvbnN0IHZvaWQgKnApCnsKCXJldHVybiAoKHN0cnVjdCBibGFtZV9lbnRyeSAqKXApLT5uZXh0Owp9CgpzdGF0aWMgdm9pZCBzZXRfbmV4dF9ibGFtZSh2b2lkICpwMSwgdm9pZCAqcDIpCnsKCSgoc3RydWN0IGJsYW1lX2VudHJ5ICopcDEpLT5uZXh0ID0gcDI7Cn0KCi8qCiAqIEZpbmFsIGltYWdlIGxpbmUgbnVtYmVycyBhcmUgYWxsIGRpZmZlcmVudCwgc28gd2UgZG9uJ3QgbmVlZCBhCiAqIHRocmVlLXdheSBjb21wYXJpc29uIGhlcmUuCiAqLwoKc3RhdGljIGludCBjb21wYXJlX2JsYW1lX2ZpbmFsKGNvbnN0IHZvaWQgKnAxLCBjb25zdCB2b2lkICpwMikKewoJcmV0dXJuICgoc3RydWN0IGJsYW1lX2VudHJ5ICopcDEpLT5sbm8gPiAoKHN0cnVjdCBibGFtZV9lbnRyeSAqKXAyKS0+bG5vCgkJPyAxIDogLTE7Cn0KCnN0YXRpYyBpbnQgY29tcGFyZV9ibGFtZV9zdXNwZWN0KGNvbnN0IHZvaWQgKnAxLCBjb25zdCB2b2lkICpwMikKewoJY29uc3Qgc3RydWN0IGJsYW1lX2VudHJ5ICpzMSA9IHAxLCAqczIgPSBwMjsKCS8qCgkgKiB0byBhbGxvdyBmb3IgY29sbGF0aW5nIHN1c3BlY3RzLCB3ZSBzb3J0IGFjY29yZGluZyB0byB0aGUKCSAqIHJlc3BlY3RpdmUgcG9pbnRlciB2YWx1ZSBhcyB0aGUgcHJpbWFyeSBzb3J0aW5nIGNyaXRlcmlvbi4KCSAqIFRoZSBhY3R1YWwgcmVsYXRpb24gaXMgcHJldHR5IHVuaW1wb3J0YW50IGFzIGxvbmcgYXMgaXQKCSAqIGVzdGFibGlzaGVzIGEgdG90YWwgb3JkZXIuICBDb21wYXJpbmcgYXMgaW50ZWdlcnMgZ2l2ZXMgdXMKCSAqIHRoYXQuCgkgKi8KCWlmIChzMS0+c3VzcGVjdCAhPSBzMi0+c3VzcGVjdCkKCQlyZXR1cm4gKGludHB0cl90KXMxLT5zdXNwZWN0ID4gKGludHB0cl90KXMyLT5zdXNwZWN0ID8gMSA6IC0xOwoJaWYgKHMxLT5zX2xubyA9PSBzMi0+c19sbm8pCgkJcmV0dXJuIDA7CglyZXR1cm4gczEtPnNfbG5vID4gczItPnNfbG5vID8gMSA6IC0xOwp9Cgp2b2lkIGJsYW1lX3NvcnRfZmluYWwoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiKQp7CglzYi0+ZW50ID0gbGxpc3RfbWVyZ2Vzb3J0KHNiLT5lbnQsIGdldF9uZXh0X2JsYW1lLCBzZXRfbmV4dF9ibGFtZSwKCQkJCSAgY29tcGFyZV9ibGFtZV9maW5hbCk7Cn0KCnN0YXRpYyBpbnQgY29tcGFyZV9jb21taXRzX2J5X3JldmVyc2VfY29tbWl0X2RhdGUoY29uc3Qgdm9pZCAqYSwKCQkJCQkJICBjb25zdCB2b2lkICpiLAoJCQkJCQkgIHZvaWQgKmMpCnsKCXJldHVybiAtY29tcGFyZV9jb21taXRzX2J5X2NvbW1pdF9kYXRlKGEsIGIsIGMpOwp9CgovKgogKiBGb3IgZGVidWdnaW5nIC0tIG9yaWdpbiBpcyByZWZjb3VudGVkLCBhbmQgdGhpcyBhc3NlcnRzIHRoYXQKICogd2UgZG8gbm90IHVuZGVyZmxvdy4KICovCnN0YXRpYyB2b2lkIHNhbml0eV9jaGVja19yZWZjbnQoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiKQp7CglpbnQgYmFhID0gMDsKCXN0cnVjdCBibGFtZV9lbnRyeSAqZW50OwoKCWZvciAoZW50ID0gc2ItPmVudDsgZW50OyBlbnQgPSBlbnQtPm5leHQpIHsKCQkvKiBOb2JvZHkgc2hvdWxkIGhhdmUgemVybyBvciBuZWdhdGl2ZSByZWZjbnQgKi8KCQlpZiAoZW50LT5zdXNwZWN0LT5yZWZjbnQgPD0gMCkgewoJCQlmcHJpbnRmKHN0ZGVyciwgIiVzIGluICVzIGhhcyBuZWdhdGl2ZSByZWZjbnQgJWRcbiIsCgkJCQllbnQtPnN1c3BlY3QtPnBhdGgsCgkJCQlvaWRfdG9faGV4KCZlbnQtPnN1c3BlY3QtPmNvbW1pdC0+b2JqZWN0Lm9pZCksCgkJCQllbnQtPnN1c3BlY3QtPnJlZmNudCk7CgkJCWJhYSA9IDE7CgkJfQoJfQoJaWYgKGJhYSkKCQlzYi0+b25fc2FuaXR5X2ZhaWwoc2IsIGJhYSk7Cn0KCi8qCiAqIElmIHR3byBibGFtZSBlbnRyaWVzIHRoYXQgYXJlIG5leHQgdG8gZWFjaCBvdGhlciBjYW1lIGZyb20KICogY29udGlndW91cyBsaW5lcyBpbiB0aGUgc2FtZSBvcmlnaW4gKGkuZS4gPGNvbW1pdCwgcGF0aD4gcGFpciksCiAqIG1lcmdlIHRoZW0gdG9nZXRoZXIuCiAqLwp2b2lkIGJsYW1lX2NvYWxlc2NlKHN0cnVjdCBibGFtZV9zY29yZWJvYXJkICpzYikKewoJc3RydWN0IGJsYW1lX2VudHJ5ICplbnQsICpuZXh0OwoKCWZvciAoZW50ID0gc2ItPmVudDsgZW50ICYmIChuZXh0ID0gZW50LT5uZXh0KTsgZW50ID0gbmV4dCkgewoJCWlmIChlbnQtPnN1c3BlY3QgPT0gbmV4dC0+c3VzcGVjdCAmJgoJCSAgICBlbnQtPnNfbG5vICsgZW50LT5udW1fbGluZXMgPT0gbmV4dC0+c19sbm8pIHsKCQkJZW50LT5udW1fbGluZXMgKz0gbmV4dC0+bnVtX2xpbmVzOwoJCQllbnQtPm5leHQgPSBuZXh0LT5uZXh0OwoJCQlibGFtZV9vcmlnaW5fZGVjcmVmKG5leHQtPnN1c3BlY3QpOwoJCQlmcmVlKG5leHQpOwoJCQllbnQtPnNjb3JlID0gMDsKCQkJbmV4dCA9IGVudDsgLyogYWdhaW4gKi8KCQl9Cgl9CgoJaWYgKHNiLT5kZWJ1ZykgLyogc2FuaXR5ICovCgkJc2FuaXR5X2NoZWNrX3JlZmNudChzYik7Cn0KCi8qCiAqIE1lcmdlIHRoZSBnaXZlbiBzb3J0ZWQgbGlzdCBvZiBibGFtZXMgaW50byBhIHByZWV4aXN0aW5nIG9yaWdpbi4KICogSWYgdGhlcmUgd2VyZSBubyBwcmV2aW91cyBibGFtZXMgdG8gdGhhdCBjb21taXQsIGl0IGlzIGVudGVyZWQgaW50bwogKiB0aGUgY29tbWl0IHByaW9yaXR5IHF1ZXVlIG9mIHRoZSBzY29yZSBib2FyZC4KICovCgpzdGF0aWMgdm9pZCBxdWV1ZV9ibGFtZXMoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLCBzdHJ1Y3QgYmxhbWVfb3JpZ2luICpwb3JpZ2luLAoJCQkgc3RydWN0IGJsYW1lX2VudHJ5ICpzb3J0ZWQpCnsKCWlmIChwb3JpZ2luLT5zdXNwZWN0cykKCQlwb3JpZ2luLT5zdXNwZWN0cyA9IGJsYW1lX21lcmdlKHBvcmlnaW4tPnN1c3BlY3RzLCBzb3J0ZWQpOwoJZWxzZSB7CgkJc3RydWN0IGJsYW1lX29yaWdpbiAqbzsKCQlmb3IgKG8gPSBwb3JpZ2luLT5jb21taXQtPnV0aWw7IG87IG8gPSBvLT5uZXh0KSB7CgkJCWlmIChvLT5zdXNwZWN0cykgewoJCQkJcG9yaWdpbi0+c3VzcGVjdHMgPSBzb3J0ZWQ7CgkJCQlyZXR1cm47CgkJCX0KCQl9CgkJcG9yaWdpbi0+c3VzcGVjdHMgPSBzb3J0ZWQ7CgkJcHJpb19xdWV1ZV9wdXQoJnNiLT5jb21taXRzLCBwb3JpZ2luLT5jb21taXQpOwoJfQp9CgovKgogKiBGaWxsIHRoZSBibG9iX3NoYTEgZmllbGQgb2YgYW4gb3JpZ2luIGlmIGl0IGhhc24ndCwgc28gdGhhdCBsYXRlcgogKiBjYWxsIHRvIGZpbGxfb3JpZ2luX2Jsb2IoKSBjYW4gdXNlIGl0IHRvIGxvY2F0ZSB0aGUgZGF0YS4gIGJsb2Jfc2hhMQogKiBmb3IgYW4gb3JpZ2luIGlzIGFsc28gdXNlZCB0byBwYXNzIHRoZSBibGFtZSBmb3IgdGhlIGVudGlyZSBmaWxlIHRvCiAqIHRoZSBwYXJlbnQgdG8gZGV0ZWN0IHRoZSBjYXNlIHdoZXJlIGEgY2hpbGQncyBibG9iIGlzIGlkZW50aWNhbCB0bwogKiB0aGF0IG9mIGl0cyBwYXJlbnQncy4KICoKICogVGhpcyBhbHNvIGZpbGxzIG9yaWdpbi0+bW9kZSBmb3IgY29ycmVzcG9uZGluZyB0cmVlIHBhdGguCiAqLwpzdGF0aWMgaW50IGZpbGxfYmxvYl9zaGExX2FuZF9tb2RlKHN0cnVjdCBibGFtZV9vcmlnaW4gKm9yaWdpbikKewoJaWYgKCFpc19udWxsX29pZCgmb3JpZ2luLT5ibG9iX29pZCkpCgkJcmV0dXJuIDA7CglpZiAoZ2V0X3RyZWVfZW50cnkob3JpZ2luLT5jb21taXQtPm9iamVjdC5vaWQuaGFzaCwKCQkJICAgb3JpZ2luLT5wYXRoLAoJCQkgICBvcmlnaW4tPmJsb2Jfb2lkLmhhc2gsICZvcmlnaW4tPm1vZGUpKQoJCWdvdG8gZXJyb3Jfb3V0OwoJaWYgKHNoYTFfb2JqZWN0X2luZm8ob3JpZ2luLT5ibG9iX29pZC5oYXNoLCBOVUxMKSAhPSBPQkpfQkxPQikKCQlnb3RvIGVycm9yX291dDsKCXJldHVybiAwOwogZXJyb3Jfb3V0OgoJb2lkY2xyKCZvcmlnaW4tPmJsb2Jfb2lkKTsKCW9yaWdpbi0+bW9kZSA9IFNfSUZJTlZBTElEOwoJcmV0dXJuIC0xOwp9CgovKgogKiBXZSBoYXZlIGFuIG9yaWdpbiAtLSBjaGVjayBpZiB0aGUgc2FtZSBwYXRoIGV4aXN0cyBpbiB0aGUKICogcGFyZW50IGFuZCByZXR1cm4gYW4gb3JpZ2luIHN0cnVjdHVyZSB0byByZXByZXNlbnQgaXQuCiAqLwpzdGF0aWMgc3RydWN0IGJsYW1lX29yaWdpbiAqZmluZF9vcmlnaW4oc3RydWN0IGNvbW1pdCAqcGFyZW50LAoJCQkJICBzdHJ1Y3QgYmxhbWVfb3JpZ2luICpvcmlnaW4pCnsKCXN0cnVjdCBibGFtZV9vcmlnaW4gKnBvcmlnaW47CglzdHJ1Y3QgZGlmZl9vcHRpb25zIGRpZmZfb3B0czsKCWNvbnN0IGNoYXIgKnBhdGhzWzJdOwoKCS8qIEZpcnN0IGNoZWNrIGFueSBleGlzdGluZyBvcmlnaW5zICovCglmb3IgKHBvcmlnaW4gPSBwYXJlbnQtPnV0aWw7IHBvcmlnaW47IHBvcmlnaW4gPSBwb3JpZ2luLT5uZXh0KQoJCWlmICghc3RyY21wKHBvcmlnaW4tPnBhdGgsIG9yaWdpbi0+cGF0aCkpIHsKCQkJLyoKCQkJICogVGhlIHNhbWUgcGF0aCBiZXR3ZWVuIG9yaWdpbiBhbmQgaXRzIHBhcmVudAoJCQkgKiB3aXRob3V0IHJlbmFtaW5nIC0tIHRoZSBtb3N0IGNvbW1vbiBjYXNlLgoJCQkgKi8KCQkJcmV0dXJuIGJsYW1lX29yaWdpbl9pbmNyZWYgKHBvcmlnaW4pOwoJCX0KCgkvKiBTZWUgaWYgdGhlIG9yaWdpbi0+cGF0aCBpcyBkaWZmZXJlbnQgYmV0d2VlbiBwYXJlbnQKCSAqIGFuZCBvcmlnaW4gZmlyc3QuICBNb3N0IG9mIHRoZSB0aW1lIHRoZXkgYXJlIHRoZQoJICogc2FtZSBhbmQgZGlmZi10cmVlIGlzIGZhaXJseSBlZmZpY2llbnQgYWJvdXQgdGhpcy4KCSAqLwoJZGlmZl9zZXR1cCgmZGlmZl9vcHRzKTsKCURJRkZfT1BUX1NFVCgmZGlmZl9vcHRzLCBSRUNVUlNJVkUpOwoJZGlmZl9vcHRzLmRldGVjdF9yZW5hbWUgPSAwOwoJZGlmZl9vcHRzLm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9OT19PVVRQVVQ7CglwYXRoc1swXSA9IG9yaWdpbi0+cGF0aDsKCXBhdGhzWzFdID0gTlVMTDsKCglwYXJzZV9wYXRoc3BlYygmZGlmZl9vcHRzLnBhdGhzcGVjLAoJCSAgICAgICBQQVRIU1BFQ19BTExfTUFHSUMgJiB+UEFUSFNQRUNfTElURVJBTCwKCQkgICAgICAgUEFUSFNQRUNfTElURVJBTF9QQVRILCAiIiwgcGF0aHMpOwoJZGlmZl9zZXR1cF9kb25lKCZkaWZmX29wdHMpOwoKCWlmIChpc19udWxsX29pZCgmb3JpZ2luLT5jb21taXQtPm9iamVjdC5vaWQpKQoJCWRvX2RpZmZfY2FjaGUocGFyZW50LT50cmVlLT5vYmplY3Qub2lkLmhhc2gsICZkaWZmX29wdHMpOwoJZWxzZQoJCWRpZmZfdHJlZV9zaGExKHBhcmVudC0+dHJlZS0+b2JqZWN0Lm9pZC5oYXNoLAoJCQkgICAgICAgb3JpZ2luLT5jb21taXQtPnRyZWUtPm9iamVjdC5vaWQuaGFzaCwKCQkJICAgICAgICIiLCAmZGlmZl9vcHRzKTsKCWRpZmZjb3JlX3N0ZCgmZGlmZl9vcHRzKTsKCglpZiAoIWRpZmZfcXVldWVkX2RpZmYubnIpIHsKCQkvKiBUaGUgcGF0aCBpcyB0aGUgc2FtZSBhcyBwYXJlbnQgKi8KCQlwb3JpZ2luID0gZ2V0X29yaWdpbihwYXJlbnQsIG9yaWdpbi0+cGF0aCk7CgkJb2lkY3B5KCZwb3JpZ2luLT5ibG9iX29pZCwgJm9yaWdpbi0+YmxvYl9vaWQpOwoJCXBvcmlnaW4tPm1vZGUgPSBvcmlnaW4tPm1vZGU7Cgl9IGVsc2UgewoJCS8qCgkJICogU2luY2Ugb3JpZ2luLT5wYXRoIGlzIGEgcGF0aHNwZWMsIGlmIHRoZSBwYXJlbnQKCQkgKiBjb21taXQgaGFkIGl0IGFzIGEgZGlyZWN0b3J5LCB3ZSB3aWxsIHNlZSBhIHdob2xlCgkJICogYnVuY2ggb2YgZGVsZXRpb24gb2YgZmlsZXMgaW4gdGhlIGRpcmVjdG9yeSB0aGF0IHdlCgkJICogZG8gbm90IGNhcmUgYWJvdXQuCgkJICovCgkJaW50IGk7CgkJc3RydWN0IGRpZmZfZmlsZXBhaXIgKnAgPSBOVUxMOwoJCWZvciAoaSA9IDA7IGkgPCBkaWZmX3F1ZXVlZF9kaWZmLm5yOyBpKyspIHsKCQkJY29uc3QgY2hhciAqbmFtZTsKCQkJcCA9IGRpZmZfcXVldWVkX2RpZmYucXVldWVbaV07CgkJCW5hbWUgPSBwLT5vbmUtPnBhdGggPyBwLT5vbmUtPnBhdGggOiBwLT50d28tPnBhdGg7CgkJCWlmICghc3RyY21wKG5hbWUsIG9yaWdpbi0+cGF0aCkpCgkJCQlicmVhazsKCQl9CgkJaWYgKCFwKQoJCQlkaWUoImludGVybmFsIGVycm9yIGluIGJsYW1lOjpmaW5kX29yaWdpbiIpOwoJCXN3aXRjaCAocC0+c3RhdHVzKSB7CgkJZGVmYXVsdDoKCQkJZGllKCJpbnRlcm5hbCBlcnJvciBpbiBibGFtZTo6ZmluZF9vcmlnaW4gKCVjKSIsCgkJCSAgICBwLT5zdGF0dXMpOwoJCWNhc2UgJ00nOgoJCQlwb3JpZ2luID0gZ2V0X29yaWdpbihwYXJlbnQsIG9yaWdpbi0+cGF0aCk7CgkJCW9pZGNweSgmcG9yaWdpbi0+YmxvYl9vaWQsICZwLT5vbmUtPm9pZCk7CgkJCXBvcmlnaW4tPm1vZGUgPSBwLT5vbmUtPm1vZGU7CgkJCWJyZWFrOwoJCWNhc2UgJ0EnOgoJCWNhc2UgJ1QnOgoJCQkvKiBEaWQgbm90IGV4aXN0IGluIHBhcmVudCwgb3IgdHlwZSBjaGFuZ2VkICovCgkJCWJyZWFrOwoJCX0KCX0KCWRpZmZfZmx1c2goJmRpZmZfb3B0cyk7CgljbGVhcl9wYXRoc3BlYygmZGlmZl9vcHRzLnBhdGhzcGVjKTsKCXJldHVybiBwb3JpZ2luOwp9CgovKgogKiBXZSBoYXZlIGFuIG9yaWdpbiAtLSBmaW5kIHRoZSBwYXRoIHRoYXQgY29ycmVzcG9uZHMgdG8gaXQgaW4gaXRzCiAqIHBhcmVudCBhbmQgcmV0dXJuIGFuIG9yaWdpbiBzdHJ1Y3R1cmUgdG8gcmVwcmVzZW50IGl0LgogKi8Kc3RhdGljIHN0cnVjdCBibGFtZV9vcmlnaW4gKmZpbmRfcmVuYW1lKHN0cnVjdCBjb21taXQgKnBhcmVudCwKCQkJCSAgc3RydWN0IGJsYW1lX29yaWdpbiAqb3JpZ2luKQp7CglzdHJ1Y3QgYmxhbWVfb3JpZ2luICpwb3JpZ2luID0gTlVMTDsKCXN0cnVjdCBkaWZmX29wdGlvbnMgZGlmZl9vcHRzOwoJaW50IGk7CgoJZGlmZl9zZXR1cCgmZGlmZl9vcHRzKTsKCURJRkZfT1BUX1NFVCgmZGlmZl9vcHRzLCBSRUNVUlNJVkUpOwoJZGlmZl9vcHRzLmRldGVjdF9yZW5hbWUgPSBESUZGX0RFVEVDVF9SRU5BTUU7CglkaWZmX29wdHMub3V0cHV0X2Zvcm1hdCA9IERJRkZfRk9STUFUX05PX09VVFBVVDsKCWRpZmZfb3B0cy5zaW5nbGVfZm9sbG93ID0gb3JpZ2luLT5wYXRoOwoJZGlmZl9zZXR1cF9kb25lKCZkaWZmX29wdHMpOwoKCWlmIChpc19udWxsX29pZCgmb3JpZ2luLT5jb21taXQtPm9iamVjdC5vaWQpKQoJCWRvX2RpZmZfY2FjaGUocGFyZW50LT50cmVlLT5vYmplY3Qub2lkLmhhc2gsICZkaWZmX29wdHMpOwoJZWxzZQoJCWRpZmZfdHJlZV9zaGExKHBhcmVudC0+dHJlZS0+b2JqZWN0Lm9pZC5oYXNoLAoJCQkgICAgICAgb3JpZ2luLT5jb21taXQtPnRyZWUtPm9iamVjdC5vaWQuaGFzaCwKCQkJICAgICAgICIiLCAmZGlmZl9vcHRzKTsKCWRpZmZjb3JlX3N0ZCgmZGlmZl9vcHRzKTsKCglmb3IgKGkgPSAwOyBpIDwgZGlmZl9xdWV1ZWRfZGlmZi5ucjsgaSsrKSB7CgkJc3RydWN0IGRpZmZfZmlsZXBhaXIgKnAgPSBkaWZmX3F1ZXVlZF9kaWZmLnF1ZXVlW2ldOwoJCWlmICgocC0+c3RhdHVzID09ICdSJyB8fCBwLT5zdGF0dXMgPT0gJ0MnKSAmJgoJCSAgICAhc3RyY21wKHAtPnR3by0+cGF0aCwgb3JpZ2luLT5wYXRoKSkgewoJCQlwb3JpZ2luID0gZ2V0X29yaWdpbihwYXJlbnQsIHAtPm9uZS0+cGF0aCk7CgkJCW9pZGNweSgmcG9yaWdpbi0+YmxvYl9vaWQsICZwLT5vbmUtPm9pZCk7CgkJCXBvcmlnaW4tPm1vZGUgPSBwLT5vbmUtPm1vZGU7CgkJCWJyZWFrOwoJCX0KCX0KCWRpZmZfZmx1c2goJmRpZmZfb3B0cyk7CgljbGVhcl9wYXRoc3BlYygmZGlmZl9vcHRzLnBhdGhzcGVjKTsKCXJldHVybiBwb3JpZ2luOwp9CgovKgogKiBBcHBlbmQgYSBuZXcgYmxhbWUgZW50cnkgdG8gYSBnaXZlbiBvdXRwdXQgcXVldWUuCiAqLwpzdGF0aWMgdm9pZCBhZGRfYmxhbWVfZW50cnkoc3RydWN0IGJsYW1lX2VudHJ5ICoqKnF1ZXVlLAoJCQkgICAgY29uc3Qgc3RydWN0IGJsYW1lX2VudHJ5ICpzcmMpCnsKCXN0cnVjdCBibGFtZV9lbnRyeSAqZSA9IHhtYWxsb2Moc2l6ZW9mKCplKSk7CgltZW1jcHkoZSwgc3JjLCBzaXplb2YoKmUpKTsKCWJsYW1lX29yaWdpbl9pbmNyZWYoZS0+c3VzcGVjdCk7CgoJZS0+bmV4dCA9ICoqcXVldWU7CgkqKnF1ZXVlID0gZTsKCSpxdWV1ZSA9ICZlLT5uZXh0Owp9CgovKgogKiBzcmMgdHlwaWNhbGx5IGlzIG9uLXN0YWNrOyB3ZSB3YW50IHRvIGNvcHkgdGhlIGluZm9ybWF0aW9uIGluIGl0IHRvCiAqIGEgbWFsbG9jZWQgYmxhbWVfZW50cnkgdGhhdCBnZXRzIGFkZGVkIHRvIHRoZSBnaXZlbiBxdWV1ZS4gIFRoZQogKiBvcmlnaW4gb2YgZHN0IGxvc2VzIGEgcmVmY250LgogKi8Kc3RhdGljIHZvaWQgZHVwX2VudHJ5KHN0cnVjdCBibGFtZV9lbnRyeSAqKipxdWV1ZSwKCQkgICAgICBzdHJ1Y3QgYmxhbWVfZW50cnkgKmRzdCwgc3RydWN0IGJsYW1lX2VudHJ5ICpzcmMpCnsKCWJsYW1lX29yaWdpbl9pbmNyZWYoc3JjLT5zdXNwZWN0KTsKCWJsYW1lX29yaWdpbl9kZWNyZWYoZHN0LT5zdXNwZWN0KTsKCW1lbWNweShkc3QsIHNyYywgc2l6ZW9mKCpzcmMpKTsKCWRzdC0+bmV4dCA9ICoqcXVldWU7CgkqKnF1ZXVlID0gZHN0OwoJKnF1ZXVlID0gJmRzdC0+bmV4dDsKfQoKY29uc3QgY2hhciAqYmxhbWVfbnRoX2xpbmUoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLCBsb25nIGxubykKewoJcmV0dXJuIHNiLT5maW5hbF9idWYgKyBzYi0+bGluZW5vW2xub107Cn0KCi8qCiAqIEl0IGlzIGtub3duIHRoYXQgbGluZXMgYmV0d2VlbiB0bG5vIHRvIHNhbWUgY2FtZSBmcm9tIHBhcmVudCwgYW5kIGUKICogaGFzIGFuIG92ZXJsYXAgd2l0aCB0aGF0IHJhbmdlLiAgaXQgYWxzbyBpcyBrbm93biB0aGF0IHBhcmVudCdzCiAqIGxpbmUgcGxubyBjb3JyZXNwb25kcyB0byBlJ3MgbGluZSB0bG5vLgogKgogKiAgICAgICAgICAgICAgICA8LS0tLSBlIC0tLS0tPgogKiAgICAgICAgICAgICAgICAgICA8LS0tLS0tPgogKiAgICAgICAgICAgICAgICAgICA8LS0tLS0tLS0tLS0tPgogKiAgICAgICAgICAgICA8LS0tLS0tLS0tLS0tPgogKiAgICAgICAgICAgICA8LS0tLS0tLS0tLS0tLS0tLS0tPgogKgogKiBTcGxpdCBlIGludG8gcG90ZW50aWFsbHkgdGhyZWUgcGFydHM7IGJlZm9yZSB0aGlzIGNodW5rLCB0aGUgY2h1bmsKICogdG8gYmUgYmxhbWVkIGZvciB0aGUgcGFyZW50LCBhbmQgYWZ0ZXIgdGhhdCBwb3J0aW9uLgogKi8Kc3RhdGljIHZvaWQgc3BsaXRfb3ZlcmxhcChzdHJ1Y3QgYmxhbWVfZW50cnkgKnNwbGl0LAoJCQkgIHN0cnVjdCBibGFtZV9lbnRyeSAqZSwKCQkJICBpbnQgdGxubywgaW50IHBsbm8sIGludCBzYW1lLAoJCQkgIHN0cnVjdCBibGFtZV9vcmlnaW4gKnBhcmVudCkKewoJaW50IGNodW5rX2VuZF9sbm87CgltZW1zZXQoc3BsaXQsIDAsIHNpemVvZihzdHJ1Y3QgYmxhbWVfZW50cnkgWzNdKSk7CgoJaWYgKGUtPnNfbG5vIDwgdGxubykgewoJCS8qIHRoZXJlIGlzIGEgcHJlLWNodW5rIHBhcnQgbm90IGJsYW1lZCBvbiBwYXJlbnQgKi8KCQlzcGxpdFswXS5zdXNwZWN0ID0gYmxhbWVfb3JpZ2luX2luY3JlZihlLT5zdXNwZWN0KTsKCQlzcGxpdFswXS5sbm8gPSBlLT5sbm87CgkJc3BsaXRbMF0uc19sbm8gPSBlLT5zX2xubzsKCQlzcGxpdFswXS5udW1fbGluZXMgPSB0bG5vIC0gZS0+c19sbm87CgkJc3BsaXRbMV0ubG5vID0gZS0+bG5vICsgdGxubyAtIGUtPnNfbG5vOwoJCXNwbGl0WzFdLnNfbG5vID0gcGxubzsKCX0KCWVsc2UgewoJCXNwbGl0WzFdLmxubyA9IGUtPmxubzsKCQlzcGxpdFsxXS5zX2xubyA9IHBsbm8gKyAoZS0+c19sbm8gLSB0bG5vKTsKCX0KCglpZiAoc2FtZSA8IGUtPnNfbG5vICsgZS0+bnVtX2xpbmVzKSB7CgkJLyogdGhlcmUgaXMgYSBwb3N0LWNodW5rIHBhcnQgbm90IGJsYW1lZCBvbiBwYXJlbnQgKi8KCQlzcGxpdFsyXS5zdXNwZWN0ID0gYmxhbWVfb3JpZ2luX2luY3JlZihlLT5zdXNwZWN0KTsKCQlzcGxpdFsyXS5sbm8gPSBlLT5sbm8gKyAoc2FtZSAtIGUtPnNfbG5vKTsKCQlzcGxpdFsyXS5zX2xubyA9IGUtPnNfbG5vICsgKHNhbWUgLSBlLT5zX2xubyk7CgkJc3BsaXRbMl0ubnVtX2xpbmVzID0gZS0+c19sbm8gKyBlLT5udW1fbGluZXMgLSBzYW1lOwoJCWNodW5rX2VuZF9sbm8gPSBzcGxpdFsyXS5sbm87Cgl9CgllbHNlCgkJY2h1bmtfZW5kX2xubyA9IGUtPmxubyArIGUtPm51bV9saW5lczsKCXNwbGl0WzFdLm51bV9saW5lcyA9IGNodW5rX2VuZF9sbm8gLSBzcGxpdFsxXS5sbm87CgoJLyoKCSAqIGlmIGl0IHR1cm5zIG91dCB0aGVyZSBpcyBub3RoaW5nIHRvIGJsYW1lIHRoZSBwYXJlbnQgZm9yLAoJICogZm9yZ2V0IGFib3V0IHRoZSBzcGxpdHRpbmcuICAhc3BsaXRbMV0uc3VzcGVjdCBzaWduYWxzIHRoaXMuCgkgKi8KCWlmIChzcGxpdFsxXS5udW1fbGluZXMgPCAxKQoJCXJldHVybjsKCXNwbGl0WzFdLnN1c3BlY3QgPSBibGFtZV9vcmlnaW5faW5jcmVmKHBhcmVudCk7Cn0KCi8qCiAqIHNwbGl0X292ZXJsYXAoKSBkaXZpZGVkIGFuIGV4aXN0aW5nIGJsYW1lIGUgaW50byB1cCB0byB0aHJlZSBwYXJ0cwogKiBpbiBzcGxpdC4gIEFueSBhc3NpZ25lZCBibGFtZSBpcyBtb3ZlZCB0byBxdWV1ZSB0bwogKiByZWZsZWN0IHRoZSBzcGxpdC4KICovCnN0YXRpYyB2b2lkIHNwbGl0X2JsYW1lKHN0cnVjdCBibGFtZV9lbnRyeSAqKipibGFtZWQsCgkJCXN0cnVjdCBibGFtZV9lbnRyeSAqKip1bmJsYW1lZCwKCQkJc3RydWN0IGJsYW1lX2VudHJ5ICpzcGxpdCwKCQkJc3RydWN0IGJsYW1lX2VudHJ5ICplKQp7CglpZiAoc3BsaXRbMF0uc3VzcGVjdCAmJiBzcGxpdFsyXS5zdXNwZWN0KSB7CgkJLyogVGhlIGZpcnN0IHBhcnQgKHJldXNlIHN0b3JhZ2UgZm9yIHRoZSBleGlzdGluZyBlbnRyeSBlKSAqLwoJCWR1cF9lbnRyeSh1bmJsYW1lZCwgZSwgJnNwbGl0WzBdKTsKCgkJLyogVGhlIGxhc3QgcGFydCAtLSBtZSAqLwoJCWFkZF9ibGFtZV9lbnRyeSh1bmJsYW1lZCwgJnNwbGl0WzJdKTsKCgkJLyogLi4uIGFuZCB0aGUgbWlkZGxlIHBhcnQgLS0gcGFyZW50ICovCgkJYWRkX2JsYW1lX2VudHJ5KGJsYW1lZCwgJnNwbGl0WzFdKTsKCX0KCWVsc2UgaWYgKCFzcGxpdFswXS5zdXNwZWN0ICYmICFzcGxpdFsyXS5zdXNwZWN0KQoJCS8qCgkJICogVGhlIHBhcmVudCBjb3ZlcnMgdGhlIGVudGlyZSBhcmVhOyByZXVzZSBzdG9yYWdlIGZvcgoJCSAqIGUgYW5kIHJlcGxhY2UgaXQgd2l0aCB0aGUgcGFyZW50LgoJCSAqLwoJCWR1cF9lbnRyeShibGFtZWQsIGUsICZzcGxpdFsxXSk7CgllbHNlIGlmIChzcGxpdFswXS5zdXNwZWN0KSB7CgkJLyogbWUgYW5kIHRoZW4gcGFyZW50ICovCgkJZHVwX2VudHJ5KHVuYmxhbWVkLCBlLCAmc3BsaXRbMF0pOwoJCWFkZF9ibGFtZV9lbnRyeShibGFtZWQsICZzcGxpdFsxXSk7Cgl9CgllbHNlIHsKCQkvKiBwYXJlbnQgYW5kIHRoZW4gbWUgKi8KCQlkdXBfZW50cnkoYmxhbWVkLCBlLCAmc3BsaXRbMV0pOwoJCWFkZF9ibGFtZV9lbnRyeSh1bmJsYW1lZCwgJnNwbGl0WzJdKTsKCX0KfQoKLyoKICogQWZ0ZXIgc3BsaXR0aW5nIHRoZSBibGFtZSwgdGhlIG9yaWdpbnMgdXNlZCBieSB0aGUKICogb24tc3RhY2sgYmxhbWVfZW50cnkgc2hvdWxkIGxvc2Ugb25lIHJlZmNudCBlYWNoLgogKi8Kc3RhdGljIHZvaWQgZGVjcmVmX3NwbGl0KHN0cnVjdCBibGFtZV9lbnRyeSAqc3BsaXQpCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCAzOyBpKyspCgkJYmxhbWVfb3JpZ2luX2RlY3JlZihzcGxpdFtpXS5zdXNwZWN0KTsKfQoKLyoKICogcmV2ZXJzZV9ibGFtZSByZXZlcnNlcyB0aGUgbGlzdCBnaXZlbiBpbiBoZWFkLCBhcHBlbmRpbmcgdGFpbC4KICogVGhhdCBhbGxvd3MgdXMgdG8gYnVpbGQgbGlzdHMgaW4gcmV2ZXJzZSBvcmRlciwgdGhlbiByZXZlcnNlIHRoZW0KICogYWZ0ZXJ3YXJkcy4gIFRoaXMgY2FuIGJlIGZhc3RlciB0aGFuIGJ1aWxkaW5nIHRoZSBsaXN0IGluIHByb3BlcgogKiBvcmRlciByaWdodCBhd2F5LiAgVGhlIHJlYXNvbiBpcyB0aGF0IGJ1aWxkaW5nIGluIHByb3BlciBvcmRlcgogKiByZXF1aXJlcyB3cml0aW5nIGEgbGluayBpbiB0aGUgX3ByZXZpb3VzXyBlbGVtZW50LCB3aGlsZSBidWlsZGluZwogKiBpbiByZXZlcnNlIG9yZGVyIGp1c3QgcmVxdWlyZXMgcGxhY2luZyB0aGUgbGlzdCBoZWFkIGludG8gdGhlCiAqIF9jdXJyZW50XyBlbGVtZW50LgogKi8KCnN0YXRpYyBzdHJ1Y3QgYmxhbWVfZW50cnkgKnJldmVyc2VfYmxhbWUoc3RydWN0IGJsYW1lX2VudHJ5ICpoZWFkLAoJCQkJCSBzdHJ1Y3QgYmxhbWVfZW50cnkgKnRhaWwpCnsKCXdoaWxlIChoZWFkKSB7CgkJc3RydWN0IGJsYW1lX2VudHJ5ICpuZXh0ID0gaGVhZC0+bmV4dDsKCQloZWFkLT5uZXh0ID0gdGFpbDsKCQl0YWlsID0gaGVhZDsKCQloZWFkID0gbmV4dDsKCX0KCXJldHVybiB0YWlsOwp9CgovKgogKiBQcm9jZXNzIG9uZSBodW5rIGZyb20gdGhlIHBhdGNoIGJldHdlZW4gdGhlIGN1cnJlbnQgc3VzcGVjdCBmb3IKICogYmxhbWVfZW50cnkgZSBhbmQgaXRzIHBhcmVudC4gIFRoaXMgZmlyc3QgYmxhbWVzIGFueSB1bmZpbmlzaGVkCiAqIGVudHJpZXMgYmVmb3JlIHRoZSBjaHVuayAod2hpY2ggaXMgd2hlcmUgdGFyZ2V0IGFuZCBwYXJlbnQgc3RhcnQKICogZGlmZmVyaW5nKSBvbiB0aGUgcGFyZW50LCBhbmQgdGhlbiBzcGxpdHMgYmxhbWUgZW50cmllcyBhdCB0aGUKICogc3RhcnQgYW5kIGF0IHRoZSBlbmQgb2YgdGhlIGRpZmZlcmVuY2UgcmVnaW9uLiAgU2luY2UgdXNlIG9mIC1NIGFuZAogKiAtQyBvcHRpb25zIG1heSBsZWFkIHRvIG92ZXJsYXBwaW5nL2R1cGxpY2F0ZSBzb3VyY2UgbGluZSBudW1iZXIKICogcmFuZ2VzLCBhbGwgd2UgY2FuIHJlbHkgb24gZnJvbSBzb3J0aW5nL21lcmdpbmcgaXMgdGhlIG9yZGVyIG9mIHRoZQogKiBmaXJzdCBzdXNwZWN0IGxpbmUgbnVtYmVyLgogKi8Kc3RhdGljIHZvaWQgYmxhbWVfY2h1bmsoc3RydWN0IGJsYW1lX2VudHJ5ICoqKmRzdHEsIHN0cnVjdCBibGFtZV9lbnRyeSAqKipzcmNxLAoJCQlpbnQgdGxubywgaW50IG9mZnNldCwgaW50IHNhbWUsCgkJCXN0cnVjdCBibGFtZV9vcmlnaW4gKnBhcmVudCkKewoJc3RydWN0IGJsYW1lX2VudHJ5ICplID0gKipzcmNxOwoJc3RydWN0IGJsYW1lX2VudHJ5ICpzYW1lcCA9IE5VTEwsICpkaWZmcCA9IE5VTEw7CgoJd2hpbGUgKGUgJiYgZS0+c19sbm8gPCB0bG5vKSB7CgkJc3RydWN0IGJsYW1lX2VudHJ5ICpuZXh0ID0gZS0+bmV4dDsKCQkvKgoJCSAqIGN1cnJlbnQgcmVjb3JkIHN0YXJ0cyBiZWZvcmUgZGlmZmVyaW5nIHBvcnRpb24uICBJZgoJCSAqIGl0IHJlYWNoZXMgaW50byBpdCwgd2UgbmVlZCB0byBzcGxpdCBpdCB1cCBhbmQKCQkgKiBleGFtaW5lIHRoZSBzZWNvbmQgcGFydCBzZXBhcmF0ZWx5LgoJCSAqLwoJCWlmIChlLT5zX2xubyArIGUtPm51bV9saW5lcyA+IHRsbm8pIHsKCQkJLyogTW92ZSBzZWNvbmQgaGFsZiB0byBhIG5ldyByZWNvcmQgKi8KCQkJaW50IGxlbiA9IHRsbm8gLSBlLT5zX2xubzsKCQkJc3RydWN0IGJsYW1lX2VudHJ5ICpuID0geGNhbGxvYygxLCBzaXplb2YgKHN0cnVjdCBibGFtZV9lbnRyeSkpOwoJCQluLT5zdXNwZWN0ID0gZS0+c3VzcGVjdDsKCQkJbi0+bG5vID0gZS0+bG5vICsgbGVuOwoJCQluLT5zX2xubyA9IGUtPnNfbG5vICsgbGVuOwoJCQluLT5udW1fbGluZXMgPSBlLT5udW1fbGluZXMgLSBsZW47CgkJCWUtPm51bV9saW5lcyA9IGxlbjsKCQkJZS0+c2NvcmUgPSAwOwoJCQkvKiBQdXNoIG5ldyByZWNvcmQgdG8gZGlmZnAgKi8KCQkJbi0+bmV4dCA9IGRpZmZwOwoJCQlkaWZmcCA9IG47CgkJfSBlbHNlCgkJCWJsYW1lX29yaWdpbl9kZWNyZWYoZS0+c3VzcGVjdCk7CgkJLyogUGFzcyBibGFtZSBmb3IgZXZlcnl0aGluZyBiZWZvcmUgdGhlIGRpZmZlcmluZwoJCSAqIGNodW5rIHRvIHRoZSBwYXJlbnQgKi8KCQllLT5zdXNwZWN0ID0gYmxhbWVfb3JpZ2luX2luY3JlZihwYXJlbnQpOwoJCWUtPnNfbG5vICs9IG9mZnNldDsKCQllLT5uZXh0ID0gc2FtZXA7CgkJc2FtZXAgPSBlOwoJCWUgPSBuZXh0OwoJfQoJLyoKCSAqIEFzIHdlIGRvbid0IGtub3cgaG93IG11Y2ggb2YgYSBjb21tb24gc3RyZXRjaCBhZnRlciB0aGlzCgkgKiBkaWZmIHdpbGwgb2NjdXIsIHRoZSBjdXJyZW50bHkgYmxhbWVkIHBhcnRzIGFyZSBhbGwgdGhhdCB3ZQoJICogY2FuIGFzc2lnbiB0byB0aGUgcGFyZW50IGZvciBub3cuCgkgKi8KCglpZiAoc2FtZXApIHsKCQkqKmRzdHEgPSByZXZlcnNlX2JsYW1lKHNhbWVwLCAqKmRzdHEpOwoJCSpkc3RxID0gJnNhbWVwLT5uZXh0OwoJfQoJLyoKCSAqIFByZXBlbmQgdGhlIHNwbGl0IG9mZiBwb3J0aW9uczogZXZlcnl0aGluZyBhZnRlciBlIHN0YXJ0cwoJICogYWZ0ZXIgdGhlIGJsYW1lYWJsZSBwb3J0aW9uLgoJICovCgllID0gcmV2ZXJzZV9ibGFtZShkaWZmcCwgZSk7CgoJLyoKCSAqIE5vdyByZXRhaW4gcmVjb3JkcyBvbiB0aGUgdGFyZ2V0IHdoaWxlIHBhcnRzIGFyZSBkaWZmZXJlbnQKCSAqIGZyb20gdGhlIHBhcmVudC4KCSAqLwoJc2FtZXAgPSBOVUxMOwoJZGlmZnAgPSBOVUxMOwoJd2hpbGUgKGUgJiYgZS0+c19sbm8gPCBzYW1lKSB7CgkJc3RydWN0IGJsYW1lX2VudHJ5ICpuZXh0ID0gZS0+bmV4dDsKCgkJLyoKCQkgKiBJZiBjdXJyZW50IHJlY29yZCBleHRlbmRzIGludG8gc2FtZW5lc3MsIG5lZWQgdG8gc3BsaXQuCgkJICovCgkJaWYgKGUtPnNfbG5vICsgZS0+bnVtX2xpbmVzID4gc2FtZSkgewoJCQkvKgoJCQkgKiBNb3ZlIHNlY29uZCBoYWxmIHRvIGEgbmV3IHJlY29yZCB0byBiZQoJCQkgKiBwcm9jZXNzZWQgYnkgbGF0ZXIgY2h1bmtzCgkJCSAqLwoJCQlpbnQgbGVuID0gc2FtZSAtIGUtPnNfbG5vOwoJCQlzdHJ1Y3QgYmxhbWVfZW50cnkgKm4gPSB4Y2FsbG9jKDEsIHNpemVvZiAoc3RydWN0IGJsYW1lX2VudHJ5KSk7CgkJCW4tPnN1c3BlY3QgPSBibGFtZV9vcmlnaW5faW5jcmVmKGUtPnN1c3BlY3QpOwoJCQluLT5sbm8gPSBlLT5sbm8gKyBsZW47CgkJCW4tPnNfbG5vID0gZS0+c19sbm8gKyBsZW47CgkJCW4tPm51bV9saW5lcyA9IGUtPm51bV9saW5lcyAtIGxlbjsKCQkJZS0+bnVtX2xpbmVzID0gbGVuOwoJCQllLT5zY29yZSA9IDA7CgkJCS8qIFB1c2ggbmV3IHJlY29yZCB0byBzYW1lcCAqLwoJCQluLT5uZXh0ID0gc2FtZXA7CgkJCXNhbWVwID0gbjsKCQl9CgkJZS0+bmV4dCA9IGRpZmZwOwoJCWRpZmZwID0gZTsKCQllID0gbmV4dDsKCX0KCSoqc3JjcSA9IHJldmVyc2VfYmxhbWUoZGlmZnAsIHJldmVyc2VfYmxhbWUoc2FtZXAsIGUpKTsKCS8qIE1vdmUgYWNyb3NzIGVsZW1lbnRzIHRoYXQgYXJlIGluIHRoZSB1bmJsYW1hYmxlIHBvcnRpb24gKi8KCWlmIChkaWZmcCkKCQkqc3JjcSA9ICZkaWZmcC0+bmV4dDsKfQoKc3RydWN0IGJsYW1lX2NodW5rX2NiX2RhdGEgewoJc3RydWN0IGJsYW1lX29yaWdpbiAqcGFyZW50OwoJbG9uZyBvZmZzZXQ7CglzdHJ1Y3QgYmxhbWVfZW50cnkgKipkc3RxOwoJc3RydWN0IGJsYW1lX2VudHJ5ICoqc3JjcTsKfTsKCi8qIGRpZmYgY2h1bmtzIGFyZSBmcm9tIHBhcmVudCB0byB0YXJnZXQgKi8Kc3RhdGljIGludCBibGFtZV9jaHVua19jYihsb25nIHN0YXJ0X2EsIGxvbmcgY291bnRfYSwKCQkJICBsb25nIHN0YXJ0X2IsIGxvbmcgY291bnRfYiwgdm9pZCAqZGF0YSkKewoJc3RydWN0IGJsYW1lX2NodW5rX2NiX2RhdGEgKmQgPSBkYXRhOwoJaWYgKHN0YXJ0X2EgLSBzdGFydF9iICE9IGQtPm9mZnNldCkKCQlkaWUoImludGVybmFsIGVycm9yIGluIGJsYW1lOjpibGFtZV9jaHVua19jYiIpOwoJYmxhbWVfY2h1bmsoJmQtPmRzdHEsICZkLT5zcmNxLCBzdGFydF9iLCBzdGFydF9hIC0gc3RhcnRfYiwKCQkgICAgc3RhcnRfYiArIGNvdW50X2IsIGQtPnBhcmVudCk7CglkLT5vZmZzZXQgPSBzdGFydF9hICsgY291bnRfYSAtIChzdGFydF9iICsgY291bnRfYik7CglyZXR1cm4gMDsKfQoKLyoKICogV2UgYXJlIGxvb2tpbmcgYXQgdGhlIG9yaWdpbiAndGFyZ2V0JyBhbmQgYWltaW5nIHRvIHBhc3MgYmxhbWUKICogZm9yIHRoZSBsaW5lcyBpdCBpcyBzdXNwZWN0ZWQgdG8gaXRzIHBhcmVudC4gIFJ1biBkaWZmIHRvIGZpbmQKICogd2hpY2ggbGluZXMgY2FtZSBmcm9tIHBhcmVudCBhbmQgcGFzcyBibGFtZSBmb3IgdGhlbS4KICovCnN0YXRpYyB2b2lkIHBhc3NfYmxhbWVfdG9fcGFyZW50KHN0cnVjdCBibGFtZV9zY29yZWJvYXJkICpzYiwKCQkJCSBzdHJ1Y3QgYmxhbWVfb3JpZ2luICp0YXJnZXQsCgkJCQkgc3RydWN0IGJsYW1lX29yaWdpbiAqcGFyZW50KQp7CgltbWZpbGVfdCBmaWxlX3AsIGZpbGVfbzsKCXN0cnVjdCBibGFtZV9jaHVua19jYl9kYXRhIGQ7CglzdHJ1Y3QgYmxhbWVfZW50cnkgKm5ld2Rlc3QgPSBOVUxMOwoKCWlmICghdGFyZ2V0LT5zdXNwZWN0cykKCQlyZXR1cm47IC8qIG5vdGhpbmcgcmVtYWlucyBmb3IgdGhpcyB0YXJnZXQgKi8KCglkLnBhcmVudCA9IHBhcmVudDsKCWQub2Zmc2V0ID0gMDsKCWQuZHN0cSA9ICZuZXdkZXN0OyBkLnNyY3EgPSAmdGFyZ2V0LT5zdXNwZWN0czsKCglmaWxsX29yaWdpbl9ibG9iKCZzYi0+cmV2cy0+ZGlmZm9wdCwgcGFyZW50LCAmZmlsZV9wLCAmc2ItPm51bV9yZWFkX2Jsb2IpOwoJZmlsbF9vcmlnaW5fYmxvYigmc2ItPnJldnMtPmRpZmZvcHQsIHRhcmdldCwgJmZpbGVfbywgJnNiLT5udW1fcmVhZF9ibG9iKTsKCXNiLT5udW1fZ2V0X3BhdGNoKys7CgoJaWYgKGRpZmZfaHVua3MoJmZpbGVfcCwgJmZpbGVfbywgYmxhbWVfY2h1bmtfY2IsICZkLCBzYi0+eGRsX29wdHMpKQoJCWRpZSgidW5hYmxlIHRvIGdlbmVyYXRlIGRpZmYgKCVzIC0+ICVzKSIsCgkJICAgIG9pZF90b19oZXgoJnBhcmVudC0+Y29tbWl0LT5vYmplY3Qub2lkKSwKCQkgICAgb2lkX3RvX2hleCgmdGFyZ2V0LT5jb21taXQtPm9iamVjdC5vaWQpKTsKCS8qIFRoZSByZXN0IGFyZSB0aGUgc2FtZSBhcyB0aGUgcGFyZW50ICovCglibGFtZV9jaHVuaygmZC5kc3RxLCAmZC5zcmNxLCBJTlRfTUFYLCBkLm9mZnNldCwgSU5UX01BWCwgcGFyZW50KTsKCSpkLmRzdHEgPSBOVUxMOwoJcXVldWVfYmxhbWVzKHNiLCBwYXJlbnQsIG5ld2Rlc3QpOwoKCXJldHVybjsKfQoKLyoKICogVGhlIGxpbmVzIGluIGJsYW1lX2VudHJ5IGFmdGVyIHNwbGl0dGluZyBibGFtZXMgbWFueSB0aW1lcyBjYW4gYmVjb21lCiAqIHZlcnkgc21hbGwgYW5kIHRyaXZpYWwsIGFuZCBhdCBzb21lIHBvaW50IGl0IGJlY29tZXMgcG9pbnRsZXNzIHRvCiAqIGJsYW1lIHRoZSBwYXJlbnRzLiAgRS5nLiAiXHRcdH1cblx0fVxuXG4iIGFwcGVhcnMgZXZlcnl3aGVyZSBpbiBhbnkKICogb3JkaW5hcnkgQyBwcm9ncmFtLCBhbmQgaXQgaXMgbm90IHdvcnRoIHRvIHNheSBpdCB3YXMgY29waWVkIGZyb20KICogdG90YWxseSB1bnJlbGF0ZWQgZmlsZSBpbiB0aGUgcGFyZW50LgogKgogKiBDb21wdXRlIGhvdyB0cml2aWFsIHRoZSBsaW5lcyBpbiB0aGUgYmxhbWVfZW50cnkgYXJlLgogKi8KdW5zaWduZWQgYmxhbWVfZW50cnlfc2NvcmUoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLCBzdHJ1Y3QgYmxhbWVfZW50cnkgKmUpCnsKCXVuc2lnbmVkIHNjb3JlOwoJY29uc3QgY2hhciAqY3AsICplcDsKCglpZiAoZS0+c2NvcmUpCgkJcmV0dXJuIGUtPnNjb3JlOwoKCXNjb3JlID0gMTsKCWNwID0gYmxhbWVfbnRoX2xpbmUoc2IsIGUtPmxubyk7CgllcCA9IGJsYW1lX250aF9saW5lKHNiLCBlLT5sbm8gKyBlLT5udW1fbGluZXMpOwoJd2hpbGUgKGNwIDwgZXApIHsKCQl1bnNpZ25lZCBjaCA9ICooKHVuc2lnbmVkIGNoYXIgKiljcCk7CgkJaWYgKGlzYWxudW0oY2gpKQoJCQlzY29yZSsrOwoJCWNwKys7Cgl9CgllLT5zY29yZSA9IHNjb3JlOwoJcmV0dXJuIHNjb3JlOwp9CgovKgogKiBiZXN0X3NvX2ZhcltdIGFuZCB0aGlzW10gYXJlIGJvdGggYSBzcGxpdCBvZiBhbiBleGlzdGluZyBibGFtZV9lbnRyeQogKiB0aGF0IHBhc3NlcyBibGFtZSB0byB0aGUgcGFyZW50LiAgTWFpbnRhaW4gYmVzdF9zb19mYXIgdGhlIGJlc3Qgc3BsaXQKICogc28gZmFyLCBieSBjb21wYXJpbmcgdGhpcyBhbmQgYmVzdF9zb19mYXIgYW5kIGNvcHlpbmcgdGhpcyBpbnRvCiAqIGJzdF9zb19mYXIgYXMgbmVlZGVkLgogKi8Kc3RhdGljIHZvaWQgY29weV9zcGxpdF9pZl9iZXR0ZXIoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLAoJCQkJIHN0cnVjdCBibGFtZV9lbnRyeSAqYmVzdF9zb19mYXIsCgkJCQkgc3RydWN0IGJsYW1lX2VudHJ5ICp0aGlzKQp7CglpbnQgaTsKCglpZiAoIXRoaXNbMV0uc3VzcGVjdCkKCQlyZXR1cm47CglpZiAoYmVzdF9zb19mYXJbMV0uc3VzcGVjdCkgewoJCWlmIChibGFtZV9lbnRyeV9zY29yZShzYiwgJnRoaXNbMV0pIDwgYmxhbWVfZW50cnlfc2NvcmUoc2IsICZiZXN0X3NvX2ZhclsxXSkpCgkJCXJldHVybjsKCX0KCglmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKQoJCWJsYW1lX29yaWdpbl9pbmNyZWYodGhpc1tpXS5zdXNwZWN0KTsKCWRlY3JlZl9zcGxpdChiZXN0X3NvX2Zhcik7CgltZW1jcHkoYmVzdF9zb19mYXIsIHRoaXMsIHNpemVvZihzdHJ1Y3QgYmxhbWVfZW50cnkgWzNdKSk7Cn0KCi8qCiAqIFdlIGFyZSBsb29raW5nIGF0IGEgcGFydCBvZiB0aGUgZmluYWwgaW1hZ2UgcmVwcmVzZW50ZWQgYnkKICogZW50ICh0bG5vIGFuZCBzYW1lIGFyZSBvZmZzZXQgYnkgZW50LT5zX2xubykuCiAqIHRsbm8gaXMgd2hlcmUgd2UgYXJlIGxvb2tpbmcgYXQgaW4gdGhlIGZpbmFsIGltYWdlLgogKiB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHNhbWUgbWF0Y2ggcHJlaW1hZ2UuCiAqIHBsbm8gaXMgd2hlcmUgd2UgYXJlIGxvb2tpbmcgYXQgaW4gdGhlIHByZWltYWdlLgogKgogKiA8LS0tLS0tLS0tLS0tLS0gZmluYWwgaW1hZ2UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT4KICogICAgICAgPC0tLS0tLWVudC0tLS0tLT4KICogICAgICAgICBedGxubyBec2FtZQogKiAgICA8LS0tLS0tLS0tcHJlaW1hZ2UtLS0tLT4KICogICAgICAgICBecGxubwogKgogKiBBbGwgbGluZSBudW1iZXJzIGFyZSAwLWJhc2VkLgogKi8Kc3RhdGljIHZvaWQgaGFuZGxlX3NwbGl0KHN0cnVjdCBibGFtZV9zY29yZWJvYXJkICpzYiwKCQkJIHN0cnVjdCBibGFtZV9lbnRyeSAqZW50LAoJCQkgaW50IHRsbm8sIGludCBwbG5vLCBpbnQgc2FtZSwKCQkJIHN0cnVjdCBibGFtZV9vcmlnaW4gKnBhcmVudCwKCQkJIHN0cnVjdCBibGFtZV9lbnRyeSAqc3BsaXQpCnsKCWlmIChlbnQtPm51bV9saW5lcyA8PSB0bG5vKQoJCXJldHVybjsKCWlmICh0bG5vIDwgc2FtZSkgewoJCXN0cnVjdCBibGFtZV9lbnRyeSB0aGlzWzNdOwoJCXRsbm8gKz0gZW50LT5zX2xubzsKCQlzYW1lICs9IGVudC0+c19sbm87CgkJc3BsaXRfb3ZlcmxhcCh0aGlzLCBlbnQsIHRsbm8sIHBsbm8sIHNhbWUsIHBhcmVudCk7CgkJY29weV9zcGxpdF9pZl9iZXR0ZXIoc2IsIHNwbGl0LCB0aGlzKTsKCQlkZWNyZWZfc3BsaXQodGhpcyk7Cgl9Cn0KCnN0cnVjdCBoYW5kbGVfc3BsaXRfY2JfZGF0YSB7CglzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCAqc2I7CglzdHJ1Y3QgYmxhbWVfZW50cnkgKmVudDsKCXN0cnVjdCBibGFtZV9vcmlnaW4gKnBhcmVudDsKCXN0cnVjdCBibGFtZV9lbnRyeSAqc3BsaXQ7Cglsb25nIHBsbm87Cglsb25nIHRsbm87Cn07CgpzdGF0aWMgaW50IGhhbmRsZV9zcGxpdF9jYihsb25nIHN0YXJ0X2EsIGxvbmcgY291bnRfYSwKCQkJICAgbG9uZyBzdGFydF9iLCBsb25nIGNvdW50X2IsIHZvaWQgKmRhdGEpCnsKCXN0cnVjdCBoYW5kbGVfc3BsaXRfY2JfZGF0YSAqZCA9IGRhdGE7CgloYW5kbGVfc3BsaXQoZC0+c2IsIGQtPmVudCwgZC0+dGxubywgZC0+cGxubywgc3RhcnRfYiwgZC0+cGFyZW50LAoJCSAgICAgZC0+c3BsaXQpOwoJZC0+cGxubyA9IHN0YXJ0X2EgKyBjb3VudF9hOwoJZC0+dGxubyA9IHN0YXJ0X2IgKyBjb3VudF9iOwoJcmV0dXJuIDA7Cn0KCi8qCiAqIEZpbmQgdGhlIGxpbmVzIGZyb20gcGFyZW50IHRoYXQgYXJlIHRoZSBzYW1lIGFzIGVudCBzbyB0aGF0CiAqIHdlIGNhbiBwYXNzIGJsYW1lcyB0byBpdC4gIGZpbGVfcCBoYXMgdGhlIGJsb2IgY29udGVudHMgZm9yCiAqIHRoZSBwYXJlbnQuCiAqLwpzdGF0aWMgdm9pZCBmaW5kX2NvcHlfaW5fYmxvYihzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCAqc2IsCgkJCSAgICAgIHN0cnVjdCBibGFtZV9lbnRyeSAqZW50LAoJCQkgICAgICBzdHJ1Y3QgYmxhbWVfb3JpZ2luICpwYXJlbnQsCgkJCSAgICAgIHN0cnVjdCBibGFtZV9lbnRyeSAqc3BsaXQsCgkJCSAgICAgIG1tZmlsZV90ICpmaWxlX3ApCnsKCWNvbnN0IGNoYXIgKmNwOwoJbW1maWxlX3QgZmlsZV9vOwoJc3RydWN0IGhhbmRsZV9zcGxpdF9jYl9kYXRhIGQ7CgoJbWVtc2V0KCZkLCAwLCBzaXplb2YoZCkpOwoJZC5zYiA9IHNiOyBkLmVudCA9IGVudDsgZC5wYXJlbnQgPSBwYXJlbnQ7IGQuc3BsaXQgPSBzcGxpdDsKCS8qCgkgKiBQcmVwYXJlIG1tZmlsZSB0aGF0IGNvbnRhaW5zIG9ubHkgdGhlIGxpbmVzIGluIGVudC4KCSAqLwoJY3AgPSBibGFtZV9udGhfbGluZShzYiwgZW50LT5sbm8pOwoJZmlsZV9vLnB0ciA9IChjaGFyICopIGNwOwoJZmlsZV9vLnNpemUgPSBibGFtZV9udGhfbGluZShzYiwgZW50LT5sbm8gKyBlbnQtPm51bV9saW5lcykgLSBjcDsKCgkvKgoJICogZmlsZV9vIGlzIGEgcGFydCBvZiBmaW5hbCBpbWFnZSB3ZSBhcmUgYW5ub3RhdGluZy4KCSAqIGZpbGVfcCBwYXJ0aWFsbHkgbWF5IG1hdGNoIHRoYXQgaW1hZ2UuCgkgKi8KCW1lbXNldChzcGxpdCwgMCwgc2l6ZW9mKHN0cnVjdCBibGFtZV9lbnRyeSBbM10pKTsKCWlmIChkaWZmX2h1bmtzKGZpbGVfcCwgJmZpbGVfbywgaGFuZGxlX3NwbGl0X2NiLCAmZCwgc2ItPnhkbF9vcHRzKSkKCQlkaWUoInVuYWJsZSB0byBnZW5lcmF0ZSBkaWZmICglcykiLAoJCSAgICBvaWRfdG9faGV4KCZwYXJlbnQtPmNvbW1pdC0+b2JqZWN0Lm9pZCkpOwoJLyogcmVtYWluZGVyLCBpZiBhbnksIGFsbCBtYXRjaCB0aGUgcHJlaW1hZ2UgKi8KCWhhbmRsZV9zcGxpdChzYiwgZW50LCBkLnRsbm8sIGQucGxubywgZW50LT5udW1fbGluZXMsIHBhcmVudCwgc3BsaXQpOwp9CgovKiBNb3ZlIGFsbCBibGFtZSBlbnRyaWVzIGZyb20gbGlzdCAqc291cmNlIHRoYXQgaGF2ZSBhIHNjb3JlIHNtYWxsZXIKICogdGhhbiBzY29yZV9taW4gdG8gdGhlIGZyb250IG9mIGxpc3QgKnNtYWxsLgogKiBSZXR1cm5zIGEgcG9pbnRlciB0byB0aGUgbGluayBwb2ludGluZyB0byB0aGUgb2xkIGhlYWQgb2YgdGhlIHNtYWxsIGxpc3QuCiAqLwoKc3RhdGljIHN0cnVjdCBibGFtZV9lbnRyeSAqKmZpbHRlcl9zbWFsbChzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCAqc2IsCgkJCQkJIHN0cnVjdCBibGFtZV9lbnRyeSAqKnNtYWxsLAoJCQkJCSBzdHJ1Y3QgYmxhbWVfZW50cnkgKipzb3VyY2UsCgkJCQkJIHVuc2lnbmVkIHNjb3JlX21pbikKewoJc3RydWN0IGJsYW1lX2VudHJ5ICpwID0gKnNvdXJjZTsKCXN0cnVjdCBibGFtZV9lbnRyeSAqb2xkc21hbGwgPSAqc21hbGw7Cgl3aGlsZSAocCkgewoJCWlmIChibGFtZV9lbnRyeV9zY29yZShzYiwgcCkgPD0gc2NvcmVfbWluKSB7CgkJCSpzbWFsbCA9IHA7CgkJCXNtYWxsID0gJnAtPm5leHQ7CgkJCXAgPSAqc21hbGw7CgkJfSBlbHNlIHsKCQkJKnNvdXJjZSA9IHA7CgkJCXNvdXJjZSA9ICZwLT5uZXh0OwoJCQlwID0gKnNvdXJjZTsKCQl9Cgl9Cgkqc21hbGwgPSBvbGRzbWFsbDsKCSpzb3VyY2UgPSBOVUxMOwoJcmV0dXJuIHNtYWxsOwp9CgovKgogKiBTZWUgaWYgbGluZXMgY3VycmVudGx5IHRhcmdldCBpcyBzdXNwZWN0ZWQgZm9yIGNhbiBiZSBhdHRyaWJ1dGVkIHRvCiAqIHBhcmVudC4KICovCnN0YXRpYyB2b2lkIGZpbmRfbW92ZV9pbl9wYXJlbnQoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLAoJCQkJc3RydWN0IGJsYW1lX2VudHJ5ICoqKmJsYW1lZCwKCQkJCXN0cnVjdCBibGFtZV9lbnRyeSAqKnRvb3NtYWxsLAoJCQkJc3RydWN0IGJsYW1lX29yaWdpbiAqdGFyZ2V0LAoJCQkJc3RydWN0IGJsYW1lX29yaWdpbiAqcGFyZW50KQp7CglzdHJ1Y3QgYmxhbWVfZW50cnkgKmUsIHNwbGl0WzNdOwoJc3RydWN0IGJsYW1lX2VudHJ5ICp1bmJsYW1lZCA9IHRhcmdldC0+c3VzcGVjdHM7CglzdHJ1Y3QgYmxhbWVfZW50cnkgKmxlZnRvdmVyID0gTlVMTDsKCW1tZmlsZV90IGZpbGVfcDsKCglpZiAoIXVuYmxhbWVkKQoJCXJldHVybjsgLyogbm90aGluZyByZW1haW5zIGZvciB0aGlzIHRhcmdldCAqLwoKCWZpbGxfb3JpZ2luX2Jsb2IoJnNiLT5yZXZzLT5kaWZmb3B0LCBwYXJlbnQsICZmaWxlX3AsICZzYi0+bnVtX3JlYWRfYmxvYik7CglpZiAoIWZpbGVfcC5wdHIpCgkJcmV0dXJuOwoKCS8qIEF0IGVhY2ggaXRlcmF0aW9uLCB1bmJsYW1lZCBoYXMgYSBOVUxMLXRlcm1pbmF0ZWQgbGlzdCBvZgoJICogZW50cmllcyB0aGF0IGhhdmUgbm90IHlldCBiZWVuIHRlc3RlZCBmb3IgYmxhbWUuICBsZWZ0b3ZlcgoJICogY29udGFpbnMgdGhlIHJldmVyc2VkIGxpc3Qgb2YgZW50cmllcyB0aGF0IGhhdmUgYmVlbiB0ZXN0ZWQKCSAqIHdpdGhvdXQgYmVpbmcgYXNzaWduYWJsZSB0byB0aGUgcGFyZW50LgoJICovCglkbyB7CgkJc3RydWN0IGJsYW1lX2VudHJ5ICoqdW5ibGFtZWR0YWlsID0gJnVuYmxhbWVkOwoJCXN0cnVjdCBibGFtZV9lbnRyeSAqbmV4dDsKCQlmb3IgKGUgPSB1bmJsYW1lZDsgZTsgZSA9IG5leHQpIHsKCQkJbmV4dCA9IGUtPm5leHQ7CgkJCWZpbmRfY29weV9pbl9ibG9iKHNiLCBlLCBwYXJlbnQsIHNwbGl0LCAmZmlsZV9wKTsKCQkJaWYgKHNwbGl0WzFdLnN1c3BlY3QgJiYKCQkJICAgIHNiLT5tb3ZlX3Njb3JlIDwgYmxhbWVfZW50cnlfc2NvcmUoc2IsICZzcGxpdFsxXSkpIHsKCQkJCXNwbGl0X2JsYW1lKGJsYW1lZCwgJnVuYmxhbWVkdGFpbCwgc3BsaXQsIGUpOwoJCQl9IGVsc2UgewoJCQkJZS0+bmV4dCA9IGxlZnRvdmVyOwoJCQkJbGVmdG92ZXIgPSBlOwoJCQl9CgkJCWRlY3JlZl9zcGxpdChzcGxpdCk7CgkJfQoJCSp1bmJsYW1lZHRhaWwgPSBOVUxMOwoJCXRvb3NtYWxsID0gZmlsdGVyX3NtYWxsKHNiLCB0b29zbWFsbCwgJnVuYmxhbWVkLCBzYi0+bW92ZV9zY29yZSk7Cgl9IHdoaWxlICh1bmJsYW1lZCk7Cgl0YXJnZXQtPnN1c3BlY3RzID0gcmV2ZXJzZV9ibGFtZShsZWZ0b3ZlciwgTlVMTCk7Cn0KCnN0cnVjdCBibGFtZV9saXN0IHsKCXN0cnVjdCBibGFtZV9lbnRyeSAqZW50OwoJc3RydWN0IGJsYW1lX2VudHJ5IHNwbGl0WzNdOwp9OwoKLyoKICogQ291bnQgdGhlIG51bWJlciBvZiBlbnRyaWVzIHRoZSB0YXJnZXQgaXMgc3VzcGVjdGVkIGZvciwKICogYW5kIHByZXBhcmUgYSBsaXN0IG9mIGVudHJ5IGFuZCB0aGUgYmVzdCBzcGxpdC4KICovCnN0YXRpYyBzdHJ1Y3QgYmxhbWVfbGlzdCAqc2V0dXBfYmxhbWVfbGlzdChzdHJ1Y3QgYmxhbWVfZW50cnkgKnVuYmxhbWVkLAoJCQkJCSAgIGludCAqbnVtX2VudHNfcCkKewoJc3RydWN0IGJsYW1lX2VudHJ5ICplOwoJaW50IG51bV9lbnRzLCBpOwoJc3RydWN0IGJsYW1lX2xpc3QgKmJsYW1lX2xpc3QgPSBOVUxMOwoKCWZvciAoZSA9IHVuYmxhbWVkLCBudW1fZW50cyA9IDA7IGU7IGUgPSBlLT5uZXh0KQoJCW51bV9lbnRzKys7CglpZiAobnVtX2VudHMpIHsKCQlibGFtZV9saXN0ID0geGNhbGxvYyhudW1fZW50cywgc2l6ZW9mKHN0cnVjdCBibGFtZV9saXN0KSk7CgkJZm9yIChlID0gdW5ibGFtZWQsIGkgPSAwOyBlOyBlID0gZS0+bmV4dCkKCQkJYmxhbWVfbGlzdFtpKytdLmVudCA9IGU7Cgl9CgkqbnVtX2VudHNfcCA9IG51bV9lbnRzOwoJcmV0dXJuIGJsYW1lX2xpc3Q7Cn0KCi8qCiAqIEZvciBsaW5lcyB0YXJnZXQgaXMgc3VzcGVjdGVkIGZvciwgc2VlIGlmIHdlIGNhbiBmaW5kIGNvZGUgbW92ZW1lbnQKICogYWNyb3NzIGZpbGUgYm91bmRhcnkgZnJvbSB0aGUgcGFyZW50IGNvbW1pdC4gIHBvcmlnaW4gaXMgdGhlIHBhdGgKICogaW4gdGhlIHBhcmVudCB3ZSBhbHJlYWR5IHRyaWVkLgogKi8Kc3RhdGljIHZvaWQgZmluZF9jb3B5X2luX3BhcmVudChzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCAqc2IsCgkJCQlzdHJ1Y3QgYmxhbWVfZW50cnkgKioqYmxhbWVkLAoJCQkJc3RydWN0IGJsYW1lX2VudHJ5ICoqdG9vc21hbGwsCgkJCQlzdHJ1Y3QgYmxhbWVfb3JpZ2luICp0YXJnZXQsCgkJCQlzdHJ1Y3QgY29tbWl0ICpwYXJlbnQsCgkJCQlzdHJ1Y3QgYmxhbWVfb3JpZ2luICpwb3JpZ2luLAoJCQkJaW50IG9wdCkKewoJc3RydWN0IGRpZmZfb3B0aW9ucyBkaWZmX29wdHM7CglpbnQgaSwgajsKCXN0cnVjdCBibGFtZV9saXN0ICpibGFtZV9saXN0OwoJaW50IG51bV9lbnRzOwoJc3RydWN0IGJsYW1lX2VudHJ5ICp1bmJsYW1lZCA9IHRhcmdldC0+c3VzcGVjdHM7CglzdHJ1Y3QgYmxhbWVfZW50cnkgKmxlZnRvdmVyID0gTlVMTDsKCglpZiAoIXVuYmxhbWVkKQoJCXJldHVybjsgLyogbm90aGluZyByZW1haW5zIGZvciB0aGlzIHRhcmdldCAqLwoKCWRpZmZfc2V0dXAoJmRpZmZfb3B0cyk7CglESUZGX09QVF9TRVQoJmRpZmZfb3B0cywgUkVDVVJTSVZFKTsKCWRpZmZfb3B0cy5vdXRwdXRfZm9ybWF0ID0gRElGRl9GT1JNQVRfTk9fT1VUUFVUOwoKCWRpZmZfc2V0dXBfZG9uZSgmZGlmZl9vcHRzKTsKCgkvKiBUcnkgImZpbmQgY29waWVzIGhhcmRlciIgb24gbmV3IHBhdGggaWYgcmVxdWVzdGVkOwoJICogd2UgZG8gbm90IHdhbnQgdG8gdXNlIGRpZmZjb3JlX3JlbmFtZSgpIGFjdHVhbGx5IHRvCgkgKiBtYXRjaCB0aGluZ3MgdXA7IGZpbmRfY29waWVzX2hhcmRlciBpcyBzZXQgb25seSB0bwoJICogZm9yY2UgZGlmZl90cmVlX3NoYTEoKSB0byBmZWVkIGFsbCBmaWxlcGFpcnMgdG8gZGlmZl9xdWV1ZSwKCSAqIGFuZCB0aGlzIGNvZGUgbmVlZHMgdG8gYmUgYWZ0ZXIgZGlmZl9zZXR1cF9kb25lKCksIHdoaWNoCgkgKiB1c3VhbGx5IG1ha2VzIGZpbmQtY29waWVzLWhhcmRlciBpbXBseSBjb3B5IGRldGVjdGlvbi4KCSAqLwoJaWYgKChvcHQgJiBQSUNLQVhFX0JMQU1FX0NPUFlfSEFSREVTVCkKCSAgICB8fCAoKG9wdCAmIFBJQ0tBWEVfQkxBTUVfQ09QWV9IQVJERVIpCgkJJiYgKCFwb3JpZ2luIHx8IHN0cmNtcCh0YXJnZXQtPnBhdGgsIHBvcmlnaW4tPnBhdGgpKSkpCgkJRElGRl9PUFRfU0VUKCZkaWZmX29wdHMsIEZJTkRfQ09QSUVTX0hBUkRFUik7CgoJaWYgKGlzX251bGxfb2lkKCZ0YXJnZXQtPmNvbW1pdC0+b2JqZWN0Lm9pZCkpCgkJZG9fZGlmZl9jYWNoZShwYXJlbnQtPnRyZWUtPm9iamVjdC5vaWQuaGFzaCwgJmRpZmZfb3B0cyk7CgllbHNlCgkJZGlmZl90cmVlX3NoYTEocGFyZW50LT50cmVlLT5vYmplY3Qub2lkLmhhc2gsCgkJCSAgICAgICB0YXJnZXQtPmNvbW1pdC0+dHJlZS0+b2JqZWN0Lm9pZC5oYXNoLAoJCQkgICAgICAgIiIsICZkaWZmX29wdHMpOwoKCWlmICghRElGRl9PUFRfVFNUKCZkaWZmX29wdHMsIEZJTkRfQ09QSUVTX0hBUkRFUikpCgkJZGlmZmNvcmVfc3RkKCZkaWZmX29wdHMpOwoKCWRvIHsKCQlzdHJ1Y3QgYmxhbWVfZW50cnkgKip1bmJsYW1lZHRhaWwgPSAmdW5ibGFtZWQ7CgkJYmxhbWVfbGlzdCA9IHNldHVwX2JsYW1lX2xpc3QodW5ibGFtZWQsICZudW1fZW50cyk7CgoJCWZvciAoaSA9IDA7IGkgPCBkaWZmX3F1ZXVlZF9kaWZmLm5yOyBpKyspIHsKCQkJc3RydWN0IGRpZmZfZmlsZXBhaXIgKnAgPSBkaWZmX3F1ZXVlZF9kaWZmLnF1ZXVlW2ldOwoJCQlzdHJ1Y3QgYmxhbWVfb3JpZ2luICpub3JpZ2luOwoJCQltbWZpbGVfdCBmaWxlX3A7CgkJCXN0cnVjdCBibGFtZV9lbnRyeSB0aGlzWzNdOwoKCQkJaWYgKCFESUZGX0ZJTEVfVkFMSUQocC0+b25lKSkKCQkJCWNvbnRpbnVlOyAvKiBkb2VzIG5vdCBleGlzdCBpbiBwYXJlbnQgKi8KCQkJaWYgKFNfSVNHSVRMSU5LKHAtPm9uZS0+bW9kZSkpCgkJCQljb250aW51ZTsgLyogaWdub3JlIGdpdCBsaW5rcyAqLwoJCQlpZiAocG9yaWdpbiAmJiAhc3RyY21wKHAtPm9uZS0+cGF0aCwgcG9yaWdpbi0+cGF0aCkpCgkJCQkvKiBmaW5kX21vdmUgYWxyZWFkeSBkZWFsdCB3aXRoIHRoaXMgcGF0aCAqLwoJCQkJY29udGludWU7CgoJCQlub3JpZ2luID0gZ2V0X29yaWdpbihwYXJlbnQsIHAtPm9uZS0+cGF0aCk7CgkJCW9pZGNweSgmbm9yaWdpbi0+YmxvYl9vaWQsICZwLT5vbmUtPm9pZCk7CgkJCW5vcmlnaW4tPm1vZGUgPSBwLT5vbmUtPm1vZGU7CgkJCWZpbGxfb3JpZ2luX2Jsb2IoJnNiLT5yZXZzLT5kaWZmb3B0LCBub3JpZ2luLCAmZmlsZV9wLCAmc2ItPm51bV9yZWFkX2Jsb2IpOwoJCQlpZiAoIWZpbGVfcC5wdHIpCgkJCQljb250aW51ZTsKCgkJCWZvciAoaiA9IDA7IGogPCBudW1fZW50czsgaisrKSB7CgkJCQlmaW5kX2NvcHlfaW5fYmxvYihzYiwgYmxhbWVfbGlzdFtqXS5lbnQsCgkJCQkJCSAgbm9yaWdpbiwgdGhpcywgJmZpbGVfcCk7CgkJCQljb3B5X3NwbGl0X2lmX2JldHRlcihzYiwgYmxhbWVfbGlzdFtqXS5zcGxpdCwKCQkJCQkJICAgICB0aGlzKTsKCQkJCWRlY3JlZl9zcGxpdCh0aGlzKTsKCQkJfQoJCQlibGFtZV9vcmlnaW5fZGVjcmVmKG5vcmlnaW4pOwoJCX0KCgkJZm9yIChqID0gMDsgaiA8IG51bV9lbnRzOyBqKyspIHsKCQkJc3RydWN0IGJsYW1lX2VudHJ5ICpzcGxpdCA9IGJsYW1lX2xpc3Rbal0uc3BsaXQ7CgkJCWlmIChzcGxpdFsxXS5zdXNwZWN0ICYmCgkJCSAgICBzYi0+Y29weV9zY29yZSA8IGJsYW1lX2VudHJ5X3Njb3JlKHNiLCAmc3BsaXRbMV0pKSB7CgkJCQlzcGxpdF9ibGFtZShibGFtZWQsICZ1bmJsYW1lZHRhaWwsIHNwbGl0LAoJCQkJCSAgICBibGFtZV9saXN0W2pdLmVudCk7CgkJCX0gZWxzZSB7CgkJCQlibGFtZV9saXN0W2pdLmVudC0+bmV4dCA9IGxlZnRvdmVyOwoJCQkJbGVmdG92ZXIgPSBibGFtZV9saXN0W2pdLmVudDsKCQkJfQoJCQlkZWNyZWZfc3BsaXQoc3BsaXQpOwoJCX0KCQlmcmVlKGJsYW1lX2xpc3QpOwoJCSp1bmJsYW1lZHRhaWwgPSBOVUxMOwoJCXRvb3NtYWxsID0gZmlsdGVyX3NtYWxsKHNiLCB0b29zbWFsbCwgJnVuYmxhbWVkLCBzYi0+Y29weV9zY29yZSk7Cgl9IHdoaWxlICh1bmJsYW1lZCk7Cgl0YXJnZXQtPnN1c3BlY3RzID0gcmV2ZXJzZV9ibGFtZShsZWZ0b3ZlciwgTlVMTCk7CglkaWZmX2ZsdXNoKCZkaWZmX29wdHMpOwoJY2xlYXJfcGF0aHNwZWMoJmRpZmZfb3B0cy5wYXRoc3BlYyk7Cn0KCi8qCiAqIFRoZSBibG9icyBvZiBvcmlnaW4gYW5kIHBvcmlnaW4gZXhhY3RseSBtYXRjaCwgc28gZXZlcnl0aGluZwogKiBvcmlnaW4gaXMgc3VzcGVjdGVkIGZvciBjYW4gYmUgYmxhbWVkIG9uIHRoZSBwYXJlbnQuCiAqLwpzdGF0aWMgdm9pZCBwYXNzX3dob2xlX2JsYW1lKHN0cnVjdCBibGFtZV9zY29yZWJvYXJkICpzYiwKCQkJICAgICBzdHJ1Y3QgYmxhbWVfb3JpZ2luICpvcmlnaW4sIHN0cnVjdCBibGFtZV9vcmlnaW4gKnBvcmlnaW4pCnsKCXN0cnVjdCBibGFtZV9lbnRyeSAqZSwgKnN1c3BlY3RzOwoKCWlmICghcG9yaWdpbi0+ZmlsZS5wdHIgJiYgb3JpZ2luLT5maWxlLnB0cikgewoJCS8qIFN0ZWFsIGl0cyBmaWxlICovCgkJcG9yaWdpbi0+ZmlsZSA9IG9yaWdpbi0+ZmlsZTsKCQlvcmlnaW4tPmZpbGUucHRyID0gTlVMTDsKCX0KCXN1c3BlY3RzID0gb3JpZ2luLT5zdXNwZWN0czsKCW9yaWdpbi0+c3VzcGVjdHMgPSBOVUxMOwoJZm9yIChlID0gc3VzcGVjdHM7IGU7IGUgPSBlLT5uZXh0KSB7CgkJYmxhbWVfb3JpZ2luX2luY3JlZihwb3JpZ2luKTsKCQlibGFtZV9vcmlnaW5fZGVjcmVmKGUtPnN1c3BlY3QpOwoJCWUtPnN1c3BlY3QgPSBwb3JpZ2luOwoJfQoJcXVldWVfYmxhbWVzKHNiLCBwb3JpZ2luLCBzdXNwZWN0cyk7Cn0KCi8qCiAqIFdlIHBhc3MgYmxhbWUgZnJvbSB0aGUgY3VycmVudCBjb21taXQgdG8gaXRzIHBhcmVudHMuICBXZSBrZWVwIHNheWluZwogKiAicGFyZW50IiAoYW5kICJwb3JpZ2luIiksIGJ1dCB3aGF0IHdlIG1lYW4gaXMgdG8gZmluZCBzY2FwZWdvYXQgdG8KICogZXhvbmVyYXRlIG91cnNlbHZlcy4KICovCnN0YXRpYyBzdHJ1Y3QgY29tbWl0X2xpc3QgKmZpcnN0X3NjYXBlZ29hdChzdHJ1Y3QgcmV2X2luZm8gKnJldnMsIHN0cnVjdCBjb21taXQgKmNvbW1pdCwKCQkJCQlpbnQgcmV2ZXJzZSkKewoJaWYgKCFyZXZlcnNlKSB7CgkJaWYgKHJldnMtPmZpcnN0X3BhcmVudF9vbmx5ICYmCgkJICAgIGNvbW1pdC0+cGFyZW50cyAmJgoJCSAgICBjb21taXQtPnBhcmVudHMtPm5leHQpIHsKCQkJZnJlZV9jb21taXRfbGlzdChjb21taXQtPnBhcmVudHMtPm5leHQpOwoJCQljb21taXQtPnBhcmVudHMtPm5leHQgPSBOVUxMOwoJCX0KCQlyZXR1cm4gY29tbWl0LT5wYXJlbnRzOwoJfQoJcmV0dXJuIGxvb2t1cF9kZWNvcmF0aW9uKCZyZXZzLT5jaGlsZHJlbiwgJmNvbW1pdC0+b2JqZWN0KTsKfQoKc3RhdGljIGludCBudW1fc2NhcGVnb2F0cyhzdHJ1Y3QgcmV2X2luZm8gKnJldnMsIHN0cnVjdCBjb21taXQgKmNvbW1pdCwgaW50IHJldmVyc2UpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqbCA9IGZpcnN0X3NjYXBlZ29hdChyZXZzLCBjb21taXQsIHJldmVyc2UpOwoJcmV0dXJuIGNvbW1pdF9saXN0X2NvdW50KGwpOwp9CgovKiBEaXN0cmlidXRlIGNvbGxlY3RlZCB1bnNvcnRlZCBibGFtZXMgdG8gdGhlIHJlc3BlY3RlZCBzb3J0ZWQgbGlzdHMKICogaW4gdGhlIHZhcmlvdXMgb3JpZ2lucy4KICovCnN0YXRpYyB2b2lkIGRpc3RyaWJ1dGVfYmxhbWUoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLCBzdHJ1Y3QgYmxhbWVfZW50cnkgKmJsYW1lZCkKewoJYmxhbWVkID0gbGxpc3RfbWVyZ2Vzb3J0KGJsYW1lZCwgZ2V0X25leHRfYmxhbWUsIHNldF9uZXh0X2JsYW1lLAoJCQkJIGNvbXBhcmVfYmxhbWVfc3VzcGVjdCk7Cgl3aGlsZSAoYmxhbWVkKQoJewoJCXN0cnVjdCBibGFtZV9vcmlnaW4gKnBvcmlnaW4gPSBibGFtZWQtPnN1c3BlY3Q7CgkJc3RydWN0IGJsYW1lX2VudHJ5ICpzdXNwZWN0cyA9IE5VTEw7CgkJZG8gewoJCQlzdHJ1Y3QgYmxhbWVfZW50cnkgKm5leHQgPSBibGFtZWQtPm5leHQ7CgkJCWJsYW1lZC0+bmV4dCA9IHN1c3BlY3RzOwoJCQlzdXNwZWN0cyA9IGJsYW1lZDsKCQkJYmxhbWVkID0gbmV4dDsKCQl9IHdoaWxlIChibGFtZWQgJiYgYmxhbWVkLT5zdXNwZWN0ID09IHBvcmlnaW4pOwoJCXN1c3BlY3RzID0gcmV2ZXJzZV9ibGFtZShzdXNwZWN0cywgTlVMTCk7CgkJcXVldWVfYmxhbWVzKHNiLCBwb3JpZ2luLCBzdXNwZWN0cyk7Cgl9Cn0KCiNkZWZpbmUgTUFYU0cgMTYKCnN0YXRpYyB2b2lkIHBhc3NfYmxhbWUoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLCBzdHJ1Y3QgYmxhbWVfb3JpZ2luICpvcmlnaW4sIGludCBvcHQpCnsKCXN0cnVjdCByZXZfaW5mbyAqcmV2cyA9IHNiLT5yZXZzOwoJaW50IGksIHBhc3MsIG51bV9zZzsKCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IG9yaWdpbi0+Y29tbWl0OwoJc3RydWN0IGNvbW1pdF9saXN0ICpzZzsKCXN0cnVjdCBibGFtZV9vcmlnaW4gKnNnX2J1ZltNQVhTR107CglzdHJ1Y3QgYmxhbWVfb3JpZ2luICpwb3JpZ2luLCAqKnNnX29yaWdpbiA9IHNnX2J1ZjsKCXN0cnVjdCBibGFtZV9lbnRyeSAqdG9vc21hbGwgPSBOVUxMOwoJc3RydWN0IGJsYW1lX2VudHJ5ICpibGFtZXMsICoqYmxhbWV0YWlsID0gJmJsYW1lczsKCgludW1fc2cgPSBudW1fc2NhcGVnb2F0cyhyZXZzLCBjb21taXQsIHNiLT5yZXZlcnNlKTsKCWlmICghbnVtX3NnKQoJCWdvdG8gZmluaXNoOwoJZWxzZSBpZiAobnVtX3NnIDwgQVJSQVlfU0laRShzZ19idWYpKQoJCW1lbXNldChzZ19idWYsIDAsIHNpemVvZihzZ19idWYpKTsKCWVsc2UKCQlzZ19vcmlnaW4gPSB4Y2FsbG9jKG51bV9zZywgc2l6ZW9mKCpzZ19vcmlnaW4pKTsKCgkvKgoJICogVGhlIGZpcnN0IHBhc3MgbG9va3MgZm9yIHVucmVuYW1lZCBwYXRoIHRvIG9wdGltaXplIGZvcgoJICogY29tbW9uIGNhc2VzLCB0aGVuIHdlIGxvb2sgZm9yIHJlbmFtZXMgaW4gdGhlIHNlY29uZCBwYXNzLgoJICovCglmb3IgKHBhc3MgPSAwOyBwYXNzIDwgMiAtIHNiLT5ub193aG9sZV9maWxlX3JlbmFtZTsgcGFzcysrKSB7CgkJc3RydWN0IGJsYW1lX29yaWdpbiAqKCpmaW5kKShzdHJ1Y3QgY29tbWl0ICosIHN0cnVjdCBibGFtZV9vcmlnaW4gKik7CgkJZmluZCA9IHBhc3MgPyBmaW5kX3JlbmFtZSA6IGZpbmRfb3JpZ2luOwoKCQlmb3IgKGkgPSAwLCBzZyA9IGZpcnN0X3NjYXBlZ29hdChyZXZzLCBjb21taXQsIHNiLT5yZXZlcnNlKTsKCQkgICAgIGkgPCBudW1fc2cgJiYgc2c7CgkJICAgICBzZyA9IHNnLT5uZXh0LCBpKyspIHsKCQkJc3RydWN0IGNvbW1pdCAqcCA9IHNnLT5pdGVtOwoJCQlpbnQgaiwgc2FtZTsKCgkJCWlmIChzZ19vcmlnaW5baV0pCgkJCQljb250aW51ZTsKCQkJaWYgKHBhcnNlX2NvbW1pdChwKSkKCQkJCWNvbnRpbnVlOwoJCQlwb3JpZ2luID0gZmluZChwLCBvcmlnaW4pOwoJCQlpZiAoIXBvcmlnaW4pCgkJCQljb250aW51ZTsKCQkJaWYgKCFvaWRjbXAoJnBvcmlnaW4tPmJsb2Jfb2lkLCAmb3JpZ2luLT5ibG9iX29pZCkpIHsKCQkJCXBhc3Nfd2hvbGVfYmxhbWUoc2IsIG9yaWdpbiwgcG9yaWdpbik7CgkJCQlibGFtZV9vcmlnaW5fZGVjcmVmKHBvcmlnaW4pOwoJCQkJZ290byBmaW5pc2g7CgkJCX0KCQkJZm9yIChqID0gc2FtZSA9IDA7IGogPCBpOyBqKyspCgkJCQlpZiAoc2dfb3JpZ2luW2pdICYmCgkJCQkgICAgIW9pZGNtcCgmc2dfb3JpZ2luW2pdLT5ibG9iX29pZCwgJnBvcmlnaW4tPmJsb2Jfb2lkKSkgewoJCQkJCXNhbWUgPSAxOwoJCQkJCWJyZWFrOwoJCQkJfQoJCQlpZiAoIXNhbWUpCgkJCQlzZ19vcmlnaW5baV0gPSBwb3JpZ2luOwoJCQllbHNlCgkJCQlibGFtZV9vcmlnaW5fZGVjcmVmKHBvcmlnaW4pOwoJCX0KCX0KCglzYi0+bnVtX2NvbW1pdHMrKzsKCWZvciAoaSA9IDAsIHNnID0gZmlyc3Rfc2NhcGVnb2F0KHJldnMsIGNvbW1pdCwgc2ItPnJldmVyc2UpOwoJICAgICBpIDwgbnVtX3NnICYmIHNnOwoJICAgICBzZyA9IHNnLT5uZXh0LCBpKyspIHsKCQlzdHJ1Y3QgYmxhbWVfb3JpZ2luICpwb3JpZ2luID0gc2dfb3JpZ2luW2ldOwoJCWlmICghcG9yaWdpbikKCQkJY29udGludWU7CgkJaWYgKCFvcmlnaW4tPnByZXZpb3VzKSB7CgkJCWJsYW1lX29yaWdpbl9pbmNyZWYocG9yaWdpbik7CgkJCW9yaWdpbi0+cHJldmlvdXMgPSBwb3JpZ2luOwoJCX0KCQlwYXNzX2JsYW1lX3RvX3BhcmVudChzYiwgb3JpZ2luLCBwb3JpZ2luKTsKCQlpZiAoIW9yaWdpbi0+c3VzcGVjdHMpCgkJCWdvdG8gZmluaXNoOwoJfQoKCS8qCgkgKiBPcHRpb25hbGx5IGZpbmQgbW92ZXMgaW4gcGFyZW50cycgZmlsZXMuCgkgKi8KCWlmIChvcHQgJiBQSUNLQVhFX0JMQU1FX01PVkUpIHsKCQlmaWx0ZXJfc21hbGwoc2IsICZ0b29zbWFsbCwgJm9yaWdpbi0+c3VzcGVjdHMsIHNiLT5tb3ZlX3Njb3JlKTsKCQlpZiAob3JpZ2luLT5zdXNwZWN0cykgewoJCQlmb3IgKGkgPSAwLCBzZyA9IGZpcnN0X3NjYXBlZ29hdChyZXZzLCBjb21taXQsIHNiLT5yZXZlcnNlKTsKCQkJICAgICBpIDwgbnVtX3NnICYmIHNnOwoJCQkgICAgIHNnID0gc2ctPm5leHQsIGkrKykgewoJCQkJc3RydWN0IGJsYW1lX29yaWdpbiAqcG9yaWdpbiA9IHNnX29yaWdpbltpXTsKCQkJCWlmICghcG9yaWdpbikKCQkJCQljb250aW51ZTsKCQkJCWZpbmRfbW92ZV9pbl9wYXJlbnQoc2IsICZibGFtZXRhaWwsICZ0b29zbWFsbCwgb3JpZ2luLCBwb3JpZ2luKTsKCQkJCWlmICghb3JpZ2luLT5zdXNwZWN0cykKCQkJCQlicmVhazsKCQkJfQoJCX0KCX0KCgkvKgoJICogT3B0aW9uYWxseSBmaW5kIGNvcGllcyBmcm9tIHBhcmVudHMnIGZpbGVzLgoJICovCglpZiAob3B0ICYgUElDS0FYRV9CTEFNRV9DT1BZKSB7CgkJaWYgKHNiLT5jb3B5X3Njb3JlID4gc2ItPm1vdmVfc2NvcmUpCgkJCWZpbHRlcl9zbWFsbChzYiwgJnRvb3NtYWxsLCAmb3JpZ2luLT5zdXNwZWN0cywgc2ItPmNvcHlfc2NvcmUpOwoJCWVsc2UgaWYgKHNiLT5jb3B5X3Njb3JlIDwgc2ItPm1vdmVfc2NvcmUpIHsKCQkJb3JpZ2luLT5zdXNwZWN0cyA9IGJsYW1lX21lcmdlKG9yaWdpbi0+c3VzcGVjdHMsIHRvb3NtYWxsKTsKCQkJdG9vc21hbGwgPSBOVUxMOwoJCQlmaWx0ZXJfc21hbGwoc2IsICZ0b29zbWFsbCwgJm9yaWdpbi0+c3VzcGVjdHMsIHNiLT5jb3B5X3Njb3JlKTsKCQl9CgkJaWYgKCFvcmlnaW4tPnN1c3BlY3RzKQoJCQlnb3RvIGZpbmlzaDsKCgkJZm9yIChpID0gMCwgc2cgPSBmaXJzdF9zY2FwZWdvYXQocmV2cywgY29tbWl0LCBzYi0+cmV2ZXJzZSk7CgkJICAgICBpIDwgbnVtX3NnICYmIHNnOwoJCSAgICAgc2cgPSBzZy0+bmV4dCwgaSsrKSB7CgkJCXN0cnVjdCBibGFtZV9vcmlnaW4gKnBvcmlnaW4gPSBzZ19vcmlnaW5baV07CgkJCWZpbmRfY29weV9pbl9wYXJlbnQoc2IsICZibGFtZXRhaWwsICZ0b29zbWFsbCwKCQkJCQkgICAgb3JpZ2luLCBzZy0+aXRlbSwgcG9yaWdpbiwgb3B0KTsKCQkJaWYgKCFvcmlnaW4tPnN1c3BlY3RzKQoJCQkJZ290byBmaW5pc2g7CgkJfQoJfQoKZmluaXNoOgoJKmJsYW1ldGFpbCA9IE5VTEw7CglkaXN0cmlidXRlX2JsYW1lKHNiLCBibGFtZXMpOwoJLyoKCSAqIHByZXBlbmQgdG9vc21hbGwgdG8gb3JpZ2luLT5zdXNwZWN0cwoJICoKCSAqIFRoZXJlIGlzIG5vIHBvaW50IGluIHNvcnRpbmc6IHRoaXMgZW5kcyB1cCBvbiBhIGJpZwoJICogdW5zb3J0ZWQgbGlzdCBpbiB0aGUgY2FsbGVyIGFueXdheS4KCSAqLwoJaWYgKHRvb3NtYWxsKSB7CgkJc3RydWN0IGJsYW1lX2VudHJ5ICoqdGFpbCA9ICZ0b29zbWFsbDsKCQl3aGlsZSAoKnRhaWwpCgkJCXRhaWwgPSAmKCp0YWlsKS0+bmV4dDsKCQkqdGFpbCA9IG9yaWdpbi0+c3VzcGVjdHM7CgkJb3JpZ2luLT5zdXNwZWN0cyA9IHRvb3NtYWxsOwoJfQoJZm9yIChpID0gMDsgaSA8IG51bV9zZzsgaSsrKSB7CgkJaWYgKHNnX29yaWdpbltpXSkgewoJCQlkcm9wX29yaWdpbl9ibG9iKHNnX29yaWdpbltpXSk7CgkJCWJsYW1lX29yaWdpbl9kZWNyZWYoc2dfb3JpZ2luW2ldKTsKCQl9Cgl9Cglkcm9wX29yaWdpbl9ibG9iKG9yaWdpbik7CglpZiAoc2dfYnVmICE9IHNnX29yaWdpbikKCQlmcmVlKHNnX29yaWdpbik7Cn0KCi8qCiAqIFRoZSBtYWluIGxvb3AgLS0gd2hpbGUgd2UgaGF2ZSBibG9icyB3aXRoIGxpbmVzIHdob3NlIHRydWUgb3JpZ2luCiAqIGlzIHN0aWxsIHVua25vd24sIHBpY2sgb25lIGJsb2IsIGFuZCBhbGxvdyBpdHMgbGluZXMgdG8gcGFzcyBibGFtZXMKICogdG8gaXRzIHBhcmVudHMuICovCnZvaWQgYXNzaWduX2JsYW1lKHN0cnVjdCBibGFtZV9zY29yZWJvYXJkICpzYiwgaW50IG9wdCkKewoJc3RydWN0IHJldl9pbmZvICpyZXZzID0gc2ItPnJldnM7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBwcmlvX3F1ZXVlX2dldCgmc2ItPmNvbW1pdHMpOwoKCXdoaWxlIChjb21taXQpIHsKCQlzdHJ1Y3QgYmxhbWVfZW50cnkgKmVudDsKCQlzdHJ1Y3QgYmxhbWVfb3JpZ2luICpzdXNwZWN0ID0gY29tbWl0LT51dGlsOwoKCQkvKiBmaW5kIG9uZSBzdXNwZWN0IHRvIGJyZWFrIGRvd24gKi8KCQl3aGlsZSAoc3VzcGVjdCAmJiAhc3VzcGVjdC0+c3VzcGVjdHMpCgkJCXN1c3BlY3QgPSBzdXNwZWN0LT5uZXh0OwoKCQlpZiAoIXN1c3BlY3QpIHsKCQkJY29tbWl0ID0gcHJpb19xdWV1ZV9nZXQoJnNiLT5jb21taXRzKTsKCQkJY29udGludWU7CgkJfQoKCQlhc3NlcnQoY29tbWl0ID09IHN1c3BlY3QtPmNvbW1pdCk7CgoJCS8qCgkJICogV2Ugd2lsbCB1c2UgdGhpcyBzdXNwZWN0IGxhdGVyIGluIHRoZSBsb29wLAoJCSAqIHNvIGhvbGQgb250byBpdCBpbiB0aGUgbWVhbnRpbWUuCgkJICovCgkJYmxhbWVfb3JpZ2luX2luY3JlZihzdXNwZWN0KTsKCQlwYXJzZV9jb21taXQoY29tbWl0KTsKCQlpZiAoc2ItPnJldmVyc2UgfHwKCQkgICAgKCEoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBVTklOVEVSRVNUSU5HKSAmJgoJCSAgICAgIShyZXZzLT5tYXhfYWdlICE9IC0xICYmIGNvbW1pdC0+ZGF0ZSA8IHJldnMtPm1heF9hZ2UpKSkKCQkJcGFzc19ibGFtZShzYiwgc3VzcGVjdCwgb3B0KTsKCQllbHNlIHsKCQkJY29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gVU5JTlRFUkVTVElORzsKCQkJaWYgKGNvbW1pdC0+b2JqZWN0LnBhcnNlZCkKCQkJCW1hcmtfcGFyZW50c191bmludGVyZXN0aW5nKGNvbW1pdCk7CgkJfQoJCS8qIHRyZWF0IHJvb3QgY29tbWl0IGFzIGJvdW5kYXJ5ICovCgkJaWYgKCFjb21taXQtPnBhcmVudHMgJiYgIXNiLT5zaG93X3Jvb3QpCgkJCWNvbW1pdC0+b2JqZWN0LmZsYWdzIHw9IFVOSU5URVJFU1RJTkc7CgoJCS8qIFRha2UgcmVzcG9uc2liaWxpdHkgZm9yIHRoZSByZW1haW5pbmcgZW50cmllcyAqLwoJCWVudCA9IHN1c3BlY3QtPnN1c3BlY3RzOwoJCWlmIChlbnQpIHsKCQkJc3VzcGVjdC0+Z3VpbHR5ID0gMTsKCQkJZm9yICg7OykgewoJCQkJc3RydWN0IGJsYW1lX2VudHJ5ICpuZXh0ID0gZW50LT5uZXh0OwoJCQkJaWYgKHNiLT5mb3VuZF9ndWlsdHlfZW50cnkpCgkJCQkJc2ItPmZvdW5kX2d1aWx0eV9lbnRyeShlbnQsIHNiLT5mb3VuZF9ndWlsdHlfZW50cnlfZGF0YSk7CgkJCQlpZiAobmV4dCkgewoJCQkJCWVudCA9IG5leHQ7CgkJCQkJY29udGludWU7CgkJCQl9CgkJCQllbnQtPm5leHQgPSBzYi0+ZW50OwoJCQkJc2ItPmVudCA9IHN1c3BlY3QtPnN1c3BlY3RzOwoJCQkJc3VzcGVjdC0+c3VzcGVjdHMgPSBOVUxMOwoJCQkJYnJlYWs7CgkJCX0KCQl9CgkJYmxhbWVfb3JpZ2luX2RlY3JlZihzdXNwZWN0KTsKCgkJaWYgKHNiLT5kZWJ1ZykgLyogc2FuaXR5ICovCgkJCXNhbml0eV9jaGVja19yZWZjbnQoc2IpOwoJfQp9CgpzdGF0aWMgY29uc3QgY2hhciAqZ2V0X25leHRfbGluZShjb25zdCBjaGFyICpzdGFydCwgY29uc3QgY2hhciAqZW5kKQp7Cgljb25zdCBjaGFyICpubCA9IG1lbWNocihzdGFydCwgJ1xuJywgZW5kIC0gc3RhcnQpOwoJcmV0dXJuIG5sID8gbmwgKyAxIDogZW5kOwp9CgovKgogKiBUbyBhbGxvdyBxdWljayBhY2Nlc3MgdG8gdGhlIGNvbnRlbnRzIG9mIG50aCBsaW5lIGluIHRoZQogKiBmaW5hbCBpbWFnZSwgcHJlcGFyZSBhbiBpbmRleCBpbiB0aGUgc2NvcmVib2FyZC4KICovCnN0YXRpYyBpbnQgcHJlcGFyZV9saW5lcyhzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCAqc2IpCnsKCWNvbnN0IGNoYXIgKmJ1ZiA9IHNiLT5maW5hbF9idWY7Cgl1bnNpZ25lZCBsb25nIGxlbiA9IHNiLT5maW5hbF9idWZfc2l6ZTsKCWNvbnN0IGNoYXIgKmVuZCA9IGJ1ZiArIGxlbjsKCWNvbnN0IGNoYXIgKnA7CglpbnQgKmxpbmVubzsKCWludCBudW0gPSAwOwoKCWZvciAocCA9IGJ1ZjsgcCA8IGVuZDsgcCA9IGdldF9uZXh0X2xpbmUocCwgZW5kKSkKCQludW0rKzsKCglBTExPQ19BUlJBWShzYi0+bGluZW5vLCBudW0gKyAxKTsKCWxpbmVubyA9IHNiLT5saW5lbm87CgoJZm9yIChwID0gYnVmOyBwIDwgZW5kOyBwID0gZ2V0X25leHRfbGluZShwLCBlbmQpKQoJCSpsaW5lbm8rKyA9IHAgLSBidWY7CgoJKmxpbmVubyA9IGxlbjsKCglzYi0+bnVtX2xpbmVzID0gbnVtOwoJcmV0dXJuIHNiLT5udW1fbGluZXM7Cn0KCnN0YXRpYyBzdHJ1Y3QgY29tbWl0ICpmaW5kX3NpbmdsZV9maW5hbChzdHJ1Y3QgcmV2X2luZm8gKnJldnMsCgkJCQkJY29uc3QgY2hhciAqKm5hbWVfcCkKewoJaW50IGk7CglzdHJ1Y3QgY29tbWl0ICpmb3VuZCA9IE5VTEw7Cgljb25zdCBjaGFyICpuYW1lID0gTlVMTDsKCglmb3IgKGkgPSAwOyBpIDwgcmV2cy0+cGVuZGluZy5ucjsgaSsrKSB7CgkJc3RydWN0IG9iamVjdCAqb2JqID0gcmV2cy0+cGVuZGluZy5vYmplY3RzW2ldLml0ZW07CgkJaWYgKG9iai0+ZmxhZ3MgJiBVTklOVEVSRVNUSU5HKQoJCQljb250aW51ZTsKCQlvYmogPSBkZXJlZl90YWcob2JqLCBOVUxMLCAwKTsKCQlpZiAob2JqLT50eXBlICE9IE9CSl9DT01NSVQpCgkJCWRpZSgiTm9uIGNvbW1pdCAlcz8iLCByZXZzLT5wZW5kaW5nLm9iamVjdHNbaV0ubmFtZSk7CgkJaWYgKGZvdW5kKQoJCQlkaWUoIk1vcmUgdGhhbiBvbmUgY29tbWl0IHRvIGRpZyBmcm9tICVzIGFuZCAlcz8iLAoJCQkgICAgcmV2cy0+cGVuZGluZy5vYmplY3RzW2ldLm5hbWUsIG5hbWUpOwoJCWZvdW5kID0gKHN0cnVjdCBjb21taXQgKilvYmo7CgkJbmFtZSA9IHJldnMtPnBlbmRpbmcub2JqZWN0c1tpXS5uYW1lOwoJfQoJaWYgKG5hbWVfcCkKCQkqbmFtZV9wID0gbmFtZTsKCXJldHVybiBmb3VuZDsKfQoKc3RhdGljIHN0cnVjdCBjb21taXQgKmR3aW1fcmV2ZXJzZV9pbml0aWFsKHN0cnVjdCByZXZfaW5mbyAqcmV2cywKCQkJCQkgICBjb25zdCBjaGFyICoqbmFtZV9wKQp7CgkvKgoJICogRFdJTSAiZ2l0IGJsYW1lIC0tcmV2ZXJzZSBPTkUgLS0gUEFUSCIgYXMKCSAqICJnaXQgYmxhbWUgLS1yZXZlcnNlIE9ORS4uSEVBRCAtLSBQQVRIIiBidXQgb25seSBkbyBzbwoJICogd2hlbiBpdCBtYWtlcyBzZW5zZS4KCSAqLwoJc3RydWN0IG9iamVjdCAqb2JqOwoJc3RydWN0IGNvbW1pdCAqaGVhZF9jb21taXQ7Cgl1bnNpZ25lZCBjaGFyIGhlYWRfc2hhMVsyMF07CgoJaWYgKHJldnMtPnBlbmRpbmcubnIgIT0gMSkKCQlyZXR1cm4gTlVMTDsKCgkvKiBJcyB0aGF0IHNvbGUgcmV2IGEgY29tbWl0dGlzaD8gKi8KCW9iaiA9IHJldnMtPnBlbmRpbmcub2JqZWN0c1swXS5pdGVtOwoJb2JqID0gZGVyZWZfdGFnKG9iaiwgTlVMTCwgMCk7CglpZiAob2JqLT50eXBlICE9IE9CSl9DT01NSVQpCgkJcmV0dXJuIE5VTEw7CgoJLyogRG8gd2UgaGF2ZSBIRUFEPyAqLwoJaWYgKCFyZXNvbHZlX3JlZl91bnNhZmUoIkhFQUQiLCBSRVNPTFZFX1JFRl9SRUFESU5HLCBoZWFkX3NoYTEsIE5VTEwpKQoJCXJldHVybiBOVUxMOwoJaGVhZF9jb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkoaGVhZF9zaGExLCAxKTsKCWlmICghaGVhZF9jb21taXQpCgkJcmV0dXJuIE5VTEw7CgoJLyogVHVybiAiT05FIiBpbnRvICJPTkUuLkhFQUQiIHRoZW4gKi8KCW9iai0+ZmxhZ3MgfD0gVU5JTlRFUkVTVElORzsKCWFkZF9wZW5kaW5nX29iamVjdChyZXZzLCAmaGVhZF9jb21taXQtPm9iamVjdCwgIkhFQUQiKTsKCglpZiAobmFtZV9wKQoJCSpuYW1lX3AgPSByZXZzLT5wZW5kaW5nLm9iamVjdHNbMF0ubmFtZTsKCXJldHVybiAoc3RydWN0IGNvbW1pdCAqKW9iajsKfQoKc3RhdGljIHN0cnVjdCBjb21taXQgKmZpbmRfc2luZ2xlX2luaXRpYWwoc3RydWN0IHJldl9pbmZvICpyZXZzLAoJCQkJCSAgY29uc3QgY2hhciAqKm5hbWVfcCkKewoJaW50IGk7CglzdHJ1Y3QgY29tbWl0ICpmb3VuZCA9IE5VTEw7Cgljb25zdCBjaGFyICpuYW1lID0gTlVMTDsKCgkvKgoJICogVGhlcmUgbXVzdCBiZSBvbmUgYW5kIG9ubHkgb25lIG5lZ2F0aXZlIGNvbW1pdCwgYW5kIGl0IG11c3QgYmUKCSAqIHRoZSBib3VuZGFyeS4KCSAqLwoJZm9yIChpID0gMDsgaSA8IHJldnMtPnBlbmRpbmcubnI7IGkrKykgewoJCXN0cnVjdCBvYmplY3QgKm9iaiA9IHJldnMtPnBlbmRpbmcub2JqZWN0c1tpXS5pdGVtOwoJCWlmICghKG9iai0+ZmxhZ3MgJiBVTklOVEVSRVNUSU5HKSkKCQkJY29udGludWU7CgkJb2JqID0gZGVyZWZfdGFnKG9iaiwgTlVMTCwgMCk7CgkJaWYgKG9iai0+dHlwZSAhPSBPQkpfQ09NTUlUKQoJCQlkaWUoIk5vbiBjb21taXQgJXM/IiwgcmV2cy0+cGVuZGluZy5vYmplY3RzW2ldLm5hbWUpOwoJCWlmIChmb3VuZCkKCQkJZGllKCJNb3JlIHRoYW4gb25lIGNvbW1pdCB0byBkaWcgdXAgZnJvbSwgJXMgYW5kICVzPyIsCgkJCSAgICByZXZzLT5wZW5kaW5nLm9iamVjdHNbaV0ubmFtZSwgbmFtZSk7CgkJZm91bmQgPSAoc3RydWN0IGNvbW1pdCAqKSBvYmo7CgkJbmFtZSA9IHJldnMtPnBlbmRpbmcub2JqZWN0c1tpXS5uYW1lOwoJfQoKCWlmICghbmFtZSkKCQlmb3VuZCA9IGR3aW1fcmV2ZXJzZV9pbml0aWFsKHJldnMsICZuYW1lKTsKCWlmICghbmFtZSkKCQlkaWUoIk5vIGNvbW1pdCB0byBkaWcgdXAgZnJvbT8iKTsKCglpZiAobmFtZV9wKQoJCSpuYW1lX3AgPSBuYW1lOwoJcmV0dXJuIGZvdW5kOwp9Cgp2b2lkIGluaXRfc2NvcmVib2FyZChzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCAqc2IpCnsKCW1lbXNldChzYiwgMCwgc2l6ZW9mKHN0cnVjdCBibGFtZV9zY29yZWJvYXJkKSk7CglzYi0+bW92ZV9zY29yZSA9IEJMQU1FX0RFRkFVTFRfTU9WRV9TQ09SRTsKCXNiLT5jb3B5X3Njb3JlID0gQkxBTUVfREVGQVVMVF9DT1BZX1NDT1JFOwp9Cgp2b2lkIHNldHVwX3Njb3JlYm9hcmQoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLCBjb25zdCBjaGFyICpwYXRoLCBzdHJ1Y3QgYmxhbWVfb3JpZ2luICoqb3JpZykKewoJY29uc3QgY2hhciAqZmluYWxfY29tbWl0X25hbWUgPSBOVUxMOwoJc3RydWN0IGJsYW1lX29yaWdpbiAqbzsKCXN0cnVjdCBjb21taXQgKmZpbmFsX2NvbW1pdCA9IE5VTEw7CgllbnVtIG9iamVjdF90eXBlIHR5cGU7CgoJaWYgKHNiLT5yZXZlcnNlICYmIHNiLT5jb250ZW50c19mcm9tKQoJCWRpZShfKCItLWNvbnRlbnRzIGFuZCAtLXJldmVyc2UgZG8gbm90IGJsZW5kIHdlbGwuIikpOwoKCWlmICghc2ItPnJldmVyc2UpIHsKCQlzYi0+ZmluYWwgPSBmaW5kX3NpbmdsZV9maW5hbChzYi0+cmV2cywgJmZpbmFsX2NvbW1pdF9uYW1lKTsKCQlzYi0+Y29tbWl0cy5jb21wYXJlID0gY29tcGFyZV9jb21taXRzX2J5X2NvbW1pdF9kYXRlOwoJfSBlbHNlIHsKCQlzYi0+ZmluYWwgPSBmaW5kX3NpbmdsZV9pbml0aWFsKHNiLT5yZXZzLCAmZmluYWxfY29tbWl0X25hbWUpOwoJCXNiLT5jb21taXRzLmNvbXBhcmUgPSBjb21wYXJlX2NvbW1pdHNfYnlfcmV2ZXJzZV9jb21taXRfZGF0ZTsKCX0KCglpZiAoc2ItPmZpbmFsICYmIHNiLT5jb250ZW50c19mcm9tKQoJCWRpZShfKCJjYW5ub3QgdXNlIC0tY29udGVudHMgd2l0aCBmaW5hbCBjb21taXQgb2JqZWN0IG5hbWUiKSk7CgoJaWYgKHNiLT5yZXZlcnNlICYmIHNiLT5yZXZzLT5maXJzdF9wYXJlbnRfb25seSkKCQlzYi0+cmV2cy0+Y2hpbGRyZW4ubmFtZSA9IE5VTEw7CgoJaWYgKCFzYi0+ZmluYWwpIHsKCQkvKgoJCSAqICItLW5vdCBBIEIgLS0gcGF0aCIgd2l0aG91dCBhbnl0aGluZyBwb3NpdGl2ZTsKCQkgKiBkbyBub3QgZGVmYXVsdCB0byBIRUFELCBidXQgdXNlIHRoZSB3b3JraW5nIHRyZWUKCQkgKiBvciAiLS1jb250ZW50cyIuCgkJICovCgkJc2V0dXBfd29ya190cmVlKCk7CgkJc2ItPmZpbmFsID0gZmFrZV93b3JraW5nX3RyZWVfY29tbWl0KCZzYi0+cmV2cy0+ZGlmZm9wdCwKCQkJCQkJICAgICBwYXRoLCBzYi0+Y29udGVudHNfZnJvbSk7CgkJYWRkX3BlbmRpbmdfb2JqZWN0KHNiLT5yZXZzLCAmKHNiLT5maW5hbC0+b2JqZWN0KSwgIjoiKTsKCX0KCglpZiAoc2ItPnJldmVyc2UgJiYgc2ItPnJldnMtPmZpcnN0X3BhcmVudF9vbmx5KSB7CgkJZmluYWxfY29tbWl0ID0gZmluZF9zaW5nbGVfZmluYWwoc2ItPnJldnMsIE5VTEwpOwoJCWlmICghZmluYWxfY29tbWl0KQoJCQlkaWUoXygiLS1yZXZlcnNlIGFuZCAtLWZpcnN0LXBhcmVudCB0b2dldGhlciByZXF1aXJlIHNwZWNpZmllZCBsYXRlc3QgY29tbWl0IikpOwoJfQoKCS8qCgkgKiBJZiB3ZSBoYXZlIGJvdHRvbSwgdGhpcyB3aWxsIG1hcmsgdGhlIGFuY2VzdG9ycyBvZiB0aGUKCSAqIGJvdHRvbSBjb21taXRzIHdlIHdvdWxkIHJlYWNoIHdoaWxlIHRyYXZlcnNpbmcgYXMKCSAqIHVuaW50ZXJlc3RpbmcuCgkgKi8KCWlmIChwcmVwYXJlX3JldmlzaW9uX3dhbGsoc2ItPnJldnMpKQoJCWRpZShfKCJyZXZpc2lvbiB3YWxrIHNldHVwIGZhaWxlZCIpKTsKCglpZiAoc2ItPnJldmVyc2UgJiYgc2ItPnJldnMtPmZpcnN0X3BhcmVudF9vbmx5KSB7CgkJc3RydWN0IGNvbW1pdCAqYyA9IGZpbmFsX2NvbW1pdDsKCgkJc2ItPnJldnMtPmNoaWxkcmVuLm5hbWUgPSAiY2hpbGRyZW4iOwoJCXdoaWxlIChjLT5wYXJlbnRzICYmCgkJICAgICAgIG9pZGNtcCgmYy0+b2JqZWN0Lm9pZCwgJnNiLT5maW5hbC0+b2JqZWN0Lm9pZCkpIHsKCQkJc3RydWN0IGNvbW1pdF9saXN0ICpsID0geGNhbGxvYygxLCBzaXplb2YoKmwpKTsKCgkJCWwtPml0ZW0gPSBjOwoJCQlpZiAoYWRkX2RlY29yYXRpb24oJnNiLT5yZXZzLT5jaGlsZHJlbiwKCQkJCQkgICAmYy0+cGFyZW50cy0+aXRlbS0+b2JqZWN0LCBsKSkKCQkJCWRpZSgiQlVHOiBub3QgdW5pcXVlIGl0ZW0gaW4gZmlyc3QtcGFyZW50IGNoYWluIik7CgkJCWMgPSBjLT5wYXJlbnRzLT5pdGVtOwoJCX0KCgkJaWYgKG9pZGNtcCgmYy0+b2JqZWN0Lm9pZCwgJnNiLT5maW5hbC0+b2JqZWN0Lm9pZCkpCgkJCWRpZShfKCItLXJldmVyc2UgLS1maXJzdC1wYXJlbnQgdG9nZXRoZXIgcmVxdWlyZSByYW5nZSBhbG9uZyBmaXJzdC1wYXJlbnQgY2hhaW4iKSk7Cgl9CgoJaWYgKGlzX251bGxfb2lkKCZzYi0+ZmluYWwtPm9iamVjdC5vaWQpKSB7CgkJbyA9IHNiLT5maW5hbC0+dXRpbDsKCQlzYi0+ZmluYWxfYnVmID0geG1lbWR1cHooby0+ZmlsZS5wdHIsIG8tPmZpbGUuc2l6ZSk7CgkJc2ItPmZpbmFsX2J1Zl9zaXplID0gby0+ZmlsZS5zaXplOwoJfQoJZWxzZSB7CgkJbyA9IGdldF9vcmlnaW4oc2ItPmZpbmFsLCBwYXRoKTsKCQlpZiAoZmlsbF9ibG9iX3NoYTFfYW5kX21vZGUobykpCgkJCWRpZShfKCJubyBzdWNoIHBhdGggJXMgaW4gJXMiKSwgcGF0aCwgZmluYWxfY29tbWl0X25hbWUpOwoKCQlpZiAoRElGRl9PUFRfVFNUKCZzYi0+cmV2cy0+ZGlmZm9wdCwgQUxMT1dfVEVYVENPTlYpICYmCgkJICAgIHRleHRjb252X29iamVjdChwYXRoLCBvLT5tb2RlLCAmby0+YmxvYl9vaWQsIDEsIChjaGFyICoqKSAmc2ItPmZpbmFsX2J1ZiwKCQkJCSAgICAmc2ItPmZpbmFsX2J1Zl9zaXplKSkKCQkJOwoJCWVsc2UKCQkJc2ItPmZpbmFsX2J1ZiA9IHJlYWRfc2hhMV9maWxlKG8tPmJsb2Jfb2lkLmhhc2gsICZ0eXBlLAoJCQkJCQkgICAgICAgJnNiLT5maW5hbF9idWZfc2l6ZSk7CgoJCWlmICghc2ItPmZpbmFsX2J1ZikKCQkJZGllKF8oImNhbm5vdCByZWFkIGJsb2IgJXMgZm9yIHBhdGggJXMiKSwKCQkJICAgIG9pZF90b19oZXgoJm8tPmJsb2Jfb2lkKSwKCQkJICAgIHBhdGgpOwoJfQoJc2ItPm51bV9yZWFkX2Jsb2IrKzsKCXByZXBhcmVfbGluZXMoc2IpOwoKCWlmIChvcmlnKQoJCSpvcmlnID0gbzsKfQoKCgpzdHJ1Y3QgYmxhbWVfZW50cnkgKmJsYW1lX2VudHJ5X3ByZXBlbmQoc3RydWN0IGJsYW1lX2VudHJ5ICpoZWFkLAoJCQkJCWxvbmcgc3RhcnQsIGxvbmcgZW5kLAoJCQkJCXN0cnVjdCBibGFtZV9vcmlnaW4gKm8pCnsKCXN0cnVjdCBibGFtZV9lbnRyeSAqbmV3X2hlYWQgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3QgYmxhbWVfZW50cnkpKTsKCW5ld19oZWFkLT5sbm8gPSBzdGFydDsKCW5ld19oZWFkLT5udW1fbGluZXMgPSBlbmQgLSBzdGFydDsKCW5ld19oZWFkLT5zdXNwZWN0ID0gbzsKCW5ld19oZWFkLT5zX2xubyA9IHN0YXJ0OwoJbmV3X2hlYWQtPm5leHQgPSBoZWFkOwoJYmxhbWVfb3JpZ2luX2luY3JlZihvKTsKCXJldHVybiBuZXdfaGVhZDsKfQo=",
    "text": "#include \"cache.h\"\n#include \"refs.h\"\n#include \"cache-tree.h\"\n#include \"mergesort.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"tag.h\"\n#include \"blame.h\"\n\nvoid blame_origin_decref(struct blame_origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tstruct blame_origin *p, *l = NULL;\n\t\tif (o->previous)\n\t\t\tblame_origin_decref(o->previous);\n\t\tfree(o->file.ptr);\n\t\t/* Should be present exactly once in commit chain */\n\t\tfor (p = o->commit->util; p; l = p, p = p->next) {\n\t\t\tif (p == o) {\n\t\t\t\tif (l)\n\t\t\t\t\tl->next = p->next;\n\t\t\t\telse\n\t\t\t\t\to->commit->util = p->next;\n\t\t\t\tfree(o);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdie(\"internal error in blame_origin_decref\");\n\t}\n}\n\n/*\n * Given a commit and a path in it, create a new origin structure.\n * The callers that add blame to the scoreboard should use\n * get_origin() to obtain shared, refcounted copy instead of calling\n * this function directly.\n */\nstatic struct blame_origin *make_origin(struct commit *commit, const char *path)\n{\n\tstruct blame_origin *o;\n\tFLEX_ALLOC_STR(o, path, path);\n\to->commit = commit;\n\to->refcnt = 1;\n\to->next = commit->util;\n\tcommit->util = o;\n\treturn o;\n}\n\n/*\n * Locate an existing origin or create a new one.\n * This moves the origin to front position in the commit util list.\n */\nstatic struct blame_origin *get_origin(struct commit *commit, const char *path)\n{\n\tstruct blame_origin *o, *l;\n\n\tfor (o = commit->util, l = NULL; o; l = o, o = o->next) {\n\t\tif (!strcmp(o->path, path)) {\n\t\t\t/* bump to front */\n\t\t\tif (l) {\n\t\t\t\tl->next = o->next;\n\t\t\t\to->next = commit->util;\n\t\t\t\tcommit->util = o;\n\t\t\t}\n\t\t\treturn blame_origin_incref(o);\n\t\t}\n\t}\n\treturn make_origin(commit, path);\n}\n\n\n\nstatic void verify_working_tree_path(struct commit *work_tree, const char *path)\n{\n\tstruct commit_list *parents;\n\tint pos;\n\n\tfor (parents = work_tree->parents; parents; parents = parents->next) {\n\t\tconst struct object_id *commit_oid = &parents->item->object.oid;\n\t\tstruct object_id blob_oid;\n\t\tunsigned mode;\n\n\t\tif (!get_tree_entry(commit_oid->hash, path, blob_oid.hash, &mode) &&\n\t\t    sha1_object_info(blob_oid.hash, NULL) == OBJ_BLOB)\n\t\t\treturn;\n\t}\n\n\tpos = cache_name_pos(path, strlen(path));\n\tif (pos >= 0)\n\t\t; /* path is in the index */\n\telse if (-1 - pos < active_nr &&\n\t\t !strcmp(active_cache[-1 - pos]->name, path))\n\t\t; /* path is in the index, unmerged */\n\telse\n\t\tdie(\"no such path '%s' in HEAD\", path);\n}\n\nstatic struct commit_list **append_parent(struct commit_list **tail, const struct object_id *oid)\n{\n\tstruct commit *parent;\n\n\tparent = lookup_commit_reference(oid->hash);\n\tif (!parent)\n\t\tdie(\"no such commit %s\", oid_to_hex(oid));\n\treturn &commit_list_insert(parent, tail)->next;\n}\n\nstatic void append_merge_parents(struct commit_list **tail)\n{\n\tint merge_head;\n\tstruct strbuf line = STRBUF_INIT;\n\n\tmerge_head = open(git_path_merge_head(), O_RDONLY);\n\tif (merge_head < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn;\n\t\tdie(\"cannot open '%s' for reading\", git_path_merge_head());\n\t}\n\n\twhile (!strbuf_getwholeline_fd(&line, merge_head, '\\n')) {\n\t\tstruct object_id oid;\n\t\tif (line.len < GIT_SHA1_HEXSZ || get_oid_hex(line.buf, &oid))\n\t\t\tdie(\"unknown line in '%s': %s\", git_path_merge_head(), line.buf);\n\t\ttail = append_parent(tail, &oid);\n\t}\n\tclose(merge_head);\n\tstrbuf_release(&line);\n}\n\n/*\n * This isn't as simple as passing sb->buf and sb->len, because we\n * want to transfer ownership of the buffer to the commit (so we\n * must use detach).\n */\nstatic void set_commit_buffer_from_strbuf(struct commit *c, struct strbuf *sb)\n{\n\tsize_t len;\n\tvoid *buf = strbuf_detach(sb, &len);\n\tset_commit_buffer(c, buf, len);\n}\n\n/*\n * Prepare a dummy commit that represents the work tree (or staged) item.\n * Note that annotating work tree item never works in the reverse.\n */\nstatic struct commit *fake_working_tree_commit(struct diff_options *opt,\n\t\t\t\t\t       const char *path,\n\t\t\t\t\t       const char *contents_from)\n{\n\tstruct commit *commit;\n\tstruct blame_origin *origin;\n\tstruct commit_list **parent_tail, *parent;\n\tstruct object_id head_oid;\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *ident;\n\ttime_t now;\n\tint size, len;\n\tstruct cache_entry *ce;\n\tunsigned mode;\n\tstruct strbuf msg = STRBUF_INIT;\n\n\tread_cache();\n\ttime(&now);\n\tcommit = alloc_commit_node();\n\tcommit->object.parsed = 1;\n\tcommit->date = now;\n\tparent_tail = &commit->parents;\n\n\tif (!resolve_ref_unsafe(\"HEAD\", RESOLVE_REF_READING, head_oid.hash, NULL))\n\t\tdie(\"no such ref: HEAD\");\n\n\tparent_tail = append_parent(parent_tail, &head_oid);\n\tappend_merge_parents(parent_tail);\n\tverify_working_tree_path(commit, path);\n\n\torigin = make_origin(commit, path);\n\n\tident = fmt_ident(\"Not Committed Yet\", \"not.committed.yet\", NULL, 0);\n\tstrbuf_addstr(&msg, \"tree 0000000000000000000000000000000000000000\\n\");\n\tfor (parent = commit->parents; parent; parent = parent->next)\n\t\tstrbuf_addf(&msg, \"parent %s\\n\",\n\t\t\t    oid_to_hex(&parent->item->object.oid));\n\tstrbuf_addf(&msg,\n\t\t    \"author %s\\n\"\n\t\t    \"committer %s\\n\\n\"\n\t\t    \"Version of %s from %s\\n\",\n\t\t    ident, ident, path,\n\t\t    (!contents_from ? path :\n\t\t     (!strcmp(contents_from, \"-\") ? \"standard input\" : contents_from)));\n\tset_commit_buffer_from_strbuf(commit, &msg);\n\n\tif (!contents_from || strcmp(\"-\", contents_from)) {\n\t\tstruct stat st;\n\t\tconst char *read_from;\n\t\tchar *buf_ptr;\n\t\tunsigned long buf_len;\n\n\t\tif (contents_from) {\n\t\t\tif (stat(contents_from, &st) < 0)\n\t\t\t\tdie_errno(\"Cannot stat '%s'\", contents_from);\n\t\t\tread_from = contents_from;\n\t\t}\n\t\telse {\n\t\t\tif (lstat(path, &st) < 0)\n\t\t\t\tdie_errno(\"Cannot lstat '%s'\", path);\n\t\t\tread_from = path;\n\t\t}\n\t\tmode = canon_mode(st.st_mode);\n\n\t\tswitch (st.st_mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tif (DIFF_OPT_TST(opt, ALLOW_TEXTCONV) &&\n\t\t\t    textconv_object(read_from, mode, &null_oid, 0, &buf_ptr, &buf_len))\n\t\t\t\tstrbuf_attach(&buf, buf_ptr, buf_len, buf_len + 1);\n\t\t\telse if (strbuf_read_file(&buf, read_from, st.st_size) != st.st_size)\n\t\t\t\tdie_errno(\"cannot open or read '%s'\", read_from);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tif (strbuf_readlink(&buf, read_from, st.st_size) < 0)\n\t\t\t\tdie_errno(\"cannot readlink '%s'\", read_from);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdie(\"unsupported file type %s\", read_from);\n\t\t}\n\t}\n\telse {\n\t\t/* Reading from stdin */\n\t\tmode = 0;\n\t\tif (strbuf_read(&buf, 0, 0) < 0)\n\t\t\tdie_errno(\"failed to read from stdin\");\n\t}\n\tconvert_to_git(path, buf.buf, buf.len, &buf, 0);\n\torigin->file.ptr = buf.buf;\n\torigin->file.size = buf.len;\n\tpretend_sha1_file(buf.buf, buf.len, OBJ_BLOB, origin->blob_oid.hash);\n\n\t/*\n\t * Read the current index, replace the path entry with\n\t * origin->blob_sha1 without mucking with its mode or type\n\t * bits; we are not going to write this index out -- we just\n\t * want to run \"diff-index --cached\".\n\t */\n\tdiscard_cache();\n\tread_cache();\n\n\tlen = strlen(path);\n\tif (!mode) {\n\t\tint pos = cache_name_pos(path, len);\n\t\tif (0 <= pos)\n\t\t\tmode = active_cache[pos]->ce_mode;\n\t\telse\n\t\t\t/* Let's not bother reading from HEAD tree */\n\t\t\tmode = S_IFREG | 0644;\n\t}\n\tsize = cache_entry_size(len);\n\tce = xcalloc(1, size);\n\toidcpy(&ce->oid, &origin->blob_oid);\n\tmemcpy(ce->name, path, len);\n\tce->ce_flags = create_ce_flags(0);\n\tce->ce_namelen = len;\n\tce->ce_mode = create_ce_mode(mode);\n\tadd_cache_entry(ce, ADD_CACHE_OK_TO_ADD|ADD_CACHE_OK_TO_REPLACE);\n\n\tcache_tree_invalidate_path(&the_index, path);\n\n\treturn commit;\n}\n\n\n\nstatic int diff_hunks(mmfile_t *file_a, mmfile_t *file_b,\n\t\t      xdl_emit_hunk_consume_func_t hunk_func, void *cb_data, int xdl_opts)\n{\n\txpparam_t xpp = {0};\n\txdemitconf_t xecfg = {0};\n\txdemitcb_t ecb = {NULL};\n\n\txpp.flags = xdl_opts;\n\txecfg.hunk_func = hunk_func;\n\tecb.priv = cb_data;\n\treturn xdi_diff(file_a, file_b, &xpp, &xecfg, &ecb);\n}\n\n/*\n * Given an origin, prepare mmfile_t structure to be used by the\n * diff machinery\n */\nstatic void fill_origin_blob(struct diff_options *opt,\n\t\t\t     struct blame_origin *o, mmfile_t *file, int *num_read_blob)\n{\n\tif (!o->file.ptr) {\n\t\tenum object_type type;\n\t\tunsigned long file_size;\n\n\t\t(*num_read_blob)++;\n\t\tif (DIFF_OPT_TST(opt, ALLOW_TEXTCONV) &&\n\t\t    textconv_object(o->path, o->mode, &o->blob_oid, 1, &file->ptr, &file_size))\n\t\t\t;\n\t\telse\n\t\t\tfile->ptr = read_sha1_file(o->blob_oid.hash, &type,\n\t\t\t\t\t\t   &file_size);\n\t\tfile->size = file_size;\n\n\t\tif (!file->ptr)\n\t\t\tdie(\"Cannot read blob %s for path %s\",\n\t\t\t    oid_to_hex(&o->blob_oid),\n\t\t\t    o->path);\n\t\to->file = *file;\n\t}\n\telse\n\t\t*file = o->file;\n}\n\nstatic void drop_origin_blob(struct blame_origin *o)\n{\n\tif (o->file.ptr) {\n\t\tfree(o->file.ptr);\n\t\to->file.ptr = NULL;\n\t}\n}\n\n/*\n * Any merge of blames happens on lists of blames that arrived via\n * different parents in a single suspect.  In this case, we want to\n * sort according to the suspect line numbers as opposed to the final\n * image line numbers.  The function body is somewhat longish because\n * it avoids unnecessary writes.\n */\n\nstatic struct blame_entry *blame_merge(struct blame_entry *list1,\n\t\t\t\t       struct blame_entry *list2)\n{\n\tstruct blame_entry *p1 = list1, *p2 = list2,\n\t\t**tail = &list1;\n\n\tif (!p1)\n\t\treturn p2;\n\tif (!p2)\n\t\treturn p1;\n\n\tif (p1->s_lno <= p2->s_lno) {\n\t\tdo {\n\t\t\ttail = &p1->next;\n\t\t\tif ((p1 = *tail) == NULL) {\n\t\t\t\t*tail = p2;\n\t\t\t\treturn list1;\n\t\t\t}\n\t\t} while (p1->s_lno <= p2->s_lno);\n\t}\n\tfor (;;) {\n\t\t*tail = p2;\n\t\tdo {\n\t\t\ttail = &p2->next;\n\t\t\tif ((p2 = *tail) == NULL)  {\n\t\t\t\t*tail = p1;\n\t\t\t\treturn list1;\n\t\t\t}\n\t\t} while (p1->s_lno > p2->s_lno);\n\t\t*tail = p1;\n\t\tdo {\n\t\t\ttail = &p1->next;\n\t\t\tif ((p1 = *tail) == NULL) {\n\t\t\t\t*tail = p2;\n\t\t\t\treturn list1;\n\t\t\t}\n\t\t} while (p1->s_lno <= p2->s_lno);\n\t}\n}\n\nstatic void *get_next_blame(const void *p)\n{\n\treturn ((struct blame_entry *)p)->next;\n}\n\nstatic void set_next_blame(void *p1, void *p2)\n{\n\t((struct blame_entry *)p1)->next = p2;\n}\n\n/*\n * Final image line numbers are all different, so we don't need a\n * three-way comparison here.\n */\n\nstatic int compare_blame_final(const void *p1, const void *p2)\n{\n\treturn ((struct blame_entry *)p1)->lno > ((struct blame_entry *)p2)->lno\n\t\t? 1 : -1;\n}\n\nstatic int compare_blame_suspect(const void *p1, const void *p2)\n{\n\tconst struct blame_entry *s1 = p1, *s2 = p2;\n\t/*\n\t * to allow for collating suspects, we sort according to the\n\t * respective pointer value as the primary sorting criterion.\n\t * The actual relation is pretty unimportant as long as it\n\t * establishes a total order.  Comparing as integers gives us\n\t * that.\n\t */\n\tif (s1->suspect != s2->suspect)\n\t\treturn (intptr_t)s1->suspect > (intptr_t)s2->suspect ? 1 : -1;\n\tif (s1->s_lno == s2->s_lno)\n\t\treturn 0;\n\treturn s1->s_lno > s2->s_lno ? 1 : -1;\n}\n\nvoid blame_sort_final(struct blame_scoreboard *sb)\n{\n\tsb->ent = llist_mergesort(sb->ent, get_next_blame, set_next_blame,\n\t\t\t\t  compare_blame_final);\n}\n\nstatic int compare_commits_by_reverse_commit_date(const void *a,\n\t\t\t\t\t\t  const void *b,\n\t\t\t\t\t\t  void *c)\n{\n\treturn -compare_commits_by_commit_date(a, b, c);\n}\n\n/*\n * For debugging -- origin is refcounted, and this asserts that\n * we do not underflow.\n */\nstatic void sanity_check_refcnt(struct blame_scoreboard *sb)\n{\n\tint baa = 0;\n\tstruct blame_entry *ent;\n\n\tfor (ent = sb->ent; ent; ent = ent->next) {\n\t\t/* Nobody should have zero or negative refcnt */\n\t\tif (ent->suspect->refcnt <= 0) {\n\t\t\tfprintf(stderr, \"%s in %s has negative refcnt %d\\n\",\n\t\t\t\tent->suspect->path,\n\t\t\t\toid_to_hex(&ent->suspect->commit->object.oid),\n\t\t\t\tent->suspect->refcnt);\n\t\t\tbaa = 1;\n\t\t}\n\t}\n\tif (baa)\n\t\tsb->on_sanity_fail(sb, baa);\n}\n\n/*\n * If two blame entries that are next to each other came from\n * contiguous lines in the same origin (i.e. <commit, path> pair),\n * merge them together.\n */\nvoid blame_coalesce(struct blame_scoreboard *sb)\n{\n\tstruct blame_entry *ent, *next;\n\n\tfor (ent = sb->ent; ent && (next = ent->next); ent = next) {\n\t\tif (ent->suspect == next->suspect &&\n\t\t    ent->s_lno + ent->num_lines == next->s_lno) {\n\t\t\tent->num_lines += next->num_lines;\n\t\t\tent->next = next->next;\n\t\t\tblame_origin_decref(next->suspect);\n\t\t\tfree(next);\n\t\t\tent->score = 0;\n\t\t\tnext = ent; /* again */\n\t\t}\n\t}\n\n\tif (sb->debug) /* sanity */\n\t\tsanity_check_refcnt(sb);\n}\n\n/*\n * Merge the given sorted list of blames into a preexisting origin.\n * If there were no previous blames to that commit, it is entered into\n * the commit priority queue of the score board.\n */\n\nstatic void queue_blames(struct blame_scoreboard *sb, struct blame_origin *porigin,\n\t\t\t struct blame_entry *sorted)\n{\n\tif (porigin->suspects)\n\t\tporigin->suspects = blame_merge(porigin->suspects, sorted);\n\telse {\n\t\tstruct blame_origin *o;\n\t\tfor (o = porigin->commit->util; o; o = o->next) {\n\t\t\tif (o->suspects) {\n\t\t\t\tporigin->suspects = sorted;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tporigin->suspects = sorted;\n\t\tprio_queue_put(&sb->commits, porigin->commit);\n\t}\n}\n\n/*\n * Fill the blob_sha1 field of an origin if it hasn't, so that later\n * call to fill_origin_blob() can use it to locate the data.  blob_sha1\n * for an origin is also used to pass the blame for the entire file to\n * the parent to detect the case where a child's blob is identical to\n * that of its parent's.\n *\n * This also fills origin->mode for corresponding tree path.\n */\nstatic int fill_blob_sha1_and_mode(struct blame_origin *origin)\n{\n\tif (!is_null_oid(&origin->blob_oid))\n\t\treturn 0;\n\tif (get_tree_entry(origin->commit->object.oid.hash,\n\t\t\t   origin->path,\n\t\t\t   origin->blob_oid.hash, &origin->mode))\n\t\tgoto error_out;\n\tif (sha1_object_info(origin->blob_oid.hash, NULL) != OBJ_BLOB)\n\t\tgoto error_out;\n\treturn 0;\n error_out:\n\toidclr(&origin->blob_oid);\n\torigin->mode = S_IFINVALID;\n\treturn -1;\n}\n\n/*\n * We have an origin -- check if the same path exists in the\n * parent and return an origin structure to represent it.\n */\nstatic struct blame_origin *find_origin(struct commit *parent,\n\t\t\t\t  struct blame_origin *origin)\n{\n\tstruct blame_origin *porigin;\n\tstruct diff_options diff_opts;\n\tconst char *paths[2];\n\n\t/* First check any existing origins */\n\tfor (porigin = parent->util; porigin; porigin = porigin->next)\n\t\tif (!strcmp(porigin->path, origin->path)) {\n\t\t\t/*\n\t\t\t * The same path between origin and its parent\n\t\t\t * without renaming -- the most common case.\n\t\t\t */\n\t\t\treturn blame_origin_incref (porigin);\n\t\t}\n\n\t/* See if the origin->path is different between parent\n\t * and origin first.  Most of the time they are the\n\t * same and diff-tree is fairly efficient about this.\n\t */\n\tdiff_setup(&diff_opts);\n\tDIFF_OPT_SET(&diff_opts, RECURSIVE);\n\tdiff_opts.detect_rename = 0;\n\tdiff_opts.output_format = DIFF_FORMAT_NO_OUTPUT;\n\tpaths[0] = origin->path;\n\tpaths[1] = NULL;\n\n\tparse_pathspec(&diff_opts.pathspec,\n\t\t       PATHSPEC_ALL_MAGIC & ~PATHSPEC_LITERAL,\n\t\t       PATHSPEC_LITERAL_PATH, \"\", paths);\n\tdiff_setup_done(&diff_opts);\n\n\tif (is_null_oid(&origin->commit->object.oid))\n\t\tdo_diff_cache(parent->tree->object.oid.hash, &diff_opts);\n\telse\n\t\tdiff_tree_sha1(parent->tree->object.oid.hash,\n\t\t\t       origin->commit->tree->object.oid.hash,\n\t\t\t       \"\", &diff_opts);\n\tdiffcore_std(&diff_opts);\n\n\tif (!diff_queued_diff.nr) {\n\t\t/* The path is the same as parent */\n\t\tporigin = get_origin(parent, origin->path);\n\t\toidcpy(&porigin->blob_oid, &origin->blob_oid);\n\t\tporigin->mode = origin->mode;\n\t} else {\n\t\t/*\n\t\t * Since origin->path is a pathspec, if the parent\n\t\t * commit had it as a directory, we will see a whole\n\t\t * bunch of deletion of files in the directory that we\n\t\t * do not care about.\n\t\t */\n\t\tint i;\n\t\tstruct diff_filepair *p = NULL;\n\t\tfor (i = 0; i < diff_queued_diff.nr; i++) {\n\t\t\tconst char *name;\n\t\t\tp = diff_queued_diff.queue[i];\n\t\t\tname = p->one->path ? p->one->path : p->two->path;\n\t\t\tif (!strcmp(name, origin->path))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!p)\n\t\t\tdie(\"internal error in blame::find_origin\");\n\t\tswitch (p->status) {\n\t\tdefault:\n\t\t\tdie(\"internal error in blame::find_origin (%c)\",\n\t\t\t    p->status);\n\t\tcase 'M':\n\t\t\tporigin = get_origin(parent, origin->path);\n\t\t\toidcpy(&porigin->blob_oid, &p->one->oid);\n\t\t\tporigin->mode = p->one->mode;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\tcase 'T':\n\t\t\t/* Did not exist in parent, or type changed */\n\t\t\tbreak;\n\t\t}\n\t}\n\tdiff_flush(&diff_opts);\n\tclear_pathspec(&diff_opts.pathspec);\n\treturn porigin;\n}\n\n/*\n * We have an origin -- find the path that corresponds to it in its\n * parent and return an origin structure to represent it.\n */\nstatic struct blame_origin *find_rename(struct commit *parent,\n\t\t\t\t  struct blame_origin *origin)\n{\n\tstruct blame_origin *porigin = NULL;\n\tstruct diff_options diff_opts;\n\tint i;\n\n\tdiff_setup(&diff_opts);\n\tDIFF_OPT_SET(&diff_opts, RECURSIVE);\n\tdiff_opts.detect_rename = DIFF_DETECT_RENAME;\n\tdiff_opts.output_format = DIFF_FORMAT_NO_OUTPUT;\n\tdiff_opts.single_follow = origin->path;\n\tdiff_setup_done(&diff_opts);\n\n\tif (is_null_oid(&origin->commit->object.oid))\n\t\tdo_diff_cache(parent->tree->object.oid.hash, &diff_opts);\n\telse\n\t\tdiff_tree_sha1(parent->tree->object.oid.hash,\n\t\t\t       origin->commit->tree->object.oid.hash,\n\t\t\t       \"\", &diff_opts);\n\tdiffcore_std(&diff_opts);\n\n\tfor (i = 0; i < diff_queued_diff.nr; i++) {\n\t\tstruct diff_filepair *p = diff_queued_diff.queue[i];\n\t\tif ((p->status == 'R' || p->status == 'C') &&\n\t\t    !strcmp(p->two->path, origin->path)) {\n\t\t\tporigin = get_origin(parent, p->one->path);\n\t\t\toidcpy(&porigin->blob_oid, &p->one->oid);\n\t\t\tporigin->mode = p->one->mode;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdiff_flush(&diff_opts);\n\tclear_pathspec(&diff_opts.pathspec);\n\treturn porigin;\n}\n\n/*\n * Append a new blame entry to a given output queue.\n */\nstatic void add_blame_entry(struct blame_entry ***queue,\n\t\t\t    const struct blame_entry *src)\n{\n\tstruct blame_entry *e = xmalloc(sizeof(*e));\n\tmemcpy(e, src, sizeof(*e));\n\tblame_origin_incref(e->suspect);\n\n\te->next = **queue;\n\t**queue = e;\n\t*queue = &e->next;\n}\n\n/*\n * src typically is on-stack; we want to copy the information in it to\n * a malloced blame_entry that gets added to the given queue.  The\n * origin of dst loses a refcnt.\n */\nstatic void dup_entry(struct blame_entry ***queue,\n\t\t      struct blame_entry *dst, struct blame_entry *src)\n{\n\tblame_origin_incref(src->suspect);\n\tblame_origin_decref(dst->suspect);\n\tmemcpy(dst, src, sizeof(*src));\n\tdst->next = **queue;\n\t**queue = dst;\n\t*queue = &dst->next;\n}\n\nconst char *blame_nth_line(struct blame_scoreboard *sb, long lno)\n{\n\treturn sb->final_buf + sb->lineno[lno];\n}\n\n/*\n * It is known that lines between tlno to same came from parent, and e\n * has an overlap with that range.  it also is known that parent's\n * line plno corresponds to e's line tlno.\n *\n *                <---- e ----->\n *                   <------>\n *                   <------------>\n *             <------------>\n *             <------------------>\n *\n * Split e into potentially three parts; before this chunk, the chunk\n * to be blamed for the parent, and after that portion.\n */\nstatic void split_overlap(struct blame_entry *split,\n\t\t\t  struct blame_entry *e,\n\t\t\t  int tlno, int plno, int same,\n\t\t\t  struct blame_origin *parent)\n{\n\tint chunk_end_lno;\n\tmemset(split, 0, sizeof(struct blame_entry [3]));\n\n\tif (e->s_lno < tlno) {\n\t\t/* there is a pre-chunk part not blamed on parent */\n\t\tsplit[0].suspect = blame_origin_incref(e->suspect);\n\t\tsplit[0].lno = e->lno;\n\t\tsplit[0].s_lno = e->s_lno;\n\t\tsplit[0].num_lines = tlno - e->s_lno;\n\t\tsplit[1].lno = e->lno + tlno - e->s_lno;\n\t\tsplit[1].s_lno = plno;\n\t}\n\telse {\n\t\tsplit[1].lno = e->lno;\n\t\tsplit[1].s_lno = plno + (e->s_lno - tlno);\n\t}\n\n\tif (same < e->s_lno + e->num_lines) {\n\t\t/* there is a post-chunk part not blamed on parent */\n\t\tsplit[2].suspect = blame_origin_incref(e->suspect);\n\t\tsplit[2].lno = e->lno + (same - e->s_lno);\n\t\tsplit[2].s_lno = e->s_lno + (same - e->s_lno);\n\t\tsplit[2].num_lines = e->s_lno + e->num_lines - same;\n\t\tchunk_end_lno = split[2].lno;\n\t}\n\telse\n\t\tchunk_end_lno = e->lno + e->num_lines;\n\tsplit[1].num_lines = chunk_end_lno - split[1].lno;\n\n\t/*\n\t * if it turns out there is nothing to blame the parent for,\n\t * forget about the splitting.  !split[1].suspect signals this.\n\t */\n\tif (split[1].num_lines < 1)\n\t\treturn;\n\tsplit[1].suspect = blame_origin_incref(parent);\n}\n\n/*\n * split_overlap() divided an existing blame e into up to three parts\n * in split.  Any assigned blame is moved to queue to\n * reflect the split.\n */\nstatic void split_blame(struct blame_entry ***blamed,\n\t\t\tstruct blame_entry ***unblamed,\n\t\t\tstruct blame_entry *split,\n\t\t\tstruct blame_entry *e)\n{\n\tif (split[0].suspect && split[2].suspect) {\n\t\t/* The first part (reuse storage for the existing entry e) */\n\t\tdup_entry(unblamed, e, &split[0]);\n\n\t\t/* The last part -- me */\n\t\tadd_blame_entry(unblamed, &split[2]);\n\n\t\t/* ... and the middle part -- parent */\n\t\tadd_blame_entry(blamed, &split[1]);\n\t}\n\telse if (!split[0].suspect && !split[2].suspect)\n\t\t/*\n\t\t * The parent covers the entire area; reuse storage for\n\t\t * e and replace it with the parent.\n\t\t */\n\t\tdup_entry(blamed, e, &split[1]);\n\telse if (split[0].suspect) {\n\t\t/* me and then parent */\n\t\tdup_entry(unblamed, e, &split[0]);\n\t\tadd_blame_entry(blamed, &split[1]);\n\t}\n\telse {\n\t\t/* parent and then me */\n\t\tdup_entry(blamed, e, &split[1]);\n\t\tadd_blame_entry(unblamed, &split[2]);\n\t}\n}\n\n/*\n * After splitting the blame, the origins used by the\n * on-stack blame_entry should lose one refcnt each.\n */\nstatic void decref_split(struct blame_entry *split)\n{\n\tint i;\n\n\tfor (i = 0; i < 3; i++)\n\t\tblame_origin_decref(split[i].suspect);\n}\n\n/*\n * reverse_blame reverses the list given in head, appending tail.\n * That allows us to build lists in reverse order, then reverse them\n * afterwards.  This can be faster than building the list in proper\n * order right away.  The reason is that building in proper order\n * requires writing a link in the _previous_ element, while building\n * in reverse order just requires placing the list head into the\n * _current_ element.\n */\n\nstatic struct blame_entry *reverse_blame(struct blame_entry *head,\n\t\t\t\t\t struct blame_entry *tail)\n{\n\twhile (head) {\n\t\tstruct blame_entry *next = head->next;\n\t\thead->next = tail;\n\t\ttail = head;\n\t\thead = next;\n\t}\n\treturn tail;\n}\n\n/*\n * Process one hunk from the patch between the current suspect for\n * blame_entry e and its parent.  This first blames any unfinished\n * entries before the chunk (which is where target and parent start\n * differing) on the parent, and then splits blame entries at the\n * start and at the end of the difference region.  Since use of -M and\n * -C options may lead to overlapping/duplicate source line number\n * ranges, all we can rely on from sorting/merging is the order of the\n * first suspect line number.\n */\nstatic void blame_chunk(struct blame_entry ***dstq, struct blame_entry ***srcq,\n\t\t\tint tlno, int offset, int same,\n\t\t\tstruct blame_origin *parent)\n{\n\tstruct blame_entry *e = **srcq;\n\tstruct blame_entry *samep = NULL, *diffp = NULL;\n\n\twhile (e && e->s_lno < tlno) {\n\t\tstruct blame_entry *next = e->next;\n\t\t/*\n\t\t * current record starts before differing portion.  If\n\t\t * it reaches into it, we need to split it up and\n\t\t * examine the second part separately.\n\t\t */\n\t\tif (e->s_lno + e->num_lines > tlno) {\n\t\t\t/* Move second half to a new record */\n\t\t\tint len = tlno - e->s_lno;\n\t\t\tstruct blame_entry *n = xcalloc(1, sizeof (struct blame_entry));\n\t\t\tn->suspect = e->suspect;\n\t\t\tn->lno = e->lno + len;\n\t\t\tn->s_lno = e->s_lno + len;\n\t\t\tn->num_lines = e->num_lines - len;\n\t\t\te->num_lines = len;\n\t\t\te->score = 0;\n\t\t\t/* Push new record to diffp */\n\t\t\tn->next = diffp;\n\t\t\tdiffp = n;\n\t\t} else\n\t\t\tblame_origin_decref(e->suspect);\n\t\t/* Pass blame for everything before the differing\n\t\t * chunk to the parent */\n\t\te->suspect = blame_origin_incref(parent);\n\t\te->s_lno += offset;\n\t\te->next = samep;\n\t\tsamep = e;\n\t\te = next;\n\t}\n\t/*\n\t * As we don't know how much of a common stretch after this\n\t * diff will occur, the currently blamed parts are all that we\n\t * can assign to the parent for now.\n\t */\n\n\tif (samep) {\n\t\t**dstq = reverse_blame(samep, **dstq);\n\t\t*dstq = &samep->next;\n\t}\n\t/*\n\t * Prepend the split off portions: everything after e starts\n\t * after the blameable portion.\n\t */\n\te = reverse_blame(diffp, e);\n\n\t/*\n\t * Now retain records on the target while parts are different\n\t * from the parent.\n\t */\n\tsamep = NULL;\n\tdiffp = NULL;\n\twhile (e && e->s_lno < same) {\n\t\tstruct blame_entry *next = e->next;\n\n\t\t/*\n\t\t * If current record extends into sameness, need to split.\n\t\t */\n\t\tif (e->s_lno + e->num_lines > same) {\n\t\t\t/*\n\t\t\t * Move second half to a new record to be\n\t\t\t * processed by later chunks\n\t\t\t */\n\t\t\tint len = same - e->s_lno;\n\t\t\tstruct blame_entry *n = xcalloc(1, sizeof (struct blame_entry));\n\t\t\tn->suspect = blame_origin_incref(e->suspect);\n\t\t\tn->lno = e->lno + len;\n\t\t\tn->s_lno = e->s_lno + len;\n\t\t\tn->num_lines = e->num_lines - len;\n\t\t\te->num_lines = len;\n\t\t\te->score = 0;\n\t\t\t/* Push new record to samep */\n\t\t\tn->next = samep;\n\t\t\tsamep = n;\n\t\t}\n\t\te->next = diffp;\n\t\tdiffp = e;\n\t\te = next;\n\t}\n\t**srcq = reverse_blame(diffp, reverse_blame(samep, e));\n\t/* Move across elements that are in the unblamable portion */\n\tif (diffp)\n\t\t*srcq = &diffp->next;\n}\n\nstruct blame_chunk_cb_data {\n\tstruct blame_origin *parent;\n\tlong offset;\n\tstruct blame_entry **dstq;\n\tstruct blame_entry **srcq;\n};\n\n/* diff chunks are from parent to target */\nstatic int blame_chunk_cb(long start_a, long count_a,\n\t\t\t  long start_b, long count_b, void *data)\n{\n\tstruct blame_chunk_cb_data *d = data;\n\tif (start_a - start_b != d->offset)\n\t\tdie(\"internal error in blame::blame_chunk_cb\");\n\tblame_chunk(&d->dstq, &d->srcq, start_b, start_a - start_b,\n\t\t    start_b + count_b, d->parent);\n\td->offset = start_a + count_a - (start_b + count_b);\n\treturn 0;\n}\n\n/*\n * We are looking at the origin 'target' and aiming to pass blame\n * for the lines it is suspected to its parent.  Run diff to find\n * which lines came from parent and pass blame for them.\n */\nstatic void pass_blame_to_parent(struct blame_scoreboard *sb,\n\t\t\t\t struct blame_origin *target,\n\t\t\t\t struct blame_origin *parent)\n{\n\tmmfile_t file_p, file_o;\n\tstruct blame_chunk_cb_data d;\n\tstruct blame_entry *newdest = NULL;\n\n\tif (!target->suspects)\n\t\treturn; /* nothing remains for this target */\n\n\td.parent = parent;\n\td.offset = 0;\n\td.dstq = &newdest; d.srcq = &target->suspects;\n\n\tfill_origin_blob(&sb->revs->diffopt, parent, &file_p, &sb->num_read_blob);\n\tfill_origin_blob(&sb->revs->diffopt, target, &file_o, &sb->num_read_blob);\n\tsb->num_get_patch++;\n\n\tif (diff_hunks(&file_p, &file_o, blame_chunk_cb, &d, sb->xdl_opts))\n\t\tdie(\"unable to generate diff (%s -> %s)\",\n\t\t    oid_to_hex(&parent->commit->object.oid),\n\t\t    oid_to_hex(&target->commit->object.oid));\n\t/* The rest are the same as the parent */\n\tblame_chunk(&d.dstq, &d.srcq, INT_MAX, d.offset, INT_MAX, parent);\n\t*d.dstq = NULL;\n\tqueue_blames(sb, parent, newdest);\n\n\treturn;\n}\n\n/*\n * The lines in blame_entry after splitting blames many times can become\n * very small and trivial, and at some point it becomes pointless to\n * blame the parents.  E.g. \"\\t\\t}\\n\\t}\\n\\n\" appears everywhere in any\n * ordinary C program, and it is not worth to say it was copied from\n * totally unrelated file in the parent.\n *\n * Compute how trivial the lines in the blame_entry are.\n */\nunsigned blame_entry_score(struct blame_scoreboard *sb, struct blame_entry *e)\n{\n\tunsigned score;\n\tconst char *cp, *ep;\n\n\tif (e->score)\n\t\treturn e->score;\n\n\tscore = 1;\n\tcp = blame_nth_line(sb, e->lno);\n\tep = blame_nth_line(sb, e->lno + e->num_lines);\n\twhile (cp < ep) {\n\t\tunsigned ch = *((unsigned char *)cp);\n\t\tif (isalnum(ch))\n\t\t\tscore++;\n\t\tcp++;\n\t}\n\te->score = score;\n\treturn score;\n}\n\n/*\n * best_so_far[] and this[] are both a split of an existing blame_entry\n * that passes blame to the parent.  Maintain best_so_far the best split\n * so far, by comparing this and best_so_far and copying this into\n * bst_so_far as needed.\n */\nstatic void copy_split_if_better(struct blame_scoreboard *sb,\n\t\t\t\t struct blame_entry *best_so_far,\n\t\t\t\t struct blame_entry *this)\n{\n\tint i;\n\n\tif (!this[1].suspect)\n\t\treturn;\n\tif (best_so_far[1].suspect) {\n\t\tif (blame_entry_score(sb, &this[1]) < blame_entry_score(sb, &best_so_far[1]))\n\t\t\treturn;\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t\tblame_origin_incref(this[i].suspect);\n\tdecref_split(best_so_far);\n\tmemcpy(best_so_far, this, sizeof(struct blame_entry [3]));\n}\n\n/*\n * We are looking at a part of the final image represented by\n * ent (tlno and same are offset by ent->s_lno).\n * tlno is where we are looking at in the final image.\n * up to (but not including) same match preimage.\n * plno is where we are looking at in the preimage.\n *\n * <-------------- final image ---------------------->\n *       <------ent------>\n *         ^tlno ^same\n *    <---------preimage----->\n *         ^plno\n *\n * All line numbers are 0-based.\n */\nstatic void handle_split(struct blame_scoreboard *sb,\n\t\t\t struct blame_entry *ent,\n\t\t\t int tlno, int plno, int same,\n\t\t\t struct blame_origin *parent,\n\t\t\t struct blame_entry *split)\n{\n\tif (ent->num_lines <= tlno)\n\t\treturn;\n\tif (tlno < same) {\n\t\tstruct blame_entry this[3];\n\t\ttlno += ent->s_lno;\n\t\tsame += ent->s_lno;\n\t\tsplit_overlap(this, ent, tlno, plno, same, parent);\n\t\tcopy_split_if_better(sb, split, this);\n\t\tdecref_split(this);\n\t}\n}\n\nstruct handle_split_cb_data {\n\tstruct blame_scoreboard *sb;\n\tstruct blame_entry *ent;\n\tstruct blame_origin *parent;\n\tstruct blame_entry *split;\n\tlong plno;\n\tlong tlno;\n};\n\nstatic int handle_split_cb(long start_a, long count_a,\n\t\t\t   long start_b, long count_b, void *data)\n{\n\tstruct handle_split_cb_data *d = data;\n\thandle_split(d->sb, d->ent, d->tlno, d->plno, start_b, d->parent,\n\t\t     d->split);\n\td->plno = start_a + count_a;\n\td->tlno = start_b + count_b;\n\treturn 0;\n}\n\n/*\n * Find the lines from parent that are the same as ent so that\n * we can pass blames to it.  file_p has the blob contents for\n * the parent.\n */\nstatic void find_copy_in_blob(struct blame_scoreboard *sb,\n\t\t\t      struct blame_entry *ent,\n\t\t\t      struct blame_origin *parent,\n\t\t\t      struct blame_entry *split,\n\t\t\t      mmfile_t *file_p)\n{\n\tconst char *cp;\n\tmmfile_t file_o;\n\tstruct handle_split_cb_data d;\n\n\tmemset(&d, 0, sizeof(d));\n\td.sb = sb; d.ent = ent; d.parent = parent; d.split = split;\n\t/*\n\t * Prepare mmfile that contains only the lines in ent.\n\t */\n\tcp = blame_nth_line(sb, ent->lno);\n\tfile_o.ptr = (char *) cp;\n\tfile_o.size = blame_nth_line(sb, ent->lno + ent->num_lines) - cp;\n\n\t/*\n\t * file_o is a part of final image we are annotating.\n\t * file_p partially may match that image.\n\t */\n\tmemset(split, 0, sizeof(struct blame_entry [3]));\n\tif (diff_hunks(file_p, &file_o, handle_split_cb, &d, sb->xdl_opts))\n\t\tdie(\"unable to generate diff (%s)\",\n\t\t    oid_to_hex(&parent->commit->object.oid));\n\t/* remainder, if any, all match the preimage */\n\thandle_split(sb, ent, d.tlno, d.plno, ent->num_lines, parent, split);\n}\n\n/* Move all blame entries from list *source that have a score smaller\n * than score_min to the front of list *small.\n * Returns a pointer to the link pointing to the old head of the small list.\n */\n\nstatic struct blame_entry **filter_small(struct blame_scoreboard *sb,\n\t\t\t\t\t struct blame_entry **small,\n\t\t\t\t\t struct blame_entry **source,\n\t\t\t\t\t unsigned score_min)\n{\n\tstruct blame_entry *p = *source;\n\tstruct blame_entry *oldsmall = *small;\n\twhile (p) {\n\t\tif (blame_entry_score(sb, p) <= score_min) {\n\t\t\t*small = p;\n\t\t\tsmall = &p->next;\n\t\t\tp = *small;\n\t\t} else {\n\t\t\t*source = p;\n\t\t\tsource = &p->next;\n\t\t\tp = *source;\n\t\t}\n\t}\n\t*small = oldsmall;\n\t*source = NULL;\n\treturn small;\n}\n\n/*\n * See if lines currently target is suspected for can be attributed to\n * parent.\n */\nstatic void find_move_in_parent(struct blame_scoreboard *sb,\n\t\t\t\tstruct blame_entry ***blamed,\n\t\t\t\tstruct blame_entry **toosmall,\n\t\t\t\tstruct blame_origin *target,\n\t\t\t\tstruct blame_origin *parent)\n{\n\tstruct blame_entry *e, split[3];\n\tstruct blame_entry *unblamed = target->suspects;\n\tstruct blame_entry *leftover = NULL;\n\tmmfile_t file_p;\n\n\tif (!unblamed)\n\t\treturn; /* nothing remains for this target */\n\n\tfill_origin_blob(&sb->revs->diffopt, parent, &file_p, &sb->num_read_blob);\n\tif (!file_p.ptr)\n\t\treturn;\n\n\t/* At each iteration, unblamed has a NULL-terminated list of\n\t * entries that have not yet been tested for blame.  leftover\n\t * contains the reversed list of entries that have been tested\n\t * without being assignable to the parent.\n\t */\n\tdo {\n\t\tstruct blame_entry **unblamedtail = &unblamed;\n\t\tstruct blame_entry *next;\n\t\tfor (e = unblamed; e; e = next) {\n\t\t\tnext = e->next;\n\t\t\tfind_copy_in_blob(sb, e, parent, split, &file_p);\n\t\t\tif (split[1].suspect &&\n\t\t\t    sb->move_score < blame_entry_score(sb, &split[1])) {\n\t\t\t\tsplit_blame(blamed, &unblamedtail, split, e);\n\t\t\t} else {\n\t\t\t\te->next = leftover;\n\t\t\t\tleftover = e;\n\t\t\t}\n\t\t\tdecref_split(split);\n\t\t}\n\t\t*unblamedtail = NULL;\n\t\ttoosmall = filter_small(sb, toosmall, &unblamed, sb->move_score);\n\t} while (unblamed);\n\ttarget->suspects = reverse_blame(leftover, NULL);\n}\n\nstruct blame_list {\n\tstruct blame_entry *ent;\n\tstruct blame_entry split[3];\n};\n\n/*\n * Count the number of entries the target is suspected for,\n * and prepare a list of entry and the best split.\n */\nstatic struct blame_list *setup_blame_list(struct blame_entry *unblamed,\n\t\t\t\t\t   int *num_ents_p)\n{\n\tstruct blame_entry *e;\n\tint num_ents, i;\n\tstruct blame_list *blame_list = NULL;\n\n\tfor (e = unblamed, num_ents = 0; e; e = e->next)\n\t\tnum_ents++;\n\tif (num_ents) {\n\t\tblame_list = xcalloc(num_ents, sizeof(struct blame_list));\n\t\tfor (e = unblamed, i = 0; e; e = e->next)\n\t\t\tblame_list[i++].ent = e;\n\t}\n\t*num_ents_p = num_ents;\n\treturn blame_list;\n}\n\n/*\n * For lines target is suspected for, see if we can find code movement\n * across file boundary from the parent commit.  porigin is the path\n * in the parent we already tried.\n */\nstatic void find_copy_in_parent(struct blame_scoreboard *sb,\n\t\t\t\tstruct blame_entry ***blamed,\n\t\t\t\tstruct blame_entry **toosmall,\n\t\t\t\tstruct blame_origin *target,\n\t\t\t\tstruct commit *parent,\n\t\t\t\tstruct blame_origin *porigin,\n\t\t\t\tint opt)\n{\n\tstruct diff_options diff_opts;\n\tint i, j;\n\tstruct blame_list *blame_list;\n\tint num_ents;\n\tstruct blame_entry *unblamed = target->suspects;\n\tstruct blame_entry *leftover = NULL;\n\n\tif (!unblamed)\n\t\treturn; /* nothing remains for this target */\n\n\tdiff_setup(&diff_opts);\n\tDIFF_OPT_SET(&diff_opts, RECURSIVE);\n\tdiff_opts.output_format = DIFF_FORMAT_NO_OUTPUT;\n\n\tdiff_setup_done(&diff_opts);\n\n\t/* Try \"find copies harder\" on new path if requested;\n\t * we do not want to use diffcore_rename() actually to\n\t * match things up; find_copies_harder is set only to\n\t * force diff_tree_sha1() to feed all filepairs to diff_queue,\n\t * and this code needs to be after diff_setup_done(), which\n\t * usually makes find-copies-harder imply copy detection.\n\t */\n\tif ((opt & PICKAXE_BLAME_COPY_HARDEST)\n\t    || ((opt & PICKAXE_BLAME_COPY_HARDER)\n\t\t&& (!porigin || strcmp(target->path, porigin->path))))\n\t\tDIFF_OPT_SET(&diff_opts, FIND_COPIES_HARDER);\n\n\tif (is_null_oid(&target->commit->object.oid))\n\t\tdo_diff_cache(parent->tree->object.oid.hash, &diff_opts);\n\telse\n\t\tdiff_tree_sha1(parent->tree->object.oid.hash,\n\t\t\t       target->commit->tree->object.oid.hash,\n\t\t\t       \"\", &diff_opts);\n\n\tif (!DIFF_OPT_TST(&diff_opts, FIND_COPIES_HARDER))\n\t\tdiffcore_std(&diff_opts);\n\n\tdo {\n\t\tstruct blame_entry **unblamedtail = &unblamed;\n\t\tblame_list = setup_blame_list(unblamed, &num_ents);\n\n\t\tfor (i = 0; i < diff_queued_diff.nr; i++) {\n\t\t\tstruct diff_filepair *p = diff_queued_diff.queue[i];\n\t\t\tstruct blame_origin *norigin;\n\t\t\tmmfile_t file_p;\n\t\t\tstruct blame_entry this[3];\n\n\t\t\tif (!DIFF_FILE_VALID(p->one))\n\t\t\t\tcontinue; /* does not exist in parent */\n\t\t\tif (S_ISGITLINK(p->one->mode))\n\t\t\t\tcontinue; /* ignore git links */\n\t\t\tif (porigin && !strcmp(p->one->path, porigin->path))\n\t\t\t\t/* find_move already dealt with this path */\n\t\t\t\tcontinue;\n\n\t\t\tnorigin = get_origin(parent, p->one->path);\n\t\t\toidcpy(&norigin->blob_oid, &p->one->oid);\n\t\t\tnorigin->mode = p->one->mode;\n\t\t\tfill_origin_blob(&sb->revs->diffopt, norigin, &file_p, &sb->num_read_blob);\n\t\t\tif (!file_p.ptr)\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; j < num_ents; j++) {\n\t\t\t\tfind_copy_in_blob(sb, blame_list[j].ent,\n\t\t\t\t\t\t  norigin, this, &file_p);\n\t\t\t\tcopy_split_if_better(sb, blame_list[j].split,\n\t\t\t\t\t\t     this);\n\t\t\t\tdecref_split(this);\n\t\t\t}\n\t\t\tblame_origin_decref(norigin);\n\t\t}\n\n\t\tfor (j = 0; j < num_ents; j++) {\n\t\t\tstruct blame_entry *split = blame_list[j].split;\n\t\t\tif (split[1].suspect &&\n\t\t\t    sb->copy_score < blame_entry_score(sb, &split[1])) {\n\t\t\t\tsplit_blame(blamed, &unblamedtail, split,\n\t\t\t\t\t    blame_list[j].ent);\n\t\t\t} else {\n\t\t\t\tblame_list[j].ent->next = leftover;\n\t\t\t\tleftover = blame_list[j].ent;\n\t\t\t}\n\t\t\tdecref_split(split);\n\t\t}\n\t\tfree(blame_list);\n\t\t*unblamedtail = NULL;\n\t\ttoosmall = filter_small(sb, toosmall, &unblamed, sb->copy_score);\n\t} while (unblamed);\n\ttarget->suspects = reverse_blame(leftover, NULL);\n\tdiff_flush(&diff_opts);\n\tclear_pathspec(&diff_opts.pathspec);\n}\n\n/*\n * The blobs of origin and porigin exactly match, so everything\n * origin is suspected for can be blamed on the parent.\n */\nstatic void pass_whole_blame(struct blame_scoreboard *sb,\n\t\t\t     struct blame_origin *origin, struct blame_origin *porigin)\n{\n\tstruct blame_entry *e, *suspects;\n\n\tif (!porigin->file.ptr && origin->file.ptr) {\n\t\t/* Steal its file */\n\t\tporigin->file = origin->file;\n\t\torigin->file.ptr = NULL;\n\t}\n\tsuspects = origin->suspects;\n\torigin->suspects = NULL;\n\tfor (e = suspects; e; e = e->next) {\n\t\tblame_origin_incref(porigin);\n\t\tblame_origin_decref(e->suspect);\n\t\te->suspect = porigin;\n\t}\n\tqueue_blames(sb, porigin, suspects);\n}\n\n/*\n * We pass blame from the current commit to its parents.  We keep saying\n * \"parent\" (and \"porigin\"), but what we mean is to find scapegoat to\n * exonerate ourselves.\n */\nstatic struct commit_list *first_scapegoat(struct rev_info *revs, struct commit *commit,\n\t\t\t\t\tint reverse)\n{\n\tif (!reverse) {\n\t\tif (revs->first_parent_only &&\n\t\t    commit->parents &&\n\t\t    commit->parents->next) {\n\t\t\tfree_commit_list(commit->parents->next);\n\t\t\tcommit->parents->next = NULL;\n\t\t}\n\t\treturn commit->parents;\n\t}\n\treturn lookup_decoration(&revs->children, &commit->object);\n}\n\nstatic int num_scapegoats(struct rev_info *revs, struct commit *commit, int reverse)\n{\n\tstruct commit_list *l = first_scapegoat(revs, commit, reverse);\n\treturn commit_list_count(l);\n}\n\n/* Distribute collected unsorted blames to the respected sorted lists\n * in the various origins.\n */\nstatic void distribute_blame(struct blame_scoreboard *sb, struct blame_entry *blamed)\n{\n\tblamed = llist_mergesort(blamed, get_next_blame, set_next_blame,\n\t\t\t\t compare_blame_suspect);\n\twhile (blamed)\n\t{\n\t\tstruct blame_origin *porigin = blamed->suspect;\n\t\tstruct blame_entry *suspects = NULL;\n\t\tdo {\n\t\t\tstruct blame_entry *next = blamed->next;\n\t\t\tblamed->next = suspects;\n\t\t\tsuspects = blamed;\n\t\t\tblamed = next;\n\t\t} while (blamed && blamed->suspect == porigin);\n\t\tsuspects = reverse_blame(suspects, NULL);\n\t\tqueue_blames(sb, porigin, suspects);\n\t}\n}\n\n#define MAXSG 16\n\nstatic void pass_blame(struct blame_scoreboard *sb, struct blame_origin *origin, int opt)\n{\n\tstruct rev_info *revs = sb->revs;\n\tint i, pass, num_sg;\n\tstruct commit *commit = origin->commit;\n\tstruct commit_list *sg;\n\tstruct blame_origin *sg_buf[MAXSG];\n\tstruct blame_origin *porigin, **sg_origin = sg_buf;\n\tstruct blame_entry *toosmall = NULL;\n\tstruct blame_entry *blames, **blametail = &blames;\n\n\tnum_sg = num_scapegoats(revs, commit, sb->reverse);\n\tif (!num_sg)\n\t\tgoto finish;\n\telse if (num_sg < ARRAY_SIZE(sg_buf))\n\t\tmemset(sg_buf, 0, sizeof(sg_buf));\n\telse\n\t\tsg_origin = xcalloc(num_sg, sizeof(*sg_origin));\n\n\t/*\n\t * The first pass looks for unrenamed path to optimize for\n\t * common cases, then we look for renames in the second pass.\n\t */\n\tfor (pass = 0; pass < 2 - sb->no_whole_file_rename; pass++) {\n\t\tstruct blame_origin *(*find)(struct commit *, struct blame_origin *);\n\t\tfind = pass ? find_rename : find_origin;\n\n\t\tfor (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);\n\t\t     i < num_sg && sg;\n\t\t     sg = sg->next, i++) {\n\t\t\tstruct commit *p = sg->item;\n\t\t\tint j, same;\n\n\t\t\tif (sg_origin[i])\n\t\t\t\tcontinue;\n\t\t\tif (parse_commit(p))\n\t\t\t\tcontinue;\n\t\t\tporigin = find(p, origin);\n\t\t\tif (!porigin)\n\t\t\t\tcontinue;\n\t\t\tif (!oidcmp(&porigin->blob_oid, &origin->blob_oid)) {\n\t\t\t\tpass_whole_blame(sb, origin, porigin);\n\t\t\t\tblame_origin_decref(porigin);\n\t\t\t\tgoto finish;\n\t\t\t}\n\t\t\tfor (j = same = 0; j < i; j++)\n\t\t\t\tif (sg_origin[j] &&\n\t\t\t\t    !oidcmp(&sg_origin[j]->blob_oid, &porigin->blob_oid)) {\n\t\t\t\t\tsame = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (!same)\n\t\t\t\tsg_origin[i] = porigin;\n\t\t\telse\n\t\t\t\tblame_origin_decref(porigin);\n\t\t}\n\t}\n\n\tsb->num_commits++;\n\tfor (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);\n\t     i < num_sg && sg;\n\t     sg = sg->next, i++) {\n\t\tstruct blame_origin *porigin = sg_origin[i];\n\t\tif (!porigin)\n\t\t\tcontinue;\n\t\tif (!origin->previous) {\n\t\t\tblame_origin_incref(porigin);\n\t\t\torigin->previous = porigin;\n\t\t}\n\t\tpass_blame_to_parent(sb, origin, porigin);\n\t\tif (!origin->suspects)\n\t\t\tgoto finish;\n\t}\n\n\t/*\n\t * Optionally find moves in parents' files.\n\t */\n\tif (opt & PICKAXE_BLAME_MOVE) {\n\t\tfilter_small(sb, &toosmall, &origin->suspects, sb->move_score);\n\t\tif (origin->suspects) {\n\t\t\tfor (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);\n\t\t\t     i < num_sg && sg;\n\t\t\t     sg = sg->next, i++) {\n\t\t\t\tstruct blame_origin *porigin = sg_origin[i];\n\t\t\t\tif (!porigin)\n\t\t\t\t\tcontinue;\n\t\t\t\tfind_move_in_parent(sb, &blametail, &toosmall, origin, porigin);\n\t\t\t\tif (!origin->suspects)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Optionally find copies from parents' files.\n\t */\n\tif (opt & PICKAXE_BLAME_COPY) {\n\t\tif (sb->copy_score > sb->move_score)\n\t\t\tfilter_small(sb, &toosmall, &origin->suspects, sb->copy_score);\n\t\telse if (sb->copy_score < sb->move_score) {\n\t\t\torigin->suspects = blame_merge(origin->suspects, toosmall);\n\t\t\ttoosmall = NULL;\n\t\t\tfilter_small(sb, &toosmall, &origin->suspects, sb->copy_score);\n\t\t}\n\t\tif (!origin->suspects)\n\t\t\tgoto finish;\n\n\t\tfor (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);\n\t\t     i < num_sg && sg;\n\t\t     sg = sg->next, i++) {\n\t\t\tstruct blame_origin *porigin = sg_origin[i];\n\t\t\tfind_copy_in_parent(sb, &blametail, &toosmall,\n\t\t\t\t\t    origin, sg->item, porigin, opt);\n\t\t\tif (!origin->suspects)\n\t\t\t\tgoto finish;\n\t\t}\n\t}\n\nfinish:\n\t*blametail = NULL;\n\tdistribute_blame(sb, blames);\n\t/*\n\t * prepend toosmall to origin->suspects\n\t *\n\t * There is no point in sorting: this ends up on a big\n\t * unsorted list in the caller anyway.\n\t */\n\tif (toosmall) {\n\t\tstruct blame_entry **tail = &toosmall;\n\t\twhile (*tail)\n\t\t\ttail = &(*tail)->next;\n\t\t*tail = origin->suspects;\n\t\torigin->suspects = toosmall;\n\t}\n\tfor (i = 0; i < num_sg; i++) {\n\t\tif (sg_origin[i]) {\n\t\t\tdrop_origin_blob(sg_origin[i]);\n\t\t\tblame_origin_decref(sg_origin[i]);\n\t\t}\n\t}\n\tdrop_origin_blob(origin);\n\tif (sg_buf != sg_origin)\n\t\tfree(sg_origin);\n}\n\n/*\n * The main loop -- while we have blobs with lines whose true origin\n * is still unknown, pick one blob, and allow its lines to pass blames\n * to its parents. */\nvoid assign_blame(struct blame_scoreboard *sb, int opt)\n{\n\tstruct rev_info *revs = sb->revs;\n\tstruct commit *commit = prio_queue_get(&sb->commits);\n\n\twhile (commit) {\n\t\tstruct blame_entry *ent;\n\t\tstruct blame_origin *suspect = commit->util;\n\n\t\t/* find one suspect to break down */\n\t\twhile (suspect && !suspect->suspects)\n\t\t\tsuspect = suspect->next;\n\n\t\tif (!suspect) {\n\t\t\tcommit = prio_queue_get(&sb->commits);\n\t\t\tcontinue;\n\t\t}\n\n\t\tassert(commit == suspect->commit);\n\n\t\t/*\n\t\t * We will use this suspect later in the loop,\n\t\t * so hold onto it in the meantime.\n\t\t */\n\t\tblame_origin_incref(suspect);\n\t\tparse_commit(commit);\n\t\tif (sb->reverse ||\n\t\t    (!(commit->object.flags & UNINTERESTING) &&\n\t\t     !(revs->max_age != -1 && commit->date < revs->max_age)))\n\t\t\tpass_blame(sb, suspect, opt);\n\t\telse {\n\t\t\tcommit->object.flags |= UNINTERESTING;\n\t\t\tif (commit->object.parsed)\n\t\t\t\tmark_parents_uninteresting(commit);\n\t\t}\n\t\t/* treat root commit as boundary */\n\t\tif (!commit->parents && !sb->show_root)\n\t\t\tcommit->object.flags |= UNINTERESTING;\n\n\t\t/* Take responsibility for the remaining entries */\n\t\tent = suspect->suspects;\n\t\tif (ent) {\n\t\t\tsuspect->guilty = 1;\n\t\t\tfor (;;) {\n\t\t\t\tstruct blame_entry *next = ent->next;\n\t\t\t\tif (sb->found_guilty_entry)\n\t\t\t\t\tsb->found_guilty_entry(ent, sb->found_guilty_entry_data);\n\t\t\t\tif (next) {\n\t\t\t\t\tent = next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tent->next = sb->ent;\n\t\t\t\tsb->ent = suspect->suspects;\n\t\t\t\tsuspect->suspects = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tblame_origin_decref(suspect);\n\n\t\tif (sb->debug) /* sanity */\n\t\t\tsanity_check_refcnt(sb);\n\t}\n}\n\nstatic const char *get_next_line(const char *start, const char *end)\n{\n\tconst char *nl = memchr(start, '\\n', end - start);\n\treturn nl ? nl + 1 : end;\n}\n\n/*\n * To allow quick access to the contents of nth line in the\n * final image, prepare an index in the scoreboard.\n */\nstatic int prepare_lines(struct blame_scoreboard *sb)\n{\n\tconst char *buf = sb->final_buf;\n\tunsigned long len = sb->final_buf_size;\n\tconst char *end = buf + len;\n\tconst char *p;\n\tint *lineno;\n\tint num = 0;\n\n\tfor (p = buf; p < end; p = get_next_line(p, end))\n\t\tnum++;\n\n\tALLOC_ARRAY(sb->lineno, num + 1);\n\tlineno = sb->lineno;\n\n\tfor (p = buf; p < end; p = get_next_line(p, end))\n\t\t*lineno++ = p - buf;\n\n\t*lineno = len;\n\n\tsb->num_lines = num;\n\treturn sb->num_lines;\n}\n\nstatic struct commit *find_single_final(struct rev_info *revs,\n\t\t\t\t\tconst char **name_p)\n{\n\tint i;\n\tstruct commit *found = NULL;\n\tconst char *name = NULL;\n\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object *obj = revs->pending.objects[i].item;\n\t\tif (obj->flags & UNINTERESTING)\n\t\t\tcontinue;\n\t\tobj = deref_tag(obj, NULL, 0);\n\t\tif (obj->type != OBJ_COMMIT)\n\t\t\tdie(\"Non commit %s?\", revs->pending.objects[i].name);\n\t\tif (found)\n\t\t\tdie(\"More than one commit to dig from %s and %s?\",\n\t\t\t    revs->pending.objects[i].name, name);\n\t\tfound = (struct commit *)obj;\n\t\tname = revs->pending.objects[i].name;\n\t}\n\tif (name_p)\n\t\t*name_p = name;\n\treturn found;\n}\n\nstatic struct commit *dwim_reverse_initial(struct rev_info *revs,\n\t\t\t\t\t   const char **name_p)\n{\n\t/*\n\t * DWIM \"git blame --reverse ONE -- PATH\" as\n\t * \"git blame --reverse ONE..HEAD -- PATH\" but only do so\n\t * when it makes sense.\n\t */\n\tstruct object *obj;\n\tstruct commit *head_commit;\n\tunsigned char head_sha1[20];\n\n\tif (revs->pending.nr != 1)\n\t\treturn NULL;\n\n\t/* Is that sole rev a committish? */\n\tobj = revs->pending.objects[0].item;\n\tobj = deref_tag(obj, NULL, 0);\n\tif (obj->type != OBJ_COMMIT)\n\t\treturn NULL;\n\n\t/* Do we have HEAD? */\n\tif (!resolve_ref_unsafe(\"HEAD\", RESOLVE_REF_READING, head_sha1, NULL))\n\t\treturn NULL;\n\thead_commit = lookup_commit_reference_gently(head_sha1, 1);\n\tif (!head_commit)\n\t\treturn NULL;\n\n\t/* Turn \"ONE\" into \"ONE..HEAD\" then */\n\tobj->flags |= UNINTERESTING;\n\tadd_pending_object(revs, &head_commit->object, \"HEAD\");\n\n\tif (name_p)\n\t\t*name_p = revs->pending.objects[0].name;\n\treturn (struct commit *)obj;\n}\n\nstatic struct commit *find_single_initial(struct rev_info *revs,\n\t\t\t\t\t  const char **name_p)\n{\n\tint i;\n\tstruct commit *found = NULL;\n\tconst char *name = NULL;\n\n\t/*\n\t * There must be one and only one negative commit, and it must be\n\t * the boundary.\n\t */\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object *obj = revs->pending.objects[i].item;\n\t\tif (!(obj->flags & UNINTERESTING))\n\t\t\tcontinue;\n\t\tobj = deref_tag(obj, NULL, 0);\n\t\tif (obj->type != OBJ_COMMIT)\n\t\t\tdie(\"Non commit %s?\", revs->pending.objects[i].name);\n\t\tif (found)\n\t\t\tdie(\"More than one commit to dig up from, %s and %s?\",\n\t\t\t    revs->pending.objects[i].name, name);\n\t\tfound = (struct commit *) obj;\n\t\tname = revs->pending.objects[i].name;\n\t}\n\n\tif (!name)\n\t\tfound = dwim_reverse_initial(revs, &name);\n\tif (!name)\n\t\tdie(\"No commit to dig up from?\");\n\n\tif (name_p)\n\t\t*name_p = name;\n\treturn found;\n}\n\nvoid init_scoreboard(struct blame_scoreboard *sb)\n{\n\tmemset(sb, 0, sizeof(struct blame_scoreboard));\n\tsb->move_score = BLAME_DEFAULT_MOVE_SCORE;\n\tsb->copy_score = BLAME_DEFAULT_COPY_SCORE;\n}\n\nvoid setup_scoreboard(struct blame_scoreboard *sb, const char *path, struct blame_origin **orig)\n{\n\tconst char *final_commit_name = NULL;\n\tstruct blame_origin *o;\n\tstruct commit *final_commit = NULL;\n\tenum object_type type;\n\n\tif (sb->reverse && sb->contents_from)\n\t\tdie(_(\"--contents and --reverse do not blend well.\"));\n\n\tif (!sb->reverse) {\n\t\tsb->final = find_single_final(sb->revs, &final_commit_name);\n\t\tsb->commits.compare = compare_commits_by_commit_date;\n\t} else {\n\t\tsb->final = find_single_initial(sb->revs, &final_commit_name);\n\t\tsb->commits.compare = compare_commits_by_reverse_commit_date;\n\t}\n\n\tif (sb->final && sb->contents_from)\n\t\tdie(_(\"cannot use --contents with final commit object name\"));\n\n\tif (sb->reverse && sb->revs->first_parent_only)\n\t\tsb->revs->children.name = NULL;\n\n\tif (!sb->final) {\n\t\t/*\n\t\t * \"--not A B -- path\" without anything positive;\n\t\t * do not default to HEAD, but use the working tree\n\t\t * or \"--contents\".\n\t\t */\n\t\tsetup_work_tree();\n\t\tsb->final = fake_working_tree_commit(&sb->revs->diffopt,\n\t\t\t\t\t\t     path, sb->contents_from);\n\t\tadd_pending_object(sb->revs, &(sb->final->object), \":\");\n\t}\n\n\tif (sb->reverse && sb->revs->first_parent_only) {\n\t\tfinal_commit = find_single_final(sb->revs, NULL);\n\t\tif (!final_commit)\n\t\t\tdie(_(\"--reverse and --first-parent together require specified latest commit\"));\n\t}\n\n\t/*\n\t * If we have bottom, this will mark the ancestors of the\n\t * bottom commits we would reach while traversing as\n\t * uninteresting.\n\t */\n\tif (prepare_revision_walk(sb->revs))\n\t\tdie(_(\"revision walk setup failed\"));\n\n\tif (sb->reverse && sb->revs->first_parent_only) {\n\t\tstruct commit *c = final_commit;\n\n\t\tsb->revs->children.name = \"children\";\n\t\twhile (c->parents &&\n\t\t       oidcmp(&c->object.oid, &sb->final->object.oid)) {\n\t\t\tstruct commit_list *l = xcalloc(1, sizeof(*l));\n\n\t\t\tl->item = c;\n\t\t\tif (add_decoration(&sb->revs->children,\n\t\t\t\t\t   &c->parents->item->object, l))\n\t\t\t\tdie(\"BUG: not unique item in first-parent chain\");\n\t\t\tc = c->parents->item;\n\t\t}\n\n\t\tif (oidcmp(&c->object.oid, &sb->final->object.oid))\n\t\t\tdie(_(\"--reverse --first-parent together require range along first-parent chain\"));\n\t}\n\n\tif (is_null_oid(&sb->final->object.oid)) {\n\t\to = sb->final->util;\n\t\tsb->final_buf = xmemdupz(o->file.ptr, o->file.size);\n\t\tsb->final_buf_size = o->file.size;\n\t}\n\telse {\n\t\to = get_origin(sb->final, path);\n\t\tif (fill_blob_sha1_and_mode(o))\n\t\t\tdie(_(\"no such path %s in %s\"), path, final_commit_name);\n\n\t\tif (DIFF_OPT_TST(&sb->revs->diffopt, ALLOW_TEXTCONV) &&\n\t\t    textconv_object(path, o->mode, &o->blob_oid, 1, (char **) &sb->final_buf,\n\t\t\t\t    &sb->final_buf_size))\n\t\t\t;\n\t\telse\n\t\t\tsb->final_buf = read_sha1_file(o->blob_oid.hash, &type,\n\t\t\t\t\t\t       &sb->final_buf_size);\n\n\t\tif (!sb->final_buf)\n\t\t\tdie(_(\"cannot read blob %s for path %s\"),\n\t\t\t    oid_to_hex(&o->blob_oid),\n\t\t\t    path);\n\t}\n\tsb->num_read_blob++;\n\tprepare_lines(sb);\n\n\tif (orig)\n\t\t*orig = o;\n}\n\n\n\nstruct blame_entry *blame_entry_prepend(struct blame_entry *head,\n\t\t\t\t\tlong start, long end,\n\t\t\t\t\tstruct blame_origin *o)\n{\n\tstruct blame_entry *new_head = xcalloc(1, sizeof(struct blame_entry));\n\tnew_head->lno = start;\n\tnew_head->num_lines = end - start;\n\tnew_head->suspect = o;\n\tnew_head->s_lno = start;\n\tnew_head->next = head;\n\tblame_origin_incref(o);\n\treturn new_head;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00404b973831c85e111225d641d987d09e96eb5c",
  "sha1_ok": true,
  "size": 50822
}
