{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGNvbW1pdCIKICoKICogQ29weXJpZ2h0IChjKSAyMDA3IEtyaXN0aWFuIEjDuGdzYmVyZyA8a3JoQHJlZGhhdC5jb20+CiAqIEJhc2VkIG9uIGdpdC1jb21taXQuc2ggYnkgSnVuaW8gQyBIYW1hbm8gYW5kIExpbnVzIFRvcnZhbGRzCiAqLwoKI2RlZmluZSBVU0VfVEhFX0lOREVYX0NPTVBBVElCSUxJVFlfTUFDUk9TCiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAiY29uZmlnLmgiCiNpbmNsdWRlICJsb2NrZmlsZS5oIgojaW5jbHVkZSAiY2FjaGUtdHJlZS5oIgojaW5jbHVkZSAiY29sb3IuaCIKI2luY2x1ZGUgImRpci5oIgojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAiZGlmZmNvcmUuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAicmV2aXNpb24uaCIKI2luY2x1ZGUgInd0LXN0YXR1cy5oIgojaW5jbHVkZSAicnVuLWNvbW1hbmQuaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgImxvZy10cmVlLmgiCiNpbmNsdWRlICJzdHJidWYuaCIKI2luY2x1ZGUgInV0ZjguaCIKI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCIKI2luY2x1ZGUgInN0cmluZy1saXN0LmgiCiNpbmNsdWRlICJyZXJlcmUuaCIKI2luY2x1ZGUgInVucGFjay10cmVlcy5oIgojaW5jbHVkZSAicXVvdGUuaCIKI2luY2x1ZGUgInN1Ym1vZHVsZS5oIgojaW5jbHVkZSAiZ3BnLWludGVyZmFjZS5oIgojaW5jbHVkZSAiY29sdW1uLmgiCiNpbmNsdWRlICJzZXF1ZW5jZXIuaCIKI2luY2x1ZGUgIm1haWxtYXAuaCIKI2luY2x1ZGUgImhlbHAuaCIKI2luY2x1ZGUgImNvbW1pdC1yZWFjaC5oIgojaW5jbHVkZSAiY29tbWl0LWdyYXBoLmgiCgpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGJ1aWx0aW5fY29tbWl0X3VzYWdlW10gPSB7CglOXygiZ2l0IGNvbW1pdCBbPG9wdGlvbnM+XSBbLS1dIDxwYXRoc3BlYz4uLi4iKSwKCU5VTEwKfTsKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgYnVpbHRpbl9zdGF0dXNfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgc3RhdHVzIFs8b3B0aW9ucz5dIFstLV0gPHBhdGhzcGVjPi4uLiIpLAoJTlVMTAp9OwoKc3RhdGljIGNvbnN0IGNoYXIgZW1wdHlfYW1lbmRfYWR2aWNlW10gPQpOXygiWW91IGFza2VkIHRvIGFtZW5kIHRoZSBtb3N0IHJlY2VudCBjb21taXQsIGJ1dCBkb2luZyBzbyB3b3VsZCBtYWtlXG4iCiJpdCBlbXB0eS4gWW91IGNhbiByZXBlYXQgeW91ciBjb21tYW5kIHdpdGggLS1hbGxvdy1lbXB0eSwgb3IgeW91IGNhblxuIgoicmVtb3ZlIHRoZSBjb21taXQgZW50aXJlbHkgd2l0aCBcImdpdCByZXNldCBIRUFEXlwiLlxuIik7CgpzdGF0aWMgY29uc3QgY2hhciBlbXB0eV9jaGVycnlfcGlja19hZHZpY2VbXSA9Ck5fKCJUaGUgcHJldmlvdXMgY2hlcnJ5LXBpY2sgaXMgbm93IGVtcHR5LCBwb3NzaWJseSBkdWUgdG8gY29uZmxpY3QgcmVzb2x1dGlvbi5cbiIKIklmIHlvdSB3aXNoIHRvIGNvbW1pdCBpdCBhbnl3YXksIHVzZTpcbiIKIlxuIgoiICAgIGdpdCBjb21taXQgLS1hbGxvdy1lbXB0eVxuIgoiXG4iKTsKCnN0YXRpYyBjb25zdCBjaGFyIGVtcHR5X2NoZXJyeV9waWNrX2FkdmljZV9zaW5nbGVbXSA9Ck5fKCJPdGhlcndpc2UsIHBsZWFzZSB1c2UgJ2dpdCBjaGVycnktcGljayAtLXNraXAnXG4iKTsKCnN0YXRpYyBjb25zdCBjaGFyIGVtcHR5X2NoZXJyeV9waWNrX2FkdmljZV9tdWx0aVtdID0KTl8oImFuZCB0aGVuIHVzZTpcbiIKIlxuIgoiICAgIGdpdCBjaGVycnktcGljayAtLWNvbnRpbnVlXG4iCiJcbiIKInRvIHJlc3VtZSBjaGVycnktcGlja2luZyB0aGUgcmVtYWluaW5nIGNvbW1pdHMuXG4iCiJJZiB5b3Ugd2lzaCB0byBza2lwIHRoaXMgY29tbWl0LCB1c2U6XG4iCiJcbiIKIiAgICBnaXQgY2hlcnJ5LXBpY2sgLS1za2lwXG4iCiJcbiIpOwoKc3RhdGljIGNvbnN0IGNoYXIgKmNvbG9yX3N0YXR1c19zbG90c1tdID0gewoJW1dUX1NUQVRVU19IRUFERVJdCSAgPSAiaGVhZGVyIiwKCVtXVF9TVEFUVVNfVVBEQVRFRF0JICA9ICJ1cGRhdGVkIiwKCVtXVF9TVEFUVVNfQ0hBTkdFRF0JICA9ICJjaGFuZ2VkIiwKCVtXVF9TVEFUVVNfVU5UUkFDS0VEXQkgID0gInVudHJhY2tlZCIsCglbV1RfU1RBVFVTX05PQlJBTkNIXQkgID0gIm5vQnJhbmNoIiwKCVtXVF9TVEFUVVNfVU5NRVJHRURdCSAgPSAidW5tZXJnZWQiLAoJW1dUX1NUQVRVU19MT0NBTF9CUkFOQ0hdICA9ICJsb2NhbEJyYW5jaCIsCglbV1RfU1RBVFVTX1JFTU9URV9CUkFOQ0hdID0gInJlbW90ZUJyYW5jaCIsCglbV1RfU1RBVFVTX09OQlJBTkNIXQkgID0gImJyYW5jaCIsCn07CgpzdGF0aWMgY29uc3QgY2hhciAqdXNlX21lc3NhZ2VfYnVmZmVyOwpzdGF0aWMgc3RydWN0IGxvY2tfZmlsZSBpbmRleF9sb2NrOyAvKiByZWFsIGluZGV4ICovCnN0YXRpYyBzdHJ1Y3QgbG9ja19maWxlIGZhbHNlX2xvY2s7IC8qIHVzZWQgb25seSBmb3IgcGFydGlhbCBjb21taXRzICovCnN0YXRpYyBlbnVtIHsKCUNPTU1JVF9BU19JUyA9IDEsCglDT01NSVRfTk9STUFMLAoJQ09NTUlUX1BBUlRJQUwKfSBjb21taXRfc3R5bGU7CgpzdGF0aWMgY29uc3QgY2hhciAqbG9nZmlsZSwgKmZvcmNlX2F1dGhvcjsKc3RhdGljIGNvbnN0IGNoYXIgKnRlbXBsYXRlX2ZpbGU7Ci8qCiAqIFRoZSBfbWVzc2FnZSB2YXJpYWJsZXMgYXJlIGNvbW1pdCBuYW1lcyBmcm9tIHdoaWNoIHRvIHRha2UKICogdGhlIGNvbW1pdCBtZXNzYWdlIGFuZC9vciBhdXRob3JzaGlwLgogKi8Kc3RhdGljIGNvbnN0IGNoYXIgKmF1dGhvcl9tZXNzYWdlLCAqYXV0aG9yX21lc3NhZ2VfYnVmZmVyOwpzdGF0aWMgY2hhciAqZWRpdF9tZXNzYWdlLCAqdXNlX21lc3NhZ2U7CnN0YXRpYyBjaGFyICpmaXh1cF9tZXNzYWdlLCAqc3F1YXNoX21lc3NhZ2U7CnN0YXRpYyBpbnQgYWxsLCBhbHNvLCBpbnRlcmFjdGl2ZSwgcGF0Y2hfaW50ZXJhY3RpdmUsIG9ubHksIGFtZW5kLCBzaWdub2ZmOwpzdGF0aWMgaW50IGVkaXRfZmxhZyA9IC0xOyAvKiB1bnNwZWNpZmllZCAqLwpzdGF0aWMgaW50IHF1aWV0LCB2ZXJib3NlLCBub192ZXJpZnksIGFsbG93X2VtcHR5LCBkcnlfcnVuLCByZW5ld19hdXRob3JzaGlwOwpzdGF0aWMgaW50IGNvbmZpZ19jb21taXRfdmVyYm9zZSA9IC0xOyAvKiB1bnNwZWNpZmllZCAqLwpzdGF0aWMgaW50IG5vX3Bvc3RfcmV3cml0ZSwgYWxsb3dfZW1wdHlfbWVzc2FnZTsKc3RhdGljIGNoYXIgKnVudHJhY2tlZF9maWxlc19hcmcsICpmb3JjZV9kYXRlLCAqaWdub3JlX3N1Ym1vZHVsZV9hcmcsICppZ25vcmVkX2FyZzsKc3RhdGljIGNoYXIgKnNpZ25fY29tbWl0OwoKLyoKICogVGhlIGRlZmF1bHQgY29tbWl0IG1lc3NhZ2UgY2xlYW51cCBtb2RlIHdpbGwgcmVtb3ZlIHRoZSBsaW5lcwogKiBiZWdpbm5pbmcgd2l0aCAjIChzaGVsbCBjb21tZW50cykgYW5kIGxlYWRpbmcgYW5kIHRyYWlsaW5nCiAqIHdoaXRlc3BhY2VzIChlbXB0eSBsaW5lcyBvciBjb250YWluaW5nIG9ubHkgd2hpdGVzcGFjZXMpCiAqIGlmIGVkaXRvciBpcyB1c2VkLCBhbmQgb25seSB0aGUgd2hpdGVzcGFjZXMgaWYgdGhlIG1lc3NhZ2UKICogaXMgc3BlY2lmaWVkIGV4cGxpY2l0bHkuCiAqLwpzdGF0aWMgZW51bSBjb21taXRfbXNnX2NsZWFudXBfbW9kZSBjbGVhbnVwX21vZGU7CnN0YXRpYyBjb25zdCBjaGFyICpjbGVhbnVwX2FyZzsKCnN0YXRpYyBlbnVtIGNvbW1pdF93aGVuY2Ugd2hlbmNlOwpzdGF0aWMgaW50IHNlcXVlbmNlcl9pbl91c2U7CnN0YXRpYyBpbnQgdXNlX2VkaXRvciA9IDEsIGluY2x1ZGVfc3RhdHVzID0gMTsKc3RhdGljIGludCBoYXZlX29wdGlvbl9tOwpzdGF0aWMgc3RydWN0IHN0cmJ1ZiBtZXNzYWdlID0gU1RSQlVGX0lOSVQ7CgpzdGF0aWMgZW51bSB3dF9zdGF0dXNfZm9ybWF0IHN0YXR1c19mb3JtYXQgPSBTVEFUVVNfRk9STUFUX1VOU1BFQ0lGSUVEOwoKc3RhdGljIGludCBvcHRfcGFyc2VfcG9yY2VsYWluKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCWVudW0gd3Rfc3RhdHVzX2Zvcm1hdCAqdmFsdWUgPSAoZW51bSB3dF9zdGF0dXNfZm9ybWF0ICopb3B0LT52YWx1ZTsKCWlmICh1bnNldCkKCQkqdmFsdWUgPSBTVEFUVVNfRk9STUFUX05PTkU7CgllbHNlIGlmICghYXJnKQoJCSp2YWx1ZSA9IFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOOwoJZWxzZSBpZiAoIXN0cmNtcChhcmcsICJ2MSIpIHx8ICFzdHJjbXAoYXJnLCAiMSIpKQoJCSp2YWx1ZSA9IFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOOwoJZWxzZSBpZiAoIXN0cmNtcChhcmcsICJ2MiIpIHx8ICFzdHJjbXAoYXJnLCAiMiIpKQoJCSp2YWx1ZSA9IFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOX1YyOwoJZWxzZQoJCWRpZSgidW5zdXBwb3J0ZWQgcG9yY2VsYWluIHZlcnNpb24gJyVzJyIsIGFyZyk7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgb3B0X3BhcnNlX20oY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJc3RydWN0IHN0cmJ1ZiAqYnVmID0gb3B0LT52YWx1ZTsKCWlmICh1bnNldCkgewoJCWhhdmVfb3B0aW9uX20gPSAwOwoJCXN0cmJ1Zl9zZXRsZW4oYnVmLCAwKTsKCX0gZWxzZSB7CgkJaGF2ZV9vcHRpb25fbSA9IDE7CgkJaWYgKGJ1Zi0+bGVuKQoJCQlzdHJidWZfYWRkY2goYnVmLCAnXG4nKTsKCQlzdHJidWZfYWRkc3RyKGJ1ZiwgYXJnKTsKCQlzdHJidWZfY29tcGxldGVfbGluZShidWYpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgb3B0X3BhcnNlX3JlbmFtZV9zY29yZShjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7Cgljb25zdCBjaGFyICoqdmFsdWUgPSBvcHQtPnZhbHVlOwoKCUJVR19PTl9PUFRfTkVHKHVuc2V0KTsKCglpZiAoYXJnICE9IE5VTEwgJiYgKmFyZyA9PSAnPScpCgkJYXJnID0gYXJnICsgMTsKCgkqdmFsdWUgPSBhcmc7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgZGV0ZXJtaW5lX3doZW5jZShzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglpZiAoZmlsZV9leGlzdHMoZ2l0X3BhdGhfbWVyZ2VfaGVhZCh0aGVfcmVwb3NpdG9yeSkpKQoJCXdoZW5jZSA9IEZST01fTUVSR0U7CgllbHNlIGlmIChmaWxlX2V4aXN0cyhnaXRfcGF0aF9jaGVycnlfcGlja19oZWFkKHRoZV9yZXBvc2l0b3J5KSkpIHsKCQl3aGVuY2UgPSBGUk9NX0NIRVJSWV9QSUNLOwoJCWlmIChmaWxlX2V4aXN0cyhnaXRfcGF0aF9zZXFfZGlyKCkpKQoJCQlzZXF1ZW5jZXJfaW5fdXNlID0gMTsKCX0KCWVsc2UKCQl3aGVuY2UgPSBGUk9NX0NPTU1JVDsKCWlmIChzKQoJCXMtPndoZW5jZSA9IHdoZW5jZTsKfQoKc3RhdGljIHZvaWQgc3RhdHVzX2luaXRfY29uZmlnKHN0cnVjdCB3dF9zdGF0dXMgKnMsIGNvbmZpZ19mbl90IGZuKQp7Cgl3dF9zdGF0dXNfcHJlcGFyZSh0aGVfcmVwb3NpdG9yeSwgcyk7Cglpbml0X2RpZmZfdWlfZGVmYXVsdHMoKTsKCWdpdF9jb25maWcoZm4sIHMpOwoJZGV0ZXJtaW5lX3doZW5jZShzKTsKCXMtPmhpbnRzID0gYWR2aWNlX3N0YXR1c19oaW50czsgLyogbXVzdCBjb21lIGFmdGVyIGdpdF9jb25maWcoKSAqLwp9CgpzdGF0aWMgdm9pZCByb2xsYmFja19pbmRleF9maWxlcyh2b2lkKQp7Cglzd2l0Y2ggKGNvbW1pdF9zdHlsZSkgewoJY2FzZSBDT01NSVRfQVNfSVM6CgkJYnJlYWs7IC8qIG5vdGhpbmcgdG8gZG8gKi8KCWNhc2UgQ09NTUlUX05PUk1BTDoKCQlyb2xsYmFja19sb2NrX2ZpbGUoJmluZGV4X2xvY2spOwoJCWJyZWFrOwoJY2FzZSBDT01NSVRfUEFSVElBTDoKCQlyb2xsYmFja19sb2NrX2ZpbGUoJmluZGV4X2xvY2spOwoJCXJvbGxiYWNrX2xvY2tfZmlsZSgmZmFsc2VfbG9jayk7CgkJYnJlYWs7Cgl9Cn0KCnN0YXRpYyBpbnQgY29tbWl0X2luZGV4X2ZpbGVzKHZvaWQpCnsKCWludCBlcnIgPSAwOwoKCXN3aXRjaCAoY29tbWl0X3N0eWxlKSB7CgljYXNlIENPTU1JVF9BU19JUzoKCQlicmVhazsgLyogbm90aGluZyB0byBkbyAqLwoJY2FzZSBDT01NSVRfTk9STUFMOgoJCWVyciA9IGNvbW1pdF9sb2NrX2ZpbGUoJmluZGV4X2xvY2spOwoJCWJyZWFrOwoJY2FzZSBDT01NSVRfUEFSVElBTDoKCQllcnIgPSBjb21taXRfbG9ja19maWxlKCZpbmRleF9sb2NrKTsKCQlyb2xsYmFja19sb2NrX2ZpbGUoJmZhbHNlX2xvY2spOwoJCWJyZWFrOwoJfQoKCXJldHVybiBlcnI7Cn0KCi8qCiAqIFRha2UgYSB1bmlvbiBvZiBwYXRocyBpbiB0aGUgaW5kZXggYW5kIHRoZSBuYW1lZCB0cmVlICh0eXBpY2FsbHksICJIRUFEIiksCiAqIGFuZCByZXR1cm4gdGhlIHBhdGhzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHBhdHRlcm4gaW4gbGlzdC4KICovCnN0YXRpYyBpbnQgbGlzdF9wYXRocyhzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QsIGNvbnN0IGNoYXIgKndpdGhfdHJlZSwKCQkgICAgICBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBhdHRlcm4pCnsKCWludCBpLCByZXQ7CgljaGFyICptOwoKCWlmICghcGF0dGVybi0+bnIpCgkJcmV0dXJuIDA7CgoJbSA9IHhjYWxsb2MoMSwgcGF0dGVybi0+bnIpOwoKCWlmICh3aXRoX3RyZWUpIHsKCQljaGFyICptYXhfcHJlZml4ID0gY29tbW9uX3ByZWZpeChwYXR0ZXJuKTsKCQlvdmVybGF5X3RyZWVfb25faW5kZXgoJnRoZV9pbmRleCwgd2l0aF90cmVlLCBtYXhfcHJlZml4KTsKCQlmcmVlKG1heF9wcmVmaXgpOwoJfQoKCWZvciAoaSA9IDA7IGkgPCBhY3RpdmVfbnI7IGkrKykgewoJCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBhY3RpdmVfY2FjaGVbaV07CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW07CgoJCWlmIChjZS0+Y2VfZmxhZ3MgJiBDRV9VUERBVEUpCgkJCWNvbnRpbnVlOwoJCWlmICghY2VfcGF0aF9tYXRjaCgmdGhlX2luZGV4LCBjZSwgcGF0dGVybiwgbSkpCgkJCWNvbnRpbnVlOwoJCWl0ZW0gPSBzdHJpbmdfbGlzdF9pbnNlcnQobGlzdCwgY2UtPm5hbWUpOwoJCWlmIChjZV9za2lwX3dvcmt0cmVlKGNlKSkKCQkJaXRlbS0+dXRpbCA9IGl0ZW07IC8qIGJldHRlciBhIHZhbGlkIHBvaW50ZXIgdGhhbiBhIGZha2Ugb25lICovCgl9CgoJcmV0ID0gcmVwb3J0X3BhdGhfZXJyb3IobSwgcGF0dGVybik7CglmcmVlKG0pOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIHZvaWQgYWRkX3JlbW92ZV9maWxlcyhzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QpCnsKCWludCBpOwoJZm9yIChpID0gMDsgaSA8IGxpc3QtPm5yOyBpKyspIHsKCQlzdHJ1Y3Qgc3RhdCBzdDsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqcCA9ICYobGlzdC0+aXRlbXNbaV0pOwoKCQkvKiBwLT51dGlsIGlzIHNraXAtd29ya3RyZWUgKi8KCQlpZiAocC0+dXRpbCkKCQkJY29udGludWU7CgoJCWlmICghbHN0YXQocC0+c3RyaW5nLCAmc3QpKSB7CgkJCWlmIChhZGRfdG9fY2FjaGUocC0+c3RyaW5nLCAmc3QsIDApKQoJCQkJZGllKF8oInVwZGF0aW5nIGZpbGVzIGZhaWxlZCIpKTsKCQl9IGVsc2UKCQkJcmVtb3ZlX2ZpbGVfZnJvbV9jYWNoZShwLT5zdHJpbmcpOwoJfQp9CgpzdGF0aWMgdm9pZCBjcmVhdGVfYmFzZV9pbmRleChjb25zdCBzdHJ1Y3QgY29tbWl0ICpjdXJyZW50X2hlYWQpCnsKCXN0cnVjdCB0cmVlICp0cmVlOwoJc3RydWN0IHVucGFja190cmVlc19vcHRpb25zIG9wdHM7CglzdHJ1Y3QgdHJlZV9kZXNjIHQ7CgoJaWYgKCFjdXJyZW50X2hlYWQpIHsKCQlkaXNjYXJkX2NhY2hlKCk7CgkJcmV0dXJuOwoJfQoKCW1lbXNldCgmb3B0cywgMCwgc2l6ZW9mKG9wdHMpKTsKCW9wdHMuaGVhZF9pZHggPSAxOwoJb3B0cy5pbmRleF9vbmx5ID0gMTsKCW9wdHMubWVyZ2UgPSAxOwoJb3B0cy5zcmNfaW5kZXggPSAmdGhlX2luZGV4OwoJb3B0cy5kc3RfaW5kZXggPSAmdGhlX2luZGV4OwoKCW9wdHMuZm4gPSBvbmV3YXlfbWVyZ2U7Cgl0cmVlID0gcGFyc2VfdHJlZV9pbmRpcmVjdCgmY3VycmVudF9oZWFkLT5vYmplY3Qub2lkKTsKCWlmICghdHJlZSkKCQlkaWUoXygiZmFpbGVkIHRvIHVucGFjayBIRUFEIHRyZWUgb2JqZWN0IikpOwoJcGFyc2VfdHJlZSh0cmVlKTsKCWluaXRfdHJlZV9kZXNjKCZ0LCB0cmVlLT5idWZmZXIsIHRyZWUtPnNpemUpOwoJaWYgKHVucGFja190cmVlcygxLCAmdCwgJm9wdHMpKQoJCWV4aXQoMTI4KTsgLyogV2UndmUgYWxyZWFkeSByZXBvcnRlZCB0aGUgZXJyb3IsIGZpbmlzaCBkeWluZyAqLwp9CgpzdGF0aWMgdm9pZCByZWZyZXNoX2NhY2hlX29yX2RpZShpbnQgcmVmcmVzaF9mbGFncykKewoJLyoKCSAqIHJlZnJlc2hfZmxhZ3MgY29udGFpbnMgUkVGUkVTSF9RVUlFVCwgc28gdGhlIG9ubHkgZXJyb3JzCgkgKiBhcmUgZm9yIHVubWVyZ2VkIGVudHJpZXMuCgkgKi8KCWlmIChyZWZyZXNoX2NhY2hlKHJlZnJlc2hfZmxhZ3MgfCBSRUZSRVNIX0lOX1BPUkNFTEFJTikpCgkJZGllX3Jlc29sdmVfY29uZmxpY3QoImNvbW1pdCIpOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqcHJlcGFyZV9pbmRleChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJCSBjb25zdCBzdHJ1Y3QgY29tbWl0ICpjdXJyZW50X2hlYWQsIGludCBpc19zdGF0dXMpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdCBwYXJ0aWFsID0gU1RSSU5HX0xJU1RfSU5JVF9EVVA7CglzdHJ1Y3QgcGF0aHNwZWMgcGF0aHNwZWM7CglpbnQgcmVmcmVzaF9mbGFncyA9IFJFRlJFU0hfUVVJRVQ7Cgljb25zdCBjaGFyICpyZXQ7CgoJaWYgKGlzX3N0YXR1cykKCQlyZWZyZXNoX2ZsYWdzIHw9IFJFRlJFU0hfVU5NRVJHRUQ7CglwYXJzZV9wYXRoc3BlYygmcGF0aHNwZWMsIDAsCgkJICAgICAgIFBBVEhTUEVDX1BSRUZFUl9GVUxMLAoJCSAgICAgICBwcmVmaXgsIGFyZ3YpOwoKCWlmIChyZWFkX2NhY2hlX3ByZWxvYWQoJnBhdGhzcGVjKSA8IDApCgkJZGllKF8oImluZGV4IGZpbGUgY29ycnVwdCIpKTsKCglpZiAoaW50ZXJhY3RpdmUpIHsKCQljaGFyICpvbGRfaW5kZXhfZW52ID0gTlVMTDsKCQlob2xkX2xvY2tlZF9pbmRleCgmaW5kZXhfbG9jaywgTE9DS19ESUVfT05fRVJST1IpOwoKCQlyZWZyZXNoX2NhY2hlX29yX2RpZShyZWZyZXNoX2ZsYWdzKTsKCgkJaWYgKHdyaXRlX2xvY2tlZF9pbmRleCgmdGhlX2luZGV4LCAmaW5kZXhfbG9jaywgMCkpCgkJCWRpZShfKCJ1bmFibGUgdG8gY3JlYXRlIHRlbXBvcmFyeSBpbmRleCIpKTsKCgkJb2xkX2luZGV4X2VudiA9IHhzdHJkdXBfb3JfbnVsbChnZXRlbnYoSU5ERVhfRU5WSVJPTk1FTlQpKTsKCQlzZXRlbnYoSU5ERVhfRU5WSVJPTk1FTlQsIGdldF9sb2NrX2ZpbGVfcGF0aCgmaW5kZXhfbG9jayksIDEpOwoKCQlpZiAoaW50ZXJhY3RpdmVfYWRkKGFyZ2MsIGFyZ3YsIHByZWZpeCwgcGF0Y2hfaW50ZXJhY3RpdmUpICE9IDApCgkJCWRpZShfKCJpbnRlcmFjdGl2ZSBhZGQgZmFpbGVkIikpOwoKCQlpZiAob2xkX2luZGV4X2VudiAmJiAqb2xkX2luZGV4X2VudikKCQkJc2V0ZW52KElOREVYX0VOVklST05NRU5ULCBvbGRfaW5kZXhfZW52LCAxKTsKCQllbHNlCgkJCXVuc2V0ZW52KElOREVYX0VOVklST05NRU5UKTsKCQlGUkVFX0FORF9OVUxMKG9sZF9pbmRleF9lbnYpOwoKCQlkaXNjYXJkX2NhY2hlKCk7CgkJcmVhZF9jYWNoZV9mcm9tKGdldF9sb2NrX2ZpbGVfcGF0aCgmaW5kZXhfbG9jaykpOwoJCWlmICh1cGRhdGVfbWFpbl9jYWNoZV90cmVlKFdSSVRFX1RSRUVfU0lMRU5UKSA9PSAwKSB7CgkJCWlmIChyZW9wZW5fbG9ja19maWxlKCZpbmRleF9sb2NrKSA8IDApCgkJCQlkaWUoXygidW5hYmxlIHRvIHdyaXRlIGluZGV4IGZpbGUiKSk7CgkJCWlmICh3cml0ZV9sb2NrZWRfaW5kZXgoJnRoZV9pbmRleCwgJmluZGV4X2xvY2ssIDApKQoJCQkJZGllKF8oInVuYWJsZSB0byB1cGRhdGUgdGVtcG9yYXJ5IGluZGV4IikpOwoJCX0gZWxzZQoJCQl3YXJuaW5nKF8oIkZhaWxlZCB0byB1cGRhdGUgbWFpbiBjYWNoZSB0cmVlIikpOwoKCQljb21taXRfc3R5bGUgPSBDT01NSVRfTk9STUFMOwoJCXJldCA9IGdldF9sb2NrX2ZpbGVfcGF0aCgmaW5kZXhfbG9jayk7CgkJZ290byBvdXQ7Cgl9CgoJLyoKCSAqIE5vbiBwYXJ0aWFsLCBub24gYXMtaXMgY29tbWl0LgoJICoKCSAqICgxKSBnZXQgdGhlIHJlYWwgaW5kZXg7CgkgKiAoMikgdXBkYXRlIHRoZV9pbmRleCBhcyBuZWNlc3Nhcnk7CgkgKiAoMykgd3JpdGUgdGhlX2luZGV4IG91dCB0byB0aGUgcmVhbCBpbmRleCAoc3RpbGwgbG9ja2VkKTsKCSAqICg0KSByZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGxvY2tlZCBpbmRleCBmaWxlLgoJICoKCSAqIFRoZSBjYWxsZXIgc2hvdWxkIHJ1biBob29rcyBvbiB0aGUgbG9ja2VkIHJlYWwgaW5kZXgsIGFuZAoJICogKEEpIGlmIGFsbCBnb2VzIHdlbGwsIGNvbW1pdCB0aGUgcmVhbCBpbmRleDsKCSAqIChCKSBvbiBmYWlsdXJlLCByb2xsYmFjayB0aGUgcmVhbCBpbmRleC4KCSAqLwoJaWYgKGFsbCB8fCAoYWxzbyAmJiBwYXRoc3BlYy5ucikpIHsKCQlob2xkX2xvY2tlZF9pbmRleCgmaW5kZXhfbG9jaywgTE9DS19ESUVfT05fRVJST1IpOwoJCWFkZF9maWxlc190b19jYWNoZShhbHNvID8gcHJlZml4IDogTlVMTCwgJnBhdGhzcGVjLCAwKTsKCQlyZWZyZXNoX2NhY2hlX29yX2RpZShyZWZyZXNoX2ZsYWdzKTsKCQl1cGRhdGVfbWFpbl9jYWNoZV90cmVlKFdSSVRFX1RSRUVfU0lMRU5UKTsKCQlpZiAod3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZpbmRleF9sb2NrLCAwKSkKCQkJZGllKF8oInVuYWJsZSB0byB3cml0ZSBuZXdfaW5kZXggZmlsZSIpKTsKCQljb21taXRfc3R5bGUgPSBDT01NSVRfTk9STUFMOwoJCXJldCA9IGdldF9sb2NrX2ZpbGVfcGF0aCgmaW5kZXhfbG9jayk7CgkJZ290byBvdXQ7Cgl9CgoJLyoKCSAqIEFzLWlzIGNvbW1pdC4KCSAqCgkgKiAoMSkgcmV0dXJuIHRoZSBuYW1lIG9mIHRoZSByZWFsIGluZGV4IGZpbGUuCgkgKgoJICogVGhlIGNhbGxlciBzaG91bGQgcnVuIGhvb2tzIG9uIHRoZSByZWFsIGluZGV4LAoJICogYW5kIGNyZWF0ZSBjb21taXQgZnJvbSB0aGVfaW5kZXguCgkgKiBXZSBzdGlsbCBuZWVkIHRvIHJlZnJlc2ggdGhlIGluZGV4IGhlcmUuCgkgKi8KCWlmICghb25seSAmJiAhcGF0aHNwZWMubnIpIHsKCQlob2xkX2xvY2tlZF9pbmRleCgmaW5kZXhfbG9jaywgTE9DS19ESUVfT05fRVJST1IpOwoJCXJlZnJlc2hfY2FjaGVfb3JfZGllKHJlZnJlc2hfZmxhZ3MpOwoJCWlmIChhY3RpdmVfY2FjaGVfY2hhbmdlZAoJCSAgICB8fCAhY2FjaGVfdHJlZV9mdWxseV92YWxpZChhY3RpdmVfY2FjaGVfdHJlZSkpCgkJCXVwZGF0ZV9tYWluX2NhY2hlX3RyZWUoV1JJVEVfVFJFRV9TSUxFTlQpOwoJCWlmICh3cml0ZV9sb2NrZWRfaW5kZXgoJnRoZV9pbmRleCwgJmluZGV4X2xvY2ssCgkJCQkgICAgICAgQ09NTUlUX0xPQ0sgfCBTS0lQX0lGX1VOQ0hBTkdFRCkpCgkJCWRpZShfKCJ1bmFibGUgdG8gd3JpdGUgbmV3X2luZGV4IGZpbGUiKSk7CgkJY29tbWl0X3N0eWxlID0gQ09NTUlUX0FTX0lTOwoJCXJldCA9IGdldF9pbmRleF9maWxlKCk7CgkJZ290byBvdXQ7Cgl9CgoJLyoKCSAqIEEgcGFydGlhbCBjb21taXQuCgkgKgoJICogKDApIGZpbmQgdGhlIHNldCBvZiBhZmZlY3RlZCBwYXRoczsKCSAqICgxKSBnZXQgbG9jayBvbiB0aGUgcmVhbCBpbmRleCBmaWxlOwoJICogKDIpIHVwZGF0ZSB0aGVfaW5kZXggd2l0aCB0aGUgZ2l2ZW4gcGF0aHM7CgkgKiAoMykgd3JpdGUgdGhlX2luZGV4IG91dCB0byB0aGUgcmVhbCBpbmRleCAoc3RpbGwgbG9ja2VkKTsKCSAqICg0KSBnZXQgbG9jayBvbiB0aGUgZmFsc2UgaW5kZXggZmlsZTsKCSAqICg1KSByZXNldCB0aGVfaW5kZXggZnJvbSBIRUFEOwoJICogKDYpIHVwZGF0ZSB0aGVfaW5kZXggdGhlIHNhbWUgd2F5IGFzICgyKTsKCSAqICg3KSB3cml0ZSB0aGVfaW5kZXggb3V0IHRvIHRoZSBmYWxzZSBpbmRleCBmaWxlOwoJICogKDgpIHJldHVybiB0aGUgbmFtZSBvZiB0aGUgZmFsc2UgaW5kZXggZmlsZSAoc3RpbGwgbG9ja2VkKTsKCSAqCgkgKiBUaGUgY2FsbGVyIHNob3VsZCBydW4gaG9va3Mgb24gdGhlIGxvY2tlZCBmYWxzZSBpbmRleCwgYW5kCgkgKiBjcmVhdGUgY29tbWl0IGZyb20gaXQuICBUaGVuCgkgKiAoQSkgaWYgYWxsIGdvZXMgd2VsbCwgY29tbWl0IHRoZSByZWFsIGluZGV4OwoJICogKEIpIG9uIGZhaWx1cmUsIHJvbGxiYWNrIHRoZSByZWFsIGluZGV4OwoJICogSW4gZWl0aGVyIGNhc2UsIHJvbGxiYWNrIHRoZSBmYWxzZSBpbmRleC4KCSAqLwoJY29tbWl0X3N0eWxlID0gQ09NTUlUX1BBUlRJQUw7CgoJaWYgKHdoZW5jZSAhPSBGUk9NX0NPTU1JVCkgewoJCWlmICh3aGVuY2UgPT0gRlJPTV9NRVJHRSkKCQkJZGllKF8oImNhbm5vdCBkbyBhIHBhcnRpYWwgY29tbWl0IGR1cmluZyBhIG1lcmdlLiIpKTsKCQllbHNlIGlmICh3aGVuY2UgPT0gRlJPTV9DSEVSUllfUElDSykKCQkJZGllKF8oImNhbm5vdCBkbyBhIHBhcnRpYWwgY29tbWl0IGR1cmluZyBhIGNoZXJyeS1waWNrLiIpKTsKCX0KCglpZiAobGlzdF9wYXRocygmcGFydGlhbCwgIWN1cnJlbnRfaGVhZCA/IE5VTEwgOiAiSEVBRCIsICZwYXRoc3BlYykpCgkJZXhpdCgxKTsKCglkaXNjYXJkX2NhY2hlKCk7CglpZiAocmVhZF9jYWNoZSgpIDwgMCkKCQlkaWUoXygiY2Fubm90IHJlYWQgdGhlIGluZGV4IikpOwoKCWhvbGRfbG9ja2VkX2luZGV4KCZpbmRleF9sb2NrLCBMT0NLX0RJRV9PTl9FUlJPUik7CglhZGRfcmVtb3ZlX2ZpbGVzKCZwYXJ0aWFsKTsKCXJlZnJlc2hfY2FjaGUoUkVGUkVTSF9RVUlFVCk7Cgl1cGRhdGVfbWFpbl9jYWNoZV90cmVlKFdSSVRFX1RSRUVfU0lMRU5UKTsKCWlmICh3cml0ZV9sb2NrZWRfaW5kZXgoJnRoZV9pbmRleCwgJmluZGV4X2xvY2ssIDApKQoJCWRpZShfKCJ1bmFibGUgdG8gd3JpdGUgbmV3X2luZGV4IGZpbGUiKSk7CgoJaG9sZF9sb2NrX2ZpbGVfZm9yX3VwZGF0ZSgmZmFsc2VfbG9jaywKCQkJCSAgZ2l0X3BhdGgoIm5leHQtaW5kZXgtJSJQUkl1TUFYLAoJCQkJCSAgICh1aW50bWF4X3QpIGdldHBpZCgpKSwKCQkJCSAgTE9DS19ESUVfT05fRVJST1IpOwoKCWNyZWF0ZV9iYXNlX2luZGV4KGN1cnJlbnRfaGVhZCk7CglhZGRfcmVtb3ZlX2ZpbGVzKCZwYXJ0aWFsKTsKCXJlZnJlc2hfY2FjaGUoUkVGUkVTSF9RVUlFVCk7CgoJaWYgKHdyaXRlX2xvY2tlZF9pbmRleCgmdGhlX2luZGV4LCAmZmFsc2VfbG9jaywgMCkpCgkJZGllKF8oInVuYWJsZSB0byB3cml0ZSB0ZW1wb3JhcnkgaW5kZXggZmlsZSIpKTsKCglkaXNjYXJkX2NhY2hlKCk7CglyZXQgPSBnZXRfbG9ja19maWxlX3BhdGgoJmZhbHNlX2xvY2spOwoJcmVhZF9jYWNoZV9mcm9tKHJldCk7Cm91dDoKCXN0cmluZ19saXN0X2NsZWFyKCZwYXJ0aWFsLCAwKTsKCWNsZWFyX3BhdGhzcGVjKCZwYXRoc3BlYyk7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IHJ1bl9zdGF0dXMoRklMRSAqZnAsIGNvbnN0IGNoYXIgKmluZGV4X2ZpbGUsIGNvbnN0IGNoYXIgKnByZWZpeCwgaW50IG5vd2FybiwKCQkgICAgICBzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCglpZiAocy0+cmVsYXRpdmVfcGF0aHMpCgkJcy0+cHJlZml4ID0gcHJlZml4OwoKCWlmIChhbWVuZCkgewoJCXMtPmFtZW5kID0gMTsKCQlzLT5yZWZlcmVuY2UgPSAiSEVBRF4xIjsKCX0KCXMtPnZlcmJvc2UgPSB2ZXJib3NlOwoJcy0+aW5kZXhfZmlsZSA9IGluZGV4X2ZpbGU7CglzLT5mcCA9IGZwOwoJcy0+bm93YXJuID0gbm93YXJuOwoJcy0+aXNfaW5pdGlhbCA9IGdldF9vaWQocy0+cmVmZXJlbmNlLCAmb2lkKSA/IDEgOiAwOwoJaWYgKCFzLT5pc19pbml0aWFsKQoJCW9pZGNweSgmcy0+b2lkX2NvbW1pdCwgJm9pZCk7CglzLT5zdGF0dXNfZm9ybWF0ID0gc3RhdHVzX2Zvcm1hdDsKCXMtPmlnbm9yZV9zdWJtb2R1bGVfYXJnID0gaWdub3JlX3N1Ym1vZHVsZV9hcmc7CgoJd3Rfc3RhdHVzX2NvbGxlY3Qocyk7Cgl3dF9zdGF0dXNfcHJpbnQocyk7Cgl3dF9zdGF0dXNfY29sbGVjdF9mcmVlX2J1ZmZlcnMocyk7CgoJcmV0dXJuIHMtPmNvbW1pdHRhYmxlOwp9CgpzdGF0aWMgaW50IGlzX2FfbWVyZ2UoY29uc3Qgc3RydWN0IGNvbW1pdCAqY3VycmVudF9oZWFkKQp7CglyZXR1cm4gISEoY3VycmVudF9oZWFkLT5wYXJlbnRzICYmIGN1cnJlbnRfaGVhZC0+cGFyZW50cy0+bmV4dCk7Cn0KCnN0YXRpYyB2b2lkIGFzc2VydF9zcGxpdF9pZGVudChzdHJ1Y3QgaWRlbnRfc3BsaXQgKmlkLCBjb25zdCBzdHJ1Y3Qgc3RyYnVmICpidWYpCnsKCWlmIChzcGxpdF9pZGVudF9saW5lKGlkLCBidWYtPmJ1ZiwgYnVmLT5sZW4pIHx8ICFpZC0+ZGF0ZV9iZWdpbikKCQlCVUcoInVuYWJsZSB0byBwYXJzZSBvdXIgb3duIGlkZW50OiAlcyIsIGJ1Zi0+YnVmKTsKfQoKc3RhdGljIHZvaWQgZXhwb3J0X29uZShjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnMsIGNvbnN0IGNoYXIgKmUsIGludCBoYWNrKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaWYgKGhhY2spCgkJc3RyYnVmX2FkZGNoKCZidWYsIGhhY2spOwoJc3RyYnVmX2FkZGYoJmJ1ZiwgIiUuKnMiLCAoaW50KShlIC0gcyksIHMpOwoJc2V0ZW52KHZhciwgYnVmLmJ1ZiwgMSk7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKfQoKc3RhdGljIGludCBwYXJzZV9mb3JjZV9kYXRlKGNvbnN0IGNoYXIgKmluLCBzdHJ1Y3Qgc3RyYnVmICpvdXQpCnsKCXN0cmJ1Zl9hZGRjaChvdXQsICdAJyk7CgoJaWYgKHBhcnNlX2RhdGUoaW4sIG91dCkgPCAwKSB7CgkJaW50IGVycm9ycyA9IDA7CgkJdW5zaWduZWQgbG9uZyB0ID0gYXBwcm94aWRhdGVfY2FyZWZ1bChpbiwgJmVycm9ycyk7CgkJaWYgKGVycm9ycykKCQkJcmV0dXJuIC0xOwoJCXN0cmJ1Zl9hZGRmKG91dCwgIiVsdSIsIHQpOwoJfQoKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBzZXRfaWRlbnRfdmFyKGNoYXIgKipidWYsIGNoYXIgKnZhbCkKewoJZnJlZSgqYnVmKTsKCSpidWYgPSB2YWw7Cn0KCnN0YXRpYyB2b2lkIGRldGVybWluZV9hdXRob3JfaW5mbyhzdHJ1Y3Qgc3RyYnVmICphdXRob3JfaWRlbnQpCnsKCWNoYXIgKm5hbWUsICplbWFpbCwgKmRhdGU7CglzdHJ1Y3QgaWRlbnRfc3BsaXQgYXV0aG9yOwoKCW5hbWUgPSB4c3RyZHVwX29yX251bGwoZ2V0ZW52KCJHSVRfQVVUSE9SX05BTUUiKSk7CgllbWFpbCA9IHhzdHJkdXBfb3JfbnVsbChnZXRlbnYoIkdJVF9BVVRIT1JfRU1BSUwiKSk7CglkYXRlID0geHN0cmR1cF9vcl9udWxsKGdldGVudigiR0lUX0FVVEhPUl9EQVRFIikpOwoKCWlmIChhdXRob3JfbWVzc2FnZSkgewoJCXN0cnVjdCBpZGVudF9zcGxpdCBpZGVudDsKCQlzaXplX3QgbGVuOwoJCWNvbnN0IGNoYXIgKmE7CgoJCWEgPSBmaW5kX2NvbW1pdF9oZWFkZXIoYXV0aG9yX21lc3NhZ2VfYnVmZmVyLCAiYXV0aG9yIiwgJmxlbik7CgkJaWYgKCFhKQoJCQlkaWUoXygiY29tbWl0ICclcycgbGFja3MgYXV0aG9yIGhlYWRlciIpLCBhdXRob3JfbWVzc2FnZSk7CgkJaWYgKHNwbGl0X2lkZW50X2xpbmUoJmlkZW50LCBhLCBsZW4pIDwgMCkKCQkJZGllKF8oImNvbW1pdCAnJXMnIGhhcyBtYWxmb3JtZWQgYXV0aG9yIGxpbmUiKSwgYXV0aG9yX21lc3NhZ2UpOwoKCQlzZXRfaWRlbnRfdmFyKCZuYW1lLCB4bWVtZHVweihpZGVudC5uYW1lX2JlZ2luLCBpZGVudC5uYW1lX2VuZCAtIGlkZW50Lm5hbWVfYmVnaW4pKTsKCQlzZXRfaWRlbnRfdmFyKCZlbWFpbCwgeG1lbWR1cHooaWRlbnQubWFpbF9iZWdpbiwgaWRlbnQubWFpbF9lbmQgLSBpZGVudC5tYWlsX2JlZ2luKSk7CgoJCWlmIChpZGVudC5kYXRlX2JlZ2luKSB7CgkJCXN0cnVjdCBzdHJidWYgZGF0ZV9idWYgPSBTVFJCVUZfSU5JVDsKCQkJc3RyYnVmX2FkZGNoKCZkYXRlX2J1ZiwgJ0AnKTsKCQkJc3RyYnVmX2FkZCgmZGF0ZV9idWYsIGlkZW50LmRhdGVfYmVnaW4sIGlkZW50LmRhdGVfZW5kIC0gaWRlbnQuZGF0ZV9iZWdpbik7CgkJCXN0cmJ1Zl9hZGRjaCgmZGF0ZV9idWYsICcgJyk7CgkJCXN0cmJ1Zl9hZGQoJmRhdGVfYnVmLCBpZGVudC50el9iZWdpbiwgaWRlbnQudHpfZW5kIC0gaWRlbnQudHpfYmVnaW4pOwoJCQlzZXRfaWRlbnRfdmFyKCZkYXRlLCBzdHJidWZfZGV0YWNoKCZkYXRlX2J1ZiwgTlVMTCkpOwoJCX0KCX0KCglpZiAoZm9yY2VfYXV0aG9yKSB7CgkJc3RydWN0IGlkZW50X3NwbGl0IGlkZW50OwoKCQlpZiAoc3BsaXRfaWRlbnRfbGluZSgmaWRlbnQsIGZvcmNlX2F1dGhvciwgc3RybGVuKGZvcmNlX2F1dGhvcikpIDwgMCkKCQkJZGllKF8oIm1hbGZvcm1lZCAtLWF1dGhvciBwYXJhbWV0ZXIiKSk7CgkJc2V0X2lkZW50X3ZhcigmbmFtZSwgeG1lbWR1cHooaWRlbnQubmFtZV9iZWdpbiwgaWRlbnQubmFtZV9lbmQgLSBpZGVudC5uYW1lX2JlZ2luKSk7CgkJc2V0X2lkZW50X3ZhcigmZW1haWwsIHhtZW1kdXB6KGlkZW50Lm1haWxfYmVnaW4sIGlkZW50Lm1haWxfZW5kIC0gaWRlbnQubWFpbF9iZWdpbikpOwoJfQoKCWlmIChmb3JjZV9kYXRlKSB7CgkJc3RydWN0IHN0cmJ1ZiBkYXRlX2J1ZiA9IFNUUkJVRl9JTklUOwoJCWlmIChwYXJzZV9mb3JjZV9kYXRlKGZvcmNlX2RhdGUsICZkYXRlX2J1ZikpCgkJCWRpZShfKCJpbnZhbGlkIGRhdGUgZm9ybWF0OiAlcyIpLCBmb3JjZV9kYXRlKTsKCQlzZXRfaWRlbnRfdmFyKCZkYXRlLCBzdHJidWZfZGV0YWNoKCZkYXRlX2J1ZiwgTlVMTCkpOwoJfQoKCXN0cmJ1Zl9hZGRzdHIoYXV0aG9yX2lkZW50LCBmbXRfaWRlbnQobmFtZSwgZW1haWwsIFdBTlRfQVVUSE9SX0lERU5ULCBkYXRlLAoJCQkJSURFTlRfU1RSSUNUKSk7Cglhc3NlcnRfc3BsaXRfaWRlbnQoJmF1dGhvciwgYXV0aG9yX2lkZW50KTsKCWV4cG9ydF9vbmUoIkdJVF9BVVRIT1JfTkFNRSIsIGF1dGhvci5uYW1lX2JlZ2luLCBhdXRob3IubmFtZV9lbmQsIDApOwoJZXhwb3J0X29uZSgiR0lUX0FVVEhPUl9FTUFJTCIsIGF1dGhvci5tYWlsX2JlZ2luLCBhdXRob3IubWFpbF9lbmQsIDApOwoJZXhwb3J0X29uZSgiR0lUX0FVVEhPUl9EQVRFIiwgYXV0aG9yLmRhdGVfYmVnaW4sIGF1dGhvci50el9lbmQsICdAJyk7CglmcmVlKG5hbWUpOwoJZnJlZShlbWFpbCk7CglmcmVlKGRhdGUpOwp9CgpzdGF0aWMgaW50IGF1dGhvcl9kYXRlX2lzX2ludGVyZXN0aW5nKHZvaWQpCnsKCXJldHVybiBhdXRob3JfbWVzc2FnZSB8fCBmb3JjZV9kYXRlOwp9CgpzdGF0aWMgdm9pZCBhZGp1c3RfY29tbWVudF9saW5lX2NoYXIoY29uc3Qgc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCWNoYXIgY2FuZGlkYXRlc1tdID0gIiM7QCEkJV4mfDoiOwoJY2hhciAqY2FuZGlkYXRlOwoJY29uc3QgY2hhciAqcDsKCgljb21tZW50X2xpbmVfY2hhciA9IGNhbmRpZGF0ZXNbMF07CglpZiAoIW1lbWNocihzYi0+YnVmLCBjb21tZW50X2xpbmVfY2hhciwgc2ItPmxlbikpCgkJcmV0dXJuOwoKCXAgPSBzYi0+YnVmOwoJY2FuZGlkYXRlID0gc3RyY2hyKGNhbmRpZGF0ZXMsICpwKTsKCWlmIChjYW5kaWRhdGUpCgkJKmNhbmRpZGF0ZSA9ICcgJzsKCWZvciAocCA9IHNiLT5idWY7ICpwOyBwKyspIHsKCQlpZiAoKHBbMF0gPT0gJ1xuJyB8fCBwWzBdID09ICdccicpICYmIHBbMV0pIHsKCQkJY2FuZGlkYXRlID0gc3RyY2hyKGNhbmRpZGF0ZXMsIHBbMV0pOwoJCQlpZiAoY2FuZGlkYXRlKQoJCQkJKmNhbmRpZGF0ZSA9ICcgJzsKCQl9Cgl9CgoJZm9yIChwID0gY2FuZGlkYXRlczsgKnAgPT0gJyAnOyBwKyspCgkJOwoJaWYgKCEqcCkKCQlkaWUoXygidW5hYmxlIHRvIHNlbGVjdCBhIGNvbW1lbnQgY2hhcmFjdGVyIHRoYXQgaXMgbm90IHVzZWRcbiIKCQkgICAgICAiaW4gdGhlIGN1cnJlbnQgY29tbWl0IG1lc3NhZ2UiKSk7Cgljb21tZW50X2xpbmVfY2hhciA9ICpwOwp9CgpzdGF0aWMgaW50IHByZXBhcmVfdG9fY29tbWl0KGNvbnN0IGNoYXIgKmluZGV4X2ZpbGUsIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJICAgICBzdHJ1Y3QgY29tbWl0ICpjdXJyZW50X2hlYWQsCgkJCSAgICAgc3RydWN0IHd0X3N0YXR1cyAqcywKCQkJICAgICBzdHJ1Y3Qgc3RyYnVmICphdXRob3JfaWRlbnQpCnsKCXN0cnVjdCBzdGF0IHN0YXRidWY7CglzdHJ1Y3Qgc3RyYnVmIGNvbW1pdHRlcl9pZGVudCA9IFNUUkJVRl9JTklUOwoJaW50IGNvbW1pdHRhYmxlOwoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJY29uc3QgY2hhciAqaG9va19hcmcxID0gTlVMTDsKCWNvbnN0IGNoYXIgKmhvb2tfYXJnMiA9IE5VTEw7CglpbnQgY2xlYW5fbWVzc2FnZV9jb250ZW50cyA9IChjbGVhbnVwX21vZGUgIT0gQ09NTUlUX01TR19DTEVBTlVQX05PTkUpOwoJaW50IG9sZF9kaXNwbGF5X2NvbW1lbnRfcHJlZml4OwoJaW50IG1lcmdlX2NvbnRhaW5zX3NjaXNzb3JzID0gMDsKCgkvKiBUaGlzIGNoZWNrcyBhbmQgYmFyZnMgaWYgYXV0aG9yIGlzIGJhZGx5IHNwZWNpZmllZCAqLwoJZGV0ZXJtaW5lX2F1dGhvcl9pbmZvKGF1dGhvcl9pZGVudCk7CgoJaWYgKCFub192ZXJpZnkgJiYgcnVuX2NvbW1pdF9ob29rKHVzZV9lZGl0b3IsIGluZGV4X2ZpbGUsICJwcmUtY29tbWl0IiwgTlVMTCkpCgkJcmV0dXJuIDA7CgoJaWYgKHNxdWFzaF9tZXNzYWdlKSB7CgkJLyoKCQkgKiBJbnNlcnQgdGhlIHByb3BlciBzdWJqZWN0IGxpbmUgYmVmb3JlIG90aGVyIGNvbW1pdAoJCSAqIG1lc3NhZ2Ugb3B0aW9ucyBhZGQgdGhlaXIgY29udGVudC4KCQkgKi8KCQlpZiAodXNlX21lc3NhZ2UgJiYgIXN0cmNtcCh1c2VfbWVzc2FnZSwgc3F1YXNoX21lc3NhZ2UpKQoJCQlzdHJidWZfYWRkc3RyKCZzYiwgInNxdWFzaCEgIik7CgkJZWxzZSB7CgkJCXN0cnVjdCBwcmV0dHlfcHJpbnRfY29udGV4dCBjdHggPSB7MH07CgkJCXN0cnVjdCBjb21taXQgKmM7CgkJCWMgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9ieV9uYW1lKHNxdWFzaF9tZXNzYWdlKTsKCQkJaWYgKCFjKQoJCQkJZGllKF8oImNvdWxkIG5vdCBsb29rdXAgY29tbWl0ICVzIiksIHNxdWFzaF9tZXNzYWdlKTsKCQkJY3R4Lm91dHB1dF9lbmNvZGluZyA9IGdldF9jb21taXRfb3V0cHV0X2VuY29kaW5nKCk7CgkJCWZvcm1hdF9jb21taXRfbWVzc2FnZShjLCAic3F1YXNoISAlc1xuXG4iLCAmc2IsCgkJCQkJICAgICAgJmN0eCk7CgkJfQoJfQoKCWlmIChoYXZlX29wdGlvbl9tICYmICFmaXh1cF9tZXNzYWdlKSB7CgkJc3RyYnVmX2FkZGJ1Zigmc2IsICZtZXNzYWdlKTsKCQlob29rX2FyZzEgPSAibWVzc2FnZSI7Cgl9IGVsc2UgaWYgKGxvZ2ZpbGUgJiYgIXN0cmNtcChsb2dmaWxlLCAiLSIpKSB7CgkJaWYgKGlzYXR0eSgwKSkKCQkJZnByaW50ZihzdGRlcnIsIF8oIihyZWFkaW5nIGxvZyBtZXNzYWdlIGZyb20gc3RhbmRhcmQgaW5wdXQpXG4iKSk7CgkJaWYgKHN0cmJ1Zl9yZWFkKCZzYiwgMCwgMCkgPCAwKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlYWQgbG9nIGZyb20gc3RhbmRhcmQgaW5wdXQiKSk7CgkJaG9va19hcmcxID0gIm1lc3NhZ2UiOwoJfSBlbHNlIGlmIChsb2dmaWxlKSB7CgkJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJnNiLCBsb2dmaWxlLCAwKSA8IDApCgkJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgcmVhZCBsb2cgZmlsZSAnJXMnIiksCgkJCQkgIGxvZ2ZpbGUpOwoJCWhvb2tfYXJnMSA9ICJtZXNzYWdlIjsKCX0gZWxzZSBpZiAodXNlX21lc3NhZ2UpIHsKCQljaGFyICpidWZmZXI7CgkJYnVmZmVyID0gc3Ryc3RyKHVzZV9tZXNzYWdlX2J1ZmZlciwgIlxuXG4iKTsKCQlpZiAoYnVmZmVyKQoJCQlzdHJidWZfYWRkc3RyKCZzYiwgc2tpcF9ibGFua19saW5lcyhidWZmZXIgKyAyKSk7CgkJaG9va19hcmcxID0gImNvbW1pdCI7CgkJaG9va19hcmcyID0gdXNlX21lc3NhZ2U7Cgl9IGVsc2UgaWYgKGZpeHVwX21lc3NhZ2UpIHsKCQlzdHJ1Y3QgcHJldHR5X3ByaW50X2NvbnRleHQgY3R4ID0gezB9OwoJCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCQljb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9ieV9uYW1lKGZpeHVwX21lc3NhZ2UpOwoJCWlmICghY29tbWl0KQoJCQlkaWUoXygiY291bGQgbm90IGxvb2t1cCBjb21taXQgJXMiKSwgZml4dXBfbWVzc2FnZSk7CgkJY3R4Lm91dHB1dF9lbmNvZGluZyA9IGdldF9jb21taXRfb3V0cHV0X2VuY29kaW5nKCk7CgkJZm9ybWF0X2NvbW1pdF9tZXNzYWdlKGNvbW1pdCwgImZpeHVwISAlc1xuXG4iLAoJCQkJICAgICAgJnNiLCAmY3R4KTsKCQlpZiAoaGF2ZV9vcHRpb25fbSkKCQkJc3RyYnVmX2FkZGJ1Zigmc2IsICZtZXNzYWdlKTsKCQlob29rX2FyZzEgPSAibWVzc2FnZSI7Cgl9IGVsc2UgaWYgKCFzdGF0KGdpdF9wYXRoX21lcmdlX21zZyh0aGVfcmVwb3NpdG9yeSksICZzdGF0YnVmKSkgewoJCXNpemVfdCBtZXJnZV9tc2dfc3RhcnQ7CgoJCS8qCgkJICogcHJlcGVuZCBTUVVBU0hfTVNHIGhlcmUgaWYgaXQgZXhpc3RzIGFuZCBhCgkJICogIm1lcmdlIC0tc3F1YXNoIiB3YXMgb3JpZ2luYWxseSBwZXJmb3JtZWQKCQkgKi8KCQlpZiAoIXN0YXQoZ2l0X3BhdGhfc3F1YXNoX21zZyh0aGVfcmVwb3NpdG9yeSksICZzdGF0YnVmKSkgewoJCQlpZiAoc3RyYnVmX3JlYWRfZmlsZSgmc2IsIGdpdF9wYXRoX3NxdWFzaF9tc2codGhlX3JlcG9zaXRvcnkpLCAwKSA8IDApCgkJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlYWQgU1FVQVNIX01TRyIpKTsKCQkJaG9va19hcmcxID0gInNxdWFzaCI7CgkJfSBlbHNlCgkJCWhvb2tfYXJnMSA9ICJtZXJnZSI7CgoJCW1lcmdlX21zZ19zdGFydCA9IHNiLmxlbjsKCQlpZiAoc3RyYnVmX3JlYWRfZmlsZSgmc2IsIGdpdF9wYXRoX21lcmdlX21zZyh0aGVfcmVwb3NpdG9yeSksIDApIDwgMCkKCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkIE1FUkdFX01TRyIpKTsKCgkJaWYgKGNsZWFudXBfbW9kZSA9PSBDT01NSVRfTVNHX0NMRUFOVVBfU0NJU1NPUlMgJiYKCQkgICAgd3Rfc3RhdHVzX2xvY2F0ZV9lbmQoc2IuYnVmICsgbWVyZ2VfbXNnX3N0YXJ0LAoJCQkJCSBzYi5sZW4gLSBtZXJnZV9tc2dfc3RhcnQpIDwKCQkJCXNiLmxlbiAtIG1lcmdlX21zZ19zdGFydCkKCQkJbWVyZ2VfY29udGFpbnNfc2Npc3NvcnMgPSAxOwoJfSBlbHNlIGlmICghc3RhdChnaXRfcGF0aF9zcXVhc2hfbXNnKHRoZV9yZXBvc2l0b3J5KSwgJnN0YXRidWYpKSB7CgkJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJnNiLCBnaXRfcGF0aF9zcXVhc2hfbXNnKHRoZV9yZXBvc2l0b3J5KSwgMCkgPCAwKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlYWQgU1FVQVNIX01TRyIpKTsKCQlob29rX2FyZzEgPSAic3F1YXNoIjsKCX0gZWxzZSBpZiAodGVtcGxhdGVfZmlsZSkgewoJCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgdGVtcGxhdGVfZmlsZSwgMCkgPCAwKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlYWQgJyVzJyIpLCB0ZW1wbGF0ZV9maWxlKTsKCQlob29rX2FyZzEgPSAidGVtcGxhdGUiOwoJCWNsZWFuX21lc3NhZ2VfY29udGVudHMgPSAwOwoJfQoKCS8qCgkgKiBUaGUgcmVtYWluaW5nIGNhc2VzIGRvbid0IG1vZGlmeSB0aGUgdGVtcGxhdGUgbWVzc2FnZSwgYnV0CgkgKiBqdXN0IHNldCB0aGUgYXJndW1lbnQocykgdG8gdGhlIHByZXBhcmUtY29tbWl0LW1zZyBob29rLgoJICovCgllbHNlIGlmICh3aGVuY2UgPT0gRlJPTV9NRVJHRSkKCQlob29rX2FyZzEgPSAibWVyZ2UiOwoJZWxzZSBpZiAod2hlbmNlID09IEZST01fQ0hFUlJZX1BJQ0spIHsKCQlob29rX2FyZzEgPSAiY29tbWl0IjsKCQlob29rX2FyZzIgPSAiQ0hFUlJZX1BJQ0tfSEVBRCI7Cgl9CgoJaWYgKHNxdWFzaF9tZXNzYWdlKSB7CgkJLyoKCQkgKiBJZiBzcXVhc2hfY29tbWl0IHdhcyB1c2VkIGZvciB0aGUgY29tbWl0IHN1YmplY3QsCgkJICogdGhlbiB3ZSdyZSBwb3NzaWJseSBoaWphY2tpbmcgb3RoZXIgY29tbWl0IGxvZyBvcHRpb25zLgoJCSAqIFJlc2V0IHRoZSBob29rIGFyZ3MgdG8gdGVsbCB0aGUgcmVhbCBzdG9yeS4KCQkgKi8KCQlob29rX2FyZzEgPSAibWVzc2FnZSI7CgkJaG9va19hcmcyID0gIiI7Cgl9CgoJcy0+ZnAgPSBmb3Blbl9mb3Jfd3JpdGluZyhnaXRfcGF0aF9jb21taXRfZWRpdG1zZygpKTsKCWlmIChzLT5mcCA9PSBOVUxMKQoJCWRpZV9lcnJubyhfKCJjb3VsZCBub3Qgb3BlbiAnJXMnIiksIGdpdF9wYXRoX2NvbW1pdF9lZGl0bXNnKCkpOwoKCS8qIElnbm9yZSBzdGF0dXMuZGlzcGxheUNvbW1lbnRQcmVmaXg6IHdlIGRvIG5lZWQgY29tbWVudHMgaW4gQ09NTUlUX0VESVRNU0cuICovCglvbGRfZGlzcGxheV9jb21tZW50X3ByZWZpeCA9IHMtPmRpc3BsYXlfY29tbWVudF9wcmVmaXg7CglzLT5kaXNwbGF5X2NvbW1lbnRfcHJlZml4ID0gMTsKCgkvKgoJICogTW9zdCBoaW50cyBhcmUgY291bnRlci1wcm9kdWN0aXZlIHdoZW4gdGhlIGNvbW1pdCBoYXMKCSAqIGFscmVhZHkgc3RhcnRlZC4KCSAqLwoJcy0+aGludHMgPSAwOwoKCWlmIChjbGVhbl9tZXNzYWdlX2NvbnRlbnRzKQoJCXN0cmJ1Zl9zdHJpcHNwYWNlKCZzYiwgMCk7CgoJaWYgKHNpZ25vZmYpCgkJYXBwZW5kX3NpZ25vZmYoJnNiLCBpZ25vcmVfbm9uX3RyYWlsZXIoc2IuYnVmLCBzYi5sZW4pLCAwKTsKCglpZiAoZndyaXRlKHNiLmJ1ZiwgMSwgc2IubGVuLCBzLT5mcCkgPCBzYi5sZW4pCgkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCB3cml0ZSBjb21taXQgdGVtcGxhdGUiKSk7CgoJaWYgKGF1dG9fY29tbWVudF9saW5lX2NoYXIpCgkJYWRqdXN0X2NvbW1lbnRfbGluZV9jaGFyKCZzYik7CglzdHJidWZfcmVsZWFzZSgmc2IpOwoKCS8qIFRoaXMgY2hlY2tzIGlmIGNvbW1pdHRlciBpZGVudCBpcyBleHBsaWNpdGx5IGdpdmVuICovCglzdHJidWZfYWRkc3RyKCZjb21taXR0ZXJfaWRlbnQsIGdpdF9jb21taXR0ZXJfaW5mbyhJREVOVF9TVFJJQ1QpKTsKCWlmICh1c2VfZWRpdG9yICYmIGluY2x1ZGVfc3RhdHVzKSB7CgkJaW50IGlkZW50X3Nob3duID0gMDsKCQlpbnQgc2F2ZWRfY29sb3Jfc2V0dGluZzsKCQlzdHJ1Y3QgaWRlbnRfc3BsaXQgY2ksIGFpOwoKCQlpZiAod2hlbmNlICE9IEZST01fQ09NTUlUKSB7CgkJCWlmIChjbGVhbnVwX21vZGUgPT0gQ09NTUlUX01TR19DTEVBTlVQX1NDSVNTT1JTICYmCgkJCQkhbWVyZ2VfY29udGFpbnNfc2Npc3NvcnMpCgkJCQl3dF9zdGF0dXNfYWRkX2N1dF9saW5lKHMtPmZwKTsKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkgICAgd2hlbmNlID09IEZST01fTUVSR0UKCQkJCT8gXygiXG4iCgkJCQkJIkl0IGxvb2tzIGxpa2UgeW91IG1heSBiZSBjb21taXR0aW5nIGEgbWVyZ2UuXG4iCgkJCQkJIklmIHRoaXMgaXMgbm90IGNvcnJlY3QsIHBsZWFzZSByZW1vdmUgdGhlIGZpbGVcbiIKCQkJCQkiCSVzXG4iCgkJCQkJImFuZCB0cnkgYWdhaW4uXG4iKQoJCQkJOiBfKCJcbiIKCQkJCQkiSXQgbG9va3MgbGlrZSB5b3UgbWF5IGJlIGNvbW1pdHRpbmcgYSBjaGVycnktcGljay5cbiIKCQkJCQkiSWYgdGhpcyBpcyBub3QgY29ycmVjdCwgcGxlYXNlIHJlbW92ZSB0aGUgZmlsZVxuIgoJCQkJCSIJJXNcbiIKCQkJCQkiYW5kIHRyeSBhZ2Fpbi5cbiIpLAoJCQkJd2hlbmNlID09IEZST01fTUVSR0UgPwoJCQkJCWdpdF9wYXRoX21lcmdlX2hlYWQodGhlX3JlcG9zaXRvcnkpIDoKCQkJCQlnaXRfcGF0aF9jaGVycnlfcGlja19oZWFkKHRoZV9yZXBvc2l0b3J5KSk7CgkJfQoKCQlmcHJpbnRmKHMtPmZwLCAiXG4iKTsKCQlpZiAoY2xlYW51cF9tb2RlID09IENPTU1JVF9NU0dfQ0xFQU5VUF9BTEwpCgkJCXN0YXR1c19wcmludGYocywgR0lUX0NPTE9SX05PUk1BTCwKCQkJCV8oIlBsZWFzZSBlbnRlciB0aGUgY29tbWl0IG1lc3NhZ2UgZm9yIHlvdXIgY2hhbmdlcy4iCgkJCQkgICIgTGluZXMgc3RhcnRpbmdcbndpdGggJyVjJyB3aWxsIGJlIGlnbm9yZWQsIGFuZCBhbiBlbXB0eSIKCQkJCSAgIiBtZXNzYWdlIGFib3J0cyB0aGUgY29tbWl0LlxuIiksIGNvbW1lbnRfbGluZV9jaGFyKTsKCQllbHNlIGlmIChjbGVhbnVwX21vZGUgPT0gQ09NTUlUX01TR19DTEVBTlVQX1NDSVNTT1JTKSB7CgkJCWlmICh3aGVuY2UgPT0gRlJPTV9DT01NSVQgJiYgIW1lcmdlX2NvbnRhaW5zX3NjaXNzb3JzKQoJCQkJd3Rfc3RhdHVzX2FkZF9jdXRfbGluZShzLT5mcCk7CgkJfSBlbHNlIC8qIENPTU1JVF9NU0dfQ0xFQU5VUF9TUEFDRSwgdGhhdCBpcy4gKi8KCQkJc3RhdHVzX3ByaW50ZihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJXygiUGxlYXNlIGVudGVyIHRoZSBjb21taXQgbWVzc2FnZSBmb3IgeW91ciBjaGFuZ2VzLiIKCQkJCSAgIiBMaW5lcyBzdGFydGluZ1xuIgoJCQkJICAid2l0aCAnJWMnIHdpbGwgYmUga2VwdDsgeW91IG1heSByZW1vdmUgdGhlbSIKCQkJCSAgIiB5b3Vyc2VsZiBpZiB5b3Ugd2FudCB0by5cbiIKCQkJCSAgIkFuIGVtcHR5IG1lc3NhZ2UgYWJvcnRzIHRoZSBjb21taXQuXG4iKSwgY29tbWVudF9saW5lX2NoYXIpOwoKCQkvKgoJCSAqIFRoZXNlIHNob3VsZCBuZXZlciBmYWlsIGJlY2F1c2UgdGhleSBjb21lIGZyb20gb3VyIG93bgoJCSAqIGZtdF9pZGVudC4gVGhleSBtYXkgZmFpbCB0aGUgc2FuZV9pZGVudCB0ZXN0LCBidXQgd2Uga25vdwoJCSAqIHRoYXQgdGhlIG5hbWUgYW5kIG1haWwgcG9pbnRlcnMgd2lsbCBhdCBsZWFzdCBiZSB2YWxpZCwKCQkgKiB3aGljaCBpcyBlbm91Z2ggZm9yIG91ciB0ZXN0cyBhbmQgcHJpbnRpbmcgaGVyZS4KCQkgKi8KCQlhc3NlcnRfc3BsaXRfaWRlbnQoJmFpLCBhdXRob3JfaWRlbnQpOwoJCWFzc2VydF9zcGxpdF9pZGVudCgmY2ksICZjb21taXR0ZXJfaWRlbnQpOwoKCQlpZiAoaWRlbnRfY21wKCZhaSwgJmNpKSkKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJXygiJXMiCgkJCQkiQXV0aG9yOiAgICAlLipzIDwlLipzPiIpLAoJCQkJaWRlbnRfc2hvd24rKyA/ICIiIDogIlxuIiwKCQkJCShpbnQpKGFpLm5hbWVfZW5kIC0gYWkubmFtZV9iZWdpbiksIGFpLm5hbWVfYmVnaW4sCgkJCQkoaW50KShhaS5tYWlsX2VuZCAtIGFpLm1haWxfYmVnaW4pLCBhaS5tYWlsX2JlZ2luKTsKCgkJaWYgKGF1dGhvcl9kYXRlX2lzX2ludGVyZXN0aW5nKCkpCgkJCXN0YXR1c19wcmludGZfbG4ocywgR0lUX0NPTE9SX05PUk1BTCwKCQkJCV8oIiVzIgoJCQkJIkRhdGU6ICAgICAgJXMiKSwKCQkJCWlkZW50X3Nob3duKysgPyAiIiA6ICJcbiIsCgkJCQlzaG93X2lkZW50X2RhdGUoJmFpLCBEQVRFX01PREUoTk9STUFMKSkpOwoKCQlpZiAoIWNvbW1pdHRlcl9pZGVudF9zdWZmaWNpZW50bHlfZ2l2ZW4oKSkKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJXygiJXMiCgkJCQkiQ29tbWl0dGVyOiAlLipzIDwlLipzPiIpLAoJCQkJaWRlbnRfc2hvd24rKyA/ICIiIDogIlxuIiwKCQkJCShpbnQpKGNpLm5hbWVfZW5kIC0gY2kubmFtZV9iZWdpbiksIGNpLm5hbWVfYmVnaW4sCgkJCQkoaW50KShjaS5tYWlsX2VuZCAtIGNpLm1haWxfYmVnaW4pLCBjaS5tYWlsX2JlZ2luKTsKCgkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLCAiJXMiLCAiIik7IC8qIEFkZCBuZXcgbGluZSBmb3IgY2xhcml0eSAqLwoKCQlzYXZlZF9jb2xvcl9zZXR0aW5nID0gcy0+dXNlX2NvbG9yOwoJCXMtPnVzZV9jb2xvciA9IDA7CgkJY29tbWl0dGFibGUgPSBydW5fc3RhdHVzKHMtPmZwLCBpbmRleF9maWxlLCBwcmVmaXgsIDEsIHMpOwoJCXMtPnVzZV9jb2xvciA9IHNhdmVkX2NvbG9yX3NldHRpbmc7CgkJc3RyaW5nX2xpc3RfY2xlYXIoJnMtPmNoYW5nZSwgMSk7Cgl9IGVsc2UgewoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCWNvbnN0IGNoYXIgKnBhcmVudCA9ICJIRUFEIjsKCgkJaWYgKCFhY3RpdmVfbnIgJiYgcmVhZF9jYWNoZSgpIDwgMCkKCQkJZGllKF8oIkNhbm5vdCByZWFkIGluZGV4IikpOwoKCQlpZiAoYW1lbmQpCgkJCXBhcmVudCA9ICJIRUFEXjEiOwoKCQlpZiAoZ2V0X29pZChwYXJlbnQsICZvaWQpKSB7CgkJCWludCBpLCBpdGFfbnIgPSAwOwoKCQkJZm9yIChpID0gMDsgaSA8IGFjdGl2ZV9ucjsgaSsrKQoJCQkJaWYgKGNlX2ludGVudF90b19hZGQoYWN0aXZlX2NhY2hlW2ldKSkKCQkJCQlpdGFfbnIrKzsKCQkJY29tbWl0dGFibGUgPSBhY3RpdmVfbnIgLSBpdGFfbnIgPiAwOwoJCX0gZWxzZSB7CgkJCS8qCgkJCSAqIFVubGVzcyB0aGUgdXNlciBkaWQgZXhwbGljaXRseSByZXF1ZXN0IGEgc3VibW9kdWxlCgkJCSAqIGlnbm9yZSBtb2RlIGJ5IHBhc3NpbmcgYSBjb21tYW5kIGxpbmUgb3B0aW9uIHdlIGRvCgkJCSAqIG5vdCBpZ25vcmUgYW55IGNoYW5nZWQgc3VibW9kdWxlIFNIQS0xcyB3aGVuCgkJCSAqIGNvbXBhcmluZyBpbmRleCBhbmQgcGFyZW50LCBubyBtYXR0ZXIgd2hhdCBpcwoJCQkgKiBjb25maWd1cmVkLiBPdGhlcndpc2Ugd2Ugd29uJ3QgY29tbWl0IGFueQoJCQkgKiBzdWJtb2R1bGVzIHdoaWNoIHdlcmUgbWFudWFsbHkgc3RhZ2VkLCB3aGljaCB3b3VsZAoJCQkgKiBiZSByZWFsbHkgY29uZnVzaW5nLgoJCQkgKi8KCQkJc3RydWN0IGRpZmZfZmxhZ3MgZmxhZ3MgPSBESUZGX0ZMQUdTX0lOSVQ7CgkJCWZsYWdzLm92ZXJyaWRlX3N1Ym1vZHVsZV9jb25maWcgPSAxOwoJCQlpZiAoaWdub3JlX3N1Ym1vZHVsZV9hcmcgJiYKCQkJICAgICFzdHJjbXAoaWdub3JlX3N1Ym1vZHVsZV9hcmcsICJhbGwiKSkKCQkJCWZsYWdzLmlnbm9yZV9zdWJtb2R1bGVzID0gMTsKCQkJY29tbWl0dGFibGUgPSBpbmRleF9kaWZmZXJzX2Zyb20odGhlX3JlcG9zaXRvcnksCgkJCQkJCQkgcGFyZW50LCAmZmxhZ3MsIDEpOwoJCX0KCX0KCXN0cmJ1Zl9yZWxlYXNlKCZjb21taXR0ZXJfaWRlbnQpOwoKCWZjbG9zZShzLT5mcCk7CgoJLyoKCSAqIFJlamVjdCBhbiBhdHRlbXB0IHRvIHJlY29yZCBhIG5vbi1tZXJnZSBlbXB0eSBjb21taXQgd2l0aG91dAoJICogZXhwbGljaXQgLS1hbGxvdy1lbXB0eS4gSW4gdGhlIGNoZXJyeS1waWNrIGNhc2UsIGl0IG1heSBiZQoJICogZW1wdHkgZHVlIHRvIGNvbmZsaWN0IHJlc29sdXRpb24sIHdoaWNoIHRoZSB1c2VyIHNob3VsZCBva2F5LgoJICovCglpZiAoIWNvbW1pdHRhYmxlICYmIHdoZW5jZSAhPSBGUk9NX01FUkdFICYmICFhbGxvd19lbXB0eSAmJgoJICAgICEoYW1lbmQgJiYgaXNfYV9tZXJnZShjdXJyZW50X2hlYWQpKSkgewoJCXMtPmhpbnRzID0gYWR2aWNlX3N0YXR1c19oaW50czsKCQlzLT5kaXNwbGF5X2NvbW1lbnRfcHJlZml4ID0gb2xkX2Rpc3BsYXlfY29tbWVudF9wcmVmaXg7CgkJcnVuX3N0YXR1cyhzdGRvdXQsIGluZGV4X2ZpbGUsIHByZWZpeCwgMCwgcyk7CgkJaWYgKGFtZW5kKQoJCQlmcHV0cyhfKGVtcHR5X2FtZW5kX2FkdmljZSksIHN0ZGVycik7CgkJZWxzZSBpZiAod2hlbmNlID09IEZST01fQ0hFUlJZX1BJQ0spIHsKCQkJZnB1dHMoXyhlbXB0eV9jaGVycnlfcGlja19hZHZpY2UpLCBzdGRlcnIpOwoJCQlpZiAoIXNlcXVlbmNlcl9pbl91c2UpCgkJCQlmcHV0cyhfKGVtcHR5X2NoZXJyeV9waWNrX2FkdmljZV9zaW5nbGUpLCBzdGRlcnIpOwoJCQllbHNlCgkJCQlmcHV0cyhfKGVtcHR5X2NoZXJyeV9waWNrX2FkdmljZV9tdWx0aSksIHN0ZGVycik7CgkJfQoJCXJldHVybiAwOwoJfQoKCWlmICghbm9fdmVyaWZ5ICYmIGZpbmRfaG9vaygicHJlLWNvbW1pdCIpKSB7CgkJLyoKCQkgKiBSZS1yZWFkIHRoZSBpbmRleCBhcyBwcmUtY29tbWl0IGhvb2sgY291bGQgaGF2ZSB1cGRhdGVkIGl0LAoJCSAqIGFuZCB3cml0ZSBpdCBvdXQgYXMgYSB0cmVlLiAgV2UgbXVzdCBkbyB0aGlzIGJlZm9yZSB3ZSBpbnZva2UKCQkgKiB0aGUgZWRpdG9yIGFuZCBhZnRlciB3ZSBpbnZva2UgcnVuX3N0YXR1cyBhYm92ZS4KCQkgKi8KCQlkaXNjYXJkX2NhY2hlKCk7Cgl9CglyZWFkX2NhY2hlX2Zyb20oaW5kZXhfZmlsZSk7CgoJaWYgKHVwZGF0ZV9tYWluX2NhY2hlX3RyZWUoMCkpIHsKCQllcnJvcihfKCJFcnJvciBidWlsZGluZyB0cmVlcyIpKTsKCQlyZXR1cm4gMDsKCX0KCglpZiAocnVuX2NvbW1pdF9ob29rKHVzZV9lZGl0b3IsIGluZGV4X2ZpbGUsICJwcmVwYXJlLWNvbW1pdC1tc2ciLAoJCQkgICAgZ2l0X3BhdGhfY29tbWl0X2VkaXRtc2coKSwgaG9va19hcmcxLCBob29rX2FyZzIsIE5VTEwpKQoJCXJldHVybiAwOwoKCWlmICh1c2VfZWRpdG9yKSB7CgkJc3RydWN0IGFyZ3ZfYXJyYXkgZW52ID0gQVJHVl9BUlJBWV9JTklUOwoKCQlhcmd2X2FycmF5X3B1c2hmKCZlbnYsICJHSVRfSU5ERVhfRklMRT0lcyIsIGluZGV4X2ZpbGUpOwoJCWlmIChsYXVuY2hfZWRpdG9yKGdpdF9wYXRoX2NvbW1pdF9lZGl0bXNnKCksIE5VTEwsIGVudi5hcmd2KSkgewoJCQlmcHJpbnRmKHN0ZGVyciwKCQkJXygiUGxlYXNlIHN1cHBseSB0aGUgbWVzc2FnZSB1c2luZyBlaXRoZXIgLW0gb3IgLUYgb3B0aW9uLlxuIikpOwoJCQlleGl0KDEpOwoJCX0KCQlhcmd2X2FycmF5X2NsZWFyKCZlbnYpOwoJfQoKCWlmICghbm9fdmVyaWZ5ICYmCgkgICAgcnVuX2NvbW1pdF9ob29rKHVzZV9lZGl0b3IsIGluZGV4X2ZpbGUsICJjb21taXQtbXNnIiwgZ2l0X3BhdGhfY29tbWl0X2VkaXRtc2coKSwgTlVMTCkpIHsKCQlyZXR1cm4gMDsKCX0KCglyZXR1cm4gMTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKmZpbmRfYXV0aG9yX2J5X25pY2tuYW1lKGNvbnN0IGNoYXIgKm5hbWUpCnsKCXN0cnVjdCByZXZfaW5mbyByZXZzOwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJpbmdfbGlzdCBtYWlsbWFwID0gU1RSSU5HX0xJU1RfSU5JVF9OT0RVUDsKCWNvbnN0IGNoYXIgKmF2WzIwXTsKCWludCBhYyA9IDA7CgoJcmVwb19pbml0X3JldmlzaW9ucyh0aGVfcmVwb3NpdG9yeSwgJnJldnMsIE5VTEwpOwoJc3RyYnVmX2FkZGYoJmJ1ZiwgIi0tYXV0aG9yPSVzIiwgbmFtZSk7CglhdlsrK2FjXSA9ICItLWFsbCI7CglhdlsrK2FjXSA9ICItaSI7CglhdlsrK2FjXSA9IGJ1Zi5idWY7CglhdlsrK2FjXSA9IE5VTEw7CglzZXR1cF9yZXZpc2lvbnMoYWMsIGF2LCAmcmV2cywgTlVMTCk7CglyZXZzLm1haWxtYXAgPSAmbWFpbG1hcDsKCXJlYWRfbWFpbG1hcChyZXZzLm1haWxtYXAsIE5VTEwpOwoKCWlmIChwcmVwYXJlX3JldmlzaW9uX3dhbGsoJnJldnMpKQoJCWRpZShfKCJyZXZpc2lvbiB3YWxrIHNldHVwIGZhaWxlZCIpKTsKCWNvbW1pdCA9IGdldF9yZXZpc2lvbigmcmV2cyk7CglpZiAoY29tbWl0KSB7CgkJc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0IGN0eCA9IHswfTsKCQljdHguZGF0ZV9tb2RlLnR5cGUgPSBEQVRFX05PUk1BTDsKCQlzdHJidWZfcmVsZWFzZSgmYnVmKTsKCQlmb3JtYXRfY29tbWl0X21lc3NhZ2UoY29tbWl0LCAiJWFOIDwlYUU+IiwgJmJ1ZiwgJmN0eCk7CgkJY2xlYXJfbWFpbG1hcCgmbWFpbG1hcCk7CgkJcmV0dXJuIHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7Cgl9CglkaWUoXygiLS1hdXRob3IgJyVzJyBpcyBub3QgJ05hbWUgPGVtYWlsPicgYW5kIG1hdGNoZXMgbm8gZXhpc3RpbmcgYXV0aG9yIiksIG5hbWUpOwp9CgpzdGF0aWMgdm9pZCBoYW5kbGVfaWdub3JlZF9hcmcoc3RydWN0IHd0X3N0YXR1cyAqcykKewoJaWYgKCFpZ25vcmVkX2FyZykKCQk7IC8qIGRlZmF1bHQgYWxyZWFkeSBpbml0aWFsaXplZCAqLwoJZWxzZSBpZiAoIXN0cmNtcChpZ25vcmVkX2FyZywgInRyYWRpdGlvbmFsIikpCgkJcy0+c2hvd19pZ25vcmVkX21vZGUgPSBTSE9XX1RSQURJVElPTkFMX0lHTk9SRUQ7CgllbHNlIGlmICghc3RyY21wKGlnbm9yZWRfYXJnLCAibm8iKSkKCQlzLT5zaG93X2lnbm9yZWRfbW9kZSA9IFNIT1dfTk9fSUdOT1JFRDsKCWVsc2UgaWYgKCFzdHJjbXAoaWdub3JlZF9hcmcsICJtYXRjaGluZyIpKQoJCXMtPnNob3dfaWdub3JlZF9tb2RlID0gU0hPV19NQVRDSElOR19JR05PUkVEOwoJZWxzZQoJCWRpZShfKCJJbnZhbGlkIGlnbm9yZWQgbW9kZSAnJXMnIiksIGlnbm9yZWRfYXJnKTsKfQoKc3RhdGljIHZvaWQgaGFuZGxlX3VudHJhY2tlZF9maWxlc19hcmcoc3RydWN0IHd0X3N0YXR1cyAqcykKewoJaWYgKCF1bnRyYWNrZWRfZmlsZXNfYXJnKQoJCTsgLyogZGVmYXVsdCBhbHJlYWR5IGluaXRpYWxpemVkICovCgllbHNlIGlmICghc3RyY21wKHVudHJhY2tlZF9maWxlc19hcmcsICJubyIpKQoJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19OT19VTlRSQUNLRURfRklMRVM7CgllbHNlIGlmICghc3RyY21wKHVudHJhY2tlZF9maWxlc19hcmcsICJub3JtYWwiKSkKCQlzLT5zaG93X3VudHJhY2tlZF9maWxlcyA9IFNIT1dfTk9STUFMX1VOVFJBQ0tFRF9GSUxFUzsKCWVsc2UgaWYgKCFzdHJjbXAodW50cmFja2VkX2ZpbGVzX2FyZywgImFsbCIpKQoJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19BTExfVU5UUkFDS0VEX0ZJTEVTOwoJLyoKCSAqIFBsZWFzZSB1cGRhdGUgJF9fZ2l0X3VudHJhY2tlZF9maWxlX21vZGVzIGluCgkgKiBnaXQtY29tcGxldGlvbi5iYXNoIHdoZW4geW91IGFkZCBuZXcgb3B0aW9ucwoJICovCgllbHNlCgkJZGllKF8oIkludmFsaWQgdW50cmFja2VkIGZpbGVzIG1vZGUgJyVzJyIpLCB1bnRyYWNrZWRfZmlsZXNfYXJnKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnJlYWRfY29tbWl0X21lc3NhZ2UoY29uc3QgY2hhciAqbmFtZSkKewoJY29uc3QgY2hhciAqb3V0X2VuYzsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCgljb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9ieV9uYW1lKG5hbWUpOwoJaWYgKCFjb21taXQpCgkJZGllKF8oImNvdWxkIG5vdCBsb29rdXAgY29tbWl0ICVzIiksIG5hbWUpOwoJb3V0X2VuYyA9IGdldF9jb21taXRfb3V0cHV0X2VuY29kaW5nKCk7CglyZXR1cm4gbG9nbXNnX3JlZW5jb2RlKGNvbW1pdCwgTlVMTCwgb3V0X2VuYyk7Cn0KCi8qCiAqIEVudW1lcmF0ZSB3aGF0IG5lZWRzIHRvIGJlIHByb3BhZ2F0ZWQgd2hlbiAtLXBvcmNlbGFpbgogKiBpcyBub3QgaW4gZWZmZWN0IGhlcmUuCiAqLwpzdGF0aWMgc3RydWN0IHN0YXR1c19kZWZlcnJlZF9jb25maWcgewoJZW51bSB3dF9zdGF0dXNfZm9ybWF0IHN0YXR1c19mb3JtYXQ7CglpbnQgc2hvd19icmFuY2g7CgllbnVtIGFoZWFkX2JlaGluZF9mbGFncyBhaGVhZF9iZWhpbmQ7Cn0gc3RhdHVzX2RlZmVycmVkX2NvbmZpZyA9IHsKCVNUQVRVU19GT1JNQVRfVU5TUEVDSUZJRUQsCgktMSwgLyogdW5zcGVjaWZpZWQgKi8KCUFIRUFEX0JFSElORF9VTlNQRUNJRklFRCwKfTsKCnN0YXRpYyB2b2lkIGZpbmFsaXplX2RlZmVycmVkX2NvbmZpZyhzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglpbnQgdXNlX2RlZmVycmVkX2NvbmZpZyA9IChzdGF0dXNfZm9ybWF0ICE9IFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOICYmCgkJCQkgICBzdGF0dXNfZm9ybWF0ICE9IFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOX1YyICYmCgkJCQkgICAhcy0+bnVsbF90ZXJtaW5hdGlvbik7CgoJaWYgKHMtPm51bGxfdGVybWluYXRpb24pIHsKCQlpZiAoc3RhdHVzX2Zvcm1hdCA9PSBTVEFUVVNfRk9STUFUX05PTkUgfHwKCQkgICAgc3RhdHVzX2Zvcm1hdCA9PSBTVEFUVVNfRk9STUFUX1VOU1BFQ0lGSUVEKQoJCQlzdGF0dXNfZm9ybWF0ID0gU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU47CgkJZWxzZSBpZiAoc3RhdHVzX2Zvcm1hdCA9PSBTVEFUVVNfRk9STUFUX0xPTkcpCgkJCWRpZShfKCItLWxvbmcgYW5kIC16IGFyZSBpbmNvbXBhdGlibGUiKSk7Cgl9CgoJaWYgKHVzZV9kZWZlcnJlZF9jb25maWcgJiYgc3RhdHVzX2Zvcm1hdCA9PSBTVEFUVVNfRk9STUFUX1VOU1BFQ0lGSUVEKQoJCXN0YXR1c19mb3JtYXQgPSBzdGF0dXNfZGVmZXJyZWRfY29uZmlnLnN0YXR1c19mb3JtYXQ7CglpZiAoc3RhdHVzX2Zvcm1hdCA9PSBTVEFUVVNfRk9STUFUX1VOU1BFQ0lGSUVEKQoJCXN0YXR1c19mb3JtYXQgPSBTVEFUVVNfRk9STUFUX05PTkU7CgoJaWYgKHVzZV9kZWZlcnJlZF9jb25maWcgJiYgcy0+c2hvd19icmFuY2ggPCAwKQoJCXMtPnNob3dfYnJhbmNoID0gc3RhdHVzX2RlZmVycmVkX2NvbmZpZy5zaG93X2JyYW5jaDsKCWlmIChzLT5zaG93X2JyYW5jaCA8IDApCgkJcy0+c2hvd19icmFuY2ggPSAwOwoKCS8qCgkgKiBJZiB0aGUgdXNlciBkaWQgbm90IGdpdmUgYSAiLS1bbm9dLWFoZWFkLWJlaGluZCIgY29tbWFuZAoJICogbGluZSBhcmd1bWVudCAqQU5EKiB3ZSB3aWxsIHByaW50IGluIGEgaHVtYW4tcmVhZGFibGUgZm9ybWF0CgkgKiAoc2hvcnQsIGxvbmcgZXRjLikgdGhlbiB3ZSBpbmhlcml0IGZyb20gdGhlIHN0YXR1cy5haGVhZGJlaGluZAoJICogY29uZmlnIHNldHRpbmcuICBJbiBhbGwgb3RoZXIgY2FzZXMgKGFuZCBwb3JjZWxhaW4gVlsxMl0gZm9ybWF0cwoJICogaW4gcGFydGljdWxhciksIHdlIGluaGVyaXQgX0ZVTEwgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LgoJICovCglpZiAodXNlX2RlZmVycmVkX2NvbmZpZyAmJgoJICAgIHMtPmFoZWFkX2JlaGluZF9mbGFncyA9PSBBSEVBRF9CRUhJTkRfVU5TUEVDSUZJRUQpCgkJcy0+YWhlYWRfYmVoaW5kX2ZsYWdzID0gc3RhdHVzX2RlZmVycmVkX2NvbmZpZy5haGVhZF9iZWhpbmQ7CgoJaWYgKHMtPmFoZWFkX2JlaGluZF9mbGFncyA9PSBBSEVBRF9CRUhJTkRfVU5TUEVDSUZJRUQpCgkJcy0+YWhlYWRfYmVoaW5kX2ZsYWdzID0gQUhFQURfQkVISU5EX0ZVTEw7Cn0KCnN0YXRpYyBpbnQgcGFyc2VfYW5kX3ZhbGlkYXRlX29wdGlvbnMoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKmFyZ3ZbXSwKCQkJCSAgICAgIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdGlvbnMsCgkJCQkgICAgICBjb25zdCBjaGFyICogY29uc3QgdXNhZ2VbXSwKCQkJCSAgICAgIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJCSAgICAgIHN0cnVjdCBjb21taXQgKmN1cnJlbnRfaGVhZCwKCQkJCSAgICAgIHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWludCBmID0gMDsKCglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIG9wdGlvbnMsIHVzYWdlLCAwKTsKCWZpbmFsaXplX2RlZmVycmVkX2NvbmZpZyhzKTsKCglpZiAoZm9yY2VfYXV0aG9yICYmICFzdHJjaHIoZm9yY2VfYXV0aG9yLCAnPicpKQoJCWZvcmNlX2F1dGhvciA9IGZpbmRfYXV0aG9yX2J5X25pY2tuYW1lKGZvcmNlX2F1dGhvcik7CgoJaWYgKGZvcmNlX2F1dGhvciAmJiByZW5ld19hdXRob3JzaGlwKQoJCWRpZShfKCJVc2luZyBib3RoIC0tcmVzZXQtYXV0aG9yIGFuZCAtLWF1dGhvciBkb2VzIG5vdCBtYWtlIHNlbnNlIikpOwoKCWlmIChsb2dmaWxlIHx8IGhhdmVfb3B0aW9uX20gfHwgdXNlX21lc3NhZ2UgfHwgZml4dXBfbWVzc2FnZSkKCQl1c2VfZWRpdG9yID0gMDsKCWlmICgwIDw9IGVkaXRfZmxhZykKCQl1c2VfZWRpdG9yID0gZWRpdF9mbGFnOwoKCS8qIFNhbml0eSBjaGVjayBvcHRpb25zICovCglpZiAoYW1lbmQgJiYgIWN1cnJlbnRfaGVhZCkKCQlkaWUoXygiWW91IGhhdmUgbm90aGluZyB0byBhbWVuZC4iKSk7CglpZiAoYW1lbmQgJiYgd2hlbmNlICE9IEZST01fQ09NTUlUKSB7CgkJaWYgKHdoZW5jZSA9PSBGUk9NX01FUkdFKQoJCQlkaWUoXygiWW91IGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgbWVyZ2UgLS0gY2Fubm90IGFtZW5kLiIpKTsKCQllbHNlIGlmICh3aGVuY2UgPT0gRlJPTV9DSEVSUllfUElDSykKCQkJZGllKF8oIllvdSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBhIGNoZXJyeS1waWNrIC0tIGNhbm5vdCBhbWVuZC4iKSk7Cgl9CglpZiAoZml4dXBfbWVzc2FnZSAmJiBzcXVhc2hfbWVzc2FnZSkKCQlkaWUoXygiT3B0aW9ucyAtLXNxdWFzaCBhbmQgLS1maXh1cCBjYW5ub3QgYmUgdXNlZCB0b2dldGhlciIpKTsKCWlmICh1c2VfbWVzc2FnZSkKCQlmKys7CglpZiAoZWRpdF9tZXNzYWdlKQoJCWYrKzsKCWlmIChmaXh1cF9tZXNzYWdlKQoJCWYrKzsKCWlmIChsb2dmaWxlKQoJCWYrKzsKCWlmIChmID4gMSkKCQlkaWUoXygiT25seSBvbmUgb2YgLWMvLUMvLUYvLS1maXh1cCBjYW4gYmUgdXNlZC4iKSk7CglpZiAoaGF2ZV9vcHRpb25fbSAmJiAoZWRpdF9tZXNzYWdlIHx8IHVzZV9tZXNzYWdlIHx8IGxvZ2ZpbGUpKQoJCWRpZSgoXygiT3B0aW9uIC1tIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIC1jLy1DLy1GLiIpKSk7CglpZiAoZiB8fCBoYXZlX29wdGlvbl9tKQoJCXRlbXBsYXRlX2ZpbGUgPSBOVUxMOwoJaWYgKGVkaXRfbWVzc2FnZSkKCQl1c2VfbWVzc2FnZSA9IGVkaXRfbWVzc2FnZTsKCWlmIChhbWVuZCAmJiAhdXNlX21lc3NhZ2UgJiYgIWZpeHVwX21lc3NhZ2UpCgkJdXNlX21lc3NhZ2UgPSAiSEVBRCI7CglpZiAoIXVzZV9tZXNzYWdlICYmIHdoZW5jZSAhPSBGUk9NX0NIRVJSWV9QSUNLICYmIHJlbmV3X2F1dGhvcnNoaXApCgkJZGllKF8oIi0tcmVzZXQtYXV0aG9yIGNhbiBiZSB1c2VkIG9ubHkgd2l0aCAtQywgLWMgb3IgLS1hbWVuZC4iKSk7CglpZiAodXNlX21lc3NhZ2UpIHsKCQl1c2VfbWVzc2FnZV9idWZmZXIgPSByZWFkX2NvbW1pdF9tZXNzYWdlKHVzZV9tZXNzYWdlKTsKCQlpZiAoIXJlbmV3X2F1dGhvcnNoaXApIHsKCQkJYXV0aG9yX21lc3NhZ2UgPSB1c2VfbWVzc2FnZTsKCQkJYXV0aG9yX21lc3NhZ2VfYnVmZmVyID0gdXNlX21lc3NhZ2VfYnVmZmVyOwoJCX0KCX0KCWlmICh3aGVuY2UgPT0gRlJPTV9DSEVSUllfUElDSyAmJiAhcmVuZXdfYXV0aG9yc2hpcCkgewoJCWF1dGhvcl9tZXNzYWdlID0gIkNIRVJSWV9QSUNLX0hFQUQiOwoJCWF1dGhvcl9tZXNzYWdlX2J1ZmZlciA9IHJlYWRfY29tbWl0X21lc3NhZ2UoYXV0aG9yX21lc3NhZ2UpOwoJfQoKCWlmIChwYXRjaF9pbnRlcmFjdGl2ZSkKCQlpbnRlcmFjdGl2ZSA9IDE7CgoJaWYgKGFsc28gKyBvbmx5ICsgYWxsICsgaW50ZXJhY3RpdmUgPiAxKQoJCWRpZShfKCJPbmx5IG9uZSBvZiAtLWluY2x1ZGUvLS1vbmx5Ly0tYWxsLy0taW50ZXJhY3RpdmUvLS1wYXRjaCBjYW4gYmUgdXNlZC4iKSk7CglpZiAoYXJnYyA9PSAwICYmIChhbHNvIHx8IChvbmx5ICYmICFhbWVuZCAmJiAhYWxsb3dfZW1wdHkpKSkKCQlkaWUoXygiTm8gcGF0aHMgd2l0aCAtLWluY2x1ZGUvLS1vbmx5IGRvZXMgbm90IG1ha2Ugc2Vuc2UuIikpOwoJY2xlYW51cF9tb2RlID0gZ2V0X2NsZWFudXBfbW9kZShjbGVhbnVwX2FyZywgdXNlX2VkaXRvcik7CgoJaGFuZGxlX3VudHJhY2tlZF9maWxlc19hcmcocyk7CgoJaWYgKGFsbCAmJiBhcmdjID4gMCkKCQlkaWUoXygicGF0aHMgJyVzIC4uLicgd2l0aCAtYSBkb2VzIG5vdCBtYWtlIHNlbnNlIiksCgkJICAgIGFyZ3ZbMF0pOwoKCWlmIChzdGF0dXNfZm9ybWF0ICE9IFNUQVRVU19GT1JNQVRfTk9ORSkKCQlkcnlfcnVuID0gMTsKCglyZXR1cm4gYXJnYzsKfQoKc3RhdGljIGludCBkcnlfcnVuX2NvbW1pdChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJICBjb25zdCBzdHJ1Y3QgY29tbWl0ICpjdXJyZW50X2hlYWQsIHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWludCBjb21taXR0YWJsZTsKCWNvbnN0IGNoYXIgKmluZGV4X2ZpbGU7CgoJaW5kZXhfZmlsZSA9IHByZXBhcmVfaW5kZXgoYXJnYywgYXJndiwgcHJlZml4LCBjdXJyZW50X2hlYWQsIDEpOwoJY29tbWl0dGFibGUgPSBydW5fc3RhdHVzKHN0ZG91dCwgaW5kZXhfZmlsZSwgcHJlZml4LCAwLCBzKTsKCXJvbGxiYWNrX2luZGV4X2ZpbGVzKCk7CgoJcmV0dXJuIGNvbW1pdHRhYmxlID8gMCA6IDE7Cn0KCmRlZmluZV9saXN0X2NvbmZpZ19hcnJheV9leHRyYShjb2xvcl9zdGF0dXNfc2xvdHMsIHsiYWRkZWQifSk7CgpzdGF0aWMgaW50IHBhcnNlX3N0YXR1c19zbG90KGNvbnN0IGNoYXIgKnNsb3QpCnsKCWlmICghc3RyY2FzZWNtcChzbG90LCAiYWRkZWQiKSkKCQlyZXR1cm4gV1RfU1RBVFVTX1VQREFURUQ7CgoJcmV0dXJuIExPT0tVUF9DT05GSUcoY29sb3Jfc3RhdHVzX3Nsb3RzLCBzbG90KTsKfQoKc3RhdGljIGludCBnaXRfc3RhdHVzX2NvbmZpZyhjb25zdCBjaGFyICprLCBjb25zdCBjaGFyICp2LCB2b2lkICpjYikKewoJc3RydWN0IHd0X3N0YXR1cyAqcyA9IGNiOwoJY29uc3QgY2hhciAqc2xvdF9uYW1lOwoKCWlmIChzdGFydHNfd2l0aChrLCAiY29sdW1uLiIpKQoJCXJldHVybiBnaXRfY29sdW1uX2NvbmZpZyhrLCB2LCAic3RhdHVzIiwgJnMtPmNvbG9wdHMpOwoJaWYgKCFzdHJjbXAoaywgInN0YXR1cy5zdWJtb2R1bGVzdW1tYXJ5IikpIHsKCQlpbnQgaXNfYm9vbDsKCQlzLT5zdWJtb2R1bGVfc3VtbWFyeSA9IGdpdF9jb25maWdfYm9vbF9vcl9pbnQoaywgdiwgJmlzX2Jvb2wpOwoJCWlmIChpc19ib29sICYmIHMtPnN1Ym1vZHVsZV9zdW1tYXJ5KQoJCQlzLT5zdWJtb2R1bGVfc3VtbWFyeSA9IC0xOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaywgInN0YXR1cy5zaG9ydCIpKSB7CgkJaWYgKGdpdF9jb25maWdfYm9vbChrLCB2KSkKCQkJc3RhdHVzX2RlZmVycmVkX2NvbmZpZy5zdGF0dXNfZm9ybWF0ID0gU1RBVFVTX0ZPUk1BVF9TSE9SVDsKCQllbHNlCgkJCXN0YXR1c19kZWZlcnJlZF9jb25maWcuc3RhdHVzX2Zvcm1hdCA9IFNUQVRVU19GT1JNQVRfTk9ORTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMuYnJhbmNoIikpIHsKCQlzdGF0dXNfZGVmZXJyZWRfY29uZmlnLnNob3dfYnJhbmNoID0gZ2l0X2NvbmZpZ19ib29sKGssIHYpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaywgInN0YXR1cy5haGVhZGJlaGluZCIpKSB7CgkJc3RhdHVzX2RlZmVycmVkX2NvbmZpZy5haGVhZF9iZWhpbmQgPSBnaXRfY29uZmlnX2Jvb2woaywgdik7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAic3RhdHVzLnNob3dzdGFzaCIpKSB7CgkJcy0+c2hvd19zdGFzaCA9IGdpdF9jb25maWdfYm9vbChrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMuY29sb3IiKSB8fCAhc3RyY21wKGssICJjb2xvci5zdGF0dXMiKSkgewoJCXMtPnVzZV9jb2xvciA9IGdpdF9jb25maWdfY29sb3Jib29sKGssIHYpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaywgInN0YXR1cy5kaXNwbGF5Y29tbWVudHByZWZpeCIpKSB7CgkJcy0+ZGlzcGxheV9jb21tZW50X3ByZWZpeCA9IGdpdF9jb25maWdfYm9vbChrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmIChza2lwX3ByZWZpeChrLCAic3RhdHVzLmNvbG9yLiIsICZzbG90X25hbWUpIHx8CgkgICAgc2tpcF9wcmVmaXgoaywgImNvbG9yLnN0YXR1cy4iLCAmc2xvdF9uYW1lKSkgewoJCWludCBzbG90ID0gcGFyc2Vfc3RhdHVzX3Nsb3Qoc2xvdF9uYW1lKTsKCQlpZiAoc2xvdCA8IDApCgkJCXJldHVybiAwOwoJCWlmICghdikKCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKGspOwoJCXJldHVybiBjb2xvcl9wYXJzZSh2LCBzLT5jb2xvcl9wYWxldHRlW3Nsb3RdKTsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMucmVsYXRpdmVwYXRocyIpKSB7CgkJcy0+cmVsYXRpdmVfcGF0aHMgPSBnaXRfY29uZmlnX2Jvb2woaywgdik7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAic3RhdHVzLnNob3d1bnRyYWNrZWRmaWxlcyIpKSB7CgkJaWYgKCF2KQoJCQlyZXR1cm4gY29uZmlnX2Vycm9yX25vbmJvb2woayk7CgkJZWxzZSBpZiAoIXN0cmNtcCh2LCAibm8iKSkKCQkJcy0+c2hvd191bnRyYWNrZWRfZmlsZXMgPSBTSE9XX05PX1VOVFJBQ0tFRF9GSUxFUzsKCQllbHNlIGlmICghc3RyY21wKHYsICJub3JtYWwiKSkKCQkJcy0+c2hvd191bnRyYWNrZWRfZmlsZXMgPSBTSE9XX05PUk1BTF9VTlRSQUNLRURfRklMRVM7CgkJZWxzZSBpZiAoIXN0cmNtcCh2LCAiYWxsIikpCgkJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19BTExfVU5UUkFDS0VEX0ZJTEVTOwoJCWVsc2UKCQkJcmV0dXJuIGVycm9yKF8oIkludmFsaWQgdW50cmFja2VkIGZpbGVzIG1vZGUgJyVzJyIpLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJkaWZmLnJlbmFtZWxpbWl0IikpIHsKCQlpZiAocy0+cmVuYW1lX2xpbWl0ID09IC0xKQoJCQlzLT5yZW5hbWVfbGltaXQgPSBnaXRfY29uZmlnX2ludChrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMucmVuYW1lbGltaXQiKSkgewoJCXMtPnJlbmFtZV9saW1pdCA9IGdpdF9jb25maWdfaW50KGssIHYpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaywgImRpZmYucmVuYW1lcyIpKSB7CgkJaWYgKHMtPmRldGVjdF9yZW5hbWUgPT0gLTEpCgkJCXMtPmRldGVjdF9yZW5hbWUgPSBnaXRfY29uZmlnX3JlbmFtZShrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMucmVuYW1lcyIpKSB7CgkJcy0+ZGV0ZWN0X3JlbmFtZSA9IGdpdF9jb25maWdfcmVuYW1lKGssIHYpOwoJCXJldHVybiAwOwoJfQoJcmV0dXJuIGdpdF9kaWZmX3VpX2NvbmZpZyhrLCB2LCBOVUxMKTsKfQoKaW50IGNtZF9zdGF0dXMoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0YXRpYyBpbnQgbm9fcmVuYW1lcyA9IC0xOwoJc3RhdGljIGNvbnN0IGNoYXIgKnJlbmFtZV9zY29yZV9hcmcgPSAoY29uc3QgY2hhciAqKS0xOwoJc3RhdGljIHN0cnVjdCB3dF9zdGF0dXMgczsKCXVuc2lnbmVkIGludCBwcm9ncmVzc19mbGFnID0gMDsKCWludCBmZDsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJc3RhdGljIHN0cnVjdCBvcHRpb24gYnVpbHRpbl9zdGF0dXNfb3B0aW9uc1tdID0gewoJCU9QVF9fVkVSQk9TRSgmdmVyYm9zZSwgTl8oImJlIHZlcmJvc2UiKSksCgkJT1BUX1NFVF9JTlQoJ3MnLCAic2hvcnQiLCAmc3RhdHVzX2Zvcm1hdCwKCQkJICAgIE5fKCJzaG93IHN0YXR1cyBjb25jaXNlbHkiKSwgU1RBVFVTX0ZPUk1BVF9TSE9SVCksCgkJT1BUX0JPT0woJ2InLCAiYnJhbmNoIiwgJnMuc2hvd19icmFuY2gsCgkJCSBOXygic2hvdyBicmFuY2ggaW5mb3JtYXRpb24iKSksCgkJT1BUX0JPT0woMCwgInNob3ctc3Rhc2giLCAmcy5zaG93X3N0YXNoLAoJCQkgTl8oInNob3cgc3Rhc2ggaW5mb3JtYXRpb24iKSksCgkJT1BUX0JPT0woMCwgImFoZWFkLWJlaGluZCIsICZzLmFoZWFkX2JlaGluZF9mbGFncywKCQkJIE5fKCJjb21wdXRlIGZ1bGwgYWhlYWQvYmVoaW5kIHZhbHVlcyIpKSwKCQl7IE9QVElPTl9DQUxMQkFDSywgMCwgInBvcmNlbGFpbiIsICZzdGF0dXNfZm9ybWF0LAoJCSAgTl8oInZlcnNpb24iKSwgTl8oIm1hY2hpbmUtcmVhZGFibGUgb3V0cHV0IiksCgkJICBQQVJTRV9PUFRfT1BUQVJHLCBvcHRfcGFyc2VfcG9yY2VsYWluIH0sCgkJT1BUX1NFVF9JTlQoMCwgImxvbmciLCAmc3RhdHVzX2Zvcm1hdCwKCQkJICAgIE5fKCJzaG93IHN0YXR1cyBpbiBsb25nIGZvcm1hdCAoZGVmYXVsdCkiKSwKCQkJICAgIFNUQVRVU19GT1JNQVRfTE9ORyksCgkJT1BUX0JPT0woJ3onLCAibnVsbCIsICZzLm51bGxfdGVybWluYXRpb24sCgkJCSBOXygidGVybWluYXRlIGVudHJpZXMgd2l0aCBOVUwiKSksCgkJeyBPUFRJT05fU1RSSU5HLCAndScsICJ1bnRyYWNrZWQtZmlsZXMiLCAmdW50cmFja2VkX2ZpbGVzX2FyZywKCQkgIE5fKCJtb2RlIiksCgkJICBOXygic2hvdyB1bnRyYWNrZWQgZmlsZXMsIG9wdGlvbmFsIG1vZGVzOiBhbGwsIG5vcm1hbCwgbm8uIChEZWZhdWx0OiBhbGwpIiksCgkJICBQQVJTRV9PUFRfT1BUQVJHLCBOVUxMLCAoaW50cHRyX3QpImFsbCIgfSwKCQl7IE9QVElPTl9TVFJJTkcsIDAsICJpZ25vcmVkIiwgJmlnbm9yZWRfYXJnLAoJCSAgTl8oIm1vZGUiKSwKCQkgIE5fKCJzaG93IGlnbm9yZWQgZmlsZXMsIG9wdGlvbmFsIG1vZGVzOiB0cmFkaXRpb25hbCwgbWF0Y2hpbmcsIG5vLiAoRGVmYXVsdDogdHJhZGl0aW9uYWwpIiksCgkJICBQQVJTRV9PUFRfT1BUQVJHLCBOVUxMLCAoaW50cHRyX3QpInRyYWRpdGlvbmFsIiB9LAoJCXsgT1BUSU9OX1NUUklORywgMCwgImlnbm9yZS1zdWJtb2R1bGVzIiwgJmlnbm9yZV9zdWJtb2R1bGVfYXJnLCBOXygid2hlbiIpLAoJCSAgTl8oImlnbm9yZSBjaGFuZ2VzIHRvIHN1Ym1vZHVsZXMsIG9wdGlvbmFsIHdoZW46IGFsbCwgZGlydHksIHVudHJhY2tlZC4gKERlZmF1bHQ6IGFsbCkiKSwKCQkgIFBBUlNFX09QVF9PUFRBUkcsIE5VTEwsIChpbnRwdHJfdCkiYWxsIiB9LAoJCU9QVF9DT0xVTU4oMCwgImNvbHVtbiIsICZzLmNvbG9wdHMsIE5fKCJsaXN0IHVudHJhY2tlZCBmaWxlcyBpbiBjb2x1bW5zIikpLAoJCU9QVF9CT09MKDAsICJuby1yZW5hbWVzIiwgJm5vX3JlbmFtZXMsIE5fKCJkbyBub3QgZGV0ZWN0IHJlbmFtZXMiKSksCgkJeyBPUFRJT05fQ0FMTEJBQ0ssICdNJywgImZpbmQtcmVuYW1lcyIsICZyZW5hbWVfc2NvcmVfYXJnLAoJCSAgTl8oIm4iKSwgTl8oImRldGVjdCByZW5hbWVzLCBvcHRpb25hbGx5IHNldCBzaW1pbGFyaXR5IGluZGV4IiksCgkJICBQQVJTRV9PUFRfT1BUQVJHIHwgUEFSU0VfT1BUX05PTkVHLCBvcHRfcGFyc2VfcmVuYW1lX3Njb3JlIH0sCgkJT1BUX0VORCgpLAoJfTsKCglpZiAoYXJnYyA9PSAyICYmICFzdHJjbXAoYXJndlsxXSwgIi1oIikpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGJ1aWx0aW5fc3RhdHVzX3VzYWdlLCBidWlsdGluX3N0YXR1c19vcHRpb25zKTsKCglzdGF0dXNfaW5pdF9jb25maWcoJnMsIGdpdF9zdGF0dXNfY29uZmlnKTsKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwKCQkJICAgICBidWlsdGluX3N0YXR1c19vcHRpb25zLAoJCQkgICAgIGJ1aWx0aW5fc3RhdHVzX3VzYWdlLCAwKTsKCWZpbmFsaXplX2NvbG9wdHMoJnMuY29sb3B0cywgLTEpOwoJZmluYWxpemVfZGVmZXJyZWRfY29uZmlnKCZzKTsKCgloYW5kbGVfdW50cmFja2VkX2ZpbGVzX2FyZygmcyk7CgloYW5kbGVfaWdub3JlZF9hcmcoJnMpOwoKCWlmIChzLnNob3dfaWdub3JlZF9tb2RlID09IFNIT1dfTUFUQ0hJTkdfSUdOT1JFRCAmJgoJICAgIHMuc2hvd191bnRyYWNrZWRfZmlsZXMgPT0gU0hPV19OT19VTlRSQUNLRURfRklMRVMpCgkJZGllKF8oIlVuc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIGlnbm9yZWQgYW5kIHVudHJhY2tlZC1maWxlcyBhcmd1bWVudHMiKSk7CgoJcGFyc2VfcGF0aHNwZWMoJnMucGF0aHNwZWMsIDAsCgkJICAgICAgIFBBVEhTUEVDX1BSRUZFUl9GVUxMLAoJCSAgICAgICBwcmVmaXgsIGFyZ3YpOwoKCWlmIChzdGF0dXNfZm9ybWF0ICE9IFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOICYmCgkgICAgc3RhdHVzX2Zvcm1hdCAhPSBTVEFUVVNfRk9STUFUX1BPUkNFTEFJTl9WMikKCQlwcm9ncmVzc19mbGFnID0gUkVGUkVTSF9QUk9HUkVTUzsKCXJlcG9fcmVhZF9pbmRleCh0aGVfcmVwb3NpdG9yeSk7CglyZWZyZXNoX2luZGV4KCZ0aGVfaW5kZXgsCgkJICAgICAgUkVGUkVTSF9RVUlFVHxSRUZSRVNIX1VOTUVSR0VEfHByb2dyZXNzX2ZsYWcsCgkJICAgICAgJnMucGF0aHNwZWMsIE5VTEwsIE5VTEwpOwoKCWlmICh1c2Vfb3B0aW9uYWxfbG9ja3MoKSkKCQlmZCA9IGhvbGRfbG9ja2VkX2luZGV4KCZpbmRleF9sb2NrLCAwKTsKCWVsc2UKCQlmZCA9IC0xOwoKCXMuaXNfaW5pdGlhbCA9IGdldF9vaWQocy5yZWZlcmVuY2UsICZvaWQpID8gMSA6IDA7CglpZiAoIXMuaXNfaW5pdGlhbCkKCQlvaWRjcHkoJnMub2lkX2NvbW1pdCwgJm9pZCk7CgoJcy5pZ25vcmVfc3VibW9kdWxlX2FyZyA9IGlnbm9yZV9zdWJtb2R1bGVfYXJnOwoJcy5zdGF0dXNfZm9ybWF0ID0gc3RhdHVzX2Zvcm1hdDsKCXMudmVyYm9zZSA9IHZlcmJvc2U7CglpZiAobm9fcmVuYW1lcyAhPSAtMSkKCQlzLmRldGVjdF9yZW5hbWUgPSAhbm9fcmVuYW1lczsKCWlmICgoaW50cHRyX3QpcmVuYW1lX3Njb3JlX2FyZyAhPSAtMSkgewoJCWlmIChzLmRldGVjdF9yZW5hbWUgPCBESUZGX0RFVEVDVF9SRU5BTUUpCgkJCXMuZGV0ZWN0X3JlbmFtZSA9IERJRkZfREVURUNUX1JFTkFNRTsKCQlpZiAocmVuYW1lX3Njb3JlX2FyZykKCQkJcy5yZW5hbWVfc2NvcmUgPSBwYXJzZV9yZW5hbWVfc2NvcmUoJnJlbmFtZV9zY29yZV9hcmcpOwoJfQoKCXd0X3N0YXR1c19jb2xsZWN0KCZzKTsKCglpZiAoMCA8PSBmZCkKCQlyZXBvX3VwZGF0ZV9pbmRleF9pZl9hYmxlKHRoZV9yZXBvc2l0b3J5LCAmaW5kZXhfbG9jayk7CgoJaWYgKHMucmVsYXRpdmVfcGF0aHMpCgkJcy5wcmVmaXggPSBwcmVmaXg7CgoJd3Rfc3RhdHVzX3ByaW50KCZzKTsKCXd0X3N0YXR1c19jb2xsZWN0X2ZyZWVfYnVmZmVycygmcyk7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZ2l0X2NvbW1pdF9jb25maWcoY29uc3QgY2hhciAqaywgY29uc3QgY2hhciAqdiwgdm9pZCAqY2IpCnsKCXN0cnVjdCB3dF9zdGF0dXMgKnMgPSBjYjsKCWludCBzdGF0dXM7CgoJaWYgKCFzdHJjbXAoaywgImNvbW1pdC50ZW1wbGF0ZSIpKQoJCXJldHVybiBnaXRfY29uZmlnX3BhdGhuYW1lKCZ0ZW1wbGF0ZV9maWxlLCBrLCB2KTsKCWlmICghc3RyY21wKGssICJjb21taXQuc3RhdHVzIikpIHsKCQlpbmNsdWRlX3N0YXR1cyA9IGdpdF9jb25maWdfYm9vbChrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJjb21taXQuY2xlYW51cCIpKQoJCXJldHVybiBnaXRfY29uZmlnX3N0cmluZygmY2xlYW51cF9hcmcsIGssIHYpOwoJaWYgKCFzdHJjbXAoaywgImNvbW1pdC5ncGdzaWduIikpIHsKCQlzaWduX2NvbW1pdCA9IGdpdF9jb25maWdfYm9vbChrLCB2KSA/ICIiIDogTlVMTDsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJjb21taXQudmVyYm9zZSIpKSB7CgkJaW50IGlzX2Jvb2w7CgkJY29uZmlnX2NvbW1pdF92ZXJib3NlID0gZ2l0X2NvbmZpZ19ib29sX29yX2ludChrLCB2LCAmaXNfYm9vbCk7CgkJcmV0dXJuIDA7Cgl9CgoJc3RhdHVzID0gZ2l0X2dwZ19jb25maWcoaywgdiwgTlVMTCk7CglpZiAoc3RhdHVzKQoJCXJldHVybiBzdGF0dXM7CglyZXR1cm4gZ2l0X3N0YXR1c19jb25maWcoaywgdiwgcyk7Cn0KCmludCBydW5fY29tbWl0X2hvb2soaW50IGVkaXRvcl9pc191c2VkLCBjb25zdCBjaGFyICppbmRleF9maWxlLCBjb25zdCBjaGFyICpuYW1lLCAuLi4pCnsKCXN0cnVjdCBhcmd2X2FycmF5IGhvb2tfZW52ID0gQVJHVl9BUlJBWV9JTklUOwoJdmFfbGlzdCBhcmdzOwoJaW50IHJldDsKCglhcmd2X2FycmF5X3B1c2hmKCZob29rX2VudiwgIkdJVF9JTkRFWF9GSUxFPSVzIiwgaW5kZXhfZmlsZSk7CgoJLyoKCSAqIExldCB0aGUgaG9vayBrbm93IHRoYXQgbm8gZWRpdG9yIHdpbGwgYmUgbGF1bmNoZWQuCgkgKi8KCWlmICghZWRpdG9yX2lzX3VzZWQpCgkJYXJndl9hcnJheV9wdXNoKCZob29rX2VudiwgIkdJVF9FRElUT1I9OiIpOwoKCXZhX3N0YXJ0KGFyZ3MsIG5hbWUpOwoJcmV0ID0gcnVuX2hvb2tfdmUoaG9va19lbnYuYXJndixuYW1lLCBhcmdzKTsKCXZhX2VuZChhcmdzKTsKCWFyZ3ZfYXJyYXlfY2xlYXIoJmhvb2tfZW52KTsKCglyZXR1cm4gcmV0Owp9CgppbnQgY21kX2NvbW1pdChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJY29uc3QgY2hhciAqYXJndl9nY19hdXRvW10gPSB7ImdjIiwgIi0tYXV0byIsIE5VTEx9OwoJc3RhdGljIHN0cnVjdCB3dF9zdGF0dXMgczsKCXN0YXRpYyBzdHJ1Y3Qgb3B0aW9uIGJ1aWx0aW5fY29tbWl0X29wdGlvbnNbXSA9IHsKCQlPUFRfX1FVSUVUKCZxdWlldCwgTl8oInN1cHByZXNzIHN1bW1hcnkgYWZ0ZXIgc3VjY2Vzc2Z1bCBjb21taXQiKSksCgkJT1BUX19WRVJCT1NFKCZ2ZXJib3NlLCBOXygic2hvdyBkaWZmIGluIGNvbW1pdCBtZXNzYWdlIHRlbXBsYXRlIikpLAoKCQlPUFRfR1JPVVAoTl8oIkNvbW1pdCBtZXNzYWdlIG9wdGlvbnMiKSksCgkJT1BUX0ZJTEVOQU1FKCdGJywgImZpbGUiLCAmbG9nZmlsZSwgTl8oInJlYWQgbWVzc2FnZSBmcm9tIGZpbGUiKSksCgkJT1BUX1NUUklORygwLCAiYXV0aG9yIiwgJmZvcmNlX2F1dGhvciwgTl8oImF1dGhvciIpLCBOXygib3ZlcnJpZGUgYXV0aG9yIGZvciBjb21taXQiKSksCgkJT1BUX1NUUklORygwLCAiZGF0ZSIsICZmb3JjZV9kYXRlLCBOXygiZGF0ZSIpLCBOXygib3ZlcnJpZGUgZGF0ZSBmb3IgY29tbWl0IikpLAoJCU9QVF9DQUxMQkFDSygnbScsICJtZXNzYWdlIiwgJm1lc3NhZ2UsIE5fKCJtZXNzYWdlIiksIE5fKCJjb21taXQgbWVzc2FnZSIpLCBvcHRfcGFyc2VfbSksCgkJT1BUX1NUUklORygnYycsICJyZWVkaXQtbWVzc2FnZSIsICZlZGl0X21lc3NhZ2UsIE5fKCJjb21taXQiKSwgTl8oInJldXNlIGFuZCBlZGl0IG1lc3NhZ2UgZnJvbSBzcGVjaWZpZWQgY29tbWl0IikpLAoJCU9QVF9TVFJJTkcoJ0MnLCAicmV1c2UtbWVzc2FnZSIsICZ1c2VfbWVzc2FnZSwgTl8oImNvbW1pdCIpLCBOXygicmV1c2UgbWVzc2FnZSBmcm9tIHNwZWNpZmllZCBjb21taXQiKSksCgkJT1BUX1NUUklORygwLCAiZml4dXAiLCAmZml4dXBfbWVzc2FnZSwgTl8oImNvbW1pdCIpLCBOXygidXNlIGF1dG9zcXVhc2ggZm9ybWF0dGVkIG1lc3NhZ2UgdG8gZml4dXAgc3BlY2lmaWVkIGNvbW1pdCIpKSwKCQlPUFRfU1RSSU5HKDAsICJzcXVhc2giLCAmc3F1YXNoX21lc3NhZ2UsIE5fKCJjb21taXQiKSwgTl8oInVzZSBhdXRvc3F1YXNoIGZvcm1hdHRlZCBtZXNzYWdlIHRvIHNxdWFzaCBzcGVjaWZpZWQgY29tbWl0IikpLAoJCU9QVF9CT09MKDAsICJyZXNldC1hdXRob3IiLCAmcmVuZXdfYXV0aG9yc2hpcCwgTl8oInRoZSBjb21taXQgaXMgYXV0aG9yZWQgYnkgbWUgbm93ICh1c2VkIHdpdGggLUMvLWMvLS1hbWVuZCkiKSksCgkJT1BUX0JPT0woJ3MnLCAic2lnbm9mZiIsICZzaWdub2ZmLCBOXygiYWRkIFNpZ25lZC1vZmYtYnk6IikpLAoJCU9QVF9GSUxFTkFNRSgndCcsICJ0ZW1wbGF0ZSIsICZ0ZW1wbGF0ZV9maWxlLCBOXygidXNlIHNwZWNpZmllZCB0ZW1wbGF0ZSBmaWxlIikpLAoJCU9QVF9CT09MKCdlJywgImVkaXQiLCAmZWRpdF9mbGFnLCBOXygiZm9yY2UgZWRpdCBvZiBjb21taXQiKSksCgkJT1BUX0NMRUFOVVAoJmNsZWFudXBfYXJnKSwKCQlPUFRfQk9PTCgwLCAic3RhdHVzIiwgJmluY2x1ZGVfc3RhdHVzLCBOXygiaW5jbHVkZSBzdGF0dXMgaW4gY29tbWl0IG1lc3NhZ2UgdGVtcGxhdGUiKSksCgkJeyBPUFRJT05fU1RSSU5HLCAnUycsICJncGctc2lnbiIsICZzaWduX2NvbW1pdCwgTl8oImtleS1pZCIpLAoJCSAgTl8oIkdQRyBzaWduIGNvbW1pdCIpLCBQQVJTRV9PUFRfT1BUQVJHLCBOVUxMLCAoaW50cHRyX3QpICIiIH0sCgkJLyogZW5kIGNvbW1pdCBtZXNzYWdlIG9wdGlvbnMgKi8KCgkJT1BUX0dST1VQKE5fKCJDb21taXQgY29udGVudHMgb3B0aW9ucyIpKSwKCQlPUFRfQk9PTCgnYScsICJhbGwiLCAmYWxsLCBOXygiY29tbWl0IGFsbCBjaGFuZ2VkIGZpbGVzIikpLAoJCU9QVF9CT09MKCdpJywgImluY2x1ZGUiLCAmYWxzbywgTl8oImFkZCBzcGVjaWZpZWQgZmlsZXMgdG8gaW5kZXggZm9yIGNvbW1pdCIpKSwKCQlPUFRfQk9PTCgwLCAiaW50ZXJhY3RpdmUiLCAmaW50ZXJhY3RpdmUsIE5fKCJpbnRlcmFjdGl2ZWx5IGFkZCBmaWxlcyIpKSwKCQlPUFRfQk9PTCgncCcsICJwYXRjaCIsICZwYXRjaF9pbnRlcmFjdGl2ZSwgTl8oImludGVyYWN0aXZlbHkgYWRkIGNoYW5nZXMiKSksCgkJT1BUX0JPT0woJ28nLCAib25seSIsICZvbmx5LCBOXygiY29tbWl0IG9ubHkgc3BlY2lmaWVkIGZpbGVzIikpLAoJCU9QVF9CT09MKCduJywgIm5vLXZlcmlmeSIsICZub192ZXJpZnksIE5fKCJieXBhc3MgcHJlLWNvbW1pdCBhbmQgY29tbWl0LW1zZyBob29rcyIpKSwKCQlPUFRfQk9PTCgwLCAiZHJ5LXJ1biIsICZkcnlfcnVuLCBOXygic2hvdyB3aGF0IHdvdWxkIGJlIGNvbW1pdHRlZCIpKSwKCQlPUFRfU0VUX0lOVCgwLCAic2hvcnQiLCAmc3RhdHVzX2Zvcm1hdCwgTl8oInNob3cgc3RhdHVzIGNvbmNpc2VseSIpLAoJCQkgICAgU1RBVFVTX0ZPUk1BVF9TSE9SVCksCgkJT1BUX0JPT0woMCwgImJyYW5jaCIsICZzLnNob3dfYnJhbmNoLCBOXygic2hvdyBicmFuY2ggaW5mb3JtYXRpb24iKSksCgkJT1BUX0JPT0woMCwgImFoZWFkLWJlaGluZCIsICZzLmFoZWFkX2JlaGluZF9mbGFncywKCQkJIE5fKCJjb21wdXRlIGZ1bGwgYWhlYWQvYmVoaW5kIHZhbHVlcyIpKSwKCQlPUFRfU0VUX0lOVCgwLCAicG9yY2VsYWluIiwgJnN0YXR1c19mb3JtYXQsCgkJCSAgICBOXygibWFjaGluZS1yZWFkYWJsZSBvdXRwdXQiKSwgU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU4pLAoJCU9QVF9TRVRfSU5UKDAsICJsb25nIiwgJnN0YXR1c19mb3JtYXQsCgkJCSAgICBOXygic2hvdyBzdGF0dXMgaW4gbG9uZyBmb3JtYXQgKGRlZmF1bHQpIiksCgkJCSAgICBTVEFUVVNfRk9STUFUX0xPTkcpLAoJCU9QVF9CT09MKCd6JywgIm51bGwiLCAmcy5udWxsX3Rlcm1pbmF0aW9uLAoJCQkgTl8oInRlcm1pbmF0ZSBlbnRyaWVzIHdpdGggTlVMIikpLAoJCU9QVF9CT09MKDAsICJhbWVuZCIsICZhbWVuZCwgTl8oImFtZW5kIHByZXZpb3VzIGNvbW1pdCIpKSwKCQlPUFRfQk9PTCgwLCAibm8tcG9zdC1yZXdyaXRlIiwgJm5vX3Bvc3RfcmV3cml0ZSwgTl8oImJ5cGFzcyBwb3N0LXJld3JpdGUgaG9vayIpKSwKCQl7IE9QVElPTl9TVFJJTkcsICd1JywgInVudHJhY2tlZC1maWxlcyIsICZ1bnRyYWNrZWRfZmlsZXNfYXJnLCBOXygibW9kZSIpLCBOXygic2hvdyB1bnRyYWNrZWQgZmlsZXMsIG9wdGlvbmFsIG1vZGVzOiBhbGwsIG5vcm1hbCwgbm8uIChEZWZhdWx0OiBhbGwpIiksIFBBUlNFX09QVF9PUFRBUkcsIE5VTEwsIChpbnRwdHJfdCkiYWxsIiB9LAoJCS8qIGVuZCBjb21taXQgY29udGVudHMgb3B0aW9ucyAqLwoKCQlPUFRfSElEREVOX0JPT0woMCwgImFsbG93LWVtcHR5IiwgJmFsbG93X2VtcHR5LAoJCQkJTl8oIm9rIHRvIHJlY29yZCBhbiBlbXB0eSBjaGFuZ2UiKSksCgkJT1BUX0hJRERFTl9CT09MKDAsICJhbGxvdy1lbXB0eS1tZXNzYWdlIiwgJmFsbG93X2VtcHR5X21lc3NhZ2UsCgkJCQlOXygib2sgdG8gcmVjb3JkIGEgY2hhbmdlIHdpdGggYW4gZW1wdHkgbWVzc2FnZSIpKSwKCgkJT1BUX0VORCgpCgl9OwoKCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgYXV0aG9yX2lkZW50ID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICppbmRleF9maWxlLCAqcmVmbG9nX21zZzsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzID0gTlVMTDsKCXN0cnVjdCBzdGF0IHN0YXRidWY7CglzdHJ1Y3QgY29tbWl0ICpjdXJyZW50X2hlYWQgPSBOVUxMOwoJc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKmV4dHJhID0gTlVMTDsKCXN0cnVjdCBzdHJidWYgZXJyID0gU1RSQlVGX0lOSVQ7CgoJaWYgKGFyZ2MgPT0gMiAmJiAhc3RyY21wKGFyZ3ZbMV0sICItaCIpKQoJCXVzYWdlX3dpdGhfb3B0aW9ucyhidWlsdGluX2NvbW1pdF91c2FnZSwgYnVpbHRpbl9jb21taXRfb3B0aW9ucyk7CgoJc3RhdHVzX2luaXRfY29uZmlnKCZzLCBnaXRfY29tbWl0X2NvbmZpZyk7CglzLmNvbW1pdF90ZW1wbGF0ZSA9IDE7CglzdGF0dXNfZm9ybWF0ID0gU1RBVFVTX0ZPUk1BVF9OT05FOyAvKiBJZ25vcmUgc3RhdHVzLnNob3J0ICovCglzLmNvbG9wdHMgPSAwOwoKCWlmIChnZXRfb2lkKCJIRUFEIiwgJm9pZCkpCgkJY3VycmVudF9oZWFkID0gTlVMTDsKCWVsc2UgewoJCWN1cnJlbnRfaGVhZCA9IGxvb2t1cF9jb21taXRfb3JfZGllKCZvaWQsICJIRUFEIik7CgkJaWYgKHBhcnNlX2NvbW1pdChjdXJyZW50X2hlYWQpKQoJCQlkaWUoXygiY291bGQgbm90IHBhcnNlIEhFQUQgY29tbWl0IikpOwoJfQoJdmVyYm9zZSA9IC0xOyAvKiB1bnNwZWNpZmllZCAqLwoJYXJnYyA9IHBhcnNlX2FuZF92YWxpZGF0ZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIGJ1aWx0aW5fY29tbWl0X29wdGlvbnMsCgkJCQkJICBidWlsdGluX2NvbW1pdF91c2FnZSwKCQkJCQkgIHByZWZpeCwgY3VycmVudF9oZWFkLCAmcyk7CglpZiAodmVyYm9zZSA9PSAtMSkKCQl2ZXJib3NlID0gKGNvbmZpZ19jb21taXRfdmVyYm9zZSA8IDApID8gMCA6IGNvbmZpZ19jb21taXRfdmVyYm9zZTsKCglpZiAoZHJ5X3J1bikKCQlyZXR1cm4gZHJ5X3J1bl9jb21taXQoYXJnYywgYXJndiwgcHJlZml4LCBjdXJyZW50X2hlYWQsICZzKTsKCWluZGV4X2ZpbGUgPSBwcmVwYXJlX2luZGV4KGFyZ2MsIGFyZ3YsIHByZWZpeCwgY3VycmVudF9oZWFkLCAwKTsKCgkvKiBTZXQgdXAgZXZlcnl0aGluZyBmb3Igd3JpdGluZyB0aGUgY29tbWl0IG9iamVjdC4gIFRoaXMgaW5jbHVkZXMKCSAgIHJ1bm5pbmcgaG9va3MsIHdyaXRpbmcgdGhlIHRyZWVzLCBhbmQgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdXNlci4gICovCglpZiAoIXByZXBhcmVfdG9fY29tbWl0KGluZGV4X2ZpbGUsIHByZWZpeCwKCQkJICAgICAgIGN1cnJlbnRfaGVhZCwgJnMsICZhdXRob3JfaWRlbnQpKSB7CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlyZXR1cm4gMTsKCX0KCgkvKiBEZXRlcm1pbmUgcGFyZW50cyAqLwoJcmVmbG9nX21zZyA9IGdldGVudigiR0lUX1JFRkxPR19BQ1RJT04iKTsKCWlmICghY3VycmVudF9oZWFkKSB7CgkJaWYgKCFyZWZsb2dfbXNnKQoJCQlyZWZsb2dfbXNnID0gImNvbW1pdCAoaW5pdGlhbCkiOwoJfSBlbHNlIGlmIChhbWVuZCkgewoJCWlmICghcmVmbG9nX21zZykKCQkJcmVmbG9nX21zZyA9ICJjb21taXQgKGFtZW5kKSI7CgkJcGFyZW50cyA9IGNvcHlfY29tbWl0X2xpc3QoY3VycmVudF9oZWFkLT5wYXJlbnRzKTsKCX0gZWxzZSBpZiAod2hlbmNlID09IEZST01fTUVSR0UpIHsKCQlzdHJ1Y3Qgc3RyYnVmIG0gPSBTVFJCVUZfSU5JVDsKCQlGSUxFICpmcDsKCQlpbnQgYWxsb3dfZmFzdF9mb3J3YXJkID0gMTsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKipwcHRyID0gJnBhcmVudHM7CgoJCWlmICghcmVmbG9nX21zZykKCQkJcmVmbG9nX21zZyA9ICJjb21taXQgKG1lcmdlKSI7CgkJcHB0ciA9IGNvbW1pdF9saXN0X2FwcGVuZChjdXJyZW50X2hlYWQsIHBwdHIpOwoJCWZwID0geGZvcGVuKGdpdF9wYXRoX21lcmdlX2hlYWQodGhlX3JlcG9zaXRvcnkpLCAiciIpOwoJCXdoaWxlIChzdHJidWZfZ2V0bGluZV9sZigmbSwgZnApICE9IEVPRikgewoJCQlzdHJ1Y3QgY29tbWl0ICpwYXJlbnQ7CgoJCQlwYXJlbnQgPSBnZXRfbWVyZ2VfcGFyZW50KG0uYnVmKTsKCQkJaWYgKCFwYXJlbnQpCgkJCQlkaWUoXygiQ29ycnVwdCBNRVJHRV9IRUFEIGZpbGUgKCVzKSIpLCBtLmJ1Zik7CgkJCXBwdHIgPSBjb21taXRfbGlzdF9hcHBlbmQocGFyZW50LCBwcHRyKTsKCQl9CgkJZmNsb3NlKGZwKTsKCQlzdHJidWZfcmVsZWFzZSgmbSk7CgkJaWYgKCFzdGF0KGdpdF9wYXRoX21lcmdlX21vZGUodGhlX3JlcG9zaXRvcnkpLCAmc3RhdGJ1ZikpIHsKCQkJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJnNiLCBnaXRfcGF0aF9tZXJnZV9tb2RlKHRoZV9yZXBvc2l0b3J5KSwgMCkgPCAwKQoJCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkIE1FUkdFX01PREUiKSk7CgkJCWlmICghc3RyY21wKHNiLmJ1ZiwgIm5vLWZmIikpCgkJCQlhbGxvd19mYXN0X2ZvcndhcmQgPSAwOwoJCX0KCQlpZiAoYWxsb3dfZmFzdF9mb3J3YXJkKQoJCQlyZWR1Y2VfaGVhZHNfcmVwbGFjZSgmcGFyZW50cyk7Cgl9IGVsc2UgewoJCWlmICghcmVmbG9nX21zZykKCQkJcmVmbG9nX21zZyA9ICh3aGVuY2UgPT0gRlJPTV9DSEVSUllfUElDSykKCQkJCQk/ICJjb21taXQgKGNoZXJyeS1waWNrKSIKCQkJCQk6ICJjb21taXQiOwoJCWNvbW1pdF9saXN0X2luc2VydChjdXJyZW50X2hlYWQsICZwYXJlbnRzKTsKCX0KCgkvKiBGaW5hbGx5LCBnZXQgdGhlIGNvbW1pdCBtZXNzYWdlICovCglzdHJidWZfcmVzZXQoJnNiKTsKCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgZ2l0X3BhdGhfY29tbWl0X2VkaXRtc2coKSwgMCkgPCAwKSB7CgkJaW50IHNhdmVkX2Vycm5vID0gZXJybm87CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlkaWUoXygiY291bGQgbm90IHJlYWQgY29tbWl0IG1lc3NhZ2U6ICVzIiksIHN0cmVycm9yKHNhdmVkX2Vycm5vKSk7Cgl9CgoJY2xlYW51cF9tZXNzYWdlKCZzYiwgY2xlYW51cF9tb2RlLCB2ZXJib3NlKTsKCglpZiAobWVzc2FnZV9pc19lbXB0eSgmc2IsIGNsZWFudXBfbW9kZSkgJiYgIWFsbG93X2VtcHR5X21lc3NhZ2UpIHsKCQlyb2xsYmFja19pbmRleF9maWxlcygpOwoJCWZwcmludGYoc3RkZXJyLCBfKCJBYm9ydGluZyBjb21taXQgZHVlIHRvIGVtcHR5IGNvbW1pdCBtZXNzYWdlLlxuIikpOwoJCWV4aXQoMSk7Cgl9CglpZiAodGVtcGxhdGVfdW50b3VjaGVkKCZzYiwgdGVtcGxhdGVfZmlsZSwgY2xlYW51cF9tb2RlKSAmJiAhYWxsb3dfZW1wdHlfbWVzc2FnZSkgewoJCXJvbGxiYWNrX2luZGV4X2ZpbGVzKCk7CgkJZnByaW50ZihzdGRlcnIsIF8oIkFib3J0aW5nIGNvbW1pdDsgeW91IGRpZCBub3QgZWRpdCB0aGUgbWVzc2FnZS5cbiIpKTsKCQlleGl0KDEpOwoJfQoKCWlmIChhbWVuZCkgewoJCWNvbnN0IGNoYXIgKmV4Y2x1ZGVfZ3Bnc2lnWzJdID0geyAiZ3Bnc2lnIiwgTlVMTCB9OwoJCWV4dHJhID0gcmVhZF9jb21taXRfZXh0cmFfaGVhZGVycyhjdXJyZW50X2hlYWQsIGV4Y2x1ZGVfZ3Bnc2lnKTsKCX0gZWxzZSB7CgkJc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKip0YWlsID0gJmV4dHJhOwoJCWFwcGVuZF9tZXJnZV90YWdfaGVhZGVycyhwYXJlbnRzLCAmdGFpbCk7Cgl9CgoJaWYgKGNvbW1pdF90cmVlX2V4dGVuZGVkKHNiLmJ1Ziwgc2IubGVuLCAmYWN0aXZlX2NhY2hlX3RyZWUtPm9pZCwKCQkJCSBwYXJlbnRzLCAmb2lkLCBhdXRob3JfaWRlbnQuYnVmLCBzaWduX2NvbW1pdCwKCQkJCSBleHRyYSkpIHsKCQlyb2xsYmFja19pbmRleF9maWxlcygpOwoJCWRpZShfKCJmYWlsZWQgdG8gd3JpdGUgY29tbWl0IG9iamVjdCIpKTsKCX0KCXN0cmJ1Zl9yZWxlYXNlKCZhdXRob3JfaWRlbnQpOwoJZnJlZV9jb21taXRfZXh0cmFfaGVhZGVycyhleHRyYSk7CgoJaWYgKHVwZGF0ZV9oZWFkX3dpdGhfcmVmbG9nKGN1cnJlbnRfaGVhZCwgJm9pZCwgcmVmbG9nX21zZywgJnNiLAoJCQkJICAgICZlcnIpKSB7CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlkaWUoIiVzIiwgZXJyLmJ1Zik7Cgl9CgoJc2VxdWVuY2VyX3Bvc3RfY29tbWl0X2NsZWFudXAodGhlX3JlcG9zaXRvcnksIDApOwoJdW5saW5rKGdpdF9wYXRoX21lcmdlX2hlYWQodGhlX3JlcG9zaXRvcnkpKTsKCXVubGluayhnaXRfcGF0aF9tZXJnZV9tc2codGhlX3JlcG9zaXRvcnkpKTsKCXVubGluayhnaXRfcGF0aF9tZXJnZV9tb2RlKHRoZV9yZXBvc2l0b3J5KSk7Cgl1bmxpbmsoZ2l0X3BhdGhfc3F1YXNoX21zZyh0aGVfcmVwb3NpdG9yeSkpOwoKCWlmIChjb21taXRfaW5kZXhfZmlsZXMoKSkKCQlkaWUoXygicmVwb3NpdG9yeSBoYXMgYmVlbiB1cGRhdGVkLCBidXQgdW5hYmxlIHRvIHdyaXRlXG4iCgkJICAgICAgIm5ld19pbmRleCBmaWxlLiBDaGVjayB0aGF0IGRpc2sgaXMgbm90IGZ1bGwgYW5kIHF1b3RhIGlzXG4iCgkJICAgICAgIm5vdCBleGNlZWRlZCwgYW5kIHRoZW4gXCJnaXQgcmVzdG9yZSAtLXN0YWdlZCA6L1wiIHRvIHJlY292ZXIuIikpOwoKCWlmIChnaXRfZW52X2Jvb2woR0lUX1RFU1RfQ09NTUlUX0dSQVBILCAwKSAmJgoJICAgIHdyaXRlX2NvbW1pdF9ncmFwaF9yZWFjaGFibGUoZ2V0X29iamVjdF9kaXJlY3RvcnkoKSwgMCwgTlVMTCkpCgkJcmV0dXJuIDE7CgoJcmVwb19yZXJlcmUodGhlX3JlcG9zaXRvcnksIDApOwoJcnVuX2NvbW1hbmRfdl9vcHQoYXJndl9nY19hdXRvLCBSVU5fR0lUX0NNRCk7CglydW5fY29tbWl0X2hvb2sodXNlX2VkaXRvciwgZ2V0X2luZGV4X2ZpbGUoKSwgInBvc3QtY29tbWl0IiwgTlVMTCk7CglpZiAoYW1lbmQgJiYgIW5vX3Bvc3RfcmV3cml0ZSkgewoJCWNvbW1pdF9wb3N0X3Jld3JpdGUodGhlX3JlcG9zaXRvcnksIGN1cnJlbnRfaGVhZCwgJm9pZCk7Cgl9CglpZiAoIXF1aWV0KSB7CgkJdW5zaWduZWQgaW50IGZsYWdzID0gMDsKCgkJaWYgKCFjdXJyZW50X2hlYWQpCgkJCWZsYWdzIHw9IFNVTU1BUllfSU5JVElBTF9DT01NSVQ7CgkJaWYgKGF1dGhvcl9kYXRlX2lzX2ludGVyZXN0aW5nKCkpCgkJCWZsYWdzIHw9IFNVTU1BUllfU0hPV19BVVRIT1JfREFURTsKCQlwcmludF9jb21taXRfc3VtbWFyeSh0aGVfcmVwb3NpdG9yeSwgcHJlZml4LAoJCQkJICAgICAmb2lkLCBmbGFncyk7Cgl9CgoJVU5MRUFLKGVycik7CglVTkxFQUsoc2IpOwoJcmV0dXJuIDA7Cn0K",
    "text": "/*\n * Builtin \"git commit\"\n *\n * Copyright (c) 2007 Kristian H\u00f8gsberg <krh@redhat.com>\n * Based on git-commit.sh by Junio C Hamano and Linus Torvalds\n */\n\n#define USE_THE_INDEX_COMPATIBILITY_MACROS\n#include \"cache.h\"\n#include \"config.h\"\n#include \"lockfile.h\"\n#include \"cache-tree.h\"\n#include \"color.h\"\n#include \"dir.h\"\n#include \"builtin.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"commit.h\"\n#include \"revision.h\"\n#include \"wt-status.h\"\n#include \"run-command.h\"\n#include \"refs.h\"\n#include \"log-tree.h\"\n#include \"strbuf.h\"\n#include \"utf8.h\"\n#include \"parse-options.h\"\n#include \"string-list.h\"\n#include \"rerere.h\"\n#include \"unpack-trees.h\"\n#include \"quote.h\"\n#include \"submodule.h\"\n#include \"gpg-interface.h\"\n#include \"column.h\"\n#include \"sequencer.h\"\n#include \"mailmap.h\"\n#include \"help.h\"\n#include \"commit-reach.h\"\n#include \"commit-graph.h\"\n\nstatic const char * const builtin_commit_usage[] = {\n\tN_(\"git commit [<options>] [--] <pathspec>...\"),\n\tNULL\n};\n\nstatic const char * const builtin_status_usage[] = {\n\tN_(\"git status [<options>] [--] <pathspec>...\"),\n\tNULL\n};\n\nstatic const char empty_amend_advice[] =\nN_(\"You asked to amend the most recent commit, but doing so would make\\n\"\n\"it empty. You can repeat your command with --allow-empty, or you can\\n\"\n\"remove the commit entirely with \\\"git reset HEAD^\\\".\\n\");\n\nstatic const char empty_cherry_pick_advice[] =\nN_(\"The previous cherry-pick is now empty, possibly due to conflict resolution.\\n\"\n\"If you wish to commit it anyway, use:\\n\"\n\"\\n\"\n\"    git commit --allow-empty\\n\"\n\"\\n\");\n\nstatic const char empty_cherry_pick_advice_single[] =\nN_(\"Otherwise, please use 'git cherry-pick --skip'\\n\");\n\nstatic const char empty_cherry_pick_advice_multi[] =\nN_(\"and then use:\\n\"\n\"\\n\"\n\"    git cherry-pick --continue\\n\"\n\"\\n\"\n\"to resume cherry-picking the remaining commits.\\n\"\n\"If you wish to skip this commit, use:\\n\"\n\"\\n\"\n\"    git cherry-pick --skip\\n\"\n\"\\n\");\n\nstatic const char *color_status_slots[] = {\n\t[WT_STATUS_HEADER]\t  = \"header\",\n\t[WT_STATUS_UPDATED]\t  = \"updated\",\n\t[WT_STATUS_CHANGED]\t  = \"changed\",\n\t[WT_STATUS_UNTRACKED]\t  = \"untracked\",\n\t[WT_STATUS_NOBRANCH]\t  = \"noBranch\",\n\t[WT_STATUS_UNMERGED]\t  = \"unmerged\",\n\t[WT_STATUS_LOCAL_BRANCH]  = \"localBranch\",\n\t[WT_STATUS_REMOTE_BRANCH] = \"remoteBranch\",\n\t[WT_STATUS_ONBRANCH]\t  = \"branch\",\n};\n\nstatic const char *use_message_buffer;\nstatic struct lock_file index_lock; /* real index */\nstatic struct lock_file false_lock; /* used only for partial commits */\nstatic enum {\n\tCOMMIT_AS_IS = 1,\n\tCOMMIT_NORMAL,\n\tCOMMIT_PARTIAL\n} commit_style;\n\nstatic const char *logfile, *force_author;\nstatic const char *template_file;\n/*\n * The _message variables are commit names from which to take\n * the commit message and/or authorship.\n */\nstatic const char *author_message, *author_message_buffer;\nstatic char *edit_message, *use_message;\nstatic char *fixup_message, *squash_message;\nstatic int all, also, interactive, patch_interactive, only, amend, signoff;\nstatic int edit_flag = -1; /* unspecified */\nstatic int quiet, verbose, no_verify, allow_empty, dry_run, renew_authorship;\nstatic int config_commit_verbose = -1; /* unspecified */\nstatic int no_post_rewrite, allow_empty_message;\nstatic char *untracked_files_arg, *force_date, *ignore_submodule_arg, *ignored_arg;\nstatic char *sign_commit;\n\n/*\n * The default commit message cleanup mode will remove the lines\n * beginning with # (shell comments) and leading and trailing\n * whitespaces (empty lines or containing only whitespaces)\n * if editor is used, and only the whitespaces if the message\n * is specified explicitly.\n */\nstatic enum commit_msg_cleanup_mode cleanup_mode;\nstatic const char *cleanup_arg;\n\nstatic enum commit_whence whence;\nstatic int sequencer_in_use;\nstatic int use_editor = 1, include_status = 1;\nstatic int have_option_m;\nstatic struct strbuf message = STRBUF_INIT;\n\nstatic enum wt_status_format status_format = STATUS_FORMAT_UNSPECIFIED;\n\nstatic int opt_parse_porcelain(const struct option *opt, const char *arg, int unset)\n{\n\tenum wt_status_format *value = (enum wt_status_format *)opt->value;\n\tif (unset)\n\t\t*value = STATUS_FORMAT_NONE;\n\telse if (!arg)\n\t\t*value = STATUS_FORMAT_PORCELAIN;\n\telse if (!strcmp(arg, \"v1\") || !strcmp(arg, \"1\"))\n\t\t*value = STATUS_FORMAT_PORCELAIN;\n\telse if (!strcmp(arg, \"v2\") || !strcmp(arg, \"2\"))\n\t\t*value = STATUS_FORMAT_PORCELAIN_V2;\n\telse\n\t\tdie(\"unsupported porcelain version '%s'\", arg);\n\n\treturn 0;\n}\n\nstatic int opt_parse_m(const struct option *opt, const char *arg, int unset)\n{\n\tstruct strbuf *buf = opt->value;\n\tif (unset) {\n\t\thave_option_m = 0;\n\t\tstrbuf_setlen(buf, 0);\n\t} else {\n\t\thave_option_m = 1;\n\t\tif (buf->len)\n\t\t\tstrbuf_addch(buf, '\\n');\n\t\tstrbuf_addstr(buf, arg);\n\t\tstrbuf_complete_line(buf);\n\t}\n\treturn 0;\n}\n\nstatic int opt_parse_rename_score(const struct option *opt, const char *arg, int unset)\n{\n\tconst char **value = opt->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tif (arg != NULL && *arg == '=')\n\t\targ = arg + 1;\n\n\t*value = arg;\n\treturn 0;\n}\n\nstatic void determine_whence(struct wt_status *s)\n{\n\tif (file_exists(git_path_merge_head(the_repository)))\n\t\twhence = FROM_MERGE;\n\telse if (file_exists(git_path_cherry_pick_head(the_repository))) {\n\t\twhence = FROM_CHERRY_PICK;\n\t\tif (file_exists(git_path_seq_dir()))\n\t\t\tsequencer_in_use = 1;\n\t}\n\telse\n\t\twhence = FROM_COMMIT;\n\tif (s)\n\t\ts->whence = whence;\n}\n\nstatic void status_init_config(struct wt_status *s, config_fn_t fn)\n{\n\twt_status_prepare(the_repository, s);\n\tinit_diff_ui_defaults();\n\tgit_config(fn, s);\n\tdetermine_whence(s);\n\ts->hints = advice_status_hints; /* must come after git_config() */\n}\n\nstatic void rollback_index_files(void)\n{\n\tswitch (commit_style) {\n\tcase COMMIT_AS_IS:\n\t\tbreak; /* nothing to do */\n\tcase COMMIT_NORMAL:\n\t\trollback_lock_file(&index_lock);\n\t\tbreak;\n\tcase COMMIT_PARTIAL:\n\t\trollback_lock_file(&index_lock);\n\t\trollback_lock_file(&false_lock);\n\t\tbreak;\n\t}\n}\n\nstatic int commit_index_files(void)\n{\n\tint err = 0;\n\n\tswitch (commit_style) {\n\tcase COMMIT_AS_IS:\n\t\tbreak; /* nothing to do */\n\tcase COMMIT_NORMAL:\n\t\terr = commit_lock_file(&index_lock);\n\t\tbreak;\n\tcase COMMIT_PARTIAL:\n\t\terr = commit_lock_file(&index_lock);\n\t\trollback_lock_file(&false_lock);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/*\n * Take a union of paths in the index and the named tree (typically, \"HEAD\"),\n * and return the paths that match the given pattern in list.\n */\nstatic int list_paths(struct string_list *list, const char *with_tree,\n\t\t      const struct pathspec *pattern)\n{\n\tint i, ret;\n\tchar *m;\n\n\tif (!pattern->nr)\n\t\treturn 0;\n\n\tm = xcalloc(1, pattern->nr);\n\n\tif (with_tree) {\n\t\tchar *max_prefix = common_prefix(pattern);\n\t\toverlay_tree_on_index(&the_index, with_tree, max_prefix);\n\t\tfree(max_prefix);\n\t}\n\n\tfor (i = 0; i < active_nr; i++) {\n\t\tconst struct cache_entry *ce = active_cache[i];\n\t\tstruct string_list_item *item;\n\n\t\tif (ce->ce_flags & CE_UPDATE)\n\t\t\tcontinue;\n\t\tif (!ce_path_match(&the_index, ce, pattern, m))\n\t\t\tcontinue;\n\t\titem = string_list_insert(list, ce->name);\n\t\tif (ce_skip_worktree(ce))\n\t\t\titem->util = item; /* better a valid pointer than a fake one */\n\t}\n\n\tret = report_path_error(m, pattern);\n\tfree(m);\n\treturn ret;\n}\n\nstatic void add_remove_files(struct string_list *list)\n{\n\tint i;\n\tfor (i = 0; i < list->nr; i++) {\n\t\tstruct stat st;\n\t\tstruct string_list_item *p = &(list->items[i]);\n\n\t\t/* p->util is skip-worktree */\n\t\tif (p->util)\n\t\t\tcontinue;\n\n\t\tif (!lstat(p->string, &st)) {\n\t\t\tif (add_to_cache(p->string, &st, 0))\n\t\t\t\tdie(_(\"updating files failed\"));\n\t\t} else\n\t\t\tremove_file_from_cache(p->string);\n\t}\n}\n\nstatic void create_base_index(const struct commit *current_head)\n{\n\tstruct tree *tree;\n\tstruct unpack_trees_options opts;\n\tstruct tree_desc t;\n\n\tif (!current_head) {\n\t\tdiscard_cache();\n\t\treturn;\n\t}\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.head_idx = 1;\n\topts.index_only = 1;\n\topts.merge = 1;\n\topts.src_index = &the_index;\n\topts.dst_index = &the_index;\n\n\topts.fn = oneway_merge;\n\ttree = parse_tree_indirect(&current_head->object.oid);\n\tif (!tree)\n\t\tdie(_(\"failed to unpack HEAD tree object\"));\n\tparse_tree(tree);\n\tinit_tree_desc(&t, tree->buffer, tree->size);\n\tif (unpack_trees(1, &t, &opts))\n\t\texit(128); /* We've already reported the error, finish dying */\n}\n\nstatic void refresh_cache_or_die(int refresh_flags)\n{\n\t/*\n\t * refresh_flags contains REFRESH_QUIET, so the only errors\n\t * are for unmerged entries.\n\t */\n\tif (refresh_cache(refresh_flags | REFRESH_IN_PORCELAIN))\n\t\tdie_resolve_conflict(\"commit\");\n}\n\nstatic const char *prepare_index(int argc, const char **argv, const char *prefix,\n\t\t\t\t const struct commit *current_head, int is_status)\n{\n\tstruct string_list partial = STRING_LIST_INIT_DUP;\n\tstruct pathspec pathspec;\n\tint refresh_flags = REFRESH_QUIET;\n\tconst char *ret;\n\n\tif (is_status)\n\t\trefresh_flags |= REFRESH_UNMERGED;\n\tparse_pathspec(&pathspec, 0,\n\t\t       PATHSPEC_PREFER_FULL,\n\t\t       prefix, argv);\n\n\tif (read_cache_preload(&pathspec) < 0)\n\t\tdie(_(\"index file corrupt\"));\n\n\tif (interactive) {\n\t\tchar *old_index_env = NULL;\n\t\thold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);\n\n\t\trefresh_cache_or_die(refresh_flags);\n\n\t\tif (write_locked_index(&the_index, &index_lock, 0))\n\t\t\tdie(_(\"unable to create temporary index\"));\n\n\t\told_index_env = xstrdup_or_null(getenv(INDEX_ENVIRONMENT));\n\t\tsetenv(INDEX_ENVIRONMENT, get_lock_file_path(&index_lock), 1);\n\n\t\tif (interactive_add(argc, argv, prefix, patch_interactive) != 0)\n\t\t\tdie(_(\"interactive add failed\"));\n\n\t\tif (old_index_env && *old_index_env)\n\t\t\tsetenv(INDEX_ENVIRONMENT, old_index_env, 1);\n\t\telse\n\t\t\tunsetenv(INDEX_ENVIRONMENT);\n\t\tFREE_AND_NULL(old_index_env);\n\n\t\tdiscard_cache();\n\t\tread_cache_from(get_lock_file_path(&index_lock));\n\t\tif (update_main_cache_tree(WRITE_TREE_SILENT) == 0) {\n\t\t\tif (reopen_lock_file(&index_lock) < 0)\n\t\t\t\tdie(_(\"unable to write index file\"));\n\t\t\tif (write_locked_index(&the_index, &index_lock, 0))\n\t\t\t\tdie(_(\"unable to update temporary index\"));\n\t\t} else\n\t\t\twarning(_(\"Failed to update main cache tree\"));\n\n\t\tcommit_style = COMMIT_NORMAL;\n\t\tret = get_lock_file_path(&index_lock);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Non partial, non as-is commit.\n\t *\n\t * (1) get the real index;\n\t * (2) update the_index as necessary;\n\t * (3) write the_index out to the real index (still locked);\n\t * (4) return the name of the locked index file.\n\t *\n\t * The caller should run hooks on the locked real index, and\n\t * (A) if all goes well, commit the real index;\n\t * (B) on failure, rollback the real index.\n\t */\n\tif (all || (also && pathspec.nr)) {\n\t\thold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);\n\t\tadd_files_to_cache(also ? prefix : NULL, &pathspec, 0);\n\t\trefresh_cache_or_die(refresh_flags);\n\t\tupdate_main_cache_tree(WRITE_TREE_SILENT);\n\t\tif (write_locked_index(&the_index, &index_lock, 0))\n\t\t\tdie(_(\"unable to write new_index file\"));\n\t\tcommit_style = COMMIT_NORMAL;\n\t\tret = get_lock_file_path(&index_lock);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * As-is commit.\n\t *\n\t * (1) return the name of the real index file.\n\t *\n\t * The caller should run hooks on the real index,\n\t * and create commit from the_index.\n\t * We still need to refresh the index here.\n\t */\n\tif (!only && !pathspec.nr) {\n\t\thold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);\n\t\trefresh_cache_or_die(refresh_flags);\n\t\tif (active_cache_changed\n\t\t    || !cache_tree_fully_valid(active_cache_tree))\n\t\t\tupdate_main_cache_tree(WRITE_TREE_SILENT);\n\t\tif (write_locked_index(&the_index, &index_lock,\n\t\t\t\t       COMMIT_LOCK | SKIP_IF_UNCHANGED))\n\t\t\tdie(_(\"unable to write new_index file\"));\n\t\tcommit_style = COMMIT_AS_IS;\n\t\tret = get_index_file();\n\t\tgoto out;\n\t}\n\n\t/*\n\t * A partial commit.\n\t *\n\t * (0) find the set of affected paths;\n\t * (1) get lock on the real index file;\n\t * (2) update the_index with the given paths;\n\t * (3) write the_index out to the real index (still locked);\n\t * (4) get lock on the false index file;\n\t * (5) reset the_index from HEAD;\n\t * (6) update the_index the same way as (2);\n\t * (7) write the_index out to the false index file;\n\t * (8) return the name of the false index file (still locked);\n\t *\n\t * The caller should run hooks on the locked false index, and\n\t * create commit from it.  Then\n\t * (A) if all goes well, commit the real index;\n\t * (B) on failure, rollback the real index;\n\t * In either case, rollback the false index.\n\t */\n\tcommit_style = COMMIT_PARTIAL;\n\n\tif (whence != FROM_COMMIT) {\n\t\tif (whence == FROM_MERGE)\n\t\t\tdie(_(\"cannot do a partial commit during a merge.\"));\n\t\telse if (whence == FROM_CHERRY_PICK)\n\t\t\tdie(_(\"cannot do a partial commit during a cherry-pick.\"));\n\t}\n\n\tif (list_paths(&partial, !current_head ? NULL : \"HEAD\", &pathspec))\n\t\texit(1);\n\n\tdiscard_cache();\n\tif (read_cache() < 0)\n\t\tdie(_(\"cannot read the index\"));\n\n\thold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);\n\tadd_remove_files(&partial);\n\trefresh_cache(REFRESH_QUIET);\n\tupdate_main_cache_tree(WRITE_TREE_SILENT);\n\tif (write_locked_index(&the_index, &index_lock, 0))\n\t\tdie(_(\"unable to write new_index file\"));\n\n\thold_lock_file_for_update(&false_lock,\n\t\t\t\t  git_path(\"next-index-%\"PRIuMAX,\n\t\t\t\t\t   (uintmax_t) getpid()),\n\t\t\t\t  LOCK_DIE_ON_ERROR);\n\n\tcreate_base_index(current_head);\n\tadd_remove_files(&partial);\n\trefresh_cache(REFRESH_QUIET);\n\n\tif (write_locked_index(&the_index, &false_lock, 0))\n\t\tdie(_(\"unable to write temporary index file\"));\n\n\tdiscard_cache();\n\tret = get_lock_file_path(&false_lock);\n\tread_cache_from(ret);\nout:\n\tstring_list_clear(&partial, 0);\n\tclear_pathspec(&pathspec);\n\treturn ret;\n}\n\nstatic int run_status(FILE *fp, const char *index_file, const char *prefix, int nowarn,\n\t\t      struct wt_status *s)\n{\n\tstruct object_id oid;\n\n\tif (s->relative_paths)\n\t\ts->prefix = prefix;\n\n\tif (amend) {\n\t\ts->amend = 1;\n\t\ts->reference = \"HEAD^1\";\n\t}\n\ts->verbose = verbose;\n\ts->index_file = index_file;\n\ts->fp = fp;\n\ts->nowarn = nowarn;\n\ts->is_initial = get_oid(s->reference, &oid) ? 1 : 0;\n\tif (!s->is_initial)\n\t\toidcpy(&s->oid_commit, &oid);\n\ts->status_format = status_format;\n\ts->ignore_submodule_arg = ignore_submodule_arg;\n\n\twt_status_collect(s);\n\twt_status_print(s);\n\twt_status_collect_free_buffers(s);\n\n\treturn s->committable;\n}\n\nstatic int is_a_merge(const struct commit *current_head)\n{\n\treturn !!(current_head->parents && current_head->parents->next);\n}\n\nstatic void assert_split_ident(struct ident_split *id, const struct strbuf *buf)\n{\n\tif (split_ident_line(id, buf->buf, buf->len) || !id->date_begin)\n\t\tBUG(\"unable to parse our own ident: %s\", buf->buf);\n}\n\nstatic void export_one(const char *var, const char *s, const char *e, int hack)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tif (hack)\n\t\tstrbuf_addch(&buf, hack);\n\tstrbuf_addf(&buf, \"%.*s\", (int)(e - s), s);\n\tsetenv(var, buf.buf, 1);\n\tstrbuf_release(&buf);\n}\n\nstatic int parse_force_date(const char *in, struct strbuf *out)\n{\n\tstrbuf_addch(out, '@');\n\n\tif (parse_date(in, out) < 0) {\n\t\tint errors = 0;\n\t\tunsigned long t = approxidate_careful(in, &errors);\n\t\tif (errors)\n\t\t\treturn -1;\n\t\tstrbuf_addf(out, \"%lu\", t);\n\t}\n\n\treturn 0;\n}\n\nstatic void set_ident_var(char **buf, char *val)\n{\n\tfree(*buf);\n\t*buf = val;\n}\n\nstatic void determine_author_info(struct strbuf *author_ident)\n{\n\tchar *name, *email, *date;\n\tstruct ident_split author;\n\n\tname = xstrdup_or_null(getenv(\"GIT_AUTHOR_NAME\"));\n\temail = xstrdup_or_null(getenv(\"GIT_AUTHOR_EMAIL\"));\n\tdate = xstrdup_or_null(getenv(\"GIT_AUTHOR_DATE\"));\n\n\tif (author_message) {\n\t\tstruct ident_split ident;\n\t\tsize_t len;\n\t\tconst char *a;\n\n\t\ta = find_commit_header(author_message_buffer, \"author\", &len);\n\t\tif (!a)\n\t\t\tdie(_(\"commit '%s' lacks author header\"), author_message);\n\t\tif (split_ident_line(&ident, a, len) < 0)\n\t\t\tdie(_(\"commit '%s' has malformed author line\"), author_message);\n\n\t\tset_ident_var(&name, xmemdupz(ident.name_begin, ident.name_end - ident.name_begin));\n\t\tset_ident_var(&email, xmemdupz(ident.mail_begin, ident.mail_end - ident.mail_begin));\n\n\t\tif (ident.date_begin) {\n\t\t\tstruct strbuf date_buf = STRBUF_INIT;\n\t\t\tstrbuf_addch(&date_buf, '@');\n\t\t\tstrbuf_add(&date_buf, ident.date_begin, ident.date_end - ident.date_begin);\n\t\t\tstrbuf_addch(&date_buf, ' ');\n\t\t\tstrbuf_add(&date_buf, ident.tz_begin, ident.tz_end - ident.tz_begin);\n\t\t\tset_ident_var(&date, strbuf_detach(&date_buf, NULL));\n\t\t}\n\t}\n\n\tif (force_author) {\n\t\tstruct ident_split ident;\n\n\t\tif (split_ident_line(&ident, force_author, strlen(force_author)) < 0)\n\t\t\tdie(_(\"malformed --author parameter\"));\n\t\tset_ident_var(&name, xmemdupz(ident.name_begin, ident.name_end - ident.name_begin));\n\t\tset_ident_var(&email, xmemdupz(ident.mail_begin, ident.mail_end - ident.mail_begin));\n\t}\n\n\tif (force_date) {\n\t\tstruct strbuf date_buf = STRBUF_INIT;\n\t\tif (parse_force_date(force_date, &date_buf))\n\t\t\tdie(_(\"invalid date format: %s\"), force_date);\n\t\tset_ident_var(&date, strbuf_detach(&date_buf, NULL));\n\t}\n\n\tstrbuf_addstr(author_ident, fmt_ident(name, email, WANT_AUTHOR_IDENT, date,\n\t\t\t\tIDENT_STRICT));\n\tassert_split_ident(&author, author_ident);\n\texport_one(\"GIT_AUTHOR_NAME\", author.name_begin, author.name_end, 0);\n\texport_one(\"GIT_AUTHOR_EMAIL\", author.mail_begin, author.mail_end, 0);\n\texport_one(\"GIT_AUTHOR_DATE\", author.date_begin, author.tz_end, '@');\n\tfree(name);\n\tfree(email);\n\tfree(date);\n}\n\nstatic int author_date_is_interesting(void)\n{\n\treturn author_message || force_date;\n}\n\nstatic void adjust_comment_line_char(const struct strbuf *sb)\n{\n\tchar candidates[] = \"#;@!$%^&|:\";\n\tchar *candidate;\n\tconst char *p;\n\n\tcomment_line_char = candidates[0];\n\tif (!memchr(sb->buf, comment_line_char, sb->len))\n\t\treturn;\n\n\tp = sb->buf;\n\tcandidate = strchr(candidates, *p);\n\tif (candidate)\n\t\t*candidate = ' ';\n\tfor (p = sb->buf; *p; p++) {\n\t\tif ((p[0] == '\\n' || p[0] == '\\r') && p[1]) {\n\t\t\tcandidate = strchr(candidates, p[1]);\n\t\t\tif (candidate)\n\t\t\t\t*candidate = ' ';\n\t\t}\n\t}\n\n\tfor (p = candidates; *p == ' '; p++)\n\t\t;\n\tif (!*p)\n\t\tdie(_(\"unable to select a comment character that is not used\\n\"\n\t\t      \"in the current commit message\"));\n\tcomment_line_char = *p;\n}\n\nstatic int prepare_to_commit(const char *index_file, const char *prefix,\n\t\t\t     struct commit *current_head,\n\t\t\t     struct wt_status *s,\n\t\t\t     struct strbuf *author_ident)\n{\n\tstruct stat statbuf;\n\tstruct strbuf committer_ident = STRBUF_INIT;\n\tint committable;\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *hook_arg1 = NULL;\n\tconst char *hook_arg2 = NULL;\n\tint clean_message_contents = (cleanup_mode != COMMIT_MSG_CLEANUP_NONE);\n\tint old_display_comment_prefix;\n\tint merge_contains_scissors = 0;\n\n\t/* This checks and barfs if author is badly specified */\n\tdetermine_author_info(author_ident);\n\n\tif (!no_verify && run_commit_hook(use_editor, index_file, \"pre-commit\", NULL))\n\t\treturn 0;\n\n\tif (squash_message) {\n\t\t/*\n\t\t * Insert the proper subject line before other commit\n\t\t * message options add their content.\n\t\t */\n\t\tif (use_message && !strcmp(use_message, squash_message))\n\t\t\tstrbuf_addstr(&sb, \"squash! \");\n\t\telse {\n\t\t\tstruct pretty_print_context ctx = {0};\n\t\t\tstruct commit *c;\n\t\t\tc = lookup_commit_reference_by_name(squash_message);\n\t\t\tif (!c)\n\t\t\t\tdie(_(\"could not lookup commit %s\"), squash_message);\n\t\t\tctx.output_encoding = get_commit_output_encoding();\n\t\t\tformat_commit_message(c, \"squash! %s\\n\\n\", &sb,\n\t\t\t\t\t      &ctx);\n\t\t}\n\t}\n\n\tif (have_option_m && !fixup_message) {\n\t\tstrbuf_addbuf(&sb, &message);\n\t\thook_arg1 = \"message\";\n\t} else if (logfile && !strcmp(logfile, \"-\")) {\n\t\tif (isatty(0))\n\t\t\tfprintf(stderr, _(\"(reading log message from standard input)\\n\"));\n\t\tif (strbuf_read(&sb, 0, 0) < 0)\n\t\t\tdie_errno(_(\"could not read log from standard input\"));\n\t\thook_arg1 = \"message\";\n\t} else if (logfile) {\n\t\tif (strbuf_read_file(&sb, logfile, 0) < 0)\n\t\t\tdie_errno(_(\"could not read log file '%s'\"),\n\t\t\t\t  logfile);\n\t\thook_arg1 = \"message\";\n\t} else if (use_message) {\n\t\tchar *buffer;\n\t\tbuffer = strstr(use_message_buffer, \"\\n\\n\");\n\t\tif (buffer)\n\t\t\tstrbuf_addstr(&sb, skip_blank_lines(buffer + 2));\n\t\thook_arg1 = \"commit\";\n\t\thook_arg2 = use_message;\n\t} else if (fixup_message) {\n\t\tstruct pretty_print_context ctx = {0};\n\t\tstruct commit *commit;\n\t\tcommit = lookup_commit_reference_by_name(fixup_message);\n\t\tif (!commit)\n\t\t\tdie(_(\"could not lookup commit %s\"), fixup_message);\n\t\tctx.output_encoding = get_commit_output_encoding();\n\t\tformat_commit_message(commit, \"fixup! %s\\n\\n\",\n\t\t\t\t      &sb, &ctx);\n\t\tif (have_option_m)\n\t\t\tstrbuf_addbuf(&sb, &message);\n\t\thook_arg1 = \"message\";\n\t} else if (!stat(git_path_merge_msg(the_repository), &statbuf)) {\n\t\tsize_t merge_msg_start;\n\n\t\t/*\n\t\t * prepend SQUASH_MSG here if it exists and a\n\t\t * \"merge --squash\" was originally performed\n\t\t */\n\t\tif (!stat(git_path_squash_msg(the_repository), &statbuf)) {\n\t\t\tif (strbuf_read_file(&sb, git_path_squash_msg(the_repository), 0) < 0)\n\t\t\t\tdie_errno(_(\"could not read SQUASH_MSG\"));\n\t\t\thook_arg1 = \"squash\";\n\t\t} else\n\t\t\thook_arg1 = \"merge\";\n\n\t\tmerge_msg_start = sb.len;\n\t\tif (strbuf_read_file(&sb, git_path_merge_msg(the_repository), 0) < 0)\n\t\t\tdie_errno(_(\"could not read MERGE_MSG\"));\n\n\t\tif (cleanup_mode == COMMIT_MSG_CLEANUP_SCISSORS &&\n\t\t    wt_status_locate_end(sb.buf + merge_msg_start,\n\t\t\t\t\t sb.len - merge_msg_start) <\n\t\t\t\tsb.len - merge_msg_start)\n\t\t\tmerge_contains_scissors = 1;\n\t} else if (!stat(git_path_squash_msg(the_repository), &statbuf)) {\n\t\tif (strbuf_read_file(&sb, git_path_squash_msg(the_repository), 0) < 0)\n\t\t\tdie_errno(_(\"could not read SQUASH_MSG\"));\n\t\thook_arg1 = \"squash\";\n\t} else if (template_file) {\n\t\tif (strbuf_read_file(&sb, template_file, 0) < 0)\n\t\t\tdie_errno(_(\"could not read '%s'\"), template_file);\n\t\thook_arg1 = \"template\";\n\t\tclean_message_contents = 0;\n\t}\n\n\t/*\n\t * The remaining cases don't modify the template message, but\n\t * just set the argument(s) to the prepare-commit-msg hook.\n\t */\n\telse if (whence == FROM_MERGE)\n\t\thook_arg1 = \"merge\";\n\telse if (whence == FROM_CHERRY_PICK) {\n\t\thook_arg1 = \"commit\";\n\t\thook_arg2 = \"CHERRY_PICK_HEAD\";\n\t}\n\n\tif (squash_message) {\n\t\t/*\n\t\t * If squash_commit was used for the commit subject,\n\t\t * then we're possibly hijacking other commit log options.\n\t\t * Reset the hook args to tell the real story.\n\t\t */\n\t\thook_arg1 = \"message\";\n\t\thook_arg2 = \"\";\n\t}\n\n\ts->fp = fopen_for_writing(git_path_commit_editmsg());\n\tif (s->fp == NULL)\n\t\tdie_errno(_(\"could not open '%s'\"), git_path_commit_editmsg());\n\n\t/* Ignore status.displayCommentPrefix: we do need comments in COMMIT_EDITMSG. */\n\told_display_comment_prefix = s->display_comment_prefix;\n\ts->display_comment_prefix = 1;\n\n\t/*\n\t * Most hints are counter-productive when the commit has\n\t * already started.\n\t */\n\ts->hints = 0;\n\n\tif (clean_message_contents)\n\t\tstrbuf_stripspace(&sb, 0);\n\n\tif (signoff)\n\t\tappend_signoff(&sb, ignore_non_trailer(sb.buf, sb.len), 0);\n\n\tif (fwrite(sb.buf, 1, sb.len, s->fp) < sb.len)\n\t\tdie_errno(_(\"could not write commit template\"));\n\n\tif (auto_comment_line_char)\n\t\tadjust_comment_line_char(&sb);\n\tstrbuf_release(&sb);\n\n\t/* This checks if committer ident is explicitly given */\n\tstrbuf_addstr(&committer_ident, git_committer_info(IDENT_STRICT));\n\tif (use_editor && include_status) {\n\t\tint ident_shown = 0;\n\t\tint saved_color_setting;\n\t\tstruct ident_split ci, ai;\n\n\t\tif (whence != FROM_COMMIT) {\n\t\t\tif (cleanup_mode == COMMIT_MSG_CLEANUP_SCISSORS &&\n\t\t\t\t!merge_contains_scissors)\n\t\t\t\twt_status_add_cut_line(s->fp);\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t    whence == FROM_MERGE\n\t\t\t\t? _(\"\\n\"\n\t\t\t\t\t\"It looks like you may be committing a merge.\\n\"\n\t\t\t\t\t\"If this is not correct, please remove the file\\n\"\n\t\t\t\t\t\"\t%s\\n\"\n\t\t\t\t\t\"and try again.\\n\")\n\t\t\t\t: _(\"\\n\"\n\t\t\t\t\t\"It looks like you may be committing a cherry-pick.\\n\"\n\t\t\t\t\t\"If this is not correct, please remove the file\\n\"\n\t\t\t\t\t\"\t%s\\n\"\n\t\t\t\t\t\"and try again.\\n\"),\n\t\t\t\twhence == FROM_MERGE ?\n\t\t\t\t\tgit_path_merge_head(the_repository) :\n\t\t\t\t\tgit_path_cherry_pick_head(the_repository));\n\t\t}\n\n\t\tfprintf(s->fp, \"\\n\");\n\t\tif (cleanup_mode == COMMIT_MSG_CLEANUP_ALL)\n\t\t\tstatus_printf(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"Please enter the commit message for your changes.\"\n\t\t\t\t  \" Lines starting\\nwith '%c' will be ignored, and an empty\"\n\t\t\t\t  \" message aborts the commit.\\n\"), comment_line_char);\n\t\telse if (cleanup_mode == COMMIT_MSG_CLEANUP_SCISSORS) {\n\t\t\tif (whence == FROM_COMMIT && !merge_contains_scissors)\n\t\t\t\twt_status_add_cut_line(s->fp);\n\t\t} else /* COMMIT_MSG_CLEANUP_SPACE, that is. */\n\t\t\tstatus_printf(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"Please enter the commit message for your changes.\"\n\t\t\t\t  \" Lines starting\\n\"\n\t\t\t\t  \"with '%c' will be kept; you may remove them\"\n\t\t\t\t  \" yourself if you want to.\\n\"\n\t\t\t\t  \"An empty message aborts the commit.\\n\"), comment_line_char);\n\n\t\t/*\n\t\t * These should never fail because they come from our own\n\t\t * fmt_ident. They may fail the sane_ident test, but we know\n\t\t * that the name and mail pointers will at least be valid,\n\t\t * which is enough for our tests and printing here.\n\t\t */\n\t\tassert_split_ident(&ai, author_ident);\n\t\tassert_split_ident(&ci, &committer_ident);\n\n\t\tif (ident_cmp(&ai, &ci))\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"%s\"\n\t\t\t\t\"Author:    %.*s <%.*s>\"),\n\t\t\t\tident_shown++ ? \"\" : \"\\n\",\n\t\t\t\t(int)(ai.name_end - ai.name_begin), ai.name_begin,\n\t\t\t\t(int)(ai.mail_end - ai.mail_begin), ai.mail_begin);\n\n\t\tif (author_date_is_interesting())\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"%s\"\n\t\t\t\t\"Date:      %s\"),\n\t\t\t\tident_shown++ ? \"\" : \"\\n\",\n\t\t\t\tshow_ident_date(&ai, DATE_MODE(NORMAL)));\n\n\t\tif (!committer_ident_sufficiently_given())\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"%s\"\n\t\t\t\t\"Committer: %.*s <%.*s>\"),\n\t\t\t\tident_shown++ ? \"\" : \"\\n\",\n\t\t\t\t(int)(ci.name_end - ci.name_begin), ci.name_begin,\n\t\t\t\t(int)(ci.mail_end - ci.mail_begin), ci.mail_begin);\n\n\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL, \"%s\", \"\"); /* Add new line for clarity */\n\n\t\tsaved_color_setting = s->use_color;\n\t\ts->use_color = 0;\n\t\tcommittable = run_status(s->fp, index_file, prefix, 1, s);\n\t\ts->use_color = saved_color_setting;\n\t\tstring_list_clear(&s->change, 1);\n\t} else {\n\t\tstruct object_id oid;\n\t\tconst char *parent = \"HEAD\";\n\n\t\tif (!active_nr && read_cache() < 0)\n\t\t\tdie(_(\"Cannot read index\"));\n\n\t\tif (amend)\n\t\t\tparent = \"HEAD^1\";\n\n\t\tif (get_oid(parent, &oid)) {\n\t\t\tint i, ita_nr = 0;\n\n\t\t\tfor (i = 0; i < active_nr; i++)\n\t\t\t\tif (ce_intent_to_add(active_cache[i]))\n\t\t\t\t\tita_nr++;\n\t\t\tcommittable = active_nr - ita_nr > 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Unless the user did explicitly request a submodule\n\t\t\t * ignore mode by passing a command line option we do\n\t\t\t * not ignore any changed submodule SHA-1s when\n\t\t\t * comparing index and parent, no matter what is\n\t\t\t * configured. Otherwise we won't commit any\n\t\t\t * submodules which were manually staged, which would\n\t\t\t * be really confusing.\n\t\t\t */\n\t\t\tstruct diff_flags flags = DIFF_FLAGS_INIT;\n\t\t\tflags.override_submodule_config = 1;\n\t\t\tif (ignore_submodule_arg &&\n\t\t\t    !strcmp(ignore_submodule_arg, \"all\"))\n\t\t\t\tflags.ignore_submodules = 1;\n\t\t\tcommittable = index_differs_from(the_repository,\n\t\t\t\t\t\t\t parent, &flags, 1);\n\t\t}\n\t}\n\tstrbuf_release(&committer_ident);\n\n\tfclose(s->fp);\n\n\t/*\n\t * Reject an attempt to record a non-merge empty commit without\n\t * explicit --allow-empty. In the cherry-pick case, it may be\n\t * empty due to conflict resolution, which the user should okay.\n\t */\n\tif (!committable && whence != FROM_MERGE && !allow_empty &&\n\t    !(amend && is_a_merge(current_head))) {\n\t\ts->hints = advice_status_hints;\n\t\ts->display_comment_prefix = old_display_comment_prefix;\n\t\trun_status(stdout, index_file, prefix, 0, s);\n\t\tif (amend)\n\t\t\tfputs(_(empty_amend_advice), stderr);\n\t\telse if (whence == FROM_CHERRY_PICK) {\n\t\t\tfputs(_(empty_cherry_pick_advice), stderr);\n\t\t\tif (!sequencer_in_use)\n\t\t\t\tfputs(_(empty_cherry_pick_advice_single), stderr);\n\t\t\telse\n\t\t\t\tfputs(_(empty_cherry_pick_advice_multi), stderr);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!no_verify && find_hook(\"pre-commit\")) {\n\t\t/*\n\t\t * Re-read the index as pre-commit hook could have updated it,\n\t\t * and write it out as a tree.  We must do this before we invoke\n\t\t * the editor and after we invoke run_status above.\n\t\t */\n\t\tdiscard_cache();\n\t}\n\tread_cache_from(index_file);\n\n\tif (update_main_cache_tree(0)) {\n\t\terror(_(\"Error building trees\"));\n\t\treturn 0;\n\t}\n\n\tif (run_commit_hook(use_editor, index_file, \"prepare-commit-msg\",\n\t\t\t    git_path_commit_editmsg(), hook_arg1, hook_arg2, NULL))\n\t\treturn 0;\n\n\tif (use_editor) {\n\t\tstruct argv_array env = ARGV_ARRAY_INIT;\n\n\t\targv_array_pushf(&env, \"GIT_INDEX_FILE=%s\", index_file);\n\t\tif (launch_editor(git_path_commit_editmsg(), NULL, env.argv)) {\n\t\t\tfprintf(stderr,\n\t\t\t_(\"Please supply the message using either -m or -F option.\\n\"));\n\t\t\texit(1);\n\t\t}\n\t\targv_array_clear(&env);\n\t}\n\n\tif (!no_verify &&\n\t    run_commit_hook(use_editor, index_file, \"commit-msg\", git_path_commit_editmsg(), NULL)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic const char *find_author_by_nickname(const char *name)\n{\n\tstruct rev_info revs;\n\tstruct commit *commit;\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct string_list mailmap = STRING_LIST_INIT_NODUP;\n\tconst char *av[20];\n\tint ac = 0;\n\n\trepo_init_revisions(the_repository, &revs, NULL);\n\tstrbuf_addf(&buf, \"--author=%s\", name);\n\tav[++ac] = \"--all\";\n\tav[++ac] = \"-i\";\n\tav[++ac] = buf.buf;\n\tav[++ac] = NULL;\n\tsetup_revisions(ac, av, &revs, NULL);\n\trevs.mailmap = &mailmap;\n\tread_mailmap(revs.mailmap, NULL);\n\n\tif (prepare_revision_walk(&revs))\n\t\tdie(_(\"revision walk setup failed\"));\n\tcommit = get_revision(&revs);\n\tif (commit) {\n\t\tstruct pretty_print_context ctx = {0};\n\t\tctx.date_mode.type = DATE_NORMAL;\n\t\tstrbuf_release(&buf);\n\t\tformat_commit_message(commit, \"%aN <%aE>\", &buf, &ctx);\n\t\tclear_mailmap(&mailmap);\n\t\treturn strbuf_detach(&buf, NULL);\n\t}\n\tdie(_(\"--author '%s' is not 'Name <email>' and matches no existing author\"), name);\n}\n\nstatic void handle_ignored_arg(struct wt_status *s)\n{\n\tif (!ignored_arg)\n\t\t; /* default already initialized */\n\telse if (!strcmp(ignored_arg, \"traditional\"))\n\t\ts->show_ignored_mode = SHOW_TRADITIONAL_IGNORED;\n\telse if (!strcmp(ignored_arg, \"no\"))\n\t\ts->show_ignored_mode = SHOW_NO_IGNORED;\n\telse if (!strcmp(ignored_arg, \"matching\"))\n\t\ts->show_ignored_mode = SHOW_MATCHING_IGNORED;\n\telse\n\t\tdie(_(\"Invalid ignored mode '%s'\"), ignored_arg);\n}\n\nstatic void handle_untracked_files_arg(struct wt_status *s)\n{\n\tif (!untracked_files_arg)\n\t\t; /* default already initialized */\n\telse if (!strcmp(untracked_files_arg, \"no\"))\n\t\ts->show_untracked_files = SHOW_NO_UNTRACKED_FILES;\n\telse if (!strcmp(untracked_files_arg, \"normal\"))\n\t\ts->show_untracked_files = SHOW_NORMAL_UNTRACKED_FILES;\n\telse if (!strcmp(untracked_files_arg, \"all\"))\n\t\ts->show_untracked_files = SHOW_ALL_UNTRACKED_FILES;\n\t/*\n\t * Please update $__git_untracked_file_modes in\n\t * git-completion.bash when you add new options\n\t */\n\telse\n\t\tdie(_(\"Invalid untracked files mode '%s'\"), untracked_files_arg);\n}\n\nstatic const char *read_commit_message(const char *name)\n{\n\tconst char *out_enc;\n\tstruct commit *commit;\n\n\tcommit = lookup_commit_reference_by_name(name);\n\tif (!commit)\n\t\tdie(_(\"could not lookup commit %s\"), name);\n\tout_enc = get_commit_output_encoding();\n\treturn logmsg_reencode(commit, NULL, out_enc);\n}\n\n/*\n * Enumerate what needs to be propagated when --porcelain\n * is not in effect here.\n */\nstatic struct status_deferred_config {\n\tenum wt_status_format status_format;\n\tint show_branch;\n\tenum ahead_behind_flags ahead_behind;\n} status_deferred_config = {\n\tSTATUS_FORMAT_UNSPECIFIED,\n\t-1, /* unspecified */\n\tAHEAD_BEHIND_UNSPECIFIED,\n};\n\nstatic void finalize_deferred_config(struct wt_status *s)\n{\n\tint use_deferred_config = (status_format != STATUS_FORMAT_PORCELAIN &&\n\t\t\t\t   status_format != STATUS_FORMAT_PORCELAIN_V2 &&\n\t\t\t\t   !s->null_termination);\n\n\tif (s->null_termination) {\n\t\tif (status_format == STATUS_FORMAT_NONE ||\n\t\t    status_format == STATUS_FORMAT_UNSPECIFIED)\n\t\t\tstatus_format = STATUS_FORMAT_PORCELAIN;\n\t\telse if (status_format == STATUS_FORMAT_LONG)\n\t\t\tdie(_(\"--long and -z are incompatible\"));\n\t}\n\n\tif (use_deferred_config && status_format == STATUS_FORMAT_UNSPECIFIED)\n\t\tstatus_format = status_deferred_config.status_format;\n\tif (status_format == STATUS_FORMAT_UNSPECIFIED)\n\t\tstatus_format = STATUS_FORMAT_NONE;\n\n\tif (use_deferred_config && s->show_branch < 0)\n\t\ts->show_branch = status_deferred_config.show_branch;\n\tif (s->show_branch < 0)\n\t\ts->show_branch = 0;\n\n\t/*\n\t * If the user did not give a \"--[no]-ahead-behind\" command\n\t * line argument *AND* we will print in a human-readable format\n\t * (short, long etc.) then we inherit from the status.aheadbehind\n\t * config setting.  In all other cases (and porcelain V[12] formats\n\t * in particular), we inherit _FULL for backwards compatibility.\n\t */\n\tif (use_deferred_config &&\n\t    s->ahead_behind_flags == AHEAD_BEHIND_UNSPECIFIED)\n\t\ts->ahead_behind_flags = status_deferred_config.ahead_behind;\n\n\tif (s->ahead_behind_flags == AHEAD_BEHIND_UNSPECIFIED)\n\t\ts->ahead_behind_flags = AHEAD_BEHIND_FULL;\n}\n\nstatic int parse_and_validate_options(int argc, const char *argv[],\n\t\t\t\t      const struct option *options,\n\t\t\t\t      const char * const usage[],\n\t\t\t\t      const char *prefix,\n\t\t\t\t      struct commit *current_head,\n\t\t\t\t      struct wt_status *s)\n{\n\tint f = 0;\n\n\targc = parse_options(argc, argv, prefix, options, usage, 0);\n\tfinalize_deferred_config(s);\n\n\tif (force_author && !strchr(force_author, '>'))\n\t\tforce_author = find_author_by_nickname(force_author);\n\n\tif (force_author && renew_authorship)\n\t\tdie(_(\"Using both --reset-author and --author does not make sense\"));\n\n\tif (logfile || have_option_m || use_message || fixup_message)\n\t\tuse_editor = 0;\n\tif (0 <= edit_flag)\n\t\tuse_editor = edit_flag;\n\n\t/* Sanity check options */\n\tif (amend && !current_head)\n\t\tdie(_(\"You have nothing to amend.\"));\n\tif (amend && whence != FROM_COMMIT) {\n\t\tif (whence == FROM_MERGE)\n\t\t\tdie(_(\"You are in the middle of a merge -- cannot amend.\"));\n\t\telse if (whence == FROM_CHERRY_PICK)\n\t\t\tdie(_(\"You are in the middle of a cherry-pick -- cannot amend.\"));\n\t}\n\tif (fixup_message && squash_message)\n\t\tdie(_(\"Options --squash and --fixup cannot be used together\"));\n\tif (use_message)\n\t\tf++;\n\tif (edit_message)\n\t\tf++;\n\tif (fixup_message)\n\t\tf++;\n\tif (logfile)\n\t\tf++;\n\tif (f > 1)\n\t\tdie(_(\"Only one of -c/-C/-F/--fixup can be used.\"));\n\tif (have_option_m && (edit_message || use_message || logfile))\n\t\tdie((_(\"Option -m cannot be combined with -c/-C/-F.\")));\n\tif (f || have_option_m)\n\t\ttemplate_file = NULL;\n\tif (edit_message)\n\t\tuse_message = edit_message;\n\tif (amend && !use_message && !fixup_message)\n\t\tuse_message = \"HEAD\";\n\tif (!use_message && whence != FROM_CHERRY_PICK && renew_authorship)\n\t\tdie(_(\"--reset-author can be used only with -C, -c or --amend.\"));\n\tif (use_message) {\n\t\tuse_message_buffer = read_commit_message(use_message);\n\t\tif (!renew_authorship) {\n\t\t\tauthor_message = use_message;\n\t\t\tauthor_message_buffer = use_message_buffer;\n\t\t}\n\t}\n\tif (whence == FROM_CHERRY_PICK && !renew_authorship) {\n\t\tauthor_message = \"CHERRY_PICK_HEAD\";\n\t\tauthor_message_buffer = read_commit_message(author_message);\n\t}\n\n\tif (patch_interactive)\n\t\tinteractive = 1;\n\n\tif (also + only + all + interactive > 1)\n\t\tdie(_(\"Only one of --include/--only/--all/--interactive/--patch can be used.\"));\n\tif (argc == 0 && (also || (only && !amend && !allow_empty)))\n\t\tdie(_(\"No paths with --include/--only does not make sense.\"));\n\tcleanup_mode = get_cleanup_mode(cleanup_arg, use_editor);\n\n\thandle_untracked_files_arg(s);\n\n\tif (all && argc > 0)\n\t\tdie(_(\"paths '%s ...' with -a does not make sense\"),\n\t\t    argv[0]);\n\n\tif (status_format != STATUS_FORMAT_NONE)\n\t\tdry_run = 1;\n\n\treturn argc;\n}\n\nstatic int dry_run_commit(int argc, const char **argv, const char *prefix,\n\t\t\t  const struct commit *current_head, struct wt_status *s)\n{\n\tint committable;\n\tconst char *index_file;\n\n\tindex_file = prepare_index(argc, argv, prefix, current_head, 1);\n\tcommittable = run_status(stdout, index_file, prefix, 0, s);\n\trollback_index_files();\n\n\treturn committable ? 0 : 1;\n}\n\ndefine_list_config_array_extra(color_status_slots, {\"added\"});\n\nstatic int parse_status_slot(const char *slot)\n{\n\tif (!strcasecmp(slot, \"added\"))\n\t\treturn WT_STATUS_UPDATED;\n\n\treturn LOOKUP_CONFIG(color_status_slots, slot);\n}\n\nstatic int git_status_config(const char *k, const char *v, void *cb)\n{\n\tstruct wt_status *s = cb;\n\tconst char *slot_name;\n\n\tif (starts_with(k, \"column.\"))\n\t\treturn git_column_config(k, v, \"status\", &s->colopts);\n\tif (!strcmp(k, \"status.submodulesummary\")) {\n\t\tint is_bool;\n\t\ts->submodule_summary = git_config_bool_or_int(k, v, &is_bool);\n\t\tif (is_bool && s->submodule_summary)\n\t\t\ts->submodule_summary = -1;\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.short\")) {\n\t\tif (git_config_bool(k, v))\n\t\t\tstatus_deferred_config.status_format = STATUS_FORMAT_SHORT;\n\t\telse\n\t\t\tstatus_deferred_config.status_format = STATUS_FORMAT_NONE;\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.branch\")) {\n\t\tstatus_deferred_config.show_branch = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.aheadbehind\")) {\n\t\tstatus_deferred_config.ahead_behind = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.showstash\")) {\n\t\ts->show_stash = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.color\") || !strcmp(k, \"color.status\")) {\n\t\ts->use_color = git_config_colorbool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.displaycommentprefix\")) {\n\t\ts->display_comment_prefix = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (skip_prefix(k, \"status.color.\", &slot_name) ||\n\t    skip_prefix(k, \"color.status.\", &slot_name)) {\n\t\tint slot = parse_status_slot(slot_name);\n\t\tif (slot < 0)\n\t\t\treturn 0;\n\t\tif (!v)\n\t\t\treturn config_error_nonbool(k);\n\t\treturn color_parse(v, s->color_palette[slot]);\n\t}\n\tif (!strcmp(k, \"status.relativepaths\")) {\n\t\ts->relative_paths = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.showuntrackedfiles\")) {\n\t\tif (!v)\n\t\t\treturn config_error_nonbool(k);\n\t\telse if (!strcmp(v, \"no\"))\n\t\t\ts->show_untracked_files = SHOW_NO_UNTRACKED_FILES;\n\t\telse if (!strcmp(v, \"normal\"))\n\t\t\ts->show_untracked_files = SHOW_NORMAL_UNTRACKED_FILES;\n\t\telse if (!strcmp(v, \"all\"))\n\t\t\ts->show_untracked_files = SHOW_ALL_UNTRACKED_FILES;\n\t\telse\n\t\t\treturn error(_(\"Invalid untracked files mode '%s'\"), v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"diff.renamelimit\")) {\n\t\tif (s->rename_limit == -1)\n\t\t\ts->rename_limit = git_config_int(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.renamelimit\")) {\n\t\ts->rename_limit = git_config_int(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"diff.renames\")) {\n\t\tif (s->detect_rename == -1)\n\t\t\ts->detect_rename = git_config_rename(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.renames\")) {\n\t\ts->detect_rename = git_config_rename(k, v);\n\t\treturn 0;\n\t}\n\treturn git_diff_ui_config(k, v, NULL);\n}\n\nint cmd_status(int argc, const char **argv, const char *prefix)\n{\n\tstatic int no_renames = -1;\n\tstatic const char *rename_score_arg = (const char *)-1;\n\tstatic struct wt_status s;\n\tunsigned int progress_flag = 0;\n\tint fd;\n\tstruct object_id oid;\n\tstatic struct option builtin_status_options[] = {\n\t\tOPT__VERBOSE(&verbose, N_(\"be verbose\")),\n\t\tOPT_SET_INT('s', \"short\", &status_format,\n\t\t\t    N_(\"show status concisely\"), STATUS_FORMAT_SHORT),\n\t\tOPT_BOOL('b', \"branch\", &s.show_branch,\n\t\t\t N_(\"show branch information\")),\n\t\tOPT_BOOL(0, \"show-stash\", &s.show_stash,\n\t\t\t N_(\"show stash information\")),\n\t\tOPT_BOOL(0, \"ahead-behind\", &s.ahead_behind_flags,\n\t\t\t N_(\"compute full ahead/behind values\")),\n\t\t{ OPTION_CALLBACK, 0, \"porcelain\", &status_format,\n\t\t  N_(\"version\"), N_(\"machine-readable output\"),\n\t\t  PARSE_OPT_OPTARG, opt_parse_porcelain },\n\t\tOPT_SET_INT(0, \"long\", &status_format,\n\t\t\t    N_(\"show status in long format (default)\"),\n\t\t\t    STATUS_FORMAT_LONG),\n\t\tOPT_BOOL('z', \"null\", &s.null_termination,\n\t\t\t N_(\"terminate entries with NUL\")),\n\t\t{ OPTION_STRING, 'u', \"untracked-files\", &untracked_files_arg,\n\t\t  N_(\"mode\"),\n\t\t  N_(\"show untracked files, optional modes: all, normal, no. (Default: all)\"),\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\t{ OPTION_STRING, 0, \"ignored\", &ignored_arg,\n\t\t  N_(\"mode\"),\n\t\t  N_(\"show ignored files, optional modes: traditional, matching, no. (Default: traditional)\"),\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"traditional\" },\n\t\t{ OPTION_STRING, 0, \"ignore-submodules\", &ignore_submodule_arg, N_(\"when\"),\n\t\t  N_(\"ignore changes to submodules, optional when: all, dirty, untracked. (Default: all)\"),\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\tOPT_COLUMN(0, \"column\", &s.colopts, N_(\"list untracked files in columns\")),\n\t\tOPT_BOOL(0, \"no-renames\", &no_renames, N_(\"do not detect renames\")),\n\t\t{ OPTION_CALLBACK, 'M', \"find-renames\", &rename_score_arg,\n\t\t  N_(\"n\"), N_(\"detect renames, optionally set similarity index\"),\n\t\t  PARSE_OPT_OPTARG | PARSE_OPT_NONEG, opt_parse_rename_score },\n\t\tOPT_END(),\n\t};\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_status_usage, builtin_status_options);\n\n\tstatus_init_config(&s, git_status_config);\n\targc = parse_options(argc, argv, prefix,\n\t\t\t     builtin_status_options,\n\t\t\t     builtin_status_usage, 0);\n\tfinalize_colopts(&s.colopts, -1);\n\tfinalize_deferred_config(&s);\n\n\thandle_untracked_files_arg(&s);\n\thandle_ignored_arg(&s);\n\n\tif (s.show_ignored_mode == SHOW_MATCHING_IGNORED &&\n\t    s.show_untracked_files == SHOW_NO_UNTRACKED_FILES)\n\t\tdie(_(\"Unsupported combination of ignored and untracked-files arguments\"));\n\n\tparse_pathspec(&s.pathspec, 0,\n\t\t       PATHSPEC_PREFER_FULL,\n\t\t       prefix, argv);\n\n\tif (status_format != STATUS_FORMAT_PORCELAIN &&\n\t    status_format != STATUS_FORMAT_PORCELAIN_V2)\n\t\tprogress_flag = REFRESH_PROGRESS;\n\trepo_read_index(the_repository);\n\trefresh_index(&the_index,\n\t\t      REFRESH_QUIET|REFRESH_UNMERGED|progress_flag,\n\t\t      &s.pathspec, NULL, NULL);\n\n\tif (use_optional_locks())\n\t\tfd = hold_locked_index(&index_lock, 0);\n\telse\n\t\tfd = -1;\n\n\ts.is_initial = get_oid(s.reference, &oid) ? 1 : 0;\n\tif (!s.is_initial)\n\t\toidcpy(&s.oid_commit, &oid);\n\n\ts.ignore_submodule_arg = ignore_submodule_arg;\n\ts.status_format = status_format;\n\ts.verbose = verbose;\n\tif (no_renames != -1)\n\t\ts.detect_rename = !no_renames;\n\tif ((intptr_t)rename_score_arg != -1) {\n\t\tif (s.detect_rename < DIFF_DETECT_RENAME)\n\t\t\ts.detect_rename = DIFF_DETECT_RENAME;\n\t\tif (rename_score_arg)\n\t\t\ts.rename_score = parse_rename_score(&rename_score_arg);\n\t}\n\n\twt_status_collect(&s);\n\n\tif (0 <= fd)\n\t\trepo_update_index_if_able(the_repository, &index_lock);\n\n\tif (s.relative_paths)\n\t\ts.prefix = prefix;\n\n\twt_status_print(&s);\n\twt_status_collect_free_buffers(&s);\n\n\treturn 0;\n}\n\nstatic int git_commit_config(const char *k, const char *v, void *cb)\n{\n\tstruct wt_status *s = cb;\n\tint status;\n\n\tif (!strcmp(k, \"commit.template\"))\n\t\treturn git_config_pathname(&template_file, k, v);\n\tif (!strcmp(k, \"commit.status\")) {\n\t\tinclude_status = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"commit.cleanup\"))\n\t\treturn git_config_string(&cleanup_arg, k, v);\n\tif (!strcmp(k, \"commit.gpgsign\")) {\n\t\tsign_commit = git_config_bool(k, v) ? \"\" : NULL;\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"commit.verbose\")) {\n\t\tint is_bool;\n\t\tconfig_commit_verbose = git_config_bool_or_int(k, v, &is_bool);\n\t\treturn 0;\n\t}\n\n\tstatus = git_gpg_config(k, v, NULL);\n\tif (status)\n\t\treturn status;\n\treturn git_status_config(k, v, s);\n}\n\nint run_commit_hook(int editor_is_used, const char *index_file, const char *name, ...)\n{\n\tstruct argv_array hook_env = ARGV_ARRAY_INIT;\n\tva_list args;\n\tint ret;\n\n\targv_array_pushf(&hook_env, \"GIT_INDEX_FILE=%s\", index_file);\n\n\t/*\n\t * Let the hook know that no editor will be launched.\n\t */\n\tif (!editor_is_used)\n\t\targv_array_push(&hook_env, \"GIT_EDITOR=:\");\n\n\tva_start(args, name);\n\tret = run_hook_ve(hook_env.argv,name, args);\n\tva_end(args);\n\targv_array_clear(&hook_env);\n\n\treturn ret;\n}\n\nint cmd_commit(int argc, const char **argv, const char *prefix)\n{\n\tconst char *argv_gc_auto[] = {\"gc\", \"--auto\", NULL};\n\tstatic struct wt_status s;\n\tstatic struct option builtin_commit_options[] = {\n\t\tOPT__QUIET(&quiet, N_(\"suppress summary after successful commit\")),\n\t\tOPT__VERBOSE(&verbose, N_(\"show diff in commit message template\")),\n\n\t\tOPT_GROUP(N_(\"Commit message options\")),\n\t\tOPT_FILENAME('F', \"file\", &logfile, N_(\"read message from file\")),\n\t\tOPT_STRING(0, \"author\", &force_author, N_(\"author\"), N_(\"override author for commit\")),\n\t\tOPT_STRING(0, \"date\", &force_date, N_(\"date\"), N_(\"override date for commit\")),\n\t\tOPT_CALLBACK('m', \"message\", &message, N_(\"message\"), N_(\"commit message\"), opt_parse_m),\n\t\tOPT_STRING('c', \"reedit-message\", &edit_message, N_(\"commit\"), N_(\"reuse and edit message from specified commit\")),\n\t\tOPT_STRING('C', \"reuse-message\", &use_message, N_(\"commit\"), N_(\"reuse message from specified commit\")),\n\t\tOPT_STRING(0, \"fixup\", &fixup_message, N_(\"commit\"), N_(\"use autosquash formatted message to fixup specified commit\")),\n\t\tOPT_STRING(0, \"squash\", &squash_message, N_(\"commit\"), N_(\"use autosquash formatted message to squash specified commit\")),\n\t\tOPT_BOOL(0, \"reset-author\", &renew_authorship, N_(\"the commit is authored by me now (used with -C/-c/--amend)\")),\n\t\tOPT_BOOL('s', \"signoff\", &signoff, N_(\"add Signed-off-by:\")),\n\t\tOPT_FILENAME('t', \"template\", &template_file, N_(\"use specified template file\")),\n\t\tOPT_BOOL('e', \"edit\", &edit_flag, N_(\"force edit of commit\")),\n\t\tOPT_CLEANUP(&cleanup_arg),\n\t\tOPT_BOOL(0, \"status\", &include_status, N_(\"include status in commit message template\")),\n\t\t{ OPTION_STRING, 'S', \"gpg-sign\", &sign_commit, N_(\"key-id\"),\n\t\t  N_(\"GPG sign commit\"), PARSE_OPT_OPTARG, NULL, (intptr_t) \"\" },\n\t\t/* end commit message options */\n\n\t\tOPT_GROUP(N_(\"Commit contents options\")),\n\t\tOPT_BOOL('a', \"all\", &all, N_(\"commit all changed files\")),\n\t\tOPT_BOOL('i', \"include\", &also, N_(\"add specified files to index for commit\")),\n\t\tOPT_BOOL(0, \"interactive\", &interactive, N_(\"interactively add files\")),\n\t\tOPT_BOOL('p', \"patch\", &patch_interactive, N_(\"interactively add changes\")),\n\t\tOPT_BOOL('o', \"only\", &only, N_(\"commit only specified files\")),\n\t\tOPT_BOOL('n', \"no-verify\", &no_verify, N_(\"bypass pre-commit and commit-msg hooks\")),\n\t\tOPT_BOOL(0, \"dry-run\", &dry_run, N_(\"show what would be committed\")),\n\t\tOPT_SET_INT(0, \"short\", &status_format, N_(\"show status concisely\"),\n\t\t\t    STATUS_FORMAT_SHORT),\n\t\tOPT_BOOL(0, \"branch\", &s.show_branch, N_(\"show branch information\")),\n\t\tOPT_BOOL(0, \"ahead-behind\", &s.ahead_behind_flags,\n\t\t\t N_(\"compute full ahead/behind values\")),\n\t\tOPT_SET_INT(0, \"porcelain\", &status_format,\n\t\t\t    N_(\"machine-readable output\"), STATUS_FORMAT_PORCELAIN),\n\t\tOPT_SET_INT(0, \"long\", &status_format,\n\t\t\t    N_(\"show status in long format (default)\"),\n\t\t\t    STATUS_FORMAT_LONG),\n\t\tOPT_BOOL('z', \"null\", &s.null_termination,\n\t\t\t N_(\"terminate entries with NUL\")),\n\t\tOPT_BOOL(0, \"amend\", &amend, N_(\"amend previous commit\")),\n\t\tOPT_BOOL(0, \"no-post-rewrite\", &no_post_rewrite, N_(\"bypass post-rewrite hook\")),\n\t\t{ OPTION_STRING, 'u', \"untracked-files\", &untracked_files_arg, N_(\"mode\"), N_(\"show untracked files, optional modes: all, normal, no. (Default: all)\"), PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\t/* end commit contents options */\n\n\t\tOPT_HIDDEN_BOOL(0, \"allow-empty\", &allow_empty,\n\t\t\t\tN_(\"ok to record an empty change\")),\n\t\tOPT_HIDDEN_BOOL(0, \"allow-empty-message\", &allow_empty_message,\n\t\t\t\tN_(\"ok to record a change with an empty message\")),\n\n\t\tOPT_END()\n\t};\n\n\tstruct strbuf sb = STRBUF_INIT;\n\tstruct strbuf author_ident = STRBUF_INIT;\n\tconst char *index_file, *reflog_msg;\n\tstruct object_id oid;\n\tstruct commit_list *parents = NULL;\n\tstruct stat statbuf;\n\tstruct commit *current_head = NULL;\n\tstruct commit_extra_header *extra = NULL;\n\tstruct strbuf err = STRBUF_INIT;\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_commit_usage, builtin_commit_options);\n\n\tstatus_init_config(&s, git_commit_config);\n\ts.commit_template = 1;\n\tstatus_format = STATUS_FORMAT_NONE; /* Ignore status.short */\n\ts.colopts = 0;\n\n\tif (get_oid(\"HEAD\", &oid))\n\t\tcurrent_head = NULL;\n\telse {\n\t\tcurrent_head = lookup_commit_or_die(&oid, \"HEAD\");\n\t\tif (parse_commit(current_head))\n\t\t\tdie(_(\"could not parse HEAD commit\"));\n\t}\n\tverbose = -1; /* unspecified */\n\targc = parse_and_validate_options(argc, argv, builtin_commit_options,\n\t\t\t\t\t  builtin_commit_usage,\n\t\t\t\t\t  prefix, current_head, &s);\n\tif (verbose == -1)\n\t\tverbose = (config_commit_verbose < 0) ? 0 : config_commit_verbose;\n\n\tif (dry_run)\n\t\treturn dry_run_commit(argc, argv, prefix, current_head, &s);\n\tindex_file = prepare_index(argc, argv, prefix, current_head, 0);\n\n\t/* Set up everything for writing the commit object.  This includes\n\t   running hooks, writing the trees, and interacting with the user.  */\n\tif (!prepare_to_commit(index_file, prefix,\n\t\t\t       current_head, &s, &author_ident)) {\n\t\trollback_index_files();\n\t\treturn 1;\n\t}\n\n\t/* Determine parents */\n\treflog_msg = getenv(\"GIT_REFLOG_ACTION\");\n\tif (!current_head) {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (initial)\";\n\t} else if (amend) {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (amend)\";\n\t\tparents = copy_commit_list(current_head->parents);\n\t} else if (whence == FROM_MERGE) {\n\t\tstruct strbuf m = STRBUF_INIT;\n\t\tFILE *fp;\n\t\tint allow_fast_forward = 1;\n\t\tstruct commit_list **pptr = &parents;\n\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (merge)\";\n\t\tpptr = commit_list_append(current_head, pptr);\n\t\tfp = xfopen(git_path_merge_head(the_repository), \"r\");\n\t\twhile (strbuf_getline_lf(&m, fp) != EOF) {\n\t\t\tstruct commit *parent;\n\n\t\t\tparent = get_merge_parent(m.buf);\n\t\t\tif (!parent)\n\t\t\t\tdie(_(\"Corrupt MERGE_HEAD file (%s)\"), m.buf);\n\t\t\tpptr = commit_list_append(parent, pptr);\n\t\t}\n\t\tfclose(fp);\n\t\tstrbuf_release(&m);\n\t\tif (!stat(git_path_merge_mode(the_repository), &statbuf)) {\n\t\t\tif (strbuf_read_file(&sb, git_path_merge_mode(the_repository), 0) < 0)\n\t\t\t\tdie_errno(_(\"could not read MERGE_MODE\"));\n\t\t\tif (!strcmp(sb.buf, \"no-ff\"))\n\t\t\t\tallow_fast_forward = 0;\n\t\t}\n\t\tif (allow_fast_forward)\n\t\t\treduce_heads_replace(&parents);\n\t} else {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = (whence == FROM_CHERRY_PICK)\n\t\t\t\t\t? \"commit (cherry-pick)\"\n\t\t\t\t\t: \"commit\";\n\t\tcommit_list_insert(current_head, &parents);\n\t}\n\n\t/* Finally, get the commit message */\n\tstrbuf_reset(&sb);\n\tif (strbuf_read_file(&sb, git_path_commit_editmsg(), 0) < 0) {\n\t\tint saved_errno = errno;\n\t\trollback_index_files();\n\t\tdie(_(\"could not read commit message: %s\"), strerror(saved_errno));\n\t}\n\n\tcleanup_message(&sb, cleanup_mode, verbose);\n\n\tif (message_is_empty(&sb, cleanup_mode) && !allow_empty_message) {\n\t\trollback_index_files();\n\t\tfprintf(stderr, _(\"Aborting commit due to empty commit message.\\n\"));\n\t\texit(1);\n\t}\n\tif (template_untouched(&sb, template_file, cleanup_mode) && !allow_empty_message) {\n\t\trollback_index_files();\n\t\tfprintf(stderr, _(\"Aborting commit; you did not edit the message.\\n\"));\n\t\texit(1);\n\t}\n\n\tif (amend) {\n\t\tconst char *exclude_gpgsig[2] = { \"gpgsig\", NULL };\n\t\textra = read_commit_extra_headers(current_head, exclude_gpgsig);\n\t} else {\n\t\tstruct commit_extra_header **tail = &extra;\n\t\tappend_merge_tag_headers(parents, &tail);\n\t}\n\n\tif (commit_tree_extended(sb.buf, sb.len, &active_cache_tree->oid,\n\t\t\t\t parents, &oid, author_ident.buf, sign_commit,\n\t\t\t\t extra)) {\n\t\trollback_index_files();\n\t\tdie(_(\"failed to write commit object\"));\n\t}\n\tstrbuf_release(&author_ident);\n\tfree_commit_extra_headers(extra);\n\n\tif (update_head_with_reflog(current_head, &oid, reflog_msg, &sb,\n\t\t\t\t    &err)) {\n\t\trollback_index_files();\n\t\tdie(\"%s\", err.buf);\n\t}\n\n\tsequencer_post_commit_cleanup(the_repository, 0);\n\tunlink(git_path_merge_head(the_repository));\n\tunlink(git_path_merge_msg(the_repository));\n\tunlink(git_path_merge_mode(the_repository));\n\tunlink(git_path_squash_msg(the_repository));\n\n\tif (commit_index_files())\n\t\tdie(_(\"repository has been updated, but unable to write\\n\"\n\t\t      \"new_index file. Check that disk is not full and quota is\\n\"\n\t\t      \"not exceeded, and then \\\"git restore --staged :/\\\" to recover.\"));\n\n\tif (git_env_bool(GIT_TEST_COMMIT_GRAPH, 0) &&\n\t    write_commit_graph_reachable(get_object_directory(), 0, NULL))\n\t\treturn 1;\n\n\trepo_rerere(the_repository, 0);\n\trun_command_v_opt(argv_gc_auto, RUN_GIT_CMD);\n\trun_commit_hook(use_editor, get_index_file(), \"post-commit\", NULL);\n\tif (amend && !no_post_rewrite) {\n\t\tcommit_post_rewrite(the_repository, current_head, &oid);\n\t}\n\tif (!quiet) {\n\t\tunsigned int flags = 0;\n\n\t\tif (!current_head)\n\t\t\tflags |= SUMMARY_INITIAL_COMMIT;\n\t\tif (author_date_is_interesting())\n\t\t\tflags |= SUMMARY_SHOW_AUTHOR_DATE;\n\t\tprint_commit_summary(the_repository, prefix,\n\t\t\t\t     &oid, flags);\n\t}\n\n\tUNLEAK(err);\n\tUNLEAK(sb);\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0078faf117e112e60244517f451ed6cbc3cf2f39",
  "sha1_ok": true,
  "size": 52071
}
