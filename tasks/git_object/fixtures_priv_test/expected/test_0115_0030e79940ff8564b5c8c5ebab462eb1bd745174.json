{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAiY29tbWl0LWdyYXBoLmgiCiNpbmNsdWRlICJwa3QtbGluZS5oIgojaW5jbHVkZSAidXRmOC5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAicmV2aXNpb24uaCIKI2luY2x1ZGUgIm5vdGVzLmgiCiNpbmNsdWRlICJncGctaW50ZXJmYWNlLmgiCiNpbmNsdWRlICJtZXJnZXNvcnQuaCIKI2luY2x1ZGUgImNvbW1pdC1zbGFiLmgiCiNpbmNsdWRlICJwcmlvLXF1ZXVlLmgiCiNpbmNsdWRlICJzaGExLWxvb2t1cC5oIgojaW5jbHVkZSAid3Qtc3RhdHVzLmgiCiNpbmNsdWRlICJhZHZpY2UuaCIKCnN0YXRpYyBzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqcmVhZF9jb21taXRfZXh0cmFfaGVhZGVyX2xpbmVzKGNvbnN0IGNoYXIgKmJ1Ziwgc2l6ZV90IGxlbiwgY29uc3QgY2hhciAqKik7CgppbnQgc2F2ZV9jb21taXRfYnVmZmVyID0gMTsKCmNvbnN0IGNoYXIgKmNvbW1pdF90eXBlID0gImNvbW1pdCI7CgpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkJCSAgICAgIGludCBxdWlldCkKewoJc3RydWN0IG9iamVjdCAqb2JqID0gZGVyZWZfdGFnKHBhcnNlX29iamVjdChvaWQpLCBOVUxMLCAwKTsKCglpZiAoIW9iaikKCQlyZXR1cm4gTlVMTDsKCXJldHVybiBvYmplY3RfYXNfdHlwZShvYmosIE9CSl9DT01NSVQsIHF1aWV0KTsKfQoKc3RydWN0IGNvbW1pdCAqbG9va3VwX2NvbW1pdF9yZWZlcmVuY2UoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglyZXR1cm4gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfZ2VudGx5KG9pZCwgMCk7Cn0KCnN0cnVjdCBjb21taXQgKmxvb2t1cF9jb21taXRfb3JfZGllKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgY29uc3QgY2hhciAqcmVmX25hbWUpCnsKCXN0cnVjdCBjb21taXQgKmMgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZShvaWQpOwoJaWYgKCFjKQoJCWRpZShfKCJjb3VsZCBub3QgcGFyc2UgJXMiKSwgcmVmX25hbWUpOwoJaWYgKG9pZGNtcChvaWQsICZjLT5vYmplY3Qub2lkKSkgewoJCXdhcm5pbmcoXygiJXMgJXMgaXMgbm90IGEgY29tbWl0ISIpLAoJCQlyZWZfbmFtZSwgb2lkX3RvX2hleChvaWQpKTsKCX0KCXJldHVybiBjOwp9CgpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJc3RydWN0IG9iamVjdCAqb2JqID0gbG9va3VwX29iamVjdChvaWQtPmhhc2gpOwoJaWYgKCFvYmopCgkJcmV0dXJuIGNyZWF0ZV9vYmplY3Qob2lkLT5oYXNoLCBhbGxvY19jb21taXRfbm9kZSgpKTsKCXJldHVybiBvYmplY3RfYXNfdHlwZShvYmosIE9CSl9DT01NSVQsIDApOwp9CgpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9ieV9uYW1lKGNvbnN0IGNoYXIgKm5hbWUpCnsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoKCWlmIChnZXRfb2lkX2NvbW1pdHRpc2gobmFtZSwgJm9pZCkpCgkJcmV0dXJuIE5VTEw7Cgljb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZSgmb2lkKTsKCWlmIChwYXJzZV9jb21taXQoY29tbWl0KSkKCQlyZXR1cm4gTlVMTDsKCXJldHVybiBjb21taXQ7Cn0KCnN0YXRpYyB0aW1lc3RhbXBfdCBwYXJzZV9jb21taXRfZGF0ZShjb25zdCBjaGFyICpidWYsIGNvbnN0IGNoYXIgKnRhaWwpCnsKCWNvbnN0IGNoYXIgKmRhdGVwdHI7CgoJaWYgKGJ1ZiArIDYgPj0gdGFpbCkKCQlyZXR1cm4gMDsKCWlmIChtZW1jbXAoYnVmLCAiYXV0aG9yIiwgNikpCgkJcmV0dXJuIDA7Cgl3aGlsZSAoYnVmIDwgdGFpbCAmJiAqYnVmKysgIT0gJ1xuJykKCQkvKiBuYWRhICovOwoJaWYgKGJ1ZiArIDkgPj0gdGFpbCkKCQlyZXR1cm4gMDsKCWlmIChtZW1jbXAoYnVmLCAiY29tbWl0dGVyIiwgOSkpCgkJcmV0dXJuIDA7Cgl3aGlsZSAoYnVmIDwgdGFpbCAmJiAqYnVmKysgIT0gJz4nKQoJCS8qIG5hZGEgKi87CglpZiAoYnVmID49IHRhaWwpCgkJcmV0dXJuIDA7CglkYXRlcHRyID0gYnVmOwoJd2hpbGUgKGJ1ZiA8IHRhaWwgJiYgKmJ1ZisrICE9ICdcbicpCgkJLyogbmFkYSAqLzsKCWlmIChidWYgPj0gdGFpbCkKCQlyZXR1cm4gMDsKCS8qIGRhdGVwdHIgPCBidWYgJiYgYnVmWy0xXSA9PSAnXG4nLCBzbyBwYXJzaW5nIHdpbGwgc3RvcCBhdCBidWYtMSAqLwoJcmV0dXJuIHBhcnNlX3RpbWVzdGFtcChkYXRlcHRyLCBOVUxMLCAxMCk7Cn0KCnN0YXRpYyBzdHJ1Y3QgY29tbWl0X2dyYWZ0ICoqY29tbWl0X2dyYWZ0OwpzdGF0aWMgaW50IGNvbW1pdF9ncmFmdF9hbGxvYywgY29tbWl0X2dyYWZ0X25yOwoKc3RhdGljIGNvbnN0IHVuc2lnbmVkIGNoYXIgKmNvbW1pdF9ncmFmdF9zaGExX2FjY2VzcyhzaXplX3QgaW5kZXgsIHZvaWQgKnRhYmxlKQp7CglzdHJ1Y3QgY29tbWl0X2dyYWZ0ICoqY29tbWl0X2dyYWZ0X3RhYmxlID0gdGFibGU7CglyZXR1cm4gY29tbWl0X2dyYWZ0X3RhYmxlW2luZGV4XS0+b2lkLmhhc2g7Cn0KCnN0YXRpYyBpbnQgY29tbWl0X2dyYWZ0X3Bvcyhjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglyZXR1cm4gc2hhMV9wb3Moc2hhMSwgY29tbWl0X2dyYWZ0LCBjb21taXRfZ3JhZnRfbnIsCgkJCWNvbW1pdF9ncmFmdF9zaGExX2FjY2Vzcyk7Cn0KCmludCByZWdpc3Rlcl9jb21taXRfZ3JhZnQoc3RydWN0IGNvbW1pdF9ncmFmdCAqZ3JhZnQsIGludCBpZ25vcmVfZHVwcykKewoJaW50IHBvcyA9IGNvbW1pdF9ncmFmdF9wb3MoZ3JhZnQtPm9pZC5oYXNoKTsKCglpZiAoMCA8PSBwb3MpIHsKCQlpZiAoaWdub3JlX2R1cHMpCgkJCWZyZWUoZ3JhZnQpOwoJCWVsc2UgewoJCQlmcmVlKGNvbW1pdF9ncmFmdFtwb3NdKTsKCQkJY29tbWl0X2dyYWZ0W3Bvc10gPSBncmFmdDsKCQl9CgkJcmV0dXJuIDE7Cgl9Cglwb3MgPSAtcG9zIC0gMTsKCUFMTE9DX0dST1coY29tbWl0X2dyYWZ0LCBjb21taXRfZ3JhZnRfbnIgKyAxLCBjb21taXRfZ3JhZnRfYWxsb2MpOwoJY29tbWl0X2dyYWZ0X25yKys7CglpZiAocG9zIDwgY29tbWl0X2dyYWZ0X25yKQoJCU1PVkVfQVJSQVkoY29tbWl0X2dyYWZ0ICsgcG9zICsgMSwgY29tbWl0X2dyYWZ0ICsgcG9zLAoJCQkgICBjb21taXRfZ3JhZnRfbnIgLSBwb3MgLSAxKTsKCWNvbW1pdF9ncmFmdFtwb3NdID0gZ3JhZnQ7CglyZXR1cm4gMDsKfQoKc3RydWN0IGNvbW1pdF9ncmFmdCAqcmVhZF9ncmFmdF9saW5lKHN0cnVjdCBzdHJidWYgKmxpbmUpCnsKCS8qIFRoZSBmb3JtYXQgaXMganVzdCAiQ29tbWl0IFBhcmVudDEgUGFyZW50MiAuLi5cbiIgKi8KCWludCBpLCBwaGFzZTsKCWNvbnN0IGNoYXIgKnRhaWwgPSBOVUxMOwoJc3RydWN0IGNvbW1pdF9ncmFmdCAqZ3JhZnQgPSBOVUxMOwoJc3RydWN0IG9iamVjdF9pZCBkdW1teV9vaWQsICpvaWQ7CgoJc3RyYnVmX3J0cmltKGxpbmUpOwoJaWYgKCFsaW5lLT5sZW4gfHwgbGluZS0+YnVmWzBdID09ICcjJykKCQlyZXR1cm4gTlVMTDsKCS8qCgkgKiBwaGFzZSAwIHZlcmlmaWVzIGxpbmUsIGNvdW50cyBoYXNoZXMgaW4gbGluZSBhbmQgYWxsb2NhdGVzIGdyYWZ0CgkgKiBwaGFzZSAxIGZpbGxzIGdyYWZ0CgkgKi8KCWZvciAocGhhc2UgPSAwOyBwaGFzZSA8IDI7IHBoYXNlKyspIHsKCQlvaWQgPSBncmFmdCA/ICZncmFmdC0+b2lkIDogJmR1bW15X29pZDsKCQlpZiAocGFyc2Vfb2lkX2hleChsaW5lLT5idWYsIG9pZCwgJnRhaWwpKQoJCQlnb3RvIGJhZF9ncmFmdF9kYXRhOwoJCWZvciAoaSA9IDA7ICp0YWlsICE9ICdcMCc7IGkrKykgewoJCQlvaWQgPSBncmFmdCA/ICZncmFmdC0+cGFyZW50W2ldIDogJmR1bW15X29pZDsKCQkJaWYgKCFpc3NwYWNlKCp0YWlsKyspIHx8IHBhcnNlX29pZF9oZXgodGFpbCwgb2lkLCAmdGFpbCkpCgkJCQlnb3RvIGJhZF9ncmFmdF9kYXRhOwoJCX0KCQlpZiAoIWdyYWZ0KSB7CgkJCWdyYWZ0ID0geG1hbGxvYyhzdF9hZGQoc2l6ZW9mKCpncmFmdCksCgkJCQkJICAgICAgIHN0X211bHQoc2l6ZW9mKHN0cnVjdCBvYmplY3RfaWQpLCBpKSkpOwoJCQlncmFmdC0+bnJfcGFyZW50ID0gaTsKCQl9Cgl9CglyZXR1cm4gZ3JhZnQ7CgpiYWRfZ3JhZnRfZGF0YToKCWVycm9yKCJiYWQgZ3JhZnQgZGF0YTogJXMiLCBsaW5lLT5idWYpOwoJYXNzZXJ0KCFncmFmdCk7CglyZXR1cm4gTlVMTDsKfQoKc3RhdGljIGludCByZWFkX2dyYWZ0X2ZpbGUoY29uc3QgY2hhciAqZ3JhZnRfZmlsZSkKewoJRklMRSAqZnAgPSBmb3Blbl9vcl93YXJuKGdyYWZ0X2ZpbGUsICJyIik7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaWYgKCFmcCkKCQlyZXR1cm4gLTE7CglpZiAoYWR2aWNlX2dyYWZ0X2ZpbGVfZGVwcmVjYXRlZCkKCQlhZHZpc2UoXygiU3VwcG9ydCBmb3IgPEdJVF9ESVI+L2luZm8vZ3JhZnRzIGlzIGRlcHJlY2F0ZWRcbiIKCQkJICJhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIEdpdCB2ZXJzaW9uLlxuIgoJCQkgIlxuIgoJCQkgIlBsZWFzZSB1c2UgXCJnaXQgcmVwbGFjZSAtLWNvbnZlcnQtZ3JhZnQtZmlsZVwiXG4iCgkJCSAidG8gY29udmVydCB0aGUgZ3JhZnRzIGludG8gcmVwbGFjZSByZWZzLlxuIgoJCQkgIlxuIgoJCQkgIlR1cm4gdGhpcyBtZXNzYWdlIG9mZiBieSBydW5uaW5nXG4iCgkJCSAiXCJnaXQgY29uZmlnIGFkdmljZS5ncmFmdEZpbGVEZXByZWNhdGVkIGZhbHNlXCIiKSk7Cgl3aGlsZSAoIXN0cmJ1Zl9nZXR3aG9sZWxpbmUoJmJ1ZiwgZnAsICdcbicpKSB7CgkJLyogVGhlIGZvcm1hdCBpcyBqdXN0ICJDb21taXQgUGFyZW50MSBQYXJlbnQyIC4uLlxuIiAqLwoJCXN0cnVjdCBjb21taXRfZ3JhZnQgKmdyYWZ0ID0gcmVhZF9ncmFmdF9saW5lKCZidWYpOwoJCWlmICghZ3JhZnQpCgkJCWNvbnRpbnVlOwoJCWlmIChyZWdpc3Rlcl9jb21taXRfZ3JhZnQoZ3JhZnQsIDEpKQoJCQllcnJvcigiZHVwbGljYXRlIGdyYWZ0IGRhdGE6ICVzIiwgYnVmLmJ1Zik7Cgl9CglmY2xvc2UoZnApOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgcHJlcGFyZV9jb21taXRfZ3JhZnQodm9pZCkKewoJc3RhdGljIGludCBjb21taXRfZ3JhZnRfcHJlcGFyZWQ7CgljaGFyICpncmFmdF9maWxlOwoKCWlmIChjb21taXRfZ3JhZnRfcHJlcGFyZWQpCgkJcmV0dXJuOwoJaWYgKCFzdGFydHVwX2luZm8tPmhhdmVfcmVwb3NpdG9yeSkKCQlyZXR1cm47CgoJZ3JhZnRfZmlsZSA9IGdldF9ncmFmdF9maWxlKCk7CglyZWFkX2dyYWZ0X2ZpbGUoZ3JhZnRfZmlsZSk7CgkvKiBtYWtlIHN1cmUgc2hhbGxvd3MgYXJlIHJlYWQgKi8KCWlzX3JlcG9zaXRvcnlfc2hhbGxvdygpOwoJY29tbWl0X2dyYWZ0X3ByZXBhcmVkID0gMTsKfQoKc3RydWN0IGNvbW1pdF9ncmFmdCAqbG9va3VwX2NvbW1pdF9ncmFmdChjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCWludCBwb3M7CglwcmVwYXJlX2NvbW1pdF9ncmFmdCgpOwoJcG9zID0gY29tbWl0X2dyYWZ0X3BvcyhvaWQtPmhhc2gpOwoJaWYgKHBvcyA8IDApCgkJcmV0dXJuIE5VTEw7CglyZXR1cm4gY29tbWl0X2dyYWZ0W3Bvc107Cn0KCmludCBmb3JfZWFjaF9jb21taXRfZ3JhZnQoZWFjaF9jb21taXRfZ3JhZnRfZm4gZm4sIHZvaWQgKmNiX2RhdGEpCnsKCWludCBpLCByZXQ7Cglmb3IgKGkgPSByZXQgPSAwOyBpIDwgY29tbWl0X2dyYWZ0X25yICYmICFyZXQ7IGkrKykKCQlyZXQgPSBmbihjb21taXRfZ3JhZnRbaV0sIGNiX2RhdGEpOwoJcmV0dXJuIHJldDsKfQoKaW50IHVucmVnaXN0ZXJfc2hhbGxvdyhjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCWludCBwb3MgPSBjb21taXRfZ3JhZnRfcG9zKG9pZC0+aGFzaCk7CglpZiAocG9zIDwgMCkKCQlyZXR1cm4gLTE7CglpZiAocG9zICsgMSA8IGNvbW1pdF9ncmFmdF9ucikKCQlNT1ZFX0FSUkFZKGNvbW1pdF9ncmFmdCArIHBvcywgY29tbWl0X2dyYWZ0ICsgcG9zICsgMSwKCQkJICAgY29tbWl0X2dyYWZ0X25yIC0gcG9zIC0gMSk7Cgljb21taXRfZ3JhZnRfbnItLTsKCXJldHVybiAwOwp9CgpzdHJ1Y3QgY29tbWl0X2J1ZmZlciB7Cgl2b2lkICpidWZmZXI7Cgl1bnNpZ25lZCBsb25nIHNpemU7Cn07CmRlZmluZV9jb21taXRfc2xhYihidWZmZXJfc2xhYiwgc3RydWN0IGNvbW1pdF9idWZmZXIpOwpzdGF0aWMgc3RydWN0IGJ1ZmZlcl9zbGFiIGJ1ZmZlcl9zbGFiID0gQ09NTUlUX1NMQUJfSU5JVCgxLCBidWZmZXJfc2xhYik7Cgp2b2lkIHNldF9jb21taXRfYnVmZmVyKHN0cnVjdCBjb21taXQgKmNvbW1pdCwgdm9pZCAqYnVmZmVyLCB1bnNpZ25lZCBsb25nIHNpemUpCnsKCXN0cnVjdCBjb21taXRfYnVmZmVyICp2ID0gYnVmZmVyX3NsYWJfYXQoJmJ1ZmZlcl9zbGFiLCBjb21taXQpOwoJdi0+YnVmZmVyID0gYnVmZmVyOwoJdi0+c2l6ZSA9IHNpemU7Cn0KCmNvbnN0IHZvaWQgKmdldF9jYWNoZWRfY29tbWl0X2J1ZmZlcihjb25zdCBzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHVuc2lnbmVkIGxvbmcgKnNpemVwKQp7CglzdHJ1Y3QgY29tbWl0X2J1ZmZlciAqdiA9IGJ1ZmZlcl9zbGFiX3BlZWsoJmJ1ZmZlcl9zbGFiLCBjb21taXQpOwoJaWYgKCF2KSB7CgkJaWYgKHNpemVwKQoJCQkqc2l6ZXAgPSAwOwoJCXJldHVybiBOVUxMOwoJfQoJaWYgKHNpemVwKQoJCSpzaXplcCA9IHYtPnNpemU7CglyZXR1cm4gdi0+YnVmZmVyOwp9Cgpjb25zdCB2b2lkICpnZXRfY29tbWl0X2J1ZmZlcihjb25zdCBzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHVuc2lnbmVkIGxvbmcgKnNpemVwKQp7Cgljb25zdCB2b2lkICpyZXQgPSBnZXRfY2FjaGVkX2NvbW1pdF9idWZmZXIoY29tbWl0LCBzaXplcCk7CglpZiAoIXJldCkgewoJCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCQl1bnNpZ25lZCBsb25nIHNpemU7CgkJcmV0ID0gcmVhZF9vYmplY3RfZmlsZSgmY29tbWl0LT5vYmplY3Qub2lkLCAmdHlwZSwgJnNpemUpOwoJCWlmICghcmV0KQoJCQlkaWUoImNhbm5vdCByZWFkIGNvbW1pdCBvYmplY3QgJXMiLAoJCQkgICAgb2lkX3RvX2hleCgmY29tbWl0LT5vYmplY3Qub2lkKSk7CgkJaWYgKHR5cGUgIT0gT0JKX0NPTU1JVCkKCQkJZGllKCJleHBlY3RlZCBjb21taXQgZm9yICVzLCBnb3QgJXMiLAoJCQkgICAgb2lkX3RvX2hleCgmY29tbWl0LT5vYmplY3Qub2lkKSwgdHlwZV9uYW1lKHR5cGUpKTsKCQlpZiAoc2l6ZXApCgkJCSpzaXplcCA9IHNpemU7Cgl9CglyZXR1cm4gcmV0Owp9Cgp2b2lkIHVudXNlX2NvbW1pdF9idWZmZXIoY29uc3Qgc3RydWN0IGNvbW1pdCAqY29tbWl0LCBjb25zdCB2b2lkICpidWZmZXIpCnsKCXN0cnVjdCBjb21taXRfYnVmZmVyICp2ID0gYnVmZmVyX3NsYWJfcGVlaygmYnVmZmVyX3NsYWIsIGNvbW1pdCk7CglpZiAoISh2ICYmIHYtPmJ1ZmZlciA9PSBidWZmZXIpKQoJCWZyZWUoKHZvaWQgKilidWZmZXIpOwp9Cgp2b2lkIGZyZWVfY29tbWl0X2J1ZmZlcihzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCXN0cnVjdCBjb21taXRfYnVmZmVyICp2ID0gYnVmZmVyX3NsYWJfcGVlaygmYnVmZmVyX3NsYWIsIGNvbW1pdCk7CglpZiAodikgewoJCUZSRUVfQU5EX05VTEwodi0+YnVmZmVyKTsKCQl2LT5zaXplID0gMDsKCX0KfQoKc3RydWN0IHRyZWUgKmdldF9jb21taXRfdHJlZShjb25zdCBzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCWlmIChjb21taXQtPm1heWJlX3RyZWUgfHwgIWNvbW1pdC0+b2JqZWN0LnBhcnNlZCkKCQlyZXR1cm4gY29tbWl0LT5tYXliZV90cmVlOwoKCWlmIChjb21taXQtPmdyYXBoX3BvcyA9PSBDT01NSVRfTk9UX0ZST01fR1JBUEgpCgkJQlVHKCJjb21taXQgaGFzIE5VTEwgdHJlZSwgYnV0IHdhcyBub3QgbG9hZGVkIGZyb20gY29tbWl0LWdyYXBoIik7CgoJcmV0dXJuIGdldF9jb21taXRfdHJlZV9pbl9ncmFwaChjb21taXQpOwp9CgpzdHJ1Y3Qgb2JqZWN0X2lkICpnZXRfY29tbWl0X3RyZWVfb2lkKGNvbnN0IHN0cnVjdCBjb21taXQgKmNvbW1pdCkKewoJcmV0dXJuICZnZXRfY29tbWl0X3RyZWUoY29tbWl0KS0+b2JqZWN0Lm9pZDsKfQoKY29uc3Qgdm9pZCAqZGV0YWNoX2NvbW1pdF9idWZmZXIoc3RydWN0IGNvbW1pdCAqY29tbWl0LCB1bnNpZ25lZCBsb25nICpzaXplcCkKewoJc3RydWN0IGNvbW1pdF9idWZmZXIgKnYgPSBidWZmZXJfc2xhYl9wZWVrKCZidWZmZXJfc2xhYiwgY29tbWl0KTsKCXZvaWQgKnJldDsKCglpZiAoIXYpIHsKCQlpZiAoc2l6ZXApCgkJCSpzaXplcCA9IDA7CgkJcmV0dXJuIE5VTEw7Cgl9CglyZXQgPSB2LT5idWZmZXI7CglpZiAoc2l6ZXApCgkJKnNpemVwID0gdi0+c2l6ZTsKCgl2LT5idWZmZXIgPSBOVUxMOwoJdi0+c2l6ZSA9IDA7CglyZXR1cm4gcmV0Owp9CgppbnQgcGFyc2VfY29tbWl0X2J1ZmZlcihzdHJ1Y3QgY29tbWl0ICppdGVtLCBjb25zdCB2b2lkICpidWZmZXIsIHVuc2lnbmVkIGxvbmcgc2l6ZSkKewoJY29uc3QgY2hhciAqdGFpbCA9IGJ1ZmZlcjsKCWNvbnN0IGNoYXIgKmJ1ZnB0ciA9IGJ1ZmZlcjsKCXN0cnVjdCBvYmplY3RfaWQgcGFyZW50OwoJc3RydWN0IGNvbW1pdF9saXN0ICoqcHB0cjsKCXN0cnVjdCBjb21taXRfZ3JhZnQgKmdyYWZ0OwoJY29uc3QgaW50IHRyZWVfZW50cnlfbGVuID0gR0lUX1NIQTFfSEVYU1ogKyA1OwoJY29uc3QgaW50IHBhcmVudF9lbnRyeV9sZW4gPSBHSVRfU0hBMV9IRVhTWiArIDc7CgoJaWYgKGl0ZW0tPm9iamVjdC5wYXJzZWQpCgkJcmV0dXJuIDA7CglpdGVtLT5vYmplY3QucGFyc2VkID0gMTsKCXRhaWwgKz0gc2l6ZTsKCWlmICh0YWlsIDw9IGJ1ZnB0ciArIHRyZWVfZW50cnlfbGVuICsgMSB8fCBtZW1jbXAoYnVmcHRyLCAidHJlZSAiLCA1KSB8fAoJCQlidWZwdHJbdHJlZV9lbnRyeV9sZW5dICE9ICdcbicpCgkJcmV0dXJuIGVycm9yKCJib2d1cyBjb21taXQgb2JqZWN0ICVzIiwgb2lkX3RvX2hleCgmaXRlbS0+b2JqZWN0Lm9pZCkpOwoJaWYgKGdldF9vaWRfaGV4KGJ1ZnB0ciArIDUsICZwYXJlbnQpIDwgMCkKCQlyZXR1cm4gZXJyb3IoImJhZCB0cmVlIHBvaW50ZXIgaW4gY29tbWl0ICVzIiwKCQkJICAgICBvaWRfdG9faGV4KCZpdGVtLT5vYmplY3Qub2lkKSk7CglpdGVtLT5tYXliZV90cmVlID0gbG9va3VwX3RyZWUoJnBhcmVudCk7CglidWZwdHIgKz0gdHJlZV9lbnRyeV9sZW4gKyAxOyAvKiAidHJlZSAiICsgImhleCBzaGExIiArICJcbiIgKi8KCXBwdHIgPSAmaXRlbS0+cGFyZW50czsKCglncmFmdCA9IGxvb2t1cF9jb21taXRfZ3JhZnQoJml0ZW0tPm9iamVjdC5vaWQpOwoJd2hpbGUgKGJ1ZnB0ciArIHBhcmVudF9lbnRyeV9sZW4gPCB0YWlsICYmICFtZW1jbXAoYnVmcHRyLCAicGFyZW50ICIsIDcpKSB7CgkJc3RydWN0IGNvbW1pdCAqbmV3X3BhcmVudDsKCgkJaWYgKHRhaWwgPD0gYnVmcHRyICsgcGFyZW50X2VudHJ5X2xlbiArIDEgfHwKCQkgICAgZ2V0X29pZF9oZXgoYnVmcHRyICsgNywgJnBhcmVudCkgfHwKCQkgICAgYnVmcHRyW3BhcmVudF9lbnRyeV9sZW5dICE9ICdcbicpCgkJCXJldHVybiBlcnJvcigiYmFkIHBhcmVudHMgaW4gY29tbWl0ICVzIiwgb2lkX3RvX2hleCgmaXRlbS0+b2JqZWN0Lm9pZCkpOwoJCWJ1ZnB0ciArPSBwYXJlbnRfZW50cnlfbGVuICsgMTsKCQkvKgoJCSAqIFRoZSBjbG9uZSBpcyBzaGFsbG93IGlmIG5yX3BhcmVudCA8IDAsIGFuZCB3ZSBtdXN0CgkJICogbm90IHRyYXZlcnNlIGl0cyByZWFsIHBhcmVudHMgZXZlbiB3aGVuIHdlIHVuaGlkZSB0aGVtLgoJCSAqLwoJCWlmIChncmFmdCAmJiAoZ3JhZnQtPm5yX3BhcmVudCA8IDAgfHwgZ3JhZnRzX3JlcGxhY2VfcGFyZW50cykpCgkJCWNvbnRpbnVlOwoJCW5ld19wYXJlbnQgPSBsb29rdXBfY29tbWl0KCZwYXJlbnQpOwoJCWlmIChuZXdfcGFyZW50KQoJCQlwcHRyID0gJmNvbW1pdF9saXN0X2luc2VydChuZXdfcGFyZW50LCBwcHRyKS0+bmV4dDsKCX0KCWlmIChncmFmdCkgewoJCWludCBpOwoJCXN0cnVjdCBjb21taXQgKm5ld19wYXJlbnQ7CgkJZm9yIChpID0gMDsgaSA8IGdyYWZ0LT5ucl9wYXJlbnQ7IGkrKykgewoJCQluZXdfcGFyZW50ID0gbG9va3VwX2NvbW1pdCgmZ3JhZnQtPnBhcmVudFtpXSk7CgkJCWlmICghbmV3X3BhcmVudCkKCQkJCWNvbnRpbnVlOwoJCQlwcHRyID0gJmNvbW1pdF9saXN0X2luc2VydChuZXdfcGFyZW50LCBwcHRyKS0+bmV4dDsKCQl9Cgl9CglpdGVtLT5kYXRlID0gcGFyc2VfY29tbWl0X2RhdGUoYnVmcHRyLCB0YWlsKTsKCglyZXR1cm4gMDsKfQoKaW50IHBhcnNlX2NvbW1pdF9nZW50bHkoc3RydWN0IGNvbW1pdCAqaXRlbSwgaW50IHF1aWV0X29uX21pc3NpbmcpCnsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCXZvaWQgKmJ1ZmZlcjsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCWludCByZXQ7CgoJaWYgKCFpdGVtKQoJCXJldHVybiAtMTsKCWlmIChpdGVtLT5vYmplY3QucGFyc2VkKQoJCXJldHVybiAwOwoJaWYgKHBhcnNlX2NvbW1pdF9pbl9ncmFwaChpdGVtKSkKCQlyZXR1cm4gMDsKCWJ1ZmZlciA9IHJlYWRfb2JqZWN0X2ZpbGUoJml0ZW0tPm9iamVjdC5vaWQsICZ0eXBlLCAmc2l6ZSk7CglpZiAoIWJ1ZmZlcikKCQlyZXR1cm4gcXVpZXRfb25fbWlzc2luZyA/IC0xIDoKCQkJZXJyb3IoIkNvdWxkIG5vdCByZWFkICVzIiwKCQkJICAgICBvaWRfdG9faGV4KCZpdGVtLT5vYmplY3Qub2lkKSk7CglpZiAodHlwZSAhPSBPQkpfQ09NTUlUKSB7CgkJZnJlZShidWZmZXIpOwoJCXJldHVybiBlcnJvcigiT2JqZWN0ICVzIG5vdCBhIGNvbW1pdCIsCgkJCSAgICAgb2lkX3RvX2hleCgmaXRlbS0+b2JqZWN0Lm9pZCkpOwoJfQoJcmV0ID0gcGFyc2VfY29tbWl0X2J1ZmZlcihpdGVtLCBidWZmZXIsIHNpemUpOwoJaWYgKHNhdmVfY29tbWl0X2J1ZmZlciAmJiAhcmV0KSB7CgkJc2V0X2NvbW1pdF9idWZmZXIoaXRlbSwgYnVmZmVyLCBzaXplKTsKCQlyZXR1cm4gMDsKCX0KCWZyZWUoYnVmZmVyKTsKCXJldHVybiByZXQ7Cn0KCnZvaWQgcGFyc2VfY29tbWl0X29yX2RpZShzdHJ1Y3QgY29tbWl0ICppdGVtKQp7CglpZiAocGFyc2VfY29tbWl0KGl0ZW0pKQoJCWRpZSgidW5hYmxlIHRvIHBhcnNlIGNvbW1pdCAlcyIsCgkJICAgIGl0ZW0gPyBvaWRfdG9faGV4KCZpdGVtLT5vYmplY3Qub2lkKSA6ICIobnVsbCkiKTsKfQoKaW50IGZpbmRfY29tbWl0X3N1YmplY3QoY29uc3QgY2hhciAqY29tbWl0X2J1ZmZlciwgY29uc3QgY2hhciAqKnN1YmplY3QpCnsKCWNvbnN0IGNoYXIgKmVvbDsKCWNvbnN0IGNoYXIgKnAgPSBjb21taXRfYnVmZmVyOwoKCXdoaWxlICgqcCAmJiAoKnAgIT0gJ1xuJyB8fCBwWzFdICE9ICdcbicpKQoJCXArKzsKCWlmICgqcCkgewoJCXAgPSBza2lwX2JsYW5rX2xpbmVzKHAgKyAyKTsKCQllb2wgPSBzdHJjaHJudWwocCwgJ1xuJyk7Cgl9IGVsc2UKCQllb2wgPSBwOwoKCSpzdWJqZWN0ID0gcDsKCglyZXR1cm4gZW9sIC0gcDsKfQoKc3RydWN0IGNvbW1pdF9saXN0ICpjb21taXRfbGlzdF9pbnNlcnQoc3RydWN0IGNvbW1pdCAqaXRlbSwgc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdF9wKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKm5ld19saXN0ID0geG1hbGxvYyhzaXplb2Yoc3RydWN0IGNvbW1pdF9saXN0KSk7CgluZXdfbGlzdC0+aXRlbSA9IGl0ZW07CgluZXdfbGlzdC0+bmV4dCA9ICpsaXN0X3A7CgkqbGlzdF9wID0gbmV3X2xpc3Q7CglyZXR1cm4gbmV3X2xpc3Q7Cn0KCnVuc2lnbmVkIGNvbW1pdF9saXN0X2NvdW50KGNvbnN0IHN0cnVjdCBjb21taXRfbGlzdCAqbCkKewoJdW5zaWduZWQgYyA9IDA7Cglmb3IgKDsgbDsgbCA9IGwtPm5leHQgKQoJCWMrKzsKCXJldHVybiBjOwp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKmNvcHlfY29tbWl0X2xpc3Qoc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0KQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKmhlYWQgPSBOVUxMOwoJc3RydWN0IGNvbW1pdF9saXN0ICoqcHAgPSAmaGVhZDsKCXdoaWxlIChsaXN0KSB7CgkJcHAgPSBjb21taXRfbGlzdF9hcHBlbmQobGlzdC0+aXRlbSwgcHApOwoJCWxpc3QgPSBsaXN0LT5uZXh0OwoJfQoJcmV0dXJuIGhlYWQ7Cn0KCnZvaWQgZnJlZV9jb21taXRfbGlzdChzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QpCnsKCXdoaWxlIChsaXN0KQoJCXBvcF9jb21taXQoJmxpc3QpOwp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKiBjb21taXRfbGlzdF9pbnNlcnRfYnlfZGF0ZShzdHJ1Y3QgY29tbWl0ICppdGVtLCBzdHJ1Y3QgY29tbWl0X2xpc3QgKipsaXN0KQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKipwcCA9IGxpc3Q7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnA7Cgl3aGlsZSAoKHAgPSAqcHApICE9IE5VTEwpIHsKCQlpZiAocC0+aXRlbS0+ZGF0ZSA8IGl0ZW0tPmRhdGUpIHsKCQkJYnJlYWs7CgkJfQoJCXBwID0gJnAtPm5leHQ7Cgl9CglyZXR1cm4gY29tbWl0X2xpc3RfaW5zZXJ0KGl0ZW0sIHBwKTsKfQoKc3RhdGljIGludCBjb21taXRfbGlzdF9jb21wYXJlX2J5X2RhdGUoY29uc3Qgdm9pZCAqYSwgY29uc3Qgdm9pZCAqYikKewoJdGltZXN0YW1wX3QgYV9kYXRlID0gKChjb25zdCBzdHJ1Y3QgY29tbWl0X2xpc3QgKilhKS0+aXRlbS0+ZGF0ZTsKCXRpbWVzdGFtcF90IGJfZGF0ZSA9ICgoY29uc3Qgc3RydWN0IGNvbW1pdF9saXN0ICopYiktPml0ZW0tPmRhdGU7CglpZiAoYV9kYXRlIDwgYl9kYXRlKQoJCXJldHVybiAxOwoJaWYgKGFfZGF0ZSA+IGJfZGF0ZSkKCQlyZXR1cm4gLTE7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgKmNvbW1pdF9saXN0X2dldF9uZXh0KGNvbnN0IHZvaWQgKmEpCnsKCXJldHVybiAoKGNvbnN0IHN0cnVjdCBjb21taXRfbGlzdCAqKWEpLT5uZXh0Owp9CgpzdGF0aWMgdm9pZCBjb21taXRfbGlzdF9zZXRfbmV4dCh2b2lkICphLCB2b2lkICpuZXh0KQp7CgkoKHN0cnVjdCBjb21taXRfbGlzdCAqKWEpLT5uZXh0ID0gbmV4dDsKfQoKdm9pZCBjb21taXRfbGlzdF9zb3J0X2J5X2RhdGUoc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCkKewoJKmxpc3QgPSBsbGlzdF9tZXJnZXNvcnQoKmxpc3QsIGNvbW1pdF9saXN0X2dldF9uZXh0LCBjb21taXRfbGlzdF9zZXRfbmV4dCwKCQkJCWNvbW1pdF9saXN0X2NvbXBhcmVfYnlfZGF0ZSk7Cn0KCnN0cnVjdCBjb21taXQgKnBvcF9tb3N0X3JlY2VudF9jb21taXQoc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCwKCQkJCSAgICAgIHVuc2lnbmVkIGludCBtYXJrKQp7CglzdHJ1Y3QgY29tbWl0ICpyZXQgPSBwb3BfY29tbWl0KGxpc3QpOwoJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzID0gcmV0LT5wYXJlbnRzOwoKCXdoaWxlIChwYXJlbnRzKSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gcGFyZW50cy0+aXRlbTsKCQlpZiAoIXBhcnNlX2NvbW1pdChjb21taXQpICYmICEoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBtYXJrKSkgewoJCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBtYXJrOwoJCQljb21taXRfbGlzdF9pbnNlcnRfYnlfZGF0ZShjb21taXQsIGxpc3QpOwoJCX0KCQlwYXJlbnRzID0gcGFyZW50cy0+bmV4dDsKCX0KCXJldHVybiByZXQ7Cn0KCnN0YXRpYyB2b2lkIGNsZWFyX2NvbW1pdF9tYXJrc18xKHN0cnVjdCBjb21taXRfbGlzdCAqKnBsaXN0LAoJCQkJIHN0cnVjdCBjb21taXQgKmNvbW1pdCwgdW5zaWduZWQgaW50IG1hcmspCnsKCXdoaWxlIChjb21taXQpIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHM7CgoJCWlmICghKG1hcmsgJiBjb21taXQtPm9iamVjdC5mbGFncykpCgkJCXJldHVybjsKCgkJY29tbWl0LT5vYmplY3QuZmxhZ3MgJj0gfm1hcms7CgoJCXBhcmVudHMgPSBjb21taXQtPnBhcmVudHM7CgkJaWYgKCFwYXJlbnRzKQoJCQlyZXR1cm47CgoJCXdoaWxlICgocGFyZW50cyA9IHBhcmVudHMtPm5leHQpKQoJCQljb21taXRfbGlzdF9pbnNlcnQocGFyZW50cy0+aXRlbSwgcGxpc3QpOwoKCQljb21taXQgPSBjb21taXQtPnBhcmVudHMtPml0ZW07Cgl9Cn0KCnZvaWQgY2xlYXJfY29tbWl0X21hcmtzX21hbnkoaW50IG5yLCBzdHJ1Y3QgY29tbWl0ICoqY29tbWl0LCB1bnNpZ25lZCBpbnQgbWFyaykKewoJc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0ID0gTlVMTDsKCgl3aGlsZSAobnItLSkgewoJCWNsZWFyX2NvbW1pdF9tYXJrc18xKCZsaXN0LCAqY29tbWl0LCBtYXJrKTsKCQljb21taXQrKzsKCX0KCXdoaWxlIChsaXN0KQoJCWNsZWFyX2NvbW1pdF9tYXJrc18xKCZsaXN0LCBwb3BfY29tbWl0KCZsaXN0KSwgbWFyayk7Cn0KCnZvaWQgY2xlYXJfY29tbWl0X21hcmtzKHN0cnVjdCBjb21taXQgKmNvbW1pdCwgdW5zaWduZWQgaW50IG1hcmspCnsKCWNsZWFyX2NvbW1pdF9tYXJrc19tYW55KDEsICZjb21taXQsIG1hcmspOwp9CgpzdHJ1Y3QgY29tbWl0ICpwb3BfY29tbWl0KHN0cnVjdCBjb21taXRfbGlzdCAqKnN0YWNrKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnRvcCA9ICpzdGFjazsKCXN0cnVjdCBjb21taXQgKml0ZW0gPSB0b3AgPyB0b3AtPml0ZW0gOiBOVUxMOwoKCWlmICh0b3ApIHsKCQkqc3RhY2sgPSB0b3AtPm5leHQ7CgkJZnJlZSh0b3ApOwoJfQoJcmV0dXJuIGl0ZW07Cn0KCi8qCiAqIFRvcG9sb2dpY2FsIHNvcnQgc3VwcG9ydAogKi8KCi8qIGNvdW50IG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGhhdmUgbm90IGJlZW4gZW1pdHRlZCAqLwpkZWZpbmVfY29tbWl0X3NsYWIoaW5kZWdyZWVfc2xhYiwgaW50KTsKCi8qIHJlY29yZCBhdXRob3ItZGF0ZSBmb3IgZWFjaCBjb21taXQgb2JqZWN0ICovCmRlZmluZV9jb21taXRfc2xhYihhdXRob3JfZGF0ZV9zbGFiLCB1bnNpZ25lZCBsb25nKTsKCnN0YXRpYyB2b2lkIHJlY29yZF9hdXRob3JfZGF0ZShzdHJ1Y3QgYXV0aG9yX2RhdGVfc2xhYiAqYXV0aG9yX2RhdGUsCgkJCSAgICAgICBzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCWNvbnN0IGNoYXIgKmJ1ZmZlciA9IGdldF9jb21taXRfYnVmZmVyKGNvbW1pdCwgTlVMTCk7CglzdHJ1Y3QgaWRlbnRfc3BsaXQgaWRlbnQ7Cgljb25zdCBjaGFyICppZGVudF9saW5lOwoJc2l6ZV90IGlkZW50X2xlbjsKCWNoYXIgKmRhdGVfZW5kOwoJdGltZXN0YW1wX3QgZGF0ZTsKCglpZGVudF9saW5lID0gZmluZF9jb21taXRfaGVhZGVyKGJ1ZmZlciwgImF1dGhvciIsICZpZGVudF9sZW4pOwoJaWYgKCFpZGVudF9saW5lKQoJCWdvdG8gZmFpbF9leGl0OyAvKiBubyBhdXRob3IgbGluZSAqLwoJaWYgKHNwbGl0X2lkZW50X2xpbmUoJmlkZW50LCBpZGVudF9saW5lLCBpZGVudF9sZW4pIHx8CgkgICAgIWlkZW50LmRhdGVfYmVnaW4gfHwgIWlkZW50LmRhdGVfZW5kKQoJCWdvdG8gZmFpbF9leGl0OyAvKiBtYWxmb3JtZWQgImF1dGhvciIgbGluZSAqLwoKCWRhdGUgPSBwYXJzZV90aW1lc3RhbXAoaWRlbnQuZGF0ZV9iZWdpbiwgJmRhdGVfZW5kLCAxMCk7CglpZiAoZGF0ZV9lbmQgIT0gaWRlbnQuZGF0ZV9lbmQpCgkJZ290byBmYWlsX2V4aXQ7IC8qIG1hbGZvcm1lZCBkYXRlICovCgkqKGF1dGhvcl9kYXRlX3NsYWJfYXQoYXV0aG9yX2RhdGUsIGNvbW1pdCkpID0gZGF0ZTsKCmZhaWxfZXhpdDoKCXVudXNlX2NvbW1pdF9idWZmZXIoY29tbWl0LCBidWZmZXIpOwp9CgpzdGF0aWMgaW50IGNvbXBhcmVfY29tbWl0c19ieV9hdXRob3JfZGF0ZShjb25zdCB2b2lkICphXywgY29uc3Qgdm9pZCAqYl8sCgkJCQkJICB2b2lkICpjYl9kYXRhKQp7Cgljb25zdCBzdHJ1Y3QgY29tbWl0ICphID0gYV8sICpiID0gYl87CglzdHJ1Y3QgYXV0aG9yX2RhdGVfc2xhYiAqYXV0aG9yX2RhdGUgPSBjYl9kYXRhOwoJdGltZXN0YW1wX3QgYV9kYXRlID0gKihhdXRob3JfZGF0ZV9zbGFiX2F0KGF1dGhvcl9kYXRlLCBhKSk7Cgl0aW1lc3RhbXBfdCBiX2RhdGUgPSAqKGF1dGhvcl9kYXRlX3NsYWJfYXQoYXV0aG9yX2RhdGUsIGIpKTsKCgkvKiBuZXdlciBjb21taXRzIHdpdGggbGFyZ2VyIGRhdGUgZmlyc3QgKi8KCWlmIChhX2RhdGUgPCBiX2RhdGUpCgkJcmV0dXJuIDE7CgllbHNlIGlmIChhX2RhdGUgPiBiX2RhdGUpCgkJcmV0dXJuIC0xOwoJcmV0dXJuIDA7Cn0KCmludCBjb21wYXJlX2NvbW1pdHNfYnlfY29tbWl0X2RhdGUoY29uc3Qgdm9pZCAqYV8sIGNvbnN0IHZvaWQgKmJfLCB2b2lkICp1bnVzZWQpCnsKCWNvbnN0IHN0cnVjdCBjb21taXQgKmEgPSBhXywgKmIgPSBiXzsKCS8qIG5ld2VyIGNvbW1pdHMgd2l0aCBsYXJnZXIgZGF0ZSBmaXJzdCAqLwoJaWYgKGEtPmRhdGUgPCBiLT5kYXRlKQoJCXJldHVybiAxOwoJZWxzZSBpZiAoYS0+ZGF0ZSA+IGItPmRhdGUpCgkJcmV0dXJuIC0xOwoJcmV0dXJuIDA7Cn0KCi8qCiAqIFBlcmZvcm1zIGFuIGluLXBsYWNlIHRvcG9sb2dpY2FsIHNvcnQgb24gdGhlIGxpc3Qgc3VwcGxpZWQuCiAqLwp2b2lkIHNvcnRfaW5fdG9wb2xvZ2ljYWxfb3JkZXIoc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCwgZW51bSByZXZfc29ydF9vcmRlciBzb3J0X29yZGVyKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKm5leHQsICpvcmlnID0gKmxpc3Q7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKipwcHRyOwoJc3RydWN0IGluZGVncmVlX3NsYWIgaW5kZWdyZWU7CglzdHJ1Y3QgcHJpb19xdWV1ZSBxdWV1ZTsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCXN0cnVjdCBhdXRob3JfZGF0ZV9zbGFiIGF1dGhvcl9kYXRlOwoKCWlmICghb3JpZykKCQlyZXR1cm47CgkqbGlzdCA9IE5VTEw7CgoJaW5pdF9pbmRlZ3JlZV9zbGFiKCZpbmRlZ3JlZSk7CgltZW1zZXQoJnF1ZXVlLCAnXDAnLCBzaXplb2YocXVldWUpKTsKCglzd2l0Y2ggKHNvcnRfb3JkZXIpIHsKCWRlZmF1bHQ6IC8qIFJFVl9TT1JUX0lOX0dSQVBIX09SREVSICovCgkJcXVldWUuY29tcGFyZSA9IE5VTEw7CgkJYnJlYWs7CgljYXNlIFJFVl9TT1JUX0JZX0NPTU1JVF9EQVRFOgoJCXF1ZXVlLmNvbXBhcmUgPSBjb21wYXJlX2NvbW1pdHNfYnlfY29tbWl0X2RhdGU7CgkJYnJlYWs7CgljYXNlIFJFVl9TT1JUX0JZX0FVVEhPUl9EQVRFOgoJCWluaXRfYXV0aG9yX2RhdGVfc2xhYigmYXV0aG9yX2RhdGUpOwoJCXF1ZXVlLmNvbXBhcmUgPSBjb21wYXJlX2NvbW1pdHNfYnlfYXV0aG9yX2RhdGU7CgkJcXVldWUuY2JfZGF0YSA9ICZhdXRob3JfZGF0ZTsKCQlicmVhazsKCX0KCgkvKiBNYXJrIHRoZW0gYW5kIGNsZWFyIHRoZSBpbmRlZ3JlZSAqLwoJZm9yIChuZXh0ID0gb3JpZzsgbmV4dDsgbmV4dCA9IG5leHQtPm5leHQpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBuZXh0LT5pdGVtOwoJCSooaW5kZWdyZWVfc2xhYl9hdCgmaW5kZWdyZWUsIGNvbW1pdCkpID0gMTsKCQkvKiBhbHNvIHJlY29yZCB0aGUgYXV0aG9yIGRhdGVzLCBpZiBuZWVkZWQgKi8KCQlpZiAoc29ydF9vcmRlciA9PSBSRVZfU09SVF9CWV9BVVRIT1JfREFURSkKCQkJcmVjb3JkX2F1dGhvcl9kYXRlKCZhdXRob3JfZGF0ZSwgY29tbWl0KTsKCX0KCgkvKiB1cGRhdGUgdGhlIGluZGVncmVlICovCglmb3IgKG5leHQgPSBvcmlnOyBuZXh0OyBuZXh0ID0gbmV4dC0+bmV4dCkgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50cyA9IG5leHQtPml0ZW0tPnBhcmVudHM7CgkJd2hpbGUgKHBhcmVudHMpIHsKCQkJc3RydWN0IGNvbW1pdCAqcGFyZW50ID0gcGFyZW50cy0+aXRlbTsKCQkJaW50ICpwaSA9IGluZGVncmVlX3NsYWJfYXQoJmluZGVncmVlLCBwYXJlbnQpOwoKCQkJaWYgKCpwaSkKCQkJCSgqcGkpKys7CgkJCXBhcmVudHMgPSBwYXJlbnRzLT5uZXh0OwoJCX0KCX0KCgkvKgoJICogZmluZCB0aGUgdGlwcwoJICoKCSAqIHRpcHMgYXJlIG5vZGVzIG5vdCByZWFjaGFibGUgZnJvbSBhbnkgb3RoZXIgbm9kZSBpbiB0aGUgbGlzdAoJICoKCSAqIHRoZSB0aXBzIHNlcnZlIGFzIGEgc3RhcnRpbmcgc2V0IGZvciB0aGUgd29yayBxdWV1ZS4KCSAqLwoJZm9yIChuZXh0ID0gb3JpZzsgbmV4dDsgbmV4dCA9IG5leHQtPm5leHQpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBuZXh0LT5pdGVtOwoKCQlpZiAoKihpbmRlZ3JlZV9zbGFiX2F0KCZpbmRlZ3JlZSwgY29tbWl0KSkgPT0gMSkKCQkJcHJpb19xdWV1ZV9wdXQoJnF1ZXVlLCBjb21taXQpOwoJfQoKCS8qCgkgKiBUaGlzIGlzIHVuZm9ydHVuYXRlOyB0aGUgaW5pdGlhbCB0aXBzIG5lZWQgdG8gYmUgc2hvd24KCSAqIGluIHRoZSBvcmRlciBnaXZlbiBmcm9tIHRoZSByZXZpc2lvbiB0cmF2ZXJzYWwgbWFjaGluZXJ5LgoJICovCglpZiAoc29ydF9vcmRlciA9PSBSRVZfU09SVF9JTl9HUkFQSF9PUkRFUikKCQlwcmlvX3F1ZXVlX3JldmVyc2UoJnF1ZXVlKTsKCgkvKiBXZSBubyBsb25nZXIgbmVlZCB0aGUgY29tbWl0IGxpc3QgKi8KCWZyZWVfY29tbWl0X2xpc3Qob3JpZyk7CgoJcHB0ciA9IGxpc3Q7CgkqbGlzdCA9IE5VTEw7Cgl3aGlsZSAoKGNvbW1pdCA9IHByaW9fcXVldWVfZ2V0KCZxdWV1ZSkpICE9IE5VTEwpIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHM7CgoJCWZvciAocGFyZW50cyA9IGNvbW1pdC0+cGFyZW50czsgcGFyZW50cyA7IHBhcmVudHMgPSBwYXJlbnRzLT5uZXh0KSB7CgkJCXN0cnVjdCBjb21taXQgKnBhcmVudCA9IHBhcmVudHMtPml0ZW07CgkJCWludCAqcGkgPSBpbmRlZ3JlZV9zbGFiX2F0KCZpbmRlZ3JlZSwgcGFyZW50KTsKCgkJCWlmICghKnBpKQoJCQkJY29udGludWU7CgoJCQkvKgoJCQkgKiBwYXJlbnRzIGFyZSBvbmx5IGVucXVldWVkIGZvciBlbWlzc2lvbgoJCQkgKiB3aGVuIGFsbCB0aGVpciBjaGlsZHJlbiBoYXZlIGJlZW4gZW1pdHRlZCB0aGVyZWJ5CgkJCSAqIGd1YXJhbnRlZWluZyB0b3BvbG9naWNhbCBvcmRlci4KCQkJICovCgkJCWlmICgtLSgqcGkpID09IDEpCgkJCQlwcmlvX3F1ZXVlX3B1dCgmcXVldWUsIHBhcmVudCk7CgkJfQoJCS8qCgkJICogYWxsIGNoaWxkcmVuIG9mIGNvbW1pdCBoYXZlIGFscmVhZHkgYmVlbgoJCSAqIGVtaXR0ZWQuIHdlIGNhbiBlbWl0IGl0IG5vdy4KCQkgKi8KCQkqKGluZGVncmVlX3NsYWJfYXQoJmluZGVncmVlLCBjb21taXQpKSA9IDA7CgoJCXBwdHIgPSAmY29tbWl0X2xpc3RfaW5zZXJ0KGNvbW1pdCwgcHB0ciktPm5leHQ7Cgl9CgoJY2xlYXJfaW5kZWdyZWVfc2xhYigmaW5kZWdyZWUpOwoJY2xlYXJfcHJpb19xdWV1ZSgmcXVldWUpOwoJaWYgKHNvcnRfb3JkZXIgPT0gUkVWX1NPUlRfQllfQVVUSE9SX0RBVEUpCgkJY2xlYXJfYXV0aG9yX2RhdGVfc2xhYigmYXV0aG9yX2RhdGUpOwp9CgovKiBtZXJnZS1iYXNlIHN0dWZmICovCgovKiBSZW1lbWJlciB0byB1cGRhdGUgb2JqZWN0IGZsYWcgYWxsb2NhdGlvbiBpbiBvYmplY3QuaCAqLwojZGVmaW5lIFBBUkVOVDEJCSgxdTw8MTYpCiNkZWZpbmUgUEFSRU5UMgkJKDF1PDwxNykKI2RlZmluZSBTVEFMRQkJKDF1PDwxOCkKI2RlZmluZSBSRVNVTFQJCSgxdTw8MTkpCgpzdGF0aWMgY29uc3QgdW5zaWduZWQgYWxsX2ZsYWdzID0gKFBBUkVOVDEgfCBQQVJFTlQyIHwgU1RBTEUgfCBSRVNVTFQpOwoKc3RhdGljIGludCBxdWV1ZV9oYXNfbm9uc3RhbGUoc3RydWN0IHByaW9fcXVldWUgKnF1ZXVlKQp7CglpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCBxdWV1ZS0+bnI7IGkrKykgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IHF1ZXVlLT5hcnJheVtpXS5kYXRhOwoJCWlmICghKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgU1RBTEUpKQoJCQlyZXR1cm4gMTsKCX0KCXJldHVybiAwOwp9CgovKiBhbGwgaW5wdXQgY29tbWl0cyBpbiBvbmUgYW5kIHR3b3NbXSBtdXN0IGhhdmUgYmVlbiBwYXJzZWQhICovCnN0YXRpYyBzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhaW50X2Rvd25fdG9fY29tbW9uKHN0cnVjdCBjb21taXQgKm9uZSwgaW50IG4sIHN0cnVjdCBjb21taXQgKip0d29zKQp7CglzdHJ1Y3QgcHJpb19xdWV1ZSBxdWV1ZSA9IHsgY29tcGFyZV9jb21taXRzX2J5X2NvbW1pdF9kYXRlIH07CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlc3VsdCA9IE5VTEw7CglpbnQgaTsKCglvbmUtPm9iamVjdC5mbGFncyB8PSBQQVJFTlQxOwoJaWYgKCFuKSB7CgkJY29tbWl0X2xpc3RfYXBwZW5kKG9uZSwgJnJlc3VsdCk7CgkJcmV0dXJuIHJlc3VsdDsKCX0KCXByaW9fcXVldWVfcHV0KCZxdWV1ZSwgb25lKTsKCglmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7CgkJdHdvc1tpXS0+b2JqZWN0LmZsYWdzIHw9IFBBUkVOVDI7CgkJcHJpb19xdWV1ZV9wdXQoJnF1ZXVlLCB0d29zW2ldKTsKCX0KCgl3aGlsZSAocXVldWVfaGFzX25vbnN0YWxlKCZxdWV1ZSkpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBwcmlvX3F1ZXVlX2dldCgmcXVldWUpOwoJCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50czsKCQlpbnQgZmxhZ3M7CgoJCWZsYWdzID0gY29tbWl0LT5vYmplY3QuZmxhZ3MgJiAoUEFSRU5UMSB8IFBBUkVOVDIgfCBTVEFMRSk7CgkJaWYgKGZsYWdzID09IChQQVJFTlQxIHwgUEFSRU5UMikpIHsKCQkJaWYgKCEoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBSRVNVTFQpKSB7CgkJCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBSRVNVTFQ7CgkJCQljb21taXRfbGlzdF9pbnNlcnRfYnlfZGF0ZShjb21taXQsICZyZXN1bHQpOwoJCQl9CgkJCS8qIE1hcmsgcGFyZW50cyBvZiBhIGZvdW5kIG1lcmdlIHN0YWxlICovCgkJCWZsYWdzIHw9IFNUQUxFOwoJCX0KCQlwYXJlbnRzID0gY29tbWl0LT5wYXJlbnRzOwoJCXdoaWxlIChwYXJlbnRzKSB7CgkJCXN0cnVjdCBjb21taXQgKnAgPSBwYXJlbnRzLT5pdGVtOwoJCQlwYXJlbnRzID0gcGFyZW50cy0+bmV4dDsKCQkJaWYgKChwLT5vYmplY3QuZmxhZ3MgJiBmbGFncykgPT0gZmxhZ3MpCgkJCQljb250aW51ZTsKCQkJaWYgKHBhcnNlX2NvbW1pdChwKSkKCQkJCXJldHVybiBOVUxMOwoJCQlwLT5vYmplY3QuZmxhZ3MgfD0gZmxhZ3M7CgkJCXByaW9fcXVldWVfcHV0KCZxdWV1ZSwgcCk7CgkJfQoJfQoKCWNsZWFyX3ByaW9fcXVldWUoJnF1ZXVlKTsKCXJldHVybiByZXN1bHQ7Cn0KCnN0YXRpYyBzdHJ1Y3QgY29tbWl0X2xpc3QgKm1lcmdlX2Jhc2VzX21hbnkoc3RydWN0IGNvbW1pdCAqb25lLCBpbnQgbiwgc3RydWN0IGNvbW1pdCAqKnR3b3MpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCA9IE5VTEw7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlc3VsdCA9IE5VTEw7CglpbnQgaTsKCglmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7CgkJaWYgKG9uZSA9PSB0d29zW2ldKQoJCQkvKgoJCQkgKiBXZSBkbyBub3QgbWFyayB0aGlzIGV2ZW4gd2l0aCBSRVNVTFQgc28gd2UgZG8gbm90CgkJCSAqIGhhdmUgdG8gY2xlYW4gaXQgdXAuCgkJCSAqLwoJCQlyZXR1cm4gY29tbWl0X2xpc3RfaW5zZXJ0KG9uZSwgJnJlc3VsdCk7Cgl9CgoJaWYgKHBhcnNlX2NvbW1pdChvbmUpKQoJCXJldHVybiBOVUxMOwoJZm9yIChpID0gMDsgaSA8IG47IGkrKykgewoJCWlmIChwYXJzZV9jb21taXQodHdvc1tpXSkpCgkJCXJldHVybiBOVUxMOwoJfQoKCWxpc3QgPSBwYWludF9kb3duX3RvX2NvbW1vbihvbmUsIG4sIHR3b3MpOwoKCXdoaWxlIChsaXN0KSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gcG9wX2NvbW1pdCgmbGlzdCk7CgkJaWYgKCEoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBTVEFMRSkpCgkJCWNvbW1pdF9saXN0X2luc2VydF9ieV9kYXRlKGNvbW1pdCwgJnJlc3VsdCk7Cgl9CglyZXR1cm4gcmVzdWx0Owp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9vY3RvcHVzX21lcmdlX2Jhc2VzKHN0cnVjdCBjb21taXRfbGlzdCAqaW4pCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqaSwgKmosICprLCAqcmV0ID0gTlVMTDsKCglpZiAoIWluKQoJCXJldHVybiByZXQ7CgoJY29tbWl0X2xpc3RfaW5zZXJ0KGluLT5pdGVtLCAmcmV0KTsKCglmb3IgKGkgPSBpbi0+bmV4dDsgaTsgaSA9IGktPm5leHQpIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKm5ld19jb21taXRzID0gTlVMTCwgKmVuZCA9IE5VTEw7CgoJCWZvciAoaiA9IHJldDsgajsgaiA9IGotPm5leHQpIHsKCQkJc3RydWN0IGNvbW1pdF9saXN0ICpiYXNlczsKCQkJYmFzZXMgPSBnZXRfbWVyZ2VfYmFzZXMoaS0+aXRlbSwgai0+aXRlbSk7CgkJCWlmICghbmV3X2NvbW1pdHMpCgkJCQluZXdfY29tbWl0cyA9IGJhc2VzOwoJCQllbHNlCgkJCQllbmQtPm5leHQgPSBiYXNlczsKCQkJZm9yIChrID0gYmFzZXM7IGs7IGsgPSBrLT5uZXh0KQoJCQkJZW5kID0gazsKCQl9CgkJcmV0ID0gbmV3X2NvbW1pdHM7Cgl9CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IHJlbW92ZV9yZWR1bmRhbnQoc3RydWN0IGNvbW1pdCAqKmFycmF5LCBpbnQgY250KQp7CgkvKgoJICogU29tZSBjb21taXQgaW4gdGhlIGFycmF5IG1heSBiZSBhbiBhbmNlc3RvciBvZgoJICogYW5vdGhlciBjb21taXQuICBNb3ZlIHN1Y2ggY29tbWl0IHRvIHRoZSBlbmQgb2YKCSAqIHRoZSBhcnJheSwgYW5kIHJldHVybiB0aGUgbnVtYmVyIG9mIGNvbW1pdHMgdGhhdAoJICogYXJlIGluZGVwZW5kZW50IGZyb20gZWFjaCBvdGhlci4KCSAqLwoJc3RydWN0IGNvbW1pdCAqKndvcms7Cgl1bnNpZ25lZCBjaGFyICpyZWR1bmRhbnQ7CglpbnQgKmZpbGxlZF9pbmRleDsKCWludCBpLCBqLCBmaWxsZWQ7CgoJd29yayA9IHhjYWxsb2MoY250LCBzaXplb2YoKndvcmspKTsKCXJlZHVuZGFudCA9IHhjYWxsb2MoY250LCAxKTsKCUFMTE9DX0FSUkFZKGZpbGxlZF9pbmRleCwgY250IC0gMSk7CgoJZm9yIChpID0gMDsgaSA8IGNudDsgaSsrKQoJCXBhcnNlX2NvbW1pdChhcnJheVtpXSk7Cglmb3IgKGkgPSAwOyBpIDwgY250OyBpKyspIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKmNvbW1vbjsKCgkJaWYgKHJlZHVuZGFudFtpXSkKCQkJY29udGludWU7CgkJZm9yIChqID0gZmlsbGVkID0gMDsgaiA8IGNudDsgaisrKSB7CgkJCWlmIChpID09IGogfHwgcmVkdW5kYW50W2pdKQoJCQkJY29udGludWU7CgkJCWZpbGxlZF9pbmRleFtmaWxsZWRdID0gajsKCQkJd29ya1tmaWxsZWQrK10gPSBhcnJheVtqXTsKCQl9CgkJY29tbW9uID0gcGFpbnRfZG93bl90b19jb21tb24oYXJyYXlbaV0sIGZpbGxlZCwgd29yayk7CgkJaWYgKGFycmF5W2ldLT5vYmplY3QuZmxhZ3MgJiBQQVJFTlQyKQoJCQlyZWR1bmRhbnRbaV0gPSAxOwoJCWZvciAoaiA9IDA7IGogPCBmaWxsZWQ7IGorKykKCQkJaWYgKHdvcmtbal0tPm9iamVjdC5mbGFncyAmIFBBUkVOVDEpCgkJCQlyZWR1bmRhbnRbZmlsbGVkX2luZGV4W2pdXSA9IDE7CgkJY2xlYXJfY29tbWl0X21hcmtzKGFycmF5W2ldLCBhbGxfZmxhZ3MpOwoJCWNsZWFyX2NvbW1pdF9tYXJrc19tYW55KGZpbGxlZCwgd29yaywgYWxsX2ZsYWdzKTsKCQlmcmVlX2NvbW1pdF9saXN0KGNvbW1vbik7Cgl9CgoJLyogTm93IGNvbGxlY3QgdGhlIHJlc3VsdCAqLwoJQ09QWV9BUlJBWSh3b3JrLCBhcnJheSwgY250KTsKCWZvciAoaSA9IGZpbGxlZCA9IDA7IGkgPCBjbnQ7IGkrKykKCQlpZiAoIXJlZHVuZGFudFtpXSkKCQkJYXJyYXlbZmlsbGVkKytdID0gd29ya1tpXTsKCWZvciAoaiA9IGZpbGxlZCwgaSA9IDA7IGkgPCBjbnQ7IGkrKykKCQlpZiAocmVkdW5kYW50W2ldKQoJCQlhcnJheVtqKytdID0gd29ya1tpXTsKCWZyZWUod29yayk7CglmcmVlKHJlZHVuZGFudCk7CglmcmVlKGZpbGxlZF9pbmRleCk7CglyZXR1cm4gZmlsbGVkOwp9CgpzdGF0aWMgc3RydWN0IGNvbW1pdF9saXN0ICpnZXRfbWVyZ2VfYmFzZXNfbWFueV8wKHN0cnVjdCBjb21taXQgKm9uZSwKCQkJCQkJICBpbnQgbiwKCQkJCQkJICBzdHJ1Y3QgY29tbWl0ICoqdHdvcywKCQkJCQkJICBpbnQgY2xlYW51cCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0OwoJc3RydWN0IGNvbW1pdCAqKnJzbHQ7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlc3VsdDsKCWludCBjbnQsIGk7CgoJcmVzdWx0ID0gbWVyZ2VfYmFzZXNfbWFueShvbmUsIG4sIHR3b3MpOwoJZm9yIChpID0gMDsgaSA8IG47IGkrKykgewoJCWlmIChvbmUgPT0gdHdvc1tpXSkKCQkJcmV0dXJuIHJlc3VsdDsKCX0KCWlmICghcmVzdWx0IHx8ICFyZXN1bHQtPm5leHQpIHsKCQlpZiAoY2xlYW51cCkgewoJCQljbGVhcl9jb21taXRfbWFya3Mob25lLCBhbGxfZmxhZ3MpOwoJCQljbGVhcl9jb21taXRfbWFya3NfbWFueShuLCB0d29zLCBhbGxfZmxhZ3MpOwoJCX0KCQlyZXR1cm4gcmVzdWx0OwoJfQoKCS8qIFRoZXJlIGFyZSBtb3JlIHRoYW4gb25lICovCgljbnQgPSBjb21taXRfbGlzdF9jb3VudChyZXN1bHQpOwoJcnNsdCA9IHhjYWxsb2MoY250LCBzaXplb2YoKnJzbHQpKTsKCWZvciAobGlzdCA9IHJlc3VsdCwgaSA9IDA7IGxpc3Q7IGxpc3QgPSBsaXN0LT5uZXh0KQoJCXJzbHRbaSsrXSA9IGxpc3QtPml0ZW07CglmcmVlX2NvbW1pdF9saXN0KHJlc3VsdCk7CgoJY2xlYXJfY29tbWl0X21hcmtzKG9uZSwgYWxsX2ZsYWdzKTsKCWNsZWFyX2NvbW1pdF9tYXJrc19tYW55KG4sIHR3b3MsIGFsbF9mbGFncyk7CgoJY250ID0gcmVtb3ZlX3JlZHVuZGFudChyc2x0LCBjbnQpOwoJcmVzdWx0ID0gTlVMTDsKCWZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykKCQljb21taXRfbGlzdF9pbnNlcnRfYnlfZGF0ZShyc2x0W2ldLCAmcmVzdWx0KTsKCWZyZWUocnNsdCk7CglyZXR1cm4gcmVzdWx0Owp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9tZXJnZV9iYXNlc19tYW55KHN0cnVjdCBjb21taXQgKm9uZSwKCQkJCQkgaW50IG4sCgkJCQkJIHN0cnVjdCBjb21taXQgKip0d29zKQp7CglyZXR1cm4gZ2V0X21lcmdlX2Jhc2VzX21hbnlfMChvbmUsIG4sIHR3b3MsIDEpOwp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9tZXJnZV9iYXNlc19tYW55X2RpcnR5KHN0cnVjdCBjb21taXQgKm9uZSwKCQkJCQkgICAgICAgaW50IG4sCgkJCQkJICAgICAgIHN0cnVjdCBjb21taXQgKip0d29zKQp7CglyZXR1cm4gZ2V0X21lcmdlX2Jhc2VzX21hbnlfMChvbmUsIG4sIHR3b3MsIDApOwp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9tZXJnZV9iYXNlcyhzdHJ1Y3QgY29tbWl0ICpvbmUsIHN0cnVjdCBjb21taXQgKnR3bykKewoJcmV0dXJuIGdldF9tZXJnZV9iYXNlc19tYW55XzAob25lLCAxLCAmdHdvLCAxKTsKfQoKLyoKICogSXMgImNvbW1pdCIgYSBkZXNjZW5kYW50IG9mIG9uZSBvZiB0aGUgZWxlbWVudHMgb24gdGhlICJ3aXRoX2NvbW1pdCIgbGlzdD8KICovCmludCBpc19kZXNjZW5kYW50X29mKHN0cnVjdCBjb21taXQgKmNvbW1pdCwgc3RydWN0IGNvbW1pdF9saXN0ICp3aXRoX2NvbW1pdCkKewoJaWYgKCF3aXRoX2NvbW1pdCkKCQlyZXR1cm4gMTsKCXdoaWxlICh3aXRoX2NvbW1pdCkgewoJCXN0cnVjdCBjb21taXQgKm90aGVyOwoKCQlvdGhlciA9IHdpdGhfY29tbWl0LT5pdGVtOwoJCXdpdGhfY29tbWl0ID0gd2l0aF9jb21taXQtPm5leHQ7CgkJaWYgKGluX21lcmdlX2Jhc2VzKG90aGVyLCBjb21taXQpKQoJCQlyZXR1cm4gMTsKCX0KCXJldHVybiAwOwp9CgovKgogKiBJcyAiY29tbWl0IiBhbiBhbmNlc3RvciBvZiBvbmUgb2YgdGhlICJyZWZlcmVuY2VzIj8KICovCmludCBpbl9tZXJnZV9iYXNlc19tYW55KHN0cnVjdCBjb21taXQgKmNvbW1pdCwgaW50IG5yX3JlZmVyZW5jZSwgc3RydWN0IGNvbW1pdCAqKnJlZmVyZW5jZSkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpiYXNlczsKCWludCByZXQgPSAwLCBpOwoKCWlmIChwYXJzZV9jb21taXQoY29tbWl0KSkKCQlyZXR1cm4gcmV0OwoJZm9yIChpID0gMDsgaSA8IG5yX3JlZmVyZW5jZTsgaSsrKQoJCWlmIChwYXJzZV9jb21taXQocmVmZXJlbmNlW2ldKSkKCQkJcmV0dXJuIHJldDsKCgliYXNlcyA9IHBhaW50X2Rvd25fdG9fY29tbW9uKGNvbW1pdCwgbnJfcmVmZXJlbmNlLCByZWZlcmVuY2UpOwoJaWYgKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgUEFSRU5UMikKCQlyZXQgPSAxOwoJY2xlYXJfY29tbWl0X21hcmtzKGNvbW1pdCwgYWxsX2ZsYWdzKTsKCWNsZWFyX2NvbW1pdF9tYXJrc19tYW55KG5yX3JlZmVyZW5jZSwgcmVmZXJlbmNlLCBhbGxfZmxhZ3MpOwoJZnJlZV9jb21taXRfbGlzdChiYXNlcyk7CglyZXR1cm4gcmV0Owp9CgovKgogKiBJcyAiY29tbWl0IiBhbiBhbmNlc3RvciBvZiAoaS5lLiByZWFjaGFibGUgZnJvbSkgdGhlICJyZWZlcmVuY2UiPwogKi8KaW50IGluX21lcmdlX2Jhc2VzKHN0cnVjdCBjb21taXQgKmNvbW1pdCwgc3RydWN0IGNvbW1pdCAqcmVmZXJlbmNlKQp7CglyZXR1cm4gaW5fbWVyZ2VfYmFzZXNfbWFueShjb21taXQsIDEsICZyZWZlcmVuY2UpOwp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlZHVjZV9oZWFkcyhzdHJ1Y3QgY29tbWl0X2xpc3QgKmhlYWRzKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnA7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlc3VsdCA9IE5VTEwsICoqdGFpbCA9ICZyZXN1bHQ7CglzdHJ1Y3QgY29tbWl0ICoqYXJyYXk7CglpbnQgbnVtX2hlYWQsIGk7CgoJaWYgKCFoZWFkcykKCQlyZXR1cm4gTlVMTDsKCgkvKiBVbmlxdWlmeSAqLwoJZm9yIChwID0gaGVhZHM7IHA7IHAgPSBwLT5uZXh0KQoJCXAtPml0ZW0tPm9iamVjdC5mbGFncyAmPSB+U1RBTEU7Cglmb3IgKHAgPSBoZWFkcywgbnVtX2hlYWQgPSAwOyBwOyBwID0gcC0+bmV4dCkgewoJCWlmIChwLT5pdGVtLT5vYmplY3QuZmxhZ3MgJiBTVEFMRSkKCQkJY29udGludWU7CgkJcC0+aXRlbS0+b2JqZWN0LmZsYWdzIHw9IFNUQUxFOwoJCW51bV9oZWFkKys7Cgl9CglhcnJheSA9IHhjYWxsb2MobnVtX2hlYWQsIHNpemVvZigqYXJyYXkpKTsKCWZvciAocCA9IGhlYWRzLCBpID0gMDsgcDsgcCA9IHAtPm5leHQpIHsKCQlpZiAocC0+aXRlbS0+b2JqZWN0LmZsYWdzICYgU1RBTEUpIHsKCQkJYXJyYXlbaSsrXSA9IHAtPml0ZW07CgkJCXAtPml0ZW0tPm9iamVjdC5mbGFncyAmPSB+U1RBTEU7CgkJfQoJfQoJbnVtX2hlYWQgPSByZW1vdmVfcmVkdW5kYW50KGFycmF5LCBudW1faGVhZCk7Cglmb3IgKGkgPSAwOyBpIDwgbnVtX2hlYWQ7IGkrKykKCQl0YWlsID0gJmNvbW1pdF9saXN0X2luc2VydChhcnJheVtpXSwgdGFpbCktPm5leHQ7CglmcmVlKGFycmF5KTsKCXJldHVybiByZXN1bHQ7Cn0KCnZvaWQgcmVkdWNlX2hlYWRzX3JlcGxhY2Uoc3RydWN0IGNvbW1pdF9saXN0ICoqaGVhZHMpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqcmVzdWx0ID0gcmVkdWNlX2hlYWRzKCpoZWFkcyk7CglmcmVlX2NvbW1pdF9saXN0KCpoZWFkcyk7CgkqaGVhZHMgPSByZXN1bHQ7Cn0KCnN0YXRpYyBjb25zdCBjaGFyIGdwZ19zaWdfaGVhZGVyW10gPSAiZ3Bnc2lnIjsKc3RhdGljIGNvbnN0IGludCBncGdfc2lnX2hlYWRlcl9sZW4gPSBzaXplb2YoZ3BnX3NpZ19oZWFkZXIpIC0gMTsKCnN0YXRpYyBpbnQgZG9fc2lnbl9jb21taXQoc3RydWN0IHN0cmJ1ZiAqYnVmLCBjb25zdCBjaGFyICprZXlpZCkKewoJc3RydWN0IHN0cmJ1ZiBzaWcgPSBTVFJCVUZfSU5JVDsKCWludCBpbnNwb3MsIGNvcHlwb3M7Cgljb25zdCBjaGFyICplb2g7CgoJLyogZmluZCB0aGUgZW5kIG9mIHRoZSBoZWFkZXIgKi8KCWVvaCA9IHN0cnN0cihidWYtPmJ1ZiwgIlxuXG4iKTsKCWlmICghZW9oKQoJCWluc3BvcyA9IGJ1Zi0+bGVuOwoJZWxzZQoJCWluc3BvcyA9IGVvaCAtIGJ1Zi0+YnVmICsgMTsKCglpZiAoIWtleWlkIHx8ICEqa2V5aWQpCgkJa2V5aWQgPSBnZXRfc2lnbmluZ19rZXkoKTsKCWlmIChzaWduX2J1ZmZlcihidWYsICZzaWcsIGtleWlkKSkgewoJCXN0cmJ1Zl9yZWxlYXNlKCZzaWcpOwoJCXJldHVybiAtMTsKCX0KCglmb3IgKGNvcHlwb3MgPSAwOyBzaWcuYnVmW2NvcHlwb3NdOyApIHsKCQljb25zdCBjaGFyICpib2wgPSBzaWcuYnVmICsgY29weXBvczsKCQljb25zdCBjaGFyICplb2wgPSBzdHJjaHJudWwoYm9sLCAnXG4nKTsKCQlpbnQgbGVuID0gKGVvbCAtIGJvbCkgKyAhISplb2w7CgoJCWlmICghY29weXBvcykgewoJCQlzdHJidWZfaW5zZXJ0KGJ1ZiwgaW5zcG9zLCBncGdfc2lnX2hlYWRlciwgZ3BnX3NpZ19oZWFkZXJfbGVuKTsKCQkJaW5zcG9zICs9IGdwZ19zaWdfaGVhZGVyX2xlbjsKCQl9CgkJc3RyYnVmX2luc2VydChidWYsIGluc3BvcysrLCAiICIsIDEpOwoJCXN0cmJ1Zl9pbnNlcnQoYnVmLCBpbnNwb3MsIGJvbCwgbGVuKTsKCQlpbnNwb3MgKz0gbGVuOwoJCWNvcHlwb3MgKz0gbGVuOwoJfQoJc3RyYnVmX3JlbGVhc2UoJnNpZyk7CglyZXR1cm4gMDsKfQoKaW50IHBhcnNlX3NpZ25lZF9jb21taXQoY29uc3Qgc3RydWN0IGNvbW1pdCAqY29tbWl0LAoJCQlzdHJ1Y3Qgc3RyYnVmICpwYXlsb2FkLCBzdHJ1Y3Qgc3RyYnVmICpzaWduYXR1cmUpCnsKCgl1bnNpZ25lZCBsb25nIHNpemU7Cgljb25zdCBjaGFyICpidWZmZXIgPSBnZXRfY29tbWl0X2J1ZmZlcihjb21taXQsICZzaXplKTsKCWludCBpbl9zaWduYXR1cmUsIHNhd19zaWduYXR1cmUgPSAtMTsKCWNvbnN0IGNoYXIgKmxpbmUsICp0YWlsOwoKCWxpbmUgPSBidWZmZXI7Cgl0YWlsID0gYnVmZmVyICsgc2l6ZTsKCWluX3NpZ25hdHVyZSA9IDA7CglzYXdfc2lnbmF0dXJlID0gMDsKCXdoaWxlIChsaW5lIDwgdGFpbCkgewoJCWNvbnN0IGNoYXIgKnNpZyA9IE5VTEw7CgkJY29uc3QgY2hhciAqbmV4dCA9IG1lbWNocihsaW5lLCAnXG4nLCB0YWlsIC0gbGluZSk7CgoJCW5leHQgPSBuZXh0ID8gbmV4dCArIDEgOiB0YWlsOwoJCWlmIChpbl9zaWduYXR1cmUgJiYgbGluZVswXSA9PSAnICcpCgkJCXNpZyA9IGxpbmUgKyAxOwoJCWVsc2UgaWYgKHN0YXJ0c193aXRoKGxpbmUsIGdwZ19zaWdfaGVhZGVyKSAmJgoJCQkgbGluZVtncGdfc2lnX2hlYWRlcl9sZW5dID09ICcgJykKCQkJc2lnID0gbGluZSArIGdwZ19zaWdfaGVhZGVyX2xlbiArIDE7CgkJaWYgKHNpZykgewoJCQlzdHJidWZfYWRkKHNpZ25hdHVyZSwgc2lnLCBuZXh0IC0gc2lnKTsKCQkJc2F3X3NpZ25hdHVyZSA9IDE7CgkJCWluX3NpZ25hdHVyZSA9IDE7CgkJfSBlbHNlIHsKCQkJaWYgKCpsaW5lID09ICdcbicpCgkJCQkvKiBkdW1wIHRoZSB3aG9sZSByZW1haW5kZXIgb2YgdGhlIGJ1ZmZlciAqLwoJCQkJbmV4dCA9IHRhaWw7CgkJCXN0cmJ1Zl9hZGQocGF5bG9hZCwgbGluZSwgbmV4dCAtIGxpbmUpOwoJCQlpbl9zaWduYXR1cmUgPSAwOwoJCX0KCQlsaW5lID0gbmV4dDsKCX0KCXVudXNlX2NvbW1pdF9idWZmZXIoY29tbWl0LCBidWZmZXIpOwoJcmV0dXJuIHNhd19zaWduYXR1cmU7Cn0KCmludCByZW1vdmVfc2lnbmF0dXJlKHN0cnVjdCBzdHJidWYgKmJ1ZikKewoJY29uc3QgY2hhciAqbGluZSA9IGJ1Zi0+YnVmOwoJY29uc3QgY2hhciAqdGFpbCA9IGJ1Zi0+YnVmICsgYnVmLT5sZW47CglpbnQgaW5fc2lnbmF0dXJlID0gMDsKCWNvbnN0IGNoYXIgKnNpZ19zdGFydCA9IE5VTEw7Cgljb25zdCBjaGFyICpzaWdfZW5kID0gTlVMTDsKCgl3aGlsZSAobGluZSA8IHRhaWwpIHsKCQljb25zdCBjaGFyICpuZXh0ID0gbWVtY2hyKGxpbmUsICdcbicsIHRhaWwgLSBsaW5lKTsKCQluZXh0ID0gbmV4dCA/IG5leHQgKyAxIDogdGFpbDsKCgkJaWYgKGluX3NpZ25hdHVyZSAmJiBsaW5lWzBdID09ICcgJykKCQkJc2lnX2VuZCA9IG5leHQ7CgkJZWxzZSBpZiAoc3RhcnRzX3dpdGgobGluZSwgZ3BnX3NpZ19oZWFkZXIpICYmCgkJCSBsaW5lW2dwZ19zaWdfaGVhZGVyX2xlbl0gPT0gJyAnKSB7CgkJCXNpZ19zdGFydCA9IGxpbmU7CgkJCXNpZ19lbmQgPSBuZXh0OwoJCQlpbl9zaWduYXR1cmUgPSAxOwoJCX0gZWxzZSB7CgkJCWlmICgqbGluZSA9PSAnXG4nKQoJCQkJLyogZHVtcCB0aGUgd2hvbGUgcmVtYWluZGVyIG9mIHRoZSBidWZmZXIgKi8KCQkJCW5leHQgPSB0YWlsOwoJCQlpbl9zaWduYXR1cmUgPSAwOwoJCX0KCQlsaW5lID0gbmV4dDsKCX0KCglpZiAoc2lnX3N0YXJ0KQoJCXN0cmJ1Zl9yZW1vdmUoYnVmLCBzaWdfc3RhcnQgLSBidWYtPmJ1Ziwgc2lnX2VuZCAtIHNpZ19zdGFydCk7CgoJcmV0dXJuIHNpZ19zdGFydCAhPSBOVUxMOwp9CgpzdGF0aWMgdm9pZCBoYW5kbGVfc2lnbmVkX3RhZyhzdHJ1Y3QgY29tbWl0ICpwYXJlbnQsIHN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICoqKnRhaWwpCnsKCXN0cnVjdCBtZXJnZV9yZW1vdGVfZGVzYyAqZGVzYzsKCXN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICptZXJnZXRhZzsKCWNoYXIgKmJ1ZjsKCXVuc2lnbmVkIGxvbmcgc2l6ZSwgbGVuOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoKCWRlc2MgPSBtZXJnZV9yZW1vdGVfdXRpbChwYXJlbnQpOwoJaWYgKCFkZXNjIHx8ICFkZXNjLT5vYmopCgkJcmV0dXJuOwoJYnVmID0gcmVhZF9vYmplY3RfZmlsZSgmZGVzYy0+b2JqLT5vaWQsICZ0eXBlLCAmc2l6ZSk7CglpZiAoIWJ1ZiB8fCB0eXBlICE9IE9CSl9UQUcpCgkJZ290byBmcmVlX3JldHVybjsKCWxlbiA9IHBhcnNlX3NpZ25hdHVyZShidWYsIHNpemUpOwoJaWYgKHNpemUgPT0gbGVuKQoJCWdvdG8gZnJlZV9yZXR1cm47CgkvKgoJICogV2UgY291bGQgdmVyaWZ5IHRoaXMgc2lnbmF0dXJlIGFuZCBlaXRoZXIgb21pdCB0aGUgdGFnIHdoZW4KCSAqIGl0IGRvZXMgbm90IHZhbGlkYXRlLCBidXQgdGhlIGludGVncmF0b3IgbWF5IG5vdCBoYXZlIHRoZQoJICogcHVibGljIGtleSBvZiB0aGUgc2lnbmVyIG9mIHRoZSB0YWcgaGUgaXMgbWVyZ2luZywgd2hpbGUgYQoJICogbGF0ZXIgYXVkaXRvciBtYXkgaGF2ZSBpdCB3aGlsZSBhdWRpdGluZywgc28gbGV0J3Mgbm90IHJ1bgoJICogdmVyaWZ5LXNpZ25lZC1idWZmZXIgaGVyZSBmb3Igbm93Li4uCgkgKgoJICogaWYgKHZlcmlmeV9zaWduZWRfYnVmZmVyKGJ1ZiwgbGVuLCBidWYgKyBsZW4sIHNpemUgLSBsZW4sIC4uLikpCgkgKgl3YXJuKCJ3YXJuaW5nOiBzaWduZWQgdGFnIHVudmVyaWZpZWQuIik7CgkgKi8KCW1lcmdldGFnID0geGNhbGxvYygxLCBzaXplb2YoKm1lcmdldGFnKSk7CgltZXJnZXRhZy0+a2V5ID0geHN0cmR1cCgibWVyZ2V0YWciKTsKCW1lcmdldGFnLT52YWx1ZSA9IGJ1ZjsKCW1lcmdldGFnLT5sZW4gPSBzaXplOwoKCSoqdGFpbCA9IG1lcmdldGFnOwoJKnRhaWwgPSAmbWVyZ2V0YWctPm5leHQ7CglyZXR1cm47CgpmcmVlX3JldHVybjoKCWZyZWUoYnVmKTsKfQoKaW50IGNoZWNrX2NvbW1pdF9zaWduYXR1cmUoY29uc3Qgc3RydWN0IGNvbW1pdCAqY29tbWl0LCBzdHJ1Y3Qgc2lnbmF0dXJlX2NoZWNrICpzaWdjKQp7CglzdHJ1Y3Qgc3RyYnVmIHBheWxvYWQgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgc2lnbmF0dXJlID0gU1RSQlVGX0lOSVQ7CglpbnQgcmV0ID0gMTsKCglzaWdjLT5yZXN1bHQgPSAnTic7CgoJaWYgKHBhcnNlX3NpZ25lZF9jb21taXQoY29tbWl0LCAmcGF5bG9hZCwgJnNpZ25hdHVyZSkgPD0gMCkKCQlnb3RvIG91dDsKCXJldCA9IGNoZWNrX3NpZ25hdHVyZShwYXlsb2FkLmJ1ZiwgcGF5bG9hZC5sZW4sIHNpZ25hdHVyZS5idWYsCgkJc2lnbmF0dXJlLmxlbiwgc2lnYyk7Cgogb3V0OgoJc3RyYnVmX3JlbGVhc2UoJnBheWxvYWQpOwoJc3RyYnVmX3JlbGVhc2UoJnNpZ25hdHVyZSk7CgoJcmV0dXJuIHJldDsKfQoKCgp2b2lkIGFwcGVuZF9tZXJnZV90YWdfaGVhZGVycyhzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMsCgkJCSAgICAgIHN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICoqKnRhaWwpCnsKCXdoaWxlIChwYXJlbnRzKSB7CgkJc3RydWN0IGNvbW1pdCAqcGFyZW50ID0gcGFyZW50cy0+aXRlbTsKCQloYW5kbGVfc2lnbmVkX3RhZyhwYXJlbnQsIHRhaWwpOwoJCXBhcmVudHMgPSBwYXJlbnRzLT5uZXh0OwoJfQp9CgpzdGF0aWMgdm9pZCBhZGRfZXh0cmFfaGVhZGVyKHN0cnVjdCBzdHJidWYgKmJ1ZmZlciwKCQkJICAgICBzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqZXh0cmEpCnsKCXN0cmJ1Zl9hZGRzdHIoYnVmZmVyLCBleHRyYS0+a2V5KTsKCWlmIChleHRyYS0+bGVuKQoJCXN0cmJ1Zl9hZGRfbGluZXMoYnVmZmVyLCAiICIsIGV4dHJhLT52YWx1ZSwgZXh0cmEtPmxlbik7CgllbHNlCgkJc3RyYnVmX2FkZGNoKGJ1ZmZlciwgJ1xuJyk7Cn0KCnN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpyZWFkX2NvbW1pdF9leHRyYV9oZWFkZXJzKHN0cnVjdCBjb21taXQgKmNvbW1pdCwKCQkJCQkJICAgICAgY29uc3QgY2hhciAqKmV4Y2x1ZGUpCnsKCXN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpleHRyYSA9IE5VTEw7Cgl1bnNpZ25lZCBsb25nIHNpemU7Cgljb25zdCBjaGFyICpidWZmZXIgPSBnZXRfY29tbWl0X2J1ZmZlcihjb21taXQsICZzaXplKTsKCWV4dHJhID0gcmVhZF9jb21taXRfZXh0cmFfaGVhZGVyX2xpbmVzKGJ1ZmZlciwgc2l6ZSwgZXhjbHVkZSk7Cgl1bnVzZV9jb21taXRfYnVmZmVyKGNvbW1pdCwgYnVmZmVyKTsKCXJldHVybiBleHRyYTsKfQoKaW50IGZvcl9lYWNoX21lcmdldGFnKGVhY2hfbWVyZ2V0YWdfZm4gZm4sIHN0cnVjdCBjb21taXQgKmNvbW1pdCwgdm9pZCAqZGF0YSkKewoJc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKmV4dHJhLCAqdG9fZnJlZTsKCWludCByZXMgPSAwOwoKCXRvX2ZyZWUgPSByZWFkX2NvbW1pdF9leHRyYV9oZWFkZXJzKGNvbW1pdCwgTlVMTCk7Cglmb3IgKGV4dHJhID0gdG9fZnJlZTsgIXJlcyAmJiBleHRyYTsgZXh0cmEgPSBleHRyYS0+bmV4dCkgewoJCWlmIChzdHJjbXAoZXh0cmEtPmtleSwgIm1lcmdldGFnIikpCgkJCWNvbnRpbnVlOyAvKiBub3QgYSBtZXJnZSB0YWcgKi8KCQlyZXMgPSBmbihjb21taXQsIGV4dHJhLCBkYXRhKTsKCX0KCWZyZWVfY29tbWl0X2V4dHJhX2hlYWRlcnModG9fZnJlZSk7CglyZXR1cm4gcmVzOwp9CgpzdGF0aWMgaW5saW5lIGludCBzdGFuZGFyZF9oZWFkZXJfZmllbGQoY29uc3QgY2hhciAqZmllbGQsIHNpemVfdCBsZW4pCnsKCXJldHVybiAoKGxlbiA9PSA0ICYmICFtZW1jbXAoZmllbGQsICJ0cmVlIiwgNCkpIHx8CgkJKGxlbiA9PSA2ICYmICFtZW1jbXAoZmllbGQsICJwYXJlbnQiLCA2KSkgfHwKCQkobGVuID09IDYgJiYgIW1lbWNtcChmaWVsZCwgImF1dGhvciIsIDYpKSB8fAoJCShsZW4gPT0gOSAmJiAhbWVtY21wKGZpZWxkLCAiY29tbWl0dGVyIiwgOSkpIHx8CgkJKGxlbiA9PSA4ICYmICFtZW1jbXAoZmllbGQsICJlbmNvZGluZyIsIDgpKSk7Cn0KCnN0YXRpYyBpbnQgZXhjbHVkZWRfaGVhZGVyX2ZpZWxkKGNvbnN0IGNoYXIgKmZpZWxkLCBzaXplX3QgbGVuLCBjb25zdCBjaGFyICoqZXhjbHVkZSkKewoJaWYgKCFleGNsdWRlKQoJCXJldHVybiAwOwoKCXdoaWxlICgqZXhjbHVkZSkgewoJCXNpemVfdCB4bGVuID0gc3RybGVuKCpleGNsdWRlKTsKCQlpZiAobGVuID09IHhsZW4gJiYgIW1lbWNtcChmaWVsZCwgKmV4Y2x1ZGUsIHhsZW4pKQoJCQlyZXR1cm4gMTsKCQlleGNsdWRlKys7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIHN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpyZWFkX2NvbW1pdF9leHRyYV9oZWFkZXJfbGluZXMoCgljb25zdCBjaGFyICpidWZmZXIsIHNpemVfdCBzaXplLAoJY29uc3QgY2hhciAqKmV4Y2x1ZGUpCnsKCXN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpleHRyYSA9IE5VTEwsICoqdGFpbCA9ICZleHRyYSwgKml0ID0gTlVMTDsKCWNvbnN0IGNoYXIgKmxpbmUsICpuZXh0LCAqZW9mLCAqZW9iOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCglmb3IgKGxpbmUgPSBidWZmZXIsIGVvYiA9IGxpbmUgKyBzaXplOwoJICAgICBsaW5lIDwgZW9iICYmICpsaW5lICE9ICdcbic7CgkgICAgIGxpbmUgPSBuZXh0KSB7CgkJbmV4dCA9IG1lbWNocihsaW5lLCAnXG4nLCBlb2IgLSBsaW5lKTsKCQluZXh0ID0gbmV4dCA/IG5leHQgKyAxIDogZW9iOwoJCWlmICgqbGluZSA9PSAnICcpIHsKCQkJLyogY29udGludWF0aW9uICovCgkJCWlmIChpdCkKCQkJCXN0cmJ1Zl9hZGQoJmJ1ZiwgbGluZSArIDEsIG5leHQgLSAobGluZSArIDEpKTsKCQkJY29udGludWU7CgkJfQoJCWlmIChpdCkKCQkJaXQtPnZhbHVlID0gc3RyYnVmX2RldGFjaCgmYnVmLCAmaXQtPmxlbik7CgkJc3RyYnVmX3Jlc2V0KCZidWYpOwoJCWl0ID0gTlVMTDsKCgkJZW9mID0gbWVtY2hyKGxpbmUsICcgJywgbmV4dCAtIGxpbmUpOwoJCWlmICghZW9mKQoJCQllb2YgPSBuZXh0OwoJCWVsc2UgaWYgKHN0YW5kYXJkX2hlYWRlcl9maWVsZChsaW5lLCBlb2YgLSBsaW5lKSB8fAoJCQkgZXhjbHVkZWRfaGVhZGVyX2ZpZWxkKGxpbmUsIGVvZiAtIGxpbmUsIGV4Y2x1ZGUpKQoJCQljb250aW51ZTsKCgkJaXQgPSB4Y2FsbG9jKDEsIHNpemVvZigqaXQpKTsKCQlpdC0+a2V5ID0geG1lbWR1cHoobGluZSwgZW9mLWxpbmUpOwoJCSp0YWlsID0gaXQ7CgkJdGFpbCA9ICZpdC0+bmV4dDsKCQlpZiAoZW9mICsgMSA8IG5leHQpCgkJCXN0cmJ1Zl9hZGQoJmJ1ZiwgZW9mICsgMSwgbmV4dCAtIChlb2YgKyAxKSk7Cgl9CglpZiAoaXQpCgkJaXQtPnZhbHVlID0gc3RyYnVmX2RldGFjaCgmYnVmLCAmaXQtPmxlbik7CglyZXR1cm4gZXh0cmE7Cn0KCnZvaWQgZnJlZV9jb21taXRfZXh0cmFfaGVhZGVycyhzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqZXh0cmEpCnsKCXdoaWxlIChleHRyYSkgewoJCXN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpuZXh0ID0gZXh0cmEtPm5leHQ7CgkJZnJlZShleHRyYS0+a2V5KTsKCQlmcmVlKGV4dHJhLT52YWx1ZSk7CgkJZnJlZShleHRyYSk7CgkJZXh0cmEgPSBuZXh0OwoJfQp9CgppbnQgY29tbWl0X3RyZWUoY29uc3QgY2hhciAqbXNnLCBzaXplX3QgbXNnX2xlbiwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqdHJlZSwKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMsIHN0cnVjdCBvYmplY3RfaWQgKnJldCwKCQljb25zdCBjaGFyICphdXRob3IsIGNvbnN0IGNoYXIgKnNpZ25fY29tbWl0KQp7CglzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqZXh0cmEgPSBOVUxMLCAqKnRhaWwgPSAmZXh0cmE7CglpbnQgcmVzdWx0OwoKCWFwcGVuZF9tZXJnZV90YWdfaGVhZGVycyhwYXJlbnRzLCAmdGFpbCk7CglyZXN1bHQgPSBjb21taXRfdHJlZV9leHRlbmRlZChtc2csIG1zZ19sZW4sIHRyZWUsIHBhcmVudHMsIHJldCwKCQkJCSAgICAgIGF1dGhvciwgc2lnbl9jb21taXQsIGV4dHJhKTsKCWZyZWVfY29tbWl0X2V4dHJhX2hlYWRlcnMoZXh0cmEpOwoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIGludCBmaW5kX2ludmFsaWRfdXRmOChjb25zdCBjaGFyICpidWYsIGludCBsZW4pCnsKCWludCBvZmZzZXQgPSAwOwoJc3RhdGljIGNvbnN0IHVuc2lnbmVkIGludCBtYXhfY29kZXBvaW50W10gPSB7CgkJMHg3ZiwgMHg3ZmYsIDB4ZmZmZiwgMHgxMGZmZmYKCX07CgoJd2hpbGUgKGxlbikgewoJCXVuc2lnbmVkIGNoYXIgYyA9ICpidWYrKzsKCQlpbnQgYnl0ZXMsIGJhZF9vZmZzZXQ7CgkJdW5zaWduZWQgaW50IGNvZGVwb2ludDsKCQl1bnNpZ25lZCBpbnQgbWluX3ZhbCwgbWF4X3ZhbDsKCgkJbGVuLS07CgkJb2Zmc2V0Kys7CgoJCS8qIFNpbXBsZSBVUy1BU0NJST8gTm8gd29ycmllcy4gKi8KCQlpZiAoYyA8IDB4ODApCgkJCWNvbnRpbnVlOwoKCQliYWRfb2Zmc2V0ID0gb2Zmc2V0LTE7CgoJCS8qCgkJICogQ291bnQgaG93IG1hbnkgbW9yZSBoaWdoIGJpdHMgc2V0OiB0aGF0J3MgaG93CgkJICogbWFueSBtb3JlIGJ5dGVzIHRoaXMgc2VxdWVuY2Ugc2hvdWxkIGhhdmUuCgkJICovCgkJYnl0ZXMgPSAwOwoJCXdoaWxlIChjICYgMHg0MCkgewoJCQljIDw8PSAxOwoJCQlieXRlcysrOwoJCX0KCgkJLyoKCQkgKiBNdXN0IGJlIGJldHdlZW4gMSBhbmQgMyBtb3JlIGJ5dGVzLiAgTG9uZ2VyIHNlcXVlbmNlcyByZXN1bHQgaW4KCQkgKiBjb2RlcG9pbnRzIGJleW9uZCBVKzEwRkZGRiwgd2hpY2ggYXJlIGd1YXJhbnRlZWQgbmV2ZXIgdG8gZXhpc3QuCgkJICovCgkJaWYgKGJ5dGVzIDwgMSB8fCAzIDwgYnl0ZXMpCgkJCXJldHVybiBiYWRfb2Zmc2V0OwoKCQkvKiBEbyB3ZSAqaGF2ZSogdGhhdCBtYW55IGJ5dGVzPyAqLwoJCWlmIChsZW4gPCBieXRlcykKCQkJcmV0dXJuIGJhZF9vZmZzZXQ7CgoJCS8qCgkJICogUGxhY2UgdGhlIGVuY29kZWQgYml0cyBhdCB0aGUgYm90dG9tIG9mIHRoZSB2YWx1ZSBhbmQgY29tcHV0ZSB0aGUKCQkgKiB2YWxpZCByYW5nZS4KCQkgKi8KCQljb2RlcG9pbnQgPSAoYyAmIDB4N2YpID4+IGJ5dGVzOwoJCW1pbl92YWwgPSBtYXhfY29kZXBvaW50W2J5dGVzLTFdICsgMTsKCQltYXhfdmFsID0gbWF4X2NvZGVwb2ludFtieXRlc107CgoJCW9mZnNldCArPSBieXRlczsKCQlsZW4gLT0gYnl0ZXM7CgoJCS8qIEFuZCB2ZXJpZnkgdGhhdCB0aGV5IGFyZSBnb29kIGNvbnRpbnVhdGlvbiBieXRlcyAqLwoJCWRvIHsKCQkJY29kZXBvaW50IDw8PSA2OwoJCQljb2RlcG9pbnQgfD0gKmJ1ZiAmIDB4M2Y7CgkJCWlmICgoKmJ1ZisrICYgMHhjMCkgIT0gMHg4MCkKCQkJCXJldHVybiBiYWRfb2Zmc2V0OwoJCX0gd2hpbGUgKC0tYnl0ZXMpOwoKCQkvKiBSZWplY3QgY29kZXBvaW50cyB0aGF0IGFyZSBvdXQgb2YgcmFuZ2UgZm9yIHRoZSBzZXF1ZW5jZSBsZW5ndGguICovCgkJaWYgKGNvZGVwb2ludCA8IG1pbl92YWwgfHwgY29kZXBvaW50ID4gbWF4X3ZhbCkKCQkJcmV0dXJuIGJhZF9vZmZzZXQ7CgkJLyogU3Vycm9nYXRlcyBhcmUgb25seSBmb3IgVVRGLTE2IGFuZCBjYW5ub3QgYmUgZW5jb2RlZCBpbiBVVEYtOC4gKi8KCQlpZiAoKGNvZGVwb2ludCAmIDB4MWZmODAwKSA9PSAweGQ4MDApCgkJCXJldHVybiBiYWRfb2Zmc2V0OwoJCS8qIFUreHhGRkZFIGFuZCBVK3h4RkZGRiBhcmUgZ3VhcmFudGVlZCBub24tY2hhcmFjdGVycy4gKi8KCQlpZiAoKGNvZGVwb2ludCAmIDB4ZmZmZSkgPT0gMHhmZmZlKQoJCQlyZXR1cm4gYmFkX29mZnNldDsKCQkvKiBTbyBhcmUgYW55dGhpbmcgaW4gdGhlIHJhbmdlIFUrRkREMC4uVStGREVGLiAqLwoJCWlmIChjb2RlcG9pbnQgPj0gMHhmZGQwICYmIGNvZGVwb2ludCA8PSAweGZkZWYpCgkJCXJldHVybiBiYWRfb2Zmc2V0OwoJfQoJcmV0dXJuIC0xOwp9CgovKgogKiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIGJ1ZmZlciBpcyBpbiBwcm9wZXIgdXRmOCBmb3JtYXQuCiAqCiAqIElmIGl0IGlzbid0LCBpdCBhc3N1bWVzIGFueSBub24tdXRmOCBjaGFyYWN0ZXJzIGFyZSBMYXRpbjEsCiAqIGFuZCBkb2VzIHRoZSBjb252ZXJzaW9uLgogKi8Kc3RhdGljIGludCB2ZXJpZnlfdXRmOChzdHJ1Y3Qgc3RyYnVmICpidWYpCnsKCWludCBvayA9IDE7Cglsb25nIHBvcyA9IDA7CgoJZm9yICg7OykgewoJCWludCBiYWQ7CgkJdW5zaWduZWQgY2hhciBjOwoJCXVuc2lnbmVkIGNoYXIgcmVwbGFjZVsyXTsKCgkJYmFkID0gZmluZF9pbnZhbGlkX3V0ZjgoYnVmLT5idWYgKyBwb3MsIGJ1Zi0+bGVuIC0gcG9zKTsKCQlpZiAoYmFkIDwgMCkKCQkJcmV0dXJuIG9rOwoJCXBvcyArPSBiYWQ7CgkJb2sgPSAwOwoJCWMgPSBidWYtPmJ1Zltwb3NdOwoJCXN0cmJ1Zl9yZW1vdmUoYnVmLCBwb3MsIDEpOwoKCQkvKiBXZSBrbm93ICdjJyBtdXN0IGJlIGluIHRoZSByYW5nZSAxMjgtMjU1ICovCgkJcmVwbGFjZVswXSA9IDB4YzAgKyAoYyA+PiA2KTsKCQlyZXBsYWNlWzFdID0gMHg4MCArIChjICYgMHgzZik7CgkJc3RyYnVmX2luc2VydChidWYsIHBvcywgcmVwbGFjZSwgMik7CgkJcG9zICs9IDI7Cgl9Cn0KCnN0YXRpYyBjb25zdCBjaGFyIGNvbW1pdF91dGY4X3dhcm5bXSA9Ck5fKCJXYXJuaW5nOiBjb21taXQgbWVzc2FnZSBkaWQgbm90IGNvbmZvcm0gdG8gVVRGLTguXG4iCiAgICJZb3UgbWF5IHdhbnQgdG8gYW1lbmQgaXQgYWZ0ZXIgZml4aW5nIHRoZSBtZXNzYWdlLCBvciBzZXQgdGhlIGNvbmZpZ1xuIgogICAidmFyaWFibGUgaTE4bi5jb21taXRlbmNvZGluZyB0byB0aGUgZW5jb2RpbmcgeW91ciBwcm9qZWN0IHVzZXMuXG4iKTsKCmludCBjb21taXRfdHJlZV9leHRlbmRlZChjb25zdCBjaGFyICptc2csIHNpemVfdCBtc2dfbGVuLAoJCQkgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqdHJlZSwKCQkJIHN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50cywgc3RydWN0IG9iamVjdF9pZCAqcmV0LAoJCQkgY29uc3QgY2hhciAqYXV0aG9yLCBjb25zdCBjaGFyICpzaWduX2NvbW1pdCwKCQkJIHN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpleHRyYSkKewoJaW50IHJlc3VsdDsKCWludCBlbmNvZGluZ19pc191dGY4OwoJc3RydWN0IHN0cmJ1ZiBidWZmZXI7CgoJYXNzZXJ0X29pZF90eXBlKHRyZWUsIE9CSl9UUkVFKTsKCglpZiAobWVtY2hyKG1zZywgJ1wwJywgbXNnX2xlbikpCgkJcmV0dXJuIGVycm9yKCJhIE5VTCBieXRlIGluIGNvbW1pdCBsb2cgbWVzc2FnZSBub3QgYWxsb3dlZC4iKTsKCgkvKiBOb3QgaGF2aW5nIGkxOG4uY29tbWl0ZW5jb2RpbmcgaXMgdGhlIHNhbWUgYXMgaGF2aW5nIHV0Zi04ICovCgllbmNvZGluZ19pc191dGY4ID0gaXNfZW5jb2RpbmdfdXRmOChnaXRfY29tbWl0X2VuY29kaW5nKTsKCglzdHJidWZfaW5pdCgmYnVmZmVyLCA4MTkyKTsgLyogc2hvdWxkIGF2b2lkIHJlYWxsb2NzIGZvciB0aGUgaGVhZGVycyAqLwoJc3RyYnVmX2FkZGYoJmJ1ZmZlciwgInRyZWUgJXNcbiIsIG9pZF90b19oZXgodHJlZSkpOwoKCS8qCgkgKiBOT1RFISBUaGlzIG9yZGVyaW5nIG1lYW5zIHRoYXQgdGhlIHNhbWUgZXhhY3QgdHJlZSBtZXJnZWQgd2l0aCBhCgkgKiBkaWZmZXJlbnQgb3JkZXIgb2YgcGFyZW50cyB3aWxsIGJlIGEgX2RpZmZlcmVudF8gY2hhbmdlc2V0IGV2ZW4KCSAqIGlmIGV2ZXJ5dGhpbmcgZWxzZSBzdGF5cyB0aGUgc2FtZS4KCSAqLwoJd2hpbGUgKHBhcmVudHMpIHsKCQlzdHJ1Y3QgY29tbWl0ICpwYXJlbnQgPSBwb3BfY29tbWl0KCZwYXJlbnRzKTsKCQlzdHJidWZfYWRkZigmYnVmZmVyLCAicGFyZW50ICVzXG4iLAoJCQkgICAgb2lkX3RvX2hleCgmcGFyZW50LT5vYmplY3Qub2lkKSk7Cgl9CgoJLyogUGVyc29uL2RhdGUgaW5mb3JtYXRpb24gKi8KCWlmICghYXV0aG9yKQoJCWF1dGhvciA9IGdpdF9hdXRob3JfaW5mbyhJREVOVF9TVFJJQ1QpOwoJc3RyYnVmX2FkZGYoJmJ1ZmZlciwgImF1dGhvciAlc1xuIiwgYXV0aG9yKTsKCXN0cmJ1Zl9hZGRmKCZidWZmZXIsICJjb21taXR0ZXIgJXNcbiIsIGdpdF9jb21taXR0ZXJfaW5mbyhJREVOVF9TVFJJQ1QpKTsKCWlmICghZW5jb2RpbmdfaXNfdXRmOCkKCQlzdHJidWZfYWRkZigmYnVmZmVyLCAiZW5jb2RpbmcgJXNcbiIsIGdpdF9jb21taXRfZW5jb2RpbmcpOwoKCXdoaWxlIChleHRyYSkgewoJCWFkZF9leHRyYV9oZWFkZXIoJmJ1ZmZlciwgZXh0cmEpOwoJCWV4dHJhID0gZXh0cmEtPm5leHQ7Cgl9CglzdHJidWZfYWRkY2goJmJ1ZmZlciwgJ1xuJyk7CgoJLyogQW5kIGFkZCB0aGUgY29tbWVudCAqLwoJc3RyYnVmX2FkZCgmYnVmZmVyLCBtc2csIG1zZ19sZW4pOwoKCS8qIEFuZCBjaGVjayB0aGUgZW5jb2RpbmcgKi8KCWlmIChlbmNvZGluZ19pc191dGY4ICYmICF2ZXJpZnlfdXRmOCgmYnVmZmVyKSkKCQlmcHJpbnRmKHN0ZGVyciwgXyhjb21taXRfdXRmOF93YXJuKSk7CgoJaWYgKHNpZ25fY29tbWl0ICYmIGRvX3NpZ25fY29tbWl0KCZidWZmZXIsIHNpZ25fY29tbWl0KSkgewoJCXJlc3VsdCA9IC0xOwoJCWdvdG8gb3V0OwoJfQoKCXJlc3VsdCA9IHdyaXRlX29iamVjdF9maWxlKGJ1ZmZlci5idWYsIGJ1ZmZlci5sZW4sIGNvbW1pdF90eXBlLCByZXQpOwpvdXQ6CglzdHJidWZfcmVsZWFzZSgmYnVmZmVyKTsKCXJldHVybiByZXN1bHQ7Cn0KCnZvaWQgc2V0X21lcmdlX3JlbW90ZV9kZXNjKHN0cnVjdCBjb21taXQgKmNvbW1pdCwKCQkJICAgY29uc3QgY2hhciAqbmFtZSwgc3RydWN0IG9iamVjdCAqb2JqKQp7CglzdHJ1Y3QgbWVyZ2VfcmVtb3RlX2Rlc2MgKmRlc2M7CglGTEVYX0FMTE9DX1NUUihkZXNjLCBuYW1lLCBuYW1lKTsKCWRlc2MtPm9iaiA9IG9iajsKCWNvbW1pdC0+dXRpbCA9IGRlc2M7Cn0KCnN0cnVjdCBjb21taXQgKmdldF9tZXJnZV9wYXJlbnQoY29uc3QgY2hhciAqbmFtZSkKewoJc3RydWN0IG9iamVjdCAqb2JqOwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CglpZiAoZ2V0X29pZChuYW1lLCAmb2lkKSkKCQlyZXR1cm4gTlVMTDsKCW9iaiA9IHBhcnNlX29iamVjdCgmb2lkKTsKCWNvbW1pdCA9IChzdHJ1Y3QgY29tbWl0ICopcGVlbF90b190eXBlKG5hbWUsIDAsIG9iaiwgT0JKX0NPTU1JVCk7CglpZiAoY29tbWl0ICYmICFjb21taXQtPnV0aWwpCgkJc2V0X21lcmdlX3JlbW90ZV9kZXNjKGNvbW1pdCwgbmFtZSwgb2JqKTsKCXJldHVybiBjb21taXQ7Cn0KCi8qCiAqIEFwcGVuZCBhIGNvbW1pdCB0byB0aGUgZW5kIG9mIHRoZSBjb21taXRfbGlzdC4KICoKICogbmV4dCBzdGFydHMgYnkgcG9pbnRpbmcgdG8gdGhlIHZhcmlhYmxlIHRoYXQgaG9sZHMgdGhlIGhlYWQgb2YgYW4KICogZW1wdHkgY29tbWl0X2xpc3QsIGFuZCBpcyB1cGRhdGVkIHRvIHBvaW50IHRvIHRoZSAibmV4dCIgZmllbGQgb2YKICogdGhlIGxhc3QgaXRlbSBvbiB0aGUgbGlzdCBhcyBuZXcgY29tbWl0cyBhcmUgYXBwZW5kZWQuCiAqCiAqIFVzYWdlIGV4YW1wbGU6CiAqCiAqICAgICBzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3Q7CiAqICAgICBzdHJ1Y3QgY29tbWl0X2xpc3QgKipuZXh0ID0gJmxpc3Q7CiAqCiAqICAgICBuZXh0ID0gY29tbWl0X2xpc3RfYXBwZW5kKGMxLCBuZXh0KTsKICogICAgIG5leHQgPSBjb21taXRfbGlzdF9hcHBlbmQoYzIsIG5leHQpOwogKiAgICAgYXNzZXJ0KGNvbW1pdF9saXN0X2NvdW50KGxpc3QpID09IDIpOwogKiAgICAgcmV0dXJuIGxpc3Q7CiAqLwpzdHJ1Y3QgY29tbWl0X2xpc3QgKipjb21taXRfbGlzdF9hcHBlbmQoc3RydWN0IGNvbW1pdCAqY29tbWl0LAoJCQkJCXN0cnVjdCBjb21taXRfbGlzdCAqKm5leHQpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqbmV3X2NvbW1pdCA9IHhtYWxsb2Moc2l6ZW9mKHN0cnVjdCBjb21taXRfbGlzdCkpOwoJbmV3X2NvbW1pdC0+aXRlbSA9IGNvbW1pdDsKCSpuZXh0ID0gbmV3X2NvbW1pdDsKCW5ld19jb21taXQtPm5leHQgPSBOVUxMOwoJcmV0dXJuICZuZXdfY29tbWl0LT5uZXh0Owp9Cgpjb25zdCBjaGFyICpmaW5kX2NvbW1pdF9oZWFkZXIoY29uc3QgY2hhciAqbXNnLCBjb25zdCBjaGFyICprZXksIHNpemVfdCAqb3V0X2xlbikKewoJaW50IGtleV9sZW4gPSBzdHJsZW4oa2V5KTsKCWNvbnN0IGNoYXIgKmxpbmUgPSBtc2c7CgoJd2hpbGUgKGxpbmUpIHsKCQljb25zdCBjaGFyICplb2wgPSBzdHJjaHJudWwobGluZSwgJ1xuJyk7CgoJCWlmIChsaW5lID09IGVvbCkKCQkJcmV0dXJuIE5VTEw7CgoJCWlmIChlb2wgLSBsaW5lID4ga2V5X2xlbiAmJgoJCSAgICAhc3RybmNtcChsaW5lLCBrZXksIGtleV9sZW4pICYmCgkJICAgIGxpbmVba2V5X2xlbl0gPT0gJyAnKSB7CgkJCSpvdXRfbGVuID0gZW9sIC0gbGluZSAtIGtleV9sZW4gLSAxOwoJCQlyZXR1cm4gbGluZSArIGtleV9sZW4gKyAxOwoJCX0KCQlsaW5lID0gKmVvbCA/IGVvbCArIDEgOiBOVUxMOwoJfQoJcmV0dXJuIE5VTEw7Cn0KCi8qCiAqIEluc3BlY3QgdGhlIGdpdmVuIHN0cmluZyBhbmQgZGV0ZXJtaW5lIHRoZSB0cnVlICJlbmQiIG9mIHRoZSBsb2cgbWVzc2FnZSwgaW4KICogb3JkZXIgdG8gZmluZCB3aGVyZSB0byBwdXQgYSBuZXcgU2lnbmVkLW9mZi1ieTogbGluZS4gIElnbm9yZWQgYXJlCiAqIHRyYWlsaW5nIGNvbW1lbnQgbGluZXMgYW5kIGJsYW5rIGxpbmVzLiAgVG8gc3VwcG9ydCAiZ2l0IGNvbW1pdCAtcwogKiAtLWFtZW5kIiBvbiBhbiBleGlzdGluZyBjb21taXQsIHdlIGFsc28gaWdub3JlICJDb25mbGljdHM6Ii4gIFRvCiAqIHN1cHBvcnQgImdpdCBjb21taXQgLXYiLCB3ZSB0cnVuY2F0ZSBhdCBjdXQgbGluZXMuCiAqCiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyBmcm9tIHRoZSB0YWlsIHRvIGlnbm9yZSwgdG8gYmUgZmVkIGFzCiAqIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGFwcGVuZF9zaWdub2ZmKCkuCiAqLwppbnQgaWdub3JlX25vbl90cmFpbGVyKGNvbnN0IGNoYXIgKmJ1Ziwgc2l6ZV90IGxlbikKewoJaW50IGJvYyA9IDA7CglpbnQgYm9sID0gMDsKCWludCBpbl9vbGRfY29uZmxpY3RzX2Jsb2NrID0gMDsKCXNpemVfdCBjdXRvZmYgPSB3dF9zdGF0dXNfbG9jYXRlX2VuZChidWYsIGxlbik7CgoJd2hpbGUgKGJvbCA8IGN1dG9mZikgewoJCWNvbnN0IGNoYXIgKm5leHRfbGluZSA9IG1lbWNocihidWYgKyBib2wsICdcbicsIGxlbiAtIGJvbCk7CgoJCWlmICghbmV4dF9saW5lKQoJCQluZXh0X2xpbmUgPSBidWYgKyBsZW47CgkJZWxzZQoJCQluZXh0X2xpbmUrKzsKCgkJaWYgKGJ1Zltib2xdID09IGNvbW1lbnRfbGluZV9jaGFyIHx8IGJ1Zltib2xdID09ICdcbicpIHsKCQkJLyogaXMgdGhpcyB0aGUgZmlyc3Qgb2YgdGhlIHJ1biBvZiBjb21tZW50cz8gKi8KCQkJaWYgKCFib2MpCgkJCQlib2MgPSBib2w7CgkJCS8qIG90aGVyd2lzZSwgaXQgaXMganVzdCBjb250aW51aW5nICovCgkJfSBlbHNlIGlmIChzdGFydHNfd2l0aChidWYgKyBib2wsICJDb25mbGljdHM6XG4iKSkgewoJCQlpbl9vbGRfY29uZmxpY3RzX2Jsb2NrID0gMTsKCQkJaWYgKCFib2MpCgkJCQlib2MgPSBib2w7CgkJfSBlbHNlIGlmIChpbl9vbGRfY29uZmxpY3RzX2Jsb2NrICYmIGJ1Zltib2xdID09ICdcdCcpIHsKCQkJOyAvKiBhIHBhdGhuYW1lIGluIHRoZSBjb25mbGljdHMgYmxvY2sgKi8KCQl9IGVsc2UgaWYgKGJvYykgewoJCQkvKiB0aGUgcHJldmlvdXMgd2FzIG5vdCB0cmFpbGluZyBjb21tZW50ICovCgkJCWJvYyA9IDA7CgkJCWluX29sZF9jb25mbGljdHNfYmxvY2sgPSAwOwoJCX0KCQlib2wgPSBuZXh0X2xpbmUgLSBidWY7Cgl9CglyZXR1cm4gYm9jID8gbGVuIC0gYm9jIDogbGVuIC0gY3V0b2ZmOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"commit-graph.h\"\n#include \"pkt-line.h\"\n#include \"utf8.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"notes.h\"\n#include \"gpg-interface.h\"\n#include \"mergesort.h\"\n#include \"commit-slab.h\"\n#include \"prio-queue.h\"\n#include \"sha1-lookup.h\"\n#include \"wt-status.h\"\n#include \"advice.h\"\n\nstatic struct commit_extra_header *read_commit_extra_header_lines(const char *buf, size_t len, const char **);\n\nint save_commit_buffer = 1;\n\nconst char *commit_type = \"commit\";\n\nstruct commit *lookup_commit_reference_gently(const struct object_id *oid,\n\t\t\t\t\t      int quiet)\n{\n\tstruct object *obj = deref_tag(parse_object(oid), NULL, 0);\n\n\tif (!obj)\n\t\treturn NULL;\n\treturn object_as_type(obj, OBJ_COMMIT, quiet);\n}\n\nstruct commit *lookup_commit_reference(const struct object_id *oid)\n{\n\treturn lookup_commit_reference_gently(oid, 0);\n}\n\nstruct commit *lookup_commit_or_die(const struct object_id *oid, const char *ref_name)\n{\n\tstruct commit *c = lookup_commit_reference(oid);\n\tif (!c)\n\t\tdie(_(\"could not parse %s\"), ref_name);\n\tif (oidcmp(oid, &c->object.oid)) {\n\t\twarning(_(\"%s %s is not a commit!\"),\n\t\t\tref_name, oid_to_hex(oid));\n\t}\n\treturn c;\n}\n\nstruct commit *lookup_commit(const struct object_id *oid)\n{\n\tstruct object *obj = lookup_object(oid->hash);\n\tif (!obj)\n\t\treturn create_object(oid->hash, alloc_commit_node());\n\treturn object_as_type(obj, OBJ_COMMIT, 0);\n}\n\nstruct commit *lookup_commit_reference_by_name(const char *name)\n{\n\tstruct object_id oid;\n\tstruct commit *commit;\n\n\tif (get_oid_committish(name, &oid))\n\t\treturn NULL;\n\tcommit = lookup_commit_reference(&oid);\n\tif (parse_commit(commit))\n\t\treturn NULL;\n\treturn commit;\n}\n\nstatic timestamp_t parse_commit_date(const char *buf, const char *tail)\n{\n\tconst char *dateptr;\n\n\tif (buf + 6 >= tail)\n\t\treturn 0;\n\tif (memcmp(buf, \"author\", 6))\n\t\treturn 0;\n\twhile (buf < tail && *buf++ != '\\n')\n\t\t/* nada */;\n\tif (buf + 9 >= tail)\n\t\treturn 0;\n\tif (memcmp(buf, \"committer\", 9))\n\t\treturn 0;\n\twhile (buf < tail && *buf++ != '>')\n\t\t/* nada */;\n\tif (buf >= tail)\n\t\treturn 0;\n\tdateptr = buf;\n\twhile (buf < tail && *buf++ != '\\n')\n\t\t/* nada */;\n\tif (buf >= tail)\n\t\treturn 0;\n\t/* dateptr < buf && buf[-1] == '\\n', so parsing will stop at buf-1 */\n\treturn parse_timestamp(dateptr, NULL, 10);\n}\n\nstatic struct commit_graft **commit_graft;\nstatic int commit_graft_alloc, commit_graft_nr;\n\nstatic const unsigned char *commit_graft_sha1_access(size_t index, void *table)\n{\n\tstruct commit_graft **commit_graft_table = table;\n\treturn commit_graft_table[index]->oid.hash;\n}\n\nstatic int commit_graft_pos(const unsigned char *sha1)\n{\n\treturn sha1_pos(sha1, commit_graft, commit_graft_nr,\n\t\t\tcommit_graft_sha1_access);\n}\n\nint register_commit_graft(struct commit_graft *graft, int ignore_dups)\n{\n\tint pos = commit_graft_pos(graft->oid.hash);\n\n\tif (0 <= pos) {\n\t\tif (ignore_dups)\n\t\t\tfree(graft);\n\t\telse {\n\t\t\tfree(commit_graft[pos]);\n\t\t\tcommit_graft[pos] = graft;\n\t\t}\n\t\treturn 1;\n\t}\n\tpos = -pos - 1;\n\tALLOC_GROW(commit_graft, commit_graft_nr + 1, commit_graft_alloc);\n\tcommit_graft_nr++;\n\tif (pos < commit_graft_nr)\n\t\tMOVE_ARRAY(commit_graft + pos + 1, commit_graft + pos,\n\t\t\t   commit_graft_nr - pos - 1);\n\tcommit_graft[pos] = graft;\n\treturn 0;\n}\n\nstruct commit_graft *read_graft_line(struct strbuf *line)\n{\n\t/* The format is just \"Commit Parent1 Parent2 ...\\n\" */\n\tint i, phase;\n\tconst char *tail = NULL;\n\tstruct commit_graft *graft = NULL;\n\tstruct object_id dummy_oid, *oid;\n\n\tstrbuf_rtrim(line);\n\tif (!line->len || line->buf[0] == '#')\n\t\treturn NULL;\n\t/*\n\t * phase 0 verifies line, counts hashes in line and allocates graft\n\t * phase 1 fills graft\n\t */\n\tfor (phase = 0; phase < 2; phase++) {\n\t\toid = graft ? &graft->oid : &dummy_oid;\n\t\tif (parse_oid_hex(line->buf, oid, &tail))\n\t\t\tgoto bad_graft_data;\n\t\tfor (i = 0; *tail != '\\0'; i++) {\n\t\t\toid = graft ? &graft->parent[i] : &dummy_oid;\n\t\t\tif (!isspace(*tail++) || parse_oid_hex(tail, oid, &tail))\n\t\t\t\tgoto bad_graft_data;\n\t\t}\n\t\tif (!graft) {\n\t\t\tgraft = xmalloc(st_add(sizeof(*graft),\n\t\t\t\t\t       st_mult(sizeof(struct object_id), i)));\n\t\t\tgraft->nr_parent = i;\n\t\t}\n\t}\n\treturn graft;\n\nbad_graft_data:\n\terror(\"bad graft data: %s\", line->buf);\n\tassert(!graft);\n\treturn NULL;\n}\n\nstatic int read_graft_file(const char *graft_file)\n{\n\tFILE *fp = fopen_or_warn(graft_file, \"r\");\n\tstruct strbuf buf = STRBUF_INIT;\n\tif (!fp)\n\t\treturn -1;\n\tif (advice_graft_file_deprecated)\n\t\tadvise(_(\"Support for <GIT_DIR>/info/grafts is deprecated\\n\"\n\t\t\t \"and will be removed in a future Git version.\\n\"\n\t\t\t \"\\n\"\n\t\t\t \"Please use \\\"git replace --convert-graft-file\\\"\\n\"\n\t\t\t \"to convert the grafts into replace refs.\\n\"\n\t\t\t \"\\n\"\n\t\t\t \"Turn this message off by running\\n\"\n\t\t\t \"\\\"git config advice.graftFileDeprecated false\\\"\"));\n\twhile (!strbuf_getwholeline(&buf, fp, '\\n')) {\n\t\t/* The format is just \"Commit Parent1 Parent2 ...\\n\" */\n\t\tstruct commit_graft *graft = read_graft_line(&buf);\n\t\tif (!graft)\n\t\t\tcontinue;\n\t\tif (register_commit_graft(graft, 1))\n\t\t\terror(\"duplicate graft data: %s\", buf.buf);\n\t}\n\tfclose(fp);\n\tstrbuf_release(&buf);\n\treturn 0;\n}\n\nstatic void prepare_commit_graft(void)\n{\n\tstatic int commit_graft_prepared;\n\tchar *graft_file;\n\n\tif (commit_graft_prepared)\n\t\treturn;\n\tif (!startup_info->have_repository)\n\t\treturn;\n\n\tgraft_file = get_graft_file();\n\tread_graft_file(graft_file);\n\t/* make sure shallows are read */\n\tis_repository_shallow();\n\tcommit_graft_prepared = 1;\n}\n\nstruct commit_graft *lookup_commit_graft(const struct object_id *oid)\n{\n\tint pos;\n\tprepare_commit_graft();\n\tpos = commit_graft_pos(oid->hash);\n\tif (pos < 0)\n\t\treturn NULL;\n\treturn commit_graft[pos];\n}\n\nint for_each_commit_graft(each_commit_graft_fn fn, void *cb_data)\n{\n\tint i, ret;\n\tfor (i = ret = 0; i < commit_graft_nr && !ret; i++)\n\t\tret = fn(commit_graft[i], cb_data);\n\treturn ret;\n}\n\nint unregister_shallow(const struct object_id *oid)\n{\n\tint pos = commit_graft_pos(oid->hash);\n\tif (pos < 0)\n\t\treturn -1;\n\tif (pos + 1 < commit_graft_nr)\n\t\tMOVE_ARRAY(commit_graft + pos, commit_graft + pos + 1,\n\t\t\t   commit_graft_nr - pos - 1);\n\tcommit_graft_nr--;\n\treturn 0;\n}\n\nstruct commit_buffer {\n\tvoid *buffer;\n\tunsigned long size;\n};\ndefine_commit_slab(buffer_slab, struct commit_buffer);\nstatic struct buffer_slab buffer_slab = COMMIT_SLAB_INIT(1, buffer_slab);\n\nvoid set_commit_buffer(struct commit *commit, void *buffer, unsigned long size)\n{\n\tstruct commit_buffer *v = buffer_slab_at(&buffer_slab, commit);\n\tv->buffer = buffer;\n\tv->size = size;\n}\n\nconst void *get_cached_commit_buffer(const struct commit *commit, unsigned long *sizep)\n{\n\tstruct commit_buffer *v = buffer_slab_peek(&buffer_slab, commit);\n\tif (!v) {\n\t\tif (sizep)\n\t\t\t*sizep = 0;\n\t\treturn NULL;\n\t}\n\tif (sizep)\n\t\t*sizep = v->size;\n\treturn v->buffer;\n}\n\nconst void *get_commit_buffer(const struct commit *commit, unsigned long *sizep)\n{\n\tconst void *ret = get_cached_commit_buffer(commit, sizep);\n\tif (!ret) {\n\t\tenum object_type type;\n\t\tunsigned long size;\n\t\tret = read_object_file(&commit->object.oid, &type, &size);\n\t\tif (!ret)\n\t\t\tdie(\"cannot read commit object %s\",\n\t\t\t    oid_to_hex(&commit->object.oid));\n\t\tif (type != OBJ_COMMIT)\n\t\t\tdie(\"expected commit for %s, got %s\",\n\t\t\t    oid_to_hex(&commit->object.oid), type_name(type));\n\t\tif (sizep)\n\t\t\t*sizep = size;\n\t}\n\treturn ret;\n}\n\nvoid unuse_commit_buffer(const struct commit *commit, const void *buffer)\n{\n\tstruct commit_buffer *v = buffer_slab_peek(&buffer_slab, commit);\n\tif (!(v && v->buffer == buffer))\n\t\tfree((void *)buffer);\n}\n\nvoid free_commit_buffer(struct commit *commit)\n{\n\tstruct commit_buffer *v = buffer_slab_peek(&buffer_slab, commit);\n\tif (v) {\n\t\tFREE_AND_NULL(v->buffer);\n\t\tv->size = 0;\n\t}\n}\n\nstruct tree *get_commit_tree(const struct commit *commit)\n{\n\tif (commit->maybe_tree || !commit->object.parsed)\n\t\treturn commit->maybe_tree;\n\n\tif (commit->graph_pos == COMMIT_NOT_FROM_GRAPH)\n\t\tBUG(\"commit has NULL tree, but was not loaded from commit-graph\");\n\n\treturn get_commit_tree_in_graph(commit);\n}\n\nstruct object_id *get_commit_tree_oid(const struct commit *commit)\n{\n\treturn &get_commit_tree(commit)->object.oid;\n}\n\nconst void *detach_commit_buffer(struct commit *commit, unsigned long *sizep)\n{\n\tstruct commit_buffer *v = buffer_slab_peek(&buffer_slab, commit);\n\tvoid *ret;\n\n\tif (!v) {\n\t\tif (sizep)\n\t\t\t*sizep = 0;\n\t\treturn NULL;\n\t}\n\tret = v->buffer;\n\tif (sizep)\n\t\t*sizep = v->size;\n\n\tv->buffer = NULL;\n\tv->size = 0;\n\treturn ret;\n}\n\nint parse_commit_buffer(struct commit *item, const void *buffer, unsigned long size)\n{\n\tconst char *tail = buffer;\n\tconst char *bufptr = buffer;\n\tstruct object_id parent;\n\tstruct commit_list **pptr;\n\tstruct commit_graft *graft;\n\tconst int tree_entry_len = GIT_SHA1_HEXSZ + 5;\n\tconst int parent_entry_len = GIT_SHA1_HEXSZ + 7;\n\n\tif (item->object.parsed)\n\t\treturn 0;\n\titem->object.parsed = 1;\n\ttail += size;\n\tif (tail <= bufptr + tree_entry_len + 1 || memcmp(bufptr, \"tree \", 5) ||\n\t\t\tbufptr[tree_entry_len] != '\\n')\n\t\treturn error(\"bogus commit object %s\", oid_to_hex(&item->object.oid));\n\tif (get_oid_hex(bufptr + 5, &parent) < 0)\n\t\treturn error(\"bad tree pointer in commit %s\",\n\t\t\t     oid_to_hex(&item->object.oid));\n\titem->maybe_tree = lookup_tree(&parent);\n\tbufptr += tree_entry_len + 1; /* \"tree \" + \"hex sha1\" + \"\\n\" */\n\tpptr = &item->parents;\n\n\tgraft = lookup_commit_graft(&item->object.oid);\n\twhile (bufptr + parent_entry_len < tail && !memcmp(bufptr, \"parent \", 7)) {\n\t\tstruct commit *new_parent;\n\n\t\tif (tail <= bufptr + parent_entry_len + 1 ||\n\t\t    get_oid_hex(bufptr + 7, &parent) ||\n\t\t    bufptr[parent_entry_len] != '\\n')\n\t\t\treturn error(\"bad parents in commit %s\", oid_to_hex(&item->object.oid));\n\t\tbufptr += parent_entry_len + 1;\n\t\t/*\n\t\t * The clone is shallow if nr_parent < 0, and we must\n\t\t * not traverse its real parents even when we unhide them.\n\t\t */\n\t\tif (graft && (graft->nr_parent < 0 || grafts_replace_parents))\n\t\t\tcontinue;\n\t\tnew_parent = lookup_commit(&parent);\n\t\tif (new_parent)\n\t\t\tpptr = &commit_list_insert(new_parent, pptr)->next;\n\t}\n\tif (graft) {\n\t\tint i;\n\t\tstruct commit *new_parent;\n\t\tfor (i = 0; i < graft->nr_parent; i++) {\n\t\t\tnew_parent = lookup_commit(&graft->parent[i]);\n\t\t\tif (!new_parent)\n\t\t\t\tcontinue;\n\t\t\tpptr = &commit_list_insert(new_parent, pptr)->next;\n\t\t}\n\t}\n\titem->date = parse_commit_date(bufptr, tail);\n\n\treturn 0;\n}\n\nint parse_commit_gently(struct commit *item, int quiet_on_missing)\n{\n\tenum object_type type;\n\tvoid *buffer;\n\tunsigned long size;\n\tint ret;\n\n\tif (!item)\n\t\treturn -1;\n\tif (item->object.parsed)\n\t\treturn 0;\n\tif (parse_commit_in_graph(item))\n\t\treturn 0;\n\tbuffer = read_object_file(&item->object.oid, &type, &size);\n\tif (!buffer)\n\t\treturn quiet_on_missing ? -1 :\n\t\t\terror(\"Could not read %s\",\n\t\t\t     oid_to_hex(&item->object.oid));\n\tif (type != OBJ_COMMIT) {\n\t\tfree(buffer);\n\t\treturn error(\"Object %s not a commit\",\n\t\t\t     oid_to_hex(&item->object.oid));\n\t}\n\tret = parse_commit_buffer(item, buffer, size);\n\tif (save_commit_buffer && !ret) {\n\t\tset_commit_buffer(item, buffer, size);\n\t\treturn 0;\n\t}\n\tfree(buffer);\n\treturn ret;\n}\n\nvoid parse_commit_or_die(struct commit *item)\n{\n\tif (parse_commit(item))\n\t\tdie(\"unable to parse commit %s\",\n\t\t    item ? oid_to_hex(&item->object.oid) : \"(null)\");\n}\n\nint find_commit_subject(const char *commit_buffer, const char **subject)\n{\n\tconst char *eol;\n\tconst char *p = commit_buffer;\n\n\twhile (*p && (*p != '\\n' || p[1] != '\\n'))\n\t\tp++;\n\tif (*p) {\n\t\tp = skip_blank_lines(p + 2);\n\t\teol = strchrnul(p, '\\n');\n\t} else\n\t\teol = p;\n\n\t*subject = p;\n\n\treturn eol - p;\n}\n\nstruct commit_list *commit_list_insert(struct commit *item, struct commit_list **list_p)\n{\n\tstruct commit_list *new_list = xmalloc(sizeof(struct commit_list));\n\tnew_list->item = item;\n\tnew_list->next = *list_p;\n\t*list_p = new_list;\n\treturn new_list;\n}\n\nunsigned commit_list_count(const struct commit_list *l)\n{\n\tunsigned c = 0;\n\tfor (; l; l = l->next )\n\t\tc++;\n\treturn c;\n}\n\nstruct commit_list *copy_commit_list(struct commit_list *list)\n{\n\tstruct commit_list *head = NULL;\n\tstruct commit_list **pp = &head;\n\twhile (list) {\n\t\tpp = commit_list_append(list->item, pp);\n\t\tlist = list->next;\n\t}\n\treturn head;\n}\n\nvoid free_commit_list(struct commit_list *list)\n{\n\twhile (list)\n\t\tpop_commit(&list);\n}\n\nstruct commit_list * commit_list_insert_by_date(struct commit *item, struct commit_list **list)\n{\n\tstruct commit_list **pp = list;\n\tstruct commit_list *p;\n\twhile ((p = *pp) != NULL) {\n\t\tif (p->item->date < item->date) {\n\t\t\tbreak;\n\t\t}\n\t\tpp = &p->next;\n\t}\n\treturn commit_list_insert(item, pp);\n}\n\nstatic int commit_list_compare_by_date(const void *a, const void *b)\n{\n\ttimestamp_t a_date = ((const struct commit_list *)a)->item->date;\n\ttimestamp_t b_date = ((const struct commit_list *)b)->item->date;\n\tif (a_date < b_date)\n\t\treturn 1;\n\tif (a_date > b_date)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void *commit_list_get_next(const void *a)\n{\n\treturn ((const struct commit_list *)a)->next;\n}\n\nstatic void commit_list_set_next(void *a, void *next)\n{\n\t((struct commit_list *)a)->next = next;\n}\n\nvoid commit_list_sort_by_date(struct commit_list **list)\n{\n\t*list = llist_mergesort(*list, commit_list_get_next, commit_list_set_next,\n\t\t\t\tcommit_list_compare_by_date);\n}\n\nstruct commit *pop_most_recent_commit(struct commit_list **list,\n\t\t\t\t      unsigned int mark)\n{\n\tstruct commit *ret = pop_commit(list);\n\tstruct commit_list *parents = ret->parents;\n\n\twhile (parents) {\n\t\tstruct commit *commit = parents->item;\n\t\tif (!parse_commit(commit) && !(commit->object.flags & mark)) {\n\t\t\tcommit->object.flags |= mark;\n\t\t\tcommit_list_insert_by_date(commit, list);\n\t\t}\n\t\tparents = parents->next;\n\t}\n\treturn ret;\n}\n\nstatic void clear_commit_marks_1(struct commit_list **plist,\n\t\t\t\t struct commit *commit, unsigned int mark)\n{\n\twhile (commit) {\n\t\tstruct commit_list *parents;\n\n\t\tif (!(mark & commit->object.flags))\n\t\t\treturn;\n\n\t\tcommit->object.flags &= ~mark;\n\n\t\tparents = commit->parents;\n\t\tif (!parents)\n\t\t\treturn;\n\n\t\twhile ((parents = parents->next))\n\t\t\tcommit_list_insert(parents->item, plist);\n\n\t\tcommit = commit->parents->item;\n\t}\n}\n\nvoid clear_commit_marks_many(int nr, struct commit **commit, unsigned int mark)\n{\n\tstruct commit_list *list = NULL;\n\n\twhile (nr--) {\n\t\tclear_commit_marks_1(&list, *commit, mark);\n\t\tcommit++;\n\t}\n\twhile (list)\n\t\tclear_commit_marks_1(&list, pop_commit(&list), mark);\n}\n\nvoid clear_commit_marks(struct commit *commit, unsigned int mark)\n{\n\tclear_commit_marks_many(1, &commit, mark);\n}\n\nstruct commit *pop_commit(struct commit_list **stack)\n{\n\tstruct commit_list *top = *stack;\n\tstruct commit *item = top ? top->item : NULL;\n\n\tif (top) {\n\t\t*stack = top->next;\n\t\tfree(top);\n\t}\n\treturn item;\n}\n\n/*\n * Topological sort support\n */\n\n/* count number of children that have not been emitted */\ndefine_commit_slab(indegree_slab, int);\n\n/* record author-date for each commit object */\ndefine_commit_slab(author_date_slab, unsigned long);\n\nstatic void record_author_date(struct author_date_slab *author_date,\n\t\t\t       struct commit *commit)\n{\n\tconst char *buffer = get_commit_buffer(commit, NULL);\n\tstruct ident_split ident;\n\tconst char *ident_line;\n\tsize_t ident_len;\n\tchar *date_end;\n\ttimestamp_t date;\n\n\tident_line = find_commit_header(buffer, \"author\", &ident_len);\n\tif (!ident_line)\n\t\tgoto fail_exit; /* no author line */\n\tif (split_ident_line(&ident, ident_line, ident_len) ||\n\t    !ident.date_begin || !ident.date_end)\n\t\tgoto fail_exit; /* malformed \"author\" line */\n\n\tdate = parse_timestamp(ident.date_begin, &date_end, 10);\n\tif (date_end != ident.date_end)\n\t\tgoto fail_exit; /* malformed date */\n\t*(author_date_slab_at(author_date, commit)) = date;\n\nfail_exit:\n\tunuse_commit_buffer(commit, buffer);\n}\n\nstatic int compare_commits_by_author_date(const void *a_, const void *b_,\n\t\t\t\t\t  void *cb_data)\n{\n\tconst struct commit *a = a_, *b = b_;\n\tstruct author_date_slab *author_date = cb_data;\n\ttimestamp_t a_date = *(author_date_slab_at(author_date, a));\n\ttimestamp_t b_date = *(author_date_slab_at(author_date, b));\n\n\t/* newer commits with larger date first */\n\tif (a_date < b_date)\n\t\treturn 1;\n\telse if (a_date > b_date)\n\t\treturn -1;\n\treturn 0;\n}\n\nint compare_commits_by_commit_date(const void *a_, const void *b_, void *unused)\n{\n\tconst struct commit *a = a_, *b = b_;\n\t/* newer commits with larger date first */\n\tif (a->date < b->date)\n\t\treturn 1;\n\telse if (a->date > b->date)\n\t\treturn -1;\n\treturn 0;\n}\n\n/*\n * Performs an in-place topological sort on the list supplied.\n */\nvoid sort_in_topological_order(struct commit_list **list, enum rev_sort_order sort_order)\n{\n\tstruct commit_list *next, *orig = *list;\n\tstruct commit_list **pptr;\n\tstruct indegree_slab indegree;\n\tstruct prio_queue queue;\n\tstruct commit *commit;\n\tstruct author_date_slab author_date;\n\n\tif (!orig)\n\t\treturn;\n\t*list = NULL;\n\n\tinit_indegree_slab(&indegree);\n\tmemset(&queue, '\\0', sizeof(queue));\n\n\tswitch (sort_order) {\n\tdefault: /* REV_SORT_IN_GRAPH_ORDER */\n\t\tqueue.compare = NULL;\n\t\tbreak;\n\tcase REV_SORT_BY_COMMIT_DATE:\n\t\tqueue.compare = compare_commits_by_commit_date;\n\t\tbreak;\n\tcase REV_SORT_BY_AUTHOR_DATE:\n\t\tinit_author_date_slab(&author_date);\n\t\tqueue.compare = compare_commits_by_author_date;\n\t\tqueue.cb_data = &author_date;\n\t\tbreak;\n\t}\n\n\t/* Mark them and clear the indegree */\n\tfor (next = orig; next; next = next->next) {\n\t\tstruct commit *commit = next->item;\n\t\t*(indegree_slab_at(&indegree, commit)) = 1;\n\t\t/* also record the author dates, if needed */\n\t\tif (sort_order == REV_SORT_BY_AUTHOR_DATE)\n\t\t\trecord_author_date(&author_date, commit);\n\t}\n\n\t/* update the indegree */\n\tfor (next = orig; next; next = next->next) {\n\t\tstruct commit_list *parents = next->item->parents;\n\t\twhile (parents) {\n\t\t\tstruct commit *parent = parents->item;\n\t\t\tint *pi = indegree_slab_at(&indegree, parent);\n\n\t\t\tif (*pi)\n\t\t\t\t(*pi)++;\n\t\t\tparents = parents->next;\n\t\t}\n\t}\n\n\t/*\n\t * find the tips\n\t *\n\t * tips are nodes not reachable from any other node in the list\n\t *\n\t * the tips serve as a starting set for the work queue.\n\t */\n\tfor (next = orig; next; next = next->next) {\n\t\tstruct commit *commit = next->item;\n\n\t\tif (*(indegree_slab_at(&indegree, commit)) == 1)\n\t\t\tprio_queue_put(&queue, commit);\n\t}\n\n\t/*\n\t * This is unfortunate; the initial tips need to be shown\n\t * in the order given from the revision traversal machinery.\n\t */\n\tif (sort_order == REV_SORT_IN_GRAPH_ORDER)\n\t\tprio_queue_reverse(&queue);\n\n\t/* We no longer need the commit list */\n\tfree_commit_list(orig);\n\n\tpptr = list;\n\t*list = NULL;\n\twhile ((commit = prio_queue_get(&queue)) != NULL) {\n\t\tstruct commit_list *parents;\n\n\t\tfor (parents = commit->parents; parents ; parents = parents->next) {\n\t\t\tstruct commit *parent = parents->item;\n\t\t\tint *pi = indegree_slab_at(&indegree, parent);\n\n\t\t\tif (!*pi)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * parents are only enqueued for emission\n\t\t\t * when all their children have been emitted thereby\n\t\t\t * guaranteeing topological order.\n\t\t\t */\n\t\t\tif (--(*pi) == 1)\n\t\t\t\tprio_queue_put(&queue, parent);\n\t\t}\n\t\t/*\n\t\t * all children of commit have already been\n\t\t * emitted. we can emit it now.\n\t\t */\n\t\t*(indegree_slab_at(&indegree, commit)) = 0;\n\n\t\tpptr = &commit_list_insert(commit, pptr)->next;\n\t}\n\n\tclear_indegree_slab(&indegree);\n\tclear_prio_queue(&queue);\n\tif (sort_order == REV_SORT_BY_AUTHOR_DATE)\n\t\tclear_author_date_slab(&author_date);\n}\n\n/* merge-base stuff */\n\n/* Remember to update object flag allocation in object.h */\n#define PARENT1\t\t(1u<<16)\n#define PARENT2\t\t(1u<<17)\n#define STALE\t\t(1u<<18)\n#define RESULT\t\t(1u<<19)\n\nstatic const unsigned all_flags = (PARENT1 | PARENT2 | STALE | RESULT);\n\nstatic int queue_has_nonstale(struct prio_queue *queue)\n{\n\tint i;\n\tfor (i = 0; i < queue->nr; i++) {\n\t\tstruct commit *commit = queue->array[i].data;\n\t\tif (!(commit->object.flags & STALE))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* all input commits in one and twos[] must have been parsed! */\nstatic struct commit_list *paint_down_to_common(struct commit *one, int n, struct commit **twos)\n{\n\tstruct prio_queue queue = { compare_commits_by_commit_date };\n\tstruct commit_list *result = NULL;\n\tint i;\n\n\tone->object.flags |= PARENT1;\n\tif (!n) {\n\t\tcommit_list_append(one, &result);\n\t\treturn result;\n\t}\n\tprio_queue_put(&queue, one);\n\n\tfor (i = 0; i < n; i++) {\n\t\ttwos[i]->object.flags |= PARENT2;\n\t\tprio_queue_put(&queue, twos[i]);\n\t}\n\n\twhile (queue_has_nonstale(&queue)) {\n\t\tstruct commit *commit = prio_queue_get(&queue);\n\t\tstruct commit_list *parents;\n\t\tint flags;\n\n\t\tflags = commit->object.flags & (PARENT1 | PARENT2 | STALE);\n\t\tif (flags == (PARENT1 | PARENT2)) {\n\t\t\tif (!(commit->object.flags & RESULT)) {\n\t\t\t\tcommit->object.flags |= RESULT;\n\t\t\t\tcommit_list_insert_by_date(commit, &result);\n\t\t\t}\n\t\t\t/* Mark parents of a found merge stale */\n\t\t\tflags |= STALE;\n\t\t}\n\t\tparents = commit->parents;\n\t\twhile (parents) {\n\t\t\tstruct commit *p = parents->item;\n\t\t\tparents = parents->next;\n\t\t\tif ((p->object.flags & flags) == flags)\n\t\t\t\tcontinue;\n\t\t\tif (parse_commit(p))\n\t\t\t\treturn NULL;\n\t\t\tp->object.flags |= flags;\n\t\t\tprio_queue_put(&queue, p);\n\t\t}\n\t}\n\n\tclear_prio_queue(&queue);\n\treturn result;\n}\n\nstatic struct commit_list *merge_bases_many(struct commit *one, int n, struct commit **twos)\n{\n\tstruct commit_list *list = NULL;\n\tstruct commit_list *result = NULL;\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (one == twos[i])\n\t\t\t/*\n\t\t\t * We do not mark this even with RESULT so we do not\n\t\t\t * have to clean it up.\n\t\t\t */\n\t\t\treturn commit_list_insert(one, &result);\n\t}\n\n\tif (parse_commit(one))\n\t\treturn NULL;\n\tfor (i = 0; i < n; i++) {\n\t\tif (parse_commit(twos[i]))\n\t\t\treturn NULL;\n\t}\n\n\tlist = paint_down_to_common(one, n, twos);\n\n\twhile (list) {\n\t\tstruct commit *commit = pop_commit(&list);\n\t\tif (!(commit->object.flags & STALE))\n\t\t\tcommit_list_insert_by_date(commit, &result);\n\t}\n\treturn result;\n}\n\nstruct commit_list *get_octopus_merge_bases(struct commit_list *in)\n{\n\tstruct commit_list *i, *j, *k, *ret = NULL;\n\n\tif (!in)\n\t\treturn ret;\n\n\tcommit_list_insert(in->item, &ret);\n\n\tfor (i = in->next; i; i = i->next) {\n\t\tstruct commit_list *new_commits = NULL, *end = NULL;\n\n\t\tfor (j = ret; j; j = j->next) {\n\t\t\tstruct commit_list *bases;\n\t\t\tbases = get_merge_bases(i->item, j->item);\n\t\t\tif (!new_commits)\n\t\t\t\tnew_commits = bases;\n\t\t\telse\n\t\t\t\tend->next = bases;\n\t\t\tfor (k = bases; k; k = k->next)\n\t\t\t\tend = k;\n\t\t}\n\t\tret = new_commits;\n\t}\n\treturn ret;\n}\n\nstatic int remove_redundant(struct commit **array, int cnt)\n{\n\t/*\n\t * Some commit in the array may be an ancestor of\n\t * another commit.  Move such commit to the end of\n\t * the array, and return the number of commits that\n\t * are independent from each other.\n\t */\n\tstruct commit **work;\n\tunsigned char *redundant;\n\tint *filled_index;\n\tint i, j, filled;\n\n\twork = xcalloc(cnt, sizeof(*work));\n\tredundant = xcalloc(cnt, 1);\n\tALLOC_ARRAY(filled_index, cnt - 1);\n\n\tfor (i = 0; i < cnt; i++)\n\t\tparse_commit(array[i]);\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct commit_list *common;\n\n\t\tif (redundant[i])\n\t\t\tcontinue;\n\t\tfor (j = filled = 0; j < cnt; j++) {\n\t\t\tif (i == j || redundant[j])\n\t\t\t\tcontinue;\n\t\t\tfilled_index[filled] = j;\n\t\t\twork[filled++] = array[j];\n\t\t}\n\t\tcommon = paint_down_to_common(array[i], filled, work);\n\t\tif (array[i]->object.flags & PARENT2)\n\t\t\tredundant[i] = 1;\n\t\tfor (j = 0; j < filled; j++)\n\t\t\tif (work[j]->object.flags & PARENT1)\n\t\t\t\tredundant[filled_index[j]] = 1;\n\t\tclear_commit_marks(array[i], all_flags);\n\t\tclear_commit_marks_many(filled, work, all_flags);\n\t\tfree_commit_list(common);\n\t}\n\n\t/* Now collect the result */\n\tCOPY_ARRAY(work, array, cnt);\n\tfor (i = filled = 0; i < cnt; i++)\n\t\tif (!redundant[i])\n\t\t\tarray[filled++] = work[i];\n\tfor (j = filled, i = 0; i < cnt; i++)\n\t\tif (redundant[i])\n\t\t\tarray[j++] = work[i];\n\tfree(work);\n\tfree(redundant);\n\tfree(filled_index);\n\treturn filled;\n}\n\nstatic struct commit_list *get_merge_bases_many_0(struct commit *one,\n\t\t\t\t\t\t  int n,\n\t\t\t\t\t\t  struct commit **twos,\n\t\t\t\t\t\t  int cleanup)\n{\n\tstruct commit_list *list;\n\tstruct commit **rslt;\n\tstruct commit_list *result;\n\tint cnt, i;\n\n\tresult = merge_bases_many(one, n, twos);\n\tfor (i = 0; i < n; i++) {\n\t\tif (one == twos[i])\n\t\t\treturn result;\n\t}\n\tif (!result || !result->next) {\n\t\tif (cleanup) {\n\t\t\tclear_commit_marks(one, all_flags);\n\t\t\tclear_commit_marks_many(n, twos, all_flags);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/* There are more than one */\n\tcnt = commit_list_count(result);\n\trslt = xcalloc(cnt, sizeof(*rslt));\n\tfor (list = result, i = 0; list; list = list->next)\n\t\trslt[i++] = list->item;\n\tfree_commit_list(result);\n\n\tclear_commit_marks(one, all_flags);\n\tclear_commit_marks_many(n, twos, all_flags);\n\n\tcnt = remove_redundant(rslt, cnt);\n\tresult = NULL;\n\tfor (i = 0; i < cnt; i++)\n\t\tcommit_list_insert_by_date(rslt[i], &result);\n\tfree(rslt);\n\treturn result;\n}\n\nstruct commit_list *get_merge_bases_many(struct commit *one,\n\t\t\t\t\t int n,\n\t\t\t\t\t struct commit **twos)\n{\n\treturn get_merge_bases_many_0(one, n, twos, 1);\n}\n\nstruct commit_list *get_merge_bases_many_dirty(struct commit *one,\n\t\t\t\t\t       int n,\n\t\t\t\t\t       struct commit **twos)\n{\n\treturn get_merge_bases_many_0(one, n, twos, 0);\n}\n\nstruct commit_list *get_merge_bases(struct commit *one, struct commit *two)\n{\n\treturn get_merge_bases_many_0(one, 1, &two, 1);\n}\n\n/*\n * Is \"commit\" a descendant of one of the elements on the \"with_commit\" list?\n */\nint is_descendant_of(struct commit *commit, struct commit_list *with_commit)\n{\n\tif (!with_commit)\n\t\treturn 1;\n\twhile (with_commit) {\n\t\tstruct commit *other;\n\n\t\tother = with_commit->item;\n\t\twith_commit = with_commit->next;\n\t\tif (in_merge_bases(other, commit))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Is \"commit\" an ancestor of one of the \"references\"?\n */\nint in_merge_bases_many(struct commit *commit, int nr_reference, struct commit **reference)\n{\n\tstruct commit_list *bases;\n\tint ret = 0, i;\n\n\tif (parse_commit(commit))\n\t\treturn ret;\n\tfor (i = 0; i < nr_reference; i++)\n\t\tif (parse_commit(reference[i]))\n\t\t\treturn ret;\n\n\tbases = paint_down_to_common(commit, nr_reference, reference);\n\tif (commit->object.flags & PARENT2)\n\t\tret = 1;\n\tclear_commit_marks(commit, all_flags);\n\tclear_commit_marks_many(nr_reference, reference, all_flags);\n\tfree_commit_list(bases);\n\treturn ret;\n}\n\n/*\n * Is \"commit\" an ancestor of (i.e. reachable from) the \"reference\"?\n */\nint in_merge_bases(struct commit *commit, struct commit *reference)\n{\n\treturn in_merge_bases_many(commit, 1, &reference);\n}\n\nstruct commit_list *reduce_heads(struct commit_list *heads)\n{\n\tstruct commit_list *p;\n\tstruct commit_list *result = NULL, **tail = &result;\n\tstruct commit **array;\n\tint num_head, i;\n\n\tif (!heads)\n\t\treturn NULL;\n\n\t/* Uniquify */\n\tfor (p = heads; p; p = p->next)\n\t\tp->item->object.flags &= ~STALE;\n\tfor (p = heads, num_head = 0; p; p = p->next) {\n\t\tif (p->item->object.flags & STALE)\n\t\t\tcontinue;\n\t\tp->item->object.flags |= STALE;\n\t\tnum_head++;\n\t}\n\tarray = xcalloc(num_head, sizeof(*array));\n\tfor (p = heads, i = 0; p; p = p->next) {\n\t\tif (p->item->object.flags & STALE) {\n\t\t\tarray[i++] = p->item;\n\t\t\tp->item->object.flags &= ~STALE;\n\t\t}\n\t}\n\tnum_head = remove_redundant(array, num_head);\n\tfor (i = 0; i < num_head; i++)\n\t\ttail = &commit_list_insert(array[i], tail)->next;\n\tfree(array);\n\treturn result;\n}\n\nvoid reduce_heads_replace(struct commit_list **heads)\n{\n\tstruct commit_list *result = reduce_heads(*heads);\n\tfree_commit_list(*heads);\n\t*heads = result;\n}\n\nstatic const char gpg_sig_header[] = \"gpgsig\";\nstatic const int gpg_sig_header_len = sizeof(gpg_sig_header) - 1;\n\nstatic int do_sign_commit(struct strbuf *buf, const char *keyid)\n{\n\tstruct strbuf sig = STRBUF_INIT;\n\tint inspos, copypos;\n\tconst char *eoh;\n\n\t/* find the end of the header */\n\teoh = strstr(buf->buf, \"\\n\\n\");\n\tif (!eoh)\n\t\tinspos = buf->len;\n\telse\n\t\tinspos = eoh - buf->buf + 1;\n\n\tif (!keyid || !*keyid)\n\t\tkeyid = get_signing_key();\n\tif (sign_buffer(buf, &sig, keyid)) {\n\t\tstrbuf_release(&sig);\n\t\treturn -1;\n\t}\n\n\tfor (copypos = 0; sig.buf[copypos]; ) {\n\t\tconst char *bol = sig.buf + copypos;\n\t\tconst char *eol = strchrnul(bol, '\\n');\n\t\tint len = (eol - bol) + !!*eol;\n\n\t\tif (!copypos) {\n\t\t\tstrbuf_insert(buf, inspos, gpg_sig_header, gpg_sig_header_len);\n\t\t\tinspos += gpg_sig_header_len;\n\t\t}\n\t\tstrbuf_insert(buf, inspos++, \" \", 1);\n\t\tstrbuf_insert(buf, inspos, bol, len);\n\t\tinspos += len;\n\t\tcopypos += len;\n\t}\n\tstrbuf_release(&sig);\n\treturn 0;\n}\n\nint parse_signed_commit(const struct commit *commit,\n\t\t\tstruct strbuf *payload, struct strbuf *signature)\n{\n\n\tunsigned long size;\n\tconst char *buffer = get_commit_buffer(commit, &size);\n\tint in_signature, saw_signature = -1;\n\tconst char *line, *tail;\n\n\tline = buffer;\n\ttail = buffer + size;\n\tin_signature = 0;\n\tsaw_signature = 0;\n\twhile (line < tail) {\n\t\tconst char *sig = NULL;\n\t\tconst char *next = memchr(line, '\\n', tail - line);\n\n\t\tnext = next ? next + 1 : tail;\n\t\tif (in_signature && line[0] == ' ')\n\t\t\tsig = line + 1;\n\t\telse if (starts_with(line, gpg_sig_header) &&\n\t\t\t line[gpg_sig_header_len] == ' ')\n\t\t\tsig = line + gpg_sig_header_len + 1;\n\t\tif (sig) {\n\t\t\tstrbuf_add(signature, sig, next - sig);\n\t\t\tsaw_signature = 1;\n\t\t\tin_signature = 1;\n\t\t} else {\n\t\t\tif (*line == '\\n')\n\t\t\t\t/* dump the whole remainder of the buffer */\n\t\t\t\tnext = tail;\n\t\t\tstrbuf_add(payload, line, next - line);\n\t\t\tin_signature = 0;\n\t\t}\n\t\tline = next;\n\t}\n\tunuse_commit_buffer(commit, buffer);\n\treturn saw_signature;\n}\n\nint remove_signature(struct strbuf *buf)\n{\n\tconst char *line = buf->buf;\n\tconst char *tail = buf->buf + buf->len;\n\tint in_signature = 0;\n\tconst char *sig_start = NULL;\n\tconst char *sig_end = NULL;\n\n\twhile (line < tail) {\n\t\tconst char *next = memchr(line, '\\n', tail - line);\n\t\tnext = next ? next + 1 : tail;\n\n\t\tif (in_signature && line[0] == ' ')\n\t\t\tsig_end = next;\n\t\telse if (starts_with(line, gpg_sig_header) &&\n\t\t\t line[gpg_sig_header_len] == ' ') {\n\t\t\tsig_start = line;\n\t\t\tsig_end = next;\n\t\t\tin_signature = 1;\n\t\t} else {\n\t\t\tif (*line == '\\n')\n\t\t\t\t/* dump the whole remainder of the buffer */\n\t\t\t\tnext = tail;\n\t\t\tin_signature = 0;\n\t\t}\n\t\tline = next;\n\t}\n\n\tif (sig_start)\n\t\tstrbuf_remove(buf, sig_start - buf->buf, sig_end - sig_start);\n\n\treturn sig_start != NULL;\n}\n\nstatic void handle_signed_tag(struct commit *parent, struct commit_extra_header ***tail)\n{\n\tstruct merge_remote_desc *desc;\n\tstruct commit_extra_header *mergetag;\n\tchar *buf;\n\tunsigned long size, len;\n\tenum object_type type;\n\n\tdesc = merge_remote_util(parent);\n\tif (!desc || !desc->obj)\n\t\treturn;\n\tbuf = read_object_file(&desc->obj->oid, &type, &size);\n\tif (!buf || type != OBJ_TAG)\n\t\tgoto free_return;\n\tlen = parse_signature(buf, size);\n\tif (size == len)\n\t\tgoto free_return;\n\t/*\n\t * We could verify this signature and either omit the tag when\n\t * it does not validate, but the integrator may not have the\n\t * public key of the signer of the tag he is merging, while a\n\t * later auditor may have it while auditing, so let's not run\n\t * verify-signed-buffer here for now...\n\t *\n\t * if (verify_signed_buffer(buf, len, buf + len, size - len, ...))\n\t *\twarn(\"warning: signed tag unverified.\");\n\t */\n\tmergetag = xcalloc(1, sizeof(*mergetag));\n\tmergetag->key = xstrdup(\"mergetag\");\n\tmergetag->value = buf;\n\tmergetag->len = size;\n\n\t**tail = mergetag;\n\t*tail = &mergetag->next;\n\treturn;\n\nfree_return:\n\tfree(buf);\n}\n\nint check_commit_signature(const struct commit *commit, struct signature_check *sigc)\n{\n\tstruct strbuf payload = STRBUF_INIT;\n\tstruct strbuf signature = STRBUF_INIT;\n\tint ret = 1;\n\n\tsigc->result = 'N';\n\n\tif (parse_signed_commit(commit, &payload, &signature) <= 0)\n\t\tgoto out;\n\tret = check_signature(payload.buf, payload.len, signature.buf,\n\t\tsignature.len, sigc);\n\n out:\n\tstrbuf_release(&payload);\n\tstrbuf_release(&signature);\n\n\treturn ret;\n}\n\n\n\nvoid append_merge_tag_headers(struct commit_list *parents,\n\t\t\t      struct commit_extra_header ***tail)\n{\n\twhile (parents) {\n\t\tstruct commit *parent = parents->item;\n\t\thandle_signed_tag(parent, tail);\n\t\tparents = parents->next;\n\t}\n}\n\nstatic void add_extra_header(struct strbuf *buffer,\n\t\t\t     struct commit_extra_header *extra)\n{\n\tstrbuf_addstr(buffer, extra->key);\n\tif (extra->len)\n\t\tstrbuf_add_lines(buffer, \" \", extra->value, extra->len);\n\telse\n\t\tstrbuf_addch(buffer, '\\n');\n}\n\nstruct commit_extra_header *read_commit_extra_headers(struct commit *commit,\n\t\t\t\t\t\t      const char **exclude)\n{\n\tstruct commit_extra_header *extra = NULL;\n\tunsigned long size;\n\tconst char *buffer = get_commit_buffer(commit, &size);\n\textra = read_commit_extra_header_lines(buffer, size, exclude);\n\tunuse_commit_buffer(commit, buffer);\n\treturn extra;\n}\n\nint for_each_mergetag(each_mergetag_fn fn, struct commit *commit, void *data)\n{\n\tstruct commit_extra_header *extra, *to_free;\n\tint res = 0;\n\n\tto_free = read_commit_extra_headers(commit, NULL);\n\tfor (extra = to_free; !res && extra; extra = extra->next) {\n\t\tif (strcmp(extra->key, \"mergetag\"))\n\t\t\tcontinue; /* not a merge tag */\n\t\tres = fn(commit, extra, data);\n\t}\n\tfree_commit_extra_headers(to_free);\n\treturn res;\n}\n\nstatic inline int standard_header_field(const char *field, size_t len)\n{\n\treturn ((len == 4 && !memcmp(field, \"tree\", 4)) ||\n\t\t(len == 6 && !memcmp(field, \"parent\", 6)) ||\n\t\t(len == 6 && !memcmp(field, \"author\", 6)) ||\n\t\t(len == 9 && !memcmp(field, \"committer\", 9)) ||\n\t\t(len == 8 && !memcmp(field, \"encoding\", 8)));\n}\n\nstatic int excluded_header_field(const char *field, size_t len, const char **exclude)\n{\n\tif (!exclude)\n\t\treturn 0;\n\n\twhile (*exclude) {\n\t\tsize_t xlen = strlen(*exclude);\n\t\tif (len == xlen && !memcmp(field, *exclude, xlen))\n\t\t\treturn 1;\n\t\texclude++;\n\t}\n\treturn 0;\n}\n\nstatic struct commit_extra_header *read_commit_extra_header_lines(\n\tconst char *buffer, size_t size,\n\tconst char **exclude)\n{\n\tstruct commit_extra_header *extra = NULL, **tail = &extra, *it = NULL;\n\tconst char *line, *next, *eof, *eob;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tfor (line = buffer, eob = line + size;\n\t     line < eob && *line != '\\n';\n\t     line = next) {\n\t\tnext = memchr(line, '\\n', eob - line);\n\t\tnext = next ? next + 1 : eob;\n\t\tif (*line == ' ') {\n\t\t\t/* continuation */\n\t\t\tif (it)\n\t\t\t\tstrbuf_add(&buf, line + 1, next - (line + 1));\n\t\t\tcontinue;\n\t\t}\n\t\tif (it)\n\t\t\tit->value = strbuf_detach(&buf, &it->len);\n\t\tstrbuf_reset(&buf);\n\t\tit = NULL;\n\n\t\teof = memchr(line, ' ', next - line);\n\t\tif (!eof)\n\t\t\teof = next;\n\t\telse if (standard_header_field(line, eof - line) ||\n\t\t\t excluded_header_field(line, eof - line, exclude))\n\t\t\tcontinue;\n\n\t\tit = xcalloc(1, sizeof(*it));\n\t\tit->key = xmemdupz(line, eof-line);\n\t\t*tail = it;\n\t\ttail = &it->next;\n\t\tif (eof + 1 < next)\n\t\t\tstrbuf_add(&buf, eof + 1, next - (eof + 1));\n\t}\n\tif (it)\n\t\tit->value = strbuf_detach(&buf, &it->len);\n\treturn extra;\n}\n\nvoid free_commit_extra_headers(struct commit_extra_header *extra)\n{\n\twhile (extra) {\n\t\tstruct commit_extra_header *next = extra->next;\n\t\tfree(extra->key);\n\t\tfree(extra->value);\n\t\tfree(extra);\n\t\textra = next;\n\t}\n}\n\nint commit_tree(const char *msg, size_t msg_len, const struct object_id *tree,\n\t\tstruct commit_list *parents, struct object_id *ret,\n\t\tconst char *author, const char *sign_commit)\n{\n\tstruct commit_extra_header *extra = NULL, **tail = &extra;\n\tint result;\n\n\tappend_merge_tag_headers(parents, &tail);\n\tresult = commit_tree_extended(msg, msg_len, tree, parents, ret,\n\t\t\t\t      author, sign_commit, extra);\n\tfree_commit_extra_headers(extra);\n\treturn result;\n}\n\nstatic int find_invalid_utf8(const char *buf, int len)\n{\n\tint offset = 0;\n\tstatic const unsigned int max_codepoint[] = {\n\t\t0x7f, 0x7ff, 0xffff, 0x10ffff\n\t};\n\n\twhile (len) {\n\t\tunsigned char c = *buf++;\n\t\tint bytes, bad_offset;\n\t\tunsigned int codepoint;\n\t\tunsigned int min_val, max_val;\n\n\t\tlen--;\n\t\toffset++;\n\n\t\t/* Simple US-ASCII? No worries. */\n\t\tif (c < 0x80)\n\t\t\tcontinue;\n\n\t\tbad_offset = offset-1;\n\n\t\t/*\n\t\t * Count how many more high bits set: that's how\n\t\t * many more bytes this sequence should have.\n\t\t */\n\t\tbytes = 0;\n\t\twhile (c & 0x40) {\n\t\t\tc <<= 1;\n\t\t\tbytes++;\n\t\t}\n\n\t\t/*\n\t\t * Must be between 1 and 3 more bytes.  Longer sequences result in\n\t\t * codepoints beyond U+10FFFF, which are guaranteed never to exist.\n\t\t */\n\t\tif (bytes < 1 || 3 < bytes)\n\t\t\treturn bad_offset;\n\n\t\t/* Do we *have* that many bytes? */\n\t\tif (len < bytes)\n\t\t\treturn bad_offset;\n\n\t\t/*\n\t\t * Place the encoded bits at the bottom of the value and compute the\n\t\t * valid range.\n\t\t */\n\t\tcodepoint = (c & 0x7f) >> bytes;\n\t\tmin_val = max_codepoint[bytes-1] + 1;\n\t\tmax_val = max_codepoint[bytes];\n\n\t\toffset += bytes;\n\t\tlen -= bytes;\n\n\t\t/* And verify that they are good continuation bytes */\n\t\tdo {\n\t\t\tcodepoint <<= 6;\n\t\t\tcodepoint |= *buf & 0x3f;\n\t\t\tif ((*buf++ & 0xc0) != 0x80)\n\t\t\t\treturn bad_offset;\n\t\t} while (--bytes);\n\n\t\t/* Reject codepoints that are out of range for the sequence length. */\n\t\tif (codepoint < min_val || codepoint > max_val)\n\t\t\treturn bad_offset;\n\t\t/* Surrogates are only for UTF-16 and cannot be encoded in UTF-8. */\n\t\tif ((codepoint & 0x1ff800) == 0xd800)\n\t\t\treturn bad_offset;\n\t\t/* U+xxFFFE and U+xxFFFF are guaranteed non-characters. */\n\t\tif ((codepoint & 0xfffe) == 0xfffe)\n\t\t\treturn bad_offset;\n\t\t/* So are anything in the range U+FDD0..U+FDEF. */\n\t\tif (codepoint >= 0xfdd0 && codepoint <= 0xfdef)\n\t\t\treturn bad_offset;\n\t}\n\treturn -1;\n}\n\n/*\n * This verifies that the buffer is in proper utf8 format.\n *\n * If it isn't, it assumes any non-utf8 characters are Latin1,\n * and does the conversion.\n */\nstatic int verify_utf8(struct strbuf *buf)\n{\n\tint ok = 1;\n\tlong pos = 0;\n\n\tfor (;;) {\n\t\tint bad;\n\t\tunsigned char c;\n\t\tunsigned char replace[2];\n\n\t\tbad = find_invalid_utf8(buf->buf + pos, buf->len - pos);\n\t\tif (bad < 0)\n\t\t\treturn ok;\n\t\tpos += bad;\n\t\tok = 0;\n\t\tc = buf->buf[pos];\n\t\tstrbuf_remove(buf, pos, 1);\n\n\t\t/* We know 'c' must be in the range 128-255 */\n\t\treplace[0] = 0xc0 + (c >> 6);\n\t\treplace[1] = 0x80 + (c & 0x3f);\n\t\tstrbuf_insert(buf, pos, replace, 2);\n\t\tpos += 2;\n\t}\n}\n\nstatic const char commit_utf8_warn[] =\nN_(\"Warning: commit message did not conform to UTF-8.\\n\"\n   \"You may want to amend it after fixing the message, or set the config\\n\"\n   \"variable i18n.commitencoding to the encoding your project uses.\\n\");\n\nint commit_tree_extended(const char *msg, size_t msg_len,\n\t\t\t const struct object_id *tree,\n\t\t\t struct commit_list *parents, struct object_id *ret,\n\t\t\t const char *author, const char *sign_commit,\n\t\t\t struct commit_extra_header *extra)\n{\n\tint result;\n\tint encoding_is_utf8;\n\tstruct strbuf buffer;\n\n\tassert_oid_type(tree, OBJ_TREE);\n\n\tif (memchr(msg, '\\0', msg_len))\n\t\treturn error(\"a NUL byte in commit log message not allowed.\");\n\n\t/* Not having i18n.commitencoding is the same as having utf-8 */\n\tencoding_is_utf8 = is_encoding_utf8(git_commit_encoding);\n\n\tstrbuf_init(&buffer, 8192); /* should avoid reallocs for the headers */\n\tstrbuf_addf(&buffer, \"tree %s\\n\", oid_to_hex(tree));\n\n\t/*\n\t * NOTE! This ordering means that the same exact tree merged with a\n\t * different order of parents will be a _different_ changeset even\n\t * if everything else stays the same.\n\t */\n\twhile (parents) {\n\t\tstruct commit *parent = pop_commit(&parents);\n\t\tstrbuf_addf(&buffer, \"parent %s\\n\",\n\t\t\t    oid_to_hex(&parent->object.oid));\n\t}\n\n\t/* Person/date information */\n\tif (!author)\n\t\tauthor = git_author_info(IDENT_STRICT);\n\tstrbuf_addf(&buffer, \"author %s\\n\", author);\n\tstrbuf_addf(&buffer, \"committer %s\\n\", git_committer_info(IDENT_STRICT));\n\tif (!encoding_is_utf8)\n\t\tstrbuf_addf(&buffer, \"encoding %s\\n\", git_commit_encoding);\n\n\twhile (extra) {\n\t\tadd_extra_header(&buffer, extra);\n\t\textra = extra->next;\n\t}\n\tstrbuf_addch(&buffer, '\\n');\n\n\t/* And add the comment */\n\tstrbuf_add(&buffer, msg, msg_len);\n\n\t/* And check the encoding */\n\tif (encoding_is_utf8 && !verify_utf8(&buffer))\n\t\tfprintf(stderr, _(commit_utf8_warn));\n\n\tif (sign_commit && do_sign_commit(&buffer, sign_commit)) {\n\t\tresult = -1;\n\t\tgoto out;\n\t}\n\n\tresult = write_object_file(buffer.buf, buffer.len, commit_type, ret);\nout:\n\tstrbuf_release(&buffer);\n\treturn result;\n}\n\nvoid set_merge_remote_desc(struct commit *commit,\n\t\t\t   const char *name, struct object *obj)\n{\n\tstruct merge_remote_desc *desc;\n\tFLEX_ALLOC_STR(desc, name, name);\n\tdesc->obj = obj;\n\tcommit->util = desc;\n}\n\nstruct commit *get_merge_parent(const char *name)\n{\n\tstruct object *obj;\n\tstruct commit *commit;\n\tstruct object_id oid;\n\tif (get_oid(name, &oid))\n\t\treturn NULL;\n\tobj = parse_object(&oid);\n\tcommit = (struct commit *)peel_to_type(name, 0, obj, OBJ_COMMIT);\n\tif (commit && !commit->util)\n\t\tset_merge_remote_desc(commit, name, obj);\n\treturn commit;\n}\n\n/*\n * Append a commit to the end of the commit_list.\n *\n * next starts by pointing to the variable that holds the head of an\n * empty commit_list, and is updated to point to the \"next\" field of\n * the last item on the list as new commits are appended.\n *\n * Usage example:\n *\n *     struct commit_list *list;\n *     struct commit_list **next = &list;\n *\n *     next = commit_list_append(c1, next);\n *     next = commit_list_append(c2, next);\n *     assert(commit_list_count(list) == 2);\n *     return list;\n */\nstruct commit_list **commit_list_append(struct commit *commit,\n\t\t\t\t\tstruct commit_list **next)\n{\n\tstruct commit_list *new_commit = xmalloc(sizeof(struct commit_list));\n\tnew_commit->item = commit;\n\t*next = new_commit;\n\tnew_commit->next = NULL;\n\treturn &new_commit->next;\n}\n\nconst char *find_commit_header(const char *msg, const char *key, size_t *out_len)\n{\n\tint key_len = strlen(key);\n\tconst char *line = msg;\n\n\twhile (line) {\n\t\tconst char *eol = strchrnul(line, '\\n');\n\n\t\tif (line == eol)\n\t\t\treturn NULL;\n\n\t\tif (eol - line > key_len &&\n\t\t    !strncmp(line, key, key_len) &&\n\t\t    line[key_len] == ' ') {\n\t\t\t*out_len = eol - line - key_len - 1;\n\t\t\treturn line + key_len + 1;\n\t\t}\n\t\tline = *eol ? eol + 1 : NULL;\n\t}\n\treturn NULL;\n}\n\n/*\n * Inspect the given string and determine the true \"end\" of the log message, in\n * order to find where to put a new Signed-off-by: line.  Ignored are\n * trailing comment lines and blank lines.  To support \"git commit -s\n * --amend\" on an existing commit, we also ignore \"Conflicts:\".  To\n * support \"git commit -v\", we truncate at cut lines.\n *\n * Returns the number of bytes from the tail to ignore, to be fed as\n * the second parameter to append_signoff().\n */\nint ignore_non_trailer(const char *buf, size_t len)\n{\n\tint boc = 0;\n\tint bol = 0;\n\tint in_old_conflicts_block = 0;\n\tsize_t cutoff = wt_status_locate_end(buf, len);\n\n\twhile (bol < cutoff) {\n\t\tconst char *next_line = memchr(buf + bol, '\\n', len - bol);\n\n\t\tif (!next_line)\n\t\t\tnext_line = buf + len;\n\t\telse\n\t\t\tnext_line++;\n\n\t\tif (buf[bol] == comment_line_char || buf[bol] == '\\n') {\n\t\t\t/* is this the first of the run of comments? */\n\t\t\tif (!boc)\n\t\t\t\tboc = bol;\n\t\t\t/* otherwise, it is just continuing */\n\t\t} else if (starts_with(buf + bol, \"Conflicts:\\n\")) {\n\t\t\tin_old_conflicts_block = 1;\n\t\t\tif (!boc)\n\t\t\t\tboc = bol;\n\t\t} else if (in_old_conflicts_block && buf[bol] == '\\t') {\n\t\t\t; /* a pathname in the conflicts block */\n\t\t} else if (boc) {\n\t\t\t/* the previous was not trailing comment */\n\t\t\tboc = 0;\n\t\t\tin_old_conflicts_block = 0;\n\t\t}\n\t\tbol = next_line - buf;\n\t}\n\treturn boc ? len - boc : len - cutoff;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0030e79940ff8564b5c8c5ebab462eb1bd745174",
  "sha1_ok": true,
  "size": 42646
}
