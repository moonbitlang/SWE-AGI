{
  "content": {
    "base64": "I2lmbmRlZiBHSVRfQ09NUEFUX1VUSUxfSAojZGVmaW5lIEdJVF9DT01QQVRfVVRJTF9ICgojZGVmaW5lIF9GSUxFX09GRlNFVF9CSVRTIDY0CgoKLyogRGVyaXZlZCBmcm9tIExpbnV4ICJGZWF0dXJlcyBUZXN0IE1hY3JvIiBoZWFkZXIKICogQ29udmVuaWVuY2UgbWFjcm9zIHRvIHRlc3QgdGhlIHZlcnNpb25zIG9mIGdjYyAob3IKICogYSBjb21wYXRpYmxlIGNvbXBpbGVyKS4KICogVXNlIHRoZW0gbGlrZSB0aGlzOgogKiAgI2lmIEdJVF9HTlVDX1BSRVJFUSAoMiw4KQogKiAgIC4uLiBjb2RlIHJlcXVpcmluZyBnY2MgMi44IG9yIGxhdGVyIC4uLgogKiAgI2VuZGlmCiovCiNpZiBkZWZpbmVkKF9fR05VQ19fKSAmJiBkZWZpbmVkKF9fR05VQ19NSU5PUl9fKQojIGRlZmluZSBHSVRfR05VQ19QUkVSRVEobWFqLCBtaW4pIFwKCSgoX19HTlVDX18gPDwgMTYpICsgX19HTlVDX01JTk9SX18gPj0gKChtYWopIDw8IDE2KSArIChtaW4pKQojZWxzZQogI2RlZmluZSBHSVRfR05VQ19QUkVSRVEobWFqLCBtaW4pIDAKI2VuZGlmCgoKI2lmbmRlZiBGTEVYX0FSUkFZCi8qCiAqIFNlZSBpZiBvdXIgY29tcGlsZXIgaXMga25vd24gdG8gc3VwcG9ydCBmbGV4aWJsZSBhcnJheSBtZW1iZXJzLgogKi8KI2lmIGRlZmluZWQoX19TVERDX1ZFUlNJT05fXykgJiYgKF9fU1REQ19WRVJTSU9OX18gPj0gMTk5OTAxTCkgJiYgKCFkZWZpbmVkKF9fU1VOUFJPX0MpIHx8IChfX1NVTlBST19DID4gMHg1ODApKQojIGRlZmluZSBGTEVYX0FSUkFZIC8qIGVtcHR5ICovCiNlbGlmIGRlZmluZWQoX19HTlVDX18pCiMgaWYgKF9fR05VQ19fID49IDMpCiMgIGRlZmluZSBGTEVYX0FSUkFZIC8qIGVtcHR5ICovCiMgZWxzZQojICBkZWZpbmUgRkxFWF9BUlJBWSAwIC8qIG9sZGVyIEdOVSBleHRlbnNpb24gKi8KIyBlbmRpZgojZW5kaWYKCi8qCiAqIE90aGVyd2lzZSwgZGVmYXVsdCB0byBzYWZlciBidXQgYSBiaXQgd2FzdGVmdWwgdHJhZGl0aW9uYWwgc3R5bGUKICovCiNpZm5kZWYgRkxFWF9BUlJBWQojIGRlZmluZSBGTEVYX0FSUkFZIDEKI2VuZGlmCiNlbmRpZgoKCi8qCiAqIEJVSUxEX0FTU0VSVF9PUl9aRVJPIC0gYXNzZXJ0IGEgYnVpbGQtdGltZSBkZXBlbmRlbmN5LCBhcyBhbiBleHByZXNzaW9uLgogKiBAY29uZDogdGhlIGNvbXBpbGUtdGltZSBjb25kaXRpb24gd2hpY2ggbXVzdCBiZSB0cnVlLgogKgogKiBZb3VyIGNvbXBpbGUgd2lsbCBmYWlsIGlmIHRoZSBjb25kaXRpb24gaXNuJ3QgdHJ1ZSwgb3IgY2FuJ3QgYmUgZXZhbHVhdGVkCiAqIGJ5IHRoZSBjb21waWxlci4gIFRoaXMgY2FuIGJlIHVzZWQgaW4gYW4gZXhwcmVzc2lvbjogaXRzIHZhbHVlIGlzICIwIi4KICoKICogRXhhbXBsZToKICoJI2RlZmluZSBmb29fdG9fY2hhcihmb28pCQkJCQlcCiAqCQkgKChjaGFyICopKGZvbykJCQkJCQlcCiAqCQkgICsgQlVJTERfQVNTRVJUX09SX1pFUk8ob2Zmc2V0b2Yoc3RydWN0IGZvbywgc3RyaW5nKSA9PSAwKSkKICovCiNkZWZpbmUgQlVJTERfQVNTRVJUX09SX1pFUk8oY29uZCkgXAoJKHNpemVvZihjaGFyIFsxIC0gMiohKGNvbmQpXSkgLSAxKQoKI2lmIEdJVF9HTlVDX1BSRVJFUSgzLCAxKQogLyogJmFyclswXSBkZWdyYWRlcyB0byBhIHBvaW50ZXI6IGEgZGlmZmVyZW50IHR5cGUgZnJvbSBhbiBhcnJheSAqLwojIGRlZmluZSBCQVJGX1VOTEVTU19BTl9BUlJBWShhcnIpCQkJCQkJXAoJQlVJTERfQVNTRVJUX09SX1pFUk8oIV9fYnVpbHRpbl90eXBlc19jb21wYXRpYmxlX3AoX190eXBlb2ZfXyhhcnIpLCBcCgkJCQkJCQkgICBfX3R5cGVvZl9fKCYoYXJyKVswXSkpKQojZWxzZQojIGRlZmluZSBCQVJGX1VOTEVTU19BTl9BUlJBWShhcnIpIDAKI2VuZGlmCi8qCiAqIEFSUkFZX1NJWkUgLSBnZXQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhIHZpc2libGUgYXJyYXkKICogIDxhdD4geDogdGhlIGFycmF5IHdob3NlIHNpemUgeW91IHdhbnQuCiAqCiAqIFRoaXMgZG9lcyBub3Qgd29yayBvbiBwb2ludGVycywgb3IgYXJyYXlzIGRlY2xhcmVkIGFzIFtdLCBvcgogKiBmdW5jdGlvbiBwYXJhbWV0ZXJzLiAgV2l0aCBjb3JyZWN0IGNvbXBpbGVyIHN1cHBvcnQsIHN1Y2ggdXNhZ2UKICogd2lsbCBjYXVzZSBhIGJ1aWxkIGVycm9yIChzZWUgdGhlIGJ1aWxkX2Fzc2VydF9vcl96ZXJvIG1hY3JvKS4KICovCiNkZWZpbmUgQVJSQVlfU0laRSh4KSAoc2l6ZW9mKHgpIC8gc2l6ZW9mKCh4KVswXSkgKyBCQVJGX1VOTEVTU19BTl9BUlJBWSh4KSkKCiNkZWZpbmUgYml0c2l6ZW9mKHgpICAoQ0hBUl9CSVQgKiBzaXplb2YoeCkpCgojZGVmaW5lIG1heGltdW1fc2lnbmVkX3ZhbHVlX29mX3R5cGUoYSkgXAogICAgKElOVE1BWF9NQVggPj4gKGJpdHNpemVvZihpbnRtYXhfdCkgLSBiaXRzaXplb2YoYSkpKQoKI2RlZmluZSBtYXhpbXVtX3Vuc2lnbmVkX3ZhbHVlX29mX3R5cGUoYSkgXAogICAgKFVJTlRNQVhfTUFYID4+IChiaXRzaXplb2YodWludG1heF90KSAtIGJpdHNpemVvZihhKSkpCgovKgogKiBTaWduZWQgaW50ZWdlciBvdmVyZmxvdyBpcyB1bmRlZmluZWQgaW4gQywgc28gaGVyZSdzIGEgaGVscGVyIG1hY3JvCiAqIHRvIGRldGVjdCBpZiB0aGUgc3VtIG9mIHR3byBpbnRlZ2VycyB3aWxsIG92ZXJmbG93LgogKgogKiBSZXF1aXJlczogYSA+PSAwLCB0eXBlb2YoYSkgZXF1YWxzIHR5cGVvZihiKQogKi8KI2RlZmluZSBzaWduZWRfYWRkX292ZXJmbG93cyhhLCBiKSBcCiAgICAoKGIpID4gbWF4aW11bV9zaWduZWRfdmFsdWVfb2ZfdHlwZShhKSAtIChhKSkKCiNkZWZpbmUgdW5zaWduZWRfYWRkX292ZXJmbG93cyhhLCBiKSBcCiAgICAoKGIpID4gbWF4aW11bV91bnNpZ25lZF92YWx1ZV9vZl90eXBlKGEpIC0gKGEpKQoKLyoKICogUmV0dXJucyB0cnVlIGlmIHRoZSBtdWx0aXBsaWNhdGlvbiBvZiAiYSIgYW5kICJiIiB3aWxsCiAqIG92ZXJmbG93LiBUaGUgdHlwZXMgb2YgImEiIGFuZCAiYiIgbXVzdCBtYXRjaCBhbmQgbXVzdCBiZSB1bnNpZ25lZC4KICogTm90ZSB0aGF0IHRoaXMgbWFjcm8gZXZhbHVhdGVzICJhIiB0d2ljZSEKICovCiNkZWZpbmUgdW5zaWduZWRfbXVsdF9vdmVyZmxvd3MoYSwgYikgXAogICAgKChhKSAmJiAoYikgPiBtYXhpbXVtX3Vuc2lnbmVkX3ZhbHVlX29mX3R5cGUoYSkgLyAoYSkpCgojaWZkZWYgX19HTlVDX18KI2RlZmluZSBUWVBFT0YoeCkgKF9fdHlwZW9mX18oeCkpCiNlbHNlCiNkZWZpbmUgVFlQRU9GKHgpCiNlbmRpZgoKI2RlZmluZSBNU0IoeCwgYml0cykgKCh4KSAmIFRZUEVPRih4KSh+MFVMTCA8PCAoYml0c2l6ZW9mKHgpIC0gKGJpdHMpKSkpCiNkZWZpbmUgSEFTX01VTFRJX0JJVFMoaSkgICgoaSkgJiAoKGkpIC0gMSkpICAvKiBjaGVja3MgaWYgYW4gaW50ZWdlciBoYXMgbW9yZSB0aGFuIDEgYml0IHNldCAqLwoKI2RlZmluZSBESVZfUk9VTkRfVVAobixkKSAoKChuKSArIChkKSAtIDEpIC8gKGQpKQoKLyogQXBwcm94aW1hdGlvbiBvZiB0aGUgbGVuZ3RoIG9mIHRoZSBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS4gKi8KI2RlZmluZSBkZWNpbWFsX2xlbmd0aCh4KQkoKGludCkoc2l6ZW9mKHgpICogMi41NiArIDAuNSkgKyAxKQoKI2lmIGRlZmluZWQoX19zdW5fXykKIC8qCiAgKiBPbiBTb2xhcmlzLCB3aGVuIF9YT1BFTl9FWFRFTkRFRCBpcyBzZXQsIGl0cyBoZWFkZXIgZmlsZQogICogZm9yY2VzIHRoZSBwcm9ncmFtcyB0byBiZSBYUEc0djIsIGRlZmVhdGluZyBhbnkgX1hPUEVOX1NPVVJDRQogICogc2V0dGluZyB0byBzYXkgd2UgYXJlIFhQRzUgb3IgWFBHNi4gIEFsc28gb24gU29sYXJpcywKICAqIFhQRzYgcHJvZ3JhbXMgbXVzdCBiZSBjb21waWxlZCB3aXRoIGEgYzk5IGNvbXBpbGVyLCB3aGlsZQogICogbm9uIFhQRzYgcHJvZ3JhbXMgbXVzdCBiZSBjb21waWxlZCB3aXRoIGEgcHJlLWM5OSBjb21waWxlci4KICAqLwojIGlmIF9fU1REQ19WRVJTSU9OX18gLSAwID49IDE5OTkwMUwKIyBkZWZpbmUgX1hPUEVOX1NPVVJDRSA2MDAKIyBlbHNlCiMgZGVmaW5lIF9YT1BFTl9TT1VSQ0UgNTAwCiMgZW5kaWYKI2VsaWYgIWRlZmluZWQoX19BUFBMRV9fKSAmJiAhZGVmaW5lZChfX0ZyZWVCU0RfXykgJiYgIWRlZmluZWQoX19VU0xDX18pICYmIFwKICAgICAgIWRlZmluZWQoX01fVU5JWCkgJiYgIWRlZmluZWQoX19zZ2kpICYmICFkZWZpbmVkKF9fRHJhZ29uRmx5X18pICYmIFwKICAgICAgIWRlZmluZWQoX19UQU5ERU0pICYmICFkZWZpbmVkKF9fUU5YX18pICYmICFkZWZpbmVkKF9fTWlyQlNEX18pICYmIFwKICAgICAgIWRlZmluZWQoX19DWUdXSU5fXykKI2RlZmluZSBfWE9QRU5fU09VUkNFIDYwMCAvKiBnbGliYzIgYW5kIEFJWCA1LjNMIG5lZWQgNTAwLCBPcGVuQlNEIG5lZWRzIDYwMCBmb3IgU19JU0xOSygpICovCiNkZWZpbmUgX1hPUEVOX1NPVVJDRV9FWFRFTkRFRCAxIC8qIEFJWCA1LjNMIG5lZWRzIHRoaXMgKi8KI2VuZGlmCiNkZWZpbmUgX0FMTF9TT1VSQ0UgMQojZGVmaW5lIF9HTlVfU09VUkNFIDEKI2RlZmluZSBfQlNEX1NPVVJDRSAxCiNkZWZpbmUgX0RFRkFVTFRfU09VUkNFIDEKI2RlZmluZSBfTkVUQlNEX1NPVVJDRSAxCiNkZWZpbmUgX1NHSV9TT1VSQ0UgMQoKI2lmIGRlZmluZWQoV0lOMzIpICYmICFkZWZpbmVkKF9fQ1lHV0lOX18pIC8qIEJvdGggTWluR1cgYW5kIE1TVkMgKi8KIyBpZiBkZWZpbmVkIChfTVNDX1ZFUikgJiYgIWRlZmluZWQoX1dJTjMyX1dJTk5UKQojICBkZWZpbmUgX1dJTjMyX1dJTk5UIDB4MDUwMgojIGVuZGlmCiNkZWZpbmUgV0lOMzJfTEVBTl9BTkRfTUVBTiAgLyogc3RvcHMgd2luZG93cy5oIGluY2x1ZGluZyB3aW5zb2NrLmggKi8KI2luY2x1ZGUgPHdpbnNvY2syLmg+CiNpbmNsdWRlIDx3aW5kb3dzLmg+CiNkZWZpbmUgR0lUX1dJTkRPV1NfTkFUSVZFCiNlbmRpZgoKI2luY2x1ZGUgPHVuaXN0ZC5oPgojaW5jbHVkZSA8c3RkaW8uaD4KI2luY2x1ZGUgPHN5cy9zdGF0Lmg+CiNpbmNsdWRlIDxmY250bC5oPgojaW5jbHVkZSA8c3RkZGVmLmg+CiNpbmNsdWRlIDxzdGRsaWIuaD4KI2luY2x1ZGUgPHN0ZGFyZy5oPgojaW5jbHVkZSA8c3RyaW5nLmg+CiNpZmRlZiBIQVZFX1NUUklOR1NfSAojaW5jbHVkZSA8c3RyaW5ncy5oPiAvKiBmb3Igc3RyY2FzZWNtcCgpICovCiNlbmRpZgojaW5jbHVkZSA8ZXJybm8uaD4KI2luY2x1ZGUgPGxpbWl0cy5oPgojaWZkZWYgTkVFRFNfU1lTX1BBUkFNX0gKI2luY2x1ZGUgPHN5cy9wYXJhbS5oPgojZW5kaWYKI2luY2x1ZGUgPHN5cy90eXBlcy5oPgojaW5jbHVkZSA8ZGlyZW50Lmg+CiNpbmNsdWRlIDxzeXMvdGltZS5oPgojaW5jbHVkZSA8dGltZS5oPgojaW5jbHVkZSA8c2lnbmFsLmg+CiNpbmNsdWRlIDxhc3NlcnQuaD4KI2luY2x1ZGUgPHJlZ2V4Lmg+CiNpbmNsdWRlIDx1dGltZS5oPgojaW5jbHVkZSA8c3lzbG9nLmg+CiNpZm5kZWYgTk9fU1lTX1BPTExfSAojaW5jbHVkZSA8c3lzL3BvbGwuaD4KI2Vsc2UKI2luY2x1ZGUgPHBvbGwuaD4KI2VuZGlmCiNpZmRlZiBIQVZFX0JTRF9TWVNDVEwKI2luY2x1ZGUgPHN5cy9zeXNjdGwuaD4KI2VuZGlmCgojaWYgZGVmaW5lZChfX0NZR1dJTl9fKQojaW5jbHVkZSAiY29tcGF0L2N5Z3dpbi5oIgojZW5kaWYKI2lmIGRlZmluZWQoX19NSU5HVzMyX18pCi8qIHB1bGwgaW4gV2luZG93cyBjb21wYXRpYmlsaXR5IHN0dWZmICovCiNpbmNsdWRlICJjb21wYXQvbWluZ3cuaCIKI2VsaWYgZGVmaW5lZChfTVNDX1ZFUikKI2luY2x1ZGUgImNvbXBhdC9tc3ZjLmgiCiNlbHNlCiNpbmNsdWRlIDxzeXMvdXRzbmFtZS5oPgojaW5jbHVkZSA8c3lzL3dhaXQuaD4KI2luY2x1ZGUgPHN5cy9yZXNvdXJjZS5oPgojaW5jbHVkZSA8c3lzL3NvY2tldC5oPgojaW5jbHVkZSA8c3lzL2lvY3RsLmg+CiNpbmNsdWRlIDx0ZXJtaW9zLmg+CiNpZm5kZWYgTk9fU1lTX1NFTEVDVF9ICiNpbmNsdWRlIDxzeXMvc2VsZWN0Lmg+CiNlbmRpZgojaW5jbHVkZSA8bmV0aW5ldC9pbi5oPgojaW5jbHVkZSA8bmV0aW5ldC90Y3AuaD4KI2luY2x1ZGUgPGFycGEvaW5ldC5oPgojaW5jbHVkZSA8bmV0ZGIuaD4KI2luY2x1ZGUgPHB3ZC5oPgojaW5jbHVkZSA8c3lzL3VuLmg+CiNpZm5kZWYgTk9fSU5UVFlQRVNfSAojaW5jbHVkZSA8aW50dHlwZXMuaD4KI2Vsc2UKI2luY2x1ZGUgPHN0ZGludC5oPgojZW5kaWYKI2lmZGVmIE5PX0lOVFBUUl9UCi8qCiAqIE9uIEkxNkxQMzIsIElMUDMyIGFuZCBMUDY0ICJsb25nIiBpcyB0aGUgc2F2ZSBiZXQsIGhvd2V2ZXIKICogb24gTExQODYsIElMMzNMTFA2NCBhbmQgUDY0IGl0IG5lZWRzIHRvIGJlICJsb25nIGxvbmciLAogKiB3aGlsZSBvbiBJUDE2IGFuZCBJUDE2TDMyIGl0IGlzICJpbnQiIChyZXNwLiAic2hvcnQiKQogKiBTaXplIG5lZWRzIHRvIG1hdGNoIChvciBleGNlZWQpICdzaXplb2Yodm9pZCAqKScuCiAqIFdlIGNhbid0IHRha2UgImxvbmcgbG9uZyIgaGVyZSBhcyBub3QgZXZlcnlib2R5IGhhcyBpdC4KICovCnR5cGVkZWYgbG9uZyBpbnRwdHJfdDsKdHlwZWRlZiB1bnNpZ25lZCBsb25nIHVpbnRwdHJfdDsKI2VuZGlmCiN1bmRlZiBfQUxMX1NPVVJDRSAvKiBBSVggNS4zTCBkZWZpbmVzIGEgc3RydWN0IGxpc3Qgd2l0aCBfQUxMX1NPVVJDRS4gKi8KI2luY2x1ZGUgPGdycC5oPgojZGVmaW5lIF9BTExfU09VUkNFIDEKI2VuZGlmCgovKiB1c2VkIG9uIE1hYyBPUyBYICovCiNpZmRlZiBQUkVDT01QT1NFX1VOSUNPREUKI2luY2x1ZGUgImNvbXBhdC9wcmVjb21wb3NlX3V0ZjguaCIKI2Vsc2UKI2RlZmluZSBwcmVjb21wb3NlX3N0cihpbixpX25mZDJuZmMpCiNkZWZpbmUgcHJlY29tcG9zZV9hcmd2KGMsdikKI2RlZmluZSBwcm9iZV91dGY4X3BhdGhuYW1lX2NvbXBvc2l0aW9uKCkKI2VuZGlmCgojaWZkZWYgTUtESVJfV09fVFJBSUxJTkdfU0xBU0gKI2RlZmluZSBta2RpcihhLGIpIGNvbXBhdF9ta2Rpcl93b190cmFpbGluZ19zbGFzaCgoYSksKGIpKQpleHRlcm4gaW50IGNvbXBhdF9ta2Rpcl93b190cmFpbGluZ19zbGFzaChjb25zdCBjaGFyKiwgbW9kZV90KTsKI2VuZGlmCgojaWZkZWYgTk9fU1RSVUNUX0lUSU1FUlZBTApzdHJ1Y3QgaXRpbWVydmFsIHsKCXN0cnVjdCB0aW1ldmFsIGl0X2ludGVydmFsOwoJc3RydWN0IHRpbWV2YWwgaXRfdmFsdWU7Cn07CiNlbmRpZgoKI2lmZGVmIE5PX1NFVElUSU1FUgojZGVmaW5lIHNldGl0aW1lcih3aGljaCx2YWx1ZSxvdmFsdWUpCiNlbmRpZgoKI2lmbmRlZiBOT19MSUJHRU5fSAojaW5jbHVkZSA8bGliZ2VuLmg+CiNlbHNlCiNkZWZpbmUgYmFzZW5hbWUgZ2l0YmFzZW5hbWUKZXh0ZXJuIGNoYXIgKmdpdGJhc2VuYW1lKGNoYXIgKik7CiNkZWZpbmUgZGlybmFtZSBnaXRkaXJuYW1lCmV4dGVybiBjaGFyICpnaXRkaXJuYW1lKGNoYXIgKik7CiNlbmRpZgoKI2lmbmRlZiBOT19JQ09OVgojaW5jbHVkZSA8aWNvbnYuaD4KI2VuZGlmCgojaWZuZGVmIE5PX09QRU5TU0wKI2lmZGVmIF9fQVBQTEVfXwojZGVmaW5lIF9fQVZBSUxBQklMSVRZX01BQ1JPU19VU0VTX0FWQUlMQUJJTElUWSAwCiNpbmNsdWRlIDxBdmFpbGFiaWxpdHlNYWNyb3MuaD4KI3VuZGVmIERFUFJFQ0FURURfQVRUUklCVVRFCiNkZWZpbmUgREVQUkVDQVRFRF9BVFRSSUJVVEUKI3VuZGVmIF9fQVZBSUxBQklMSVRZX01BQ1JPU19VU0VTX0FWQUlMQUJJTElUWQojZW5kaWYKI2luY2x1ZGUgPG9wZW5zc2wvc3NsLmg+CiNpbmNsdWRlIDxvcGVuc3NsL2Vyci5oPgojZW5kaWYKCi8qIE9uIG1vc3Qgc3lzdGVtcyA8bmV0ZGIuaD4gd291bGQgaGF2ZSBnaXZlbiB1cyB0aGlzLCBidXQKICogbm90IG9uIHNvbWUgc3lzdGVtcyAoZS5nLiB6L09TKS4KICovCiNpZm5kZWYgTklfTUFYSE9TVAojZGVmaW5lIE5JX01BWEhPU1QgMTAyNQojZW5kaWYKCiNpZm5kZWYgTklfTUFYU0VSVgojZGVmaW5lIE5JX01BWFNFUlYgMzIKI2VuZGlmCgovKiBPbiBtb3N0IHN5c3RlbXMgPGxpbWl0cy5oPiB3b3VsZCBoYXZlIGdpdmVuIHVzIHRoaXMsIGJ1dAogKiBub3Qgb24gc29tZSBzeXN0ZW1zIChlLmcuIEdOVS9IdXJkKS4KICovCiNpZm5kZWYgUEFUSF9NQVgKI2RlZmluZSBQQVRIX01BWCA0MDk2CiNlbmRpZgoKI2lmbmRlZiBQUkl1TUFYCiNkZWZpbmUgUFJJdU1BWCAibGx1IgojZW5kaWYKCiNpZm5kZWYgU0NOdU1BWAojZGVmaW5lIFNDTnVNQVggUFJJdU1BWAojZW5kaWYKCiNpZm5kZWYgUFJJdTMyCiNkZWZpbmUgUFJJdTMyICJ1IgojZW5kaWYKCiNpZm5kZWYgUFJJeDMyCiNkZWZpbmUgUFJJeDMyICJ4IgojZW5kaWYKCiNpZm5kZWYgUFJJbzMyCiNkZWZpbmUgUFJJbzMyICJvIgojZW5kaWYKCnR5cGVkZWYgdWludG1heF90IHRpbWVzdGFtcF90OwojZGVmaW5lIFBSSXRpbWUgUFJJdU1BWAojZGVmaW5lIHBhcnNlX3RpbWVzdGFtcCBzdHJ0b3VtYXgKI2RlZmluZSBUSU1FX01BWCBVSU5UTUFYX01BWAoKI2lmbmRlZiBQQVRIX1NFUAojZGVmaW5lIFBBVEhfU0VQICc6JwojZW5kaWYKCiNpZmRlZiBIQVZFX1BBVEhTX0gKI2luY2x1ZGUgPHBhdGhzLmg+CiNlbmRpZgojaWZuZGVmIF9QQVRIX0RFRlBBVEgKI2RlZmluZSBfUEFUSF9ERUZQQVRIICIvdXNyL2xvY2FsL2JpbjovdXNyL2JpbjovYmluIgojZW5kaWYKCiNpZm5kZWYgaGFzX2Rvc19kcml2ZV9wcmVmaXgKc3RhdGljIGlubGluZSBpbnQgZ2l0X2hhc19kb3NfZHJpdmVfcHJlZml4KGNvbnN0IGNoYXIgKnBhdGgpCnsKCXJldHVybiAwOwp9CiNkZWZpbmUgaGFzX2Rvc19kcml2ZV9wcmVmaXggZ2l0X2hhc19kb3NfZHJpdmVfcHJlZml4CiNlbmRpZgoKI2lmbmRlZiBza2lwX2Rvc19kcml2ZV9wcmVmaXgKc3RhdGljIGlubGluZSBpbnQgZ2l0X3NraXBfZG9zX2RyaXZlX3ByZWZpeChjaGFyICoqcGF0aCkKewoJcmV0dXJuIDA7Cn0KI2RlZmluZSBza2lwX2Rvc19kcml2ZV9wcmVmaXggZ2l0X3NraXBfZG9zX2RyaXZlX3ByZWZpeAojZW5kaWYKCiNpZm5kZWYgaXNfZGlyX3NlcApzdGF0aWMgaW5saW5lIGludCBnaXRfaXNfZGlyX3NlcChpbnQgYykKewoJcmV0dXJuIGMgPT0gJy8nOwp9CiNkZWZpbmUgaXNfZGlyX3NlcCBnaXRfaXNfZGlyX3NlcAojZW5kaWYKCiNpZm5kZWYgb2Zmc2V0XzFzdF9jb21wb25lbnQKc3RhdGljIGlubGluZSBpbnQgZ2l0X29mZnNldF8xc3RfY29tcG9uZW50KGNvbnN0IGNoYXIgKnBhdGgpCnsKCXJldHVybiBpc19kaXJfc2VwKHBhdGhbMF0pOwp9CiNkZWZpbmUgb2Zmc2V0XzFzdF9jb21wb25lbnQgZ2l0X29mZnNldF8xc3RfY29tcG9uZW50CiNlbmRpZgoKI2lmbmRlZiBmaW5kX2xhc3RfZGlyX3NlcApzdGF0aWMgaW5saW5lIGNoYXIgKmdpdF9maW5kX2xhc3RfZGlyX3NlcChjb25zdCBjaGFyICpwYXRoKQp7CglyZXR1cm4gc3RycmNocihwYXRoLCAnLycpOwp9CiNkZWZpbmUgZmluZF9sYXN0X2Rpcl9zZXAgZ2l0X2ZpbmRfbGFzdF9kaXJfc2VwCiNlbmRpZgoKI2lmIGRlZmluZWQoX19IUF9jYykgJiYgKF9fSFBfY2MgPj0gNjEwMDApCiNkZWZpbmUgTk9SRVRVUk4gX19hdHRyaWJ1dGVfXygobm9yZXR1cm4pKQojZGVmaW5lIE5PUkVUVVJOX1BUUgojZWxpZiBkZWZpbmVkKF9fR05VQ19fKSAmJiAhZGVmaW5lZChOT19OT1JFVFVSTikKI2RlZmluZSBOT1JFVFVSTiBfX2F0dHJpYnV0ZV9fKChfX25vcmV0dXJuX18pKQojZGVmaW5lIE5PUkVUVVJOX1BUUiBfX2F0dHJpYnV0ZV9fKChfX25vcmV0dXJuX18pKQojZWxpZiBkZWZpbmVkKF9NU0NfVkVSKQojZGVmaW5lIE5PUkVUVVJOIF9fZGVjbHNwZWMobm9yZXR1cm4pCiNkZWZpbmUgTk9SRVRVUk5fUFRSCiNlbHNlCiNkZWZpbmUgTk9SRVRVUk4KI2RlZmluZSBOT1JFVFVSTl9QVFIKI2lmbmRlZiBfX0dOVUNfXwojaWZuZGVmIF9fYXR0cmlidXRlX18KI2RlZmluZSBfX2F0dHJpYnV0ZV9fKHgpCiNlbmRpZgojZW5kaWYKI2VuZGlmCgovKiBUaGUgc2VudGluZWwgYXR0cmlidXRlIGlzIHZhbGlkIGZyb20gZ2NjIHZlcnNpb24gNC4wICovCiNpZiBkZWZpbmVkKF9fR05VQ19fKSAmJiAoX19HTlVDX18gPj0gNCkKI2RlZmluZSBMQVNUX0FSR19NVVNUX0JFX05VTEwgX19hdHRyaWJ1dGVfXygoc2VudGluZWwpKQojZWxzZQojZGVmaW5lIExBU1RfQVJHX01VU1RfQkVfTlVMTAojZW5kaWYKCiNpbmNsdWRlICJjb21wYXQvYnN3YXAuaCIKCiNpbmNsdWRlICJ3aWxkbWF0Y2guaCIKCnN0cnVjdCBzdHJidWY7CgovKiBHZW5lcmFsIGhlbHBlciBmdW5jdGlvbnMgKi8KZXh0ZXJuIHZvaWQgdnJlcG9ydGYoY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCBjaGFyICplcnIsIHZhX2xpc3QgcGFyYW1zKTsKZXh0ZXJuIE5PUkVUVVJOIHZvaWQgdXNhZ2UoY29uc3QgY2hhciAqZXJyKTsKZXh0ZXJuIE5PUkVUVVJOIHZvaWQgdXNhZ2VmKGNvbnN0IGNoYXIgKmVyciwgLi4uKSBfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMSwgMikpKTsKZXh0ZXJuIE5PUkVUVVJOIHZvaWQgZGllKGNvbnN0IGNoYXIgKmVyciwgLi4uKSBfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMSwgMikpKTsKZXh0ZXJuIE5PUkVUVVJOIHZvaWQgZGllX2Vycm5vKGNvbnN0IGNoYXIgKmVyciwgLi4uKSBfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMSwgMikpKTsKZXh0ZXJuIGludCBlcnJvcihjb25zdCBjaGFyICplcnIsIC4uLikgX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsIDEsIDIpKSk7CmV4dGVybiBpbnQgZXJyb3JfZXJybm8oY29uc3QgY2hhciAqZXJyLCAuLi4pIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwpleHRlcm4gdm9pZCB3YXJuaW5nKGNvbnN0IGNoYXIgKmVyciwgLi4uKSBfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMSwgMikpKTsKZXh0ZXJuIHZvaWQgd2FybmluZ19lcnJubyhjb25zdCBjaGFyICplcnIsIC4uLikgX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsIDEsIDIpKSk7CgojaWZuZGVmIE5PX09QRU5TU0wKI2lmZGVmIEFQUExFX0NPTU1PTl9DUllQVE8KI2luY2x1ZGUgImNvbXBhdC9hcHBsZS1jb21tb24tY3J5cHRvLmgiCiNlbHNlCiNpbmNsdWRlIDxvcGVuc3NsL2V2cC5oPgojaW5jbHVkZSA8b3BlbnNzbC9obWFjLmg+CiNlbmRpZiAvKiBBUFBMRV9DT01NT05fQ1JZUFRPICovCiNpbmNsdWRlIDxvcGVuc3NsL3g1MDl2My5oPgojZW5kaWYgLyogTk9fT1BFTlNTTCAqLwoKLyoKICogTGV0IGNhbGxlcnMgYmUgYXdhcmUgb2YgdGhlIGNvbnN0YW50IHJldHVybiB2YWx1ZTsgdGhpcyBjYW4gaGVscAogKiBnY2Mgd2l0aCAtV3VuaW5pdGlhbGl6ZWQgYW5hbHlzaXMuIFdlIHJlc3RyaWN0IHRoaXMgdHJpY2sgdG8gZ2NjLCB0aG91Z2gsCiAqIGJlY2F1c2Ugc29tZSBjb21waWxlcnMgbWF5IG5vdCBzdXBwb3J0IHZhcmlhZGljIG1hY3Jvcy4gU2luY2Ugd2UncmUgb25seQogKiB0cnlpbmcgdG8gaGVscCBnY2MsIGFueXdheSwgaXQncyBPSzsgb3RoZXIgY29tcGlsZXJzIHdpbGwgZmFsbCBiYWNrIHRvCiAqIHVzaW5nIHRoZSBmdW5jdGlvbiBhcyB1c3VhbC4KICovCiNpZiBkZWZpbmVkKF9fR05VQ19fKQpzdGF0aWMgaW5saW5lIGludCBjb25zdF9lcnJvcih2b2lkKQp7CglyZXR1cm4gLTE7Cn0KI2RlZmluZSBlcnJvciguLi4pIChlcnJvcihfX1ZBX0FSR1NfXyksIGNvbnN0X2Vycm9yKCkpCiNkZWZpbmUgZXJyb3JfZXJybm8oLi4uKSAoZXJyb3JfZXJybm8oX19WQV9BUkdTX18pLCBjb25zdF9lcnJvcigpKQojZW5kaWYKCmV4dGVybiB2b2lkIHNldF9kaWVfcm91dGluZShOT1JFVFVSTl9QVFIgdm9pZCAoKnJvdXRpbmUpKGNvbnN0IGNoYXIgKmVyciwgdmFfbGlzdCBwYXJhbXMpKTsKZXh0ZXJuIHZvaWQgc2V0X2Vycm9yX3JvdXRpbmUodm9pZCAoKnJvdXRpbmUpKGNvbnN0IGNoYXIgKmVyciwgdmFfbGlzdCBwYXJhbXMpKTsKZXh0ZXJuIHZvaWQgKCpnZXRfZXJyb3Jfcm91dGluZSh2b2lkKSkoY29uc3QgY2hhciAqZXJyLCB2YV9saXN0IHBhcmFtcyk7CmV4dGVybiB2b2lkIHNldF93YXJuX3JvdXRpbmUodm9pZCAoKnJvdXRpbmUpKGNvbnN0IGNoYXIgKndhcm4sIHZhX2xpc3QgcGFyYW1zKSk7CmV4dGVybiB2b2lkICgqZ2V0X3dhcm5fcm91dGluZSh2b2lkKSkoY29uc3QgY2hhciAqd2FybiwgdmFfbGlzdCBwYXJhbXMpOwpleHRlcm4gdm9pZCBzZXRfZGllX2lzX3JlY3Vyc2luZ19yb3V0aW5lKGludCAoKnJvdXRpbmUpKHZvaWQpKTsKCmV4dGVybiBpbnQgc3RhcnRzX3dpdGgoY29uc3QgY2hhciAqc3RyLCBjb25zdCBjaGFyICpwcmVmaXgpOwoKLyoKICogSWYgdGhlIHN0cmluZyAic3RyIiBiZWdpbnMgd2l0aCB0aGUgc3RyaW5nIGZvdW5kIGluICJwcmVmaXgiLCByZXR1cm4gMS4KICogVGhlICJvdXQiIHBhcmFtZXRlciBpcyBzZXQgdG8gInN0ciArIHN0cmxlbihwcmVmaXgpIiAoaS5lLiwgdG8gdGhlIHBvaW50IGluCiAqIHRoZSBzdHJpbmcgcmlnaHQgYWZ0ZXIgdGhlIHByZWZpeCkuCiAqCiAqIE90aGVyd2lzZSwgcmV0dXJuIDAgYW5kIGxlYXZlICJvdXQiIHVudG91Y2hlZC4KICoKICogRXhhbXBsZXM6CiAqCiAqICAgW2V4dHJhY3QgYnJhbmNoIG5hbWUsIGZhaWwgaWYgbm90IGEgYnJhbmNoXQogKiAgIGlmICghc2tpcF9wcmVmaXgocmVmLCAicmVmcy9oZWFkcy8iLCAmYnJhbmNoKQogKglyZXR1cm4gLTE7CiAqCiAqICAgW3NraXAgcHJlZml4IGlmIHByZXNlbnQsIG90aGVyd2lzZSB1c2Ugd2hvbGUgc3RyaW5nXQogKiAgIHNraXBfcHJlZml4KG5hbWUsICJyZWZzL2hlYWRzLyIsICZuYW1lKTsKICovCnN0YXRpYyBpbmxpbmUgaW50IHNraXBfcHJlZml4KGNvbnN0IGNoYXIgKnN0ciwgY29uc3QgY2hhciAqcHJlZml4LAoJCQkgICAgICBjb25zdCBjaGFyICoqb3V0KQp7CglkbyB7CgkJaWYgKCEqcHJlZml4KSB7CgkJCSpvdXQgPSBzdHI7CgkJCXJldHVybiAxOwoJCX0KCX0gd2hpbGUgKCpzdHIrKyA9PSAqcHJlZml4KyspOwoJcmV0dXJuIDA7Cn0KCi8qCiAqIExpa2Ugc2tpcF9wcmVmaXgsIGJ1dCBwcm9taXNlcyBuZXZlciB0byByZWFkIHBhc3QgImxlbiIgYnl0ZXMgb2YgdGhlIGlucHV0CiAqIGJ1ZmZlciwgYW5kIHJldHVybnMgdGhlIHJlbWFpbmluZyBudW1iZXIgb2YgYnl0ZXMgaW4gIm91dCIgdmlhICJvdXRsZW4iLgogKi8Kc3RhdGljIGlubGluZSBpbnQgc2tpcF9wcmVmaXhfbWVtKGNvbnN0IGNoYXIgKmJ1Ziwgc2l6ZV90IGxlbiwKCQkJCSAgY29uc3QgY2hhciAqcHJlZml4LAoJCQkJICBjb25zdCBjaGFyICoqb3V0LCBzaXplX3QgKm91dGxlbikKewoJc2l6ZV90IHByZWZpeF9sZW4gPSBzdHJsZW4ocHJlZml4KTsKCWlmIChwcmVmaXhfbGVuIDw9IGxlbiAmJiAhbWVtY21wKGJ1ZiwgcHJlZml4LCBwcmVmaXhfbGVuKSkgewoJCSpvdXQgPSBidWYgKyBwcmVmaXhfbGVuOwoJCSpvdXRsZW4gPSBsZW4gLSBwcmVmaXhfbGVuOwoJCXJldHVybiAxOwoJfQoJcmV0dXJuIDA7Cn0KCi8qCiAqIElmIGJ1ZiBlbmRzIHdpdGggc3VmZml4LCByZXR1cm4gMSBhbmQgc3VidHJhY3QgdGhlIGxlbmd0aCBvZiB0aGUgc3VmZml4CiAqIGZyb20gKmxlbi4gT3RoZXJ3aXNlLCByZXR1cm4gMCBhbmQgbGVhdmUgKmxlbiB1bnRvdWNoZWQuCiAqLwpzdGF0aWMgaW5saW5lIGludCBzdHJpcF9zdWZmaXhfbWVtKGNvbnN0IGNoYXIgKmJ1Ziwgc2l6ZV90ICpsZW4sCgkJCQkgICBjb25zdCBjaGFyICpzdWZmaXgpCnsKCXNpemVfdCBzdWZsZW4gPSBzdHJsZW4oc3VmZml4KTsKCWlmICgqbGVuIDwgc3VmbGVuIHx8IG1lbWNtcChidWYgKyAoKmxlbiAtIHN1ZmxlbiksIHN1ZmZpeCwgc3VmbGVuKSkKCQlyZXR1cm4gMDsKCSpsZW4gLT0gc3VmbGVuOwoJcmV0dXJuIDE7Cn0KCi8qCiAqIElmIHN0ciBlbmRzIHdpdGggc3VmZml4LCByZXR1cm4gMSBhbmQgc2V0ICpsZW4gdG8gdGhlIHNpemUgb2YgdGhlIHN0cmluZwogKiB3aXRob3V0IHRoZSBzdWZmaXguIE90aGVyd2lzZSwgcmV0dXJuIDAgYW5kIHNldCAqbGVuIHRvIHRoZSBzaXplIG9mIHRoZQogKiBzdHJpbmcuCiAqCiAqIE5vdGUgdGhhdCB3ZSBkbyBfbm90XyBOVUwtdGVybWluYXRlIHN0ciB0byB0aGUgbmV3IGxlbmd0aC4KICovCnN0YXRpYyBpbmxpbmUgaW50IHN0cmlwX3N1ZmZpeChjb25zdCBjaGFyICpzdHIsIGNvbnN0IGNoYXIgKnN1ZmZpeCwgc2l6ZV90ICpsZW4pCnsKCSpsZW4gPSBzdHJsZW4oc3RyKTsKCXJldHVybiBzdHJpcF9zdWZmaXhfbWVtKHN0ciwgbGVuLCBzdWZmaXgpOwp9CgpzdGF0aWMgaW5saW5lIGludCBlbmRzX3dpdGgoY29uc3QgY2hhciAqc3RyLCBjb25zdCBjaGFyICpzdWZmaXgpCnsKCXNpemVfdCBsZW47CglyZXR1cm4gc3RyaXBfc3VmZml4KHN0ciwgc3VmZml4LCAmbGVuKTsKfQoKI2RlZmluZSBTV0FQKGEsIGIpIGRvIHsJCQkJCQlcCgl2b2lkICpfc3dhcF9hX3B0ciA9ICYoYSk7CQkJCVwKCXZvaWQgKl9zd2FwX2JfcHRyID0gJihiKTsJCQkJXAoJdW5zaWduZWQgY2hhciBfc3dhcF9idWZmZXJbc2l6ZW9mKGEpXTsJCQlcCgltZW1jcHkoX3N3YXBfYnVmZmVyLCBfc3dhcF9hX3B0ciwgc2l6ZW9mKGEpKTsJCVwKCW1lbWNweShfc3dhcF9hX3B0ciwgX3N3YXBfYl9wdHIsIHNpemVvZihhKSArCQlcCgkgICAgICAgQlVJTERfQVNTRVJUX09SX1pFUk8oc2l6ZW9mKGEpID09IHNpemVvZihiKSkpOwlcCgltZW1jcHkoX3N3YXBfYl9wdHIsIF9zd2FwX2J1ZmZlciwgc2l6ZW9mKGEpKTsJCVwKfSB3aGlsZSAoMCkKCiNpZiBkZWZpbmVkKE5PX01NQVApIHx8IGRlZmluZWQoVVNFX1dJTjMyX01NQVApCgojaWZuZGVmIFBST1RfUkVBRAojZGVmaW5lIFBST1RfUkVBRCAxCiNkZWZpbmUgUFJPVF9XUklURSAyCiNkZWZpbmUgTUFQX1BSSVZBVEUgMQojZW5kaWYKCiNkZWZpbmUgbW1hcCBnaXRfbW1hcAojZGVmaW5lIG11bm1hcCBnaXRfbXVubWFwCmV4dGVybiB2b2lkICpnaXRfbW1hcCh2b2lkICpzdGFydCwgc2l6ZV90IGxlbmd0aCwgaW50IHByb3QsIGludCBmbGFncywgaW50IGZkLCBvZmZfdCBvZmZzZXQpOwpleHRlcm4gaW50IGdpdF9tdW5tYXAodm9pZCAqc3RhcnQsIHNpemVfdCBsZW5ndGgpOwoKI2Vsc2UgLyogTk9fTU1BUCB8fCBVU0VfV0lOMzJfTU1BUCAqLwoKI2luY2x1ZGUgPHN5cy9tbWFuLmg+CgojZW5kaWYgLyogTk9fTU1BUCB8fCBVU0VfV0lOMzJfTU1BUCAqLwoKI2lmZGVmIE5PX01NQVAKCi8qIFRoaXMgdmFsdWUgbXVzdCBiZSBtdWx0aXBsZSBvZiAocGFnZXNpemUgKiAyKSAqLwojZGVmaW5lIERFRkFVTFRfUEFDS0VEX0dJVF9XSU5ET1dfU0laRSAoMSAqIDEwMjQgKiAxMDI0KQoKI2Vsc2UgLyogTk9fTU1BUCAqLwoKLyogVGhpcyB2YWx1ZSBtdXN0IGJlIG11bHRpcGxlIG9mIChwYWdlc2l6ZSAqIDIpICovCiNkZWZpbmUgREVGQVVMVF9QQUNLRURfR0lUX1dJTkRPV19TSVpFIFwKCShzaXplb2Yodm9pZCopID49IDggXAoJCT8gIDEgKiAxMDI0ICogMTAyNCAqIDEwMjQgXAoJCTogMzIgKiAxMDI0ICogMTAyNCkKCiNlbmRpZiAvKiBOT19NTUFQICovCgojaWZuZGVmIE1BUF9GQUlMRUQKI2RlZmluZSBNQVBfRkFJTEVEICgodm9pZCAqKS0xKQojZW5kaWYKCiNpZmRlZiBOT19TVF9CTE9DS1NfSU5fU1RSVUNUX1NUQVQKI2RlZmluZSBvbl9kaXNrX2J5dGVzKHN0KSAoKHN0KS5zdF9zaXplKQojZWxzZQojZGVmaW5lIG9uX2Rpc2tfYnl0ZXMoc3QpICgoc3QpLnN0X2Jsb2NrcyAqIDUxMikKI2VuZGlmCgojaWZkZWYgTkVFRFNfTU9ERV9UUkFOU0xBVElPTgojdW5kZWYgU19JRk1UCiN1bmRlZiBTX0lGUkVHCiN1bmRlZiBTX0lGRElSCiN1bmRlZiBTX0lGTE5LCiN1bmRlZiBTX0lGQkxLCiN1bmRlZiBTX0lGQ0hSCiN1bmRlZiBTX0lGSUZPCiN1bmRlZiBTX0lGU09DSwojZGVmaW5lIFNfSUZNVCAgIDAxNzAwMDAKI2RlZmluZSBTX0lGUkVHICAwMTAwMDAwCiNkZWZpbmUgU19JRkRJUiAgMDA0MDAwMAojZGVmaW5lIFNfSUZMTksgIDAxMjAwMDAKI2RlZmluZSBTX0lGQkxLICAwMDYwMDAwCiNkZWZpbmUgU19JRkNIUiAgMDAyMDAwMAojZGVmaW5lIFNfSUZJRk8gIDAwMTAwMDAKI2RlZmluZSBTX0lGU09DSyAwMTQwMDAwCiNpZmRlZiBzdGF0CiN1bmRlZiBzdGF0CiNlbmRpZgojZGVmaW5lIHN0YXQocGF0aCwgYnVmKSBnaXRfc3RhdChwYXRoLCBidWYpCmV4dGVybiBpbnQgZ2l0X3N0YXQoY29uc3QgY2hhciAqLCBzdHJ1Y3Qgc3RhdCAqKTsKI2lmZGVmIGZzdGF0CiN1bmRlZiBmc3RhdAojZW5kaWYKI2RlZmluZSBmc3RhdChmZCwgYnVmKSBnaXRfZnN0YXQoZmQsIGJ1ZikKZXh0ZXJuIGludCBnaXRfZnN0YXQoaW50LCBzdHJ1Y3Qgc3RhdCAqKTsKI2lmZGVmIGxzdGF0CiN1bmRlZiBsc3RhdAojZW5kaWYKI2RlZmluZSBsc3RhdChwYXRoLCBidWYpIGdpdF9sc3RhdChwYXRoLCBidWYpCmV4dGVybiBpbnQgZ2l0X2xzdGF0KGNvbnN0IGNoYXIgKiwgc3RydWN0IHN0YXQgKik7CiNlbmRpZgoKI2RlZmluZSBERUZBVUxUX1BBQ0tFRF9HSVRfTElNSVQgXAoJKCgxMDI0TCAqIDEwMjRMKSAqIChzaXplX3QpKHNpemVvZih2b2lkKikgPj0gOCA/ICgzMiAqIDEwMjRMICogMTAyNEwpIDogMjU2KSkKCiNpZmRlZiBOT19QUkVBRAojZGVmaW5lIHByZWFkIGdpdF9wcmVhZApleHRlcm4gc3NpemVfdCBnaXRfcHJlYWQoaW50IGZkLCB2b2lkICpidWYsIHNpemVfdCBjb3VudCwgb2ZmX3Qgb2Zmc2V0KTsKI2VuZGlmCi8qCiAqIEZvcndhcmQgZGVjbCB0aGF0IHdpbGwgcmVtaW5kIHVzIGlmIGl0cyB0d2luIGluIGNhY2hlLmggY2hhbmdlcy4KICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGluIGNvbXBhdC9wcmVhZC5jLiAgQnV0IHdlIGNhbid0IGluY2x1ZGUKICogY2FjaGUuaCB0aGVyZS4KICovCmV4dGVybiBzc2l6ZV90IHJlYWRfaW5fZnVsbChpbnQgZmQsIHZvaWQgKmJ1Ziwgc2l6ZV90IGNvdW50KTsKCiNpZmRlZiBOT19TRVRFTlYKI2RlZmluZSBzZXRlbnYgZ2l0c2V0ZW52CmV4dGVybiBpbnQgZ2l0c2V0ZW52KGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqLCBpbnQpOwojZW5kaWYKCiNpZmRlZiBOT19NS0RURU1QCiNkZWZpbmUgbWtkdGVtcCBnaXRta2R0ZW1wCmV4dGVybiBjaGFyICpnaXRta2R0ZW1wKGNoYXIgKik7CiNlbmRpZgoKI2lmZGVmIE5PX1VOU0VURU5WCiNkZWZpbmUgdW5zZXRlbnYgZ2l0dW5zZXRlbnYKZXh0ZXJuIHZvaWQgZ2l0dW5zZXRlbnYoY29uc3QgY2hhciAqKTsKI2VuZGlmCgojaWZkZWYgTk9fU1RSQ0FTRVNUUgojZGVmaW5lIHN0cmNhc2VzdHIgZ2l0c3RyY2FzZXN0cgpleHRlcm4gY2hhciAqZ2l0c3RyY2FzZXN0cihjb25zdCBjaGFyICpoYXlzdGFjaywgY29uc3QgY2hhciAqbmVlZGxlKTsKI2VuZGlmCgojaWZkZWYgTk9fU1RSTENQWQojZGVmaW5lIHN0cmxjcHkgZ2l0c3RybGNweQpleHRlcm4gc2l6ZV90IGdpdHN0cmxjcHkoY2hhciAqLCBjb25zdCBjaGFyICosIHNpemVfdCk7CiNlbmRpZgoKI2lmZGVmIE5PX1NUUlRPVU1BWAojZGVmaW5lIHN0cnRvdW1heCBnaXRzdHJ0b3VtYXgKZXh0ZXJuIHVpbnRtYXhfdCBnaXRzdHJ0b3VtYXgoY29uc3QgY2hhciAqLCBjaGFyICoqLCBpbnQpOwojZGVmaW5lIHN0cnRvaW1heCBnaXRzdHJ0b2ltYXgKZXh0ZXJuIGludG1heF90IGdpdHN0cnRvaW1heChjb25zdCBjaGFyICosIGNoYXIgKiosIGludCk7CiNlbmRpZgoKI2lmZGVmIE5PX0hTVFJFUlJPUgojZGVmaW5lIGhzdHJlcnJvciBnaXRoc3RyZXJyb3IKZXh0ZXJuIGNvbnN0IGNoYXIgKmdpdGhzdHJlcnJvcihpbnQgaGVycm9yKTsKI2VuZGlmCgojaWZkZWYgTk9fTUVNTUVNCiNkZWZpbmUgbWVtbWVtIGdpdG1lbW1lbQp2b2lkICpnaXRtZW1tZW0oY29uc3Qgdm9pZCAqaGF5c3RhY2ssIHNpemVfdCBoYXlzdGFja2xlbiwKICAgICAgICAgICAgICAgIGNvbnN0IHZvaWQgKm5lZWRsZSwgc2l6ZV90IG5lZWRsZWxlbik7CiNlbmRpZgoKI2lmZGVmIE9WRVJSSURFX1NUUkRVUAojaWZkZWYgc3RyZHVwCiN1bmRlZiBzdHJkdXAKI2VuZGlmCiNkZWZpbmUgc3RyZHVwIGdpdHN0cmR1cApjaGFyICpnaXRzdHJkdXAoY29uc3QgY2hhciAqcyk7CiNlbmRpZgoKI2lmZGVmIE5PX0dFVFBBR0VTSVpFCiNkZWZpbmUgZ2V0cGFnZXNpemUoKSBzeXNjb25mKF9TQ19QQUdFU0laRSkKI2VuZGlmCgojaWZuZGVmIE9fQ0xPRVhFQwojZGVmaW5lIE9fQ0xPRVhFQyAwCiNlbmRpZgoKI2lmZGVmIEZSRUFEX1JFQURTX0RJUkVDVE9SSUVTCiMgaWYgIWRlZmluZWQoU1VQUFJFU1NfRk9QRU5fUkVERUZJTklUSU9OKQojICBpZmRlZiBmb3BlbgojICAgdW5kZWYgZm9wZW4KIyAgZW5kaWYKIyAgZGVmaW5lIGZvcGVuKGEsYikgZ2l0X2ZvcGVuKGEsYikKIyBlbmRpZgpleHRlcm4gRklMRSAqZ2l0X2ZvcGVuKGNvbnN0IGNoYXIqLCBjb25zdCBjaGFyKik7CiNlbmRpZgoKI2lmZGVmIFNOUFJJTlRGX1JFVFVSTlNfQk9HVVMKI2lmZGVmIHNucHJpbnRmCiN1bmRlZiBzbnByaW50ZgojZW5kaWYKI2RlZmluZSBzbnByaW50ZiBnaXRfc25wcmludGYKZXh0ZXJuIGludCBnaXRfc25wcmludGYoY2hhciAqc3RyLCBzaXplX3QgbWF4c2l6ZSwKCQkJY29uc3QgY2hhciAqZm9ybWF0LCAuLi4pOwojaWZkZWYgdnNucHJpbnRmCiN1bmRlZiB2c25wcmludGYKI2VuZGlmCiNkZWZpbmUgdnNucHJpbnRmIGdpdF92c25wcmludGYKZXh0ZXJuIGludCBnaXRfdnNucHJpbnRmKGNoYXIgKnN0ciwgc2l6ZV90IG1heHNpemUsCgkJCSBjb25zdCBjaGFyICpmb3JtYXQsIHZhX2xpc3QgYXApOwojZW5kaWYKCiNpZmRlZiBfX0dMSUJDX1BSRVJFUQojaWYgX19HTElCQ19QUkVSRVEoMiwgMSkKI2RlZmluZSBIQVZFX1NUUkNIUk5VTAojZW5kaWYKI2VuZGlmCgojaWZuZGVmIEhBVkVfU1RSQ0hSTlVMCiNkZWZpbmUgc3RyY2hybnVsIGdpdHN0cmNocm51bApzdGF0aWMgaW5saW5lIGNoYXIgKmdpdHN0cmNocm51bChjb25zdCBjaGFyICpzLCBpbnQgYykKewoJd2hpbGUgKCpzICYmICpzICE9IGMpCgkJcysrOwoJcmV0dXJuIChjaGFyICopczsKfQojZW5kaWYKCiNpZmRlZiBOT19JTkVUX1BUT04KaW50IGluZXRfcHRvbihpbnQgYWYsIGNvbnN0IGNoYXIgKnNyYywgdm9pZCAqZHN0KTsKI2VuZGlmCgojaWZkZWYgTk9fSU5FVF9OVE9QCmNvbnN0IGNoYXIgKmluZXRfbnRvcChpbnQgYWYsIGNvbnN0IHZvaWQgKnNyYywgY2hhciAqZHN0LCBzaXplX3Qgc2l6ZSk7CiNlbmRpZgoKI2lmZGVmIE5PX1BUSFJFQURTCiNkZWZpbmUgYXRleGl0IGdpdF9hdGV4aXQKZXh0ZXJuIGludCBnaXRfYXRleGl0KHZvaWQgKCpoYW5kbGVyKSh2b2lkKSk7CiNlbmRpZgoKdHlwZWRlZiB2b2lkICgqdHJ5X3RvX2ZyZWVfdCkoc2l6ZV90KTsKZXh0ZXJuIHRyeV90b19mcmVlX3Qgc2V0X3RyeV90b19mcmVlX3JvdXRpbmUodHJ5X3RvX2ZyZWVfdCk7CgpzdGF0aWMgaW5saW5lIHNpemVfdCBzdF9hZGQoc2l6ZV90IGEsIHNpemVfdCBiKQp7CglpZiAodW5zaWduZWRfYWRkX292ZXJmbG93cyhhLCBiKSkKCQlkaWUoInNpemVfdCBvdmVyZmxvdzogJSJQUkl1TUFYIiArICUiUFJJdU1BWCwKCQkgICAgKHVpbnRtYXhfdClhLCAodWludG1heF90KWIpOwoJcmV0dXJuIGEgKyBiOwp9CiNkZWZpbmUgc3RfYWRkMyhhLGIsYykgICBzdF9hZGQoc3RfYWRkKChhKSwoYikpLChjKSkKI2RlZmluZSBzdF9hZGQ0KGEsYixjLGQpIHN0X2FkZChzdF9hZGQzKChhKSwoYiksKGMpKSwoZCkpCgpzdGF0aWMgaW5saW5lIHNpemVfdCBzdF9tdWx0KHNpemVfdCBhLCBzaXplX3QgYikKewoJaWYgKHVuc2lnbmVkX211bHRfb3ZlcmZsb3dzKGEsIGIpKQoJCWRpZSgic2l6ZV90IG92ZXJmbG93OiAlIlBSSXVNQVgiICogJSJQUkl1TUFYLAoJCSAgICAodWludG1heF90KWEsICh1aW50bWF4X3QpYik7CglyZXR1cm4gYSAqIGI7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90IHN0X3N1YihzaXplX3QgYSwgc2l6ZV90IGIpCnsKCWlmIChhIDwgYikKCQlkaWUoInNpemVfdCB1bmRlcmZsb3c6ICUiUFJJdU1BWCIgLSAlIlBSSXVNQVgsCgkJICAgICh1aW50bWF4X3QpYSwgKHVpbnRtYXhfdCliKTsKCXJldHVybiBhIC0gYjsKfQoKI2lmZGVmIEhBVkVfQUxMT0NBX0gKIyBpbmNsdWRlIDxhbGxvY2EuaD4KIyBkZWZpbmUgeGFsbG9jYShzaXplKSAgICAgIChhbGxvY2Eoc2l6ZSkpCiMgZGVmaW5lIHhhbGxvY2FfZnJlZShwKSAgICBkbyB7fSB3aGlsZSAoMCkKI2Vsc2UKIyBkZWZpbmUgeGFsbG9jYShzaXplKSAgICAgICh4bWFsbG9jKHNpemUpKQojIGRlZmluZSB4YWxsb2NhX2ZyZWUocCkgICAgKGZyZWUocCkpCiNlbmRpZgpleHRlcm4gY2hhciAqeHN0cmR1cChjb25zdCBjaGFyICpzdHIpOwpleHRlcm4gdm9pZCAqeG1hbGxvYyhzaXplX3Qgc2l6ZSk7CmV4dGVybiB2b2lkICp4bWFsbG9jeihzaXplX3Qgc2l6ZSk7CmV4dGVybiB2b2lkICp4bWFsbG9jel9nZW50bHkoc2l6ZV90IHNpemUpOwpleHRlcm4gdm9pZCAqeG1lbWR1cHooY29uc3Qgdm9pZCAqZGF0YSwgc2l6ZV90IGxlbik7CmV4dGVybiBjaGFyICp4c3RybmR1cChjb25zdCBjaGFyICpzdHIsIHNpemVfdCBsZW4pOwpleHRlcm4gdm9pZCAqeHJlYWxsb2Modm9pZCAqcHRyLCBzaXplX3Qgc2l6ZSk7CmV4dGVybiB2b2lkICp4Y2FsbG9jKHNpemVfdCBubWVtYiwgc2l6ZV90IHNpemUpOwpleHRlcm4gdm9pZCAqeG1tYXAodm9pZCAqc3RhcnQsIHNpemVfdCBsZW5ndGgsIGludCBwcm90LCBpbnQgZmxhZ3MsIGludCBmZCwgb2ZmX3Qgb2Zmc2V0KTsKZXh0ZXJuIHZvaWQgKnhtbWFwX2dlbnRseSh2b2lkICpzdGFydCwgc2l6ZV90IGxlbmd0aCwgaW50IHByb3QsIGludCBmbGFncywgaW50IGZkLCBvZmZfdCBvZmZzZXQpOwpleHRlcm4gaW50IHhvcGVuKGNvbnN0IGNoYXIgKnBhdGgsIGludCBmbGFncywgLi4uKTsKZXh0ZXJuIHNzaXplX3QgeHJlYWQoaW50IGZkLCB2b2lkICpidWYsIHNpemVfdCBsZW4pOwpleHRlcm4gc3NpemVfdCB4d3JpdGUoaW50IGZkLCBjb25zdCB2b2lkICpidWYsIHNpemVfdCBsZW4pOwpleHRlcm4gc3NpemVfdCB4cHJlYWQoaW50IGZkLCB2b2lkICpidWYsIHNpemVfdCBsZW4sIG9mZl90IG9mZnNldCk7CmV4dGVybiBpbnQgeGR1cChpbnQgZmQpOwpleHRlcm4gRklMRSAqeGZvcGVuKGNvbnN0IGNoYXIgKnBhdGgsIGNvbnN0IGNoYXIgKm1vZGUpOwpleHRlcm4gRklMRSAqeGZkb3BlbihpbnQgZmQsIGNvbnN0IGNoYXIgKm1vZGUpOwpleHRlcm4gaW50IHhta3N0ZW1wKGNoYXIgKnRlbXBsYXRlKTsKZXh0ZXJuIGludCB4bWtzdGVtcF9tb2RlKGNoYXIgKnRlbXBsYXRlLCBpbnQgbW9kZSk7CmV4dGVybiBjaGFyICp4Z2V0Y3dkKHZvaWQpOwpleHRlcm4gRklMRSAqZm9wZW5fZm9yX3dyaXRpbmcoY29uc3QgY2hhciAqcGF0aCk7CmV4dGVybiBGSUxFICpmb3Blbl9vcl93YXJuKGNvbnN0IGNoYXIgKnBhdGgsIGNvbnN0IGNoYXIgKm1vZGUpOwoKLyoKICogRlJFRV9BTkRfTlVMTChwdHIpIGlzIGxpa2UgZnJlZShwdHIpIGZvbGxvd2VkIGJ5IHB0ciA9IE5VTEwuIE5vdGUKICogdGhhdCBwdHIgaXMgdXNlZCB0d2ljZSwgc28gZG9uJ3QgcGFzcyBlLmcuIHB0cisrLgogKi8KI2RlZmluZSBGUkVFX0FORF9OVUxMKHApIGRvIHsgZnJlZShwKTsgKHApID0gTlVMTDsgfSB3aGlsZSAoMCkKCiNkZWZpbmUgQUxMT0NfQVJSQVkoeCwgYWxsb2MpICh4KSA9IHhtYWxsb2Moc3RfbXVsdChzaXplb2YoKih4KSksIChhbGxvYykpKQojZGVmaW5lIFJFQUxMT0NfQVJSQVkoeCwgYWxsb2MpICh4KSA9IHhyZWFsbG9jKCh4KSwgc3RfbXVsdChzaXplb2YoKih4KSksIChhbGxvYykpKQoKI2RlZmluZSBDT1BZX0FSUkFZKGRzdCwgc3JjLCBuKSBjb3B5X2FycmF5KChkc3QpLCAoc3JjKSwgKG4pLCBzaXplb2YoKihkc3QpKSArIFwKCUJVSUxEX0FTU0VSVF9PUl9aRVJPKHNpemVvZigqKGRzdCkpID09IHNpemVvZigqKHNyYykpKSkKc3RhdGljIGlubGluZSB2b2lkIGNvcHlfYXJyYXkodm9pZCAqZHN0LCBjb25zdCB2b2lkICpzcmMsIHNpemVfdCBuLCBzaXplX3Qgc2l6ZSkKewoJaWYgKG4pCgkJbWVtY3B5KGRzdCwgc3JjLCBzdF9tdWx0KHNpemUsIG4pKTsKfQoKI2RlZmluZSBNT1ZFX0FSUkFZKGRzdCwgc3JjLCBuKSBtb3ZlX2FycmF5KChkc3QpLCAoc3JjKSwgKG4pLCBzaXplb2YoKihkc3QpKSArIFwKCUJVSUxEX0FTU0VSVF9PUl9aRVJPKHNpemVvZigqKGRzdCkpID09IHNpemVvZigqKHNyYykpKSkKc3RhdGljIGlubGluZSB2b2lkIG1vdmVfYXJyYXkodm9pZCAqZHN0LCBjb25zdCB2b2lkICpzcmMsIHNpemVfdCBuLCBzaXplX3Qgc2l6ZSkKewoJaWYgKG4pCgkJbWVtbW92ZShkc3QsIHNyYywgc3RfbXVsdChzaXplLCBuKSk7Cn0KCi8qCiAqIFRoZXNlIGZ1bmN0aW9ucyBoZWxwIHlvdSBhbGxvY2F0ZSBzdHJ1Y3RzIHdpdGggZmxleCBhcnJheXMsIGFuZCBjb3B5CiAqIHRoZSBkYXRhIGRpcmVjdGx5IGludG8gdGhlIGFycmF5LiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhZDoKICoKICogICBzdHJ1Y3QgZm9vIHsKICogICAgIGludCBiYXI7CiAqICAgICBjaGFyIG5hbWVbRkxFWF9BUlJBWV07CiAqICAgfTsKICoKICogeW91IGNhbiBkbzoKICoKICogICBzdHJ1Y3QgZm9vICpmOwogKiAgIEZMRVhfQUxMT0NfTUVNKGYsIG5hbWUsIHNyYywgbGVuKTsKICoKICogdG8gYWxsb2NhdGUgYSAiZm9vIiB3aXRoIHRoZSBjb250ZW50cyBvZiAic3JjIiBpbiB0aGUgIm5hbWUiIGZpZWxkLgogKiBUaGUgcmVzdWx0aW5nIHN0cnVjdCBpcyBhdXRvbWF0aWNhbGx5IHplcm8nZCwgYW5kIHRoZSBmbGV4LWFycmF5IGZpZWxkCiAqIGlzIE5VTC10ZXJtaW5hdGVkICh3aGV0aGVyIHRoZSBpbmNvbWluZyBzcmMgYnVmZmVyIHdhcyBvciBub3QpLgogKgogKiBUaGUgRkxFWFBUUl8qIHZhcmlhbnRzIG9wZXJhdGUgb24gc3RydWN0cyB0aGF0IGRvbid0IHVzZSBmbGV4LWFycmF5cywKICogYnV0IGRvIHdhbnQgdG8gc3RvcmUgYSBwb2ludGVyIHRvIHNvbWUgZXh0cmEgZGF0YSBpbiB0aGUgc2FtZSBhbGxvY2F0ZWQKICogYmxvY2suIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZToKICoKICogICBzdHJ1Y3QgZm9vIHsKICogICAgIGNoYXIgKm5hbWU7CiAqICAgICBpbnQgYmFyOwogKiAgIH07CiAqCiAqIHlvdSBjYW4gZG86CiAqCiAqICAgc3RydWN0IGZvbyAqZjsKICogICBGTEVYUFRSX0FMTE9DX1NUUihmLCBuYW1lLCBzcmMpOwogKgogKiBhbmQgIm5hbWUiIHdpbGwgcG9pbnQgdG8gYSBibG9jayBvZiBtZW1vcnkgYWZ0ZXIgdGhlIHN0cnVjdCwgd2hpY2ggd2lsbCBiZQogKiBmcmVlZCBhbG9uZyB3aXRoIHRoZSBzdHJ1Y3QgKGJ1dCB0aGUgcG9pbnRlciBjYW4gYmUgcmVwb2ludGVkIGFueXdoZXJlKS4KICoKICogVGhlICpfU1RSIHZhcmlhbnRzIGFjY2VwdCBhIHN0cmluZyBwYXJhbWV0ZXIgcmF0aGVyIHRoYW4gYSBwdHIvbGVuCiAqIGNvbWJpbmF0aW9uLgogKgogKiBOb3RlIHRoYXQgdGhlc2UgbWFjcm9zIHdpbGwgZXZhbHVhdGUgdGhlIGZpcnN0IHBhcmFtZXRlciBtdWx0aXBsZQogKiB0aW1lcywgYW5kIGl0IG11c3QgYmUgYXNzaWduYWJsZSBhcyBhbiBsdmFsdWUuCiAqLwojZGVmaW5lIEZMRVhfQUxMT0NfTUVNKHgsIGZsZXhuYW1lLCBidWYsIGxlbikgZG8geyBcCglzaXplX3QgZmxleF9hcnJheV9sZW5fID0gKGxlbik7IFwKCSh4KSA9IHhjYWxsb2MoMSwgc3RfYWRkMyhzaXplb2YoKih4KSksIGZsZXhfYXJyYXlfbGVuXywgMSkpOyBcCgltZW1jcHkoKHZvaWQgKikoeCktPmZsZXhuYW1lLCAoYnVmKSwgZmxleF9hcnJheV9sZW5fKTsgXAp9IHdoaWxlICgwKQojZGVmaW5lIEZMRVhQVFJfQUxMT0NfTUVNKHgsIHB0cm5hbWUsIGJ1ZiwgbGVuKSBkbyB7IFwKCXNpemVfdCBmbGV4X2FycmF5X2xlbl8gPSAobGVuKTsgXAoJKHgpID0geGNhbGxvYygxLCBzdF9hZGQzKHNpemVvZigqKHgpKSwgZmxleF9hcnJheV9sZW5fLCAxKSk7IFwKCW1lbWNweSgoeCkgKyAxLCAoYnVmKSwgZmxleF9hcnJheV9sZW5fKTsgXAoJKHgpLT5wdHJuYW1lID0gKHZvaWQgKikoKHgpKzEpOyBcCn0gd2hpbGUoMCkKI2RlZmluZSBGTEVYX0FMTE9DX1NUUih4LCBmbGV4bmFtZSwgc3RyKSBcCglGTEVYX0FMTE9DX01FTSgoeCksIGZsZXhuYW1lLCAoc3RyKSwgc3RybGVuKHN0cikpCiNkZWZpbmUgRkxFWFBUUl9BTExPQ19TVFIoeCwgcHRybmFtZSwgc3RyKSBcCglGTEVYUFRSX0FMTE9DX01FTSgoeCksIHB0cm5hbWUsIChzdHIpLCBzdHJsZW4oc3RyKSkKCnN0YXRpYyBpbmxpbmUgY2hhciAqeHN0cmR1cF9vcl9udWxsKGNvbnN0IGNoYXIgKnN0cikKewoJcmV0dXJuIHN0ciA/IHhzdHJkdXAoc3RyKSA6IE5VTEw7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90IHhzaXplX3Qob2ZmX3QgbGVuKQp7CglpZiAobGVuID4gKHNpemVfdCkgbGVuKQoJCWRpZSgiQ2Fubm90IGhhbmRsZSBmaWxlcyB0aGlzIGJpZyIpOwoJcmV0dXJuIChzaXplX3QpbGVuOwp9CgpfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMywgNCkpKQpleHRlcm4gaW50IHhzbnByaW50ZihjaGFyICpkc3QsIHNpemVfdCBtYXgsIGNvbnN0IGNoYXIgKmZtdCwgLi4uKTsKCiNpZm5kZWYgSE9TVF9OQU1FX01BWAojZGVmaW5lIEhPU1RfTkFNRV9NQVggMjU2CiNlbmRpZgoKZXh0ZXJuIGludCB4Z2V0aG9zdG5hbWUoY2hhciAqYnVmLCBzaXplX3QgbGVuKTsKCi8qIGluIGN0eXBlLmMsIGZvciBrd3NldCB1c2VycyAqLwpleHRlcm4gY29uc3QgdW5zaWduZWQgY2hhciB0b2xvd2VyX3RyYW5zX3RibFsyNTZdOwoKLyogU2FuZSBjdHlwZSAtIG5vIGxvY2FsZSwgYW5kIHdvcmtzIHdpdGggc2lnbmVkIGNoYXJzICovCiN1bmRlZiBpc2FzY2lpCiN1bmRlZiBpc3NwYWNlCiN1bmRlZiBpc2RpZ2l0CiN1bmRlZiBpc2FscGhhCiN1bmRlZiBpc2FsbnVtCiN1bmRlZiBpc3ByaW50CiN1bmRlZiBpc2xvd2VyCiN1bmRlZiBpc3VwcGVyCiN1bmRlZiB0b2xvd2VyCiN1bmRlZiB0b3VwcGVyCiN1bmRlZiBpc2NudHJsCiN1bmRlZiBpc3B1bmN0CiN1bmRlZiBpc3hkaWdpdAoKZXh0ZXJuIGNvbnN0IHVuc2lnbmVkIGNoYXIgc2FuZV9jdHlwZVsyNTZdOwojZGVmaW5lIEdJVF9TUEFDRSAweDAxCiNkZWZpbmUgR0lUX0RJR0lUIDB4MDIKI2RlZmluZSBHSVRfQUxQSEEgMHgwNAojZGVmaW5lIEdJVF9HTE9CX1NQRUNJQUwgMHgwOAojZGVmaW5lIEdJVF9SRUdFWF9TUEVDSUFMIDB4MTAKI2RlZmluZSBHSVRfUEFUSFNQRUNfTUFHSUMgMHgyMAojZGVmaW5lIEdJVF9DTlRSTCAweDQwCiNkZWZpbmUgR0lUX1BVTkNUIDB4ODAKI2RlZmluZSBzYW5lX2lzdGVzdCh4LG1hc2spICgoc2FuZV9jdHlwZVsodW5zaWduZWQgY2hhcikoeCldICYgKG1hc2spKSAhPSAwKQojZGVmaW5lIGlzYXNjaWkoeCkgKCgoeCkgJiB+MHg3ZikgPT0gMCkKI2RlZmluZSBpc3NwYWNlKHgpIHNhbmVfaXN0ZXN0KHgsR0lUX1NQQUNFKQojZGVmaW5lIGlzZGlnaXQoeCkgc2FuZV9pc3Rlc3QoeCxHSVRfRElHSVQpCiNkZWZpbmUgaXNhbHBoYSh4KSBzYW5lX2lzdGVzdCh4LEdJVF9BTFBIQSkKI2RlZmluZSBpc2FsbnVtKHgpIHNhbmVfaXN0ZXN0KHgsR0lUX0FMUEhBIHwgR0lUX0RJR0lUKQojZGVmaW5lIGlzcHJpbnQoeCkgKCh4KSA+PSAweDIwICYmICh4KSA8PSAweDdlKQojZGVmaW5lIGlzbG93ZXIoeCkgc2FuZV9pc2Nhc2UoeCwgMSkKI2RlZmluZSBpc3VwcGVyKHgpIHNhbmVfaXNjYXNlKHgsIDApCiNkZWZpbmUgaXNfZ2xvYl9zcGVjaWFsKHgpIHNhbmVfaXN0ZXN0KHgsR0lUX0dMT0JfU1BFQ0lBTCkKI2RlZmluZSBpc19yZWdleF9zcGVjaWFsKHgpIHNhbmVfaXN0ZXN0KHgsR0lUX0dMT0JfU1BFQ0lBTCB8IEdJVF9SRUdFWF9TUEVDSUFMKQojZGVmaW5lIGlzY250cmwoeCkgKHNhbmVfaXN0ZXN0KHgsR0lUX0NOVFJMKSkKI2RlZmluZSBpc3B1bmN0KHgpIHNhbmVfaXN0ZXN0KHgsIEdJVF9QVU5DVCB8IEdJVF9SRUdFWF9TUEVDSUFMIHwgXAoJCUdJVF9HTE9CX1NQRUNJQUwgfCBHSVRfUEFUSFNQRUNfTUFHSUMpCiNkZWZpbmUgaXN4ZGlnaXQoeCkgKGhleHZhbF90YWJsZVsodW5zaWduZWQgY2hhcikoeCldICE9IC0xKQojZGVmaW5lIHRvbG93ZXIoeCkgc2FuZV9jYXNlKCh1bnNpZ25lZCBjaGFyKSh4KSwgMHgyMCkKI2RlZmluZSB0b3VwcGVyKHgpIHNhbmVfY2FzZSgodW5zaWduZWQgY2hhcikoeCksIDApCiNkZWZpbmUgaXNfcGF0aHNwZWNfbWFnaWMoeCkgc2FuZV9pc3Rlc3QoeCxHSVRfUEFUSFNQRUNfTUFHSUMpCgpzdGF0aWMgaW5saW5lIGludCBzYW5lX2Nhc2UoaW50IHgsIGludCBoaWdoKQp7CglpZiAoc2FuZV9pc3Rlc3QoeCwgR0lUX0FMUEhBKSkKCQl4ID0gKHggJiB+MHgyMCkgfCBoaWdoOwoJcmV0dXJuIHg7Cn0KCnN0YXRpYyBpbmxpbmUgaW50IHNhbmVfaXNjYXNlKGludCB4LCBpbnQgaXNfbG93ZXIpCnsKCWlmICghc2FuZV9pc3Rlc3QoeCwgR0lUX0FMUEhBKSkKCQlyZXR1cm4gMDsKCglpZiAoaXNfbG93ZXIpCgkJcmV0dXJuICh4ICYgMHgyMCkgIT0gMDsKCWVsc2UKCQlyZXR1cm4gKHggJiAweDIwKSA9PSAwOwp9CgpzdGF0aWMgaW5saW5lIGludCBzdHJ0b3VsX3VpKGNoYXIgY29uc3QgKnMsIGludCBiYXNlLCB1bnNpZ25lZCBpbnQgKnJlc3VsdCkKewoJdW5zaWduZWQgbG9uZyB1bDsKCWNoYXIgKnA7CgoJZXJybm8gPSAwOwoJLyogbmVnYXRpdmUgdmFsdWVzIHdvdWxkIGJlIGFjY2VwdGVkIGJ5IHN0cnRvdWwgKi8KCWlmIChzdHJjaHIocywgJy0nKSkKCQlyZXR1cm4gLTE7Cgl1bCA9IHN0cnRvdWwocywgJnAsIGJhc2UpOwoJaWYgKGVycm5vIHx8ICpwIHx8IHAgPT0gcyB8fCAodW5zaWduZWQgaW50KSB1bCAhPSB1bCkKCQlyZXR1cm4gLTE7CgkqcmVzdWx0ID0gdWw7CglyZXR1cm4gMDsKfQoKc3RhdGljIGlubGluZSBpbnQgc3RydG9sX2koY2hhciBjb25zdCAqcywgaW50IGJhc2UsIGludCAqcmVzdWx0KQp7Cglsb25nIHVsOwoJY2hhciAqcDsKCgllcnJubyA9IDA7Cgl1bCA9IHN0cnRvbChzLCAmcCwgYmFzZSk7CglpZiAoZXJybm8gfHwgKnAgfHwgcCA9PSBzIHx8IChpbnQpIHVsICE9IHVsKQoJCXJldHVybiAtMTsKCSpyZXN1bHQgPSB1bDsKCXJldHVybiAwOwp9CgojaWZkZWYgSU5URVJOQUxfUVNPUlQKdm9pZCBnaXRfcXNvcnQodm9pZCAqYmFzZSwgc2l6ZV90IG5tZW1iLCBzaXplX3Qgc2l6ZSwKCSAgICAgICBpbnQoKmNvbXBhcikoY29uc3Qgdm9pZCAqLCBjb25zdCB2b2lkICopKTsKI2RlZmluZSBxc29ydCBnaXRfcXNvcnQKI2VuZGlmCgojZGVmaW5lIFFTT1JUKGJhc2UsIG4sIGNvbXBhcikgc2FuZV9xc29ydCgoYmFzZSksIChuKSwgc2l6ZW9mKCooYmFzZSkpLCBjb21wYXIpCnN0YXRpYyBpbmxpbmUgdm9pZCBzYW5lX3Fzb3J0KHZvaWQgKmJhc2UsIHNpemVfdCBubWVtYiwgc2l6ZV90IHNpemUsCgkJCSAgICAgIGludCgqY29tcGFyKShjb25zdCB2b2lkICosIGNvbnN0IHZvaWQgKikpCnsKCWlmIChubWVtYiA+IDEpCgkJcXNvcnQoYmFzZSwgbm1lbWIsIHNpemUsIGNvbXBhcik7Cn0KCiNpZm5kZWYgSEFWRV9JU09fUVNPUlRfUwppbnQgZ2l0X3Fzb3J0X3Modm9pZCAqYmFzZSwgc2l6ZV90IG5tZW1iLCBzaXplX3Qgc2l6ZSwKCQlpbnQgKCpjb21wYXIpKGNvbnN0IHZvaWQgKiwgY29uc3Qgdm9pZCAqLCB2b2lkICopLCB2b2lkICpjdHgpOwojZGVmaW5lIHFzb3J0X3MgZ2l0X3Fzb3J0X3MKI2VuZGlmCgojZGVmaW5lIFFTT1JUX1MoYmFzZSwgbiwgY29tcGFyLCBjdHgpIGRvIHsJCQlcCglpZiAocXNvcnRfcygoYmFzZSksIChuKSwgc2l6ZW9mKCooYmFzZSkpLCBjb21wYXIsIGN0eCkpCVwKCQlkaWUoIkJVRzogcXNvcnRfcygpIGZhaWxlZCIpOwkJCVwKfSB3aGlsZSAoMCkKCiNpZm5kZWYgUkVHX1NUQVJURU5ECiNlcnJvciAiR2l0IHJlcXVpcmVzIFJFR19TVEFSVEVORCBzdXBwb3J0LiBDb21waWxlIHdpdGggTk9fUkVHRVg9TmVlZHNTdGFydEVuZCIKI2VuZGlmCgpzdGF0aWMgaW5saW5lIGludCByZWdleGVjX2J1Zihjb25zdCByZWdleF90ICpwcmVnLCBjb25zdCBjaGFyICpidWYsIHNpemVfdCBzaXplLAoJCQkgICAgICBzaXplX3Qgbm1hdGNoLCByZWdtYXRjaF90IHBtYXRjaFtdLCBpbnQgZWZsYWdzKQp7Cglhc3NlcnQobm1hdGNoID4gMCAmJiBwbWF0Y2gpOwoJcG1hdGNoWzBdLnJtX3NvID0gMDsKCXBtYXRjaFswXS5ybV9lbyA9IHNpemU7CglyZXR1cm4gcmVnZXhlYyhwcmVnLCBidWYsIG5tYXRjaCwgcG1hdGNoLCBlZmxhZ3MgfCBSRUdfU1RBUlRFTkQpOwp9CgojaWZuZGVmIERJUl9IQVNfQlNEX0dST1VQX1NFTUFOVElDUwojIGRlZmluZSBGT1JDRV9ESVJfU0VUX0dJRCBTX0lTR0lECiNlbHNlCiMgZGVmaW5lIEZPUkNFX0RJUl9TRVRfR0lEIDAKI2VuZGlmCgojaWZkZWYgTk9fTlNFQwojdW5kZWYgVVNFX05TRUMKI2RlZmluZSBTVF9DVElNRV9OU0VDKHN0KSAwCiNkZWZpbmUgU1RfTVRJTUVfTlNFQyhzdCkgMAojZWxzZQojaWZkZWYgVVNFX1NUX1RJTUVTUEVDCiNkZWZpbmUgU1RfQ1RJTUVfTlNFQyhzdCkgKCh1bnNpZ25lZCBpbnQpKChzdCkuc3RfY3RpbWVzcGVjLnR2X25zZWMpKQojZGVmaW5lIFNUX01USU1FX05TRUMoc3QpICgodW5zaWduZWQgaW50KSgoc3QpLnN0X210aW1lc3BlYy50dl9uc2VjKSkKI2Vsc2UKI2RlZmluZSBTVF9DVElNRV9OU0VDKHN0KSAoKHVuc2lnbmVkIGludCkoKHN0KS5zdF9jdGltLnR2X25zZWMpKQojZGVmaW5lIFNUX01USU1FX05TRUMoc3QpICgodW5zaWduZWQgaW50KSgoc3QpLnN0X210aW0udHZfbnNlYykpCiNlbmRpZgojZW5kaWYKCiNpZmRlZiBVTlJFTElBQkxFX0ZTVEFUCiNkZWZpbmUgZnN0YXRfaXNfcmVsaWFibGUoKSAwCiNlbHNlCiNkZWZpbmUgZnN0YXRfaXNfcmVsaWFibGUoKSAxCiNlbmRpZgoKI2lmbmRlZiB2YV9jb3B5Ci8qCiAqIFNpbmNlIGFuIG9idmlvdXMgaW1wbGVtZW50YXRpb24gb2YgdmFfbGlzdCB3b3VsZCBiZSB0byBtYWtlIGl0IGEKICogcG9pbnRlciBpbnRvIHRoZSBzdGFjayBmcmFtZSwgYSBzaW1wbGUgYXNzaWdubWVudCB3aWxsIHdvcmsgb24KICogbWFueSBzeXN0ZW1zLiAgQnV0IGxldCdzIHRyeSB0byBiZSBtb3JlIHBvcnRhYmxlLgogKi8KI2lmZGVmIF9fdmFfY29weQojZGVmaW5lIHZhX2NvcHkoZHN0LCBzcmMpIF9fdmFfY29weShkc3QsIHNyYykKI2Vsc2UKI2RlZmluZSB2YV9jb3B5KGRzdCwgc3JjKSAoKGRzdCkgPSAoc3JjKSkKI2VuZGlmCiNlbmRpZgoKI2lmIGRlZmluZWQoX19HTlVDX18pIHx8IChfTVNDX1ZFUiA+PSAxNDAwKSB8fCBkZWZpbmVkKF9fQzk5X01BQ1JPX1dJVEhfVkFfQVJHUykKI2RlZmluZSBIQVZFX1ZBUklBRElDX01BQ1JPUyAxCiNlbmRpZgoKI2lmZGVmIEhBVkVfVkFSSUFESUNfTUFDUk9TCl9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAzLCA0KSkpIE5PUkVUVVJOCnZvaWQgQlVHX2ZsKGNvbnN0IGNoYXIgKmZpbGUsIGludCBsaW5lLCBjb25zdCBjaGFyICpmbXQsIC4uLik7CiNkZWZpbmUgQlVHKC4uLikgQlVHX2ZsKF9fRklMRV9fLCBfX0xJTkVfXywgX19WQV9BUkdTX18pCiNlbHNlCl9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpIE5PUkVUVVJOCnZvaWQgQlVHKGNvbnN0IGNoYXIgKmZtdCwgLi4uKTsKI2VuZGlmCgovKgogKiBQcmVzZXJ2ZXMgZXJybm8sIHByaW50cyBhIG1lc3NhZ2UsIGJ1dCBnaXZlcyBubyB3YXJuaW5nIGZvciBFTk9FTlQuCiAqIFJldHVybnMgMCBvbiBzdWNjZXNzLCB3aGljaCBpbmNsdWRlcyB0cnlpbmcgdG8gdW5saW5rIGFuIG9iamVjdCB0aGF0IGRvZXMKICogbm90IGV4aXN0LgogKi8KaW50IHVubGlua19vcl93YXJuKGNvbnN0IGNoYXIgKnBhdGgpOwogLyoKICAqIFRyaWVzIHRvIHVubGluayBmaWxlLiAgUmV0dXJucyAwIGlmIHVubGluayBzdWNjZWVkZWQKICAqIG9yIHRoZSBmaWxlIGFscmVhZHkgZGlkbid0IGV4aXN0LiAgUmV0dXJucyAtMSBhbmQKICAqIGFwcGVuZHMgYSBtZXNzYWdlIHRvIGVyciBzdWl0YWJsZSBmb3IKICAqICdlcnJvcigiJXMiLCBlcnItPmJ1ZiknIG9uIGVycm9yLgogICovCmludCB1bmxpbmtfb3JfbXNnKGNvbnN0IGNoYXIgKmZpbGUsIHN0cnVjdCBzdHJidWYgKmVycik7Ci8qCiAqIFByZXNlcnZlcyBlcnJubywgcHJpbnRzIGEgbWVzc2FnZSwgYnV0IGdpdmVzIG5vIHdhcm5pbmcgZm9yIEVOT0VOVC4KICogUmV0dXJucyAwIG9uIHN1Y2Nlc3MsIHdoaWNoIGluY2x1ZGVzIHRyeWluZyB0byByZW1vdmUgYSBkaXJlY3RvcnkgdGhhdCBkb2VzCiAqIG5vdCBleGlzdC4KICovCmludCBybWRpcl9vcl93YXJuKGNvbnN0IGNoYXIgKnBhdGgpOwovKgogKiBDYWxscyB0aGUgY29ycmVjdCBmdW5jdGlvbiBvdXQgb2Yge3VubGluayxybWRpcn1fb3Jfd2FybiBiYXNlZCBvbgogKiB0aGUgc3VwcGxpZWQgZmlsZSBtb2RlLgogKi8KaW50IHJlbW92ZV9vcl93YXJuKHVuc2lnbmVkIGludCBtb2RlLCBjb25zdCBjaGFyICpwYXRoKTsKCi8qCiAqIENhbGwgYWNjZXNzKDIpLCBidXQgd2FybiBmb3IgYW55IGVycm9yIGV4Y2VwdCAibWlzc2luZyBmaWxlIgogKiAoRU5PRU5UIG9yIEVOT1RESVIpLgogKi8KI2RlZmluZSBBQ0NFU1NfRUFDQ0VTX09LICgxVSA8PCAwKQppbnQgYWNjZXNzX29yX3dhcm4oY29uc3QgY2hhciAqcGF0aCwgaW50IG1vZGUsIHVuc2lnbmVkIGZsYWcpOwppbnQgYWNjZXNzX29yX2RpZShjb25zdCBjaGFyICpwYXRoLCBpbnQgbW9kZSwgdW5zaWduZWQgZmxhZyk7CgovKiBXYXJuIG9uIGFuIGluYWNjZXNzaWJsZSBmaWxlIGlmIGVycm5vIGluZGljYXRlcyB0aGlzIGlzIGFuIGVycm9yICovCmludCB3YXJuX29uX2ZvcGVuX2Vycm9ycyhjb25zdCBjaGFyICpwYXRoKTsKCiNpZmRlZiBHTVRJTUVfVU5SRUxJQUJMRV9FUlJPUlMKc3RydWN0IHRtICpnaXRfZ210aW1lKGNvbnN0IHRpbWVfdCAqKTsKc3RydWN0IHRtICpnaXRfZ210aW1lX3IoY29uc3QgdGltZV90ICosIHN0cnVjdCB0bSAqKTsKI2RlZmluZSBnbXRpbWUgZ2l0X2dtdGltZQojZGVmaW5lIGdtdGltZV9yIGdpdF9nbXRpbWVfcgojZW5kaWYKCiNpZiAhZGVmaW5lZChVU0VfUEFSRU5TX0FST1VORF9HRVRURVhUX04pICYmIGRlZmluZWQoX19HTlVDX18pCiNkZWZpbmUgVVNFX1BBUkVOU19BUk9VTkRfR0VUVEVYVF9OIDEKI2VuZGlmCgojaWZuZGVmIFNIRUxMX1BBVEgKIyBkZWZpbmUgU0hFTExfUEFUSCAiL2Jpbi9zaCIKI2VuZGlmCgojaWZuZGVmIF9QT1NJWF9USFJFQURfU0FGRV9GVU5DVElPTlMKI2RlZmluZSBmbG9ja2ZpbGUoZmgpCiNkZWZpbmUgZnVubG9ja2ZpbGUoZmgpCiNkZWZpbmUgZ2V0Y191bmxvY2tlZChmaCkgZ2V0YyhmaCkKI2VuZGlmCgovKgogKiBPdXIgY29kZSBvZnRlbiBvcGVucyBhIHBhdGggdG8gYW4gb3B0aW9uYWwgZmlsZSwgdG8gd29yayBvbiBpdHMKICogY29udGVudHMgd2hlbiB3ZSBjYW4gc3VjY2Vzc2Z1bGx5IG9wZW4gaXQuICBXZSBjYW4gaWdub3JlIGEgZmFpbHVyZQogKiB0byBvcGVuIGlmIHN1Y2ggYW4gb3B0aW9uYWwgZmlsZSBkb2VzIG5vdCBleGlzdCwgYnV0IHdlIGRvIHdhbnQgdG8KICogcmVwb3J0IGEgZmFpbHVyZSBpbiBvcGVuaW5nIGZvciBvdGhlciByZWFzb25zIChlLmcuIHdlIGdvdCBhbiBJL08KICogZXJyb3IsIG9yIHRoZSBmaWxlIGlzIHRoZXJlLCBidXQgd2UgbGFjayB0aGUgcGVybWlzc2lvbiB0byBvcGVuKS4KICoKICogQ2FsbCB0aGlzIGZ1bmN0aW9uIGFmdGVyIHNlZWluZyBhbiBlcnJvciBmcm9tIG9wZW4oKSBvciBmb3BlbigpIHRvCiAqIHNlZSBpZiB0aGUgZXJybm8gaW5kaWNhdGVzIGEgbWlzc2luZyBmaWxlIHRoYXQgd2UgY2FuIHNhZmVseSBpZ25vcmUuCiAqLwpzdGF0aWMgaW5saW5lIGludCBpc19taXNzaW5nX2ZpbGVfZXJyb3IoaW50IGVycm5vXykKewoJcmV0dXJuIChlcnJub18gPT0gRU5PRU5UIHx8IGVycm5vXyA9PSBFTk9URElSKTsKfQoKZXh0ZXJuIGludCBjbWRfbWFpbihpbnQsIGNvbnN0IGNoYXIgKiopOwoKLyoKICogWW91IGNhbiBtYXJrIGEgc3RhY2sgdmFyaWFibGUgd2l0aCBVTkxFQUsodmFyKSB0byBhdm9pZCBpdCBiZWluZwogKiByZXBvcnRlZCBhcyBhIGxlYWsgYnkgdG9vbHMgbGlrZSBMU0FOIG9yIHZhbGdyaW5kLiBUaGUgYXJndW1lbnQKICogc2hvdWxkIGdlbmVyYWxseSBiZSB0aGUgdmFyaWFibGUgaXRzZWxmIChub3QgaXRzIGFkZHJlc3MgYW5kIG5vdCB3aGF0CiAqIGl0IHBvaW50cyB0bykuIEl0J3Mgc2FmZSB0byB1c2UgdGhpcyBvbiBwb2ludGVycyB3aGljaCBtYXkgYWxyZWFkeQogKiBoYXZlIGJlZW4gZnJlZWQsIG9yIG9uIHBvaW50ZXJzIHdoaWNoIG1heSBzdGlsbCBiZSBpbiB1c2UuCiAqCiAqIFVzZSB0aGlzIF9vbmx5XyBmb3IgYSB2YXJpYWJsZSB0aGF0IGxlYWtzIGJ5IGdvaW5nIG91dCBvZiBzY29wZSBhdAogKiBwcm9ncmFtIGV4aXQgKHNvIG9ubHkgZnJvbSBjbWRfKiBmdW5jdGlvbnMgb3IgdGhlaXIgZGlyZWN0IGhlbHBlcnMpLgogKiBOb3JtYWwgZnVuY3Rpb25zLCBlc3BlY2lhbGx5IHRob3NlIHdoaWNoIG1heSBiZSBjYWxsZWQgbXVsdGlwbGUKICogdGltZXMsIHNob3VsZCBhY3R1YWxseSBmcmVlIHRoZWlyIG1lbW9yeS4gVGhpcyBpcyBvbmx5IG1lYW50IGFzCiAqIGFuIGFubm90YXRpb24sIGFuZCBkb2VzIG5vdGhpbmcgaW4gbm9uLWxlYWstY2hlY2tpbmcgYnVpbGRzLgogKi8KI2lmZGVmIFNVUFBSRVNTX0FOTk9UQVRFRF9MRUFLUwpleHRlcm4gdm9pZCB1bmxlYWtfbWVtb3J5KGNvbnN0IHZvaWQgKnB0ciwgc2l6ZV90IGxlbik7CiNkZWZpbmUgVU5MRUFLKHZhcikgdW5sZWFrX21lbW9yeSgmKHZhciksIHNpemVvZih2YXIpKTsKI2Vsc2UKI2RlZmluZSBVTkxFQUsodmFyKQojZW5kaWYKCiNlbmRpZgo=",
    "text": "#ifndef GIT_COMPAT_UTIL_H\n#define GIT_COMPAT_UTIL_H\n\n#define _FILE_OFFSET_BITS 64\n\n\n/* Derived from Linux \"Features Test Macro\" header\n * Convenience macros to test the versions of gcc (or\n * a compatible compiler).\n * Use them like this:\n *  #if GIT_GNUC_PREREQ (2,8)\n *   ... code requiring gcc 2.8 or later ...\n *  #endif\n*/\n#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n# define GIT_GNUC_PREREQ(maj, min) \\\n\t((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))\n#else\n #define GIT_GNUC_PREREQ(maj, min) 0\n#endif\n\n\n#ifndef FLEX_ARRAY\n/*\n * See if our compiler is known to support flexible array members.\n */\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && (!defined(__SUNPRO_C) || (__SUNPRO_C > 0x580))\n# define FLEX_ARRAY /* empty */\n#elif defined(__GNUC__)\n# if (__GNUC__ >= 3)\n#  define FLEX_ARRAY /* empty */\n# else\n#  define FLEX_ARRAY 0 /* older GNU extension */\n# endif\n#endif\n\n/*\n * Otherwise, default to safer but a bit wasteful traditional style\n */\n#ifndef FLEX_ARRAY\n# define FLEX_ARRAY 1\n#endif\n#endif\n\n\n/*\n * BUILD_ASSERT_OR_ZERO - assert a build-time dependency, as an expression.\n * @cond: the compile-time condition which must be true.\n *\n * Your compile will fail if the condition isn't true, or can't be evaluated\n * by the compiler.  This can be used in an expression: its value is \"0\".\n *\n * Example:\n *\t#define foo_to_char(foo)\t\t\t\t\t\\\n *\t\t ((char *)(foo)\t\t\t\t\t\t\\\n *\t\t  + BUILD_ASSERT_OR_ZERO(offsetof(struct foo, string) == 0))\n */\n#define BUILD_ASSERT_OR_ZERO(cond) \\\n\t(sizeof(char [1 - 2*!(cond)]) - 1)\n\n#if GIT_GNUC_PREREQ(3, 1)\n /* &arr[0] degrades to a pointer: a different type from an array */\n# define BARF_UNLESS_AN_ARRAY(arr)\t\t\t\t\t\t\\\n\tBUILD_ASSERT_OR_ZERO(!__builtin_types_compatible_p(__typeof__(arr), \\\n\t\t\t\t\t\t\t   __typeof__(&(arr)[0])))\n#else\n# define BARF_UNLESS_AN_ARRAY(arr) 0\n#endif\n/*\n * ARRAY_SIZE - get the number of elements in a visible array\n *  <at> x: the array whose size you want.\n *\n * This does not work on pointers, or arrays declared as [], or\n * function parameters.  With correct compiler support, such usage\n * will cause a build error (see the build_assert_or_zero macro).\n */\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]) + BARF_UNLESS_AN_ARRAY(x))\n\n#define bitsizeof(x)  (CHAR_BIT * sizeof(x))\n\n#define maximum_signed_value_of_type(a) \\\n    (INTMAX_MAX >> (bitsizeof(intmax_t) - bitsizeof(a)))\n\n#define maximum_unsigned_value_of_type(a) \\\n    (UINTMAX_MAX >> (bitsizeof(uintmax_t) - bitsizeof(a)))\n\n/*\n * Signed integer overflow is undefined in C, so here's a helper macro\n * to detect if the sum of two integers will overflow.\n *\n * Requires: a >= 0, typeof(a) equals typeof(b)\n */\n#define signed_add_overflows(a, b) \\\n    ((b) > maximum_signed_value_of_type(a) - (a))\n\n#define unsigned_add_overflows(a, b) \\\n    ((b) > maximum_unsigned_value_of_type(a) - (a))\n\n/*\n * Returns true if the multiplication of \"a\" and \"b\" will\n * overflow. The types of \"a\" and \"b\" must match and must be unsigned.\n * Note that this macro evaluates \"a\" twice!\n */\n#define unsigned_mult_overflows(a, b) \\\n    ((a) && (b) > maximum_unsigned_value_of_type(a) / (a))\n\n#ifdef __GNUC__\n#define TYPEOF(x) (__typeof__(x))\n#else\n#define TYPEOF(x)\n#endif\n\n#define MSB(x, bits) ((x) & TYPEOF(x)(~0ULL << (bitsizeof(x) - (bits))))\n#define HAS_MULTI_BITS(i)  ((i) & ((i) - 1))  /* checks if an integer has more than 1 bit set */\n\n#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))\n\n/* Approximation of the length of the decimal representation of this type. */\n#define decimal_length(x)\t((int)(sizeof(x) * 2.56 + 0.5) + 1)\n\n#if defined(__sun__)\n /*\n  * On Solaris, when _XOPEN_EXTENDED is set, its header file\n  * forces the programs to be XPG4v2, defeating any _XOPEN_SOURCE\n  * setting to say we are XPG5 or XPG6.  Also on Solaris,\n  * XPG6 programs must be compiled with a c99 compiler, while\n  * non XPG6 programs must be compiled with a pre-c99 compiler.\n  */\n# if __STDC_VERSION__ - 0 >= 199901L\n# define _XOPEN_SOURCE 600\n# else\n# define _XOPEN_SOURCE 500\n# endif\n#elif !defined(__APPLE__) && !defined(__FreeBSD__) && !defined(__USLC__) && \\\n      !defined(_M_UNIX) && !defined(__sgi) && !defined(__DragonFly__) && \\\n      !defined(__TANDEM) && !defined(__QNX__) && !defined(__MirBSD__) && \\\n      !defined(__CYGWIN__)\n#define _XOPEN_SOURCE 600 /* glibc2 and AIX 5.3L need 500, OpenBSD needs 600 for S_ISLNK() */\n#define _XOPEN_SOURCE_EXTENDED 1 /* AIX 5.3L needs this */\n#endif\n#define _ALL_SOURCE 1\n#define _GNU_SOURCE 1\n#define _BSD_SOURCE 1\n#define _DEFAULT_SOURCE 1\n#define _NETBSD_SOURCE 1\n#define _SGI_SOURCE 1\n\n#if defined(WIN32) && !defined(__CYGWIN__) /* Both MinGW and MSVC */\n# if defined (_MSC_VER) && !defined(_WIN32_WINNT)\n#  define _WIN32_WINNT 0x0502\n# endif\n#define WIN32_LEAN_AND_MEAN  /* stops windows.h including winsock.h */\n#include <winsock2.h>\n#include <windows.h>\n#define GIT_WINDOWS_NATIVE\n#endif\n\n#include <unistd.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#ifdef HAVE_STRINGS_H\n#include <strings.h> /* for strcasecmp() */\n#endif\n#include <errno.h>\n#include <limits.h>\n#ifdef NEEDS_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n#include <sys/types.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <time.h>\n#include <signal.h>\n#include <assert.h>\n#include <regex.h>\n#include <utime.h>\n#include <syslog.h>\n#ifndef NO_SYS_POLL_H\n#include <sys/poll.h>\n#else\n#include <poll.h>\n#endif\n#ifdef HAVE_BSD_SYSCTL\n#include <sys/sysctl.h>\n#endif\n\n#if defined(__CYGWIN__)\n#include \"compat/cygwin.h\"\n#endif\n#if defined(__MINGW32__)\n/* pull in Windows compatibility stuff */\n#include \"compat/mingw.h\"\n#elif defined(_MSC_VER)\n#include \"compat/msvc.h\"\n#else\n#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#ifndef NO_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <pwd.h>\n#include <sys/un.h>\n#ifndef NO_INTTYPES_H\n#include <inttypes.h>\n#else\n#include <stdint.h>\n#endif\n#ifdef NO_INTPTR_T\n/*\n * On I16LP32, ILP32 and LP64 \"long\" is the save bet, however\n * on LLP86, IL33LLP64 and P64 it needs to be \"long long\",\n * while on IP16 and IP16L32 it is \"int\" (resp. \"short\")\n * Size needs to match (or exceed) 'sizeof(void *)'.\n * We can't take \"long long\" here as not everybody has it.\n */\ntypedef long intptr_t;\ntypedef unsigned long uintptr_t;\n#endif\n#undef _ALL_SOURCE /* AIX 5.3L defines a struct list with _ALL_SOURCE. */\n#include <grp.h>\n#define _ALL_SOURCE 1\n#endif\n\n/* used on Mac OS X */\n#ifdef PRECOMPOSE_UNICODE\n#include \"compat/precompose_utf8.h\"\n#else\n#define precompose_str(in,i_nfd2nfc)\n#define precompose_argv(c,v)\n#define probe_utf8_pathname_composition()\n#endif\n\n#ifdef MKDIR_WO_TRAILING_SLASH\n#define mkdir(a,b) compat_mkdir_wo_trailing_slash((a),(b))\nextern int compat_mkdir_wo_trailing_slash(const char*, mode_t);\n#endif\n\n#ifdef NO_STRUCT_ITIMERVAL\nstruct itimerval {\n\tstruct timeval it_interval;\n\tstruct timeval it_value;\n};\n#endif\n\n#ifdef NO_SETITIMER\n#define setitimer(which,value,ovalue)\n#endif\n\n#ifndef NO_LIBGEN_H\n#include <libgen.h>\n#else\n#define basename gitbasename\nextern char *gitbasename(char *);\n#define dirname gitdirname\nextern char *gitdirname(char *);\n#endif\n\n#ifndef NO_ICONV\n#include <iconv.h>\n#endif\n\n#ifndef NO_OPENSSL\n#ifdef __APPLE__\n#define __AVAILABILITY_MACROS_USES_AVAILABILITY 0\n#include <AvailabilityMacros.h>\n#undef DEPRECATED_ATTRIBUTE\n#define DEPRECATED_ATTRIBUTE\n#undef __AVAILABILITY_MACROS_USES_AVAILABILITY\n#endif\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#endif\n\n/* On most systems <netdb.h> would have given us this, but\n * not on some systems (e.g. z/OS).\n */\n#ifndef NI_MAXHOST\n#define NI_MAXHOST 1025\n#endif\n\n#ifndef NI_MAXSERV\n#define NI_MAXSERV 32\n#endif\n\n/* On most systems <limits.h> would have given us this, but\n * not on some systems (e.g. GNU/Hurd).\n */\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\n#ifndef PRIuMAX\n#define PRIuMAX \"llu\"\n#endif\n\n#ifndef SCNuMAX\n#define SCNuMAX PRIuMAX\n#endif\n\n#ifndef PRIu32\n#define PRIu32 \"u\"\n#endif\n\n#ifndef PRIx32\n#define PRIx32 \"x\"\n#endif\n\n#ifndef PRIo32\n#define PRIo32 \"o\"\n#endif\n\ntypedef uintmax_t timestamp_t;\n#define PRItime PRIuMAX\n#define parse_timestamp strtoumax\n#define TIME_MAX UINTMAX_MAX\n\n#ifndef PATH_SEP\n#define PATH_SEP ':'\n#endif\n\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n#ifndef _PATH_DEFPATH\n#define _PATH_DEFPATH \"/usr/local/bin:/usr/bin:/bin\"\n#endif\n\n#ifndef has_dos_drive_prefix\nstatic inline int git_has_dos_drive_prefix(const char *path)\n{\n\treturn 0;\n}\n#define has_dos_drive_prefix git_has_dos_drive_prefix\n#endif\n\n#ifndef skip_dos_drive_prefix\nstatic inline int git_skip_dos_drive_prefix(char **path)\n{\n\treturn 0;\n}\n#define skip_dos_drive_prefix git_skip_dos_drive_prefix\n#endif\n\n#ifndef is_dir_sep\nstatic inline int git_is_dir_sep(int c)\n{\n\treturn c == '/';\n}\n#define is_dir_sep git_is_dir_sep\n#endif\n\n#ifndef offset_1st_component\nstatic inline int git_offset_1st_component(const char *path)\n{\n\treturn is_dir_sep(path[0]);\n}\n#define offset_1st_component git_offset_1st_component\n#endif\n\n#ifndef find_last_dir_sep\nstatic inline char *git_find_last_dir_sep(const char *path)\n{\n\treturn strrchr(path, '/');\n}\n#define find_last_dir_sep git_find_last_dir_sep\n#endif\n\n#if defined(__HP_cc) && (__HP_cc >= 61000)\n#define NORETURN __attribute__((noreturn))\n#define NORETURN_PTR\n#elif defined(__GNUC__) && !defined(NO_NORETURN)\n#define NORETURN __attribute__((__noreturn__))\n#define NORETURN_PTR __attribute__((__noreturn__))\n#elif defined(_MSC_VER)\n#define NORETURN __declspec(noreturn)\n#define NORETURN_PTR\n#else\n#define NORETURN\n#define NORETURN_PTR\n#ifndef __GNUC__\n#ifndef __attribute__\n#define __attribute__(x)\n#endif\n#endif\n#endif\n\n/* The sentinel attribute is valid from gcc version 4.0 */\n#if defined(__GNUC__) && (__GNUC__ >= 4)\n#define LAST_ARG_MUST_BE_NULL __attribute__((sentinel))\n#else\n#define LAST_ARG_MUST_BE_NULL\n#endif\n\n#include \"compat/bswap.h\"\n\n#include \"wildmatch.h\"\n\nstruct strbuf;\n\n/* General helper functions */\nextern void vreportf(const char *prefix, const char *err, va_list params);\nextern NORETURN void usage(const char *err);\nextern NORETURN void usagef(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern NORETURN void die(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern NORETURN void die_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern int error(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern int error_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern void warning(const char *err, ...) __attribute__((format (printf, 1, 2)));\nextern void warning_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));\n\n#ifndef NO_OPENSSL\n#ifdef APPLE_COMMON_CRYPTO\n#include \"compat/apple-common-crypto.h\"\n#else\n#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#endif /* APPLE_COMMON_CRYPTO */\n#include <openssl/x509v3.h>\n#endif /* NO_OPENSSL */\n\n/*\n * Let callers be aware of the constant return value; this can help\n * gcc with -Wuninitialized analysis. We restrict this trick to gcc, though,\n * because some compilers may not support variadic macros. Since we're only\n * trying to help gcc, anyway, it's OK; other compilers will fall back to\n * using the function as usual.\n */\n#if defined(__GNUC__)\nstatic inline int const_error(void)\n{\n\treturn -1;\n}\n#define error(...) (error(__VA_ARGS__), const_error())\n#define error_errno(...) (error_errno(__VA_ARGS__), const_error())\n#endif\n\nextern void set_die_routine(NORETURN_PTR void (*routine)(const char *err, va_list params));\nextern void set_error_routine(void (*routine)(const char *err, va_list params));\nextern void (*get_error_routine(void))(const char *err, va_list params);\nextern void set_warn_routine(void (*routine)(const char *warn, va_list params));\nextern void (*get_warn_routine(void))(const char *warn, va_list params);\nextern void set_die_is_recursing_routine(int (*routine)(void));\n\nextern int starts_with(const char *str, const char *prefix);\n\n/*\n * If the string \"str\" begins with the string found in \"prefix\", return 1.\n * The \"out\" parameter is set to \"str + strlen(prefix)\" (i.e., to the point in\n * the string right after the prefix).\n *\n * Otherwise, return 0 and leave \"out\" untouched.\n *\n * Examples:\n *\n *   [extract branch name, fail if not a branch]\n *   if (!skip_prefix(ref, \"refs/heads/\", &branch)\n *\treturn -1;\n *\n *   [skip prefix if present, otherwise use whole string]\n *   skip_prefix(name, \"refs/heads/\", &name);\n */\nstatic inline int skip_prefix(const char *str, const char *prefix,\n\t\t\t      const char **out)\n{\n\tdo {\n\t\tif (!*prefix) {\n\t\t\t*out = str;\n\t\t\treturn 1;\n\t\t}\n\t} while (*str++ == *prefix++);\n\treturn 0;\n}\n\n/*\n * Like skip_prefix, but promises never to read past \"len\" bytes of the input\n * buffer, and returns the remaining number of bytes in \"out\" via \"outlen\".\n */\nstatic inline int skip_prefix_mem(const char *buf, size_t len,\n\t\t\t\t  const char *prefix,\n\t\t\t\t  const char **out, size_t *outlen)\n{\n\tsize_t prefix_len = strlen(prefix);\n\tif (prefix_len <= len && !memcmp(buf, prefix, prefix_len)) {\n\t\t*out = buf + prefix_len;\n\t\t*outlen = len - prefix_len;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * If buf ends with suffix, return 1 and subtract the length of the suffix\n * from *len. Otherwise, return 0 and leave *len untouched.\n */\nstatic inline int strip_suffix_mem(const char *buf, size_t *len,\n\t\t\t\t   const char *suffix)\n{\n\tsize_t suflen = strlen(suffix);\n\tif (*len < suflen || memcmp(buf + (*len - suflen), suffix, suflen))\n\t\treturn 0;\n\t*len -= suflen;\n\treturn 1;\n}\n\n/*\n * If str ends with suffix, return 1 and set *len to the size of the string\n * without the suffix. Otherwise, return 0 and set *len to the size of the\n * string.\n *\n * Note that we do _not_ NUL-terminate str to the new length.\n */\nstatic inline int strip_suffix(const char *str, const char *suffix, size_t *len)\n{\n\t*len = strlen(str);\n\treturn strip_suffix_mem(str, len, suffix);\n}\n\nstatic inline int ends_with(const char *str, const char *suffix)\n{\n\tsize_t len;\n\treturn strip_suffix(str, suffix, &len);\n}\n\n#define SWAP(a, b) do {\t\t\t\t\t\t\\\n\tvoid *_swap_a_ptr = &(a);\t\t\t\t\\\n\tvoid *_swap_b_ptr = &(b);\t\t\t\t\\\n\tunsigned char _swap_buffer[sizeof(a)];\t\t\t\\\n\tmemcpy(_swap_buffer, _swap_a_ptr, sizeof(a));\t\t\\\n\tmemcpy(_swap_a_ptr, _swap_b_ptr, sizeof(a) +\t\t\\\n\t       BUILD_ASSERT_OR_ZERO(sizeof(a) == sizeof(b)));\t\\\n\tmemcpy(_swap_b_ptr, _swap_buffer, sizeof(a));\t\t\\\n} while (0)\n\n#if defined(NO_MMAP) || defined(USE_WIN32_MMAP)\n\n#ifndef PROT_READ\n#define PROT_READ 1\n#define PROT_WRITE 2\n#define MAP_PRIVATE 1\n#endif\n\n#define mmap git_mmap\n#define munmap git_munmap\nextern void *git_mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nextern int git_munmap(void *start, size_t length);\n\n#else /* NO_MMAP || USE_WIN32_MMAP */\n\n#include <sys/mman.h>\n\n#endif /* NO_MMAP || USE_WIN32_MMAP */\n\n#ifdef NO_MMAP\n\n/* This value must be multiple of (pagesize * 2) */\n#define DEFAULT_PACKED_GIT_WINDOW_SIZE (1 * 1024 * 1024)\n\n#else /* NO_MMAP */\n\n/* This value must be multiple of (pagesize * 2) */\n#define DEFAULT_PACKED_GIT_WINDOW_SIZE \\\n\t(sizeof(void*) >= 8 \\\n\t\t?  1 * 1024 * 1024 * 1024 \\\n\t\t: 32 * 1024 * 1024)\n\n#endif /* NO_MMAP */\n\n#ifndef MAP_FAILED\n#define MAP_FAILED ((void *)-1)\n#endif\n\n#ifdef NO_ST_BLOCKS_IN_STRUCT_STAT\n#define on_disk_bytes(st) ((st).st_size)\n#else\n#define on_disk_bytes(st) ((st).st_blocks * 512)\n#endif\n\n#ifdef NEEDS_MODE_TRANSLATION\n#undef S_IFMT\n#undef S_IFREG\n#undef S_IFDIR\n#undef S_IFLNK\n#undef S_IFBLK\n#undef S_IFCHR\n#undef S_IFIFO\n#undef S_IFSOCK\n#define S_IFMT   0170000\n#define S_IFREG  0100000\n#define S_IFDIR  0040000\n#define S_IFLNK  0120000\n#define S_IFBLK  0060000\n#define S_IFCHR  0020000\n#define S_IFIFO  0010000\n#define S_IFSOCK 0140000\n#ifdef stat\n#undef stat\n#endif\n#define stat(path, buf) git_stat(path, buf)\nextern int git_stat(const char *, struct stat *);\n#ifdef fstat\n#undef fstat\n#endif\n#define fstat(fd, buf) git_fstat(fd, buf)\nextern int git_fstat(int, struct stat *);\n#ifdef lstat\n#undef lstat\n#endif\n#define lstat(path, buf) git_lstat(path, buf)\nextern int git_lstat(const char *, struct stat *);\n#endif\n\n#define DEFAULT_PACKED_GIT_LIMIT \\\n\t((1024L * 1024L) * (size_t)(sizeof(void*) >= 8 ? (32 * 1024L * 1024L) : 256))\n\n#ifdef NO_PREAD\n#define pread git_pread\nextern ssize_t git_pread(int fd, void *buf, size_t count, off_t offset);\n#endif\n/*\n * Forward decl that will remind us if its twin in cache.h changes.\n * This function is used in compat/pread.c.  But we can't include\n * cache.h there.\n */\nextern ssize_t read_in_full(int fd, void *buf, size_t count);\n\n#ifdef NO_SETENV\n#define setenv gitsetenv\nextern int gitsetenv(const char *, const char *, int);\n#endif\n\n#ifdef NO_MKDTEMP\n#define mkdtemp gitmkdtemp\nextern char *gitmkdtemp(char *);\n#endif\n\n#ifdef NO_UNSETENV\n#define unsetenv gitunsetenv\nextern void gitunsetenv(const char *);\n#endif\n\n#ifdef NO_STRCASESTR\n#define strcasestr gitstrcasestr\nextern char *gitstrcasestr(const char *haystack, const char *needle);\n#endif\n\n#ifdef NO_STRLCPY\n#define strlcpy gitstrlcpy\nextern size_t gitstrlcpy(char *, const char *, size_t);\n#endif\n\n#ifdef NO_STRTOUMAX\n#define strtoumax gitstrtoumax\nextern uintmax_t gitstrtoumax(const char *, char **, int);\n#define strtoimax gitstrtoimax\nextern intmax_t gitstrtoimax(const char *, char **, int);\n#endif\n\n#ifdef NO_HSTRERROR\n#define hstrerror githstrerror\nextern const char *githstrerror(int herror);\n#endif\n\n#ifdef NO_MEMMEM\n#define memmem gitmemmem\nvoid *gitmemmem(const void *haystack, size_t haystacklen,\n                const void *needle, size_t needlelen);\n#endif\n\n#ifdef OVERRIDE_STRDUP\n#ifdef strdup\n#undef strdup\n#endif\n#define strdup gitstrdup\nchar *gitstrdup(const char *s);\n#endif\n\n#ifdef NO_GETPAGESIZE\n#define getpagesize() sysconf(_SC_PAGESIZE)\n#endif\n\n#ifndef O_CLOEXEC\n#define O_CLOEXEC 0\n#endif\n\n#ifdef FREAD_READS_DIRECTORIES\n# if !defined(SUPPRESS_FOPEN_REDEFINITION)\n#  ifdef fopen\n#   undef fopen\n#  endif\n#  define fopen(a,b) git_fopen(a,b)\n# endif\nextern FILE *git_fopen(const char*, const char*);\n#endif\n\n#ifdef SNPRINTF_RETURNS_BOGUS\n#ifdef snprintf\n#undef snprintf\n#endif\n#define snprintf git_snprintf\nextern int git_snprintf(char *str, size_t maxsize,\n\t\t\tconst char *format, ...);\n#ifdef vsnprintf\n#undef vsnprintf\n#endif\n#define vsnprintf git_vsnprintf\nextern int git_vsnprintf(char *str, size_t maxsize,\n\t\t\t const char *format, va_list ap);\n#endif\n\n#ifdef __GLIBC_PREREQ\n#if __GLIBC_PREREQ(2, 1)\n#define HAVE_STRCHRNUL\n#endif\n#endif\n\n#ifndef HAVE_STRCHRNUL\n#define strchrnul gitstrchrnul\nstatic inline char *gitstrchrnul(const char *s, int c)\n{\n\twhile (*s && *s != c)\n\t\ts++;\n\treturn (char *)s;\n}\n#endif\n\n#ifdef NO_INET_PTON\nint inet_pton(int af, const char *src, void *dst);\n#endif\n\n#ifdef NO_INET_NTOP\nconst char *inet_ntop(int af, const void *src, char *dst, size_t size);\n#endif\n\n#ifdef NO_PTHREADS\n#define atexit git_atexit\nextern int git_atexit(void (*handler)(void));\n#endif\n\ntypedef void (*try_to_free_t)(size_t);\nextern try_to_free_t set_try_to_free_routine(try_to_free_t);\n\nstatic inline size_t st_add(size_t a, size_t b)\n{\n\tif (unsigned_add_overflows(a, b))\n\t\tdie(\"size_t overflow: %\"PRIuMAX\" + %\"PRIuMAX,\n\t\t    (uintmax_t)a, (uintmax_t)b);\n\treturn a + b;\n}\n#define st_add3(a,b,c)   st_add(st_add((a),(b)),(c))\n#define st_add4(a,b,c,d) st_add(st_add3((a),(b),(c)),(d))\n\nstatic inline size_t st_mult(size_t a, size_t b)\n{\n\tif (unsigned_mult_overflows(a, b))\n\t\tdie(\"size_t overflow: %\"PRIuMAX\" * %\"PRIuMAX,\n\t\t    (uintmax_t)a, (uintmax_t)b);\n\treturn a * b;\n}\n\nstatic inline size_t st_sub(size_t a, size_t b)\n{\n\tif (a < b)\n\t\tdie(\"size_t underflow: %\"PRIuMAX\" - %\"PRIuMAX,\n\t\t    (uintmax_t)a, (uintmax_t)b);\n\treturn a - b;\n}\n\n#ifdef HAVE_ALLOCA_H\n# include <alloca.h>\n# define xalloca(size)      (alloca(size))\n# define xalloca_free(p)    do {} while (0)\n#else\n# define xalloca(size)      (xmalloc(size))\n# define xalloca_free(p)    (free(p))\n#endif\nextern char *xstrdup(const char *str);\nextern void *xmalloc(size_t size);\nextern void *xmallocz(size_t size);\nextern void *xmallocz_gently(size_t size);\nextern void *xmemdupz(const void *data, size_t len);\nextern char *xstrndup(const char *str, size_t len);\nextern void *xrealloc(void *ptr, size_t size);\nextern void *xcalloc(size_t nmemb, size_t size);\nextern void *xmmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nextern void *xmmap_gently(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nextern int xopen(const char *path, int flags, ...);\nextern ssize_t xread(int fd, void *buf, size_t len);\nextern ssize_t xwrite(int fd, const void *buf, size_t len);\nextern ssize_t xpread(int fd, void *buf, size_t len, off_t offset);\nextern int xdup(int fd);\nextern FILE *xfopen(const char *path, const char *mode);\nextern FILE *xfdopen(int fd, const char *mode);\nextern int xmkstemp(char *template);\nextern int xmkstemp_mode(char *template, int mode);\nextern char *xgetcwd(void);\nextern FILE *fopen_for_writing(const char *path);\nextern FILE *fopen_or_warn(const char *path, const char *mode);\n\n/*\n * FREE_AND_NULL(ptr) is like free(ptr) followed by ptr = NULL. Note\n * that ptr is used twice, so don't pass e.g. ptr++.\n */\n#define FREE_AND_NULL(p) do { free(p); (p) = NULL; } while (0)\n\n#define ALLOC_ARRAY(x, alloc) (x) = xmalloc(st_mult(sizeof(*(x)), (alloc)))\n#define REALLOC_ARRAY(x, alloc) (x) = xrealloc((x), st_mult(sizeof(*(x)), (alloc)))\n\n#define COPY_ARRAY(dst, src, n) copy_array((dst), (src), (n), sizeof(*(dst)) + \\\n\tBUILD_ASSERT_OR_ZERO(sizeof(*(dst)) == sizeof(*(src))))\nstatic inline void copy_array(void *dst, const void *src, size_t n, size_t size)\n{\n\tif (n)\n\t\tmemcpy(dst, src, st_mult(size, n));\n}\n\n#define MOVE_ARRAY(dst, src, n) move_array((dst), (src), (n), sizeof(*(dst)) + \\\n\tBUILD_ASSERT_OR_ZERO(sizeof(*(dst)) == sizeof(*(src))))\nstatic inline void move_array(void *dst, const void *src, size_t n, size_t size)\n{\n\tif (n)\n\t\tmemmove(dst, src, st_mult(size, n));\n}\n\n/*\n * These functions help you allocate structs with flex arrays, and copy\n * the data directly into the array. For example, if you had:\n *\n *   struct foo {\n *     int bar;\n *     char name[FLEX_ARRAY];\n *   };\n *\n * you can do:\n *\n *   struct foo *f;\n *   FLEX_ALLOC_MEM(f, name, src, len);\n *\n * to allocate a \"foo\" with the contents of \"src\" in the \"name\" field.\n * The resulting struct is automatically zero'd, and the flex-array field\n * is NUL-terminated (whether the incoming src buffer was or not).\n *\n * The FLEXPTR_* variants operate on structs that don't use flex-arrays,\n * but do want to store a pointer to some extra data in the same allocated\n * block. For example, if you have:\n *\n *   struct foo {\n *     char *name;\n *     int bar;\n *   };\n *\n * you can do:\n *\n *   struct foo *f;\n *   FLEXPTR_ALLOC_STR(f, name, src);\n *\n * and \"name\" will point to a block of memory after the struct, which will be\n * freed along with the struct (but the pointer can be repointed anywhere).\n *\n * The *_STR variants accept a string parameter rather than a ptr/len\n * combination.\n *\n * Note that these macros will evaluate the first parameter multiple\n * times, and it must be assignable as an lvalue.\n */\n#define FLEX_ALLOC_MEM(x, flexname, buf, len) do { \\\n\tsize_t flex_array_len_ = (len); \\\n\t(x) = xcalloc(1, st_add3(sizeof(*(x)), flex_array_len_, 1)); \\\n\tmemcpy((void *)(x)->flexname, (buf), flex_array_len_); \\\n} while (0)\n#define FLEXPTR_ALLOC_MEM(x, ptrname, buf, len) do { \\\n\tsize_t flex_array_len_ = (len); \\\n\t(x) = xcalloc(1, st_add3(sizeof(*(x)), flex_array_len_, 1)); \\\n\tmemcpy((x) + 1, (buf), flex_array_len_); \\\n\t(x)->ptrname = (void *)((x)+1); \\\n} while(0)\n#define FLEX_ALLOC_STR(x, flexname, str) \\\n\tFLEX_ALLOC_MEM((x), flexname, (str), strlen(str))\n#define FLEXPTR_ALLOC_STR(x, ptrname, str) \\\n\tFLEXPTR_ALLOC_MEM((x), ptrname, (str), strlen(str))\n\nstatic inline char *xstrdup_or_null(const char *str)\n{\n\treturn str ? xstrdup(str) : NULL;\n}\n\nstatic inline size_t xsize_t(off_t len)\n{\n\tif (len > (size_t) len)\n\t\tdie(\"Cannot handle files this big\");\n\treturn (size_t)len;\n}\n\n__attribute__((format (printf, 3, 4)))\nextern int xsnprintf(char *dst, size_t max, const char *fmt, ...);\n\n#ifndef HOST_NAME_MAX\n#define HOST_NAME_MAX 256\n#endif\n\nextern int xgethostname(char *buf, size_t len);\n\n/* in ctype.c, for kwset users */\nextern const unsigned char tolower_trans_tbl[256];\n\n/* Sane ctype - no locale, and works with signed chars */\n#undef isascii\n#undef isspace\n#undef isdigit\n#undef isalpha\n#undef isalnum\n#undef isprint\n#undef islower\n#undef isupper\n#undef tolower\n#undef toupper\n#undef iscntrl\n#undef ispunct\n#undef isxdigit\n\nextern const unsigned char sane_ctype[256];\n#define GIT_SPACE 0x01\n#define GIT_DIGIT 0x02\n#define GIT_ALPHA 0x04\n#define GIT_GLOB_SPECIAL 0x08\n#define GIT_REGEX_SPECIAL 0x10\n#define GIT_PATHSPEC_MAGIC 0x20\n#define GIT_CNTRL 0x40\n#define GIT_PUNCT 0x80\n#define sane_istest(x,mask) ((sane_ctype[(unsigned char)(x)] & (mask)) != 0)\n#define isascii(x) (((x) & ~0x7f) == 0)\n#define isspace(x) sane_istest(x,GIT_SPACE)\n#define isdigit(x) sane_istest(x,GIT_DIGIT)\n#define isalpha(x) sane_istest(x,GIT_ALPHA)\n#define isalnum(x) sane_istest(x,GIT_ALPHA | GIT_DIGIT)\n#define isprint(x) ((x) >= 0x20 && (x) <= 0x7e)\n#define islower(x) sane_iscase(x, 1)\n#define isupper(x) sane_iscase(x, 0)\n#define is_glob_special(x) sane_istest(x,GIT_GLOB_SPECIAL)\n#define is_regex_special(x) sane_istest(x,GIT_GLOB_SPECIAL | GIT_REGEX_SPECIAL)\n#define iscntrl(x) (sane_istest(x,GIT_CNTRL))\n#define ispunct(x) sane_istest(x, GIT_PUNCT | GIT_REGEX_SPECIAL | \\\n\t\tGIT_GLOB_SPECIAL | GIT_PATHSPEC_MAGIC)\n#define isxdigit(x) (hexval_table[(unsigned char)(x)] != -1)\n#define tolower(x) sane_case((unsigned char)(x), 0x20)\n#define toupper(x) sane_case((unsigned char)(x), 0)\n#define is_pathspec_magic(x) sane_istest(x,GIT_PATHSPEC_MAGIC)\n\nstatic inline int sane_case(int x, int high)\n{\n\tif (sane_istest(x, GIT_ALPHA))\n\t\tx = (x & ~0x20) | high;\n\treturn x;\n}\n\nstatic inline int sane_iscase(int x, int is_lower)\n{\n\tif (!sane_istest(x, GIT_ALPHA))\n\t\treturn 0;\n\n\tif (is_lower)\n\t\treturn (x & 0x20) != 0;\n\telse\n\t\treturn (x & 0x20) == 0;\n}\n\nstatic inline int strtoul_ui(char const *s, int base, unsigned int *result)\n{\n\tunsigned long ul;\n\tchar *p;\n\n\terrno = 0;\n\t/* negative values would be accepted by strtoul */\n\tif (strchr(s, '-'))\n\t\treturn -1;\n\tul = strtoul(s, &p, base);\n\tif (errno || *p || p == s || (unsigned int) ul != ul)\n\t\treturn -1;\n\t*result = ul;\n\treturn 0;\n}\n\nstatic inline int strtol_i(char const *s, int base, int *result)\n{\n\tlong ul;\n\tchar *p;\n\n\terrno = 0;\n\tul = strtol(s, &p, base);\n\tif (errno || *p || p == s || (int) ul != ul)\n\t\treturn -1;\n\t*result = ul;\n\treturn 0;\n}\n\n#ifdef INTERNAL_QSORT\nvoid git_qsort(void *base, size_t nmemb, size_t size,\n\t       int(*compar)(const void *, const void *));\n#define qsort git_qsort\n#endif\n\n#define QSORT(base, n, compar) sane_qsort((base), (n), sizeof(*(base)), compar)\nstatic inline void sane_qsort(void *base, size_t nmemb, size_t size,\n\t\t\t      int(*compar)(const void *, const void *))\n{\n\tif (nmemb > 1)\n\t\tqsort(base, nmemb, size, compar);\n}\n\n#ifndef HAVE_ISO_QSORT_S\nint git_qsort_s(void *base, size_t nmemb, size_t size,\n\t\tint (*compar)(const void *, const void *, void *), void *ctx);\n#define qsort_s git_qsort_s\n#endif\n\n#define QSORT_S(base, n, compar, ctx) do {\t\t\t\\\n\tif (qsort_s((base), (n), sizeof(*(base)), compar, ctx))\t\\\n\t\tdie(\"BUG: qsort_s() failed\");\t\t\t\\\n} while (0)\n\n#ifndef REG_STARTEND\n#error \"Git requires REG_STARTEND support. Compile with NO_REGEX=NeedsStartEnd\"\n#endif\n\nstatic inline int regexec_buf(const regex_t *preg, const char *buf, size_t size,\n\t\t\t      size_t nmatch, regmatch_t pmatch[], int eflags)\n{\n\tassert(nmatch > 0 && pmatch);\n\tpmatch[0].rm_so = 0;\n\tpmatch[0].rm_eo = size;\n\treturn regexec(preg, buf, nmatch, pmatch, eflags | REG_STARTEND);\n}\n\n#ifndef DIR_HAS_BSD_GROUP_SEMANTICS\n# define FORCE_DIR_SET_GID S_ISGID\n#else\n# define FORCE_DIR_SET_GID 0\n#endif\n\n#ifdef NO_NSEC\n#undef USE_NSEC\n#define ST_CTIME_NSEC(st) 0\n#define ST_MTIME_NSEC(st) 0\n#else\n#ifdef USE_ST_TIMESPEC\n#define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctimespec.tv_nsec))\n#define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtimespec.tv_nsec))\n#else\n#define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctim.tv_nsec))\n#define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtim.tv_nsec))\n#endif\n#endif\n\n#ifdef UNRELIABLE_FSTAT\n#define fstat_is_reliable() 0\n#else\n#define fstat_is_reliable() 1\n#endif\n\n#ifndef va_copy\n/*\n * Since an obvious implementation of va_list would be to make it a\n * pointer into the stack frame, a simple assignment will work on\n * many systems.  But let's try to be more portable.\n */\n#ifdef __va_copy\n#define va_copy(dst, src) __va_copy(dst, src)\n#else\n#define va_copy(dst, src) ((dst) = (src))\n#endif\n#endif\n\n#if defined(__GNUC__) || (_MSC_VER >= 1400) || defined(__C99_MACRO_WITH_VA_ARGS)\n#define HAVE_VARIADIC_MACROS 1\n#endif\n\n#ifdef HAVE_VARIADIC_MACROS\n__attribute__((format (printf, 3, 4))) NORETURN\nvoid BUG_fl(const char *file, int line, const char *fmt, ...);\n#define BUG(...) BUG_fl(__FILE__, __LINE__, __VA_ARGS__)\n#else\n__attribute__((format (printf, 1, 2))) NORETURN\nvoid BUG(const char *fmt, ...);\n#endif\n\n/*\n * Preserves errno, prints a message, but gives no warning for ENOENT.\n * Returns 0 on success, which includes trying to unlink an object that does\n * not exist.\n */\nint unlink_or_warn(const char *path);\n /*\n  * Tries to unlink file.  Returns 0 if unlink succeeded\n  * or the file already didn't exist.  Returns -1 and\n  * appends a message to err suitable for\n  * 'error(\"%s\", err->buf)' on error.\n  */\nint unlink_or_msg(const char *file, struct strbuf *err);\n/*\n * Preserves errno, prints a message, but gives no warning for ENOENT.\n * Returns 0 on success, which includes trying to remove a directory that does\n * not exist.\n */\nint rmdir_or_warn(const char *path);\n/*\n * Calls the correct function out of {unlink,rmdir}_or_warn based on\n * the supplied file mode.\n */\nint remove_or_warn(unsigned int mode, const char *path);\n\n/*\n * Call access(2), but warn for any error except \"missing file\"\n * (ENOENT or ENOTDIR).\n */\n#define ACCESS_EACCES_OK (1U << 0)\nint access_or_warn(const char *path, int mode, unsigned flag);\nint access_or_die(const char *path, int mode, unsigned flag);\n\n/* Warn on an inaccessible file if errno indicates this is an error */\nint warn_on_fopen_errors(const char *path);\n\n#ifdef GMTIME_UNRELIABLE_ERRORS\nstruct tm *git_gmtime(const time_t *);\nstruct tm *git_gmtime_r(const time_t *, struct tm *);\n#define gmtime git_gmtime\n#define gmtime_r git_gmtime_r\n#endif\n\n#if !defined(USE_PARENS_AROUND_GETTEXT_N) && defined(__GNUC__)\n#define USE_PARENS_AROUND_GETTEXT_N 1\n#endif\n\n#ifndef SHELL_PATH\n# define SHELL_PATH \"/bin/sh\"\n#endif\n\n#ifndef _POSIX_THREAD_SAFE_FUNCTIONS\n#define flockfile(fh)\n#define funlockfile(fh)\n#define getc_unlocked(fh) getc(fh)\n#endif\n\n/*\n * Our code often opens a path to an optional file, to work on its\n * contents when we can successfully open it.  We can ignore a failure\n * to open if such an optional file does not exist, but we do want to\n * report a failure in opening for other reasons (e.g. we got an I/O\n * error, or the file is there, but we lack the permission to open).\n *\n * Call this function after seeing an error from open() or fopen() to\n * see if the errno indicates a missing file that we can safely ignore.\n */\nstatic inline int is_missing_file_error(int errno_)\n{\n\treturn (errno_ == ENOENT || errno_ == ENOTDIR);\n}\n\nextern int cmd_main(int, const char **);\n\n/*\n * You can mark a stack variable with UNLEAK(var) to avoid it being\n * reported as a leak by tools like LSAN or valgrind. The argument\n * should generally be the variable itself (not its address and not what\n * it points to). It's safe to use this on pointers which may already\n * have been freed, or on pointers which may still be in use.\n *\n * Use this _only_ for a variable that leaks by going out of scope at\n * program exit (so only from cmd_* functions or their direct helpers).\n * Normal functions, especially those which may be called multiple\n * times, should actually free their memory. This is only meant as\n * an annotation, and does nothing in non-leak-checking builds.\n */\n#ifdef SUPPRESS_ANNOTATED_LEAKS\nextern void unleak_memory(const void *ptr, size_t len);\n#define UNLEAK(var) unleak_memory(&(var), sizeof(var));\n#else\n#define UNLEAK(var)\n#endif\n\n#endif\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "003e444c46edce65f04413d732c22d71d708fd4f",
  "sha1_ok": true,
  "size": 32483
}
