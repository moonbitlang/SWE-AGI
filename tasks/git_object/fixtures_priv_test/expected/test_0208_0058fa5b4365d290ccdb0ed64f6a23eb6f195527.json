{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAicGt0LWxpbmUuaCIKI2luY2x1ZGUgInV0ZjguaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgInJldmlzaW9uLmgiCiNpbmNsdWRlICJub3Rlcy5oIgojaW5jbHVkZSAiZ3BnLWludGVyZmFjZS5oIgoKaW50IHNhdmVfY29tbWl0X2J1ZmZlciA9IDE7Cgpjb25zdCBjaGFyICpjb21taXRfdHlwZSA9ICJjb21taXQiOwoKc3RhdGljIHN0cnVjdCBjb21taXQgKmNoZWNrX2NvbW1pdChzdHJ1Y3Qgb2JqZWN0ICpvYmosCgkJCQkgICBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCQkJICAgaW50IHF1aWV0KQp7CglpZiAob2JqLT50eXBlICE9IE9CSl9DT01NSVQpIHsKCQlpZiAoIXF1aWV0KQoJCQllcnJvcigiT2JqZWN0ICVzIGlzIGEgJXMsIG5vdCBhIGNvbW1pdCIsCgkJCSAgICAgIHNoYTFfdG9faGV4KHNoYTEpLCB0eXBlbmFtZShvYmotPnR5cGUpKTsKCQlyZXR1cm4gTlVMTDsKCX0KCXJldHVybiAoc3RydWN0IGNvbW1pdCAqKSBvYmo7Cn0KCnN0cnVjdCBjb21taXQgKmxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCQkJCSAgICAgIGludCBxdWlldCkKewoJc3RydWN0IG9iamVjdCAqb2JqID0gZGVyZWZfdGFnKHBhcnNlX29iamVjdChzaGExKSwgTlVMTCwgMCk7CgoJaWYgKCFvYmopCgkJcmV0dXJuIE5VTEw7CglyZXR1cm4gY2hlY2tfY29tbWl0KG9iaiwgc2hhMSwgcXVpZXQpOwp9CgpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0X3JlZmVyZW5jZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglyZXR1cm4gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfZ2VudGx5KHNoYTEsIDApOwp9CgpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0X29yX2RpZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBjb25zdCBjaGFyICpyZWZfbmFtZSkKewoJc3RydWN0IGNvbW1pdCAqYyA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlKHNoYTEpOwoJaWYgKCFjKQoJCWRpZShfKCJjb3VsZCBub3QgcGFyc2UgJXMiKSwgcmVmX25hbWUpOwoJaWYgKGhhc2hjbXAoc2hhMSwgYy0+b2JqZWN0LnNoYTEpKSB7CgkJd2FybmluZyhfKCIlcyAlcyBpcyBub3QgYSBjb21taXQhIiksCgkJCXJlZl9uYW1lLCBzaGExX3RvX2hleChzaGExKSk7Cgl9CglyZXR1cm4gYzsKfQoKc3RydWN0IGNvbW1pdCAqbG9va3VwX2NvbW1pdChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmogPSBsb29rdXBfb2JqZWN0KHNoYTEpOwoJaWYgKCFvYmopCgkJcmV0dXJuIGNyZWF0ZV9vYmplY3Qoc2hhMSwgT0JKX0NPTU1JVCwgYWxsb2NfY29tbWl0X25vZGUoKSk7CglpZiAoIW9iai0+dHlwZSkKCQlvYmotPnR5cGUgPSBPQkpfQ09NTUlUOwoJcmV0dXJuIGNoZWNrX2NvbW1pdChvYmosIHNoYTEsIDApOwp9CgpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9ieV9uYW1lKGNvbnN0IGNoYXIgKm5hbWUpCnsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgoJaWYgKGdldF9zaGExKG5hbWUsIHNoYTEpKQoJCXJldHVybiBOVUxMOwoJY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2Uoc2hhMSk7CglpZiAoIWNvbW1pdCB8fCBwYXJzZV9jb21taXQoY29tbWl0KSkKCQlyZXR1cm4gTlVMTDsKCXJldHVybiBjb21taXQ7Cn0KCnN0YXRpYyB1bnNpZ25lZCBsb25nIHBhcnNlX2NvbW1pdF9kYXRlKGNvbnN0IGNoYXIgKmJ1ZiwgY29uc3QgY2hhciAqdGFpbCkKewoJY29uc3QgY2hhciAqZGF0ZXB0cjsKCglpZiAoYnVmICsgNiA+PSB0YWlsKQoJCXJldHVybiAwOwoJaWYgKG1lbWNtcChidWYsICJhdXRob3IiLCA2KSkKCQlyZXR1cm4gMDsKCXdoaWxlIChidWYgPCB0YWlsICYmICpidWYrKyAhPSAnXG4nKQoJCS8qIG5hZGEgKi87CglpZiAoYnVmICsgOSA+PSB0YWlsKQoJCXJldHVybiAwOwoJaWYgKG1lbWNtcChidWYsICJjb21taXR0ZXIiLCA5KSkKCQlyZXR1cm4gMDsKCXdoaWxlIChidWYgPCB0YWlsICYmICpidWYrKyAhPSAnPicpCgkJLyogbmFkYSAqLzsKCWlmIChidWYgPj0gdGFpbCkKCQlyZXR1cm4gMDsKCWRhdGVwdHIgPSBidWY7Cgl3aGlsZSAoYnVmIDwgdGFpbCAmJiAqYnVmKysgIT0gJ1xuJykKCQkvKiBuYWRhICovOwoJaWYgKGJ1ZiA+PSB0YWlsKQoJCXJldHVybiAwOwoJLyogZGF0ZXB0ciA8IGJ1ZiAmJiBidWZbLTFdID09ICdcbicsIHNvIHN0cnRvdWwgd2lsbCBzdG9wIGF0IGJ1Zi0xICovCglyZXR1cm4gc3RydG91bChkYXRlcHRyLCBOVUxMLCAxMCk7Cn0KCnN0YXRpYyBzdHJ1Y3QgY29tbWl0X2dyYWZ0ICoqY29tbWl0X2dyYWZ0OwpzdGF0aWMgaW50IGNvbW1pdF9ncmFmdF9hbGxvYywgY29tbWl0X2dyYWZ0X25yOwoKc3RhdGljIGludCBjb21taXRfZ3JhZnRfcG9zKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCWludCBsbywgaGk7CglsbyA9IDA7CgloaSA9IGNvbW1pdF9ncmFmdF9ucjsKCXdoaWxlIChsbyA8IGhpKSB7CgkJaW50IG1pID0gKGxvICsgaGkpIC8gMjsKCQlzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpncmFmdCA9IGNvbW1pdF9ncmFmdFttaV07CgkJaW50IGNtcCA9IGhhc2hjbXAoc2hhMSwgZ3JhZnQtPnNoYTEpOwoJCWlmICghY21wKQoJCQlyZXR1cm4gbWk7CgkJaWYgKGNtcCA8IDApCgkJCWhpID0gbWk7CgkJZWxzZQoJCQlsbyA9IG1pICsgMTsKCX0KCXJldHVybiAtbG8gLSAxOwp9CgppbnQgcmVnaXN0ZXJfY29tbWl0X2dyYWZ0KHN0cnVjdCBjb21taXRfZ3JhZnQgKmdyYWZ0LCBpbnQgaWdub3JlX2R1cHMpCnsKCWludCBwb3MgPSBjb21taXRfZ3JhZnRfcG9zKGdyYWZ0LT5zaGExKTsKCglpZiAoMCA8PSBwb3MpIHsKCQlpZiAoaWdub3JlX2R1cHMpCgkJCWZyZWUoZ3JhZnQpOwoJCWVsc2UgewoJCQlmcmVlKGNvbW1pdF9ncmFmdFtwb3NdKTsKCQkJY29tbWl0X2dyYWZ0W3Bvc10gPSBncmFmdDsKCQl9CgkJcmV0dXJuIDE7Cgl9Cglwb3MgPSAtcG9zIC0gMTsKCWlmIChjb21taXRfZ3JhZnRfYWxsb2MgPD0gKytjb21taXRfZ3JhZnRfbnIpIHsKCQljb21taXRfZ3JhZnRfYWxsb2MgPSBhbGxvY19ucihjb21taXRfZ3JhZnRfYWxsb2MpOwoJCWNvbW1pdF9ncmFmdCA9IHhyZWFsbG9jKGNvbW1pdF9ncmFmdCwKCQkJCQlzaXplb2YoKmNvbW1pdF9ncmFmdCkgKgoJCQkJCWNvbW1pdF9ncmFmdF9hbGxvYyk7Cgl9CglpZiAocG9zIDwgY29tbWl0X2dyYWZ0X25yKQoJCW1lbW1vdmUoY29tbWl0X2dyYWZ0ICsgcG9zICsgMSwKCQkJY29tbWl0X2dyYWZ0ICsgcG9zLAoJCQkoY29tbWl0X2dyYWZ0X25yIC0gcG9zIC0gMSkgKgoJCQlzaXplb2YoKmNvbW1pdF9ncmFmdCkpOwoJY29tbWl0X2dyYWZ0W3Bvc10gPSBncmFmdDsKCXJldHVybiAwOwp9CgpzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpyZWFkX2dyYWZ0X2xpbmUoY2hhciAqYnVmLCBpbnQgbGVuKQp7CgkvKiBUaGUgZm9ybWF0IGlzIGp1c3QgIkNvbW1pdCBQYXJlbnQxIFBhcmVudDIgLi4uXG4iICovCglpbnQgaTsKCXN0cnVjdCBjb21taXRfZ3JhZnQgKmdyYWZ0ID0gTlVMTDsKCgl3aGlsZSAobGVuICYmIGlzc3BhY2UoYnVmW2xlbi0xXSkpCgkJYnVmWy0tbGVuXSA9ICdcMCc7CglpZiAoYnVmWzBdID09ICcjJyB8fCBidWZbMF0gPT0gJ1wwJykKCQlyZXR1cm4gTlVMTDsKCWlmICgobGVuICsgMSkgJSA0MSkKCQlnb3RvIGJhZF9ncmFmdF9kYXRhOwoJaSA9IChsZW4gKyAxKSAvIDQxIC0gMTsKCWdyYWZ0ID0geG1hbGxvYyhzaXplb2YoKmdyYWZ0KSArIDIwICogaSk7CglncmFmdC0+bnJfcGFyZW50ID0gaTsKCWlmIChnZXRfc2hhMV9oZXgoYnVmLCBncmFmdC0+c2hhMSkpCgkJZ290byBiYWRfZ3JhZnRfZGF0YTsKCWZvciAoaSA9IDQwOyBpIDwgbGVuOyBpICs9IDQxKSB7CgkJaWYgKGJ1ZltpXSAhPSAnICcpCgkJCWdvdG8gYmFkX2dyYWZ0X2RhdGE7CgkJaWYgKGdldF9zaGExX2hleChidWYgKyBpICsgMSwgZ3JhZnQtPnBhcmVudFtpLzQxXSkpCgkJCWdvdG8gYmFkX2dyYWZ0X2RhdGE7Cgl9CglyZXR1cm4gZ3JhZnQ7CgpiYWRfZ3JhZnRfZGF0YToKCWVycm9yKCJiYWQgZ3JhZnQgZGF0YTogJXMiLCBidWYpOwoJZnJlZShncmFmdCk7CglyZXR1cm4gTlVMTDsKfQoKc3RhdGljIGludCByZWFkX2dyYWZ0X2ZpbGUoY29uc3QgY2hhciAqZ3JhZnRfZmlsZSkKewoJRklMRSAqZnAgPSBmb3BlbihncmFmdF9maWxlLCAiciIpOwoJY2hhciBidWZbMTAyNF07CglpZiAoIWZwKQoJCXJldHVybiAtMTsKCXdoaWxlIChmZ2V0cyhidWYsIHNpemVvZihidWYpLCBmcCkpIHsKCQkvKiBUaGUgZm9ybWF0IGlzIGp1c3QgIkNvbW1pdCBQYXJlbnQxIFBhcmVudDIgLi4uXG4iICovCgkJaW50IGxlbiA9IHN0cmxlbihidWYpOwoJCXN0cnVjdCBjb21taXRfZ3JhZnQgKmdyYWZ0ID0gcmVhZF9ncmFmdF9saW5lKGJ1ZiwgbGVuKTsKCQlpZiAoIWdyYWZ0KQoJCQljb250aW51ZTsKCQlpZiAocmVnaXN0ZXJfY29tbWl0X2dyYWZ0KGdyYWZ0LCAxKSkKCQkJZXJyb3IoImR1cGxpY2F0ZSBncmFmdCBkYXRhOiAlcyIsIGJ1Zik7Cgl9CglmY2xvc2UoZnApOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHByZXBhcmVfY29tbWl0X2dyYWZ0KHZvaWQpCnsKCXN0YXRpYyBpbnQgY29tbWl0X2dyYWZ0X3ByZXBhcmVkOwoJY2hhciAqZ3JhZnRfZmlsZTsKCglpZiAoY29tbWl0X2dyYWZ0X3ByZXBhcmVkKQoJCXJldHVybjsKCWdyYWZ0X2ZpbGUgPSBnZXRfZ3JhZnRfZmlsZSgpOwoJcmVhZF9ncmFmdF9maWxlKGdyYWZ0X2ZpbGUpOwoJLyogbWFrZSBzdXJlIHNoYWxsb3dzIGFyZSByZWFkICovCglpc19yZXBvc2l0b3J5X3NoYWxsb3coKTsKCWNvbW1pdF9ncmFmdF9wcmVwYXJlZCA9IDE7Cn0KCnN0cnVjdCBjb21taXRfZ3JhZnQgKmxvb2t1cF9jb21taXRfZ3JhZnQoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJaW50IHBvczsKCXByZXBhcmVfY29tbWl0X2dyYWZ0KCk7Cglwb3MgPSBjb21taXRfZ3JhZnRfcG9zKHNoYTEpOwoJaWYgKHBvcyA8IDApCgkJcmV0dXJuIE5VTEw7CglyZXR1cm4gY29tbWl0X2dyYWZ0W3Bvc107Cn0KCmludCBmb3JfZWFjaF9jb21taXRfZ3JhZnQoZWFjaF9jb21taXRfZ3JhZnRfZm4gZm4sIHZvaWQgKmNiX2RhdGEpCnsKCWludCBpLCByZXQ7Cglmb3IgKGkgPSByZXQgPSAwOyBpIDwgY29tbWl0X2dyYWZ0X25yICYmICFyZXQ7IGkrKykKCQlyZXQgPSBmbihjb21taXRfZ3JhZnRbaV0sIGNiX2RhdGEpOwoJcmV0dXJuIHJldDsKfQoKaW50IHVucmVnaXN0ZXJfc2hhbGxvdyhjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglpbnQgcG9zID0gY29tbWl0X2dyYWZ0X3BvcyhzaGExKTsKCWlmIChwb3MgPCAwKQoJCXJldHVybiAtMTsKCWlmIChwb3MgKyAxIDwgY29tbWl0X2dyYWZ0X25yKQoJCW1lbW1vdmUoY29tbWl0X2dyYWZ0ICsgcG9zLCBjb21taXRfZ3JhZnQgKyBwb3MgKyAxLAoJCQkJc2l6ZW9mKHN0cnVjdCBjb21taXRfZ3JhZnQgKikKCQkJCSogKGNvbW1pdF9ncmFmdF9uciAtIHBvcyAtIDEpKTsKCWNvbW1pdF9ncmFmdF9uci0tOwoJcmV0dXJuIDA7Cn0KCmludCBwYXJzZV9jb21taXRfYnVmZmVyKHN0cnVjdCBjb21taXQgKml0ZW0sIGNvbnN0IHZvaWQgKmJ1ZmZlciwgdW5zaWduZWQgbG9uZyBzaXplKQp7Cgljb25zdCBjaGFyICp0YWlsID0gYnVmZmVyOwoJY29uc3QgY2hhciAqYnVmcHRyID0gYnVmZmVyOwoJdW5zaWduZWQgY2hhciBwYXJlbnRbMjBdOwoJc3RydWN0IGNvbW1pdF9saXN0ICoqcHB0cjsKCXN0cnVjdCBjb21taXRfZ3JhZnQgKmdyYWZ0OwoKCWlmIChpdGVtLT5vYmplY3QucGFyc2VkKQoJCXJldHVybiAwOwoJaXRlbS0+b2JqZWN0LnBhcnNlZCA9IDE7Cgl0YWlsICs9IHNpemU7CglpZiAodGFpbCA8PSBidWZwdHIgKyA0NiB8fCBtZW1jbXAoYnVmcHRyLCAidHJlZSAiLCA1KSB8fCBidWZwdHJbNDVdICE9ICdcbicpCgkJcmV0dXJuIGVycm9yKCJib2d1cyBjb21taXQgb2JqZWN0ICVzIiwgc2hhMV90b19oZXgoaXRlbS0+b2JqZWN0LnNoYTEpKTsKCWlmIChnZXRfc2hhMV9oZXgoYnVmcHRyICsgNSwgcGFyZW50KSA8IDApCgkJcmV0dXJuIGVycm9yKCJiYWQgdHJlZSBwb2ludGVyIGluIGNvbW1pdCAlcyIsCgkJCSAgICAgc2hhMV90b19oZXgoaXRlbS0+b2JqZWN0LnNoYTEpKTsKCWl0ZW0tPnRyZWUgPSBsb29rdXBfdHJlZShwYXJlbnQpOwoJYnVmcHRyICs9IDQ2OyAvKiAidHJlZSAiICsgImhleCBzaGExIiArICJcbiIgKi8KCXBwdHIgPSAmaXRlbS0+cGFyZW50czsKCglncmFmdCA9IGxvb2t1cF9jb21taXRfZ3JhZnQoaXRlbS0+b2JqZWN0LnNoYTEpOwoJd2hpbGUgKGJ1ZnB0ciArIDQ4IDwgdGFpbCAmJiAhbWVtY21wKGJ1ZnB0ciwgInBhcmVudCAiLCA3KSkgewoJCXN0cnVjdCBjb21taXQgKm5ld19wYXJlbnQ7CgoJCWlmICh0YWlsIDw9IGJ1ZnB0ciArIDQ4IHx8CgkJICAgIGdldF9zaGExX2hleChidWZwdHIgKyA3LCBwYXJlbnQpIHx8CgkJICAgIGJ1ZnB0cls0N10gIT0gJ1xuJykKCQkJcmV0dXJuIGVycm9yKCJiYWQgcGFyZW50cyBpbiBjb21taXQgJXMiLCBzaGExX3RvX2hleChpdGVtLT5vYmplY3Quc2hhMSkpOwoJCWJ1ZnB0ciArPSA0ODsKCQkvKgoJCSAqIFRoZSBjbG9uZSBpcyBzaGFsbG93IGlmIG5yX3BhcmVudCA8IDAsIGFuZCB3ZSBtdXN0CgkJICogbm90IHRyYXZlcnNlIGl0cyByZWFsIHBhcmVudHMgZXZlbiB3aGVuIHdlIHVuaGlkZSB0aGVtLgoJCSAqLwoJCWlmIChncmFmdCAmJiAoZ3JhZnQtPm5yX3BhcmVudCA8IDAgfHwgZ3JhZnRzX3JlcGxhY2VfcGFyZW50cykpCgkJCWNvbnRpbnVlOwoJCW5ld19wYXJlbnQgPSBsb29rdXBfY29tbWl0KHBhcmVudCk7CgkJaWYgKG5ld19wYXJlbnQpCgkJCXBwdHIgPSAmY29tbWl0X2xpc3RfaW5zZXJ0KG5ld19wYXJlbnQsIHBwdHIpLT5uZXh0OwoJfQoJaWYgKGdyYWZ0KSB7CgkJaW50IGk7CgkJc3RydWN0IGNvbW1pdCAqbmV3X3BhcmVudDsKCQlmb3IgKGkgPSAwOyBpIDwgZ3JhZnQtPm5yX3BhcmVudDsgaSsrKSB7CgkJCW5ld19wYXJlbnQgPSBsb29rdXBfY29tbWl0KGdyYWZ0LT5wYXJlbnRbaV0pOwoJCQlpZiAoIW5ld19wYXJlbnQpCgkJCQljb250aW51ZTsKCQkJcHB0ciA9ICZjb21taXRfbGlzdF9pbnNlcnQobmV3X3BhcmVudCwgcHB0ciktPm5leHQ7CgkJfQoJfQoJaXRlbS0+ZGF0ZSA9IHBhcnNlX2NvbW1pdF9kYXRlKGJ1ZnB0ciwgdGFpbCk7CgoJcmV0dXJuIDA7Cn0KCmludCBwYXJzZV9jb21taXQoc3RydWN0IGNvbW1pdCAqaXRlbSkKewoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJdm9pZCAqYnVmZmVyOwoJdW5zaWduZWQgbG9uZyBzaXplOwoJaW50IHJldDsKCglpZiAoIWl0ZW0pCgkJcmV0dXJuIC0xOwoJaWYgKGl0ZW0tPm9iamVjdC5wYXJzZWQpCgkJcmV0dXJuIDA7CglidWZmZXIgPSByZWFkX3NoYTFfZmlsZShpdGVtLT5vYmplY3Quc2hhMSwgJnR5cGUsICZzaXplKTsKCWlmICghYnVmZmVyKQoJCXJldHVybiBlcnJvcigiQ291bGQgbm90IHJlYWQgJXMiLAoJCQkgICAgIHNoYTFfdG9faGV4KGl0ZW0tPm9iamVjdC5zaGExKSk7CglpZiAodHlwZSAhPSBPQkpfQ09NTUlUKSB7CgkJZnJlZShidWZmZXIpOwoJCXJldHVybiBlcnJvcigiT2JqZWN0ICVzIG5vdCBhIGNvbW1pdCIsCgkJCSAgICAgc2hhMV90b19oZXgoaXRlbS0+b2JqZWN0LnNoYTEpKTsKCX0KCXJldCA9IHBhcnNlX2NvbW1pdF9idWZmZXIoaXRlbSwgYnVmZmVyLCBzaXplKTsKCWlmIChzYXZlX2NvbW1pdF9idWZmZXIgJiYgIXJldCkgewoJCWl0ZW0tPmJ1ZmZlciA9IGJ1ZmZlcjsKCQlyZXR1cm4gMDsKCX0KCWZyZWUoYnVmZmVyKTsKCXJldHVybiByZXQ7Cn0KCmludCBmaW5kX2NvbW1pdF9zdWJqZWN0KGNvbnN0IGNoYXIgKmNvbW1pdF9idWZmZXIsIGNvbnN0IGNoYXIgKipzdWJqZWN0KQp7Cgljb25zdCBjaGFyICplb2w7Cgljb25zdCBjaGFyICpwID0gY29tbWl0X2J1ZmZlcjsKCgl3aGlsZSAoKnAgJiYgKCpwICE9ICdcbicgfHwgcFsxXSAhPSAnXG4nKSkKCQlwKys7CglpZiAoKnApIHsKCQlwICs9IDI7CgkJZm9yIChlb2wgPSBwOyAqZW9sICYmICplb2wgIT0gJ1xuJzsgZW9sKyspCgkJCTsgLyogZG8gbm90aGluZyAqLwoJfSBlbHNlCgkJZW9sID0gcDsKCgkqc3ViamVjdCA9IHA7CgoJcmV0dXJuIGVvbCAtIHA7Cn0KCnN0cnVjdCBjb21taXRfbGlzdCAqY29tbWl0X2xpc3RfaW5zZXJ0KHN0cnVjdCBjb21taXQgKml0ZW0sIHN0cnVjdCBjb21taXRfbGlzdCAqKmxpc3RfcCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpuZXdfbGlzdCA9IHhtYWxsb2Moc2l6ZW9mKHN0cnVjdCBjb21taXRfbGlzdCkpOwoJbmV3X2xpc3QtPml0ZW0gPSBpdGVtOwoJbmV3X2xpc3QtPm5leHQgPSAqbGlzdF9wOwoJKmxpc3RfcCA9IG5ld19saXN0OwoJcmV0dXJuIG5ld19saXN0Owp9Cgp1bnNpZ25lZCBjb21taXRfbGlzdF9jb3VudChjb25zdCBzdHJ1Y3QgY29tbWl0X2xpc3QgKmwpCnsKCXVuc2lnbmVkIGMgPSAwOwoJZm9yICg7IGw7IGwgPSBsLT5uZXh0ICkKCQljKys7CglyZXR1cm4gYzsKfQoKdm9pZCBmcmVlX2NvbW1pdF9saXN0KHN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCkKewoJd2hpbGUgKGxpc3QpIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnRlbXAgPSBsaXN0OwoJCWxpc3QgPSB0ZW1wLT5uZXh0OwoJCWZyZWUodGVtcCk7Cgl9Cn0KCnN0cnVjdCBjb21taXRfbGlzdCAqIGNvbW1pdF9saXN0X2luc2VydF9ieV9kYXRlKHN0cnVjdCBjb21taXQgKml0ZW0sIHN0cnVjdCBjb21taXRfbGlzdCAqKmxpc3QpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqKnBwID0gbGlzdDsKCXN0cnVjdCBjb21taXRfbGlzdCAqcDsKCXdoaWxlICgocCA9ICpwcCkgIT0gTlVMTCkgewoJCWlmIChwLT5pdGVtLT5kYXRlIDwgaXRlbS0+ZGF0ZSkgewoJCQlicmVhazsKCQl9CgkJcHAgPSAmcC0+bmV4dDsKCX0KCXJldHVybiBjb21taXRfbGlzdF9pbnNlcnQoaXRlbSwgcHApOwp9CgoKdm9pZCBjb21taXRfbGlzdF9zb3J0X2J5X2RhdGUoc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpyZXQgPSBOVUxMOwoJd2hpbGUgKCpsaXN0KSB7CgkJY29tbWl0X2xpc3RfaW5zZXJ0X2J5X2RhdGUoKCpsaXN0KS0+aXRlbSwgJnJldCk7CgkJKmxpc3QgPSAoKmxpc3QpLT5uZXh0OwoJfQoJKmxpc3QgPSByZXQ7Cn0KCnN0cnVjdCBjb21taXQgKnBvcF9tb3N0X3JlY2VudF9jb21taXQoc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCwKCQkJCSAgICAgIHVuc2lnbmVkIGludCBtYXJrKQp7CglzdHJ1Y3QgY29tbWl0ICpyZXQgPSAoKmxpc3QpLT5pdGVtOwoJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzID0gcmV0LT5wYXJlbnRzOwoJc3RydWN0IGNvbW1pdF9saXN0ICpvbGQgPSAqbGlzdDsKCgkqbGlzdCA9ICgqbGlzdCktPm5leHQ7CglmcmVlKG9sZCk7CgoJd2hpbGUgKHBhcmVudHMpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBwYXJlbnRzLT5pdGVtOwoJCWlmICghcGFyc2VfY29tbWl0KGNvbW1pdCkgJiYgIShjb21taXQtPm9iamVjdC5mbGFncyAmIG1hcmspKSB7CgkJCWNvbW1pdC0+b2JqZWN0LmZsYWdzIHw9IG1hcms7CgkJCWNvbW1pdF9saXN0X2luc2VydF9ieV9kYXRlKGNvbW1pdCwgbGlzdCk7CgkJfQoJCXBhcmVudHMgPSBwYXJlbnRzLT5uZXh0OwoJfQoJcmV0dXJuIHJldDsKfQoKdm9pZCBjbGVhcl9jb21taXRfbWFya3Moc3RydWN0IGNvbW1pdCAqY29tbWl0LCB1bnNpZ25lZCBpbnQgbWFyaykKewoJd2hpbGUgKGNvbW1pdCkgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50czsKCgkJaWYgKCEobWFyayAmIGNvbW1pdC0+b2JqZWN0LmZsYWdzKSkKCQkJcmV0dXJuOwoKCQljb21taXQtPm9iamVjdC5mbGFncyAmPSB+bWFyazsKCgkJcGFyZW50cyA9IGNvbW1pdC0+cGFyZW50czsKCQlpZiAoIXBhcmVudHMpCgkJCXJldHVybjsKCgkJd2hpbGUgKChwYXJlbnRzID0gcGFyZW50cy0+bmV4dCkpCgkJCWNsZWFyX2NvbW1pdF9tYXJrcyhwYXJlbnRzLT5pdGVtLCBtYXJrKTsKCgkJY29tbWl0ID0gY29tbWl0LT5wYXJlbnRzLT5pdGVtOwoJfQp9Cgp2b2lkIGNsZWFyX2NvbW1pdF9tYXJrc19mb3Jfb2JqZWN0X2FycmF5KHN0cnVjdCBvYmplY3RfYXJyYXkgKmEsIHVuc2lnbmVkIG1hcmspCnsKCXN0cnVjdCBvYmplY3QgKm9iamVjdDsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCXVuc2lnbmVkIGludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBhLT5ucjsgaSsrKSB7CgkJb2JqZWN0ID0gYS0+b2JqZWN0c1tpXS5pdGVtOwoJCWNvbW1pdCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseShvYmplY3QtPnNoYTEsIDEpOwoJCWlmIChjb21taXQpCgkJCWNsZWFyX2NvbW1pdF9tYXJrcyhjb21taXQsIG1hcmspOwoJfQp9CgpzdHJ1Y3QgY29tbWl0ICpwb3BfY29tbWl0KHN0cnVjdCBjb21taXRfbGlzdCAqKnN0YWNrKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnRvcCA9ICpzdGFjazsKCXN0cnVjdCBjb21taXQgKml0ZW0gPSB0b3AgPyB0b3AtPml0ZW0gOiBOVUxMOwoKCWlmICh0b3ApIHsKCQkqc3RhY2sgPSB0b3AtPm5leHQ7CgkJZnJlZSh0b3ApOwoJfQoJcmV0dXJuIGl0ZW07Cn0KCi8qCiAqIFBlcmZvcm1zIGFuIGluLXBsYWNlIHRvcG9sb2dpY2FsIHNvcnQgb24gdGhlIGxpc3Qgc3VwcGxpZWQuCiAqLwp2b2lkIHNvcnRfaW5fdG9wb2xvZ2ljYWxfb3JkZXIoc3RydWN0IGNvbW1pdF9saXN0ICoqIGxpc3QsIGludCBsaWZvKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKm5leHQsICpvcmlnID0gKmxpc3Q7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKndvcmssICoqaW5zZXJ0OwoJc3RydWN0IGNvbW1pdF9saXN0ICoqcHB0cjsKCglpZiAoIW9yaWcpCgkJcmV0dXJuOwoJKmxpc3QgPSBOVUxMOwoKCS8qIE1hcmsgdGhlbSBhbmQgY2xlYXIgdGhlIGluZGVncmVlICovCglmb3IgKG5leHQgPSBvcmlnOyBuZXh0OyBuZXh0ID0gbmV4dC0+bmV4dCkgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IG5leHQtPml0ZW07CgkJY29tbWl0LT5pbmRlZ3JlZSA9IDE7Cgl9CgoJLyogdXBkYXRlIHRoZSBpbmRlZ3JlZSAqLwoJZm9yIChuZXh0ID0gb3JpZzsgbmV4dDsgbmV4dCA9IG5leHQtPm5leHQpIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKiBwYXJlbnRzID0gbmV4dC0+aXRlbS0+cGFyZW50czsKCQl3aGlsZSAocGFyZW50cykgewoJCQlzdHJ1Y3QgY29tbWl0ICpwYXJlbnQgPSBwYXJlbnRzLT5pdGVtOwoKCQkJaWYgKHBhcmVudC0+aW5kZWdyZWUpCgkJCQlwYXJlbnQtPmluZGVncmVlKys7CgkJCXBhcmVudHMgPSBwYXJlbnRzLT5uZXh0OwoJCX0KCX0KCgkvKgoJICogZmluZCB0aGUgdGlwcwoJICoKCSAqIHRpcHMgYXJlIG5vZGVzIG5vdCByZWFjaGFibGUgZnJvbSBhbnkgb3RoZXIgbm9kZSBpbiB0aGUgbGlzdAoJICoKCSAqIHRoZSB0aXBzIHNlcnZlIGFzIGEgc3RhcnRpbmcgc2V0IGZvciB0aGUgd29yayBxdWV1ZS4KCSAqLwoJd29yayA9IE5VTEw7CglpbnNlcnQgPSAmd29yazsKCWZvciAobmV4dCA9IG9yaWc7IG5leHQ7IG5leHQgPSBuZXh0LT5uZXh0KSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gbmV4dC0+aXRlbTsKCgkJaWYgKGNvbW1pdC0+aW5kZWdyZWUgPT0gMSkKCQkJaW5zZXJ0ID0gJmNvbW1pdF9saXN0X2luc2VydChjb21taXQsIGluc2VydCktPm5leHQ7Cgl9CgoJLyogcHJvY2VzcyB0aGUgbGlzdCBpbiB0b3BvbG9naWNhbCBvcmRlciAqLwoJaWYgKCFsaWZvKQoJCWNvbW1pdF9saXN0X3NvcnRfYnlfZGF0ZSgmd29yayk7CgoJcHB0ciA9IGxpc3Q7CgkqbGlzdCA9IE5VTEw7Cgl3aGlsZSAod29yaykgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMsICp3b3JrX2l0ZW07CgoJCXdvcmtfaXRlbSA9IHdvcms7CgkJd29yayA9IHdvcmtfaXRlbS0+bmV4dDsKCQl3b3JrX2l0ZW0tPm5leHQgPSBOVUxMOwoKCQljb21taXQgPSB3b3JrX2l0ZW0tPml0ZW07CgkJZm9yIChwYXJlbnRzID0gY29tbWl0LT5wYXJlbnRzOyBwYXJlbnRzIDsgcGFyZW50cyA9IHBhcmVudHMtPm5leHQpIHsKCQkJc3RydWN0IGNvbW1pdCAqcGFyZW50ID0gcGFyZW50cy0+aXRlbTsKCgkJCWlmICghcGFyZW50LT5pbmRlZ3JlZSkKCQkJCWNvbnRpbnVlOwoKCQkJLyoKCQkJICogcGFyZW50cyBhcmUgb25seSBlbnF1ZXVlZCBmb3IgZW1pc3Npb24KCQkJICogd2hlbiBhbGwgdGhlaXIgY2hpbGRyZW4gaGF2ZSBiZWVuIGVtaXR0ZWQgdGhlcmVieQoJCQkgKiBndWFyYW50ZWVpbmcgdG9wb2xvZ2ljYWwgb3JkZXIuCgkJCSAqLwoJCQlpZiAoLS1wYXJlbnQtPmluZGVncmVlID09IDEpIHsKCQkJCWlmICghbGlmbykKCQkJCQljb21taXRfbGlzdF9pbnNlcnRfYnlfZGF0ZShwYXJlbnQsICZ3b3JrKTsKCQkJCWVsc2UKCQkJCQljb21taXRfbGlzdF9pbnNlcnQocGFyZW50LCAmd29yayk7CgkJCX0KCQl9CgkJLyoKCQkgKiB3b3JrX2l0ZW0gaXMgYSBjb21taXQgYWxsIG9mIHdob3NlIGNoaWxkcmVuCgkJICogaGF2ZSBhbHJlYWR5IGJlZW4gZW1pdHRlZC4gd2UgY2FuIGVtaXQgaXQgbm93LgoJCSAqLwoJCWNvbW1pdC0+aW5kZWdyZWUgPSAwOwoJCSpwcHRyID0gd29ya19pdGVtOwoJCXBwdHIgPSAmd29ya19pdGVtLT5uZXh0OwoJfQp9CgovKiBtZXJnZS1iYXNlIHN0dWZmICovCgovKiBiaXRzICMwLi4xNSBpbiByZXZpc2lvbi5oICovCiNkZWZpbmUgUEFSRU5UMQkJKDF1PDwxNikKI2RlZmluZSBQQVJFTlQyCQkoMXU8PDE3KQojZGVmaW5lIFNUQUxFCQkoMXU8PDE4KQojZGVmaW5lIFJFU1VMVAkJKDF1PDwxOSkKCnN0YXRpYyBjb25zdCB1bnNpZ25lZCBhbGxfZmxhZ3MgPSAoUEFSRU5UMSB8IFBBUkVOVDIgfCBTVEFMRSB8IFJFU1VMVCk7CgpzdGF0aWMgc3RydWN0IGNvbW1pdCAqaW50ZXJlc3Rpbmcoc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0KQp7Cgl3aGlsZSAobGlzdCkgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IGxpc3QtPml0ZW07CgkJbGlzdCA9IGxpc3QtPm5leHQ7CgkJaWYgKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgU1RBTEUpCgkJCWNvbnRpbnVlOwoJCXJldHVybiBjb21taXQ7Cgl9CglyZXR1cm4gTlVMTDsKfQoKc3RhdGljIHN0cnVjdCBjb21taXRfbGlzdCAqcGFpbnRfZG93bl90b19jb21tb24oc3RydWN0IGNvbW1pdCAqb25lLCBpbnQgbiwgc3RydWN0IGNvbW1pdCAqKnR3b3MpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCA9IE5VTEw7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlc3VsdCA9IE5VTEw7CglpbnQgaTsKCglvbmUtPm9iamVjdC5mbGFncyB8PSBQQVJFTlQxOwoJY29tbWl0X2xpc3RfaW5zZXJ0X2J5X2RhdGUob25lLCAmbGlzdCk7Cglmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7CgkJdHdvc1tpXS0+b2JqZWN0LmZsYWdzIHw9IFBBUkVOVDI7CgkJY29tbWl0X2xpc3RfaW5zZXJ0X2J5X2RhdGUodHdvc1tpXSwgJmxpc3QpOwoJfQoKCXdoaWxlIChpbnRlcmVzdGluZyhsaXN0KSkgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHM7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpuZXh0OwoJCWludCBmbGFnczsKCgkJY29tbWl0ID0gbGlzdC0+aXRlbTsKCQluZXh0ID0gbGlzdC0+bmV4dDsKCQlmcmVlKGxpc3QpOwoJCWxpc3QgPSBuZXh0OwoKCQlmbGFncyA9IGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgKFBBUkVOVDEgfCBQQVJFTlQyIHwgU1RBTEUpOwoJCWlmIChmbGFncyA9PSAoUEFSRU5UMSB8IFBBUkVOVDIpKSB7CgkJCWlmICghKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgUkVTVUxUKSkgewoJCQkJY29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gUkVTVUxUOwoJCQkJY29tbWl0X2xpc3RfaW5zZXJ0X2J5X2RhdGUoY29tbWl0LCAmcmVzdWx0KTsKCQkJfQoJCQkvKiBNYXJrIHBhcmVudHMgb2YgYSBmb3VuZCBtZXJnZSBzdGFsZSAqLwoJCQlmbGFncyB8PSBTVEFMRTsKCQl9CgkJcGFyZW50cyA9IGNvbW1pdC0+cGFyZW50czsKCQl3aGlsZSAocGFyZW50cykgewoJCQlzdHJ1Y3QgY29tbWl0ICpwID0gcGFyZW50cy0+aXRlbTsKCQkJcGFyZW50cyA9IHBhcmVudHMtPm5leHQ7CgkJCWlmICgocC0+b2JqZWN0LmZsYWdzICYgZmxhZ3MpID09IGZsYWdzKQoJCQkJY29udGludWU7CgkJCWlmIChwYXJzZV9jb21taXQocCkpCgkJCQlyZXR1cm4gTlVMTDsKCQkJcC0+b2JqZWN0LmZsYWdzIHw9IGZsYWdzOwoJCQljb21taXRfbGlzdF9pbnNlcnRfYnlfZGF0ZShwLCAmbGlzdCk7CgkJfQoJfQoKCWZyZWVfY29tbWl0X2xpc3QobGlzdCk7CglyZXR1cm4gcmVzdWx0Owp9CgpzdGF0aWMgc3RydWN0IGNvbW1pdF9saXN0ICptZXJnZV9iYXNlc19tYW55KHN0cnVjdCBjb21taXQgKm9uZSwgaW50IG4sIHN0cnVjdCBjb21taXQgKip0d29zKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QgPSBOVUxMOwoJc3RydWN0IGNvbW1pdF9saXN0ICpyZXN1bHQgPSBOVUxMOwoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IG47IGkrKykgewoJCWlmIChvbmUgPT0gdHdvc1tpXSkKCQkJLyoKCQkJICogV2UgZG8gbm90IG1hcmsgdGhpcyBldmVuIHdpdGggUkVTVUxUIHNvIHdlIGRvIG5vdAoJCQkgKiBoYXZlIHRvIGNsZWFuIGl0IHVwLgoJCQkgKi8KCQkJcmV0dXJuIGNvbW1pdF9saXN0X2luc2VydChvbmUsICZyZXN1bHQpOwoJfQoKCWlmIChwYXJzZV9jb21taXQob25lKSkKCQlyZXR1cm4gTlVMTDsKCWZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHsKCQlpZiAocGFyc2VfY29tbWl0KHR3b3NbaV0pKQoJCQlyZXR1cm4gTlVMTDsKCX0KCglsaXN0ID0gcGFpbnRfZG93bl90b19jb21tb24ob25lLCBuLCB0d29zKTsKCgl3aGlsZSAobGlzdCkgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqbmV4dCA9IGxpc3QtPm5leHQ7CgkJaWYgKCEobGlzdC0+aXRlbS0+b2JqZWN0LmZsYWdzICYgU1RBTEUpKQoJCQljb21taXRfbGlzdF9pbnNlcnRfYnlfZGF0ZShsaXN0LT5pdGVtLCAmcmVzdWx0KTsKCQlmcmVlKGxpc3QpOwoJCWxpc3QgPSBuZXh0OwoJfQoJcmV0dXJuIHJlc3VsdDsKfQoKc3RydWN0IGNvbW1pdF9saXN0ICpnZXRfb2N0b3B1c19tZXJnZV9iYXNlcyhzdHJ1Y3QgY29tbWl0X2xpc3QgKmluKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKmksICpqLCAqaywgKnJldCA9IE5VTEw7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKipwcHRyID0gJnJldDsKCglmb3IgKGkgPSBpbjsgaTsgaSA9IGktPm5leHQpIHsKCQlpZiAoIXJldCkKCQkJcHB0ciA9ICZjb21taXRfbGlzdF9pbnNlcnQoaS0+aXRlbSwgcHB0ciktPm5leHQ7CgkJZWxzZSB7CgkJCXN0cnVjdCBjb21taXRfbGlzdCAqbmV3ID0gTlVMTCwgKmVuZCA9IE5VTEw7CgoJCQlmb3IgKGogPSByZXQ7IGo7IGogPSBqLT5uZXh0KSB7CgkJCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKmJhc2VzOwoJCQkJYmFzZXMgPSBnZXRfbWVyZ2VfYmFzZXMoaS0+aXRlbSwgai0+aXRlbSwgMSk7CgkJCQlpZiAoIW5ldykKCQkJCQluZXcgPSBiYXNlczsKCQkJCWVsc2UKCQkJCQllbmQtPm5leHQgPSBiYXNlczsKCQkJCWZvciAoayA9IGJhc2VzOyBrOyBrID0gay0+bmV4dCkKCQkJCQllbmQgPSBrOwoJCQl9CgkJCXJldCA9IG5ldzsKCQl9Cgl9CglyZXR1cm4gcmV0Owp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9tZXJnZV9iYXNlc19tYW55KHN0cnVjdCBjb21taXQgKm9uZSwKCQkJCQkgaW50IG4sCgkJCQkJIHN0cnVjdCBjb21taXQgKip0d29zLAoJCQkJCSBpbnQgY2xlYW51cCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0OwoJc3RydWN0IGNvbW1pdCAqKnJzbHQ7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlc3VsdDsKCWludCBjbnQsIGksIGo7CgoJcmVzdWx0ID0gbWVyZ2VfYmFzZXNfbWFueShvbmUsIG4sIHR3b3MpOwoJZm9yIChpID0gMDsgaSA8IG47IGkrKykgewoJCWlmIChvbmUgPT0gdHdvc1tpXSkKCQkJcmV0dXJuIHJlc3VsdDsKCX0KCWlmICghcmVzdWx0IHx8ICFyZXN1bHQtPm5leHQpIHsKCQlpZiAoY2xlYW51cCkgewoJCQljbGVhcl9jb21taXRfbWFya3Mob25lLCBhbGxfZmxhZ3MpOwoJCQlmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKQoJCQkJY2xlYXJfY29tbWl0X21hcmtzKHR3b3NbaV0sIGFsbF9mbGFncyk7CgkJfQoJCXJldHVybiByZXN1bHQ7Cgl9CgoJLyogVGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgKi8KCWNudCA9IDA7CglsaXN0ID0gcmVzdWx0OwoJd2hpbGUgKGxpc3QpIHsKCQlsaXN0ID0gbGlzdC0+bmV4dDsKCQljbnQrKzsKCX0KCXJzbHQgPSB4Y2FsbG9jKGNudCwgc2l6ZW9mKCpyc2x0KSk7Cglmb3IgKGxpc3QgPSByZXN1bHQsIGkgPSAwOyBsaXN0OyBsaXN0ID0gbGlzdC0+bmV4dCkKCQlyc2x0W2krK10gPSBsaXN0LT5pdGVtOwoJZnJlZV9jb21taXRfbGlzdChyZXN1bHQpOwoKCWNsZWFyX2NvbW1pdF9tYXJrcyhvbmUsIGFsbF9mbGFncyk7Cglmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKQoJCWNsZWFyX2NvbW1pdF9tYXJrcyh0d29zW2ldLCBhbGxfZmxhZ3MpOwoJZm9yIChpID0gMDsgaSA8IGNudCAtIDE7IGkrKykgewoJCWZvciAoaiA9IGkrMTsgaiA8IGNudDsgaisrKSB7CgkJCWlmICghcnNsdFtpXSB8fCAhcnNsdFtqXSkKCQkJCWNvbnRpbnVlOwoJCQlyZXN1bHQgPSBtZXJnZV9iYXNlc19tYW55KHJzbHRbaV0sIDEsICZyc2x0W2pdKTsKCQkJY2xlYXJfY29tbWl0X21hcmtzKHJzbHRbaV0sIGFsbF9mbGFncyk7CgkJCWNsZWFyX2NvbW1pdF9tYXJrcyhyc2x0W2pdLCBhbGxfZmxhZ3MpOwoJCQlmb3IgKGxpc3QgPSByZXN1bHQ7IGxpc3Q7IGxpc3QgPSBsaXN0LT5uZXh0KSB7CgkJCQlpZiAocnNsdFtpXSA9PSBsaXN0LT5pdGVtKQoJCQkJCXJzbHRbaV0gPSBOVUxMOwoJCQkJaWYgKHJzbHRbal0gPT0gbGlzdC0+aXRlbSkKCQkJCQlyc2x0W2pdID0gTlVMTDsKCQkJfQoJCX0KCX0KCgkvKiBTdXJ2aXZpbmcgb25lcyBpbiByc2x0W10gYXJlIHRoZSBpbmRlcGVuZGVudCByZXN1bHRzICovCglyZXN1bHQgPSBOVUxMOwoJZm9yIChpID0gMDsgaSA8IGNudDsgaSsrKSB7CgkJaWYgKHJzbHRbaV0pCgkJCWNvbW1pdF9saXN0X2luc2VydF9ieV9kYXRlKHJzbHRbaV0sICZyZXN1bHQpOwoJfQoJZnJlZShyc2x0KTsKCXJldHVybiByZXN1bHQ7Cn0KCnN0cnVjdCBjb21taXRfbGlzdCAqZ2V0X21lcmdlX2Jhc2VzKHN0cnVjdCBjb21taXQgKm9uZSwgc3RydWN0IGNvbW1pdCAqdHdvLAoJCQkJICAgIGludCBjbGVhbnVwKQp7CglyZXR1cm4gZ2V0X21lcmdlX2Jhc2VzX21hbnkob25lLCAxLCAmdHdvLCBjbGVhbnVwKTsKfQoKLyoKICogSXMgImNvbW1pdCIgYSBkZWNlbmRhbnQgb2Ygb25lIG9mIHRoZSBlbGVtZW50cyBvbiB0aGUgIndpdGhfY29tbWl0IiBsaXN0PwogKi8KaW50IGlzX2Rlc2NlbmRhbnRfb2Yoc3RydWN0IGNvbW1pdCAqY29tbWl0LCBzdHJ1Y3QgY29tbWl0X2xpc3QgKndpdGhfY29tbWl0KQp7CglpZiAoIXdpdGhfY29tbWl0KQoJCXJldHVybiAxOwoJd2hpbGUgKHdpdGhfY29tbWl0KSB7CgkJc3RydWN0IGNvbW1pdCAqb3RoZXI7CgoJCW90aGVyID0gd2l0aF9jb21taXQtPml0ZW07CgkJd2l0aF9jb21taXQgPSB3aXRoX2NvbW1pdC0+bmV4dDsKCQlpZiAoaW5fbWVyZ2VfYmFzZXMob3RoZXIsIGNvbW1pdCkpCgkJCXJldHVybiAxOwoJfQoJcmV0dXJuIDA7Cn0KCi8qCiAqIElzICJjb21taXQiIGFuIGFuY2VzdG9yIG9mIChpLmUuIHJlYWNoYWJsZSBmcm9tKSB0aGUgInJlZmVyZW5jZSI/CiAqLwppbnQgaW5fbWVyZ2VfYmFzZXMoc3RydWN0IGNvbW1pdCAqY29tbWl0LCBzdHJ1Y3QgY29tbWl0ICpyZWZlcmVuY2UpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqYmFzZXMsICpiOwoJaW50IHJldCA9IDA7CgoJYmFzZXMgPSBtZXJnZV9iYXNlc19tYW55KGNvbW1pdCwgMSwgJnJlZmVyZW5jZSk7CgljbGVhcl9jb21taXRfbWFya3MoY29tbWl0LCBhbGxfZmxhZ3MpOwoJY2xlYXJfY29tbWl0X21hcmtzKHJlZmVyZW5jZSwgYWxsX2ZsYWdzKTsKCglmb3IgKGIgPSBiYXNlczsgYjsgYiA9IGItPm5leHQpIHsKCQlpZiAoIWhhc2hjbXAoY29tbWl0LT5vYmplY3Quc2hhMSwgYi0+aXRlbS0+b2JqZWN0LnNoYTEpKSB7CgkJCXJldCA9IDE7CgkJCWJyZWFrOwoJCX0KCX0KCglmcmVlX2NvbW1pdF9saXN0KGJhc2VzKTsKCXJldHVybiByZXQ7Cn0KCnN0cnVjdCBjb21taXRfbGlzdCAqcmVkdWNlX2hlYWRzKHN0cnVjdCBjb21taXRfbGlzdCAqaGVhZHMpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqcDsKCXN0cnVjdCBjb21taXRfbGlzdCAqcmVzdWx0ID0gTlVMTCwgKip0YWlsID0gJnJlc3VsdDsKCXN0cnVjdCBjb21taXQgKipvdGhlcjsKCXNpemVfdCBudW1faGVhZCwgbnVtX290aGVyOwoKCWlmICghaGVhZHMpCgkJcmV0dXJuIE5VTEw7CgoJLyogQXZvaWQgdW5uZWNlc3NhcnkgcmVhbGxvY2F0aW9ucyAqLwoJZm9yIChwID0gaGVhZHMsIG51bV9oZWFkID0gMDsgcDsgcCA9IHAtPm5leHQpCgkJbnVtX2hlYWQrKzsKCW90aGVyID0geGNhbGxvYyhzaXplb2YoKm90aGVyKSwgbnVtX2hlYWQpOwoKCS8qIEZvciBlYWNoIGNvbW1pdCwgc2VlIGlmIGl0IGNhbiBiZSByZWFjaGVkIGJ5IG90aGVycyAqLwoJZm9yIChwID0gaGVhZHM7IHA7IHAgPSBwLT5uZXh0KSB7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpxLCAqYmFzZTsKCgkJLyogRG8gd2UgYWxyZWFkeSBoYXZlIHRoaXMgaW4gdGhlIHJlc3VsdD8gKi8KCQlmb3IgKHEgPSByZXN1bHQ7IHE7IHEgPSBxLT5uZXh0KQoJCQlpZiAocC0+aXRlbSA9PSBxLT5pdGVtKQoJCQkJYnJlYWs7CgkJaWYgKHEpCgkJCWNvbnRpbnVlOwoKCQludW1fb3RoZXIgPSAwOwoJCWZvciAocSA9IGhlYWRzOyBxOyBxID0gcS0+bmV4dCkgewoJCQlpZiAocC0+aXRlbSA9PSBxLT5pdGVtKQoJCQkJY29udGludWU7CgkJCW90aGVyW251bV9vdGhlcisrXSA9IHEtPml0ZW07CgkJfQoJCWlmIChudW1fb3RoZXIpCgkJCWJhc2UgPSBnZXRfbWVyZ2VfYmFzZXNfbWFueShwLT5pdGVtLCBudW1fb3RoZXIsIG90aGVyLCAxKTsKCQllbHNlCgkJCWJhc2UgPSBOVUxMOwoJCS8qCgkJICogSWYgcC0+aXRlbSBkb2VzIG5vdCBoYXZlIGFueXRoaW5nIGNvbW1vbiB3aXRoIG90aGVyCgkJICogY29tbWl0cywgdGhlcmUgd29uJ3QgYmUgYW55IG1lcmdlIGJhc2UuICBJZiBpdCBpcwoJCSAqIHJlYWNoYWJsZSBmcm9tIHNvbWUgb2YgdGhlIG90aGVycywgcC0+aXRlbSB3aWxsIGJlCgkJICogdGhlIG1lcmdlIGJhc2UuICBJZiBpdHMgaGlzdG9yeSBpcyBjb25uZWN0ZWQgd2l0aAoJCSAqIG90aGVycywgYnV0IHAtPml0ZW0gaXMgbm90IHJlYWNoYWJsZSBieSBvdGhlcnMsIHdlCgkJICogd2lsbCBnZXQgc29tZXRoaW5nIG90aGVyIHRoYW4gcC0+aXRlbSBiYWNrLgoJCSAqLwoJCWlmICghYmFzZSB8fCAoYmFzZS0+aXRlbSAhPSBwLT5pdGVtKSkKCQkJdGFpbCA9ICYoY29tbWl0X2xpc3RfaW5zZXJ0KHAtPml0ZW0sIHRhaWwpLT5uZXh0KTsKCQlmcmVlX2NvbW1pdF9saXN0KGJhc2UpOwoJfQoJZnJlZShvdGhlcik7CglyZXR1cm4gcmVzdWx0Owp9CgpzdGF0aWMgY29uc3QgY2hhciBncGdfc2lnX2hlYWRlcltdID0gImdwZ3NpZyI7CnN0YXRpYyBjb25zdCBpbnQgZ3BnX3NpZ19oZWFkZXJfbGVuID0gc2l6ZW9mKGdwZ19zaWdfaGVhZGVyKSAtIDE7CgpzdGF0aWMgaW50IGRvX3NpZ25fY29tbWl0KHN0cnVjdCBzdHJidWYgKmJ1ZiwgY29uc3QgY2hhciAqa2V5aWQpCnsKCXN0cnVjdCBzdHJidWYgc2lnID0gU1RSQlVGX0lOSVQ7CglpbnQgaW5zcG9zLCBjb3B5cG9zOwoKCS8qIGZpbmQgdGhlIGVuZCBvZiB0aGUgaGVhZGVyICovCglpbnNwb3MgPSBzdHJzdHIoYnVmLT5idWYsICJcblxuIikgLSBidWYtPmJ1ZiArIDE7CgoJaWYgKCFrZXlpZCB8fCAhKmtleWlkKQoJCWtleWlkID0gZ2V0X3NpZ25pbmdfa2V5KCk7CglpZiAoc2lnbl9idWZmZXIoYnVmLCAmc2lnLCBrZXlpZCkpIHsKCQlzdHJidWZfcmVsZWFzZSgmc2lnKTsKCQlyZXR1cm4gLTE7Cgl9CgoJZm9yIChjb3B5cG9zID0gMDsgc2lnLmJ1Zltjb3B5cG9zXTsgKSB7CgkJY29uc3QgY2hhciAqYm9sID0gc2lnLmJ1ZiArIGNvcHlwb3M7CgkJY29uc3QgY2hhciAqZW9sID0gc3RyY2hybnVsKGJvbCwgJ1xuJyk7CgkJaW50IGxlbiA9IChlb2wgLSBib2wpICsgISEqZW9sOwoKCQlpZiAoIWNvcHlwb3MpIHsKCQkJc3RyYnVmX2luc2VydChidWYsIGluc3BvcywgZ3BnX3NpZ19oZWFkZXIsIGdwZ19zaWdfaGVhZGVyX2xlbik7CgkJCWluc3BvcyArPSBncGdfc2lnX2hlYWRlcl9sZW47CgkJfQoJCXN0cmJ1Zl9pbnNlcnQoYnVmLCBpbnNwb3MrKywgIiAiLCAxKTsKCQlzdHJidWZfaW5zZXJ0KGJ1ZiwgaW5zcG9zLCBib2wsIGxlbik7CgkJaW5zcG9zICs9IGxlbjsKCQljb3B5cG9zICs9IGxlbjsKCX0KCXN0cmJ1Zl9yZWxlYXNlKCZzaWcpOwoJcmV0dXJuIDA7Cn0KCmludCBwYXJzZV9zaWduZWRfY29tbWl0KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsCgkJCXN0cnVjdCBzdHJidWYgKnBheWxvYWQsIHN0cnVjdCBzdHJidWYgKnNpZ25hdHVyZSkKewoJdW5zaWduZWQgbG9uZyBzaXplOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJY2hhciAqYnVmZmVyID0gcmVhZF9zaGExX2ZpbGUoc2hhMSwgJnR5cGUsICZzaXplKTsKCWludCBpbl9zaWduYXR1cmUsIHNhd19zaWduYXR1cmUgPSAtMTsKCWNoYXIgKmxpbmUsICp0YWlsOwoKCWlmICghYnVmZmVyIHx8IHR5cGUgIT0gT0JKX0NPTU1JVCkKCQlnb3RvIGNsZWFudXA7CgoJbGluZSA9IGJ1ZmZlcjsKCXRhaWwgPSBidWZmZXIgKyBzaXplOwoJaW5fc2lnbmF0dXJlID0gMDsKCXNhd19zaWduYXR1cmUgPSAwOwoJd2hpbGUgKGxpbmUgPCB0YWlsKSB7CgkJY29uc3QgY2hhciAqc2lnID0gTlVMTDsKCQljaGFyICpuZXh0ID0gbWVtY2hyKGxpbmUsICdcbicsIHRhaWwgLSBsaW5lKTsKCgkJbmV4dCA9IG5leHQgPyBuZXh0ICsgMSA6IHRhaWw7CgkJaWYgKGluX3NpZ25hdHVyZSAmJiBsaW5lWzBdID09ICcgJykKCQkJc2lnID0gbGluZSArIDE7CgkJZWxzZSBpZiAoIXByZWZpeGNtcChsaW5lLCBncGdfc2lnX2hlYWRlcikgJiYKCQkJIGxpbmVbZ3BnX3NpZ19oZWFkZXJfbGVuXSA9PSAnICcpCgkJCXNpZyA9IGxpbmUgKyBncGdfc2lnX2hlYWRlcl9sZW4gKyAxOwoJCWlmIChzaWcpIHsKCQkJc3RyYnVmX2FkZChzaWduYXR1cmUsIHNpZywgbmV4dCAtIHNpZyk7CgkJCXNhd19zaWduYXR1cmUgPSAxOwoJCQlpbl9zaWduYXR1cmUgPSAxOwoJCX0gZWxzZSB7CgkJCWlmICgqbGluZSA9PSAnXG4nKQoJCQkJLyogZHVtcCB0aGUgd2hvbGUgcmVtYWluZGVyIG9mIHRoZSBidWZmZXIgKi8KCQkJCW5leHQgPSB0YWlsOwoJCQlzdHJidWZfYWRkKHBheWxvYWQsIGxpbmUsIG5leHQgLSBsaW5lKTsKCQkJaW5fc2lnbmF0dXJlID0gMDsKCQl9CgkJbGluZSA9IG5leHQ7Cgl9CiBjbGVhbnVwOgoJZnJlZShidWZmZXIpOwoJcmV0dXJuIHNhd19zaWduYXR1cmU7Cn0KCnN0YXRpYyB2b2lkIGhhbmRsZV9zaWduZWRfdGFnKHN0cnVjdCBjb21taXQgKnBhcmVudCwgc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKioqdGFpbCkKewoJc3RydWN0IG1lcmdlX3JlbW90ZV9kZXNjICpkZXNjOwoJc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKm1lcmdldGFnOwoJY2hhciAqYnVmOwoJdW5zaWduZWQgbG9uZyBzaXplLCBsZW47CgllbnVtIG9iamVjdF90eXBlIHR5cGU7CgoJZGVzYyA9IG1lcmdlX3JlbW90ZV91dGlsKHBhcmVudCk7CglpZiAoIWRlc2MgfHwgIWRlc2MtPm9iaikKCQlyZXR1cm47CglidWYgPSByZWFkX3NoYTFfZmlsZShkZXNjLT5vYmotPnNoYTEsICZ0eXBlLCAmc2l6ZSk7CglpZiAoIWJ1ZiB8fCB0eXBlICE9IE9CSl9UQUcpCgkJZ290byBmcmVlX3JldHVybjsKCWxlbiA9IHBhcnNlX3NpZ25hdHVyZShidWYsIHNpemUpOwoJaWYgKHNpemUgPT0gbGVuKQoJCWdvdG8gZnJlZV9yZXR1cm47CgkvKgoJICogV2UgY291bGQgdmVyaWZ5IHRoaXMgc2lnbmF0dXJlIGFuZCBlaXRoZXIgb21pdCB0aGUgdGFnIHdoZW4KCSAqIGl0IGRvZXMgbm90IHZhbGlkYXRlLCBidXQgdGhlIGludGVncmF0b3IgbWF5IG5vdCBoYXZlIHRoZQoJICogcHVibGljIGtleSBvZiB0aGUgc2lnbmVyIG9mIHRoZSB0YWcgaGUgaXMgbWVyZ2luZywgd2hpbGUgYQoJICogbGF0ZXIgYXVkaXRvciBtYXkgaGF2ZSBpdCB3aGlsZSBhdWRpdGluZywgc28gbGV0J3Mgbm90IHJ1bgoJICogdmVyaWZ5LXNpZ25lZC1idWZmZXIgaGVyZSBmb3Igbm93Li4uCgkgKgoJICogaWYgKHZlcmlmeV9zaWduZWRfYnVmZmVyKGJ1ZiwgbGVuLCBidWYgKyBsZW4sIHNpemUgLSBsZW4sIC4uLikpCgkgKgl3YXJuKCJ3YXJuaW5nOiBzaWduZWQgdGFnIHVudmVyaWZpZWQuIik7CgkgKi8KCW1lcmdldGFnID0geGNhbGxvYygxLCBzaXplb2YoKm1lcmdldGFnKSk7CgltZXJnZXRhZy0+a2V5ID0geHN0cmR1cCgibWVyZ2V0YWciKTsKCW1lcmdldGFnLT52YWx1ZSA9IGJ1ZjsKCW1lcmdldGFnLT5sZW4gPSBzaXplOwoKCSoqdGFpbCA9IG1lcmdldGFnOwoJKnRhaWwgPSAmbWVyZ2V0YWctPm5leHQ7CglyZXR1cm47CgpmcmVlX3JldHVybjoKCWZyZWUoYnVmKTsKfQoKdm9pZCBhcHBlbmRfbWVyZ2VfdGFnX2hlYWRlcnMoc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzLAoJCQkgICAgICBzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqKip0YWlsKQp7Cgl3aGlsZSAocGFyZW50cykgewoJCXN0cnVjdCBjb21taXQgKnBhcmVudCA9IHBhcmVudHMtPml0ZW07CgkJaGFuZGxlX3NpZ25lZF90YWcocGFyZW50LCB0YWlsKTsKCQlwYXJlbnRzID0gcGFyZW50cy0+bmV4dDsKCX0KfQoKc3RhdGljIHZvaWQgYWRkX2V4dHJhX2hlYWRlcihzdHJ1Y3Qgc3RyYnVmICpidWZmZXIsCgkJCSAgICAgc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKmV4dHJhKQp7CglzdHJidWZfYWRkc3RyKGJ1ZmZlciwgZXh0cmEtPmtleSk7CglpZiAoZXh0cmEtPmxlbikKCQlzdHJidWZfYWRkX2xpbmVzKGJ1ZmZlciwgIiAiLCBleHRyYS0+dmFsdWUsIGV4dHJhLT5sZW4pOwoJZWxzZQoJCXN0cmJ1Zl9hZGRjaChidWZmZXIsICdcbicpOwp9CgpzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqcmVhZF9jb21taXRfZXh0cmFfaGVhZGVycyhzdHJ1Y3QgY29tbWl0ICpjb21taXQsCgkJCQkJCSAgICAgIGNvbnN0IGNoYXIgKipleGNsdWRlKQp7CglzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqZXh0cmEgPSBOVUxMOwoJdW5zaWduZWQgbG9uZyBzaXplOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJY2hhciAqYnVmZmVyID0gcmVhZF9zaGExX2ZpbGUoY29tbWl0LT5vYmplY3Quc2hhMSwgJnR5cGUsICZzaXplKTsKCWlmIChidWZmZXIgJiYgdHlwZSA9PSBPQkpfQ09NTUlUKQoJCWV4dHJhID0gcmVhZF9jb21taXRfZXh0cmFfaGVhZGVyX2xpbmVzKGJ1ZmZlciwgc2l6ZSwgZXhjbHVkZSk7CglmcmVlKGJ1ZmZlcik7CglyZXR1cm4gZXh0cmE7Cn0KCnN0YXRpYyBpbmxpbmUgaW50IHN0YW5kYXJkX2hlYWRlcl9maWVsZChjb25zdCBjaGFyICpmaWVsZCwgc2l6ZV90IGxlbikKewoJcmV0dXJuICgobGVuID09IDQgJiYgIW1lbWNtcChmaWVsZCwgInRyZWUgIiwgNSkpIHx8CgkJKGxlbiA9PSA2ICYmICFtZW1jbXAoZmllbGQsICJwYXJlbnQgIiwgNykpIHx8CgkJKGxlbiA9PSA2ICYmICFtZW1jbXAoZmllbGQsICJhdXRob3IgIiwgNykpIHx8CgkJKGxlbiA9PSA5ICYmICFtZW1jbXAoZmllbGQsICJjb21taXR0ZXIgIiwgMTApKSB8fAoJCShsZW4gPT0gOCAmJiAhbWVtY21wKGZpZWxkLCAiZW5jb2RpbmcgIiwgOSkpKTsKfQoKc3RhdGljIGludCBleGNsdWRlZF9oZWFkZXJfZmllbGQoY29uc3QgY2hhciAqZmllbGQsIHNpemVfdCBsZW4sIGNvbnN0IGNoYXIgKipleGNsdWRlKQp7CglpZiAoIWV4Y2x1ZGUpCgkJcmV0dXJuIDA7CgoJd2hpbGUgKCpleGNsdWRlKSB7CgkJc2l6ZV90IHhsZW4gPSBzdHJsZW4oKmV4Y2x1ZGUpOwoJCWlmIChsZW4gPT0geGxlbiAmJgoJCSAgICAhbWVtY21wKGZpZWxkLCAqZXhjbHVkZSwgeGxlbikgJiYgZmllbGRbeGxlbl0gPT0gJyAnKQoJCQlyZXR1cm4gMTsKCQlleGNsdWRlKys7Cgl9CglyZXR1cm4gMDsKfQoKc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKnJlYWRfY29tbWl0X2V4dHJhX2hlYWRlcl9saW5lcyhjb25zdCBjaGFyICpidWZmZXIsIHNpemVfdCBzaXplLAoJCQkJCQkJICAgY29uc3QgY2hhciAqKmV4Y2x1ZGUpCnsKCXN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpleHRyYSA9IE5VTEwsICoqdGFpbCA9ICZleHRyYSwgKml0ID0gTlVMTDsKCWNvbnN0IGNoYXIgKmxpbmUsICpuZXh0LCAqZW9mLCAqZW9iOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCglmb3IgKGxpbmUgPSBidWZmZXIsIGVvYiA9IGxpbmUgKyBzaXplOwoJICAgICBsaW5lIDwgZW9iICYmICpsaW5lICE9ICdcbic7CgkgICAgIGxpbmUgPSBuZXh0KSB7CgkJbmV4dCA9IG1lbWNocihsaW5lLCAnXG4nLCBlb2IgLSBsaW5lKTsKCQluZXh0ID0gbmV4dCA/IG5leHQgKyAxIDogZW9iOwoJCWlmICgqbGluZSA9PSAnICcpIHsKCQkJLyogY29udGludWF0aW9uICovCgkJCWlmIChpdCkKCQkJCXN0cmJ1Zl9hZGQoJmJ1ZiwgbGluZSArIDEsIG5leHQgLSAobGluZSArIDEpKTsKCQkJY29udGludWU7CgkJfQoJCWlmIChpdCkKCQkJaXQtPnZhbHVlID0gc3RyYnVmX2RldGFjaCgmYnVmLCAmaXQtPmxlbik7CgkJc3RyYnVmX3Jlc2V0KCZidWYpOwoJCWl0ID0gTlVMTDsKCgkJZW9mID0gc3RyY2hyKGxpbmUsICcgJyk7CgkJaWYgKG5leHQgPD0gZW9mKQoJCQllb2YgPSBuZXh0OwoKCQlpZiAoc3RhbmRhcmRfaGVhZGVyX2ZpZWxkKGxpbmUsIGVvZiAtIGxpbmUpIHx8CgkJICAgIGV4Y2x1ZGVkX2hlYWRlcl9maWVsZChsaW5lLCBlb2YgLSBsaW5lLCBleGNsdWRlKSkKCQkJY29udGludWU7CgoJCWl0ID0geGNhbGxvYygxLCBzaXplb2YoKml0KSk7CgkJaXQtPmtleSA9IHhtZW1kdXB6KGxpbmUsIGVvZi1saW5lKTsKCQkqdGFpbCA9IGl0OwoJCXRhaWwgPSAmaXQtPm5leHQ7CgkJaWYgKGVvZiArIDEgPCBuZXh0KQoJCQlzdHJidWZfYWRkKCZidWYsIGVvZiArIDEsIG5leHQgLSAoZW9mICsgMSkpOwoJfQoJaWYgKGl0KQoJCWl0LT52YWx1ZSA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgJml0LT5sZW4pOwoJcmV0dXJuIGV4dHJhOwp9Cgp2b2lkIGZyZWVfY29tbWl0X2V4dHJhX2hlYWRlcnMoc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKmV4dHJhKQp7Cgl3aGlsZSAoZXh0cmEpIHsKCQlzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqbmV4dCA9IGV4dHJhLT5uZXh0OwoJCWZyZWUoZXh0cmEtPmtleSk7CgkJZnJlZShleHRyYS0+dmFsdWUpOwoJCWZyZWUoZXh0cmEpOwoJCWV4dHJhID0gbmV4dDsKCX0KfQoKaW50IGNvbW1pdF90cmVlKGNvbnN0IHN0cnVjdCBzdHJidWYgKm1zZywgdW5zaWduZWQgY2hhciAqdHJlZSwKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMsIHVuc2lnbmVkIGNoYXIgKnJldCwKCQljb25zdCBjaGFyICphdXRob3IsIGNvbnN0IGNoYXIgKnNpZ25fY29tbWl0KQp7CglzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqZXh0cmEgPSBOVUxMLCAqKnRhaWwgPSAmZXh0cmE7CglpbnQgcmVzdWx0OwoKCWFwcGVuZF9tZXJnZV90YWdfaGVhZGVycyhwYXJlbnRzLCAmdGFpbCk7CglyZXN1bHQgPSBjb21taXRfdHJlZV9leHRlbmRlZChtc2csIHRyZWUsIHBhcmVudHMsIHJldCwKCQkJCSAgICAgIGF1dGhvciwgc2lnbl9jb21taXQsIGV4dHJhKTsKCWZyZWVfY29tbWl0X2V4dHJhX2hlYWRlcnMoZXh0cmEpOwoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIGNvbnN0IGNoYXIgY29tbWl0X3V0Zjhfd2FybltdID0KIldhcm5pbmc6IGNvbW1pdCBtZXNzYWdlIGRvZXMgbm90IGNvbmZvcm0gdG8gVVRGLTguXG4iCiJZb3UgbWF5IHdhbnQgdG8gYW1lbmQgaXQgYWZ0ZXIgZml4aW5nIHRoZSBtZXNzYWdlLCBvciBzZXQgdGhlIGNvbmZpZ1xuIgoidmFyaWFibGUgaTE4bi5jb21taXRlbmNvZGluZyB0byB0aGUgZW5jb2RpbmcgeW91ciBwcm9qZWN0IHVzZXMuXG4iOwoKaW50IGNvbW1pdF90cmVlX2V4dGVuZGVkKGNvbnN0IHN0cnVjdCBzdHJidWYgKm1zZywgdW5zaWduZWQgY2hhciAqdHJlZSwKCQkJIHN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50cywgdW5zaWduZWQgY2hhciAqcmV0LAoJCQkgY29uc3QgY2hhciAqYXV0aG9yLCBjb25zdCBjaGFyICpzaWduX2NvbW1pdCwKCQkJIHN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpleHRyYSkKewoJaW50IHJlc3VsdDsKCWludCBlbmNvZGluZ19pc191dGY4OwoJc3RydWN0IHN0cmJ1ZiBidWZmZXI7CgoJYXNzZXJ0X3NoYTFfdHlwZSh0cmVlLCBPQkpfVFJFRSk7CgoJaWYgKG1lbWNocihtc2ctPmJ1ZiwgJ1wwJywgbXNnLT5sZW4pKQoJCXJldHVybiBlcnJvcigiYSBOVUwgYnl0ZSBpbiBjb21taXQgbG9nIG1lc3NhZ2Ugbm90IGFsbG93ZWQuIik7CgoJLyogTm90IGhhdmluZyBpMThuLmNvbW1pdGVuY29kaW5nIGlzIHRoZSBzYW1lIGFzIGhhdmluZyB1dGYtOCAqLwoJZW5jb2RpbmdfaXNfdXRmOCA9IGlzX2VuY29kaW5nX3V0ZjgoZ2l0X2NvbW1pdF9lbmNvZGluZyk7CgoJc3RyYnVmX2luaXQoJmJ1ZmZlciwgODE5Mik7IC8qIHNob3VsZCBhdm9pZCByZWFsbG9jcyBmb3IgdGhlIGhlYWRlcnMgKi8KCXN0cmJ1Zl9hZGRmKCZidWZmZXIsICJ0cmVlICVzXG4iLCBzaGExX3RvX2hleCh0cmVlKSk7CgoJLyoKCSAqIE5PVEUhIFRoaXMgb3JkZXJpbmcgbWVhbnMgdGhhdCB0aGUgc2FtZSBleGFjdCB0cmVlIG1lcmdlZCB3aXRoIGEKCSAqIGRpZmZlcmVudCBvcmRlciBvZiBwYXJlbnRzIHdpbGwgYmUgYSBfZGlmZmVyZW50XyBjaGFuZ2VzZXQgZXZlbgoJICogaWYgZXZlcnl0aGluZyBlbHNlIHN0YXlzIHRoZSBzYW1lLgoJICovCgl3aGlsZSAocGFyZW50cykgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqbmV4dCA9IHBhcmVudHMtPm5leHQ7CgkJc3RydWN0IGNvbW1pdCAqcGFyZW50ID0gcGFyZW50cy0+aXRlbTsKCgkJc3RyYnVmX2FkZGYoJmJ1ZmZlciwgInBhcmVudCAlc1xuIiwKCQkJICAgIHNoYTFfdG9faGV4KHBhcmVudC0+b2JqZWN0LnNoYTEpKTsKCQlmcmVlKHBhcmVudHMpOwoJCXBhcmVudHMgPSBuZXh0OwoJfQoKCS8qIFBlcnNvbi9kYXRlIGluZm9ybWF0aW9uICovCglpZiAoIWF1dGhvcikKCQlhdXRob3IgPSBnaXRfYXV0aG9yX2luZm8oSURFTlRfRVJST1JfT05fTk9fTkFNRSk7CglzdHJidWZfYWRkZigmYnVmZmVyLCAiYXV0aG9yICVzXG4iLCBhdXRob3IpOwoJc3RyYnVmX2FkZGYoJmJ1ZmZlciwgImNvbW1pdHRlciAlc1xuIiwgZ2l0X2NvbW1pdHRlcl9pbmZvKElERU5UX0VSUk9SX09OX05PX05BTUUpKTsKCWlmICghZW5jb2RpbmdfaXNfdXRmOCkKCQlzdHJidWZfYWRkZigmYnVmZmVyLCAiZW5jb2RpbmcgJXNcbiIsIGdpdF9jb21taXRfZW5jb2RpbmcpOwoKCXdoaWxlIChleHRyYSkgewoJCWFkZF9leHRyYV9oZWFkZXIoJmJ1ZmZlciwgZXh0cmEpOwoJCWV4dHJhID0gZXh0cmEtPm5leHQ7Cgl9CglzdHJidWZfYWRkY2goJmJ1ZmZlciwgJ1xuJyk7CgoJLyogQW5kIGFkZCB0aGUgY29tbWVudCAqLwoJc3RyYnVmX2FkZGJ1ZigmYnVmZmVyLCBtc2cpOwoKCS8qIEFuZCBjaGVjayB0aGUgZW5jb2RpbmcgKi8KCWlmIChlbmNvZGluZ19pc191dGY4ICYmICFpc191dGY4KGJ1ZmZlci5idWYpKQoJCWZwcmludGYoc3RkZXJyLCBjb21taXRfdXRmOF93YXJuKTsKCglpZiAoc2lnbl9jb21taXQgJiYgZG9fc2lnbl9jb21taXQoJmJ1ZmZlciwgc2lnbl9jb21taXQpKQoJCXJldHVybiAtMTsKCglyZXN1bHQgPSB3cml0ZV9zaGExX2ZpbGUoYnVmZmVyLmJ1ZiwgYnVmZmVyLmxlbiwgY29tbWl0X3R5cGUsIHJldCk7CglzdHJidWZfcmVsZWFzZSgmYnVmZmVyKTsKCXJldHVybiByZXN1bHQ7Cn0KCnN0cnVjdCBjb21taXQgKmdldF9tZXJnZV9wYXJlbnQoY29uc3QgY2hhciAqbmFtZSkKewoJc3RydWN0IG9iamVjdCAqb2JqOwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCWlmIChnZXRfc2hhMShuYW1lLCBzaGExKSkKCQlyZXR1cm4gTlVMTDsKCW9iaiA9IHBhcnNlX29iamVjdChzaGExKTsKCWNvbW1pdCA9IChzdHJ1Y3QgY29tbWl0ICopcGVlbF90b190eXBlKG5hbWUsIDAsIG9iaiwgT0JKX0NPTU1JVCk7CglpZiAoY29tbWl0ICYmICFjb21taXQtPnV0aWwpIHsKCQlzdHJ1Y3QgbWVyZ2VfcmVtb3RlX2Rlc2MgKmRlc2M7CgkJZGVzYyA9IHhtYWxsb2Moc2l6ZW9mKCpkZXNjKSk7CgkJZGVzYy0+b2JqID0gb2JqOwoJCWRlc2MtPm5hbWUgPSBzdHJkdXAobmFtZSk7CgkJY29tbWl0LT51dGlsID0gZGVzYzsKCX0KCXJldHVybiBjb21taXQ7Cn0K",
    "text": "#include \"cache.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"pkt-line.h\"\n#include \"utf8.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"notes.h\"\n#include \"gpg-interface.h\"\n\nint save_commit_buffer = 1;\n\nconst char *commit_type = \"commit\";\n\nstatic struct commit *check_commit(struct object *obj,\n\t\t\t\t   const unsigned char *sha1,\n\t\t\t\t   int quiet)\n{\n\tif (obj->type != OBJ_COMMIT) {\n\t\tif (!quiet)\n\t\t\terror(\"Object %s is a %s, not a commit\",\n\t\t\t      sha1_to_hex(sha1), typename(obj->type));\n\t\treturn NULL;\n\t}\n\treturn (struct commit *) obj;\n}\n\nstruct commit *lookup_commit_reference_gently(const unsigned char *sha1,\n\t\t\t\t\t      int quiet)\n{\n\tstruct object *obj = deref_tag(parse_object(sha1), NULL, 0);\n\n\tif (!obj)\n\t\treturn NULL;\n\treturn check_commit(obj, sha1, quiet);\n}\n\nstruct commit *lookup_commit_reference(const unsigned char *sha1)\n{\n\treturn lookup_commit_reference_gently(sha1, 0);\n}\n\nstruct commit *lookup_commit_or_die(const unsigned char *sha1, const char *ref_name)\n{\n\tstruct commit *c = lookup_commit_reference(sha1);\n\tif (!c)\n\t\tdie(_(\"could not parse %s\"), ref_name);\n\tif (hashcmp(sha1, c->object.sha1)) {\n\t\twarning(_(\"%s %s is not a commit!\"),\n\t\t\tref_name, sha1_to_hex(sha1));\n\t}\n\treturn c;\n}\n\nstruct commit *lookup_commit(const unsigned char *sha1)\n{\n\tstruct object *obj = lookup_object(sha1);\n\tif (!obj)\n\t\treturn create_object(sha1, OBJ_COMMIT, alloc_commit_node());\n\tif (!obj->type)\n\t\tobj->type = OBJ_COMMIT;\n\treturn check_commit(obj, sha1, 0);\n}\n\nstruct commit *lookup_commit_reference_by_name(const char *name)\n{\n\tunsigned char sha1[20];\n\tstruct commit *commit;\n\n\tif (get_sha1(name, sha1))\n\t\treturn NULL;\n\tcommit = lookup_commit_reference(sha1);\n\tif (!commit || parse_commit(commit))\n\t\treturn NULL;\n\treturn commit;\n}\n\nstatic unsigned long parse_commit_date(const char *buf, const char *tail)\n{\n\tconst char *dateptr;\n\n\tif (buf + 6 >= tail)\n\t\treturn 0;\n\tif (memcmp(buf, \"author\", 6))\n\t\treturn 0;\n\twhile (buf < tail && *buf++ != '\\n')\n\t\t/* nada */;\n\tif (buf + 9 >= tail)\n\t\treturn 0;\n\tif (memcmp(buf, \"committer\", 9))\n\t\treturn 0;\n\twhile (buf < tail && *buf++ != '>')\n\t\t/* nada */;\n\tif (buf >= tail)\n\t\treturn 0;\n\tdateptr = buf;\n\twhile (buf < tail && *buf++ != '\\n')\n\t\t/* nada */;\n\tif (buf >= tail)\n\t\treturn 0;\n\t/* dateptr < buf && buf[-1] == '\\n', so strtoul will stop at buf-1 */\n\treturn strtoul(dateptr, NULL, 10);\n}\n\nstatic struct commit_graft **commit_graft;\nstatic int commit_graft_alloc, commit_graft_nr;\n\nstatic int commit_graft_pos(const unsigned char *sha1)\n{\n\tint lo, hi;\n\tlo = 0;\n\thi = commit_graft_nr;\n\twhile (lo < hi) {\n\t\tint mi = (lo + hi) / 2;\n\t\tstruct commit_graft *graft = commit_graft[mi];\n\t\tint cmp = hashcmp(sha1, graft->sha1);\n\t\tif (!cmp)\n\t\t\treturn mi;\n\t\tif (cmp < 0)\n\t\t\thi = mi;\n\t\telse\n\t\t\tlo = mi + 1;\n\t}\n\treturn -lo - 1;\n}\n\nint register_commit_graft(struct commit_graft *graft, int ignore_dups)\n{\n\tint pos = commit_graft_pos(graft->sha1);\n\n\tif (0 <= pos) {\n\t\tif (ignore_dups)\n\t\t\tfree(graft);\n\t\telse {\n\t\t\tfree(commit_graft[pos]);\n\t\t\tcommit_graft[pos] = graft;\n\t\t}\n\t\treturn 1;\n\t}\n\tpos = -pos - 1;\n\tif (commit_graft_alloc <= ++commit_graft_nr) {\n\t\tcommit_graft_alloc = alloc_nr(commit_graft_alloc);\n\t\tcommit_graft = xrealloc(commit_graft,\n\t\t\t\t\tsizeof(*commit_graft) *\n\t\t\t\t\tcommit_graft_alloc);\n\t}\n\tif (pos < commit_graft_nr)\n\t\tmemmove(commit_graft + pos + 1,\n\t\t\tcommit_graft + pos,\n\t\t\t(commit_graft_nr - pos - 1) *\n\t\t\tsizeof(*commit_graft));\n\tcommit_graft[pos] = graft;\n\treturn 0;\n}\n\nstruct commit_graft *read_graft_line(char *buf, int len)\n{\n\t/* The format is just \"Commit Parent1 Parent2 ...\\n\" */\n\tint i;\n\tstruct commit_graft *graft = NULL;\n\n\twhile (len && isspace(buf[len-1]))\n\t\tbuf[--len] = '\\0';\n\tif (buf[0] == '#' || buf[0] == '\\0')\n\t\treturn NULL;\n\tif ((len + 1) % 41)\n\t\tgoto bad_graft_data;\n\ti = (len + 1) / 41 - 1;\n\tgraft = xmalloc(sizeof(*graft) + 20 * i);\n\tgraft->nr_parent = i;\n\tif (get_sha1_hex(buf, graft->sha1))\n\t\tgoto bad_graft_data;\n\tfor (i = 40; i < len; i += 41) {\n\t\tif (buf[i] != ' ')\n\t\t\tgoto bad_graft_data;\n\t\tif (get_sha1_hex(buf + i + 1, graft->parent[i/41]))\n\t\t\tgoto bad_graft_data;\n\t}\n\treturn graft;\n\nbad_graft_data:\n\terror(\"bad graft data: %s\", buf);\n\tfree(graft);\n\treturn NULL;\n}\n\nstatic int read_graft_file(const char *graft_file)\n{\n\tFILE *fp = fopen(graft_file, \"r\");\n\tchar buf[1024];\n\tif (!fp)\n\t\treturn -1;\n\twhile (fgets(buf, sizeof(buf), fp)) {\n\t\t/* The format is just \"Commit Parent1 Parent2 ...\\n\" */\n\t\tint len = strlen(buf);\n\t\tstruct commit_graft *graft = read_graft_line(buf, len);\n\t\tif (!graft)\n\t\t\tcontinue;\n\t\tif (register_commit_graft(graft, 1))\n\t\t\terror(\"duplicate graft data: %s\", buf);\n\t}\n\tfclose(fp);\n\treturn 0;\n}\n\nstatic void prepare_commit_graft(void)\n{\n\tstatic int commit_graft_prepared;\n\tchar *graft_file;\n\n\tif (commit_graft_prepared)\n\t\treturn;\n\tgraft_file = get_graft_file();\n\tread_graft_file(graft_file);\n\t/* make sure shallows are read */\n\tis_repository_shallow();\n\tcommit_graft_prepared = 1;\n}\n\nstruct commit_graft *lookup_commit_graft(const unsigned char *sha1)\n{\n\tint pos;\n\tprepare_commit_graft();\n\tpos = commit_graft_pos(sha1);\n\tif (pos < 0)\n\t\treturn NULL;\n\treturn commit_graft[pos];\n}\n\nint for_each_commit_graft(each_commit_graft_fn fn, void *cb_data)\n{\n\tint i, ret;\n\tfor (i = ret = 0; i < commit_graft_nr && !ret; i++)\n\t\tret = fn(commit_graft[i], cb_data);\n\treturn ret;\n}\n\nint unregister_shallow(const unsigned char *sha1)\n{\n\tint pos = commit_graft_pos(sha1);\n\tif (pos < 0)\n\t\treturn -1;\n\tif (pos + 1 < commit_graft_nr)\n\t\tmemmove(commit_graft + pos, commit_graft + pos + 1,\n\t\t\t\tsizeof(struct commit_graft *)\n\t\t\t\t* (commit_graft_nr - pos - 1));\n\tcommit_graft_nr--;\n\treturn 0;\n}\n\nint parse_commit_buffer(struct commit *item, const void *buffer, unsigned long size)\n{\n\tconst char *tail = buffer;\n\tconst char *bufptr = buffer;\n\tunsigned char parent[20];\n\tstruct commit_list **pptr;\n\tstruct commit_graft *graft;\n\n\tif (item->object.parsed)\n\t\treturn 0;\n\titem->object.parsed = 1;\n\ttail += size;\n\tif (tail <= bufptr + 46 || memcmp(bufptr, \"tree \", 5) || bufptr[45] != '\\n')\n\t\treturn error(\"bogus commit object %s\", sha1_to_hex(item->object.sha1));\n\tif (get_sha1_hex(bufptr + 5, parent) < 0)\n\t\treturn error(\"bad tree pointer in commit %s\",\n\t\t\t     sha1_to_hex(item->object.sha1));\n\titem->tree = lookup_tree(parent);\n\tbufptr += 46; /* \"tree \" + \"hex sha1\" + \"\\n\" */\n\tpptr = &item->parents;\n\n\tgraft = lookup_commit_graft(item->object.sha1);\n\twhile (bufptr + 48 < tail && !memcmp(bufptr, \"parent \", 7)) {\n\t\tstruct commit *new_parent;\n\n\t\tif (tail <= bufptr + 48 ||\n\t\t    get_sha1_hex(bufptr + 7, parent) ||\n\t\t    bufptr[47] != '\\n')\n\t\t\treturn error(\"bad parents in commit %s\", sha1_to_hex(item->object.sha1));\n\t\tbufptr += 48;\n\t\t/*\n\t\t * The clone is shallow if nr_parent < 0, and we must\n\t\t * not traverse its real parents even when we unhide them.\n\t\t */\n\t\tif (graft && (graft->nr_parent < 0 || grafts_replace_parents))\n\t\t\tcontinue;\n\t\tnew_parent = lookup_commit(parent);\n\t\tif (new_parent)\n\t\t\tpptr = &commit_list_insert(new_parent, pptr)->next;\n\t}\n\tif (graft) {\n\t\tint i;\n\t\tstruct commit *new_parent;\n\t\tfor (i = 0; i < graft->nr_parent; i++) {\n\t\t\tnew_parent = lookup_commit(graft->parent[i]);\n\t\t\tif (!new_parent)\n\t\t\t\tcontinue;\n\t\t\tpptr = &commit_list_insert(new_parent, pptr)->next;\n\t\t}\n\t}\n\titem->date = parse_commit_date(bufptr, tail);\n\n\treturn 0;\n}\n\nint parse_commit(struct commit *item)\n{\n\tenum object_type type;\n\tvoid *buffer;\n\tunsigned long size;\n\tint ret;\n\n\tif (!item)\n\t\treturn -1;\n\tif (item->object.parsed)\n\t\treturn 0;\n\tbuffer = read_sha1_file(item->object.sha1, &type, &size);\n\tif (!buffer)\n\t\treturn error(\"Could not read %s\",\n\t\t\t     sha1_to_hex(item->object.sha1));\n\tif (type != OBJ_COMMIT) {\n\t\tfree(buffer);\n\t\treturn error(\"Object %s not a commit\",\n\t\t\t     sha1_to_hex(item->object.sha1));\n\t}\n\tret = parse_commit_buffer(item, buffer, size);\n\tif (save_commit_buffer && !ret) {\n\t\titem->buffer = buffer;\n\t\treturn 0;\n\t}\n\tfree(buffer);\n\treturn ret;\n}\n\nint find_commit_subject(const char *commit_buffer, const char **subject)\n{\n\tconst char *eol;\n\tconst char *p = commit_buffer;\n\n\twhile (*p && (*p != '\\n' || p[1] != '\\n'))\n\t\tp++;\n\tif (*p) {\n\t\tp += 2;\n\t\tfor (eol = p; *eol && *eol != '\\n'; eol++)\n\t\t\t; /* do nothing */\n\t} else\n\t\teol = p;\n\n\t*subject = p;\n\n\treturn eol - p;\n}\n\nstruct commit_list *commit_list_insert(struct commit *item, struct commit_list **list_p)\n{\n\tstruct commit_list *new_list = xmalloc(sizeof(struct commit_list));\n\tnew_list->item = item;\n\tnew_list->next = *list_p;\n\t*list_p = new_list;\n\treturn new_list;\n}\n\nunsigned commit_list_count(const struct commit_list *l)\n{\n\tunsigned c = 0;\n\tfor (; l; l = l->next )\n\t\tc++;\n\treturn c;\n}\n\nvoid free_commit_list(struct commit_list *list)\n{\n\twhile (list) {\n\t\tstruct commit_list *temp = list;\n\t\tlist = temp->next;\n\t\tfree(temp);\n\t}\n}\n\nstruct commit_list * commit_list_insert_by_date(struct commit *item, struct commit_list **list)\n{\n\tstruct commit_list **pp = list;\n\tstruct commit_list *p;\n\twhile ((p = *pp) != NULL) {\n\t\tif (p->item->date < item->date) {\n\t\t\tbreak;\n\t\t}\n\t\tpp = &p->next;\n\t}\n\treturn commit_list_insert(item, pp);\n}\n\n\nvoid commit_list_sort_by_date(struct commit_list **list)\n{\n\tstruct commit_list *ret = NULL;\n\twhile (*list) {\n\t\tcommit_list_insert_by_date((*list)->item, &ret);\n\t\t*list = (*list)->next;\n\t}\n\t*list = ret;\n}\n\nstruct commit *pop_most_recent_commit(struct commit_list **list,\n\t\t\t\t      unsigned int mark)\n{\n\tstruct commit *ret = (*list)->item;\n\tstruct commit_list *parents = ret->parents;\n\tstruct commit_list *old = *list;\n\n\t*list = (*list)->next;\n\tfree(old);\n\n\twhile (parents) {\n\t\tstruct commit *commit = parents->item;\n\t\tif (!parse_commit(commit) && !(commit->object.flags & mark)) {\n\t\t\tcommit->object.flags |= mark;\n\t\t\tcommit_list_insert_by_date(commit, list);\n\t\t}\n\t\tparents = parents->next;\n\t}\n\treturn ret;\n}\n\nvoid clear_commit_marks(struct commit *commit, unsigned int mark)\n{\n\twhile (commit) {\n\t\tstruct commit_list *parents;\n\n\t\tif (!(mark & commit->object.flags))\n\t\t\treturn;\n\n\t\tcommit->object.flags &= ~mark;\n\n\t\tparents = commit->parents;\n\t\tif (!parents)\n\t\t\treturn;\n\n\t\twhile ((parents = parents->next))\n\t\t\tclear_commit_marks(parents->item, mark);\n\n\t\tcommit = commit->parents->item;\n\t}\n}\n\nvoid clear_commit_marks_for_object_array(struct object_array *a, unsigned mark)\n{\n\tstruct object *object;\n\tstruct commit *commit;\n\tunsigned int i;\n\n\tfor (i = 0; i < a->nr; i++) {\n\t\tobject = a->objects[i].item;\n\t\tcommit = lookup_commit_reference_gently(object->sha1, 1);\n\t\tif (commit)\n\t\t\tclear_commit_marks(commit, mark);\n\t}\n}\n\nstruct commit *pop_commit(struct commit_list **stack)\n{\n\tstruct commit_list *top = *stack;\n\tstruct commit *item = top ? top->item : NULL;\n\n\tif (top) {\n\t\t*stack = top->next;\n\t\tfree(top);\n\t}\n\treturn item;\n}\n\n/*\n * Performs an in-place topological sort on the list supplied.\n */\nvoid sort_in_topological_order(struct commit_list ** list, int lifo)\n{\n\tstruct commit_list *next, *orig = *list;\n\tstruct commit_list *work, **insert;\n\tstruct commit_list **pptr;\n\n\tif (!orig)\n\t\treturn;\n\t*list = NULL;\n\n\t/* Mark them and clear the indegree */\n\tfor (next = orig; next; next = next->next) {\n\t\tstruct commit *commit = next->item;\n\t\tcommit->indegree = 1;\n\t}\n\n\t/* update the indegree */\n\tfor (next = orig; next; next = next->next) {\n\t\tstruct commit_list * parents = next->item->parents;\n\t\twhile (parents) {\n\t\t\tstruct commit *parent = parents->item;\n\n\t\t\tif (parent->indegree)\n\t\t\t\tparent->indegree++;\n\t\t\tparents = parents->next;\n\t\t}\n\t}\n\n\t/*\n\t * find the tips\n\t *\n\t * tips are nodes not reachable from any other node in the list\n\t *\n\t * the tips serve as a starting set for the work queue.\n\t */\n\twork = NULL;\n\tinsert = &work;\n\tfor (next = orig; next; next = next->next) {\n\t\tstruct commit *commit = next->item;\n\n\t\tif (commit->indegree == 1)\n\t\t\tinsert = &commit_list_insert(commit, insert)->next;\n\t}\n\n\t/* process the list in topological order */\n\tif (!lifo)\n\t\tcommit_list_sort_by_date(&work);\n\n\tpptr = list;\n\t*list = NULL;\n\twhile (work) {\n\t\tstruct commit *commit;\n\t\tstruct commit_list *parents, *work_item;\n\n\t\twork_item = work;\n\t\twork = work_item->next;\n\t\twork_item->next = NULL;\n\n\t\tcommit = work_item->item;\n\t\tfor (parents = commit->parents; parents ; parents = parents->next) {\n\t\t\tstruct commit *parent = parents->item;\n\n\t\t\tif (!parent->indegree)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * parents are only enqueued for emission\n\t\t\t * when all their children have been emitted thereby\n\t\t\t * guaranteeing topological order.\n\t\t\t */\n\t\t\tif (--parent->indegree == 1) {\n\t\t\t\tif (!lifo)\n\t\t\t\t\tcommit_list_insert_by_date(parent, &work);\n\t\t\t\telse\n\t\t\t\t\tcommit_list_insert(parent, &work);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * work_item is a commit all of whose children\n\t\t * have already been emitted. we can emit it now.\n\t\t */\n\t\tcommit->indegree = 0;\n\t\t*pptr = work_item;\n\t\tpptr = &work_item->next;\n\t}\n}\n\n/* merge-base stuff */\n\n/* bits #0..15 in revision.h */\n#define PARENT1\t\t(1u<<16)\n#define PARENT2\t\t(1u<<17)\n#define STALE\t\t(1u<<18)\n#define RESULT\t\t(1u<<19)\n\nstatic const unsigned all_flags = (PARENT1 | PARENT2 | STALE | RESULT);\n\nstatic struct commit *interesting(struct commit_list *list)\n{\n\twhile (list) {\n\t\tstruct commit *commit = list->item;\n\t\tlist = list->next;\n\t\tif (commit->object.flags & STALE)\n\t\t\tcontinue;\n\t\treturn commit;\n\t}\n\treturn NULL;\n}\n\nstatic struct commit_list *paint_down_to_common(struct commit *one, int n, struct commit **twos)\n{\n\tstruct commit_list *list = NULL;\n\tstruct commit_list *result = NULL;\n\tint i;\n\n\tone->object.flags |= PARENT1;\n\tcommit_list_insert_by_date(one, &list);\n\tfor (i = 0; i < n; i++) {\n\t\ttwos[i]->object.flags |= PARENT2;\n\t\tcommit_list_insert_by_date(twos[i], &list);\n\t}\n\n\twhile (interesting(list)) {\n\t\tstruct commit *commit;\n\t\tstruct commit_list *parents;\n\t\tstruct commit_list *next;\n\t\tint flags;\n\n\t\tcommit = list->item;\n\t\tnext = list->next;\n\t\tfree(list);\n\t\tlist = next;\n\n\t\tflags = commit->object.flags & (PARENT1 | PARENT2 | STALE);\n\t\tif (flags == (PARENT1 | PARENT2)) {\n\t\t\tif (!(commit->object.flags & RESULT)) {\n\t\t\t\tcommit->object.flags |= RESULT;\n\t\t\t\tcommit_list_insert_by_date(commit, &result);\n\t\t\t}\n\t\t\t/* Mark parents of a found merge stale */\n\t\t\tflags |= STALE;\n\t\t}\n\t\tparents = commit->parents;\n\t\twhile (parents) {\n\t\t\tstruct commit *p = parents->item;\n\t\t\tparents = parents->next;\n\t\t\tif ((p->object.flags & flags) == flags)\n\t\t\t\tcontinue;\n\t\t\tif (parse_commit(p))\n\t\t\t\treturn NULL;\n\t\t\tp->object.flags |= flags;\n\t\t\tcommit_list_insert_by_date(p, &list);\n\t\t}\n\t}\n\n\tfree_commit_list(list);\n\treturn result;\n}\n\nstatic struct commit_list *merge_bases_many(struct commit *one, int n, struct commit **twos)\n{\n\tstruct commit_list *list = NULL;\n\tstruct commit_list *result = NULL;\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (one == twos[i])\n\t\t\t/*\n\t\t\t * We do not mark this even with RESULT so we do not\n\t\t\t * have to clean it up.\n\t\t\t */\n\t\t\treturn commit_list_insert(one, &result);\n\t}\n\n\tif (parse_commit(one))\n\t\treturn NULL;\n\tfor (i = 0; i < n; i++) {\n\t\tif (parse_commit(twos[i]))\n\t\t\treturn NULL;\n\t}\n\n\tlist = paint_down_to_common(one, n, twos);\n\n\twhile (list) {\n\t\tstruct commit_list *next = list->next;\n\t\tif (!(list->item->object.flags & STALE))\n\t\t\tcommit_list_insert_by_date(list->item, &result);\n\t\tfree(list);\n\t\tlist = next;\n\t}\n\treturn result;\n}\n\nstruct commit_list *get_octopus_merge_bases(struct commit_list *in)\n{\n\tstruct commit_list *i, *j, *k, *ret = NULL;\n\tstruct commit_list **pptr = &ret;\n\n\tfor (i = in; i; i = i->next) {\n\t\tif (!ret)\n\t\t\tpptr = &commit_list_insert(i->item, pptr)->next;\n\t\telse {\n\t\t\tstruct commit_list *new = NULL, *end = NULL;\n\n\t\t\tfor (j = ret; j; j = j->next) {\n\t\t\t\tstruct commit_list *bases;\n\t\t\t\tbases = get_merge_bases(i->item, j->item, 1);\n\t\t\t\tif (!new)\n\t\t\t\t\tnew = bases;\n\t\t\t\telse\n\t\t\t\t\tend->next = bases;\n\t\t\t\tfor (k = bases; k; k = k->next)\n\t\t\t\t\tend = k;\n\t\t\t}\n\t\t\tret = new;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstruct commit_list *get_merge_bases_many(struct commit *one,\n\t\t\t\t\t int n,\n\t\t\t\t\t struct commit **twos,\n\t\t\t\t\t int cleanup)\n{\n\tstruct commit_list *list;\n\tstruct commit **rslt;\n\tstruct commit_list *result;\n\tint cnt, i, j;\n\n\tresult = merge_bases_many(one, n, twos);\n\tfor (i = 0; i < n; i++) {\n\t\tif (one == twos[i])\n\t\t\treturn result;\n\t}\n\tif (!result || !result->next) {\n\t\tif (cleanup) {\n\t\t\tclear_commit_marks(one, all_flags);\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\tclear_commit_marks(twos[i], all_flags);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/* There are more than one */\n\tcnt = 0;\n\tlist = result;\n\twhile (list) {\n\t\tlist = list->next;\n\t\tcnt++;\n\t}\n\trslt = xcalloc(cnt, sizeof(*rslt));\n\tfor (list = result, i = 0; list; list = list->next)\n\t\trslt[i++] = list->item;\n\tfree_commit_list(result);\n\n\tclear_commit_marks(one, all_flags);\n\tfor (i = 0; i < n; i++)\n\t\tclear_commit_marks(twos[i], all_flags);\n\tfor (i = 0; i < cnt - 1; i++) {\n\t\tfor (j = i+1; j < cnt; j++) {\n\t\t\tif (!rslt[i] || !rslt[j])\n\t\t\t\tcontinue;\n\t\t\tresult = merge_bases_many(rslt[i], 1, &rslt[j]);\n\t\t\tclear_commit_marks(rslt[i], all_flags);\n\t\t\tclear_commit_marks(rslt[j], all_flags);\n\t\t\tfor (list = result; list; list = list->next) {\n\t\t\t\tif (rslt[i] == list->item)\n\t\t\t\t\trslt[i] = NULL;\n\t\t\t\tif (rslt[j] == list->item)\n\t\t\t\t\trslt[j] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Surviving ones in rslt[] are the independent results */\n\tresult = NULL;\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (rslt[i])\n\t\t\tcommit_list_insert_by_date(rslt[i], &result);\n\t}\n\tfree(rslt);\n\treturn result;\n}\n\nstruct commit_list *get_merge_bases(struct commit *one, struct commit *two,\n\t\t\t\t    int cleanup)\n{\n\treturn get_merge_bases_many(one, 1, &two, cleanup);\n}\n\n/*\n * Is \"commit\" a decendant of one of the elements on the \"with_commit\" list?\n */\nint is_descendant_of(struct commit *commit, struct commit_list *with_commit)\n{\n\tif (!with_commit)\n\t\treturn 1;\n\twhile (with_commit) {\n\t\tstruct commit *other;\n\n\t\tother = with_commit->item;\n\t\twith_commit = with_commit->next;\n\t\tif (in_merge_bases(other, commit))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Is \"commit\" an ancestor of (i.e. reachable from) the \"reference\"?\n */\nint in_merge_bases(struct commit *commit, struct commit *reference)\n{\n\tstruct commit_list *bases, *b;\n\tint ret = 0;\n\n\tbases = merge_bases_many(commit, 1, &reference);\n\tclear_commit_marks(commit, all_flags);\n\tclear_commit_marks(reference, all_flags);\n\n\tfor (b = bases; b; b = b->next) {\n\t\tif (!hashcmp(commit->object.sha1, b->item->object.sha1)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree_commit_list(bases);\n\treturn ret;\n}\n\nstruct commit_list *reduce_heads(struct commit_list *heads)\n{\n\tstruct commit_list *p;\n\tstruct commit_list *result = NULL, **tail = &result;\n\tstruct commit **other;\n\tsize_t num_head, num_other;\n\n\tif (!heads)\n\t\treturn NULL;\n\n\t/* Avoid unnecessary reallocations */\n\tfor (p = heads, num_head = 0; p; p = p->next)\n\t\tnum_head++;\n\tother = xcalloc(sizeof(*other), num_head);\n\n\t/* For each commit, see if it can be reached by others */\n\tfor (p = heads; p; p = p->next) {\n\t\tstruct commit_list *q, *base;\n\n\t\t/* Do we already have this in the result? */\n\t\tfor (q = result; q; q = q->next)\n\t\t\tif (p->item == q->item)\n\t\t\t\tbreak;\n\t\tif (q)\n\t\t\tcontinue;\n\n\t\tnum_other = 0;\n\t\tfor (q = heads; q; q = q->next) {\n\t\t\tif (p->item == q->item)\n\t\t\t\tcontinue;\n\t\t\tother[num_other++] = q->item;\n\t\t}\n\t\tif (num_other)\n\t\t\tbase = get_merge_bases_many(p->item, num_other, other, 1);\n\t\telse\n\t\t\tbase = NULL;\n\t\t/*\n\t\t * If p->item does not have anything common with other\n\t\t * commits, there won't be any merge base.  If it is\n\t\t * reachable from some of the others, p->item will be\n\t\t * the merge base.  If its history is connected with\n\t\t * others, but p->item is not reachable by others, we\n\t\t * will get something other than p->item back.\n\t\t */\n\t\tif (!base || (base->item != p->item))\n\t\t\ttail = &(commit_list_insert(p->item, tail)->next);\n\t\tfree_commit_list(base);\n\t}\n\tfree(other);\n\treturn result;\n}\n\nstatic const char gpg_sig_header[] = \"gpgsig\";\nstatic const int gpg_sig_header_len = sizeof(gpg_sig_header) - 1;\n\nstatic int do_sign_commit(struct strbuf *buf, const char *keyid)\n{\n\tstruct strbuf sig = STRBUF_INIT;\n\tint inspos, copypos;\n\n\t/* find the end of the header */\n\tinspos = strstr(buf->buf, \"\\n\\n\") - buf->buf + 1;\n\n\tif (!keyid || !*keyid)\n\t\tkeyid = get_signing_key();\n\tif (sign_buffer(buf, &sig, keyid)) {\n\t\tstrbuf_release(&sig);\n\t\treturn -1;\n\t}\n\n\tfor (copypos = 0; sig.buf[copypos]; ) {\n\t\tconst char *bol = sig.buf + copypos;\n\t\tconst char *eol = strchrnul(bol, '\\n');\n\t\tint len = (eol - bol) + !!*eol;\n\n\t\tif (!copypos) {\n\t\t\tstrbuf_insert(buf, inspos, gpg_sig_header, gpg_sig_header_len);\n\t\t\tinspos += gpg_sig_header_len;\n\t\t}\n\t\tstrbuf_insert(buf, inspos++, \" \", 1);\n\t\tstrbuf_insert(buf, inspos, bol, len);\n\t\tinspos += len;\n\t\tcopypos += len;\n\t}\n\tstrbuf_release(&sig);\n\treturn 0;\n}\n\nint parse_signed_commit(const unsigned char *sha1,\n\t\t\tstruct strbuf *payload, struct strbuf *signature)\n{\n\tunsigned long size;\n\tenum object_type type;\n\tchar *buffer = read_sha1_file(sha1, &type, &size);\n\tint in_signature, saw_signature = -1;\n\tchar *line, *tail;\n\n\tif (!buffer || type != OBJ_COMMIT)\n\t\tgoto cleanup;\n\n\tline = buffer;\n\ttail = buffer + size;\n\tin_signature = 0;\n\tsaw_signature = 0;\n\twhile (line < tail) {\n\t\tconst char *sig = NULL;\n\t\tchar *next = memchr(line, '\\n', tail - line);\n\n\t\tnext = next ? next + 1 : tail;\n\t\tif (in_signature && line[0] == ' ')\n\t\t\tsig = line + 1;\n\t\telse if (!prefixcmp(line, gpg_sig_header) &&\n\t\t\t line[gpg_sig_header_len] == ' ')\n\t\t\tsig = line + gpg_sig_header_len + 1;\n\t\tif (sig) {\n\t\t\tstrbuf_add(signature, sig, next - sig);\n\t\t\tsaw_signature = 1;\n\t\t\tin_signature = 1;\n\t\t} else {\n\t\t\tif (*line == '\\n')\n\t\t\t\t/* dump the whole remainder of the buffer */\n\t\t\t\tnext = tail;\n\t\t\tstrbuf_add(payload, line, next - line);\n\t\t\tin_signature = 0;\n\t\t}\n\t\tline = next;\n\t}\n cleanup:\n\tfree(buffer);\n\treturn saw_signature;\n}\n\nstatic void handle_signed_tag(struct commit *parent, struct commit_extra_header ***tail)\n{\n\tstruct merge_remote_desc *desc;\n\tstruct commit_extra_header *mergetag;\n\tchar *buf;\n\tunsigned long size, len;\n\tenum object_type type;\n\n\tdesc = merge_remote_util(parent);\n\tif (!desc || !desc->obj)\n\t\treturn;\n\tbuf = read_sha1_file(desc->obj->sha1, &type, &size);\n\tif (!buf || type != OBJ_TAG)\n\t\tgoto free_return;\n\tlen = parse_signature(buf, size);\n\tif (size == len)\n\t\tgoto free_return;\n\t/*\n\t * We could verify this signature and either omit the tag when\n\t * it does not validate, but the integrator may not have the\n\t * public key of the signer of the tag he is merging, while a\n\t * later auditor may have it while auditing, so let's not run\n\t * verify-signed-buffer here for now...\n\t *\n\t * if (verify_signed_buffer(buf, len, buf + len, size - len, ...))\n\t *\twarn(\"warning: signed tag unverified.\");\n\t */\n\tmergetag = xcalloc(1, sizeof(*mergetag));\n\tmergetag->key = xstrdup(\"mergetag\");\n\tmergetag->value = buf;\n\tmergetag->len = size;\n\n\t**tail = mergetag;\n\t*tail = &mergetag->next;\n\treturn;\n\nfree_return:\n\tfree(buf);\n}\n\nvoid append_merge_tag_headers(struct commit_list *parents,\n\t\t\t      struct commit_extra_header ***tail)\n{\n\twhile (parents) {\n\t\tstruct commit *parent = parents->item;\n\t\thandle_signed_tag(parent, tail);\n\t\tparents = parents->next;\n\t}\n}\n\nstatic void add_extra_header(struct strbuf *buffer,\n\t\t\t     struct commit_extra_header *extra)\n{\n\tstrbuf_addstr(buffer, extra->key);\n\tif (extra->len)\n\t\tstrbuf_add_lines(buffer, \" \", extra->value, extra->len);\n\telse\n\t\tstrbuf_addch(buffer, '\\n');\n}\n\nstruct commit_extra_header *read_commit_extra_headers(struct commit *commit,\n\t\t\t\t\t\t      const char **exclude)\n{\n\tstruct commit_extra_header *extra = NULL;\n\tunsigned long size;\n\tenum object_type type;\n\tchar *buffer = read_sha1_file(commit->object.sha1, &type, &size);\n\tif (buffer && type == OBJ_COMMIT)\n\t\textra = read_commit_extra_header_lines(buffer, size, exclude);\n\tfree(buffer);\n\treturn extra;\n}\n\nstatic inline int standard_header_field(const char *field, size_t len)\n{\n\treturn ((len == 4 && !memcmp(field, \"tree \", 5)) ||\n\t\t(len == 6 && !memcmp(field, \"parent \", 7)) ||\n\t\t(len == 6 && !memcmp(field, \"author \", 7)) ||\n\t\t(len == 9 && !memcmp(field, \"committer \", 10)) ||\n\t\t(len == 8 && !memcmp(field, \"encoding \", 9)));\n}\n\nstatic int excluded_header_field(const char *field, size_t len, const char **exclude)\n{\n\tif (!exclude)\n\t\treturn 0;\n\n\twhile (*exclude) {\n\t\tsize_t xlen = strlen(*exclude);\n\t\tif (len == xlen &&\n\t\t    !memcmp(field, *exclude, xlen) && field[xlen] == ' ')\n\t\t\treturn 1;\n\t\texclude++;\n\t}\n\treturn 0;\n}\n\nstruct commit_extra_header *read_commit_extra_header_lines(const char *buffer, size_t size,\n\t\t\t\t\t\t\t   const char **exclude)\n{\n\tstruct commit_extra_header *extra = NULL, **tail = &extra, *it = NULL;\n\tconst char *line, *next, *eof, *eob;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tfor (line = buffer, eob = line + size;\n\t     line < eob && *line != '\\n';\n\t     line = next) {\n\t\tnext = memchr(line, '\\n', eob - line);\n\t\tnext = next ? next + 1 : eob;\n\t\tif (*line == ' ') {\n\t\t\t/* continuation */\n\t\t\tif (it)\n\t\t\t\tstrbuf_add(&buf, line + 1, next - (line + 1));\n\t\t\tcontinue;\n\t\t}\n\t\tif (it)\n\t\t\tit->value = strbuf_detach(&buf, &it->len);\n\t\tstrbuf_reset(&buf);\n\t\tit = NULL;\n\n\t\teof = strchr(line, ' ');\n\t\tif (next <= eof)\n\t\t\teof = next;\n\n\t\tif (standard_header_field(line, eof - line) ||\n\t\t    excluded_header_field(line, eof - line, exclude))\n\t\t\tcontinue;\n\n\t\tit = xcalloc(1, sizeof(*it));\n\t\tit->key = xmemdupz(line, eof-line);\n\t\t*tail = it;\n\t\ttail = &it->next;\n\t\tif (eof + 1 < next)\n\t\t\tstrbuf_add(&buf, eof + 1, next - (eof + 1));\n\t}\n\tif (it)\n\t\tit->value = strbuf_detach(&buf, &it->len);\n\treturn extra;\n}\n\nvoid free_commit_extra_headers(struct commit_extra_header *extra)\n{\n\twhile (extra) {\n\t\tstruct commit_extra_header *next = extra->next;\n\t\tfree(extra->key);\n\t\tfree(extra->value);\n\t\tfree(extra);\n\t\textra = next;\n\t}\n}\n\nint commit_tree(const struct strbuf *msg, unsigned char *tree,\n\t\tstruct commit_list *parents, unsigned char *ret,\n\t\tconst char *author, const char *sign_commit)\n{\n\tstruct commit_extra_header *extra = NULL, **tail = &extra;\n\tint result;\n\n\tappend_merge_tag_headers(parents, &tail);\n\tresult = commit_tree_extended(msg, tree, parents, ret,\n\t\t\t\t      author, sign_commit, extra);\n\tfree_commit_extra_headers(extra);\n\treturn result;\n}\n\nstatic const char commit_utf8_warn[] =\n\"Warning: commit message does not conform to UTF-8.\\n\"\n\"You may want to amend it after fixing the message, or set the config\\n\"\n\"variable i18n.commitencoding to the encoding your project uses.\\n\";\n\nint commit_tree_extended(const struct strbuf *msg, unsigned char *tree,\n\t\t\t struct commit_list *parents, unsigned char *ret,\n\t\t\t const char *author, const char *sign_commit,\n\t\t\t struct commit_extra_header *extra)\n{\n\tint result;\n\tint encoding_is_utf8;\n\tstruct strbuf buffer;\n\n\tassert_sha1_type(tree, OBJ_TREE);\n\n\tif (memchr(msg->buf, '\\0', msg->len))\n\t\treturn error(\"a NUL byte in commit log message not allowed.\");\n\n\t/* Not having i18n.commitencoding is the same as having utf-8 */\n\tencoding_is_utf8 = is_encoding_utf8(git_commit_encoding);\n\n\tstrbuf_init(&buffer, 8192); /* should avoid reallocs for the headers */\n\tstrbuf_addf(&buffer, \"tree %s\\n\", sha1_to_hex(tree));\n\n\t/*\n\t * NOTE! This ordering means that the same exact tree merged with a\n\t * different order of parents will be a _different_ changeset even\n\t * if everything else stays the same.\n\t */\n\twhile (parents) {\n\t\tstruct commit_list *next = parents->next;\n\t\tstruct commit *parent = parents->item;\n\n\t\tstrbuf_addf(&buffer, \"parent %s\\n\",\n\t\t\t    sha1_to_hex(parent->object.sha1));\n\t\tfree(parents);\n\t\tparents = next;\n\t}\n\n\t/* Person/date information */\n\tif (!author)\n\t\tauthor = git_author_info(IDENT_ERROR_ON_NO_NAME);\n\tstrbuf_addf(&buffer, \"author %s\\n\", author);\n\tstrbuf_addf(&buffer, \"committer %s\\n\", git_committer_info(IDENT_ERROR_ON_NO_NAME));\n\tif (!encoding_is_utf8)\n\t\tstrbuf_addf(&buffer, \"encoding %s\\n\", git_commit_encoding);\n\n\twhile (extra) {\n\t\tadd_extra_header(&buffer, extra);\n\t\textra = extra->next;\n\t}\n\tstrbuf_addch(&buffer, '\\n');\n\n\t/* And add the comment */\n\tstrbuf_addbuf(&buffer, msg);\n\n\t/* And check the encoding */\n\tif (encoding_is_utf8 && !is_utf8(buffer.buf))\n\t\tfprintf(stderr, commit_utf8_warn);\n\n\tif (sign_commit && do_sign_commit(&buffer, sign_commit))\n\t\treturn -1;\n\n\tresult = write_sha1_file(buffer.buf, buffer.len, commit_type, ret);\n\tstrbuf_release(&buffer);\n\treturn result;\n}\n\nstruct commit *get_merge_parent(const char *name)\n{\n\tstruct object *obj;\n\tstruct commit *commit;\n\tunsigned char sha1[20];\n\tif (get_sha1(name, sha1))\n\t\treturn NULL;\n\tobj = parse_object(sha1);\n\tcommit = (struct commit *)peel_to_type(name, 0, obj, OBJ_COMMIT);\n\tif (commit && !commit->util) {\n\t\tstruct merge_remote_desc *desc;\n\t\tdesc = xmalloc(sizeof(*desc));\n\t\tdesc->obj = obj;\n\t\tdesc->name = strdup(name);\n\t\tcommit->util = desc;\n\t}\n\treturn commit;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0058fa5b4365d290ccdb0ed64f6a23eb6f195527",
  "sha1_ok": true,
  "size": 28278
}
