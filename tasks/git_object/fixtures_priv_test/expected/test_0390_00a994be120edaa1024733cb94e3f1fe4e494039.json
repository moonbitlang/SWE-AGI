{
  "content": {
    "base64": "IyBnaXQtZ3VpIGNvbW1pdCBjaGVja291dCBzdXBwb3J0CiMgQ29weXJpZ2h0IChDKSAyMDA3IFNoYXduIFBlYXJjZQoKY2xhc3MgY2hlY2tvdXRfb3AgewoKZmllbGQgdyAgICAgICAge307ICMgb3VyIHdpbmRvdyAoaWYgd2UgaGF2ZSBvbmUpCmZpZWxkIHdfY29ucyAgIHt9OyAjIGVtYmVkZGVkIGNvbnNvbGUgd2luZG93IG9iamVjdAoKZmllbGQgbmV3X2V4cHIgICA7ICMgZXhwcmVzc2lvbiB0aGUgdXNlciBzYXcvdGhpbmtzIHRoaXMgaXMKZmllbGQgbmV3X2hhc2ggICA7ICMgY29tbWl0IFNIQS0xIHdlIGFyZSBzd2l0Y2hpbmcgdG8KZmllbGQgbmV3X3JlZiAgICA7ICMgcmVmIHdlIGFyZSB1cGRhdGluZy9jcmVhdGluZwoKZmllbGQgcGFyZW50X3cgICAgICAuOyAjIHdpbmRvdyB0aGF0IHN0YXJ0ZWQgdXMKZmllbGQgbWVyZ2VfdHlwZSBub25lOyAjIHR5cGUgb2YgbWVyZ2UgdG8gYXBwbHkgdG8gZXhpc3RpbmcgYnJhbmNoCmZpZWxkIGZldGNoX3NwZWMgICB7fTsgIyByZWZldGNoIHRyYWNraW5nIGJyYW5jaCBpZiB1c2VkPwpmaWVsZCBjaGVja291dCAgICAgIDE7ICMgYWN0dWFsbHkgY2hlY2tvdXQgdGhlIGJyYW5jaD8KZmllbGQgY3JlYXRlICAgICAgICAwOyAjIGNyZWF0ZSB0aGUgYnJhbmNoIGlmIGl0IGRvZXNuJ3QgZXhpc3Q/CgpmaWVsZCByZXNldF9vayAgICAgIDA7ICMgZGlkIHRoZSB1c2VyIGFncmVlIHRvIHJlc2V0PwpmaWVsZCBmZXRjaF9vayAgICAgIDA7ICMgZGlkIHRoZSBmZXRjaCBzdWNjZWVkPwoKZmllbGQgcmVhZHRyZWVfZCAgIHt9OyAjIGJ1ZmZlcmVkIG91dHB1dCBmcm9tIHJlYWQtdHJlZQpmaWVsZCB1cGRhdGVfb2xkICAge307ICMgd2FzIHRoZSB1cGRhdGUtcmVmIGNhbGwgZGVmZXJyZWQ/CmZpZWxkIHJlZmxvZ19tc2cgICB7fTsgIyBsb2cgbWVzc2FnZSBmb3IgdGhlIHVwZGF0ZS1yZWYgY2FsbAoKY29uc3RydWN0b3IgbmV3IHtleHByIGhhc2gge3JlZiB7fX19IHsKCXNldCBuZXdfZXhwciAkZXhwcgoJc2V0IG5ld19oYXNoICRoYXNoCglzZXQgbmV3X3JlZiAgJHJlZgoKCXJldHVybiAkdGhpcwp9CgptZXRob2QgcGFyZW50IHtwYXRofSB7CglzZXQgcGFyZW50X3cgW3dpbmZvIHRvcGxldmVsICRwYXRoXQp9CgptZXRob2QgZW5hYmxlX21lcmdlIHt0eXBlfSB7CglzZXQgbWVyZ2VfdHlwZSAkdHlwZQp9CgptZXRob2QgZW5hYmxlX2ZldGNoIHtzcGVjfSB7CglzZXQgZmV0Y2hfc3BlYyAkc3BlYwp9CgptZXRob2QgZW5hYmxlX2NoZWNrb3V0IHtjb30gewoJc2V0IGNoZWNrb3V0ICRjbwp9CgptZXRob2QgZW5hYmxlX2NyZWF0ZSB7Y299IHsKCXNldCBjcmVhdGUgJGNvCn0KCm1ldGhvZCBydW4ge30gewoJaWYgeyRmZXRjaF9zcGVjIG5lIHt9fSB7CgkJZ2xvYmFsIE0xQgoKCQkjIFdlIHdlcmUgYXNrZWQgdG8gcmVmcmVzaCBhIHNpbmdsZSB0cmFja2luZyBicmFuY2gKCQkjIGJlZm9yZSB3ZSBnZXQgdG8gd29yay4gIFdlIHNob3VsZCBkbyB0aGF0IGJlZm9yZSB3ZQoJCSMgY29uc2lkZXIgYW55IHJlZiB1cGRhdGluZy4KCQkjCgkJc2V0IGZldGNoX29rIDAKCQlzZXQgbF90cmNrIFtsaW5kZXggJGZldGNoX3NwZWMgMF0KCQlzZXQgcmVtb3RlIFtsaW5kZXggJGZldGNoX3NwZWMgMV0KCQlzZXQgcl9oZWFkIFtsaW5kZXggJGZldGNoX3NwZWMgMl0KCQlyZWdzdWIgXnJlZnMvaGVhZHMvICRyX2hlYWQge30gcl9uYW1lCgoJCV90b3BsZXZlbCAkdGhpcyB7UmVmcmVzaGluZyBUcmFja2luZyBCcmFuY2h9CgkJc2V0IHdfY29ucyBbOjpjb25zb2xlOjplbWJlZCBcCgkJCSR3LmNvbnNvbGUgXAoJCQkiRmV0Y2hpbmcgJHJfbmFtZSBmcm9tICRyZW1vdGUiXQoJCXBhY2sgJHcuY29uc29sZSAtZmlsbCBib3RoIC1leHBhbmQgMQoJCSR3X2NvbnMgZXhlYyBcCgkJCVtsaXN0IGdpdCBmZXRjaCAkcmVtb3RlICskcl9oZWFkOiRsX3RyY2tdIFwKCQkJW2NiIF9maW5pc2hfZmV0Y2hdCgoJCWJpbmQgJHcgPCRNMUItS2V5LXc+IGJyZWFrCgkJYmluZCAkdyA8JE0xQi1LZXktVz4gYnJlYWsKCQliaW5kICR3IDxWaXNpYmlsaXR5PiAiCgkJCVtsaXN0IGdyYWIgJHddCgkJCVtsaXN0IGZvY3VzICR3XQoJCSIKCQl3bSBwcm90b2NvbCAkdyBXTV9ERUxFVEVfV0lORE9XIFtjYiBfbm9vcF0KCQl0a3dhaXQgd2luZG93ICR3CgoJCWlmIHshJGZldGNoX29rfSB7CgkJCWRlbGV0ZV90aGlzCgkJCXJldHVybiAwCgkJfQoJfQoKCWlmIHskbmV3X3JlZiBuZSB7fX0gewoJCSMgSWYgd2UgaGF2ZSBhIHJlZiB3ZSBuZWVkIHRvIHVwZGF0ZSBpdCBiZWZvcmUgd2UgY2FuCgkJIyBwcm9jZWVkIHdpdGggYSBjaGVja291dCAoaWYgb25lIHdhcyBlbmFibGVkKS4KCQkjCgkJaWYgeyFbX3VwZGF0ZV9yZWYgJHRoaXNdfSB7CgkJCWRlbGV0ZV90aGlzCgkJCXJldHVybiAwCgkJfQoJfQoKCWlmIHskY2hlY2tvdXR9IHsKCQlfY2hlY2tvdXQgJHRoaXMKCQlyZXR1cm4gMQoJfQoKCWRlbGV0ZV90aGlzCglyZXR1cm4gMQp9CgptZXRob2QgX25vb3Age30ge30KCm1ldGhvZCBfZmluaXNoX2ZldGNoIHtva30gewoJaWYgeyRva30gewoJCXNldCBsX3RyY2sgW2xpbmRleCAkZmV0Y2hfc3BlYyAwXQoJCWlmIHtbY2F0Y2gge3NldCBuZXdfaGFzaCBbZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSAiJGxfdHJja14wIl19IGVycl19IHsKCQkJc2V0IG9rIDAKCQkJJHdfY29ucyBpbnNlcnQgImZhdGFsOiBDYW5ub3QgcmVzb2x2ZSAkbF90cmNrIgoJCQkkd19jb25zIGluc2VydCAkZXJyCgkJfQoJfQoKCSR3X2NvbnMgZG9uZSAkb2sKCXNldCB3X2NvbnMge30KCXdtIHByb3RvY29sICR3IFdNX0RFTEVURV9XSU5ET1cge30KCglpZiB7JG9rfSB7CgkJZGVzdHJveSAkdwoJCXNldCB3IHt9Cgl9IGVsc2UgewoJCWJ1dHRvbiAkdy5jbG9zZSAtdGV4dCBDbG9zZSAtY29tbWFuZCBbbGlzdCBkZXN0cm95ICR3XQoJCXBhY2sgJHcuY2xvc2UgLXNpZGUgYm90dG9tIC1hbmNob3IgZSAtcGFkeCAxMCAtcGFkeSAxMAoJfQoKCXNldCBmZXRjaF9vayAkb2sKfQoKbWV0aG9kIF91cGRhdGVfcmVmIHt9IHsKCWdsb2JhbCBudWxsX3NoYTEgY3VycmVudF9icmFuY2gKCglzZXQgcmVmICRuZXdfcmVmCglzZXQgbmV3ICRuZXdfaGFzaAoKCXNldCBpc19jdXJyZW50IDAKCXNldCByaCByZWZzL2hlYWRzLwoJc2V0IHJuIFtzdHJpbmcgbGVuZ3RoICRyaF0KCWlmIHtbc3RyaW5nIGVxdWFsIC1sZW5ndGggJHJuICRyaCAkcmVmXX0gewoJCXNldCBuZXdicmFuY2ggW3N0cmluZyByYW5nZSAkcmVmICRybiBlbmRdCgkJaWYgeyRjdXJyZW50X2JyYW5jaCBlcSAkbmV3YnJhbmNofSB7CgkJCXNldCBpc19jdXJyZW50IDEKCQl9Cgl9IGVsc2UgewoJCXNldCBuZXdicmFuY2ggJHJlZgoJfQoKCWlmIHtbY2F0Y2gge3NldCBjdXIgW2dpdCByZXYtcGFyc2UgLS12ZXJpZnkgIiRyZWZeMCJdfV19IHsKCQkjIEFzc3VtZSBpdCBkb2VzIG5vdCBleGlzdCwgYW5kIHRoYXQgaXMgd2hhdCB0aGUgZXJyb3Igd2FzLgoJCSMKCQlpZiB7ISRjcmVhdGV9IHsKCQkJX2Vycm9yICR0aGlzICJCcmFuY2ggJyRuZXdicmFuY2gnIGRvZXMgbm90IGV4aXN0LiIKCQkJcmV0dXJuIDAKCQl9CgoJCXNldCByZWZsb2dfbXNnICJicmFuY2g6IENyZWF0ZWQgZnJvbSAkbmV3X2V4cHIiCgkJc2V0IGN1ciAkbnVsbF9zaGExCgl9IGVsc2VpZiB7JGNyZWF0ZSAmJiAkbWVyZ2VfdHlwZSBlcSB7bm9uZX19IHsKCQkjIFdlIHdlcmUgdG9sZCB0byBjcmVhdGUgaXQsIGJ1dCBub3QgZG8gYSBtZXJnZS4KCQkjIEJhZC4gIE5hbWUgc2hvdWxkbid0IGhhdmUgZXhpc3RlZC4KCQkjCgkJX2Vycm9yICR0aGlzICJCcmFuY2ggJyRuZXdicmFuY2gnIGFscmVhZHkgZXhpc3RzLiIKCQlyZXR1cm4gMAoJfSBlbHNlaWYgeyEkY3JlYXRlICYmICRtZXJnZV90eXBlIGVxIHtub25lfX0gewoJCSMgV2UgYXJlbid0IGNyZWF0aW5nLCBpdCBleGlzdHMgYW5kIHdlIGRvbid0IG1lcmdlLgoJCSMgV2UgYXJlIHByb2JhYmx5IGp1c3QgYSBzaW1wbGUgYnJhbmNoIHN3aXRjaC4KCQkjIFVzZSB3aGF0ZXZlciB2YWx1ZSB3ZSBqdXN0IHJlYWQuCgkJIwoJCXNldCBuZXcgICAgICAkY3VyCgkJc2V0IG5ld19oYXNoICRjdXIKCX0gZWxzZWlmIHskbmV3IGVxICRjdXJ9IHsKCQkjIE5vIG1lcmdlIHdvdWxkIGJlIHJlcXVpcmVkLCBkb24ndCBjb21wdXRlIGFueXRoaW5nLgoJCSMKCX0gZWxzZSB7CgkJc2V0IG1yYiB7fQoJCWNhdGNoIHtzZXQgbXJiIFtnaXQgbWVyZ2UtYmFzZSAkbmV3ICRjdXJdfQoJCXN3aXRjaCAtLSAkbWVyZ2VfdHlwZSB7CgkJZmYgewoJCQlpZiB7JG1yYiBlcSAkbmV3fSB7CgkJCQkjIFRoZSBjdXJyZW50IGJyYW5jaCBpcyBhY3R1YWxseSBuZXdlci4KCQkJCSMKCQkJCXNldCBuZXcgJGN1cgoJCQl9IGVsc2VpZiB7JG1yYiBlcSAkY3VyfSB7CgkJCQkjIFRoZSBjdXJyZW50IGJyYW5jaCBpcyBvbGRlci4KCQkJCSMKCQkJCXNldCByZWZsb2dfbXNnICJtZXJnZSAkbmV3X2V4cHI6IEZhc3QtZm9yd2FyZCIKCQkJfSBlbHNlIHsKCQkJCV9lcnJvciAkdGhpcyAiQnJhbmNoICckbmV3YnJhbmNoJyBhbHJlYWR5IGV4aXN0cy5cblxuSXQgY2Fubm90IGZhc3QtZm9yd2FyZCB0byAkbmV3X2V4cHIuXG5BIG1lcmdlIGlzIHJlcXVpcmVkLiIKCQkJCXJldHVybiAwCgkJCX0KCQl9CgkJcmVzZXQgewoJCQlpZiB7JG1yYiBlcSAkY3VyfSB7CgkJCQkjIFRoZSBjdXJyZW50IGJyYW5jaCBpcyBvbGRlci4KCQkJCSMKCQkJCXNldCByZWZsb2dfbXNnICJtZXJnZSAkbmV3X2V4cHI6IEZhc3QtZm9yd2FyZCIKCQkJfSBlbHNlIHsKCQkJCSMgVGhlIGN1cnJlbnQgYnJhbmNoIHdpbGwgbG9zZSB0aGluZ3MuCgkJCQkjCgkJCQlpZiB7W19jb25maXJtX3Jlc2V0ICR0aGlzICRjdXJdfSB7CgkJCQkJc2V0IHJlZmxvZ19tc2cgInJlc2V0ICRuZXdfZXhwciIKCQkJCX0gZWxzZSB7CgkJCQkJcmV0dXJuIDAKCQkJCX0KCQkJfQoJCX0KCQlkZWZhdWx0IHsKCQkJX2Vycm9yICR0aGlzICJPbmx5ICdmZicgYW5kICdyZXNldCcgbWVyZ2UgaXMgY3VycmVudGx5IHN1cHBvcnRlZC4iCgkJCXJldHVybiAwCgkJfQoJCX0KCX0KCglpZiB7JG5ldyBuZSAkY3VyfSB7CgkJaWYgeyRpc19jdXJyZW50fSB7CgkJCSMgTm8gc28gZmFzdC4gIFdlIHNob3VsZCBkZWZlciB0aGlzIGluIGNhc2UKCQkJIyB3ZSBjYW5ub3QgdXBkYXRlIHRoZSB3b3JraW5nIGRpcmVjdG9yeS4KCQkJIwoJCQlzZXQgdXBkYXRlX29sZCAkY3VyCgkJCXJldHVybiAxCgkJfQoKCQlpZiB7W2NhdGNoIHsKCQkJCWdpdCB1cGRhdGUtcmVmIC1tICRyZWZsb2dfbXNnICRyZWYgJG5ldyAkY3VyCgkJCX0gZXJyXX0gewoJCQlfZXJyb3IgJHRoaXMgIkZhaWxlZCB0byB1cGRhdGUgJyRuZXdicmFuY2gnLlxuXG4kZXJyIgoJCQlyZXR1cm4gMAoJCX0KCX0KCglyZXR1cm4gMQp9CgptZXRob2QgX2NoZWNrb3V0IHt9IHsKCWlmIHtbbG9ja19pbmRleCBjaGVja291dF9vcF19IHsKCQlhZnRlciBpZGxlIFtjYiBfc3RhcnRfY2hlY2tvdXRdCgl9IGVsc2UgewoJCV9lcnJvciAkdGhpcyAiSW5kZXggaXMgYWxyZWFkeSBsb2NrZWQuIgoJCWRlbGV0ZV90aGlzCgl9Cn0KCm1ldGhvZCBfc3RhcnRfY2hlY2tvdXQge30gewoJZ2xvYmFsIEhFQUQgY29tbWl0X3R5cGUKCgkjIC0tIE91ciBpbiBtZW1vcnkgc3RhdGUgc2hvdWxkIG1hdGNoIHRoZSByZXBvc2l0b3J5LgoJIwoJcmVwb3NpdG9yeV9zdGF0ZSBjdXJUeXBlIGN1ckhFQUQgY3VyTUVSR0VfSEVBRAoJaWYge1tzdHJpbmcgbWF0Y2ggYW1lbmQqICRjb21taXRfdHlwZV0KCQkmJiAkY3VyVHlwZSBlcSB7bm9ybWFsfQoJCSYmICRjdXJIRUFEIGVxICRIRUFEfSB7Cgl9IGVsc2VpZiB7JGNvbW1pdF90eXBlIG5lICRjdXJUeXBlIHx8ICRIRUFEIG5lICRjdXJIRUFEfSB7CgkJaW5mb19wb3B1cCB7TGFzdCBzY2FubmVkIHN0YXRlIGRvZXMgbm90IG1hdGNoIHJlcG9zaXRvcnkgc3RhdGUuCgpBbm90aGVyIEdpdCBwcm9ncmFtIGhhcyBtb2RpZmllZCB0aGlzIHJlcG9zaXRvcnkgc2luY2UgdGhlIGxhc3Qgc2Nhbi4gIEEgcmVzY2FuIG11c3QgYmUgcGVyZm9ybWVkIGJlZm9yZSB0aGUgY3VycmVudCBicmFuY2ggY2FuIGJlIGNoYW5nZWQuCgpUaGUgcmVzY2FuIHdpbGwgYmUgYXV0b21hdGljYWxseSBzdGFydGVkIG5vdy4KfQoJCXVubG9ja19pbmRleAoJCXJlc2NhbiB1aV9yZWFkeQoJCWRlbGV0ZV90aGlzCgkJcmV0dXJuCgl9CgoJaWYge1tpc19jb25maWdfdHJ1ZSBndWkudHJ1c3RtdGltZV19IHsKCQlfcmVhZHRyZWUgJHRoaXMKCX0gZWxzZSB7CgkJdWlfc3RhdHVzIHtSZWZyZXNoaW5nIGZpbGUgc3RhdHVzLi4ufQoJCXNldCBmZCBbZ2l0X3JlYWQgdXBkYXRlLWluZGV4IFwKCQkJLXEgXAoJCQktLXVubWVyZ2VkIFwKCQkJLS1pZ25vcmUtbWlzc2luZyBcCgkJCS0tcmVmcmVzaCBcCgkJCV0KCQlmY29uZmlndXJlICRmZCAtYmxvY2tpbmcgMCAtdHJhbnNsYXRpb24gYmluYXJ5CgkJZmlsZWV2ZW50ICRmZCByZWFkYWJsZSBbY2IgX3JlZnJlc2hfd2FpdCAkZmRdCgl9Cn0KCm1ldGhvZCBfcmVmcmVzaF93YWl0IHtmZH0gewoJcmVhZCAkZmQKCWlmIHtbZW9mICRmZF19IHsKCQljbG9zZSAkZmQKCQlfcmVhZHRyZWUgJHRoaXMKCX0KfQoKbWV0aG9kIF9uYW1lIHt9IHsKCWlmIHskbmV3X3JlZiBlcSB7fX0gewoJCXJldHVybiBbc3RyaW5nIHJhbmdlICRuZXdfaGFzaCAwIDddCgl9CgoJc2V0IHJoIHJlZnMvaGVhZHMvCglzZXQgcm4gW3N0cmluZyBsZW5ndGggJHJoXQoJaWYge1tzdHJpbmcgZXF1YWwgLWxlbmd0aCAkcm4gJHJoICRuZXdfcmVmXX0gewoJCXJldHVybiBbc3RyaW5nIHJhbmdlICRuZXdfcmVmICRybiBlbmRdCgl9IGVsc2UgewoJCXJldHVybiAkbmV3X3JlZgoJfQp9CgptZXRob2QgX3JlYWR0cmVlIHt9IHsKCWdsb2JhbCBIRUFECgoJc2V0IHJlYWR0cmVlX2Qge30KCSQ6Om1haW5fc3RhdHVzIHN0YXJ0IFwKCQkiVXBkYXRpbmcgd29ya2luZyBkaXJlY3RvcnkgdG8gJ1tfbmFtZSAkdGhpc10nLi4uIiBcCgkJe2ZpbGVzIGNoZWNrZWQgb3V0fQoKCXNldCBmZCBbZ2l0X3JlYWQgLS1zdGRlcnIgcmVhZC10cmVlIFwKCQktbSBcCgkJLXUgXAoJCS12IFwKCQktLWV4Y2x1ZGUtcGVyLWRpcmVjdG9yeT0uZ2l0aWdub3JlIFwKCQkkSEVBRCBcCgkJJG5ld19oYXNoIFwKCQldCglmY29uZmlndXJlICRmZCAtYmxvY2tpbmcgMCAtdHJhbnNsYXRpb24gYmluYXJ5CglmaWxlZXZlbnQgJGZkIHJlYWRhYmxlIFtjYiBfcmVhZHRyZWVfd2FpdCAkZmRdCn0KCm1ldGhvZCBfcmVhZHRyZWVfd2FpdCB7ZmR9IHsKCWdsb2JhbCBjdXJyZW50X2JyYW5jaAoKCXNldCBidWYgW3JlYWQgJGZkXQoJJDo6bWFpbl9zdGF0dXMgdXBkYXRlX21ldGVyICRidWYKCWFwcGVuZCByZWFkdHJlZV9kICRidWYKCglmY29uZmlndXJlICRmZCAtYmxvY2tpbmcgMQoJaWYgeyFbZW9mICRmZF19IHsKCQlmY29uZmlndXJlICRmZCAtYmxvY2tpbmcgMAoJCXJldHVybgoJfQoKCWlmIHtbY2F0Y2gge2Nsb3NlICRmZH1dfSB7CgkJc2V0IGVyciAkcmVhZHRyZWVfZAoJCXJlZ3N1YiB7XmZhdGFsOiB9ICRlcnIge30gZXJyCgkJJDo6bWFpbl9zdGF0dXMgc3RvcCAiQWJvcnRlZCBjaGVja291dCBvZiAnW19uYW1lICR0aGlzXScgKGZpbGUgbGV2ZWwgbWVyZ2luZyBpcyByZXF1aXJlZCkuIgoJCXdhcm5fcG9wdXAgIkZpbGUgbGV2ZWwgbWVyZ2UgcmVxdWlyZWQuCgokZXJyCgpTdGF5aW5nIG9uIGJyYW5jaCAnJGN1cnJlbnRfYnJhbmNoJy4iCgkJdW5sb2NrX2luZGV4CgkJZGVsZXRlX3RoaXMKCQlyZXR1cm4KCX0KCgkkOjptYWluX3N0YXR1cyBzdG9wCglfYWZ0ZXJfcmVhZHRyZWUgJHRoaXMKfQoKbWV0aG9kIF9hZnRlcl9yZWFkdHJlZSB7fSB7CglnbG9iYWwgc2VsZWN0ZWRfY29tbWl0X3R5cGUgY29tbWl0X3R5cGUgSEVBRCBNRVJHRV9IRUFEIFBBUkVOVAoJZ2xvYmFsIGN1cnJlbnRfYnJhbmNoIGlzX2RldGFjaGVkCglnbG9iYWwgdWlfY29tbQoKCXNldCBuYW1lIFtfbmFtZSAkdGhpc10KCXNldCBsb2cgImNoZWNrb3V0OiBtb3ZpbmciCglpZiB7ISRpc19kZXRhY2hlZH0gewoJCWFwcGVuZCBsb2cgIiBmcm9tICRjdXJyZW50X2JyYW5jaCIKCX0KCgkjIC0tIE1vdmUvY3JlYXRlIEhFQUQgYXMgYSBzeW1ib2xpYyByZWYuICBDb3JlIGdpdCBkb2VzIG5vdAoJIyAgICBldmVuIGNoZWNrIGZvciBmYWlsdXJlIGhlcmUsIGl0IEp1c3QgV29ya3ModG0pLiAgSWYgaXQKCSMgICAgZG9lc24ndCB3ZSBhcmUgaW4gc29tZSByZWFsbHkgdWdseSBzdGF0ZSB0aGF0IGlzIGRpZmZpY3VsdAoJIyAgICB0byByZWNvdmVyIGZyb20gd2l0aGluIGdpdC1ndWkuCgkjCglzZXQgcmggcmVmcy9oZWFkcy8KCXNldCBybiBbc3RyaW5nIGxlbmd0aCAkcmhdCglpZiB7W3N0cmluZyBlcXVhbCAtbGVuZ3RoICRybiAkcmggJG5ld19yZWZdfSB7CgkJc2V0IG5ld19icmFuY2ggW3N0cmluZyByYW5nZSAkbmV3X3JlZiAkcm4gZW5kXQoJCWFwcGVuZCBsb2cgIiB0byAkbmV3X2JyYW5jaCIKCgkJaWYge1tjYXRjaCB7CgkJCQlnaXQgc3ltYm9saWMtcmVmIC1tICRsb2cgSEVBRCAkbmV3X3JlZgoJCQl9IGVycl19IHsKCQkJX2ZhdGFsICR0aGlzICRlcnIKCQl9CgkJc2V0IGN1cnJlbnRfYnJhbmNoICRuZXdfYnJhbmNoCgkJc2V0IGlzX2RldGFjaGVkIDAKCX0gZWxzZSB7CgkJYXBwZW5kIGxvZyAiIHRvICRuZXdfZXhwciIKCgkJaWYge1tjYXRjaCB7CgkJCQlfZGV0YWNoX0hFQUQgJGxvZyAkbmV3X2hhc2gKCQkJfSBlcnJdfSB7CgkJCV9mYXRhbCAkdGhpcyAkZXJyCgkJfQoJCXNldCBjdXJyZW50X2JyYW5jaCBIRUFECgkJc2V0IGlzX2RldGFjaGVkIDEKCX0KCgkjIC0tIFdlIGhhZCB0byBkZWZlciB1cGRhdGluZyB0aGUgYnJhbmNoIGl0c2VsZiB1bnRpbCB3ZQoJIyAgICBrbmV3IHRoZSB3b3JraW5nIGRpcmVjdG9yeSB3b3VsZCB1cGRhdGUuICBTbyBub3cgd2UKCSMgICAgbmVlZCB0byBmaW5pc2ggdGhhdCB3b3JrLiAgSWYgaXQgZmFpbHMgd2UncmUgaW4gYmlnCgkjICAgIHRyb3VibGUuCgkjCglpZiB7JHVwZGF0ZV9vbGQgbmUge319IHsKCQlpZiB7W2NhdGNoIHsKCQkJCWdpdCB1cGRhdGUtcmVmIFwKCQkJCQktbSAkcmVmbG9nX21zZyBcCgkJCQkJJG5ld19yZWYgXAoJCQkJCSRuZXdfaGFzaCBcCgkJCQkJJHVwZGF0ZV9vbGQKCQkJfSBlcnJdfSB7CgkJCV9mYXRhbCAkdGhpcyAkZXJyCgkJfQoJfQoKCWlmIHskaXNfZGV0YWNoZWR9IHsKCQlpbmZvX3BvcHVwICJZb3UgYXJlIG5vIGxvbmdlciBvbiBhIGxvY2FsIGJyYW5jaC4KCklmIHlvdSB3YW50ZWQgdG8gYmUgb24gYSBicmFuY2gsIGNyZWF0ZSBvbmUgbm93IHN0YXJ0aW5nIGZyb20gJ1RoaXMgRGV0YWNoZWQgQ2hlY2tvdXQnLiIKCX0KCgkjIC0tIFVwZGF0ZSBvdXIgcmVwb3NpdG9yeSBzdGF0ZS4gIElmIHdlIHdlcmUgcHJldmlvdXNseSBpbgoJIyAgICBhbWVuZCBtb2RlIHdlIG5lZWQgdG8gdG9zcyB0aGUgY3VycmVudCBidWZmZXIgYW5kIGRvIGEKCSMgICAgZnVsbCByZXNjYW4gdG8gdXBkYXRlIG91ciBmaWxlIGxpc3RzLiAgSWYgd2Ugd2VyZW4ndCBpbgoJIyAgICBhbWVuZCBtb2RlIG91ciBmaWxlIGxpc3RzIGFyZSBhY2N1cmF0ZSBhbmQgd2UgY2FuIGF2b2lkCgkjICAgIHRoZSByZXNjYW4uCgkjCgl1bmxvY2tfaW5kZXgKCXNldCBzZWxlY3RlZF9jb21taXRfdHlwZSBuZXcKCWlmIHtbc3RyaW5nIG1hdGNoIGFtZW5kKiAkY29tbWl0X3R5cGVdfSB7CgkJJHVpX2NvbW0gZGVsZXRlIDAuMCBlbmQKCQkkdWlfY29tbSBlZGl0IHJlc2V0CgkJJHVpX2NvbW0gZWRpdCBtb2RpZmllZCBmYWxzZQoJCXJlc2NhbiBbbGlzdCB1aV9zdGF0dXMgIkNoZWNrZWQgb3V0ICckbmFtZScuIl0KCX0gZWxzZSB7CgkJcmVwb3NpdG9yeV9zdGF0ZSBjb21taXRfdHlwZSBIRUFEIE1FUkdFX0hFQUQKCQlzZXQgUEFSRU5UICRIRUFECgkJdWlfc3RhdHVzICJDaGVja2VkIG91dCAnJG5hbWUnLiIKCX0KCWRlbGV0ZV90aGlzCn0KCmdpdC12ZXJzaW9uIHByb2MgX2RldGFjaF9IRUFEIHtsb2cgbmV3fSB7Cgk+PSAxLjUuMyB7CgkJZ2l0IHVwZGF0ZS1yZWYgLS1uby1kZXJlZiAtbSAkbG9nIEhFQUQgJG5ldwoJfQoJZGVmYXVsdCB7CgkJc2V0IHAgW2dpdGRpciBIRUFEXQoJCWZpbGUgZGVsZXRlICRwCgkJc2V0IGZkIFtvcGVuICRwIHddCgkJZmNvbmZpZ3VyZSAkZmQgLXRyYW5zbGF0aW9uIGxmIC1lbmNvZGluZyB1dGYtOAoJCXB1dHMgJGZkICRuZXcKCQljbG9zZSAkZmQKCX0KfQoKbWV0aG9kIF9jb25maXJtX3Jlc2V0IHtjdXJ9IHsKCXNldCByZXNldF9vayAwCglzZXQgbmFtZSBbX25hbWUgJHRoaXNdCglzZXQgZ2l0ayBbbGlzdCBkb19naXRrIFtsaXN0ICRjdXIgXiRuZXdfaGFzaF1dCgoJX3RvcGxldmVsICR0aGlzIHtDb25maXJtIEJyYW5jaCBSZXNldH0KCXBhY2sgW2xhYmVsICR3Lm1zZzEgXAoJCS1hbmNob3IgdyBcCgkJLWp1c3RpZnkgbGVmdCBcCgkJLXRleHQgIlJlc2V0dGluZyAnJG5hbWUnIHRvICRuZXdfZXhwciB3aWxsIGxvc2UgdGhlIGZvbGxvd2luZyBjb21taXRzOiIgXAoJCV0gLWFuY2hvciB3CgoJc2V0IGxpc3QgJHcubGlzdC5sCglmcmFtZSAkdy5saXN0Cgl0ZXh0ICRsaXN0IFwKCQktZm9udCBmb250X2RpZmYgXAoJCS13aWR0aCA4MCBcCgkJLWhlaWdodCAxMCBcCgkJLXdyYXAgbm9uZSBcCgkJLXhzY3JvbGxjb21tYW5kIFtsaXN0ICR3Lmxpc3Quc2J4IHNldF0gXAoJCS15c2Nyb2xsY29tbWFuZCBbbGlzdCAkdy5saXN0LnNieSBzZXRdCglzY3JvbGxiYXIgJHcubGlzdC5zYnggLW9yaWVudCBoIC1jb21tYW5kIFtsaXN0ICRsaXN0IHh2aWV3XQoJc2Nyb2xsYmFyICR3Lmxpc3Quc2J5IC1vcmllbnQgdiAtY29tbWFuZCBbbGlzdCAkbGlzdCB5dmlld10KCXBhY2sgJHcubGlzdC5zYnggLWZpbGwgeCAtc2lkZSBib3R0b20KCXBhY2sgJHcubGlzdC5zYnkgLWZpbGwgeSAtc2lkZSByaWdodAoJcGFjayAkbGlzdCAtZmlsbCBib3RoIC1leHBhbmQgMQoJcGFjayAkdy5saXN0IC1maWxsIGJvdGggLWV4cGFuZCAxIC1wYWR4IDUgLXBhZHkgNQoKCXBhY2sgW2xhYmVsICR3Lm1zZzIgXAoJCS1hbmNob3IgdyBcCgkJLWp1c3RpZnkgbGVmdCBcCgkJLXRleHQge1JlY292ZXJpbmcgbG9zdCBjb21taXRzIG1heSBub3QgYmUgZWFzeS59IFwKCQldCglwYWNrIFtsYWJlbCAkdy5tc2czIFwKCQktYW5jaG9yIHcgXAoJCS1qdXN0aWZ5IGxlZnQgXAoJCS10ZXh0ICJSZXNldCAnJG5hbWUnPyIgXAoJCV0KCglmcmFtZSAkdy5idXR0b25zCglidXR0b24gJHcuYnV0dG9ucy52aXN1YWxpemUgXAoJCS10ZXh0IFZpc3VhbGl6ZSBcCgkJLWNvbW1hbmQgJGdpdGsKCXBhY2sgJHcuYnV0dG9ucy52aXN1YWxpemUgLXNpZGUgbGVmdAoJYnV0dG9uICR3LmJ1dHRvbnMucmVzZXQgXAoJCS10ZXh0IFJlc2V0IFwKCQktY29tbWFuZCAiCgkJCXNldCBAcmVzZXRfb2sgMQoJCQlkZXN0cm95ICR3CgkJIgoJcGFjayAkdy5idXR0b25zLnJlc2V0IC1zaWRlIHJpZ2h0CglidXR0b24gJHcuYnV0dG9ucy5jYW5jZWwgXAoJCS1kZWZhdWx0IGFjdGl2ZSBcCgkJLXRleHQgQ2FuY2VsIFwKCQktY29tbWFuZCBbbGlzdCBkZXN0cm95ICR3XQoJcGFjayAkdy5idXR0b25zLmNhbmNlbCAtc2lkZSByaWdodCAtcGFkeCA1CglwYWNrICR3LmJ1dHRvbnMgLXNpZGUgYm90dG9tIC1maWxsIHggLXBhZHkgMTAgLXBhZHggMTAKCglzZXQgZmQgW2dpdF9yZWFkIHJldi1saXN0IC0tcHJldHR5PW9uZWxpbmUgJGN1ciBeJG5ld19oYXNoXQoJd2hpbGUge1tnZXRzICRmZCBsaW5lXSA+IDB9IHsKCQlzZXQgYWJiciBbc3RyaW5nIHJhbmdlICRsaW5lIDAgN10KCQlzZXQgc3ViaiBbc3RyaW5nIHJhbmdlICRsaW5lIDQxIGVuZF0KCQkkbGlzdCBpbnNlcnQgZW5kICIkYWJiciAgJHN1YmpcbiIKCX0KCWNsb3NlICRmZAoJJGxpc3QgY29uZmlndXJlIC1zdGF0ZSBkaXNhYmxlZAoKCWJpbmQgJHcgICAgPEtleS12PiAkZ2l0awoJYmluZCAkdyA8VmlzaWJpbGl0eT4gIgoJCWdyYWIgJHcKCQlmb2N1cyAkdy5idXR0b25zLmNhbmNlbAoJIgoJYmluZCAkdyA8S2V5LVJldHVybj4gW2xpc3QgZGVzdHJveSAkd10KCWJpbmQgJHcgPEtleS1Fc2NhcGU+IFtsaXN0IGRlc3Ryb3kgJHddCgl0a3dhaXQgd2luZG93ICR3CglyZXR1cm4gJHJlc2V0X29rCn0KCm1ldGhvZCBfZXJyb3Ige21zZ30gewoJaWYge1t3aW5mbyBpc21hcHBlZCAkcGFyZW50X3ddfSB7CgkJc2V0IHAgJHBhcmVudF93Cgl9IGVsc2UgewoJCXNldCBwIC4KCX0KCgl0a19tZXNzYWdlQm94IFwKCQktaWNvbiBlcnJvciBcCgkJLXR5cGUgb2sgXAoJCS10aXRsZSBbd20gdGl0bGUgJHBdIFwKCQktcGFyZW50ICRwIFwKCQktbWVzc2FnZSAkbXNnCn0KCm1ldGhvZCBfdG9wbGV2ZWwge3RpdGxlfSB7CglyZWdzdWIgLWFsbCB7Ojp9ICR0aGlzIHtfX30gdwoJc2V0IHcgLiR3CgoJaWYge1t3aW5mbyBpc21hcHBlZCAkcGFyZW50X3ddfSB7CgkJc2V0IHAgJHBhcmVudF93Cgl9IGVsc2UgewoJCXNldCBwIC4KCX0KCgl0b3BsZXZlbCAkdwoJd20gdGl0bGUgJHcgJHRpdGxlCgl3bSBnZW9tZXRyeSAkdyAiK1t3aW5mbyByb290eCAkcF0rW3dpbmZvIHJvb3R5ICRwXSIKfQoKbWV0aG9kIF9mYXRhbCB7ZXJyfSB7CgllcnJvcl9wb3B1cCAiRmFpbGVkIHRvIHNldCBjdXJyZW50IGJyYW5jaC4KClRoaXMgd29ya2luZyBkaXJlY3RvcnkgaXMgb25seSBwYXJ0aWFsbHkgc3dpdGNoZWQuICBXZSBzdWNjZXNzZnVsbHkgdXBkYXRlZCB5b3VyIGZpbGVzLCBidXQgZmFpbGVkIHRvIHVwZGF0ZSBhbiBpbnRlcm5hbCBHaXQgZmlsZS4KClRoaXMgc2hvdWxkIG5vdCBoYXZlIG9jY3VycmVkLiAgW2FwcG5hbWVdIHdpbGwgbm93IGNsb3NlIGFuZCBnaXZlIHVwLgoKJGVyciIKCWV4aXQgMQp9Cgp9Cg==",
    "text": "# git-gui commit checkout support\n# Copyright (C) 2007 Shawn Pearce\n\nclass checkout_op {\n\nfield w        {}; # our window (if we have one)\nfield w_cons   {}; # embedded console window object\n\nfield new_expr   ; # expression the user saw/thinks this is\nfield new_hash   ; # commit SHA-1 we are switching to\nfield new_ref    ; # ref we are updating/creating\n\nfield parent_w      .; # window that started us\nfield merge_type none; # type of merge to apply to existing branch\nfield fetch_spec   {}; # refetch tracking branch if used?\nfield checkout      1; # actually checkout the branch?\nfield create        0; # create the branch if it doesn't exist?\n\nfield reset_ok      0; # did the user agree to reset?\nfield fetch_ok      0; # did the fetch succeed?\n\nfield readtree_d   {}; # buffered output from read-tree\nfield update_old   {}; # was the update-ref call deferred?\nfield reflog_msg   {}; # log message for the update-ref call\n\nconstructor new {expr hash {ref {}}} {\n\tset new_expr $expr\n\tset new_hash $hash\n\tset new_ref  $ref\n\n\treturn $this\n}\n\nmethod parent {path} {\n\tset parent_w [winfo toplevel $path]\n}\n\nmethod enable_merge {type} {\n\tset merge_type $type\n}\n\nmethod enable_fetch {spec} {\n\tset fetch_spec $spec\n}\n\nmethod enable_checkout {co} {\n\tset checkout $co\n}\n\nmethod enable_create {co} {\n\tset create $co\n}\n\nmethod run {} {\n\tif {$fetch_spec ne {}} {\n\t\tglobal M1B\n\n\t\t# We were asked to refresh a single tracking branch\n\t\t# before we get to work.  We should do that before we\n\t\t# consider any ref updating.\n\t\t#\n\t\tset fetch_ok 0\n\t\tset l_trck [lindex $fetch_spec 0]\n\t\tset remote [lindex $fetch_spec 1]\n\t\tset r_head [lindex $fetch_spec 2]\n\t\tregsub ^refs/heads/ $r_head {} r_name\n\n\t\t_toplevel $this {Refreshing Tracking Branch}\n\t\tset w_cons [::console::embed \\\n\t\t\t$w.console \\\n\t\t\t\"Fetching $r_name from $remote\"]\n\t\tpack $w.console -fill both -expand 1\n\t\t$w_cons exec \\\n\t\t\t[list git fetch $remote +$r_head:$l_trck] \\\n\t\t\t[cb _finish_fetch]\n\n\t\tbind $w <$M1B-Key-w> break\n\t\tbind $w <$M1B-Key-W> break\n\t\tbind $w <Visibility> \"\n\t\t\t[list grab $w]\n\t\t\t[list focus $w]\n\t\t\"\n\t\twm protocol $w WM_DELETE_WINDOW [cb _noop]\n\t\ttkwait window $w\n\n\t\tif {!$fetch_ok} {\n\t\t\tdelete_this\n\t\t\treturn 0\n\t\t}\n\t}\n\n\tif {$new_ref ne {}} {\n\t\t# If we have a ref we need to update it before we can\n\t\t# proceed with a checkout (if one was enabled).\n\t\t#\n\t\tif {![_update_ref $this]} {\n\t\t\tdelete_this\n\t\t\treturn 0\n\t\t}\n\t}\n\n\tif {$checkout} {\n\t\t_checkout $this\n\t\treturn 1\n\t}\n\n\tdelete_this\n\treturn 1\n}\n\nmethod _noop {} {}\n\nmethod _finish_fetch {ok} {\n\tif {$ok} {\n\t\tset l_trck [lindex $fetch_spec 0]\n\t\tif {[catch {set new_hash [git rev-parse --verify \"$l_trck^0\"]} err]} {\n\t\t\tset ok 0\n\t\t\t$w_cons insert \"fatal: Cannot resolve $l_trck\"\n\t\t\t$w_cons insert $err\n\t\t}\n\t}\n\n\t$w_cons done $ok\n\tset w_cons {}\n\twm protocol $w WM_DELETE_WINDOW {}\n\n\tif {$ok} {\n\t\tdestroy $w\n\t\tset w {}\n\t} else {\n\t\tbutton $w.close -text Close -command [list destroy $w]\n\t\tpack $w.close -side bottom -anchor e -padx 10 -pady 10\n\t}\n\n\tset fetch_ok $ok\n}\n\nmethod _update_ref {} {\n\tglobal null_sha1 current_branch\n\n\tset ref $new_ref\n\tset new $new_hash\n\n\tset is_current 0\n\tset rh refs/heads/\n\tset rn [string length $rh]\n\tif {[string equal -length $rn $rh $ref]} {\n\t\tset newbranch [string range $ref $rn end]\n\t\tif {$current_branch eq $newbranch} {\n\t\t\tset is_current 1\n\t\t}\n\t} else {\n\t\tset newbranch $ref\n\t}\n\n\tif {[catch {set cur [git rev-parse --verify \"$ref^0\"]}]} {\n\t\t# Assume it does not exist, and that is what the error was.\n\t\t#\n\t\tif {!$create} {\n\t\t\t_error $this \"Branch '$newbranch' does not exist.\"\n\t\t\treturn 0\n\t\t}\n\n\t\tset reflog_msg \"branch: Created from $new_expr\"\n\t\tset cur $null_sha1\n\t} elseif {$create && $merge_type eq {none}} {\n\t\t# We were told to create it, but not do a merge.\n\t\t# Bad.  Name shouldn't have existed.\n\t\t#\n\t\t_error $this \"Branch '$newbranch' already exists.\"\n\t\treturn 0\n\t} elseif {!$create && $merge_type eq {none}} {\n\t\t# We aren't creating, it exists and we don't merge.\n\t\t# We are probably just a simple branch switch.\n\t\t# Use whatever value we just read.\n\t\t#\n\t\tset new      $cur\n\t\tset new_hash $cur\n\t} elseif {$new eq $cur} {\n\t\t# No merge would be required, don't compute anything.\n\t\t#\n\t} else {\n\t\tset mrb {}\n\t\tcatch {set mrb [git merge-base $new $cur]}\n\t\tswitch -- $merge_type {\n\t\tff {\n\t\t\tif {$mrb eq $new} {\n\t\t\t\t# The current branch is actually newer.\n\t\t\t\t#\n\t\t\t\tset new $cur\n\t\t\t} elseif {$mrb eq $cur} {\n\t\t\t\t# The current branch is older.\n\t\t\t\t#\n\t\t\t\tset reflog_msg \"merge $new_expr: Fast-forward\"\n\t\t\t} else {\n\t\t\t\t_error $this \"Branch '$newbranch' already exists.\\n\\nIt cannot fast-forward to $new_expr.\\nA merge is required.\"\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t\treset {\n\t\t\tif {$mrb eq $cur} {\n\t\t\t\t# The current branch is older.\n\t\t\t\t#\n\t\t\t\tset reflog_msg \"merge $new_expr: Fast-forward\"\n\t\t\t} else {\n\t\t\t\t# The current branch will lose things.\n\t\t\t\t#\n\t\t\t\tif {[_confirm_reset $this $cur]} {\n\t\t\t\t\tset reflog_msg \"reset $new_expr\"\n\t\t\t\t} else {\n\t\t\t\t\treturn 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdefault {\n\t\t\t_error $this \"Only 'ff' and 'reset' merge is currently supported.\"\n\t\t\treturn 0\n\t\t}\n\t\t}\n\t}\n\n\tif {$new ne $cur} {\n\t\tif {$is_current} {\n\t\t\t# No so fast.  We should defer this in case\n\t\t\t# we cannot update the working directory.\n\t\t\t#\n\t\t\tset update_old $cur\n\t\t\treturn 1\n\t\t}\n\n\t\tif {[catch {\n\t\t\t\tgit update-ref -m $reflog_msg $ref $new $cur\n\t\t\t} err]} {\n\t\t\t_error $this \"Failed to update '$newbranch'.\\n\\n$err\"\n\t\t\treturn 0\n\t\t}\n\t}\n\n\treturn 1\n}\n\nmethod _checkout {} {\n\tif {[lock_index checkout_op]} {\n\t\tafter idle [cb _start_checkout]\n\t} else {\n\t\t_error $this \"Index is already locked.\"\n\t\tdelete_this\n\t}\n}\n\nmethod _start_checkout {} {\n\tglobal HEAD commit_type\n\n\t# -- Our in memory state should match the repository.\n\t#\n\trepository_state curType curHEAD curMERGE_HEAD\n\tif {[string match amend* $commit_type]\n\t\t&& $curType eq {normal}\n\t\t&& $curHEAD eq $HEAD} {\n\t} elseif {$commit_type ne $curType || $HEAD ne $curHEAD} {\n\t\tinfo_popup {Last scanned state does not match repository state.\n\nAnother Git program has modified this repository since the last scan.  A rescan must be performed before the current branch can be changed.\n\nThe rescan will be automatically started now.\n}\n\t\tunlock_index\n\t\trescan ui_ready\n\t\tdelete_this\n\t\treturn\n\t}\n\n\tif {[is_config_true gui.trustmtime]} {\n\t\t_readtree $this\n\t} else {\n\t\tui_status {Refreshing file status...}\n\t\tset fd [git_read update-index \\\n\t\t\t-q \\\n\t\t\t--unmerged \\\n\t\t\t--ignore-missing \\\n\t\t\t--refresh \\\n\t\t\t]\n\t\tfconfigure $fd -blocking 0 -translation binary\n\t\tfileevent $fd readable [cb _refresh_wait $fd]\n\t}\n}\n\nmethod _refresh_wait {fd} {\n\tread $fd\n\tif {[eof $fd]} {\n\t\tclose $fd\n\t\t_readtree $this\n\t}\n}\n\nmethod _name {} {\n\tif {$new_ref eq {}} {\n\t\treturn [string range $new_hash 0 7]\n\t}\n\n\tset rh refs/heads/\n\tset rn [string length $rh]\n\tif {[string equal -length $rn $rh $new_ref]} {\n\t\treturn [string range $new_ref $rn end]\n\t} else {\n\t\treturn $new_ref\n\t}\n}\n\nmethod _readtree {} {\n\tglobal HEAD\n\n\tset readtree_d {}\n\t$::main_status start \\\n\t\t\"Updating working directory to '[_name $this]'...\" \\\n\t\t{files checked out}\n\n\tset fd [git_read --stderr read-tree \\\n\t\t-m \\\n\t\t-u \\\n\t\t-v \\\n\t\t--exclude-per-directory=.gitignore \\\n\t\t$HEAD \\\n\t\t$new_hash \\\n\t\t]\n\tfconfigure $fd -blocking 0 -translation binary\n\tfileevent $fd readable [cb _readtree_wait $fd]\n}\n\nmethod _readtree_wait {fd} {\n\tglobal current_branch\n\n\tset buf [read $fd]\n\t$::main_status update_meter $buf\n\tappend readtree_d $buf\n\n\tfconfigure $fd -blocking 1\n\tif {![eof $fd]} {\n\t\tfconfigure $fd -blocking 0\n\t\treturn\n\t}\n\n\tif {[catch {close $fd}]} {\n\t\tset err $readtree_d\n\t\tregsub {^fatal: } $err {} err\n\t\t$::main_status stop \"Aborted checkout of '[_name $this]' (file level merging is required).\"\n\t\twarn_popup \"File level merge required.\n\n$err\n\nStaying on branch '$current_branch'.\"\n\t\tunlock_index\n\t\tdelete_this\n\t\treturn\n\t}\n\n\t$::main_status stop\n\t_after_readtree $this\n}\n\nmethod _after_readtree {} {\n\tglobal selected_commit_type commit_type HEAD MERGE_HEAD PARENT\n\tglobal current_branch is_detached\n\tglobal ui_comm\n\n\tset name [_name $this]\n\tset log \"checkout: moving\"\n\tif {!$is_detached} {\n\t\tappend log \" from $current_branch\"\n\t}\n\n\t# -- Move/create HEAD as a symbolic ref.  Core git does not\n\t#    even check for failure here, it Just Works(tm).  If it\n\t#    doesn't we are in some really ugly state that is difficult\n\t#    to recover from within git-gui.\n\t#\n\tset rh refs/heads/\n\tset rn [string length $rh]\n\tif {[string equal -length $rn $rh $new_ref]} {\n\t\tset new_branch [string range $new_ref $rn end]\n\t\tappend log \" to $new_branch\"\n\n\t\tif {[catch {\n\t\t\t\tgit symbolic-ref -m $log HEAD $new_ref\n\t\t\t} err]} {\n\t\t\t_fatal $this $err\n\t\t}\n\t\tset current_branch $new_branch\n\t\tset is_detached 0\n\t} else {\n\t\tappend log \" to $new_expr\"\n\n\t\tif {[catch {\n\t\t\t\t_detach_HEAD $log $new_hash\n\t\t\t} err]} {\n\t\t\t_fatal $this $err\n\t\t}\n\t\tset current_branch HEAD\n\t\tset is_detached 1\n\t}\n\n\t# -- We had to defer updating the branch itself until we\n\t#    knew the working directory would update.  So now we\n\t#    need to finish that work.  If it fails we're in big\n\t#    trouble.\n\t#\n\tif {$update_old ne {}} {\n\t\tif {[catch {\n\t\t\t\tgit update-ref \\\n\t\t\t\t\t-m $reflog_msg \\\n\t\t\t\t\t$new_ref \\\n\t\t\t\t\t$new_hash \\\n\t\t\t\t\t$update_old\n\t\t\t} err]} {\n\t\t\t_fatal $this $err\n\t\t}\n\t}\n\n\tif {$is_detached} {\n\t\tinfo_popup \"You are no longer on a local branch.\n\nIf you wanted to be on a branch, create one now starting from 'This Detached Checkout'.\"\n\t}\n\n\t# -- Update our repository state.  If we were previously in\n\t#    amend mode we need to toss the current buffer and do a\n\t#    full rescan to update our file lists.  If we weren't in\n\t#    amend mode our file lists are accurate and we can avoid\n\t#    the rescan.\n\t#\n\tunlock_index\n\tset selected_commit_type new\n\tif {[string match amend* $commit_type]} {\n\t\t$ui_comm delete 0.0 end\n\t\t$ui_comm edit reset\n\t\t$ui_comm edit modified false\n\t\trescan [list ui_status \"Checked out '$name'.\"]\n\t} else {\n\t\trepository_state commit_type HEAD MERGE_HEAD\n\t\tset PARENT $HEAD\n\t\tui_status \"Checked out '$name'.\"\n\t}\n\tdelete_this\n}\n\ngit-version proc _detach_HEAD {log new} {\n\t>= 1.5.3 {\n\t\tgit update-ref --no-deref -m $log HEAD $new\n\t}\n\tdefault {\n\t\tset p [gitdir HEAD]\n\t\tfile delete $p\n\t\tset fd [open $p w]\n\t\tfconfigure $fd -translation lf -encoding utf-8\n\t\tputs $fd $new\n\t\tclose $fd\n\t}\n}\n\nmethod _confirm_reset {cur} {\n\tset reset_ok 0\n\tset name [_name $this]\n\tset gitk [list do_gitk [list $cur ^$new_hash]]\n\n\t_toplevel $this {Confirm Branch Reset}\n\tpack [label $w.msg1 \\\n\t\t-anchor w \\\n\t\t-justify left \\\n\t\t-text \"Resetting '$name' to $new_expr will lose the following commits:\" \\\n\t\t] -anchor w\n\n\tset list $w.list.l\n\tframe $w.list\n\ttext $list \\\n\t\t-font font_diff \\\n\t\t-width 80 \\\n\t\t-height 10 \\\n\t\t-wrap none \\\n\t\t-xscrollcommand [list $w.list.sbx set] \\\n\t\t-yscrollcommand [list $w.list.sby set]\n\tscrollbar $w.list.sbx -orient h -command [list $list xview]\n\tscrollbar $w.list.sby -orient v -command [list $list yview]\n\tpack $w.list.sbx -fill x -side bottom\n\tpack $w.list.sby -fill y -side right\n\tpack $list -fill both -expand 1\n\tpack $w.list -fill both -expand 1 -padx 5 -pady 5\n\n\tpack [label $w.msg2 \\\n\t\t-anchor w \\\n\t\t-justify left \\\n\t\t-text {Recovering lost commits may not be easy.} \\\n\t\t]\n\tpack [label $w.msg3 \\\n\t\t-anchor w \\\n\t\t-justify left \\\n\t\t-text \"Reset '$name'?\" \\\n\t\t]\n\n\tframe $w.buttons\n\tbutton $w.buttons.visualize \\\n\t\t-text Visualize \\\n\t\t-command $gitk\n\tpack $w.buttons.visualize -side left\n\tbutton $w.buttons.reset \\\n\t\t-text Reset \\\n\t\t-command \"\n\t\t\tset @reset_ok 1\n\t\t\tdestroy $w\n\t\t\"\n\tpack $w.buttons.reset -side right\n\tbutton $w.buttons.cancel \\\n\t\t-default active \\\n\t\t-text Cancel \\\n\t\t-command [list destroy $w]\n\tpack $w.buttons.cancel -side right -padx 5\n\tpack $w.buttons -side bottom -fill x -pady 10 -padx 10\n\n\tset fd [git_read rev-list --pretty=oneline $cur ^$new_hash]\n\twhile {[gets $fd line] > 0} {\n\t\tset abbr [string range $line 0 7]\n\t\tset subj [string range $line 41 end]\n\t\t$list insert end \"$abbr  $subj\\n\"\n\t}\n\tclose $fd\n\t$list configure -state disabled\n\n\tbind $w    <Key-v> $gitk\n\tbind $w <Visibility> \"\n\t\tgrab $w\n\t\tfocus $w.buttons.cancel\n\t\"\n\tbind $w <Key-Return> [list destroy $w]\n\tbind $w <Key-Escape> [list destroy $w]\n\ttkwait window $w\n\treturn $reset_ok\n}\n\nmethod _error {msg} {\n\tif {[winfo ismapped $parent_w]} {\n\t\tset p $parent_w\n\t} else {\n\t\tset p .\n\t}\n\n\ttk_messageBox \\\n\t\t-icon error \\\n\t\t-type ok \\\n\t\t-title [wm title $p] \\\n\t\t-parent $p \\\n\t\t-message $msg\n}\n\nmethod _toplevel {title} {\n\tregsub -all {::} $this {__} w\n\tset w .$w\n\n\tif {[winfo ismapped $parent_w]} {\n\t\tset p $parent_w\n\t} else {\n\t\tset p .\n\t}\n\n\ttoplevel $w\n\twm title $w $title\n\twm geometry $w \"+[winfo rootx $p]+[winfo rooty $p]\"\n}\n\nmethod _fatal {err} {\n\terror_popup \"Failed to set current branch.\n\nThis working directory is only partially switched.  We successfully updated your files, but failed to update an internal Git file.\n\nThis should not have occurred.  [appname] will now close and give up.\n\n$err\"\n\texit 1\n}\n\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00a994be120edaa1024733cb94e3f1fe4e494039",
  "sha1_ok": true,
  "size": 12766
}
