{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCiNpbmNsdWRlICJ0cmFuc3BvcnQuaCIKI2luY2x1ZGUgInJlbW90ZS5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgInN0cmJ1Zi5oIgojaW5jbHVkZSAicnVuLWNvbW1hbmQuaCIKI2luY2x1ZGUgInJlZnMuaCIKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgYnVpbHRpbl9yZW1vdGVfdXNhZ2VbXSA9IHsKCSJnaXQgcmVtb3RlIFstdiB8IC0tdmVyYm9zZV0iLAoJImdpdCByZW1vdGUgYWRkIFstdCA8YnJhbmNoPl0gWy1tIDxtYXN0ZXI+XSBbLWZdIFstLW1pcnJvcl0gPG5hbWU+IDx1cmw+IiwKCSJnaXQgcmVtb3RlIHJlbmFtZSA8b2xkPiA8bmV3PiIsCgkiZ2l0IHJlbW90ZSBybSA8bmFtZT4iLAoJImdpdCByZW1vdGUgc2V0LWhlYWQgPG5hbWU+IFstYSB8IC1kIHwgPGJyYW5jaD5dIiwKCSJnaXQgcmVtb3RlIHNob3cgWy1uXSA8bmFtZT4iLAoJImdpdCByZW1vdGUgcHJ1bmUgWy1uIHwgLS1kcnktcnVuXSA8bmFtZT4iLAoJImdpdCByZW1vdGUgWy12IHwgLS12ZXJib3NlXSB1cGRhdGUgWy1wIHwgLS1wcnVuZV0gW2dyb3VwXSIsCglOVUxMCn07CgojZGVmaW5lIEdFVF9SRUZfU1RBVEVTICgxPDwwKQojZGVmaW5lIEdFVF9IRUFEX05BTUVTICgxPDwxKQojZGVmaW5lIEdFVF9QVVNIX1JFRl9TVEFURVMgKDE8PDIpCgpzdGF0aWMgaW50IHZlcmJvc2U7CgpzdGF0aWMgaW50IHNob3dfYWxsKHZvaWQpOwpzdGF0aWMgaW50IHBydW5lX3JlbW90ZShjb25zdCBjaGFyICpyZW1vdGUsIGludCBkcnlfcnVuKTsKCnN0YXRpYyBpbmxpbmUgaW50IHBvc3RmaXhjbXAoY29uc3QgY2hhciAqc3RyaW5nLCBjb25zdCBjaGFyICpwb3N0Zml4KQp7CglpbnQgbGVuMSA9IHN0cmxlbihzdHJpbmcpLCBsZW4yID0gc3RybGVuKHBvc3RmaXgpOwoJaWYgKGxlbjEgPCBsZW4yKQoJCXJldHVybiAxOwoJcmV0dXJuIHN0cmNtcChzdHJpbmcgKyBsZW4xIC0gbGVuMiwgcG9zdGZpeCk7Cn0KCnN0YXRpYyBpbnQgb3B0X3BhcnNlX3RyYWNrKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgbm90KQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QgPSBvcHQtPnZhbHVlOwoJaWYgKG5vdCkKCQlzdHJpbmdfbGlzdF9jbGVhcihsaXN0LCAwKTsKCWVsc2UKCQlzdHJpbmdfbGlzdF9hcHBlbmQoYXJnLCBsaXN0KTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGZldGNoX3JlbW90ZShjb25zdCBjaGFyICpuYW1lKQp7Cgljb25zdCBjaGFyICphcmd2W10gPSB7ICJmZXRjaCIsIG5hbWUsIE5VTEwsIE5VTEwgfTsKCWlmICh2ZXJib3NlKSB7CgkJYXJndlsxXSA9ICItdiI7CgkJYXJndlsyXSA9IG5hbWU7Cgl9CglwcmludGYoIlVwZGF0aW5nICVzXG4iLCBuYW1lKTsKCWlmIChydW5fY29tbWFuZF92X29wdChhcmd2LCBSVU5fR0lUX0NNRCkpCgkJcmV0dXJuIGVycm9yKCJDb3VsZCBub3QgZmV0Y2ggJXMiLCBuYW1lKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGFkZChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YpCnsKCWludCBmZXRjaCA9IDAsIG1pcnJvciA9IDA7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgdHJhY2sgPSB7IE5VTEwsIDAsIDAgfTsKCWNvbnN0IGNoYXIgKm1hc3RlciA9IE5VTEw7CglzdHJ1Y3QgcmVtb3RlICpyZW1vdGU7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklULCBidWYyID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpuYW1lLCAqdXJsOwoJaW50IGk7CgoJc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJT1BUX0dST1VQKCJhZGQgc3BlY2lmaWMgb3B0aW9ucyIpLAoJCU9QVF9CT09MRUFOKCdmJywgImZldGNoIiwgJmZldGNoLCAiZmV0Y2ggdGhlIHJlbW90ZSBicmFuY2hlcyIpLAoJCU9QVF9DQUxMQkFDSygndCcsICJ0cmFjayIsICZ0cmFjaywgImJyYW5jaCIsCgkJCSJicmFuY2goZXMpIHRvIHRyYWNrIiwgb3B0X3BhcnNlX3RyYWNrKSwKCQlPUFRfU1RSSU5HKCdtJywgIm1hc3RlciIsICZtYXN0ZXIsICJicmFuY2giLCAibWFzdGVyIGJyYW5jaCIpLAoJCU9QVF9CT09MRUFOKDAsICJtaXJyb3IiLCAmbWlycm9yLCAibm8gc2VwYXJhdGUgcmVtb3RlcyIpLAoJCU9QVF9FTkQoKQoJfTsKCglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBOVUxMLCBvcHRpb25zLCBidWlsdGluX3JlbW90ZV91c2FnZSwKCQkJICAgICAwKTsKCglpZiAoYXJnYyA8IDIpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGJ1aWx0aW5fcmVtb3RlX3VzYWdlLCBvcHRpb25zKTsKCgluYW1lID0gYXJndlswXTsKCXVybCA9IGFyZ3ZbMV07CgoJcmVtb3RlID0gcmVtb3RlX2dldChuYW1lKTsKCWlmIChyZW1vdGUgJiYgKHJlbW90ZS0+dXJsX25yID4gMSB8fCBzdHJjbXAobmFtZSwgcmVtb3RlLT51cmxbMF0pIHx8CgkJCXJlbW90ZS0+ZmV0Y2hfcmVmc3BlY19ucikpCgkJZGllKCJyZW1vdGUgJXMgYWxyZWFkeSBleGlzdHMuIiwgbmFtZSk7CgoJc3RyYnVmX2FkZGYoJmJ1ZjIsICJyZWZzL2hlYWRzL3Rlc3Q6cmVmcy9yZW1vdGVzLyVzL3Rlc3QiLCBuYW1lKTsKCWlmICghdmFsaWRfZmV0Y2hfcmVmc3BlYyhidWYyLmJ1ZikpCgkJZGllKCInJXMnIGlzIG5vdCBhIHZhbGlkIHJlbW90ZSBuYW1lIiwgbmFtZSk7CgoJc3RyYnVmX2FkZGYoJmJ1ZiwgInJlbW90ZS4lcy51cmwiLCBuYW1lKTsKCWlmIChnaXRfY29uZmlnX3NldChidWYuYnVmLCB1cmwpKQoJCXJldHVybiAxOwoKCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCXN0cmJ1Zl9hZGRmKCZidWYsICJyZW1vdGUuJXMuZmV0Y2giLCBuYW1lKTsKCglpZiAodHJhY2subnIgPT0gMCkKCQlzdHJpbmdfbGlzdF9hcHBlbmQoIioiLCAmdHJhY2spOwoJZm9yIChpID0gMDsgaSA8IHRyYWNrLm5yOyBpKyspIHsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbSA9IHRyYWNrLml0ZW1zICsgaTsKCgkJc3RyYnVmX3Jlc2V0KCZidWYyKTsKCQlzdHJidWZfYWRkY2goJmJ1ZjIsICcrJyk7CgkJaWYgKG1pcnJvcikKCQkJc3RyYnVmX2FkZGYoJmJ1ZjIsICJyZWZzLyVzOnJlZnMvJXMiLAoJCQkJCWl0ZW0tPnN0cmluZywgaXRlbS0+c3RyaW5nKTsKCQllbHNlCgkJCXN0cmJ1Zl9hZGRmKCZidWYyLCAicmVmcy9oZWFkcy8lczpyZWZzL3JlbW90ZXMvJXMvJXMiLAoJCQkJCWl0ZW0tPnN0cmluZywgbmFtZSwgaXRlbS0+c3RyaW5nKTsKCQlpZiAoZ2l0X2NvbmZpZ19zZXRfbXVsdGl2YXIoYnVmLmJ1ZiwgYnVmMi5idWYsICJeJCIsIDApKQoJCQlyZXR1cm4gMTsKCX0KCglpZiAobWlycm9yKSB7CgkJc3RyYnVmX3Jlc2V0KCZidWYpOwoJCXN0cmJ1Zl9hZGRmKCZidWYsICJyZW1vdGUuJXMubWlycm9yIiwgbmFtZSk7CgkJaWYgKGdpdF9jb25maWdfc2V0KGJ1Zi5idWYsICJ0cnVlIikpCgkJCXJldHVybiAxOwoJfQoKCWlmIChmZXRjaCAmJiBmZXRjaF9yZW1vdGUobmFtZSkpCgkJcmV0dXJuIDE7CgoJaWYgKG1hc3RlcikgewoJCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCQlzdHJidWZfYWRkZigmYnVmLCAicmVmcy9yZW1vdGVzLyVzL0hFQUQiLCBuYW1lKTsKCgkJc3RyYnVmX3Jlc2V0KCZidWYyKTsKCQlzdHJidWZfYWRkZigmYnVmMiwgInJlZnMvcmVtb3Rlcy8lcy8lcyIsIG5hbWUsIG1hc3Rlcik7CgoJCWlmIChjcmVhdGVfc3ltcmVmKGJ1Zi5idWYsIGJ1ZjIuYnVmLCAicmVtb3RlIGFkZCIpKQoJCQlyZXR1cm4gZXJyb3IoIkNvdWxkIG5vdCBzZXR1cCBtYXN0ZXIgJyVzJyIsIG1hc3Rlcik7Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CglzdHJidWZfcmVsZWFzZSgmYnVmMik7CglzdHJpbmdfbGlzdF9jbGVhcigmdHJhY2ssIDApOwoKCXJldHVybiAwOwp9CgpzdHJ1Y3QgYnJhbmNoX2luZm8gewoJY2hhciAqcmVtb3RlX25hbWU7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgbWVyZ2U7CglpbnQgcmViYXNlOwp9OwoKc3RhdGljIHN0cnVjdCBzdHJpbmdfbGlzdCBicmFuY2hfbGlzdDsKCnN0YXRpYyBjb25zdCBjaGFyICphYmJyZXZfcmVmKGNvbnN0IGNoYXIgKm5hbWUsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJY29uc3QgY2hhciAqYWJicmV2ID0gc2tpcF9wcmVmaXgobmFtZSwgcHJlZml4KTsKCWlmIChhYmJyZXYpCgkJcmV0dXJuIGFiYnJldjsKCXJldHVybiBuYW1lOwp9CiNkZWZpbmUgYWJicmV2X2JyYW5jaChuYW1lKSBhYmJyZXZfcmVmKChuYW1lKSwgInJlZnMvaGVhZHMvIikKCnN0YXRpYyBpbnQgY29uZmlnX3JlYWRfYnJhbmNoZXMoY29uc3QgY2hhciAqa2V5LCBjb25zdCBjaGFyICp2YWx1ZSwgdm9pZCAqY2IpCnsKCWlmICghcHJlZml4Y21wKGtleSwgImJyYW5jaC4iKSkgewoJCWNvbnN0IGNoYXIgKm9yaWdfa2V5ID0ga2V5OwoJCWNoYXIgKm5hbWU7CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW07CgkJc3RydWN0IGJyYW5jaF9pbmZvICppbmZvOwoJCWVudW0geyBSRU1PVEUsIE1FUkdFLCBSRUJBU0UgfSB0eXBlOwoKCQlrZXkgKz0gNzsKCQlpZiAoIXBvc3RmaXhjbXAoa2V5LCAiLnJlbW90ZSIpKSB7CgkJCW5hbWUgPSB4c3RybmR1cChrZXksIHN0cmxlbihrZXkpIC0gNyk7CgkJCXR5cGUgPSBSRU1PVEU7CgkJfSBlbHNlIGlmICghcG9zdGZpeGNtcChrZXksICIubWVyZ2UiKSkgewoJCQluYW1lID0geHN0cm5kdXAoa2V5LCBzdHJsZW4oa2V5KSAtIDYpOwoJCQl0eXBlID0gTUVSR0U7CgkJfSBlbHNlIGlmICghcG9zdGZpeGNtcChrZXksICIucmViYXNlIikpIHsKCQkJbmFtZSA9IHhzdHJuZHVwKGtleSwgc3RybGVuKGtleSkgLSA3KTsKCQkJdHlwZSA9IFJFQkFTRTsKCQl9IGVsc2UKCQkJcmV0dXJuIDA7CgoJCWl0ZW0gPSBzdHJpbmdfbGlzdF9pbnNlcnQobmFtZSwgJmJyYW5jaF9saXN0KTsKCgkJaWYgKCFpdGVtLT51dGlsKQoJCQlpdGVtLT51dGlsID0geGNhbGxvYyhzaXplb2Yoc3RydWN0IGJyYW5jaF9pbmZvKSwgMSk7CgkJaW5mbyA9IGl0ZW0tPnV0aWw7CgkJaWYgKHR5cGUgPT0gUkVNT1RFKSB7CgkJCWlmIChpbmZvLT5yZW1vdGVfbmFtZSkKCQkJCXdhcm5pbmcoIm1vcmUgdGhhbiBvbmUgJXMiLCBvcmlnX2tleSk7CgkJCWluZm8tPnJlbW90ZV9uYW1lID0geHN0cmR1cCh2YWx1ZSk7CgkJfSBlbHNlIGlmICh0eXBlID09IE1FUkdFKSB7CgkJCWNoYXIgKnNwYWNlID0gc3RyY2hyKHZhbHVlLCAnICcpOwoJCQl2YWx1ZSA9IGFiYnJldl9icmFuY2godmFsdWUpOwoJCQl3aGlsZSAoc3BhY2UpIHsKCQkJCWNoYXIgKm1lcmdlOwoJCQkJbWVyZ2UgPSB4c3RybmR1cCh2YWx1ZSwgc3BhY2UgLSB2YWx1ZSk7CgkJCQlzdHJpbmdfbGlzdF9hcHBlbmQobWVyZ2UsICZpbmZvLT5tZXJnZSk7CgkJCQl2YWx1ZSA9IGFiYnJldl9icmFuY2goc3BhY2UgKyAxKTsKCQkJCXNwYWNlID0gc3RyY2hyKHZhbHVlLCAnICcpOwoJCQl9CgkJCXN0cmluZ19saXN0X2FwcGVuZCh4c3RyZHVwKHZhbHVlKSwgJmluZm8tPm1lcmdlKTsKCQl9IGVsc2UKCQkJaW5mby0+cmViYXNlID0gZ2l0X2NvbmZpZ19ib29sKG9yaWdfa2V5LCB2YWx1ZSk7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgcmVhZF9icmFuY2hlcyh2b2lkKQp7CglpZiAoYnJhbmNoX2xpc3QubnIpCgkJcmV0dXJuOwoJZ2l0X2NvbmZpZyhjb25maWdfcmVhZF9icmFuY2hlcywgTlVMTCk7Cn0KCnN0cnVjdCByZWZfc3RhdGVzIHsKCXN0cnVjdCByZW1vdGUgKnJlbW90ZTsKCXN0cnVjdCBzdHJpbmdfbGlzdCBuZXcsIHN0YWxlLCB0cmFja2VkLCBoZWFkcywgcHVzaDsKCWludCBxdWVyaWVkOwp9OwoKc3RhdGljIGludCBoYW5kbGVfb25lX2JyYW5jaChjb25zdCBjaGFyICpyZWZuYW1lLAoJY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgaW50IGZsYWdzLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3QgcmVmX3N0YXRlcyAqc3RhdGVzID0gY2JfZGF0YTsKCXN0cnVjdCByZWZzcGVjIHJlZnNwZWM7CgoJbWVtc2V0KCZyZWZzcGVjLCAwLCBzaXplb2YocmVmc3BlYykpOwoJcmVmc3BlYy5kc3QgPSAoY2hhciAqKXJlZm5hbWU7CglpZiAoIXJlbW90ZV9maW5kX3RyYWNraW5nKHN0YXRlcy0+cmVtb3RlLCAmcmVmc3BlYykpIHsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbTsKCQljb25zdCBjaGFyICpuYW1lID0gYWJicmV2X2JyYW5jaChyZWZzcGVjLnNyYyk7CgkJLyogc3ltYm9saWMgcmVmcyBwb2ludGluZyBub3doZXJlIHdlcmUgaGFuZGxlZCBhbHJlYWR5ICovCgkJaWYgKChmbGFncyAmIFJFRl9JU1NZTVJFRikgfHwKCQkgICAgc3RyaW5nX2xpc3RfaGFzX3N0cmluZygmc3RhdGVzLT50cmFja2VkLCBuYW1lKSB8fAoJCSAgICBzdHJpbmdfbGlzdF9oYXNfc3RyaW5nKCZzdGF0ZXMtPm5ldywgbmFtZSkpCgkJCXJldHVybiAwOwoJCWl0ZW0gPSBzdHJpbmdfbGlzdF9hcHBlbmQobmFtZSwgJnN0YXRlcy0+c3RhbGUpOwoJCWl0ZW0tPnV0aWwgPSB4c3RyZHVwKHJlZm5hbWUpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZ2V0X3JlZl9zdGF0ZXMoY29uc3Qgc3RydWN0IHJlZiAqcmVtb3RlX3JlZnMsIHN0cnVjdCByZWZfc3RhdGVzICpzdGF0ZXMpCnsKCXN0cnVjdCByZWYgKmZldGNoX21hcCA9IE5VTEwsICoqdGFpbCA9ICZmZXRjaF9tYXA7CglzdHJ1Y3QgcmVmICpyZWY7CglpbnQgaTsKCglmb3IgKGkgPSAwOyBpIDwgc3RhdGVzLT5yZW1vdGUtPmZldGNoX3JlZnNwZWNfbnI7IGkrKykKCQlpZiAoZ2V0X2ZldGNoX21hcChyZW1vdGVfcmVmcywgc3RhdGVzLT5yZW1vdGUtPmZldGNoICsgaSwgJnRhaWwsIDEpKQoJCQlkaWUoIkNvdWxkIG5vdCBnZXQgZmV0Y2ggbWFwIGZvciByZWZzcGVjICVzIiwKCQkJCXN0YXRlcy0+cmVtb3RlLT5mZXRjaF9yZWZzcGVjW2ldKTsKCglzdGF0ZXMtPm5ldy5zdHJkdXBfc3RyaW5ncyA9IHN0YXRlcy0+dHJhY2tlZC5zdHJkdXBfc3RyaW5ncyA9IDE7Cglmb3IgKHJlZiA9IGZldGNoX21hcDsgcmVmOyByZWYgPSByZWYtPm5leHQpIHsKCQl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJCWlmICghcmVmLT5wZWVyX3JlZiB8fCByZWFkX3JlZihyZWYtPnBlZXJfcmVmLT5uYW1lLCBzaGExKSkKCQkJc3RyaW5nX2xpc3RfYXBwZW5kKGFiYnJldl9icmFuY2gocmVmLT5uYW1lKSwgJnN0YXRlcy0+bmV3KTsKCQllbHNlCgkJCXN0cmluZ19saXN0X2FwcGVuZChhYmJyZXZfYnJhbmNoKHJlZi0+bmFtZSksICZzdGF0ZXMtPnRyYWNrZWQpOwoJfQoJZnJlZV9yZWZzKGZldGNoX21hcCk7CgoJc29ydF9zdHJpbmdfbGlzdCgmc3RhdGVzLT5uZXcpOwoJc29ydF9zdHJpbmdfbGlzdCgmc3RhdGVzLT50cmFja2VkKTsKCWZvcl9lYWNoX3JlZihoYW5kbGVfb25lX2JyYW5jaCwgc3RhdGVzKTsKCXNvcnRfc3RyaW5nX2xpc3QoJnN0YXRlcy0+c3RhbGUpOwoKCXJldHVybiAwOwp9CgpzdHJ1Y3QgcHVzaF9pbmZvIHsKCWNoYXIgKmRlc3Q7CglpbnQgZm9yY2VkOwoJZW51bSB7CgkJUFVTSF9TVEFUVVNfQ1JFQVRFID0gMCwKCQlQVVNIX1NUQVRVU19ERUxFVEUsCgkJUFVTSF9TVEFUVVNfVVBUT0RBVEUsCgkJUFVTSF9TVEFUVVNfRkFTVEZPUldBUkQsCgkJUFVTSF9TVEFUVVNfT1VUT0ZEQVRFLAoJCVBVU0hfU1RBVFVTX05PVFFVRVJJRUQsCgl9IHN0YXR1czsKfTsKCnN0YXRpYyBpbnQgZ2V0X3B1c2hfcmVmX3N0YXRlcyhjb25zdCBzdHJ1Y3QgcmVmICpyZW1vdGVfcmVmcywKCXN0cnVjdCByZWZfc3RhdGVzICpzdGF0ZXMpCnsKCXN0cnVjdCByZW1vdGUgKnJlbW90ZSA9IHN0YXRlcy0+cmVtb3RlOwoJc3RydWN0IHJlZiAqcmVmLCAqbG9jYWxfcmVmcywgKnB1c2hfbWFwOwoJaWYgKHJlbW90ZS0+bWlycm9yKQoJCXJldHVybiAwOwoKCWxvY2FsX3JlZnMgPSBnZXRfbG9jYWxfaGVhZHMoKTsKCXB1c2hfbWFwID0gY29weV9yZWZfbGlzdChyZW1vdGVfcmVmcyk7CgoJbWF0Y2hfcmVmcyhsb2NhbF9yZWZzLCAmcHVzaF9tYXAsIHJlbW90ZS0+cHVzaF9yZWZzcGVjX25yLAoJCSAgIHJlbW90ZS0+cHVzaF9yZWZzcGVjLCBNQVRDSF9SRUZTX05PTkUpOwoKCXN0YXRlcy0+cHVzaC5zdHJkdXBfc3RyaW5ncyA9IDE7Cglmb3IgKHJlZiA9IHB1c2hfbWFwOyByZWY7IHJlZiA9IHJlZi0+bmV4dCkgewoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoJCXN0cnVjdCBwdXNoX2luZm8gKmluZm87CgoJCWlmICghcmVmLT5wZWVyX3JlZikKCQkJY29udGludWU7CgkJaGFzaGNweShyZWYtPm5ld19zaGExLCByZWYtPnBlZXJfcmVmLT5uZXdfc2hhMSk7CgoJCWl0ZW0gPSBzdHJpbmdfbGlzdF9hcHBlbmQoYWJicmV2X2JyYW5jaChyZWYtPnBlZXJfcmVmLT5uYW1lKSwKCQkJCQkgICZzdGF0ZXMtPnB1c2gpOwoJCWl0ZW0tPnV0aWwgPSB4Y2FsbG9jKHNpemVvZihzdHJ1Y3QgcHVzaF9pbmZvKSwgMSk7CgkJaW5mbyA9IGl0ZW0tPnV0aWw7CgkJaW5mby0+Zm9yY2VkID0gcmVmLT5mb3JjZTsKCQlpbmZvLT5kZXN0ID0geHN0cmR1cChhYmJyZXZfYnJhbmNoKHJlZi0+bmFtZSkpOwoKCQlpZiAoaXNfbnVsbF9zaGExKHJlZi0+bmV3X3NoYTEpKSB7CgkJCWluZm8tPnN0YXR1cyA9IFBVU0hfU1RBVFVTX0RFTEVURTsKCQl9IGVsc2UgaWYgKCFoYXNoY21wKHJlZi0+b2xkX3NoYTEsIHJlZi0+bmV3X3NoYTEpKQoJCQlpbmZvLT5zdGF0dXMgPSBQVVNIX1NUQVRVU19VUFRPREFURTsKCQllbHNlIGlmIChpc19udWxsX3NoYTEocmVmLT5vbGRfc2hhMSkpCgkJCWluZm8tPnN0YXR1cyA9IFBVU0hfU1RBVFVTX0NSRUFURTsKCQllbHNlIGlmIChoYXNfc2hhMV9maWxlKHJlZi0+b2xkX3NoYTEpICYmCgkJCSByZWZfbmV3ZXIocmVmLT5uZXdfc2hhMSwgcmVmLT5vbGRfc2hhMSkpCgkJCWluZm8tPnN0YXR1cyA9IFBVU0hfU1RBVFVTX0ZBU1RGT1JXQVJEOwoJCWVsc2UKCQkJaW5mby0+c3RhdHVzID0gUFVTSF9TVEFUVVNfT1VUT0ZEQVRFOwoJfQoJZnJlZV9yZWZzKGxvY2FsX3JlZnMpOwoJZnJlZV9yZWZzKHB1c2hfbWFwKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdldF9wdXNoX3JlZl9zdGF0ZXNfbm9xdWVyeShzdHJ1Y3QgcmVmX3N0YXRlcyAqc3RhdGVzKQp7CglpbnQgaTsKCXN0cnVjdCByZW1vdGUgKnJlbW90ZSA9IHN0YXRlcy0+cmVtb3RlOwoJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW07CglzdHJ1Y3QgcHVzaF9pbmZvICppbmZvOwoKCWlmIChyZW1vdGUtPm1pcnJvcikKCQlyZXR1cm4gMDsKCglzdGF0ZXMtPnB1c2guc3RyZHVwX3N0cmluZ3MgPSAxOwoJaWYgKCFyZW1vdGUtPnB1c2hfcmVmc3BlY19ucikgewoJCWl0ZW0gPSBzdHJpbmdfbGlzdF9hcHBlbmQoIihtYXRjaGluZykiLCAmc3RhdGVzLT5wdXNoKTsKCQlpbmZvID0gaXRlbS0+dXRpbCA9IHhjYWxsb2Moc2l6ZW9mKHN0cnVjdCBwdXNoX2luZm8pLCAxKTsKCQlpbmZvLT5zdGF0dXMgPSBQVVNIX1NUQVRVU19OT1RRVUVSSUVEOwoJCWluZm8tPmRlc3QgPSB4c3RyZHVwKGl0ZW0tPnN0cmluZyk7Cgl9Cglmb3IgKGkgPSAwOyBpIDwgcmVtb3RlLT5wdXNoX3JlZnNwZWNfbnI7IGkrKykgewoJCXN0cnVjdCByZWZzcGVjICpzcGVjID0gcmVtb3RlLT5wdXNoICsgaTsKCQlpZiAoc3BlYy0+bWF0Y2hpbmcpCgkJCWl0ZW0gPSBzdHJpbmdfbGlzdF9hcHBlbmQoIihtYXRjaGluZykiLCAmc3RhdGVzLT5wdXNoKTsKCQllbHNlIGlmIChzdHJsZW4oc3BlYy0+c3JjKSkKCQkJaXRlbSA9IHN0cmluZ19saXN0X2FwcGVuZChzcGVjLT5zcmMsICZzdGF0ZXMtPnB1c2gpOwoJCWVsc2UKCQkJaXRlbSA9IHN0cmluZ19saXN0X2FwcGVuZCgiKGRlbGV0ZSkiLCAmc3RhdGVzLT5wdXNoKTsKCgkJaW5mbyA9IGl0ZW0tPnV0aWwgPSB4Y2FsbG9jKHNpemVvZihzdHJ1Y3QgcHVzaF9pbmZvKSwgMSk7CgkJaW5mby0+Zm9yY2VkID0gc3BlYy0+Zm9yY2U7CgkJaW5mby0+c3RhdHVzID0gUFVTSF9TVEFUVVNfTk9UUVVFUklFRDsKCQlpbmZvLT5kZXN0ID0geHN0cmR1cChzcGVjLT5kc3QgPyBzcGVjLT5kc3QgOiBpdGVtLT5zdHJpbmcpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZ2V0X2hlYWRfbmFtZXMoY29uc3Qgc3RydWN0IHJlZiAqcmVtb3RlX3JlZnMsIHN0cnVjdCByZWZfc3RhdGVzICpzdGF0ZXMpCnsKCXN0cnVjdCByZWYgKnJlZiwgKm1hdGNoZXM7CglzdHJ1Y3QgcmVmICpmZXRjaF9tYXAgPSBOVUxMLCAqKmZldGNoX21hcF90YWlsID0gJmZldGNoX21hcDsKCXN0cnVjdCByZWZzcGVjIHJlZnNwZWM7CgoJcmVmc3BlYy5mb3JjZSA9IDA7CglyZWZzcGVjLnBhdHRlcm4gPSAxOwoJcmVmc3BlYy5zcmMgPSByZWZzcGVjLmRzdCA9ICJyZWZzL2hlYWRzLyoiOwoJc3RhdGVzLT5oZWFkcy5zdHJkdXBfc3RyaW5ncyA9IDE7CglnZXRfZmV0Y2hfbWFwKHJlbW90ZV9yZWZzLCAmcmVmc3BlYywgJmZldGNoX21hcF90YWlsLCAwKTsKCW1hdGNoZXMgPSBndWVzc19yZW1vdGVfaGVhZChmaW5kX3JlZl9ieV9uYW1lKHJlbW90ZV9yZWZzLCAiSEVBRCIpLAoJCQkJICAgIGZldGNoX21hcCwgMSk7Cglmb3IocmVmID0gbWF0Y2hlczsgcmVmOyByZWYgPSByZWYtPm5leHQpCgkJc3RyaW5nX2xpc3RfYXBwZW5kKGFiYnJldl9icmFuY2gocmVmLT5uYW1lKSwgJnN0YXRlcy0+aGVhZHMpOwoKCWZyZWVfcmVmcyhmZXRjaF9tYXApOwoJZnJlZV9yZWZzKG1hdGNoZXMpOwoKCXJldHVybiAwOwp9CgpzdHJ1Y3Qga25vd25fcmVtb3RlIHsKCXN0cnVjdCBrbm93bl9yZW1vdGUgKm5leHQ7CglzdHJ1Y3QgcmVtb3RlICpyZW1vdGU7Cn07CgpzdHJ1Y3Qga25vd25fcmVtb3RlcyB7CglzdHJ1Y3QgcmVtb3RlICp0b19kZWxldGU7CglzdHJ1Y3Qga25vd25fcmVtb3RlICpsaXN0Owp9OwoKc3RhdGljIGludCBhZGRfa25vd25fcmVtb3RlKHN0cnVjdCByZW1vdGUgKnJlbW90ZSwgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IGtub3duX3JlbW90ZXMgKmFsbCA9IGNiX2RhdGE7CglzdHJ1Y3Qga25vd25fcmVtb3RlICpyOwoKCWlmICghc3RyY21wKGFsbC0+dG9fZGVsZXRlLT5uYW1lLCByZW1vdGUtPm5hbWUpKQoJCXJldHVybiAwOwoKCXIgPSB4bWFsbG9jKHNpemVvZigqcikpOwoJci0+cmVtb3RlID0gcmVtb3RlOwoJci0+bmV4dCA9IGFsbC0+bGlzdDsKCWFsbC0+bGlzdCA9IHI7CglyZXR1cm4gMDsKfQoKc3RydWN0IGJyYW5jaGVzX2Zvcl9yZW1vdGUgewoJc3RydWN0IHJlbW90ZSAqcmVtb3RlOwoJc3RydWN0IHN0cmluZ19saXN0ICpicmFuY2hlcywgKnNraXBwZWQ7CglzdHJ1Y3Qga25vd25fcmVtb3RlcyAqa2VlcDsKfTsKCnN0YXRpYyBpbnQgYWRkX2JyYW5jaF9mb3JfcmVtb3ZhbChjb25zdCBjaGFyICpyZWZuYW1lLAoJY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgaW50IGZsYWdzLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3QgYnJhbmNoZXNfZm9yX3JlbW90ZSAqYnJhbmNoZXMgPSBjYl9kYXRhOwoJc3RydWN0IHJlZnNwZWMgcmVmc3BlYzsKCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoJc3RydWN0IGtub3duX3JlbW90ZSAqa3I7CgoJbWVtc2V0KCZyZWZzcGVjLCAwLCBzaXplb2YocmVmc3BlYykpOwoJcmVmc3BlYy5kc3QgPSAoY2hhciAqKXJlZm5hbWU7CglpZiAocmVtb3RlX2ZpbmRfdHJhY2tpbmcoYnJhbmNoZXMtPnJlbW90ZSwgJnJlZnNwZWMpKQoJCXJldHVybiAwOwoKCS8qIGRvbid0IGRlbGV0ZSBhIGJyYW5jaCBpZiBhbm90aGVyIHJlbW90ZSBhbHNvIHVzZXMgaXQgKi8KCWZvciAoa3IgPSBicmFuY2hlcy0+a2VlcC0+bGlzdDsga3I7IGtyID0ga3ItPm5leHQpIHsKCQltZW1zZXQoJnJlZnNwZWMsIDAsIHNpemVvZihyZWZzcGVjKSk7CgkJcmVmc3BlYy5kc3QgPSAoY2hhciAqKXJlZm5hbWU7CgkJaWYgKCFyZW1vdGVfZmluZF90cmFja2luZyhrci0+cmVtb3RlLCAmcmVmc3BlYykpCgkJCXJldHVybiAwOwoJfQoKCS8qIGRvbid0IGRlbGV0ZSBub24tcmVtb3RlIHJlZnMgKi8KCWlmIChwcmVmaXhjbXAocmVmbmFtZSwgInJlZnMvcmVtb3RlcyIpKSB7CgkJLyogYWR2aXNlIHVzZXIgaG93IHRvIGRlbGV0ZSBsb2NhbCBicmFuY2hlcyAqLwoJCWlmICghcHJlZml4Y21wKHJlZm5hbWUsICJyZWZzL2hlYWRzLyIpKQoJCQlzdHJpbmdfbGlzdF9hcHBlbmQoYWJicmV2X2JyYW5jaChyZWZuYW1lKSwKCQkJCQkgICBicmFuY2hlcy0+c2tpcHBlZCk7CgkJLyogc2lsZW50bHkgc2tpcCBvdmVyIG90aGVyIG5vbi1yZW1vdGUgcmVmcyAqLwoJCXJldHVybiAwOwoJfQoKCS8qIG1ha2Ugc3VyZSB0aGF0IHN5bXJlZnMgYXJlIGRlbGV0ZWQgKi8KCWlmIChmbGFncyAmIFJFRl9JU1NZTVJFRikKCQlyZXR1cm4gdW5saW5rKGdpdF9wYXRoKCIlcyIsIHJlZm5hbWUpKTsKCglpdGVtID0gc3RyaW5nX2xpc3RfYXBwZW5kKHJlZm5hbWUsIGJyYW5jaGVzLT5icmFuY2hlcyk7CglpdGVtLT51dGlsID0geG1hbGxvYygyMCk7CgloYXNoY3B5KGl0ZW0tPnV0aWwsIHNoYTEpOwoKCXJldHVybiAwOwp9CgpzdHJ1Y3QgcmVuYW1lX2luZm8gewoJY29uc3QgY2hhciAqb2xkOwoJY29uc3QgY2hhciAqbmV3OwoJc3RydWN0IHN0cmluZ19saXN0ICpyZW1vdGVfYnJhbmNoZXM7Cn07CgpzdGF0aWMgaW50IHJlYWRfcmVtb3RlX2JyYW5jaGVzKGNvbnN0IGNoYXIgKnJlZm5hbWUsCgljb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBpbnQgZmxhZ3MsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCByZW5hbWVfaW5mbyAqcmVuYW1lID0gY2JfZGF0YTsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbTsKCWludCBmbGFnOwoJdW5zaWduZWQgY2hhciBvcmlnX3NoYTFbMjBdOwoJY29uc3QgY2hhciAqc3ltcmVmOwoKCXN0cmJ1Zl9hZGRmKCZidWYsICJyZWZzL3JlbW90ZXMvJXMiLCByZW5hbWUtPm9sZCk7CglpZighcHJlZml4Y21wKHJlZm5hbWUsIGJ1Zi5idWYpKSB7CgkJaXRlbSA9IHN0cmluZ19saXN0X2FwcGVuZCh4c3RyZHVwKHJlZm5hbWUpLCByZW5hbWUtPnJlbW90ZV9icmFuY2hlcyk7CgkJc3ltcmVmID0gcmVzb2x2ZV9yZWYocmVmbmFtZSwgb3JpZ19zaGExLCAxLCAmZmxhZyk7CgkJaWYgKGZsYWcgJiBSRUZfSVNTWU1SRUYpCgkJCWl0ZW0tPnV0aWwgPSB4c3RyZHVwKHN5bXJlZik7CgkJZWxzZQoJCQlpdGVtLT51dGlsID0gTlVMTDsKCX0KCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBtaWdyYXRlX2ZpbGUoc3RydWN0IHJlbW90ZSAqcmVtb3RlKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaW50IGk7CgljaGFyICpwYXRoID0gTlVMTDsKCglzdHJidWZfYWRkZigmYnVmLCAicmVtb3RlLiVzLnVybCIsIHJlbW90ZS0+bmFtZSk7Cglmb3IgKGkgPSAwOyBpIDwgcmVtb3RlLT51cmxfbnI7IGkrKykKCQlpZiAoZ2l0X2NvbmZpZ19zZXRfbXVsdGl2YXIoYnVmLmJ1ZiwgcmVtb3RlLT51cmxbaV0sICJeJCIsIDApKQoJCQlyZXR1cm4gZXJyb3IoIkNvdWxkIG5vdCBhcHBlbmQgJyVzJyB0byAnJXMnIiwKCQkJCQlyZW1vdGUtPnVybFtpXSwgYnVmLmJ1Zik7CglzdHJidWZfcmVzZXQoJmJ1Zik7CglzdHJidWZfYWRkZigmYnVmLCAicmVtb3RlLiVzLnB1c2giLCByZW1vdGUtPm5hbWUpOwoJZm9yIChpID0gMDsgaSA8IHJlbW90ZS0+cHVzaF9yZWZzcGVjX25yOyBpKyspCgkJaWYgKGdpdF9jb25maWdfc2V0X211bHRpdmFyKGJ1Zi5idWYsIHJlbW90ZS0+cHVzaF9yZWZzcGVjW2ldLCAiXiQiLCAwKSkKCQkJcmV0dXJuIGVycm9yKCJDb3VsZCBub3QgYXBwZW5kICclcycgdG8gJyVzJyIsCgkJCQkJcmVtb3RlLT5wdXNoX3JlZnNwZWNbaV0sIGJ1Zi5idWYpOwoJc3RyYnVmX3Jlc2V0KCZidWYpOwoJc3RyYnVmX2FkZGYoJmJ1ZiwgInJlbW90ZS4lcy5mZXRjaCIsIHJlbW90ZS0+bmFtZSk7Cglmb3IgKGkgPSAwOyBpIDwgcmVtb3RlLT5mZXRjaF9yZWZzcGVjX25yOyBpKyspCgkJaWYgKGdpdF9jb25maWdfc2V0X211bHRpdmFyKGJ1Zi5idWYsIHJlbW90ZS0+ZmV0Y2hfcmVmc3BlY1tpXSwgIl4kIiwgMCkpCgkJCXJldHVybiBlcnJvcigiQ291bGQgbm90IGFwcGVuZCAnJXMnIHRvICclcyciLAoJCQkJCXJlbW90ZS0+ZmV0Y2hfcmVmc3BlY1tpXSwgYnVmLmJ1Zik7CglpZiAocmVtb3RlLT5vcmlnaW4gPT0gUkVNT1RFX1JFTU9URVMpCgkJcGF0aCA9IGdpdF9wYXRoKCJyZW1vdGVzLyVzIiwgcmVtb3RlLT5uYW1lKTsKCWVsc2UgaWYgKHJlbW90ZS0+b3JpZ2luID09IFJFTU9URV9CUkFOQ0hFUykKCQlwYXRoID0gZ2l0X3BhdGgoImJyYW5jaGVzLyVzIiwgcmVtb3RlLT5uYW1lKTsKCWlmIChwYXRoKQoJCXVubGlua19vcl93YXJuKHBhdGgpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgbXYoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2KQp7CglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfRU5EKCkKCX07CglzdHJ1Y3QgcmVtb3RlICpvbGRyZW1vdGUsICpuZXdyZW1vdGU7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklULCBidWYyID0gU1RSQlVGX0lOSVQsIGJ1ZjMgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJpbmdfbGlzdCByZW1vdGVfYnJhbmNoZXMgPSB7IE5VTEwsIDAsIDAsIDAgfTsKCXN0cnVjdCByZW5hbWVfaW5mbyByZW5hbWU7CglpbnQgaTsKCglpZiAoYXJnYyAhPSAzKQoJCXVzYWdlX3dpdGhfb3B0aW9ucyhidWlsdGluX3JlbW90ZV91c2FnZSwgb3B0aW9ucyk7CgoJcmVuYW1lLm9sZCA9IGFyZ3ZbMV07CglyZW5hbWUubmV3ID0gYXJndlsyXTsKCXJlbmFtZS5yZW1vdGVfYnJhbmNoZXMgPSAmcmVtb3RlX2JyYW5jaGVzOwoKCW9sZHJlbW90ZSA9IHJlbW90ZV9nZXQocmVuYW1lLm9sZCk7CglpZiAoIW9sZHJlbW90ZSkKCQlkaWUoIk5vIHN1Y2ggcmVtb3RlOiAlcyIsIHJlbmFtZS5vbGQpOwoKCWlmICghc3RyY21wKHJlbmFtZS5vbGQsIHJlbmFtZS5uZXcpICYmIG9sZHJlbW90ZS0+b3JpZ2luICE9IFJFTU9URV9DT05GSUcpCgkJcmV0dXJuIG1pZ3JhdGVfZmlsZShvbGRyZW1vdGUpOwoKCW5ld3JlbW90ZSA9IHJlbW90ZV9nZXQocmVuYW1lLm5ldyk7CglpZiAobmV3cmVtb3RlICYmIChuZXdyZW1vdGUtPnVybF9uciA+IDEgfHwgbmV3cmVtb3RlLT5mZXRjaF9yZWZzcGVjX25yKSkKCQlkaWUoInJlbW90ZSAlcyBhbHJlYWR5IGV4aXN0cy4iLCByZW5hbWUubmV3KTsKCglzdHJidWZfYWRkZigmYnVmLCAicmVmcy9oZWFkcy90ZXN0OnJlZnMvcmVtb3Rlcy8lcy90ZXN0IiwgcmVuYW1lLm5ldyk7CglpZiAoIXZhbGlkX2ZldGNoX3JlZnNwZWMoYnVmLmJ1ZikpCgkJZGllKCInJXMnIGlzIG5vdCBhIHZhbGlkIHJlbW90ZSBuYW1lIiwgcmVuYW1lLm5ldyk7CgoJc3RyYnVmX3Jlc2V0KCZidWYpOwoJc3RyYnVmX2FkZGYoJmJ1ZiwgInJlbW90ZS4lcyIsIHJlbmFtZS5vbGQpOwoJc3RyYnVmX2FkZGYoJmJ1ZjIsICJyZW1vdGUuJXMiLCByZW5hbWUubmV3KTsKCWlmIChnaXRfY29uZmlnX3JlbmFtZV9zZWN0aW9uKGJ1Zi5idWYsIGJ1ZjIuYnVmKSA8IDEpCgkJcmV0dXJuIGVycm9yKCJDb3VsZCBub3QgcmVuYW1lIGNvbmZpZyBzZWN0aW9uICclcycgdG8gJyVzJyIsCgkJCQlidWYuYnVmLCBidWYyLmJ1Zik7CgoJc3RyYnVmX3Jlc2V0KCZidWYpOwoJc3RyYnVmX2FkZGYoJmJ1ZiwgInJlbW90ZS4lcy5mZXRjaCIsIHJlbmFtZS5uZXcpOwoJaWYgKGdpdF9jb25maWdfc2V0X211bHRpdmFyKGJ1Zi5idWYsIE5VTEwsIE5VTEwsIDEpKQoJCXJldHVybiBlcnJvcigiQ291bGQgbm90IHJlbW92ZSBjb25maWcgc2VjdGlvbiAnJXMnIiwgYnVmLmJ1Zik7Cglmb3IgKGkgPSAwOyBpIDwgb2xkcmVtb3RlLT5mZXRjaF9yZWZzcGVjX25yOyBpKyspIHsKCQljaGFyICpwdHI7CgoJCXN0cmJ1Zl9yZXNldCgmYnVmMik7CgkJc3RyYnVmX2FkZHN0cigmYnVmMiwgb2xkcmVtb3RlLT5mZXRjaF9yZWZzcGVjW2ldKTsKCQlwdHIgPSBzdHJzdHIoYnVmMi5idWYsIHJlbmFtZS5vbGQpOwoJCWlmIChwdHIpCgkJCXN0cmJ1Zl9zcGxpY2UoJmJ1ZjIsIHB0ci1idWYyLmJ1Ziwgc3RybGVuKHJlbmFtZS5vbGQpLAoJCQkJCXJlbmFtZS5uZXcsIHN0cmxlbihyZW5hbWUubmV3KSk7CgkJaWYgKGdpdF9jb25maWdfc2V0X211bHRpdmFyKGJ1Zi5idWYsIGJ1ZjIuYnVmLCAiXiQiLCAwKSkKCQkJcmV0dXJuIGVycm9yKCJDb3VsZCBub3QgYXBwZW5kICclcyciLCBidWYuYnVmKTsKCX0KCglyZWFkX2JyYW5jaGVzKCk7Cglmb3IgKGkgPSAwOyBpIDwgYnJhbmNoX2xpc3QubnI7IGkrKykgewoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtID0gYnJhbmNoX2xpc3QuaXRlbXMgKyBpOwoJCXN0cnVjdCBicmFuY2hfaW5mbyAqaW5mbyA9IGl0ZW0tPnV0aWw7CgkJaWYgKGluZm8tPnJlbW90ZV9uYW1lICYmICFzdHJjbXAoaW5mby0+cmVtb3RlX25hbWUsIHJlbmFtZS5vbGQpKSB7CgkJCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCQkJc3RyYnVmX2FkZGYoJmJ1ZiwgImJyYW5jaC4lcy5yZW1vdGUiLCBpdGVtLT5zdHJpbmcpOwoJCQlpZiAoZ2l0X2NvbmZpZ19zZXQoYnVmLmJ1ZiwgcmVuYW1lLm5ldykpIHsKCQkJCXJldHVybiBlcnJvcigiQ291bGQgbm90IHNldCAnJXMnIiwgYnVmLmJ1Zik7CgkJCX0KCQl9Cgl9CgoJLyoKCSAqIEZpcnN0IHJlbW92ZSBzeW1yZWZzLCB0aGVuIHJlbmFtZSB0aGUgcmVzdCwgZmluYWxseSBjcmVhdGUKCSAqIHRoZSBuZXcgc3ltcmVmcy4KCSAqLwoJZm9yX2VhY2hfcmVmKHJlYWRfcmVtb3RlX2JyYW5jaGVzLCAmcmVuYW1lKTsKCWZvciAoaSA9IDA7IGkgPCByZW1vdGVfYnJhbmNoZXMubnI7IGkrKykgewoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtID0gcmVtb3RlX2JyYW5jaGVzLml0ZW1zICsgaTsKCQlpbnQgZmxhZyA9IDA7CgkJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCgkJcmVzb2x2ZV9yZWYoaXRlbS0+c3RyaW5nLCBzaGExLCAxLCAmZmxhZyk7CgkJaWYgKCEoZmxhZyAmIFJFRl9JU1NZTVJFRikpCgkJCWNvbnRpbnVlOwoJCWlmIChkZWxldGVfcmVmKGl0ZW0tPnN0cmluZywgTlVMTCwgUkVGX05PREVSRUYpKQoJCQlkaWUoImRlbGV0aW5nICclcycgZmFpbGVkIiwgaXRlbS0+c3RyaW5nKTsKCX0KCWZvciAoaSA9IDA7IGkgPCByZW1vdGVfYnJhbmNoZXMubnI7IGkrKykgewoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtID0gcmVtb3RlX2JyYW5jaGVzLml0ZW1zICsgaTsKCgkJaWYgKGl0ZW0tPnV0aWwpCgkJCWNvbnRpbnVlOwoJCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCQlzdHJidWZfYWRkc3RyKCZidWYsIGl0ZW0tPnN0cmluZyk7CgkJc3RyYnVmX3NwbGljZSgmYnVmLCBzdHJsZW4oInJlZnMvcmVtb3Rlcy8iKSwgc3RybGVuKHJlbmFtZS5vbGQpLAoJCQkJcmVuYW1lLm5ldywgc3RybGVuKHJlbmFtZS5uZXcpKTsKCQlzdHJidWZfcmVzZXQoJmJ1ZjIpOwoJCXN0cmJ1Zl9hZGRmKCZidWYyLCAicmVtb3RlOiByZW5hbWVkICVzIHRvICVzIiwKCQkJCWl0ZW0tPnN0cmluZywgYnVmLmJ1Zik7CgkJaWYgKHJlbmFtZV9yZWYoaXRlbS0+c3RyaW5nLCBidWYuYnVmLCBidWYyLmJ1ZikpCgkJCWRpZSgicmVuYW1pbmcgJyVzJyBmYWlsZWQiLCBpdGVtLT5zdHJpbmcpOwoJfQoJZm9yIChpID0gMDsgaSA8IHJlbW90ZV9icmFuY2hlcy5ucjsgaSsrKSB7CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW0gPSByZW1vdGVfYnJhbmNoZXMuaXRlbXMgKyBpOwoKCQlpZiAoIWl0ZW0tPnV0aWwpCgkJCWNvbnRpbnVlOwoJCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCQlzdHJidWZfYWRkc3RyKCZidWYsIGl0ZW0tPnN0cmluZyk7CgkJc3RyYnVmX3NwbGljZSgmYnVmLCBzdHJsZW4oInJlZnMvcmVtb3Rlcy8iKSwgc3RybGVuKHJlbmFtZS5vbGQpLAoJCQkJcmVuYW1lLm5ldywgc3RybGVuKHJlbmFtZS5uZXcpKTsKCQlzdHJidWZfcmVzZXQoJmJ1ZjIpOwoJCXN0cmJ1Zl9hZGRzdHIoJmJ1ZjIsIGl0ZW0tPnV0aWwpOwoJCXN0cmJ1Zl9zcGxpY2UoJmJ1ZjIsIHN0cmxlbigicmVmcy9yZW1vdGVzLyIpLCBzdHJsZW4ocmVuYW1lLm9sZCksCgkJCQlyZW5hbWUubmV3LCBzdHJsZW4ocmVuYW1lLm5ldykpOwoJCXN0cmJ1Zl9yZXNldCgmYnVmMyk7CgkJc3RyYnVmX2FkZGYoJmJ1ZjMsICJyZW1vdGU6IHJlbmFtZWQgJXMgdG8gJXMiLAoJCQkJaXRlbS0+c3RyaW5nLCBidWYuYnVmKTsKCQlpZiAoY3JlYXRlX3N5bXJlZihidWYuYnVmLCBidWYyLmJ1ZiwgYnVmMy5idWYpKQoJCQlkaWUoImNyZWF0aW5nICclcycgZmFpbGVkIiwgYnVmLmJ1Zik7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCByZW1vdmVfYnJhbmNoZXMoc3RydWN0IHN0cmluZ19saXN0ICpicmFuY2hlcykKewoJaW50IGksIHJlc3VsdCA9IDA7Cglmb3IgKGkgPSAwOyBpIDwgYnJhbmNoZXMtPm5yOyBpKyspIHsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbSA9IGJyYW5jaGVzLT5pdGVtcyArIGk7CgkJY29uc3QgY2hhciAqcmVmbmFtZSA9IGl0ZW0tPnN0cmluZzsKCQl1bnNpZ25lZCBjaGFyICpzaGExID0gaXRlbS0+dXRpbDsKCgkJaWYgKGRlbGV0ZV9yZWYocmVmbmFtZSwgc2hhMSwgMCkpCgkJCXJlc3VsdCB8PSBlcnJvcigiQ291bGQgbm90IHJlbW92ZSBicmFuY2ggJXMiLCByZWZuYW1lKTsKCX0KCXJldHVybiByZXN1bHQ7Cn0KCnN0YXRpYyBpbnQgcm0oaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2KQp7CglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfRU5EKCkKCX07CglzdHJ1Y3QgcmVtb3RlICpyZW1vdGU7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJc3RydWN0IGtub3duX3JlbW90ZXMga25vd25fcmVtb3RlcyA9IHsgTlVMTCwgTlVMTCB9OwoJc3RydWN0IHN0cmluZ19saXN0IGJyYW5jaGVzID0geyBOVUxMLCAwLCAwLCAxIH07CglzdHJ1Y3Qgc3RyaW5nX2xpc3Qgc2tpcHBlZCA9IHsgTlVMTCwgMCwgMCwgMSB9OwoJc3RydWN0IGJyYW5jaGVzX2Zvcl9yZW1vdGUgY2JfZGF0YSA9IHsKCQlOVUxMLCAmYnJhbmNoZXMsICZza2lwcGVkLCAma25vd25fcmVtb3RlcwoJfTsKCWludCBpLCByZXN1bHQ7CgoJaWYgKGFyZ2MgIT0gMikKCQl1c2FnZV93aXRoX29wdGlvbnMoYnVpbHRpbl9yZW1vdGVfdXNhZ2UsIG9wdGlvbnMpOwoKCXJlbW90ZSA9IHJlbW90ZV9nZXQoYXJndlsxXSk7CglpZiAoIXJlbW90ZSkKCQlkaWUoIk5vIHN1Y2ggcmVtb3RlOiAlcyIsIGFyZ3ZbMV0pOwoKCWtub3duX3JlbW90ZXMudG9fZGVsZXRlID0gcmVtb3RlOwoJZm9yX2VhY2hfcmVtb3RlKGFkZF9rbm93bl9yZW1vdGUsICZrbm93bl9yZW1vdGVzKTsKCglzdHJidWZfYWRkZigmYnVmLCAicmVtb3RlLiVzIiwgcmVtb3RlLT5uYW1lKTsKCWlmIChnaXRfY29uZmlnX3JlbmFtZV9zZWN0aW9uKGJ1Zi5idWYsIE5VTEwpIDwgMSkKCQlyZXR1cm4gZXJyb3IoIkNvdWxkIG5vdCByZW1vdmUgY29uZmlnIHNlY3Rpb24gJyVzJyIsIGJ1Zi5idWYpOwoKCXJlYWRfYnJhbmNoZXMoKTsKCWZvciAoaSA9IDA7IGkgPCBicmFuY2hfbGlzdC5ucjsgaSsrKSB7CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW0gPSBicmFuY2hfbGlzdC5pdGVtcyArIGk7CgkJc3RydWN0IGJyYW5jaF9pbmZvICppbmZvID0gaXRlbS0+dXRpbDsKCQlpZiAoaW5mby0+cmVtb3RlX25hbWUgJiYgIXN0cmNtcChpbmZvLT5yZW1vdGVfbmFtZSwgcmVtb3RlLT5uYW1lKSkgewoJCQljb25zdCBjaGFyICprZXlzW10gPSB7ICJyZW1vdGUiLCAibWVyZ2UiLCBOVUxMIH0sICoqazsKCQkJZm9yIChrID0ga2V5czsgKms7IGsrKykgewoJCQkJc3RyYnVmX3Jlc2V0KCZidWYpOwoJCQkJc3RyYnVmX2FkZGYoJmJ1ZiwgImJyYW5jaC4lcy4lcyIsCgkJCQkJCWl0ZW0tPnN0cmluZywgKmspOwoJCQkJaWYgKGdpdF9jb25maWdfc2V0KGJ1Zi5idWYsIE5VTEwpKSB7CgkJCQkJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CgkJCQkJcmV0dXJuIC0xOwoJCQkJfQoJCQl9CgkJfQoJfQoKCS8qCgkgKiBXZSBjYW5ub3QganVzdCBwYXNzIGEgZnVuY3Rpb24gdG8gZm9yX2VhY2hfcmVmKCkgd2hpY2ggZGVsZXRlcwoJICogdGhlIGJyYW5jaGVzIG9uZSBieSBvbmUsIHNpbmNlIGZvcl9lYWNoX3JlZigpIHJlbGllcyBvbiBjYWNoZWQKCSAqIHJlZnMsIHdoaWNoIGFyZSBpbnZhbGlkYXRlZCB3aGVuIGRlbGV0aW5nIGEgYnJhbmNoLgoJICovCgljYl9kYXRhLnJlbW90ZSA9IHJlbW90ZTsKCXJlc3VsdCA9IGZvcl9lYWNoX3JlZihhZGRfYnJhbmNoX2Zvcl9yZW1vdmFsLCAmY2JfZGF0YSk7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCglpZiAoIXJlc3VsdCkKCQlyZXN1bHQgPSByZW1vdmVfYnJhbmNoZXMoJmJyYW5jaGVzKTsKCXN0cmluZ19saXN0X2NsZWFyKCZicmFuY2hlcywgMSk7CgoJaWYgKHNraXBwZWQubnIpIHsKCQlmcHJpbnRmKHN0ZGVyciwgc2tpcHBlZC5uciA9PSAxID8KCQkJIk5vdGU6IEEgbm9uLXJlbW90ZSBicmFuY2ggd2FzIG5vdCByZW1vdmVkOyAiCgkJCSJ0byBkZWxldGUgaXQsIHVzZTpcbiIgOgoJCQkiTm90ZTogTm9uLXJlbW90ZSBicmFuY2hlcyB3ZXJlIG5vdCByZW1vdmVkOyAiCgkJCSJ0byBkZWxldGUgdGhlbSwgdXNlOlxuIik7CgkJZm9yIChpID0gMDsgaSA8IHNraXBwZWQubnI7IGkrKykKCQkJZnByaW50ZihzdGRlcnIsICIgIGdpdCBicmFuY2ggLWQgJXNcbiIsCgkJCQlza2lwcGVkLml0ZW1zW2ldLnN0cmluZyk7Cgl9CglzdHJpbmdfbGlzdF9jbGVhcigmc2tpcHBlZCwgMCk7CgoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIHZvaWQgY2xlYXJfcHVzaF9pbmZvKHZvaWQgKnV0aWwsIGNvbnN0IGNoYXIgKnN0cmluZykKewoJc3RydWN0IHB1c2hfaW5mbyAqaW5mbyA9IHV0aWw7CglmcmVlKGluZm8tPmRlc3QpOwoJZnJlZShpbmZvKTsKfQoKc3RhdGljIHZvaWQgZnJlZV9yZW1vdGVfcmVmX3N0YXRlcyhzdHJ1Y3QgcmVmX3N0YXRlcyAqc3RhdGVzKQp7CglzdHJpbmdfbGlzdF9jbGVhcigmc3RhdGVzLT5uZXcsIDApOwoJc3RyaW5nX2xpc3RfY2xlYXIoJnN0YXRlcy0+c3RhbGUsIDApOwoJc3RyaW5nX2xpc3RfY2xlYXIoJnN0YXRlcy0+dHJhY2tlZCwgMCk7CglzdHJpbmdfbGlzdF9jbGVhcigmc3RhdGVzLT5oZWFkcywgMCk7CglzdHJpbmdfbGlzdF9jbGVhcl9mdW5jKCZzdGF0ZXMtPnB1c2gsIGNsZWFyX3B1c2hfaW5mbyk7Cn0KCnN0YXRpYyBpbnQgYXBwZW5kX3JlZl90b190cmFja2VkX2xpc3QoY29uc3QgY2hhciAqcmVmbmFtZSwKCWNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIGludCBmbGFncywgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IHJlZl9zdGF0ZXMgKnN0YXRlcyA9IGNiX2RhdGE7CglzdHJ1Y3QgcmVmc3BlYyByZWZzcGVjOwoKCWlmIChmbGFncyAmIFJFRl9JU1NZTVJFRikKCQlyZXR1cm4gMDsKCgltZW1zZXQoJnJlZnNwZWMsIDAsIHNpemVvZihyZWZzcGVjKSk7CglyZWZzcGVjLmRzdCA9IChjaGFyICopcmVmbmFtZTsKCWlmICghcmVtb3RlX2ZpbmRfdHJhY2tpbmcoc3RhdGVzLT5yZW1vdGUsICZyZWZzcGVjKSkKCQlzdHJpbmdfbGlzdF9hcHBlbmQoYWJicmV2X2JyYW5jaChyZWZzcGVjLnNyYyksICZzdGF0ZXMtPnRyYWNrZWQpOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdldF9yZW1vdGVfcmVmX3N0YXRlcyhjb25zdCBjaGFyICpuYW1lLAoJCQkJIHN0cnVjdCByZWZfc3RhdGVzICpzdGF0ZXMsCgkJCQkgaW50IHF1ZXJ5KQp7CglzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQ7Cgljb25zdCBzdHJ1Y3QgcmVmICpyZW1vdGVfcmVmczsKCglzdGF0ZXMtPnJlbW90ZSA9IHJlbW90ZV9nZXQobmFtZSk7CglpZiAoIXN0YXRlcy0+cmVtb3RlKQoJCXJldHVybiBlcnJvcigiTm8gc3VjaCByZW1vdGU6ICVzIiwgbmFtZSk7CgoJcmVhZF9icmFuY2hlcygpOwoKCWlmIChxdWVyeSkgewoJCXRyYW5zcG9ydCA9IHRyYW5zcG9ydF9nZXQoc3RhdGVzLT5yZW1vdGUsIHN0YXRlcy0+cmVtb3RlLT51cmxfbnIgPiAwID8KCQkJc3RhdGVzLT5yZW1vdGUtPnVybFswXSA6IE5VTEwpOwoJCXJlbW90ZV9yZWZzID0gdHJhbnNwb3J0X2dldF9yZW1vdGVfcmVmcyh0cmFuc3BvcnQpOwoJCXRyYW5zcG9ydF9kaXNjb25uZWN0KHRyYW5zcG9ydCk7CgoJCXN0YXRlcy0+cXVlcmllZCA9IDE7CgkJaWYgKHF1ZXJ5ICYgR0VUX1JFRl9TVEFURVMpCgkJCWdldF9yZWZfc3RhdGVzKHJlbW90ZV9yZWZzLCBzdGF0ZXMpOwoJCWlmIChxdWVyeSAmIEdFVF9IRUFEX05BTUVTKQoJCQlnZXRfaGVhZF9uYW1lcyhyZW1vdGVfcmVmcywgc3RhdGVzKTsKCQlpZiAocXVlcnkgJiBHRVRfUFVTSF9SRUZfU1RBVEVTKQoJCQlnZXRfcHVzaF9yZWZfc3RhdGVzKHJlbW90ZV9yZWZzLCBzdGF0ZXMpOwoJfSBlbHNlIHsKCQlmb3JfZWFjaF9yZWYoYXBwZW5kX3JlZl90b190cmFja2VkX2xpc3QsIHN0YXRlcyk7CgkJc29ydF9zdHJpbmdfbGlzdCgmc3RhdGVzLT50cmFja2VkKTsKCQlnZXRfcHVzaF9yZWZfc3RhdGVzX25vcXVlcnkoc3RhdGVzKTsKCX0KCglyZXR1cm4gMDsKfQoKc3RydWN0IHNob3dfaW5mbyB7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3Q7CglzdHJ1Y3QgcmVmX3N0YXRlcyAqc3RhdGVzOwoJaW50IHdpZHRoLCB3aWR0aDI7CglpbnQgYW55X3JlYmFzZTsKfTsKCnN0YXRpYyBpbnQgYWRkX3JlbW90ZV90b19zaG93X2luZm8oc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW0sIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBzaG93X2luZm8gKmluZm8gPSBjYl9kYXRhOwoJaW50IG4gPSBzdHJsZW4oaXRlbS0+c3RyaW5nKTsKCWlmIChuID4gaW5mby0+d2lkdGgpCgkJaW5mby0+d2lkdGggPSBuOwoJc3RyaW5nX2xpc3RfaW5zZXJ0KGl0ZW0tPnN0cmluZywgaW5mby0+bGlzdCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBzaG93X3JlbW90ZV9pbmZvX2l0ZW0oc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW0sIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBzaG93X2luZm8gKmluZm8gPSBjYl9kYXRhOwoJc3RydWN0IHJlZl9zdGF0ZXMgKnN0YXRlcyA9IGluZm8tPnN0YXRlczsKCWNvbnN0IGNoYXIgKm5hbWUgPSBpdGVtLT5zdHJpbmc7CgoJaWYgKHN0YXRlcy0+cXVlcmllZCkgewoJCWNvbnN0IGNoYXIgKmZtdCA9ICIlcyI7CgkJY29uc3QgY2hhciAqYXJnID0gIiI7CgkJaWYgKHN0cmluZ19saXN0X2hhc19zdHJpbmcoJnN0YXRlcy0+bmV3LCBuYW1lKSkgewoJCQlmbXQgPSAiIG5ldyAobmV4dCBmZXRjaCB3aWxsIHN0b3JlIGluIHJlbW90ZXMvJXMpIjsKCQkJYXJnID0gc3RhdGVzLT5yZW1vdGUtPm5hbWU7CgkJfSBlbHNlIGlmIChzdHJpbmdfbGlzdF9oYXNfc3RyaW5nKCZzdGF0ZXMtPnRyYWNrZWQsIG5hbWUpKQoJCQlhcmcgPSAiIHRyYWNrZWQiOwoJCWVsc2UgaWYgKHN0cmluZ19saXN0X2hhc19zdHJpbmcoJnN0YXRlcy0+c3RhbGUsIG5hbWUpKQoJCQlhcmcgPSAiIHN0YWxlICh1c2UgJ2dpdCByZW1vdGUgcHJ1bmUnIHRvIHJlbW92ZSkiOwoJCWVsc2UKCQkJYXJnID0gIiA/Pz8iOwoJCXByaW50ZigiICAgICUtKnMiLCBpbmZvLT53aWR0aCwgbmFtZSk7CgkJcHJpbnRmKGZtdCwgYXJnKTsKCQlwcmludGYoIlxuIik7Cgl9IGVsc2UKCQlwcmludGYoIiAgICAlc1xuIiwgbmFtZSk7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgYWRkX2xvY2FsX3RvX3Nob3dfaW5mbyhzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqYnJhbmNoX2l0ZW0sIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBzaG93X2luZm8gKnNob3dfaW5mbyA9IGNiX2RhdGE7CglzdHJ1Y3QgcmVmX3N0YXRlcyAqc3RhdGVzID0gc2hvd19pbmZvLT5zdGF0ZXM7CglzdHJ1Y3QgYnJhbmNoX2luZm8gKmJyYW5jaF9pbmZvID0gYnJhbmNoX2l0ZW0tPnV0aWw7CglzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbTsKCWludCBuOwoKCWlmICghYnJhbmNoX2luZm8tPm1lcmdlLm5yIHx8ICFicmFuY2hfaW5mby0+cmVtb3RlX25hbWUgfHwKCSAgICBzdHJjbXAoc3RhdGVzLT5yZW1vdGUtPm5hbWUsIGJyYW5jaF9pbmZvLT5yZW1vdGVfbmFtZSkpCgkJcmV0dXJuIDA7CglpZiAoKG4gPSBzdHJsZW4oYnJhbmNoX2l0ZW0tPnN0cmluZykpID4gc2hvd19pbmZvLT53aWR0aCkKCQlzaG93X2luZm8tPndpZHRoID0gbjsKCWlmIChicmFuY2hfaW5mby0+cmViYXNlKQoJCXNob3dfaW5mby0+YW55X3JlYmFzZSA9IDE7CgoJaXRlbSA9IHN0cmluZ19saXN0X2luc2VydChicmFuY2hfaXRlbS0+c3RyaW5nLCBzaG93X2luZm8tPmxpc3QpOwoJaXRlbS0+dXRpbCA9IGJyYW5jaF9pbmZvOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHNob3dfbG9jYWxfaW5mb19pdGVtKHN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3Qgc2hvd19pbmZvICpzaG93X2luZm8gPSBjYl9kYXRhOwoJc3RydWN0IGJyYW5jaF9pbmZvICpicmFuY2hfaW5mbyA9IGl0ZW0tPnV0aWw7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgKm1lcmdlID0gJmJyYW5jaF9pbmZvLT5tZXJnZTsKCWNvbnN0IGNoYXIgKmFsc287CglpbnQgaTsKCglpZiAoYnJhbmNoX2luZm8tPnJlYmFzZSAmJiBicmFuY2hfaW5mby0+bWVyZ2UubnIgPiAxKSB7CgkJZXJyb3IoImludmFsaWQgYnJhbmNoLiVzLm1lcmdlOyBjYW5ub3QgcmViYXNlIG9udG8gPiAxIGJyYW5jaCIsCgkJCWl0ZW0tPnN0cmluZyk7CgkJcmV0dXJuIDA7Cgl9CgoJcHJpbnRmKCIgICAgJS0qcyAiLCBzaG93X2luZm8tPndpZHRoLCBpdGVtLT5zdHJpbmcpOwoJaWYgKGJyYW5jaF9pbmZvLT5yZWJhc2UpIHsKCQlwcmludGYoInJlYmFzZXMgb250byByZW1vdGUgJXNcbiIsIG1lcmdlLT5pdGVtc1swXS5zdHJpbmcpOwoJCXJldHVybiAwOwoJfSBlbHNlIGlmIChzaG93X2luZm8tPmFueV9yZWJhc2UpIHsKCQlwcmludGYoIiBtZXJnZXMgd2l0aCByZW1vdGUgJXNcbiIsIG1lcmdlLT5pdGVtc1swXS5zdHJpbmcpOwoJCWFsc28gPSAiICAgIGFuZCB3aXRoIHJlbW90ZSI7Cgl9IGVsc2UgewoJCXByaW50ZigibWVyZ2VzIHdpdGggcmVtb3RlICVzXG4iLCBtZXJnZS0+aXRlbXNbMF0uc3RyaW5nKTsKCQlhbHNvID0gIiAgIGFuZCB3aXRoIHJlbW90ZSI7Cgl9Cglmb3IgKGkgPSAxOyBpIDwgbWVyZ2UtPm5yOyBpKyspCgkJcHJpbnRmKCIgICAgJS0qcyAlcyAlc1xuIiwgc2hvd19pbmZvLT53aWR0aCwgIiIsIGFsc28sCgkJICAgICAgIG1lcmdlLT5pdGVtc1tpXS5zdHJpbmcpOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGFkZF9wdXNoX3RvX3Nob3dfaW5mbyhzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqcHVzaF9pdGVtLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3Qgc2hvd19pbmZvICpzaG93X2luZm8gPSBjYl9kYXRhOwoJc3RydWN0IHB1c2hfaW5mbyAqcHVzaF9pbmZvID0gcHVzaF9pdGVtLT51dGlsOwoJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW07CglpbnQgbjsKCWlmICgobiA9IHN0cmxlbihwdXNoX2l0ZW0tPnN0cmluZykpID4gc2hvd19pbmZvLT53aWR0aCkKCQlzaG93X2luZm8tPndpZHRoID0gbjsKCWlmICgobiA9IHN0cmxlbihwdXNoX2luZm8tPmRlc3QpKSA+IHNob3dfaW5mby0+d2lkdGgyKQoJCXNob3dfaW5mby0+d2lkdGgyID0gbjsKCWl0ZW0gPSBzdHJpbmdfbGlzdF9hcHBlbmQocHVzaF9pdGVtLT5zdHJpbmcsIHNob3dfaW5mby0+bGlzdCk7CglpdGVtLT51dGlsID0gcHVzaF9pdGVtLT51dGlsOwoJcmV0dXJuIDA7Cn0KCi8qCiAqIFNvcnRpbmcgY29tcGFyaXNvbiBmb3IgYSBzdHJpbmcgbGlzdCB0aGF0IGhhcyBwdXNoX2luZm8KICogc3RydWN0cyBpbiBpdHMgdXRpbCBmaWVsZAogKi8Kc3RhdGljIGludCBjbXBfc3RyaW5nX3dpdGhfcHVzaChjb25zdCB2b2lkICp2YSwgY29uc3Qgdm9pZCAqdmIpCnsKCWNvbnN0IHN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICphID0gdmE7Cgljb25zdCBzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqYiA9IHZiOwoJY29uc3Qgc3RydWN0IHB1c2hfaW5mbyAqYV9wdXNoID0gYS0+dXRpbDsKCWNvbnN0IHN0cnVjdCBwdXNoX2luZm8gKmJfcHVzaCA9IGItPnV0aWw7CglpbnQgY21wID0gc3RyY21wKGEtPnN0cmluZywgYi0+c3RyaW5nKTsKCXJldHVybiBjbXAgPyBjbXAgOiBzdHJjbXAoYV9wdXNoLT5kZXN0LCBiX3B1c2gtPmRlc3QpOwp9CgpzdGF0aWMgaW50IHNob3dfcHVzaF9pbmZvX2l0ZW0oc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW0sIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBzaG93X2luZm8gKnNob3dfaW5mbyA9IGNiX2RhdGE7CglzdHJ1Y3QgcHVzaF9pbmZvICpwdXNoX2luZm8gPSBpdGVtLT51dGlsOwoJY2hhciAqc3JjID0gaXRlbS0+c3RyaW5nLCAqc3RhdHVzID0gTlVMTDsKCglzd2l0Y2ggKHB1c2hfaW5mby0+c3RhdHVzKSB7CgljYXNlIFBVU0hfU1RBVFVTX0NSRUFURToKCQlzdGF0dXMgPSAiY3JlYXRlIjsKCQlicmVhazsKCWNhc2UgUFVTSF9TVEFUVVNfREVMRVRFOgoJCXN0YXR1cyA9ICJkZWxldGUiOwoJCXNyYyA9ICIobm9uZSkiOwoJCWJyZWFrOwoJY2FzZSBQVVNIX1NUQVRVU19VUFRPREFURToKCQlzdGF0dXMgPSAidXAgdG8gZGF0ZSI7CgkJYnJlYWs7CgljYXNlIFBVU0hfU1RBVFVTX0ZBU1RGT1JXQVJEOgoJCXN0YXR1cyA9ICJmYXN0IGZvcndhcmRhYmxlIjsKCQlicmVhazsKCWNhc2UgUFVTSF9TVEFUVVNfT1VUT0ZEQVRFOgoJCXN0YXR1cyA9ICJsb2NhbCBvdXQgb2YgZGF0ZSI7CgkJYnJlYWs7CgljYXNlIFBVU0hfU1RBVFVTX05PVFFVRVJJRUQ6CgkJYnJlYWs7Cgl9CglpZiAoc3RhdHVzKQoJCXByaW50ZigiICAgICUtKnMgJXMgdG8gJS0qcyAoJXMpXG4iLCBzaG93X2luZm8tPndpZHRoLCBzcmMsCgkJCXB1c2hfaW5mby0+Zm9yY2VkID8gImZvcmNlcyIgOiAicHVzaGVzIiwKCQkJc2hvd19pbmZvLT53aWR0aDIsIHB1c2hfaW5mby0+ZGVzdCwgc3RhdHVzKTsKCWVsc2UKCQlwcmludGYoIiAgICAlLSpzICVzIHRvICVzXG4iLCBzaG93X2luZm8tPndpZHRoLCBzcmMsCgkJCXB1c2hfaW5mby0+Zm9yY2VkID8gImZvcmNlcyIgOiAicHVzaGVzIiwKCQkJcHVzaF9pbmZvLT5kZXN0KTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHNob3coaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2KQp7CglpbnQgbm9fcXVlcnkgPSAwLCByZXN1bHQgPSAwLCBxdWVyeV9mbGFnID0gMDsKCXN0cnVjdCBvcHRpb24gb3B0aW9uc1tdID0gewoJCU9QVF9HUk9VUCgic2hvdyBzcGVjaWZpYyBvcHRpb25zIiksCgkJT1BUX0JPT0xFQU4oJ24nLCBOVUxMLCAmbm9fcXVlcnksICJkbyBub3QgcXVlcnkgcmVtb3RlcyIpLAoJCU9QVF9FTkQoKQoJfTsKCXN0cnVjdCByZWZfc3RhdGVzIHN0YXRlczsKCXN0cnVjdCBzdHJpbmdfbGlzdCBpbmZvX2xpc3QgPSB7IE5VTEwsIDAsIDAsIDAgfTsKCXN0cnVjdCBzaG93X2luZm8gaW5mbzsKCglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBOVUxMLCBvcHRpb25zLCBidWlsdGluX3JlbW90ZV91c2FnZSwKCQkJICAgICAwKTsKCglpZiAoYXJnYyA8IDEpCgkJcmV0dXJuIHNob3dfYWxsKCk7CgoJaWYgKCFub19xdWVyeSkKCQlxdWVyeV9mbGFnID0gKEdFVF9SRUZfU1RBVEVTIHwgR0VUX0hFQURfTkFNRVMgfCBHRVRfUFVTSF9SRUZfU1RBVEVTKTsKCgltZW1zZXQoJnN0YXRlcywgMCwgc2l6ZW9mKHN0YXRlcykpOwoJbWVtc2V0KCZpbmZvLCAwLCBzaXplb2YoaW5mbykpOwoJaW5mby5zdGF0ZXMgPSAmc3RhdGVzOwoJaW5mby5saXN0ID0gJmluZm9fbGlzdDsKCWZvciAoOyBhcmdjOyBhcmdjLS0sIGFyZ3YrKykgewoJCWludCBpOwoJCWNvbnN0IGNoYXIgKip1cmw7CgkJaW50IHVybF9ucjsKCgkJZ2V0X3JlbW90ZV9yZWZfc3RhdGVzKCphcmd2LCAmc3RhdGVzLCBxdWVyeV9mbGFnKTsKCgkJcHJpbnRmKCIqIHJlbW90ZSAlc1xuIiwgKmFyZ3YpOwoJCXByaW50ZigiICBGZXRjaCBVUkw6ICVzXG4iLCBzdGF0ZXMucmVtb3RlLT51cmxfbnIgPiAwID8KCQkJc3RhdGVzLnJlbW90ZS0+dXJsWzBdIDogIihubyBVUkwpIik7CgkJaWYgKHN0YXRlcy5yZW1vdGUtPnB1c2h1cmxfbnIpIHsKCQkJdXJsID0gc3RhdGVzLnJlbW90ZS0+cHVzaHVybDsKCQkJdXJsX25yID0gc3RhdGVzLnJlbW90ZS0+cHVzaHVybF9ucjsKCQl9IGVsc2UgewoJCQl1cmwgPSBzdGF0ZXMucmVtb3RlLT51cmw7CgkJCXVybF9uciA9IHN0YXRlcy5yZW1vdGUtPnVybF9ucjsKCQl9CgkJZm9yIChpPTA7IGkgPCB1cmxfbnI7IGkrKykKCQkJcHJpbnRmKCIgIFB1c2ggIFVSTDogJXNcbiIsIHVybFtpXSk7CgkJaWYgKCFpKQoJCQlwcmludGYoIiAgUHVzaCAgVVJMOiAlc1xuIiwgIihubyBVUkwpIik7CgkJaWYgKG5vX3F1ZXJ5KQoJCQlwcmludGYoIiAgSEVBRCBicmFuY2g6IChub3QgcXVlcmllZClcbiIpOwoJCWVsc2UgaWYgKCFzdGF0ZXMuaGVhZHMubnIpCgkJCXByaW50ZigiICBIRUFEIGJyYW5jaDogKHVua25vd24pXG4iKTsKCQllbHNlIGlmIChzdGF0ZXMuaGVhZHMubnIgPT0gMSkKCQkJcHJpbnRmKCIgIEhFQUQgYnJhbmNoOiAlc1xuIiwgc3RhdGVzLmhlYWRzLml0ZW1zWzBdLnN0cmluZyk7CgkJZWxzZSB7CgkJCXByaW50ZigiICBIRUFEIGJyYW5jaCAocmVtb3RlIEhFQUQgaXMgYW1iaWd1b3VzLCIKCQkJICAgICAgICIgbWF5IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nKTpcbiIpOwoJCQlmb3IgKGkgPSAwOyBpIDwgc3RhdGVzLmhlYWRzLm5yOyBpKyspCgkJCQlwcmludGYoIiAgICAlc1xuIiwgc3RhdGVzLmhlYWRzLml0ZW1zW2ldLnN0cmluZyk7CgkJfQoKCQkvKiByZW1vdGUgYnJhbmNoIGluZm8gKi8KCQlpbmZvLndpZHRoID0gMDsKCQlmb3JfZWFjaF9zdHJpbmdfbGlzdChhZGRfcmVtb3RlX3RvX3Nob3dfaW5mbywgJnN0YXRlcy5uZXcsICZpbmZvKTsKCQlmb3JfZWFjaF9zdHJpbmdfbGlzdChhZGRfcmVtb3RlX3RvX3Nob3dfaW5mbywgJnN0YXRlcy50cmFja2VkLCAmaW5mbyk7CgkJZm9yX2VhY2hfc3RyaW5nX2xpc3QoYWRkX3JlbW90ZV90b19zaG93X2luZm8sICZzdGF0ZXMuc3RhbGUsICZpbmZvKTsKCQlpZiAoaW5mby5saXN0LT5ucikKCQkJcHJpbnRmKCIgIFJlbW90ZSBicmFuY2glczolc1xuIiwKCQkJICAgICAgIGluZm8ubGlzdC0+bnIgPiAxID8gImVzIiA6ICIiLAoJCQkJbm9fcXVlcnkgPyAiIChzdGF0dXMgbm90IHF1ZXJpZWQpIiA6ICIiKTsKCQlmb3JfZWFjaF9zdHJpbmdfbGlzdChzaG93X3JlbW90ZV9pbmZvX2l0ZW0sIGluZm8ubGlzdCwgJmluZm8pOwoJCXN0cmluZ19saXN0X2NsZWFyKGluZm8ubGlzdCwgMCk7CgoJCS8qIGdpdCBwdWxsIGluZm8gKi8KCQlpbmZvLndpZHRoID0gMDsKCQlpbmZvLmFueV9yZWJhc2UgPSAwOwoJCWZvcl9lYWNoX3N0cmluZ19saXN0KGFkZF9sb2NhbF90b19zaG93X2luZm8sICZicmFuY2hfbGlzdCwgJmluZm8pOwoJCWlmIChpbmZvLmxpc3QtPm5yKQoJCQlwcmludGYoIiAgTG9jYWwgYnJhbmNoJXMgY29uZmlndXJlZCBmb3IgJ2dpdCBwdWxsJzpcbiIsCgkJCSAgICAgICBpbmZvLmxpc3QtPm5yID4gMSA/ICJlcyIgOiAiIik7CgkJZm9yX2VhY2hfc3RyaW5nX2xpc3Qoc2hvd19sb2NhbF9pbmZvX2l0ZW0sIGluZm8ubGlzdCwgJmluZm8pOwoJCXN0cmluZ19saXN0X2NsZWFyKGluZm8ubGlzdCwgMCk7CgoJCS8qIGdpdCBwdXNoIGluZm8gKi8KCQlpZiAoc3RhdGVzLnJlbW90ZS0+bWlycm9yKQoJCQlwcmludGYoIiAgTG9jYWwgcmVmcyB3aWxsIGJlIG1pcnJvcmVkIGJ5ICdnaXQgcHVzaCdcbiIpOwoKCQlpbmZvLndpZHRoID0gaW5mby53aWR0aDIgPSAwOwoJCWZvcl9lYWNoX3N0cmluZ19saXN0KGFkZF9wdXNoX3RvX3Nob3dfaW5mbywgJnN0YXRlcy5wdXNoLCAmaW5mbyk7CgkJcXNvcnQoaW5mby5saXN0LT5pdGVtcywgaW5mby5saXN0LT5uciwKCQkJc2l6ZW9mKCppbmZvLmxpc3QtPml0ZW1zKSwgY21wX3N0cmluZ193aXRoX3B1c2gpOwoJCWlmIChpbmZvLmxpc3QtPm5yKQoJCQlwcmludGYoIiAgTG9jYWwgcmVmJXMgY29uZmlndXJlZCBmb3IgJ2dpdCBwdXNoJyVzOlxuIiwKCQkJCWluZm8ubGlzdC0+bnIgPiAxID8gInMiIDogIiIsCgkJCQlub19xdWVyeSA/ICIgKHN0YXR1cyBub3QgcXVlcmllZCkiIDogIiIpOwoJCWZvcl9lYWNoX3N0cmluZ19saXN0KHNob3dfcHVzaF9pbmZvX2l0ZW0sIGluZm8ubGlzdCwgJmluZm8pOwoJCXN0cmluZ19saXN0X2NsZWFyKGluZm8ubGlzdCwgMCk7CgoJCWZyZWVfcmVtb3RlX3JlZl9zdGF0ZXMoJnN0YXRlcyk7Cgl9CgoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIGludCBzZXRfaGVhZChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YpCnsKCWludCBpLCBvcHRfYSA9IDAsIG9wdF9kID0gMCwgcmVzdWx0ID0gMDsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQsIGJ1ZjIgPSBTVFJCVUZfSU5JVDsKCWNoYXIgKmhlYWRfbmFtZSA9IE5VTEw7CgoJc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJT1BUX0dST1VQKCJzZXQtaGVhZCBzcGVjaWZpYyBvcHRpb25zIiksCgkJT1BUX0JPT0xFQU4oJ2EnLCAiYXV0byIsICZvcHRfYSwKCQkJICAgICJzZXQgcmVmcy9yZW1vdGVzLzxuYW1lPi9IRUFEIGFjY29yZGluZyB0byByZW1vdGUiKSwKCQlPUFRfQk9PTEVBTignZCcsICJkZWxldGUiLCAmb3B0X2QsCgkJCSAgICAiZGVsZXRlIHJlZnMvcmVtb3Rlcy88bmFtZT4vSEVBRCIpLAoJCU9QVF9FTkQoKQoJfTsKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIE5VTEwsIG9wdGlvbnMsIGJ1aWx0aW5fcmVtb3RlX3VzYWdlLAoJCQkgICAgIDApOwoJaWYgKGFyZ2MpCgkJc3RyYnVmX2FkZGYoJmJ1ZiwgInJlZnMvcmVtb3Rlcy8lcy9IRUFEIiwgYXJndlswXSk7CgoJaWYgKCFvcHRfYSAmJiAhb3B0X2QgJiYgYXJnYyA9PSAyKSB7CgkJaGVhZF9uYW1lID0geHN0cmR1cChhcmd2WzFdKTsKCX0gZWxzZSBpZiAob3B0X2EgJiYgIW9wdF9kICYmIGFyZ2MgPT0gMSkgewoJCXN0cnVjdCByZWZfc3RhdGVzIHN0YXRlczsKCQltZW1zZXQoJnN0YXRlcywgMCwgc2l6ZW9mKHN0YXRlcykpOwoJCWdldF9yZW1vdGVfcmVmX3N0YXRlcyhhcmd2WzBdLCAmc3RhdGVzLCBHRVRfSEVBRF9OQU1FUyk7CgkJaWYgKCFzdGF0ZXMuaGVhZHMubnIpCgkJCXJlc3VsdCB8PSBlcnJvcigiQ2Fubm90IGRldGVybWluZSByZW1vdGUgSEVBRCIpOwoJCWVsc2UgaWYgKHN0YXRlcy5oZWFkcy5uciA+IDEpIHsKCQkJcmVzdWx0IHw9IGVycm9yKCJNdWx0aXBsZSByZW1vdGUgSEVBRCBicmFuY2hlcy4gIgoJCQkJCSJQbGVhc2UgY2hvb3NlIG9uZSBleHBsaWNpdGx5IHdpdGg6Iik7CgkJCWZvciAoaSA9IDA7IGkgPCBzdGF0ZXMuaGVhZHMubnI7IGkrKykKCQkJCWZwcmludGYoc3RkZXJyLCAiICBnaXQgcmVtb3RlIHNldC1oZWFkICVzICVzXG4iLAoJCQkJCWFyZ3ZbMF0sIHN0YXRlcy5oZWFkcy5pdGVtc1tpXS5zdHJpbmcpOwoJCX0gZWxzZQoJCQloZWFkX25hbWUgPSB4c3RyZHVwKHN0YXRlcy5oZWFkcy5pdGVtc1swXS5zdHJpbmcpOwoJCWZyZWVfcmVtb3RlX3JlZl9zdGF0ZXMoJnN0YXRlcyk7Cgl9IGVsc2UgaWYgKG9wdF9kICYmICFvcHRfYSAmJiBhcmdjID09IDEpIHsKCQlpZiAoZGVsZXRlX3JlZihidWYuYnVmLCBOVUxMLCBSRUZfTk9ERVJFRikpCgkJCXJlc3VsdCB8PSBlcnJvcigiQ291bGQgbm90IGRlbGV0ZSAlcyIsIGJ1Zi5idWYpOwoJfSBlbHNlCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGJ1aWx0aW5fcmVtb3RlX3VzYWdlLCBvcHRpb25zKTsKCglpZiAoaGVhZF9uYW1lKSB7CgkJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCQlzdHJidWZfYWRkZigmYnVmMiwgInJlZnMvcmVtb3Rlcy8lcy8lcyIsIGFyZ3ZbMF0sIGhlYWRfbmFtZSk7CgkJLyogbWFrZSBzdXJlIGl0J3MgdmFsaWQgKi8KCQlpZiAoIXJlc29sdmVfcmVmKGJ1ZjIuYnVmLCBzaGExLCAxLCBOVUxMKSkKCQkJcmVzdWx0IHw9IGVycm9yKCJOb3QgYSB2YWxpZCByZWY6ICVzIiwgYnVmMi5idWYpOwoJCWVsc2UgaWYgKGNyZWF0ZV9zeW1yZWYoYnVmLmJ1ZiwgYnVmMi5idWYsICJyZW1vdGUgc2V0LWhlYWQiKSkKCQkJcmVzdWx0IHw9IGVycm9yKCJDb3VsZCBub3Qgc2V0dXAgJXMiLCBidWYuYnVmKTsKCQlpZiAob3B0X2EpCgkJCXByaW50ZigiJXMvSEVBRCBzZXQgdG8gJXNcbiIsIGFyZ3ZbMF0sIGhlYWRfbmFtZSk7CgkJZnJlZShoZWFkX25hbWUpOwoJfQoKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1ZjIpOwoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIGludCBwcnVuZShpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YpCnsKCWludCBkcnlfcnVuID0gMCwgcmVzdWx0ID0gMDsKCXN0cnVjdCBvcHRpb24gb3B0aW9uc1tdID0gewoJCU9QVF9HUk9VUCgicHJ1bmUgc3BlY2lmaWMgb3B0aW9ucyIpLAoJCU9QVF9fRFJZX1JVTigmZHJ5X3J1biksCgkJT1BUX0VORCgpCgl9OwoKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIE5VTEwsIG9wdGlvbnMsIGJ1aWx0aW5fcmVtb3RlX3VzYWdlLAoJCQkgICAgIDApOwoKCWlmIChhcmdjIDwgMSkKCQl1c2FnZV93aXRoX29wdGlvbnMoYnVpbHRpbl9yZW1vdGVfdXNhZ2UsIG9wdGlvbnMpOwoKCWZvciAoOyBhcmdjOyBhcmdjLS0sIGFyZ3YrKykKCQlyZXN1bHQgfD0gcHJ1bmVfcmVtb3RlKCphcmd2LCBkcnlfcnVuKTsKCglyZXR1cm4gcmVzdWx0Owp9CgpzdGF0aWMgaW50IHBydW5lX3JlbW90ZShjb25zdCBjaGFyICpyZW1vdGUsIGludCBkcnlfcnVuKQp7CglpbnQgcmVzdWx0ID0gMCwgaTsKCXN0cnVjdCByZWZfc3RhdGVzIHN0YXRlczsKCWNvbnN0IGNoYXIgKmRhbmdsaW5nX21zZyA9IGRyeV9ydW4KCQk/ICIgJXMgd2lsbCBiZWNvbWUgZGFuZ2xpbmchXG4iCgkJOiAiICVzIGhhcyBiZWNvbWUgZGFuZ2xpbmchXG4iOwoKCW1lbXNldCgmc3RhdGVzLCAwLCBzaXplb2Yoc3RhdGVzKSk7CglnZXRfcmVtb3RlX3JlZl9zdGF0ZXMocmVtb3RlLCAmc3RhdGVzLCBHRVRfUkVGX1NUQVRFUyk7CgoJaWYgKHN0YXRlcy5zdGFsZS5ucikgewoJCXByaW50ZigiUHJ1bmluZyAlc1xuIiwgcmVtb3RlKTsKCQlwcmludGYoIlVSTDogJXNcbiIsCgkJICAgICAgIHN0YXRlcy5yZW1vdGUtPnVybF9ucgoJCSAgICAgICA/IHN0YXRlcy5yZW1vdGUtPnVybFswXQoJCSAgICAgICA6ICIobm8gVVJMKSIpOwoJfQoKCWZvciAoaSA9IDA7IGkgPCBzdGF0ZXMuc3RhbGUubnI7IGkrKykgewoJCWNvbnN0IGNoYXIgKnJlZm5hbWUgPSBzdGF0ZXMuc3RhbGUuaXRlbXNbaV0udXRpbDsKCgkJaWYgKCFkcnlfcnVuKQoJCQlyZXN1bHQgfD0gZGVsZXRlX3JlZihyZWZuYW1lLCBOVUxMLCAwKTsKCgkJcHJpbnRmKCIgKiBbJXNdICVzXG4iLCBkcnlfcnVuID8gIndvdWxkIHBydW5lIiA6ICJwcnVuZWQiLAoJCSAgICAgICBhYmJyZXZfcmVmKHJlZm5hbWUsICJyZWZzL3JlbW90ZXMvIikpOwoJCXdhcm5fZGFuZ2xpbmdfc3ltcmVmKGRhbmdsaW5nX21zZywgcmVmbmFtZSk7Cgl9CgoJZnJlZV9yZW1vdGVfcmVmX3N0YXRlcygmc3RhdGVzKTsKCXJldHVybiByZXN1bHQ7Cn0KCnN0YXRpYyBpbnQgZ2V0X29uZV9yZW1vdGVfZm9yX3VwZGF0ZShzdHJ1Y3QgcmVtb3RlICpyZW1vdGUsIHZvaWQgKnByaXYpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCA9IHByaXY7CglpZiAoIXJlbW90ZS0+c2tpcF9kZWZhdWx0X3VwZGF0ZSkKCQlzdHJpbmdfbGlzdF9hcHBlbmQocmVtb3RlLT5uYW1lLCBsaXN0KTsKCXJldHVybiAwOwp9CgpzdGF0aWMgc3RydWN0IHJlbW90ZV9ncm91cCB7Cgljb25zdCBjaGFyICpuYW1lOwoJc3RydWN0IHN0cmluZ19saXN0ICpsaXN0Owp9IHJlbW90ZV9ncm91cDsKCnN0YXRpYyBpbnQgZ2V0X3JlbW90ZV9ncm91cChjb25zdCBjaGFyICprZXksIGNvbnN0IGNoYXIgKnZhbHVlLCB2b2lkICpudW1faGl0cykKewoJaWYgKCFwcmVmaXhjbXAoa2V5LCAicmVtb3Rlcy4iKSAmJgoJCQkhc3RyY21wKGtleSArIDgsIHJlbW90ZV9ncm91cC5uYW1lKSkgewoJCS8qIHNwbGl0IGxpc3QgYnkgd2hpdGUgc3BhY2UgKi8KCQlpbnQgc3BhY2UgPSBzdHJjc3BuKHZhbHVlLCAiIFx0XG4iKTsKCQl3aGlsZSAoKnZhbHVlKSB7CgkJCWlmIChzcGFjZSA+IDEpIHsKCQkJCXN0cmluZ19saXN0X2FwcGVuZCh4c3RybmR1cCh2YWx1ZSwgc3BhY2UpLAoJCQkJCQlyZW1vdGVfZ3JvdXAubGlzdCk7CgkJCQkrKyooKGludCAqKW51bV9oaXRzKTsKCQkJfQoJCQl2YWx1ZSArPSBzcGFjZSArICh2YWx1ZVtzcGFjZV0gIT0gJ1wwJyk7CgkJCXNwYWNlID0gc3RyY3Nwbih2YWx1ZSwgIiBcdFxuIik7CgkJfQoJfQoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHVwZGF0ZShpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YpCnsKCWludCBpLCByZXN1bHQgPSAwLCBwcnVuZSA9IDA7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgbGlzdCA9IHsgTlVMTCwgMCwgMCwgMCB9OwoJc3RhdGljIGNvbnN0IGNoYXIgKmRlZmF1bHRfYXJndltdID0geyBOVUxMLCAiZGVmYXVsdCIsIE5VTEwgfTsKCXN0cnVjdCBvcHRpb24gb3B0aW9uc1tdID0gewoJCU9QVF9HUk9VUCgidXBkYXRlIHNwZWNpZmljIG9wdGlvbnMiKSwKCQlPUFRfQk9PTEVBTigncCcsICJwcnVuZSIsICZwcnVuZSwKCQkJICAgICJwcnVuZSByZW1vdGVzIGFmdGVyIGZldGNoaW5nIiksCgkJT1BUX0VORCgpCgl9OwoKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIE5VTEwsIG9wdGlvbnMsIGJ1aWx0aW5fcmVtb3RlX3VzYWdlLAoJCQkgICAgIFBBUlNFX09QVF9LRUVQX0FSR1YwKTsKCWlmIChhcmdjIDwgMikgewoJCWFyZ2MgPSAyOwoJCWFyZ3YgPSBkZWZhdWx0X2FyZ3Y7Cgl9CgoJcmVtb3RlX2dyb3VwLmxpc3QgPSAmbGlzdDsKCWZvciAoaSA9IDE7IGkgPCBhcmdjOyBpKyspIHsKCQlpbnQgZ3JvdXBzX2ZvdW5kID0gMDsKCQlyZW1vdGVfZ3JvdXAubmFtZSA9IGFyZ3ZbaV07CgkJcmVzdWx0ID0gZ2l0X2NvbmZpZyhnZXRfcmVtb3RlX2dyb3VwLCAmZ3JvdXBzX2ZvdW5kKTsKCQlpZiAoIWdyb3Vwc19mb3VuZCAmJiAoaSAhPSAxIHx8IHN0cmNtcChhcmd2WzFdLCAiZGVmYXVsdCIpKSkgewoJCQlzdHJ1Y3QgcmVtb3RlICpyZW1vdGU7CgkJCWlmICghcmVtb3RlX2lzX2NvbmZpZ3VyZWQoYXJndltpXSkpCgkJCQlkaWUoIk5vIHN1Y2ggcmVtb3RlIG9yIHJlbW90ZSBncm91cDogJXMiLAoJCQkJICAgIGFyZ3ZbaV0pOwoJCQlyZW1vdGUgPSByZW1vdGVfZ2V0KGFyZ3ZbaV0pOwoJCQlzdHJpbmdfbGlzdF9hcHBlbmQocmVtb3RlLT5uYW1lLCByZW1vdGVfZ3JvdXAubGlzdCk7CgkJfQoJfQoKCWlmICghcmVzdWx0ICYmICFsaXN0Lm5yICAmJiBhcmdjID09IDIgJiYgIXN0cmNtcChhcmd2WzFdLCAiZGVmYXVsdCIpKQoJCXJlc3VsdCA9IGZvcl9lYWNoX3JlbW90ZShnZXRfb25lX3JlbW90ZV9mb3JfdXBkYXRlLCAmbGlzdCk7CgoJZm9yIChpID0gMDsgaSA8IGxpc3QubnI7IGkrKykgewoJCWludCBlcnIgPSBmZXRjaF9yZW1vdGUobGlzdC5pdGVtc1tpXS5zdHJpbmcpOwoJCXJlc3VsdCB8PSBlcnI7CgkJaWYgKCFlcnIgJiYgcHJ1bmUpCgkJCXJlc3VsdCB8PSBwcnVuZV9yZW1vdGUobGlzdC5pdGVtc1tpXS5zdHJpbmcsIDApOwoJfQoKCS8qIGFsbCBuYW1lcyB3ZXJlIHN0cmR1cCgpZWQgb3Igc3RybmR1cCgpZWQgKi8KCWxpc3Quc3RyZHVwX3N0cmluZ3MgPSAxOwoJc3RyaW5nX2xpc3RfY2xlYXIoJmxpc3QsIDApOwoKCXJldHVybiByZXN1bHQ7Cn0KCnN0YXRpYyBpbnQgZ2V0X29uZV9lbnRyeShzdHJ1Y3QgcmVtb3RlICpyZW1vdGUsIHZvaWQgKnByaXYpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCA9IHByaXY7CglzdHJ1Y3Qgc3RyYnVmIHVybF9idWYgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKip1cmw7CglpbnQgaSwgdXJsX25yOwoKCWlmIChyZW1vdGUtPnVybF9uciA+IDApIHsKCQlzdHJidWZfYWRkZigmdXJsX2J1ZiwgIiVzIChmZXRjaCkiLCByZW1vdGUtPnVybFswXSk7CgkJc3RyaW5nX2xpc3RfYXBwZW5kKHJlbW90ZS0+bmFtZSwgbGlzdCktPnV0aWwgPQoJCQkJc3RyYnVmX2RldGFjaCgmdXJsX2J1ZiwgTlVMTCk7Cgl9IGVsc2UKCQlzdHJpbmdfbGlzdF9hcHBlbmQocmVtb3RlLT5uYW1lLCBsaXN0KS0+dXRpbCA9IE5VTEw7CglpZiAocmVtb3RlLT5wdXNodXJsX25yKSB7CgkJdXJsID0gcmVtb3RlLT5wdXNodXJsOwoJCXVybF9uciA9IHJlbW90ZS0+cHVzaHVybF9ucjsKCX0gZWxzZSB7CgkJdXJsID0gcmVtb3RlLT51cmw7CgkJdXJsX25yID0gcmVtb3RlLT51cmxfbnI7Cgl9Cglmb3IgKGkgPSAwOyBpIDwgdXJsX25yOyBpKyspCgl7CgkJc3RyYnVmX2FkZGYoJnVybF9idWYsICIlcyAocHVzaCkiLCB1cmxbaV0pOwoJCXN0cmluZ19saXN0X2FwcGVuZChyZW1vdGUtPm5hbWUsIGxpc3QpLT51dGlsID0KCQkJCXN0cmJ1Zl9kZXRhY2goJnVybF9idWYsIE5VTEwpOwoJfQoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHNob3dfYWxsKHZvaWQpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdCBsaXN0ID0geyBOVUxMLCAwLCAwIH07CglpbnQgcmVzdWx0OwoKCWxpc3Quc3RyZHVwX3N0cmluZ3MgPSAxOwoJcmVzdWx0ID0gZm9yX2VhY2hfcmVtb3RlKGdldF9vbmVfZW50cnksICZsaXN0KTsKCglpZiAoIXJlc3VsdCkgewoJCWludCBpOwoKCQlzb3J0X3N0cmluZ19saXN0KCZsaXN0KTsKCQlmb3IgKGkgPSAwOyBpIDwgbGlzdC5ucjsgaSsrKSB7CgkJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtID0gbGlzdC5pdGVtcyArIGk7CgkJCWlmICh2ZXJib3NlKQoJCQkJcHJpbnRmKCIlc1x0JXNcbiIsIGl0ZW0tPnN0cmluZywKCQkJCQlpdGVtLT51dGlsID8gKGNvbnN0IGNoYXIgKilpdGVtLT51dGlsIDogIiIpOwoJCQllbHNlIHsKCQkJCWlmIChpICYmICFzdHJjbXAoKGl0ZW0gLSAxKS0+c3RyaW5nLCBpdGVtLT5zdHJpbmcpKQoJCQkJCWNvbnRpbnVlOwoJCQkJcHJpbnRmKCIlc1xuIiwgaXRlbS0+c3RyaW5nKTsKCQkJfQoJCX0KCX0KCXN0cmluZ19saXN0X2NsZWFyKCZsaXN0LCAxKTsKCXJldHVybiByZXN1bHQ7Cn0KCmludCBjbWRfcmVtb3RlKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfX1ZFUkJPU0UoJnZlcmJvc2UpLAoJCU9QVF9FTkQoKQoJfTsKCWludCByZXN1bHQ7CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBvcHRpb25zLCBidWlsdGluX3JlbW90ZV91c2FnZSwKCQlQQVJTRV9PUFRfU1RPUF9BVF9OT05fT1BUSU9OKTsKCglpZiAoYXJnYyA8IDEpCgkJcmVzdWx0ID0gc2hvd19hbGwoKTsKCWVsc2UgaWYgKCFzdHJjbXAoYXJndlswXSwgImFkZCIpKQoJCXJlc3VsdCA9IGFkZChhcmdjLCBhcmd2KTsKCWVsc2UgaWYgKCFzdHJjbXAoYXJndlswXSwgInJlbmFtZSIpKQoJCXJlc3VsdCA9IG12KGFyZ2MsIGFyZ3YpOwoJZWxzZSBpZiAoIXN0cmNtcChhcmd2WzBdLCAicm0iKSkKCQlyZXN1bHQgPSBybShhcmdjLCBhcmd2KTsKCWVsc2UgaWYgKCFzdHJjbXAoYXJndlswXSwgInNldC1oZWFkIikpCgkJcmVzdWx0ID0gc2V0X2hlYWQoYXJnYywgYXJndik7CgllbHNlIGlmICghc3RyY21wKGFyZ3ZbMF0sICJzaG93IikpCgkJcmVzdWx0ID0gc2hvdyhhcmdjLCBhcmd2KTsKCWVsc2UgaWYgKCFzdHJjbXAoYXJndlswXSwgInBydW5lIikpCgkJcmVzdWx0ID0gcHJ1bmUoYXJnYywgYXJndik7CgllbHNlIGlmICghc3RyY21wKGFyZ3ZbMF0sICJ1cGRhdGUiKSkKCQlyZXN1bHQgPSB1cGRhdGUoYXJnYywgYXJndik7CgllbHNlIHsKCQllcnJvcigiVW5rbm93biBzdWJjb21tYW5kOiAlcyIsIGFyZ3ZbMF0pOwoJCXVzYWdlX3dpdGhfb3B0aW9ucyhidWlsdGluX3JlbW90ZV91c2FnZSwgb3B0aW9ucyk7Cgl9CgoJcmV0dXJuIHJlc3VsdCA/IDEgOiAwOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"parse-options.h\"\n#include \"transport.h\"\n#include \"remote.h\"\n#include \"string-list.h\"\n#include \"strbuf.h\"\n#include \"run-command.h\"\n#include \"refs.h\"\n\nstatic const char * const builtin_remote_usage[] = {\n\t\"git remote [-v | --verbose]\",\n\t\"git remote add [-t <branch>] [-m <master>] [-f] [--mirror] <name> <url>\",\n\t\"git remote rename <old> <new>\",\n\t\"git remote rm <name>\",\n\t\"git remote set-head <name> [-a | -d | <branch>]\",\n\t\"git remote show [-n] <name>\",\n\t\"git remote prune [-n | --dry-run] <name>\",\n\t\"git remote [-v | --verbose] update [-p | --prune] [group]\",\n\tNULL\n};\n\n#define GET_REF_STATES (1<<0)\n#define GET_HEAD_NAMES (1<<1)\n#define GET_PUSH_REF_STATES (1<<2)\n\nstatic int verbose;\n\nstatic int show_all(void);\nstatic int prune_remote(const char *remote, int dry_run);\n\nstatic inline int postfixcmp(const char *string, const char *postfix)\n{\n\tint len1 = strlen(string), len2 = strlen(postfix);\n\tif (len1 < len2)\n\t\treturn 1;\n\treturn strcmp(string + len1 - len2, postfix);\n}\n\nstatic int opt_parse_track(const struct option *opt, const char *arg, int not)\n{\n\tstruct string_list *list = opt->value;\n\tif (not)\n\t\tstring_list_clear(list, 0);\n\telse\n\t\tstring_list_append(arg, list);\n\treturn 0;\n}\n\nstatic int fetch_remote(const char *name)\n{\n\tconst char *argv[] = { \"fetch\", name, NULL, NULL };\n\tif (verbose) {\n\t\targv[1] = \"-v\";\n\t\targv[2] = name;\n\t}\n\tprintf(\"Updating %s\\n\", name);\n\tif (run_command_v_opt(argv, RUN_GIT_CMD))\n\t\treturn error(\"Could not fetch %s\", name);\n\treturn 0;\n}\n\nstatic int add(int argc, const char **argv)\n{\n\tint fetch = 0, mirror = 0;\n\tstruct string_list track = { NULL, 0, 0 };\n\tconst char *master = NULL;\n\tstruct remote *remote;\n\tstruct strbuf buf = STRBUF_INIT, buf2 = STRBUF_INIT;\n\tconst char *name, *url;\n\tint i;\n\n\tstruct option options[] = {\n\t\tOPT_GROUP(\"add specific options\"),\n\t\tOPT_BOOLEAN('f', \"fetch\", &fetch, \"fetch the remote branches\"),\n\t\tOPT_CALLBACK('t', \"track\", &track, \"branch\",\n\t\t\t\"branch(es) to track\", opt_parse_track),\n\t\tOPT_STRING('m', \"master\", &master, \"branch\", \"master branch\"),\n\t\tOPT_BOOLEAN(0, \"mirror\", &mirror, \"no separate remotes\"),\n\t\tOPT_END()\n\t};\n\n\targc = parse_options(argc, argv, NULL, options, builtin_remote_usage,\n\t\t\t     0);\n\n\tif (argc < 2)\n\t\tusage_with_options(builtin_remote_usage, options);\n\n\tname = argv[0];\n\turl = argv[1];\n\n\tremote = remote_get(name);\n\tif (remote && (remote->url_nr > 1 || strcmp(name, remote->url[0]) ||\n\t\t\tremote->fetch_refspec_nr))\n\t\tdie(\"remote %s already exists.\", name);\n\n\tstrbuf_addf(&buf2, \"refs/heads/test:refs/remotes/%s/test\", name);\n\tif (!valid_fetch_refspec(buf2.buf))\n\t\tdie(\"'%s' is not a valid remote name\", name);\n\n\tstrbuf_addf(&buf, \"remote.%s.url\", name);\n\tif (git_config_set(buf.buf, url))\n\t\treturn 1;\n\n\tstrbuf_reset(&buf);\n\tstrbuf_addf(&buf, \"remote.%s.fetch\", name);\n\n\tif (track.nr == 0)\n\t\tstring_list_append(\"*\", &track);\n\tfor (i = 0; i < track.nr; i++) {\n\t\tstruct string_list_item *item = track.items + i;\n\n\t\tstrbuf_reset(&buf2);\n\t\tstrbuf_addch(&buf2, '+');\n\t\tif (mirror)\n\t\t\tstrbuf_addf(&buf2, \"refs/%s:refs/%s\",\n\t\t\t\t\titem->string, item->string);\n\t\telse\n\t\t\tstrbuf_addf(&buf2, \"refs/heads/%s:refs/remotes/%s/%s\",\n\t\t\t\t\titem->string, name, item->string);\n\t\tif (git_config_set_multivar(buf.buf, buf2.buf, \"^$\", 0))\n\t\t\treturn 1;\n\t}\n\n\tif (mirror) {\n\t\tstrbuf_reset(&buf);\n\t\tstrbuf_addf(&buf, \"remote.%s.mirror\", name);\n\t\tif (git_config_set(buf.buf, \"true\"))\n\t\t\treturn 1;\n\t}\n\n\tif (fetch && fetch_remote(name))\n\t\treturn 1;\n\n\tif (master) {\n\t\tstrbuf_reset(&buf);\n\t\tstrbuf_addf(&buf, \"refs/remotes/%s/HEAD\", name);\n\n\t\tstrbuf_reset(&buf2);\n\t\tstrbuf_addf(&buf2, \"refs/remotes/%s/%s\", name, master);\n\n\t\tif (create_symref(buf.buf, buf2.buf, \"remote add\"))\n\t\t\treturn error(\"Could not setup master '%s'\", master);\n\t}\n\n\tstrbuf_release(&buf);\n\tstrbuf_release(&buf2);\n\tstring_list_clear(&track, 0);\n\n\treturn 0;\n}\n\nstruct branch_info {\n\tchar *remote_name;\n\tstruct string_list merge;\n\tint rebase;\n};\n\nstatic struct string_list branch_list;\n\nstatic const char *abbrev_ref(const char *name, const char *prefix)\n{\n\tconst char *abbrev = skip_prefix(name, prefix);\n\tif (abbrev)\n\t\treturn abbrev;\n\treturn name;\n}\n#define abbrev_branch(name) abbrev_ref((name), \"refs/heads/\")\n\nstatic int config_read_branches(const char *key, const char *value, void *cb)\n{\n\tif (!prefixcmp(key, \"branch.\")) {\n\t\tconst char *orig_key = key;\n\t\tchar *name;\n\t\tstruct string_list_item *item;\n\t\tstruct branch_info *info;\n\t\tenum { REMOTE, MERGE, REBASE } type;\n\n\t\tkey += 7;\n\t\tif (!postfixcmp(key, \".remote\")) {\n\t\t\tname = xstrndup(key, strlen(key) - 7);\n\t\t\ttype = REMOTE;\n\t\t} else if (!postfixcmp(key, \".merge\")) {\n\t\t\tname = xstrndup(key, strlen(key) - 6);\n\t\t\ttype = MERGE;\n\t\t} else if (!postfixcmp(key, \".rebase\")) {\n\t\t\tname = xstrndup(key, strlen(key) - 7);\n\t\t\ttype = REBASE;\n\t\t} else\n\t\t\treturn 0;\n\n\t\titem = string_list_insert(name, &branch_list);\n\n\t\tif (!item->util)\n\t\t\titem->util = xcalloc(sizeof(struct branch_info), 1);\n\t\tinfo = item->util;\n\t\tif (type == REMOTE) {\n\t\t\tif (info->remote_name)\n\t\t\t\twarning(\"more than one %s\", orig_key);\n\t\t\tinfo->remote_name = xstrdup(value);\n\t\t} else if (type == MERGE) {\n\t\t\tchar *space = strchr(value, ' ');\n\t\t\tvalue = abbrev_branch(value);\n\t\t\twhile (space) {\n\t\t\t\tchar *merge;\n\t\t\t\tmerge = xstrndup(value, space - value);\n\t\t\t\tstring_list_append(merge, &info->merge);\n\t\t\t\tvalue = abbrev_branch(space + 1);\n\t\t\t\tspace = strchr(value, ' ');\n\t\t\t}\n\t\t\tstring_list_append(xstrdup(value), &info->merge);\n\t\t} else\n\t\t\tinfo->rebase = git_config_bool(orig_key, value);\n\t}\n\treturn 0;\n}\n\nstatic void read_branches(void)\n{\n\tif (branch_list.nr)\n\t\treturn;\n\tgit_config(config_read_branches, NULL);\n}\n\nstruct ref_states {\n\tstruct remote *remote;\n\tstruct string_list new, stale, tracked, heads, push;\n\tint queried;\n};\n\nstatic int handle_one_branch(const char *refname,\n\tconst unsigned char *sha1, int flags, void *cb_data)\n{\n\tstruct ref_states *states = cb_data;\n\tstruct refspec refspec;\n\n\tmemset(&refspec, 0, sizeof(refspec));\n\trefspec.dst = (char *)refname;\n\tif (!remote_find_tracking(states->remote, &refspec)) {\n\t\tstruct string_list_item *item;\n\t\tconst char *name = abbrev_branch(refspec.src);\n\t\t/* symbolic refs pointing nowhere were handled already */\n\t\tif ((flags & REF_ISSYMREF) ||\n\t\t    string_list_has_string(&states->tracked, name) ||\n\t\t    string_list_has_string(&states->new, name))\n\t\t\treturn 0;\n\t\titem = string_list_append(name, &states->stale);\n\t\titem->util = xstrdup(refname);\n\t}\n\treturn 0;\n}\n\nstatic int get_ref_states(const struct ref *remote_refs, struct ref_states *states)\n{\n\tstruct ref *fetch_map = NULL, **tail = &fetch_map;\n\tstruct ref *ref;\n\tint i;\n\n\tfor (i = 0; i < states->remote->fetch_refspec_nr; i++)\n\t\tif (get_fetch_map(remote_refs, states->remote->fetch + i, &tail, 1))\n\t\t\tdie(\"Could not get fetch map for refspec %s\",\n\t\t\t\tstates->remote->fetch_refspec[i]);\n\n\tstates->new.strdup_strings = states->tracked.strdup_strings = 1;\n\tfor (ref = fetch_map; ref; ref = ref->next) {\n\t\tunsigned char sha1[20];\n\t\tif (!ref->peer_ref || read_ref(ref->peer_ref->name, sha1))\n\t\t\tstring_list_append(abbrev_branch(ref->name), &states->new);\n\t\telse\n\t\t\tstring_list_append(abbrev_branch(ref->name), &states->tracked);\n\t}\n\tfree_refs(fetch_map);\n\n\tsort_string_list(&states->new);\n\tsort_string_list(&states->tracked);\n\tfor_each_ref(handle_one_branch, states);\n\tsort_string_list(&states->stale);\n\n\treturn 0;\n}\n\nstruct push_info {\n\tchar *dest;\n\tint forced;\n\tenum {\n\t\tPUSH_STATUS_CREATE = 0,\n\t\tPUSH_STATUS_DELETE,\n\t\tPUSH_STATUS_UPTODATE,\n\t\tPUSH_STATUS_FASTFORWARD,\n\t\tPUSH_STATUS_OUTOFDATE,\n\t\tPUSH_STATUS_NOTQUERIED,\n\t} status;\n};\n\nstatic int get_push_ref_states(const struct ref *remote_refs,\n\tstruct ref_states *states)\n{\n\tstruct remote *remote = states->remote;\n\tstruct ref *ref, *local_refs, *push_map;\n\tif (remote->mirror)\n\t\treturn 0;\n\n\tlocal_refs = get_local_heads();\n\tpush_map = copy_ref_list(remote_refs);\n\n\tmatch_refs(local_refs, &push_map, remote->push_refspec_nr,\n\t\t   remote->push_refspec, MATCH_REFS_NONE);\n\n\tstates->push.strdup_strings = 1;\n\tfor (ref = push_map; ref; ref = ref->next) {\n\t\tstruct string_list_item *item;\n\t\tstruct push_info *info;\n\n\t\tif (!ref->peer_ref)\n\t\t\tcontinue;\n\t\thashcpy(ref->new_sha1, ref->peer_ref->new_sha1);\n\n\t\titem = string_list_append(abbrev_branch(ref->peer_ref->name),\n\t\t\t\t\t  &states->push);\n\t\titem->util = xcalloc(sizeof(struct push_info), 1);\n\t\tinfo = item->util;\n\t\tinfo->forced = ref->force;\n\t\tinfo->dest = xstrdup(abbrev_branch(ref->name));\n\n\t\tif (is_null_sha1(ref->new_sha1)) {\n\t\t\tinfo->status = PUSH_STATUS_DELETE;\n\t\t} else if (!hashcmp(ref->old_sha1, ref->new_sha1))\n\t\t\tinfo->status = PUSH_STATUS_UPTODATE;\n\t\telse if (is_null_sha1(ref->old_sha1))\n\t\t\tinfo->status = PUSH_STATUS_CREATE;\n\t\telse if (has_sha1_file(ref->old_sha1) &&\n\t\t\t ref_newer(ref->new_sha1, ref->old_sha1))\n\t\t\tinfo->status = PUSH_STATUS_FASTFORWARD;\n\t\telse\n\t\t\tinfo->status = PUSH_STATUS_OUTOFDATE;\n\t}\n\tfree_refs(local_refs);\n\tfree_refs(push_map);\n\treturn 0;\n}\n\nstatic int get_push_ref_states_noquery(struct ref_states *states)\n{\n\tint i;\n\tstruct remote *remote = states->remote;\n\tstruct string_list_item *item;\n\tstruct push_info *info;\n\n\tif (remote->mirror)\n\t\treturn 0;\n\n\tstates->push.strdup_strings = 1;\n\tif (!remote->push_refspec_nr) {\n\t\titem = string_list_append(\"(matching)\", &states->push);\n\t\tinfo = item->util = xcalloc(sizeof(struct push_info), 1);\n\t\tinfo->status = PUSH_STATUS_NOTQUERIED;\n\t\tinfo->dest = xstrdup(item->string);\n\t}\n\tfor (i = 0; i < remote->push_refspec_nr; i++) {\n\t\tstruct refspec *spec = remote->push + i;\n\t\tif (spec->matching)\n\t\t\titem = string_list_append(\"(matching)\", &states->push);\n\t\telse if (strlen(spec->src))\n\t\t\titem = string_list_append(spec->src, &states->push);\n\t\telse\n\t\t\titem = string_list_append(\"(delete)\", &states->push);\n\n\t\tinfo = item->util = xcalloc(sizeof(struct push_info), 1);\n\t\tinfo->forced = spec->force;\n\t\tinfo->status = PUSH_STATUS_NOTQUERIED;\n\t\tinfo->dest = xstrdup(spec->dst ? spec->dst : item->string);\n\t}\n\treturn 0;\n}\n\nstatic int get_head_names(const struct ref *remote_refs, struct ref_states *states)\n{\n\tstruct ref *ref, *matches;\n\tstruct ref *fetch_map = NULL, **fetch_map_tail = &fetch_map;\n\tstruct refspec refspec;\n\n\trefspec.force = 0;\n\trefspec.pattern = 1;\n\trefspec.src = refspec.dst = \"refs/heads/*\";\n\tstates->heads.strdup_strings = 1;\n\tget_fetch_map(remote_refs, &refspec, &fetch_map_tail, 0);\n\tmatches = guess_remote_head(find_ref_by_name(remote_refs, \"HEAD\"),\n\t\t\t\t    fetch_map, 1);\n\tfor(ref = matches; ref; ref = ref->next)\n\t\tstring_list_append(abbrev_branch(ref->name), &states->heads);\n\n\tfree_refs(fetch_map);\n\tfree_refs(matches);\n\n\treturn 0;\n}\n\nstruct known_remote {\n\tstruct known_remote *next;\n\tstruct remote *remote;\n};\n\nstruct known_remotes {\n\tstruct remote *to_delete;\n\tstruct known_remote *list;\n};\n\nstatic int add_known_remote(struct remote *remote, void *cb_data)\n{\n\tstruct known_remotes *all = cb_data;\n\tstruct known_remote *r;\n\n\tif (!strcmp(all->to_delete->name, remote->name))\n\t\treturn 0;\n\n\tr = xmalloc(sizeof(*r));\n\tr->remote = remote;\n\tr->next = all->list;\n\tall->list = r;\n\treturn 0;\n}\n\nstruct branches_for_remote {\n\tstruct remote *remote;\n\tstruct string_list *branches, *skipped;\n\tstruct known_remotes *keep;\n};\n\nstatic int add_branch_for_removal(const char *refname,\n\tconst unsigned char *sha1, int flags, void *cb_data)\n{\n\tstruct branches_for_remote *branches = cb_data;\n\tstruct refspec refspec;\n\tstruct string_list_item *item;\n\tstruct known_remote *kr;\n\n\tmemset(&refspec, 0, sizeof(refspec));\n\trefspec.dst = (char *)refname;\n\tif (remote_find_tracking(branches->remote, &refspec))\n\t\treturn 0;\n\n\t/* don't delete a branch if another remote also uses it */\n\tfor (kr = branches->keep->list; kr; kr = kr->next) {\n\t\tmemset(&refspec, 0, sizeof(refspec));\n\t\trefspec.dst = (char *)refname;\n\t\tif (!remote_find_tracking(kr->remote, &refspec))\n\t\t\treturn 0;\n\t}\n\n\t/* don't delete non-remote refs */\n\tif (prefixcmp(refname, \"refs/remotes\")) {\n\t\t/* advise user how to delete local branches */\n\t\tif (!prefixcmp(refname, \"refs/heads/\"))\n\t\t\tstring_list_append(abbrev_branch(refname),\n\t\t\t\t\t   branches->skipped);\n\t\t/* silently skip over other non-remote refs */\n\t\treturn 0;\n\t}\n\n\t/* make sure that symrefs are deleted */\n\tif (flags & REF_ISSYMREF)\n\t\treturn unlink(git_path(\"%s\", refname));\n\n\titem = string_list_append(refname, branches->branches);\n\titem->util = xmalloc(20);\n\thashcpy(item->util, sha1);\n\n\treturn 0;\n}\n\nstruct rename_info {\n\tconst char *old;\n\tconst char *new;\n\tstruct string_list *remote_branches;\n};\n\nstatic int read_remote_branches(const char *refname,\n\tconst unsigned char *sha1, int flags, void *cb_data)\n{\n\tstruct rename_info *rename = cb_data;\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct string_list_item *item;\n\tint flag;\n\tunsigned char orig_sha1[20];\n\tconst char *symref;\n\n\tstrbuf_addf(&buf, \"refs/remotes/%s\", rename->old);\n\tif(!prefixcmp(refname, buf.buf)) {\n\t\titem = string_list_append(xstrdup(refname), rename->remote_branches);\n\t\tsymref = resolve_ref(refname, orig_sha1, 1, &flag);\n\t\tif (flag & REF_ISSYMREF)\n\t\t\titem->util = xstrdup(symref);\n\t\telse\n\t\t\titem->util = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int migrate_file(struct remote *remote)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tint i;\n\tchar *path = NULL;\n\n\tstrbuf_addf(&buf, \"remote.%s.url\", remote->name);\n\tfor (i = 0; i < remote->url_nr; i++)\n\t\tif (git_config_set_multivar(buf.buf, remote->url[i], \"^$\", 0))\n\t\t\treturn error(\"Could not append '%s' to '%s'\",\n\t\t\t\t\tremote->url[i], buf.buf);\n\tstrbuf_reset(&buf);\n\tstrbuf_addf(&buf, \"remote.%s.push\", remote->name);\n\tfor (i = 0; i < remote->push_refspec_nr; i++)\n\t\tif (git_config_set_multivar(buf.buf, remote->push_refspec[i], \"^$\", 0))\n\t\t\treturn error(\"Could not append '%s' to '%s'\",\n\t\t\t\t\tremote->push_refspec[i], buf.buf);\n\tstrbuf_reset(&buf);\n\tstrbuf_addf(&buf, \"remote.%s.fetch\", remote->name);\n\tfor (i = 0; i < remote->fetch_refspec_nr; i++)\n\t\tif (git_config_set_multivar(buf.buf, remote->fetch_refspec[i], \"^$\", 0))\n\t\t\treturn error(\"Could not append '%s' to '%s'\",\n\t\t\t\t\tremote->fetch_refspec[i], buf.buf);\n\tif (remote->origin == REMOTE_REMOTES)\n\t\tpath = git_path(\"remotes/%s\", remote->name);\n\telse if (remote->origin == REMOTE_BRANCHES)\n\t\tpath = git_path(\"branches/%s\", remote->name);\n\tif (path)\n\t\tunlink_or_warn(path);\n\treturn 0;\n}\n\nstatic int mv(int argc, const char **argv)\n{\n\tstruct option options[] = {\n\t\tOPT_END()\n\t};\n\tstruct remote *oldremote, *newremote;\n\tstruct strbuf buf = STRBUF_INIT, buf2 = STRBUF_INIT, buf3 = STRBUF_INIT;\n\tstruct string_list remote_branches = { NULL, 0, 0, 0 };\n\tstruct rename_info rename;\n\tint i;\n\n\tif (argc != 3)\n\t\tusage_with_options(builtin_remote_usage, options);\n\n\trename.old = argv[1];\n\trename.new = argv[2];\n\trename.remote_branches = &remote_branches;\n\n\toldremote = remote_get(rename.old);\n\tif (!oldremote)\n\t\tdie(\"No such remote: %s\", rename.old);\n\n\tif (!strcmp(rename.old, rename.new) && oldremote->origin != REMOTE_CONFIG)\n\t\treturn migrate_file(oldremote);\n\n\tnewremote = remote_get(rename.new);\n\tif (newremote && (newremote->url_nr > 1 || newremote->fetch_refspec_nr))\n\t\tdie(\"remote %s already exists.\", rename.new);\n\n\tstrbuf_addf(&buf, \"refs/heads/test:refs/remotes/%s/test\", rename.new);\n\tif (!valid_fetch_refspec(buf.buf))\n\t\tdie(\"'%s' is not a valid remote name\", rename.new);\n\n\tstrbuf_reset(&buf);\n\tstrbuf_addf(&buf, \"remote.%s\", rename.old);\n\tstrbuf_addf(&buf2, \"remote.%s\", rename.new);\n\tif (git_config_rename_section(buf.buf, buf2.buf) < 1)\n\t\treturn error(\"Could not rename config section '%s' to '%s'\",\n\t\t\t\tbuf.buf, buf2.buf);\n\n\tstrbuf_reset(&buf);\n\tstrbuf_addf(&buf, \"remote.%s.fetch\", rename.new);\n\tif (git_config_set_multivar(buf.buf, NULL, NULL, 1))\n\t\treturn error(\"Could not remove config section '%s'\", buf.buf);\n\tfor (i = 0; i < oldremote->fetch_refspec_nr; i++) {\n\t\tchar *ptr;\n\n\t\tstrbuf_reset(&buf2);\n\t\tstrbuf_addstr(&buf2, oldremote->fetch_refspec[i]);\n\t\tptr = strstr(buf2.buf, rename.old);\n\t\tif (ptr)\n\t\t\tstrbuf_splice(&buf2, ptr-buf2.buf, strlen(rename.old),\n\t\t\t\t\trename.new, strlen(rename.new));\n\t\tif (git_config_set_multivar(buf.buf, buf2.buf, \"^$\", 0))\n\t\t\treturn error(\"Could not append '%s'\", buf.buf);\n\t}\n\n\tread_branches();\n\tfor (i = 0; i < branch_list.nr; i++) {\n\t\tstruct string_list_item *item = branch_list.items + i;\n\t\tstruct branch_info *info = item->util;\n\t\tif (info->remote_name && !strcmp(info->remote_name, rename.old)) {\n\t\t\tstrbuf_reset(&buf);\n\t\t\tstrbuf_addf(&buf, \"branch.%s.remote\", item->string);\n\t\t\tif (git_config_set(buf.buf, rename.new)) {\n\t\t\t\treturn error(\"Could not set '%s'\", buf.buf);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * First remove symrefs, then rename the rest, finally create\n\t * the new symrefs.\n\t */\n\tfor_each_ref(read_remote_branches, &rename);\n\tfor (i = 0; i < remote_branches.nr; i++) {\n\t\tstruct string_list_item *item = remote_branches.items + i;\n\t\tint flag = 0;\n\t\tunsigned char sha1[20];\n\n\t\tresolve_ref(item->string, sha1, 1, &flag);\n\t\tif (!(flag & REF_ISSYMREF))\n\t\t\tcontinue;\n\t\tif (delete_ref(item->string, NULL, REF_NODEREF))\n\t\t\tdie(\"deleting '%s' failed\", item->string);\n\t}\n\tfor (i = 0; i < remote_branches.nr; i++) {\n\t\tstruct string_list_item *item = remote_branches.items + i;\n\n\t\tif (item->util)\n\t\t\tcontinue;\n\t\tstrbuf_reset(&buf);\n\t\tstrbuf_addstr(&buf, item->string);\n\t\tstrbuf_splice(&buf, strlen(\"refs/remotes/\"), strlen(rename.old),\n\t\t\t\trename.new, strlen(rename.new));\n\t\tstrbuf_reset(&buf2);\n\t\tstrbuf_addf(&buf2, \"remote: renamed %s to %s\",\n\t\t\t\titem->string, buf.buf);\n\t\tif (rename_ref(item->string, buf.buf, buf2.buf))\n\t\t\tdie(\"renaming '%s' failed\", item->string);\n\t}\n\tfor (i = 0; i < remote_branches.nr; i++) {\n\t\tstruct string_list_item *item = remote_branches.items + i;\n\n\t\tif (!item->util)\n\t\t\tcontinue;\n\t\tstrbuf_reset(&buf);\n\t\tstrbuf_addstr(&buf, item->string);\n\t\tstrbuf_splice(&buf, strlen(\"refs/remotes/\"), strlen(rename.old),\n\t\t\t\trename.new, strlen(rename.new));\n\t\tstrbuf_reset(&buf2);\n\t\tstrbuf_addstr(&buf2, item->util);\n\t\tstrbuf_splice(&buf2, strlen(\"refs/remotes/\"), strlen(rename.old),\n\t\t\t\trename.new, strlen(rename.new));\n\t\tstrbuf_reset(&buf3);\n\t\tstrbuf_addf(&buf3, \"remote: renamed %s to %s\",\n\t\t\t\titem->string, buf.buf);\n\t\tif (create_symref(buf.buf, buf2.buf, buf3.buf))\n\t\t\tdie(\"creating '%s' failed\", buf.buf);\n\t}\n\treturn 0;\n}\n\nstatic int remove_branches(struct string_list *branches)\n{\n\tint i, result = 0;\n\tfor (i = 0; i < branches->nr; i++) {\n\t\tstruct string_list_item *item = branches->items + i;\n\t\tconst char *refname = item->string;\n\t\tunsigned char *sha1 = item->util;\n\n\t\tif (delete_ref(refname, sha1, 0))\n\t\t\tresult |= error(\"Could not remove branch %s\", refname);\n\t}\n\treturn result;\n}\n\nstatic int rm(int argc, const char **argv)\n{\n\tstruct option options[] = {\n\t\tOPT_END()\n\t};\n\tstruct remote *remote;\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct known_remotes known_remotes = { NULL, NULL };\n\tstruct string_list branches = { NULL, 0, 0, 1 };\n\tstruct string_list skipped = { NULL, 0, 0, 1 };\n\tstruct branches_for_remote cb_data = {\n\t\tNULL, &branches, &skipped, &known_remotes\n\t};\n\tint i, result;\n\n\tif (argc != 2)\n\t\tusage_with_options(builtin_remote_usage, options);\n\n\tremote = remote_get(argv[1]);\n\tif (!remote)\n\t\tdie(\"No such remote: %s\", argv[1]);\n\n\tknown_remotes.to_delete = remote;\n\tfor_each_remote(add_known_remote, &known_remotes);\n\n\tstrbuf_addf(&buf, \"remote.%s\", remote->name);\n\tif (git_config_rename_section(buf.buf, NULL) < 1)\n\t\treturn error(\"Could not remove config section '%s'\", buf.buf);\n\n\tread_branches();\n\tfor (i = 0; i < branch_list.nr; i++) {\n\t\tstruct string_list_item *item = branch_list.items + i;\n\t\tstruct branch_info *info = item->util;\n\t\tif (info->remote_name && !strcmp(info->remote_name, remote->name)) {\n\t\t\tconst char *keys[] = { \"remote\", \"merge\", NULL }, **k;\n\t\t\tfor (k = keys; *k; k++) {\n\t\t\t\tstrbuf_reset(&buf);\n\t\t\t\tstrbuf_addf(&buf, \"branch.%s.%s\",\n\t\t\t\t\t\titem->string, *k);\n\t\t\t\tif (git_config_set(buf.buf, NULL)) {\n\t\t\t\t\tstrbuf_release(&buf);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We cannot just pass a function to for_each_ref() which deletes\n\t * the branches one by one, since for_each_ref() relies on cached\n\t * refs, which are invalidated when deleting a branch.\n\t */\n\tcb_data.remote = remote;\n\tresult = for_each_ref(add_branch_for_removal, &cb_data);\n\tstrbuf_release(&buf);\n\n\tif (!result)\n\t\tresult = remove_branches(&branches);\n\tstring_list_clear(&branches, 1);\n\n\tif (skipped.nr) {\n\t\tfprintf(stderr, skipped.nr == 1 ?\n\t\t\t\"Note: A non-remote branch was not removed; \"\n\t\t\t\"to delete it, use:\\n\" :\n\t\t\t\"Note: Non-remote branches were not removed; \"\n\t\t\t\"to delete them, use:\\n\");\n\t\tfor (i = 0; i < skipped.nr; i++)\n\t\t\tfprintf(stderr, \"  git branch -d %s\\n\",\n\t\t\t\tskipped.items[i].string);\n\t}\n\tstring_list_clear(&skipped, 0);\n\n\treturn result;\n}\n\nstatic void clear_push_info(void *util, const char *string)\n{\n\tstruct push_info *info = util;\n\tfree(info->dest);\n\tfree(info);\n}\n\nstatic void free_remote_ref_states(struct ref_states *states)\n{\n\tstring_list_clear(&states->new, 0);\n\tstring_list_clear(&states->stale, 0);\n\tstring_list_clear(&states->tracked, 0);\n\tstring_list_clear(&states->heads, 0);\n\tstring_list_clear_func(&states->push, clear_push_info);\n}\n\nstatic int append_ref_to_tracked_list(const char *refname,\n\tconst unsigned char *sha1, int flags, void *cb_data)\n{\n\tstruct ref_states *states = cb_data;\n\tstruct refspec refspec;\n\n\tif (flags & REF_ISSYMREF)\n\t\treturn 0;\n\n\tmemset(&refspec, 0, sizeof(refspec));\n\trefspec.dst = (char *)refname;\n\tif (!remote_find_tracking(states->remote, &refspec))\n\t\tstring_list_append(abbrev_branch(refspec.src), &states->tracked);\n\n\treturn 0;\n}\n\nstatic int get_remote_ref_states(const char *name,\n\t\t\t\t struct ref_states *states,\n\t\t\t\t int query)\n{\n\tstruct transport *transport;\n\tconst struct ref *remote_refs;\n\n\tstates->remote = remote_get(name);\n\tif (!states->remote)\n\t\treturn error(\"No such remote: %s\", name);\n\n\tread_branches();\n\n\tif (query) {\n\t\ttransport = transport_get(states->remote, states->remote->url_nr > 0 ?\n\t\t\tstates->remote->url[0] : NULL);\n\t\tremote_refs = transport_get_remote_refs(transport);\n\t\ttransport_disconnect(transport);\n\n\t\tstates->queried = 1;\n\t\tif (query & GET_REF_STATES)\n\t\t\tget_ref_states(remote_refs, states);\n\t\tif (query & GET_HEAD_NAMES)\n\t\t\tget_head_names(remote_refs, states);\n\t\tif (query & GET_PUSH_REF_STATES)\n\t\t\tget_push_ref_states(remote_refs, states);\n\t} else {\n\t\tfor_each_ref(append_ref_to_tracked_list, states);\n\t\tsort_string_list(&states->tracked);\n\t\tget_push_ref_states_noquery(states);\n\t}\n\n\treturn 0;\n}\n\nstruct show_info {\n\tstruct string_list *list;\n\tstruct ref_states *states;\n\tint width, width2;\n\tint any_rebase;\n};\n\nstatic int add_remote_to_show_info(struct string_list_item *item, void *cb_data)\n{\n\tstruct show_info *info = cb_data;\n\tint n = strlen(item->string);\n\tif (n > info->width)\n\t\tinfo->width = n;\n\tstring_list_insert(item->string, info->list);\n\treturn 0;\n}\n\nstatic int show_remote_info_item(struct string_list_item *item, void *cb_data)\n{\n\tstruct show_info *info = cb_data;\n\tstruct ref_states *states = info->states;\n\tconst char *name = item->string;\n\n\tif (states->queried) {\n\t\tconst char *fmt = \"%s\";\n\t\tconst char *arg = \"\";\n\t\tif (string_list_has_string(&states->new, name)) {\n\t\t\tfmt = \" new (next fetch will store in remotes/%s)\";\n\t\t\targ = states->remote->name;\n\t\t} else if (string_list_has_string(&states->tracked, name))\n\t\t\targ = \" tracked\";\n\t\telse if (string_list_has_string(&states->stale, name))\n\t\t\targ = \" stale (use 'git remote prune' to remove)\";\n\t\telse\n\t\t\targ = \" ???\";\n\t\tprintf(\"    %-*s\", info->width, name);\n\t\tprintf(fmt, arg);\n\t\tprintf(\"\\n\");\n\t} else\n\t\tprintf(\"    %s\\n\", name);\n\n\treturn 0;\n}\n\nstatic int add_local_to_show_info(struct string_list_item *branch_item, void *cb_data)\n{\n\tstruct show_info *show_info = cb_data;\n\tstruct ref_states *states = show_info->states;\n\tstruct branch_info *branch_info = branch_item->util;\n\tstruct string_list_item *item;\n\tint n;\n\n\tif (!branch_info->merge.nr || !branch_info->remote_name ||\n\t    strcmp(states->remote->name, branch_info->remote_name))\n\t\treturn 0;\n\tif ((n = strlen(branch_item->string)) > show_info->width)\n\t\tshow_info->width = n;\n\tif (branch_info->rebase)\n\t\tshow_info->any_rebase = 1;\n\n\titem = string_list_insert(branch_item->string, show_info->list);\n\titem->util = branch_info;\n\n\treturn 0;\n}\n\nstatic int show_local_info_item(struct string_list_item *item, void *cb_data)\n{\n\tstruct show_info *show_info = cb_data;\n\tstruct branch_info *branch_info = item->util;\n\tstruct string_list *merge = &branch_info->merge;\n\tconst char *also;\n\tint i;\n\n\tif (branch_info->rebase && branch_info->merge.nr > 1) {\n\t\terror(\"invalid branch.%s.merge; cannot rebase onto > 1 branch\",\n\t\t\titem->string);\n\t\treturn 0;\n\t}\n\n\tprintf(\"    %-*s \", show_info->width, item->string);\n\tif (branch_info->rebase) {\n\t\tprintf(\"rebases onto remote %s\\n\", merge->items[0].string);\n\t\treturn 0;\n\t} else if (show_info->any_rebase) {\n\t\tprintf(\" merges with remote %s\\n\", merge->items[0].string);\n\t\talso = \"    and with remote\";\n\t} else {\n\t\tprintf(\"merges with remote %s\\n\", merge->items[0].string);\n\t\talso = \"   and with remote\";\n\t}\n\tfor (i = 1; i < merge->nr; i++)\n\t\tprintf(\"    %-*s %s %s\\n\", show_info->width, \"\", also,\n\t\t       merge->items[i].string);\n\n\treturn 0;\n}\n\nstatic int add_push_to_show_info(struct string_list_item *push_item, void *cb_data)\n{\n\tstruct show_info *show_info = cb_data;\n\tstruct push_info *push_info = push_item->util;\n\tstruct string_list_item *item;\n\tint n;\n\tif ((n = strlen(push_item->string)) > show_info->width)\n\t\tshow_info->width = n;\n\tif ((n = strlen(push_info->dest)) > show_info->width2)\n\t\tshow_info->width2 = n;\n\titem = string_list_append(push_item->string, show_info->list);\n\titem->util = push_item->util;\n\treturn 0;\n}\n\n/*\n * Sorting comparison for a string list that has push_info\n * structs in its util field\n */\nstatic int cmp_string_with_push(const void *va, const void *vb)\n{\n\tconst struct string_list_item *a = va;\n\tconst struct string_list_item *b = vb;\n\tconst struct push_info *a_push = a->util;\n\tconst struct push_info *b_push = b->util;\n\tint cmp = strcmp(a->string, b->string);\n\treturn cmp ? cmp : strcmp(a_push->dest, b_push->dest);\n}\n\nstatic int show_push_info_item(struct string_list_item *item, void *cb_data)\n{\n\tstruct show_info *show_info = cb_data;\n\tstruct push_info *push_info = item->util;\n\tchar *src = item->string, *status = NULL;\n\n\tswitch (push_info->status) {\n\tcase PUSH_STATUS_CREATE:\n\t\tstatus = \"create\";\n\t\tbreak;\n\tcase PUSH_STATUS_DELETE:\n\t\tstatus = \"delete\";\n\t\tsrc = \"(none)\";\n\t\tbreak;\n\tcase PUSH_STATUS_UPTODATE:\n\t\tstatus = \"up to date\";\n\t\tbreak;\n\tcase PUSH_STATUS_FASTFORWARD:\n\t\tstatus = \"fast forwardable\";\n\t\tbreak;\n\tcase PUSH_STATUS_OUTOFDATE:\n\t\tstatus = \"local out of date\";\n\t\tbreak;\n\tcase PUSH_STATUS_NOTQUERIED:\n\t\tbreak;\n\t}\n\tif (status)\n\t\tprintf(\"    %-*s %s to %-*s (%s)\\n\", show_info->width, src,\n\t\t\tpush_info->forced ? \"forces\" : \"pushes\",\n\t\t\tshow_info->width2, push_info->dest, status);\n\telse\n\t\tprintf(\"    %-*s %s to %s\\n\", show_info->width, src,\n\t\t\tpush_info->forced ? \"forces\" : \"pushes\",\n\t\t\tpush_info->dest);\n\treturn 0;\n}\n\nstatic int show(int argc, const char **argv)\n{\n\tint no_query = 0, result = 0, query_flag = 0;\n\tstruct option options[] = {\n\t\tOPT_GROUP(\"show specific options\"),\n\t\tOPT_BOOLEAN('n', NULL, &no_query, \"do not query remotes\"),\n\t\tOPT_END()\n\t};\n\tstruct ref_states states;\n\tstruct string_list info_list = { NULL, 0, 0, 0 };\n\tstruct show_info info;\n\n\targc = parse_options(argc, argv, NULL, options, builtin_remote_usage,\n\t\t\t     0);\n\n\tif (argc < 1)\n\t\treturn show_all();\n\n\tif (!no_query)\n\t\tquery_flag = (GET_REF_STATES | GET_HEAD_NAMES | GET_PUSH_REF_STATES);\n\n\tmemset(&states, 0, sizeof(states));\n\tmemset(&info, 0, sizeof(info));\n\tinfo.states = &states;\n\tinfo.list = &info_list;\n\tfor (; argc; argc--, argv++) {\n\t\tint i;\n\t\tconst char **url;\n\t\tint url_nr;\n\n\t\tget_remote_ref_states(*argv, &states, query_flag);\n\n\t\tprintf(\"* remote %s\\n\", *argv);\n\t\tprintf(\"  Fetch URL: %s\\n\", states.remote->url_nr > 0 ?\n\t\t\tstates.remote->url[0] : \"(no URL)\");\n\t\tif (states.remote->pushurl_nr) {\n\t\t\turl = states.remote->pushurl;\n\t\t\turl_nr = states.remote->pushurl_nr;\n\t\t} else {\n\t\t\turl = states.remote->url;\n\t\t\turl_nr = states.remote->url_nr;\n\t\t}\n\t\tfor (i=0; i < url_nr; i++)\n\t\t\tprintf(\"  Push  URL: %s\\n\", url[i]);\n\t\tif (!i)\n\t\t\tprintf(\"  Push  URL: %s\\n\", \"(no URL)\");\n\t\tif (no_query)\n\t\t\tprintf(\"  HEAD branch: (not queried)\\n\");\n\t\telse if (!states.heads.nr)\n\t\t\tprintf(\"  HEAD branch: (unknown)\\n\");\n\t\telse if (states.heads.nr == 1)\n\t\t\tprintf(\"  HEAD branch: %s\\n\", states.heads.items[0].string);\n\t\telse {\n\t\t\tprintf(\"  HEAD branch (remote HEAD is ambiguous,\"\n\t\t\t       \" may be one of the following):\\n\");\n\t\t\tfor (i = 0; i < states.heads.nr; i++)\n\t\t\t\tprintf(\"    %s\\n\", states.heads.items[i].string);\n\t\t}\n\n\t\t/* remote branch info */\n\t\tinfo.width = 0;\n\t\tfor_each_string_list(add_remote_to_show_info, &states.new, &info);\n\t\tfor_each_string_list(add_remote_to_show_info, &states.tracked, &info);\n\t\tfor_each_string_list(add_remote_to_show_info, &states.stale, &info);\n\t\tif (info.list->nr)\n\t\t\tprintf(\"  Remote branch%s:%s\\n\",\n\t\t\t       info.list->nr > 1 ? \"es\" : \"\",\n\t\t\t\tno_query ? \" (status not queried)\" : \"\");\n\t\tfor_each_string_list(show_remote_info_item, info.list, &info);\n\t\tstring_list_clear(info.list, 0);\n\n\t\t/* git pull info */\n\t\tinfo.width = 0;\n\t\tinfo.any_rebase = 0;\n\t\tfor_each_string_list(add_local_to_show_info, &branch_list, &info);\n\t\tif (info.list->nr)\n\t\t\tprintf(\"  Local branch%s configured for 'git pull':\\n\",\n\t\t\t       info.list->nr > 1 ? \"es\" : \"\");\n\t\tfor_each_string_list(show_local_info_item, info.list, &info);\n\t\tstring_list_clear(info.list, 0);\n\n\t\t/* git push info */\n\t\tif (states.remote->mirror)\n\t\t\tprintf(\"  Local refs will be mirrored by 'git push'\\n\");\n\n\t\tinfo.width = info.width2 = 0;\n\t\tfor_each_string_list(add_push_to_show_info, &states.push, &info);\n\t\tqsort(info.list->items, info.list->nr,\n\t\t\tsizeof(*info.list->items), cmp_string_with_push);\n\t\tif (info.list->nr)\n\t\t\tprintf(\"  Local ref%s configured for 'git push'%s:\\n\",\n\t\t\t\tinfo.list->nr > 1 ? \"s\" : \"\",\n\t\t\t\tno_query ? \" (status not queried)\" : \"\");\n\t\tfor_each_string_list(show_push_info_item, info.list, &info);\n\t\tstring_list_clear(info.list, 0);\n\n\t\tfree_remote_ref_states(&states);\n\t}\n\n\treturn result;\n}\n\nstatic int set_head(int argc, const char **argv)\n{\n\tint i, opt_a = 0, opt_d = 0, result = 0;\n\tstruct strbuf buf = STRBUF_INIT, buf2 = STRBUF_INIT;\n\tchar *head_name = NULL;\n\n\tstruct option options[] = {\n\t\tOPT_GROUP(\"set-head specific options\"),\n\t\tOPT_BOOLEAN('a', \"auto\", &opt_a,\n\t\t\t    \"set refs/remotes/<name>/HEAD according to remote\"),\n\t\tOPT_BOOLEAN('d', \"delete\", &opt_d,\n\t\t\t    \"delete refs/remotes/<name>/HEAD\"),\n\t\tOPT_END()\n\t};\n\targc = parse_options(argc, argv, NULL, options, builtin_remote_usage,\n\t\t\t     0);\n\tif (argc)\n\t\tstrbuf_addf(&buf, \"refs/remotes/%s/HEAD\", argv[0]);\n\n\tif (!opt_a && !opt_d && argc == 2) {\n\t\thead_name = xstrdup(argv[1]);\n\t} else if (opt_a && !opt_d && argc == 1) {\n\t\tstruct ref_states states;\n\t\tmemset(&states, 0, sizeof(states));\n\t\tget_remote_ref_states(argv[0], &states, GET_HEAD_NAMES);\n\t\tif (!states.heads.nr)\n\t\t\tresult |= error(\"Cannot determine remote HEAD\");\n\t\telse if (states.heads.nr > 1) {\n\t\t\tresult |= error(\"Multiple remote HEAD branches. \"\n\t\t\t\t\t\"Please choose one explicitly with:\");\n\t\t\tfor (i = 0; i < states.heads.nr; i++)\n\t\t\t\tfprintf(stderr, \"  git remote set-head %s %s\\n\",\n\t\t\t\t\targv[0], states.heads.items[i].string);\n\t\t} else\n\t\t\thead_name = xstrdup(states.heads.items[0].string);\n\t\tfree_remote_ref_states(&states);\n\t} else if (opt_d && !opt_a && argc == 1) {\n\t\tif (delete_ref(buf.buf, NULL, REF_NODEREF))\n\t\t\tresult |= error(\"Could not delete %s\", buf.buf);\n\t} else\n\t\tusage_with_options(builtin_remote_usage, options);\n\n\tif (head_name) {\n\t\tunsigned char sha1[20];\n\t\tstrbuf_addf(&buf2, \"refs/remotes/%s/%s\", argv[0], head_name);\n\t\t/* make sure it's valid */\n\t\tif (!resolve_ref(buf2.buf, sha1, 1, NULL))\n\t\t\tresult |= error(\"Not a valid ref: %s\", buf2.buf);\n\t\telse if (create_symref(buf.buf, buf2.buf, \"remote set-head\"))\n\t\t\tresult |= error(\"Could not setup %s\", buf.buf);\n\t\tif (opt_a)\n\t\t\tprintf(\"%s/HEAD set to %s\\n\", argv[0], head_name);\n\t\tfree(head_name);\n\t}\n\n\tstrbuf_release(&buf);\n\tstrbuf_release(&buf2);\n\treturn result;\n}\n\nstatic int prune(int argc, const char **argv)\n{\n\tint dry_run = 0, result = 0;\n\tstruct option options[] = {\n\t\tOPT_GROUP(\"prune specific options\"),\n\t\tOPT__DRY_RUN(&dry_run),\n\t\tOPT_END()\n\t};\n\n\targc = parse_options(argc, argv, NULL, options, builtin_remote_usage,\n\t\t\t     0);\n\n\tif (argc < 1)\n\t\tusage_with_options(builtin_remote_usage, options);\n\n\tfor (; argc; argc--, argv++)\n\t\tresult |= prune_remote(*argv, dry_run);\n\n\treturn result;\n}\n\nstatic int prune_remote(const char *remote, int dry_run)\n{\n\tint result = 0, i;\n\tstruct ref_states states;\n\tconst char *dangling_msg = dry_run\n\t\t? \" %s will become dangling!\\n\"\n\t\t: \" %s has become dangling!\\n\";\n\n\tmemset(&states, 0, sizeof(states));\n\tget_remote_ref_states(remote, &states, GET_REF_STATES);\n\n\tif (states.stale.nr) {\n\t\tprintf(\"Pruning %s\\n\", remote);\n\t\tprintf(\"URL: %s\\n\",\n\t\t       states.remote->url_nr\n\t\t       ? states.remote->url[0]\n\t\t       : \"(no URL)\");\n\t}\n\n\tfor (i = 0; i < states.stale.nr; i++) {\n\t\tconst char *refname = states.stale.items[i].util;\n\n\t\tif (!dry_run)\n\t\t\tresult |= delete_ref(refname, NULL, 0);\n\n\t\tprintf(\" * [%s] %s\\n\", dry_run ? \"would prune\" : \"pruned\",\n\t\t       abbrev_ref(refname, \"refs/remotes/\"));\n\t\twarn_dangling_symref(dangling_msg, refname);\n\t}\n\n\tfree_remote_ref_states(&states);\n\treturn result;\n}\n\nstatic int get_one_remote_for_update(struct remote *remote, void *priv)\n{\n\tstruct string_list *list = priv;\n\tif (!remote->skip_default_update)\n\t\tstring_list_append(remote->name, list);\n\treturn 0;\n}\n\nstatic struct remote_group {\n\tconst char *name;\n\tstruct string_list *list;\n} remote_group;\n\nstatic int get_remote_group(const char *key, const char *value, void *num_hits)\n{\n\tif (!prefixcmp(key, \"remotes.\") &&\n\t\t\t!strcmp(key + 8, remote_group.name)) {\n\t\t/* split list by white space */\n\t\tint space = strcspn(value, \" \\t\\n\");\n\t\twhile (*value) {\n\t\t\tif (space > 1) {\n\t\t\t\tstring_list_append(xstrndup(value, space),\n\t\t\t\t\t\tremote_group.list);\n\t\t\t\t++*((int *)num_hits);\n\t\t\t}\n\t\t\tvalue += space + (value[space] != '\\0');\n\t\t\tspace = strcspn(value, \" \\t\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int update(int argc, const char **argv)\n{\n\tint i, result = 0, prune = 0;\n\tstruct string_list list = { NULL, 0, 0, 0 };\n\tstatic const char *default_argv[] = { NULL, \"default\", NULL };\n\tstruct option options[] = {\n\t\tOPT_GROUP(\"update specific options\"),\n\t\tOPT_BOOLEAN('p', \"prune\", &prune,\n\t\t\t    \"prune remotes after fetching\"),\n\t\tOPT_END()\n\t};\n\n\targc = parse_options(argc, argv, NULL, options, builtin_remote_usage,\n\t\t\t     PARSE_OPT_KEEP_ARGV0);\n\tif (argc < 2) {\n\t\targc = 2;\n\t\targv = default_argv;\n\t}\n\n\tremote_group.list = &list;\n\tfor (i = 1; i < argc; i++) {\n\t\tint groups_found = 0;\n\t\tremote_group.name = argv[i];\n\t\tresult = git_config(get_remote_group, &groups_found);\n\t\tif (!groups_found && (i != 1 || strcmp(argv[1], \"default\"))) {\n\t\t\tstruct remote *remote;\n\t\t\tif (!remote_is_configured(argv[i]))\n\t\t\t\tdie(\"No such remote or remote group: %s\",\n\t\t\t\t    argv[i]);\n\t\t\tremote = remote_get(argv[i]);\n\t\t\tstring_list_append(remote->name, remote_group.list);\n\t\t}\n\t}\n\n\tif (!result && !list.nr  && argc == 2 && !strcmp(argv[1], \"default\"))\n\t\tresult = for_each_remote(get_one_remote_for_update, &list);\n\n\tfor (i = 0; i < list.nr; i++) {\n\t\tint err = fetch_remote(list.items[i].string);\n\t\tresult |= err;\n\t\tif (!err && prune)\n\t\t\tresult |= prune_remote(list.items[i].string, 0);\n\t}\n\n\t/* all names were strdup()ed or strndup()ed */\n\tlist.strdup_strings = 1;\n\tstring_list_clear(&list, 0);\n\n\treturn result;\n}\n\nstatic int get_one_entry(struct remote *remote, void *priv)\n{\n\tstruct string_list *list = priv;\n\tstruct strbuf url_buf = STRBUF_INIT;\n\tconst char **url;\n\tint i, url_nr;\n\n\tif (remote->url_nr > 0) {\n\t\tstrbuf_addf(&url_buf, \"%s (fetch)\", remote->url[0]);\n\t\tstring_list_append(remote->name, list)->util =\n\t\t\t\tstrbuf_detach(&url_buf, NULL);\n\t} else\n\t\tstring_list_append(remote->name, list)->util = NULL;\n\tif (remote->pushurl_nr) {\n\t\turl = remote->pushurl;\n\t\turl_nr = remote->pushurl_nr;\n\t} else {\n\t\turl = remote->url;\n\t\turl_nr = remote->url_nr;\n\t}\n\tfor (i = 0; i < url_nr; i++)\n\t{\n\t\tstrbuf_addf(&url_buf, \"%s (push)\", url[i]);\n\t\tstring_list_append(remote->name, list)->util =\n\t\t\t\tstrbuf_detach(&url_buf, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic int show_all(void)\n{\n\tstruct string_list list = { NULL, 0, 0 };\n\tint result;\n\n\tlist.strdup_strings = 1;\n\tresult = for_each_remote(get_one_entry, &list);\n\n\tif (!result) {\n\t\tint i;\n\n\t\tsort_string_list(&list);\n\t\tfor (i = 0; i < list.nr; i++) {\n\t\t\tstruct string_list_item *item = list.items + i;\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"%s\\t%s\\n\", item->string,\n\t\t\t\t\titem->util ? (const char *)item->util : \"\");\n\t\t\telse {\n\t\t\t\tif (i && !strcmp((item - 1)->string, item->string))\n\t\t\t\t\tcontinue;\n\t\t\t\tprintf(\"%s\\n\", item->string);\n\t\t\t}\n\t\t}\n\t}\n\tstring_list_clear(&list, 1);\n\treturn result;\n}\n\nint cmd_remote(int argc, const char **argv, const char *prefix)\n{\n\tstruct option options[] = {\n\t\tOPT__VERBOSE(&verbose),\n\t\tOPT_END()\n\t};\n\tint result;\n\n\targc = parse_options(argc, argv, prefix, options, builtin_remote_usage,\n\t\tPARSE_OPT_STOP_AT_NON_OPTION);\n\n\tif (argc < 1)\n\t\tresult = show_all();\n\telse if (!strcmp(argv[0], \"add\"))\n\t\tresult = add(argc, argv);\n\telse if (!strcmp(argv[0], \"rename\"))\n\t\tresult = mv(argc, argv);\n\telse if (!strcmp(argv[0], \"rm\"))\n\t\tresult = rm(argc, argv);\n\telse if (!strcmp(argv[0], \"set-head\"))\n\t\tresult = set_head(argc, argv);\n\telse if (!strcmp(argv[0], \"show\"))\n\t\tresult = show(argc, argv);\n\telse if (!strcmp(argv[0], \"prune\"))\n\t\tresult = prune(argc, argv);\n\telse if (!strcmp(argv[0], \"update\"))\n\t\tresult = update(argc, argv);\n\telse {\n\t\terror(\"Unknown subcommand: %s\", argv[0]);\n\t\tusage_with_options(builtin_remote_usage, options);\n\t}\n\n\treturn result ? 1 : 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "008abfe0922f6d1662aebcfbf63ba9f47de4ae65",
  "sha1_ok": true,
  "size": 37522
}
