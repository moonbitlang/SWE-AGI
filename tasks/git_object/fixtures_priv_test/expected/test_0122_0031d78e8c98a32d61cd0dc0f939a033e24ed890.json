{
  "content": {
    "base64": "LyoKICogbmFtZS1oYXNoLmMKICoKICogSGFzaGluZyBuYW1lcyBpbiB0aGUgaW5kZXggc3RhdGUKICoKICogQ29weXJpZ2h0IChDKSAyMDA4IExpbnVzIFRvcnZhbGRzCiAqLwojZGVmaW5lIE5PX1RIRV9JTkRFWF9DT01QQVRJQklMSVRZX01BQ1JPUwojaW5jbHVkZSAiY2FjaGUuaCIKCi8qCiAqIFRoaXMgcmVtb3ZlcyBiaXQgNSBpZiBiaXQgNiBpcyBzZXQuCiAqCiAqIFRoYXQgd2lsbCBtYWtlIFVTLUFTQ0lJIGNoYXJhY3RlcnMgaGFzaCB0byB0aGVpciB1cHBlci1jYXNlCiAqIGVxdWl2YWxlbnQuIFdlIGNvdWxkIGVhc2lseSBkbyB0aGlzIG9uZSB3aG9sZSB3b3JkIGF0IGEgdGltZSwKICogYnV0IHRoYXQncyBmb3IgZnV0dXJlIHdvcnJpZXMuCiAqLwpzdGF0aWMgaW5saW5lIHVuc2lnbmVkIGNoYXIgaWNhc2VfaGFzaCh1bnNpZ25lZCBjaGFyIGMpCnsKCXJldHVybiBjICYgfigoYyAmIDB4NDApID4+IDEpOwp9CgpzdGF0aWMgdW5zaWduZWQgaW50IGhhc2hfbmFtZShjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbikKewoJdW5zaWduZWQgaW50IGhhc2ggPSAweDEyMzsKCglkbyB7CgkJdW5zaWduZWQgY2hhciBjID0gKm5hbWUrKzsKCQljID0gaWNhc2VfaGFzaChjKTsKCQloYXNoID0gaGFzaCoxMDEgKyBjOwoJfSB3aGlsZSAoLS1uYW1lbGVuKTsKCXJldHVybiBoYXNoOwp9CgpzdGF0aWMgdm9pZCBoYXNoX2luZGV4X2VudHJ5KHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKQp7Cgl2b2lkICoqcG9zOwoJdW5zaWduZWQgaW50IGhhc2g7CgoJaWYgKGNlLT5jZV9mbGFncyAmIENFX0hBU0hFRCkKCQlyZXR1cm47CgljZS0+Y2VfZmxhZ3MgfD0gQ0VfSEFTSEVEOwoJY2UtPm5leHQgPSBOVUxMOwoJaGFzaCA9IGhhc2hfbmFtZShjZS0+bmFtZSwgY2VfbmFtZWxlbihjZSkpOwoJcG9zID0gaW5zZXJ0X2hhc2goaGFzaCwgY2UsICZpc3RhdGUtPm5hbWVfaGFzaCk7CglpZiAocG9zKSB7CgkJY2UtPm5leHQgPSAqcG9zOwoJCSpwb3MgPSBjZTsKCX0KfQoKc3RhdGljIHZvaWQgbGF6eV9pbml0X25hbWVfaGFzaChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSkKewoJaW50IG5yOwoKCWlmIChpc3RhdGUtPm5hbWVfaGFzaF9pbml0aWFsaXplZCkKCQlyZXR1cm47Cglmb3IgKG5yID0gMDsgbnIgPCBpc3RhdGUtPmNhY2hlX25yOyBucisrKQoJCWhhc2hfaW5kZXhfZW50cnkoaXN0YXRlLCBpc3RhdGUtPmNhY2hlW25yXSk7Cglpc3RhdGUtPm5hbWVfaGFzaF9pbml0aWFsaXplZCA9IDE7Cn0KCnZvaWQgYWRkX25hbWVfaGFzaChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSkKewoJY2UtPmNlX2ZsYWdzICY9IH5DRV9VTkhBU0hFRDsKCWlmIChpc3RhdGUtPm5hbWVfaGFzaF9pbml0aWFsaXplZCkKCQloYXNoX2luZGV4X2VudHJ5KGlzdGF0ZSwgY2UpOwp9CgpzdGF0aWMgaW50IHNsb3dfc2FtZV9uYW1lKGNvbnN0IGNoYXIgKm5hbWUxLCBpbnQgbGVuMSwgY29uc3QgY2hhciAqbmFtZTIsIGludCBsZW4yKQp7CglpZiAobGVuMSAhPSBsZW4yKQoJCXJldHVybiAwOwoKCXdoaWxlIChsZW4xKSB7CgkJdW5zaWduZWQgY2hhciBjMSA9ICpuYW1lMSsrOwoJCXVuc2lnbmVkIGNoYXIgYzIgPSAqbmFtZTIrKzsKCQlsZW4xLS07CgkJaWYgKGMxICE9IGMyKSB7CgkJCWMxID0gdG91cHBlcihjMSk7CgkJCWMyID0gdG91cHBlcihjMik7CgkJCWlmIChjMSAhPSBjMikKCQkJCXJldHVybiAwOwoJCX0KCX0KCXJldHVybiAxOwp9CgpzdGF0aWMgaW50IHNhbWVfbmFtZShjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbiwgaW50IGljYXNlKQp7CglpbnQgbGVuID0gY2VfbmFtZWxlbihjZSk7CgoJLyoKCSAqIEFsd2F5cyBkbyBleGFjdCBjb21wYXJlLCBldmVuIGlmIHdlIHdhbnQgYSBjYXNlLWlnbm9yaW5nIGNvbXBhcmlzb247CgkgKiB3ZSBkbyB0aGUgcXVpY2sgZXhhY3Qgb25lIGZpcnN0LCBiZWNhdXNlIGl0IHdpbGwgYmUgdGhlIGNvbW1vbiBjYXNlLgoJICovCglpZiAobGVuID09IG5hbWVsZW4gJiYgIWNhY2hlX25hbWVfY29tcGFyZShuYW1lLCBuYW1lbGVuLCBjZS0+bmFtZSwgbGVuKSkKCQlyZXR1cm4gMTsKCglyZXR1cm4gaWNhc2UgJiYgc2xvd19zYW1lX25hbWUobmFtZSwgbmFtZWxlbiwgY2UtPm5hbWUsIGxlbik7Cn0KCnN0cnVjdCBjYWNoZV9lbnRyeSAqaW5kZXhfbmFtZV9leGlzdHMoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIGNvbnN0IGNoYXIgKm5hbWUsIGludCBuYW1lbGVuLCBpbnQgaWNhc2UpCnsKCXVuc2lnbmVkIGludCBoYXNoID0gaGFzaF9uYW1lKG5hbWUsIG5hbWVsZW4pOwoJc3RydWN0IGNhY2hlX2VudHJ5ICpjZTsKCglsYXp5X2luaXRfbmFtZV9oYXNoKGlzdGF0ZSk7CgljZSA9IGxvb2t1cF9oYXNoKGhhc2gsICZpc3RhdGUtPm5hbWVfaGFzaCk7CgoJd2hpbGUgKGNlKSB7CgkJaWYgKCEoY2UtPmNlX2ZsYWdzICYgQ0VfVU5IQVNIRUQpKSB7CgkJCWlmIChzYW1lX25hbWUoY2UsIG5hbWUsIG5hbWVsZW4sIGljYXNlKSkKCQkJCXJldHVybiBjZTsKCQl9CgkJY2UgPSBjZS0+bmV4dDsKCX0KCXJldHVybiBOVUxMOwp9Cg==",
    "text": "/*\n * name-hash.c\n *\n * Hashing names in the index state\n *\n * Copyright (C) 2008 Linus Torvalds\n */\n#define NO_THE_INDEX_COMPATIBILITY_MACROS\n#include \"cache.h\"\n\n/*\n * This removes bit 5 if bit 6 is set.\n *\n * That will make US-ASCII characters hash to their upper-case\n * equivalent. We could easily do this one whole word at a time,\n * but that's for future worries.\n */\nstatic inline unsigned char icase_hash(unsigned char c)\n{\n\treturn c & ~((c & 0x40) >> 1);\n}\n\nstatic unsigned int hash_name(const char *name, int namelen)\n{\n\tunsigned int hash = 0x123;\n\n\tdo {\n\t\tunsigned char c = *name++;\n\t\tc = icase_hash(c);\n\t\thash = hash*101 + c;\n\t} while (--namelen);\n\treturn hash;\n}\n\nstatic void hash_index_entry(struct index_state *istate, struct cache_entry *ce)\n{\n\tvoid **pos;\n\tunsigned int hash;\n\n\tif (ce->ce_flags & CE_HASHED)\n\t\treturn;\n\tce->ce_flags |= CE_HASHED;\n\tce->next = NULL;\n\thash = hash_name(ce->name, ce_namelen(ce));\n\tpos = insert_hash(hash, ce, &istate->name_hash);\n\tif (pos) {\n\t\tce->next = *pos;\n\t\t*pos = ce;\n\t}\n}\n\nstatic void lazy_init_name_hash(struct index_state *istate)\n{\n\tint nr;\n\n\tif (istate->name_hash_initialized)\n\t\treturn;\n\tfor (nr = 0; nr < istate->cache_nr; nr++)\n\t\thash_index_entry(istate, istate->cache[nr]);\n\tistate->name_hash_initialized = 1;\n}\n\nvoid add_name_hash(struct index_state *istate, struct cache_entry *ce)\n{\n\tce->ce_flags &= ~CE_UNHASHED;\n\tif (istate->name_hash_initialized)\n\t\thash_index_entry(istate, ce);\n}\n\nstatic int slow_same_name(const char *name1, int len1, const char *name2, int len2)\n{\n\tif (len1 != len2)\n\t\treturn 0;\n\n\twhile (len1) {\n\t\tunsigned char c1 = *name1++;\n\t\tunsigned char c2 = *name2++;\n\t\tlen1--;\n\t\tif (c1 != c2) {\n\t\t\tc1 = toupper(c1);\n\t\t\tc2 = toupper(c2);\n\t\t\tif (c1 != c2)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int same_name(const struct cache_entry *ce, const char *name, int namelen, int icase)\n{\n\tint len = ce_namelen(ce);\n\n\t/*\n\t * Always do exact compare, even if we want a case-ignoring comparison;\n\t * we do the quick exact one first, because it will be the common case.\n\t */\n\tif (len == namelen && !cache_name_compare(name, namelen, ce->name, len))\n\t\treturn 1;\n\n\treturn icase && slow_same_name(name, namelen, ce->name, len);\n}\n\nstruct cache_entry *index_name_exists(struct index_state *istate, const char *name, int namelen, int icase)\n{\n\tunsigned int hash = hash_name(name, namelen);\n\tstruct cache_entry *ce;\n\n\tlazy_init_name_hash(istate);\n\tce = lookup_hash(hash, &istate->name_hash);\n\n\twhile (ce) {\n\t\tif (!(ce->ce_flags & CE_UNHASHED)) {\n\t\t\tif (same_name(ce, name, namelen, icase))\n\t\t\t\treturn ce;\n\t\t}\n\t\tce = ce->next;\n\t}\n\treturn NULL;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0031d78e8c98a32d61cd0dc0f939a033e24ed890",
  "sha1_ok": true,
  "size": 2608
}
