{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJvYmplY3Qtc3RvcmUuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAiYmxvYi5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAiZGlmZmNvcmUuaCIKI2luY2x1ZGUgInF1b3RlLmgiCiNpbmNsdWRlICJ4ZGlmZi1pbnRlcmZhY2UuaCIKI2luY2x1ZGUgInhkaWZmL3htYWNyb3MuaCIKI2luY2x1ZGUgImxvZy10cmVlLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJ1c2VyZGlmZi5oIgojaW5jbHVkZSAib2lkLWFycmF5LmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgoKc3RhdGljIGludCBjb21wYXJlX3BhdGhzKGNvbnN0IHN0cnVjdCBjb21iaW5lX2RpZmZfcGF0aCAqb25lLAoJCQkgIGNvbnN0IHN0cnVjdCBkaWZmX2ZpbGVzcGVjICp0d28pCnsKCWlmICghU19JU0RJUihvbmUtPm1vZGUpICYmICFTX0lTRElSKHR3by0+bW9kZSkpCgkJcmV0dXJuIHN0cmNtcChvbmUtPnBhdGgsIHR3by0+cGF0aCk7CgoJcmV0dXJuIGJhc2VfbmFtZV9jb21wYXJlKG9uZS0+cGF0aCwgc3RybGVuKG9uZS0+cGF0aCksIG9uZS0+bW9kZSwKCQkJCSB0d28tPnBhdGgsIHN0cmxlbih0d28tPnBhdGgpLCB0d28tPm1vZGUpOwp9CgpzdGF0aWMgaW50IGZpbGVuYW1lX2NoYW5nZWQoY2hhciBzdGF0dXMpCnsKCXJldHVybiBzdGF0dXMgPT0gJ1InIHx8IHN0YXR1cyA9PSAnQyc7Cn0KCnN0YXRpYyBzdHJ1Y3QgY29tYmluZV9kaWZmX3BhdGggKmludGVyc2VjdF9wYXRocygKCXN0cnVjdCBjb21iaW5lX2RpZmZfcGF0aCAqY3VyciwKCWludCBuLAoJaW50IG51bV9wYXJlbnQsCglpbnQgY29tYmluZWRfYWxsX3BhdGhzKQp7CglzdHJ1Y3QgZGlmZl9xdWV1ZV9zdHJ1Y3QgKnEgPSAmZGlmZl9xdWV1ZWRfZGlmZjsKCXN0cnVjdCBjb21iaW5lX2RpZmZfcGF0aCAqcCwgKip0YWlsID0gJmN1cnI7CglpbnQgaSwgaiwgY21wOwoKCWlmICghbikgewoJCWZvciAoaSA9IDA7IGkgPCBxLT5ucjsgaSsrKSB7CgkJCWludCBsZW47CgkJCWNvbnN0IGNoYXIgKnBhdGg7CgkJCWlmIChkaWZmX3VubW9kaWZpZWRfcGFpcihxLT5xdWV1ZVtpXSkpCgkJCQljb250aW51ZTsKCQkJcGF0aCA9IHEtPnF1ZXVlW2ldLT50d28tPnBhdGg7CgkJCWxlbiA9IHN0cmxlbihwYXRoKTsKCQkJcCA9IHhtYWxsb2MoY29tYmluZV9kaWZmX3BhdGhfc2l6ZShudW1fcGFyZW50LCBsZW4pKTsKCQkJcC0+cGF0aCA9IChjaGFyICopICYocC0+cGFyZW50W251bV9wYXJlbnRdKTsKCQkJbWVtY3B5KHAtPnBhdGgsIHBhdGgsIGxlbik7CgkJCXAtPnBhdGhbbGVuXSA9IDA7CgkJCXAtPm5leHQgPSBOVUxMOwoJCQltZW1zZXQocC0+cGFyZW50LCAwLAoJCQkgICAgICAgc2l6ZW9mKHAtPnBhcmVudFswXSkgKiBudW1fcGFyZW50KTsKCgkJCW9pZGNweSgmcC0+b2lkLCAmcS0+cXVldWVbaV0tPnR3by0+b2lkKTsKCQkJcC0+bW9kZSA9IHEtPnF1ZXVlW2ldLT50d28tPm1vZGU7CgkJCW9pZGNweSgmcC0+cGFyZW50W25dLm9pZCwgJnEtPnF1ZXVlW2ldLT5vbmUtPm9pZCk7CgkJCXAtPnBhcmVudFtuXS5tb2RlID0gcS0+cXVldWVbaV0tPm9uZS0+bW9kZTsKCQkJcC0+cGFyZW50W25dLnN0YXR1cyA9IHEtPnF1ZXVlW2ldLT5zdGF0dXM7CgoJCQlpZiAoY29tYmluZWRfYWxsX3BhdGhzICYmCgkJCSAgICBmaWxlbmFtZV9jaGFuZ2VkKHAtPnBhcmVudFtuXS5zdGF0dXMpKSB7CgkJCQlzdHJidWZfaW5pdCgmcC0+cGFyZW50W25dLnBhdGgsIDApOwoJCQkJc3RyYnVmX2FkZHN0cigmcC0+cGFyZW50W25dLnBhdGgsCgkJCQkJICAgICAgcS0+cXVldWVbaV0tPm9uZS0+cGF0aCk7CgkJCX0KCQkJKnRhaWwgPSBwOwoJCQl0YWlsID0gJnAtPm5leHQ7CgkJfQoJCXJldHVybiBjdXJyOwoJfQoKCS8qCgkgKiBwYXRocyBpbiBjdXJyIChsaW5rZWQgbGlzdCkgYW5kIHEtPnF1ZXVlW10gKGFycmF5KSBhcmUKCSAqIGJvdGggc29ydGVkIGluIHRoZSB0cmVlIG9yZGVyLgoJICovCglpID0gMDsKCXdoaWxlICgocCA9ICp0YWlsKSAhPSBOVUxMKSB7CgkJY21wID0gKChpID49IHEtPm5yKQoJCSAgICAgICA/IC0xIDogY29tcGFyZV9wYXRocyhwLCBxLT5xdWV1ZVtpXS0+dHdvKSk7CgoJCWlmIChjbXAgPCAwKSB7CgkJCS8qIHAtPnBhdGggbm90IGluIHEtPnF1ZXVlW107IGRyb3AgaXQgKi8KCQkJKnRhaWwgPSBwLT5uZXh0OwoJCQlmb3IgKGogPSAwOyBqIDwgbnVtX3BhcmVudDsgaisrKQoJCQkJaWYgKGNvbWJpbmVkX2FsbF9wYXRocyAmJgoJCQkJICAgIGZpbGVuYW1lX2NoYW5nZWQocC0+cGFyZW50W2pdLnN0YXR1cykpCgkJCQkJc3RyYnVmX3JlbGVhc2UoJnAtPnBhcmVudFtqXS5wYXRoKTsKCQkJZnJlZShwKTsKCQkJY29udGludWU7CgkJfQoKCQlpZiAoY21wID4gMCkgewoJCQkvKiBxLT5xdWV1ZVtpXSBub3QgaW4gcC0+cGF0aDsgc2tpcCBpdCAqLwoJCQlpKys7CgkJCWNvbnRpbnVlOwoJCX0KCgkJb2lkY3B5KCZwLT5wYXJlbnRbbl0ub2lkLCAmcS0+cXVldWVbaV0tPm9uZS0+b2lkKTsKCQlwLT5wYXJlbnRbbl0ubW9kZSA9IHEtPnF1ZXVlW2ldLT5vbmUtPm1vZGU7CgkJcC0+cGFyZW50W25dLnN0YXR1cyA9IHEtPnF1ZXVlW2ldLT5zdGF0dXM7CgkJaWYgKGNvbWJpbmVkX2FsbF9wYXRocyAmJgoJCSAgICBmaWxlbmFtZV9jaGFuZ2VkKHAtPnBhcmVudFtuXS5zdGF0dXMpKQoJCQlzdHJidWZfYWRkc3RyKCZwLT5wYXJlbnRbbl0ucGF0aCwKCQkJCSAgICAgIHEtPnF1ZXVlW2ldLT5vbmUtPnBhdGgpOwoKCQl0YWlsID0gJnAtPm5leHQ7CgkJaSsrOwoJfQoJcmV0dXJuIGN1cnI7Cn0KCi8qIExpbmVzIGxvc3QgZnJvbSBwYXJlbnQgKi8Kc3RydWN0IGxsaW5lIHsKCXN0cnVjdCBsbGluZSAqbmV4dCwgKnByZXY7CglpbnQgbGVuOwoJdW5zaWduZWQgbG9uZyBwYXJlbnRfbWFwOwoJY2hhciBsaW5lW0ZMRVhfQVJSQVldOwp9OwoKLyogTGluZXMgbG9zdCBmcm9tIGN1cnJlbnQgcGFyZW50IChiZWZvcmUgY29hbGVzY2luZykgKi8Kc3RydWN0IHBsb3N0IHsKCXN0cnVjdCBsbGluZSAqbG9zdF9oZWFkLCAqbG9zdF90YWlsOwoJaW50IGxlbjsKfTsKCi8qIExpbmVzIHN1cnZpdmluZyBpbiB0aGUgbWVyZ2UgcmVzdWx0ICovCnN0cnVjdCBzbGluZSB7CgkvKiBBY2N1bXVsYXRlZCBhbmQgY29hbGVzY2VkIGxvc3QgbGluZXMgKi8KCXN0cnVjdCBsbGluZSAqbG9zdDsKCWludCBsZW5sb3N0OwoJc3RydWN0IHBsb3N0IHBsb3N0OwoJY2hhciAqYm9sOwoJaW50IGxlbjsKCS8qIGJpdCAwIHVwIHRvIChOLTEpIGFyZSBvbiBpZiB0aGUgcGFyZW50IGhhcyB0aGlzIGxpbmUgKGkuZS4KCSAqIHdlIGRpZCBub3QgY2hhbmdlIGl0KS4KCSAqIGJpdCBOIGlzIHVzZWQgZm9yICJpbnRlcmVzdGluZyIgbGluZXMsIGluY2x1ZGluZyBjb250ZXh0LgoJICogYml0IChOKzEpIGlzIHVzZWQgZm9yICJkbyBub3Qgc2hvdyBkZWxldGlvbiBiZWZvcmUgdGhpcyIuCgkgKi8KCXVuc2lnbmVkIGxvbmcgZmxhZzsKCXVuc2lnbmVkIGxvbmcgKnBfbG5vOwp9OwoKc3RhdGljIGludCBtYXRjaF9zdHJpbmdfc3BhY2VzKGNvbnN0IGNoYXIgKmxpbmUxLCBpbnQgbGVuMSwKCQkJICAgICAgIGNvbnN0IGNoYXIgKmxpbmUyLCBpbnQgbGVuMiwKCQkJICAgICAgIGxvbmcgZmxhZ3MpCnsKCWlmIChmbGFncyAmIFhERl9XSElURVNQQUNFX0ZMQUdTKSB7CgkJZm9yICg7IGxlbjEgPiAwICYmIFhETF9JU1NQQUNFKGxpbmUxW2xlbjEgLSAxXSk7IGxlbjEtLSk7CgkJZm9yICg7IGxlbjIgPiAwICYmIFhETF9JU1NQQUNFKGxpbmUyW2xlbjIgLSAxXSk7IGxlbjItLSk7Cgl9CgoJaWYgKCEoZmxhZ3MgJiAoWERGX0lHTk9SRV9XSElURVNQQUNFIHwgWERGX0lHTk9SRV9XSElURVNQQUNFX0NIQU5HRSkpKQoJCXJldHVybiAobGVuMSA9PSBsZW4yICYmICFtZW1jbXAobGluZTEsIGxpbmUyLCBsZW4xKSk7CgoJd2hpbGUgKGxlbjEgPiAwICYmIGxlbjIgPiAwKSB7CgkJbGVuMS0tOwoJCWxlbjItLTsKCQlpZiAoWERMX0lTU1BBQ0UobGluZTFbbGVuMV0pIHx8IFhETF9JU1NQQUNFKGxpbmUyW2xlbjJdKSkgewoJCQlpZiAoKGZsYWdzICYgWERGX0lHTk9SRV9XSElURVNQQUNFX0NIQU5HRSkgJiYKCQkJICAgICghWERMX0lTU1BBQ0UobGluZTFbbGVuMV0pIHx8ICFYRExfSVNTUEFDRShsaW5lMltsZW4yXSkpKQoJCQkJcmV0dXJuIDA7CgoJCQlmb3IgKDsgbGVuMSA+IDAgJiYgWERMX0lTU1BBQ0UobGluZTFbbGVuMV0pOyBsZW4xLS0pOwoJCQlmb3IgKDsgbGVuMiA+IDAgJiYgWERMX0lTU1BBQ0UobGluZTJbbGVuMl0pOyBsZW4yLS0pOwoJCX0KCQlpZiAobGluZTFbbGVuMV0gIT0gbGluZTJbbGVuMl0pCgkJCXJldHVybiAwOwoJfQoKCWlmIChmbGFncyAmIFhERl9JR05PUkVfV0hJVEVTUEFDRSkgewoJCS8qIENvbnN1bWUgcmVtYWluaW5nIHNwYWNlcyAqLwoJCWZvciAoOyBsZW4xID4gMCAmJiBYRExfSVNTUEFDRShsaW5lMVtsZW4xIC0gMV0pOyBsZW4xLS0pOwoJCWZvciAoOyBsZW4yID4gMCAmJiBYRExfSVNTUEFDRShsaW5lMltsZW4yIC0gMV0pOyBsZW4yLS0pOwoJfQoKCS8qIFdlIG1hdGNoZWQgZnVsbCBsaW5lMSBhbmQgbGluZTIgKi8KCWlmICghbGVuMSAmJiAhbGVuMikKCQlyZXR1cm4gMTsKCglyZXR1cm4gMDsKfQoKZW51bSBjb2FsZXNjZV9kaXJlY3Rpb24geyBNQVRDSCwgQkFTRSwgTkVXIH07CgovKiBDb2FsZXNjZSBuZXcgbGluZXMgaW50byBiYXNlIGJ5IGZpbmRpbmcgTENTICovCnN0YXRpYyBzdHJ1Y3QgbGxpbmUgKmNvYWxlc2NlX2xpbmVzKHN0cnVjdCBsbGluZSAqYmFzZSwgaW50ICpsZW5iYXNlLAoJCQkJICAgIHN0cnVjdCBsbGluZSAqbmV3bGluZSwgaW50IGxlbm5ldywKCQkJCSAgICB1bnNpZ25lZCBsb25nIHBhcmVudCwgbG9uZyBmbGFncykKewoJaW50ICoqbGNzOwoJZW51bSBjb2FsZXNjZV9kaXJlY3Rpb24gKipkaXJlY3Rpb25zOwoJc3RydWN0IGxsaW5lICpiYXNlZW5kLCAqbmV3ZW5kID0gTlVMTDsKCWludCBpLCBqLCBvcmlnYmFzZWxlbiA9ICpsZW5iYXNlOwoKCWlmIChuZXdsaW5lID09IE5VTEwpCgkJcmV0dXJuIGJhc2U7CgoJaWYgKGJhc2UgPT0gTlVMTCkgewoJCSpsZW5iYXNlID0gbGVubmV3OwoJCXJldHVybiBuZXdsaW5lOwoJfQoKCS8qCgkgKiBDb2FsZXNjZSBuZXcgbGluZXMgaW50byBiYXNlIGJ5IGZpbmRpbmcgdGhlIExDUwoJICogLSBDcmVhdGUgdGhlIHRhYmxlIHRvIHJ1biBkeW5hbWljIHByb2dyYW1taW5nCgkgKiAtIENvbXB1dGUgdGhlIExDUwoJICogLSBUaGVuIHJldmVyc2UgcmVhZCB0aGUgZGlyZWN0aW9uIHN0cnVjdHVyZToKCSAqICAgLSBJZiB3ZSBoYXZlIE1BVENILCBhc3NpZ24gcGFyZW50IHRvIGJhc2UgZmxhZywgYW5kIGNvbnN1bWUKCSAqICAgYm90aCBiYXNlZW5kIGFuZCBuZXdlbmQKCSAqICAgLSBFbHNlIGlmIHdlIGhhdmUgQkFTRSwgY29uc3VtZSBiYXNlZW5kCgkgKiAgIC0gRWxzZSBpZiB3ZSBoYXZlIE5FVywgaW5zZXJ0IG5ld2VuZCBsbGluZSBpbnRvIGJhc2UgYW5kCgkgKiAgIGNvbnN1bWUgbmV3ZW5kCgkgKi8KCWxjcyA9IHhjYWxsb2Moc3RfYWRkKG9yaWdiYXNlbGVuLCAxKSwgc2l6ZW9mKGludCopKTsKCWRpcmVjdGlvbnMgPSB4Y2FsbG9jKHN0X2FkZChvcmlnYmFzZWxlbiwgMSksIHNpemVvZihlbnVtIGNvYWxlc2NlX2RpcmVjdGlvbiopKTsKCWZvciAoaSA9IDA7IGkgPCBvcmlnYmFzZWxlbiArIDE7IGkrKykgewoJCWxjc1tpXSA9IHhjYWxsb2Moc3RfYWRkKGxlbm5ldywgMSksIHNpemVvZihpbnQpKTsKCQlkaXJlY3Rpb25zW2ldID0geGNhbGxvYyhzdF9hZGQobGVubmV3LCAxKSwgc2l6ZW9mKGVudW0gY29hbGVzY2VfZGlyZWN0aW9uKSk7CgkJZGlyZWN0aW9uc1tpXVswXSA9IEJBU0U7Cgl9Cglmb3IgKGogPSAxOyBqIDwgbGVubmV3ICsgMTsgaisrKQoJCWRpcmVjdGlvbnNbMF1bal0gPSBORVc7CgoJZm9yIChpID0gMSwgYmFzZWVuZCA9IGJhc2U7IGkgPCBvcmlnYmFzZWxlbiArIDE7IGkrKykgewoJCWZvciAoaiA9IDEsIG5ld2VuZCA9IG5ld2xpbmU7IGogPCBsZW5uZXcgKyAxOyBqKyspIHsKCQkJaWYgKG1hdGNoX3N0cmluZ19zcGFjZXMoYmFzZWVuZC0+bGluZSwgYmFzZWVuZC0+bGVuLAoJCQkJCQluZXdlbmQtPmxpbmUsIG5ld2VuZC0+bGVuLCBmbGFncykpIHsKCQkJCWxjc1tpXVtqXSA9IGxjc1tpIC0gMV1baiAtIDFdICsgMTsKCQkJCWRpcmVjdGlvbnNbaV1bal0gPSBNQVRDSDsKCQkJfSBlbHNlIGlmIChsY3NbaV1baiAtIDFdID49IGxjc1tpIC0gMV1bal0pIHsKCQkJCWxjc1tpXVtqXSA9IGxjc1tpXVtqIC0gMV07CgkJCQlkaXJlY3Rpb25zW2ldW2pdID0gTkVXOwoJCQl9IGVsc2UgewoJCQkJbGNzW2ldW2pdID0gbGNzW2kgLSAxXVtqXTsKCQkJCWRpcmVjdGlvbnNbaV1bal0gPSBCQVNFOwoJCQl9CgkJCWlmIChuZXdlbmQtPm5leHQpCgkJCQluZXdlbmQgPSBuZXdlbmQtPm5leHQ7CgkJfQoJCWlmIChiYXNlZW5kLT5uZXh0KQoJCQliYXNlZW5kID0gYmFzZWVuZC0+bmV4dDsKCX0KCglmb3IgKGkgPSAwOyBpIDwgb3JpZ2Jhc2VsZW4gKyAxOyBpKyspCgkJZnJlZShsY3NbaV0pOwoJZnJlZShsY3MpOwoKCS8qIEF0IHRoaXMgcG9pbnQsIGJhc2VlbmQgYW5kIG5ld2VuZCBwb2ludCB0byB0aGUgZW5kIG9mIGVhY2ggbGlzdHMgKi8KCWktLTsKCWotLTsKCXdoaWxlIChpICE9IDAgfHwgaiAhPSAwKSB7CgkJaWYgKGRpcmVjdGlvbnNbaV1bal0gPT0gTUFUQ0gpIHsKCQkJYmFzZWVuZC0+cGFyZW50X21hcCB8PSAxPDxwYXJlbnQ7CgkJCWJhc2VlbmQgPSBiYXNlZW5kLT5wcmV2OwoJCQluZXdlbmQgPSBuZXdlbmQtPnByZXY7CgkJCWktLTsKCQkJai0tOwoJCX0gZWxzZSBpZiAoZGlyZWN0aW9uc1tpXVtqXSA9PSBORVcpIHsKCQkJc3RydWN0IGxsaW5lICpsbGluZTsKCgkJCWxsaW5lID0gbmV3ZW5kOwoJCQkvKiBSZW1vdmUgbGxpbmUgZnJvbSBuZXcgbGlzdCBhbmQgdXBkYXRlIG5ld2VuZCAqLwoJCQlpZiAobGxpbmUtPnByZXYpCgkJCQlsbGluZS0+cHJldi0+bmV4dCA9IGxsaW5lLT5uZXh0OwoJCQllbHNlCgkJCQluZXdsaW5lID0gbGxpbmUtPm5leHQ7CgkJCWlmIChsbGluZS0+bmV4dCkKCQkJCWxsaW5lLT5uZXh0LT5wcmV2ID0gbGxpbmUtPnByZXY7CgoJCQluZXdlbmQgPSBsbGluZS0+cHJldjsKCQkJai0tOwoKCQkJLyogQWRkIGxsaW5lIHRvIGJhc2UgbGlzdCAqLwoJCQlpZiAoYmFzZWVuZCkgewoJCQkJbGxpbmUtPm5leHQgPSBiYXNlZW5kLT5uZXh0OwoJCQkJbGxpbmUtPnByZXYgPSBiYXNlZW5kOwoJCQkJaWYgKGxsaW5lLT5wcmV2KQoJCQkJCWxsaW5lLT5wcmV2LT5uZXh0ID0gbGxpbmU7CgkJCX0KCQkJZWxzZSB7CgkJCQlsbGluZS0+bmV4dCA9IGJhc2U7CgkJCQliYXNlID0gbGxpbmU7CgkJCX0KCQkJKCpsZW5iYXNlKSsrOwoKCQkJaWYgKGxsaW5lLT5uZXh0KQoJCQkJbGxpbmUtPm5leHQtPnByZXYgPSBsbGluZTsKCgkJfSBlbHNlIHsKCQkJYmFzZWVuZCA9IGJhc2VlbmQtPnByZXY7CgkJCWktLTsKCQl9Cgl9CgoJbmV3ZW5kID0gbmV3bGluZTsKCXdoaWxlIChuZXdlbmQpIHsKCQlzdHJ1Y3QgbGxpbmUgKmxsaW5lID0gbmV3ZW5kOwoJCW5ld2VuZCA9IG5ld2VuZC0+bmV4dDsKCQlmcmVlKGxsaW5lKTsKCX0KCglmb3IgKGkgPSAwOyBpIDwgb3JpZ2Jhc2VsZW4gKyAxOyBpKyspCgkJZnJlZShkaXJlY3Rpb25zW2ldKTsKCWZyZWUoZGlyZWN0aW9ucyk7CgoJcmV0dXJuIGJhc2U7Cn0KCnN0YXRpYyBjaGFyICpncmFiX2Jsb2Ioc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJICAgICAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgdW5zaWduZWQgaW50IG1vZGUsCgkJICAgICAgIHVuc2lnbmVkIGxvbmcgKnNpemUsIHN0cnVjdCB1c2VyZGlmZl9kcml2ZXIgKnRleHRjb252LAoJCSAgICAgICBjb25zdCBjaGFyICpwYXRoKQp7CgljaGFyICpibG9iOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoKCWlmIChTX0lTR0lUTElOSyhtb2RlKSkgewoJCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgkJc3RyYnVmX2FkZGYoJmJ1ZiwgIlN1YnByb2plY3QgY29tbWl0ICVzXG4iLCBvaWRfdG9faGV4KG9pZCkpOwoJCSpzaXplID0gYnVmLmxlbjsKCQlibG9iID0gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCX0gZWxzZSBpZiAoaXNfbnVsbF9vaWQob2lkKSkgewoJCS8qIGRlbGV0ZWQgYmxvYiAqLwoJCSpzaXplID0gMDsKCQlyZXR1cm4geGNhbGxvYygxLCAxKTsKCX0gZWxzZSBpZiAodGV4dGNvbnYpIHsKCQlzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqZGYgPSBhbGxvY19maWxlc3BlYyhwYXRoKTsKCQlmaWxsX2ZpbGVzcGVjKGRmLCBvaWQsIDEsIG1vZGUpOwoJCSpzaXplID0gZmlsbF90ZXh0Y29udihyLCB0ZXh0Y29udiwgZGYsICZibG9iKTsKCQlmcmVlX2ZpbGVzcGVjKGRmKTsKCX0gZWxzZSB7CgkJYmxvYiA9IHJlYWRfb2JqZWN0X2ZpbGUob2lkLCAmdHlwZSwgc2l6ZSk7CgkJaWYgKHR5cGUgIT0gT0JKX0JMT0IpCgkJCWRpZSgib2JqZWN0ICclcycgaXMgbm90IGEgYmxvYiEiLCBvaWRfdG9faGV4KG9pZCkpOwoJfQoJcmV0dXJuIGJsb2I7Cn0KCnN0YXRpYyB2b2lkIGFwcGVuZF9sb3N0KHN0cnVjdCBzbGluZSAqc2xpbmUsIGludCBuLCBjb25zdCBjaGFyICpsaW5lLCBpbnQgbGVuKQp7CglzdHJ1Y3QgbGxpbmUgKmxsaW5lOwoJdW5zaWduZWQgbG9uZyB0aGlzX21hc2sgPSAoMVVMPDxuKTsKCWlmIChsaW5lW2xlbi0xXSA9PSAnXG4nKQoJCWxlbi0tOwoKCUZMRVhfQUxMT0NfTUVNKGxsaW5lLCBsaW5lLCBsaW5lLCBsZW4pOwoJbGxpbmUtPmxlbiA9IGxlbjsKCWxsaW5lLT5uZXh0ID0gTlVMTDsKCWxsaW5lLT5wcmV2ID0gc2xpbmUtPnBsb3N0Lmxvc3RfdGFpbDsKCWlmIChsbGluZS0+cHJldikKCQlsbGluZS0+cHJldi0+bmV4dCA9IGxsaW5lOwoJZWxzZQoJCXNsaW5lLT5wbG9zdC5sb3N0X2hlYWQgPSBsbGluZTsKCXNsaW5lLT5wbG9zdC5sb3N0X3RhaWwgPSBsbGluZTsKCXNsaW5lLT5wbG9zdC5sZW4rKzsKCWxsaW5lLT5wYXJlbnRfbWFwID0gdGhpc19tYXNrOwp9CgpzdHJ1Y3QgY29tYmluZV9kaWZmX3N0YXRlIHsKCXVuc2lnbmVkIGludCBsbm87CglpbnQgb2IsIG9uLCBuYiwgbm47Cgl1bnNpZ25lZCBsb25nIG5tYXNrOwoJaW50IG51bV9wYXJlbnQ7CglpbnQgbjsKCXN0cnVjdCBzbGluZSAqc2xpbmU7CglzdHJ1Y3Qgc2xpbmUgKmxvc3RfYnVja2V0Owp9OwoKc3RhdGljIHZvaWQgY29uc3VtZV9odW5rKHZvaWQgKnN0YXRlXywKCQkJIGxvbmcgb2IsIGxvbmcgb24sCgkJCSBsb25nIG5iLCBsb25nIG5uLAoJCQkgY29uc3QgY2hhciAqZnVuY2xpbmUsIGxvbmcgZnVuY2xlbikKewoJc3RydWN0IGNvbWJpbmVfZGlmZl9zdGF0ZSAqc3RhdGUgPSBzdGF0ZV87CgoJc3RhdGUtPm9iID0gb2I7CglzdGF0ZS0+b24gPSBvbjsKCXN0YXRlLT5uYiA9IG5iOwoJc3RhdGUtPm5uID0gbm47CglzdGF0ZS0+bG5vID0gc3RhdGUtPm5iOwoJaWYgKHN0YXRlLT5ubiA9PSAwKSB7CgkJLyogQEAgLVgsWSArTiwwIEBAIHJlbW92ZWQgWSBsaW5lcwoJCSAqIHRoYXQgd291bGQgaGF2ZSBjb21lICphZnRlciogbGluZSBOCgkJICogaW4gdGhlIHJlc3VsdC4gIE91ciBsb3N0IGJ1Y2tldHMgaGFuZwoJCSAqIHRvIHRoZSBsaW5lIGFmdGVyIHRoZSByZW1vdmVkIGxpbmVzLAoJCSAqCgkJICogTm90ZSB0aGF0IHRoaXMgaXMgY29ycmVjdCBldmVuIHdoZW4gTiA9PSAwLAoJCSAqIGluIHdoaWNoIGNhc2UgdGhlIGh1bmsgcmVtb3ZlcyB0aGUgZmlyc3QKCQkgKiBsaW5lIGluIHRoZSBmaWxlLgoJCSAqLwoJCXN0YXRlLT5sb3N0X2J1Y2tldCA9ICZzdGF0ZS0+c2xpbmVbc3RhdGUtPm5iXTsKCQlpZiAoIXN0YXRlLT5uYikKCQkJc3RhdGUtPm5iID0gMTsKCX0gZWxzZSB7CgkJc3RhdGUtPmxvc3RfYnVja2V0ID0gJnN0YXRlLT5zbGluZVtzdGF0ZS0+bmItMV07Cgl9CglpZiAoIXN0YXRlLT5zbGluZVtzdGF0ZS0+bmItMV0ucF9sbm8pCgkJc3RhdGUtPnNsaW5lW3N0YXRlLT5uYi0xXS5wX2xubyA9CgkJCXhjYWxsb2Moc3RhdGUtPm51bV9wYXJlbnQsIHNpemVvZih1bnNpZ25lZCBsb25nKSk7CglzdGF0ZS0+c2xpbmVbc3RhdGUtPm5iLTFdLnBfbG5vW3N0YXRlLT5uXSA9IHN0YXRlLT5vYjsKfQoKc3RhdGljIHZvaWQgY29uc3VtZV9saW5lKHZvaWQgKnN0YXRlXywgY2hhciAqbGluZSwgdW5zaWduZWQgbG9uZyBsZW4pCnsKCXN0cnVjdCBjb21iaW5lX2RpZmZfc3RhdGUgKnN0YXRlID0gc3RhdGVfOwoJaWYgKCFzdGF0ZS0+bG9zdF9idWNrZXQpCgkJcmV0dXJuOyAvKiBub3QgaW4gYW55IGh1bmsgeWV0ICovCglzd2l0Y2ggKGxpbmVbMF0pIHsKCWNhc2UgJy0nOgoJCWFwcGVuZF9sb3N0KHN0YXRlLT5sb3N0X2J1Y2tldCwgc3RhdGUtPm4sIGxpbmUrMSwgbGVuLTEpOwoJCWJyZWFrOwoJY2FzZSAnKyc6CgkJc3RhdGUtPnNsaW5lW3N0YXRlLT5sbm8tMV0uZmxhZyB8PSBzdGF0ZS0+bm1hc2s7CgkJc3RhdGUtPmxubysrOwoJCWJyZWFrOwoJfQp9CgpzdGF0aWMgdm9pZCBjb21iaW5lX2RpZmYoc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCSBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpwYXJlbnQsIHVuc2lnbmVkIGludCBtb2RlLAoJCQkgbW1maWxlX3QgKnJlc3VsdF9maWxlLAoJCQkgc3RydWN0IHNsaW5lICpzbGluZSwgdW5zaWduZWQgaW50IGNudCwgaW50IG4sCgkJCSBpbnQgbnVtX3BhcmVudCwgaW50IHJlc3VsdF9kZWxldGVkLAoJCQkgc3RydWN0IHVzZXJkaWZmX2RyaXZlciAqdGV4dGNvbnYsCgkJCSBjb25zdCBjaGFyICpwYXRoLCBsb25nIGZsYWdzKQp7Cgl1bnNpZ25lZCBpbnQgcF9sbm8sIGxubzsKCXVuc2lnbmVkIGxvbmcgbm1hc2sgPSAoMVVMIDw8IG4pOwoJeHBwYXJhbV90IHhwcDsKCXhkZW1pdGNvbmZfdCB4ZWNmZzsKCW1tZmlsZV90IHBhcmVudF9maWxlOwoJc3RydWN0IGNvbWJpbmVfZGlmZl9zdGF0ZSBzdGF0ZTsKCXVuc2lnbmVkIGxvbmcgc3o7CgoJaWYgKHJlc3VsdF9kZWxldGVkKQoJCXJldHVybjsgLyogcmVzdWx0IGRlbGV0ZWQgKi8KCglwYXJlbnRfZmlsZS5wdHIgPSBncmFiX2Jsb2IociwgcGFyZW50LCBtb2RlLCAmc3osIHRleHRjb252LCBwYXRoKTsKCXBhcmVudF9maWxlLnNpemUgPSBzejsKCW1lbXNldCgmeHBwLCAwLCBzaXplb2YoeHBwKSk7Cgl4cHAuZmxhZ3MgPSBmbGFnczsKCW1lbXNldCgmeGVjZmcsIDAsIHNpemVvZih4ZWNmZykpOwoJbWVtc2V0KCZzdGF0ZSwgMCwgc2l6ZW9mKHN0YXRlKSk7CglzdGF0ZS5ubWFzayA9IG5tYXNrOwoJc3RhdGUuc2xpbmUgPSBzbGluZTsKCXN0YXRlLmxubyA9IDE7CglzdGF0ZS5udW1fcGFyZW50ID0gbnVtX3BhcmVudDsKCXN0YXRlLm4gPSBuOwoKCWlmICh4ZGlfZGlmZl9vdXRmKCZwYXJlbnRfZmlsZSwgcmVzdWx0X2ZpbGUsIGNvbnN1bWVfaHVuaywKCQkJICBjb25zdW1lX2xpbmUsICZzdGF0ZSwgJnhwcCwgJnhlY2ZnKSkKCQlkaWUoInVuYWJsZSB0byBnZW5lcmF0ZSBjb21iaW5lZCBkaWZmIGZvciAlcyIsCgkJICAgIG9pZF90b19oZXgocGFyZW50KSk7CglmcmVlKHBhcmVudF9maWxlLnB0cik7CgoJLyogQXNzaWduIGxpbmUgbnVtYmVycyBmb3IgdGhpcyBwYXJlbnQuCgkgKgoJICogc2xpbmVbbG5vXS5wX2xub1tuXSByZWNvcmRzIHRoZSBmaXJzdCBsaW5lIG51bWJlcgoJICogKGNvdW50aW5nIGZyb20gMSkgZm9yIHBhcmVudCBOIGlmIHRoZSBmaW5hbCBodW5rIGRpc3BsYXkKCSAqIHN0YXJ0ZWQgYnkgc2hvd2luZyBzbGluZVtsbm9dIChwb3NzaWJseSBzaG93aW5nIHRoZSBsb3N0CgkgKiBsaW5lcyBhdHRhY2hlZCB0byBpdCBmaXJzdCkuCgkgKi8KCWZvciAobG5vID0gMCwgIHBfbG5vID0gMTsgbG5vIDw9IGNudDsgbG5vKyspIHsKCQlzdHJ1Y3QgbGxpbmUgKmxsOwoJCXNsaW5lW2xub10ucF9sbm9bbl0gPSBwX2xubzsKCgkJLyogQ29hbGVzY2UgbmV3IGxpbmVzICovCgkJaWYgKHNsaW5lW2xub10ucGxvc3QubG9zdF9oZWFkKSB7CgkJCXN0cnVjdCBzbGluZSAqc2wgPSAmc2xpbmVbbG5vXTsKCQkJc2wtPmxvc3QgPSBjb2FsZXNjZV9saW5lcyhzbC0+bG9zdCwgJnNsLT5sZW5sb3N0LAoJCQkJCQkgIHNsLT5wbG9zdC5sb3N0X2hlYWQsCgkJCQkJCSAgc2wtPnBsb3N0LmxlbiwgbiwgZmxhZ3MpOwoJCQlzbC0+cGxvc3QubG9zdF9oZWFkID0gc2wtPnBsb3N0Lmxvc3RfdGFpbCA9IE5VTEw7CgkJCXNsLT5wbG9zdC5sZW4gPSAwOwoJCX0KCgkJLyogSG93IG1hbnkgbGluZXMgd291bGQgdGhpcyBzbGluZSBhZHZhbmNlIHRoZSBwX2xubz8gKi8KCQlsbCA9IHNsaW5lW2xub10ubG9zdDsKCQl3aGlsZSAobGwpIHsKCQkJaWYgKGxsLT5wYXJlbnRfbWFwICYgbm1hc2spCgkJCQlwX2xubysrOyAvKiAnLScgbWVhbnMgcGFyZW50IGhhZCBpdCAqLwoJCQlsbCA9IGxsLT5uZXh0OwoJCX0KCQlpZiAobG5vIDwgY250ICYmICEoc2xpbmVbbG5vXS5mbGFnICYgbm1hc2spKQoJCQlwX2xubysrOyAvKiBubyAnKycgbWVhbnMgcGFyZW50IGhhZCBpdCAqLwoJfQoJc2xpbmVbbG5vXS5wX2xub1tuXSA9IHBfbG5vOyAvKiB0cmFpbGVyICovCn0KCnN0YXRpYyB1bnNpZ25lZCBsb25nIGNvbnRleHQgPSAzOwpzdGF0aWMgY2hhciBjb21iaW5lX21hcmtlciA9ICdAJzsKCnN0YXRpYyBpbnQgaW50ZXJlc3Rpbmcoc3RydWN0IHNsaW5lICpzbGluZSwgdW5zaWduZWQgbG9uZyBhbGxfbWFzaykKewoJLyogSWYgc29tZSBwYXJlbnRzIGxvc3QgbGluZXMgaGVyZSwgb3IgaWYgd2UgaGF2ZSBhZGRlZCB0bwoJICogc29tZSBwYXJlbnQsIGl0IGlzIGludGVyZXN0aW5nLgoJICovCglyZXR1cm4gKChzbGluZS0+ZmxhZyAmIGFsbF9tYXNrKSB8fCBzbGluZS0+bG9zdCk7Cn0KCnN0YXRpYyB1bnNpZ25lZCBsb25nIGFkanVzdF9odW5rX3RhaWwoc3RydWN0IHNsaW5lICpzbGluZSwKCQkJCSAgICAgIHVuc2lnbmVkIGxvbmcgYWxsX21hc2ssCgkJCQkgICAgICB1bnNpZ25lZCBsb25nIGh1bmtfYmVnaW4sCgkJCQkgICAgICB1bnNpZ25lZCBsb25nIGkpCnsKCS8qIGkgcG9pbnRzIGF0IHRoZSBmaXJzdCB1bmludGVyZXN0aW5nIGxpbmUuICBJZiB0aGUgbGFzdCBsaW5lCgkgKiBvZiB0aGUgaHVuayB3YXMgaW50ZXJlc3Rpbmcgb25seSBiZWNhdXNlIGl0IGhhcyBzb21lCgkgKiBkZWxldGlvbiwgdGhlbiBpdCBpcyBub3QgYWxsIHRoYXQgaW50ZXJlc3RpbmcgZm9yIHRoZQoJICogcHVycG9zZSBvZiBnaXZpbmcgdHJhaWxpbmcgY29udGV4dCBsaW5lcy4gIFRoaXMgaXMgYmVjYXVzZQoJICogd2Ugb3V0cHV0ICctJyBsaW5lIGFuZCB0aGVuIHVubW9kaWZpZWQgc2xpbmVbaS0xXSBpdHNlbGYgaW4KCSAqIHRoYXQgY2FzZSB3aGljaCBnaXZlcyB1cyBvbmUgZXh0cmEgY29udGV4dCBsaW5lLgoJICovCglpZiAoKGh1bmtfYmVnaW4gKyAxIDw9IGkpICYmICEoc2xpbmVbaS0xXS5mbGFnICYgYWxsX21hc2spKQoJCWktLTsKCXJldHVybiBpOwp9CgpzdGF0aWMgdW5zaWduZWQgbG9uZyBmaW5kX25leHQoc3RydWN0IHNsaW5lICpzbGluZSwKCQkJICAgICAgIHVuc2lnbmVkIGxvbmcgbWFyaywKCQkJICAgICAgIHVuc2lnbmVkIGxvbmcgaSwKCQkJICAgICAgIHVuc2lnbmVkIGxvbmcgY250LAoJCQkgICAgICAgaW50IGxvb2tfZm9yX3VuaW50ZXJlc3RpbmcpCnsKCS8qIFdlIGhhdmUgZXhhbWluZWQgdXAgdG8gaS0xIGFuZCBhcmUgYWJvdXQgdG8gbG9vayBhdCBpLgoJICogRmluZCBuZXh0IGludGVyZXN0aW5nIG9yIHVuaW50ZXJlc3RpbmcgbGluZS4gIEhlcmUsCgkgKiAiaW50ZXJlc3RpbmciIGRvZXMgbm90IG1lYW4gaW50ZXJlc3RpbmcoKSwgYnV0IG1hcmtlZCBieQoJICogdGhlIGdpdmVfY29udGV4dCgpIGZ1bmN0aW9uIGJlbG93IChpLmUuIGl0IGluY2x1ZGVzIGNvbnRleHQKCSAqIGxpbmVzIHRoYXQgYXJlIG5vdCBpbnRlcmVzdGluZyB0byBpbnRlcmVzdGluZygpIGZ1bmN0aW9uCgkgKiB0aGF0IGFyZSBzdXJyb3VuZGVkIGJ5IGludGVyZXN0aW5nKCkgb25lcy4KCSAqLwoJd2hpbGUgKGkgPD0gY250KQoJCWlmIChsb29rX2Zvcl91bmludGVyZXN0aW5nCgkJICAgID8gIShzbGluZVtpXS5mbGFnICYgbWFyaykKCQkgICAgOiAoc2xpbmVbaV0uZmxhZyAmIG1hcmspKQoJCQlyZXR1cm4gaTsKCQllbHNlCgkJCWkrKzsKCXJldHVybiBpOwp9CgpzdGF0aWMgaW50IGdpdmVfY29udGV4dChzdHJ1Y3Qgc2xpbmUgKnNsaW5lLCB1bnNpZ25lZCBsb25nIGNudCwgaW50IG51bV9wYXJlbnQpCnsKCXVuc2lnbmVkIGxvbmcgYWxsX21hc2sgPSAoMVVMPDxudW1fcGFyZW50KSAtIDE7Cgl1bnNpZ25lZCBsb25nIG1hcmsgPSAoMVVMPDxudW1fcGFyZW50KTsKCXVuc2lnbmVkIGxvbmcgbm9fcHJlX2RlbGV0ZSA9ICgyVUw8PG51bV9wYXJlbnQpOwoJdW5zaWduZWQgbG9uZyBpOwoKCS8qIFR3byBncm91cHMgb2YgaW50ZXJlc3RpbmcgbGluZXMgbWF5IGhhdmUgYSBzaG9ydCBnYXAgb2YKCSAqIHVuaW50ZXJlc3RpbmcgbGluZXMuICBDb25uZWN0IHN1Y2ggZ3JvdXBzIHRvIGdpdmUgdGhlbSBhCgkgKiBiaXQgb2YgY29udGV4dC4KCSAqCgkgKiBXZSBmaXJzdCBzdGFydCBmcm9tIHdoYXQgdGhlIGludGVyZXN0aW5nKCkgZnVuY3Rpb24gc2F5cywKCSAqIGFuZCBtYXJrIHRoZW0gd2l0aCAibWFyayIsIGFuZCBwYWludCBjb250ZXh0IGxpbmVzIHdpdGggdGhlCgkgKiBtYXJrLiAgU28gaW50ZXJlc3RpbmcoKSB3b3VsZCBzdGlsbCBzYXkgZmFsc2UgZm9yIHN1Y2ggY29udGV4dAoJICogbGluZXMgYnV0IHRoZXkgYXJlIHRyZWF0ZWQgYXMgImludGVyZXN0aW5nIiBpbiB0aGUgZW5kLgoJICovCglpID0gZmluZF9uZXh0KHNsaW5lLCBtYXJrLCAwLCBjbnQsIDApOwoJaWYgKGNudCA8IGkpCgkJcmV0dXJuIDA7CgoJd2hpbGUgKGkgPD0gY250KSB7CgkJdW5zaWduZWQgbG9uZyBqID0gKGNvbnRleHQgPCBpKSA/IChpIC0gY29udGV4dCkgOiAwOwoJCXVuc2lnbmVkIGxvbmcgazsKCgkJLyogUGFpbnQgYSBmZXcgbGluZXMgYmVmb3JlIHRoZSBmaXJzdCBpbnRlcmVzdGluZyBsaW5lLiAqLwoJCXdoaWxlIChqIDwgaSkgewoJCQlpZiAoIShzbGluZVtqXS5mbGFnICYgbWFyaykpCgkJCQlzbGluZVtqXS5mbGFnIHw9IG5vX3ByZV9kZWxldGU7CgkJCXNsaW5lW2orK10uZmxhZyB8PSBtYXJrOwoJCX0KCglhZ2FpbjoKCQkvKiB3ZSBrbm93IHVwIHRvIGkgaXMgdG8gYmUgaW5jbHVkZWQuICB3aGVyZSBkb2VzIHRoZQoJCSAqIG5leHQgdW5pbnRlcmVzdGluZyBvbmUgc3RhcnQ/CgkJICovCgkJaiA9IGZpbmRfbmV4dChzbGluZSwgbWFyaywgaSwgY250LCAxKTsKCQlpZiAoY250IDwgaikKCQkJYnJlYWs7IC8qIHRoZSByZXN0IGFyZSBhbGwgaW50ZXJlc3RpbmcgKi8KCgkJLyogbG9va2FoZWFkIGNvbnRleHQgbGluZXMgKi8KCQlrID0gZmluZF9uZXh0KHNsaW5lLCBtYXJrLCBqLCBjbnQsIDApOwoJCWogPSBhZGp1c3RfaHVua190YWlsKHNsaW5lLCBhbGxfbWFzaywgaSwgaik7CgoJCWlmIChrIDwgaiArIGNvbnRleHQpIHsKCQkJLyogayBpcyBpbnRlcmVzdGluZyBhbmQgW2osaykgYXJlIG5vdCwgYnV0CgkJCSAqIHBhaW50IHRoZW0gaW50ZXJlc3RpbmcgYmVjYXVzZSB0aGUgZ2FwIGlzIHNtYWxsLgoJCQkgKi8KCQkJd2hpbGUgKGogPCBrKQoJCQkJc2xpbmVbaisrXS5mbGFnIHw9IG1hcms7CgkJCWkgPSBrOwoJCQlnb3RvIGFnYWluOwoJCX0KCgkJLyogaiBpcyB0aGUgZmlyc3QgdW5pbnRlcmVzdGluZyBsaW5lIGFuZCB0aGVyZSBpcwoJCSAqIG5vIG92ZXJsYXAgYmV5b25kIGl0IHdpdGhpbiBjb250ZXh0IGxpbmVzLiAgUGFpbnQKCQkgKiB0aGUgdHJhaWxpbmcgZWRnZSBhIGJpdC4KCQkgKi8KCQlpID0gazsKCQlrID0gKGogKyBjb250ZXh0IDwgY250KzEpID8gaiArIGNvbnRleHQgOiBjbnQrMTsKCQl3aGlsZSAoaiA8IGspCgkJCXNsaW5lW2orK10uZmxhZyB8PSBtYXJrOwoJfQoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBpbnQgbWFrZV9odW5rcyhzdHJ1Y3Qgc2xpbmUgKnNsaW5lLCB1bnNpZ25lZCBsb25nIGNudCwKCQkgICAgICAgaW50IG51bV9wYXJlbnQsIGludCBkZW5zZSkKewoJdW5zaWduZWQgbG9uZyBhbGxfbWFzayA9ICgxVUw8PG51bV9wYXJlbnQpIC0gMTsKCXVuc2lnbmVkIGxvbmcgbWFyayA9ICgxVUw8PG51bV9wYXJlbnQpOwoJdW5zaWduZWQgbG9uZyBpOwoJaW50IGhhc19pbnRlcmVzdGluZyA9IDA7CgoJZm9yIChpID0gMDsgaSA8PSBjbnQ7IGkrKykgewoJCWlmIChpbnRlcmVzdGluZygmc2xpbmVbaV0sIGFsbF9tYXNrKSkKCQkJc2xpbmVbaV0uZmxhZyB8PSBtYXJrOwoJCWVsc2UKCQkJc2xpbmVbaV0uZmxhZyAmPSB+bWFyazsKCX0KCWlmICghZGVuc2UpCgkJcmV0dXJuIGdpdmVfY29udGV4dChzbGluZSwgY250LCBudW1fcGFyZW50KTsKCgkvKiBMb29rIGF0IGVhY2ggaHVuaywgYW5kIGlmIHdlIGhhdmUgY2hhbmdlcyBmcm9tIG9ubHkgb25lCgkgKiBwYXJlbnQsIG9yIHRoZSBjaGFuZ2VzIGFyZSB0aGUgc2FtZSBmcm9tIGFsbCBidXQgb25lCgkgKiBwYXJlbnQsIG1hcmsgdGhhdCB1bmludGVyZXN0aW5nLgoJICovCglpID0gMDsKCXdoaWxlIChpIDw9IGNudCkgewoJCXVuc2lnbmVkIGxvbmcgaiwgaHVua19iZWdpbiwgaHVua19lbmQ7CgkJdW5zaWduZWQgbG9uZyBzYW1lX2RpZmY7CgkJd2hpbGUgKGkgPD0gY250ICYmICEoc2xpbmVbaV0uZmxhZyAmIG1hcmspKQoJCQlpKys7CgkJaWYgKGNudCA8IGkpCgkJCWJyZWFrOyAvKiBObyBtb3JlIGludGVyZXN0aW5nIGh1bmtzICovCgkJaHVua19iZWdpbiA9IGk7CgkJZm9yIChqID0gaSArIDE7IGogPD0gY250OyBqKyspIHsKCQkJaWYgKCEoc2xpbmVbal0uZmxhZyAmIG1hcmspKSB7CgkJCQkvKiBMb29rIGJleW9uZCB0aGUgZW5kIHRvIHNlZSBpZiB0aGVyZQoJCQkJICogaXMgYW4gaW50ZXJlc3RpbmcgbGluZSBhZnRlciB0aGlzCgkJCQkgKiBodW5rIHdpdGhpbiBjb250ZXh0IHNwYW4uCgkJCQkgKi8KCQkJCXVuc2lnbmVkIGxvbmcgbGE7IC8qIGxvb2thaGVhZCAqLwoJCQkJaW50IGNvbnRpbiA9IDA7CgkJCQlsYSA9IGFkanVzdF9odW5rX3RhaWwoc2xpbmUsIGFsbF9tYXNrLAoJCQkJCQkgICAgIGh1bmtfYmVnaW4sIGopOwoJCQkJbGEgPSAobGEgKyBjb250ZXh0IDwgY250ICsgMSkgPwoJCQkJCShsYSArIGNvbnRleHQpIDogY250ICsgMTsKCQkJCXdoaWxlIChsYSAmJiBqIDw9IC0tbGEpIHsKCQkJCQlpZiAoc2xpbmVbbGFdLmZsYWcgJiBtYXJrKSB7CgkJCQkJCWNvbnRpbiA9IDE7CgkJCQkJCWJyZWFrOwoJCQkJCX0KCQkJCX0KCQkJCWlmICghY29udGluKQoJCQkJCWJyZWFrOwoJCQkJaiA9IGxhOwoJCQl9CgkJfQoJCWh1bmtfZW5kID0gajsKCgkJLyogW2kuLmh1bmtfZW5kKSBhcmUgaW50ZXJlc3RpbmcuICBOb3cgaXMgaXQgcmVhbGx5CgkJICogaW50ZXJlc3Rpbmc/ICBXZSBjaGVjayBpZiB0aGVyZSBhcmUgb25seSB0d28gdmVyc2lvbnMKCQkgKiBhbmQgdGhlIHJlc3VsdCBtYXRjaGVzIG9uZSBvZiB0aGVtLiAgVGhhdCBpcywgd2UgbG9vawoJCSAqIGF0OgoJCSAqICAgKCspIGxpbmUsIHdoaWNoIHJlY29yZHMgbGluZXMgYWRkZWQgdG8gd2hpY2ggcGFyZW50czsKCQkgKiAgICAgICB0aGlzIGxpbmUgYXBwZWFycyBpbiB0aGUgcmVzdWx0LgoJCSAqICAgKC0pIGxpbmUsIHdoaWNoIHJlY29yZHMgZnJvbSB3aGF0IHBhcmVudHMgdGhlIGxpbmUKCQkgKiAgICAgICB3YXMgcmVtb3ZlZDsgdGhpcyBsaW5lIGRvZXMgbm90IGFwcGVhciBpbiB0aGUgcmVzdWx0LgoJCSAqIHRoZW4gY2hlY2sgdGhlIHNldCBvZiBwYXJlbnRzIHRoZSByZXN1bHQgaGFzIGRpZmZlcmVuY2UKCQkgKiBmcm9tLCBmcm9tIGFsbCBsaW5lcy4gIElmIHRoZXJlIGFyZSBsaW5lcyB0aGF0IGhhcwoJCSAqIGRpZmZlcmVudCBzZXQgb2YgcGFyZW50cyB0aGF0IHRoZSByZXN1bHQgaGFzIGRpZmZlcmVuY2VzCgkJICogZnJvbSwgdGhhdCBtZWFucyB3ZSBoYXZlIG1vcmUgdGhhbiB0d28gdmVyc2lvbnMuCgkJICoKCQkgKiBFdmVuIHdoZW4gd2UgaGF2ZSBvbmx5IHR3byB2ZXJzaW9ucywgaWYgdGhlIHJlc3VsdCBkb2VzCgkJICogbm90IG1hdGNoIGFueSBvZiB0aGUgcGFyZW50cywgdGhlIGl0IHNob3VsZCBiZSBjb25zaWRlcmVkCgkJICogaW50ZXJlc3RpbmcuICBJbiBzdWNoIGEgY2FzZSwgd2Ugd291bGQgaGF2ZSBhbGwgJysnIGxpbmUuCgkJICogQWZ0ZXIgcGFzc2luZyB0aGUgYWJvdmUgInR3byB2ZXJzaW9ucyIgdGVzdCwgdGhhdCB3b3VsZAoJCSAqIGFwcGVhciBhcyAidGhlIHNhbWUgc2V0IG9mIHBhcmVudHMiIHRvIGJlICJhbGwgcGFyZW50cyIuCgkJICovCgkJc2FtZV9kaWZmID0gMDsKCQloYXNfaW50ZXJlc3RpbmcgPSAwOwoJCWZvciAoaiA9IGk7IGogPCBodW5rX2VuZCAmJiAhaGFzX2ludGVyZXN0aW5nOyBqKyspIHsKCQkJdW5zaWduZWQgbG9uZyB0aGlzX2RpZmYgPSBzbGluZVtqXS5mbGFnICYgYWxsX21hc2s7CgkJCXN0cnVjdCBsbGluZSAqbGwgPSBzbGluZVtqXS5sb3N0OwoJCQlpZiAodGhpc19kaWZmKSB7CgkJCQkvKiBUaGlzIGhhcyBzb21lIGNoYW5nZXMuICBJcyBpdCB0aGUKCQkJCSAqIHNhbWUgYXMgb3RoZXJzPwoJCQkJICovCgkJCQlpZiAoIXNhbWVfZGlmZikKCQkJCQlzYW1lX2RpZmYgPSB0aGlzX2RpZmY7CgkJCQllbHNlIGlmIChzYW1lX2RpZmYgIT0gdGhpc19kaWZmKSB7CgkJCQkJaGFzX2ludGVyZXN0aW5nID0gMTsKCQkJCQlicmVhazsKCQkJCX0KCQkJfQoJCQl3aGlsZSAobGwgJiYgIWhhc19pbnRlcmVzdGluZykgewoJCQkJLyogTG9zdCB0aGlzIGxpbmUgZnJvbSB0aGVzZSBwYXJlbnRzOwoJCQkJICogd2hvIGFyZSB0aGV5PyAgQXJlIHRoZXkgdGhlIHNhbWU/CgkJCQkgKi8KCQkJCXRoaXNfZGlmZiA9IGxsLT5wYXJlbnRfbWFwOwoJCQkJaWYgKCFzYW1lX2RpZmYpCgkJCQkJc2FtZV9kaWZmID0gdGhpc19kaWZmOwoJCQkJZWxzZSBpZiAoc2FtZV9kaWZmICE9IHRoaXNfZGlmZikgewoJCQkJCWhhc19pbnRlcmVzdGluZyA9IDE7CgkJCQl9CgkJCQlsbCA9IGxsLT5uZXh0OwoJCQl9CgkJfQoKCQlpZiAoIWhhc19pbnRlcmVzdGluZyAmJiBzYW1lX2RpZmYgIT0gYWxsX21hc2spIHsKCQkJLyogVGhpcyBodW5rIGlzIG5vdCB0aGF0IGludGVyZXN0aW5nIGFmdGVyIGFsbCAqLwoJCQlmb3IgKGogPSBodW5rX2JlZ2luOyBqIDwgaHVua19lbmQ7IGorKykKCQkJCXNsaW5lW2pdLmZsYWcgJj0gfm1hcms7CgkJfQoJCWkgPSBodW5rX2VuZDsKCX0KCgloYXNfaW50ZXJlc3RpbmcgPSBnaXZlX2NvbnRleHQoc2xpbmUsIGNudCwgbnVtX3BhcmVudCk7CglyZXR1cm4gaGFzX2ludGVyZXN0aW5nOwp9CgpzdGF0aWMgdm9pZCBzaG93X3BhcmVudF9sbm8oc3RydWN0IHNsaW5lICpzbGluZSwgdW5zaWduZWQgbG9uZyBsMCwgdW5zaWduZWQgbG9uZyBsMSwgaW50IG4sIHVuc2lnbmVkIGxvbmcgbnVsbF9jb250ZXh0KQp7CglsMCA9IHNsaW5lW2wwXS5wX2xub1tuXTsKCWwxID0gc2xpbmVbbDFdLnBfbG5vW25dOwoJcHJpbnRmKCIgLSVsdSwlbHUiLCBsMCwgbDEtbDAtbnVsbF9jb250ZXh0KTsKfQoKc3RhdGljIGludCBodW5rX2NvbW1lbnRfbGluZShjb25zdCBjaGFyICpib2wpCnsKCWludCBjaDsKCglpZiAoIWJvbCkKCQlyZXR1cm4gMDsKCWNoID0gKmJvbCAmIDB4ZmY7CglyZXR1cm4gKGlzYWxwaGEoY2gpIHx8IGNoID09ICdfJyB8fCBjaCA9PSAnJCcpOwp9CgpzdGF0aWMgdm9pZCBzaG93X2xpbmVfdG9fZW9sKGNvbnN0IGNoYXIgKmxpbmUsIGludCBsZW4sIGNvbnN0IGNoYXIgKnJlc2V0KQp7CglpbnQgc2F3X2NyX2F0X2VvbCA9IDA7CglpZiAobGVuIDwgMCkKCQlsZW4gPSBzdHJsZW4obGluZSk7CglzYXdfY3JfYXRfZW9sID0gKGxlbiAmJiBsaW5lW2xlbi0xXSA9PSAnXHInKTsKCglwcmludGYoIiUuKnMlcyVzXG4iLCBsZW4gLSBzYXdfY3JfYXRfZW9sLCBsaW5lLAoJICAgICAgIHJlc2V0LAoJICAgICAgIHNhd19jcl9hdF9lb2wgPyAiXHIiIDogIiIpOwp9CgpzdGF0aWMgdm9pZCBkdW1wX3NsaW5lKHN0cnVjdCBzbGluZSAqc2xpbmUsIGNvbnN0IGNoYXIgKmxpbmVfcHJlZml4LAoJCSAgICAgICB1bnNpZ25lZCBsb25nIGNudCwgaW50IG51bV9wYXJlbnQsCgkJICAgICAgIGludCB1c2VfY29sb3IsIGludCByZXN1bHRfZGVsZXRlZCkKewoJdW5zaWduZWQgbG9uZyBtYXJrID0gKDFVTDw8bnVtX3BhcmVudCk7Cgl1bnNpZ25lZCBsb25nIG5vX3ByZV9kZWxldGUgPSAoMlVMPDxudW1fcGFyZW50KTsKCWludCBpOwoJdW5zaWduZWQgbG9uZyBsbm8gPSAwOwoJY29uc3QgY2hhciAqY19mcmFnID0gZGlmZl9nZXRfY29sb3IodXNlX2NvbG9yLCBESUZGX0ZSQUdJTkZPKTsKCWNvbnN0IGNoYXIgKmNfZnVuYyA9IGRpZmZfZ2V0X2NvbG9yKHVzZV9jb2xvciwgRElGRl9GVU5DSU5GTyk7Cgljb25zdCBjaGFyICpjX25ldyA9IGRpZmZfZ2V0X2NvbG9yKHVzZV9jb2xvciwgRElGRl9GSUxFX05FVyk7Cgljb25zdCBjaGFyICpjX29sZCA9IGRpZmZfZ2V0X2NvbG9yKHVzZV9jb2xvciwgRElGRl9GSUxFX09MRCk7Cgljb25zdCBjaGFyICpjX2NvbnRleHQgPSBkaWZmX2dldF9jb2xvcih1c2VfY29sb3IsIERJRkZfQ09OVEVYVCk7Cgljb25zdCBjaGFyICpjX3Jlc2V0ID0gZGlmZl9nZXRfY29sb3IodXNlX2NvbG9yLCBESUZGX1JFU0VUKTsKCglpZiAocmVzdWx0X2RlbGV0ZWQpCgkJcmV0dXJuOyAvKiByZXN1bHQgZGVsZXRlZCAqLwoKCXdoaWxlICgxKSB7CgkJdW5zaWduZWQgbG9uZyBodW5rX2VuZDsKCQl1bnNpZ25lZCBsb25nIHJsaW5lczsKCQljb25zdCBjaGFyICpodW5rX2NvbW1lbnQgPSBOVUxMOwoJCXVuc2lnbmVkIGxvbmcgbnVsbF9jb250ZXh0ID0gMDsKCgkJd2hpbGUgKGxubyA8PSBjbnQgJiYgIShzbGluZVtsbm9dLmZsYWcgJiBtYXJrKSkgewoJCQlpZiAoaHVua19jb21tZW50X2xpbmUoc2xpbmVbbG5vXS5ib2wpKQoJCQkJaHVua19jb21tZW50ID0gc2xpbmVbbG5vXS5ib2w7CgkJCWxubysrOwoJCX0KCQlpZiAoY250IDwgbG5vKQoJCQlicmVhazsKCQllbHNlIHsKCQkJZm9yIChodW5rX2VuZCA9IGxubyArIDE7IGh1bmtfZW5kIDw9IGNudDsgaHVua19lbmQrKykKCQkJCWlmICghKHNsaW5lW2h1bmtfZW5kXS5mbGFnICYgbWFyaykpCgkJCQkJYnJlYWs7CgkJfQoJCXJsaW5lcyA9IGh1bmtfZW5kIC0gbG5vOwoJCWlmIChjbnQgPCBodW5rX2VuZCkKCQkJcmxpbmVzLS07IC8qIHBvaW50aW5nIGF0IHRoZSBsYXN0IGRlbGV0ZSBodW5rICovCgoJCWlmICghY29udGV4dCkgewoJCQkvKgoJCQkgKiBFdmVuIHdoZW4gcnVubmluZyB3aXRoIC0tdW5pZmllZD0wLCBhbGwKCQkJICogbGluZXMgaW4gdGhlIGh1bmsgbmVlZHMgdG8gYmUgcHJvY2Vzc2VkIGluCgkJCSAqIHRoZSBsb29wIGJlbG93IGluIG9yZGVyIHRvIHNob3cgdGhlCgkJCSAqIGRlbGV0aW9uIHJlY29yZGVkIGluIGxvc3RfaGVhZC4gIEhvd2V2ZXIsCgkJCSAqIHdlIGRvIG5vdCB3YW50IHRvIHNob3cgdGhlIHJlc3VsdGluZyBsaW5lCgkJCSAqIHdpdGggYWxsIGJsYW5rIGNvbnRleHQgbWFya2VycyBpbiBzdWNoIGEKCQkJICogY2FzZS4gIENvbXBlbnNhdGUuCgkJCSAqLwoJCQl1bnNpZ25lZCBsb25nIGo7CgkJCWZvciAoaiA9IGxubzsgaiA8IGh1bmtfZW5kOyBqKyspCgkJCQlpZiAoIShzbGluZVtqXS5mbGFnICYgKG1hcmstMSkpKQoJCQkJCW51bGxfY29udGV4dCsrOwoJCQlybGluZXMgLT0gbnVsbF9jb250ZXh0OwoJCX0KCgkJcHJpbnRmKCIlcyVzIiwgbGluZV9wcmVmaXgsIGNfZnJhZyk7CgkJZm9yIChpID0gMDsgaSA8PSBudW1fcGFyZW50OyBpKyspIHB1dGNoYXIoY29tYmluZV9tYXJrZXIpOwoJCWZvciAoaSA9IDA7IGkgPCBudW1fcGFyZW50OyBpKyspCgkJCXNob3dfcGFyZW50X2xubyhzbGluZSwgbG5vLCBodW5rX2VuZCwgaSwgbnVsbF9jb250ZXh0KTsKCQlwcmludGYoIiArJWx1LCVsdSAiLCBsbm8rMSwgcmxpbmVzKTsKCQlmb3IgKGkgPSAwOyBpIDw9IG51bV9wYXJlbnQ7IGkrKykgcHV0Y2hhcihjb21iaW5lX21hcmtlcik7CgoJCWlmIChodW5rX2NvbW1lbnQpIHsKCQkJaW50IGNvbW1lbnRfZW5kID0gMDsKCQkJZm9yIChpID0gMDsgaSA8IDQwOyBpKyspIHsKCQkJCWludCBjaCA9IGh1bmtfY29tbWVudFtpXSAmIDB4ZmY7CgkJCQlpZiAoIWNoIHx8IGNoID09ICdcbicpCgkJCQkJYnJlYWs7CgkJCQlpZiAoIWlzc3BhY2UoY2gpKQoJCQkJICAgIGNvbW1lbnRfZW5kID0gaTsKCQkJfQoJCQlpZiAoY29tbWVudF9lbmQpCgkJCQlwcmludGYoIiVzJXMgJXMlcyIsIGNfcmVzZXQsCgkJCQkJCSAgICBjX2NvbnRleHQsIGNfcmVzZXQsCgkJCQkJCSAgICBjX2Z1bmMpOwoJCQlmb3IgKGkgPSAwOyBpIDwgY29tbWVudF9lbmQ7IGkrKykKCQkJCXB1dGNoYXIoaHVua19jb21tZW50W2ldKTsKCQl9CgoJCXByaW50ZigiJXNcbiIsIGNfcmVzZXQpOwoJCXdoaWxlIChsbm8gPCBodW5rX2VuZCkgewoJCQlzdHJ1Y3QgbGxpbmUgKmxsOwoJCQlpbnQgajsKCQkJdW5zaWduZWQgbG9uZyBwX21hc2s7CgkJCXN0cnVjdCBzbGluZSAqc2wgPSAmc2xpbmVbbG5vKytdOwoJCQlsbCA9IChzbC0+ZmxhZyAmIG5vX3ByZV9kZWxldGUpID8gTlVMTCA6IHNsLT5sb3N0OwoJCQl3aGlsZSAobGwpIHsKCQkJCXByaW50ZigiJXMlcyIsIGxpbmVfcHJlZml4LCBjX29sZCk7CgkJCQlmb3IgKGogPSAwOyBqIDwgbnVtX3BhcmVudDsgaisrKSB7CgkJCQkJaWYgKGxsLT5wYXJlbnRfbWFwICYgKDFVTDw8aikpCgkJCQkJCXB1dGNoYXIoJy0nKTsKCQkJCQllbHNlCgkJCQkJCXB1dGNoYXIoJyAnKTsKCQkJCX0KCQkJCXNob3dfbGluZV90b19lb2wobGwtPmxpbmUsIC0xLCBjX3Jlc2V0KTsKCQkJCWxsID0gbGwtPm5leHQ7CgkJCX0KCQkJaWYgKGNudCA8IGxubykKCQkJCWJyZWFrOwoJCQlwX21hc2sgPSAxOwoJCQlmcHV0cyhsaW5lX3ByZWZpeCwgc3Rkb3V0KTsKCQkJaWYgKCEoc2wtPmZsYWcgJiAobWFyay0xKSkpIHsKCQkJCS8qCgkJCQkgKiBUaGlzIHNsaW5lIHdhcyBoZXJlIHRvIGhhbmcgdGhlCgkJCQkgKiBsb3N0IGxpbmVzIGluIGZyb250IG9mIGl0LgoJCQkJICovCgkJCQlpZiAoIWNvbnRleHQpCgkJCQkJY29udGludWU7CgkJCQlmcHV0cyhjX2NvbnRleHQsIHN0ZG91dCk7CgkJCX0KCQkJZWxzZQoJCQkJZnB1dHMoY19uZXcsIHN0ZG91dCk7CgkJCWZvciAoaiA9IDA7IGogPCBudW1fcGFyZW50OyBqKyspIHsKCQkJCWlmIChwX21hc2sgJiBzbC0+ZmxhZykKCQkJCQlwdXRjaGFyKCcrJyk7CgkJCQllbHNlCgkJCQkJcHV0Y2hhcignICcpOwoJCQkJcF9tYXNrIDw8PSAxOwoJCQl9CgkJCXNob3dfbGluZV90b19lb2woc2wtPmJvbCwgc2wtPmxlbiwgY19yZXNldCk7CgkJfQoJfQp9CgpzdGF0aWMgdm9pZCByZXVzZV9jb21iaW5lX2RpZmYoc3RydWN0IHNsaW5lICpzbGluZSwgdW5zaWduZWQgbG9uZyBjbnQsCgkJCSAgICAgICBpbnQgaSwgaW50IGopCnsKCS8qIFdlIGhhdmUgYWxyZWFkeSBleGFtaW5lZCBwYXJlbnQgaiBhbmQgd2Uga25vdyBwYXJlbnQgaQoJICogYW5kIHBhcmVudCBqIGFyZSB0aGUgc2FtZSwgc28gcmV1c2UgdGhlIGNvbWJpbmVkIHJlc3VsdAoJICogb2YgcGFyZW50IGogZm9yIHBhcmVudCBpLgoJICovCgl1bnNpZ25lZCBsb25nIGxubywgaW1hc2ssIGptYXNrOwoJaW1hc2sgPSAoMVVMPDxpKTsKCWptYXNrID0gKDFVTDw8aik7CgoJZm9yIChsbm8gPSAwOyBsbm8gPD0gY250OyBsbm8rKykgewoJCXN0cnVjdCBsbGluZSAqbGwgPSBzbGluZS0+bG9zdDsKCQlzbGluZS0+cF9sbm9baV0gPSBzbGluZS0+cF9sbm9bal07CgkJd2hpbGUgKGxsKSB7CgkJCWlmIChsbC0+cGFyZW50X21hcCAmIGptYXNrKQoJCQkJbGwtPnBhcmVudF9tYXAgfD0gaW1hc2s7CgkJCWxsID0gbGwtPm5leHQ7CgkJfQoJCWlmIChzbGluZS0+ZmxhZyAmIGptYXNrKQoJCQlzbGluZS0+ZmxhZyB8PSBpbWFzazsKCQlzbGluZSsrOwoJfQoJLyogdGhlIG92ZXJhbGwgc2l6ZSBvZiB0aGUgZmlsZSAoc2xpbmVbY250XSkgKi8KCXNsaW5lLT5wX2xub1tpXSA9IHNsaW5lLT5wX2xub1tqXTsKfQoKc3RhdGljIHZvaWQgZHVtcF9xdW90ZWRfcGF0aChjb25zdCBjaGFyICpoZWFkLAoJCQkgICAgIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJICAgICBjb25zdCBjaGFyICpwYXRoLAoJCQkgICAgIGNvbnN0IGNoYXIgKmxpbmVfcHJlZml4LAoJCQkgICAgIGNvbnN0IGNoYXIgKmNfbWV0YSwgY29uc3QgY2hhciAqY19yZXNldCkKewoJc3RhdGljIHN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJc3RyYnVmX3Jlc2V0KCZidWYpOwoJc3RyYnVmX2FkZHN0cigmYnVmLCBsaW5lX3ByZWZpeCk7CglzdHJidWZfYWRkc3RyKCZidWYsIGNfbWV0YSk7CglzdHJidWZfYWRkc3RyKCZidWYsIGhlYWQpOwoJcXVvdGVfdHdvX2Nfc3R5bGUoJmJ1ZiwgcHJlZml4LCBwYXRoLCAwKTsKCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgY19yZXNldCk7CglwdXRzKGJ1Zi5idWYpOwp9CgpzdGF0aWMgdm9pZCBzaG93X2NvbWJpbmVkX2hlYWRlcihzdHJ1Y3QgY29tYmluZV9kaWZmX3BhdGggKmVsZW0sCgkJCQkgaW50IG51bV9wYXJlbnQsCgkJCQkgaW50IGRlbnNlLAoJCQkJIHN0cnVjdCByZXZfaW5mbyAqcmV2LAoJCQkJIGNvbnN0IGNoYXIgKmxpbmVfcHJlZml4LAoJCQkJIGludCBtb2RlX2RpZmZlcnMsCgkJCQkgaW50IHNob3dfZmlsZV9oZWFkZXIpCnsKCXN0cnVjdCBkaWZmX29wdGlvbnMgKm9wdCA9ICZyZXYtPmRpZmZvcHQ7CglpbnQgYWJicmV2ID0gb3B0LT5mbGFncy5mdWxsX2luZGV4ID8gdGhlX2hhc2hfYWxnby0+aGV4c3ogOiBERUZBVUxUX0FCQlJFVjsKCWNvbnN0IGNoYXIgKmFfcHJlZml4ID0gb3B0LT5hX3ByZWZpeCA/IG9wdC0+YV9wcmVmaXggOiAiYS8iOwoJY29uc3QgY2hhciAqYl9wcmVmaXggPSBvcHQtPmJfcHJlZml4ID8gb3B0LT5iX3ByZWZpeCA6ICJiLyI7Cgljb25zdCBjaGFyICpjX21ldGEgPSBkaWZmX2dldF9jb2xvcl9vcHQob3B0LCBESUZGX01FVEFJTkZPKTsKCWNvbnN0IGNoYXIgKmNfcmVzZXQgPSBkaWZmX2dldF9jb2xvcl9vcHQob3B0LCBESUZGX1JFU0VUKTsKCWNvbnN0IGNoYXIgKmFiYjsKCWludCBhZGRlZCA9IDA7CglpbnQgZGVsZXRlZCA9IDA7CglpbnQgaTsKCglpZiAocmV2LT5sb2dpbmZvICYmICFyZXYtPm5vX2NvbW1pdF9pZCkKCQlzaG93X2xvZyhyZXYpOwoKCWR1bXBfcXVvdGVkX3BhdGgoZGVuc2UgPyAiZGlmZiAtLWNjICIgOiAiZGlmZiAtLWNvbWJpbmVkICIsCgkJCSAiIiwgZWxlbS0+cGF0aCwgbGluZV9wcmVmaXgsIGNfbWV0YSwgY19yZXNldCk7CglwcmludGYoIiVzJXNpbmRleCAiLCBsaW5lX3ByZWZpeCwgY19tZXRhKTsKCWZvciAoaSA9IDA7IGkgPCBudW1fcGFyZW50OyBpKyspIHsKCQlhYmIgPSBmaW5kX3VuaXF1ZV9hYmJyZXYoJmVsZW0tPnBhcmVudFtpXS5vaWQsCgkJCQkJIGFiYnJldik7CgkJcHJpbnRmKCIlcyVzIiwgaSA/ICIsIiA6ICIiLCBhYmIpOwoJfQoJYWJiID0gZmluZF91bmlxdWVfYWJicmV2KCZlbGVtLT5vaWQsIGFiYnJldik7CglwcmludGYoIi4uJXMlc1xuIiwgYWJiLCBjX3Jlc2V0KTsKCglpZiAobW9kZV9kaWZmZXJzKSB7CgkJZGVsZXRlZCA9ICFlbGVtLT5tb2RlOwoKCQkvKiBXZSBzYXkgaXQgd2FzIGFkZGVkIGlmIG5vYm9keSBoYWQgaXQgKi8KCQlhZGRlZCA9ICFkZWxldGVkOwoJCWZvciAoaSA9IDA7IGFkZGVkICYmIGkgPCBudW1fcGFyZW50OyBpKyspCgkJCWlmIChlbGVtLT5wYXJlbnRbaV0uc3RhdHVzICE9CgkJCSAgICBESUZGX1NUQVRVU19BRERFRCkKCQkJCWFkZGVkID0gMDsKCQlpZiAoYWRkZWQpCgkJCXByaW50ZigiJXMlc25ldyBmaWxlIG1vZGUgJTA2byIsCgkJCSAgICAgICBsaW5lX3ByZWZpeCwgY19tZXRhLCBlbGVtLT5tb2RlKTsKCQllbHNlIHsKCQkJaWYgKGRlbGV0ZWQpCgkJCQlwcmludGYoIiVzJXNkZWxldGVkIGZpbGUgIiwKCQkJCSAgICAgICBsaW5lX3ByZWZpeCwgY19tZXRhKTsKCQkJcHJpbnRmKCJtb2RlICIpOwoJCQlmb3IgKGkgPSAwOyBpIDwgbnVtX3BhcmVudDsgaSsrKSB7CgkJCQlwcmludGYoIiVzJTA2byIsIGkgPyAiLCIgOiAiIiwKCQkJCSAgICAgICBlbGVtLT5wYXJlbnRbaV0ubW9kZSk7CgkJCX0KCQkJaWYgKGVsZW0tPm1vZGUpCgkJCQlwcmludGYoIi4uJTA2byIsIGVsZW0tPm1vZGUpOwoJCX0KCQlwcmludGYoIiVzXG4iLCBjX3Jlc2V0KTsKCX0KCglpZiAoIXNob3dfZmlsZV9oZWFkZXIpCgkJcmV0dXJuOwoKCWlmIChyZXYtPmNvbWJpbmVkX2FsbF9wYXRocykgewoJCWZvciAoaSA9IDA7IGkgPCBudW1fcGFyZW50OyBpKyspIHsKCQkJY2hhciAqcGF0aCA9IGZpbGVuYW1lX2NoYW5nZWQoZWxlbS0+cGFyZW50W2ldLnN0YXR1cykKCQkJCT8gZWxlbS0+cGFyZW50W2ldLnBhdGguYnVmIDogZWxlbS0+cGF0aDsKCQkJaWYgKGVsZW0tPnBhcmVudFtpXS5zdGF0dXMgPT0gRElGRl9TVEFUVVNfQURERUQpCgkJCQlkdW1wX3F1b3RlZF9wYXRoKCItLS0gIiwgIiIsICIvZGV2L251bGwiLAoJCQkJCQkgbGluZV9wcmVmaXgsIGNfbWV0YSwgY19yZXNldCk7CgkJCWVsc2UKCQkJCWR1bXBfcXVvdGVkX3BhdGgoIi0tLSAiLCBhX3ByZWZpeCwgcGF0aCwKCQkJCQkJIGxpbmVfcHJlZml4LCBjX21ldGEsIGNfcmVzZXQpOwoJCX0KCX0gZWxzZSB7CgkJaWYgKGFkZGVkKQoJCQlkdW1wX3F1b3RlZF9wYXRoKCItLS0gIiwgIiIsICIvZGV2L251bGwiLAoJCQkJCSBsaW5lX3ByZWZpeCwgY19tZXRhLCBjX3Jlc2V0KTsKCQllbHNlCgkJCWR1bXBfcXVvdGVkX3BhdGgoIi0tLSAiLCBhX3ByZWZpeCwgZWxlbS0+cGF0aCwKCQkJCQkgbGluZV9wcmVmaXgsIGNfbWV0YSwgY19yZXNldCk7Cgl9CglpZiAoZGVsZXRlZCkKCQlkdW1wX3F1b3RlZF9wYXRoKCIrKysgIiwgIiIsICIvZGV2L251bGwiLAoJCQkJIGxpbmVfcHJlZml4LCBjX21ldGEsIGNfcmVzZXQpOwoJZWxzZQoJCWR1bXBfcXVvdGVkX3BhdGgoIisrKyAiLCBiX3ByZWZpeCwgZWxlbS0+cGF0aCwKCQkJCSBsaW5lX3ByZWZpeCwgY19tZXRhLCBjX3Jlc2V0KTsKfQoKc3RhdGljIHZvaWQgc2hvd19wYXRjaF9kaWZmKHN0cnVjdCBjb21iaW5lX2RpZmZfcGF0aCAqZWxlbSwgaW50IG51bV9wYXJlbnQsCgkJCSAgICBpbnQgZGVuc2UsIGludCB3b3JraW5nX3RyZWVfZmlsZSwKCQkJICAgIHN0cnVjdCByZXZfaW5mbyAqcmV2KQp7CglzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHQgPSAmcmV2LT5kaWZmb3B0OwoJdW5zaWduZWQgbG9uZyByZXN1bHRfc2l6ZSwgY250LCBsbm87CglpbnQgcmVzdWx0X2RlbGV0ZWQgPSAwOwoJY2hhciAqcmVzdWx0LCAqY3A7CglzdHJ1Y3Qgc2xpbmUgKnNsaW5lOyAvKiBzdXJ2aXZlZCBsaW5lcyAqLwoJaW50IG1vZGVfZGlmZmVycyA9IDA7CglpbnQgaSwgc2hvd19odW5rczsKCW1tZmlsZV90IHJlc3VsdF9maWxlOwoJc3RydWN0IHVzZXJkaWZmX2RyaXZlciAqdXNlcmRpZmY7CglzdHJ1Y3QgdXNlcmRpZmZfZHJpdmVyICp0ZXh0Y29udiA9IE5VTEw7CglpbnQgaXNfYmluYXJ5OwoJY29uc3QgY2hhciAqbGluZV9wcmVmaXggPSBkaWZmX2xpbmVfcHJlZml4KG9wdCk7CgoJY29udGV4dCA9IG9wdC0+Y29udGV4dDsKCXVzZXJkaWZmID0gdXNlcmRpZmZfZmluZF9ieV9wYXRoKG9wdC0+cmVwby0+aW5kZXgsIGVsZW0tPnBhdGgpOwoJaWYgKCF1c2VyZGlmZikKCQl1c2VyZGlmZiA9IHVzZXJkaWZmX2ZpbmRfYnlfbmFtZSgiZGVmYXVsdCIpOwoJaWYgKG9wdC0+ZmxhZ3MuYWxsb3dfdGV4dGNvbnYpCgkJdGV4dGNvbnYgPSB1c2VyZGlmZl9nZXRfdGV4dGNvbnYob3B0LT5yZXBvLCB1c2VyZGlmZik7CgoJLyogUmVhZCB0aGUgcmVzdWx0IG9mIG1lcmdlIGZpcnN0ICovCglpZiAoIXdvcmtpbmdfdHJlZV9maWxlKQoJCXJlc3VsdCA9IGdyYWJfYmxvYihvcHQtPnJlcG8sICZlbGVtLT5vaWQsIGVsZW0tPm1vZGUsICZyZXN1bHRfc2l6ZSwKCQkJCSAgIHRleHRjb252LCBlbGVtLT5wYXRoKTsKCWVsc2UgewoJCS8qIFVzZWQgYnkgZGlmZi10cmVlIHRvIHJlYWQgZnJvbSB0aGUgd29ya2luZyB0cmVlICovCgkJc3RydWN0IHN0YXQgc3Q7CgkJaW50IGZkID0gLTE7CgoJCWlmIChsc3RhdChlbGVtLT5wYXRoLCAmc3QpIDwgMCkKCQkJZ290byBkZWxldGVkX2ZpbGU7CgoJCWlmIChTX0lTTE5LKHN0LnN0X21vZGUpKSB7CgkJCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJCQlpZiAoc3RyYnVmX3JlYWRsaW5rKCZidWYsIGVsZW0tPnBhdGgsIHN0LnN0X3NpemUpIDwgMCkgewoJCQkJZXJyb3JfZXJybm8oInJlYWRsaW5rKCVzKSIsIGVsZW0tPnBhdGgpOwoJCQkJcmV0dXJuOwoJCQl9CgkJCXJlc3VsdF9zaXplID0gYnVmLmxlbjsKCQkJcmVzdWx0ID0gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCQkJZWxlbS0+bW9kZSA9IGNhbm9uX21vZGUoc3Quc3RfbW9kZSk7CgkJfSBlbHNlIGlmIChTX0lTRElSKHN0LnN0X21vZGUpKSB7CgkJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCQlpZiAocmVzb2x2ZV9naXRsaW5rX3JlZihlbGVtLT5wYXRoLCAiSEVBRCIsICZvaWQpIDwgMCkKCQkJCXJlc3VsdCA9IGdyYWJfYmxvYihvcHQtPnJlcG8sICZlbGVtLT5vaWQsCgkJCQkJCSAgIGVsZW0tPm1vZGUsICZyZXN1bHRfc2l6ZSwKCQkJCQkJICAgTlVMTCwgTlVMTCk7CgkJCWVsc2UKCQkJCXJlc3VsdCA9IGdyYWJfYmxvYihvcHQtPnJlcG8sICZvaWQsIGVsZW0tPm1vZGUsCgkJCQkJCSAgICZyZXN1bHRfc2l6ZSwgTlVMTCwgTlVMTCk7CgkJfSBlbHNlIGlmICh0ZXh0Y29udikgewoJCQlzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqZGYgPSBhbGxvY19maWxlc3BlYyhlbGVtLT5wYXRoKTsKCQkJZmlsbF9maWxlc3BlYyhkZiwgJm51bGxfb2lkLCAwLCBzdC5zdF9tb2RlKTsKCQkJcmVzdWx0X3NpemUgPSBmaWxsX3RleHRjb252KG9wdC0+cmVwbywgdGV4dGNvbnYsIGRmLCAmcmVzdWx0KTsKCQkJZnJlZV9maWxlc3BlYyhkZik7CgkJfSBlbHNlIGlmICgwIDw9IChmZCA9IG9wZW4oZWxlbS0+cGF0aCwgT19SRE9OTFkpKSkgewoJCQlzaXplX3QgbGVuID0geHNpemVfdChzdC5zdF9zaXplKTsKCQkJc3NpemVfdCBkb25lOwoJCQlpbnQgaXNfZmlsZSwgaTsKCgkJCWVsZW0tPm1vZGUgPSBjYW5vbl9tb2RlKHN0LnN0X21vZGUpOwoJCQkvKiBpZiBzeW1saW5rcyBkb24ndCB3b3JrLCBhc3N1bWUgc3ltbGluayBpZiBhbGwgcGFyZW50cwoJCQkgKiBhcmUgc3ltbGlua3MKCQkJICovCgkJCWlzX2ZpbGUgPSBoYXNfc3ltbGlua3M7CgkJCWZvciAoaSA9IDA7ICFpc19maWxlICYmIGkgPCBudW1fcGFyZW50OyBpKyspCgkJCQlpc19maWxlID0gIVNfSVNMTksoZWxlbS0+cGFyZW50W2ldLm1vZGUpOwoJCQlpZiAoIWlzX2ZpbGUpCgkJCQllbGVtLT5tb2RlID0gY2Fub25fbW9kZShTX0lGTE5LKTsKCgkJCXJlc3VsdF9zaXplID0gbGVuOwoJCQlyZXN1bHQgPSB4bWFsbG9jeihsZW4pOwoKCQkJZG9uZSA9IHJlYWRfaW5fZnVsbChmZCwgcmVzdWx0LCBsZW4pOwoJCQlpZiAoZG9uZSA8IDApCgkJCQlkaWVfZXJybm8oInJlYWQgZXJyb3IgJyVzJyIsIGVsZW0tPnBhdGgpOwoJCQllbHNlIGlmIChkb25lIDwgbGVuKQoJCQkJZGllKCJlYXJseSBFT0YgJyVzJyIsIGVsZW0tPnBhdGgpOwoKCQkJLyogSWYgbm90IGEgZmFrZSBzeW1saW5rLCBhcHBseSBmaWx0ZXJzLCBlLmcuIGF1dG9jcmxmICovCgkJCWlmIChpc19maWxlKSB7CgkJCQlzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoKCQkJCWlmIChjb252ZXJ0X3RvX2dpdChyZXYtPmRpZmZvcHQucmVwby0+aW5kZXgsCgkJCQkJCSAgIGVsZW0tPnBhdGgsIHJlc3VsdCwgbGVuLCAmYnVmLCBnbG9iYWxfY29udl9mbGFnc19lb2wpKSB7CgkJCQkJZnJlZShyZXN1bHQpOwoJCQkJCXJlc3VsdCA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgJmxlbik7CgkJCQkJcmVzdWx0X3NpemUgPSBsZW47CgkJCQl9CgkJCX0KCQl9CgkJZWxzZSB7CgkJZGVsZXRlZF9maWxlOgoJCQlyZXN1bHRfZGVsZXRlZCA9IDE7CgkJCXJlc3VsdF9zaXplID0gMDsKCQkJZWxlbS0+bW9kZSA9IDA7CgkJCXJlc3VsdCA9IHhjYWxsb2MoMSwgMSk7CgkJfQoKCQlpZiAoMCA8PSBmZCkKCQkJY2xvc2UoZmQpOwoJfQoKCWZvciAoaSA9IDA7IGkgPCBudW1fcGFyZW50OyBpKyspIHsKCQlpZiAoZWxlbS0+cGFyZW50W2ldLm1vZGUgIT0gZWxlbS0+bW9kZSkgewoJCQltb2RlX2RpZmZlcnMgPSAxOwoJCQlicmVhazsKCQl9Cgl9CgoJaWYgKHRleHRjb252KQoJCWlzX2JpbmFyeSA9IDA7CgllbHNlIGlmICh1c2VyZGlmZi0+YmluYXJ5ICE9IC0xKQoJCWlzX2JpbmFyeSA9IHVzZXJkaWZmLT5iaW5hcnk7CgllbHNlIHsKCQlpc19iaW5hcnkgPSBidWZmZXJfaXNfYmluYXJ5KHJlc3VsdCwgcmVzdWx0X3NpemUpOwoJCWZvciAoaSA9IDA7ICFpc19iaW5hcnkgJiYgaSA8IG51bV9wYXJlbnQ7IGkrKykgewoJCQljaGFyICpidWY7CgkJCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCQkJYnVmID0gZ3JhYl9ibG9iKG9wdC0+cmVwbywKCQkJCQkmZWxlbS0+cGFyZW50W2ldLm9pZCwKCQkJCQllbGVtLT5wYXJlbnRbaV0ubW9kZSwKCQkJCQkmc2l6ZSwgTlVMTCwgTlVMTCk7CgkJCWlmIChidWZmZXJfaXNfYmluYXJ5KGJ1Ziwgc2l6ZSkpCgkJCQlpc19iaW5hcnkgPSAxOwoJCQlmcmVlKGJ1Zik7CgkJfQoJfQoJaWYgKGlzX2JpbmFyeSkgewoJCXNob3dfY29tYmluZWRfaGVhZGVyKGVsZW0sIG51bV9wYXJlbnQsIGRlbnNlLCByZXYsCgkJCQkgICAgIGxpbmVfcHJlZml4LCBtb2RlX2RpZmZlcnMsIDApOwoJCXByaW50ZigiQmluYXJ5IGZpbGVzIGRpZmZlclxuIik7CgkJZnJlZShyZXN1bHQpOwoJCXJldHVybjsKCX0KCglmb3IgKGNudCA9IDAsIGNwID0gcmVzdWx0OyBjcCA8IHJlc3VsdCArIHJlc3VsdF9zaXplOyBjcCsrKSB7CgkJaWYgKCpjcCA9PSAnXG4nKQoJCQljbnQrKzsKCX0KCWlmIChyZXN1bHRfc2l6ZSAmJiByZXN1bHRbcmVzdWx0X3NpemUtMV0gIT0gJ1xuJykKCQljbnQrKzsgLyogaW5jb21wbGV0ZSBsaW5lICovCgoJc2xpbmUgPSB4Y2FsbG9jKHN0X2FkZChjbnQsIDIpLCBzaXplb2YoKnNsaW5lKSk7CglzbGluZVswXS5ib2wgPSByZXN1bHQ7Cglmb3IgKGxubyA9IDAsIGNwID0gcmVzdWx0OyBjcCA8IHJlc3VsdCArIHJlc3VsdF9zaXplOyBjcCsrKSB7CgkJaWYgKCpjcCA9PSAnXG4nKSB7CgkJCXNsaW5lW2xub10ubGVuID0gY3AgLSBzbGluZVtsbm9dLmJvbDsKCQkJbG5vKys7CgkJCWlmIChsbm8gPCBjbnQpCgkJCQlzbGluZVtsbm9dLmJvbCA9IGNwICsgMTsKCQl9Cgl9CglpZiAocmVzdWx0X3NpemUgJiYgcmVzdWx0W3Jlc3VsdF9zaXplLTFdICE9ICdcbicpCgkJc2xpbmVbY250LTFdLmxlbiA9IHJlc3VsdF9zaXplIC0gKHNsaW5lW2NudC0xXS5ib2wgLSByZXN1bHQpOwoKCXJlc3VsdF9maWxlLnB0ciA9IHJlc3VsdDsKCXJlc3VsdF9maWxlLnNpemUgPSByZXN1bHRfc2l6ZTsKCgkvKiBFdmVuIHBfbG5vW2NudCsxXSBpcyB2YWxpZCAtLSB0aGF0IGlzIGZvciB0aGUgZW5kIGxpbmUgbnVtYmVyCgkgKiBmb3IgZGVsZXRpb24gaHVuayBhdCB0aGUgZW5kLgoJICovCglzbGluZVswXS5wX2xubyA9IHhjYWxsb2Moc3RfbXVsdChzdF9hZGQoY250LCAyKSwgbnVtX3BhcmVudCksIHNpemVvZih1bnNpZ25lZCBsb25nKSk7Cglmb3IgKGxubyA9IDA7IGxubyA8PSBjbnQ7IGxubysrKQoJCXNsaW5lW2xubysxXS5wX2xubyA9IHNsaW5lW2xub10ucF9sbm8gKyBudW1fcGFyZW50OwoKCWZvciAoaSA9IDA7IGkgPCBudW1fcGFyZW50OyBpKyspIHsKCQlpbnQgajsKCQlmb3IgKGogPSAwOyBqIDwgaTsgaisrKSB7CgkJCWlmIChvaWRlcSgmZWxlbS0+cGFyZW50W2ldLm9pZCwKCQkJCSAgJmVsZW0tPnBhcmVudFtqXS5vaWQpKSB7CgkJCQlyZXVzZV9jb21iaW5lX2RpZmYoc2xpbmUsIGNudCwgaSwgaik7CgkJCQlicmVhazsKCQkJfQoJCX0KCQlpZiAoaSA8PSBqKQoJCQljb21iaW5lX2RpZmYob3B0LT5yZXBvLAoJCQkJICAgICAmZWxlbS0+cGFyZW50W2ldLm9pZCwKCQkJCSAgICAgZWxlbS0+cGFyZW50W2ldLm1vZGUsCgkJCQkgICAgICZyZXN1bHRfZmlsZSwgc2xpbmUsCgkJCQkgICAgIGNudCwgaSwgbnVtX3BhcmVudCwgcmVzdWx0X2RlbGV0ZWQsCgkJCQkgICAgIHRleHRjb252LCBlbGVtLT5wYXRoLCBvcHQtPnhkbF9vcHRzKTsKCX0KCglzaG93X2h1bmtzID0gbWFrZV9odW5rcyhzbGluZSwgY250LCBudW1fcGFyZW50LCBkZW5zZSk7CgoJaWYgKHNob3dfaHVua3MgfHwgbW9kZV9kaWZmZXJzIHx8IHdvcmtpbmdfdHJlZV9maWxlKSB7CgkJc2hvd19jb21iaW5lZF9oZWFkZXIoZWxlbSwgbnVtX3BhcmVudCwgZGVuc2UsIHJldiwKCQkJCSAgICAgbGluZV9wcmVmaXgsIG1vZGVfZGlmZmVycywgMSk7CgkJZHVtcF9zbGluZShzbGluZSwgbGluZV9wcmVmaXgsIGNudCwgbnVtX3BhcmVudCwKCQkJICAgb3B0LT51c2VfY29sb3IsIHJlc3VsdF9kZWxldGVkKTsKCX0KCWZyZWUocmVzdWx0KTsKCglmb3IgKGxubyA9IDA7IGxubyA8IGNudDsgbG5vKyspIHsKCQlpZiAoc2xpbmVbbG5vXS5sb3N0KSB7CgkJCXN0cnVjdCBsbGluZSAqbGwgPSBzbGluZVtsbm9dLmxvc3Q7CgkJCXdoaWxlIChsbCkgewoJCQkJc3RydWN0IGxsaW5lICp0bXAgPSBsbDsKCQkJCWxsID0gbGwtPm5leHQ7CgkJCQlmcmVlKHRtcCk7CgkJCX0KCQl9Cgl9CglmcmVlKHNsaW5lWzBdLnBfbG5vKTsKCWZyZWUoc2xpbmUpOwp9CgpzdGF0aWMgdm9pZCBzaG93X3Jhd19kaWZmKHN0cnVjdCBjb21iaW5lX2RpZmZfcGF0aCAqcCwgaW50IG51bV9wYXJlbnQsIHN0cnVjdCByZXZfaW5mbyAqcmV2KQp7CglzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHQgPSAmcmV2LT5kaWZmb3B0OwoJaW50IGxpbmVfdGVybWluYXRpb24sIGludGVyX25hbWVfdGVybWluYXRpb24sIGk7Cgljb25zdCBjaGFyICpsaW5lX3ByZWZpeCA9IGRpZmZfbGluZV9wcmVmaXgob3B0KTsKCglsaW5lX3Rlcm1pbmF0aW9uID0gb3B0LT5saW5lX3Rlcm1pbmF0aW9uOwoJaW50ZXJfbmFtZV90ZXJtaW5hdGlvbiA9ICdcdCc7CglpZiAoIWxpbmVfdGVybWluYXRpb24pCgkJaW50ZXJfbmFtZV90ZXJtaW5hdGlvbiA9IDA7CgoJaWYgKHJldi0+bG9naW5mbyAmJiAhcmV2LT5ub19jb21taXRfaWQpCgkJc2hvd19sb2cocmV2KTsKCgoJaWYgKG9wdC0+b3V0cHV0X2Zvcm1hdCAmIERJRkZfRk9STUFUX1JBVykgewoJCXByaW50ZigiJXMiLCBsaW5lX3ByZWZpeCk7CgoJCS8qIEFzIG1hbnkgY29sb25zIGFzIHRoZXJlIGFyZSBwYXJlbnRzICovCgkJZm9yIChpID0gMDsgaSA8IG51bV9wYXJlbnQ7IGkrKykKCQkJcHV0Y2hhcignOicpOwoKCQkvKiBTaG93IHRoZSBtb2RlcyAqLwoJCWZvciAoaSA9IDA7IGkgPCBudW1fcGFyZW50OyBpKyspCgkJCXByaW50ZigiJTA2byAiLCBwLT5wYXJlbnRbaV0ubW9kZSk7CgkJcHJpbnRmKCIlMDZvIiwgcC0+bW9kZSk7CgoJCS8qIFNob3cgc2hhMSdzICovCgkJZm9yIChpID0gMDsgaSA8IG51bV9wYXJlbnQ7IGkrKykKCQkJcHJpbnRmKCIgJXMiLCBkaWZmX2FsaWduZWRfYWJicmV2KCZwLT5wYXJlbnRbaV0ub2lkLAoJCQkJCQkJICBvcHQtPmFiYnJldikpOwoJCXByaW50ZigiICVzICIsIGRpZmZfYWxpZ25lZF9hYmJyZXYoJnAtPm9pZCwgb3B0LT5hYmJyZXYpKTsKCX0KCglpZiAob3B0LT5vdXRwdXRfZm9ybWF0ICYgKERJRkZfRk9STUFUX1JBVyB8IERJRkZfRk9STUFUX05BTUVfU1RBVFVTKSkgewoJCWZvciAoaSA9IDA7IGkgPCBudW1fcGFyZW50OyBpKyspCgkJCXB1dGNoYXIocC0+cGFyZW50W2ldLnN0YXR1cyk7CgkJcHV0Y2hhcihpbnRlcl9uYW1lX3Rlcm1pbmF0aW9uKTsKCX0KCglmb3IgKGkgPSAwOyBpIDwgbnVtX3BhcmVudDsgaSsrKQoJCWlmIChyZXYtPmNvbWJpbmVkX2FsbF9wYXRocykgewoJCQlpZiAoZmlsZW5hbWVfY2hhbmdlZChwLT5wYXJlbnRbaV0uc3RhdHVzKSkKCQkJCXdyaXRlX25hbWVfcXVvdGVkKHAtPnBhcmVudFtpXS5wYXRoLmJ1Ziwgc3Rkb3V0LAoJCQkJCQkgIGludGVyX25hbWVfdGVybWluYXRpb24pOwoJCQllbHNlCgkJCQl3cml0ZV9uYW1lX3F1b3RlZChwLT5wYXRoLCBzdGRvdXQsCgkJCQkJCSAgaW50ZXJfbmFtZV90ZXJtaW5hdGlvbik7CgkJfQoJd3JpdGVfbmFtZV9xdW90ZWQocC0+cGF0aCwgc3Rkb3V0LCBsaW5lX3Rlcm1pbmF0aW9uKTsKfQoKLyoKICogVGhlIHJlc3VsdCAocC0+ZWxlbSkgaXMgZnJvbSB0aGUgd29ya2luZyB0cmVlIGFuZCB0aGVpcgogKiBwYXJlbnRzIGFyZSB0eXBpY2FsbHkgZnJvbSBtdWx0aXBsZSBzdGFnZXMgZHVyaW5nIGEgbWVyZ2UKICogKGkuZS4gZGlmZi1maWxlcykgb3IgdGhlIHN0YXRlIGluIEhFQUQgYW5kIGluIHRoZSBpbmRleAogKiAoaS5lLiBkaWZmLWluZGV4KS4KICovCnZvaWQgc2hvd19jb21iaW5lZF9kaWZmKHN0cnVjdCBjb21iaW5lX2RpZmZfcGF0aCAqcCwKCQkgICAgICAgaW50IG51bV9wYXJlbnQsCgkJICAgICAgIGludCBkZW5zZSwKCQkgICAgICAgc3RydWN0IHJldl9pbmZvICpyZXYpCnsKCXN0cnVjdCBkaWZmX29wdGlvbnMgKm9wdCA9ICZyZXYtPmRpZmZvcHQ7CgoJaWYgKG9wdC0+b3V0cHV0X2Zvcm1hdCAmIChESUZGX0ZPUk1BVF9SQVcgfAoJCQkJICBESUZGX0ZPUk1BVF9OQU1FIHwKCQkJCSAgRElGRl9GT1JNQVRfTkFNRV9TVEFUVVMpKQoJCXNob3dfcmF3X2RpZmYocCwgbnVtX3BhcmVudCwgcmV2KTsKCWVsc2UgaWYgKG9wdC0+b3V0cHV0X2Zvcm1hdCAmIERJRkZfRk9STUFUX1BBVENIKQoJCXNob3dfcGF0Y2hfZGlmZihwLCBudW1fcGFyZW50LCBkZW5zZSwgMSwgcmV2KTsKfQoKc3RhdGljIHZvaWQgZnJlZV9jb21iaW5lZF9wYWlyKHN0cnVjdCBkaWZmX2ZpbGVwYWlyICpwYWlyKQp7CglmcmVlKHBhaXItPnR3byk7CglmcmVlKHBhaXIpOwp9CgovKgogKiBBIGNvbWJpbmVfZGlmZl9wYXRoIGV4cHJlc3NlcyBOIHBhcmVudHMgb24gdGhlIExIUyBhZ2FpbnN0IDEgbWVyZ2UKICogcmVzdWx0LiBTeW50aGVzaXplIGEgZGlmZl9maWxlcGFpciB0aGF0IGhhcyBOIGVudHJpZXMgb24gdGhlICJvbmUiCiAqIHNpZGUgYW5kIDEgZW50cnkgb24gdGhlICJ0d28iIHNpZGUuCiAqCiAqIEluIHRoZSBmdXR1cmUsIHdlIG1pZ2h0IHdhbnQgdG8gYWRkIG1vcmUgZGF0YSB0byBjb21iaW5lX2RpZmZfcGF0aAogKiBzbyB0aGF0IHdlIGNhbiBmaWxsIGZpZWxkcyB3ZSBhcmUgaWdub3JpbmcgKG1vc3Qgbm90YWJseSwgc2l6ZSkgaGVyZSwKICogYnV0IGN1cnJlbnRseSBub2JvZHkgdXNlcyBpdCwgc28gdGhpcyBzaG91bGQgc3VmZmljZSBmb3Igbm93LgogKi8Kc3RhdGljIHN0cnVjdCBkaWZmX2ZpbGVwYWlyICpjb21iaW5lZF9wYWlyKHN0cnVjdCBjb21iaW5lX2RpZmZfcGF0aCAqcCwKCQkJCQkgICBpbnQgbnVtX3BhcmVudCkKewoJaW50IGk7CglzdHJ1Y3QgZGlmZl9maWxlcGFpciAqcGFpcjsKCXN0cnVjdCBkaWZmX2ZpbGVzcGVjICpwb29sOwoKCXBhaXIgPSB4bWFsbG9jKHNpemVvZigqcGFpcikpOwoJcG9vbCA9IHhjYWxsb2Moc3RfYWRkKG51bV9wYXJlbnQsIDEpLCBzaXplb2Yoc3RydWN0IGRpZmZfZmlsZXNwZWMpKTsKCXBhaXItPm9uZSA9IHBvb2wgKyAxOwoJcGFpci0+dHdvID0gcG9vbDsKCglmb3IgKGkgPSAwOyBpIDwgbnVtX3BhcmVudDsgaSsrKSB7CgkJcGFpci0+b25lW2ldLnBhdGggPSBwLT5wYXRoOwoJCXBhaXItPm9uZVtpXS5tb2RlID0gcC0+cGFyZW50W2ldLm1vZGU7CgkJb2lkY3B5KCZwYWlyLT5vbmVbaV0ub2lkLCAmcC0+cGFyZW50W2ldLm9pZCk7CgkJcGFpci0+b25lW2ldLm9pZF92YWxpZCA9ICFpc19udWxsX29pZCgmcC0+cGFyZW50W2ldLm9pZCk7CgkJcGFpci0+b25lW2ldLmhhc19tb3JlX2VudHJpZXMgPSAxOwoJfQoJcGFpci0+b25lW251bV9wYXJlbnQgLSAxXS5oYXNfbW9yZV9lbnRyaWVzID0gMDsKCglwYWlyLT50d28tPnBhdGggPSBwLT5wYXRoOwoJcGFpci0+dHdvLT5tb2RlID0gcC0+bW9kZTsKCW9pZGNweSgmcGFpci0+dHdvLT5vaWQsICZwLT5vaWQpOwoJcGFpci0+dHdvLT5vaWRfdmFsaWQgPSAhaXNfbnVsbF9vaWQoJnAtPm9pZCk7CglyZXR1cm4gcGFpcjsKfQoKc3RhdGljIHZvaWQgaGFuZGxlX2NvbWJpbmVkX2NhbGxiYWNrKHN0cnVjdCBkaWZmX29wdGlvbnMgKm9wdCwKCQkJCSAgICAgc3RydWN0IGNvbWJpbmVfZGlmZl9wYXRoICpwYXRocywKCQkJCSAgICAgaW50IG51bV9wYXJlbnQsCgkJCQkgICAgIGludCBudW1fcGF0aHMpCnsKCXN0cnVjdCBjb21iaW5lX2RpZmZfcGF0aCAqcDsKCXN0cnVjdCBkaWZmX3F1ZXVlX3N0cnVjdCBxOwoJaW50IGk7CgoJcS5xdWV1ZSA9IHhjYWxsb2MobnVtX3BhdGhzLCBzaXplb2Yoc3RydWN0IGRpZmZfZmlsZXBhaXIgKikpOwoJcS5hbGxvYyA9IG51bV9wYXRoczsKCXEubnIgPSBudW1fcGF0aHM7Cglmb3IgKGkgPSAwLCBwID0gcGF0aHM7IHA7IHAgPSBwLT5uZXh0KQoJCXEucXVldWVbaSsrXSA9IGNvbWJpbmVkX3BhaXIocCwgbnVtX3BhcmVudCk7CglvcHQtPmZvcm1hdF9jYWxsYmFjaygmcSwgb3B0LCBvcHQtPmZvcm1hdF9jYWxsYmFja19kYXRhKTsKCWZvciAoaSA9IDA7IGkgPCBudW1fcGF0aHM7IGkrKykKCQlmcmVlX2NvbWJpbmVkX3BhaXIocS5xdWV1ZVtpXSk7CglmcmVlKHEucXVldWUpOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqcGF0aF9wYXRoKHZvaWQgKm9iaikKewoJc3RydWN0IGNvbWJpbmVfZGlmZl9wYXRoICpwYXRoID0gKHN0cnVjdCBjb21iaW5lX2RpZmZfcGF0aCAqKW9iajsKCglyZXR1cm4gcGF0aC0+cGF0aDsKfQoKLyoKICogRGlmZiBzdGF0IGZvcm1hdHMgd2hpY2ggd2UgYWx3YXlzIGNvbXB1dGUgc29sZWx5IGFnYWluc3QgdGhlIGZpcnN0IHBhcmVudC4KICovCiNkZWZpbmUgU1RBVF9GT1JNQVRfTUFTSyAoRElGRl9GT1JNQVRfTlVNU1RBVCBcCgkJCSAgfCBESUZGX0ZPUk1BVF9TSE9SVFNUQVQgXAoJCQkgIHwgRElGRl9GT1JNQVRfU1VNTUFSWSBcCgkJCSAgfCBESUZGX0ZPUk1BVF9ESVJTVEFUIFwKCQkJICB8IERJRkZfRk9STUFUX0RJRkZTVEFUKQoKLyogZmluZCBzZXQgb2YgcGF0aHMgdGhhdCBldmVyeSBwYXJlbnQgdG91Y2hlcyAqLwpzdGF0aWMgc3RydWN0IGNvbWJpbmVfZGlmZl9wYXRoICpmaW5kX3BhdGhzX2dlbmVyaWMoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJY29uc3Qgc3RydWN0IG9pZF9hcnJheSAqcGFyZW50cywKCXN0cnVjdCBkaWZmX29wdGlvbnMgKm9wdCwKCWludCBjb21iaW5lZF9hbGxfcGF0aHMpCnsKCXN0cnVjdCBjb21iaW5lX2RpZmZfcGF0aCAqcGF0aHMgPSBOVUxMOwoJaW50IGksIG51bV9wYXJlbnQgPSBwYXJlbnRzLT5ucjsKCglpbnQgb3V0cHV0X2Zvcm1hdCA9IG9wdC0+b3V0cHV0X2Zvcm1hdDsKCWNvbnN0IGNoYXIgKm9yZGVyZmlsZSA9IG9wdC0+b3JkZXJmaWxlOwoKCW9wdC0+b3V0cHV0X2Zvcm1hdCA9IERJRkZfRk9STUFUX05PX09VVFBVVDsKCS8qIHRlbGwgZGlmZl90cmVlIHRvIGVtaXQgcGF0aHMgaW4gc29ydGVkICg9dHJlZSkgb3JkZXIgKi8KCW9wdC0+b3JkZXJmaWxlID0gTlVMTDsKCgkvKiBEKEEsUDEuLi5QbikgPSBEKEEsUDEpIF4gLi4uIF4gRChBLFBuKSAgKHdydCBwYXRocykgKi8KCWZvciAoaSA9IDA7IGkgPCBudW1fcGFyZW50OyBpKyspIHsKCQkvKgoJCSAqIHNob3cgc3RhdCBhZ2FpbnN0IHRoZSBmaXJzdCBwYXJlbnQgZXZlbiB3aGVuIGRvaW5nCgkJICogY29tYmluZWQgZGlmZi4KCQkgKi8KCQlpbnQgc3RhdF9vcHQgPSBvdXRwdXRfZm9ybWF0ICYgU1RBVF9GT1JNQVRfTUFTSzsKCQlpZiAoaSA9PSAwICYmIHN0YXRfb3B0KQoJCQlvcHQtPm91dHB1dF9mb3JtYXQgPSBzdGF0X29wdDsKCQllbHNlCgkJCW9wdC0+b3V0cHV0X2Zvcm1hdCA9IERJRkZfRk9STUFUX05PX09VVFBVVDsKCQlkaWZmX3RyZWVfb2lkKCZwYXJlbnRzLT5vaWRbaV0sIG9pZCwgIiIsIG9wdCk7CgkJZGlmZmNvcmVfc3RkKG9wdCk7CgkJcGF0aHMgPSBpbnRlcnNlY3RfcGF0aHMocGF0aHMsIGksIG51bV9wYXJlbnQsCgkJCQkJY29tYmluZWRfYWxsX3BhdGhzKTsKCgkJLyogaWYgc2hvd2luZyBkaWZmLCBzaG93IGl0IGluIHJlcXVlc3RlZCBvcmRlciAqLwoJCWlmIChvcHQtPm91dHB1dF9mb3JtYXQgIT0gRElGRl9GT1JNQVRfTk9fT1VUUFVUICYmCgkJICAgIG9yZGVyZmlsZSkgewoJCQlkaWZmY29yZV9vcmRlcihvcmRlcmZpbGUpOwoJCX0KCgkJZGlmZl9mbHVzaChvcHQpOwoJfQoKCW9wdC0+b3V0cHV0X2Zvcm1hdCA9IG91dHB1dF9mb3JtYXQ7CglvcHQtPm9yZGVyZmlsZSA9IG9yZGVyZmlsZTsKCXJldHVybiBwYXRoczsKfQoKCi8qCiAqIGZpbmQgc2V0IG9mIHBhdGhzIHRoYXQgZXZlcnlib2R5IHRvdWNoZXMsIGFzc3VtaW5nIGRpZmYgaXMgcnVuIHdpdGhvdXQKICogcmVuYW1lL2NvcHkgZGV0ZWN0aW9uLCBldGMsIGNvbXBhcmluZyBhbGwgdHJlZXMgc2ltdWx0YW5lb3VzbHkgKD0gZmFzdGVyKS4KICovCnN0YXRpYyBzdHJ1Y3QgY29tYmluZV9kaWZmX3BhdGggKmZpbmRfcGF0aHNfbXVsdGl0cmVlKAoJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBjb25zdCBzdHJ1Y3Qgb2lkX2FycmF5ICpwYXJlbnRzLAoJc3RydWN0IGRpZmZfb3B0aW9ucyAqb3B0KQp7CglpbnQgaSwgbnBhcmVudCA9IHBhcmVudHMtPm5yOwoJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqKnBhcmVudHNfb2lkOwoJc3RydWN0IGNvbWJpbmVfZGlmZl9wYXRoIHBhdGhzX2hlYWQ7CglzdHJ1Y3Qgc3RyYnVmIGJhc2U7CgoJQUxMT0NfQVJSQVkocGFyZW50c19vaWQsIG5wYXJlbnQpOwoJZm9yIChpID0gMDsgaSA8IG5wYXJlbnQ7IGkrKykKCQlwYXJlbnRzX29pZFtpXSA9ICZwYXJlbnRzLT5vaWRbaV07CgoJLyogZmFrZSBsaXN0IGhlYWQsIHNvIHdvcmtlciBjYW4gYXNzdW1lIGl0IGlzIG5vbi1OVUxMICovCglwYXRoc19oZWFkLm5leHQgPSBOVUxMOwoKCXN0cmJ1Zl9pbml0KCZiYXNlLCBQQVRIX01BWCk7CglkaWZmX3RyZWVfcGF0aHMoJnBhdGhzX2hlYWQsIG9pZCwgcGFyZW50c19vaWQsIG5wYXJlbnQsICZiYXNlLCBvcHQpOwoKCXN0cmJ1Zl9yZWxlYXNlKCZiYXNlKTsKCWZyZWUocGFyZW50c19vaWQpOwoJcmV0dXJuIHBhdGhzX2hlYWQubmV4dDsKfQoKCnZvaWQgZGlmZl90cmVlX2NvbWJpbmVkKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJY29uc3Qgc3RydWN0IG9pZF9hcnJheSAqcGFyZW50cywKCQkJaW50IGRlbnNlLAoJCQlzdHJ1Y3QgcmV2X2luZm8gKnJldikKewoJc3RydWN0IGRpZmZfb3B0aW9ucyAqb3B0ID0gJnJldi0+ZGlmZm9wdDsKCXN0cnVjdCBkaWZmX29wdGlvbnMgZGlmZm9wdHM7CglzdHJ1Y3QgY29tYmluZV9kaWZmX3BhdGggKnAsICpwYXRoczsKCWludCBpLCBudW1fcGF0aHMsIG5lZWRzZXAsIHNob3dfbG9nX2ZpcnN0LCBudW1fcGFyZW50ID0gcGFyZW50cy0+bnI7CglpbnQgbmVlZF9nZW5lcmljX3BhdGhzY2FuOwoKCS8qIG5vdGhpbmcgdG8gZG8sIGlmIG5vIHBhcmVudHMgKi8KCWlmICghbnVtX3BhcmVudCkKCQlyZXR1cm47CgoJc2hvd19sb2dfZmlyc3QgPSAhIXJldi0+bG9naW5mbyAmJiAhcmV2LT5ub19jb21taXRfaWQ7CgluZWVkc2VwID0gMDsKCWlmIChzaG93X2xvZ19maXJzdCkgewoJCXNob3dfbG9nKHJldik7CgoJCWlmIChyZXYtPnZlcmJvc2VfaGVhZGVyICYmIG9wdC0+b3V0cHV0X2Zvcm1hdCAmJgoJCSAgICBvcHQtPm91dHB1dF9mb3JtYXQgIT0gRElGRl9GT1JNQVRfTk9fT1VUUFVUICYmCgkJICAgICFjb21taXRfZm9ybWF0X2lzX2VtcHR5KHJldi0+Y29tbWl0X2Zvcm1hdCkpCgkJCXByaW50ZigiJXMlYyIsIGRpZmZfbGluZV9wcmVmaXgob3B0KSwKCQkJICAgICAgIG9wdC0+bGluZV90ZXJtaW5hdGlvbik7Cgl9CgoJZGlmZm9wdHMgPSAqb3B0OwoJY29weV9wYXRoc3BlYygmZGlmZm9wdHMucGF0aHNwZWMsICZvcHQtPnBhdGhzcGVjKTsKCWRpZmZvcHRzLmZsYWdzLnJlY3Vyc2l2ZSA9IDE7CglkaWZmb3B0cy5mbGFncy5hbGxvd19leHRlcm5hbCA9IDA7CgoJLyogZmluZCBzZXQgb2YgcGF0aHMgdGhhdCBldmVyeWJvZHkgdG91Y2hlcwoJICoKCSAqIE5PVEUKCSAqCgkgKiBEaWZmY29yZSB0cmFuc2Zvcm1hdGlvbnMgYXJlIGJvdW5kIHRvIGRpZmZfZmlsZXNwZWMgYW5kIGxvZ2ljCgkgKiBjb21wYXJpbmcgdHdvIGVudHJpZXMgLSBpLmUuIHRoZXkgZG8gbm90IGFwcGx5IGRpcmVjdGx5IHRvIGNvbWJpbmUKCSAqIGRpZmYuCgkgKgoJICogSWYgc29tZSBvZiBzdWNoIHRyYW5zZm9ybWF0aW9ucyBpcyByZXF1ZXN0ZWQgLSB3ZSBsYXVuY2ggZ2VuZXJpYwoJICogcGF0aCBzY2FubmluZywgd2hpY2ggd29ya3Mgc2lnbmlmaWNhbnRseSBzbG93ZXIgY29tcGFyZWQgdG8KCSAqIHNpbXVsdGFuZW91cyBhbGwtdHJlZXMtaW4tb25lLWdvIHNjYW4gaW4gZmluZF9wYXRoc19tdWx0aXRyZWUoKS4KCSAqCgkgKiBUT0RPIHNvbWUgb2YgdGhlIGZpbHRlcnMgY291bGQgYmUgcG9ydGVkIHRvIHdvcmsgb24KCSAqIGNvbWJpbmVfZGlmZl9wYXRocyAtIGkuZS4gYWxsIGZ1bmN0aW9uYWxpdHkgdGhhdCBza2lwcyBwYXRocywgc28gaW4KCSAqIHRoZW9yeSwgd2UgY291bGQgZW5kIHVwIGhhdmluZyBvbmx5IG11bHRpdHJlZSBwYXRoIHNjYW5uaW5nLgoJICoKCSAqIE5PVEUgcGxlYXNlIGtlZXAgdGhpcyBzZW1hbnRpY2FsbHkgaW4gc3luYyB3aXRoIGRpZmZjb3JlX3N0ZCgpCgkgKi8KCW5lZWRfZ2VuZXJpY19wYXRoc2NhbiA9IG9wdC0+c2tpcF9zdGF0X3VubWF0Y2gJfHwKCQkJb3B0LT5mbGFncy5mb2xsb3dfcmVuYW1lcwl8fAoJCQlvcHQtPmJyZWFrX29wdCAhPSAtMQl8fAoJCQlvcHQtPmRldGVjdF9yZW5hbWUJfHwKCQkJKG9wdC0+cGlja2F4ZV9vcHRzICYgRElGRl9QSUNLQVhFX0tJTkRTX01BU0spCXx8CgkJCW9wdC0+ZmlsdGVyOwoKCglpZiAobmVlZF9nZW5lcmljX3BhdGhzY2FuKSB7CgkJLyoKCQkgKiBOT1RFIGdlbmVyaWMgY2FzZSBhbHNvIGhhbmRsZXMgLS1zdGF0LCBhcyBpdCBjb21wdXRlcwoJCSAqIGRpZmYoc2hhMSxwYXJlbnRfaSkgZm9yIGFsbCBpIHRvIGRvIHRoZSBqb2IsIHNwZWNpZmljYWxseQoJCSAqIGZvciBwYXJlbnQwLgoJCSAqLwoJCXBhdGhzID0gZmluZF9wYXRoc19nZW5lcmljKG9pZCwgcGFyZW50cywgJmRpZmZvcHRzLAoJCQkJCSAgIHJldi0+Y29tYmluZWRfYWxsX3BhdGhzKTsKCX0KCWVsc2UgewoJCWludCBzdGF0X29wdDsKCQlwYXRocyA9IGZpbmRfcGF0aHNfbXVsdGl0cmVlKG9pZCwgcGFyZW50cywgJmRpZmZvcHRzKTsKCgkJLyoKCQkgKiBzaG93IHN0YXQgYWdhaW5zdCB0aGUgZmlyc3QgcGFyZW50IGV2ZW4KCQkgKiB3aGVuIGRvaW5nIGNvbWJpbmVkIGRpZmYuCgkJICovCgkJc3RhdF9vcHQgPSBvcHQtPm91dHB1dF9mb3JtYXQgJiBTVEFUX0ZPUk1BVF9NQVNLOwoJCWlmIChzdGF0X29wdCkgewoJCQlkaWZmb3B0cy5vdXRwdXRfZm9ybWF0ID0gc3RhdF9vcHQ7CgoJCQlkaWZmX3RyZWVfb2lkKCZwYXJlbnRzLT5vaWRbMF0sIG9pZCwgIiIsICZkaWZmb3B0cyk7CgkJCWRpZmZjb3JlX3N0ZCgmZGlmZm9wdHMpOwoJCQlpZiAob3B0LT5vcmRlcmZpbGUpCgkJCQlkaWZmY29yZV9vcmRlcihvcHQtPm9yZGVyZmlsZSk7CgkJCWRpZmZfZmx1c2goJmRpZmZvcHRzKTsKCQl9Cgl9CgoJLyogZmluZCBvdXQgbnVtYmVyIG9mIHN1cnZpdmluZyBwYXRocyAqLwoJZm9yIChudW1fcGF0aHMgPSAwLCBwID0gcGF0aHM7IHA7IHAgPSBwLT5uZXh0KQoJCW51bV9wYXRocysrOwoKCS8qIG9yZGVyIHBhdGhzIGFjY29yZGluZyB0byBkaWZmY29yZV9vcmRlciAqLwoJaWYgKG9wdC0+b3JkZXJmaWxlICYmIG51bV9wYXRocykgewoJCXN0cnVjdCBvYmpfb3JkZXIgKm87CgoJCUFMTE9DX0FSUkFZKG8sIG51bV9wYXRocyk7CgkJZm9yIChpID0gMCwgcCA9IHBhdGhzOyBwOyBwID0gcC0+bmV4dCwgaSsrKQoJCQlvW2ldLm9iaiA9IHA7CgkJb3JkZXJfb2JqZWN0cyhvcHQtPm9yZGVyZmlsZSwgcGF0aF9wYXRoLCBvLCBudW1fcGF0aHMpOwoJCWZvciAoaSA9IDA7IGkgPCBudW1fcGF0aHMgLSAxOyBpKyspIHsKCQkJcCA9IG9baV0ub2JqOwoJCQlwLT5uZXh0ID0gb1tpKzFdLm9iajsKCQl9CgoJCXAgPSBvW251bV9wYXRocy0xXS5vYmo7CgkJcC0+bmV4dCA9IE5VTEw7CgkJcGF0aHMgPSBvWzBdLm9iajsKCQlmcmVlKG8pOwoJfQoKCglpZiAobnVtX3BhdGhzKSB7CgkJaWYgKG9wdC0+b3V0cHV0X2Zvcm1hdCAmIChESUZGX0ZPUk1BVF9SQVcgfAoJCQkJCSAgRElGRl9GT1JNQVRfTkFNRSB8CgkJCQkJICBESUZGX0ZPUk1BVF9OQU1FX1NUQVRVUykpIHsKCQkJZm9yIChwID0gcGF0aHM7IHA7IHAgPSBwLT5uZXh0KQoJCQkJc2hvd19yYXdfZGlmZihwLCBudW1fcGFyZW50LCByZXYpOwoJCQluZWVkc2VwID0gMTsKCQl9CgkJZWxzZSBpZiAob3B0LT5vdXRwdXRfZm9ybWF0ICYgU1RBVF9GT1JNQVRfTUFTSykKCQkJbmVlZHNlcCA9IDE7CgkJZWxzZSBpZiAob3B0LT5vdXRwdXRfZm9ybWF0ICYgRElGRl9GT1JNQVRfQ0FMTEJBQ0spCgkJCWhhbmRsZV9jb21iaW5lZF9jYWxsYmFjayhvcHQsIHBhdGhzLCBudW1fcGFyZW50LCBudW1fcGF0aHMpOwoKCQlpZiAob3B0LT5vdXRwdXRfZm9ybWF0ICYgRElGRl9GT1JNQVRfUEFUQ0gpIHsKCQkJaWYgKG5lZWRzZXApCgkJCQlwcmludGYoIiVzJWMiLCBkaWZmX2xpbmVfcHJlZml4KG9wdCksCgkJCQkgICAgICAgb3B0LT5saW5lX3Rlcm1pbmF0aW9uKTsKCQkJZm9yIChwID0gcGF0aHM7IHA7IHAgPSBwLT5uZXh0KQoJCQkJc2hvd19wYXRjaF9kaWZmKHAsIG51bV9wYXJlbnQsIGRlbnNlLAoJCQkJCQkwLCByZXYpOwoJCX0KCX0KCgkvKiBDbGVhbiB0aGluZ3MgdXAgKi8KCXdoaWxlIChwYXRocykgewoJCXN0cnVjdCBjb21iaW5lX2RpZmZfcGF0aCAqdG1wID0gcGF0aHM7CgkJcGF0aHMgPSBwYXRocy0+bmV4dDsKCQlmb3IgKGkgPSAwOyBpIDwgbnVtX3BhcmVudDsgaSsrKQoJCQlpZiAocmV2LT5jb21iaW5lZF9hbGxfcGF0aHMgJiYKCQkJICAgIGZpbGVuYW1lX2NoYW5nZWQodG1wLT5wYXJlbnRbaV0uc3RhdHVzKSkKCQkJCXN0cmJ1Zl9yZWxlYXNlKCZ0bXAtPnBhcmVudFtpXS5wYXRoKTsKCQlmcmVlKHRtcCk7Cgl9CgoJY2xlYXJfcGF0aHNwZWMoJmRpZmZvcHRzLnBhdGhzcGVjKTsKfQoKdm9pZCBkaWZmX3RyZWVfY29tYmluZWRfbWVyZ2UoY29uc3Qgc3RydWN0IGNvbW1pdCAqY29tbWl0LCBpbnQgZGVuc2UsCgkJCSAgICAgIHN0cnVjdCByZXZfaW5mbyAqcmV2KQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudCA9IGdldF9zYXZlZF9wYXJlbnRzKHJldiwgY29tbWl0KTsKCXN0cnVjdCBvaWRfYXJyYXkgcGFyZW50cyA9IE9JRF9BUlJBWV9JTklUOwoKCXdoaWxlIChwYXJlbnQpIHsKCQlvaWRfYXJyYXlfYXBwZW5kKCZwYXJlbnRzLCAmcGFyZW50LT5pdGVtLT5vYmplY3Qub2lkKTsKCQlwYXJlbnQgPSBwYXJlbnQtPm5leHQ7Cgl9CglkaWZmX3RyZWVfY29tYmluZWQoJmNvbW1pdC0+b2JqZWN0Lm9pZCwgJnBhcmVudHMsIGRlbnNlLCByZXYpOwoJb2lkX2FycmF5X2NsZWFyKCZwYXJlbnRzKTsKfQo=",
    "text": "#include \"cache.h\"\n#include \"object-store.h\"\n#include \"commit.h\"\n#include \"blob.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"quote.h\"\n#include \"xdiff-interface.h\"\n#include \"xdiff/xmacros.h\"\n#include \"log-tree.h\"\n#include \"refs.h\"\n#include \"userdiff.h\"\n#include \"oid-array.h\"\n#include \"revision.h\"\n\nstatic int compare_paths(const struct combine_diff_path *one,\n\t\t\t  const struct diff_filespec *two)\n{\n\tif (!S_ISDIR(one->mode) && !S_ISDIR(two->mode))\n\t\treturn strcmp(one->path, two->path);\n\n\treturn base_name_compare(one->path, strlen(one->path), one->mode,\n\t\t\t\t two->path, strlen(two->path), two->mode);\n}\n\nstatic int filename_changed(char status)\n{\n\treturn status == 'R' || status == 'C';\n}\n\nstatic struct combine_diff_path *intersect_paths(\n\tstruct combine_diff_path *curr,\n\tint n,\n\tint num_parent,\n\tint combined_all_paths)\n{\n\tstruct diff_queue_struct *q = &diff_queued_diff;\n\tstruct combine_diff_path *p, **tail = &curr;\n\tint i, j, cmp;\n\n\tif (!n) {\n\t\tfor (i = 0; i < q->nr; i++) {\n\t\t\tint len;\n\t\t\tconst char *path;\n\t\t\tif (diff_unmodified_pair(q->queue[i]))\n\t\t\t\tcontinue;\n\t\t\tpath = q->queue[i]->two->path;\n\t\t\tlen = strlen(path);\n\t\t\tp = xmalloc(combine_diff_path_size(num_parent, len));\n\t\t\tp->path = (char *) &(p->parent[num_parent]);\n\t\t\tmemcpy(p->path, path, len);\n\t\t\tp->path[len] = 0;\n\t\t\tp->next = NULL;\n\t\t\tmemset(p->parent, 0,\n\t\t\t       sizeof(p->parent[0]) * num_parent);\n\n\t\t\toidcpy(&p->oid, &q->queue[i]->two->oid);\n\t\t\tp->mode = q->queue[i]->two->mode;\n\t\t\toidcpy(&p->parent[n].oid, &q->queue[i]->one->oid);\n\t\t\tp->parent[n].mode = q->queue[i]->one->mode;\n\t\t\tp->parent[n].status = q->queue[i]->status;\n\n\t\t\tif (combined_all_paths &&\n\t\t\t    filename_changed(p->parent[n].status)) {\n\t\t\t\tstrbuf_init(&p->parent[n].path, 0);\n\t\t\t\tstrbuf_addstr(&p->parent[n].path,\n\t\t\t\t\t      q->queue[i]->one->path);\n\t\t\t}\n\t\t\t*tail = p;\n\t\t\ttail = &p->next;\n\t\t}\n\t\treturn curr;\n\t}\n\n\t/*\n\t * paths in curr (linked list) and q->queue[] (array) are\n\t * both sorted in the tree order.\n\t */\n\ti = 0;\n\twhile ((p = *tail) != NULL) {\n\t\tcmp = ((i >= q->nr)\n\t\t       ? -1 : compare_paths(p, q->queue[i]->two));\n\n\t\tif (cmp < 0) {\n\t\t\t/* p->path not in q->queue[]; drop it */\n\t\t\t*tail = p->next;\n\t\t\tfor (j = 0; j < num_parent; j++)\n\t\t\t\tif (combined_all_paths &&\n\t\t\t\t    filename_changed(p->parent[j].status))\n\t\t\t\t\tstrbuf_release(&p->parent[j].path);\n\t\t\tfree(p);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cmp > 0) {\n\t\t\t/* q->queue[i] not in p->path; skip it */\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\toidcpy(&p->parent[n].oid, &q->queue[i]->one->oid);\n\t\tp->parent[n].mode = q->queue[i]->one->mode;\n\t\tp->parent[n].status = q->queue[i]->status;\n\t\tif (combined_all_paths &&\n\t\t    filename_changed(p->parent[n].status))\n\t\t\tstrbuf_addstr(&p->parent[n].path,\n\t\t\t\t      q->queue[i]->one->path);\n\n\t\ttail = &p->next;\n\t\ti++;\n\t}\n\treturn curr;\n}\n\n/* Lines lost from parent */\nstruct lline {\n\tstruct lline *next, *prev;\n\tint len;\n\tunsigned long parent_map;\n\tchar line[FLEX_ARRAY];\n};\n\n/* Lines lost from current parent (before coalescing) */\nstruct plost {\n\tstruct lline *lost_head, *lost_tail;\n\tint len;\n};\n\n/* Lines surviving in the merge result */\nstruct sline {\n\t/* Accumulated and coalesced lost lines */\n\tstruct lline *lost;\n\tint lenlost;\n\tstruct plost plost;\n\tchar *bol;\n\tint len;\n\t/* bit 0 up to (N-1) are on if the parent has this line (i.e.\n\t * we did not change it).\n\t * bit N is used for \"interesting\" lines, including context.\n\t * bit (N+1) is used for \"do not show deletion before this\".\n\t */\n\tunsigned long flag;\n\tunsigned long *p_lno;\n};\n\nstatic int match_string_spaces(const char *line1, int len1,\n\t\t\t       const char *line2, int len2,\n\t\t\t       long flags)\n{\n\tif (flags & XDF_WHITESPACE_FLAGS) {\n\t\tfor (; len1 > 0 && XDL_ISSPACE(line1[len1 - 1]); len1--);\n\t\tfor (; len2 > 0 && XDL_ISSPACE(line2[len2 - 1]); len2--);\n\t}\n\n\tif (!(flags & (XDF_IGNORE_WHITESPACE | XDF_IGNORE_WHITESPACE_CHANGE)))\n\t\treturn (len1 == len2 && !memcmp(line1, line2, len1));\n\n\twhile (len1 > 0 && len2 > 0) {\n\t\tlen1--;\n\t\tlen2--;\n\t\tif (XDL_ISSPACE(line1[len1]) || XDL_ISSPACE(line2[len2])) {\n\t\t\tif ((flags & XDF_IGNORE_WHITESPACE_CHANGE) &&\n\t\t\t    (!XDL_ISSPACE(line1[len1]) || !XDL_ISSPACE(line2[len2])))\n\t\t\t\treturn 0;\n\n\t\t\tfor (; len1 > 0 && XDL_ISSPACE(line1[len1]); len1--);\n\t\t\tfor (; len2 > 0 && XDL_ISSPACE(line2[len2]); len2--);\n\t\t}\n\t\tif (line1[len1] != line2[len2])\n\t\t\treturn 0;\n\t}\n\n\tif (flags & XDF_IGNORE_WHITESPACE) {\n\t\t/* Consume remaining spaces */\n\t\tfor (; len1 > 0 && XDL_ISSPACE(line1[len1 - 1]); len1--);\n\t\tfor (; len2 > 0 && XDL_ISSPACE(line2[len2 - 1]); len2--);\n\t}\n\n\t/* We matched full line1 and line2 */\n\tif (!len1 && !len2)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nenum coalesce_direction { MATCH, BASE, NEW };\n\n/* Coalesce new lines into base by finding LCS */\nstatic struct lline *coalesce_lines(struct lline *base, int *lenbase,\n\t\t\t\t    struct lline *newline, int lennew,\n\t\t\t\t    unsigned long parent, long flags)\n{\n\tint **lcs;\n\tenum coalesce_direction **directions;\n\tstruct lline *baseend, *newend = NULL;\n\tint i, j, origbaselen = *lenbase;\n\n\tif (newline == NULL)\n\t\treturn base;\n\n\tif (base == NULL) {\n\t\t*lenbase = lennew;\n\t\treturn newline;\n\t}\n\n\t/*\n\t * Coalesce new lines into base by finding the LCS\n\t * - Create the table to run dynamic programming\n\t * - Compute the LCS\n\t * - Then reverse read the direction structure:\n\t *   - If we have MATCH, assign parent to base flag, and consume\n\t *   both baseend and newend\n\t *   - Else if we have BASE, consume baseend\n\t *   - Else if we have NEW, insert newend lline into base and\n\t *   consume newend\n\t */\n\tlcs = xcalloc(st_add(origbaselen, 1), sizeof(int*));\n\tdirections = xcalloc(st_add(origbaselen, 1), sizeof(enum coalesce_direction*));\n\tfor (i = 0; i < origbaselen + 1; i++) {\n\t\tlcs[i] = xcalloc(st_add(lennew, 1), sizeof(int));\n\t\tdirections[i] = xcalloc(st_add(lennew, 1), sizeof(enum coalesce_direction));\n\t\tdirections[i][0] = BASE;\n\t}\n\tfor (j = 1; j < lennew + 1; j++)\n\t\tdirections[0][j] = NEW;\n\n\tfor (i = 1, baseend = base; i < origbaselen + 1; i++) {\n\t\tfor (j = 1, newend = newline; j < lennew + 1; j++) {\n\t\t\tif (match_string_spaces(baseend->line, baseend->len,\n\t\t\t\t\t\tnewend->line, newend->len, flags)) {\n\t\t\t\tlcs[i][j] = lcs[i - 1][j - 1] + 1;\n\t\t\t\tdirections[i][j] = MATCH;\n\t\t\t} else if (lcs[i][j - 1] >= lcs[i - 1][j]) {\n\t\t\t\tlcs[i][j] = lcs[i][j - 1];\n\t\t\t\tdirections[i][j] = NEW;\n\t\t\t} else {\n\t\t\t\tlcs[i][j] = lcs[i - 1][j];\n\t\t\t\tdirections[i][j] = BASE;\n\t\t\t}\n\t\t\tif (newend->next)\n\t\t\t\tnewend = newend->next;\n\t\t}\n\t\tif (baseend->next)\n\t\t\tbaseend = baseend->next;\n\t}\n\n\tfor (i = 0; i < origbaselen + 1; i++)\n\t\tfree(lcs[i]);\n\tfree(lcs);\n\n\t/* At this point, baseend and newend point to the end of each lists */\n\ti--;\n\tj--;\n\twhile (i != 0 || j != 0) {\n\t\tif (directions[i][j] == MATCH) {\n\t\t\tbaseend->parent_map |= 1<<parent;\n\t\t\tbaseend = baseend->prev;\n\t\t\tnewend = newend->prev;\n\t\t\ti--;\n\t\t\tj--;\n\t\t} else if (directions[i][j] == NEW) {\n\t\t\tstruct lline *lline;\n\n\t\t\tlline = newend;\n\t\t\t/* Remove lline from new list and update newend */\n\t\t\tif (lline->prev)\n\t\t\t\tlline->prev->next = lline->next;\n\t\t\telse\n\t\t\t\tnewline = lline->next;\n\t\t\tif (lline->next)\n\t\t\t\tlline->next->prev = lline->prev;\n\n\t\t\tnewend = lline->prev;\n\t\t\tj--;\n\n\t\t\t/* Add lline to base list */\n\t\t\tif (baseend) {\n\t\t\t\tlline->next = baseend->next;\n\t\t\t\tlline->prev = baseend;\n\t\t\t\tif (lline->prev)\n\t\t\t\t\tlline->prev->next = lline;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlline->next = base;\n\t\t\t\tbase = lline;\n\t\t\t}\n\t\t\t(*lenbase)++;\n\n\t\t\tif (lline->next)\n\t\t\t\tlline->next->prev = lline;\n\n\t\t} else {\n\t\t\tbaseend = baseend->prev;\n\t\t\ti--;\n\t\t}\n\t}\n\n\tnewend = newline;\n\twhile (newend) {\n\t\tstruct lline *lline = newend;\n\t\tnewend = newend->next;\n\t\tfree(lline);\n\t}\n\n\tfor (i = 0; i < origbaselen + 1; i++)\n\t\tfree(directions[i]);\n\tfree(directions);\n\n\treturn base;\n}\n\nstatic char *grab_blob(struct repository *r,\n\t\t       const struct object_id *oid, unsigned int mode,\n\t\t       unsigned long *size, struct userdiff_driver *textconv,\n\t\t       const char *path)\n{\n\tchar *blob;\n\tenum object_type type;\n\n\tif (S_ISGITLINK(mode)) {\n\t\tstruct strbuf buf = STRBUF_INIT;\n\t\tstrbuf_addf(&buf, \"Subproject commit %s\\n\", oid_to_hex(oid));\n\t\t*size = buf.len;\n\t\tblob = strbuf_detach(&buf, NULL);\n\t} else if (is_null_oid(oid)) {\n\t\t/* deleted blob */\n\t\t*size = 0;\n\t\treturn xcalloc(1, 1);\n\t} else if (textconv) {\n\t\tstruct diff_filespec *df = alloc_filespec(path);\n\t\tfill_filespec(df, oid, 1, mode);\n\t\t*size = fill_textconv(r, textconv, df, &blob);\n\t\tfree_filespec(df);\n\t} else {\n\t\tblob = read_object_file(oid, &type, size);\n\t\tif (type != OBJ_BLOB)\n\t\t\tdie(\"object '%s' is not a blob!\", oid_to_hex(oid));\n\t}\n\treturn blob;\n}\n\nstatic void append_lost(struct sline *sline, int n, const char *line, int len)\n{\n\tstruct lline *lline;\n\tunsigned long this_mask = (1UL<<n);\n\tif (line[len-1] == '\\n')\n\t\tlen--;\n\n\tFLEX_ALLOC_MEM(lline, line, line, len);\n\tlline->len = len;\n\tlline->next = NULL;\n\tlline->prev = sline->plost.lost_tail;\n\tif (lline->prev)\n\t\tlline->prev->next = lline;\n\telse\n\t\tsline->plost.lost_head = lline;\n\tsline->plost.lost_tail = lline;\n\tsline->plost.len++;\n\tlline->parent_map = this_mask;\n}\n\nstruct combine_diff_state {\n\tunsigned int lno;\n\tint ob, on, nb, nn;\n\tunsigned long nmask;\n\tint num_parent;\n\tint n;\n\tstruct sline *sline;\n\tstruct sline *lost_bucket;\n};\n\nstatic void consume_hunk(void *state_,\n\t\t\t long ob, long on,\n\t\t\t long nb, long nn,\n\t\t\t const char *funcline, long funclen)\n{\n\tstruct combine_diff_state *state = state_;\n\n\tstate->ob = ob;\n\tstate->on = on;\n\tstate->nb = nb;\n\tstate->nn = nn;\n\tstate->lno = state->nb;\n\tif (state->nn == 0) {\n\t\t/* @@ -X,Y +N,0 @@ removed Y lines\n\t\t * that would have come *after* line N\n\t\t * in the result.  Our lost buckets hang\n\t\t * to the line after the removed lines,\n\t\t *\n\t\t * Note that this is correct even when N == 0,\n\t\t * in which case the hunk removes the first\n\t\t * line in the file.\n\t\t */\n\t\tstate->lost_bucket = &state->sline[state->nb];\n\t\tif (!state->nb)\n\t\t\tstate->nb = 1;\n\t} else {\n\t\tstate->lost_bucket = &state->sline[state->nb-1];\n\t}\n\tif (!state->sline[state->nb-1].p_lno)\n\t\tstate->sline[state->nb-1].p_lno =\n\t\t\txcalloc(state->num_parent, sizeof(unsigned long));\n\tstate->sline[state->nb-1].p_lno[state->n] = state->ob;\n}\n\nstatic void consume_line(void *state_, char *line, unsigned long len)\n{\n\tstruct combine_diff_state *state = state_;\n\tif (!state->lost_bucket)\n\t\treturn; /* not in any hunk yet */\n\tswitch (line[0]) {\n\tcase '-':\n\t\tappend_lost(state->lost_bucket, state->n, line+1, len-1);\n\t\tbreak;\n\tcase '+':\n\t\tstate->sline[state->lno-1].flag |= state->nmask;\n\t\tstate->lno++;\n\t\tbreak;\n\t}\n}\n\nstatic void combine_diff(struct repository *r,\n\t\t\t const struct object_id *parent, unsigned int mode,\n\t\t\t mmfile_t *result_file,\n\t\t\t struct sline *sline, unsigned int cnt, int n,\n\t\t\t int num_parent, int result_deleted,\n\t\t\t struct userdiff_driver *textconv,\n\t\t\t const char *path, long flags)\n{\n\tunsigned int p_lno, lno;\n\tunsigned long nmask = (1UL << n);\n\txpparam_t xpp;\n\txdemitconf_t xecfg;\n\tmmfile_t parent_file;\n\tstruct combine_diff_state state;\n\tunsigned long sz;\n\n\tif (result_deleted)\n\t\treturn; /* result deleted */\n\n\tparent_file.ptr = grab_blob(r, parent, mode, &sz, textconv, path);\n\tparent_file.size = sz;\n\tmemset(&xpp, 0, sizeof(xpp));\n\txpp.flags = flags;\n\tmemset(&xecfg, 0, sizeof(xecfg));\n\tmemset(&state, 0, sizeof(state));\n\tstate.nmask = nmask;\n\tstate.sline = sline;\n\tstate.lno = 1;\n\tstate.num_parent = num_parent;\n\tstate.n = n;\n\n\tif (xdi_diff_outf(&parent_file, result_file, consume_hunk,\n\t\t\t  consume_line, &state, &xpp, &xecfg))\n\t\tdie(\"unable to generate combined diff for %s\",\n\t\t    oid_to_hex(parent));\n\tfree(parent_file.ptr);\n\n\t/* Assign line numbers for this parent.\n\t *\n\t * sline[lno].p_lno[n] records the first line number\n\t * (counting from 1) for parent N if the final hunk display\n\t * started by showing sline[lno] (possibly showing the lost\n\t * lines attached to it first).\n\t */\n\tfor (lno = 0,  p_lno = 1; lno <= cnt; lno++) {\n\t\tstruct lline *ll;\n\t\tsline[lno].p_lno[n] = p_lno;\n\n\t\t/* Coalesce new lines */\n\t\tif (sline[lno].plost.lost_head) {\n\t\t\tstruct sline *sl = &sline[lno];\n\t\t\tsl->lost = coalesce_lines(sl->lost, &sl->lenlost,\n\t\t\t\t\t\t  sl->plost.lost_head,\n\t\t\t\t\t\t  sl->plost.len, n, flags);\n\t\t\tsl->plost.lost_head = sl->plost.lost_tail = NULL;\n\t\t\tsl->plost.len = 0;\n\t\t}\n\n\t\t/* How many lines would this sline advance the p_lno? */\n\t\tll = sline[lno].lost;\n\t\twhile (ll) {\n\t\t\tif (ll->parent_map & nmask)\n\t\t\t\tp_lno++; /* '-' means parent had it */\n\t\t\tll = ll->next;\n\t\t}\n\t\tif (lno < cnt && !(sline[lno].flag & nmask))\n\t\t\tp_lno++; /* no '+' means parent had it */\n\t}\n\tsline[lno].p_lno[n] = p_lno; /* trailer */\n}\n\nstatic unsigned long context = 3;\nstatic char combine_marker = '@';\n\nstatic int interesting(struct sline *sline, unsigned long all_mask)\n{\n\t/* If some parents lost lines here, or if we have added to\n\t * some parent, it is interesting.\n\t */\n\treturn ((sline->flag & all_mask) || sline->lost);\n}\n\nstatic unsigned long adjust_hunk_tail(struct sline *sline,\n\t\t\t\t      unsigned long all_mask,\n\t\t\t\t      unsigned long hunk_begin,\n\t\t\t\t      unsigned long i)\n{\n\t/* i points at the first uninteresting line.  If the last line\n\t * of the hunk was interesting only because it has some\n\t * deletion, then it is not all that interesting for the\n\t * purpose of giving trailing context lines.  This is because\n\t * we output '-' line and then unmodified sline[i-1] itself in\n\t * that case which gives us one extra context line.\n\t */\n\tif ((hunk_begin + 1 <= i) && !(sline[i-1].flag & all_mask))\n\t\ti--;\n\treturn i;\n}\n\nstatic unsigned long find_next(struct sline *sline,\n\t\t\t       unsigned long mark,\n\t\t\t       unsigned long i,\n\t\t\t       unsigned long cnt,\n\t\t\t       int look_for_uninteresting)\n{\n\t/* We have examined up to i-1 and are about to look at i.\n\t * Find next interesting or uninteresting line.  Here,\n\t * \"interesting\" does not mean interesting(), but marked by\n\t * the give_context() function below (i.e. it includes context\n\t * lines that are not interesting to interesting() function\n\t * that are surrounded by interesting() ones.\n\t */\n\twhile (i <= cnt)\n\t\tif (look_for_uninteresting\n\t\t    ? !(sline[i].flag & mark)\n\t\t    : (sline[i].flag & mark))\n\t\t\treturn i;\n\t\telse\n\t\t\ti++;\n\treturn i;\n}\n\nstatic int give_context(struct sline *sline, unsigned long cnt, int num_parent)\n{\n\tunsigned long all_mask = (1UL<<num_parent) - 1;\n\tunsigned long mark = (1UL<<num_parent);\n\tunsigned long no_pre_delete = (2UL<<num_parent);\n\tunsigned long i;\n\n\t/* Two groups of interesting lines may have a short gap of\n\t * uninteresting lines.  Connect such groups to give them a\n\t * bit of context.\n\t *\n\t * We first start from what the interesting() function says,\n\t * and mark them with \"mark\", and paint context lines with the\n\t * mark.  So interesting() would still say false for such context\n\t * lines but they are treated as \"interesting\" in the end.\n\t */\n\ti = find_next(sline, mark, 0, cnt, 0);\n\tif (cnt < i)\n\t\treturn 0;\n\n\twhile (i <= cnt) {\n\t\tunsigned long j = (context < i) ? (i - context) : 0;\n\t\tunsigned long k;\n\n\t\t/* Paint a few lines before the first interesting line. */\n\t\twhile (j < i) {\n\t\t\tif (!(sline[j].flag & mark))\n\t\t\t\tsline[j].flag |= no_pre_delete;\n\t\t\tsline[j++].flag |= mark;\n\t\t}\n\n\tagain:\n\t\t/* we know up to i is to be included.  where does the\n\t\t * next uninteresting one start?\n\t\t */\n\t\tj = find_next(sline, mark, i, cnt, 1);\n\t\tif (cnt < j)\n\t\t\tbreak; /* the rest are all interesting */\n\n\t\t/* lookahead context lines */\n\t\tk = find_next(sline, mark, j, cnt, 0);\n\t\tj = adjust_hunk_tail(sline, all_mask, i, j);\n\n\t\tif (k < j + context) {\n\t\t\t/* k is interesting and [j,k) are not, but\n\t\t\t * paint them interesting because the gap is small.\n\t\t\t */\n\t\t\twhile (j < k)\n\t\t\t\tsline[j++].flag |= mark;\n\t\t\ti = k;\n\t\t\tgoto again;\n\t\t}\n\n\t\t/* j is the first uninteresting line and there is\n\t\t * no overlap beyond it within context lines.  Paint\n\t\t * the trailing edge a bit.\n\t\t */\n\t\ti = k;\n\t\tk = (j + context < cnt+1) ? j + context : cnt+1;\n\t\twhile (j < k)\n\t\t\tsline[j++].flag |= mark;\n\t}\n\treturn 1;\n}\n\nstatic int make_hunks(struct sline *sline, unsigned long cnt,\n\t\t       int num_parent, int dense)\n{\n\tunsigned long all_mask = (1UL<<num_parent) - 1;\n\tunsigned long mark = (1UL<<num_parent);\n\tunsigned long i;\n\tint has_interesting = 0;\n\n\tfor (i = 0; i <= cnt; i++) {\n\t\tif (interesting(&sline[i], all_mask))\n\t\t\tsline[i].flag |= mark;\n\t\telse\n\t\t\tsline[i].flag &= ~mark;\n\t}\n\tif (!dense)\n\t\treturn give_context(sline, cnt, num_parent);\n\n\t/* Look at each hunk, and if we have changes from only one\n\t * parent, or the changes are the same from all but one\n\t * parent, mark that uninteresting.\n\t */\n\ti = 0;\n\twhile (i <= cnt) {\n\t\tunsigned long j, hunk_begin, hunk_end;\n\t\tunsigned long same_diff;\n\t\twhile (i <= cnt && !(sline[i].flag & mark))\n\t\t\ti++;\n\t\tif (cnt < i)\n\t\t\tbreak; /* No more interesting hunks */\n\t\thunk_begin = i;\n\t\tfor (j = i + 1; j <= cnt; j++) {\n\t\t\tif (!(sline[j].flag & mark)) {\n\t\t\t\t/* Look beyond the end to see if there\n\t\t\t\t * is an interesting line after this\n\t\t\t\t * hunk within context span.\n\t\t\t\t */\n\t\t\t\tunsigned long la; /* lookahead */\n\t\t\t\tint contin = 0;\n\t\t\t\tla = adjust_hunk_tail(sline, all_mask,\n\t\t\t\t\t\t     hunk_begin, j);\n\t\t\t\tla = (la + context < cnt + 1) ?\n\t\t\t\t\t(la + context) : cnt + 1;\n\t\t\t\twhile (la && j <= --la) {\n\t\t\t\t\tif (sline[la].flag & mark) {\n\t\t\t\t\t\tcontin = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!contin)\n\t\t\t\t\tbreak;\n\t\t\t\tj = la;\n\t\t\t}\n\t\t}\n\t\thunk_end = j;\n\n\t\t/* [i..hunk_end) are interesting.  Now is it really\n\t\t * interesting?  We check if there are only two versions\n\t\t * and the result matches one of them.  That is, we look\n\t\t * at:\n\t\t *   (+) line, which records lines added to which parents;\n\t\t *       this line appears in the result.\n\t\t *   (-) line, which records from what parents the line\n\t\t *       was removed; this line does not appear in the result.\n\t\t * then check the set of parents the result has difference\n\t\t * from, from all lines.  If there are lines that has\n\t\t * different set of parents that the result has differences\n\t\t * from, that means we have more than two versions.\n\t\t *\n\t\t * Even when we have only two versions, if the result does\n\t\t * not match any of the parents, the it should be considered\n\t\t * interesting.  In such a case, we would have all '+' line.\n\t\t * After passing the above \"two versions\" test, that would\n\t\t * appear as \"the same set of parents\" to be \"all parents\".\n\t\t */\n\t\tsame_diff = 0;\n\t\thas_interesting = 0;\n\t\tfor (j = i; j < hunk_end && !has_interesting; j++) {\n\t\t\tunsigned long this_diff = sline[j].flag & all_mask;\n\t\t\tstruct lline *ll = sline[j].lost;\n\t\t\tif (this_diff) {\n\t\t\t\t/* This has some changes.  Is it the\n\t\t\t\t * same as others?\n\t\t\t\t */\n\t\t\t\tif (!same_diff)\n\t\t\t\t\tsame_diff = this_diff;\n\t\t\t\telse if (same_diff != this_diff) {\n\t\t\t\t\thas_interesting = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (ll && !has_interesting) {\n\t\t\t\t/* Lost this line from these parents;\n\t\t\t\t * who are they?  Are they the same?\n\t\t\t\t */\n\t\t\t\tthis_diff = ll->parent_map;\n\t\t\t\tif (!same_diff)\n\t\t\t\t\tsame_diff = this_diff;\n\t\t\t\telse if (same_diff != this_diff) {\n\t\t\t\t\thas_interesting = 1;\n\t\t\t\t}\n\t\t\t\tll = ll->next;\n\t\t\t}\n\t\t}\n\n\t\tif (!has_interesting && same_diff != all_mask) {\n\t\t\t/* This hunk is not that interesting after all */\n\t\t\tfor (j = hunk_begin; j < hunk_end; j++)\n\t\t\t\tsline[j].flag &= ~mark;\n\t\t}\n\t\ti = hunk_end;\n\t}\n\n\thas_interesting = give_context(sline, cnt, num_parent);\n\treturn has_interesting;\n}\n\nstatic void show_parent_lno(struct sline *sline, unsigned long l0, unsigned long l1, int n, unsigned long null_context)\n{\n\tl0 = sline[l0].p_lno[n];\n\tl1 = sline[l1].p_lno[n];\n\tprintf(\" -%lu,%lu\", l0, l1-l0-null_context);\n}\n\nstatic int hunk_comment_line(const char *bol)\n{\n\tint ch;\n\n\tif (!bol)\n\t\treturn 0;\n\tch = *bol & 0xff;\n\treturn (isalpha(ch) || ch == '_' || ch == '$');\n}\n\nstatic void show_line_to_eol(const char *line, int len, const char *reset)\n{\n\tint saw_cr_at_eol = 0;\n\tif (len < 0)\n\t\tlen = strlen(line);\n\tsaw_cr_at_eol = (len && line[len-1] == '\\r');\n\n\tprintf(\"%.*s%s%s\\n\", len - saw_cr_at_eol, line,\n\t       reset,\n\t       saw_cr_at_eol ? \"\\r\" : \"\");\n}\n\nstatic void dump_sline(struct sline *sline, const char *line_prefix,\n\t\t       unsigned long cnt, int num_parent,\n\t\t       int use_color, int result_deleted)\n{\n\tunsigned long mark = (1UL<<num_parent);\n\tunsigned long no_pre_delete = (2UL<<num_parent);\n\tint i;\n\tunsigned long lno = 0;\n\tconst char *c_frag = diff_get_color(use_color, DIFF_FRAGINFO);\n\tconst char *c_func = diff_get_color(use_color, DIFF_FUNCINFO);\n\tconst char *c_new = diff_get_color(use_color, DIFF_FILE_NEW);\n\tconst char *c_old = diff_get_color(use_color, DIFF_FILE_OLD);\n\tconst char *c_context = diff_get_color(use_color, DIFF_CONTEXT);\n\tconst char *c_reset = diff_get_color(use_color, DIFF_RESET);\n\n\tif (result_deleted)\n\t\treturn; /* result deleted */\n\n\twhile (1) {\n\t\tunsigned long hunk_end;\n\t\tunsigned long rlines;\n\t\tconst char *hunk_comment = NULL;\n\t\tunsigned long null_context = 0;\n\n\t\twhile (lno <= cnt && !(sline[lno].flag & mark)) {\n\t\t\tif (hunk_comment_line(sline[lno].bol))\n\t\t\t\thunk_comment = sline[lno].bol;\n\t\t\tlno++;\n\t\t}\n\t\tif (cnt < lno)\n\t\t\tbreak;\n\t\telse {\n\t\t\tfor (hunk_end = lno + 1; hunk_end <= cnt; hunk_end++)\n\t\t\t\tif (!(sline[hunk_end].flag & mark))\n\t\t\t\t\tbreak;\n\t\t}\n\t\trlines = hunk_end - lno;\n\t\tif (cnt < hunk_end)\n\t\t\trlines--; /* pointing at the last delete hunk */\n\n\t\tif (!context) {\n\t\t\t/*\n\t\t\t * Even when running with --unified=0, all\n\t\t\t * lines in the hunk needs to be processed in\n\t\t\t * the loop below in order to show the\n\t\t\t * deletion recorded in lost_head.  However,\n\t\t\t * we do not want to show the resulting line\n\t\t\t * with all blank context markers in such a\n\t\t\t * case.  Compensate.\n\t\t\t */\n\t\t\tunsigned long j;\n\t\t\tfor (j = lno; j < hunk_end; j++)\n\t\t\t\tif (!(sline[j].flag & (mark-1)))\n\t\t\t\t\tnull_context++;\n\t\t\trlines -= null_context;\n\t\t}\n\n\t\tprintf(\"%s%s\", line_prefix, c_frag);\n\t\tfor (i = 0; i <= num_parent; i++) putchar(combine_marker);\n\t\tfor (i = 0; i < num_parent; i++)\n\t\t\tshow_parent_lno(sline, lno, hunk_end, i, null_context);\n\t\tprintf(\" +%lu,%lu \", lno+1, rlines);\n\t\tfor (i = 0; i <= num_parent; i++) putchar(combine_marker);\n\n\t\tif (hunk_comment) {\n\t\t\tint comment_end = 0;\n\t\t\tfor (i = 0; i < 40; i++) {\n\t\t\t\tint ch = hunk_comment[i] & 0xff;\n\t\t\t\tif (!ch || ch == '\\n')\n\t\t\t\t\tbreak;\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t    comment_end = i;\n\t\t\t}\n\t\t\tif (comment_end)\n\t\t\t\tprintf(\"%s%s %s%s\", c_reset,\n\t\t\t\t\t\t    c_context, c_reset,\n\t\t\t\t\t\t    c_func);\n\t\t\tfor (i = 0; i < comment_end; i++)\n\t\t\t\tputchar(hunk_comment[i]);\n\t\t}\n\n\t\tprintf(\"%s\\n\", c_reset);\n\t\twhile (lno < hunk_end) {\n\t\t\tstruct lline *ll;\n\t\t\tint j;\n\t\t\tunsigned long p_mask;\n\t\t\tstruct sline *sl = &sline[lno++];\n\t\t\tll = (sl->flag & no_pre_delete) ? NULL : sl->lost;\n\t\t\twhile (ll) {\n\t\t\t\tprintf(\"%s%s\", line_prefix, c_old);\n\t\t\t\tfor (j = 0; j < num_parent; j++) {\n\t\t\t\t\tif (ll->parent_map & (1UL<<j))\n\t\t\t\t\t\tputchar('-');\n\t\t\t\t\telse\n\t\t\t\t\t\tputchar(' ');\n\t\t\t\t}\n\t\t\t\tshow_line_to_eol(ll->line, -1, c_reset);\n\t\t\t\tll = ll->next;\n\t\t\t}\n\t\t\tif (cnt < lno)\n\t\t\t\tbreak;\n\t\t\tp_mask = 1;\n\t\t\tfputs(line_prefix, stdout);\n\t\t\tif (!(sl->flag & (mark-1))) {\n\t\t\t\t/*\n\t\t\t\t * This sline was here to hang the\n\t\t\t\t * lost lines in front of it.\n\t\t\t\t */\n\t\t\t\tif (!context)\n\t\t\t\t\tcontinue;\n\t\t\t\tfputs(c_context, stdout);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfputs(c_new, stdout);\n\t\t\tfor (j = 0; j < num_parent; j++) {\n\t\t\t\tif (p_mask & sl->flag)\n\t\t\t\t\tputchar('+');\n\t\t\t\telse\n\t\t\t\t\tputchar(' ');\n\t\t\t\tp_mask <<= 1;\n\t\t\t}\n\t\t\tshow_line_to_eol(sl->bol, sl->len, c_reset);\n\t\t}\n\t}\n}\n\nstatic void reuse_combine_diff(struct sline *sline, unsigned long cnt,\n\t\t\t       int i, int j)\n{\n\t/* We have already examined parent j and we know parent i\n\t * and parent j are the same, so reuse the combined result\n\t * of parent j for parent i.\n\t */\n\tunsigned long lno, imask, jmask;\n\timask = (1UL<<i);\n\tjmask = (1UL<<j);\n\n\tfor (lno = 0; lno <= cnt; lno++) {\n\t\tstruct lline *ll = sline->lost;\n\t\tsline->p_lno[i] = sline->p_lno[j];\n\t\twhile (ll) {\n\t\t\tif (ll->parent_map & jmask)\n\t\t\t\tll->parent_map |= imask;\n\t\t\tll = ll->next;\n\t\t}\n\t\tif (sline->flag & jmask)\n\t\t\tsline->flag |= imask;\n\t\tsline++;\n\t}\n\t/* the overall size of the file (sline[cnt]) */\n\tsline->p_lno[i] = sline->p_lno[j];\n}\n\nstatic void dump_quoted_path(const char *head,\n\t\t\t     const char *prefix,\n\t\t\t     const char *path,\n\t\t\t     const char *line_prefix,\n\t\t\t     const char *c_meta, const char *c_reset)\n{\n\tstatic struct strbuf buf = STRBUF_INIT;\n\n\tstrbuf_reset(&buf);\n\tstrbuf_addstr(&buf, line_prefix);\n\tstrbuf_addstr(&buf, c_meta);\n\tstrbuf_addstr(&buf, head);\n\tquote_two_c_style(&buf, prefix, path, 0);\n\tstrbuf_addstr(&buf, c_reset);\n\tputs(buf.buf);\n}\n\nstatic void show_combined_header(struct combine_diff_path *elem,\n\t\t\t\t int num_parent,\n\t\t\t\t int dense,\n\t\t\t\t struct rev_info *rev,\n\t\t\t\t const char *line_prefix,\n\t\t\t\t int mode_differs,\n\t\t\t\t int show_file_header)\n{\n\tstruct diff_options *opt = &rev->diffopt;\n\tint abbrev = opt->flags.full_index ? the_hash_algo->hexsz : DEFAULT_ABBREV;\n\tconst char *a_prefix = opt->a_prefix ? opt->a_prefix : \"a/\";\n\tconst char *b_prefix = opt->b_prefix ? opt->b_prefix : \"b/\";\n\tconst char *c_meta = diff_get_color_opt(opt, DIFF_METAINFO);\n\tconst char *c_reset = diff_get_color_opt(opt, DIFF_RESET);\n\tconst char *abb;\n\tint added = 0;\n\tint deleted = 0;\n\tint i;\n\n\tif (rev->loginfo && !rev->no_commit_id)\n\t\tshow_log(rev);\n\n\tdump_quoted_path(dense ? \"diff --cc \" : \"diff --combined \",\n\t\t\t \"\", elem->path, line_prefix, c_meta, c_reset);\n\tprintf(\"%s%sindex \", line_prefix, c_meta);\n\tfor (i = 0; i < num_parent; i++) {\n\t\tabb = find_unique_abbrev(&elem->parent[i].oid,\n\t\t\t\t\t abbrev);\n\t\tprintf(\"%s%s\", i ? \",\" : \"\", abb);\n\t}\n\tabb = find_unique_abbrev(&elem->oid, abbrev);\n\tprintf(\"..%s%s\\n\", abb, c_reset);\n\n\tif (mode_differs) {\n\t\tdeleted = !elem->mode;\n\n\t\t/* We say it was added if nobody had it */\n\t\tadded = !deleted;\n\t\tfor (i = 0; added && i < num_parent; i++)\n\t\t\tif (elem->parent[i].status !=\n\t\t\t    DIFF_STATUS_ADDED)\n\t\t\t\tadded = 0;\n\t\tif (added)\n\t\t\tprintf(\"%s%snew file mode %06o\",\n\t\t\t       line_prefix, c_meta, elem->mode);\n\t\telse {\n\t\t\tif (deleted)\n\t\t\t\tprintf(\"%s%sdeleted file \",\n\t\t\t\t       line_prefix, c_meta);\n\t\t\tprintf(\"mode \");\n\t\t\tfor (i = 0; i < num_parent; i++) {\n\t\t\t\tprintf(\"%s%06o\", i ? \",\" : \"\",\n\t\t\t\t       elem->parent[i].mode);\n\t\t\t}\n\t\t\tif (elem->mode)\n\t\t\t\tprintf(\"..%06o\", elem->mode);\n\t\t}\n\t\tprintf(\"%s\\n\", c_reset);\n\t}\n\n\tif (!show_file_header)\n\t\treturn;\n\n\tif (rev->combined_all_paths) {\n\t\tfor (i = 0; i < num_parent; i++) {\n\t\t\tchar *path = filename_changed(elem->parent[i].status)\n\t\t\t\t? elem->parent[i].path.buf : elem->path;\n\t\t\tif (elem->parent[i].status == DIFF_STATUS_ADDED)\n\t\t\t\tdump_quoted_path(\"--- \", \"\", \"/dev/null\",\n\t\t\t\t\t\t line_prefix, c_meta, c_reset);\n\t\t\telse\n\t\t\t\tdump_quoted_path(\"--- \", a_prefix, path,\n\t\t\t\t\t\t line_prefix, c_meta, c_reset);\n\t\t}\n\t} else {\n\t\tif (added)\n\t\t\tdump_quoted_path(\"--- \", \"\", \"/dev/null\",\n\t\t\t\t\t line_prefix, c_meta, c_reset);\n\t\telse\n\t\t\tdump_quoted_path(\"--- \", a_prefix, elem->path,\n\t\t\t\t\t line_prefix, c_meta, c_reset);\n\t}\n\tif (deleted)\n\t\tdump_quoted_path(\"+++ \", \"\", \"/dev/null\",\n\t\t\t\t line_prefix, c_meta, c_reset);\n\telse\n\t\tdump_quoted_path(\"+++ \", b_prefix, elem->path,\n\t\t\t\t line_prefix, c_meta, c_reset);\n}\n\nstatic void show_patch_diff(struct combine_diff_path *elem, int num_parent,\n\t\t\t    int dense, int working_tree_file,\n\t\t\t    struct rev_info *rev)\n{\n\tstruct diff_options *opt = &rev->diffopt;\n\tunsigned long result_size, cnt, lno;\n\tint result_deleted = 0;\n\tchar *result, *cp;\n\tstruct sline *sline; /* survived lines */\n\tint mode_differs = 0;\n\tint i, show_hunks;\n\tmmfile_t result_file;\n\tstruct userdiff_driver *userdiff;\n\tstruct userdiff_driver *textconv = NULL;\n\tint is_binary;\n\tconst char *line_prefix = diff_line_prefix(opt);\n\n\tcontext = opt->context;\n\tuserdiff = userdiff_find_by_path(opt->repo->index, elem->path);\n\tif (!userdiff)\n\t\tuserdiff = userdiff_find_by_name(\"default\");\n\tif (opt->flags.allow_textconv)\n\t\ttextconv = userdiff_get_textconv(opt->repo, userdiff);\n\n\t/* Read the result of merge first */\n\tif (!working_tree_file)\n\t\tresult = grab_blob(opt->repo, &elem->oid, elem->mode, &result_size,\n\t\t\t\t   textconv, elem->path);\n\telse {\n\t\t/* Used by diff-tree to read from the working tree */\n\t\tstruct stat st;\n\t\tint fd = -1;\n\n\t\tif (lstat(elem->path, &st) < 0)\n\t\t\tgoto deleted_file;\n\n\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\tstruct strbuf buf = STRBUF_INIT;\n\n\t\t\tif (strbuf_readlink(&buf, elem->path, st.st_size) < 0) {\n\t\t\t\terror_errno(\"readlink(%s)\", elem->path);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult_size = buf.len;\n\t\t\tresult = strbuf_detach(&buf, NULL);\n\t\t\telem->mode = canon_mode(st.st_mode);\n\t\t} else if (S_ISDIR(st.st_mode)) {\n\t\t\tstruct object_id oid;\n\t\t\tif (resolve_gitlink_ref(elem->path, \"HEAD\", &oid) < 0)\n\t\t\t\tresult = grab_blob(opt->repo, &elem->oid,\n\t\t\t\t\t\t   elem->mode, &result_size,\n\t\t\t\t\t\t   NULL, NULL);\n\t\t\telse\n\t\t\t\tresult = grab_blob(opt->repo, &oid, elem->mode,\n\t\t\t\t\t\t   &result_size, NULL, NULL);\n\t\t} else if (textconv) {\n\t\t\tstruct diff_filespec *df = alloc_filespec(elem->path);\n\t\t\tfill_filespec(df, &null_oid, 0, st.st_mode);\n\t\t\tresult_size = fill_textconv(opt->repo, textconv, df, &result);\n\t\t\tfree_filespec(df);\n\t\t} else if (0 <= (fd = open(elem->path, O_RDONLY))) {\n\t\t\tsize_t len = xsize_t(st.st_size);\n\t\t\tssize_t done;\n\t\t\tint is_file, i;\n\n\t\t\telem->mode = canon_mode(st.st_mode);\n\t\t\t/* if symlinks don't work, assume symlink if all parents\n\t\t\t * are symlinks\n\t\t\t */\n\t\t\tis_file = has_symlinks;\n\t\t\tfor (i = 0; !is_file && i < num_parent; i++)\n\t\t\t\tis_file = !S_ISLNK(elem->parent[i].mode);\n\t\t\tif (!is_file)\n\t\t\t\telem->mode = canon_mode(S_IFLNK);\n\n\t\t\tresult_size = len;\n\t\t\tresult = xmallocz(len);\n\n\t\t\tdone = read_in_full(fd, result, len);\n\t\t\tif (done < 0)\n\t\t\t\tdie_errno(\"read error '%s'\", elem->path);\n\t\t\telse if (done < len)\n\t\t\t\tdie(\"early EOF '%s'\", elem->path);\n\n\t\t\t/* If not a fake symlink, apply filters, e.g. autocrlf */\n\t\t\tif (is_file) {\n\t\t\t\tstruct strbuf buf = STRBUF_INIT;\n\n\t\t\t\tif (convert_to_git(rev->diffopt.repo->index,\n\t\t\t\t\t\t   elem->path, result, len, &buf, global_conv_flags_eol)) {\n\t\t\t\t\tfree(result);\n\t\t\t\t\tresult = strbuf_detach(&buf, &len);\n\t\t\t\t\tresult_size = len;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\tdeleted_file:\n\t\t\tresult_deleted = 1;\n\t\t\tresult_size = 0;\n\t\t\telem->mode = 0;\n\t\t\tresult = xcalloc(1, 1);\n\t\t}\n\n\t\tif (0 <= fd)\n\t\t\tclose(fd);\n\t}\n\n\tfor (i = 0; i < num_parent; i++) {\n\t\tif (elem->parent[i].mode != elem->mode) {\n\t\t\tmode_differs = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (textconv)\n\t\tis_binary = 0;\n\telse if (userdiff->binary != -1)\n\t\tis_binary = userdiff->binary;\n\telse {\n\t\tis_binary = buffer_is_binary(result, result_size);\n\t\tfor (i = 0; !is_binary && i < num_parent; i++) {\n\t\t\tchar *buf;\n\t\t\tunsigned long size;\n\t\t\tbuf = grab_blob(opt->repo,\n\t\t\t\t\t&elem->parent[i].oid,\n\t\t\t\t\telem->parent[i].mode,\n\t\t\t\t\t&size, NULL, NULL);\n\t\t\tif (buffer_is_binary(buf, size))\n\t\t\t\tis_binary = 1;\n\t\t\tfree(buf);\n\t\t}\n\t}\n\tif (is_binary) {\n\t\tshow_combined_header(elem, num_parent, dense, rev,\n\t\t\t\t     line_prefix, mode_differs, 0);\n\t\tprintf(\"Binary files differ\\n\");\n\t\tfree(result);\n\t\treturn;\n\t}\n\n\tfor (cnt = 0, cp = result; cp < result + result_size; cp++) {\n\t\tif (*cp == '\\n')\n\t\t\tcnt++;\n\t}\n\tif (result_size && result[result_size-1] != '\\n')\n\t\tcnt++; /* incomplete line */\n\n\tsline = xcalloc(st_add(cnt, 2), sizeof(*sline));\n\tsline[0].bol = result;\n\tfor (lno = 0, cp = result; cp < result + result_size; cp++) {\n\t\tif (*cp == '\\n') {\n\t\t\tsline[lno].len = cp - sline[lno].bol;\n\t\t\tlno++;\n\t\t\tif (lno < cnt)\n\t\t\t\tsline[lno].bol = cp + 1;\n\t\t}\n\t}\n\tif (result_size && result[result_size-1] != '\\n')\n\t\tsline[cnt-1].len = result_size - (sline[cnt-1].bol - result);\n\n\tresult_file.ptr = result;\n\tresult_file.size = result_size;\n\n\t/* Even p_lno[cnt+1] is valid -- that is for the end line number\n\t * for deletion hunk at the end.\n\t */\n\tsline[0].p_lno = xcalloc(st_mult(st_add(cnt, 2), num_parent), sizeof(unsigned long));\n\tfor (lno = 0; lno <= cnt; lno++)\n\t\tsline[lno+1].p_lno = sline[lno].p_lno + num_parent;\n\n\tfor (i = 0; i < num_parent; i++) {\n\t\tint j;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (oideq(&elem->parent[i].oid,\n\t\t\t\t  &elem->parent[j].oid)) {\n\t\t\t\treuse_combine_diff(sline, cnt, i, j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= j)\n\t\t\tcombine_diff(opt->repo,\n\t\t\t\t     &elem->parent[i].oid,\n\t\t\t\t     elem->parent[i].mode,\n\t\t\t\t     &result_file, sline,\n\t\t\t\t     cnt, i, num_parent, result_deleted,\n\t\t\t\t     textconv, elem->path, opt->xdl_opts);\n\t}\n\n\tshow_hunks = make_hunks(sline, cnt, num_parent, dense);\n\n\tif (show_hunks || mode_differs || working_tree_file) {\n\t\tshow_combined_header(elem, num_parent, dense, rev,\n\t\t\t\t     line_prefix, mode_differs, 1);\n\t\tdump_sline(sline, line_prefix, cnt, num_parent,\n\t\t\t   opt->use_color, result_deleted);\n\t}\n\tfree(result);\n\n\tfor (lno = 0; lno < cnt; lno++) {\n\t\tif (sline[lno].lost) {\n\t\t\tstruct lline *ll = sline[lno].lost;\n\t\t\twhile (ll) {\n\t\t\t\tstruct lline *tmp = ll;\n\t\t\t\tll = ll->next;\n\t\t\t\tfree(tmp);\n\t\t\t}\n\t\t}\n\t}\n\tfree(sline[0].p_lno);\n\tfree(sline);\n}\n\nstatic void show_raw_diff(struct combine_diff_path *p, int num_parent, struct rev_info *rev)\n{\n\tstruct diff_options *opt = &rev->diffopt;\n\tint line_termination, inter_name_termination, i;\n\tconst char *line_prefix = diff_line_prefix(opt);\n\n\tline_termination = opt->line_termination;\n\tinter_name_termination = '\\t';\n\tif (!line_termination)\n\t\tinter_name_termination = 0;\n\n\tif (rev->loginfo && !rev->no_commit_id)\n\t\tshow_log(rev);\n\n\n\tif (opt->output_format & DIFF_FORMAT_RAW) {\n\t\tprintf(\"%s\", line_prefix);\n\n\t\t/* As many colons as there are parents */\n\t\tfor (i = 0; i < num_parent; i++)\n\t\t\tputchar(':');\n\n\t\t/* Show the modes */\n\t\tfor (i = 0; i < num_parent; i++)\n\t\t\tprintf(\"%06o \", p->parent[i].mode);\n\t\tprintf(\"%06o\", p->mode);\n\n\t\t/* Show sha1's */\n\t\tfor (i = 0; i < num_parent; i++)\n\t\t\tprintf(\" %s\", diff_aligned_abbrev(&p->parent[i].oid,\n\t\t\t\t\t\t\t  opt->abbrev));\n\t\tprintf(\" %s \", diff_aligned_abbrev(&p->oid, opt->abbrev));\n\t}\n\n\tif (opt->output_format & (DIFF_FORMAT_RAW | DIFF_FORMAT_NAME_STATUS)) {\n\t\tfor (i = 0; i < num_parent; i++)\n\t\t\tputchar(p->parent[i].status);\n\t\tputchar(inter_name_termination);\n\t}\n\n\tfor (i = 0; i < num_parent; i++)\n\t\tif (rev->combined_all_paths) {\n\t\t\tif (filename_changed(p->parent[i].status))\n\t\t\t\twrite_name_quoted(p->parent[i].path.buf, stdout,\n\t\t\t\t\t\t  inter_name_termination);\n\t\t\telse\n\t\t\t\twrite_name_quoted(p->path, stdout,\n\t\t\t\t\t\t  inter_name_termination);\n\t\t}\n\twrite_name_quoted(p->path, stdout, line_termination);\n}\n\n/*\n * The result (p->elem) is from the working tree and their\n * parents are typically from multiple stages during a merge\n * (i.e. diff-files) or the state in HEAD and in the index\n * (i.e. diff-index).\n */\nvoid show_combined_diff(struct combine_diff_path *p,\n\t\t       int num_parent,\n\t\t       int dense,\n\t\t       struct rev_info *rev)\n{\n\tstruct diff_options *opt = &rev->diffopt;\n\n\tif (opt->output_format & (DIFF_FORMAT_RAW |\n\t\t\t\t  DIFF_FORMAT_NAME |\n\t\t\t\t  DIFF_FORMAT_NAME_STATUS))\n\t\tshow_raw_diff(p, num_parent, rev);\n\telse if (opt->output_format & DIFF_FORMAT_PATCH)\n\t\tshow_patch_diff(p, num_parent, dense, 1, rev);\n}\n\nstatic void free_combined_pair(struct diff_filepair *pair)\n{\n\tfree(pair->two);\n\tfree(pair);\n}\n\n/*\n * A combine_diff_path expresses N parents on the LHS against 1 merge\n * result. Synthesize a diff_filepair that has N entries on the \"one\"\n * side and 1 entry on the \"two\" side.\n *\n * In the future, we might want to add more data to combine_diff_path\n * so that we can fill fields we are ignoring (most notably, size) here,\n * but currently nobody uses it, so this should suffice for now.\n */\nstatic struct diff_filepair *combined_pair(struct combine_diff_path *p,\n\t\t\t\t\t   int num_parent)\n{\n\tint i;\n\tstruct diff_filepair *pair;\n\tstruct diff_filespec *pool;\n\n\tpair = xmalloc(sizeof(*pair));\n\tpool = xcalloc(st_add(num_parent, 1), sizeof(struct diff_filespec));\n\tpair->one = pool + 1;\n\tpair->two = pool;\n\n\tfor (i = 0; i < num_parent; i++) {\n\t\tpair->one[i].path = p->path;\n\t\tpair->one[i].mode = p->parent[i].mode;\n\t\toidcpy(&pair->one[i].oid, &p->parent[i].oid);\n\t\tpair->one[i].oid_valid = !is_null_oid(&p->parent[i].oid);\n\t\tpair->one[i].has_more_entries = 1;\n\t}\n\tpair->one[num_parent - 1].has_more_entries = 0;\n\n\tpair->two->path = p->path;\n\tpair->two->mode = p->mode;\n\toidcpy(&pair->two->oid, &p->oid);\n\tpair->two->oid_valid = !is_null_oid(&p->oid);\n\treturn pair;\n}\n\nstatic void handle_combined_callback(struct diff_options *opt,\n\t\t\t\t     struct combine_diff_path *paths,\n\t\t\t\t     int num_parent,\n\t\t\t\t     int num_paths)\n{\n\tstruct combine_diff_path *p;\n\tstruct diff_queue_struct q;\n\tint i;\n\n\tq.queue = xcalloc(num_paths, sizeof(struct diff_filepair *));\n\tq.alloc = num_paths;\n\tq.nr = num_paths;\n\tfor (i = 0, p = paths; p; p = p->next)\n\t\tq.queue[i++] = combined_pair(p, num_parent);\n\topt->format_callback(&q, opt, opt->format_callback_data);\n\tfor (i = 0; i < num_paths; i++)\n\t\tfree_combined_pair(q.queue[i]);\n\tfree(q.queue);\n}\n\nstatic const char *path_path(void *obj)\n{\n\tstruct combine_diff_path *path = (struct combine_diff_path *)obj;\n\n\treturn path->path;\n}\n\n/*\n * Diff stat formats which we always compute solely against the first parent.\n */\n#define STAT_FORMAT_MASK (DIFF_FORMAT_NUMSTAT \\\n\t\t\t  | DIFF_FORMAT_SHORTSTAT \\\n\t\t\t  | DIFF_FORMAT_SUMMARY \\\n\t\t\t  | DIFF_FORMAT_DIRSTAT \\\n\t\t\t  | DIFF_FORMAT_DIFFSTAT)\n\n/* find set of paths that every parent touches */\nstatic struct combine_diff_path *find_paths_generic(const struct object_id *oid,\n\tconst struct oid_array *parents,\n\tstruct diff_options *opt,\n\tint combined_all_paths)\n{\n\tstruct combine_diff_path *paths = NULL;\n\tint i, num_parent = parents->nr;\n\n\tint output_format = opt->output_format;\n\tconst char *orderfile = opt->orderfile;\n\n\topt->output_format = DIFF_FORMAT_NO_OUTPUT;\n\t/* tell diff_tree to emit paths in sorted (=tree) order */\n\topt->orderfile = NULL;\n\n\t/* D(A,P1...Pn) = D(A,P1) ^ ... ^ D(A,Pn)  (wrt paths) */\n\tfor (i = 0; i < num_parent; i++) {\n\t\t/*\n\t\t * show stat against the first parent even when doing\n\t\t * combined diff.\n\t\t */\n\t\tint stat_opt = output_format & STAT_FORMAT_MASK;\n\t\tif (i == 0 && stat_opt)\n\t\t\topt->output_format = stat_opt;\n\t\telse\n\t\t\topt->output_format = DIFF_FORMAT_NO_OUTPUT;\n\t\tdiff_tree_oid(&parents->oid[i], oid, \"\", opt);\n\t\tdiffcore_std(opt);\n\t\tpaths = intersect_paths(paths, i, num_parent,\n\t\t\t\t\tcombined_all_paths);\n\n\t\t/* if showing diff, show it in requested order */\n\t\tif (opt->output_format != DIFF_FORMAT_NO_OUTPUT &&\n\t\t    orderfile) {\n\t\t\tdiffcore_order(orderfile);\n\t\t}\n\n\t\tdiff_flush(opt);\n\t}\n\n\topt->output_format = output_format;\n\topt->orderfile = orderfile;\n\treturn paths;\n}\n\n\n/*\n * find set of paths that everybody touches, assuming diff is run without\n * rename/copy detection, etc, comparing all trees simultaneously (= faster).\n */\nstatic struct combine_diff_path *find_paths_multitree(\n\tconst struct object_id *oid, const struct oid_array *parents,\n\tstruct diff_options *opt)\n{\n\tint i, nparent = parents->nr;\n\tconst struct object_id **parents_oid;\n\tstruct combine_diff_path paths_head;\n\tstruct strbuf base;\n\n\tALLOC_ARRAY(parents_oid, nparent);\n\tfor (i = 0; i < nparent; i++)\n\t\tparents_oid[i] = &parents->oid[i];\n\n\t/* fake list head, so worker can assume it is non-NULL */\n\tpaths_head.next = NULL;\n\n\tstrbuf_init(&base, PATH_MAX);\n\tdiff_tree_paths(&paths_head, oid, parents_oid, nparent, &base, opt);\n\n\tstrbuf_release(&base);\n\tfree(parents_oid);\n\treturn paths_head.next;\n}\n\n\nvoid diff_tree_combined(const struct object_id *oid,\n\t\t\tconst struct oid_array *parents,\n\t\t\tint dense,\n\t\t\tstruct rev_info *rev)\n{\n\tstruct diff_options *opt = &rev->diffopt;\n\tstruct diff_options diffopts;\n\tstruct combine_diff_path *p, *paths;\n\tint i, num_paths, needsep, show_log_first, num_parent = parents->nr;\n\tint need_generic_pathscan;\n\n\t/* nothing to do, if no parents */\n\tif (!num_parent)\n\t\treturn;\n\n\tshow_log_first = !!rev->loginfo && !rev->no_commit_id;\n\tneedsep = 0;\n\tif (show_log_first) {\n\t\tshow_log(rev);\n\n\t\tif (rev->verbose_header && opt->output_format &&\n\t\t    opt->output_format != DIFF_FORMAT_NO_OUTPUT &&\n\t\t    !commit_format_is_empty(rev->commit_format))\n\t\t\tprintf(\"%s%c\", diff_line_prefix(opt),\n\t\t\t       opt->line_termination);\n\t}\n\n\tdiffopts = *opt;\n\tcopy_pathspec(&diffopts.pathspec, &opt->pathspec);\n\tdiffopts.flags.recursive = 1;\n\tdiffopts.flags.allow_external = 0;\n\n\t/* find set of paths that everybody touches\n\t *\n\t * NOTE\n\t *\n\t * Diffcore transformations are bound to diff_filespec and logic\n\t * comparing two entries - i.e. they do not apply directly to combine\n\t * diff.\n\t *\n\t * If some of such transformations is requested - we launch generic\n\t * path scanning, which works significantly slower compared to\n\t * simultaneous all-trees-in-one-go scan in find_paths_multitree().\n\t *\n\t * TODO some of the filters could be ported to work on\n\t * combine_diff_paths - i.e. all functionality that skips paths, so in\n\t * theory, we could end up having only multitree path scanning.\n\t *\n\t * NOTE please keep this semantically in sync with diffcore_std()\n\t */\n\tneed_generic_pathscan = opt->skip_stat_unmatch\t||\n\t\t\topt->flags.follow_renames\t||\n\t\t\topt->break_opt != -1\t||\n\t\t\topt->detect_rename\t||\n\t\t\t(opt->pickaxe_opts & DIFF_PICKAXE_KINDS_MASK)\t||\n\t\t\topt->filter;\n\n\n\tif (need_generic_pathscan) {\n\t\t/*\n\t\t * NOTE generic case also handles --stat, as it computes\n\t\t * diff(sha1,parent_i) for all i to do the job, specifically\n\t\t * for parent0.\n\t\t */\n\t\tpaths = find_paths_generic(oid, parents, &diffopts,\n\t\t\t\t\t   rev->combined_all_paths);\n\t}\n\telse {\n\t\tint stat_opt;\n\t\tpaths = find_paths_multitree(oid, parents, &diffopts);\n\n\t\t/*\n\t\t * show stat against the first parent even\n\t\t * when doing combined diff.\n\t\t */\n\t\tstat_opt = opt->output_format & STAT_FORMAT_MASK;\n\t\tif (stat_opt) {\n\t\t\tdiffopts.output_format = stat_opt;\n\n\t\t\tdiff_tree_oid(&parents->oid[0], oid, \"\", &diffopts);\n\t\t\tdiffcore_std(&diffopts);\n\t\t\tif (opt->orderfile)\n\t\t\t\tdiffcore_order(opt->orderfile);\n\t\t\tdiff_flush(&diffopts);\n\t\t}\n\t}\n\n\t/* find out number of surviving paths */\n\tfor (num_paths = 0, p = paths; p; p = p->next)\n\t\tnum_paths++;\n\n\t/* order paths according to diffcore_order */\n\tif (opt->orderfile && num_paths) {\n\t\tstruct obj_order *o;\n\n\t\tALLOC_ARRAY(o, num_paths);\n\t\tfor (i = 0, p = paths; p; p = p->next, i++)\n\t\t\to[i].obj = p;\n\t\torder_objects(opt->orderfile, path_path, o, num_paths);\n\t\tfor (i = 0; i < num_paths - 1; i++) {\n\t\t\tp = o[i].obj;\n\t\t\tp->next = o[i+1].obj;\n\t\t}\n\n\t\tp = o[num_paths-1].obj;\n\t\tp->next = NULL;\n\t\tpaths = o[0].obj;\n\t\tfree(o);\n\t}\n\n\n\tif (num_paths) {\n\t\tif (opt->output_format & (DIFF_FORMAT_RAW |\n\t\t\t\t\t  DIFF_FORMAT_NAME |\n\t\t\t\t\t  DIFF_FORMAT_NAME_STATUS)) {\n\t\t\tfor (p = paths; p; p = p->next)\n\t\t\t\tshow_raw_diff(p, num_parent, rev);\n\t\t\tneedsep = 1;\n\t\t}\n\t\telse if (opt->output_format & STAT_FORMAT_MASK)\n\t\t\tneedsep = 1;\n\t\telse if (opt->output_format & DIFF_FORMAT_CALLBACK)\n\t\t\thandle_combined_callback(opt, paths, num_parent, num_paths);\n\n\t\tif (opt->output_format & DIFF_FORMAT_PATCH) {\n\t\t\tif (needsep)\n\t\t\t\tprintf(\"%s%c\", diff_line_prefix(opt),\n\t\t\t\t       opt->line_termination);\n\t\t\tfor (p = paths; p; p = p->next)\n\t\t\t\tshow_patch_diff(p, num_parent, dense,\n\t\t\t\t\t\t0, rev);\n\t\t}\n\t}\n\n\t/* Clean things up */\n\twhile (paths) {\n\t\tstruct combine_diff_path *tmp = paths;\n\t\tpaths = paths->next;\n\t\tfor (i = 0; i < num_parent; i++)\n\t\t\tif (rev->combined_all_paths &&\n\t\t\t    filename_changed(tmp->parent[i].status))\n\t\t\t\tstrbuf_release(&tmp->parent[i].path);\n\t\tfree(tmp);\n\t}\n\n\tclear_pathspec(&diffopts.pathspec);\n}\n\nvoid diff_tree_combined_merge(const struct commit *commit, int dense,\n\t\t\t      struct rev_info *rev)\n{\n\tstruct commit_list *parent = get_saved_parents(rev, commit);\n\tstruct oid_array parents = OID_ARRAY_INIT;\n\n\twhile (parent) {\n\t\toid_array_append(&parents, &parent->item->object.oid);\n\t\tparent = parent->next;\n\t}\n\tdiff_tree_combined(&commit->object.oid, &parents, dense, rev);\n\toid_array_clear(&parents);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "002e0e5438bc27472d032ac562a2f3a29ec20a68",
  "sha1_ok": true,
  "size": 43235
}
