{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgInRyZWUuaCIKI2luY2x1ZGUgInRyZWUtd2Fsay5oIgojaW5jbHVkZSAiY2FjaGUtdHJlZS5oIgojaW5jbHVkZSAidW5wYWNrLXRyZWVzLmgiCiNpbmNsdWRlICJkaXIuaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJtZXJnZS1yZWN1cnNpdmUuaCIKI2luY2x1ZGUgImJyYW5jaC5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAicmV2aXNpb24uaCIKI2luY2x1ZGUgInJlbW90ZS5oIgojaW5jbHVkZSAiYmxvYi5oIgojaW5jbHVkZSAieGRpZmYtaW50ZXJmYWNlLmgiCiNpbmNsdWRlICJsbC1tZXJnZS5oIgojaW5jbHVkZSAicmVzb2x2ZS11bmRvLmgiCiNpbmNsdWRlICJzdWJtb2R1bGUuaCIKI2luY2x1ZGUgImFyZ3YtYXJyYXkuaCIKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgY2hlY2tvdXRfdXNhZ2VbXSA9IHsKCSJnaXQgY2hlY2tvdXQgW29wdGlvbnNdIDxicmFuY2g+IiwKCSJnaXQgY2hlY2tvdXQgW29wdGlvbnNdIFs8YnJhbmNoPl0gLS0gPGZpbGU+Li4uIiwKCU5VTEwsCn07CgpzdHJ1Y3QgY2hlY2tvdXRfb3B0cyB7CglpbnQgcXVpZXQ7CglpbnQgbWVyZ2U7CglpbnQgZm9yY2U7CglpbnQgZm9yY2VfZGV0YWNoOwoJaW50IHdyaXRlb3V0X3N0YWdlOwoJaW50IHdyaXRlb3V0X2Vycm9yOwoKCS8qIG5vdCBzZXQgYnkgcGFyc2Vfb3B0aW9ucyAqLwoJaW50IGJyYW5jaF9leGlzdHM7CgoJY29uc3QgY2hhciAqbmV3X2JyYW5jaDsKCWNvbnN0IGNoYXIgKm5ld19icmFuY2hfZm9yY2U7Cgljb25zdCBjaGFyICpuZXdfb3JwaGFuX2JyYW5jaDsKCWludCBuZXdfYnJhbmNoX2xvZzsKCWVudW0gYnJhbmNoX3RyYWNrIHRyYWNrOwoJc3RydWN0IGRpZmZfb3B0aW9ucyBkaWZmX29wdGlvbnM7Cn07CgpzdGF0aWMgaW50IHBvc3RfY2hlY2tvdXRfaG9vayhzdHJ1Y3QgY29tbWl0ICpvbGQsIHN0cnVjdCBjb21taXQgKm5ldywKCQkJICAgICAgaW50IGNoYW5nZWQpCnsKCXJldHVybiBydW5faG9vayhOVUxMLCAicG9zdC1jaGVja291dCIsCgkJCXNoYTFfdG9faGV4KG9sZCA/IG9sZC0+b2JqZWN0LnNoYTEgOiBudWxsX3NoYTEpLAoJCQlzaGExX3RvX2hleChuZXcgPyBuZXctPm9iamVjdC5zaGExIDogbnVsbF9zaGExKSwKCQkJY2hhbmdlZCA/ICIxIiA6ICIwIiwgTlVMTCk7CgkvKiAibmV3IiBjYW4gYmUgTlVMTCB3aGVuIGNoZWNraW5nIG91dCBmcm9tIHRoZSBpbmRleCBiZWZvcmUKCSAgIGEgY29tbWl0IGV4aXN0cy4gKi8KCn0KCnN0YXRpYyBpbnQgdXBkYXRlX3NvbWUoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgY29uc3QgY2hhciAqYmFzZSwgaW50IGJhc2VsZW4sCgkJY29uc3QgY2hhciAqcGF0aG5hbWUsIHVuc2lnbmVkIG1vZGUsIGludCBzdGFnZSwgdm9pZCAqY29udGV4dCkKewoJaW50IGxlbjsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2U7CgoJaWYgKFNfSVNESVIobW9kZSkpCgkJcmV0dXJuIFJFQURfVFJFRV9SRUNVUlNJVkU7CgoJbGVuID0gYmFzZWxlbiArIHN0cmxlbihwYXRobmFtZSk7CgljZSA9IHhjYWxsb2MoMSwgY2FjaGVfZW50cnlfc2l6ZShsZW4pKTsKCWhhc2hjcHkoY2UtPnNoYTEsIHNoYTEpOwoJbWVtY3B5KGNlLT5uYW1lLCBiYXNlLCBiYXNlbGVuKTsKCW1lbWNweShjZS0+bmFtZSArIGJhc2VsZW4sIHBhdGhuYW1lLCBsZW4gLSBiYXNlbGVuKTsKCWNlLT5jZV9mbGFncyA9IGNyZWF0ZV9jZV9mbGFncyhsZW4sIDApIHwgQ0VfVVBEQVRFOwoJY2UtPmNlX21vZGUgPSBjcmVhdGVfY2VfbW9kZShtb2RlKTsKCWFkZF9jYWNoZV9lbnRyeShjZSwgQUREX0NBQ0hFX09LX1RPX0FERCB8IEFERF9DQUNIRV9PS19UT19SRVBMQUNFKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHJlYWRfdHJlZV9zb21lKHN0cnVjdCB0cmVlICp0cmVlLCBjb25zdCBjaGFyICoqcGF0aHNwZWMpCnsKCXN0cnVjdCBwYXRoc3BlYyBwczsKCWluaXRfcGF0aHNwZWMoJnBzLCBwYXRoc3BlYyk7CglyZWFkX3RyZWVfcmVjdXJzaXZlKHRyZWUsICIiLCAwLCAwLCAmcHMsIHVwZGF0ZV9zb21lLCBOVUxMKTsKCWZyZWVfcGF0aHNwZWMoJnBzKTsKCgkvKiB1cGRhdGUgdGhlIGluZGV4IHdpdGggdGhlIGdpdmVuIHRyZWUncyBpbmZvCgkgKiBmb3IgYWxsIGFyZ3MsIGV4cGFuZGluZyB3aWxkY2FyZHMsIGFuZCBleGl0CgkgKiB3aXRoIGFueSBub24temVybyByZXR1cm4gY29kZS4KCSAqLwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgc2tpcF9zYW1lX25hbWUoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgaW50IHBvcykKewoJd2hpbGUgKCsrcG9zIDwgYWN0aXZlX25yICYmCgkgICAgICAgIXN0cmNtcChhY3RpdmVfY2FjaGVbcG9zXS0+bmFtZSwgY2UtPm5hbWUpKQoJCTsgLyogc2tpcCAqLwoJcmV0dXJuIHBvczsKfQoKc3RhdGljIGludCBjaGVja19zdGFnZShpbnQgc3RhZ2UsIHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIGludCBwb3MpCnsKCXdoaWxlIChwb3MgPCBhY3RpdmVfbnIgJiYKCSAgICAgICAhc3RyY21wKGFjdGl2ZV9jYWNoZVtwb3NdLT5uYW1lLCBjZS0+bmFtZSkpIHsKCQlpZiAoY2Vfc3RhZ2UoYWN0aXZlX2NhY2hlW3Bvc10pID09IHN0YWdlKQoJCQlyZXR1cm4gMDsKCQlwb3MrKzsKCX0KCWlmIChzdGFnZSA9PSAyKQoJCXJldHVybiBlcnJvcihfKCJwYXRoICclcycgZG9lcyBub3QgaGF2ZSBvdXIgdmVyc2lvbiIpLCBjZS0+bmFtZSk7CgllbHNlCgkJcmV0dXJuIGVycm9yKF8oInBhdGggJyVzJyBkb2VzIG5vdCBoYXZlIHRoZWlyIHZlcnNpb24iKSwgY2UtPm5hbWUpOwp9CgpzdGF0aWMgaW50IGNoZWNrX2FsbF9zdGFnZXMoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgaW50IHBvcykKewoJaWYgKGNlX3N0YWdlKGNlKSAhPSAxIHx8CgkgICAgYWN0aXZlX25yIDw9IHBvcyArIDIgfHwKCSAgICBzdHJjbXAoYWN0aXZlX2NhY2hlW3BvcysxXS0+bmFtZSwgY2UtPm5hbWUpIHx8CgkgICAgY2Vfc3RhZ2UoYWN0aXZlX2NhY2hlW3BvcysxXSkgIT0gMiB8fAoJICAgIHN0cmNtcChhY3RpdmVfY2FjaGVbcG9zKzJdLT5uYW1lLCBjZS0+bmFtZSkgfHwKCSAgICBjZV9zdGFnZShhY3RpdmVfY2FjaGVbcG9zKzJdKSAhPSAzKQoJCXJldHVybiBlcnJvcihfKCJwYXRoICclcycgZG9lcyBub3QgaGF2ZSBhbGwgdGhyZWUgdmVyc2lvbnMiKSwKCQkJICAgICBjZS0+bmFtZSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBjaGVja291dF9zdGFnZShpbnQgc3RhZ2UsIHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIGludCBwb3MsCgkJCSAgc3RydWN0IGNoZWNrb3V0ICpzdGF0ZSkKewoJd2hpbGUgKHBvcyA8IGFjdGl2ZV9uciAmJgoJICAgICAgICFzdHJjbXAoYWN0aXZlX2NhY2hlW3Bvc10tPm5hbWUsIGNlLT5uYW1lKSkgewoJCWlmIChjZV9zdGFnZShhY3RpdmVfY2FjaGVbcG9zXSkgPT0gc3RhZ2UpCgkJCXJldHVybiBjaGVja291dF9lbnRyeShhY3RpdmVfY2FjaGVbcG9zXSwgc3RhdGUsIE5VTEwpOwoJCXBvcysrOwoJfQoJaWYgKHN0YWdlID09IDIpCgkJcmV0dXJuIGVycm9yKF8oInBhdGggJyVzJyBkb2VzIG5vdCBoYXZlIG91ciB2ZXJzaW9uIiksIGNlLT5uYW1lKTsKCWVsc2UKCQlyZXR1cm4gZXJyb3IoXygicGF0aCAnJXMnIGRvZXMgbm90IGhhdmUgdGhlaXIgdmVyc2lvbiIpLCBjZS0+bmFtZSk7Cn0KCnN0YXRpYyBpbnQgY2hlY2tvdXRfbWVyZ2VkKGludCBwb3MsIHN0cnVjdCBjaGVja291dCAqc3RhdGUpCnsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBhY3RpdmVfY2FjaGVbcG9zXTsKCWNvbnN0IGNoYXIgKnBhdGggPSBjZS0+bmFtZTsKCW1tZmlsZV90IGFuY2VzdG9yLCBvdXJzLCB0aGVpcnM7CglpbnQgc3RhdHVzOwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCW1tYnVmZmVyX3QgcmVzdWx0X2J1ZjsKCglpZiAoY2Vfc3RhZ2UoY2UpICE9IDEgfHwKCSAgICBhY3RpdmVfbnIgPD0gcG9zICsgMiB8fAoJICAgIHN0cmNtcChhY3RpdmVfY2FjaGVbcG9zKzFdLT5uYW1lLCBwYXRoKSB8fAoJICAgIGNlX3N0YWdlKGFjdGl2ZV9jYWNoZVtwb3MrMV0pICE9IDIgfHwKCSAgICBzdHJjbXAoYWN0aXZlX2NhY2hlW3BvcysyXS0+bmFtZSwgcGF0aCkgfHwKCSAgICBjZV9zdGFnZShhY3RpdmVfY2FjaGVbcG9zKzJdKSAhPSAzKQoJCXJldHVybiBlcnJvcihfKCJwYXRoICclcycgZG9lcyBub3QgaGF2ZSBhbGwgMyB2ZXJzaW9ucyIpLCBwYXRoKTsKCglyZWFkX21tYmxvYigmYW5jZXN0b3IsIGFjdGl2ZV9jYWNoZVtwb3NdLT5zaGExKTsKCXJlYWRfbW1ibG9iKCZvdXJzLCBhY3RpdmVfY2FjaGVbcG9zKzFdLT5zaGExKTsKCXJlYWRfbW1ibG9iKCZ0aGVpcnMsIGFjdGl2ZV9jYWNoZVtwb3MrMl0tPnNoYTEpOwoKCS8qCgkgKiBORUVEU1dPUks6IHJlLWNyZWF0ZSBjb25mbGljdHMgZnJvbSBtZXJnZXMgd2l0aAoJICogbWVyZ2UucmVub3JtYWxpemUgc2V0LCB0b28KCSAqLwoJc3RhdHVzID0gbGxfbWVyZ2UoJnJlc3VsdF9idWYsIHBhdGgsICZhbmNlc3RvciwgImJhc2UiLAoJCQkgICZvdXJzLCAib3VycyIsICZ0aGVpcnMsICJ0aGVpcnMiLCBOVUxMKTsKCWZyZWUoYW5jZXN0b3IucHRyKTsKCWZyZWUob3Vycy5wdHIpOwoJZnJlZSh0aGVpcnMucHRyKTsKCWlmIChzdGF0dXMgPCAwIHx8ICFyZXN1bHRfYnVmLnB0cikgewoJCWZyZWUocmVzdWx0X2J1Zi5wdHIpOwoJCXJldHVybiBlcnJvcihfKCJwYXRoICclcyc6IGNhbm5vdCBtZXJnZSIpLCBwYXRoKTsKCX0KCgkvKgoJICogTkVFRFNXT1JLOgoJICogVGhlcmUgaXMgYWJzb2x1dGVseSBubyByZWFzb24gdG8gd3JpdGUgdGhpcyBhcyBhIGJsb2Igb2JqZWN0CgkgKiBhbmQgY3JlYXRlIGEgcGhvbnkgY2FjaGUgZW50cnkganVzdCB0byBsZWFrLiAgVGhpcyBoYWNrIGlzCgkgKiBwcmltYXJpbHkgdG8gZ2V0IHRvIHRoZSB3cml0ZV9lbnRyeSgpIG1hY2hpbmVyeSB0aGF0IG1hc3NhZ2VzCgkgKiB0aGUgY29udGVudHMgdG8gd29yay10cmVlIGZvcm1hdCBhbmQgd3JpdGVzIG91dCB3aGljaCBvbmx5CgkgKiBhbGxvd3MgaXQgZm9yIGEgY2FjaGUgZW50cnkuICBUaGUgY29kZSBpbiB3cml0ZV9lbnRyeSgpIG5lZWRzCgkgKiB0byBiZSByZWZhY3RvcmVkIHRvIGFsbG93IHVzIHRvIGZlZWQgYSA8YnVmZmVyLCBzaXplLCBtb2RlPgoJICogaW5zdGVhZCBvZiBhIGNhY2hlIGVudHJ5LiAgU3VjaCBhIHJlZmFjdG9yaW5nIHdvdWxkIGhlbHAKCSAqIG1lcmdlX3JlY3Vyc2l2ZSBhcyB3ZWxsIChpdCBhbHNvIHdyaXRlcyB0aGUgbWVyZ2UgcmVzdWx0IHRvIHRoZQoJICogb2JqZWN0IGRhdGFiYXNlIGV2ZW4gd2hlbiBpdCBtYXkgY29udGFpbiBjb25mbGljdHMpLgoJICovCglpZiAod3JpdGVfc2hhMV9maWxlKHJlc3VsdF9idWYucHRyLCByZXN1bHRfYnVmLnNpemUsCgkJCSAgICBibG9iX3R5cGUsIHNoYTEpKQoJCWRpZShfKCJVbmFibGUgdG8gYWRkIG1lcmdlIHJlc3VsdCBmb3IgJyVzJyIpLCBwYXRoKTsKCWNlID0gbWFrZV9jYWNoZV9lbnRyeShjcmVhdGVfY2VfbW9kZShhY3RpdmVfY2FjaGVbcG9zKzFdLT5jZV9tb2RlKSwKCQkJICAgICAgc2hhMSwKCQkJICAgICAgcGF0aCwgMiwgMCk7CglpZiAoIWNlKQoJCWRpZShfKCJtYWtlX2NhY2hlX2VudHJ5IGZhaWxlZCBmb3IgcGF0aCAnJXMnIiksIHBhdGgpOwoJc3RhdHVzID0gY2hlY2tvdXRfZW50cnkoY2UsIHN0YXRlLCBOVUxMKTsKCXJldHVybiBzdGF0dXM7Cn0KCnN0YXRpYyBpbnQgY2hlY2tvdXRfcGF0aHMoc3RydWN0IHRyZWUgKnNvdXJjZV90cmVlLCBjb25zdCBjaGFyICoqcGF0aHNwZWMsCgkJCSAgY29uc3QgY2hhciAqcHJlZml4LCBzdHJ1Y3QgY2hlY2tvdXRfb3B0cyAqb3B0cykKewoJaW50IHBvczsKCXN0cnVjdCBjaGVja291dCBzdGF0ZTsKCXN0YXRpYyBjaGFyICpwc19tYXRjaGVkOwoJdW5zaWduZWQgY2hhciByZXZbMjBdOwoJaW50IGZsYWc7CglzdHJ1Y3QgY29tbWl0ICpoZWFkOwoJaW50IGVycnMgPSAwOwoJaW50IHN0YWdlID0gb3B0cy0+d3JpdGVvdXRfc3RhZ2U7CglpbnQgbWVyZ2UgPSBvcHRzLT5tZXJnZTsKCWludCBuZXdmZDsKCXN0cnVjdCBsb2NrX2ZpbGUgKmxvY2tfZmlsZSA9IHhjYWxsb2MoMSwgc2l6ZW9mKHN0cnVjdCBsb2NrX2ZpbGUpKTsKCgluZXdmZCA9IGhvbGRfbG9ja2VkX2luZGV4KGxvY2tfZmlsZSwgMSk7CglpZiAocmVhZF9jYWNoZV9wcmVsb2FkKHBhdGhzcGVjKSA8IDApCgkJcmV0dXJuIGVycm9yKF8oImNvcnJ1cHQgaW5kZXggZmlsZSIpKTsKCglpZiAoc291cmNlX3RyZWUpCgkJcmVhZF90cmVlX3NvbWUoc291cmNlX3RyZWUsIHBhdGhzcGVjKTsKCglmb3IgKHBvcyA9IDA7IHBhdGhzcGVjW3Bvc107IHBvcysrKQoJCTsKCXBzX21hdGNoZWQgPSB4Y2FsbG9jKDEsIHBvcyk7CgoJZm9yIChwb3MgPSAwOyBwb3MgPCBhY3RpdmVfbnI7IHBvcysrKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGFjdGl2ZV9jYWNoZVtwb3NdOwoJCWlmIChzb3VyY2VfdHJlZSAmJiAhKGNlLT5jZV9mbGFncyAmIENFX1VQREFURSkpCgkJCWNvbnRpbnVlOwoJCW1hdGNoX3BhdGhzcGVjKHBhdGhzcGVjLCBjZS0+bmFtZSwgY2VfbmFtZWxlbihjZSksIDAsIHBzX21hdGNoZWQpOwoJfQoKCWlmIChyZXBvcnRfcGF0aF9lcnJvcihwc19tYXRjaGVkLCBwYXRoc3BlYywgcHJlZml4KSkKCQlyZXR1cm4gMTsKCgkvKiAiY2hlY2tvdXQgLW0gcGF0aCIgdG8gcmVjcmVhdGUgY29uZmxpY3RlZCBzdGF0ZSAqLwoJaWYgKG9wdHMtPm1lcmdlKQoJCXVubWVyZ2VfY2FjaGUocGF0aHNwZWMpOwoKCS8qIEFueSB1bm1lcmdlZCBwYXRocz8gKi8KCWZvciAocG9zID0gMDsgcG9zIDwgYWN0aXZlX25yOyBwb3MrKykgewoJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBhY3RpdmVfY2FjaGVbcG9zXTsKCQlpZiAobWF0Y2hfcGF0aHNwZWMocGF0aHNwZWMsIGNlLT5uYW1lLCBjZV9uYW1lbGVuKGNlKSwgMCwgTlVMTCkpIHsKCQkJaWYgKCFjZV9zdGFnZShjZSkpCgkJCQljb250aW51ZTsKCQkJaWYgKG9wdHMtPmZvcmNlKSB7CgkJCQl3YXJuaW5nKF8oInBhdGggJyVzJyBpcyB1bm1lcmdlZCIpLCBjZS0+bmFtZSk7CgkJCX0gZWxzZSBpZiAoc3RhZ2UpIHsKCQkJCWVycnMgfD0gY2hlY2tfc3RhZ2Uoc3RhZ2UsIGNlLCBwb3MpOwoJCQl9IGVsc2UgaWYgKG9wdHMtPm1lcmdlKSB7CgkJCQllcnJzIHw9IGNoZWNrX2FsbF9zdGFnZXMoY2UsIHBvcyk7CgkJCX0gZWxzZSB7CgkJCQllcnJzID0gMTsKCQkJCWVycm9yKF8oInBhdGggJyVzJyBpcyB1bm1lcmdlZCIpLCBjZS0+bmFtZSk7CgkJCX0KCQkJcG9zID0gc2tpcF9zYW1lX25hbWUoY2UsIHBvcykgLSAxOwoJCX0KCX0KCWlmIChlcnJzKQoJCXJldHVybiAxOwoKCS8qIE5vdyB3ZSBhcmUgY29tbWl0dGVkIHRvIGNoZWNrIHRoZW0gb3V0ICovCgltZW1zZXQoJnN0YXRlLCAwLCBzaXplb2Yoc3RhdGUpKTsKCXN0YXRlLmZvcmNlID0gMTsKCXN0YXRlLnJlZnJlc2hfY2FjaGUgPSAxOwoJZm9yIChwb3MgPSAwOyBwb3MgPCBhY3RpdmVfbnI7IHBvcysrKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGFjdGl2ZV9jYWNoZVtwb3NdOwoJCWlmIChzb3VyY2VfdHJlZSAmJiAhKGNlLT5jZV9mbGFncyAmIENFX1VQREFURSkpCgkJCWNvbnRpbnVlOwoJCWlmIChtYXRjaF9wYXRoc3BlYyhwYXRoc3BlYywgY2UtPm5hbWUsIGNlX25hbWVsZW4oY2UpLCAwLCBOVUxMKSkgewoJCQlpZiAoIWNlX3N0YWdlKGNlKSkgewoJCQkJZXJycyB8PSBjaGVja291dF9lbnRyeShjZSwgJnN0YXRlLCBOVUxMKTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWlmIChzdGFnZSkKCQkJCWVycnMgfD0gY2hlY2tvdXRfc3RhZ2Uoc3RhZ2UsIGNlLCBwb3MsICZzdGF0ZSk7CgkJCWVsc2UgaWYgKG1lcmdlKQoJCQkJZXJycyB8PSBjaGVja291dF9tZXJnZWQocG9zLCAmc3RhdGUpOwoJCQlwb3MgPSBza2lwX3NhbWVfbmFtZShjZSwgcG9zKSAtIDE7CgkJfQoJfQoKCWlmICh3cml0ZV9jYWNoZShuZXdmZCwgYWN0aXZlX2NhY2hlLCBhY3RpdmVfbnIpIHx8CgkgICAgY29tbWl0X2xvY2tlZF9pbmRleChsb2NrX2ZpbGUpKQoJCWRpZShfKCJ1bmFibGUgdG8gd3JpdGUgbmV3IGluZGV4IGZpbGUiKSk7CgoJcmVhZF9yZWZfZnVsbCgiSEVBRCIsIHJldiwgMCwgJmZsYWcpOwoJaGVhZCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseShyZXYsIDEpOwoKCWVycnMgfD0gcG9zdF9jaGVja291dF9ob29rKGhlYWQsIGhlYWQsIDApOwoJcmV0dXJuIGVycnM7Cn0KCnN0YXRpYyB2b2lkIHNob3dfbG9jYWxfY2hhbmdlcyhzdHJ1Y3Qgb2JqZWN0ICpoZWFkLCBzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHRzKQp7CglzdHJ1Y3QgcmV2X2luZm8gcmV2OwoJLyogSSB0aGluayB3ZSB3YW50IGZ1bGwgcGF0aHMsIGV2ZW4gaWYgd2UncmUgaW4gYSBzdWJkaXJlY3RvcnkuICovCglpbml0X3JldmlzaW9ucygmcmV2LCBOVUxMKTsKCXJldi5kaWZmb3B0LmZsYWdzID0gb3B0cy0+ZmxhZ3M7CglyZXYuZGlmZm9wdC5vdXRwdXRfZm9ybWF0IHw9IERJRkZfRk9STUFUX05BTUVfU1RBVFVTOwoJaWYgKGRpZmZfc2V0dXBfZG9uZSgmcmV2LmRpZmZvcHQpIDwgMCkKCQlkaWUoXygiZGlmZl9zZXR1cF9kb25lIGZhaWxlZCIpKTsKCWFkZF9wZW5kaW5nX29iamVjdCgmcmV2LCBoZWFkLCBOVUxMKTsKCXJ1bl9kaWZmX2luZGV4KCZyZXYsIDApOwp9CgpzdGF0aWMgdm9pZCBkZXNjcmliZV9kZXRhY2hlZF9oZWFkKGNvbnN0IGNoYXIgKm1zZywgc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CglwYXJzZV9jb21taXQoY29tbWl0KTsKCXBwX2NvbW1pdF9lYXN5KENNSVRfRk1UX09ORUxJTkUsIGNvbW1pdCwgJnNiKTsKCWZwcmludGYoc3RkZXJyLCAiJXMgJXMuLi4gJXNcbiIsIG1zZywKCQlmaW5kX3VuaXF1ZV9hYmJyZXYoY29tbWl0LT5vYmplY3Quc2hhMSwgREVGQVVMVF9BQkJSRVYpLCBzYi5idWYpOwoJc3RyYnVmX3JlbGVhc2UoJnNiKTsKfQoKc3RhdGljIGludCByZXNldF90cmVlKHN0cnVjdCB0cmVlICp0cmVlLCBzdHJ1Y3QgY2hlY2tvdXRfb3B0cyAqbywgaW50IHdvcmt0cmVlKQp7CglzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgb3B0czsKCXN0cnVjdCB0cmVlX2Rlc2MgdHJlZV9kZXNjOwoKCW1lbXNldCgmb3B0cywgMCwgc2l6ZW9mKG9wdHMpKTsKCW9wdHMuaGVhZF9pZHggPSAtMTsKCW9wdHMudXBkYXRlID0gd29ya3RyZWU7CglvcHRzLnNraXBfdW5tZXJnZWQgPSAhd29ya3RyZWU7CglvcHRzLnJlc2V0ID0gMTsKCW9wdHMubWVyZ2UgPSAxOwoJb3B0cy5mbiA9IG9uZXdheV9tZXJnZTsKCW9wdHMudmVyYm9zZV91cGRhdGUgPSAhby0+cXVpZXQ7CglvcHRzLnNyY19pbmRleCA9ICZ0aGVfaW5kZXg7CglvcHRzLmRzdF9pbmRleCA9ICZ0aGVfaW5kZXg7CglwYXJzZV90cmVlKHRyZWUpOwoJaW5pdF90cmVlX2Rlc2MoJnRyZWVfZGVzYywgdHJlZS0+YnVmZmVyLCB0cmVlLT5zaXplKTsKCXN3aXRjaCAodW5wYWNrX3RyZWVzKDEsICZ0cmVlX2Rlc2MsICZvcHRzKSkgewoJY2FzZSAtMjoKCQlvLT53cml0ZW91dF9lcnJvciA9IDE7CgkJLyoKCQkgKiBXZSByZXR1cm4gMCBuZXZlcnRoZWxlc3MsIGFzIHRoZSBpbmRleCBpcyBhbGwgcmlnaHQKCQkgKiBhbmQgbW9yZSBpbXBvcnRhbnRseSB3ZSBoYXZlIG1hZGUgYmVzdCBlZmZvcnRzIHRvCgkJICogdXBkYXRlIHBhdGhzIGluIHRoZSB3b3JrIHRyZWUsIGFuZCB3ZSBjYW5ub3QgcmV2ZXJ0CgkJICogdGhlbS4KCQkgKi8KCWNhc2UgMDoKCQlyZXR1cm4gMDsKCWRlZmF1bHQ6CgkJcmV0dXJuIDEyODsKCX0KfQoKc3RydWN0IGJyYW5jaF9pbmZvIHsKCWNvbnN0IGNoYXIgKm5hbWU7IC8qIFRoZSBzaG9ydCBuYW1lIHVzZWQgKi8KCWNvbnN0IGNoYXIgKnBhdGg7IC8qIFRoZSBmdWxsIG5hbWUgb2YgYSByZWFsIGJyYW5jaCAqLwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OyAvKiBUaGUgbmFtZWQgY29tbWl0ICovCn07CgpzdGF0aWMgdm9pZCBzZXR1cF9icmFuY2hfcGF0aChzdHJ1Y3QgYnJhbmNoX2luZm8gKmJyYW5jaCkKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCglzdHJidWZfYnJhbmNobmFtZSgmYnVmLCBicmFuY2gtPm5hbWUpOwoJaWYgKHN0cmNtcChidWYuYnVmLCBicmFuY2gtPm5hbWUpKQoJCWJyYW5jaC0+bmFtZSA9IHhzdHJkdXAoYnVmLmJ1Zik7CglzdHJidWZfc3BsaWNlKCZidWYsIDAsIDAsICJyZWZzL2hlYWRzLyIsIDExKTsKCWJyYW5jaC0+cGF0aCA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7Cn0KCnN0YXRpYyBpbnQgbWVyZ2Vfd29ya2luZ190cmVlKHN0cnVjdCBjaGVja291dF9vcHRzICpvcHRzLAoJCQkgICAgICBzdHJ1Y3QgYnJhbmNoX2luZm8gKm9sZCwgc3RydWN0IGJyYW5jaF9pbmZvICpuZXcpCnsKCWludCByZXQ7CglzdHJ1Y3QgbG9ja19maWxlICpsb2NrX2ZpbGUgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3QgbG9ja19maWxlKSk7CglpbnQgbmV3ZmQgPSBob2xkX2xvY2tlZF9pbmRleChsb2NrX2ZpbGUsIDEpOwoKCWlmIChyZWFkX2NhY2hlX3ByZWxvYWQoTlVMTCkgPCAwKQoJCXJldHVybiBlcnJvcihfKCJjb3JydXB0IGluZGV4IGZpbGUiKSk7CgoJcmVzb2x2ZV91bmRvX2NsZWFyKCk7CglpZiAob3B0cy0+Zm9yY2UpIHsKCQlyZXQgPSByZXNldF90cmVlKG5ldy0+Y29tbWl0LT50cmVlLCBvcHRzLCAxKTsKCQlpZiAocmV0KQoJCQlyZXR1cm4gcmV0OwoJfSBlbHNlIHsKCQlzdHJ1Y3QgdHJlZV9kZXNjIHRyZWVzWzJdOwoJCXN0cnVjdCB0cmVlICp0cmVlOwoJCXN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyB0b3B0czsKCgkJbWVtc2V0KCZ0b3B0cywgMCwgc2l6ZW9mKHRvcHRzKSk7CgkJdG9wdHMuaGVhZF9pZHggPSAtMTsKCQl0b3B0cy5zcmNfaW5kZXggPSAmdGhlX2luZGV4OwoJCXRvcHRzLmRzdF9pbmRleCA9ICZ0aGVfaW5kZXg7CgoJCXNldHVwX3VucGFja190cmVlc19wb3JjZWxhaW4oJnRvcHRzLCAiY2hlY2tvdXQiKTsKCgkJcmVmcmVzaF9jYWNoZShSRUZSRVNIX1FVSUVUKTsKCgkJaWYgKHVubWVyZ2VkX2NhY2hlKCkpIHsKCQkJZXJyb3IoXygieW91IG5lZWQgdG8gcmVzb2x2ZSB5b3VyIGN1cnJlbnQgaW5kZXggZmlyc3QiKSk7CgkJCXJldHVybiAxOwoJCX0KCgkJLyogMi13YXkgbWVyZ2UgdG8gdGhlIG5ldyBicmFuY2ggKi8KCQl0b3B0cy5pbml0aWFsX2NoZWNrb3V0ID0gaXNfY2FjaGVfdW5ib3JuKCk7CgkJdG9wdHMudXBkYXRlID0gMTsKCQl0b3B0cy5tZXJnZSA9IDE7CgkJdG9wdHMuZ2VudGx5ID0gb3B0cy0+bWVyZ2UgJiYgb2xkLT5jb21taXQ7CgkJdG9wdHMudmVyYm9zZV91cGRhdGUgPSAhb3B0cy0+cXVpZXQ7CgkJdG9wdHMuZm4gPSB0d293YXlfbWVyZ2U7CgkJdG9wdHMuZGlyID0geGNhbGxvYygxLCBzaXplb2YoKnRvcHRzLmRpcikpOwoJCXRvcHRzLmRpci0+ZmxhZ3MgfD0gRElSX1NIT1dfSUdOT1JFRDsKCQlzZXR1cF9zdGFuZGFyZF9leGNsdWRlcyh0b3B0cy5kaXIpOwoJCXRyZWUgPSBwYXJzZV90cmVlX2luZGlyZWN0KG9sZC0+Y29tbWl0ID8KCQkJCQkgICBvbGQtPmNvbW1pdC0+b2JqZWN0LnNoYTEgOgoJCQkJCSAgIEVNUFRZX1RSRUVfU0hBMV9CSU4pOwoJCWluaXRfdHJlZV9kZXNjKCZ0cmVlc1swXSwgdHJlZS0+YnVmZmVyLCB0cmVlLT5zaXplKTsKCQl0cmVlID0gcGFyc2VfdHJlZV9pbmRpcmVjdChuZXctPmNvbW1pdC0+b2JqZWN0LnNoYTEpOwoJCWluaXRfdHJlZV9kZXNjKCZ0cmVlc1sxXSwgdHJlZS0+YnVmZmVyLCB0cmVlLT5zaXplKTsKCgkJcmV0ID0gdW5wYWNrX3RyZWVzKDIsIHRyZWVzLCAmdG9wdHMpOwoJCWlmIChyZXQgPT0gLTEpIHsKCQkJLyoKCQkJICogVW5wYWNrIGNvdWxkbid0IGRvIGEgdHJpdmlhbCBtZXJnZTsgZWl0aGVyCgkJCSAqIGdpdmUgdXAgb3IgZG8gYSByZWFsIG1lcmdlLCBkZXBlbmRpbmcgb24KCQkJICogd2hldGhlciB0aGUgbWVyZ2UgZmxhZyB3YXMgdXNlZC4KCQkJICovCgkJCXN0cnVjdCB0cmVlICpyZXN1bHQ7CgkJCXN0cnVjdCB0cmVlICp3b3JrOwoJCQlzdHJ1Y3QgbWVyZ2Vfb3B0aW9ucyBvOwoJCQlpZiAoIW9wdHMtPm1lcmdlKQoJCQkJcmV0dXJuIDE7CgoJCQkvKgoJCQkgKiBXaXRob3V0IG9sZC0+Y29tbWl0LCB0aGUgYmVsb3cgaXMgdGhlIHNhbWUgYXMKCQkJICogdGhlIHR3by10cmVlIHVucGFjayB3ZSBhbHJlYWR5IHRyaWVkIGFuZCBmYWlsZWQuCgkJCSAqLwoJCQlpZiAoIW9sZC0+Y29tbWl0KQoJCQkJcmV0dXJuIDE7CgoJCQkvKiBEbyBtb3JlIHJlYWwgbWVyZ2UgKi8KCgkJCS8qCgkJCSAqIFdlIHVwZGF0ZSB0aGUgaW5kZXggZnVsbHksIHRoZW4gd3JpdGUgdGhlCgkJCSAqIHRyZWUgZnJvbSB0aGUgaW5kZXgsIHRoZW4gbWVyZ2UgdGhlIG5ldwoJCQkgKiBicmFuY2ggd2l0aCB0aGUgY3VycmVudCB0cmVlLCB3aXRoIHRoZSBvbGQKCQkJICogYnJhbmNoIGFzIHRoZSBiYXNlLiBUaGVuIHdlIHJlc2V0IHRoZSBpbmRleAoJCQkgKiAoYnV0IG5vdCB0aGUgd29ya2luZyB0cmVlKSB0byB0aGUgbmV3CgkJCSAqIGJyYW5jaCwgbGVhdmluZyB0aGUgd29ya2luZyB0cmVlIGFzIHRoZQoJCQkgKiBtZXJnZWQgdmVyc2lvbiwgYnV0IHNraXBwaW5nIHVubWVyZ2VkCgkJCSAqIGVudHJpZXMgaW4gdGhlIGluZGV4LgoJCQkgKi8KCgkJCWFkZF9maWxlc190b19jYWNoZShOVUxMLCBOVUxMLCAwKTsKCQkJLyoKCQkJICogTkVFRFNXT1JLOiBjYXJyeWluZyBvdmVyIGxvY2FsIGNoYW5nZXMKCQkJICogd2hlbiBicmFuY2hlcyBoYXZlIGRpZmZlcmVudCBlbmQtb2YtbGluZQoJCQkgKiBub3JtYWxpemF0aW9uIChvciBjbGVhbitzbXVkZ2UgcnVsZXMpIGlzCgkJCSAqIGEgcGFpbjsgcGx1bWIgaW4gYW4gb3B0aW9uIHRvIHNldAoJCQkgKiBvLnJlbm9ybWFsaXplPwoJCQkgKi8KCQkJaW5pdF9tZXJnZV9vcHRpb25zKCZvKTsKCQkJby52ZXJib3NpdHkgPSAwOwoJCQl3b3JrID0gd3JpdGVfdHJlZV9mcm9tX21lbW9yeSgmbyk7CgoJCQlyZXQgPSByZXNldF90cmVlKG5ldy0+Y29tbWl0LT50cmVlLCBvcHRzLCAxKTsKCQkJaWYgKHJldCkKCQkJCXJldHVybiByZXQ7CgkJCW8uYW5jZXN0b3IgPSBvbGQtPm5hbWU7CgkJCW8uYnJhbmNoMSA9IG5ldy0+bmFtZTsKCQkJby5icmFuY2gyID0gImxvY2FsIjsKCQkJbWVyZ2VfdHJlZXMoJm8sIG5ldy0+Y29tbWl0LT50cmVlLCB3b3JrLAoJCQkJb2xkLT5jb21taXQtPnRyZWUsICZyZXN1bHQpOwoJCQlyZXQgPSByZXNldF90cmVlKG5ldy0+Y29tbWl0LT50cmVlLCBvcHRzLCAwKTsKCQkJaWYgKHJldCkKCQkJCXJldHVybiByZXQ7CgkJfQoJfQoKCWlmICh3cml0ZV9jYWNoZShuZXdmZCwgYWN0aXZlX2NhY2hlLCBhY3RpdmVfbnIpIHx8CgkgICAgY29tbWl0X2xvY2tlZF9pbmRleChsb2NrX2ZpbGUpKQoJCWRpZShfKCJ1bmFibGUgdG8gd3JpdGUgbmV3IGluZGV4IGZpbGUiKSk7CgoJaWYgKCFvcHRzLT5mb3JjZSAmJiAhb3B0cy0+cXVpZXQpCgkJc2hvd19sb2NhbF9jaGFuZ2VzKCZuZXctPmNvbW1pdC0+b2JqZWN0LCAmb3B0cy0+ZGlmZl9vcHRpb25zKTsKCglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgcmVwb3J0X3RyYWNraW5nKHN0cnVjdCBicmFuY2hfaW5mbyAqbmV3KQp7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3QgYnJhbmNoICpicmFuY2ggPSBicmFuY2hfZ2V0KG5ldy0+bmFtZSk7CgoJaWYgKCFmb3JtYXRfdHJhY2tpbmdfaW5mbyhicmFuY2gsICZzYikpCgkJcmV0dXJuOwoJZnB1dHMoc2IuYnVmLCBzdGRvdXQpOwoJc3RyYnVmX3JlbGVhc2UoJnNiKTsKfQoKc3RhdGljIHZvaWQgZGV0YWNoX2FkdmljZShjb25zdCBjaGFyICpvbGRfcGF0aCwgY29uc3QgY2hhciAqbmV3X25hbWUpCnsKCWNvbnN0IGNoYXIgZm10W10gPQoJIk5vdGU6IGNoZWNraW5nIG91dCAnJXMnLlxuXG4iCgkiWW91IGFyZSBpbiAnZGV0YWNoZWQgSEVBRCcgc3RhdGUuIFlvdSBjYW4gbG9vayBhcm91bmQsIG1ha2UgZXhwZXJpbWVudGFsXG4iCgkiY2hhbmdlcyBhbmQgY29tbWl0IHRoZW0sIGFuZCB5b3UgY2FuIGRpc2NhcmQgYW55IGNvbW1pdHMgeW91IG1ha2UgaW4gdGhpc1xuIgoJInN0YXRlIHdpdGhvdXQgaW1wYWN0aW5nIGFueSBicmFuY2hlcyBieSBwZXJmb3JtaW5nIGFub3RoZXIgY2hlY2tvdXQuXG5cbiIKCSJJZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBuZXcgYnJhbmNoIHRvIHJldGFpbiBjb21taXRzIHlvdSBjcmVhdGUsIHlvdSBtYXlcbiIKCSJkbyBzbyAobm93IG9yIGxhdGVyKSBieSB1c2luZyAtYiB3aXRoIHRoZSBjaGVja291dCBjb21tYW5kIGFnYWluLiBFeGFtcGxlOlxuXG4iCgkiICBnaXQgY2hlY2tvdXQgLWIgbmV3X2JyYW5jaF9uYW1lXG5cbiI7CgoJZnByaW50ZihzdGRlcnIsIGZtdCwgbmV3X25hbWUpOwp9CgpzdGF0aWMgdm9pZCB1cGRhdGVfcmVmc19mb3Jfc3dpdGNoKHN0cnVjdCBjaGVja291dF9vcHRzICpvcHRzLAoJCQkJICAgc3RydWN0IGJyYW5jaF9pbmZvICpvbGQsCgkJCQkgICBzdHJ1Y3QgYnJhbmNoX2luZm8gKm5ldykKewoJc3RydWN0IHN0cmJ1ZiBtc2cgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKm9sZF9kZXNjOwoJaWYgKG9wdHMtPm5ld19icmFuY2gpIHsKCQlpZiAob3B0cy0+bmV3X29ycGhhbl9icmFuY2gpIHsKCQkJaWYgKG9wdHMtPm5ld19icmFuY2hfbG9nICYmICFsb2dfYWxsX3JlZl91cGRhdGVzKSB7CgkJCQlpbnQgdGVtcDsKCQkJCWNoYXIgbG9nX2ZpbGVbUEFUSF9NQVhdOwoJCQkJY2hhciAqcmVmX25hbWUgPSBta3BhdGgoInJlZnMvaGVhZHMvJXMiLCBvcHRzLT5uZXdfb3JwaGFuX2JyYW5jaCk7CgoJCQkJdGVtcCA9IGxvZ19hbGxfcmVmX3VwZGF0ZXM7CgkJCQlsb2dfYWxsX3JlZl91cGRhdGVzID0gMTsKCQkJCWlmIChsb2dfcmVmX3NldHVwKHJlZl9uYW1lLCBsb2dfZmlsZSwgc2l6ZW9mKGxvZ19maWxlKSkpIHsKCQkJCQlmcHJpbnRmKHN0ZGVyciwgXygiQ2FuIG5vdCBkbyByZWZsb2cgZm9yICclcydcbiIpLAoJCQkJCSAgICBvcHRzLT5uZXdfb3JwaGFuX2JyYW5jaCk7CgkJCQkJbG9nX2FsbF9yZWZfdXBkYXRlcyA9IHRlbXA7CgkJCQkJcmV0dXJuOwoJCQkJfQoJCQkJbG9nX2FsbF9yZWZfdXBkYXRlcyA9IHRlbXA7CgkJCX0KCQl9CgkJZWxzZQoJCQljcmVhdGVfYnJhbmNoKG9sZC0+bmFtZSwgb3B0cy0+bmV3X2JyYW5jaCwgbmV3LT5uYW1lLAoJCQkJICAgICAgb3B0cy0+bmV3X2JyYW5jaF9mb3JjZSA/IDEgOiAwLAoJCQkJICAgICAgb3B0cy0+bmV3X2JyYW5jaF9sb2csIG9wdHMtPnRyYWNrKTsKCQluZXctPm5hbWUgPSBvcHRzLT5uZXdfYnJhbmNoOwoJCXNldHVwX2JyYW5jaF9wYXRoKG5ldyk7Cgl9CgoJb2xkX2Rlc2MgPSBvbGQtPm5hbWU7CglpZiAoIW9sZF9kZXNjICYmIG9sZC0+Y29tbWl0KQoJCW9sZF9kZXNjID0gc2hhMV90b19oZXgob2xkLT5jb21taXQtPm9iamVjdC5zaGExKTsKCXN0cmJ1Zl9hZGRmKCZtc2csICJjaGVja291dDogbW92aW5nIGZyb20gJXMgdG8gJXMiLAoJCSAgICBvbGRfZGVzYyA/IG9sZF9kZXNjIDogIihpbnZhbGlkKSIsIG5ldy0+bmFtZSk7CgoJaWYgKCFzdHJjbXAobmV3LT5uYW1lLCAiSEVBRCIpICYmICFuZXctPnBhdGggJiYgIW9wdHMtPmZvcmNlX2RldGFjaCkgewoJCS8qIE5vdGhpbmcgdG8gZG8uICovCgl9IGVsc2UgaWYgKG9wdHMtPmZvcmNlX2RldGFjaCB8fCAhbmV3LT5wYXRoKSB7CS8qIE5vIGxvbmdlciBvbiBhbnkgYnJhbmNoLiAqLwoJCXVwZGF0ZV9yZWYobXNnLmJ1ZiwgIkhFQUQiLCBuZXctPmNvbW1pdC0+b2JqZWN0LnNoYTEsIE5VTEwsCgkJCSAgIFJFRl9OT0RFUkVGLCBESUVfT05fRVJSKTsKCQlpZiAoIW9wdHMtPnF1aWV0KSB7CgkJCWlmIChvbGQtPnBhdGggJiYgYWR2aWNlX2RldGFjaGVkX2hlYWQpCgkJCQlkZXRhY2hfYWR2aWNlKG9sZC0+cGF0aCwgbmV3LT5uYW1lKTsKCQkJZGVzY3JpYmVfZGV0YWNoZWRfaGVhZChfKCJIRUFEIGlzIG5vdyBhdCIpLCBuZXctPmNvbW1pdCk7CgkJfQoJfSBlbHNlIGlmIChuZXctPnBhdGgpIHsJLyogU3dpdGNoIGJyYW5jaGVzLiAqLwoJCWNyZWF0ZV9zeW1yZWYoIkhFQUQiLCBuZXctPnBhdGgsIG1zZy5idWYpOwoJCWlmICghb3B0cy0+cXVpZXQpIHsKCQkJaWYgKG9sZC0+cGF0aCAmJiAhc3RyY21wKG5ldy0+cGF0aCwgb2xkLT5wYXRoKSkgewoJCQkJZnByaW50ZihzdGRlcnIsIF8oIkFscmVhZHkgb24gJyVzJ1xuIiksCgkJCQkJbmV3LT5uYW1lKTsKCQkJfSBlbHNlIGlmIChvcHRzLT5uZXdfYnJhbmNoKSB7CgkJCQlpZiAob3B0cy0+YnJhbmNoX2V4aXN0cykKCQkJCQlmcHJpbnRmKHN0ZGVyciwgXygiU3dpdGNoZWQgdG8gYW5kIHJlc2V0IGJyYW5jaCAnJXMnXG4iKSwgbmV3LT5uYW1lKTsKCQkJCWVsc2UKCQkJCQlmcHJpbnRmKHN0ZGVyciwgXygiU3dpdGNoZWQgdG8gYSBuZXcgYnJhbmNoICclcydcbiIpLCBuZXctPm5hbWUpOwoJCQl9IGVsc2UgewoJCQkJZnByaW50ZihzdGRlcnIsIF8oIlN3aXRjaGVkIHRvIGJyYW5jaCAnJXMnXG4iKSwKCQkJCQluZXctPm5hbWUpOwoJCQl9CgkJfQoJCWlmIChvbGQtPnBhdGggJiYgb2xkLT5uYW1lKSB7CgkJCWNoYXIgbG9nX2ZpbGVbUEFUSF9NQVhdLCByZWZfZmlsZVtQQVRIX01BWF07CgoJCQlnaXRfc25wYXRoKGxvZ19maWxlLCBzaXplb2YobG9nX2ZpbGUpLCAibG9ncy8lcyIsIG9sZC0+cGF0aCk7CgkJCWdpdF9zbnBhdGgocmVmX2ZpbGUsIHNpemVvZihyZWZfZmlsZSksICIlcyIsIG9sZC0+cGF0aCk7CgkJCWlmICghZmlsZV9leGlzdHMocmVmX2ZpbGUpICYmIGZpbGVfZXhpc3RzKGxvZ19maWxlKSkKCQkJCXJlbW92ZV9wYXRoKGxvZ19maWxlKTsKCQl9Cgl9CglyZW1vdmVfYnJhbmNoX3N0YXRlKCk7CglzdHJidWZfcmVsZWFzZSgmbXNnKTsKCWlmICghb3B0cy0+cXVpZXQgJiYKCSAgICAobmV3LT5wYXRoIHx8ICghb3B0cy0+Zm9yY2VfZGV0YWNoICYmICFzdHJjbXAobmV3LT5uYW1lLCAiSEVBRCIpKSkpCgkJcmVwb3J0X3RyYWNraW5nKG5ldyk7Cn0KCnN0YXRpYyBpbnQgYWRkX3BlbmRpbmdfdW5pbnRlcmVzdGluZ19yZWYoY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJCQkgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkJCQkgaW50IGZsYWdzLCB2b2lkICpjYl9kYXRhKQp7CglhZGRfcGVuZGluZ19zaGExKGNiX2RhdGEsIHJlZm5hbWUsIHNoYTEsIGZsYWdzIHwgVU5JTlRFUkVTVElORyk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgZGVzY3JpYmVfb25lX29ycGhhbihzdHJ1Y3Qgc3RyYnVmICpzYiwgc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglwYXJzZV9jb21taXQoY29tbWl0KTsKCXN0cmJ1Zl9hZGRzdHIoc2IsICIgICIpOwoJc3RyYnVmX2FkZHN0cihzYiwKCQlmaW5kX3VuaXF1ZV9hYmJyZXYoY29tbWl0LT5vYmplY3Quc2hhMSwgREVGQVVMVF9BQkJSRVYpKTsKCXN0cmJ1Zl9hZGRjaChzYiwgJyAnKTsKCXBwX2NvbW1pdF9lYXN5KENNSVRfRk1UX09ORUxJTkUsIGNvbW1pdCwgc2IpOwoJc3RyYnVmX2FkZGNoKHNiLCAnXG4nKTsKfQoKI2RlZmluZSBPUlBIQU5fQ1VUT0ZGIDQKc3RhdGljIHZvaWQgc3VnZ2VzdF9yZWF0dGFjaChzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHN0cnVjdCByZXZfaW5mbyAqcmV2cykKewoJc3RydWN0IGNvbW1pdCAqYywgKmxhc3QgPSBOVUxMOwoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJaW50IGxvc3QgPSAwOwoJd2hpbGUgKChjID0gZ2V0X3JldmlzaW9uKHJldnMpKSAhPSBOVUxMKSB7CgkJaWYgKGxvc3QgPCBPUlBIQU5fQ1VUT0ZGKQoJCQlkZXNjcmliZV9vbmVfb3JwaGFuKCZzYiwgYyk7CgkJbGFzdCA9IGM7CgkJbG9zdCsrOwoJfQoJaWYgKE9SUEhBTl9DVVRPRkYgPCBsb3N0KSB7CgkJaW50IG1vcmUgPSBsb3N0IC0gT1JQSEFOX0NVVE9GRjsKCQlpZiAobW9yZSA9PSAxKQoJCQlkZXNjcmliZV9vbmVfb3JwaGFuKCZzYiwgbGFzdCk7CgkJZWxzZQoJCQlzdHJidWZfYWRkZigmc2IsIF8oIiAuLi4gYW5kICVkIG1vcmUuXG4iKSwgbW9yZSk7Cgl9CgoJZnByaW50ZihzdGRlcnIsCgkJUV8oCgkJLyogVGhlIHNpbmd1bGFyIHZlcnNpb24gKi8KCQkiV2FybmluZzogeW91IGFyZSBsZWF2aW5nICVkIGNvbW1pdCBiZWhpbmQsICIKCQkibm90IGNvbm5lY3RlZCB0b1xuIgoJCSJhbnkgb2YgeW91ciBicmFuY2hlczpcblxuIgoJCSIlc1xuIiwKCQkvKiBUaGUgcGx1cmFsIHZlcnNpb24gKi8KCQkiV2FybmluZzogeW91IGFyZSBsZWF2aW5nICVkIGNvbW1pdHMgYmVoaW5kLCAiCgkJIm5vdCBjb25uZWN0ZWQgdG9cbiIKCQkiYW55IG9mIHlvdXIgYnJhbmNoZXM6XG5cbiIKCQkiJXNcbiIsCgkJLyogR2l2ZSBuZ2V0dGV4dCgpIHRoZSBjb3VudCAqLwoJCWxvc3QpLAoJCWxvc3QsCgkJc2IuYnVmKTsKCXN0cmJ1Zl9yZWxlYXNlKCZzYik7CgoJaWYgKGFkdmljZV9kZXRhY2hlZF9oZWFkKQoJCWZwcmludGYoc3RkZXJyLAoJCQlfKAoJCQkiSWYgeW91IHdhbnQgdG8ga2VlcCB0aGVtIGJ5IGNyZWF0aW5nIGEgbmV3IGJyYW5jaCwgIgoJCQkidGhpcyBtYXkgYmUgYSBnb29kIHRpbWVcbnRvIGRvIHNvIHdpdGg6XG5cbiIKCQkJIiBnaXQgYnJhbmNoIG5ld19icmFuY2hfbmFtZSAlc1xuXG4iKSwKCQkJc2hhMV90b19oZXgoY29tbWl0LT5vYmplY3Quc2hhMSkpOwp9CgovKgogKiBXZSBhcmUgYWJvdXQgdG8gbGVhdmUgY29tbWl0IHRoYXQgd2FzIGF0IHRoZSB0aXAgb2YgYSBkZXRhY2hlZAogKiBIRUFELiAgSWYgaXQgaXMgbm90IHJlYWNoYWJsZSBmcm9tIGFueSByZWYsIHRoaXMgaXMgdGhlIGxhc3QgY2hhbmNlCiAqIGZvciB0aGUgdXNlciB0byBkbyBzbyB3aXRob3V0IHJlc29ydGluZyB0byByZWZsb2cuCiAqLwpzdGF0aWMgdm9pZCBvcnBoYW5lZF9jb21taXRfd2FybmluZyhzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCXN0cnVjdCByZXZfaW5mbyByZXZzOwoJc3RydWN0IG9iamVjdCAqb2JqZWN0ID0gJmNvbW1pdC0+b2JqZWN0OwoJc3RydWN0IG9iamVjdF9hcnJheSByZWZzOwoKCWluaXRfcmV2aXNpb25zKCZyZXZzLCBOVUxMKTsKCXNldHVwX3JldmlzaW9ucygwLCBOVUxMLCAmcmV2cywgTlVMTCk7CgoJb2JqZWN0LT5mbGFncyAmPSB+VU5JTlRFUkVTVElORzsKCWFkZF9wZW5kaW5nX29iamVjdCgmcmV2cywgb2JqZWN0LCBzaGExX3RvX2hleChvYmplY3QtPnNoYTEpKTsKCglmb3JfZWFjaF9yZWYoYWRkX3BlbmRpbmdfdW5pbnRlcmVzdGluZ19yZWYsICZyZXZzKTsKCglyZWZzID0gcmV2cy5wZW5kaW5nOwoJcmV2cy5sZWFrX3BlbmRpbmcgPSAxOwoKCWlmIChwcmVwYXJlX3JldmlzaW9uX3dhbGsoJnJldnMpKQoJCWRpZShfKCJpbnRlcm5hbCBlcnJvciBpbiByZXZpc2lvbiB3YWxrIikpOwoJaWYgKCEoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBVTklOVEVSRVNUSU5HKSkKCQlzdWdnZXN0X3JlYXR0YWNoKGNvbW1pdCwgJnJldnMpOwoJZWxzZQoJCWRlc2NyaWJlX2RldGFjaGVkX2hlYWQoXygiUHJldmlvdXMgSEVBRCBwb3NpdGlvbiB3YXMiKSwgY29tbWl0KTsKCgljbGVhcl9jb21taXRfbWFya3NfZm9yX29iamVjdF9hcnJheSgmcmVmcywgQUxMX1JFVl9GTEFHUyk7CglmcmVlKHJlZnMub2JqZWN0cyk7Cn0KCnN0YXRpYyBpbnQgc3dpdGNoX2JyYW5jaGVzKHN0cnVjdCBjaGVja291dF9vcHRzICpvcHRzLCBzdHJ1Y3QgYnJhbmNoX2luZm8gKm5ldykKewoJaW50IHJldCA9IDA7CglzdHJ1Y3QgYnJhbmNoX2luZm8gb2xkOwoJdm9pZCAqcGF0aF90b19mcmVlOwoJdW5zaWduZWQgY2hhciByZXZbMjBdOwoJaW50IGZsYWc7CgltZW1zZXQoJm9sZCwgMCwgc2l6ZW9mKG9sZCkpOwoJb2xkLnBhdGggPSBwYXRoX3RvX2ZyZWUgPSByZXNvbHZlX3JlZmR1cCgiSEVBRCIsIHJldiwgMCwgJmZsYWcpOwoJb2xkLmNvbW1pdCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseShyZXYsIDEpOwoJaWYgKCEoZmxhZyAmIFJFRl9JU1NZTVJFRikpCgkJb2xkLnBhdGggPSBOVUxMOwoKCWlmIChvbGQucGF0aCAmJiAhcHJlZml4Y21wKG9sZC5wYXRoLCAicmVmcy9oZWFkcy8iKSkKCQlvbGQubmFtZSA9IG9sZC5wYXRoICsgc3RybGVuKCJyZWZzL2hlYWRzLyIpOwoKCWlmICghbmV3LT5uYW1lKSB7CgkJbmV3LT5uYW1lID0gIkhFQUQiOwoJCW5ldy0+Y29tbWl0ID0gb2xkLmNvbW1pdDsKCQlpZiAoIW5ldy0+Y29tbWl0KQoJCQlkaWUoXygiWW91IGFyZSBvbiBhIGJyYW5jaCB5ZXQgdG8gYmUgYm9ybiIpKTsKCQlwYXJzZV9jb21taXQobmV3LT5jb21taXQpOwoJfQoKCXJldCA9IG1lcmdlX3dvcmtpbmdfdHJlZShvcHRzLCAmb2xkLCBuZXcpOwoJaWYgKHJldCkgewoJCWZyZWUocGF0aF90b19mcmVlKTsKCQlyZXR1cm4gcmV0OwoJfQoKCWlmICghb3B0cy0+cXVpZXQgJiYgIW9sZC5wYXRoICYmIG9sZC5jb21taXQgJiYgbmV3LT5jb21taXQgIT0gb2xkLmNvbW1pdCkKCQlvcnBoYW5lZF9jb21taXRfd2FybmluZyhvbGQuY29tbWl0KTsKCgl1cGRhdGVfcmVmc19mb3Jfc3dpdGNoKG9wdHMsICZvbGQsIG5ldyk7CgoJcmV0ID0gcG9zdF9jaGVja291dF9ob29rKG9sZC5jb21taXQsIG5ldy0+Y29tbWl0LCAxKTsKCWZyZWUocGF0aF90b19mcmVlKTsKCXJldHVybiByZXQgfHwgb3B0cy0+d3JpdGVvdXRfZXJyb3I7Cn0KCnN0YXRpYyBpbnQgZ2l0X2NoZWNrb3V0X2NvbmZpZyhjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlLCB2b2lkICpjYikKewoJaWYgKCFzdHJjbXAodmFyLCAiZGlmZi5pZ25vcmVzdWJtb2R1bGVzIikpIHsKCQlzdHJ1Y3QgY2hlY2tvdXRfb3B0cyAqb3B0cyA9IGNiOwoJCWhhbmRsZV9pZ25vcmVfc3VibW9kdWxlc19hcmcoJm9wdHMtPmRpZmZfb3B0aW9ucywgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoKCWlmICghcHJlZml4Y21wKHZhciwgInN1Ym1vZHVsZS4iKSkKCQlyZXR1cm4gcGFyc2Vfc3VibW9kdWxlX2NvbmZpZ19vcHRpb24odmFyLCB2YWx1ZSk7CgoJcmV0dXJuIGdpdF94bWVyZ2VfY29uZmlnKHZhciwgdmFsdWUsIE5VTEwpOwp9CgpzdGF0aWMgaW50IGludGVyYWN0aXZlX2NoZWNrb3V0KGNvbnN0IGNoYXIgKnJldmlzaW9uLCBjb25zdCBjaGFyICoqcGF0aHNwZWMsCgkJCQlzdHJ1Y3QgY2hlY2tvdXRfb3B0cyAqb3B0cykKewoJcmV0dXJuIHJ1bl9hZGRfaW50ZXJhY3RpdmUocmV2aXNpb24sICItLXBhdGNoPWNoZWNrb3V0IiwgcGF0aHNwZWMpOwp9CgpzdHJ1Y3QgdHJhY2tpbmdfbmFtZV9kYXRhIHsKCWNvbnN0IGNoYXIgKm5hbWU7CgljaGFyICpyZW1vdGU7CglpbnQgdW5pcXVlOwp9OwoKc3RhdGljIGludCBjaGVja190cmFja2luZ19uYW1lKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsCgkJCSAgICAgICBpbnQgZmxhZ3MsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCB0cmFja2luZ19uYW1lX2RhdGEgKmNiID0gY2JfZGF0YTsKCWNvbnN0IGNoYXIgKnNsYXNoOwoKCWlmIChwcmVmaXhjbXAocmVmbmFtZSwgInJlZnMvcmVtb3Rlcy8iKSkKCQlyZXR1cm4gMDsKCXNsYXNoID0gc3RyY2hyKHJlZm5hbWUgKyAxMywgJy8nKTsKCWlmICghc2xhc2ggfHwgc3RyY21wKHNsYXNoICsgMSwgY2ItPm5hbWUpKQoJCXJldHVybiAwOwoJaWYgKGNiLT5yZW1vdGUpIHsKCQljYi0+dW5pcXVlID0gMDsKCQlyZXR1cm4gMDsKCX0KCWNiLT5yZW1vdGUgPSB4c3RyZHVwKHJlZm5hbWUpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICp1bmlxdWVfdHJhY2tpbmdfbmFtZShjb25zdCBjaGFyICpuYW1lKQp7CglzdHJ1Y3QgdHJhY2tpbmdfbmFtZV9kYXRhIGNiX2RhdGEgPSB7IE5VTEwsIE5VTEwsIDEgfTsKCWNiX2RhdGEubmFtZSA9IG5hbWU7Cglmb3JfZWFjaF9yZWYoY2hlY2tfdHJhY2tpbmdfbmFtZSwgJmNiX2RhdGEpOwoJaWYgKGNiX2RhdGEudW5pcXVlKQoJCXJldHVybiBjYl9kYXRhLnJlbW90ZTsKCWZyZWUoY2JfZGF0YS5yZW1vdGUpOwoJcmV0dXJuIE5VTEw7Cn0KCnN0YXRpYyBpbnQgcGFyc2VfYnJhbmNobmFtZV9hcmcoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LAoJCQkJaW50IGR3aW1fbmV3X2xvY2FsX2JyYW5jaF9vaywKCQkJCXN0cnVjdCBicmFuY2hfaW5mbyAqbmV3LAoJCQkJc3RydWN0IHRyZWUgKipzb3VyY2VfdHJlZSwKCQkJCXVuc2lnbmVkIGNoYXIgcmV2WzIwXSwKCQkJCWNvbnN0IGNoYXIgKipuZXdfYnJhbmNoKQp7CglpbnQgYXJnY291bnQgPSAwOwoJdW5zaWduZWQgY2hhciBicmFuY2hfcmV2WzIwXTsKCWNvbnN0IGNoYXIgKmFyZzsKCWludCBoYXNfZGFzaF9kYXNoOwoKCS8qCgkgKiBjYXNlIDE6IGdpdCBjaGVja291dCA8cmVmPiAtLSBbPHBhdGhzPl0KCSAqCgkgKiAgIDxyZWY+IG11c3QgYmUgYSB2YWxpZCB0cmVlLCBldmVyeXRoaW5nIGFmdGVyIHRoZSAnLS0nIG11c3QgYmUKCSAqICAgYSBwYXRoLgoJICoKCSAqIGNhc2UgMjogZ2l0IGNoZWNrb3V0IC0tIFs8cGF0aHM+XQoJICoKCSAqICAgZXZlcnl0aGluZyBhZnRlciB0aGUgJy0tJyBtdXN0IGJlIHBhdGhzLgoJICoKCSAqIGNhc2UgMzogZ2l0IGNoZWNrb3V0IDxzb21ldGhpbmc+IFs8cGF0aHM+XQoJICoKCSAqICAgV2l0aCBubyBwYXRocywgaWYgPHNvbWV0aGluZz4gaXMgYSBjb21taXQsIHRoYXQgaXMgdG8KCSAqICAgc3dpdGNoIHRvIHRoZSBicmFuY2ggb3IgZGV0YWNoIEhFQUQgYXQgaXQuICBBcyBhIHNwZWNpYWwgY2FzZSwKCSAqICAgaWYgPHNvbWV0aGluZz4gaXMgQS4uLkIgKG1pc3NpbmcgQSBvciBCIG1lYW5zIEhFQUQgYnV0IHlvdSBjYW4KCSAqICAgb21pdCBhdCBtb3N0IG9uZSBzaWRlKSwgYW5kIGlmIHRoZXJlIGlzIGEgdW5pcXVlIG1lcmdlIGJhc2UKCSAqICAgYmV0d2VlbiBBIGFuZCBCLCBBLi4uQiBuYW1lcyB0aGF0IG1lcmdlIGJhc2UuCgkgKgoJICogICBXaXRoIG5vIHBhdGhzLCBpZiA8c29tZXRoaW5nPiBpcyBfbm90XyBhIGNvbW1pdCwgbm8gLXQgbm9yIC1iCgkgKiAgIHdhcyBnaXZlbiwgYW5kIHRoZXJlIGlzIGEgdHJhY2tpbmcgYnJhbmNoIHdob3NlIG5hbWUgaXMKCSAqICAgPHNvbWV0aGluZz4gaW4gb25lIGFuZCBvbmx5IG9uZSByZW1vdGUsIHRoZW4gdGhpcyBpcyBhIHNob3J0LWhhbmQKCSAqICAgdG8gZm9yayBsb2NhbCA8c29tZXRoaW5nPiBmcm9tIHRoYXQgcmVtb3RlLXRyYWNraW5nIGJyYW5jaC4KCSAqCgkgKiAgIE90aGVyd2lzZSA8c29tZXRoaW5nPiBzaGFsbCBub3QgYmUgYW1iaWd1b3VzLgoJICogICAtIElmIGl0J3MgKm9ubHkqIGEgcmVmZXJlbmNlLCB0cmVhdCBpdCBsaWtlIGNhc2UgKDEpLgoJICogICAtIElmIGl0J3Mgb25seSBhIHBhdGgsIHRyZWF0IGl0IGxpa2UgY2FzZSAoMikuCgkgKiAgIC0gZWxzZTogZmFpbC4KCSAqCgkgKi8KCWlmICghYXJnYykKCQlyZXR1cm4gMDsKCglpZiAoIXN0cmNtcChhcmd2WzBdLCAiLS0iKSkJLyogY2FzZSAoMikgKi8KCQlyZXR1cm4gMTsKCglhcmcgPSBhcmd2WzBdOwoJaGFzX2Rhc2hfZGFzaCA9IChhcmdjID4gMSkgJiYgIXN0cmNtcChhcmd2WzFdLCAiLS0iKTsKCglpZiAoIXN0cmNtcChhcmcsICItIikpCgkJYXJnID0gIkB7LTF9IjsKCglpZiAoZ2V0X3NoYTFfbWIoYXJnLCByZXYpKSB7CgkJaWYgKGhhc19kYXNoX2Rhc2gpICAgICAgICAgIC8qIGNhc2UgKDEpICovCgkJCWRpZShfKCJpbnZhbGlkIHJlZmVyZW5jZTogJXMiKSwgYXJnKTsKCQlpZiAoZHdpbV9uZXdfbG9jYWxfYnJhbmNoX29rICYmCgkJICAgICFjaGVja19maWxlbmFtZShOVUxMLCBhcmcpICYmCgkJICAgIGFyZ2MgPT0gMSkgewoJCQljb25zdCBjaGFyICpyZW1vdGUgPSB1bmlxdWVfdHJhY2tpbmdfbmFtZShhcmcpOwoJCQlpZiAoIXJlbW90ZSB8fCBnZXRfc2hhMShyZW1vdGUsIHJldikpCgkJCQlyZXR1cm4gYXJnY291bnQ7CgkJCSpuZXdfYnJhbmNoID0gYXJnOwoJCQlhcmcgPSByZW1vdGU7CgkJCS8qIERXSU1tZWQgdG8gY3JlYXRlIGxvY2FsIGJyYW5jaCAqLwoJCX0gZWxzZSB7CgkJCXJldHVybiBhcmdjb3VudDsKCQl9Cgl9CgoJLyogd2UgY2FuJ3QgZW5kIHVwIGJlaW5nIGluICgyKSBhbnltb3JlLCBlYXQgdGhlIGFyZ3VtZW50ICovCglhcmdjb3VudCsrOwoJYXJndisrOwoJYXJnYy0tOwoKCW5ldy0+bmFtZSA9IGFyZzsKCXNldHVwX2JyYW5jaF9wYXRoKG5ldyk7CgoJaWYgKCFjaGVja19yZWZuYW1lX2Zvcm1hdChuZXctPnBhdGgsIDApICYmCgkgICAgIXJlYWRfcmVmKG5ldy0+cGF0aCwgYnJhbmNoX3JldikpCgkJaGFzaGNweShyZXYsIGJyYW5jaF9yZXYpOwoJZWxzZQoJCW5ldy0+cGF0aCA9IE5VTEw7IC8qIG5vdCBhbiBleGlzdGluZyBicmFuY2ggKi8KCgluZXctPmNvbW1pdCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseShyZXYsIDEpOwoJaWYgKCFuZXctPmNvbW1pdCkgewoJCS8qIG5vdCBhIGNvbW1pdCAqLwoJCSpzb3VyY2VfdHJlZSA9IHBhcnNlX3RyZWVfaW5kaXJlY3QocmV2KTsKCX0gZWxzZSB7CgkJcGFyc2VfY29tbWl0KG5ldy0+Y29tbWl0KTsKCQkqc291cmNlX3RyZWUgPSBuZXctPmNvbW1pdC0+dHJlZTsKCX0KCglpZiAoISpzb3VyY2VfdHJlZSkgICAgICAgICAgICAgICAgICAgLyogY2FzZSAoMSk6IHdhbnQgYSB0cmVlICovCgkJZGllKF8oInJlZmVyZW5jZSBpcyBub3QgYSB0cmVlOiAlcyIpLCBhcmcpOwoJaWYgKCFoYXNfZGFzaF9kYXNoKSB7LyogY2FzZSAoMyAtPiAxKSAqLwoJCS8qCgkJICogRG8gbm90IGNvbXBsYWluIHRoZSBtb3N0IGNvbW1vbiBjYXNlCgkJICoJZ2l0IGNoZWNrb3V0IGJyYW5jaAoJCSAqIGV2ZW4gaWYgdGhlcmUgaGFwcGVuIHRvIGJlIGEgZmlsZSBjYWxsZWQgJ2JyYW5jaCc7CgkJICogaXQgd291bGQgYmUgZXh0cmVtZWx5IGFubm95aW5nLgoJCSAqLwoJCWlmIChhcmdjKQoJCQl2ZXJpZnlfbm9uX2ZpbGVuYW1lKE5VTEwsIGFyZyk7Cgl9IGVsc2UgewoJCWFyZ2NvdW50Kys7CgkJYXJndisrOwoJCWFyZ2MtLTsKCX0KCglyZXR1cm4gYXJnY291bnQ7Cn0KCmludCBjbWRfY2hlY2tvdXQoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0cnVjdCBjaGVja291dF9vcHRzIG9wdHM7Cgl1bnNpZ25lZCBjaGFyIHJldlsyMF07CglzdHJ1Y3QgYnJhbmNoX2luZm8gbmV3OwoJc3RydWN0IHRyZWUgKnNvdXJjZV90cmVlID0gTlVMTDsKCWNoYXIgKmNvbmZsaWN0X3N0eWxlID0gTlVMTDsKCWludCBwYXRjaF9tb2RlID0gMDsKCWludCBkd2ltX25ld19sb2NhbF9icmFuY2ggPSAxOwoJc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJT1BUX19RVUlFVCgmb3B0cy5xdWlldCwgInN1cHByZXNzIHByb2dyZXNzIHJlcG9ydGluZyIpLAoJCU9QVF9TVFJJTkcoJ2InLCBOVUxMLCAmb3B0cy5uZXdfYnJhbmNoLCAiYnJhbmNoIiwKCQkJICAgImNyZWF0ZSBhbmQgY2hlY2tvdXQgYSBuZXcgYnJhbmNoIiksCgkJT1BUX1NUUklORygnQicsIE5VTEwsICZvcHRzLm5ld19icmFuY2hfZm9yY2UsICJicmFuY2giLAoJCQkgICAiY3JlYXRlL3Jlc2V0IGFuZCBjaGVja291dCBhIGJyYW5jaCIpLAoJCU9QVF9CT09MRUFOKCdsJywgTlVMTCwgJm9wdHMubmV3X2JyYW5jaF9sb2csICJjcmVhdGUgcmVmbG9nIGZvciBuZXcgYnJhbmNoIiksCgkJT1BUX0JPT0xFQU4oMCwgImRldGFjaCIsICZvcHRzLmZvcmNlX2RldGFjaCwgImRldGFjaCB0aGUgSEVBRCBhdCBuYW1lZCBjb21taXQiKSwKCQlPUFRfU0VUX0lOVCgndCcsICJ0cmFjayIsICAmb3B0cy50cmFjaywgInNldCB1cHN0cmVhbSBpbmZvIGZvciBuZXcgYnJhbmNoIiwKCQkJQlJBTkNIX1RSQUNLX0VYUExJQ0lUKSwKCQlPUFRfU1RSSU5HKDAsICJvcnBoYW4iLCAmb3B0cy5uZXdfb3JwaGFuX2JyYW5jaCwgIm5ldyBicmFuY2giLCAibmV3IHVucGFyZW50ZWQgYnJhbmNoIiksCgkJT1BUX1NFVF9JTlQoJzInLCAib3VycyIsICZvcHRzLndyaXRlb3V0X3N0YWdlLCAiY2hlY2tvdXQgb3VyIHZlcnNpb24gZm9yIHVubWVyZ2VkIGZpbGVzIiwKCQkJICAgIDIpLAoJCU9QVF9TRVRfSU5UKCczJywgInRoZWlycyIsICZvcHRzLndyaXRlb3V0X3N0YWdlLCAiY2hlY2tvdXQgdGhlaXIgdmVyc2lvbiBmb3IgdW5tZXJnZWQgZmlsZXMiLAoJCQkgICAgMyksCgkJT1BUX19GT1JDRSgmb3B0cy5mb3JjZSwgImZvcmNlIGNoZWNrb3V0ICh0aHJvdyBhd2F5IGxvY2FsIG1vZGlmaWNhdGlvbnMpIiksCgkJT1BUX0JPT0xFQU4oJ20nLCAibWVyZ2UiLCAmb3B0cy5tZXJnZSwgInBlcmZvcm0gYSAzLXdheSBtZXJnZSB3aXRoIHRoZSBuZXcgYnJhbmNoIiksCgkJT1BUX1NUUklORygwLCAiY29uZmxpY3QiLCAmY29uZmxpY3Rfc3R5bGUsICJzdHlsZSIsCgkJCSAgICJjb25mbGljdCBzdHlsZSAobWVyZ2Ugb3IgZGlmZjMpIiksCgkJT1BUX0JPT0xFQU4oJ3AnLCAicGF0Y2giLCAmcGF0Y2hfbW9kZSwgInNlbGVjdCBodW5rcyBpbnRlcmFjdGl2ZWx5IiksCgkJeyBPUFRJT05fQk9PTEVBTiwgMCwgImd1ZXNzIiwgJmR3aW1fbmV3X2xvY2FsX2JyYW5jaCwgTlVMTCwKCQkgICJzZWNvbmQgZ3Vlc3MgJ2dpdCBjaGVja291dCBuby1zdWNoLWJyYW5jaCciLAoJCSAgUEFSU0VfT1BUX05PQVJHIHwgUEFSU0VfT1BUX0hJRERFTiB9LAoJCU9QVF9FTkQoKSwKCX07CgoJbWVtc2V0KCZvcHRzLCAwLCBzaXplb2Yob3B0cykpOwoJbWVtc2V0KCZuZXcsIDAsIHNpemVvZihuZXcpKTsKCglnaXRtb2R1bGVzX2NvbmZpZygpOwoJZ2l0X2NvbmZpZyhnaXRfY2hlY2tvdXRfY29uZmlnLCAmb3B0cyk7CgoJb3B0cy50cmFjayA9IEJSQU5DSF9UUkFDS19VTlNQRUNJRklFRDsKCglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIG9wdGlvbnMsIGNoZWNrb3V0X3VzYWdlLAoJCQkgICAgIFBBUlNFX09QVF9LRUVQX0RBU0hEQVNIKTsKCgkvKiB3ZSBjYW4gYXNzdW1lIGZyb20gbm93IG9uIG5ld19icmFuY2ggPSAhbmV3X2JyYW5jaF9mb3JjZSAqLwoJaWYgKG9wdHMubmV3X2JyYW5jaCAmJiBvcHRzLm5ld19icmFuY2hfZm9yY2UpCgkJZGllKF8oIi1CIGNhbm5vdCBiZSB1c2VkIHdpdGggLWIiKSk7CgoJLyogY29weSAtQiBvdmVyIHRvIC1iLCBzbyB0aGF0IHdlIGNhbiBqdXN0IGNoZWNrIHRoZSBsYXR0ZXIgKi8KCWlmIChvcHRzLm5ld19icmFuY2hfZm9yY2UpCgkJb3B0cy5uZXdfYnJhbmNoID0gb3B0cy5uZXdfYnJhbmNoX2ZvcmNlOwoKCWlmIChwYXRjaF9tb2RlICYmIChvcHRzLnRyYWNrID4gMCB8fCBvcHRzLm5ld19icmFuY2gKCQkJICAgfHwgb3B0cy5uZXdfYnJhbmNoX2xvZyB8fCBvcHRzLm1lcmdlIHx8IG9wdHMuZm9yY2UKCQkJICAgfHwgb3B0cy5mb3JjZV9kZXRhY2gpKQoJCWRpZSAoXygiLS1wYXRjaCBpcyBpbmNvbXBhdGlibGUgd2l0aCBhbGwgb3RoZXIgb3B0aW9ucyIpKTsKCglpZiAob3B0cy5mb3JjZV9kZXRhY2ggJiYgKG9wdHMubmV3X2JyYW5jaCB8fCBvcHRzLm5ld19vcnBoYW5fYnJhbmNoKSkKCQlkaWUoXygiLS1kZXRhY2ggY2Fubm90IGJlIHVzZWQgd2l0aCAtYi8tQi8tLW9ycGhhbiIpKTsKCWlmIChvcHRzLmZvcmNlX2RldGFjaCAmJiAwIDwgb3B0cy50cmFjaykKCQlkaWUoXygiLS1kZXRhY2ggY2Fubm90IGJlIHVzZWQgd2l0aCAtdCIpKTsKCgkvKiAtLXRyYWNrIHdpdGhvdXQgLWIgc2hvdWxkIERXSU0gKi8KCWlmICgwIDwgb3B0cy50cmFjayAmJiAhb3B0cy5uZXdfYnJhbmNoKSB7CgkJY29uc3QgY2hhciAqYXJndjAgPSBhcmd2WzBdOwoJCWlmICghYXJnYyB8fCAhc3RyY21wKGFyZ3YwLCAiLS0iKSkKCQkJZGllIChfKCItLXRyYWNrIG5lZWRzIGEgYnJhbmNoIG5hbWUiKSk7CgkJaWYgKCFwcmVmaXhjbXAoYXJndjAsICJyZWZzLyIpKQoJCQlhcmd2MCArPSA1OwoJCWlmICghcHJlZml4Y21wKGFyZ3YwLCAicmVtb3Rlcy8iKSkKCQkJYXJndjAgKz0gODsKCQlhcmd2MCA9IHN0cmNocihhcmd2MCwgJy8nKTsKCQlpZiAoIWFyZ3YwIHx8ICFhcmd2MFsxXSkKCQkJZGllIChfKCJNaXNzaW5nIGJyYW5jaCBuYW1lOyB0cnkgLWIiKSk7CgkJb3B0cy5uZXdfYnJhbmNoID0gYXJndjAgKyAxOwoJfQoKCWlmIChvcHRzLm5ld19vcnBoYW5fYnJhbmNoKSB7CgkJaWYgKG9wdHMubmV3X2JyYW5jaCkKCQkJZGllKF8oIi0tb3JwaGFuIGFuZCAtYnwtQiBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlIikpOwoJCWlmIChvcHRzLnRyYWNrID4gMCkKCQkJZGllKF8oIi0tb3JwaGFuIGNhbm5vdCBiZSB1c2VkIHdpdGggLXQiKSk7CgkJb3B0cy5uZXdfYnJhbmNoID0gb3B0cy5uZXdfb3JwaGFuX2JyYW5jaDsKCX0KCglpZiAoY29uZmxpY3Rfc3R5bGUpIHsKCQlvcHRzLm1lcmdlID0gMTsgLyogaW1wbGllZCAqLwoJCWdpdF94bWVyZ2VfY29uZmlnKCJtZXJnZS5jb25mbGljdHN0eWxlIiwgY29uZmxpY3Rfc3R5bGUsIE5VTEwpOwoJfQoKCWlmIChvcHRzLmZvcmNlICYmIG9wdHMubWVyZ2UpCgkJZGllKF8oImdpdCBjaGVja291dDogLWYgYW5kIC1tIGFyZSBpbmNvbXBhdGlibGUiKSk7CgoJLyoKCSAqIEV4dHJhY3QgYnJhbmNoIG5hbWUgZnJvbSBjb21tYW5kIGxpbmUgYXJndW1lbnRzLCBzbwoJICogYWxsIHRoYXQgaXMgbGVmdCBpcyBwYXRoc3BlY3MuCgkgKgoJICogSGFuZGxlCgkgKgoJICogIDEpIGdpdCBjaGVja291dCA8dHJlZT4gLS0gWzxwYXRocz5dCgkgKiAgMikgZ2l0IGNoZWNrb3V0IC0tIFs8cGF0aHM+XQoJICogIDMpIGdpdCBjaGVja291dCA8c29tZXRoaW5nPiBbPHBhdGhzPl0KCSAqCgkgKiBpbmNsdWRpbmcgImxhc3QgYnJhbmNoIiBzeW50YXggYW5kIERXSU0tZXJ5IGZvciBuYW1lcyBvZgoJICogcmVtb3RlIGJyYW5jaGVzLCBlcnJvcmluZyBvdXQgZm9yIGludmFsaWQgb3IgYW1iaWd1b3VzIGNhc2VzLgoJICovCglpZiAoYXJnYykgewoJCWludCBkd2ltX29rID0KCQkJIXBhdGNoX21vZGUgJiYKCQkJZHdpbV9uZXdfbG9jYWxfYnJhbmNoICYmCgkJCW9wdHMudHJhY2sgPT0gQlJBTkNIX1RSQUNLX1VOU1BFQ0lGSUVEICYmCgkJCSFvcHRzLm5ld19icmFuY2g7CgkJaW50IG4gPSBwYXJzZV9icmFuY2huYW1lX2FyZyhhcmdjLCBhcmd2LCBkd2ltX29rLAoJCQkJJm5ldywgJnNvdXJjZV90cmVlLCByZXYsICZvcHRzLm5ld19icmFuY2gpOwoJCWFyZ3YgKz0gbjsKCQlhcmdjIC09IG47Cgl9CgoJaWYgKG9wdHMudHJhY2sgPT0gQlJBTkNIX1RSQUNLX1VOU1BFQ0lGSUVEKQoJCW9wdHMudHJhY2sgPSBnaXRfYnJhbmNoX3RyYWNrOwoKCWlmIChhcmdjKSB7CgkJY29uc3QgY2hhciAqKnBhdGhzcGVjID0gZ2V0X3BhdGhzcGVjKHByZWZpeCwgYXJndik7CgoJCWlmICghcGF0aHNwZWMpCgkJCWRpZShfKCJpbnZhbGlkIHBhdGggc3BlY2lmaWNhdGlvbiIpKTsKCgkJaWYgKHBhdGNoX21vZGUpCgkJCXJldHVybiBpbnRlcmFjdGl2ZV9jaGVja291dChuZXcubmFtZSwgcGF0aHNwZWMsICZvcHRzKTsKCgkJLyogQ2hlY2tvdXQgcGF0aHMgKi8KCQlpZiAob3B0cy5uZXdfYnJhbmNoKSB7CgkJCWlmIChhcmdjID09IDEpIHsKCQkJCWRpZShfKCJnaXQgY2hlY2tvdXQ6IHVwZGF0aW5nIHBhdGhzIGlzIGluY29tcGF0aWJsZSB3aXRoIHN3aXRjaGluZyBicmFuY2hlcy5cbkRpZCB5b3UgaW50ZW5kIHRvIGNoZWNrb3V0ICclcycgd2hpY2ggY2FuIG5vdCBiZSByZXNvbHZlZCBhcyBjb21taXQ/IiksIGFyZ3ZbMF0pOwoJCQl9IGVsc2UgewoJCQkJZGllKF8oImdpdCBjaGVja291dDogdXBkYXRpbmcgcGF0aHMgaXMgaW5jb21wYXRpYmxlIHdpdGggc3dpdGNoaW5nIGJyYW5jaGVzLiIpKTsKCQkJfQoJCX0KCgkJaWYgKG9wdHMuZm9yY2VfZGV0YWNoKQoJCQlkaWUoXygiZ2l0IGNoZWNrb3V0OiAtLWRldGFjaCBkb2VzIG5vdCB0YWtlIGEgcGF0aCBhcmd1bWVudCIpKTsKCgkJaWYgKDEgPCAhIW9wdHMud3JpdGVvdXRfc3RhZ2UgKyAhIW9wdHMuZm9yY2UgKyAhIW9wdHMubWVyZ2UpCgkJCWRpZShfKCJnaXQgY2hlY2tvdXQ6IC0tb3Vycy8tLXRoZWlycywgLS1mb3JjZSBhbmQgLS1tZXJnZSBhcmUgaW5jb21wYXRpYmxlIHdoZW5cbmNoZWNraW5nIG91dCBvZiB0aGUgaW5kZXguIikpOwoKCQlyZXR1cm4gY2hlY2tvdXRfcGF0aHMoc291cmNlX3RyZWUsIHBhdGhzcGVjLCBwcmVmaXgsICZvcHRzKTsKCX0KCglpZiAocGF0Y2hfbW9kZSkKCQlyZXR1cm4gaW50ZXJhY3RpdmVfY2hlY2tvdXQobmV3Lm5hbWUsIE5VTEwsICZvcHRzKTsKCglpZiAob3B0cy5uZXdfYnJhbmNoKSB7CgkJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCgkJb3B0cy5icmFuY2hfZXhpc3RzID0gdmFsaWRhdGVfbmV3X2JyYW5jaG5hbWUob3B0cy5uZXdfYnJhbmNoLCAmYnVmLAoJCQkJCQkJICAgICAhIW9wdHMubmV3X2JyYW5jaF9mb3JjZSwgMCk7CgoJCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJfQoKCWlmIChuZXcubmFtZSAmJiAhbmV3LmNvbW1pdCkgewoJCWRpZShfKCJDYW5ub3Qgc3dpdGNoIGJyYW5jaCB0byBhIG5vbi1jb21taXQuIikpOwoJfQoJaWYgKG9wdHMud3JpdGVvdXRfc3RhZ2UpCgkJZGllKF8oIi0tb3Vycy8tLXRoZWlycyBpcyBpbmNvbXBhdGlibGUgd2l0aCBzd2l0Y2hpbmcgYnJhbmNoZXMuIikpOwoKCXJldHVybiBzd2l0Y2hfYnJhbmNoZXMoJm9wdHMsICZuZXcpOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"builtin.h\"\n#include \"parse-options.h\"\n#include \"refs.h\"\n#include \"commit.h\"\n#include \"tree.h\"\n#include \"tree-walk.h\"\n#include \"cache-tree.h\"\n#include \"unpack-trees.h\"\n#include \"dir.h\"\n#include \"run-command.h\"\n#include \"merge-recursive.h\"\n#include \"branch.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"remote.h\"\n#include \"blob.h\"\n#include \"xdiff-interface.h\"\n#include \"ll-merge.h\"\n#include \"resolve-undo.h\"\n#include \"submodule.h\"\n#include \"argv-array.h\"\n\nstatic const char * const checkout_usage[] = {\n\t\"git checkout [options] <branch>\",\n\t\"git checkout [options] [<branch>] -- <file>...\",\n\tNULL,\n};\n\nstruct checkout_opts {\n\tint quiet;\n\tint merge;\n\tint force;\n\tint force_detach;\n\tint writeout_stage;\n\tint writeout_error;\n\n\t/* not set by parse_options */\n\tint branch_exists;\n\n\tconst char *new_branch;\n\tconst char *new_branch_force;\n\tconst char *new_orphan_branch;\n\tint new_branch_log;\n\tenum branch_track track;\n\tstruct diff_options diff_options;\n};\n\nstatic int post_checkout_hook(struct commit *old, struct commit *new,\n\t\t\t      int changed)\n{\n\treturn run_hook(NULL, \"post-checkout\",\n\t\t\tsha1_to_hex(old ? old->object.sha1 : null_sha1),\n\t\t\tsha1_to_hex(new ? new->object.sha1 : null_sha1),\n\t\t\tchanged ? \"1\" : \"0\", NULL);\n\t/* \"new\" can be NULL when checking out from the index before\n\t   a commit exists. */\n\n}\n\nstatic int update_some(const unsigned char *sha1, const char *base, int baselen,\n\t\tconst char *pathname, unsigned mode, int stage, void *context)\n{\n\tint len;\n\tstruct cache_entry *ce;\n\n\tif (S_ISDIR(mode))\n\t\treturn READ_TREE_RECURSIVE;\n\n\tlen = baselen + strlen(pathname);\n\tce = xcalloc(1, cache_entry_size(len));\n\thashcpy(ce->sha1, sha1);\n\tmemcpy(ce->name, base, baselen);\n\tmemcpy(ce->name + baselen, pathname, len - baselen);\n\tce->ce_flags = create_ce_flags(len, 0) | CE_UPDATE;\n\tce->ce_mode = create_ce_mode(mode);\n\tadd_cache_entry(ce, ADD_CACHE_OK_TO_ADD | ADD_CACHE_OK_TO_REPLACE);\n\treturn 0;\n}\n\nstatic int read_tree_some(struct tree *tree, const char **pathspec)\n{\n\tstruct pathspec ps;\n\tinit_pathspec(&ps, pathspec);\n\tread_tree_recursive(tree, \"\", 0, 0, &ps, update_some, NULL);\n\tfree_pathspec(&ps);\n\n\t/* update the index with the given tree's info\n\t * for all args, expanding wildcards, and exit\n\t * with any non-zero return code.\n\t */\n\treturn 0;\n}\n\nstatic int skip_same_name(struct cache_entry *ce, int pos)\n{\n\twhile (++pos < active_nr &&\n\t       !strcmp(active_cache[pos]->name, ce->name))\n\t\t; /* skip */\n\treturn pos;\n}\n\nstatic int check_stage(int stage, struct cache_entry *ce, int pos)\n{\n\twhile (pos < active_nr &&\n\t       !strcmp(active_cache[pos]->name, ce->name)) {\n\t\tif (ce_stage(active_cache[pos]) == stage)\n\t\t\treturn 0;\n\t\tpos++;\n\t}\n\tif (stage == 2)\n\t\treturn error(_(\"path '%s' does not have our version\"), ce->name);\n\telse\n\t\treturn error(_(\"path '%s' does not have their version\"), ce->name);\n}\n\nstatic int check_all_stages(struct cache_entry *ce, int pos)\n{\n\tif (ce_stage(ce) != 1 ||\n\t    active_nr <= pos + 2 ||\n\t    strcmp(active_cache[pos+1]->name, ce->name) ||\n\t    ce_stage(active_cache[pos+1]) != 2 ||\n\t    strcmp(active_cache[pos+2]->name, ce->name) ||\n\t    ce_stage(active_cache[pos+2]) != 3)\n\t\treturn error(_(\"path '%s' does not have all three versions\"),\n\t\t\t     ce->name);\n\treturn 0;\n}\n\nstatic int checkout_stage(int stage, struct cache_entry *ce, int pos,\n\t\t\t  struct checkout *state)\n{\n\twhile (pos < active_nr &&\n\t       !strcmp(active_cache[pos]->name, ce->name)) {\n\t\tif (ce_stage(active_cache[pos]) == stage)\n\t\t\treturn checkout_entry(active_cache[pos], state, NULL);\n\t\tpos++;\n\t}\n\tif (stage == 2)\n\t\treturn error(_(\"path '%s' does not have our version\"), ce->name);\n\telse\n\t\treturn error(_(\"path '%s' does not have their version\"), ce->name);\n}\n\nstatic int checkout_merged(int pos, struct checkout *state)\n{\n\tstruct cache_entry *ce = active_cache[pos];\n\tconst char *path = ce->name;\n\tmmfile_t ancestor, ours, theirs;\n\tint status;\n\tunsigned char sha1[20];\n\tmmbuffer_t result_buf;\n\n\tif (ce_stage(ce) != 1 ||\n\t    active_nr <= pos + 2 ||\n\t    strcmp(active_cache[pos+1]->name, path) ||\n\t    ce_stage(active_cache[pos+1]) != 2 ||\n\t    strcmp(active_cache[pos+2]->name, path) ||\n\t    ce_stage(active_cache[pos+2]) != 3)\n\t\treturn error(_(\"path '%s' does not have all 3 versions\"), path);\n\n\tread_mmblob(&ancestor, active_cache[pos]->sha1);\n\tread_mmblob(&ours, active_cache[pos+1]->sha1);\n\tread_mmblob(&theirs, active_cache[pos+2]->sha1);\n\n\t/*\n\t * NEEDSWORK: re-create conflicts from merges with\n\t * merge.renormalize set, too\n\t */\n\tstatus = ll_merge(&result_buf, path, &ancestor, \"base\",\n\t\t\t  &ours, \"ours\", &theirs, \"theirs\", NULL);\n\tfree(ancestor.ptr);\n\tfree(ours.ptr);\n\tfree(theirs.ptr);\n\tif (status < 0 || !result_buf.ptr) {\n\t\tfree(result_buf.ptr);\n\t\treturn error(_(\"path '%s': cannot merge\"), path);\n\t}\n\n\t/*\n\t * NEEDSWORK:\n\t * There is absolutely no reason to write this as a blob object\n\t * and create a phony cache entry just to leak.  This hack is\n\t * primarily to get to the write_entry() machinery that massages\n\t * the contents to work-tree format and writes out which only\n\t * allows it for a cache entry.  The code in write_entry() needs\n\t * to be refactored to allow us to feed a <buffer, size, mode>\n\t * instead of a cache entry.  Such a refactoring would help\n\t * merge_recursive as well (it also writes the merge result to the\n\t * object database even when it may contain conflicts).\n\t */\n\tif (write_sha1_file(result_buf.ptr, result_buf.size,\n\t\t\t    blob_type, sha1))\n\t\tdie(_(\"Unable to add merge result for '%s'\"), path);\n\tce = make_cache_entry(create_ce_mode(active_cache[pos+1]->ce_mode),\n\t\t\t      sha1,\n\t\t\t      path, 2, 0);\n\tif (!ce)\n\t\tdie(_(\"make_cache_entry failed for path '%s'\"), path);\n\tstatus = checkout_entry(ce, state, NULL);\n\treturn status;\n}\n\nstatic int checkout_paths(struct tree *source_tree, const char **pathspec,\n\t\t\t  const char *prefix, struct checkout_opts *opts)\n{\n\tint pos;\n\tstruct checkout state;\n\tstatic char *ps_matched;\n\tunsigned char rev[20];\n\tint flag;\n\tstruct commit *head;\n\tint errs = 0;\n\tint stage = opts->writeout_stage;\n\tint merge = opts->merge;\n\tint newfd;\n\tstruct lock_file *lock_file = xcalloc(1, sizeof(struct lock_file));\n\n\tnewfd = hold_locked_index(lock_file, 1);\n\tif (read_cache_preload(pathspec) < 0)\n\t\treturn error(_(\"corrupt index file\"));\n\n\tif (source_tree)\n\t\tread_tree_some(source_tree, pathspec);\n\n\tfor (pos = 0; pathspec[pos]; pos++)\n\t\t;\n\tps_matched = xcalloc(1, pos);\n\n\tfor (pos = 0; pos < active_nr; pos++) {\n\t\tstruct cache_entry *ce = active_cache[pos];\n\t\tif (source_tree && !(ce->ce_flags & CE_UPDATE))\n\t\t\tcontinue;\n\t\tmatch_pathspec(pathspec, ce->name, ce_namelen(ce), 0, ps_matched);\n\t}\n\n\tif (report_path_error(ps_matched, pathspec, prefix))\n\t\treturn 1;\n\n\t/* \"checkout -m path\" to recreate conflicted state */\n\tif (opts->merge)\n\t\tunmerge_cache(pathspec);\n\n\t/* Any unmerged paths? */\n\tfor (pos = 0; pos < active_nr; pos++) {\n\t\tstruct cache_entry *ce = active_cache[pos];\n\t\tif (match_pathspec(pathspec, ce->name, ce_namelen(ce), 0, NULL)) {\n\t\t\tif (!ce_stage(ce))\n\t\t\t\tcontinue;\n\t\t\tif (opts->force) {\n\t\t\t\twarning(_(\"path '%s' is unmerged\"), ce->name);\n\t\t\t} else if (stage) {\n\t\t\t\terrs |= check_stage(stage, ce, pos);\n\t\t\t} else if (opts->merge) {\n\t\t\t\terrs |= check_all_stages(ce, pos);\n\t\t\t} else {\n\t\t\t\terrs = 1;\n\t\t\t\terror(_(\"path '%s' is unmerged\"), ce->name);\n\t\t\t}\n\t\t\tpos = skip_same_name(ce, pos) - 1;\n\t\t}\n\t}\n\tif (errs)\n\t\treturn 1;\n\n\t/* Now we are committed to check them out */\n\tmemset(&state, 0, sizeof(state));\n\tstate.force = 1;\n\tstate.refresh_cache = 1;\n\tfor (pos = 0; pos < active_nr; pos++) {\n\t\tstruct cache_entry *ce = active_cache[pos];\n\t\tif (source_tree && !(ce->ce_flags & CE_UPDATE))\n\t\t\tcontinue;\n\t\tif (match_pathspec(pathspec, ce->name, ce_namelen(ce), 0, NULL)) {\n\t\t\tif (!ce_stage(ce)) {\n\t\t\t\terrs |= checkout_entry(ce, &state, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stage)\n\t\t\t\terrs |= checkout_stage(stage, ce, pos, &state);\n\t\t\telse if (merge)\n\t\t\t\terrs |= checkout_merged(pos, &state);\n\t\t\tpos = skip_same_name(ce, pos) - 1;\n\t\t}\n\t}\n\n\tif (write_cache(newfd, active_cache, active_nr) ||\n\t    commit_locked_index(lock_file))\n\t\tdie(_(\"unable to write new index file\"));\n\n\tread_ref_full(\"HEAD\", rev, 0, &flag);\n\thead = lookup_commit_reference_gently(rev, 1);\n\n\terrs |= post_checkout_hook(head, head, 0);\n\treturn errs;\n}\n\nstatic void show_local_changes(struct object *head, struct diff_options *opts)\n{\n\tstruct rev_info rev;\n\t/* I think we want full paths, even if we're in a subdirectory. */\n\tinit_revisions(&rev, NULL);\n\trev.diffopt.flags = opts->flags;\n\trev.diffopt.output_format |= DIFF_FORMAT_NAME_STATUS;\n\tif (diff_setup_done(&rev.diffopt) < 0)\n\t\tdie(_(\"diff_setup_done failed\"));\n\tadd_pending_object(&rev, head, NULL);\n\trun_diff_index(&rev, 0);\n}\n\nstatic void describe_detached_head(const char *msg, struct commit *commit)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tparse_commit(commit);\n\tpp_commit_easy(CMIT_FMT_ONELINE, commit, &sb);\n\tfprintf(stderr, \"%s %s... %s\\n\", msg,\n\t\tfind_unique_abbrev(commit->object.sha1, DEFAULT_ABBREV), sb.buf);\n\tstrbuf_release(&sb);\n}\n\nstatic int reset_tree(struct tree *tree, struct checkout_opts *o, int worktree)\n{\n\tstruct unpack_trees_options opts;\n\tstruct tree_desc tree_desc;\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.head_idx = -1;\n\topts.update = worktree;\n\topts.skip_unmerged = !worktree;\n\topts.reset = 1;\n\topts.merge = 1;\n\topts.fn = oneway_merge;\n\topts.verbose_update = !o->quiet;\n\topts.src_index = &the_index;\n\topts.dst_index = &the_index;\n\tparse_tree(tree);\n\tinit_tree_desc(&tree_desc, tree->buffer, tree->size);\n\tswitch (unpack_trees(1, &tree_desc, &opts)) {\n\tcase -2:\n\t\to->writeout_error = 1;\n\t\t/*\n\t\t * We return 0 nevertheless, as the index is all right\n\t\t * and more importantly we have made best efforts to\n\t\t * update paths in the work tree, and we cannot revert\n\t\t * them.\n\t\t */\n\tcase 0:\n\t\treturn 0;\n\tdefault:\n\t\treturn 128;\n\t}\n}\n\nstruct branch_info {\n\tconst char *name; /* The short name used */\n\tconst char *path; /* The full name of a real branch */\n\tstruct commit *commit; /* The named commit */\n};\n\nstatic void setup_branch_path(struct branch_info *branch)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tstrbuf_branchname(&buf, branch->name);\n\tif (strcmp(buf.buf, branch->name))\n\t\tbranch->name = xstrdup(buf.buf);\n\tstrbuf_splice(&buf, 0, 0, \"refs/heads/\", 11);\n\tbranch->path = strbuf_detach(&buf, NULL);\n}\n\nstatic int merge_working_tree(struct checkout_opts *opts,\n\t\t\t      struct branch_info *old, struct branch_info *new)\n{\n\tint ret;\n\tstruct lock_file *lock_file = xcalloc(1, sizeof(struct lock_file));\n\tint newfd = hold_locked_index(lock_file, 1);\n\n\tif (read_cache_preload(NULL) < 0)\n\t\treturn error(_(\"corrupt index file\"));\n\n\tresolve_undo_clear();\n\tif (opts->force) {\n\t\tret = reset_tree(new->commit->tree, opts, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tstruct tree_desc trees[2];\n\t\tstruct tree *tree;\n\t\tstruct unpack_trees_options topts;\n\n\t\tmemset(&topts, 0, sizeof(topts));\n\t\ttopts.head_idx = -1;\n\t\ttopts.src_index = &the_index;\n\t\ttopts.dst_index = &the_index;\n\n\t\tsetup_unpack_trees_porcelain(&topts, \"checkout\");\n\n\t\trefresh_cache(REFRESH_QUIET);\n\n\t\tif (unmerged_cache()) {\n\t\t\terror(_(\"you need to resolve your current index first\"));\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* 2-way merge to the new branch */\n\t\ttopts.initial_checkout = is_cache_unborn();\n\t\ttopts.update = 1;\n\t\ttopts.merge = 1;\n\t\ttopts.gently = opts->merge && old->commit;\n\t\ttopts.verbose_update = !opts->quiet;\n\t\ttopts.fn = twoway_merge;\n\t\ttopts.dir = xcalloc(1, sizeof(*topts.dir));\n\t\ttopts.dir->flags |= DIR_SHOW_IGNORED;\n\t\tsetup_standard_excludes(topts.dir);\n\t\ttree = parse_tree_indirect(old->commit ?\n\t\t\t\t\t   old->commit->object.sha1 :\n\t\t\t\t\t   EMPTY_TREE_SHA1_BIN);\n\t\tinit_tree_desc(&trees[0], tree->buffer, tree->size);\n\t\ttree = parse_tree_indirect(new->commit->object.sha1);\n\t\tinit_tree_desc(&trees[1], tree->buffer, tree->size);\n\n\t\tret = unpack_trees(2, trees, &topts);\n\t\tif (ret == -1) {\n\t\t\t/*\n\t\t\t * Unpack couldn't do a trivial merge; either\n\t\t\t * give up or do a real merge, depending on\n\t\t\t * whether the merge flag was used.\n\t\t\t */\n\t\t\tstruct tree *result;\n\t\t\tstruct tree *work;\n\t\t\tstruct merge_options o;\n\t\t\tif (!opts->merge)\n\t\t\t\treturn 1;\n\n\t\t\t/*\n\t\t\t * Without old->commit, the below is the same as\n\t\t\t * the two-tree unpack we already tried and failed.\n\t\t\t */\n\t\t\tif (!old->commit)\n\t\t\t\treturn 1;\n\n\t\t\t/* Do more real merge */\n\n\t\t\t/*\n\t\t\t * We update the index fully, then write the\n\t\t\t * tree from the index, then merge the new\n\t\t\t * branch with the current tree, with the old\n\t\t\t * branch as the base. Then we reset the index\n\t\t\t * (but not the working tree) to the new\n\t\t\t * branch, leaving the working tree as the\n\t\t\t * merged version, but skipping unmerged\n\t\t\t * entries in the index.\n\t\t\t */\n\n\t\t\tadd_files_to_cache(NULL, NULL, 0);\n\t\t\t/*\n\t\t\t * NEEDSWORK: carrying over local changes\n\t\t\t * when branches have different end-of-line\n\t\t\t * normalization (or clean+smudge rules) is\n\t\t\t * a pain; plumb in an option to set\n\t\t\t * o.renormalize?\n\t\t\t */\n\t\t\tinit_merge_options(&o);\n\t\t\to.verbosity = 0;\n\t\t\twork = write_tree_from_memory(&o);\n\n\t\t\tret = reset_tree(new->commit->tree, opts, 1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\to.ancestor = old->name;\n\t\t\to.branch1 = new->name;\n\t\t\to.branch2 = \"local\";\n\t\t\tmerge_trees(&o, new->commit->tree, work,\n\t\t\t\told->commit->tree, &result);\n\t\t\tret = reset_tree(new->commit->tree, opts, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (write_cache(newfd, active_cache, active_nr) ||\n\t    commit_locked_index(lock_file))\n\t\tdie(_(\"unable to write new index file\"));\n\n\tif (!opts->force && !opts->quiet)\n\t\tshow_local_changes(&new->commit->object, &opts->diff_options);\n\n\treturn 0;\n}\n\nstatic void report_tracking(struct branch_info *new)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tstruct branch *branch = branch_get(new->name);\n\n\tif (!format_tracking_info(branch, &sb))\n\t\treturn;\n\tfputs(sb.buf, stdout);\n\tstrbuf_release(&sb);\n}\n\nstatic void detach_advice(const char *old_path, const char *new_name)\n{\n\tconst char fmt[] =\n\t\"Note: checking out '%s'.\\n\\n\"\n\t\"You are in 'detached HEAD' state. You can look around, make experimental\\n\"\n\t\"changes and commit them, and you can discard any commits you make in this\\n\"\n\t\"state without impacting any branches by performing another checkout.\\n\\n\"\n\t\"If you want to create a new branch to retain commits you create, you may\\n\"\n\t\"do so (now or later) by using -b with the checkout command again. Example:\\n\\n\"\n\t\"  git checkout -b new_branch_name\\n\\n\";\n\n\tfprintf(stderr, fmt, new_name);\n}\n\nstatic void update_refs_for_switch(struct checkout_opts *opts,\n\t\t\t\t   struct branch_info *old,\n\t\t\t\t   struct branch_info *new)\n{\n\tstruct strbuf msg = STRBUF_INIT;\n\tconst char *old_desc;\n\tif (opts->new_branch) {\n\t\tif (opts->new_orphan_branch) {\n\t\t\tif (opts->new_branch_log && !log_all_ref_updates) {\n\t\t\t\tint temp;\n\t\t\t\tchar log_file[PATH_MAX];\n\t\t\t\tchar *ref_name = mkpath(\"refs/heads/%s\", opts->new_orphan_branch);\n\n\t\t\t\ttemp = log_all_ref_updates;\n\t\t\t\tlog_all_ref_updates = 1;\n\t\t\t\tif (log_ref_setup(ref_name, log_file, sizeof(log_file))) {\n\t\t\t\t\tfprintf(stderr, _(\"Can not do reflog for '%s'\\n\"),\n\t\t\t\t\t    opts->new_orphan_branch);\n\t\t\t\t\tlog_all_ref_updates = temp;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlog_all_ref_updates = temp;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tcreate_branch(old->name, opts->new_branch, new->name,\n\t\t\t\t      opts->new_branch_force ? 1 : 0,\n\t\t\t\t      opts->new_branch_log, opts->track);\n\t\tnew->name = opts->new_branch;\n\t\tsetup_branch_path(new);\n\t}\n\n\told_desc = old->name;\n\tif (!old_desc && old->commit)\n\t\told_desc = sha1_to_hex(old->commit->object.sha1);\n\tstrbuf_addf(&msg, \"checkout: moving from %s to %s\",\n\t\t    old_desc ? old_desc : \"(invalid)\", new->name);\n\n\tif (!strcmp(new->name, \"HEAD\") && !new->path && !opts->force_detach) {\n\t\t/* Nothing to do. */\n\t} else if (opts->force_detach || !new->path) {\t/* No longer on any branch. */\n\t\tupdate_ref(msg.buf, \"HEAD\", new->commit->object.sha1, NULL,\n\t\t\t   REF_NODEREF, DIE_ON_ERR);\n\t\tif (!opts->quiet) {\n\t\t\tif (old->path && advice_detached_head)\n\t\t\t\tdetach_advice(old->path, new->name);\n\t\t\tdescribe_detached_head(_(\"HEAD is now at\"), new->commit);\n\t\t}\n\t} else if (new->path) {\t/* Switch branches. */\n\t\tcreate_symref(\"HEAD\", new->path, msg.buf);\n\t\tif (!opts->quiet) {\n\t\t\tif (old->path && !strcmp(new->path, old->path)) {\n\t\t\t\tfprintf(stderr, _(\"Already on '%s'\\n\"),\n\t\t\t\t\tnew->name);\n\t\t\t} else if (opts->new_branch) {\n\t\t\t\tif (opts->branch_exists)\n\t\t\t\t\tfprintf(stderr, _(\"Switched to and reset branch '%s'\\n\"), new->name);\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, _(\"Switched to a new branch '%s'\\n\"), new->name);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, _(\"Switched to branch '%s'\\n\"),\n\t\t\t\t\tnew->name);\n\t\t\t}\n\t\t}\n\t\tif (old->path && old->name) {\n\t\t\tchar log_file[PATH_MAX], ref_file[PATH_MAX];\n\n\t\t\tgit_snpath(log_file, sizeof(log_file), \"logs/%s\", old->path);\n\t\t\tgit_snpath(ref_file, sizeof(ref_file), \"%s\", old->path);\n\t\t\tif (!file_exists(ref_file) && file_exists(log_file))\n\t\t\t\tremove_path(log_file);\n\t\t}\n\t}\n\tremove_branch_state();\n\tstrbuf_release(&msg);\n\tif (!opts->quiet &&\n\t    (new->path || (!opts->force_detach && !strcmp(new->name, \"HEAD\"))))\n\t\treport_tracking(new);\n}\n\nstatic int add_pending_uninteresting_ref(const char *refname,\n\t\t\t\t\t const unsigned char *sha1,\n\t\t\t\t\t int flags, void *cb_data)\n{\n\tadd_pending_sha1(cb_data, refname, sha1, flags | UNINTERESTING);\n\treturn 0;\n}\n\nstatic void describe_one_orphan(struct strbuf *sb, struct commit *commit)\n{\n\tparse_commit(commit);\n\tstrbuf_addstr(sb, \"  \");\n\tstrbuf_addstr(sb,\n\t\tfind_unique_abbrev(commit->object.sha1, DEFAULT_ABBREV));\n\tstrbuf_addch(sb, ' ');\n\tpp_commit_easy(CMIT_FMT_ONELINE, commit, sb);\n\tstrbuf_addch(sb, '\\n');\n}\n\n#define ORPHAN_CUTOFF 4\nstatic void suggest_reattach(struct commit *commit, struct rev_info *revs)\n{\n\tstruct commit *c, *last = NULL;\n\tstruct strbuf sb = STRBUF_INIT;\n\tint lost = 0;\n\twhile ((c = get_revision(revs)) != NULL) {\n\t\tif (lost < ORPHAN_CUTOFF)\n\t\t\tdescribe_one_orphan(&sb, c);\n\t\tlast = c;\n\t\tlost++;\n\t}\n\tif (ORPHAN_CUTOFF < lost) {\n\t\tint more = lost - ORPHAN_CUTOFF;\n\t\tif (more == 1)\n\t\t\tdescribe_one_orphan(&sb, last);\n\t\telse\n\t\t\tstrbuf_addf(&sb, _(\" ... and %d more.\\n\"), more);\n\t}\n\n\tfprintf(stderr,\n\t\tQ_(\n\t\t/* The singular version */\n\t\t\"Warning: you are leaving %d commit behind, \"\n\t\t\"not connected to\\n\"\n\t\t\"any of your branches:\\n\\n\"\n\t\t\"%s\\n\",\n\t\t/* The plural version */\n\t\t\"Warning: you are leaving %d commits behind, \"\n\t\t\"not connected to\\n\"\n\t\t\"any of your branches:\\n\\n\"\n\t\t\"%s\\n\",\n\t\t/* Give ngettext() the count */\n\t\tlost),\n\t\tlost,\n\t\tsb.buf);\n\tstrbuf_release(&sb);\n\n\tif (advice_detached_head)\n\t\tfprintf(stderr,\n\t\t\t_(\n\t\t\t\"If you want to keep them by creating a new branch, \"\n\t\t\t\"this may be a good time\\nto do so with:\\n\\n\"\n\t\t\t\" git branch new_branch_name %s\\n\\n\"),\n\t\t\tsha1_to_hex(commit->object.sha1));\n}\n\n/*\n * We are about to leave commit that was at the tip of a detached\n * HEAD.  If it is not reachable from any ref, this is the last chance\n * for the user to do so without resorting to reflog.\n */\nstatic void orphaned_commit_warning(struct commit *commit)\n{\n\tstruct rev_info revs;\n\tstruct object *object = &commit->object;\n\tstruct object_array refs;\n\n\tinit_revisions(&revs, NULL);\n\tsetup_revisions(0, NULL, &revs, NULL);\n\n\tobject->flags &= ~UNINTERESTING;\n\tadd_pending_object(&revs, object, sha1_to_hex(object->sha1));\n\n\tfor_each_ref(add_pending_uninteresting_ref, &revs);\n\n\trefs = revs.pending;\n\trevs.leak_pending = 1;\n\n\tif (prepare_revision_walk(&revs))\n\t\tdie(_(\"internal error in revision walk\"));\n\tif (!(commit->object.flags & UNINTERESTING))\n\t\tsuggest_reattach(commit, &revs);\n\telse\n\t\tdescribe_detached_head(_(\"Previous HEAD position was\"), commit);\n\n\tclear_commit_marks_for_object_array(&refs, ALL_REV_FLAGS);\n\tfree(refs.objects);\n}\n\nstatic int switch_branches(struct checkout_opts *opts, struct branch_info *new)\n{\n\tint ret = 0;\n\tstruct branch_info old;\n\tvoid *path_to_free;\n\tunsigned char rev[20];\n\tint flag;\n\tmemset(&old, 0, sizeof(old));\n\told.path = path_to_free = resolve_refdup(\"HEAD\", rev, 0, &flag);\n\told.commit = lookup_commit_reference_gently(rev, 1);\n\tif (!(flag & REF_ISSYMREF))\n\t\told.path = NULL;\n\n\tif (old.path && !prefixcmp(old.path, \"refs/heads/\"))\n\t\told.name = old.path + strlen(\"refs/heads/\");\n\n\tif (!new->name) {\n\t\tnew->name = \"HEAD\";\n\t\tnew->commit = old.commit;\n\t\tif (!new->commit)\n\t\t\tdie(_(\"You are on a branch yet to be born\"));\n\t\tparse_commit(new->commit);\n\t}\n\n\tret = merge_working_tree(opts, &old, new);\n\tif (ret) {\n\t\tfree(path_to_free);\n\t\treturn ret;\n\t}\n\n\tif (!opts->quiet && !old.path && old.commit && new->commit != old.commit)\n\t\torphaned_commit_warning(old.commit);\n\n\tupdate_refs_for_switch(opts, &old, new);\n\n\tret = post_checkout_hook(old.commit, new->commit, 1);\n\tfree(path_to_free);\n\treturn ret || opts->writeout_error;\n}\n\nstatic int git_checkout_config(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(var, \"diff.ignoresubmodules\")) {\n\t\tstruct checkout_opts *opts = cb;\n\t\thandle_ignore_submodules_arg(&opts->diff_options, value);\n\t\treturn 0;\n\t}\n\n\tif (!prefixcmp(var, \"submodule.\"))\n\t\treturn parse_submodule_config_option(var, value);\n\n\treturn git_xmerge_config(var, value, NULL);\n}\n\nstatic int interactive_checkout(const char *revision, const char **pathspec,\n\t\t\t\tstruct checkout_opts *opts)\n{\n\treturn run_add_interactive(revision, \"--patch=checkout\", pathspec);\n}\n\nstruct tracking_name_data {\n\tconst char *name;\n\tchar *remote;\n\tint unique;\n};\n\nstatic int check_tracking_name(const char *refname, const unsigned char *sha1,\n\t\t\t       int flags, void *cb_data)\n{\n\tstruct tracking_name_data *cb = cb_data;\n\tconst char *slash;\n\n\tif (prefixcmp(refname, \"refs/remotes/\"))\n\t\treturn 0;\n\tslash = strchr(refname + 13, '/');\n\tif (!slash || strcmp(slash + 1, cb->name))\n\t\treturn 0;\n\tif (cb->remote) {\n\t\tcb->unique = 0;\n\t\treturn 0;\n\t}\n\tcb->remote = xstrdup(refname);\n\treturn 0;\n}\n\nstatic const char *unique_tracking_name(const char *name)\n{\n\tstruct tracking_name_data cb_data = { NULL, NULL, 1 };\n\tcb_data.name = name;\n\tfor_each_ref(check_tracking_name, &cb_data);\n\tif (cb_data.unique)\n\t\treturn cb_data.remote;\n\tfree(cb_data.remote);\n\treturn NULL;\n}\n\nstatic int parse_branchname_arg(int argc, const char **argv,\n\t\t\t\tint dwim_new_local_branch_ok,\n\t\t\t\tstruct branch_info *new,\n\t\t\t\tstruct tree **source_tree,\n\t\t\t\tunsigned char rev[20],\n\t\t\t\tconst char **new_branch)\n{\n\tint argcount = 0;\n\tunsigned char branch_rev[20];\n\tconst char *arg;\n\tint has_dash_dash;\n\n\t/*\n\t * case 1: git checkout <ref> -- [<paths>]\n\t *\n\t *   <ref> must be a valid tree, everything after the '--' must be\n\t *   a path.\n\t *\n\t * case 2: git checkout -- [<paths>]\n\t *\n\t *   everything after the '--' must be paths.\n\t *\n\t * case 3: git checkout <something> [<paths>]\n\t *\n\t *   With no paths, if <something> is a commit, that is to\n\t *   switch to the branch or detach HEAD at it.  As a special case,\n\t *   if <something> is A...B (missing A or B means HEAD but you can\n\t *   omit at most one side), and if there is a unique merge base\n\t *   between A and B, A...B names that merge base.\n\t *\n\t *   With no paths, if <something> is _not_ a commit, no -t nor -b\n\t *   was given, and there is a tracking branch whose name is\n\t *   <something> in one and only one remote, then this is a short-hand\n\t *   to fork local <something> from that remote-tracking branch.\n\t *\n\t *   Otherwise <something> shall not be ambiguous.\n\t *   - If it's *only* a reference, treat it like case (1).\n\t *   - If it's only a path, treat it like case (2).\n\t *   - else: fail.\n\t *\n\t */\n\tif (!argc)\n\t\treturn 0;\n\n\tif (!strcmp(argv[0], \"--\"))\t/* case (2) */\n\t\treturn 1;\n\n\targ = argv[0];\n\thas_dash_dash = (argc > 1) && !strcmp(argv[1], \"--\");\n\n\tif (!strcmp(arg, \"-\"))\n\t\targ = \"@{-1}\";\n\n\tif (get_sha1_mb(arg, rev)) {\n\t\tif (has_dash_dash)          /* case (1) */\n\t\t\tdie(_(\"invalid reference: %s\"), arg);\n\t\tif (dwim_new_local_branch_ok &&\n\t\t    !check_filename(NULL, arg) &&\n\t\t    argc == 1) {\n\t\t\tconst char *remote = unique_tracking_name(arg);\n\t\t\tif (!remote || get_sha1(remote, rev))\n\t\t\t\treturn argcount;\n\t\t\t*new_branch = arg;\n\t\t\targ = remote;\n\t\t\t/* DWIMmed to create local branch */\n\t\t} else {\n\t\t\treturn argcount;\n\t\t}\n\t}\n\n\t/* we can't end up being in (2) anymore, eat the argument */\n\targcount++;\n\targv++;\n\targc--;\n\n\tnew->name = arg;\n\tsetup_branch_path(new);\n\n\tif (!check_refname_format(new->path, 0) &&\n\t    !read_ref(new->path, branch_rev))\n\t\thashcpy(rev, branch_rev);\n\telse\n\t\tnew->path = NULL; /* not an existing branch */\n\n\tnew->commit = lookup_commit_reference_gently(rev, 1);\n\tif (!new->commit) {\n\t\t/* not a commit */\n\t\t*source_tree = parse_tree_indirect(rev);\n\t} else {\n\t\tparse_commit(new->commit);\n\t\t*source_tree = new->commit->tree;\n\t}\n\n\tif (!*source_tree)                   /* case (1): want a tree */\n\t\tdie(_(\"reference is not a tree: %s\"), arg);\n\tif (!has_dash_dash) {/* case (3 -> 1) */\n\t\t/*\n\t\t * Do not complain the most common case\n\t\t *\tgit checkout branch\n\t\t * even if there happen to be a file called 'branch';\n\t\t * it would be extremely annoying.\n\t\t */\n\t\tif (argc)\n\t\t\tverify_non_filename(NULL, arg);\n\t} else {\n\t\targcount++;\n\t\targv++;\n\t\targc--;\n\t}\n\n\treturn argcount;\n}\n\nint cmd_checkout(int argc, const char **argv, const char *prefix)\n{\n\tstruct checkout_opts opts;\n\tunsigned char rev[20];\n\tstruct branch_info new;\n\tstruct tree *source_tree = NULL;\n\tchar *conflict_style = NULL;\n\tint patch_mode = 0;\n\tint dwim_new_local_branch = 1;\n\tstruct option options[] = {\n\t\tOPT__QUIET(&opts.quiet, \"suppress progress reporting\"),\n\t\tOPT_STRING('b', NULL, &opts.new_branch, \"branch\",\n\t\t\t   \"create and checkout a new branch\"),\n\t\tOPT_STRING('B', NULL, &opts.new_branch_force, \"branch\",\n\t\t\t   \"create/reset and checkout a branch\"),\n\t\tOPT_BOOLEAN('l', NULL, &opts.new_branch_log, \"create reflog for new branch\"),\n\t\tOPT_BOOLEAN(0, \"detach\", &opts.force_detach, \"detach the HEAD at named commit\"),\n\t\tOPT_SET_INT('t', \"track\",  &opts.track, \"set upstream info for new branch\",\n\t\t\tBRANCH_TRACK_EXPLICIT),\n\t\tOPT_STRING(0, \"orphan\", &opts.new_orphan_branch, \"new branch\", \"new unparented branch\"),\n\t\tOPT_SET_INT('2', \"ours\", &opts.writeout_stage, \"checkout our version for unmerged files\",\n\t\t\t    2),\n\t\tOPT_SET_INT('3', \"theirs\", &opts.writeout_stage, \"checkout their version for unmerged files\",\n\t\t\t    3),\n\t\tOPT__FORCE(&opts.force, \"force checkout (throw away local modifications)\"),\n\t\tOPT_BOOLEAN('m', \"merge\", &opts.merge, \"perform a 3-way merge with the new branch\"),\n\t\tOPT_STRING(0, \"conflict\", &conflict_style, \"style\",\n\t\t\t   \"conflict style (merge or diff3)\"),\n\t\tOPT_BOOLEAN('p', \"patch\", &patch_mode, \"select hunks interactively\"),\n\t\t{ OPTION_BOOLEAN, 0, \"guess\", &dwim_new_local_branch, NULL,\n\t\t  \"second guess 'git checkout no-such-branch'\",\n\t\t  PARSE_OPT_NOARG | PARSE_OPT_HIDDEN },\n\t\tOPT_END(),\n\t};\n\n\tmemset(&opts, 0, sizeof(opts));\n\tmemset(&new, 0, sizeof(new));\n\n\tgitmodules_config();\n\tgit_config(git_checkout_config, &opts);\n\n\topts.track = BRANCH_TRACK_UNSPECIFIED;\n\n\targc = parse_options(argc, argv, prefix, options, checkout_usage,\n\t\t\t     PARSE_OPT_KEEP_DASHDASH);\n\n\t/* we can assume from now on new_branch = !new_branch_force */\n\tif (opts.new_branch && opts.new_branch_force)\n\t\tdie(_(\"-B cannot be used with -b\"));\n\n\t/* copy -B over to -b, so that we can just check the latter */\n\tif (opts.new_branch_force)\n\t\topts.new_branch = opts.new_branch_force;\n\n\tif (patch_mode && (opts.track > 0 || opts.new_branch\n\t\t\t   || opts.new_branch_log || opts.merge || opts.force\n\t\t\t   || opts.force_detach))\n\t\tdie (_(\"--patch is incompatible with all other options\"));\n\n\tif (opts.force_detach && (opts.new_branch || opts.new_orphan_branch))\n\t\tdie(_(\"--detach cannot be used with -b/-B/--orphan\"));\n\tif (opts.force_detach && 0 < opts.track)\n\t\tdie(_(\"--detach cannot be used with -t\"));\n\n\t/* --track without -b should DWIM */\n\tif (0 < opts.track && !opts.new_branch) {\n\t\tconst char *argv0 = argv[0];\n\t\tif (!argc || !strcmp(argv0, \"--\"))\n\t\t\tdie (_(\"--track needs a branch name\"));\n\t\tif (!prefixcmp(argv0, \"refs/\"))\n\t\t\targv0 += 5;\n\t\tif (!prefixcmp(argv0, \"remotes/\"))\n\t\t\targv0 += 8;\n\t\targv0 = strchr(argv0, '/');\n\t\tif (!argv0 || !argv0[1])\n\t\t\tdie (_(\"Missing branch name; try -b\"));\n\t\topts.new_branch = argv0 + 1;\n\t}\n\n\tif (opts.new_orphan_branch) {\n\t\tif (opts.new_branch)\n\t\t\tdie(_(\"--orphan and -b|-B are mutually exclusive\"));\n\t\tif (opts.track > 0)\n\t\t\tdie(_(\"--orphan cannot be used with -t\"));\n\t\topts.new_branch = opts.new_orphan_branch;\n\t}\n\n\tif (conflict_style) {\n\t\topts.merge = 1; /* implied */\n\t\tgit_xmerge_config(\"merge.conflictstyle\", conflict_style, NULL);\n\t}\n\n\tif (opts.force && opts.merge)\n\t\tdie(_(\"git checkout: -f and -m are incompatible\"));\n\n\t/*\n\t * Extract branch name from command line arguments, so\n\t * all that is left is pathspecs.\n\t *\n\t * Handle\n\t *\n\t *  1) git checkout <tree> -- [<paths>]\n\t *  2) git checkout -- [<paths>]\n\t *  3) git checkout <something> [<paths>]\n\t *\n\t * including \"last branch\" syntax and DWIM-ery for names of\n\t * remote branches, erroring out for invalid or ambiguous cases.\n\t */\n\tif (argc) {\n\t\tint dwim_ok =\n\t\t\t!patch_mode &&\n\t\t\tdwim_new_local_branch &&\n\t\t\topts.track == BRANCH_TRACK_UNSPECIFIED &&\n\t\t\t!opts.new_branch;\n\t\tint n = parse_branchname_arg(argc, argv, dwim_ok,\n\t\t\t\t&new, &source_tree, rev, &opts.new_branch);\n\t\targv += n;\n\t\targc -= n;\n\t}\n\n\tif (opts.track == BRANCH_TRACK_UNSPECIFIED)\n\t\topts.track = git_branch_track;\n\n\tif (argc) {\n\t\tconst char **pathspec = get_pathspec(prefix, argv);\n\n\t\tif (!pathspec)\n\t\t\tdie(_(\"invalid path specification\"));\n\n\t\tif (patch_mode)\n\t\t\treturn interactive_checkout(new.name, pathspec, &opts);\n\n\t\t/* Checkout paths */\n\t\tif (opts.new_branch) {\n\t\t\tif (argc == 1) {\n\t\t\t\tdie(_(\"git checkout: updating paths is incompatible with switching branches.\\nDid you intend to checkout '%s' which can not be resolved as commit?\"), argv[0]);\n\t\t\t} else {\n\t\t\t\tdie(_(\"git checkout: updating paths is incompatible with switching branches.\"));\n\t\t\t}\n\t\t}\n\n\t\tif (opts.force_detach)\n\t\t\tdie(_(\"git checkout: --detach does not take a path argument\"));\n\n\t\tif (1 < !!opts.writeout_stage + !!opts.force + !!opts.merge)\n\t\t\tdie(_(\"git checkout: --ours/--theirs, --force and --merge are incompatible when\\nchecking out of the index.\"));\n\n\t\treturn checkout_paths(source_tree, pathspec, prefix, &opts);\n\t}\n\n\tif (patch_mode)\n\t\treturn interactive_checkout(new.name, NULL, &opts);\n\n\tif (opts.new_branch) {\n\t\tstruct strbuf buf = STRBUF_INIT;\n\n\t\topts.branch_exists = validate_new_branchname(opts.new_branch, &buf,\n\t\t\t\t\t\t\t     !!opts.new_branch_force, 0);\n\n\t\tstrbuf_release(&buf);\n\t}\n\n\tif (new.name && !new.commit) {\n\t\tdie(_(\"Cannot switch branch to a non-commit.\"));\n\t}\n\tif (opts.writeout_stage)\n\t\tdie(_(\"--ours/--theirs is incompatible with switching branches.\"));\n\n\treturn switch_branches(&opts, &new);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00740bd6796785cedd8d6baf730016f93a379cd8",
  "sha1_ok": true,
  "size": 30403
}
