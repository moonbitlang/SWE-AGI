{
  "content": {
    "base64": "LyoKICogImdpdCByZXNldCIgYnVpbHRpbiBjb21tYW5kCiAqCiAqIENvcHlyaWdodCAoYykgMjAwNyBDYXJsb3MgUmljYQogKgogKiBCYXNlZCBvbiBnaXQtcmVzZXQuc2gsIHdoaWNoIGlzCiAqCiAqIENvcHlyaWdodCAoYykgMjAwNSwgMjAwNiBMaW51cyBUb3J2YWxkcyBhbmQgSnVuaW8gQyBIYW1hbm8KICovCiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAidGFnLmgiCiNpbmNsdWRlICJvYmplY3QuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAicnVuLWNvbW1hbmQuaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgImRpZmZjb3JlLmgiCiNpbmNsdWRlICJ0cmVlLmgiCiNpbmNsdWRlICJicmFuY2guaCIKI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCIKI2luY2x1ZGUgInVucGFjay10cmVlcy5oIgojaW5jbHVkZSAiY2FjaGUtdHJlZS5oIgoKc3RhdGljIGNvbnN0IGNoYXIgKiBjb25zdCBnaXRfcmVzZXRfdXNhZ2VbXSA9IHsKCSJnaXQgcmVzZXQgWy0tbWl4ZWQgfCAtLXNvZnQgfCAtLWhhcmQgfCAtLW1lcmdlIHwgLS1rZWVwXSBbLXFdIFs8Y29tbWl0Pl0iLAoJImdpdCByZXNldCBbLXFdIDxjb21taXQ+IFstLV0gPHBhdGhzPi4uLiIsCgkiZ2l0IHJlc2V0IC0tcGF0Y2ggWzxjb21taXQ+XSBbLS1dIFs8cGF0aHM+Li4uXSIsCglOVUxMCn07CgplbnVtIHJlc2V0X3R5cGUgeyBNSVhFRCwgU09GVCwgSEFSRCwgTUVSR0UsIEtFRVAsIE5PTkUgfTsKc3RhdGljIGNvbnN0IGNoYXIgKnJlc2V0X3R5cGVfbmFtZXNbXSA9IHsKCSJtaXhlZCIsICJzb2Z0IiwgImhhcmQiLCAibWVyZ2UiLCAia2VlcCIsIE5VTEwKfTsKCnN0YXRpYyBjaGFyICphcmdzX3RvX3N0cihjb25zdCBjaGFyICoqYXJndikKewoJY2hhciAqYnVmID0gTlVMTDsKCXVuc2lnbmVkIGxvbmcgbGVuLCBzcGFjZSA9IDAsIG5yID0gMDsKCglmb3IgKDsgKmFyZ3Y7IGFyZ3YrKykgewoJCWxlbiA9IHN0cmxlbigqYXJndik7CgkJQUxMT0NfR1JPVyhidWYsIG5yICsgMSArIGxlbiwgc3BhY2UpOwoJCWlmIChucikKCQkJYnVmW25yKytdID0gJyAnOwoJCW1lbWNweShidWYgKyBuciwgKmFyZ3YsIGxlbik7CgkJbnIgKz0gbGVuOwoJfQoJQUxMT0NfR1JPVyhidWYsIG5yICsgMSwgc3BhY2UpOwoJYnVmW25yXSA9ICdcMCc7CgoJcmV0dXJuIGJ1ZjsKfQoKc3RhdGljIGlubGluZSBpbnQgaXNfbWVyZ2Uodm9pZCkKewoJcmV0dXJuICFhY2Nlc3MoZ2l0X3BhdGgoIk1FUkdFX0hFQUQiKSwgRl9PSyk7Cn0KCnN0YXRpYyBpbnQgcmVzZXRfaW5kZXhfZmlsZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBpbnQgcmVzZXRfdHlwZSwgaW50IHF1aWV0KQp7CglpbnQgbnIgPSAxOwoJaW50IG5ld2ZkOwoJc3RydWN0IHRyZWVfZGVzYyBkZXNjWzJdOwoJc3RydWN0IHVucGFja190cmVlc19vcHRpb25zIG9wdHM7CglzdHJ1Y3QgbG9ja19maWxlICpsb2NrID0geGNhbGxvYygxLCBzaXplb2Yoc3RydWN0IGxvY2tfZmlsZSkpOwoKCW1lbXNldCgmb3B0cywgMCwgc2l6ZW9mKG9wdHMpKTsKCW9wdHMuaGVhZF9pZHggPSAxOwoJb3B0cy5zcmNfaW5kZXggPSAmdGhlX2luZGV4OwoJb3B0cy5kc3RfaW5kZXggPSAmdGhlX2luZGV4OwoJb3B0cy5mbiA9IG9uZXdheV9tZXJnZTsKCW9wdHMubWVyZ2UgPSAxOwoJaWYgKCFxdWlldCkKCQlvcHRzLnZlcmJvc2VfdXBkYXRlID0gMTsKCXN3aXRjaCAocmVzZXRfdHlwZSkgewoJY2FzZSBLRUVQOgoJY2FzZSBNRVJHRToKCQlvcHRzLnVwZGF0ZSA9IDE7CgkJYnJlYWs7CgljYXNlIEhBUkQ6CgkJb3B0cy51cGRhdGUgPSAxOwoJCS8qIGZhbGx0aHJvdWdoICovCglkZWZhdWx0OgoJCW9wdHMucmVzZXQgPSAxOwoJfQoKCW5ld2ZkID0gaG9sZF9sb2NrZWRfaW5kZXgobG9jaywgMSk7CgoJcmVhZF9jYWNoZV91bm1lcmdlZCgpOwoKCWlmIChyZXNldF90eXBlID09IEtFRVApIHsKCQl1bnNpZ25lZCBjaGFyIGhlYWRfc2hhMVsyMF07CgkJaWYgKGdldF9zaGExKCJIRUFEIiwgaGVhZF9zaGExKSkKCQkJcmV0dXJuIGVycm9yKCJZb3UgZG8gbm90IGhhdmUgYSB2YWxpZCBIRUFELiIpOwoJCWlmICghZmlsbF90cmVlX2Rlc2NyaXB0b3IoZGVzYywgaGVhZF9zaGExKSkKCQkJcmV0dXJuIGVycm9yKCJGYWlsZWQgdG8gZmluZCB0cmVlIG9mIEhFQUQuIik7CgkJbnIrKzsKCQlvcHRzLmZuID0gdHdvd2F5X21lcmdlOwoJfQoKCWlmICghZmlsbF90cmVlX2Rlc2NyaXB0b3IoZGVzYyArIG5yIC0gMSwgc2hhMSkpCgkJcmV0dXJuIGVycm9yKCJGYWlsZWQgdG8gZmluZCB0cmVlIG9mICVzLiIsIHNoYTFfdG9faGV4KHNoYTEpKTsKCWlmICh1bnBhY2tfdHJlZXMobnIsIGRlc2MsICZvcHRzKSkKCQlyZXR1cm4gLTE7CglpZiAod3JpdGVfY2FjaGUobmV3ZmQsIGFjdGl2ZV9jYWNoZSwgYWN0aXZlX25yKSB8fAoJICAgIGNvbW1pdF9sb2NrZWRfaW5kZXgobG9jaykpCgkJcmV0dXJuIGVycm9yKCJDb3VsZCBub3Qgd3JpdGUgbmV3IGluZGV4IGZpbGUuIik7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHByaW50X25ld19oZWFkX2xpbmUoc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7Cgljb25zdCBjaGFyICpoZXgsICpib2R5OwoKCWhleCA9IGZpbmRfdW5pcXVlX2FiYnJldihjb21taXQtPm9iamVjdC5zaGExLCBERUZBVUxUX0FCQlJFVik7CglwcmludGYoIkhFQUQgaXMgbm93IGF0ICVzIiwgaGV4KTsKCWJvZHkgPSBzdHJzdHIoY29tbWl0LT5idWZmZXIsICJcblxuIik7CglpZiAoYm9keSkgewoJCWNvbnN0IGNoYXIgKmVvbDsKCQlzaXplX3QgbGVuOwoJCWJvZHkgKz0gMjsKCQllb2wgPSBzdHJjaHIoYm9keSwgJ1xuJyk7CgkJbGVuID0gZW9sID8gZW9sIC0gYm9keSA6IHN0cmxlbihib2R5KTsKCQlwcmludGYoIiAlLipzXG4iLCAoaW50KSBsZW4sIGJvZHkpOwoJfQoJZWxzZQoJCXByaW50ZigiXG4iKTsKfQoKc3RhdGljIGludCB1cGRhdGVfaW5kZXhfcmVmcmVzaChpbnQgZmQsIHN0cnVjdCBsb2NrX2ZpbGUgKmluZGV4X2xvY2ssIGludCBmbGFncykKewoJaW50IHJlc3VsdDsKCglpZiAoIWluZGV4X2xvY2spIHsKCQlpbmRleF9sb2NrID0geGNhbGxvYygxLCBzaXplb2Yoc3RydWN0IGxvY2tfZmlsZSkpOwoJCWZkID0gaG9sZF9sb2NrZWRfaW5kZXgoaW5kZXhfbG9jaywgMSk7Cgl9CgoJaWYgKHJlYWRfY2FjaGUoKSA8IDApCgkJcmV0dXJuIGVycm9yKCJDb3VsZCBub3QgcmVhZCBpbmRleCIpOwoKCXJlc3VsdCA9IHJlZnJlc2hfaW5kZXgoJnRoZV9pbmRleCwgKGZsYWdzKSwgTlVMTCwgTlVMTCwKCQkJICAgICAgICJVbnN0YWdlZCBjaGFuZ2VzIGFmdGVyIHJlc2V0OiIpID8gMSA6IDA7CglpZiAod3JpdGVfY2FjaGUoZmQsIGFjdGl2ZV9jYWNoZSwgYWN0aXZlX25yKSB8fAoJCQljb21taXRfbG9ja2VkX2luZGV4KGluZGV4X2xvY2spKQoJCXJldHVybiBlcnJvciAoIkNvdWxkIG5vdCByZWZyZXNoIGluZGV4Iik7CglyZXR1cm4gcmVzdWx0Owp9CgpzdGF0aWMgdm9pZCB1cGRhdGVfaW5kZXhfZnJvbV9kaWZmKHN0cnVjdCBkaWZmX3F1ZXVlX3N0cnVjdCAqcSwKCQlzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHQsIHZvaWQgKmRhdGEpCnsKCWludCBpOwoJaW50ICpkaXNjYXJkX2ZsYWcgPSBkYXRhOwoKCS8qIGRvX2RpZmZfY2FjaGUoKSBtYW5nbGVkIHRoZSBpbmRleCAqLwoJZGlzY2FyZF9jYWNoZSgpOwoJKmRpc2NhcmRfZmxhZyA9IDE7CglyZWFkX2NhY2hlKCk7CgoJZm9yIChpID0gMDsgaSA8IHEtPm5yOyBpKyspIHsKCQlzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqb25lID0gcS0+cXVldWVbaV0tPm9uZTsKCQlpZiAob25lLT5tb2RlKSB7CgkJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2U7CgkJCWNlID0gbWFrZV9jYWNoZV9lbnRyeShvbmUtPm1vZGUsIG9uZS0+c2hhMSwgb25lLT5wYXRoLAoJCQkJMCwgMCk7CgkJCWlmICghY2UpCgkJCQlkaWUoIm1ha2VfY2FjaGVfZW50cnkgZmFpbGVkIGZvciBwYXRoICclcyciLAoJCQkJICAgIG9uZS0+cGF0aCk7CgkJCWFkZF9jYWNoZV9lbnRyeShjZSwgQUREX0NBQ0hFX09LX1RPX0FERCB8CgkJCQlBRERfQ0FDSEVfT0tfVE9fUkVQTEFDRSk7CgkJfSBlbHNlCgkJCXJlbW92ZV9maWxlX2Zyb21fY2FjaGUob25lLT5wYXRoKTsKCX0KfQoKc3RhdGljIGludCBpbnRlcmFjdGl2ZV9yZXNldChjb25zdCBjaGFyICpyZXZpc2lvbiwgY29uc3QgY2hhciAqKmFyZ3YsCgkJCSAgICAgY29uc3QgY2hhciAqcHJlZml4KQp7Cgljb25zdCBjaGFyICoqcGF0aHNwZWMgPSBOVUxMOwoKCWlmICgqYXJndikKCQlwYXRoc3BlYyA9IGdldF9wYXRoc3BlYyhwcmVmaXgsIGFyZ3YpOwoKCXJldHVybiBydW5fYWRkX2ludGVyYWN0aXZlKHJldmlzaW9uLCAiLS1wYXRjaD1yZXNldCIsIHBhdGhzcGVjKTsKfQoKc3RhdGljIGludCByZWFkX2Zyb21fdHJlZShjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IGNoYXIgKiphcmd2LAoJCXVuc2lnbmVkIGNoYXIgKnRyZWVfc2hhMSwgaW50IHJlZnJlc2hfZmxhZ3MpCnsKCXN0cnVjdCBsb2NrX2ZpbGUgKmxvY2sgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3QgbG9ja19maWxlKSk7CglpbnQgaW5kZXhfZmQsIGluZGV4X3dhc19kaXNjYXJkZWQgPSAwOwoJc3RydWN0IGRpZmZfb3B0aW9ucyBvcHQ7CgoJbWVtc2V0KCZvcHQsIDAsIHNpemVvZihvcHQpKTsKCWRpZmZfdHJlZV9zZXR1cF9wYXRocyhnZXRfcGF0aHNwZWMocHJlZml4LCAoY29uc3QgY2hhciAqKilhcmd2KSwgJm9wdCk7CglvcHQub3V0cHV0X2Zvcm1hdCA9IERJRkZfRk9STUFUX0NBTExCQUNLOwoJb3B0LmZvcm1hdF9jYWxsYmFjayA9IHVwZGF0ZV9pbmRleF9mcm9tX2RpZmY7CglvcHQuZm9ybWF0X2NhbGxiYWNrX2RhdGEgPSAmaW5kZXhfd2FzX2Rpc2NhcmRlZDsKCglpbmRleF9mZCA9IGhvbGRfbG9ja2VkX2luZGV4KGxvY2ssIDEpOwoJaW5kZXhfd2FzX2Rpc2NhcmRlZCA9IDA7CglyZWFkX2NhY2hlKCk7CglpZiAoZG9fZGlmZl9jYWNoZSh0cmVlX3NoYTEsICZvcHQpKQoJCXJldHVybiAxOwoJZGlmZmNvcmVfc3RkKCZvcHQpOwoJZGlmZl9mbHVzaCgmb3B0KTsKCWRpZmZfdHJlZV9yZWxlYXNlX3BhdGhzKCZvcHQpOwoKCWlmICghaW5kZXhfd2FzX2Rpc2NhcmRlZCkKCQkvKiBUaGUgaW5kZXggaXMgc3RpbGwgY2xvYmJlcmVkIGZyb20gZG9fZGlmZl9jYWNoZSgpICovCgkJZGlzY2FyZF9jYWNoZSgpOwoJcmV0dXJuIHVwZGF0ZV9pbmRleF9yZWZyZXNoKGluZGV4X2ZkLCBsb2NrLCByZWZyZXNoX2ZsYWdzKTsKfQoKc3RhdGljIHZvaWQgcHJlcGVuZF9yZWZsb2dfYWN0aW9uKGNvbnN0IGNoYXIgKmFjdGlvbiwgY2hhciAqYnVmLCBzaXplX3Qgc2l6ZSkKewoJY29uc3QgY2hhciAqc2VwID0gIjogIjsKCWNvbnN0IGNoYXIgKnJsYSA9IGdldGVudigiR0lUX1JFRkxPR19BQ1RJT04iKTsKCWlmICghcmxhKQoJCXJsYSA9IHNlcCA9ICIiOwoJaWYgKHNucHJpbnRmKGJ1Ziwgc2l6ZSwgIiVzJXMlcyIsIHJsYSwgc2VwLCBhY3Rpb24pID49IHNpemUpCgkJd2FybmluZygiUmVmbG9nIGFjdGlvbiBtZXNzYWdlIHRvbyBsb25nOiAlLipzLi4uIiwgNTAsIGJ1Zik7Cn0KCnN0YXRpYyB2b2lkIGRpZV9pZl91bm1lcmdlZF9jYWNoZShpbnQgcmVzZXRfdHlwZSkKewoJaWYgKGlzX21lcmdlKCkgfHwgcmVhZF9jYWNoZSgpIDwgMCB8fCB1bm1lcmdlZF9jYWNoZSgpKQoJCWRpZSgiQ2Fubm90IGRvIGEgJXMgcmVzZXQgaW4gdGhlIG1pZGRsZSBvZiBhIG1lcmdlLiIsCgkJICAgIHJlc2V0X3R5cGVfbmFtZXNbcmVzZXRfdHlwZV0pOwoKfQoKaW50IGNtZF9yZXNldChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJaW50IGkgPSAwLCByZXNldF90eXBlID0gTk9ORSwgdXBkYXRlX3JlZl9zdGF0dXMgPSAwLCBxdWlldCA9IDA7CglpbnQgcGF0Y2hfbW9kZSA9IDA7Cgljb25zdCBjaGFyICpyZXYgPSAiSEVBRCI7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdLCAqb3JpZyA9IE5VTEwsIHNoYTFfb3JpZ1syMF0sCgkJCQkqb2xkX29yaWcgPSBOVUxMLCBzaGExX29sZF9vcmlnWzIwXTsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCWNoYXIgKnJlZmxvZ19hY3Rpb24sIG1zZ1sxMDI0XTsKCWNvbnN0IHN0cnVjdCBvcHRpb24gb3B0aW9uc1tdID0gewoJCU9QVF9fUVVJRVQoJnF1aWV0KSwKCQlPUFRfU0VUX0lOVCgwLCAibWl4ZWQiLCAmcmVzZXRfdHlwZSwKCQkJCQkJInJlc2V0IEhFQUQgYW5kIGluZGV4IiwgTUlYRUQpLAoJCU9QVF9TRVRfSU5UKDAsICJzb2Z0IiwgJnJlc2V0X3R5cGUsICJyZXNldCBvbmx5IEhFQUQiLCBTT0ZUKSwKCQlPUFRfU0VUX0lOVCgwLCAiaGFyZCIsICZyZXNldF90eXBlLAoJCQkJInJlc2V0IEhFQUQsIGluZGV4IGFuZCB3b3JraW5nIHRyZWUiLCBIQVJEKSwKCQlPUFRfU0VUX0lOVCgwLCAibWVyZ2UiLCAmcmVzZXRfdHlwZSwKCQkJCSJyZXNldCBIRUFELCBpbmRleCBhbmQgd29ya2luZyB0cmVlIiwgTUVSR0UpLAoJCU9QVF9TRVRfSU5UKDAsICJrZWVwIiwgJnJlc2V0X3R5cGUsCgkJCQkicmVzZXQgSEVBRCBidXQga2VlcCBsb2NhbCBjaGFuZ2VzIiwgS0VFUCksCgkJT1BUX0JPT0xFQU4oJ3AnLCAicGF0Y2giLCAmcGF0Y2hfbW9kZSwgInNlbGVjdCBodW5rcyBpbnRlcmFjdGl2ZWx5IiksCgkJT1BUX0VORCgpCgl9OwoKCWdpdF9jb25maWcoZ2l0X2RlZmF1bHRfY29uZmlnLCBOVUxMKTsKCglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIG9wdGlvbnMsIGdpdF9yZXNldF91c2FnZSwKCQkJCQkJUEFSU0VfT1BUX0tFRVBfREFTSERBU0gpOwoJcmVmbG9nX2FjdGlvbiA9IGFyZ3NfdG9fc3RyKGFyZ3YpOwoJc2V0ZW52KCJHSVRfUkVGTE9HX0FDVElPTiIsIHJlZmxvZ19hY3Rpb24sIDApOwoKCS8qCgkgKiBQb3NzaWJsZSBhcmd1bWVudHMgYXJlOgoJICoKCSAqIGdpdCByZXNldCBbLW9wdHNdIDxyZXY+IDxwYXRocz4uLi4KCSAqIGdpdCByZXNldCBbLW9wdHNdIDxyZXY+IC0tIDxwYXRocz4uLi4KCSAqIGdpdCByZXNldCBbLW9wdHNdIC0tIDxwYXRocz4uLi4KCSAqIGdpdCByZXNldCBbLW9wdHNdIDxwYXRocz4uLi4KCSAqCgkgKiBBdCB0aGlzIHBvaW50LCBhcmd2W2ldIHBvaW50cyBpbW1lZGlhdGVseSBhZnRlciBbLW9wdHNdLgoJICovCgoJaWYgKGkgPCBhcmdjKSB7CgkJaWYgKCFzdHJjbXAoYXJndltpXSwgIi0tIikpIHsKCQkJaSsrOyAvKiByZXNldCB0byBIRUFELCBwb3NzaWJseSB3aXRoIHBhdGhzICovCgkJfSBlbHNlIGlmIChpICsgMSA8IGFyZ2MgJiYgIXN0cmNtcChhcmd2W2krMV0sICItLSIpKSB7CgkJCXJldiA9IGFyZ3ZbaV07CgkJCWkgKz0gMjsKCQl9CgkJLyoKCQkgKiBPdGhlcndpc2UsIGFyZ3ZbaV0gY291bGQgYmUgZWl0aGVyIDxyZXY+IG9yIDxwYXRocz4gYW5kCgkJICogaGFzIHRvIGJlIHVuYW1iaWd1b3VzLgoJCSAqLwoJCWVsc2UgaWYgKCFnZXRfc2hhMShhcmd2W2ldLCBzaGExKSkgewoJCQkvKgoJCQkgKiBPaywgYXJndltpXSBsb29rcyBsaWtlIGEgcmV2OyBpdCBzaG91bGQgbm90CgkJCSAqIGJlIGEgZmlsZW5hbWUuCgkJCSAqLwoJCQl2ZXJpZnlfbm9uX2ZpbGVuYW1lKHByZWZpeCwgYXJndltpXSk7CgkJCXJldiA9IGFyZ3ZbaSsrXTsKCQl9IGVsc2UgewoJCQkvKiBPdGhlcndpc2Ugd2UgdHJlYXQgdGhpcyBhcyBhIGZpbGVuYW1lICovCgkJCXZlcmlmeV9maWxlbmFtZShwcmVmaXgsIGFyZ3ZbaV0pOwoJCX0KCX0KCglpZiAoZ2V0X3NoYTEocmV2LCBzaGExKSkKCQlkaWUoIkZhaWxlZCB0byByZXNvbHZlICclcycgYXMgYSB2YWxpZCByZWYuIiwgcmV2KTsKCgljb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZShzaGExKTsKCWlmICghY29tbWl0KQoJCWRpZSgiQ291bGQgbm90IHBhcnNlIG9iamVjdCAnJXMnLiIsIHJldik7CgloYXNoY3B5KHNoYTEsIGNvbW1pdC0+b2JqZWN0LnNoYTEpOwoKCWlmIChwYXRjaF9tb2RlKSB7CgkJaWYgKHJlc2V0X3R5cGUgIT0gTk9ORSkKCQkJZGllKCItLXBhdGNoIGlzIGluY29tcGF0aWJsZSB3aXRoIC0te2hhcmQsbWl4ZWQsc29mdH0iKTsKCQlyZXR1cm4gaW50ZXJhY3RpdmVfcmVzZXQocmV2LCBhcmd2ICsgaSwgcHJlZml4KTsKCX0KCgkvKiBnaXQgcmVzZXQgdHJlZSBbLS1dIHBhdGhzLi4uIGNhbiBiZSB1c2VkIHRvCgkgKiBsb2FkIGNob3NlbiBwYXRocyBmcm9tIHRoZSB0cmVlIGludG8gdGhlIGluZGV4IHdpdGhvdXQKCSAqIGFmZmVjdGluZyB0aGUgd29ya2luZyB0cmVlIG5vciBIRUFELiAqLwoJaWYgKGkgPCBhcmdjKSB7CgkJaWYgKHJlc2V0X3R5cGUgPT0gTUlYRUQpCgkJCXdhcm5pbmcoIi0tbWl4ZWQgd2l0aCBwYXRocyBpcyBkZXByZWNhdGVkOyB1c2UgJ2dpdCByZXNldCAtLSA8cGF0aHM+JyBpbnN0ZWFkLiIpOwoJCWVsc2UgaWYgKHJlc2V0X3R5cGUgIT0gTk9ORSkKCQkJZGllKCJDYW5ub3QgZG8gJXMgcmVzZXQgd2l0aCBwYXRocy4iLAoJCQkJCXJlc2V0X3R5cGVfbmFtZXNbcmVzZXRfdHlwZV0pOwoJCXJldHVybiByZWFkX2Zyb21fdHJlZShwcmVmaXgsIGFyZ3YgKyBpLCBzaGExLAoJCQkJcXVpZXQgPyBSRUZSRVNIX1FVSUVUIDogUkVGUkVTSF9JTl9QT1JDRUxBSU4pOwoJfQoJaWYgKHJlc2V0X3R5cGUgPT0gTk9ORSkKCQlyZXNldF90eXBlID0gTUlYRUQ7IC8qIGJ5IGRlZmF1bHQgKi8KCglpZiAocmVzZXRfdHlwZSAhPSBTT0ZUICYmIHJlc2V0X3R5cGUgIT0gTUlYRUQpCgkJc2V0dXBfd29ya190cmVlKCk7CgoJaWYgKHJlc2V0X3R5cGUgPT0gTUlYRUQgJiYgaXNfYmFyZV9yZXBvc2l0b3J5KCkpCgkJZGllKCIlcyByZXNldCBpcyBub3QgYWxsb3dlZCBpbiBhIGJhcmUgcmVwb3NpdG9yeSIsCgkJICAgIHJlc2V0X3R5cGVfbmFtZXNbcmVzZXRfdHlwZV0pOwoKCS8qIFNvZnQgcmVzZXQgZG9lcyBub3QgdG91Y2ggdGhlIGluZGV4IGZpbGUgbm9yIHRoZSB3b3JraW5nIHRyZWUKCSAqIGF0IGFsbCwgYnV0IHJlcXVpcmVzIHRoZW0gaW4gYSBnb29kIG9yZGVyLiAgT3RoZXIgcmVzZXRzIHJlc2V0CgkgKiB0aGUgaW5kZXggZmlsZSB0byB0aGUgdHJlZSBvYmplY3Qgd2UgYXJlIHN3aXRjaGluZyB0by4gKi8KCWlmIChyZXNldF90eXBlID09IFNPRlQpCgkJZGllX2lmX3VubWVyZ2VkX2NhY2hlKHJlc2V0X3R5cGUpOwoJZWxzZSB7CgkJaW50IGVycjsKCQlpZiAocmVzZXRfdHlwZSA9PSBLRUVQKQoJCQlkaWVfaWZfdW5tZXJnZWRfY2FjaGUocmVzZXRfdHlwZSk7CgkJZXJyID0gcmVzZXRfaW5kZXhfZmlsZShzaGExLCByZXNldF90eXBlLCBxdWlldCk7CgkJaWYgKHJlc2V0X3R5cGUgPT0gS0VFUCkKCQkJZXJyID0gZXJyIHx8IHJlc2V0X2luZGV4X2ZpbGUoc2hhMSwgTUlYRUQsIHF1aWV0KTsKCQlpZiAoZXJyKQoJCQlkaWUoIkNvdWxkIG5vdCByZXNldCBpbmRleCBmaWxlIHRvIHJldmlzaW9uICclcycuIiwgcmV2KTsKCX0KCgkvKiBBbnkgcmVzZXRzIHVwZGF0ZSBIRUFEIHRvIHRoZSBoZWFkIGJlaW5nIHN3aXRjaGVkIHRvLAoJICogc2F2aW5nIHRoZSBwcmV2aW91cyBoZWFkIGluIE9SSUdfSEVBRCBiZWZvcmUuICovCglpZiAoIWdldF9zaGExKCJPUklHX0hFQUQiLCBzaGExX29sZF9vcmlnKSkKCQlvbGRfb3JpZyA9IHNoYTFfb2xkX29yaWc7CglpZiAoIWdldF9zaGExKCJIRUFEIiwgc2hhMV9vcmlnKSkgewoJCW9yaWcgPSBzaGExX29yaWc7CgkJcHJlcGVuZF9yZWZsb2dfYWN0aW9uKCJ1cGRhdGluZyBPUklHX0hFQUQiLCBtc2csIHNpemVvZihtc2cpKTsKCQl1cGRhdGVfcmVmKG1zZywgIk9SSUdfSEVBRCIsIG9yaWcsIG9sZF9vcmlnLCAwLCBNU0dfT05fRVJSKTsKCX0KCWVsc2UgaWYgKG9sZF9vcmlnKQoJCWRlbGV0ZV9yZWYoIk9SSUdfSEVBRCIsIG9sZF9vcmlnLCAwKTsKCXByZXBlbmRfcmVmbG9nX2FjdGlvbigidXBkYXRpbmcgSEVBRCIsIG1zZywgc2l6ZW9mKG1zZykpOwoJdXBkYXRlX3JlZl9zdGF0dXMgPSB1cGRhdGVfcmVmKG1zZywgIkhFQUQiLCBzaGExLCBvcmlnLCAwLCBNU0dfT05fRVJSKTsKCglzd2l0Y2ggKHJlc2V0X3R5cGUpIHsKCWNhc2UgSEFSRDoKCQlpZiAoIXVwZGF0ZV9yZWZfc3RhdHVzICYmICFxdWlldCkKCQkJcHJpbnRfbmV3X2hlYWRfbGluZShjb21taXQpOwoJCWJyZWFrOwoJY2FzZSBTT0ZUOiAvKiBOb3RoaW5nIGVsc2UgdG8gZG8uICovCgkJYnJlYWs7CgljYXNlIE1JWEVEOiAvKiBSZXBvcnQgd2hhdCBoYXMgbm90IGJlZW4gdXBkYXRlZC4gKi8KCQl1cGRhdGVfaW5kZXhfcmVmcmVzaCgwLCBOVUxMLAoJCQkJcXVpZXQgPyBSRUZSRVNIX1FVSUVUIDogUkVGUkVTSF9JTl9QT1JDRUxBSU4pOwoJCWJyZWFrOwoJfQoKCXJlbW92ZV9icmFuY2hfc3RhdGUoKTsKCglmcmVlKHJlZmxvZ19hY3Rpb24pOwoKCXJldHVybiB1cGRhdGVfcmVmX3N0YXR1czsKfQo=",
    "text": "/*\n * \"git reset\" builtin command\n *\n * Copyright (c) 2007 Carlos Rica\n *\n * Based on git-reset.sh, which is\n *\n * Copyright (c) 2005, 2006 Linus Torvalds and Junio C Hamano\n */\n#include \"cache.h\"\n#include \"tag.h\"\n#include \"object.h\"\n#include \"commit.h\"\n#include \"run-command.h\"\n#include \"refs.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"tree.h\"\n#include \"branch.h\"\n#include \"parse-options.h\"\n#include \"unpack-trees.h\"\n#include \"cache-tree.h\"\n\nstatic const char * const git_reset_usage[] = {\n\t\"git reset [--mixed | --soft | --hard | --merge | --keep] [-q] [<commit>]\",\n\t\"git reset [-q] <commit> [--] <paths>...\",\n\t\"git reset --patch [<commit>] [--] [<paths>...]\",\n\tNULL\n};\n\nenum reset_type { MIXED, SOFT, HARD, MERGE, KEEP, NONE };\nstatic const char *reset_type_names[] = {\n\t\"mixed\", \"soft\", \"hard\", \"merge\", \"keep\", NULL\n};\n\nstatic char *args_to_str(const char **argv)\n{\n\tchar *buf = NULL;\n\tunsigned long len, space = 0, nr = 0;\n\n\tfor (; *argv; argv++) {\n\t\tlen = strlen(*argv);\n\t\tALLOC_GROW(buf, nr + 1 + len, space);\n\t\tif (nr)\n\t\t\tbuf[nr++] = ' ';\n\t\tmemcpy(buf + nr, *argv, len);\n\t\tnr += len;\n\t}\n\tALLOC_GROW(buf, nr + 1, space);\n\tbuf[nr] = '\\0';\n\n\treturn buf;\n}\n\nstatic inline int is_merge(void)\n{\n\treturn !access(git_path(\"MERGE_HEAD\"), F_OK);\n}\n\nstatic int reset_index_file(const unsigned char *sha1, int reset_type, int quiet)\n{\n\tint nr = 1;\n\tint newfd;\n\tstruct tree_desc desc[2];\n\tstruct unpack_trees_options opts;\n\tstruct lock_file *lock = xcalloc(1, sizeof(struct lock_file));\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.head_idx = 1;\n\topts.src_index = &the_index;\n\topts.dst_index = &the_index;\n\topts.fn = oneway_merge;\n\topts.merge = 1;\n\tif (!quiet)\n\t\topts.verbose_update = 1;\n\tswitch (reset_type) {\n\tcase KEEP:\n\tcase MERGE:\n\t\topts.update = 1;\n\t\tbreak;\n\tcase HARD:\n\t\topts.update = 1;\n\t\t/* fallthrough */\n\tdefault:\n\t\topts.reset = 1;\n\t}\n\n\tnewfd = hold_locked_index(lock, 1);\n\n\tread_cache_unmerged();\n\n\tif (reset_type == KEEP) {\n\t\tunsigned char head_sha1[20];\n\t\tif (get_sha1(\"HEAD\", head_sha1))\n\t\t\treturn error(\"You do not have a valid HEAD.\");\n\t\tif (!fill_tree_descriptor(desc, head_sha1))\n\t\t\treturn error(\"Failed to find tree of HEAD.\");\n\t\tnr++;\n\t\topts.fn = twoway_merge;\n\t}\n\n\tif (!fill_tree_descriptor(desc + nr - 1, sha1))\n\t\treturn error(\"Failed to find tree of %s.\", sha1_to_hex(sha1));\n\tif (unpack_trees(nr, desc, &opts))\n\t\treturn -1;\n\tif (write_cache(newfd, active_cache, active_nr) ||\n\t    commit_locked_index(lock))\n\t\treturn error(\"Could not write new index file.\");\n\n\treturn 0;\n}\n\nstatic void print_new_head_line(struct commit *commit)\n{\n\tconst char *hex, *body;\n\n\thex = find_unique_abbrev(commit->object.sha1, DEFAULT_ABBREV);\n\tprintf(\"HEAD is now at %s\", hex);\n\tbody = strstr(commit->buffer, \"\\n\\n\");\n\tif (body) {\n\t\tconst char *eol;\n\t\tsize_t len;\n\t\tbody += 2;\n\t\teol = strchr(body, '\\n');\n\t\tlen = eol ? eol - body : strlen(body);\n\t\tprintf(\" %.*s\\n\", (int) len, body);\n\t}\n\telse\n\t\tprintf(\"\\n\");\n}\n\nstatic int update_index_refresh(int fd, struct lock_file *index_lock, int flags)\n{\n\tint result;\n\n\tif (!index_lock) {\n\t\tindex_lock = xcalloc(1, sizeof(struct lock_file));\n\t\tfd = hold_locked_index(index_lock, 1);\n\t}\n\n\tif (read_cache() < 0)\n\t\treturn error(\"Could not read index\");\n\n\tresult = refresh_index(&the_index, (flags), NULL, NULL,\n\t\t\t       \"Unstaged changes after reset:\") ? 1 : 0;\n\tif (write_cache(fd, active_cache, active_nr) ||\n\t\t\tcommit_locked_index(index_lock))\n\t\treturn error (\"Could not refresh index\");\n\treturn result;\n}\n\nstatic void update_index_from_diff(struct diff_queue_struct *q,\n\t\tstruct diff_options *opt, void *data)\n{\n\tint i;\n\tint *discard_flag = data;\n\n\t/* do_diff_cache() mangled the index */\n\tdiscard_cache();\n\t*discard_flag = 1;\n\tread_cache();\n\n\tfor (i = 0; i < q->nr; i++) {\n\t\tstruct diff_filespec *one = q->queue[i]->one;\n\t\tif (one->mode) {\n\t\t\tstruct cache_entry *ce;\n\t\t\tce = make_cache_entry(one->mode, one->sha1, one->path,\n\t\t\t\t0, 0);\n\t\t\tif (!ce)\n\t\t\t\tdie(\"make_cache_entry failed for path '%s'\",\n\t\t\t\t    one->path);\n\t\t\tadd_cache_entry(ce, ADD_CACHE_OK_TO_ADD |\n\t\t\t\tADD_CACHE_OK_TO_REPLACE);\n\t\t} else\n\t\t\tremove_file_from_cache(one->path);\n\t}\n}\n\nstatic int interactive_reset(const char *revision, const char **argv,\n\t\t\t     const char *prefix)\n{\n\tconst char **pathspec = NULL;\n\n\tif (*argv)\n\t\tpathspec = get_pathspec(prefix, argv);\n\n\treturn run_add_interactive(revision, \"--patch=reset\", pathspec);\n}\n\nstatic int read_from_tree(const char *prefix, const char **argv,\n\t\tunsigned char *tree_sha1, int refresh_flags)\n{\n\tstruct lock_file *lock = xcalloc(1, sizeof(struct lock_file));\n\tint index_fd, index_was_discarded = 0;\n\tstruct diff_options opt;\n\n\tmemset(&opt, 0, sizeof(opt));\n\tdiff_tree_setup_paths(get_pathspec(prefix, (const char **)argv), &opt);\n\topt.output_format = DIFF_FORMAT_CALLBACK;\n\topt.format_callback = update_index_from_diff;\n\topt.format_callback_data = &index_was_discarded;\n\n\tindex_fd = hold_locked_index(lock, 1);\n\tindex_was_discarded = 0;\n\tread_cache();\n\tif (do_diff_cache(tree_sha1, &opt))\n\t\treturn 1;\n\tdiffcore_std(&opt);\n\tdiff_flush(&opt);\n\tdiff_tree_release_paths(&opt);\n\n\tif (!index_was_discarded)\n\t\t/* The index is still clobbered from do_diff_cache() */\n\t\tdiscard_cache();\n\treturn update_index_refresh(index_fd, lock, refresh_flags);\n}\n\nstatic void prepend_reflog_action(const char *action, char *buf, size_t size)\n{\n\tconst char *sep = \": \";\n\tconst char *rla = getenv(\"GIT_REFLOG_ACTION\");\n\tif (!rla)\n\t\trla = sep = \"\";\n\tif (snprintf(buf, size, \"%s%s%s\", rla, sep, action) >= size)\n\t\twarning(\"Reflog action message too long: %.*s...\", 50, buf);\n}\n\nstatic void die_if_unmerged_cache(int reset_type)\n{\n\tif (is_merge() || read_cache() < 0 || unmerged_cache())\n\t\tdie(\"Cannot do a %s reset in the middle of a merge.\",\n\t\t    reset_type_names[reset_type]);\n\n}\n\nint cmd_reset(int argc, const char **argv, const char *prefix)\n{\n\tint i = 0, reset_type = NONE, update_ref_status = 0, quiet = 0;\n\tint patch_mode = 0;\n\tconst char *rev = \"HEAD\";\n\tunsigned char sha1[20], *orig = NULL, sha1_orig[20],\n\t\t\t\t*old_orig = NULL, sha1_old_orig[20];\n\tstruct commit *commit;\n\tchar *reflog_action, msg[1024];\n\tconst struct option options[] = {\n\t\tOPT__QUIET(&quiet),\n\t\tOPT_SET_INT(0, \"mixed\", &reset_type,\n\t\t\t\t\t\t\"reset HEAD and index\", MIXED),\n\t\tOPT_SET_INT(0, \"soft\", &reset_type, \"reset only HEAD\", SOFT),\n\t\tOPT_SET_INT(0, \"hard\", &reset_type,\n\t\t\t\t\"reset HEAD, index and working tree\", HARD),\n\t\tOPT_SET_INT(0, \"merge\", &reset_type,\n\t\t\t\t\"reset HEAD, index and working tree\", MERGE),\n\t\tOPT_SET_INT(0, \"keep\", &reset_type,\n\t\t\t\t\"reset HEAD but keep local changes\", KEEP),\n\t\tOPT_BOOLEAN('p', \"patch\", &patch_mode, \"select hunks interactively\"),\n\t\tOPT_END()\n\t};\n\n\tgit_config(git_default_config, NULL);\n\n\targc = parse_options(argc, argv, prefix, options, git_reset_usage,\n\t\t\t\t\t\tPARSE_OPT_KEEP_DASHDASH);\n\treflog_action = args_to_str(argv);\n\tsetenv(\"GIT_REFLOG_ACTION\", reflog_action, 0);\n\n\t/*\n\t * Possible arguments are:\n\t *\n\t * git reset [-opts] <rev> <paths>...\n\t * git reset [-opts] <rev> -- <paths>...\n\t * git reset [-opts] -- <paths>...\n\t * git reset [-opts] <paths>...\n\t *\n\t * At this point, argv[i] points immediately after [-opts].\n\t */\n\n\tif (i < argc) {\n\t\tif (!strcmp(argv[i], \"--\")) {\n\t\t\ti++; /* reset to HEAD, possibly with paths */\n\t\t} else if (i + 1 < argc && !strcmp(argv[i+1], \"--\")) {\n\t\t\trev = argv[i];\n\t\t\ti += 2;\n\t\t}\n\t\t/*\n\t\t * Otherwise, argv[i] could be either <rev> or <paths> and\n\t\t * has to be unambiguous.\n\t\t */\n\t\telse if (!get_sha1(argv[i], sha1)) {\n\t\t\t/*\n\t\t\t * Ok, argv[i] looks like a rev; it should not\n\t\t\t * be a filename.\n\t\t\t */\n\t\t\tverify_non_filename(prefix, argv[i]);\n\t\t\trev = argv[i++];\n\t\t} else {\n\t\t\t/* Otherwise we treat this as a filename */\n\t\t\tverify_filename(prefix, argv[i]);\n\t\t}\n\t}\n\n\tif (get_sha1(rev, sha1))\n\t\tdie(\"Failed to resolve '%s' as a valid ref.\", rev);\n\n\tcommit = lookup_commit_reference(sha1);\n\tif (!commit)\n\t\tdie(\"Could not parse object '%s'.\", rev);\n\thashcpy(sha1, commit->object.sha1);\n\n\tif (patch_mode) {\n\t\tif (reset_type != NONE)\n\t\t\tdie(\"--patch is incompatible with --{hard,mixed,soft}\");\n\t\treturn interactive_reset(rev, argv + i, prefix);\n\t}\n\n\t/* git reset tree [--] paths... can be used to\n\t * load chosen paths from the tree into the index without\n\t * affecting the working tree nor HEAD. */\n\tif (i < argc) {\n\t\tif (reset_type == MIXED)\n\t\t\twarning(\"--mixed with paths is deprecated; use 'git reset -- <paths>' instead.\");\n\t\telse if (reset_type != NONE)\n\t\t\tdie(\"Cannot do %s reset with paths.\",\n\t\t\t\t\treset_type_names[reset_type]);\n\t\treturn read_from_tree(prefix, argv + i, sha1,\n\t\t\t\tquiet ? REFRESH_QUIET : REFRESH_IN_PORCELAIN);\n\t}\n\tif (reset_type == NONE)\n\t\treset_type = MIXED; /* by default */\n\n\tif (reset_type != SOFT && reset_type != MIXED)\n\t\tsetup_work_tree();\n\n\tif (reset_type == MIXED && is_bare_repository())\n\t\tdie(\"%s reset is not allowed in a bare repository\",\n\t\t    reset_type_names[reset_type]);\n\n\t/* Soft reset does not touch the index file nor the working tree\n\t * at all, but requires them in a good order.  Other resets reset\n\t * the index file to the tree object we are switching to. */\n\tif (reset_type == SOFT)\n\t\tdie_if_unmerged_cache(reset_type);\n\telse {\n\t\tint err;\n\t\tif (reset_type == KEEP)\n\t\t\tdie_if_unmerged_cache(reset_type);\n\t\terr = reset_index_file(sha1, reset_type, quiet);\n\t\tif (reset_type == KEEP)\n\t\t\terr = err || reset_index_file(sha1, MIXED, quiet);\n\t\tif (err)\n\t\t\tdie(\"Could not reset index file to revision '%s'.\", rev);\n\t}\n\n\t/* Any resets update HEAD to the head being switched to,\n\t * saving the previous head in ORIG_HEAD before. */\n\tif (!get_sha1(\"ORIG_HEAD\", sha1_old_orig))\n\t\told_orig = sha1_old_orig;\n\tif (!get_sha1(\"HEAD\", sha1_orig)) {\n\t\torig = sha1_orig;\n\t\tprepend_reflog_action(\"updating ORIG_HEAD\", msg, sizeof(msg));\n\t\tupdate_ref(msg, \"ORIG_HEAD\", orig, old_orig, 0, MSG_ON_ERR);\n\t}\n\telse if (old_orig)\n\t\tdelete_ref(\"ORIG_HEAD\", old_orig, 0);\n\tprepend_reflog_action(\"updating HEAD\", msg, sizeof(msg));\n\tupdate_ref_status = update_ref(msg, \"HEAD\", sha1, orig, 0, MSG_ON_ERR);\n\n\tswitch (reset_type) {\n\tcase HARD:\n\t\tif (!update_ref_status && !quiet)\n\t\t\tprint_new_head_line(commit);\n\t\tbreak;\n\tcase SOFT: /* Nothing else to do. */\n\t\tbreak;\n\tcase MIXED: /* Report what has not been updated. */\n\t\tupdate_index_refresh(0, NULL,\n\t\t\t\tquiet ? REFRESH_QUIET : REFRESH_IN_PORCELAIN);\n\t\tbreak;\n\t}\n\n\tremove_branch_state();\n\n\tfree(reflog_action);\n\n\treturn update_ref_status;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0037be4693bbd875e644df13ce4a9fae31e7378c",
  "sha1_ok": true,
  "size": 10301
}
