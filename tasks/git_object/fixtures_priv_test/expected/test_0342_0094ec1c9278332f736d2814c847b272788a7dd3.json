{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAicGt0LWxpbmUuaCIKI2luY2x1ZGUgInV0ZjguaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgInJldmlzaW9uLmgiCiNpbmNsdWRlICJub3Rlcy5oIgoKaW50IHNhdmVfY29tbWl0X2J1ZmZlciA9IDE7Cgpjb25zdCBjaGFyICpjb21taXRfdHlwZSA9ICJjb21taXQiOwoKc3RhdGljIHN0cnVjdCBjb21taXQgKmNoZWNrX2NvbW1pdChzdHJ1Y3Qgb2JqZWN0ICpvYmosCgkJCQkgICBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCQkJICAgaW50IHF1aWV0KQp7CglpZiAob2JqLT50eXBlICE9IE9CSl9DT01NSVQpIHsKCQlpZiAoIXF1aWV0KQoJCQllcnJvcigiT2JqZWN0ICVzIGlzIGEgJXMsIG5vdCBhIGNvbW1pdCIsCgkJCSAgICAgIHNoYTFfdG9faGV4KHNoYTEpLCB0eXBlbmFtZShvYmotPnR5cGUpKTsKCQlyZXR1cm4gTlVMTDsKCX0KCXJldHVybiAoc3RydWN0IGNvbW1pdCAqKSBvYmo7Cn0KCnN0cnVjdCBjb21taXQgKmxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCQkJCSAgICAgIGludCBxdWlldCkKewoJc3RydWN0IG9iamVjdCAqb2JqID0gZGVyZWZfdGFnKHBhcnNlX29iamVjdChzaGExKSwgTlVMTCwgMCk7CgoJaWYgKCFvYmopCgkJcmV0dXJuIE5VTEw7CglyZXR1cm4gY2hlY2tfY29tbWl0KG9iaiwgc2hhMSwgcXVpZXQpOwp9CgpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0X3JlZmVyZW5jZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglyZXR1cm4gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfZ2VudGx5KHNoYTEsIDApOwp9CgpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXN0cnVjdCBvYmplY3QgKm9iaiA9IGxvb2t1cF9vYmplY3Qoc2hhMSk7CglpZiAoIW9iaikKCQlyZXR1cm4gY3JlYXRlX29iamVjdChzaGExLCBPQkpfQ09NTUlULCBhbGxvY19jb21taXRfbm9kZSgpKTsKCWlmICghb2JqLT50eXBlKQoJCW9iai0+dHlwZSA9IE9CSl9DT01NSVQ7CglyZXR1cm4gY2hlY2tfY29tbWl0KG9iaiwgc2hhMSwgMCk7Cn0KCnN0YXRpYyB1bnNpZ25lZCBsb25nIHBhcnNlX2NvbW1pdF9kYXRlKGNvbnN0IGNoYXIgKmJ1ZiwgY29uc3QgY2hhciAqdGFpbCkKewoJY29uc3QgY2hhciAqZGF0ZXB0cjsKCglpZiAoYnVmICsgNiA+PSB0YWlsKQoJCXJldHVybiAwOwoJaWYgKG1lbWNtcChidWYsICJhdXRob3IiLCA2KSkKCQlyZXR1cm4gMDsKCXdoaWxlIChidWYgPCB0YWlsICYmICpidWYrKyAhPSAnXG4nKQoJCS8qIG5hZGEgKi87CglpZiAoYnVmICsgOSA+PSB0YWlsKQoJCXJldHVybiAwOwoJaWYgKG1lbWNtcChidWYsICJjb21taXR0ZXIiLCA5KSkKCQlyZXR1cm4gMDsKCXdoaWxlIChidWYgPCB0YWlsICYmICpidWYrKyAhPSAnPicpCgkJLyogbmFkYSAqLzsKCWlmIChidWYgPj0gdGFpbCkKCQlyZXR1cm4gMDsKCWRhdGVwdHIgPSBidWY7Cgl3aGlsZSAoYnVmIDwgdGFpbCAmJiAqYnVmKysgIT0gJ1xuJykKCQkvKiBuYWRhICovOwoJaWYgKGJ1ZiA+PSB0YWlsKQoJCXJldHVybiAwOwoJLyogZGF0ZXB0ciA8IGJ1ZiAmJiBidWZbLTFdID09ICdcbicsIHNvIHN0cnRvdWwgd2lsbCBzdG9wIGF0IGJ1Zi0xICovCglyZXR1cm4gc3RydG91bChkYXRlcHRyLCBOVUxMLCAxMCk7Cn0KCnN0YXRpYyBzdHJ1Y3QgY29tbWl0X2dyYWZ0ICoqY29tbWl0X2dyYWZ0OwpzdGF0aWMgaW50IGNvbW1pdF9ncmFmdF9hbGxvYywgY29tbWl0X2dyYWZ0X25yOwoKc3RhdGljIGludCBjb21taXRfZ3JhZnRfcG9zKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCWludCBsbywgaGk7CglsbyA9IDA7CgloaSA9IGNvbW1pdF9ncmFmdF9ucjsKCXdoaWxlIChsbyA8IGhpKSB7CgkJaW50IG1pID0gKGxvICsgaGkpIC8gMjsKCQlzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpncmFmdCA9IGNvbW1pdF9ncmFmdFttaV07CgkJaW50IGNtcCA9IGhhc2hjbXAoc2hhMSwgZ3JhZnQtPnNoYTEpOwoJCWlmICghY21wKQoJCQlyZXR1cm4gbWk7CgkJaWYgKGNtcCA8IDApCgkJCWhpID0gbWk7CgkJZWxzZQoJCQlsbyA9IG1pICsgMTsKCX0KCXJldHVybiAtbG8gLSAxOwp9CgppbnQgcmVnaXN0ZXJfY29tbWl0X2dyYWZ0KHN0cnVjdCBjb21taXRfZ3JhZnQgKmdyYWZ0LCBpbnQgaWdub3JlX2R1cHMpCnsKCWludCBwb3MgPSBjb21taXRfZ3JhZnRfcG9zKGdyYWZ0LT5zaGExKTsKCglpZiAoMCA8PSBwb3MpIHsKCQlpZiAoaWdub3JlX2R1cHMpCgkJCWZyZWUoZ3JhZnQpOwoJCWVsc2UgewoJCQlmcmVlKGNvbW1pdF9ncmFmdFtwb3NdKTsKCQkJY29tbWl0X2dyYWZ0W3Bvc10gPSBncmFmdDsKCQl9CgkJcmV0dXJuIDE7Cgl9Cglwb3MgPSAtcG9zIC0gMTsKCWlmIChjb21taXRfZ3JhZnRfYWxsb2MgPD0gKytjb21taXRfZ3JhZnRfbnIpIHsKCQljb21taXRfZ3JhZnRfYWxsb2MgPSBhbGxvY19ucihjb21taXRfZ3JhZnRfYWxsb2MpOwoJCWNvbW1pdF9ncmFmdCA9IHhyZWFsbG9jKGNvbW1pdF9ncmFmdCwKCQkJCQlzaXplb2YoKmNvbW1pdF9ncmFmdCkgKgoJCQkJCWNvbW1pdF9ncmFmdF9hbGxvYyk7Cgl9CglpZiAocG9zIDwgY29tbWl0X2dyYWZ0X25yKQoJCW1lbW1vdmUoY29tbWl0X2dyYWZ0ICsgcG9zICsgMSwKCQkJY29tbWl0X2dyYWZ0ICsgcG9zLAoJCQkoY29tbWl0X2dyYWZ0X25yIC0gcG9zIC0gMSkgKgoJCQlzaXplb2YoKmNvbW1pdF9ncmFmdCkpOwoJY29tbWl0X2dyYWZ0W3Bvc10gPSBncmFmdDsKCXJldHVybiAwOwp9CgpzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpyZWFkX2dyYWZ0X2xpbmUoY2hhciAqYnVmLCBpbnQgbGVuKQp7CgkvKiBUaGUgZm9ybWF0IGlzIGp1c3QgIkNvbW1pdCBQYXJlbnQxIFBhcmVudDIgLi4uXG4iICovCglpbnQgaTsKCXN0cnVjdCBjb21taXRfZ3JhZnQgKmdyYWZ0ID0gTlVMTDsKCgl3aGlsZSAobGVuICYmIGlzc3BhY2UoYnVmW2xlbi0xXSkpCgkJYnVmWy0tbGVuXSA9ICdcMCc7CglpZiAoYnVmWzBdID09ICcjJyB8fCBidWZbMF0gPT0gJ1wwJykKCQlyZXR1cm4gTlVMTDsKCWlmICgobGVuICsgMSkgJSA0MSkgewoJYmFkX2dyYWZ0X2RhdGE6CgkJZXJyb3IoImJhZCBncmFmdCBkYXRhOiAlcyIsIGJ1Zik7CgkJZnJlZShncmFmdCk7CgkJcmV0dXJuIE5VTEw7Cgl9CglpID0gKGxlbiArIDEpIC8gNDEgLSAxOwoJZ3JhZnQgPSB4bWFsbG9jKHNpemVvZigqZ3JhZnQpICsgMjAgKiBpKTsKCWdyYWZ0LT5ucl9wYXJlbnQgPSBpOwoJaWYgKGdldF9zaGExX2hleChidWYsIGdyYWZ0LT5zaGExKSkKCQlnb3RvIGJhZF9ncmFmdF9kYXRhOwoJZm9yIChpID0gNDA7IGkgPCBsZW47IGkgKz0gNDEpIHsKCQlpZiAoYnVmW2ldICE9ICcgJykKCQkJZ290byBiYWRfZ3JhZnRfZGF0YTsKCQlpZiAoZ2V0X3NoYTFfaGV4KGJ1ZiArIGkgKyAxLCBncmFmdC0+cGFyZW50W2kvNDFdKSkKCQkJZ290byBiYWRfZ3JhZnRfZGF0YTsKCX0KCXJldHVybiBncmFmdDsKfQoKc3RhdGljIGludCByZWFkX2dyYWZ0X2ZpbGUoY29uc3QgY2hhciAqZ3JhZnRfZmlsZSkKewoJRklMRSAqZnAgPSBmb3BlbihncmFmdF9maWxlLCAiciIpOwoJY2hhciBidWZbMTAyNF07CglpZiAoIWZwKQoJCXJldHVybiAtMTsKCXdoaWxlIChmZ2V0cyhidWYsIHNpemVvZihidWYpLCBmcCkpIHsKCQkvKiBUaGUgZm9ybWF0IGlzIGp1c3QgIkNvbW1pdCBQYXJlbnQxIFBhcmVudDIgLi4uXG4iICovCgkJaW50IGxlbiA9IHN0cmxlbihidWYpOwoJCXN0cnVjdCBjb21taXRfZ3JhZnQgKmdyYWZ0ID0gcmVhZF9ncmFmdF9saW5lKGJ1ZiwgbGVuKTsKCQlpZiAoIWdyYWZ0KQoJCQljb250aW51ZTsKCQlpZiAocmVnaXN0ZXJfY29tbWl0X2dyYWZ0KGdyYWZ0LCAxKSkKCQkJZXJyb3IoImR1cGxpY2F0ZSBncmFmdCBkYXRhOiAlcyIsIGJ1Zik7Cgl9CglmY2xvc2UoZnApOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHByZXBhcmVfY29tbWl0X2dyYWZ0KHZvaWQpCnsKCXN0YXRpYyBpbnQgY29tbWl0X2dyYWZ0X3ByZXBhcmVkOwoJY2hhciAqZ3JhZnRfZmlsZTsKCglpZiAoY29tbWl0X2dyYWZ0X3ByZXBhcmVkKQoJCXJldHVybjsKCWdyYWZ0X2ZpbGUgPSBnZXRfZ3JhZnRfZmlsZSgpOwoJcmVhZF9ncmFmdF9maWxlKGdyYWZ0X2ZpbGUpOwoJLyogbWFrZSBzdXJlIHNoYWxsb3dzIGFyZSByZWFkICovCglpc19yZXBvc2l0b3J5X3NoYWxsb3coKTsKCWNvbW1pdF9ncmFmdF9wcmVwYXJlZCA9IDE7Cn0KCnN0cnVjdCBjb21taXRfZ3JhZnQgKmxvb2t1cF9jb21taXRfZ3JhZnQoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJaW50IHBvczsKCXByZXBhcmVfY29tbWl0X2dyYWZ0KCk7Cglwb3MgPSBjb21taXRfZ3JhZnRfcG9zKHNoYTEpOwoJaWYgKHBvcyA8IDApCgkJcmV0dXJuIE5VTEw7CglyZXR1cm4gY29tbWl0X2dyYWZ0W3Bvc107Cn0KCmludCB3cml0ZV9zaGFsbG93X2NvbW1pdHMoc3RydWN0IHN0cmJ1ZiAqb3V0LCBpbnQgdXNlX3BhY2tfcHJvdG9jb2wpCnsKCWludCBpLCBjb3VudCA9IDA7Cglmb3IgKGkgPSAwOyBpIDwgY29tbWl0X2dyYWZ0X25yOyBpKyspCgkJaWYgKGNvbW1pdF9ncmFmdFtpXS0+bnJfcGFyZW50IDwgMCkgewoJCQljb25zdCBjaGFyICpoZXggPQoJCQkJc2hhMV90b19oZXgoY29tbWl0X2dyYWZ0W2ldLT5zaGExKTsKCQkJY291bnQrKzsKCQkJaWYgKHVzZV9wYWNrX3Byb3RvY29sKQoJCQkJcGFja2V0X2J1Zl93cml0ZShvdXQsICJzaGFsbG93ICVzIiwgaGV4KTsKCQkJZWxzZSB7CgkJCQlzdHJidWZfYWRkc3RyKG91dCwgaGV4KTsKCQkJCXN0cmJ1Zl9hZGRjaChvdXQsICdcbicpOwoJCQl9CgkJfQoJcmV0dXJuIGNvdW50Owp9CgppbnQgdW5yZWdpc3Rlcl9zaGFsbG93KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCWludCBwb3MgPSBjb21taXRfZ3JhZnRfcG9zKHNoYTEpOwoJaWYgKHBvcyA8IDApCgkJcmV0dXJuIC0xOwoJaWYgKHBvcyArIDEgPCBjb21taXRfZ3JhZnRfbnIpCgkJbWVtbW92ZShjb21taXRfZ3JhZnQgKyBwb3MsIGNvbW1pdF9ncmFmdCArIHBvcyArIDEsCgkJCQlzaXplb2Yoc3RydWN0IGNvbW1pdF9ncmFmdCAqKQoJCQkJKiAoY29tbWl0X2dyYWZ0X25yIC0gcG9zIC0gMSkpOwoJY29tbWl0X2dyYWZ0X25yLS07CglyZXR1cm4gMDsKfQoKaW50IHBhcnNlX2NvbW1pdF9idWZmZXIoc3RydWN0IGNvbW1pdCAqaXRlbSwgdm9pZCAqYnVmZmVyLCB1bnNpZ25lZCBsb25nIHNpemUpCnsKCWNoYXIgKnRhaWwgPSBidWZmZXI7CgljaGFyICpidWZwdHIgPSBidWZmZXI7Cgl1bnNpZ25lZCBjaGFyIHBhcmVudFsyMF07CglzdHJ1Y3QgY29tbWl0X2xpc3QgKipwcHRyOwoJc3RydWN0IGNvbW1pdF9ncmFmdCAqZ3JhZnQ7CgoJaWYgKGl0ZW0tPm9iamVjdC5wYXJzZWQpCgkJcmV0dXJuIDA7CglpdGVtLT5vYmplY3QucGFyc2VkID0gMTsKCXRhaWwgKz0gc2l6ZTsKCWlmICh0YWlsIDw9IGJ1ZnB0ciArIDQ2IHx8IG1lbWNtcChidWZwdHIsICJ0cmVlICIsIDUpIHx8IGJ1ZnB0cls0NV0gIT0gJ1xuJykKCQlyZXR1cm4gZXJyb3IoImJvZ3VzIGNvbW1pdCBvYmplY3QgJXMiLCBzaGExX3RvX2hleChpdGVtLT5vYmplY3Quc2hhMSkpOwoJaWYgKGdldF9zaGExX2hleChidWZwdHIgKyA1LCBwYXJlbnQpIDwgMCkKCQlyZXR1cm4gZXJyb3IoImJhZCB0cmVlIHBvaW50ZXIgaW4gY29tbWl0ICVzIiwKCQkJICAgICBzaGExX3RvX2hleChpdGVtLT5vYmplY3Quc2hhMSkpOwoJaXRlbS0+dHJlZSA9IGxvb2t1cF90cmVlKHBhcmVudCk7CglidWZwdHIgKz0gNDY7IC8qICJ0cmVlICIgKyAiaGV4IHNoYTEiICsgIlxuIiAqLwoJcHB0ciA9ICZpdGVtLT5wYXJlbnRzOwoKCWdyYWZ0ID0gbG9va3VwX2NvbW1pdF9ncmFmdChpdGVtLT5vYmplY3Quc2hhMSk7Cgl3aGlsZSAoYnVmcHRyICsgNDggPCB0YWlsICYmICFtZW1jbXAoYnVmcHRyLCAicGFyZW50ICIsIDcpKSB7CgkJc3RydWN0IGNvbW1pdCAqbmV3X3BhcmVudDsKCgkJaWYgKHRhaWwgPD0gYnVmcHRyICsgNDggfHwKCQkgICAgZ2V0X3NoYTFfaGV4KGJ1ZnB0ciArIDcsIHBhcmVudCkgfHwKCQkgICAgYnVmcHRyWzQ3XSAhPSAnXG4nKQoJCQlyZXR1cm4gZXJyb3IoImJhZCBwYXJlbnRzIGluIGNvbW1pdCAlcyIsIHNoYTFfdG9faGV4KGl0ZW0tPm9iamVjdC5zaGExKSk7CgkJYnVmcHRyICs9IDQ4OwoJCS8qCgkJICogVGhlIGNsb25lIGlzIHNoYWxsb3cgaWYgbnJfcGFyZW50IDwgMCwgYW5kIHdlIG11c3QKCQkgKiBub3QgdHJhdmVyc2UgaXRzIHJlYWwgcGFyZW50cyBldmVuIHdoZW4gd2UgdW5oaWRlIHRoZW0uCgkJICovCgkJaWYgKGdyYWZ0ICYmIChncmFmdC0+bnJfcGFyZW50IDwgMCB8fCBncmFmdHNfcmVwbGFjZV9wYXJlbnRzKSkKCQkJY29udGludWU7CgkJbmV3X3BhcmVudCA9IGxvb2t1cF9jb21taXQocGFyZW50KTsKCQlpZiAobmV3X3BhcmVudCkKCQkJcHB0ciA9ICZjb21taXRfbGlzdF9pbnNlcnQobmV3X3BhcmVudCwgcHB0ciktPm5leHQ7Cgl9CglpZiAoZ3JhZnQpIHsKCQlpbnQgaTsKCQlzdHJ1Y3QgY29tbWl0ICpuZXdfcGFyZW50OwoJCWZvciAoaSA9IDA7IGkgPCBncmFmdC0+bnJfcGFyZW50OyBpKyspIHsKCQkJbmV3X3BhcmVudCA9IGxvb2t1cF9jb21taXQoZ3JhZnQtPnBhcmVudFtpXSk7CgkJCWlmICghbmV3X3BhcmVudCkKCQkJCWNvbnRpbnVlOwoJCQlwcHRyID0gJmNvbW1pdF9saXN0X2luc2VydChuZXdfcGFyZW50LCBwcHRyKS0+bmV4dDsKCQl9Cgl9CglpdGVtLT5kYXRlID0gcGFyc2VfY29tbWl0X2RhdGUoYnVmcHRyLCB0YWlsKTsKCglyZXR1cm4gMDsKfQoKaW50IHBhcnNlX2NvbW1pdChzdHJ1Y3QgY29tbWl0ICppdGVtKQp7CgllbnVtIG9iamVjdF90eXBlIHR5cGU7Cgl2b2lkICpidWZmZXI7Cgl1bnNpZ25lZCBsb25nIHNpemU7CglpbnQgcmV0OwoKCWlmICghaXRlbSkKCQlyZXR1cm4gLTE7CglpZiAoaXRlbS0+b2JqZWN0LnBhcnNlZCkKCQlyZXR1cm4gMDsKCWJ1ZmZlciA9IHJlYWRfc2hhMV9maWxlKGl0ZW0tPm9iamVjdC5zaGExLCAmdHlwZSwgJnNpemUpOwoJaWYgKCFidWZmZXIpCgkJcmV0dXJuIGVycm9yKCJDb3VsZCBub3QgcmVhZCAlcyIsCgkJCSAgICAgc2hhMV90b19oZXgoaXRlbS0+b2JqZWN0LnNoYTEpKTsKCWlmICh0eXBlICE9IE9CSl9DT01NSVQpIHsKCQlmcmVlKGJ1ZmZlcik7CgkJcmV0dXJuIGVycm9yKCJPYmplY3QgJXMgbm90IGEgY29tbWl0IiwKCQkJICAgICBzaGExX3RvX2hleChpdGVtLT5vYmplY3Quc2hhMSkpOwoJfQoJcmV0ID0gcGFyc2VfY29tbWl0X2J1ZmZlcihpdGVtLCBidWZmZXIsIHNpemUpOwoJaWYgKHNhdmVfY29tbWl0X2J1ZmZlciAmJiAhcmV0KSB7CgkJaXRlbS0+YnVmZmVyID0gYnVmZmVyOwoJCXJldHVybiAwOwoJfQoJZnJlZShidWZmZXIpOwoJcmV0dXJuIHJldDsKfQoKaW50IGZpbmRfY29tbWl0X3N1YmplY3QoY29uc3QgY2hhciAqY29tbWl0X2J1ZmZlciwgY29uc3QgY2hhciAqKnN1YmplY3QpCnsKCWNvbnN0IGNoYXIgKmVvbDsKCWNvbnN0IGNoYXIgKnAgPSBjb21taXRfYnVmZmVyOwoKCXdoaWxlICgqcCAmJiAoKnAgIT0gJ1xuJyB8fCBwWzFdICE9ICdcbicpKQoJCXArKzsKCWlmICgqcCkgewoJCXAgKz0gMjsKCQlmb3IgKGVvbCA9IHA7ICplb2wgJiYgKmVvbCAhPSAnXG4nOyBlb2wrKykKCQkJOyAvKiBkbyBub3RoaW5nICovCgl9IGVsc2UKCQllb2wgPSBwOwoKCSpzdWJqZWN0ID0gcDsKCglyZXR1cm4gZW9sIC0gcDsKfQoKc3RydWN0IGNvbW1pdF9saXN0ICpjb21taXRfbGlzdF9pbnNlcnQoc3RydWN0IGNvbW1pdCAqaXRlbSwgc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdF9wKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKm5ld19saXN0ID0geG1hbGxvYyhzaXplb2Yoc3RydWN0IGNvbW1pdF9saXN0KSk7CgluZXdfbGlzdC0+aXRlbSA9IGl0ZW07CgluZXdfbGlzdC0+bmV4dCA9ICpsaXN0X3A7CgkqbGlzdF9wID0gbmV3X2xpc3Q7CglyZXR1cm4gbmV3X2xpc3Q7Cn0KCnVuc2lnbmVkIGNvbW1pdF9saXN0X2NvdW50KGNvbnN0IHN0cnVjdCBjb21taXRfbGlzdCAqbCkKewoJdW5zaWduZWQgYyA9IDA7Cglmb3IgKDsgbDsgbCA9IGwtPm5leHQgKQoJCWMrKzsKCXJldHVybiBjOwp9Cgp2b2lkIGZyZWVfY29tbWl0X2xpc3Qoc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0KQp7Cgl3aGlsZSAobGlzdCkgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqdGVtcCA9IGxpc3Q7CgkJbGlzdCA9IHRlbXAtPm5leHQ7CgkJZnJlZSh0ZW1wKTsKCX0KfQoKc3RydWN0IGNvbW1pdF9saXN0ICogaW5zZXJ0X2J5X2RhdGUoc3RydWN0IGNvbW1pdCAqaXRlbSwgc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICoqcHAgPSBsaXN0OwoJc3RydWN0IGNvbW1pdF9saXN0ICpwOwoJd2hpbGUgKChwID0gKnBwKSAhPSBOVUxMKSB7CgkJaWYgKHAtPml0ZW0tPmRhdGUgPCBpdGVtLT5kYXRlKSB7CgkJCWJyZWFrOwoJCX0KCQlwcCA9ICZwLT5uZXh0OwoJfQoJcmV0dXJuIGNvbW1pdF9saXN0X2luc2VydChpdGVtLCBwcCk7Cn0KCgp2b2lkIHNvcnRfYnlfZGF0ZShzdHJ1Y3QgY29tbWl0X2xpc3QgKipsaXN0KQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnJldCA9IE5VTEw7Cgl3aGlsZSAoKmxpc3QpIHsKCQlpbnNlcnRfYnlfZGF0ZSgoKmxpc3QpLT5pdGVtLCAmcmV0KTsKCQkqbGlzdCA9ICgqbGlzdCktPm5leHQ7Cgl9CgkqbGlzdCA9IHJldDsKfQoKc3RydWN0IGNvbW1pdCAqcG9wX21vc3RfcmVjZW50X2NvbW1pdChzdHJ1Y3QgY29tbWl0X2xpc3QgKipsaXN0LAoJCQkJICAgICAgdW5zaWduZWQgaW50IG1hcmspCnsKCXN0cnVjdCBjb21taXQgKnJldCA9ICgqbGlzdCktPml0ZW07CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMgPSByZXQtPnBhcmVudHM7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKm9sZCA9ICpsaXN0OwoKCSpsaXN0ID0gKCpsaXN0KS0+bmV4dDsKCWZyZWUob2xkKTsKCgl3aGlsZSAocGFyZW50cykgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IHBhcmVudHMtPml0ZW07CgkJaWYgKCFwYXJzZV9jb21taXQoY29tbWl0KSAmJiAhKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgbWFyaykpIHsKCQkJY29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gbWFyazsKCQkJaW5zZXJ0X2J5X2RhdGUoY29tbWl0LCBsaXN0KTsKCQl9CgkJcGFyZW50cyA9IHBhcmVudHMtPm5leHQ7Cgl9CglyZXR1cm4gcmV0Owp9Cgp2b2lkIGNsZWFyX2NvbW1pdF9tYXJrcyhzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHVuc2lnbmVkIGludCBtYXJrKQp7Cgl3aGlsZSAoY29tbWl0KSB7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzOwoKCQlpZiAoIShtYXJrICYgY29tbWl0LT5vYmplY3QuZmxhZ3MpKQoJCQlyZXR1cm47CgoJCWNvbW1pdC0+b2JqZWN0LmZsYWdzICY9IH5tYXJrOwoKCQlwYXJlbnRzID0gY29tbWl0LT5wYXJlbnRzOwoJCWlmICghcGFyZW50cykKCQkJcmV0dXJuOwoKCQl3aGlsZSAoKHBhcmVudHMgPSBwYXJlbnRzLT5uZXh0KSkKCQkJY2xlYXJfY29tbWl0X21hcmtzKHBhcmVudHMtPml0ZW0sIG1hcmspOwoKCQljb21taXQgPSBjb21taXQtPnBhcmVudHMtPml0ZW07Cgl9Cn0KCnN0cnVjdCBjb21taXQgKnBvcF9jb21taXQoc3RydWN0IGNvbW1pdF9saXN0ICoqc3RhY2spCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqdG9wID0gKnN0YWNrOwoJc3RydWN0IGNvbW1pdCAqaXRlbSA9IHRvcCA/IHRvcC0+aXRlbSA6IE5VTEw7CgoJaWYgKHRvcCkgewoJCSpzdGFjayA9IHRvcC0+bmV4dDsKCQlmcmVlKHRvcCk7Cgl9CglyZXR1cm4gaXRlbTsKfQoKLyoKICogUGVyZm9ybXMgYW4gaW4tcGxhY2UgdG9wb2xvZ2ljYWwgc29ydCBvbiB0aGUgbGlzdCBzdXBwbGllZC4KICovCnZvaWQgc29ydF9pbl90b3BvbG9naWNhbF9vcmRlcihzdHJ1Y3QgY29tbWl0X2xpc3QgKiogbGlzdCwgaW50IGxpZm8pCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqbmV4dCwgKm9yaWcgPSAqbGlzdDsKCXN0cnVjdCBjb21taXRfbGlzdCAqd29yaywgKippbnNlcnQ7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKipwcHRyOwoKCWlmICghb3JpZykKCQlyZXR1cm47CgkqbGlzdCA9IE5VTEw7CgoJLyogTWFyayB0aGVtIGFuZCBjbGVhciB0aGUgaW5kZWdyZWUgKi8KCWZvciAobmV4dCA9IG9yaWc7IG5leHQ7IG5leHQgPSBuZXh0LT5uZXh0KSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gbmV4dC0+aXRlbTsKCQljb21taXQtPmluZGVncmVlID0gMTsKCX0KCgkvKiB1cGRhdGUgdGhlIGluZGVncmVlICovCglmb3IgKG5leHQgPSBvcmlnOyBuZXh0OyBuZXh0ID0gbmV4dC0+bmV4dCkgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqIHBhcmVudHMgPSBuZXh0LT5pdGVtLT5wYXJlbnRzOwoJCXdoaWxlIChwYXJlbnRzKSB7CgkJCXN0cnVjdCBjb21taXQgKnBhcmVudCA9IHBhcmVudHMtPml0ZW07CgoJCQlpZiAocGFyZW50LT5pbmRlZ3JlZSkKCQkJCXBhcmVudC0+aW5kZWdyZWUrKzsKCQkJcGFyZW50cyA9IHBhcmVudHMtPm5leHQ7CgkJfQoJfQoKCS8qCgkgKiBmaW5kIHRoZSB0aXBzCgkgKgoJICogdGlwcyBhcmUgbm9kZXMgbm90IHJlYWNoYWJsZSBmcm9tIGFueSBvdGhlciBub2RlIGluIHRoZSBsaXN0CgkgKgoJICogdGhlIHRpcHMgc2VydmUgYXMgYSBzdGFydGluZyBzZXQgZm9yIHRoZSB3b3JrIHF1ZXVlLgoJICovCgl3b3JrID0gTlVMTDsKCWluc2VydCA9ICZ3b3JrOwoJZm9yIChuZXh0ID0gb3JpZzsgbmV4dDsgbmV4dCA9IG5leHQtPm5leHQpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBuZXh0LT5pdGVtOwoKCQlpZiAoY29tbWl0LT5pbmRlZ3JlZSA9PSAxKQoJCQlpbnNlcnQgPSAmY29tbWl0X2xpc3RfaW5zZXJ0KGNvbW1pdCwgaW5zZXJ0KS0+bmV4dDsKCX0KCgkvKiBwcm9jZXNzIHRoZSBsaXN0IGluIHRvcG9sb2dpY2FsIG9yZGVyICovCglpZiAoIWxpZm8pCgkJc29ydF9ieV9kYXRlKCZ3b3JrKTsKCglwcHRyID0gbGlzdDsKCSpsaXN0ID0gTlVMTDsKCXdoaWxlICh3b3JrKSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50cywgKndvcmtfaXRlbTsKCgkJd29ya19pdGVtID0gd29yazsKCQl3b3JrID0gd29ya19pdGVtLT5uZXh0OwoJCXdvcmtfaXRlbS0+bmV4dCA9IE5VTEw7CgoJCWNvbW1pdCA9IHdvcmtfaXRlbS0+aXRlbTsKCQlmb3IgKHBhcmVudHMgPSBjb21taXQtPnBhcmVudHM7IHBhcmVudHMgOyBwYXJlbnRzID0gcGFyZW50cy0+bmV4dCkgewoJCQlzdHJ1Y3QgY29tbWl0ICpwYXJlbnQ9cGFyZW50cy0+aXRlbTsKCgkJCWlmICghcGFyZW50LT5pbmRlZ3JlZSkKCQkJCWNvbnRpbnVlOwoKCQkJLyoKCQkJICogcGFyZW50cyBhcmUgb25seSBlbnF1ZXVlZCBmb3IgZW1pc3Npb24KCQkJICogd2hlbiBhbGwgdGhlaXIgY2hpbGRyZW4gaGF2ZSBiZWVuIGVtaXR0ZWQgdGhlcmVieQoJCQkgKiBndWFyYW50ZWVpbmcgdG9wb2xvZ2ljYWwgb3JkZXIuCgkJCSAqLwoJCQlpZiAoLS1wYXJlbnQtPmluZGVncmVlID09IDEpIHsKCQkJCWlmICghbGlmbykKCQkJCQlpbnNlcnRfYnlfZGF0ZShwYXJlbnQsICZ3b3JrKTsKCQkJCWVsc2UKCQkJCQljb21taXRfbGlzdF9pbnNlcnQocGFyZW50LCAmd29yayk7CgkJCX0KCQl9CgkJLyoKCQkgKiB3b3JrX2l0ZW0gaXMgYSBjb21taXQgYWxsIG9mIHdob3NlIGNoaWxkcmVuCgkJICogaGF2ZSBhbHJlYWR5IGJlZW4gZW1pdHRlZC4gd2UgY2FuIGVtaXQgaXQgbm93LgoJCSAqLwoJCWNvbW1pdC0+aW5kZWdyZWUgPSAwOwoJCSpwcHRyID0gd29ya19pdGVtOwoJCXBwdHIgPSAmd29ya19pdGVtLT5uZXh0OwoJfQp9CgovKiBtZXJnZS1iYXNlIHN0dWZmICovCgovKiBiaXRzICMwLi4xNSBpbiByZXZpc2lvbi5oICovCiNkZWZpbmUgUEFSRU5UMQkJKDF1PDwxNikKI2RlZmluZSBQQVJFTlQyCQkoMXU8PDE3KQojZGVmaW5lIFNUQUxFCQkoMXU8PDE4KQojZGVmaW5lIFJFU1VMVAkJKDF1PDwxOSkKCnN0YXRpYyBjb25zdCB1bnNpZ25lZCBhbGxfZmxhZ3MgPSAoUEFSRU5UMSB8IFBBUkVOVDIgfCBTVEFMRSB8IFJFU1VMVCk7CgpzdGF0aWMgc3RydWN0IGNvbW1pdCAqaW50ZXJlc3Rpbmcoc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0KQp7Cgl3aGlsZSAobGlzdCkgewoJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IGxpc3QtPml0ZW07CgkJbGlzdCA9IGxpc3QtPm5leHQ7CgkJaWYgKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgU1RBTEUpCgkJCWNvbnRpbnVlOwoJCXJldHVybiBjb21taXQ7Cgl9CglyZXR1cm4gTlVMTDsKfQoKc3RhdGljIHN0cnVjdCBjb21taXRfbGlzdCAqbWVyZ2VfYmFzZXNfbWFueShzdHJ1Y3QgY29tbWl0ICpvbmUsIGludCBuLCBzdHJ1Y3QgY29tbWl0ICoqdHdvcykKewoJc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0ID0gTlVMTDsKCXN0cnVjdCBjb21taXRfbGlzdCAqcmVzdWx0ID0gTlVMTDsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHsKCQlpZiAob25lID09IHR3b3NbaV0pCgkJCS8qCgkJCSAqIFdlIGRvIG5vdCBtYXJrIHRoaXMgZXZlbiB3aXRoIFJFU1VMVCBzbyB3ZSBkbyBub3QKCQkJICogaGF2ZSB0byBjbGVhbiBpdCB1cC4KCQkJICovCgkJCXJldHVybiBjb21taXRfbGlzdF9pbnNlcnQob25lLCAmcmVzdWx0KTsKCX0KCglpZiAocGFyc2VfY29tbWl0KG9uZSkpCgkJcmV0dXJuIE5VTEw7Cglmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7CgkJaWYgKHBhcnNlX2NvbW1pdCh0d29zW2ldKSkKCQkJcmV0dXJuIE5VTEw7Cgl9CgoJb25lLT5vYmplY3QuZmxhZ3MgfD0gUEFSRU5UMTsKCWluc2VydF9ieV9kYXRlKG9uZSwgJmxpc3QpOwoJZm9yIChpID0gMDsgaSA8IG47IGkrKykgewoJCXR3b3NbaV0tPm9iamVjdC5mbGFncyB8PSBQQVJFTlQyOwoJCWluc2VydF9ieV9kYXRlKHR3b3NbaV0sICZsaXN0KTsKCX0KCgl3aGlsZSAoaW50ZXJlc3RpbmcobGlzdCkpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzOwoJCXN0cnVjdCBjb21taXRfbGlzdCAqbmV4dDsKCQlpbnQgZmxhZ3M7CgoJCWNvbW1pdCA9IGxpc3QtPml0ZW07CgkJbmV4dCA9IGxpc3QtPm5leHQ7CgkJZnJlZShsaXN0KTsKCQlsaXN0ID0gbmV4dDsKCgkJZmxhZ3MgPSBjb21taXQtPm9iamVjdC5mbGFncyAmIChQQVJFTlQxIHwgUEFSRU5UMiB8IFNUQUxFKTsKCQlpZiAoZmxhZ3MgPT0gKFBBUkVOVDEgfCBQQVJFTlQyKSkgewoJCQlpZiAoIShjb21taXQtPm9iamVjdC5mbGFncyAmIFJFU1VMVCkpIHsKCQkJCWNvbW1pdC0+b2JqZWN0LmZsYWdzIHw9IFJFU1VMVDsKCQkJCWluc2VydF9ieV9kYXRlKGNvbW1pdCwgJnJlc3VsdCk7CgkJCX0KCQkJLyogTWFyayBwYXJlbnRzIG9mIGEgZm91bmQgbWVyZ2Ugc3RhbGUgKi8KCQkJZmxhZ3MgfD0gU1RBTEU7CgkJfQoJCXBhcmVudHMgPSBjb21taXQtPnBhcmVudHM7CgkJd2hpbGUgKHBhcmVudHMpIHsKCQkJc3RydWN0IGNvbW1pdCAqcCA9IHBhcmVudHMtPml0ZW07CgkJCXBhcmVudHMgPSBwYXJlbnRzLT5uZXh0OwoJCQlpZiAoKHAtPm9iamVjdC5mbGFncyAmIGZsYWdzKSA9PSBmbGFncykKCQkJCWNvbnRpbnVlOwoJCQlpZiAocGFyc2VfY29tbWl0KHApKQoJCQkJcmV0dXJuIE5VTEw7CgkJCXAtPm9iamVjdC5mbGFncyB8PSBmbGFnczsKCQkJaW5zZXJ0X2J5X2RhdGUocCwgJmxpc3QpOwoJCX0KCX0KCgkvKiBDbGVhbiB1cCB0aGUgcmVzdWx0IHRvIHJlbW92ZSBzdGFsZSBvbmVzICovCglmcmVlX2NvbW1pdF9saXN0KGxpc3QpOwoJbGlzdCA9IHJlc3VsdDsgcmVzdWx0ID0gTlVMTDsKCXdoaWxlIChsaXN0KSB7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpuZXh0ID0gbGlzdC0+bmV4dDsKCQlpZiAoIShsaXN0LT5pdGVtLT5vYmplY3QuZmxhZ3MgJiBTVEFMRSkpCgkJCWluc2VydF9ieV9kYXRlKGxpc3QtPml0ZW0sICZyZXN1bHQpOwoJCWZyZWUobGlzdCk7CgkJbGlzdCA9IG5leHQ7Cgl9CglyZXR1cm4gcmVzdWx0Owp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9vY3RvcHVzX21lcmdlX2Jhc2VzKHN0cnVjdCBjb21taXRfbGlzdCAqaW4pCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqaSwgKmosICprLCAqcmV0ID0gTlVMTDsKCXN0cnVjdCBjb21taXRfbGlzdCAqKnBwdHIgPSAmcmV0OwoKCWZvciAoaSA9IGluOyBpOyBpID0gaS0+bmV4dCkgewoJCWlmICghcmV0KQoJCQlwcHRyID0gJmNvbW1pdF9saXN0X2luc2VydChpLT5pdGVtLCBwcHRyKS0+bmV4dDsKCQllbHNlIHsKCQkJc3RydWN0IGNvbW1pdF9saXN0ICpuZXcgPSBOVUxMLCAqZW5kID0gTlVMTDsKCgkJCWZvciAoaiA9IHJldDsgajsgaiA9IGotPm5leHQpIHsKCQkJCXN0cnVjdCBjb21taXRfbGlzdCAqYmFzZXM7CgkJCQliYXNlcyA9IGdldF9tZXJnZV9iYXNlcyhpLT5pdGVtLCBqLT5pdGVtLCAxKTsKCQkJCWlmICghbmV3KQoJCQkJCW5ldyA9IGJhc2VzOwoJCQkJZWxzZQoJCQkJCWVuZC0+bmV4dCA9IGJhc2VzOwoJCQkJZm9yIChrID0gYmFzZXM7IGs7IGsgPSBrLT5uZXh0KQoJCQkJCWVuZCA9IGs7CgkJCX0KCQkJcmV0ID0gbmV3OwoJCX0KCX0KCXJldHVybiByZXQ7Cn0KCnN0cnVjdCBjb21taXRfbGlzdCAqZ2V0X21lcmdlX2Jhc2VzX21hbnkoc3RydWN0IGNvbW1pdCAqb25lLAoJCQkJCSBpbnQgbiwKCQkJCQkgc3RydWN0IGNvbW1pdCAqKnR3b3MsCgkJCQkJIGludCBjbGVhbnVwKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3Q7CglzdHJ1Y3QgY29tbWl0ICoqcnNsdDsKCXN0cnVjdCBjb21taXRfbGlzdCAqcmVzdWx0OwoJaW50IGNudCwgaSwgajsKCglyZXN1bHQgPSBtZXJnZV9iYXNlc19tYW55KG9uZSwgbiwgdHdvcyk7Cglmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7CgkJaWYgKG9uZSA9PSB0d29zW2ldKQoJCQlyZXR1cm4gcmVzdWx0OwoJfQoJaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC0+bmV4dCkgewoJCWlmIChjbGVhbnVwKSB7CgkJCWNsZWFyX2NvbW1pdF9tYXJrcyhvbmUsIGFsbF9mbGFncyk7CgkJCWZvciAoaSA9IDA7IGkgPCBuOyBpKyspCgkJCQljbGVhcl9jb21taXRfbWFya3ModHdvc1tpXSwgYWxsX2ZsYWdzKTsKCQl9CgkJcmV0dXJuIHJlc3VsdDsKCX0KCgkvKiBUaGVyZSBhcmUgbW9yZSB0aGFuIG9uZSAqLwoJY250ID0gMDsKCWxpc3QgPSByZXN1bHQ7Cgl3aGlsZSAobGlzdCkgewoJCWxpc3QgPSBsaXN0LT5uZXh0OwoJCWNudCsrOwoJfQoJcnNsdCA9IHhjYWxsb2MoY250LCBzaXplb2YoKnJzbHQpKTsKCWZvciAobGlzdCA9IHJlc3VsdCwgaSA9IDA7IGxpc3Q7IGxpc3QgPSBsaXN0LT5uZXh0KQoJCXJzbHRbaSsrXSA9IGxpc3QtPml0ZW07CglmcmVlX2NvbW1pdF9saXN0KHJlc3VsdCk7CgoJY2xlYXJfY29tbWl0X21hcmtzKG9uZSwgYWxsX2ZsYWdzKTsKCWZvciAoaSA9IDA7IGkgPCBuOyBpKyspCgkJY2xlYXJfY29tbWl0X21hcmtzKHR3b3NbaV0sIGFsbF9mbGFncyk7Cglmb3IgKGkgPSAwOyBpIDwgY250IC0gMTsgaSsrKSB7CgkJZm9yIChqID0gaSsxOyBqIDwgY250OyBqKyspIHsKCQkJaWYgKCFyc2x0W2ldIHx8ICFyc2x0W2pdKQoJCQkJY29udGludWU7CgkJCXJlc3VsdCA9IG1lcmdlX2Jhc2VzX21hbnkocnNsdFtpXSwgMSwgJnJzbHRbal0pOwoJCQljbGVhcl9jb21taXRfbWFya3MocnNsdFtpXSwgYWxsX2ZsYWdzKTsKCQkJY2xlYXJfY29tbWl0X21hcmtzKHJzbHRbal0sIGFsbF9mbGFncyk7CgkJCWZvciAobGlzdCA9IHJlc3VsdDsgbGlzdDsgbGlzdCA9IGxpc3QtPm5leHQpIHsKCQkJCWlmIChyc2x0W2ldID09IGxpc3QtPml0ZW0pCgkJCQkJcnNsdFtpXSA9IE5VTEw7CgkJCQlpZiAocnNsdFtqXSA9PSBsaXN0LT5pdGVtKQoJCQkJCXJzbHRbal0gPSBOVUxMOwoJCQl9CgkJfQoJfQoKCS8qIFN1cnZpdmluZyBvbmVzIGluIHJzbHRbXSBhcmUgdGhlIGluZGVwZW5kZW50IHJlc3VsdHMgKi8KCXJlc3VsdCA9IE5VTEw7Cglmb3IgKGkgPSAwOyBpIDwgY250OyBpKyspIHsKCQlpZiAocnNsdFtpXSkKCQkJaW5zZXJ0X2J5X2RhdGUocnNsdFtpXSwgJnJlc3VsdCk7Cgl9CglmcmVlKHJzbHQpOwoJcmV0dXJuIHJlc3VsdDsKfQoKc3RydWN0IGNvbW1pdF9saXN0ICpnZXRfbWVyZ2VfYmFzZXMoc3RydWN0IGNvbW1pdCAqb25lLCBzdHJ1Y3QgY29tbWl0ICp0d28sCgkJCQkgICAgaW50IGNsZWFudXApCnsKCXJldHVybiBnZXRfbWVyZ2VfYmFzZXNfbWFueShvbmUsIDEsICZ0d28sIGNsZWFudXApOwp9CgppbnQgaXNfZGVzY2VuZGFudF9vZihzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHN0cnVjdCBjb21taXRfbGlzdCAqd2l0aF9jb21taXQpCnsKCWlmICghd2l0aF9jb21taXQpCgkJcmV0dXJuIDE7Cgl3aGlsZSAod2l0aF9jb21taXQpIHsKCQlzdHJ1Y3QgY29tbWl0ICpvdGhlcjsKCgkJb3RoZXIgPSB3aXRoX2NvbW1pdC0+aXRlbTsKCQl3aXRoX2NvbW1pdCA9IHdpdGhfY29tbWl0LT5uZXh0OwoJCWlmIChpbl9tZXJnZV9iYXNlcyhvdGhlciwgJmNvbW1pdCwgMSkpCgkJCXJldHVybiAxOwoJfQoJcmV0dXJuIDA7Cn0KCmludCBpbl9tZXJnZV9iYXNlcyhzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHN0cnVjdCBjb21taXQgKipyZWZlcmVuY2UsIGludCBudW0pCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqYmFzZXMsICpiOwoJaW50IHJldCA9IDA7CgoJaWYgKG51bSA9PSAxKQoJCWJhc2VzID0gZ2V0X21lcmdlX2Jhc2VzKGNvbW1pdCwgKnJlZmVyZW5jZSwgMSk7CgllbHNlCgkJZGllKCJub3QgeWV0Iik7Cglmb3IgKGIgPSBiYXNlczsgYjsgYiA9IGItPm5leHQpIHsKCQlpZiAoIWhhc2hjbXAoY29tbWl0LT5vYmplY3Quc2hhMSwgYi0+aXRlbS0+b2JqZWN0LnNoYTEpKSB7CgkJCXJldCA9IDE7CgkJCWJyZWFrOwoJCX0KCX0KCglmcmVlX2NvbW1pdF9saXN0KGJhc2VzKTsKCXJldHVybiByZXQ7Cn0KCnN0cnVjdCBjb21taXRfbGlzdCAqcmVkdWNlX2hlYWRzKHN0cnVjdCBjb21taXRfbGlzdCAqaGVhZHMpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqcDsKCXN0cnVjdCBjb21taXRfbGlzdCAqcmVzdWx0ID0gTlVMTCwgKip0YWlsID0gJnJlc3VsdDsKCXN0cnVjdCBjb21taXQgKipvdGhlcjsKCXNpemVfdCBudW1faGVhZCwgbnVtX290aGVyOwoKCWlmICghaGVhZHMpCgkJcmV0dXJuIE5VTEw7CgoJLyogQXZvaWQgdW5uZWNlc3NhcnkgcmVhbGxvY2F0aW9ucyAqLwoJZm9yIChwID0gaGVhZHMsIG51bV9oZWFkID0gMDsgcDsgcCA9IHAtPm5leHQpCgkJbnVtX2hlYWQrKzsKCW90aGVyID0geGNhbGxvYyhzaXplb2YoKm90aGVyKSwgbnVtX2hlYWQpOwoKCS8qIEZvciBlYWNoIGNvbW1pdCwgc2VlIGlmIGl0IGNhbiBiZSByZWFjaGVkIGJ5IG90aGVycyAqLwoJZm9yIChwID0gaGVhZHM7IHA7IHAgPSBwLT5uZXh0KSB7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpxLCAqYmFzZTsKCgkJLyogRG8gd2UgYWxyZWFkeSBoYXZlIHRoaXMgaW4gdGhlIHJlc3VsdD8gKi8KCQlmb3IgKHEgPSByZXN1bHQ7IHE7IHEgPSBxLT5uZXh0KQoJCQlpZiAocC0+aXRlbSA9PSBxLT5pdGVtKQoJCQkJYnJlYWs7CgkJaWYgKHEpCgkJCWNvbnRpbnVlOwoKCQludW1fb3RoZXIgPSAwOwoJCWZvciAocSA9IGhlYWRzOyBxOyBxID0gcS0+bmV4dCkgewoJCQlpZiAocC0+aXRlbSA9PSBxLT5pdGVtKQoJCQkJY29udGludWU7CgkJCW90aGVyW251bV9vdGhlcisrXSA9IHEtPml0ZW07CgkJfQoJCWlmIChudW1fb3RoZXIpCgkJCWJhc2UgPSBnZXRfbWVyZ2VfYmFzZXNfbWFueShwLT5pdGVtLCBudW1fb3RoZXIsIG90aGVyLCAxKTsKCQllbHNlCgkJCWJhc2UgPSBOVUxMOwoJCS8qCgkJICogSWYgcC0+aXRlbSBkb2VzIG5vdCBoYXZlIGFueXRoaW5nIGNvbW1vbiB3aXRoIG90aGVyCgkJICogY29tbWl0cywgdGhlcmUgd29uJ3QgYmUgYW55IG1lcmdlIGJhc2UuICBJZiBpdCBpcwoJCSAqIHJlYWNoYWJsZSBmcm9tIHNvbWUgb2YgdGhlIG90aGVycywgcC0+aXRlbSB3aWxsIGJlCgkJICogdGhlIG1lcmdlIGJhc2UuICBJZiBpdHMgaGlzdG9yeSBpcyBjb25uZWN0ZWQgd2l0aAoJCSAqIG90aGVycywgYnV0IHAtPml0ZW0gaXMgbm90IHJlYWNoYWJsZSBieSBvdGhlcnMsIHdlCgkJICogd2lsbCBnZXQgc29tZXRoaW5nIG90aGVyIHRoYW4gcC0+aXRlbSBiYWNrLgoJCSAqLwoJCWlmICghYmFzZSB8fCAoYmFzZS0+aXRlbSAhPSBwLT5pdGVtKSkKCQkJdGFpbCA9ICYoY29tbWl0X2xpc3RfaW5zZXJ0KHAtPml0ZW0sIHRhaWwpLT5uZXh0KTsKCQlmcmVlX2NvbW1pdF9saXN0KGJhc2UpOwoJfQoJZnJlZShvdGhlcik7CglyZXR1cm4gcmVzdWx0Owp9CgpzdGF0aWMgY29uc3QgY2hhciBjb21taXRfdXRmOF93YXJuW10gPQoiV2FybmluZzogY29tbWl0IG1lc3NhZ2UgZG9lcyBub3QgY29uZm9ybSB0byBVVEYtOC5cbiIKIllvdSBtYXkgd2FudCB0byBhbWVuZCBpdCBhZnRlciBmaXhpbmcgdGhlIG1lc3NhZ2UsIG9yIHNldCB0aGUgY29uZmlnXG4iCiJ2YXJpYWJsZSBpMThuLmNvbW1pdGVuY29kaW5nIHRvIHRoZSBlbmNvZGluZyB5b3VyIHByb2plY3QgdXNlcy5cbiI7CgppbnQgY29tbWl0X3RyZWUoY29uc3QgY2hhciAqbXNnLCB1bnNpZ25lZCBjaGFyICp0cmVlLAoJCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50cywgdW5zaWduZWQgY2hhciAqcmV0LAoJCWNvbnN0IGNoYXIgKmF1dGhvcikKewoJaW50IHJlc3VsdDsKCWludCBlbmNvZGluZ19pc191dGY4OwoJc3RydWN0IHN0cmJ1ZiBidWZmZXI7CgoJYXNzZXJ0X3NoYTFfdHlwZSh0cmVlLCBPQkpfVFJFRSk7CgoJLyogTm90IGhhdmluZyBpMThuLmNvbW1pdGVuY29kaW5nIGlzIHRoZSBzYW1lIGFzIGhhdmluZyB1dGYtOCAqLwoJZW5jb2RpbmdfaXNfdXRmOCA9IGlzX2VuY29kaW5nX3V0ZjgoZ2l0X2NvbW1pdF9lbmNvZGluZyk7CgoJc3RyYnVmX2luaXQoJmJ1ZmZlciwgODE5Mik7IC8qIHNob3VsZCBhdm9pZCByZWFsbG9jcyBmb3IgdGhlIGhlYWRlcnMgKi8KCXN0cmJ1Zl9hZGRmKCZidWZmZXIsICJ0cmVlICVzXG4iLCBzaGExX3RvX2hleCh0cmVlKSk7CgoJLyoKCSAqIE5PVEUhIFRoaXMgb3JkZXJpbmcgbWVhbnMgdGhhdCB0aGUgc2FtZSBleGFjdCB0cmVlIG1lcmdlZCB3aXRoIGEKCSAqIGRpZmZlcmVudCBvcmRlciBvZiBwYXJlbnRzIHdpbGwgYmUgYSBfZGlmZmVyZW50XyBjaGFuZ2VzZXQgZXZlbgoJICogaWYgZXZlcnl0aGluZyBlbHNlIHN0YXlzIHRoZSBzYW1lLgoJICovCgl3aGlsZSAocGFyZW50cykgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqbmV4dCA9IHBhcmVudHMtPm5leHQ7CgkJc3RyYnVmX2FkZGYoJmJ1ZmZlciwgInBhcmVudCAlc1xuIiwKCQkJc2hhMV90b19oZXgocGFyZW50cy0+aXRlbS0+b2JqZWN0LnNoYTEpKTsKCQlmcmVlKHBhcmVudHMpOwoJCXBhcmVudHMgPSBuZXh0OwoJfQoKCS8qIFBlcnNvbi9kYXRlIGluZm9ybWF0aW9uICovCglpZiAoIWF1dGhvcikKCQlhdXRob3IgPSBnaXRfYXV0aG9yX2luZm8oSURFTlRfRVJST1JfT05fTk9fTkFNRSk7CglzdHJidWZfYWRkZigmYnVmZmVyLCAiYXV0aG9yICVzXG4iLCBhdXRob3IpOwoJc3RyYnVmX2FkZGYoJmJ1ZmZlciwgImNvbW1pdHRlciAlc1xuIiwgZ2l0X2NvbW1pdHRlcl9pbmZvKElERU5UX0VSUk9SX09OX05PX05BTUUpKTsKCWlmICghZW5jb2RpbmdfaXNfdXRmOCkKCQlzdHJidWZfYWRkZigmYnVmZmVyLCAiZW5jb2RpbmcgJXNcbiIsIGdpdF9jb21taXRfZW5jb2RpbmcpOwoJc3RyYnVmX2FkZGNoKCZidWZmZXIsICdcbicpOwoKCS8qIEFuZCBhZGQgdGhlIGNvbW1lbnQgKi8KCXN0cmJ1Zl9hZGRzdHIoJmJ1ZmZlciwgbXNnKTsKCgkvKiBBbmQgY2hlY2sgdGhlIGVuY29kaW5nICovCglpZiAoZW5jb2RpbmdfaXNfdXRmOCAmJiAhaXNfdXRmOChidWZmZXIuYnVmKSkKCQlmcHJpbnRmKHN0ZGVyciwgY29tbWl0X3V0Zjhfd2Fybik7CgoJcmVzdWx0ID0gd3JpdGVfc2hhMV9maWxlKGJ1ZmZlci5idWYsIGJ1ZmZlci5sZW4sIGNvbW1pdF90eXBlLCByZXQpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1ZmZlcik7CglyZXR1cm4gcmVzdWx0Owp9Cg==",
    "text": "#include \"cache.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"pkt-line.h\"\n#include \"utf8.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"notes.h\"\n\nint save_commit_buffer = 1;\n\nconst char *commit_type = \"commit\";\n\nstatic struct commit *check_commit(struct object *obj,\n\t\t\t\t   const unsigned char *sha1,\n\t\t\t\t   int quiet)\n{\n\tif (obj->type != OBJ_COMMIT) {\n\t\tif (!quiet)\n\t\t\terror(\"Object %s is a %s, not a commit\",\n\t\t\t      sha1_to_hex(sha1), typename(obj->type));\n\t\treturn NULL;\n\t}\n\treturn (struct commit *) obj;\n}\n\nstruct commit *lookup_commit_reference_gently(const unsigned char *sha1,\n\t\t\t\t\t      int quiet)\n{\n\tstruct object *obj = deref_tag(parse_object(sha1), NULL, 0);\n\n\tif (!obj)\n\t\treturn NULL;\n\treturn check_commit(obj, sha1, quiet);\n}\n\nstruct commit *lookup_commit_reference(const unsigned char *sha1)\n{\n\treturn lookup_commit_reference_gently(sha1, 0);\n}\n\nstruct commit *lookup_commit(const unsigned char *sha1)\n{\n\tstruct object *obj = lookup_object(sha1);\n\tif (!obj)\n\t\treturn create_object(sha1, OBJ_COMMIT, alloc_commit_node());\n\tif (!obj->type)\n\t\tobj->type = OBJ_COMMIT;\n\treturn check_commit(obj, sha1, 0);\n}\n\nstatic unsigned long parse_commit_date(const char *buf, const char *tail)\n{\n\tconst char *dateptr;\n\n\tif (buf + 6 >= tail)\n\t\treturn 0;\n\tif (memcmp(buf, \"author\", 6))\n\t\treturn 0;\n\twhile (buf < tail && *buf++ != '\\n')\n\t\t/* nada */;\n\tif (buf + 9 >= tail)\n\t\treturn 0;\n\tif (memcmp(buf, \"committer\", 9))\n\t\treturn 0;\n\twhile (buf < tail && *buf++ != '>')\n\t\t/* nada */;\n\tif (buf >= tail)\n\t\treturn 0;\n\tdateptr = buf;\n\twhile (buf < tail && *buf++ != '\\n')\n\t\t/* nada */;\n\tif (buf >= tail)\n\t\treturn 0;\n\t/* dateptr < buf && buf[-1] == '\\n', so strtoul will stop at buf-1 */\n\treturn strtoul(dateptr, NULL, 10);\n}\n\nstatic struct commit_graft **commit_graft;\nstatic int commit_graft_alloc, commit_graft_nr;\n\nstatic int commit_graft_pos(const unsigned char *sha1)\n{\n\tint lo, hi;\n\tlo = 0;\n\thi = commit_graft_nr;\n\twhile (lo < hi) {\n\t\tint mi = (lo + hi) / 2;\n\t\tstruct commit_graft *graft = commit_graft[mi];\n\t\tint cmp = hashcmp(sha1, graft->sha1);\n\t\tif (!cmp)\n\t\t\treturn mi;\n\t\tif (cmp < 0)\n\t\t\thi = mi;\n\t\telse\n\t\t\tlo = mi + 1;\n\t}\n\treturn -lo - 1;\n}\n\nint register_commit_graft(struct commit_graft *graft, int ignore_dups)\n{\n\tint pos = commit_graft_pos(graft->sha1);\n\n\tif (0 <= pos) {\n\t\tif (ignore_dups)\n\t\t\tfree(graft);\n\t\telse {\n\t\t\tfree(commit_graft[pos]);\n\t\t\tcommit_graft[pos] = graft;\n\t\t}\n\t\treturn 1;\n\t}\n\tpos = -pos - 1;\n\tif (commit_graft_alloc <= ++commit_graft_nr) {\n\t\tcommit_graft_alloc = alloc_nr(commit_graft_alloc);\n\t\tcommit_graft = xrealloc(commit_graft,\n\t\t\t\t\tsizeof(*commit_graft) *\n\t\t\t\t\tcommit_graft_alloc);\n\t}\n\tif (pos < commit_graft_nr)\n\t\tmemmove(commit_graft + pos + 1,\n\t\t\tcommit_graft + pos,\n\t\t\t(commit_graft_nr - pos - 1) *\n\t\t\tsizeof(*commit_graft));\n\tcommit_graft[pos] = graft;\n\treturn 0;\n}\n\nstruct commit_graft *read_graft_line(char *buf, int len)\n{\n\t/* The format is just \"Commit Parent1 Parent2 ...\\n\" */\n\tint i;\n\tstruct commit_graft *graft = NULL;\n\n\twhile (len && isspace(buf[len-1]))\n\t\tbuf[--len] = '\\0';\n\tif (buf[0] == '#' || buf[0] == '\\0')\n\t\treturn NULL;\n\tif ((len + 1) % 41) {\n\tbad_graft_data:\n\t\terror(\"bad graft data: %s\", buf);\n\t\tfree(graft);\n\t\treturn NULL;\n\t}\n\ti = (len + 1) / 41 - 1;\n\tgraft = xmalloc(sizeof(*graft) + 20 * i);\n\tgraft->nr_parent = i;\n\tif (get_sha1_hex(buf, graft->sha1))\n\t\tgoto bad_graft_data;\n\tfor (i = 40; i < len; i += 41) {\n\t\tif (buf[i] != ' ')\n\t\t\tgoto bad_graft_data;\n\t\tif (get_sha1_hex(buf + i + 1, graft->parent[i/41]))\n\t\t\tgoto bad_graft_data;\n\t}\n\treturn graft;\n}\n\nstatic int read_graft_file(const char *graft_file)\n{\n\tFILE *fp = fopen(graft_file, \"r\");\n\tchar buf[1024];\n\tif (!fp)\n\t\treturn -1;\n\twhile (fgets(buf, sizeof(buf), fp)) {\n\t\t/* The format is just \"Commit Parent1 Parent2 ...\\n\" */\n\t\tint len = strlen(buf);\n\t\tstruct commit_graft *graft = read_graft_line(buf, len);\n\t\tif (!graft)\n\t\t\tcontinue;\n\t\tif (register_commit_graft(graft, 1))\n\t\t\terror(\"duplicate graft data: %s\", buf);\n\t}\n\tfclose(fp);\n\treturn 0;\n}\n\nstatic void prepare_commit_graft(void)\n{\n\tstatic int commit_graft_prepared;\n\tchar *graft_file;\n\n\tif (commit_graft_prepared)\n\t\treturn;\n\tgraft_file = get_graft_file();\n\tread_graft_file(graft_file);\n\t/* make sure shallows are read */\n\tis_repository_shallow();\n\tcommit_graft_prepared = 1;\n}\n\nstruct commit_graft *lookup_commit_graft(const unsigned char *sha1)\n{\n\tint pos;\n\tprepare_commit_graft();\n\tpos = commit_graft_pos(sha1);\n\tif (pos < 0)\n\t\treturn NULL;\n\treturn commit_graft[pos];\n}\n\nint write_shallow_commits(struct strbuf *out, int use_pack_protocol)\n{\n\tint i, count = 0;\n\tfor (i = 0; i < commit_graft_nr; i++)\n\t\tif (commit_graft[i]->nr_parent < 0) {\n\t\t\tconst char *hex =\n\t\t\t\tsha1_to_hex(commit_graft[i]->sha1);\n\t\t\tcount++;\n\t\t\tif (use_pack_protocol)\n\t\t\t\tpacket_buf_write(out, \"shallow %s\", hex);\n\t\t\telse {\n\t\t\t\tstrbuf_addstr(out, hex);\n\t\t\t\tstrbuf_addch(out, '\\n');\n\t\t\t}\n\t\t}\n\treturn count;\n}\n\nint unregister_shallow(const unsigned char *sha1)\n{\n\tint pos = commit_graft_pos(sha1);\n\tif (pos < 0)\n\t\treturn -1;\n\tif (pos + 1 < commit_graft_nr)\n\t\tmemmove(commit_graft + pos, commit_graft + pos + 1,\n\t\t\t\tsizeof(struct commit_graft *)\n\t\t\t\t* (commit_graft_nr - pos - 1));\n\tcommit_graft_nr--;\n\treturn 0;\n}\n\nint parse_commit_buffer(struct commit *item, void *buffer, unsigned long size)\n{\n\tchar *tail = buffer;\n\tchar *bufptr = buffer;\n\tunsigned char parent[20];\n\tstruct commit_list **pptr;\n\tstruct commit_graft *graft;\n\n\tif (item->object.parsed)\n\t\treturn 0;\n\titem->object.parsed = 1;\n\ttail += size;\n\tif (tail <= bufptr + 46 || memcmp(bufptr, \"tree \", 5) || bufptr[45] != '\\n')\n\t\treturn error(\"bogus commit object %s\", sha1_to_hex(item->object.sha1));\n\tif (get_sha1_hex(bufptr + 5, parent) < 0)\n\t\treturn error(\"bad tree pointer in commit %s\",\n\t\t\t     sha1_to_hex(item->object.sha1));\n\titem->tree = lookup_tree(parent);\n\tbufptr += 46; /* \"tree \" + \"hex sha1\" + \"\\n\" */\n\tpptr = &item->parents;\n\n\tgraft = lookup_commit_graft(item->object.sha1);\n\twhile (bufptr + 48 < tail && !memcmp(bufptr, \"parent \", 7)) {\n\t\tstruct commit *new_parent;\n\n\t\tif (tail <= bufptr + 48 ||\n\t\t    get_sha1_hex(bufptr + 7, parent) ||\n\t\t    bufptr[47] != '\\n')\n\t\t\treturn error(\"bad parents in commit %s\", sha1_to_hex(item->object.sha1));\n\t\tbufptr += 48;\n\t\t/*\n\t\t * The clone is shallow if nr_parent < 0, and we must\n\t\t * not traverse its real parents even when we unhide them.\n\t\t */\n\t\tif (graft && (graft->nr_parent < 0 || grafts_replace_parents))\n\t\t\tcontinue;\n\t\tnew_parent = lookup_commit(parent);\n\t\tif (new_parent)\n\t\t\tpptr = &commit_list_insert(new_parent, pptr)->next;\n\t}\n\tif (graft) {\n\t\tint i;\n\t\tstruct commit *new_parent;\n\t\tfor (i = 0; i < graft->nr_parent; i++) {\n\t\t\tnew_parent = lookup_commit(graft->parent[i]);\n\t\t\tif (!new_parent)\n\t\t\t\tcontinue;\n\t\t\tpptr = &commit_list_insert(new_parent, pptr)->next;\n\t\t}\n\t}\n\titem->date = parse_commit_date(bufptr, tail);\n\n\treturn 0;\n}\n\nint parse_commit(struct commit *item)\n{\n\tenum object_type type;\n\tvoid *buffer;\n\tunsigned long size;\n\tint ret;\n\n\tif (!item)\n\t\treturn -1;\n\tif (item->object.parsed)\n\t\treturn 0;\n\tbuffer = read_sha1_file(item->object.sha1, &type, &size);\n\tif (!buffer)\n\t\treturn error(\"Could not read %s\",\n\t\t\t     sha1_to_hex(item->object.sha1));\n\tif (type != OBJ_COMMIT) {\n\t\tfree(buffer);\n\t\treturn error(\"Object %s not a commit\",\n\t\t\t     sha1_to_hex(item->object.sha1));\n\t}\n\tret = parse_commit_buffer(item, buffer, size);\n\tif (save_commit_buffer && !ret) {\n\t\titem->buffer = buffer;\n\t\treturn 0;\n\t}\n\tfree(buffer);\n\treturn ret;\n}\n\nint find_commit_subject(const char *commit_buffer, const char **subject)\n{\n\tconst char *eol;\n\tconst char *p = commit_buffer;\n\n\twhile (*p && (*p != '\\n' || p[1] != '\\n'))\n\t\tp++;\n\tif (*p) {\n\t\tp += 2;\n\t\tfor (eol = p; *eol && *eol != '\\n'; eol++)\n\t\t\t; /* do nothing */\n\t} else\n\t\teol = p;\n\n\t*subject = p;\n\n\treturn eol - p;\n}\n\nstruct commit_list *commit_list_insert(struct commit *item, struct commit_list **list_p)\n{\n\tstruct commit_list *new_list = xmalloc(sizeof(struct commit_list));\n\tnew_list->item = item;\n\tnew_list->next = *list_p;\n\t*list_p = new_list;\n\treturn new_list;\n}\n\nunsigned commit_list_count(const struct commit_list *l)\n{\n\tunsigned c = 0;\n\tfor (; l; l = l->next )\n\t\tc++;\n\treturn c;\n}\n\nvoid free_commit_list(struct commit_list *list)\n{\n\twhile (list) {\n\t\tstruct commit_list *temp = list;\n\t\tlist = temp->next;\n\t\tfree(temp);\n\t}\n}\n\nstruct commit_list * insert_by_date(struct commit *item, struct commit_list **list)\n{\n\tstruct commit_list **pp = list;\n\tstruct commit_list *p;\n\twhile ((p = *pp) != NULL) {\n\t\tif (p->item->date < item->date) {\n\t\t\tbreak;\n\t\t}\n\t\tpp = &p->next;\n\t}\n\treturn commit_list_insert(item, pp);\n}\n\n\nvoid sort_by_date(struct commit_list **list)\n{\n\tstruct commit_list *ret = NULL;\n\twhile (*list) {\n\t\tinsert_by_date((*list)->item, &ret);\n\t\t*list = (*list)->next;\n\t}\n\t*list = ret;\n}\n\nstruct commit *pop_most_recent_commit(struct commit_list **list,\n\t\t\t\t      unsigned int mark)\n{\n\tstruct commit *ret = (*list)->item;\n\tstruct commit_list *parents = ret->parents;\n\tstruct commit_list *old = *list;\n\n\t*list = (*list)->next;\n\tfree(old);\n\n\twhile (parents) {\n\t\tstruct commit *commit = parents->item;\n\t\tif (!parse_commit(commit) && !(commit->object.flags & mark)) {\n\t\t\tcommit->object.flags |= mark;\n\t\t\tinsert_by_date(commit, list);\n\t\t}\n\t\tparents = parents->next;\n\t}\n\treturn ret;\n}\n\nvoid clear_commit_marks(struct commit *commit, unsigned int mark)\n{\n\twhile (commit) {\n\t\tstruct commit_list *parents;\n\n\t\tif (!(mark & commit->object.flags))\n\t\t\treturn;\n\n\t\tcommit->object.flags &= ~mark;\n\n\t\tparents = commit->parents;\n\t\tif (!parents)\n\t\t\treturn;\n\n\t\twhile ((parents = parents->next))\n\t\t\tclear_commit_marks(parents->item, mark);\n\n\t\tcommit = commit->parents->item;\n\t}\n}\n\nstruct commit *pop_commit(struct commit_list **stack)\n{\n\tstruct commit_list *top = *stack;\n\tstruct commit *item = top ? top->item : NULL;\n\n\tif (top) {\n\t\t*stack = top->next;\n\t\tfree(top);\n\t}\n\treturn item;\n}\n\n/*\n * Performs an in-place topological sort on the list supplied.\n */\nvoid sort_in_topological_order(struct commit_list ** list, int lifo)\n{\n\tstruct commit_list *next, *orig = *list;\n\tstruct commit_list *work, **insert;\n\tstruct commit_list **pptr;\n\n\tif (!orig)\n\t\treturn;\n\t*list = NULL;\n\n\t/* Mark them and clear the indegree */\n\tfor (next = orig; next; next = next->next) {\n\t\tstruct commit *commit = next->item;\n\t\tcommit->indegree = 1;\n\t}\n\n\t/* update the indegree */\n\tfor (next = orig; next; next = next->next) {\n\t\tstruct commit_list * parents = next->item->parents;\n\t\twhile (parents) {\n\t\t\tstruct commit *parent = parents->item;\n\n\t\t\tif (parent->indegree)\n\t\t\t\tparent->indegree++;\n\t\t\tparents = parents->next;\n\t\t}\n\t}\n\n\t/*\n\t * find the tips\n\t *\n\t * tips are nodes not reachable from any other node in the list\n\t *\n\t * the tips serve as a starting set for the work queue.\n\t */\n\twork = NULL;\n\tinsert = &work;\n\tfor (next = orig; next; next = next->next) {\n\t\tstruct commit *commit = next->item;\n\n\t\tif (commit->indegree == 1)\n\t\t\tinsert = &commit_list_insert(commit, insert)->next;\n\t}\n\n\t/* process the list in topological order */\n\tif (!lifo)\n\t\tsort_by_date(&work);\n\n\tpptr = list;\n\t*list = NULL;\n\twhile (work) {\n\t\tstruct commit *commit;\n\t\tstruct commit_list *parents, *work_item;\n\n\t\twork_item = work;\n\t\twork = work_item->next;\n\t\twork_item->next = NULL;\n\n\t\tcommit = work_item->item;\n\t\tfor (parents = commit->parents; parents ; parents = parents->next) {\n\t\t\tstruct commit *parent=parents->item;\n\n\t\t\tif (!parent->indegree)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * parents are only enqueued for emission\n\t\t\t * when all their children have been emitted thereby\n\t\t\t * guaranteeing topological order.\n\t\t\t */\n\t\t\tif (--parent->indegree == 1) {\n\t\t\t\tif (!lifo)\n\t\t\t\t\tinsert_by_date(parent, &work);\n\t\t\t\telse\n\t\t\t\t\tcommit_list_insert(parent, &work);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * work_item is a commit all of whose children\n\t\t * have already been emitted. we can emit it now.\n\t\t */\n\t\tcommit->indegree = 0;\n\t\t*pptr = work_item;\n\t\tpptr = &work_item->next;\n\t}\n}\n\n/* merge-base stuff */\n\n/* bits #0..15 in revision.h */\n#define PARENT1\t\t(1u<<16)\n#define PARENT2\t\t(1u<<17)\n#define STALE\t\t(1u<<18)\n#define RESULT\t\t(1u<<19)\n\nstatic const unsigned all_flags = (PARENT1 | PARENT2 | STALE | RESULT);\n\nstatic struct commit *interesting(struct commit_list *list)\n{\n\twhile (list) {\n\t\tstruct commit *commit = list->item;\n\t\tlist = list->next;\n\t\tif (commit->object.flags & STALE)\n\t\t\tcontinue;\n\t\treturn commit;\n\t}\n\treturn NULL;\n}\n\nstatic struct commit_list *merge_bases_many(struct commit *one, int n, struct commit **twos)\n{\n\tstruct commit_list *list = NULL;\n\tstruct commit_list *result = NULL;\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (one == twos[i])\n\t\t\t/*\n\t\t\t * We do not mark this even with RESULT so we do not\n\t\t\t * have to clean it up.\n\t\t\t */\n\t\t\treturn commit_list_insert(one, &result);\n\t}\n\n\tif (parse_commit(one))\n\t\treturn NULL;\n\tfor (i = 0; i < n; i++) {\n\t\tif (parse_commit(twos[i]))\n\t\t\treturn NULL;\n\t}\n\n\tone->object.flags |= PARENT1;\n\tinsert_by_date(one, &list);\n\tfor (i = 0; i < n; i++) {\n\t\ttwos[i]->object.flags |= PARENT2;\n\t\tinsert_by_date(twos[i], &list);\n\t}\n\n\twhile (interesting(list)) {\n\t\tstruct commit *commit;\n\t\tstruct commit_list *parents;\n\t\tstruct commit_list *next;\n\t\tint flags;\n\n\t\tcommit = list->item;\n\t\tnext = list->next;\n\t\tfree(list);\n\t\tlist = next;\n\n\t\tflags = commit->object.flags & (PARENT1 | PARENT2 | STALE);\n\t\tif (flags == (PARENT1 | PARENT2)) {\n\t\t\tif (!(commit->object.flags & RESULT)) {\n\t\t\t\tcommit->object.flags |= RESULT;\n\t\t\t\tinsert_by_date(commit, &result);\n\t\t\t}\n\t\t\t/* Mark parents of a found merge stale */\n\t\t\tflags |= STALE;\n\t\t}\n\t\tparents = commit->parents;\n\t\twhile (parents) {\n\t\t\tstruct commit *p = parents->item;\n\t\t\tparents = parents->next;\n\t\t\tif ((p->object.flags & flags) == flags)\n\t\t\t\tcontinue;\n\t\t\tif (parse_commit(p))\n\t\t\t\treturn NULL;\n\t\t\tp->object.flags |= flags;\n\t\t\tinsert_by_date(p, &list);\n\t\t}\n\t}\n\n\t/* Clean up the result to remove stale ones */\n\tfree_commit_list(list);\n\tlist = result; result = NULL;\n\twhile (list) {\n\t\tstruct commit_list *next = list->next;\n\t\tif (!(list->item->object.flags & STALE))\n\t\t\tinsert_by_date(list->item, &result);\n\t\tfree(list);\n\t\tlist = next;\n\t}\n\treturn result;\n}\n\nstruct commit_list *get_octopus_merge_bases(struct commit_list *in)\n{\n\tstruct commit_list *i, *j, *k, *ret = NULL;\n\tstruct commit_list **pptr = &ret;\n\n\tfor (i = in; i; i = i->next) {\n\t\tif (!ret)\n\t\t\tpptr = &commit_list_insert(i->item, pptr)->next;\n\t\telse {\n\t\t\tstruct commit_list *new = NULL, *end = NULL;\n\n\t\t\tfor (j = ret; j; j = j->next) {\n\t\t\t\tstruct commit_list *bases;\n\t\t\t\tbases = get_merge_bases(i->item, j->item, 1);\n\t\t\t\tif (!new)\n\t\t\t\t\tnew = bases;\n\t\t\t\telse\n\t\t\t\t\tend->next = bases;\n\t\t\t\tfor (k = bases; k; k = k->next)\n\t\t\t\t\tend = k;\n\t\t\t}\n\t\t\tret = new;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstruct commit_list *get_merge_bases_many(struct commit *one,\n\t\t\t\t\t int n,\n\t\t\t\t\t struct commit **twos,\n\t\t\t\t\t int cleanup)\n{\n\tstruct commit_list *list;\n\tstruct commit **rslt;\n\tstruct commit_list *result;\n\tint cnt, i, j;\n\n\tresult = merge_bases_many(one, n, twos);\n\tfor (i = 0; i < n; i++) {\n\t\tif (one == twos[i])\n\t\t\treturn result;\n\t}\n\tif (!result || !result->next) {\n\t\tif (cleanup) {\n\t\t\tclear_commit_marks(one, all_flags);\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\tclear_commit_marks(twos[i], all_flags);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/* There are more than one */\n\tcnt = 0;\n\tlist = result;\n\twhile (list) {\n\t\tlist = list->next;\n\t\tcnt++;\n\t}\n\trslt = xcalloc(cnt, sizeof(*rslt));\n\tfor (list = result, i = 0; list; list = list->next)\n\t\trslt[i++] = list->item;\n\tfree_commit_list(result);\n\n\tclear_commit_marks(one, all_flags);\n\tfor (i = 0; i < n; i++)\n\t\tclear_commit_marks(twos[i], all_flags);\n\tfor (i = 0; i < cnt - 1; i++) {\n\t\tfor (j = i+1; j < cnt; j++) {\n\t\t\tif (!rslt[i] || !rslt[j])\n\t\t\t\tcontinue;\n\t\t\tresult = merge_bases_many(rslt[i], 1, &rslt[j]);\n\t\t\tclear_commit_marks(rslt[i], all_flags);\n\t\t\tclear_commit_marks(rslt[j], all_flags);\n\t\t\tfor (list = result; list; list = list->next) {\n\t\t\t\tif (rslt[i] == list->item)\n\t\t\t\t\trslt[i] = NULL;\n\t\t\t\tif (rslt[j] == list->item)\n\t\t\t\t\trslt[j] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Surviving ones in rslt[] are the independent results */\n\tresult = NULL;\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (rslt[i])\n\t\t\tinsert_by_date(rslt[i], &result);\n\t}\n\tfree(rslt);\n\treturn result;\n}\n\nstruct commit_list *get_merge_bases(struct commit *one, struct commit *two,\n\t\t\t\t    int cleanup)\n{\n\treturn get_merge_bases_many(one, 1, &two, cleanup);\n}\n\nint is_descendant_of(struct commit *commit, struct commit_list *with_commit)\n{\n\tif (!with_commit)\n\t\treturn 1;\n\twhile (with_commit) {\n\t\tstruct commit *other;\n\n\t\tother = with_commit->item;\n\t\twith_commit = with_commit->next;\n\t\tif (in_merge_bases(other, &commit, 1))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint in_merge_bases(struct commit *commit, struct commit **reference, int num)\n{\n\tstruct commit_list *bases, *b;\n\tint ret = 0;\n\n\tif (num == 1)\n\t\tbases = get_merge_bases(commit, *reference, 1);\n\telse\n\t\tdie(\"not yet\");\n\tfor (b = bases; b; b = b->next) {\n\t\tif (!hashcmp(commit->object.sha1, b->item->object.sha1)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree_commit_list(bases);\n\treturn ret;\n}\n\nstruct commit_list *reduce_heads(struct commit_list *heads)\n{\n\tstruct commit_list *p;\n\tstruct commit_list *result = NULL, **tail = &result;\n\tstruct commit **other;\n\tsize_t num_head, num_other;\n\n\tif (!heads)\n\t\treturn NULL;\n\n\t/* Avoid unnecessary reallocations */\n\tfor (p = heads, num_head = 0; p; p = p->next)\n\t\tnum_head++;\n\tother = xcalloc(sizeof(*other), num_head);\n\n\t/* For each commit, see if it can be reached by others */\n\tfor (p = heads; p; p = p->next) {\n\t\tstruct commit_list *q, *base;\n\n\t\t/* Do we already have this in the result? */\n\t\tfor (q = result; q; q = q->next)\n\t\t\tif (p->item == q->item)\n\t\t\t\tbreak;\n\t\tif (q)\n\t\t\tcontinue;\n\n\t\tnum_other = 0;\n\t\tfor (q = heads; q; q = q->next) {\n\t\t\tif (p->item == q->item)\n\t\t\t\tcontinue;\n\t\t\tother[num_other++] = q->item;\n\t\t}\n\t\tif (num_other)\n\t\t\tbase = get_merge_bases_many(p->item, num_other, other, 1);\n\t\telse\n\t\t\tbase = NULL;\n\t\t/*\n\t\t * If p->item does not have anything common with other\n\t\t * commits, there won't be any merge base.  If it is\n\t\t * reachable from some of the others, p->item will be\n\t\t * the merge base.  If its history is connected with\n\t\t * others, but p->item is not reachable by others, we\n\t\t * will get something other than p->item back.\n\t\t */\n\t\tif (!base || (base->item != p->item))\n\t\t\ttail = &(commit_list_insert(p->item, tail)->next);\n\t\tfree_commit_list(base);\n\t}\n\tfree(other);\n\treturn result;\n}\n\nstatic const char commit_utf8_warn[] =\n\"Warning: commit message does not conform to UTF-8.\\n\"\n\"You may want to amend it after fixing the message, or set the config\\n\"\n\"variable i18n.commitencoding to the encoding your project uses.\\n\";\n\nint commit_tree(const char *msg, unsigned char *tree,\n\t\tstruct commit_list *parents, unsigned char *ret,\n\t\tconst char *author)\n{\n\tint result;\n\tint encoding_is_utf8;\n\tstruct strbuf buffer;\n\n\tassert_sha1_type(tree, OBJ_TREE);\n\n\t/* Not having i18n.commitencoding is the same as having utf-8 */\n\tencoding_is_utf8 = is_encoding_utf8(git_commit_encoding);\n\n\tstrbuf_init(&buffer, 8192); /* should avoid reallocs for the headers */\n\tstrbuf_addf(&buffer, \"tree %s\\n\", sha1_to_hex(tree));\n\n\t/*\n\t * NOTE! This ordering means that the same exact tree merged with a\n\t * different order of parents will be a _different_ changeset even\n\t * if everything else stays the same.\n\t */\n\twhile (parents) {\n\t\tstruct commit_list *next = parents->next;\n\t\tstrbuf_addf(&buffer, \"parent %s\\n\",\n\t\t\tsha1_to_hex(parents->item->object.sha1));\n\t\tfree(parents);\n\t\tparents = next;\n\t}\n\n\t/* Person/date information */\n\tif (!author)\n\t\tauthor = git_author_info(IDENT_ERROR_ON_NO_NAME);\n\tstrbuf_addf(&buffer, \"author %s\\n\", author);\n\tstrbuf_addf(&buffer, \"committer %s\\n\", git_committer_info(IDENT_ERROR_ON_NO_NAME));\n\tif (!encoding_is_utf8)\n\t\tstrbuf_addf(&buffer, \"encoding %s\\n\", git_commit_encoding);\n\tstrbuf_addch(&buffer, '\\n');\n\n\t/* And add the comment */\n\tstrbuf_addstr(&buffer, msg);\n\n\t/* And check the encoding */\n\tif (encoding_is_utf8 && !is_utf8(buffer.buf))\n\t\tfprintf(stderr, commit_utf8_warn);\n\n\tresult = write_sha1_file(buffer.buf, buffer.len, commit_type, ret);\n\tstrbuf_release(&buffer);\n\treturn result;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0094ec1c9278332f736d2814c847b272788a7dd3",
  "sha1_ok": true,
  "size": 19924
}
