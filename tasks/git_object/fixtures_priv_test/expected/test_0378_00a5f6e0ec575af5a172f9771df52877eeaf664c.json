{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJvYmplY3QuaCIKI2luY2x1ZGUgInBhY2suaCIKI2luY2x1ZGUgInBhY2stb2JqZWN0cy5oIgojaW5jbHVkZSAicGFja2ZpbGUuaCIKI2luY2x1ZGUgImNvbmZpZy5oIgoKc3RhdGljIHVpbnQzMl90IGxvY2F0ZV9vYmplY3RfZW50cnlfaGFzaChzdHJ1Y3QgcGFja2luZ19kYXRhICpwZGF0YSwKCQkJCQkgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkJCSBpbnQgKmZvdW5kKQp7Cgl1aW50MzJfdCBpLCBtYXNrID0gKHBkYXRhLT5pbmRleF9zaXplIC0gMSk7CgoJaSA9IHNoYTFoYXNoKG9pZC0+aGFzaCkgJiBtYXNrOwoKCXdoaWxlIChwZGF0YS0+aW5kZXhbaV0gPiAwKSB7CgkJdWludDMyX3QgcG9zID0gcGRhdGEtPmluZGV4W2ldIC0gMTsKCgkJaWYgKG9pZGVxKG9pZCwgJnBkYXRhLT5vYmplY3RzW3Bvc10uaWR4Lm9pZCkpIHsKCQkJKmZvdW5kID0gMTsKCQkJcmV0dXJuIGk7CgkJfQoKCQlpID0gKGkgKyAxKSAmIG1hc2s7Cgl9CgoJKmZvdW5kID0gMDsKCXJldHVybiBpOwp9CgpzdGF0aWMgaW5saW5lIHVpbnQzMl90IGNsb3Nlc3RfcG93Mih1aW50MzJfdCB2KQp7Cgl2ID0gdiAtIDE7Cgl2IHw9IHYgPj4gMTsKCXYgfD0gdiA+PiAyOwoJdiB8PSB2ID4+IDQ7Cgl2IHw9IHYgPj4gODsKCXYgfD0gdiA+PiAxNjsKCXJldHVybiB2ICsgMTsKfQoKc3RhdGljIHZvaWQgcmVoYXNoX29iamVjdHMoc3RydWN0IHBhY2tpbmdfZGF0YSAqcGRhdGEpCnsKCXVpbnQzMl90IGk7CglzdHJ1Y3Qgb2JqZWN0X2VudHJ5ICplbnRyeTsKCglwZGF0YS0+aW5kZXhfc2l6ZSA9IGNsb3Nlc3RfcG93MihwZGF0YS0+bnJfb2JqZWN0cyAqIDMpOwoJaWYgKHBkYXRhLT5pbmRleF9zaXplIDwgMTAyNCkKCQlwZGF0YS0+aW5kZXhfc2l6ZSA9IDEwMjQ7CgoJZnJlZShwZGF0YS0+aW5kZXgpOwoJcGRhdGEtPmluZGV4ID0geGNhbGxvYyhwZGF0YS0+aW5kZXhfc2l6ZSwgc2l6ZW9mKCpwZGF0YS0+aW5kZXgpKTsKCgllbnRyeSA9IHBkYXRhLT5vYmplY3RzOwoKCWZvciAoaSA9IDA7IGkgPCBwZGF0YS0+bnJfb2JqZWN0czsgaSsrKSB7CgkJaW50IGZvdW5kOwoJCXVpbnQzMl90IGl4ID0gbG9jYXRlX29iamVjdF9lbnRyeV9oYXNoKHBkYXRhLAoJCQkJCQkgICAgICAgJmVudHJ5LT5pZHgub2lkLAoJCQkJCQkgICAgICAgJmZvdW5kKTsKCgkJaWYgKGZvdW5kKQoJCQlCVUcoIkR1cGxpY2F0ZSBvYmplY3QgaW4gaGFzaCIpOwoKCQlwZGF0YS0+aW5kZXhbaXhdID0gaSArIDE7CgkJZW50cnkrKzsKCX0KfQoKc3RydWN0IG9iamVjdF9lbnRyeSAqcGFja2xpc3RfZmluZChzdHJ1Y3QgcGFja2luZ19kYXRhICpwZGF0YSwKCQkJCSAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCSAgIHVpbnQzMl90ICppbmRleF9wb3MpCnsKCXVpbnQzMl90IGk7CglpbnQgZm91bmQ7CgoJaWYgKCFwZGF0YS0+aW5kZXhfc2l6ZSkKCQlyZXR1cm4gTlVMTDsKCglpID0gbG9jYXRlX29iamVjdF9lbnRyeV9oYXNoKHBkYXRhLCBvaWQsICZmb3VuZCk7CgoJaWYgKGluZGV4X3BvcykKCQkqaW5kZXhfcG9zID0gaTsKCglpZiAoIWZvdW5kKQoJCXJldHVybiBOVUxMOwoKCXJldHVybiAmcGRhdGEtPm9iamVjdHNbcGRhdGEtPmluZGV4W2ldIC0gMV07Cn0KCnN0YXRpYyB2b2lkIHByZXBhcmVfaW5fcGFja19ieV9pZHgoc3RydWN0IHBhY2tpbmdfZGF0YSAqcGRhdGEpCnsKCXN0cnVjdCBwYWNrZWRfZ2l0ICoqbWFwcGluZywgKnA7CglpbnQgY250ID0gMCwgbnIgPSAxVSA8PCBPRV9JTl9QQUNLX0JJVFM7CgoJQUxMT0NfQVJSQVkobWFwcGluZywgbnIpOwoJLyoKCSAqIG9lX2luX3BhY2soKSBvbiBhbiBhbGwtemVybydkIG9iamVjdF9lbnRyeQoJICogKGkuZS4gaW5fcGFja19pZHggYWxzbyB6ZXJvKSBzaG91bGQgcmV0dXJuIE5VTEwuCgkgKi8KCW1hcHBpbmdbY250KytdID0gTlVMTDsKCWZvciAocCA9IGdldF9hbGxfcGFja3MocGRhdGEtPnJlcG8pOyBwOyBwID0gcC0+bmV4dCwgY250KyspIHsKCQlpZiAoY250ID09IG5yKSB7CgkJCWZyZWUobWFwcGluZyk7CgkJCXJldHVybjsKCQl9CgkJcC0+aW5kZXggPSBjbnQ7CgkJbWFwcGluZ1tjbnRdID0gcDsKCX0KCXBkYXRhLT5pbl9wYWNrX2J5X2lkeCA9IG1hcHBpbmc7Cn0KCi8qCiAqIEEgbmV3IHBhY2sgYXBwZWFycyBhZnRlciBwcmVwYXJlX2luX3BhY2tfYnlfaWR4KCkgaGFzIGJlZW4KICogcnVuLiBUaGlzIGlzIGxpa2VseSBhIHJhY2UuCiAqCiAqIFdlIGNvdWxkIG1hcCB0aGlzIG5ldyBwYWNrIHRvIGluX3BhY2tfYnlfaWR4W10gYXJyYXksIGJ1dCB0aGVuIHdlCiAqIGhhdmUgdG8gZGVhbCB3aXRoIGZ1bGwgYXJyYXkgYW55d2F5LiBBbmQgc2luY2UgaXQncyBoYXJkIHRvIHRlc3QKICogdGhpcyBmYWxsIGJhY2sgY29kZSwganVzdCBzdGF5IHNpbXBsZSBhbmQgZmFsbCBiYWNrIHRvIHVzaW5nCiAqIGluX3BhY2tbXSBhcnJheS4KICovCnZvaWQgb2VfbWFwX25ld19wYWNrKHN0cnVjdCBwYWNraW5nX2RhdGEgKnBhY2spCnsKCXVpbnQzMl90IGk7CgoJUkVBTExPQ19BUlJBWShwYWNrLT5pbl9wYWNrLCBwYWNrLT5ucl9hbGxvYyk7CgoJZm9yIChpID0gMDsgaSA8IHBhY2stPm5yX29iamVjdHM7IGkrKykKCQlwYWNrLT5pbl9wYWNrW2ldID0gb2VfaW5fcGFjayhwYWNrLCBwYWNrLT5vYmplY3RzICsgaSk7CgoJRlJFRV9BTkRfTlVMTChwYWNrLT5pbl9wYWNrX2J5X2lkeCk7Cn0KCi8qIGFzc3VtZSBwZGF0YSBpcyBhbHJlYWR5IHplcm8nZCBieSBjYWxsZXIgKi8Kdm9pZCBwcmVwYXJlX3BhY2tpbmdfZGF0YShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgc3RydWN0IHBhY2tpbmdfZGF0YSAqcGRhdGEpCnsKCXBkYXRhLT5yZXBvID0gcjsKCglpZiAoZ2l0X2Vudl9ib29sKCJHSVRfVEVTVF9GVUxMX0lOX1BBQ0tfQVJSQVkiLCAwKSkgewoJCS8qCgkJICogZG8gbm90IGluaXRpYWxpemUgaW5fcGFja19ieV9pZHhbXSB0byBmb3JjZSB0aGUKCQkgKiBzbG93IHBhdGggaW4gb2VfaW5fcGFjaygpCgkJICovCgl9IGVsc2UgewoJCXByZXBhcmVfaW5fcGFja19ieV9pZHgocGRhdGEpOwoJfQoKCXBkYXRhLT5vZV9zaXplX2xpbWl0ID0gZ2l0X2Vudl91bG9uZygiR0lUX1RFU1RfT0VfU0laRSIsCgkJCQkJICAgICAxVSA8PCBPRV9TSVpFX0JJVFMpOwoJcGRhdGEtPm9lX2RlbHRhX3NpemVfbGltaXQgPSBnaXRfZW52X3Vsb25nKCJHSVRfVEVTVF9PRV9ERUxUQV9TSVpFIiwKCQkJCQkJICAgMVVMIDw8IE9FX0RFTFRBX1NJWkVfQklUUyk7Cglpbml0X3JlY3Vyc2l2ZV9tdXRleCgmcGRhdGEtPm9kYl9sb2NrKTsKfQoKc3RydWN0IG9iamVjdF9lbnRyeSAqcGFja2xpc3RfYWxsb2Moc3RydWN0IHBhY2tpbmdfZGF0YSAqcGRhdGEsCgkJCQkgICAgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkJCSAgICB1aW50MzJfdCBpbmRleF9wb3MpCnsKCXN0cnVjdCBvYmplY3RfZW50cnkgKm5ld19lbnRyeTsKCglpZiAocGRhdGEtPm5yX29iamVjdHMgPj0gcGRhdGEtPm5yX2FsbG9jKSB7CgkJcGRhdGEtPm5yX2FsbG9jID0gKHBkYXRhLT5ucl9hbGxvYyAgKyAxMDI0KSAqIDMgLyAyOwoJCVJFQUxMT0NfQVJSQVkocGRhdGEtPm9iamVjdHMsIHBkYXRhLT5ucl9hbGxvYyk7CgoJCWlmICghcGRhdGEtPmluX3BhY2tfYnlfaWR4KQoJCQlSRUFMTE9DX0FSUkFZKHBkYXRhLT5pbl9wYWNrLCBwZGF0YS0+bnJfYWxsb2MpOwoJCWlmIChwZGF0YS0+ZGVsdGFfc2l6ZSkKCQkJUkVBTExPQ19BUlJBWShwZGF0YS0+ZGVsdGFfc2l6ZSwgcGRhdGEtPm5yX2FsbG9jKTsKCgkJaWYgKHBkYXRhLT50cmVlX2RlcHRoKQoJCQlSRUFMTE9DX0FSUkFZKHBkYXRhLT50cmVlX2RlcHRoLCBwZGF0YS0+bnJfYWxsb2MpOwoKCQlpZiAocGRhdGEtPmxheWVyKQoJCQlSRUFMTE9DX0FSUkFZKHBkYXRhLT5sYXllciwgcGRhdGEtPm5yX2FsbG9jKTsKCX0KCgluZXdfZW50cnkgPSBwZGF0YS0+b2JqZWN0cyArIHBkYXRhLT5ucl9vYmplY3RzKys7CgoJbWVtc2V0KG5ld19lbnRyeSwgMCwgc2l6ZW9mKCpuZXdfZW50cnkpKTsKCWhhc2hjcHkobmV3X2VudHJ5LT5pZHgub2lkLmhhc2gsIHNoYTEpOwoKCWlmIChwZGF0YS0+aW5kZXhfc2l6ZSAqIDMgPD0gcGRhdGEtPm5yX29iamVjdHMgKiA0KQoJCXJlaGFzaF9vYmplY3RzKHBkYXRhKTsKCWVsc2UKCQlwZGF0YS0+aW5kZXhbaW5kZXhfcG9zXSA9IHBkYXRhLT5ucl9vYmplY3RzOwoKCWlmIChwZGF0YS0+aW5fcGFjaykKCQlwZGF0YS0+aW5fcGFja1twZGF0YS0+bnJfb2JqZWN0cyAtIDFdID0gTlVMTDsKCglpZiAocGRhdGEtPnRyZWVfZGVwdGgpCgkJcGRhdGEtPnRyZWVfZGVwdGhbcGRhdGEtPm5yX29iamVjdHMgLSAxXSA9IDA7CgoJaWYgKHBkYXRhLT5sYXllcikKCQlwZGF0YS0+bGF5ZXJbcGRhdGEtPm5yX29iamVjdHMgLSAxXSA9IDA7CgoJcmV0dXJuIG5ld19lbnRyeTsKfQoKdm9pZCBvZV9zZXRfZGVsdGFfZXh0KHN0cnVjdCBwYWNraW5nX2RhdGEgKnBkYXRhLAoJCSAgICAgIHN0cnVjdCBvYmplY3RfZW50cnkgKmRlbHRhLAoJCSAgICAgIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXN0cnVjdCBvYmplY3RfZW50cnkgKmJhc2U7CgoJQUxMT0NfR1JPVyhwZGF0YS0+ZXh0X2Jhc2VzLCBwZGF0YS0+bnJfZXh0ICsgMSwgcGRhdGEtPmFsbG9jX2V4dCk7CgliYXNlID0gJnBkYXRhLT5leHRfYmFzZXNbcGRhdGEtPm5yX2V4dCsrXTsKCW1lbXNldChiYXNlLCAwLCBzaXplb2YoKmJhc2UpKTsKCWhhc2hjcHkoYmFzZS0+aWR4Lm9pZC5oYXNoLCBzaGExKTsKCgkvKiBUaGVzZSBmbGFncyBtYXJrIHRoYXQgd2UgYXJlIG5vdCBwYXJ0IG9mIHRoZSBhY3R1YWwgcGFjayBvdXRwdXQuICovCgliYXNlLT5wcmVmZXJyZWRfYmFzZSA9IDE7CgliYXNlLT5maWxsZWQgPSAxOwoKCWRlbHRhLT5leHRfYmFzZSA9IDE7CglkZWx0YS0+ZGVsdGFfaWR4ID0gYmFzZSAtIHBkYXRhLT5leHRfYmFzZXMgKyAxOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"object.h\"\n#include \"pack.h\"\n#include \"pack-objects.h\"\n#include \"packfile.h\"\n#include \"config.h\"\n\nstatic uint32_t locate_object_entry_hash(struct packing_data *pdata,\n\t\t\t\t\t const struct object_id *oid,\n\t\t\t\t\t int *found)\n{\n\tuint32_t i, mask = (pdata->index_size - 1);\n\n\ti = sha1hash(oid->hash) & mask;\n\n\twhile (pdata->index[i] > 0) {\n\t\tuint32_t pos = pdata->index[i] - 1;\n\n\t\tif (oideq(oid, &pdata->objects[pos].idx.oid)) {\n\t\t\t*found = 1;\n\t\t\treturn i;\n\t\t}\n\n\t\ti = (i + 1) & mask;\n\t}\n\n\t*found = 0;\n\treturn i;\n}\n\nstatic inline uint32_t closest_pow2(uint32_t v)\n{\n\tv = v - 1;\n\tv |= v >> 1;\n\tv |= v >> 2;\n\tv |= v >> 4;\n\tv |= v >> 8;\n\tv |= v >> 16;\n\treturn v + 1;\n}\n\nstatic void rehash_objects(struct packing_data *pdata)\n{\n\tuint32_t i;\n\tstruct object_entry *entry;\n\n\tpdata->index_size = closest_pow2(pdata->nr_objects * 3);\n\tif (pdata->index_size < 1024)\n\t\tpdata->index_size = 1024;\n\n\tfree(pdata->index);\n\tpdata->index = xcalloc(pdata->index_size, sizeof(*pdata->index));\n\n\tentry = pdata->objects;\n\n\tfor (i = 0; i < pdata->nr_objects; i++) {\n\t\tint found;\n\t\tuint32_t ix = locate_object_entry_hash(pdata,\n\t\t\t\t\t\t       &entry->idx.oid,\n\t\t\t\t\t\t       &found);\n\n\t\tif (found)\n\t\t\tBUG(\"Duplicate object in hash\");\n\n\t\tpdata->index[ix] = i + 1;\n\t\tentry++;\n\t}\n}\n\nstruct object_entry *packlist_find(struct packing_data *pdata,\n\t\t\t\t   const struct object_id *oid,\n\t\t\t\t   uint32_t *index_pos)\n{\n\tuint32_t i;\n\tint found;\n\n\tif (!pdata->index_size)\n\t\treturn NULL;\n\n\ti = locate_object_entry_hash(pdata, oid, &found);\n\n\tif (index_pos)\n\t\t*index_pos = i;\n\n\tif (!found)\n\t\treturn NULL;\n\n\treturn &pdata->objects[pdata->index[i] - 1];\n}\n\nstatic void prepare_in_pack_by_idx(struct packing_data *pdata)\n{\n\tstruct packed_git **mapping, *p;\n\tint cnt = 0, nr = 1U << OE_IN_PACK_BITS;\n\n\tALLOC_ARRAY(mapping, nr);\n\t/*\n\t * oe_in_pack() on an all-zero'd object_entry\n\t * (i.e. in_pack_idx also zero) should return NULL.\n\t */\n\tmapping[cnt++] = NULL;\n\tfor (p = get_all_packs(pdata->repo); p; p = p->next, cnt++) {\n\t\tif (cnt == nr) {\n\t\t\tfree(mapping);\n\t\t\treturn;\n\t\t}\n\t\tp->index = cnt;\n\t\tmapping[cnt] = p;\n\t}\n\tpdata->in_pack_by_idx = mapping;\n}\n\n/*\n * A new pack appears after prepare_in_pack_by_idx() has been\n * run. This is likely a race.\n *\n * We could map this new pack to in_pack_by_idx[] array, but then we\n * have to deal with full array anyway. And since it's hard to test\n * this fall back code, just stay simple and fall back to using\n * in_pack[] array.\n */\nvoid oe_map_new_pack(struct packing_data *pack)\n{\n\tuint32_t i;\n\n\tREALLOC_ARRAY(pack->in_pack, pack->nr_alloc);\n\n\tfor (i = 0; i < pack->nr_objects; i++)\n\t\tpack->in_pack[i] = oe_in_pack(pack, pack->objects + i);\n\n\tFREE_AND_NULL(pack->in_pack_by_idx);\n}\n\n/* assume pdata is already zero'd by caller */\nvoid prepare_packing_data(struct repository *r, struct packing_data *pdata)\n{\n\tpdata->repo = r;\n\n\tif (git_env_bool(\"GIT_TEST_FULL_IN_PACK_ARRAY\", 0)) {\n\t\t/*\n\t\t * do not initialize in_pack_by_idx[] to force the\n\t\t * slow path in oe_in_pack()\n\t\t */\n\t} else {\n\t\tprepare_in_pack_by_idx(pdata);\n\t}\n\n\tpdata->oe_size_limit = git_env_ulong(\"GIT_TEST_OE_SIZE\",\n\t\t\t\t\t     1U << OE_SIZE_BITS);\n\tpdata->oe_delta_size_limit = git_env_ulong(\"GIT_TEST_OE_DELTA_SIZE\",\n\t\t\t\t\t\t   1UL << OE_DELTA_SIZE_BITS);\n\tinit_recursive_mutex(&pdata->odb_lock);\n}\n\nstruct object_entry *packlist_alloc(struct packing_data *pdata,\n\t\t\t\t    const unsigned char *sha1,\n\t\t\t\t    uint32_t index_pos)\n{\n\tstruct object_entry *new_entry;\n\n\tif (pdata->nr_objects >= pdata->nr_alloc) {\n\t\tpdata->nr_alloc = (pdata->nr_alloc  + 1024) * 3 / 2;\n\t\tREALLOC_ARRAY(pdata->objects, pdata->nr_alloc);\n\n\t\tif (!pdata->in_pack_by_idx)\n\t\t\tREALLOC_ARRAY(pdata->in_pack, pdata->nr_alloc);\n\t\tif (pdata->delta_size)\n\t\t\tREALLOC_ARRAY(pdata->delta_size, pdata->nr_alloc);\n\n\t\tif (pdata->tree_depth)\n\t\t\tREALLOC_ARRAY(pdata->tree_depth, pdata->nr_alloc);\n\n\t\tif (pdata->layer)\n\t\t\tREALLOC_ARRAY(pdata->layer, pdata->nr_alloc);\n\t}\n\n\tnew_entry = pdata->objects + pdata->nr_objects++;\n\n\tmemset(new_entry, 0, sizeof(*new_entry));\n\thashcpy(new_entry->idx.oid.hash, sha1);\n\n\tif (pdata->index_size * 3 <= pdata->nr_objects * 4)\n\t\trehash_objects(pdata);\n\telse\n\t\tpdata->index[index_pos] = pdata->nr_objects;\n\n\tif (pdata->in_pack)\n\t\tpdata->in_pack[pdata->nr_objects - 1] = NULL;\n\n\tif (pdata->tree_depth)\n\t\tpdata->tree_depth[pdata->nr_objects - 1] = 0;\n\n\tif (pdata->layer)\n\t\tpdata->layer[pdata->nr_objects - 1] = 0;\n\n\treturn new_entry;\n}\n\nvoid oe_set_delta_ext(struct packing_data *pdata,\n\t\t      struct object_entry *delta,\n\t\t      const unsigned char *sha1)\n{\n\tstruct object_entry *base;\n\n\tALLOC_GROW(pdata->ext_bases, pdata->nr_ext + 1, pdata->alloc_ext);\n\tbase = &pdata->ext_bases[pdata->nr_ext++];\n\tmemset(base, 0, sizeof(*base));\n\thashcpy(base->idx.oid.hash, sha1);\n\n\t/* These flags mark that we are not part of the actual pack output. */\n\tbase->preferred_base = 1;\n\tbase->filled = 1;\n\n\tdelta->ext_base = 1;\n\tdelta->delta_idx = base - pdata->ext_bases + 1;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00a5f6e0ec575af5a172f9771df52877eeaf664c",
  "sha1_ok": true,
  "size": 4936
}
