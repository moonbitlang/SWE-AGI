{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJvYmplY3QuaCIKI2luY2x1ZGUgInJlcGxhY2Utb2JqZWN0LmgiCiNpbmNsdWRlICJvYmplY3Qtc3RvcmUuaCIKI2luY2x1ZGUgImJsb2IuaCIKI2luY2x1ZGUgInRyZWUuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAidGFnLmgiCiNpbmNsdWRlICJhbGxvYy5oIgojaW5jbHVkZSAib2JqZWN0LXN0b3JlLmgiCiNpbmNsdWRlICJwYWNrZmlsZS5oIgojaW5jbHVkZSAiY29tbWl0LWdyYXBoLmgiCgp1bnNpZ25lZCBpbnQgZ2V0X21heF9vYmplY3RfaW5kZXgodm9pZCkKewoJcmV0dXJuIHRoZV9yZXBvc2l0b3J5LT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2hfc2l6ZTsKfQoKc3RydWN0IG9iamVjdCAqZ2V0X2luZGV4ZWRfb2JqZWN0KHVuc2lnbmVkIGludCBpZHgpCnsKCXJldHVybiB0aGVfcmVwb3NpdG9yeS0+cGFyc2VkX29iamVjdHMtPm9ial9oYXNoW2lkeF07Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpvYmplY3RfdHlwZV9zdHJpbmdzW10gPSB7CglOVUxMLAkJLyogT0JKX05PTkUgPSAwICovCgkiY29tbWl0IiwJLyogT0JKX0NPTU1JVCA9IDEgKi8KCSJ0cmVlIiwJCS8qIE9CSl9UUkVFID0gMiAqLwoJImJsb2IiLAkJLyogT0JKX0JMT0IgPSAzICovCgkidGFnIiwJCS8qIE9CSl9UQUcgPSA0ICovCn07Cgpjb25zdCBjaGFyICp0eXBlX25hbWUodW5zaWduZWQgaW50IHR5cGUpCnsKCWlmICh0eXBlID49IEFSUkFZX1NJWkUob2JqZWN0X3R5cGVfc3RyaW5ncykpCgkJcmV0dXJuIE5VTEw7CglyZXR1cm4gb2JqZWN0X3R5cGVfc3RyaW5nc1t0eXBlXTsKfQoKaW50IHR5cGVfZnJvbV9zdHJpbmdfZ2VudGx5KGNvbnN0IGNoYXIgKnN0ciwgc3NpemVfdCBsZW4sIGludCBnZW50bGUpCnsKCWludCBpOwoKCWlmIChsZW4gPCAwKQoJCWxlbiA9IHN0cmxlbihzdHIpOwoKCWZvciAoaSA9IDE7IGkgPCBBUlJBWV9TSVpFKG9iamVjdF90eXBlX3N0cmluZ3MpOyBpKyspCgkJaWYgKCFzdHJuY21wKHN0ciwgb2JqZWN0X3R5cGVfc3RyaW5nc1tpXSwgbGVuKSAmJgoJCSAgICBvYmplY3RfdHlwZV9zdHJpbmdzW2ldW2xlbl0gPT0gJ1wwJykKCQkJcmV0dXJuIGk7CgoJaWYgKGdlbnRsZSkKCQlyZXR1cm4gLTE7CgoJZGllKF8oImludmFsaWQgb2JqZWN0IHR5cGUgXCIlc1wiIiksIHN0cik7Cn0KCi8qCiAqIFJldHVybiBhIG51bWVyaWNhbCBoYXNoIHZhbHVlIGJldHdlZW4gMCBhbmQgbi0xIGZvciB0aGUgb2JqZWN0IHdpdGgKICogdGhlIHNwZWNpZmllZCBzaGExLiAgbiBtdXN0IGJlIGEgcG93ZXIgb2YgMi4gIFBsZWFzZSBub3RlIHRoYXQgdGhlCiAqIHJldHVybiB2YWx1ZSBpcyAqbm90KiBjb25zaXN0ZW50IGFjcm9zcyBjb21wdXRlciBhcmNoaXRlY3R1cmVzLgogKi8Kc3RhdGljIHVuc2lnbmVkIGludCBoYXNoX29iaihjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCB1bnNpZ25lZCBpbnQgbikKewoJcmV0dXJuIHNoYTFoYXNoKHNoYTEpICYgKG4gLSAxKTsKfQoKLyoKICogSW5zZXJ0IG9iaiBpbnRvIHRoZSBoYXNoIHRhYmxlIGhhc2gsIHdoaWNoIGhhcyBsZW5ndGggc2l6ZSAod2hpY2gKICogbXVzdCBiZSBhIHBvd2VyIG9mIDIpLiAgT24gY29sbGlzaW9ucywgc2ltcGx5IG92ZXJmbG93IHRvIHRoZSBuZXh0CiAqIGVtcHR5IGJ1Y2tldC4KICovCnN0YXRpYyB2b2lkIGluc2VydF9vYmpfaGFzaChzdHJ1Y3Qgb2JqZWN0ICpvYmosIHN0cnVjdCBvYmplY3QgKipoYXNoLCB1bnNpZ25lZCBpbnQgc2l6ZSkKewoJdW5zaWduZWQgaW50IGogPSBoYXNoX29iaihvYmotPm9pZC5oYXNoLCBzaXplKTsKCgl3aGlsZSAoaGFzaFtqXSkgewoJCWorKzsKCQlpZiAoaiA+PSBzaXplKQoJCQlqID0gMDsKCX0KCWhhc2hbal0gPSBvYmo7Cn0KCi8qCiAqIExvb2sgdXAgdGhlIHJlY29yZCBmb3IgdGhlIGdpdmVuIHNoYTEgaW4gdGhlIGhhc2ggbWFwIHN0b3JlZCBpbgogKiBvYmpfaGFzaC4gIFJldHVybiBOVUxMIGlmIGl0IHdhcyBub3QgZm91bmQuCiAqLwpzdHJ1Y3Qgb2JqZWN0ICpsb29rdXBfb2JqZWN0KHN0cnVjdCByZXBvc2l0b3J5ICpyLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7Cgl1bnNpZ25lZCBpbnQgaSwgZmlyc3Q7CglzdHJ1Y3Qgb2JqZWN0ICpvYmo7CgoJaWYgKCFyLT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2gpCgkJcmV0dXJuIE5VTEw7CgoJZmlyc3QgPSBpID0gaGFzaF9vYmooc2hhMSwgci0+cGFyc2VkX29iamVjdHMtPm9ial9oYXNoX3NpemUpOwoJd2hpbGUgKChvYmogPSByLT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2hbaV0pICE9IE5VTEwpIHsKCQlpZiAoaGFzaGVxKHNoYTEsIG9iai0+b2lkLmhhc2gpKQoJCQlicmVhazsKCQlpKys7CgkJaWYgKGkgPT0gci0+cGFyc2VkX29iamVjdHMtPm9ial9oYXNoX3NpemUpCgkJCWkgPSAwOwoJfQoJaWYgKG9iaiAmJiBpICE9IGZpcnN0KSB7CgkJLyoKCQkgKiBNb3ZlIG9iamVjdCB0byB3aGVyZSB3ZSBzdGFydGVkIHRvIGxvb2sgZm9yIGl0IHNvCgkJICogdGhhdCB3ZSBkbyBub3QgbmVlZCB0byB3YWxrIHRoZSBoYXNoIHRhYmxlIHRoZSBuZXh0CgkJICogdGltZSB3ZSBsb29rIGZvciBpdC4KCQkgKi8KCQlTV0FQKHItPnBhcnNlZF9vYmplY3RzLT5vYmpfaGFzaFtpXSwKCQkgICAgIHItPnBhcnNlZF9vYmplY3RzLT5vYmpfaGFzaFtmaXJzdF0pOwoJfQoJcmV0dXJuIG9iajsKfQoKLyoKICogSW5jcmVhc2UgdGhlIHNpemUgb2YgdGhlIGhhc2ggbWFwIHN0b3JlZCBpbiBvYmpfaGFzaCB0byB0aGUgbmV4dAogKiBwb3dlciBvZiAyIChidXQgYXQgbGVhc3QgMzIpLiAgQ29weSB0aGUgZXhpc3RpbmcgdmFsdWVzIHRvIHRoZSBuZXcKICogaGFzaCBtYXAuCiAqLwpzdGF0aWMgdm9pZCBncm93X29iamVjdF9oYXNoKHN0cnVjdCByZXBvc2l0b3J5ICpyKQp7CglpbnQgaTsKCS8qCgkgKiBOb3RlIHRoYXQgdGhpcyBzaXplIG11c3QgYWx3YXlzIGJlIHBvd2VyLW9mLTIgdG8gbWF0Y2ggaGFzaF9vYmoKCSAqIGFib3ZlLgoJICovCglpbnQgbmV3X2hhc2hfc2l6ZSA9IHItPnBhcnNlZF9vYmplY3RzLT5vYmpfaGFzaF9zaXplIDwgMzIgPyAzMiA6IDIgKiByLT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2hfc2l6ZTsKCXN0cnVjdCBvYmplY3QgKipuZXdfaGFzaDsKCgluZXdfaGFzaCA9IHhjYWxsb2MobmV3X2hhc2hfc2l6ZSwgc2l6ZW9mKHN0cnVjdCBvYmplY3QgKikpOwoJZm9yIChpID0gMDsgaSA8IHItPnBhcnNlZF9vYmplY3RzLT5vYmpfaGFzaF9zaXplOyBpKyspIHsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmogPSByLT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2hbaV07CgoJCWlmICghb2JqKQoJCQljb250aW51ZTsKCQlpbnNlcnRfb2JqX2hhc2gob2JqLCBuZXdfaGFzaCwgbmV3X2hhc2hfc2l6ZSk7Cgl9CglmcmVlKHItPnBhcnNlZF9vYmplY3RzLT5vYmpfaGFzaCk7CglyLT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2ggPSBuZXdfaGFzaDsKCXItPnBhcnNlZF9vYmplY3RzLT5vYmpfaGFzaF9zaXplID0gbmV3X2hhc2hfc2l6ZTsKfQoKdm9pZCAqY3JlYXRlX29iamVjdChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgdm9pZCAqbykKewoJc3RydWN0IG9iamVjdCAqb2JqID0gbzsKCglvYmotPnBhcnNlZCA9IDA7CglvYmotPmZsYWdzID0gMDsKCWhhc2hjcHkob2JqLT5vaWQuaGFzaCwgc2hhMSk7CgoJaWYgKHItPnBhcnNlZF9vYmplY3RzLT5vYmpfaGFzaF9zaXplIC0gMSA8PSByLT5wYXJzZWRfb2JqZWN0cy0+bnJfb2JqcyAqIDIpCgkJZ3Jvd19vYmplY3RfaGFzaChyKTsKCglpbnNlcnRfb2JqX2hhc2gob2JqLCByLT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2gsCgkJCXItPnBhcnNlZF9vYmplY3RzLT5vYmpfaGFzaF9zaXplKTsKCXItPnBhcnNlZF9vYmplY3RzLT5ucl9vYmpzKys7CglyZXR1cm4gb2JqOwp9Cgp2b2lkICpvYmplY3RfYXNfdHlwZShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgc3RydWN0IG9iamVjdCAqb2JqLCBlbnVtIG9iamVjdF90eXBlIHR5cGUsIGludCBxdWlldCkKewoJaWYgKG9iai0+dHlwZSA9PSB0eXBlKQoJCXJldHVybiBvYmo7CgllbHNlIGlmIChvYmotPnR5cGUgPT0gT0JKX05PTkUpIHsKCQlpZiAodHlwZSA9PSBPQkpfQ09NTUlUKQoJCQkoKHN0cnVjdCBjb21taXQgKilvYmopLT5pbmRleCA9IGFsbG9jX2NvbW1pdF9pbmRleChyKTsKCQlvYmotPnR5cGUgPSB0eXBlOwoJCXJldHVybiBvYmo7Cgl9CgllbHNlIHsKCQlpZiAoIXF1aWV0KQoJCQllcnJvcihfKCJvYmplY3QgJXMgaXMgYSAlcywgbm90IGEgJXMiKSwKCQkJICAgICAgb2lkX3RvX2hleCgmb2JqLT5vaWQpLAoJCQkgICAgICB0eXBlX25hbWUob2JqLT50eXBlKSwgdHlwZV9uYW1lKHR5cGUpKTsKCQlyZXR1cm4gTlVMTDsKCX0KfQoKc3RydWN0IG9iamVjdCAqbG9va3VwX3Vua25vd25fb2JqZWN0KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXN0cnVjdCBvYmplY3QgKm9iaiA9IGxvb2t1cF9vYmplY3QodGhlX3JlcG9zaXRvcnksIHNoYTEpOwoJaWYgKCFvYmopCgkJb2JqID0gY3JlYXRlX29iamVjdCh0aGVfcmVwb3NpdG9yeSwgc2hhMSwKCQkJCSAgICBhbGxvY19vYmplY3Rfbm9kZSh0aGVfcmVwb3NpdG9yeSkpOwoJcmV0dXJuIG9iajsKfQoKc3RydWN0IG9iamVjdCAqcGFyc2Vfb2JqZWN0X2J1ZmZlcihzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBlbnVtIG9iamVjdF90eXBlIHR5cGUsIHVuc2lnbmVkIGxvbmcgc2l6ZSwgdm9pZCAqYnVmZmVyLCBpbnQgKmVhdGVuX3ApCnsKCXN0cnVjdCBvYmplY3QgKm9iajsKCSplYXRlbl9wID0gMDsKCglvYmogPSBOVUxMOwoJaWYgKHR5cGUgPT0gT0JKX0JMT0IpIHsKCQlzdHJ1Y3QgYmxvYiAqYmxvYiA9IGxvb2t1cF9ibG9iKHIsIG9pZCk7CgkJaWYgKGJsb2IpIHsKCQkJaWYgKHBhcnNlX2Jsb2JfYnVmZmVyKGJsb2IsIGJ1ZmZlciwgc2l6ZSkpCgkJCQlyZXR1cm4gTlVMTDsKCQkJb2JqID0gJmJsb2ItPm9iamVjdDsKCQl9Cgl9IGVsc2UgaWYgKHR5cGUgPT0gT0JKX1RSRUUpIHsKCQlzdHJ1Y3QgdHJlZSAqdHJlZSA9IGxvb2t1cF90cmVlKHIsIG9pZCk7CgkJaWYgKHRyZWUpIHsKCQkJb2JqID0gJnRyZWUtPm9iamVjdDsKCQkJaWYgKCF0cmVlLT5idWZmZXIpCgkJCQl0cmVlLT5vYmplY3QucGFyc2VkID0gMDsKCQkJaWYgKCF0cmVlLT5vYmplY3QucGFyc2VkKSB7CgkJCQlpZiAocGFyc2VfdHJlZV9idWZmZXIodHJlZSwgYnVmZmVyLCBzaXplKSkKCQkJCQlyZXR1cm4gTlVMTDsKCQkJCSplYXRlbl9wID0gMTsKCQkJfQoJCX0KCX0gZWxzZSBpZiAodHlwZSA9PSBPQkpfQ09NTUlUKSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gbG9va3VwX2NvbW1pdChyLCBvaWQpOwoJCWlmIChjb21taXQpIHsKCQkJaWYgKHBhcnNlX2NvbW1pdF9idWZmZXIociwgY29tbWl0LCBidWZmZXIsIHNpemUsIDEpKQoJCQkJcmV0dXJuIE5VTEw7CgkJCWlmICghZ2V0X2NhY2hlZF9jb21taXRfYnVmZmVyKHIsIGNvbW1pdCwgTlVMTCkpIHsKCQkJCXNldF9jb21taXRfYnVmZmVyKHIsIGNvbW1pdCwgYnVmZmVyLCBzaXplKTsKCQkJCSplYXRlbl9wID0gMTsKCQkJfQoJCQlvYmogPSAmY29tbWl0LT5vYmplY3Q7CgkJfQoJfSBlbHNlIGlmICh0eXBlID09IE9CSl9UQUcpIHsKCQlzdHJ1Y3QgdGFnICp0YWcgPSBsb29rdXBfdGFnKHIsIG9pZCk7CgkJaWYgKHRhZykgewoJCQlpZiAocGFyc2VfdGFnX2J1ZmZlcihyLCB0YWcsIGJ1ZmZlciwgc2l6ZSkpCgkJCSAgICAgICByZXR1cm4gTlVMTDsKCQkJb2JqID0gJnRhZy0+b2JqZWN0OwoJCX0KCX0gZWxzZSB7CgkJd2FybmluZyhfKCJvYmplY3QgJXMgaGFzIHVua25vd24gdHlwZSBpZCAlZCIpLCBvaWRfdG9faGV4KG9pZCksIHR5cGUpOwoJCW9iaiA9IE5VTEw7Cgl9CglyZXR1cm4gb2JqOwp9CgpzdHJ1Y3Qgb2JqZWN0ICpwYXJzZV9vYmplY3Rfb3JfZGllKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCSAgIGNvbnN0IGNoYXIgKm5hbWUpCnsKCXN0cnVjdCBvYmplY3QgKm8gPSBwYXJzZV9vYmplY3QodGhlX3JlcG9zaXRvcnksIG9pZCk7CglpZiAobykKCQlyZXR1cm4gbzsKCglkaWUoXygidW5hYmxlIHRvIHBhcnNlIG9iamVjdDogJXMiKSwgbmFtZSA/IG5hbWUgOiBvaWRfdG9faGV4KG9pZCkpOwp9CgpzdHJ1Y3Qgb2JqZWN0ICpwYXJzZV9vYmplY3Qoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJdW5zaWduZWQgbG9uZyBzaXplOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJaW50IGVhdGVuOwoJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqcmVwbCA9IGxvb2t1cF9yZXBsYWNlX29iamVjdChyLCBvaWQpOwoJdm9pZCAqYnVmZmVyOwoJc3RydWN0IG9iamVjdCAqb2JqOwoKCW9iaiA9IGxvb2t1cF9vYmplY3Qociwgb2lkLT5oYXNoKTsKCWlmIChvYmogJiYgb2JqLT5wYXJzZWQpCgkJcmV0dXJuIG9iajsKCglpZiAoKG9iaiAmJiBvYmotPnR5cGUgPT0gT0JKX0JMT0IgJiYgcmVwb19oYXNfb2JqZWN0X2ZpbGUociwgb2lkKSkgfHwKCSAgICAoIW9iaiAmJiByZXBvX2hhc19vYmplY3RfZmlsZShyLCBvaWQpICYmCgkgICAgIG9pZF9vYmplY3RfaW5mbyhyLCBvaWQsIE5VTEwpID09IE9CSl9CTE9CKSkgewoJCWlmIChjaGVja19vYmplY3Rfc2lnbmF0dXJlKHJlcGwsIE5VTEwsIDAsIE5VTEwpIDwgMCkgewoJCQllcnJvcihfKCJzaGExIG1pc21hdGNoICVzIiksIG9pZF90b19oZXgob2lkKSk7CgkJCXJldHVybiBOVUxMOwoJCX0KCQlwYXJzZV9ibG9iX2J1ZmZlcihsb29rdXBfYmxvYihyLCBvaWQpLCBOVUxMLCAwKTsKCQlyZXR1cm4gbG9va3VwX29iamVjdChyLCBvaWQtPmhhc2gpOwoJfQoKCWJ1ZmZlciA9IHJlcG9fcmVhZF9vYmplY3RfZmlsZShyLCBvaWQsICZ0eXBlLCAmc2l6ZSk7CglpZiAoYnVmZmVyKSB7CgkJaWYgKGNoZWNrX29iamVjdF9zaWduYXR1cmUocmVwbCwgYnVmZmVyLCBzaXplLCB0eXBlX25hbWUodHlwZSkpIDwgMCkgewoJCQlmcmVlKGJ1ZmZlcik7CgkJCWVycm9yKF8oInNoYTEgbWlzbWF0Y2ggJXMiKSwgb2lkX3RvX2hleChyZXBsKSk7CgkJCXJldHVybiBOVUxMOwoJCX0KCgkJb2JqID0gcGFyc2Vfb2JqZWN0X2J1ZmZlcihyLCBvaWQsIHR5cGUsIHNpemUsCgkJCQkJICBidWZmZXIsICZlYXRlbik7CgkJaWYgKCFlYXRlbikKCQkJZnJlZShidWZmZXIpOwoJCXJldHVybiBvYmo7Cgl9CglyZXR1cm4gTlVMTDsKfQoKc3RydWN0IG9iamVjdF9saXN0ICpvYmplY3RfbGlzdF9pbnNlcnQoc3RydWN0IG9iamVjdCAqaXRlbSwKCQkJCSAgICAgICBzdHJ1Y3Qgb2JqZWN0X2xpc3QgKipsaXN0X3ApCnsKCXN0cnVjdCBvYmplY3RfbGlzdCAqbmV3X2xpc3QgPSB4bWFsbG9jKHNpemVvZihzdHJ1Y3Qgb2JqZWN0X2xpc3QpKTsKCW5ld19saXN0LT5pdGVtID0gaXRlbTsKCW5ld19saXN0LT5uZXh0ID0gKmxpc3RfcDsKCSpsaXN0X3AgPSBuZXdfbGlzdDsKCXJldHVybiBuZXdfbGlzdDsKfQoKaW50IG9iamVjdF9saXN0X2NvbnRhaW5zKHN0cnVjdCBvYmplY3RfbGlzdCAqbGlzdCwgc3RydWN0IG9iamVjdCAqb2JqKQp7Cgl3aGlsZSAobGlzdCkgewoJCWlmIChsaXN0LT5pdGVtID09IG9iaikKCQkJcmV0dXJuIDE7CgkJbGlzdCA9IGxpc3QtPm5leHQ7Cgl9CglyZXR1cm4gMDsKfQoKLyoKICogQSB6ZXJvLWxlbmd0aCBzdHJpbmcgdG8gd2hpY2ggb2JqZWN0X2FycmF5X2VudHJ5OjpuYW1lIGNhbiBiZQogKiBpbml0aWFsaXplZCB3aXRob3V0IHJlcXVpcmluZyBhIG1hbGxvYy9mcmVlLgogKi8Kc3RhdGljIGNoYXIgb2JqZWN0X2FycmF5X3Nsb3BidWZbMV07Cgp2b2lkIGFkZF9vYmplY3RfYXJyYXlfd2l0aF9wYXRoKHN0cnVjdCBvYmplY3QgKm9iaiwgY29uc3QgY2hhciAqbmFtZSwKCQkJCXN0cnVjdCBvYmplY3RfYXJyYXkgKmFycmF5LAoJCQkJdW5zaWduZWQgbW9kZSwgY29uc3QgY2hhciAqcGF0aCkKewoJdW5zaWduZWQgbnIgPSBhcnJheS0+bnI7Cgl1bnNpZ25lZCBhbGxvYyA9IGFycmF5LT5hbGxvYzsKCXN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKm9iamVjdHMgPSBhcnJheS0+b2JqZWN0czsKCXN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKmVudHJ5OwoKCWlmIChuciA+PSBhbGxvYykgewoJCWFsbG9jID0gKGFsbG9jICsgMzIpICogMjsKCQlSRUFMTE9DX0FSUkFZKG9iamVjdHMsIGFsbG9jKTsKCQlhcnJheS0+YWxsb2MgPSBhbGxvYzsKCQlhcnJheS0+b2JqZWN0cyA9IG9iamVjdHM7Cgl9CgllbnRyeSA9ICZvYmplY3RzW25yXTsKCWVudHJ5LT5pdGVtID0gb2JqOwoJaWYgKCFuYW1lKQoJCWVudHJ5LT5uYW1lID0gTlVMTDsKCWVsc2UgaWYgKCEqbmFtZSkKCQkvKiBVc2Ugb3VyIG93biBlbXB0eSBzdHJpbmcgaW5zdGVhZCBvZiBhbGxvY2F0aW5nIG9uZTogKi8KCQllbnRyeS0+bmFtZSA9IG9iamVjdF9hcnJheV9zbG9wYnVmOwoJZWxzZQoJCWVudHJ5LT5uYW1lID0geHN0cmR1cChuYW1lKTsKCWVudHJ5LT5tb2RlID0gbW9kZTsKCWlmIChwYXRoKQoJCWVudHJ5LT5wYXRoID0geHN0cmR1cChwYXRoKTsKCWVsc2UKCQllbnRyeS0+cGF0aCA9IE5VTEw7CglhcnJheS0+bnIgPSArK25yOwp9Cgp2b2lkIGFkZF9vYmplY3RfYXJyYXkoc3RydWN0IG9iamVjdCAqb2JqLCBjb25zdCBjaGFyICpuYW1lLCBzdHJ1Y3Qgb2JqZWN0X2FycmF5ICphcnJheSkKewoJYWRkX29iamVjdF9hcnJheV93aXRoX3BhdGgob2JqLCBuYW1lLCBhcnJheSwgU19JRklOVkFMSUQsIE5VTEwpOwp9CgovKgogKiBGcmVlIGFsbCBtZW1vcnkgYXNzb2NpYXRlZCB3aXRoIGFuIGVudHJ5OyB0aGUgcmVzdWx0IGlzCiAqIGluIGFuIHVuc3BlY2lmaWVkIHN0YXRlIGFuZCBzaG91bGQgbm90IGJlIGV4YW1pbmVkLgogKi8Kc3RhdGljIHZvaWQgb2JqZWN0X2FycmF5X3JlbGVhc2VfZW50cnkoc3RydWN0IG9iamVjdF9hcnJheV9lbnRyeSAqZW50KQp7CglpZiAoZW50LT5uYW1lICE9IG9iamVjdF9hcnJheV9zbG9wYnVmKQoJCWZyZWUoZW50LT5uYW1lKTsKCWZyZWUoZW50LT5wYXRoKTsKfQoKc3RydWN0IG9iamVjdCAqb2JqZWN0X2FycmF5X3BvcChzdHJ1Y3Qgb2JqZWN0X2FycmF5ICphcnJheSkKewoJc3RydWN0IG9iamVjdCAqcmV0OwoKCWlmICghYXJyYXktPm5yKQoJCXJldHVybiBOVUxMOwoKCXJldCA9IGFycmF5LT5vYmplY3RzW2FycmF5LT5uciAtIDFdLml0ZW07CglvYmplY3RfYXJyYXlfcmVsZWFzZV9lbnRyeSgmYXJyYXktPm9iamVjdHNbYXJyYXktPm5yIC0gMV0pOwoJYXJyYXktPm5yLS07CglyZXR1cm4gcmV0Owp9Cgp2b2lkIG9iamVjdF9hcnJheV9maWx0ZXIoc3RydWN0IG9iamVjdF9hcnJheSAqYXJyYXksCgkJCSBvYmplY3RfYXJyYXlfZWFjaF9mdW5jX3Qgd2FudCwgdm9pZCAqY2JfZGF0YSkKewoJdW5zaWduZWQgbnIgPSBhcnJheS0+bnIsIHNyYywgZHN0OwoJc3RydWN0IG9iamVjdF9hcnJheV9lbnRyeSAqb2JqZWN0cyA9IGFycmF5LT5vYmplY3RzOwoKCWZvciAoc3JjID0gZHN0ID0gMDsgc3JjIDwgbnI7IHNyYysrKSB7CgkJaWYgKHdhbnQoJm9iamVjdHNbc3JjXSwgY2JfZGF0YSkpIHsKCQkJaWYgKHNyYyAhPSBkc3QpCgkJCQlvYmplY3RzW2RzdF0gPSBvYmplY3RzW3NyY107CgkJCWRzdCsrOwoJCX0gZWxzZSB7CgkJCW9iamVjdF9hcnJheV9yZWxlYXNlX2VudHJ5KCZvYmplY3RzW3NyY10pOwoJCX0KCX0KCWFycmF5LT5uciA9IGRzdDsKfQoKdm9pZCBvYmplY3RfYXJyYXlfY2xlYXIoc3RydWN0IG9iamVjdF9hcnJheSAqYXJyYXkpCnsKCWludCBpOwoJZm9yIChpID0gMDsgaSA8IGFycmF5LT5ucjsgaSsrKQoJCW9iamVjdF9hcnJheV9yZWxlYXNlX2VudHJ5KCZhcnJheS0+b2JqZWN0c1tpXSk7CglGUkVFX0FORF9OVUxMKGFycmF5LT5vYmplY3RzKTsKCWFycmF5LT5uciA9IGFycmF5LT5hbGxvYyA9IDA7Cn0KCi8qCiAqIFJldHVybiB0cnVlIGlmZiBhcnJheSBhbHJlYWR5IGNvbnRhaW5zIGFuIGVudHJ5IHdpdGggbmFtZS4KICovCnN0YXRpYyBpbnQgY29udGFpbnNfbmFtZShzdHJ1Y3Qgb2JqZWN0X2FycmF5ICphcnJheSwgY29uc3QgY2hhciAqbmFtZSkKewoJdW5zaWduZWQgbnIgPSBhcnJheS0+bnIsIGk7CglzdHJ1Y3Qgb2JqZWN0X2FycmF5X2VudHJ5ICpvYmplY3QgPSBhcnJheS0+b2JqZWN0czsKCglmb3IgKGkgPSAwOyBpIDwgbnI7IGkrKywgb2JqZWN0KyspCgkJaWYgKCFzdHJjbXAob2JqZWN0LT5uYW1lLCBuYW1lKSkKCQkJcmV0dXJuIDE7CglyZXR1cm4gMDsKfQoKdm9pZCBvYmplY3RfYXJyYXlfcmVtb3ZlX2R1cGxpY2F0ZXMoc3RydWN0IG9iamVjdF9hcnJheSAqYXJyYXkpCnsKCXVuc2lnbmVkIG5yID0gYXJyYXktPm5yLCBzcmM7CglzdHJ1Y3Qgb2JqZWN0X2FycmF5X2VudHJ5ICpvYmplY3RzID0gYXJyYXktPm9iamVjdHM7CgoJYXJyYXktPm5yID0gMDsKCWZvciAoc3JjID0gMDsgc3JjIDwgbnI7IHNyYysrKSB7CgkJaWYgKCFjb250YWluc19uYW1lKGFycmF5LCBvYmplY3RzW3NyY10ubmFtZSkpIHsKCQkJaWYgKHNyYyAhPSBhcnJheS0+bnIpCgkJCQlvYmplY3RzW2FycmF5LT5ucl0gPSBvYmplY3RzW3NyY107CgkJCWFycmF5LT5ucisrOwoJCX0gZWxzZSB7CgkJCW9iamVjdF9hcnJheV9yZWxlYXNlX2VudHJ5KCZvYmplY3RzW3NyY10pOwoJCX0KCX0KfQoKdm9pZCBjbGVhcl9vYmplY3RfZmxhZ3ModW5zaWduZWQgZmxhZ3MpCnsKCWludCBpOwoKCWZvciAoaT0wOyBpIDwgdGhlX3JlcG9zaXRvcnktPnBhcnNlZF9vYmplY3RzLT5vYmpfaGFzaF9zaXplOyBpKyspIHsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmogPSB0aGVfcmVwb3NpdG9yeS0+cGFyc2VkX29iamVjdHMtPm9ial9oYXNoW2ldOwoJCWlmIChvYmopCgkJCW9iai0+ZmxhZ3MgJj0gfmZsYWdzOwoJfQp9Cgp2b2lkIGNsZWFyX2NvbW1pdF9tYXJrc19hbGwodW5zaWduZWQgaW50IGZsYWdzKQp7CglpbnQgaTsKCglmb3IgKGkgPSAwOyBpIDwgdGhlX3JlcG9zaXRvcnktPnBhcnNlZF9vYmplY3RzLT5vYmpfaGFzaF9zaXplOyBpKyspIHsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmogPSB0aGVfcmVwb3NpdG9yeS0+cGFyc2VkX29iamVjdHMtPm9ial9oYXNoW2ldOwoJCWlmIChvYmogJiYgb2JqLT50eXBlID09IE9CSl9DT01NSVQpCgkJCW9iai0+ZmxhZ3MgJj0gfmZsYWdzOwoJfQp9CgpzdHJ1Y3QgcGFyc2VkX29iamVjdF9wb29sICpwYXJzZWRfb2JqZWN0X3Bvb2xfbmV3KHZvaWQpCnsKCXN0cnVjdCBwYXJzZWRfb2JqZWN0X3Bvb2wgKm8gPSB4bWFsbG9jKHNpemVvZigqbykpOwoJbWVtc2V0KG8sIDAsIHNpemVvZigqbykpOwoKCW8tPmJsb2Jfc3RhdGUgPSBhbGxvY2F0ZV9hbGxvY19zdGF0ZSgpOwoJby0+dHJlZV9zdGF0ZSA9IGFsbG9jYXRlX2FsbG9jX3N0YXRlKCk7CglvLT5jb21taXRfc3RhdGUgPSBhbGxvY2F0ZV9hbGxvY19zdGF0ZSgpOwoJby0+dGFnX3N0YXRlID0gYWxsb2NhdGVfYWxsb2Nfc3RhdGUoKTsKCW8tPm9iamVjdF9zdGF0ZSA9IGFsbG9jYXRlX2FsbG9jX3N0YXRlKCk7CgoJby0+aXNfc2hhbGxvdyA9IC0xOwoJby0+c2hhbGxvd19zdGF0ID0geGNhbGxvYygxLCBzaXplb2YoKm8tPnNoYWxsb3dfc3RhdCkpOwoKCW8tPmJ1ZmZlcl9zbGFiID0gYWxsb2NhdGVfY29tbWl0X2J1ZmZlcl9zbGFiKCk7CgoJcmV0dXJuIG87Cn0KCnN0cnVjdCByYXdfb2JqZWN0X3N0b3JlICpyYXdfb2JqZWN0X3N0b3JlX25ldyh2b2lkKQp7CglzdHJ1Y3QgcmF3X29iamVjdF9zdG9yZSAqbyA9IHhtYWxsb2Moc2l6ZW9mKCpvKSk7CgoJbWVtc2V0KG8sIDAsIHNpemVvZigqbykpOwoJSU5JVF9MSVNUX0hFQUQoJm8tPnBhY2tlZF9naXRfbXJ1KTsKCXJldHVybiBvOwp9CgpzdGF0aWMgdm9pZCBmcmVlX2FsdF9vZGIoc3RydWN0IGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UgKmFsdCkKewoJc3RyYnVmX3JlbGVhc2UoJmFsdC0+c2NyYXRjaCk7CglvaWRfYXJyYXlfY2xlYXIoJmFsdC0+bG9vc2Vfb2JqZWN0c19jYWNoZSk7CglmcmVlKGFsdCk7Cn0KCnN0YXRpYyB2b2lkIGZyZWVfYWx0X29kYnMoc3RydWN0IHJhd19vYmplY3Rfc3RvcmUgKm8pCnsKCXdoaWxlIChvLT5hbHRfb2RiX2xpc3QpIHsKCQlzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSAqbmV4dDsKCgkJbmV4dCA9IG8tPmFsdF9vZGJfbGlzdC0+bmV4dDsKCQlmcmVlX2FsdF9vZGIoby0+YWx0X29kYl9saXN0KTsKCQlvLT5hbHRfb2RiX2xpc3QgPSBuZXh0OwoJfQp9Cgp2b2lkIHJhd19vYmplY3Rfc3RvcmVfY2xlYXIoc3RydWN0IHJhd19vYmplY3Rfc3RvcmUgKm8pCnsKCUZSRUVfQU5EX05VTEwoby0+b2JqZWN0ZGlyKTsKCUZSRUVfQU5EX05VTEwoby0+YWx0ZXJuYXRlX2RiKTsKCglvaWRtYXBfZnJlZShvLT5yZXBsYWNlX21hcCwgMSk7CglGUkVFX0FORF9OVUxMKG8tPnJlcGxhY2VfbWFwKTsKCglmcmVlX2NvbW1pdF9ncmFwaChvLT5jb21taXRfZ3JhcGgpOwoJby0+Y29tbWl0X2dyYXBoID0gTlVMTDsKCW8tPmNvbW1pdF9ncmFwaF9hdHRlbXB0ZWQgPSAwOwoKCWZyZWVfYWx0X29kYnMobyk7CglvLT5hbHRfb2RiX3RhaWwgPSBOVUxMOwoKCUlOSVRfTElTVF9IRUFEKCZvLT5wYWNrZWRfZ2l0X21ydSk7CgljbG9zZV9hbGxfcGFja3Mobyk7CglvLT5wYWNrZWRfZ2l0ID0gTlVMTDsKfQoKdm9pZCBwYXJzZWRfb2JqZWN0X3Bvb2xfY2xlYXIoc3RydWN0IHBhcnNlZF9vYmplY3RfcG9vbCAqbykKewoJLyoKCSAqIEFzIG9iamVjdHMgYXJlIGFsbG9jYXRlZCBpbiBzbGFicyAoc2VlIGFsbG9jLmMpLCB3ZSBkbwoJICogbm90IG5lZWQgdG8gZnJlZSBlYWNoIG9iamVjdCwgYnV0IGVhY2ggc2xhYiBpbnN0ZWFkLgoJICoKCSAqIEJlZm9yZSBkb2luZyBzbywgd2UgbmVlZCB0byBmcmVlIGFueSBhZGRpdGlvbmFsIG1lbW9yeQoJICogdGhlIG9iamVjdHMgbWF5IGhvbGQuCgkgKi8KCXVuc2lnbmVkIGk7CgoJZm9yIChpID0gMDsgaSA8IG8tPm9ial9oYXNoX3NpemU7IGkrKykgewoJCXN0cnVjdCBvYmplY3QgKm9iaiA9IG8tPm9ial9oYXNoW2ldOwoKCQlpZiAoIW9iaikKCQkJY29udGludWU7CgoJCWlmIChvYmotPnR5cGUgPT0gT0JKX1RSRUUpCgkJCWZyZWVfdHJlZV9idWZmZXIoKHN0cnVjdCB0cmVlKilvYmopOwoJCWVsc2UgaWYgKG9iai0+dHlwZSA9PSBPQkpfQ09NTUlUKQoJCQlyZWxlYXNlX2NvbW1pdF9tZW1vcnkoKHN0cnVjdCBjb21taXQqKW9iaik7CgkJZWxzZSBpZiAob2JqLT50eXBlID09IE9CSl9UQUcpCgkJCXJlbGVhc2VfdGFnX21lbW9yeSgoc3RydWN0IHRhZyopb2JqKTsKCX0KCglGUkVFX0FORF9OVUxMKG8tPm9ial9oYXNoKTsKCW8tPm9ial9oYXNoX3NpemUgPSAwOwoKCWZyZWVfY29tbWl0X2J1ZmZlcl9zbGFiKG8tPmJ1ZmZlcl9zbGFiKTsKCW8tPmJ1ZmZlcl9zbGFiID0gTlVMTDsKCgljbGVhcl9hbGxvY19zdGF0ZShvLT5ibG9iX3N0YXRlKTsKCWNsZWFyX2FsbG9jX3N0YXRlKG8tPnRyZWVfc3RhdGUpOwoJY2xlYXJfYWxsb2Nfc3RhdGUoby0+Y29tbWl0X3N0YXRlKTsKCWNsZWFyX2FsbG9jX3N0YXRlKG8tPnRhZ19zdGF0ZSk7CgljbGVhcl9hbGxvY19zdGF0ZShvLT5vYmplY3Rfc3RhdGUpOwoJRlJFRV9BTkRfTlVMTChvLT5ibG9iX3N0YXRlKTsKCUZSRUVfQU5EX05VTEwoby0+dHJlZV9zdGF0ZSk7CglGUkVFX0FORF9OVUxMKG8tPmNvbW1pdF9zdGF0ZSk7CglGUkVFX0FORF9OVUxMKG8tPnRhZ19zdGF0ZSk7CglGUkVFX0FORF9OVUxMKG8tPm9iamVjdF9zdGF0ZSk7Cn0K",
    "text": "#include \"cache.h\"\n#include \"object.h\"\n#include \"replace-object.h\"\n#include \"object-store.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"alloc.h\"\n#include \"object-store.h\"\n#include \"packfile.h\"\n#include \"commit-graph.h\"\n\nunsigned int get_max_object_index(void)\n{\n\treturn the_repository->parsed_objects->obj_hash_size;\n}\n\nstruct object *get_indexed_object(unsigned int idx)\n{\n\treturn the_repository->parsed_objects->obj_hash[idx];\n}\n\nstatic const char *object_type_strings[] = {\n\tNULL,\t\t/* OBJ_NONE = 0 */\n\t\"commit\",\t/* OBJ_COMMIT = 1 */\n\t\"tree\",\t\t/* OBJ_TREE = 2 */\n\t\"blob\",\t\t/* OBJ_BLOB = 3 */\n\t\"tag\",\t\t/* OBJ_TAG = 4 */\n};\n\nconst char *type_name(unsigned int type)\n{\n\tif (type >= ARRAY_SIZE(object_type_strings))\n\t\treturn NULL;\n\treturn object_type_strings[type];\n}\n\nint type_from_string_gently(const char *str, ssize_t len, int gentle)\n{\n\tint i;\n\n\tif (len < 0)\n\t\tlen = strlen(str);\n\n\tfor (i = 1; i < ARRAY_SIZE(object_type_strings); i++)\n\t\tif (!strncmp(str, object_type_strings[i], len) &&\n\t\t    object_type_strings[i][len] == '\\0')\n\t\t\treturn i;\n\n\tif (gentle)\n\t\treturn -1;\n\n\tdie(_(\"invalid object type \\\"%s\\\"\"), str);\n}\n\n/*\n * Return a numerical hash value between 0 and n-1 for the object with\n * the specified sha1.  n must be a power of 2.  Please note that the\n * return value is *not* consistent across computer architectures.\n */\nstatic unsigned int hash_obj(const unsigned char *sha1, unsigned int n)\n{\n\treturn sha1hash(sha1) & (n - 1);\n}\n\n/*\n * Insert obj into the hash table hash, which has length size (which\n * must be a power of 2).  On collisions, simply overflow to the next\n * empty bucket.\n */\nstatic void insert_obj_hash(struct object *obj, struct object **hash, unsigned int size)\n{\n\tunsigned int j = hash_obj(obj->oid.hash, size);\n\n\twhile (hash[j]) {\n\t\tj++;\n\t\tif (j >= size)\n\t\t\tj = 0;\n\t}\n\thash[j] = obj;\n}\n\n/*\n * Look up the record for the given sha1 in the hash map stored in\n * obj_hash.  Return NULL if it was not found.\n */\nstruct object *lookup_object(struct repository *r, const unsigned char *sha1)\n{\n\tunsigned int i, first;\n\tstruct object *obj;\n\n\tif (!r->parsed_objects->obj_hash)\n\t\treturn NULL;\n\n\tfirst = i = hash_obj(sha1, r->parsed_objects->obj_hash_size);\n\twhile ((obj = r->parsed_objects->obj_hash[i]) != NULL) {\n\t\tif (hasheq(sha1, obj->oid.hash))\n\t\t\tbreak;\n\t\ti++;\n\t\tif (i == r->parsed_objects->obj_hash_size)\n\t\t\ti = 0;\n\t}\n\tif (obj && i != first) {\n\t\t/*\n\t\t * Move object to where we started to look for it so\n\t\t * that we do not need to walk the hash table the next\n\t\t * time we look for it.\n\t\t */\n\t\tSWAP(r->parsed_objects->obj_hash[i],\n\t\t     r->parsed_objects->obj_hash[first]);\n\t}\n\treturn obj;\n}\n\n/*\n * Increase the size of the hash map stored in obj_hash to the next\n * power of 2 (but at least 32).  Copy the existing values to the new\n * hash map.\n */\nstatic void grow_object_hash(struct repository *r)\n{\n\tint i;\n\t/*\n\t * Note that this size must always be power-of-2 to match hash_obj\n\t * above.\n\t */\n\tint new_hash_size = r->parsed_objects->obj_hash_size < 32 ? 32 : 2 * r->parsed_objects->obj_hash_size;\n\tstruct object **new_hash;\n\n\tnew_hash = xcalloc(new_hash_size, sizeof(struct object *));\n\tfor (i = 0; i < r->parsed_objects->obj_hash_size; i++) {\n\t\tstruct object *obj = r->parsed_objects->obj_hash[i];\n\n\t\tif (!obj)\n\t\t\tcontinue;\n\t\tinsert_obj_hash(obj, new_hash, new_hash_size);\n\t}\n\tfree(r->parsed_objects->obj_hash);\n\tr->parsed_objects->obj_hash = new_hash;\n\tr->parsed_objects->obj_hash_size = new_hash_size;\n}\n\nvoid *create_object(struct repository *r, const unsigned char *sha1, void *o)\n{\n\tstruct object *obj = o;\n\n\tobj->parsed = 0;\n\tobj->flags = 0;\n\thashcpy(obj->oid.hash, sha1);\n\n\tif (r->parsed_objects->obj_hash_size - 1 <= r->parsed_objects->nr_objs * 2)\n\t\tgrow_object_hash(r);\n\n\tinsert_obj_hash(obj, r->parsed_objects->obj_hash,\n\t\t\tr->parsed_objects->obj_hash_size);\n\tr->parsed_objects->nr_objs++;\n\treturn obj;\n}\n\nvoid *object_as_type(struct repository *r, struct object *obj, enum object_type type, int quiet)\n{\n\tif (obj->type == type)\n\t\treturn obj;\n\telse if (obj->type == OBJ_NONE) {\n\t\tif (type == OBJ_COMMIT)\n\t\t\t((struct commit *)obj)->index = alloc_commit_index(r);\n\t\tobj->type = type;\n\t\treturn obj;\n\t}\n\telse {\n\t\tif (!quiet)\n\t\t\terror(_(\"object %s is a %s, not a %s\"),\n\t\t\t      oid_to_hex(&obj->oid),\n\t\t\t      type_name(obj->type), type_name(type));\n\t\treturn NULL;\n\t}\n}\n\nstruct object *lookup_unknown_object(const unsigned char *sha1)\n{\n\tstruct object *obj = lookup_object(the_repository, sha1);\n\tif (!obj)\n\t\tobj = create_object(the_repository, sha1,\n\t\t\t\t    alloc_object_node(the_repository));\n\treturn obj;\n}\n\nstruct object *parse_object_buffer(struct repository *r, const struct object_id *oid, enum object_type type, unsigned long size, void *buffer, int *eaten_p)\n{\n\tstruct object *obj;\n\t*eaten_p = 0;\n\n\tobj = NULL;\n\tif (type == OBJ_BLOB) {\n\t\tstruct blob *blob = lookup_blob(r, oid);\n\t\tif (blob) {\n\t\t\tif (parse_blob_buffer(blob, buffer, size))\n\t\t\t\treturn NULL;\n\t\t\tobj = &blob->object;\n\t\t}\n\t} else if (type == OBJ_TREE) {\n\t\tstruct tree *tree = lookup_tree(r, oid);\n\t\tif (tree) {\n\t\t\tobj = &tree->object;\n\t\t\tif (!tree->buffer)\n\t\t\t\ttree->object.parsed = 0;\n\t\t\tif (!tree->object.parsed) {\n\t\t\t\tif (parse_tree_buffer(tree, buffer, size))\n\t\t\t\t\treturn NULL;\n\t\t\t\t*eaten_p = 1;\n\t\t\t}\n\t\t}\n\t} else if (type == OBJ_COMMIT) {\n\t\tstruct commit *commit = lookup_commit(r, oid);\n\t\tif (commit) {\n\t\t\tif (parse_commit_buffer(r, commit, buffer, size, 1))\n\t\t\t\treturn NULL;\n\t\t\tif (!get_cached_commit_buffer(r, commit, NULL)) {\n\t\t\t\tset_commit_buffer(r, commit, buffer, size);\n\t\t\t\t*eaten_p = 1;\n\t\t\t}\n\t\t\tobj = &commit->object;\n\t\t}\n\t} else if (type == OBJ_TAG) {\n\t\tstruct tag *tag = lookup_tag(r, oid);\n\t\tif (tag) {\n\t\t\tif (parse_tag_buffer(r, tag, buffer, size))\n\t\t\t       return NULL;\n\t\t\tobj = &tag->object;\n\t\t}\n\t} else {\n\t\twarning(_(\"object %s has unknown type id %d\"), oid_to_hex(oid), type);\n\t\tobj = NULL;\n\t}\n\treturn obj;\n}\n\nstruct object *parse_object_or_die(const struct object_id *oid,\n\t\t\t\t   const char *name)\n{\n\tstruct object *o = parse_object(the_repository, oid);\n\tif (o)\n\t\treturn o;\n\n\tdie(_(\"unable to parse object: %s\"), name ? name : oid_to_hex(oid));\n}\n\nstruct object *parse_object(struct repository *r, const struct object_id *oid)\n{\n\tunsigned long size;\n\tenum object_type type;\n\tint eaten;\n\tconst struct object_id *repl = lookup_replace_object(r, oid);\n\tvoid *buffer;\n\tstruct object *obj;\n\n\tobj = lookup_object(r, oid->hash);\n\tif (obj && obj->parsed)\n\t\treturn obj;\n\n\tif ((obj && obj->type == OBJ_BLOB && repo_has_object_file(r, oid)) ||\n\t    (!obj && repo_has_object_file(r, oid) &&\n\t     oid_object_info(r, oid, NULL) == OBJ_BLOB)) {\n\t\tif (check_object_signature(repl, NULL, 0, NULL) < 0) {\n\t\t\terror(_(\"sha1 mismatch %s\"), oid_to_hex(oid));\n\t\t\treturn NULL;\n\t\t}\n\t\tparse_blob_buffer(lookup_blob(r, oid), NULL, 0);\n\t\treturn lookup_object(r, oid->hash);\n\t}\n\n\tbuffer = repo_read_object_file(r, oid, &type, &size);\n\tif (buffer) {\n\t\tif (check_object_signature(repl, buffer, size, type_name(type)) < 0) {\n\t\t\tfree(buffer);\n\t\t\terror(_(\"sha1 mismatch %s\"), oid_to_hex(repl));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tobj = parse_object_buffer(r, oid, type, size,\n\t\t\t\t\t  buffer, &eaten);\n\t\tif (!eaten)\n\t\t\tfree(buffer);\n\t\treturn obj;\n\t}\n\treturn NULL;\n}\n\nstruct object_list *object_list_insert(struct object *item,\n\t\t\t\t       struct object_list **list_p)\n{\n\tstruct object_list *new_list = xmalloc(sizeof(struct object_list));\n\tnew_list->item = item;\n\tnew_list->next = *list_p;\n\t*list_p = new_list;\n\treturn new_list;\n}\n\nint object_list_contains(struct object_list *list, struct object *obj)\n{\n\twhile (list) {\n\t\tif (list->item == obj)\n\t\t\treturn 1;\n\t\tlist = list->next;\n\t}\n\treturn 0;\n}\n\n/*\n * A zero-length string to which object_array_entry::name can be\n * initialized without requiring a malloc/free.\n */\nstatic char object_array_slopbuf[1];\n\nvoid add_object_array_with_path(struct object *obj, const char *name,\n\t\t\t\tstruct object_array *array,\n\t\t\t\tunsigned mode, const char *path)\n{\n\tunsigned nr = array->nr;\n\tunsigned alloc = array->alloc;\n\tstruct object_array_entry *objects = array->objects;\n\tstruct object_array_entry *entry;\n\n\tif (nr >= alloc) {\n\t\talloc = (alloc + 32) * 2;\n\t\tREALLOC_ARRAY(objects, alloc);\n\t\tarray->alloc = alloc;\n\t\tarray->objects = objects;\n\t}\n\tentry = &objects[nr];\n\tentry->item = obj;\n\tif (!name)\n\t\tentry->name = NULL;\n\telse if (!*name)\n\t\t/* Use our own empty string instead of allocating one: */\n\t\tentry->name = object_array_slopbuf;\n\telse\n\t\tentry->name = xstrdup(name);\n\tentry->mode = mode;\n\tif (path)\n\t\tentry->path = xstrdup(path);\n\telse\n\t\tentry->path = NULL;\n\tarray->nr = ++nr;\n}\n\nvoid add_object_array(struct object *obj, const char *name, struct object_array *array)\n{\n\tadd_object_array_with_path(obj, name, array, S_IFINVALID, NULL);\n}\n\n/*\n * Free all memory associated with an entry; the result is\n * in an unspecified state and should not be examined.\n */\nstatic void object_array_release_entry(struct object_array_entry *ent)\n{\n\tif (ent->name != object_array_slopbuf)\n\t\tfree(ent->name);\n\tfree(ent->path);\n}\n\nstruct object *object_array_pop(struct object_array *array)\n{\n\tstruct object *ret;\n\n\tif (!array->nr)\n\t\treturn NULL;\n\n\tret = array->objects[array->nr - 1].item;\n\tobject_array_release_entry(&array->objects[array->nr - 1]);\n\tarray->nr--;\n\treturn ret;\n}\n\nvoid object_array_filter(struct object_array *array,\n\t\t\t object_array_each_func_t want, void *cb_data)\n{\n\tunsigned nr = array->nr, src, dst;\n\tstruct object_array_entry *objects = array->objects;\n\n\tfor (src = dst = 0; src < nr; src++) {\n\t\tif (want(&objects[src], cb_data)) {\n\t\t\tif (src != dst)\n\t\t\t\tobjects[dst] = objects[src];\n\t\t\tdst++;\n\t\t} else {\n\t\t\tobject_array_release_entry(&objects[src]);\n\t\t}\n\t}\n\tarray->nr = dst;\n}\n\nvoid object_array_clear(struct object_array *array)\n{\n\tint i;\n\tfor (i = 0; i < array->nr; i++)\n\t\tobject_array_release_entry(&array->objects[i]);\n\tFREE_AND_NULL(array->objects);\n\tarray->nr = array->alloc = 0;\n}\n\n/*\n * Return true iff array already contains an entry with name.\n */\nstatic int contains_name(struct object_array *array, const char *name)\n{\n\tunsigned nr = array->nr, i;\n\tstruct object_array_entry *object = array->objects;\n\n\tfor (i = 0; i < nr; i++, object++)\n\t\tif (!strcmp(object->name, name))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nvoid object_array_remove_duplicates(struct object_array *array)\n{\n\tunsigned nr = array->nr, src;\n\tstruct object_array_entry *objects = array->objects;\n\n\tarray->nr = 0;\n\tfor (src = 0; src < nr; src++) {\n\t\tif (!contains_name(array, objects[src].name)) {\n\t\t\tif (src != array->nr)\n\t\t\t\tobjects[array->nr] = objects[src];\n\t\t\tarray->nr++;\n\t\t} else {\n\t\t\tobject_array_release_entry(&objects[src]);\n\t\t}\n\t}\n}\n\nvoid clear_object_flags(unsigned flags)\n{\n\tint i;\n\n\tfor (i=0; i < the_repository->parsed_objects->obj_hash_size; i++) {\n\t\tstruct object *obj = the_repository->parsed_objects->obj_hash[i];\n\t\tif (obj)\n\t\t\tobj->flags &= ~flags;\n\t}\n}\n\nvoid clear_commit_marks_all(unsigned int flags)\n{\n\tint i;\n\n\tfor (i = 0; i < the_repository->parsed_objects->obj_hash_size; i++) {\n\t\tstruct object *obj = the_repository->parsed_objects->obj_hash[i];\n\t\tif (obj && obj->type == OBJ_COMMIT)\n\t\t\tobj->flags &= ~flags;\n\t}\n}\n\nstruct parsed_object_pool *parsed_object_pool_new(void)\n{\n\tstruct parsed_object_pool *o = xmalloc(sizeof(*o));\n\tmemset(o, 0, sizeof(*o));\n\n\to->blob_state = allocate_alloc_state();\n\to->tree_state = allocate_alloc_state();\n\to->commit_state = allocate_alloc_state();\n\to->tag_state = allocate_alloc_state();\n\to->object_state = allocate_alloc_state();\n\n\to->is_shallow = -1;\n\to->shallow_stat = xcalloc(1, sizeof(*o->shallow_stat));\n\n\to->buffer_slab = allocate_commit_buffer_slab();\n\n\treturn o;\n}\n\nstruct raw_object_store *raw_object_store_new(void)\n{\n\tstruct raw_object_store *o = xmalloc(sizeof(*o));\n\n\tmemset(o, 0, sizeof(*o));\n\tINIT_LIST_HEAD(&o->packed_git_mru);\n\treturn o;\n}\n\nstatic void free_alt_odb(struct alternate_object_database *alt)\n{\n\tstrbuf_release(&alt->scratch);\n\toid_array_clear(&alt->loose_objects_cache);\n\tfree(alt);\n}\n\nstatic void free_alt_odbs(struct raw_object_store *o)\n{\n\twhile (o->alt_odb_list) {\n\t\tstruct alternate_object_database *next;\n\n\t\tnext = o->alt_odb_list->next;\n\t\tfree_alt_odb(o->alt_odb_list);\n\t\to->alt_odb_list = next;\n\t}\n}\n\nvoid raw_object_store_clear(struct raw_object_store *o)\n{\n\tFREE_AND_NULL(o->objectdir);\n\tFREE_AND_NULL(o->alternate_db);\n\n\toidmap_free(o->replace_map, 1);\n\tFREE_AND_NULL(o->replace_map);\n\n\tfree_commit_graph(o->commit_graph);\n\to->commit_graph = NULL;\n\to->commit_graph_attempted = 0;\n\n\tfree_alt_odbs(o);\n\to->alt_odb_tail = NULL;\n\n\tINIT_LIST_HEAD(&o->packed_git_mru);\n\tclose_all_packs(o);\n\to->packed_git = NULL;\n}\n\nvoid parsed_object_pool_clear(struct parsed_object_pool *o)\n{\n\t/*\n\t * As objects are allocated in slabs (see alloc.c), we do\n\t * not need to free each object, but each slab instead.\n\t *\n\t * Before doing so, we need to free any additional memory\n\t * the objects may hold.\n\t */\n\tunsigned i;\n\n\tfor (i = 0; i < o->obj_hash_size; i++) {\n\t\tstruct object *obj = o->obj_hash[i];\n\n\t\tif (!obj)\n\t\t\tcontinue;\n\n\t\tif (obj->type == OBJ_TREE)\n\t\t\tfree_tree_buffer((struct tree*)obj);\n\t\telse if (obj->type == OBJ_COMMIT)\n\t\t\trelease_commit_memory((struct commit*)obj);\n\t\telse if (obj->type == OBJ_TAG)\n\t\t\trelease_tag_memory((struct tag*)obj);\n\t}\n\n\tFREE_AND_NULL(o->obj_hash);\n\to->obj_hash_size = 0;\n\n\tfree_commit_buffer_slab(o->buffer_slab);\n\to->buffer_slab = NULL;\n\n\tclear_alloc_state(o->blob_state);\n\tclear_alloc_state(o->tree_state);\n\tclear_alloc_state(o->commit_state);\n\tclear_alloc_state(o->tag_state);\n\tclear_alloc_state(o->object_state);\n\tFREE_AND_NULL(o->blob_state);\n\tFREE_AND_NULL(o->tree_state);\n\tFREE_AND_NULL(o->commit_state);\n\tFREE_AND_NULL(o->tag_state);\n\tFREE_AND_NULL(o->object_state);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "003f8704844c5a6c70b719d87494e535719de044",
  "sha1_ok": true,
  "size": 13653
}
