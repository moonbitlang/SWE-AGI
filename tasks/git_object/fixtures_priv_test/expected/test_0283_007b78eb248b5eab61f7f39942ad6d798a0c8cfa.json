{
  "content": {
    "base64": "I2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgoKI2RlZmluZSBPUFRfU0hPUlQgMQojZGVmaW5lIE9QVF9VTlNFVCAyCgpzdGF0aWMgaW5saW5lIGNvbnN0IGNoYXIgKmdldF9hcmcoc3RydWN0IHBhcnNlX29wdF9jdHhfdCAqcCkKewoJaWYgKHAtPm9wdCkgewoJCWNvbnN0IGNoYXIgKnJlcyA9IHAtPm9wdDsKCQlwLT5vcHQgPSBOVUxMOwoJCXJldHVybiByZXM7Cgl9CglwLT5hcmdjLS07CglyZXR1cm4gKisrcC0+YXJndjsKfQoKc3RhdGljIGlubGluZSBjb25zdCBjaGFyICpza2lwX3ByZWZpeChjb25zdCBjaGFyICpzdHIsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc2l6ZV90IGxlbiA9IHN0cmxlbihwcmVmaXgpOwoJcmV0dXJuIHN0cm5jbXAoc3RyLCBwcmVmaXgsIGxlbikgPyBOVUxMIDogc3RyICsgbGVuOwp9CgpzdGF0aWMgaW50IG9wdGVycm9yKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqcmVhc29uLCBpbnQgZmxhZ3MpCnsKCWlmIChmbGFncyAmIE9QVF9TSE9SVCkKCQlyZXR1cm4gZXJyb3IoInN3aXRjaCBgJWMnICVzIiwgb3B0LT5zaG9ydF9uYW1lLCByZWFzb24pOwoJaWYgKGZsYWdzICYgT1BUX1VOU0VUKQoJCXJldHVybiBlcnJvcigib3B0aW9uIGBuby0lcycgJXMiLCBvcHQtPmxvbmdfbmFtZSwgcmVhc29uKTsKCXJldHVybiBlcnJvcigib3B0aW9uIGAlcycgJXMiLCBvcHQtPmxvbmdfbmFtZSwgcmVhc29uKTsKfQoKc3RhdGljIGludCBnZXRfdmFsdWUoc3RydWN0IHBhcnNlX29wdF9jdHhfdCAqcCwKICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBpbnQgZmxhZ3MpCnsKCWNvbnN0IGNoYXIgKnMsICphcmc7Cgljb25zdCBpbnQgdW5zZXQgPSBmbGFncyAmIE9QVF9VTlNFVDsKCglpZiAodW5zZXQgJiYgcC0+b3B0KQoJCXJldHVybiBvcHRlcnJvcihvcHQsICJ0YWtlcyBubyB2YWx1ZSIsIGZsYWdzKTsKCWlmICh1bnNldCAmJiAob3B0LT5mbGFncyAmIFBBUlNFX09QVF9OT05FRykpCgkJcmV0dXJuIG9wdGVycm9yKG9wdCwgImlzbid0IGF2YWlsYWJsZSIsIGZsYWdzKTsKCglpZiAoIShmbGFncyAmIE9QVF9TSE9SVCkgJiYgcC0+b3B0KSB7CgkJc3dpdGNoIChvcHQtPnR5cGUpIHsKCQljYXNlIE9QVElPTl9DQUxMQkFDSzoKCQkJaWYgKCEob3B0LT5mbGFncyAmIFBBUlNFX09QVF9OT0FSRykpCgkJCQlicmVhazsKCQkJLyogRkFMTFRIUk9VR0ggKi8KCQljYXNlIE9QVElPTl9CT09MRUFOOgoJCWNhc2UgT1BUSU9OX0JJVDoKCQljYXNlIE9QVElPTl9TRVRfSU5UOgoJCWNhc2UgT1BUSU9OX1NFVF9QVFI6CgkJCXJldHVybiBvcHRlcnJvcihvcHQsICJ0YWtlcyBubyB2YWx1ZSIsIGZsYWdzKTsKCQlkZWZhdWx0OgoJCQlicmVhazsKCQl9Cgl9CgoJYXJnID0gcC0+b3B0ID8gcC0+b3B0IDogKHAtPmFyZ2MgPiAxID8gcC0+YXJndlsxXSA6IE5VTEwpOwoJc3dpdGNoIChvcHQtPnR5cGUpIHsKCWNhc2UgT1BUSU9OX0JJVDoKCQlpZiAodW5zZXQpCgkJCSooaW50ICopb3B0LT52YWx1ZSAmPSB+b3B0LT5kZWZ2YWw7CgkJZWxzZQoJCQkqKGludCAqKW9wdC0+dmFsdWUgfD0gb3B0LT5kZWZ2YWw7CgkJcmV0dXJuIDA7CgoJY2FzZSBPUFRJT05fQk9PTEVBTjoKCQkqKGludCAqKW9wdC0+dmFsdWUgPSB1bnNldCA/IDAgOiAqKGludCAqKW9wdC0+dmFsdWUgKyAxOwoJCXJldHVybiAwOwoKCWNhc2UgT1BUSU9OX1NFVF9JTlQ6CgkJKihpbnQgKilvcHQtPnZhbHVlID0gdW5zZXQgPyAwIDogb3B0LT5kZWZ2YWw7CgkJcmV0dXJuIDA7CgoJY2FzZSBPUFRJT05fU0VUX1BUUjoKCQkqKHZvaWQgKiopb3B0LT52YWx1ZSA9IHVuc2V0ID8gTlVMTCA6ICh2b2lkICopb3B0LT5kZWZ2YWw7CgkJcmV0dXJuIDA7CgoJY2FzZSBPUFRJT05fU1RSSU5HOgoJCWlmICh1bnNldCkgewoJCQkqKGNvbnN0IGNoYXIgKiopb3B0LT52YWx1ZSA9IE5VTEw7CgkJCXJldHVybiAwOwoJCX0KCQlpZiAob3B0LT5mbGFncyAmIFBBUlNFX09QVF9PUFRBUkcgJiYgIXAtPm9wdCkgewoJCQkqKGNvbnN0IGNoYXIgKiopb3B0LT52YWx1ZSA9IChjb25zdCBjaGFyICopb3B0LT5kZWZ2YWw7CgkJCXJldHVybiAwOwoJCX0KCQlpZiAoIWFyZykKCQkJcmV0dXJuIG9wdGVycm9yKG9wdCwgInJlcXVpcmVzIGEgdmFsdWUiLCBmbGFncyk7CgkJKihjb25zdCBjaGFyICoqKW9wdC0+dmFsdWUgPSBnZXRfYXJnKHApOwoJCXJldHVybiAwOwoKCWNhc2UgT1BUSU9OX0NBTExCQUNLOgoJCWlmICh1bnNldCkKCQkJcmV0dXJuICgqb3B0LT5jYWxsYmFjaykob3B0LCBOVUxMLCAxKTsKCQlpZiAob3B0LT5mbGFncyAmIFBBUlNFX09QVF9OT0FSRykKCQkJcmV0dXJuICgqb3B0LT5jYWxsYmFjaykob3B0LCBOVUxMLCAwKTsKCQlpZiAob3B0LT5mbGFncyAmIFBBUlNFX09QVF9PUFRBUkcgJiYgIXAtPm9wdCkKCQkJcmV0dXJuICgqb3B0LT5jYWxsYmFjaykob3B0LCBOVUxMLCAwKTsKCQlpZiAoIWFyZykKCQkJcmV0dXJuIG9wdGVycm9yKG9wdCwgInJlcXVpcmVzIGEgdmFsdWUiLCBmbGFncyk7CgkJcmV0dXJuICgqb3B0LT5jYWxsYmFjaykob3B0LCBnZXRfYXJnKHApLCAwKTsKCgljYXNlIE9QVElPTl9JTlRFR0VSOgoJCWlmICh1bnNldCkgewoJCQkqKGludCAqKW9wdC0+dmFsdWUgPSAwOwoJCQlyZXR1cm4gMDsKCQl9CgkJaWYgKG9wdC0+ZmxhZ3MgJiBQQVJTRV9PUFRfT1BUQVJHICYmICFwLT5vcHQpIHsKCQkJKihpbnQgKilvcHQtPnZhbHVlID0gb3B0LT5kZWZ2YWw7CgkJCXJldHVybiAwOwoJCX0KCQlpZiAoIWFyZykKCQkJcmV0dXJuIG9wdGVycm9yKG9wdCwgInJlcXVpcmVzIGEgdmFsdWUiLCBmbGFncyk7CgkJKihpbnQgKilvcHQtPnZhbHVlID0gc3RydG9sKGdldF9hcmcocCksIChjaGFyICoqKSZzLCAxMCk7CgkJaWYgKCpzKQoJCQlyZXR1cm4gb3B0ZXJyb3Iob3B0LCAiZXhwZWN0cyBhIG51bWVyaWNhbCB2YWx1ZSIsIGZsYWdzKTsKCQlyZXR1cm4gMDsKCglkZWZhdWx0OgoJCWRpZSgic2hvdWxkIG5vdCBoYXBwZW4sIHNvbWVvbmUgbXVzdCBiZSBoaXQgb24gdGhlIGZvcmVoZWFkIik7Cgl9Cn0KCnN0YXRpYyBpbnQgcGFyc2Vfc2hvcnRfb3B0KHN0cnVjdCBwYXJzZV9vcHRfY3R4X3QgKnAsIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdGlvbnMpCnsKCWZvciAoOyBvcHRpb25zLT50eXBlICE9IE9QVElPTl9FTkQ7IG9wdGlvbnMrKykgewoJCWlmIChvcHRpb25zLT5zaG9ydF9uYW1lID09ICpwLT5vcHQpIHsKCQkJcC0+b3B0ID0gcC0+b3B0WzFdID8gcC0+b3B0ICsgMSA6IE5VTEw7CgkJCXJldHVybiBnZXRfdmFsdWUocCwgb3B0aW9ucywgT1BUX1NIT1JUKTsKCQl9Cgl9CglyZXR1cm4gZXJyb3IoInVua25vd24gc3dpdGNoIGAlYyciLCAqcC0+b3B0KTsKfQoKc3RhdGljIGludCBwYXJzZV9sb25nX29wdChzdHJ1Y3QgcGFyc2Vfb3B0X2N0eF90ICpwLCBjb25zdCBjaGFyICphcmcsCiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0aW9ucykKewoJY29uc3QgY2hhciAqYXJnX2VuZCA9IHN0cmNocihhcmcsICc9Jyk7Cgljb25zdCBzdHJ1Y3Qgb3B0aW9uICphYmJyZXZfb3B0aW9uID0gTlVMTCwgKmFtYmlndW91c19vcHRpb24gPSBOVUxMOwoJaW50IGFiYnJldl9mbGFncyA9IDAsIGFtYmlndW91c19mbGFncyA9IDA7CgoJaWYgKCFhcmdfZW5kKQoJCWFyZ19lbmQgPSBhcmcgKyBzdHJsZW4oYXJnKTsKCglmb3IgKDsgb3B0aW9ucy0+dHlwZSAhPSBPUFRJT05fRU5EOyBvcHRpb25zKyspIHsKCQljb25zdCBjaGFyICpyZXN0OwoJCWludCBmbGFncyA9IDA7CgoJCWlmICghb3B0aW9ucy0+bG9uZ19uYW1lKQoJCQljb250aW51ZTsKCgkJcmVzdCA9IHNraXBfcHJlZml4KGFyZywgb3B0aW9ucy0+bG9uZ19uYW1lKTsKCQlpZiAob3B0aW9ucy0+dHlwZSA9PSBPUFRJT05fQVJHVU1FTlQpIHsKCQkJaWYgKCFyZXN0KQoJCQkJY29udGludWU7CgkJCWlmICgqcmVzdCA9PSAnPScpCgkJCQlyZXR1cm4gb3B0ZXJyb3Iob3B0aW9ucywgInRha2VzIG5vIHZhbHVlIiwgZmxhZ3MpOwoJCQlpZiAoKnJlc3QpCgkJCQljb250aW51ZTsKCQkJcC0+b3V0W3AtPmNwaWR4KytdID0gYXJnIC0gMjsKCQkJcmV0dXJuIDA7CgkJfQoJCWlmICghcmVzdCkgewoJCQkvKiBhYmJyZXZpYXRlZD8gKi8KCQkJaWYgKCFzdHJuY21wKG9wdGlvbnMtPmxvbmdfbmFtZSwgYXJnLCBhcmdfZW5kIC0gYXJnKSkgewppc19hYmJyZXZpYXRlZDoKCQkJCWlmIChhYmJyZXZfb3B0aW9uKSB7CgkJCQkJLyoKCQkJCQkgKiBJZiB0aGlzIGlzIGFiYnJldmlhdGVkLCBpdCBpcwoJCQkJCSAqIGFtYmlndW91cy4gU28gd2hlbiB0aGVyZSBpcyBubwoJCQkJCSAqIGV4YWN0IG1hdGNoIGxhdGVyLCB3ZSBuZWVkIHRvCgkJCQkJICogZXJyb3Igb3V0LgoJCQkJCSAqLwoJCQkJCWFtYmlndW91c19vcHRpb24gPSBhYmJyZXZfb3B0aW9uOwoJCQkJCWFtYmlndW91c19mbGFncyA9IGFiYnJldl9mbGFnczsKCQkJCX0KCQkJCWlmICghKGZsYWdzICYgT1BUX1VOU0VUKSAmJiAqYXJnX2VuZCkKCQkJCQlwLT5vcHQgPSBhcmdfZW5kICsgMTsKCQkJCWFiYnJldl9vcHRpb24gPSBvcHRpb25zOwoJCQkJYWJicmV2X2ZsYWdzID0gZmxhZ3M7CgkJCQljb250aW51ZTsKCQkJfQoJCQkvKiBuZWdhdGVkIGFuZCBhYmJyZXZpYXRlZCB2ZXJ5IG11Y2g/ICovCgkJCWlmICghcHJlZml4Y21wKCJuby0iLCBhcmcpKSB7CgkJCQlmbGFncyB8PSBPUFRfVU5TRVQ7CgkJCQlnb3RvIGlzX2FiYnJldmlhdGVkOwoJCQl9CgkJCS8qIG5lZ2F0ZWQ/ICovCgkJCWlmIChzdHJuY21wKGFyZywgIm5vLSIsIDMpKQoJCQkJY29udGludWU7CgkJCWZsYWdzIHw9IE9QVF9VTlNFVDsKCQkJcmVzdCA9IHNraXBfcHJlZml4KGFyZyArIDMsIG9wdGlvbnMtPmxvbmdfbmFtZSk7CgkJCS8qIGFiYnJldmlhdGVkIGFuZCBuZWdhdGVkPyAqLwoJCQlpZiAoIXJlc3QgJiYgIXByZWZpeGNtcChvcHRpb25zLT5sb25nX25hbWUsIGFyZyArIDMpKQoJCQkJZ290byBpc19hYmJyZXZpYXRlZDsKCQkJaWYgKCFyZXN0KQoJCQkJY29udGludWU7CgkJfQoJCWlmICgqcmVzdCkgewoJCQlpZiAoKnJlc3QgIT0gJz0nKQoJCQkJY29udGludWU7CgkJCXAtPm9wdCA9IHJlc3QgKyAxOwoJCX0KCQlyZXR1cm4gZ2V0X3ZhbHVlKHAsIG9wdGlvbnMsIGZsYWdzKTsKCX0KCglpZiAoYW1iaWd1b3VzX29wdGlvbikKCQlyZXR1cm4gZXJyb3IoIkFtYmlndW91cyBvcHRpb246ICVzICIKCQkJIihjb3VsZCBiZSAtLSVzJXMgb3IgLS0lcyVzKSIsCgkJCWFyZywKCQkJKGFtYmlndW91c19mbGFncyAmIE9QVF9VTlNFVCkgPyAgIm5vLSIgOiAiIiwKCQkJYW1iaWd1b3VzX29wdGlvbi0+bG9uZ19uYW1lLAoJCQkoYWJicmV2X2ZsYWdzICYgT1BUX1VOU0VUKSA/ICAibm8tIiA6ICIiLAoJCQlhYmJyZXZfb3B0aW9uLT5sb25nX25hbWUpOwoJaWYgKGFiYnJldl9vcHRpb24pCgkJcmV0dXJuIGdldF92YWx1ZShwLCBhYmJyZXZfb3B0aW9uLCBhYmJyZXZfZmxhZ3MpOwoJcmV0dXJuIGVycm9yKCJ1bmtub3duIG9wdGlvbiBgJXMnIiwgYXJnKTsKfQoKdm9pZCBjaGVja190eXBvcyhjb25zdCBjaGFyICphcmcsIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdGlvbnMpCnsKCWlmIChzdHJsZW4oYXJnKSA8IDMpCgkJcmV0dXJuOwoKCWlmICghcHJlZml4Y21wKGFyZywgIm5vLSIpKSB7CgkJZXJyb3IgKCJkaWQgeW91IG1lYW4gYC0tJXNgICh3aXRoIHR3byBkYXNoZXMgPykiLCBhcmcpOwoJCWV4aXQoMTI5KTsKCX0KCglmb3IgKDsgb3B0aW9ucy0+dHlwZSAhPSBPUFRJT05fRU5EOyBvcHRpb25zKyspIHsKCQlpZiAoIW9wdGlvbnMtPmxvbmdfbmFtZSkKCQkJY29udGludWU7CgkJaWYgKCFwcmVmaXhjbXAob3B0aW9ucy0+bG9uZ19uYW1lLCBhcmcpKSB7CgkJCWVycm9yICgiZGlkIHlvdSBtZWFuIGAtLSVzYCAod2l0aCB0d28gZGFzaGVzID8pIiwgYXJnKTsKCQkJZXhpdCgxMjkpOwoJCX0KCX0KfQoKdm9pZCBwYXJzZV9vcHRpb25zX3N0YXJ0KHN0cnVjdCBwYXJzZV9vcHRfY3R4X3QgKmN0eCwKCQkJIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgaW50IGZsYWdzKQp7CgltZW1zZXQoY3R4LCAwLCBzaXplb2YoKmN0eCkpOwoJY3R4LT5hcmdjID0gYXJnYyAtIDE7CgljdHgtPmFyZ3YgPSBhcmd2ICsgMTsKCWN0eC0+b3V0ICA9IGFyZ3Y7CgljdHgtPmZsYWdzID0gZmxhZ3M7Cn0KCmludCBwYXJzZV9vcHRpb25zX2VuZChzdHJ1Y3QgcGFyc2Vfb3B0X2N0eF90ICpjdHgpCnsKCW1lbW1vdmUoY3R4LT5vdXQgKyBjdHgtPmNwaWR4LCBjdHgtPmFyZ3YsIGN0eC0+YXJnYyAqIHNpemVvZigqY3R4LT5vdXQpKTsKCWN0eC0+b3V0W2N0eC0+Y3BpZHggKyBjdHgtPmFyZ2NdID0gTlVMTDsKCXJldHVybiBjdHgtPmNwaWR4ICsgY3R4LT5hcmdjOwp9CgpzdGF0aWMgaW50IHVzYWdlX3dpdGhfb3B0aW9uc19pbnRlcm5hbChjb25zdCBjaGFyICogY29uc3QgKiwKCQkJCSAgICAgICBjb25zdCBzdHJ1Y3Qgb3B0aW9uICosIGludCwgaW50KTsKCmludCBwYXJzZV9vcHRpb25zKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0aW9ucywKICAgICAgICAgICAgICAgICAgY29uc3QgY2hhciAqIGNvbnN0IHVzYWdlc3RyW10sIGludCBmbGFncykKewoJc3RydWN0IHBhcnNlX29wdF9jdHhfdCBjdHg7CgoJcGFyc2Vfb3B0aW9uc19zdGFydCgmY3R4LCBhcmdjLCBhcmd2LCBmbGFncyk7Cglmb3IgKDsgY3R4LmFyZ2M7IGN0eC5hcmdjLS0sIGN0eC5hcmd2KyspIHsKCQljb25zdCBjaGFyICphcmcgPSBjdHguYXJndlswXTsKCgkJaWYgKCphcmcgIT0gJy0nIHx8ICFhcmdbMV0pIHsKCQkJaWYgKGN0eC5mbGFncyAmIFBBUlNFX09QVF9TVE9QX0FUX05PTl9PUFRJT04pCgkJCQlicmVhazsKCQkJY3R4Lm91dFtjdHguY3BpZHgrK10gPSBjdHguYXJndlswXTsKCQkJY29udGludWU7CgkJfQoKCQlpZiAoYXJnWzFdICE9ICctJykgewoJCQljdHgub3B0ID0gYXJnICsgMTsKCQkJaWYgKCpjdHgub3B0ID09ICdoJykKCQkJCXVzYWdlX3dpdGhfb3B0aW9ucyh1c2FnZXN0ciwgb3B0aW9ucyk7CgkJCWlmIChwYXJzZV9zaG9ydF9vcHQoJmN0eCwgb3B0aW9ucykgPCAwKQoJCQkJdXNhZ2Vfd2l0aF9vcHRpb25zKHVzYWdlc3RyLCBvcHRpb25zKTsKCQkJaWYgKGN0eC5vcHQpCgkJCQljaGVja190eXBvcyhhcmcgKyAxLCBvcHRpb25zKTsKCQkJd2hpbGUgKGN0eC5vcHQpIHsKCQkJCWlmICgqY3R4Lm9wdCA9PSAnaCcpCgkJCQkJdXNhZ2Vfd2l0aF9vcHRpb25zKHVzYWdlc3RyLCBvcHRpb25zKTsKCQkJCWlmIChwYXJzZV9zaG9ydF9vcHQoJmN0eCwgb3B0aW9ucykgPCAwKQoJCQkJCXVzYWdlX3dpdGhfb3B0aW9ucyh1c2FnZXN0ciwgb3B0aW9ucyk7CgkJCX0KCQkJY29udGludWU7CgkJfQoKCQlpZiAoIWFyZ1syXSkgeyAvKiAiLS0iICovCgkJCWlmICghKGN0eC5mbGFncyAmIFBBUlNFX09QVF9LRUVQX0RBU0hEQVNIKSkgewoJCQkJY3R4LmFyZ2MtLTsKCQkJCWN0eC5hcmd2Kys7CgkJCX0KCQkJYnJlYWs7CgkJfQoKCQlpZiAoIXN0cmNtcChhcmcgKyAyLCAiaGVscC1hbGwiKSkKCQkJdXNhZ2Vfd2l0aF9vcHRpb25zX2ludGVybmFsKHVzYWdlc3RyLCBvcHRpb25zLCAxLCAxKTsKCQlpZiAoIXN0cmNtcChhcmcgKyAyLCAiaGVscCIpKQoJCQl1c2FnZV93aXRoX29wdGlvbnModXNhZ2VzdHIsIG9wdGlvbnMpOwoJCWlmIChwYXJzZV9sb25nX29wdCgmY3R4LCBhcmcgKyAyLCBvcHRpb25zKSkKCQkJdXNhZ2Vfd2l0aF9vcHRpb25zKHVzYWdlc3RyLCBvcHRpb25zKTsKCX0KCglyZXR1cm4gcGFyc2Vfb3B0aW9uc19lbmQoJmN0eCk7Cn0KCiNkZWZpbmUgVVNBR0VfT1BUU19XSURUSCAyNAojZGVmaW5lIFVTQUdFX0dBUCAgICAgICAgIDIKCmludCB1c2FnZV93aXRoX29wdGlvbnNfaW50ZXJuYWwoY29uc3QgY2hhciAqIGNvbnN0ICp1c2FnZXN0ciwKCQkJCWNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdHMsIGludCBmdWxsLCBpbnQgZG9fZXhpdCkKewoJZnByaW50ZihzdGRlcnIsICJ1c2FnZTogJXNcbiIsICp1c2FnZXN0cisrKTsKCXdoaWxlICgqdXNhZ2VzdHIgJiYgKip1c2FnZXN0cikKCQlmcHJpbnRmKHN0ZGVyciwgIiAgIG9yOiAlc1xuIiwgKnVzYWdlc3RyKyspOwoJd2hpbGUgKCp1c2FnZXN0cikgewoJCWZwcmludGYoc3RkZXJyLCAiJXMlc1xuIiwKCQkJCSoqdXNhZ2VzdHIgPyAiICAgICIgOiAiIiwKCQkJCSp1c2FnZXN0cik7CgkJdXNhZ2VzdHIrKzsKCX0KCglpZiAob3B0cy0+dHlwZSAhPSBPUFRJT05fR1JPVVApCgkJZnB1dGMoJ1xuJywgc3RkZXJyKTsKCglmb3IgKDsgb3B0cy0+dHlwZSAhPSBPUFRJT05fRU5EOyBvcHRzKyspIHsKCQlzaXplX3QgcG9zOwoJCWludCBwYWQ7CgoJCWlmIChvcHRzLT50eXBlID09IE9QVElPTl9HUk9VUCkgewoJCQlmcHV0YygnXG4nLCBzdGRlcnIpOwoJCQlpZiAoKm9wdHMtPmhlbHApCgkJCQlmcHJpbnRmKHN0ZGVyciwgIiVzXG4iLCBvcHRzLT5oZWxwKTsKCQkJY29udGludWU7CgkJfQoJCWlmICghZnVsbCAmJiAob3B0cy0+ZmxhZ3MgJiBQQVJTRV9PUFRfSElEREVOKSkKCQkJY29udGludWU7CgoJCXBvcyA9IGZwcmludGYoc3RkZXJyLCAiICAgICIpOwoJCWlmIChvcHRzLT5zaG9ydF9uYW1lKQoJCQlwb3MgKz0gZnByaW50ZihzdGRlcnIsICItJWMiLCBvcHRzLT5zaG9ydF9uYW1lKTsKCQlpZiAob3B0cy0+bG9uZ19uYW1lICYmIG9wdHMtPnNob3J0X25hbWUpCgkJCXBvcyArPSBmcHJpbnRmKHN0ZGVyciwgIiwgIik7CgkJaWYgKG9wdHMtPmxvbmdfbmFtZSkKCQkJcG9zICs9IGZwcmludGYoc3RkZXJyLCAiLS0lcyIsIG9wdHMtPmxvbmdfbmFtZSk7CgoJCXN3aXRjaCAob3B0cy0+dHlwZSkgewoJCWNhc2UgT1BUSU9OX0FSR1VNRU5UOgoJCQlicmVhazsKCQljYXNlIE9QVElPTl9JTlRFR0VSOgoJCQlpZiAob3B0cy0+ZmxhZ3MgJiBQQVJTRV9PUFRfT1BUQVJHKQoJCQkJaWYgKG9wdHMtPmxvbmdfbmFtZSkKCQkJCQlwb3MgKz0gZnByaW50ZihzdGRlcnIsICJbPTxuPl0iKTsKCQkJCWVsc2UKCQkJCQlwb3MgKz0gZnByaW50ZihzdGRlcnIsICJbPG4+XSIpOwoJCQllbHNlCgkJCQlwb3MgKz0gZnByaW50ZihzdGRlcnIsICIgPG4+Iik7CgkJCWJyZWFrOwoJCWNhc2UgT1BUSU9OX0NBTExCQUNLOgoJCQlpZiAob3B0cy0+ZmxhZ3MgJiBQQVJTRV9PUFRfTk9BUkcpCgkJCQlicmVhazsKCQkJLyogRkFMTFRIUk9VR0ggKi8KCQljYXNlIE9QVElPTl9TVFJJTkc6CgkJCWlmIChvcHRzLT5hcmdoKSB7CgkJCQlpZiAob3B0cy0+ZmxhZ3MgJiBQQVJTRV9PUFRfT1BUQVJHKQoJCQkJCWlmIChvcHRzLT5sb25nX25hbWUpCgkJCQkJCXBvcyArPSBmcHJpbnRmKHN0ZGVyciwgIls9PCVzPl0iLCBvcHRzLT5hcmdoKTsKCQkJCQllbHNlCgkJCQkJCXBvcyArPSBmcHJpbnRmKHN0ZGVyciwgIls8JXM+XSIsIG9wdHMtPmFyZ2gpOwoJCQkJZWxzZQoJCQkJCXBvcyArPSBmcHJpbnRmKHN0ZGVyciwgIiA8JXM+Iiwgb3B0cy0+YXJnaCk7CgkJCX0gZWxzZSB7CgkJCQlpZiAob3B0cy0+ZmxhZ3MgJiBQQVJTRV9PUFRfT1BUQVJHKQoJCQkJCWlmIChvcHRzLT5sb25nX25hbWUpCgkJCQkJCXBvcyArPSBmcHJpbnRmKHN0ZGVyciwgIls9Li4uXSIpOwoJCQkJCWVsc2UKCQkJCQkJcG9zICs9IGZwcmludGYoc3RkZXJyLCAiWy4uLl0iKTsKCQkJCWVsc2UKCQkJCQlwb3MgKz0gZnByaW50ZihzdGRlcnIsICIgLi4uIik7CgkJCX0KCQkJYnJlYWs7CgkJZGVmYXVsdDogLyogT1BUSU9OX3tCSVQsQk9PTEVBTixTRVRfSU5ULFNFVF9QVFJ9ICovCgkJCWJyZWFrOwoJCX0KCgkJaWYgKHBvcyA8PSBVU0FHRV9PUFRTX1dJRFRIKQoJCQlwYWQgPSBVU0FHRV9PUFRTX1dJRFRIIC0gcG9zOwoJCWVsc2UgewoJCQlmcHV0YygnXG4nLCBzdGRlcnIpOwoJCQlwYWQgPSBVU0FHRV9PUFRTX1dJRFRIOwoJCX0KCQlmcHJpbnRmKHN0ZGVyciwgIiUqcyVzXG4iLCBwYWQgKyBVU0FHRV9HQVAsICIiLCBvcHRzLT5oZWxwKTsKCX0KCWZwdXRjKCdcbicsIHN0ZGVycik7CgoJaWYgKGRvX2V4aXQpCgkJZXhpdCgxMjkpOwoJcmV0dXJuIFBBUlNFX09QVF9IRUxQOwp9Cgp2b2lkIHVzYWdlX3dpdGhfb3B0aW9ucyhjb25zdCBjaGFyICogY29uc3QgKnVzYWdlc3RyLAogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRzKQp7Cgl1c2FnZV93aXRoX29wdGlvbnNfaW50ZXJuYWwodXNhZ2VzdHIsIG9wdHMsIDAsIDEpOwoJZXhpdCgxMjkpOyAvKiBtYWtlIGdjYyBoYXBweSAqLwp9CgppbnQgcGFyc2Vfb3B0aW9uc191c2FnZShjb25zdCBjaGFyICogY29uc3QgKnVzYWdlc3RyLAoJCQljb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRzKQp7CglyZXR1cm4gdXNhZ2Vfd2l0aF9vcHRpb25zX2ludGVybmFsKHVzYWdlc3RyLCBvcHRzLCAwLCAwKTsKfQoKCi8qLS0tLS0gc29tZSBvZnRlbiB1c2VkIG9wdGlvbnMgLS0tLS0qLwojaW5jbHVkZSAiY2FjaGUuaCIKCmludCBwYXJzZV9vcHRfYWJicmV2X2NiKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCWludCB2OwoKCWlmICghYXJnKSB7CgkJdiA9IHVuc2V0ID8gMCA6IERFRkFVTFRfQUJCUkVWOwoJfSBlbHNlIHsKCQl2ID0gc3RydG9sKGFyZywgKGNoYXIgKiopJmFyZywgMTApOwoJCWlmICgqYXJnKQoJCQlyZXR1cm4gb3B0ZXJyb3Iob3B0LCAiZXhwZWN0cyBhIG51bWVyaWNhbCB2YWx1ZSIsIDApOwoJCWlmICh2ICYmIHYgPCBNSU5JTVVNX0FCQlJFVikKCQkJdiA9IE1JTklNVU1fQUJCUkVWOwoJCWVsc2UgaWYgKHYgPiA0MCkKCQkJdiA9IDQwOwoJfQoJKihpbnQgKikob3B0LT52YWx1ZSkgPSB2OwoJcmV0dXJuIDA7Cn0KCmludCBwYXJzZV9vcHRfYXBwcm94aWRhdGVfY2IoY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsCgkJCSAgICAgaW50IHVuc2V0KQp7CgkqKHVuc2lnbmVkIGxvbmcgKikob3B0LT52YWx1ZSkgPSBhcHByb3hpZGF0ZShhcmcpOwoJcmV0dXJuIDA7Cn0K",
    "text": "#include \"git-compat-util.h\"\n#include \"parse-options.h\"\n\n#define OPT_SHORT 1\n#define OPT_UNSET 2\n\nstatic inline const char *get_arg(struct parse_opt_ctx_t *p)\n{\n\tif (p->opt) {\n\t\tconst char *res = p->opt;\n\t\tp->opt = NULL;\n\t\treturn res;\n\t}\n\tp->argc--;\n\treturn *++p->argv;\n}\n\nstatic inline const char *skip_prefix(const char *str, const char *prefix)\n{\n\tsize_t len = strlen(prefix);\n\treturn strncmp(str, prefix, len) ? NULL : str + len;\n}\n\nstatic int opterror(const struct option *opt, const char *reason, int flags)\n{\n\tif (flags & OPT_SHORT)\n\t\treturn error(\"switch `%c' %s\", opt->short_name, reason);\n\tif (flags & OPT_UNSET)\n\t\treturn error(\"option `no-%s' %s\", opt->long_name, reason);\n\treturn error(\"option `%s' %s\", opt->long_name, reason);\n}\n\nstatic int get_value(struct parse_opt_ctx_t *p,\n                     const struct option *opt, int flags)\n{\n\tconst char *s, *arg;\n\tconst int unset = flags & OPT_UNSET;\n\n\tif (unset && p->opt)\n\t\treturn opterror(opt, \"takes no value\", flags);\n\tif (unset && (opt->flags & PARSE_OPT_NONEG))\n\t\treturn opterror(opt, \"isn't available\", flags);\n\n\tif (!(flags & OPT_SHORT) && p->opt) {\n\t\tswitch (opt->type) {\n\t\tcase OPTION_CALLBACK:\n\t\t\tif (!(opt->flags & PARSE_OPT_NOARG))\n\t\t\t\tbreak;\n\t\t\t/* FALLTHROUGH */\n\t\tcase OPTION_BOOLEAN:\n\t\tcase OPTION_BIT:\n\t\tcase OPTION_SET_INT:\n\t\tcase OPTION_SET_PTR:\n\t\t\treturn opterror(opt, \"takes no value\", flags);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targ = p->opt ? p->opt : (p->argc > 1 ? p->argv[1] : NULL);\n\tswitch (opt->type) {\n\tcase OPTION_BIT:\n\t\tif (unset)\n\t\t\t*(int *)opt->value &= ~opt->defval;\n\t\telse\n\t\t\t*(int *)opt->value |= opt->defval;\n\t\treturn 0;\n\n\tcase OPTION_BOOLEAN:\n\t\t*(int *)opt->value = unset ? 0 : *(int *)opt->value + 1;\n\t\treturn 0;\n\n\tcase OPTION_SET_INT:\n\t\t*(int *)opt->value = unset ? 0 : opt->defval;\n\t\treturn 0;\n\n\tcase OPTION_SET_PTR:\n\t\t*(void **)opt->value = unset ? NULL : (void *)opt->defval;\n\t\treturn 0;\n\n\tcase OPTION_STRING:\n\t\tif (unset) {\n\t\t\t*(const char **)opt->value = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\n\t\t\t*(const char **)opt->value = (const char *)opt->defval;\n\t\t\treturn 0;\n\t\t}\n\t\tif (!arg)\n\t\t\treturn opterror(opt, \"requires a value\", flags);\n\t\t*(const char **)opt->value = get_arg(p);\n\t\treturn 0;\n\n\tcase OPTION_CALLBACK:\n\t\tif (unset)\n\t\t\treturn (*opt->callback)(opt, NULL, 1);\n\t\tif (opt->flags & PARSE_OPT_NOARG)\n\t\t\treturn (*opt->callback)(opt, NULL, 0);\n\t\tif (opt->flags & PARSE_OPT_OPTARG && !p->opt)\n\t\t\treturn (*opt->callback)(opt, NULL, 0);\n\t\tif (!arg)\n\t\t\treturn opterror(opt, \"requires a value\", flags);\n\t\treturn (*opt->callback)(opt, get_arg(p), 0);\n\n\tcase OPTION_INTEGER:\n\t\tif (unset) {\n\t\t\t*(int *)opt->value = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\n\t\t\t*(int *)opt->value = opt->defval;\n\t\t\treturn 0;\n\t\t}\n\t\tif (!arg)\n\t\t\treturn opterror(opt, \"requires a value\", flags);\n\t\t*(int *)opt->value = strtol(get_arg(p), (char **)&s, 10);\n\t\tif (*s)\n\t\t\treturn opterror(opt, \"expects a numerical value\", flags);\n\t\treturn 0;\n\n\tdefault:\n\t\tdie(\"should not happen, someone must be hit on the forehead\");\n\t}\n}\n\nstatic int parse_short_opt(struct parse_opt_ctx_t *p, const struct option *options)\n{\n\tfor (; options->type != OPTION_END; options++) {\n\t\tif (options->short_name == *p->opt) {\n\t\t\tp->opt = p->opt[1] ? p->opt + 1 : NULL;\n\t\t\treturn get_value(p, options, OPT_SHORT);\n\t\t}\n\t}\n\treturn error(\"unknown switch `%c'\", *p->opt);\n}\n\nstatic int parse_long_opt(struct parse_opt_ctx_t *p, const char *arg,\n                          const struct option *options)\n{\n\tconst char *arg_end = strchr(arg, '=');\n\tconst struct option *abbrev_option = NULL, *ambiguous_option = NULL;\n\tint abbrev_flags = 0, ambiguous_flags = 0;\n\n\tif (!arg_end)\n\t\targ_end = arg + strlen(arg);\n\n\tfor (; options->type != OPTION_END; options++) {\n\t\tconst char *rest;\n\t\tint flags = 0;\n\n\t\tif (!options->long_name)\n\t\t\tcontinue;\n\n\t\trest = skip_prefix(arg, options->long_name);\n\t\tif (options->type == OPTION_ARGUMENT) {\n\t\t\tif (!rest)\n\t\t\t\tcontinue;\n\t\t\tif (*rest == '=')\n\t\t\t\treturn opterror(options, \"takes no value\", flags);\n\t\t\tif (*rest)\n\t\t\t\tcontinue;\n\t\t\tp->out[p->cpidx++] = arg - 2;\n\t\t\treturn 0;\n\t\t}\n\t\tif (!rest) {\n\t\t\t/* abbreviated? */\n\t\t\tif (!strncmp(options->long_name, arg, arg_end - arg)) {\nis_abbreviated:\n\t\t\t\tif (abbrev_option) {\n\t\t\t\t\t/*\n\t\t\t\t\t * If this is abbreviated, it is\n\t\t\t\t\t * ambiguous. So when there is no\n\t\t\t\t\t * exact match later, we need to\n\t\t\t\t\t * error out.\n\t\t\t\t\t */\n\t\t\t\t\tambiguous_option = abbrev_option;\n\t\t\t\t\tambiguous_flags = abbrev_flags;\n\t\t\t\t}\n\t\t\t\tif (!(flags & OPT_UNSET) && *arg_end)\n\t\t\t\t\tp->opt = arg_end + 1;\n\t\t\t\tabbrev_option = options;\n\t\t\t\tabbrev_flags = flags;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* negated and abbreviated very much? */\n\t\t\tif (!prefixcmp(\"no-\", arg)) {\n\t\t\t\tflags |= OPT_UNSET;\n\t\t\t\tgoto is_abbreviated;\n\t\t\t}\n\t\t\t/* negated? */\n\t\t\tif (strncmp(arg, \"no-\", 3))\n\t\t\t\tcontinue;\n\t\t\tflags |= OPT_UNSET;\n\t\t\trest = skip_prefix(arg + 3, options->long_name);\n\t\t\t/* abbreviated and negated? */\n\t\t\tif (!rest && !prefixcmp(options->long_name, arg + 3))\n\t\t\t\tgoto is_abbreviated;\n\t\t\tif (!rest)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (*rest) {\n\t\t\tif (*rest != '=')\n\t\t\t\tcontinue;\n\t\t\tp->opt = rest + 1;\n\t\t}\n\t\treturn get_value(p, options, flags);\n\t}\n\n\tif (ambiguous_option)\n\t\treturn error(\"Ambiguous option: %s \"\n\t\t\t\"(could be --%s%s or --%s%s)\",\n\t\t\targ,\n\t\t\t(ambiguous_flags & OPT_UNSET) ?  \"no-\" : \"\",\n\t\t\tambiguous_option->long_name,\n\t\t\t(abbrev_flags & OPT_UNSET) ?  \"no-\" : \"\",\n\t\t\tabbrev_option->long_name);\n\tif (abbrev_option)\n\t\treturn get_value(p, abbrev_option, abbrev_flags);\n\treturn error(\"unknown option `%s'\", arg);\n}\n\nvoid check_typos(const char *arg, const struct option *options)\n{\n\tif (strlen(arg) < 3)\n\t\treturn;\n\n\tif (!prefixcmp(arg, \"no-\")) {\n\t\terror (\"did you mean `--%s` (with two dashes ?)\", arg);\n\t\texit(129);\n\t}\n\n\tfor (; options->type != OPTION_END; options++) {\n\t\tif (!options->long_name)\n\t\t\tcontinue;\n\t\tif (!prefixcmp(options->long_name, arg)) {\n\t\t\terror (\"did you mean `--%s` (with two dashes ?)\", arg);\n\t\t\texit(129);\n\t\t}\n\t}\n}\n\nvoid parse_options_start(struct parse_opt_ctx_t *ctx,\n\t\t\t int argc, const char **argv, int flags)\n{\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->argc = argc - 1;\n\tctx->argv = argv + 1;\n\tctx->out  = argv;\n\tctx->flags = flags;\n}\n\nint parse_options_end(struct parse_opt_ctx_t *ctx)\n{\n\tmemmove(ctx->out + ctx->cpidx, ctx->argv, ctx->argc * sizeof(*ctx->out));\n\tctx->out[ctx->cpidx + ctx->argc] = NULL;\n\treturn ctx->cpidx + ctx->argc;\n}\n\nstatic int usage_with_options_internal(const char * const *,\n\t\t\t\t       const struct option *, int, int);\n\nint parse_options(int argc, const char **argv, const struct option *options,\n                  const char * const usagestr[], int flags)\n{\n\tstruct parse_opt_ctx_t ctx;\n\n\tparse_options_start(&ctx, argc, argv, flags);\n\tfor (; ctx.argc; ctx.argc--, ctx.argv++) {\n\t\tconst char *arg = ctx.argv[0];\n\n\t\tif (*arg != '-' || !arg[1]) {\n\t\t\tif (ctx.flags & PARSE_OPT_STOP_AT_NON_OPTION)\n\t\t\t\tbreak;\n\t\t\tctx.out[ctx.cpidx++] = ctx.argv[0];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (arg[1] != '-') {\n\t\t\tctx.opt = arg + 1;\n\t\t\tif (*ctx.opt == 'h')\n\t\t\t\tusage_with_options(usagestr, options);\n\t\t\tif (parse_short_opt(&ctx, options) < 0)\n\t\t\t\tusage_with_options(usagestr, options);\n\t\t\tif (ctx.opt)\n\t\t\t\tcheck_typos(arg + 1, options);\n\t\t\twhile (ctx.opt) {\n\t\t\t\tif (*ctx.opt == 'h')\n\t\t\t\t\tusage_with_options(usagestr, options);\n\t\t\t\tif (parse_short_opt(&ctx, options) < 0)\n\t\t\t\t\tusage_with_options(usagestr, options);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!arg[2]) { /* \"--\" */\n\t\t\tif (!(ctx.flags & PARSE_OPT_KEEP_DASHDASH)) {\n\t\t\t\tctx.argc--;\n\t\t\t\tctx.argv++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!strcmp(arg + 2, \"help-all\"))\n\t\t\tusage_with_options_internal(usagestr, options, 1, 1);\n\t\tif (!strcmp(arg + 2, \"help\"))\n\t\t\tusage_with_options(usagestr, options);\n\t\tif (parse_long_opt(&ctx, arg + 2, options))\n\t\t\tusage_with_options(usagestr, options);\n\t}\n\n\treturn parse_options_end(&ctx);\n}\n\n#define USAGE_OPTS_WIDTH 24\n#define USAGE_GAP         2\n\nint usage_with_options_internal(const char * const *usagestr,\n\t\t\t\tconst struct option *opts, int full, int do_exit)\n{\n\tfprintf(stderr, \"usage: %s\\n\", *usagestr++);\n\twhile (*usagestr && **usagestr)\n\t\tfprintf(stderr, \"   or: %s\\n\", *usagestr++);\n\twhile (*usagestr) {\n\t\tfprintf(stderr, \"%s%s\\n\",\n\t\t\t\t**usagestr ? \"    \" : \"\",\n\t\t\t\t*usagestr);\n\t\tusagestr++;\n\t}\n\n\tif (opts->type != OPTION_GROUP)\n\t\tfputc('\\n', stderr);\n\n\tfor (; opts->type != OPTION_END; opts++) {\n\t\tsize_t pos;\n\t\tint pad;\n\n\t\tif (opts->type == OPTION_GROUP) {\n\t\t\tfputc('\\n', stderr);\n\t\t\tif (*opts->help)\n\t\t\t\tfprintf(stderr, \"%s\\n\", opts->help);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!full && (opts->flags & PARSE_OPT_HIDDEN))\n\t\t\tcontinue;\n\n\t\tpos = fprintf(stderr, \"    \");\n\t\tif (opts->short_name)\n\t\t\tpos += fprintf(stderr, \"-%c\", opts->short_name);\n\t\tif (opts->long_name && opts->short_name)\n\t\t\tpos += fprintf(stderr, \", \");\n\t\tif (opts->long_name)\n\t\t\tpos += fprintf(stderr, \"--%s\", opts->long_name);\n\n\t\tswitch (opts->type) {\n\t\tcase OPTION_ARGUMENT:\n\t\t\tbreak;\n\t\tcase OPTION_INTEGER:\n\t\t\tif (opts->flags & PARSE_OPT_OPTARG)\n\t\t\t\tif (opts->long_name)\n\t\t\t\t\tpos += fprintf(stderr, \"[=<n>]\");\n\t\t\t\telse\n\t\t\t\t\tpos += fprintf(stderr, \"[<n>]\");\n\t\t\telse\n\t\t\t\tpos += fprintf(stderr, \" <n>\");\n\t\t\tbreak;\n\t\tcase OPTION_CALLBACK:\n\t\t\tif (opts->flags & PARSE_OPT_NOARG)\n\t\t\t\tbreak;\n\t\t\t/* FALLTHROUGH */\n\t\tcase OPTION_STRING:\n\t\t\tif (opts->argh) {\n\t\t\t\tif (opts->flags & PARSE_OPT_OPTARG)\n\t\t\t\t\tif (opts->long_name)\n\t\t\t\t\t\tpos += fprintf(stderr, \"[=<%s>]\", opts->argh);\n\t\t\t\t\telse\n\t\t\t\t\t\tpos += fprintf(stderr, \"[<%s>]\", opts->argh);\n\t\t\t\telse\n\t\t\t\t\tpos += fprintf(stderr, \" <%s>\", opts->argh);\n\t\t\t} else {\n\t\t\t\tif (opts->flags & PARSE_OPT_OPTARG)\n\t\t\t\t\tif (opts->long_name)\n\t\t\t\t\t\tpos += fprintf(stderr, \"[=...]\");\n\t\t\t\t\telse\n\t\t\t\t\t\tpos += fprintf(stderr, \"[...]\");\n\t\t\t\telse\n\t\t\t\t\tpos += fprintf(stderr, \" ...\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault: /* OPTION_{BIT,BOOLEAN,SET_INT,SET_PTR} */\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pos <= USAGE_OPTS_WIDTH)\n\t\t\tpad = USAGE_OPTS_WIDTH - pos;\n\t\telse {\n\t\t\tfputc('\\n', stderr);\n\t\t\tpad = USAGE_OPTS_WIDTH;\n\t\t}\n\t\tfprintf(stderr, \"%*s%s\\n\", pad + USAGE_GAP, \"\", opts->help);\n\t}\n\tfputc('\\n', stderr);\n\n\tif (do_exit)\n\t\texit(129);\n\treturn PARSE_OPT_HELP;\n}\n\nvoid usage_with_options(const char * const *usagestr,\n                        const struct option *opts)\n{\n\tusage_with_options_internal(usagestr, opts, 0, 1);\n\texit(129); /* make gcc happy */\n}\n\nint parse_options_usage(const char * const *usagestr,\n\t\t\tconst struct option *opts)\n{\n\treturn usage_with_options_internal(usagestr, opts, 0, 0);\n}\n\n\n/*----- some often used options -----*/\n#include \"cache.h\"\n\nint parse_opt_abbrev_cb(const struct option *opt, const char *arg, int unset)\n{\n\tint v;\n\n\tif (!arg) {\n\t\tv = unset ? 0 : DEFAULT_ABBREV;\n\t} else {\n\t\tv = strtol(arg, (char **)&arg, 10);\n\t\tif (*arg)\n\t\t\treturn opterror(opt, \"expects a numerical value\", 0);\n\t\tif (v && v < MINIMUM_ABBREV)\n\t\t\tv = MINIMUM_ABBREV;\n\t\telse if (v > 40)\n\t\t\tv = 40;\n\t}\n\t*(int *)(opt->value) = v;\n\treturn 0;\n}\n\nint parse_opt_approxidate_cb(const struct option *opt, const char *arg,\n\t\t\t     int unset)\n{\n\t*(unsigned long *)(opt->value) = approxidate(arg);\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "007b78eb248b5eab61f7f39942ad6d798a0c8cfa",
  "sha1_ok": true,
  "size": 10983
}
