{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJibG9iLmgiCiNpbmNsdWRlICJvYmplY3Qtc3RvcmUuaCIKI2luY2x1ZGUgImRpci5oIgojaW5jbHVkZSAic3RyZWFtaW5nLmgiCiNpbmNsdWRlICJzdWJtb2R1bGUuaCIKI2luY2x1ZGUgInByb2dyZXNzLmgiCiNpbmNsdWRlICJmc21vbml0b3IuaCIKCnN0YXRpYyB2b2lkIGNyZWF0ZV9kaXJlY3Rvcmllcyhjb25zdCBjaGFyICpwYXRoLCBpbnQgcGF0aF9sZW4sCgkJCSAgICAgICBjb25zdCBzdHJ1Y3QgY2hlY2tvdXQgKnN0YXRlKQp7CgljaGFyICpidWYgPSB4bWFsbG9jeihwYXRoX2xlbik7CglpbnQgbGVuID0gMDsKCgl3aGlsZSAobGVuIDwgcGF0aF9sZW4pIHsKCQlkbyB7CgkJCWJ1ZltsZW5dID0gcGF0aFtsZW5dOwoJCQlsZW4rKzsKCQl9IHdoaWxlIChsZW4gPCBwYXRoX2xlbiAmJiBwYXRoW2xlbl0gIT0gJy8nKTsKCQlpZiAobGVuID49IHBhdGhfbGVuKQoJCQlicmVhazsKCQlidWZbbGVuXSA9IDA7CgoJCS8qCgkJICogRm9yICdjaGVja291dC1pbmRleCAtLXByZWZpeD08ZGlyPicsIDxkaXI+IGlzCgkJICogYWxsb3dlZCB0byBiZSBhIHN5bWxpbmsgdG8gYW4gZXhpc3RpbmcgZGlyZWN0b3J5LAoJCSAqIGFuZCB3ZSBzZXQgJ3N0YXRlLT5iYXNlX2Rpcl9sZW4nIGJlbG93LCBzdWNoIHRoYXQKCQkgKiB3ZSB0ZXN0IHRoZSBwYXRoIGNvbXBvbmVudHMgb2YgdGhlIHByZWZpeCB3aXRoIHRoZQoJCSAqIHN0YXQoKSBmdW5jdGlvbiBpbnN0ZWFkIG9mIHRoZSBsc3RhdCgpIGZ1bmN0aW9uLgoJCSAqLwoJCWlmIChoYXNfZGlyc19vbmx5X3BhdGgoYnVmLCBsZW4sIHN0YXRlLT5iYXNlX2Rpcl9sZW4pKQoJCQljb250aW51ZTsgLyogb2ssIGl0IGlzIGFscmVhZHkgYSBkaXJlY3RvcnkuICovCgoJCS8qCgkJICogSWYgdGhpcyBta2RpcigpIHdvdWxkIGZhaWwsIGl0IGNvdWxkIGJlIHRoYXQgdGhlcmUKCQkgKiBpcyBhbHJlYWR5IGEgc3ltbGluayBvciBzb21ldGhpbmcgZWxzZSBleGlzdHMKCQkgKiB0aGVyZSwgdGhlcmVmb3JlIHdlIHRoZW4gdHJ5IHRvIHVubGluayBpdCBhbmQgdHJ5CgkJICogb25lIG1vcmUgdGltZSB0byBjcmVhdGUgdGhlIGRpcmVjdG9yeS4KCQkgKi8KCQlpZiAobWtkaXIoYnVmLCAwNzc3KSkgewoJCQlpZiAoZXJybm8gPT0gRUVYSVNUICYmIHN0YXRlLT5mb3JjZSAmJgoJCQkgICAgIXVubGlua19vcl93YXJuKGJ1ZikgJiYgIW1rZGlyKGJ1ZiwgMDc3NykpCgkJCQljb250aW51ZTsKCQkJZGllX2Vycm5vKCJjYW5ub3QgY3JlYXRlIGRpcmVjdG9yeSBhdCAnJXMnIiwgYnVmKTsKCQl9Cgl9CglmcmVlKGJ1Zik7Cn0KCnN0YXRpYyB2b2lkIHJlbW92ZV9zdWJ0cmVlKHN0cnVjdCBzdHJidWYgKnBhdGgpCnsKCURJUiAqZGlyID0gb3BlbmRpcihwYXRoLT5idWYpOwoJc3RydWN0IGRpcmVudCAqZGU7CglpbnQgb3JpZ2xlbiA9IHBhdGgtPmxlbjsKCglpZiAoIWRpcikKCQlkaWVfZXJybm8oImNhbm5vdCBvcGVuZGlyICclcyciLCBwYXRoLT5idWYpOwoJd2hpbGUgKChkZSA9IHJlYWRkaXIoZGlyKSkgIT0gTlVMTCkgewoJCXN0cnVjdCBzdGF0IHN0OwoKCQlpZiAoaXNfZG90X29yX2RvdGRvdChkZS0+ZF9uYW1lKSkKCQkJY29udGludWU7CgoJCXN0cmJ1Zl9hZGRjaChwYXRoLCAnLycpOwoJCXN0cmJ1Zl9hZGRzdHIocGF0aCwgZGUtPmRfbmFtZSk7CgkJaWYgKGxzdGF0KHBhdGgtPmJ1ZiwgJnN0KSkKCQkJZGllX2Vycm5vKCJjYW5ub3QgbHN0YXQgJyVzJyIsIHBhdGgtPmJ1Zik7CgkJaWYgKFNfSVNESVIoc3Quc3RfbW9kZSkpCgkJCXJlbW92ZV9zdWJ0cmVlKHBhdGgpOwoJCWVsc2UgaWYgKHVubGluayhwYXRoLT5idWYpKQoJCQlkaWVfZXJybm8oImNhbm5vdCB1bmxpbmsgJyVzJyIsIHBhdGgtPmJ1Zik7CgkJc3RyYnVmX3NldGxlbihwYXRoLCBvcmlnbGVuKTsKCX0KCWNsb3NlZGlyKGRpcik7CglpZiAocm1kaXIocGF0aC0+YnVmKSkKCQlkaWVfZXJybm8oImNhbm5vdCBybWRpciAnJXMnIiwgcGF0aC0+YnVmKTsKfQoKc3RhdGljIGludCBjcmVhdGVfZmlsZShjb25zdCBjaGFyICpwYXRoLCB1bnNpZ25lZCBpbnQgbW9kZSkKewoJbW9kZSA9IChtb2RlICYgMDEwMCkgPyAwNzc3IDogMDY2NjsKCXJldHVybiBvcGVuKHBhdGgsIE9fV1JPTkxZIHwgT19DUkVBVCB8IE9fRVhDTCwgbW9kZSk7Cn0KCnN0YXRpYyB2b2lkICpyZWFkX2Jsb2JfZW50cnkoY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgdW5zaWduZWQgbG9uZyAqc2l6ZSkKewoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJdm9pZCAqYmxvYl9kYXRhID0gcmVhZF9vYmplY3RfZmlsZSgmY2UtPm9pZCwgJnR5cGUsIHNpemUpOwoKCWlmIChibG9iX2RhdGEpIHsKCQlpZiAodHlwZSA9PSBPQkpfQkxPQikKCQkJcmV0dXJuIGJsb2JfZGF0YTsKCQlmcmVlKGJsb2JfZGF0YSk7Cgl9CglyZXR1cm4gTlVMTDsKfQoKc3RhdGljIGludCBvcGVuX291dHB1dF9mZChjaGFyICpwYXRoLCBjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBpbnQgdG9fdGVtcGZpbGUpCnsKCWludCBzeW1saW5rID0gKGNlLT5jZV9tb2RlICYgU19JRk1UKSAhPSBTX0lGUkVHOwoJaWYgKHRvX3RlbXBmaWxlKSB7CgkJeHNucHJpbnRmKHBhdGgsIFRFTVBPUkFSWV9GSUxFTkFNRV9MRU5HVEgsICIlcyIsCgkJCSAgc3ltbGluayA/ICIubWVyZ2VfbGlua19YWFhYWFgiIDogIi5tZXJnZV9maWxlX1hYWFhYWCIpOwoJCXJldHVybiBta3N0ZW1wKHBhdGgpOwoJfSBlbHNlIHsKCQlyZXR1cm4gY3JlYXRlX2ZpbGUocGF0aCwgIXN5bWxpbmsgPyBjZS0+Y2VfbW9kZSA6IDA2NjYpOwoJfQp9CgpzdGF0aWMgaW50IGZzdGF0X291dHB1dChpbnQgZmQsIGNvbnN0IHN0cnVjdCBjaGVja291dCAqc3RhdGUsIHN0cnVjdCBzdGF0ICpzdCkKewoJLyogdXNlIGZzdGF0KCkgb25seSB3aGVuIHBhdGggPT0gY2UtPm5hbWUgKi8KCWlmIChmc3RhdF9pc19yZWxpYWJsZSgpICYmCgkgICAgc3RhdGUtPnJlZnJlc2hfY2FjaGUgJiYgIXN0YXRlLT5iYXNlX2Rpcl9sZW4pIHsKCQlmc3RhdChmZCwgc3QpOwoJCXJldHVybiAxOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgc3RyZWFtaW5nX3dyaXRlX2VudHJ5KGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIGNoYXIgKnBhdGgsCgkJCQkgc3RydWN0IHN0cmVhbV9maWx0ZXIgKmZpbHRlciwKCQkJCSBjb25zdCBzdHJ1Y3QgY2hlY2tvdXQgKnN0YXRlLCBpbnQgdG9fdGVtcGZpbGUsCgkJCQkgaW50ICpmc3RhdF9kb25lLCBzdHJ1Y3Qgc3RhdCAqc3RhdGJ1ZikKewoJaW50IHJlc3VsdCA9IDA7CglpbnQgZmQ7CgoJZmQgPSBvcGVuX291dHB1dF9mZChwYXRoLCBjZSwgdG9fdGVtcGZpbGUpOwoJaWYgKGZkIDwgMCkKCQlyZXR1cm4gLTE7CgoJcmVzdWx0IHw9IHN0cmVhbV9ibG9iX3RvX2ZkKGZkLCAmY2UtPm9pZCwgZmlsdGVyLCAxKTsKCSpmc3RhdF9kb25lID0gZnN0YXRfb3V0cHV0KGZkLCBzdGF0ZSwgc3RhdGJ1Zik7CglyZXN1bHQgfD0gY2xvc2UoZmQpOwoKCWlmIChyZXN1bHQpCgkJdW5saW5rKHBhdGgpOwoJcmV0dXJuIHJlc3VsdDsKfQoKdm9pZCBlbmFibGVfZGVsYXllZF9jaGVja291dChzdHJ1Y3QgY2hlY2tvdXQgKnN0YXRlKQp7CglpZiAoIXN0YXRlLT5kZWxheWVkX2NoZWNrb3V0KSB7CgkJc3RhdGUtPmRlbGF5ZWRfY2hlY2tvdXQgPSB4bWFsbG9jKHNpemVvZigqc3RhdGUtPmRlbGF5ZWRfY2hlY2tvdXQpKTsKCQlzdGF0ZS0+ZGVsYXllZF9jaGVja291dC0+c3RhdGUgPSBDRV9DQU5fREVMQVk7CgkJc3RyaW5nX2xpc3RfaW5pdCgmc3RhdGUtPmRlbGF5ZWRfY2hlY2tvdXQtPmZpbHRlcnMsIDApOwoJCXN0cmluZ19saXN0X2luaXQoJnN0YXRlLT5kZWxheWVkX2NoZWNrb3V0LT5wYXRocywgMCk7Cgl9Cn0KCnN0YXRpYyBpbnQgcmVtb3ZlX2F2YWlsYWJsZV9wYXRocyhzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbSwgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IHN0cmluZ19saXN0ICphdmFpbGFibGVfcGF0aHMgPSBjYl9kYXRhOwoJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKmF2YWlsYWJsZTsKCglhdmFpbGFibGUgPSBzdHJpbmdfbGlzdF9sb29rdXAoYXZhaWxhYmxlX3BhdGhzLCBpdGVtLT5zdHJpbmcpOwoJaWYgKGF2YWlsYWJsZSkKCQlhdmFpbGFibGUtPnV0aWwgPSAodm9pZCAqKWl0ZW0tPnN0cmluZzsKCXJldHVybiAhYXZhaWxhYmxlOwp9CgppbnQgZmluaXNoX2RlbGF5ZWRfY2hlY2tvdXQoc3RydWN0IGNoZWNrb3V0ICpzdGF0ZSwgaW50ICpucl9jaGVja291dHMpCnsKCWludCBlcnJzID0gMDsKCXVuc2lnbmVkIGRlbGF5ZWRfb2JqZWN0X2NvdW50OwoJb2ZmX3QgZmlsdGVyZWRfYnl0ZXMgPSAwOwoJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKmZpbHRlciwgKnBhdGg7CglzdHJ1Y3QgcHJvZ3Jlc3MgKnByb2dyZXNzOwoJc3RydWN0IGRlbGF5ZWRfY2hlY2tvdXQgKmRjbyA9IHN0YXRlLT5kZWxheWVkX2NoZWNrb3V0OwoKCWlmICghc3RhdGUtPmRlbGF5ZWRfY2hlY2tvdXQpCgkJcmV0dXJuIGVycnM7CgoJZGNvLT5zdGF0ZSA9IENFX1JFVFJZOwoJZGVsYXllZF9vYmplY3RfY291bnQgPSBkY28tPnBhdGhzLm5yOwoJcHJvZ3Jlc3MgPSBzdGFydF9kZWxheWVkX3Byb2dyZXNzKF8oIkZpbHRlcmluZyBjb250ZW50IiksIGRlbGF5ZWRfb2JqZWN0X2NvdW50KTsKCXdoaWxlIChkY28tPmZpbHRlcnMubnIgPiAwKSB7CgkJZm9yX2VhY2hfc3RyaW5nX2xpc3RfaXRlbShmaWx0ZXIsICZkY28tPmZpbHRlcnMpIHsKCQkJc3RydWN0IHN0cmluZ19saXN0IGF2YWlsYWJsZV9wYXRocyA9IFNUUklOR19MSVNUX0lOSVRfTk9EVVA7CgkJCWRpc3BsYXlfcHJvZ3Jlc3MocHJvZ3Jlc3MsIGRlbGF5ZWRfb2JqZWN0X2NvdW50IC0gZGNvLT5wYXRocy5ucik7CgoJCQlpZiAoIWFzeW5jX3F1ZXJ5X2F2YWlsYWJsZV9ibG9icyhmaWx0ZXItPnN0cmluZywgJmF2YWlsYWJsZV9wYXRocykpIHsKCQkJCS8qIEZpbHRlciByZXBvcnRlZCBhbiBlcnJvciAqLwoJCQkJZXJycyA9IDE7CgkJCQlmaWx0ZXItPnN0cmluZyA9ICIiOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKGF2YWlsYWJsZV9wYXRocy5uciA8PSAwKSB7CgkJCQkvKgoJCQkJICogRmlsdGVyIHJlc3BvbmRlZCB3aXRoIG5vIGVudHJpZXMuIFRoYXQgbWVhbnMKCQkJCSAqIHRoZSBmaWx0ZXIgaXMgZG9uZSBhbmQgd2UgY2FuIHJlbW92ZSB0aGUKCQkJCSAqIGZpbHRlciBmcm9tIHRoZSBsaXN0IChzZWUKCQkJCSAqICJzdHJpbmdfbGlzdF9yZW1vdmVfZW1wdHlfaXRlbXMiIGNhbGwgYmVsb3cpLgoJCQkJICovCgkJCQlmaWx0ZXItPnN0cmluZyA9ICIiOwoJCQkJY29udGludWU7CgkJCX0KCgkJCS8qCgkJCSAqIEluIGRjby0+cGF0aHMgd2Ugc3RvcmUgYSBsaXN0IG9mIGFsbCBkZWxheWVkIHBhdGhzLgoJCQkgKiBUaGUgZmlsdGVyIGp1c3Qgc2VuZCB1cyBhIGxpc3Qgb2YgYXZhaWxhYmxlIHBhdGhzLgoJCQkgKiBSZW1vdmUgdGhlbSBmcm9tIHRoZSBsaXN0LgoJCQkgKi8KCQkJZmlsdGVyX3N0cmluZ19saXN0KCZkY28tPnBhdGhzLCAwLAoJCQkJJnJlbW92ZV9hdmFpbGFibGVfcGF0aHMsICZhdmFpbGFibGVfcGF0aHMpOwoKCQkJZm9yX2VhY2hfc3RyaW5nX2xpc3RfaXRlbShwYXRoLCAmYXZhaWxhYmxlX3BhdGhzKSB7CgkJCQlzdHJ1Y3QgY2FjaGVfZW50cnkqIGNlOwoKCQkJCWlmICghcGF0aC0+dXRpbCkgewoJCQkJCWVycm9yKCJleHRlcm5hbCBmaWx0ZXIgJyVzJyBzaWduYWxlZCB0aGF0ICclcycgIgoJCQkJCSAgICAgICJpcyBub3cgYXZhaWxhYmxlIGFsdGhvdWdoIGl0IGhhcyBub3QgYmVlbiAiCgkJCQkJICAgICAgImRlbGF5ZWQgZWFybGllciIsCgkJCQkJICAgICAgZmlsdGVyLT5zdHJpbmcsIHBhdGgtPnN0cmluZyk7CgkJCQkJZXJycyB8PSAxOwoKCQkJCQkvKgoJCQkJCSAqIERvIG5vdCBhc2sgdGhlIGZpbHRlciBmb3IgYXZhaWxhYmxlIGJsb2JzLAoJCQkJCSAqIGFnYWluLCBhcyB0aGUgZmlsdGVyIGlzIGxpa2VseSBidWdneS4KCQkJCQkgKi8KCQkJCQlmaWx0ZXItPnN0cmluZyA9ICIiOwoJCQkJCWNvbnRpbnVlOwoJCQkJfQoJCQkJY2UgPSBpbmRleF9maWxlX2V4aXN0cyhzdGF0ZS0+aXN0YXRlLCBwYXRoLT5zdHJpbmcsCgkJCQkJCSAgICAgICBzdHJsZW4ocGF0aC0+c3RyaW5nKSwgMCk7CgkJCQlpZiAoY2UpIHsKCQkJCQllcnJzIHw9IGNoZWNrb3V0X2VudHJ5KGNlLCBzdGF0ZSwgTlVMTCwgbnJfY2hlY2tvdXRzKTsKCQkJCQlmaWx0ZXJlZF9ieXRlcyArPSBjZS0+Y2Vfc3RhdF9kYXRhLnNkX3NpemU7CgkJCQkJZGlzcGxheV90aHJvdWdocHV0KHByb2dyZXNzLCBmaWx0ZXJlZF9ieXRlcyk7CgkJCQl9IGVsc2UKCQkJCQllcnJzID0gMTsKCQkJfQoJCX0KCQlzdHJpbmdfbGlzdF9yZW1vdmVfZW1wdHlfaXRlbXMoJmRjby0+ZmlsdGVycywgMCk7Cgl9CglzdG9wX3Byb2dyZXNzKCZwcm9ncmVzcyk7CglzdHJpbmdfbGlzdF9jbGVhcigmZGNvLT5maWx0ZXJzLCAwKTsKCgkvKiBBdCB0aGlzIHBvaW50IHdlIHNob3VsZCBub3QgaGF2ZSBhbnkgZGVsYXllZCBwYXRocyBhbnltb3JlLiAqLwoJZXJycyB8PSBkY28tPnBhdGhzLm5yOwoJZm9yX2VhY2hfc3RyaW5nX2xpc3RfaXRlbShwYXRoLCAmZGNvLT5wYXRocykgewoJCWVycm9yKCInJXMnIHdhcyBub3QgZmlsdGVyZWQgcHJvcGVybHkiLCBwYXRoLT5zdHJpbmcpOwoJfQoJc3RyaW5nX2xpc3RfY2xlYXIoJmRjby0+cGF0aHMsIDApOwoKCWZyZWUoZGNvKTsKCXN0YXRlLT5kZWxheWVkX2NoZWNrb3V0ID0gTlVMTDsKCglyZXR1cm4gZXJyczsKfQoKc3RhdGljIGludCB3cml0ZV9lbnRyeShzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCSAgICAgICBjaGFyICpwYXRoLCBjb25zdCBzdHJ1Y3QgY2hlY2tvdXQgKnN0YXRlLCBpbnQgdG9fdGVtcGZpbGUpCnsKCXVuc2lnbmVkIGludCBjZV9tb2RlX3NfaWZtdCA9IGNlLT5jZV9tb2RlICYgU19JRk1UOwoJc3RydWN0IGRlbGF5ZWRfY2hlY2tvdXQgKmRjbyA9IHN0YXRlLT5kZWxheWVkX2NoZWNrb3V0OwoJaW50IGZkLCByZXQsIGZzdGF0X2RvbmUgPSAwOwoJY2hhciAqbmV3X2Jsb2I7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJdW5zaWduZWQgbG9uZyBzaXplOwoJc3NpemVfdCB3cm90ZTsKCXNpemVfdCBuZXdzaXplID0gMDsKCXN0cnVjdCBzdGF0IHN0OwoJY29uc3Qgc3RydWN0IHN1Ym1vZHVsZSAqc3ViOwoJc3RydWN0IGNoZWNrb3V0X21ldGFkYXRhIG1ldGE7CgoJY2xvbmVfY2hlY2tvdXRfbWV0YWRhdGEoJm1ldGEsICZzdGF0ZS0+bWV0YSwgJmNlLT5vaWQpOwoKCWlmIChjZV9tb2RlX3NfaWZtdCA9PSBTX0lGUkVHKSB7CgkJc3RydWN0IHN0cmVhbV9maWx0ZXIgKmZpbHRlciA9IGdldF9zdHJlYW1fZmlsdGVyKHN0YXRlLT5pc3RhdGUsIGNlLT5uYW1lLAoJCQkJCQkJCSAmY2UtPm9pZCk7CgkJaWYgKGZpbHRlciAmJgoJCSAgICAhc3RyZWFtaW5nX3dyaXRlX2VudHJ5KGNlLCBwYXRoLCBmaWx0ZXIsCgkJCQkJICAgc3RhdGUsIHRvX3RlbXBmaWxlLAoJCQkJCSAgICZmc3RhdF9kb25lLCAmc3QpKQoJCQlnb3RvIGZpbmlzaDsKCX0KCglzd2l0Y2ggKGNlX21vZGVfc19pZm10KSB7CgljYXNlIFNfSUZMTks6CgkJbmV3X2Jsb2IgPSByZWFkX2Jsb2JfZW50cnkoY2UsICZzaXplKTsKCQlpZiAoIW5ld19ibG9iKQoJCQlyZXR1cm4gZXJyb3IoInVuYWJsZSB0byByZWFkIHNoYTEgZmlsZSBvZiAlcyAoJXMpIiwKCQkJCSAgICAgcGF0aCwgb2lkX3RvX2hleCgmY2UtPm9pZCkpOwoKCQkvKgoJCSAqIFdlIGNhbid0IG1ha2UgYSByZWFsIHN5bWxpbms7IHdyaXRlIG91dCBhIHJlZ3VsYXIgZmlsZSBlbnRyeQoJCSAqIHdpdGggdGhlIHN5bWxpbmsgZGVzdGluYXRpb24gYXMgaXRzIGNvbnRlbnRzLgoJCSAqLwoJCWlmICghaGFzX3N5bWxpbmtzIHx8IHRvX3RlbXBmaWxlKQoJCQlnb3RvIHdyaXRlX2ZpbGVfZW50cnk7CgoJCXJldCA9IHN5bWxpbmsobmV3X2Jsb2IsIHBhdGgpOwoJCWZyZWUobmV3X2Jsb2IpOwoJCWlmIChyZXQpCgkJCXJldHVybiBlcnJvcl9lcnJubygidW5hYmxlIHRvIGNyZWF0ZSBzeW1saW5rICVzIiwgcGF0aCk7CgkJYnJlYWs7CgoJY2FzZSBTX0lGUkVHOgoJCS8qCgkJICogV2UgZG8gbm90IHNlbmQgdGhlIGJsb2IgaW4gY2FzZSBvZiBhIHJldHJ5LCBzbyBkbyBub3QKCQkgKiBib3RoZXIgcmVhZGluZyBpdCBhdCBhbGwuCgkJICovCgkJaWYgKGRjbyAmJiBkY28tPnN0YXRlID09IENFX1JFVFJZKSB7CgkJCW5ld19ibG9iID0gTlVMTDsKCQkJc2l6ZSA9IDA7CgkJfSBlbHNlIHsKCQkJbmV3X2Jsb2IgPSByZWFkX2Jsb2JfZW50cnkoY2UsICZzaXplKTsKCQkJaWYgKCFuZXdfYmxvYikKCQkJCXJldHVybiBlcnJvcigidW5hYmxlIHRvIHJlYWQgc2hhMSBmaWxlIG9mICVzICglcykiLAoJCQkJCSAgICAgcGF0aCwgb2lkX3RvX2hleCgmY2UtPm9pZCkpOwoJCX0KCgkJLyoKCQkgKiBDb252ZXJ0IGZyb20gZ2l0IGludGVybmFsIGZvcm1hdCB0byB3b3JraW5nIHRyZWUgZm9ybWF0CgkJICovCgkJaWYgKGRjbyAmJiBkY28tPnN0YXRlICE9IENFX05PX0RFTEFZKSB7CgkJCXJldCA9IGFzeW5jX2NvbnZlcnRfdG9fd29ya2luZ190cmVlKHN0YXRlLT5pc3RhdGUsIGNlLT5uYW1lLCBuZXdfYmxvYiwKCQkJCQkJCSAgICBzaXplLCAmYnVmLCAmbWV0YSwgZGNvKTsKCQkJaWYgKHJldCAmJiBzdHJpbmdfbGlzdF9oYXNfc3RyaW5nKCZkY28tPnBhdGhzLCBjZS0+bmFtZSkpIHsKCQkJCWZyZWUobmV3X2Jsb2IpOwoJCQkJZ290byBkZWxheWVkOwoJCQl9CgkJfSBlbHNlCgkJCXJldCA9IGNvbnZlcnRfdG9fd29ya2luZ190cmVlKHN0YXRlLT5pc3RhdGUsIGNlLT5uYW1lLCBuZXdfYmxvYiwgc2l6ZSwgJmJ1ZiwgJm1ldGEpOwoKCQlpZiAocmV0KSB7CgkJCWZyZWUobmV3X2Jsb2IpOwoJCQluZXdfYmxvYiA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgJm5ld3NpemUpOwoJCQlzaXplID0gbmV3c2l6ZTsKCQl9CgkJLyoKCQkgKiBObyAiZWxzZSIgaGVyZSBhcyBlcnJvcnMgZnJvbSBjb252ZXJ0IGFyZSBPSyBhdCB0aGlzCgkJICogcG9pbnQuIElmIHRoZSBlcnJvciB3b3VsZCBoYXZlIGJlZW4gZmF0YWwgKGUuZy4KCQkgKiBmaWx0ZXIgaXMgcmVxdWlyZWQpLCB0aGVuIHdlIHdvdWxkIGhhdmUgZGllZCBhbHJlYWR5LgoJCSAqLwoKCXdyaXRlX2ZpbGVfZW50cnk6CgkJZmQgPSBvcGVuX291dHB1dF9mZChwYXRoLCBjZSwgdG9fdGVtcGZpbGUpOwoJCWlmIChmZCA8IDApIHsKCQkJZnJlZShuZXdfYmxvYik7CgkJCXJldHVybiBlcnJvcl9lcnJubygidW5hYmxlIHRvIGNyZWF0ZSBmaWxlICVzIiwgcGF0aCk7CgkJfQoKCQl3cm90ZSA9IHdyaXRlX2luX2Z1bGwoZmQsIG5ld19ibG9iLCBzaXplKTsKCQlpZiAoIXRvX3RlbXBmaWxlKQoJCQlmc3RhdF9kb25lID0gZnN0YXRfb3V0cHV0KGZkLCBzdGF0ZSwgJnN0KTsKCQljbG9zZShmZCk7CgkJZnJlZShuZXdfYmxvYik7CgkJaWYgKHdyb3RlIDwgMCkKCQkJcmV0dXJuIGVycm9yKCJ1bmFibGUgdG8gd3JpdGUgZmlsZSAlcyIsIHBhdGgpOwoJCWJyZWFrOwoKCWNhc2UgU19JRkdJVExJTks6CgkJaWYgKHRvX3RlbXBmaWxlKQoJCQlyZXR1cm4gZXJyb3IoImNhbm5vdCBjcmVhdGUgdGVtcG9yYXJ5IHN1Ym1vZHVsZSAlcyIsIHBhdGgpOwoJCWlmIChta2RpcihwYXRoLCAwNzc3KSA8IDApCgkJCXJldHVybiBlcnJvcigiY2Fubm90IGNyZWF0ZSBzdWJtb2R1bGUgZGlyZWN0b3J5ICVzIiwgcGF0aCk7CgkJc3ViID0gc3VibW9kdWxlX2Zyb21fY2UoY2UpOwoJCWlmIChzdWIpCgkJCXJldHVybiBzdWJtb2R1bGVfbW92ZV9oZWFkKGNlLT5uYW1lLAoJCQkJTlVMTCwgb2lkX3RvX2hleCgmY2UtPm9pZCksCgkJCQlzdGF0ZS0+Zm9yY2UgPyBTVUJNT0RVTEVfTU9WRV9IRUFEX0ZPUkNFIDogMCk7CgkJYnJlYWs7CgoJZGVmYXVsdDoKCQlyZXR1cm4gZXJyb3IoInVua25vd24gZmlsZSBtb2RlIGZvciAlcyBpbiBpbmRleCIsIHBhdGgpOwoJfQoKZmluaXNoOgoJaWYgKHN0YXRlLT5yZWZyZXNoX2NhY2hlKSB7CgkJYXNzZXJ0KHN0YXRlLT5pc3RhdGUpOwoJCWlmICghZnN0YXRfZG9uZSkKCQkJaWYgKGxzdGF0KGNlLT5uYW1lLCAmc3QpIDwgMCkKCQkJCXJldHVybiBlcnJvcl9lcnJubygidW5hYmxlIHRvIHN0YXQganVzdC13cml0dGVuIGZpbGUgJXMiLAoJCQkJCQkgICBjZS0+bmFtZSk7CgkJZmlsbF9zdGF0X2NhY2hlX2luZm8oc3RhdGUtPmlzdGF0ZSwgY2UsICZzdCk7CgkJY2UtPmNlX2ZsYWdzIHw9IENFX1VQREFURV9JTl9CQVNFOwoJCW1hcmtfZnNtb25pdG9yX2ludmFsaWQoc3RhdGUtPmlzdGF0ZSwgY2UpOwoJCXN0YXRlLT5pc3RhdGUtPmNhY2hlX2NoYW5nZWQgfD0gQ0VfRU5UUllfQ0hBTkdFRDsKCX0KZGVsYXllZDoKCXJldHVybiAwOwp9CgovKgogKiBUaGlzIGlzIGxpa2UgJ2xzdGF0KCknLCBleGNlcHQgaXQgcmVmdXNlcyB0byBmb2xsb3cgc3ltbGlua3MKICogaW4gdGhlIHBhdGgsIGFmdGVyIHNraXBwaW5nICJza2lwbGVuIi4KICovCnN0YXRpYyBpbnQgY2hlY2tfcGF0aChjb25zdCBjaGFyICpwYXRoLCBpbnQgbGVuLCBzdHJ1Y3Qgc3RhdCAqc3QsIGludCBza2lwbGVuKQp7Cgljb25zdCBjaGFyICpzbGFzaCA9IHBhdGggKyBsZW47CgoJd2hpbGUgKHBhdGggPCBzbGFzaCAmJiAqc2xhc2ggIT0gJy8nKQoJCXNsYXNoLS07CglpZiAoIWhhc19kaXJzX29ubHlfcGF0aChwYXRoLCBzbGFzaCAtIHBhdGgsIHNraXBsZW4pKSB7CgkJZXJybm8gPSBFTk9FTlQ7CgkJcmV0dXJuIC0xOwoJfQoJcmV0dXJuIGxzdGF0KHBhdGgsIHN0KTsKfQoKc3RhdGljIHZvaWQgbWFya19jb2xsaWRpbmdfZW50cmllcyhjb25zdCBzdHJ1Y3QgY2hlY2tvdXQgKnN0YXRlLAoJCQkJICAgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgc3RydWN0IHN0YXQgKnN0KQp7CglpbnQgaSwgdHJ1c3RfaW5vID0gY2hlY2tfc3RhdDsKCiNpZiBkZWZpbmVkKEdJVF9XSU5ET1dTX05BVElWRSkgfHwgZGVmaW5lZChfX0NZR1dJTl9fKQoJdHJ1c3RfaW5vID0gMDsKI2VuZGlmCgoJY2UtPmNlX2ZsYWdzIHw9IENFX01BVENIRUQ7CgoJZm9yIChpID0gMDsgaSA8IHN0YXRlLT5pc3RhdGUtPmNhY2hlX25yOyBpKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmR1cCA9IHN0YXRlLT5pc3RhdGUtPmNhY2hlW2ldOwoKCQlpZiAoZHVwID09IGNlKQoJCQlicmVhazsKCgkJaWYgKGR1cC0+Y2VfZmxhZ3MgJiAoQ0VfTUFUQ0hFRCB8IENFX1ZBTElEIHwgQ0VfU0tJUF9XT1JLVFJFRSkpCgkJCWNvbnRpbnVlOwoKCQlpZiAoKHRydXN0X2lubyAmJiAhbWF0Y2hfc3RhdF9kYXRhKCZkdXAtPmNlX3N0YXRfZGF0YSwgc3QpKSB8fAoJCSAgICAoIXRydXN0X2lubyAmJiAhZnNwYXRoY21wKGNlLT5uYW1lLCBkdXAtPm5hbWUpKSkgewoJCQlkdXAtPmNlX2ZsYWdzIHw9IENFX01BVENIRUQ7CgkJCWJyZWFrOwoJCX0KCX0KfQoKLyoKICogV3JpdGUgdGhlIGNvbnRlbnRzIGZyb20gY2Ugb3V0IHRvIHRoZSB3b3JraW5nIHRyZWUuCiAqCiAqIFdoZW4gdG9wYXRoW10gaXMgbm90IE5VTEwsIGluc3RlYWQgb2Ygd3JpdGluZyB0byB0aGUgd29ya2luZyB0cmVlCiAqIGZpbGUgbmFtZWQgYnkgY2UsIGEgdGVtcG9yYXJ5IGZpbGUgaXMgY3JlYXRlZCBieSB0aGlzIGZ1bmN0aW9uIGFuZAogKiBpdHMgbmFtZSBpcyByZXR1cm5lZCBpbiB0b3BhdGhbXSwgd2hpY2ggbXVzdCBiZSBhYmxlIHRvIGhvbGQgYXQKICogbGVhc3QgVEVNUE9SQVJZX0ZJTEVOQU1FX0xFTkdUSCBieXRlcyBsb25nLgogKi8KaW50IGNoZWNrb3V0X2VudHJ5KHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIGNvbnN0IHN0cnVjdCBjaGVja291dCAqc3RhdGUsCgkJICAgY2hhciAqdG9wYXRoLCBpbnQgKm5yX2NoZWNrb3V0cykKewoJc3RhdGljIHN0cnVjdCBzdHJidWYgcGF0aCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0YXQgc3Q7CgoJaWYgKGNlLT5jZV9mbGFncyAmIENFX1dUX1JFTU9WRSkgewoJCWlmICh0b3BhdGgpCgkJCS8qCgkJCSAqIE5vIGNvbnRlbnQgYW5kIHRodXMgbm8gcGF0aCB0byBjcmVhdGUsIHNvIHdlIGhhdmUKCQkJICogbm8gcGF0aG5hbWUgdG8gcmV0dXJuLgoJCQkgKi8KCQkJQlVHKCJDYW4ndCByZW1vdmUgZW50cnkgdG8gYSBwYXRoIik7CgkJdW5saW5rX2VudHJ5KGNlKTsKCQlyZXR1cm4gMDsKCX0KCglpZiAodG9wYXRoKQoJCXJldHVybiB3cml0ZV9lbnRyeShjZSwgdG9wYXRoLCBzdGF0ZSwgMSk7CgoJc3RyYnVmX3Jlc2V0KCZwYXRoKTsKCXN0cmJ1Zl9hZGQoJnBhdGgsIHN0YXRlLT5iYXNlX2Rpciwgc3RhdGUtPmJhc2VfZGlyX2xlbik7CglzdHJidWZfYWRkKCZwYXRoLCBjZS0+bmFtZSwgY2VfbmFtZWxlbihjZSkpOwoKCWlmICghY2hlY2tfcGF0aChwYXRoLmJ1ZiwgcGF0aC5sZW4sICZzdCwgc3RhdGUtPmJhc2VfZGlyX2xlbikpIHsKCQljb25zdCBzdHJ1Y3Qgc3VibW9kdWxlICpzdWI7CgkJdW5zaWduZWQgY2hhbmdlZCA9IGllX21hdGNoX3N0YXQoc3RhdGUtPmlzdGF0ZSwgY2UsICZzdCwKCQkJCQkJIENFX01BVENIX0lHTk9SRV9WQUxJRCB8IENFX01BVENIX0lHTk9SRV9TS0lQX1dPUktUUkVFKTsKCQkvKgoJCSAqIE5lZWRzIHRvIGJlIGNoZWNrZWQgYmVmb3JlICFjaGFuZ2VkIHJldHVybnMgZWFybHksCgkJICogYXMgdGhlIHBvc3NpYmx5IGVtcHR5IGRpcmVjdG9yeSB3YXMgbm90IGNoYW5nZWQKCQkgKi8KCQlzdWIgPSBzdWJtb2R1bGVfZnJvbV9jZShjZSk7CgkJaWYgKHN1YikgewoJCQlpbnQgZXJyOwoJCQlpZiAoIWlzX3N1Ym1vZHVsZV9wb3B1bGF0ZWRfZ2VudGx5KGNlLT5uYW1lLCAmZXJyKSkgewoJCQkJc3RydWN0IHN0YXQgc2I7CgkJCQlpZiAobHN0YXQoY2UtPm5hbWUsICZzYikpCgkJCQkJZGllKF8oImNvdWxkIG5vdCBzdGF0IGZpbGUgJyVzJyIpLCBjZS0+bmFtZSk7CgkJCQlpZiAoIShzdC5zdF9tb2RlICYgU19JRkRJUikpCgkJCQkJdW5saW5rX29yX3dhcm4oY2UtPm5hbWUpOwoKCQkJCXJldHVybiBzdWJtb2R1bGVfbW92ZV9oZWFkKGNlLT5uYW1lLAoJCQkJCU5VTEwsIG9pZF90b19oZXgoJmNlLT5vaWQpLCAwKTsKCQkJfSBlbHNlCgkJCQlyZXR1cm4gc3VibW9kdWxlX21vdmVfaGVhZChjZS0+bmFtZSwKCQkJCQkiSEVBRCIsIG9pZF90b19oZXgoJmNlLT5vaWQpLAoJCQkJCXN0YXRlLT5mb3JjZSA/IFNVQk1PRFVMRV9NT1ZFX0hFQURfRk9SQ0UgOiAwKTsKCQl9CgoJCWlmICghY2hhbmdlZCkKCQkJcmV0dXJuIDA7CgkJaWYgKCFzdGF0ZS0+Zm9yY2UpIHsKCQkJaWYgKCFzdGF0ZS0+cXVpZXQpCgkJCQlmcHJpbnRmKHN0ZGVyciwKCQkJCQkiJXMgYWxyZWFkeSBleGlzdHMsIG5vIGNoZWNrb3V0XG4iLAoJCQkJCXBhdGguYnVmKTsKCQkJcmV0dXJuIC0xOwoJCX0KCgkJaWYgKHN0YXRlLT5jbG9uZSkKCQkJbWFya19jb2xsaWRpbmdfZW50cmllcyhzdGF0ZSwgY2UsICZzdCk7CgoJCS8qCgkJICogV2UgdW5saW5rIHRoZSBvbGQgZmlsZSwgdG8gZ2V0IHRoZSBuZXcgb25lIHdpdGggdGhlCgkJICogcmlnaHQgcGVybWlzc2lvbnMgKGluY2x1ZGluZyB1bWFzaywgd2hpY2ggaXMgbmFzdHkKCQkgKiB0byBlbXVsYXRlIGJ5IGhhbmQgLSBtdWNoIGVhc2llciB0byBsZXQgdGhlIHN5c3RlbQoJCSAqIGp1c3QgZG8gdGhlIHJpZ2h0IHRoaW5nKQoJCSAqLwoJCWlmIChTX0lTRElSKHN0LnN0X21vZGUpKSB7CgkJCS8qIElmIGl0IGlzIGEgZ2l0bGluaywgbGVhdmUgaXQgYWxvbmUhICovCgkJCWlmIChTX0lTR0lUTElOSyhjZS0+Y2VfbW9kZSkpCgkJCQlyZXR1cm4gMDsKCQkJaWYgKCFzdGF0ZS0+Zm9yY2UpCgkJCQlyZXR1cm4gZXJyb3IoIiVzIGlzIGEgZGlyZWN0b3J5IiwgcGF0aC5idWYpOwoJCQlyZW1vdmVfc3VidHJlZSgmcGF0aCk7CgkJfSBlbHNlIGlmICh1bmxpbmsocGF0aC5idWYpKQoJCQlyZXR1cm4gZXJyb3JfZXJybm8oInVuYWJsZSB0byB1bmxpbmsgb2xkICclcyciLCBwYXRoLmJ1Zik7Cgl9IGVsc2UgaWYgKHN0YXRlLT5ub3RfbmV3KQoJCXJldHVybiAwOwoKCWNyZWF0ZV9kaXJlY3RvcmllcyhwYXRoLmJ1ZiwgcGF0aC5sZW4sIHN0YXRlKTsKCWlmIChucl9jaGVja291dHMpCgkJKCpucl9jaGVja291dHMpKys7CglyZXR1cm4gd3JpdGVfZW50cnkoY2UsIHBhdGguYnVmLCBzdGF0ZSwgMCk7Cn0KCnZvaWQgdW5saW5rX2VudHJ5KGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UpCnsKCWNvbnN0IHN0cnVjdCBzdWJtb2R1bGUgKnN1YiA9IHN1Ym1vZHVsZV9mcm9tX2NlKGNlKTsKCWlmIChzdWIpIHsKCQkvKiBzdGF0ZS5mb3JjZSBpcyBzZXQgYXQgdGhlIGNhbGxlci4gKi8KCQlzdWJtb2R1bGVfbW92ZV9oZWFkKGNlLT5uYW1lLCAiSEVBRCIsIE5VTEwsCgkJCQkgICAgU1VCTU9EVUxFX01PVkVfSEVBRF9GT1JDRSk7Cgl9CglpZiAoIWNoZWNrX2xlYWRpbmdfcGF0aChjZS0+bmFtZSwgY2VfbmFtZWxlbihjZSkpKQoJCXJldHVybjsKCWlmIChyZW1vdmVfb3Jfd2FybihjZS0+Y2VfbW9kZSwgY2UtPm5hbWUpKQoJCXJldHVybjsKCXNjaGVkdWxlX2Rpcl9mb3JfcmVtb3ZhbChjZS0+bmFtZSwgY2VfbmFtZWxlbihjZSkpOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"blob.h\"\n#include \"object-store.h\"\n#include \"dir.h\"\n#include \"streaming.h\"\n#include \"submodule.h\"\n#include \"progress.h\"\n#include \"fsmonitor.h\"\n\nstatic void create_directories(const char *path, int path_len,\n\t\t\t       const struct checkout *state)\n{\n\tchar *buf = xmallocz(path_len);\n\tint len = 0;\n\n\twhile (len < path_len) {\n\t\tdo {\n\t\t\tbuf[len] = path[len];\n\t\t\tlen++;\n\t\t} while (len < path_len && path[len] != '/');\n\t\tif (len >= path_len)\n\t\t\tbreak;\n\t\tbuf[len] = 0;\n\n\t\t/*\n\t\t * For 'checkout-index --prefix=<dir>', <dir> is\n\t\t * allowed to be a symlink to an existing directory,\n\t\t * and we set 'state->base_dir_len' below, such that\n\t\t * we test the path components of the prefix with the\n\t\t * stat() function instead of the lstat() function.\n\t\t */\n\t\tif (has_dirs_only_path(buf, len, state->base_dir_len))\n\t\t\tcontinue; /* ok, it is already a directory. */\n\n\t\t/*\n\t\t * If this mkdir() would fail, it could be that there\n\t\t * is already a symlink or something else exists\n\t\t * there, therefore we then try to unlink it and try\n\t\t * one more time to create the directory.\n\t\t */\n\t\tif (mkdir(buf, 0777)) {\n\t\t\tif (errno == EEXIST && state->force &&\n\t\t\t    !unlink_or_warn(buf) && !mkdir(buf, 0777))\n\t\t\t\tcontinue;\n\t\t\tdie_errno(\"cannot create directory at '%s'\", buf);\n\t\t}\n\t}\n\tfree(buf);\n}\n\nstatic void remove_subtree(struct strbuf *path)\n{\n\tDIR *dir = opendir(path->buf);\n\tstruct dirent *de;\n\tint origlen = path->len;\n\n\tif (!dir)\n\t\tdie_errno(\"cannot opendir '%s'\", path->buf);\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tstruct stat st;\n\n\t\tif (is_dot_or_dotdot(de->d_name))\n\t\t\tcontinue;\n\n\t\tstrbuf_addch(path, '/');\n\t\tstrbuf_addstr(path, de->d_name);\n\t\tif (lstat(path->buf, &st))\n\t\t\tdie_errno(\"cannot lstat '%s'\", path->buf);\n\t\tif (S_ISDIR(st.st_mode))\n\t\t\tremove_subtree(path);\n\t\telse if (unlink(path->buf))\n\t\t\tdie_errno(\"cannot unlink '%s'\", path->buf);\n\t\tstrbuf_setlen(path, origlen);\n\t}\n\tclosedir(dir);\n\tif (rmdir(path->buf))\n\t\tdie_errno(\"cannot rmdir '%s'\", path->buf);\n}\n\nstatic int create_file(const char *path, unsigned int mode)\n{\n\tmode = (mode & 0100) ? 0777 : 0666;\n\treturn open(path, O_WRONLY | O_CREAT | O_EXCL, mode);\n}\n\nstatic void *read_blob_entry(const struct cache_entry *ce, unsigned long *size)\n{\n\tenum object_type type;\n\tvoid *blob_data = read_object_file(&ce->oid, &type, size);\n\n\tif (blob_data) {\n\t\tif (type == OBJ_BLOB)\n\t\t\treturn blob_data;\n\t\tfree(blob_data);\n\t}\n\treturn NULL;\n}\n\nstatic int open_output_fd(char *path, const struct cache_entry *ce, int to_tempfile)\n{\n\tint symlink = (ce->ce_mode & S_IFMT) != S_IFREG;\n\tif (to_tempfile) {\n\t\txsnprintf(path, TEMPORARY_FILENAME_LENGTH, \"%s\",\n\t\t\t  symlink ? \".merge_link_XXXXXX\" : \".merge_file_XXXXXX\");\n\t\treturn mkstemp(path);\n\t} else {\n\t\treturn create_file(path, !symlink ? ce->ce_mode : 0666);\n\t}\n}\n\nstatic int fstat_output(int fd, const struct checkout *state, struct stat *st)\n{\n\t/* use fstat() only when path == ce->name */\n\tif (fstat_is_reliable() &&\n\t    state->refresh_cache && !state->base_dir_len) {\n\t\tfstat(fd, st);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int streaming_write_entry(const struct cache_entry *ce, char *path,\n\t\t\t\t struct stream_filter *filter,\n\t\t\t\t const struct checkout *state, int to_tempfile,\n\t\t\t\t int *fstat_done, struct stat *statbuf)\n{\n\tint result = 0;\n\tint fd;\n\n\tfd = open_output_fd(path, ce, to_tempfile);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tresult |= stream_blob_to_fd(fd, &ce->oid, filter, 1);\n\t*fstat_done = fstat_output(fd, state, statbuf);\n\tresult |= close(fd);\n\n\tif (result)\n\t\tunlink(path);\n\treturn result;\n}\n\nvoid enable_delayed_checkout(struct checkout *state)\n{\n\tif (!state->delayed_checkout) {\n\t\tstate->delayed_checkout = xmalloc(sizeof(*state->delayed_checkout));\n\t\tstate->delayed_checkout->state = CE_CAN_DELAY;\n\t\tstring_list_init(&state->delayed_checkout->filters, 0);\n\t\tstring_list_init(&state->delayed_checkout->paths, 0);\n\t}\n}\n\nstatic int remove_available_paths(struct string_list_item *item, void *cb_data)\n{\n\tstruct string_list *available_paths = cb_data;\n\tstruct string_list_item *available;\n\n\tavailable = string_list_lookup(available_paths, item->string);\n\tif (available)\n\t\tavailable->util = (void *)item->string;\n\treturn !available;\n}\n\nint finish_delayed_checkout(struct checkout *state, int *nr_checkouts)\n{\n\tint errs = 0;\n\tunsigned delayed_object_count;\n\toff_t filtered_bytes = 0;\n\tstruct string_list_item *filter, *path;\n\tstruct progress *progress;\n\tstruct delayed_checkout *dco = state->delayed_checkout;\n\n\tif (!state->delayed_checkout)\n\t\treturn errs;\n\n\tdco->state = CE_RETRY;\n\tdelayed_object_count = dco->paths.nr;\n\tprogress = start_delayed_progress(_(\"Filtering content\"), delayed_object_count);\n\twhile (dco->filters.nr > 0) {\n\t\tfor_each_string_list_item(filter, &dco->filters) {\n\t\t\tstruct string_list available_paths = STRING_LIST_INIT_NODUP;\n\t\t\tdisplay_progress(progress, delayed_object_count - dco->paths.nr);\n\n\t\t\tif (!async_query_available_blobs(filter->string, &available_paths)) {\n\t\t\t\t/* Filter reported an error */\n\t\t\t\terrs = 1;\n\t\t\t\tfilter->string = \"\";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (available_paths.nr <= 0) {\n\t\t\t\t/*\n\t\t\t\t * Filter responded with no entries. That means\n\t\t\t\t * the filter is done and we can remove the\n\t\t\t\t * filter from the list (see\n\t\t\t\t * \"string_list_remove_empty_items\" call below).\n\t\t\t\t */\n\t\t\t\tfilter->string = \"\";\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In dco->paths we store a list of all delayed paths.\n\t\t\t * The filter just send us a list of available paths.\n\t\t\t * Remove them from the list.\n\t\t\t */\n\t\t\tfilter_string_list(&dco->paths, 0,\n\t\t\t\t&remove_available_paths, &available_paths);\n\n\t\t\tfor_each_string_list_item(path, &available_paths) {\n\t\t\t\tstruct cache_entry* ce;\n\n\t\t\t\tif (!path->util) {\n\t\t\t\t\terror(\"external filter '%s' signaled that '%s' \"\n\t\t\t\t\t      \"is now available although it has not been \"\n\t\t\t\t\t      \"delayed earlier\",\n\t\t\t\t\t      filter->string, path->string);\n\t\t\t\t\terrs |= 1;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Do not ask the filter for available blobs,\n\t\t\t\t\t * again, as the filter is likely buggy.\n\t\t\t\t\t */\n\t\t\t\t\tfilter->string = \"\";\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tce = index_file_exists(state->istate, path->string,\n\t\t\t\t\t\t       strlen(path->string), 0);\n\t\t\t\tif (ce) {\n\t\t\t\t\terrs |= checkout_entry(ce, state, NULL, nr_checkouts);\n\t\t\t\t\tfiltered_bytes += ce->ce_stat_data.sd_size;\n\t\t\t\t\tdisplay_throughput(progress, filtered_bytes);\n\t\t\t\t} else\n\t\t\t\t\terrs = 1;\n\t\t\t}\n\t\t}\n\t\tstring_list_remove_empty_items(&dco->filters, 0);\n\t}\n\tstop_progress(&progress);\n\tstring_list_clear(&dco->filters, 0);\n\n\t/* At this point we should not have any delayed paths anymore. */\n\terrs |= dco->paths.nr;\n\tfor_each_string_list_item(path, &dco->paths) {\n\t\terror(\"'%s' was not filtered properly\", path->string);\n\t}\n\tstring_list_clear(&dco->paths, 0);\n\n\tfree(dco);\n\tstate->delayed_checkout = NULL;\n\n\treturn errs;\n}\n\nstatic int write_entry(struct cache_entry *ce,\n\t\t       char *path, const struct checkout *state, int to_tempfile)\n{\n\tunsigned int ce_mode_s_ifmt = ce->ce_mode & S_IFMT;\n\tstruct delayed_checkout *dco = state->delayed_checkout;\n\tint fd, ret, fstat_done = 0;\n\tchar *new_blob;\n\tstruct strbuf buf = STRBUF_INIT;\n\tunsigned long size;\n\tssize_t wrote;\n\tsize_t newsize = 0;\n\tstruct stat st;\n\tconst struct submodule *sub;\n\tstruct checkout_metadata meta;\n\n\tclone_checkout_metadata(&meta, &state->meta, &ce->oid);\n\n\tif (ce_mode_s_ifmt == S_IFREG) {\n\t\tstruct stream_filter *filter = get_stream_filter(state->istate, ce->name,\n\t\t\t\t\t\t\t\t &ce->oid);\n\t\tif (filter &&\n\t\t    !streaming_write_entry(ce, path, filter,\n\t\t\t\t\t   state, to_tempfile,\n\t\t\t\t\t   &fstat_done, &st))\n\t\t\tgoto finish;\n\t}\n\n\tswitch (ce_mode_s_ifmt) {\n\tcase S_IFLNK:\n\t\tnew_blob = read_blob_entry(ce, &size);\n\t\tif (!new_blob)\n\t\t\treturn error(\"unable to read sha1 file of %s (%s)\",\n\t\t\t\t     path, oid_to_hex(&ce->oid));\n\n\t\t/*\n\t\t * We can't make a real symlink; write out a regular file entry\n\t\t * with the symlink destination as its contents.\n\t\t */\n\t\tif (!has_symlinks || to_tempfile)\n\t\t\tgoto write_file_entry;\n\n\t\tret = symlink(new_blob, path);\n\t\tfree(new_blob);\n\t\tif (ret)\n\t\t\treturn error_errno(\"unable to create symlink %s\", path);\n\t\tbreak;\n\n\tcase S_IFREG:\n\t\t/*\n\t\t * We do not send the blob in case of a retry, so do not\n\t\t * bother reading it at all.\n\t\t */\n\t\tif (dco && dco->state == CE_RETRY) {\n\t\t\tnew_blob = NULL;\n\t\t\tsize = 0;\n\t\t} else {\n\t\t\tnew_blob = read_blob_entry(ce, &size);\n\t\t\tif (!new_blob)\n\t\t\t\treturn error(\"unable to read sha1 file of %s (%s)\",\n\t\t\t\t\t     path, oid_to_hex(&ce->oid));\n\t\t}\n\n\t\t/*\n\t\t * Convert from git internal format to working tree format\n\t\t */\n\t\tif (dco && dco->state != CE_NO_DELAY) {\n\t\t\tret = async_convert_to_working_tree(state->istate, ce->name, new_blob,\n\t\t\t\t\t\t\t    size, &buf, &meta, dco);\n\t\t\tif (ret && string_list_has_string(&dco->paths, ce->name)) {\n\t\t\t\tfree(new_blob);\n\t\t\t\tgoto delayed;\n\t\t\t}\n\t\t} else\n\t\t\tret = convert_to_working_tree(state->istate, ce->name, new_blob, size, &buf, &meta);\n\n\t\tif (ret) {\n\t\t\tfree(new_blob);\n\t\t\tnew_blob = strbuf_detach(&buf, &newsize);\n\t\t\tsize = newsize;\n\t\t}\n\t\t/*\n\t\t * No \"else\" here as errors from convert are OK at this\n\t\t * point. If the error would have been fatal (e.g.\n\t\t * filter is required), then we would have died already.\n\t\t */\n\n\twrite_file_entry:\n\t\tfd = open_output_fd(path, ce, to_tempfile);\n\t\tif (fd < 0) {\n\t\t\tfree(new_blob);\n\t\t\treturn error_errno(\"unable to create file %s\", path);\n\t\t}\n\n\t\twrote = write_in_full(fd, new_blob, size);\n\t\tif (!to_tempfile)\n\t\t\tfstat_done = fstat_output(fd, state, &st);\n\t\tclose(fd);\n\t\tfree(new_blob);\n\t\tif (wrote < 0)\n\t\t\treturn error(\"unable to write file %s\", path);\n\t\tbreak;\n\n\tcase S_IFGITLINK:\n\t\tif (to_tempfile)\n\t\t\treturn error(\"cannot create temporary submodule %s\", path);\n\t\tif (mkdir(path, 0777) < 0)\n\t\t\treturn error(\"cannot create submodule directory %s\", path);\n\t\tsub = submodule_from_ce(ce);\n\t\tif (sub)\n\t\t\treturn submodule_move_head(ce->name,\n\t\t\t\tNULL, oid_to_hex(&ce->oid),\n\t\t\t\tstate->force ? SUBMODULE_MOVE_HEAD_FORCE : 0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn error(\"unknown file mode for %s in index\", path);\n\t}\n\nfinish:\n\tif (state->refresh_cache) {\n\t\tassert(state->istate);\n\t\tif (!fstat_done)\n\t\t\tif (lstat(ce->name, &st) < 0)\n\t\t\t\treturn error_errno(\"unable to stat just-written file %s\",\n\t\t\t\t\t\t   ce->name);\n\t\tfill_stat_cache_info(state->istate, ce, &st);\n\t\tce->ce_flags |= CE_UPDATE_IN_BASE;\n\t\tmark_fsmonitor_invalid(state->istate, ce);\n\t\tstate->istate->cache_changed |= CE_ENTRY_CHANGED;\n\t}\ndelayed:\n\treturn 0;\n}\n\n/*\n * This is like 'lstat()', except it refuses to follow symlinks\n * in the path, after skipping \"skiplen\".\n */\nstatic int check_path(const char *path, int len, struct stat *st, int skiplen)\n{\n\tconst char *slash = path + len;\n\n\twhile (path < slash && *slash != '/')\n\t\tslash--;\n\tif (!has_dirs_only_path(path, slash - path, skiplen)) {\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\treturn lstat(path, st);\n}\n\nstatic void mark_colliding_entries(const struct checkout *state,\n\t\t\t\t   struct cache_entry *ce, struct stat *st)\n{\n\tint i, trust_ino = check_stat;\n\n#if defined(GIT_WINDOWS_NATIVE) || defined(__CYGWIN__)\n\ttrust_ino = 0;\n#endif\n\n\tce->ce_flags |= CE_MATCHED;\n\n\tfor (i = 0; i < state->istate->cache_nr; i++) {\n\t\tstruct cache_entry *dup = state->istate->cache[i];\n\n\t\tif (dup == ce)\n\t\t\tbreak;\n\n\t\tif (dup->ce_flags & (CE_MATCHED | CE_VALID | CE_SKIP_WORKTREE))\n\t\t\tcontinue;\n\n\t\tif ((trust_ino && !match_stat_data(&dup->ce_stat_data, st)) ||\n\t\t    (!trust_ino && !fspathcmp(ce->name, dup->name))) {\n\t\t\tdup->ce_flags |= CE_MATCHED;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*\n * Write the contents from ce out to the working tree.\n *\n * When topath[] is not NULL, instead of writing to the working tree\n * file named by ce, a temporary file is created by this function and\n * its name is returned in topath[], which must be able to hold at\n * least TEMPORARY_FILENAME_LENGTH bytes long.\n */\nint checkout_entry(struct cache_entry *ce, const struct checkout *state,\n\t\t   char *topath, int *nr_checkouts)\n{\n\tstatic struct strbuf path = STRBUF_INIT;\n\tstruct stat st;\n\n\tif (ce->ce_flags & CE_WT_REMOVE) {\n\t\tif (topath)\n\t\t\t/*\n\t\t\t * No content and thus no path to create, so we have\n\t\t\t * no pathname to return.\n\t\t\t */\n\t\t\tBUG(\"Can't remove entry to a path\");\n\t\tunlink_entry(ce);\n\t\treturn 0;\n\t}\n\n\tif (topath)\n\t\treturn write_entry(ce, topath, state, 1);\n\n\tstrbuf_reset(&path);\n\tstrbuf_add(&path, state->base_dir, state->base_dir_len);\n\tstrbuf_add(&path, ce->name, ce_namelen(ce));\n\n\tif (!check_path(path.buf, path.len, &st, state->base_dir_len)) {\n\t\tconst struct submodule *sub;\n\t\tunsigned changed = ie_match_stat(state->istate, ce, &st,\n\t\t\t\t\t\t CE_MATCH_IGNORE_VALID | CE_MATCH_IGNORE_SKIP_WORKTREE);\n\t\t/*\n\t\t * Needs to be checked before !changed returns early,\n\t\t * as the possibly empty directory was not changed\n\t\t */\n\t\tsub = submodule_from_ce(ce);\n\t\tif (sub) {\n\t\t\tint err;\n\t\t\tif (!is_submodule_populated_gently(ce->name, &err)) {\n\t\t\t\tstruct stat sb;\n\t\t\t\tif (lstat(ce->name, &sb))\n\t\t\t\t\tdie(_(\"could not stat file '%s'\"), ce->name);\n\t\t\t\tif (!(st.st_mode & S_IFDIR))\n\t\t\t\t\tunlink_or_warn(ce->name);\n\n\t\t\t\treturn submodule_move_head(ce->name,\n\t\t\t\t\tNULL, oid_to_hex(&ce->oid), 0);\n\t\t\t} else\n\t\t\t\treturn submodule_move_head(ce->name,\n\t\t\t\t\t\"HEAD\", oid_to_hex(&ce->oid),\n\t\t\t\t\tstate->force ? SUBMODULE_MOVE_HEAD_FORCE : 0);\n\t\t}\n\n\t\tif (!changed)\n\t\t\treturn 0;\n\t\tif (!state->force) {\n\t\t\tif (!state->quiet)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"%s already exists, no checkout\\n\",\n\t\t\t\t\tpath.buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (state->clone)\n\t\t\tmark_colliding_entries(state, ce, &st);\n\n\t\t/*\n\t\t * We unlink the old file, to get the new one with the\n\t\t * right permissions (including umask, which is nasty\n\t\t * to emulate by hand - much easier to let the system\n\t\t * just do the right thing)\n\t\t */\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\t/* If it is a gitlink, leave it alone! */\n\t\t\tif (S_ISGITLINK(ce->ce_mode))\n\t\t\t\treturn 0;\n\t\t\tif (!state->force)\n\t\t\t\treturn error(\"%s is a directory\", path.buf);\n\t\t\tremove_subtree(&path);\n\t\t} else if (unlink(path.buf))\n\t\t\treturn error_errno(\"unable to unlink old '%s'\", path.buf);\n\t} else if (state->not_new)\n\t\treturn 0;\n\n\tcreate_directories(path.buf, path.len, state);\n\tif (nr_checkouts)\n\t\t(*nr_checkouts)++;\n\treturn write_entry(ce, path.buf, state, 0);\n}\n\nvoid unlink_entry(const struct cache_entry *ce)\n{\n\tconst struct submodule *sub = submodule_from_ce(ce);\n\tif (sub) {\n\t\t/* state.force is set at the caller. */\n\t\tsubmodule_move_head(ce->name, \"HEAD\", NULL,\n\t\t\t\t    SUBMODULE_MOVE_HEAD_FORCE);\n\t}\n\tif (!check_leading_path(ce->name, ce_namelen(ce)))\n\t\treturn;\n\tif (remove_or_warn(ce->ce_mode, ce->name))\n\t\treturn;\n\tschedule_dir_for_removal(ce->name, ce_namelen(ce));\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00b49033668160574c35555293c0c755cbafaeaa",
  "sha1_ok": true,
  "size": 14437
}
