{
  "content": {
    "base64": "LyoKQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQwoKVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUKbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0Cmh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL29wZW4tc291cmNlL2xpY2Vuc2VzL2JzZAoqLwoKI2luY2x1ZGUgInN5c3RlbS5oIgoKI2luY2x1ZGUgImJhc2ljcy5oIgojaW5jbHVkZSAiYmxvY2tzb3VyY2UuaCIKI2luY2x1ZGUgInJlZnRhYmxlLWJsb2Nrc291cmNlLmgiCiNpbmNsdWRlICJyZWZ0YWJsZS1lcnJvci5oIgoKc3RhdGljIHZvaWQgc3RyYnVmX3JldHVybl9ibG9jayh2b2lkICpiLCBzdHJ1Y3QgcmVmdGFibGVfYmxvY2sgKmRlc3QpCnsKCW1lbXNldChkZXN0LT5kYXRhLCAweGZmLCBkZXN0LT5sZW4pOwoJcmVmdGFibGVfZnJlZShkZXN0LT5kYXRhKTsKfQoKc3RhdGljIHZvaWQgc3RyYnVmX2Nsb3NlKHZvaWQgKmIpCnsKfQoKc3RhdGljIGludCBzdHJidWZfcmVhZF9ibG9jayh2b2lkICp2LCBzdHJ1Y3QgcmVmdGFibGVfYmxvY2sgKmRlc3QsIHVpbnQ2NF90IG9mZiwKCQkJICAgICB1aW50MzJfdCBzaXplKQp7CglzdHJ1Y3Qgc3RyYnVmICpiID0gdjsKCWFzc2VydChvZmYgKyBzaXplIDw9IGItPmxlbik7CglkZXN0LT5kYXRhID0gcmVmdGFibGVfY2FsbG9jKHNpemUpOwoJbWVtY3B5KGRlc3QtPmRhdGEsIGItPmJ1ZiArIG9mZiwgc2l6ZSk7CglkZXN0LT5sZW4gPSBzaXplOwoJcmV0dXJuIHNpemU7Cn0KCnN0YXRpYyB1aW50NjRfdCBzdHJidWZfc2l6ZSh2b2lkICpiKQp7CglyZXR1cm4gKChzdHJ1Y3Qgc3RyYnVmICopYiktPmxlbjsKfQoKc3RhdGljIHN0cnVjdCByZWZ0YWJsZV9ibG9ja19zb3VyY2VfdnRhYmxlIHN0cmJ1Zl92dGFibGUgPSB7Cgkuc2l6ZSA9ICZzdHJidWZfc2l6ZSwKCS5yZWFkX2Jsb2NrID0gJnN0cmJ1Zl9yZWFkX2Jsb2NrLAoJLnJldHVybl9ibG9jayA9ICZzdHJidWZfcmV0dXJuX2Jsb2NrLAoJLmNsb3NlID0gJnN0cmJ1Zl9jbG9zZSwKfTsKCnZvaWQgYmxvY2tfc291cmNlX2Zyb21fc3RyYnVmKHN0cnVjdCByZWZ0YWJsZV9ibG9ja19zb3VyY2UgKmJzLAoJCQkgICAgICBzdHJ1Y3Qgc3RyYnVmICpidWYpCnsKCWFzc2VydCghYnMtPm9wcyk7Cglicy0+b3BzID0gJnN0cmJ1Zl92dGFibGU7Cglicy0+YXJnID0gYnVmOwp9CgpzdGF0aWMgdm9pZCBtYWxsb2NfcmV0dXJuX2Jsb2NrKHZvaWQgKmIsIHN0cnVjdCByZWZ0YWJsZV9ibG9jayAqZGVzdCkKewoJbWVtc2V0KGRlc3QtPmRhdGEsIDB4ZmYsIGRlc3QtPmxlbik7CglyZWZ0YWJsZV9mcmVlKGRlc3QtPmRhdGEpOwp9CgpzdGF0aWMgc3RydWN0IHJlZnRhYmxlX2Jsb2NrX3NvdXJjZV92dGFibGUgbWFsbG9jX3Z0YWJsZSA9IHsKCS5yZXR1cm5fYmxvY2sgPSAmbWFsbG9jX3JldHVybl9ibG9jaywKfTsKCnN0YXRpYyBzdHJ1Y3QgcmVmdGFibGVfYmxvY2tfc291cmNlIG1hbGxvY19ibG9ja19zb3VyY2VfaW5zdGFuY2UgPSB7Cgkub3BzID0gJm1hbGxvY192dGFibGUsCn07CgpzdHJ1Y3QgcmVmdGFibGVfYmxvY2tfc291cmNlIG1hbGxvY19ibG9ja19zb3VyY2Uodm9pZCkKewoJcmV0dXJuIG1hbGxvY19ibG9ja19zb3VyY2VfaW5zdGFuY2U7Cn0KCnN0cnVjdCBmaWxlX2Jsb2NrX3NvdXJjZSB7CglpbnQgZmQ7Cgl1aW50NjRfdCBzaXplOwp9OwoKc3RhdGljIHVpbnQ2NF90IGZpbGVfc2l6ZSh2b2lkICpiKQp7CglyZXR1cm4gKChzdHJ1Y3QgZmlsZV9ibG9ja19zb3VyY2UgKiliKS0+c2l6ZTsKfQoKc3RhdGljIHZvaWQgZmlsZV9yZXR1cm5fYmxvY2sodm9pZCAqYiwgc3RydWN0IHJlZnRhYmxlX2Jsb2NrICpkZXN0KQp7CgltZW1zZXQoZGVzdC0+ZGF0YSwgMHhmZiwgZGVzdC0+bGVuKTsKCXJlZnRhYmxlX2ZyZWUoZGVzdC0+ZGF0YSk7Cn0KCnN0YXRpYyB2b2lkIGZpbGVfY2xvc2Uodm9pZCAqYikKewoJaW50IGZkID0gKChzdHJ1Y3QgZmlsZV9ibG9ja19zb3VyY2UgKiliKS0+ZmQ7CglpZiAoZmQgPiAwKSB7CgkJY2xvc2UoZmQpOwoJCSgoc3RydWN0IGZpbGVfYmxvY2tfc291cmNlICopYiktPmZkID0gMDsKCX0KCglyZWZ0YWJsZV9mcmVlKGIpOwp9CgpzdGF0aWMgaW50IGZpbGVfcmVhZF9ibG9jayh2b2lkICp2LCBzdHJ1Y3QgcmVmdGFibGVfYmxvY2sgKmRlc3QsIHVpbnQ2NF90IG9mZiwKCQkJICAgdWludDMyX3Qgc2l6ZSkKewoJc3RydWN0IGZpbGVfYmxvY2tfc291cmNlICpiID0gdjsKCWFzc2VydChvZmYgKyBzaXplIDw9IGItPnNpemUpOwoJZGVzdC0+ZGF0YSA9IHJlZnRhYmxlX21hbGxvYyhzaXplKTsKCWlmIChwcmVhZChiLT5mZCwgZGVzdC0+ZGF0YSwgc2l6ZSwgb2ZmKSAhPSBzaXplKQoJCXJldHVybiAtMTsKCWRlc3QtPmxlbiA9IHNpemU7CglyZXR1cm4gc2l6ZTsKfQoKc3RhdGljIHN0cnVjdCByZWZ0YWJsZV9ibG9ja19zb3VyY2VfdnRhYmxlIGZpbGVfdnRhYmxlID0gewoJLnNpemUgPSAmZmlsZV9zaXplLAoJLnJlYWRfYmxvY2sgPSAmZmlsZV9yZWFkX2Jsb2NrLAoJLnJldHVybl9ibG9jayA9ICZmaWxlX3JldHVybl9ibG9jaywKCS5jbG9zZSA9ICZmaWxlX2Nsb3NlLAp9OwoKaW50IHJlZnRhYmxlX2Jsb2NrX3NvdXJjZV9mcm9tX2ZpbGUoc3RydWN0IHJlZnRhYmxlX2Jsb2NrX3NvdXJjZSAqYnMsCgkJCQkgICAgY29uc3QgY2hhciAqbmFtZSkKewoJc3RydWN0IHN0YXQgc3QgPSB7IDAgfTsKCWludCBlcnIgPSAwOwoJaW50IGZkID0gb3BlbihuYW1lLCBPX1JET05MWSk7CglzdHJ1Y3QgZmlsZV9ibG9ja19zb3VyY2UgKnAgPSBOVUxMOwoJaWYgKGZkIDwgMCkgewoJCWlmIChlcnJubyA9PSBFTk9FTlQpIHsKCQkJcmV0dXJuIFJFRlRBQkxFX05PVF9FWElTVF9FUlJPUjsKCQl9CgkJcmV0dXJuIC0xOwoJfQoKCWVyciA9IGZzdGF0KGZkLCAmc3QpOwoJaWYgKGVyciA8IDApCgkJcmV0dXJuIC0xOwoKCXAgPSByZWZ0YWJsZV9jYWxsb2Moc2l6ZW9mKHN0cnVjdCBmaWxlX2Jsb2NrX3NvdXJjZSkpOwoJcC0+c2l6ZSA9IHN0LnN0X3NpemU7CglwLT5mZCA9IGZkOwoKCWFzc2VydCghYnMtPm9wcyk7Cglicy0+b3BzID0gJmZpbGVfdnRhYmxlOwoJYnMtPmFyZyA9IHA7CglyZXR1cm4gMDsKfQo=",
    "text": "/*\nCopyright 2020 Google LLC\n\nUse of this source code is governed by a BSD-style\nlicense that can be found in the LICENSE file or at\nhttps://developers.google.com/open-source/licenses/bsd\n*/\n\n#include \"system.h\"\n\n#include \"basics.h\"\n#include \"blocksource.h\"\n#include \"reftable-blocksource.h\"\n#include \"reftable-error.h\"\n\nstatic void strbuf_return_block(void *b, struct reftable_block *dest)\n{\n\tmemset(dest->data, 0xff, dest->len);\n\treftable_free(dest->data);\n}\n\nstatic void strbuf_close(void *b)\n{\n}\n\nstatic int strbuf_read_block(void *v, struct reftable_block *dest, uint64_t off,\n\t\t\t     uint32_t size)\n{\n\tstruct strbuf *b = v;\n\tassert(off + size <= b->len);\n\tdest->data = reftable_calloc(size);\n\tmemcpy(dest->data, b->buf + off, size);\n\tdest->len = size;\n\treturn size;\n}\n\nstatic uint64_t strbuf_size(void *b)\n{\n\treturn ((struct strbuf *)b)->len;\n}\n\nstatic struct reftable_block_source_vtable strbuf_vtable = {\n\t.size = &strbuf_size,\n\t.read_block = &strbuf_read_block,\n\t.return_block = &strbuf_return_block,\n\t.close = &strbuf_close,\n};\n\nvoid block_source_from_strbuf(struct reftable_block_source *bs,\n\t\t\t      struct strbuf *buf)\n{\n\tassert(!bs->ops);\n\tbs->ops = &strbuf_vtable;\n\tbs->arg = buf;\n}\n\nstatic void malloc_return_block(void *b, struct reftable_block *dest)\n{\n\tmemset(dest->data, 0xff, dest->len);\n\treftable_free(dest->data);\n}\n\nstatic struct reftable_block_source_vtable malloc_vtable = {\n\t.return_block = &malloc_return_block,\n};\n\nstatic struct reftable_block_source malloc_block_source_instance = {\n\t.ops = &malloc_vtable,\n};\n\nstruct reftable_block_source malloc_block_source(void)\n{\n\treturn malloc_block_source_instance;\n}\n\nstruct file_block_source {\n\tint fd;\n\tuint64_t size;\n};\n\nstatic uint64_t file_size(void *b)\n{\n\treturn ((struct file_block_source *)b)->size;\n}\n\nstatic void file_return_block(void *b, struct reftable_block *dest)\n{\n\tmemset(dest->data, 0xff, dest->len);\n\treftable_free(dest->data);\n}\n\nstatic void file_close(void *b)\n{\n\tint fd = ((struct file_block_source *)b)->fd;\n\tif (fd > 0) {\n\t\tclose(fd);\n\t\t((struct file_block_source *)b)->fd = 0;\n\t}\n\n\treftable_free(b);\n}\n\nstatic int file_read_block(void *v, struct reftable_block *dest, uint64_t off,\n\t\t\t   uint32_t size)\n{\n\tstruct file_block_source *b = v;\n\tassert(off + size <= b->size);\n\tdest->data = reftable_malloc(size);\n\tif (pread(b->fd, dest->data, size, off) != size)\n\t\treturn -1;\n\tdest->len = size;\n\treturn size;\n}\n\nstatic struct reftable_block_source_vtable file_vtable = {\n\t.size = &file_size,\n\t.read_block = &file_read_block,\n\t.return_block = &file_return_block,\n\t.close = &file_close,\n};\n\nint reftable_block_source_from_file(struct reftable_block_source *bs,\n\t\t\t\t    const char *name)\n{\n\tstruct stat st = { 0 };\n\tint err = 0;\n\tint fd = open(name, O_RDONLY);\n\tstruct file_block_source *p = NULL;\n\tif (fd < 0) {\n\t\tif (errno == ENOENT) {\n\t\t\treturn REFTABLE_NOT_EXIST_ERROR;\n\t\t}\n\t\treturn -1;\n\t}\n\n\terr = fstat(fd, &st);\n\tif (err < 0)\n\t\treturn -1;\n\n\tp = reftable_calloc(sizeof(struct file_block_source));\n\tp->size = st.st_size;\n\tp->fd = fd;\n\n\tassert(!bs->ops);\n\tbs->ops = &file_vtable;\n\tbs->arg = p;\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0044eecd9aa39afa476dcfb8e6eeaaa89fb08b86",
  "sha1_ok": true,
  "size": 3098
}
