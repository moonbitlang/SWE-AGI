{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJ0cmFjZTIvdHIyX2RzdC5oIgojaW5jbHVkZSAidHJhY2UyL3RyMl9zaWQuaCIKI2luY2x1ZGUgInRyYWNlMi90cjJfc3lzZW52LmgiCgovKgogKiBIb3cgbWFueSBhdHRlbXB0cyB3ZSB3aWxsIG1ha2UgYXQgY3JlYXRpbmcgYW4gYXV0b21hdGljYWxseS1uYW1lZCB0cmFjZSBmaWxlLgogKi8KI2RlZmluZSBNQVhfQVVUT19BVFRFTVBUUyAxMAoKc3RhdGljIGludCB0cjJfZHN0X3dhbnRfd2FybmluZyh2b2lkKQp7CglzdGF0aWMgaW50IHRyMmVudl9kc3RfZGVidWcgPSAtMTsKCglpZiAodHIyZW52X2RzdF9kZWJ1ZyA9PSAtMSkgewoJCWNvbnN0IGNoYXIgKmVudl92YWx1ZSA9IHRyMl9zeXNlbnZfZ2V0KFRSMl9TWVNFTlZfRFNUX0RFQlVHKTsKCQlpZiAoIWVudl92YWx1ZSB8fCAhKmVudl92YWx1ZSkKCQkJdHIyZW52X2RzdF9kZWJ1ZyA9IDA7CgkJZWxzZQoJCQl0cjJlbnZfZHN0X2RlYnVnID0gYXRvaShlbnZfdmFsdWUpID4gMDsKCX0KCglyZXR1cm4gdHIyZW52X2RzdF9kZWJ1ZzsKfQoKdm9pZCB0cjJfZHN0X3RyYWNlX2Rpc2FibGUoc3RydWN0IHRyMl9kc3QgKmRzdCkKewoJaWYgKGRzdC0+bmVlZF9jbG9zZSkKCQljbG9zZShkc3QtPmZkKTsKCWRzdC0+ZmQgPSAwOwoJZHN0LT5pbml0aWFsaXplZCA9IDE7Cglkc3QtPm5lZWRfY2xvc2UgPSAwOwp9CgpzdGF0aWMgaW50IHRyMl9kc3RfdHJ5X2F1dG9fcGF0aChzdHJ1Y3QgdHIyX2RzdCAqZHN0LCBjb25zdCBjaGFyICp0Z3RfcHJlZml4KQp7CglpbnQgZmQ7Cgljb25zdCBjaGFyICpsYXN0X3NsYXNoLCAqc2lkID0gdHIyX3NpZF9nZXQoKTsKCXN0cnVjdCBzdHJidWYgcGF0aCA9IFNUUkJVRl9JTklUOwoJc2l6ZV90IGJhc2VfcGF0aF9sZW47Cgl1bnNpZ25lZCBhdHRlbXB0X2NvdW50OwoKCWxhc3Rfc2xhc2ggPSBzdHJyY2hyKHNpZCwgJy8nKTsKCWlmIChsYXN0X3NsYXNoKQoJCXNpZCA9IGxhc3Rfc2xhc2ggKyAxOwoKCXN0cmJ1Zl9hZGRzdHIoJnBhdGgsIHRndF9wcmVmaXgpOwoJaWYgKCFpc19kaXJfc2VwKHBhdGguYnVmW3BhdGgubGVuIC0gMV0pKQoJCXN0cmJ1Zl9hZGRjaCgmcGF0aCwgJy8nKTsKCXN0cmJ1Zl9hZGRzdHIoJnBhdGgsIHNpZCk7CgliYXNlX3BhdGhfbGVuID0gcGF0aC5sZW47CgoJZm9yIChhdHRlbXB0X2NvdW50ID0gMDsgYXR0ZW1wdF9jb3VudCA8IE1BWF9BVVRPX0FUVEVNUFRTOyBhdHRlbXB0X2NvdW50KyspIHsKCQlpZiAoYXR0ZW1wdF9jb3VudCA+IDApIHsKCQkJc3RyYnVmX3NldGxlbigmcGF0aCwgYmFzZV9wYXRoX2xlbik7CgkJCXN0cmJ1Zl9hZGRmKCZwYXRoLCAiLiVkIiwgYXR0ZW1wdF9jb3VudCk7CgkJfQoKCQlmZCA9IG9wZW4ocGF0aC5idWYsIE9fV1JPTkxZIHwgT19DUkVBVCB8IE9fRVhDTCwgMDY2Nik7CgkJaWYgKGZkICE9IC0xKQoJCQlicmVhazsKCX0KCglpZiAoZmQgPT0gLTEpIHsKCQlpZiAodHIyX2RzdF93YW50X3dhcm5pbmcoKSkKCQkJd2FybmluZygidHJhY2UyOiBjb3VsZCBub3Qgb3BlbiAnJS4qcycgZm9yICclcycgdHJhY2luZzogJXMiLAoJCQkJKGludCkgYmFzZV9wYXRoX2xlbiwgcGF0aC5idWYsCgkJCQl0cjJfc3lzZW52X2Rpc3BsYXlfbmFtZShkc3QtPnN5c2Vudl92YXIpLAoJCQkJc3RyZXJyb3IoZXJybm8pKTsKCgkJdHIyX2RzdF90cmFjZV9kaXNhYmxlKGRzdCk7CgkJc3RyYnVmX3JlbGVhc2UoJnBhdGgpOwoJCXJldHVybiAwOwoJfQoKCXN0cmJ1Zl9yZWxlYXNlKCZwYXRoKTsKCglkc3QtPmZkID0gZmQ7Cglkc3QtPm5lZWRfY2xvc2UgPSAxOwoJZHN0LT5pbml0aWFsaXplZCA9IDE7CgoJcmV0dXJuIGRzdC0+ZmQ7Cn0KCnN0YXRpYyBpbnQgdHIyX2RzdF90cnlfcGF0aChzdHJ1Y3QgdHIyX2RzdCAqZHN0LCBjb25zdCBjaGFyICp0Z3RfdmFsdWUpCnsKCWludCBmZCA9IG9wZW4odGd0X3ZhbHVlLCBPX1dST05MWSB8IE9fQVBQRU5EIHwgT19DUkVBVCwgMDY2Nik7CglpZiAoZmQgPT0gLTEpIHsKCQlpZiAodHIyX2RzdF93YW50X3dhcm5pbmcoKSkKCQkJd2FybmluZygidHJhY2UyOiBjb3VsZCBub3Qgb3BlbiAnJXMnIGZvciAnJXMnIHRyYWNpbmc6ICVzIiwKCQkJCXRndF92YWx1ZSwKCQkJCXRyMl9zeXNlbnZfZGlzcGxheV9uYW1lKGRzdC0+c3lzZW52X3ZhciksCgkJCQlzdHJlcnJvcihlcnJubykpOwoKCQl0cjJfZHN0X3RyYWNlX2Rpc2FibGUoZHN0KTsKCQlyZXR1cm4gMDsKCX0KCglkc3QtPmZkID0gZmQ7Cglkc3QtPm5lZWRfY2xvc2UgPSAxOwoJZHN0LT5pbml0aWFsaXplZCA9IDE7CgoJcmV0dXJuIGRzdC0+ZmQ7Cn0KCiNpZm5kZWYgTk9fVU5JWF9TT0NLRVRTCiNkZWZpbmUgUFJFRklYX0FGX1VOSVggImFmX3VuaXg6IgojZGVmaW5lIFBSRUZJWF9BRl9VTklYX1NUUkVBTSAiYWZfdW5peDpzdHJlYW06IgojZGVmaW5lIFBSRUZJWF9BRl9VTklYX0RHUkFNICJhZl91bml4OmRncmFtOiIKCnN0YXRpYyBpbnQgdHIyX2RzdF90cnlfdWRzX2Nvbm5lY3QoY29uc3QgY2hhciAqcGF0aCwgaW50IHNvY2tfdHlwZSwgaW50ICpvdXRfZmQpCnsKCWludCBmZDsKCXN0cnVjdCBzb2NrYWRkcl91biBzYTsKCglmZCA9IHNvY2tldChBRl9VTklYLCBzb2NrX3R5cGUsIDApOwoJaWYgKGZkID09IC0xKQoJCXJldHVybiAtMTsKCglzYS5zdW5fZmFtaWx5ID0gQUZfVU5JWDsKCXN0cmxjcHkoc2Euc3VuX3BhdGgsIHBhdGgsIHNpemVvZihzYS5zdW5fcGF0aCkpOwoKCWlmIChjb25uZWN0KGZkLCAoc3RydWN0IHNvY2thZGRyICopJnNhLCBzaXplb2Yoc2EpKSA9PSAtMSkgewoJCWludCBzYXZlZF9lcnJubyA9IGVycm5vOwoJCWNsb3NlKGZkKTsKCQllcnJubyA9IHNhdmVkX2Vycm5vOwoJCXJldHVybiAtMTsKCX0KCgkqb3V0X2ZkID0gZmQ7CglyZXR1cm4gMDsKfQoKI2RlZmluZSBUUjJfRFNUX1VEU19UUllfU1RSRUFNICgxIDw8IDApCiNkZWZpbmUgVFIyX0RTVF9VRFNfVFJZX0RHUkFNICAoMSA8PCAxKQoKc3RhdGljIGludCB0cjJfZHN0X3RyeV91bml4X2RvbWFpbl9zb2NrZXQoc3RydWN0IHRyMl9kc3QgKmRzdCwKCQkJCQkgIGNvbnN0IGNoYXIgKnRndF92YWx1ZSkKewoJdW5zaWduZWQgaW50IHVkc190cnkgPSAwOwoJaW50IGZkOwoJY29uc3QgY2hhciAqcGF0aCA9IE5VTEw7CgoJLyoKCSAqIEFsbG93ICJhZl91bml4Ols8dHlwZT46XTxhYnNvbHV0ZV9wYXRoPiIKCSAqCgkgKiBUcmFjZTIgYWx3YXlzIHdyaXRlcyBjb21wbGV0ZSBpbmRpdmlkdWFsIG1lc3NhZ2VzICh3aXRob3V0CgkgKiBjaHVua2luZyksIHNvIHdlIGNhbiB0YWxrIHRvIGVpdGhlciBER1JBTSBvciBTVFJFQU0gdHlwZSBzb2NrZXRzLgoJICoKCSAqIEFsbG93IHRoZSB1c2VyIHRvIGV4cGxpY2l0bHkgcmVxdWVzdCB0aGUgc29ja2V0IHR5cGUuCgkgKgoJICogSWYgdGhleSBvbWl0IHRoZSBzb2NrZXQgdHlwZSwgdHJ5IG9uZSBhbmQgdGhlbiB0aGUgb3RoZXIuCgkgKi8KCglpZiAoc2tpcF9wcmVmaXgodGd0X3ZhbHVlLCBQUkVGSVhfQUZfVU5JWF9TVFJFQU0sICZwYXRoKSkKCQl1ZHNfdHJ5IHw9IFRSMl9EU1RfVURTX1RSWV9TVFJFQU07CgoJZWxzZSBpZiAoc2tpcF9wcmVmaXgodGd0X3ZhbHVlLCBQUkVGSVhfQUZfVU5JWF9ER1JBTSwgJnBhdGgpKQoJCXVkc190cnkgfD0gVFIyX0RTVF9VRFNfVFJZX0RHUkFNOwoKCWVsc2UgaWYgKHNraXBfcHJlZml4KHRndF92YWx1ZSwgUFJFRklYX0FGX1VOSVgsICZwYXRoKSkKCQl1ZHNfdHJ5IHw9IFRSMl9EU1RfVURTX1RSWV9TVFJFQU0gfCBUUjJfRFNUX1VEU19UUllfREdSQU07CgoJaWYgKCFwYXRoIHx8ICEqcGF0aCkgewoJCWlmICh0cjJfZHN0X3dhbnRfd2FybmluZygpKQoJCQl3YXJuaW5nKCJ0cmFjZTI6IGludmFsaWQgQUZfVU5JWCB2YWx1ZSAnJXMnIGZvciAnJXMnIHRyYWNpbmciLAoJCQkJdGd0X3ZhbHVlLAoJCQkJdHIyX3N5c2Vudl9kaXNwbGF5X25hbWUoZHN0LT5zeXNlbnZfdmFyKSk7CgoJCXRyMl9kc3RfdHJhY2VfZGlzYWJsZShkc3QpOwoJCXJldHVybiAwOwoJfQoKCWlmICghaXNfYWJzb2x1dGVfcGF0aChwYXRoKSB8fAoJICAgIHN0cmxlbihwYXRoKSA+PSBzaXplb2YoKChzdHJ1Y3Qgc29ja2FkZHJfdW4gKikwKS0+c3VuX3BhdGgpKSB7CgkJaWYgKHRyMl9kc3Rfd2FudF93YXJuaW5nKCkpCgkJCXdhcm5pbmcoInRyYWNlMjogaW52YWxpZCBBRl9VTklYIHBhdGggJyVzJyBmb3IgJyVzJyB0cmFjaW5nIiwKCQkJCXBhdGgsIHRyMl9zeXNlbnZfZGlzcGxheV9uYW1lKGRzdC0+c3lzZW52X3ZhcikpOwoKCQl0cjJfZHN0X3RyYWNlX2Rpc2FibGUoZHN0KTsKCQlyZXR1cm4gMDsKCX0KCglpZiAodWRzX3RyeSAmIFRSMl9EU1RfVURTX1RSWV9TVFJFQU0pIHsKCQlpZiAoIXRyMl9kc3RfdHJ5X3Vkc19jb25uZWN0KHBhdGgsIFNPQ0tfU1RSRUFNLCAmZmQpKQoJCQlnb3RvIGNvbm5lY3RlZDsKCQlpZiAoZXJybm8gIT0gRVBST1RPVFlQRSkKCQkJZ290byBlcnJvcjsKCX0KCWlmICh1ZHNfdHJ5ICYgVFIyX0RTVF9VRFNfVFJZX0RHUkFNKSB7CgkJaWYgKCF0cjJfZHN0X3RyeV91ZHNfY29ubmVjdChwYXRoLCBTT0NLX0RHUkFNLCAmZmQpKQoJCQlnb3RvIGNvbm5lY3RlZDsKCX0KCmVycm9yOgoJaWYgKHRyMl9kc3Rfd2FudF93YXJuaW5nKCkpCgkJd2FybmluZygidHJhY2UyOiBjb3VsZCBub3QgY29ubmVjdCB0byBzb2NrZXQgJyVzJyBmb3IgJyVzJyB0cmFjaW5nOiAlcyIsCgkJCXBhdGgsIHRyMl9zeXNlbnZfZGlzcGxheV9uYW1lKGRzdC0+c3lzZW52X3ZhciksCgkJCXN0cmVycm9yKGVycm5vKSk7CgoJdHIyX2RzdF90cmFjZV9kaXNhYmxlKGRzdCk7CglyZXR1cm4gMDsKCmNvbm5lY3RlZDoKCWRzdC0+ZmQgPSBmZDsKCWRzdC0+bmVlZF9jbG9zZSA9IDE7Cglkc3QtPmluaXRpYWxpemVkID0gMTsKCglyZXR1cm4gZHN0LT5mZDsKfQojZW5kaWYKCnN0YXRpYyB2b2lkIHRyMl9kc3RfbWFsZm9ybWVkX3dhcm5pbmcoc3RydWN0IHRyMl9kc3QgKmRzdCwKCQkJCSAgICAgIGNvbnN0IGNoYXIgKnRndF92YWx1ZSkKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCglzdHJidWZfYWRkZigmYnVmLCAidHJhY2UyOiB1bmtub3duIHZhbHVlIGZvciAnJXMnOiAnJXMnIiwKCQkgICAgdHIyX3N5c2Vudl9kaXNwbGF5X25hbWUoZHN0LT5zeXNlbnZfdmFyKSwgdGd0X3ZhbHVlKTsKCXdhcm5pbmcoIiVzIiwgYnVmLmJ1Zik7CgoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7Cn0KCmludCB0cjJfZHN0X2dldF90cmFjZV9mZChzdHJ1Y3QgdHIyX2RzdCAqZHN0KQp7Cgljb25zdCBjaGFyICp0Z3RfdmFsdWU7CgoJLyogZG9uJ3Qgb3BlbiB0d2ljZSAqLwoJaWYgKGRzdC0+aW5pdGlhbGl6ZWQpCgkJcmV0dXJuIGRzdC0+ZmQ7CgoJZHN0LT5pbml0aWFsaXplZCA9IDE7CgoJdGd0X3ZhbHVlID0gdHIyX3N5c2Vudl9nZXQoZHN0LT5zeXNlbnZfdmFyKTsKCglpZiAoIXRndF92YWx1ZSB8fCAhc3RyY21wKHRndF92YWx1ZSwgIiIpIHx8ICFzdHJjbXAodGd0X3ZhbHVlLCAiMCIpIHx8CgkgICAgIXN0cmNhc2VjbXAodGd0X3ZhbHVlLCAiZmFsc2UiKSkgewoJCWRzdC0+ZmQgPSAwOwoJCXJldHVybiBkc3QtPmZkOwoJfQoKCWlmICghc3RyY21wKHRndF92YWx1ZSwgIjEiKSB8fCAhc3RyY2FzZWNtcCh0Z3RfdmFsdWUsICJ0cnVlIikpIHsKCQlkc3QtPmZkID0gU1RERVJSX0ZJTEVOTzsKCQlyZXR1cm4gZHN0LT5mZDsKCX0KCglpZiAoc3RybGVuKHRndF92YWx1ZSkgPT0gMSAmJiBpc2RpZ2l0KCp0Z3RfdmFsdWUpKSB7CgkJZHN0LT5mZCA9IGF0b2kodGd0X3ZhbHVlKTsKCQlyZXR1cm4gZHN0LT5mZDsKCX0KCglpZiAoaXNfYWJzb2x1dGVfcGF0aCh0Z3RfdmFsdWUpKSB7CgkJaWYgKGlzX2RpcmVjdG9yeSh0Z3RfdmFsdWUpKQoJCQlyZXR1cm4gdHIyX2RzdF90cnlfYXV0b19wYXRoKGRzdCwgdGd0X3ZhbHVlKTsKCQllbHNlCgkJCXJldHVybiB0cjJfZHN0X3RyeV9wYXRoKGRzdCwgdGd0X3ZhbHVlKTsKCX0KCiNpZm5kZWYgTk9fVU5JWF9TT0NLRVRTCglpZiAoc3RhcnRzX3dpdGgodGd0X3ZhbHVlLCBQUkVGSVhfQUZfVU5JWCkpCgkJcmV0dXJuIHRyMl9kc3RfdHJ5X3VuaXhfZG9tYWluX3NvY2tldChkc3QsIHRndF92YWx1ZSk7CiNlbmRpZgoKCS8qIEFsd2F5cyB3YXJuIGFib3V0IG1hbGZvcm1lZCB2YWx1ZXMuICovCgl0cjJfZHN0X21hbGZvcm1lZF93YXJuaW5nKGRzdCwgdGd0X3ZhbHVlKTsKCXRyMl9kc3RfdHJhY2VfZGlzYWJsZShkc3QpOwoJcmV0dXJuIDA7Cn0KCmludCB0cjJfZHN0X3RyYWNlX3dhbnQoc3RydWN0IHRyMl9kc3QgKmRzdCkKewoJcmV0dXJuICEhdHIyX2RzdF9nZXRfdHJhY2VfZmQoZHN0KTsKfQoKdm9pZCB0cjJfZHN0X3dyaXRlX2xpbmUoc3RydWN0IHRyMl9kc3QgKmRzdCwgc3RydWN0IHN0cmJ1ZiAqYnVmX2xpbmUpCnsKCWludCBmZCA9IHRyMl9kc3RfZ2V0X3RyYWNlX2ZkKGRzdCk7CgoJc3RyYnVmX2NvbXBsZXRlX2xpbmUoYnVmX2xpbmUpOyAvKiBlbnN1cmUgZmluYWwgTkwgb24gYnVmZmVyICovCgoJLyoKCSAqIFdlIGRvIG5vdCB1c2Ugd3JpdGVfaW5fZnVsbCgpIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQKCSAqIGEgc2hvcnQtd3JpdGUgdG8gdHJ5IGFnYWluLiAgV2UgYXJlIHVzaW5nIE9fQVBQRU5EIG1vZGUKCSAqIGZpbGVzIGFuZCB0aGUga2VybmVsIGhhbmRsZXMgdGhlIGF0b21pYyBzZWVrK3dyaXRlLiBJZgoJICogYW5vdGhlciB0aHJlYWQgb3IgZ2l0IHByb2Nlc3MgaXMgY29uY3VycmVudGx5IHdyaXRpbmcgdG8KCSAqIHRoaXMgZmQgb3IgZmlsZSwgb3VyIHJlbWFpbmRlci13cml0ZSBtYXkgbm90IGJlIGNvbnRpZ3VvdXMKCSAqIHdpdGggb3VyIGluaXRpYWwgd3JpdGUgb2YgdGhpcyBtZXNzYWdlLiAgQW5kIHRoYXQgd2lsbAoJICogY29uZnVzZSByZWFkZXJzLiAgU28ganVzdCBkb24ndCBib3RoZXIuCgkgKgoJICogSXQgaXMgYXNzdW1lZCB0aGF0IFRSQUNFMiBtZXNzYWdlcyBhcmUgc2hvcnQgZW5vdWdoIHRoYXQKCSAqIHRoZSBzeXN0ZW0gY2FuIHdyaXRlIHRoZW0gaW4gMSBhdHRlbXB0IGFuZCB3ZSB3b24ndCBzZWUKCSAqIGEgc2hvcnQtd3JpdGUuCgkgKgoJICogSWYgd2UgZ2V0IGFuIElPIGVycm9yLCBqdXN0IGNsb3NlIHRoZSB0cmFjZSBkc3QuCgkgKi8KCWlmICh3cml0ZShmZCwgYnVmX2xpbmUtPmJ1ZiwgYnVmX2xpbmUtPmxlbikgPj0gMCkKCQlyZXR1cm47CgoJaWYgKHRyMl9kc3Rfd2FudF93YXJuaW5nKCkpCgkJd2FybmluZygidW5hYmxlIHRvIHdyaXRlIHRyYWNlIHRvICclcyc6ICVzIiwKCQkJdHIyX3N5c2Vudl9kaXNwbGF5X25hbWUoZHN0LT5zeXNlbnZfdmFyKSwKCQkJc3RyZXJyb3IoZXJybm8pKTsKCXRyMl9kc3RfdHJhY2VfZGlzYWJsZShkc3QpOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"trace2/tr2_dst.h\"\n#include \"trace2/tr2_sid.h\"\n#include \"trace2/tr2_sysenv.h\"\n\n/*\n * How many attempts we will make at creating an automatically-named trace file.\n */\n#define MAX_AUTO_ATTEMPTS 10\n\nstatic int tr2_dst_want_warning(void)\n{\n\tstatic int tr2env_dst_debug = -1;\n\n\tif (tr2env_dst_debug == -1) {\n\t\tconst char *env_value = tr2_sysenv_get(TR2_SYSENV_DST_DEBUG);\n\t\tif (!env_value || !*env_value)\n\t\t\ttr2env_dst_debug = 0;\n\t\telse\n\t\t\ttr2env_dst_debug = atoi(env_value) > 0;\n\t}\n\n\treturn tr2env_dst_debug;\n}\n\nvoid tr2_dst_trace_disable(struct tr2_dst *dst)\n{\n\tif (dst->need_close)\n\t\tclose(dst->fd);\n\tdst->fd = 0;\n\tdst->initialized = 1;\n\tdst->need_close = 0;\n}\n\nstatic int tr2_dst_try_auto_path(struct tr2_dst *dst, const char *tgt_prefix)\n{\n\tint fd;\n\tconst char *last_slash, *sid = tr2_sid_get();\n\tstruct strbuf path = STRBUF_INIT;\n\tsize_t base_path_len;\n\tunsigned attempt_count;\n\n\tlast_slash = strrchr(sid, '/');\n\tif (last_slash)\n\t\tsid = last_slash + 1;\n\n\tstrbuf_addstr(&path, tgt_prefix);\n\tif (!is_dir_sep(path.buf[path.len - 1]))\n\t\tstrbuf_addch(&path, '/');\n\tstrbuf_addstr(&path, sid);\n\tbase_path_len = path.len;\n\n\tfor (attempt_count = 0; attempt_count < MAX_AUTO_ATTEMPTS; attempt_count++) {\n\t\tif (attempt_count > 0) {\n\t\t\tstrbuf_setlen(&path, base_path_len);\n\t\t\tstrbuf_addf(&path, \".%d\", attempt_count);\n\t\t}\n\n\t\tfd = open(path.buf, O_WRONLY | O_CREAT | O_EXCL, 0666);\n\t\tif (fd != -1)\n\t\t\tbreak;\n\t}\n\n\tif (fd == -1) {\n\t\tif (tr2_dst_want_warning())\n\t\t\twarning(\"trace2: could not open '%.*s' for '%s' tracing: %s\",\n\t\t\t\t(int) base_path_len, path.buf,\n\t\t\t\ttr2_sysenv_display_name(dst->sysenv_var),\n\t\t\t\tstrerror(errno));\n\n\t\ttr2_dst_trace_disable(dst);\n\t\tstrbuf_release(&path);\n\t\treturn 0;\n\t}\n\n\tstrbuf_release(&path);\n\n\tdst->fd = fd;\n\tdst->need_close = 1;\n\tdst->initialized = 1;\n\n\treturn dst->fd;\n}\n\nstatic int tr2_dst_try_path(struct tr2_dst *dst, const char *tgt_value)\n{\n\tint fd = open(tgt_value, O_WRONLY | O_APPEND | O_CREAT, 0666);\n\tif (fd == -1) {\n\t\tif (tr2_dst_want_warning())\n\t\t\twarning(\"trace2: could not open '%s' for '%s' tracing: %s\",\n\t\t\t\ttgt_value,\n\t\t\t\ttr2_sysenv_display_name(dst->sysenv_var),\n\t\t\t\tstrerror(errno));\n\n\t\ttr2_dst_trace_disable(dst);\n\t\treturn 0;\n\t}\n\n\tdst->fd = fd;\n\tdst->need_close = 1;\n\tdst->initialized = 1;\n\n\treturn dst->fd;\n}\n\n#ifndef NO_UNIX_SOCKETS\n#define PREFIX_AF_UNIX \"af_unix:\"\n#define PREFIX_AF_UNIX_STREAM \"af_unix:stream:\"\n#define PREFIX_AF_UNIX_DGRAM \"af_unix:dgram:\"\n\nstatic int tr2_dst_try_uds_connect(const char *path, int sock_type, int *out_fd)\n{\n\tint fd;\n\tstruct sockaddr_un sa;\n\n\tfd = socket(AF_UNIX, sock_type, 0);\n\tif (fd == -1)\n\t\treturn -1;\n\n\tsa.sun_family = AF_UNIX;\n\tstrlcpy(sa.sun_path, path, sizeof(sa.sun_path));\n\n\tif (connect(fd, (struct sockaddr *)&sa, sizeof(sa)) == -1) {\n\t\tint saved_errno = errno;\n\t\tclose(fd);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\n\t*out_fd = fd;\n\treturn 0;\n}\n\n#define TR2_DST_UDS_TRY_STREAM (1 << 0)\n#define TR2_DST_UDS_TRY_DGRAM  (1 << 1)\n\nstatic int tr2_dst_try_unix_domain_socket(struct tr2_dst *dst,\n\t\t\t\t\t  const char *tgt_value)\n{\n\tunsigned int uds_try = 0;\n\tint fd;\n\tconst char *path = NULL;\n\n\t/*\n\t * Allow \"af_unix:[<type>:]<absolute_path>\"\n\t *\n\t * Trace2 always writes complete individual messages (without\n\t * chunking), so we can talk to either DGRAM or STREAM type sockets.\n\t *\n\t * Allow the user to explicitly request the socket type.\n\t *\n\t * If they omit the socket type, try one and then the other.\n\t */\n\n\tif (skip_prefix(tgt_value, PREFIX_AF_UNIX_STREAM, &path))\n\t\tuds_try |= TR2_DST_UDS_TRY_STREAM;\n\n\telse if (skip_prefix(tgt_value, PREFIX_AF_UNIX_DGRAM, &path))\n\t\tuds_try |= TR2_DST_UDS_TRY_DGRAM;\n\n\telse if (skip_prefix(tgt_value, PREFIX_AF_UNIX, &path))\n\t\tuds_try |= TR2_DST_UDS_TRY_STREAM | TR2_DST_UDS_TRY_DGRAM;\n\n\tif (!path || !*path) {\n\t\tif (tr2_dst_want_warning())\n\t\t\twarning(\"trace2: invalid AF_UNIX value '%s' for '%s' tracing\",\n\t\t\t\ttgt_value,\n\t\t\t\ttr2_sysenv_display_name(dst->sysenv_var));\n\n\t\ttr2_dst_trace_disable(dst);\n\t\treturn 0;\n\t}\n\n\tif (!is_absolute_path(path) ||\n\t    strlen(path) >= sizeof(((struct sockaddr_un *)0)->sun_path)) {\n\t\tif (tr2_dst_want_warning())\n\t\t\twarning(\"trace2: invalid AF_UNIX path '%s' for '%s' tracing\",\n\t\t\t\tpath, tr2_sysenv_display_name(dst->sysenv_var));\n\n\t\ttr2_dst_trace_disable(dst);\n\t\treturn 0;\n\t}\n\n\tif (uds_try & TR2_DST_UDS_TRY_STREAM) {\n\t\tif (!tr2_dst_try_uds_connect(path, SOCK_STREAM, &fd))\n\t\t\tgoto connected;\n\t\tif (errno != EPROTOTYPE)\n\t\t\tgoto error;\n\t}\n\tif (uds_try & TR2_DST_UDS_TRY_DGRAM) {\n\t\tif (!tr2_dst_try_uds_connect(path, SOCK_DGRAM, &fd))\n\t\t\tgoto connected;\n\t}\n\nerror:\n\tif (tr2_dst_want_warning())\n\t\twarning(\"trace2: could not connect to socket '%s' for '%s' tracing: %s\",\n\t\t\tpath, tr2_sysenv_display_name(dst->sysenv_var),\n\t\t\tstrerror(errno));\n\n\ttr2_dst_trace_disable(dst);\n\treturn 0;\n\nconnected:\n\tdst->fd = fd;\n\tdst->need_close = 1;\n\tdst->initialized = 1;\n\n\treturn dst->fd;\n}\n#endif\n\nstatic void tr2_dst_malformed_warning(struct tr2_dst *dst,\n\t\t\t\t      const char *tgt_value)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tstrbuf_addf(&buf, \"trace2: unknown value for '%s': '%s'\",\n\t\t    tr2_sysenv_display_name(dst->sysenv_var), tgt_value);\n\twarning(\"%s\", buf.buf);\n\n\tstrbuf_release(&buf);\n}\n\nint tr2_dst_get_trace_fd(struct tr2_dst *dst)\n{\n\tconst char *tgt_value;\n\n\t/* don't open twice */\n\tif (dst->initialized)\n\t\treturn dst->fd;\n\n\tdst->initialized = 1;\n\n\ttgt_value = tr2_sysenv_get(dst->sysenv_var);\n\n\tif (!tgt_value || !strcmp(tgt_value, \"\") || !strcmp(tgt_value, \"0\") ||\n\t    !strcasecmp(tgt_value, \"false\")) {\n\t\tdst->fd = 0;\n\t\treturn dst->fd;\n\t}\n\n\tif (!strcmp(tgt_value, \"1\") || !strcasecmp(tgt_value, \"true\")) {\n\t\tdst->fd = STDERR_FILENO;\n\t\treturn dst->fd;\n\t}\n\n\tif (strlen(tgt_value) == 1 && isdigit(*tgt_value)) {\n\t\tdst->fd = atoi(tgt_value);\n\t\treturn dst->fd;\n\t}\n\n\tif (is_absolute_path(tgt_value)) {\n\t\tif (is_directory(tgt_value))\n\t\t\treturn tr2_dst_try_auto_path(dst, tgt_value);\n\t\telse\n\t\t\treturn tr2_dst_try_path(dst, tgt_value);\n\t}\n\n#ifndef NO_UNIX_SOCKETS\n\tif (starts_with(tgt_value, PREFIX_AF_UNIX))\n\t\treturn tr2_dst_try_unix_domain_socket(dst, tgt_value);\n#endif\n\n\t/* Always warn about malformed values. */\n\ttr2_dst_malformed_warning(dst, tgt_value);\n\ttr2_dst_trace_disable(dst);\n\treturn 0;\n}\n\nint tr2_dst_trace_want(struct tr2_dst *dst)\n{\n\treturn !!tr2_dst_get_trace_fd(dst);\n}\n\nvoid tr2_dst_write_line(struct tr2_dst *dst, struct strbuf *buf_line)\n{\n\tint fd = tr2_dst_get_trace_fd(dst);\n\n\tstrbuf_complete_line(buf_line); /* ensure final NL on buffer */\n\n\t/*\n\t * We do not use write_in_full() because we do not want\n\t * a short-write to try again.  We are using O_APPEND mode\n\t * files and the kernel handles the atomic seek+write. If\n\t * another thread or git process is concurrently writing to\n\t * this fd or file, our remainder-write may not be contiguous\n\t * with our initial write of this message.  And that will\n\t * confuse readers.  So just don't bother.\n\t *\n\t * It is assumed that TRACE2 messages are short enough that\n\t * the system can write them in 1 attempt and we won't see\n\t * a short-write.\n\t *\n\t * If we get an IO error, just close the trace dst.\n\t */\n\tif (write(fd, buf_line->buf, buf_line->len) >= 0)\n\t\treturn;\n\n\tif (tr2_dst_want_warning())\n\t\twarning(\"unable to write trace to '%s': %s\",\n\t\t\ttr2_sysenv_display_name(dst->sysenv_var),\n\t\t\tstrerror(errno));\n\ttr2_dst_trace_disable(dst);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00314763505b0344ba881e76854a1ef3d7808150",
  "sha1_ok": true,
  "size": 7291
}
