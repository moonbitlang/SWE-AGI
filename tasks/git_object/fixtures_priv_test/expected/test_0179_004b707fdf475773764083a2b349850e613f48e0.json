{
  "content": {
    "base64": "I2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAiZ2l0LWN1cmwtY29tcGF0LmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImVudmlyb25tZW50LmgiCiNpbmNsdWRlICJnZXR0ZXh0LmgiCiNpbmNsdWRlICJoZXguaCIKI2luY2x1ZGUgInJlbW90ZS5oIgojaW5jbHVkZSAiY29ubmVjdC5oIgojaW5jbHVkZSAic3RyYnVmLmgiCiNpbmNsdWRlICJ3YWxrZXIuaCIKI2luY2x1ZGUgImh0dHAuaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJwa3QtbGluZS5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgInN0cnZlYy5oIgojaW5jbHVkZSAiY3JlZGVudGlhbC5oIgojaW5jbHVkZSAib2lkLWFycmF5LmgiCiNpbmNsdWRlICJzZW5kLXBhY2suaCIKI2luY2x1ZGUgInNldHVwLmgiCiNpbmNsdWRlICJwcm90b2NvbC5oIgojaW5jbHVkZSAicXVvdGUuaCIKI2luY2x1ZGUgInRyYWNlMi5oIgojaW5jbHVkZSAidHJhbnNwb3J0LmgiCiNpbmNsdWRlICJ1cmwuaCIKI2luY2x1ZGUgIndyaXRlLW9yLWRpZS5oIgoKc3RhdGljIHN0cnVjdCByZW1vdGUgKnJlbW90ZTsKLyogYWx3YXlzIGVuZHMgd2l0aCBhIHRyYWlsaW5nIHNsYXNoICovCnN0YXRpYyBzdHJ1Y3Qgc3RyYnVmIHVybCA9IFNUUkJVRl9JTklUOwoKc3RydWN0IG9wdGlvbnMgewoJaW50IHZlcmJvc2l0eTsKCXVuc2lnbmVkIGxvbmcgZGVwdGg7CgljaGFyICpkZWVwZW5fc2luY2U7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgZGVlcGVuX25vdDsKCXN0cnVjdCBzdHJpbmdfbGlzdCBwdXNoX29wdGlvbnM7CgljaGFyICpmaWx0ZXI7Cgl1bnNpZ25lZCBwcm9ncmVzcyA6IDEsCgkJY2hlY2tfc2VsZl9jb250YWluZWRfYW5kX2Nvbm5lY3RlZCA6IDEsCgkJY2xvbmluZyA6IDEsCgkJdXBkYXRlX3NoYWxsb3cgOiAxLAoJCWZvbGxvd3RhZ3MgOiAxLAoJCWRyeV9ydW4gOiAxLAoJCXRoaW4gOiAxLAoJCS8qIE9uZSBvZiB0aGUgU0VORF9QQUNLX1BVU0hfQ0VSVF8qIGNvbnN0YW50cy4gKi8KCQlwdXNoX2NlcnQgOiAyLAoJCWRlZXBlbl9yZWxhdGl2ZSA6IDEsCgoJCS8qIHNlZSBkb2N1bWVudGF0aW9uIG9mIGNvcnJlc3BvbmRpbmcgZmxhZyBpbiBmZXRjaC1wYWNrLmggKi8KCQlmcm9tX3Byb21pc29yIDogMSwKCgkJcmVmZXRjaCA6IDEsCgkJYXRvbWljIDogMSwKCQlvYmplY3RfZm9ybWF0IDogMSwKCQlmb3JjZV9pZl9pbmNsdWRlcyA6IDE7Cgljb25zdCBzdHJ1Y3QgZ2l0X2hhc2hfYWxnbyAqaGFzaF9hbGdvOwp9OwpzdGF0aWMgc3RydWN0IG9wdGlvbnMgb3B0aW9uczsKc3RhdGljIHN0cnVjdCBzdHJpbmdfbGlzdCBjYXNfb3B0aW9ucyA9IFNUUklOR19MSVNUX0lOSVRfRFVQOwoKc3RhdGljIGludCBzZXRfb3B0aW9uKGNvbnN0IGNoYXIgKm5hbWUsIGNvbnN0IGNoYXIgKnZhbHVlKQp7CglpZiAoIXN0cmNtcChuYW1lLCAidmVyYm9zaXR5IikpIHsKCQljaGFyICplbmQ7CgkJaW50IHYgPSBzdHJ0b2wodmFsdWUsICZlbmQsIDEwKTsKCQlpZiAodmFsdWUgPT0gZW5kIHx8ICplbmQpCgkJCXJldHVybiAtMTsKCQlvcHRpb25zLnZlcmJvc2l0eSA9IHY7CgkJcmV0dXJuIDA7Cgl9CgllbHNlIGlmICghc3RyY21wKG5hbWUsICJwcm9ncmVzcyIpKSB7CgkJaWYgKCFzdHJjbXAodmFsdWUsICJ0cnVlIikpCgkJCW9wdGlvbnMucHJvZ3Jlc3MgPSAxOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJmYWxzZSIpKQoJCQlvcHRpb25zLnByb2dyZXNzID0gMDsKCQllbHNlCgkJCXJldHVybiAtMTsKCQlyZXR1cm4gMDsKCX0KCWVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImRlcHRoIikpIHsKCQljaGFyICplbmQ7CgkJdW5zaWduZWQgbG9uZyB2ID0gc3RydG91bCh2YWx1ZSwgJmVuZCwgMTApOwoJCWlmICh2YWx1ZSA9PSBlbmQgfHwgKmVuZCkKCQkJcmV0dXJuIC0xOwoJCW9wdGlvbnMuZGVwdGggPSB2OwoJCXJldHVybiAwOwoJfQoJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiZGVlcGVuLXNpbmNlIikpIHsKCQlvcHRpb25zLmRlZXBlbl9zaW5jZSA9IHhzdHJkdXAodmFsdWUpOwoJCXJldHVybiAwOwoJfQoJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiZGVlcGVuLW5vdCIpKSB7CgkJc3RyaW5nX2xpc3RfYXBwZW5kKCZvcHRpb25zLmRlZXBlbl9ub3QsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCWVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImRlZXBlbi1yZWxhdGl2ZSIpKSB7CgkJaWYgKCFzdHJjbXAodmFsdWUsICJ0cnVlIikpCgkJCW9wdGlvbnMuZGVlcGVuX3JlbGF0aXZlID0gMTsKCQllbHNlIGlmICghc3RyY21wKHZhbHVlLCAiZmFsc2UiKSkKCQkJb3B0aW9ucy5kZWVwZW5fcmVsYXRpdmUgPSAwOwoJCWVsc2UKCQkJcmV0dXJuIC0xOwoJCXJldHVybiAwOwoJfQoJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiZm9sbG93dGFncyIpKSB7CgkJaWYgKCFzdHJjbXAodmFsdWUsICJ0cnVlIikpCgkJCW9wdGlvbnMuZm9sbG93dGFncyA9IDE7CgkJZWxzZSBpZiAoIXN0cmNtcCh2YWx1ZSwgImZhbHNlIikpCgkJCW9wdGlvbnMuZm9sbG93dGFncyA9IDA7CgkJZWxzZQoJCQlyZXR1cm4gLTE7CgkJcmV0dXJuIDA7Cgl9CgllbHNlIGlmICghc3RyY21wKG5hbWUsICJkcnktcnVuIikpIHsKCQlpZiAoIXN0cmNtcCh2YWx1ZSwgInRydWUiKSkKCQkJb3B0aW9ucy5kcnlfcnVuID0gMTsKCQllbHNlIGlmICghc3RyY21wKHZhbHVlLCAiZmFsc2UiKSkKCQkJb3B0aW9ucy5kcnlfcnVuID0gMDsKCQllbHNlCgkJCXJldHVybiAtMTsKCQlyZXR1cm4gMDsKCX0KCWVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImNoZWNrLWNvbm5lY3Rpdml0eSIpKSB7CgkJaWYgKCFzdHJjbXAodmFsdWUsICJ0cnVlIikpCgkJCW9wdGlvbnMuY2hlY2tfc2VsZl9jb250YWluZWRfYW5kX2Nvbm5lY3RlZCA9IDE7CgkJZWxzZSBpZiAoIXN0cmNtcCh2YWx1ZSwgImZhbHNlIikpCgkJCW9wdGlvbnMuY2hlY2tfc2VsZl9jb250YWluZWRfYW5kX2Nvbm5lY3RlZCA9IDA7CgkJZWxzZQoJCQlyZXR1cm4gLTE7CgkJcmV0dXJuIDA7Cgl9CgllbHNlIGlmICghc3RyY21wKG5hbWUsICJjYXMiKSkgewoJCXN0cnVjdCBzdHJidWYgdmFsID0gU1RSQlVGX0lOSVQ7CgkJc3RyYnVmX2FkZHN0cigmdmFsLCAiLS1mb3JjZS13aXRoLWxlYXNlPSIpOwoJCWlmICgqdmFsdWUgIT0gJyInKQoJCQlzdHJidWZfYWRkc3RyKCZ2YWwsIHZhbHVlKTsKCQllbHNlIGlmICh1bnF1b3RlX2Nfc3R5bGUoJnZhbCwgdmFsdWUsIE5VTEwpKQoJCQlyZXR1cm4gLTE7CgkJc3RyaW5nX2xpc3RfYXBwZW5kKCZjYXNfb3B0aW9ucywgdmFsLmJ1Zik7CgkJc3RyYnVmX3JlbGVhc2UoJnZhbCk7CgkJcmV0dXJuIDA7Cgl9IGVsc2UgaWYgKCFzdHJjbXAobmFtZSwgVFJBTlNfT1BUX0ZPUkNFX0lGX0lOQ0xVREVTKSkgewoJCWlmICghc3RyY21wKHZhbHVlLCAidHJ1ZSIpKQoJCQlvcHRpb25zLmZvcmNlX2lmX2luY2x1ZGVzID0gMTsKCQllbHNlIGlmICghc3RyY21wKHZhbHVlLCAiZmFsc2UiKSkKCQkJb3B0aW9ucy5mb3JjZV9pZl9pbmNsdWRlcyA9IDA7CgkJZWxzZQoJCQlyZXR1cm4gLTE7CgkJcmV0dXJuIDA7Cgl9IGVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImNsb25pbmciKSkgewoJCWlmICghc3RyY21wKHZhbHVlLCAidHJ1ZSIpKQoJCQlvcHRpb25zLmNsb25pbmcgPSAxOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJmYWxzZSIpKQoJCQlvcHRpb25zLmNsb25pbmcgPSAwOwoJCWVsc2UKCQkJcmV0dXJuIC0xOwoJCXJldHVybiAwOwoJfSBlbHNlIGlmICghc3RyY21wKG5hbWUsICJ1cGRhdGUtc2hhbGxvdyIpKSB7CgkJaWYgKCFzdHJjbXAodmFsdWUsICJ0cnVlIikpCgkJCW9wdGlvbnMudXBkYXRlX3NoYWxsb3cgPSAxOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJmYWxzZSIpKQoJCQlvcHRpb25zLnVwZGF0ZV9zaGFsbG93ID0gMDsKCQllbHNlCgkJCXJldHVybiAtMTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAicHVzaGNlcnQiKSkgewoJCWlmICghc3RyY21wKHZhbHVlLCAidHJ1ZSIpKQoJCQlvcHRpb25zLnB1c2hfY2VydCA9IFNFTkRfUEFDS19QVVNIX0NFUlRfQUxXQVlTOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJmYWxzZSIpKQoJCQlvcHRpb25zLnB1c2hfY2VydCA9IFNFTkRfUEFDS19QVVNIX0NFUlRfTkVWRVI7CgkJZWxzZSBpZiAoIXN0cmNtcCh2YWx1ZSwgImlmLWFza2VkIikpCgkJCW9wdGlvbnMucHVzaF9jZXJ0ID0gU0VORF9QQUNLX1BVU0hfQ0VSVF9JRl9BU0tFRDsKCQllbHNlCgkJCXJldHVybiAtMTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiYXRvbWljIikpIHsKCQlpZiAoIXN0cmNtcCh2YWx1ZSwgInRydWUiKSkKCQkJb3B0aW9ucy5hdG9taWMgPSAxOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJmYWxzZSIpKQoJCQlvcHRpb25zLmF0b21pYyA9IDA7CgkJZWxzZQoJCQlyZXR1cm4gLTE7CgkJcmV0dXJuIDA7Cgl9IGVsc2UgaWYgKCFzdHJjbXAobmFtZSwgInB1c2gtb3B0aW9uIikpIHsKCQlpZiAoKnZhbHVlICE9ICciJykKCQkJc3RyaW5nX2xpc3RfYXBwZW5kKCZvcHRpb25zLnB1c2hfb3B0aW9ucywgdmFsdWUpOwoJCWVsc2UgewoJCQlzdHJ1Y3Qgc3RyYnVmIHVucXVvdGVkID0gU1RSQlVGX0lOSVQ7CgkJCWlmICh1bnF1b3RlX2Nfc3R5bGUoJnVucXVvdGVkLCB2YWx1ZSwgTlVMTCkgPCAwKQoJCQkJZGllKF8oImludmFsaWQgcXVvdGluZyBpbiBwdXNoLW9wdGlvbiB2YWx1ZTogJyVzJyIpLCB2YWx1ZSk7CgkJCXN0cmluZ19saXN0X2FwcGVuZF9ub2R1cCgmb3B0aW9ucy5wdXNoX29wdGlvbnMsCgkJCQkJCSBzdHJidWZfZGV0YWNoKCZ1bnF1b3RlZCwgTlVMTCkpOwoJCX0KCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiZmFtaWx5IikpIHsKCQlpZiAoIXN0cmNtcCh2YWx1ZSwgImlwdjQiKSkKCQkJZ2l0X2N1cmxfaXByZXNvbHZlID0gQ1VSTF9JUFJFU09MVkVfVjQ7CgkJZWxzZSBpZiAoIXN0cmNtcCh2YWx1ZSwgImlwdjYiKSkKCQkJZ2l0X2N1cmxfaXByZXNvbHZlID0gQ1VSTF9JUFJFU09MVkVfVjY7CgkJZWxzZSBpZiAoIXN0cmNtcCh2YWx1ZSwgImFsbCIpKQoJCQlnaXRfY3VybF9pcHJlc29sdmUgPSBDVVJMX0lQUkVTT0xWRV9XSEFURVZFUjsKCQllbHNlCgkJCXJldHVybiAtMTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiZnJvbS1wcm9taXNvciIpKSB7CgkJb3B0aW9ucy5mcm9tX3Byb21pc29yID0gMTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAicmVmZXRjaCIpKSB7CgkJb3B0aW9ucy5yZWZldGNoID0gMTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiZmlsdGVyIikpIHsKCQlvcHRpb25zLmZpbHRlciA9IHhzdHJkdXAodmFsdWUpOwoJCXJldHVybiAwOwoJfSBlbHNlIGlmICghc3RyY21wKG5hbWUsICJvYmplY3QtZm9ybWF0IikpIHsKCQlvcHRpb25zLm9iamVjdF9mb3JtYXQgPSAxOwoJCWlmIChzdHJjbXAodmFsdWUsICJ0cnVlIikpCgkJCWRpZShfKCJ1bmtub3duIHZhbHVlIGZvciBvYmplY3QtZm9ybWF0OiAlcyIpLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9IGVsc2UgewoJCXJldHVybiAxIC8qIHVuc3VwcG9ydGVkICovOwoJfQp9CgpzdHJ1Y3QgZGlzY292ZXJ5IHsKCWNoYXIgKnNlcnZpY2U7CgljaGFyICpidWZfYWxsb2M7CgljaGFyICpidWY7CglzaXplX3QgbGVuOwoJc3RydWN0IHJlZiAqcmVmczsKCXN0cnVjdCBvaWRfYXJyYXkgc2hhbGxvdzsKCWVudW0gcHJvdG9jb2xfdmVyc2lvbiB2ZXJzaW9uOwoJdW5zaWduZWQgcHJvdG9fZ2l0IDogMTsKfTsKc3RhdGljIHN0cnVjdCBkaXNjb3ZlcnkgKmxhc3RfZGlzY292ZXJ5OwoKc3RhdGljIHN0cnVjdCByZWYgKnBhcnNlX2dpdF9yZWZzKHN0cnVjdCBkaXNjb3ZlcnkgKmhlYWRzLCBpbnQgZm9yX3B1c2gpCnsKCXN0cnVjdCByZWYgKmxpc3QgPSBOVUxMOwoJc3RydWN0IHBhY2tldF9yZWFkZXIgcmVhZGVyOwoKCXBhY2tldF9yZWFkZXJfaW5pdCgmcmVhZGVyLCAtMSwgaGVhZHMtPmJ1ZiwgaGVhZHMtPmxlbiwKCQkJICAgUEFDS0VUX1JFQURfQ0hPTVBfTkVXTElORSB8CgkJCSAgIFBBQ0tFVF9SRUFEX0dFTlRMRV9PTl9FT0YgfAoJCQkgICBQQUNLRVRfUkVBRF9ESUVfT05fRVJSX1BBQ0tFVCk7CgoJaGVhZHMtPnZlcnNpb24gPSBkaXNjb3Zlcl92ZXJzaW9uKCZyZWFkZXIpOwoJc3dpdGNoIChoZWFkcy0+dmVyc2lvbikgewoJY2FzZSBwcm90b2NvbF92MjoKCQkvKgoJCSAqIERvIG5vdGhpbmcuICBUaGlzIGlzbid0IGEgbGlzdCBvZiByZWZzIGJ1dCByYXRoZXIgYQoJCSAqIGNhcGFiaWxpdHkgYWR2ZXJ0aXNlbWVudC4gIENsaWVudCB3b3VsZCBoYXZlIHJ1bgoJCSAqICdzdGF0ZWxlc3MtY29ubmVjdCcgc28gd2UnbGwgZHVtcCB0aGlzIGNhcGFiaWxpdHkgbGlzdGluZwoJCSAqIGFuZCBsZXQgdGhlbSByZXF1ZXN0IHRoZSByZWZzIHRoZW1zZWx2ZXMuCgkJICovCgkJYnJlYWs7CgljYXNlIHByb3RvY29sX3YxOgoJY2FzZSBwcm90b2NvbF92MDoKCQlnZXRfcmVtb3RlX2hlYWRzKCZyZWFkZXIsICZsaXN0LCBmb3JfcHVzaCA/IFJFRl9OT1JNQUwgOiAwLAoJCQkJIE5VTEwsICZoZWFkcy0+c2hhbGxvdyk7CgkJb3B0aW9ucy5oYXNoX2FsZ28gPSByZWFkZXIuaGFzaF9hbGdvOwoJCWJyZWFrOwoJY2FzZSBwcm90b2NvbF91bmtub3duX3ZlcnNpb246CgkJQlVHKCJ1bmtub3duIHByb3RvY29sIHZlcnNpb24iKTsKCX0KCglyZXR1cm4gbGlzdDsKfQoKLyoKICogVHJ5IHRvIGRldGVjdCB0aGUgaGFzaCBhbGdvcml0aG0gdXNlZCBieSB0aGUgcmVtb3RlIHJlcG9zaXRvcnkgd2hlbiB1c2luZwogKiB0aGUgZHVtYiBIVFRQIHRyYW5zcG9ydC4gQXMgZHVtYiB0cmFuc3BvcnRzIGNhbm5vdCB0ZWxsIHVzIHRoZSBvYmplY3QgaGFzaAogKiBkaXJlY3RseSBoYXZlIHRvIGRlcml2ZSBpdCBmcm9tIHRoZSBhZHZlcnRpc2VkIHJlZiBsZW5ndGhzLgogKi8Kc3RhdGljIGNvbnN0IHN0cnVjdCBnaXRfaGFzaF9hbGdvICpkZXRlY3RfaGFzaF9hbGdvKHN0cnVjdCBkaXNjb3ZlcnkgKmhlYWRzKQp7Cgljb25zdCBjaGFyICpwID0gbWVtY2hyKGhlYWRzLT5idWYsICdcdCcsIGhlYWRzLT5sZW4pOwoJaW50IGFsZ287CgoJLyoKCSAqIEluIGNhc2UgdGhlIHJlbW90ZSBoYXMgbm8gcmVmcyB3ZSBoYXZlIG5vIHdheSB0byByZWxpYWJseSBkZXRlcm1pbmUKCSAqIHRoZSBvYmplY3QgaGFzaCB1c2VkIGJ5IHRoYXQgcmVwb3NpdG9yeS4gSW4gdGhhdCBjYXNlIHdlIHNpbXBseSBmYWxsCgkgKiBiYWNrIHRvIFNIQTEsIHdoaWNoIG1heSBvciBtYXkgbm90IGJlIGNvcnJlY3QuCgkgKi8KCWlmICghcCkKCQlyZXR1cm4gJmhhc2hfYWxnb3NbR0lUX0hBU0hfU0hBMV07CgoJYWxnbyA9IGhhc2hfYWxnb19ieV9sZW5ndGgoKHAgLSBoZWFkcy0+YnVmKSAvIDIpOwoJaWYgKGFsZ28gPT0gR0lUX0hBU0hfVU5LTk9XTikKCQlyZXR1cm4gTlVMTDsKCXJldHVybiAmaGFzaF9hbGdvc1thbGdvXTsKfQoKc3RhdGljIHN0cnVjdCByZWYgKnBhcnNlX2luZm9fcmVmcyhzdHJ1Y3QgZGlzY292ZXJ5ICpoZWFkcykKewoJY2hhciAqZGF0YSwgKnN0YXJ0LCAqbWlkOwoJY2hhciAqcmVmX25hbWU7CglpbnQgaSA9IDA7CgoJc3RydWN0IHJlZiAqcmVmcyA9IE5VTEw7CglzdHJ1Y3QgcmVmICpyZWYgPSBOVUxMOwoJc3RydWN0IHJlZiAqbGFzdF9yZWYgPSBOVUxMOwoKCW9wdGlvbnMuaGFzaF9hbGdvID0gZGV0ZWN0X2hhc2hfYWxnbyhoZWFkcyk7CglpZiAoIW9wdGlvbnMuaGFzaF9hbGdvKQoJCWRpZSgiJXNpbmZvL3JlZnMgbm90IHZhbGlkOiBjb3VsZCBub3QgZGV0ZXJtaW5lIGhhc2ggYWxnb3JpdGhtOyAiCgkJICAgICJpcyB0aGlzIGEgZ2l0IHJlcG9zaXRvcnk/IiwKCQkgICAgdHJhbnNwb3J0X2Fub255bWl6ZV91cmwodXJsLmJ1ZikpOwoKCS8qCgkgKiBTZXQgdGhlIHJlcG9zaXRvcnkncyBoYXNoIGFsZ28gdG8gd2hhdGV2ZXIgd2UgaGF2ZSBqdXN0IGRldGVjdGVkLgoJICogVGhpcyBlbnN1cmVzIHRoYXQgd2UgY2FuIGNvcnJlY3RseSBwYXJzZSB0aGUgcmVtb3RlIHJlZmVyZW5jZXMuCgkgKi8KCXJlcG9fc2V0X2hhc2hfYWxnbyh0aGVfcmVwb3NpdG9yeSwgaGFzaF9hbGdvX2J5X3B0cihvcHRpb25zLmhhc2hfYWxnbykpOwoKCWRhdGEgPSBoZWFkcy0+YnVmOwoJc3RhcnQgPSBOVUxMOwoJbWlkID0gZGF0YTsKCXdoaWxlIChpIDwgaGVhZHMtPmxlbikgewoJCWlmICghc3RhcnQpIHsKCQkJc3RhcnQgPSAmZGF0YVtpXTsKCQl9CgkJaWYgKGRhdGFbaV0gPT0gJ1x0JykKCQkJbWlkID0gJmRhdGFbaV07CgkJaWYgKGRhdGFbaV0gPT0gJ1xuJykgewoJCQlpZiAobWlkIC0gc3RhcnQgIT0gb3B0aW9ucy5oYXNoX2FsZ28tPmhleHN6KQoJCQkJZGllKF8oIiVzaW5mby9yZWZzIG5vdCB2YWxpZDogaXMgdGhpcyBhIGdpdCByZXBvc2l0b3J5PyIpLAoJCQkJICAgIHRyYW5zcG9ydF9hbm9ueW1pemVfdXJsKHVybC5idWYpKTsKCQkJZGF0YVtpXSA9IDA7CgkJCXJlZl9uYW1lID0gbWlkICsgMTsKCQkJcmVmID0gYWxsb2NfcmVmKHJlZl9uYW1lKTsKCQkJZ2V0X29pZF9oZXhfYWxnb3Aoc3RhcnQsICZyZWYtPm9sZF9vaWQsIG9wdGlvbnMuaGFzaF9hbGdvKTsKCQkJaWYgKCFyZWZzKQoJCQkJcmVmcyA9IHJlZjsKCQkJaWYgKGxhc3RfcmVmKQoJCQkJbGFzdF9yZWYtPm5leHQgPSByZWY7CgkJCWxhc3RfcmVmID0gcmVmOwoJCQlzdGFydCA9IE5VTEw7CgkJfQoJCWkrKzsKCX0KCglyZWYgPSBhbGxvY19yZWYoIkhFQUQiKTsKCWlmICghaHR0cF9mZXRjaF9yZWYodXJsLmJ1ZiwgcmVmKSAmJgoJICAgICFyZXNvbHZlX3JlbW90ZV9zeW1yZWYocmVmLCByZWZzKSkgewoJCXJlZi0+bmV4dCA9IHJlZnM7CgkJcmVmcyA9IHJlZjsKCX0gZWxzZSB7CgkJZnJlZShyZWYpOwoJfQoKCXJldHVybiByZWZzOwp9CgpzdGF0aWMgdm9pZCBmcmVlX2Rpc2NvdmVyeShzdHJ1Y3QgZGlzY292ZXJ5ICpkKQp7CglpZiAoZCkgewoJCWlmIChkID09IGxhc3RfZGlzY292ZXJ5KQoJCQlsYXN0X2Rpc2NvdmVyeSA9IE5VTEw7CgkJZnJlZShkLT5zaGFsbG93Lm9pZCk7CgkJZnJlZShkLT5idWZfYWxsb2MpOwoJCWZyZWVfcmVmcyhkLT5yZWZzKTsKCQlmcmVlKGQtPnNlcnZpY2UpOwoJCWZyZWUoZCk7Cgl9Cn0KCnN0YXRpYyBpbnQgc2hvd19odHRwX21lc3NhZ2Uoc3RydWN0IHN0cmJ1ZiAqdHlwZSwgc3RydWN0IHN0cmJ1ZiAqY2hhcnNldCwKCQkJICAgICBzdHJ1Y3Qgc3RyYnVmICptc2cpCnsKCWNvbnN0IGNoYXIgKnAsICplb2w7CgoJLyoKCSAqIFdlIG9ubHkgc2hvdyB0ZXh0L3BsYWluIHBhcnRzLCBhcyBvdGhlciB0eXBlcyBhcmUgbGlrZWx5CgkgKiB0byBiZSB1Z2x5IHRvIGxvb2sgYXQgb24gdGhlIHVzZXIncyB0ZXJtaW5hbC4KCSAqLwoJaWYgKHN0cmNtcCh0eXBlLT5idWYsICJ0ZXh0L3BsYWluIikpCgkJcmV0dXJuIC0xOwoJaWYgKGNoYXJzZXQtPmxlbikKCQlzdHJidWZfcmVlbmNvZGUobXNnLCBjaGFyc2V0LT5idWYsIGdldF9sb2dfb3V0cHV0X2VuY29kaW5nKCkpOwoKCXN0cmJ1Zl90cmltKG1zZyk7CglpZiAoIW1zZy0+bGVuKQoJCXJldHVybiAtMTsKCglwID0gbXNnLT5idWY7CglkbyB7CgkJZW9sID0gc3RyY2hybnVsKHAsICdcbicpOwoJCWZwcmludGYoc3RkZXJyLCAicmVtb3RlOiAlLipzXG4iLCAoaW50KShlb2wgLSBwKSwgcCk7CgkJcCA9IGVvbCArIDE7Cgl9IHdoaWxlKCplb2wpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZ2V0X3Byb3RvY29sX2h0dHBfaGVhZGVyKGVudW0gcHJvdG9jb2xfdmVyc2lvbiB2ZXJzaW9uLAoJCQkJICAgIHN0cnVjdCBzdHJidWYgKmhlYWRlcikKewoJaWYgKHZlcnNpb24gPiAwKSB7CgkJc3RyYnVmX2FkZGYoaGVhZGVyLCBHSVRfUFJPVE9DT0xfSEVBREVSICI6IHZlcnNpb249JWQiLAoJCQkgICAgdmVyc2lvbik7CgoJCXJldHVybiAxOwoJfQoKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBjaGVja19zbWFydF9odHRwKHN0cnVjdCBkaXNjb3ZlcnkgKmQsIGNvbnN0IGNoYXIgKnNlcnZpY2UsCgkJCSAgICAgc3RydWN0IHN0cmJ1ZiAqdHlwZSkKewoJY29uc3QgY2hhciAqcDsKCXN0cnVjdCBwYWNrZXRfcmVhZGVyIHJlYWRlcjsKCgkvKgoJICogSWYgd2UgZG9uJ3Qgc2VlIHgtJHNlcnZpY2UtYWR2ZXJ0aXNlbWVudCwgdGhlbiBpdCdzIG5vdCBzbWFydC1odHRwLgoJICogQnV0IG9uY2Ugd2UgZG8sIHdlIGNvbW1pdCB0byBpdCBhbmQgYXNzdW1lIGFueSBvdGhlciBwcm90b2NvbAoJICogdmlvbGF0aW9ucyBhcmUgaGFyZCBlcnJvcnMuCgkgKi8KCWlmICghc2tpcF9wcmVmaXgodHlwZS0+YnVmLCAiYXBwbGljYXRpb24veC0iLCAmcCkgfHwKCSAgICAhc2tpcF9wcmVmaXgocCwgc2VydmljZSwgJnApIHx8CgkgICAgc3RyY21wKHAsICItYWR2ZXJ0aXNlbWVudCIpKQoJCXJldHVybjsKCglwYWNrZXRfcmVhZGVyX2luaXQoJnJlYWRlciwgLTEsIGQtPmJ1ZiwgZC0+bGVuLAoJCQkgICBQQUNLRVRfUkVBRF9DSE9NUF9ORVdMSU5FIHwKCQkJICAgUEFDS0VUX1JFQURfRElFX09OX0VSUl9QQUNLRVQpOwoJaWYgKHBhY2tldF9yZWFkZXJfcmVhZCgmcmVhZGVyKSAhPSBQQUNLRVRfUkVBRF9OT1JNQUwpCgkJZGllKF8oImludmFsaWQgc2VydmVyIHJlc3BvbnNlOyBleHBlY3RlZCBzZXJ2aWNlLCBnb3QgZmx1c2ggcGFja2V0IikpOwoKCWlmIChza2lwX3ByZWZpeChyZWFkZXIubGluZSwgIiMgc2VydmljZT0iLCAmcCkgJiYgIXN0cmNtcChwLCBzZXJ2aWNlKSkgewoJCS8qCgkJICogVGhlIGhlYWRlciBjYW4gaW5jbHVkZSBhZGRpdGlvbmFsIG1ldGFkYXRhIGxpbmVzLCB1cAoJCSAqIHVudGlsIGEgcGFja2V0IGZsdXNoIG1hcmtlci4gIElnbm9yZSB0aGVzZSBub3csIGJ1dAoJCSAqIGluIHRoZSBmdXR1cmUgd2UgbWlnaHQgc3RhcnQgdG8gc2NhbiB0aGVtLgoJCSAqLwoJCWZvciAoOzspIHsKCQkJcGFja2V0X3JlYWRlcl9yZWFkKCZyZWFkZXIpOwoJCQlpZiAocmVhZGVyLnBrdGxlbiA8PSAwKSB7CgkJCQlicmVhazsKCQkJfQoJCX0KCgkJLyoKCQkgKiB2MCBzbWFydCBodHRwOyBjYWxsZXJzIGV4cGVjdCB1cyB0byBzb2FrIHVwIHRoZQoJCSAqIHNlcnZpY2UgYW5kIGhlYWRlciBwYWNrZXRzCgkJICovCgkJZC0+YnVmID0gcmVhZGVyLnNyY19idWZmZXI7CgkJZC0+bGVuID0gcmVhZGVyLnNyY19sZW47CgkJZC0+cHJvdG9fZ2l0ID0gMTsKCgl9IGVsc2UgaWYgKCFzdHJjbXAocmVhZGVyLmxpbmUsICJ2ZXJzaW9uIDIiKSkgewoJCS8qCgkJICogdjIgc21hcnQgaHR0cDsgZG8gbm90IGNvbnN1bWUgdmVyc2lvbiBwYWNrZXQsIHdoaWNoIHdpbGwKCQkgKiBiZSBoYW5kbGVkIGVsc2V3aGVyZS4KCQkgKi8KCQlkLT5wcm90b19naXQgPSAxOwoKCX0gZWxzZSB7CgkJZGllKF8oImludmFsaWQgc2VydmVyIHJlc3BvbnNlOyBnb3QgJyVzJyIpLCByZWFkZXIubGluZSk7Cgl9Cn0KCnN0YXRpYyBzdHJ1Y3QgZGlzY292ZXJ5ICpkaXNjb3Zlcl9yZWZzKGNvbnN0IGNoYXIgKnNlcnZpY2UsIGludCBmb3JfcHVzaCkKewoJc3RydWN0IHN0cmJ1ZiB0eXBlID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGNoYXJzZXQgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgYnVmZmVyID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIHJlZnNfdXJsID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGVmZmVjdGl2ZV91cmwgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgcHJvdG9jb2xfaGVhZGVyID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgZXh0cmFfaGVhZGVycyA9IFNUUklOR19MSVNUX0lOSVRfRFVQOwoJc3RydWN0IGRpc2NvdmVyeSAqbGFzdCA9IGxhc3RfZGlzY292ZXJ5OwoJaW50IGh0dHBfcmV0LCBtYXliZV9zbWFydCA9IDA7CglzdHJ1Y3QgaHR0cF9nZXRfb3B0aW9ucyBodHRwX29wdGlvbnM7CgllbnVtIHByb3RvY29sX3ZlcnNpb24gdmVyc2lvbiA9IGdldF9wcm90b2NvbF92ZXJzaW9uX2NvbmZpZygpOwoKCWlmIChsYXN0ICYmICFzdHJjbXAoc2VydmljZSwgbGFzdC0+c2VydmljZSkpCgkJcmV0dXJuIGxhc3Q7CglmcmVlX2Rpc2NvdmVyeShsYXN0KTsKCglzdHJidWZfYWRkZigmcmVmc191cmwsICIlc2luZm8vcmVmcyIsIHVybC5idWYpOwoJaWYgKChzdGFydHNfd2l0aCh1cmwuYnVmLCAiaHR0cDovLyIpIHx8IHN0YXJ0c193aXRoKHVybC5idWYsICJodHRwczovLyIpKSAmJgoJICAgICBnaXRfZW52X2Jvb2woIkdJVF9TTUFSVF9IVFRQIiwgMSkpIHsKCQltYXliZV9zbWFydCA9IDE7CgkJaWYgKCFzdHJjaHIodXJsLmJ1ZiwgJz8nKSkKCQkJc3RyYnVmX2FkZGNoKCZyZWZzX3VybCwgJz8nKTsKCQllbHNlCgkJCXN0cmJ1Zl9hZGRjaCgmcmVmc191cmwsICcmJyk7CgkJc3RyYnVmX2FkZGYoJnJlZnNfdXJsLCAic2VydmljZT0lcyIsIHNlcnZpY2UpOwoJfQoKCS8qCgkgKiBORUVEU1dPUks6IElmIHdlIGFyZSB0cnlpbmcgdG8gdXNlIHByb3RvY29sIHYyIGFuZCB3ZSBhcmUgcGxhbm5pbmcKCSAqIHRvIHBlcmZvcm0gYW55IG9wZXJhdGlvbiB0aGF0IGRvZXNuJ3QgaW52b2x2ZSB1cGxvYWQtcGFjayAoaS5lLiwgYQoJICogZmV0Y2gsIGxzLXJlbW90ZSwgZXRjKSwgdGhlbiBmYWxsYmFjayB0byB2MCBzaW5jZSB3ZSBkb24ndCBrbm93IGhvdwoJICogdG8gZG8gYW55dGhpbmcgZWxzZSAobGlrZSBwdXNoIG9yIHJlbW90ZSBhcmNoaXZlKSB2aWEgdjIuCgkgKi8KCWlmICh2ZXJzaW9uID09IHByb3RvY29sX3YyICYmIHN0cmNtcCgiZ2l0LXVwbG9hZC1wYWNrIiwgc2VydmljZSkpCgkJdmVyc2lvbiA9IHByb3RvY29sX3YwOwoKCS8qIEFkZCB0aGUgZXh0cmEgR2l0LVByb3RvY29sIGhlYWRlciAqLwoJaWYgKGdldF9wcm90b2NvbF9odHRwX2hlYWRlcih2ZXJzaW9uLCAmcHJvdG9jb2xfaGVhZGVyKSkKCQlzdHJpbmdfbGlzdF9hcHBlbmQoJmV4dHJhX2hlYWRlcnMsIHByb3RvY29sX2hlYWRlci5idWYpOwoKCW1lbXNldCgmaHR0cF9vcHRpb25zLCAwLCBzaXplb2YoaHR0cF9vcHRpb25zKSk7CglodHRwX29wdGlvbnMuY29udGVudF90eXBlID0gJnR5cGU7CglodHRwX29wdGlvbnMuY2hhcnNldCA9ICZjaGFyc2V0OwoJaHR0cF9vcHRpb25zLmVmZmVjdGl2ZV91cmwgPSAmZWZmZWN0aXZlX3VybDsKCWh0dHBfb3B0aW9ucy5iYXNlX3VybCA9ICZ1cmw7CglodHRwX29wdGlvbnMuZXh0cmFfaGVhZGVycyA9ICZleHRyYV9oZWFkZXJzOwoJaHR0cF9vcHRpb25zLmluaXRpYWxfcmVxdWVzdCA9IDE7CglodHRwX29wdGlvbnMubm9fY2FjaGUgPSAxOwoKCWh0dHBfcmV0ID0gaHR0cF9nZXRfc3RyYnVmKHJlZnNfdXJsLmJ1ZiwgJmJ1ZmZlciwgJmh0dHBfb3B0aW9ucyk7Cglzd2l0Y2ggKGh0dHBfcmV0KSB7CgljYXNlIEhUVFBfT0s6CgkJYnJlYWs7CgljYXNlIEhUVFBfTUlTU0lOR19UQVJHRVQ6CgkJc2hvd19odHRwX21lc3NhZ2UoJnR5cGUsICZjaGFyc2V0LCAmYnVmZmVyKTsKCQlkaWUoXygicmVwb3NpdG9yeSAnJXMnIG5vdCBmb3VuZCIpLAoJCSAgICB0cmFuc3BvcnRfYW5vbnltaXplX3VybCh1cmwuYnVmKSk7CgljYXNlIEhUVFBfTk9BVVRIOgoJCXNob3dfaHR0cF9tZXNzYWdlKCZ0eXBlLCAmY2hhcnNldCwgJmJ1ZmZlcik7CgkJZGllKF8oIkF1dGhlbnRpY2F0aW9uIGZhaWxlZCBmb3IgJyVzJyIpLAoJCSAgICB0cmFuc3BvcnRfYW5vbnltaXplX3VybCh1cmwuYnVmKSk7CgljYXNlIEhUVFBfTk9NQVRDSFBVQkxJQ0tFWToKCQlzaG93X2h0dHBfbWVzc2FnZSgmdHlwZSwgJmNoYXJzZXQsICZidWZmZXIpOwoJCWRpZShfKCJ1bmFibGUgdG8gYWNjZXNzICclcycgd2l0aCBodHRwLnBpbm5lZFB1YmtleSBjb25maWd1cmF0aW9uOiAlcyIpLAoJCSAgICB0cmFuc3BvcnRfYW5vbnltaXplX3VybCh1cmwuYnVmKSwgY3VybF9lcnJvcnN0cik7CglkZWZhdWx0OgoJCXNob3dfaHR0cF9tZXNzYWdlKCZ0eXBlLCAmY2hhcnNldCwgJmJ1ZmZlcik7CgkJZGllKF8oInVuYWJsZSB0byBhY2Nlc3MgJyVzJzogJXMiKSwKCQkgICAgdHJhbnNwb3J0X2Fub255bWl6ZV91cmwodXJsLmJ1ZiksIGN1cmxfZXJyb3JzdHIpOwoJfQoKCWlmIChvcHRpb25zLnZlcmJvc2l0eSAmJiAhc3RhcnRzX3dpdGgocmVmc191cmwuYnVmLCB1cmwuYnVmKSkgewoJCWNoYXIgKnUgPSB0cmFuc3BvcnRfYW5vbnltaXplX3VybCh1cmwuYnVmKTsKCQl3YXJuaW5nKF8oInJlZGlyZWN0aW5nIHRvICVzIiksIHUpOwoJCWZyZWUodSk7Cgl9CgoJbGFzdD0geGNhbGxvYygxLCBzaXplb2YoKmxhc3RfZGlzY292ZXJ5KSk7CglsYXN0LT5zZXJ2aWNlID0geHN0cmR1cChzZXJ2aWNlKTsKCWxhc3QtPmJ1Zl9hbGxvYyA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZmZlciwgJmxhc3QtPmxlbik7CglsYXN0LT5idWYgPSBsYXN0LT5idWZfYWxsb2M7CgoJaWYgKG1heWJlX3NtYXJ0KQoJCWNoZWNrX3NtYXJ0X2h0dHAobGFzdCwgc2VydmljZSwgJnR5cGUpOwoKCWlmIChsYXN0LT5wcm90b19naXQpCgkJbGFzdC0+cmVmcyA9IHBhcnNlX2dpdF9yZWZzKGxhc3QsIGZvcl9wdXNoKTsKCWVsc2UKCQlsYXN0LT5yZWZzID0gcGFyc2VfaW5mb19yZWZzKGxhc3QpOwoKCXN0cmJ1Zl9yZWxlYXNlKCZyZWZzX3VybCk7CglzdHJidWZfcmVsZWFzZSgmdHlwZSk7CglzdHJidWZfcmVsZWFzZSgmY2hhcnNldCk7CglzdHJidWZfcmVsZWFzZSgmZWZmZWN0aXZlX3VybCk7CglzdHJidWZfcmVsZWFzZSgmYnVmZmVyKTsKCXN0cmJ1Zl9yZWxlYXNlKCZwcm90b2NvbF9oZWFkZXIpOwoJc3RyaW5nX2xpc3RfY2xlYXIoJmV4dHJhX2hlYWRlcnMsIDApOwoJbGFzdF9kaXNjb3ZlcnkgPSBsYXN0OwoJcmV0dXJuIGxhc3Q7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVmICpnZXRfcmVmcyhpbnQgZm9yX3B1c2gpCnsKCXN0cnVjdCBkaXNjb3ZlcnkgKmhlYWRzOwoKCWlmIChmb3JfcHVzaCkKCQloZWFkcyA9IGRpc2NvdmVyX3JlZnMoImdpdC1yZWNlaXZlLXBhY2siLCBmb3JfcHVzaCk7CgllbHNlCgkJaGVhZHMgPSBkaXNjb3Zlcl9yZWZzKCJnaXQtdXBsb2FkLXBhY2siLCBmb3JfcHVzaCk7CgoJcmV0dXJuIGhlYWRzLT5yZWZzOwp9CgpzdGF0aWMgdm9pZCBvdXRwdXRfcmVmcyhzdHJ1Y3QgcmVmICpyZWZzKQp7CglzdHJ1Y3QgcmVmICpwb3NuOwoJaWYgKG9wdGlvbnMub2JqZWN0X2Zvcm1hdCAmJiBvcHRpb25zLmhhc2hfYWxnbykgewoJCXByaW50ZigiOm9iamVjdC1mb3JtYXQgJXNcbiIsIG9wdGlvbnMuaGFzaF9hbGdvLT5uYW1lKTsKCQlyZXBvX3NldF9oYXNoX2FsZ28odGhlX3JlcG9zaXRvcnksCgkJCQloYXNoX2FsZ29fYnlfcHRyKG9wdGlvbnMuaGFzaF9hbGdvKSk7Cgl9Cglmb3IgKHBvc24gPSByZWZzOyBwb3NuOyBwb3NuID0gcG9zbi0+bmV4dCkgewoJCWlmIChwb3NuLT5zeW1yZWYpCgkJCXByaW50ZigiQCVzICVzXG4iLCBwb3NuLT5zeW1yZWYsIHBvc24tPm5hbWUpOwoJCWVsc2UKCQkJcHJpbnRmKCIlcyAlc1xuIiwgaGFzaF90b19oZXhfYWxnb3AocG9zbi0+b2xkX29pZC5oYXNoLAoJCQkJCQkJICAgIG9wdGlvbnMuaGFzaF9hbGdvKSwKCQkJCQkgIHBvc24tPm5hbWUpOwoJfQoJcHJpbnRmKCJcbiIpOwoJZmZsdXNoKHN0ZG91dCk7Cn0KCnN0cnVjdCBycGNfc3RhdGUgewoJY29uc3QgY2hhciAqc2VydmljZV9uYW1lOwoJY2hhciAqc2VydmljZV91cmw7CgljaGFyICpoZHJfY29udGVudF90eXBlOwoJY2hhciAqaGRyX2FjY2VwdDsKCWNoYXIgKmhkcl9hY2NlcHRfbGFuZ3VhZ2U7CgljaGFyICpwcm90b2NvbF9oZWFkZXI7CgljaGFyICpidWY7CglzaXplX3QgYWxsb2M7CglzaXplX3QgbGVuOwoJc2l6ZV90IHBvczsKCWludCBpbjsKCWludCBvdXQ7CglpbnQgYW55X3dyaXR0ZW47Cgl1bnNpZ25lZCBnemlwX3JlcXVlc3QgOiAxOwoJdW5zaWduZWQgaW5pdGlhbF9idWZmZXIgOiAxOwoKCS8qCgkgKiBXaGVuZXZlciBhIHBrdC1saW5lIGlzIHJlYWQgaW50byBidWYsIGFwcGVuZCB0aGUgNCBjaGFyYWN0ZXJzCgkgKiBkZW5vdGluZyBpdHMgbGVuZ3RoIGJlZm9yZSBhcHBlbmRpbmcgdGhlIHBheWxvYWQuCgkgKi8KCXVuc2lnbmVkIHdyaXRlX2xpbmVfbGVuZ3RocyA6IDE7CgoJLyoKCSAqIFVzZWQgYnkgcnBjX291dDsgaW5pdGlhbGl6ZSB0byAwLiBUaGlzIGlzIHRydWUgaWYgYSBmbHVzaCBoYXMgYmVlbgoJICogcmVhZCwgYnV0IHRoZSBjb3JyZXNwb25kaW5nIGxpbmUgbGVuZ3RoIChpZiB3cml0ZV9saW5lX2xlbmd0aHMgaXMKCSAqIHRydWUpIGFuZCBFT0YgaGF2ZSBub3QgYmVlbiBzZW50IHRvIGxpYmN1cmwuIFNpbmNlIGVhY2ggZmx1c2ggbWFya3MKCSAqIHRoZSBlbmQgb2YgYSByZXF1ZXN0LCBlYWNoIGZsdXNoIG11c3QgYmUgY29tcGxldGVseSBzZW50IGJlZm9yZSBhbnkKCSAqIGZ1cnRoZXIgcmVhZGluZyBvY2N1cnMuCgkgKi8KCXVuc2lnbmVkIGZsdXNoX3JlYWRfYnV0X25vdF9zZW50IDogMTsKfTsKCiNkZWZpbmUgUlBDX1NUQVRFX0lOSVQgeyAwIH0KCi8qCiAqIEFwcGVuZHMgdGhlIHJlc3VsdCBvZiByZWFkaW5nIGZyb20gcnBjLT5vdXQgdG8gdGhlIHN0cmluZyByZXByZXNlbnRlZCBieQogKiBycGMtPmJ1ZiBhbmQgcnBjLT5sZW4gaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlLiBSZXR1cm5zIDEgaWYgdGhlcmUgd2FzCiAqIGVub3VnaCBzcGFjZSwgMCBvdGhlcndpc2UuCiAqCiAqIElmIHJwYy0+d3JpdGVfbGluZV9sZW5ndGhzIGlzIHRydWUsIGFwcGVuZHMgdGhlIGxpbmUgbGVuZ3RoIGFzIGEgNC1ieXRlCiAqIGhleGFkZWNpbWFsIHN0cmluZyBiZWZvcmUgYXBwZW5kaW5nIHRoZSByZXN1bHQgZGVzY3JpYmVkIGFib3ZlLgogKgogKiBXcml0ZXMgdGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyBhcHBlbmRlZCBpbnRvIGFwcGVuZGVkLgogKi8Kc3RhdGljIGludCBycGNfcmVhZF9mcm9tX291dChzdHJ1Y3QgcnBjX3N0YXRlICpycGMsIGludCBvcHRpb25zLAoJCQkgICAgIHNpemVfdCAqYXBwZW5kZWQsCgkJCSAgICAgZW51bSBwYWNrZXRfcmVhZF9zdGF0dXMgKnN0YXR1cykgewoJc2l6ZV90IGxlZnQ7CgljaGFyICpidWY7CglpbnQgcGt0bGVuX3JhdzsKCglpZiAocnBjLT53cml0ZV9saW5lX2xlbmd0aHMpIHsKCQlsZWZ0ID0gcnBjLT5hbGxvYyAtIHJwYy0+bGVuIC0gNDsKCQlidWYgPSBycGMtPmJ1ZiArIHJwYy0+bGVuICsgNDsKCX0gZWxzZSB7CgkJbGVmdCA9IHJwYy0+YWxsb2MgLSBycGMtPmxlbjsKCQlidWYgPSBycGMtPmJ1ZiArIHJwYy0+bGVuOwoJfQoKCWlmIChsZWZ0IDwgTEFSR0VfUEFDS0VUX01BWCkKCQlyZXR1cm4gMDsKCgkqc3RhdHVzID0gcGFja2V0X3JlYWRfd2l0aF9zdGF0dXMocnBjLT5vdXQsIE5VTEwsIE5VTEwsIGJ1ZiwKCQkJbGVmdCwgJnBrdGxlbl9yYXcsIG9wdGlvbnMpOwoJaWYgKCpzdGF0dXMgIT0gUEFDS0VUX1JFQURfRU9GKSB7CgkJKmFwcGVuZGVkID0gcGt0bGVuX3JhdyArIChycGMtPndyaXRlX2xpbmVfbGVuZ3RocyA/IDQgOiAwKTsKCQlycGMtPmxlbiArPSAqYXBwZW5kZWQ7Cgl9CgoJaWYgKHJwYy0+d3JpdGVfbGluZV9sZW5ndGhzKSB7CgkJc3dpdGNoICgqc3RhdHVzKSB7CgkJY2FzZSBQQUNLRVRfUkVBRF9FT0Y6CgkJCWlmICghKG9wdGlvbnMgJiBQQUNLRVRfUkVBRF9HRU5UTEVfT05fRU9GKSkKCQkJCWRpZShfKCJzaG91bGRuJ3QgaGF2ZSBFT0Ygd2hlbiBub3QgZ2VudGxlIG9uIEVPRiIpKTsKCQkJYnJlYWs7CgkJY2FzZSBQQUNLRVRfUkVBRF9OT1JNQUw6CgkJCXNldF9wYWNrZXRfaGVhZGVyKGJ1ZiAtIDQsICphcHBlbmRlZCk7CgkJCWJyZWFrOwoJCWNhc2UgUEFDS0VUX1JFQURfREVMSU06CgkJCW1lbWNweShidWYgLSA0LCAiMDAwMSIsIDQpOwoJCQlicmVhazsKCQljYXNlIFBBQ0tFVF9SRUFEX0ZMVVNIOgoJCQltZW1jcHkoYnVmIC0gNCwgIjAwMDAiLCA0KTsKCQkJYnJlYWs7CgkJY2FzZSBQQUNLRVRfUkVBRF9SRVNQT05TRV9FTkQ6CgkJCWRpZShfKCJyZW1vdGUgc2VydmVyIHNlbnQgdW5leHBlY3RlZCByZXNwb25zZSBlbmQgcGFja2V0IikpOwoJCX0KCX0KCglyZXR1cm4gMTsKfQoKc3RhdGljIHNpemVfdCBycGNfb3V0KHZvaWQgKnB0ciwgc2l6ZV90IGVsdHNpemUsCgkJc2l6ZV90IG5tZW1iLCB2b2lkICpidWZmZXJfKQp7CglzaXplX3QgbWF4ID0gZWx0c2l6ZSAqIG5tZW1iOwoJc3RydWN0IHJwY19zdGF0ZSAqcnBjID0gYnVmZmVyXzsKCXNpemVfdCBhdmFpbCA9IHJwYy0+bGVuIC0gcnBjLT5wb3M7CgllbnVtIHBhY2tldF9yZWFkX3N0YXR1cyBzdGF0dXM7CgoJaWYgKCFhdmFpbCkgewoJCXJwYy0+aW5pdGlhbF9idWZmZXIgPSAwOwoJCXJwYy0+bGVuID0gMDsKCQlycGMtPnBvcyA9IDA7CgkJaWYgKCFycGMtPmZsdXNoX3JlYWRfYnV0X25vdF9zZW50KSB7CgkJCWlmICghcnBjX3JlYWRfZnJvbV9vdXQocnBjLCAwLCAmYXZhaWwsICZzdGF0dXMpKQoJCQkJQlVHKCJUaGUgZW50aXJlIHJwYy0+YnVmIHNob3VsZCBiZSBsYXJnZXIgdGhhbiBMQVJHRV9QQUNLRVRfTUFYIik7CgkJCWlmIChzdGF0dXMgPT0gUEFDS0VUX1JFQURfRkxVU0gpCgkJCQlycGMtPmZsdXNoX3JlYWRfYnV0X25vdF9zZW50ID0gMTsKCQl9CgkJLyoKCQkgKiBJZiBmbHVzaF9yZWFkX2J1dF9ub3Rfc2VudCBpcyB0cnVlLCB3ZSBoYXZlIGFscmVhZHkgcmVhZCBvbmUKCQkgKiBmdWxsIHJlcXVlc3QgYnV0IGhhdmUgbm90IGZ1bGx5IHNlbnQgaXQgKyBFT0YsIHdoaWNoIGlzIHdoeQoJCSAqIHdlIG5lZWQgdG8gcmVmcmFpbiBmcm9tIHJlYWRpbmcuCgkJICovCgl9CglpZiAocnBjLT5mbHVzaF9yZWFkX2J1dF9ub3Rfc2VudCkgewoJCWlmICghYXZhaWwpIHsKCQkJLyoKCQkJICogVGhlIGxpbmUgbGVuZ3RoIGVpdGhlciBkb2VzIG5vdCBuZWVkIHRvIGJlIHNlbnQgYXQKCQkJICogYWxsIG9yIGhhcyBhbHJlYWR5IGJlZW4gY29tcGxldGVseSBzZW50LiBOb3cgd2UgY2FuCgkJCSAqIHJldHVybiAwLCBpbmRpY2F0aW5nIEVPRiwgbWVhbmluZyB0aGF0IHRoZSBmbHVzaCBoYXMKCQkJICogYmVlbiBmdWxseSBzZW50LgoJCQkgKi8KCQkJcnBjLT5mbHVzaF9yZWFkX2J1dF9ub3Rfc2VudCA9IDA7CgkJCXJldHVybiAwOwoJCX0KCQkvKgoJCSAqIElmIGF2YWlsIGlzIG5vbi16ZXJvLCB0aGUgbGluZSBsZW5ndGggZm9yIHRoZSBmbHVzaCBzdGlsbAoJCSAqIGhhc24ndCBiZWVuIGZ1bGx5IHNlbnQuIFByb2NlZWQgd2l0aCBzZW5kaW5nIHRoZSBsaW5lCgkJICogbGVuZ3RoLgoJCSAqLwoJfQoKCWlmIChtYXggPCBhdmFpbCkKCQlhdmFpbCA9IG1heDsKCW1lbWNweShwdHIsIHJwYy0+YnVmICsgcnBjLT5wb3MsIGF2YWlsKTsKCXJwYy0+cG9zICs9IGF2YWlsOwoJcmV0dXJuIGF2YWlsOwp9CgpzdGF0aWMgaW50IHJwY19zZWVrKHZvaWQgKmNsaWVudHAsIGN1cmxfb2ZmX3Qgb2Zmc2V0LCBpbnQgb3JpZ2luKQp7CglzdHJ1Y3QgcnBjX3N0YXRlICpycGMgPSBjbGllbnRwOwoKCWlmIChvcmlnaW4gIT0gU0VFS19TRVQpCgkJQlVHKCJycGNfc2VlayBvbmx5IGhhbmRsZXMgU0VFS19TRVQsIG5vdCAlZCIsIG9yaWdpbik7CgoJaWYgKHJwYy0+aW5pdGlhbF9idWZmZXIpIHsKCQlpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBycGMtPmxlbikgewoJCQllcnJvcigiY3VybCBzZWVrIHdvdWxkIGJlIG91dHNpZGUgb2YgcnBjIGJ1ZmZlciIpOwoJCQlyZXR1cm4gQ1VSTF9TRUVLRlVOQ19GQUlMOwoJCX0KCQlycGMtPnBvcyA9IG9mZnNldDsKCQlyZXR1cm4gQ1VSTF9TRUVLRlVOQ19PSzsKCX0KCWVycm9yKF8oInVuYWJsZSB0byByZXdpbmQgcnBjIHBvc3QgZGF0YSAtIHRyeSBpbmNyZWFzaW5nIGh0dHAucG9zdEJ1ZmZlciIpKTsKCXJldHVybiBDVVJMX1NFRUtGVU5DX0ZBSUw7Cn0KCnN0cnVjdCBjaGVja19wa3RsaW5lX3N0YXRlIHsKCWNoYXIgbGVuX2J1Zls0XTsKCWludCBsZW5fZmlsbGVkOwoJaW50IHJlbWFpbmluZzsKfTsKCnN0YXRpYyB2b2lkIGNoZWNrX3BrdGxpbmUoc3RydWN0IGNoZWNrX3BrdGxpbmVfc3RhdGUgKnN0YXRlLCBjb25zdCBjaGFyICpwdHIsIHNpemVfdCBzaXplKQp7Cgl3aGlsZSAoc2l6ZSkgewoJCWlmICghc3RhdGUtPnJlbWFpbmluZykgewoJCQlpbnQgZGlnaXRzX3JlbWFpbmluZyA9IDQgLSBzdGF0ZS0+bGVuX2ZpbGxlZDsKCQkJaWYgKGRpZ2l0c19yZW1haW5pbmcgPiBzaXplKQoJCQkJZGlnaXRzX3JlbWFpbmluZyA9IHNpemU7CgkJCW1lbWNweSgmc3RhdGUtPmxlbl9idWZbc3RhdGUtPmxlbl9maWxsZWRdLCBwdHIsIGRpZ2l0c19yZW1haW5pbmcpOwoJCQlzdGF0ZS0+bGVuX2ZpbGxlZCArPSBkaWdpdHNfcmVtYWluaW5nOwoJCQlwdHIgKz0gZGlnaXRzX3JlbWFpbmluZzsKCQkJc2l6ZSAtPSBkaWdpdHNfcmVtYWluaW5nOwoKCQkJaWYgKHN0YXRlLT5sZW5fZmlsbGVkID09IDQpIHsKCQkJCXN0YXRlLT5yZW1haW5pbmcgPSBwYWNrZXRfbGVuZ3RoKHN0YXRlLT5sZW5fYnVmLAoJCQkJCQkJCSBzaXplb2Yoc3RhdGUtPmxlbl9idWYpKTsKCQkJCWlmIChzdGF0ZS0+cmVtYWluaW5nIDwgMCkgewoJCQkJCWRpZShfKCJyZW1vdGUtY3VybDogYmFkIGxpbmUgbGVuZ3RoIGNoYXJhY3RlcjogJS40cyIpLCBzdGF0ZS0+bGVuX2J1Zik7CgkJCQl9IGVsc2UgaWYgKHN0YXRlLT5yZW1haW5pbmcgPT0gMikgewoJCQkJCWRpZShfKCJyZW1vdGUtY3VybDogdW5leHBlY3RlZCByZXNwb25zZSBlbmQgcGFja2V0IikpOwoJCQkJfSBlbHNlIGlmIChzdGF0ZS0+cmVtYWluaW5nIDwgNCkgewoJCQkJCXN0YXRlLT5yZW1haW5pbmcgPSAwOwoJCQkJfSBlbHNlIHsKCQkJCQlzdGF0ZS0+cmVtYWluaW5nIC09IDQ7CgkJCQl9CgkJCQlzdGF0ZS0+bGVuX2ZpbGxlZCA9IDA7CgkJCX0KCQl9CgoJCWlmIChzdGF0ZS0+cmVtYWluaW5nKSB7CgkJCWludCByZW1haW5pbmcgPSBzdGF0ZS0+cmVtYWluaW5nOwoJCQlpZiAocmVtYWluaW5nID4gc2l6ZSkKCQkJCXJlbWFpbmluZyA9IHNpemU7CgkJCXB0ciArPSByZW1haW5pbmc7CgkJCXNpemUgLT0gcmVtYWluaW5nOwoJCQlzdGF0ZS0+cmVtYWluaW5nIC09IHJlbWFpbmluZzsKCQl9Cgl9Cn0KCnN0cnVjdCBycGNfaW5fZGF0YSB7CglzdHJ1Y3QgcnBjX3N0YXRlICpycGM7CglzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdDsKCWludCBjaGVja19wa3RsaW5lOwoJc3RydWN0IGNoZWNrX3BrdGxpbmVfc3RhdGUgcGt0bGluZV9zdGF0ZTsKfTsKCi8qCiAqIEEgY2FsbGJhY2sgZm9yIENVUkxPUFRfV1JJVEVGVU5DVElPTi4gVGhlIHJldHVybiB2YWx1ZSBpcyB0aGUgYnl0ZXMgY29uc3VtZWQKICogZnJvbSBwdHIuCiAqLwpzdGF0aWMgc2l6ZV90IHJwY19pbihjaGFyICpwdHIsIHNpemVfdCBlbHRzaXplLAoJCXNpemVfdCBubWVtYiwgdm9pZCAqYnVmZmVyXykKewoJc2l6ZV90IHNpemUgPSBlbHRzaXplICogbm1lbWI7CglzdHJ1Y3QgcnBjX2luX2RhdGEgKmRhdGEgPSBidWZmZXJfOwoJbG9uZyByZXNwb25zZV9jb2RlOwoKCWlmIChjdXJsX2Vhc3lfZ2V0aW5mbyhkYXRhLT5zbG90LT5jdXJsLCBDVVJMSU5GT19SRVNQT05TRV9DT0RFLAoJCQkgICAgICAmcmVzcG9uc2VfY29kZSkgIT0gQ1VSTEVfT0spCgkJcmV0dXJuIHNpemU7CglpZiAocmVzcG9uc2VfY29kZSA+PSAzMDApCgkJcmV0dXJuIHNpemU7CglpZiAoc2l6ZSkKCQlkYXRhLT5ycGMtPmFueV93cml0dGVuID0gMTsKCWlmIChkYXRhLT5jaGVja19wa3RsaW5lKQoJCWNoZWNrX3BrdGxpbmUoJmRhdGEtPnBrdGxpbmVfc3RhdGUsIHB0ciwgc2l6ZSk7Cgl3cml0ZV9vcl9kaWUoZGF0YS0+cnBjLT5pbiwgcHRyLCBzaXplKTsKCXJldHVybiBzaXplOwp9CgpzdGF0aWMgaW50IHJ1bl9zbG90KHN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90LAoJCSAgICBzdHJ1Y3Qgc2xvdF9yZXN1bHRzICpyZXN1bHRzKQp7CglpbnQgZXJyOwoJc3RydWN0IHNsb3RfcmVzdWx0cyByZXN1bHRzX2J1ZjsKCglpZiAoIXJlc3VsdHMpCgkJcmVzdWx0cyA9ICZyZXN1bHRzX2J1ZjsKCgllcnIgPSBydW5fb25lX3Nsb3Qoc2xvdCwgcmVzdWx0cyk7CgoJaWYgKGVyciAhPSBIVFRQX09LICYmIGVyciAhPSBIVFRQX1JFQVVUSCkgewoJCXN0cnVjdCBzdHJidWYgbXNnID0gU1RSQlVGX0lOSVQ7CgkJaWYgKHJlc3VsdHMtPmh0dHBfY29kZSAmJiByZXN1bHRzLT5odHRwX2NvZGUgIT0gMjAwKQoJCQlzdHJidWZfYWRkZigmbXNnLCAiSFRUUCAlbGQiLCByZXN1bHRzLT5odHRwX2NvZGUpOwoJCWlmIChyZXN1bHRzLT5jdXJsX3Jlc3VsdCAhPSBDVVJMRV9PSykgewoJCQlpZiAobXNnLmxlbikKCQkJCXN0cmJ1Zl9hZGRjaCgmbXNnLCAnICcpOwoJCQlzdHJidWZfYWRkZigmbXNnLCAiY3VybCAlZCIsIHJlc3VsdHMtPmN1cmxfcmVzdWx0KTsKCQkJaWYgKGN1cmxfZXJyb3JzdHJbMF0pIHsKCQkJCXN0cmJ1Zl9hZGRjaCgmbXNnLCAnICcpOwoJCQkJc3RyYnVmX2FkZHN0cigmbXNnLCBjdXJsX2Vycm9yc3RyKTsKCQkJfQoJCX0KCQllcnJvcihfKCJSUEMgZmFpbGVkOyAlcyIpLCBtc2cuYnVmKTsKCQlzdHJidWZfcmVsZWFzZSgmbXNnKTsKCX0KCglyZXR1cm4gZXJyOwp9CgpzdGF0aWMgaW50IHByb2JlX3JwYyhzdHJ1Y3QgcnBjX3N0YXRlICpycGMsIHN0cnVjdCBzbG90X3Jlc3VsdHMgKnJlc3VsdHMpCnsKCXN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90OwoJc3RydWN0IGN1cmxfc2xpc3QgKmhlYWRlcnMgPSBodHRwX2NvcHlfZGVmYXVsdF9oZWFkZXJzKCk7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaW50IGVycjsKCglzbG90ID0gZ2V0X2FjdGl2ZV9zbG90KCk7CgoJaGVhZGVycyA9IGN1cmxfc2xpc3RfYXBwZW5kKGhlYWRlcnMsIHJwYy0+aGRyX2NvbnRlbnRfdHlwZSk7CgloZWFkZXJzID0gY3VybF9zbGlzdF9hcHBlbmQoaGVhZGVycywgcnBjLT5oZHJfYWNjZXB0KTsKCgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfTk9CT0RZLCAwKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NULCAxKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9VUkwsIHJwYy0+c2VydmljZV91cmwpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0VOQ09ESU5HLCBOVUxMKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NURklFTERTLCAiMDAwMCIpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1BPU1RGSUVMRFNJWkUsIDQpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0hUVFBIRUFERVIsIGhlYWRlcnMpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1dSSVRFRlVOQ1RJT04sIGZ3cml0ZV9idWZmZXIpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1dSSVRFREFUQSwgJmJ1Zik7CgoJZXJyID0gcnVuX3Nsb3Qoc2xvdCwgcmVzdWx0cyk7CgoJY3VybF9zbGlzdF9mcmVlX2FsbChoZWFkZXJzKTsKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJcmV0dXJuIGVycjsKfQoKc3RhdGljIGN1cmxfb2ZmX3QgeGN1cmxfb2ZmX3Qoc2l6ZV90IGxlbikKewoJdWludG1heF90IHNpemUgPSBsZW47CglpZiAoc2l6ZSA+IG1heGltdW1fc2lnbmVkX3ZhbHVlX29mX3R5cGUoY3VybF9vZmZfdCkpCgkJZGllKF8oImNhbm5vdCBoYW5kbGUgcHVzaGVzIHRoaXMgYmlnIikpOwoJcmV0dXJuIChjdXJsX29mZl90KXNpemU7Cn0KCi8qCiAqIElmIGZsdXNoX3JlY2VpdmVkIGlzIHRydWUsIGRvIG5vdCBhdHRlbXB0IHRvIHJlYWQgYW55IG1vcmU7IGp1c3QgdXNlIHdoYXQncwogKiBpbiBycGMtPmJ1Zi4KICovCnN0YXRpYyBpbnQgcG9zdF9ycGMoc3RydWN0IHJwY19zdGF0ZSAqcnBjLCBpbnQgc3RhdGVsZXNzX2Nvbm5lY3QsIGludCBmbHVzaF9yZWNlaXZlZCkKewoJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3Q7CglzdHJ1Y3QgY3VybF9zbGlzdCAqaGVhZGVycyA9IGh0dHBfY29weV9kZWZhdWx0X2hlYWRlcnMoKTsKCWludCB1c2VfZ3ppcCA9IHJwYy0+Z3ppcF9yZXF1ZXN0OwoJY2hhciAqZ3ppcF9ib2R5ID0gTlVMTDsKCXNpemVfdCBnemlwX3NpemUgPSAwOwoJaW50IGVyciwgbGFyZ2VfcmVxdWVzdCA9IDA7CglpbnQgbmVlZHNfMTAwX2NvbnRpbnVlID0gMDsKCXN0cnVjdCBycGNfaW5fZGF0YSBycGNfaW5fZGF0YTsKCgkvKiBUcnkgdG8gbG9hZCB0aGUgZW50aXJlIHJlcXVlc3QsIGlmIHdlIGNhbiBmaXQgaXQgaW50byB0aGUKCSAqIGFsbG9jYXRlZCBidWZmZXIgc3BhY2Ugd2UgY2FuIHVzZSBIVFRQLzEuMCBhbmQgYXZvaWQgdGhlCgkgKiBjaHVua2VkIGVuY29kaW5nIG1lc3MuCgkgKi8KCWlmICghZmx1c2hfcmVjZWl2ZWQpIHsKCQl3aGlsZSAoMSkgewoJCQlzaXplX3QgbjsKCQkJZW51bSBwYWNrZXRfcmVhZF9zdGF0dXMgc3RhdHVzOwoKCQkJaWYgKCFycGNfcmVhZF9mcm9tX291dChycGMsIDAsICZuLCAmc3RhdHVzKSkgewoJCQkJbGFyZ2VfcmVxdWVzdCA9IDE7CgkJCQl1c2VfZ3ppcCA9IDA7CgkJCQlicmVhazsKCQkJfQoJCQlpZiAoc3RhdHVzID09IFBBQ0tFVF9SRUFEX0ZMVVNIKQoJCQkJYnJlYWs7CgkJfQoJfQoKCWlmIChsYXJnZV9yZXF1ZXN0KSB7CgkJc3RydWN0IHNsb3RfcmVzdWx0cyByZXN1bHRzOwoKCQlkbyB7CgkJCWVyciA9IHByb2JlX3JwYyhycGMsICZyZXN1bHRzKTsKCQkJaWYgKGVyciA9PSBIVFRQX1JFQVVUSCkKCQkJCWNyZWRlbnRpYWxfZmlsbCgmaHR0cF9hdXRoKTsKCQl9IHdoaWxlIChlcnIgPT0gSFRUUF9SRUFVVEgpOwoJCWlmIChlcnIgIT0gSFRUUF9PSykKCQkJcmV0dXJuIC0xOwoKCQlpZiAocmVzdWx0cy5hdXRoX2F2YWlsICYgQ1VSTEFVVEhfR1NTTkVHT1RJQVRFKQoJCQluZWVkc18xMDBfY29udGludWUgPSAxOwoJfQoKCWhlYWRlcnMgPSBjdXJsX3NsaXN0X2FwcGVuZChoZWFkZXJzLCBycGMtPmhkcl9jb250ZW50X3R5cGUpOwoJaGVhZGVycyA9IGN1cmxfc2xpc3RfYXBwZW5kKGhlYWRlcnMsIHJwYy0+aGRyX2FjY2VwdCk7CgloZWFkZXJzID0gY3VybF9zbGlzdF9hcHBlbmQoaGVhZGVycywgbmVlZHNfMTAwX2NvbnRpbnVlID8KCQkiRXhwZWN0OiAxMDAtY29udGludWUiIDogIkV4cGVjdDoiKTsKCgkvKiBBZGQgQWNjZXB0LUxhbmd1YWdlIGhlYWRlciAqLwoJaWYgKHJwYy0+aGRyX2FjY2VwdF9sYW5ndWFnZSkKCQloZWFkZXJzID0gY3VybF9zbGlzdF9hcHBlbmQoaGVhZGVycywgcnBjLT5oZHJfYWNjZXB0X2xhbmd1YWdlKTsKCgkvKiBBZGQgdGhlIGV4dHJhIEdpdC1Qcm90b2NvbCBoZWFkZXIgKi8KCWlmIChycGMtPnByb3RvY29sX2hlYWRlcikKCQloZWFkZXJzID0gY3VybF9zbGlzdF9hcHBlbmQoaGVhZGVycywgcnBjLT5wcm90b2NvbF9oZWFkZXIpOwoKcmV0cnk6CglzbG90ID0gZ2V0X2FjdGl2ZV9zbG90KCk7CgoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX05PQk9EWSwgMCk7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfUE9TVCwgMSk7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfVVJMLCBycGMtPnNlcnZpY2VfdXJsKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9FTkNPRElORywgIiIpOwoKCWlmIChsYXJnZV9yZXF1ZXN0KSB7CgkJLyogVGhlIHJlcXVlc3QgYm9keSBpcyBsYXJnZSBhbmQgdGhlIHNpemUgY2Fubm90IGJlIHByZWRpY3RlZC4KCQkgKiBXZSBtdXN0IHVzZSBjaHVua2VkIGVuY29kaW5nIHRvIHNlbmQgaXQuCgkJICovCiNpZmRlZiBHSVRfQ1VSTF9ORUVEX1RSQU5TRkVSX0VOQ09ESU5HX0hFQURFUgoJCWhlYWRlcnMgPSBjdXJsX3NsaXN0X2FwcGVuZChoZWFkZXJzLCAiVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWQiKTsKI2VuZGlmCgkJcnBjLT5pbml0aWFsX2J1ZmZlciA9IDE7CgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1JFQURGVU5DVElPTiwgcnBjX291dCk7CgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0lORklMRSwgcnBjKTsKCQljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfU0VFS0ZVTkNUSU9OLCBycGNfc2Vlayk7CgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1NFRUtEQVRBLCBycGMpOwoJCWlmIChvcHRpb25zLnZlcmJvc2l0eSA+IDEpIHsKCQkJZnByaW50ZihzdGRlcnIsICJQT1NUICVzIChjaHVua2VkKVxuIiwgcnBjLT5zZXJ2aWNlX25hbWUpOwoJCQlmZmx1c2goc3RkZXJyKTsKCQl9CgoJfSBlbHNlIGlmIChnemlwX2JvZHkpIHsKCQkvKgoJCSAqIElmIHdlIGFyZSBsb29waW5nIHRvIHJldHJ5IGF1dGhlbnRpY2F0aW9uLCB0aGVuIHRoZSBwcmV2aW91cwoJCSAqIHJ1biB3aWxsIGhhdmUgc2V0IHVwIHRoZSBoZWFkZXJzIGFuZCBnemlwIGJ1ZmZlciBhbHJlYWR5LAoJCSAqIGFuZCB3ZSBqdXN0IG5lZWQgdG8gc2VuZCBpdC4KCQkgKi8KCQljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfUE9TVEZJRUxEUywgZ3ppcF9ib2R5KTsKCQljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfUE9TVEZJRUxEU0laRV9MQVJHRSwgeGN1cmxfb2ZmX3QoZ3ppcF9zaXplKSk7CgoJfSBlbHNlIGlmICh1c2VfZ3ppcCAmJiAxMDI0IDwgcnBjLT5sZW4pIHsKCQkvKiBUaGUgY2xpZW50IGJhY2tlbmQgaXNuJ3QgZ2l2aW5nIHVzIGNvbXByZXNzZWQgZGF0YSBzbwoJCSAqIHdlIGNhbiB0cnkgdG8gZGVmbGF0ZSBpdCBvdXJzZWx2ZXMsIHRoaXMgbWF5IHNhdmUgb24KCQkgKiB0aGUgdHJhbnNmZXIgdGltZS4KCQkgKi8KCQlnaXRfenN0cmVhbSBzdHJlYW07CgkJaW50IHJldDsKCgkJZ2l0X2RlZmxhdGVfaW5pdF9nemlwKCZzdHJlYW0sIFpfQkVTVF9DT01QUkVTU0lPTik7CgkJZ3ppcF9zaXplID0gZ2l0X2RlZmxhdGVfYm91bmQoJnN0cmVhbSwgcnBjLT5sZW4pOwoJCWd6aXBfYm9keSA9IHhtYWxsb2MoZ3ppcF9zaXplKTsKCgkJc3RyZWFtLm5leHRfaW4gPSAodW5zaWduZWQgY2hhciAqKXJwYy0+YnVmOwoJCXN0cmVhbS5hdmFpbF9pbiA9IHJwYy0+bGVuOwoJCXN0cmVhbS5uZXh0X291dCA9ICh1bnNpZ25lZCBjaGFyICopZ3ppcF9ib2R5OwoJCXN0cmVhbS5hdmFpbF9vdXQgPSBnemlwX3NpemU7CgoJCXJldCA9IGdpdF9kZWZsYXRlKCZzdHJlYW0sIFpfRklOSVNIKTsKCQlpZiAocmV0ICE9IFpfU1RSRUFNX0VORCkKCQkJZGllKF8oImNhbm5vdCBkZWZsYXRlIHJlcXVlc3Q7IHpsaWIgZGVmbGF0ZSBlcnJvciAlZCIpLCByZXQpOwoKCQlyZXQgPSBnaXRfZGVmbGF0ZV9lbmRfZ2VudGx5KCZzdHJlYW0pOwoJCWlmIChyZXQgIT0gWl9PSykKCQkJZGllKF8oImNhbm5vdCBkZWZsYXRlIHJlcXVlc3Q7IHpsaWIgZW5kIGVycm9yICVkIiksIHJldCk7CgoJCWd6aXBfc2l6ZSA9IHN0cmVhbS50b3RhbF9vdXQ7CgoJCWhlYWRlcnMgPSBjdXJsX3NsaXN0X2FwcGVuZChoZWFkZXJzLCAiQ29udGVudC1FbmNvZGluZzogZ3ppcCIpOwoJCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NURklFTERTLCBnemlwX2JvZHkpOwoJCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NURklFTERTSVpFX0xBUkdFLCB4Y3VybF9vZmZfdChnemlwX3NpemUpKTsKCgkJaWYgKG9wdGlvbnMudmVyYm9zaXR5ID4gMSkgewoJCQlmcHJpbnRmKHN0ZGVyciwgIlBPU1QgJXMgKGd6aXAgJWx1IHRvICVsdSBieXRlcylcbiIsCgkJCQlycGMtPnNlcnZpY2VfbmFtZSwKCQkJCSh1bnNpZ25lZCBsb25nKXJwYy0+bGVuLCAodW5zaWduZWQgbG9uZylnemlwX3NpemUpOwoJCQlmZmx1c2goc3RkZXJyKTsKCQl9Cgl9IGVsc2UgewoJCS8qIFdlIGtub3cgdGhlIGNvbXBsZXRlIHJlcXVlc3Qgc2l6ZSBpbiBhZHZhbmNlLCB1c2UgdGhlCgkJICogbW9yZSBub3JtYWwgQ29udGVudC1MZW5ndGggYXBwcm9hY2guCgkJICovCgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1BPU1RGSUVMRFMsIHJwYy0+YnVmKTsKCQljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfUE9TVEZJRUxEU0laRV9MQVJHRSwgeGN1cmxfb2ZmX3QocnBjLT5sZW4pKTsKCQlpZiAob3B0aW9ucy52ZXJib3NpdHkgPiAxKSB7CgkJCWZwcmludGYoc3RkZXJyLCAiUE9TVCAlcyAoJWx1IGJ5dGVzKVxuIiwKCQkJCXJwYy0+c2VydmljZV9uYW1lLCAodW5zaWduZWQgbG9uZylycGMtPmxlbik7CgkJCWZmbHVzaChzdGRlcnIpOwoJCX0KCX0KCgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfSFRUUEhFQURFUiwgaGVhZGVycyk7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfV1JJVEVGVU5DVElPTiwgcnBjX2luKTsKCXJwY19pbl9kYXRhLnJwYyA9IHJwYzsKCXJwY19pbl9kYXRhLnNsb3QgPSBzbG90OwoJcnBjX2luX2RhdGEuY2hlY2tfcGt0bGluZSA9IHN0YXRlbGVzc19jb25uZWN0OwoJbWVtc2V0KCZycGNfaW5fZGF0YS5wa3RsaW5lX3N0YXRlLCAwLCBzaXplb2YocnBjX2luX2RhdGEucGt0bGluZV9zdGF0ZSkpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1dSSVRFREFUQSwgJnJwY19pbl9kYXRhKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9GQUlMT05FUlJPUiwgMCk7CgoKCXJwYy0+YW55X3dyaXR0ZW4gPSAwOwoJZXJyID0gcnVuX3Nsb3Qoc2xvdCwgTlVMTCk7CglpZiAoZXJyID09IEhUVFBfUkVBVVRIICYmICFsYXJnZV9yZXF1ZXN0KSB7CgkJY3JlZGVudGlhbF9maWxsKCZodHRwX2F1dGgpOwoJCWdvdG8gcmV0cnk7Cgl9CglpZiAoZXJyICE9IEhUVFBfT0spCgkJZXJyID0gLTE7CgoJaWYgKCFycGMtPmFueV93cml0dGVuKQoJCWVyciA9IC0xOwoKCWlmIChycGNfaW5fZGF0YS5wa3RsaW5lX3N0YXRlLmxlbl9maWxsZWQpCgkJZXJyID0gZXJyb3IoXygiJWQgYnl0ZXMgb2YgbGVuZ3RoIGhlYWRlciB3ZXJlIHJlY2VpdmVkIiksIHJwY19pbl9kYXRhLnBrdGxpbmVfc3RhdGUubGVuX2ZpbGxlZCk7CglpZiAocnBjX2luX2RhdGEucGt0bGluZV9zdGF0ZS5yZW1haW5pbmcpCgkJZXJyID0gZXJyb3IoXygiJWQgYnl0ZXMgb2YgYm9keSBhcmUgc3RpbGwgZXhwZWN0ZWQiKSwgcnBjX2luX2RhdGEucGt0bGluZV9zdGF0ZS5yZW1haW5pbmcpOwoKCWlmIChzdGF0ZWxlc3NfY29ubmVjdCkKCQlwYWNrZXRfcmVzcG9uc2VfZW5kKHJwYy0+aW4pOwoKCWN1cmxfc2xpc3RfZnJlZV9hbGwoaGVhZGVycyk7CglmcmVlKGd6aXBfYm9keSk7CglyZXR1cm4gZXJyOwp9CgpzdGF0aWMgaW50IHJwY19zZXJ2aWNlKHN0cnVjdCBycGNfc3RhdGUgKnJwYywgc3RydWN0IGRpc2NvdmVyeSAqaGVhZHMsCgkJICAgICAgIGNvbnN0IGNoYXIgKipjbGllbnRfYXJndiwgY29uc3Qgc3RydWN0IHN0cmJ1ZiAqcHJlYW1ibGUsCgkJICAgICAgIHN0cnVjdCBzdHJidWYgKnJwY19yZXN1bHQpCnsKCWNvbnN0IGNoYXIgKnN2YyA9IHJwYy0+c2VydmljZV9uYW1lOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGNsaWVudCA9IENISUxEX1BST0NFU1NfSU5JVDsKCWludCBlcnIgPSAwOwoKCWNsaWVudC5pbiA9IC0xOwoJY2xpZW50Lm91dCA9IC0xOwoJY2xpZW50LmdpdF9jbWQgPSAxOwoJc3RydmVjX3B1c2h2KCZjbGllbnQuYXJncywgY2xpZW50X2FyZ3YpOwoJaWYgKHN0YXJ0X2NvbW1hbmQoJmNsaWVudCkpCgkJZXhpdCgxKTsKCXdyaXRlX29yX2RpZShjbGllbnQuaW4sIHByZWFtYmxlLT5idWYsIHByZWFtYmxlLT5sZW4pOwoJaWYgKGhlYWRzKQoJCXdyaXRlX29yX2RpZShjbGllbnQuaW4sIGhlYWRzLT5idWYsIGhlYWRzLT5sZW4pOwoKCXJwYy0+YWxsb2MgPSBodHRwX3Bvc3RfYnVmZmVyOwoJcnBjLT5idWYgPSB4bWFsbG9jKHJwYy0+YWxsb2MpOwoJcnBjLT5pbiA9IGNsaWVudC5pbjsKCXJwYy0+b3V0ID0gY2xpZW50Lm91dDsKCglzdHJidWZfYWRkZigmYnVmLCAiJXMlcyIsIHVybC5idWYsIHN2Yyk7CglycGMtPnNlcnZpY2VfdXJsID0gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCglycGMtPmhkcl9hY2NlcHRfbGFuZ3VhZ2UgPSB4c3RyZHVwX29yX251bGwoaHR0cF9nZXRfYWNjZXB0X2xhbmd1YWdlX2hlYWRlcigpKTsKCglzdHJidWZfYWRkZigmYnVmLCAiQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi94LSVzLXJlcXVlc3QiLCBzdmMpOwoJcnBjLT5oZHJfY29udGVudF90eXBlID0gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCglzdHJidWZfYWRkZigmYnVmLCAiQWNjZXB0OiBhcHBsaWNhdGlvbi94LSVzLXJlc3VsdCIsIHN2Yyk7CglycGMtPmhkcl9hY2NlcHQgPSBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpOwoKCWlmIChnZXRfcHJvdG9jb2xfaHR0cF9oZWFkZXIoaGVhZHMtPnZlcnNpb24sICZidWYpKQoJCXJwYy0+cHJvdG9jb2xfaGVhZGVyID0gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCWVsc2UKCQlycGMtPnByb3RvY29sX2hlYWRlciA9IE5VTEw7CgoJd2hpbGUgKCFlcnIpIHsKCQlpbnQgbiA9IHBhY2tldF9yZWFkKHJwYy0+b3V0LCBycGMtPmJ1ZiwgcnBjLT5hbGxvYywgMCk7CgkJaWYgKCFuKQoJCQlicmVhazsKCQlycGMtPnBvcyA9IDA7CgkJcnBjLT5sZW4gPSBuOwoJCWVyciB8PSBwb3N0X3JwYyhycGMsIDAsIDApOwoJfQoKCWNsb3NlKGNsaWVudC5pbik7CgljbGllbnQuaW4gPSAtMTsKCWlmICghZXJyKSB7CgkJc3RyYnVmX3JlYWQocnBjX3Jlc3VsdCwgY2xpZW50Lm91dCwgMCk7Cgl9IGVsc2UgewoJCWNoYXIgYnVmWzQwOTZdOwoJCWZvciAoOzspCgkJCWlmICh4cmVhZChjbGllbnQub3V0LCBidWYsIHNpemVvZihidWYpKSA8PSAwKQoJCQkJYnJlYWs7Cgl9CgoJY2xvc2UoY2xpZW50Lm91dCk7CgljbGllbnQub3V0ID0gLTE7CgoJZXJyIHw9IGZpbmlzaF9jb21tYW5kKCZjbGllbnQpOwoJZnJlZShycGMtPnNlcnZpY2VfdXJsKTsKCWZyZWUocnBjLT5oZHJfY29udGVudF90eXBlKTsKCWZyZWUocnBjLT5oZHJfYWNjZXB0KTsKCWZyZWUocnBjLT5oZHJfYWNjZXB0X2xhbmd1YWdlKTsKCWZyZWUocnBjLT5wcm90b2NvbF9oZWFkZXIpOwoJZnJlZShycGMtPmJ1Zik7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCXJldHVybiBlcnI7Cn0KCnN0YXRpYyBpbnQgZmV0Y2hfZHVtYihpbnQgbnJfaGVhZHMsIHN0cnVjdCByZWYgKip0b19mZXRjaCkKewoJc3RydWN0IHdhbGtlciAqd2Fsa2VyOwoJY2hhciAqKnRhcmdldHM7CglpbnQgcmV0LCBpOwoKCUFMTE9DX0FSUkFZKHRhcmdldHMsIG5yX2hlYWRzKTsKCWlmIChvcHRpb25zLmRlcHRoIHx8IG9wdGlvbnMuZGVlcGVuX3NpbmNlKQoJCWRpZShfKCJkdW1iIGh0dHAgdHJhbnNwb3J0IGRvZXMgbm90IHN1cHBvcnQgc2hhbGxvdyBjYXBhYmlsaXRpZXMiKSk7Cglmb3IgKGkgPSAwOyBpIDwgbnJfaGVhZHM7IGkrKykKCQl0YXJnZXRzW2ldID0geHN0cmR1cChvaWRfdG9faGV4KCZ0b19mZXRjaFtpXS0+b2xkX29pZCkpOwoKCXdhbGtlciA9IGdldF9odHRwX3dhbGtlcih1cmwuYnVmKTsKCXdhbGtlci0+Z2V0X3ZlcmJvc2VseSA9IG9wdGlvbnMudmVyYm9zaXR5ID49IDM7Cgl3YWxrZXItPmdldF9wcm9ncmVzcyA9IG9wdGlvbnMucHJvZ3Jlc3M7Cgl3YWxrZXItPmdldF9yZWNvdmVyID0gMDsKCXJldCA9IHdhbGtlcl9mZXRjaCh3YWxrZXIsIG5yX2hlYWRzLCB0YXJnZXRzLCBOVUxMLCBOVUxMKTsKCXdhbGtlcl9mcmVlKHdhbGtlcik7CgoJZm9yIChpID0gMDsgaSA8IG5yX2hlYWRzOyBpKyspCgkJZnJlZSh0YXJnZXRzW2ldKTsKCWZyZWUodGFyZ2V0cyk7CgoJcmV0dXJuIHJldCA/IGVycm9yKF8oImZldGNoIGZhaWxlZC4iKSkgOiAwOwp9CgpzdGF0aWMgaW50IGZldGNoX2dpdChzdHJ1Y3QgZGlzY292ZXJ5ICpoZWFkcywKCWludCBucl9oZWFkcywgc3RydWN0IHJlZiAqKnRvX2ZldGNoKQp7CglzdHJ1Y3QgcnBjX3N0YXRlIHJwYyA9IFJQQ19TVEFURV9JTklUOwoJc3RydWN0IHN0cmJ1ZiBwcmVhbWJsZSA9IFNUUkJVRl9JTklUOwoJaW50IGksIGVycjsKCXN0cnVjdCBzdHJ2ZWMgYXJncyA9IFNUUlZFQ19JTklUOwoJc3RydWN0IHN0cmJ1ZiBycGNfcmVzdWx0ID0gU1RSQlVGX0lOSVQ7CgoJc3RydmVjX3B1c2hsKCZhcmdzLCAiZmV0Y2gtcGFjayIsICItLXN0YXRlbGVzcy1ycGMiLAoJCSAgICAgIi0tc3RkaW4iLCAiLS1sb2NrLXBhY2siLCBOVUxMKTsKCWlmIChvcHRpb25zLmZvbGxvd3RhZ3MpCgkJc3RydmVjX3B1c2goJmFyZ3MsICItLWluY2x1ZGUtdGFnIik7CglpZiAob3B0aW9ucy50aGluKQoJCXN0cnZlY19wdXNoKCZhcmdzLCAiLS10aGluIik7CglpZiAob3B0aW9ucy52ZXJib3NpdHkgPj0gMykKCQlzdHJ2ZWNfcHVzaGwoJmFyZ3MsICItdiIsICItdiIsIE5VTEwpOwoJaWYgKG9wdGlvbnMuY2hlY2tfc2VsZl9jb250YWluZWRfYW5kX2Nvbm5lY3RlZCkKCQlzdHJ2ZWNfcHVzaCgmYXJncywgIi0tY2hlY2stc2VsZi1jb250YWluZWQtYW5kLWNvbm5lY3RlZCIpOwoJaWYgKG9wdGlvbnMuY2xvbmluZykKCQlzdHJ2ZWNfcHVzaCgmYXJncywgIi0tY2xvbmluZyIpOwoJaWYgKG9wdGlvbnMudXBkYXRlX3NoYWxsb3cpCgkJc3RydmVjX3B1c2goJmFyZ3MsICItLXVwZGF0ZS1zaGFsbG93Iik7CglpZiAoIW9wdGlvbnMucHJvZ3Jlc3MpCgkJc3RydmVjX3B1c2goJmFyZ3MsICItLW5vLXByb2dyZXNzIik7CglpZiAob3B0aW9ucy5kZXB0aCkKCQlzdHJ2ZWNfcHVzaGYoJmFyZ3MsICItLWRlcHRoPSVsdSIsIG9wdGlvbnMuZGVwdGgpOwoJaWYgKG9wdGlvbnMuZGVlcGVuX3NpbmNlKQoJCXN0cnZlY19wdXNoZigmYXJncywgIi0tc2hhbGxvdy1zaW5jZT0lcyIsIG9wdGlvbnMuZGVlcGVuX3NpbmNlKTsKCWZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmRlZXBlbl9ub3QubnI7IGkrKykKCQlzdHJ2ZWNfcHVzaGYoJmFyZ3MsICItLXNoYWxsb3ctZXhjbHVkZT0lcyIsCgkJCSAgICAgb3B0aW9ucy5kZWVwZW5fbm90Lml0ZW1zW2ldLnN0cmluZyk7CglpZiAob3B0aW9ucy5kZWVwZW5fcmVsYXRpdmUgJiYgb3B0aW9ucy5kZXB0aCkKCQlzdHJ2ZWNfcHVzaCgmYXJncywgIi0tZGVlcGVuLXJlbGF0aXZlIik7CglpZiAob3B0aW9ucy5mcm9tX3Byb21pc29yKQoJCXN0cnZlY19wdXNoKCZhcmdzLCAiLS1mcm9tLXByb21pc29yIik7CglpZiAob3B0aW9ucy5yZWZldGNoKQoJCXN0cnZlY19wdXNoKCZhcmdzLCAiLS1yZWZldGNoIik7CglpZiAob3B0aW9ucy5maWx0ZXIpCgkJc3RydmVjX3B1c2hmKCZhcmdzLCAiLS1maWx0ZXI9JXMiLCBvcHRpb25zLmZpbHRlcik7CglzdHJ2ZWNfcHVzaCgmYXJncywgdXJsLmJ1Zik7CgoJZm9yIChpID0gMDsgaSA8IG5yX2hlYWRzOyBpKyspIHsKCQlzdHJ1Y3QgcmVmICpyZWYgPSB0b19mZXRjaFtpXTsKCQlpZiAoISpyZWYtPm5hbWUpCgkJCWRpZShfKCJjYW5ub3QgZmV0Y2ggYnkgc2hhMSBvdmVyIHNtYXJ0IGh0dHAiKSk7CgkJcGFja2V0X2J1Zl93cml0ZSgmcHJlYW1ibGUsICIlcyAlc1xuIiwKCQkJCSBvaWRfdG9faGV4KCZyZWYtPm9sZF9vaWQpLCByZWYtPm5hbWUpOwoJfQoJcGFja2V0X2J1Zl9mbHVzaCgmcHJlYW1ibGUpOwoKCW1lbXNldCgmcnBjLCAwLCBzaXplb2YocnBjKSk7CglycGMuc2VydmljZV9uYW1lID0gImdpdC11cGxvYWQtcGFjayIsCglycGMuZ3ppcF9yZXF1ZXN0ID0gMTsKCgllcnIgPSBycGNfc2VydmljZSgmcnBjLCBoZWFkcywgYXJncy52LCAmcHJlYW1ibGUsICZycGNfcmVzdWx0KTsKCWlmIChycGNfcmVzdWx0LmxlbikKCQl3cml0ZV9vcl9kaWUoMSwgcnBjX3Jlc3VsdC5idWYsIHJwY19yZXN1bHQubGVuKTsKCXN0cmJ1Zl9yZWxlYXNlKCZycGNfcmVzdWx0KTsKCXN0cmJ1Zl9yZWxlYXNlKCZwcmVhbWJsZSk7CglzdHJ2ZWNfY2xlYXIoJmFyZ3MpOwoJcmV0dXJuIGVycjsKfQoKc3RhdGljIGludCBmZXRjaChpbnQgbnJfaGVhZHMsIHN0cnVjdCByZWYgKip0b19mZXRjaCkKewoJc3RydWN0IGRpc2NvdmVyeSAqZCA9IGRpc2NvdmVyX3JlZnMoImdpdC11cGxvYWQtcGFjayIsIDApOwoJaWYgKGQtPnByb3RvX2dpdCkKCQlyZXR1cm4gZmV0Y2hfZ2l0KGQsIG5yX2hlYWRzLCB0b19mZXRjaCk7CgllbHNlCgkJcmV0dXJuIGZldGNoX2R1bWIobnJfaGVhZHMsIHRvX2ZldGNoKTsKfQoKc3RhdGljIHZvaWQgcGFyc2VfZmV0Y2goc3RydWN0IHN0cmJ1ZiAqYnVmKQp7CglzdHJ1Y3QgcmVmICoqdG9fZmV0Y2ggPSBOVUxMOwoJc3RydWN0IHJlZiAqbGlzdF9oZWFkID0gTlVMTDsKCXN0cnVjdCByZWYgKipsaXN0ID0gJmxpc3RfaGVhZDsKCWludCBhbGxvY19oZWFkcyA9IDAsIG5yX2hlYWRzID0gMDsKCglkbyB7CgkJY29uc3QgY2hhciAqcDsKCQlpZiAoc2tpcF9wcmVmaXgoYnVmLT5idWYsICJmZXRjaCAiLCAmcCkpIHsKCQkJY29uc3QgY2hhciAqbmFtZTsKCQkJc3RydWN0IHJlZiAqcmVmOwoJCQlzdHJ1Y3Qgb2JqZWN0X2lkIG9sZF9vaWQ7CgkJCWNvbnN0IGNoYXIgKnE7CgoJCQlpZiAocGFyc2Vfb2lkX2hleChwLCAmb2xkX29pZCwgJnEpKQoJCQkJZGllKF8oInByb3RvY29sIGVycm9yOiBleHBlY3RlZCBzaGEvcmVmLCBnb3QgJyVzJyIpLCBwKTsKCQkJaWYgKCpxID09ICcgJykKCQkJCW5hbWUgPSBxICsgMTsKCQkJZWxzZSBpZiAoISpxKQoJCQkJbmFtZSA9ICIiOwoJCQllbHNlCgkJCQlkaWUoXygicHJvdG9jb2wgZXJyb3I6IGV4cGVjdGVkIHNoYS9yZWYsIGdvdCAnJXMnIiksIHApOwoKCQkJcmVmID0gYWxsb2NfcmVmKG5hbWUpOwoJCQlvaWRjcHkoJnJlZi0+b2xkX29pZCwgJm9sZF9vaWQpOwoKCQkJKmxpc3QgPSByZWY7CgkJCWxpc3QgPSAmcmVmLT5uZXh0OwoKCQkJQUxMT0NfR1JPVyh0b19mZXRjaCwgbnJfaGVhZHMgKyAxLCBhbGxvY19oZWFkcyk7CgkJCXRvX2ZldGNoW25yX2hlYWRzKytdID0gcmVmOwoJCX0KCQllbHNlCgkJCWRpZShfKCJodHRwIHRyYW5zcG9ydCBkb2VzIG5vdCBzdXBwb3J0ICVzIiksIGJ1Zi0+YnVmKTsKCgkJc3RyYnVmX3Jlc2V0KGJ1Zik7CgkJaWYgKHN0cmJ1Zl9nZXRsaW5lX2xmKGJ1Ziwgc3RkaW4pID09IEVPRikKCQkJcmV0dXJuOwoJCWlmICghKmJ1Zi0+YnVmKQoJCQlicmVhazsKCX0gd2hpbGUgKDEpOwoKCWlmIChmZXRjaChucl9oZWFkcywgdG9fZmV0Y2gpKQoJCWV4aXQoMTI4KTsgLyogZXJyb3IgYWxyZWFkeSByZXBvcnRlZCAqLwoJZnJlZV9yZWZzKGxpc3RfaGVhZCk7CglmcmVlKHRvX2ZldGNoKTsKCglwcmludGYoIlxuIik7CglmZmx1c2goc3Rkb3V0KTsKCXN0cmJ1Zl9yZXNldChidWYpOwp9CgpzdGF0aWMgdm9pZCBwYXJzZV9nZXQoY29uc3QgY2hhciAqYXJnKQp7CglzdHJ1Y3Qgc3RyYnVmIHVybCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBwYXRoID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpzcGFjZTsKCglzcGFjZSA9IHN0cmNocihhcmcsICcgJyk7CgoJaWYgKCFzcGFjZSkKCQlkaWUoXygicHJvdG9jb2wgZXJyb3I6IGV4cGVjdGVkICc8dXJsPiA8cGF0aD4nLCBtaXNzaW5nIHNwYWNlIikpOwoKCXN0cmJ1Zl9hZGQoJnVybCwgYXJnLCBzcGFjZSAtIGFyZyk7CglzdHJidWZfYWRkc3RyKCZwYXRoLCBzcGFjZSArIDEpOwoKCWlmIChodHRwX2dldF9maWxlKHVybC5idWYsIHBhdGguYnVmLCBOVUxMKSkKCQlkaWUoXygiZmFpbGVkIHRvIGRvd25sb2FkIGZpbGUgYXQgVVJMICclcyciKSwgdXJsLmJ1Zik7CgoJc3RyYnVmX3JlbGVhc2UoJnVybCk7CglzdHJidWZfcmVsZWFzZSgmcGF0aCk7CglwcmludGYoIlxuIik7CglmZmx1c2goc3Rkb3V0KTsKfQoKc3RhdGljIGludCBwdXNoX2RhdihpbnQgbnJfc3BlYywgY29uc3QgY2hhciAqKnNwZWNzKQp7CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBjaGlsZCA9IENISUxEX1BST0NFU1NfSU5JVDsKCXNpemVfdCBpOwoKCWNoaWxkLmdpdF9jbWQgPSAxOwoJc3RydmVjX3B1c2goJmNoaWxkLmFyZ3MsICJodHRwLXB1c2giKTsKCXN0cnZlY19wdXNoKCZjaGlsZC5hcmdzLCAiLS1oZWxwZXItc3RhdHVzIik7CglpZiAob3B0aW9ucy5kcnlfcnVuKQoJCXN0cnZlY19wdXNoKCZjaGlsZC5hcmdzLCAiLS1kcnktcnVuIik7CglpZiAob3B0aW9ucy52ZXJib3NpdHkgPiAxKQoJCXN0cnZlY19wdXNoKCZjaGlsZC5hcmdzLCAiLS12ZXJib3NlIik7CglzdHJ2ZWNfcHVzaCgmY2hpbGQuYXJncywgdXJsLmJ1Zik7Cglmb3IgKGkgPSAwOyBpIDwgbnJfc3BlYzsgaSsrKQoJCXN0cnZlY19wdXNoKCZjaGlsZC5hcmdzLCBzcGVjc1tpXSk7CgoJaWYgKHJ1bl9jb21tYW5kKCZjaGlsZCkpCgkJZGllKF8oImdpdC1odHRwLXB1c2ggZmFpbGVkIikpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgcHVzaF9naXQoc3RydWN0IGRpc2NvdmVyeSAqaGVhZHMsIGludCBucl9zcGVjLCBjb25zdCBjaGFyICoqc3BlY3MpCnsKCXN0cnVjdCBycGNfc3RhdGUgcnBjID0gUlBDX1NUQVRFX0lOSVQ7CglpbnQgaSwgZXJyOwoJc3RydWN0IHN0cnZlYyBhcmdzOwoJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKmNhc19vcHRpb247CglzdHJ1Y3Qgc3RyYnVmIHByZWFtYmxlID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIHJwY19yZXN1bHQgPSBTVFJCVUZfSU5JVDsKCglzdHJ2ZWNfaW5pdCgmYXJncyk7CglzdHJ2ZWNfcHVzaGwoJmFyZ3MsICJzZW5kLXBhY2siLCAiLS1zdGF0ZWxlc3MtcnBjIiwgIi0taGVscGVyLXN0YXR1cyIsCgkJICAgICBOVUxMKTsKCglpZiAob3B0aW9ucy50aGluKQoJCXN0cnZlY19wdXNoKCZhcmdzLCAiLS10aGluIik7CglpZiAob3B0aW9ucy5kcnlfcnVuKQoJCXN0cnZlY19wdXNoKCZhcmdzLCAiLS1kcnktcnVuIik7CglpZiAob3B0aW9ucy5wdXNoX2NlcnQgPT0gU0VORF9QQUNLX1BVU0hfQ0VSVF9BTFdBWVMpCgkJc3RydmVjX3B1c2goJmFyZ3MsICItLXNpZ25lZD15ZXMiKTsKCWVsc2UgaWYgKG9wdGlvbnMucHVzaF9jZXJ0ID09IFNFTkRfUEFDS19QVVNIX0NFUlRfSUZfQVNLRUQpCgkJc3RydmVjX3B1c2goJmFyZ3MsICItLXNpZ25lZD1pZi1hc2tlZCIpOwoJaWYgKG9wdGlvbnMuYXRvbWljKQoJCXN0cnZlY19wdXNoKCZhcmdzLCAiLS1hdG9taWMiKTsKCWlmIChvcHRpb25zLnZlcmJvc2l0eSA9PSAwKQoJCXN0cnZlY19wdXNoKCZhcmdzLCAiLS1xdWlldCIpOwoJZWxzZSBpZiAob3B0aW9ucy52ZXJib3NpdHkgPiAxKQoJCXN0cnZlY19wdXNoKCZhcmdzLCAiLS12ZXJib3NlIik7Cglmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5wdXNoX29wdGlvbnMubnI7IGkrKykKCQlzdHJ2ZWNfcHVzaGYoJmFyZ3MsICItLXB1c2gtb3B0aW9uPSVzIiwKCQkJICAgICBvcHRpb25zLnB1c2hfb3B0aW9ucy5pdGVtc1tpXS5zdHJpbmcpOwoJc3RydmVjX3B1c2goJmFyZ3MsIG9wdGlvbnMucHJvZ3Jlc3MgPyAiLS1wcm9ncmVzcyIgOiAiLS1uby1wcm9ncmVzcyIpOwoJZm9yX2VhY2hfc3RyaW5nX2xpc3RfaXRlbShjYXNfb3B0aW9uLCAmY2FzX29wdGlvbnMpCgkJc3RydmVjX3B1c2goJmFyZ3MsIGNhc19vcHRpb24tPnN0cmluZyk7CglzdHJ2ZWNfcHVzaCgmYXJncywgdXJsLmJ1Zik7CgoJaWYgKG9wdGlvbnMuZm9yY2VfaWZfaW5jbHVkZXMpCgkJc3RydmVjX3B1c2goJmFyZ3MsICItLWZvcmNlLWlmLWluY2x1ZGVzIik7CgoJc3RydmVjX3B1c2goJmFyZ3MsICItLXN0ZGluIik7Cglmb3IgKGkgPSAwOyBpIDwgbnJfc3BlYzsgaSsrKQoJCXBhY2tldF9idWZfd3JpdGUoJnByZWFtYmxlLCAiJXNcbiIsIHNwZWNzW2ldKTsKCXBhY2tldF9idWZfZmx1c2goJnByZWFtYmxlKTsKCgltZW1zZXQoJnJwYywgMCwgc2l6ZW9mKHJwYykpOwoJcnBjLnNlcnZpY2VfbmFtZSA9ICJnaXQtcmVjZWl2ZS1wYWNrIiwKCgllcnIgPSBycGNfc2VydmljZSgmcnBjLCBoZWFkcywgYXJncy52LCAmcHJlYW1ibGUsICZycGNfcmVzdWx0KTsKCWlmIChycGNfcmVzdWx0LmxlbikKCQl3cml0ZV9vcl9kaWUoMSwgcnBjX3Jlc3VsdC5idWYsIHJwY19yZXN1bHQubGVuKTsKCXN0cmJ1Zl9yZWxlYXNlKCZycGNfcmVzdWx0KTsKCXN0cmJ1Zl9yZWxlYXNlKCZwcmVhbWJsZSk7CglzdHJ2ZWNfY2xlYXIoJmFyZ3MpOwoJcmV0dXJuIGVycjsKfQoKc3RhdGljIGludCBwdXNoKGludCBucl9zcGVjLCBjb25zdCBjaGFyICoqc3BlY3MpCnsKCXN0cnVjdCBkaXNjb3ZlcnkgKmhlYWRzID0gZGlzY292ZXJfcmVmcygiZ2l0LXJlY2VpdmUtcGFjayIsIDEpOwoJaW50IHJldDsKCglpZiAoaGVhZHMtPnByb3RvX2dpdCkKCQlyZXQgPSBwdXNoX2dpdChoZWFkcywgbnJfc3BlYywgc3BlY3MpOwoJZWxzZQoJCXJldCA9IHB1c2hfZGF2KG5yX3NwZWMsIHNwZWNzKTsKCWZyZWVfZGlzY292ZXJ5KGhlYWRzKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyB2b2lkIHBhcnNlX3B1c2goc3RydWN0IHN0cmJ1ZiAqYnVmKQp7CglzdHJ1Y3Qgc3RydmVjIHNwZWNzID0gU1RSVkVDX0lOSVQ7CglpbnQgcmV0OwoKCWRvIHsKCQljb25zdCBjaGFyICphcmc7CgkJaWYgKHNraXBfcHJlZml4KGJ1Zi0+YnVmLCAicHVzaCAiLCAmYXJnKSkKCQkJc3RydmVjX3B1c2goJnNwZWNzLCBhcmcpOwoJCWVsc2UKCQkJZGllKF8oImh0dHAgdHJhbnNwb3J0IGRvZXMgbm90IHN1cHBvcnQgJXMiKSwgYnVmLT5idWYpOwoKCQlzdHJidWZfcmVzZXQoYnVmKTsKCQlpZiAoc3RyYnVmX2dldGxpbmVfbGYoYnVmLCBzdGRpbikgPT0gRU9GKQoJCQlnb3RvIGZyZWVfc3BlY3M7CgkJaWYgKCEqYnVmLT5idWYpCgkJCWJyZWFrOwoJfSB3aGlsZSAoMSk7CgoJcmV0ID0gcHVzaChzcGVjcy5uciwgc3BlY3Mudik7CglwcmludGYoIlxuIik7CglmZmx1c2goc3Rkb3V0KTsKCglpZiAocmV0KQoJCWV4aXQoMTI4KTsgLyogZXJyb3IgYWxyZWFkeSByZXBvcnRlZCAqLwoKZnJlZV9zcGVjczoKCXN0cnZlY19jbGVhcigmc3BlY3MpOwp9CgpzdGF0aWMgaW50IHN0YXRlbGVzc19jb25uZWN0KGNvbnN0IGNoYXIgKnNlcnZpY2VfbmFtZSkKewoJc3RydWN0IGRpc2NvdmVyeSAqZGlzY292ZXI7CglzdHJ1Y3QgcnBjX3N0YXRlIHJwYyA9IFJQQ19TVEFURV9JTklUOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKmFjY2VwdF9sYW5ndWFnZTsKCgkvKgoJICogUnVuIHRoZSBpbmZvL3JlZnMgcmVxdWVzdCBhbmQgc2VlIGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgcHJvdG9jb2wKCSAqIHYyLiAgSWYgYW5kIG9ubHkgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyB2MiBjYW4gd2Ugc3VjY2Vzc2Z1bGx5CgkgKiBlc3RhYmxpc2ggYSBzdGF0ZWxlc3MgY29ubmVjdGlvbiwgb3RoZXJ3aXNlIHdlIG5lZWQgdG8gdGVsbCB0aGUKCSAqIGNsaWVudCB0byBmYWxsYmFjayB0byB1c2luZyBvdGhlciB0cmFuc3BvcnQgaGVscGVyIGZ1bmN0aW9ucyB0bwoJICogY29tcGxldGUgdGhlaXIgcmVxdWVzdC4KCSAqCgkgKiBUaGUgImdpdC11cGxvYWQtYXJjaGl2ZSIgc2VydmljZSBpcyBhIHJlYWQtb25seSBvcGVyYXRpb24uIEZhbGxiYWNrCgkgKiB0byB1c2UgImdpdC11cGxvYWQtcGFjayIgc2VydmljZSB0byBkaXNjb3ZlciBwcm90b2NvbCB2ZXJzaW9uLgoJICovCglpZiAoIXN0cmNtcChzZXJ2aWNlX25hbWUsICJnaXQtdXBsb2FkLWFyY2hpdmUiKSkKCQlkaXNjb3ZlciA9IGRpc2NvdmVyX3JlZnMoImdpdC11cGxvYWQtcGFjayIsIDApOwoJZWxzZQoJCWRpc2NvdmVyID0gZGlzY292ZXJfcmVmcyhzZXJ2aWNlX25hbWUsIDApOwoJaWYgKGRpc2NvdmVyLT52ZXJzaW9uICE9IHByb3RvY29sX3YyKSB7CgkJcHJpbnRmKCJmYWxsYmFja1xuIik7CgkJZmZsdXNoKHN0ZG91dCk7CgkJcmV0dXJuIC0xOwoJfSBlbHNlIHsKCQkvKiBTdGF0ZWxlc3MgQ29ubmVjdGlvbiBlc3RhYmxpc2hlZCAqLwoJCXByaW50ZigiXG4iKTsKCQlmZmx1c2goc3Rkb3V0KTsKCX0KCWFjY2VwdF9sYW5ndWFnZSA9IGh0dHBfZ2V0X2FjY2VwdF9sYW5ndWFnZV9oZWFkZXIoKTsKCWlmIChhY2NlcHRfbGFuZ3VhZ2UpCgkJcnBjLmhkcl9hY2NlcHRfbGFuZ3VhZ2UgPSB4c3RyZm10KCIlcyIsIGFjY2VwdF9sYW5ndWFnZSk7CgoJcnBjLnNlcnZpY2VfbmFtZSA9IHNlcnZpY2VfbmFtZTsKCXJwYy5zZXJ2aWNlX3VybCA9IHhzdHJmbXQoIiVzJXMiLCB1cmwuYnVmLCBycGMuc2VydmljZV9uYW1lKTsKCXJwYy5oZHJfY29udGVudF90eXBlID0geHN0cmZtdCgiQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi94LSVzLXJlcXVlc3QiLCBycGMuc2VydmljZV9uYW1lKTsKCXJwYy5oZHJfYWNjZXB0ID0geHN0cmZtdCgiQWNjZXB0OiBhcHBsaWNhdGlvbi94LSVzLXJlc3VsdCIsIHJwYy5zZXJ2aWNlX25hbWUpOwoJaWYgKGdldF9wcm90b2NvbF9odHRwX2hlYWRlcihkaXNjb3Zlci0+dmVyc2lvbiwgJmJ1ZikpIHsKCQlycGMucHJvdG9jb2xfaGVhZGVyID0gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCX0gZWxzZSB7CgkJcnBjLnByb3RvY29sX2hlYWRlciA9IE5VTEw7CgkJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7Cgl9CglycGMuYnVmID0geG1hbGxvYyhodHRwX3Bvc3RfYnVmZmVyKTsKCXJwYy5hbGxvYyA9IGh0dHBfcG9zdF9idWZmZXI7CglycGMubGVuID0gMDsKCXJwYy5wb3MgPSAwOwoJcnBjLmluID0gMTsKCXJwYy5vdXQgPSAwOwoJcnBjLmFueV93cml0dGVuID0gMDsKCXJwYy5nemlwX3JlcXVlc3QgPSAxOwoJcnBjLmluaXRpYWxfYnVmZmVyID0gMDsKCXJwYy53cml0ZV9saW5lX2xlbmd0aHMgPSAxOwoJcnBjLmZsdXNoX3JlYWRfYnV0X25vdF9zZW50ID0gMDsKCgkvKgoJICogRHVtcCB0aGUgY2FwYWJpbGl0eSBsaXN0aW5nIHRoYXQgd2UgZ290IGZyb20gdGhlIHNlcnZlciBlYXJsaWVyCgkgKiBkdXJpbmcgdGhlIGluZm8vcmVmcyByZXF1ZXN0LiBUaGlzIGRvZXMgbm90IHdvcmsgd2l0aCB0aGUKCSAqICJnaXQtdXBsb2FkLWFyY2hpdmUiIHNlcnZpY2UuCgkgKi8KCWlmIChzdHJjbXAoc2VydmljZV9uYW1lLCAiZ2l0LXVwbG9hZC1hcmNoaXZlIikpCgkJd3JpdGVfb3JfZGllKHJwYy5pbiwgZGlzY292ZXItPmJ1ZiwgZGlzY292ZXItPmxlbik7CgoJLyogVW50aWwgd2Ugc2VlIEVPRiBrZWVwIHNlbmRpbmcgUE9TVHMgKi8KCXdoaWxlICgxKSB7CgkJc2l6ZV90IGF2YWlsOwoJCWVudW0gcGFja2V0X3JlYWRfc3RhdHVzIHN0YXR1czsKCgkJaWYgKCFycGNfcmVhZF9mcm9tX291dCgmcnBjLCBQQUNLRVRfUkVBRF9HRU5UTEVfT05fRU9GLCAmYXZhaWwsCgkJCQkgICAgICAgJnN0YXR1cykpCgkJCUJVRygiVGhlIGVudGlyZSBycGMtPmJ1ZiBzaG91bGQgYmUgbGFyZ2VyIHRoYW4gTEFSR0VfUEFDS0VUX01BWCIpOwoJCWlmIChzdGF0dXMgPT0gUEFDS0VUX1JFQURfRU9GKQoJCQlicmVhazsKCQlpZiAocG9zdF9ycGMoJnJwYywgMSwgc3RhdHVzID09IFBBQ0tFVF9SRUFEX0ZMVVNIKSkKCQkJLyogV2Ugd291bGQgaGF2ZSBhbiBlcnIgaGVyZSAqLwoJCQlicmVhazsKCQkvKiBSZXNldCB0aGUgYnVmZmVyIGZvciBuZXh0IHJlcXVlc3QgKi8KCQlycGMubGVuID0gMDsKCX0KCglmcmVlKHJwYy5zZXJ2aWNlX3VybCk7CglmcmVlKHJwYy5oZHJfY29udGVudF90eXBlKTsKCWZyZWUocnBjLmhkcl9hY2NlcHQpOwoJZnJlZShycGMuaGRyX2FjY2VwdF9sYW5ndWFnZSk7CglmcmVlKHJwYy5wcm90b2NvbF9oZWFkZXIpOwoJZnJlZShycGMuYnVmKTsKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoKCXJldHVybiAwOwp9CgppbnQgY21kX21haW4oaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2KQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaW50IG5vbmdpdDsKCWludCByZXQgPSAxOwoKCXNldHVwX2dpdF9kaXJlY3RvcnlfZ2VudGx5KCZub25naXQpOwoJaWYgKGFyZ2MgPCAyKSB7CgkJZXJyb3IoXygicmVtb3RlLWN1cmw6IHVzYWdlOiBnaXQgcmVtb3RlLWN1cmwgPHJlbW90ZT4gWzx1cmw+XSIpKTsKCQlnb3RvIGNsZWFudXA7Cgl9CgoJb3B0aW9ucy52ZXJib3NpdHkgPSAxOwoJb3B0aW9ucy5wcm9ncmVzcyA9ICEhaXNhdHR5KDIpOwoJb3B0aW9ucy50aGluID0gMTsKCXN0cmluZ19saXN0X2luaXRfZHVwKCZvcHRpb25zLmRlZXBlbl9ub3QpOwoJc3RyaW5nX2xpc3RfaW5pdF9kdXAoJm9wdGlvbnMucHVzaF9vcHRpb25zKTsKCgkvKgoJICogSnVzdCByZXBvcnQgInJlbW90ZS1jdXJsIiBoZXJlIChmb2xkaW5nIGFsbCB0aGUgdmFyaW91cyBhbGlhc2VzCgkgKiAoImdpdC1yZW1vdGUtaHR0cCIsICJnaXQtcmVtb3RlLWh0dHBzIiwgYW5kIGV0Yy4pIGhlcmUgc2luY2UgdGhleQoJICogYXJlIGFsbCBqdXN0IGNvcGllcyBvZiB0aGUgc2FtZSBhY3R1YWwgZXhlY3V0YWJsZS4KCSAqLwoJdHJhY2UyX2NtZF9uYW1lKCJyZW1vdGUtY3VybCIpOwoKCXJlbW90ZSA9IHJlbW90ZV9nZXQoYXJndlsxXSk7CgoJaWYgKGFyZ2MgPiAyKSB7CgkJZW5kX3VybF93aXRoX3NsYXNoKCZ1cmwsIGFyZ3ZbMl0pOwoJfSBlbHNlIHsKCQllbmRfdXJsX3dpdGhfc2xhc2goJnVybCwgcmVtb3RlLT51cmxbMF0pOwoJfQoKCWh0dHBfaW5pdChyZW1vdGUsIHVybC5idWYsIDApOwoKCWRvIHsKCQljb25zdCBjaGFyICphcmc7CgoJCWlmIChzdHJidWZfZ2V0bGluZV9sZigmYnVmLCBzdGRpbikgPT0gRU9GKSB7CgkJCWlmIChmZXJyb3Ioc3RkaW4pKQoJCQkJZXJyb3IoXygicmVtb3RlLWN1cmw6IGVycm9yIHJlYWRpbmcgY29tbWFuZCBzdHJlYW0gZnJvbSBnaXQiKSk7CgkJCWdvdG8gY2xlYW51cDsKCQl9CgkJaWYgKGJ1Zi5sZW4gPT0gMCkKCQkJYnJlYWs7CgkJaWYgKHN0YXJ0c193aXRoKGJ1Zi5idWYsICJmZXRjaCAiKSkgewoJCQlpZiAobm9uZ2l0KSB7CgkJCQlzZXR1cF9naXRfZGlyZWN0b3J5X2dlbnRseSgmbm9uZ2l0KTsKCQkJCWlmIChub25naXQpCgkJCQkJZGllKF8oInJlbW90ZS1jdXJsOiBmZXRjaCBhdHRlbXB0ZWQgd2l0aG91dCBhIGxvY2FsIHJlcG8iKSk7CgkJCX0KCQkJcGFyc2VfZmV0Y2goJmJ1Zik7CgoJCX0gZWxzZSBpZiAoIXN0cmNtcChidWYuYnVmLCAibGlzdCIpIHx8IHN0YXJ0c193aXRoKGJ1Zi5idWYsICJsaXN0ICIpKSB7CgkJCWludCBmb3JfcHVzaCA9ICEhc3Ryc3RyKGJ1Zi5idWYgKyA0LCAiZm9yLXB1c2giKTsKCQkJb3V0cHV0X3JlZnMoZ2V0X3JlZnMoZm9yX3B1c2gpKTsKCgkJfSBlbHNlIGlmIChzdGFydHNfd2l0aChidWYuYnVmLCAicHVzaCAiKSkgewoJCQlwYXJzZV9wdXNoKCZidWYpOwoKCQl9IGVsc2UgaWYgKHNraXBfcHJlZml4KGJ1Zi5idWYsICJvcHRpb24gIiwgJmFyZykpIHsKCQkJY2hhciAqdmFsdWUgPSBzdHJjaHIoYXJnLCAnICcpOwoJCQlpbnQgcmVzdWx0OwoKCQkJaWYgKHZhbHVlKQoJCQkJKnZhbHVlKysgPSAnXDAnOwoJCQllbHNlCgkJCQl2YWx1ZSA9ICJ0cnVlIjsKCgkJCXJlc3VsdCA9IHNldF9vcHRpb24oYXJnLCB2YWx1ZSk7CgkJCWlmICghcmVzdWx0KQoJCQkJcHJpbnRmKCJva1xuIik7CgkJCWVsc2UgaWYgKHJlc3VsdCA8IDApCgkJCQlwcmludGYoImVycm9yIGludmFsaWQgdmFsdWVcbiIpOwoJCQllbHNlCgkJCQlwcmludGYoInVuc3VwcG9ydGVkXG4iKTsKCQkJZmZsdXNoKHN0ZG91dCk7CgoJCX0gZWxzZSBpZiAoc2tpcF9wcmVmaXgoYnVmLmJ1ZiwgImdldCAiLCAmYXJnKSkgewoJCQlwYXJzZV9nZXQoYXJnKTsKCQkJZmZsdXNoKHN0ZG91dCk7CgoJCX0gZWxzZSBpZiAoIXN0cmNtcChidWYuYnVmLCAiY2FwYWJpbGl0aWVzIikpIHsKCQkJcHJpbnRmKCJzdGF0ZWxlc3MtY29ubmVjdFxuIik7CgkJCXByaW50ZigiZmV0Y2hcbiIpOwoJCQlwcmludGYoImdldFxuIik7CgkJCXByaW50Zigib3B0aW9uXG4iKTsKCQkJcHJpbnRmKCJwdXNoXG4iKTsKCQkJcHJpbnRmKCJjaGVjay1jb25uZWN0aXZpdHlcbiIpOwoJCQlwcmludGYoIm9iamVjdC1mb3JtYXRcbiIpOwoJCQlwcmludGYoIlxuIik7CgkJCWZmbHVzaChzdGRvdXQpOwoJCX0gZWxzZSBpZiAoc2tpcF9wcmVmaXgoYnVmLmJ1ZiwgInN0YXRlbGVzcy1jb25uZWN0ICIsICZhcmcpKSB7CgkJCWlmICghc3RhdGVsZXNzX2Nvbm5lY3QoYXJnKSkKCQkJCWJyZWFrOwoJCX0gZWxzZSB7CgkJCWVycm9yKF8oInJlbW90ZS1jdXJsOiB1bmtub3duIGNvbW1hbmQgJyVzJyBmcm9tIGdpdCIpLCBidWYuYnVmKTsKCQkJZ290byBjbGVhbnVwOwoJCX0KCQlzdHJidWZfcmVzZXQoJmJ1Zik7Cgl9IHdoaWxlICgxKTsKCglodHRwX2NsZWFudXAoKTsKCXJldCA9IDA7CmNsZWFudXA6CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCglyZXR1cm4gcmV0Owp9Cg==",
    "text": "#include \"git-compat-util.h\"\n#include \"git-curl-compat.h\"\n#include \"config.h\"\n#include \"environment.h\"\n#include \"gettext.h\"\n#include \"hex.h\"\n#include \"remote.h\"\n#include \"connect.h\"\n#include \"strbuf.h\"\n#include \"walker.h\"\n#include \"http.h\"\n#include \"run-command.h\"\n#include \"pkt-line.h\"\n#include \"string-list.h\"\n#include \"strvec.h\"\n#include \"credential.h\"\n#include \"oid-array.h\"\n#include \"send-pack.h\"\n#include \"setup.h\"\n#include \"protocol.h\"\n#include \"quote.h\"\n#include \"trace2.h\"\n#include \"transport.h\"\n#include \"url.h\"\n#include \"write-or-die.h\"\n\nstatic struct remote *remote;\n/* always ends with a trailing slash */\nstatic struct strbuf url = STRBUF_INIT;\n\nstruct options {\n\tint verbosity;\n\tunsigned long depth;\n\tchar *deepen_since;\n\tstruct string_list deepen_not;\n\tstruct string_list push_options;\n\tchar *filter;\n\tunsigned progress : 1,\n\t\tcheck_self_contained_and_connected : 1,\n\t\tcloning : 1,\n\t\tupdate_shallow : 1,\n\t\tfollowtags : 1,\n\t\tdry_run : 1,\n\t\tthin : 1,\n\t\t/* One of the SEND_PACK_PUSH_CERT_* constants. */\n\t\tpush_cert : 2,\n\t\tdeepen_relative : 1,\n\n\t\t/* see documentation of corresponding flag in fetch-pack.h */\n\t\tfrom_promisor : 1,\n\n\t\trefetch : 1,\n\t\tatomic : 1,\n\t\tobject_format : 1,\n\t\tforce_if_includes : 1;\n\tconst struct git_hash_algo *hash_algo;\n};\nstatic struct options options;\nstatic struct string_list cas_options = STRING_LIST_INIT_DUP;\n\nstatic int set_option(const char *name, const char *value)\n{\n\tif (!strcmp(name, \"verbosity\")) {\n\t\tchar *end;\n\t\tint v = strtol(value, &end, 10);\n\t\tif (value == end || *end)\n\t\t\treturn -1;\n\t\toptions.verbosity = v;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"progress\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.progress = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.progress = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"depth\")) {\n\t\tchar *end;\n\t\tunsigned long v = strtoul(value, &end, 10);\n\t\tif (value == end || *end)\n\t\t\treturn -1;\n\t\toptions.depth = v;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"deepen-since\")) {\n\t\toptions.deepen_since = xstrdup(value);\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"deepen-not\")) {\n\t\tstring_list_append(&options.deepen_not, value);\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"deepen-relative\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.deepen_relative = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.deepen_relative = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"followtags\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.followtags = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.followtags = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"dry-run\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.dry_run = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.dry_run = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"check-connectivity\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.check_self_contained_and_connected = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.check_self_contained_and_connected = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"cas\")) {\n\t\tstruct strbuf val = STRBUF_INIT;\n\t\tstrbuf_addstr(&val, \"--force-with-lease=\");\n\t\tif (*value != '\"')\n\t\t\tstrbuf_addstr(&val, value);\n\t\telse if (unquote_c_style(&val, value, NULL))\n\t\t\treturn -1;\n\t\tstring_list_append(&cas_options, val.buf);\n\t\tstrbuf_release(&val);\n\t\treturn 0;\n\t} else if (!strcmp(name, TRANS_OPT_FORCE_IF_INCLUDES)) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.force_if_includes = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.force_if_includes = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"cloning\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.cloning = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.cloning = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"update-shallow\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.update_shallow = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.update_shallow = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"pushcert\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.push_cert = SEND_PACK_PUSH_CERT_ALWAYS;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.push_cert = SEND_PACK_PUSH_CERT_NEVER;\n\t\telse if (!strcmp(value, \"if-asked\"))\n\t\t\toptions.push_cert = SEND_PACK_PUSH_CERT_IF_ASKED;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"atomic\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.atomic = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.atomic = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"push-option\")) {\n\t\tif (*value != '\"')\n\t\t\tstring_list_append(&options.push_options, value);\n\t\telse {\n\t\t\tstruct strbuf unquoted = STRBUF_INIT;\n\t\t\tif (unquote_c_style(&unquoted, value, NULL) < 0)\n\t\t\t\tdie(_(\"invalid quoting in push-option value: '%s'\"), value);\n\t\t\tstring_list_append_nodup(&options.push_options,\n\t\t\t\t\t\t strbuf_detach(&unquoted, NULL));\n\t\t}\n\t\treturn 0;\n\t} else if (!strcmp(name, \"family\")) {\n\t\tif (!strcmp(value, \"ipv4\"))\n\t\t\tgit_curl_ipresolve = CURL_IPRESOLVE_V4;\n\t\telse if (!strcmp(value, \"ipv6\"))\n\t\t\tgit_curl_ipresolve = CURL_IPRESOLVE_V6;\n\t\telse if (!strcmp(value, \"all\"))\n\t\t\tgit_curl_ipresolve = CURL_IPRESOLVE_WHATEVER;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"from-promisor\")) {\n\t\toptions.from_promisor = 1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"refetch\")) {\n\t\toptions.refetch = 1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"filter\")) {\n\t\toptions.filter = xstrdup(value);\n\t\treturn 0;\n\t} else if (!strcmp(name, \"object-format\")) {\n\t\toptions.object_format = 1;\n\t\tif (strcmp(value, \"true\"))\n\t\t\tdie(_(\"unknown value for object-format: %s\"), value);\n\t\treturn 0;\n\t} else {\n\t\treturn 1 /* unsupported */;\n\t}\n}\n\nstruct discovery {\n\tchar *service;\n\tchar *buf_alloc;\n\tchar *buf;\n\tsize_t len;\n\tstruct ref *refs;\n\tstruct oid_array shallow;\n\tenum protocol_version version;\n\tunsigned proto_git : 1;\n};\nstatic struct discovery *last_discovery;\n\nstatic struct ref *parse_git_refs(struct discovery *heads, int for_push)\n{\n\tstruct ref *list = NULL;\n\tstruct packet_reader reader;\n\n\tpacket_reader_init(&reader, -1, heads->buf, heads->len,\n\t\t\t   PACKET_READ_CHOMP_NEWLINE |\n\t\t\t   PACKET_READ_GENTLE_ON_EOF |\n\t\t\t   PACKET_READ_DIE_ON_ERR_PACKET);\n\n\theads->version = discover_version(&reader);\n\tswitch (heads->version) {\n\tcase protocol_v2:\n\t\t/*\n\t\t * Do nothing.  This isn't a list of refs but rather a\n\t\t * capability advertisement.  Client would have run\n\t\t * 'stateless-connect' so we'll dump this capability listing\n\t\t * and let them request the refs themselves.\n\t\t */\n\t\tbreak;\n\tcase protocol_v1:\n\tcase protocol_v0:\n\t\tget_remote_heads(&reader, &list, for_push ? REF_NORMAL : 0,\n\t\t\t\t NULL, &heads->shallow);\n\t\toptions.hash_algo = reader.hash_algo;\n\t\tbreak;\n\tcase protocol_unknown_version:\n\t\tBUG(\"unknown protocol version\");\n\t}\n\n\treturn list;\n}\n\n/*\n * Try to detect the hash algorithm used by the remote repository when using\n * the dumb HTTP transport. As dumb transports cannot tell us the object hash\n * directly have to derive it from the advertised ref lengths.\n */\nstatic const struct git_hash_algo *detect_hash_algo(struct discovery *heads)\n{\n\tconst char *p = memchr(heads->buf, '\\t', heads->len);\n\tint algo;\n\n\t/*\n\t * In case the remote has no refs we have no way to reliably determine\n\t * the object hash used by that repository. In that case we simply fall\n\t * back to SHA1, which may or may not be correct.\n\t */\n\tif (!p)\n\t\treturn &hash_algos[GIT_HASH_SHA1];\n\n\talgo = hash_algo_by_length((p - heads->buf) / 2);\n\tif (algo == GIT_HASH_UNKNOWN)\n\t\treturn NULL;\n\treturn &hash_algos[algo];\n}\n\nstatic struct ref *parse_info_refs(struct discovery *heads)\n{\n\tchar *data, *start, *mid;\n\tchar *ref_name;\n\tint i = 0;\n\n\tstruct ref *refs = NULL;\n\tstruct ref *ref = NULL;\n\tstruct ref *last_ref = NULL;\n\n\toptions.hash_algo = detect_hash_algo(heads);\n\tif (!options.hash_algo)\n\t\tdie(\"%sinfo/refs not valid: could not determine hash algorithm; \"\n\t\t    \"is this a git repository?\",\n\t\t    transport_anonymize_url(url.buf));\n\n\t/*\n\t * Set the repository's hash algo to whatever we have just detected.\n\t * This ensures that we can correctly parse the remote references.\n\t */\n\trepo_set_hash_algo(the_repository, hash_algo_by_ptr(options.hash_algo));\n\n\tdata = heads->buf;\n\tstart = NULL;\n\tmid = data;\n\twhile (i < heads->len) {\n\t\tif (!start) {\n\t\t\tstart = &data[i];\n\t\t}\n\t\tif (data[i] == '\\t')\n\t\t\tmid = &data[i];\n\t\tif (data[i] == '\\n') {\n\t\t\tif (mid - start != options.hash_algo->hexsz)\n\t\t\t\tdie(_(\"%sinfo/refs not valid: is this a git repository?\"),\n\t\t\t\t    transport_anonymize_url(url.buf));\n\t\t\tdata[i] = 0;\n\t\t\tref_name = mid + 1;\n\t\t\tref = alloc_ref(ref_name);\n\t\t\tget_oid_hex_algop(start, &ref->old_oid, options.hash_algo);\n\t\t\tif (!refs)\n\t\t\t\trefs = ref;\n\t\t\tif (last_ref)\n\t\t\t\tlast_ref->next = ref;\n\t\t\tlast_ref = ref;\n\t\t\tstart = NULL;\n\t\t}\n\t\ti++;\n\t}\n\n\tref = alloc_ref(\"HEAD\");\n\tif (!http_fetch_ref(url.buf, ref) &&\n\t    !resolve_remote_symref(ref, refs)) {\n\t\tref->next = refs;\n\t\trefs = ref;\n\t} else {\n\t\tfree(ref);\n\t}\n\n\treturn refs;\n}\n\nstatic void free_discovery(struct discovery *d)\n{\n\tif (d) {\n\t\tif (d == last_discovery)\n\t\t\tlast_discovery = NULL;\n\t\tfree(d->shallow.oid);\n\t\tfree(d->buf_alloc);\n\t\tfree_refs(d->refs);\n\t\tfree(d->service);\n\t\tfree(d);\n\t}\n}\n\nstatic int show_http_message(struct strbuf *type, struct strbuf *charset,\n\t\t\t     struct strbuf *msg)\n{\n\tconst char *p, *eol;\n\n\t/*\n\t * We only show text/plain parts, as other types are likely\n\t * to be ugly to look at on the user's terminal.\n\t */\n\tif (strcmp(type->buf, \"text/plain\"))\n\t\treturn -1;\n\tif (charset->len)\n\t\tstrbuf_reencode(msg, charset->buf, get_log_output_encoding());\n\n\tstrbuf_trim(msg);\n\tif (!msg->len)\n\t\treturn -1;\n\n\tp = msg->buf;\n\tdo {\n\t\teol = strchrnul(p, '\\n');\n\t\tfprintf(stderr, \"remote: %.*s\\n\", (int)(eol - p), p);\n\t\tp = eol + 1;\n\t} while(*eol);\n\treturn 0;\n}\n\nstatic int get_protocol_http_header(enum protocol_version version,\n\t\t\t\t    struct strbuf *header)\n{\n\tif (version > 0) {\n\t\tstrbuf_addf(header, GIT_PROTOCOL_HEADER \": version=%d\",\n\t\t\t    version);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void check_smart_http(struct discovery *d, const char *service,\n\t\t\t     struct strbuf *type)\n{\n\tconst char *p;\n\tstruct packet_reader reader;\n\n\t/*\n\t * If we don't see x-$service-advertisement, then it's not smart-http.\n\t * But once we do, we commit to it and assume any other protocol\n\t * violations are hard errors.\n\t */\n\tif (!skip_prefix(type->buf, \"application/x-\", &p) ||\n\t    !skip_prefix(p, service, &p) ||\n\t    strcmp(p, \"-advertisement\"))\n\t\treturn;\n\n\tpacket_reader_init(&reader, -1, d->buf, d->len,\n\t\t\t   PACKET_READ_CHOMP_NEWLINE |\n\t\t\t   PACKET_READ_DIE_ON_ERR_PACKET);\n\tif (packet_reader_read(&reader) != PACKET_READ_NORMAL)\n\t\tdie(_(\"invalid server response; expected service, got flush packet\"));\n\n\tif (skip_prefix(reader.line, \"# service=\", &p) && !strcmp(p, service)) {\n\t\t/*\n\t\t * The header can include additional metadata lines, up\n\t\t * until a packet flush marker.  Ignore these now, but\n\t\t * in the future we might start to scan them.\n\t\t */\n\t\tfor (;;) {\n\t\t\tpacket_reader_read(&reader);\n\t\t\tif (reader.pktlen <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * v0 smart http; callers expect us to soak up the\n\t\t * service and header packets\n\t\t */\n\t\td->buf = reader.src_buffer;\n\t\td->len = reader.src_len;\n\t\td->proto_git = 1;\n\n\t} else if (!strcmp(reader.line, \"version 2\")) {\n\t\t/*\n\t\t * v2 smart http; do not consume version packet, which will\n\t\t * be handled elsewhere.\n\t\t */\n\t\td->proto_git = 1;\n\n\t} else {\n\t\tdie(_(\"invalid server response; got '%s'\"), reader.line);\n\t}\n}\n\nstatic struct discovery *discover_refs(const char *service, int for_push)\n{\n\tstruct strbuf type = STRBUF_INIT;\n\tstruct strbuf charset = STRBUF_INIT;\n\tstruct strbuf buffer = STRBUF_INIT;\n\tstruct strbuf refs_url = STRBUF_INIT;\n\tstruct strbuf effective_url = STRBUF_INIT;\n\tstruct strbuf protocol_header = STRBUF_INIT;\n\tstruct string_list extra_headers = STRING_LIST_INIT_DUP;\n\tstruct discovery *last = last_discovery;\n\tint http_ret, maybe_smart = 0;\n\tstruct http_get_options http_options;\n\tenum protocol_version version = get_protocol_version_config();\n\n\tif (last && !strcmp(service, last->service))\n\t\treturn last;\n\tfree_discovery(last);\n\n\tstrbuf_addf(&refs_url, \"%sinfo/refs\", url.buf);\n\tif ((starts_with(url.buf, \"http://\") || starts_with(url.buf, \"https://\")) &&\n\t     git_env_bool(\"GIT_SMART_HTTP\", 1)) {\n\t\tmaybe_smart = 1;\n\t\tif (!strchr(url.buf, '?'))\n\t\t\tstrbuf_addch(&refs_url, '?');\n\t\telse\n\t\t\tstrbuf_addch(&refs_url, '&');\n\t\tstrbuf_addf(&refs_url, \"service=%s\", service);\n\t}\n\n\t/*\n\t * NEEDSWORK: If we are trying to use protocol v2 and we are planning\n\t * to perform any operation that doesn't involve upload-pack (i.e., a\n\t * fetch, ls-remote, etc), then fallback to v0 since we don't know how\n\t * to do anything else (like push or remote archive) via v2.\n\t */\n\tif (version == protocol_v2 && strcmp(\"git-upload-pack\", service))\n\t\tversion = protocol_v0;\n\n\t/* Add the extra Git-Protocol header */\n\tif (get_protocol_http_header(version, &protocol_header))\n\t\tstring_list_append(&extra_headers, protocol_header.buf);\n\n\tmemset(&http_options, 0, sizeof(http_options));\n\thttp_options.content_type = &type;\n\thttp_options.charset = &charset;\n\thttp_options.effective_url = &effective_url;\n\thttp_options.base_url = &url;\n\thttp_options.extra_headers = &extra_headers;\n\thttp_options.initial_request = 1;\n\thttp_options.no_cache = 1;\n\n\thttp_ret = http_get_strbuf(refs_url.buf, &buffer, &http_options);\n\tswitch (http_ret) {\n\tcase HTTP_OK:\n\t\tbreak;\n\tcase HTTP_MISSING_TARGET:\n\t\tshow_http_message(&type, &charset, &buffer);\n\t\tdie(_(\"repository '%s' not found\"),\n\t\t    transport_anonymize_url(url.buf));\n\tcase HTTP_NOAUTH:\n\t\tshow_http_message(&type, &charset, &buffer);\n\t\tdie(_(\"Authentication failed for '%s'\"),\n\t\t    transport_anonymize_url(url.buf));\n\tcase HTTP_NOMATCHPUBLICKEY:\n\t\tshow_http_message(&type, &charset, &buffer);\n\t\tdie(_(\"unable to access '%s' with http.pinnedPubkey configuration: %s\"),\n\t\t    transport_anonymize_url(url.buf), curl_errorstr);\n\tdefault:\n\t\tshow_http_message(&type, &charset, &buffer);\n\t\tdie(_(\"unable to access '%s': %s\"),\n\t\t    transport_anonymize_url(url.buf), curl_errorstr);\n\t}\n\n\tif (options.verbosity && !starts_with(refs_url.buf, url.buf)) {\n\t\tchar *u = transport_anonymize_url(url.buf);\n\t\twarning(_(\"redirecting to %s\"), u);\n\t\tfree(u);\n\t}\n\n\tlast= xcalloc(1, sizeof(*last_discovery));\n\tlast->service = xstrdup(service);\n\tlast->buf_alloc = strbuf_detach(&buffer, &last->len);\n\tlast->buf = last->buf_alloc;\n\n\tif (maybe_smart)\n\t\tcheck_smart_http(last, service, &type);\n\n\tif (last->proto_git)\n\t\tlast->refs = parse_git_refs(last, for_push);\n\telse\n\t\tlast->refs = parse_info_refs(last);\n\n\tstrbuf_release(&refs_url);\n\tstrbuf_release(&type);\n\tstrbuf_release(&charset);\n\tstrbuf_release(&effective_url);\n\tstrbuf_release(&buffer);\n\tstrbuf_release(&protocol_header);\n\tstring_list_clear(&extra_headers, 0);\n\tlast_discovery = last;\n\treturn last;\n}\n\nstatic struct ref *get_refs(int for_push)\n{\n\tstruct discovery *heads;\n\n\tif (for_push)\n\t\theads = discover_refs(\"git-receive-pack\", for_push);\n\telse\n\t\theads = discover_refs(\"git-upload-pack\", for_push);\n\n\treturn heads->refs;\n}\n\nstatic void output_refs(struct ref *refs)\n{\n\tstruct ref *posn;\n\tif (options.object_format && options.hash_algo) {\n\t\tprintf(\":object-format %s\\n\", options.hash_algo->name);\n\t\trepo_set_hash_algo(the_repository,\n\t\t\t\thash_algo_by_ptr(options.hash_algo));\n\t}\n\tfor (posn = refs; posn; posn = posn->next) {\n\t\tif (posn->symref)\n\t\t\tprintf(\"@%s %s\\n\", posn->symref, posn->name);\n\t\telse\n\t\t\tprintf(\"%s %s\\n\", hash_to_hex_algop(posn->old_oid.hash,\n\t\t\t\t\t\t\t    options.hash_algo),\n\t\t\t\t\t  posn->name);\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);\n}\n\nstruct rpc_state {\n\tconst char *service_name;\n\tchar *service_url;\n\tchar *hdr_content_type;\n\tchar *hdr_accept;\n\tchar *hdr_accept_language;\n\tchar *protocol_header;\n\tchar *buf;\n\tsize_t alloc;\n\tsize_t len;\n\tsize_t pos;\n\tint in;\n\tint out;\n\tint any_written;\n\tunsigned gzip_request : 1;\n\tunsigned initial_buffer : 1;\n\n\t/*\n\t * Whenever a pkt-line is read into buf, append the 4 characters\n\t * denoting its length before appending the payload.\n\t */\n\tunsigned write_line_lengths : 1;\n\n\t/*\n\t * Used by rpc_out; initialize to 0. This is true if a flush has been\n\t * read, but the corresponding line length (if write_line_lengths is\n\t * true) and EOF have not been sent to libcurl. Since each flush marks\n\t * the end of a request, each flush must be completely sent before any\n\t * further reading occurs.\n\t */\n\tunsigned flush_read_but_not_sent : 1;\n};\n\n#define RPC_STATE_INIT { 0 }\n\n/*\n * Appends the result of reading from rpc->out to the string represented by\n * rpc->buf and rpc->len if there is enough space. Returns 1 if there was\n * enough space, 0 otherwise.\n *\n * If rpc->write_line_lengths is true, appends the line length as a 4-byte\n * hexadecimal string before appending the result described above.\n *\n * Writes the total number of bytes appended into appended.\n */\nstatic int rpc_read_from_out(struct rpc_state *rpc, int options,\n\t\t\t     size_t *appended,\n\t\t\t     enum packet_read_status *status) {\n\tsize_t left;\n\tchar *buf;\n\tint pktlen_raw;\n\n\tif (rpc->write_line_lengths) {\n\t\tleft = rpc->alloc - rpc->len - 4;\n\t\tbuf = rpc->buf + rpc->len + 4;\n\t} else {\n\t\tleft = rpc->alloc - rpc->len;\n\t\tbuf = rpc->buf + rpc->len;\n\t}\n\n\tif (left < LARGE_PACKET_MAX)\n\t\treturn 0;\n\n\t*status = packet_read_with_status(rpc->out, NULL, NULL, buf,\n\t\t\tleft, &pktlen_raw, options);\n\tif (*status != PACKET_READ_EOF) {\n\t\t*appended = pktlen_raw + (rpc->write_line_lengths ? 4 : 0);\n\t\trpc->len += *appended;\n\t}\n\n\tif (rpc->write_line_lengths) {\n\t\tswitch (*status) {\n\t\tcase PACKET_READ_EOF:\n\t\t\tif (!(options & PACKET_READ_GENTLE_ON_EOF))\n\t\t\t\tdie(_(\"shouldn't have EOF when not gentle on EOF\"));\n\t\t\tbreak;\n\t\tcase PACKET_READ_NORMAL:\n\t\t\tset_packet_header(buf - 4, *appended);\n\t\t\tbreak;\n\t\tcase PACKET_READ_DELIM:\n\t\t\tmemcpy(buf - 4, \"0001\", 4);\n\t\t\tbreak;\n\t\tcase PACKET_READ_FLUSH:\n\t\t\tmemcpy(buf - 4, \"0000\", 4);\n\t\t\tbreak;\n\t\tcase PACKET_READ_RESPONSE_END:\n\t\t\tdie(_(\"remote server sent unexpected response end packet\"));\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic size_t rpc_out(void *ptr, size_t eltsize,\n\t\tsize_t nmemb, void *buffer_)\n{\n\tsize_t max = eltsize * nmemb;\n\tstruct rpc_state *rpc = buffer_;\n\tsize_t avail = rpc->len - rpc->pos;\n\tenum packet_read_status status;\n\n\tif (!avail) {\n\t\trpc->initial_buffer = 0;\n\t\trpc->len = 0;\n\t\trpc->pos = 0;\n\t\tif (!rpc->flush_read_but_not_sent) {\n\t\t\tif (!rpc_read_from_out(rpc, 0, &avail, &status))\n\t\t\t\tBUG(\"The entire rpc->buf should be larger than LARGE_PACKET_MAX\");\n\t\t\tif (status == PACKET_READ_FLUSH)\n\t\t\t\trpc->flush_read_but_not_sent = 1;\n\t\t}\n\t\t/*\n\t\t * If flush_read_but_not_sent is true, we have already read one\n\t\t * full request but have not fully sent it + EOF, which is why\n\t\t * we need to refrain from reading.\n\t\t */\n\t}\n\tif (rpc->flush_read_but_not_sent) {\n\t\tif (!avail) {\n\t\t\t/*\n\t\t\t * The line length either does not need to be sent at\n\t\t\t * all or has already been completely sent. Now we can\n\t\t\t * return 0, indicating EOF, meaning that the flush has\n\t\t\t * been fully sent.\n\t\t\t */\n\t\t\trpc->flush_read_but_not_sent = 0;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * If avail is non-zero, the line length for the flush still\n\t\t * hasn't been fully sent. Proceed with sending the line\n\t\t * length.\n\t\t */\n\t}\n\n\tif (max < avail)\n\t\tavail = max;\n\tmemcpy(ptr, rpc->buf + rpc->pos, avail);\n\trpc->pos += avail;\n\treturn avail;\n}\n\nstatic int rpc_seek(void *clientp, curl_off_t offset, int origin)\n{\n\tstruct rpc_state *rpc = clientp;\n\n\tif (origin != SEEK_SET)\n\t\tBUG(\"rpc_seek only handles SEEK_SET, not %d\", origin);\n\n\tif (rpc->initial_buffer) {\n\t\tif (offset < 0 || offset > rpc->len) {\n\t\t\terror(\"curl seek would be outside of rpc buffer\");\n\t\t\treturn CURL_SEEKFUNC_FAIL;\n\t\t}\n\t\trpc->pos = offset;\n\t\treturn CURL_SEEKFUNC_OK;\n\t}\n\terror(_(\"unable to rewind rpc post data - try increasing http.postBuffer\"));\n\treturn CURL_SEEKFUNC_FAIL;\n}\n\nstruct check_pktline_state {\n\tchar len_buf[4];\n\tint len_filled;\n\tint remaining;\n};\n\nstatic void check_pktline(struct check_pktline_state *state, const char *ptr, size_t size)\n{\n\twhile (size) {\n\t\tif (!state->remaining) {\n\t\t\tint digits_remaining = 4 - state->len_filled;\n\t\t\tif (digits_remaining > size)\n\t\t\t\tdigits_remaining = size;\n\t\t\tmemcpy(&state->len_buf[state->len_filled], ptr, digits_remaining);\n\t\t\tstate->len_filled += digits_remaining;\n\t\t\tptr += digits_remaining;\n\t\t\tsize -= digits_remaining;\n\n\t\t\tif (state->len_filled == 4) {\n\t\t\t\tstate->remaining = packet_length(state->len_buf,\n\t\t\t\t\t\t\t\t sizeof(state->len_buf));\n\t\t\t\tif (state->remaining < 0) {\n\t\t\t\t\tdie(_(\"remote-curl: bad line length character: %.4s\"), state->len_buf);\n\t\t\t\t} else if (state->remaining == 2) {\n\t\t\t\t\tdie(_(\"remote-curl: unexpected response end packet\"));\n\t\t\t\t} else if (state->remaining < 4) {\n\t\t\t\t\tstate->remaining = 0;\n\t\t\t\t} else {\n\t\t\t\t\tstate->remaining -= 4;\n\t\t\t\t}\n\t\t\t\tstate->len_filled = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (state->remaining) {\n\t\t\tint remaining = state->remaining;\n\t\t\tif (remaining > size)\n\t\t\t\tremaining = size;\n\t\t\tptr += remaining;\n\t\t\tsize -= remaining;\n\t\t\tstate->remaining -= remaining;\n\t\t}\n\t}\n}\n\nstruct rpc_in_data {\n\tstruct rpc_state *rpc;\n\tstruct active_request_slot *slot;\n\tint check_pktline;\n\tstruct check_pktline_state pktline_state;\n};\n\n/*\n * A callback for CURLOPT_WRITEFUNCTION. The return value is the bytes consumed\n * from ptr.\n */\nstatic size_t rpc_in(char *ptr, size_t eltsize,\n\t\tsize_t nmemb, void *buffer_)\n{\n\tsize_t size = eltsize * nmemb;\n\tstruct rpc_in_data *data = buffer_;\n\tlong response_code;\n\n\tif (curl_easy_getinfo(data->slot->curl, CURLINFO_RESPONSE_CODE,\n\t\t\t      &response_code) != CURLE_OK)\n\t\treturn size;\n\tif (response_code >= 300)\n\t\treturn size;\n\tif (size)\n\t\tdata->rpc->any_written = 1;\n\tif (data->check_pktline)\n\t\tcheck_pktline(&data->pktline_state, ptr, size);\n\twrite_or_die(data->rpc->in, ptr, size);\n\treturn size;\n}\n\nstatic int run_slot(struct active_request_slot *slot,\n\t\t    struct slot_results *results)\n{\n\tint err;\n\tstruct slot_results results_buf;\n\n\tif (!results)\n\t\tresults = &results_buf;\n\n\terr = run_one_slot(slot, results);\n\n\tif (err != HTTP_OK && err != HTTP_REAUTH) {\n\t\tstruct strbuf msg = STRBUF_INIT;\n\t\tif (results->http_code && results->http_code != 200)\n\t\t\tstrbuf_addf(&msg, \"HTTP %ld\", results->http_code);\n\t\tif (results->curl_result != CURLE_OK) {\n\t\t\tif (msg.len)\n\t\t\t\tstrbuf_addch(&msg, ' ');\n\t\t\tstrbuf_addf(&msg, \"curl %d\", results->curl_result);\n\t\t\tif (curl_errorstr[0]) {\n\t\t\t\tstrbuf_addch(&msg, ' ');\n\t\t\t\tstrbuf_addstr(&msg, curl_errorstr);\n\t\t\t}\n\t\t}\n\t\terror(_(\"RPC failed; %s\"), msg.buf);\n\t\tstrbuf_release(&msg);\n\t}\n\n\treturn err;\n}\n\nstatic int probe_rpc(struct rpc_state *rpc, struct slot_results *results)\n{\n\tstruct active_request_slot *slot;\n\tstruct curl_slist *headers = http_copy_default_headers();\n\tstruct strbuf buf = STRBUF_INIT;\n\tint err;\n\n\tslot = get_active_slot();\n\n\theaders = curl_slist_append(headers, rpc->hdr_content_type);\n\theaders = curl_slist_append(headers, rpc->hdr_accept);\n\n\tcurl_easy_setopt(slot->curl, CURLOPT_NOBODY, 0);\n\tcurl_easy_setopt(slot->curl, CURLOPT_POST, 1);\n\tcurl_easy_setopt(slot->curl, CURLOPT_URL, rpc->service_url);\n\tcurl_easy_setopt(slot->curl, CURLOPT_ENCODING, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, \"0000\");\n\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE, 4);\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, headers);\n\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION, fwrite_buffer);\n\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEDATA, &buf);\n\n\terr = run_slot(slot, results);\n\n\tcurl_slist_free_all(headers);\n\tstrbuf_release(&buf);\n\treturn err;\n}\n\nstatic curl_off_t xcurl_off_t(size_t len)\n{\n\tuintmax_t size = len;\n\tif (size > maximum_signed_value_of_type(curl_off_t))\n\t\tdie(_(\"cannot handle pushes this big\"));\n\treturn (curl_off_t)size;\n}\n\n/*\n * If flush_received is true, do not attempt to read any more; just use what's\n * in rpc->buf.\n */\nstatic int post_rpc(struct rpc_state *rpc, int stateless_connect, int flush_received)\n{\n\tstruct active_request_slot *slot;\n\tstruct curl_slist *headers = http_copy_default_headers();\n\tint use_gzip = rpc->gzip_request;\n\tchar *gzip_body = NULL;\n\tsize_t gzip_size = 0;\n\tint err, large_request = 0;\n\tint needs_100_continue = 0;\n\tstruct rpc_in_data rpc_in_data;\n\n\t/* Try to load the entire request, if we can fit it into the\n\t * allocated buffer space we can use HTTP/1.0 and avoid the\n\t * chunked encoding mess.\n\t */\n\tif (!flush_received) {\n\t\twhile (1) {\n\t\t\tsize_t n;\n\t\t\tenum packet_read_status status;\n\n\t\t\tif (!rpc_read_from_out(rpc, 0, &n, &status)) {\n\t\t\t\tlarge_request = 1;\n\t\t\t\tuse_gzip = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (status == PACKET_READ_FLUSH)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (large_request) {\n\t\tstruct slot_results results;\n\n\t\tdo {\n\t\t\terr = probe_rpc(rpc, &results);\n\t\t\tif (err == HTTP_REAUTH)\n\t\t\t\tcredential_fill(&http_auth);\n\t\t} while (err == HTTP_REAUTH);\n\t\tif (err != HTTP_OK)\n\t\t\treturn -1;\n\n\t\tif (results.auth_avail & CURLAUTH_GSSNEGOTIATE)\n\t\t\tneeds_100_continue = 1;\n\t}\n\n\theaders = curl_slist_append(headers, rpc->hdr_content_type);\n\theaders = curl_slist_append(headers, rpc->hdr_accept);\n\theaders = curl_slist_append(headers, needs_100_continue ?\n\t\t\"Expect: 100-continue\" : \"Expect:\");\n\n\t/* Add Accept-Language header */\n\tif (rpc->hdr_accept_language)\n\t\theaders = curl_slist_append(headers, rpc->hdr_accept_language);\n\n\t/* Add the extra Git-Protocol header */\n\tif (rpc->protocol_header)\n\t\theaders = curl_slist_append(headers, rpc->protocol_header);\n\nretry:\n\tslot = get_active_slot();\n\n\tcurl_easy_setopt(slot->curl, CURLOPT_NOBODY, 0);\n\tcurl_easy_setopt(slot->curl, CURLOPT_POST, 1);\n\tcurl_easy_setopt(slot->curl, CURLOPT_URL, rpc->service_url);\n\tcurl_easy_setopt(slot->curl, CURLOPT_ENCODING, \"\");\n\n\tif (large_request) {\n\t\t/* The request body is large and the size cannot be predicted.\n\t\t * We must use chunked encoding to send it.\n\t\t */\n#ifdef GIT_CURL_NEED_TRANSFER_ENCODING_HEADER\n\t\theaders = curl_slist_append(headers, \"Transfer-Encoding: chunked\");\n#endif\n\t\trpc->initial_buffer = 1;\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_READFUNCTION, rpc_out);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_INFILE, rpc);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_SEEKFUNCTION, rpc_seek);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_SEEKDATA, rpc);\n\t\tif (options.verbosity > 1) {\n\t\t\tfprintf(stderr, \"POST %s (chunked)\\n\", rpc->service_name);\n\t\t\tfflush(stderr);\n\t\t}\n\n\t} else if (gzip_body) {\n\t\t/*\n\t\t * If we are looping to retry authentication, then the previous\n\t\t * run will have set up the headers and gzip buffer already,\n\t\t * and we just need to send it.\n\t\t */\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, gzip_body);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE_LARGE, xcurl_off_t(gzip_size));\n\n\t} else if (use_gzip && 1024 < rpc->len) {\n\t\t/* The client backend isn't giving us compressed data so\n\t\t * we can try to deflate it ourselves, this may save on\n\t\t * the transfer time.\n\t\t */\n\t\tgit_zstream stream;\n\t\tint ret;\n\n\t\tgit_deflate_init_gzip(&stream, Z_BEST_COMPRESSION);\n\t\tgzip_size = git_deflate_bound(&stream, rpc->len);\n\t\tgzip_body = xmalloc(gzip_size);\n\n\t\tstream.next_in = (unsigned char *)rpc->buf;\n\t\tstream.avail_in = rpc->len;\n\t\tstream.next_out = (unsigned char *)gzip_body;\n\t\tstream.avail_out = gzip_size;\n\n\t\tret = git_deflate(&stream, Z_FINISH);\n\t\tif (ret != Z_STREAM_END)\n\t\t\tdie(_(\"cannot deflate request; zlib deflate error %d\"), ret);\n\n\t\tret = git_deflate_end_gently(&stream);\n\t\tif (ret != Z_OK)\n\t\t\tdie(_(\"cannot deflate request; zlib end error %d\"), ret);\n\n\t\tgzip_size = stream.total_out;\n\n\t\theaders = curl_slist_append(headers, \"Content-Encoding: gzip\");\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, gzip_body);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE_LARGE, xcurl_off_t(gzip_size));\n\n\t\tif (options.verbosity > 1) {\n\t\t\tfprintf(stderr, \"POST %s (gzip %lu to %lu bytes)\\n\",\n\t\t\t\trpc->service_name,\n\t\t\t\t(unsigned long)rpc->len, (unsigned long)gzip_size);\n\t\t\tfflush(stderr);\n\t\t}\n\t} else {\n\t\t/* We know the complete request size in advance, use the\n\t\t * more normal Content-Length approach.\n\t\t */\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, rpc->buf);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE_LARGE, xcurl_off_t(rpc->len));\n\t\tif (options.verbosity > 1) {\n\t\t\tfprintf(stderr, \"POST %s (%lu bytes)\\n\",\n\t\t\t\trpc->service_name, (unsigned long)rpc->len);\n\t\t\tfflush(stderr);\n\t\t}\n\t}\n\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, headers);\n\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION, rpc_in);\n\trpc_in_data.rpc = rpc;\n\trpc_in_data.slot = slot;\n\trpc_in_data.check_pktline = stateless_connect;\n\tmemset(&rpc_in_data.pktline_state, 0, sizeof(rpc_in_data.pktline_state));\n\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEDATA, &rpc_in_data);\n\tcurl_easy_setopt(slot->curl, CURLOPT_FAILONERROR, 0);\n\n\n\trpc->any_written = 0;\n\terr = run_slot(slot, NULL);\n\tif (err == HTTP_REAUTH && !large_request) {\n\t\tcredential_fill(&http_auth);\n\t\tgoto retry;\n\t}\n\tif (err != HTTP_OK)\n\t\terr = -1;\n\n\tif (!rpc->any_written)\n\t\terr = -1;\n\n\tif (rpc_in_data.pktline_state.len_filled)\n\t\terr = error(_(\"%d bytes of length header were received\"), rpc_in_data.pktline_state.len_filled);\n\tif (rpc_in_data.pktline_state.remaining)\n\t\terr = error(_(\"%d bytes of body are still expected\"), rpc_in_data.pktline_state.remaining);\n\n\tif (stateless_connect)\n\t\tpacket_response_end(rpc->in);\n\n\tcurl_slist_free_all(headers);\n\tfree(gzip_body);\n\treturn err;\n}\n\nstatic int rpc_service(struct rpc_state *rpc, struct discovery *heads,\n\t\t       const char **client_argv, const struct strbuf *preamble,\n\t\t       struct strbuf *rpc_result)\n{\n\tconst char *svc = rpc->service_name;\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct child_process client = CHILD_PROCESS_INIT;\n\tint err = 0;\n\n\tclient.in = -1;\n\tclient.out = -1;\n\tclient.git_cmd = 1;\n\tstrvec_pushv(&client.args, client_argv);\n\tif (start_command(&client))\n\t\texit(1);\n\twrite_or_die(client.in, preamble->buf, preamble->len);\n\tif (heads)\n\t\twrite_or_die(client.in, heads->buf, heads->len);\n\n\trpc->alloc = http_post_buffer;\n\trpc->buf = xmalloc(rpc->alloc);\n\trpc->in = client.in;\n\trpc->out = client.out;\n\n\tstrbuf_addf(&buf, \"%s%s\", url.buf, svc);\n\trpc->service_url = strbuf_detach(&buf, NULL);\n\n\trpc->hdr_accept_language = xstrdup_or_null(http_get_accept_language_header());\n\n\tstrbuf_addf(&buf, \"Content-Type: application/x-%s-request\", svc);\n\trpc->hdr_content_type = strbuf_detach(&buf, NULL);\n\n\tstrbuf_addf(&buf, \"Accept: application/x-%s-result\", svc);\n\trpc->hdr_accept = strbuf_detach(&buf, NULL);\n\n\tif (get_protocol_http_header(heads->version, &buf))\n\t\trpc->protocol_header = strbuf_detach(&buf, NULL);\n\telse\n\t\trpc->protocol_header = NULL;\n\n\twhile (!err) {\n\t\tint n = packet_read(rpc->out, rpc->buf, rpc->alloc, 0);\n\t\tif (!n)\n\t\t\tbreak;\n\t\trpc->pos = 0;\n\t\trpc->len = n;\n\t\terr |= post_rpc(rpc, 0, 0);\n\t}\n\n\tclose(client.in);\n\tclient.in = -1;\n\tif (!err) {\n\t\tstrbuf_read(rpc_result, client.out, 0);\n\t} else {\n\t\tchar buf[4096];\n\t\tfor (;;)\n\t\t\tif (xread(client.out, buf, sizeof(buf)) <= 0)\n\t\t\t\tbreak;\n\t}\n\n\tclose(client.out);\n\tclient.out = -1;\n\n\terr |= finish_command(&client);\n\tfree(rpc->service_url);\n\tfree(rpc->hdr_content_type);\n\tfree(rpc->hdr_accept);\n\tfree(rpc->hdr_accept_language);\n\tfree(rpc->protocol_header);\n\tfree(rpc->buf);\n\tstrbuf_release(&buf);\n\treturn err;\n}\n\nstatic int fetch_dumb(int nr_heads, struct ref **to_fetch)\n{\n\tstruct walker *walker;\n\tchar **targets;\n\tint ret, i;\n\n\tALLOC_ARRAY(targets, nr_heads);\n\tif (options.depth || options.deepen_since)\n\t\tdie(_(\"dumb http transport does not support shallow capabilities\"));\n\tfor (i = 0; i < nr_heads; i++)\n\t\ttargets[i] = xstrdup(oid_to_hex(&to_fetch[i]->old_oid));\n\n\twalker = get_http_walker(url.buf);\n\twalker->get_verbosely = options.verbosity >= 3;\n\twalker->get_progress = options.progress;\n\twalker->get_recover = 0;\n\tret = walker_fetch(walker, nr_heads, targets, NULL, NULL);\n\twalker_free(walker);\n\n\tfor (i = 0; i < nr_heads; i++)\n\t\tfree(targets[i]);\n\tfree(targets);\n\n\treturn ret ? error(_(\"fetch failed.\")) : 0;\n}\n\nstatic int fetch_git(struct discovery *heads,\n\tint nr_heads, struct ref **to_fetch)\n{\n\tstruct rpc_state rpc = RPC_STATE_INIT;\n\tstruct strbuf preamble = STRBUF_INIT;\n\tint i, err;\n\tstruct strvec args = STRVEC_INIT;\n\tstruct strbuf rpc_result = STRBUF_INIT;\n\n\tstrvec_pushl(&args, \"fetch-pack\", \"--stateless-rpc\",\n\t\t     \"--stdin\", \"--lock-pack\", NULL);\n\tif (options.followtags)\n\t\tstrvec_push(&args, \"--include-tag\");\n\tif (options.thin)\n\t\tstrvec_push(&args, \"--thin\");\n\tif (options.verbosity >= 3)\n\t\tstrvec_pushl(&args, \"-v\", \"-v\", NULL);\n\tif (options.check_self_contained_and_connected)\n\t\tstrvec_push(&args, \"--check-self-contained-and-connected\");\n\tif (options.cloning)\n\t\tstrvec_push(&args, \"--cloning\");\n\tif (options.update_shallow)\n\t\tstrvec_push(&args, \"--update-shallow\");\n\tif (!options.progress)\n\t\tstrvec_push(&args, \"--no-progress\");\n\tif (options.depth)\n\t\tstrvec_pushf(&args, \"--depth=%lu\", options.depth);\n\tif (options.deepen_since)\n\t\tstrvec_pushf(&args, \"--shallow-since=%s\", options.deepen_since);\n\tfor (i = 0; i < options.deepen_not.nr; i++)\n\t\tstrvec_pushf(&args, \"--shallow-exclude=%s\",\n\t\t\t     options.deepen_not.items[i].string);\n\tif (options.deepen_relative && options.depth)\n\t\tstrvec_push(&args, \"--deepen-relative\");\n\tif (options.from_promisor)\n\t\tstrvec_push(&args, \"--from-promisor\");\n\tif (options.refetch)\n\t\tstrvec_push(&args, \"--refetch\");\n\tif (options.filter)\n\t\tstrvec_pushf(&args, \"--filter=%s\", options.filter);\n\tstrvec_push(&args, url.buf);\n\n\tfor (i = 0; i < nr_heads; i++) {\n\t\tstruct ref *ref = to_fetch[i];\n\t\tif (!*ref->name)\n\t\t\tdie(_(\"cannot fetch by sha1 over smart http\"));\n\t\tpacket_buf_write(&preamble, \"%s %s\\n\",\n\t\t\t\t oid_to_hex(&ref->old_oid), ref->name);\n\t}\n\tpacket_buf_flush(&preamble);\n\n\tmemset(&rpc, 0, sizeof(rpc));\n\trpc.service_name = \"git-upload-pack\",\n\trpc.gzip_request = 1;\n\n\terr = rpc_service(&rpc, heads, args.v, &preamble, &rpc_result);\n\tif (rpc_result.len)\n\t\twrite_or_die(1, rpc_result.buf, rpc_result.len);\n\tstrbuf_release(&rpc_result);\n\tstrbuf_release(&preamble);\n\tstrvec_clear(&args);\n\treturn err;\n}\n\nstatic int fetch(int nr_heads, struct ref **to_fetch)\n{\n\tstruct discovery *d = discover_refs(\"git-upload-pack\", 0);\n\tif (d->proto_git)\n\t\treturn fetch_git(d, nr_heads, to_fetch);\n\telse\n\t\treturn fetch_dumb(nr_heads, to_fetch);\n}\n\nstatic void parse_fetch(struct strbuf *buf)\n{\n\tstruct ref **to_fetch = NULL;\n\tstruct ref *list_head = NULL;\n\tstruct ref **list = &list_head;\n\tint alloc_heads = 0, nr_heads = 0;\n\n\tdo {\n\t\tconst char *p;\n\t\tif (skip_prefix(buf->buf, \"fetch \", &p)) {\n\t\t\tconst char *name;\n\t\t\tstruct ref *ref;\n\t\t\tstruct object_id old_oid;\n\t\t\tconst char *q;\n\n\t\t\tif (parse_oid_hex(p, &old_oid, &q))\n\t\t\t\tdie(_(\"protocol error: expected sha/ref, got '%s'\"), p);\n\t\t\tif (*q == ' ')\n\t\t\t\tname = q + 1;\n\t\t\telse if (!*q)\n\t\t\t\tname = \"\";\n\t\t\telse\n\t\t\t\tdie(_(\"protocol error: expected sha/ref, got '%s'\"), p);\n\n\t\t\tref = alloc_ref(name);\n\t\t\toidcpy(&ref->old_oid, &old_oid);\n\n\t\t\t*list = ref;\n\t\t\tlist = &ref->next;\n\n\t\t\tALLOC_GROW(to_fetch, nr_heads + 1, alloc_heads);\n\t\t\tto_fetch[nr_heads++] = ref;\n\t\t}\n\t\telse\n\t\t\tdie(_(\"http transport does not support %s\"), buf->buf);\n\n\t\tstrbuf_reset(buf);\n\t\tif (strbuf_getline_lf(buf, stdin) == EOF)\n\t\t\treturn;\n\t\tif (!*buf->buf)\n\t\t\tbreak;\n\t} while (1);\n\n\tif (fetch(nr_heads, to_fetch))\n\t\texit(128); /* error already reported */\n\tfree_refs(list_head);\n\tfree(to_fetch);\n\n\tprintf(\"\\n\");\n\tfflush(stdout);\n\tstrbuf_reset(buf);\n}\n\nstatic void parse_get(const char *arg)\n{\n\tstruct strbuf url = STRBUF_INIT;\n\tstruct strbuf path = STRBUF_INIT;\n\tconst char *space;\n\n\tspace = strchr(arg, ' ');\n\n\tif (!space)\n\t\tdie(_(\"protocol error: expected '<url> <path>', missing space\"));\n\n\tstrbuf_add(&url, arg, space - arg);\n\tstrbuf_addstr(&path, space + 1);\n\n\tif (http_get_file(url.buf, path.buf, NULL))\n\t\tdie(_(\"failed to download file at URL '%s'\"), url.buf);\n\n\tstrbuf_release(&url);\n\tstrbuf_release(&path);\n\tprintf(\"\\n\");\n\tfflush(stdout);\n}\n\nstatic int push_dav(int nr_spec, const char **specs)\n{\n\tstruct child_process child = CHILD_PROCESS_INIT;\n\tsize_t i;\n\n\tchild.git_cmd = 1;\n\tstrvec_push(&child.args, \"http-push\");\n\tstrvec_push(&child.args, \"--helper-status\");\n\tif (options.dry_run)\n\t\tstrvec_push(&child.args, \"--dry-run\");\n\tif (options.verbosity > 1)\n\t\tstrvec_push(&child.args, \"--verbose\");\n\tstrvec_push(&child.args, url.buf);\n\tfor (i = 0; i < nr_spec; i++)\n\t\tstrvec_push(&child.args, specs[i]);\n\n\tif (run_command(&child))\n\t\tdie(_(\"git-http-push failed\"));\n\treturn 0;\n}\n\nstatic int push_git(struct discovery *heads, int nr_spec, const char **specs)\n{\n\tstruct rpc_state rpc = RPC_STATE_INIT;\n\tint i, err;\n\tstruct strvec args;\n\tstruct string_list_item *cas_option;\n\tstruct strbuf preamble = STRBUF_INIT;\n\tstruct strbuf rpc_result = STRBUF_INIT;\n\n\tstrvec_init(&args);\n\tstrvec_pushl(&args, \"send-pack\", \"--stateless-rpc\", \"--helper-status\",\n\t\t     NULL);\n\n\tif (options.thin)\n\t\tstrvec_push(&args, \"--thin\");\n\tif (options.dry_run)\n\t\tstrvec_push(&args, \"--dry-run\");\n\tif (options.push_cert == SEND_PACK_PUSH_CERT_ALWAYS)\n\t\tstrvec_push(&args, \"--signed=yes\");\n\telse if (options.push_cert == SEND_PACK_PUSH_CERT_IF_ASKED)\n\t\tstrvec_push(&args, \"--signed=if-asked\");\n\tif (options.atomic)\n\t\tstrvec_push(&args, \"--atomic\");\n\tif (options.verbosity == 0)\n\t\tstrvec_push(&args, \"--quiet\");\n\telse if (options.verbosity > 1)\n\t\tstrvec_push(&args, \"--verbose\");\n\tfor (i = 0; i < options.push_options.nr; i++)\n\t\tstrvec_pushf(&args, \"--push-option=%s\",\n\t\t\t     options.push_options.items[i].string);\n\tstrvec_push(&args, options.progress ? \"--progress\" : \"--no-progress\");\n\tfor_each_string_list_item(cas_option, &cas_options)\n\t\tstrvec_push(&args, cas_option->string);\n\tstrvec_push(&args, url.buf);\n\n\tif (options.force_if_includes)\n\t\tstrvec_push(&args, \"--force-if-includes\");\n\n\tstrvec_push(&args, \"--stdin\");\n\tfor (i = 0; i < nr_spec; i++)\n\t\tpacket_buf_write(&preamble, \"%s\\n\", specs[i]);\n\tpacket_buf_flush(&preamble);\n\n\tmemset(&rpc, 0, sizeof(rpc));\n\trpc.service_name = \"git-receive-pack\",\n\n\terr = rpc_service(&rpc, heads, args.v, &preamble, &rpc_result);\n\tif (rpc_result.len)\n\t\twrite_or_die(1, rpc_result.buf, rpc_result.len);\n\tstrbuf_release(&rpc_result);\n\tstrbuf_release(&preamble);\n\tstrvec_clear(&args);\n\treturn err;\n}\n\nstatic int push(int nr_spec, const char **specs)\n{\n\tstruct discovery *heads = discover_refs(\"git-receive-pack\", 1);\n\tint ret;\n\n\tif (heads->proto_git)\n\t\tret = push_git(heads, nr_spec, specs);\n\telse\n\t\tret = push_dav(nr_spec, specs);\n\tfree_discovery(heads);\n\treturn ret;\n}\n\nstatic void parse_push(struct strbuf *buf)\n{\n\tstruct strvec specs = STRVEC_INIT;\n\tint ret;\n\n\tdo {\n\t\tconst char *arg;\n\t\tif (skip_prefix(buf->buf, \"push \", &arg))\n\t\t\tstrvec_push(&specs, arg);\n\t\telse\n\t\t\tdie(_(\"http transport does not support %s\"), buf->buf);\n\n\t\tstrbuf_reset(buf);\n\t\tif (strbuf_getline_lf(buf, stdin) == EOF)\n\t\t\tgoto free_specs;\n\t\tif (!*buf->buf)\n\t\t\tbreak;\n\t} while (1);\n\n\tret = push(specs.nr, specs.v);\n\tprintf(\"\\n\");\n\tfflush(stdout);\n\n\tif (ret)\n\t\texit(128); /* error already reported */\n\nfree_specs:\n\tstrvec_clear(&specs);\n}\n\nstatic int stateless_connect(const char *service_name)\n{\n\tstruct discovery *discover;\n\tstruct rpc_state rpc = RPC_STATE_INIT;\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *accept_language;\n\n\t/*\n\t * Run the info/refs request and see if the server supports protocol\n\t * v2.  If and only if the server supports v2 can we successfully\n\t * establish a stateless connection, otherwise we need to tell the\n\t * client to fallback to using other transport helper functions to\n\t * complete their request.\n\t *\n\t * The \"git-upload-archive\" service is a read-only operation. Fallback\n\t * to use \"git-upload-pack\" service to discover protocol version.\n\t */\n\tif (!strcmp(service_name, \"git-upload-archive\"))\n\t\tdiscover = discover_refs(\"git-upload-pack\", 0);\n\telse\n\t\tdiscover = discover_refs(service_name, 0);\n\tif (discover->version != protocol_v2) {\n\t\tprintf(\"fallback\\n\");\n\t\tfflush(stdout);\n\t\treturn -1;\n\t} else {\n\t\t/* Stateless Connection established */\n\t\tprintf(\"\\n\");\n\t\tfflush(stdout);\n\t}\n\taccept_language = http_get_accept_language_header();\n\tif (accept_language)\n\t\trpc.hdr_accept_language = xstrfmt(\"%s\", accept_language);\n\n\trpc.service_name = service_name;\n\trpc.service_url = xstrfmt(\"%s%s\", url.buf, rpc.service_name);\n\trpc.hdr_content_type = xstrfmt(\"Content-Type: application/x-%s-request\", rpc.service_name);\n\trpc.hdr_accept = xstrfmt(\"Accept: application/x-%s-result\", rpc.service_name);\n\tif (get_protocol_http_header(discover->version, &buf)) {\n\t\trpc.protocol_header = strbuf_detach(&buf, NULL);\n\t} else {\n\t\trpc.protocol_header = NULL;\n\t\tstrbuf_release(&buf);\n\t}\n\trpc.buf = xmalloc(http_post_buffer);\n\trpc.alloc = http_post_buffer;\n\trpc.len = 0;\n\trpc.pos = 0;\n\trpc.in = 1;\n\trpc.out = 0;\n\trpc.any_written = 0;\n\trpc.gzip_request = 1;\n\trpc.initial_buffer = 0;\n\trpc.write_line_lengths = 1;\n\trpc.flush_read_but_not_sent = 0;\n\n\t/*\n\t * Dump the capability listing that we got from the server earlier\n\t * during the info/refs request. This does not work with the\n\t * \"git-upload-archive\" service.\n\t */\n\tif (strcmp(service_name, \"git-upload-archive\"))\n\t\twrite_or_die(rpc.in, discover->buf, discover->len);\n\n\t/* Until we see EOF keep sending POSTs */\n\twhile (1) {\n\t\tsize_t avail;\n\t\tenum packet_read_status status;\n\n\t\tif (!rpc_read_from_out(&rpc, PACKET_READ_GENTLE_ON_EOF, &avail,\n\t\t\t\t       &status))\n\t\t\tBUG(\"The entire rpc->buf should be larger than LARGE_PACKET_MAX\");\n\t\tif (status == PACKET_READ_EOF)\n\t\t\tbreak;\n\t\tif (post_rpc(&rpc, 1, status == PACKET_READ_FLUSH))\n\t\t\t/* We would have an err here */\n\t\t\tbreak;\n\t\t/* Reset the buffer for next request */\n\t\trpc.len = 0;\n\t}\n\n\tfree(rpc.service_url);\n\tfree(rpc.hdr_content_type);\n\tfree(rpc.hdr_accept);\n\tfree(rpc.hdr_accept_language);\n\tfree(rpc.protocol_header);\n\tfree(rpc.buf);\n\tstrbuf_release(&buf);\n\n\treturn 0;\n}\n\nint cmd_main(int argc, const char **argv)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tint nongit;\n\tint ret = 1;\n\n\tsetup_git_directory_gently(&nongit);\n\tif (argc < 2) {\n\t\terror(_(\"remote-curl: usage: git remote-curl <remote> [<url>]\"));\n\t\tgoto cleanup;\n\t}\n\n\toptions.verbosity = 1;\n\toptions.progress = !!isatty(2);\n\toptions.thin = 1;\n\tstring_list_init_dup(&options.deepen_not);\n\tstring_list_init_dup(&options.push_options);\n\n\t/*\n\t * Just report \"remote-curl\" here (folding all the various aliases\n\t * (\"git-remote-http\", \"git-remote-https\", and etc.) here since they\n\t * are all just copies of the same actual executable.\n\t */\n\ttrace2_cmd_name(\"remote-curl\");\n\n\tremote = remote_get(argv[1]);\n\n\tif (argc > 2) {\n\t\tend_url_with_slash(&url, argv[2]);\n\t} else {\n\t\tend_url_with_slash(&url, remote->url[0]);\n\t}\n\n\thttp_init(remote, url.buf, 0);\n\n\tdo {\n\t\tconst char *arg;\n\n\t\tif (strbuf_getline_lf(&buf, stdin) == EOF) {\n\t\t\tif (ferror(stdin))\n\t\t\t\terror(_(\"remote-curl: error reading command stream from git\"));\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (buf.len == 0)\n\t\t\tbreak;\n\t\tif (starts_with(buf.buf, \"fetch \")) {\n\t\t\tif (nongit) {\n\t\t\t\tsetup_git_directory_gently(&nongit);\n\t\t\t\tif (nongit)\n\t\t\t\t\tdie(_(\"remote-curl: fetch attempted without a local repo\"));\n\t\t\t}\n\t\t\tparse_fetch(&buf);\n\n\t\t} else if (!strcmp(buf.buf, \"list\") || starts_with(buf.buf, \"list \")) {\n\t\t\tint for_push = !!strstr(buf.buf + 4, \"for-push\");\n\t\t\toutput_refs(get_refs(for_push));\n\n\t\t} else if (starts_with(buf.buf, \"push \")) {\n\t\t\tparse_push(&buf);\n\n\t\t} else if (skip_prefix(buf.buf, \"option \", &arg)) {\n\t\t\tchar *value = strchr(arg, ' ');\n\t\t\tint result;\n\n\t\t\tif (value)\n\t\t\t\t*value++ = '\\0';\n\t\t\telse\n\t\t\t\tvalue = \"true\";\n\n\t\t\tresult = set_option(arg, value);\n\t\t\tif (!result)\n\t\t\t\tprintf(\"ok\\n\");\n\t\t\telse if (result < 0)\n\t\t\t\tprintf(\"error invalid value\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"unsupported\\n\");\n\t\t\tfflush(stdout);\n\n\t\t} else if (skip_prefix(buf.buf, \"get \", &arg)) {\n\t\t\tparse_get(arg);\n\t\t\tfflush(stdout);\n\n\t\t} else if (!strcmp(buf.buf, \"capabilities\")) {\n\t\t\tprintf(\"stateless-connect\\n\");\n\t\t\tprintf(\"fetch\\n\");\n\t\t\tprintf(\"get\\n\");\n\t\t\tprintf(\"option\\n\");\n\t\t\tprintf(\"push\\n\");\n\t\t\tprintf(\"check-connectivity\\n\");\n\t\t\tprintf(\"object-format\\n\");\n\t\t\tprintf(\"\\n\");\n\t\t\tfflush(stdout);\n\t\t} else if (skip_prefix(buf.buf, \"stateless-connect \", &arg)) {\n\t\t\tif (!stateless_connect(arg))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\terror(_(\"remote-curl: unknown command '%s' from git\"), buf.buf);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tstrbuf_reset(&buf);\n\t} while (1);\n\n\thttp_cleanup();\n\tret = 0;\ncleanup:\n\tstrbuf_release(&buf);\n\n\treturn ret;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "004b707fdf475773764083a2b349850e613f48e0",
  "sha1_ok": true,
  "size": 43897
}
