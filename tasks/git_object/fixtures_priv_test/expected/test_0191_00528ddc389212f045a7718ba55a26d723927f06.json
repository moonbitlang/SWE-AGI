{
  "content": {
    "base64": "LyoKICogR0lUIC0gVGhlIGluZm9ybWF0aW9uIG1hbmFnZXIgZnJvbSBoZWxsCiAqCiAqIENvcHlyaWdodCAoQykgTGludXMgVG9ydmFsZHMsIDIwMDUKICovCiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAiZXhlY19jbWQuaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAidHJlZS5oIgojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAidXNlcmRpZmYuaCIKI2luY2x1ZGUgInN0cmVhbWluZy5oIgoKI2RlZmluZSBCQVRDSCAxCiNkZWZpbmUgQkFUQ0hfQ0hFQ0sgMgoKc3RhdGljIHZvaWQgcHByaW50X3RhZyhjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBjb25zdCBjaGFyICpidWYsIHVuc2lnbmVkIGxvbmcgc2l6ZSkKewoJLyogdGhlIHBhcnNlciBpbiB0YWcuYyBpcyB1c2VsZXNzIGhlcmUuICovCgljb25zdCBjaGFyICplbmRwID0gYnVmICsgc2l6ZTsKCWNvbnN0IGNoYXIgKmNwID0gYnVmOwoKCXdoaWxlIChjcCA8IGVuZHApIHsKCQljaGFyIGMgPSAqY3ArKzsKCQlpZiAoYyAhPSAnXG4nKQoJCQljb250aW51ZTsKCQlpZiAoNyA8PSBlbmRwIC0gY3AgJiYgIW1lbWNtcCgidGFnZ2VyICIsIGNwLCA3KSkgewoJCQljb25zdCBjaGFyICp0YWdnZXIgPSBjcDsKCgkJCS8qIEZvdW5kIHRoZSB0YWdnZXIgbGluZS4gIENvcHkgb3V0IHRoZSBjb250ZW50cwoJCQkgKiBvZiB0aGUgYnVmZmVyIHNvIGZhci4KCQkJICovCgkJCXdyaXRlX29yX2RpZSgxLCBidWYsIGNwIC0gYnVmKTsKCgkJCS8qCgkJCSAqIERvIHNvbWV0aGluZyBpbnRlbGxpZ2VudCwgbGlrZSBwcmV0dHktcHJpbnRpbmcKCQkJICogdGhlIGRhdGUuCgkJCSAqLwoJCQl3aGlsZSAoY3AgPCBlbmRwKSB7CgkJCQlpZiAoKmNwKysgPT0gJ1xuJykgewoJCQkJCS8qIHRhZ2dlciB0byBjcCBpcyBhIGxpbmUKCQkJCQkgKiB0aGF0IGhhcyBpZGVudCBhbmQgdGltZS4KCQkJCQkgKi8KCQkJCQljb25zdCBjaGFyICpzcCA9IHRhZ2dlcjsKCQkJCQljaGFyICplcDsKCQkJCQl1bnNpZ25lZCBsb25nIGRhdGU7CgkJCQkJbG9uZyB0ejsKCQkJCQl3aGlsZSAoc3AgPCBjcCAmJiAqc3AgIT0gJz4nKQoJCQkJCQlzcCsrOwoJCQkJCWlmIChzcCA9PSBjcCkgewoJCQkJCQkvKiBnaXZlIHVwICovCgkJCQkJCXdyaXRlX29yX2RpZSgxLCB0YWdnZXIsCgkJCQkJCQkgICAgIGNwIC0gdGFnZ2VyKTsKCQkJCQkJYnJlYWs7CgkJCQkJfQoJCQkJCXdoaWxlIChzcCA8IGNwICYmCgkJCQkJICAgICAgICEoJzAnIDw9ICpzcCAmJiAqc3AgPD0gJzknKSkKCQkJCQkJc3ArKzsKCQkJCQl3cml0ZV9vcl9kaWUoMSwgdGFnZ2VyLCBzcCAtIHRhZ2dlcik7CgkJCQkJZGF0ZSA9IHN0cnRvdWwoc3AsICZlcCwgMTApOwoJCQkJCXR6ID0gc3RydG9sKGVwLCBOVUxMLCAxMCk7CgkJCQkJc3AgPSBzaG93X2RhdGUoZGF0ZSwgdHosIDApOwoJCQkJCXdyaXRlX29yX2RpZSgxLCBzcCwgc3RybGVuKHNwKSk7CgkJCQkJeHdyaXRlKDEsICJcbiIsIDEpOwoJCQkJCWJyZWFrOwoJCQkJfQoJCQl9CgkJCWJyZWFrOwoJCX0KCQlpZiAoY3AgPCBlbmRwICYmICpjcCA9PSAnXG4nKQoJCQkvKiBlbmQgb2YgaGVhZGVyICovCgkJCWJyZWFrOwoJfQoJLyogQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSBjb3BpZWQgb3V0IHRoZSBoZWFkZXIgdXAgdG8gdGhlIGVuZCBvZgoJICogdGhlIHRhZ2dlciBsaW5lIGFuZCBjcCBwb2ludHMgYXQgb25lIHBhc3QgXG4uICBJdCBjb3VsZCBiZSB0aGUKCSAqIG5leHQgaGVhZGVyIGxpbmUgYWZ0ZXIgdGhlIHRhZ2dlciBsaW5lLCBvciBpdCBjb3VsZCBiZSBhbm90aGVyCgkgKiBcbiB0aGF0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGhlYWRlcnMuICBXZSBuZWVkIHRvIGNvcHkgb3V0IHRoZQoJICogcmVtYWluZGVyIGFzIGlzLgoJICovCglpZiAoY3AgPCBlbmRwKQoJCXdyaXRlX29yX2RpZSgxLCBjcCwgZW5kcCAtIGNwKTsKfQoKc3RhdGljIGludCBjYXRfb25lX2ZpbGUoaW50IG9wdCwgY29uc3QgY2hhciAqZXhwX3R5cGUsIGNvbnN0IGNoYXIgKm9ial9uYW1lKQp7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJY2hhciAqYnVmOwoJdW5zaWduZWQgbG9uZyBzaXplOwoJc3RydWN0IG9iamVjdF9jb250ZXh0IG9ial9jb250ZXh0OwoKCWlmIChnZXRfc2hhMV93aXRoX2NvbnRleHQob2JqX25hbWUsIDAsIHNoYTEsICZvYmpfY29udGV4dCkpCgkJZGllKCJOb3QgYSB2YWxpZCBvYmplY3QgbmFtZSAlcyIsIG9ial9uYW1lKTsKCglidWYgPSBOVUxMOwoJc3dpdGNoIChvcHQpIHsKCWNhc2UgJ3QnOgoJCXR5cGUgPSBzaGExX29iamVjdF9pbmZvKHNoYTEsIE5VTEwpOwoJCWlmICh0eXBlID4gMCkgewoJCQlwcmludGYoIiVzXG4iLCB0eXBlbmFtZSh0eXBlKSk7CgkJCXJldHVybiAwOwoJCX0KCQlicmVhazsKCgljYXNlICdzJzoKCQl0eXBlID0gc2hhMV9vYmplY3RfaW5mbyhzaGExLCAmc2l6ZSk7CgkJaWYgKHR5cGUgPiAwKSB7CgkJCXByaW50ZigiJWx1XG4iLCBzaXplKTsKCQkJcmV0dXJuIDA7CgkJfQoJCWJyZWFrOwoKCWNhc2UgJ2UnOgoJCXJldHVybiAhaGFzX3NoYTFfZmlsZShzaGExKTsKCgljYXNlICdwJzoKCQl0eXBlID0gc2hhMV9vYmplY3RfaW5mbyhzaGExLCBOVUxMKTsKCQlpZiAodHlwZSA8IDApCgkJCWRpZSgiTm90IGEgdmFsaWQgb2JqZWN0IG5hbWUgJXMiLCBvYmpfbmFtZSk7CgoJCS8qIGN1c3RvbSBwcmV0dHktcHJpbnQgaGVyZSAqLwoJCWlmICh0eXBlID09IE9CSl9UUkVFKSB7CgkJCWNvbnN0IGNoYXIgKmxzX2FyZ3NbM10gPSB7IE5VTEwgfTsKCQkJbHNfYXJnc1swXSA9ICAibHMtdHJlZSI7CgkJCWxzX2FyZ3NbMV0gPSAgb2JqX25hbWU7CgkJCXJldHVybiBjbWRfbHNfdHJlZSgyLCBsc19hcmdzLCBOVUxMKTsKCQl9CgoJCWlmICh0eXBlID09IE9CSl9CTE9CKQoJCQlyZXR1cm4gc3RyZWFtX2Jsb2JfdG9fZmQoMSwgc2hhMSwgTlVMTCwgMCk7CgkJYnVmID0gcmVhZF9zaGExX2ZpbGUoc2hhMSwgJnR5cGUsICZzaXplKTsKCQlpZiAoIWJ1ZikKCQkJZGllKCJDYW5ub3QgcmVhZCBvYmplY3QgJXMiLCBvYmpfbmFtZSk7CgkJaWYgKHR5cGUgPT0gT0JKX1RBRykgewoJCQlwcHJpbnRfdGFnKHNoYTEsIGJ1Ziwgc2l6ZSk7CgkJCXJldHVybiAwOwoJCX0KCgkJLyogb3RoZXJ3aXNlIGp1c3Qgc3BpdCBvdXQgdGhlIGRhdGEgKi8KCQlicmVhazsKCgljYXNlICdjJzoKCQlpZiAoIW9ial9jb250ZXh0LnBhdGhbMF0pCgkJCWRpZSgiZ2l0IGNhdC1maWxlIC0tdGV4dGNvbnYgJXM6IDxvYmplY3Q+IG11c3QgYmUgPHNoYTE6cGF0aD4iLAoJCQkgICAgb2JqX25hbWUpOwoKCQlpZiAoIXRleHRjb252X29iamVjdChvYmpfY29udGV4dC5wYXRoLCBvYmpfY29udGV4dC5tb2RlLCBzaGExLCAxLCAmYnVmLCAmc2l6ZSkpCgkJCWRpZSgiZ2l0IGNhdC1maWxlIC0tdGV4dGNvbnY6IHVuYWJsZSB0byBydW4gdGV4dGNvbnYgb24gJXMiLAoJCQkgICAgb2JqX25hbWUpOwoJCWJyZWFrOwoKCWNhc2UgMDoKCQlpZiAodHlwZV9mcm9tX3N0cmluZyhleHBfdHlwZSkgPT0gT0JKX0JMT0IpIHsKCQkJdW5zaWduZWQgY2hhciBibG9iX3NoYTFbMjBdOwoJCQlpZiAoc2hhMV9vYmplY3RfaW5mbyhzaGExLCBOVUxMKSA9PSBPQkpfVEFHKSB7CgkJCQllbnVtIG9iamVjdF90eXBlIHR5cGU7CgkJCQl1bnNpZ25lZCBsb25nIHNpemU7CgkJCQljaGFyICpidWZmZXIgPSByZWFkX3NoYTFfZmlsZShzaGExLCAmdHlwZSwgJnNpemUpOwoJCQkJaWYgKG1lbWNtcChidWZmZXIsICJvYmplY3QgIiwgNykgfHwKCQkJCSAgICBnZXRfc2hhMV9oZXgoYnVmZmVyICsgNywgYmxvYl9zaGExKSkKCQkJCQlkaWUoIiVzIG5vdCBhIHZhbGlkIHRhZyIsIHNoYTFfdG9faGV4KHNoYTEpKTsKCQkJCWZyZWUoYnVmZmVyKTsKCQkJfSBlbHNlCgkJCQloYXNoY3B5KGJsb2Jfc2hhMSwgc2hhMSk7CgoJCQlpZiAoc2hhMV9vYmplY3RfaW5mbyhibG9iX3NoYTEsIE5VTEwpID09IE9CSl9CTE9CKQoJCQkJcmV0dXJuIHN0cmVhbV9ibG9iX3RvX2ZkKDEsIGJsb2Jfc2hhMSwgTlVMTCwgMCk7CgkJCS8qCgkJCSAqIHdlIGF0dGVtcHRlZCB0byBkZXJlZmVyZW5jZSBhIHRhZyB0byBhIGJsb2IKCQkJICogYW5kIGZhaWxlZDsgdGhlcmUgbWF5IGJlIG5ldyBkZXJlZmVyZW5jZQoJCQkgKiBtZWNoYW5pc21zIHRoaXMgY29kZSBpcyBub3QgYXdhcmUgb2YuCgkJCSAqIGZhbGwtYmFjayB0byB0aGUgdXN1YWwgY2FzZS4KCQkJICovCgkJfQoJCWJ1ZiA9IHJlYWRfb2JqZWN0X3dpdGhfcmVmZXJlbmNlKHNoYTEsIGV4cF90eXBlLCAmc2l6ZSwgTlVMTCk7CgkJYnJlYWs7CgoJZGVmYXVsdDoKCQlkaWUoImdpdCBjYXQtZmlsZTogdW5rbm93biBvcHRpb246ICVzIiwgZXhwX3R5cGUpOwoJfQoKCWlmICghYnVmKQoJCWRpZSgiZ2l0IGNhdC1maWxlICVzOiBiYWQgZmlsZSIsIG9ial9uYW1lKTsKCgl3cml0ZV9vcl9kaWUoMSwgYnVmLCBzaXplKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGJhdGNoX29uZV9vYmplY3QoY29uc3QgY2hhciAqb2JqX25hbWUsIGludCBwcmludF9jb250ZW50cykKewoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZSA9IDA7Cgl1bnNpZ25lZCBsb25nIHNpemU7Cgl2b2lkICpjb250ZW50cyA9IGNvbnRlbnRzOwoKCWlmICghb2JqX25hbWUpCgkgICByZXR1cm4gMTsKCglpZiAoZ2V0X3NoYTEob2JqX25hbWUsIHNoYTEpKSB7CgkJcHJpbnRmKCIlcyBtaXNzaW5nXG4iLCBvYmpfbmFtZSk7CgkJZmZsdXNoKHN0ZG91dCk7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKHByaW50X2NvbnRlbnRzID09IEJBVENIKQoJCWNvbnRlbnRzID0gcmVhZF9zaGExX2ZpbGUoc2hhMSwgJnR5cGUsICZzaXplKTsKCWVsc2UKCQl0eXBlID0gc2hhMV9vYmplY3RfaW5mbyhzaGExLCAmc2l6ZSk7CgoJaWYgKHR5cGUgPD0gMCkgewoJCXByaW50ZigiJXMgbWlzc2luZ1xuIiwgb2JqX25hbWUpOwoJCWZmbHVzaChzdGRvdXQpOwoJCWlmIChwcmludF9jb250ZW50cyA9PSBCQVRDSCkKCQkJZnJlZShjb250ZW50cyk7CgkJcmV0dXJuIDA7Cgl9CgoJcHJpbnRmKCIlcyAlcyAlbHVcbiIsIHNoYTFfdG9faGV4KHNoYTEpLCB0eXBlbmFtZSh0eXBlKSwgc2l6ZSk7CglmZmx1c2goc3Rkb3V0KTsKCglpZiAocHJpbnRfY29udGVudHMgPT0gQkFUQ0gpIHsKCQl3cml0ZV9vcl9kaWUoMSwgY29udGVudHMsIHNpemUpOwoJCXByaW50ZigiXG4iKTsKCQlmZmx1c2goc3Rkb3V0KTsKCQlmcmVlKGNvbnRlbnRzKTsKCX0KCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBiYXRjaF9vYmplY3RzKGludCBwcmludF9jb250ZW50cykKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCgl3aGlsZSAoc3RyYnVmX2dldGxpbmUoJmJ1Ziwgc3RkaW4sICdcbicpICE9IEVPRikgewoJCWludCBlcnJvciA9IGJhdGNoX29uZV9vYmplY3QoYnVmLmJ1ZiwgcHJpbnRfY29udGVudHMpOwoJCWlmIChlcnJvcikKCQkJcmV0dXJuIGVycm9yOwoJfQoKCXJldHVybiAwOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGNhdF9maWxlX3VzYWdlW10gPSB7CglOXygiZ2l0IGNhdC1maWxlICgtdHwtc3wtZXwtcHw8dHlwZT58LS10ZXh0Y29udikgPG9iamVjdD4iKSwKCU5fKCJnaXQgY2F0LWZpbGUgKC0tYmF0Y2h8LS1iYXRjaC1jaGVjaykgPCA8bGlzdF9vZl9vYmplY3RzPiIpLAoJTlVMTAp9OwoKc3RhdGljIGludCBnaXRfY2F0X2ZpbGVfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmNiKQp7CglpZiAodXNlcmRpZmZfY29uZmlnKHZhciwgdmFsdWUpIDwgMCkKCQlyZXR1cm4gLTE7CgoJcmV0dXJuIGdpdF9kZWZhdWx0X2NvbmZpZyh2YXIsIHZhbHVlLCBjYik7Cn0KCmludCBjbWRfY2F0X2ZpbGUoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCWludCBvcHQgPSAwLCBiYXRjaCA9IDA7Cgljb25zdCBjaGFyICpleHBfdHlwZSA9IE5VTEwsICpvYmpfbmFtZSA9IE5VTEw7CgoJY29uc3Qgc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJT1BUX0dST1VQKE5fKCI8dHlwZT4gY2FuIGJlIG9uZSBvZjogYmxvYiwgdHJlZSwgY29tbWl0LCB0YWciKSksCgkJT1BUX1NFVF9JTlQoJ3QnLCBOVUxMLCAmb3B0LCBOXygic2hvdyBvYmplY3QgdHlwZSIpLCAndCcpLAoJCU9QVF9TRVRfSU5UKCdzJywgTlVMTCwgJm9wdCwgTl8oInNob3cgb2JqZWN0IHNpemUiKSwgJ3MnKSwKCQlPUFRfU0VUX0lOVCgnZScsIE5VTEwsICZvcHQsCgkJCSAgICBOXygiZXhpdCB3aXRoIHplcm8gd2hlbiB0aGVyZSdzIG5vIGVycm9yIiksICdlJyksCgkJT1BUX1NFVF9JTlQoJ3AnLCBOVUxMLCAmb3B0LCBOXygicHJldHR5LXByaW50IG9iamVjdCdzIGNvbnRlbnQiKSwgJ3AnKSwKCQlPUFRfU0VUX0lOVCgwLCAidGV4dGNvbnYiLCAmb3B0LAoJCQkgICAgTl8oImZvciBibG9iIG9iamVjdHMsIHJ1biB0ZXh0Y29udiBvbiBvYmplY3QncyBjb250ZW50IiksICdjJyksCgkJT1BUX1NFVF9JTlQoMCwgImJhdGNoIiwgJmJhdGNoLAoJCQkgICAgTl8oInNob3cgaW5mbyBhbmQgY29udGVudCBvZiBvYmplY3RzIGZlZCBmcm9tIHRoZSBzdGFuZGFyZCBpbnB1dCIpLAoJCQkgICAgQkFUQ0gpLAoJCU9QVF9TRVRfSU5UKDAsICJiYXRjaC1jaGVjayIsICZiYXRjaCwKCQkJICAgIE5fKCJzaG93IGluZm8gYWJvdXQgb2JqZWN0cyBmZWQgZnJvbSB0aGUgc3RhbmRhcmQgaW5wdXQiKSwKCQkJICAgIEJBVENIX0NIRUNLKSwKCQlPUFRfRU5EKCkKCX07CgoJZ2l0X2NvbmZpZyhnaXRfY2F0X2ZpbGVfY29uZmlnLCBOVUxMKTsKCglpZiAoYXJnYyAhPSAzICYmIGFyZ2MgIT0gMikKCQl1c2FnZV93aXRoX29wdGlvbnMoY2F0X2ZpbGVfdXNhZ2UsIG9wdGlvbnMpOwoKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgb3B0aW9ucywgY2F0X2ZpbGVfdXNhZ2UsIDApOwoKCWlmIChvcHQpIHsKCQlpZiAoYXJnYyA9PSAxKQoJCQlvYmpfbmFtZSA9IGFyZ3ZbMF07CgkJZWxzZQoJCQl1c2FnZV93aXRoX29wdGlvbnMoY2F0X2ZpbGVfdXNhZ2UsIG9wdGlvbnMpOwoJfQoJaWYgKCFvcHQgJiYgIWJhdGNoKSB7CgkJaWYgKGFyZ2MgPT0gMikgewoJCQlleHBfdHlwZSA9IGFyZ3ZbMF07CgkJCW9ial9uYW1lID0gYXJndlsxXTsKCQl9IGVsc2UKCQkJdXNhZ2Vfd2l0aF9vcHRpb25zKGNhdF9maWxlX3VzYWdlLCBvcHRpb25zKTsKCX0KCWlmIChiYXRjaCAmJiAob3B0IHx8IGFyZ2MpKSB7CgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGNhdF9maWxlX3VzYWdlLCBvcHRpb25zKTsKCX0KCglpZiAoYmF0Y2gpCgkJcmV0dXJuIGJhdGNoX29iamVjdHMoYmF0Y2gpOwoKCXJldHVybiBjYXRfb25lX2ZpbGUob3B0LCBleHBfdHlwZSwgb2JqX25hbWUpOwp9Cg==",
    "text": "/*\n * GIT - The information manager from hell\n *\n * Copyright (C) Linus Torvalds, 2005\n */\n#include \"cache.h\"\n#include \"exec_cmd.h\"\n#include \"tag.h\"\n#include \"tree.h\"\n#include \"builtin.h\"\n#include \"parse-options.h\"\n#include \"diff.h\"\n#include \"userdiff.h\"\n#include \"streaming.h\"\n\n#define BATCH 1\n#define BATCH_CHECK 2\n\nstatic void pprint_tag(const unsigned char *sha1, const char *buf, unsigned long size)\n{\n\t/* the parser in tag.c is useless here. */\n\tconst char *endp = buf + size;\n\tconst char *cp = buf;\n\n\twhile (cp < endp) {\n\t\tchar c = *cp++;\n\t\tif (c != '\\n')\n\t\t\tcontinue;\n\t\tif (7 <= endp - cp && !memcmp(\"tagger \", cp, 7)) {\n\t\t\tconst char *tagger = cp;\n\n\t\t\t/* Found the tagger line.  Copy out the contents\n\t\t\t * of the buffer so far.\n\t\t\t */\n\t\t\twrite_or_die(1, buf, cp - buf);\n\n\t\t\t/*\n\t\t\t * Do something intelligent, like pretty-printing\n\t\t\t * the date.\n\t\t\t */\n\t\t\twhile (cp < endp) {\n\t\t\t\tif (*cp++ == '\\n') {\n\t\t\t\t\t/* tagger to cp is a line\n\t\t\t\t\t * that has ident and time.\n\t\t\t\t\t */\n\t\t\t\t\tconst char *sp = tagger;\n\t\t\t\t\tchar *ep;\n\t\t\t\t\tunsigned long date;\n\t\t\t\t\tlong tz;\n\t\t\t\t\twhile (sp < cp && *sp != '>')\n\t\t\t\t\t\tsp++;\n\t\t\t\t\tif (sp == cp) {\n\t\t\t\t\t\t/* give up */\n\t\t\t\t\t\twrite_or_die(1, tagger,\n\t\t\t\t\t\t\t     cp - tagger);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\twhile (sp < cp &&\n\t\t\t\t\t       !('0' <= *sp && *sp <= '9'))\n\t\t\t\t\t\tsp++;\n\t\t\t\t\twrite_or_die(1, tagger, sp - tagger);\n\t\t\t\t\tdate = strtoul(sp, &ep, 10);\n\t\t\t\t\ttz = strtol(ep, NULL, 10);\n\t\t\t\t\tsp = show_date(date, tz, 0);\n\t\t\t\t\twrite_or_die(1, sp, strlen(sp));\n\t\t\t\t\txwrite(1, \"\\n\", 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (cp < endp && *cp == '\\n')\n\t\t\t/* end of header */\n\t\t\tbreak;\n\t}\n\t/* At this point, we have copied out the header up to the end of\n\t * the tagger line and cp points at one past \\n.  It could be the\n\t * next header line after the tagger line, or it could be another\n\t * \\n that marks the end of the headers.  We need to copy out the\n\t * remainder as is.\n\t */\n\tif (cp < endp)\n\t\twrite_or_die(1, cp, endp - cp);\n}\n\nstatic int cat_one_file(int opt, const char *exp_type, const char *obj_name)\n{\n\tunsigned char sha1[20];\n\tenum object_type type;\n\tchar *buf;\n\tunsigned long size;\n\tstruct object_context obj_context;\n\n\tif (get_sha1_with_context(obj_name, 0, sha1, &obj_context))\n\t\tdie(\"Not a valid object name %s\", obj_name);\n\n\tbuf = NULL;\n\tswitch (opt) {\n\tcase 't':\n\t\ttype = sha1_object_info(sha1, NULL);\n\t\tif (type > 0) {\n\t\t\tprintf(\"%s\\n\", typename(type));\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase 's':\n\t\ttype = sha1_object_info(sha1, &size);\n\t\tif (type > 0) {\n\t\t\tprintf(\"%lu\\n\", size);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase 'e':\n\t\treturn !has_sha1_file(sha1);\n\n\tcase 'p':\n\t\ttype = sha1_object_info(sha1, NULL);\n\t\tif (type < 0)\n\t\t\tdie(\"Not a valid object name %s\", obj_name);\n\n\t\t/* custom pretty-print here */\n\t\tif (type == OBJ_TREE) {\n\t\t\tconst char *ls_args[3] = { NULL };\n\t\t\tls_args[0] =  \"ls-tree\";\n\t\t\tls_args[1] =  obj_name;\n\t\t\treturn cmd_ls_tree(2, ls_args, NULL);\n\t\t}\n\n\t\tif (type == OBJ_BLOB)\n\t\t\treturn stream_blob_to_fd(1, sha1, NULL, 0);\n\t\tbuf = read_sha1_file(sha1, &type, &size);\n\t\tif (!buf)\n\t\t\tdie(\"Cannot read object %s\", obj_name);\n\t\tif (type == OBJ_TAG) {\n\t\t\tpprint_tag(sha1, buf, size);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* otherwise just spit out the data */\n\t\tbreak;\n\n\tcase 'c':\n\t\tif (!obj_context.path[0])\n\t\t\tdie(\"git cat-file --textconv %s: <object> must be <sha1:path>\",\n\t\t\t    obj_name);\n\n\t\tif (!textconv_object(obj_context.path, obj_context.mode, sha1, 1, &buf, &size))\n\t\t\tdie(\"git cat-file --textconv: unable to run textconv on %s\",\n\t\t\t    obj_name);\n\t\tbreak;\n\n\tcase 0:\n\t\tif (type_from_string(exp_type) == OBJ_BLOB) {\n\t\t\tunsigned char blob_sha1[20];\n\t\t\tif (sha1_object_info(sha1, NULL) == OBJ_TAG) {\n\t\t\t\tenum object_type type;\n\t\t\t\tunsigned long size;\n\t\t\t\tchar *buffer = read_sha1_file(sha1, &type, &size);\n\t\t\t\tif (memcmp(buffer, \"object \", 7) ||\n\t\t\t\t    get_sha1_hex(buffer + 7, blob_sha1))\n\t\t\t\t\tdie(\"%s not a valid tag\", sha1_to_hex(sha1));\n\t\t\t\tfree(buffer);\n\t\t\t} else\n\t\t\t\thashcpy(blob_sha1, sha1);\n\n\t\t\tif (sha1_object_info(blob_sha1, NULL) == OBJ_BLOB)\n\t\t\t\treturn stream_blob_to_fd(1, blob_sha1, NULL, 0);\n\t\t\t/*\n\t\t\t * we attempted to dereference a tag to a blob\n\t\t\t * and failed; there may be new dereference\n\t\t\t * mechanisms this code is not aware of.\n\t\t\t * fall-back to the usual case.\n\t\t\t */\n\t\t}\n\t\tbuf = read_object_with_reference(sha1, exp_type, &size, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tdie(\"git cat-file: unknown option: %s\", exp_type);\n\t}\n\n\tif (!buf)\n\t\tdie(\"git cat-file %s: bad file\", obj_name);\n\n\twrite_or_die(1, buf, size);\n\treturn 0;\n}\n\nstatic int batch_one_object(const char *obj_name, int print_contents)\n{\n\tunsigned char sha1[20];\n\tenum object_type type = 0;\n\tunsigned long size;\n\tvoid *contents = contents;\n\n\tif (!obj_name)\n\t   return 1;\n\n\tif (get_sha1(obj_name, sha1)) {\n\t\tprintf(\"%s missing\\n\", obj_name);\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\n\tif (print_contents == BATCH)\n\t\tcontents = read_sha1_file(sha1, &type, &size);\n\telse\n\t\ttype = sha1_object_info(sha1, &size);\n\n\tif (type <= 0) {\n\t\tprintf(\"%s missing\\n\", obj_name);\n\t\tfflush(stdout);\n\t\tif (print_contents == BATCH)\n\t\t\tfree(contents);\n\t\treturn 0;\n\t}\n\n\tprintf(\"%s %s %lu\\n\", sha1_to_hex(sha1), typename(type), size);\n\tfflush(stdout);\n\n\tif (print_contents == BATCH) {\n\t\twrite_or_die(1, contents, size);\n\t\tprintf(\"\\n\");\n\t\tfflush(stdout);\n\t\tfree(contents);\n\t}\n\n\treturn 0;\n}\n\nstatic int batch_objects(int print_contents)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\n\twhile (strbuf_getline(&buf, stdin, '\\n') != EOF) {\n\t\tint error = batch_one_object(buf.buf, print_contents);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const char * const cat_file_usage[] = {\n\tN_(\"git cat-file (-t|-s|-e|-p|<type>|--textconv) <object>\"),\n\tN_(\"git cat-file (--batch|--batch-check) < <list_of_objects>\"),\n\tNULL\n};\n\nstatic int git_cat_file_config(const char *var, const char *value, void *cb)\n{\n\tif (userdiff_config(var, value) < 0)\n\t\treturn -1;\n\n\treturn git_default_config(var, value, cb);\n}\n\nint cmd_cat_file(int argc, const char **argv, const char *prefix)\n{\n\tint opt = 0, batch = 0;\n\tconst char *exp_type = NULL, *obj_name = NULL;\n\n\tconst struct option options[] = {\n\t\tOPT_GROUP(N_(\"<type> can be one of: blob, tree, commit, tag\")),\n\t\tOPT_SET_INT('t', NULL, &opt, N_(\"show object type\"), 't'),\n\t\tOPT_SET_INT('s', NULL, &opt, N_(\"show object size\"), 's'),\n\t\tOPT_SET_INT('e', NULL, &opt,\n\t\t\t    N_(\"exit with zero when there's no error\"), 'e'),\n\t\tOPT_SET_INT('p', NULL, &opt, N_(\"pretty-print object's content\"), 'p'),\n\t\tOPT_SET_INT(0, \"textconv\", &opt,\n\t\t\t    N_(\"for blob objects, run textconv on object's content\"), 'c'),\n\t\tOPT_SET_INT(0, \"batch\", &batch,\n\t\t\t    N_(\"show info and content of objects fed from the standard input\"),\n\t\t\t    BATCH),\n\t\tOPT_SET_INT(0, \"batch-check\", &batch,\n\t\t\t    N_(\"show info about objects fed from the standard input\"),\n\t\t\t    BATCH_CHECK),\n\t\tOPT_END()\n\t};\n\n\tgit_config(git_cat_file_config, NULL);\n\n\tif (argc != 3 && argc != 2)\n\t\tusage_with_options(cat_file_usage, options);\n\n\targc = parse_options(argc, argv, prefix, options, cat_file_usage, 0);\n\n\tif (opt) {\n\t\tif (argc == 1)\n\t\t\tobj_name = argv[0];\n\t\telse\n\t\t\tusage_with_options(cat_file_usage, options);\n\t}\n\tif (!opt && !batch) {\n\t\tif (argc == 2) {\n\t\t\texp_type = argv[0];\n\t\t\tobj_name = argv[1];\n\t\t} else\n\t\t\tusage_with_options(cat_file_usage, options);\n\t}\n\tif (batch && (opt || argc)) {\n\t\tusage_with_options(cat_file_usage, options);\n\t}\n\n\tif (batch)\n\t\treturn batch_objects(batch);\n\n\treturn cat_one_file(opt, exp_type, obj_name);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00528ddc389212f045a7718ba55a26d723927f06",
  "sha1_ok": true,
  "size": 7405
}
