{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGdyZXAiCiAqCiAqIENvcHlyaWdodCAoYykgMjAwNiBKdW5pbyBDIEhhbWFubwogKi8KI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJibG9iLmgiCiNpbmNsdWRlICJ0cmVlLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAidHJlZS13YWxrLmgiCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCiNpbmNsdWRlICJ1c2VyZGlmZi5oIgojaW5jbHVkZSAiZ3JlcC5oIgojaW5jbHVkZSAicXVvdGUuaCIKCiNpZm5kZWYgTk9fUFRIUkVBRFMKI2luY2x1ZGUgInRocmVhZC11dGlscy5oIgojaW5jbHVkZSA8cHRocmVhZC5oPgojZW5kaWYKCnN0YXRpYyBjaGFyIGNvbnN0ICogY29uc3QgZ3JlcF91c2FnZVtdID0gewoJImdpdCBncmVwIFtvcHRpb25zXSBbLWVdIDxwYXR0ZXJuPiBbPHJldj4uLi5dIFtbLS1dIHBhdGguLi5dIiwKCU5VTEwKfTsKCnN0YXRpYyBpbnQgdXNlX3RocmVhZHMgPSAxOwoKI2lmbmRlZiBOT19QVEhSRUFEUwojZGVmaW5lIFRIUkVBRFMgOApzdGF0aWMgcHRocmVhZF90IHRocmVhZHNbVEhSRUFEU107CgpzdGF0aWMgdm9pZCAqbG9hZF9zaGExKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIHVuc2lnbmVkIGxvbmcgKnNpemUsCgkJICAgICAgIGNvbnN0IGNoYXIgKm5hbWUpOwpzdGF0aWMgdm9pZCAqbG9hZF9maWxlKGNvbnN0IGNoYXIgKmZpbGVuYW1lLCBzaXplX3QgKnN6KTsKCmVudW0gd29ya190eXBlIHtXT1JLX1NIQTEsIFdPUktfRklMRX07CgovKiBXZSB1c2Ugb25lIHByb2R1Y2VyIHRocmVhZCBhbmQgVEhSRUFEUyBjb25zdW1lcgogKiB0aHJlYWRzLiBUaGUgcHJvZHVjZXIgYWRkcyBzdHJ1Y3Qgd29ya19pdGVtcyB0byAndG9kbycgYW5kIHRoZQogKiBjb25zdW1lcnMgcGljayB3b3JrIGl0ZW1zIGZyb20gdGhlIHNhbWUgYXJyYXkuCiAqLwpzdHJ1Y3Qgd29ya19pdGVtCnsKCWVudW0gd29ya190eXBlIHR5cGU7CgljaGFyICpuYW1lOwoKCS8qIGlmIHR5cGUgPT0gV09SS19TSEExLCB0aGVuICdpZGVudGlmaWVyJyBpcyBhIFNIQTEsCgkgKiBvdGhlcndpc2UgdHlwZSA9PSBXT1JLX0ZJTEUsIGFuZCAnaWRlbnRpZmllcicgaXMgYSBOVUwKCSAqIHRlcm1pbmF0ZWQgZmlsZW5hbWUuCgkgKi8KCXZvaWQgKmlkZW50aWZpZXI7CgljaGFyIGRvbmU7CglzdHJ1Y3Qgc3RyYnVmIG91dDsKfTsKCi8qIEluIHRoZSByYW5nZSBbdG9kb19kb25lLCB0b2RvX3N0YXJ0KSBpbiAndG9kbycgd2UgaGF2ZSB3b3JrX2l0ZW1zCiAqIHRoYXQgaGF2ZSBiZWVuIG9yIGFyZSBwcm9jZXNzZWQgYnkgYSBjb25zdW1lciB0aHJlYWQuIFdlIGhhdmVuJ3QKICogd3JpdHRlbiB0aGUgcmVzdWx0IGZvciB0aGVzZSB0byBzdGRvdXQgeWV0LgogKgogKiBUaGUgd29ya19pdGVtcyBpbiBbdG9kb19zdGFydCwgdG9kb19lbmQpIGFyZSB3YWl0aW5nIHRvIGJlIHBpY2tlZAogKiB1cCBieSBhIGNvbnN1bWVyIHRocmVhZC4KICoKICogVGhlIHJhbmdlcyBhcmUgbW9kdWxvIFRPRE9fU0laRS4KICovCiNkZWZpbmUgVE9ET19TSVpFIDEyOApzdGF0aWMgc3RydWN0IHdvcmtfaXRlbSB0b2RvW1RPRE9fU0laRV07CnN0YXRpYyBpbnQgdG9kb19zdGFydDsKc3RhdGljIGludCB0b2RvX2VuZDsKc3RhdGljIGludCB0b2RvX2RvbmU7CgovKiBIYXMgYWxsIHdvcmsgaXRlbXMgYmVlbiBhZGRlZD8gKi8Kc3RhdGljIGludCBhbGxfd29ya19hZGRlZDsKCi8qIFRoaXMgbG9jayBwcm90ZWN0cyBhbGwgdGhlIHZhcmlhYmxlcyBhYm92ZS4gKi8Kc3RhdGljIHB0aHJlYWRfbXV0ZXhfdCBncmVwX211dGV4OwoKLyogVXNlZCB0byBzZXJpYWxpemUgY2FsbHMgdG8gcmVhZF9zaGExX2ZpbGUuICovCnN0YXRpYyBwdGhyZWFkX211dGV4X3QgcmVhZF9zaGExX211dGV4OwoKI2RlZmluZSBncmVwX2xvY2soKSBwdGhyZWFkX211dGV4X2xvY2soJmdyZXBfbXV0ZXgpCiNkZWZpbmUgZ3JlcF91bmxvY2soKSBwdGhyZWFkX211dGV4X3VubG9jaygmZ3JlcF9tdXRleCkKI2RlZmluZSByZWFkX3NoYTFfbG9jaygpIHB0aHJlYWRfbXV0ZXhfbG9jaygmcmVhZF9zaGExX211dGV4KQojZGVmaW5lIHJlYWRfc2hhMV91bmxvY2soKSBwdGhyZWFkX211dGV4X3VubG9jaygmcmVhZF9zaGExX211dGV4KQoKLyogU2lnbmFsbGVkIHdoZW4gYSBuZXcgd29ya19pdGVtIGlzIGFkZGVkIHRvIHRvZG8uICovCnN0YXRpYyBwdGhyZWFkX2NvbmRfdCBjb25kX2FkZDsKCi8qIFNpZ25hbGxlZCB3aGVuIHRoZSByZXN1bHQgZnJvbSBvbmUgd29ya19pdGVtIGlzIHdyaXR0ZW4gdG8KICogc3Rkb3V0LgogKi8Kc3RhdGljIHB0aHJlYWRfY29uZF90IGNvbmRfd3JpdGU7CgovKiBTaWduYWxsZWQgd2hlbiB3ZSBhcmUgZmluaXNoZWQgd2l0aCBldmVyeXRoaW5nLiAqLwpzdGF0aWMgcHRocmVhZF9jb25kX3QgY29uZF9yZXN1bHQ7CgpzdGF0aWMgdm9pZCBhZGRfd29yayhlbnVtIHdvcmtfdHlwZSB0eXBlLCBjaGFyICpuYW1lLCB2b2lkICppZCkKewoJZ3JlcF9sb2NrKCk7CgoJd2hpbGUgKCh0b2RvX2VuZCsxKSAlIEFSUkFZX1NJWkUodG9kbykgPT0gdG9kb19kb25lKSB7CgkJcHRocmVhZF9jb25kX3dhaXQoJmNvbmRfd3JpdGUsICZncmVwX211dGV4KTsKCX0KCgl0b2RvW3RvZG9fZW5kXS50eXBlID0gdHlwZTsKCXRvZG9bdG9kb19lbmRdLm5hbWUgPSBuYW1lOwoJdG9kb1t0b2RvX2VuZF0uaWRlbnRpZmllciA9IGlkOwoJdG9kb1t0b2RvX2VuZF0uZG9uZSA9IDA7CglzdHJidWZfcmVzZXQoJnRvZG9bdG9kb19lbmRdLm91dCk7Cgl0b2RvX2VuZCA9ICh0b2RvX2VuZCArIDEpICUgQVJSQVlfU0laRSh0b2RvKTsKCglwdGhyZWFkX2NvbmRfc2lnbmFsKCZjb25kX2FkZCk7CglncmVwX3VubG9jaygpOwp9CgpzdGF0aWMgc3RydWN0IHdvcmtfaXRlbSAqZ2V0X3dvcmsodm9pZCkKewoJc3RydWN0IHdvcmtfaXRlbSAqcmV0OwoKCWdyZXBfbG9jaygpOwoJd2hpbGUgKHRvZG9fc3RhcnQgPT0gdG9kb19lbmQgJiYgIWFsbF93b3JrX2FkZGVkKSB7CgkJcHRocmVhZF9jb25kX3dhaXQoJmNvbmRfYWRkLCAmZ3JlcF9tdXRleCk7Cgl9CgoJaWYgKHRvZG9fc3RhcnQgPT0gdG9kb19lbmQgJiYgYWxsX3dvcmtfYWRkZWQpIHsKCQlyZXQgPSBOVUxMOwoJfSBlbHNlIHsKCQlyZXQgPSAmdG9kb1t0b2RvX3N0YXJ0XTsKCQl0b2RvX3N0YXJ0ID0gKHRvZG9fc3RhcnQgKyAxKSAlIEFSUkFZX1NJWkUodG9kbyk7Cgl9CglncmVwX3VubG9jaygpOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIHZvaWQgZ3JlcF9zaGExX2FzeW5jKHN0cnVjdCBncmVwX29wdCAqb3B0LCBjaGFyICpuYW1lLAoJCQkgICAgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJdW5zaWduZWQgY2hhciAqczsKCXMgPSB4bWFsbG9jKDIwKTsKCW1lbWNweShzLCBzaGExLCAyMCk7CglhZGRfd29yayhXT1JLX1NIQTEsIG5hbWUsIHMpOwp9CgpzdGF0aWMgdm9pZCBncmVwX2ZpbGVfYXN5bmMoc3RydWN0IGdyZXBfb3B0ICpvcHQsIGNoYXIgKm5hbWUsCgkJCSAgICBjb25zdCBjaGFyICpmaWxlbmFtZSkKewoJYWRkX3dvcmsoV09SS19GSUxFLCBuYW1lLCB4c3RyZHVwKGZpbGVuYW1lKSk7Cn0KCnN0YXRpYyB2b2lkIHdvcmtfZG9uZShzdHJ1Y3Qgd29ya19pdGVtICp3KQp7CglpbnQgb2xkX2RvbmU7CgoJZ3JlcF9sb2NrKCk7Cgl3LT5kb25lID0gMTsKCW9sZF9kb25lID0gdG9kb19kb25lOwoJZm9yKDsgdG9kb1t0b2RvX2RvbmVdLmRvbmUgJiYgdG9kb19kb25lICE9IHRvZG9fc3RhcnQ7CgkgICAgdG9kb19kb25lID0gKHRvZG9fZG9uZSsxKSAlIEFSUkFZX1NJWkUodG9kbykpIHsKCQl3ID0gJnRvZG9bdG9kb19kb25lXTsKCQl3cml0ZV9vcl9kaWUoMSwgdy0+b3V0LmJ1Ziwgdy0+b3V0Lmxlbik7CgkJZnJlZSh3LT5uYW1lKTsKCQlmcmVlKHctPmlkZW50aWZpZXIpOwoJfQoKCWlmIChvbGRfZG9uZSAhPSB0b2RvX2RvbmUpCgkJcHRocmVhZF9jb25kX3NpZ25hbCgmY29uZF93cml0ZSk7CgoJaWYgKGFsbF93b3JrX2FkZGVkICYmIHRvZG9fZG9uZSA9PSB0b2RvX2VuZCkKCQlwdGhyZWFkX2NvbmRfc2lnbmFsKCZjb25kX3Jlc3VsdCk7CgoJZ3JlcF91bmxvY2soKTsKfQoKc3RhdGljIHZvaWQgKnJ1bih2b2lkICphcmcpCnsKCWludCBoaXQgPSAwOwoJc3RydWN0IGdyZXBfb3B0ICpvcHQgPSBhcmc7CgoJd2hpbGUgKDEpIHsKCQlzdHJ1Y3Qgd29ya19pdGVtICp3ID0gZ2V0X3dvcmsoKTsKCQlpZiAoIXcpCgkJCWJyZWFrOwoKCQlvcHQtPm91dHB1dF9wcml2ID0gdzsKCQlpZiAody0+dHlwZSA9PSBXT1JLX1NIQTEpIHsKCQkJdW5zaWduZWQgbG9uZyBzejsKCQkJdm9pZCogZGF0YSA9IGxvYWRfc2hhMSh3LT5pZGVudGlmaWVyLCAmc3osIHctPm5hbWUpOwoKCQkJaWYgKGRhdGEpIHsKCQkJCWhpdCB8PSBncmVwX2J1ZmZlcihvcHQsIHctPm5hbWUsIGRhdGEsIHN6KTsKCQkJCWZyZWUoZGF0YSk7CgkJCX0KCQl9IGVsc2UgaWYgKHctPnR5cGUgPT0gV09SS19GSUxFKSB7CgkJCXNpemVfdCBzejsKCQkJdm9pZCogZGF0YSA9IGxvYWRfZmlsZSh3LT5pZGVudGlmaWVyLCAmc3opOwoJCQlpZiAoZGF0YSkgewoJCQkJaGl0IHw9IGdyZXBfYnVmZmVyKG9wdCwgdy0+bmFtZSwgZGF0YSwgc3opOwoJCQkJZnJlZShkYXRhKTsKCQkJfQoJCX0gZWxzZSB7CgkJCWFzc2VydCgwKTsKCQl9CgoJCXdvcmtfZG9uZSh3KTsKCX0KCWZyZWVfZ3JlcF9wYXR0ZXJucyhhcmcpOwoJZnJlZShhcmcpOwoKCXJldHVybiAodm9pZCopIChpbnRwdHJfdCkgaGl0Owp9CgpzdGF0aWMgdm9pZCBzdHJidWZfb3V0KHN0cnVjdCBncmVwX29wdCAqb3B0LCBjb25zdCB2b2lkICpidWYsIHNpemVfdCBzaXplKQp7CglzdHJ1Y3Qgd29ya19pdGVtICp3ID0gb3B0LT5vdXRwdXRfcHJpdjsKCXN0cmJ1Zl9hZGQoJnctPm91dCwgYnVmLCBzaXplKTsKfQoKc3RhdGljIHZvaWQgc3RhcnRfdGhyZWFkcyhzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCkKewoJaW50IGk7CgoJcHRocmVhZF9tdXRleF9pbml0KCZncmVwX211dGV4LCBOVUxMKTsKCXB0aHJlYWRfbXV0ZXhfaW5pdCgmcmVhZF9zaGExX211dGV4LCBOVUxMKTsKCXB0aHJlYWRfY29uZF9pbml0KCZjb25kX2FkZCwgTlVMTCk7CglwdGhyZWFkX2NvbmRfaW5pdCgmY29uZF93cml0ZSwgTlVMTCk7CglwdGhyZWFkX2NvbmRfaW5pdCgmY29uZF9yZXN1bHQsIE5VTEwpOwoKCWZvciAoaSA9IDA7IGkgPCBBUlJBWV9TSVpFKHRvZG8pOyBpKyspIHsKCQlzdHJidWZfaW5pdCgmdG9kb1tpXS5vdXQsIDApOwoJfQoKCWZvciAoaSA9IDA7IGkgPCBBUlJBWV9TSVpFKHRocmVhZHMpOyBpKyspIHsKCQlpbnQgZXJyOwoJCXN0cnVjdCBncmVwX29wdCAqbyA9IGdyZXBfb3B0X2R1cChvcHQpOwoJCW8tPm91dHB1dCA9IHN0cmJ1Zl9vdXQ7CgkJY29tcGlsZV9ncmVwX3BhdHRlcm5zKG8pOwoJCWVyciA9IHB0aHJlYWRfY3JlYXRlKCZ0aHJlYWRzW2ldLCBOVUxMLCBydW4sIG8pOwoKCQlpZiAoZXJyKQoJCQlkaWUoImdyZXA6IGZhaWxlZCB0byBjcmVhdGUgdGhyZWFkOiAlcyIsCgkJCSAgICBzdHJlcnJvcihlcnIpKTsKCX0KfQoKc3RhdGljIGludCB3YWl0X2FsbCh2b2lkKQp7CglpbnQgaGl0ID0gMDsKCWludCBpOwoKCWdyZXBfbG9jaygpOwoJYWxsX3dvcmtfYWRkZWQgPSAxOwoKCS8qIFdhaXQgdW50aWwgYWxsIHdvcmsgaXMgZG9uZS4gKi8KCXdoaWxlICh0b2RvX2RvbmUgIT0gdG9kb19lbmQpCgkJcHRocmVhZF9jb25kX3dhaXQoJmNvbmRfcmVzdWx0LCAmZ3JlcF9tdXRleCk7CgoJLyogV2FrZSB1cCBhbGwgdGhlIGNvbnN1bWVyIHRocmVhZHMgc28gdGhleSBjYW4gc2VlIHRoYXQgdGhlcmUKCSAqIGlzIG5vIG1vcmUgd29yayB0byBkby4KCSAqLwoJcHRocmVhZF9jb25kX2Jyb2FkY2FzdCgmY29uZF9hZGQpOwoJZ3JlcF91bmxvY2soKTsKCglmb3IgKGkgPSAwOyBpIDwgQVJSQVlfU0laRSh0aHJlYWRzKTsgaSsrKSB7CgkJdm9pZCAqaDsKCQlwdGhyZWFkX2pvaW4odGhyZWFkc1tpXSwgJmgpOwoJCWhpdCB8PSAoaW50KSAoaW50cHRyX3QpIGg7Cgl9CgoJcHRocmVhZF9tdXRleF9kZXN0cm95KCZncmVwX211dGV4KTsKCXB0aHJlYWRfbXV0ZXhfZGVzdHJveSgmcmVhZF9zaGExX211dGV4KTsKCXB0aHJlYWRfY29uZF9kZXN0cm95KCZjb25kX2FkZCk7CglwdGhyZWFkX2NvbmRfZGVzdHJveSgmY29uZF93cml0ZSk7CglwdGhyZWFkX2NvbmRfZGVzdHJveSgmY29uZF9yZXN1bHQpOwoKCXJldHVybiBoaXQ7Cn0KI2Vsc2UgLyogIU5PX1BUSFJFQURTICovCiNkZWZpbmUgcmVhZF9zaGExX2xvY2soKQojZGVmaW5lIHJlYWRfc2hhMV91bmxvY2soKQoKc3RhdGljIGludCB3YWl0X2FsbCh2b2lkKQp7CglyZXR1cm4gMDsKfQojZW5kaWYKCnN0YXRpYyBpbnQgZ3JlcF9jb25maWcoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSwgdm9pZCAqY2IpCnsKCXN0cnVjdCBncmVwX29wdCAqb3B0ID0gY2I7CgoJc3dpdGNoICh1c2VyZGlmZl9jb25maWcodmFyLCB2YWx1ZSkpIHsKCWNhc2UgMDogYnJlYWs7CgljYXNlIC0xOiByZXR1cm4gLTE7CglkZWZhdWx0OiByZXR1cm4gMDsKCX0KCglpZiAoIXN0cmNtcCh2YXIsICJjb2xvci5ncmVwIikpIHsKCQlvcHQtPmNvbG9yID0gZ2l0X2NvbmZpZ19jb2xvcmJvb2wodmFyLCB2YWx1ZSwgLTEpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAodmFyLCAiY29sb3IuZ3JlcC5tYXRjaCIpKSB7CgkJaWYgKCF2YWx1ZSkKCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKHZhcik7CgkJY29sb3JfcGFyc2UodmFsdWUsIHZhciwgb3B0LT5jb2xvcl9tYXRjaCk7CgkJcmV0dXJuIDA7Cgl9CglyZXR1cm4gZ2l0X2NvbG9yX2RlZmF1bHRfY29uZmlnKHZhciwgdmFsdWUsIGNiKTsKfQoKLyoKICogUmV0dXJuIG5vbi16ZXJvIGlmIG1heF9kZXB0aCBpcyBuZWdhdGl2ZSBvciBwYXRoIGhhcyBubyBtb3JlIHRoZW4gbWF4X2RlcHRoCiAqIHNsYXNoZXMuCiAqLwpzdGF0aWMgaW50IGFjY2VwdF9zdWJkaXIoY29uc3QgY2hhciAqcGF0aCwgaW50IG1heF9kZXB0aCkKewoJaWYgKG1heF9kZXB0aCA8IDApCgkJcmV0dXJuIDE7CgoJd2hpbGUgKChwYXRoID0gc3RyY2hyKHBhdGgsICcvJykpICE9IE5VTEwpIHsKCQltYXhfZGVwdGgtLTsKCQlpZiAobWF4X2RlcHRoIDwgMCkKCQkJcmV0dXJuIDA7CgkJcGF0aCsrOwoJfQoJcmV0dXJuIDE7Cn0KCi8qCiAqIFJldHVybiBub24temVybyBpZiBuYW1lIGlzIGEgc3ViZGlyZWN0b3J5IG9mIG1hdGNoIGFuZCBpcyBub3QgdG9vIGRlZXAuCiAqLwpzdGF0aWMgaW50IGlzX3N1YmRpcihjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbiwKCQljb25zdCBjaGFyICptYXRjaCwgaW50IG1hdGNobGVuLCBpbnQgbWF4X2RlcHRoKQp7CglpZiAobWF0Y2hsZW4gPiBuYW1lbGVuIHx8IHN0cm5jbXAobmFtZSwgbWF0Y2gsIG1hdGNobGVuKSkKCQlyZXR1cm4gMDsKCglpZiAobmFtZVttYXRjaGxlbl0gPT0gJ1wwJykgLyogZXhhY3QgbWF0Y2ggKi8KCQlyZXR1cm4gMTsKCglpZiAoIW1hdGNobGVuIHx8IG1hdGNoW21hdGNobGVuLTFdID09ICcvJyB8fCBuYW1lW21hdGNobGVuXSA9PSAnLycpCgkJcmV0dXJuIGFjY2VwdF9zdWJkaXIobmFtZSArIG1hdGNobGVuICsgMSwgbWF4X2RlcHRoKTsKCglyZXR1cm4gMDsKfQoKLyoKICogZ2l0IGdyZXAgcGF0aHNwZWNzIGFyZSBzb21ld2hhdCBkaWZmZXJlbnQgZnJvbSBkaWZmLXRyZWUgcGF0aHNwZWNzOwogKiBwYXRobmFtZSB3aWxkY2FyZHMgYXJlIGFsbG93ZWQuCiAqLwpzdGF0aWMgaW50IHBhdGhzcGVjX21hdGNoZXMoY29uc3QgY2hhciAqKnBhdGhzLCBjb25zdCBjaGFyICpuYW1lLCBpbnQgbWF4X2RlcHRoKQp7CglpbnQgbmFtZWxlbiwgaTsKCWlmICghcGF0aHMgfHwgISpwYXRocykKCQlyZXR1cm4gYWNjZXB0X3N1YmRpcihuYW1lLCBtYXhfZGVwdGgpOwoJbmFtZWxlbiA9IHN0cmxlbihuYW1lKTsKCWZvciAoaSA9IDA7IHBhdGhzW2ldOyBpKyspIHsKCQljb25zdCBjaGFyICptYXRjaCA9IHBhdGhzW2ldOwoJCWludCBtYXRjaGxlbiA9IHN0cmxlbihtYXRjaCk7CgkJY29uc3QgY2hhciAqY3AsICptZXRhOwoKCQlpZiAoaXNfc3ViZGlyKG5hbWUsIG5hbWVsZW4sIG1hdGNoLCBtYXRjaGxlbiwgbWF4X2RlcHRoKSkKCQkJcmV0dXJuIDE7CgkJaWYgKCFmbm1hdGNoKG1hdGNoLCBuYW1lLCAwKSkKCQkJcmV0dXJuIDE7CgkJaWYgKG5hbWVbbmFtZWxlbi0xXSAhPSAnLycpCgkJCWNvbnRpbnVlOwoKCQkvKiBXZSBhcmUgYmVpbmcgYXNrZWQgaWYgdGhlIGRpcmVjdG9yeSAoIm5hbWUiKSBpcyB3b3J0aAoJCSAqIGRlc2NlbmRpbmcgaW50by4KCQkgKgoJCSAqIEZpbmQgdGhlIGxvbmdlc3QgbGVhZGluZyBkaXJlY3RvcnkgbmFtZSB0aGF0IGRvZXMKCQkgKiBub3QgaGF2ZSBtZXRhY2hhcmFjdGVyIGluIHRoZSBwYXRoc3BlYzsgdGhlIG5hbWUKCQkgKiB3ZSBhcmUgbG9va2luZyBhdCBtdXN0IG92ZXJsYXAgd2l0aCB0aGF0IGRpcmVjdG9yeS4KCQkgKi8KCQlmb3IgKGNwID0gbWF0Y2gsIG1ldGEgPSBOVUxMOyBjcCAtIG1hdGNoIDwgbWF0Y2hsZW47IGNwKyspIHsKCQkJY2hhciBjaCA9ICpjcDsKCQkJaWYgKGNoID09ICcqJyB8fCBjaCA9PSAnWycgfHwgY2ggPT0gJz8nKSB7CgkJCQltZXRhID0gY3A7CgkJCQlicmVhazsKCQkJfQoJCX0KCQlpZiAoIW1ldGEpCgkJCW1ldGEgPSBjcDsgLyogZnVsbHkgbGl0ZXJhbCAqLwoKCQlpZiAobmFtZWxlbiA8PSBtZXRhIC0gbWF0Y2gpIHsKCQkJLyogTG9va2luZyBhdCAiRG9jdW1lbnRhdGlvbi8iIGFuZAoJCQkgKiB0aGUgcGF0dGVybiBzYXlzICJEb2N1bWVudGF0aW9uL2hvd3RvLyIsIG9yCgkJCSAqICJEb2N1bWVudGF0aW9uL2RpZmYqLnR4dCIuICBUaGUgbmFtZSB3ZQoJCQkgKiBoYXZlIHNob3VsZCBtYXRjaCBwcmVmaXguCgkJCSAqLwoJCQlpZiAoIW1lbWNtcChtYXRjaCwgbmFtZSwgbmFtZWxlbikpCgkJCQlyZXR1cm4gMTsKCQkJY29udGludWU7CgkJfQoKCQlpZiAobWV0YSAtIG1hdGNoIDwgbmFtZWxlbikgewoJCQkvKiBMb29raW5nIGF0ICJEb2N1bWVudGF0aW9uL2hvd3RvLyIgYW5kCgkJCSAqIHRoZSBwYXR0ZXJuIHNheXMgIkRvY3VtZW50YXRpb24vaCoiOwoJCQkgKiBtYXRjaCB1cCB0byAiRG8uLi4vaCI7IHRoaXMgYXZvaWRzIGRlc2NlbmRpbmcKCQkJICogaW50byAiRG9jdW1lbnRhdGlvbi90ZWNobmljYWwvIi4KCQkJICovCgkJCWlmICghbWVtY21wKG1hdGNoLCBuYW1lLCBtZXRhIC0gbWF0Y2gpKQoJCQkJcmV0dXJuIDE7CgkJCWNvbnRpbnVlOwoJCX0KCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCAqbG9hZF9zaGExKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIHVuc2lnbmVkIGxvbmcgKnNpemUsCgkJICAgICAgIGNvbnN0IGNoYXIgKm5hbWUpCnsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCWNoYXIgKmRhdGE7CgoJcmVhZF9zaGExX2xvY2soKTsKCWRhdGEgPSByZWFkX3NoYTFfZmlsZShzaGExLCAmdHlwZSwgc2l6ZSk7CglyZWFkX3NoYTFfdW5sb2NrKCk7CgoJaWYgKCFkYXRhKQoJCWVycm9yKCInJXMnOiB1bmFibGUgdG8gcmVhZCAlcyIsIG5hbWUsIHNoYTFfdG9faGV4KHNoYTEpKTsKCglyZXR1cm4gZGF0YTsKfQoKc3RhdGljIGludCBncmVwX3NoYTEoc3RydWN0IGdyZXBfb3B0ICpvcHQsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsCgkJICAgICBjb25zdCBjaGFyICpmaWxlbmFtZSwgaW50IHRyZWVfbmFtZV9sZW4pCnsKCXN0cnVjdCBzdHJidWYgcGF0aGJ1ZiA9IFNUUkJVRl9JTklUOwoJY2hhciAqbmFtZTsKCglpZiAob3B0LT5yZWxhdGl2ZSAmJiBvcHQtPnByZWZpeF9sZW5ndGgpIHsKCQlxdW90ZV9wYXRoX3JlbGF0aXZlKGZpbGVuYW1lICsgdHJlZV9uYW1lX2xlbiwgLTEsICZwYXRoYnVmLAoJCQkJICAgIG9wdC0+cHJlZml4KTsKCQlzdHJidWZfaW5zZXJ0KCZwYXRoYnVmLCAwLCBmaWxlbmFtZSwgdHJlZV9uYW1lX2xlbik7Cgl9IGVsc2UgewoJCXN0cmJ1Zl9hZGRzdHIoJnBhdGhidWYsIGZpbGVuYW1lKTsKCX0KCgluYW1lID0gc3RyYnVmX2RldGFjaCgmcGF0aGJ1ZiwgTlVMTCk7CgojaWZuZGVmIE5PX1BUSFJFQURTCglpZiAodXNlX3RocmVhZHMpIHsKCQlncmVwX3NoYTFfYXN5bmMob3B0LCBuYW1lLCBzaGExKTsKCQlyZXR1cm4gMDsKCX0gZWxzZQojZW5kaWYKCXsKCQlpbnQgaGl0OwoJCXVuc2lnbmVkIGxvbmcgc3o7CgkJdm9pZCAqZGF0YSA9IGxvYWRfc2hhMShzaGExLCAmc3osIG5hbWUpOwoJCWlmICghZGF0YSkKCQkJaGl0ID0gMDsKCQllbHNlCgkJCWhpdCA9IGdyZXBfYnVmZmVyKG9wdCwgbmFtZSwgZGF0YSwgc3opOwoKCQlmcmVlKGRhdGEpOwoJCWZyZWUobmFtZSk7CgkJcmV0dXJuIGhpdDsKCX0KfQoKc3RhdGljIHZvaWQgKmxvYWRfZmlsZShjb25zdCBjaGFyICpmaWxlbmFtZSwgc2l6ZV90ICpzeikKewoJc3RydWN0IHN0YXQgc3Q7CgljaGFyICpkYXRhOwoJaW50IGk7CgoJaWYgKGxzdGF0KGZpbGVuYW1lLCAmc3QpIDwgMCkgewoJZXJyX3JldDoKCQlpZiAoZXJybm8gIT0gRU5PRU5UKQoJCQllcnJvcigiJyVzJzogJXMiLCBmaWxlbmFtZSwgc3RyZXJyb3IoZXJybm8pKTsKCQlyZXR1cm4gMDsKCX0KCWlmICghU19JU1JFRyhzdC5zdF9tb2RlKSkKCQlyZXR1cm4gMDsKCSpzeiA9IHhzaXplX3Qoc3Quc3Rfc2l6ZSk7CglpID0gb3BlbihmaWxlbmFtZSwgT19SRE9OTFkpOwoJaWYgKGkgPCAwKQoJCWdvdG8gZXJyX3JldDsKCWRhdGEgPSB4bWFsbG9jKCpzeiArIDEpOwoJaWYgKHN0LnN0X3NpemUgIT0gcmVhZF9pbl9mdWxsKGksIGRhdGEsICpzeikpIHsKCQllcnJvcigiJyVzJzogc2hvcnQgcmVhZCAlcyIsIGZpbGVuYW1lLCBzdHJlcnJvcihlcnJubykpOwoJCWNsb3NlKGkpOwoJCWZyZWUoZGF0YSk7CgkJcmV0dXJuIDA7Cgl9CgljbG9zZShpKTsKCWRhdGFbKnN6XSA9IDA7CglyZXR1cm4gZGF0YTsKfQoKc3RhdGljIGludCBncmVwX2ZpbGUoc3RydWN0IGdyZXBfb3B0ICpvcHQsIGNvbnN0IGNoYXIgKmZpbGVuYW1lKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJY2hhciAqbmFtZTsKCglpZiAob3B0LT5yZWxhdGl2ZSAmJiBvcHQtPnByZWZpeF9sZW5ndGgpCgkJcXVvdGVfcGF0aF9yZWxhdGl2ZShmaWxlbmFtZSwgLTEsICZidWYsIG9wdC0+cHJlZml4KTsKCWVsc2UKCQlzdHJidWZfYWRkc3RyKCZidWYsIGZpbGVuYW1lKTsKCW5hbWUgPSBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpOwoKI2lmbmRlZiBOT19QVEhSRUFEUwoJaWYgKHVzZV90aHJlYWRzKSB7CgkJZ3JlcF9maWxlX2FzeW5jKG9wdCwgbmFtZSwgZmlsZW5hbWUpOwoJCXJldHVybiAwOwoJfSBlbHNlCiNlbmRpZgoJewoJCWludCBoaXQ7CgkJc2l6ZV90IHN6OwoJCXZvaWQgKmRhdGEgPSBsb2FkX2ZpbGUoZmlsZW5hbWUsICZzeik7CgkJaWYgKCFkYXRhKQoJCQloaXQgPSAwOwoJCWVsc2UKCQkJaGl0ID0gZ3JlcF9idWZmZXIob3B0LCBuYW1lLCBkYXRhLCBzeik7CgoJCWZyZWUoZGF0YSk7CgkJZnJlZShuYW1lKTsKCQlyZXR1cm4gaGl0OwoJfQp9CgpzdGF0aWMgaW50IGdyZXBfY2FjaGUoc3RydWN0IGdyZXBfb3B0ICpvcHQsIGNvbnN0IGNoYXIgKipwYXRocywgaW50IGNhY2hlZCkKewoJaW50IGhpdCA9IDA7CglpbnQgbnI7CglyZWFkX2NhY2hlKCk7CgoJZm9yIChuciA9IDA7IG5yIDwgYWN0aXZlX25yOyBucisrKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGFjdGl2ZV9jYWNoZVtucl07CgkJaWYgKCFTX0lTUkVHKGNlLT5jZV9tb2RlKSkKCQkJY29udGludWU7CgkJaWYgKCFwYXRoc3BlY19tYXRjaGVzKHBhdGhzLCBjZS0+bmFtZSwgb3B0LT5tYXhfZGVwdGgpKQoJCQljb250aW51ZTsKCQkvKgoJCSAqIElmIENFX1ZBTElEIGlzIG9uLCB3ZSBhc3N1bWUgd29ya3RyZWUgZmlsZSBhbmQgaXRzIGNhY2hlIGVudHJ5CgkJICogYXJlIGlkZW50aWNhbCwgZXZlbiBpZiB3b3JrdHJlZSBmaWxlIGhhcyBiZWVuIG1vZGlmaWVkLCBzbyB1c2UKCQkgKiBjYWNoZSB2ZXJzaW9uIGluc3RlYWQKCQkgKi8KCQlpZiAoY2FjaGVkIHx8IChjZS0+Y2VfZmxhZ3MgJiBDRV9WQUxJRCkgfHwgY2Vfc2tpcF93b3JrdHJlZShjZSkpIHsKCQkJaWYgKGNlX3N0YWdlKGNlKSkKCQkJCWNvbnRpbnVlOwoJCQloaXQgfD0gZ3JlcF9zaGExKG9wdCwgY2UtPnNoYTEsIGNlLT5uYW1lLCAwKTsKCQl9CgkJZWxzZQoJCQloaXQgfD0gZ3JlcF9maWxlKG9wdCwgY2UtPm5hbWUpOwoJCWlmIChjZV9zdGFnZShjZSkpIHsKCQkJZG8gewoJCQkJbnIrKzsKCQkJfSB3aGlsZSAobnIgPCBhY3RpdmVfbnIgJiYKCQkJCSAhc3RyY21wKGNlLT5uYW1lLCBhY3RpdmVfY2FjaGVbbnJdLT5uYW1lKSk7CgkJCW5yLS07IC8qIGNvbXBlbnNhdGUgZm9yIGxvb3AgY29udHJvbCAqLwoJCX0KCQlpZiAoaGl0ICYmIG9wdC0+c3RhdHVzX29ubHkpCgkJCWJyZWFrOwoJfQoJZnJlZV9ncmVwX3BhdHRlcm5zKG9wdCk7CglyZXR1cm4gaGl0Owp9CgpzdGF0aWMgaW50IGdyZXBfdHJlZShzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCwgY29uc3QgY2hhciAqKnBhdGhzLAoJCSAgICAgc3RydWN0IHRyZWVfZGVzYyAqdHJlZSwKCQkgICAgIGNvbnN0IGNoYXIgKnRyZWVfbmFtZSwgY29uc3QgY2hhciAqYmFzZSkKewoJaW50IGxlbjsKCWludCBoaXQgPSAwOwoJc3RydWN0IG5hbWVfZW50cnkgZW50cnk7CgljaGFyICpkb3duOwoJaW50IHRuX2xlbiA9IHN0cmxlbih0cmVlX25hbWUpOwoJc3RydWN0IHN0cmJ1ZiBwYXRoYnVmOwoKCXN0cmJ1Zl9pbml0KCZwYXRoYnVmLCBQQVRIX01BWCArIHRuX2xlbik7CgoJaWYgKHRuX2xlbikgewoJCXN0cmJ1Zl9hZGQoJnBhdGhidWYsIHRyZWVfbmFtZSwgdG5fbGVuKTsKCQlzdHJidWZfYWRkY2goJnBhdGhidWYsICc6Jyk7CgkJdG5fbGVuID0gcGF0aGJ1Zi5sZW47Cgl9CglzdHJidWZfYWRkc3RyKCZwYXRoYnVmLCBiYXNlKTsKCWxlbiA9IHBhdGhidWYubGVuOwoKCXdoaWxlICh0cmVlX2VudHJ5KHRyZWUsICZlbnRyeSkpIHsKCQlpbnQgdGVfbGVuID0gdHJlZV9lbnRyeV9sZW4oZW50cnkucGF0aCwgZW50cnkuc2hhMSk7CgkJcGF0aGJ1Zi5sZW4gPSBsZW47CgkJc3RyYnVmX2FkZCgmcGF0aGJ1ZiwgZW50cnkucGF0aCwgdGVfbGVuKTsKCgkJaWYgKFNfSVNESVIoZW50cnkubW9kZSkpCgkJCS8qIE1hdGNoICJhYmMvIiBhZ2FpbnN0IHBhdGhzcGVjIHRvCgkJCSAqIGRlY2lkZSBpZiB3ZSB3YW50IHRvIGRlc2NlbmQgaW50byAiYWJjIgoJCQkgKiBkaXJlY3RvcnkuCgkJCSAqLwoJCQlzdHJidWZfYWRkY2goJnBhdGhidWYsICcvJyk7CgoJCWRvd24gPSBwYXRoYnVmLmJ1ZiArIHRuX2xlbjsKCQlpZiAoIXBhdGhzcGVjX21hdGNoZXMocGF0aHMsIGRvd24sIG9wdC0+bWF4X2RlcHRoKSkKCQkJOwoJCWVsc2UgaWYgKFNfSVNSRUcoZW50cnkubW9kZSkpCgkJCWhpdCB8PSBncmVwX3NoYTEob3B0LCBlbnRyeS5zaGExLCBwYXRoYnVmLmJ1ZiwgdG5fbGVuKTsKCQllbHNlIGlmIChTX0lTRElSKGVudHJ5Lm1vZGUpKSB7CgkJCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCQkJc3RydWN0IHRyZWVfZGVzYyBzdWI7CgkJCXZvaWQgKmRhdGE7CgkJCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCgkJCXJlYWRfc2hhMV9sb2NrKCk7CgkJCWRhdGEgPSByZWFkX3NoYTFfZmlsZShlbnRyeS5zaGExLCAmdHlwZSwgJnNpemUpOwoJCQlyZWFkX3NoYTFfdW5sb2NrKCk7CgoJCQlpZiAoIWRhdGEpCgkJCQlkaWUoInVuYWJsZSB0byByZWFkIHRyZWUgKCVzKSIsCgkJCQkgICAgc2hhMV90b19oZXgoZW50cnkuc2hhMSkpOwoJCQlpbml0X3RyZWVfZGVzYygmc3ViLCBkYXRhLCBzaXplKTsKCQkJaGl0IHw9IGdyZXBfdHJlZShvcHQsIHBhdGhzLCAmc3ViLCB0cmVlX25hbWUsIGRvd24pOwoJCQlmcmVlKGRhdGEpOwoJCX0KCQlpZiAoaGl0ICYmIG9wdC0+c3RhdHVzX29ubHkpCgkJCWJyZWFrOwoJfQoJc3RyYnVmX3JlbGVhc2UoJnBhdGhidWYpOwoJcmV0dXJuIGhpdDsKfQoKc3RhdGljIGludCBncmVwX29iamVjdChzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCwgY29uc3QgY2hhciAqKnBhdGhzLAoJCSAgICAgICBzdHJ1Y3Qgb2JqZWN0ICpvYmosIGNvbnN0IGNoYXIgKm5hbWUpCnsKCWlmIChvYmotPnR5cGUgPT0gT0JKX0JMT0IpCgkJcmV0dXJuIGdyZXBfc2hhMShvcHQsIG9iai0+c2hhMSwgbmFtZSwgMCk7CglpZiAob2JqLT50eXBlID09IE9CSl9DT01NSVQgfHwgb2JqLT50eXBlID09IE9CSl9UUkVFKSB7CgkJc3RydWN0IHRyZWVfZGVzYyB0cmVlOwoJCXZvaWQgKmRhdGE7CgkJdW5zaWduZWQgbG9uZyBzaXplOwoJCWludCBoaXQ7CgkJZGF0YSA9IHJlYWRfb2JqZWN0X3dpdGhfcmVmZXJlbmNlKG9iai0+c2hhMSwgdHJlZV90eXBlLAoJCQkJCQkgICZzaXplLCBOVUxMKTsKCQlpZiAoIWRhdGEpCgkJCWRpZSgidW5hYmxlIHRvIHJlYWQgdHJlZSAoJXMpIiwgc2hhMV90b19oZXgob2JqLT5zaGExKSk7CgkJaW5pdF90cmVlX2Rlc2MoJnRyZWUsIGRhdGEsIHNpemUpOwoJCWhpdCA9IGdyZXBfdHJlZShvcHQsIHBhdGhzLCAmdHJlZSwgbmFtZSwgIiIpOwoJCWZyZWUoZGF0YSk7CgkJcmV0dXJuIGhpdDsKCX0KCWRpZSgidW5hYmxlIHRvIGdyZXAgZnJvbSBvYmplY3Qgb2YgdHlwZSAlcyIsIHR5cGVuYW1lKG9iai0+dHlwZSkpOwp9CgpzdGF0aWMgaW50IGNvbnRleHRfY2FsbGJhY2soY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsCgkJCSAgICBpbnQgdW5zZXQpCnsKCXN0cnVjdCBncmVwX29wdCAqZ3JlcF9vcHQgPSBvcHQtPnZhbHVlOwoJaW50IHZhbHVlOwoJY29uc3QgY2hhciAqZW5kcDsKCglpZiAodW5zZXQpIHsKCQlncmVwX29wdC0+cHJlX2NvbnRleHQgPSBncmVwX29wdC0+cG9zdF9jb250ZXh0ID0gMDsKCQlyZXR1cm4gMDsKCX0KCXZhbHVlID0gc3RydG9sKGFyZywgKGNoYXIgKiopJmVuZHAsIDEwKTsKCWlmICgqZW5kcCkgewoJCXJldHVybiBlcnJvcigic3dpdGNoIGAlYycgZXhwZWN0cyBhIG51bWVyaWNhbCB2YWx1ZSIsCgkJCSAgICAgb3B0LT5zaG9ydF9uYW1lKTsKCX0KCWdyZXBfb3B0LT5wcmVfY29udGV4dCA9IGdyZXBfb3B0LT5wb3N0X2NvbnRleHQgPSB2YWx1ZTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGZpbGVfY2FsbGJhY2soY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJc3RydWN0IGdyZXBfb3B0ICpncmVwX29wdCA9IG9wdC0+dmFsdWU7CglGSUxFICpwYXR0ZXJuczsKCWludCBsbm8gPSAwOwoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoKCXBhdHRlcm5zID0gZm9wZW4oYXJnLCAiciIpOwoJaWYgKCFwYXR0ZXJucykKCQlkaWVfZXJybm8oImNhbm5vdCBvcGVuICclcyciLCBhcmcpOwoJd2hpbGUgKHN0cmJ1Zl9nZXRsaW5lKCZzYiwgcGF0dGVybnMsICdcbicpID09IDApIHsKCQkvKiBpZ25vcmUgZW1wdHkgbGluZSBsaWtlIGdyZXAgZG9lcyAqLwoJCWlmIChzYi5sZW4gPT0gMCkKCQkJY29udGludWU7CgkJYXBwZW5kX2dyZXBfcGF0dGVybihncmVwX29wdCwgc3RyYnVmX2RldGFjaCgmc2IsIE5VTEwpLCBhcmcsCgkJCQkgICAgKytsbm8sIEdSRVBfUEFUVEVSTik7Cgl9CglmY2xvc2UocGF0dGVybnMpOwoJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IG5vdF9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglzdHJ1Y3QgZ3JlcF9vcHQgKmdyZXBfb3B0ID0gb3B0LT52YWx1ZTsKCWFwcGVuZF9ncmVwX3BhdHRlcm4oZ3JlcF9vcHQsICItLW5vdCIsICJjb21tYW5kIGxpbmUiLCAwLCBHUkVQX05PVCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBhbmRfY2FsbGJhY2soY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJc3RydWN0IGdyZXBfb3B0ICpncmVwX29wdCA9IG9wdC0+dmFsdWU7CglhcHBlbmRfZ3JlcF9wYXR0ZXJuKGdyZXBfb3B0LCAiLS1hbmQiLCAiY29tbWFuZCBsaW5lIiwgMCwgR1JFUF9BTkQpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgb3Blbl9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglzdHJ1Y3QgZ3JlcF9vcHQgKmdyZXBfb3B0ID0gb3B0LT52YWx1ZTsKCWFwcGVuZF9ncmVwX3BhdHRlcm4oZ3JlcF9vcHQsICIoIiwgImNvbW1hbmQgbGluZSIsIDAsIEdSRVBfT1BFTl9QQVJFTik7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBjbG9zZV9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglzdHJ1Y3QgZ3JlcF9vcHQgKmdyZXBfb3B0ID0gb3B0LT52YWx1ZTsKCWFwcGVuZF9ncmVwX3BhdHRlcm4oZ3JlcF9vcHQsICIpIiwgImNvbW1hbmQgbGluZSIsIDAsIEdSRVBfQ0xPU0VfUEFSRU4pOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgcGF0dGVybl9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywKCQkJICAgIGludCB1bnNldCkKewoJc3RydWN0IGdyZXBfb3B0ICpncmVwX29wdCA9IG9wdC0+dmFsdWU7CglhcHBlbmRfZ3JlcF9wYXR0ZXJuKGdyZXBfb3B0LCBhcmcsICItZSBvcHRpb24iLCAwLCBHUkVQX1BBVFRFUk4pOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgaGVscF9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglyZXR1cm4gLTE7Cn0KCmludCBjbWRfZ3JlcChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJaW50IGhpdCA9IDA7CglpbnQgY2FjaGVkID0gMDsKCWludCBzZWVuX2Rhc2hkYXNoID0gMDsKCWludCBleHRlcm5hbF9ncmVwX2FsbG93ZWRfX2lnbm9yZWQ7CglzdHJ1Y3QgZ3JlcF9vcHQgb3B0OwoJc3RydWN0IG9iamVjdF9hcnJheSBsaXN0ID0geyAwLCAwLCBOVUxMIH07Cgljb25zdCBjaGFyICoqcGF0aHMgPSBOVUxMOwoJaW50IGk7CglpbnQgZHVtbXk7CglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfQk9PTEVBTigwLCAiY2FjaGVkIiwgJmNhY2hlZCwKCQkJInNlYXJjaCBpbiBpbmRleCBpbnN0ZWFkIG9mIGluIHRoZSB3b3JrIHRyZWUiKSwKCQlPUFRfR1JPVVAoIiIpLAoJCU9QVF9CT09MRUFOKCd2JywgImludmVydC1tYXRjaCIsICZvcHQuaW52ZXJ0LAoJCQkic2hvdyBub24tbWF0Y2hpbmcgbGluZXMiKSwKCQlPUFRfQk9PTEVBTignaScsICJpZ25vcmUtY2FzZSIsICZvcHQuaWdub3JlX2Nhc2UsCgkJCSJjYXNlIGluc2Vuc2l0aXZlIG1hdGNoaW5nIiksCgkJT1BUX0JPT0xFQU4oJ3cnLCAid29yZC1yZWdleHAiLCAmb3B0LndvcmRfcmVnZXhwLAoJCQkibWF0Y2ggcGF0dGVybnMgb25seSBhdCB3b3JkIGJvdW5kYXJpZXMiKSwKCQlPUFRfU0VUX0lOVCgnYScsICJ0ZXh0IiwgJm9wdC5iaW5hcnksCgkJCSJwcm9jZXNzIGJpbmFyeSBmaWxlcyBhcyB0ZXh0IiwgR1JFUF9CSU5BUllfVEVYVCksCgkJT1BUX1NFVF9JTlQoJ0knLCBOVUxMLCAmb3B0LmJpbmFyeSwKCQkJImRvbid0IG1hdGNoIHBhdHRlcm5zIGluIGJpbmFyeSBmaWxlcyIsCgkJCUdSRVBfQklOQVJZX05PTUFUQ0gpLAoJCXsgT1BUSU9OX0lOVEVHRVIsIDAsICJtYXgtZGVwdGgiLCAmb3B0Lm1heF9kZXB0aCwgImRlcHRoIiwKCQkJImRlc2NlbmQgYXQgbW9zdCA8ZGVwdGg+IGxldmVscyIsIFBBUlNFX09QVF9OT05FRywKCQkJTlVMTCwgMSB9LAoJCU9QVF9HUk9VUCgiIiksCgkJT1BUX0JJVCgnRScsICJleHRlbmRlZC1yZWdleHAiLCAmb3B0LnJlZ2ZsYWdzLAoJCQkidXNlIGV4dGVuZGVkIFBPU0lYIHJlZ3VsYXIgZXhwcmVzc2lvbnMiLCBSRUdfRVhURU5ERUQpLAoJCU9QVF9ORUdCSVQoJ0cnLCAiYmFzaWMtcmVnZXhwIiwgJm9wdC5yZWdmbGFncywKCQkJInVzZSBiYXNpYyBQT1NJWCByZWd1bGFyIGV4cHJlc3Npb25zIChkZWZhdWx0KSIsCgkJCVJFR19FWFRFTkRFRCksCgkJT1BUX0JPT0xFQU4oJ0YnLCAiZml4ZWQtc3RyaW5ncyIsICZvcHQuZml4ZWQsCgkJCSJpbnRlcnByZXQgcGF0dGVybnMgYXMgZml4ZWQgc3RyaW5ncyIpLAoJCU9QVF9HUk9VUCgiIiksCgkJT1BUX0JPT0xFQU4oJ24nLCBOVUxMLCAmb3B0LmxpbmVudW0sICJzaG93IGxpbmUgbnVtYmVycyIpLAoJCU9QVF9ORUdCSVQoJ2gnLCBOVUxMLCAmb3B0LnBhdGhuYW1lLCAiZG9uJ3Qgc2hvdyBmaWxlbmFtZXMiLCAxKSwKCQlPUFRfQklUKCdIJywgTlVMTCwgJm9wdC5wYXRobmFtZSwgInNob3cgZmlsZW5hbWVzIiwgMSksCgkJT1BUX05FR0JJVCgwLCAiZnVsbC1uYW1lIiwgJm9wdC5yZWxhdGl2ZSwKCQkJInNob3cgZmlsZW5hbWVzIHJlbGF0aXZlIHRvIHRvcCBkaXJlY3RvcnkiLCAxKSwKCQlPUFRfQk9PTEVBTignbCcsICJmaWxlcy13aXRoLW1hdGNoZXMiLCAmb3B0Lm5hbWVfb25seSwKCQkJInNob3cgb25seSBmaWxlbmFtZXMgaW5zdGVhZCBvZiBtYXRjaGluZyBsaW5lcyIpLAoJCU9QVF9CT09MRUFOKDAsICJuYW1lLW9ubHkiLCAmb3B0Lm5hbWVfb25seSwKCQkJInN5bm9ueW0gZm9yIC0tZmlsZXMtd2l0aC1tYXRjaGVzIiksCgkJT1BUX0JPT0xFQU4oJ0wnLCAiZmlsZXMtd2l0aG91dC1tYXRjaCIsCgkJCSZvcHQudW5tYXRjaF9uYW1lX29ubHksCgkJCSJzaG93IG9ubHkgdGhlIG5hbWVzIG9mIGZpbGVzIHdpdGhvdXQgbWF0Y2giKSwKCQlPUFRfQk9PTEVBTigneicsICJudWxsIiwgJm9wdC5udWxsX2ZvbGxvd2luZ19uYW1lLAoJCQkicHJpbnQgTlVMIGFmdGVyIGZpbGVuYW1lcyIpLAoJCU9QVF9CT09MRUFOKCdjJywgImNvdW50IiwgJm9wdC5jb3VudCwKCQkJInNob3cgdGhlIG51bWJlciBvZiBtYXRjaGVzIGluc3RlYWQgb2YgbWF0Y2hpbmcgbGluZXMiKSwKCQlPUFRfX0NPTE9SKCZvcHQuY29sb3IsICJoaWdobGlnaHQgbWF0Y2hlcyIpLAoJCU9QVF9HUk9VUCgiIiksCgkJT1BUX0NBTExCQUNLKCdDJywgTlVMTCwgJm9wdCwgIm4iLAoJCQkic2hvdyA8bj4gY29udGV4dCBsaW5lcyBiZWZvcmUgYW5kIGFmdGVyIG1hdGNoZXMiLAoJCQljb250ZXh0X2NhbGxiYWNrKSwKCQlPUFRfSU5URUdFUignQicsIE5VTEwsICZvcHQucHJlX2NvbnRleHQsCgkJCSJzaG93IDxuPiBjb250ZXh0IGxpbmVzIGJlZm9yZSBtYXRjaGVzIiksCgkJT1BUX0lOVEVHRVIoJ0EnLCBOVUxMLCAmb3B0LnBvc3RfY29udGV4dCwKCQkJInNob3cgPG4+IGNvbnRleHQgbGluZXMgYWZ0ZXIgbWF0Y2hlcyIpLAoJCU9QVF9OVU1CRVJfQ0FMTEJBQ0soJm9wdCwgInNob3J0Y3V0IGZvciAtQyBOVU0iLAoJCQljb250ZXh0X2NhbGxiYWNrKSwKCQlPUFRfQk9PTEVBTigncCcsICJzaG93LWZ1bmN0aW9uIiwgJm9wdC5mdW5jbmFtZSwKCQkJInNob3cgYSBsaW5lIHdpdGggdGhlIGZ1bmN0aW9uIG5hbWUgYmVmb3JlIG1hdGNoZXMiKSwKCQlPUFRfR1JPVVAoIiIpLAoJCU9QVF9DQUxMQkFDSygnZicsIE5VTEwsICZvcHQsICJmaWxlIiwKCQkJInJlYWQgcGF0dGVybnMgZnJvbSBmaWxlIiwgZmlsZV9jYWxsYmFjayksCgkJeyBPUFRJT05fQ0FMTEJBQ0ssICdlJywgTlVMTCwgJm9wdCwgInBhdHRlcm4iLAoJCQkibWF0Y2ggPHBhdHRlcm4+IiwgUEFSU0VfT1BUX05PTkVHLCBwYXR0ZXJuX2NhbGxiYWNrIH0sCgkJeyBPUFRJT05fQ0FMTEJBQ0ssIDAsICJhbmQiLCAmb3B0LCBOVUxMLAoJCSAgImNvbWJpbmUgcGF0dGVybnMgc3BlY2lmaWVkIHdpdGggLWUiLAoJCSAgUEFSU0VfT1BUX05PQVJHIHwgUEFSU0VfT1BUX05PTkVHLCBhbmRfY2FsbGJhY2sgfSwKCQlPUFRfQk9PTEVBTigwLCAib3IiLCAmZHVtbXksICIiKSwKCQl7IE9QVElPTl9DQUxMQkFDSywgMCwgIm5vdCIsICZvcHQsIE5VTEwsICIiLAoJCSAgUEFSU0VfT1BUX05PQVJHIHwgUEFSU0VfT1BUX05PTkVHLCBub3RfY2FsbGJhY2sgfSwKCQl7IE9QVElPTl9DQUxMQkFDSywgJygnLCBOVUxMLCAmb3B0LCBOVUxMLCAiIiwKCQkgIFBBUlNFX09QVF9OT0FSRyB8IFBBUlNFX09QVF9OT05FRyB8IFBBUlNFX09QVF9OT0RBU0gsCgkJICBvcGVuX2NhbGxiYWNrIH0sCgkJeyBPUFRJT05fQ0FMTEJBQ0ssICcpJywgTlVMTCwgJm9wdCwgTlVMTCwgIiIsCgkJICBQQVJTRV9PUFRfTk9BUkcgfCBQQVJTRV9PUFRfTk9ORUcgfCBQQVJTRV9PUFRfTk9EQVNILAoJCSAgY2xvc2VfY2FsbGJhY2sgfSwKCQlPUFRfQk9PTEVBTigncScsICJxdWlldCIsICZvcHQuc3RhdHVzX29ubHksCgkJCSAgICAiaW5kaWNhdGUgaGl0IHdpdGggZXhpdCBzdGF0dXMgd2l0aG91dCBvdXRwdXQiKSwKCQlPUFRfQk9PTEVBTigwLCAiYWxsLW1hdGNoIiwgJm9wdC5hbGxfbWF0Y2gsCgkJCSJzaG93IG9ubHkgbWF0Y2hlcyBmcm9tIGZpbGVzIHRoYXQgbWF0Y2ggYWxsIHBhdHRlcm5zIiksCgkJT1BUX0dST1VQKCIiKSwKCQlPUFRfQk9PTEVBTigwLCAiZXh0LWdyZXAiLCAmZXh0ZXJuYWxfZ3JlcF9hbGxvd2VkX19pZ25vcmVkLAoJCQkgICAgImFsbG93IGNhbGxpbmcgb2YgZ3JlcCgxKSAoaWdub3JlZCBieSB0aGlzIGJ1aWxkKSIpLAoJCXsgT1BUSU9OX0NBTExCQUNLLCAwLCAiaGVscC1hbGwiLCAmb3B0aW9ucywgTlVMTCwgInNob3cgdXNhZ2UiLAoJCSAgUEFSU0VfT1BUX0hJRERFTiB8IFBBUlNFX09QVF9OT0FSRywgaGVscF9jYWxsYmFjayB9LAoJCU9QVF9FTkQoKQoJfTsKCgkvKgoJICogJ2dpdCBncmVwIC1oJywgdW5saWtlICdnaXQgZ3JlcCAtaCA8cGF0dGVybj4nLCBpcyBhIHJlcXVlc3QKCSAqIHRvIHNob3cgdXNhZ2UgaW5mb3JtYXRpb24gYW5kIGV4aXQuCgkgKi8KCWlmIChhcmdjID09IDIgJiYgIXN0cmNtcChhcmd2WzFdLCAiLWgiKSkKCQl1c2FnZV93aXRoX29wdGlvbnMoZ3JlcF91c2FnZSwgb3B0aW9ucyk7CgoJbWVtc2V0KCZvcHQsIDAsIHNpemVvZihvcHQpKTsKCW9wdC5wcmVmaXggPSBwcmVmaXg7CglvcHQucHJlZml4X2xlbmd0aCA9IChwcmVmaXggJiYgKnByZWZpeCkgPyBzdHJsZW4ocHJlZml4KSA6IDA7CglvcHQucmVsYXRpdmUgPSAxOwoJb3B0LnBhdGhuYW1lID0gMTsKCW9wdC5wYXR0ZXJuX3RhaWwgPSAmb3B0LnBhdHRlcm5fbGlzdDsKCW9wdC5yZWdmbGFncyA9IFJFR19ORVdMSU5FOwoJb3B0Lm1heF9kZXB0aCA9IC0xOwoKCXN0cmNweShvcHQuY29sb3JfbWF0Y2gsIEdJVF9DT0xPUl9SRUQgR0lUX0NPTE9SX0JPTEQpOwoJb3B0LmNvbG9yID0gLTE7CglnaXRfY29uZmlnKGdyZXBfY29uZmlnLCAmb3B0KTsKCWlmIChvcHQuY29sb3IgPT0gLTEpCgkJb3B0LmNvbG9yID0gZ2l0X3VzZV9jb2xvcl9kZWZhdWx0OwoKCS8qCgkgKiBJZiB0aGVyZSBpcyBubyAtLSB0aGVuIHRoZSBwYXRocyBtdXN0IGV4aXN0IGluIHRoZSB3b3JraW5nCgkgKiB0cmVlLiAgSWYgdGhlcmUgaXMgbm8gZXhwbGljaXQgcGF0dGVybiBzcGVjaWZpZWQgd2l0aCAtZSBvcgoJICogLWYsIHdlIHRha2UgdGhlIGZpcnN0IHVucmVjb2duaXplZCBub24gb3B0aW9uIHRvIGJlIHRoZQoJICogcGF0dGVybiwgYnV0IHRoZW4gd2hhdCBmb2xsb3dzIGl0IG11c3QgYmUgemVybyBvciBtb3JlCgkgKiB2YWxpZCByZWZzIHVwIHRvIHRoZSAtLSAoaWYgZXhpc3RzKSwgYW5kIHRoZW4gZXhpc3RpbmcKCSAqIHBhdGhzLiAgSWYgdGhlcmUgaXMgYW4gZXhwbGljaXQgcGF0dGVybiwgdGhlbiB0aGUgZmlyc3QKCSAqIHVucmVjb2duaXplZCBub24gb3B0aW9uIGlzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlZnMgbGlzdAoJICogdGhhdCBjb250aW51ZXMgdXAgdG8gdGhlIC0tIChpZiBleGlzdHMpLCBhbmQgdGhlbiBwYXRocy4KCSAqLwoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBvcHRpb25zLCBncmVwX3VzYWdlLAoJCQkgICAgIFBBUlNFX09QVF9LRUVQX0RBU0hEQVNIIHwKCQkJICAgICBQQVJTRV9PUFRfU1RPUF9BVF9OT05fT1BUSU9OIHwKCQkJICAgICBQQVJTRV9PUFRfTk9fSU5URVJOQUxfSEVMUCk7CgoJLyogRmlyc3QgdW5yZWNvZ25pemVkIG5vbi1vcHRpb24gdG9rZW4gKi8KCWlmIChhcmdjID4gMCAmJiAhb3B0LnBhdHRlcm5fbGlzdCkgewoJCWFwcGVuZF9ncmVwX3BhdHRlcm4oJm9wdCwgYXJndlswXSwgImNvbW1hbmQgbGluZSIsIDAsCgkJCQkgICAgR1JFUF9QQVRURVJOKTsKCQlhcmd2Kys7CgkJYXJnYy0tOwoJfQoKCWlmICghb3B0LnBhdHRlcm5fbGlzdCkKCQlkaWUoIm5vIHBhdHRlcm4gZ2l2ZW4uIik7CglpZiAoIW9wdC5maXhlZCAmJiBvcHQuaWdub3JlX2Nhc2UpCgkJb3B0LnJlZ2ZsYWdzIHw9IFJFR19JQ0FTRTsKCWlmICgob3B0LnJlZ2ZsYWdzICE9IFJFR19ORVdMSU5FKSAmJiBvcHQuZml4ZWQpCgkJZGllKCJjYW5ub3QgbWl4IC0tZml4ZWQtc3RyaW5ncyBhbmQgcmVnZXhwIik7CgojaWZuZGVmIE5PX1BUSFJFQURTCglpZiAob25saW5lX2NwdXMoKSA9PSAxIHx8ICFncmVwX3RocmVhZHNfb2soJm9wdCkpCgkJdXNlX3RocmVhZHMgPSAwOwoKCWlmICh1c2VfdGhyZWFkcykKCQlzdGFydF90aHJlYWRzKCZvcHQpOwojZWxzZQoJdXNlX3RocmVhZHMgPSAwOwojZW5kaWYKCgljb21waWxlX2dyZXBfcGF0dGVybnMoJm9wdCk7CgoJLyogQ2hlY2sgcmV2cyBhbmQgdGhlbiBwYXRocyAqLwoJZm9yIChpID0gMDsgaSA8IGFyZ2M7IGkrKykgewoJCWNvbnN0IGNoYXIgKmFyZyA9IGFyZ3ZbaV07CgkJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCQkvKiBJcyBpdCBhIHJldj8gKi8KCQlpZiAoIWdldF9zaGExKGFyZywgc2hhMSkpIHsKCQkJc3RydWN0IG9iamVjdCAqb2JqZWN0ID0gcGFyc2Vfb2JqZWN0KHNoYTEpOwoJCQlpZiAoIW9iamVjdCkKCQkJCWRpZSgiYmFkIG9iamVjdCAlcyIsIGFyZyk7CgkJCWFkZF9vYmplY3RfYXJyYXkob2JqZWN0LCBhcmcsICZsaXN0KTsKCQkJY29udGludWU7CgkJfQoJCWlmICghc3RyY21wKGFyZywgIi0tIikpIHsKCQkJaSsrOwoJCQlzZWVuX2Rhc2hkYXNoID0gMTsKCQl9CgkJYnJlYWs7Cgl9CgoJLyogVGhlIHJlc3QgYXJlIHBhdGhzICovCglpZiAoIXNlZW5fZGFzaGRhc2gpIHsKCQlpbnQgajsKCQlmb3IgKGogPSBpOyBqIDwgYXJnYzsgaisrKQoJCQl2ZXJpZnlfZmlsZW5hbWUocHJlZml4LCBhcmd2W2pdKTsKCX0KCglpZiAoaSA8IGFyZ2MpCgkJcGF0aHMgPSBnZXRfcGF0aHNwZWMocHJlZml4LCBhcmd2ICsgaSk7CgllbHNlIGlmIChwcmVmaXgpIHsKCQlwYXRocyA9IHhjYWxsb2MoMiwgc2l6ZW9mKGNvbnN0IGNoYXIgKikpOwoJCXBhdGhzWzBdID0gcHJlZml4OwoJCXBhdGhzWzFdID0gTlVMTDsKCX0KCglpZiAoIWxpc3QubnIpIHsKCQlpbnQgaGl0OwoJCWlmICghY2FjaGVkKQoJCQlzZXR1cF93b3JrX3RyZWUoKTsKCgkJaGl0ID0gZ3JlcF9jYWNoZSgmb3B0LCBwYXRocywgY2FjaGVkKTsKCQlpZiAodXNlX3RocmVhZHMpCgkJCWhpdCB8PSB3YWl0X2FsbCgpOwoJCXJldHVybiAhaGl0OwoJfQoKCWlmIChjYWNoZWQpCgkJZGllKCJib3RoIC0tY2FjaGVkIGFuZCB0cmVlcyBhcmUgZ2l2ZW4uIik7CgoJZm9yIChpID0gMDsgaSA8IGxpc3QubnI7IGkrKykgewoJCXN0cnVjdCBvYmplY3QgKnJlYWxfb2JqOwoJCXJlYWxfb2JqID0gZGVyZWZfdGFnKGxpc3Qub2JqZWN0c1tpXS5pdGVtLCBOVUxMLCAwKTsKCQlpZiAoZ3JlcF9vYmplY3QoJm9wdCwgcGF0aHMsIHJlYWxfb2JqLCBsaXN0Lm9iamVjdHNbaV0ubmFtZSkpIHsKCQkJaGl0ID0gMTsKCQkJaWYgKG9wdC5zdGF0dXNfb25seSkKCQkJCWJyZWFrOwoJCX0KCX0KCglpZiAodXNlX3RocmVhZHMpCgkJaGl0IHw9IHdhaXRfYWxsKCk7CglmcmVlX2dyZXBfcGF0dGVybnMoJm9wdCk7CglyZXR1cm4gIWhpdDsKfQo=",
    "text": "/*\n * Builtin \"git grep\"\n *\n * Copyright (c) 2006 Junio C Hamano\n */\n#include \"cache.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"tree-walk.h\"\n#include \"builtin.h\"\n#include \"parse-options.h\"\n#include \"userdiff.h\"\n#include \"grep.h\"\n#include \"quote.h\"\n\n#ifndef NO_PTHREADS\n#include \"thread-utils.h\"\n#include <pthread.h>\n#endif\n\nstatic char const * const grep_usage[] = {\n\t\"git grep [options] [-e] <pattern> [<rev>...] [[--] path...]\",\n\tNULL\n};\n\nstatic int use_threads = 1;\n\n#ifndef NO_PTHREADS\n#define THREADS 8\nstatic pthread_t threads[THREADS];\n\nstatic void *load_sha1(const unsigned char *sha1, unsigned long *size,\n\t\t       const char *name);\nstatic void *load_file(const char *filename, size_t *sz);\n\nenum work_type {WORK_SHA1, WORK_FILE};\n\n/* We use one producer thread and THREADS consumer\n * threads. The producer adds struct work_items to 'todo' and the\n * consumers pick work items from the same array.\n */\nstruct work_item\n{\n\tenum work_type type;\n\tchar *name;\n\n\t/* if type == WORK_SHA1, then 'identifier' is a SHA1,\n\t * otherwise type == WORK_FILE, and 'identifier' is a NUL\n\t * terminated filename.\n\t */\n\tvoid *identifier;\n\tchar done;\n\tstruct strbuf out;\n};\n\n/* In the range [todo_done, todo_start) in 'todo' we have work_items\n * that have been or are processed by a consumer thread. We haven't\n * written the result for these to stdout yet.\n *\n * The work_items in [todo_start, todo_end) are waiting to be picked\n * up by a consumer thread.\n *\n * The ranges are modulo TODO_SIZE.\n */\n#define TODO_SIZE 128\nstatic struct work_item todo[TODO_SIZE];\nstatic int todo_start;\nstatic int todo_end;\nstatic int todo_done;\n\n/* Has all work items been added? */\nstatic int all_work_added;\n\n/* This lock protects all the variables above. */\nstatic pthread_mutex_t grep_mutex;\n\n/* Used to serialize calls to read_sha1_file. */\nstatic pthread_mutex_t read_sha1_mutex;\n\n#define grep_lock() pthread_mutex_lock(&grep_mutex)\n#define grep_unlock() pthread_mutex_unlock(&grep_mutex)\n#define read_sha1_lock() pthread_mutex_lock(&read_sha1_mutex)\n#define read_sha1_unlock() pthread_mutex_unlock(&read_sha1_mutex)\n\n/* Signalled when a new work_item is added to todo. */\nstatic pthread_cond_t cond_add;\n\n/* Signalled when the result from one work_item is written to\n * stdout.\n */\nstatic pthread_cond_t cond_write;\n\n/* Signalled when we are finished with everything. */\nstatic pthread_cond_t cond_result;\n\nstatic void add_work(enum work_type type, char *name, void *id)\n{\n\tgrep_lock();\n\n\twhile ((todo_end+1) % ARRAY_SIZE(todo) == todo_done) {\n\t\tpthread_cond_wait(&cond_write, &grep_mutex);\n\t}\n\n\ttodo[todo_end].type = type;\n\ttodo[todo_end].name = name;\n\ttodo[todo_end].identifier = id;\n\ttodo[todo_end].done = 0;\n\tstrbuf_reset(&todo[todo_end].out);\n\ttodo_end = (todo_end + 1) % ARRAY_SIZE(todo);\n\n\tpthread_cond_signal(&cond_add);\n\tgrep_unlock();\n}\n\nstatic struct work_item *get_work(void)\n{\n\tstruct work_item *ret;\n\n\tgrep_lock();\n\twhile (todo_start == todo_end && !all_work_added) {\n\t\tpthread_cond_wait(&cond_add, &grep_mutex);\n\t}\n\n\tif (todo_start == todo_end && all_work_added) {\n\t\tret = NULL;\n\t} else {\n\t\tret = &todo[todo_start];\n\t\ttodo_start = (todo_start + 1) % ARRAY_SIZE(todo);\n\t}\n\tgrep_unlock();\n\treturn ret;\n}\n\nstatic void grep_sha1_async(struct grep_opt *opt, char *name,\n\t\t\t    const unsigned char *sha1)\n{\n\tunsigned char *s;\n\ts = xmalloc(20);\n\tmemcpy(s, sha1, 20);\n\tadd_work(WORK_SHA1, name, s);\n}\n\nstatic void grep_file_async(struct grep_opt *opt, char *name,\n\t\t\t    const char *filename)\n{\n\tadd_work(WORK_FILE, name, xstrdup(filename));\n}\n\nstatic void work_done(struct work_item *w)\n{\n\tint old_done;\n\n\tgrep_lock();\n\tw->done = 1;\n\told_done = todo_done;\n\tfor(; todo[todo_done].done && todo_done != todo_start;\n\t    todo_done = (todo_done+1) % ARRAY_SIZE(todo)) {\n\t\tw = &todo[todo_done];\n\t\twrite_or_die(1, w->out.buf, w->out.len);\n\t\tfree(w->name);\n\t\tfree(w->identifier);\n\t}\n\n\tif (old_done != todo_done)\n\t\tpthread_cond_signal(&cond_write);\n\n\tif (all_work_added && todo_done == todo_end)\n\t\tpthread_cond_signal(&cond_result);\n\n\tgrep_unlock();\n}\n\nstatic void *run(void *arg)\n{\n\tint hit = 0;\n\tstruct grep_opt *opt = arg;\n\n\twhile (1) {\n\t\tstruct work_item *w = get_work();\n\t\tif (!w)\n\t\t\tbreak;\n\n\t\topt->output_priv = w;\n\t\tif (w->type == WORK_SHA1) {\n\t\t\tunsigned long sz;\n\t\t\tvoid* data = load_sha1(w->identifier, &sz, w->name);\n\n\t\t\tif (data) {\n\t\t\t\thit |= grep_buffer(opt, w->name, data, sz);\n\t\t\t\tfree(data);\n\t\t\t}\n\t\t} else if (w->type == WORK_FILE) {\n\t\t\tsize_t sz;\n\t\t\tvoid* data = load_file(w->identifier, &sz);\n\t\t\tif (data) {\n\t\t\t\thit |= grep_buffer(opt, w->name, data, sz);\n\t\t\t\tfree(data);\n\t\t\t}\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\n\t\twork_done(w);\n\t}\n\tfree_grep_patterns(arg);\n\tfree(arg);\n\n\treturn (void*) (intptr_t) hit;\n}\n\nstatic void strbuf_out(struct grep_opt *opt, const void *buf, size_t size)\n{\n\tstruct work_item *w = opt->output_priv;\n\tstrbuf_add(&w->out, buf, size);\n}\n\nstatic void start_threads(struct grep_opt *opt)\n{\n\tint i;\n\n\tpthread_mutex_init(&grep_mutex, NULL);\n\tpthread_mutex_init(&read_sha1_mutex, NULL);\n\tpthread_cond_init(&cond_add, NULL);\n\tpthread_cond_init(&cond_write, NULL);\n\tpthread_cond_init(&cond_result, NULL);\n\n\tfor (i = 0; i < ARRAY_SIZE(todo); i++) {\n\t\tstrbuf_init(&todo[i].out, 0);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(threads); i++) {\n\t\tint err;\n\t\tstruct grep_opt *o = grep_opt_dup(opt);\n\t\to->output = strbuf_out;\n\t\tcompile_grep_patterns(o);\n\t\terr = pthread_create(&threads[i], NULL, run, o);\n\n\t\tif (err)\n\t\t\tdie(\"grep: failed to create thread: %s\",\n\t\t\t    strerror(err));\n\t}\n}\n\nstatic int wait_all(void)\n{\n\tint hit = 0;\n\tint i;\n\n\tgrep_lock();\n\tall_work_added = 1;\n\n\t/* Wait until all work is done. */\n\twhile (todo_done != todo_end)\n\t\tpthread_cond_wait(&cond_result, &grep_mutex);\n\n\t/* Wake up all the consumer threads so they can see that there\n\t * is no more work to do.\n\t */\n\tpthread_cond_broadcast(&cond_add);\n\tgrep_unlock();\n\n\tfor (i = 0; i < ARRAY_SIZE(threads); i++) {\n\t\tvoid *h;\n\t\tpthread_join(threads[i], &h);\n\t\thit |= (int) (intptr_t) h;\n\t}\n\n\tpthread_mutex_destroy(&grep_mutex);\n\tpthread_mutex_destroy(&read_sha1_mutex);\n\tpthread_cond_destroy(&cond_add);\n\tpthread_cond_destroy(&cond_write);\n\tpthread_cond_destroy(&cond_result);\n\n\treturn hit;\n}\n#else /* !NO_PTHREADS */\n#define read_sha1_lock()\n#define read_sha1_unlock()\n\nstatic int wait_all(void)\n{\n\treturn 0;\n}\n#endif\n\nstatic int grep_config(const char *var, const char *value, void *cb)\n{\n\tstruct grep_opt *opt = cb;\n\n\tswitch (userdiff_config(var, value)) {\n\tcase 0: break;\n\tcase -1: return -1;\n\tdefault: return 0;\n\t}\n\n\tif (!strcmp(var, \"color.grep\")) {\n\t\topt->color = git_config_colorbool(var, value, -1);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"color.grep.match\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tcolor_parse(value, var, opt->color_match);\n\t\treturn 0;\n\t}\n\treturn git_color_default_config(var, value, cb);\n}\n\n/*\n * Return non-zero if max_depth is negative or path has no more then max_depth\n * slashes.\n */\nstatic int accept_subdir(const char *path, int max_depth)\n{\n\tif (max_depth < 0)\n\t\treturn 1;\n\n\twhile ((path = strchr(path, '/')) != NULL) {\n\t\tmax_depth--;\n\t\tif (max_depth < 0)\n\t\t\treturn 0;\n\t\tpath++;\n\t}\n\treturn 1;\n}\n\n/*\n * Return non-zero if name is a subdirectory of match and is not too deep.\n */\nstatic int is_subdir(const char *name, int namelen,\n\t\tconst char *match, int matchlen, int max_depth)\n{\n\tif (matchlen > namelen || strncmp(name, match, matchlen))\n\t\treturn 0;\n\n\tif (name[matchlen] == '\\0') /* exact match */\n\t\treturn 1;\n\n\tif (!matchlen || match[matchlen-1] == '/' || name[matchlen] == '/')\n\t\treturn accept_subdir(name + matchlen + 1, max_depth);\n\n\treturn 0;\n}\n\n/*\n * git grep pathspecs are somewhat different from diff-tree pathspecs;\n * pathname wildcards are allowed.\n */\nstatic int pathspec_matches(const char **paths, const char *name, int max_depth)\n{\n\tint namelen, i;\n\tif (!paths || !*paths)\n\t\treturn accept_subdir(name, max_depth);\n\tnamelen = strlen(name);\n\tfor (i = 0; paths[i]; i++) {\n\t\tconst char *match = paths[i];\n\t\tint matchlen = strlen(match);\n\t\tconst char *cp, *meta;\n\n\t\tif (is_subdir(name, namelen, match, matchlen, max_depth))\n\t\t\treturn 1;\n\t\tif (!fnmatch(match, name, 0))\n\t\t\treturn 1;\n\t\tif (name[namelen-1] != '/')\n\t\t\tcontinue;\n\n\t\t/* We are being asked if the directory (\"name\") is worth\n\t\t * descending into.\n\t\t *\n\t\t * Find the longest leading directory name that does\n\t\t * not have metacharacter in the pathspec; the name\n\t\t * we are looking at must overlap with that directory.\n\t\t */\n\t\tfor (cp = match, meta = NULL; cp - match < matchlen; cp++) {\n\t\t\tchar ch = *cp;\n\t\t\tif (ch == '*' || ch == '[' || ch == '?') {\n\t\t\t\tmeta = cp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!meta)\n\t\t\tmeta = cp; /* fully literal */\n\n\t\tif (namelen <= meta - match) {\n\t\t\t/* Looking at \"Documentation/\" and\n\t\t\t * the pattern says \"Documentation/howto/\", or\n\t\t\t * \"Documentation/diff*.txt\".  The name we\n\t\t\t * have should match prefix.\n\t\t\t */\n\t\t\tif (!memcmp(match, name, namelen))\n\t\t\t\treturn 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (meta - match < namelen) {\n\t\t\t/* Looking at \"Documentation/howto/\" and\n\t\t\t * the pattern says \"Documentation/h*\";\n\t\t\t * match up to \"Do.../h\"; this avoids descending\n\t\t\t * into \"Documentation/technical/\".\n\t\t\t */\n\t\t\tif (!memcmp(match, name, meta - match))\n\t\t\t\treturn 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void *load_sha1(const unsigned char *sha1, unsigned long *size,\n\t\t       const char *name)\n{\n\tenum object_type type;\n\tchar *data;\n\n\tread_sha1_lock();\n\tdata = read_sha1_file(sha1, &type, size);\n\tread_sha1_unlock();\n\n\tif (!data)\n\t\terror(\"'%s': unable to read %s\", name, sha1_to_hex(sha1));\n\n\treturn data;\n}\n\nstatic int grep_sha1(struct grep_opt *opt, const unsigned char *sha1,\n\t\t     const char *filename, int tree_name_len)\n{\n\tstruct strbuf pathbuf = STRBUF_INIT;\n\tchar *name;\n\n\tif (opt->relative && opt->prefix_length) {\n\t\tquote_path_relative(filename + tree_name_len, -1, &pathbuf,\n\t\t\t\t    opt->prefix);\n\t\tstrbuf_insert(&pathbuf, 0, filename, tree_name_len);\n\t} else {\n\t\tstrbuf_addstr(&pathbuf, filename);\n\t}\n\n\tname = strbuf_detach(&pathbuf, NULL);\n\n#ifndef NO_PTHREADS\n\tif (use_threads) {\n\t\tgrep_sha1_async(opt, name, sha1);\n\t\treturn 0;\n\t} else\n#endif\n\t{\n\t\tint hit;\n\t\tunsigned long sz;\n\t\tvoid *data = load_sha1(sha1, &sz, name);\n\t\tif (!data)\n\t\t\thit = 0;\n\t\telse\n\t\t\thit = grep_buffer(opt, name, data, sz);\n\n\t\tfree(data);\n\t\tfree(name);\n\t\treturn hit;\n\t}\n}\n\nstatic void *load_file(const char *filename, size_t *sz)\n{\n\tstruct stat st;\n\tchar *data;\n\tint i;\n\n\tif (lstat(filename, &st) < 0) {\n\terr_ret:\n\t\tif (errno != ENOENT)\n\t\t\terror(\"'%s': %s\", filename, strerror(errno));\n\t\treturn 0;\n\t}\n\tif (!S_ISREG(st.st_mode))\n\t\treturn 0;\n\t*sz = xsize_t(st.st_size);\n\ti = open(filename, O_RDONLY);\n\tif (i < 0)\n\t\tgoto err_ret;\n\tdata = xmalloc(*sz + 1);\n\tif (st.st_size != read_in_full(i, data, *sz)) {\n\t\terror(\"'%s': short read %s\", filename, strerror(errno));\n\t\tclose(i);\n\t\tfree(data);\n\t\treturn 0;\n\t}\n\tclose(i);\n\tdata[*sz] = 0;\n\treturn data;\n}\n\nstatic int grep_file(struct grep_opt *opt, const char *filename)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tchar *name;\n\n\tif (opt->relative && opt->prefix_length)\n\t\tquote_path_relative(filename, -1, &buf, opt->prefix);\n\telse\n\t\tstrbuf_addstr(&buf, filename);\n\tname = strbuf_detach(&buf, NULL);\n\n#ifndef NO_PTHREADS\n\tif (use_threads) {\n\t\tgrep_file_async(opt, name, filename);\n\t\treturn 0;\n\t} else\n#endif\n\t{\n\t\tint hit;\n\t\tsize_t sz;\n\t\tvoid *data = load_file(filename, &sz);\n\t\tif (!data)\n\t\t\thit = 0;\n\t\telse\n\t\t\thit = grep_buffer(opt, name, data, sz);\n\n\t\tfree(data);\n\t\tfree(name);\n\t\treturn hit;\n\t}\n}\n\nstatic int grep_cache(struct grep_opt *opt, const char **paths, int cached)\n{\n\tint hit = 0;\n\tint nr;\n\tread_cache();\n\n\tfor (nr = 0; nr < active_nr; nr++) {\n\t\tstruct cache_entry *ce = active_cache[nr];\n\t\tif (!S_ISREG(ce->ce_mode))\n\t\t\tcontinue;\n\t\tif (!pathspec_matches(paths, ce->name, opt->max_depth))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If CE_VALID is on, we assume worktree file and its cache entry\n\t\t * are identical, even if worktree file has been modified, so use\n\t\t * cache version instead\n\t\t */\n\t\tif (cached || (ce->ce_flags & CE_VALID) || ce_skip_worktree(ce)) {\n\t\t\tif (ce_stage(ce))\n\t\t\t\tcontinue;\n\t\t\thit |= grep_sha1(opt, ce->sha1, ce->name, 0);\n\t\t}\n\t\telse\n\t\t\thit |= grep_file(opt, ce->name);\n\t\tif (ce_stage(ce)) {\n\t\t\tdo {\n\t\t\t\tnr++;\n\t\t\t} while (nr < active_nr &&\n\t\t\t\t !strcmp(ce->name, active_cache[nr]->name));\n\t\t\tnr--; /* compensate for loop control */\n\t\t}\n\t\tif (hit && opt->status_only)\n\t\t\tbreak;\n\t}\n\tfree_grep_patterns(opt);\n\treturn hit;\n}\n\nstatic int grep_tree(struct grep_opt *opt, const char **paths,\n\t\t     struct tree_desc *tree,\n\t\t     const char *tree_name, const char *base)\n{\n\tint len;\n\tint hit = 0;\n\tstruct name_entry entry;\n\tchar *down;\n\tint tn_len = strlen(tree_name);\n\tstruct strbuf pathbuf;\n\n\tstrbuf_init(&pathbuf, PATH_MAX + tn_len);\n\n\tif (tn_len) {\n\t\tstrbuf_add(&pathbuf, tree_name, tn_len);\n\t\tstrbuf_addch(&pathbuf, ':');\n\t\ttn_len = pathbuf.len;\n\t}\n\tstrbuf_addstr(&pathbuf, base);\n\tlen = pathbuf.len;\n\n\twhile (tree_entry(tree, &entry)) {\n\t\tint te_len = tree_entry_len(entry.path, entry.sha1);\n\t\tpathbuf.len = len;\n\t\tstrbuf_add(&pathbuf, entry.path, te_len);\n\n\t\tif (S_ISDIR(entry.mode))\n\t\t\t/* Match \"abc/\" against pathspec to\n\t\t\t * decide if we want to descend into \"abc\"\n\t\t\t * directory.\n\t\t\t */\n\t\t\tstrbuf_addch(&pathbuf, '/');\n\n\t\tdown = pathbuf.buf + tn_len;\n\t\tif (!pathspec_matches(paths, down, opt->max_depth))\n\t\t\t;\n\t\telse if (S_ISREG(entry.mode))\n\t\t\thit |= grep_sha1(opt, entry.sha1, pathbuf.buf, tn_len);\n\t\telse if (S_ISDIR(entry.mode)) {\n\t\t\tenum object_type type;\n\t\t\tstruct tree_desc sub;\n\t\t\tvoid *data;\n\t\t\tunsigned long size;\n\n\t\t\tread_sha1_lock();\n\t\t\tdata = read_sha1_file(entry.sha1, &type, &size);\n\t\t\tread_sha1_unlock();\n\n\t\t\tif (!data)\n\t\t\t\tdie(\"unable to read tree (%s)\",\n\t\t\t\t    sha1_to_hex(entry.sha1));\n\t\t\tinit_tree_desc(&sub, data, size);\n\t\t\thit |= grep_tree(opt, paths, &sub, tree_name, down);\n\t\t\tfree(data);\n\t\t}\n\t\tif (hit && opt->status_only)\n\t\t\tbreak;\n\t}\n\tstrbuf_release(&pathbuf);\n\treturn hit;\n}\n\nstatic int grep_object(struct grep_opt *opt, const char **paths,\n\t\t       struct object *obj, const char *name)\n{\n\tif (obj->type == OBJ_BLOB)\n\t\treturn grep_sha1(opt, obj->sha1, name, 0);\n\tif (obj->type == OBJ_COMMIT || obj->type == OBJ_TREE) {\n\t\tstruct tree_desc tree;\n\t\tvoid *data;\n\t\tunsigned long size;\n\t\tint hit;\n\t\tdata = read_object_with_reference(obj->sha1, tree_type,\n\t\t\t\t\t\t  &size, NULL);\n\t\tif (!data)\n\t\t\tdie(\"unable to read tree (%s)\", sha1_to_hex(obj->sha1));\n\t\tinit_tree_desc(&tree, data, size);\n\t\thit = grep_tree(opt, paths, &tree, name, \"\");\n\t\tfree(data);\n\t\treturn hit;\n\t}\n\tdie(\"unable to grep from object of type %s\", typename(obj->type));\n}\n\nstatic int context_callback(const struct option *opt, const char *arg,\n\t\t\t    int unset)\n{\n\tstruct grep_opt *grep_opt = opt->value;\n\tint value;\n\tconst char *endp;\n\n\tif (unset) {\n\t\tgrep_opt->pre_context = grep_opt->post_context = 0;\n\t\treturn 0;\n\t}\n\tvalue = strtol(arg, (char **)&endp, 10);\n\tif (*endp) {\n\t\treturn error(\"switch `%c' expects a numerical value\",\n\t\t\t     opt->short_name);\n\t}\n\tgrep_opt->pre_context = grep_opt->post_context = value;\n\treturn 0;\n}\n\nstatic int file_callback(const struct option *opt, const char *arg, int unset)\n{\n\tstruct grep_opt *grep_opt = opt->value;\n\tFILE *patterns;\n\tint lno = 0;\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tpatterns = fopen(arg, \"r\");\n\tif (!patterns)\n\t\tdie_errno(\"cannot open '%s'\", arg);\n\twhile (strbuf_getline(&sb, patterns, '\\n') == 0) {\n\t\t/* ignore empty line like grep does */\n\t\tif (sb.len == 0)\n\t\t\tcontinue;\n\t\tappend_grep_pattern(grep_opt, strbuf_detach(&sb, NULL), arg,\n\t\t\t\t    ++lno, GREP_PATTERN);\n\t}\n\tfclose(patterns);\n\tstrbuf_release(&sb);\n\treturn 0;\n}\n\nstatic int not_callback(const struct option *opt, const char *arg, int unset)\n{\n\tstruct grep_opt *grep_opt = opt->value;\n\tappend_grep_pattern(grep_opt, \"--not\", \"command line\", 0, GREP_NOT);\n\treturn 0;\n}\n\nstatic int and_callback(const struct option *opt, const char *arg, int unset)\n{\n\tstruct grep_opt *grep_opt = opt->value;\n\tappend_grep_pattern(grep_opt, \"--and\", \"command line\", 0, GREP_AND);\n\treturn 0;\n}\n\nstatic int open_callback(const struct option *opt, const char *arg, int unset)\n{\n\tstruct grep_opt *grep_opt = opt->value;\n\tappend_grep_pattern(grep_opt, \"(\", \"command line\", 0, GREP_OPEN_PAREN);\n\treturn 0;\n}\n\nstatic int close_callback(const struct option *opt, const char *arg, int unset)\n{\n\tstruct grep_opt *grep_opt = opt->value;\n\tappend_grep_pattern(grep_opt, \")\", \"command line\", 0, GREP_CLOSE_PAREN);\n\treturn 0;\n}\n\nstatic int pattern_callback(const struct option *opt, const char *arg,\n\t\t\t    int unset)\n{\n\tstruct grep_opt *grep_opt = opt->value;\n\tappend_grep_pattern(grep_opt, arg, \"-e option\", 0, GREP_PATTERN);\n\treturn 0;\n}\n\nstatic int help_callback(const struct option *opt, const char *arg, int unset)\n{\n\treturn -1;\n}\n\nint cmd_grep(int argc, const char **argv, const char *prefix)\n{\n\tint hit = 0;\n\tint cached = 0;\n\tint seen_dashdash = 0;\n\tint external_grep_allowed__ignored;\n\tstruct grep_opt opt;\n\tstruct object_array list = { 0, 0, NULL };\n\tconst char **paths = NULL;\n\tint i;\n\tint dummy;\n\tstruct option options[] = {\n\t\tOPT_BOOLEAN(0, \"cached\", &cached,\n\t\t\t\"search in index instead of in the work tree\"),\n\t\tOPT_GROUP(\"\"),\n\t\tOPT_BOOLEAN('v', \"invert-match\", &opt.invert,\n\t\t\t\"show non-matching lines\"),\n\t\tOPT_BOOLEAN('i', \"ignore-case\", &opt.ignore_case,\n\t\t\t\"case insensitive matching\"),\n\t\tOPT_BOOLEAN('w', \"word-regexp\", &opt.word_regexp,\n\t\t\t\"match patterns only at word boundaries\"),\n\t\tOPT_SET_INT('a', \"text\", &opt.binary,\n\t\t\t\"process binary files as text\", GREP_BINARY_TEXT),\n\t\tOPT_SET_INT('I', NULL, &opt.binary,\n\t\t\t\"don't match patterns in binary files\",\n\t\t\tGREP_BINARY_NOMATCH),\n\t\t{ OPTION_INTEGER, 0, \"max-depth\", &opt.max_depth, \"depth\",\n\t\t\t\"descend at most <depth> levels\", PARSE_OPT_NONEG,\n\t\t\tNULL, 1 },\n\t\tOPT_GROUP(\"\"),\n\t\tOPT_BIT('E', \"extended-regexp\", &opt.regflags,\n\t\t\t\"use extended POSIX regular expressions\", REG_EXTENDED),\n\t\tOPT_NEGBIT('G', \"basic-regexp\", &opt.regflags,\n\t\t\t\"use basic POSIX regular expressions (default)\",\n\t\t\tREG_EXTENDED),\n\t\tOPT_BOOLEAN('F', \"fixed-strings\", &opt.fixed,\n\t\t\t\"interpret patterns as fixed strings\"),\n\t\tOPT_GROUP(\"\"),\n\t\tOPT_BOOLEAN('n', NULL, &opt.linenum, \"show line numbers\"),\n\t\tOPT_NEGBIT('h', NULL, &opt.pathname, \"don't show filenames\", 1),\n\t\tOPT_BIT('H', NULL, &opt.pathname, \"show filenames\", 1),\n\t\tOPT_NEGBIT(0, \"full-name\", &opt.relative,\n\t\t\t\"show filenames relative to top directory\", 1),\n\t\tOPT_BOOLEAN('l', \"files-with-matches\", &opt.name_only,\n\t\t\t\"show only filenames instead of matching lines\"),\n\t\tOPT_BOOLEAN(0, \"name-only\", &opt.name_only,\n\t\t\t\"synonym for --files-with-matches\"),\n\t\tOPT_BOOLEAN('L', \"files-without-match\",\n\t\t\t&opt.unmatch_name_only,\n\t\t\t\"show only the names of files without match\"),\n\t\tOPT_BOOLEAN('z', \"null\", &opt.null_following_name,\n\t\t\t\"print NUL after filenames\"),\n\t\tOPT_BOOLEAN('c', \"count\", &opt.count,\n\t\t\t\"show the number of matches instead of matching lines\"),\n\t\tOPT__COLOR(&opt.color, \"highlight matches\"),\n\t\tOPT_GROUP(\"\"),\n\t\tOPT_CALLBACK('C', NULL, &opt, \"n\",\n\t\t\t\"show <n> context lines before and after matches\",\n\t\t\tcontext_callback),\n\t\tOPT_INTEGER('B', NULL, &opt.pre_context,\n\t\t\t\"show <n> context lines before matches\"),\n\t\tOPT_INTEGER('A', NULL, &opt.post_context,\n\t\t\t\"show <n> context lines after matches\"),\n\t\tOPT_NUMBER_CALLBACK(&opt, \"shortcut for -C NUM\",\n\t\t\tcontext_callback),\n\t\tOPT_BOOLEAN('p', \"show-function\", &opt.funcname,\n\t\t\t\"show a line with the function name before matches\"),\n\t\tOPT_GROUP(\"\"),\n\t\tOPT_CALLBACK('f', NULL, &opt, \"file\",\n\t\t\t\"read patterns from file\", file_callback),\n\t\t{ OPTION_CALLBACK, 'e', NULL, &opt, \"pattern\",\n\t\t\t\"match <pattern>\", PARSE_OPT_NONEG, pattern_callback },\n\t\t{ OPTION_CALLBACK, 0, \"and\", &opt, NULL,\n\t\t  \"combine patterns specified with -e\",\n\t\t  PARSE_OPT_NOARG | PARSE_OPT_NONEG, and_callback },\n\t\tOPT_BOOLEAN(0, \"or\", &dummy, \"\"),\n\t\t{ OPTION_CALLBACK, 0, \"not\", &opt, NULL, \"\",\n\t\t  PARSE_OPT_NOARG | PARSE_OPT_NONEG, not_callback },\n\t\t{ OPTION_CALLBACK, '(', NULL, &opt, NULL, \"\",\n\t\t  PARSE_OPT_NOARG | PARSE_OPT_NONEG | PARSE_OPT_NODASH,\n\t\t  open_callback },\n\t\t{ OPTION_CALLBACK, ')', NULL, &opt, NULL, \"\",\n\t\t  PARSE_OPT_NOARG | PARSE_OPT_NONEG | PARSE_OPT_NODASH,\n\t\t  close_callback },\n\t\tOPT_BOOLEAN('q', \"quiet\", &opt.status_only,\n\t\t\t    \"indicate hit with exit status without output\"),\n\t\tOPT_BOOLEAN(0, \"all-match\", &opt.all_match,\n\t\t\t\"show only matches from files that match all patterns\"),\n\t\tOPT_GROUP(\"\"),\n\t\tOPT_BOOLEAN(0, \"ext-grep\", &external_grep_allowed__ignored,\n\t\t\t    \"allow calling of grep(1) (ignored by this build)\"),\n\t\t{ OPTION_CALLBACK, 0, \"help-all\", &options, NULL, \"show usage\",\n\t\t  PARSE_OPT_HIDDEN | PARSE_OPT_NOARG, help_callback },\n\t\tOPT_END()\n\t};\n\n\t/*\n\t * 'git grep -h', unlike 'git grep -h <pattern>', is a request\n\t * to show usage information and exit.\n\t */\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(grep_usage, options);\n\n\tmemset(&opt, 0, sizeof(opt));\n\topt.prefix = prefix;\n\topt.prefix_length = (prefix && *prefix) ? strlen(prefix) : 0;\n\topt.relative = 1;\n\topt.pathname = 1;\n\topt.pattern_tail = &opt.pattern_list;\n\topt.regflags = REG_NEWLINE;\n\topt.max_depth = -1;\n\n\tstrcpy(opt.color_match, GIT_COLOR_RED GIT_COLOR_BOLD);\n\topt.color = -1;\n\tgit_config(grep_config, &opt);\n\tif (opt.color == -1)\n\t\topt.color = git_use_color_default;\n\n\t/*\n\t * If there is no -- then the paths must exist in the working\n\t * tree.  If there is no explicit pattern specified with -e or\n\t * -f, we take the first unrecognized non option to be the\n\t * pattern, but then what follows it must be zero or more\n\t * valid refs up to the -- (if exists), and then existing\n\t * paths.  If there is an explicit pattern, then the first\n\t * unrecognized non option is the beginning of the refs list\n\t * that continues up to the -- (if exists), and then paths.\n\t */\n\targc = parse_options(argc, argv, prefix, options, grep_usage,\n\t\t\t     PARSE_OPT_KEEP_DASHDASH |\n\t\t\t     PARSE_OPT_STOP_AT_NON_OPTION |\n\t\t\t     PARSE_OPT_NO_INTERNAL_HELP);\n\n\t/* First unrecognized non-option token */\n\tif (argc > 0 && !opt.pattern_list) {\n\t\tappend_grep_pattern(&opt, argv[0], \"command line\", 0,\n\t\t\t\t    GREP_PATTERN);\n\t\targv++;\n\t\targc--;\n\t}\n\n\tif (!opt.pattern_list)\n\t\tdie(\"no pattern given.\");\n\tif (!opt.fixed && opt.ignore_case)\n\t\topt.regflags |= REG_ICASE;\n\tif ((opt.regflags != REG_NEWLINE) && opt.fixed)\n\t\tdie(\"cannot mix --fixed-strings and regexp\");\n\n#ifndef NO_PTHREADS\n\tif (online_cpus() == 1 || !grep_threads_ok(&opt))\n\t\tuse_threads = 0;\n\n\tif (use_threads)\n\t\tstart_threads(&opt);\n#else\n\tuse_threads = 0;\n#endif\n\n\tcompile_grep_patterns(&opt);\n\n\t/* Check revs and then paths */\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\t\tunsigned char sha1[20];\n\t\t/* Is it a rev? */\n\t\tif (!get_sha1(arg, sha1)) {\n\t\t\tstruct object *object = parse_object(sha1);\n\t\t\tif (!object)\n\t\t\t\tdie(\"bad object %s\", arg);\n\t\t\tadd_object_array(object, arg, &list);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--\")) {\n\t\t\ti++;\n\t\t\tseen_dashdash = 1;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* The rest are paths */\n\tif (!seen_dashdash) {\n\t\tint j;\n\t\tfor (j = i; j < argc; j++)\n\t\t\tverify_filename(prefix, argv[j]);\n\t}\n\n\tif (i < argc)\n\t\tpaths = get_pathspec(prefix, argv + i);\n\telse if (prefix) {\n\t\tpaths = xcalloc(2, sizeof(const char *));\n\t\tpaths[0] = prefix;\n\t\tpaths[1] = NULL;\n\t}\n\n\tif (!list.nr) {\n\t\tint hit;\n\t\tif (!cached)\n\t\t\tsetup_work_tree();\n\n\t\thit = grep_cache(&opt, paths, cached);\n\t\tif (use_threads)\n\t\t\thit |= wait_all();\n\t\treturn !hit;\n\t}\n\n\tif (cached)\n\t\tdie(\"both --cached and trees are given.\");\n\n\tfor (i = 0; i < list.nr; i++) {\n\t\tstruct object *real_obj;\n\t\treal_obj = deref_tag(list.objects[i].item, NULL, 0);\n\t\tif (grep_object(&opt, paths, real_obj, list.objects[i].name)) {\n\t\t\thit = 1;\n\t\t\tif (opt.status_only)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (use_threads)\n\t\thit |= wait_all();\n\tfree_grep_patterns(&opt);\n\treturn !hit;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00cbd90bf68bc729d9b4d1bdb2fcaa92954010f1",
  "sha1_ok": true,
  "size": 23696
}
