{
  "content": {
    "base64": "I2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAiaHR0cC5oIgojaW5jbHVkZSAicGFjay5oIgojaW5jbHVkZSAic2lkZWJhbmQuaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJ1cmwuaCIKI2luY2x1ZGUgInVybG1hdGNoLmgiCiNpbmNsdWRlICJjcmVkZW50aWFsLmgiCiNpbmNsdWRlICJ2ZXJzaW9uLmgiCiNpbmNsdWRlICJwa3QtbGluZS5oIgojaW5jbHVkZSAiZ2V0dGV4dC5oIgoKaW50IGFjdGl2ZV9yZXF1ZXN0czsKaW50IGh0dHBfaXNfdmVyYm9zZTsKc2l6ZV90IGh0dHBfcG9zdF9idWZmZXIgPSAxNiAqIExBUkdFX1BBQ0tFVF9NQVg7CgojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MGEwNgojZGVmaW5lIExJQkNVUkxfQ0FOX0hBTkRMRV9BVVRIX0FOWQojZW5kaWYKCnN0YXRpYyBpbnQgbWluX2N1cmxfc2Vzc2lvbnMgPSAxOwpzdGF0aWMgaW50IGN1cmxfc2Vzc2lvbl9jb3VudDsKI2lmZGVmIFVTRV9DVVJMX01VTFRJCnN0YXRpYyBpbnQgbWF4X3JlcXVlc3RzID0gLTE7CnN0YXRpYyBDVVJMTSAqY3VybG07CiNlbmRpZgojaWZuZGVmIE5PX0NVUkxfRUFTWV9EVVBIQU5ETEUKc3RhdGljIENVUkwgKmN1cmxfZGVmYXVsdDsKI2VuZGlmCgojZGVmaW5lIFBSRVZfQlVGX1NJWkUgNDA5NgojZGVmaW5lIFJBTkdFX0hFQURFUl9TSVpFIDMwCgpjaGFyIGN1cmxfZXJyb3JzdHJbQ1VSTF9FUlJPUl9TSVpFXTsKCnN0YXRpYyBpbnQgY3VybF9zc2xfdmVyaWZ5ID0gLTE7CnN0YXRpYyBpbnQgY3VybF9zc2xfdHJ5OwpzdGF0aWMgY29uc3QgY2hhciAqc3NsX2NlcnQ7CiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwOTAzCnN0YXRpYyBjb25zdCBjaGFyICpzc2xfa2V5OwojZW5kaWYKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzA5MDgKc3RhdGljIGNvbnN0IGNoYXIgKnNzbF9jYXBhdGg7CiNlbmRpZgpzdGF0aWMgY29uc3QgY2hhciAqc3NsX2NhaW5mbzsKc3RhdGljIGxvbmcgY3VybF9sb3dfc3BlZWRfbGltaXQgPSAtMTsKc3RhdGljIGxvbmcgY3VybF9sb3dfc3BlZWRfdGltZSA9IC0xOwpzdGF0aWMgaW50IGN1cmxfZnRwX25vX2Vwc3Y7CnN0YXRpYyBjb25zdCBjaGFyICpjdXJsX2h0dHBfcHJveHk7CnN0YXRpYyBjb25zdCBjaGFyICpjdXJsX2Nvb2tpZV9maWxlOwpzdGF0aWMgaW50IGN1cmxfc2F2ZV9jb29raWVzOwpzdHJ1Y3QgY3JlZGVudGlhbCBodHRwX2F1dGggPSBDUkVERU5USUFMX0lOSVQ7CnN0YXRpYyBpbnQgaHR0cF9wcm9hY3RpdmVfYXV0aDsKc3RhdGljIGNvbnN0IGNoYXIgKnVzZXJfYWdlbnQ7CgojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MTcwMAovKiBVc2UgQ1VSTE9QVF9LRVlQQVNTV0QgYXMgaXMgKi8KI2VsaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MDkwMwojZGVmaW5lIENVUkxPUFRfS0VZUEFTU1dEIENVUkxPUFRfU1NMS0VZUEFTU1dECiNlbHNlCiNkZWZpbmUgQ1VSTE9QVF9LRVlQQVNTV0QgQ1VSTE9QVF9TU0xDRVJUUEFTU1dECiNlbmRpZgoKc3RhdGljIHN0cnVjdCBjcmVkZW50aWFsIGNlcnRfYXV0aCA9IENSRURFTlRJQUxfSU5JVDsKc3RhdGljIGludCBzc2xfY2VydF9wYXNzd29yZF9yZXF1aXJlZDsKCnN0YXRpYyBzdHJ1Y3QgY3VybF9zbGlzdCAqcHJhZ21hX2hlYWRlcjsKc3RhdGljIHN0cnVjdCBjdXJsX3NsaXN0ICpub19wcmFnbWFfaGVhZGVyOwoKc3RhdGljIHN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICphY3RpdmVfcXVldWVfaGVhZDsKCnN0YXRpYyBjaGFyICpjYWNoZWRfYWNjZXB0X2xhbmd1YWdlOwoKc2l6ZV90IGZyZWFkX2J1ZmZlcihjaGFyICpwdHIsIHNpemVfdCBlbHRzaXplLCBzaXplX3Qgbm1lbWIsIHZvaWQgKmJ1ZmZlcl8pCnsKCXNpemVfdCBzaXplID0gZWx0c2l6ZSAqIG5tZW1iOwoJc3RydWN0IGJ1ZmZlciAqYnVmZmVyID0gYnVmZmVyXzsKCglpZiAoc2l6ZSA+IGJ1ZmZlci0+YnVmLmxlbiAtIGJ1ZmZlci0+cG9zbikKCQlzaXplID0gYnVmZmVyLT5idWYubGVuIC0gYnVmZmVyLT5wb3NuOwoJbWVtY3B5KHB0ciwgYnVmZmVyLT5idWYuYnVmICsgYnVmZmVyLT5wb3NuLCBzaXplKTsKCWJ1ZmZlci0+cG9zbiArPSBzaXplOwoKCXJldHVybiBzaXplOwp9CgojaWZuZGVmIE5PX0NVUkxfSU9DVEwKY3VybGlvZXJyIGlvY3RsX2J1ZmZlcihDVVJMICpoYW5kbGUsIGludCBjbWQsIHZvaWQgKmNsaWVudHApCnsKCXN0cnVjdCBidWZmZXIgKmJ1ZmZlciA9IGNsaWVudHA7CgoJc3dpdGNoIChjbWQpIHsKCWNhc2UgQ1VSTElPQ01EX05PUDoKCQlyZXR1cm4gQ1VSTElPRV9PSzsKCgljYXNlIENVUkxJT0NNRF9SRVNUQVJUUkVBRDoKCQlidWZmZXItPnBvc24gPSAwOwoJCXJldHVybiBDVVJMSU9FX09LOwoKCWRlZmF1bHQ6CgkJcmV0dXJuIENVUkxJT0VfVU5LTk9XTkNNRDsKCX0KfQojZW5kaWYKCnNpemVfdCBmd3JpdGVfYnVmZmVyKGNoYXIgKnB0ciwgc2l6ZV90IGVsdHNpemUsIHNpemVfdCBubWVtYiwgdm9pZCAqYnVmZmVyXykKewoJc2l6ZV90IHNpemUgPSBlbHRzaXplICogbm1lbWI7CglzdHJ1Y3Qgc3RyYnVmICpidWZmZXIgPSBidWZmZXJfOwoKCXN0cmJ1Zl9hZGQoYnVmZmVyLCBwdHIsIHNpemUpOwoJcmV0dXJuIHNpemU7Cn0KCnNpemVfdCBmd3JpdGVfbnVsbChjaGFyICpwdHIsIHNpemVfdCBlbHRzaXplLCBzaXplX3Qgbm1lbWIsIHZvaWQgKnN0cmJ1ZikKewoJcmV0dXJuIGVsdHNpemUgKiBubWVtYjsKfQoKI2lmZGVmIFVTRV9DVVJMX01VTFRJCnN0YXRpYyB2b2lkIHByb2Nlc3NfY3VybF9tZXNzYWdlcyh2b2lkKQp7CglpbnQgbnVtX21lc3NhZ2VzOwoJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3Q7CglDVVJMTXNnICpjdXJsX21lc3NhZ2UgPSBjdXJsX211bHRpX2luZm9fcmVhZChjdXJsbSwgJm51bV9tZXNzYWdlcyk7CgoJd2hpbGUgKGN1cmxfbWVzc2FnZSAhPSBOVUxMKSB7CgkJaWYgKGN1cmxfbWVzc2FnZS0+bXNnID09IENVUkxNU0dfRE9ORSkgewoJCQlpbnQgY3VybF9yZXN1bHQgPSBjdXJsX21lc3NhZ2UtPmRhdGEucmVzdWx0OwoJCQlzbG90ID0gYWN0aXZlX3F1ZXVlX2hlYWQ7CgkJCXdoaWxlIChzbG90ICE9IE5VTEwgJiYKCQkJICAgICAgIHNsb3QtPmN1cmwgIT0gY3VybF9tZXNzYWdlLT5lYXN5X2hhbmRsZSkKCQkJCXNsb3QgPSBzbG90LT5uZXh0OwoJCQlpZiAoc2xvdCAhPSBOVUxMKSB7CgkJCQljdXJsX211bHRpX3JlbW92ZV9oYW5kbGUoY3VybG0sIHNsb3QtPmN1cmwpOwoJCQkJc2xvdC0+Y3VybF9yZXN1bHQgPSBjdXJsX3Jlc3VsdDsKCQkJCWZpbmlzaF9hY3RpdmVfc2xvdChzbG90KTsKCQkJfSBlbHNlIHsKCQkJCWZwcmludGYoc3RkZXJyLCAiUmVjZWl2ZWQgRE9ORSBtZXNzYWdlIGZvciB1bmtub3duIHJlcXVlc3QhXG4iKTsKCQkJfQoJCX0gZWxzZSB7CgkJCWZwcmludGYoc3RkZXJyLCAiVW5rbm93biBDVVJMIG1lc3NhZ2UgcmVjZWl2ZWQ6ICVkXG4iLAoJCQkJKGludCljdXJsX21lc3NhZ2UtPm1zZyk7CgkJfQoJCWN1cmxfbWVzc2FnZSA9IGN1cmxfbXVsdGlfaW5mb19yZWFkKGN1cmxtLCAmbnVtX21lc3NhZ2VzKTsKCX0KfQojZW5kaWYKCnN0YXRpYyBpbnQgaHR0cF9vcHRpb25zKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmNiKQp7CglpZiAoIXN0cmNtcCgiaHR0cC5zc2x2ZXJpZnkiLCB2YXIpKSB7CgkJY3VybF9zc2xfdmVyaWZ5ID0gZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoImh0dHAuc3NsY2VydCIsIHZhcikpCgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZzc2xfY2VydCwgdmFyLCB2YWx1ZSk7CiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwOTAzCglpZiAoIXN0cmNtcCgiaHR0cC5zc2xrZXkiLCB2YXIpKQoJCXJldHVybiBnaXRfY29uZmlnX3N0cmluZygmc3NsX2tleSwgdmFyLCB2YWx1ZSk7CiNlbmRpZgojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MDkwOAoJaWYgKCFzdHJjbXAoImh0dHAuc3NsY2FwYXRoIiwgdmFyKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJnNzbF9jYXBhdGgsIHZhciwgdmFsdWUpOwojZW5kaWYKCWlmICghc3RyY21wKCJodHRwLnNzbGNhaW5mbyIsIHZhcikpCgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZzc2xfY2FpbmZvLCB2YXIsIHZhbHVlKTsKCWlmICghc3RyY21wKCJodHRwLnNzbGNlcnRwYXNzd29yZHByb3RlY3RlZCIsIHZhcikpIHsKCQlzc2xfY2VydF9wYXNzd29yZF9yZXF1aXJlZCA9IGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKCJodHRwLnNzbHRyeSIsIHZhcikpIHsKCQljdXJsX3NzbF90cnkgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCgiaHR0cC5taW5zZXNzaW9ucyIsIHZhcikpIHsKCQltaW5fY3VybF9zZXNzaW9ucyA9IGdpdF9jb25maWdfaW50KHZhciwgdmFsdWUpOwojaWZuZGVmIFVTRV9DVVJMX01VTFRJCgkJaWYgKG1pbl9jdXJsX3Nlc3Npb25zID4gMSkKCQkJbWluX2N1cmxfc2Vzc2lvbnMgPSAxOwojZW5kaWYKCQlyZXR1cm4gMDsKCX0KI2lmZGVmIFVTRV9DVVJMX01VTFRJCglpZiAoIXN0cmNtcCgiaHR0cC5tYXhyZXF1ZXN0cyIsIHZhcikpIHsKCQltYXhfcmVxdWVzdHMgPSBnaXRfY29uZmlnX2ludCh2YXIsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KI2VuZGlmCglpZiAoIXN0cmNtcCgiaHR0cC5sb3dzcGVlZGxpbWl0IiwgdmFyKSkgewoJCWN1cmxfbG93X3NwZWVkX2xpbWl0ID0gKGxvbmcpZ2l0X2NvbmZpZ19pbnQodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCgiaHR0cC5sb3dzcGVlZHRpbWUiLCB2YXIpKSB7CgkJY3VybF9sb3dfc3BlZWRfdGltZSA9IChsb25nKWdpdF9jb25maWdfaW50KHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoKCWlmICghc3RyY21wKCJodHRwLm5vZXBzdiIsIHZhcikpIHsKCQljdXJsX2Z0cF9ub19lcHN2ID0gZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoImh0dHAucHJveHkiLCB2YXIpKQoJCXJldHVybiBnaXRfY29uZmlnX3N0cmluZygmY3VybF9odHRwX3Byb3h5LCB2YXIsIHZhbHVlKTsKCglpZiAoIXN0cmNtcCgiaHR0cC5jb29raWVmaWxlIiwgdmFyKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJmN1cmxfY29va2llX2ZpbGUsIHZhciwgdmFsdWUpOwoJaWYgKCFzdHJjbXAoImh0dHAuc2F2ZWNvb2tpZXMiLCB2YXIpKSB7CgkJY3VybF9zYXZlX2Nvb2tpZXMgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKCFzdHJjbXAoImh0dHAucG9zdGJ1ZmZlciIsIHZhcikpIHsKCQlodHRwX3Bvc3RfYnVmZmVyID0gZ2l0X2NvbmZpZ19pbnQodmFyLCB2YWx1ZSk7CgkJaWYgKGh0dHBfcG9zdF9idWZmZXIgPCBMQVJHRV9QQUNLRVRfTUFYKQoJCQlodHRwX3Bvc3RfYnVmZmVyID0gTEFSR0VfUEFDS0VUX01BWDsKCQlyZXR1cm4gMDsKCX0KCglpZiAoIXN0cmNtcCgiaHR0cC51c2VyYWdlbnQiLCB2YXIpKQoJCXJldHVybiBnaXRfY29uZmlnX3N0cmluZygmdXNlcl9hZ2VudCwgdmFyLCB2YWx1ZSk7CgoJLyogRmFsbCBiYWNrIG9uIHRoZSBkZWZhdWx0IG9uZXMgKi8KCXJldHVybiBnaXRfZGVmYXVsdF9jb25maWcodmFyLCB2YWx1ZSwgY2IpOwp9CgpzdGF0aWMgdm9pZCBpbml0X2N1cmxfaHR0cF9hdXRoKENVUkwgKnJlc3VsdCkKewoJaWYgKCFodHRwX2F1dGgudXNlcm5hbWUpCgkJcmV0dXJuOwoKCWNyZWRlbnRpYWxfZmlsbCgmaHR0cF9hdXRoKTsKCiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcxMzAxCgljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9VU0VSTkFNRSwgaHR0cF9hdXRoLnVzZXJuYW1lKTsKCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX1BBU1NXT1JELCBodHRwX2F1dGgucGFzc3dvcmQpOwojZWxzZQoJewoJCXN0YXRpYyBzdHJ1Y3Qgc3RyYnVmIHVwID0gU1RSQlVGX0lOSVQ7CgkJLyoKCQkgKiBOb3RlIHRoYXQgd2UgYXNzdW1lIHdlIG9ubHkgZXZlciBoYXZlIGEgc2luZ2xlIHNldCBvZgoJCSAqIGNyZWRlbnRpYWxzIGluIGEgZ2l2ZW4gcHJvZ3JhbSBydW4sIHNvIHdlIGRvIG5vdCBoYXZlCgkJICogdG8gd29ycnkgYWJvdXQgdXBkYXRpbmcgdGhpcyBidWZmZXIsIG9ubHkgc2V0dGluZyBpdHMKCQkgKiBpbml0aWFsIHZhbHVlLgoJCSAqLwoJCWlmICghdXAubGVuKQoJCQlzdHJidWZfYWRkZigmdXAsICIlczolcyIsCgkJCQlodHRwX2F1dGgudXNlcm5hbWUsIGh0dHBfYXV0aC5wYXNzd29yZCk7CgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfVVNFUlBXRCwgdXAuYnVmKTsKCX0KI2VuZGlmCn0KCnN0YXRpYyBpbnQgaGFzX2NlcnRfcGFzc3dvcmQodm9pZCkKewoJaWYgKHNzbF9jZXJ0ID09IE5VTEwgfHwgc3NsX2NlcnRfcGFzc3dvcmRfcmVxdWlyZWQgIT0gMSkKCQlyZXR1cm4gMDsKCWlmICghY2VydF9hdXRoLnBhc3N3b3JkKSB7CgkJY2VydF9hdXRoLnByb3RvY29sID0geHN0cmR1cCgiY2VydCIpOwoJCWNlcnRfYXV0aC51c2VybmFtZSA9IHhzdHJkdXAoIiIpOwoJCWNlcnRfYXV0aC5wYXRoID0geHN0cmR1cChzc2xfY2VydCk7CgkJY3JlZGVudGlhbF9maWxsKCZjZXJ0X2F1dGgpOwoJfQoJcmV0dXJuIDE7Cn0KCiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcxOTAwCnN0YXRpYyB2b2lkIHNldF9jdXJsX2tlZXBhbGl2ZShDVVJMICpjKQp7CgljdXJsX2Vhc3lfc2V0b3B0KGMsIENVUkxPUFRfVENQX0tFRVBBTElWRSwgMSk7Cn0KCiNlbGlmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzEwMDAKc3RhdGljIGludCBzb2Nrb3B0X2NhbGxiYWNrKHZvaWQgKmNsaWVudCwgY3VybF9zb2NrZXRfdCBmZCwgY3VybHNvY2t0eXBlIHR5cGUpCnsKCWludCBrYSA9IDE7CglpbnQgcmM7Cglzb2NrbGVuX3QgbGVuID0gKHNvY2tsZW5fdClzaXplb2Yoa2EpOwoKCWlmICh0eXBlICE9IENVUkxTT0NLVFlQRV9JUENYTikKCQlyZXR1cm4gMDsKCglyYyA9IHNldHNvY2tvcHQoZmQsIFNPTF9TT0NLRVQsIFNPX0tFRVBBTElWRSwgKHZvaWQgKikma2EsIGxlbik7CglpZiAocmMgPCAwKQoJCXdhcm5pbmcoInVuYWJsZSB0byBzZXQgU09fS0VFUEFMSVZFIG9uIHNvY2tldCAlcyIsCgkJCXN0cmVycm9yKGVycm5vKSk7CgoJcmV0dXJuIDA7IC8qIENVUkxfU09DS09QVF9PSyBvbmx5IGV4aXN0cyBzaW5jZSBjdXJsIDcuMjEuNSAqLwp9CgpzdGF0aWMgdm9pZCBzZXRfY3VybF9rZWVwYWxpdmUoQ1VSTCAqYykKewoJY3VybF9lYXN5X3NldG9wdChjLCBDVVJMT1BUX1NPQ0tPUFRGVU5DVElPTiwgc29ja29wdF9jYWxsYmFjayk7Cn0KCiNlbHNlCnN0YXRpYyB2b2lkIHNldF9jdXJsX2tlZXBhbGl2ZShDVVJMICpjKQp7CgkvKiBub3Qgc3VwcG9ydGVkIG9uIG9sZGVyIGN1cmwgdmVyc2lvbnMgKi8KfQojZW5kaWYKCnN0YXRpYyBDVVJMICpnZXRfY3VybF9oYW5kbGUodm9pZCkKewoJQ1VSTCAqcmVzdWx0ID0gY3VybF9lYXN5X2luaXQoKTsKCglpZiAoIXJlc3VsdCkKCQlkaWUoImN1cmxfZWFzeV9pbml0IGZhaWxlZCIpOwoKCWlmICghY3VybF9zc2xfdmVyaWZ5KSB7CgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfU1NMX1ZFUklGWVBFRVIsIDApOwoJCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX1NTTF9WRVJJRllIT1NULCAwKTsKCX0gZWxzZSB7CgkJLyogVmVyaWZ5IGF1dGhlbnRpY2l0eSBvZiB0aGUgcGVlcidzIGNlcnRpZmljYXRlICovCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfU1NMX1ZFUklGWVBFRVIsIDEpOwoJCS8qIFRoZSBuYW1lIGluIHRoZSBjZXJ0IG11c3QgbWF0Y2ggd2hvbSB3ZSB0cmllZCB0byBjb25uZWN0ICovCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfU1NMX1ZFUklGWUhPU1QsIDIpOwoJfQoKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzA5MDcKCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX05FVFJDLCBDVVJMX05FVFJDX09QVElPTkFMKTsKI2VuZGlmCiNpZmRlZiBMSUJDVVJMX0NBTl9IQU5ETEVfQVVUSF9BTlkKCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX0hUVFBBVVRILCBDVVJMQVVUSF9BTlkpOwojZW5kaWYKCglpZiAoaHR0cF9wcm9hY3RpdmVfYXV0aCkKCQlpbml0X2N1cmxfaHR0cF9hdXRoKHJlc3VsdCk7CgoJaWYgKHNzbF9jZXJ0ICE9IE5VTEwpCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfU1NMQ0VSVCwgc3NsX2NlcnQpOwoJaWYgKGhhc19jZXJ0X3Bhc3N3b3JkKCkpCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfS0VZUEFTU1dELCBjZXJ0X2F1dGgucGFzc3dvcmQpOwojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MDkwMwoJaWYgKHNzbF9rZXkgIT0gTlVMTCkKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9TU0xLRVksIHNzbF9rZXkpOwojZW5kaWYKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzA5MDgKCWlmIChzc2xfY2FwYXRoICE9IE5VTEwpCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfQ0FQQVRILCBzc2xfY2FwYXRoKTsKI2VuZGlmCglpZiAoc3NsX2NhaW5mbyAhPSBOVUxMKQoJCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX0NBSU5GTywgc3NsX2NhaW5mbyk7CgoJaWYgKGN1cmxfbG93X3NwZWVkX2xpbWl0ID4gMCAmJiBjdXJsX2xvd19zcGVlZF90aW1lID4gMCkgewoJCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX0xPV19TUEVFRF9MSU1JVCwKCQkJCSBjdXJsX2xvd19zcGVlZF9saW1pdCk7CgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfTE9XX1NQRUVEX1RJTUUsCgkJCQkgY3VybF9sb3dfc3BlZWRfdGltZSk7Cgl9CgoJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfRk9MTE9XTE9DQVRJT04sIDEpOwojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MTMwMQoJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfUE9TVFJFRElSLCBDVVJMX1JFRElSX1BPU1RfQUxMKTsKI2VsaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MTEwMQoJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfUE9TVDMwMSwgMSk7CiNlbmRpZgoKCWlmIChnZXRlbnYoIkdJVF9DVVJMX1ZFUkJPU0UiKSkKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9WRVJCT1NFLCAxKTsKCgljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9VU0VSQUdFTlQsCgkJdXNlcl9hZ2VudCA/IHVzZXJfYWdlbnQgOiBnaXRfdXNlcl9hZ2VudCgpKTsKCglpZiAoY3VybF9mdHBfbm9fZXBzdikKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9GVFBfVVNFX0VQU1YsIDApOwoKI2lmZGVmIENVUkxPUFRfVVNFX1NTTAoJaWYgKGN1cmxfc3NsX3RyeSkKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9VU0VfU1NMLCBDVVJMVVNFU1NMX1RSWSk7CiNlbmRpZgoKCWlmIChjdXJsX2h0dHBfcHJveHkpIHsKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9QUk9YWSwgY3VybF9odHRwX3Byb3h5KTsKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9QUk9YWUFVVEgsIENVUkxBVVRIX0FOWSk7Cgl9CgoJc2V0X2N1cmxfa2VlcGFsaXZlKHJlc3VsdCk7CgoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIHZvaWQgc2V0X2Zyb21fZW52KGNvbnN0IGNoYXIgKip2YXIsIGNvbnN0IGNoYXIgKmVudm5hbWUpCnsKCWNvbnN0IGNoYXIgKnZhbCA9IGdldGVudihlbnZuYW1lKTsKCWlmICh2YWwpCgkJKnZhciA9IHZhbDsKfQoKdm9pZCBodHRwX2luaXQoc3RydWN0IHJlbW90ZSAqcmVtb3RlLCBjb25zdCBjaGFyICp1cmwsIGludCBwcm9hY3RpdmVfYXV0aCkKewoJY2hhciAqbG93X3NwZWVkX2xpbWl0OwoJY2hhciAqbG93X3NwZWVkX3RpbWU7CgljaGFyICpub3JtYWxpemVkX3VybDsKCXN0cnVjdCB1cmxtYXRjaF9jb25maWcgY29uZmlnID0geyBTVFJJTkdfTElTVF9JTklUX0RVUCB9OwoKCWNvbmZpZy5zZWN0aW9uID0gImh0dHAiOwoJY29uZmlnLmtleSA9IE5VTEw7Cgljb25maWcuY29sbGVjdF9mbiA9IGh0dHBfb3B0aW9uczsKCWNvbmZpZy5jYXNjYWRlX2ZuID0gZ2l0X2RlZmF1bHRfY29uZmlnOwoJY29uZmlnLmNiID0gTlVMTDsKCglodHRwX2lzX3ZlcmJvc2UgPSAwOwoJbm9ybWFsaXplZF91cmwgPSB1cmxfbm9ybWFsaXplKHVybCwgJmNvbmZpZy51cmwpOwoKCWdpdF9jb25maWcodXJsbWF0Y2hfY29uZmlnX2VudHJ5LCAmY29uZmlnKTsKCWZyZWUobm9ybWFsaXplZF91cmwpOwoKCWlmIChjdXJsX2dsb2JhbF9pbml0KENVUkxfR0xPQkFMX0FMTCkgIT0gQ1VSTEVfT0spCgkJZGllKCJjdXJsX2dsb2JhbF9pbml0IGZhaWxlZCIpOwoKCWh0dHBfcHJvYWN0aXZlX2F1dGggPSBwcm9hY3RpdmVfYXV0aDsKCglpZiAocmVtb3RlICYmIHJlbW90ZS0+aHR0cF9wcm94eSkKCQljdXJsX2h0dHBfcHJveHkgPSB4c3RyZHVwKHJlbW90ZS0+aHR0cF9wcm94eSk7CgoJcHJhZ21hX2hlYWRlciA9IGN1cmxfc2xpc3RfYXBwZW5kKHByYWdtYV9oZWFkZXIsICJQcmFnbWE6IG5vLWNhY2hlIik7Cglub19wcmFnbWFfaGVhZGVyID0gY3VybF9zbGlzdF9hcHBlbmQobm9fcHJhZ21hX2hlYWRlciwgIlByYWdtYToiKTsKCiNpZmRlZiBVU0VfQ1VSTF9NVUxUSQoJewoJCWNoYXIgKmh0dHBfbWF4X3JlcXVlc3RzID0gZ2V0ZW52KCJHSVRfSFRUUF9NQVhfUkVRVUVTVFMiKTsKCQlpZiAoaHR0cF9tYXhfcmVxdWVzdHMgIT0gTlVMTCkKCQkJbWF4X3JlcXVlc3RzID0gYXRvaShodHRwX21heF9yZXF1ZXN0cyk7Cgl9CgoJY3VybG0gPSBjdXJsX211bHRpX2luaXQoKTsKCWlmICghY3VybG0pCgkJZGllKCJjdXJsX211bHRpX2luaXQgZmFpbGVkIik7CiNlbmRpZgoKCWlmIChnZXRlbnYoIkdJVF9TU0xfTk9fVkVSSUZZIikpCgkJY3VybF9zc2xfdmVyaWZ5ID0gMDsKCglzZXRfZnJvbV9lbnYoJnNzbF9jZXJ0LCAiR0lUX1NTTF9DRVJUIik7CiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwOTAzCglzZXRfZnJvbV9lbnYoJnNzbF9rZXksICJHSVRfU1NMX0tFWSIpOwojZW5kaWYKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzA5MDgKCXNldF9mcm9tX2Vudigmc3NsX2NhcGF0aCwgIkdJVF9TU0xfQ0FQQVRIIik7CiNlbmRpZgoJc2V0X2Zyb21fZW52KCZzc2xfY2FpbmZvLCAiR0lUX1NTTF9DQUlORk8iKTsKCglzZXRfZnJvbV9lbnYoJnVzZXJfYWdlbnQsICJHSVRfSFRUUF9VU0VSX0FHRU5UIik7CgoJbG93X3NwZWVkX2xpbWl0ID0gZ2V0ZW52KCJHSVRfSFRUUF9MT1dfU1BFRURfTElNSVQiKTsKCWlmIChsb3dfc3BlZWRfbGltaXQgIT0gTlVMTCkKCQljdXJsX2xvd19zcGVlZF9saW1pdCA9IHN0cnRvbChsb3dfc3BlZWRfbGltaXQsIE5VTEwsIDEwKTsKCWxvd19zcGVlZF90aW1lID0gZ2V0ZW52KCJHSVRfSFRUUF9MT1dfU1BFRURfVElNRSIpOwoJaWYgKGxvd19zcGVlZF90aW1lICE9IE5VTEwpCgkJY3VybF9sb3dfc3BlZWRfdGltZSA9IHN0cnRvbChsb3dfc3BlZWRfdGltZSwgTlVMTCwgMTApOwoKCWlmIChjdXJsX3NzbF92ZXJpZnkgPT0gLTEpCgkJY3VybF9zc2xfdmVyaWZ5ID0gMTsKCgljdXJsX3Nlc3Npb25fY291bnQgPSAwOwojaWZkZWYgVVNFX0NVUkxfTVVMVEkKCWlmIChtYXhfcmVxdWVzdHMgPCAxKQoJCW1heF9yZXF1ZXN0cyA9IERFRkFVTFRfTUFYX1JFUVVFU1RTOwojZW5kaWYKCglpZiAoZ2V0ZW52KCJHSVRfQ1VSTF9GVFBfTk9fRVBTViIpKQoJCWN1cmxfZnRwX25vX2Vwc3YgPSAxOwoKCWlmICh1cmwpIHsKCQljcmVkZW50aWFsX2Zyb21fdXJsKCZodHRwX2F1dGgsIHVybCk7CgkJaWYgKCFzc2xfY2VydF9wYXNzd29yZF9yZXF1aXJlZCAmJgoJCSAgICBnZXRlbnYoIkdJVF9TU0xfQ0VSVF9QQVNTV09SRF9QUk9URUNURUQiKSAmJgoJCSAgICBzdGFydHNfd2l0aCh1cmwsICJodHRwczovLyIpKQoJCQlzc2xfY2VydF9wYXNzd29yZF9yZXF1aXJlZCA9IDE7Cgl9CgojaWZuZGVmIE5PX0NVUkxfRUFTWV9EVVBIQU5ETEUKCWN1cmxfZGVmYXVsdCA9IGdldF9jdXJsX2hhbmRsZSgpOwojZW5kaWYKfQoKdm9pZCBodHRwX2NsZWFudXAodm9pZCkKewoJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3QgPSBhY3RpdmVfcXVldWVfaGVhZDsKCgl3aGlsZSAoc2xvdCAhPSBOVUxMKSB7CgkJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKm5leHQgPSBzbG90LT5uZXh0OwoJCWlmIChzbG90LT5jdXJsICE9IE5VTEwpIHsKI2lmZGVmIFVTRV9DVVJMX01VTFRJCgkJCWN1cmxfbXVsdGlfcmVtb3ZlX2hhbmRsZShjdXJsbSwgc2xvdC0+Y3VybCk7CiNlbmRpZgoJCQljdXJsX2Vhc3lfY2xlYW51cChzbG90LT5jdXJsKTsKCQl9CgkJZnJlZShzbG90KTsKCQlzbG90ID0gbmV4dDsKCX0KCWFjdGl2ZV9xdWV1ZV9oZWFkID0gTlVMTDsKCiNpZm5kZWYgTk9fQ1VSTF9FQVNZX0RVUEhBTkRMRQoJY3VybF9lYXN5X2NsZWFudXAoY3VybF9kZWZhdWx0KTsKI2VuZGlmCgojaWZkZWYgVVNFX0NVUkxfTVVMVEkKCWN1cmxfbXVsdGlfY2xlYW51cChjdXJsbSk7CiNlbmRpZgoJY3VybF9nbG9iYWxfY2xlYW51cCgpOwoKCWN1cmxfc2xpc3RfZnJlZV9hbGwocHJhZ21hX2hlYWRlcik7CglwcmFnbWFfaGVhZGVyID0gTlVMTDsKCgljdXJsX3NsaXN0X2ZyZWVfYWxsKG5vX3ByYWdtYV9oZWFkZXIpOwoJbm9fcHJhZ21hX2hlYWRlciA9IE5VTEw7CgoJaWYgKGN1cmxfaHR0cF9wcm94eSkgewoJCWZyZWUoKHZvaWQgKiljdXJsX2h0dHBfcHJveHkpOwoJCWN1cmxfaHR0cF9wcm94eSA9IE5VTEw7Cgl9CgoJaWYgKGNlcnRfYXV0aC5wYXNzd29yZCAhPSBOVUxMKSB7CgkJbWVtc2V0KGNlcnRfYXV0aC5wYXNzd29yZCwgMCwgc3RybGVuKGNlcnRfYXV0aC5wYXNzd29yZCkpOwoJCWZyZWUoY2VydF9hdXRoLnBhc3N3b3JkKTsKCQljZXJ0X2F1dGgucGFzc3dvcmQgPSBOVUxMOwoJfQoJc3NsX2NlcnRfcGFzc3dvcmRfcmVxdWlyZWQgPSAwOwoKCWZyZWUoY2FjaGVkX2FjY2VwdF9sYW5ndWFnZSk7CgljYWNoZWRfYWNjZXB0X2xhbmd1YWdlID0gTlVMTDsKfQoKc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKmdldF9hY3RpdmVfc2xvdCh2b2lkKQp7CglzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdCA9IGFjdGl2ZV9xdWV1ZV9oZWFkOwoJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKm5ld3Nsb3Q7CgojaWZkZWYgVVNFX0NVUkxfTVVMVEkKCWludCBudW1fdHJhbnNmZXJzOwoKCS8qIFdhaXQgZm9yIGEgc2xvdCB0byBvcGVuIHVwIGlmIHRoZSBxdWV1ZSBpcyBmdWxsICovCgl3aGlsZSAoYWN0aXZlX3JlcXVlc3RzID49IG1heF9yZXF1ZXN0cykgewoJCWN1cmxfbXVsdGlfcGVyZm9ybShjdXJsbSwgJm51bV90cmFuc2ZlcnMpOwoJCWlmIChudW1fdHJhbnNmZXJzIDwgYWN0aXZlX3JlcXVlc3RzKQoJCQlwcm9jZXNzX2N1cmxfbWVzc2FnZXMoKTsKCX0KI2VuZGlmCgoJd2hpbGUgKHNsb3QgIT0gTlVMTCAmJiBzbG90LT5pbl91c2UpCgkJc2xvdCA9IHNsb3QtPm5leHQ7CgoJaWYgKHNsb3QgPT0gTlVMTCkgewoJCW5ld3Nsb3QgPSB4bWFsbG9jKHNpemVvZigqbmV3c2xvdCkpOwoJCW5ld3Nsb3QtPmN1cmwgPSBOVUxMOwoJCW5ld3Nsb3QtPmluX3VzZSA9IDA7CgkJbmV3c2xvdC0+bmV4dCA9IE5VTEw7CgoJCXNsb3QgPSBhY3RpdmVfcXVldWVfaGVhZDsKCQlpZiAoc2xvdCA9PSBOVUxMKSB7CgkJCWFjdGl2ZV9xdWV1ZV9oZWFkID0gbmV3c2xvdDsKCQl9IGVsc2UgewoJCQl3aGlsZSAoc2xvdC0+bmV4dCAhPSBOVUxMKQoJCQkJc2xvdCA9IHNsb3QtPm5leHQ7CgkJCXNsb3QtPm5leHQgPSBuZXdzbG90OwoJCX0KCQlzbG90ID0gbmV3c2xvdDsKCX0KCglpZiAoc2xvdC0+Y3VybCA9PSBOVUxMKSB7CiNpZmRlZiBOT19DVVJMX0VBU1lfRFVQSEFORExFCgkJc2xvdC0+Y3VybCA9IGdldF9jdXJsX2hhbmRsZSgpOwojZWxzZQoJCXNsb3QtPmN1cmwgPSBjdXJsX2Vhc3lfZHVwaGFuZGxlKGN1cmxfZGVmYXVsdCk7CiNlbmRpZgoJCWN1cmxfc2Vzc2lvbl9jb3VudCsrOwoJfQoKCWFjdGl2ZV9yZXF1ZXN0cysrOwoJc2xvdC0+aW5fdXNlID0gMTsKCXNsb3QtPnJlc3VsdHMgPSBOVUxMOwoJc2xvdC0+ZmluaXNoZWQgPSBOVUxMOwoJc2xvdC0+Y2FsbGJhY2tfZGF0YSA9IE5VTEw7CglzbG90LT5jYWxsYmFja19mdW5jID0gTlVMTDsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9DT09LSUVGSUxFLCBjdXJsX2Nvb2tpZV9maWxlKTsKCWlmIChjdXJsX3NhdmVfY29va2llcykKCQljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfQ09PS0lFSkFSLCBjdXJsX2Nvb2tpZV9maWxlKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9IVFRQSEVBREVSLCBwcmFnbWFfaGVhZGVyKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9FUlJPUkJVRkZFUiwgY3VybF9lcnJvcnN0cik7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfQ1VTVE9NUkVRVUVTVCwgTlVMTCk7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfUkVBREZVTkNUSU9OLCBOVUxMKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9XUklURUZVTkNUSU9OLCBOVUxMKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NURklFTERTLCBOVUxMKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9VUExPQUQsIDApOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0hUVFBHRVQsIDEpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0ZBSUxPTkVSUk9SLCAxKTsKCWlmIChodHRwX2F1dGgucGFzc3dvcmQpCgkJaW5pdF9jdXJsX2h0dHBfYXV0aChzbG90LT5jdXJsKTsKCglyZXR1cm4gc2xvdDsKfQoKaW50IHN0YXJ0X2FjdGl2ZV9zbG90KHN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90KQp7CiNpZmRlZiBVU0VfQ1VSTF9NVUxUSQoJQ1VSTE1jb2RlIGN1cmxtX3Jlc3VsdCA9IGN1cmxfbXVsdGlfYWRkX2hhbmRsZShjdXJsbSwgc2xvdC0+Y3VybCk7CglpbnQgbnVtX3RyYW5zZmVyczsKCglpZiAoY3VybG1fcmVzdWx0ICE9IENVUkxNX09LICYmCgkgICAgY3VybG1fcmVzdWx0ICE9IENVUkxNX0NBTExfTVVMVElfUEVSRk9STSkgewoJCWFjdGl2ZV9yZXF1ZXN0cy0tOwoJCXNsb3QtPmluX3VzZSA9IDA7CgkJcmV0dXJuIDA7Cgl9CgoJLyoKCSAqIFdlIGtub3cgdGhlcmUgbXVzdCBiZSBzb21ldGhpbmcgdG8gZG8sIHNpbmNlIHdlIGp1c3QgYWRkZWQKCSAqIHNvbWV0aGluZy4KCSAqLwoJY3VybF9tdWx0aV9wZXJmb3JtKGN1cmxtLCAmbnVtX3RyYW5zZmVycyk7CiNlbmRpZgoJcmV0dXJuIDE7Cn0KCiNpZmRlZiBVU0VfQ1VSTF9NVUxUSQpzdHJ1Y3QgZmlsbF9jaGFpbiB7Cgl2b2lkICpkYXRhOwoJaW50ICgqZmlsbCkodm9pZCAqKTsKCXN0cnVjdCBmaWxsX2NoYWluICpuZXh0Owp9OwoKc3RhdGljIHN0cnVjdCBmaWxsX2NoYWluICpmaWxsX2NmZzsKCnZvaWQgYWRkX2ZpbGxfZnVuY3Rpb24odm9pZCAqZGF0YSwgaW50ICgqZmlsbCkodm9pZCAqKSkKewoJc3RydWN0IGZpbGxfY2hhaW4gKm5ldyA9IHhtYWxsb2Moc2l6ZW9mKCpuZXcpKTsKCXN0cnVjdCBmaWxsX2NoYWluICoqbGlua3AgPSAmZmlsbF9jZmc7CgluZXctPmRhdGEgPSBkYXRhOwoJbmV3LT5maWxsID0gZmlsbDsKCW5ldy0+bmV4dCA9IE5VTEw7Cgl3aGlsZSAoKmxpbmtwKQoJCWxpbmtwID0gJigqbGlua3ApLT5uZXh0OwoJKmxpbmtwID0gbmV3Owp9Cgp2b2lkIGZpbGxfYWN0aXZlX3Nsb3RzKHZvaWQpCnsKCXN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90ID0gYWN0aXZlX3F1ZXVlX2hlYWQ7CgoJd2hpbGUgKGFjdGl2ZV9yZXF1ZXN0cyA8IG1heF9yZXF1ZXN0cykgewoJCXN0cnVjdCBmaWxsX2NoYWluICpmaWxsOwoJCWZvciAoZmlsbCA9IGZpbGxfY2ZnOyBmaWxsOyBmaWxsID0gZmlsbC0+bmV4dCkKCQkJaWYgKGZpbGwtPmZpbGwoZmlsbC0+ZGF0YSkpCgkJCQlicmVhazsKCgkJaWYgKCFmaWxsKQoJCQlicmVhazsKCX0KCgl3aGlsZSAoc2xvdCAhPSBOVUxMKSB7CgkJaWYgKCFzbG90LT5pbl91c2UgJiYgc2xvdC0+Y3VybCAhPSBOVUxMCgkJCSYmIGN1cmxfc2Vzc2lvbl9jb3VudCA+IG1pbl9jdXJsX3Nlc3Npb25zKSB7CgkJCWN1cmxfZWFzeV9jbGVhbnVwKHNsb3QtPmN1cmwpOwoJCQlzbG90LT5jdXJsID0gTlVMTDsKCQkJY3VybF9zZXNzaW9uX2NvdW50LS07CgkJfQoJCXNsb3QgPSBzbG90LT5uZXh0OwoJfQp9Cgp2b2lkIHN0ZXBfYWN0aXZlX3Nsb3RzKHZvaWQpCnsKCWludCBudW1fdHJhbnNmZXJzOwoJQ1VSTE1jb2RlIGN1cmxtX3Jlc3VsdDsKCglkbyB7CgkJY3VybG1fcmVzdWx0ID0gY3VybF9tdWx0aV9wZXJmb3JtKGN1cmxtLCAmbnVtX3RyYW5zZmVycyk7Cgl9IHdoaWxlIChjdXJsbV9yZXN1bHQgPT0gQ1VSTE1fQ0FMTF9NVUxUSV9QRVJGT1JNKTsKCWlmIChudW1fdHJhbnNmZXJzIDwgYWN0aXZlX3JlcXVlc3RzKSB7CgkJcHJvY2Vzc19jdXJsX21lc3NhZ2VzKCk7CgkJZmlsbF9hY3RpdmVfc2xvdHMoKTsKCX0KfQojZW5kaWYKCnZvaWQgcnVuX2FjdGl2ZV9zbG90KHN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90KQp7CiNpZmRlZiBVU0VfQ1VSTF9NVUxUSQoJZmRfc2V0IHJlYWRmZHM7CglmZF9zZXQgd3JpdGVmZHM7CglmZF9zZXQgZXhjZmRzOwoJaW50IG1heF9mZDsKCXN0cnVjdCB0aW1ldmFsIHNlbGVjdF90aW1lb3V0OwoJaW50IGZpbmlzaGVkID0gMDsKCglzbG90LT5maW5pc2hlZCA9ICZmaW5pc2hlZDsKCXdoaWxlICghZmluaXNoZWQpIHsKCQlzdGVwX2FjdGl2ZV9zbG90cygpOwoKCQlpZiAoc2xvdC0+aW5fdXNlKSB7CiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwZjA0CgkJCWxvbmcgY3VybF90aW1lb3V0OwoJCQljdXJsX211bHRpX3RpbWVvdXQoY3VybG0sICZjdXJsX3RpbWVvdXQpOwoJCQlpZiAoY3VybF90aW1lb3V0ID09IDApIHsKCQkJCWNvbnRpbnVlOwoJCQl9IGVsc2UgaWYgKGN1cmxfdGltZW91dCA9PSAtMSkgewoJCQkJc2VsZWN0X3RpbWVvdXQudHZfc2VjICA9IDA7CgkJCQlzZWxlY3RfdGltZW91dC50dl91c2VjID0gNTAwMDA7CgkJCX0gZWxzZSB7CgkJCQlzZWxlY3RfdGltZW91dC50dl9zZWMgID0gIGN1cmxfdGltZW91dCAvIDEwMDA7CgkJCQlzZWxlY3RfdGltZW91dC50dl91c2VjID0gKGN1cmxfdGltZW91dCAlIDEwMDApICogMTAwMDsKCQkJfQojZWxzZQoJCQlzZWxlY3RfdGltZW91dC50dl9zZWMgID0gMDsKCQkJc2VsZWN0X3RpbWVvdXQudHZfdXNlYyA9IDUwMDAwOwojZW5kaWYKCgkJCW1heF9mZCA9IC0xOwoJCQlGRF9aRVJPKCZyZWFkZmRzKTsKCQkJRkRfWkVSTygmd3JpdGVmZHMpOwoJCQlGRF9aRVJPKCZleGNmZHMpOwoJCQljdXJsX211bHRpX2Zkc2V0KGN1cmxtLCAmcmVhZGZkcywgJndyaXRlZmRzLCAmZXhjZmRzLCAmbWF4X2ZkKTsKCgkJCS8qCgkJCSAqIEl0IGNhbiBoYXBwZW4gdGhhdCBjdXJsX211bHRpX3RpbWVvdXQgcmV0dXJucyBhIHBhdGhvbG9naWNhbGx5CgkJCSAqIGxvbmcgdGltZW91dCB3aGVuIGN1cmxfbXVsdGlfZmRzZXQgcmV0dXJucyBubyBmaWxlIGRlc2NyaXB0b3JzCgkJCSAqIHRvIHJlYWQuICBTZWUgY29tbWl0IG1lc3NhZ2UgZm9yIG1vcmUgZGV0YWlscy4KCQkJICovCgkJCWlmIChtYXhfZmQgPCAwICYmCgkJCSAgICAoc2VsZWN0X3RpbWVvdXQudHZfc2VjID4gMCB8fAoJCQkgICAgIHNlbGVjdF90aW1lb3V0LnR2X3VzZWMgPiA1MDAwMCkpIHsKCQkJCXNlbGVjdF90aW1lb3V0LnR2X3NlYyAgPSAwOwoJCQkJc2VsZWN0X3RpbWVvdXQudHZfdXNlYyA9IDUwMDAwOwoJCQl9CgoJCQlzZWxlY3QobWF4X2ZkKzEsICZyZWFkZmRzLCAmd3JpdGVmZHMsICZleGNmZHMsICZzZWxlY3RfdGltZW91dCk7CgkJfQoJfQojZWxzZQoJd2hpbGUgKHNsb3QtPmluX3VzZSkgewoJCXNsb3QtPmN1cmxfcmVzdWx0ID0gY3VybF9lYXN5X3BlcmZvcm0oc2xvdC0+Y3VybCk7CgkJZmluaXNoX2FjdGl2ZV9zbG90KHNsb3QpOwoJfQojZW5kaWYKfQoKc3RhdGljIHZvaWQgY2xvc2Vkb3duX2FjdGl2ZV9zbG90KHN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90KQp7CglhY3RpdmVfcmVxdWVzdHMtLTsKCXNsb3QtPmluX3VzZSA9IDA7Cn0KCnN0YXRpYyB2b2lkIHJlbGVhc2VfYWN0aXZlX3Nsb3Qoc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3QpCnsKCWNsb3NlZG93bl9hY3RpdmVfc2xvdChzbG90KTsKCWlmIChzbG90LT5jdXJsICYmIGN1cmxfc2Vzc2lvbl9jb3VudCA+IG1pbl9jdXJsX3Nlc3Npb25zKSB7CiNpZmRlZiBVU0VfQ1VSTF9NVUxUSQoJCWN1cmxfbXVsdGlfcmVtb3ZlX2hhbmRsZShjdXJsbSwgc2xvdC0+Y3VybCk7CiNlbmRpZgoJCWN1cmxfZWFzeV9jbGVhbnVwKHNsb3QtPmN1cmwpOwoJCXNsb3QtPmN1cmwgPSBOVUxMOwoJCWN1cmxfc2Vzc2lvbl9jb3VudC0tOwoJfQojaWZkZWYgVVNFX0NVUkxfTVVMVEkKCWZpbGxfYWN0aXZlX3Nsb3RzKCk7CiNlbmRpZgp9Cgp2b2lkIGZpbmlzaF9hY3RpdmVfc2xvdChzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdCkKewoJY2xvc2Vkb3duX2FjdGl2ZV9zbG90KHNsb3QpOwoJY3VybF9lYXN5X2dldGluZm8oc2xvdC0+Y3VybCwgQ1VSTElORk9fSFRUUF9DT0RFLCAmc2xvdC0+aHR0cF9jb2RlKTsKCglpZiAoc2xvdC0+ZmluaXNoZWQgIT0gTlVMTCkKCQkoKnNsb3QtPmZpbmlzaGVkKSA9IDE7CgoJLyogU3RvcmUgc2xvdCByZXN1bHRzIHNvIHRoZXkgY2FuIGJlIHJlYWQgYWZ0ZXIgdGhlIHNsb3QgaXMgcmV1c2VkICovCglpZiAoc2xvdC0+cmVzdWx0cyAhPSBOVUxMKSB7CgkJc2xvdC0+cmVzdWx0cy0+Y3VybF9yZXN1bHQgPSBzbG90LT5jdXJsX3Jlc3VsdDsKCQlzbG90LT5yZXN1bHRzLT5odHRwX2NvZGUgPSBzbG90LT5odHRwX2NvZGU7CiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwYTA4CgkJY3VybF9lYXN5X2dldGluZm8oc2xvdC0+Y3VybCwgQ1VSTElORk9fSFRUUEFVVEhfQVZBSUwsCgkJCQkgICZzbG90LT5yZXN1bHRzLT5hdXRoX2F2YWlsKTsKI2Vsc2UKCQlzbG90LT5yZXN1bHRzLT5hdXRoX2F2YWlsID0gMDsKI2VuZGlmCgl9CgoJLyogUnVuIGNhbGxiYWNrIGlmIGFwcHJvcHJpYXRlICovCglpZiAoc2xvdC0+Y2FsbGJhY2tfZnVuYyAhPSBOVUxMKQoJCXNsb3QtPmNhbGxiYWNrX2Z1bmMoc2xvdC0+Y2FsbGJhY2tfZGF0YSk7Cn0KCnZvaWQgZmluaXNoX2FsbF9hY3RpdmVfc2xvdHModm9pZCkKewoJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3QgPSBhY3RpdmVfcXVldWVfaGVhZDsKCgl3aGlsZSAoc2xvdCAhPSBOVUxMKQoJCWlmIChzbG90LT5pbl91c2UpIHsKCQkJcnVuX2FjdGl2ZV9zbG90KHNsb3QpOwoJCQlzbG90ID0gYWN0aXZlX3F1ZXVlX2hlYWQ7CgkJfSBlbHNlIHsKCQkJc2xvdCA9IHNsb3QtPm5leHQ7CgkJfQp9CgovKiBIZWxwZXJzIGZvciBtb2RpZnlpbmcgYW5kIGNyZWF0aW5nIFVSTHMgKi8Kc3RhdGljIGlubGluZSBpbnQgbmVlZHNfcXVvdGUoaW50IGNoKQp7CglpZiAoKChjaCA+PSAnQScpICYmIChjaCA8PSAnWicpKQoJCQl8fCAoKGNoID49ICdhJykgJiYgKGNoIDw9ICd6JykpCgkJCXx8ICgoY2ggPj0gJzAnKSAmJiAoY2ggPD0gJzknKSkKCQkJfHwgKGNoID09ICcvJykKCQkJfHwgKGNoID09ICctJykKCQkJfHwgKGNoID09ICcuJykpCgkJcmV0dXJuIDA7CglyZXR1cm4gMTsKfQoKc3RhdGljIGNoYXIgKnF1b3RlX3JlZl91cmwoY29uc3QgY2hhciAqYmFzZSwgY29uc3QgY2hhciAqcmVmKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJY29uc3QgY2hhciAqY3A7CglpbnQgY2g7CgoJZW5kX3VybF93aXRoX3NsYXNoKCZidWYsIGJhc2UpOwoKCWZvciAoY3AgPSByZWY7IChjaCA9ICpjcCkgIT0gMDsgY3ArKykKCQlpZiAobmVlZHNfcXVvdGUoY2gpKQoJCQlzdHJidWZfYWRkZigmYnVmLCAiJSUlMDJ4IiwgY2gpOwoJCWVsc2UKCQkJc3RyYnVmX2FkZGNoKCZidWYsICpjcCk7CgoJcmV0dXJuIHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7Cn0KCnZvaWQgYXBwZW5kX3JlbW90ZV9vYmplY3RfdXJsKHN0cnVjdCBzdHJidWYgKmJ1ZiwgY29uc3QgY2hhciAqdXJsLAoJCQkgICAgICBjb25zdCBjaGFyICpoZXgsCgkJCSAgICAgIGludCBvbmx5X3R3b19kaWdpdF9wcmVmaXgpCnsKCWVuZF91cmxfd2l0aF9zbGFzaChidWYsIHVybCk7CgoJc3RyYnVmX2FkZGYoYnVmLCAib2JqZWN0cy8lLipzLyIsIDIsIGhleCk7CglpZiAoIW9ubHlfdHdvX2RpZ2l0X3ByZWZpeCkKCQlzdHJidWZfYWRkZihidWYsICIlcyIsIGhleCsyKTsKfQoKY2hhciAqZ2V0X3JlbW90ZV9vYmplY3RfdXJsKGNvbnN0IGNoYXIgKnVybCwgY29uc3QgY2hhciAqaGV4LAoJCQkgICAgaW50IG9ubHlfdHdvX2RpZ2l0X3ByZWZpeCkKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWFwcGVuZF9yZW1vdGVfb2JqZWN0X3VybCgmYnVmLCB1cmwsIGhleCwgb25seV90d29fZGlnaXRfcHJlZml4KTsKCXJldHVybiBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpOwp9CgppbnQgaGFuZGxlX2N1cmxfcmVzdWx0KHN0cnVjdCBzbG90X3Jlc3VsdHMgKnJlc3VsdHMpCnsKCS8qCgkgKiBJZiB3ZSBzZWUgYSBmYWlsaW5nIGh0dHAgY29kZSB3aXRoIENVUkxFX09LLCB3ZSBoYXZlIHR1cm5lZCBvZmYKCSAqIEZBSUxPTkVSUk9SICh0byBrZWVwIHRoZSBzZXJ2ZXIncyBjdXN0b20gZXJyb3IgcmVzcG9uc2UpLCBhbmQgc2hvdWxkCgkgKiB0cmFuc2xhdGUgdGhlIGNvZGUgaW50byBmYWlsdXJlIGhlcmUuCgkgKi8KCWlmIChyZXN1bHRzLT5jdXJsX3Jlc3VsdCA9PSBDVVJMRV9PSyAmJgoJICAgIHJlc3VsdHMtPmh0dHBfY29kZSA+PSA0MDApIHsKCQlyZXN1bHRzLT5jdXJsX3Jlc3VsdCA9IENVUkxFX0hUVFBfUkVUVVJORURfRVJST1I7CgkJLyoKCQkgKiBOb3JtYWxseSBjdXJsIHdpbGwgYWxyZWFkeSBoYXZlIHB1dCB0aGUgInJlYXNvbiBwaHJhc2UiCgkJICogZnJvbSB0aGUgc2VydmVyIGludG8gY3VybF9lcnJvcnN0cjsgdW5mb3J0dW5hdGVseSB3aXRob3V0CgkJICogRkFJTE9ORVJST1IgaXQgaXMgbG9zdCwgc28gd2UgY2FuIGdpdmUgb25seSB0aGUgbnVtZXJpYwoJCSAqIHN0YXR1cyBjb2RlLgoJCSAqLwoJCXNucHJpbnRmKGN1cmxfZXJyb3JzdHIsIHNpemVvZihjdXJsX2Vycm9yc3RyKSwKCQkJICJUaGUgcmVxdWVzdGVkIFVSTCByZXR1cm5lZCBlcnJvcjogJWxkIiwKCQkJIHJlc3VsdHMtPmh0dHBfY29kZSk7Cgl9CgoJaWYgKHJlc3VsdHMtPmN1cmxfcmVzdWx0ID09IENVUkxFX09LKSB7CgkJY3JlZGVudGlhbF9hcHByb3ZlKCZodHRwX2F1dGgpOwoJCXJldHVybiBIVFRQX09LOwoJfSBlbHNlIGlmIChtaXNzaW5nX3RhcmdldChyZXN1bHRzKSkKCQlyZXR1cm4gSFRUUF9NSVNTSU5HX1RBUkdFVDsKCWVsc2UgaWYgKHJlc3VsdHMtPmh0dHBfY29kZSA9PSA0MDEpIHsKCQlpZiAoaHR0cF9hdXRoLnVzZXJuYW1lICYmIGh0dHBfYXV0aC5wYXNzd29yZCkgewoJCQljcmVkZW50aWFsX3JlamVjdCgmaHR0cF9hdXRoKTsKCQkJcmV0dXJuIEhUVFBfTk9BVVRIOwoJCX0gZWxzZSB7CgkJCXJldHVybiBIVFRQX1JFQVVUSDsKCQl9Cgl9IGVsc2UgewojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MGMwMAoJCWlmICghY3VybF9lcnJvcnN0clswXSkKCQkJc3RybGNweShjdXJsX2Vycm9yc3RyLAoJCQkJY3VybF9lYXN5X3N0cmVycm9yKHJlc3VsdHMtPmN1cmxfcmVzdWx0KSwKCQkJCXNpemVvZihjdXJsX2Vycm9yc3RyKSk7CiNlbmRpZgoJCXJldHVybiBIVFRQX0VSUk9SOwoJfQp9CgppbnQgcnVuX29uZV9zbG90KHN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90LAoJCSBzdHJ1Y3Qgc2xvdF9yZXN1bHRzICpyZXN1bHRzKQp7CglzbG90LT5yZXN1bHRzID0gcmVzdWx0czsKCWlmICghc3RhcnRfYWN0aXZlX3Nsb3Qoc2xvdCkpIHsKCQlzbnByaW50ZihjdXJsX2Vycm9yc3RyLCBzaXplb2YoY3VybF9lcnJvcnN0ciksCgkJCSAiZmFpbGVkIHRvIHN0YXJ0IEhUVFAgcmVxdWVzdCIpOwoJCXJldHVybiBIVFRQX1NUQVJUX0ZBSUxFRDsKCX0KCglydW5fYWN0aXZlX3Nsb3Qoc2xvdCk7CglyZXR1cm4gaGFuZGxlX2N1cmxfcmVzdWx0KHJlc3VsdHMpOwp9CgpzdGF0aWMgQ1VSTGNvZGUgY3VybGluZm9fc3RyYnVmKENVUkwgKmN1cmwsIENVUkxJTkZPIGluZm8sIHN0cnVjdCBzdHJidWYgKmJ1ZikKewoJY2hhciAqcHRyOwoJQ1VSTGNvZGUgcmV0OwoKCXN0cmJ1Zl9yZXNldChidWYpOwoJcmV0ID0gY3VybF9lYXN5X2dldGluZm8oY3VybCwgaW5mbywgJnB0cik7CglpZiAoIXJldCAmJiBwdHIpCgkJc3RyYnVmX2FkZHN0cihidWYsIHB0cik7CglyZXR1cm4gcmV0Owp9CgovKgogKiBDaGVjayBmb3IgYW5kIGV4dHJhY3QgYSBjb250ZW50LXR5cGUgcGFyYW1ldGVyLiAicmF3IgogKiBzaG91bGQgYmUgcG9zaXRpb25lZCBhdCB0aGUgc3RhcnQgb2YgdGhlIHBvdGVudGlhbAogKiBwYXJhbWV0ZXIsIHdpdGggYW55IHdoaXRlc3BhY2UgYWxyZWFkeSByZW1vdmVkLgogKgogKiAibmFtZSIgaXMgdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlci4gVGhlIHZhbHVlIGlzIGFwcGVuZGVkCiAqIHRvICJvdXQiLgogKi8Kc3RhdGljIGludCBleHRyYWN0X3BhcmFtKGNvbnN0IGNoYXIgKnJhdywgY29uc3QgY2hhciAqbmFtZSwKCQkJIHN0cnVjdCBzdHJidWYgKm91dCkKewoJc2l6ZV90IGxlbiA9IHN0cmxlbihuYW1lKTsKCglpZiAoc3RybmNhc2VjbXAocmF3LCBuYW1lLCBsZW4pKQoJCXJldHVybiAtMTsKCXJhdyArPSBsZW47CgoJaWYgKCpyYXcgIT0gJz0nKQoJCXJldHVybiAtMTsKCXJhdysrOwoKCXdoaWxlICgqcmF3ICYmICFpc3NwYWNlKCpyYXcpICYmICpyYXcgIT0gJzsnKQoJCXN0cmJ1Zl9hZGRjaChvdXQsICpyYXcrKyk7CglyZXR1cm4gMDsKfQoKLyoKICogRXh0cmFjdCBhIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgY29udGVudCB0eXBlLCB3aXRoIGFueQogKiBzcGFjZXMgc3VwcHJlc3NlZCwgYWxsIGxldHRlcnMgbG93ZXJjYXNlZCwgYW5kIG5vIHRyYWlsaW5nICI7IgogKiBvciBwYXJhbWV0ZXJzLgogKgogKiBOb3RlIHRoYXQgd2Ugd2lsbCBzaWxlbnRseSByZW1vdmUgZXZlbiBpbnZhbGlkIHdoaXRlc3BhY2UuIEZvcgogKiBleGFtcGxlLCAidGV4dCAvIHBsYWluIiBpcyBzcGVjaWZpY2FsbHkgZm9yYmlkZGVuIGJ5IFJGQyAyNjE2LAogKiBidXQgInRleHQvcGxhaW4iIGlzIHRoZSBvbmx5IHJlYXNvbmFibGUgb3V0cHV0LCBhbmQgdGhpcyBrZWVwcwogKiBvdXIgY29kZSBzaW1wbGUuCiAqCiAqIElmIHRoZSAiY2hhcnNldCIgYXJndW1lbnQgaXMgbm90IE5VTEwsIHN0b3JlIHRoZSB2YWx1ZSBvZiBhbnkKICogY2hhcnNldCBwYXJhbWV0ZXIgdGhlcmUuCiAqCiAqIEV4YW1wbGU6CiAqICAgIlRFWFQvUExBSU47IGNoYXJzZXQ9dXRmLTgiIC0+ICJ0ZXh0L3BsYWluIiwgInV0Zi04IgogKiAgICJ0ZXh0IC8gcGxhaW4iIC0+ICJ0ZXh0L3BsYWluIgogKi8Kc3RhdGljIHZvaWQgZXh0cmFjdF9jb250ZW50X3R5cGUoc3RydWN0IHN0cmJ1ZiAqcmF3LCBzdHJ1Y3Qgc3RyYnVmICp0eXBlLAoJCQkJIHN0cnVjdCBzdHJidWYgKmNoYXJzZXQpCnsKCWNvbnN0IGNoYXIgKnA7CgoJc3RyYnVmX3Jlc2V0KHR5cGUpOwoJc3RyYnVmX2dyb3codHlwZSwgcmF3LT5sZW4pOwoJZm9yIChwID0gcmF3LT5idWY7ICpwOyBwKyspIHsKCQlpZiAoaXNzcGFjZSgqcCkpCgkJCWNvbnRpbnVlOwoJCWlmICgqcCA9PSAnOycpIHsKCQkJcCsrOwoJCQlicmVhazsKCQl9CgkJc3RyYnVmX2FkZGNoKHR5cGUsIHRvbG93ZXIoKnApKTsKCX0KCglpZiAoIWNoYXJzZXQpCgkJcmV0dXJuOwoKCXN0cmJ1Zl9yZXNldChjaGFyc2V0KTsKCXdoaWxlICgqcCkgewoJCXdoaWxlIChpc3NwYWNlKCpwKSB8fCAqcCA9PSAnOycpCgkJCXArKzsKCQlpZiAoIWV4dHJhY3RfcGFyYW0ocCwgImNoYXJzZXQiLCBjaGFyc2V0KSkKCQkJcmV0dXJuOwoJCXdoaWxlICgqcCAmJiAhaXNzcGFjZSgqcCkpCgkJCXArKzsKCX0KCglpZiAoIWNoYXJzZXQtPmxlbiAmJiBzdGFydHNfd2l0aCh0eXBlLT5idWYsICJ0ZXh0LyIpKQoJCXN0cmJ1Zl9hZGRzdHIoY2hhcnNldCwgIklTTy04ODU5LTEiKTsKfQoKc3RhdGljIHZvaWQgd3JpdGVfYWNjZXB0X2xhbmd1YWdlKHN0cnVjdCBzdHJidWYgKmJ1ZikKewoJLyoKCSAqIE1BWF9ERUNJTUFMX1BMQUNFUyBtdXN0IG5vdCBiZSBsYXJnZXIgdGhhbiAzLiBJZiBpdCBpcyBsYXJnZXIgdGhhbgoJICogdGhhdCwgcS12YWx1ZSB3aWxsIGJlIHNtYWxsZXIgdGhhbiAwLjAwMSwgdGhlIG1pbmltdW0gcS12YWx1ZSB0aGUKCSAqIEhUVFAgc3BlY2lmaWNhdGlvbiBhbGxvd3MuIFNlZQoJICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTUuMy4xIGZvciBxLXZhbHVlLgoJICovCgljb25zdCBpbnQgTUFYX0RFQ0lNQUxfUExBQ0VTID0gMzsKCWNvbnN0IGludCBNQVhfTEFOR1VBR0VfVEFHUyA9IDEwMDA7Cgljb25zdCBpbnQgTUFYX0FDQ0VQVF9MQU5HVUFHRV9IRUFERVJfU0laRSA9IDQwMDA7CgljaGFyICoqbGFuZ3VhZ2VfdGFncyA9IE5VTEw7CglpbnQgbnVtX2xhbmdzID0gMDsKCWNvbnN0IGNoYXIgKnMgPSBnZXRfcHJlZmVycmVkX2xhbmd1YWdlcygpOwoJaW50IGk7CglzdHJ1Y3Qgc3RyYnVmIHRhZyA9IFNUUkJVRl9JTklUOwoKCS8qIERvbid0IGFkZCBBY2NlcHQtTGFuZ3VhZ2UgaGVhZGVyIGlmIG5vIGxhbmd1YWdlIGlzIHByZWZlcnJlZC4gKi8KCWlmICghcykKCQlyZXR1cm47CgoJLyoKCSAqIFNwbGl0IHRoZSBjb2xvbi1zZXBhcmF0ZWQgc3RyaW5nIG9mIHByZWZlcnJlZCBsYW5ndWFnZXMgaW50bwoJICogbGFuZ3VhZ2VfdGFncyBhcnJheS4KCSAqLwoJZG8gewoJCS8qIGNvbGxlY3QgbGFuZ3VhZ2UgdGFnICovCgkJZm9yICg7ICpzICYmIChpc2FsbnVtKCpzKSB8fCAqcyA9PSAnXycpOyBzKyspCgkJCXN0cmJ1Zl9hZGRjaCgmdGFnLCAqcyA9PSAnXycgPyAnLScgOiAqcyk7CgoJCS8qIHNraXAgLmNvZGVzZXQsIEBtb2RpZmllciBhbmQgYW55IG90aGVyIHVubmVjZXNzYXJ5IHBhcnRzICovCgkJd2hpbGUgKCpzICYmICpzICE9ICc6JykKCQkJcysrOwoKCQlpZiAodGFnLmxlbikgewoJCQludW1fbGFuZ3MrKzsKCQkJUkVBTExPQ19BUlJBWShsYW5ndWFnZV90YWdzLCBudW1fbGFuZ3MpOwoJCQlsYW5ndWFnZV90YWdzW251bV9sYW5ncyAtIDFdID0gc3RyYnVmX2RldGFjaCgmdGFnLCBOVUxMKTsKCQkJaWYgKG51bV9sYW5ncyA+PSBNQVhfTEFOR1VBR0VfVEFHUyAtIDEpIC8qIC0xIGZvciAnKicgKi8KCQkJCWJyZWFrOwoJCX0KCX0gd2hpbGUgKCpzKyspOwoKCS8qIHdyaXRlIEFjY2VwdC1MYW5ndWFnZSBoZWFkZXIgaW50byBidWYgKi8KCWlmIChudW1fbGFuZ3MpIHsKCQlpbnQgbGFzdF9idWZfbGVuID0gMDsKCQlpbnQgbWF4X3E7CgkJaW50IGRlY2ltYWxfcGxhY2VzOwoJCWNoYXIgcV9mb3JtYXRbMzJdOwoKCQkvKiBhZGQgJyonICovCgkJUkVBTExPQ19BUlJBWShsYW5ndWFnZV90YWdzLCBudW1fbGFuZ3MgKyAxKTsKCQlsYW5ndWFnZV90YWdzW251bV9sYW5ncysrXSA9ICIqIjsgLyogaXQncyBPSzsgdGhpcyB3b24ndCBiZSBmcmVlZCAqLwoKCQkvKiBjb21wdXRlIGRlY2ltYWxfcGxhY2VzICovCgkJZm9yIChtYXhfcSA9IDEsIGRlY2ltYWxfcGxhY2VzID0gMDsKCQkgICAgIG1heF9xIDwgbnVtX2xhbmdzICYmIGRlY2ltYWxfcGxhY2VzIDw9IE1BWF9ERUNJTUFMX1BMQUNFUzsKCQkgICAgIGRlY2ltYWxfcGxhY2VzKyssIG1heF9xICo9IDEwKQoJCQk7CgoJCXNwcmludGYocV9mb3JtYXQsICI7cT0wLiUlMCVkZCIsIGRlY2ltYWxfcGxhY2VzKTsKCgkJc3RyYnVmX2FkZHN0cihidWYsICJBY2NlcHQtTGFuZ3VhZ2U6ICIpOwoKCQlmb3IgKGkgPSAwOyBpIDwgbnVtX2xhbmdzOyBpKyspIHsKCQkJaWYgKGkgPiAwKQoJCQkJc3RyYnVmX2FkZHN0cihidWYsICIsICIpOwoKCQkJc3RyYnVmX2FkZHN0cihidWYsIGxhbmd1YWdlX3RhZ3NbaV0pOwoKCQkJaWYgKGkgPiAwKQoJCQkJc3RyYnVmX2FkZGYoYnVmLCBxX2Zvcm1hdCwgbWF4X3EgLSBpKTsKCgkJCWlmIChidWYtPmxlbiA+IE1BWF9BQ0NFUFRfTEFOR1VBR0VfSEVBREVSX1NJWkUpIHsKCQkJCXN0cmJ1Zl9yZW1vdmUoYnVmLCBsYXN0X2J1Zl9sZW4sIGJ1Zi0+bGVuIC0gbGFzdF9idWZfbGVuKTsKCQkJCWJyZWFrOwoJCQl9CgoJCQlsYXN0X2J1Zl9sZW4gPSBidWYtPmxlbjsKCQl9Cgl9CgoJLyogZnJlZSBsYW5ndWFnZSB0YWdzIC0tIGxhc3Qgb25lIGlzIGEgc3RhdGljICcqJyAqLwoJZm9yIChpID0gMDsgaSA8IG51bV9sYW5ncyAtIDE7IGkrKykKCQlmcmVlKGxhbmd1YWdlX3RhZ3NbaV0pOwoJZnJlZShsYW5ndWFnZV90YWdzKTsKfQoKLyoKICogR2V0IGFuIEFjY2VwdC1MYW5ndWFnZSBoZWFkZXIgd2hpY2ggaW5kaWNhdGVzIHVzZXIncyBwcmVmZXJyZWQgbGFuZ3VhZ2VzLgogKgogKiBFeGFtcGxlczoKICogICBMQU5HVUFHRT0gLT4gIiIKICogICBMQU5HVUFHRT1rbzplbiAtPiAiQWNjZXB0LUxhbmd1YWdlOiBrbywgZW47IHE9MC45LCAqOyBxPTAuMSIKICogICBMQU5HVUFHRT1rb19LUi5VVEYtODpzckBsYXRpbiAtPiAiQWNjZXB0LUxhbmd1YWdlOiBrby1LUiwgc3I7IHE9MC45LCAqOyBxPTAuMSIKICogICBMQU5HVUFHRT1rbyBMQU5HPWVuX1VTLlVURi04IC0+ICJBY2NlcHQtTGFuZ3VhZ2U6IGtvLCAqOyBxPTAuMSIKICogICBMQU5HVUFHRT0gTEFORz1lbl9VUy5VVEYtOCAtPiAiQWNjZXB0LUxhbmd1YWdlOiBlbi1VUywgKjsgcT0wLjEiCiAqICAgTEFOR1VBR0U9IExBTkc9QyAtPiAiIgogKi8Kc3RhdGljIGNvbnN0IGNoYXIgKmdldF9hY2NlcHRfbGFuZ3VhZ2Uodm9pZCkKewoJaWYgKCFjYWNoZWRfYWNjZXB0X2xhbmd1YWdlKSB7CgkJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCQl3cml0ZV9hY2NlcHRfbGFuZ3VhZ2UoJmJ1Zik7CgkJaWYgKGJ1Zi5sZW4gPiAwKQoJCQljYWNoZWRfYWNjZXB0X2xhbmd1YWdlID0gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCX0KCglyZXR1cm4gY2FjaGVkX2FjY2VwdF9sYW5ndWFnZTsKfQoKLyogaHR0cF9yZXF1ZXN0KCkgdGFyZ2V0cyAqLwojZGVmaW5lIEhUVFBfUkVRVUVTVF9TVFJCVUYJMAojZGVmaW5lIEhUVFBfUkVRVUVTVF9GSUxFCTEKCnN0YXRpYyBpbnQgaHR0cF9yZXF1ZXN0KGNvbnN0IGNoYXIgKnVybCwKCQkJdm9pZCAqcmVzdWx0LCBpbnQgdGFyZ2V0LAoJCQljb25zdCBzdHJ1Y3QgaHR0cF9nZXRfb3B0aW9ucyAqb3B0aW9ucykKewoJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3Q7CglzdHJ1Y3Qgc2xvdF9yZXN1bHRzIHJlc3VsdHM7CglzdHJ1Y3QgY3VybF9zbGlzdCAqaGVhZGVycyA9IE5VTEw7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJY29uc3QgY2hhciAqYWNjZXB0X2xhbmd1YWdlOwoJaW50IHJldDsKCglzbG90ID0gZ2V0X2FjdGl2ZV9zbG90KCk7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfSFRUUEdFVCwgMSk7CgoJaWYgKHJlc3VsdCA9PSBOVUxMKSB7CgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX05PQk9EWSwgMSk7Cgl9IGVsc2UgewoJCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9OT0JPRFksIDApOwoJCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9GSUxFLCByZXN1bHQpOwoKCQlpZiAodGFyZ2V0ID09IEhUVFBfUkVRVUVTVF9GSUxFKSB7CgkJCWxvbmcgcG9zbiA9IGZ0ZWxsKHJlc3VsdCk7CgkJCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9XUklURUZVTkNUSU9OLAoJCQkJCSBmd3JpdGUpOwoJCQlpZiAocG9zbiA+IDApIHsKCQkJCXN0cmJ1Zl9hZGRmKCZidWYsICJSYW5nZTogYnl0ZXM9JWxkLSIsIHBvc24pOwoJCQkJaGVhZGVycyA9IGN1cmxfc2xpc3RfYXBwZW5kKGhlYWRlcnMsIGJ1Zi5idWYpOwoJCQkJc3RyYnVmX3Jlc2V0KCZidWYpOwoJCQl9CgkJfSBlbHNlCgkJCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9XUklURUZVTkNUSU9OLAoJCQkJCSBmd3JpdGVfYnVmZmVyKTsKCX0KCglhY2NlcHRfbGFuZ3VhZ2UgPSBnZXRfYWNjZXB0X2xhbmd1YWdlKCk7CgoJaWYgKGFjY2VwdF9sYW5ndWFnZSkKCQloZWFkZXJzID0gY3VybF9zbGlzdF9hcHBlbmQoaGVhZGVycywgYWNjZXB0X2xhbmd1YWdlKTsKCglzdHJidWZfYWRkc3RyKCZidWYsICJQcmFnbWE6Iik7CglpZiAob3B0aW9ucyAmJiBvcHRpb25zLT5ub19jYWNoZSkKCQlzdHJidWZfYWRkc3RyKCZidWYsICIgbm8tY2FjaGUiKTsKCWlmIChvcHRpb25zICYmIG9wdGlvbnMtPmtlZXBfZXJyb3IpCgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0ZBSUxPTkVSUk9SLCAwKTsKCgloZWFkZXJzID0gY3VybF9zbGlzdF9hcHBlbmQoaGVhZGVycywgYnVmLmJ1Zik7CgoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1VSTCwgdXJsKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9IVFRQSEVBREVSLCBoZWFkZXJzKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9FTkNPRElORywgImd6aXAiKTsKCglyZXQgPSBydW5fb25lX3Nsb3Qoc2xvdCwgJnJlc3VsdHMpOwoKCWlmIChvcHRpb25zICYmIG9wdGlvbnMtPmNvbnRlbnRfdHlwZSkgewoJCXN0cnVjdCBzdHJidWYgcmF3ID0gU1RSQlVGX0lOSVQ7CgkJY3VybGluZm9fc3RyYnVmKHNsb3QtPmN1cmwsIENVUkxJTkZPX0NPTlRFTlRfVFlQRSwgJnJhdyk7CgkJZXh0cmFjdF9jb250ZW50X3R5cGUoJnJhdywgb3B0aW9ucy0+Y29udGVudF90eXBlLAoJCQkJICAgICBvcHRpb25zLT5jaGFyc2V0KTsKCQlzdHJidWZfcmVsZWFzZSgmcmF3KTsKCX0KCglpZiAob3B0aW9ucyAmJiBvcHRpb25zLT5lZmZlY3RpdmVfdXJsKQoJCWN1cmxpbmZvX3N0cmJ1ZihzbG90LT5jdXJsLCBDVVJMSU5GT19FRkZFQ1RJVkVfVVJMLAoJCQkJb3B0aW9ucy0+ZWZmZWN0aXZlX3VybCk7CgoJY3VybF9zbGlzdF9mcmVlX2FsbChoZWFkZXJzKTsKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoKCXJldHVybiByZXQ7Cn0KCi8qCiAqIFVwZGF0ZSB0aGUgImJhc2UiIHVybCB0byBhIG1vcmUgYXBwcm9wcmlhdGUgdmFsdWUsIGFzIGRlZHVjZWQgYnkKICogcmVkaXJlY3RzIHNlZW4gd2hlbiByZXF1ZXN0aW5nIGEgVVJMIHN0YXJ0aW5nIHdpdGggInVybCIuCiAqCiAqIFRoZSAiYXNrZWQiIHBhcmFtZXRlciBpcyBhIFVSTCB0aGF0IHdlIGFza2VkIGN1cmwgdG8gYWNjZXNzLCBhbmQgbXVzdCBiZWdpbgogKiB3aXRoICJiYXNlIi4KICoKICogVGhlICJnb3QiIHBhcmFtZXRlciBpcyB0aGUgVVJMIHRoYXQgY3VybCByZXBvcnRlZCB0byB1cyBhcyB3aGVyZSB3ZSBlbmRlZAogKiB1cC4KICoKICogUmV0dXJucyAxIGlmIHdlIHVwZGF0ZWQgdGhlIGJhc2UgdXJsLCAwIG90aGVyd2lzZS4KICoKICogT3VyIGJhc2ljIHN0cmF0ZWd5IGlzIHRvIGNvbXBhcmUgImJhc2UiIGFuZCAiYXNrZWQiIHRvIGZpbmQgdGhlIGJpdHMKICogc3BlY2lmaWMgdG8gb3VyIHJlcXVlc3QuIFdlIHRoZW4gc3RyaXAgdGhvc2UgYml0cyBvZmYgb2YgImdvdCIgdG8geWllbGQgdGhlCiAqIG5ldyBiYXNlLiBTbyBmb3IgZXhhbXBsZSwgaWYgb3VyIGJhc2UgaXMgImh0dHA6Ly9leGFtcGxlLmNvbS9mb28uZ2l0IiwKICogYW5kIHdlIGFzayBmb3IgImh0dHA6Ly9leGFtcGxlLmNvbS9mb28uZ2l0L2luZm8vcmVmcyIsIHdlIG1pZ2h0IGVuZCB1cAogKiB3aXRoICJodHRwczovL290aGVyLmV4YW1wbGUuY29tL2Zvby5naXQvaW5mby9yZWZzIi4gV2Ugd291bGQgd2FudCB0aGUKICogbmV3IFVSTCB0byBiZWNvbWUgImh0dHBzOi8vb3RoZXIuZXhhbXBsZS5jb20vZm9vLmdpdCIuCiAqCiAqIE5vdGUgdGhhdCB0aGlzIGFzc3VtZXMgYSBzYW5lIHJlZGlyZWN0IHNjaGVtZS4gSXQncyBlbnRpcmVseSBwb3NzaWJsZQogKiBpbiB0aGUgZXhhbXBsZSBhYm92ZSB0byBlbmQgdXAgYXQgYSBVUkwgdGhhdCBkb2VzIG5vdCBldmVuIGVuZCBpbgogKiAiaW5mby9yZWZzIi4gIEluIHN1Y2ggYSBjYXNlIHdlIHNpbXBseSBwdW50LCBhcyB0aGVyZSBpcyBub3QgbXVjaCB3ZSBjYW4KICogZG8gKGFuZCBzdWNoIGEgc2NoZW1lIGlzIHVubGlrZWx5IHRvIHJlcHJlc2VudCBhIHJlYWwgZ2l0IHJlcG9zaXRvcnksCiAqIHdoaWNoIG1lYW5zIHdlIGFyZSBsaWtlbHkgYWJvdXQgdG8gYWJvcnQgYW55d2F5KS4KICovCnN0YXRpYyBpbnQgdXBkYXRlX3VybF9mcm9tX3JlZGlyZWN0KHN0cnVjdCBzdHJidWYgKmJhc2UsCgkJCQkgICAgY29uc3QgY2hhciAqYXNrZWQsCgkJCQkgICAgY29uc3Qgc3RydWN0IHN0cmJ1ZiAqZ290KQp7Cgljb25zdCBjaGFyICp0YWlsOwoJc2l6ZV90IHRhaWxfbGVuOwoKCWlmICghc3RyY21wKGFza2VkLCBnb3QtPmJ1ZikpCgkJcmV0dXJuIDA7CgoJaWYgKCFza2lwX3ByZWZpeChhc2tlZCwgYmFzZS0+YnVmLCAmdGFpbCkpCgkJZGllKCJCVUc6IHVwZGF0ZV91cmxfZnJvbV9yZWRpcmVjdDogJXMgaXMgbm90IGEgc3VwZXJzZXQgb2YgJXMiLAoJCSAgICBhc2tlZCwgYmFzZS0+YnVmKTsKCgl0YWlsX2xlbiA9IHN0cmxlbih0YWlsKTsKCglpZiAoZ290LT5sZW4gPCB0YWlsX2xlbiB8fAoJICAgIHN0cmNtcCh0YWlsLCBnb3QtPmJ1ZiArIGdvdC0+bGVuIC0gdGFpbF9sZW4pKQoJCXJldHVybiAwOyAvKiBpbnNhbmUgcmVkaXJlY3Qgc2NoZW1lICovCgoJc3RyYnVmX3Jlc2V0KGJhc2UpOwoJc3RyYnVmX2FkZChiYXNlLCBnb3QtPmJ1ZiwgZ290LT5sZW4gLSB0YWlsX2xlbik7CglyZXR1cm4gMTsKfQoKc3RhdGljIGludCBodHRwX3JlcXVlc3RfcmVhdXRoKGNvbnN0IGNoYXIgKnVybCwKCQkJICAgICAgIHZvaWQgKnJlc3VsdCwgaW50IHRhcmdldCwKCQkJICAgICAgIHN0cnVjdCBodHRwX2dldF9vcHRpb25zICpvcHRpb25zKQp7CglpbnQgcmV0ID0gaHR0cF9yZXF1ZXN0KHVybCwgcmVzdWx0LCB0YXJnZXQsIG9wdGlvbnMpOwoKCWlmIChvcHRpb25zICYmIG9wdGlvbnMtPmVmZmVjdGl2ZV91cmwgJiYgb3B0aW9ucy0+YmFzZV91cmwpIHsKCQlpZiAodXBkYXRlX3VybF9mcm9tX3JlZGlyZWN0KG9wdGlvbnMtPmJhc2VfdXJsLAoJCQkJCSAgICAgdXJsLCBvcHRpb25zLT5lZmZlY3RpdmVfdXJsKSkgewoJCQljcmVkZW50aWFsX2Zyb21fdXJsKCZodHRwX2F1dGgsIG9wdGlvbnMtPmJhc2VfdXJsLT5idWYpOwoJCQl1cmwgPSBvcHRpb25zLT5lZmZlY3RpdmVfdXJsLT5idWY7CgkJfQoJfQoKCWlmIChyZXQgIT0gSFRUUF9SRUFVVEgpCgkJcmV0dXJuIHJldDsKCgkvKgoJICogSWYgd2UgYXJlIHVzaW5nIEtFRVBfRVJST1IsIHRoZSBwcmV2aW91cyByZXF1ZXN0IG1heSBoYXZlCgkgKiBwdXQgY3J1ZnQgaW50byBvdXIgb3V0cHV0IHN0cmVhbTsgd2Ugc2hvdWxkIGNsZWFyIGl0IG91dCBiZWZvcmUKCSAqIG1ha2luZyBvdXIgbmV4dCByZXF1ZXN0LiBXZSBvbmx5IGtub3cgaG93IHRvIGRvIHRoaXMgZm9yCgkgKiB0aGUgc3RyYnVmIGNhc2UsIGJ1dCB0aGF0IGlzIGVub3VnaCB0byBzYXRpc2Z5IGN1cnJlbnQgY2FsbGVycy4KCSAqLwoJaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy0+a2VlcF9lcnJvcikgewoJCXN3aXRjaCAodGFyZ2V0KSB7CgkJY2FzZSBIVFRQX1JFUVVFU1RfU1RSQlVGOgoJCQlzdHJidWZfcmVzZXQocmVzdWx0KTsKCQkJYnJlYWs7CgkJZGVmYXVsdDoKCQkJZGllKCJCVUc6IEhUVFBfS0VFUF9FUlJPUiBpcyBvbmx5IHN1cHBvcnRlZCB3aXRoIHN0cmJ1ZnMiKTsKCQl9Cgl9CgoJY3JlZGVudGlhbF9maWxsKCZodHRwX2F1dGgpOwoKCXJldHVybiBodHRwX3JlcXVlc3QodXJsLCByZXN1bHQsIHRhcmdldCwgb3B0aW9ucyk7Cn0KCmludCBodHRwX2dldF9zdHJidWYoY29uc3QgY2hhciAqdXJsLAoJCSAgICBzdHJ1Y3Qgc3RyYnVmICpyZXN1bHQsCgkJICAgIHN0cnVjdCBodHRwX2dldF9vcHRpb25zICpvcHRpb25zKQp7CglyZXR1cm4gaHR0cF9yZXF1ZXN0X3JlYXV0aCh1cmwsIHJlc3VsdCwgSFRUUF9SRVFVRVNUX1NUUkJVRiwgb3B0aW9ucyk7Cn0KCi8qCiAqIERvd25sb2FkcyBhIFVSTCBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIGdpdmVuIGZpbGUuCiAqCiAqIElmIGEgcHJldmlvdXMgaW50ZXJydXB0ZWQgZG93bmxvYWQgaXMgZGV0ZWN0ZWQgKGkuZS4gYSBwcmV2aW91cyB0ZW1wb3JhcnkKICogZmlsZSBpcyBzdGlsbCBhcm91bmQpIHRoZSBkb3dubG9hZCBpcyByZXN1bWVkLgogKi8Kc3RhdGljIGludCBodHRwX2dldF9maWxlKGNvbnN0IGNoYXIgKnVybCwgY29uc3QgY2hhciAqZmlsZW5hbWUsCgkJCSBzdHJ1Y3QgaHR0cF9nZXRfb3B0aW9ucyAqb3B0aW9ucykKewoJaW50IHJldDsKCXN0cnVjdCBzdHJidWYgdG1wZmlsZSA9IFNUUkJVRl9JTklUOwoJRklMRSAqcmVzdWx0OwoKCXN0cmJ1Zl9hZGRmKCZ0bXBmaWxlLCAiJXMudGVtcCIsIGZpbGVuYW1lKTsKCXJlc3VsdCA9IGZvcGVuKHRtcGZpbGUuYnVmLCAiYSIpOwoJaWYgKCFyZXN1bHQpIHsKCQllcnJvcigiVW5hYmxlIHRvIG9wZW4gbG9jYWwgZmlsZSAlcyIsIHRtcGZpbGUuYnVmKTsKCQlyZXQgPSBIVFRQX0VSUk9SOwoJCWdvdG8gY2xlYW51cDsKCX0KCglyZXQgPSBodHRwX3JlcXVlc3RfcmVhdXRoKHVybCwgcmVzdWx0LCBIVFRQX1JFUVVFU1RfRklMRSwgb3B0aW9ucyk7CglmY2xvc2UocmVzdWx0KTsKCglpZiAocmV0ID09IEhUVFBfT0sgJiYgbW92ZV90ZW1wX3RvX2ZpbGUodG1wZmlsZS5idWYsIGZpbGVuYW1lKSkKCQlyZXQgPSBIVFRQX0VSUk9SOwpjbGVhbnVwOgoJc3RyYnVmX3JlbGVhc2UoJnRtcGZpbGUpOwoJcmV0dXJuIHJldDsKfQoKaW50IGh0dHBfZmV0Y2hfcmVmKGNvbnN0IGNoYXIgKmJhc2UsIHN0cnVjdCByZWYgKnJlZikKewoJc3RydWN0IGh0dHBfZ2V0X29wdGlvbnMgb3B0aW9ucyA9IHswfTsKCWNoYXIgKnVybDsKCXN0cnVjdCBzdHJidWYgYnVmZmVyID0gU1RSQlVGX0lOSVQ7CglpbnQgcmV0ID0gLTE7CgoJb3B0aW9ucy5ub19jYWNoZSA9IDE7CgoJdXJsID0gcXVvdGVfcmVmX3VybChiYXNlLCByZWYtPm5hbWUpOwoJaWYgKGh0dHBfZ2V0X3N0cmJ1Zih1cmwsICZidWZmZXIsICZvcHRpb25zKSA9PSBIVFRQX09LKSB7CgkJc3RyYnVmX3J0cmltKCZidWZmZXIpOwoJCWlmIChidWZmZXIubGVuID09IDQwKQoJCQlyZXQgPSBnZXRfc2hhMV9oZXgoYnVmZmVyLmJ1ZiwgcmVmLT5vbGRfc2hhMSk7CgkJZWxzZSBpZiAoc3RhcnRzX3dpdGgoYnVmZmVyLmJ1ZiwgInJlZjogIikpIHsKCQkJcmVmLT5zeW1yZWYgPSB4c3RyZHVwKGJ1ZmZlci5idWYgKyA1KTsKCQkJcmV0ID0gMDsKCQl9Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJmJ1ZmZlcik7CglmcmVlKHVybCk7CglyZXR1cm4gcmV0Owp9CgovKiBIZWxwZXJzIGZvciBmZXRjaGluZyBwYWNrcyAqLwpzdGF0aWMgY2hhciAqZmV0Y2hfcGFja19pbmRleCh1bnNpZ25lZCBjaGFyICpzaGExLCBjb25zdCBjaGFyICpiYXNlX3VybCkKewoJY2hhciAqdXJsLCAqdG1wOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCglpZiAoaHR0cF9pc192ZXJib3NlKQoJCWZwcmludGYoc3RkZXJyLCAiR2V0dGluZyBpbmRleCBmb3IgcGFjayAlc1xuIiwgc2hhMV90b19oZXgoc2hhMSkpOwoKCWVuZF91cmxfd2l0aF9zbGFzaCgmYnVmLCBiYXNlX3VybCk7CglzdHJidWZfYWRkZigmYnVmLCAib2JqZWN0cy9wYWNrL3BhY2stJXMuaWR4Iiwgc2hhMV90b19oZXgoc2hhMSkpOwoJdXJsID0gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCglzdHJidWZfYWRkZigmYnVmLCAiJXMudGVtcCIsIHNoYTFfcGFja19pbmRleF9uYW1lKHNoYTEpKTsKCXRtcCA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7CgoJaWYgKGh0dHBfZ2V0X2ZpbGUodXJsLCB0bXAsIE5VTEwpICE9IEhUVFBfT0spIHsKCQllcnJvcigiVW5hYmxlIHRvIGdldCBwYWNrIGluZGV4ICVzIiwgdXJsKTsKCQlmcmVlKHRtcCk7CgkJdG1wID0gTlVMTDsKCX0KCglmcmVlKHVybCk7CglyZXR1cm4gdG1wOwp9CgpzdGF0aWMgaW50IGZldGNoX2FuZF9zZXR1cF9wYWNrX2luZGV4KHN0cnVjdCBwYWNrZWRfZ2l0ICoqcGFja3NfaGVhZCwKCXVuc2lnbmVkIGNoYXIgKnNoYTEsIGNvbnN0IGNoYXIgKmJhc2VfdXJsKQp7CglzdHJ1Y3QgcGFja2VkX2dpdCAqbmV3X3BhY2s7CgljaGFyICp0bXBfaWR4ID0gTlVMTDsKCWludCByZXQ7CgoJaWYgKGhhc19wYWNrX2luZGV4KHNoYTEpKSB7CgkJbmV3X3BhY2sgPSBwYXJzZV9wYWNrX2luZGV4KHNoYTEsIE5VTEwpOwoJCWlmICghbmV3X3BhY2spCgkJCXJldHVybiAtMTsgLyogcGFyc2VfcGFja19pbmRleCgpIGFscmVhZHkgaXNzdWVkIGVycm9yIG1lc3NhZ2UgKi8KCQlnb3RvIGFkZF9wYWNrOwoJfQoKCXRtcF9pZHggPSBmZXRjaF9wYWNrX2luZGV4KHNoYTEsIGJhc2VfdXJsKTsKCWlmICghdG1wX2lkeCkKCQlyZXR1cm4gLTE7CgoJbmV3X3BhY2sgPSBwYXJzZV9wYWNrX2luZGV4KHNoYTEsIHRtcF9pZHgpOwoJaWYgKCFuZXdfcGFjaykgewoJCXVubGluayh0bXBfaWR4KTsKCQlmcmVlKHRtcF9pZHgpOwoKCQlyZXR1cm4gLTE7IC8qIHBhcnNlX3BhY2tfaW5kZXgoKSBhbHJlYWR5IGlzc3VlZCBlcnJvciBtZXNzYWdlICovCgl9CgoJcmV0ID0gdmVyaWZ5X3BhY2tfaW5kZXgobmV3X3BhY2spOwoJaWYgKCFyZXQpIHsKCQljbG9zZV9wYWNrX2luZGV4KG5ld19wYWNrKTsKCQlyZXQgPSBtb3ZlX3RlbXBfdG9fZmlsZSh0bXBfaWR4LCBzaGExX3BhY2tfaW5kZXhfbmFtZShzaGExKSk7Cgl9CglmcmVlKHRtcF9pZHgpOwoJaWYgKHJldCkKCQlyZXR1cm4gLTE7CgphZGRfcGFjazoKCW5ld19wYWNrLT5uZXh0ID0gKnBhY2tzX2hlYWQ7CgkqcGFja3NfaGVhZCA9IG5ld19wYWNrOwoJcmV0dXJuIDA7Cn0KCmludCBodHRwX2dldF9pbmZvX3BhY2tzKGNvbnN0IGNoYXIgKmJhc2VfdXJsLCBzdHJ1Y3QgcGFja2VkX2dpdCAqKnBhY2tzX2hlYWQpCnsKCXN0cnVjdCBodHRwX2dldF9vcHRpb25zIG9wdGlvbnMgPSB7MH07CglpbnQgcmV0ID0gMCwgaSA9IDA7CgljaGFyICp1cmwsICpkYXRhOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgoJZW5kX3VybF93aXRoX3NsYXNoKCZidWYsIGJhc2VfdXJsKTsKCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgIm9iamVjdHMvaW5mby9wYWNrcyIpOwoJdXJsID0gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCglvcHRpb25zLm5vX2NhY2hlID0gMTsKCXJldCA9IGh0dHBfZ2V0X3N0cmJ1Zih1cmwsICZidWYsICZvcHRpb25zKTsKCWlmIChyZXQgIT0gSFRUUF9PSykKCQlnb3RvIGNsZWFudXA7CgoJZGF0YSA9IGJ1Zi5idWY7Cgl3aGlsZSAoaSA8IGJ1Zi5sZW4pIHsKCQlzd2l0Y2ggKGRhdGFbaV0pIHsKCQljYXNlICdQJzoKCQkJaSsrOwoJCQlpZiAoaSArIDUyIDw9IGJ1Zi5sZW4gJiYKCQkJICAgIHN0YXJ0c193aXRoKGRhdGEgKyBpLCAiIHBhY2stIikgJiYKCQkJICAgIHN0YXJ0c193aXRoKGRhdGEgKyBpICsgNDYsICIucGFja1xuIikpIHsKCQkJCWdldF9zaGExX2hleChkYXRhICsgaSArIDYsIHNoYTEpOwoJCQkJZmV0Y2hfYW5kX3NldHVwX3BhY2tfaW5kZXgocGFja3NfaGVhZCwgc2hhMSwKCQkJCQkJICAgICAgYmFzZV91cmwpOwoJCQkJaSArPSA1MTsKCQkJCWJyZWFrOwoJCQl9CgkJZGVmYXVsdDoKCQkJd2hpbGUgKGkgPCBidWYubGVuICYmIGRhdGFbaV0gIT0gJ1xuJykKCQkJCWkrKzsKCQl9CgkJaSsrOwoJfQoKY2xlYW51cDoKCWZyZWUodXJsKTsKCXJldHVybiByZXQ7Cn0KCnZvaWQgcmVsZWFzZV9odHRwX3BhY2tfcmVxdWVzdChzdHJ1Y3QgaHR0cF9wYWNrX3JlcXVlc3QgKnByZXEpCnsKCWlmIChwcmVxLT5wYWNrZmlsZSAhPSBOVUxMKSB7CgkJZmNsb3NlKHByZXEtPnBhY2tmaWxlKTsKCQlwcmVxLT5wYWNrZmlsZSA9IE5VTEw7Cgl9CglpZiAocHJlcS0+cmFuZ2VfaGVhZGVyICE9IE5VTEwpIHsKCQljdXJsX3NsaXN0X2ZyZWVfYWxsKHByZXEtPnJhbmdlX2hlYWRlcik7CgkJcHJlcS0+cmFuZ2VfaGVhZGVyID0gTlVMTDsKCX0KCXByZXEtPnNsb3QgPSBOVUxMOwoJZnJlZShwcmVxLT51cmwpOwp9CgppbnQgZmluaXNoX2h0dHBfcGFja19yZXF1ZXN0KHN0cnVjdCBodHRwX3BhY2tfcmVxdWVzdCAqcHJlcSkKewoJc3RydWN0IHBhY2tlZF9naXQgKipsc3Q7CglzdHJ1Y3QgcGFja2VkX2dpdCAqcCA9IHByZXEtPnRhcmdldDsKCWNoYXIgKnRtcF9pZHg7CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBpcCA9IENISUxEX1BST0NFU1NfSU5JVDsKCWNvbnN0IGNoYXIgKmlwX2FyZ3ZbOF07CgoJY2xvc2VfcGFja19pbmRleChwKTsKCglmY2xvc2UocHJlcS0+cGFja2ZpbGUpOwoJcHJlcS0+cGFja2ZpbGUgPSBOVUxMOwoKCWxzdCA9IHByZXEtPmxzdDsKCXdoaWxlICgqbHN0ICE9IHApCgkJbHN0ID0gJigoKmxzdCktPm5leHQpOwoJKmxzdCA9ICgqbHN0KS0+bmV4dDsKCgl0bXBfaWR4ID0geHN0cmR1cChwcmVxLT50bXBmaWxlKTsKCXN0cmNweSh0bXBfaWR4ICsgc3RybGVuKHRtcF9pZHgpIC0gc3RybGVuKCIucGFjay50ZW1wIiksCgkgICAgICAgIi5pZHgudGVtcCIpOwoKCWlwX2FyZ3ZbMF0gPSAiaW5kZXgtcGFjayI7CglpcF9hcmd2WzFdID0gIi1vIjsKCWlwX2FyZ3ZbMl0gPSB0bXBfaWR4OwoJaXBfYXJndlszXSA9IHByZXEtPnRtcGZpbGU7CglpcF9hcmd2WzRdID0gTlVMTDsKCglpcC5hcmd2ID0gaXBfYXJndjsKCWlwLmdpdF9jbWQgPSAxOwoJaXAubm9fc3RkaW4gPSAxOwoJaXAubm9fc3Rkb3V0ID0gMTsKCglpZiAocnVuX2NvbW1hbmQoJmlwKSkgewoJCXVubGluayhwcmVxLT50bXBmaWxlKTsKCQl1bmxpbmsodG1wX2lkeCk7CgkJZnJlZSh0bXBfaWR4KTsKCQlyZXR1cm4gLTE7Cgl9CgoJdW5saW5rKHNoYTFfcGFja19pbmRleF9uYW1lKHAtPnNoYTEpKTsKCglpZiAobW92ZV90ZW1wX3RvX2ZpbGUocHJlcS0+dG1wZmlsZSwgc2hhMV9wYWNrX25hbWUocC0+c2hhMSkpCgkgfHwgbW92ZV90ZW1wX3RvX2ZpbGUodG1wX2lkeCwgc2hhMV9wYWNrX2luZGV4X25hbWUocC0+c2hhMSkpKSB7CgkJZnJlZSh0bXBfaWR4KTsKCQlyZXR1cm4gLTE7Cgl9CgoJaW5zdGFsbF9wYWNrZWRfZ2l0KHApOwoJZnJlZSh0bXBfaWR4KTsKCXJldHVybiAwOwp9CgpzdHJ1Y3QgaHR0cF9wYWNrX3JlcXVlc3QgKm5ld19odHRwX3BhY2tfcmVxdWVzdCgKCXN0cnVjdCBwYWNrZWRfZ2l0ICp0YXJnZXQsIGNvbnN0IGNoYXIgKmJhc2VfdXJsKQp7Cglsb25nIHByZXZfcG9zbiA9IDA7CgljaGFyIHJhbmdlW1JBTkdFX0hFQURFUl9TSVpFXTsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3QgaHR0cF9wYWNrX3JlcXVlc3QgKnByZXE7CgoJcHJlcSA9IHhjYWxsb2MoMSwgc2l6ZW9mKCpwcmVxKSk7CglwcmVxLT50YXJnZXQgPSB0YXJnZXQ7CgoJZW5kX3VybF93aXRoX3NsYXNoKCZidWYsIGJhc2VfdXJsKTsKCXN0cmJ1Zl9hZGRmKCZidWYsICJvYmplY3RzL3BhY2svcGFjay0lcy5wYWNrIiwKCQlzaGExX3RvX2hleCh0YXJnZXQtPnNoYTEpKTsKCXByZXEtPnVybCA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7CgoJc25wcmludGYocHJlcS0+dG1wZmlsZSwgc2l6ZW9mKHByZXEtPnRtcGZpbGUpLCAiJXMudGVtcCIsCgkJc2hhMV9wYWNrX25hbWUodGFyZ2V0LT5zaGExKSk7CglwcmVxLT5wYWNrZmlsZSA9IGZvcGVuKHByZXEtPnRtcGZpbGUsICJhIik7CglpZiAoIXByZXEtPnBhY2tmaWxlKSB7CgkJZXJyb3IoIlVuYWJsZSB0byBvcGVuIGxvY2FsIGZpbGUgJXMgZm9yIHBhY2siLAoJCSAgICAgIHByZXEtPnRtcGZpbGUpOwoJCWdvdG8gYWJvcnQ7Cgl9CgoJcHJlcS0+c2xvdCA9IGdldF9hY3RpdmVfc2xvdCgpOwoJY3VybF9lYXN5X3NldG9wdChwcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX0ZJTEUsIHByZXEtPnBhY2tmaWxlKTsKCWN1cmxfZWFzeV9zZXRvcHQocHJlcS0+c2xvdC0+Y3VybCwgQ1VSTE9QVF9XUklURUZVTkNUSU9OLCBmd3JpdGUpOwoJY3VybF9lYXN5X3NldG9wdChwcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX1VSTCwgcHJlcS0+dXJsKTsKCWN1cmxfZWFzeV9zZXRvcHQocHJlcS0+c2xvdC0+Y3VybCwgQ1VSTE9QVF9IVFRQSEVBREVSLAoJCW5vX3ByYWdtYV9oZWFkZXIpOwoKCS8qCgkgKiBJZiB0aGVyZSBpcyBkYXRhIHByZXNlbnQgZnJvbSBhIHByZXZpb3VzIHRyYW5zZmVyIGF0dGVtcHQsCgkgKiByZXN1bWUgd2hlcmUgaXQgbGVmdCBvZmYKCSAqLwoJcHJldl9wb3NuID0gZnRlbGwocHJlcS0+cGFja2ZpbGUpOwoJaWYgKHByZXZfcG9zbj4wKSB7CgkJaWYgKGh0dHBfaXNfdmVyYm9zZSkKCQkJZnByaW50ZihzdGRlcnIsCgkJCQkiUmVzdW1pbmcgZmV0Y2ggb2YgcGFjayAlcyBhdCBieXRlICVsZFxuIiwKCQkJCXNoYTFfdG9faGV4KHRhcmdldC0+c2hhMSksIHByZXZfcG9zbik7CgkJc3ByaW50ZihyYW5nZSwgIlJhbmdlOiBieXRlcz0lbGQtIiwgcHJldl9wb3NuKTsKCQlwcmVxLT5yYW5nZV9oZWFkZXIgPSBjdXJsX3NsaXN0X2FwcGVuZChOVUxMLCByYW5nZSk7CgkJY3VybF9lYXN5X3NldG9wdChwcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX0hUVFBIRUFERVIsCgkJCXByZXEtPnJhbmdlX2hlYWRlcik7Cgl9CgoJcmV0dXJuIHByZXE7CgphYm9ydDoKCWZyZWUocHJlcS0+dXJsKTsKCWZyZWUocHJlcSk7CglyZXR1cm4gTlVMTDsKfQoKLyogSGVscGVycyBmb3IgZmV0Y2hpbmcgb2JqZWN0cyAobG9vc2UpICovCnN0YXRpYyBzaXplX3QgZndyaXRlX3NoYTFfZmlsZShjaGFyICpwdHIsIHNpemVfdCBlbHRzaXplLCBzaXplX3Qgbm1lbWIsCgkJCSAgICAgICB2b2lkICpkYXRhKQp7Cgl1bnNpZ25lZCBjaGFyIGV4cG5bNDA5Nl07CglzaXplX3Qgc2l6ZSA9IGVsdHNpemUgKiBubWVtYjsKCWludCBwb3NuID0gMDsKCXN0cnVjdCBodHRwX29iamVjdF9yZXF1ZXN0ICpmcmVxID0KCQkoc3RydWN0IGh0dHBfb2JqZWN0X3JlcXVlc3QgKilkYXRhOwoJZG8gewoJCXNzaXplX3QgcmV0dmFsID0geHdyaXRlKGZyZXEtPmxvY2FsZmlsZSwKCQkJCQkoY2hhciAqKSBwdHIgKyBwb3NuLCBzaXplIC0gcG9zbik7CgkJaWYgKHJldHZhbCA8IDApCgkJCXJldHVybiBwb3NuOwoJCXBvc24gKz0gcmV0dmFsOwoJfSB3aGlsZSAocG9zbiA8IHNpemUpOwoKCWZyZXEtPnN0cmVhbS5hdmFpbF9pbiA9IHNpemU7CglmcmVxLT5zdHJlYW0ubmV4dF9pbiA9ICh2b2lkICopcHRyOwoJZG8gewoJCWZyZXEtPnN0cmVhbS5uZXh0X291dCA9IGV4cG47CgkJZnJlcS0+c3RyZWFtLmF2YWlsX291dCA9IHNpemVvZihleHBuKTsKCQlmcmVxLT56cmV0ID0gZ2l0X2luZmxhdGUoJmZyZXEtPnN0cmVhbSwgWl9TWU5DX0ZMVVNIKTsKCQlnaXRfU0hBMV9VcGRhdGUoJmZyZXEtPmMsIGV4cG4sCgkJCQlzaXplb2YoZXhwbikgLSBmcmVxLT5zdHJlYW0uYXZhaWxfb3V0KTsKCX0gd2hpbGUgKGZyZXEtPnN0cmVhbS5hdmFpbF9pbiAmJiBmcmVxLT56cmV0ID09IFpfT0spOwoJcmV0dXJuIHNpemU7Cn0KCnN0cnVjdCBodHRwX29iamVjdF9yZXF1ZXN0ICpuZXdfaHR0cF9vYmplY3RfcmVxdWVzdChjb25zdCBjaGFyICpiYXNlX3VybCwKCXVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCWNoYXIgKmhleCA9IHNoYTFfdG9faGV4KHNoYTEpOwoJY29uc3QgY2hhciAqZmlsZW5hbWU7CgljaGFyIHByZXZmaWxlW1BBVEhfTUFYXTsKCWludCBwcmV2bG9jYWw7CgljaGFyIHByZXZfYnVmW1BSRVZfQlVGX1NJWkVdOwoJc3NpemVfdCBwcmV2X3JlYWQgPSAwOwoJbG9uZyBwcmV2X3Bvc24gPSAwOwoJY2hhciByYW5nZVtSQU5HRV9IRUFERVJfU0laRV07CglzdHJ1Y3QgY3VybF9zbGlzdCAqcmFuZ2VfaGVhZGVyID0gTlVMTDsKCXN0cnVjdCBodHRwX29iamVjdF9yZXF1ZXN0ICpmcmVxOwoKCWZyZXEgPSB4Y2FsbG9jKDEsIHNpemVvZigqZnJlcSkpOwoJaGFzaGNweShmcmVxLT5zaGExLCBzaGExKTsKCWZyZXEtPmxvY2FsZmlsZSA9IC0xOwoKCWZpbGVuYW1lID0gc2hhMV9maWxlX25hbWUoc2hhMSk7CglzbnByaW50ZihmcmVxLT50bXBmaWxlLCBzaXplb2YoZnJlcS0+dG1wZmlsZSksCgkJICIlcy50ZW1wIiwgZmlsZW5hbWUpOwoKCXNucHJpbnRmKHByZXZmaWxlLCBzaXplb2YocHJldmZpbGUpLCAiJXMucHJldiIsIGZpbGVuYW1lKTsKCXVubGlua19vcl93YXJuKHByZXZmaWxlKTsKCXJlbmFtZShmcmVxLT50bXBmaWxlLCBwcmV2ZmlsZSk7Cgl1bmxpbmtfb3Jfd2FybihmcmVxLT50bXBmaWxlKTsKCglpZiAoZnJlcS0+bG9jYWxmaWxlICE9IC0xKQoJCWVycm9yKCJmZCBsZWFrYWdlIGluIHN0YXJ0OiAlZCIsIGZyZXEtPmxvY2FsZmlsZSk7CglmcmVxLT5sb2NhbGZpbGUgPSBvcGVuKGZyZXEtPnRtcGZpbGUsCgkJCSAgICAgICBPX1dST05MWSB8IE9fQ1JFQVQgfCBPX0VYQ0wsIDA2NjYpOwoJLyoKCSAqIFRoaXMgY291bGQgaGF2ZSBmYWlsZWQgZHVlIHRvIHRoZSAibGF6eSBkaXJlY3RvcnkgY3JlYXRpb24iOwoJICogdHJ5IHRvIG1rZGlyIHRoZSBsYXN0IHBhdGggY29tcG9uZW50LgoJICovCglpZiAoZnJlcS0+bG9jYWxmaWxlIDwgMCAmJiBlcnJubyA9PSBFTk9FTlQpIHsKCQljaGFyICpkaXIgPSBzdHJyY2hyKGZyZXEtPnRtcGZpbGUsICcvJyk7CgkJaWYgKGRpcikgewoJCQkqZGlyID0gMDsKCQkJbWtkaXIoZnJlcS0+dG1wZmlsZSwgMDc3Nyk7CgkJCSpkaXIgPSAnLyc7CgkJfQoJCWZyZXEtPmxvY2FsZmlsZSA9IG9wZW4oZnJlcS0+dG1wZmlsZSwKCQkJCSAgICAgICBPX1dST05MWSB8IE9fQ1JFQVQgfCBPX0VYQ0wsIDA2NjYpOwoJfQoKCWlmIChmcmVxLT5sb2NhbGZpbGUgPCAwKSB7CgkJZXJyb3IoIkNvdWxkbid0IGNyZWF0ZSB0ZW1wb3JhcnkgZmlsZSAlczogJXMiLAoJCSAgICAgIGZyZXEtPnRtcGZpbGUsIHN0cmVycm9yKGVycm5vKSk7CgkJZ290byBhYm9ydDsKCX0KCglnaXRfaW5mbGF0ZV9pbml0KCZmcmVxLT5zdHJlYW0pOwoKCWdpdF9TSEExX0luaXQoJmZyZXEtPmMpOwoKCWZyZXEtPnVybCA9IGdldF9yZW1vdGVfb2JqZWN0X3VybChiYXNlX3VybCwgaGV4LCAwKTsKCgkvKgoJICogSWYgYSBwcmV2aW91cyB0ZW1wIGZpbGUgaXMgcHJlc2VudCwgcHJvY2VzcyB3aGF0IHdhcyBhbHJlYWR5CgkgKiBmZXRjaGVkLgoJICovCglwcmV2bG9jYWwgPSBvcGVuKHByZXZmaWxlLCBPX1JET05MWSk7CglpZiAocHJldmxvY2FsICE9IC0xKSB7CgkJZG8gewoJCQlwcmV2X3JlYWQgPSB4cmVhZChwcmV2bG9jYWwsIHByZXZfYnVmLCBQUkVWX0JVRl9TSVpFKTsKCQkJaWYgKHByZXZfcmVhZD4wKSB7CgkJCQlpZiAoZndyaXRlX3NoYTFfZmlsZShwcmV2X2J1ZiwKCQkJCQkJICAgICAxLAoJCQkJCQkgICAgIHByZXZfcmVhZCwKCQkJCQkJICAgICBmcmVxKSA9PSBwcmV2X3JlYWQpIHsKCQkJCQlwcmV2X3Bvc24gKz0gcHJldl9yZWFkOwoJCQkJfSBlbHNlIHsKCQkJCQlwcmV2X3JlYWQgPSAtMTsKCQkJCX0KCQkJfQoJCX0gd2hpbGUgKHByZXZfcmVhZCA+IDApOwoJCWNsb3NlKHByZXZsb2NhbCk7Cgl9Cgl1bmxpbmtfb3Jfd2FybihwcmV2ZmlsZSk7CgoJLyoKCSAqIFJlc2V0IGluZmxhdGUvU0hBMSBpZiB0aGVyZSB3YXMgYW4gZXJyb3IgcmVhZGluZyB0aGUgcHJldmlvdXMgdGVtcAoJICogZmlsZTsgYWxzbyByZXdpbmQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbG9jYWwgZmlsZS4KCSAqLwoJaWYgKHByZXZfcmVhZCA9PSAtMSkgewoJCW1lbXNldCgmZnJlcS0+c3RyZWFtLCAwLCBzaXplb2YoZnJlcS0+c3RyZWFtKSk7CgkJZ2l0X2luZmxhdGVfaW5pdCgmZnJlcS0+c3RyZWFtKTsKCQlnaXRfU0hBMV9Jbml0KCZmcmVxLT5jKTsKCQlpZiAocHJldl9wb3NuPjApIHsKCQkJcHJldl9wb3NuID0gMDsKCQkJbHNlZWsoZnJlcS0+bG9jYWxmaWxlLCAwLCBTRUVLX1NFVCk7CgkJCWlmIChmdHJ1bmNhdGUoZnJlcS0+bG9jYWxmaWxlLCAwKSA8IDApIHsKCQkJCWVycm9yKCJDb3VsZG4ndCB0cnVuY2F0ZSB0ZW1wb3JhcnkgZmlsZSAlczogJXMiLAoJCQkJCSAgZnJlcS0+dG1wZmlsZSwgc3RyZXJyb3IoZXJybm8pKTsKCQkJCWdvdG8gYWJvcnQ7CgkJCX0KCQl9Cgl9CgoJZnJlcS0+c2xvdCA9IGdldF9hY3RpdmVfc2xvdCgpOwoKCWN1cmxfZWFzeV9zZXRvcHQoZnJlcS0+c2xvdC0+Y3VybCwgQ1VSTE9QVF9GSUxFLCBmcmVxKTsKCWN1cmxfZWFzeV9zZXRvcHQoZnJlcS0+c2xvdC0+Y3VybCwgQ1VSTE9QVF9XUklURUZVTkNUSU9OLCBmd3JpdGVfc2hhMV9maWxlKTsKCWN1cmxfZWFzeV9zZXRvcHQoZnJlcS0+c2xvdC0+Y3VybCwgQ1VSTE9QVF9FUlJPUkJVRkZFUiwgZnJlcS0+ZXJyb3JzdHIpOwoJY3VybF9lYXN5X3NldG9wdChmcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX1VSTCwgZnJlcS0+dXJsKTsKCWN1cmxfZWFzeV9zZXRvcHQoZnJlcS0+c2xvdC0+Y3VybCwgQ1VSTE9QVF9IVFRQSEVBREVSLCBub19wcmFnbWFfaGVhZGVyKTsKCgkvKgoJICogSWYgd2UgaGF2ZSBzdWNjZXNzZnVsbHkgcHJvY2Vzc2VkIGRhdGEgZnJvbSBhIHByZXZpb3VzIGZldGNoCgkgKiBhdHRlbXB0LCBvbmx5IGZldGNoIHRoZSBkYXRhIHdlIGRvbid0IGFscmVhZHkgaGF2ZS4KCSAqLwoJaWYgKHByZXZfcG9zbj4wKSB7CgkJaWYgKGh0dHBfaXNfdmVyYm9zZSkKCQkJZnByaW50ZihzdGRlcnIsCgkJCQkiUmVzdW1pbmcgZmV0Y2ggb2Ygb2JqZWN0ICVzIGF0IGJ5dGUgJWxkXG4iLAoJCQkJaGV4LCBwcmV2X3Bvc24pOwoJCXNwcmludGYocmFuZ2UsICJSYW5nZTogYnl0ZXM9JWxkLSIsIHByZXZfcG9zbik7CgkJcmFuZ2VfaGVhZGVyID0gY3VybF9zbGlzdF9hcHBlbmQocmFuZ2VfaGVhZGVyLCByYW5nZSk7CgkJY3VybF9lYXN5X3NldG9wdChmcmVxLT5zbG90LT5jdXJsLAoJCQkJIENVUkxPUFRfSFRUUEhFQURFUiwgcmFuZ2VfaGVhZGVyKTsKCX0KCglyZXR1cm4gZnJlcTsKCmFib3J0OgoJZnJlZShmcmVxLT51cmwpOwoJZnJlZShmcmVxKTsKCXJldHVybiBOVUxMOwp9Cgp2b2lkIHByb2Nlc3NfaHR0cF9vYmplY3RfcmVxdWVzdChzdHJ1Y3QgaHR0cF9vYmplY3RfcmVxdWVzdCAqZnJlcSkKewoJaWYgKGZyZXEtPnNsb3QgPT0gTlVMTCkKCQlyZXR1cm47CglmcmVxLT5jdXJsX3Jlc3VsdCA9IGZyZXEtPnNsb3QtPmN1cmxfcmVzdWx0OwoJZnJlcS0+aHR0cF9jb2RlID0gZnJlcS0+c2xvdC0+aHR0cF9jb2RlOwoJZnJlcS0+c2xvdCA9IE5VTEw7Cn0KCmludCBmaW5pc2hfaHR0cF9vYmplY3RfcmVxdWVzdChzdHJ1Y3QgaHR0cF9vYmplY3RfcmVxdWVzdCAqZnJlcSkKewoJc3RydWN0IHN0YXQgc3Q7CgoJY2xvc2UoZnJlcS0+bG9jYWxmaWxlKTsKCWZyZXEtPmxvY2FsZmlsZSA9IC0xOwoKCXByb2Nlc3NfaHR0cF9vYmplY3RfcmVxdWVzdChmcmVxKTsKCglpZiAoZnJlcS0+aHR0cF9jb2RlID09IDQxNikgewoJCXdhcm5pbmcoInJlcXVlc3RlZCByYW5nZSBpbnZhbGlkOyB3ZSBtYXkgYWxyZWFkeSBoYXZlIGFsbCB0aGUgZGF0YS4iKTsKCX0gZWxzZSBpZiAoZnJlcS0+Y3VybF9yZXN1bHQgIT0gQ1VSTEVfT0spIHsKCQlpZiAoc3RhdChmcmVxLT50bXBmaWxlLCAmc3QpID09IDApCgkJCWlmIChzdC5zdF9zaXplID09IDApCgkJCQl1bmxpbmtfb3Jfd2FybihmcmVxLT50bXBmaWxlKTsKCQlyZXR1cm4gLTE7Cgl9CgoJZ2l0X2luZmxhdGVfZW5kKCZmcmVxLT5zdHJlYW0pOwoJZ2l0X1NIQTFfRmluYWwoZnJlcS0+cmVhbF9zaGExLCAmZnJlcS0+Yyk7CglpZiAoZnJlcS0+enJldCAhPSBaX1NUUkVBTV9FTkQpIHsKCQl1bmxpbmtfb3Jfd2FybihmcmVxLT50bXBmaWxlKTsKCQlyZXR1cm4gLTE7Cgl9CglpZiAoaGFzaGNtcChmcmVxLT5zaGExLCBmcmVxLT5yZWFsX3NoYTEpKSB7CgkJdW5saW5rX29yX3dhcm4oZnJlcS0+dG1wZmlsZSk7CgkJcmV0dXJuIC0xOwoJfQoJZnJlcS0+cmVuYW1lID0KCQltb3ZlX3RlbXBfdG9fZmlsZShmcmVxLT50bXBmaWxlLCBzaGExX2ZpbGVfbmFtZShmcmVxLT5zaGExKSk7CgoJcmV0dXJuIGZyZXEtPnJlbmFtZTsKfQoKdm9pZCBhYm9ydF9odHRwX29iamVjdF9yZXF1ZXN0KHN0cnVjdCBodHRwX29iamVjdF9yZXF1ZXN0ICpmcmVxKQp7Cgl1bmxpbmtfb3Jfd2FybihmcmVxLT50bXBmaWxlKTsKCglyZWxlYXNlX2h0dHBfb2JqZWN0X3JlcXVlc3QoZnJlcSk7Cn0KCnZvaWQgcmVsZWFzZV9odHRwX29iamVjdF9yZXF1ZXN0KHN0cnVjdCBodHRwX29iamVjdF9yZXF1ZXN0ICpmcmVxKQp7CglpZiAoZnJlcS0+bG9jYWxmaWxlICE9IC0xKSB7CgkJY2xvc2UoZnJlcS0+bG9jYWxmaWxlKTsKCQlmcmVxLT5sb2NhbGZpbGUgPSAtMTsKCX0KCWlmIChmcmVxLT51cmwgIT0gTlVMTCkgewoJCWZyZWUoZnJlcS0+dXJsKTsKCQlmcmVxLT51cmwgPSBOVUxMOwoJfQoJaWYgKGZyZXEtPnNsb3QgIT0gTlVMTCkgewoJCWZyZXEtPnNsb3QtPmNhbGxiYWNrX2Z1bmMgPSBOVUxMOwoJCWZyZXEtPnNsb3QtPmNhbGxiYWNrX2RhdGEgPSBOVUxMOwoJCXJlbGVhc2VfYWN0aXZlX3Nsb3QoZnJlcS0+c2xvdCk7CgkJZnJlcS0+c2xvdCA9IE5VTEw7Cgl9Cn0K",
    "text": "#include \"git-compat-util.h\"\n#include \"http.h\"\n#include \"pack.h\"\n#include \"sideband.h\"\n#include \"run-command.h\"\n#include \"url.h\"\n#include \"urlmatch.h\"\n#include \"credential.h\"\n#include \"version.h\"\n#include \"pkt-line.h\"\n#include \"gettext.h\"\n\nint active_requests;\nint http_is_verbose;\nsize_t http_post_buffer = 16 * LARGE_PACKET_MAX;\n\n#if LIBCURL_VERSION_NUM >= 0x070a06\n#define LIBCURL_CAN_HANDLE_AUTH_ANY\n#endif\n\nstatic int min_curl_sessions = 1;\nstatic int curl_session_count;\n#ifdef USE_CURL_MULTI\nstatic int max_requests = -1;\nstatic CURLM *curlm;\n#endif\n#ifndef NO_CURL_EASY_DUPHANDLE\nstatic CURL *curl_default;\n#endif\n\n#define PREV_BUF_SIZE 4096\n#define RANGE_HEADER_SIZE 30\n\nchar curl_errorstr[CURL_ERROR_SIZE];\n\nstatic int curl_ssl_verify = -1;\nstatic int curl_ssl_try;\nstatic const char *ssl_cert;\n#if LIBCURL_VERSION_NUM >= 0x070903\nstatic const char *ssl_key;\n#endif\n#if LIBCURL_VERSION_NUM >= 0x070908\nstatic const char *ssl_capath;\n#endif\nstatic const char *ssl_cainfo;\nstatic long curl_low_speed_limit = -1;\nstatic long curl_low_speed_time = -1;\nstatic int curl_ftp_no_epsv;\nstatic const char *curl_http_proxy;\nstatic const char *curl_cookie_file;\nstatic int curl_save_cookies;\nstruct credential http_auth = CREDENTIAL_INIT;\nstatic int http_proactive_auth;\nstatic const char *user_agent;\n\n#if LIBCURL_VERSION_NUM >= 0x071700\n/* Use CURLOPT_KEYPASSWD as is */\n#elif LIBCURL_VERSION_NUM >= 0x070903\n#define CURLOPT_KEYPASSWD CURLOPT_SSLKEYPASSWD\n#else\n#define CURLOPT_KEYPASSWD CURLOPT_SSLCERTPASSWD\n#endif\n\nstatic struct credential cert_auth = CREDENTIAL_INIT;\nstatic int ssl_cert_password_required;\n\nstatic struct curl_slist *pragma_header;\nstatic struct curl_slist *no_pragma_header;\n\nstatic struct active_request_slot *active_queue_head;\n\nstatic char *cached_accept_language;\n\nsize_t fread_buffer(char *ptr, size_t eltsize, size_t nmemb, void *buffer_)\n{\n\tsize_t size = eltsize * nmemb;\n\tstruct buffer *buffer = buffer_;\n\n\tif (size > buffer->buf.len - buffer->posn)\n\t\tsize = buffer->buf.len - buffer->posn;\n\tmemcpy(ptr, buffer->buf.buf + buffer->posn, size);\n\tbuffer->posn += size;\n\n\treturn size;\n}\n\n#ifndef NO_CURL_IOCTL\ncurlioerr ioctl_buffer(CURL *handle, int cmd, void *clientp)\n{\n\tstruct buffer *buffer = clientp;\n\n\tswitch (cmd) {\n\tcase CURLIOCMD_NOP:\n\t\treturn CURLIOE_OK;\n\n\tcase CURLIOCMD_RESTARTREAD:\n\t\tbuffer->posn = 0;\n\t\treturn CURLIOE_OK;\n\n\tdefault:\n\t\treturn CURLIOE_UNKNOWNCMD;\n\t}\n}\n#endif\n\nsize_t fwrite_buffer(char *ptr, size_t eltsize, size_t nmemb, void *buffer_)\n{\n\tsize_t size = eltsize * nmemb;\n\tstruct strbuf *buffer = buffer_;\n\n\tstrbuf_add(buffer, ptr, size);\n\treturn size;\n}\n\nsize_t fwrite_null(char *ptr, size_t eltsize, size_t nmemb, void *strbuf)\n{\n\treturn eltsize * nmemb;\n}\n\n#ifdef USE_CURL_MULTI\nstatic void process_curl_messages(void)\n{\n\tint num_messages;\n\tstruct active_request_slot *slot;\n\tCURLMsg *curl_message = curl_multi_info_read(curlm, &num_messages);\n\n\twhile (curl_message != NULL) {\n\t\tif (curl_message->msg == CURLMSG_DONE) {\n\t\t\tint curl_result = curl_message->data.result;\n\t\t\tslot = active_queue_head;\n\t\t\twhile (slot != NULL &&\n\t\t\t       slot->curl != curl_message->easy_handle)\n\t\t\t\tslot = slot->next;\n\t\t\tif (slot != NULL) {\n\t\t\t\tcurl_multi_remove_handle(curlm, slot->curl);\n\t\t\t\tslot->curl_result = curl_result;\n\t\t\t\tfinish_active_slot(slot);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Received DONE message for unknown request!\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown CURL message received: %d\\n\",\n\t\t\t\t(int)curl_message->msg);\n\t\t}\n\t\tcurl_message = curl_multi_info_read(curlm, &num_messages);\n\t}\n}\n#endif\n\nstatic int http_options(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(\"http.sslverify\", var)) {\n\t\tcurl_ssl_verify = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.sslcert\", var))\n\t\treturn git_config_string(&ssl_cert, var, value);\n#if LIBCURL_VERSION_NUM >= 0x070903\n\tif (!strcmp(\"http.sslkey\", var))\n\t\treturn git_config_string(&ssl_key, var, value);\n#endif\n#if LIBCURL_VERSION_NUM >= 0x070908\n\tif (!strcmp(\"http.sslcapath\", var))\n\t\treturn git_config_string(&ssl_capath, var, value);\n#endif\n\tif (!strcmp(\"http.sslcainfo\", var))\n\t\treturn git_config_string(&ssl_cainfo, var, value);\n\tif (!strcmp(\"http.sslcertpasswordprotected\", var)) {\n\t\tssl_cert_password_required = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.ssltry\", var)) {\n\t\tcurl_ssl_try = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.minsessions\", var)) {\n\t\tmin_curl_sessions = git_config_int(var, value);\n#ifndef USE_CURL_MULTI\n\t\tif (min_curl_sessions > 1)\n\t\t\tmin_curl_sessions = 1;\n#endif\n\t\treturn 0;\n\t}\n#ifdef USE_CURL_MULTI\n\tif (!strcmp(\"http.maxrequests\", var)) {\n\t\tmax_requests = git_config_int(var, value);\n\t\treturn 0;\n\t}\n#endif\n\tif (!strcmp(\"http.lowspeedlimit\", var)) {\n\t\tcurl_low_speed_limit = (long)git_config_int(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.lowspeedtime\", var)) {\n\t\tcurl_low_speed_time = (long)git_config_int(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(\"http.noepsv\", var)) {\n\t\tcurl_ftp_no_epsv = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.proxy\", var))\n\t\treturn git_config_string(&curl_http_proxy, var, value);\n\n\tif (!strcmp(\"http.cookiefile\", var))\n\t\treturn git_config_string(&curl_cookie_file, var, value);\n\tif (!strcmp(\"http.savecookies\", var)) {\n\t\tcurl_save_cookies = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(\"http.postbuffer\", var)) {\n\t\thttp_post_buffer = git_config_int(var, value);\n\t\tif (http_post_buffer < LARGE_PACKET_MAX)\n\t\t\thttp_post_buffer = LARGE_PACKET_MAX;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(\"http.useragent\", var))\n\t\treturn git_config_string(&user_agent, var, value);\n\n\t/* Fall back on the default ones */\n\treturn git_default_config(var, value, cb);\n}\n\nstatic void init_curl_http_auth(CURL *result)\n{\n\tif (!http_auth.username)\n\t\treturn;\n\n\tcredential_fill(&http_auth);\n\n#if LIBCURL_VERSION_NUM >= 0x071301\n\tcurl_easy_setopt(result, CURLOPT_USERNAME, http_auth.username);\n\tcurl_easy_setopt(result, CURLOPT_PASSWORD, http_auth.password);\n#else\n\t{\n\t\tstatic struct strbuf up = STRBUF_INIT;\n\t\t/*\n\t\t * Note that we assume we only ever have a single set of\n\t\t * credentials in a given program run, so we do not have\n\t\t * to worry about updating this buffer, only setting its\n\t\t * initial value.\n\t\t */\n\t\tif (!up.len)\n\t\t\tstrbuf_addf(&up, \"%s:%s\",\n\t\t\t\thttp_auth.username, http_auth.password);\n\t\tcurl_easy_setopt(result, CURLOPT_USERPWD, up.buf);\n\t}\n#endif\n}\n\nstatic int has_cert_password(void)\n{\n\tif (ssl_cert == NULL || ssl_cert_password_required != 1)\n\t\treturn 0;\n\tif (!cert_auth.password) {\n\t\tcert_auth.protocol = xstrdup(\"cert\");\n\t\tcert_auth.username = xstrdup(\"\");\n\t\tcert_auth.path = xstrdup(ssl_cert);\n\t\tcredential_fill(&cert_auth);\n\t}\n\treturn 1;\n}\n\n#if LIBCURL_VERSION_NUM >= 0x071900\nstatic void set_curl_keepalive(CURL *c)\n{\n\tcurl_easy_setopt(c, CURLOPT_TCP_KEEPALIVE, 1);\n}\n\n#elif LIBCURL_VERSION_NUM >= 0x071000\nstatic int sockopt_callback(void *client, curl_socket_t fd, curlsocktype type)\n{\n\tint ka = 1;\n\tint rc;\n\tsocklen_t len = (socklen_t)sizeof(ka);\n\n\tif (type != CURLSOCKTYPE_IPCXN)\n\t\treturn 0;\n\n\trc = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void *)&ka, len);\n\tif (rc < 0)\n\t\twarning(\"unable to set SO_KEEPALIVE on socket %s\",\n\t\t\tstrerror(errno));\n\n\treturn 0; /* CURL_SOCKOPT_OK only exists since curl 7.21.5 */\n}\n\nstatic void set_curl_keepalive(CURL *c)\n{\n\tcurl_easy_setopt(c, CURLOPT_SOCKOPTFUNCTION, sockopt_callback);\n}\n\n#else\nstatic void set_curl_keepalive(CURL *c)\n{\n\t/* not supported on older curl versions */\n}\n#endif\n\nstatic CURL *get_curl_handle(void)\n{\n\tCURL *result = curl_easy_init();\n\n\tif (!result)\n\t\tdie(\"curl_easy_init failed\");\n\n\tif (!curl_ssl_verify) {\n\t\tcurl_easy_setopt(result, CURLOPT_SSL_VERIFYPEER, 0);\n\t\tcurl_easy_setopt(result, CURLOPT_SSL_VERIFYHOST, 0);\n\t} else {\n\t\t/* Verify authenticity of the peer's certificate */\n\t\tcurl_easy_setopt(result, CURLOPT_SSL_VERIFYPEER, 1);\n\t\t/* The name in the cert must match whom we tried to connect */\n\t\tcurl_easy_setopt(result, CURLOPT_SSL_VERIFYHOST, 2);\n\t}\n\n#if LIBCURL_VERSION_NUM >= 0x070907\n\tcurl_easy_setopt(result, CURLOPT_NETRC, CURL_NETRC_OPTIONAL);\n#endif\n#ifdef LIBCURL_CAN_HANDLE_AUTH_ANY\n\tcurl_easy_setopt(result, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n#endif\n\n\tif (http_proactive_auth)\n\t\tinit_curl_http_auth(result);\n\n\tif (ssl_cert != NULL)\n\t\tcurl_easy_setopt(result, CURLOPT_SSLCERT, ssl_cert);\n\tif (has_cert_password())\n\t\tcurl_easy_setopt(result, CURLOPT_KEYPASSWD, cert_auth.password);\n#if LIBCURL_VERSION_NUM >= 0x070903\n\tif (ssl_key != NULL)\n\t\tcurl_easy_setopt(result, CURLOPT_SSLKEY, ssl_key);\n#endif\n#if LIBCURL_VERSION_NUM >= 0x070908\n\tif (ssl_capath != NULL)\n\t\tcurl_easy_setopt(result, CURLOPT_CAPATH, ssl_capath);\n#endif\n\tif (ssl_cainfo != NULL)\n\t\tcurl_easy_setopt(result, CURLOPT_CAINFO, ssl_cainfo);\n\n\tif (curl_low_speed_limit > 0 && curl_low_speed_time > 0) {\n\t\tcurl_easy_setopt(result, CURLOPT_LOW_SPEED_LIMIT,\n\t\t\t\t curl_low_speed_limit);\n\t\tcurl_easy_setopt(result, CURLOPT_LOW_SPEED_TIME,\n\t\t\t\t curl_low_speed_time);\n\t}\n\n\tcurl_easy_setopt(result, CURLOPT_FOLLOWLOCATION, 1);\n#if LIBCURL_VERSION_NUM >= 0x071301\n\tcurl_easy_setopt(result, CURLOPT_POSTREDIR, CURL_REDIR_POST_ALL);\n#elif LIBCURL_VERSION_NUM >= 0x071101\n\tcurl_easy_setopt(result, CURLOPT_POST301, 1);\n#endif\n\n\tif (getenv(\"GIT_CURL_VERBOSE\"))\n\t\tcurl_easy_setopt(result, CURLOPT_VERBOSE, 1);\n\n\tcurl_easy_setopt(result, CURLOPT_USERAGENT,\n\t\tuser_agent ? user_agent : git_user_agent());\n\n\tif (curl_ftp_no_epsv)\n\t\tcurl_easy_setopt(result, CURLOPT_FTP_USE_EPSV, 0);\n\n#ifdef CURLOPT_USE_SSL\n\tif (curl_ssl_try)\n\t\tcurl_easy_setopt(result, CURLOPT_USE_SSL, CURLUSESSL_TRY);\n#endif\n\n\tif (curl_http_proxy) {\n\t\tcurl_easy_setopt(result, CURLOPT_PROXY, curl_http_proxy);\n\t\tcurl_easy_setopt(result, CURLOPT_PROXYAUTH, CURLAUTH_ANY);\n\t}\n\n\tset_curl_keepalive(result);\n\n\treturn result;\n}\n\nstatic void set_from_env(const char **var, const char *envname)\n{\n\tconst char *val = getenv(envname);\n\tif (val)\n\t\t*var = val;\n}\n\nvoid http_init(struct remote *remote, const char *url, int proactive_auth)\n{\n\tchar *low_speed_limit;\n\tchar *low_speed_time;\n\tchar *normalized_url;\n\tstruct urlmatch_config config = { STRING_LIST_INIT_DUP };\n\n\tconfig.section = \"http\";\n\tconfig.key = NULL;\n\tconfig.collect_fn = http_options;\n\tconfig.cascade_fn = git_default_config;\n\tconfig.cb = NULL;\n\n\thttp_is_verbose = 0;\n\tnormalized_url = url_normalize(url, &config.url);\n\n\tgit_config(urlmatch_config_entry, &config);\n\tfree(normalized_url);\n\n\tif (curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK)\n\t\tdie(\"curl_global_init failed\");\n\n\thttp_proactive_auth = proactive_auth;\n\n\tif (remote && remote->http_proxy)\n\t\tcurl_http_proxy = xstrdup(remote->http_proxy);\n\n\tpragma_header = curl_slist_append(pragma_header, \"Pragma: no-cache\");\n\tno_pragma_header = curl_slist_append(no_pragma_header, \"Pragma:\");\n\n#ifdef USE_CURL_MULTI\n\t{\n\t\tchar *http_max_requests = getenv(\"GIT_HTTP_MAX_REQUESTS\");\n\t\tif (http_max_requests != NULL)\n\t\t\tmax_requests = atoi(http_max_requests);\n\t}\n\n\tcurlm = curl_multi_init();\n\tif (!curlm)\n\t\tdie(\"curl_multi_init failed\");\n#endif\n\n\tif (getenv(\"GIT_SSL_NO_VERIFY\"))\n\t\tcurl_ssl_verify = 0;\n\n\tset_from_env(&ssl_cert, \"GIT_SSL_CERT\");\n#if LIBCURL_VERSION_NUM >= 0x070903\n\tset_from_env(&ssl_key, \"GIT_SSL_KEY\");\n#endif\n#if LIBCURL_VERSION_NUM >= 0x070908\n\tset_from_env(&ssl_capath, \"GIT_SSL_CAPATH\");\n#endif\n\tset_from_env(&ssl_cainfo, \"GIT_SSL_CAINFO\");\n\n\tset_from_env(&user_agent, \"GIT_HTTP_USER_AGENT\");\n\n\tlow_speed_limit = getenv(\"GIT_HTTP_LOW_SPEED_LIMIT\");\n\tif (low_speed_limit != NULL)\n\t\tcurl_low_speed_limit = strtol(low_speed_limit, NULL, 10);\n\tlow_speed_time = getenv(\"GIT_HTTP_LOW_SPEED_TIME\");\n\tif (low_speed_time != NULL)\n\t\tcurl_low_speed_time = strtol(low_speed_time, NULL, 10);\n\n\tif (curl_ssl_verify == -1)\n\t\tcurl_ssl_verify = 1;\n\n\tcurl_session_count = 0;\n#ifdef USE_CURL_MULTI\n\tif (max_requests < 1)\n\t\tmax_requests = DEFAULT_MAX_REQUESTS;\n#endif\n\n\tif (getenv(\"GIT_CURL_FTP_NO_EPSV\"))\n\t\tcurl_ftp_no_epsv = 1;\n\n\tif (url) {\n\t\tcredential_from_url(&http_auth, url);\n\t\tif (!ssl_cert_password_required &&\n\t\t    getenv(\"GIT_SSL_CERT_PASSWORD_PROTECTED\") &&\n\t\t    starts_with(url, \"https://\"))\n\t\t\tssl_cert_password_required = 1;\n\t}\n\n#ifndef NO_CURL_EASY_DUPHANDLE\n\tcurl_default = get_curl_handle();\n#endif\n}\n\nvoid http_cleanup(void)\n{\n\tstruct active_request_slot *slot = active_queue_head;\n\n\twhile (slot != NULL) {\n\t\tstruct active_request_slot *next = slot->next;\n\t\tif (slot->curl != NULL) {\n#ifdef USE_CURL_MULTI\n\t\t\tcurl_multi_remove_handle(curlm, slot->curl);\n#endif\n\t\t\tcurl_easy_cleanup(slot->curl);\n\t\t}\n\t\tfree(slot);\n\t\tslot = next;\n\t}\n\tactive_queue_head = NULL;\n\n#ifndef NO_CURL_EASY_DUPHANDLE\n\tcurl_easy_cleanup(curl_default);\n#endif\n\n#ifdef USE_CURL_MULTI\n\tcurl_multi_cleanup(curlm);\n#endif\n\tcurl_global_cleanup();\n\n\tcurl_slist_free_all(pragma_header);\n\tpragma_header = NULL;\n\n\tcurl_slist_free_all(no_pragma_header);\n\tno_pragma_header = NULL;\n\n\tif (curl_http_proxy) {\n\t\tfree((void *)curl_http_proxy);\n\t\tcurl_http_proxy = NULL;\n\t}\n\n\tif (cert_auth.password != NULL) {\n\t\tmemset(cert_auth.password, 0, strlen(cert_auth.password));\n\t\tfree(cert_auth.password);\n\t\tcert_auth.password = NULL;\n\t}\n\tssl_cert_password_required = 0;\n\n\tfree(cached_accept_language);\n\tcached_accept_language = NULL;\n}\n\nstruct active_request_slot *get_active_slot(void)\n{\n\tstruct active_request_slot *slot = active_queue_head;\n\tstruct active_request_slot *newslot;\n\n#ifdef USE_CURL_MULTI\n\tint num_transfers;\n\n\t/* Wait for a slot to open up if the queue is full */\n\twhile (active_requests >= max_requests) {\n\t\tcurl_multi_perform(curlm, &num_transfers);\n\t\tif (num_transfers < active_requests)\n\t\t\tprocess_curl_messages();\n\t}\n#endif\n\n\twhile (slot != NULL && slot->in_use)\n\t\tslot = slot->next;\n\n\tif (slot == NULL) {\n\t\tnewslot = xmalloc(sizeof(*newslot));\n\t\tnewslot->curl = NULL;\n\t\tnewslot->in_use = 0;\n\t\tnewslot->next = NULL;\n\n\t\tslot = active_queue_head;\n\t\tif (slot == NULL) {\n\t\t\tactive_queue_head = newslot;\n\t\t} else {\n\t\t\twhile (slot->next != NULL)\n\t\t\t\tslot = slot->next;\n\t\t\tslot->next = newslot;\n\t\t}\n\t\tslot = newslot;\n\t}\n\n\tif (slot->curl == NULL) {\n#ifdef NO_CURL_EASY_DUPHANDLE\n\t\tslot->curl = get_curl_handle();\n#else\n\t\tslot->curl = curl_easy_duphandle(curl_default);\n#endif\n\t\tcurl_session_count++;\n\t}\n\n\tactive_requests++;\n\tslot->in_use = 1;\n\tslot->results = NULL;\n\tslot->finished = NULL;\n\tslot->callback_data = NULL;\n\tslot->callback_func = NULL;\n\tcurl_easy_setopt(slot->curl, CURLOPT_COOKIEFILE, curl_cookie_file);\n\tif (curl_save_cookies)\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_COOKIEJAR, curl_cookie_file);\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, pragma_header);\n\tcurl_easy_setopt(slot->curl, CURLOPT_ERRORBUFFER, curl_errorstr);\n\tcurl_easy_setopt(slot->curl, CURLOPT_CUSTOMREQUEST, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_READFUNCTION, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_UPLOAD, 0);\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPGET, 1);\n\tcurl_easy_setopt(slot->curl, CURLOPT_FAILONERROR, 1);\n\tif (http_auth.password)\n\t\tinit_curl_http_auth(slot->curl);\n\n\treturn slot;\n}\n\nint start_active_slot(struct active_request_slot *slot)\n{\n#ifdef USE_CURL_MULTI\n\tCURLMcode curlm_result = curl_multi_add_handle(curlm, slot->curl);\n\tint num_transfers;\n\n\tif (curlm_result != CURLM_OK &&\n\t    curlm_result != CURLM_CALL_MULTI_PERFORM) {\n\t\tactive_requests--;\n\t\tslot->in_use = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We know there must be something to do, since we just added\n\t * something.\n\t */\n\tcurl_multi_perform(curlm, &num_transfers);\n#endif\n\treturn 1;\n}\n\n#ifdef USE_CURL_MULTI\nstruct fill_chain {\n\tvoid *data;\n\tint (*fill)(void *);\n\tstruct fill_chain *next;\n};\n\nstatic struct fill_chain *fill_cfg;\n\nvoid add_fill_function(void *data, int (*fill)(void *))\n{\n\tstruct fill_chain *new = xmalloc(sizeof(*new));\n\tstruct fill_chain **linkp = &fill_cfg;\n\tnew->data = data;\n\tnew->fill = fill;\n\tnew->next = NULL;\n\twhile (*linkp)\n\t\tlinkp = &(*linkp)->next;\n\t*linkp = new;\n}\n\nvoid fill_active_slots(void)\n{\n\tstruct active_request_slot *slot = active_queue_head;\n\n\twhile (active_requests < max_requests) {\n\t\tstruct fill_chain *fill;\n\t\tfor (fill = fill_cfg; fill; fill = fill->next)\n\t\t\tif (fill->fill(fill->data))\n\t\t\t\tbreak;\n\n\t\tif (!fill)\n\t\t\tbreak;\n\t}\n\n\twhile (slot != NULL) {\n\t\tif (!slot->in_use && slot->curl != NULL\n\t\t\t&& curl_session_count > min_curl_sessions) {\n\t\t\tcurl_easy_cleanup(slot->curl);\n\t\t\tslot->curl = NULL;\n\t\t\tcurl_session_count--;\n\t\t}\n\t\tslot = slot->next;\n\t}\n}\n\nvoid step_active_slots(void)\n{\n\tint num_transfers;\n\tCURLMcode curlm_result;\n\n\tdo {\n\t\tcurlm_result = curl_multi_perform(curlm, &num_transfers);\n\t} while (curlm_result == CURLM_CALL_MULTI_PERFORM);\n\tif (num_transfers < active_requests) {\n\t\tprocess_curl_messages();\n\t\tfill_active_slots();\n\t}\n}\n#endif\n\nvoid run_active_slot(struct active_request_slot *slot)\n{\n#ifdef USE_CURL_MULTI\n\tfd_set readfds;\n\tfd_set writefds;\n\tfd_set excfds;\n\tint max_fd;\n\tstruct timeval select_timeout;\n\tint finished = 0;\n\n\tslot->finished = &finished;\n\twhile (!finished) {\n\t\tstep_active_slots();\n\n\t\tif (slot->in_use) {\n#if LIBCURL_VERSION_NUM >= 0x070f04\n\t\t\tlong curl_timeout;\n\t\t\tcurl_multi_timeout(curlm, &curl_timeout);\n\t\t\tif (curl_timeout == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (curl_timeout == -1) {\n\t\t\t\tselect_timeout.tv_sec  = 0;\n\t\t\t\tselect_timeout.tv_usec = 50000;\n\t\t\t} else {\n\t\t\t\tselect_timeout.tv_sec  =  curl_timeout / 1000;\n\t\t\t\tselect_timeout.tv_usec = (curl_timeout % 1000) * 1000;\n\t\t\t}\n#else\n\t\t\tselect_timeout.tv_sec  = 0;\n\t\t\tselect_timeout.tv_usec = 50000;\n#endif\n\n\t\t\tmax_fd = -1;\n\t\t\tFD_ZERO(&readfds);\n\t\t\tFD_ZERO(&writefds);\n\t\t\tFD_ZERO(&excfds);\n\t\t\tcurl_multi_fdset(curlm, &readfds, &writefds, &excfds, &max_fd);\n\n\t\t\t/*\n\t\t\t * It can happen that curl_multi_timeout returns a pathologically\n\t\t\t * long timeout when curl_multi_fdset returns no file descriptors\n\t\t\t * to read.  See commit message for more details.\n\t\t\t */\n\t\t\tif (max_fd < 0 &&\n\t\t\t    (select_timeout.tv_sec > 0 ||\n\t\t\t     select_timeout.tv_usec > 50000)) {\n\t\t\t\tselect_timeout.tv_sec  = 0;\n\t\t\t\tselect_timeout.tv_usec = 50000;\n\t\t\t}\n\n\t\t\tselect(max_fd+1, &readfds, &writefds, &excfds, &select_timeout);\n\t\t}\n\t}\n#else\n\twhile (slot->in_use) {\n\t\tslot->curl_result = curl_easy_perform(slot->curl);\n\t\tfinish_active_slot(slot);\n\t}\n#endif\n}\n\nstatic void closedown_active_slot(struct active_request_slot *slot)\n{\n\tactive_requests--;\n\tslot->in_use = 0;\n}\n\nstatic void release_active_slot(struct active_request_slot *slot)\n{\n\tclosedown_active_slot(slot);\n\tif (slot->curl && curl_session_count > min_curl_sessions) {\n#ifdef USE_CURL_MULTI\n\t\tcurl_multi_remove_handle(curlm, slot->curl);\n#endif\n\t\tcurl_easy_cleanup(slot->curl);\n\t\tslot->curl = NULL;\n\t\tcurl_session_count--;\n\t}\n#ifdef USE_CURL_MULTI\n\tfill_active_slots();\n#endif\n}\n\nvoid finish_active_slot(struct active_request_slot *slot)\n{\n\tclosedown_active_slot(slot);\n\tcurl_easy_getinfo(slot->curl, CURLINFO_HTTP_CODE, &slot->http_code);\n\n\tif (slot->finished != NULL)\n\t\t(*slot->finished) = 1;\n\n\t/* Store slot results so they can be read after the slot is reused */\n\tif (slot->results != NULL) {\n\t\tslot->results->curl_result = slot->curl_result;\n\t\tslot->results->http_code = slot->http_code;\n#if LIBCURL_VERSION_NUM >= 0x070a08\n\t\tcurl_easy_getinfo(slot->curl, CURLINFO_HTTPAUTH_AVAIL,\n\t\t\t\t  &slot->results->auth_avail);\n#else\n\t\tslot->results->auth_avail = 0;\n#endif\n\t}\n\n\t/* Run callback if appropriate */\n\tif (slot->callback_func != NULL)\n\t\tslot->callback_func(slot->callback_data);\n}\n\nvoid finish_all_active_slots(void)\n{\n\tstruct active_request_slot *slot = active_queue_head;\n\n\twhile (slot != NULL)\n\t\tif (slot->in_use) {\n\t\t\trun_active_slot(slot);\n\t\t\tslot = active_queue_head;\n\t\t} else {\n\t\t\tslot = slot->next;\n\t\t}\n}\n\n/* Helpers for modifying and creating URLs */\nstatic inline int needs_quote(int ch)\n{\n\tif (((ch >= 'A') && (ch <= 'Z'))\n\t\t\t|| ((ch >= 'a') && (ch <= 'z'))\n\t\t\t|| ((ch >= '0') && (ch <= '9'))\n\t\t\t|| (ch == '/')\n\t\t\t|| (ch == '-')\n\t\t\t|| (ch == '.'))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic char *quote_ref_url(const char *base, const char *ref)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *cp;\n\tint ch;\n\n\tend_url_with_slash(&buf, base);\n\n\tfor (cp = ref; (ch = *cp) != 0; cp++)\n\t\tif (needs_quote(ch))\n\t\t\tstrbuf_addf(&buf, \"%%%02x\", ch);\n\t\telse\n\t\t\tstrbuf_addch(&buf, *cp);\n\n\treturn strbuf_detach(&buf, NULL);\n}\n\nvoid append_remote_object_url(struct strbuf *buf, const char *url,\n\t\t\t      const char *hex,\n\t\t\t      int only_two_digit_prefix)\n{\n\tend_url_with_slash(buf, url);\n\n\tstrbuf_addf(buf, \"objects/%.*s/\", 2, hex);\n\tif (!only_two_digit_prefix)\n\t\tstrbuf_addf(buf, \"%s\", hex+2);\n}\n\nchar *get_remote_object_url(const char *url, const char *hex,\n\t\t\t    int only_two_digit_prefix)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tappend_remote_object_url(&buf, url, hex, only_two_digit_prefix);\n\treturn strbuf_detach(&buf, NULL);\n}\n\nint handle_curl_result(struct slot_results *results)\n{\n\t/*\n\t * If we see a failing http code with CURLE_OK, we have turned off\n\t * FAILONERROR (to keep the server's custom error response), and should\n\t * translate the code into failure here.\n\t */\n\tif (results->curl_result == CURLE_OK &&\n\t    results->http_code >= 400) {\n\t\tresults->curl_result = CURLE_HTTP_RETURNED_ERROR;\n\t\t/*\n\t\t * Normally curl will already have put the \"reason phrase\"\n\t\t * from the server into curl_errorstr; unfortunately without\n\t\t * FAILONERROR it is lost, so we can give only the numeric\n\t\t * status code.\n\t\t */\n\t\tsnprintf(curl_errorstr, sizeof(curl_errorstr),\n\t\t\t \"The requested URL returned error: %ld\",\n\t\t\t results->http_code);\n\t}\n\n\tif (results->curl_result == CURLE_OK) {\n\t\tcredential_approve(&http_auth);\n\t\treturn HTTP_OK;\n\t} else if (missing_target(results))\n\t\treturn HTTP_MISSING_TARGET;\n\telse if (results->http_code == 401) {\n\t\tif (http_auth.username && http_auth.password) {\n\t\t\tcredential_reject(&http_auth);\n\t\t\treturn HTTP_NOAUTH;\n\t\t} else {\n\t\t\treturn HTTP_REAUTH;\n\t\t}\n\t} else {\n#if LIBCURL_VERSION_NUM >= 0x070c00\n\t\tif (!curl_errorstr[0])\n\t\t\tstrlcpy(curl_errorstr,\n\t\t\t\tcurl_easy_strerror(results->curl_result),\n\t\t\t\tsizeof(curl_errorstr));\n#endif\n\t\treturn HTTP_ERROR;\n\t}\n}\n\nint run_one_slot(struct active_request_slot *slot,\n\t\t struct slot_results *results)\n{\n\tslot->results = results;\n\tif (!start_active_slot(slot)) {\n\t\tsnprintf(curl_errorstr, sizeof(curl_errorstr),\n\t\t\t \"failed to start HTTP request\");\n\t\treturn HTTP_START_FAILED;\n\t}\n\n\trun_active_slot(slot);\n\treturn handle_curl_result(results);\n}\n\nstatic CURLcode curlinfo_strbuf(CURL *curl, CURLINFO info, struct strbuf *buf)\n{\n\tchar *ptr;\n\tCURLcode ret;\n\n\tstrbuf_reset(buf);\n\tret = curl_easy_getinfo(curl, info, &ptr);\n\tif (!ret && ptr)\n\t\tstrbuf_addstr(buf, ptr);\n\treturn ret;\n}\n\n/*\n * Check for and extract a content-type parameter. \"raw\"\n * should be positioned at the start of the potential\n * parameter, with any whitespace already removed.\n *\n * \"name\" is the name of the parameter. The value is appended\n * to \"out\".\n */\nstatic int extract_param(const char *raw, const char *name,\n\t\t\t struct strbuf *out)\n{\n\tsize_t len = strlen(name);\n\n\tif (strncasecmp(raw, name, len))\n\t\treturn -1;\n\traw += len;\n\n\tif (*raw != '=')\n\t\treturn -1;\n\traw++;\n\n\twhile (*raw && !isspace(*raw) && *raw != ';')\n\t\tstrbuf_addch(out, *raw++);\n\treturn 0;\n}\n\n/*\n * Extract a normalized version of the content type, with any\n * spaces suppressed, all letters lowercased, and no trailing \";\"\n * or parameters.\n *\n * Note that we will silently remove even invalid whitespace. For\n * example, \"text / plain\" is specifically forbidden by RFC 2616,\n * but \"text/plain\" is the only reasonable output, and this keeps\n * our code simple.\n *\n * If the \"charset\" argument is not NULL, store the value of any\n * charset parameter there.\n *\n * Example:\n *   \"TEXT/PLAIN; charset=utf-8\" -> \"text/plain\", \"utf-8\"\n *   \"text / plain\" -> \"text/plain\"\n */\nstatic void extract_content_type(struct strbuf *raw, struct strbuf *type,\n\t\t\t\t struct strbuf *charset)\n{\n\tconst char *p;\n\n\tstrbuf_reset(type);\n\tstrbuf_grow(type, raw->len);\n\tfor (p = raw->buf; *p; p++) {\n\t\tif (isspace(*p))\n\t\t\tcontinue;\n\t\tif (*p == ';') {\n\t\t\tp++;\n\t\t\tbreak;\n\t\t}\n\t\tstrbuf_addch(type, tolower(*p));\n\t}\n\n\tif (!charset)\n\t\treturn;\n\n\tstrbuf_reset(charset);\n\twhile (*p) {\n\t\twhile (isspace(*p) || *p == ';')\n\t\t\tp++;\n\t\tif (!extract_param(p, \"charset\", charset))\n\t\t\treturn;\n\t\twhile (*p && !isspace(*p))\n\t\t\tp++;\n\t}\n\n\tif (!charset->len && starts_with(type->buf, \"text/\"))\n\t\tstrbuf_addstr(charset, \"ISO-8859-1\");\n}\n\nstatic void write_accept_language(struct strbuf *buf)\n{\n\t/*\n\t * MAX_DECIMAL_PLACES must not be larger than 3. If it is larger than\n\t * that, q-value will be smaller than 0.001, the minimum q-value the\n\t * HTTP specification allows. See\n\t * http://tools.ietf.org/html/rfc7231#section-5.3.1 for q-value.\n\t */\n\tconst int MAX_DECIMAL_PLACES = 3;\n\tconst int MAX_LANGUAGE_TAGS = 1000;\n\tconst int MAX_ACCEPT_LANGUAGE_HEADER_SIZE = 4000;\n\tchar **language_tags = NULL;\n\tint num_langs = 0;\n\tconst char *s = get_preferred_languages();\n\tint i;\n\tstruct strbuf tag = STRBUF_INIT;\n\n\t/* Don't add Accept-Language header if no language is preferred. */\n\tif (!s)\n\t\treturn;\n\n\t/*\n\t * Split the colon-separated string of preferred languages into\n\t * language_tags array.\n\t */\n\tdo {\n\t\t/* collect language tag */\n\t\tfor (; *s && (isalnum(*s) || *s == '_'); s++)\n\t\t\tstrbuf_addch(&tag, *s == '_' ? '-' : *s);\n\n\t\t/* skip .codeset, @modifier and any other unnecessary parts */\n\t\twhile (*s && *s != ':')\n\t\t\ts++;\n\n\t\tif (tag.len) {\n\t\t\tnum_langs++;\n\t\t\tREALLOC_ARRAY(language_tags, num_langs);\n\t\t\tlanguage_tags[num_langs - 1] = strbuf_detach(&tag, NULL);\n\t\t\tif (num_langs >= MAX_LANGUAGE_TAGS - 1) /* -1 for '*' */\n\t\t\t\tbreak;\n\t\t}\n\t} while (*s++);\n\n\t/* write Accept-Language header into buf */\n\tif (num_langs) {\n\t\tint last_buf_len = 0;\n\t\tint max_q;\n\t\tint decimal_places;\n\t\tchar q_format[32];\n\n\t\t/* add '*' */\n\t\tREALLOC_ARRAY(language_tags, num_langs + 1);\n\t\tlanguage_tags[num_langs++] = \"*\"; /* it's OK; this won't be freed */\n\n\t\t/* compute decimal_places */\n\t\tfor (max_q = 1, decimal_places = 0;\n\t\t     max_q < num_langs && decimal_places <= MAX_DECIMAL_PLACES;\n\t\t     decimal_places++, max_q *= 10)\n\t\t\t;\n\n\t\tsprintf(q_format, \";q=0.%%0%dd\", decimal_places);\n\n\t\tstrbuf_addstr(buf, \"Accept-Language: \");\n\n\t\tfor (i = 0; i < num_langs; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tstrbuf_addstr(buf, \", \");\n\n\t\t\tstrbuf_addstr(buf, language_tags[i]);\n\n\t\t\tif (i > 0)\n\t\t\t\tstrbuf_addf(buf, q_format, max_q - i);\n\n\t\t\tif (buf->len > MAX_ACCEPT_LANGUAGE_HEADER_SIZE) {\n\t\t\t\tstrbuf_remove(buf, last_buf_len, buf->len - last_buf_len);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlast_buf_len = buf->len;\n\t\t}\n\t}\n\n\t/* free language tags -- last one is a static '*' */\n\tfor (i = 0; i < num_langs - 1; i++)\n\t\tfree(language_tags[i]);\n\tfree(language_tags);\n}\n\n/*\n * Get an Accept-Language header which indicates user's preferred languages.\n *\n * Examples:\n *   LANGUAGE= -> \"\"\n *   LANGUAGE=ko:en -> \"Accept-Language: ko, en; q=0.9, *; q=0.1\"\n *   LANGUAGE=ko_KR.UTF-8:sr@latin -> \"Accept-Language: ko-KR, sr; q=0.9, *; q=0.1\"\n *   LANGUAGE=ko LANG=en_US.UTF-8 -> \"Accept-Language: ko, *; q=0.1\"\n *   LANGUAGE= LANG=en_US.UTF-8 -> \"Accept-Language: en-US, *; q=0.1\"\n *   LANGUAGE= LANG=C -> \"\"\n */\nstatic const char *get_accept_language(void)\n{\n\tif (!cached_accept_language) {\n\t\tstruct strbuf buf = STRBUF_INIT;\n\t\twrite_accept_language(&buf);\n\t\tif (buf.len > 0)\n\t\t\tcached_accept_language = strbuf_detach(&buf, NULL);\n\t}\n\n\treturn cached_accept_language;\n}\n\n/* http_request() targets */\n#define HTTP_REQUEST_STRBUF\t0\n#define HTTP_REQUEST_FILE\t1\n\nstatic int http_request(const char *url,\n\t\t\tvoid *result, int target,\n\t\t\tconst struct http_get_options *options)\n{\n\tstruct active_request_slot *slot;\n\tstruct slot_results results;\n\tstruct curl_slist *headers = NULL;\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *accept_language;\n\tint ret;\n\n\tslot = get_active_slot();\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPGET, 1);\n\n\tif (result == NULL) {\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_NOBODY, 1);\n\t} else {\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_NOBODY, 0);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_FILE, result);\n\n\t\tif (target == HTTP_REQUEST_FILE) {\n\t\t\tlong posn = ftell(result);\n\t\t\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION,\n\t\t\t\t\t fwrite);\n\t\t\tif (posn > 0) {\n\t\t\t\tstrbuf_addf(&buf, \"Range: bytes=%ld-\", posn);\n\t\t\t\theaders = curl_slist_append(headers, buf.buf);\n\t\t\t\tstrbuf_reset(&buf);\n\t\t\t}\n\t\t} else\n\t\t\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION,\n\t\t\t\t\t fwrite_buffer);\n\t}\n\n\taccept_language = get_accept_language();\n\n\tif (accept_language)\n\t\theaders = curl_slist_append(headers, accept_language);\n\n\tstrbuf_addstr(&buf, \"Pragma:\");\n\tif (options && options->no_cache)\n\t\tstrbuf_addstr(&buf, \" no-cache\");\n\tif (options && options->keep_error)\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_FAILONERROR, 0);\n\n\theaders = curl_slist_append(headers, buf.buf);\n\n\tcurl_easy_setopt(slot->curl, CURLOPT_URL, url);\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, headers);\n\tcurl_easy_setopt(slot->curl, CURLOPT_ENCODING, \"gzip\");\n\n\tret = run_one_slot(slot, &results);\n\n\tif (options && options->content_type) {\n\t\tstruct strbuf raw = STRBUF_INIT;\n\t\tcurlinfo_strbuf(slot->curl, CURLINFO_CONTENT_TYPE, &raw);\n\t\textract_content_type(&raw, options->content_type,\n\t\t\t\t     options->charset);\n\t\tstrbuf_release(&raw);\n\t}\n\n\tif (options && options->effective_url)\n\t\tcurlinfo_strbuf(slot->curl, CURLINFO_EFFECTIVE_URL,\n\t\t\t\toptions->effective_url);\n\n\tcurl_slist_free_all(headers);\n\tstrbuf_release(&buf);\n\n\treturn ret;\n}\n\n/*\n * Update the \"base\" url to a more appropriate value, as deduced by\n * redirects seen when requesting a URL starting with \"url\".\n *\n * The \"asked\" parameter is a URL that we asked curl to access, and must begin\n * with \"base\".\n *\n * The \"got\" parameter is the URL that curl reported to us as where we ended\n * up.\n *\n * Returns 1 if we updated the base url, 0 otherwise.\n *\n * Our basic strategy is to compare \"base\" and \"asked\" to find the bits\n * specific to our request. We then strip those bits off of \"got\" to yield the\n * new base. So for example, if our base is \"http://example.com/foo.git\",\n * and we ask for \"http://example.com/foo.git/info/refs\", we might end up\n * with \"https://other.example.com/foo.git/info/refs\". We would want the\n * new URL to become \"https://other.example.com/foo.git\".\n *\n * Note that this assumes a sane redirect scheme. It's entirely possible\n * in the example above to end up at a URL that does not even end in\n * \"info/refs\".  In such a case we simply punt, as there is not much we can\n * do (and such a scheme is unlikely to represent a real git repository,\n * which means we are likely about to abort anyway).\n */\nstatic int update_url_from_redirect(struct strbuf *base,\n\t\t\t\t    const char *asked,\n\t\t\t\t    const struct strbuf *got)\n{\n\tconst char *tail;\n\tsize_t tail_len;\n\n\tif (!strcmp(asked, got->buf))\n\t\treturn 0;\n\n\tif (!skip_prefix(asked, base->buf, &tail))\n\t\tdie(\"BUG: update_url_from_redirect: %s is not a superset of %s\",\n\t\t    asked, base->buf);\n\n\ttail_len = strlen(tail);\n\n\tif (got->len < tail_len ||\n\t    strcmp(tail, got->buf + got->len - tail_len))\n\t\treturn 0; /* insane redirect scheme */\n\n\tstrbuf_reset(base);\n\tstrbuf_add(base, got->buf, got->len - tail_len);\n\treturn 1;\n}\n\nstatic int http_request_reauth(const char *url,\n\t\t\t       void *result, int target,\n\t\t\t       struct http_get_options *options)\n{\n\tint ret = http_request(url, result, target, options);\n\n\tif (options && options->effective_url && options->base_url) {\n\t\tif (update_url_from_redirect(options->base_url,\n\t\t\t\t\t     url, options->effective_url)) {\n\t\t\tcredential_from_url(&http_auth, options->base_url->buf);\n\t\t\turl = options->effective_url->buf;\n\t\t}\n\t}\n\n\tif (ret != HTTP_REAUTH)\n\t\treturn ret;\n\n\t/*\n\t * If we are using KEEP_ERROR, the previous request may have\n\t * put cruft into our output stream; we should clear it out before\n\t * making our next request. We only know how to do this for\n\t * the strbuf case, but that is enough to satisfy current callers.\n\t */\n\tif (options && options->keep_error) {\n\t\tswitch (target) {\n\t\tcase HTTP_REQUEST_STRBUF:\n\t\t\tstrbuf_reset(result);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdie(\"BUG: HTTP_KEEP_ERROR is only supported with strbufs\");\n\t\t}\n\t}\n\n\tcredential_fill(&http_auth);\n\n\treturn http_request(url, result, target, options);\n}\n\nint http_get_strbuf(const char *url,\n\t\t    struct strbuf *result,\n\t\t    struct http_get_options *options)\n{\n\treturn http_request_reauth(url, result, HTTP_REQUEST_STRBUF, options);\n}\n\n/*\n * Downloads a URL and stores the result in the given file.\n *\n * If a previous interrupted download is detected (i.e. a previous temporary\n * file is still around) the download is resumed.\n */\nstatic int http_get_file(const char *url, const char *filename,\n\t\t\t struct http_get_options *options)\n{\n\tint ret;\n\tstruct strbuf tmpfile = STRBUF_INIT;\n\tFILE *result;\n\n\tstrbuf_addf(&tmpfile, \"%s.temp\", filename);\n\tresult = fopen(tmpfile.buf, \"a\");\n\tif (!result) {\n\t\terror(\"Unable to open local file %s\", tmpfile.buf);\n\t\tret = HTTP_ERROR;\n\t\tgoto cleanup;\n\t}\n\n\tret = http_request_reauth(url, result, HTTP_REQUEST_FILE, options);\n\tfclose(result);\n\n\tif (ret == HTTP_OK && move_temp_to_file(tmpfile.buf, filename))\n\t\tret = HTTP_ERROR;\ncleanup:\n\tstrbuf_release(&tmpfile);\n\treturn ret;\n}\n\nint http_fetch_ref(const char *base, struct ref *ref)\n{\n\tstruct http_get_options options = {0};\n\tchar *url;\n\tstruct strbuf buffer = STRBUF_INIT;\n\tint ret = -1;\n\n\toptions.no_cache = 1;\n\n\turl = quote_ref_url(base, ref->name);\n\tif (http_get_strbuf(url, &buffer, &options) == HTTP_OK) {\n\t\tstrbuf_rtrim(&buffer);\n\t\tif (buffer.len == 40)\n\t\t\tret = get_sha1_hex(buffer.buf, ref->old_sha1);\n\t\telse if (starts_with(buffer.buf, \"ref: \")) {\n\t\t\tref->symref = xstrdup(buffer.buf + 5);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tstrbuf_release(&buffer);\n\tfree(url);\n\treturn ret;\n}\n\n/* Helpers for fetching packs */\nstatic char *fetch_pack_index(unsigned char *sha1, const char *base_url)\n{\n\tchar *url, *tmp;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tif (http_is_verbose)\n\t\tfprintf(stderr, \"Getting index for pack %s\\n\", sha1_to_hex(sha1));\n\n\tend_url_with_slash(&buf, base_url);\n\tstrbuf_addf(&buf, \"objects/pack/pack-%s.idx\", sha1_to_hex(sha1));\n\turl = strbuf_detach(&buf, NULL);\n\n\tstrbuf_addf(&buf, \"%s.temp\", sha1_pack_index_name(sha1));\n\ttmp = strbuf_detach(&buf, NULL);\n\n\tif (http_get_file(url, tmp, NULL) != HTTP_OK) {\n\t\terror(\"Unable to get pack index %s\", url);\n\t\tfree(tmp);\n\t\ttmp = NULL;\n\t}\n\n\tfree(url);\n\treturn tmp;\n}\n\nstatic int fetch_and_setup_pack_index(struct packed_git **packs_head,\n\tunsigned char *sha1, const char *base_url)\n{\n\tstruct packed_git *new_pack;\n\tchar *tmp_idx = NULL;\n\tint ret;\n\n\tif (has_pack_index(sha1)) {\n\t\tnew_pack = parse_pack_index(sha1, NULL);\n\t\tif (!new_pack)\n\t\t\treturn -1; /* parse_pack_index() already issued error message */\n\t\tgoto add_pack;\n\t}\n\n\ttmp_idx = fetch_pack_index(sha1, base_url);\n\tif (!tmp_idx)\n\t\treturn -1;\n\n\tnew_pack = parse_pack_index(sha1, tmp_idx);\n\tif (!new_pack) {\n\t\tunlink(tmp_idx);\n\t\tfree(tmp_idx);\n\n\t\treturn -1; /* parse_pack_index() already issued error message */\n\t}\n\n\tret = verify_pack_index(new_pack);\n\tif (!ret) {\n\t\tclose_pack_index(new_pack);\n\t\tret = move_temp_to_file(tmp_idx, sha1_pack_index_name(sha1));\n\t}\n\tfree(tmp_idx);\n\tif (ret)\n\t\treturn -1;\n\nadd_pack:\n\tnew_pack->next = *packs_head;\n\t*packs_head = new_pack;\n\treturn 0;\n}\n\nint http_get_info_packs(const char *base_url, struct packed_git **packs_head)\n{\n\tstruct http_get_options options = {0};\n\tint ret = 0, i = 0;\n\tchar *url, *data;\n\tstruct strbuf buf = STRBUF_INIT;\n\tunsigned char sha1[20];\n\n\tend_url_with_slash(&buf, base_url);\n\tstrbuf_addstr(&buf, \"objects/info/packs\");\n\turl = strbuf_detach(&buf, NULL);\n\n\toptions.no_cache = 1;\n\tret = http_get_strbuf(url, &buf, &options);\n\tif (ret != HTTP_OK)\n\t\tgoto cleanup;\n\n\tdata = buf.buf;\n\twhile (i < buf.len) {\n\t\tswitch (data[i]) {\n\t\tcase 'P':\n\t\t\ti++;\n\t\t\tif (i + 52 <= buf.len &&\n\t\t\t    starts_with(data + i, \" pack-\") &&\n\t\t\t    starts_with(data + i + 46, \".pack\\n\")) {\n\t\t\t\tget_sha1_hex(data + i + 6, sha1);\n\t\t\t\tfetch_and_setup_pack_index(packs_head, sha1,\n\t\t\t\t\t\t      base_url);\n\t\t\t\ti += 51;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\twhile (i < buf.len && data[i] != '\\n')\n\t\t\t\ti++;\n\t\t}\n\t\ti++;\n\t}\n\ncleanup:\n\tfree(url);\n\treturn ret;\n}\n\nvoid release_http_pack_request(struct http_pack_request *preq)\n{\n\tif (preq->packfile != NULL) {\n\t\tfclose(preq->packfile);\n\t\tpreq->packfile = NULL;\n\t}\n\tif (preq->range_header != NULL) {\n\t\tcurl_slist_free_all(preq->range_header);\n\t\tpreq->range_header = NULL;\n\t}\n\tpreq->slot = NULL;\n\tfree(preq->url);\n}\n\nint finish_http_pack_request(struct http_pack_request *preq)\n{\n\tstruct packed_git **lst;\n\tstruct packed_git *p = preq->target;\n\tchar *tmp_idx;\n\tstruct child_process ip = CHILD_PROCESS_INIT;\n\tconst char *ip_argv[8];\n\n\tclose_pack_index(p);\n\n\tfclose(preq->packfile);\n\tpreq->packfile = NULL;\n\n\tlst = preq->lst;\n\twhile (*lst != p)\n\t\tlst = &((*lst)->next);\n\t*lst = (*lst)->next;\n\n\ttmp_idx = xstrdup(preq->tmpfile);\n\tstrcpy(tmp_idx + strlen(tmp_idx) - strlen(\".pack.temp\"),\n\t       \".idx.temp\");\n\n\tip_argv[0] = \"index-pack\";\n\tip_argv[1] = \"-o\";\n\tip_argv[2] = tmp_idx;\n\tip_argv[3] = preq->tmpfile;\n\tip_argv[4] = NULL;\n\n\tip.argv = ip_argv;\n\tip.git_cmd = 1;\n\tip.no_stdin = 1;\n\tip.no_stdout = 1;\n\n\tif (run_command(&ip)) {\n\t\tunlink(preq->tmpfile);\n\t\tunlink(tmp_idx);\n\t\tfree(tmp_idx);\n\t\treturn -1;\n\t}\n\n\tunlink(sha1_pack_index_name(p->sha1));\n\n\tif (move_temp_to_file(preq->tmpfile, sha1_pack_name(p->sha1))\n\t || move_temp_to_file(tmp_idx, sha1_pack_index_name(p->sha1))) {\n\t\tfree(tmp_idx);\n\t\treturn -1;\n\t}\n\n\tinstall_packed_git(p);\n\tfree(tmp_idx);\n\treturn 0;\n}\n\nstruct http_pack_request *new_http_pack_request(\n\tstruct packed_git *target, const char *base_url)\n{\n\tlong prev_posn = 0;\n\tchar range[RANGE_HEADER_SIZE];\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct http_pack_request *preq;\n\n\tpreq = xcalloc(1, sizeof(*preq));\n\tpreq->target = target;\n\n\tend_url_with_slash(&buf, base_url);\n\tstrbuf_addf(&buf, \"objects/pack/pack-%s.pack\",\n\t\tsha1_to_hex(target->sha1));\n\tpreq->url = strbuf_detach(&buf, NULL);\n\n\tsnprintf(preq->tmpfile, sizeof(preq->tmpfile), \"%s.temp\",\n\t\tsha1_pack_name(target->sha1));\n\tpreq->packfile = fopen(preq->tmpfile, \"a\");\n\tif (!preq->packfile) {\n\t\terror(\"Unable to open local file %s for pack\",\n\t\t      preq->tmpfile);\n\t\tgoto abort;\n\t}\n\n\tpreq->slot = get_active_slot();\n\tcurl_easy_setopt(preq->slot->curl, CURLOPT_FILE, preq->packfile);\n\tcurl_easy_setopt(preq->slot->curl, CURLOPT_WRITEFUNCTION, fwrite);\n\tcurl_easy_setopt(preq->slot->curl, CURLOPT_URL, preq->url);\n\tcurl_easy_setopt(preq->slot->curl, CURLOPT_HTTPHEADER,\n\t\tno_pragma_header);\n\n\t/*\n\t * If there is data present from a previous transfer attempt,\n\t * resume where it left off\n\t */\n\tprev_posn = ftell(preq->packfile);\n\tif (prev_posn>0) {\n\t\tif (http_is_verbose)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Resuming fetch of pack %s at byte %ld\\n\",\n\t\t\t\tsha1_to_hex(target->sha1), prev_posn);\n\t\tsprintf(range, \"Range: bytes=%ld-\", prev_posn);\n\t\tpreq->range_header = curl_slist_append(NULL, range);\n\t\tcurl_easy_setopt(preq->slot->curl, CURLOPT_HTTPHEADER,\n\t\t\tpreq->range_header);\n\t}\n\n\treturn preq;\n\nabort:\n\tfree(preq->url);\n\tfree(preq);\n\treturn NULL;\n}\n\n/* Helpers for fetching objects (loose) */\nstatic size_t fwrite_sha1_file(char *ptr, size_t eltsize, size_t nmemb,\n\t\t\t       void *data)\n{\n\tunsigned char expn[4096];\n\tsize_t size = eltsize * nmemb;\n\tint posn = 0;\n\tstruct http_object_request *freq =\n\t\t(struct http_object_request *)data;\n\tdo {\n\t\tssize_t retval = xwrite(freq->localfile,\n\t\t\t\t\t(char *) ptr + posn, size - posn);\n\t\tif (retval < 0)\n\t\t\treturn posn;\n\t\tposn += retval;\n\t} while (posn < size);\n\n\tfreq->stream.avail_in = size;\n\tfreq->stream.next_in = (void *)ptr;\n\tdo {\n\t\tfreq->stream.next_out = expn;\n\t\tfreq->stream.avail_out = sizeof(expn);\n\t\tfreq->zret = git_inflate(&freq->stream, Z_SYNC_FLUSH);\n\t\tgit_SHA1_Update(&freq->c, expn,\n\t\t\t\tsizeof(expn) - freq->stream.avail_out);\n\t} while (freq->stream.avail_in && freq->zret == Z_OK);\n\treturn size;\n}\n\nstruct http_object_request *new_http_object_request(const char *base_url,\n\tunsigned char *sha1)\n{\n\tchar *hex = sha1_to_hex(sha1);\n\tconst char *filename;\n\tchar prevfile[PATH_MAX];\n\tint prevlocal;\n\tchar prev_buf[PREV_BUF_SIZE];\n\tssize_t prev_read = 0;\n\tlong prev_posn = 0;\n\tchar range[RANGE_HEADER_SIZE];\n\tstruct curl_slist *range_header = NULL;\n\tstruct http_object_request *freq;\n\n\tfreq = xcalloc(1, sizeof(*freq));\n\thashcpy(freq->sha1, sha1);\n\tfreq->localfile = -1;\n\n\tfilename = sha1_file_name(sha1);\n\tsnprintf(freq->tmpfile, sizeof(freq->tmpfile),\n\t\t \"%s.temp\", filename);\n\n\tsnprintf(prevfile, sizeof(prevfile), \"%s.prev\", filename);\n\tunlink_or_warn(prevfile);\n\trename(freq->tmpfile, prevfile);\n\tunlink_or_warn(freq->tmpfile);\n\n\tif (freq->localfile != -1)\n\t\terror(\"fd leakage in start: %d\", freq->localfile);\n\tfreq->localfile = open(freq->tmpfile,\n\t\t\t       O_WRONLY | O_CREAT | O_EXCL, 0666);\n\t/*\n\t * This could have failed due to the \"lazy directory creation\";\n\t * try to mkdir the last path component.\n\t */\n\tif (freq->localfile < 0 && errno == ENOENT) {\n\t\tchar *dir = strrchr(freq->tmpfile, '/');\n\t\tif (dir) {\n\t\t\t*dir = 0;\n\t\t\tmkdir(freq->tmpfile, 0777);\n\t\t\t*dir = '/';\n\t\t}\n\t\tfreq->localfile = open(freq->tmpfile,\n\t\t\t\t       O_WRONLY | O_CREAT | O_EXCL, 0666);\n\t}\n\n\tif (freq->localfile < 0) {\n\t\terror(\"Couldn't create temporary file %s: %s\",\n\t\t      freq->tmpfile, strerror(errno));\n\t\tgoto abort;\n\t}\n\n\tgit_inflate_init(&freq->stream);\n\n\tgit_SHA1_Init(&freq->c);\n\n\tfreq->url = get_remote_object_url(base_url, hex, 0);\n\n\t/*\n\t * If a previous temp file is present, process what was already\n\t * fetched.\n\t */\n\tprevlocal = open(prevfile, O_RDONLY);\n\tif (prevlocal != -1) {\n\t\tdo {\n\t\t\tprev_read = xread(prevlocal, prev_buf, PREV_BUF_SIZE);\n\t\t\tif (prev_read>0) {\n\t\t\t\tif (fwrite_sha1_file(prev_buf,\n\t\t\t\t\t\t     1,\n\t\t\t\t\t\t     prev_read,\n\t\t\t\t\t\t     freq) == prev_read) {\n\t\t\t\t\tprev_posn += prev_read;\n\t\t\t\t} else {\n\t\t\t\t\tprev_read = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (prev_read > 0);\n\t\tclose(prevlocal);\n\t}\n\tunlink_or_warn(prevfile);\n\n\t/*\n\t * Reset inflate/SHA1 if there was an error reading the previous temp\n\t * file; also rewind to the beginning of the local file.\n\t */\n\tif (prev_read == -1) {\n\t\tmemset(&freq->stream, 0, sizeof(freq->stream));\n\t\tgit_inflate_init(&freq->stream);\n\t\tgit_SHA1_Init(&freq->c);\n\t\tif (prev_posn>0) {\n\t\t\tprev_posn = 0;\n\t\t\tlseek(freq->localfile, 0, SEEK_SET);\n\t\t\tif (ftruncate(freq->localfile, 0) < 0) {\n\t\t\t\terror(\"Couldn't truncate temporary file %s: %s\",\n\t\t\t\t\t  freq->tmpfile, strerror(errno));\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\t}\n\n\tfreq->slot = get_active_slot();\n\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_FILE, freq);\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_WRITEFUNCTION, fwrite_sha1_file);\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_ERRORBUFFER, freq->errorstr);\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_URL, freq->url);\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_HTTPHEADER, no_pragma_header);\n\n\t/*\n\t * If we have successfully processed data from a previous fetch\n\t * attempt, only fetch the data we don't already have.\n\t */\n\tif (prev_posn>0) {\n\t\tif (http_is_verbose)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Resuming fetch of object %s at byte %ld\\n\",\n\t\t\t\thex, prev_posn);\n\t\tsprintf(range, \"Range: bytes=%ld-\", prev_posn);\n\t\trange_header = curl_slist_append(range_header, range);\n\t\tcurl_easy_setopt(freq->slot->curl,\n\t\t\t\t CURLOPT_HTTPHEADER, range_header);\n\t}\n\n\treturn freq;\n\nabort:\n\tfree(freq->url);\n\tfree(freq);\n\treturn NULL;\n}\n\nvoid process_http_object_request(struct http_object_request *freq)\n{\n\tif (freq->slot == NULL)\n\t\treturn;\n\tfreq->curl_result = freq->slot->curl_result;\n\tfreq->http_code = freq->slot->http_code;\n\tfreq->slot = NULL;\n}\n\nint finish_http_object_request(struct http_object_request *freq)\n{\n\tstruct stat st;\n\n\tclose(freq->localfile);\n\tfreq->localfile = -1;\n\n\tprocess_http_object_request(freq);\n\n\tif (freq->http_code == 416) {\n\t\twarning(\"requested range invalid; we may already have all the data.\");\n\t} else if (freq->curl_result != CURLE_OK) {\n\t\tif (stat(freq->tmpfile, &st) == 0)\n\t\t\tif (st.st_size == 0)\n\t\t\t\tunlink_or_warn(freq->tmpfile);\n\t\treturn -1;\n\t}\n\n\tgit_inflate_end(&freq->stream);\n\tgit_SHA1_Final(freq->real_sha1, &freq->c);\n\tif (freq->zret != Z_STREAM_END) {\n\t\tunlink_or_warn(freq->tmpfile);\n\t\treturn -1;\n\t}\n\tif (hashcmp(freq->sha1, freq->real_sha1)) {\n\t\tunlink_or_warn(freq->tmpfile);\n\t\treturn -1;\n\t}\n\tfreq->rename =\n\t\tmove_temp_to_file(freq->tmpfile, sha1_file_name(freq->sha1));\n\n\treturn freq->rename;\n}\n\nvoid abort_http_object_request(struct http_object_request *freq)\n{\n\tunlink_or_warn(freq->tmpfile);\n\n\trelease_http_object_request(freq);\n}\n\nvoid release_http_object_request(struct http_object_request *freq)\n{\n\tif (freq->localfile != -1) {\n\t\tclose(freq->localfile);\n\t\tfreq->localfile = -1;\n\t}\n\tif (freq->url != NULL) {\n\t\tfree(freq->url);\n\t\tfreq->url = NULL;\n\t}\n\tif (freq->slot != NULL) {\n\t\tfreq->slot->callback_func = NULL;\n\t\tfreq->slot->callback_data = NULL;\n\t\trelease_active_slot(freq->slot);\n\t\tfreq->slot = NULL;\n\t}\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "007b29b8bb4cf27b619467d69a88ef5c79db282d",
  "sha1_ok": true,
  "size": 44643
}
