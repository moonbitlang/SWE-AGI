{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJxdW90ZS5oIgoKLyogSGVscCB0byBjb3B5IHRoZSB0aGluZyBwcm9wZXJseSBxdW90ZWQgZm9yIHRoZSBzaGVsbCBzYWZldHkuCiAqIGFueSBzaW5nbGUgcXVvdGUgaXMgcmVwbGFjZWQgd2l0aCAnXCcnLCBhbnkgZXhjbGFtYXRpb24gcG9pbnQKICogaXMgcmVwbGFjZWQgd2l0aCAnXCEnLCBhbmQgdGhlIHdob2xlIHRoaW5nIGlzIGVuY2xvc2VkIGluIGEKICoKICogRS5nLgogKiAgb3JpZ2luYWwgICAgIHNxX3F1b3RlICAgICByZXN1bHQKICogIG5hbWUgICAgID09PiBuYW1lICAgICAgPT0+ICduYW1lJwogKiAgYSBiICAgICAgPT0+IGEgYiAgICAgICA9PT4gJ2EgYicKICogIGEnYiAgICAgID09PiBhJ1wnJ2IgICAgPT0+ICdhJ1wnJ2InCiAqICBhIWIgICAgICA9PT4gYSdcISdiICAgID09PiAnYSdcISdiJwogKi8KI3VuZGVmIEVNSVQKI2RlZmluZSBFTUlUKHgpICggKCsrbGVuIDwgbikgJiYgKCpicCsrID0gKHgpKSApCgpzaXplX3Qgc3FfcXVvdGVfYnVmKGNoYXIgKmRzdCwgc2l6ZV90IG4sIGNvbnN0IGNoYXIgKnNyYykKewoJY2hhciBjOwoJY2hhciAqYnAgPSBkc3Q7CglzaXplX3QgbGVuID0gMDsKCglFTUlUKCdcJycpOwoJd2hpbGUgKChjID0gKnNyYysrKSkgewoJCWlmIChjID09ICdcJycgfHwgYyA9PSAnIScpIHsKCQkJRU1JVCgnXCcnKTsKCQkJRU1JVCgnXFwnKTsKCQkJRU1JVChjKTsKCQkJRU1JVCgnXCcnKTsKCQl9IGVsc2UgewoJCQlFTUlUKGMpOwoJCX0KCX0KCUVNSVQoJ1wnJyk7CgoJaWYgKCBuICkKCQkqYnAgPSAwOwoKCXJldHVybiBsZW47Cn0KCmNoYXIgKnNxX3F1b3RlKGNvbnN0IGNoYXIgKnNyYykKewoJY2hhciAqYnVmOwoJc2l6ZV90IGNudDsKCgljbnQgPSBzcV9xdW90ZV9idWYoTlVMTCwgMCwgc3JjKSArIDE7CglidWYgPSB4bWFsbG9jKGNudCk7CglzcV9xdW90ZV9idWYoYnVmLCBjbnQsIHNyYyk7CgoJcmV0dXJuIGJ1ZjsKfQoKLyoKICogQy1zdHlsZSBuYW1lIHF1b3RpbmcuCiAqCiAqIERvZXMgb25lIG9mIHRocmVlIHRoaW5nczoKICoKICogKDEpIGlmIG91dGJ1ZiBhbmQgb3V0ZnAgYXJlIGJvdGggTlVMTCwgaW5zcGVjdCB0aGUgaW5wdXQgbmFtZSBhbmQKICogICAgIGNvdW50cyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgYXJlIG5lZWRlZCB0byBob2xkIGNfc3R5bGUKICogICAgIHF1b3RlZCB2ZXJzaW9uIG9mIG5hbWUsIGNvdW50aW5nIHRoZSBkb3VibGUgcXVvdGVzIGFyb3VuZAogKiAgICAgaXQgYnV0IG5vdCB0ZXJtaW5hdGluZyBOVUwsIGFuZCByZXR1cm5zIGl0LiAgSG93ZXZlciwgaWYgbmFtZQogKiAgICAgZG9lcyBub3QgbmVlZCBjX3N0eWxlIHF1b3RpbmcsIGl0IHJldHVybnMgMC4KICoKICogKDIpIGlmIG91dGJ1ZiBpcyBub3QgTlVMTCwgaXQgbXVzdCBwb2ludCBhdCBhIGJ1ZmZlciBsYXJnZSBlbm91Z2gKICogICAgIHRvIGhvbGQgdGhlIGNfc3R5bGUgcXVvdGVkIHZlcnNpb24gb2YgbmFtZSwgZW5jbG9zaW5nIGRvdWJsZQogKiAgICAgcXVvdGVzLCBhbmQgdGVybWluYXRpbmcgTlVMLiAgRmlsbHMgb3V0YnVmIHdpdGggY19zdHlsZSBxdW90ZWQKICogICAgIHZlcnNpb24gb2YgbmFtZSBlbmNsb3NlZCBpbiBkb3VibGUtcXVvdGUgcGFpci4gIFJldHVybiB2YWx1ZQogKiAgICAgaXMgdW5kZWZpbmVkLgogKgogKiAoMykgaWYgb3V0ZnAgaXMgbm90IE5VTEwsIG91dHB1dHMgY19zdHlsZSBxdW90ZWQgdmVyc2lvbiBvZiBuYW1lLAogKiAgICAgYnV0IG5vdCBlbmNsb3NlZCBpbiBkb3VibGUtcXVvdGUgcGFpci4gIFJldHVybiB2YWx1ZSBpcyB1bmRlZmluZWQuCiAqLwoKaW50IHF1b3RlX2Nfc3R5bGUoY29uc3QgY2hhciAqbmFtZSwgY2hhciAqb3V0YnVmLCBGSUxFICpvdXRmcCwgaW50IG5vX2RxKQp7CiN1bmRlZiBFTUlUCiNkZWZpbmUgRU1JVChjKSBcCgkob3V0YnVmID8gKCpvdXRidWYrKyA9IChjKSkgOiBvdXRmcCA/IGZwdXRjKGMsIG91dGZwKSA6IChjb3VudCsrKSkKCiNkZWZpbmUgRU1JVFEoKSBFTUlUKCdcXCcpCgoJY29uc3QgY2hhciAqc3A7CglpbnQgY2gsIGNvdW50ID0gMCwgbmVlZHF1b3RlID0gMDsKCglpZiAoIW5vX2RxKQoJCUVNSVQoJyInKTsKCWZvciAoc3AgPSBuYW1lOyAoY2ggPSAqc3ArKyk7ICkgewoKCQlpZiAoKGNoIDwgJyAnKSB8fCAoY2ggPT0gJyInKSB8fCAoY2ggPT0gJ1xcJykgfHwKCQkgICAgKGNoID09IDAxNzcpKSB7CgkJCW5lZWRxdW90ZSA9IDE7CgkJCXN3aXRjaCAoY2gpIHsKCQkJY2FzZSAnXGEnOiBFTUlUUSgpOyBjaCA9ICdhJzsgYnJlYWs7CgkJCWNhc2UgJ1xiJzogRU1JVFEoKTsgY2ggPSAnYic7IGJyZWFrOwoJCQljYXNlICdcZic6IEVNSVRRKCk7IGNoID0gJ2YnOyBicmVhazsKCQkJY2FzZSAnXG4nOiBFTUlUUSgpOyBjaCA9ICduJzsgYnJlYWs7CgkJCWNhc2UgJ1xyJzogRU1JVFEoKTsgY2ggPSAncic7IGJyZWFrOwoJCQljYXNlICdcdCc6IEVNSVRRKCk7IGNoID0gJ3QnOyBicmVhazsKCQkJY2FzZSAnXHYnOiBFTUlUUSgpOyBjaCA9ICd2JzsgYnJlYWs7CgoJCQljYXNlICdcXCc6IC8qIGZhbGx0aHJ1ICovCgkJCWNhc2UgJyInOiBFTUlUUSgpOyBicmVhazsKCQkJY2FzZSAnICc6CgkJCQlicmVhazsKCQkJZGVmYXVsdDoKCQkJCS8qIG9jdGFsICovCgkJCQlFTUlUUSgpOwoJCQkJRU1JVCgoKGNoID4+IDYpICYgMDMpICsgJzAnKTsKCQkJCUVNSVQoKChjaCA+PiAzKSAmIDA3KSArICcwJyk7CgkJCQljaCA9IChjaCAmIDA3KSArICcwJzsKCQkJCWJyZWFrOwoJCQl9CgkJfQoJCUVNSVQoY2gpOwoJfQoJaWYgKCFub19kcSkKCQlFTUlUKCciJyk7CglpZiAob3V0YnVmKQoJCSpvdXRidWYgPSAwOwoKCXJldHVybiBuZWVkcXVvdGUgPyBjb3VudCA6IDA7Cn0KCi8qCiAqIEMtc3R5bGUgbmFtZSB1bnF1b3RpbmcuCiAqCiAqIFF1b3RlZCBzaG91bGQgcG9pbnQgYXQgdGhlIG9wZW5pbmcgZG91YmxlIHF1b3RlLiAgUmV0dXJucwogKiBhbiBhbGxvY2F0ZWQgbWVtb3J5IHRoYXQgaG9sZHMgdW5xdW90ZWQgbmFtZSwgd2hpY2ggdGhlIGNhbGxlcgogKiBzaG91bGQgZnJlZSB3aGVuIGRvbmUuICBVcGRhdGVzIGVuZHAgcG9pbnRlciB0byBwb2ludCBhdAogKiBvbmUgcGFzdCB0aGUgZW5kaW5nIGRvdWJsZSBxdW90ZSBpZiBnaXZlbi4KICovCgpjaGFyICp1bnF1b3RlX2Nfc3R5bGUoY29uc3QgY2hhciAqcXVvdGVkLCBjb25zdCBjaGFyICoqZW5kcCkKewoJY29uc3QgY2hhciAqc3A7CgljaGFyICpuYW1lID0gTlVMTCwgKm91dHAgPSBOVUxMOwoJaW50IGNvdW50ID0gMCwgY2gsIGFjOwoKI3VuZGVmIEVNSVQKI2RlZmluZSBFTUlUKGMpIChvdXRwID8gKCpvdXRwKysgPSAoYykpIDogKGNvdW50KyspKQoKCWlmICgqcXVvdGVkKysgIT0gJyInKQoJCXJldHVybiBOVUxMOwoKCXdoaWxlICgxKSB7CgkJLyogZmlyc3QgcGFzcyBjb3VudHMgYW5kIGFsbG9jYXRlcywgc2Vjb25kIHBhc3MgZmlsbHMgKi8KCQlmb3IgKHNwID0gcXVvdGVkOyAoY2ggPSAqc3ArKykgIT0gJyInOyApIHsKCQkJaWYgKGNoID09ICdcXCcpIHsKCQkJCXN3aXRjaCAoY2ggPSAqc3ArKykgewoJCQkJY2FzZSAnYSc6IGNoID0gJ1xhJzsgYnJlYWs7CgkJCQljYXNlICdiJzogY2ggPSAnXGInOyBicmVhazsKCQkJCWNhc2UgJ2YnOiBjaCA9ICdcZic7IGJyZWFrOwoJCQkJY2FzZSAnbic6IGNoID0gJ1xuJzsgYnJlYWs7CgkJCQljYXNlICdyJzogY2ggPSAnXHInOyBicmVhazsKCQkJCWNhc2UgJ3QnOiBjaCA9ICdcdCc7IGJyZWFrOwoJCQkJY2FzZSAndic6IGNoID0gJ1x2JzsgYnJlYWs7CgoJCQkJY2FzZSAnXFwnOiBjYXNlICciJzoKCQkJCQlicmVhazsgLyogdmVyYmF0aW0gKi8KCgkJCQljYXNlICcwJy4uLic3JzoKCQkJCQkvKiBvY3RhbCAqLwoJCQkJCWFjID0gKChjaCAtICcwJykgPDwgNik7CgkJCQkJaWYgKChjaCA9ICpzcCsrKSA8ICcwJyB8fCAnNycgPCBjaCkKCQkJCQkJcmV0dXJuIE5VTEw7CgkJCQkJYWMgfD0gKChjaCAtICcwJykgPDwgMyk7CgkJCQkJaWYgKChjaCA9ICpzcCsrKSA8ICcwJyB8fCAnNycgPCBjaCkKCQkJCQkJcmV0dXJuIE5VTEw7CgkJCQkJYWMgfD0gKGNoIC0gJzAnKTsKCQkJCQljaCA9IGFjOwoJCQkJCWJyZWFrOwoJCQkJZGVmYXVsdDoKCQkJCQlyZXR1cm4gTlVMTDsgLyogbWFsZm9ybWVkICovCgkJCQl9CgkJCX0KCQkJRU1JVChjaCk7CgkJfQoKCQlpZiAobmFtZSkgewoJCQkqb3V0cCA9IDA7CgkJCWlmIChlbmRwKQoJCQkJKmVuZHAgPSBzcDsKCQkJcmV0dXJuIG5hbWU7CgkJfQoJCW91dHAgPSBuYW1lID0geG1hbGxvYyhjb3VudCArIDEpOwoJfQp9Cgp2b2lkIHdyaXRlX25hbWVfcXVvdGVkKGNvbnN0IGNoYXIgKnByZWZpeCwgY29uc3QgY2hhciAqbmFtZSwKCQkgICAgICAgaW50IHF1b3RlLCBGSUxFICpvdXQpCnsKCWludCBuZWVkcXVvdGU7CgoJaWYgKCFxdW90ZSkgewoJbm9fcXVvdGU6CgkJaWYgKHByZWZpeCAmJiBwcmVmaXhbMF0pCgkJCWZwdXRzKHByZWZpeCwgb3V0KTsKCQlmcHV0cyhuYW1lLCBvdXQpOwoJCXJldHVybjsKCX0KCgluZWVkcXVvdGUgPSAwOwoJaWYgKHByZWZpeCAmJiBwcmVmaXhbMF0pCgkJbmVlZHF1b3RlID0gcXVvdGVfY19zdHlsZShwcmVmaXgsIE5VTEwsIE5VTEwsIDApOwoJaWYgKCFuZWVkcXVvdGUpCgkJbmVlZHF1b3RlID0gcXVvdGVfY19zdHlsZShuYW1lLCBOVUxMLCBOVUxMLCAwKTsKCWlmIChuZWVkcXVvdGUpIHsKCQlmcHV0YygnIicsIG91dCk7CgkJaWYgKHByZWZpeCAmJiBwcmVmaXhbMF0pCgkJCXF1b3RlX2Nfc3R5bGUocHJlZml4LCBOVUxMLCBvdXQsIDEpOwoJCXF1b3RlX2Nfc3R5bGUobmFtZSwgTlVMTCwgb3V0LCAxKTsKCQlmcHV0YygnIicsIG91dCk7Cgl9CgllbHNlCgkJZ290byBub19xdW90ZTsKfQo=",
    "text": "#include \"cache.h\"\n#include \"quote.h\"\n\n/* Help to copy the thing properly quoted for the shell safety.\n * any single quote is replaced with '\\'', any exclamation point\n * is replaced with '\\!', and the whole thing is enclosed in a\n *\n * E.g.\n *  original     sq_quote     result\n *  name     ==> name      ==> 'name'\n *  a b      ==> a b       ==> 'a b'\n *  a'b      ==> a'\\''b    ==> 'a'\\''b'\n *  a!b      ==> a'\\!'b    ==> 'a'\\!'b'\n */\n#undef EMIT\n#define EMIT(x) ( (++len < n) && (*bp++ = (x)) )\n\nsize_t sq_quote_buf(char *dst, size_t n, const char *src)\n{\n\tchar c;\n\tchar *bp = dst;\n\tsize_t len = 0;\n\n\tEMIT('\\'');\n\twhile ((c = *src++)) {\n\t\tif (c == '\\'' || c == '!') {\n\t\t\tEMIT('\\'');\n\t\t\tEMIT('\\\\');\n\t\t\tEMIT(c);\n\t\t\tEMIT('\\'');\n\t\t} else {\n\t\t\tEMIT(c);\n\t\t}\n\t}\n\tEMIT('\\'');\n\n\tif ( n )\n\t\t*bp = 0;\n\n\treturn len;\n}\n\nchar *sq_quote(const char *src)\n{\n\tchar *buf;\n\tsize_t cnt;\n\n\tcnt = sq_quote_buf(NULL, 0, src) + 1;\n\tbuf = xmalloc(cnt);\n\tsq_quote_buf(buf, cnt, src);\n\n\treturn buf;\n}\n\n/*\n * C-style name quoting.\n *\n * Does one of three things:\n *\n * (1) if outbuf and outfp are both NULL, inspect the input name and\n *     counts the number of bytes that are needed to hold c_style\n *     quoted version of name, counting the double quotes around\n *     it but not terminating NUL, and returns it.  However, if name\n *     does not need c_style quoting, it returns 0.\n *\n * (2) if outbuf is not NULL, it must point at a buffer large enough\n *     to hold the c_style quoted version of name, enclosing double\n *     quotes, and terminating NUL.  Fills outbuf with c_style quoted\n *     version of name enclosed in double-quote pair.  Return value\n *     is undefined.\n *\n * (3) if outfp is not NULL, outputs c_style quoted version of name,\n *     but not enclosed in double-quote pair.  Return value is undefined.\n */\n\nint quote_c_style(const char *name, char *outbuf, FILE *outfp, int no_dq)\n{\n#undef EMIT\n#define EMIT(c) \\\n\t(outbuf ? (*outbuf++ = (c)) : outfp ? fputc(c, outfp) : (count++))\n\n#define EMITQ() EMIT('\\\\')\n\n\tconst char *sp;\n\tint ch, count = 0, needquote = 0;\n\n\tif (!no_dq)\n\t\tEMIT('\"');\n\tfor (sp = name; (ch = *sp++); ) {\n\n\t\tif ((ch < ' ') || (ch == '\"') || (ch == '\\\\') ||\n\t\t    (ch == 0177)) {\n\t\t\tneedquote = 1;\n\t\t\tswitch (ch) {\n\t\t\tcase '\\a': EMITQ(); ch = 'a'; break;\n\t\t\tcase '\\b': EMITQ(); ch = 'b'; break;\n\t\t\tcase '\\f': EMITQ(); ch = 'f'; break;\n\t\t\tcase '\\n': EMITQ(); ch = 'n'; break;\n\t\t\tcase '\\r': EMITQ(); ch = 'r'; break;\n\t\t\tcase '\\t': EMITQ(); ch = 't'; break;\n\t\t\tcase '\\v': EMITQ(); ch = 'v'; break;\n\n\t\t\tcase '\\\\': /* fallthru */\n\t\t\tcase '\"': EMITQ(); break;\n\t\t\tcase ' ':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* octal */\n\t\t\t\tEMITQ();\n\t\t\t\tEMIT(((ch >> 6) & 03) + '0');\n\t\t\t\tEMIT(((ch >> 3) & 07) + '0');\n\t\t\t\tch = (ch & 07) + '0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tEMIT(ch);\n\t}\n\tif (!no_dq)\n\t\tEMIT('\"');\n\tif (outbuf)\n\t\t*outbuf = 0;\n\n\treturn needquote ? count : 0;\n}\n\n/*\n * C-style name unquoting.\n *\n * Quoted should point at the opening double quote.  Returns\n * an allocated memory that holds unquoted name, which the caller\n * should free when done.  Updates endp pointer to point at\n * one past the ending double quote if given.\n */\n\nchar *unquote_c_style(const char *quoted, const char **endp)\n{\n\tconst char *sp;\n\tchar *name = NULL, *outp = NULL;\n\tint count = 0, ch, ac;\n\n#undef EMIT\n#define EMIT(c) (outp ? (*outp++ = (c)) : (count++))\n\n\tif (*quoted++ != '\"')\n\t\treturn NULL;\n\n\twhile (1) {\n\t\t/* first pass counts and allocates, second pass fills */\n\t\tfor (sp = quoted; (ch = *sp++) != '\"'; ) {\n\t\t\tif (ch == '\\\\') {\n\t\t\t\tswitch (ch = *sp++) {\n\t\t\t\tcase 'a': ch = '\\a'; break;\n\t\t\t\tcase 'b': ch = '\\b'; break;\n\t\t\t\tcase 'f': ch = '\\f'; break;\n\t\t\t\tcase 'n': ch = '\\n'; break;\n\t\t\t\tcase 'r': ch = '\\r'; break;\n\t\t\t\tcase 't': ch = '\\t'; break;\n\t\t\t\tcase 'v': ch = '\\v'; break;\n\n\t\t\t\tcase '\\\\': case '\"':\n\t\t\t\t\tbreak; /* verbatim */\n\n\t\t\t\tcase '0'...'7':\n\t\t\t\t\t/* octal */\n\t\t\t\t\tac = ((ch - '0') << 6);\n\t\t\t\t\tif ((ch = *sp++) < '0' || '7' < ch)\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\tac |= ((ch - '0') << 3);\n\t\t\t\t\tif ((ch = *sp++) < '0' || '7' < ch)\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\tac |= (ch - '0');\n\t\t\t\t\tch = ac;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn NULL; /* malformed */\n\t\t\t\t}\n\t\t\t}\n\t\t\tEMIT(ch);\n\t\t}\n\n\t\tif (name) {\n\t\t\t*outp = 0;\n\t\t\tif (endp)\n\t\t\t\t*endp = sp;\n\t\t\treturn name;\n\t\t}\n\t\toutp = name = xmalloc(count + 1);\n\t}\n}\n\nvoid write_name_quoted(const char *prefix, const char *name,\n\t\t       int quote, FILE *out)\n{\n\tint needquote;\n\n\tif (!quote) {\n\tno_quote:\n\t\tif (prefix && prefix[0])\n\t\t\tfputs(prefix, out);\n\t\tfputs(name, out);\n\t\treturn;\n\t}\n\n\tneedquote = 0;\n\tif (prefix && prefix[0])\n\t\tneedquote = quote_c_style(prefix, NULL, NULL, 0);\n\tif (!needquote)\n\t\tneedquote = quote_c_style(name, NULL, NULL, 0);\n\tif (needquote) {\n\t\tfputc('\"', out);\n\t\tif (prefix && prefix[0])\n\t\t\tquote_c_style(prefix, NULL, out, 1);\n\t\tquote_c_style(name, NULL, out, 1);\n\t\tfputc('\"', out);\n\t}\n\telse\n\t\tgoto no_quote;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "009e69494b007fc7bfe590029c144d9ce41aa6b5",
  "sha1_ok": true,
  "size": 4847
}
