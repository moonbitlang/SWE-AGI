{
  "content": {
    "headers": [
      "tree 124dc5f73d06b1d009dc6c3852a424f8f8abb7c0",
      "parent 0d464a4e6a5a19bd8fbea1deae22d48d14dccb01",
      "author Patrick Steinhardt <ps@pks.im> 1711035592 +0100",
      "committer Junio C Hamano <gitster@pobox.com> 1711042341 -0700"
    ],
    "message": "reftable: fix tests being broken by NFS' delete-after-close semantics\n\nIt was reported that the reftable unit tests in t0032 fail with the\nfollowing assertion when running on top of NFS:\n\n    running test_reftable_stack_compaction_concurrent_clean\n    reftable/stack_test.c: 1063: failed assertion count_dir_entries(dir) == 2\n    Aborted\n\nSetting a breakpoint immediately before the assertion in fact shows the\nfollowing list of files:\n\n    ./stack_test-1027.QJBpnd\n    ./stack_test-1027.QJBpnd/0x000000000001-0x000000000003-dad7ac80.ref\n    ./stack_test-1027.QJBpnd/.nfs000000000001729f00001e11\n    ./stack_test-1027.QJBpnd/tables.list\n\nNote the weird \".nfs*\" file? This file is maintained by NFS clients in\norder to emulate delete-after-last-close semantics that we rely on in\nthe reftable code [1]. Instead of unlinking the file right away and\nkeeping it open in the client, the NFS client will rename it to \".nfs*\"\nand then delete that temporary file when the last reference to it gets\ndropped. Quoting the NFS FAQ:\n\n    > D2. What is a \"silly rename\"? Why do these .nfsXXXXX files keep\n    > showing up?\n    >\n    > A. Unix applications often open a scratch file and then unlink it.\n    > They do this so that the file is not visible in the file system name\n    > space to any other applications, and so that the system will\n    > automatically clean up (delete) the file when the application exits.\n    > This is known as \"delete on last close\", and is a tradition among\n    > Unix applications.\n    >\n    > Because of the design of the NFS protocol, there is no way for a\n    > file to be deleted from the name space but still remain in use by an\n    > application. Thus NFS clients have to emulate this using what\n    > already exists in the protocol. If an open file is unlinked, an NFS\n    > client renames it to a special name that looks like \".nfsXXXXX\".\n    > This \"hides\" the file while it remains in use. This is known as a\n    > \"silly rename.\" Note that NFS servers have nothing to do with this\n    > behavior.\n\nThis of course throws off the assertion that we got exactly two files in\nthat directory.\n\nThe test in question triggers this behaviour by holding two open file\ndescriptors to the \"tables.list\" file. One of the references is because\nwe are about to append to the stack, whereas the other reference is\nbecause we want to compact it. As the compaction has just finished we\nalready rewrote \"tables.list\" to point to the new contents, but the\nother file descriptor pointing to the old version is still open. Thus we\ntrigger the delete-after-last-close emulation.\n\nFurthermore, it was reported that this behaviour only triggers with\n4f36b8597c (reftable/stack: fix race in up-to-date check, 2024-01-18).\nThis is expected as well because it is the first point in time where we\nactually keep the \"tables.list\" file descriptor open for the stat cache.\n\nFix this bug by skipping over any files that start with a leading dot\nwhen counting files. While we could explicitly check for a prefix of\n\".nfs\", other network file systems like SMB for example do the same\ntrickery but with a \".smb\" prefix. In any case though, this loosening of\nthe assertion should be fine given that the reftable library would never\nwrite files with leading dots by itself.\n\n[1]: https://nfs.sourceforge.net/#faq_d2\n\nReported-by: Chuck Lever <chuck.lever@oracle.com>\nSigned-off-by: Patrick Steinhardt <ps@pks.im>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>\n",
    "type": "commit"
  },
  "kind": "commit",
  "oid": "0068aa794696188d3c9bea62804780d44bee824f",
  "sha1_ok": true,
  "size": 3668
}
