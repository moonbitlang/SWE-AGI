{
  "content": {
    "base64": "IyBUZXN0IGZyYW1ld29yayBmb3IgZ2l0LiAgU2VlIHQvUkVBRE1FIGZvciB1c2FnZS4KIwojIENvcHlyaWdodCAoYykgMjAwNSBKdW5pbyBDIEhhbWFubwojCiMgVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkKIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieQojIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDIgb2YgdGhlIExpY2Vuc2UsIG9yCiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi4KIwojIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLAojIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mCiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZQojIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuCiMKIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQojIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiAgSWYgbm90LCBzZWUgaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLyAuCgojIFRlc3QgdGhlIGJpbmFyaWVzIHdlIGhhdmUganVzdCBidWlsdC4gIFRoZSB0ZXN0cyBhcmUga2VwdCBpbgojIHQvIHN1YmRpcmVjdG9yeSBhbmQgYXJlIHJ1biBpbiAndHJhc2ggZGlyZWN0b3J5JyBzdWJkaXJlY3RvcnkuCmlmIHRlc3QgLXogIiRURVNUX0RJUkVDVE9SWSIKdGhlbgoJIyBlbnN1cmUgdGhhdCBURVNUX0RJUkVDVE9SWSBpcyBhbiBhYnNvbHV0ZSBwYXRoIHNvIHRoYXQgaXQKCSMgaXMgdmFsaWQgZXZlbiBpZiB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSBpcyBjaGFuZ2VkCglURVNUX0RJUkVDVE9SWT0kKHB3ZCkKZWxzZQoJIyBUaGUgVEVTVF9ESVJFQ1RPUlkgd2lsbCBhbHdheXMgYmUgdGhlIHBhdGggdG8gdGhlICJ0IgoJIyBkaXJlY3RvcnkgaW4gdGhlIGdpdC5naXQgY2hlY2tvdXQuIFRoaXMgaXMgb3ZlcnJpZGRlbiBieQoJIyBlLmcuIHQvbGliLXN1YnRlc3Quc2gsIGJ1dCBvbmx5IGJlY2F1c2UgaXRzICQocHdkKSBpcwoJIyBkaWZmZXJlbnQuIFRob3NlIHRlc3RzIHN0aWxsIHNldCAiJFRFU1RfRElSRUNUT1JZIiB0byB0aGUKCSMgc2FtZSBwYXRoLgoJIwoJIyBTZWUgdXNlIG9mICIkR0lUX0JVSUxEX0RJUiIgYW5kICIkVEVTVF9ESVJFQ1RPUlkiIGJlbG93IGZvcgoJIyBoYXJkIGFzc3VtcHRpb25zIGFib3V0ICIkR0lUX0JVSUxEX0RJUi90IiBleGlzdGluZyBhbmQgYmVpbmcKCSMgdGhlICIkVEVTVF9ESVJFQ1RPUlkiLCBhbmQgZS5nLiAiJFRFU1RfRElSRUNUT1JZL2hlbHBlciIKCSMgbmVlZGluZyB0byBleGlzdC4KCVRFU1RfRElSRUNUT1JZPSQoY2QgIiRURVNUX0RJUkVDVE9SWSIgJiYgcHdkKSB8fCBleGl0IDEKZmkKaWYgdGVzdCAteiAiJFRFU1RfT1VUUFVUX0RJUkVDVE9SWSIKdGhlbgoJIyBTaW1pbGFybHksIG92ZXJyaWRlIHRoaXMgdG8gc3RvcmUgdGhlIHRlc3QtcmVzdWx0cyBzdWJkaXIKCSMgZWxzZXdoZXJlCglURVNUX09VVFBVVF9ESVJFQ1RPUlk9JFRFU1RfRElSRUNUT1JZCmZpCkdJVF9CVUlMRF9ESVI9IiR7VEVTVF9ESVJFQ1RPUlklL3R9IgppZiB0ZXN0ICIkVEVTVF9ESVJFQ1RPUlkiID0gIiRHSVRfQlVJTERfRElSIgp0aGVuCgllY2hvICJQQU5JQzogUnVubmluZyBpbiBhICRURVNUX0RJUkVDVE9SWSB0aGF0IGRvZXNuJ3QgZW5kIGluICcvdCc/IiA+JjIKCWV4aXQgMQpmaQppZiB0ZXN0IC1mICIkR0lUX0JVSUxEX0RJUi9HSVQtQlVJTEQtRElSIgp0aGVuCglHSVRfQlVJTERfRElSPSIkKGNhdCAiJEdJVF9CVUlMRF9ESVIvR0lULUJVSUxELURJUiIpIiB8fCBleGl0IDEKCSMgT24gV2luZG93cywgd2UgbXVzdCBjb252ZXJ0IFdpbmRvd3MgcGF0aHMgbGVzdCB0aGV5IGNvbnRhaW4gYSBjb2xvbgoJY2FzZSAiJCh1bmFtZSAtcykiIGluCgkqTUlOR1cqKQoJCUdJVF9CVUlMRF9ESVI9IiQoY3lncGF0aCAtYXUgIiRHSVRfQlVJTERfRElSIikiCgkJOzsKCWVzYWMKZmkKCiMgUHJlcGVuZCBhIHN0cmluZyB0byBhIFZBUiB1c2luZyBhbiBhcmJpdHJhcnkgIjoiIGRlbGltaXRlciwgbm90CiMgYWRkaW5nIHRoZSBkZWxpbWl0ZXIgaWYgVkFSIG9yIFZBTFVFIGlzIGVtcHR5LiBJLmUuIGEgZ2VuZXJhbGl6ZWQ6CiMKIwlWQVI9JDEke1ZBUjorJHsxOiskMn0kVkFSfQojCiMgVXNhZ2UgKHVzaW5nICI6IiBhcyB0aGUgJDIgZGVsaW1pdGVyKToKIwojCXByZXBlbmRfdmFyIFZBUiA6IFZBTFVFCnByZXBlbmRfdmFyICgpIHsKCWV2YWwgIiQxPVwiJDNcJHskMTorJHszOiskMn1cJCQxfVwiIgp9CgojIElmIFtBTF1TQU4gaXMgaW4gZWZmZWN0IHdlIHdhbnQgdG8gYWJvcnQgc28gdGhhdCB3ZSBub3RpY2UKIyBwcm9ibGVtcy4gVGhlIEdJVF9TQU5fT1BUSU9OUyB2YXJpYWJsZSBjYW4gYmUgdXNlZCB0byBzZXQgY29tbW9uCiMgZGVmYXVsdHMgc2hhcmVkIGJldHdlZW4gW0FMXVNBTl9PUFRJT05TLgpwcmVwZW5kX3ZhciBHSVRfU0FOX09QVElPTlMgOiBhYm9ydF9vbl9lcnJvcj0xCnByZXBlbmRfdmFyIEdJVF9TQU5fT1BUSU9OUyA6IHN0cmlwX3BhdGhfcHJlZml4PSIkR0lUX0JVSUxEX0RJUi8iCgojIElmIHdlIHdlcmUgYnVpbHQgd2l0aCBBU0FOLCBpdCBtYXkgY29tcGxhaW4gYWJvdXQgbGVha3MKIyBvZiBwcm9ncmFtLWxpZmV0aW1lIHZhcmlhYmxlcy4gRGlzYWJsZSBpdCBieSBkZWZhdWx0IHRvIGxvd2VyCiMgdGhlIG5vaXNlIGxldmVsLiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBhdCB0aGUgc3RhcnQgb2YgdGhlIHNjcmlwdCwKIyBiZWZvcmUgd2UgZXZlbiBkbyBvdXIgImRpZCB3ZSBidWlsZCBnaXQgeWV0IiBjaGVjayAoc2luY2Ugd2UgZG9uJ3QKIyB3YW50IHRoYXQgb25lIHRvIGNvbXBsYWluIHRvIHN0ZGVycikuCnByZXBlbmRfdmFyIEFTQU5fT1BUSU9OUyA6ICRHSVRfU0FOX09QVElPTlMKcHJlcGVuZF92YXIgQVNBTl9PUFRJT05TIDogZGV0ZWN0X2xlYWtzPTAKZXhwb3J0IEFTQU5fT1BUSU9OUwoKcHJlcGVuZF92YXIgTFNBTl9PUFRJT05TIDogJEdJVF9TQU5fT1BUSU9OUwpwcmVwZW5kX3ZhciBMU0FOX09QVElPTlMgOiBmYXN0X3Vud2luZF9vbl9tYWxsb2M9MApleHBvcnQgTFNBTl9PUFRJT05TCgppZiB0ZXN0ICEgLWYgIiRHSVRfQlVJTERfRElSIi9HSVQtQlVJTEQtT1BUSU9OUwp0aGVuCgllY2hvID4mMiAnZXJyb3I6IEdJVC1CVUlMRC1PUFRJT05TIG1pc3NpbmcgKGhhcyBHaXQgYmVlbiBidWlsdD8pLicKCWV4aXQgMQpmaQouICIkR0lUX0JVSUxEX0RJUiIvR0lULUJVSUxELU9QVElPTlMKZXhwb3J0IFBFUkxfUEFUSCBTSEVMTF9QQVRICgojIEluIHQwMDAwLCB3ZSBuZWVkIHRvIG92ZXJyaWRlIHRlc3QgZGlyZWN0b3JpZXMgb2YgbmVzdGVkIHRlc3RjYXNlcy4gSW4gY2FzZQojIHRoZSBkZXZlbG9wZXIgaGFzIFRFU1RfT1VUUFVUX0RJUkVDVE9SWSBwYXJ0IG9mIGhpcyBidWlsZCBvcHRpb25zLCB0aGVuIHdlJ2QKIyByZXNldCB0aGlzIHZhbHVlIHRvIGluc3RlYWQgY29udGFpbiB3aGF0IHRoZSBkZXZlbG9wZXIgaGFzIHNwZWNpZmllZC4gV2UgdGh1cwojIGhhdmUgdGhpcyBrbm9iIHRvIGFsbG93IG92ZXJyaWRpbmcgdGhlIGRpcmVjdG9yeS4KaWYgdGVzdCAtbiAiJHtURVNUX09VVFBVVF9ESVJFQ1RPUllfT1ZFUlJJREV9Igp0aGVuCglURVNUX09VVFBVVF9ESVJFQ1RPUlk9IiR7VEVTVF9PVVRQVVRfRElSRUNUT1JZX09WRVJSSURFfSIKZmkKCiMgRGlzYWxsb3cgdGhlIHVzZSBvZiBhYmJyZXZpYXRlZCBvcHRpb25zIGluIHRoZSB0ZXN0IHN1aXRlIGJ5IGRlZmF1bHQKaWYgdGVzdCAteiAiJHtHSVRfVEVTVF9ESVNBTExPV19BQkJSRVZJQVRFRF9PUFRJT05TfSIKdGhlbgoJR0lUX1RFU1RfRElTQUxMT1dfQUJCUkVWSUFURURfT1BUSU9OUz10cnVlCglleHBvcnQgR0lUX1RFU1RfRElTQUxMT1dfQUJCUkVWSUFURURfT1BUSU9OUwpmaQoKIyBFeHBsaWNpdGx5IHNldCB0aGUgZGVmYXVsdCBicmFuY2ggbmFtZSBmb3IgdGVzdGluZywgdG8gYXZvaWQgdGhlCiMgdHJhbnNpdG9yeSAiZ2l0IGluaXQiIHdhcm5pbmcgdW5kZXIgLS12ZXJib3NlLgo6ICR7R0lUX1RFU1RfREVGQVVMVF9JTklUSUFMX0JSQU5DSF9OQU1FOj1tYXN0ZXJ9CmV4cG9ydCBHSVRfVEVTVF9ERUZBVUxUX0lOSVRJQUxfQlJBTkNIX05BTUUKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKIyBJdCBhcHBlYXJzIHRoYXQgcGVvcGxlIHRyeSB0byBydW4gdGVzdHMgd2l0aG91dCBidWlsZGluZy4uLgoiJHtHSVRfVEVTVF9JTlNUQUxMRUQ6LSRHSVRfQlVJTERfRElSfS9naXQkWCIgPi9kZXYvbnVsbAppZiB0ZXN0ICQ/ICE9IDEKdGhlbgoJaWYgdGVzdCAtbiAiJEdJVF9URVNUX0lOU1RBTExFRCIKCXRoZW4KCQllY2hvID4mMiAiZXJyb3I6IHRoZXJlIGlzIG5vIHdvcmtpbmcgR2l0IGF0ICckR0lUX1RFU1RfSU5TVEFMTEVEJyIKCWVsc2UKCQllY2hvID4mMiAnZXJyb3I6IHlvdSBkbyBub3Qgc2VlbSB0byBoYXZlIGJ1aWx0IGdpdCB5ZXQuJwoJZmkKCWV4aXQgMQpmaQoKc3RvcmVfYXJnX3RvPQpvcHRfcmVxdWlyZWRfYXJnPQojICQxOiBvcHRpb24gc3RyaW5nCiMgJDI6IG5hbWUgb2YgdGhlIHZhciB3aGVyZSB0aGUgYXJnIHdpbGwgYmUgc3RvcmVkCm1hcmtfb3B0aW9uX3JlcXVpcmVzX2FyZyAoKSB7CglpZiB0ZXN0IC1uICIkb3B0X3JlcXVpcmVkX2FyZyIKCXRoZW4KCQllY2hvICJlcnJvcjogb3B0aW9ucyB0aGF0IHJlcXVpcmUgYXJncyBjYW5ub3QgYmUgYnVuZGxlZCIgXAoJCQkidG9nZXRoZXI6ICckb3B0X3JlcXVpcmVkX2FyZycgYW5kICckMSciID4mMgoJCWV4aXQgMQoJZmkKCW9wdF9yZXF1aXJlZF9hcmc9JDEKCXN0b3JlX2FyZ190bz0kMgp9CgojIFRoZXNlIGZ1bmN0aW9ucyBjYW4gYmUgb3ZlcnJpZGRlbiBlLmcuIHRvIG91dHB1dCBKVW5pdCBYTUwKc3RhcnRfdGVzdF9vdXRwdXQgKCkgeyA6OyB9CnN0YXJ0X3Rlc3RfY2FzZV9vdXRwdXQgKCkgeyA6OyB9CmZpbmFsaXplX3Rlc3RfY2FzZV9vdXRwdXQgKCkgeyA6OyB9CmZpbmFsaXplX3Rlc3Rfb3V0cHV0ICgpIHsgOjsgfQoKcGFyc2Vfb3B0aW9uICgpIHsKCWxvY2FsIG9wdD0iJDEiCgoJY2FzZSAiJG9wdCIgaW4KCS1kfC0tZHwtLWRlfC0tZGVifC0tZGVidXwtLWRlYnVnKQoJCWRlYnVnPXQgOzsKCS1pfC0taXwtLWltfC0taW1tfC0taW1tZXwtLWltbWVkfC0taW1tZWRpfC0taW1tZWRpYXwtLWltbWVkaWF0fC0taW1tZWRpYXRlKQoJCWltbWVkaWF0ZT10IDs7CgktbHwtLWx8LS1sb3wtLWxvbnwtLWxvbmd8LS1sb25nLXwtLWxvbmctdHwtLWxvbmctdGV8LS1sb25nLXRlc3wtLWxvbmctdGVzdHwtLWxvbmctdGVzdHMpCgkJR0lUX1RFU1RfTE9ORz10OyBleHBvcnQgR0lUX1RFU1RfTE9ORyA7OwoJLXIpCgkJbWFya19vcHRpb25fcmVxdWlyZXNfYXJnICIkb3B0IiBydW5fbGlzdAoJCTs7CgktLXJ1bj0qKQoJCXJ1bl9saXN0PSR7b3B0Iy0tKj19IDs7CgktaHwtLWh8LS1oZXwtLWhlbHwtLWhlbHApCgkJaGVscD10IDs7CgktdnwtLXZ8LS12ZXwtLXZlcnwtLXZlcmJ8LS12ZXJib3wtLXZlcmJvc3wtLXZlcmJvc2UpCgkJdmVyYm9zZT10IDs7CgktLXZlcmJvc2Utb25seT0qKQoJCXZlcmJvc2Vfb25seT0ke29wdCMtLSo9fQoJCTs7CgktcXwtLXF8LS1xdXwtLXF1aXwtLXF1aWV8LS1xdWlldCkKCQkjIElnbm9yZSAtLXF1aWV0IHVuZGVyIGEgVEFQOjpIYXJuZXNzLiBTYXlpbmcgaG93IG1hbnkgdGVzdHMKCQkjIHBhc3NlZCB3aXRob3V0IHRoZSBvay9ub3Qgb2sgZGV0YWlscyBpcyBhbHdheXMgYW4gZXJyb3IuCgkJdGVzdCAteiAiJEhBUk5FU1NfQUNUSVZFIiAmJiBxdWlldD10IDs7CgktLXdpdGgtZGFzaGVzKQoJCXdpdGhfZGFzaGVzPXQgOzsKCS0tbm8tYmluLXdyYXBwZXJzKQoJCW5vX2Jpbl93cmFwcGVycz10IDs7CgktLW5vLWNvbG9yKQoJCWNvbG9yPSA7OwoJLS12YXwtLXZhbHwtLXZhbGd8LS12YWxncnwtLXZhbGdyaXwtLXZhbGdyaW58LS12YWxncmluZCkKCQl2YWxncmluZD1tZW1jaGVjawoJCXRlZT10CgkJOzsKCS0tdmFsZ3JpbmQ9KikKCQl2YWxncmluZD0ke29wdCMtLSo9fQoJCXRlZT10CgkJOzsKCS0tdmFsZ3JpbmQtb25seT0qKQoJCXZhbGdyaW5kX29ubHk9JHtvcHQjLS0qPX0KCQl0ZWU9dAoJCTs7CgktLXRlZSkKCQl0ZWU9dCA7OwoJLS1yb290PSopCgkJcm9vdD0ke29wdCMtLSo9fSA7OwoJLS1jaGFpbi1saW50KQoJCUdJVF9URVNUX0NIQUlOX0xJTlQ9MSA7OwoJLS1uby1jaGFpbi1saW50KQoJCUdJVF9URVNUX0NIQUlOX0xJTlQ9MCA7OwoJLXgpCgkJdHJhY2U9dCA7OwoJLVZ8LS12ZXJib3NlLWxvZykKCQl2ZXJib3NlX2xvZz10CgkJdGVlPXQKCQk7OwoJLS13cml0ZS1qdW5pdC14bWwpCgkJLiAiJFRFU1RfRElSRUNUT1JZL3Rlc3QtbGliLWp1bml0LnNoIgoJCTs7CgktLWdpdGh1Yi13b3JrZmxvdy1tYXJrdXApCgkJLiAiJFRFU1RfRElSRUNUT1JZL3Rlc3QtbGliLWdpdGh1Yi13b3JrZmxvdy1tYXJrdXAuc2giCgkJOzsKCS0tc3RyZXNzKQoJCXN0cmVzcz10IDs7CgktLXN0cmVzcz0qKQoJCWVjaG8gImVycm9yOiAtLXN0cmVzcyBkb2VzIG5vdCBhY2NlcHQgYW4gYXJndW1lbnQ6ICckb3B0JyIgPiYyCgkJZWNobyAiZGlkIHlvdSBtZWFuIC0tc3RyZXNzLWpvYnM9JHtvcHQjKj19IG9yIC0tc3RyZXNzLWxpbWl0PSR7b3B0Iyo9fT8iID4mMgoJCWV4aXQgMQoJCTs7CgktLXN0cmVzcy1qb2JzPSopCgkJc3RyZXNzPXQ7CgkJc3RyZXNzX2pvYnM9JHtvcHQjLS0qPX0KCQljYXNlICIkc3RyZXNzX2pvYnMiIGluCgkJKlshMC05XSp8MCp8IiIpCgkJCWVjaG8gImVycm9yOiAtLXN0cmVzcy1qb2JzPTxOPiByZXF1aXJlcyB0aGUgbnVtYmVyIG9mIGpvYnMgdG8gcnVuIiA+JjIKCQkJZXhpdCAxCgkJCTs7CgkJKikJIyBHb29kLgoJCQk7OwoJCWVzYWMKCQk7OwoJLS1zdHJlc3MtbGltaXQ9KikKCQlzdHJlc3M9dDsKCQlzdHJlc3NfbGltaXQ9JHtvcHQjLS0qPX0KCQljYXNlICIkc3RyZXNzX2xpbWl0IiBpbgoJCSpbITAtOV0qfDAqfCIiKQoJCQllY2hvICJlcnJvcjogLS1zdHJlc3MtbGltaXQ9PE4+IHJlcXVpcmVzIHRoZSBudW1iZXIgb2YgcmVwZXRpdGlvbnMiID4mMgoJCQlleGl0IDEKCQkJOzsKCQkqKQkjIEdvb2QuCgkJCTs7CgkJZXNhYwoJCTs7CgktLWludmVydC1leGl0LWNvZGUpCgkJaW52ZXJ0X2V4aXRfY29kZT10CgkJOzsKCSopCgkJZWNobyAiZXJyb3I6IHVua25vd24gdGVzdCBvcHRpb24gJyRvcHQnIiA+JjI7IGV4aXQgMSA7OwoJZXNhYwp9CgojIFBhcnNlIG9wdGlvbnMgd2hpbGUgdGFraW5nIGNhcmUgdG8gbGVhdmUgJEAgaW50YWN0LCBzbyB3ZSB3aWxsIHN0aWxsCiMgaGF2ZSBhbGwgdGhlIG9yaWdpbmFsIGNvbW1hbmQgbGluZSBvcHRpb25zIHdoZW4gZXhlY3V0aW5nIHRoZSB0ZXN0CiMgc2NyaXB0IGFnYWluIGZvciAnLS10ZWUnIGFuZCAnLS12ZXJib3NlLWxvZycgbGF0ZXIuCmZvciBvcHQKZG8KCWlmIHRlc3QgLW4gIiRzdG9yZV9hcmdfdG8iCgl0aGVuCgkJZXZhbCAkc3RvcmVfYXJnX3RvPVwkb3B0CgkJc3RvcmVfYXJnX3RvPQoJCW9wdF9yZXF1aXJlZF9hcmc9CgkJY29udGludWUKCWZpCgoJY2FzZSAiJG9wdCIgaW4KCS0tKnwtPykKCQlwYXJzZV9vcHRpb24gIiRvcHQiIDs7CgktPyopCgkJIyBidW5kbGVkIHNob3J0IG9wdGlvbnMgbXVzdCBiZSBmZWQgc2VwYXJhdGVseSB0byBwYXJzZV9vcHRpb24KCQlvcHQ9JHtvcHQjLX0KCQl3aGlsZSB0ZXN0IC1uICIkb3B0IgoJCWRvCgkJCWV4dHJhPSR7b3B0Iz99CgkJCXRoaXM9JHtvcHQlJGV4dHJhfQoJCQlvcHQ9JGV4dHJhCgkJCXBhcnNlX29wdGlvbiAiLSR0aGlzIgoJCWRvbmUKCQk7OwoJKikKCQllY2hvICJlcnJvcjogdW5rbm93biB0ZXN0IG9wdGlvbiAnJG9wdCciID4mMjsgZXhpdCAxIDs7Cgllc2FjCmRvbmUKaWYgdGVzdCAtbiAiJHN0b3JlX2FyZ190byIKdGhlbgoJZWNobyAiZXJyb3I6ICRvcHRfcmVxdWlyZWRfYXJnIHJlcXVpcmVzIGFuIGFyZ3VtZW50IiA+JjIKCWV4aXQgMQpmaQoKaWYgdGVzdCAtbiAiJHZhbGdyaW5kX29ubHkiCnRoZW4KCXRlc3QgLXogIiR2YWxncmluZCIgJiYgdmFsZ3JpbmQ9bWVtY2hlY2sKCXRlc3QgLXogIiR2ZXJib3NlIiAmJiB2ZXJib3NlX29ubHk9IiR2YWxncmluZF9vbmx5IgplbGlmIHRlc3QgLW4gIiR2YWxncmluZCIKdGhlbgoJdGVzdCAteiAiJHZlcmJvc2VfbG9nIiAmJiB2ZXJib3NlPXQKZmkKCmlmIHRlc3QgLW4gIiRzdHJlc3MiCnRoZW4KCXZlcmJvc2U9dAoJdHJhY2U9dAoJaW1tZWRpYXRlPXQKZmkKClRFU1RfU1RSRVNTX0pPQl9TRlg9IiR7R0lUX1RFU1RfU1RSRVNTX0pPQl9OUjorLnN0cmVzcy0kR0lUX1RFU1RfU1RSRVNTX0pPQl9OUn0iClRFU1RfTkFNRT0iJChiYXNlbmFtZSAiJDAiIC5zaCkiClRFU1RfTlVNQkVSPSIke1RFU1RfTkFNRSUlLSp9IgpURVNUX05VTUJFUj0iJHtURVNUX05VTUJFUiN0fSIKVEVTVF9SRVNVTFRTX0RJUj0iJFRFU1RfT1VUUFVUX0RJUkVDVE9SWS90ZXN0LXJlc3VsdHMiClRFU1RfUkVTVUxUU19CQVNFPSIkVEVTVF9SRVNVTFRTX0RJUi8kVEVTVF9OQU1FJFRFU1RfU1RSRVNTX0pPQl9TRlgiClRFU1RfUkVTVUxUU19TQU5fRklMRV9QRlg9dHJhY2UKVEVTVF9SRVNVTFRTX1NBTl9ESVJfU0ZYPWxlYWsKVEVTVF9SRVNVTFRTX1NBTl9GSUxFPQpURVNUX1JFU1VMVFNfU0FOX0RJUj0iJFRFU1RfUkVTVUxUU19ESVIvJFRFU1RfTkFNRS4kVEVTVF9SRVNVTFRTX1NBTl9ESVJfU0ZYIgpURVNUX1JFU1VMVFNfU0FOX0RJUl9OUl9MRUFLU19TVEFSVFVQPQpUUkFTSF9ESVJFQ1RPUlk9InRyYXNoIGRpcmVjdG9yeS4kVEVTVF9OQU1FJFRFU1RfU1RSRVNTX0pPQl9TRlgiCnRlc3QgLW4gIiRyb290IiAmJiBUUkFTSF9ESVJFQ1RPUlk9IiRyb290LyRUUkFTSF9ESVJFQ1RPUlkiCmNhc2UgIiRUUkFTSF9ESVJFQ1RPUlkiIGluCi8qKSA7OyAjIGFic29sdXRlIHBhdGggaXMgZ29vZAogKikgVFJBU0hfRElSRUNUT1JZPSIkVEVTVF9PVVRQVVRfRElSRUNUT1JZLyRUUkFTSF9ESVJFQ1RPUlkiIDs7CmVzYWMKCiMgVXRpbGl0eSBmdW5jdGlvbnMgdXNpbmcgJFRFU1RfUkVTVUxUU18qIHZhcmlhYmxlcwpucl9zYW5fZGlyX2xlYWtzXyAoKSB7CgkjIHN0ZGVyciBwaXBlZCB0byAvZGV2L251bGwgYmVjYXVzZSB0aGUgZGlyZWN0b3J5IG1heSBoYXZlCgkjIGJlZW4gInJtZGlyIidkIGFscmVhZHkuCglmaW5kICIkVEVTVF9SRVNVTFRTX1NBTl9ESVIiIFwKCQktdHlwZSBmIFwKCQktbmFtZSAiJFRFU1RfUkVTVUxUU19TQU5fRklMRV9QRlguKiIgMj4vZGV2L251bGwgfAoJd2MgLWwKfQoKIyBJZiAtLXN0cmVzcyB3YXMgcGFzc2VkLCBydW4gdGhpcyB0ZXN0IHJlcGVhdGVkbHkgaW4gc2V2ZXJhbCBwYXJhbGxlbCBsb29wcy4KaWYgdGVzdCAiJEdJVF9URVNUX1NUUkVTU19TVEFSVEVEIiA9ICJkb25lIgp0aGVuCgk6ICMgRG9uJ3Qgc3RyZXNzIHRlc3QgYWdhaW4uCmVsaWYgdGVzdCAtbiAiJHN0cmVzcyIKdGhlbgoJaWYgdGVzdCAtbiAiJHN0cmVzc19qb2JzIgoJdGhlbgoJCWpvYl9jb3VudD0kc3RyZXNzX2pvYnMKCWVsaWYgdGVzdCAtbiAiJEdJVF9URVNUX1NUUkVTU19MT0FEIgoJdGhlbgoJCWpvYl9jb3VudD0iJEdJVF9URVNUX1NUUkVTU19MT0FEIgoJZWxpZiBqb2JfY291bnQ9JChnZXRjb25mIF9OUFJPQ0VTU09SU19PTkxOIDI+L2Rldi9udWxsKSAmJgoJICAgICB0ZXN0IC1uICIkam9iX2NvdW50IgoJdGhlbgoJCWpvYl9jb3VudD0kKCgyICogJGpvYl9jb3VudCkpCgllbHNlCgkJam9iX2NvdW50PTgKCWZpCgoJbWtkaXIgLXAgIiRURVNUX1JFU1VMVFNfRElSIgoJc3RyZXNzZmFpbD0iJFRFU1RfUkVTVUxUU19CQVNFLnN0cmVzcy1mYWlsZWQiCglybSAtZiAiJHN0cmVzc2ZhaWwiCgoJc3RyZXNzX2V4aXQ9MAoJdHJhcCAnCgkJa2lsbCAkam9iX3BpZHMgMj4vZGV2L251bGwKCQl3YWl0CgkJc3RyZXNzX2V4aXQ9MQoJJyBURVJNIElOVCBIVVAKCglqb2JfcGlkcz0KCWpvYl9ucj0wCgl3aGlsZSB0ZXN0ICRqb2JfbnIgLWx0ICIkam9iX2NvdW50IgoJZG8KCQkoCgkJCUdJVF9URVNUX1NUUkVTU19TVEFSVEVEPWRvbmUKCQkJR0lUX1RFU1RfU1RSRVNTX0pPQl9OUj0kam9iX25yCgkJCWV4cG9ydCBHSVRfVEVTVF9TVFJFU1NfU1RBUlRFRCBHSVRfVEVTVF9TVFJFU1NfSk9CX05SCgoJCQl0cmFwICcKCQkJCWtpbGwgJHRlc3RfcGlkIDI+L2Rldi9udWxsCgkJCQl3YWl0CgkJCQlleGl0IDEKCQkJJyBURVJNIElOVAoKCQkJY250PTEKCQkJd2hpbGUgISB0ZXN0IC1lICIkc3RyZXNzZmFpbCIgJiYKCQkJICAgICAgeyB0ZXN0IC16ICIkc3RyZXNzX2xpbWl0IiB8fAoJCQkJdGVzdCAkY250IC1sZSAkc3RyZXNzX2xpbWl0IDsgfQoJCQlkbwoJCQkJJFRFU1RfU0hFTExfUEFUSCAiJDAiICIkQCIgPiIkVEVTVF9SRVNVTFRTX0JBU0Uuc3RyZXNzLSRqb2JfbnIub3V0IiAyPiYxICYKCQkJCXRlc3RfcGlkPSQhCgoJCQkJaWYgd2FpdCAkdGVzdF9waWQKCQkJCXRoZW4KCQkJCQlwcmludGYgIk9LICAgJTJkLiVkXG4iICRHSVRfVEVTVF9TVFJFU1NfSk9CX05SICRjbnQKCQkJCWVsc2UKCQkJCQllY2hvICRHSVRfVEVTVF9TVFJFU1NfSk9CX05SID4+IiRzdHJlc3NmYWlsIgoJCQkJCXByaW50ZiAiRkFJTCAlMmQuJWRcbiIgJEdJVF9URVNUX1NUUkVTU19KT0JfTlIgJGNudAoJCQkJZmkKCQkJCWNudD0kKCgkY250ICsgMSkpCgkJCWRvbmUKCQkpICYKCQlqb2JfcGlkcz0iJGpvYl9waWRzICQhIgoJCWpvYl9ucj0kKCgkam9iX25yICsgMSkpCglkb25lCgoJd2FpdAoKCWlmIHRlc3QgLWYgIiRzdHJlc3NmYWlsIgoJdGhlbgoJCXN0cmVzc19leGl0PTEKCQllY2hvICJMb2cocykgb2YgZmFpbGVkIHRlc3QgcnVuKHMpOiIKCQlmb3IgZmFpbGVkX2pvYl9uciBpbiAkKHNvcnQgLW4gIiRzdHJlc3NmYWlsIikKCQlkbwoJCQllY2hvICJDb250ZW50cyBvZiAnJFRFU1RfUkVTVUxUU19CQVNFLnN0cmVzcy0kZmFpbGVkX2pvYl9uci5vdXQnOiIKCQkJY2F0ICIkVEVTVF9SRVNVTFRTX0JBU0Uuc3RyZXNzLSRmYWlsZWRfam9iX25yLm91dCIKCQlkb25lCgkJcm0gLXJmICIkVFJBU0hfRElSRUNUT1JZLnN0cmVzcy1mYWlsZWQiCgkJIyBNb3ZlIHRoZSBsYXN0IG9uZS4KCQltdiAiJFRSQVNIX0RJUkVDVE9SWS5zdHJlc3MtJGZhaWxlZF9qb2JfbnIiICIkVFJBU0hfRElSRUNUT1JZLnN0cmVzcy1mYWlsZWQiCglmaQoKCWV4aXQgJHN0cmVzc19leGl0CmZpCgojIGlmIC0tdGVlIHdhcyBwYXNzZWQsIHdyaXRlIHRoZSBvdXRwdXQgbm90IG9ubHkgdG8gdGhlIHRlcm1pbmFsLCBidXQKIyBhZGRpdGlvbmFsbHkgdG8gdGhlIGZpbGUgdGVzdC1yZXN1bHRzLyRCQVNFTkFNRS5vdXQsIHRvby4KaWYgdGVzdCAiJEdJVF9URVNUX1RFRV9TVEFSVEVEIiA9ICJkb25lIgp0aGVuCgk6ICMgZG8gbm90IHJlZGlyZWN0IGFnYWluCmVsaWYgdGVzdCAtbiAiJHRlZSIKdGhlbgoJbWtkaXIgLXAgIiRURVNUX1JFU1VMVFNfRElSIgoKCSMgTWFrZSB0aGlzIGZpbGVuYW1lIGF2YWlsYWJsZSB0byB0aGUgc3ViLXByb2Nlc3MgaW4gY2FzZSBpdCBpcyB1c2luZwoJIyAtLXZlcmJvc2UtbG9nLgoJR0lUX1RFU1RfVEVFX09VVFBVVF9GSUxFPSRURVNUX1JFU1VMVFNfQkFTRS5vdXQKCWV4cG9ydCBHSVRfVEVTVF9URUVfT1VUUFVUX0ZJTEUKCgkjIFRydW5jYXRlIGJlZm9yZSBjYWxsaW5nICJ0ZWUgLWEiIHRvIGdldCByaWQgb2YgdGhlIHJlc3VsdHMKCSMgZnJvbSBhbnkgcHJldmlvdXMgcnVucy4KCT4iJEdJVF9URVNUX1RFRV9PVVRQVVRfRklMRSIKCgkoR0lUX1RFU1RfVEVFX1NUQVJURUQ9ZG9uZSAke1RFU1RfU0hFTExfUEFUSH0gIiQwIiAiJEAiIDI+JjE7CgkgZWNobyAkPyA+IiRURVNUX1JFU1VMVFNfQkFTRS5leGl0IikgfCB0ZWUgLWEgIiRHSVRfVEVTVF9URUVfT1VUUFVUX0ZJTEUiCgl0ZXN0ICIkKGNhdCAiJFRFU1RfUkVTVUxUU19CQVNFLmV4aXQiKSIgPSAwCglleGl0CmZpCgppZiB0ZXN0IC1uICIkdHJhY2UiICYmIHRlc3QgLW4gIiR0ZXN0X3VudHJhY2VhYmxlIgp0aGVuCgkjICcteCcgdHJhY2luZyByZXF1ZXN0ZWQsIGJ1dCB0aGlzIHRlc3Qgc2NyaXB0IGNhbid0IGJlIHJlbGlhYmx5CgkjIHRyYWNlZCwgdW5sZXNzIGl0IGlzIHJ1biB3aXRoIGEgQmFzaCB2ZXJzaW9uIHN1cHBvcnRpbmcKCSMgQkFTSF9YVFJBQ0VGRCAoaW50cm9kdWNlZCBpbiBCYXNoIHY0LjEpLgoJIwoJIyBQZXJmb3JtIHRoaXMgdmVyc2lvbiBjaGVjayBfYWZ0ZXJfIHRoZSB0ZXN0IHNjcmlwdCB3YXMKCSMgcG90ZW50aWFsbHkgcmUtZXhlY3V0ZWQgd2l0aCAkVEVTVF9TSEVMTF9QQVRIIGZvciAnLS10ZWUnIG9yCgkjICctLXZlcmJvc2UtbG9nJywgc28gdGhlIHJpZ2h0IHNoZWxsIGlzIGNoZWNrZWQgYW5kIHRoZQoJIyB3YXJuaW5nIGlzIGlzc3VlZCBvbmx5IG9uY2UuCglpZiB0ZXN0IC1uICIkQkFTSF9WRVJTSU9OIiAmJiBldmFsICcKCSAgICAgdGVzdCAke0JBU0hfVkVSU0lORk9bMF19IC1ndCA0IHx8IHsKCSAgICAgICB0ZXN0ICR7QkFTSF9WRVJTSU5GT1swXX0gLWVxIDQgJiYKCSAgICAgICB0ZXN0ICR7QkFTSF9WRVJTSU5GT1sxXX0gLWdlIDEKCSAgICAgfQoJICAgJwoJdGhlbgoJCTogRXhlY3V0ZWQgYnkgYSBCYXNoIHZlcnNpb24gc3VwcG9ydGluZyBCQVNIX1hUUkFDRUZELiAgR29vZC4KCWVsc2UKCQllY2hvID4mMiAid2FybmluZzogaWdub3JpbmcgLXg7ICckMCcgaXMgdW50cmFjZWFibGUgd2l0aG91dCBCQVNIX1hUUkFDRUZEIgoJCXRyYWNlPQoJZmkKZmkKaWYgdGVzdCAtbiAiJHRyYWNlIiAmJiB0ZXN0IC16ICIkdmVyYm9zZV9sb2ciCnRoZW4KCXZlcmJvc2U9dApmaQoKIyBTaW5jZSBiYXNoIDUuMCwgY2hlY2t3aW5zaXplIGlzIGVuYWJsZWQgYnkgZGVmYXVsdCB3aGljaCBkb2VzCiMgdXBkYXRlIHRoZSBDT0xVTU5TIHZhcmlhYmxlIGV2ZXJ5IHRpbWUgYSBub24tYnVpbHRpbiBjb21tYW5kCiMgY29tcGxldGVzLCBldmVuIGZvciBub24taW50ZXJhY3RpdmUgc2hlbGxzLgojIERpc2FibGUgdGhhdCBzaW5jZSB3ZSBhcmUgYWltaW5nIGZvciByZXBlYXRhYmlsaXR5Lgp0ZXN0IC1uICIkQkFTSF9WRVJTSU9OIiAmJiBzaG9wdCAtdSBjaGVja3dpbnNpemUgMj4vZGV2L251bGwKCiMgRm9yIHJlcGVhdGFiaWxpdHksIHJlc2V0IHRoZSBlbnZpcm9ubWVudCB0byBrbm93biB2YWx1ZS4KIyBURVJNIGlzIHNhbml0aXplZCBiZWxvdywgYWZ0ZXIgc2F2aW5nIGNvbG9yIGNvbnRyb2wgc2VxdWVuY2VzLgpMQU5HPUMKTENfQUxMPUMKUEFHRVI9Y2F0ClRaPVVUQwpDT0xVTU5TPTgwCmV4cG9ydCBMQU5HIExDX0FMTCBQQUdFUiBUWiBDT0xVTU5TCkVESVRPUj06CgojIEEgY2FsbCB0byAidW5zZXQiIHdpdGggbm8gYXJndW1lbnRzIGNhdXNlcyBhdCBsZWFzdCBTb2xhcmlzIDEwCiMgL3Vzci94cGc0L2Jpbi9zaCBhbmQgL2Jpbi9rc2ggdG8gYmFpbCBvdXQuICBTbyBrZWVwIHRoZSB1bnNldHMKIyBkZXJpdmluZyBmcm9tIHRoZSBjb21tYW5kIHN1YnN0aXR1dGlvbiBjbHVzdGVyZWQgd2l0aCB0aGUgb3RoZXIKIyBvbmVzLgp1bnNldCBWSVNVQUwgRU1BSUwgTEFOR1VBR0UgJCgiJFBFUkxfUEFUSCIgLWUgJwoJbXkgQGVudiA9IGtleXMgJUVOVjsKCW15ICRvayA9IGpvaW4oInwiLCBxdygKCQlUUkFDRQoJCURFQlVHCgkJVEVTVAoJCS4qX1RFU1QKCQlQUk9WRQoJCVZBTEdSSU5ECgkJVU5aSVAKCQlQRVJGXwoJCUNVUkxfVkVSQk9TRQoJCVRSQUNFX0NVUkwKCSkpOwoJbXkgQHZhcnMgPSBncmVwKC9eR0lUXy8gJiYgIS9eR0lUXygkb2spL28sIEBlbnYpOwoJcHJpbnQgam9pbigiXG4iLCBAdmFycyk7CicpCnVuc2V0IFhER19DQUNIRV9IT01FCnVuc2V0IFhER19DT05GSUdfSE9NRQp1bnNldCBHSVRQRVJMTElCCnVuc2V0IEdJVF9UUkFDRTJfUEFSRU5UX05BTUUKdW5zZXQgR0lUX1RSQUNFMl9QQVJFTlRfU0lEClRFU1RfQVVUSE9SX0xPQ0FMTkFNRT1hdXRob3IKVEVTVF9BVVRIT1JfRE9NQUlOPWV4YW1wbGUuY29tCkdJVF9BVVRIT1JfRU1BSUw9JHtURVNUX0FVVEhPUl9MT0NBTE5BTUV9QCR7VEVTVF9BVVRIT1JfRE9NQUlOfQpHSVRfQVVUSE9SX05BTUU9J0EgVSBUaG9yJwpHSVRfQVVUSE9SX0RBVEU9JzExMTIzNTQwNTUgKzAyMDAnClRFU1RfQ09NTUlUVEVSX0xPQ0FMTkFNRT1jb21taXR0ZXIKVEVTVF9DT01NSVRURVJfRE9NQUlOPWV4YW1wbGUuY29tCkdJVF9DT01NSVRURVJfRU1BSUw9JHtURVNUX0NPTU1JVFRFUl9MT0NBTE5BTUV9QCR7VEVTVF9DT01NSVRURVJfRE9NQUlOfQpHSVRfQ09NTUlUVEVSX05BTUU9J0MgTyBNaXR0ZXInCkdJVF9DT01NSVRURVJfREFURT0nMTExMjM1NDA1NSArMDIwMCcKR0lUX01FUkdFX1ZFUkJPU0lUWT01CkdJVF9NRVJHRV9BVVRPRURJVD1ubwpleHBvcnQgR0lUX01FUkdFX1ZFUkJPU0lUWSBHSVRfTUVSR0VfQVVUT0VESVQKZXhwb3J0IEdJVF9BVVRIT1JfRU1BSUwgR0lUX0FVVEhPUl9OQU1FCmV4cG9ydCBHSVRfQ09NTUlUVEVSX0VNQUlMIEdJVF9DT01NSVRURVJfTkFNRQpleHBvcnQgR0lUX0NPTU1JVFRFUl9EQVRFIEdJVF9BVVRIT1JfREFURQpleHBvcnQgRURJVE9SCgpHSVRfREVGQVVMVF9IQVNIPSIke0dJVF9URVNUX0RFRkFVTFRfSEFTSDotc2hhMX0iCmV4cG9ydCBHSVRfREVGQVVMVF9IQVNICkdJVF9URVNUX01FUkdFX0FMR09SSVRITT0iJHtHSVRfVEVTVF9NRVJHRV9BTEdPUklUSE06LW9ydH0iCmV4cG9ydCBHSVRfVEVTVF9NRVJHRV9BTEdPUklUSE0KCiMgVGVzdHMgdXNpbmcgR0lUX1RSQUNFIHR5cGljYWxseSBkb24ndCB3YW50IDx0aW1lc3RhbXA+IDxmaWxlPjo8bGluZT4gb3V0cHV0CkdJVF9UUkFDRV9CQVJFPTEKZXhwb3J0IEdJVF9UUkFDRV9CQVJFCgojIFNvbWUgdGVzdHMgc2NhbiB0aGUgR0lUX1RSQUNFMl9FVkVOVCBmZWVkIGZvciBldmVudHMsIGJ1dCB0aGUKIyBkZWZhdWx0IGRlcHRoIGlzIDIsIHdoaWNoIGZyZXF1ZW50bHkgY2F1c2VzIGlzc3VlcyB3aGVuIHRoZQojIGV2ZW50cyBhcmUgd3JhcHBlZCBpbiBuZXcgcmVnaW9ucy4gU2V0IGl0IHRvIGEgc3VmZmljaWVudGx5CiMgbGFyZ2UgZGVwdGggdG8gYXZvaWQgY3VzdG9tIGNoYW5nZXMgaW4gdGhlIHRlc3Qgc3VpdGUuCkdJVF9UUkFDRTJfRVZFTlRfTkVTVElORz0xMDAKZXhwb3J0IEdJVF9UUkFDRTJfRVZFTlRfTkVTVElORwoKIyBVc2Ugc3BlY2lmaWMgdmVyc2lvbiBvZiB0aGUgaW5kZXggZmlsZSBmb3JtYXQKaWYgdGVzdCAtbiAiJHtHSVRfVEVTVF9JTkRFWF9WRVJTSU9OOitpc3NldH0iCnRoZW4KCUdJVF9JTkRFWF9WRVJTSU9OPSIkR0lUX1RFU1RfSU5ERVhfVkVSU0lPTiIKCWV4cG9ydCBHSVRfSU5ERVhfVkVSU0lPTgpmaQoKaWYgdGVzdCAtbiAiJEdJVF9URVNUX1BFUkxfRkFUQUxfV0FSTklOR1MiCnRoZW4KCUdJVF9QRVJMX0ZBVEFMX1dBUk5JTkdTPTEKCWV4cG9ydCBHSVRfUEVSTF9GQVRBTF9XQVJOSU5HUwpmaQoKY2FzZSAkR0lUX1RFU1RfRlNZTkMgaW4KJycpCglHSVRfVEVTVF9GU1lOQz0wCglleHBvcnQgR0lUX1RFU1RfRlNZTkMKCTs7CmVzYWMKCiMgQWRkIGxpYmMgTUFMTE9DIGFuZCBNQUxMT0NfUEVSVFVSQiB0ZXN0IG9ubHkgaWYgd2UgYXJlIG5vdCBleGVjdXRpbmcKIyB0aGUgdGVzdCB3aXRoIHZhbGdyaW5kIGFuZCBoYXZlIG5vdCBjb21waWxlZCB3aXRoIGNvbmZsaWN0IFNBTklUSVpFCiMgb3B0aW9ucy4KaWYgdGVzdCAtbiAiJHZhbGdyaW5kIiB8fAogICB0ZXN0IC1uICIkU0FOSVRJWkVfQUREUkVTUyIgfHwKICAgdGVzdCAtbiAiJFNBTklUSVpFX0xFQUsiIHx8CiAgIHRlc3QgLW4gIiRURVNUX05PX01BTExPQ19DSEVDSyIKdGhlbgoJc2V0dXBfbWFsbG9jX2NoZWNrICgpIHsKCQk6IG5vdGhpbmcKCX0KCXRlYXJkb3duX21hbGxvY19jaGVjayAoKSB7CgkJOiBub3RoaW5nCgl9CmVsc2UKCV9VU0VfR0xJQkNfVFVOQUJMRVM9CglpZiBfR0xJQkNfVkVSU0lPTj0kKGdldGNvbmYgR05VX0xJQkNfVkVSU0lPTiAyPi9kZXYvbnVsbCkgJiYKCSAgIF9HTElCQ19WRVJTSU9OPSR7X0dMSUJDX1ZFUlNJT04jImdsaWJjICJ9ICYmCgkgICBleHByIDIuMzQgXDw9ICIkX0dMSUJDX1ZFUlNJT04iID4vZGV2L251bGwKCXRoZW4KCQlfVVNFX0dMSUJDX1RVTkFCTEVTPVllc1BsZWFzZQoJZmkKCXNldHVwX21hbGxvY19jaGVjayAoKSB7CgkJbG9jYWwgZwoJCWxvY2FsIHQKCQlNQUxMT0NfQ0hFQ0tfPTMJTUFMTE9DX1BFUlRVUkJfPTE2NQoJCWV4cG9ydCBNQUxMT0NfQ0hFQ0tfIE1BTExPQ19QRVJUVVJCXwoJCWlmIHRlc3QgLW4gIiRfVVNFX0dMSUJDX1RVTkFCTEVTIgoJCXRoZW4KCQkJZz0KCQkJTERfUFJFTE9BRD0ibGliY19tYWxsb2NfZGVidWcuc28uMCIKCQkJZm9yIHQgaW4gXAoJCQkJZ2xpYmMubWFsbG9jLmNoZWNrPTEgXAoJCQkJZ2xpYmMubWFsbG9jLnBlcnR1cmI9MTY1CgkJCWRvCgkJCQlnPSIke2cjOn06JHQiCgkJCWRvbmUKCQkJR0xJQkNfVFVOQUJMRVM9JGcKCQkJZXhwb3J0IExEX1BSRUxPQUQgR0xJQkNfVFVOQUJMRVMKCQlmaQoJfQoJdGVhcmRvd25fbWFsbG9jX2NoZWNrICgpIHsKCQl1bnNldCBNQUxMT0NfQ0hFQ0tfIE1BTExPQ19QRVJUVVJCXwoJCXVuc2V0IExEX1BSRUxPQUQgR0xJQkNfVFVOQUJMRVMKCX0KZmkKCiMgUHJvdGVjdCBvdXJzZWx2ZXMgZnJvbSBjb21tb24gbWlzY29uZmlndXJhdGlvbiB0byBleHBvcnQKIyBDRFBBVEggaW50byB0aGUgZW52aXJvbm1lbnQKdW5zZXQgQ0RQQVRICgp1bnNldCBHUkVQX09QVElPTlMKdW5zZXQgVU5aSVAKCmNhc2UgJChlY2hvICRHSVRfVFJBQ0UgfHRyICJbQS1aXSIgIlthLXpdIikgaW4KMXwyfHRydWUpCglHSVRfVFJBQ0U9NAoJOzsKZXNhYwoKIyBMaW5lIGZlZWQKTEY9JwonCgojIFNpbmdsZSBxdW90ZQpTUT1cJwoKIyBVVEYtOCBaRVJPIFdJRFRIIE5PTi1KT0lORVIsIHdoaWNoIEhGUysgaWdub3JlcwojIHdoZW4gY2FzZS1mb2xkaW5nIGZpbGVuYW1lcwp1MjAwYz0kKHByaW50ZiAnXDM0MlwyMDBcMjE0JykKCmV4cG9ydCBfeDA1IF94MzUgTEYgdTIwMGMgRU1QVFlfVFJFRSBFTVBUWV9CTE9CIFpFUk9fT0lEIE9JRF9SRUdFWAoKdGVzdCAieCRURVJNIiAhPSAieGR1bWIiICYmICgKCQl0ZXN0IC10IDEgJiYKCQl0cHV0IGJvbGQgPi9kZXYvbnVsbCAyPiYxICYmCgkJdHB1dCBzZXRhZiAxID4vZGV2L251bGwgMj4mMSAmJgoJCXRwdXQgc2dyMCA+L2Rldi9udWxsIDI+JjEKCSkgJiYKCWNvbG9yPXQKCmlmIHRlc3QgLW4gIiRjb2xvciIKdGhlbgoJIyBTYXZlIHRoZSBjb2xvciBjb250cm9sIHNlcXVlbmNlcyBub3cgcmF0aGVyIHRoYW4gcnVuIHRwdXQKCSMgZWFjaCB0aW1lIHNheV9jb2xvcigpIGlzIGNhbGxlZC4gIFRoaXMgaXMgZG9uZSBmb3IgdHdvCgkjIHJlYXNvbnM6CgkjICAgKiBURVJNIHdpbGwgYmUgY2hhbmdlZCB0byBkdW1iCgkjICAgKiBIT01FIHdpbGwgYmUgY2hhbmdlZCB0byBhIHRlbXBvcmFyeSBkaXJlY3RvcnkgYW5kIHRwdXQKCSMgICAgIG1pZ2h0IG5lZWQgdG8gcmVhZCB+Ly50ZXJtaW5mbyBmcm9tIHRoZSBvcmlnaW5hbCBIT01FCgkjICAgICBkaXJlY3RvcnkgdG8gZ2V0IHRoZSBjb250cm9sIHNlcXVlbmNlcwoJIyBOb3RlOiAgVGhpcyBhcHByb2FjaCBhc3N1bWVzIHRoZSBjb250cm9sIHNlcXVlbmNlcyBkb24ndCBlbmQKCSMgaW4gYSBuZXdsaW5lIGZvciBhbnkgdGVybWluYWwgb2YgaW50ZXJlc3QgKGNvbW1hbmQKCSMgc3Vic3RpdHV0aW9ucyBzdHJpcCB0cmFpbGluZyBuZXdsaW5lcykuICBHaXZlbiB0aGF0IG1vc3QKCSMgKGFsbD8pIHRlcm1pbmFscyBpbiBjb21tb24gdXNlIGFyZSByZWxhdGVkIHRvIEVDTUEtNDgsIHRoaXMKCSMgc2hvdWxkbid0IGJlIGEgcHJvYmxlbS4KCXNheV9jb2xvcl9lcnJvcj0kKHRwdXQgYm9sZDsgdHB1dCBzZXRhZiAxKSAjIGJvbGQgcmVkCglzYXlfY29sb3Jfc2tpcD0kKHRwdXQgc2V0YWYgNCkgIyBibHVlCglzYXlfY29sb3Jfd2Fybj0kKHRwdXQgc2V0YWYgMykgIyBicm93bi95ZWxsb3cKCXNheV9jb2xvcl9wYXNzPSQodHB1dCBzZXRhZiAyKSAjIGdyZWVuCglzYXlfY29sb3JfaW5mbz0kKHRwdXQgc2V0YWYgNikgIyBjeWFuCglzYXlfY29sb3JfcmVzZXQ9JCh0cHV0IHNncjApCglzYXlfY29sb3JfPSIiICMgbm8gZm9ybWF0dGluZyBmb3Igbm9ybWFsIHRleHQKCXNheV9jb2xvciAoKSB7CgkJdGVzdCAteiAiJDEiICYmIHRlc3QgLW4gIiRxdWlldCIgJiYgcmV0dXJuCgkJZXZhbCAic2F5X2NvbG9yX2NvbG9yPVwkc2F5X2NvbG9yXyQxIgoJCXNoaWZ0CgkJcHJpbnRmICIlc1xcbiIgIiRzYXlfY29sb3JfY29sb3IkKiRzYXlfY29sb3JfcmVzZXQiCgl9CmVsc2UKCXNheV9jb2xvcigpIHsKCQl0ZXN0IC16ICIkMSIgJiYgdGVzdCAtbiAiJHF1aWV0IiAmJiByZXR1cm4KCQlzaGlmdAoJCXByaW50ZiAiJXNcbiIgIiQqIgoJfQpmaQoKVVNFUl9URVJNPSIkVEVSTSIKVEVSTT1kdW1iCmV4cG9ydCBURVJNIFVTRVJfVEVSTQoKIyBXaGF0IGlzIHdyaXR0ZW4gYnkgdGVzdHMgdG8gc3Rkb3V0IGFuZCBzdGRlcnIgaXMgc2VudCB0byBkaWZmZXJlbnQgcGxhY2VzCiMgZGVwZW5kaW5nIG9uIHRoZSB0ZXN0IG1vZGUgKGUuZy4gL2Rldi9udWxsIGluIG5vbi12ZXJib3NlIG1vZGUsIHBpcGVkIHRvIHRlZQojIHdpdGggLS10ZWUgb3B0aW9uLCBldGMuKS4gV2Ugc2F2ZSB0aGUgb3JpZ2luYWwgc3RkaW4gdG8gRkQgIzYgYW5kIHN0ZG91dCBhbmQKIyBzdGRlcnIgdG8gIzUgYW5kICM3LCBzbyB0aGF0IHRoZSB0ZXN0IGZyYW1ld29yayBjYW4gdXNlIHRoZW0gKGUuZy4gZm9yCiMgcHJpbnRpbmcgZXJyb3JzIHdpdGhpbiB0aGUgdGVzdCBmcmFtZXdvcmspIGluZGVwZW5kZW50bHkgb2YgdGhlIHRlc3QgbW9kZS4KZXhlYyA1PiYxCmV4ZWMgNjwmMApleGVjIDc+JjIKCl9lcnJvcl9leGl0ICgpIHsKCWZpbmFsaXplX3Rlc3Rfb3V0cHV0CglHSVRfRVhJVF9PSz10CglleGl0IDEKfQoKZXJyb3IgKCkgewoJc2F5X2NvbG9yIGVycm9yICJlcnJvcjogJCoiCglfZXJyb3JfZXhpdAp9CgpCVUcgKCkgewoJZXJyb3IgPiY3ICJidWcgaW4gdGhlIHRlc3Qgc2NyaXB0OiAkKiIKfQoKQkFJTF9PVVQgKCkgewoJdGVzdCAkIyAtbmUgMSAmJiBCVUcgIjEgcGFyYW0iCgoJIyBEbyBub3QgY2hhbmdlICJCYWlsIG91dCEgIiBzdHJpbmcuIEl0J3MgcGFydCBvZiBUQVAgc3ludGF4OgoJIyBodHRwczovL3Rlc3Rhbnl0aGluZy5vcmcvdGFwLXNwZWNpZmljYXRpb24uaHRtbAoJbG9jYWwgYmFpbF9vdXQ9IkJhaWwgb3V0ISAiCglsb2NhbCBtZXNzYWdlPSIkMSIKCglzYXlfY29sb3IgPiY1IGVycm9yICRiYWlsX291dCAiJG1lc3NhZ2UiCglfZXJyb3JfZXhpdAp9CgpzYXkgKCkgewoJc2F5X2NvbG9yIGluZm8gIiQqIgp9CgppZiB0ZXN0IC1uICIkSEFSTkVTU19BQ1RJVkUiCnRoZW4KCWlmIHRlc3QgIiR2ZXJib3NlIiA9IHQgfHwgdGVzdCAtbiAiJHZlcmJvc2Vfb25seSIKCXRoZW4KCQlCQUlMX09VVCAndmVyYm9zZSBtb2RlIGZvcmJpZGRlbiB1bmRlciBUQVAgaGFybmVzczsgdHJ5IC0tdmVyYm9zZS1sb2cnCglmaQpmaQoKdGVzdCAiJHt0ZXN0X2Rlc2NyaXB0aW9ufSIgIT0gIiIgfHwKZXJyb3IgIlRlc3Qgc2NyaXB0IGRpZCBub3Qgc2V0IHRlc3RfZGVzY3JpcHRpb24uIgoKaWYgdGVzdCAiJGhlbHAiID0gInQiCnRoZW4KCXByaW50ZiAnJXNcbicgIiR0ZXN0X2Rlc2NyaXB0aW9uIgoJZXhpdCAwCmZpCgppZiB0ZXN0ICIkdmVyYm9zZV9sb2ciID0gInQiCnRoZW4KCWV4ZWMgMz4+IiRHSVRfVEVTVF9URUVfT1VUUFVUX0ZJTEUiIDQ+JjMKZWxpZiB0ZXN0ICIkdmVyYm9zZSIgPSAidCIKdGhlbgoJZXhlYyA0PiYyIDM+JjEKZWxzZQoJZXhlYyA0Pi9kZXYvbnVsbCAzPi9kZXYvbnVsbApmaQoKIyBTZW5kIGFueSAiLXgiIG91dHB1dCBkaXJlY3RseSB0byBzdGRlcnIgdG8gYXZvaWQgcG9sbHV0aW5nIHRlc3RzCiMgd2hpY2ggY2FwdHVyZSBzdGRlcnIuIFdlIGNhbiBkbyB0aGlzIHVuY29uZGl0aW9uYWxseSBzaW5jZSBpdAojIGhhcyBubyBlZmZlY3QgaWYgdHJhY2luZyBpc24ndCB0dXJuZWQgb24uCiMKIyBOb3RlIHRoYXQgdGhpcyBzZXRzIHVwIHRoZSB0cmFjZSBmZCBhcyBzb29uIGFzIHdlIGFzc2lnbiB0aGUgdmFyaWFibGUsIHNvIGl0CiMgbXVzdCBjb21lIGFmdGVyIHRoZSBjcmVhdGlvbiBvZiBkZXNjcmlwdG9yIDQgYWJvdmUuIExpa2V3aXNlLCB3ZSBtdXN0IG5ldmVyCiMgdW5zZXQgdGhpcywgYXMgaXQgaGFzIHRoZSBzaWRlIGVmZmVjdCBvZiBjbG9zaW5nIGRlc2NyaXB0b3IgNCwgd2hpY2ggd2UKIyB1c2UgdG8gc2hvdyB2ZXJib3NlIHRlc3RzIHRvIHRoZSB1c2VyLgojCiMgTm90ZSBhbHNvIHRoYXQgd2UgZG9uJ3QgbmVlZCBvciB3YW50IHRvIGV4cG9ydCBpdC4gVGhlIHRyYWNpbmcgaXMgbG9jYWwgdG8KIyB0aGlzIHNoZWxsLCBhbmQgd2Ugd291bGQgbm90IHdhbnQgdG8gaW5mbHVlbmNlIGFueSBzaGVsbHMgd2UgZXhlYy4KQkFTSF9YVFJBQ0VGRD00Cgp0ZXN0X2ZhaWx1cmU9MAp0ZXN0X2NvdW50PTAKdGVzdF9maXhlZD0wCnRlc3RfYnJva2VuPTAKdGVzdF9zdWNjZXNzPTAKCnRlc3RfbWlzc2luZ19wcmVyZXE9Cgp0ZXN0X2V4dGVybmFsX2hhc190YXA9MAoKZGllICgpIHsKCWNvZGU9JD8KCSMgVGhpcyBpcyByZXNwb25zaWJsZSBmb3IgcnVubmluZyB0aGUgYXRleGl0IGNvbW1hbmRzIGV2ZW4gd2hlbiBhCgkjIHRlc3Qgc2NyaXB0IHJ1biB3aXRoICctLWltbWVkaWF0ZScgZmFpbHMsIG9yIHdoZW4gdGhlIHVzZXIgaGl0cwoJIyBjdHJsLUMsIGkuZS4gd2hlbiAndGVzdF9kb25lJyBpcyBub3QgaW52b2tlZCBhdCBhbGwuCgl0ZXN0X2F0ZXhpdF9oYW5kbGVyIHx8IGNvZGU9JD8KCWlmIHRlc3QgLW4gIiRHSVRfRVhJVF9PSyIKCXRoZW4KCQlleGl0ICRjb2RlCgllbHNlCgkJZWNobyA+JjUgIkZBVEFMOiBVbmV4cGVjdGVkIGV4aXQgd2l0aCBjb2RlICRjb2RlIgoJCWV4aXQgMQoJZmkKfQoKR0lUX0VYSVRfT0s9CnRyYXAgJ2RpZScgRVhJVAojIERpc2FibGUgJy14JyB0cmFjaW5nLCBiZWNhdXNlIHdpdGggc29tZSBzaGVsbHMsIG5vdGFibHkgZGFzaCwgaXQKIyBwcmV2ZW50cyBydW5uaW5nIHRoZSBjbGVhbnVwIGNvbW1hbmRzIHdoZW4gYSB0ZXN0IHNjcmlwdCBydW4gd2l0aAojICctLXZlcmJvc2UtbG9nIC14JyBpcyBpbnRlcnJ1cHRlZC4KdHJhcCAneyBjb2RlPSQ/OyBzZXQgK3g7IH0gMj4vZGV2L251bGw7IGV4aXQgJGNvZGUnIElOVCBURVJNIEhVUAoKIyBUaGUgdXNlci1mYWNpbmcgZnVuY3Rpb25zIGFyZSBsb2FkZWQgZnJvbSBhIHNlcGFyYXRlIGZpbGUgc28gdGhhdAojIHRlc3RfcGVyZiBzdWJzaGVsbHMgY2FuIGhhdmUgdGhlbSB0b28KLiAiJFRFU1RfRElSRUNUT1JZL3Rlc3QtbGliLWZ1bmN0aW9ucy5zaCIKCiMgWW91IGFyZSBub3QgZXhwZWN0ZWQgdG8gY2FsbCB0ZXN0X29rXyBhbmQgdGVzdF9mYWlsdXJlXyBkaXJlY3RseSwgdXNlCiMgdGhlIHRlc3RfZXhwZWN0XyogZnVuY3Rpb25zIGluc3RlYWQuCgp0ZXN0X29rXyAoKSB7Cgl0ZXN0X3N1Y2Nlc3M9JCgoJHRlc3Rfc3VjY2VzcyArIDEpKQoJc2F5X2NvbG9yICIiICJvayAkdGVzdF9jb3VudCAtICRAIgoJZmluYWxpemVfdGVzdF9jYXNlX291dHB1dCBvayAiJEAiCn0KCl9pbnZlcnRfZXhpdF9jb2RlX2ZhaWx1cmVfZW5kX2JsdXJiICgpIHsKCXNheV9jb2xvciB3YXJuICIjIGZha2VkIHVwIGZhaWx1cmVzIGFzIFRPRE8gJiBub3cgZXhpdGluZyB3aXRoIDAgZHVlIHRvIC0taW52ZXJ0LWV4aXQtY29kZSIKfQoKdGVzdF9mYWlsdXJlXyAoKSB7CglmYWlsdXJlX2xhYmVsPSQxCgl0ZXN0X2ZhaWx1cmU9JCgoJHRlc3RfZmFpbHVyZSArIDEpKQoJbG9jYWwgcGZ4PSIiCglpZiB0ZXN0IC1uICIkaW52ZXJ0X2V4aXRfY29kZSIgIyAmJiB0ZXN0IC1uICIkSEFSTkVTU19BQ1RJVkUiCgl0aGVuCgkJcGZ4PSIjIFRPRE8gaW5kdWNlZCBicmVha2FnZSAoLS1pbnZlcnQtZXhpdC1jb2RlKToiCglmaQoJc2F5X2NvbG9yIGVycm9yICJub3Qgb2sgJHRlc3RfY291bnQgLSAke3BmeDorJHBmeCB9JDEiCglzaGlmdAoJcHJpbnRmICclc1xuJyAiJCoiIHwgc2VkIC1lICdzL14vIwkvJwoJaWYgdGVzdCAtbiAiJGltbWVkaWF0ZSIKCXRoZW4KCQlzYXlfY29sb3IgZXJyb3IgIjEuLiR0ZXN0X2NvdW50IgoJCWlmIHRlc3QgLW4gIiRpbnZlcnRfZXhpdF9jb2RlIgoJCXRoZW4KCQkJZmluYWxpemVfdGVzdF9vdXRwdXQKCQkJX2ludmVydF9leGl0X2NvZGVfZmFpbHVyZV9lbmRfYmx1cmIKCQkJR0lUX0VYSVRfT0s9dAoJCQlleGl0IDAKCQlmaQoJCV9lcnJvcl9leGl0CglmaQoJZmluYWxpemVfdGVzdF9jYXNlX291dHB1dCBmYWlsdXJlICIkZmFpbHVyZV9sYWJlbCIgIiRAIgp9Cgp0ZXN0X2tub3duX2Jyb2tlbl9va18gKCkgewoJdGVzdF9maXhlZD0kKCgkdGVzdF9maXhlZCsxKSkKCXNheV9jb2xvciBlcnJvciAib2sgJHRlc3RfY291bnQgLSAkMSAjIFRPRE8ga25vd24gYnJlYWthZ2UgdmFuaXNoZWQiCglmaW5hbGl6ZV90ZXN0X2Nhc2Vfb3V0cHV0IGZpeGVkICIkMSIKfQoKdGVzdF9rbm93bl9icm9rZW5fZmFpbHVyZV8gKCkgewoJdGVzdF9icm9rZW49JCgoJHRlc3RfYnJva2VuKzEpKQoJc2F5X2NvbG9yIHdhcm4gIm5vdCBvayAkdGVzdF9jb3VudCAtICQxICMgVE9ETyBrbm93biBicmVha2FnZSIKCWZpbmFsaXplX3Rlc3RfY2FzZV9vdXRwdXQgYnJva2VuICIkMSIKfQoKdGVzdF9kZWJ1ZyAoKSB7Cgl0ZXN0ICIkZGVidWciID0gIiIgfHwgZXZhbCAiJDEiCn0KCm1hdGNoX3BhdHRlcm5fbGlzdCAoKSB7Cglhcmc9IiQxIgoJc2hpZnQKCXRlc3QgLXogIiQqIiAmJiByZXR1cm4gMQoJIyBXZSBuZWVkIHRvIHVzZSAiJCoiIHRvIGdldCBmaWVsZC1zcGxpdHRpbmcsIGJ1dCB3ZSB3YW50IHRvCgkjIGRpc2FibGUgZ2xvYmJpbmcsIHNpbmNlIHdlIGFyZSBtYXRjaGluZyBhZ2FpbnN0IGFuIGFyYml0cmFyeQoJIyAkYXJnLCBub3Qgd2hhdCdzIGluIHRoZSBmaWxlc3lzdGVtLiBVc2luZyAic2V0IC1mIiBhY2NvbXBsaXNoZXMKCSMgdGhhdCwgYnV0IHdlIG11c3QgZG8gaXQgaW4gYSBzdWJzaGVsbCB0byBhdm9pZCBpbXBhY3RpbmcgdGhlCgkjIHJlc3Qgb2YgdGhlIHNjcmlwdC4gVGhlIGV4aXQgdmFsdWUgb2YgdGhlIHN1YnNoZWxsIGJlY29tZXMKCSMgdGhlIGZ1bmN0aW9uJ3MgcmV0dXJuIHZhbHVlLgoJKAoJCXNldCAtZgoJCWZvciBwYXR0ZXJuXyBpbiAkKgoJCWRvCgkJCWNhc2UgIiRhcmciIGluCgkJCSRwYXR0ZXJuXykKCQkJCWV4aXQgMAoJCQkJOzsKCQkJZXNhYwoJCWRvbmUKCQlleGl0IDEKCSkKfQoKbWF0Y2hfdGVzdF9zZWxlY3Rvcl9saXN0ICgpIHsKCW9wZXJhdGlvbj0iJDEiCglzaGlmdAoJdGl0bGU9IiQxIgoJc2hpZnQKCWFyZz0iJDEiCglzaGlmdAoJdGVzdCAteiAiJDEiICYmIHJldHVybiAwCgoJIyBDb21tYXMgYXJlIGFjY2VwdGVkIGFzIHNlcGFyYXRvcnMuCglPTERJRlM9JElGUwoJSUZTPScsJwoJc2V0IC0tICQxCglJRlM9JE9MRElGUwoKCSMgSWYgdGhlIGZpcnN0IHNlbGVjdG9yIGlzIG5lZ2F0aXZlIHdlIGluY2x1ZGUgYnkgZGVmYXVsdC4KCWluY2x1ZGU9CgljYXNlICIkMSIgaW4KCQkhKikgaW5jbHVkZT10IDs7Cgllc2FjCgoJZm9yIHNlbGVjdG9yCglkbwoJCW9yaWdfc2VsZWN0b3I9JHNlbGVjdG9yCgoJCXBvc2l0aXZlPXQKCQljYXNlICIkc2VsZWN0b3IiIGluCgkJCSEqKQoJCQkJcG9zaXRpdmU9CgkJCQlzZWxlY3Rvcj0ke3NlbGVjdG9yIyM/fQoJCQkJOzsKCQllc2FjCgoJCXRlc3QgLXogIiRzZWxlY3RvciIgJiYgY29udGludWUKCgkJY2FzZSAiJHNlbGVjdG9yIiBpbgoJCQkqLSopCgkJCQlpZiBleHByICJ6JHtzZWxlY3RvciUlLSp9IiA6ICJ6WzAtOV0qW14wLTldIiA+L2Rldi9udWxsCgkJCQl0aGVuCgkJCQkJZWNobyAiZXJyb3I6ICRvcGVyYXRpb246IGludmFsaWQgbm9uLW51bWVyaWMgaW4gcmFuZ2UiIFwKCQkJCQkJInN0YXJ0OiAnJG9yaWdfc2VsZWN0b3InIiA+JjIKCQkJCQlleGl0IDEKCQkJCWZpCgkJCQlpZiBleHByICJ6JHtzZWxlY3RvciMqLX0iIDogInpbMC05XSpbXjAtOV0iID4vZGV2L251bGwKCQkJCXRoZW4KCQkJCQllY2hvICJlcnJvcjogJG9wZXJhdGlvbjogaW52YWxpZCBub24tbnVtZXJpYyBpbiByYW5nZSIgXAoJCQkJCQkiZW5kOiAnJG9yaWdfc2VsZWN0b3InIiA+JjIKCQkJCQlleGl0IDEKCQkJCWZpCgkJCQk7OwoJCQkqKQoJCQkJaWYgZXhwciAieiRzZWxlY3RvciIgOiAielswLTldKlteMC05XSIgPi9kZXYvbnVsbAoJCQkJdGhlbgoJCQkJCWNhc2UgIiR0aXRsZSIgaW4gKiR7c2VsZWN0b3J9KikKCQkJCQkJaW5jbHVkZT0kcG9zaXRpdmUKCQkJCQkJOzsKCQkJCQllc2FjCgkJCQkJY29udGludWUKCQkJCWZpCgkJZXNhYwoKCQkjIFNob3J0IGN1dCBmb3IgIm9idmlvdXMiIGNhc2VzCgkJdGVzdCAteiAiJGluY2x1ZGUiICYmIHRlc3QgLXogIiRwb3NpdGl2ZSIgJiYgY29udGludWUKCQl0ZXN0IC1uICIkaW5jbHVkZSIgJiYgdGVzdCAtbiAiJHBvc2l0aXZlIiAmJiBjb250aW51ZQoKCQljYXNlICIkc2VsZWN0b3IiIGluCgkJCS0qKQoJCQkJaWYgdGVzdCAkYXJnIC1sZSAke3NlbGVjdG9yIy19CgkJCQl0aGVuCgkJCQkJaW5jbHVkZT0kcG9zaXRpdmUKCQkJCWZpCgkJCQk7OwoJCQkqLSkKCQkJCWlmIHRlc3QgJGFyZyAtZ2UgJHtzZWxlY3RvciUtfQoJCQkJdGhlbgoJCQkJCWluY2x1ZGU9JHBvc2l0aXZlCgkJCQlmaQoJCQkJOzsKCQkJKi0qKQoJCQkJaWYgdGVzdCAke3NlbGVjdG9yJSUtKn0gLWxlICRhcmcgXAoJCQkJCSYmIHRlc3QgJGFyZyAtbGUgJHtzZWxlY3RvciMqLX0KCQkJCXRoZW4KCQkJCQlpbmNsdWRlPSRwb3NpdGl2ZQoJCQkJZmkKCQkJCTs7CgkJCSopCgkJCQlpZiB0ZXN0ICRhcmcgLWVxICRzZWxlY3RvcgoJCQkJdGhlbgoJCQkJCWluY2x1ZGU9JHBvc2l0aXZlCgkJCQlmaQoJCQkJOzsKCQllc2FjCglkb25lCgoJdGVzdCAtbiAiJGluY2x1ZGUiCn0KCm1heWJlX3RlYXJkb3duX3ZlcmJvc2UgKCkgewoJdGVzdCAteiAiJHZlcmJvc2Vfb25seSIgJiYgcmV0dXJuCglleGVjIDQ+L2Rldi9udWxsIDM+L2Rldi9udWxsCgl2ZXJib3NlPQp9CgpsYXN0X3ZlcmJvc2U9dAptYXliZV9zZXR1cF92ZXJib3NlICgpIHsKCXRlc3QgLXogIiR2ZXJib3NlX29ubHkiICYmIHJldHVybgoJaWYgbWF0Y2hfcGF0dGVybl9saXN0ICR0ZXN0X2NvdW50ICIkdmVyYm9zZV9vbmx5IgoJdGhlbgoJCWV4ZWMgND4mMiAzPiYxCgkJIyBFbWl0IGEgZGVsaW1pdGluZyBibGFuayBsaW5lIHdoZW4gZ29pbmcgZnJvbQoJCSMgbm9uLXZlcmJvc2UgdG8gdmVyYm9zZS4gIFdpdGhpbiB2ZXJib3NlIG1vZGUgdGhlCgkJIyBkZWxpbWl0ZXIgaXMgcHJpbnRlZCBieSB0ZXN0X2V4cGVjdF8qLiAgVGhlIGNob2ljZQoJCSMgb2YgdGhlIGluaXRpYWwgJGxhc3RfdmVyYm9zZSBpcyBzdWNoIHRoYXQgYmVmb3JlCgkJIyB0ZXN0IDEsIHdlIGRvIG5vdCBwcmludCBpdC4KCQl0ZXN0IC16ICIkbGFzdF92ZXJib3NlIiAmJiBlY2hvID4mMyAiIgoJCXZlcmJvc2U9dAoJZWxzZQoJCWV4ZWMgND4vZGV2L251bGwgMz4vZGV2L251bGwKCQl2ZXJib3NlPQoJZmkKCWxhc3RfdmVyYm9zZT0kdmVyYm9zZQp9CgptYXliZV90ZWFyZG93bl92YWxncmluZCAoKSB7Cgl0ZXN0IC16ICIkR0lUX1ZBTEdSSU5EIiAmJiByZXR1cm4KCUdJVF9WQUxHUklORF9FTkFCTEVEPQp9CgptYXliZV9zZXR1cF92YWxncmluZCAoKSB7Cgl0ZXN0IC16ICIkR0lUX1ZBTEdSSU5EIiAmJiByZXR1cm4KCWlmIHRlc3QgLXogIiR2YWxncmluZF9vbmx5IgoJdGhlbgoJCUdJVF9WQUxHUklORF9FTkFCTEVEPXQKCQlyZXR1cm4KCWZpCglHSVRfVkFMR1JJTkRfRU5BQkxFRD0KCWlmIG1hdGNoX3BhdHRlcm5fbGlzdCAkdGVzdF9jb3VudCAiJHZhbGdyaW5kX29ubHkiCgl0aGVuCgkJR0lUX1ZBTEdSSU5EX0VOQUJMRUQ9dAoJZmkKfQoKdHJhY2VfbGV2ZWxfPTAKd2FudF90cmFjZSAoKSB7Cgl0ZXN0ICIkdHJhY2UiID0gdCAmJiB7CgkJdGVzdCAiJHZlcmJvc2UiID0gdCB8fCB0ZXN0ICIkdmVyYm9zZV9sb2ciID0gdAoJfQp9CgojIFRoaXMgaXMgYSBzZXBhcmF0ZSBmdW5jdGlvbiBiZWNhdXNlIHNvbWUgdGVzdHMgdXNlCiMgInJldHVybiIgdG8gZW5kIGEgdGVzdF9leHBlY3Rfc3VjY2VzcyBibG9jayBlYXJseQojIChhbmQgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgcnVuIGFueSBjbGVhbnVwIGxpa2UKIyAic2V0ICt4IikuCnRlc3RfZXZhbF9pbm5lcl8gKCkgewoJIyBEbyBub3QgYWRkIGFueXRoaW5nIGV4dHJhIChpbmNsdWRpbmcgTEYpIGFmdGVyICckKicKCWV2YWwgIgoJCXdhbnRfdHJhY2UgJiYgdHJhY2VfbGV2ZWxfPSQoKCR0cmFjZV9sZXZlbF8rMSkpICYmIHNldCAteAoJCSQqIgp9Cgp0ZXN0X2V2YWxfICgpIHsKCSMgSWYgIi14IiB0cmFjaW5nIGlzIGluIGVmZmVjdCwgdGhlbiB3ZSB3YW50IHRvIGF2b2lkIHBvbGx1dGluZyBzdGRlcnIKCSMgd2l0aCBub24tdGVzdCBjb21tYW5kcy4gQnV0IG9uY2UgaW4gInNldCAteCIgbW9kZSwgd2UgY2Fubm90IHByZXZlbnQKCSMgdGhlIHNoZWxsIGZyb20gcHJpbnRpbmcgdGhlICJzZXQgK3giIHRvIHR1cm4gaXQgb2ZmIChub3IgdGhlIHNhdmluZwoJIyBvZiAkPyBiZWZvcmUgdGhhdCkuIEJ1dCB3ZSBjYW4gbWFrZSBzdXJlIHRoYXQgdGhlIG91dHB1dCBnb2VzIHRvCgkjIC9kZXYvbnVsbC4KCSMKCSMgVGhlcmUgYXJlIGEgZmV3IHN1YnRsZXRpZXMgaGVyZToKCSMKCSMgICAtIHdlIGhhdmUgdG8gcmVkaXJlY3QgZGVzY3JpcHRvciA0IGluIGFkZGl0aW9uIHRvIDIsIHRvIGNvdmVyCgkjICAgICBCQVNIX1hUUkFDRUZECgkjCgkjICAgLSB0aGUgYWN0dWFsIGV2YWwgaGFzIHRvIGNvbWUgYmVmb3JlIHRoZSByZWRpcmVjdGlvbiBibG9jayAoc2luY2UKCSMgICAgIGl0IG5lZWRzIHRvIHNlZSBkZXNjcmlwdG9yIDQgdG8gc2V0IHVwIGl0cyBzdGRlcnIpCgkjCgkjICAgLSBsaWtld2lzZSwgYW55IGVycm9yIG1lc3NhZ2Ugd2UgcHJpbnQgbXVzdCBiZSBvdXRzaWRlIHRoZSBibG9jayB0bwoJIyAgICAgYWNjZXNzIGRlc2NyaXB0b3IgNAoJIwoJIyAgIC0gY2hlY2tpbmcgJD8gaGFzIHRvIGNvbWUgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGV2YWwsIGJ1dCBpdCBtdXN0CgkjICAgICBiZSBfaW5zaWRlXyB0aGUgYmxvY2sgdG8gYXZvaWQgcG9sbHV0aW5nIHRoZSAic2V0IC14IiBvdXRwdXQKCSMKCgl0ZXN0X2V2YWxfaW5uZXJfICIkQCIgPC9kZXYvbnVsbCA+JjMgMj4mNAoJewoJCXRlc3RfZXZhbF9yZXRfPSQ/CgkJaWYgd2FudF90cmFjZQoJCXRoZW4KCQkJdGVzdCAxID0gJHRyYWNlX2xldmVsXyAmJiBzZXQgK3gKCQkJdHJhY2VfbGV2ZWxfPSQoKCR0cmFjZV9sZXZlbF8tMSkpCgkJZmkKCX0gMj4vZGV2L251bGwgND4mMgoKCWlmIHRlc3QgIiR0ZXN0X2V2YWxfcmV0XyIgIT0gMCAmJiB3YW50X3RyYWNlCgl0aGVuCgkJc2F5X2NvbG9yIGVycm9yID4mNCAiZXJyb3I6IGxhc3QgY29tbWFuZCBleGl0ZWQgd2l0aCBcJD89JHRlc3RfZXZhbF9yZXRfIgoJZmkKCXJldHVybiAkdGVzdF9ldmFsX3JldF8KfQoKZmFpbF8xMTcgKCkgewoJcmV0dXJuIDExNwp9Cgp0ZXN0X3J1bl8gKCkgewoJdGVzdF9jbGVhbnVwPToKCWV4cGVjdGluZ19mYWlsdXJlPSQyCgoJaWYgdGVzdCAiJHtHSVRfVEVTVF9DSEFJTl9MSU5UOi0xfSIgIT0gMDsgdGhlbgoJCSMgdHVybiBvZmYgdHJhY2luZyBmb3IgdGhpcyB0ZXN0LWV2YWwsIGFzIGl0IHNpbXBseSBjcmVhdGVzCgkJIyBjb25mdXNpbmcgbm9pc2UgaW4gdGhlICIteCIgb3V0cHV0CgkJdHJhY2VfdG1wPSR0cmFjZQoJCXRyYWNlPQoJCSMgMTE3IGlzIG1hZ2ljIGJlY2F1c2UgaXQgaXMgdW5saWtlbHkgdG8gbWF0Y2ggdGhlIGV4aXQKCQkjIGNvZGUgb2Ygb3RoZXIgcHJvZ3JhbXMKCQl0ZXN0X2V2YWxfICJmYWlsXzExNyAmJiAkMSIKCQlpZiB0ZXN0ICQ/ICE9IDExNwoJCXRoZW4KCQkJQlVHICJicm9rZW4gJiYtY2hhaW46ICQxIgoJCWZpCgkJdHJhY2U9JHRyYWNlX3RtcAoJZmkKCglzZXR1cF9tYWxsb2NfY2hlY2sKCXRlc3RfZXZhbF8gIiQxIgoJZXZhbF9yZXQ9JD8KCXRlYXJkb3duX21hbGxvY19jaGVjawoKCWlmIHRlc3QgLXogIiRpbW1lZGlhdGUiIHx8IHRlc3QgJGV2YWxfcmV0ID0gMCB8fAoJICAgdGVzdCAtbiAiJGV4cGVjdGluZ19mYWlsdXJlIiAmJiB0ZXN0ICIkdGVzdF9jbGVhbnVwIiAhPSAiOiIKCXRoZW4KCQlzZXR1cF9tYWxsb2NfY2hlY2sKCQl0ZXN0X2V2YWxfICIkdGVzdF9jbGVhbnVwIgoJCXRlYXJkb3duX21hbGxvY19jaGVjawoJZmkKCWlmIHRlc3QgIiR2ZXJib3NlIiA9ICJ0IiAmJiB0ZXN0IC1uICIkSEFSTkVTU19BQ1RJVkUiCgl0aGVuCgkJZWNobyAiIgoJZmkKCXJldHVybiAiJGV2YWxfcmV0Igp9Cgp0ZXN0X3N0YXJ0XyAoKSB7Cgl0ZXN0X2NvdW50PSQoKCR0ZXN0X2NvdW50KzEpKQoJbWF5YmVfc2V0dXBfdmVyYm9zZQoJbWF5YmVfc2V0dXBfdmFsZ3JpbmQKCXN0YXJ0X3Rlc3RfY2FzZV9vdXRwdXQgIiRAIgp9Cgp0ZXN0X2ZpbmlzaF8gKCkgewoJZWNobyA+JjMgIiIKCW1heWJlX3RlYXJkb3duX3ZhbGdyaW5kCgltYXliZV90ZWFyZG93bl92ZXJib3NlCglpZiB0ZXN0IC1uICIkR0lUX1RFU1RfVEVFX09GRlNFVCIKCXRoZW4KCQlHSVRfVEVTVF9URUVfT0ZGU0VUPSQodGVzdC10b29sIHBhdGgtdXRpbHMgZmlsZS1zaXplIFwKCQkJIiRHSVRfVEVTVF9URUVfT1VUUFVUX0ZJTEUiKQoJZmkKfQoKdGVzdF9za2lwICgpIHsKCXRvX3NraXA9Cglza2lwcGVkX3JlYXNvbj0KCWlmIG1hdGNoX3BhdHRlcm5fbGlzdCAkdGhpc190ZXN0LiR0ZXN0X2NvdW50ICIkR0lUX1NLSVBfVEVTVFMiCgl0aGVuCgkJdG9fc2tpcD10CgkJc2tpcHBlZF9yZWFzb249IkdJVF9TS0lQX1RFU1RTIgoJZmkKCWlmIHRlc3QgLXogIiR0b19za2lwIiAmJiB0ZXN0IC1uICIkcnVuX2xpc3QiICYmCgkgICAhIG1hdGNoX3Rlc3Rfc2VsZWN0b3JfbGlzdCAnLS1ydW4nICIkMSIgJHRlc3RfY291bnQgIiRydW5fbGlzdCIKCXRoZW4KCQl0b19za2lwPXQKCQlza2lwcGVkX3JlYXNvbj0iLS1ydW4iCglmaQoJaWYgdGVzdCAteiAiJHRvX3NraXAiICYmIHRlc3QgLW4gIiR0ZXN0X3ByZXJlcSIgJiYKCSAgICEgdGVzdF9oYXZlX3ByZXJlcSAiJHRlc3RfcHJlcmVxIgoJdGhlbgoJCXRvX3NraXA9dAoKCQlvZl9wcmVyZXE9CgkJaWYgdGVzdCAiJG1pc3NpbmdfcHJlcmVxIiAhPSAiJHRlc3RfcHJlcmVxIgoJCXRoZW4KCQkJb2ZfcHJlcmVxPSIgb2YgJHRlc3RfcHJlcmVxIgoJCWZpCgkJc2tpcHBlZF9yZWFzb249Im1pc3NpbmcgJG1pc3NpbmdfcHJlcmVxJHtvZl9wcmVyZXF9IgoKCQkjIEtlZXAgYSBsaXN0IG9mIGFsbCB0aGUgbWlzc2luZyBwcmVyZXEgZm9yIHJlc3VsdCBhZ2dyZWdhdGlvbgoJCWlmIHRlc3QgLXogIiRtaXNzaW5nX3ByZXJlcSIKCQl0aGVuCgkJCXRlc3RfbWlzc2luZ19wcmVyZXE9JG1pc3NpbmdfcHJlcmVxCgkJZWxzZQoJCQl0ZXN0X21pc3NpbmdfcHJlcmVxPSIkdGVzdF9taXNzaW5nX3ByZXJlcSwkbWlzc2luZ19wcmVyZXEiCgkJZmkKCWZpCgoJY2FzZSAiJHRvX3NraXAiIGluCgl0KQoKCQlzYXlfY29sb3Igc2tpcCAib2sgJHRlc3RfY291bnQgIyBza2lwICQxICgkc2tpcHBlZF9yZWFzb24pIgoJCTogdHJ1ZQoJCWZpbmFsaXplX3Rlc3RfY2FzZV9vdXRwdXQgc2tpcCAiJEAiCgkJOzsKCSopCgkJZmFsc2UKCQk7OwoJZXNhYwp9CgojIHN0dWI7IHBlcmYtbGliIG92ZXJyaWRlcyBpdAp0ZXN0X2F0X2VuZF9ob29rXyAoKSB7Cgk6Cn0KCnRlc3RfYXRleGl0X2NsZWFudXA9Ogp0ZXN0X2F0ZXhpdF9oYW5kbGVyICgpIHsKCSMgSW4gYSBzdWNjZWVkaW5nIHRlc3Qgc2NyaXB0ICd0ZXN0X2F0ZXhpdF9oYW5kbGVyJyBpcyBpbnZva2VkCgkjIHR3aWNlOiBmaXJzdCBmcm9tICd0ZXN0X2RvbmUnLCB0aGVuIGZyb20gJ2RpZScgaW4gdGhlIHRyYXAgb24KCSMgRVhJVC4KCSMgVGhpcyBjb25kaXRpb24gYW5kIHJlc2V0dGluZyAndGVzdF9hdGV4aXRfY2xlYW51cCcgYmVsb3cgbWFrZXMKCSMgc3VyZSB0aGF0IHRoZSByZWdpc3RlcmVkIGNsZWFudXAgY29tbWFuZHMgYXJlIHJ1biBvbmx5IG9uY2UuCgl0ZXN0IDogIT0gIiR0ZXN0X2F0ZXhpdF9jbGVhbnVwIiB8fCByZXR1cm4gMAoKCXNldHVwX21hbGxvY19jaGVjawoJdGVzdF9ldmFsXyAiJHRlc3RfYXRleGl0X2NsZWFudXAiCgl0ZXN0X2F0ZXhpdF9jbGVhbnVwPToKCXRlYXJkb3duX21hbGxvY19jaGVjawp9CgpzYW5pdGl6ZV9sZWFrX2xvZ19tZXNzYWdlXyAoKSB7Cglsb2NhbCBuZXc9IiQxIiAmJgoJbG9jYWwgb2xkPSIkMiIgJiYKCWxvY2FsIGZpbGU9IiQzIiAmJgoKCXByaW50ZiAiV2l0aCBTQU5JVElaRT1sZWFrIGF0IGV4aXQgd2UgaGF2ZSAlZCBsZWFrIGxvZ3MsIGJ1dCBzdGFydGVkIHdpdGggJWQKClRoaXMgbWVhbnMgdGhhdCB3ZSBoYXZlIGEgYmxpbmRzcG90IHdoZXJlIGdpdCBpcyBsZWFraW5nIGJ1dCB3ZSdyZQpsb3NpbmcgdGhlIGV4aXQgY29kZSBzb21ld2hlcmUsIG9yIG5vdCBwcm9wYWdhdGluZyBpdCBhcHByb3ByaWF0ZWx5CnVwd2FyZHMhCgpTZWUgdGhlIGxvZ3MgYXQgXCIlcy4qXCI7CnRob3NlIGxvZ3MgYXJlIHJlcHJvZHVjZWQgYmVsb3cuIiBcCgkgICAgICAgIiRuZXciICIkb2xkIiAiJGZpbGUiCn0KCmNoZWNrX3Rlc3RfcmVzdWx0c19zYW5fZmlsZV8gKCkgewoJaWYgdGVzdCAteiAiJFRFU1RfUkVTVUxUU19TQU5fRklMRSIKCXRoZW4KCQlyZXR1cm4KCWZpICYmCglsb2NhbCBvbGQ9IiRURVNUX1JFU1VMVFNfU0FOX0RJUl9OUl9MRUFLU19TVEFSVFVQIiAmJgoJbG9jYWwgbmV3PSIkKG5yX3Nhbl9kaXJfbGVha3NfKSIgJiYKCglpZiB0ZXN0ICRuZXcgLWxlICRvbGQKCXRoZW4KCQlyZXR1cm4KCWZpICYmCglsb2NhbCBvdXQ9IiQoc2FuaXRpemVfbGVha19sb2dfbWVzc2FnZV8gIiRuZXciICIkb2xkIiAiJFRFU1RfUkVTVUxUU19TQU5fRklMRSIpIiAmJgoJc2F5X2NvbG9yIGVycm9yICIkb3V0IiAmJgoJaWYgdGVzdCAiJG9sZCIgIT0gMAoJdGhlbgoJCWVjaG8gJiYKCQlzYXlfY29sb3IgZXJyb3IgIlRoZSBsb2dzIGluY2x1ZGUgb3V0cHV0IGZyb20gcGFzdCBydW5zIHRvIGF2b2lkIiAmJgoJCXNheV9jb2xvciBlcnJvciAidGhhdCByZW1vdmUgJ3Rlc3QtcmVzdWx0cycgYmV0d2VlbiBydW5zLiIKCWZpICYmCglzYXlfY29sb3IgZXJyb3IgIiQoY2F0ICIkVEVTVF9SRVNVTFRTX1NBTl9GSUxFIi4qKSIgJiYKCglpZiB0ZXN0IC1uICIkcGFzc2VzX3Nhbml0aXplX2xlYWsiICYmIHRlc3QgIiR0ZXN0X2ZhaWx1cmUiID0gMAoJdGhlbgoJCXNheSAiQXMgVEVTVF9QQVNTRVNfU0FOSVRJWkVfTEVBSz10cnVlIGFuZCBvdXIgbG9ncyBzaG93IHdlJ3JlIGxlYWtpbmcsIGV4aXQgbm9uLXplcm8hIiAmJgoJCWludmVydF9leGl0X2NvZGU9dAoJZWxpZiB0ZXN0IC1uICIkcGFzc2VzX3Nhbml0aXplX2xlYWsiCgl0aGVuCgkJc2F5ICJBcyBURVNUX1BBU1NFU19TQU5JVElaRV9MRUFLPXRydWUgYW5kIG91ciBsb2dzIHNob3cgd2UncmUgbGVha2luZywgYW5kIHdlJ3JlIGZhaWxpbmcgZm9yIG90aGVyIHJlYXNvbnMgdG9vLi4uIiAmJgoJCWludmVydF9leGl0X2NvZGU9CgllbGlmIHRlc3QgLW4gIiRzYW5pdGl6ZV9sZWFrX2NoZWNrIiAmJiB0ZXN0ICIkdGVzdF9mYWlsdXJlIiA9IDAKCXRoZW4KCQlzYXkgIkFzIFRFU1RfUEFTU0VTX1NBTklUSVpFX0xFQUs9dHJ1ZSBpc24ndCBzZXQgdGhlIGFib3ZlIGxlYWsgaXMgJ29rJyB3aXRoIEdJVF9URVNUX1BBU1NJTkdfU0FOSVRJWkVfTEVBSz1jaGVjayIgJiYKCQlpbnZlcnRfZXhpdF9jb2RlPQoJZWxpZiB0ZXN0IC1uICIkc2FuaXRpemVfbGVha19jaGVjayIKCXRoZW4KCQlzYXkgIkFzIFRFU1RfUEFTU0VTX1NBTklUSVpFX0xFQUs9dHJ1ZSBpc24ndCBzZXQgdGhlIGFib3ZlIGxlYWsgaXMgJ29rJyB3aXRoIEdJVF9URVNUX1BBU1NJTkdfU0FOSVRJWkVfTEVBSz1jaGVjayIgJiYKCQlpbnZlcnRfZXhpdF9jb2RlPXQKCWVsc2UKCQlzYXkgIldpdGggR0lUX1RFU1RfU0FOSVRJWkVfTEVBS19MT0c9dHJ1ZSBvdXIgbG9ncyByZXZlYWxlZCBhIG1lbW9yeSBsZWFrLCBleGl0IG5vbi16ZXJvISIgJiYKCQlpbnZlcnRfZXhpdF9jb2RlPXQKCWZpCn0KCnRlc3RfZG9uZSAoKSB7CgkjIFJ1biB0aGUgYXRleGl0IGNvbW1hbmRzIF9iZWZvcmVfIHRoZSB0cmFzaCBkaXJlY3RvcnkgaXMKCSMgcmVtb3ZlZCwgc28gdGhlIGNvbW1hbmRzIGNhbiBhY2Nlc3MgcGlkZmlsZXMgYW5kIHNvY2tldCBmaWxlcy4KCXRlc3RfYXRleGl0X2hhbmRsZXIKCglmaW5hbGl6ZV90ZXN0X291dHB1dAoKCWlmIHRlc3QgLXogIiRIQVJORVNTX0FDVElWRSIKCXRoZW4KCQlta2RpciAtcCAiJFRFU1RfUkVTVUxUU19ESVIiCgoJCWNhdCA+IiRURVNUX1JFU1VMVFNfQkFTRS5jb3VudHMiIDw8LUVPRgoJCXRvdGFsICR0ZXN0X2NvdW50CgkJc3VjY2VzcyAkdGVzdF9zdWNjZXNzCgkJZml4ZWQgJHRlc3RfZml4ZWQKCQlicm9rZW4gJHRlc3RfYnJva2VuCgkJZmFpbGVkICR0ZXN0X2ZhaWx1cmUKCQltaXNzaW5nX3ByZXJlcSAkdGVzdF9taXNzaW5nX3ByZXJlcQoKCQlFT0YKCWZpCgoJaWYgdGVzdCAiJHRlc3RfZml4ZWQiICE9IDAKCXRoZW4KCQlzYXlfY29sb3IgZXJyb3IgIiMgJHRlc3RfZml4ZWQga25vd24gYnJlYWthZ2UocykgdmFuaXNoZWQ7IHBsZWFzZSB1cGRhdGUgdGVzdChzKSIKCWZpCglpZiB0ZXN0ICIkdGVzdF9icm9rZW4iICE9IDAKCXRoZW4KCQlzYXlfY29sb3Igd2FybiAiIyBzdGlsbCBoYXZlICR0ZXN0X2Jyb2tlbiBrbm93biBicmVha2FnZShzKSIKCWZpCglpZiB0ZXN0ICIkdGVzdF9icm9rZW4iICE9IDAgfHwgdGVzdCAiJHRlc3RfZml4ZWQiICE9IDAKCXRoZW4KCQl0ZXN0X3JlbWFpbmluZz0kKCggJHRlc3RfY291bnQgLSAkdGVzdF9icm9rZW4gLSAkdGVzdF9maXhlZCApKQoJCW1zZz0icmVtYWluaW5nICR0ZXN0X3JlbWFpbmluZyB0ZXN0KHMpIgoJZWxzZQoJCXRlc3RfcmVtYWluaW5nPSR0ZXN0X2NvdW50CgkJbXNnPSIkdGVzdF9jb3VudCB0ZXN0KHMpIgoJZmkKCWNhc2UgIiR0ZXN0X2ZhaWx1cmUiIGluCgkwKQoJCWlmIHRlc3QgJHRlc3RfcmVtYWluaW5nIC1ndCAwCgkJdGhlbgoJCQlzYXlfY29sb3IgcGFzcyAiIyBwYXNzZWQgYWxsICRtc2ciCgkJZmkKCgkJIyBNYXliZSBwcmludCBTS0lQIG1lc3NhZ2UKCQl0ZXN0IC16ICIkc2tpcF9hbGwiIHx8IHNraXBfYWxsPSIjIFNLSVAgJHNraXBfYWxsIgoJCWNhc2UgIiR0ZXN0X2NvdW50IiBpbgoJCTApCgkJCXNheSAiMS4uJHRlc3RfY291bnQke3NraXBfYWxsOisgJHNraXBfYWxsfSIKCQkJOzsKCQkqKQoJCQl0ZXN0IC16ICIkc2tpcF9hbGwiIHx8CgkJCXNheV9jb2xvciB3YXJuICIkc2tpcF9hbGwiCgkJCXNheSAiMS4uJHRlc3RfY291bnQiCgkJCTs7CgkJZXNhYwoKCQlpZiB0ZXN0IC1uICIkc3RyZXNzIiAmJiB0ZXN0IC1uICIkaW52ZXJ0X2V4aXRfY29kZSIKCQl0aGVuCgkJCSMgV2UncmUgYWJvdXQgdG8gbW92ZSBvdXIgIiRUUkFTSF9ESVJFQ1RPUlkiCgkJCSMgdG8gIiRUUkFTSF9ESVJFQ1RPUlkuc3RyZXNzLWZhaWxlZCIgaWYKCQkJIyAtLXN0cmVzcyBpcyBjb21iaW5lZCB3aXRoCgkJCSMgLS1pbnZlcnQtZXhpdC1jb2RlLgoJCQlzYXkgIndpdGggLS1zdHJlc3MgYW5kIC0taW52ZXJ0LWV4aXQtY29kZSB3ZSdyZSBub3QgcmVtb3ZpbmcgJyRUUkFTSF9ESVJFQ1RPUlknIgoJCWVsaWYgdGVzdCAteiAiJGRlYnVnIiAmJiB0ZXN0IC1uICIkcmVtb3ZlX3RyYXNoIgoJCXRoZW4KCQkJdGVzdCAtZCAiJFRSQVNIX0RJUkVDVE9SWSIgfHwKCQkJZXJyb3IgIlRlc3RzIHBhc3NlZCBidXQgdHJhc2ggZGlyZWN0b3J5IGFscmVhZHkgcmVtb3ZlZCBiZWZvcmUgdGVzdCBjbGVhbnVwOyBhYm9ydGluZyIKCgkJCWNkICIkVFJBU0hfRElSRUNUT1JZLy4uIiAmJgoJCQlybSAtZnIgIiRUUkFTSF9ESVJFQ1RPUlkiIHx8IHsKCQkJCSMgdHJ5IGFnYWluIGluIGEgYml0CgkJCQlzbGVlcCA1OwoJCQkJcm0gLWZyICIkVFJBU0hfRElSRUNUT1JZIgoJCQl9IHx8CgkJCWVycm9yICJUZXN0cyBwYXNzZWQgYnV0IHRlc3QgY2xlYW51cCBmYWlsZWQ7IGFib3J0aW5nIgoJCWZpCgoJCWNoZWNrX3Rlc3RfcmVzdWx0c19zYW5fZmlsZV8gIiR0ZXN0X2ZhaWx1cmUiCgoJCWlmIHRlc3QgLXogIiRza2lwX2FsbCIgJiYgdGVzdCAtbiAiJGludmVydF9leGl0X2NvZGUiCgkJdGhlbgoJCQlzYXlfY29sb3Igd2FybiAiIyBmYWtpbmcgdXAgbm9uLXplcm8gZXhpdCB3aXRoIC0taW52ZXJ0LWV4aXQtY29kZSIKCQkJR0lUX0VYSVRfT0s9dAoJCQlleGl0IDEKCQlmaQoKCQl0ZXN0X2F0X2VuZF9ob29rXwoKCQlHSVRfRVhJVF9PSz10CgkJZXhpdCAwIDs7CgoJKikKCQlzYXlfY29sb3IgZXJyb3IgIiMgZmFpbGVkICR0ZXN0X2ZhaWx1cmUgYW1vbmcgJG1zZyIKCQlzYXkgIjEuLiR0ZXN0X2NvdW50IgoKCQljaGVja190ZXN0X3Jlc3VsdHNfc2FuX2ZpbGVfICIkdGVzdF9mYWlsdXJlIgoKCQlpZiB0ZXN0IC1uICIkaW52ZXJ0X2V4aXRfY29kZSIKCQl0aGVuCgkJCV9pbnZlcnRfZXhpdF9jb2RlX2ZhaWx1cmVfZW5kX2JsdXJiCgkJCUdJVF9FWElUX09LPXQKCQkJZXhpdCAwCgkJZmkKCgkJR0lUX0VYSVRfT0s9dAoJCWV4aXQgMSA7OwoKCWVzYWMKfQoKaWYgdGVzdCAtbiAiJHZhbGdyaW5kIgp0aGVuCgltYWtlX3N5bWxpbmsgKCkgewoJCXRlc3QgLWggIiQyIiAmJgoJCXRlc3QgIiQxIiA9ICIkKHJlYWRsaW5rICIkMiIpIiB8fCB7CgkJCSMgYmUgc3VwZXIgcGFyYW5vaWQKCQkJaWYgbWtkaXIgIiQyIi5sb2NrCgkJCXRoZW4KCQkJCXJtIC1mICIkMiIgJiYKCQkJCWxuIC1zICIkMSIgIiQyIiAmJgoJCQkJcm0gLXIgIiQyIi5sb2NrCgkJCWVsc2UKCQkJCXdoaWxlIHRlc3QgLWQgIiQyIi5sb2NrCgkJCQlkbwoJCQkJCXNheSAiV2FpdGluZyBmb3IgbG9jayBvbiAkMi4iCgkJCQkJc2xlZXAgMQoJCQkJZG9uZQoJCQlmaQoJCX0KCX0KCgltYWtlX3ZhbGdyaW5kX3N5bWxpbmsgKCkgewoJCSMgaGFuZGxlIG9ubHkgZXhlY3V0YWJsZXMsIHVubGVzcyB0aGV5IGFyZSBzaGVsbCBsaWJyYXJpZXMgdGhhdAoJCSMgbmVlZCB0byBiZSBpbiB0aGUgZXhlYy1wYXRoLgoJCXRlc3QgLXggIiQxIiB8fAoJCXRlc3QgIiMgIiA9ICIkKHRlc3RfY29weV9ieXRlcyAyIDwiJDEiKSIgfHwKCQlyZXR1cm47CgoJCWJhc2U9JChiYXNlbmFtZSAiJDEiKQoJCWNhc2UgIiRiYXNlIiBpbgoJCXRlc3QtKikKCQkJc3ltbGlua190YXJnZXQ9IiRHSVRfQlVJTERfRElSL3QvaGVscGVyLyRiYXNlIgoJCQk7OwoJCSopCgkJCXN5bWxpbmtfdGFyZ2V0PSIkR0lUX0JVSUxEX0RJUi8kYmFzZSIKCQkJOzsKCQllc2FjCgkJIyBkbyBub3Qgb3ZlcnJpZGUgc2NyaXB0cwoJCWlmIHRlc3QgLXggIiRzeW1saW5rX3RhcmdldCIgJiYKCQkgICAgdGVzdCAhIC1kICIkc3ltbGlua190YXJnZXQiICYmCgkJICAgIHRlc3QgIiMhIiAhPSAiJCh0ZXN0X2NvcHlfYnl0ZXMgMiA8IiRzeW1saW5rX3RhcmdldCIpIgoJCXRoZW4KCQkJc3ltbGlua190YXJnZXQ9Li4vdmFsZ3JpbmQuc2gKCQlmaQoJCWNhc2UgIiRiYXNlIiBpbgoJCSouc2h8Ki5wZXJsKQoJCQlzeW1saW5rX3RhcmdldD0uLi91bnByb2Nlc3NlZC1zY3JpcHQKCQllc2FjCgkJIyBjcmVhdGUgdGhlIGxpbmssIG9yIHJlcGxhY2UgaXQgaWYgaXQgaXMgb3V0IG9mIGRhdGUKCQltYWtlX3N5bWxpbmsgIiRzeW1saW5rX3RhcmdldCIgIiRHSVRfVkFMR1JJTkQvYmluLyRiYXNlIiB8fCBleGl0Cgl9CgoJIyBvdmVycmlkZSBhbGwgZ2l0IGV4ZWN1dGFibGVzIGluIFRFU1RfRElSRUNUT1JZLy4uCglHSVRfVkFMR1JJTkQ9JFRFU1RfRElSRUNUT1JZL3ZhbGdyaW5kCglta2RpciAtcCAiJEdJVF9WQUxHUklORCIvYmluCglmb3IgZmlsZSBpbiAkR0lUX0JVSUxEX0RJUi9naXQqICRHSVRfQlVJTERfRElSL3QvaGVscGVyL3Rlc3QtKgoJZG8KCQltYWtlX3ZhbGdyaW5kX3N5bWxpbmsgJGZpbGUKCWRvbmUKCSMgc3BlY2lhbC1jYXNlIHRoZSBtZXJnZXRvb2xzIGxvYWRhYmxlcwoJbWFrZV9zeW1saW5rICIkR0lUX0JVSUxEX0RJUiIvbWVyZ2V0b29scyAiJEdJVF9WQUxHUklORC9iaW4vbWVyZ2V0b29scyIKCU9MRElGUz0kSUZTCglJRlM9OgoJZm9yIHBhdGggaW4gJFBBVEgKCWRvCgkJbHMgIiRwYXRoIi9naXQtKiAyPiAvZGV2L251bGwgfAoJCXdoaWxlIHJlYWQgZmlsZQoJCWRvCgkJCW1ha2VfdmFsZ3JpbmRfc3ltbGluayAiJGZpbGUiCgkJZG9uZQoJZG9uZQoJSUZTPSRPTERJRlMKCVBBVEg9JEdJVF9WQUxHUklORC9iaW46JFBBVEgKCUdJVF9FWEVDX1BBVEg9JEdJVF9WQUxHUklORC9iaW4KCWV4cG9ydCBHSVRfVkFMR1JJTkQKCUdJVF9WQUxHUklORF9NT0RFPSIkdmFsZ3JpbmQiCglleHBvcnQgR0lUX1ZBTEdSSU5EX01PREUKCUdJVF9WQUxHUklORF9FTkFCTEVEPXQKCXRlc3QgLW4gIiR2YWxncmluZF9vbmx5IiAmJiBHSVRfVkFMR1JJTkRfRU5BQkxFRD0KCWV4cG9ydCBHSVRfVkFMR1JJTkRfRU5BQkxFRAplbGlmIHRlc3QgLW4gIiRHSVRfVEVTVF9JTlNUQUxMRUQiCnRoZW4KCUdJVF9FWEVDX1BBVEg9JCgkR0lUX1RFU1RfSU5TVEFMTEVEL2dpdCAtLWV4ZWMtcGF0aCkgIHx8CgllcnJvciAiQ2Fubm90IHJ1biBnaXQgZnJvbSAkR0lUX1RFU1RfSU5TVEFMTEVELiIKCVBBVEg9JEdJVF9URVNUX0lOU1RBTExFRDokR0lUX0JVSUxEX0RJUi90L2hlbHBlcjokUEFUSAoJR0lUX0VYRUNfUEFUSD0ke0dJVF9URVNUX0VYRUNfUEFUSDotJEdJVF9FWEVDX1BBVEh9CmVsc2UgIyBub3JtYWwgY2FzZSwgdXNlIC4uL2Jpbi13cmFwcGVycyBvbmx5IHVubGVzcyAkd2l0aF9kYXNoZXM6CglpZiB0ZXN0IC1uICIkbm9fYmluX3dyYXBwZXJzIgoJdGhlbgoJCXdpdGhfZGFzaGVzPXQKCWVsc2UKCQlnaXRfYmluX2Rpcj0iJEdJVF9CVUlMRF9ESVIvYmluLXdyYXBwZXJzIgoJCWlmICEgdGVzdCAteCAiJGdpdF9iaW5fZGlyL2dpdCIKCQl0aGVuCgkJCWlmIHRlc3QgLXogIiR3aXRoX2Rhc2hlcyIKCQkJdGhlbgoJCQkJc2F5ICIkZ2l0X2Jpbl9kaXIvZ2l0IGlzIG5vdCBleGVjdXRhYmxlOyB1c2luZyBHSVRfRVhFQ19QQVRIIgoJCQlmaQoJCQl3aXRoX2Rhc2hlcz10CgkJZmkKCQlQQVRIPSIkZ2l0X2Jpbl9kaXI6JFBBVEgiCglmaQoJR0lUX0VYRUNfUEFUSD0kR0lUX0JVSUxEX0RJUgoJaWYgdGVzdCAtbiAiJHdpdGhfZGFzaGVzIgoJdGhlbgoJCVBBVEg9IiRHSVRfQlVJTERfRElSOiRHSVRfQlVJTERfRElSL3QvaGVscGVyOiRQQVRIIgoJZmkKZmkKR0lUX1RFTVBMQVRFX0RJUj0iJEdJVF9CVUlMRF9ESVIiL3RlbXBsYXRlcy9ibHQKR0lUX0NPTkZJR19OT1NZU1RFTT0xCkdJVF9BVFRSX05PU1lTVEVNPTEKR0lUX0NFSUxJTkdfRElSRUNUT1JJRVM9IiRUUkFTSF9ESVJFQ1RPUlkvLi4iCmV4cG9ydCBQQVRIIEdJVF9FWEVDX1BBVEggR0lUX1RFTVBMQVRFX0RJUiBHSVRfQ09ORklHX05PU1lTVEVNIEdJVF9BVFRSX05PU1lTVEVNIEdJVF9DRUlMSU5HX0RJUkVDVE9SSUVTCgppZiB0ZXN0IC16ICIkR0lUX1RFU1RfQ01QIgp0aGVuCglpZiB0ZXN0IC1uICIkR0lUX1RFU1RfQ01QX1VTRV9DT1BJRURfQ09OVEVYVCIKCXRoZW4KCQlHSVRfVEVTVF9DTVA9IiRESUZGIC1jIgoJZWxzZQoJCUdJVF9URVNUX0NNUD0iJERJRkYgLXUiCglmaQpmaQoKR0lUUEVSTExJQj0iJEdJVF9CVUlMRF9ESVIiL3BlcmwvYnVpbGQvbGliCmV4cG9ydCBHSVRQRVJMTElCCnRlc3QgLWQgIiRHSVRfQlVJTERfRElSIi90ZW1wbGF0ZXMvYmx0IHx8IHsKCUJBSUxfT1VUICJZb3UgaGF2ZW4ndCBidWlsdCB0aGluZ3MgeWV0LCBoYXZlIHlvdT8iCn0KCmlmICEgdGVzdCAteCAiJEdJVF9CVUlMRF9ESVIiL3QvaGVscGVyL3Rlc3QtdG9vbCRYCnRoZW4KCUJBSUxfT1VUICdZb3UgbmVlZCB0byBidWlsZCB0ZXN0LXRvb2w7IFJ1biAibWFrZSB0L2hlbHBlci90ZXN0LXRvb2wiIGluIHRoZSBzb3VyY2UgKHRvcGxldmVsKSBkaXJlY3RvcnknCmZpCgojIEFyZSB3ZSBydW5uaW5nIHRoaXMgdGVzdCBhdCBhbGw/CnJlbW92ZV90cmFzaD0KdGhpc190ZXN0PSR7MCMjKi99CnRoaXNfdGVzdD0ke3RoaXNfdGVzdCUlLSp9CmlmIG1hdGNoX3BhdHRlcm5fbGlzdCAiJHRoaXNfdGVzdCIgIiRHSVRfU0tJUF9URVNUUyIKdGhlbgoJc2F5X2NvbG9yIGluZm8gPiYzICJza2lwcGluZyB0ZXN0ICR0aGlzX3Rlc3QgYWx0b2dldGhlciIKCXNraXBfYWxsPSJza2lwIGFsbCB0ZXN0cyBpbiAkdGhpc190ZXN0IgoJdGVzdF9kb25lCmZpCgpCQUlMX09VVF9FTlZfTkVFRFNfU0FOSVRJWkVfTEVBSyAoKSB7CglCQUlMX09VVCAiJDEgaGFzIG5vIGVmZmVjdCBleGNlcHQgd2hlbiBjb21waWxlZCB3aXRoIFNBTklUSVpFPWxlYWsiCn0KCmlmIHRlc3QgLW4gIiRTQU5JVElaRV9MRUFLIgp0aGVuCgkjIE5vcm1hbGl6ZSB3aXRoIHRlc3RfYm9vbF9lbnYKCXBhc3Nlc19zYW5pdGl6ZV9sZWFrPQoKCSMgV2UgbmVlZCB0byBzZWUgVEVTVF9QQVNTRVNfU0FOSVRJWkVfTEVBSyBpbiAidGVzdC10b29sCgkjIGVudi1oZWxwZXIiICh2aWEgdGVzdF9ib29sX2VudikKCWV4cG9ydCBURVNUX1BBU1NFU19TQU5JVElaRV9MRUFLCglpZiB0ZXN0X2Jvb2xfZW52IFRFU1RfUEFTU0VTX1NBTklUSVpFX0xFQUsgZmFsc2UKCXRoZW4KCQlwYXNzZXNfc2FuaXRpemVfbGVhaz10CglmaQoKCWlmIHRlc3QgIiRHSVRfVEVTVF9QQVNTSU5HX1NBTklUSVpFX0xFQUsiID0gImNoZWNrIgoJdGhlbgoJCXNhbml0aXplX2xlYWtfY2hlY2s9dAoJCWlmIHRlc3QgLW4gIiRpbnZlcnRfZXhpdF9jb2RlIgoJCXRoZW4KCQkJQkFJTF9PVVQgImNhbm5vdCB1c2UgLS1pbnZlcnQtZXhpdC1jb2RlIHVuZGVyIEdJVF9URVNUX1BBU1NJTkdfU0FOSVRJWkVfTEVBSz1jaGVjayIKCQlmaQoKCQlpZiB0ZXN0IC16ICIkcGFzc2VzX3Nhbml0aXplX2xlYWsiCgkJdGhlbgoJCQlzYXkgImluIEdJVF9URVNUX1BBU1NJTkdfU0FOSVRJWkVfTEVBSz1jaGVjayBtb2RlLCBzZXR0aW5nIC0taW52ZXJ0LWV4aXQtY29kZSBmb3IgVEVTVF9QQVNTRVNfU0FOSVRJWkVfTEVBSyAhPSB0cnVlIgoJCQlpbnZlcnRfZXhpdF9jb2RlPXQKCQlmaQoJZWxpZiB0ZXN0IC16ICIkcGFzc2VzX3Nhbml0aXplX2xlYWsiICYmCgkgICAgIHRlc3RfYm9vbF9lbnYgR0lUX1RFU1RfUEFTU0lOR19TQU5JVElaRV9MRUFLIGZhbHNlCgl0aGVuCgkJc2tpcF9hbGw9InNraXBwaW5nICR0aGlzX3Rlc3QgdW5kZXIgR0lUX1RFU1RfUEFTU0lOR19TQU5JVElaRV9MRUFLPXRydWUiCgkJdGVzdF9kb25lCglmaQoKCWlmIHRlc3RfYm9vbF9lbnYgR0lUX1RFU1RfU0FOSVRJWkVfTEVBS19MT0cgZmFsc2UKCXRoZW4KCQlpZiAhIG1rZGlyIC1wICIkVEVTVF9SRVNVTFRTX1NBTl9ESVIiCgkJdGhlbgoJCQlCQUlMX09VVCAiY2Fubm90IGNyZWF0ZSAkVEVTVF9SRVNVTFRTX1NBTl9ESVIiCgkJZmkgJiYKCQlURVNUX1JFU1VMVFNfU0FOX0ZJTEU9IiRURVNUX1JFU1VMVFNfU0FOX0RJUi8kVEVTVF9SRVNVTFRTX1NBTl9GSUxFX1BGWCIKCgkJIyBJbiBjYXNlICJ0ZXN0LXJlc3VsdHMiIGlzIGxlZnQgb3ZlciBmcm9tIGEgcHJldmlvdXMKCQkjIHJ1bjogT25seSByZXBvcnQgaWYgbmV3IGxlYWtzIHNob3cgdXAuCgkJVEVTVF9SRVNVTFRTX1NBTl9ESVJfTlJfTEVBS1NfU1RBUlRVUD0kKG5yX3Nhbl9kaXJfbGVha3NfKQoKCQkjIERvbid0IGxpdHRlciAqLmxlYWsgZGlycyBpZiB0aGVyZSB3YXMgbm90aGluZyB0byByZXBvcnQKCQl0ZXN0X2F0ZXhpdCAicm1kaXIgXCIkVEVTVF9SRVNVTFRTX1NBTl9ESVJcIiAyPi9kZXYvbnVsbCB8fCA6IgoKCQlwcmVwZW5kX3ZhciBMU0FOX09QVElPTlMgOiBkZWR1cF90b2tlbl9sZW5ndGg9OTk5OQoJCXByZXBlbmRfdmFyIExTQU5fT1BUSU9OUyA6IGxvZ19leGVfbmFtZT0xCgkJcHJlcGVuZF92YXIgTFNBTl9PUFRJT05TIDogbG9nX3BhdGg9XCIkVEVTVF9SRVNVTFRTX1NBTl9GSUxFXCIKCQlleHBvcnQgTFNBTl9PUFRJT05TCglmaQplbGlmIHRlc3QgIiRHSVRfVEVTVF9QQVNTSU5HX1NBTklUSVpFX0xFQUsiID0gImNoZWNrIiB8fAogICAgIHRlc3RfYm9vbF9lbnYgR0lUX1RFU1RfUEFTU0lOR19TQU5JVElaRV9MRUFLIGZhbHNlCnRoZW4KCUJBSUxfT1VUX0VOVl9ORUVEU19TQU5JVElaRV9MRUFLICJHSVRfVEVTVF9QQVNTSU5HX1NBTklUSVpFX0xFQUs9dHJ1ZSIKZWxpZiB0ZXN0X2Jvb2xfZW52IEdJVF9URVNUX1NBTklUSVpFX0xFQUtfTE9HIGZhbHNlCnRoZW4KCUJBSUxfT1VUX0VOVl9ORUVEU19TQU5JVElaRV9MRUFLICJHSVRfVEVTVF9TQU5JVElaRV9MRUFLX0xPRz10cnVlIgpmaQoKaWYgdGVzdCAiJHtHSVRfVEVTVF9DSEFJTl9MSU5UOi0xfSIgIT0gMCAmJgogICB0ZXN0ICIke0dJVF9URVNUX0VYVF9DSEFJTl9MSU5UOi0xfSIgIT0gMAp0aGVuCgkiJFBFUkxfUEFUSCIgIiRURVNUX0RJUkVDVE9SWS9jaGFpbmxpbnQucGwiICIkMCIgfHwKCQlCVUcgImxpbnQgZXJyb3IgKHNlZSAnPyEuLi4hPyBhbm5vdGF0aW9ucyBhYm92ZSkiCmZpCgojIExhc3QtbWludXRlIHZhcmlhYmxlIHNldHVwClVTRVJfSE9NRT0iJEhPTUUiCkhPTUU9IiRUUkFTSF9ESVJFQ1RPUlkiCkdOVVBHSE9NRT0iJEhPTUUvZ251cGctaG9tZS1ub3QtdXNlZCIKZXhwb3J0IEhPTUUgR05VUEdIT01FIFVTRVJfSE9NRQoKIyAicm0gLXJmIiBleGlzdGluZyB0cmFzaCBkaXJlY3RvcnksIGV2ZW4gaWYgYSBwcmV2aW91cyBydW4gbGVmdCBpdAojIHdpdGggYmFkIHBlcm1pc3Npb25zLgpyZW1vdmVfdHJhc2hfZGlyZWN0b3J5ICgpIHsKCWRpcj0iJDEiCglpZiAhIHJtIC1yZiAiJGRpciIgMj4vZGV2L251bGwKCXRoZW4KCQljaG1vZCAtUiB1K3J3eCAiJGRpciIKCQlybSAtcmYgIiRkaXIiCglmaQoJISB0ZXN0IC1kICIkZGlyIgp9CgojIFRlc3QgcmVwb3NpdG9yeQpyZW1vdmVfdHJhc2hfZGlyZWN0b3J5ICIkVFJBU0hfRElSRUNUT1JZIiB8fCB7CglCQUlMX09VVCAnY2Fubm90IHByZXBhcmUgdGVzdCBhcmVhJwp9CgpyZW1vdmVfdHJhc2g9dAppZiB0ZXN0IC16ICIkVEVTVF9OT19DUkVBVEVfUkVQTyIKdGhlbgoJZ2l0IGluaXQgXAoJICAgICR7VEVTVF9DUkVBVEVfUkVQT19OT19URU1QTEFURTorLS10ZW1wbGF0ZT19IFwKCSAgICAiJFRSQVNIX0RJUkVDVE9SWSIgPiYzIDI+JjQgfHwKCWVycm9yICJjYW5ub3QgcnVuIGdpdCBpbml0IgplbHNlCglta2RpciAtcCAiJFRSQVNIX0RJUkVDVE9SWSIKZmkKCiMgVXNlIC1QIHRvIHJlc29sdmUgc3ltbGlua3MgaW4gb3VyIHdvcmtpbmcgZGlyZWN0b3J5IHNvIHRoYXQgdGhlIGN3ZAojIGluIHN1YnByb2Nlc3NlcyBsaWtlIGdpdCBlcXVhbHMgb3VyICRQV0QgKGZvciBwYXRobmFtZSBjb21wYXJpc29ucykuCmNkIC1QICIkVFJBU0hfRElSRUNUT1JZIiB8fCBCQUlMX09VVCAiY2Fubm90IGNkIC1QIHRvIFwiJFRSQVNIX0RJUkVDVE9SWVwiIgoKc3RhcnRfdGVzdF9vdXRwdXQgIiQwIgoKIyBDb252ZW5pZW5jZQojIEEgcmVnZXhwIHRvIG1hdGNoIDUgYW5kIDM1IGhleGRpZ2l0cwpfeDA1PSdbMC05YS1mXVswLTlhLWZdWzAtOWEtZl1bMC05YS1mXVswLTlhLWZdJwpfeDM1PSIkX3gwNSRfeDA1JF94MDUkX3gwNSRfeDA1JF94MDUkX3gwNSIKCnRlc3Rfb2lkX2luaXQKClpFUk9fT0lEPSQodGVzdF9vaWQgemVybykKT0lEX1JFR0VYPSQoZWNobyAkWkVST19PSUQgfCBzZWQgLWUgJ3MvMC9bMC05YS1mXS9nJykKT0lEUEFUSF9SRUdFWD0kKHRlc3Rfb2lkX3RvX3BhdGggJFpFUk9fT0lEIHwgc2VkIC1lICdzLzAvWzAtOWEtZl0vZycpCkVNUFRZX1RSRUU9JCh0ZXN0X29pZCBlbXB0eV90cmVlKQpFTVBUWV9CTE9CPSQodGVzdF9vaWQgZW1wdHlfYmxvYikKCiMgUHJvdmlkZSBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgJ3llcycgdXRpbGl0eTsgdGhlIHVwcGVyIGJvdW5kCiMgbGltaXQgaXMgdGhlcmUgdG8gaGVscCBXaW5kb3dzIHRoYXQgY2Fubm90IHN0b3AgdGhpcyBsb29wIGZyb20KIyB3YXN0aW5nIGN5Y2xlcyB3aGVuIHRoZSBkb3duc3RyZWFtIHN0b3BzIHJlYWRpbmcsIHNvIGRvIG5vdCBiZQojIHRlbXB0ZWQgdG8gdHVybiBpdCBpbnRvIGFuIGluZmluaXRlIGxvb3AuIGNmLiA2MTI5YzkzMCAoInRlc3QtbGliOgojIGxpbWl0IHRoZSBvdXRwdXQgb2YgdGhlIHllcyB1dGlsaXR5IiwgMjAxNi0wMi0wMikKeWVzICgpIHsKCWlmIHRlc3QgJCMgPSAwCgl0aGVuCgkJeT15CgllbHNlCgkJeT0iJCoiCglmaQoKCWk9MAoJd2hpbGUgdGVzdCAkaSAtbHQgOTkKCWRvCgkJZWNobyAiJHkiCgkJaT0kKCgkaSsxKSkKCWRvbmUKfQoKIyBUaGUgR0lUX1RFU1RfRkFJTF9QUkVSRVFTIGNvZGUgaG9va3MgaW50byB0ZXN0X3NldF9wcmVyZXEoKSwgYW5kCiMgdGh1cyBuZWVkcyB0byBiZSBzZXQgdXAgcmVhbGx5IGVhcmx5LCBhbmQgc2V0IGFuIGludGVybmFsIHZhcmlhYmxlCiMgZm9yIGNvbnZlbmllbmNlIHNvIHRoZSBob3QgdGVzdF9zZXRfcHJlcmVxKCkgY29kZXBhdGggZG9lc24ndCBuZWVkCiMgdG8gY2FsbCAidGVzdC10b29sIGVudi1oZWxwZXIiICh2aWEgdGVzdF9ib29sX2VudikuIE9ubHkgZG8gdGhhdCB3b3JrCiMgaWYgbmVlZGVkIGJ5IHNlZWluZyBpZiBHSVRfVEVTVF9GQUlMX1BSRVJFUVMgaXMgc2V0IGF0IGFsbC4KR0lUX1RFU1RfRkFJTF9QUkVSRVFTX0lOVEVSTkFMPQppZiB0ZXN0IC1uICIkR0lUX1RFU1RfRkFJTF9QUkVSRVFTIgp0aGVuCglpZiB0ZXN0X2Jvb2xfZW52IEdJVF9URVNUX0ZBSUxfUFJFUkVRUyBmYWxzZQoJdGhlbgoJCUdJVF9URVNUX0ZBSUxfUFJFUkVRU19JTlRFUk5BTD10cnVlCgkJdGVzdF9zZXRfcHJlcmVxIEZBSUxfUFJFUkVRUwoJZmkKZWxzZQoJdGVzdF9sYXp5X3ByZXJlcSBGQUlMX1BSRVJFUVMgJwoJCXRlc3RfYm9vbF9lbnYgR0lUX1RFU1RfRkFJTF9QUkVSRVFTIGZhbHNlCgknCmZpCgojIEZpeCBzb21lIGNvbW1hbmRzIG9uIFdpbmRvd3MsIGFuZCBvdGhlciBPUy1zcGVjaWZpYyB0aGluZ3MKdW5hbWVfcz0kKHVuYW1lIC1zKQpjYXNlICR1bmFtZV9zIGluCipNSU5HVyopCgkjIFdpbmRvd3MgaGFzIGl0cyBvd24gKGluY29tcGF0aWJsZSkgc29ydCBhbmQgZmluZAoJc29ydCAoKSB7CgkJL3Vzci9iaW4vc29ydCAiJEAiCgl9CglmaW5kICgpIHsKCQkvdXNyL2Jpbi9maW5kICIkQCIKCX0KCSMgZ2l0IHNlZXMgV2luZG93cy1zdHlsZSBwd2QKCXB3ZCAoKSB7CgkJYnVpbHRpbiBwd2QgLVcKCX0KCSMgbm8gUE9TSVggcGVybWlzc2lvbnMKCSMgYmFja3NsYXNoZXMgaW4gcGF0aHNwZWMgYXJlIGNvbnZlcnRlZCB0byAnLycKCSMgZXhlYyBkb2VzIG5vdCBpbmhlcml0IHRoZSBQSUQKCXRlc3Rfc2V0X3ByZXJlcSBNSU5HVwoJdGVzdF9zZXRfcHJlcmVxIE5BVElWRV9DUkxGCgl0ZXN0X3NldF9wcmVyZXEgU0VEX1NUUklQU19DUgoJdGVzdF9zZXRfcHJlcmVxIEdSRVBfU1RSSVBTX0NSCgl0ZXN0X3NldF9wcmVyZXEgV0lORE9XUwoJR0lUX1RFU1RfQ01QPSJHSVRfRElSPS9kZXYvbnVsbCBnaXQgZGlmZiAtLW5vLWluZGV4IC0taWdub3JlLWNyLWF0LWVvbCAtLSIKCTs7CipDWUdXSU4qKQoJdGVzdF9zZXRfcHJlcmVxIFBPU0lYUEVSTQoJdGVzdF9zZXRfcHJlcmVxIEVYRUNLRUVQU1BJRAoJdGVzdF9zZXRfcHJlcmVxIENZR1dJTgoJdGVzdF9zZXRfcHJlcmVxIFNFRF9TVFJJUFNfQ1IKCXRlc3Rfc2V0X3ByZXJlcSBHUkVQX1NUUklQU19DUgoJdGVzdF9zZXRfcHJlcmVxIFdJTkRPV1MKCTs7CiopCgl0ZXN0X3NldF9wcmVyZXEgUE9TSVhQRVJNCgl0ZXN0X3NldF9wcmVyZXEgQlNMQVNIUFNQRUMKCXRlc3Rfc2V0X3ByZXJlcSBFWEVDS0VFUFNQSUQKCTs7CmVzYWMKCiMgRGV0ZWN0IGFyY2hlcyB3aGVyZSBhIGZldyB0aGluZ3MgZG9uJ3Qgd29yawp1bmFtZV9tPSQodW5hbWUgLW0pCmNhc2UgJHVuYW1lX20gaW4KcGFyaXNjKiB8IGhwcGEqKQoJdGVzdF9zZXRfcHJlcmVxIEhQUEEKCTs7CmVzYWMKCnRlc3Rfc2V0X3ByZXJlcSBSRUZGSUxFUwoKKCBDT0xVTU5TPTEgJiYgdGVzdCAkQ09MVU1OUyA9IDEgKSAmJiB0ZXN0X3NldF9wcmVyZXEgQ09MVU1OU19DQU5fQkVfMQp0ZXN0IC16ICIkTk9fQ1VSTCIgJiYgdGVzdF9zZXRfcHJlcmVxIExJQkNVUkwKdGVzdCAteiAiJE5PX1BFUkwiICYmIHRlc3Rfc2V0X3ByZXJlcSBQRVJMCnRlc3QgLXogIiROT19QVEhSRUFEUyIgJiYgdGVzdF9zZXRfcHJlcmVxIFBUSFJFQURTCnRlc3QgLXogIiROT19QWVRIT04iICYmIHRlc3Rfc2V0X3ByZXJlcSBQWVRIT04KdGVzdCAtbiAiJFVTRV9MSUJQQ1JFMiIgJiYgdGVzdF9zZXRfcHJlcmVxIFBDUkUKdGVzdCAtbiAiJFVTRV9MSUJQQ1JFMiIgJiYgdGVzdF9zZXRfcHJlcmVxIExJQlBDUkUyCnRlc3QgLXogIiROT19HRVRURVhUIiAmJiB0ZXN0X3NldF9wcmVyZXEgR0VUVEVYVAp0ZXN0IC1uICIkU0FOSVRJWkVfTEVBSyIgJiYgdGVzdF9zZXRfcHJlcmVxIFNBTklUSVpFX0xFQUsKdGVzdCAtbiAiJEdJVF9WQUxHUklORF9FTkFCTEVEIiAmJiB0ZXN0X3NldF9wcmVyZXEgVkFMR1JJTkQKCmlmIHRlc3QgLXogIiRHSVRfVEVTVF9DSEVDS19DQUNIRV9UUkVFIgp0aGVuCglHSVRfVEVTVF9DSEVDS19DQUNIRV9UUkVFPXRydWUKCWV4cG9ydCBHSVRfVEVTVF9DSEVDS19DQUNIRV9UUkVFCmZpCgp0ZXN0X2xhenlfcHJlcmVxIFBJUEUgJwoJIyB0ZXN0IHdoZXRoZXIgdGhlIGZpbGVzeXN0ZW0gc3VwcG9ydHMgRklGT3MKCXRlc3RfaGF2ZV9wcmVyZXEgIU1JTkdXLCFDWUdXSU4gJiYKCXJtIC1mIHRlc3RmaWZvICYmIG1rZmlmbyB0ZXN0ZmlmbwonCgp0ZXN0X2xhenlfcHJlcmVxIFNZTUxJTktTICcKCSMgdGVzdCB3aGV0aGVyIHRoZSBmaWxlc3lzdGVtIHN1cHBvcnRzIHN5bWJvbGljIGxpbmtzCglsbiAtcyB4IHkgJiYgdGVzdCAtaCB5CicKCnRlc3RfbGF6eV9wcmVyZXEgU1lNTElOS1NfV0lORE9XUyAnCgkjIHRlc3Qgd2hldGhlciBzeW1ib2xpYyBsaW5rcyBhcmUgZW5hYmxlZCBvbiBXaW5kb3dzCgl0ZXN0X2hhdmVfcHJlcmVxIE1JTkdXICYmCgljbWQgLy9jICJta2xpbmsgeSB4IiAmPiAvZGV2L251bGwgJiYgdGVzdCAtaCB5CicKCnRlc3RfbGF6eV9wcmVyZXEgRklMRU1PREUgJwoJdGVzdCAiJChnaXQgY29uZmlnIC0tYm9vbCBjb3JlLmZpbGVtb2RlKSIgPSB0cnVlCicKCnRlc3RfbGF6eV9wcmVyZXEgQ0FTRV9JTlNFTlNJVElWRV9GUyAnCgllY2hvIGdvb2QgPkNhbWVsQ2FzZSAmJgoJZWNobyBiYWQgPmNhbWVsY2FzZSAmJgoJdGVzdCAiJChjYXQgQ2FtZWxDYXNlKSIgIT0gZ29vZAonCgp0ZXN0X2xhenlfcHJlcmVxIEZVTk5ZTkFNRVMgJwoJdGVzdF9oYXZlX3ByZXJlcSAhTUlOR1cgJiYKCXRvdWNoIC0tIFwKCQkiRlVOTllOQU1FUyB0YWIJZW1iZWRkZWQiIFwKCQkiRlVOTllOQU1FUyBcInF1b3RlIGVtYmVkZGVkXCIiIFwKCQkiRlVOTllOQU1FUyBuZXdsaW5lCmVtYmVkZGVkIiAyPi9kZXYvbnVsbCAmJgoJcm0gLS0gXAoJCSJGVU5OWU5BTUVTIHRhYgllbWJlZGRlZCIgXAoJCSJGVU5OWU5BTUVTIFwicXVvdGUgZW1iZWRkZWRcIiIgXAoJCSJGVU5OWU5BTUVTIG5ld2xpbmUKZW1iZWRkZWQiIDI+L2Rldi9udWxsCicKCnRlc3RfbGF6eV9wcmVyZXEgVVRGOF9ORkRfVE9fTkZDICcKCSMgY2hlY2sgd2hldGhlciBGUyBjb252ZXJ0cyBuZmQgdW5pY29kZSB0byBuZmMKCWF1bWw9JChwcmludGYgIlwzMDNcMjQ0IikKCWF1bWxjZGlhcj0kKHByaW50ZiAiXDE0MVwzMTRcMjEwIikKCT4iJGF1bWwiICYmCgl0ZXN0IC1mICIkYXVtbGNkaWFyIgonCgp0ZXN0X2xhenlfcHJlcmVxIEFVVE9JREVOVCAnCglzYW5lX3Vuc2V0IEdJVF9BVVRIT1JfTkFNRSAmJgoJc2FuZV91bnNldCBHSVRfQVVUSE9SX0VNQUlMICYmCglnaXQgdmFyIEdJVF9BVVRIT1JfSURFTlQKJwoKdGVzdF9sYXp5X3ByZXJlcSBFWFBFTlNJVkUgJwoJdGVzdCAtbiAiJEdJVF9URVNUX0xPTkciCicKCnRlc3RfbGF6eV9wcmVyZXEgRVhQRU5TSVZFX09OX1dJTkRPV1MgJwoJdGVzdF9oYXZlX3ByZXJlcSBFWFBFTlNJVkUgfHwgdGVzdF9oYXZlX3ByZXJlcSAhTUlOR1csIUNZR1dJTgonCgp0ZXN0X2xhenlfcHJlcmVxIFVTUl9CSU5fVElNRSAnCgl0ZXN0IC14IC91c3IvYmluL3RpbWUKJwoKdGVzdF9sYXp5X3ByZXJlcSBOT1RfUk9PVCAnCgl1aWQ9JChpZCAtdSkgJiYKCXRlc3QgIiR1aWQiICE9IDAKJwoKdGVzdF9sYXp5X3ByZXJlcSBKR0lUICcKCWpnaXQgLS12ZXJzaW9uCicKCiMgU0FOSVRZIGlzIGFib3V0ICJjYW4geW91IGNvcnJlY3RseSBwcmVkaWN0IHdoYXQgdGhlIGZpbGVzeXN0ZW0gd291bGQKIyBkbyBieSBvbmx5IGxvb2tpbmcgYXQgdGhlIHBlcm1pc3Npb24gYml0cyBvZiB0aGUgZmlsZXMgYW5kCiMgZGlyZWN0b3JpZXM/IiAgQSB0eXBpY2FsIGV4YW1wbGUgb2YgIVNBTklUWSBpcyBydW5uaW5nIHRoZSB0ZXN0CiMgc3VpdGUgYXMgcm9vdCwgd2hlcmUgYSB0ZXN0IG1heSBleHBlY3QgImNobW9kIC1yIGZpbGUgJiYgY2F0IGZpbGUiCiMgdG8gZmFpbCBiZWNhdXNlIGZpbGUgaXMgc3VwcG9zZWQgdG8gYmUgdW5yZWFkYWJsZSBhZnRlciBhIHN1Y2Nlc3NmdWwKIyBjaG1vZC4gIEluIGFuIGVudmlyb25tZW50IChpLmUuIGNvbWJpbmF0aW9uIG9mIHdoYXQgZmlsZXN5c3RlbSBpcwojIGJlaW5nIHVzZWQgYW5kIHdobyBpcyBydW5uaW5nIHRoZSB0ZXN0cykgdGhhdCBsYWNrcyBTQU5JVFksIHlvdSBtYXkKIyBiZSBhYmxlIHRvIGRlbGV0ZSBvciBjcmVhdGUgYSBmaWxlIHdoZW4gdGhlIGNvbnRhaW5pbmcgZGlyZWN0b3J5CiMgZG9lc24ndCBoYXZlIHdyaXRlIHBlcm1pc3Npb25zLCBvciBhY2Nlc3MgYSBmaWxlIGV2ZW4gaWYgdGhlCiMgY29udGFpbmluZyBkaXJlY3RvcnkgZG9lc24ndCBoYXZlIHJlYWQgb3IgZXhlY3V0ZSBwZXJtaXNzaW9ucy4KCnRlc3RfbGF6eV9wcmVyZXEgU0FOSVRZICcKCW1rZGlyIFNBTkVURVNURC4xIFNBTkVURVNURC4yICYmCgoJY2htb2QgK3cgU0FORVRFU1RELjEgU0FORVRFU1RELjIgJiYKCT5TQU5FVEVTVEQuMS94IDI+U0FORVRFU1RELjIveCAmJgoJY2htb2QgLXcgU0FORVRFU1RELjEgJiYKCWNobW9kIC1yIFNBTkVURVNURC4xL3ggJiYKCWNobW9kIC1yeCBTQU5FVEVTVEQuMiB8fAoJQlVHICJjYW5ub3QgcHJlcGFyZSBTQU5FVEVTVEQiCgoJISB0ZXN0IC1yIFNBTkVURVNURC4xL3ggJiYKCSEgcm0gU0FORVRFU1RELjEveCAmJiAhIHRlc3QgLWYgU0FORVRFU1RELjIveAoJc3RhdHVzPSQ/CgoJY2htb2QgK3J3eCBTQU5FVEVTVEQuMSBTQU5FVEVTVEQuMiAmJgoJcm0gLXJmIFNBTkVURVNURC4xIFNBTkVURVNURC4yIHx8CglCVUcgImNhbm5vdCBjbGVhbiBTQU5FVEVTVEQiCglyZXR1cm4gJHN0YXR1cwonCgp0ZXN0IEZyZWVCU0QgIT0gJHVuYW1lX3MgfHwgR0lUX1VOWklQPSR7R0lUX1VOWklQOi0vdXNyL2xvY2FsL2Jpbi91bnppcH0KR0lUX1VOWklQPSR7R0lUX1VOWklQOi11bnppcH0KdGVzdF9sYXp5X3ByZXJlcSBVTlpJUCAnCgkiJEdJVF9VTlpJUCIgLXYKCXRlc3QgJD8gLW5lIDEyNwonCgpydW5fd2l0aF9saW1pdGVkX2NtZGxpbmUgKCkgewoJKHVsaW1pdCAtcyAxMjggJiYgIiRAIikKfQoKdGVzdF9sYXp5X3ByZXJlcSBDTURMSU5FX0xJTUlUICcKCXRlc3RfaGF2ZV9wcmVyZXEgIUhQUEEsIU1JTkdXLCFDWUdXSU4gJiYKCXJ1bl93aXRoX2xpbWl0ZWRfY21kbGluZSB0cnVlCicKCnJ1bl93aXRoX2xpbWl0ZWRfc3RhY2sgKCkgewoJKHVsaW1pdCAtcyAxMjggJiYgIiRAIikKfQoKdGVzdF9sYXp5X3ByZXJlcSBVTElNSVRfU1RBQ0tfU0laRSAnCgl0ZXN0X2hhdmVfcHJlcmVxICFIUFBBLCFNSU5HVywhQ1lHV0lOICYmCglydW5fd2l0aF9saW1pdGVkX3N0YWNrIHRydWUKJwoKcnVuX3dpdGhfbGltaXRlZF9vcGVuX2ZpbGVzICgpIHsKCSh1bGltaXQgLW4gMzIgJiYgIiRAIikKfQoKdGVzdF9sYXp5X3ByZXJlcSBVTElNSVRfRklMRV9ERVNDUklQVE9SUyAnCgl0ZXN0X2hhdmVfcHJlcmVxICFNSU5HVywhQ1lHV0lOICYmCglydW5fd2l0aF9saW1pdGVkX29wZW5fZmlsZXMgdHJ1ZQonCgpidWlsZF9vcHRpb24gKCkgewoJZ2l0IHZlcnNpb24gLS1idWlsZC1vcHRpb25zIHwKCXNlZCAtbmUgInMvXiQxOiAvL3AiCn0KCnRlc3RfbGF6eV9wcmVyZXEgU0laRV9UX0lTXzY0QklUICcKCXRlc3QgOCAtZXEgIiQoYnVpbGRfb3B0aW9uIHNpemVvZi1zaXplX3QpIgonCgp0ZXN0X2xhenlfcHJlcmVxIExPTkdfSVNfNjRCSVQgJwoJdGVzdCA4IC1sZSAiJChidWlsZF9vcHRpb24gc2l6ZW9mLWxvbmcpIgonCgp0ZXN0X2xhenlfcHJlcmVxIFRJTUVfSVNfNjRCSVQgJ3Rlc3QtdG9vbCBkYXRlIGlzNjRiaXQnCnRlc3RfbGF6eV9wcmVyZXEgVElNRV9UX0lTXzY0QklUICd0ZXN0LXRvb2wgZGF0ZSB0aW1lX3QtaXM2NGJpdCcKCnRlc3RfbGF6eV9wcmVyZXEgQ1VSTCAnCgljdXJsIC0tdmVyc2lvbgonCgojIFNIQTEgaXMgYSB0ZXN0IGlmIHRoZSBoYXNoIGFsZ29yaXRobSBpbiB1c2UgaXMgU0hBLTEuICBUaGlzIGlzIGJvdGggZm9yIHRlc3RzCiMgd2hpY2ggd2lsbCBub3Qgd29yayB3aXRoIG90aGVyIGhhc2ggYWxnb3JpdGhtcyBhbmQgdGVzdHMgdGhhdCB3b3JrIGJ1dCBkb24ndAojIHRlc3QgYW55dGhpbmcgbWVhbmluZ2Z1bCAoZS5nLiBzcGVjaWFsIHZhbHVlcyB3aGljaCBjYXVzZSBzaG9ydCBjb2xsaXNpb25zKS4KdGVzdF9sYXp5X3ByZXJlcSBTSEExICcKCWNhc2UgIiRHSVRfREVGQVVMVF9IQVNIIiBpbgoJc2hhMSkgdHJ1ZSA7OwoJIiIpIHRlc3QgJChnaXQgaGFzaC1vYmplY3QgL2Rldi9udWxsKSA9IGU2OWRlMjliYjJkMWQ2NDM0YjhiMjlhZTc3NWFkOGMyZTQ4YzUzOTEgOzsKCSopIGZhbHNlIDs7Cgllc2FjCicKCiMgRW5zdXJlIHRoYXQgbm8gdGVzdCBhY2NpZGVudGFsbHkgdHJpZ2dlcnMgYSBHaXQgY29tbWFuZAojIHRoYXQgcnVucyB0aGUgYWN0dWFsIG1haW50ZW5hbmNlIHNjaGVkdWxlciwgYWZmZWN0aW5nIGEgdXNlcidzCiMgc3lzdGVtIHBlcm1hbmVudGx5LgojIFRlc3RzIHRoYXQgdmVyaWZ5IHRoZSBzY2hlZHVsZXIgaW50ZWdyYXRpb24gbXVzdCBzZXQgdGhpcyBsb2NhbGx5CiMgdG8gYXZvaWQgZXJyb3JzLgpHSVRfVEVTVF9NQUlOVF9TQ0hFRFVMRVI9Im5vbmU6ZXhpdCAxIgoKIyBEb2VzIHRoaXMgcGxhdGZvcm0gc3VwcG9ydCBgZ2l0IGZzbW9uaXRvci0tZGFlbW9uYAojCnRlc3RfbGF6eV9wcmVyZXEgRlNNT05JVE9SX0RBRU1PTiAnCglnaXQgdmVyc2lvbiAtLWJ1aWxkLW9wdGlvbnMgPm91dHB1dCAmJgoJZ3JlcCAiZmVhdHVyZTogZnNtb25pdG9yLS1kYWVtb24iIG91dHB1dAonCg==",
    "text": "# Test framework for git.  See t/README for usage.\n#\n# Copyright (c) 2005 Junio C Hamano\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see http://www.gnu.org/licenses/ .\n\n# Test the binaries we have just built.  The tests are kept in\n# t/ subdirectory and are run in 'trash directory' subdirectory.\nif test -z \"$TEST_DIRECTORY\"\nthen\n\t# ensure that TEST_DIRECTORY is an absolute path so that it\n\t# is valid even if the current working directory is changed\n\tTEST_DIRECTORY=$(pwd)\nelse\n\t# The TEST_DIRECTORY will always be the path to the \"t\"\n\t# directory in the git.git checkout. This is overridden by\n\t# e.g. t/lib-subtest.sh, but only because its $(pwd) is\n\t# different. Those tests still set \"$TEST_DIRECTORY\" to the\n\t# same path.\n\t#\n\t# See use of \"$GIT_BUILD_DIR\" and \"$TEST_DIRECTORY\" below for\n\t# hard assumptions about \"$GIT_BUILD_DIR/t\" existing and being\n\t# the \"$TEST_DIRECTORY\", and e.g. \"$TEST_DIRECTORY/helper\"\n\t# needing to exist.\n\tTEST_DIRECTORY=$(cd \"$TEST_DIRECTORY\" && pwd) || exit 1\nfi\nif test -z \"$TEST_OUTPUT_DIRECTORY\"\nthen\n\t# Similarly, override this to store the test-results subdir\n\t# elsewhere\n\tTEST_OUTPUT_DIRECTORY=$TEST_DIRECTORY\nfi\nGIT_BUILD_DIR=\"${TEST_DIRECTORY%/t}\"\nif test \"$TEST_DIRECTORY\" = \"$GIT_BUILD_DIR\"\nthen\n\techo \"PANIC: Running in a $TEST_DIRECTORY that doesn't end in '/t'?\" >&2\n\texit 1\nfi\nif test -f \"$GIT_BUILD_DIR/GIT-BUILD-DIR\"\nthen\n\tGIT_BUILD_DIR=\"$(cat \"$GIT_BUILD_DIR/GIT-BUILD-DIR\")\" || exit 1\n\t# On Windows, we must convert Windows paths lest they contain a colon\n\tcase \"$(uname -s)\" in\n\t*MINGW*)\n\t\tGIT_BUILD_DIR=\"$(cygpath -au \"$GIT_BUILD_DIR\")\"\n\t\t;;\n\tesac\nfi\n\n# Prepend a string to a VAR using an arbitrary \":\" delimiter, not\n# adding the delimiter if VAR or VALUE is empty. I.e. a generalized:\n#\n#\tVAR=$1${VAR:+${1:+$2}$VAR}\n#\n# Usage (using \":\" as the $2 delimiter):\n#\n#\tprepend_var VAR : VALUE\nprepend_var () {\n\teval \"$1=\\\"$3\\${$1:+${3:+$2}\\$$1}\\\"\"\n}\n\n# If [AL]SAN is in effect we want to abort so that we notice\n# problems. The GIT_SAN_OPTIONS variable can be used to set common\n# defaults shared between [AL]SAN_OPTIONS.\nprepend_var GIT_SAN_OPTIONS : abort_on_error=1\nprepend_var GIT_SAN_OPTIONS : strip_path_prefix=\"$GIT_BUILD_DIR/\"\n\n# If we were built with ASAN, it may complain about leaks\n# of program-lifetime variables. Disable it by default to lower\n# the noise level. This needs to happen at the start of the script,\n# before we even do our \"did we build git yet\" check (since we don't\n# want that one to complain to stderr).\nprepend_var ASAN_OPTIONS : $GIT_SAN_OPTIONS\nprepend_var ASAN_OPTIONS : detect_leaks=0\nexport ASAN_OPTIONS\n\nprepend_var LSAN_OPTIONS : $GIT_SAN_OPTIONS\nprepend_var LSAN_OPTIONS : fast_unwind_on_malloc=0\nexport LSAN_OPTIONS\n\nif test ! -f \"$GIT_BUILD_DIR\"/GIT-BUILD-OPTIONS\nthen\n\techo >&2 'error: GIT-BUILD-OPTIONS missing (has Git been built?).'\n\texit 1\nfi\n. \"$GIT_BUILD_DIR\"/GIT-BUILD-OPTIONS\nexport PERL_PATH SHELL_PATH\n\n# In t0000, we need to override test directories of nested testcases. In case\n# the developer has TEST_OUTPUT_DIRECTORY part of his build options, then we'd\n# reset this value to instead contain what the developer has specified. We thus\n# have this knob to allow overriding the directory.\nif test -n \"${TEST_OUTPUT_DIRECTORY_OVERRIDE}\"\nthen\n\tTEST_OUTPUT_DIRECTORY=\"${TEST_OUTPUT_DIRECTORY_OVERRIDE}\"\nfi\n\n# Disallow the use of abbreviated options in the test suite by default\nif test -z \"${GIT_TEST_DISALLOW_ABBREVIATED_OPTIONS}\"\nthen\n\tGIT_TEST_DISALLOW_ABBREVIATED_OPTIONS=true\n\texport GIT_TEST_DISALLOW_ABBREVIATED_OPTIONS\nfi\n\n# Explicitly set the default branch name for testing, to avoid the\n# transitory \"git init\" warning under --verbose.\n: ${GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME:=master}\nexport GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME\n\n################################################################\n# It appears that people try to run tests without building...\n\"${GIT_TEST_INSTALLED:-$GIT_BUILD_DIR}/git$X\" >/dev/null\nif test $? != 1\nthen\n\tif test -n \"$GIT_TEST_INSTALLED\"\n\tthen\n\t\techo >&2 \"error: there is no working Git at '$GIT_TEST_INSTALLED'\"\n\telse\n\t\techo >&2 'error: you do not seem to have built git yet.'\n\tfi\n\texit 1\nfi\n\nstore_arg_to=\nopt_required_arg=\n# $1: option string\n# $2: name of the var where the arg will be stored\nmark_option_requires_arg () {\n\tif test -n \"$opt_required_arg\"\n\tthen\n\t\techo \"error: options that require args cannot be bundled\" \\\n\t\t\t\"together: '$opt_required_arg' and '$1'\" >&2\n\t\texit 1\n\tfi\n\topt_required_arg=$1\n\tstore_arg_to=$2\n}\n\n# These functions can be overridden e.g. to output JUnit XML\nstart_test_output () { :; }\nstart_test_case_output () { :; }\nfinalize_test_case_output () { :; }\nfinalize_test_output () { :; }\n\nparse_option () {\n\tlocal opt=\"$1\"\n\n\tcase \"$opt\" in\n\t-d|--d|--de|--deb|--debu|--debug)\n\t\tdebug=t ;;\n\t-i|--i|--im|--imm|--imme|--immed|--immedi|--immedia|--immediat|--immediate)\n\t\timmediate=t ;;\n\t-l|--l|--lo|--lon|--long|--long-|--long-t|--long-te|--long-tes|--long-test|--long-tests)\n\t\tGIT_TEST_LONG=t; export GIT_TEST_LONG ;;\n\t-r)\n\t\tmark_option_requires_arg \"$opt\" run_list\n\t\t;;\n\t--run=*)\n\t\trun_list=${opt#--*=} ;;\n\t-h|--h|--he|--hel|--help)\n\t\thelp=t ;;\n\t-v|--v|--ve|--ver|--verb|--verbo|--verbos|--verbose)\n\t\tverbose=t ;;\n\t--verbose-only=*)\n\t\tverbose_only=${opt#--*=}\n\t\t;;\n\t-q|--q|--qu|--qui|--quie|--quiet)\n\t\t# Ignore --quiet under a TAP::Harness. Saying how many tests\n\t\t# passed without the ok/not ok details is always an error.\n\t\ttest -z \"$HARNESS_ACTIVE\" && quiet=t ;;\n\t--with-dashes)\n\t\twith_dashes=t ;;\n\t--no-bin-wrappers)\n\t\tno_bin_wrappers=t ;;\n\t--no-color)\n\t\tcolor= ;;\n\t--va|--val|--valg|--valgr|--valgri|--valgrin|--valgrind)\n\t\tvalgrind=memcheck\n\t\ttee=t\n\t\t;;\n\t--valgrind=*)\n\t\tvalgrind=${opt#--*=}\n\t\ttee=t\n\t\t;;\n\t--valgrind-only=*)\n\t\tvalgrind_only=${opt#--*=}\n\t\ttee=t\n\t\t;;\n\t--tee)\n\t\ttee=t ;;\n\t--root=*)\n\t\troot=${opt#--*=} ;;\n\t--chain-lint)\n\t\tGIT_TEST_CHAIN_LINT=1 ;;\n\t--no-chain-lint)\n\t\tGIT_TEST_CHAIN_LINT=0 ;;\n\t-x)\n\t\ttrace=t ;;\n\t-V|--verbose-log)\n\t\tverbose_log=t\n\t\ttee=t\n\t\t;;\n\t--write-junit-xml)\n\t\t. \"$TEST_DIRECTORY/test-lib-junit.sh\"\n\t\t;;\n\t--github-workflow-markup)\n\t\t. \"$TEST_DIRECTORY/test-lib-github-workflow-markup.sh\"\n\t\t;;\n\t--stress)\n\t\tstress=t ;;\n\t--stress=*)\n\t\techo \"error: --stress does not accept an argument: '$opt'\" >&2\n\t\techo \"did you mean --stress-jobs=${opt#*=} or --stress-limit=${opt#*=}?\" >&2\n\t\texit 1\n\t\t;;\n\t--stress-jobs=*)\n\t\tstress=t;\n\t\tstress_jobs=${opt#--*=}\n\t\tcase \"$stress_jobs\" in\n\t\t*[!0-9]*|0*|\"\")\n\t\t\techo \"error: --stress-jobs=<N> requires the number of jobs to run\" >&2\n\t\t\texit 1\n\t\t\t;;\n\t\t*)\t# Good.\n\t\t\t;;\n\t\tesac\n\t\t;;\n\t--stress-limit=*)\n\t\tstress=t;\n\t\tstress_limit=${opt#--*=}\n\t\tcase \"$stress_limit\" in\n\t\t*[!0-9]*|0*|\"\")\n\t\t\techo \"error: --stress-limit=<N> requires the number of repetitions\" >&2\n\t\t\texit 1\n\t\t\t;;\n\t\t*)\t# Good.\n\t\t\t;;\n\t\tesac\n\t\t;;\n\t--invert-exit-code)\n\t\tinvert_exit_code=t\n\t\t;;\n\t*)\n\t\techo \"error: unknown test option '$opt'\" >&2; exit 1 ;;\n\tesac\n}\n\n# Parse options while taking care to leave $@ intact, so we will still\n# have all the original command line options when executing the test\n# script again for '--tee' and '--verbose-log' later.\nfor opt\ndo\n\tif test -n \"$store_arg_to\"\n\tthen\n\t\teval $store_arg_to=\\$opt\n\t\tstore_arg_to=\n\t\topt_required_arg=\n\t\tcontinue\n\tfi\n\n\tcase \"$opt\" in\n\t--*|-?)\n\t\tparse_option \"$opt\" ;;\n\t-?*)\n\t\t# bundled short options must be fed separately to parse_option\n\t\topt=${opt#-}\n\t\twhile test -n \"$opt\"\n\t\tdo\n\t\t\textra=${opt#?}\n\t\t\tthis=${opt%$extra}\n\t\t\topt=$extra\n\t\t\tparse_option \"-$this\"\n\t\tdone\n\t\t;;\n\t*)\n\t\techo \"error: unknown test option '$opt'\" >&2; exit 1 ;;\n\tesac\ndone\nif test -n \"$store_arg_to\"\nthen\n\techo \"error: $opt_required_arg requires an argument\" >&2\n\texit 1\nfi\n\nif test -n \"$valgrind_only\"\nthen\n\ttest -z \"$valgrind\" && valgrind=memcheck\n\ttest -z \"$verbose\" && verbose_only=\"$valgrind_only\"\nelif test -n \"$valgrind\"\nthen\n\ttest -z \"$verbose_log\" && verbose=t\nfi\n\nif test -n \"$stress\"\nthen\n\tverbose=t\n\ttrace=t\n\timmediate=t\nfi\n\nTEST_STRESS_JOB_SFX=\"${GIT_TEST_STRESS_JOB_NR:+.stress-$GIT_TEST_STRESS_JOB_NR}\"\nTEST_NAME=\"$(basename \"$0\" .sh)\"\nTEST_NUMBER=\"${TEST_NAME%%-*}\"\nTEST_NUMBER=\"${TEST_NUMBER#t}\"\nTEST_RESULTS_DIR=\"$TEST_OUTPUT_DIRECTORY/test-results\"\nTEST_RESULTS_BASE=\"$TEST_RESULTS_DIR/$TEST_NAME$TEST_STRESS_JOB_SFX\"\nTEST_RESULTS_SAN_FILE_PFX=trace\nTEST_RESULTS_SAN_DIR_SFX=leak\nTEST_RESULTS_SAN_FILE=\nTEST_RESULTS_SAN_DIR=\"$TEST_RESULTS_DIR/$TEST_NAME.$TEST_RESULTS_SAN_DIR_SFX\"\nTEST_RESULTS_SAN_DIR_NR_LEAKS_STARTUP=\nTRASH_DIRECTORY=\"trash directory.$TEST_NAME$TEST_STRESS_JOB_SFX\"\ntest -n \"$root\" && TRASH_DIRECTORY=\"$root/$TRASH_DIRECTORY\"\ncase \"$TRASH_DIRECTORY\" in\n/*) ;; # absolute path is good\n *) TRASH_DIRECTORY=\"$TEST_OUTPUT_DIRECTORY/$TRASH_DIRECTORY\" ;;\nesac\n\n# Utility functions using $TEST_RESULTS_* variables\nnr_san_dir_leaks_ () {\n\t# stderr piped to /dev/null because the directory may have\n\t# been \"rmdir\"'d already.\n\tfind \"$TEST_RESULTS_SAN_DIR\" \\\n\t\t-type f \\\n\t\t-name \"$TEST_RESULTS_SAN_FILE_PFX.*\" 2>/dev/null |\n\twc -l\n}\n\n# If --stress was passed, run this test repeatedly in several parallel loops.\nif test \"$GIT_TEST_STRESS_STARTED\" = \"done\"\nthen\n\t: # Don't stress test again.\nelif test -n \"$stress\"\nthen\n\tif test -n \"$stress_jobs\"\n\tthen\n\t\tjob_count=$stress_jobs\n\telif test -n \"$GIT_TEST_STRESS_LOAD\"\n\tthen\n\t\tjob_count=\"$GIT_TEST_STRESS_LOAD\"\n\telif job_count=$(getconf _NPROCESSORS_ONLN 2>/dev/null) &&\n\t     test -n \"$job_count\"\n\tthen\n\t\tjob_count=$((2 * $job_count))\n\telse\n\t\tjob_count=8\n\tfi\n\n\tmkdir -p \"$TEST_RESULTS_DIR\"\n\tstressfail=\"$TEST_RESULTS_BASE.stress-failed\"\n\trm -f \"$stressfail\"\n\n\tstress_exit=0\n\ttrap '\n\t\tkill $job_pids 2>/dev/null\n\t\twait\n\t\tstress_exit=1\n\t' TERM INT HUP\n\n\tjob_pids=\n\tjob_nr=0\n\twhile test $job_nr -lt \"$job_count\"\n\tdo\n\t\t(\n\t\t\tGIT_TEST_STRESS_STARTED=done\n\t\t\tGIT_TEST_STRESS_JOB_NR=$job_nr\n\t\t\texport GIT_TEST_STRESS_STARTED GIT_TEST_STRESS_JOB_NR\n\n\t\t\ttrap '\n\t\t\t\tkill $test_pid 2>/dev/null\n\t\t\t\twait\n\t\t\t\texit 1\n\t\t\t' TERM INT\n\n\t\t\tcnt=1\n\t\t\twhile ! test -e \"$stressfail\" &&\n\t\t\t      { test -z \"$stress_limit\" ||\n\t\t\t\ttest $cnt -le $stress_limit ; }\n\t\t\tdo\n\t\t\t\t$TEST_SHELL_PATH \"$0\" \"$@\" >\"$TEST_RESULTS_BASE.stress-$job_nr.out\" 2>&1 &\n\t\t\t\ttest_pid=$!\n\n\t\t\t\tif wait $test_pid\n\t\t\t\tthen\n\t\t\t\t\tprintf \"OK   %2d.%d\\n\" $GIT_TEST_STRESS_JOB_NR $cnt\n\t\t\t\telse\n\t\t\t\t\techo $GIT_TEST_STRESS_JOB_NR >>\"$stressfail\"\n\t\t\t\t\tprintf \"FAIL %2d.%d\\n\" $GIT_TEST_STRESS_JOB_NR $cnt\n\t\t\t\tfi\n\t\t\t\tcnt=$(($cnt + 1))\n\t\t\tdone\n\t\t) &\n\t\tjob_pids=\"$job_pids $!\"\n\t\tjob_nr=$(($job_nr + 1))\n\tdone\n\n\twait\n\n\tif test -f \"$stressfail\"\n\tthen\n\t\tstress_exit=1\n\t\techo \"Log(s) of failed test run(s):\"\n\t\tfor failed_job_nr in $(sort -n \"$stressfail\")\n\t\tdo\n\t\t\techo \"Contents of '$TEST_RESULTS_BASE.stress-$failed_job_nr.out':\"\n\t\t\tcat \"$TEST_RESULTS_BASE.stress-$failed_job_nr.out\"\n\t\tdone\n\t\trm -rf \"$TRASH_DIRECTORY.stress-failed\"\n\t\t# Move the last one.\n\t\tmv \"$TRASH_DIRECTORY.stress-$failed_job_nr\" \"$TRASH_DIRECTORY.stress-failed\"\n\tfi\n\n\texit $stress_exit\nfi\n\n# if --tee was passed, write the output not only to the terminal, but\n# additionally to the file test-results/$BASENAME.out, too.\nif test \"$GIT_TEST_TEE_STARTED\" = \"done\"\nthen\n\t: # do not redirect again\nelif test -n \"$tee\"\nthen\n\tmkdir -p \"$TEST_RESULTS_DIR\"\n\n\t# Make this filename available to the sub-process in case it is using\n\t# --verbose-log.\n\tGIT_TEST_TEE_OUTPUT_FILE=$TEST_RESULTS_BASE.out\n\texport GIT_TEST_TEE_OUTPUT_FILE\n\n\t# Truncate before calling \"tee -a\" to get rid of the results\n\t# from any previous runs.\n\t>\"$GIT_TEST_TEE_OUTPUT_FILE\"\n\n\t(GIT_TEST_TEE_STARTED=done ${TEST_SHELL_PATH} \"$0\" \"$@\" 2>&1;\n\t echo $? >\"$TEST_RESULTS_BASE.exit\") | tee -a \"$GIT_TEST_TEE_OUTPUT_FILE\"\n\ttest \"$(cat \"$TEST_RESULTS_BASE.exit\")\" = 0\n\texit\nfi\n\nif test -n \"$trace\" && test -n \"$test_untraceable\"\nthen\n\t# '-x' tracing requested, but this test script can't be reliably\n\t# traced, unless it is run with a Bash version supporting\n\t# BASH_XTRACEFD (introduced in Bash v4.1).\n\t#\n\t# Perform this version check _after_ the test script was\n\t# potentially re-executed with $TEST_SHELL_PATH for '--tee' or\n\t# '--verbose-log', so the right shell is checked and the\n\t# warning is issued only once.\n\tif test -n \"$BASH_VERSION\" && eval '\n\t     test ${BASH_VERSINFO[0]} -gt 4 || {\n\t       test ${BASH_VERSINFO[0]} -eq 4 &&\n\t       test ${BASH_VERSINFO[1]} -ge 1\n\t     }\n\t   '\n\tthen\n\t\t: Executed by a Bash version supporting BASH_XTRACEFD.  Good.\n\telse\n\t\techo >&2 \"warning: ignoring -x; '$0' is untraceable without BASH_XTRACEFD\"\n\t\ttrace=\n\tfi\nfi\nif test -n \"$trace\" && test -z \"$verbose_log\"\nthen\n\tverbose=t\nfi\n\n# Since bash 5.0, checkwinsize is enabled by default which does\n# update the COLUMNS variable every time a non-builtin command\n# completes, even for non-interactive shells.\n# Disable that since we are aiming for repeatability.\ntest -n \"$BASH_VERSION\" && shopt -u checkwinsize 2>/dev/null\n\n# For repeatability, reset the environment to known value.\n# TERM is sanitized below, after saving color control sequences.\nLANG=C\nLC_ALL=C\nPAGER=cat\nTZ=UTC\nCOLUMNS=80\nexport LANG LC_ALL PAGER TZ COLUMNS\nEDITOR=:\n\n# A call to \"unset\" with no arguments causes at least Solaris 10\n# /usr/xpg4/bin/sh and /bin/ksh to bail out.  So keep the unsets\n# deriving from the command substitution clustered with the other\n# ones.\nunset VISUAL EMAIL LANGUAGE $(\"$PERL_PATH\" -e '\n\tmy @env = keys %ENV;\n\tmy $ok = join(\"|\", qw(\n\t\tTRACE\n\t\tDEBUG\n\t\tTEST\n\t\t.*_TEST\n\t\tPROVE\n\t\tVALGRIND\n\t\tUNZIP\n\t\tPERF_\n\t\tCURL_VERBOSE\n\t\tTRACE_CURL\n\t));\n\tmy @vars = grep(/^GIT_/ && !/^GIT_($ok)/o, @env);\n\tprint join(\"\\n\", @vars);\n')\nunset XDG_CACHE_HOME\nunset XDG_CONFIG_HOME\nunset GITPERLLIB\nunset GIT_TRACE2_PARENT_NAME\nunset GIT_TRACE2_PARENT_SID\nTEST_AUTHOR_LOCALNAME=author\nTEST_AUTHOR_DOMAIN=example.com\nGIT_AUTHOR_EMAIL=${TEST_AUTHOR_LOCALNAME}@${TEST_AUTHOR_DOMAIN}\nGIT_AUTHOR_NAME='A U Thor'\nGIT_AUTHOR_DATE='1112354055 +0200'\nTEST_COMMITTER_LOCALNAME=committer\nTEST_COMMITTER_DOMAIN=example.com\nGIT_COMMITTER_EMAIL=${TEST_COMMITTER_LOCALNAME}@${TEST_COMMITTER_DOMAIN}\nGIT_COMMITTER_NAME='C O Mitter'\nGIT_COMMITTER_DATE='1112354055 +0200'\nGIT_MERGE_VERBOSITY=5\nGIT_MERGE_AUTOEDIT=no\nexport GIT_MERGE_VERBOSITY GIT_MERGE_AUTOEDIT\nexport GIT_AUTHOR_EMAIL GIT_AUTHOR_NAME\nexport GIT_COMMITTER_EMAIL GIT_COMMITTER_NAME\nexport GIT_COMMITTER_DATE GIT_AUTHOR_DATE\nexport EDITOR\n\nGIT_DEFAULT_HASH=\"${GIT_TEST_DEFAULT_HASH:-sha1}\"\nexport GIT_DEFAULT_HASH\nGIT_TEST_MERGE_ALGORITHM=\"${GIT_TEST_MERGE_ALGORITHM:-ort}\"\nexport GIT_TEST_MERGE_ALGORITHM\n\n# Tests using GIT_TRACE typically don't want <timestamp> <file>:<line> output\nGIT_TRACE_BARE=1\nexport GIT_TRACE_BARE\n\n# Some tests scan the GIT_TRACE2_EVENT feed for events, but the\n# default depth is 2, which frequently causes issues when the\n# events are wrapped in new regions. Set it to a sufficiently\n# large depth to avoid custom changes in the test suite.\nGIT_TRACE2_EVENT_NESTING=100\nexport GIT_TRACE2_EVENT_NESTING\n\n# Use specific version of the index file format\nif test -n \"${GIT_TEST_INDEX_VERSION:+isset}\"\nthen\n\tGIT_INDEX_VERSION=\"$GIT_TEST_INDEX_VERSION\"\n\texport GIT_INDEX_VERSION\nfi\n\nif test -n \"$GIT_TEST_PERL_FATAL_WARNINGS\"\nthen\n\tGIT_PERL_FATAL_WARNINGS=1\n\texport GIT_PERL_FATAL_WARNINGS\nfi\n\ncase $GIT_TEST_FSYNC in\n'')\n\tGIT_TEST_FSYNC=0\n\texport GIT_TEST_FSYNC\n\t;;\nesac\n\n# Add libc MALLOC and MALLOC_PERTURB test only if we are not executing\n# the test with valgrind and have not compiled with conflict SANITIZE\n# options.\nif test -n \"$valgrind\" ||\n   test -n \"$SANITIZE_ADDRESS\" ||\n   test -n \"$SANITIZE_LEAK\" ||\n   test -n \"$TEST_NO_MALLOC_CHECK\"\nthen\n\tsetup_malloc_check () {\n\t\t: nothing\n\t}\n\tteardown_malloc_check () {\n\t\t: nothing\n\t}\nelse\n\t_USE_GLIBC_TUNABLES=\n\tif _GLIBC_VERSION=$(getconf GNU_LIBC_VERSION 2>/dev/null) &&\n\t   _GLIBC_VERSION=${_GLIBC_VERSION#\"glibc \"} &&\n\t   expr 2.34 \\<= \"$_GLIBC_VERSION\" >/dev/null\n\tthen\n\t\t_USE_GLIBC_TUNABLES=YesPlease\n\tfi\n\tsetup_malloc_check () {\n\t\tlocal g\n\t\tlocal t\n\t\tMALLOC_CHECK_=3\tMALLOC_PERTURB_=165\n\t\texport MALLOC_CHECK_ MALLOC_PERTURB_\n\t\tif test -n \"$_USE_GLIBC_TUNABLES\"\n\t\tthen\n\t\t\tg=\n\t\t\tLD_PRELOAD=\"libc_malloc_debug.so.0\"\n\t\t\tfor t in \\\n\t\t\t\tglibc.malloc.check=1 \\\n\t\t\t\tglibc.malloc.perturb=165\n\t\t\tdo\n\t\t\t\tg=\"${g#:}:$t\"\n\t\t\tdone\n\t\t\tGLIBC_TUNABLES=$g\n\t\t\texport LD_PRELOAD GLIBC_TUNABLES\n\t\tfi\n\t}\n\tteardown_malloc_check () {\n\t\tunset MALLOC_CHECK_ MALLOC_PERTURB_\n\t\tunset LD_PRELOAD GLIBC_TUNABLES\n\t}\nfi\n\n# Protect ourselves from common misconfiguration to export\n# CDPATH into the environment\nunset CDPATH\n\nunset GREP_OPTIONS\nunset UNZIP\n\ncase $(echo $GIT_TRACE |tr \"[A-Z]\" \"[a-z]\") in\n1|2|true)\n\tGIT_TRACE=4\n\t;;\nesac\n\n# Line feed\nLF='\n'\n\n# Single quote\nSQ=\\'\n\n# UTF-8 ZERO WIDTH NON-JOINER, which HFS+ ignores\n# when case-folding filenames\nu200c=$(printf '\\342\\200\\214')\n\nexport _x05 _x35 LF u200c EMPTY_TREE EMPTY_BLOB ZERO_OID OID_REGEX\n\ntest \"x$TERM\" != \"xdumb\" && (\n\t\ttest -t 1 &&\n\t\ttput bold >/dev/null 2>&1 &&\n\t\ttput setaf 1 >/dev/null 2>&1 &&\n\t\ttput sgr0 >/dev/null 2>&1\n\t) &&\n\tcolor=t\n\nif test -n \"$color\"\nthen\n\t# Save the color control sequences now rather than run tput\n\t# each time say_color() is called.  This is done for two\n\t# reasons:\n\t#   * TERM will be changed to dumb\n\t#   * HOME will be changed to a temporary directory and tput\n\t#     might need to read ~/.terminfo from the original HOME\n\t#     directory to get the control sequences\n\t# Note:  This approach assumes the control sequences don't end\n\t# in a newline for any terminal of interest (command\n\t# substitutions strip trailing newlines).  Given that most\n\t# (all?) terminals in common use are related to ECMA-48, this\n\t# shouldn't be a problem.\n\tsay_color_error=$(tput bold; tput setaf 1) # bold red\n\tsay_color_skip=$(tput setaf 4) # blue\n\tsay_color_warn=$(tput setaf 3) # brown/yellow\n\tsay_color_pass=$(tput setaf 2) # green\n\tsay_color_info=$(tput setaf 6) # cyan\n\tsay_color_reset=$(tput sgr0)\n\tsay_color_=\"\" # no formatting for normal text\n\tsay_color () {\n\t\ttest -z \"$1\" && test -n \"$quiet\" && return\n\t\teval \"say_color_color=\\$say_color_$1\"\n\t\tshift\n\t\tprintf \"%s\\\\n\" \"$say_color_color$*$say_color_reset\"\n\t}\nelse\n\tsay_color() {\n\t\ttest -z \"$1\" && test -n \"$quiet\" && return\n\t\tshift\n\t\tprintf \"%s\\n\" \"$*\"\n\t}\nfi\n\nUSER_TERM=\"$TERM\"\nTERM=dumb\nexport TERM USER_TERM\n\n# What is written by tests to stdout and stderr is sent to different places\n# depending on the test mode (e.g. /dev/null in non-verbose mode, piped to tee\n# with --tee option, etc.). We save the original stdin to FD #6 and stdout and\n# stderr to #5 and #7, so that the test framework can use them (e.g. for\n# printing errors within the test framework) independently of the test mode.\nexec 5>&1\nexec 6<&0\nexec 7>&2\n\n_error_exit () {\n\tfinalize_test_output\n\tGIT_EXIT_OK=t\n\texit 1\n}\n\nerror () {\n\tsay_color error \"error: $*\"\n\t_error_exit\n}\n\nBUG () {\n\terror >&7 \"bug in the test script: $*\"\n}\n\nBAIL_OUT () {\n\ttest $# -ne 1 && BUG \"1 param\"\n\n\t# Do not change \"Bail out! \" string. It's part of TAP syntax:\n\t# https://testanything.org/tap-specification.html\n\tlocal bail_out=\"Bail out! \"\n\tlocal message=\"$1\"\n\n\tsay_color >&5 error $bail_out \"$message\"\n\t_error_exit\n}\n\nsay () {\n\tsay_color info \"$*\"\n}\n\nif test -n \"$HARNESS_ACTIVE\"\nthen\n\tif test \"$verbose\" = t || test -n \"$verbose_only\"\n\tthen\n\t\tBAIL_OUT 'verbose mode forbidden under TAP harness; try --verbose-log'\n\tfi\nfi\n\ntest \"${test_description}\" != \"\" ||\nerror \"Test script did not set test_description.\"\n\nif test \"$help\" = \"t\"\nthen\n\tprintf '%s\\n' \"$test_description\"\n\texit 0\nfi\n\nif test \"$verbose_log\" = \"t\"\nthen\n\texec 3>>\"$GIT_TEST_TEE_OUTPUT_FILE\" 4>&3\nelif test \"$verbose\" = \"t\"\nthen\n\texec 4>&2 3>&1\nelse\n\texec 4>/dev/null 3>/dev/null\nfi\n\n# Send any \"-x\" output directly to stderr to avoid polluting tests\n# which capture stderr. We can do this unconditionally since it\n# has no effect if tracing isn't turned on.\n#\n# Note that this sets up the trace fd as soon as we assign the variable, so it\n# must come after the creation of descriptor 4 above. Likewise, we must never\n# unset this, as it has the side effect of closing descriptor 4, which we\n# use to show verbose tests to the user.\n#\n# Note also that we don't need or want to export it. The tracing is local to\n# this shell, and we would not want to influence any shells we exec.\nBASH_XTRACEFD=4\n\ntest_failure=0\ntest_count=0\ntest_fixed=0\ntest_broken=0\ntest_success=0\n\ntest_missing_prereq=\n\ntest_external_has_tap=0\n\ndie () {\n\tcode=$?\n\t# This is responsible for running the atexit commands even when a\n\t# test script run with '--immediate' fails, or when the user hits\n\t# ctrl-C, i.e. when 'test_done' is not invoked at all.\n\ttest_atexit_handler || code=$?\n\tif test -n \"$GIT_EXIT_OK\"\n\tthen\n\t\texit $code\n\telse\n\t\techo >&5 \"FATAL: Unexpected exit with code $code\"\n\t\texit 1\n\tfi\n}\n\nGIT_EXIT_OK=\ntrap 'die' EXIT\n# Disable '-x' tracing, because with some shells, notably dash, it\n# prevents running the cleanup commands when a test script run with\n# '--verbose-log -x' is interrupted.\ntrap '{ code=$?; set +x; } 2>/dev/null; exit $code' INT TERM HUP\n\n# The user-facing functions are loaded from a separate file so that\n# test_perf subshells can have them too\n. \"$TEST_DIRECTORY/test-lib-functions.sh\"\n\n# You are not expected to call test_ok_ and test_failure_ directly, use\n# the test_expect_* functions instead.\n\ntest_ok_ () {\n\ttest_success=$(($test_success + 1))\n\tsay_color \"\" \"ok $test_count - $@\"\n\tfinalize_test_case_output ok \"$@\"\n}\n\n_invert_exit_code_failure_end_blurb () {\n\tsay_color warn \"# faked up failures as TODO & now exiting with 0 due to --invert-exit-code\"\n}\n\ntest_failure_ () {\n\tfailure_label=$1\n\ttest_failure=$(($test_failure + 1))\n\tlocal pfx=\"\"\n\tif test -n \"$invert_exit_code\" # && test -n \"$HARNESS_ACTIVE\"\n\tthen\n\t\tpfx=\"# TODO induced breakage (--invert-exit-code):\"\n\tfi\n\tsay_color error \"not ok $test_count - ${pfx:+$pfx }$1\"\n\tshift\n\tprintf '%s\\n' \"$*\" | sed -e 's/^/#\t/'\n\tif test -n \"$immediate\"\n\tthen\n\t\tsay_color error \"1..$test_count\"\n\t\tif test -n \"$invert_exit_code\"\n\t\tthen\n\t\t\tfinalize_test_output\n\t\t\t_invert_exit_code_failure_end_blurb\n\t\t\tGIT_EXIT_OK=t\n\t\t\texit 0\n\t\tfi\n\t\t_error_exit\n\tfi\n\tfinalize_test_case_output failure \"$failure_label\" \"$@\"\n}\n\ntest_known_broken_ok_ () {\n\ttest_fixed=$(($test_fixed+1))\n\tsay_color error \"ok $test_count - $1 # TODO known breakage vanished\"\n\tfinalize_test_case_output fixed \"$1\"\n}\n\ntest_known_broken_failure_ () {\n\ttest_broken=$(($test_broken+1))\n\tsay_color warn \"not ok $test_count - $1 # TODO known breakage\"\n\tfinalize_test_case_output broken \"$1\"\n}\n\ntest_debug () {\n\ttest \"$debug\" = \"\" || eval \"$1\"\n}\n\nmatch_pattern_list () {\n\targ=\"$1\"\n\tshift\n\ttest -z \"$*\" && return 1\n\t# We need to use \"$*\" to get field-splitting, but we want to\n\t# disable globbing, since we are matching against an arbitrary\n\t# $arg, not what's in the filesystem. Using \"set -f\" accomplishes\n\t# that, but we must do it in a subshell to avoid impacting the\n\t# rest of the script. The exit value of the subshell becomes\n\t# the function's return value.\n\t(\n\t\tset -f\n\t\tfor pattern_ in $*\n\t\tdo\n\t\t\tcase \"$arg\" in\n\t\t\t$pattern_)\n\t\t\t\texit 0\n\t\t\t\t;;\n\t\t\tesac\n\t\tdone\n\t\texit 1\n\t)\n}\n\nmatch_test_selector_list () {\n\toperation=\"$1\"\n\tshift\n\ttitle=\"$1\"\n\tshift\n\targ=\"$1\"\n\tshift\n\ttest -z \"$1\" && return 0\n\n\t# Commas are accepted as separators.\n\tOLDIFS=$IFS\n\tIFS=','\n\tset -- $1\n\tIFS=$OLDIFS\n\n\t# If the first selector is negative we include by default.\n\tinclude=\n\tcase \"$1\" in\n\t\t!*) include=t ;;\n\tesac\n\n\tfor selector\n\tdo\n\t\torig_selector=$selector\n\n\t\tpositive=t\n\t\tcase \"$selector\" in\n\t\t\t!*)\n\t\t\t\tpositive=\n\t\t\t\tselector=${selector##?}\n\t\t\t\t;;\n\t\tesac\n\n\t\ttest -z \"$selector\" && continue\n\n\t\tcase \"$selector\" in\n\t\t\t*-*)\n\t\t\t\tif expr \"z${selector%%-*}\" : \"z[0-9]*[^0-9]\" >/dev/null\n\t\t\t\tthen\n\t\t\t\t\techo \"error: $operation: invalid non-numeric in range\" \\\n\t\t\t\t\t\t\"start: '$orig_selector'\" >&2\n\t\t\t\t\texit 1\n\t\t\t\tfi\n\t\t\t\tif expr \"z${selector#*-}\" : \"z[0-9]*[^0-9]\" >/dev/null\n\t\t\t\tthen\n\t\t\t\t\techo \"error: $operation: invalid non-numeric in range\" \\\n\t\t\t\t\t\t\"end: '$orig_selector'\" >&2\n\t\t\t\t\texit 1\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tif expr \"z$selector\" : \"z[0-9]*[^0-9]\" >/dev/null\n\t\t\t\tthen\n\t\t\t\t\tcase \"$title\" in *${selector}*)\n\t\t\t\t\t\tinclude=$positive\n\t\t\t\t\t\t;;\n\t\t\t\t\tesac\n\t\t\t\t\tcontinue\n\t\t\t\tfi\n\t\tesac\n\n\t\t# Short cut for \"obvious\" cases\n\t\ttest -z \"$include\" && test -z \"$positive\" && continue\n\t\ttest -n \"$include\" && test -n \"$positive\" && continue\n\n\t\tcase \"$selector\" in\n\t\t\t-*)\n\t\t\t\tif test $arg -le ${selector#-}\n\t\t\t\tthen\n\t\t\t\t\tinclude=$positive\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*-)\n\t\t\t\tif test $arg -ge ${selector%-}\n\t\t\t\tthen\n\t\t\t\t\tinclude=$positive\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*-*)\n\t\t\t\tif test ${selector%%-*} -le $arg \\\n\t\t\t\t\t&& test $arg -le ${selector#*-}\n\t\t\t\tthen\n\t\t\t\t\tinclude=$positive\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tif test $arg -eq $selector\n\t\t\t\tthen\n\t\t\t\t\tinclude=$positive\n\t\t\t\tfi\n\t\t\t\t;;\n\t\tesac\n\tdone\n\n\ttest -n \"$include\"\n}\n\nmaybe_teardown_verbose () {\n\ttest -z \"$verbose_only\" && return\n\texec 4>/dev/null 3>/dev/null\n\tverbose=\n}\n\nlast_verbose=t\nmaybe_setup_verbose () {\n\ttest -z \"$verbose_only\" && return\n\tif match_pattern_list $test_count \"$verbose_only\"\n\tthen\n\t\texec 4>&2 3>&1\n\t\t# Emit a delimiting blank line when going from\n\t\t# non-verbose to verbose.  Within verbose mode the\n\t\t# delimiter is printed by test_expect_*.  The choice\n\t\t# of the initial $last_verbose is such that before\n\t\t# test 1, we do not print it.\n\t\ttest -z \"$last_verbose\" && echo >&3 \"\"\n\t\tverbose=t\n\telse\n\t\texec 4>/dev/null 3>/dev/null\n\t\tverbose=\n\tfi\n\tlast_verbose=$verbose\n}\n\nmaybe_teardown_valgrind () {\n\ttest -z \"$GIT_VALGRIND\" && return\n\tGIT_VALGRIND_ENABLED=\n}\n\nmaybe_setup_valgrind () {\n\ttest -z \"$GIT_VALGRIND\" && return\n\tif test -z \"$valgrind_only\"\n\tthen\n\t\tGIT_VALGRIND_ENABLED=t\n\t\treturn\n\tfi\n\tGIT_VALGRIND_ENABLED=\n\tif match_pattern_list $test_count \"$valgrind_only\"\n\tthen\n\t\tGIT_VALGRIND_ENABLED=t\n\tfi\n}\n\ntrace_level_=0\nwant_trace () {\n\ttest \"$trace\" = t && {\n\t\ttest \"$verbose\" = t || test \"$verbose_log\" = t\n\t}\n}\n\n# This is a separate function because some tests use\n# \"return\" to end a test_expect_success block early\n# (and we want to make sure we run any cleanup like\n# \"set +x\").\ntest_eval_inner_ () {\n\t# Do not add anything extra (including LF) after '$*'\n\teval \"\n\t\twant_trace && trace_level_=$(($trace_level_+1)) && set -x\n\t\t$*\"\n}\n\ntest_eval_ () {\n\t# If \"-x\" tracing is in effect, then we want to avoid polluting stderr\n\t# with non-test commands. But once in \"set -x\" mode, we cannot prevent\n\t# the shell from printing the \"set +x\" to turn it off (nor the saving\n\t# of $? before that). But we can make sure that the output goes to\n\t# /dev/null.\n\t#\n\t# There are a few subtleties here:\n\t#\n\t#   - we have to redirect descriptor 4 in addition to 2, to cover\n\t#     BASH_XTRACEFD\n\t#\n\t#   - the actual eval has to come before the redirection block (since\n\t#     it needs to see descriptor 4 to set up its stderr)\n\t#\n\t#   - likewise, any error message we print must be outside the block to\n\t#     access descriptor 4\n\t#\n\t#   - checking $? has to come immediately after the eval, but it must\n\t#     be _inside_ the block to avoid polluting the \"set -x\" output\n\t#\n\n\ttest_eval_inner_ \"$@\" </dev/null >&3 2>&4\n\t{\n\t\ttest_eval_ret_=$?\n\t\tif want_trace\n\t\tthen\n\t\t\ttest 1 = $trace_level_ && set +x\n\t\t\ttrace_level_=$(($trace_level_-1))\n\t\tfi\n\t} 2>/dev/null 4>&2\n\n\tif test \"$test_eval_ret_\" != 0 && want_trace\n\tthen\n\t\tsay_color error >&4 \"error: last command exited with \\$?=$test_eval_ret_\"\n\tfi\n\treturn $test_eval_ret_\n}\n\nfail_117 () {\n\treturn 117\n}\n\ntest_run_ () {\n\ttest_cleanup=:\n\texpecting_failure=$2\n\n\tif test \"${GIT_TEST_CHAIN_LINT:-1}\" != 0; then\n\t\t# turn off tracing for this test-eval, as it simply creates\n\t\t# confusing noise in the \"-x\" output\n\t\ttrace_tmp=$trace\n\t\ttrace=\n\t\t# 117 is magic because it is unlikely to match the exit\n\t\t# code of other programs\n\t\ttest_eval_ \"fail_117 && $1\"\n\t\tif test $? != 117\n\t\tthen\n\t\t\tBUG \"broken &&-chain: $1\"\n\t\tfi\n\t\ttrace=$trace_tmp\n\tfi\n\n\tsetup_malloc_check\n\ttest_eval_ \"$1\"\n\teval_ret=$?\n\tteardown_malloc_check\n\n\tif test -z \"$immediate\" || test $eval_ret = 0 ||\n\t   test -n \"$expecting_failure\" && test \"$test_cleanup\" != \":\"\n\tthen\n\t\tsetup_malloc_check\n\t\ttest_eval_ \"$test_cleanup\"\n\t\tteardown_malloc_check\n\tfi\n\tif test \"$verbose\" = \"t\" && test -n \"$HARNESS_ACTIVE\"\n\tthen\n\t\techo \"\"\n\tfi\n\treturn \"$eval_ret\"\n}\n\ntest_start_ () {\n\ttest_count=$(($test_count+1))\n\tmaybe_setup_verbose\n\tmaybe_setup_valgrind\n\tstart_test_case_output \"$@\"\n}\n\ntest_finish_ () {\n\techo >&3 \"\"\n\tmaybe_teardown_valgrind\n\tmaybe_teardown_verbose\n\tif test -n \"$GIT_TEST_TEE_OFFSET\"\n\tthen\n\t\tGIT_TEST_TEE_OFFSET=$(test-tool path-utils file-size \\\n\t\t\t\"$GIT_TEST_TEE_OUTPUT_FILE\")\n\tfi\n}\n\ntest_skip () {\n\tto_skip=\n\tskipped_reason=\n\tif match_pattern_list $this_test.$test_count \"$GIT_SKIP_TESTS\"\n\tthen\n\t\tto_skip=t\n\t\tskipped_reason=\"GIT_SKIP_TESTS\"\n\tfi\n\tif test -z \"$to_skip\" && test -n \"$run_list\" &&\n\t   ! match_test_selector_list '--run' \"$1\" $test_count \"$run_list\"\n\tthen\n\t\tto_skip=t\n\t\tskipped_reason=\"--run\"\n\tfi\n\tif test -z \"$to_skip\" && test -n \"$test_prereq\" &&\n\t   ! test_have_prereq \"$test_prereq\"\n\tthen\n\t\tto_skip=t\n\n\t\tof_prereq=\n\t\tif test \"$missing_prereq\" != \"$test_prereq\"\n\t\tthen\n\t\t\tof_prereq=\" of $test_prereq\"\n\t\tfi\n\t\tskipped_reason=\"missing $missing_prereq${of_prereq}\"\n\n\t\t# Keep a list of all the missing prereq for result aggregation\n\t\tif test -z \"$missing_prereq\"\n\t\tthen\n\t\t\ttest_missing_prereq=$missing_prereq\n\t\telse\n\t\t\ttest_missing_prereq=\"$test_missing_prereq,$missing_prereq\"\n\t\tfi\n\tfi\n\n\tcase \"$to_skip\" in\n\tt)\n\n\t\tsay_color skip \"ok $test_count # skip $1 ($skipped_reason)\"\n\t\t: true\n\t\tfinalize_test_case_output skip \"$@\"\n\t\t;;\n\t*)\n\t\tfalse\n\t\t;;\n\tesac\n}\n\n# stub; perf-lib overrides it\ntest_at_end_hook_ () {\n\t:\n}\n\ntest_atexit_cleanup=:\ntest_atexit_handler () {\n\t# In a succeeding test script 'test_atexit_handler' is invoked\n\t# twice: first from 'test_done', then from 'die' in the trap on\n\t# EXIT.\n\t# This condition and resetting 'test_atexit_cleanup' below makes\n\t# sure that the registered cleanup commands are run only once.\n\ttest : != \"$test_atexit_cleanup\" || return 0\n\n\tsetup_malloc_check\n\ttest_eval_ \"$test_atexit_cleanup\"\n\ttest_atexit_cleanup=:\n\tteardown_malloc_check\n}\n\nsanitize_leak_log_message_ () {\n\tlocal new=\"$1\" &&\n\tlocal old=\"$2\" &&\n\tlocal file=\"$3\" &&\n\n\tprintf \"With SANITIZE=leak at exit we have %d leak logs, but started with %d\n\nThis means that we have a blindspot where git is leaking but we're\nlosing the exit code somewhere, or not propagating it appropriately\nupwards!\n\nSee the logs at \\\"%s.*\\\";\nthose logs are reproduced below.\" \\\n\t       \"$new\" \"$old\" \"$file\"\n}\n\ncheck_test_results_san_file_ () {\n\tif test -z \"$TEST_RESULTS_SAN_FILE\"\n\tthen\n\t\treturn\n\tfi &&\n\tlocal old=\"$TEST_RESULTS_SAN_DIR_NR_LEAKS_STARTUP\" &&\n\tlocal new=\"$(nr_san_dir_leaks_)\" &&\n\n\tif test $new -le $old\n\tthen\n\t\treturn\n\tfi &&\n\tlocal out=\"$(sanitize_leak_log_message_ \"$new\" \"$old\" \"$TEST_RESULTS_SAN_FILE\")\" &&\n\tsay_color error \"$out\" &&\n\tif test \"$old\" != 0\n\tthen\n\t\techo &&\n\t\tsay_color error \"The logs include output from past runs to avoid\" &&\n\t\tsay_color error \"that remove 'test-results' between runs.\"\n\tfi &&\n\tsay_color error \"$(cat \"$TEST_RESULTS_SAN_FILE\".*)\" &&\n\n\tif test -n \"$passes_sanitize_leak\" && test \"$test_failure\" = 0\n\tthen\n\t\tsay \"As TEST_PASSES_SANITIZE_LEAK=true and our logs show we're leaking, exit non-zero!\" &&\n\t\tinvert_exit_code=t\n\telif test -n \"$passes_sanitize_leak\"\n\tthen\n\t\tsay \"As TEST_PASSES_SANITIZE_LEAK=true and our logs show we're leaking, and we're failing for other reasons too...\" &&\n\t\tinvert_exit_code=\n\telif test -n \"$sanitize_leak_check\" && test \"$test_failure\" = 0\n\tthen\n\t\tsay \"As TEST_PASSES_SANITIZE_LEAK=true isn't set the above leak is 'ok' with GIT_TEST_PASSING_SANITIZE_LEAK=check\" &&\n\t\tinvert_exit_code=\n\telif test -n \"$sanitize_leak_check\"\n\tthen\n\t\tsay \"As TEST_PASSES_SANITIZE_LEAK=true isn't set the above leak is 'ok' with GIT_TEST_PASSING_SANITIZE_LEAK=check\" &&\n\t\tinvert_exit_code=t\n\telse\n\t\tsay \"With GIT_TEST_SANITIZE_LEAK_LOG=true our logs revealed a memory leak, exit non-zero!\" &&\n\t\tinvert_exit_code=t\n\tfi\n}\n\ntest_done () {\n\t# Run the atexit commands _before_ the trash directory is\n\t# removed, so the commands can access pidfiles and socket files.\n\ttest_atexit_handler\n\n\tfinalize_test_output\n\n\tif test -z \"$HARNESS_ACTIVE\"\n\tthen\n\t\tmkdir -p \"$TEST_RESULTS_DIR\"\n\n\t\tcat >\"$TEST_RESULTS_BASE.counts\" <<-EOF\n\t\ttotal $test_count\n\t\tsuccess $test_success\n\t\tfixed $test_fixed\n\t\tbroken $test_broken\n\t\tfailed $test_failure\n\t\tmissing_prereq $test_missing_prereq\n\n\t\tEOF\n\tfi\n\n\tif test \"$test_fixed\" != 0\n\tthen\n\t\tsay_color error \"# $test_fixed known breakage(s) vanished; please update test(s)\"\n\tfi\n\tif test \"$test_broken\" != 0\n\tthen\n\t\tsay_color warn \"# still have $test_broken known breakage(s)\"\n\tfi\n\tif test \"$test_broken\" != 0 || test \"$test_fixed\" != 0\n\tthen\n\t\ttest_remaining=$(( $test_count - $test_broken - $test_fixed ))\n\t\tmsg=\"remaining $test_remaining test(s)\"\n\telse\n\t\ttest_remaining=$test_count\n\t\tmsg=\"$test_count test(s)\"\n\tfi\n\tcase \"$test_failure\" in\n\t0)\n\t\tif test $test_remaining -gt 0\n\t\tthen\n\t\t\tsay_color pass \"# passed all $msg\"\n\t\tfi\n\n\t\t# Maybe print SKIP message\n\t\ttest -z \"$skip_all\" || skip_all=\"# SKIP $skip_all\"\n\t\tcase \"$test_count\" in\n\t\t0)\n\t\t\tsay \"1..$test_count${skip_all:+ $skip_all}\"\n\t\t\t;;\n\t\t*)\n\t\t\ttest -z \"$skip_all\" ||\n\t\t\tsay_color warn \"$skip_all\"\n\t\t\tsay \"1..$test_count\"\n\t\t\t;;\n\t\tesac\n\n\t\tif test -n \"$stress\" && test -n \"$invert_exit_code\"\n\t\tthen\n\t\t\t# We're about to move our \"$TRASH_DIRECTORY\"\n\t\t\t# to \"$TRASH_DIRECTORY.stress-failed\" if\n\t\t\t# --stress is combined with\n\t\t\t# --invert-exit-code.\n\t\t\tsay \"with --stress and --invert-exit-code we're not removing '$TRASH_DIRECTORY'\"\n\t\telif test -z \"$debug\" && test -n \"$remove_trash\"\n\t\tthen\n\t\t\ttest -d \"$TRASH_DIRECTORY\" ||\n\t\t\terror \"Tests passed but trash directory already removed before test cleanup; aborting\"\n\n\t\t\tcd \"$TRASH_DIRECTORY/..\" &&\n\t\t\trm -fr \"$TRASH_DIRECTORY\" || {\n\t\t\t\t# try again in a bit\n\t\t\t\tsleep 5;\n\t\t\t\trm -fr \"$TRASH_DIRECTORY\"\n\t\t\t} ||\n\t\t\terror \"Tests passed but test cleanup failed; aborting\"\n\t\tfi\n\n\t\tcheck_test_results_san_file_ \"$test_failure\"\n\n\t\tif test -z \"$skip_all\" && test -n \"$invert_exit_code\"\n\t\tthen\n\t\t\tsay_color warn \"# faking up non-zero exit with --invert-exit-code\"\n\t\t\tGIT_EXIT_OK=t\n\t\t\texit 1\n\t\tfi\n\n\t\ttest_at_end_hook_\n\n\t\tGIT_EXIT_OK=t\n\t\texit 0 ;;\n\n\t*)\n\t\tsay_color error \"# failed $test_failure among $msg\"\n\t\tsay \"1..$test_count\"\n\n\t\tcheck_test_results_san_file_ \"$test_failure\"\n\n\t\tif test -n \"$invert_exit_code\"\n\t\tthen\n\t\t\t_invert_exit_code_failure_end_blurb\n\t\t\tGIT_EXIT_OK=t\n\t\t\texit 0\n\t\tfi\n\n\t\tGIT_EXIT_OK=t\n\t\texit 1 ;;\n\n\tesac\n}\n\nif test -n \"$valgrind\"\nthen\n\tmake_symlink () {\n\t\ttest -h \"$2\" &&\n\t\ttest \"$1\" = \"$(readlink \"$2\")\" || {\n\t\t\t# be super paranoid\n\t\t\tif mkdir \"$2\".lock\n\t\t\tthen\n\t\t\t\trm -f \"$2\" &&\n\t\t\t\tln -s \"$1\" \"$2\" &&\n\t\t\t\trm -r \"$2\".lock\n\t\t\telse\n\t\t\t\twhile test -d \"$2\".lock\n\t\t\t\tdo\n\t\t\t\t\tsay \"Waiting for lock on $2.\"\n\t\t\t\t\tsleep 1\n\t\t\t\tdone\n\t\t\tfi\n\t\t}\n\t}\n\n\tmake_valgrind_symlink () {\n\t\t# handle only executables, unless they are shell libraries that\n\t\t# need to be in the exec-path.\n\t\ttest -x \"$1\" ||\n\t\ttest \"# \" = \"$(test_copy_bytes 2 <\"$1\")\" ||\n\t\treturn;\n\n\t\tbase=$(basename \"$1\")\n\t\tcase \"$base\" in\n\t\ttest-*)\n\t\t\tsymlink_target=\"$GIT_BUILD_DIR/t/helper/$base\"\n\t\t\t;;\n\t\t*)\n\t\t\tsymlink_target=\"$GIT_BUILD_DIR/$base\"\n\t\t\t;;\n\t\tesac\n\t\t# do not override scripts\n\t\tif test -x \"$symlink_target\" &&\n\t\t    test ! -d \"$symlink_target\" &&\n\t\t    test \"#!\" != \"$(test_copy_bytes 2 <\"$symlink_target\")\"\n\t\tthen\n\t\t\tsymlink_target=../valgrind.sh\n\t\tfi\n\t\tcase \"$base\" in\n\t\t*.sh|*.perl)\n\t\t\tsymlink_target=../unprocessed-script\n\t\tesac\n\t\t# create the link, or replace it if it is out of date\n\t\tmake_symlink \"$symlink_target\" \"$GIT_VALGRIND/bin/$base\" || exit\n\t}\n\n\t# override all git executables in TEST_DIRECTORY/..\n\tGIT_VALGRIND=$TEST_DIRECTORY/valgrind\n\tmkdir -p \"$GIT_VALGRIND\"/bin\n\tfor file in $GIT_BUILD_DIR/git* $GIT_BUILD_DIR/t/helper/test-*\n\tdo\n\t\tmake_valgrind_symlink $file\n\tdone\n\t# special-case the mergetools loadables\n\tmake_symlink \"$GIT_BUILD_DIR\"/mergetools \"$GIT_VALGRIND/bin/mergetools\"\n\tOLDIFS=$IFS\n\tIFS=:\n\tfor path in $PATH\n\tdo\n\t\tls \"$path\"/git-* 2> /dev/null |\n\t\twhile read file\n\t\tdo\n\t\t\tmake_valgrind_symlink \"$file\"\n\t\tdone\n\tdone\n\tIFS=$OLDIFS\n\tPATH=$GIT_VALGRIND/bin:$PATH\n\tGIT_EXEC_PATH=$GIT_VALGRIND/bin\n\texport GIT_VALGRIND\n\tGIT_VALGRIND_MODE=\"$valgrind\"\n\texport GIT_VALGRIND_MODE\n\tGIT_VALGRIND_ENABLED=t\n\ttest -n \"$valgrind_only\" && GIT_VALGRIND_ENABLED=\n\texport GIT_VALGRIND_ENABLED\nelif test -n \"$GIT_TEST_INSTALLED\"\nthen\n\tGIT_EXEC_PATH=$($GIT_TEST_INSTALLED/git --exec-path)  ||\n\terror \"Cannot run git from $GIT_TEST_INSTALLED.\"\n\tPATH=$GIT_TEST_INSTALLED:$GIT_BUILD_DIR/t/helper:$PATH\n\tGIT_EXEC_PATH=${GIT_TEST_EXEC_PATH:-$GIT_EXEC_PATH}\nelse # normal case, use ../bin-wrappers only unless $with_dashes:\n\tif test -n \"$no_bin_wrappers\"\n\tthen\n\t\twith_dashes=t\n\telse\n\t\tgit_bin_dir=\"$GIT_BUILD_DIR/bin-wrappers\"\n\t\tif ! test -x \"$git_bin_dir/git\"\n\t\tthen\n\t\t\tif test -z \"$with_dashes\"\n\t\t\tthen\n\t\t\t\tsay \"$git_bin_dir/git is not executable; using GIT_EXEC_PATH\"\n\t\t\tfi\n\t\t\twith_dashes=t\n\t\tfi\n\t\tPATH=\"$git_bin_dir:$PATH\"\n\tfi\n\tGIT_EXEC_PATH=$GIT_BUILD_DIR\n\tif test -n \"$with_dashes\"\n\tthen\n\t\tPATH=\"$GIT_BUILD_DIR:$GIT_BUILD_DIR/t/helper:$PATH\"\n\tfi\nfi\nGIT_TEMPLATE_DIR=\"$GIT_BUILD_DIR\"/templates/blt\nGIT_CONFIG_NOSYSTEM=1\nGIT_ATTR_NOSYSTEM=1\nGIT_CEILING_DIRECTORIES=\"$TRASH_DIRECTORY/..\"\nexport PATH GIT_EXEC_PATH GIT_TEMPLATE_DIR GIT_CONFIG_NOSYSTEM GIT_ATTR_NOSYSTEM GIT_CEILING_DIRECTORIES\n\nif test -z \"$GIT_TEST_CMP\"\nthen\n\tif test -n \"$GIT_TEST_CMP_USE_COPIED_CONTEXT\"\n\tthen\n\t\tGIT_TEST_CMP=\"$DIFF -c\"\n\telse\n\t\tGIT_TEST_CMP=\"$DIFF -u\"\n\tfi\nfi\n\nGITPERLLIB=\"$GIT_BUILD_DIR\"/perl/build/lib\nexport GITPERLLIB\ntest -d \"$GIT_BUILD_DIR\"/templates/blt || {\n\tBAIL_OUT \"You haven't built things yet, have you?\"\n}\n\nif ! test -x \"$GIT_BUILD_DIR\"/t/helper/test-tool$X\nthen\n\tBAIL_OUT 'You need to build test-tool; Run \"make t/helper/test-tool\" in the source (toplevel) directory'\nfi\n\n# Are we running this test at all?\nremove_trash=\nthis_test=${0##*/}\nthis_test=${this_test%%-*}\nif match_pattern_list \"$this_test\" \"$GIT_SKIP_TESTS\"\nthen\n\tsay_color info >&3 \"skipping test $this_test altogether\"\n\tskip_all=\"skip all tests in $this_test\"\n\ttest_done\nfi\n\nBAIL_OUT_ENV_NEEDS_SANITIZE_LEAK () {\n\tBAIL_OUT \"$1 has no effect except when compiled with SANITIZE=leak\"\n}\n\nif test -n \"$SANITIZE_LEAK\"\nthen\n\t# Normalize with test_bool_env\n\tpasses_sanitize_leak=\n\n\t# We need to see TEST_PASSES_SANITIZE_LEAK in \"test-tool\n\t# env-helper\" (via test_bool_env)\n\texport TEST_PASSES_SANITIZE_LEAK\n\tif test_bool_env TEST_PASSES_SANITIZE_LEAK false\n\tthen\n\t\tpasses_sanitize_leak=t\n\tfi\n\n\tif test \"$GIT_TEST_PASSING_SANITIZE_LEAK\" = \"check\"\n\tthen\n\t\tsanitize_leak_check=t\n\t\tif test -n \"$invert_exit_code\"\n\t\tthen\n\t\t\tBAIL_OUT \"cannot use --invert-exit-code under GIT_TEST_PASSING_SANITIZE_LEAK=check\"\n\t\tfi\n\n\t\tif test -z \"$passes_sanitize_leak\"\n\t\tthen\n\t\t\tsay \"in GIT_TEST_PASSING_SANITIZE_LEAK=check mode, setting --invert-exit-code for TEST_PASSES_SANITIZE_LEAK != true\"\n\t\t\tinvert_exit_code=t\n\t\tfi\n\telif test -z \"$passes_sanitize_leak\" &&\n\t     test_bool_env GIT_TEST_PASSING_SANITIZE_LEAK false\n\tthen\n\t\tskip_all=\"skipping $this_test under GIT_TEST_PASSING_SANITIZE_LEAK=true\"\n\t\ttest_done\n\tfi\n\n\tif test_bool_env GIT_TEST_SANITIZE_LEAK_LOG false\n\tthen\n\t\tif ! mkdir -p \"$TEST_RESULTS_SAN_DIR\"\n\t\tthen\n\t\t\tBAIL_OUT \"cannot create $TEST_RESULTS_SAN_DIR\"\n\t\tfi &&\n\t\tTEST_RESULTS_SAN_FILE=\"$TEST_RESULTS_SAN_DIR/$TEST_RESULTS_SAN_FILE_PFX\"\n\n\t\t# In case \"test-results\" is left over from a previous\n\t\t# run: Only report if new leaks show up.\n\t\tTEST_RESULTS_SAN_DIR_NR_LEAKS_STARTUP=$(nr_san_dir_leaks_)\n\n\t\t# Don't litter *.leak dirs if there was nothing to report\n\t\ttest_atexit \"rmdir \\\"$TEST_RESULTS_SAN_DIR\\\" 2>/dev/null || :\"\n\n\t\tprepend_var LSAN_OPTIONS : dedup_token_length=9999\n\t\tprepend_var LSAN_OPTIONS : log_exe_name=1\n\t\tprepend_var LSAN_OPTIONS : log_path=\\\"$TEST_RESULTS_SAN_FILE\\\"\n\t\texport LSAN_OPTIONS\n\tfi\nelif test \"$GIT_TEST_PASSING_SANITIZE_LEAK\" = \"check\" ||\n     test_bool_env GIT_TEST_PASSING_SANITIZE_LEAK false\nthen\n\tBAIL_OUT_ENV_NEEDS_SANITIZE_LEAK \"GIT_TEST_PASSING_SANITIZE_LEAK=true\"\nelif test_bool_env GIT_TEST_SANITIZE_LEAK_LOG false\nthen\n\tBAIL_OUT_ENV_NEEDS_SANITIZE_LEAK \"GIT_TEST_SANITIZE_LEAK_LOG=true\"\nfi\n\nif test \"${GIT_TEST_CHAIN_LINT:-1}\" != 0 &&\n   test \"${GIT_TEST_EXT_CHAIN_LINT:-1}\" != 0\nthen\n\t\"$PERL_PATH\" \"$TEST_DIRECTORY/chainlint.pl\" \"$0\" ||\n\t\tBUG \"lint error (see '?!...!? annotations above)\"\nfi\n\n# Last-minute variable setup\nUSER_HOME=\"$HOME\"\nHOME=\"$TRASH_DIRECTORY\"\nGNUPGHOME=\"$HOME/gnupg-home-not-used\"\nexport HOME GNUPGHOME USER_HOME\n\n# \"rm -rf\" existing trash directory, even if a previous run left it\n# with bad permissions.\nremove_trash_directory () {\n\tdir=\"$1\"\n\tif ! rm -rf \"$dir\" 2>/dev/null\n\tthen\n\t\tchmod -R u+rwx \"$dir\"\n\t\trm -rf \"$dir\"\n\tfi\n\t! test -d \"$dir\"\n}\n\n# Test repository\nremove_trash_directory \"$TRASH_DIRECTORY\" || {\n\tBAIL_OUT 'cannot prepare test area'\n}\n\nremove_trash=t\nif test -z \"$TEST_NO_CREATE_REPO\"\nthen\n\tgit init \\\n\t    ${TEST_CREATE_REPO_NO_TEMPLATE:+--template=} \\\n\t    \"$TRASH_DIRECTORY\" >&3 2>&4 ||\n\terror \"cannot run git init\"\nelse\n\tmkdir -p \"$TRASH_DIRECTORY\"\nfi\n\n# Use -P to resolve symlinks in our working directory so that the cwd\n# in subprocesses like git equals our $PWD (for pathname comparisons).\ncd -P \"$TRASH_DIRECTORY\" || BAIL_OUT \"cannot cd -P to \\\"$TRASH_DIRECTORY\\\"\"\n\nstart_test_output \"$0\"\n\n# Convenience\n# A regexp to match 5 and 35 hexdigits\n_x05='[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]'\n_x35=\"$_x05$_x05$_x05$_x05$_x05$_x05$_x05\"\n\ntest_oid_init\n\nZERO_OID=$(test_oid zero)\nOID_REGEX=$(echo $ZERO_OID | sed -e 's/0/[0-9a-f]/g')\nOIDPATH_REGEX=$(test_oid_to_path $ZERO_OID | sed -e 's/0/[0-9a-f]/g')\nEMPTY_TREE=$(test_oid empty_tree)\nEMPTY_BLOB=$(test_oid empty_blob)\n\n# Provide an implementation of the 'yes' utility; the upper bound\n# limit is there to help Windows that cannot stop this loop from\n# wasting cycles when the downstream stops reading, so do not be\n# tempted to turn it into an infinite loop. cf. 6129c930 (\"test-lib:\n# limit the output of the yes utility\", 2016-02-02)\nyes () {\n\tif test $# = 0\n\tthen\n\t\ty=y\n\telse\n\t\ty=\"$*\"\n\tfi\n\n\ti=0\n\twhile test $i -lt 99\n\tdo\n\t\techo \"$y\"\n\t\ti=$(($i+1))\n\tdone\n}\n\n# The GIT_TEST_FAIL_PREREQS code hooks into test_set_prereq(), and\n# thus needs to be set up really early, and set an internal variable\n# for convenience so the hot test_set_prereq() codepath doesn't need\n# to call \"test-tool env-helper\" (via test_bool_env). Only do that work\n# if needed by seeing if GIT_TEST_FAIL_PREREQS is set at all.\nGIT_TEST_FAIL_PREREQS_INTERNAL=\nif test -n \"$GIT_TEST_FAIL_PREREQS\"\nthen\n\tif test_bool_env GIT_TEST_FAIL_PREREQS false\n\tthen\n\t\tGIT_TEST_FAIL_PREREQS_INTERNAL=true\n\t\ttest_set_prereq FAIL_PREREQS\n\tfi\nelse\n\ttest_lazy_prereq FAIL_PREREQS '\n\t\ttest_bool_env GIT_TEST_FAIL_PREREQS false\n\t'\nfi\n\n# Fix some commands on Windows, and other OS-specific things\nuname_s=$(uname -s)\ncase $uname_s in\n*MINGW*)\n\t# Windows has its own (incompatible) sort and find\n\tsort () {\n\t\t/usr/bin/sort \"$@\"\n\t}\n\tfind () {\n\t\t/usr/bin/find \"$@\"\n\t}\n\t# git sees Windows-style pwd\n\tpwd () {\n\t\tbuiltin pwd -W\n\t}\n\t# no POSIX permissions\n\t# backslashes in pathspec are converted to '/'\n\t# exec does not inherit the PID\n\ttest_set_prereq MINGW\n\ttest_set_prereq NATIVE_CRLF\n\ttest_set_prereq SED_STRIPS_CR\n\ttest_set_prereq GREP_STRIPS_CR\n\ttest_set_prereq WINDOWS\n\tGIT_TEST_CMP=\"GIT_DIR=/dev/null git diff --no-index --ignore-cr-at-eol --\"\n\t;;\n*CYGWIN*)\n\ttest_set_prereq POSIXPERM\n\ttest_set_prereq EXECKEEPSPID\n\ttest_set_prereq CYGWIN\n\ttest_set_prereq SED_STRIPS_CR\n\ttest_set_prereq GREP_STRIPS_CR\n\ttest_set_prereq WINDOWS\n\t;;\n*)\n\ttest_set_prereq POSIXPERM\n\ttest_set_prereq BSLASHPSPEC\n\ttest_set_prereq EXECKEEPSPID\n\t;;\nesac\n\n# Detect arches where a few things don't work\nuname_m=$(uname -m)\ncase $uname_m in\nparisc* | hppa*)\n\ttest_set_prereq HPPA\n\t;;\nesac\n\ntest_set_prereq REFFILES\n\n( COLUMNS=1 && test $COLUMNS = 1 ) && test_set_prereq COLUMNS_CAN_BE_1\ntest -z \"$NO_CURL\" && test_set_prereq LIBCURL\ntest -z \"$NO_PERL\" && test_set_prereq PERL\ntest -z \"$NO_PTHREADS\" && test_set_prereq PTHREADS\ntest -z \"$NO_PYTHON\" && test_set_prereq PYTHON\ntest -n \"$USE_LIBPCRE2\" && test_set_prereq PCRE\ntest -n \"$USE_LIBPCRE2\" && test_set_prereq LIBPCRE2\ntest -z \"$NO_GETTEXT\" && test_set_prereq GETTEXT\ntest -n \"$SANITIZE_LEAK\" && test_set_prereq SANITIZE_LEAK\ntest -n \"$GIT_VALGRIND_ENABLED\" && test_set_prereq VALGRIND\n\nif test -z \"$GIT_TEST_CHECK_CACHE_TREE\"\nthen\n\tGIT_TEST_CHECK_CACHE_TREE=true\n\texport GIT_TEST_CHECK_CACHE_TREE\nfi\n\ntest_lazy_prereq PIPE '\n\t# test whether the filesystem supports FIFOs\n\ttest_have_prereq !MINGW,!CYGWIN &&\n\trm -f testfifo && mkfifo testfifo\n'\n\ntest_lazy_prereq SYMLINKS '\n\t# test whether the filesystem supports symbolic links\n\tln -s x y && test -h y\n'\n\ntest_lazy_prereq SYMLINKS_WINDOWS '\n\t# test whether symbolic links are enabled on Windows\n\ttest_have_prereq MINGW &&\n\tcmd //c \"mklink y x\" &> /dev/null && test -h y\n'\n\ntest_lazy_prereq FILEMODE '\n\ttest \"$(git config --bool core.filemode)\" = true\n'\n\ntest_lazy_prereq CASE_INSENSITIVE_FS '\n\techo good >CamelCase &&\n\techo bad >camelcase &&\n\ttest \"$(cat CamelCase)\" != good\n'\n\ntest_lazy_prereq FUNNYNAMES '\n\ttest_have_prereq !MINGW &&\n\ttouch -- \\\n\t\t\"FUNNYNAMES tab\tembedded\" \\\n\t\t\"FUNNYNAMES \\\"quote embedded\\\"\" \\\n\t\t\"FUNNYNAMES newline\nembedded\" 2>/dev/null &&\n\trm -- \\\n\t\t\"FUNNYNAMES tab\tembedded\" \\\n\t\t\"FUNNYNAMES \\\"quote embedded\\\"\" \\\n\t\t\"FUNNYNAMES newline\nembedded\" 2>/dev/null\n'\n\ntest_lazy_prereq UTF8_NFD_TO_NFC '\n\t# check whether FS converts nfd unicode to nfc\n\tauml=$(printf \"\\303\\244\")\n\taumlcdiar=$(printf \"\\141\\314\\210\")\n\t>\"$auml\" &&\n\ttest -f \"$aumlcdiar\"\n'\n\ntest_lazy_prereq AUTOIDENT '\n\tsane_unset GIT_AUTHOR_NAME &&\n\tsane_unset GIT_AUTHOR_EMAIL &&\n\tgit var GIT_AUTHOR_IDENT\n'\n\ntest_lazy_prereq EXPENSIVE '\n\ttest -n \"$GIT_TEST_LONG\"\n'\n\ntest_lazy_prereq EXPENSIVE_ON_WINDOWS '\n\ttest_have_prereq EXPENSIVE || test_have_prereq !MINGW,!CYGWIN\n'\n\ntest_lazy_prereq USR_BIN_TIME '\n\ttest -x /usr/bin/time\n'\n\ntest_lazy_prereq NOT_ROOT '\n\tuid=$(id -u) &&\n\ttest \"$uid\" != 0\n'\n\ntest_lazy_prereq JGIT '\n\tjgit --version\n'\n\n# SANITY is about \"can you correctly predict what the filesystem would\n# do by only looking at the permission bits of the files and\n# directories?\"  A typical example of !SANITY is running the test\n# suite as root, where a test may expect \"chmod -r file && cat file\"\n# to fail because file is supposed to be unreadable after a successful\n# chmod.  In an environment (i.e. combination of what filesystem is\n# being used and who is running the tests) that lacks SANITY, you may\n# be able to delete or create a file when the containing directory\n# doesn't have write permissions, or access a file even if the\n# containing directory doesn't have read or execute permissions.\n\ntest_lazy_prereq SANITY '\n\tmkdir SANETESTD.1 SANETESTD.2 &&\n\n\tchmod +w SANETESTD.1 SANETESTD.2 &&\n\t>SANETESTD.1/x 2>SANETESTD.2/x &&\n\tchmod -w SANETESTD.1 &&\n\tchmod -r SANETESTD.1/x &&\n\tchmod -rx SANETESTD.2 ||\n\tBUG \"cannot prepare SANETESTD\"\n\n\t! test -r SANETESTD.1/x &&\n\t! rm SANETESTD.1/x && ! test -f SANETESTD.2/x\n\tstatus=$?\n\n\tchmod +rwx SANETESTD.1 SANETESTD.2 &&\n\trm -rf SANETESTD.1 SANETESTD.2 ||\n\tBUG \"cannot clean SANETESTD\"\n\treturn $status\n'\n\ntest FreeBSD != $uname_s || GIT_UNZIP=${GIT_UNZIP:-/usr/local/bin/unzip}\nGIT_UNZIP=${GIT_UNZIP:-unzip}\ntest_lazy_prereq UNZIP '\n\t\"$GIT_UNZIP\" -v\n\ttest $? -ne 127\n'\n\nrun_with_limited_cmdline () {\n\t(ulimit -s 128 && \"$@\")\n}\n\ntest_lazy_prereq CMDLINE_LIMIT '\n\ttest_have_prereq !HPPA,!MINGW,!CYGWIN &&\n\trun_with_limited_cmdline true\n'\n\nrun_with_limited_stack () {\n\t(ulimit -s 128 && \"$@\")\n}\n\ntest_lazy_prereq ULIMIT_STACK_SIZE '\n\ttest_have_prereq !HPPA,!MINGW,!CYGWIN &&\n\trun_with_limited_stack true\n'\n\nrun_with_limited_open_files () {\n\t(ulimit -n 32 && \"$@\")\n}\n\ntest_lazy_prereq ULIMIT_FILE_DESCRIPTORS '\n\ttest_have_prereq !MINGW,!CYGWIN &&\n\trun_with_limited_open_files true\n'\n\nbuild_option () {\n\tgit version --build-options |\n\tsed -ne \"s/^$1: //p\"\n}\n\ntest_lazy_prereq SIZE_T_IS_64BIT '\n\ttest 8 -eq \"$(build_option sizeof-size_t)\"\n'\n\ntest_lazy_prereq LONG_IS_64BIT '\n\ttest 8 -le \"$(build_option sizeof-long)\"\n'\n\ntest_lazy_prereq TIME_IS_64BIT 'test-tool date is64bit'\ntest_lazy_prereq TIME_T_IS_64BIT 'test-tool date time_t-is64bit'\n\ntest_lazy_prereq CURL '\n\tcurl --version\n'\n\n# SHA1 is a test if the hash algorithm in use is SHA-1.  This is both for tests\n# which will not work with other hash algorithms and tests that work but don't\n# test anything meaningful (e.g. special values which cause short collisions).\ntest_lazy_prereq SHA1 '\n\tcase \"$GIT_DEFAULT_HASH\" in\n\tsha1) true ;;\n\t\"\") test $(git hash-object /dev/null) = e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 ;;\n\t*) false ;;\n\tesac\n'\n\n# Ensure that no test accidentally triggers a Git command\n# that runs the actual maintenance scheduler, affecting a user's\n# system permanently.\n# Tests that verify the scheduler integration must set this locally\n# to avoid errors.\nGIT_TEST_MAINT_SCHEDULER=\"none:exit 1\"\n\n# Does this platform support `git fsmonitor--daemon`\n#\ntest_lazy_prereq FSMONITOR_DAEMON '\n\tgit version --build-options >output &&\n\tgrep \"feature: fsmonitor--daemon\" output\n'\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0048ec7b6f6759641ec0e5265b067d739d74b6ba",
  "sha1_ok": true,
  "size": 49216
}
