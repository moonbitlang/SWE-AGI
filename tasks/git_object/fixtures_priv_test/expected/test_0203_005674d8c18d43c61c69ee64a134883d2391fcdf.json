{
  "content": {
    "base64": "LyoKICogTGljZW5zZWQgdW5kZXIgYSB0d28tY2xhdXNlIEJTRC1zdHlsZSBsaWNlbnNlLgogKiBTZWUgTElDRU5TRSBmb3IgZGV0YWlscy4KICovCgojaW5jbHVkZSAiZ2l0LWNvbXBhdC11dGlsLmgiCiNpbmNsdWRlICJzdHJidWYuaCIKI2luY2x1ZGUgInF1b3RlLmgiCiNpbmNsdWRlICJmYXN0X2V4cG9ydC5oIgojaW5jbHVkZSAicmVwb190cmVlLmgiCiNpbmNsdWRlICJzdHJidWYuaCIKI2luY2x1ZGUgInN2bmRpZmYuaCIKI2luY2x1ZGUgInNsaWRpbmdfd2luZG93LmgiCiNpbmNsdWRlICJsaW5lX2J1ZmZlci5oIgoKI2RlZmluZSBNQVhfR0lUU1ZOX0xJTkVfTEVOIDQwOTYKI2RlZmluZSBSRVBPUlRfRklMRU5PIDMKCnN0YXRpYyB1aW50MzJfdCBmaXJzdF9jb21taXRfZG9uZTsKc3RhdGljIHN0cnVjdCBsaW5lX2J1ZmZlciBwb3N0aW1hZ2UgPSBMSU5FX0JVRkZFUl9JTklUOwpzdGF0aWMgc3RydWN0IGxpbmVfYnVmZmVyIHJlcG9ydF9idWZmZXIgPSBMSU5FX0JVRkZFUl9JTklUOwoKLyogTkVFRFNXT1JLOiBtb3ZlIHRvIGZhc3RfZXhwb3J0X2luaXQoKSAqLwpzdGF0aWMgaW50IGluaXRfcG9zdGltYWdlKHZvaWQpCnsKCXN0YXRpYyBpbnQgcG9zdGltYWdlX2luaXRpYWxpemVkOwoJaWYgKHBvc3RpbWFnZV9pbml0aWFsaXplZCkKCQlyZXR1cm4gMDsKCXBvc3RpbWFnZV9pbml0aWFsaXplZCA9IDE7CglyZXR1cm4gYnVmZmVyX3RtcGZpbGVfaW5pdCgmcG9zdGltYWdlKTsKfQoKc3RhdGljIGludCBpbml0X3JlcG9ydF9idWZmZXIoaW50IGZkKQp7CglzdGF0aWMgaW50IHJlcG9ydF9idWZmZXJfaW5pdGlhbGl6ZWQ7CglpZiAocmVwb3J0X2J1ZmZlcl9pbml0aWFsaXplZCkKCQlyZXR1cm4gMDsKCXJlcG9ydF9idWZmZXJfaW5pdGlhbGl6ZWQgPSAxOwoJcmV0dXJuIGJ1ZmZlcl9mZGluaXQoJnJlcG9ydF9idWZmZXIsIGZkKTsKfQoKdm9pZCBmYXN0X2V4cG9ydF9pbml0KGludCBmZCkKewoJaWYgKGJ1ZmZlcl9mZGluaXQoJnJlcG9ydF9idWZmZXIsIGZkKSkKCQlkaWVfZXJybm8oImNhbm5vdCByZWFkIGZyb20gZmlsZSBkZXNjcmlwdG9yICVkIiwgZmQpOwp9Cgp2b2lkIGZhc3RfZXhwb3J0X2RlaW5pdCh2b2lkKQp7CglpZiAoYnVmZmVyX2RlaW5pdCgmcmVwb3J0X2J1ZmZlcikpCgkJZGllX2Vycm5vKCJlcnJvciBjbG9zaW5nIGZhc3QtaW1wb3J0IGZlZWRiYWNrIHN0cmVhbSIpOwp9Cgp2b2lkIGZhc3RfZXhwb3J0X3Jlc2V0KHZvaWQpCnsKCWJ1ZmZlcl9yZXNldCgmcmVwb3J0X2J1ZmZlcik7Cn0KCnZvaWQgZmFzdF9leHBvcnRfZGVsZXRlKGNvbnN0IGNoYXIgKnBhdGgpCnsKCXB1dGNoYXIoJ0QnKTsKCXB1dGNoYXIoJyAnKTsKCXF1b3RlX2Nfc3R5bGUocGF0aCwgTlVMTCwgc3Rkb3V0LCAwKTsKCXB1dGNoYXIoJ1xuJyk7Cn0KCnN0YXRpYyB2b2lkIGZhc3RfZXhwb3J0X3RydW5jYXRlKGNvbnN0IGNoYXIgKnBhdGgsIHVpbnQzMl90IG1vZGUpCnsKCWZhc3RfZXhwb3J0X21vZGlmeShwYXRoLCBtb2RlLCAiaW5saW5lIik7CglwcmludGYoImRhdGEgMFxuXG4iKTsKfQoKdm9pZCBmYXN0X2V4cG9ydF9tb2RpZnkoY29uc3QgY2hhciAqcGF0aCwgdWludDMyX3QgbW9kZSwgY29uc3QgY2hhciAqZGF0YXJlZikKewoJLyogTW9kZSBtdXN0IGJlIDEwMDY0NCwgMTAwNzU1LCAxMjAwMDAsIG9yIDE2MDAwMC4gKi8KCWlmICghZGF0YXJlZikgewoJCWZhc3RfZXhwb3J0X3RydW5jYXRlKHBhdGgsIG1vZGUpOwoJCXJldHVybjsKCX0KCXByaW50ZigiTSAlMDYiUFJJbzMyIiAlcyAiLCBtb2RlLCBkYXRhcmVmKTsKCXF1b3RlX2Nfc3R5bGUocGF0aCwgTlVMTCwgc3Rkb3V0LCAwKTsKCXB1dGNoYXIoJ1xuJyk7Cn0KCnN0YXRpYyBjaGFyIGdpdHN2bmxpbmVbTUFYX0dJVFNWTl9MSU5FX0xFTl07CnZvaWQgZmFzdF9leHBvcnRfYmVnaW5fY29tbWl0KHVpbnQzMl90IHJldmlzaW9uLCBjb25zdCBjaGFyICphdXRob3IsCgkJCWNvbnN0IHN0cnVjdCBzdHJidWYgKmxvZywKCQkJY29uc3QgY2hhciAqdXVpZCwgY29uc3QgY2hhciAqdXJsLAoJCQl1bnNpZ25lZCBsb25nIHRpbWVzdGFtcCkKewoJc3RhdGljIGNvbnN0IHN0cnVjdCBzdHJidWYgZW1wdHkgPSBTVFJCVUZfSU5JVDsKCWlmICghbG9nKQoJCWxvZyA9ICZlbXB0eTsKCWlmICgqdXVpZCAmJiAqdXJsKSB7CgkJc25wcmludGYoZ2l0c3ZubGluZSwgTUFYX0dJVFNWTl9MSU5FX0xFTiwKCQkJCSJcblxuZ2l0LXN2bi1pZDogJXNAJSJQUkl1MzIiICVzXG4iLAoJCQkJIHVybCwgcmV2aXNpb24sIHV1aWQpOwoJfSBlbHNlIHsKCQkqZ2l0c3ZubGluZSA9ICdcMCc7Cgl9CglwcmludGYoImNvbW1pdCByZWZzL2hlYWRzL21hc3RlclxuIik7CglwcmludGYoIm1hcmsgOiUiUFJJdTMyIlxuIiwgcmV2aXNpb24pOwoJcHJpbnRmKCJjb21taXR0ZXIgJXMgPCVzQCVzPiAlbGQgKzAwMDBcbiIsCgkJICAgKmF1dGhvciA/IGF1dGhvciA6ICJub2JvZHkiLAoJCSAgICphdXRob3IgPyBhdXRob3IgOiAibm9ib2R5IiwKCQkgICAqdXVpZCA/IHV1aWQgOiAibG9jYWwiLCB0aW1lc3RhbXApOwoJcHJpbnRmKCJkYXRhICUiUFJJdU1BWCJcbiIsCgkJKHVpbnRtYXhfdCkgKGxvZy0+bGVuICsgc3RybGVuKGdpdHN2bmxpbmUpKSk7Cglmd3JpdGUobG9nLT5idWYsIGxvZy0+bGVuLCAxLCBzdGRvdXQpOwoJcHJpbnRmKCIlc1xuIiwgZ2l0c3ZubGluZSk7CglpZiAoIWZpcnN0X2NvbW1pdF9kb25lKSB7CgkJaWYgKHJldmlzaW9uID4gMSkKCQkJcHJpbnRmKCJmcm9tIDolIlBSSXUzMiJcbiIsIHJldmlzaW9uIC0gMSk7CgkJZmlyc3RfY29tbWl0X2RvbmUgPSAxOwoJfQp9Cgp2b2lkIGZhc3RfZXhwb3J0X2VuZF9jb21taXQodWludDMyX3QgcmV2aXNpb24pCnsKCXByaW50ZigicHJvZ3Jlc3MgSW1wb3J0ZWQgY29tbWl0ICUiUFJJdTMyIi5cblxuIiwgcmV2aXNpb24pOwp9CgpzdGF0aWMgdm9pZCBsc19mcm9tX3Jldih1aW50MzJfdCByZXYsIGNvbnN0IGNoYXIgKnBhdGgpCnsKCS8qIGxzIDo1IHBhdGgvdG8vb2xkL2ZpbGUgKi8KCXByaW50ZigibHMgOiUiUFJJdTMyIiAiLCByZXYpOwoJcXVvdGVfY19zdHlsZShwYXRoLCBOVUxMLCBzdGRvdXQsIDApOwoJcHV0Y2hhcignXG4nKTsKCWZmbHVzaChzdGRvdXQpOwp9CgpzdGF0aWMgdm9pZCBsc19mcm9tX2FjdGl2ZV9jb21taXQoY29uc3QgY2hhciAqcGF0aCkKewoJLyogbHMgInBhdGgvdG8vZmlsZSIgKi8KCXByaW50ZigibHMgXCIiKTsKCXF1b3RlX2Nfc3R5bGUocGF0aCwgTlVMTCwgc3Rkb3V0LCAxKTsKCXByaW50ZigiXCJcbiIpOwoJZmZsdXNoKHN0ZG91dCk7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpnZXRfcmVzcG9uc2VfbGluZSh2b2lkKQp7Cgljb25zdCBjaGFyICpsaW5lID0gYnVmZmVyX3JlYWRfbGluZSgmcmVwb3J0X2J1ZmZlcik7CglpZiAobGluZSkKCQlyZXR1cm4gbGluZTsKCWlmIChidWZmZXJfZmVycm9yKCZyZXBvcnRfYnVmZmVyKSkKCQlkaWVfZXJybm8oImVycm9yIHJlYWRpbmcgZnJvbSBmYXN0LWltcG9ydCIpOwoJZGllKCJ1bmV4cGVjdGVkIGVuZCBvZiBmYXN0LWltcG9ydCBmZWVkYmFjayIpOwp9CgpzdGF0aWMgdm9pZCBkaWVfc2hvcnRfcmVhZChzdHJ1Y3QgbGluZV9idWZmZXIgKmlucHV0KQp7CglpZiAoYnVmZmVyX2ZlcnJvcihpbnB1dCkpCgkJZGllX2Vycm5vKCJlcnJvciByZWFkaW5nIGR1bXAgZmlsZSIpOwoJZGllKCJpbnZhbGlkIGR1bXA6IHVuZXhwZWN0ZWQgZW5kIG9mIGZpbGUiKTsKfQoKc3RhdGljIGludCBlbmRzX3dpdGgoY29uc3QgY2hhciAqcywgc2l6ZV90IGxlbiwgY29uc3QgY2hhciAqc3VmZml4KQp7Cgljb25zdCBzaXplX3Qgc3VmZml4bGVuID0gc3RybGVuKHN1ZmZpeCk7CglpZiAobGVuIDwgc3VmZml4bGVuKQoJCXJldHVybiAwOwoJcmV0dXJuICFtZW1jbXAocyArIGxlbiAtIHN1ZmZpeGxlbiwgc3VmZml4LCBzdWZmaXhsZW4pOwp9CgpzdGF0aWMgaW50IHBhcnNlX2NhdF9yZXNwb25zZV9saW5lKGNvbnN0IGNoYXIgKmhlYWRlciwgb2ZmX3QgKmxlbikKewoJc2l6ZV90IGhlYWRlcmxlbiA9IHN0cmxlbihoZWFkZXIpOwoJY29uc3QgY2hhciAqdHlwZTsKCWNvbnN0IGNoYXIgKmVuZDsKCglpZiAoZW5kc193aXRoKGhlYWRlciwgaGVhZGVybGVuLCAiIG1pc3NpbmciKSkKCQlyZXR1cm4gZXJyb3IoImNhdC1ibG9iIHJlcG9ydHMgbWlzc2luZyBibG9iOiAlcyIsIGhlYWRlcik7Cgl0eXBlID0gbWVtbWVtKGhlYWRlciwgaGVhZGVybGVuLCAiIGJsb2IgIiwgc3RybGVuKCIgYmxvYiAiKSk7CglpZiAoIXR5cGUpCgkJcmV0dXJuIGVycm9yKCJjYXQtYmxvYiBoZWFkZXIgaGFzIHdyb25nIG9iamVjdCB0eXBlOiAlcyIsIGhlYWRlcik7CgkqbGVuID0gc3RydG91bWF4KHR5cGUgKyBzdHJsZW4oIiBibG9iICIpLCAoY2hhciAqKikgJmVuZCwgMTApOwoJaWYgKGVuZCA9PSB0eXBlICsgc3RybGVuKCIgYmxvYiAiKSkKCQlyZXR1cm4gZXJyb3IoImNhdC1ibG9iIGhlYWRlciBkb2VzIG5vdCBjb250YWluIGxlbmd0aDogJXMiLCBoZWFkZXIpOwoJaWYgKCplbmQpCgkJcmV0dXJuIGVycm9yKCJjYXQtYmxvYiBoZWFkZXIgY29udGFpbnMgZ2FyYmFnZSBhZnRlciBsZW5ndGg6ICVzIiwgaGVhZGVyKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgbG9uZyBhcHBseV9kZWx0YShvZmZfdCBsZW4sIHN0cnVjdCBsaW5lX2J1ZmZlciAqaW5wdXQsCgkJCWNvbnN0IGNoYXIgKm9sZF9kYXRhLCB1aW50MzJfdCBvbGRfbW9kZSkKewoJbG9uZyByZXQ7CglvZmZfdCBwcmVpbWFnZV9sZW4gPSAwOwoJc3RydWN0IHNsaWRpbmdfdmlldyBwcmVpbWFnZSA9IFNMSURJTkdfVklFV19JTklUKCZyZXBvcnRfYnVmZmVyKTsKCUZJTEUgKm91dDsKCglpZiAoaW5pdF9wb3N0aW1hZ2UoKSB8fCAhKG91dCA9IGJ1ZmZlcl90bXBmaWxlX3Jld2luZCgmcG9zdGltYWdlKSkpCgkJZGllKCJjYW5ub3Qgb3BlbiB0ZW1wb3JhcnkgZmlsZSBmb3IgYmxvYiByZXRyaWV2YWwiKTsKCWlmIChpbml0X3JlcG9ydF9idWZmZXIoUkVQT1JUX0ZJTEVOTykpCgkJZGllKCJjYW5ub3Qgb3BlbiBmZCAzIGZvciBmZWVkYmFjayBmcm9tIGZhc3QtaW1wb3J0Iik7CglpZiAob2xkX2RhdGEpIHsKCQljb25zdCBjaGFyICpyZXNwb25zZTsKCQlwcmludGYoImNhdC1ibG9iICVzXG4iLCBvbGRfZGF0YSk7CgkJZmZsdXNoKHN0ZG91dCk7CgkJcmVzcG9uc2UgPSBnZXRfcmVzcG9uc2VfbGluZSgpOwoJCWlmIChwYXJzZV9jYXRfcmVzcG9uc2VfbGluZShyZXNwb25zZSwgJnByZWltYWdlX2xlbikpCgkJCWRpZSgiaW52YWxpZCBjYXQtYmxvYiByZXNwb25zZTogJXMiLCByZXNwb25zZSk7Cgl9CglpZiAob2xkX21vZGUgPT0gUkVQT19NT0RFX0xOSykgewoJCXN0cmJ1Zl9hZGRzdHIoJnByZWltYWdlLmJ1ZiwgImxpbmsgIik7CgkJcHJlaW1hZ2VfbGVuICs9IHN0cmxlbigibGluayAiKTsKCX0KCWlmIChzdm5kaWZmMF9hcHBseShpbnB1dCwgbGVuLCAmcHJlaW1hZ2UsIG91dCkpCgkJZGllKCJjYW5ub3QgYXBwbHkgZGVsdGEiKTsKCWlmIChvbGRfZGF0YSkgewoJCS8qIFJlYWQgdGhlIHJlbWFpbmRlciBvZiBwcmVpbWFnZSBhbmQgdHJhaWxpbmcgbmV3bGluZS4gKi8KCQlpZiAobW92ZV93aW5kb3coJnByZWltYWdlLCBwcmVpbWFnZV9sZW4sIDEpKQoJCQlkaWUoImNhbm5vdCBzZWVrIHRvIGVuZCBvZiBpbnB1dCIpOwoJCWlmIChwcmVpbWFnZS5idWYuYnVmWzBdICE9ICdcbicpCgkJCWRpZSgibWlzc2luZyBuZXdsaW5lIGFmdGVyIGNhdC1ibG9iIHJlc3BvbnNlIik7Cgl9CglyZXQgPSBidWZmZXJfdG1wZmlsZV9wcmVwYXJlX3RvX3JlYWQoJnBvc3RpbWFnZSk7CglpZiAocmV0IDwgMCkKCQlkaWUoImNhbm5vdCByZWFkIHRlbXBvcmFyeSBmaWxlIGZvciBibG9iIHJldHJpZXZhbCIpOwoJc3RyYnVmX3JlbGVhc2UoJnByZWltYWdlLmJ1Zik7CglyZXR1cm4gcmV0Owp9Cgp2b2lkIGZhc3RfZXhwb3J0X2RhdGEodWludDMyX3QgbW9kZSwgdWludDMyX3QgbGVuLCBzdHJ1Y3QgbGluZV9idWZmZXIgKmlucHV0KQp7CglpZiAobW9kZSA9PSBSRVBPX01PREVfTE5LKSB7CgkJLyogc3ZuIHN5bWxpbmsgYmxvYnMgc3RhcnQgd2l0aCAibGluayAiICovCgkJbGVuIC09IDU7CgkJaWYgKGJ1ZmZlcl9za2lwX2J5dGVzKGlucHV0LCA1KSAhPSA1KQoJCQlkaWVfc2hvcnRfcmVhZChpbnB1dCk7Cgl9CglwcmludGYoImRhdGEgJSJQUkl1MzIiXG4iLCBsZW4pOwoJaWYgKGJ1ZmZlcl9jb3B5X2J5dGVzKGlucHV0LCBsZW4pICE9IGxlbikKCQlkaWVfc2hvcnRfcmVhZChpbnB1dCk7CglmcHV0YygnXG4nLCBzdGRvdXQpOwp9CgpzdGF0aWMgaW50IHBhcnNlX2xzX3Jlc3BvbnNlKGNvbnN0IGNoYXIgKnJlc3BvbnNlLCB1aW50MzJfdCAqbW9kZSwKCQkJCQlzdHJ1Y3Qgc3RyYnVmICpkYXRhcmVmKQp7Cgljb25zdCBjaGFyICp0YWI7Cgljb25zdCBjaGFyICpyZXNwb25zZV9lbmQ7CgoJYXNzZXJ0KHJlc3BvbnNlKTsKCXJlc3BvbnNlX2VuZCA9IHJlc3BvbnNlICsgc3RybGVuKHJlc3BvbnNlKTsKCglpZiAoKnJlc3BvbnNlID09ICdtJykgewkvKiBNaXNzaW5nLiAqLwoJCWVycm5vID0gRU5PRU5UOwoJCXJldHVybiAtMTsKCX0KCgkvKiBNb2RlLiAqLwoJaWYgKHJlc3BvbnNlX2VuZCAtIHJlc3BvbnNlIDwgc3RybGVuKCIxMDA2NDQiKSB8fAoJICAgIHJlc3BvbnNlW3N0cmxlbigiMTAwNjQ0IildICE9ICcgJykKCQlkaWUoImludmFsaWQgbHMgcmVzcG9uc2U6IG1pc3NpbmcgbW9kZTogJXMiLCByZXNwb25zZSk7CgkqbW9kZSA9IDA7Cglmb3IgKDsgKnJlc3BvbnNlICE9ICcgJzsgcmVzcG9uc2UrKykgewoJCWNoYXIgY2ggPSAqcmVzcG9uc2U7CgkJaWYgKGNoIDwgJzAnIHx8IGNoID4gJzcnKQoJCQlkaWUoImludmFsaWQgbHMgcmVzcG9uc2U6IG1vZGUgaXMgbm90IG9jdGFsOiAlcyIsIHJlc3BvbnNlKTsKCQkqbW9kZSAqPSA4OwoJCSptb2RlICs9IGNoIC0gJzAnOwoJfQoKCS8qICcgYmxvYiAnIG9yICcgdHJlZSAnICovCglpZiAocmVzcG9uc2VfZW5kIC0gcmVzcG9uc2UgPCBzdHJsZW4oIiBibG9iICIpIHx8CgkgICAgKHJlc3BvbnNlWzFdICE9ICdiJyAmJiByZXNwb25zZVsxXSAhPSAndCcpKQoJCWRpZSgidW5leHBlY3RlZCBscyByZXNwb25zZTogbm90IGEgdHJlZSBvciBibG9iOiAlcyIsIHJlc3BvbnNlKTsKCXJlc3BvbnNlICs9IHN0cmxlbigiIGJsb2IgIik7CgoJLyogRGF0YXJlZi4gKi8KCXRhYiA9IG1lbWNocihyZXNwb25zZSwgJ1x0JywgcmVzcG9uc2VfZW5kIC0gcmVzcG9uc2UpOwoJaWYgKCF0YWIpCgkJZGllKCJpbnZhbGlkIGxzIHJlc3BvbnNlOiBtaXNzaW5nIHRhYjogJXMiLCByZXNwb25zZSk7CglzdHJidWZfYWRkKGRhdGFyZWYsIHJlc3BvbnNlLCB0YWIgLSByZXNwb25zZSk7CglyZXR1cm4gMDsKfQoKaW50IGZhc3RfZXhwb3J0X2xzX3Jldih1aW50MzJfdCByZXYsIGNvbnN0IGNoYXIgKnBhdGgsCgkJCQl1aW50MzJfdCAqbW9kZSwgc3RydWN0IHN0cmJ1ZiAqZGF0YXJlZikKewoJbHNfZnJvbV9yZXYocmV2LCBwYXRoKTsKCXJldHVybiBwYXJzZV9sc19yZXNwb25zZShnZXRfcmVzcG9uc2VfbGluZSgpLCBtb2RlLCBkYXRhcmVmKTsKfQoKaW50IGZhc3RfZXhwb3J0X2xzKGNvbnN0IGNoYXIgKnBhdGgsIHVpbnQzMl90ICptb2RlLCBzdHJ1Y3Qgc3RyYnVmICpkYXRhcmVmKQp7Cglsc19mcm9tX2FjdGl2ZV9jb21taXQocGF0aCk7CglyZXR1cm4gcGFyc2VfbHNfcmVzcG9uc2UoZ2V0X3Jlc3BvbnNlX2xpbmUoKSwgbW9kZSwgZGF0YXJlZik7Cn0KCnZvaWQgZmFzdF9leHBvcnRfYmxvYl9kZWx0YSh1aW50MzJfdCBtb2RlLAoJCQkJdWludDMyX3Qgb2xkX21vZGUsIGNvbnN0IGNoYXIgKm9sZF9kYXRhLAoJCQkJdWludDMyX3QgbGVuLCBzdHJ1Y3QgbGluZV9idWZmZXIgKmlucHV0KQp7Cglsb25nIHBvc3RpbWFnZV9sZW47CglpZiAobGVuID4gbWF4aW11bV9zaWduZWRfdmFsdWVfb2ZfdHlwZShvZmZfdCkpCgkJZGllKCJlbm9ybW91cyBkZWx0YSIpOwoJcG9zdGltYWdlX2xlbiA9IGFwcGx5X2RlbHRhKChvZmZfdCkgbGVuLCBpbnB1dCwgb2xkX2RhdGEsIG9sZF9tb2RlKTsKCWlmIChtb2RlID09IFJFUE9fTU9ERV9MTkspIHsKCQlidWZmZXJfc2tpcF9ieXRlcygmcG9zdGltYWdlLCBzdHJsZW4oImxpbmsgIikpOwoJCXBvc3RpbWFnZV9sZW4gLT0gc3RybGVuKCJsaW5rICIpOwoJfQoJcHJpbnRmKCJkYXRhICVsZFxuIiwgcG9zdGltYWdlX2xlbik7CglidWZmZXJfY29weV9ieXRlcygmcG9zdGltYWdlLCBwb3N0aW1hZ2VfbGVuKTsKCWZwdXRjKCdcbicsIHN0ZG91dCk7Cn0K",
    "text": "/*\n * Licensed under a two-clause BSD-style license.\n * See LICENSE for details.\n */\n\n#include \"git-compat-util.h\"\n#include \"strbuf.h\"\n#include \"quote.h\"\n#include \"fast_export.h\"\n#include \"repo_tree.h\"\n#include \"strbuf.h\"\n#include \"svndiff.h\"\n#include \"sliding_window.h\"\n#include \"line_buffer.h\"\n\n#define MAX_GITSVN_LINE_LEN 4096\n#define REPORT_FILENO 3\n\nstatic uint32_t first_commit_done;\nstatic struct line_buffer postimage = LINE_BUFFER_INIT;\nstatic struct line_buffer report_buffer = LINE_BUFFER_INIT;\n\n/* NEEDSWORK: move to fast_export_init() */\nstatic int init_postimage(void)\n{\n\tstatic int postimage_initialized;\n\tif (postimage_initialized)\n\t\treturn 0;\n\tpostimage_initialized = 1;\n\treturn buffer_tmpfile_init(&postimage);\n}\n\nstatic int init_report_buffer(int fd)\n{\n\tstatic int report_buffer_initialized;\n\tif (report_buffer_initialized)\n\t\treturn 0;\n\treport_buffer_initialized = 1;\n\treturn buffer_fdinit(&report_buffer, fd);\n}\n\nvoid fast_export_init(int fd)\n{\n\tif (buffer_fdinit(&report_buffer, fd))\n\t\tdie_errno(\"cannot read from file descriptor %d\", fd);\n}\n\nvoid fast_export_deinit(void)\n{\n\tif (buffer_deinit(&report_buffer))\n\t\tdie_errno(\"error closing fast-import feedback stream\");\n}\n\nvoid fast_export_reset(void)\n{\n\tbuffer_reset(&report_buffer);\n}\n\nvoid fast_export_delete(const char *path)\n{\n\tputchar('D');\n\tputchar(' ');\n\tquote_c_style(path, NULL, stdout, 0);\n\tputchar('\\n');\n}\n\nstatic void fast_export_truncate(const char *path, uint32_t mode)\n{\n\tfast_export_modify(path, mode, \"inline\");\n\tprintf(\"data 0\\n\\n\");\n}\n\nvoid fast_export_modify(const char *path, uint32_t mode, const char *dataref)\n{\n\t/* Mode must be 100644, 100755, 120000, or 160000. */\n\tif (!dataref) {\n\t\tfast_export_truncate(path, mode);\n\t\treturn;\n\t}\n\tprintf(\"M %06\"PRIo32\" %s \", mode, dataref);\n\tquote_c_style(path, NULL, stdout, 0);\n\tputchar('\\n');\n}\n\nstatic char gitsvnline[MAX_GITSVN_LINE_LEN];\nvoid fast_export_begin_commit(uint32_t revision, const char *author,\n\t\t\tconst struct strbuf *log,\n\t\t\tconst char *uuid, const char *url,\n\t\t\tunsigned long timestamp)\n{\n\tstatic const struct strbuf empty = STRBUF_INIT;\n\tif (!log)\n\t\tlog = &empty;\n\tif (*uuid && *url) {\n\t\tsnprintf(gitsvnline, MAX_GITSVN_LINE_LEN,\n\t\t\t\t\"\\n\\ngit-svn-id: %s@%\"PRIu32\" %s\\n\",\n\t\t\t\t url, revision, uuid);\n\t} else {\n\t\t*gitsvnline = '\\0';\n\t}\n\tprintf(\"commit refs/heads/master\\n\");\n\tprintf(\"mark :%\"PRIu32\"\\n\", revision);\n\tprintf(\"committer %s <%s@%s> %ld +0000\\n\",\n\t\t   *author ? author : \"nobody\",\n\t\t   *author ? author : \"nobody\",\n\t\t   *uuid ? uuid : \"local\", timestamp);\n\tprintf(\"data %\"PRIuMAX\"\\n\",\n\t\t(uintmax_t) (log->len + strlen(gitsvnline)));\n\tfwrite(log->buf, log->len, 1, stdout);\n\tprintf(\"%s\\n\", gitsvnline);\n\tif (!first_commit_done) {\n\t\tif (revision > 1)\n\t\t\tprintf(\"from :%\"PRIu32\"\\n\", revision - 1);\n\t\tfirst_commit_done = 1;\n\t}\n}\n\nvoid fast_export_end_commit(uint32_t revision)\n{\n\tprintf(\"progress Imported commit %\"PRIu32\".\\n\\n\", revision);\n}\n\nstatic void ls_from_rev(uint32_t rev, const char *path)\n{\n\t/* ls :5 path/to/old/file */\n\tprintf(\"ls :%\"PRIu32\" \", rev);\n\tquote_c_style(path, NULL, stdout, 0);\n\tputchar('\\n');\n\tfflush(stdout);\n}\n\nstatic void ls_from_active_commit(const char *path)\n{\n\t/* ls \"path/to/file\" */\n\tprintf(\"ls \\\"\");\n\tquote_c_style(path, NULL, stdout, 1);\n\tprintf(\"\\\"\\n\");\n\tfflush(stdout);\n}\n\nstatic const char *get_response_line(void)\n{\n\tconst char *line = buffer_read_line(&report_buffer);\n\tif (line)\n\t\treturn line;\n\tif (buffer_ferror(&report_buffer))\n\t\tdie_errno(\"error reading from fast-import\");\n\tdie(\"unexpected end of fast-import feedback\");\n}\n\nstatic void die_short_read(struct line_buffer *input)\n{\n\tif (buffer_ferror(input))\n\t\tdie_errno(\"error reading dump file\");\n\tdie(\"invalid dump: unexpected end of file\");\n}\n\nstatic int ends_with(const char *s, size_t len, const char *suffix)\n{\n\tconst size_t suffixlen = strlen(suffix);\n\tif (len < suffixlen)\n\t\treturn 0;\n\treturn !memcmp(s + len - suffixlen, suffix, suffixlen);\n}\n\nstatic int parse_cat_response_line(const char *header, off_t *len)\n{\n\tsize_t headerlen = strlen(header);\n\tconst char *type;\n\tconst char *end;\n\n\tif (ends_with(header, headerlen, \" missing\"))\n\t\treturn error(\"cat-blob reports missing blob: %s\", header);\n\ttype = memmem(header, headerlen, \" blob \", strlen(\" blob \"));\n\tif (!type)\n\t\treturn error(\"cat-blob header has wrong object type: %s\", header);\n\t*len = strtoumax(type + strlen(\" blob \"), (char **) &end, 10);\n\tif (end == type + strlen(\" blob \"))\n\t\treturn error(\"cat-blob header does not contain length: %s\", header);\n\tif (*end)\n\t\treturn error(\"cat-blob header contains garbage after length: %s\", header);\n\treturn 0;\n}\n\nstatic long apply_delta(off_t len, struct line_buffer *input,\n\t\t\tconst char *old_data, uint32_t old_mode)\n{\n\tlong ret;\n\toff_t preimage_len = 0;\n\tstruct sliding_view preimage = SLIDING_VIEW_INIT(&report_buffer);\n\tFILE *out;\n\n\tif (init_postimage() || !(out = buffer_tmpfile_rewind(&postimage)))\n\t\tdie(\"cannot open temporary file for blob retrieval\");\n\tif (init_report_buffer(REPORT_FILENO))\n\t\tdie(\"cannot open fd 3 for feedback from fast-import\");\n\tif (old_data) {\n\t\tconst char *response;\n\t\tprintf(\"cat-blob %s\\n\", old_data);\n\t\tfflush(stdout);\n\t\tresponse = get_response_line();\n\t\tif (parse_cat_response_line(response, &preimage_len))\n\t\t\tdie(\"invalid cat-blob response: %s\", response);\n\t}\n\tif (old_mode == REPO_MODE_LNK) {\n\t\tstrbuf_addstr(&preimage.buf, \"link \");\n\t\tpreimage_len += strlen(\"link \");\n\t}\n\tif (svndiff0_apply(input, len, &preimage, out))\n\t\tdie(\"cannot apply delta\");\n\tif (old_data) {\n\t\t/* Read the remainder of preimage and trailing newline. */\n\t\tif (move_window(&preimage, preimage_len, 1))\n\t\t\tdie(\"cannot seek to end of input\");\n\t\tif (preimage.buf.buf[0] != '\\n')\n\t\t\tdie(\"missing newline after cat-blob response\");\n\t}\n\tret = buffer_tmpfile_prepare_to_read(&postimage);\n\tif (ret < 0)\n\t\tdie(\"cannot read temporary file for blob retrieval\");\n\tstrbuf_release(&preimage.buf);\n\treturn ret;\n}\n\nvoid fast_export_data(uint32_t mode, uint32_t len, struct line_buffer *input)\n{\n\tif (mode == REPO_MODE_LNK) {\n\t\t/* svn symlink blobs start with \"link \" */\n\t\tlen -= 5;\n\t\tif (buffer_skip_bytes(input, 5) != 5)\n\t\t\tdie_short_read(input);\n\t}\n\tprintf(\"data %\"PRIu32\"\\n\", len);\n\tif (buffer_copy_bytes(input, len) != len)\n\t\tdie_short_read(input);\n\tfputc('\\n', stdout);\n}\n\nstatic int parse_ls_response(const char *response, uint32_t *mode,\n\t\t\t\t\tstruct strbuf *dataref)\n{\n\tconst char *tab;\n\tconst char *response_end;\n\n\tassert(response);\n\tresponse_end = response + strlen(response);\n\n\tif (*response == 'm') {\t/* Missing. */\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\n\t/* Mode. */\n\tif (response_end - response < strlen(\"100644\") ||\n\t    response[strlen(\"100644\")] != ' ')\n\t\tdie(\"invalid ls response: missing mode: %s\", response);\n\t*mode = 0;\n\tfor (; *response != ' '; response++) {\n\t\tchar ch = *response;\n\t\tif (ch < '0' || ch > '7')\n\t\t\tdie(\"invalid ls response: mode is not octal: %s\", response);\n\t\t*mode *= 8;\n\t\t*mode += ch - '0';\n\t}\n\n\t/* ' blob ' or ' tree ' */\n\tif (response_end - response < strlen(\" blob \") ||\n\t    (response[1] != 'b' && response[1] != 't'))\n\t\tdie(\"unexpected ls response: not a tree or blob: %s\", response);\n\tresponse += strlen(\" blob \");\n\n\t/* Dataref. */\n\ttab = memchr(response, '\\t', response_end - response);\n\tif (!tab)\n\t\tdie(\"invalid ls response: missing tab: %s\", response);\n\tstrbuf_add(dataref, response, tab - response);\n\treturn 0;\n}\n\nint fast_export_ls_rev(uint32_t rev, const char *path,\n\t\t\t\tuint32_t *mode, struct strbuf *dataref)\n{\n\tls_from_rev(rev, path);\n\treturn parse_ls_response(get_response_line(), mode, dataref);\n}\n\nint fast_export_ls(const char *path, uint32_t *mode, struct strbuf *dataref)\n{\n\tls_from_active_commit(path);\n\treturn parse_ls_response(get_response_line(), mode, dataref);\n}\n\nvoid fast_export_blob_delta(uint32_t mode,\n\t\t\t\tuint32_t old_mode, const char *old_data,\n\t\t\t\tuint32_t len, struct line_buffer *input)\n{\n\tlong postimage_len;\n\tif (len > maximum_signed_value_of_type(off_t))\n\t\tdie(\"enormous delta\");\n\tpostimage_len = apply_delta((off_t) len, input, old_data, old_mode);\n\tif (mode == REPO_MODE_LNK) {\n\t\tbuffer_skip_bytes(&postimage, strlen(\"link \"));\n\t\tpostimage_len -= strlen(\"link \");\n\t}\n\tprintf(\"data %ld\\n\", postimage_len);\n\tbuffer_copy_bytes(&postimage, postimage_len);\n\tfputc('\\n', stdout);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "005674d8c18d43c61c69ee64a134883d2391fcdf",
  "sha1_ok": true,
  "size": 8214
}
