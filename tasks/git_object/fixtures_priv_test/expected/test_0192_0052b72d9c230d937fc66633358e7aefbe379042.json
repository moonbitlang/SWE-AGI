{
  "content": {
    "base64": "LyoKICogR0lUIC0gVGhlIGluZm9ybWF0aW9uIG1hbmFnZXIgZnJvbSBoZWxsCiAqCiAqIENvcHlyaWdodCAoQykgTGludXMgVG9ydmFsZHMsIDIwMDUKICovCiNkZWZpbmUgTk9fVEhFX0lOREVYX0NPTVBBVElCSUxJVFlfTUFDUk9TCiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAibG9ja2ZpbGUuaCIKI2luY2x1ZGUgImNhY2hlLXRyZWUuaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgImRpci5oIgojaW5jbHVkZSAidHJlZS5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJibG9iLmgiCiNpbmNsdWRlICJyZXNvbHZlLXVuZG8uaCIKI2luY2x1ZGUgInN0cmJ1Zi5oIgojaW5jbHVkZSAidmFyaW50LmgiCiNpbmNsdWRlICJzcGxpdC1pbmRleC5oIgojaW5jbHVkZSAic2lnY2hhaW4uaCIKI2luY2x1ZGUgInV0ZjguaCIKCnN0YXRpYyBzdHJ1Y3QgY2FjaGVfZW50cnkgKnJlZnJlc2hfY2FjaGVfZW50cnkoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwKCQkJCQkgICAgICAgdW5zaWduZWQgaW50IG9wdGlvbnMpOwoKLyogTWFzayBmb3IgdGhlIG5hbWUgbGVuZ3RoIGluIGNlX2ZsYWdzIGluIHRoZSBvbi1kaXNrIGluZGV4ICovCgojZGVmaW5lIENFX05BTUVNQVNLICAoMHgwZmZmKQoKLyogSW5kZXggZXh0ZW5zaW9ucy4KICoKICogVGhlIGZpcnN0IGxldHRlciBzaG91bGQgYmUgJ0EnLi4nWicgZm9yIGV4dGVuc2lvbnMgdGhhdCBhcmUgbm90CiAqIG5lY2Vzc2FyeSBmb3IgYSBjb3JyZWN0IG9wZXJhdGlvbiAoaS5lLiBvcHRpbWl6YXRpb24gZGF0YSkuCiAqIFdoZW4gbmV3IGV4dGVuc2lvbnMgYXJlIGFkZGVkIHRoYXQgX25lZWRzXyB0byBiZSB1bmRlcnN0b29kIGluCiAqIG9yZGVyIHRvIGNvcnJlY3RseSBpbnRlcnByZXQgdGhlIGluZGV4IGZpbGUsIHBpY2sgY2hhcmFjdGVyIHRoYXQKICogaXMgb3V0c2lkZSB0aGUgcmFuZ2UsIHRvIGNhdXNlIHRoZSByZWFkZXIgdG8gYWJvcnQuCiAqLwoKI2RlZmluZSBDQUNIRV9FWFQocykgKCAoc1swXTw8MjQpfChzWzFdPDwxNil8KHNbMl08PDgpfChzWzNdKSApCiNkZWZpbmUgQ0FDSEVfRVhUX1RSRUUgMHg1NDUyNDU0NQkvKiAiVFJFRSIgKi8KI2RlZmluZSBDQUNIRV9FWFRfUkVTT0xWRV9VTkRPIDB4NTI0NTU1NDMgLyogIlJFVUMiICovCiNkZWZpbmUgQ0FDSEVfRVhUX0xJTksgMHg2YzY5NmU2YgkgIC8qICJsaW5rIiAqLwoKLyogY2hhbmdlcyB0aGF0IGNhbiBiZSBrZXB0IGluICRHSVRfRElSL2luZGV4IChiYXNpY2FsbHkgYWxsIGV4dGVuc2lvbnMpICovCiNkZWZpbmUgRVhUTUFTSyAoUkVTT0xWRV9VTkRPX0NIQU5HRUQgfCBDQUNIRV9UUkVFX0NIQU5HRUQgfCBcCgkJIENFX0VOVFJZX0FEREVEIHwgQ0VfRU5UUllfUkVNT1ZFRCB8IENFX0VOVFJZX0NIQU5HRUQgfCBcCgkJIFNQTElUX0lOREVYX09SREVSRUQpCgpzdHJ1Y3QgaW5kZXhfc3RhdGUgdGhlX2luZGV4OwpzdGF0aWMgY29uc3QgY2hhciAqYWx0ZXJuYXRlX2luZGV4X291dHB1dDsKCnN0YXRpYyB2b2lkIHNldF9pbmRleF9lbnRyeShzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgaW50IG5yLCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKQp7Cglpc3RhdGUtPmNhY2hlW25yXSA9IGNlOwoJYWRkX25hbWVfaGFzaChpc3RhdGUsIGNlKTsKfQoKc3RhdGljIHZvaWQgcmVwbGFjZV9pbmRleF9lbnRyeShzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgaW50IG5yLCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKQp7CglzdHJ1Y3QgY2FjaGVfZW50cnkgKm9sZCA9IGlzdGF0ZS0+Y2FjaGVbbnJdOwoKCXJlcGxhY2VfaW5kZXhfZW50cnlfaW5fYmFzZShpc3RhdGUsIG9sZCwgY2UpOwoJcmVtb3ZlX25hbWVfaGFzaChpc3RhdGUsIG9sZCk7CglmcmVlKG9sZCk7CglzZXRfaW5kZXhfZW50cnkoaXN0YXRlLCBuciwgY2UpOwoJY2UtPmNlX2ZsYWdzIHw9IENFX1VQREFURV9JTl9CQVNFOwoJaXN0YXRlLT5jYWNoZV9jaGFuZ2VkIHw9IENFX0VOVFJZX0NIQU5HRUQ7Cn0KCnZvaWQgcmVuYW1lX2luZGV4X2VudHJ5X2F0KHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBpbnQgbnIsIGNvbnN0IGNoYXIgKm5ld19uYW1lKQp7CglzdHJ1Y3QgY2FjaGVfZW50cnkgKm9sZCA9IGlzdGF0ZS0+Y2FjaGVbbnJdLCAqbmV3OwoJaW50IG5hbWVsZW4gPSBzdHJsZW4obmV3X25hbWUpOwoKCW5ldyA9IHhtYWxsb2MoY2FjaGVfZW50cnlfc2l6ZShuYW1lbGVuKSk7Cgljb3B5X2NhY2hlX2VudHJ5KG5ldywgb2xkKTsKCW5ldy0+Y2VfZmxhZ3MgJj0gfkNFX0hBU0hFRDsKCW5ldy0+Y2VfbmFtZWxlbiA9IG5hbWVsZW47CgluZXctPmluZGV4ID0gMDsKCW1lbWNweShuZXctPm5hbWUsIG5ld19uYW1lLCBuYW1lbGVuICsgMSk7CgoJY2FjaGVfdHJlZV9pbnZhbGlkYXRlX3BhdGgoaXN0YXRlLCBvbGQtPm5hbWUpOwoJcmVtb3ZlX2luZGV4X2VudHJ5X2F0KGlzdGF0ZSwgbnIpOwoJYWRkX2luZGV4X2VudHJ5KGlzdGF0ZSwgbmV3LCBBRERfQ0FDSEVfT0tfVE9fQUREfEFERF9DQUNIRV9PS19UT19SRVBMQUNFKTsKfQoKdm9pZCBmaWxsX3N0YXRfZGF0YShzdHJ1Y3Qgc3RhdF9kYXRhICpzZCwgc3RydWN0IHN0YXQgKnN0KQp7CglzZC0+c2RfY3RpbWUuc2VjID0gKHVuc2lnbmVkIGludClzdC0+c3RfY3RpbWU7CglzZC0+c2RfbXRpbWUuc2VjID0gKHVuc2lnbmVkIGludClzdC0+c3RfbXRpbWU7CglzZC0+c2RfY3RpbWUubnNlYyA9IFNUX0NUSU1FX05TRUMoKnN0KTsKCXNkLT5zZF9tdGltZS5uc2VjID0gU1RfTVRJTUVfTlNFQygqc3QpOwoJc2QtPnNkX2RldiA9IHN0LT5zdF9kZXY7CglzZC0+c2RfaW5vID0gc3QtPnN0X2lubzsKCXNkLT5zZF91aWQgPSBzdC0+c3RfdWlkOwoJc2QtPnNkX2dpZCA9IHN0LT5zdF9naWQ7CglzZC0+c2Rfc2l6ZSA9IHN0LT5zdF9zaXplOwp9CgppbnQgbWF0Y2hfc3RhdF9kYXRhKGNvbnN0IHN0cnVjdCBzdGF0X2RhdGEgKnNkLCBzdHJ1Y3Qgc3RhdCAqc3QpCnsKCWludCBjaGFuZ2VkID0gMDsKCglpZiAoc2QtPnNkX210aW1lLnNlYyAhPSAodW5zaWduZWQgaW50KXN0LT5zdF9tdGltZSkKCQljaGFuZ2VkIHw9IE1USU1FX0NIQU5HRUQ7CglpZiAodHJ1c3RfY3RpbWUgJiYgY2hlY2tfc3RhdCAmJgoJICAgIHNkLT5zZF9jdGltZS5zZWMgIT0gKHVuc2lnbmVkIGludClzdC0+c3RfY3RpbWUpCgkJY2hhbmdlZCB8PSBDVElNRV9DSEFOR0VEOwoKI2lmZGVmIFVTRV9OU0VDCglpZiAoY2hlY2tfc3RhdCAmJiBzZC0+c2RfbXRpbWUubnNlYyAhPSBTVF9NVElNRV9OU0VDKCpzdCkpCgkJY2hhbmdlZCB8PSBNVElNRV9DSEFOR0VEOwoJaWYgKHRydXN0X2N0aW1lICYmIGNoZWNrX3N0YXQgJiYKCSAgICBzZC0+c2RfY3RpbWUubnNlYyAhPSBTVF9DVElNRV9OU0VDKCpzdCkpCgkJY2hhbmdlZCB8PSBDVElNRV9DSEFOR0VEOwojZW5kaWYKCglpZiAoY2hlY2tfc3RhdCkgewoJCWlmIChzZC0+c2RfdWlkICE9ICh1bnNpZ25lZCBpbnQpIHN0LT5zdF91aWQgfHwKCQkJc2QtPnNkX2dpZCAhPSAodW5zaWduZWQgaW50KSBzdC0+c3RfZ2lkKQoJCQljaGFuZ2VkIHw9IE9XTkVSX0NIQU5HRUQ7CgkJaWYgKHNkLT5zZF9pbm8gIT0gKHVuc2lnbmVkIGludCkgc3QtPnN0X2lubykKCQkJY2hhbmdlZCB8PSBJTk9ERV9DSEFOR0VEOwoJfQoKI2lmZGVmIFVTRV9TVERFVgoJLyoKCSAqIHN0X2RldiBicmVha3Mgb24gbmV0d29yayBmaWxlc3lzdGVtcyB3aGVyZSBkaWZmZXJlbnQKCSAqIGNsaWVudHMgd2lsbCBoYXZlIGRpZmZlcmVudCB2aWV3cyBvZiB3aGF0ICJkZXZpY2UiCgkgKiB0aGUgZmlsZXN5c3RlbSBpcyBvbgoJICovCglpZiAoY2hlY2tfc3RhdCAmJiBzZC0+c2RfZGV2ICE9ICh1bnNpZ25lZCBpbnQpIHN0LT5zdF9kZXYpCgkJCWNoYW5nZWQgfD0gSU5PREVfQ0hBTkdFRDsKI2VuZGlmCgoJaWYgKHNkLT5zZF9zaXplICE9ICh1bnNpZ25lZCBpbnQpIHN0LT5zdF9zaXplKQoJCWNoYW5nZWQgfD0gREFUQV9DSEFOR0VEOwoKCXJldHVybiBjaGFuZ2VkOwp9CgovKgogKiBUaGlzIG9ubHkgdXBkYXRlcyB0aGUgIm5vbi1jcml0aWNhbCIgcGFydHMgb2YgdGhlIGRpcmVjdG9yeQogKiBjYWNoZSwgaWUgdGhlIHBhcnRzIHRoYXQgYXJlbid0IHRyYWNrZWQgYnkgR0lULCBhbmQgb25seSB1c2VkCiAqIHRvIHZhbGlkYXRlIHRoZSBjYWNoZS4KICovCnZvaWQgZmlsbF9zdGF0X2NhY2hlX2luZm8oc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgc3RydWN0IHN0YXQgKnN0KQp7CglmaWxsX3N0YXRfZGF0YSgmY2UtPmNlX3N0YXRfZGF0YSwgc3QpOwoKCWlmIChhc3N1bWVfdW5jaGFuZ2VkKQoJCWNlLT5jZV9mbGFncyB8PSBDRV9WQUxJRDsKCglpZiAoU19JU1JFRyhzdC0+c3RfbW9kZSkpCgkJY2VfbWFya191cHRvZGF0ZShjZSk7Cn0KCnN0YXRpYyBpbnQgY2VfY29tcGFyZV9kYXRhKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIHN0cnVjdCBzdGF0ICpzdCkKewoJaW50IG1hdGNoID0gLTE7CglpbnQgZmQgPSBvcGVuKGNlLT5uYW1lLCBPX1JET05MWSk7CgoJaWYgKGZkID49IDApIHsKCQl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJCWlmICghaW5kZXhfZmQoc2hhMSwgZmQsIHN0LCBPQkpfQkxPQiwgY2UtPm5hbWUsIDApKQoJCQltYXRjaCA9IGhhc2hjbXAoc2hhMSwgY2UtPnNoYTEpOwoJCS8qIGluZGV4X2ZkKCkgY2xvc2VkIHRoZSBmaWxlIGRlc2NyaXB0b3IgYWxyZWFkeSAqLwoJfQoJcmV0dXJuIG1hdGNoOwp9CgpzdGF0aWMgaW50IGNlX2NvbXBhcmVfbGluayhjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBzaXplX3QgZXhwZWN0ZWRfc2l6ZSkKewoJaW50IG1hdGNoID0gLTE7Cgl2b2lkICpidWZmZXI7Cgl1bnNpZ25lZCBsb25nIHNpemU7CgllbnVtIG9iamVjdF90eXBlIHR5cGU7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CgoJaWYgKHN0cmJ1Zl9yZWFkbGluaygmc2IsIGNlLT5uYW1lLCBleHBlY3RlZF9zaXplKSkKCQlyZXR1cm4gLTE7CgoJYnVmZmVyID0gcmVhZF9zaGExX2ZpbGUoY2UtPnNoYTEsICZ0eXBlLCAmc2l6ZSk7CglpZiAoYnVmZmVyKSB7CgkJaWYgKHNpemUgPT0gc2IubGVuKQoJCQltYXRjaCA9IG1lbWNtcChidWZmZXIsIHNiLmJ1Ziwgc2l6ZSk7CgkJZnJlZShidWZmZXIpOwoJfQoJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCXJldHVybiBtYXRjaDsKfQoKc3RhdGljIGludCBjZV9jb21wYXJlX2dpdGxpbmsoY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSkKewoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCgkvKgoJICogV2UgZG9uJ3QgYWN0dWFsbHkgcmVxdWlyZSB0aGF0IHRoZSAuZ2l0IGRpcmVjdG9yeQoJICogdW5kZXIgR0lUTElOSyBkaXJlY3RvcnkgYmUgYSB2YWxpZCBnaXQgZGlyZWN0b3J5LiBJdAoJICogbWlnaHQgZXZlbiBiZSBtaXNzaW5nIChpbiBjYXNlIG5vYm9keSBwb3B1bGF0ZWQgdGhhdAoJICogc3ViLXByb2plY3QpLgoJICoKCSAqIElmIHNvLCB3ZSBjb25zaWRlciBpdCBhbHdheXMgdG8gbWF0Y2guCgkgKi8KCWlmIChyZXNvbHZlX2dpdGxpbmtfcmVmKGNlLT5uYW1lLCAiSEVBRCIsIHNoYTEpIDwgMCkKCQlyZXR1cm4gMDsKCXJldHVybiBoYXNoY21wKHNoYTEsIGNlLT5zaGExKTsKfQoKc3RhdGljIGludCBjZV9tb2RpZmllZF9jaGVja19mcyhjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBzdHJ1Y3Qgc3RhdCAqc3QpCnsKCXN3aXRjaCAoc3QtPnN0X21vZGUgJiBTX0lGTVQpIHsKCWNhc2UgU19JRlJFRzoKCQlpZiAoY2VfY29tcGFyZV9kYXRhKGNlLCBzdCkpCgkJCXJldHVybiBEQVRBX0NIQU5HRUQ7CgkJYnJlYWs7CgljYXNlIFNfSUZMTks6CgkJaWYgKGNlX2NvbXBhcmVfbGluayhjZSwgeHNpemVfdChzdC0+c3Rfc2l6ZSkpKQoJCQlyZXR1cm4gREFUQV9DSEFOR0VEOwoJCWJyZWFrOwoJY2FzZSBTX0lGRElSOgoJCWlmIChTX0lTR0lUTElOSyhjZS0+Y2VfbW9kZSkpCgkJCXJldHVybiBjZV9jb21wYXJlX2dpdGxpbmsoY2UpID8gREFUQV9DSEFOR0VEIDogMDsKCWRlZmF1bHQ6CgkJcmV0dXJuIFRZUEVfQ0hBTkdFRDsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGNlX21hdGNoX3N0YXRfYmFzaWMoY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgc3RydWN0IHN0YXQgKnN0KQp7Cgl1bnNpZ25lZCBpbnQgY2hhbmdlZCA9IDA7CgoJaWYgKGNlLT5jZV9mbGFncyAmIENFX1JFTU9WRSkKCQlyZXR1cm4gTU9ERV9DSEFOR0VEIHwgREFUQV9DSEFOR0VEIHwgVFlQRV9DSEFOR0VEOwoKCXN3aXRjaCAoY2UtPmNlX21vZGUgJiBTX0lGTVQpIHsKCWNhc2UgU19JRlJFRzoKCQljaGFuZ2VkIHw9ICFTX0lTUkVHKHN0LT5zdF9tb2RlKSA/IFRZUEVfQ0hBTkdFRCA6IDA7CgkJLyogV2UgY29uc2lkZXIgb25seSB0aGUgb3duZXIgeCBiaXQgdG8gYmUgcmVsZXZhbnQgZm9yCgkJICogIm1vZGUgY2hhbmdlcyIKCQkgKi8KCQlpZiAodHJ1c3RfZXhlY3V0YWJsZV9iaXQgJiYKCQkgICAgKDAxMDAgJiAoY2UtPmNlX21vZGUgXiBzdC0+c3RfbW9kZSkpKQoJCQljaGFuZ2VkIHw9IE1PREVfQ0hBTkdFRDsKCQlicmVhazsKCWNhc2UgU19JRkxOSzoKCQlpZiAoIVNfSVNMTksoc3QtPnN0X21vZGUpICYmCgkJICAgIChoYXNfc3ltbGlua3MgfHwgIVNfSVNSRUcoc3QtPnN0X21vZGUpKSkKCQkJY2hhbmdlZCB8PSBUWVBFX0NIQU5HRUQ7CgkJYnJlYWs7CgljYXNlIFNfSUZHSVRMSU5LOgoJCS8qIFdlIGlnbm9yZSBtb3N0IG9mIHRoZSBzdF94eHggZmllbGRzIGZvciBnaXRsaW5rcyAqLwoJCWlmICghU19JU0RJUihzdC0+c3RfbW9kZSkpCgkJCWNoYW5nZWQgfD0gVFlQRV9DSEFOR0VEOwoJCWVsc2UgaWYgKGNlX2NvbXBhcmVfZ2l0bGluayhjZSkpCgkJCWNoYW5nZWQgfD0gREFUQV9DSEFOR0VEOwoJCXJldHVybiBjaGFuZ2VkOwoJZGVmYXVsdDoKCQlkaWUoImludGVybmFsIGVycm9yOiBjZV9tb2RlIGlzICVvIiwgY2UtPmNlX21vZGUpOwoJfQoKCWNoYW5nZWQgfD0gbWF0Y2hfc3RhdF9kYXRhKCZjZS0+Y2Vfc3RhdF9kYXRhLCBzdCk7CgoJLyogUmFjaWx5IHNtdWRnZWQgZW50cnk/ICovCglpZiAoIWNlLT5jZV9zdGF0X2RhdGEuc2Rfc2l6ZSkgewoJCWlmICghaXNfZW1wdHlfYmxvYl9zaGExKGNlLT5zaGExKSkKCQkJY2hhbmdlZCB8PSBEQVRBX0NIQU5HRUQ7Cgl9CgoJcmV0dXJuIGNoYW5nZWQ7Cn0KCnN0YXRpYyBpbnQgaXNfcmFjeV90aW1lc3RhbXAoY29uc3Qgc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsCgkJCSAgICAgY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSkKewoJcmV0dXJuICghU19JU0dJVExJTksoY2UtPmNlX21vZGUpICYmCgkJaXN0YXRlLT50aW1lc3RhbXAuc2VjICYmCiNpZmRlZiBVU0VfTlNFQwoJCSAvKiBuYW5vc2Vjb25kIHRpbWVzdGFtcGVkIGZpbGVzIGNhbiBhbHNvIGJlIHJhY3khICovCgkJKGlzdGF0ZS0+dGltZXN0YW1wLnNlYyA8IGNlLT5jZV9zdGF0X2RhdGEuc2RfbXRpbWUuc2VjIHx8CgkJIChpc3RhdGUtPnRpbWVzdGFtcC5zZWMgPT0gY2UtPmNlX3N0YXRfZGF0YS5zZF9tdGltZS5zZWMgJiYKCQkgIGlzdGF0ZS0+dGltZXN0YW1wLm5zZWMgPD0gY2UtPmNlX3N0YXRfZGF0YS5zZF9tdGltZS5uc2VjKSkKI2Vsc2UKCQlpc3RhdGUtPnRpbWVzdGFtcC5zZWMgPD0gY2UtPmNlX3N0YXRfZGF0YS5zZF9tdGltZS5zZWMKI2VuZGlmCgkJICk7Cn0KCmludCBpZV9tYXRjaF9zdGF0KGNvbnN0IHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLAoJCSAgY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgc3RydWN0IHN0YXQgKnN0LAoJCSAgdW5zaWduZWQgaW50IG9wdGlvbnMpCnsKCXVuc2lnbmVkIGludCBjaGFuZ2VkOwoJaW50IGlnbm9yZV92YWxpZCA9IG9wdGlvbnMgJiBDRV9NQVRDSF9JR05PUkVfVkFMSUQ7CglpbnQgaWdub3JlX3NraXBfd29ya3RyZWUgPSBvcHRpb25zICYgQ0VfTUFUQ0hfSUdOT1JFX1NLSVBfV09SS1RSRUU7CglpbnQgYXNzdW1lX3JhY3lfaXNfbW9kaWZpZWQgPSBvcHRpb25zICYgQ0VfTUFUQ0hfUkFDWV9JU19ESVJUWTsKCgkvKgoJICogSWYgaXQncyBtYXJrZWQgYXMgYWx3YXlzIHZhbGlkIGluIHRoZSBpbmRleCwgaXQncwoJICogdmFsaWQgd2hhdGV2ZXIgdGhlIGNoZWNrZWQtb3V0IGNvcHkgc2F5cy4KCSAqCgkgKiBza2lwLXdvcmt0cmVlIGhhcyB0aGUgc2FtZSBlZmZlY3Qgd2l0aCBoaWdoZXIgcHJlY2VkZW5jZQoJICovCglpZiAoIWlnbm9yZV9za2lwX3dvcmt0cmVlICYmIGNlX3NraXBfd29ya3RyZWUoY2UpKQoJCXJldHVybiAwOwoJaWYgKCFpZ25vcmVfdmFsaWQgJiYgKGNlLT5jZV9mbGFncyAmIENFX1ZBTElEKSkKCQlyZXR1cm4gMDsKCgkvKgoJICogSW50ZW50LXRvLWFkZCBlbnRyaWVzIGhhdmUgbm90IGJlZW4gYWRkZWQsIHNvIHRoZSBpbmRleCBlbnRyeQoJICogYnkgZGVmaW5pdGlvbiBuZXZlciBtYXRjaGVzIHdoYXQgaXMgaW4gdGhlIHdvcmsgdHJlZSB1bnRpbCBpdAoJICogYWN0dWFsbHkgZ2V0cyBhZGRlZC4KCSAqLwoJaWYgKGNlLT5jZV9mbGFncyAmIENFX0lOVEVOVF9UT19BREQpCgkJcmV0dXJuIERBVEFfQ0hBTkdFRCB8IFRZUEVfQ0hBTkdFRCB8IE1PREVfQ0hBTkdFRDsKCgljaGFuZ2VkID0gY2VfbWF0Y2hfc3RhdF9iYXNpYyhjZSwgc3QpOwoKCS8qCgkgKiBXaXRoaW4gMSBzZWNvbmQgb2YgdGhpcyBzZXF1ZW5jZToKCSAqIAllY2hvIHh5enp5ID5maWxlICYmIGdpdC11cGRhdGUtaW5kZXggLS1hZGQgZmlsZQoJICogcnVubmluZyB0aGlzIGNvbW1hbmQ6CgkgKiAJZWNobyBmcm90eiA+ZmlsZQoJICogd291bGQgZ2l2ZSBhIGZhbHNlbHkgY2xlYW4gY2FjaGUgZW50cnkuICBUaGUgbXRpbWUgYW5kCgkgKiBsZW5ndGggbWF0Y2ggdGhlIGNhY2hlLCBhbmQgb3RoZXIgc3RhdCBmaWVsZHMgZG8gbm90IGNoYW5nZS4KCSAqCgkgKiBXZSBjb3VsZCBkZXRlY3QgdGhpcyBhdCB1cGRhdGUtaW5kZXggdGltZSAodGhlIGNhY2hlIGVudHJ5CgkgKiBiZWluZyByZWdpc3RlcmVkL3VwZGF0ZWQgcmVjb3JkcyB0aGUgc2FtZSB0aW1lIGFzICJub3ciKQoJICogYW5kIGRlbGF5IHRoZSByZXR1cm4gZnJvbSBnaXQtdXBkYXRlLWluZGV4LCBidXQgdGhhdCB3b3VsZAoJICogZWZmZWN0aXZlbHkgbWVhbiB3ZSBjYW4gbWFrZSBhdCBtb3N0IG9uZSBjb21taXQgcGVyIHNlY29uZCwKCSAqIHdoaWNoIGlzIG5vdCBhY2NlcHRhYmxlLiAgSW5zdGVhZCwgd2UgY2hlY2sgY2FjaGUgZW50cmllcwoJICogd2hvc2UgbXRpbWUgYXJlIHRoZSBzYW1lIGFzIHRoZSBpbmRleCBmaWxlIHRpbWVzdGFtcCBtb3JlCgkgKiBjYXJlZnVsbHkgdGhhbiBvdGhlcnMuCgkgKi8KCWlmICghY2hhbmdlZCAmJiBpc19yYWN5X3RpbWVzdGFtcChpc3RhdGUsIGNlKSkgewoJCWlmIChhc3N1bWVfcmFjeV9pc19tb2RpZmllZCkKCQkJY2hhbmdlZCB8PSBEQVRBX0NIQU5HRUQ7CgkJZWxzZQoJCQljaGFuZ2VkIHw9IGNlX21vZGlmaWVkX2NoZWNrX2ZzKGNlLCBzdCk7Cgl9CgoJcmV0dXJuIGNoYW5nZWQ7Cn0KCmludCBpZV9tb2RpZmllZChjb25zdCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwKCQljb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCXN0cnVjdCBzdGF0ICpzdCwgdW5zaWduZWQgaW50IG9wdGlvbnMpCnsKCWludCBjaGFuZ2VkLCBjaGFuZ2VkX2ZzOwoKCWNoYW5nZWQgPSBpZV9tYXRjaF9zdGF0KGlzdGF0ZSwgY2UsIHN0LCBvcHRpb25zKTsKCWlmICghY2hhbmdlZCkKCQlyZXR1cm4gMDsKCS8qCgkgKiBJZiB0aGUgbW9kZSBvciB0eXBlIGhhcyBjaGFuZ2VkLCB0aGVyZSdzIG5vIHBvaW50IGluIHRyeWluZwoJICogdG8gcmVmcmVzaCB0aGUgZW50cnkgLSBpdCdzIG5vdCBnb2luZyB0byBtYXRjaAoJICovCglpZiAoY2hhbmdlZCAmIChNT0RFX0NIQU5HRUQgfCBUWVBFX0NIQU5HRUQpKQoJCXJldHVybiBjaGFuZ2VkOwoKCS8qCgkgKiBJbW1lZGlhdGVseSBhZnRlciByZWFkLXRyZWUgb3IgdXBkYXRlLWluZGV4IC0tY2FjaGVpbmZvLAoJICogdGhlIGxlbmd0aCBmaWVsZCBpcyB6ZXJvLCBhcyB3ZSBoYXZlIG5ldmVyIGV2ZW4gcmVhZCB0aGUKCSAqIGxzdGF0KDIpIGluZm9ybWF0aW9uIG9uY2UsIGFuZCB3ZSBjYW5ub3QgdHJ1c3QgREFUQV9DSEFOR0VECgkgKiByZXR1cm5lZCBieSBpZV9tYXRjaF9zdGF0KCkgd2hpY2ggaW4gdHVybiB3YXMgcmV0dXJuZWQgYnkKCSAqIGNlX21hdGNoX3N0YXRfYmFzaWMoKSB0byBzaWduYWwgdGhhdCB0aGUgZmlsZXNpemUgb2YgdGhlCgkgKiBibG9iIGNoYW5nZWQuICBXZSBoYXZlIHRvIGFjdHVhbGx5IGdvIHRvIHRoZSBmaWxlc3lzdGVtIHRvCgkgKiBzZWUgaWYgdGhlIGNvbnRlbnRzIG1hdGNoLCBhbmQgaWYgc28sIHNob3VsZCBhbnN3ZXIgInVuY2hhbmdlZCIuCgkgKgoJICogVGhlIGxvZ2ljIGRvZXMgbm90IGFwcGx5IHRvIGdpdGxpbmtzLCBhcyBjZV9tYXRjaF9zdGF0X2Jhc2ljKCkKCSAqIGFscmVhZHkgaGFzIGNoZWNrZWQgdGhlIGFjdHVhbCBIRUFEIGZyb20gdGhlIGZpbGVzeXN0ZW0gaW4gdGhlCgkgKiBzdWJwcm9qZWN0LiAgSWYgaWVfbWF0Y2hfc3RhdCgpIGFscmVhZHkgc2FpZCBpdCBpcyBkaWZmZXJlbnQsCgkgKiB0aGVuIHdlIGtub3cgaXQgaXMuCgkgKi8KCWlmICgoY2hhbmdlZCAmIERBVEFfQ0hBTkdFRCkgJiYKCSAgICAoU19JU0dJVExJTksoY2UtPmNlX21vZGUpIHx8IGNlLT5jZV9zdGF0X2RhdGEuc2Rfc2l6ZSAhPSAwKSkKCQlyZXR1cm4gY2hhbmdlZDsKCgljaGFuZ2VkX2ZzID0gY2VfbW9kaWZpZWRfY2hlY2tfZnMoY2UsIHN0KTsKCWlmIChjaGFuZ2VkX2ZzKQoJCXJldHVybiBjaGFuZ2VkIHwgY2hhbmdlZF9mczsKCXJldHVybiAwOwp9CgppbnQgYmFzZV9uYW1lX2NvbXBhcmUoY29uc3QgY2hhciAqbmFtZTEsIGludCBsZW4xLCBpbnQgbW9kZTEsCgkJICAgICAgY29uc3QgY2hhciAqbmFtZTIsIGludCBsZW4yLCBpbnQgbW9kZTIpCnsKCXVuc2lnbmVkIGNoYXIgYzEsIGMyOwoJaW50IGxlbiA9IGxlbjEgPCBsZW4yID8gbGVuMSA6IGxlbjI7CglpbnQgY21wOwoKCWNtcCA9IG1lbWNtcChuYW1lMSwgbmFtZTIsIGxlbik7CglpZiAoY21wKQoJCXJldHVybiBjbXA7CgljMSA9IG5hbWUxW2xlbl07CgljMiA9IG5hbWUyW2xlbl07CglpZiAoIWMxICYmIFNfSVNESVIobW9kZTEpKQoJCWMxID0gJy8nOwoJaWYgKCFjMiAmJiBTX0lTRElSKG1vZGUyKSkKCQljMiA9ICcvJzsKCXJldHVybiAoYzEgPCBjMikgPyAtMSA6IChjMSA+IGMyKSA/IDEgOiAwOwp9CgovKgogKiBkZl9uYW1lX2NvbXBhcmUoKSBpcyBpZGVudGljYWwgdG8gYmFzZV9uYW1lX2NvbXBhcmUoKSwgZXhjZXB0IGl0CiAqIGNvbXBhcmVzIGNvbmZsaWN0aW5nIGRpcmVjdG9yeS9maWxlIGVudHJpZXMgYXMgZXF1YWwuIE5vdGUgdGhhdAogKiB3aGlsZSBhIGRpcmVjdG9yeSBuYW1lIGNvbXBhcmVzIGFzIGVxdWFsIHRvIGEgcmVndWxhciBmaWxlLCB0aGV5CiAqIHRoZW4gaW5kaXZpZHVhbGx5IGNvbXBhcmUgX2RpZmZlcmVudGx5XyB0byBhIGZpbGVuYW1lIHRoYXQgaGFzCiAqIGEgZG90IGFmdGVyIHRoZSBiYXNlbmFtZSAoYmVjYXVzZSAnXDAnIDwgJy4nIDwgJy8nKS4KICoKICogVGhpcyBpcyB1c2VkIGJ5IHJvdXRpbmVzIHRoYXQgd2FudCB0byB0cmF2ZXJzZSB0aGUgZ2l0IG5hbWVzcGFjZQogKiBidXQgdGhlbiBoYW5kbGUgY29uZmxpY3RpbmcgZW50cmllcyB0b2dldGhlciB3aGVuIHBvc3NpYmxlLgogKi8KaW50IGRmX25hbWVfY29tcGFyZShjb25zdCBjaGFyICpuYW1lMSwgaW50IGxlbjEsIGludCBtb2RlMSwKCQkgICAgY29uc3QgY2hhciAqbmFtZTIsIGludCBsZW4yLCBpbnQgbW9kZTIpCnsKCWludCBsZW4gPSBsZW4xIDwgbGVuMiA/IGxlbjEgOiBsZW4yLCBjbXA7Cgl1bnNpZ25lZCBjaGFyIGMxLCBjMjsKCgljbXAgPSBtZW1jbXAobmFtZTEsIG5hbWUyLCBsZW4pOwoJaWYgKGNtcCkKCQlyZXR1cm4gY21wOwoJLyogRGlyZWN0b3JpZXMgYW5kIGZpbGVzIGNvbXBhcmUgZXF1YWwgKHNhbWUgbGVuZ3RoLCBzYW1lIG5hbWUpICovCglpZiAobGVuMSA9PSBsZW4yKQoJCXJldHVybiAwOwoJYzEgPSBuYW1lMVtsZW5dOwoJaWYgKCFjMSAmJiBTX0lTRElSKG1vZGUxKSkKCQljMSA9ICcvJzsKCWMyID0gbmFtZTJbbGVuXTsKCWlmICghYzIgJiYgU19JU0RJUihtb2RlMikpCgkJYzIgPSAnLyc7CglpZiAoYzEgPT0gJy8nICYmICFjMikKCQlyZXR1cm4gMDsKCWlmIChjMiA9PSAnLycgJiYgIWMxKQoJCXJldHVybiAwOwoJcmV0dXJuIGMxIC0gYzI7Cn0KCmludCBuYW1lX2NvbXBhcmUoY29uc3QgY2hhciAqbmFtZTEsIHNpemVfdCBsZW4xLCBjb25zdCBjaGFyICpuYW1lMiwgc2l6ZV90IGxlbjIpCnsKCXNpemVfdCBtaW5fbGVuID0gKGxlbjEgPCBsZW4yKSA/IGxlbjEgOiBsZW4yOwoJaW50IGNtcCA9IG1lbWNtcChuYW1lMSwgbmFtZTIsIG1pbl9sZW4pOwoJaWYgKGNtcCkKCQlyZXR1cm4gY21wOwoJaWYgKGxlbjEgPCBsZW4yKQoJCXJldHVybiAtMTsKCWlmIChsZW4xID4gbGVuMikKCQlyZXR1cm4gMTsKCXJldHVybiAwOwp9CgppbnQgY2FjaGVfbmFtZV9zdGFnZV9jb21wYXJlKGNvbnN0IGNoYXIgKm5hbWUxLCBpbnQgbGVuMSwgaW50IHN0YWdlMSwgY29uc3QgY2hhciAqbmFtZTIsIGludCBsZW4yLCBpbnQgc3RhZ2UyKQp7CglpbnQgY21wOwoKCWNtcCA9IG5hbWVfY29tcGFyZShuYW1lMSwgbGVuMSwgbmFtZTIsIGxlbjIpOwoJaWYgKGNtcCkKCQlyZXR1cm4gY21wOwoKCWlmIChzdGFnZTEgPCBzdGFnZTIpCgkJcmV0dXJuIC0xOwoJaWYgKHN0YWdlMSA+IHN0YWdlMikKCQlyZXR1cm4gMTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGluZGV4X25hbWVfc3RhZ2VfcG9zKGNvbnN0IHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbiwgaW50IHN0YWdlKQp7CglpbnQgZmlyc3QsIGxhc3Q7CgoJZmlyc3QgPSAwOwoJbGFzdCA9IGlzdGF0ZS0+Y2FjaGVfbnI7Cgl3aGlsZSAobGFzdCA+IGZpcnN0KSB7CgkJaW50IG5leHQgPSAobGFzdCArIGZpcnN0KSA+PiAxOwoJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBpc3RhdGUtPmNhY2hlW25leHRdOwoJCWludCBjbXAgPSBjYWNoZV9uYW1lX3N0YWdlX2NvbXBhcmUobmFtZSwgbmFtZWxlbiwgc3RhZ2UsIGNlLT5uYW1lLCBjZV9uYW1lbGVuKGNlKSwgY2Vfc3RhZ2UoY2UpKTsKCQlpZiAoIWNtcCkKCQkJcmV0dXJuIG5leHQ7CgkJaWYgKGNtcCA8IDApIHsKCQkJbGFzdCA9IG5leHQ7CgkJCWNvbnRpbnVlOwoJCX0KCQlmaXJzdCA9IG5leHQrMTsKCX0KCXJldHVybiAtZmlyc3QtMTsKfQoKaW50IGluZGV4X25hbWVfcG9zKGNvbnN0IHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbikKewoJcmV0dXJuIGluZGV4X25hbWVfc3RhZ2VfcG9zKGlzdGF0ZSwgbmFtZSwgbmFtZWxlbiwgMCk7Cn0KCi8qIFJlbW92ZSBlbnRyeSwgcmV0dXJuIHRydWUgaWYgdGhlcmUgYXJlIG1vcmUgZW50cmllcyB0byBnby4uICovCmludCByZW1vdmVfaW5kZXhfZW50cnlfYXQoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIGludCBwb3MpCnsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBpc3RhdGUtPmNhY2hlW3Bvc107CgoJcmVjb3JkX3Jlc29sdmVfdW5kbyhpc3RhdGUsIGNlKTsKCXJlbW92ZV9uYW1lX2hhc2goaXN0YXRlLCBjZSk7CglzYXZlX29yX2ZyZWVfaW5kZXhfZW50cnkoaXN0YXRlLCBjZSk7Cglpc3RhdGUtPmNhY2hlX2NoYW5nZWQgfD0gQ0VfRU5UUllfUkVNT1ZFRDsKCWlzdGF0ZS0+Y2FjaGVfbnItLTsKCWlmIChwb3MgPj0gaXN0YXRlLT5jYWNoZV9ucikKCQlyZXR1cm4gMDsKCW1lbW1vdmUoaXN0YXRlLT5jYWNoZSArIHBvcywKCQlpc3RhdGUtPmNhY2hlICsgcG9zICsgMSwKCQkoaXN0YXRlLT5jYWNoZV9uciAtIHBvcykgKiBzaXplb2Yoc3RydWN0IGNhY2hlX2VudHJ5ICopKTsKCXJldHVybiAxOwp9CgovKgogKiBSZW1vdmUgYWxsIGNhY2hlIGVudHJpZXMgbWFya2VkIGZvciByZW1vdmFsLCB0aGF0IGlzIHdoZXJlCiAqIENFX1JFTU9WRSBpcyBzZXQgaW4gY2VfZmxhZ3MuICBUaGlzIGlzIG11Y2ggbW9yZSBlZmZlY3RpdmUgdGhhbgogKiBjYWxsaW5nIHJlbW92ZV9pbmRleF9lbnRyeV9hdCgpIGZvciBlYWNoIGVudHJ5IHRvIGJlIHJlbW92ZWQuCiAqLwp2b2lkIHJlbW92ZV9tYXJrZWRfY2FjaGVfZW50cmllcyhzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSkKewoJc3RydWN0IGNhY2hlX2VudHJ5ICoqY2VfYXJyYXkgPSBpc3RhdGUtPmNhY2hlOwoJdW5zaWduZWQgaW50IGksIGo7CgoJZm9yIChpID0gaiA9IDA7IGkgPCBpc3RhdGUtPmNhY2hlX25yOyBpKyspIHsKCQlpZiAoY2VfYXJyYXlbaV0tPmNlX2ZsYWdzICYgQ0VfUkVNT1ZFKSB7CgkJCXJlbW92ZV9uYW1lX2hhc2goaXN0YXRlLCBjZV9hcnJheVtpXSk7CgkJCXNhdmVfb3JfZnJlZV9pbmRleF9lbnRyeShpc3RhdGUsIGNlX2FycmF5W2ldKTsKCQl9CgkJZWxzZQoJCQljZV9hcnJheVtqKytdID0gY2VfYXJyYXlbaV07Cgl9CglpZiAoaiA9PSBpc3RhdGUtPmNhY2hlX25yKQoJCXJldHVybjsKCWlzdGF0ZS0+Y2FjaGVfY2hhbmdlZCB8PSBDRV9FTlRSWV9SRU1PVkVEOwoJaXN0YXRlLT5jYWNoZV9uciA9IGo7Cn0KCmludCByZW1vdmVfZmlsZV9mcm9tX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBjb25zdCBjaGFyICpwYXRoKQp7CglpbnQgcG9zID0gaW5kZXhfbmFtZV9wb3MoaXN0YXRlLCBwYXRoLCBzdHJsZW4ocGF0aCkpOwoJaWYgKHBvcyA8IDApCgkJcG9zID0gLXBvcy0xOwoJY2FjaGVfdHJlZV9pbnZhbGlkYXRlX3BhdGgoaXN0YXRlLCBwYXRoKTsKCXdoaWxlIChwb3MgPCBpc3RhdGUtPmNhY2hlX25yICYmICFzdHJjbXAoaXN0YXRlLT5jYWNoZVtwb3NdLT5uYW1lLCBwYXRoKSkKCQlyZW1vdmVfaW5kZXhfZW50cnlfYXQoaXN0YXRlLCBwb3MpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgY29tcGFyZV9uYW1lKHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIGNvbnN0IGNoYXIgKnBhdGgsIGludCBuYW1lbGVuKQp7CglyZXR1cm4gbmFtZWxlbiAhPSBjZV9uYW1lbGVuKGNlKSB8fCBtZW1jbXAocGF0aCwgY2UtPm5hbWUsIG5hbWVsZW4pOwp9CgpzdGF0aWMgaW50IGluZGV4X25hbWVfcG9zX2Fsc29fdW5tZXJnZWQoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsCgljb25zdCBjaGFyICpwYXRoLCBpbnQgbmFtZWxlbikKewoJaW50IHBvcyA9IGluZGV4X25hbWVfcG9zKGlzdGF0ZSwgcGF0aCwgbmFtZWxlbik7CglzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlOwoKCWlmIChwb3MgPj0gMCkKCQlyZXR1cm4gcG9zOwoKCS8qIG1heWJlIHVubWVyZ2VkPyAqLwoJcG9zID0gLTEgLSBwb3M7CglpZiAocG9zID49IGlzdGF0ZS0+Y2FjaGVfbnIgfHwKCQkJY29tcGFyZV9uYW1lKChjZSA9IGlzdGF0ZS0+Y2FjaGVbcG9zXSksIHBhdGgsIG5hbWVsZW4pKQoJCXJldHVybiAtMTsKCgkvKiBvcmRlciBvZiBwcmVmZXJlbmNlOiBzdGFnZSAyLCAxLCAzICovCglpZiAoY2Vfc3RhZ2UoY2UpID09IDEgJiYgcG9zICsgMSA8IGlzdGF0ZS0+Y2FjaGVfbnIgJiYKCQkJY2Vfc3RhZ2UoKGNlID0gaXN0YXRlLT5jYWNoZVtwb3MgKyAxXSkpID09IDIgJiYKCQkJIWNvbXBhcmVfbmFtZShjZSwgcGF0aCwgbmFtZWxlbikpCgkJcG9zKys7CglyZXR1cm4gcG9zOwp9CgpzdGF0aWMgaW50IGRpZmZlcmVudF9uYW1lKHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIHN0cnVjdCBjYWNoZV9lbnRyeSAqYWxpYXMpCnsKCWludCBsZW4gPSBjZV9uYW1lbGVuKGNlKTsKCXJldHVybiBjZV9uYW1lbGVuKGFsaWFzKSAhPSBsZW4gfHwgbWVtY21wKGNlLT5uYW1lLCBhbGlhcy0+bmFtZSwgbGVuKTsKfQoKLyoKICogSWYgd2UgYWRkIGEgZmlsZW5hbWUgdGhhdCBhbGlhc2VzIGluIHRoZSBjYWNoZSwgd2Ugd2lsbCB1c2UgdGhlCiAqIG5hbWUgdGhhdCB3ZSBhbHJlYWR5IGhhdmUgLSBidXQgd2UgZG9uJ3Qgd2FudCB0byB1cGRhdGUgdGhlIHNhbWUKICogYWxpYXMgdHdpY2UsIGJlY2F1c2UgdGhhdCBpbXBsaWVzIHRoYXQgdGhlcmUgd2VyZSBhY3R1YWxseSB0d28KICogZGlmZmVyZW50IGZpbGVzIHdpdGggYWxpYXNpbmcgbmFtZXMhCiAqCiAqIFNvIHdlIHVzZSB0aGUgQ0VfQURERUQgZmxhZyB0byB2ZXJpZnkgdGhhdCB0aGUgYWxpYXMgd2FzIGFuIG9sZAogKiBvbmUgYmVmb3JlIHdlIGFjY2VwdCBpdCBhcwogKi8Kc3RhdGljIHN0cnVjdCBjYWNoZV9lbnRyeSAqY3JlYXRlX2FsaWFzX2NlKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLAoJCQkJCSAgIHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCQkJICAgc3RydWN0IGNhY2hlX2VudHJ5ICphbGlhcykKewoJaW50IGxlbjsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqbmV3OwoKCWlmIChhbGlhcy0+Y2VfZmxhZ3MgJiBDRV9BRERFRCkKCQlkaWUoIldpbGwgbm90IGFkZCBmaWxlIGFsaWFzICclcycgKCclcycgYWxyZWFkeSBleGlzdHMgaW4gaW5kZXgpIiwgY2UtPm5hbWUsIGFsaWFzLT5uYW1lKTsKCgkvKiBPaywgY3JlYXRlIHRoZSBuZXcgZW50cnkgdXNpbmcgdGhlIG5hbWUgb2YgdGhlIGV4aXN0aW5nIGFsaWFzICovCglsZW4gPSBjZV9uYW1lbGVuKGFsaWFzKTsKCW5ldyA9IHhjYWxsb2MoMSwgY2FjaGVfZW50cnlfc2l6ZShsZW4pKTsKCW1lbWNweShuZXctPm5hbWUsIGFsaWFzLT5uYW1lLCBsZW4pOwoJY29weV9jYWNoZV9lbnRyeShuZXcsIGNlKTsKCXNhdmVfb3JfZnJlZV9pbmRleF9lbnRyeShpc3RhdGUsIGNlKTsKCXJldHVybiBuZXc7Cn0KCnZvaWQgc2V0X29iamVjdF9uYW1lX2Zvcl9pbnRlbnRfdG9fYWRkX2VudHJ5KHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UpCnsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CglpZiAod3JpdGVfc2hhMV9maWxlKCIiLCAwLCBibG9iX3R5cGUsIHNoYTEpKQoJCWRpZSgiY2Fubm90IGNyZWF0ZSBhbiBlbXB0eSBibG9iIGluIHRoZSBvYmplY3QgZGF0YWJhc2UiKTsKCWhhc2hjcHkoY2UtPnNoYTEsIHNoYTEpOwp9CgppbnQgYWRkX3RvX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBjb25zdCBjaGFyICpwYXRoLCBzdHJ1Y3Qgc3RhdCAqc3QsIGludCBmbGFncykKewoJaW50IHNpemUsIG5hbWVsZW4sIHdhc19zYW1lOwoJbW9kZV90IHN0X21vZGUgPSBzdC0+c3RfbW9kZTsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsICphbGlhczsKCXVuc2lnbmVkIGNlX29wdGlvbiA9IENFX01BVENIX0lHTk9SRV9WQUxJRHxDRV9NQVRDSF9JR05PUkVfU0tJUF9XT1JLVFJFRXxDRV9NQVRDSF9SQUNZX0lTX0RJUlRZOwoJaW50IHZlcmJvc2UgPSBmbGFncyAmIChBRERfQ0FDSEVfVkVSQk9TRSB8IEFERF9DQUNIRV9QUkVURU5EKTsKCWludCBwcmV0ZW5kID0gZmxhZ3MgJiBBRERfQ0FDSEVfUFJFVEVORDsKCWludCBpbnRlbnRfb25seSA9IGZsYWdzICYgQUREX0NBQ0hFX0lOVEVOVDsKCWludCBhZGRfb3B0aW9uID0gKEFERF9DQUNIRV9PS19UT19BRER8QUREX0NBQ0hFX09LX1RPX1JFUExBQ0V8CgkJCSAgKGludGVudF9vbmx5ID8gQUREX0NBQ0hFX05FV19PTkxZIDogMCkpOwoKCWlmICghU19JU1JFRyhzdF9tb2RlKSAmJiAhU19JU0xOSyhzdF9tb2RlKSAmJiAhU19JU0RJUihzdF9tb2RlKSkKCQlyZXR1cm4gZXJyb3IoIiVzOiBjYW4gb25seSBhZGQgcmVndWxhciBmaWxlcywgc3ltYm9saWMgbGlua3Mgb3IgZ2l0LWRpcmVjdG9yaWVzIiwgcGF0aCk7CgoJbmFtZWxlbiA9IHN0cmxlbihwYXRoKTsKCWlmIChTX0lTRElSKHN0X21vZGUpKSB7CgkJd2hpbGUgKG5hbWVsZW4gJiYgcGF0aFtuYW1lbGVuLTFdID09ICcvJykKCQkJbmFtZWxlbi0tOwoJfQoJc2l6ZSA9IGNhY2hlX2VudHJ5X3NpemUobmFtZWxlbik7CgljZSA9IHhjYWxsb2MoMSwgc2l6ZSk7CgltZW1jcHkoY2UtPm5hbWUsIHBhdGgsIG5hbWVsZW4pOwoJY2UtPmNlX25hbWVsZW4gPSBuYW1lbGVuOwoJaWYgKCFpbnRlbnRfb25seSkKCQlmaWxsX3N0YXRfY2FjaGVfaW5mbyhjZSwgc3QpOwoJZWxzZQoJCWNlLT5jZV9mbGFncyB8PSBDRV9JTlRFTlRfVE9fQUREOwoKCWlmICh0cnVzdF9leGVjdXRhYmxlX2JpdCAmJiBoYXNfc3ltbGlua3MpCgkJY2UtPmNlX21vZGUgPSBjcmVhdGVfY2VfbW9kZShzdF9tb2RlKTsKCWVsc2UgewoJCS8qIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGVudHJ5LCBwaWNrIHRoZSBtb2RlIGJpdHMgYW5kIHR5cGUKCQkgKiBmcm9tIGl0LCBvdGhlcndpc2UgYXNzdW1lIHVuZXhlY3V0YWJsZSByZWd1bGFyIGZpbGUuCgkJICovCgkJc3RydWN0IGNhY2hlX2VudHJ5ICplbnQ7CgkJaW50IHBvcyA9IGluZGV4X25hbWVfcG9zX2Fsc29fdW5tZXJnZWQoaXN0YXRlLCBwYXRoLCBuYW1lbGVuKTsKCgkJZW50ID0gKDAgPD0gcG9zKSA/IGlzdGF0ZS0+Y2FjaGVbcG9zXSA6IE5VTEw7CgkJY2UtPmNlX21vZGUgPSBjZV9tb2RlX2Zyb21fc3RhdChlbnQsIHN0X21vZGUpOwoJfQoKCS8qIFdoZW4gY29yZS5pZ25vcmVjYXNlPXRydWUsIGRldGVybWluZSBpZiBhIGRpcmVjdG9yeSBvZiB0aGUgc2FtZSBuYW1lIGJ1dCBkaWZmZXJpbmcKCSAqIGNhc2UgYWxyZWFkeSBleGlzdHMgd2l0aGluIHRoZSBHaXQgcmVwb3NpdG9yeS4gIElmIGl0IGRvZXMsIGVuc3VyZSB0aGUgZGlyZWN0b3J5CgkgKiBjYXNlIG9mIHRoZSBmaWxlIGJlaW5nIGFkZGVkIHRvIHRoZSByZXBvc2l0b3J5IG1hdGNoZXMgKGlzIGZvbGRlZCBpbnRvKSB0aGUgZXhpc3RpbmcKCSAqIGVudHJ5J3MgZGlyZWN0b3J5IGNhc2UuCgkgKi8KCWlmIChpZ25vcmVfY2FzZSkgewoJCWNvbnN0IGNoYXIgKnN0YXJ0UHRyID0gY2UtPm5hbWU7CgkJY29uc3QgY2hhciAqcHRyID0gc3RhcnRQdHI7CgkJd2hpbGUgKCpwdHIpIHsKCQkJd2hpbGUgKCpwdHIgJiYgKnB0ciAhPSAnLycpCgkJCQkrK3B0cjsKCQkJaWYgKCpwdHIgPT0gJy8nKSB7CgkJCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmZvdW5kY2U7CgkJCQkrK3B0cjsKCQkJCWZvdW5kY2UgPSBpbmRleF9kaXJfZXhpc3RzKGlzdGF0ZSwgY2UtPm5hbWUsIHB0ciAtIGNlLT5uYW1lIC0gMSk7CgkJCQlpZiAoZm91bmRjZSkgewoJCQkJCW1lbWNweSgodm9pZCAqKXN0YXJ0UHRyLCBmb3VuZGNlLT5uYW1lICsgKHN0YXJ0UHRyIC0gY2UtPm5hbWUpLCBwdHIgLSBzdGFydFB0cik7CgkJCQkJc3RhcnRQdHIgPSBwdHI7CgkJCQl9CgkJCX0KCQl9Cgl9CgoJYWxpYXMgPSBpbmRleF9maWxlX2V4aXN0cyhpc3RhdGUsIGNlLT5uYW1lLCBjZV9uYW1lbGVuKGNlKSwgaWdub3JlX2Nhc2UpOwoJaWYgKGFsaWFzICYmICFjZV9zdGFnZShhbGlhcykgJiYgIWllX21hdGNoX3N0YXQoaXN0YXRlLCBhbGlhcywgc3QsIGNlX29wdGlvbikpIHsKCQkvKiBOb3RoaW5nIGNoYW5nZWQsIHJlYWxseSAqLwoJCWlmICghU19JU0dJVExJTksoYWxpYXMtPmNlX21vZGUpKQoJCQljZV9tYXJrX3VwdG9kYXRlKGFsaWFzKTsKCQlhbGlhcy0+Y2VfZmxhZ3MgfD0gQ0VfQURERUQ7CgoJCWZyZWUoY2UpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFpbnRlbnRfb25seSkgewoJCWlmIChpbmRleF9wYXRoKGNlLT5zaGExLCBwYXRoLCBzdCwgSEFTSF9XUklURV9PQkpFQ1QpKSB7CgkJCWZyZWUoY2UpOwoJCQlyZXR1cm4gZXJyb3IoInVuYWJsZSB0byBpbmRleCBmaWxlICVzIiwgcGF0aCk7CgkJfQoJfSBlbHNlCgkJc2V0X29iamVjdF9uYW1lX2Zvcl9pbnRlbnRfdG9fYWRkX2VudHJ5KGNlKTsKCglpZiAoaWdub3JlX2Nhc2UgJiYgYWxpYXMgJiYgZGlmZmVyZW50X25hbWUoY2UsIGFsaWFzKSkKCQljZSA9IGNyZWF0ZV9hbGlhc19jZShpc3RhdGUsIGNlLCBhbGlhcyk7CgljZS0+Y2VfZmxhZ3MgfD0gQ0VfQURERUQ7CgoJLyogSXQgd2FzIHN1c3BlY3RlZCB0byBiZSByYWNpbHkgY2xlYW4sIGJ1dCBpdCB0dXJucyBvdXQgdG8gYmUgT2sgKi8KCXdhc19zYW1lID0gKGFsaWFzICYmCgkJICAgICFjZV9zdGFnZShhbGlhcykgJiYKCQkgICAgIWhhc2hjbXAoYWxpYXMtPnNoYTEsIGNlLT5zaGExKSAmJgoJCSAgICBjZS0+Y2VfbW9kZSA9PSBhbGlhcy0+Y2VfbW9kZSk7CgoJaWYgKHByZXRlbmQpCgkJZnJlZShjZSk7CgllbHNlIGlmIChhZGRfaW5kZXhfZW50cnkoaXN0YXRlLCBjZSwgYWRkX29wdGlvbikpIHsKCQlmcmVlKGNlKTsKCQlyZXR1cm4gZXJyb3IoInVuYWJsZSB0byBhZGQgJXMgdG8gaW5kZXgiLCBwYXRoKTsKCX0KCWlmICh2ZXJib3NlICYmICF3YXNfc2FtZSkKCQlwcmludGYoImFkZCAnJXMnXG4iLCBwYXRoKTsKCXJldHVybiAwOwp9CgppbnQgYWRkX2ZpbGVfdG9faW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIGNvbnN0IGNoYXIgKnBhdGgsIGludCBmbGFncykKewoJc3RydWN0IHN0YXQgc3Q7CglpZiAobHN0YXQocGF0aCwgJnN0KSkKCQlkaWVfZXJybm8oInVuYWJsZSB0byBzdGF0ICclcyciLCBwYXRoKTsKCXJldHVybiBhZGRfdG9faW5kZXgoaXN0YXRlLCBwYXRoLCAmc3QsIGZsYWdzKTsKfQoKc3RydWN0IGNhY2hlX2VudHJ5ICptYWtlX2NhY2hlX2VudHJ5KHVuc2lnbmVkIGludCBtb2RlLAoJCWNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIGNvbnN0IGNoYXIgKnBhdGgsIGludCBzdGFnZSwKCQl1bnNpZ25lZCBpbnQgcmVmcmVzaF9vcHRpb25zKQp7CglpbnQgc2l6ZSwgbGVuOwoJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgKnJldDsKCglpZiAoIXZlcmlmeV9wYXRoKHBhdGgpKSB7CgkJZXJyb3IoIkludmFsaWQgcGF0aCAnJXMnIiwgcGF0aCk7CgkJcmV0dXJuIE5VTEw7Cgl9CgoJbGVuID0gc3RybGVuKHBhdGgpOwoJc2l6ZSA9IGNhY2hlX2VudHJ5X3NpemUobGVuKTsKCWNlID0geGNhbGxvYygxLCBzaXplKTsKCgloYXNoY3B5KGNlLT5zaGExLCBzaGExKTsKCW1lbWNweShjZS0+bmFtZSwgcGF0aCwgbGVuKTsKCWNlLT5jZV9mbGFncyA9IGNyZWF0ZV9jZV9mbGFncyhzdGFnZSk7CgljZS0+Y2VfbmFtZWxlbiA9IGxlbjsKCWNlLT5jZV9tb2RlID0gY3JlYXRlX2NlX21vZGUobW9kZSk7CgoJcmV0ID0gcmVmcmVzaF9jYWNoZV9lbnRyeShjZSwgcmVmcmVzaF9vcHRpb25zKTsKCWlmIChyZXQgIT0gY2UpCgkJZnJlZShjZSk7CglyZXR1cm4gcmV0Owp9CgppbnQgY2Vfc2FtZV9uYW1lKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqYSwgY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpiKQp7CglpbnQgbGVuID0gY2VfbmFtZWxlbihhKTsKCXJldHVybiBjZV9uYW1lbGVuKGIpID09IGxlbiAmJiAhbWVtY21wKGEtPm5hbWUsIGItPm5hbWUsIGxlbik7Cn0KCi8qCiAqIFdlIGZ1bmRhbWVudGFsbHkgZG9uJ3QgbGlrZSBzb21lIHBhdGhzOiB3ZSBkb24ndCB3YW50CiAqIGRvdCBvciBkb3QtZG90IGFueXdoZXJlLCBhbmQgZm9yIG9idmlvdXMgcmVhc29ucyBkb24ndAogKiB3YW50IHRvIHJlY3Vyc2UgaW50byAiLmdpdCIgZWl0aGVyLgogKgogKiBBbHNvLCB3ZSBkb24ndCB3YW50IGRvdWJsZSBzbGFzaGVzIG9yIHNsYXNoZXMgYXQgdGhlCiAqIGVuZCB0aGF0IGNhbiBtYWtlIHBhdGhuYW1lcyBhbWJpZ3VvdXMuCiAqLwpzdGF0aWMgaW50IHZlcmlmeV9kb3RmaWxlKGNvbnN0IGNoYXIgKnJlc3QpCnsKCS8qCgkgKiBUaGUgZmlyc3QgY2hhcmFjdGVyIHdhcyAnLicsIGJ1dCB0aGF0CgkgKiBoYXMgYWxyZWFkeSBiZWVuIGRpc2NhcmRlZCwgd2Ugbm93IHRlc3QKCSAqIHRoZSByZXN0LgoJICovCgoJLyogIi4iIGlzIG5vdCBhbGxvd2VkICovCglpZiAoKnJlc3QgPT0gJ1wwJyB8fCBpc19kaXJfc2VwKCpyZXN0KSkKCQlyZXR1cm4gMDsKCglzd2l0Y2ggKCpyZXN0KSB7CgkvKgoJICogIi5naXQiIGZvbGxvd2VkIGJ5ICBOVUwgb3Igc2xhc2ggaXMgYmFkLiBUaGlzCgkgKiBzaGFyZXMgdGhlIHBhdGggZW5kIHRlc3Qgd2l0aCB0aGUgIi4uIiBjYXNlLgoJICovCgljYXNlICdnJzoKCWNhc2UgJ0cnOgoJCWlmIChyZXN0WzFdICE9ICdpJyAmJiByZXN0WzFdICE9ICdJJykKCQkJYnJlYWs7CgkJaWYgKHJlc3RbMl0gIT0gJ3QnICYmIHJlc3RbMl0gIT0gJ1QnKQoJCQlicmVhazsKCQlyZXN0ICs9IDI7CgkvKiBmYWxsdGhyb3VnaCAqLwoJY2FzZSAnLic6CgkJaWYgKHJlc3RbMV0gPT0gJ1wwJyB8fCBpc19kaXJfc2VwKHJlc3RbMV0pKQoJCQlyZXR1cm4gMDsKCX0KCXJldHVybiAxOwp9CgppbnQgdmVyaWZ5X3BhdGgoY29uc3QgY2hhciAqcGF0aCkKewoJY2hhciBjOwoKCWlmIChoYXNfZG9zX2RyaXZlX3ByZWZpeChwYXRoKSkKCQlyZXR1cm4gMDsKCglnb3RvIGluc2lkZTsKCWZvciAoOzspIHsKCQlpZiAoIWMpCgkJCXJldHVybiAxOwoJCWlmIChpc19kaXJfc2VwKGMpKSB7Cmluc2lkZToKCQkJaWYgKHByb3RlY3RfaGZzICYmIGlzX2hmc19kb3RnaXQocGF0aCkpCgkJCQlyZXR1cm4gMDsKCQkJaWYgKHByb3RlY3RfbnRmcyAmJiBpc19udGZzX2RvdGdpdChwYXRoKSkKCQkJCXJldHVybiAwOwoJCQljID0gKnBhdGgrKzsKCQkJaWYgKChjID09ICcuJyAmJiAhdmVyaWZ5X2RvdGZpbGUocGF0aCkpIHx8CgkJCSAgICBpc19kaXJfc2VwKGMpIHx8IGMgPT0gJ1wwJykKCQkJCXJldHVybiAwOwoJCX0KCQljID0gKnBhdGgrKzsKCX0KfQoKLyoKICogRG8gd2UgaGF2ZSBhbm90aGVyIGZpbGUgdGhhdCBoYXMgdGhlIGJlZ2lubmluZyBjb21wb25lbnRzIGJlaW5nIGEKICogcHJvcGVyIHN1cGVyc2V0IG9mIHRoZSBuYW1lIHdlJ3JlIHRyeWluZyB0byBhZGQ/CiAqLwpzdGF0aWMgaW50IGhhc19maWxlX25hbWUoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsCgkJCSBjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBpbnQgcG9zLCBpbnQgb2tfdG9fcmVwbGFjZSkKewoJaW50IHJldHZhbCA9IDA7CglpbnQgbGVuID0gY2VfbmFtZWxlbihjZSk7CglpbnQgc3RhZ2UgPSBjZV9zdGFnZShjZSk7Cgljb25zdCBjaGFyICpuYW1lID0gY2UtPm5hbWU7CgoJd2hpbGUgKHBvcyA8IGlzdGF0ZS0+Y2FjaGVfbnIpIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKnAgPSBpc3RhdGUtPmNhY2hlW3BvcysrXTsKCgkJaWYgKGxlbiA+PSBjZV9uYW1lbGVuKHApKQoJCQlicmVhazsKCQlpZiAobWVtY21wKG5hbWUsIHAtPm5hbWUsIGxlbikpCgkJCWJyZWFrOwoJCWlmIChjZV9zdGFnZShwKSAhPSBzdGFnZSkKCQkJY29udGludWU7CgkJaWYgKHAtPm5hbWVbbGVuXSAhPSAnLycpCgkJCWNvbnRpbnVlOwoJCWlmIChwLT5jZV9mbGFncyAmIENFX1JFTU9WRSkKCQkJY29udGludWU7CgkJcmV0dmFsID0gLTE7CgkJaWYgKCFva190b19yZXBsYWNlKQoJCQlicmVhazsKCQlyZW1vdmVfaW5kZXhfZW50cnlfYXQoaXN0YXRlLCAtLXBvcyk7Cgl9CglyZXR1cm4gcmV0dmFsOwp9CgovKgogKiBEbyB3ZSBoYXZlIGFub3RoZXIgZmlsZSB3aXRoIGEgcGF0aG5hbWUgdGhhdCBpcyBhIHByb3BlcgogKiBzdWJzZXQgb2YgdGhlIG5hbWUgd2UncmUgdHJ5aW5nIHRvIGFkZD8KICovCnN0YXRpYyBpbnQgaGFzX2Rpcl9uYW1lKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLAoJCQljb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBpbnQgcG9zLCBpbnQgb2tfdG9fcmVwbGFjZSkKewoJaW50IHJldHZhbCA9IDA7CglpbnQgc3RhZ2UgPSBjZV9zdGFnZShjZSk7Cgljb25zdCBjaGFyICpuYW1lID0gY2UtPm5hbWU7Cgljb25zdCBjaGFyICpzbGFzaCA9IG5hbWUgKyBjZV9uYW1lbGVuKGNlKTsKCglmb3IgKDs7KSB7CgkJaW50IGxlbjsKCgkJZm9yICg7OykgewoJCQlpZiAoKi0tc2xhc2ggPT0gJy8nKQoJCQkJYnJlYWs7CgkJCWlmIChzbGFzaCA8PSBjZS0+bmFtZSkKCQkJCXJldHVybiByZXR2YWw7CgkJfQoJCWxlbiA9IHNsYXNoIC0gbmFtZTsKCgkJcG9zID0gaW5kZXhfbmFtZV9zdGFnZV9wb3MoaXN0YXRlLCBuYW1lLCBsZW4sIHN0YWdlKTsKCQlpZiAocG9zID49IDApIHsKCQkJLyoKCQkJICogRm91bmQgb25lLCBidXQgbm90IHNvIGZhc3QuICBUaGlzIGNvdWxkCgkJCSAqIGJlIGEgbWFya2VyIHRoYXQgc2F5cyAiSSB3YXMgaGVyZSwgYnV0CgkJCSAqIEkgYW0gYmVpbmcgcmVtb3ZlZCIuICBTdWNoIGFuIGVudHJ5IGlzCgkJCSAqIG5vdCBhIHBhcnQgb2YgdGhlIHJlc3VsdGluZyB0cmVlLCBhbmQKCQkJICogaXQgaXMgT2sgdG8gaGF2ZSBhIGRpcmVjdG9yeSBhdCB0aGUgc2FtZQoJCQkgKiBwYXRoLgoJCQkgKi8KCQkJaWYgKCEoaXN0YXRlLT5jYWNoZVtwb3NdLT5jZV9mbGFncyAmIENFX1JFTU9WRSkpIHsKCQkJCXJldHZhbCA9IC0xOwoJCQkJaWYgKCFva190b19yZXBsYWNlKQoJCQkJCWJyZWFrOwoJCQkJcmVtb3ZlX2luZGV4X2VudHJ5X2F0KGlzdGF0ZSwgcG9zKTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJfQoJCWVsc2UKCQkJcG9zID0gLXBvcy0xOwoKCQkvKgoJCSAqIFRyaXZpYWwgb3B0aW1pemF0aW9uOiBpZiB3ZSBmaW5kIGFuIGVudHJ5IHRoYXQKCQkgKiBhbHJlYWR5IG1hdGNoZXMgdGhlIHN1Yi1kaXJlY3RvcnksIHRoZW4gd2Uga25vdwoJCSAqIHdlJ3JlIG9rLCBhbmQgd2UgY2FuIGV4aXQuCgkJICovCgkJd2hpbGUgKHBvcyA8IGlzdGF0ZS0+Y2FjaGVfbnIpIHsKCQkJc3RydWN0IGNhY2hlX2VudHJ5ICpwID0gaXN0YXRlLT5jYWNoZVtwb3NdOwoJCQlpZiAoKGNlX25hbWVsZW4ocCkgPD0gbGVuKSB8fAoJCQkgICAgKHAtPm5hbWVbbGVuXSAhPSAnLycpIHx8CgkJCSAgICBtZW1jbXAocC0+bmFtZSwgbmFtZSwgbGVuKSkKCQkJCWJyZWFrOyAvKiBub3Qgb3VyIHN1YmRpcmVjdG9yeSAqLwoJCQlpZiAoY2Vfc3RhZ2UocCkgPT0gc3RhZ2UgJiYgIShwLT5jZV9mbGFncyAmIENFX1JFTU9WRSkpCgkJCQkvKgoJCQkJICogcCBpcyBhdCB0aGUgc2FtZSBzdGFnZSBhcyBvdXIgZW50cnksIGFuZAoJCQkJICogaXMgYSBzdWJkaXJlY3Rvcnkgb2Ygd2hhdCB3ZSBhcmUgbG9va2luZwoJCQkJICogYXQsIHNvIHdlIGNhbm5vdCBoYXZlIGNvbmZsaWN0cyBhdCBvdXIKCQkJCSAqIGxldmVsIG9yIGFueXRoaW5nIHNob3J0ZXIuCgkJCQkgKi8KCQkJCXJldHVybiByZXR2YWw7CgkJCXBvcysrOwoJCX0KCX0KCXJldHVybiByZXR2YWw7Cn0KCi8qIFdlIG1heSBiZSBpbiBhIHNpdHVhdGlvbiB3aGVyZSB3ZSBhbHJlYWR5IGhhdmUgcGF0aC9maWxlIGFuZCBwYXRoCiAqIGlzIGJlaW5nIGFkZGVkLCBvciB3ZSBhbHJlYWR5IGhhdmUgcGF0aCBhbmQgcGF0aC9maWxlIGlzIGJlaW5nCiAqIGFkZGVkLiAgRWl0aGVyIG9uZSB3b3VsZCByZXN1bHQgaW4gYSBub25zZW5zZSB0cmVlIHRoYXQgaGFzIHBhdGgKICogdHdpY2Ugd2hlbiBnaXQtd3JpdGUtdHJlZSB0cmllcyB0byB3cml0ZSBpdCBvdXQuICBQcmV2ZW50IGl0LgogKgogKiBJZiBvay10by1yZXBsYWNlIGlzIHNwZWNpZmllZCwgd2UgcmVtb3ZlIHRoZSBjb25mbGljdGluZyBlbnRyaWVzCiAqIGZyb20gdGhlIGNhY2hlIHNvIHRoZSBjYWxsZXIgc2hvdWxkIHJlY29tcHV0ZSB0aGUgaW5zZXJ0IHBvc2l0aW9uLgogKiBXaGVuIHRoaXMgaGFwcGVucywgd2UgcmV0dXJuIG5vbi16ZXJvLgogKi8Kc3RhdGljIGludCBjaGVja19maWxlX2RpcmVjdG9yeV9jb25mbGljdChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwKCQkJCQkgY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwKCQkJCQkgaW50IHBvcywgaW50IG9rX3RvX3JlcGxhY2UpCnsKCWludCByZXR2YWw7CgoJLyoKCSAqIFdoZW4gY2UgaXMgYW4gIkkgYW0gZ29pbmcgYXdheSIgZW50cnksIHdlIGFsbG93IGl0IHRvIGJlIGFkZGVkCgkgKi8KCWlmIChjZS0+Y2VfZmxhZ3MgJiBDRV9SRU1PVkUpCgkJcmV0dXJuIDA7CgoJLyoKCSAqIFdlIGNoZWNrIGlmIHRoZSBwYXRoIGlzIGEgc3ViLXBhdGggb2YgYSBzdWJzZXF1ZW50IHBhdGhuYW1lCgkgKiBmaXJzdCwgc2luY2UgcmVtb3ZpbmcgdGhvc2Ugd2lsbCBub3QgY2hhbmdlIHRoZSBwb3NpdGlvbgoJICogaW4gdGhlIGFycmF5LgoJICovCglyZXR2YWwgPSBoYXNfZmlsZV9uYW1lKGlzdGF0ZSwgY2UsIHBvcywgb2tfdG9fcmVwbGFjZSk7CgoJLyoKCSAqIFRoZW4gY2hlY2sgaWYgdGhlIHBhdGggbWlnaHQgaGF2ZSBhIGNsYXNoaW5nIHN1Yi1kaXJlY3RvcnkKCSAqIGJlZm9yZSBpdC4KCSAqLwoJcmV0dXJuIHJldHZhbCArIGhhc19kaXJfbmFtZShpc3RhdGUsIGNlLCBwb3MsIG9rX3RvX3JlcGxhY2UpOwp9CgpzdGF0aWMgaW50IGFkZF9pbmRleF9lbnRyeV93aXRoX2NoZWNrKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBpbnQgb3B0aW9uKQp7CglpbnQgcG9zOwoJaW50IG9rX3RvX2FkZCA9IG9wdGlvbiAmIEFERF9DQUNIRV9PS19UT19BREQ7CglpbnQgb2tfdG9fcmVwbGFjZSA9IG9wdGlvbiAmIEFERF9DQUNIRV9PS19UT19SRVBMQUNFOwoJaW50IHNraXBfZGZfY2hlY2sgPSBvcHRpb24gJiBBRERfQ0FDSEVfU0tJUF9ERkNIRUNLOwoJaW50IG5ld19vbmx5ID0gb3B0aW9uICYgQUREX0NBQ0hFX05FV19PTkxZOwoKCWlmICghKG9wdGlvbiAmIEFERF9DQUNIRV9LRUVQX0NBQ0hFX1RSRUUpKQoJCWNhY2hlX3RyZWVfaW52YWxpZGF0ZV9wYXRoKGlzdGF0ZSwgY2UtPm5hbWUpOwoJcG9zID0gaW5kZXhfbmFtZV9zdGFnZV9wb3MoaXN0YXRlLCBjZS0+bmFtZSwgY2VfbmFtZWxlbihjZSksIGNlX3N0YWdlKGNlKSk7CgoJLyogZXhpc3RpbmcgbWF0Y2g/IEp1c3QgcmVwbGFjZSBpdC4gKi8KCWlmIChwb3MgPj0gMCkgewoJCWlmICghbmV3X29ubHkpCgkJCXJlcGxhY2VfaW5kZXhfZW50cnkoaXN0YXRlLCBwb3MsIGNlKTsKCQlyZXR1cm4gMDsKCX0KCXBvcyA9IC1wb3MtMTsKCgkvKgoJICogSW5zZXJ0aW5nIGEgbWVyZ2VkIGVudHJ5ICgic3RhZ2UgMCIpIGludG8gdGhlIGluZGV4CgkgKiB3aWxsIGFsd2F5cyByZXBsYWNlIGFsbCBub24tbWVyZ2VkIGVudHJpZXMuLgoJICovCglpZiAocG9zIDwgaXN0YXRlLT5jYWNoZV9uciAmJiBjZV9zdGFnZShjZSkgPT0gMCkgewoJCXdoaWxlIChjZV9zYW1lX25hbWUoaXN0YXRlLT5jYWNoZVtwb3NdLCBjZSkpIHsKCQkJb2tfdG9fYWRkID0gMTsKCQkJaWYgKCFyZW1vdmVfaW5kZXhfZW50cnlfYXQoaXN0YXRlLCBwb3MpKQoJCQkJYnJlYWs7CgkJfQoJfQoKCWlmICghb2tfdG9fYWRkKQoJCXJldHVybiAtMTsKCWlmICghdmVyaWZ5X3BhdGgoY2UtPm5hbWUpKQoJCXJldHVybiBlcnJvcigiSW52YWxpZCBwYXRoICclcyciLCBjZS0+bmFtZSk7CgoJaWYgKCFza2lwX2RmX2NoZWNrICYmCgkgICAgY2hlY2tfZmlsZV9kaXJlY3RvcnlfY29uZmxpY3QoaXN0YXRlLCBjZSwgcG9zLCBva190b19yZXBsYWNlKSkgewoJCWlmICghb2tfdG9fcmVwbGFjZSkKCQkJcmV0dXJuIGVycm9yKCInJXMnIGFwcGVhcnMgYXMgYm90aCBhIGZpbGUgYW5kIGFzIGEgZGlyZWN0b3J5IiwKCQkJCSAgICAgY2UtPm5hbWUpOwoJCXBvcyA9IGluZGV4X25hbWVfc3RhZ2VfcG9zKGlzdGF0ZSwgY2UtPm5hbWUsIGNlX25hbWVsZW4oY2UpLCBjZV9zdGFnZShjZSkpOwoJCXBvcyA9IC1wb3MtMTsKCX0KCXJldHVybiBwb3MgKyAxOwp9CgppbnQgYWRkX2luZGV4X2VudHJ5KHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBpbnQgb3B0aW9uKQp7CglpbnQgcG9zOwoKCWlmIChvcHRpb24gJiBBRERfQ0FDSEVfSlVTVF9BUFBFTkQpCgkJcG9zID0gaXN0YXRlLT5jYWNoZV9ucjsKCWVsc2UgewoJCWludCByZXQ7CgkJcmV0ID0gYWRkX2luZGV4X2VudHJ5X3dpdGhfY2hlY2soaXN0YXRlLCBjZSwgb3B0aW9uKTsKCQlpZiAocmV0IDw9IDApCgkJCXJldHVybiByZXQ7CgkJcG9zID0gcmV0IC0gMTsKCX0KCgkvKiBNYWtlIHN1cmUgdGhlIGFycmF5IGlzIGJpZyBlbm91Z2ggLi4gKi8KCUFMTE9DX0dST1coaXN0YXRlLT5jYWNoZSwgaXN0YXRlLT5jYWNoZV9uciArIDEsIGlzdGF0ZS0+Y2FjaGVfYWxsb2MpOwoKCS8qIEFkZCBpdCBpbi4uICovCglpc3RhdGUtPmNhY2hlX25yKys7CglpZiAoaXN0YXRlLT5jYWNoZV9uciA+IHBvcyArIDEpCgkJbWVtbW92ZShpc3RhdGUtPmNhY2hlICsgcG9zICsgMSwKCQkJaXN0YXRlLT5jYWNoZSArIHBvcywKCQkJKGlzdGF0ZS0+Y2FjaGVfbnIgLSBwb3MgLSAxKSAqIHNpemVvZihjZSkpOwoJc2V0X2luZGV4X2VudHJ5KGlzdGF0ZSwgcG9zLCBjZSk7Cglpc3RhdGUtPmNhY2hlX2NoYW5nZWQgfD0gQ0VfRU5UUllfQURERUQ7CglyZXR1cm4gMDsKfQoKLyoKICogInJlZnJlc2giIGRvZXMgbm90IGNhbGN1bGF0ZSBhIG5ldyBzaGExIGZpbGUgb3IgYnJpbmcgdGhlCiAqIGNhY2hlIHVwLXRvLWRhdGUgZm9yIG1vZGUvY29udGVudCBjaGFuZ2VzLiBCdXQgd2hhdCBpdAogKiBfZG9lc18gZG8gaXMgdG8gInJlLW1hdGNoIiB0aGUgc3RhdCBpbmZvcm1hdGlvbiBvZiBhIGZpbGUKICogd2l0aCB0aGUgY2FjaGUsIHNvIHRoYXQgeW91IGNhbiByZWZyZXNoIHRoZSBjYWNoZSBmb3IgYQogKiBmaWxlIHRoYXQgaGFzbid0IGJlZW4gY2hhbmdlZCBidXQgd2hlcmUgdGhlIHN0YXQgZW50cnkgaXMKICogb3V0IG9mIGRhdGUuCiAqCiAqIEZvciBleGFtcGxlLCB5b3UnZCB3YW50IHRvIGRvIHRoaXMgYWZ0ZXIgZG9pbmcgYSAiZ2l0LXJlYWQtdHJlZSIsCiAqIHRvIGxpbmsgdXAgdGhlIHN0YXQgY2FjaGUgZGV0YWlscyB3aXRoIHRoZSBwcm9wZXIgZmlsZXMuCiAqLwpzdGF0aWMgc3RydWN0IGNhY2hlX2VudHJ5ICpyZWZyZXNoX2NhY2hlX2VudChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwKCQkJCQkgICAgIHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCQkJICAgICB1bnNpZ25lZCBpbnQgb3B0aW9ucywgaW50ICplcnIsCgkJCQkJICAgICBpbnQgKmNoYW5nZWRfcmV0KQp7CglzdHJ1Y3Qgc3RhdCBzdDsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqdXBkYXRlZDsKCWludCBjaGFuZ2VkLCBzaXplOwoJaW50IHJlZnJlc2ggPSBvcHRpb25zICYgQ0VfTUFUQ0hfUkVGUkVTSDsKCWludCBpZ25vcmVfdmFsaWQgPSBvcHRpb25zICYgQ0VfTUFUQ0hfSUdOT1JFX1ZBTElEOwoJaW50IGlnbm9yZV9za2lwX3dvcmt0cmVlID0gb3B0aW9ucyAmIENFX01BVENIX0lHTk9SRV9TS0lQX1dPUktUUkVFOwoJaW50IGlnbm9yZV9taXNzaW5nID0gb3B0aW9ucyAmIENFX01BVENIX0lHTk9SRV9NSVNTSU5HOwoKCWlmICghcmVmcmVzaCB8fCBjZV91cHRvZGF0ZShjZSkpCgkJcmV0dXJuIGNlOwoKCS8qCgkgKiBDRV9WQUxJRCBvciBDRV9TS0lQX1dPUktUUkVFIG1lYW5zIHRoZSB1c2VyIHByb21pc2VkIHVzCgkgKiB0aGF0IHRoZSBjaGFuZ2UgdG8gdGhlIHdvcmsgdHJlZSBkb2VzIG5vdCBtYXR0ZXIgYW5kIHRvbGQKCSAqIHVzIG5vdCB0byB3b3JyeS4KCSAqLwoJaWYgKCFpZ25vcmVfc2tpcF93b3JrdHJlZSAmJiBjZV9za2lwX3dvcmt0cmVlKGNlKSkgewoJCWNlX21hcmtfdXB0b2RhdGUoY2UpOwoJCXJldHVybiBjZTsKCX0KCWlmICghaWdub3JlX3ZhbGlkICYmIChjZS0+Y2VfZmxhZ3MgJiBDRV9WQUxJRCkpIHsKCQljZV9tYXJrX3VwdG9kYXRlKGNlKTsKCQlyZXR1cm4gY2U7Cgl9CgoJaWYgKGhhc19zeW1saW5rX2xlYWRpbmdfcGF0aChjZS0+bmFtZSwgY2VfbmFtZWxlbihjZSkpKSB7CgkJaWYgKGlnbm9yZV9taXNzaW5nKQoJCQlyZXR1cm4gY2U7CgkJaWYgKGVycikKCQkJKmVyciA9IEVOT0VOVDsKCQlyZXR1cm4gTlVMTDsKCX0KCglpZiAobHN0YXQoY2UtPm5hbWUsICZzdCkgPCAwKSB7CgkJaWYgKGlnbm9yZV9taXNzaW5nICYmIGVycm5vID09IEVOT0VOVCkKCQkJcmV0dXJuIGNlOwoJCWlmIChlcnIpCgkJCSplcnIgPSBlcnJubzsKCQlyZXR1cm4gTlVMTDsKCX0KCgljaGFuZ2VkID0gaWVfbWF0Y2hfc3RhdChpc3RhdGUsIGNlLCAmc3QsIG9wdGlvbnMpOwoJaWYgKGNoYW5nZWRfcmV0KQoJCSpjaGFuZ2VkX3JldCA9IGNoYW5nZWQ7CglpZiAoIWNoYW5nZWQpIHsKCQkvKgoJCSAqIFRoZSBwYXRoIGlzIHVuY2hhbmdlZC4gIElmIHdlIHdlcmUgdG9sZCB0byBpZ25vcmUKCQkgKiB2YWxpZCBiaXQsIHRoZW4gd2UgZGlkIHRoZSBhY3R1YWwgc3RhdCBjaGVjayBhbmQKCQkgKiBmb3VuZCB0aGF0IHRoZSBlbnRyeSBpcyB1bm1vZGlmaWVkLiAgSWYgdGhlIGVudHJ5CgkJICogaXMgbm90IG1hcmtlZCBWQUxJRCwgdGhpcyBpcyB0aGUgcGxhY2UgdG8gbWFyayBpdAoJCSAqIHZhbGlkIGFnYWluLCB1bmRlciAiYXNzdW1lIHVuY2hhbmdlZCIgbW9kZS4KCQkgKi8KCQlpZiAoaWdub3JlX3ZhbGlkICYmIGFzc3VtZV91bmNoYW5nZWQgJiYKCQkgICAgIShjZS0+Y2VfZmxhZ3MgJiBDRV9WQUxJRCkpCgkJCTsgLyogbWFyayB0aGlzIG9uZSBWQUxJRCBhZ2FpbiAqLwoJCWVsc2UgewoJCQkvKgoJCQkgKiBXZSBkbyBub3QgbWFyayB0aGUgaW5kZXggaXRzZWxmICJtb2RpZmllZCIKCQkJICogYmVjYXVzZSBDRV9VUFRPREFURSBmbGFnIGlzIGluLWNvcmUgb25seTsKCQkJICogd2UgYXJlIG5vdCBnb2luZyB0byB3cml0ZSB0aGlzIGNoYW5nZSBvdXQuCgkJCSAqLwoJCQlpZiAoIVNfSVNHSVRMSU5LKGNlLT5jZV9tb2RlKSkKCQkJCWNlX21hcmtfdXB0b2RhdGUoY2UpOwoJCQlyZXR1cm4gY2U7CgkJfQoJfQoKCWlmIChpZV9tb2RpZmllZChpc3RhdGUsIGNlLCAmc3QsIG9wdGlvbnMpKSB7CgkJaWYgKGVycikKCQkJKmVyciA9IEVJTlZBTDsKCQlyZXR1cm4gTlVMTDsKCX0KCglzaXplID0gY2Vfc2l6ZShjZSk7Cgl1cGRhdGVkID0geG1hbGxvYyhzaXplKTsKCW1lbWNweSh1cGRhdGVkLCBjZSwgc2l6ZSk7CglmaWxsX3N0YXRfY2FjaGVfaW5mbyh1cGRhdGVkLCAmc3QpOwoJLyoKCSAqIElmIGlnbm9yZV92YWxpZCBpcyBub3Qgc2V0LCB3ZSBzaG91bGQgbGVhdmUgQ0VfVkFMSUQgYml0CgkgKiBhbG9uZS4gIE90aGVyd2lzZSwgcGF0aHMgbWFya2VkIHdpdGggLS1uby1hc3N1bWUtdW5jaGFuZ2VkCgkgKiAoaS5lLiB0aGluZ3MgdG8gYmUgZWRpdGVkKSB3aWxsIHJlYWNxdWlyZSBDRV9WQUxJRCBiaXQKCSAqIGF1dG9tYXRpY2FsbHksIHdoaWNoIGlzIG5vdCByZWFsbHkgd2hhdCB3ZSB3YW50LgoJICovCglpZiAoIWlnbm9yZV92YWxpZCAmJiBhc3N1bWVfdW5jaGFuZ2VkICYmCgkgICAgIShjZS0+Y2VfZmxhZ3MgJiBDRV9WQUxJRCkpCgkJdXBkYXRlZC0+Y2VfZmxhZ3MgJj0gfkNFX1ZBTElEOwoKCS8qIGlzdGF0ZS0+Y2FjaGVfY2hhbmdlZCBpcyB1cGRhdGVkIGluIHRoZSBjYWxsZXIgKi8KCXJldHVybiB1cGRhdGVkOwp9CgpzdGF0aWMgdm9pZCBzaG93X2ZpbGUoY29uc3QgY2hhciAqIGZtdCwgY29uc3QgY2hhciAqIG5hbWUsIGludCBpbl9wb3JjZWxhaW4sCgkJICAgICAgaW50ICogZmlyc3QsIGNvbnN0IGNoYXIgKmhlYWRlcl9tc2cpCnsKCWlmIChpbl9wb3JjZWxhaW4gJiYgKmZpcnN0ICYmIGhlYWRlcl9tc2cpIHsKCQlwcmludGYoIiVzXG4iLCBoZWFkZXJfbXNnKTsKCQkqZmlyc3QgPSAwOwoJfQoJcHJpbnRmKGZtdCwgbmFtZSk7Cn0KCmludCByZWZyZXNoX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCB1bnNpZ25lZCBpbnQgZmxhZ3MsCgkJICBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBhdGhzcGVjLAoJCSAgY2hhciAqc2VlbiwgY29uc3QgY2hhciAqaGVhZGVyX21zZykKewoJaW50IGk7CglpbnQgaGFzX2Vycm9ycyA9IDA7CglpbnQgcmVhbGx5ID0gKGZsYWdzICYgUkVGUkVTSF9SRUFMTFkpICE9IDA7CglpbnQgYWxsb3dfdW5tZXJnZWQgPSAoZmxhZ3MgJiBSRUZSRVNIX1VOTUVSR0VEKSAhPSAwOwoJaW50IHF1aWV0ID0gKGZsYWdzICYgUkVGUkVTSF9RVUlFVCkgIT0gMDsKCWludCBub3RfbmV3ID0gKGZsYWdzICYgUkVGUkVTSF9JR05PUkVfTUlTU0lORykgIT0gMDsKCWludCBpZ25vcmVfc3VibW9kdWxlcyA9IChmbGFncyAmIFJFRlJFU0hfSUdOT1JFX1NVQk1PRFVMRVMpICE9IDA7CglpbnQgZmlyc3QgPSAxOwoJaW50IGluX3BvcmNlbGFpbiA9IChmbGFncyAmIFJFRlJFU0hfSU5fUE9SQ0VMQUlOKTsKCXVuc2lnbmVkIGludCBvcHRpb25zID0gKENFX01BVENIX1JFRlJFU0ggfAoJCQkJKHJlYWxseSA/IENFX01BVENIX0lHTk9SRV9WQUxJRCA6IDApIHwKCQkJCShub3RfbmV3ID8gQ0VfTUFUQ0hfSUdOT1JFX01JU1NJTkcgOiAwKSk7Cgljb25zdCBjaGFyICptb2RpZmllZF9mbXQ7Cgljb25zdCBjaGFyICpkZWxldGVkX2ZtdDsKCWNvbnN0IGNoYXIgKnR5cGVjaGFuZ2VfZm10OwoJY29uc3QgY2hhciAqYWRkZWRfZm10OwoJY29uc3QgY2hhciAqdW5tZXJnZWRfZm10OwoKCW1vZGlmaWVkX2ZtdCA9IChpbl9wb3JjZWxhaW4gPyAiTVx0JXNcbiIgOiAiJXM6IG5lZWRzIHVwZGF0ZVxuIik7CglkZWxldGVkX2ZtdCA9IChpbl9wb3JjZWxhaW4gPyAiRFx0JXNcbiIgOiAiJXM6IG5lZWRzIHVwZGF0ZVxuIik7Cgl0eXBlY2hhbmdlX2ZtdCA9IChpbl9wb3JjZWxhaW4gPyAiVFx0JXNcbiIgOiAiJXMgbmVlZHMgdXBkYXRlXG4iKTsKCWFkZGVkX2ZtdCA9IChpbl9wb3JjZWxhaW4gPyAiQVx0JXNcbiIgOiAiJXMgbmVlZHMgdXBkYXRlXG4iKTsKCXVubWVyZ2VkX2ZtdCA9IChpbl9wb3JjZWxhaW4gPyAiVVx0JXNcbiIgOiAiJXM6IG5lZWRzIG1lcmdlXG4iKTsKCWZvciAoaSA9IDA7IGkgPCBpc3RhdGUtPmNhY2hlX25yOyBpKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCAqbmV3OwoJCWludCBjYWNoZV9lcnJubyA9IDA7CgkJaW50IGNoYW5nZWQgPSAwOwoJCWludCBmaWx0ZXJlZCA9IDA7CgoJCWNlID0gaXN0YXRlLT5jYWNoZVtpXTsKCQlpZiAoaWdub3JlX3N1Ym1vZHVsZXMgJiYgU19JU0dJVExJTksoY2UtPmNlX21vZGUpKQoJCQljb250aW51ZTsKCgkJaWYgKHBhdGhzcGVjICYmICFjZV9wYXRoX21hdGNoKGNlLCBwYXRoc3BlYywgc2VlbikpCgkJCWZpbHRlcmVkID0gMTsKCgkJaWYgKGNlX3N0YWdlKGNlKSkgewoJCQl3aGlsZSAoKGkgPCBpc3RhdGUtPmNhY2hlX25yKSAmJgoJCQkgICAgICAgISBzdHJjbXAoaXN0YXRlLT5jYWNoZVtpXS0+bmFtZSwgY2UtPm5hbWUpKQoJCQkJaSsrOwoJCQlpLS07CgkJCWlmIChhbGxvd191bm1lcmdlZCkKCQkJCWNvbnRpbnVlOwoJCQlpZiAoIWZpbHRlcmVkKQoJCQkJc2hvd19maWxlKHVubWVyZ2VkX2ZtdCwgY2UtPm5hbWUsIGluX3BvcmNlbGFpbiwKCQkJCQkgICZmaXJzdCwgaGVhZGVyX21zZyk7CgkJCWhhc19lcnJvcnMgPSAxOwoJCQljb250aW51ZTsKCQl9CgoJCWlmIChmaWx0ZXJlZCkKCQkJY29udGludWU7CgoJCW5ldyA9IHJlZnJlc2hfY2FjaGVfZW50KGlzdGF0ZSwgY2UsIG9wdGlvbnMsICZjYWNoZV9lcnJubywgJmNoYW5nZWQpOwoJCWlmIChuZXcgPT0gY2UpCgkJCWNvbnRpbnVlOwoJCWlmICghbmV3KSB7CgkJCWNvbnN0IGNoYXIgKmZtdDsKCgkJCWlmIChyZWFsbHkgJiYgY2FjaGVfZXJybm8gPT0gRUlOVkFMKSB7CgkJCQkvKiBJZiB3ZSBhcmUgZG9pbmcgLS1yZWFsbHktcmVmcmVzaCB0aGF0CgkJCQkgKiBtZWFucyB0aGUgaW5kZXggaXMgbm90IHZhbGlkIGFueW1vcmUuCgkJCQkgKi8KCQkJCWNlLT5jZV9mbGFncyAmPSB+Q0VfVkFMSUQ7CgkJCQljZS0+Y2VfZmxhZ3MgfD0gQ0VfVVBEQVRFX0lOX0JBU0U7CgkJCQlpc3RhdGUtPmNhY2hlX2NoYW5nZWQgfD0gQ0VfRU5UUllfQ0hBTkdFRDsKCQkJfQoJCQlpZiAocXVpZXQpCgkJCQljb250aW51ZTsKCgkJCWlmIChjYWNoZV9lcnJubyA9PSBFTk9FTlQpCgkJCQlmbXQgPSBkZWxldGVkX2ZtdDsKCQkJZWxzZSBpZiAoY2UtPmNlX2ZsYWdzICYgQ0VfSU5URU5UX1RPX0FERCkKCQkJCWZtdCA9IGFkZGVkX2ZtdDsgLyogbXVzdCBiZSBiZWZvcmUgb3RoZXIgY2hlY2tzICovCgkJCWVsc2UgaWYgKGNoYW5nZWQgJiBUWVBFX0NIQU5HRUQpCgkJCQlmbXQgPSB0eXBlY2hhbmdlX2ZtdDsKCQkJZWxzZQoJCQkJZm10ID0gbW9kaWZpZWRfZm10OwoJCQlzaG93X2ZpbGUoZm10LAoJCQkJICBjZS0+bmFtZSwgaW5fcG9yY2VsYWluLCAmZmlyc3QsIGhlYWRlcl9tc2cpOwoJCQloYXNfZXJyb3JzID0gMTsKCQkJY29udGludWU7CgkJfQoKCQlyZXBsYWNlX2luZGV4X2VudHJ5KGlzdGF0ZSwgaSwgbmV3KTsKCX0KCXJldHVybiBoYXNfZXJyb3JzOwp9CgpzdGF0aWMgc3RydWN0IGNhY2hlX2VudHJ5ICpyZWZyZXNoX2NhY2hlX2VudHJ5KHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCQkJICAgICAgIHVuc2lnbmVkIGludCBvcHRpb25zKQp7CglyZXR1cm4gcmVmcmVzaF9jYWNoZV9lbnQoJnRoZV9pbmRleCwgY2UsIG9wdGlvbnMsIE5VTEwsIE5VTEwpOwp9CgoKLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqCiAqIEluZGV4IEZpbGUgSS9PCiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8KCiNkZWZpbmUgSU5ERVhfRk9STUFUX0RFRkFVTFQgMwoKc3RhdGljIHVuc2lnbmVkIGludCBnZXRfaW5kZXhfZm9ybWF0X2RlZmF1bHQodm9pZCkKewoJY2hhciAqZW52dmVyc2lvbiA9IGdldGVudigiR0lUX0lOREVYX1ZFUlNJT04iKTsKCWNoYXIgKmVuZHA7CglpbnQgdmFsdWU7Cgl1bnNpZ25lZCBpbnQgdmVyc2lvbiA9IElOREVYX0ZPUk1BVF9ERUZBVUxUOwoKCWlmICghZW52dmVyc2lvbikgewoJCWlmICghZ2l0X2NvbmZpZ19nZXRfaW50KCJpbmRleC52ZXJzaW9uIiwgJnZhbHVlKSkKCQkJdmVyc2lvbiA9IHZhbHVlOwoJCWlmICh2ZXJzaW9uIDwgSU5ERVhfRk9STUFUX0xCIHx8IElOREVYX0ZPUk1BVF9VQiA8IHZlcnNpb24pIHsKCQkJd2FybmluZyhfKCJpbmRleC52ZXJzaW9uIHNldCwgYnV0IHRoZSB2YWx1ZSBpcyBpbnZhbGlkLlxuIgoJCQkJICAiVXNpbmcgdmVyc2lvbiAlaSIpLCBJTkRFWF9GT1JNQVRfREVGQVVMVCk7CgkJCXJldHVybiBJTkRFWF9GT1JNQVRfREVGQVVMVDsKCQl9CgkJcmV0dXJuIHZlcnNpb247Cgl9CgoJdmVyc2lvbiA9IHN0cnRvdWwoZW52dmVyc2lvbiwgJmVuZHAsIDEwKTsKCWlmICgqZW5kcCB8fAoJICAgIHZlcnNpb24gPCBJTkRFWF9GT1JNQVRfTEIgfHwgSU5ERVhfRk9STUFUX1VCIDwgdmVyc2lvbikgewoJCXdhcm5pbmcoXygiR0lUX0lOREVYX1ZFUlNJT04gc2V0LCBidXQgdGhlIHZhbHVlIGlzIGludmFsaWQuXG4iCgkJCSAgIlVzaW5nIHZlcnNpb24gJWkiKSwgSU5ERVhfRk9STUFUX0RFRkFVTFQpOwoJCXZlcnNpb24gPSBJTkRFWF9GT1JNQVRfREVGQVVMVDsKCX0KCXJldHVybiB2ZXJzaW9uOwp9CgovKgogKiBkZXYvaW5vL3VpZC9naWQvc2l6ZSBhcmUgYWxzbyBqdXN0IHRyYWNrZWQgdG8gdGhlIGxvdyAzMiBiaXRzCiAqIEFnYWluIC0gdGhpcyBpcyBqdXN0IGEgKHZlcnkgc3Ryb25nIGluIHByYWN0aWNlKSBoZXVyaXN0aWMgdGhhdAogKiB0aGUgaW5vZGUgaGFzbid0IGNoYW5nZWQuCiAqCiAqIFdlIHNhdmUgdGhlIGZpZWxkcyBpbiBiaWctZW5kaWFuIG9yZGVyIHRvIGFsbG93IHVzaW5nIHRoZQogKiBpbmRleCBmaWxlIG92ZXIgTkZTIHRyYW5zcGFyZW50bHkuCiAqLwpzdHJ1Y3Qgb25kaXNrX2NhY2hlX2VudHJ5IHsKCXN0cnVjdCBjYWNoZV90aW1lIGN0aW1lOwoJc3RydWN0IGNhY2hlX3RpbWUgbXRpbWU7Cgl1aW50MzJfdCBkZXY7Cgl1aW50MzJfdCBpbm87Cgl1aW50MzJfdCBtb2RlOwoJdWludDMyX3QgdWlkOwoJdWludDMyX3QgZ2lkOwoJdWludDMyX3Qgc2l6ZTsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07Cgl1aW50MTZfdCBmbGFnczsKCWNoYXIgbmFtZVtGTEVYX0FSUkFZXTsgLyogbW9yZSAqLwp9OwoKLyoKICogVGhpcyBzdHJ1Y3QgaXMgdXNlZCB3aGVuIENFX0VYVEVOREVEIGJpdCBpcyAxCiAqIFRoZSBzdHJ1Y3QgbXVzdCBtYXRjaCBvbmRpc2tfY2FjaGVfZW50cnkgZXhhY3RseSBmcm9tCiAqIGN0aW1lIHRpbGwgZmxhZ3MKICovCnN0cnVjdCBvbmRpc2tfY2FjaGVfZW50cnlfZXh0ZW5kZWQgewoJc3RydWN0IGNhY2hlX3RpbWUgY3RpbWU7CglzdHJ1Y3QgY2FjaGVfdGltZSBtdGltZTsKCXVpbnQzMl90IGRldjsKCXVpbnQzMl90IGlubzsKCXVpbnQzMl90IG1vZGU7Cgl1aW50MzJfdCB1aWQ7Cgl1aW50MzJfdCBnaWQ7Cgl1aW50MzJfdCBzaXplOwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCXVpbnQxNl90IGZsYWdzOwoJdWludDE2X3QgZmxhZ3MyOwoJY2hhciBuYW1lW0ZMRVhfQVJSQVldOyAvKiBtb3JlICovCn07CgovKiBUaGVzZSBhcmUgb25seSB1c2VkIGZvciB2MyBvciBsb3dlciAqLwojZGVmaW5lIGFsaWduX2ZsZXhfbmFtZShTVFJVQ1QsbGVuKSAoKG9mZnNldG9mKHN0cnVjdCBTVFJVQ1QsbmFtZSkgKyAobGVuKSArIDgpICYgfjcpCiNkZWZpbmUgb25kaXNrX2NhY2hlX2VudHJ5X3NpemUobGVuKSBhbGlnbl9mbGV4X25hbWUob25kaXNrX2NhY2hlX2VudHJ5LGxlbikKI2RlZmluZSBvbmRpc2tfY2FjaGVfZW50cnlfZXh0ZW5kZWRfc2l6ZShsZW4pIGFsaWduX2ZsZXhfbmFtZShvbmRpc2tfY2FjaGVfZW50cnlfZXh0ZW5kZWQsbGVuKQojZGVmaW5lIG9uZGlza19jZV9zaXplKGNlKSAoKChjZSktPmNlX2ZsYWdzICYgQ0VfRVhURU5ERUQpID8gXAoJCQkgICAgb25kaXNrX2NhY2hlX2VudHJ5X2V4dGVuZGVkX3NpemUoY2VfbmFtZWxlbihjZSkpIDogXAoJCQkgICAgb25kaXNrX2NhY2hlX2VudHJ5X3NpemUoY2VfbmFtZWxlbihjZSkpKQoKc3RhdGljIGludCB2ZXJpZnlfaGRyKHN0cnVjdCBjYWNoZV9oZWFkZXIgKmhkciwgdW5zaWduZWQgbG9uZyBzaXplKQp7CglnaXRfU0hBX0NUWCBjOwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCWludCBoZHJfdmVyc2lvbjsKCglpZiAoaGRyLT5oZHJfc2lnbmF0dXJlICE9IGh0b25sKENBQ0hFX1NJR05BVFVSRSkpCgkJcmV0dXJuIGVycm9yKCJiYWQgc2lnbmF0dXJlIik7CgloZHJfdmVyc2lvbiA9IG50b2hsKGhkci0+aGRyX3ZlcnNpb24pOwoJaWYgKGhkcl92ZXJzaW9uIDwgSU5ERVhfRk9STUFUX0xCIHx8IElOREVYX0ZPUk1BVF9VQiA8IGhkcl92ZXJzaW9uKQoJCXJldHVybiBlcnJvcigiYmFkIGluZGV4IHZlcnNpb24gJWQiLCBoZHJfdmVyc2lvbik7CglnaXRfU0hBMV9Jbml0KCZjKTsKCWdpdF9TSEExX1VwZGF0ZSgmYywgaGRyLCBzaXplIC0gMjApOwoJZ2l0X1NIQTFfRmluYWwoc2hhMSwgJmMpOwoJaWYgKGhhc2hjbXAoc2hhMSwgKHVuc2lnbmVkIGNoYXIgKiloZHIgKyBzaXplIC0gMjApKQoJCXJldHVybiBlcnJvcigiYmFkIGluZGV4IGZpbGUgc2hhMSBzaWduYXR1cmUiKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHJlYWRfaW5kZXhfZXh0ZW5zaW9uKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLAoJCQkJY29uc3QgY2hhciAqZXh0LCB2b2lkICpkYXRhLCB1bnNpZ25lZCBsb25nIHN6KQp7Cglzd2l0Y2ggKENBQ0hFX0VYVChleHQpKSB7CgljYXNlIENBQ0hFX0VYVF9UUkVFOgoJCWlzdGF0ZS0+Y2FjaGVfdHJlZSA9IGNhY2hlX3RyZWVfcmVhZChkYXRhLCBzeik7CgkJYnJlYWs7CgljYXNlIENBQ0hFX0VYVF9SRVNPTFZFX1VORE86CgkJaXN0YXRlLT5yZXNvbHZlX3VuZG8gPSByZXNvbHZlX3VuZG9fcmVhZChkYXRhLCBzeik7CgkJYnJlYWs7CgljYXNlIENBQ0hFX0VYVF9MSU5LOgoJCWlmIChyZWFkX2xpbmtfZXh0ZW5zaW9uKGlzdGF0ZSwgZGF0YSwgc3opKQoJCQlyZXR1cm4gLTE7CgkJYnJlYWs7CglkZWZhdWx0OgoJCWlmICgqZXh0IDwgJ0EnIHx8ICdaJyA8ICpleHQpCgkJCXJldHVybiBlcnJvcigiaW5kZXggdXNlcyAlLjRzIGV4dGVuc2lvbiwgd2hpY2ggd2UgZG8gbm90IHVuZGVyc3RhbmQiLAoJCQkJICAgICBleHQpOwoJCWZwcmludGYoc3RkZXJyLCAiaWdub3JpbmcgJS40cyBleHRlbnNpb25cbiIsIGV4dCk7CgkJYnJlYWs7Cgl9CglyZXR1cm4gMDsKfQoKaW50IGhvbGRfbG9ja2VkX2luZGV4KHN0cnVjdCBsb2NrX2ZpbGUgKmxrLCBpbnQgZGllX29uX2Vycm9yKQp7CglyZXR1cm4gaG9sZF9sb2NrX2ZpbGVfZm9yX3VwZGF0ZShsaywgZ2V0X2luZGV4X2ZpbGUoKSwKCQkJCQkgZGllX29uX2Vycm9yCgkJCQkJID8gTE9DS19ESUVfT05fRVJST1IKCQkJCQkgOiAwKTsKfQoKaW50IHJlYWRfaW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUpCnsKCXJldHVybiByZWFkX2luZGV4X2Zyb20oaXN0YXRlLCBnZXRfaW5kZXhfZmlsZSgpKTsKfQoKc3RhdGljIHN0cnVjdCBjYWNoZV9lbnRyeSAqY2FjaGVfZW50cnlfZnJvbV9vbmRpc2soc3RydWN0IG9uZGlza19jYWNoZV9lbnRyeSAqb25kaXNrLAoJCQkJCQkgICB1bnNpZ25lZCBpbnQgZmxhZ3MsCgkJCQkJCSAgIGNvbnN0IGNoYXIgKm5hbWUsCgkJCQkJCSAgIHNpemVfdCBsZW4pCnsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSB4bWFsbG9jKGNhY2hlX2VudHJ5X3NpemUobGVuKSk7CgoJY2UtPmNlX3N0YXRfZGF0YS5zZF9jdGltZS5zZWMgPSBnZXRfYmUzMigmb25kaXNrLT5jdGltZS5zZWMpOwoJY2UtPmNlX3N0YXRfZGF0YS5zZF9tdGltZS5zZWMgPSBnZXRfYmUzMigmb25kaXNrLT5tdGltZS5zZWMpOwoJY2UtPmNlX3N0YXRfZGF0YS5zZF9jdGltZS5uc2VjID0gZ2V0X2JlMzIoJm9uZGlzay0+Y3RpbWUubnNlYyk7CgljZS0+Y2Vfc3RhdF9kYXRhLnNkX210aW1lLm5zZWMgPSBnZXRfYmUzMigmb25kaXNrLT5tdGltZS5uc2VjKTsKCWNlLT5jZV9zdGF0X2RhdGEuc2RfZGV2ICAgPSBnZXRfYmUzMigmb25kaXNrLT5kZXYpOwoJY2UtPmNlX3N0YXRfZGF0YS5zZF9pbm8gICA9IGdldF9iZTMyKCZvbmRpc2stPmlubyk7CgljZS0+Y2VfbW9kZSAgPSBnZXRfYmUzMigmb25kaXNrLT5tb2RlKTsKCWNlLT5jZV9zdGF0X2RhdGEuc2RfdWlkICAgPSBnZXRfYmUzMigmb25kaXNrLT51aWQpOwoJY2UtPmNlX3N0YXRfZGF0YS5zZF9naWQgICA9IGdldF9iZTMyKCZvbmRpc2stPmdpZCk7CgljZS0+Y2Vfc3RhdF9kYXRhLnNkX3NpemUgID0gZ2V0X2JlMzIoJm9uZGlzay0+c2l6ZSk7CgljZS0+Y2VfZmxhZ3MgPSBmbGFncyAmIH5DRV9OQU1FTUFTSzsKCWNlLT5jZV9uYW1lbGVuID0gbGVuOwoJY2UtPmluZGV4ID0gMDsKCWhhc2hjcHkoY2UtPnNoYTEsIG9uZGlzay0+c2hhMSk7CgltZW1jcHkoY2UtPm5hbWUsIG5hbWUsIGxlbik7CgljZS0+bmFtZVtsZW5dID0gJ1wwJzsKCXJldHVybiBjZTsKfQoKLyoKICogQWRqYWNlbnQgY2FjaGUgZW50cmllcyB0ZW5kIHRvIHNoYXJlIHRoZSBsZWFkaW5nIHBhdGhzLCBzbyBpdCBtYWtlcwogKiBzZW5zZSB0byBvbmx5IHN0b3JlIHRoZSBkaWZmZXJlbmNlcyBpbiBsYXRlciBlbnRyaWVzLiAgSW4gdGhlIHY0CiAqIG9uLWRpc2sgZm9ybWF0IG9mIHRoZSBpbmRleCwgZWFjaCBvbi1kaXNrIGNhY2hlIGVudHJ5IHN0b3JlcyB0aGUKICogbnVtYmVyIG9mIGJ5dGVzIHRvIGJlIHN0cmlwcGVkIGZyb20gdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgbmFtZSwKICogYW5kIHRoZSBieXRlcyB0byBhcHBlbmQgdG8gdGhlIHJlc3VsdCwgdG8gY29tZSB1cCB3aXRoIGl0cyBuYW1lLgogKi8Kc3RhdGljIHVuc2lnbmVkIGxvbmcgZXhwYW5kX25hbWVfZmllbGQoc3RydWN0IHN0cmJ1ZiAqbmFtZSwgY29uc3QgY2hhciAqY3BfKQp7Cgljb25zdCB1bnNpZ25lZCBjaGFyICplcCwgKmNwID0gKGNvbnN0IHVuc2lnbmVkIGNoYXIgKiljcF87CglzaXplX3QgbGVuID0gZGVjb2RlX3ZhcmludCgmY3ApOwoKCWlmIChuYW1lLT5sZW4gPCBsZW4pCgkJZGllKCJtYWxmb3JtZWQgbmFtZSBmaWVsZCBpbiB0aGUgaW5kZXgiKTsKCXN0cmJ1Zl9yZW1vdmUobmFtZSwgbmFtZS0+bGVuIC0gbGVuLCBsZW4pOwoJZm9yIChlcCA9IGNwOyAqZXA7IGVwKyspCgkJOyAvKiBmaW5kIHRoZSBlbmQgKi8KCXN0cmJ1Zl9hZGQobmFtZSwgY3AsIGVwIC0gY3ApOwoJcmV0dXJuIChjb25zdCBjaGFyICopZXAgKyAxIC0gY3BfOwp9CgpzdGF0aWMgc3RydWN0IGNhY2hlX2VudHJ5ICpjcmVhdGVfZnJvbV9kaXNrKHN0cnVjdCBvbmRpc2tfY2FjaGVfZW50cnkgKm9uZGlzaywKCQkJCQkgICAgdW5zaWduZWQgbG9uZyAqZW50X3NpemUsCgkJCQkJICAgIHN0cnVjdCBzdHJidWYgKnByZXZpb3VzX25hbWUpCnsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2U7CglzaXplX3QgbGVuOwoJY29uc3QgY2hhciAqbmFtZTsKCXVuc2lnbmVkIGludCBmbGFnczsKCgkvKiBPbi1kaXNrIGZsYWdzIGFyZSBqdXN0IDE2IGJpdHMgKi8KCWZsYWdzID0gZ2V0X2JlMTYoJm9uZGlzay0+ZmxhZ3MpOwoJbGVuID0gZmxhZ3MgJiBDRV9OQU1FTUFTSzsKCglpZiAoZmxhZ3MgJiBDRV9FWFRFTkRFRCkgewoJCXN0cnVjdCBvbmRpc2tfY2FjaGVfZW50cnlfZXh0ZW5kZWQgKm9uZGlzazI7CgkJaW50IGV4dGVuZGVkX2ZsYWdzOwoJCW9uZGlzazIgPSAoc3RydWN0IG9uZGlza19jYWNoZV9lbnRyeV9leHRlbmRlZCAqKW9uZGlzazsKCQlleHRlbmRlZF9mbGFncyA9IGdldF9iZTE2KCZvbmRpc2syLT5mbGFnczIpIDw8IDE2OwoJCS8qIFdlIGRvIG5vdCB5ZXQgdW5kZXJzdGFuZCBhbnkgYml0IG91dCBvZiBDRV9FWFRFTkRFRF9GTEFHUyAqLwoJCWlmIChleHRlbmRlZF9mbGFncyAmIH5DRV9FWFRFTkRFRF9GTEFHUykKCQkJZGllKCJVbmtub3duIGluZGV4IGVudHJ5IGZvcm1hdCAlMDh4IiwgZXh0ZW5kZWRfZmxhZ3MpOwoJCWZsYWdzIHw9IGV4dGVuZGVkX2ZsYWdzOwoJCW5hbWUgPSBvbmRpc2syLT5uYW1lOwoJfQoJZWxzZQoJCW5hbWUgPSBvbmRpc2stPm5hbWU7CgoJaWYgKCFwcmV2aW91c19uYW1lKSB7CgkJLyogdjMgYW5kIGVhcmxpZXIgKi8KCQlpZiAobGVuID09IENFX05BTUVNQVNLKQoJCQlsZW4gPSBzdHJsZW4obmFtZSk7CgkJY2UgPSBjYWNoZV9lbnRyeV9mcm9tX29uZGlzayhvbmRpc2ssIGZsYWdzLCBuYW1lLCBsZW4pOwoKCQkqZW50X3NpemUgPSBvbmRpc2tfY2Vfc2l6ZShjZSk7Cgl9IGVsc2UgewoJCXVuc2lnbmVkIGxvbmcgY29uc3VtZWQ7CgkJY29uc3VtZWQgPSBleHBhbmRfbmFtZV9maWVsZChwcmV2aW91c19uYW1lLCBuYW1lKTsKCQljZSA9IGNhY2hlX2VudHJ5X2Zyb21fb25kaXNrKG9uZGlzaywgZmxhZ3MsCgkJCQkJICAgICBwcmV2aW91c19uYW1lLT5idWYsCgkJCQkJICAgICBwcmV2aW91c19uYW1lLT5sZW4pOwoKCQkqZW50X3NpemUgPSAobmFtZSAtICgoY2hhciAqKW9uZGlzaykpICsgY29uc3VtZWQ7Cgl9CglyZXR1cm4gY2U7Cn0KCnN0YXRpYyB2b2lkIGNoZWNrX2NlX29yZGVyKHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIHN0cnVjdCBjYWNoZV9lbnRyeSAqbmV4dF9jZSkKewoJaW50IG5hbWVfY29tcGFyZSA9IHN0cmNtcChjZS0+bmFtZSwgbmV4dF9jZS0+bmFtZSk7CglpZiAoMCA8IG5hbWVfY29tcGFyZSkKCQlkaWUoInVub3JkZXJlZCBzdGFnZSBlbnRyaWVzIGluIGluZGV4Iik7CglpZiAoIW5hbWVfY29tcGFyZSkgewoJCWlmICghY2Vfc3RhZ2UoY2UpKQoJCQlkaWUoIm11bHRpcGxlIHN0YWdlIGVudHJpZXMgZm9yIG1lcmdlZCBmaWxlICclcyciLAoJCQkJY2UtPm5hbWUpOwoJCWlmIChjZV9zdGFnZShjZSkgPiBjZV9zdGFnZShuZXh0X2NlKSkKCQkJZGllKCJ1bm9yZGVyZWQgc3RhZ2UgZW50cmllcyBmb3IgJyVzJyIsCgkJCQljZS0+bmFtZSk7Cgl9Cn0KCi8qIHJlbWVtYmVyIHRvIGRpc2NhcmRfY2FjaGUoKSBiZWZvcmUgcmVhZGluZyBhIGRpZmZlcmVudCBjYWNoZSEgKi8KaW50IGRvX3JlYWRfaW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIGNvbnN0IGNoYXIgKnBhdGgsIGludCBtdXN0X2V4aXN0KQp7CglpbnQgZmQsIGk7CglzdHJ1Y3Qgc3RhdCBzdDsKCXVuc2lnbmVkIGxvbmcgc3JjX29mZnNldDsKCXN0cnVjdCBjYWNoZV9oZWFkZXIgKmhkcjsKCXZvaWQgKm1tYXA7CglzaXplX3QgbW1hcF9zaXplOwoJc3RydWN0IHN0cmJ1ZiBwcmV2aW91c19uYW1lX2J1ZiA9IFNUUkJVRl9JTklULCAqcHJldmlvdXNfbmFtZTsKCglpZiAoaXN0YXRlLT5pbml0aWFsaXplZCkKCQlyZXR1cm4gaXN0YXRlLT5jYWNoZV9ucjsKCglpc3RhdGUtPnRpbWVzdGFtcC5zZWMgPSAwOwoJaXN0YXRlLT50aW1lc3RhbXAubnNlYyA9IDA7CglmZCA9IG9wZW4ocGF0aCwgT19SRE9OTFkpOwoJaWYgKGZkIDwgMCkgewoJCWlmICghbXVzdF9leGlzdCAmJiBlcnJubyA9PSBFTk9FTlQpCgkJCXJldHVybiAwOwoJCWRpZV9lcnJubygiJXM6IGluZGV4IGZpbGUgb3BlbiBmYWlsZWQiLCBwYXRoKTsKCX0KCglpZiAoZnN0YXQoZmQsICZzdCkpCgkJZGllX2Vycm5vKCJjYW5ub3Qgc3RhdCB0aGUgb3BlbiBpbmRleCIpOwoKCW1tYXBfc2l6ZSA9IHhzaXplX3Qoc3Quc3Rfc2l6ZSk7CglpZiAobW1hcF9zaXplIDwgc2l6ZW9mKHN0cnVjdCBjYWNoZV9oZWFkZXIpICsgMjApCgkJZGllKCJpbmRleCBmaWxlIHNtYWxsZXIgdGhhbiBleHBlY3RlZCIpOwoKCW1tYXAgPSB4bW1hcChOVUxMLCBtbWFwX3NpemUsIFBST1RfUkVBRCB8IFBST1RfV1JJVEUsIE1BUF9QUklWQVRFLCBmZCwgMCk7CglpZiAobW1hcCA9PSBNQVBfRkFJTEVEKQoJCWRpZV9lcnJubygidW5hYmxlIHRvIG1hcCBpbmRleCBmaWxlIik7CgljbG9zZShmZCk7CgoJaGRyID0gbW1hcDsKCWlmICh2ZXJpZnlfaGRyKGhkciwgbW1hcF9zaXplKSA8IDApCgkJZ290byB1bm1hcDsKCgloYXNoY3B5KGlzdGF0ZS0+c2hhMSwgKGNvbnN0IHVuc2lnbmVkIGNoYXIgKiloZHIgKyBtbWFwX3NpemUgLSAyMCk7Cglpc3RhdGUtPnZlcnNpb24gPSBudG9obChoZHItPmhkcl92ZXJzaW9uKTsKCWlzdGF0ZS0+Y2FjaGVfbnIgPSBudG9obChoZHItPmhkcl9lbnRyaWVzKTsKCWlzdGF0ZS0+Y2FjaGVfYWxsb2MgPSBhbGxvY19ucihpc3RhdGUtPmNhY2hlX25yKTsKCWlzdGF0ZS0+Y2FjaGUgPSB4Y2FsbG9jKGlzdGF0ZS0+Y2FjaGVfYWxsb2MsIHNpemVvZigqaXN0YXRlLT5jYWNoZSkpOwoJaXN0YXRlLT5pbml0aWFsaXplZCA9IDE7CgoJaWYgKGlzdGF0ZS0+dmVyc2lvbiA9PSA0KQoJCXByZXZpb3VzX25hbWUgPSAmcHJldmlvdXNfbmFtZV9idWY7CgllbHNlCgkJcHJldmlvdXNfbmFtZSA9IE5VTEw7CgoJc3JjX29mZnNldCA9IHNpemVvZigqaGRyKTsKCWZvciAoaSA9IDA7IGkgPCBpc3RhdGUtPmNhY2hlX25yOyBpKyspIHsKCQlzdHJ1Y3Qgb25kaXNrX2NhY2hlX2VudHJ5ICpkaXNrX2NlOwoJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2U7CgkJdW5zaWduZWQgbG9uZyBjb25zdW1lZDsKCgkJZGlza19jZSA9IChzdHJ1Y3Qgb25kaXNrX2NhY2hlX2VudHJ5ICopKChjaGFyICopbW1hcCArIHNyY19vZmZzZXQpOwoJCWNlID0gY3JlYXRlX2Zyb21fZGlzayhkaXNrX2NlLCAmY29uc3VtZWQsIHByZXZpb3VzX25hbWUpOwoJCXNldF9pbmRleF9lbnRyeShpc3RhdGUsIGksIGNlKTsKCgkJaWYgKGkgPiAwKQoJCQljaGVja19jZV9vcmRlcihpc3RhdGUtPmNhY2hlW2kgLSAxXSwgY2UpOwoKCQlzcmNfb2Zmc2V0ICs9IGNvbnN1bWVkOwoJfQoJc3RyYnVmX3JlbGVhc2UoJnByZXZpb3VzX25hbWVfYnVmKTsKCWlzdGF0ZS0+dGltZXN0YW1wLnNlYyA9IHN0LnN0X210aW1lOwoJaXN0YXRlLT50aW1lc3RhbXAubnNlYyA9IFNUX01USU1FX05TRUMoc3QpOwoKCXdoaWxlIChzcmNfb2Zmc2V0IDw9IG1tYXBfc2l6ZSAtIDIwIC0gOCkgewoJCS8qIEFmdGVyIGFuIGFycmF5IG9mIGFjdGl2ZV9uciBpbmRleCBlbnRyaWVzLAoJCSAqIHRoZXJlIGNhbiBiZSBhcmJpdHJhcnkgbnVtYmVyIG9mIGV4dGVuZGVkCgkJICogc2VjdGlvbnMsIGVhY2ggb2Ygd2hpY2ggaXMgcHJlZml4ZWQgd2l0aAoJCSAqIGV4dGVuc2lvbiBuYW1lICg0LWJ5dGUpIGFuZCBzZWN0aW9uIGxlbmd0aAoJCSAqIGluIDQtYnl0ZSBuZXR3b3JrIGJ5dGUgb3JkZXIuCgkJICovCgkJdWludDMyX3QgZXh0c2l6ZTsKCQltZW1jcHkoJmV4dHNpemUsIChjaGFyICopbW1hcCArIHNyY19vZmZzZXQgKyA0LCA0KTsKCQlleHRzaXplID0gbnRvaGwoZXh0c2l6ZSk7CgkJaWYgKHJlYWRfaW5kZXhfZXh0ZW5zaW9uKGlzdGF0ZSwKCQkJCQkgKGNvbnN0IGNoYXIgKikgbW1hcCArIHNyY19vZmZzZXQsCgkJCQkJIChjaGFyICopIG1tYXAgKyBzcmNfb2Zmc2V0ICsgOCwKCQkJCQkgZXh0c2l6ZSkgPCAwKQoJCQlnb3RvIHVubWFwOwoJCXNyY19vZmZzZXQgKz0gODsKCQlzcmNfb2Zmc2V0ICs9IGV4dHNpemU7Cgl9CgltdW5tYXAobW1hcCwgbW1hcF9zaXplKTsKCXJldHVybiBpc3RhdGUtPmNhY2hlX25yOwoKdW5tYXA6CgltdW5tYXAobW1hcCwgbW1hcF9zaXplKTsKCWRpZSgiaW5kZXggZmlsZSBjb3JydXB0Iik7Cn0KCmludCByZWFkX2luZGV4X2Zyb20oc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIGNvbnN0IGNoYXIgKnBhdGgpCnsKCXN0cnVjdCBzcGxpdF9pbmRleCAqc3BsaXRfaW5kZXg7CglpbnQgcmV0OwoKCS8qIGlzdGF0ZS0+aW5pdGlhbGl6ZWQgY292ZXJzIGJvdGggLmdpdC9pbmRleCBhbmQgLmdpdC9zaGFyZWRpbmRleC54eHggKi8KCWlmIChpc3RhdGUtPmluaXRpYWxpemVkKQoJCXJldHVybiBpc3RhdGUtPmNhY2hlX25yOwoKCXJldCA9IGRvX3JlYWRfaW5kZXgoaXN0YXRlLCBwYXRoLCAwKTsKCXNwbGl0X2luZGV4ID0gaXN0YXRlLT5zcGxpdF9pbmRleDsKCWlmICghc3BsaXRfaW5kZXgpCgkJcmV0dXJuIHJldDsKCglpZiAoaXNfbnVsbF9zaGExKHNwbGl0X2luZGV4LT5iYXNlX3NoYTEpKQoJCXJldHVybiByZXQ7CgoJaWYgKHNwbGl0X2luZGV4LT5iYXNlKQoJCWRpc2NhcmRfaW5kZXgoc3BsaXRfaW5kZXgtPmJhc2UpOwoJZWxzZQoJCXNwbGl0X2luZGV4LT5iYXNlID0geGNhbGxvYygxLCBzaXplb2YoKnNwbGl0X2luZGV4LT5iYXNlKSk7CglyZXQgPSBkb19yZWFkX2luZGV4KHNwbGl0X2luZGV4LT5iYXNlLAoJCQkgICAgZ2l0X3BhdGgoInNoYXJlZGluZGV4LiVzIiwKCQkJCSAgICAgc2hhMV90b19oZXgoc3BsaXRfaW5kZXgtPmJhc2Vfc2hhMSkpLCAxKTsKCWlmIChoYXNoY21wKHNwbGl0X2luZGV4LT5iYXNlX3NoYTEsIHNwbGl0X2luZGV4LT5iYXNlLT5zaGExKSkKCQlkaWUoImJyb2tlbiBpbmRleCwgZXhwZWN0ICVzIGluICVzLCBnb3QgJXMiLAoJCSAgICBzaGExX3RvX2hleChzcGxpdF9pbmRleC0+YmFzZV9zaGExKSwKCQkgICAgZ2l0X3BhdGgoInNoYXJlZGluZGV4LiVzIiwKCQkJCSAgICAgc2hhMV90b19oZXgoc3BsaXRfaW5kZXgtPmJhc2Vfc2hhMSkpLAoJCSAgICBzaGExX3RvX2hleChzcGxpdF9pbmRleC0+YmFzZS0+c2hhMSkpOwoJbWVyZ2VfYmFzZV9pbmRleChpc3RhdGUpOwoJcmV0dXJuIHJldDsKfQoKaW50IGlzX2luZGV4X3VuYm9ybihzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSkKewoJcmV0dXJuICghaXN0YXRlLT5jYWNoZV9uciAmJiAhaXN0YXRlLT50aW1lc3RhbXAuc2VjKTsKfQoKaW50IGRpc2NhcmRfaW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUpCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBpc3RhdGUtPmNhY2hlX25yOyBpKyspIHsKCQlpZiAoaXN0YXRlLT5jYWNoZVtpXS0+aW5kZXggJiYKCQkgICAgaXN0YXRlLT5zcGxpdF9pbmRleCAmJgoJCSAgICBpc3RhdGUtPnNwbGl0X2luZGV4LT5iYXNlICYmCgkJICAgIGlzdGF0ZS0+Y2FjaGVbaV0tPmluZGV4IDw9IGlzdGF0ZS0+c3BsaXRfaW5kZXgtPmJhc2UtPmNhY2hlX25yICYmCgkJICAgIGlzdGF0ZS0+Y2FjaGVbaV0gPT0gaXN0YXRlLT5zcGxpdF9pbmRleC0+YmFzZS0+Y2FjaGVbaXN0YXRlLT5jYWNoZVtpXS0+aW5kZXggLSAxXSkKCQkJY29udGludWU7CgkJZnJlZShpc3RhdGUtPmNhY2hlW2ldKTsKCX0KCXJlc29sdmVfdW5kb19jbGVhcl9pbmRleChpc3RhdGUpOwoJaXN0YXRlLT5jYWNoZV9uciA9IDA7Cglpc3RhdGUtPmNhY2hlX2NoYW5nZWQgPSAwOwoJaXN0YXRlLT50aW1lc3RhbXAuc2VjID0gMDsKCWlzdGF0ZS0+dGltZXN0YW1wLm5zZWMgPSAwOwoJZnJlZV9uYW1lX2hhc2goaXN0YXRlKTsKCWNhY2hlX3RyZWVfZnJlZSgmKGlzdGF0ZS0+Y2FjaGVfdHJlZSkpOwoJaXN0YXRlLT5pbml0aWFsaXplZCA9IDA7CglmcmVlKGlzdGF0ZS0+Y2FjaGUpOwoJaXN0YXRlLT5jYWNoZSA9IE5VTEw7Cglpc3RhdGUtPmNhY2hlX2FsbG9jID0gMDsKCWRpc2NhcmRfc3BsaXRfaW5kZXgoaXN0YXRlKTsKCXJldHVybiAwOwp9CgppbnQgdW5tZXJnZWRfaW5kZXgoY29uc3Qgc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUpCnsKCWludCBpOwoJZm9yIChpID0gMDsgaSA8IGlzdGF0ZS0+Y2FjaGVfbnI7IGkrKykgewoJCWlmIChjZV9zdGFnZShpc3RhdGUtPmNhY2hlW2ldKSkKCQkJcmV0dXJuIDE7Cgl9CglyZXR1cm4gMDsKfQoKI2RlZmluZSBXUklURV9CVUZGRVJfU0laRSA4MTkyCnN0YXRpYyB1bnNpZ25lZCBjaGFyIHdyaXRlX2J1ZmZlcltXUklURV9CVUZGRVJfU0laRV07CnN0YXRpYyB1bnNpZ25lZCBsb25nIHdyaXRlX2J1ZmZlcl9sZW47CgpzdGF0aWMgaW50IGNlX3dyaXRlX2ZsdXNoKGdpdF9TSEFfQ1RYICpjb250ZXh0LCBpbnQgZmQpCnsKCXVuc2lnbmVkIGludCBidWZmZXJlZCA9IHdyaXRlX2J1ZmZlcl9sZW47CglpZiAoYnVmZmVyZWQpIHsKCQlnaXRfU0hBMV9VcGRhdGUoY29udGV4dCwgd3JpdGVfYnVmZmVyLCBidWZmZXJlZCk7CgkJaWYgKHdyaXRlX2luX2Z1bGwoZmQsIHdyaXRlX2J1ZmZlciwgYnVmZmVyZWQpICE9IGJ1ZmZlcmVkKQoJCQlyZXR1cm4gLTE7CgkJd3JpdGVfYnVmZmVyX2xlbiA9IDA7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBjZV93cml0ZShnaXRfU0hBX0NUWCAqY29udGV4dCwgaW50IGZkLCB2b2lkICpkYXRhLCB1bnNpZ25lZCBpbnQgbGVuKQp7Cgl3aGlsZSAobGVuKSB7CgkJdW5zaWduZWQgaW50IGJ1ZmZlcmVkID0gd3JpdGVfYnVmZmVyX2xlbjsKCQl1bnNpZ25lZCBpbnQgcGFydGlhbCA9IFdSSVRFX0JVRkZFUl9TSVpFIC0gYnVmZmVyZWQ7CgkJaWYgKHBhcnRpYWwgPiBsZW4pCgkJCXBhcnRpYWwgPSBsZW47CgkJbWVtY3B5KHdyaXRlX2J1ZmZlciArIGJ1ZmZlcmVkLCBkYXRhLCBwYXJ0aWFsKTsKCQlidWZmZXJlZCArPSBwYXJ0aWFsOwoJCWlmIChidWZmZXJlZCA9PSBXUklURV9CVUZGRVJfU0laRSkgewoJCQl3cml0ZV9idWZmZXJfbGVuID0gYnVmZmVyZWQ7CgkJCWlmIChjZV93cml0ZV9mbHVzaChjb250ZXh0LCBmZCkpCgkJCQlyZXR1cm4gLTE7CgkJCWJ1ZmZlcmVkID0gMDsKCQl9CgkJd3JpdGVfYnVmZmVyX2xlbiA9IGJ1ZmZlcmVkOwoJCWxlbiAtPSBwYXJ0aWFsOwoJCWRhdGEgPSAoY2hhciAqKSBkYXRhICsgcGFydGlhbDsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHdyaXRlX2luZGV4X2V4dF9oZWFkZXIoZ2l0X1NIQV9DVFggKmNvbnRleHQsIGludCBmZCwKCQkJCSAgdW5zaWduZWQgaW50IGV4dCwgdW5zaWduZWQgaW50IHN6KQp7CglleHQgPSBodG9ubChleHQpOwoJc3ogPSBodG9ubChzeik7CglyZXR1cm4gKChjZV93cml0ZShjb250ZXh0LCBmZCwgJmV4dCwgNCkgPCAwKSB8fAoJCShjZV93cml0ZShjb250ZXh0LCBmZCwgJnN6LCA0KSA8IDApKSA/IC0xIDogMDsKfQoKc3RhdGljIGludCBjZV9mbHVzaChnaXRfU0hBX0NUWCAqY29udGV4dCwgaW50IGZkLCB1bnNpZ25lZCBjaGFyICpzaGExKQp7Cgl1bnNpZ25lZCBpbnQgbGVmdCA9IHdyaXRlX2J1ZmZlcl9sZW47CgoJaWYgKGxlZnQpIHsKCQl3cml0ZV9idWZmZXJfbGVuID0gMDsKCQlnaXRfU0hBMV9VcGRhdGUoY29udGV4dCwgd3JpdGVfYnVmZmVyLCBsZWZ0KTsKCX0KCgkvKiBGbHVzaCBmaXJzdCBpZiBub3QgZW5vdWdoIHNwYWNlIGZvciBTSEExIHNpZ25hdHVyZSAqLwoJaWYgKGxlZnQgKyAyMCA+IFdSSVRFX0JVRkZFUl9TSVpFKSB7CgkJaWYgKHdyaXRlX2luX2Z1bGwoZmQsIHdyaXRlX2J1ZmZlciwgbGVmdCkgIT0gbGVmdCkKCQkJcmV0dXJuIC0xOwoJCWxlZnQgPSAwOwoJfQoKCS8qIEFwcGVuZCB0aGUgU0hBMSBzaWduYXR1cmUgYXQgdGhlIGVuZCAqLwoJZ2l0X1NIQTFfRmluYWwod3JpdGVfYnVmZmVyICsgbGVmdCwgY29udGV4dCk7CgloYXNoY3B5KHNoYTEsIHdyaXRlX2J1ZmZlciArIGxlZnQpOwoJbGVmdCArPSAyMDsKCXJldHVybiAod3JpdGVfaW5fZnVsbChmZCwgd3JpdGVfYnVmZmVyLCBsZWZ0KSAhPSBsZWZ0KSA/IC0xIDogMDsKfQoKc3RhdGljIHZvaWQgY2Vfc211ZGdlX3JhY2lseV9jbGVhbl9lbnRyeShzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKQp7CgkvKgoJICogVGhlIG9ubHkgdGhpbmcgd2UgY2FyZSBhYm91dCBpbiB0aGlzIGZ1bmN0aW9uIGlzIHRvIHNtdWRnZSB0aGUKCSAqIGZhbHNlbHkgY2xlYW4gZW50cnkgZHVlIHRvIHRvdWNoLXVwZGF0ZS10b3VjaCByYWNlLCBzbyB3ZSBsZWF2ZQoJICogZXZlcnl0aGluZyBlbHNlIGFzIHRoZXkgYXJlLiAgV2UgYXJlIGNhbGxlZCBmb3IgZW50cmllcyB3aG9zZQoJICogY2Vfc3RhdF9kYXRhLnNkX210aW1lIG1hdGNoIHRoZSBpbmRleCBmaWxlIG10aW1lLgoJICoKCSAqIE5vdGUgdGhhdCB0aGlzIGFjdHVhbGx5IGRvZXMgbm90IGRvIG11Y2ggZm9yIGdpdGxpbmtzLCBmb3IKCSAqIHdoaWNoIGNlX21hdGNoX3N0YXRfYmFzaWMoKSBhbHdheXMgZ29lcyB0byB0aGUgYWN0dWFsCgkgKiBjb250ZW50cy4gIFRoZSBjYWxsZXIgY2hlY2tzIHdpdGggaXNfcmFjeV90aW1lc3RhbXAoKSB3aGljaAoJICogYWx3YXlzIHNheXMgIm5vIiBmb3IgZ2l0bGlua3MsIHNvIHdlIGFyZSBub3QgY2FsbGVkIGZvciB0aGVtIDstKQoJICovCglzdHJ1Y3Qgc3RhdCBzdDsKCglpZiAobHN0YXQoY2UtPm5hbWUsICZzdCkgPCAwKQoJCXJldHVybjsKCWlmIChjZV9tYXRjaF9zdGF0X2Jhc2ljKGNlLCAmc3QpKQoJCXJldHVybjsKCWlmIChjZV9tb2RpZmllZF9jaGVja19mcyhjZSwgJnN0KSkgewoJCS8qIFRoaXMgaXMgInJhY2lseSBjbGVhbiI7IHNtdWRnZSBpdC4gIE5vdGUgdGhhdCB0aGlzCgkJICogaXMgYSB0cmlja3kgY29kZS4gIEF0IGZpcnN0IGdsYW5jZSwgaXQgbWF5IGFwcGVhcgoJCSAqIHRoYXQgaXQgY2FuIGJyZWFrIHdpdGggdGhpcyBzZXF1ZW5jZToKCQkgKgoJCSAqICQgZWNobyB4eXp6eSA+ZnJvdHoKCQkgKiAkIGdpdC11cGRhdGUtaW5kZXggLS1hZGQgZnJvdHoKCQkgKiAkIDogPmZyb3R6CgkJICogJCBzbGVlcCAzCgkJICogJCBlY2hvIGZpbGZyZSA+bml0Zm9sCgkJICogJCBnaXQtdXBkYXRlLWluZGV4IC0tYWRkIG5pdGZvbAoJCSAqCgkJICogYnV0IGl0IGRvZXMgbm90LiAgV2hlbiB0aGUgc2Vjb25kIHVwZGF0ZS1pbmRleCBydW5zLAoJCSAqIGl0IG5vdGljZXMgdGhhdCB0aGUgZW50cnkgImZyb3R6IiBoYXMgdGhlIHNhbWUgdGltZXN0YW1wCgkJICogYXMgaW5kZXgsIGFuZCBpZiB3ZSB3ZXJlIHRvIHNtdWRnZSBpdCBieSByZXNldHRpbmcgaXRzCgkJICogc2l6ZSB0byB6ZXJvIGhlcmUsIHRoZW4gdGhlIG9iamVjdCBuYW1lIHJlY29yZGVkCgkJICogaW4gaW5kZXggaXMgdGhlIDYtYnl0ZSBmaWxlIGJ1dCB0aGUgY2FjaGVkIHN0YXQgaW5mb3JtYXRpb24KCQkgKiBiZWNvbWVzIHplcm8gLS0tIHdoaWNoIHdvdWxkIHRoZW4gbWF0Y2ggd2hhdCB3ZSB3b3VsZAoJCSAqIG9idGFpbiBmcm9tIHRoZSBmaWxlc3lzdGVtIG5leHQgdGltZSB3ZSBzdGF0KCJmcm90eiIpLgoJCSAqCgkJICogSG93ZXZlciwgdGhlIHNlY29uZCB1cGRhdGUtaW5kZXgsIGJlZm9yZSBjYWxsaW5nCgkJICogdGhpcyBmdW5jdGlvbiwgbm90aWNlcyB0aGF0IHRoZSBjYWNoZWQgc2l6ZSBpcyA2CgkJICogYnl0ZXMgYW5kIHdoYXQgaXMgb24gdGhlIGZpbGVzeXN0ZW0gaXMgYW4gZW1wdHkKCQkgKiBmaWxlLCBhbmQgbmV2ZXIgY2FsbHMgdXMsIHNvIHRoZSBjYWNoZWQgc2l6ZSBpbmZvcm1hdGlvbgoJCSAqIGZvciAiZnJvdHoiIHN0YXlzIDYgd2hpY2ggZG9lcyBub3QgbWF0Y2ggdGhlIGZpbGVzeXN0ZW0uCgkJICovCgkJY2UtPmNlX3N0YXRfZGF0YS5zZF9zaXplID0gMDsKCX0KfQoKLyogQ29weSBtaXNjZWxsYW5lb3VzIGZpZWxkcyBidXQgbm90IHRoZSBuYW1lICovCnN0YXRpYyBjaGFyICpjb3B5X2NhY2hlX2VudHJ5X3RvX29uZGlzayhzdHJ1Y3Qgb25kaXNrX2NhY2hlX2VudHJ5ICpvbmRpc2ssCgkJCQkgICAgICAgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSkKewoJc2hvcnQgZmxhZ3M7CgoJb25kaXNrLT5jdGltZS5zZWMgPSBodG9ubChjZS0+Y2Vfc3RhdF9kYXRhLnNkX2N0aW1lLnNlYyk7CglvbmRpc2stPm10aW1lLnNlYyA9IGh0b25sKGNlLT5jZV9zdGF0X2RhdGEuc2RfbXRpbWUuc2VjKTsKCW9uZGlzay0+Y3RpbWUubnNlYyA9IGh0b25sKGNlLT5jZV9zdGF0X2RhdGEuc2RfY3RpbWUubnNlYyk7CglvbmRpc2stPm10aW1lLm5zZWMgPSBodG9ubChjZS0+Y2Vfc3RhdF9kYXRhLnNkX210aW1lLm5zZWMpOwoJb25kaXNrLT5kZXYgID0gaHRvbmwoY2UtPmNlX3N0YXRfZGF0YS5zZF9kZXYpOwoJb25kaXNrLT5pbm8gID0gaHRvbmwoY2UtPmNlX3N0YXRfZGF0YS5zZF9pbm8pOwoJb25kaXNrLT5tb2RlID0gaHRvbmwoY2UtPmNlX21vZGUpOwoJb25kaXNrLT51aWQgID0gaHRvbmwoY2UtPmNlX3N0YXRfZGF0YS5zZF91aWQpOwoJb25kaXNrLT5naWQgID0gaHRvbmwoY2UtPmNlX3N0YXRfZGF0YS5zZF9naWQpOwoJb25kaXNrLT5zaXplID0gaHRvbmwoY2UtPmNlX3N0YXRfZGF0YS5zZF9zaXplKTsKCWhhc2hjcHkob25kaXNrLT5zaGExLCBjZS0+c2hhMSk7CgoJZmxhZ3MgPSBjZS0+Y2VfZmxhZ3MgJiB+Q0VfTkFNRU1BU0s7CglmbGFncyB8PSAoY2VfbmFtZWxlbihjZSkgPj0gQ0VfTkFNRU1BU0sgPyBDRV9OQU1FTUFTSyA6IGNlX25hbWVsZW4oY2UpKTsKCW9uZGlzay0+ZmxhZ3MgPSBodG9ucyhmbGFncyk7CglpZiAoY2UtPmNlX2ZsYWdzICYgQ0VfRVhURU5ERUQpIHsKCQlzdHJ1Y3Qgb25kaXNrX2NhY2hlX2VudHJ5X2V4dGVuZGVkICpvbmRpc2syOwoJCW9uZGlzazIgPSAoc3RydWN0IG9uZGlza19jYWNoZV9lbnRyeV9leHRlbmRlZCAqKW9uZGlzazsKCQlvbmRpc2syLT5mbGFnczIgPSBodG9ucygoY2UtPmNlX2ZsYWdzICYgQ0VfRVhURU5ERURfRkxBR1MpID4+IDE2KTsKCQlyZXR1cm4gb25kaXNrMi0+bmFtZTsKCX0KCWVsc2UgewoJCXJldHVybiBvbmRpc2stPm5hbWU7Cgl9Cn0KCnN0YXRpYyBpbnQgY2Vfd3JpdGVfZW50cnkoZ2l0X1NIQV9DVFggKmMsIGludCBmZCwgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwKCQkJICBzdHJ1Y3Qgc3RyYnVmICpwcmV2aW91c19uYW1lKQp7CglpbnQgc2l6ZTsKCXN0cnVjdCBvbmRpc2tfY2FjaGVfZW50cnkgKm9uZGlzazsKCWludCBzYXZlZF9uYW1lbGVuID0gc2F2ZWRfbmFtZWxlbjsgLyogY29tcGlsZXIgd29ya2Fyb3VuZCAqLwoJY2hhciAqbmFtZTsKCWludCByZXN1bHQ7CgoJaWYgKGNlLT5jZV9mbGFncyAmIENFX1NUUklQX05BTUUpIHsKCQlzYXZlZF9uYW1lbGVuID0gY2VfbmFtZWxlbihjZSk7CgkJY2UtPmNlX25hbWVsZW4gPSAwOwoJfQoKCWlmICghcHJldmlvdXNfbmFtZSkgewoJCXNpemUgPSBvbmRpc2tfY2Vfc2l6ZShjZSk7CgkJb25kaXNrID0geGNhbGxvYygxLCBzaXplKTsKCQluYW1lID0gY29weV9jYWNoZV9lbnRyeV90b19vbmRpc2sob25kaXNrLCBjZSk7CgkJbWVtY3B5KG5hbWUsIGNlLT5uYW1lLCBjZV9uYW1lbGVuKGNlKSk7Cgl9IGVsc2UgewoJCWludCBjb21tb24sIHRvX3JlbW92ZSwgcHJlZml4X3NpemU7CgkJdW5zaWduZWQgY2hhciB0b19yZW1vdmVfdmlbMTZdOwoJCWZvciAoY29tbW9uID0gMDsKCQkgICAgIChjZS0+bmFtZVtjb21tb25dICYmCgkJICAgICAgY29tbW9uIDwgcHJldmlvdXNfbmFtZS0+bGVuICYmCgkJICAgICAgY2UtPm5hbWVbY29tbW9uXSA9PSBwcmV2aW91c19uYW1lLT5idWZbY29tbW9uXSk7CgkJICAgICBjb21tb24rKykKCQkJOyAvKiBzdGlsbCBtYXRjaGluZyAqLwoJCXRvX3JlbW92ZSA9IHByZXZpb3VzX25hbWUtPmxlbiAtIGNvbW1vbjsKCQlwcmVmaXhfc2l6ZSA9IGVuY29kZV92YXJpbnQodG9fcmVtb3ZlLCB0b19yZW1vdmVfdmkpOwoKCQlpZiAoY2UtPmNlX2ZsYWdzICYgQ0VfRVhURU5ERUQpCgkJCXNpemUgPSBvZmZzZXRvZihzdHJ1Y3Qgb25kaXNrX2NhY2hlX2VudHJ5X2V4dGVuZGVkLCBuYW1lKTsKCQllbHNlCgkJCXNpemUgPSBvZmZzZXRvZihzdHJ1Y3Qgb25kaXNrX2NhY2hlX2VudHJ5LCBuYW1lKTsKCQlzaXplICs9IHByZWZpeF9zaXplICsgKGNlX25hbWVsZW4oY2UpIC0gY29tbW9uICsgMSk7CgoJCW9uZGlzayA9IHhjYWxsb2MoMSwgc2l6ZSk7CgkJbmFtZSA9IGNvcHlfY2FjaGVfZW50cnlfdG9fb25kaXNrKG9uZGlzaywgY2UpOwoJCW1lbWNweShuYW1lLCB0b19yZW1vdmVfdmksIHByZWZpeF9zaXplKTsKCQltZW1jcHkobmFtZSArIHByZWZpeF9zaXplLCBjZS0+bmFtZSArIGNvbW1vbiwgY2VfbmFtZWxlbihjZSkgLSBjb21tb24pOwoKCQlzdHJidWZfc3BsaWNlKHByZXZpb3VzX25hbWUsIGNvbW1vbiwgdG9fcmVtb3ZlLAoJCQkgICAgICBjZS0+bmFtZSArIGNvbW1vbiwgY2VfbmFtZWxlbihjZSkgLSBjb21tb24pOwoJfQoJaWYgKGNlLT5jZV9mbGFncyAmIENFX1NUUklQX05BTUUpIHsKCQljZS0+Y2VfbmFtZWxlbiA9IHNhdmVkX25hbWVsZW47CgkJY2UtPmNlX2ZsYWdzICY9IH5DRV9TVFJJUF9OQU1FOwoJfQoKCXJlc3VsdCA9IGNlX3dyaXRlKGMsIGZkLCBvbmRpc2ssIHNpemUpOwoJZnJlZShvbmRpc2spOwoJcmV0dXJuIHJlc3VsdDsKfQoKLyoKICogVGhpcyBmdW5jdGlvbiB2ZXJpZmllcyBpZiBpbmRleF9zdGF0ZSBoYXMgdGhlIGNvcnJlY3Qgc2hhMSBvZiB0aGUKICogaW5kZXggZmlsZS4gIERvbid0IGRpZSBpZiB3ZSBoYXZlIGFueSBvdGhlciBmYWlsdXJlLCBqdXN0IHJldHVybiAwLgogKi8Kc3RhdGljIGludCB2ZXJpZnlfaW5kZXhfZnJvbShjb25zdCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgY29uc3QgY2hhciAqcGF0aCkKewoJaW50IGZkOwoJc3NpemVfdCBuOwoJc3RydWN0IHN0YXQgc3Q7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoKCWlmICghaXN0YXRlLT5pbml0aWFsaXplZCkKCQlyZXR1cm4gMDsKCglmZCA9IG9wZW4ocGF0aCwgT19SRE9OTFkpOwoJaWYgKGZkIDwgMCkKCQlyZXR1cm4gMDsKCglpZiAoZnN0YXQoZmQsICZzdCkpCgkJZ290byBvdXQ7CgoJaWYgKHN0LnN0X3NpemUgPCBzaXplb2Yoc3RydWN0IGNhY2hlX2hlYWRlcikgKyAyMCkKCQlnb3RvIG91dDsKCgluID0gcHJlYWRfaW5fZnVsbChmZCwgc2hhMSwgMjAsIHN0LnN0X3NpemUgLSAyMCk7CglpZiAobiAhPSAyMCkKCQlnb3RvIG91dDsKCglpZiAoaGFzaGNtcChpc3RhdGUtPnNoYTEsIHNoYTEpKQoJCWdvdG8gb3V0OwoKCWNsb3NlKGZkKTsKCXJldHVybiAxOwoKb3V0OgoJY2xvc2UoZmQpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgdmVyaWZ5X2luZGV4KGNvbnN0IHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlKQp7CglyZXR1cm4gdmVyaWZ5X2luZGV4X2Zyb20oaXN0YXRlLCBnZXRfaW5kZXhfZmlsZSgpKTsKfQoKc3RhdGljIGludCBoYXNfcmFjeV90aW1lc3RhbXAoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUpCnsKCWludCBlbnRyaWVzID0gaXN0YXRlLT5jYWNoZV9ucjsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBlbnRyaWVzOyBpKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gaXN0YXRlLT5jYWNoZVtpXTsKCQlpZiAoaXNfcmFjeV90aW1lc3RhbXAoaXN0YXRlLCBjZSkpCgkJCXJldHVybiAxOwoJfQoJcmV0dXJuIDA7Cn0KCi8qCiAqIE9wcG9ydHVuaXN0aWNhbGx5IHVwZGF0ZSB0aGUgaW5kZXggYnV0IGRvIG5vdCBjb21wbGFpbiBpZiB3ZSBjYW4ndAogKi8Kdm9pZCB1cGRhdGVfaW5kZXhfaWZfYWJsZShzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgc3RydWN0IGxvY2tfZmlsZSAqbG9ja2ZpbGUpCnsKCWlmICgoaXN0YXRlLT5jYWNoZV9jaGFuZ2VkIHx8IGhhc19yYWN5X3RpbWVzdGFtcChpc3RhdGUpKSAmJgoJICAgIHZlcmlmeV9pbmRleChpc3RhdGUpICYmCgkgICAgd3JpdGVfbG9ja2VkX2luZGV4KGlzdGF0ZSwgbG9ja2ZpbGUsIENPTU1JVF9MT0NLKSkKCQlyb2xsYmFja19sb2NrX2ZpbGUobG9ja2ZpbGUpOwp9CgpzdGF0aWMgaW50IGRvX3dyaXRlX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBpbnQgbmV3ZmQsCgkJCSAgaW50IHN0cmlwX2V4dGVuc2lvbnMpCnsKCWdpdF9TSEFfQ1RYIGM7CglzdHJ1Y3QgY2FjaGVfaGVhZGVyIGhkcjsKCWludCBpLCBlcnIsIHJlbW92ZWQsIGV4dGVuZGVkLCBoZHJfdmVyc2lvbjsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqKmNhY2hlID0gaXN0YXRlLT5jYWNoZTsKCWludCBlbnRyaWVzID0gaXN0YXRlLT5jYWNoZV9ucjsKCXN0cnVjdCBzdGF0IHN0OwoJc3RydWN0IHN0cmJ1ZiBwcmV2aW91c19uYW1lX2J1ZiA9IFNUUkJVRl9JTklULCAqcHJldmlvdXNfbmFtZTsKCglmb3IgKGkgPSByZW1vdmVkID0gZXh0ZW5kZWQgPSAwOyBpIDwgZW50cmllczsgaSsrKSB7CgkJaWYgKGNhY2hlW2ldLT5jZV9mbGFncyAmIENFX1JFTU9WRSkKCQkJcmVtb3ZlZCsrOwoKCQkvKiByZWR1Y2UgZXh0ZW5kZWQgZW50cmllcyBpZiBwb3NzaWJsZSAqLwoJCWNhY2hlW2ldLT5jZV9mbGFncyAmPSB+Q0VfRVhURU5ERUQ7CgkJaWYgKGNhY2hlW2ldLT5jZV9mbGFncyAmIENFX0VYVEVOREVEX0ZMQUdTKSB7CgkJCWV4dGVuZGVkKys7CgkJCWNhY2hlW2ldLT5jZV9mbGFncyB8PSBDRV9FWFRFTkRFRDsKCQl9Cgl9CgoJaWYgKCFpc3RhdGUtPnZlcnNpb24pIHsKCQlpc3RhdGUtPnZlcnNpb24gPSBnZXRfaW5kZXhfZm9ybWF0X2RlZmF1bHQoKTsKCQlpZiAoZ2V0ZW52KCJHSVRfVEVTVF9TUExJVF9JTkRFWCIpKQoJCQlpbml0X3NwbGl0X2luZGV4KGlzdGF0ZSk7Cgl9CgoJLyogZGVtb3RlIHZlcnNpb24gMyB0byB2ZXJzaW9uIDIgd2hlbiB0aGUgbGF0dGVyIHN1ZmZpY2VzICovCglpZiAoaXN0YXRlLT52ZXJzaW9uID09IDMgfHwgaXN0YXRlLT52ZXJzaW9uID09IDIpCgkJaXN0YXRlLT52ZXJzaW9uID0gZXh0ZW5kZWQgPyAzIDogMjsKCgloZHJfdmVyc2lvbiA9IGlzdGF0ZS0+dmVyc2lvbjsKCgloZHIuaGRyX3NpZ25hdHVyZSA9IGh0b25sKENBQ0hFX1NJR05BVFVSRSk7CgloZHIuaGRyX3ZlcnNpb24gPSBodG9ubChoZHJfdmVyc2lvbik7CgloZHIuaGRyX2VudHJpZXMgPSBodG9ubChlbnRyaWVzIC0gcmVtb3ZlZCk7CgoJZ2l0X1NIQTFfSW5pdCgmYyk7CglpZiAoY2Vfd3JpdGUoJmMsIG5ld2ZkLCAmaGRyLCBzaXplb2YoaGRyKSkgPCAwKQoJCXJldHVybiAtMTsKCglwcmV2aW91c19uYW1lID0gKGhkcl92ZXJzaW9uID09IDQpID8gJnByZXZpb3VzX25hbWVfYnVmIDogTlVMTDsKCWZvciAoaSA9IDA7IGkgPCBlbnRyaWVzOyBpKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gY2FjaGVbaV07CgkJaWYgKGNlLT5jZV9mbGFncyAmIENFX1JFTU9WRSkKCQkJY29udGludWU7CgkJaWYgKCFjZV91cHRvZGF0ZShjZSkgJiYgaXNfcmFjeV90aW1lc3RhbXAoaXN0YXRlLCBjZSkpCgkJCWNlX3NtdWRnZV9yYWNpbHlfY2xlYW5fZW50cnkoY2UpOwoJCWlmIChpc19udWxsX3NoYTEoY2UtPnNoYTEpKSB7CgkJCXN0YXRpYyBjb25zdCBjaGFyIG1zZ1tdID0gImNhY2hlIGVudHJ5IGhhcyBudWxsIHNoYTE6ICVzIjsKCQkJc3RhdGljIGludCBhbGxvdyA9IC0xOwoKCQkJaWYgKGFsbG93IDwgMCkKCQkJCWFsbG93ID0gZ2l0X2Vudl9ib29sKCJHSVRfQUxMT1dfTlVMTF9TSEExIiwgMCk7CgkJCWlmIChhbGxvdykKCQkJCXdhcm5pbmcobXNnLCBjZS0+bmFtZSk7CgkJCWVsc2UKCQkJCXJldHVybiBlcnJvcihtc2csIGNlLT5uYW1lKTsKCQl9CgkJaWYgKGNlX3dyaXRlX2VudHJ5KCZjLCBuZXdmZCwgY2UsIHByZXZpb3VzX25hbWUpIDwgMCkKCQkJcmV0dXJuIC0xOwoJfQoJc3RyYnVmX3JlbGVhc2UoJnByZXZpb3VzX25hbWVfYnVmKTsKCgkvKiBXcml0ZSBleHRlbnNpb24gZGF0YSBoZXJlICovCglpZiAoIXN0cmlwX2V4dGVuc2lvbnMgJiYgaXN0YXRlLT5zcGxpdF9pbmRleCkgewoJCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCgkJZXJyID0gd3JpdGVfbGlua19leHRlbnNpb24oJnNiLCBpc3RhdGUpIDwgMCB8fAoJCQl3cml0ZV9pbmRleF9leHRfaGVhZGVyKCZjLCBuZXdmZCwgQ0FDSEVfRVhUX0xJTkssCgkJCQkJICAgICAgIHNiLmxlbikgPCAwIHx8CgkJCWNlX3dyaXRlKCZjLCBuZXdmZCwgc2IuYnVmLCBzYi5sZW4pIDwgMDsKCQlzdHJidWZfcmVsZWFzZSgmc2IpOwoJCWlmIChlcnIpCgkJCXJldHVybiAtMTsKCX0KCWlmICghc3RyaXBfZXh0ZW5zaW9ucyAmJiBpc3RhdGUtPmNhY2hlX3RyZWUpIHsKCQlzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CgoJCWNhY2hlX3RyZWVfd3JpdGUoJnNiLCBpc3RhdGUtPmNhY2hlX3RyZWUpOwoJCWVyciA9IHdyaXRlX2luZGV4X2V4dF9oZWFkZXIoJmMsIG5ld2ZkLCBDQUNIRV9FWFRfVFJFRSwgc2IubGVuKSA8IDAKCQkJfHwgY2Vfd3JpdGUoJmMsIG5ld2ZkLCBzYi5idWYsIHNiLmxlbikgPCAwOwoJCXN0cmJ1Zl9yZWxlYXNlKCZzYik7CgkJaWYgKGVycikKCQkJcmV0dXJuIC0xOwoJfQoJaWYgKCFzdHJpcF9leHRlbnNpb25zICYmIGlzdGF0ZS0+cmVzb2x2ZV91bmRvKSB7CgkJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoKCQlyZXNvbHZlX3VuZG9fd3JpdGUoJnNiLCBpc3RhdGUtPnJlc29sdmVfdW5kbyk7CgkJZXJyID0gd3JpdGVfaW5kZXhfZXh0X2hlYWRlcigmYywgbmV3ZmQsIENBQ0hFX0VYVF9SRVNPTFZFX1VORE8sCgkJCQkJICAgICBzYi5sZW4pIDwgMAoJCQl8fCBjZV93cml0ZSgmYywgbmV3ZmQsIHNiLmJ1Ziwgc2IubGVuKSA8IDA7CgkJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCQlpZiAoZXJyKQoJCQlyZXR1cm4gLTE7Cgl9CgoJaWYgKGNlX2ZsdXNoKCZjLCBuZXdmZCwgaXN0YXRlLT5zaGExKSB8fCBmc3RhdChuZXdmZCwgJnN0KSkKCQlyZXR1cm4gLTE7Cglpc3RhdGUtPnRpbWVzdGFtcC5zZWMgPSAodW5zaWduZWQgaW50KXN0LnN0X210aW1lOwoJaXN0YXRlLT50aW1lc3RhbXAubnNlYyA9IFNUX01USU1FX05TRUMoc3QpOwoJcmV0dXJuIDA7Cn0KCnZvaWQgc2V0X2FsdGVybmF0ZV9pbmRleF9vdXRwdXQoY29uc3QgY2hhciAqbmFtZSkKewoJYWx0ZXJuYXRlX2luZGV4X291dHB1dCA9IG5hbWU7Cn0KCnN0YXRpYyBpbnQgY29tbWl0X2xvY2tlZF9pbmRleChzdHJ1Y3QgbG9ja19maWxlICpsaykKewoJaWYgKGFsdGVybmF0ZV9pbmRleF9vdXRwdXQpCgkJcmV0dXJuIGNvbW1pdF9sb2NrX2ZpbGVfdG8obGssIGFsdGVybmF0ZV9pbmRleF9vdXRwdXQpOwoJZWxzZQoJCXJldHVybiBjb21taXRfbG9ja19maWxlKGxrKTsKfQoKc3RhdGljIGludCBkb193cml0ZV9sb2NrZWRfaW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIHN0cnVjdCBsb2NrX2ZpbGUgKmxvY2ssCgkJCQkgdW5zaWduZWQgZmxhZ3MpCnsKCWludCByZXQgPSBkb193cml0ZV9pbmRleChpc3RhdGUsIGxvY2stPmZkLCAwKTsKCWlmIChyZXQpCgkJcmV0dXJuIHJldDsKCWFzc2VydCgoZmxhZ3MgJiAoQ09NTUlUX0xPQ0sgfCBDTE9TRV9MT0NLKSkgIT0KCSAgICAgICAoQ09NTUlUX0xPQ0sgfCBDTE9TRV9MT0NLKSk7CglpZiAoZmxhZ3MgJiBDT01NSVRfTE9DSykKCQlyZXR1cm4gY29tbWl0X2xvY2tlZF9pbmRleChsb2NrKTsKCWVsc2UgaWYgKGZsYWdzICYgQ0xPU0VfTE9DSykKCQlyZXR1cm4gY2xvc2VfbG9ja19maWxlKGxvY2spOwoJZWxzZQoJCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQgd3JpdGVfc3BsaXRfaW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsCgkJCSAgICAgc3RydWN0IGxvY2tfZmlsZSAqbG9jaywKCQkJICAgICB1bnNpZ25lZCBmbGFncykKewoJaW50IHJldDsKCXByZXBhcmVfdG9fd3JpdGVfc3BsaXRfaW5kZXgoaXN0YXRlKTsKCXJldCA9IGRvX3dyaXRlX2xvY2tlZF9pbmRleChpc3RhdGUsIGxvY2ssIGZsYWdzKTsKCWZpbmlzaF93cml0aW5nX3NwbGl0X2luZGV4KGlzdGF0ZSk7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgY2hhciAqdGVtcG9yYXJ5X3NoYXJlZGluZGV4OwoKc3RhdGljIHZvaWQgcmVtb3ZlX3RlbXBvcmFyeV9zaGFyZWRpbmRleCh2b2lkKQp7CglpZiAodGVtcG9yYXJ5X3NoYXJlZGluZGV4KSB7CgkJdW5saW5rX29yX3dhcm4odGVtcG9yYXJ5X3NoYXJlZGluZGV4KTsKCQlmcmVlKHRlbXBvcmFyeV9zaGFyZWRpbmRleCk7CgkJdGVtcG9yYXJ5X3NoYXJlZGluZGV4ID0gTlVMTDsKCX0KfQoKc3RhdGljIHZvaWQgcmVtb3ZlX3RlbXBvcmFyeV9zaGFyZWRpbmRleF9vbl9zaWduYWwoaW50IHNpZ25vKQp7CglyZW1vdmVfdGVtcG9yYXJ5X3NoYXJlZGluZGV4KCk7CglzaWdjaGFpbl9wb3Aoc2lnbm8pOwoJcmFpc2Uoc2lnbm8pOwp9CgpzdGF0aWMgaW50IHdyaXRlX3NoYXJlZF9pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwKCQkJICAgICAgc3RydWN0IGxvY2tfZmlsZSAqbG9jaywgdW5zaWduZWQgZmxhZ3MpCnsKCXN0cnVjdCBzcGxpdF9pbmRleCAqc2kgPSBpc3RhdGUtPnNwbGl0X2luZGV4OwoJc3RhdGljIGludCBpbnN0YWxsZWRfaGFuZGxlcjsKCWludCBmZCwgcmV0OwoKCXRlbXBvcmFyeV9zaGFyZWRpbmRleCA9IGdpdF9wYXRoZHVwKCJzaGFyZWRpbmRleF9YWFhYWFgiKTsKCWZkID0gbWtzdGVtcCh0ZW1wb3Jhcnlfc2hhcmVkaW5kZXgpOwoJaWYgKGZkIDwgMCkgewoJCWZyZWUodGVtcG9yYXJ5X3NoYXJlZGluZGV4KTsKCQl0ZW1wb3Jhcnlfc2hhcmVkaW5kZXggPSBOVUxMOwoJCWhhc2hjbHIoc2ktPmJhc2Vfc2hhMSk7CgkJcmV0dXJuIGRvX3dyaXRlX2xvY2tlZF9pbmRleChpc3RhdGUsIGxvY2ssIGZsYWdzKTsKCX0KCWlmICghaW5zdGFsbGVkX2hhbmRsZXIpIHsKCQlhdGV4aXQocmVtb3ZlX3RlbXBvcmFyeV9zaGFyZWRpbmRleCk7CgkJc2lnY2hhaW5fcHVzaF9jb21tb24ocmVtb3ZlX3RlbXBvcmFyeV9zaGFyZWRpbmRleF9vbl9zaWduYWwpOwoJfQoJbW92ZV9jYWNoZV90b19iYXNlX2luZGV4KGlzdGF0ZSk7CglyZXQgPSBkb193cml0ZV9pbmRleChzaS0+YmFzZSwgZmQsIDEpOwoJY2xvc2UoZmQpOwoJaWYgKHJldCkgewoJCXJlbW92ZV90ZW1wb3Jhcnlfc2hhcmVkaW5kZXgoKTsKCQlyZXR1cm4gcmV0OwoJfQoJcmV0ID0gcmVuYW1lKHRlbXBvcmFyeV9zaGFyZWRpbmRleCwKCQkgICAgIGdpdF9wYXRoKCJzaGFyZWRpbmRleC4lcyIsIHNoYTFfdG9faGV4KHNpLT5iYXNlLT5zaGExKSkpOwoJZnJlZSh0ZW1wb3Jhcnlfc2hhcmVkaW5kZXgpOwoJdGVtcG9yYXJ5X3NoYXJlZGluZGV4ID0gTlVMTDsKCWlmICghcmV0KQoJCWhhc2hjcHkoc2ktPmJhc2Vfc2hhMSwgc2ktPmJhc2UtPnNoYTEpOwoJcmV0dXJuIHJldDsKfQoKaW50IHdyaXRlX2xvY2tlZF9pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgc3RydWN0IGxvY2tfZmlsZSAqbG9jaywKCQkgICAgICAgdW5zaWduZWQgZmxhZ3MpCnsKCXN0cnVjdCBzcGxpdF9pbmRleCAqc2kgPSBpc3RhdGUtPnNwbGl0X2luZGV4OwoKCWlmICghc2kgfHwgYWx0ZXJuYXRlX2luZGV4X291dHB1dCB8fAoJICAgIChpc3RhdGUtPmNhY2hlX2NoYW5nZWQgJiB+RVhUTUFTSykpIHsKCQlpZiAoc2kpCgkJCWhhc2hjbHIoc2ktPmJhc2Vfc2hhMSk7CgkJcmV0dXJuIGRvX3dyaXRlX2xvY2tlZF9pbmRleChpc3RhdGUsIGxvY2ssIGZsYWdzKTsKCX0KCglpZiAoZ2V0ZW52KCJHSVRfVEVTVF9TUExJVF9JTkRFWCIpKSB7CgkJaW50IHYgPSBzaS0+YmFzZV9zaGExWzBdOwoJCWlmICgodiAmIDE1KSA8IDYpCgkJCWlzdGF0ZS0+Y2FjaGVfY2hhbmdlZCB8PSBTUExJVF9JTkRFWF9PUkRFUkVEOwoJfQoJaWYgKGlzdGF0ZS0+Y2FjaGVfY2hhbmdlZCAmIFNQTElUX0lOREVYX09SREVSRUQpIHsKCQlpbnQgcmV0ID0gd3JpdGVfc2hhcmVkX2luZGV4KGlzdGF0ZSwgbG9jaywgZmxhZ3MpOwoJCWlmIChyZXQpCgkJCXJldHVybiByZXQ7Cgl9CgoJcmV0dXJuIHdyaXRlX3NwbGl0X2luZGV4KGlzdGF0ZSwgbG9jaywgZmxhZ3MpOwp9CgovKgogKiBSZWFkIHRoZSBpbmRleCBmaWxlIHRoYXQgaXMgcG90ZW50aWFsbHkgdW5tZXJnZWQgaW50byBnaXZlbgogKiBpbmRleF9zdGF0ZSwgZHJvcHBpbmcgYW55IHVubWVyZ2VkIGVudHJpZXMuICBSZXR1cm5zIHRydWUgaWYKICogdGhlIGluZGV4IGlzIHVubWVyZ2VkLiAgQ2FsbGVycyB3aG8gd2FudCB0byByZWZ1c2UgdG8gd29yawogKiBmcm9tIGFuIHVubWVyZ2VkIHN0YXRlIGNhbiBjYWxsIHRoaXMgYW5kIGNoZWNrIGl0cyByZXR1cm4gdmFsdWUsCiAqIGluc3RlYWQgb2YgY2FsbGluZyByZWFkX2NhY2hlKCkuCiAqLwppbnQgcmVhZF9pbmRleF91bm1lcmdlZChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSkKewoJaW50IGk7CglpbnQgdW5tZXJnZWQgPSAwOwoKCXJlYWRfaW5kZXgoaXN0YXRlKTsKCWZvciAoaSA9IDA7IGkgPCBpc3RhdGUtPmNhY2hlX25yOyBpKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gaXN0YXRlLT5jYWNoZVtpXTsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKm5ld19jZTsKCQlpbnQgc2l6ZSwgbGVuOwoKCQlpZiAoIWNlX3N0YWdlKGNlKSkKCQkJY29udGludWU7CgkJdW5tZXJnZWQgPSAxOwoJCWxlbiA9IGNlX25hbWVsZW4oY2UpOwoJCXNpemUgPSBjYWNoZV9lbnRyeV9zaXplKGxlbik7CgkJbmV3X2NlID0geGNhbGxvYygxLCBzaXplKTsKCQltZW1jcHkobmV3X2NlLT5uYW1lLCBjZS0+bmFtZSwgbGVuKTsKCQluZXdfY2UtPmNlX2ZsYWdzID0gY3JlYXRlX2NlX2ZsYWdzKDApIHwgQ0VfQ09ORkxJQ1RFRDsKCQluZXdfY2UtPmNlX25hbWVsZW4gPSBsZW47CgkJbmV3X2NlLT5jZV9tb2RlID0gY2UtPmNlX21vZGU7CgkJaWYgKGFkZF9pbmRleF9lbnRyeShpc3RhdGUsIG5ld19jZSwgMCkpCgkJCXJldHVybiBlcnJvcigiJXM6IGNhbm5vdCBkcm9wIHRvIHN0YWdlICMwIiwKCQkJCSAgICAgbmV3X2NlLT5uYW1lKTsKCX0KCXJldHVybiB1bm1lcmdlZDsKfQoKLyoKICogUmV0dXJucyAxIGlmIHRoZSBwYXRoIGlzIGFuICJvdGhlciIgcGF0aCB3aXRoIHJlc3BlY3QgdG8KICogdGhlIGluZGV4OyB0aGF0IGlzLCB0aGUgcGF0aCBpcyBub3QgbWVudGlvbmVkIGluIHRoZSBpbmRleCBhdCBhbGwsCiAqIGVpdGhlciBhcyBhIGZpbGUsIGEgZGlyZWN0b3J5IHdpdGggc29tZSBmaWxlcyBpbiB0aGUgaW5kZXgsCiAqIG9yIGFzIGFuIHVubWVyZ2VkIGVudHJ5LgogKgogKiBXZSBoZWxwZnVsbHkgcmVtb3ZlIGEgdHJhaWxpbmcgIi8iIGZyb20gZGlyZWN0b3JpZXMgc28gdGhhdAogKiB0aGUgb3V0cHV0IG9mIHJlYWRfZGlyZWN0b3J5IGNhbiBiZSB1c2VkIGFzLWlzLgogKi8KaW50IGluZGV4X25hbWVfaXNfb3RoZXIoY29uc3Qgc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIGNvbnN0IGNoYXIgKm5hbWUsCgkJaW50IG5hbWVsZW4pCnsKCWludCBwb3M7CglpZiAobmFtZWxlbiAmJiBuYW1lW25hbWVsZW4gLSAxXSA9PSAnLycpCgkJbmFtZWxlbi0tOwoJcG9zID0gaW5kZXhfbmFtZV9wb3MoaXN0YXRlLCBuYW1lLCBuYW1lbGVuKTsKCWlmICgwIDw9IHBvcykKCQlyZXR1cm4gMDsJLyogZXhhY3QgbWF0Y2ggKi8KCXBvcyA9IC1wb3MgLSAxOwoJaWYgKHBvcyA8IGlzdGF0ZS0+Y2FjaGVfbnIpIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gaXN0YXRlLT5jYWNoZVtwb3NdOwoJCWlmIChjZV9uYW1lbGVuKGNlKSA9PSBuYW1lbGVuICYmCgkJICAgICFtZW1jbXAoY2UtPm5hbWUsIG5hbWUsIG5hbWVsZW4pKQoJCQlyZXR1cm4gMDsgLyogWXVwLCB0aGlzIG9uZSBleGlzdHMgdW5tZXJnZWQgKi8KCX0KCXJldHVybiAxOwp9Cgp2b2lkICpyZWFkX2Jsb2JfZGF0YV9mcm9tX2luZGV4KHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBjb25zdCBjaGFyICpwYXRoLCB1bnNpZ25lZCBsb25nICpzaXplKQp7CglpbnQgcG9zLCBsZW47Cgl1bnNpZ25lZCBsb25nIHN6OwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJdm9pZCAqZGF0YTsKCglsZW4gPSBzdHJsZW4ocGF0aCk7Cglwb3MgPSBpbmRleF9uYW1lX3Bvcyhpc3RhdGUsIHBhdGgsIGxlbik7CglpZiAocG9zIDwgMCkgewoJCS8qCgkJICogV2UgbWlnaHQgYmUgaW4gdGhlIG1pZGRsZSBvZiBhIG1lcmdlLCBpbiB3aGljaAoJCSAqIGNhc2Ugd2Ugd291bGQgcmVhZCBzdGFnZSAjMiAob3VycykuCgkJICovCgkJaW50IGk7CgkJZm9yIChpID0gLXBvcyAtIDE7CgkJICAgICAocG9zIDwgMCAmJiBpIDwgaXN0YXRlLT5jYWNoZV9uciAmJgoJCSAgICAgICFzdHJjbXAoaXN0YXRlLT5jYWNoZVtpXS0+bmFtZSwgcGF0aCkpOwoJCSAgICAgaSsrKQoJCQlpZiAoY2Vfc3RhZ2UoaXN0YXRlLT5jYWNoZVtpXSkgPT0gMikKCQkJCXBvcyA9IGk7Cgl9CglpZiAocG9zIDwgMCkKCQlyZXR1cm4gTlVMTDsKCWRhdGEgPSByZWFkX3NoYTFfZmlsZShpc3RhdGUtPmNhY2hlW3Bvc10tPnNoYTEsICZ0eXBlLCAmc3opOwoJaWYgKCFkYXRhIHx8IHR5cGUgIT0gT0JKX0JMT0IpIHsKCQlmcmVlKGRhdGEpOwoJCXJldHVybiBOVUxMOwoJfQoJaWYgKHNpemUpCgkJKnNpemUgPSBzejsKCXJldHVybiBkYXRhOwp9Cgp2b2lkIHN0YXRfdmFsaWRpdHlfY2xlYXIoc3RydWN0IHN0YXRfdmFsaWRpdHkgKnN2KQp7CglmcmVlKHN2LT5zZCk7Cglzdi0+c2QgPSBOVUxMOwp9CgppbnQgc3RhdF92YWxpZGl0eV9jaGVjayhzdHJ1Y3Qgc3RhdF92YWxpZGl0eSAqc3YsIGNvbnN0IGNoYXIgKnBhdGgpCnsKCXN0cnVjdCBzdGF0IHN0OwoKCWlmIChzdGF0KHBhdGgsICZzdCkgPCAwKQoJCXJldHVybiBzdi0+c2QgPT0gTlVMTDsKCWlmICghc3YtPnNkKQoJCXJldHVybiAwOwoJcmV0dXJuIFNfSVNSRUcoc3Quc3RfbW9kZSkgJiYgIW1hdGNoX3N0YXRfZGF0YShzdi0+c2QsICZzdCk7Cn0KCnZvaWQgc3RhdF92YWxpZGl0eV91cGRhdGUoc3RydWN0IHN0YXRfdmFsaWRpdHkgKnN2LCBpbnQgZmQpCnsKCXN0cnVjdCBzdGF0IHN0OwoKCWlmIChmc3RhdChmZCwgJnN0KSA8IDAgfHwgIVNfSVNSRUcoc3Quc3RfbW9kZSkpCgkJc3RhdF92YWxpZGl0eV9jbGVhcihzdik7CgllbHNlIHsKCQlpZiAoIXN2LT5zZCkKCQkJc3YtPnNkID0geGNhbGxvYygxLCBzaXplb2Yoc3RydWN0IHN0YXRfZGF0YSkpOwoJCWZpbGxfc3RhdF9kYXRhKHN2LT5zZCwgJnN0KTsKCX0KfQo=",
    "text": "/*\n * GIT - The information manager from hell\n *\n * Copyright (C) Linus Torvalds, 2005\n */\n#define NO_THE_INDEX_COMPATIBILITY_MACROS\n#include \"cache.h\"\n#include \"lockfile.h\"\n#include \"cache-tree.h\"\n#include \"refs.h\"\n#include \"dir.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"blob.h\"\n#include \"resolve-undo.h\"\n#include \"strbuf.h\"\n#include \"varint.h\"\n#include \"split-index.h\"\n#include \"sigchain.h\"\n#include \"utf8.h\"\n\nstatic struct cache_entry *refresh_cache_entry(struct cache_entry *ce,\n\t\t\t\t\t       unsigned int options);\n\n/* Mask for the name length in ce_flags in the on-disk index */\n\n#define CE_NAMEMASK  (0x0fff)\n\n/* Index extensions.\n *\n * The first letter should be 'A'..'Z' for extensions that are not\n * necessary for a correct operation (i.e. optimization data).\n * When new extensions are added that _needs_ to be understood in\n * order to correctly interpret the index file, pick character that\n * is outside the range, to cause the reader to abort.\n */\n\n#define CACHE_EXT(s) ( (s[0]<<24)|(s[1]<<16)|(s[2]<<8)|(s[3]) )\n#define CACHE_EXT_TREE 0x54524545\t/* \"TREE\" */\n#define CACHE_EXT_RESOLVE_UNDO 0x52455543 /* \"REUC\" */\n#define CACHE_EXT_LINK 0x6c696e6b\t  /* \"link\" */\n\n/* changes that can be kept in $GIT_DIR/index (basically all extensions) */\n#define EXTMASK (RESOLVE_UNDO_CHANGED | CACHE_TREE_CHANGED | \\\n\t\t CE_ENTRY_ADDED | CE_ENTRY_REMOVED | CE_ENTRY_CHANGED | \\\n\t\t SPLIT_INDEX_ORDERED)\n\nstruct index_state the_index;\nstatic const char *alternate_index_output;\n\nstatic void set_index_entry(struct index_state *istate, int nr, struct cache_entry *ce)\n{\n\tistate->cache[nr] = ce;\n\tadd_name_hash(istate, ce);\n}\n\nstatic void replace_index_entry(struct index_state *istate, int nr, struct cache_entry *ce)\n{\n\tstruct cache_entry *old = istate->cache[nr];\n\n\treplace_index_entry_in_base(istate, old, ce);\n\tremove_name_hash(istate, old);\n\tfree(old);\n\tset_index_entry(istate, nr, ce);\n\tce->ce_flags |= CE_UPDATE_IN_BASE;\n\tistate->cache_changed |= CE_ENTRY_CHANGED;\n}\n\nvoid rename_index_entry_at(struct index_state *istate, int nr, const char *new_name)\n{\n\tstruct cache_entry *old = istate->cache[nr], *new;\n\tint namelen = strlen(new_name);\n\n\tnew = xmalloc(cache_entry_size(namelen));\n\tcopy_cache_entry(new, old);\n\tnew->ce_flags &= ~CE_HASHED;\n\tnew->ce_namelen = namelen;\n\tnew->index = 0;\n\tmemcpy(new->name, new_name, namelen + 1);\n\n\tcache_tree_invalidate_path(istate, old->name);\n\tremove_index_entry_at(istate, nr);\n\tadd_index_entry(istate, new, ADD_CACHE_OK_TO_ADD|ADD_CACHE_OK_TO_REPLACE);\n}\n\nvoid fill_stat_data(struct stat_data *sd, struct stat *st)\n{\n\tsd->sd_ctime.sec = (unsigned int)st->st_ctime;\n\tsd->sd_mtime.sec = (unsigned int)st->st_mtime;\n\tsd->sd_ctime.nsec = ST_CTIME_NSEC(*st);\n\tsd->sd_mtime.nsec = ST_MTIME_NSEC(*st);\n\tsd->sd_dev = st->st_dev;\n\tsd->sd_ino = st->st_ino;\n\tsd->sd_uid = st->st_uid;\n\tsd->sd_gid = st->st_gid;\n\tsd->sd_size = st->st_size;\n}\n\nint match_stat_data(const struct stat_data *sd, struct stat *st)\n{\n\tint changed = 0;\n\n\tif (sd->sd_mtime.sec != (unsigned int)st->st_mtime)\n\t\tchanged |= MTIME_CHANGED;\n\tif (trust_ctime && check_stat &&\n\t    sd->sd_ctime.sec != (unsigned int)st->st_ctime)\n\t\tchanged |= CTIME_CHANGED;\n\n#ifdef USE_NSEC\n\tif (check_stat && sd->sd_mtime.nsec != ST_MTIME_NSEC(*st))\n\t\tchanged |= MTIME_CHANGED;\n\tif (trust_ctime && check_stat &&\n\t    sd->sd_ctime.nsec != ST_CTIME_NSEC(*st))\n\t\tchanged |= CTIME_CHANGED;\n#endif\n\n\tif (check_stat) {\n\t\tif (sd->sd_uid != (unsigned int) st->st_uid ||\n\t\t\tsd->sd_gid != (unsigned int) st->st_gid)\n\t\t\tchanged |= OWNER_CHANGED;\n\t\tif (sd->sd_ino != (unsigned int) st->st_ino)\n\t\t\tchanged |= INODE_CHANGED;\n\t}\n\n#ifdef USE_STDEV\n\t/*\n\t * st_dev breaks on network filesystems where different\n\t * clients will have different views of what \"device\"\n\t * the filesystem is on\n\t */\n\tif (check_stat && sd->sd_dev != (unsigned int) st->st_dev)\n\t\t\tchanged |= INODE_CHANGED;\n#endif\n\n\tif (sd->sd_size != (unsigned int) st->st_size)\n\t\tchanged |= DATA_CHANGED;\n\n\treturn changed;\n}\n\n/*\n * This only updates the \"non-critical\" parts of the directory\n * cache, ie the parts that aren't tracked by GIT, and only used\n * to validate the cache.\n */\nvoid fill_stat_cache_info(struct cache_entry *ce, struct stat *st)\n{\n\tfill_stat_data(&ce->ce_stat_data, st);\n\n\tif (assume_unchanged)\n\t\tce->ce_flags |= CE_VALID;\n\n\tif (S_ISREG(st->st_mode))\n\t\tce_mark_uptodate(ce);\n}\n\nstatic int ce_compare_data(const struct cache_entry *ce, struct stat *st)\n{\n\tint match = -1;\n\tint fd = open(ce->name, O_RDONLY);\n\n\tif (fd >= 0) {\n\t\tunsigned char sha1[20];\n\t\tif (!index_fd(sha1, fd, st, OBJ_BLOB, ce->name, 0))\n\t\t\tmatch = hashcmp(sha1, ce->sha1);\n\t\t/* index_fd() closed the file descriptor already */\n\t}\n\treturn match;\n}\n\nstatic int ce_compare_link(const struct cache_entry *ce, size_t expected_size)\n{\n\tint match = -1;\n\tvoid *buffer;\n\tunsigned long size;\n\tenum object_type type;\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tif (strbuf_readlink(&sb, ce->name, expected_size))\n\t\treturn -1;\n\n\tbuffer = read_sha1_file(ce->sha1, &type, &size);\n\tif (buffer) {\n\t\tif (size == sb.len)\n\t\t\tmatch = memcmp(buffer, sb.buf, size);\n\t\tfree(buffer);\n\t}\n\tstrbuf_release(&sb);\n\treturn match;\n}\n\nstatic int ce_compare_gitlink(const struct cache_entry *ce)\n{\n\tunsigned char sha1[20];\n\n\t/*\n\t * We don't actually require that the .git directory\n\t * under GITLINK directory be a valid git directory. It\n\t * might even be missing (in case nobody populated that\n\t * sub-project).\n\t *\n\t * If so, we consider it always to match.\n\t */\n\tif (resolve_gitlink_ref(ce->name, \"HEAD\", sha1) < 0)\n\t\treturn 0;\n\treturn hashcmp(sha1, ce->sha1);\n}\n\nstatic int ce_modified_check_fs(const struct cache_entry *ce, struct stat *st)\n{\n\tswitch (st->st_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tif (ce_compare_data(ce, st))\n\t\t\treturn DATA_CHANGED;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (ce_compare_link(ce, xsize_t(st->st_size)))\n\t\t\treturn DATA_CHANGED;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tif (S_ISGITLINK(ce->ce_mode))\n\t\t\treturn ce_compare_gitlink(ce) ? DATA_CHANGED : 0;\n\tdefault:\n\t\treturn TYPE_CHANGED;\n\t}\n\treturn 0;\n}\n\nstatic int ce_match_stat_basic(const struct cache_entry *ce, struct stat *st)\n{\n\tunsigned int changed = 0;\n\n\tif (ce->ce_flags & CE_REMOVE)\n\t\treturn MODE_CHANGED | DATA_CHANGED | TYPE_CHANGED;\n\n\tswitch (ce->ce_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tchanged |= !S_ISREG(st->st_mode) ? TYPE_CHANGED : 0;\n\t\t/* We consider only the owner x bit to be relevant for\n\t\t * \"mode changes\"\n\t\t */\n\t\tif (trust_executable_bit &&\n\t\t    (0100 & (ce->ce_mode ^ st->st_mode)))\n\t\t\tchanged |= MODE_CHANGED;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (!S_ISLNK(st->st_mode) &&\n\t\t    (has_symlinks || !S_ISREG(st->st_mode)))\n\t\t\tchanged |= TYPE_CHANGED;\n\t\tbreak;\n\tcase S_IFGITLINK:\n\t\t/* We ignore most of the st_xxx fields for gitlinks */\n\t\tif (!S_ISDIR(st->st_mode))\n\t\t\tchanged |= TYPE_CHANGED;\n\t\telse if (ce_compare_gitlink(ce))\n\t\t\tchanged |= DATA_CHANGED;\n\t\treturn changed;\n\tdefault:\n\t\tdie(\"internal error: ce_mode is %o\", ce->ce_mode);\n\t}\n\n\tchanged |= match_stat_data(&ce->ce_stat_data, st);\n\n\t/* Racily smudged entry? */\n\tif (!ce->ce_stat_data.sd_size) {\n\t\tif (!is_empty_blob_sha1(ce->sha1))\n\t\t\tchanged |= DATA_CHANGED;\n\t}\n\n\treturn changed;\n}\n\nstatic int is_racy_timestamp(const struct index_state *istate,\n\t\t\t     const struct cache_entry *ce)\n{\n\treturn (!S_ISGITLINK(ce->ce_mode) &&\n\t\tistate->timestamp.sec &&\n#ifdef USE_NSEC\n\t\t /* nanosecond timestamped files can also be racy! */\n\t\t(istate->timestamp.sec < ce->ce_stat_data.sd_mtime.sec ||\n\t\t (istate->timestamp.sec == ce->ce_stat_data.sd_mtime.sec &&\n\t\t  istate->timestamp.nsec <= ce->ce_stat_data.sd_mtime.nsec))\n#else\n\t\tistate->timestamp.sec <= ce->ce_stat_data.sd_mtime.sec\n#endif\n\t\t );\n}\n\nint ie_match_stat(const struct index_state *istate,\n\t\t  const struct cache_entry *ce, struct stat *st,\n\t\t  unsigned int options)\n{\n\tunsigned int changed;\n\tint ignore_valid = options & CE_MATCH_IGNORE_VALID;\n\tint ignore_skip_worktree = options & CE_MATCH_IGNORE_SKIP_WORKTREE;\n\tint assume_racy_is_modified = options & CE_MATCH_RACY_IS_DIRTY;\n\n\t/*\n\t * If it's marked as always valid in the index, it's\n\t * valid whatever the checked-out copy says.\n\t *\n\t * skip-worktree has the same effect with higher precedence\n\t */\n\tif (!ignore_skip_worktree && ce_skip_worktree(ce))\n\t\treturn 0;\n\tif (!ignore_valid && (ce->ce_flags & CE_VALID))\n\t\treturn 0;\n\n\t/*\n\t * Intent-to-add entries have not been added, so the index entry\n\t * by definition never matches what is in the work tree until it\n\t * actually gets added.\n\t */\n\tif (ce->ce_flags & CE_INTENT_TO_ADD)\n\t\treturn DATA_CHANGED | TYPE_CHANGED | MODE_CHANGED;\n\n\tchanged = ce_match_stat_basic(ce, st);\n\n\t/*\n\t * Within 1 second of this sequence:\n\t * \techo xyzzy >file && git-update-index --add file\n\t * running this command:\n\t * \techo frotz >file\n\t * would give a falsely clean cache entry.  The mtime and\n\t * length match the cache, and other stat fields do not change.\n\t *\n\t * We could detect this at update-index time (the cache entry\n\t * being registered/updated records the same time as \"now\")\n\t * and delay the return from git-update-index, but that would\n\t * effectively mean we can make at most one commit per second,\n\t * which is not acceptable.  Instead, we check cache entries\n\t * whose mtime are the same as the index file timestamp more\n\t * carefully than others.\n\t */\n\tif (!changed && is_racy_timestamp(istate, ce)) {\n\t\tif (assume_racy_is_modified)\n\t\t\tchanged |= DATA_CHANGED;\n\t\telse\n\t\t\tchanged |= ce_modified_check_fs(ce, st);\n\t}\n\n\treturn changed;\n}\n\nint ie_modified(const struct index_state *istate,\n\t\tconst struct cache_entry *ce,\n\t\tstruct stat *st, unsigned int options)\n{\n\tint changed, changed_fs;\n\n\tchanged = ie_match_stat(istate, ce, st, options);\n\tif (!changed)\n\t\treturn 0;\n\t/*\n\t * If the mode or type has changed, there's no point in trying\n\t * to refresh the entry - it's not going to match\n\t */\n\tif (changed & (MODE_CHANGED | TYPE_CHANGED))\n\t\treturn changed;\n\n\t/*\n\t * Immediately after read-tree or update-index --cacheinfo,\n\t * the length field is zero, as we have never even read the\n\t * lstat(2) information once, and we cannot trust DATA_CHANGED\n\t * returned by ie_match_stat() which in turn was returned by\n\t * ce_match_stat_basic() to signal that the filesize of the\n\t * blob changed.  We have to actually go to the filesystem to\n\t * see if the contents match, and if so, should answer \"unchanged\".\n\t *\n\t * The logic does not apply to gitlinks, as ce_match_stat_basic()\n\t * already has checked the actual HEAD from the filesystem in the\n\t * subproject.  If ie_match_stat() already said it is different,\n\t * then we know it is.\n\t */\n\tif ((changed & DATA_CHANGED) &&\n\t    (S_ISGITLINK(ce->ce_mode) || ce->ce_stat_data.sd_size != 0))\n\t\treturn changed;\n\n\tchanged_fs = ce_modified_check_fs(ce, st);\n\tif (changed_fs)\n\t\treturn changed | changed_fs;\n\treturn 0;\n}\n\nint base_name_compare(const char *name1, int len1, int mode1,\n\t\t      const char *name2, int len2, int mode2)\n{\n\tunsigned char c1, c2;\n\tint len = len1 < len2 ? len1 : len2;\n\tint cmp;\n\n\tcmp = memcmp(name1, name2, len);\n\tif (cmp)\n\t\treturn cmp;\n\tc1 = name1[len];\n\tc2 = name2[len];\n\tif (!c1 && S_ISDIR(mode1))\n\t\tc1 = '/';\n\tif (!c2 && S_ISDIR(mode2))\n\t\tc2 = '/';\n\treturn (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;\n}\n\n/*\n * df_name_compare() is identical to base_name_compare(), except it\n * compares conflicting directory/file entries as equal. Note that\n * while a directory name compares as equal to a regular file, they\n * then individually compare _differently_ to a filename that has\n * a dot after the basename (because '\\0' < '.' < '/').\n *\n * This is used by routines that want to traverse the git namespace\n * but then handle conflicting entries together when possible.\n */\nint df_name_compare(const char *name1, int len1, int mode1,\n\t\t    const char *name2, int len2, int mode2)\n{\n\tint len = len1 < len2 ? len1 : len2, cmp;\n\tunsigned char c1, c2;\n\n\tcmp = memcmp(name1, name2, len);\n\tif (cmp)\n\t\treturn cmp;\n\t/* Directories and files compare equal (same length, same name) */\n\tif (len1 == len2)\n\t\treturn 0;\n\tc1 = name1[len];\n\tif (!c1 && S_ISDIR(mode1))\n\t\tc1 = '/';\n\tc2 = name2[len];\n\tif (!c2 && S_ISDIR(mode2))\n\t\tc2 = '/';\n\tif (c1 == '/' && !c2)\n\t\treturn 0;\n\tif (c2 == '/' && !c1)\n\t\treturn 0;\n\treturn c1 - c2;\n}\n\nint name_compare(const char *name1, size_t len1, const char *name2, size_t len2)\n{\n\tsize_t min_len = (len1 < len2) ? len1 : len2;\n\tint cmp = memcmp(name1, name2, min_len);\n\tif (cmp)\n\t\treturn cmp;\n\tif (len1 < len2)\n\t\treturn -1;\n\tif (len1 > len2)\n\t\treturn 1;\n\treturn 0;\n}\n\nint cache_name_stage_compare(const char *name1, int len1, int stage1, const char *name2, int len2, int stage2)\n{\n\tint cmp;\n\n\tcmp = name_compare(name1, len1, name2, len2);\n\tif (cmp)\n\t\treturn cmp;\n\n\tif (stage1 < stage2)\n\t\treturn -1;\n\tif (stage1 > stage2)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int index_name_stage_pos(const struct index_state *istate, const char *name, int namelen, int stage)\n{\n\tint first, last;\n\n\tfirst = 0;\n\tlast = istate->cache_nr;\n\twhile (last > first) {\n\t\tint next = (last + first) >> 1;\n\t\tstruct cache_entry *ce = istate->cache[next];\n\t\tint cmp = cache_name_stage_compare(name, namelen, stage, ce->name, ce_namelen(ce), ce_stage(ce));\n\t\tif (!cmp)\n\t\t\treturn next;\n\t\tif (cmp < 0) {\n\t\t\tlast = next;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst = next+1;\n\t}\n\treturn -first-1;\n}\n\nint index_name_pos(const struct index_state *istate, const char *name, int namelen)\n{\n\treturn index_name_stage_pos(istate, name, namelen, 0);\n}\n\n/* Remove entry, return true if there are more entries to go.. */\nint remove_index_entry_at(struct index_state *istate, int pos)\n{\n\tstruct cache_entry *ce = istate->cache[pos];\n\n\trecord_resolve_undo(istate, ce);\n\tremove_name_hash(istate, ce);\n\tsave_or_free_index_entry(istate, ce);\n\tistate->cache_changed |= CE_ENTRY_REMOVED;\n\tistate->cache_nr--;\n\tif (pos >= istate->cache_nr)\n\t\treturn 0;\n\tmemmove(istate->cache + pos,\n\t\tistate->cache + pos + 1,\n\t\t(istate->cache_nr - pos) * sizeof(struct cache_entry *));\n\treturn 1;\n}\n\n/*\n * Remove all cache entries marked for removal, that is where\n * CE_REMOVE is set in ce_flags.  This is much more effective than\n * calling remove_index_entry_at() for each entry to be removed.\n */\nvoid remove_marked_cache_entries(struct index_state *istate)\n{\n\tstruct cache_entry **ce_array = istate->cache;\n\tunsigned int i, j;\n\n\tfor (i = j = 0; i < istate->cache_nr; i++) {\n\t\tif (ce_array[i]->ce_flags & CE_REMOVE) {\n\t\t\tremove_name_hash(istate, ce_array[i]);\n\t\t\tsave_or_free_index_entry(istate, ce_array[i]);\n\t\t}\n\t\telse\n\t\t\tce_array[j++] = ce_array[i];\n\t}\n\tif (j == istate->cache_nr)\n\t\treturn;\n\tistate->cache_changed |= CE_ENTRY_REMOVED;\n\tistate->cache_nr = j;\n}\n\nint remove_file_from_index(struct index_state *istate, const char *path)\n{\n\tint pos = index_name_pos(istate, path, strlen(path));\n\tif (pos < 0)\n\t\tpos = -pos-1;\n\tcache_tree_invalidate_path(istate, path);\n\twhile (pos < istate->cache_nr && !strcmp(istate->cache[pos]->name, path))\n\t\tremove_index_entry_at(istate, pos);\n\treturn 0;\n}\n\nstatic int compare_name(struct cache_entry *ce, const char *path, int namelen)\n{\n\treturn namelen != ce_namelen(ce) || memcmp(path, ce->name, namelen);\n}\n\nstatic int index_name_pos_also_unmerged(struct index_state *istate,\n\tconst char *path, int namelen)\n{\n\tint pos = index_name_pos(istate, path, namelen);\n\tstruct cache_entry *ce;\n\n\tif (pos >= 0)\n\t\treturn pos;\n\n\t/* maybe unmerged? */\n\tpos = -1 - pos;\n\tif (pos >= istate->cache_nr ||\n\t\t\tcompare_name((ce = istate->cache[pos]), path, namelen))\n\t\treturn -1;\n\n\t/* order of preference: stage 2, 1, 3 */\n\tif (ce_stage(ce) == 1 && pos + 1 < istate->cache_nr &&\n\t\t\tce_stage((ce = istate->cache[pos + 1])) == 2 &&\n\t\t\t!compare_name(ce, path, namelen))\n\t\tpos++;\n\treturn pos;\n}\n\nstatic int different_name(struct cache_entry *ce, struct cache_entry *alias)\n{\n\tint len = ce_namelen(ce);\n\treturn ce_namelen(alias) != len || memcmp(ce->name, alias->name, len);\n}\n\n/*\n * If we add a filename that aliases in the cache, we will use the\n * name that we already have - but we don't want to update the same\n * alias twice, because that implies that there were actually two\n * different files with aliasing names!\n *\n * So we use the CE_ADDED flag to verify that the alias was an old\n * one before we accept it as\n */\nstatic struct cache_entry *create_alias_ce(struct index_state *istate,\n\t\t\t\t\t   struct cache_entry *ce,\n\t\t\t\t\t   struct cache_entry *alias)\n{\n\tint len;\n\tstruct cache_entry *new;\n\n\tif (alias->ce_flags & CE_ADDED)\n\t\tdie(\"Will not add file alias '%s' ('%s' already exists in index)\", ce->name, alias->name);\n\n\t/* Ok, create the new entry using the name of the existing alias */\n\tlen = ce_namelen(alias);\n\tnew = xcalloc(1, cache_entry_size(len));\n\tmemcpy(new->name, alias->name, len);\n\tcopy_cache_entry(new, ce);\n\tsave_or_free_index_entry(istate, ce);\n\treturn new;\n}\n\nvoid set_object_name_for_intent_to_add_entry(struct cache_entry *ce)\n{\n\tunsigned char sha1[20];\n\tif (write_sha1_file(\"\", 0, blob_type, sha1))\n\t\tdie(\"cannot create an empty blob in the object database\");\n\thashcpy(ce->sha1, sha1);\n}\n\nint add_to_index(struct index_state *istate, const char *path, struct stat *st, int flags)\n{\n\tint size, namelen, was_same;\n\tmode_t st_mode = st->st_mode;\n\tstruct cache_entry *ce, *alias;\n\tunsigned ce_option = CE_MATCH_IGNORE_VALID|CE_MATCH_IGNORE_SKIP_WORKTREE|CE_MATCH_RACY_IS_DIRTY;\n\tint verbose = flags & (ADD_CACHE_VERBOSE | ADD_CACHE_PRETEND);\n\tint pretend = flags & ADD_CACHE_PRETEND;\n\tint intent_only = flags & ADD_CACHE_INTENT;\n\tint add_option = (ADD_CACHE_OK_TO_ADD|ADD_CACHE_OK_TO_REPLACE|\n\t\t\t  (intent_only ? ADD_CACHE_NEW_ONLY : 0));\n\n\tif (!S_ISREG(st_mode) && !S_ISLNK(st_mode) && !S_ISDIR(st_mode))\n\t\treturn error(\"%s: can only add regular files, symbolic links or git-directories\", path);\n\n\tnamelen = strlen(path);\n\tif (S_ISDIR(st_mode)) {\n\t\twhile (namelen && path[namelen-1] == '/')\n\t\t\tnamelen--;\n\t}\n\tsize = cache_entry_size(namelen);\n\tce = xcalloc(1, size);\n\tmemcpy(ce->name, path, namelen);\n\tce->ce_namelen = namelen;\n\tif (!intent_only)\n\t\tfill_stat_cache_info(ce, st);\n\telse\n\t\tce->ce_flags |= CE_INTENT_TO_ADD;\n\n\tif (trust_executable_bit && has_symlinks)\n\t\tce->ce_mode = create_ce_mode(st_mode);\n\telse {\n\t\t/* If there is an existing entry, pick the mode bits and type\n\t\t * from it, otherwise assume unexecutable regular file.\n\t\t */\n\t\tstruct cache_entry *ent;\n\t\tint pos = index_name_pos_also_unmerged(istate, path, namelen);\n\n\t\tent = (0 <= pos) ? istate->cache[pos] : NULL;\n\t\tce->ce_mode = ce_mode_from_stat(ent, st_mode);\n\t}\n\n\t/* When core.ignorecase=true, determine if a directory of the same name but differing\n\t * case already exists within the Git repository.  If it does, ensure the directory\n\t * case of the file being added to the repository matches (is folded into) the existing\n\t * entry's directory case.\n\t */\n\tif (ignore_case) {\n\t\tconst char *startPtr = ce->name;\n\t\tconst char *ptr = startPtr;\n\t\twhile (*ptr) {\n\t\t\twhile (*ptr && *ptr != '/')\n\t\t\t\t++ptr;\n\t\t\tif (*ptr == '/') {\n\t\t\t\tstruct cache_entry *foundce;\n\t\t\t\t++ptr;\n\t\t\t\tfoundce = index_dir_exists(istate, ce->name, ptr - ce->name - 1);\n\t\t\t\tif (foundce) {\n\t\t\t\t\tmemcpy((void *)startPtr, foundce->name + (startPtr - ce->name), ptr - startPtr);\n\t\t\t\t\tstartPtr = ptr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\talias = index_file_exists(istate, ce->name, ce_namelen(ce), ignore_case);\n\tif (alias && !ce_stage(alias) && !ie_match_stat(istate, alias, st, ce_option)) {\n\t\t/* Nothing changed, really */\n\t\tif (!S_ISGITLINK(alias->ce_mode))\n\t\t\tce_mark_uptodate(alias);\n\t\talias->ce_flags |= CE_ADDED;\n\n\t\tfree(ce);\n\t\treturn 0;\n\t}\n\tif (!intent_only) {\n\t\tif (index_path(ce->sha1, path, st, HASH_WRITE_OBJECT)) {\n\t\t\tfree(ce);\n\t\t\treturn error(\"unable to index file %s\", path);\n\t\t}\n\t} else\n\t\tset_object_name_for_intent_to_add_entry(ce);\n\n\tif (ignore_case && alias && different_name(ce, alias))\n\t\tce = create_alias_ce(istate, ce, alias);\n\tce->ce_flags |= CE_ADDED;\n\n\t/* It was suspected to be racily clean, but it turns out to be Ok */\n\twas_same = (alias &&\n\t\t    !ce_stage(alias) &&\n\t\t    !hashcmp(alias->sha1, ce->sha1) &&\n\t\t    ce->ce_mode == alias->ce_mode);\n\n\tif (pretend)\n\t\tfree(ce);\n\telse if (add_index_entry(istate, ce, add_option)) {\n\t\tfree(ce);\n\t\treturn error(\"unable to add %s to index\", path);\n\t}\n\tif (verbose && !was_same)\n\t\tprintf(\"add '%s'\\n\", path);\n\treturn 0;\n}\n\nint add_file_to_index(struct index_state *istate, const char *path, int flags)\n{\n\tstruct stat st;\n\tif (lstat(path, &st))\n\t\tdie_errno(\"unable to stat '%s'\", path);\n\treturn add_to_index(istate, path, &st, flags);\n}\n\nstruct cache_entry *make_cache_entry(unsigned int mode,\n\t\tconst unsigned char *sha1, const char *path, int stage,\n\t\tunsigned int refresh_options)\n{\n\tint size, len;\n\tstruct cache_entry *ce, *ret;\n\n\tif (!verify_path(path)) {\n\t\terror(\"Invalid path '%s'\", path);\n\t\treturn NULL;\n\t}\n\n\tlen = strlen(path);\n\tsize = cache_entry_size(len);\n\tce = xcalloc(1, size);\n\n\thashcpy(ce->sha1, sha1);\n\tmemcpy(ce->name, path, len);\n\tce->ce_flags = create_ce_flags(stage);\n\tce->ce_namelen = len;\n\tce->ce_mode = create_ce_mode(mode);\n\n\tret = refresh_cache_entry(ce, refresh_options);\n\tif (ret != ce)\n\t\tfree(ce);\n\treturn ret;\n}\n\nint ce_same_name(const struct cache_entry *a, const struct cache_entry *b)\n{\n\tint len = ce_namelen(a);\n\treturn ce_namelen(b) == len && !memcmp(a->name, b->name, len);\n}\n\n/*\n * We fundamentally don't like some paths: we don't want\n * dot or dot-dot anywhere, and for obvious reasons don't\n * want to recurse into \".git\" either.\n *\n * Also, we don't want double slashes or slashes at the\n * end that can make pathnames ambiguous.\n */\nstatic int verify_dotfile(const char *rest)\n{\n\t/*\n\t * The first character was '.', but that\n\t * has already been discarded, we now test\n\t * the rest.\n\t */\n\n\t/* \".\" is not allowed */\n\tif (*rest == '\\0' || is_dir_sep(*rest))\n\t\treturn 0;\n\n\tswitch (*rest) {\n\t/*\n\t * \".git\" followed by  NUL or slash is bad. This\n\t * shares the path end test with the \"..\" case.\n\t */\n\tcase 'g':\n\tcase 'G':\n\t\tif (rest[1] != 'i' && rest[1] != 'I')\n\t\t\tbreak;\n\t\tif (rest[2] != 't' && rest[2] != 'T')\n\t\t\tbreak;\n\t\trest += 2;\n\t/* fallthrough */\n\tcase '.':\n\t\tif (rest[1] == '\\0' || is_dir_sep(rest[1]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint verify_path(const char *path)\n{\n\tchar c;\n\n\tif (has_dos_drive_prefix(path))\n\t\treturn 0;\n\n\tgoto inside;\n\tfor (;;) {\n\t\tif (!c)\n\t\t\treturn 1;\n\t\tif (is_dir_sep(c)) {\ninside:\n\t\t\tif (protect_hfs && is_hfs_dotgit(path))\n\t\t\t\treturn 0;\n\t\t\tif (protect_ntfs && is_ntfs_dotgit(path))\n\t\t\t\treturn 0;\n\t\t\tc = *path++;\n\t\t\tif ((c == '.' && !verify_dotfile(path)) ||\n\t\t\t    is_dir_sep(c) || c == '\\0')\n\t\t\t\treturn 0;\n\t\t}\n\t\tc = *path++;\n\t}\n}\n\n/*\n * Do we have another file that has the beginning components being a\n * proper superset of the name we're trying to add?\n */\nstatic int has_file_name(struct index_state *istate,\n\t\t\t const struct cache_entry *ce, int pos, int ok_to_replace)\n{\n\tint retval = 0;\n\tint len = ce_namelen(ce);\n\tint stage = ce_stage(ce);\n\tconst char *name = ce->name;\n\n\twhile (pos < istate->cache_nr) {\n\t\tstruct cache_entry *p = istate->cache[pos++];\n\n\t\tif (len >= ce_namelen(p))\n\t\t\tbreak;\n\t\tif (memcmp(name, p->name, len))\n\t\t\tbreak;\n\t\tif (ce_stage(p) != stage)\n\t\t\tcontinue;\n\t\tif (p->name[len] != '/')\n\t\t\tcontinue;\n\t\tif (p->ce_flags & CE_REMOVE)\n\t\t\tcontinue;\n\t\tretval = -1;\n\t\tif (!ok_to_replace)\n\t\t\tbreak;\n\t\tremove_index_entry_at(istate, --pos);\n\t}\n\treturn retval;\n}\n\n/*\n * Do we have another file with a pathname that is a proper\n * subset of the name we're trying to add?\n */\nstatic int has_dir_name(struct index_state *istate,\n\t\t\tconst struct cache_entry *ce, int pos, int ok_to_replace)\n{\n\tint retval = 0;\n\tint stage = ce_stage(ce);\n\tconst char *name = ce->name;\n\tconst char *slash = name + ce_namelen(ce);\n\n\tfor (;;) {\n\t\tint len;\n\n\t\tfor (;;) {\n\t\t\tif (*--slash == '/')\n\t\t\t\tbreak;\n\t\t\tif (slash <= ce->name)\n\t\t\t\treturn retval;\n\t\t}\n\t\tlen = slash - name;\n\n\t\tpos = index_name_stage_pos(istate, name, len, stage);\n\t\tif (pos >= 0) {\n\t\t\t/*\n\t\t\t * Found one, but not so fast.  This could\n\t\t\t * be a marker that says \"I was here, but\n\t\t\t * I am being removed\".  Such an entry is\n\t\t\t * not a part of the resulting tree, and\n\t\t\t * it is Ok to have a directory at the same\n\t\t\t * path.\n\t\t\t */\n\t\t\tif (!(istate->cache[pos]->ce_flags & CE_REMOVE)) {\n\t\t\t\tretval = -1;\n\t\t\t\tif (!ok_to_replace)\n\t\t\t\t\tbreak;\n\t\t\t\tremove_index_entry_at(istate, pos);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tpos = -pos-1;\n\n\t\t/*\n\t\t * Trivial optimization: if we find an entry that\n\t\t * already matches the sub-directory, then we know\n\t\t * we're ok, and we can exit.\n\t\t */\n\t\twhile (pos < istate->cache_nr) {\n\t\t\tstruct cache_entry *p = istate->cache[pos];\n\t\t\tif ((ce_namelen(p) <= len) ||\n\t\t\t    (p->name[len] != '/') ||\n\t\t\t    memcmp(p->name, name, len))\n\t\t\t\tbreak; /* not our subdirectory */\n\t\t\tif (ce_stage(p) == stage && !(p->ce_flags & CE_REMOVE))\n\t\t\t\t/*\n\t\t\t\t * p is at the same stage as our entry, and\n\t\t\t\t * is a subdirectory of what we are looking\n\t\t\t\t * at, so we cannot have conflicts at our\n\t\t\t\t * level or anything shorter.\n\t\t\t\t */\n\t\t\t\treturn retval;\n\t\t\tpos++;\n\t\t}\n\t}\n\treturn retval;\n}\n\n/* We may be in a situation where we already have path/file and path\n * is being added, or we already have path and path/file is being\n * added.  Either one would result in a nonsense tree that has path\n * twice when git-write-tree tries to write it out.  Prevent it.\n *\n * If ok-to-replace is specified, we remove the conflicting entries\n * from the cache so the caller should recompute the insert position.\n * When this happens, we return non-zero.\n */\nstatic int check_file_directory_conflict(struct index_state *istate,\n\t\t\t\t\t const struct cache_entry *ce,\n\t\t\t\t\t int pos, int ok_to_replace)\n{\n\tint retval;\n\n\t/*\n\t * When ce is an \"I am going away\" entry, we allow it to be added\n\t */\n\tif (ce->ce_flags & CE_REMOVE)\n\t\treturn 0;\n\n\t/*\n\t * We check if the path is a sub-path of a subsequent pathname\n\t * first, since removing those will not change the position\n\t * in the array.\n\t */\n\tretval = has_file_name(istate, ce, pos, ok_to_replace);\n\n\t/*\n\t * Then check if the path might have a clashing sub-directory\n\t * before it.\n\t */\n\treturn retval + has_dir_name(istate, ce, pos, ok_to_replace);\n}\n\nstatic int add_index_entry_with_check(struct index_state *istate, struct cache_entry *ce, int option)\n{\n\tint pos;\n\tint ok_to_add = option & ADD_CACHE_OK_TO_ADD;\n\tint ok_to_replace = option & ADD_CACHE_OK_TO_REPLACE;\n\tint skip_df_check = option & ADD_CACHE_SKIP_DFCHECK;\n\tint new_only = option & ADD_CACHE_NEW_ONLY;\n\n\tif (!(option & ADD_CACHE_KEEP_CACHE_TREE))\n\t\tcache_tree_invalidate_path(istate, ce->name);\n\tpos = index_name_stage_pos(istate, ce->name, ce_namelen(ce), ce_stage(ce));\n\n\t/* existing match? Just replace it. */\n\tif (pos >= 0) {\n\t\tif (!new_only)\n\t\t\treplace_index_entry(istate, pos, ce);\n\t\treturn 0;\n\t}\n\tpos = -pos-1;\n\n\t/*\n\t * Inserting a merged entry (\"stage 0\") into the index\n\t * will always replace all non-merged entries..\n\t */\n\tif (pos < istate->cache_nr && ce_stage(ce) == 0) {\n\t\twhile (ce_same_name(istate->cache[pos], ce)) {\n\t\t\tok_to_add = 1;\n\t\t\tif (!remove_index_entry_at(istate, pos))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ok_to_add)\n\t\treturn -1;\n\tif (!verify_path(ce->name))\n\t\treturn error(\"Invalid path '%s'\", ce->name);\n\n\tif (!skip_df_check &&\n\t    check_file_directory_conflict(istate, ce, pos, ok_to_replace)) {\n\t\tif (!ok_to_replace)\n\t\t\treturn error(\"'%s' appears as both a file and as a directory\",\n\t\t\t\t     ce->name);\n\t\tpos = index_name_stage_pos(istate, ce->name, ce_namelen(ce), ce_stage(ce));\n\t\tpos = -pos-1;\n\t}\n\treturn pos + 1;\n}\n\nint add_index_entry(struct index_state *istate, struct cache_entry *ce, int option)\n{\n\tint pos;\n\n\tif (option & ADD_CACHE_JUST_APPEND)\n\t\tpos = istate->cache_nr;\n\telse {\n\t\tint ret;\n\t\tret = add_index_entry_with_check(istate, ce, option);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t\tpos = ret - 1;\n\t}\n\n\t/* Make sure the array is big enough .. */\n\tALLOC_GROW(istate->cache, istate->cache_nr + 1, istate->cache_alloc);\n\n\t/* Add it in.. */\n\tistate->cache_nr++;\n\tif (istate->cache_nr > pos + 1)\n\t\tmemmove(istate->cache + pos + 1,\n\t\t\tistate->cache + pos,\n\t\t\t(istate->cache_nr - pos - 1) * sizeof(ce));\n\tset_index_entry(istate, pos, ce);\n\tistate->cache_changed |= CE_ENTRY_ADDED;\n\treturn 0;\n}\n\n/*\n * \"refresh\" does not calculate a new sha1 file or bring the\n * cache up-to-date for mode/content changes. But what it\n * _does_ do is to \"re-match\" the stat information of a file\n * with the cache, so that you can refresh the cache for a\n * file that hasn't been changed but where the stat entry is\n * out of date.\n *\n * For example, you'd want to do this after doing a \"git-read-tree\",\n * to link up the stat cache details with the proper files.\n */\nstatic struct cache_entry *refresh_cache_ent(struct index_state *istate,\n\t\t\t\t\t     struct cache_entry *ce,\n\t\t\t\t\t     unsigned int options, int *err,\n\t\t\t\t\t     int *changed_ret)\n{\n\tstruct stat st;\n\tstruct cache_entry *updated;\n\tint changed, size;\n\tint refresh = options & CE_MATCH_REFRESH;\n\tint ignore_valid = options & CE_MATCH_IGNORE_VALID;\n\tint ignore_skip_worktree = options & CE_MATCH_IGNORE_SKIP_WORKTREE;\n\tint ignore_missing = options & CE_MATCH_IGNORE_MISSING;\n\n\tif (!refresh || ce_uptodate(ce))\n\t\treturn ce;\n\n\t/*\n\t * CE_VALID or CE_SKIP_WORKTREE means the user promised us\n\t * that the change to the work tree does not matter and told\n\t * us not to worry.\n\t */\n\tif (!ignore_skip_worktree && ce_skip_worktree(ce)) {\n\t\tce_mark_uptodate(ce);\n\t\treturn ce;\n\t}\n\tif (!ignore_valid && (ce->ce_flags & CE_VALID)) {\n\t\tce_mark_uptodate(ce);\n\t\treturn ce;\n\t}\n\n\tif (has_symlink_leading_path(ce->name, ce_namelen(ce))) {\n\t\tif (ignore_missing)\n\t\t\treturn ce;\n\t\tif (err)\n\t\t\t*err = ENOENT;\n\t\treturn NULL;\n\t}\n\n\tif (lstat(ce->name, &st) < 0) {\n\t\tif (ignore_missing && errno == ENOENT)\n\t\t\treturn ce;\n\t\tif (err)\n\t\t\t*err = errno;\n\t\treturn NULL;\n\t}\n\n\tchanged = ie_match_stat(istate, ce, &st, options);\n\tif (changed_ret)\n\t\t*changed_ret = changed;\n\tif (!changed) {\n\t\t/*\n\t\t * The path is unchanged.  If we were told to ignore\n\t\t * valid bit, then we did the actual stat check and\n\t\t * found that the entry is unmodified.  If the entry\n\t\t * is not marked VALID, this is the place to mark it\n\t\t * valid again, under \"assume unchanged\" mode.\n\t\t */\n\t\tif (ignore_valid && assume_unchanged &&\n\t\t    !(ce->ce_flags & CE_VALID))\n\t\t\t; /* mark this one VALID again */\n\t\telse {\n\t\t\t/*\n\t\t\t * We do not mark the index itself \"modified\"\n\t\t\t * because CE_UPTODATE flag is in-core only;\n\t\t\t * we are not going to write this change out.\n\t\t\t */\n\t\t\tif (!S_ISGITLINK(ce->ce_mode))\n\t\t\t\tce_mark_uptodate(ce);\n\t\t\treturn ce;\n\t\t}\n\t}\n\n\tif (ie_modified(istate, ce, &st, options)) {\n\t\tif (err)\n\t\t\t*err = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tsize = ce_size(ce);\n\tupdated = xmalloc(size);\n\tmemcpy(updated, ce, size);\n\tfill_stat_cache_info(updated, &st);\n\t/*\n\t * If ignore_valid is not set, we should leave CE_VALID bit\n\t * alone.  Otherwise, paths marked with --no-assume-unchanged\n\t * (i.e. things to be edited) will reacquire CE_VALID bit\n\t * automatically, which is not really what we want.\n\t */\n\tif (!ignore_valid && assume_unchanged &&\n\t    !(ce->ce_flags & CE_VALID))\n\t\tupdated->ce_flags &= ~CE_VALID;\n\n\t/* istate->cache_changed is updated in the caller */\n\treturn updated;\n}\n\nstatic void show_file(const char * fmt, const char * name, int in_porcelain,\n\t\t      int * first, const char *header_msg)\n{\n\tif (in_porcelain && *first && header_msg) {\n\t\tprintf(\"%s\\n\", header_msg);\n\t\t*first = 0;\n\t}\n\tprintf(fmt, name);\n}\n\nint refresh_index(struct index_state *istate, unsigned int flags,\n\t\t  const struct pathspec *pathspec,\n\t\t  char *seen, const char *header_msg)\n{\n\tint i;\n\tint has_errors = 0;\n\tint really = (flags & REFRESH_REALLY) != 0;\n\tint allow_unmerged = (flags & REFRESH_UNMERGED) != 0;\n\tint quiet = (flags & REFRESH_QUIET) != 0;\n\tint not_new = (flags & REFRESH_IGNORE_MISSING) != 0;\n\tint ignore_submodules = (flags & REFRESH_IGNORE_SUBMODULES) != 0;\n\tint first = 1;\n\tint in_porcelain = (flags & REFRESH_IN_PORCELAIN);\n\tunsigned int options = (CE_MATCH_REFRESH |\n\t\t\t\t(really ? CE_MATCH_IGNORE_VALID : 0) |\n\t\t\t\t(not_new ? CE_MATCH_IGNORE_MISSING : 0));\n\tconst char *modified_fmt;\n\tconst char *deleted_fmt;\n\tconst char *typechange_fmt;\n\tconst char *added_fmt;\n\tconst char *unmerged_fmt;\n\n\tmodified_fmt = (in_porcelain ? \"M\\t%s\\n\" : \"%s: needs update\\n\");\n\tdeleted_fmt = (in_porcelain ? \"D\\t%s\\n\" : \"%s: needs update\\n\");\n\ttypechange_fmt = (in_porcelain ? \"T\\t%s\\n\" : \"%s needs update\\n\");\n\tadded_fmt = (in_porcelain ? \"A\\t%s\\n\" : \"%s needs update\\n\");\n\tunmerged_fmt = (in_porcelain ? \"U\\t%s\\n\" : \"%s: needs merge\\n\");\n\tfor (i = 0; i < istate->cache_nr; i++) {\n\t\tstruct cache_entry *ce, *new;\n\t\tint cache_errno = 0;\n\t\tint changed = 0;\n\t\tint filtered = 0;\n\n\t\tce = istate->cache[i];\n\t\tif (ignore_submodules && S_ISGITLINK(ce->ce_mode))\n\t\t\tcontinue;\n\n\t\tif (pathspec && !ce_path_match(ce, pathspec, seen))\n\t\t\tfiltered = 1;\n\n\t\tif (ce_stage(ce)) {\n\t\t\twhile ((i < istate->cache_nr) &&\n\t\t\t       ! strcmp(istate->cache[i]->name, ce->name))\n\t\t\t\ti++;\n\t\t\ti--;\n\t\t\tif (allow_unmerged)\n\t\t\t\tcontinue;\n\t\t\tif (!filtered)\n\t\t\t\tshow_file(unmerged_fmt, ce->name, in_porcelain,\n\t\t\t\t\t  &first, header_msg);\n\t\t\thas_errors = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filtered)\n\t\t\tcontinue;\n\n\t\tnew = refresh_cache_ent(istate, ce, options, &cache_errno, &changed);\n\t\tif (new == ce)\n\t\t\tcontinue;\n\t\tif (!new) {\n\t\t\tconst char *fmt;\n\n\t\t\tif (really && cache_errno == EINVAL) {\n\t\t\t\t/* If we are doing --really-refresh that\n\t\t\t\t * means the index is not valid anymore.\n\t\t\t\t */\n\t\t\t\tce->ce_flags &= ~CE_VALID;\n\t\t\t\tce->ce_flags |= CE_UPDATE_IN_BASE;\n\t\t\t\tistate->cache_changed |= CE_ENTRY_CHANGED;\n\t\t\t}\n\t\t\tif (quiet)\n\t\t\t\tcontinue;\n\n\t\t\tif (cache_errno == ENOENT)\n\t\t\t\tfmt = deleted_fmt;\n\t\t\telse if (ce->ce_flags & CE_INTENT_TO_ADD)\n\t\t\t\tfmt = added_fmt; /* must be before other checks */\n\t\t\telse if (changed & TYPE_CHANGED)\n\t\t\t\tfmt = typechange_fmt;\n\t\t\telse\n\t\t\t\tfmt = modified_fmt;\n\t\t\tshow_file(fmt,\n\t\t\t\t  ce->name, in_porcelain, &first, header_msg);\n\t\t\thas_errors = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\treplace_index_entry(istate, i, new);\n\t}\n\treturn has_errors;\n}\n\nstatic struct cache_entry *refresh_cache_entry(struct cache_entry *ce,\n\t\t\t\t\t       unsigned int options)\n{\n\treturn refresh_cache_ent(&the_index, ce, options, NULL, NULL);\n}\n\n\n/*****************************************************************\n * Index File I/O\n *****************************************************************/\n\n#define INDEX_FORMAT_DEFAULT 3\n\nstatic unsigned int get_index_format_default(void)\n{\n\tchar *envversion = getenv(\"GIT_INDEX_VERSION\");\n\tchar *endp;\n\tint value;\n\tunsigned int version = INDEX_FORMAT_DEFAULT;\n\n\tif (!envversion) {\n\t\tif (!git_config_get_int(\"index.version\", &value))\n\t\t\tversion = value;\n\t\tif (version < INDEX_FORMAT_LB || INDEX_FORMAT_UB < version) {\n\t\t\twarning(_(\"index.version set, but the value is invalid.\\n\"\n\t\t\t\t  \"Using version %i\"), INDEX_FORMAT_DEFAULT);\n\t\t\treturn INDEX_FORMAT_DEFAULT;\n\t\t}\n\t\treturn version;\n\t}\n\n\tversion = strtoul(envversion, &endp, 10);\n\tif (*endp ||\n\t    version < INDEX_FORMAT_LB || INDEX_FORMAT_UB < version) {\n\t\twarning(_(\"GIT_INDEX_VERSION set, but the value is invalid.\\n\"\n\t\t\t  \"Using version %i\"), INDEX_FORMAT_DEFAULT);\n\t\tversion = INDEX_FORMAT_DEFAULT;\n\t}\n\treturn version;\n}\n\n/*\n * dev/ino/uid/gid/size are also just tracked to the low 32 bits\n * Again - this is just a (very strong in practice) heuristic that\n * the inode hasn't changed.\n *\n * We save the fields in big-endian order to allow using the\n * index file over NFS transparently.\n */\nstruct ondisk_cache_entry {\n\tstruct cache_time ctime;\n\tstruct cache_time mtime;\n\tuint32_t dev;\n\tuint32_t ino;\n\tuint32_t mode;\n\tuint32_t uid;\n\tuint32_t gid;\n\tuint32_t size;\n\tunsigned char sha1[20];\n\tuint16_t flags;\n\tchar name[FLEX_ARRAY]; /* more */\n};\n\n/*\n * This struct is used when CE_EXTENDED bit is 1\n * The struct must match ondisk_cache_entry exactly from\n * ctime till flags\n */\nstruct ondisk_cache_entry_extended {\n\tstruct cache_time ctime;\n\tstruct cache_time mtime;\n\tuint32_t dev;\n\tuint32_t ino;\n\tuint32_t mode;\n\tuint32_t uid;\n\tuint32_t gid;\n\tuint32_t size;\n\tunsigned char sha1[20];\n\tuint16_t flags;\n\tuint16_t flags2;\n\tchar name[FLEX_ARRAY]; /* more */\n};\n\n/* These are only used for v3 or lower */\n#define align_flex_name(STRUCT,len) ((offsetof(struct STRUCT,name) + (len) + 8) & ~7)\n#define ondisk_cache_entry_size(len) align_flex_name(ondisk_cache_entry,len)\n#define ondisk_cache_entry_extended_size(len) align_flex_name(ondisk_cache_entry_extended,len)\n#define ondisk_ce_size(ce) (((ce)->ce_flags & CE_EXTENDED) ? \\\n\t\t\t    ondisk_cache_entry_extended_size(ce_namelen(ce)) : \\\n\t\t\t    ondisk_cache_entry_size(ce_namelen(ce)))\n\nstatic int verify_hdr(struct cache_header *hdr, unsigned long size)\n{\n\tgit_SHA_CTX c;\n\tunsigned char sha1[20];\n\tint hdr_version;\n\n\tif (hdr->hdr_signature != htonl(CACHE_SIGNATURE))\n\t\treturn error(\"bad signature\");\n\thdr_version = ntohl(hdr->hdr_version);\n\tif (hdr_version < INDEX_FORMAT_LB || INDEX_FORMAT_UB < hdr_version)\n\t\treturn error(\"bad index version %d\", hdr_version);\n\tgit_SHA1_Init(&c);\n\tgit_SHA1_Update(&c, hdr, size - 20);\n\tgit_SHA1_Final(sha1, &c);\n\tif (hashcmp(sha1, (unsigned char *)hdr + size - 20))\n\t\treturn error(\"bad index file sha1 signature\");\n\treturn 0;\n}\n\nstatic int read_index_extension(struct index_state *istate,\n\t\t\t\tconst char *ext, void *data, unsigned long sz)\n{\n\tswitch (CACHE_EXT(ext)) {\n\tcase CACHE_EXT_TREE:\n\t\tistate->cache_tree = cache_tree_read(data, sz);\n\t\tbreak;\n\tcase CACHE_EXT_RESOLVE_UNDO:\n\t\tistate->resolve_undo = resolve_undo_read(data, sz);\n\t\tbreak;\n\tcase CACHE_EXT_LINK:\n\t\tif (read_link_extension(istate, data, sz))\n\t\t\treturn -1;\n\t\tbreak;\n\tdefault:\n\t\tif (*ext < 'A' || 'Z' < *ext)\n\t\t\treturn error(\"index uses %.4s extension, which we do not understand\",\n\t\t\t\t     ext);\n\t\tfprintf(stderr, \"ignoring %.4s extension\\n\", ext);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint hold_locked_index(struct lock_file *lk, int die_on_error)\n{\n\treturn hold_lock_file_for_update(lk, get_index_file(),\n\t\t\t\t\t die_on_error\n\t\t\t\t\t ? LOCK_DIE_ON_ERROR\n\t\t\t\t\t : 0);\n}\n\nint read_index(struct index_state *istate)\n{\n\treturn read_index_from(istate, get_index_file());\n}\n\nstatic struct cache_entry *cache_entry_from_ondisk(struct ondisk_cache_entry *ondisk,\n\t\t\t\t\t\t   unsigned int flags,\n\t\t\t\t\t\t   const char *name,\n\t\t\t\t\t\t   size_t len)\n{\n\tstruct cache_entry *ce = xmalloc(cache_entry_size(len));\n\n\tce->ce_stat_data.sd_ctime.sec = get_be32(&ondisk->ctime.sec);\n\tce->ce_stat_data.sd_mtime.sec = get_be32(&ondisk->mtime.sec);\n\tce->ce_stat_data.sd_ctime.nsec = get_be32(&ondisk->ctime.nsec);\n\tce->ce_stat_data.sd_mtime.nsec = get_be32(&ondisk->mtime.nsec);\n\tce->ce_stat_data.sd_dev   = get_be32(&ondisk->dev);\n\tce->ce_stat_data.sd_ino   = get_be32(&ondisk->ino);\n\tce->ce_mode  = get_be32(&ondisk->mode);\n\tce->ce_stat_data.sd_uid   = get_be32(&ondisk->uid);\n\tce->ce_stat_data.sd_gid   = get_be32(&ondisk->gid);\n\tce->ce_stat_data.sd_size  = get_be32(&ondisk->size);\n\tce->ce_flags = flags & ~CE_NAMEMASK;\n\tce->ce_namelen = len;\n\tce->index = 0;\n\thashcpy(ce->sha1, ondisk->sha1);\n\tmemcpy(ce->name, name, len);\n\tce->name[len] = '\\0';\n\treturn ce;\n}\n\n/*\n * Adjacent cache entries tend to share the leading paths, so it makes\n * sense to only store the differences in later entries.  In the v4\n * on-disk format of the index, each on-disk cache entry stores the\n * number of bytes to be stripped from the end of the previous name,\n * and the bytes to append to the result, to come up with its name.\n */\nstatic unsigned long expand_name_field(struct strbuf *name, const char *cp_)\n{\n\tconst unsigned char *ep, *cp = (const unsigned char *)cp_;\n\tsize_t len = decode_varint(&cp);\n\n\tif (name->len < len)\n\t\tdie(\"malformed name field in the index\");\n\tstrbuf_remove(name, name->len - len, len);\n\tfor (ep = cp; *ep; ep++)\n\t\t; /* find the end */\n\tstrbuf_add(name, cp, ep - cp);\n\treturn (const char *)ep + 1 - cp_;\n}\n\nstatic struct cache_entry *create_from_disk(struct ondisk_cache_entry *ondisk,\n\t\t\t\t\t    unsigned long *ent_size,\n\t\t\t\t\t    struct strbuf *previous_name)\n{\n\tstruct cache_entry *ce;\n\tsize_t len;\n\tconst char *name;\n\tunsigned int flags;\n\n\t/* On-disk flags are just 16 bits */\n\tflags = get_be16(&ondisk->flags);\n\tlen = flags & CE_NAMEMASK;\n\n\tif (flags & CE_EXTENDED) {\n\t\tstruct ondisk_cache_entry_extended *ondisk2;\n\t\tint extended_flags;\n\t\tondisk2 = (struct ondisk_cache_entry_extended *)ondisk;\n\t\textended_flags = get_be16(&ondisk2->flags2) << 16;\n\t\t/* We do not yet understand any bit out of CE_EXTENDED_FLAGS */\n\t\tif (extended_flags & ~CE_EXTENDED_FLAGS)\n\t\t\tdie(\"Unknown index entry format %08x\", extended_flags);\n\t\tflags |= extended_flags;\n\t\tname = ondisk2->name;\n\t}\n\telse\n\t\tname = ondisk->name;\n\n\tif (!previous_name) {\n\t\t/* v3 and earlier */\n\t\tif (len == CE_NAMEMASK)\n\t\t\tlen = strlen(name);\n\t\tce = cache_entry_from_ondisk(ondisk, flags, name, len);\n\n\t\t*ent_size = ondisk_ce_size(ce);\n\t} else {\n\t\tunsigned long consumed;\n\t\tconsumed = expand_name_field(previous_name, name);\n\t\tce = cache_entry_from_ondisk(ondisk, flags,\n\t\t\t\t\t     previous_name->buf,\n\t\t\t\t\t     previous_name->len);\n\n\t\t*ent_size = (name - ((char *)ondisk)) + consumed;\n\t}\n\treturn ce;\n}\n\nstatic void check_ce_order(struct cache_entry *ce, struct cache_entry *next_ce)\n{\n\tint name_compare = strcmp(ce->name, next_ce->name);\n\tif (0 < name_compare)\n\t\tdie(\"unordered stage entries in index\");\n\tif (!name_compare) {\n\t\tif (!ce_stage(ce))\n\t\t\tdie(\"multiple stage entries for merged file '%s'\",\n\t\t\t\tce->name);\n\t\tif (ce_stage(ce) > ce_stage(next_ce))\n\t\t\tdie(\"unordered stage entries for '%s'\",\n\t\t\t\tce->name);\n\t}\n}\n\n/* remember to discard_cache() before reading a different cache! */\nint do_read_index(struct index_state *istate, const char *path, int must_exist)\n{\n\tint fd, i;\n\tstruct stat st;\n\tunsigned long src_offset;\n\tstruct cache_header *hdr;\n\tvoid *mmap;\n\tsize_t mmap_size;\n\tstruct strbuf previous_name_buf = STRBUF_INIT, *previous_name;\n\n\tif (istate->initialized)\n\t\treturn istate->cache_nr;\n\n\tistate->timestamp.sec = 0;\n\tistate->timestamp.nsec = 0;\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0) {\n\t\tif (!must_exist && errno == ENOENT)\n\t\t\treturn 0;\n\t\tdie_errno(\"%s: index file open failed\", path);\n\t}\n\n\tif (fstat(fd, &st))\n\t\tdie_errno(\"cannot stat the open index\");\n\n\tmmap_size = xsize_t(st.st_size);\n\tif (mmap_size < sizeof(struct cache_header) + 20)\n\t\tdie(\"index file smaller than expected\");\n\n\tmmap = xmmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n\tif (mmap == MAP_FAILED)\n\t\tdie_errno(\"unable to map index file\");\n\tclose(fd);\n\n\thdr = mmap;\n\tif (verify_hdr(hdr, mmap_size) < 0)\n\t\tgoto unmap;\n\n\thashcpy(istate->sha1, (const unsigned char *)hdr + mmap_size - 20);\n\tistate->version = ntohl(hdr->hdr_version);\n\tistate->cache_nr = ntohl(hdr->hdr_entries);\n\tistate->cache_alloc = alloc_nr(istate->cache_nr);\n\tistate->cache = xcalloc(istate->cache_alloc, sizeof(*istate->cache));\n\tistate->initialized = 1;\n\n\tif (istate->version == 4)\n\t\tprevious_name = &previous_name_buf;\n\telse\n\t\tprevious_name = NULL;\n\n\tsrc_offset = sizeof(*hdr);\n\tfor (i = 0; i < istate->cache_nr; i++) {\n\t\tstruct ondisk_cache_entry *disk_ce;\n\t\tstruct cache_entry *ce;\n\t\tunsigned long consumed;\n\n\t\tdisk_ce = (struct ondisk_cache_entry *)((char *)mmap + src_offset);\n\t\tce = create_from_disk(disk_ce, &consumed, previous_name);\n\t\tset_index_entry(istate, i, ce);\n\n\t\tif (i > 0)\n\t\t\tcheck_ce_order(istate->cache[i - 1], ce);\n\n\t\tsrc_offset += consumed;\n\t}\n\tstrbuf_release(&previous_name_buf);\n\tistate->timestamp.sec = st.st_mtime;\n\tistate->timestamp.nsec = ST_MTIME_NSEC(st);\n\n\twhile (src_offset <= mmap_size - 20 - 8) {\n\t\t/* After an array of active_nr index entries,\n\t\t * there can be arbitrary number of extended\n\t\t * sections, each of which is prefixed with\n\t\t * extension name (4-byte) and section length\n\t\t * in 4-byte network byte order.\n\t\t */\n\t\tuint32_t extsize;\n\t\tmemcpy(&extsize, (char *)mmap + src_offset + 4, 4);\n\t\textsize = ntohl(extsize);\n\t\tif (read_index_extension(istate,\n\t\t\t\t\t (const char *) mmap + src_offset,\n\t\t\t\t\t (char *) mmap + src_offset + 8,\n\t\t\t\t\t extsize) < 0)\n\t\t\tgoto unmap;\n\t\tsrc_offset += 8;\n\t\tsrc_offset += extsize;\n\t}\n\tmunmap(mmap, mmap_size);\n\treturn istate->cache_nr;\n\nunmap:\n\tmunmap(mmap, mmap_size);\n\tdie(\"index file corrupt\");\n}\n\nint read_index_from(struct index_state *istate, const char *path)\n{\n\tstruct split_index *split_index;\n\tint ret;\n\n\t/* istate->initialized covers both .git/index and .git/sharedindex.xxx */\n\tif (istate->initialized)\n\t\treturn istate->cache_nr;\n\n\tret = do_read_index(istate, path, 0);\n\tsplit_index = istate->split_index;\n\tif (!split_index)\n\t\treturn ret;\n\n\tif (is_null_sha1(split_index->base_sha1))\n\t\treturn ret;\n\n\tif (split_index->base)\n\t\tdiscard_index(split_index->base);\n\telse\n\t\tsplit_index->base = xcalloc(1, sizeof(*split_index->base));\n\tret = do_read_index(split_index->base,\n\t\t\t    git_path(\"sharedindex.%s\",\n\t\t\t\t     sha1_to_hex(split_index->base_sha1)), 1);\n\tif (hashcmp(split_index->base_sha1, split_index->base->sha1))\n\t\tdie(\"broken index, expect %s in %s, got %s\",\n\t\t    sha1_to_hex(split_index->base_sha1),\n\t\t    git_path(\"sharedindex.%s\",\n\t\t\t\t     sha1_to_hex(split_index->base_sha1)),\n\t\t    sha1_to_hex(split_index->base->sha1));\n\tmerge_base_index(istate);\n\treturn ret;\n}\n\nint is_index_unborn(struct index_state *istate)\n{\n\treturn (!istate->cache_nr && !istate->timestamp.sec);\n}\n\nint discard_index(struct index_state *istate)\n{\n\tint i;\n\n\tfor (i = 0; i < istate->cache_nr; i++) {\n\t\tif (istate->cache[i]->index &&\n\t\t    istate->split_index &&\n\t\t    istate->split_index->base &&\n\t\t    istate->cache[i]->index <= istate->split_index->base->cache_nr &&\n\t\t    istate->cache[i] == istate->split_index->base->cache[istate->cache[i]->index - 1])\n\t\t\tcontinue;\n\t\tfree(istate->cache[i]);\n\t}\n\tresolve_undo_clear_index(istate);\n\tistate->cache_nr = 0;\n\tistate->cache_changed = 0;\n\tistate->timestamp.sec = 0;\n\tistate->timestamp.nsec = 0;\n\tfree_name_hash(istate);\n\tcache_tree_free(&(istate->cache_tree));\n\tistate->initialized = 0;\n\tfree(istate->cache);\n\tistate->cache = NULL;\n\tistate->cache_alloc = 0;\n\tdiscard_split_index(istate);\n\treturn 0;\n}\n\nint unmerged_index(const struct index_state *istate)\n{\n\tint i;\n\tfor (i = 0; i < istate->cache_nr; i++) {\n\t\tif (ce_stage(istate->cache[i]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#define WRITE_BUFFER_SIZE 8192\nstatic unsigned char write_buffer[WRITE_BUFFER_SIZE];\nstatic unsigned long write_buffer_len;\n\nstatic int ce_write_flush(git_SHA_CTX *context, int fd)\n{\n\tunsigned int buffered = write_buffer_len;\n\tif (buffered) {\n\t\tgit_SHA1_Update(context, write_buffer, buffered);\n\t\tif (write_in_full(fd, write_buffer, buffered) != buffered)\n\t\t\treturn -1;\n\t\twrite_buffer_len = 0;\n\t}\n\treturn 0;\n}\n\nstatic int ce_write(git_SHA_CTX *context, int fd, void *data, unsigned int len)\n{\n\twhile (len) {\n\t\tunsigned int buffered = write_buffer_len;\n\t\tunsigned int partial = WRITE_BUFFER_SIZE - buffered;\n\t\tif (partial > len)\n\t\t\tpartial = len;\n\t\tmemcpy(write_buffer + buffered, data, partial);\n\t\tbuffered += partial;\n\t\tif (buffered == WRITE_BUFFER_SIZE) {\n\t\t\twrite_buffer_len = buffered;\n\t\t\tif (ce_write_flush(context, fd))\n\t\t\t\treturn -1;\n\t\t\tbuffered = 0;\n\t\t}\n\t\twrite_buffer_len = buffered;\n\t\tlen -= partial;\n\t\tdata = (char *) data + partial;\n\t}\n\treturn 0;\n}\n\nstatic int write_index_ext_header(git_SHA_CTX *context, int fd,\n\t\t\t\t  unsigned int ext, unsigned int sz)\n{\n\text = htonl(ext);\n\tsz = htonl(sz);\n\treturn ((ce_write(context, fd, &ext, 4) < 0) ||\n\t\t(ce_write(context, fd, &sz, 4) < 0)) ? -1 : 0;\n}\n\nstatic int ce_flush(git_SHA_CTX *context, int fd, unsigned char *sha1)\n{\n\tunsigned int left = write_buffer_len;\n\n\tif (left) {\n\t\twrite_buffer_len = 0;\n\t\tgit_SHA1_Update(context, write_buffer, left);\n\t}\n\n\t/* Flush first if not enough space for SHA1 signature */\n\tif (left + 20 > WRITE_BUFFER_SIZE) {\n\t\tif (write_in_full(fd, write_buffer, left) != left)\n\t\t\treturn -1;\n\t\tleft = 0;\n\t}\n\n\t/* Append the SHA1 signature at the end */\n\tgit_SHA1_Final(write_buffer + left, context);\n\thashcpy(sha1, write_buffer + left);\n\tleft += 20;\n\treturn (write_in_full(fd, write_buffer, left) != left) ? -1 : 0;\n}\n\nstatic void ce_smudge_racily_clean_entry(struct cache_entry *ce)\n{\n\t/*\n\t * The only thing we care about in this function is to smudge the\n\t * falsely clean entry due to touch-update-touch race, so we leave\n\t * everything else as they are.  We are called for entries whose\n\t * ce_stat_data.sd_mtime match the index file mtime.\n\t *\n\t * Note that this actually does not do much for gitlinks, for\n\t * which ce_match_stat_basic() always goes to the actual\n\t * contents.  The caller checks with is_racy_timestamp() which\n\t * always says \"no\" for gitlinks, so we are not called for them ;-)\n\t */\n\tstruct stat st;\n\n\tif (lstat(ce->name, &st) < 0)\n\t\treturn;\n\tif (ce_match_stat_basic(ce, &st))\n\t\treturn;\n\tif (ce_modified_check_fs(ce, &st)) {\n\t\t/* This is \"racily clean\"; smudge it.  Note that this\n\t\t * is a tricky code.  At first glance, it may appear\n\t\t * that it can break with this sequence:\n\t\t *\n\t\t * $ echo xyzzy >frotz\n\t\t * $ git-update-index --add frotz\n\t\t * $ : >frotz\n\t\t * $ sleep 3\n\t\t * $ echo filfre >nitfol\n\t\t * $ git-update-index --add nitfol\n\t\t *\n\t\t * but it does not.  When the second update-index runs,\n\t\t * it notices that the entry \"frotz\" has the same timestamp\n\t\t * as index, and if we were to smudge it by resetting its\n\t\t * size to zero here, then the object name recorded\n\t\t * in index is the 6-byte file but the cached stat information\n\t\t * becomes zero --- which would then match what we would\n\t\t * obtain from the filesystem next time we stat(\"frotz\").\n\t\t *\n\t\t * However, the second update-index, before calling\n\t\t * this function, notices that the cached size is 6\n\t\t * bytes and what is on the filesystem is an empty\n\t\t * file, and never calls us, so the cached size information\n\t\t * for \"frotz\" stays 6 which does not match the filesystem.\n\t\t */\n\t\tce->ce_stat_data.sd_size = 0;\n\t}\n}\n\n/* Copy miscellaneous fields but not the name */\nstatic char *copy_cache_entry_to_ondisk(struct ondisk_cache_entry *ondisk,\n\t\t\t\t       struct cache_entry *ce)\n{\n\tshort flags;\n\n\tondisk->ctime.sec = htonl(ce->ce_stat_data.sd_ctime.sec);\n\tondisk->mtime.sec = htonl(ce->ce_stat_data.sd_mtime.sec);\n\tondisk->ctime.nsec = htonl(ce->ce_stat_data.sd_ctime.nsec);\n\tondisk->mtime.nsec = htonl(ce->ce_stat_data.sd_mtime.nsec);\n\tondisk->dev  = htonl(ce->ce_stat_data.sd_dev);\n\tondisk->ino  = htonl(ce->ce_stat_data.sd_ino);\n\tondisk->mode = htonl(ce->ce_mode);\n\tondisk->uid  = htonl(ce->ce_stat_data.sd_uid);\n\tondisk->gid  = htonl(ce->ce_stat_data.sd_gid);\n\tondisk->size = htonl(ce->ce_stat_data.sd_size);\n\thashcpy(ondisk->sha1, ce->sha1);\n\n\tflags = ce->ce_flags & ~CE_NAMEMASK;\n\tflags |= (ce_namelen(ce) >= CE_NAMEMASK ? CE_NAMEMASK : ce_namelen(ce));\n\tondisk->flags = htons(flags);\n\tif (ce->ce_flags & CE_EXTENDED) {\n\t\tstruct ondisk_cache_entry_extended *ondisk2;\n\t\tondisk2 = (struct ondisk_cache_entry_extended *)ondisk;\n\t\tondisk2->flags2 = htons((ce->ce_flags & CE_EXTENDED_FLAGS) >> 16);\n\t\treturn ondisk2->name;\n\t}\n\telse {\n\t\treturn ondisk->name;\n\t}\n}\n\nstatic int ce_write_entry(git_SHA_CTX *c, int fd, struct cache_entry *ce,\n\t\t\t  struct strbuf *previous_name)\n{\n\tint size;\n\tstruct ondisk_cache_entry *ondisk;\n\tint saved_namelen = saved_namelen; /* compiler workaround */\n\tchar *name;\n\tint result;\n\n\tif (ce->ce_flags & CE_STRIP_NAME) {\n\t\tsaved_namelen = ce_namelen(ce);\n\t\tce->ce_namelen = 0;\n\t}\n\n\tif (!previous_name) {\n\t\tsize = ondisk_ce_size(ce);\n\t\tondisk = xcalloc(1, size);\n\t\tname = copy_cache_entry_to_ondisk(ondisk, ce);\n\t\tmemcpy(name, ce->name, ce_namelen(ce));\n\t} else {\n\t\tint common, to_remove, prefix_size;\n\t\tunsigned char to_remove_vi[16];\n\t\tfor (common = 0;\n\t\t     (ce->name[common] &&\n\t\t      common < previous_name->len &&\n\t\t      ce->name[common] == previous_name->buf[common]);\n\t\t     common++)\n\t\t\t; /* still matching */\n\t\tto_remove = previous_name->len - common;\n\t\tprefix_size = encode_varint(to_remove, to_remove_vi);\n\n\t\tif (ce->ce_flags & CE_EXTENDED)\n\t\t\tsize = offsetof(struct ondisk_cache_entry_extended, name);\n\t\telse\n\t\t\tsize = offsetof(struct ondisk_cache_entry, name);\n\t\tsize += prefix_size + (ce_namelen(ce) - common + 1);\n\n\t\tondisk = xcalloc(1, size);\n\t\tname = copy_cache_entry_to_ondisk(ondisk, ce);\n\t\tmemcpy(name, to_remove_vi, prefix_size);\n\t\tmemcpy(name + prefix_size, ce->name + common, ce_namelen(ce) - common);\n\n\t\tstrbuf_splice(previous_name, common, to_remove,\n\t\t\t      ce->name + common, ce_namelen(ce) - common);\n\t}\n\tif (ce->ce_flags & CE_STRIP_NAME) {\n\t\tce->ce_namelen = saved_namelen;\n\t\tce->ce_flags &= ~CE_STRIP_NAME;\n\t}\n\n\tresult = ce_write(c, fd, ondisk, size);\n\tfree(ondisk);\n\treturn result;\n}\n\n/*\n * This function verifies if index_state has the correct sha1 of the\n * index file.  Don't die if we have any other failure, just return 0.\n */\nstatic int verify_index_from(const struct index_state *istate, const char *path)\n{\n\tint fd;\n\tssize_t n;\n\tstruct stat st;\n\tunsigned char sha1[20];\n\n\tif (!istate->initialized)\n\t\treturn 0;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\tif (fstat(fd, &st))\n\t\tgoto out;\n\n\tif (st.st_size < sizeof(struct cache_header) + 20)\n\t\tgoto out;\n\n\tn = pread_in_full(fd, sha1, 20, st.st_size - 20);\n\tif (n != 20)\n\t\tgoto out;\n\n\tif (hashcmp(istate->sha1, sha1))\n\t\tgoto out;\n\n\tclose(fd);\n\treturn 1;\n\nout:\n\tclose(fd);\n\treturn 0;\n}\n\nstatic int verify_index(const struct index_state *istate)\n{\n\treturn verify_index_from(istate, get_index_file());\n}\n\nstatic int has_racy_timestamp(struct index_state *istate)\n{\n\tint entries = istate->cache_nr;\n\tint i;\n\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct cache_entry *ce = istate->cache[i];\n\t\tif (is_racy_timestamp(istate, ce))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Opportunistically update the index but do not complain if we can't\n */\nvoid update_index_if_able(struct index_state *istate, struct lock_file *lockfile)\n{\n\tif ((istate->cache_changed || has_racy_timestamp(istate)) &&\n\t    verify_index(istate) &&\n\t    write_locked_index(istate, lockfile, COMMIT_LOCK))\n\t\trollback_lock_file(lockfile);\n}\n\nstatic int do_write_index(struct index_state *istate, int newfd,\n\t\t\t  int strip_extensions)\n{\n\tgit_SHA_CTX c;\n\tstruct cache_header hdr;\n\tint i, err, removed, extended, hdr_version;\n\tstruct cache_entry **cache = istate->cache;\n\tint entries = istate->cache_nr;\n\tstruct stat st;\n\tstruct strbuf previous_name_buf = STRBUF_INIT, *previous_name;\n\n\tfor (i = removed = extended = 0; i < entries; i++) {\n\t\tif (cache[i]->ce_flags & CE_REMOVE)\n\t\t\tremoved++;\n\n\t\t/* reduce extended entries if possible */\n\t\tcache[i]->ce_flags &= ~CE_EXTENDED;\n\t\tif (cache[i]->ce_flags & CE_EXTENDED_FLAGS) {\n\t\t\textended++;\n\t\t\tcache[i]->ce_flags |= CE_EXTENDED;\n\t\t}\n\t}\n\n\tif (!istate->version) {\n\t\tistate->version = get_index_format_default();\n\t\tif (getenv(\"GIT_TEST_SPLIT_INDEX\"))\n\t\t\tinit_split_index(istate);\n\t}\n\n\t/* demote version 3 to version 2 when the latter suffices */\n\tif (istate->version == 3 || istate->version == 2)\n\t\tistate->version = extended ? 3 : 2;\n\n\thdr_version = istate->version;\n\n\thdr.hdr_signature = htonl(CACHE_SIGNATURE);\n\thdr.hdr_version = htonl(hdr_version);\n\thdr.hdr_entries = htonl(entries - removed);\n\n\tgit_SHA1_Init(&c);\n\tif (ce_write(&c, newfd, &hdr, sizeof(hdr)) < 0)\n\t\treturn -1;\n\n\tprevious_name = (hdr_version == 4) ? &previous_name_buf : NULL;\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct cache_entry *ce = cache[i];\n\t\tif (ce->ce_flags & CE_REMOVE)\n\t\t\tcontinue;\n\t\tif (!ce_uptodate(ce) && is_racy_timestamp(istate, ce))\n\t\t\tce_smudge_racily_clean_entry(ce);\n\t\tif (is_null_sha1(ce->sha1)) {\n\t\t\tstatic const char msg[] = \"cache entry has null sha1: %s\";\n\t\t\tstatic int allow = -1;\n\n\t\t\tif (allow < 0)\n\t\t\t\tallow = git_env_bool(\"GIT_ALLOW_NULL_SHA1\", 0);\n\t\t\tif (allow)\n\t\t\t\twarning(msg, ce->name);\n\t\t\telse\n\t\t\t\treturn error(msg, ce->name);\n\t\t}\n\t\tif (ce_write_entry(&c, newfd, ce, previous_name) < 0)\n\t\t\treturn -1;\n\t}\n\tstrbuf_release(&previous_name_buf);\n\n\t/* Write extension data here */\n\tif (!strip_extensions && istate->split_index) {\n\t\tstruct strbuf sb = STRBUF_INIT;\n\n\t\terr = write_link_extension(&sb, istate) < 0 ||\n\t\t\twrite_index_ext_header(&c, newfd, CACHE_EXT_LINK,\n\t\t\t\t\t       sb.len) < 0 ||\n\t\t\tce_write(&c, newfd, sb.buf, sb.len) < 0;\n\t\tstrbuf_release(&sb);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\tif (!strip_extensions && istate->cache_tree) {\n\t\tstruct strbuf sb = STRBUF_INIT;\n\n\t\tcache_tree_write(&sb, istate->cache_tree);\n\t\terr = write_index_ext_header(&c, newfd, CACHE_EXT_TREE, sb.len) < 0\n\t\t\t|| ce_write(&c, newfd, sb.buf, sb.len) < 0;\n\t\tstrbuf_release(&sb);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\tif (!strip_extensions && istate->resolve_undo) {\n\t\tstruct strbuf sb = STRBUF_INIT;\n\n\t\tresolve_undo_write(&sb, istate->resolve_undo);\n\t\terr = write_index_ext_header(&c, newfd, CACHE_EXT_RESOLVE_UNDO,\n\t\t\t\t\t     sb.len) < 0\n\t\t\t|| ce_write(&c, newfd, sb.buf, sb.len) < 0;\n\t\tstrbuf_release(&sb);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\n\tif (ce_flush(&c, newfd, istate->sha1) || fstat(newfd, &st))\n\t\treturn -1;\n\tistate->timestamp.sec = (unsigned int)st.st_mtime;\n\tistate->timestamp.nsec = ST_MTIME_NSEC(st);\n\treturn 0;\n}\n\nvoid set_alternate_index_output(const char *name)\n{\n\talternate_index_output = name;\n}\n\nstatic int commit_locked_index(struct lock_file *lk)\n{\n\tif (alternate_index_output)\n\t\treturn commit_lock_file_to(lk, alternate_index_output);\n\telse\n\t\treturn commit_lock_file(lk);\n}\n\nstatic int do_write_locked_index(struct index_state *istate, struct lock_file *lock,\n\t\t\t\t unsigned flags)\n{\n\tint ret = do_write_index(istate, lock->fd, 0);\n\tif (ret)\n\t\treturn ret;\n\tassert((flags & (COMMIT_LOCK | CLOSE_LOCK)) !=\n\t       (COMMIT_LOCK | CLOSE_LOCK));\n\tif (flags & COMMIT_LOCK)\n\t\treturn commit_locked_index(lock);\n\telse if (flags & CLOSE_LOCK)\n\t\treturn close_lock_file(lock);\n\telse\n\t\treturn ret;\n}\n\nstatic int write_split_index(struct index_state *istate,\n\t\t\t     struct lock_file *lock,\n\t\t\t     unsigned flags)\n{\n\tint ret;\n\tprepare_to_write_split_index(istate);\n\tret = do_write_locked_index(istate, lock, flags);\n\tfinish_writing_split_index(istate);\n\treturn ret;\n}\n\nstatic char *temporary_sharedindex;\n\nstatic void remove_temporary_sharedindex(void)\n{\n\tif (temporary_sharedindex) {\n\t\tunlink_or_warn(temporary_sharedindex);\n\t\tfree(temporary_sharedindex);\n\t\ttemporary_sharedindex = NULL;\n\t}\n}\n\nstatic void remove_temporary_sharedindex_on_signal(int signo)\n{\n\tremove_temporary_sharedindex();\n\tsigchain_pop(signo);\n\traise(signo);\n}\n\nstatic int write_shared_index(struct index_state *istate,\n\t\t\t      struct lock_file *lock, unsigned flags)\n{\n\tstruct split_index *si = istate->split_index;\n\tstatic int installed_handler;\n\tint fd, ret;\n\n\ttemporary_sharedindex = git_pathdup(\"sharedindex_XXXXXX\");\n\tfd = mkstemp(temporary_sharedindex);\n\tif (fd < 0) {\n\t\tfree(temporary_sharedindex);\n\t\ttemporary_sharedindex = NULL;\n\t\thashclr(si->base_sha1);\n\t\treturn do_write_locked_index(istate, lock, flags);\n\t}\n\tif (!installed_handler) {\n\t\tatexit(remove_temporary_sharedindex);\n\t\tsigchain_push_common(remove_temporary_sharedindex_on_signal);\n\t}\n\tmove_cache_to_base_index(istate);\n\tret = do_write_index(si->base, fd, 1);\n\tclose(fd);\n\tif (ret) {\n\t\tremove_temporary_sharedindex();\n\t\treturn ret;\n\t}\n\tret = rename(temporary_sharedindex,\n\t\t     git_path(\"sharedindex.%s\", sha1_to_hex(si->base->sha1)));\n\tfree(temporary_sharedindex);\n\ttemporary_sharedindex = NULL;\n\tif (!ret)\n\t\thashcpy(si->base_sha1, si->base->sha1);\n\treturn ret;\n}\n\nint write_locked_index(struct index_state *istate, struct lock_file *lock,\n\t\t       unsigned flags)\n{\n\tstruct split_index *si = istate->split_index;\n\n\tif (!si || alternate_index_output ||\n\t    (istate->cache_changed & ~EXTMASK)) {\n\t\tif (si)\n\t\t\thashclr(si->base_sha1);\n\t\treturn do_write_locked_index(istate, lock, flags);\n\t}\n\n\tif (getenv(\"GIT_TEST_SPLIT_INDEX\")) {\n\t\tint v = si->base_sha1[0];\n\t\tif ((v & 15) < 6)\n\t\t\tistate->cache_changed |= SPLIT_INDEX_ORDERED;\n\t}\n\tif (istate->cache_changed & SPLIT_INDEX_ORDERED) {\n\t\tint ret = write_shared_index(istate, lock, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn write_split_index(istate, lock, flags);\n}\n\n/*\n * Read the index file that is potentially unmerged into given\n * index_state, dropping any unmerged entries.  Returns true if\n * the index is unmerged.  Callers who want to refuse to work\n * from an unmerged state can call this and check its return value,\n * instead of calling read_cache().\n */\nint read_index_unmerged(struct index_state *istate)\n{\n\tint i;\n\tint unmerged = 0;\n\n\tread_index(istate);\n\tfor (i = 0; i < istate->cache_nr; i++) {\n\t\tstruct cache_entry *ce = istate->cache[i];\n\t\tstruct cache_entry *new_ce;\n\t\tint size, len;\n\n\t\tif (!ce_stage(ce))\n\t\t\tcontinue;\n\t\tunmerged = 1;\n\t\tlen = ce_namelen(ce);\n\t\tsize = cache_entry_size(len);\n\t\tnew_ce = xcalloc(1, size);\n\t\tmemcpy(new_ce->name, ce->name, len);\n\t\tnew_ce->ce_flags = create_ce_flags(0) | CE_CONFLICTED;\n\t\tnew_ce->ce_namelen = len;\n\t\tnew_ce->ce_mode = ce->ce_mode;\n\t\tif (add_index_entry(istate, new_ce, 0))\n\t\t\treturn error(\"%s: cannot drop to stage #0\",\n\t\t\t\t     new_ce->name);\n\t}\n\treturn unmerged;\n}\n\n/*\n * Returns 1 if the path is an \"other\" path with respect to\n * the index; that is, the path is not mentioned in the index at all,\n * either as a file, a directory with some files in the index,\n * or as an unmerged entry.\n *\n * We helpfully remove a trailing \"/\" from directories so that\n * the output of read_directory can be used as-is.\n */\nint index_name_is_other(const struct index_state *istate, const char *name,\n\t\tint namelen)\n{\n\tint pos;\n\tif (namelen && name[namelen - 1] == '/')\n\t\tnamelen--;\n\tpos = index_name_pos(istate, name, namelen);\n\tif (0 <= pos)\n\t\treturn 0;\t/* exact match */\n\tpos = -pos - 1;\n\tif (pos < istate->cache_nr) {\n\t\tstruct cache_entry *ce = istate->cache[pos];\n\t\tif (ce_namelen(ce) == namelen &&\n\t\t    !memcmp(ce->name, name, namelen))\n\t\t\treturn 0; /* Yup, this one exists unmerged */\n\t}\n\treturn 1;\n}\n\nvoid *read_blob_data_from_index(struct index_state *istate, const char *path, unsigned long *size)\n{\n\tint pos, len;\n\tunsigned long sz;\n\tenum object_type type;\n\tvoid *data;\n\n\tlen = strlen(path);\n\tpos = index_name_pos(istate, path, len);\n\tif (pos < 0) {\n\t\t/*\n\t\t * We might be in the middle of a merge, in which\n\t\t * case we would read stage #2 (ours).\n\t\t */\n\t\tint i;\n\t\tfor (i = -pos - 1;\n\t\t     (pos < 0 && i < istate->cache_nr &&\n\t\t      !strcmp(istate->cache[i]->name, path));\n\t\t     i++)\n\t\t\tif (ce_stage(istate->cache[i]) == 2)\n\t\t\t\tpos = i;\n\t}\n\tif (pos < 0)\n\t\treturn NULL;\n\tdata = read_sha1_file(istate->cache[pos]->sha1, &type, &sz);\n\tif (!data || type != OBJ_BLOB) {\n\t\tfree(data);\n\t\treturn NULL;\n\t}\n\tif (size)\n\t\t*size = sz;\n\treturn data;\n}\n\nvoid stat_validity_clear(struct stat_validity *sv)\n{\n\tfree(sv->sd);\n\tsv->sd = NULL;\n}\n\nint stat_validity_check(struct stat_validity *sv, const char *path)\n{\n\tstruct stat st;\n\n\tif (stat(path, &st) < 0)\n\t\treturn sv->sd == NULL;\n\tif (!sv->sd)\n\t\treturn 0;\n\treturn S_ISREG(st.st_mode) && !match_stat_data(sv->sd, &st);\n}\n\nvoid stat_validity_update(struct stat_validity *sv, int fd)\n{\n\tstruct stat st;\n\n\tif (fstat(fd, &st) < 0 || !S_ISREG(st.st_mode))\n\t\tstat_validity_clear(sv);\n\telse {\n\t\tif (!sv->sd)\n\t\t\tsv->sd = xcalloc(1, sizeof(struct stat_data));\n\t\tfill_stat_data(sv->sd, &st);\n\t}\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0052b72d9c230d937fc66633358e7aefbe379042",
  "sha1_ok": true,
  "size": 62528
}
