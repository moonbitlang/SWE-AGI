{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImxvY2tmaWxlLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJwa3QtbGluZS5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgImV4ZWNfY21kLmgiCiNpbmNsdWRlICJwYWNrLmgiCiNpbmNsdWRlICJzaWRlYmFuZC5oIgojaW5jbHVkZSAiZmV0Y2gtcGFjay5oIgojaW5jbHVkZSAicmVtb3RlLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAiY29ubmVjdC5oIgojaW5jbHVkZSAidHJhbnNwb3J0LmgiCiNpbmNsdWRlICJ2ZXJzaW9uLmgiCiNpbmNsdWRlICJwcmlvLXF1ZXVlLmgiCiNpbmNsdWRlICJzaGExLWFycmF5LmgiCiNpbmNsdWRlICJvaWRzZXQuaCIKI2luY2x1ZGUgInBhY2tmaWxlLmgiCgpzdGF0aWMgaW50IHRyYW5zZmVyX3VucGFja19saW1pdCA9IC0xOwpzdGF0aWMgaW50IGZldGNoX3VucGFja19saW1pdCA9IC0xOwpzdGF0aWMgaW50IHVucGFja19saW1pdCA9IDEwMDsKc3RhdGljIGludCBwcmVmZXJfb2ZzX2RlbHRhID0gMTsKc3RhdGljIGludCBub19kb25lOwpzdGF0aWMgaW50IGRlZXBlbl9zaW5jZV9vazsKc3RhdGljIGludCBkZWVwZW5fbm90X29rOwpzdGF0aWMgaW50IGZldGNoX2ZzY2tfb2JqZWN0cyA9IC0xOwpzdGF0aWMgaW50IHRyYW5zZmVyX2ZzY2tfb2JqZWN0cyA9IC0xOwpzdGF0aWMgaW50IGFnZW50X3N1cHBvcnRlZDsKc3RhdGljIHN0cnVjdCBsb2NrX2ZpbGUgc2hhbGxvd19sb2NrOwpzdGF0aWMgY29uc3QgY2hhciAqYWx0ZXJuYXRlX3NoYWxsb3dfZmlsZTsKCi8qIFJlbWVtYmVyIHRvIHVwZGF0ZSBvYmplY3QgZmxhZyBhbGxvY2F0aW9uIGluIG9iamVjdC5oICovCiNkZWZpbmUgQ09NUExFVEUJKDFVIDw8IDApCiNkZWZpbmUgQ09NTU9OCQkoMVUgPDwgMSkKI2RlZmluZSBDT01NT05fUkVGCSgxVSA8PCAyKQojZGVmaW5lIFNFRU4JCSgxVSA8PCAzKQojZGVmaW5lIFBPUFBFRAkJKDFVIDw8IDQpCiNkZWZpbmUgQUxURVJOQVRFCSgxVSA8PCA1KQoKc3RhdGljIGludCBtYXJrZWQ7CgovKgogKiBBZnRlciBzZW5kaW5nIHRoaXMgbWFueSAiaGF2ZSJzIGlmIHdlIGRvIG5vdCBnZXQgYW55IG5ldyBBQ0sgLCB3ZQogKiBnaXZlIHVwIHRyYXZlcnNpbmcgb3VyIGhpc3RvcnkuCiAqLwojZGVmaW5lIE1BWF9JTl9WQUlOIDI1NgoKc3RhdGljIHN0cnVjdCBwcmlvX3F1ZXVlIHJldl9saXN0ID0geyBjb21wYXJlX2NvbW1pdHNfYnlfY29tbWl0X2RhdGUgfTsKc3RhdGljIGludCBub25fY29tbW9uX3JldnMsIG11bHRpX2FjaywgdXNlX3NpZGViYW5kOwovKiBBbGxvdyBzcGVjaWZ5aW5nIHNoYTEgaWYgaXQgaXMgYSByZWYgdGlwLiAqLwojZGVmaW5lIEFMTE9XX1RJUF9TSEExCTAxCi8qIEFsbG93IHJlcXVlc3Qgb2YgYSBzaGExIGlmIGl0IGlzIHJlYWNoYWJsZSBmcm9tIGEgcmVmIChwb3NzaWJseSBoaWRkZW4gcmVmKS4gKi8KI2RlZmluZSBBTExPV19SRUFDSEFCTEVfU0hBMQkwMgpzdGF0aWMgdW5zaWduZWQgaW50IGFsbG93X3VuYWR2ZXJ0aXNlZF9vYmplY3RfcmVxdWVzdDsKCl9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAyLCAzKSkpCnN0YXRpYyBpbmxpbmUgdm9pZCBwcmludF92ZXJib3NlKGNvbnN0IHN0cnVjdCBmZXRjaF9wYWNrX2FyZ3MgKmFyZ3MsCgkJCQkgY29uc3QgY2hhciAqZm10LCAuLi4pCnsKCXZhX2xpc3QgcGFyYW1zOwoKCWlmICghYXJncy0+dmVyYm9zZSkKCQlyZXR1cm47CgoJdmFfc3RhcnQocGFyYW1zLCBmbXQpOwoJdmZwcmludGYoc3RkZXJyLCBmbXQsIHBhcmFtcyk7Cgl2YV9lbmQocGFyYW1zKTsKCWZwdXRjKCdcbicsIHN0ZGVycik7Cn0KCnN0cnVjdCBhbHRlcm5hdGVfb2JqZWN0X2NhY2hlIHsKCXN0cnVjdCBvYmplY3QgKippdGVtczsKCXNpemVfdCBuciwgYWxsb2M7Cn07CgpzdGF0aWMgdm9pZCBjYWNoZV9vbmVfYWx0ZXJuYXRlKGNvbnN0IGNoYXIgKnJlZm5hbWUsCgkJCQljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCQl2b2lkICp2Y2FjaGUpCnsKCXN0cnVjdCBhbHRlcm5hdGVfb2JqZWN0X2NhY2hlICpjYWNoZSA9IHZjYWNoZTsKCXN0cnVjdCBvYmplY3QgKm9iaiA9IHBhcnNlX29iamVjdChvaWQpOwoKCWlmICghb2JqIHx8IChvYmotPmZsYWdzICYgQUxURVJOQVRFKSkKCQlyZXR1cm47CgoJb2JqLT5mbGFncyB8PSBBTFRFUk5BVEU7CglBTExPQ19HUk9XKGNhY2hlLT5pdGVtcywgY2FjaGUtPm5yICsgMSwgY2FjaGUtPmFsbG9jKTsKCWNhY2hlLT5pdGVtc1tjYWNoZS0+bnIrK10gPSBvYmo7Cn0KCnN0YXRpYyB2b2lkIGZvcl9lYWNoX2NhY2hlZF9hbHRlcm5hdGUodm9pZCAoKmNiKShzdHJ1Y3Qgb2JqZWN0ICopKQp7CglzdGF0aWMgaW50IGluaXRpYWxpemVkOwoJc3RhdGljIHN0cnVjdCBhbHRlcm5hdGVfb2JqZWN0X2NhY2hlIGNhY2hlOwoJc2l6ZV90IGk7CgoJaWYgKCFpbml0aWFsaXplZCkgewoJCWZvcl9lYWNoX2FsdGVybmF0ZV9yZWYoY2FjaGVfb25lX2FsdGVybmF0ZSwgJmNhY2hlKTsKCQlpbml0aWFsaXplZCA9IDE7Cgl9CgoJZm9yIChpID0gMDsgaSA8IGNhY2hlLm5yOyBpKyspCgkJY2IoY2FjaGUuaXRlbXNbaV0pOwp9CgpzdGF0aWMgdm9pZCByZXZfbGlzdF9wdXNoKHN0cnVjdCBjb21taXQgKmNvbW1pdCwgaW50IG1hcmspCnsKCWlmICghKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgbWFyaykpIHsKCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBtYXJrOwoKCQlpZiAocGFyc2VfY29tbWl0KGNvbW1pdCkpCgkJCXJldHVybjsKCgkJcHJpb19xdWV1ZV9wdXQoJnJldl9saXN0LCBjb21taXQpOwoKCQlpZiAoIShjb21taXQtPm9iamVjdC5mbGFncyAmIENPTU1PTikpCgkJCW5vbl9jb21tb25fcmV2cysrOwoJfQp9CgpzdGF0aWMgaW50IHJldl9saXN0X2luc2VydF9yZWYoY29uc3QgY2hhciAqcmVmbmFtZSwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvID0gZGVyZWZfdGFnKHBhcnNlX29iamVjdChvaWQpLCByZWZuYW1lLCAwKTsKCglpZiAobyAmJiBvLT50eXBlID09IE9CSl9DT01NSVQpCgkJcmV2X2xpc3RfcHVzaCgoc3RydWN0IGNvbW1pdCAqKW8sIFNFRU4pOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHJldl9saXN0X2luc2VydF9yZWZfb2lkKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCSAgIGludCBmbGFnLCB2b2lkICpjYl9kYXRhKQp7CglyZXR1cm4gcmV2X2xpc3RfaW5zZXJ0X3JlZihyZWZuYW1lLCBvaWQpOwp9CgpzdGF0aWMgaW50IGNsZWFyX21hcmtzKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkgICAgICAgaW50IGZsYWcsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBvYmplY3QgKm8gPSBkZXJlZl90YWcocGFyc2Vfb2JqZWN0KG9pZCksIHJlZm5hbWUsIDApOwoKCWlmIChvICYmIG8tPnR5cGUgPT0gT0JKX0NPTU1JVCkKCQljbGVhcl9jb21taXRfbWFya3MoKHN0cnVjdCBjb21taXQgKilvLAoJCQkJICAgQ09NTU9OIHwgQ09NTU9OX1JFRiB8IFNFRU4gfCBQT1BQRUQpOwoJcmV0dXJuIDA7Cn0KCi8qCiAgIFRoaXMgZnVuY3Rpb24gbWFya3MgYSByZXYgYW5kIGl0cyBhbmNlc3RvcnMgYXMgY29tbW9uLgogICBJbiBzb21lIGNhc2VzLCBpdCBpcyBkZXNpcmFibGUgdG8gbWFyayBvbmx5IHRoZSBhbmNlc3RvcnMgKGZvciBleGFtcGxlCiAgIHdoZW4gb25seSB0aGUgc2VydmVyIGRvZXMgbm90IHlldCBrbm93IHRoYXQgdGhleSBhcmUgY29tbW9uKS4KKi8KCnN0YXRpYyB2b2lkIG1hcmtfY29tbW9uKHN0cnVjdCBjb21taXQgKmNvbW1pdCwKCQlpbnQgYW5jZXN0b3JzX29ubHksIGludCBkb250X3BhcnNlKQp7CglpZiAoY29tbWl0ICE9IE5VTEwgJiYgIShjb21taXQtPm9iamVjdC5mbGFncyAmIENPTU1PTikpIHsKCQlzdHJ1Y3Qgb2JqZWN0ICpvID0gKHN0cnVjdCBvYmplY3QgKiljb21taXQ7CgoJCWlmICghYW5jZXN0b3JzX29ubHkpCgkJCW8tPmZsYWdzIHw9IENPTU1PTjsKCgkJaWYgKCEoby0+ZmxhZ3MgJiBTRUVOKSkKCQkJcmV2X2xpc3RfcHVzaChjb21taXQsIFNFRU4pOwoJCWVsc2UgewoJCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHM7CgoJCQlpZiAoIWFuY2VzdG9yc19vbmx5ICYmICEoby0+ZmxhZ3MgJiBQT1BQRUQpKQoJCQkJbm9uX2NvbW1vbl9yZXZzLS07CgkJCWlmICghby0+cGFyc2VkICYmICFkb250X3BhcnNlKQoJCQkJaWYgKHBhcnNlX2NvbW1pdChjb21taXQpKQoJCQkJCXJldHVybjsKCgkJCWZvciAocGFyZW50cyA9IGNvbW1pdC0+cGFyZW50czsKCQkJCQlwYXJlbnRzOwoJCQkJCXBhcmVudHMgPSBwYXJlbnRzLT5uZXh0KQoJCQkJbWFya19jb21tb24ocGFyZW50cy0+aXRlbSwgMCwgZG9udF9wYXJzZSk7CgkJfQoJfQp9CgovKgogIEdldCB0aGUgbmV4dCByZXYgdG8gc2VuZCwgaWdub3JpbmcgdGhlIGNvbW1vbi4KKi8KCnN0YXRpYyBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpnZXRfcmV2KHZvaWQpCnsKCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IE5VTEw7CgoJd2hpbGUgKGNvbW1pdCA9PSBOVUxMKSB7CgkJdW5zaWduZWQgaW50IG1hcms7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzOwoKCQlpZiAocmV2X2xpc3QubnIgPT0gMCB8fCBub25fY29tbW9uX3JldnMgPT0gMCkKCQkJcmV0dXJuIE5VTEw7CgoJCWNvbW1pdCA9IHByaW9fcXVldWVfZ2V0KCZyZXZfbGlzdCk7CgkJcGFyc2VfY29tbWl0KGNvbW1pdCk7CgkJcGFyZW50cyA9IGNvbW1pdC0+cGFyZW50czsKCgkJY29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gUE9QUEVEOwoJCWlmICghKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgQ09NTU9OKSkKCQkJbm9uX2NvbW1vbl9yZXZzLS07CgoJCWlmIChjb21taXQtPm9iamVjdC5mbGFncyAmIENPTU1PTikgewoJCQkvKiBkbyBub3Qgc2VuZCAiaGF2ZSIsIGFuZCBpZ25vcmUgYW5jZXN0b3JzICovCgkJCWNvbW1pdCA9IE5VTEw7CgkJCW1hcmsgPSBDT01NT04gfCBTRUVOOwoJCX0gZWxzZSBpZiAoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBDT01NT05fUkVGKQoJCQkvKiBzZW5kICJoYXZlIiwgYW5kIGlnbm9yZSBhbmNlc3RvcnMgKi8KCQkJbWFyayA9IENPTU1PTiB8IFNFRU47CgkJZWxzZQoJCQkvKiBzZW5kICJoYXZlIiwgYWxzbyBmb3IgaXRzIGFuY2VzdG9ycyAqLwoJCQltYXJrID0gU0VFTjsKCgkJd2hpbGUgKHBhcmVudHMpIHsKCQkJaWYgKCEocGFyZW50cy0+aXRlbS0+b2JqZWN0LmZsYWdzICYgU0VFTikpCgkJCQlyZXZfbGlzdF9wdXNoKHBhcmVudHMtPml0ZW0sIG1hcmspOwoJCQlpZiAobWFyayAmIENPTU1PTikKCQkJCW1hcmtfY29tbW9uKHBhcmVudHMtPml0ZW0sIDEsIDApOwoJCQlwYXJlbnRzID0gcGFyZW50cy0+bmV4dDsKCQl9Cgl9CgoJcmV0dXJuICZjb21taXQtPm9iamVjdC5vaWQ7Cn0KCmVudW0gYWNrX3R5cGUgewoJTkFLID0gMCwKCUFDSywKCUFDS19jb250aW51ZSwKCUFDS19jb21tb24sCglBQ0tfcmVhZHkKfTsKCnN0YXRpYyB2b2lkIGNvbnN1bWVfc2hhbGxvd19saXN0KHN0cnVjdCBmZXRjaF9wYWNrX2FyZ3MgKmFyZ3MsIGludCBmZCkKewoJaWYgKGFyZ3MtPnN0YXRlbGVzc19ycGMgJiYgYXJncy0+ZGVlcGVuKSB7CgkJLyogSWYgd2Ugc2VudCBhIGRlcHRoIHdlIHdpbGwgZ2V0IGJhY2sgImR1cGxpY2F0ZSIKCQkgKiBzaGFsbG93IGFuZCB1bnNoYWxsb3cgY29tbWFuZHMgZXZlcnkgdGltZSB0aGVyZQoJCSAqIGlzIGEgYmxvY2sgb2YgaGF2ZSBsaW5lcyBleGNoYW5nZWQuCgkJICovCgkJY2hhciAqbGluZTsKCQl3aGlsZSAoKGxpbmUgPSBwYWNrZXRfcmVhZF9saW5lKGZkLCBOVUxMKSkpIHsKCQkJaWYgKHN0YXJ0c193aXRoKGxpbmUsICJzaGFsbG93ICIpKQoJCQkJY29udGludWU7CgkJCWlmIChzdGFydHNfd2l0aChsaW5lLCAidW5zaGFsbG93ICIpKQoJCQkJY29udGludWU7CgkJCWRpZShfKCJnaXQgZmV0Y2gtcGFjazogZXhwZWN0ZWQgc2hhbGxvdyBsaXN0IikpOwoJCX0KCX0KfQoKc3RhdGljIGVudW0gYWNrX3R5cGUgZ2V0X2FjayhpbnQgZmQsIHN0cnVjdCBvYmplY3RfaWQgKnJlc3VsdF9vaWQpCnsKCWludCBsZW47CgljaGFyICpsaW5lID0gcGFja2V0X3JlYWRfbGluZShmZCwgJmxlbik7Cgljb25zdCBjaGFyICphcmc7CgoJaWYgKCFsZW4pCgkJZGllKF8oImdpdCBmZXRjaC1wYWNrOiBleHBlY3RlZCBBQ0svTkFLLCBnb3QgRU9GIikpOwoJaWYgKCFzdHJjbXAobGluZSwgIk5BSyIpKQoJCXJldHVybiBOQUs7CglpZiAoc2tpcF9wcmVmaXgobGluZSwgIkFDSyAiLCAmYXJnKSkgewoJCWlmICghZ2V0X29pZF9oZXgoYXJnLCByZXN1bHRfb2lkKSkgewoJCQlhcmcgKz0gNDA7CgkJCWxlbiAtPSBhcmcgLSBsaW5lOwoJCQlpZiAobGVuIDwgMSkKCQkJCXJldHVybiBBQ0s7CgkJCWlmIChzdHJzdHIoYXJnLCAiY29udGludWUiKSkKCQkJCXJldHVybiBBQ0tfY29udGludWU7CgkJCWlmIChzdHJzdHIoYXJnLCAiY29tbW9uIikpCgkJCQlyZXR1cm4gQUNLX2NvbW1vbjsKCQkJaWYgKHN0cnN0cihhcmcsICJyZWFkeSIpKQoJCQkJcmV0dXJuIEFDS19yZWFkeTsKCQkJcmV0dXJuIEFDSzsKCQl9Cgl9CglpZiAoc2tpcF9wcmVmaXgobGluZSwgIkVSUiAiLCAmYXJnKSkKCQlkaWUoXygicmVtb3RlIGVycm9yOiAlcyIpLCBhcmcpOwoJZGllKF8oImdpdCBmZXRjaC1wYWNrOiBleHBlY3RlZCBBQ0svTkFLLCBnb3QgJyVzJyIpLCBsaW5lKTsKfQoKc3RhdGljIHZvaWQgc2VuZF9yZXF1ZXN0KHN0cnVjdCBmZXRjaF9wYWNrX2FyZ3MgKmFyZ3MsCgkJCSBpbnQgZmQsIHN0cnVjdCBzdHJidWYgKmJ1ZikKewoJaWYgKGFyZ3MtPnN0YXRlbGVzc19ycGMpIHsKCQlzZW5kX3NpZGViYW5kKGZkLCAtMSwgYnVmLT5idWYsIGJ1Zi0+bGVuLCBMQVJHRV9QQUNLRVRfTUFYKTsKCQlwYWNrZXRfZmx1c2goZmQpOwoJfSBlbHNlCgkJd3JpdGVfb3JfZGllKGZkLCBidWYtPmJ1ZiwgYnVmLT5sZW4pOwp9CgpzdGF0aWMgdm9pZCBpbnNlcnRfb25lX2FsdGVybmF0ZV9vYmplY3Qoc3RydWN0IG9iamVjdCAqb2JqKQp7CglyZXZfbGlzdF9pbnNlcnRfcmVmKE5VTEwsICZvYmotPm9pZCk7Cn0KCiNkZWZpbmUgSU5JVElBTF9GTFVTSCAxNgojZGVmaW5lIFBJUEVTQUZFX0ZMVVNIIDMyCiNkZWZpbmUgTEFSR0VfRkxVU0ggMTYzODQKCnN0YXRpYyBpbnQgbmV4dF9mbHVzaChzdHJ1Y3QgZmV0Y2hfcGFja19hcmdzICphcmdzLCBpbnQgY291bnQpCnsKCWlmIChhcmdzLT5zdGF0ZWxlc3NfcnBjKSB7CgkJaWYgKGNvdW50IDwgTEFSR0VfRkxVU0gpCgkJCWNvdW50IDw8PSAxOwoJCWVsc2UKCQkJY291bnQgPSBjb3VudCAqIDExIC8gMTA7Cgl9IGVsc2UgewoJCWlmIChjb3VudCA8IFBJUEVTQUZFX0ZMVVNIKQoJCQljb3VudCA8PD0gMTsKCQllbHNlCgkJCWNvdW50ICs9IFBJUEVTQUZFX0ZMVVNIOwoJfQoJcmV0dXJuIGNvdW50Owp9CgpzdGF0aWMgaW50IGZpbmRfY29tbW9uKHN0cnVjdCBmZXRjaF9wYWNrX2FyZ3MgKmFyZ3MsCgkJICAgICAgIGludCBmZFsyXSwgc3RydWN0IG9iamVjdF9pZCAqcmVzdWx0X29pZCwKCQkgICAgICAgc3RydWN0IHJlZiAqcmVmcykKewoJaW50IGZldGNoaW5nOwoJaW50IGNvdW50ID0gMCwgZmx1c2hlcyA9IDAsIGZsdXNoX2F0ID0gSU5JVElBTF9GTFVTSCwgcmV0dmFsOwoJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkOwoJdW5zaWduZWQgaW5fdmFpbiA9IDA7CglpbnQgZ290X2NvbnRpbnVlID0gMDsKCWludCBnb3RfcmVhZHkgPSAwOwoJc3RydWN0IHN0cmJ1ZiByZXFfYnVmID0gU1RSQlVGX0lOSVQ7CglzaXplX3Qgc3RhdGVfbGVuID0gMDsKCglpZiAoYXJncy0+c3RhdGVsZXNzX3JwYyAmJiBtdWx0aV9hY2sgPT0gMSkKCQlkaWUoXygiLS1zdGF0ZWxlc3MtcnBjIHJlcXVpcmVzIG11bHRpX2Fja19kZXRhaWxlZCIpKTsKCWlmIChtYXJrZWQpCgkJZm9yX2VhY2hfcmVmKGNsZWFyX21hcmtzLCBOVUxMKTsKCW1hcmtlZCA9IDE7CgoJZm9yX2VhY2hfcmVmKHJldl9saXN0X2luc2VydF9yZWZfb2lkLCBOVUxMKTsKCWZvcl9lYWNoX2NhY2hlZF9hbHRlcm5hdGUoaW5zZXJ0X29uZV9hbHRlcm5hdGVfb2JqZWN0KTsKCglmZXRjaGluZyA9IDA7Cglmb3IgKCA7IHJlZnMgOyByZWZzID0gcmVmcy0+bmV4dCkgewoJCXN0cnVjdCBvYmplY3RfaWQgKnJlbW90ZSA9ICZyZWZzLT5vbGRfb2lkOwoJCWNvbnN0IGNoYXIgKnJlbW90ZV9oZXg7CgkJc3RydWN0IG9iamVjdCAqbzsKCgkJLyoKCQkgKiBJZiB0aGF0IG9iamVjdCBpcyBjb21wbGV0ZSAoaS5lLiBpdCBpcyBhbiBhbmNlc3RvciBvZiBhCgkJICogbG9jYWwgcmVmKSwgd2UgdGVsbCB0aGVtIHdlIGhhdmUgaXQgYnV0IGRvIG5vdCBoYXZlIHRvCgkJICogdGVsbCB0aGVtIGFib3V0IGl0cyBhbmNlc3RvcnMsIHdoaWNoIHRoZXkgYWxyZWFkeSBrbm93CgkJICogYWJvdXQuCgkJICoKCQkgKiBXZSB1c2UgbG9va3VwX29iamVjdCBoZXJlIGJlY2F1c2Ugd2UgYXJlIG9ubHkKCQkgKiBpbnRlcmVzdGVkIGluIHRoZSBjYXNlIHdlICprbm93KiB0aGUgb2JqZWN0IGlzCgkJICogcmVhY2hhYmxlIGFuZCB3ZSBoYXZlIGFscmVhZHkgc2Nhbm5lZCBpdC4KCQkgKi8KCQlpZiAoKChvID0gbG9va3VwX29iamVjdChyZW1vdGUtPmhhc2gpKSAhPSBOVUxMKSAmJgoJCQkJKG8tPmZsYWdzICYgQ09NUExFVEUpKSB7CgkJCWNvbnRpbnVlOwoJCX0KCgkJcmVtb3RlX2hleCA9IG9pZF90b19oZXgocmVtb3RlKTsKCQlpZiAoIWZldGNoaW5nKSB7CgkJCXN0cnVjdCBzdHJidWYgYyA9IFNUUkJVRl9JTklUOwoJCQlpZiAobXVsdGlfYWNrID09IDIpICAgICBzdHJidWZfYWRkc3RyKCZjLCAiIG11bHRpX2Fja19kZXRhaWxlZCIpOwoJCQlpZiAobXVsdGlfYWNrID09IDEpICAgICBzdHJidWZfYWRkc3RyKCZjLCAiIG11bHRpX2FjayIpOwoJCQlpZiAobm9fZG9uZSkgICAgICAgICAgICBzdHJidWZfYWRkc3RyKCZjLCAiIG5vLWRvbmUiKTsKCQkJaWYgKHVzZV9zaWRlYmFuZCA9PSAyKSAgc3RyYnVmX2FkZHN0cigmYywgIiBzaWRlLWJhbmQtNjRrIik7CgkJCWlmICh1c2Vfc2lkZWJhbmQgPT0gMSkgIHN0cmJ1Zl9hZGRzdHIoJmMsICIgc2lkZS1iYW5kIik7CgkJCWlmIChhcmdzLT5kZWVwZW5fcmVsYXRpdmUpIHN0cmJ1Zl9hZGRzdHIoJmMsICIgZGVlcGVuLXJlbGF0aXZlIik7CgkJCWlmIChhcmdzLT51c2VfdGhpbl9wYWNrKSBzdHJidWZfYWRkc3RyKCZjLCAiIHRoaW4tcGFjayIpOwoJCQlpZiAoYXJncy0+bm9fcHJvZ3Jlc3MpICAgc3RyYnVmX2FkZHN0cigmYywgIiBuby1wcm9ncmVzcyIpOwoJCQlpZiAoYXJncy0+aW5jbHVkZV90YWcpICAgc3RyYnVmX2FkZHN0cigmYywgIiBpbmNsdWRlLXRhZyIpOwoJCQlpZiAocHJlZmVyX29mc19kZWx0YSkgICBzdHJidWZfYWRkc3RyKCZjLCAiIG9mcy1kZWx0YSIpOwoJCQlpZiAoZGVlcGVuX3NpbmNlX29rKSAgICBzdHJidWZfYWRkc3RyKCZjLCAiIGRlZXBlbi1zaW5jZSIpOwoJCQlpZiAoZGVlcGVuX25vdF9vaykgICAgICBzdHJidWZfYWRkc3RyKCZjLCAiIGRlZXBlbi1ub3QiKTsKCQkJaWYgKGFnZW50X3N1cHBvcnRlZCkgICAgc3RyYnVmX2FkZGYoJmMsICIgYWdlbnQ9JXMiLAoJCQkJCQkJICAgIGdpdF91c2VyX2FnZW50X3Nhbml0aXplZCgpKTsKCQkJcGFja2V0X2J1Zl93cml0ZSgmcmVxX2J1ZiwgIndhbnQgJXMlc1xuIiwgcmVtb3RlX2hleCwgYy5idWYpOwoJCQlzdHJidWZfcmVsZWFzZSgmYyk7CgkJfSBlbHNlCgkJCXBhY2tldF9idWZfd3JpdGUoJnJlcV9idWYsICJ3YW50ICVzXG4iLCByZW1vdGVfaGV4KTsKCQlmZXRjaGluZysrOwoJfQoKCWlmICghZmV0Y2hpbmcpIHsKCQlzdHJidWZfcmVsZWFzZSgmcmVxX2J1Zik7CgkJcGFja2V0X2ZsdXNoKGZkWzFdKTsKCQlyZXR1cm4gMTsKCX0KCglpZiAoaXNfcmVwb3NpdG9yeV9zaGFsbG93KCkpCgkJd3JpdGVfc2hhbGxvd19jb21taXRzKCZyZXFfYnVmLCAxLCBOVUxMKTsKCWlmIChhcmdzLT5kZXB0aCA+IDApCgkJcGFja2V0X2J1Zl93cml0ZSgmcmVxX2J1ZiwgImRlZXBlbiAlZCIsIGFyZ3MtPmRlcHRoKTsKCWlmIChhcmdzLT5kZWVwZW5fc2luY2UpIHsKCQl0aW1lc3RhbXBfdCBtYXhfYWdlID0gYXBwcm94aWRhdGUoYXJncy0+ZGVlcGVuX3NpbmNlKTsKCQlwYWNrZXRfYnVmX3dyaXRlKCZyZXFfYnVmLCAiZGVlcGVuLXNpbmNlICUiUFJJdGltZSwgbWF4X2FnZSk7Cgl9CglpZiAoYXJncy0+ZGVlcGVuX25vdCkgewoJCWludCBpOwoJCWZvciAoaSA9IDA7IGkgPCBhcmdzLT5kZWVwZW5fbm90LT5ucjsgaSsrKSB7CgkJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICpzID0gYXJncy0+ZGVlcGVuX25vdC0+aXRlbXMgKyBpOwoJCQlwYWNrZXRfYnVmX3dyaXRlKCZyZXFfYnVmLCAiZGVlcGVuLW5vdCAlcyIsIHMtPnN0cmluZyk7CgkJfQoJfQoJcGFja2V0X2J1Zl9mbHVzaCgmcmVxX2J1Zik7CglzdGF0ZV9sZW4gPSByZXFfYnVmLmxlbjsKCglpZiAoYXJncy0+ZGVlcGVuKSB7CgkJY2hhciAqbGluZTsKCQljb25zdCBjaGFyICphcmc7CgkJc3RydWN0IG9iamVjdF9pZCBvaWQ7CgoJCXNlbmRfcmVxdWVzdChhcmdzLCBmZFsxXSwgJnJlcV9idWYpOwoJCXdoaWxlICgobGluZSA9IHBhY2tldF9yZWFkX2xpbmUoZmRbMF0sIE5VTEwpKSkgewoJCQlpZiAoc2tpcF9wcmVmaXgobGluZSwgInNoYWxsb3cgIiwgJmFyZykpIHsKCQkJCWlmIChnZXRfb2lkX2hleChhcmcsICZvaWQpKQoJCQkJCWRpZShfKCJpbnZhbGlkIHNoYWxsb3cgbGluZTogJXMiKSwgbGluZSk7CgkJCQlyZWdpc3Rlcl9zaGFsbG93KCZvaWQpOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKHNraXBfcHJlZml4KGxpbmUsICJ1bnNoYWxsb3cgIiwgJmFyZykpIHsKCQkJCWlmIChnZXRfb2lkX2hleChhcmcsICZvaWQpKQoJCQkJCWRpZShfKCJpbnZhbGlkIHVuc2hhbGxvdyBsaW5lOiAlcyIpLCBsaW5lKTsKCQkJCWlmICghbG9va3VwX29iamVjdChvaWQuaGFzaCkpCgkJCQkJZGllKF8oIm9iamVjdCBub3QgZm91bmQ6ICVzIiksIGxpbmUpOwoJCQkJLyogbWFrZSBzdXJlIHRoYXQgaXQgaXMgcGFyc2VkIGFzIHNoYWxsb3cgKi8KCQkJCWlmICghcGFyc2Vfb2JqZWN0KCZvaWQpKQoJCQkJCWRpZShfKCJlcnJvciBpbiBvYmplY3Q6ICVzIiksIGxpbmUpOwoJCQkJaWYgKHVucmVnaXN0ZXJfc2hhbGxvdygmb2lkKSkKCQkJCQlkaWUoXygibm8gc2hhbGxvdyBmb3VuZDogJXMiKSwgbGluZSk7CgkJCQljb250aW51ZTsKCQkJfQoJCQlkaWUoXygiZXhwZWN0ZWQgc2hhbGxvdy91bnNoYWxsb3csIGdvdCAlcyIpLCBsaW5lKTsKCQl9Cgl9IGVsc2UgaWYgKCFhcmdzLT5zdGF0ZWxlc3NfcnBjKQoJCXNlbmRfcmVxdWVzdChhcmdzLCBmZFsxXSwgJnJlcV9idWYpOwoKCWlmICghYXJncy0+c3RhdGVsZXNzX3JwYykgewoJCS8qIElmIHdlIGFyZW4ndCB1c2luZyB0aGUgc3RhdGVsZXNzLXJwYyBpbnRlcmZhY2UKCQkgKiB3ZSBkb24ndCBuZWVkIHRvIHJldGFpbiB0aGUgaGVhZGVycy4KCQkgKi8KCQlzdHJidWZfc2V0bGVuKCZyZXFfYnVmLCAwKTsKCQlzdGF0ZV9sZW4gPSAwOwoJfQoKCWZsdXNoZXMgPSAwOwoJcmV0dmFsID0gLTE7Cgl3aGlsZSAoKG9pZCA9IGdldF9yZXYoKSkpIHsKCQlwYWNrZXRfYnVmX3dyaXRlKCZyZXFfYnVmLCAiaGF2ZSAlc1xuIiwgb2lkX3RvX2hleChvaWQpKTsKCQlwcmludF92ZXJib3NlKGFyZ3MsICJoYXZlICVzIiwgb2lkX3RvX2hleChvaWQpKTsKCQlpbl92YWluKys7CgkJaWYgKGZsdXNoX2F0IDw9ICsrY291bnQpIHsKCQkJaW50IGFjazsKCgkJCXBhY2tldF9idWZfZmx1c2goJnJlcV9idWYpOwoJCQlzZW5kX3JlcXVlc3QoYXJncywgZmRbMV0sICZyZXFfYnVmKTsKCQkJc3RyYnVmX3NldGxlbigmcmVxX2J1Ziwgc3RhdGVfbGVuKTsKCQkJZmx1c2hlcysrOwoJCQlmbHVzaF9hdCA9IG5leHRfZmx1c2goYXJncywgY291bnQpOwoKCQkJLyoKCQkJICogV2Uga2VlcCBvbmUgd2luZG93ICJhaGVhZCIgb2YgdGhlIG90aGVyIHNpZGUsIGFuZAoJCQkgKiB3aWxsIHdhaXQgZm9yIGFuIEFDSyBvbmx5IG9uIHRoZSBuZXh0IG9uZQoJCQkgKi8KCQkJaWYgKCFhcmdzLT5zdGF0ZWxlc3NfcnBjICYmIGNvdW50ID09IElOSVRJQUxfRkxVU0gpCgkJCQljb250aW51ZTsKCgkJCWNvbnN1bWVfc2hhbGxvd19saXN0KGFyZ3MsIGZkWzBdKTsKCQkJZG8gewoJCQkJYWNrID0gZ2V0X2FjayhmZFswXSwgcmVzdWx0X29pZCk7CgkJCQlpZiAoYWNrKQoJCQkJCXByaW50X3ZlcmJvc2UoYXJncywgXygiZ290ICVzICVkICVzIiksICJhY2siLAoJCQkJCQkgICAgICBhY2ssIG9pZF90b19oZXgocmVzdWx0X29pZCkpOwoJCQkJc3dpdGNoIChhY2spIHsKCQkJCWNhc2UgQUNLOgoJCQkJCWZsdXNoZXMgPSAwOwoJCQkJCW11bHRpX2FjayA9IDA7CgkJCQkJcmV0dmFsID0gMDsKCQkJCQlnb3RvIGRvbmU7CgkJCQljYXNlIEFDS19jb21tb246CgkJCQljYXNlIEFDS19yZWFkeToKCQkJCWNhc2UgQUNLX2NvbnRpbnVlOiB7CgkJCQkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0KCQkJCQkJbG9va3VwX2NvbW1pdChyZXN1bHRfb2lkKTsKCQkJCQlpZiAoIWNvbW1pdCkKCQkJCQkJZGllKF8oImludmFsaWQgY29tbWl0ICVzIiksIG9pZF90b19oZXgocmVzdWx0X29pZCkpOwoJCQkJCWlmIChhcmdzLT5zdGF0ZWxlc3NfcnBjCgkJCQkJICYmIGFjayA9PSBBQ0tfY29tbW9uCgkJCQkJICYmICEoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBDT01NT04pKSB7CgkJCQkJCS8qIFdlIG5lZWQgdG8gcmVwbGF5IHRoZSBoYXZlIGZvciB0aGlzIG9iamVjdAoJCQkJCQkgKiBvbiB0aGUgbmV4dCBSUEMgcmVxdWVzdCBzbyB0aGUgcGVlciBrbm93cwoJCQkJCQkgKiBpdCBpcyBpbiBjb21tb24gd2l0aCB1cy4KCQkJCQkJICovCgkJCQkJCWNvbnN0IGNoYXIgKmhleCA9IG9pZF90b19oZXgocmVzdWx0X29pZCk7CgkJCQkJCXBhY2tldF9idWZfd3JpdGUoJnJlcV9idWYsICJoYXZlICVzXG4iLCBoZXgpOwoJCQkJCQlzdGF0ZV9sZW4gPSByZXFfYnVmLmxlbjsKCQkJCQkJLyoKCQkJCQkJICogUmVzZXQgaW5fdmFpbiBiZWNhdXNlIGFuIGFjawoJCQkJCQkgKiBmb3IgdGhpcyBjb21taXQgaGFzIG5vdCBiZWVuCgkJCQkJCSAqIHNlZW4uCgkJCQkJCSAqLwoJCQkJCQlpbl92YWluID0gMDsKCQkJCQl9IGVsc2UgaWYgKCFhcmdzLT5zdGF0ZWxlc3NfcnBjCgkJCQkJCSAgIHx8IGFjayAhPSBBQ0tfY29tbW9uKQoJCQkJCQlpbl92YWluID0gMDsKCQkJCQltYXJrX2NvbW1vbihjb21taXQsIDAsIDEpOwoJCQkJCXJldHZhbCA9IDA7CgkJCQkJZ290X2NvbnRpbnVlID0gMTsKCQkJCQlpZiAoYWNrID09IEFDS19yZWFkeSkgewoJCQkJCQljbGVhcl9wcmlvX3F1ZXVlKCZyZXZfbGlzdCk7CgkJCQkJCWdvdF9yZWFkeSA9IDE7CgkJCQkJfQoJCQkJCWJyZWFrOwoJCQkJCX0KCQkJCX0KCQkJfSB3aGlsZSAoYWNrKTsKCQkJZmx1c2hlcy0tOwoJCQlpZiAoZ290X2NvbnRpbnVlICYmIE1BWF9JTl9WQUlOIDwgaW5fdmFpbikgewoJCQkJcHJpbnRfdmVyYm9zZShhcmdzLCBfKCJnaXZpbmcgdXAiKSk7CgkJCQlicmVhazsgLyogZ2l2ZSB1cCAqLwoJCQl9CgkJfQoJfQpkb25lOgoJaWYgKCFnb3RfcmVhZHkgfHwgIW5vX2RvbmUpIHsKCQlwYWNrZXRfYnVmX3dyaXRlKCZyZXFfYnVmLCAiZG9uZVxuIik7CgkJc2VuZF9yZXF1ZXN0KGFyZ3MsIGZkWzFdLCAmcmVxX2J1Zik7Cgl9CglwcmludF92ZXJib3NlKGFyZ3MsIF8oImRvbmUiKSk7CglpZiAocmV0dmFsICE9IDApIHsKCQltdWx0aV9hY2sgPSAwOwoJCWZsdXNoZXMrKzsKCX0KCXN0cmJ1Zl9yZWxlYXNlKCZyZXFfYnVmKTsKCglpZiAoIWdvdF9yZWFkeSB8fCAhbm9fZG9uZSkKCQljb25zdW1lX3NoYWxsb3dfbGlzdChhcmdzLCBmZFswXSk7Cgl3aGlsZSAoZmx1c2hlcyB8fCBtdWx0aV9hY2spIHsKCQlpbnQgYWNrID0gZ2V0X2FjayhmZFswXSwgcmVzdWx0X29pZCk7CgkJaWYgKGFjaykgewoJCQlwcmludF92ZXJib3NlKGFyZ3MsIF8oImdvdCAlcyAoJWQpICVzIiksICJhY2siLAoJCQkJICAgICAgYWNrLCBvaWRfdG9faGV4KHJlc3VsdF9vaWQpKTsKCQkJaWYgKGFjayA9PSBBQ0spCgkJCQlyZXR1cm4gMDsKCQkJbXVsdGlfYWNrID0gMTsKCQkJY29udGludWU7CgkJfQoJCWZsdXNoZXMtLTsKCX0KCS8qIGl0IGlzIG5vIGVycm9yIHRvIGZldGNoIGludG8gYSBjb21wbGV0ZWx5IGVtcHR5IHJlcG8gKi8KCXJldHVybiBjb3VudCA/IHJldHZhbCA6IDA7Cn0KCnN0YXRpYyBzdHJ1Y3QgY29tbWl0X2xpc3QgKmNvbXBsZXRlOwoKc3RhdGljIGludCBtYXJrX2NvbXBsZXRlKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJc3RydWN0IG9iamVjdCAqbyA9IHBhcnNlX29iamVjdChvaWQpOwoKCXdoaWxlIChvICYmIG8tPnR5cGUgPT0gT0JKX1RBRykgewoJCXN0cnVjdCB0YWcgKnQgPSAoc3RydWN0IHRhZyAqKSBvOwoJCWlmICghdC0+dGFnZ2VkKQoJCQlicmVhazsgLyogYnJva2VuIHJlcG9zaXRvcnkgKi8KCQlvLT5mbGFncyB8PSBDT01QTEVURTsKCQlvID0gcGFyc2Vfb2JqZWN0KCZ0LT50YWdnZWQtPm9pZCk7Cgl9CglpZiAobyAmJiBvLT50eXBlID09IE9CSl9DT01NSVQpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSAoc3RydWN0IGNvbW1pdCAqKW87CgkJaWYgKCEoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBDT01QTEVURSkpIHsKCQkJY29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gQ09NUExFVEU7CgkJCWNvbW1pdF9saXN0X2luc2VydChjb21taXQsICZjb21wbGV0ZSk7CgkJfQoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgbWFya19jb21wbGV0ZV9vaWQoY29uc3QgY2hhciAqcmVmbmFtZSwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgICAgIGludCBmbGFnLCB2b2lkICpjYl9kYXRhKQp7CglyZXR1cm4gbWFya19jb21wbGV0ZShvaWQpOwp9CgpzdGF0aWMgdm9pZCBtYXJrX3JlY2VudF9jb21wbGV0ZV9jb21taXRzKHN0cnVjdCBmZXRjaF9wYWNrX2FyZ3MgKmFyZ3MsCgkJCQkJIHRpbWVzdGFtcF90IGN1dG9mZikKewoJd2hpbGUgKGNvbXBsZXRlICYmIGN1dG9mZiA8PSBjb21wbGV0ZS0+aXRlbS0+ZGF0ZSkgewoJCXByaW50X3ZlcmJvc2UoYXJncywgXygiTWFya2luZyAlcyBhcyBjb21wbGV0ZSIpLAoJCQkgICAgICBvaWRfdG9faGV4KCZjb21wbGV0ZS0+aXRlbS0+b2JqZWN0Lm9pZCkpOwoJCXBvcF9tb3N0X3JlY2VudF9jb21taXQoJmNvbXBsZXRlLCBDT01QTEVURSk7Cgl9Cn0KCnN0YXRpYyB2b2lkIGFkZF9yZWZzX3RvX29pZHNldChzdHJ1Y3Qgb2lkc2V0ICpvaWRzLCBzdHJ1Y3QgcmVmICpyZWZzKQp7Cglmb3IgKDsgcmVmczsgcmVmcyA9IHJlZnMtPm5leHQpCgkJb2lkc2V0X2luc2VydChvaWRzLCAmcmVmcy0+b2xkX29pZCk7Cn0KCnN0YXRpYyBpbnQgdGlwX29pZHNfY29udGFpbihzdHJ1Y3Qgb2lkc2V0ICp0aXBfb2lkcywKCQkJICAgIHN0cnVjdCByZWYgKnVubWF0Y2hlZCwgc3RydWN0IHJlZiAqbmV3bGlzdCwKCQkJICAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKmlkKQp7CgkvKgoJICogTm90ZSB0aGF0IHRoaXMgb25seSBsb29rcyBhdCB0aGUgcmVmIGxpc3RzIHRoZSBmaXJzdCB0aW1lIGl0J3MKCSAqIGNhbGxlZC4gVGhpcyB3b3JrcyBvdXQgaW4gZmlsdGVyX3JlZnMoKSBiZWNhdXNlIGV2ZW4gdGhvdWdoIGl0IG1heQoJICogYWRkIHRvICJuZXdsaXN0IiBiZXR3ZWVuIGNhbGxzLCB0aGUgYWRkaXRpb25zIHdpbGwgYWx3YXlzIGJlIGZvcgoJICogb2lkcyB0aGF0IGFyZSBhbHJlYWR5IGluIHRoZSBzZXQuCgkgKi8KCWlmICghdGlwX29pZHMtPm1hcC5tYXAudGFibGVzaXplKSB7CgkJYWRkX3JlZnNfdG9fb2lkc2V0KHRpcF9vaWRzLCB1bm1hdGNoZWQpOwoJCWFkZF9yZWZzX3RvX29pZHNldCh0aXBfb2lkcywgbmV3bGlzdCk7Cgl9CglyZXR1cm4gb2lkc2V0X2NvbnRhaW5zKHRpcF9vaWRzLCBpZCk7Cn0KCnN0YXRpYyB2b2lkIGZpbHRlcl9yZWZzKHN0cnVjdCBmZXRjaF9wYWNrX2FyZ3MgKmFyZ3MsCgkJCXN0cnVjdCByZWYgKipyZWZzLAoJCQlzdHJ1Y3QgcmVmICoqc291Z2h0LCBpbnQgbnJfc291Z2h0KQp7CglzdHJ1Y3QgcmVmICpuZXdsaXN0ID0gTlVMTDsKCXN0cnVjdCByZWYgKipuZXd0YWlsID0gJm5ld2xpc3Q7CglzdHJ1Y3QgcmVmICp1bm1hdGNoZWQgPSBOVUxMOwoJc3RydWN0IHJlZiAqcmVmLCAqbmV4dDsKCXN0cnVjdCBvaWRzZXQgdGlwX29pZHMgPSBPSURTRVRfSU5JVDsKCWludCBpOwoKCWkgPSAwOwoJZm9yIChyZWYgPSAqcmVmczsgcmVmOyByZWYgPSBuZXh0KSB7CgkJaW50IGtlZXAgPSAwOwoJCW5leHQgPSByZWYtPm5leHQ7CgoJCWlmIChzdGFydHNfd2l0aChyZWYtPm5hbWUsICJyZWZzLyIpICYmCgkJICAgIGNoZWNrX3JlZm5hbWVfZm9ybWF0KHJlZi0+bmFtZSwgMCkpCgkJCTsgLyogdHJhc2ggKi8KCQllbHNlIHsKCQkJd2hpbGUgKGkgPCBucl9zb3VnaHQpIHsKCQkJCWludCBjbXAgPSBzdHJjbXAocmVmLT5uYW1lLCBzb3VnaHRbaV0tPm5hbWUpOwoJCQkJaWYgKGNtcCA8IDApCgkJCQkJYnJlYWs7IC8qIGRlZmluaXRlbHkgZG8gbm90IGhhdmUgaXQgKi8KCQkJCWVsc2UgaWYgKGNtcCA9PSAwKSB7CgkJCQkJa2VlcCA9IDE7IC8qIGRlZmluaXRlbHkgaGF2ZSBpdCAqLwoJCQkJCXNvdWdodFtpXS0+bWF0Y2hfc3RhdHVzID0gUkVGX01BVENIRUQ7CgkJCQl9CgkJCQlpKys7CgkJCX0KCQl9CgoJCWlmICgha2VlcCAmJiBhcmdzLT5mZXRjaF9hbGwgJiYKCQkgICAgKCFhcmdzLT5kZWVwZW4gfHwgIXN0YXJ0c193aXRoKHJlZi0+bmFtZSwgInJlZnMvdGFncy8iKSkpCgkJCWtlZXAgPSAxOwoKCQlpZiAoa2VlcCkgewoJCQkqbmV3dGFpbCA9IHJlZjsKCQkJcmVmLT5uZXh0ID0gTlVMTDsKCQkJbmV3dGFpbCA9ICZyZWYtPm5leHQ7CgkJfSBlbHNlIHsKCQkJcmVmLT5uZXh0ID0gdW5tYXRjaGVkOwoJCQl1bm1hdGNoZWQgPSByZWY7CgkJfQoJfQoKCS8qIEFwcGVuZCB1bm1hdGNoZWQgcmVxdWVzdHMgdG8gdGhlIGxpc3QgKi8KCWZvciAoaSA9IDA7IGkgPCBucl9zb3VnaHQ7IGkrKykgewoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCWNvbnN0IGNoYXIgKnA7CgoJCXJlZiA9IHNvdWdodFtpXTsKCQlpZiAocmVmLT5tYXRjaF9zdGF0dXMgIT0gUkVGX05PVF9NQVRDSEVEKQoJCQljb250aW51ZTsKCQlpZiAocGFyc2Vfb2lkX2hleChyZWYtPm5hbWUsICZvaWQsICZwKSB8fAoJCSAgICAqcCAhPSAnXDAnIHx8CgkJICAgIG9pZGNtcCgmb2lkLCAmcmVmLT5vbGRfb2lkKSkKCQkJY29udGludWU7CgoJCWlmICgoYWxsb3dfdW5hZHZlcnRpc2VkX29iamVjdF9yZXF1ZXN0ICYKCQkgICAgIChBTExPV19USVBfU0hBMSB8IEFMTE9XX1JFQUNIQUJMRV9TSEExKSkgfHwKCQkgICAgdGlwX29pZHNfY29udGFpbigmdGlwX29pZHMsIHVubWF0Y2hlZCwgbmV3bGlzdCwKCQkJCSAgICAgJnJlZi0+b2xkX29pZCkpIHsKCQkJcmVmLT5tYXRjaF9zdGF0dXMgPSBSRUZfTUFUQ0hFRDsKCQkJKm5ld3RhaWwgPSBjb3B5X3JlZihyZWYpOwoJCQluZXd0YWlsID0gJigqbmV3dGFpbCktPm5leHQ7CgkJfSBlbHNlIHsKCQkJcmVmLT5tYXRjaF9zdGF0dXMgPSBSRUZfVU5BRFZFUlRJU0VEX05PVF9BTExPV0VEOwoJCX0KCX0KCglvaWRzZXRfY2xlYXIoJnRpcF9vaWRzKTsKCWZvciAocmVmID0gdW5tYXRjaGVkOyByZWY7IHJlZiA9IG5leHQpIHsKCQluZXh0ID0gcmVmLT5uZXh0OwoJCWZyZWUocmVmKTsKCX0KCgkqcmVmcyA9IG5ld2xpc3Q7Cn0KCnN0YXRpYyB2b2lkIG1hcmtfYWx0ZXJuYXRlX2NvbXBsZXRlKHN0cnVjdCBvYmplY3QgKm9iaikKewoJbWFya19jb21wbGV0ZSgmb2JqLT5vaWQpOwp9CgpzdGF0aWMgaW50IGV2ZXJ5dGhpbmdfbG9jYWwoc3RydWN0IGZldGNoX3BhY2tfYXJncyAqYXJncywKCQkJICAgIHN0cnVjdCByZWYgKipyZWZzLAoJCQkgICAgc3RydWN0IHJlZiAqKnNvdWdodCwgaW50IG5yX3NvdWdodCkKewoJc3RydWN0IHJlZiAqcmVmOwoJaW50IHJldHZhbDsKCXRpbWVzdGFtcF90IGN1dG9mZiA9IDA7CgoJc2F2ZV9jb21taXRfYnVmZmVyID0gMDsKCglmb3IgKHJlZiA9ICpyZWZzOyByZWY7IHJlZiA9IHJlZi0+bmV4dCkgewoJCXN0cnVjdCBvYmplY3QgKm87CgoJCWlmICghaGFzX29iamVjdF9maWxlKCZyZWYtPm9sZF9vaWQpKQoJCQljb250aW51ZTsKCgkJbyA9IHBhcnNlX29iamVjdCgmcmVmLT5vbGRfb2lkKTsKCQlpZiAoIW8pCgkJCWNvbnRpbnVlOwoKCQkvKiBXZSBhbHJlYWR5IGhhdmUgaXQgLS0gd2hpY2ggbWF5IG1lYW4gdGhhdCB3ZSB3ZXJlCgkJICogaW4gc3luYyB3aXRoIHRoZSBvdGhlciBzaWRlIGF0IHNvbWUgdGltZSBhZnRlcgoJCSAqIHRoYXQgKGl0IGlzIE9LIGlmIHdlIGd1ZXNzIHdyb25nIGhlcmUpLgoJCSAqLwoJCWlmIChvLT50eXBlID09IE9CSl9DT01NSVQpIHsKCQkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gKHN0cnVjdCBjb21taXQgKilvOwoJCQlpZiAoIWN1dG9mZiB8fCBjdXRvZmYgPCBjb21taXQtPmRhdGUpCgkJCQljdXRvZmYgPSBjb21taXQtPmRhdGU7CgkJfQoJfQoKCWlmICghYXJncy0+ZGVlcGVuKSB7CgkJZm9yX2VhY2hfcmVmKG1hcmtfY29tcGxldGVfb2lkLCBOVUxMKTsKCQlmb3JfZWFjaF9jYWNoZWRfYWx0ZXJuYXRlKG1hcmtfYWx0ZXJuYXRlX2NvbXBsZXRlKTsKCQljb21taXRfbGlzdF9zb3J0X2J5X2RhdGUoJmNvbXBsZXRlKTsKCQlpZiAoY3V0b2ZmKQoJCQltYXJrX3JlY2VudF9jb21wbGV0ZV9jb21taXRzKGFyZ3MsIGN1dG9mZik7Cgl9CgoJLyoKCSAqIE1hcmsgYWxsIGNvbXBsZXRlIHJlbW90ZSByZWZzIGFzIGNvbW1vbiByZWZzLgoJICogRG9uJ3QgbWFyayB0aGVtIGNvbW1vbiB5ZXQ7IHRoZSBzZXJ2ZXIgaGFzIHRvIGJlIHRvbGQgc28gZmlyc3QuCgkgKi8KCWZvciAocmVmID0gKnJlZnM7IHJlZjsgcmVmID0gcmVmLT5uZXh0KSB7CgkJc3RydWN0IG9iamVjdCAqbyA9IGRlcmVmX3RhZyhsb29rdXBfb2JqZWN0KHJlZi0+b2xkX29pZC5oYXNoKSwKCQkJCQkgICAgIE5VTEwsIDApOwoKCQlpZiAoIW8gfHwgby0+dHlwZSAhPSBPQkpfQ09NTUlUIHx8ICEoby0+ZmxhZ3MgJiBDT01QTEVURSkpCgkJCWNvbnRpbnVlOwoKCQlpZiAoIShvLT5mbGFncyAmIFNFRU4pKSB7CgkJCXJldl9saXN0X3B1c2goKHN0cnVjdCBjb21taXQgKilvLCBDT01NT05fUkVGIHwgU0VFTik7CgoJCQltYXJrX2NvbW1vbigoc3RydWN0IGNvbW1pdCAqKW8sIDEsIDEpOwoJCX0KCX0KCglmaWx0ZXJfcmVmcyhhcmdzLCByZWZzLCBzb3VnaHQsIG5yX3NvdWdodCk7CgoJZm9yIChyZXR2YWwgPSAxLCByZWYgPSAqcmVmczsgcmVmIDsgcmVmID0gcmVmLT5uZXh0KSB7CgkJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqcmVtb3RlID0gJnJlZi0+b2xkX29pZDsKCQlzdHJ1Y3Qgb2JqZWN0ICpvOwoKCQlvID0gbG9va3VwX29iamVjdChyZW1vdGUtPmhhc2gpOwoJCWlmICghbyB8fCAhKG8tPmZsYWdzICYgQ09NUExFVEUpKSB7CgkJCXJldHZhbCA9IDA7CgkJCXByaW50X3ZlcmJvc2UoYXJncywgIndhbnQgJXMgKCVzKSIsIG9pZF90b19oZXgocmVtb3RlKSwKCQkJCSAgICAgIHJlZi0+bmFtZSk7CgkJCWNvbnRpbnVlOwoJCX0KCQlwcmludF92ZXJib3NlKGFyZ3MsIF8oImFscmVhZHkgaGF2ZSAlcyAoJXMpIiksIG9pZF90b19oZXgocmVtb3RlKSwKCQkJICAgICAgcmVmLT5uYW1lKTsKCX0KCXJldHVybiByZXR2YWw7Cn0KCnN0YXRpYyBpbnQgc2lkZWJhbmRfZGVtdXgoaW50IGluLCBpbnQgb3V0LCB2b2lkICpkYXRhKQp7CglpbnQgKnhkID0gZGF0YTsKCWludCByZXQ7CgoJcmV0ID0gcmVjdl9zaWRlYmFuZCgiZmV0Y2gtcGFjayIsIHhkWzBdLCBvdXQpOwoJY2xvc2Uob3V0KTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQgZ2V0X3BhY2soc3RydWN0IGZldGNoX3BhY2tfYXJncyAqYXJncywKCQkgICAgaW50IHhkWzJdLCBjaGFyICoqcGFja19sb2NrZmlsZSkKewoJc3RydWN0IGFzeW5jIGRlbXV4OwoJaW50IGRvX2tlZXAgPSBhcmdzLT5rZWVwX3BhY2s7Cgljb25zdCBjaGFyICpjbWRfbmFtZTsKCXN0cnVjdCBwYWNrX2hlYWRlciBoZWFkZXI7CglpbnQgcGFzc19oZWFkZXIgPSAwOwoJc3RydWN0IGNoaWxkX3Byb2Nlc3MgY21kID0gQ0hJTERfUFJPQ0VTU19JTklUOwoJaW50IHJldDsKCgltZW1zZXQoJmRlbXV4LCAwLCBzaXplb2YoZGVtdXgpKTsKCWlmICh1c2Vfc2lkZWJhbmQpIHsKCQkvKiB4ZFtdIGlzIHRhbGtpbmcgd2l0aCB1cGxvYWQtcGFjazsgc3VicHJvY2VzcyByZWFkcyBmcm9tCgkJICogeGRbMF0sIHNwaXRzIG91dCBiYW5kIzIgdG8gc3RkZXJyLCBhbmQgZmVlZHMgdXMgYmFuZCMxCgkJICogdGhyb3VnaCBkZW11eC0+b3V0LgoJCSAqLwoJCWRlbXV4LnByb2MgPSBzaWRlYmFuZF9kZW11eDsKCQlkZW11eC5kYXRhID0geGQ7CgkJZGVtdXgub3V0ID0gLTE7CgkJZGVtdXguaXNvbGF0ZV9zaWdwaXBlID0gMTsKCQlpZiAoc3RhcnRfYXN5bmMoJmRlbXV4KSkKCQkJZGllKF8oImZldGNoLXBhY2s6IHVuYWJsZSB0byBmb3JrIG9mZiBzaWRlYmFuZCBkZW11bHRpcGxleGVyIikpOwoJfQoJZWxzZQoJCWRlbXV4Lm91dCA9IHhkWzBdOwoKCWlmICghYXJncy0+a2VlcF9wYWNrICYmIHVucGFja19saW1pdCkgewoKCQlpZiAocmVhZF9wYWNrX2hlYWRlcihkZW11eC5vdXQsICZoZWFkZXIpKQoJCQlkaWUoXygicHJvdG9jb2wgZXJyb3I6IGJhZCBwYWNrIGhlYWRlciIpKTsKCQlwYXNzX2hlYWRlciA9IDE7CgkJaWYgKG50b2hsKGhlYWRlci5oZHJfZW50cmllcykgPCB1bnBhY2tfbGltaXQpCgkJCWRvX2tlZXAgPSAwOwoJCWVsc2UKCQkJZG9fa2VlcCA9IDE7Cgl9CgoJaWYgKGFsdGVybmF0ZV9zaGFsbG93X2ZpbGUpIHsKCQlhcmd2X2FycmF5X3B1c2goJmNtZC5hcmdzLCAiLS1zaGFsbG93LWZpbGUiKTsKCQlhcmd2X2FycmF5X3B1c2goJmNtZC5hcmdzLCBhbHRlcm5hdGVfc2hhbGxvd19maWxlKTsKCX0KCglpZiAoZG9fa2VlcCkgewoJCWlmIChwYWNrX2xvY2tmaWxlKQoJCQljbWQub3V0ID0gLTE7CgkJY21kX25hbWUgPSAiaW5kZXgtcGFjayI7CgkJYXJndl9hcnJheV9wdXNoKCZjbWQuYXJncywgY21kX25hbWUpOwoJCWFyZ3ZfYXJyYXlfcHVzaCgmY21kLmFyZ3MsICItLXN0ZGluIik7CgkJaWYgKCFhcmdzLT5xdWlldCAmJiAhYXJncy0+bm9fcHJvZ3Jlc3MpCgkJCWFyZ3ZfYXJyYXlfcHVzaCgmY21kLmFyZ3MsICItdiIpOwoJCWlmIChhcmdzLT51c2VfdGhpbl9wYWNrKQoJCQlhcmd2X2FycmF5X3B1c2goJmNtZC5hcmdzLCAiLS1maXgtdGhpbiIpOwoJCWlmIChhcmdzLT5sb2NrX3BhY2sgfHwgdW5wYWNrX2xpbWl0KSB7CgkJCWNoYXIgaG9zdG5hbWVbSE9TVF9OQU1FX01BWCArIDFdOwoJCQlpZiAoeGdldGhvc3RuYW1lKGhvc3RuYW1lLCBzaXplb2YoaG9zdG5hbWUpKSkKCQkJCXhzbnByaW50Zihob3N0bmFtZSwgc2l6ZW9mKGhvc3RuYW1lKSwgImxvY2FsaG9zdCIpOwoJCQlhcmd2X2FycmF5X3B1c2hmKCZjbWQuYXJncywKCQkJCQkiLS1rZWVwPWZldGNoLXBhY2sgJSJQUkl1TUFYICIgb24gJXMiLAoJCQkJCSh1aW50bWF4X3QpZ2V0cGlkKCksIGhvc3RuYW1lKTsKCQl9CgkJaWYgKGFyZ3MtPmNoZWNrX3NlbGZfY29udGFpbmVkX2FuZF9jb25uZWN0ZWQpCgkJCWFyZ3ZfYXJyYXlfcHVzaCgmY21kLmFyZ3MsICItLWNoZWNrLXNlbGYtY29udGFpbmVkLWFuZC1jb25uZWN0ZWQiKTsKCX0KCWVsc2UgewoJCWNtZF9uYW1lID0gInVucGFjay1vYmplY3RzIjsKCQlhcmd2X2FycmF5X3B1c2goJmNtZC5hcmdzLCBjbWRfbmFtZSk7CgkJaWYgKGFyZ3MtPnF1aWV0IHx8IGFyZ3MtPm5vX3Byb2dyZXNzKQoJCQlhcmd2X2FycmF5X3B1c2goJmNtZC5hcmdzLCAiLXEiKTsKCQlhcmdzLT5jaGVja19zZWxmX2NvbnRhaW5lZF9hbmRfY29ubmVjdGVkID0gMDsKCX0KCglpZiAocGFzc19oZWFkZXIpCgkJYXJndl9hcnJheV9wdXNoZigmY21kLmFyZ3MsICItLXBhY2tfaGVhZGVyPSUiUFJJdTMyIiwlIlBSSXUzMiwKCQkJCSBudG9obChoZWFkZXIuaGRyX3ZlcnNpb24pLAoJCQkJIG50b2hsKGhlYWRlci5oZHJfZW50cmllcykpOwoJaWYgKGZldGNoX2ZzY2tfb2JqZWN0cyA+PSAwCgkgICAgPyBmZXRjaF9mc2NrX29iamVjdHMKCSAgICA6IHRyYW5zZmVyX2ZzY2tfb2JqZWN0cyA+PSAwCgkgICAgPyB0cmFuc2Zlcl9mc2NrX29iamVjdHMKCSAgICA6IDApCgkJYXJndl9hcnJheV9wdXNoKCZjbWQuYXJncywgIi0tc3RyaWN0Iik7CgoJY21kLmluID0gZGVtdXgub3V0OwoJY21kLmdpdF9jbWQgPSAxOwoJaWYgKHN0YXJ0X2NvbW1hbmQoJmNtZCkpCgkJZGllKF8oImZldGNoLXBhY2s6IHVuYWJsZSB0byBmb3JrIG9mZiAlcyIpLCBjbWRfbmFtZSk7CglpZiAoZG9fa2VlcCAmJiBwYWNrX2xvY2tmaWxlKSB7CgkJKnBhY2tfbG9ja2ZpbGUgPSBpbmRleF9wYWNrX2xvY2tmaWxlKGNtZC5vdXQpOwoJCWNsb3NlKGNtZC5vdXQpOwoJfQoKCWlmICghdXNlX3NpZGViYW5kKQoJCS8qIENsb3NlZCBieSBzdGFydF9jb21tYW5kKCkgKi8KCQl4ZFswXSA9IC0xOwoKCXJldCA9IGZpbmlzaF9jb21tYW5kKCZjbWQpOwoJaWYgKCFyZXQgfHwgKGFyZ3MtPmNoZWNrX3NlbGZfY29udGFpbmVkX2FuZF9jb25uZWN0ZWQgJiYgcmV0ID09IDEpKQoJCWFyZ3MtPnNlbGZfY29udGFpbmVkX2FuZF9jb25uZWN0ZWQgPQoJCQlhcmdzLT5jaGVja19zZWxmX2NvbnRhaW5lZF9hbmRfY29ubmVjdGVkICYmCgkJCXJldCA9PSAwOwoJZWxzZQoJCWRpZShfKCIlcyBmYWlsZWQiKSwgY21kX25hbWUpOwoJaWYgKHVzZV9zaWRlYmFuZCAmJiBmaW5pc2hfYXN5bmMoJmRlbXV4KSkKCQlkaWUoXygiZXJyb3IgaW4gc2lkZWJhbmQgZGVtdWx0aXBsZXhlciIpKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGNtcF9yZWZfYnlfbmFtZShjb25zdCB2b2lkICphXywgY29uc3Qgdm9pZCAqYl8pCnsKCWNvbnN0IHN0cnVjdCByZWYgKmEgPSAqKChjb25zdCBzdHJ1Y3QgcmVmICoqKWFfKTsKCWNvbnN0IHN0cnVjdCByZWYgKmIgPSAqKChjb25zdCBzdHJ1Y3QgcmVmICoqKWJfKTsKCXJldHVybiBzdHJjbXAoYS0+bmFtZSwgYi0+bmFtZSk7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVmICpkb19mZXRjaF9wYWNrKHN0cnVjdCBmZXRjaF9wYWNrX2FyZ3MgKmFyZ3MsCgkJCQkgaW50IGZkWzJdLAoJCQkJIGNvbnN0IHN0cnVjdCByZWYgKm9yaWdfcmVmLAoJCQkJIHN0cnVjdCByZWYgKipzb3VnaHQsIGludCBucl9zb3VnaHQsCgkJCQkgc3RydWN0IHNoYWxsb3dfaW5mbyAqc2ksCgkJCQkgY2hhciAqKnBhY2tfbG9ja2ZpbGUpCnsKCXN0cnVjdCByZWYgKnJlZiA9IGNvcHlfcmVmX2xpc3Qob3JpZ19yZWYpOwoJc3RydWN0IG9iamVjdF9pZCBvaWQ7Cgljb25zdCBjaGFyICphZ2VudF9mZWF0dXJlOwoJaW50IGFnZW50X2xlbjsKCglzb3J0X3JlZl9saXN0KCZyZWYsIHJlZl9jb21wYXJlX25hbWUpOwoJUVNPUlQoc291Z2h0LCBucl9zb3VnaHQsIGNtcF9yZWZfYnlfbmFtZSk7CgoJaWYgKChhcmdzLT5kZXB0aCA+IDAgfHwgaXNfcmVwb3NpdG9yeV9zaGFsbG93KCkpICYmICFzZXJ2ZXJfc3VwcG9ydHMoInNoYWxsb3ciKSkKCQlkaWUoXygiU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgc2hhbGxvdyBjbGllbnRzIikpOwoJaWYgKGFyZ3MtPmRlcHRoID4gMCB8fCBhcmdzLT5kZWVwZW5fc2luY2UgfHwgYXJncy0+ZGVlcGVuX25vdCkKCQlhcmdzLT5kZWVwZW4gPSAxOwoJaWYgKHNlcnZlcl9zdXBwb3J0cygibXVsdGlfYWNrX2RldGFpbGVkIikpIHsKCQlwcmludF92ZXJib3NlKGFyZ3MsIF8oIlNlcnZlciBzdXBwb3J0cyBtdWx0aV9hY2tfZGV0YWlsZWQiKSk7CgkJbXVsdGlfYWNrID0gMjsKCQlpZiAoc2VydmVyX3N1cHBvcnRzKCJuby1kb25lIikpIHsKCQkJcHJpbnRfdmVyYm9zZShhcmdzLCBfKCJTZXJ2ZXIgc3VwcG9ydHMgbm8tZG9uZSIpKTsKCQkJaWYgKGFyZ3MtPnN0YXRlbGVzc19ycGMpCgkJCQlub19kb25lID0gMTsKCQl9Cgl9CgllbHNlIGlmIChzZXJ2ZXJfc3VwcG9ydHMoIm11bHRpX2FjayIpKSB7CgkJcHJpbnRfdmVyYm9zZShhcmdzLCBfKCJTZXJ2ZXIgc3VwcG9ydHMgbXVsdGlfYWNrIikpOwoJCW11bHRpX2FjayA9IDE7Cgl9CglpZiAoc2VydmVyX3N1cHBvcnRzKCJzaWRlLWJhbmQtNjRrIikpIHsKCQlwcmludF92ZXJib3NlKGFyZ3MsIF8oIlNlcnZlciBzdXBwb3J0cyBzaWRlLWJhbmQtNjRrIikpOwoJCXVzZV9zaWRlYmFuZCA9IDI7Cgl9CgllbHNlIGlmIChzZXJ2ZXJfc3VwcG9ydHMoInNpZGUtYmFuZCIpKSB7CgkJcHJpbnRfdmVyYm9zZShhcmdzLCBfKCJTZXJ2ZXIgc3VwcG9ydHMgc2lkZS1iYW5kIikpOwoJCXVzZV9zaWRlYmFuZCA9IDE7Cgl9CglpZiAoc2VydmVyX3N1cHBvcnRzKCJhbGxvdy10aXAtc2hhMS1pbi13YW50IikpIHsKCQlwcmludF92ZXJib3NlKGFyZ3MsIF8oIlNlcnZlciBzdXBwb3J0cyBhbGxvdy10aXAtc2hhMS1pbi13YW50IikpOwoJCWFsbG93X3VuYWR2ZXJ0aXNlZF9vYmplY3RfcmVxdWVzdCB8PSBBTExPV19USVBfU0hBMTsKCX0KCWlmIChzZXJ2ZXJfc3VwcG9ydHMoImFsbG93LXJlYWNoYWJsZS1zaGExLWluLXdhbnQiKSkgewoJCXByaW50X3ZlcmJvc2UoYXJncywgXygiU2VydmVyIHN1cHBvcnRzIGFsbG93LXJlYWNoYWJsZS1zaGExLWluLXdhbnQiKSk7CgkJYWxsb3dfdW5hZHZlcnRpc2VkX29iamVjdF9yZXF1ZXN0IHw9IEFMTE9XX1JFQUNIQUJMRV9TSEExOwoJfQoJaWYgKCFzZXJ2ZXJfc3VwcG9ydHMoInRoaW4tcGFjayIpKQoJCWFyZ3MtPnVzZV90aGluX3BhY2sgPSAwOwoJaWYgKCFzZXJ2ZXJfc3VwcG9ydHMoIm5vLXByb2dyZXNzIikpCgkJYXJncy0+bm9fcHJvZ3Jlc3MgPSAwOwoJaWYgKCFzZXJ2ZXJfc3VwcG9ydHMoImluY2x1ZGUtdGFnIikpCgkJYXJncy0+aW5jbHVkZV90YWcgPSAwOwoJaWYgKHNlcnZlcl9zdXBwb3J0cygib2ZzLWRlbHRhIikpCgkJcHJpbnRfdmVyYm9zZShhcmdzLCBfKCJTZXJ2ZXIgc3VwcG9ydHMgb2ZzLWRlbHRhIikpOwoJZWxzZQoJCXByZWZlcl9vZnNfZGVsdGEgPSAwOwoKCWlmICgoYWdlbnRfZmVhdHVyZSA9IHNlcnZlcl9mZWF0dXJlX3ZhbHVlKCJhZ2VudCIsICZhZ2VudF9sZW4pKSkgewoJCWFnZW50X3N1cHBvcnRlZCA9IDE7CgkJaWYgKGFnZW50X2xlbikKCQkJcHJpbnRfdmVyYm9zZShhcmdzLCBfKCJTZXJ2ZXIgdmVyc2lvbiBpcyAlLipzIiksCgkJCQkgICAgICBhZ2VudF9sZW4sIGFnZW50X2ZlYXR1cmUpOwoJfQoJaWYgKHNlcnZlcl9zdXBwb3J0cygiZGVlcGVuLXNpbmNlIikpCgkJZGVlcGVuX3NpbmNlX29rID0gMTsKCWVsc2UgaWYgKGFyZ3MtPmRlZXBlbl9zaW5jZSkKCQlkaWUoXygiU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgLS1zaGFsbG93LXNpbmNlIikpOwoJaWYgKHNlcnZlcl9zdXBwb3J0cygiZGVlcGVuLW5vdCIpKQoJCWRlZXBlbl9ub3Rfb2sgPSAxOwoJZWxzZSBpZiAoYXJncy0+ZGVlcGVuX25vdCkKCQlkaWUoXygiU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgLS1zaGFsbG93LWV4Y2x1ZGUiKSk7CglpZiAoIXNlcnZlcl9zdXBwb3J0cygiZGVlcGVuLXJlbGF0aXZlIikgJiYgYXJncy0+ZGVlcGVuX3JlbGF0aXZlKQoJCWRpZShfKCJTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCAtLWRlZXBlbiIpKTsKCglpZiAoZXZlcnl0aGluZ19sb2NhbChhcmdzLCAmcmVmLCBzb3VnaHQsIG5yX3NvdWdodCkpIHsKCQlwYWNrZXRfZmx1c2goZmRbMV0pOwoJCWdvdG8gYWxsX2RvbmU7Cgl9CglpZiAoZmluZF9jb21tb24oYXJncywgZmQsICZvaWQsIHJlZikgPCAwKQoJCWlmICghYXJncy0+a2VlcF9wYWNrKQoJCQkvKiBXaGVuIGNsb25pbmcsIGl0IGlzIG5vdCB1bnVzdWFsIHRvIGhhdmUKCQkJICogbm8gY29tbW9uIGNvbW1pdC4KCQkJICovCgkJCXdhcm5pbmcoXygibm8gY29tbW9uIGNvbW1pdHMiKSk7CgoJaWYgKGFyZ3MtPnN0YXRlbGVzc19ycGMpCgkJcGFja2V0X2ZsdXNoKGZkWzFdKTsKCWlmIChhcmdzLT5kZWVwZW4pCgkJc2V0dXBfYWx0ZXJuYXRlX3NoYWxsb3coJnNoYWxsb3dfbG9jaywgJmFsdGVybmF0ZV9zaGFsbG93X2ZpbGUsCgkJCQkJTlVMTCk7CgllbHNlIGlmIChzaS0+bnJfb3VycyB8fCBzaS0+bnJfdGhlaXJzKQoJCWFsdGVybmF0ZV9zaGFsbG93X2ZpbGUgPSBzZXR1cF90ZW1wb3Jhcnlfc2hhbGxvdyhzaS0+c2hhbGxvdyk7CgllbHNlCgkJYWx0ZXJuYXRlX3NoYWxsb3dfZmlsZSA9IE5VTEw7CglpZiAoZ2V0X3BhY2soYXJncywgZmQsIHBhY2tfbG9ja2ZpbGUpKQoJCWRpZShfKCJnaXQgZmV0Y2gtcGFjazogZmV0Y2ggZmFpbGVkLiIpKTsKCiBhbGxfZG9uZToKCXJldHVybiByZWY7Cn0KCnN0YXRpYyB2b2lkIGZldGNoX3BhY2tfY29uZmlnKHZvaWQpCnsKCWdpdF9jb25maWdfZ2V0X2ludCgiZmV0Y2gudW5wYWNrbGltaXQiLCAmZmV0Y2hfdW5wYWNrX2xpbWl0KTsKCWdpdF9jb25maWdfZ2V0X2ludCgidHJhbnNmZXIudW5wYWNrbGltaXQiLCAmdHJhbnNmZXJfdW5wYWNrX2xpbWl0KTsKCWdpdF9jb25maWdfZ2V0X2Jvb2woInJlcGFjay51c2VkZWx0YWJhc2VvZmZzZXQiLCAmcHJlZmVyX29mc19kZWx0YSk7CglnaXRfY29uZmlnX2dldF9ib29sKCJmZXRjaC5mc2Nrb2JqZWN0cyIsICZmZXRjaF9mc2NrX29iamVjdHMpOwoJZ2l0X2NvbmZpZ19nZXRfYm9vbCgidHJhbnNmZXIuZnNja29iamVjdHMiLCAmdHJhbnNmZXJfZnNja19vYmplY3RzKTsKCglnaXRfY29uZmlnKGdpdF9kZWZhdWx0X2NvbmZpZywgTlVMTCk7Cn0KCnN0YXRpYyB2b2lkIGZldGNoX3BhY2tfc2V0dXAodm9pZCkKewoJc3RhdGljIGludCBkaWRfc2V0dXA7CglpZiAoZGlkX3NldHVwKQoJCXJldHVybjsKCWZldGNoX3BhY2tfY29uZmlnKCk7CglpZiAoMCA8PSB0cmFuc2Zlcl91bnBhY2tfbGltaXQpCgkJdW5wYWNrX2xpbWl0ID0gdHJhbnNmZXJfdW5wYWNrX2xpbWl0OwoJZWxzZSBpZiAoMCA8PSBmZXRjaF91bnBhY2tfbGltaXQpCgkJdW5wYWNrX2xpbWl0ID0gZmV0Y2hfdW5wYWNrX2xpbWl0OwoJZGlkX3NldHVwID0gMTsKfQoKc3RhdGljIGludCByZW1vdmVfZHVwbGljYXRlc19pbl9yZWZzKHN0cnVjdCByZWYgKipyZWYsIGludCBucikKewoJc3RydWN0IHN0cmluZ19saXN0IG5hbWVzID0gU1RSSU5HX0xJU1RfSU5JVF9OT0RVUDsKCWludCBzcmMsIGRzdDsKCglmb3IgKHNyYyA9IGRzdCA9IDA7IHNyYyA8IG5yOyBzcmMrKykgewoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoJCWl0ZW0gPSBzdHJpbmdfbGlzdF9pbnNlcnQoJm5hbWVzLCByZWZbc3JjXS0+bmFtZSk7CgkJaWYgKGl0ZW0tPnV0aWwpCgkJCWNvbnRpbnVlOyAvKiBhbHJlYWR5IGhhdmUgaXQgKi8KCQlpdGVtLT51dGlsID0gcmVmW3NyY107CgkJaWYgKHNyYyAhPSBkc3QpCgkJCXJlZltkc3RdID0gcmVmW3NyY107CgkJZHN0Kys7Cgl9Cglmb3IgKHNyYyA9IGRzdDsgc3JjIDwgbnI7IHNyYysrKQoJCXJlZltzcmNdID0gTlVMTDsKCXN0cmluZ19saXN0X2NsZWFyKCZuYW1lcywgMCk7CglyZXR1cm4gZHN0Owp9CgpzdGF0aWMgdm9pZCB1cGRhdGVfc2hhbGxvdyhzdHJ1Y3QgZmV0Y2hfcGFja19hcmdzICphcmdzLAoJCQkgICBzdHJ1Y3QgcmVmICoqc291Z2h0LCBpbnQgbnJfc291Z2h0LAoJCQkgICBzdHJ1Y3Qgc2hhbGxvd19pbmZvICpzaSkKewoJc3RydWN0IG9pZF9hcnJheSByZWYgPSBPSURfQVJSQVlfSU5JVDsKCWludCAqc3RhdHVzOwoJaW50IGk7CgoJaWYgKGFyZ3MtPmRlZXBlbiAmJiBhbHRlcm5hdGVfc2hhbGxvd19maWxlKSB7CgkJaWYgKCphbHRlcm5hdGVfc2hhbGxvd19maWxlID09ICdcMCcpIHsgLyogLS11bnNoYWxsb3cgKi8KCQkJdW5saW5rX29yX3dhcm4oZ2l0X3BhdGhfc2hhbGxvdygpKTsKCQkJcm9sbGJhY2tfbG9ja19maWxlKCZzaGFsbG93X2xvY2spOwoJCX0gZWxzZQoJCQljb21taXRfbG9ja19maWxlKCZzaGFsbG93X2xvY2spOwoJCXJldHVybjsKCX0KCglpZiAoIXNpLT5zaGFsbG93IHx8ICFzaS0+c2hhbGxvdy0+bnIpCgkJcmV0dXJuOwoKCWlmIChhcmdzLT5jbG9uaW5nKSB7CgkJLyoKCQkgKiByZW1vdGUgaXMgc2hhbGxvdywgYnV0IHRoaXMgaXMgYSBjbG9uZSwgdGhlcmUgYXJlCgkJICogbm8gb2JqZWN0cyBpbiByZXBvIHRvIHdvcnJ5IGFib3V0LiBBY2NlcHQgYW55CgkJICogc2hhbGxvdyBwb2ludHMgdGhhdCBleGlzdCBpbiB0aGUgcGFjayAoaW93IGluIHJlcG8KCQkgKiBhZnRlciBnZXRfcGFjaygpIGFuZCByZXByZXBhcmVfcGFja2VkX2dpdCgpKQoJCSAqLwoJCXN0cnVjdCBvaWRfYXJyYXkgZXh0cmEgPSBPSURfQVJSQVlfSU5JVDsKCQlzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQgPSBzaS0+c2hhbGxvdy0+b2lkOwoJCWZvciAoaSA9IDA7IGkgPCBzaS0+c2hhbGxvdy0+bnI7IGkrKykKCQkJaWYgKGhhc19vYmplY3RfZmlsZSgmb2lkW2ldKSkKCQkJCW9pZF9hcnJheV9hcHBlbmQoJmV4dHJhLCAmb2lkW2ldKTsKCQlpZiAoZXh0cmEubnIpIHsKCQkJc2V0dXBfYWx0ZXJuYXRlX3NoYWxsb3coJnNoYWxsb3dfbG9jaywKCQkJCQkJJmFsdGVybmF0ZV9zaGFsbG93X2ZpbGUsCgkJCQkJCSZleHRyYSk7CgkJCWNvbW1pdF9sb2NrX2ZpbGUoJnNoYWxsb3dfbG9jayk7CgkJfQoJCW9pZF9hcnJheV9jbGVhcigmZXh0cmEpOwoJCXJldHVybjsKCX0KCglpZiAoIXNpLT5ucl9vdXJzICYmICFzaS0+bnJfdGhlaXJzKQoJCXJldHVybjsKCglyZW1vdmVfbm9uZXhpc3RlbnRfdGhlaXJzX3NoYWxsb3coc2kpOwoJaWYgKCFzaS0+bnJfb3VycyAmJiAhc2ktPm5yX3RoZWlycykKCQlyZXR1cm47Cglmb3IgKGkgPSAwOyBpIDwgbnJfc291Z2h0OyBpKyspCgkJb2lkX2FycmF5X2FwcGVuZCgmcmVmLCAmc291Z2h0W2ldLT5vbGRfb2lkKTsKCXNpLT5yZWYgPSAmcmVmOwoKCWlmIChhcmdzLT51cGRhdGVfc2hhbGxvdykgewoJCS8qCgkJICogcmVtb3RlIGlzIGFsc28gc2hhbGxvdywgLmdpdC9zaGFsbG93IG1heSBiZSB1cGRhdGVkCgkJICogc28gYWxsIHJlZnMgY2FuIGJlIGFjY2VwdGVkLiBNYWtlIHN1cmUgd2Ugb25seSBhZGQKCQkgKiBzaGFsbG93IHJvb3RzIHRoYXQgYXJlIGFjdHVhbGx5IHJlYWNoYWJsZSBmcm9tIG5ldwoJCSAqIHJlZnMuCgkJICovCgkJc3RydWN0IG9pZF9hcnJheSBleHRyYSA9IE9JRF9BUlJBWV9JTklUOwoJCXN0cnVjdCBvYmplY3RfaWQgKm9pZCA9IHNpLT5zaGFsbG93LT5vaWQ7CgkJYXNzaWduX3NoYWxsb3dfY29tbWl0c190b19yZWZzKHNpLCBOVUxMLCBOVUxMKTsKCQlpZiAoIXNpLT5ucl9vdXJzICYmICFzaS0+bnJfdGhlaXJzKSB7CgkJCW9pZF9hcnJheV9jbGVhcigmcmVmKTsKCQkJcmV0dXJuOwoJCX0KCQlmb3IgKGkgPSAwOyBpIDwgc2ktPm5yX291cnM7IGkrKykKCQkJb2lkX2FycmF5X2FwcGVuZCgmZXh0cmEsICZvaWRbc2ktPm91cnNbaV1dKTsKCQlmb3IgKGkgPSAwOyBpIDwgc2ktPm5yX3RoZWlyczsgaSsrKQoJCQlvaWRfYXJyYXlfYXBwZW5kKCZleHRyYSwgJm9pZFtzaS0+dGhlaXJzW2ldXSk7CgkJc2V0dXBfYWx0ZXJuYXRlX3NoYWxsb3coJnNoYWxsb3dfbG9jaywKCQkJCQkmYWx0ZXJuYXRlX3NoYWxsb3dfZmlsZSwKCQkJCQkmZXh0cmEpOwoJCWNvbW1pdF9sb2NrX2ZpbGUoJnNoYWxsb3dfbG9jayk7CgkJb2lkX2FycmF5X2NsZWFyKCZleHRyYSk7CgkJb2lkX2FycmF5X2NsZWFyKCZyZWYpOwoJCXJldHVybjsKCX0KCgkvKgoJICogcmVtb3RlIGlzIGFsc28gc2hhbGxvdywgY2hlY2sgd2hhdCByZWYgaXMgc2FmZSB0byB1cGRhdGUKCSAqIHdpdGhvdXQgdXBkYXRpbmcgLmdpdC9zaGFsbG93CgkgKi8KCXN0YXR1cyA9IHhjYWxsb2MobnJfc291Z2h0LCBzaXplb2YoKnN0YXR1cykpOwoJYXNzaWduX3NoYWxsb3dfY29tbWl0c190b19yZWZzKHNpLCBOVUxMLCBzdGF0dXMpOwoJaWYgKHNpLT5ucl9vdXJzIHx8IHNpLT5ucl90aGVpcnMpIHsKCQlmb3IgKGkgPSAwOyBpIDwgbnJfc291Z2h0OyBpKyspCgkJCWlmIChzdGF0dXNbaV0pCgkJCQlzb3VnaHRbaV0tPnN0YXR1cyA9IFJFRl9TVEFUVVNfUkVKRUNUX1NIQUxMT1c7Cgl9CglmcmVlKHN0YXR1cyk7CglvaWRfYXJyYXlfY2xlYXIoJnJlZik7Cn0KCnN0cnVjdCByZWYgKmZldGNoX3BhY2soc3RydWN0IGZldGNoX3BhY2tfYXJncyAqYXJncywKCQkgICAgICAgaW50IGZkW10sIHN0cnVjdCBjaGlsZF9wcm9jZXNzICpjb25uLAoJCSAgICAgICBjb25zdCBzdHJ1Y3QgcmVmICpyZWYsCgkJICAgICAgIGNvbnN0IGNoYXIgKmRlc3QsCgkJICAgICAgIHN0cnVjdCByZWYgKipzb3VnaHQsIGludCBucl9zb3VnaHQsCgkJICAgICAgIHN0cnVjdCBvaWRfYXJyYXkgKnNoYWxsb3csCgkJICAgICAgIGNoYXIgKipwYWNrX2xvY2tmaWxlKQp7CglzdHJ1Y3QgcmVmICpyZWZfY3B5OwoJc3RydWN0IHNoYWxsb3dfaW5mbyBzaTsKCglmZXRjaF9wYWNrX3NldHVwKCk7CglpZiAobnJfc291Z2h0KQoJCW5yX3NvdWdodCA9IHJlbW92ZV9kdXBsaWNhdGVzX2luX3JlZnMoc291Z2h0LCBucl9zb3VnaHQpOwoKCWlmICghcmVmKSB7CgkJcGFja2V0X2ZsdXNoKGZkWzFdKTsKCQlkaWUoXygibm8gbWF0Y2hpbmcgcmVtb3RlIGhlYWQiKSk7Cgl9CglwcmVwYXJlX3NoYWxsb3dfaW5mbygmc2ksIHNoYWxsb3cpOwoJcmVmX2NweSA9IGRvX2ZldGNoX3BhY2soYXJncywgZmQsIHJlZiwgc291Z2h0LCBucl9zb3VnaHQsCgkJCQkmc2ksIHBhY2tfbG9ja2ZpbGUpOwoJcmVwcmVwYXJlX3BhY2tlZF9naXQoKTsKCXVwZGF0ZV9zaGFsbG93KGFyZ3MsIHNvdWdodCwgbnJfc291Z2h0LCAmc2kpOwoJY2xlYXJfc2hhbGxvd19pbmZvKCZzaSk7CglyZXR1cm4gcmVmX2NweTsKfQoKaW50IHJlcG9ydF91bm1hdGNoZWRfcmVmcyhzdHJ1Y3QgcmVmICoqc291Z2h0LCBpbnQgbnJfc291Z2h0KQp7CglpbnQgaSwgcmV0ID0gMDsKCglmb3IgKGkgPSAwOyBpIDwgbnJfc291Z2h0OyBpKyspIHsKCQlpZiAoIXNvdWdodFtpXSkKCQkJY29udGludWU7CgkJc3dpdGNoIChzb3VnaHRbaV0tPm1hdGNoX3N0YXR1cykgewoJCWNhc2UgUkVGX01BVENIRUQ6CgkJCWNvbnRpbnVlOwoJCWNhc2UgUkVGX05PVF9NQVRDSEVEOgoJCQllcnJvcihfKCJubyBzdWNoIHJlbW90ZSByZWYgJXMiKSwgc291Z2h0W2ldLT5uYW1lKTsKCQkJYnJlYWs7CgkJY2FzZSBSRUZfVU5BRFZFUlRJU0VEX05PVF9BTExPV0VEOgoJCQllcnJvcihfKCJTZXJ2ZXIgZG9lcyBub3QgYWxsb3cgcmVxdWVzdCBmb3IgdW5hZHZlcnRpc2VkIG9iamVjdCAlcyIpLAoJCQkgICAgICBzb3VnaHRbaV0tPm5hbWUpOwoJCQlicmVhazsKCQl9CgkJcmV0ID0gMTsKCX0KCXJldHVybiByZXQ7Cn0K",
    "text": "#include \"cache.h\"\n#include \"config.h\"\n#include \"lockfile.h\"\n#include \"refs.h\"\n#include \"pkt-line.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"exec_cmd.h\"\n#include \"pack.h\"\n#include \"sideband.h\"\n#include \"fetch-pack.h\"\n#include \"remote.h\"\n#include \"run-command.h\"\n#include \"connect.h\"\n#include \"transport.h\"\n#include \"version.h\"\n#include \"prio-queue.h\"\n#include \"sha1-array.h\"\n#include \"oidset.h\"\n#include \"packfile.h\"\n\nstatic int transfer_unpack_limit = -1;\nstatic int fetch_unpack_limit = -1;\nstatic int unpack_limit = 100;\nstatic int prefer_ofs_delta = 1;\nstatic int no_done;\nstatic int deepen_since_ok;\nstatic int deepen_not_ok;\nstatic int fetch_fsck_objects = -1;\nstatic int transfer_fsck_objects = -1;\nstatic int agent_supported;\nstatic struct lock_file shallow_lock;\nstatic const char *alternate_shallow_file;\n\n/* Remember to update object flag allocation in object.h */\n#define COMPLETE\t(1U << 0)\n#define COMMON\t\t(1U << 1)\n#define COMMON_REF\t(1U << 2)\n#define SEEN\t\t(1U << 3)\n#define POPPED\t\t(1U << 4)\n#define ALTERNATE\t(1U << 5)\n\nstatic int marked;\n\n/*\n * After sending this many \"have\"s if we do not get any new ACK , we\n * give up traversing our history.\n */\n#define MAX_IN_VAIN 256\n\nstatic struct prio_queue rev_list = { compare_commits_by_commit_date };\nstatic int non_common_revs, multi_ack, use_sideband;\n/* Allow specifying sha1 if it is a ref tip. */\n#define ALLOW_TIP_SHA1\t01\n/* Allow request of a sha1 if it is reachable from a ref (possibly hidden ref). */\n#define ALLOW_REACHABLE_SHA1\t02\nstatic unsigned int allow_unadvertised_object_request;\n\n__attribute__((format (printf, 2, 3)))\nstatic inline void print_verbose(const struct fetch_pack_args *args,\n\t\t\t\t const char *fmt, ...)\n{\n\tva_list params;\n\n\tif (!args->verbose)\n\t\treturn;\n\n\tva_start(params, fmt);\n\tvfprintf(stderr, fmt, params);\n\tva_end(params);\n\tfputc('\\n', stderr);\n}\n\nstruct alternate_object_cache {\n\tstruct object **items;\n\tsize_t nr, alloc;\n};\n\nstatic void cache_one_alternate(const char *refname,\n\t\t\t\tconst struct object_id *oid,\n\t\t\t\tvoid *vcache)\n{\n\tstruct alternate_object_cache *cache = vcache;\n\tstruct object *obj = parse_object(oid);\n\n\tif (!obj || (obj->flags & ALTERNATE))\n\t\treturn;\n\n\tobj->flags |= ALTERNATE;\n\tALLOC_GROW(cache->items, cache->nr + 1, cache->alloc);\n\tcache->items[cache->nr++] = obj;\n}\n\nstatic void for_each_cached_alternate(void (*cb)(struct object *))\n{\n\tstatic int initialized;\n\tstatic struct alternate_object_cache cache;\n\tsize_t i;\n\n\tif (!initialized) {\n\t\tfor_each_alternate_ref(cache_one_alternate, &cache);\n\t\tinitialized = 1;\n\t}\n\n\tfor (i = 0; i < cache.nr; i++)\n\t\tcb(cache.items[i]);\n}\n\nstatic void rev_list_push(struct commit *commit, int mark)\n{\n\tif (!(commit->object.flags & mark)) {\n\t\tcommit->object.flags |= mark;\n\n\t\tif (parse_commit(commit))\n\t\t\treturn;\n\n\t\tprio_queue_put(&rev_list, commit);\n\n\t\tif (!(commit->object.flags & COMMON))\n\t\t\tnon_common_revs++;\n\t}\n}\n\nstatic int rev_list_insert_ref(const char *refname, const struct object_id *oid)\n{\n\tstruct object *o = deref_tag(parse_object(oid), refname, 0);\n\n\tif (o && o->type == OBJ_COMMIT)\n\t\trev_list_push((struct commit *)o, SEEN);\n\n\treturn 0;\n}\n\nstatic int rev_list_insert_ref_oid(const char *refname, const struct object_id *oid,\n\t\t\t\t   int flag, void *cb_data)\n{\n\treturn rev_list_insert_ref(refname, oid);\n}\n\nstatic int clear_marks(const char *refname, const struct object_id *oid,\n\t\t       int flag, void *cb_data)\n{\n\tstruct object *o = deref_tag(parse_object(oid), refname, 0);\n\n\tif (o && o->type == OBJ_COMMIT)\n\t\tclear_commit_marks((struct commit *)o,\n\t\t\t\t   COMMON | COMMON_REF | SEEN | POPPED);\n\treturn 0;\n}\n\n/*\n   This function marks a rev and its ancestors as common.\n   In some cases, it is desirable to mark only the ancestors (for example\n   when only the server does not yet know that they are common).\n*/\n\nstatic void mark_common(struct commit *commit,\n\t\tint ancestors_only, int dont_parse)\n{\n\tif (commit != NULL && !(commit->object.flags & COMMON)) {\n\t\tstruct object *o = (struct object *)commit;\n\n\t\tif (!ancestors_only)\n\t\t\to->flags |= COMMON;\n\n\t\tif (!(o->flags & SEEN))\n\t\t\trev_list_push(commit, SEEN);\n\t\telse {\n\t\t\tstruct commit_list *parents;\n\n\t\t\tif (!ancestors_only && !(o->flags & POPPED))\n\t\t\t\tnon_common_revs--;\n\t\t\tif (!o->parsed && !dont_parse)\n\t\t\t\tif (parse_commit(commit))\n\t\t\t\t\treturn;\n\n\t\t\tfor (parents = commit->parents;\n\t\t\t\t\tparents;\n\t\t\t\t\tparents = parents->next)\n\t\t\t\tmark_common(parents->item, 0, dont_parse);\n\t\t}\n\t}\n}\n\n/*\n  Get the next rev to send, ignoring the common.\n*/\n\nstatic const struct object_id *get_rev(void)\n{\n\tstruct commit *commit = NULL;\n\n\twhile (commit == NULL) {\n\t\tunsigned int mark;\n\t\tstruct commit_list *parents;\n\n\t\tif (rev_list.nr == 0 || non_common_revs == 0)\n\t\t\treturn NULL;\n\n\t\tcommit = prio_queue_get(&rev_list);\n\t\tparse_commit(commit);\n\t\tparents = commit->parents;\n\n\t\tcommit->object.flags |= POPPED;\n\t\tif (!(commit->object.flags & COMMON))\n\t\t\tnon_common_revs--;\n\n\t\tif (commit->object.flags & COMMON) {\n\t\t\t/* do not send \"have\", and ignore ancestors */\n\t\t\tcommit = NULL;\n\t\t\tmark = COMMON | SEEN;\n\t\t} else if (commit->object.flags & COMMON_REF)\n\t\t\t/* send \"have\", and ignore ancestors */\n\t\t\tmark = COMMON | SEEN;\n\t\telse\n\t\t\t/* send \"have\", also for its ancestors */\n\t\t\tmark = SEEN;\n\n\t\twhile (parents) {\n\t\t\tif (!(parents->item->object.flags & SEEN))\n\t\t\t\trev_list_push(parents->item, mark);\n\t\t\tif (mark & COMMON)\n\t\t\t\tmark_common(parents->item, 1, 0);\n\t\t\tparents = parents->next;\n\t\t}\n\t}\n\n\treturn &commit->object.oid;\n}\n\nenum ack_type {\n\tNAK = 0,\n\tACK,\n\tACK_continue,\n\tACK_common,\n\tACK_ready\n};\n\nstatic void consume_shallow_list(struct fetch_pack_args *args, int fd)\n{\n\tif (args->stateless_rpc && args->deepen) {\n\t\t/* If we sent a depth we will get back \"duplicate\"\n\t\t * shallow and unshallow commands every time there\n\t\t * is a block of have lines exchanged.\n\t\t */\n\t\tchar *line;\n\t\twhile ((line = packet_read_line(fd, NULL))) {\n\t\t\tif (starts_with(line, \"shallow \"))\n\t\t\t\tcontinue;\n\t\t\tif (starts_with(line, \"unshallow \"))\n\t\t\t\tcontinue;\n\t\t\tdie(_(\"git fetch-pack: expected shallow list\"));\n\t\t}\n\t}\n}\n\nstatic enum ack_type get_ack(int fd, struct object_id *result_oid)\n{\n\tint len;\n\tchar *line = packet_read_line(fd, &len);\n\tconst char *arg;\n\n\tif (!len)\n\t\tdie(_(\"git fetch-pack: expected ACK/NAK, got EOF\"));\n\tif (!strcmp(line, \"NAK\"))\n\t\treturn NAK;\n\tif (skip_prefix(line, \"ACK \", &arg)) {\n\t\tif (!get_oid_hex(arg, result_oid)) {\n\t\t\targ += 40;\n\t\t\tlen -= arg - line;\n\t\t\tif (len < 1)\n\t\t\t\treturn ACK;\n\t\t\tif (strstr(arg, \"continue\"))\n\t\t\t\treturn ACK_continue;\n\t\t\tif (strstr(arg, \"common\"))\n\t\t\t\treturn ACK_common;\n\t\t\tif (strstr(arg, \"ready\"))\n\t\t\t\treturn ACK_ready;\n\t\t\treturn ACK;\n\t\t}\n\t}\n\tif (skip_prefix(line, \"ERR \", &arg))\n\t\tdie(_(\"remote error: %s\"), arg);\n\tdie(_(\"git fetch-pack: expected ACK/NAK, got '%s'\"), line);\n}\n\nstatic void send_request(struct fetch_pack_args *args,\n\t\t\t int fd, struct strbuf *buf)\n{\n\tif (args->stateless_rpc) {\n\t\tsend_sideband(fd, -1, buf->buf, buf->len, LARGE_PACKET_MAX);\n\t\tpacket_flush(fd);\n\t} else\n\t\twrite_or_die(fd, buf->buf, buf->len);\n}\n\nstatic void insert_one_alternate_object(struct object *obj)\n{\n\trev_list_insert_ref(NULL, &obj->oid);\n}\n\n#define INITIAL_FLUSH 16\n#define PIPESAFE_FLUSH 32\n#define LARGE_FLUSH 16384\n\nstatic int next_flush(struct fetch_pack_args *args, int count)\n{\n\tif (args->stateless_rpc) {\n\t\tif (count < LARGE_FLUSH)\n\t\t\tcount <<= 1;\n\t\telse\n\t\t\tcount = count * 11 / 10;\n\t} else {\n\t\tif (count < PIPESAFE_FLUSH)\n\t\t\tcount <<= 1;\n\t\telse\n\t\t\tcount += PIPESAFE_FLUSH;\n\t}\n\treturn count;\n}\n\nstatic int find_common(struct fetch_pack_args *args,\n\t\t       int fd[2], struct object_id *result_oid,\n\t\t       struct ref *refs)\n{\n\tint fetching;\n\tint count = 0, flushes = 0, flush_at = INITIAL_FLUSH, retval;\n\tconst struct object_id *oid;\n\tunsigned in_vain = 0;\n\tint got_continue = 0;\n\tint got_ready = 0;\n\tstruct strbuf req_buf = STRBUF_INIT;\n\tsize_t state_len = 0;\n\n\tif (args->stateless_rpc && multi_ack == 1)\n\t\tdie(_(\"--stateless-rpc requires multi_ack_detailed\"));\n\tif (marked)\n\t\tfor_each_ref(clear_marks, NULL);\n\tmarked = 1;\n\n\tfor_each_ref(rev_list_insert_ref_oid, NULL);\n\tfor_each_cached_alternate(insert_one_alternate_object);\n\n\tfetching = 0;\n\tfor ( ; refs ; refs = refs->next) {\n\t\tstruct object_id *remote = &refs->old_oid;\n\t\tconst char *remote_hex;\n\t\tstruct object *o;\n\n\t\t/*\n\t\t * If that object is complete (i.e. it is an ancestor of a\n\t\t * local ref), we tell them we have it but do not have to\n\t\t * tell them about its ancestors, which they already know\n\t\t * about.\n\t\t *\n\t\t * We use lookup_object here because we are only\n\t\t * interested in the case we *know* the object is\n\t\t * reachable and we have already scanned it.\n\t\t */\n\t\tif (((o = lookup_object(remote->hash)) != NULL) &&\n\t\t\t\t(o->flags & COMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tremote_hex = oid_to_hex(remote);\n\t\tif (!fetching) {\n\t\t\tstruct strbuf c = STRBUF_INIT;\n\t\t\tif (multi_ack == 2)     strbuf_addstr(&c, \" multi_ack_detailed\");\n\t\t\tif (multi_ack == 1)     strbuf_addstr(&c, \" multi_ack\");\n\t\t\tif (no_done)            strbuf_addstr(&c, \" no-done\");\n\t\t\tif (use_sideband == 2)  strbuf_addstr(&c, \" side-band-64k\");\n\t\t\tif (use_sideband == 1)  strbuf_addstr(&c, \" side-band\");\n\t\t\tif (args->deepen_relative) strbuf_addstr(&c, \" deepen-relative\");\n\t\t\tif (args->use_thin_pack) strbuf_addstr(&c, \" thin-pack\");\n\t\t\tif (args->no_progress)   strbuf_addstr(&c, \" no-progress\");\n\t\t\tif (args->include_tag)   strbuf_addstr(&c, \" include-tag\");\n\t\t\tif (prefer_ofs_delta)   strbuf_addstr(&c, \" ofs-delta\");\n\t\t\tif (deepen_since_ok)    strbuf_addstr(&c, \" deepen-since\");\n\t\t\tif (deepen_not_ok)      strbuf_addstr(&c, \" deepen-not\");\n\t\t\tif (agent_supported)    strbuf_addf(&c, \" agent=%s\",\n\t\t\t\t\t\t\t    git_user_agent_sanitized());\n\t\t\tpacket_buf_write(&req_buf, \"want %s%s\\n\", remote_hex, c.buf);\n\t\t\tstrbuf_release(&c);\n\t\t} else\n\t\t\tpacket_buf_write(&req_buf, \"want %s\\n\", remote_hex);\n\t\tfetching++;\n\t}\n\n\tif (!fetching) {\n\t\tstrbuf_release(&req_buf);\n\t\tpacket_flush(fd[1]);\n\t\treturn 1;\n\t}\n\n\tif (is_repository_shallow())\n\t\twrite_shallow_commits(&req_buf, 1, NULL);\n\tif (args->depth > 0)\n\t\tpacket_buf_write(&req_buf, \"deepen %d\", args->depth);\n\tif (args->deepen_since) {\n\t\ttimestamp_t max_age = approxidate(args->deepen_since);\n\t\tpacket_buf_write(&req_buf, \"deepen-since %\"PRItime, max_age);\n\t}\n\tif (args->deepen_not) {\n\t\tint i;\n\t\tfor (i = 0; i < args->deepen_not->nr; i++) {\n\t\t\tstruct string_list_item *s = args->deepen_not->items + i;\n\t\t\tpacket_buf_write(&req_buf, \"deepen-not %s\", s->string);\n\t\t}\n\t}\n\tpacket_buf_flush(&req_buf);\n\tstate_len = req_buf.len;\n\n\tif (args->deepen) {\n\t\tchar *line;\n\t\tconst char *arg;\n\t\tstruct object_id oid;\n\n\t\tsend_request(args, fd[1], &req_buf);\n\t\twhile ((line = packet_read_line(fd[0], NULL))) {\n\t\t\tif (skip_prefix(line, \"shallow \", &arg)) {\n\t\t\t\tif (get_oid_hex(arg, &oid))\n\t\t\t\t\tdie(_(\"invalid shallow line: %s\"), line);\n\t\t\t\tregister_shallow(&oid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (skip_prefix(line, \"unshallow \", &arg)) {\n\t\t\t\tif (get_oid_hex(arg, &oid))\n\t\t\t\t\tdie(_(\"invalid unshallow line: %s\"), line);\n\t\t\t\tif (!lookup_object(oid.hash))\n\t\t\t\t\tdie(_(\"object not found: %s\"), line);\n\t\t\t\t/* make sure that it is parsed as shallow */\n\t\t\t\tif (!parse_object(&oid))\n\t\t\t\t\tdie(_(\"error in object: %s\"), line);\n\t\t\t\tif (unregister_shallow(&oid))\n\t\t\t\t\tdie(_(\"no shallow found: %s\"), line);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdie(_(\"expected shallow/unshallow, got %s\"), line);\n\t\t}\n\t} else if (!args->stateless_rpc)\n\t\tsend_request(args, fd[1], &req_buf);\n\n\tif (!args->stateless_rpc) {\n\t\t/* If we aren't using the stateless-rpc interface\n\t\t * we don't need to retain the headers.\n\t\t */\n\t\tstrbuf_setlen(&req_buf, 0);\n\t\tstate_len = 0;\n\t}\n\n\tflushes = 0;\n\tretval = -1;\n\twhile ((oid = get_rev())) {\n\t\tpacket_buf_write(&req_buf, \"have %s\\n\", oid_to_hex(oid));\n\t\tprint_verbose(args, \"have %s\", oid_to_hex(oid));\n\t\tin_vain++;\n\t\tif (flush_at <= ++count) {\n\t\t\tint ack;\n\n\t\t\tpacket_buf_flush(&req_buf);\n\t\t\tsend_request(args, fd[1], &req_buf);\n\t\t\tstrbuf_setlen(&req_buf, state_len);\n\t\t\tflushes++;\n\t\t\tflush_at = next_flush(args, count);\n\n\t\t\t/*\n\t\t\t * We keep one window \"ahead\" of the other side, and\n\t\t\t * will wait for an ACK only on the next one\n\t\t\t */\n\t\t\tif (!args->stateless_rpc && count == INITIAL_FLUSH)\n\t\t\t\tcontinue;\n\n\t\t\tconsume_shallow_list(args, fd[0]);\n\t\t\tdo {\n\t\t\t\tack = get_ack(fd[0], result_oid);\n\t\t\t\tif (ack)\n\t\t\t\t\tprint_verbose(args, _(\"got %s %d %s\"), \"ack\",\n\t\t\t\t\t\t      ack, oid_to_hex(result_oid));\n\t\t\t\tswitch (ack) {\n\t\t\t\tcase ACK:\n\t\t\t\t\tflushes = 0;\n\t\t\t\t\tmulti_ack = 0;\n\t\t\t\t\tretval = 0;\n\t\t\t\t\tgoto done;\n\t\t\t\tcase ACK_common:\n\t\t\t\tcase ACK_ready:\n\t\t\t\tcase ACK_continue: {\n\t\t\t\t\tstruct commit *commit =\n\t\t\t\t\t\tlookup_commit(result_oid);\n\t\t\t\t\tif (!commit)\n\t\t\t\t\t\tdie(_(\"invalid commit %s\"), oid_to_hex(result_oid));\n\t\t\t\t\tif (args->stateless_rpc\n\t\t\t\t\t && ack == ACK_common\n\t\t\t\t\t && !(commit->object.flags & COMMON)) {\n\t\t\t\t\t\t/* We need to replay the have for this object\n\t\t\t\t\t\t * on the next RPC request so the peer knows\n\t\t\t\t\t\t * it is in common with us.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst char *hex = oid_to_hex(result_oid);\n\t\t\t\t\t\tpacket_buf_write(&req_buf, \"have %s\\n\", hex);\n\t\t\t\t\t\tstate_len = req_buf.len;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Reset in_vain because an ack\n\t\t\t\t\t\t * for this commit has not been\n\t\t\t\t\t\t * seen.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tin_vain = 0;\n\t\t\t\t\t} else if (!args->stateless_rpc\n\t\t\t\t\t\t   || ack != ACK_common)\n\t\t\t\t\t\tin_vain = 0;\n\t\t\t\t\tmark_common(commit, 0, 1);\n\t\t\t\t\tretval = 0;\n\t\t\t\t\tgot_continue = 1;\n\t\t\t\t\tif (ack == ACK_ready) {\n\t\t\t\t\t\tclear_prio_queue(&rev_list);\n\t\t\t\t\t\tgot_ready = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (ack);\n\t\t\tflushes--;\n\t\t\tif (got_continue && MAX_IN_VAIN < in_vain) {\n\t\t\t\tprint_verbose(args, _(\"giving up\"));\n\t\t\t\tbreak; /* give up */\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tif (!got_ready || !no_done) {\n\t\tpacket_buf_write(&req_buf, \"done\\n\");\n\t\tsend_request(args, fd[1], &req_buf);\n\t}\n\tprint_verbose(args, _(\"done\"));\n\tif (retval != 0) {\n\t\tmulti_ack = 0;\n\t\tflushes++;\n\t}\n\tstrbuf_release(&req_buf);\n\n\tif (!got_ready || !no_done)\n\t\tconsume_shallow_list(args, fd[0]);\n\twhile (flushes || multi_ack) {\n\t\tint ack = get_ack(fd[0], result_oid);\n\t\tif (ack) {\n\t\t\tprint_verbose(args, _(\"got %s (%d) %s\"), \"ack\",\n\t\t\t\t      ack, oid_to_hex(result_oid));\n\t\t\tif (ack == ACK)\n\t\t\t\treturn 0;\n\t\t\tmulti_ack = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tflushes--;\n\t}\n\t/* it is no error to fetch into a completely empty repo */\n\treturn count ? retval : 0;\n}\n\nstatic struct commit_list *complete;\n\nstatic int mark_complete(const struct object_id *oid)\n{\n\tstruct object *o = parse_object(oid);\n\n\twhile (o && o->type == OBJ_TAG) {\n\t\tstruct tag *t = (struct tag *) o;\n\t\tif (!t->tagged)\n\t\t\tbreak; /* broken repository */\n\t\to->flags |= COMPLETE;\n\t\to = parse_object(&t->tagged->oid);\n\t}\n\tif (o && o->type == OBJ_COMMIT) {\n\t\tstruct commit *commit = (struct commit *)o;\n\t\tif (!(commit->object.flags & COMPLETE)) {\n\t\t\tcommit->object.flags |= COMPLETE;\n\t\t\tcommit_list_insert(commit, &complete);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int mark_complete_oid(const char *refname, const struct object_id *oid,\n\t\t\t     int flag, void *cb_data)\n{\n\treturn mark_complete(oid);\n}\n\nstatic void mark_recent_complete_commits(struct fetch_pack_args *args,\n\t\t\t\t\t timestamp_t cutoff)\n{\n\twhile (complete && cutoff <= complete->item->date) {\n\t\tprint_verbose(args, _(\"Marking %s as complete\"),\n\t\t\t      oid_to_hex(&complete->item->object.oid));\n\t\tpop_most_recent_commit(&complete, COMPLETE);\n\t}\n}\n\nstatic void add_refs_to_oidset(struct oidset *oids, struct ref *refs)\n{\n\tfor (; refs; refs = refs->next)\n\t\toidset_insert(oids, &refs->old_oid);\n}\n\nstatic int tip_oids_contain(struct oidset *tip_oids,\n\t\t\t    struct ref *unmatched, struct ref *newlist,\n\t\t\t    const struct object_id *id)\n{\n\t/*\n\t * Note that this only looks at the ref lists the first time it's\n\t * called. This works out in filter_refs() because even though it may\n\t * add to \"newlist\" between calls, the additions will always be for\n\t * oids that are already in the set.\n\t */\n\tif (!tip_oids->map.map.tablesize) {\n\t\tadd_refs_to_oidset(tip_oids, unmatched);\n\t\tadd_refs_to_oidset(tip_oids, newlist);\n\t}\n\treturn oidset_contains(tip_oids, id);\n}\n\nstatic void filter_refs(struct fetch_pack_args *args,\n\t\t\tstruct ref **refs,\n\t\t\tstruct ref **sought, int nr_sought)\n{\n\tstruct ref *newlist = NULL;\n\tstruct ref **newtail = &newlist;\n\tstruct ref *unmatched = NULL;\n\tstruct ref *ref, *next;\n\tstruct oidset tip_oids = OIDSET_INIT;\n\tint i;\n\n\ti = 0;\n\tfor (ref = *refs; ref; ref = next) {\n\t\tint keep = 0;\n\t\tnext = ref->next;\n\n\t\tif (starts_with(ref->name, \"refs/\") &&\n\t\t    check_refname_format(ref->name, 0))\n\t\t\t; /* trash */\n\t\telse {\n\t\t\twhile (i < nr_sought) {\n\t\t\t\tint cmp = strcmp(ref->name, sought[i]->name);\n\t\t\t\tif (cmp < 0)\n\t\t\t\t\tbreak; /* definitely do not have it */\n\t\t\t\telse if (cmp == 0) {\n\t\t\t\t\tkeep = 1; /* definitely have it */\n\t\t\t\t\tsought[i]->match_status = REF_MATCHED;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif (!keep && args->fetch_all &&\n\t\t    (!args->deepen || !starts_with(ref->name, \"refs/tags/\")))\n\t\t\tkeep = 1;\n\n\t\tif (keep) {\n\t\t\t*newtail = ref;\n\t\t\tref->next = NULL;\n\t\t\tnewtail = &ref->next;\n\t\t} else {\n\t\t\tref->next = unmatched;\n\t\t\tunmatched = ref;\n\t\t}\n\t}\n\n\t/* Append unmatched requests to the list */\n\tfor (i = 0; i < nr_sought; i++) {\n\t\tstruct object_id oid;\n\t\tconst char *p;\n\n\t\tref = sought[i];\n\t\tif (ref->match_status != REF_NOT_MATCHED)\n\t\t\tcontinue;\n\t\tif (parse_oid_hex(ref->name, &oid, &p) ||\n\t\t    *p != '\\0' ||\n\t\t    oidcmp(&oid, &ref->old_oid))\n\t\t\tcontinue;\n\n\t\tif ((allow_unadvertised_object_request &\n\t\t     (ALLOW_TIP_SHA1 | ALLOW_REACHABLE_SHA1)) ||\n\t\t    tip_oids_contain(&tip_oids, unmatched, newlist,\n\t\t\t\t     &ref->old_oid)) {\n\t\t\tref->match_status = REF_MATCHED;\n\t\t\t*newtail = copy_ref(ref);\n\t\t\tnewtail = &(*newtail)->next;\n\t\t} else {\n\t\t\tref->match_status = REF_UNADVERTISED_NOT_ALLOWED;\n\t\t}\n\t}\n\n\toidset_clear(&tip_oids);\n\tfor (ref = unmatched; ref; ref = next) {\n\t\tnext = ref->next;\n\t\tfree(ref);\n\t}\n\n\t*refs = newlist;\n}\n\nstatic void mark_alternate_complete(struct object *obj)\n{\n\tmark_complete(&obj->oid);\n}\n\nstatic int everything_local(struct fetch_pack_args *args,\n\t\t\t    struct ref **refs,\n\t\t\t    struct ref **sought, int nr_sought)\n{\n\tstruct ref *ref;\n\tint retval;\n\ttimestamp_t cutoff = 0;\n\n\tsave_commit_buffer = 0;\n\n\tfor (ref = *refs; ref; ref = ref->next) {\n\t\tstruct object *o;\n\n\t\tif (!has_object_file(&ref->old_oid))\n\t\t\tcontinue;\n\n\t\to = parse_object(&ref->old_oid);\n\t\tif (!o)\n\t\t\tcontinue;\n\n\t\t/* We already have it -- which may mean that we were\n\t\t * in sync with the other side at some time after\n\t\t * that (it is OK if we guess wrong here).\n\t\t */\n\t\tif (o->type == OBJ_COMMIT) {\n\t\t\tstruct commit *commit = (struct commit *)o;\n\t\t\tif (!cutoff || cutoff < commit->date)\n\t\t\t\tcutoff = commit->date;\n\t\t}\n\t}\n\n\tif (!args->deepen) {\n\t\tfor_each_ref(mark_complete_oid, NULL);\n\t\tfor_each_cached_alternate(mark_alternate_complete);\n\t\tcommit_list_sort_by_date(&complete);\n\t\tif (cutoff)\n\t\t\tmark_recent_complete_commits(args, cutoff);\n\t}\n\n\t/*\n\t * Mark all complete remote refs as common refs.\n\t * Don't mark them common yet; the server has to be told so first.\n\t */\n\tfor (ref = *refs; ref; ref = ref->next) {\n\t\tstruct object *o = deref_tag(lookup_object(ref->old_oid.hash),\n\t\t\t\t\t     NULL, 0);\n\n\t\tif (!o || o->type != OBJ_COMMIT || !(o->flags & COMPLETE))\n\t\t\tcontinue;\n\n\t\tif (!(o->flags & SEEN)) {\n\t\t\trev_list_push((struct commit *)o, COMMON_REF | SEEN);\n\n\t\t\tmark_common((struct commit *)o, 1, 1);\n\t\t}\n\t}\n\n\tfilter_refs(args, refs, sought, nr_sought);\n\n\tfor (retval = 1, ref = *refs; ref ; ref = ref->next) {\n\t\tconst struct object_id *remote = &ref->old_oid;\n\t\tstruct object *o;\n\n\t\to = lookup_object(remote->hash);\n\t\tif (!o || !(o->flags & COMPLETE)) {\n\t\t\tretval = 0;\n\t\t\tprint_verbose(args, \"want %s (%s)\", oid_to_hex(remote),\n\t\t\t\t      ref->name);\n\t\t\tcontinue;\n\t\t}\n\t\tprint_verbose(args, _(\"already have %s (%s)\"), oid_to_hex(remote),\n\t\t\t      ref->name);\n\t}\n\treturn retval;\n}\n\nstatic int sideband_demux(int in, int out, void *data)\n{\n\tint *xd = data;\n\tint ret;\n\n\tret = recv_sideband(\"fetch-pack\", xd[0], out);\n\tclose(out);\n\treturn ret;\n}\n\nstatic int get_pack(struct fetch_pack_args *args,\n\t\t    int xd[2], char **pack_lockfile)\n{\n\tstruct async demux;\n\tint do_keep = args->keep_pack;\n\tconst char *cmd_name;\n\tstruct pack_header header;\n\tint pass_header = 0;\n\tstruct child_process cmd = CHILD_PROCESS_INIT;\n\tint ret;\n\n\tmemset(&demux, 0, sizeof(demux));\n\tif (use_sideband) {\n\t\t/* xd[] is talking with upload-pack; subprocess reads from\n\t\t * xd[0], spits out band#2 to stderr, and feeds us band#1\n\t\t * through demux->out.\n\t\t */\n\t\tdemux.proc = sideband_demux;\n\t\tdemux.data = xd;\n\t\tdemux.out = -1;\n\t\tdemux.isolate_sigpipe = 1;\n\t\tif (start_async(&demux))\n\t\t\tdie(_(\"fetch-pack: unable to fork off sideband demultiplexer\"));\n\t}\n\telse\n\t\tdemux.out = xd[0];\n\n\tif (!args->keep_pack && unpack_limit) {\n\n\t\tif (read_pack_header(demux.out, &header))\n\t\t\tdie(_(\"protocol error: bad pack header\"));\n\t\tpass_header = 1;\n\t\tif (ntohl(header.hdr_entries) < unpack_limit)\n\t\t\tdo_keep = 0;\n\t\telse\n\t\t\tdo_keep = 1;\n\t}\n\n\tif (alternate_shallow_file) {\n\t\targv_array_push(&cmd.args, \"--shallow-file\");\n\t\targv_array_push(&cmd.args, alternate_shallow_file);\n\t}\n\n\tif (do_keep) {\n\t\tif (pack_lockfile)\n\t\t\tcmd.out = -1;\n\t\tcmd_name = \"index-pack\";\n\t\targv_array_push(&cmd.args, cmd_name);\n\t\targv_array_push(&cmd.args, \"--stdin\");\n\t\tif (!args->quiet && !args->no_progress)\n\t\t\targv_array_push(&cmd.args, \"-v\");\n\t\tif (args->use_thin_pack)\n\t\t\targv_array_push(&cmd.args, \"--fix-thin\");\n\t\tif (args->lock_pack || unpack_limit) {\n\t\t\tchar hostname[HOST_NAME_MAX + 1];\n\t\t\tif (xgethostname(hostname, sizeof(hostname)))\n\t\t\t\txsnprintf(hostname, sizeof(hostname), \"localhost\");\n\t\t\targv_array_pushf(&cmd.args,\n\t\t\t\t\t\"--keep=fetch-pack %\"PRIuMAX \" on %s\",\n\t\t\t\t\t(uintmax_t)getpid(), hostname);\n\t\t}\n\t\tif (args->check_self_contained_and_connected)\n\t\t\targv_array_push(&cmd.args, \"--check-self-contained-and-connected\");\n\t}\n\telse {\n\t\tcmd_name = \"unpack-objects\";\n\t\targv_array_push(&cmd.args, cmd_name);\n\t\tif (args->quiet || args->no_progress)\n\t\t\targv_array_push(&cmd.args, \"-q\");\n\t\targs->check_self_contained_and_connected = 0;\n\t}\n\n\tif (pass_header)\n\t\targv_array_pushf(&cmd.args, \"--pack_header=%\"PRIu32\",%\"PRIu32,\n\t\t\t\t ntohl(header.hdr_version),\n\t\t\t\t ntohl(header.hdr_entries));\n\tif (fetch_fsck_objects >= 0\n\t    ? fetch_fsck_objects\n\t    : transfer_fsck_objects >= 0\n\t    ? transfer_fsck_objects\n\t    : 0)\n\t\targv_array_push(&cmd.args, \"--strict\");\n\n\tcmd.in = demux.out;\n\tcmd.git_cmd = 1;\n\tif (start_command(&cmd))\n\t\tdie(_(\"fetch-pack: unable to fork off %s\"), cmd_name);\n\tif (do_keep && pack_lockfile) {\n\t\t*pack_lockfile = index_pack_lockfile(cmd.out);\n\t\tclose(cmd.out);\n\t}\n\n\tif (!use_sideband)\n\t\t/* Closed by start_command() */\n\t\txd[0] = -1;\n\n\tret = finish_command(&cmd);\n\tif (!ret || (args->check_self_contained_and_connected && ret == 1))\n\t\targs->self_contained_and_connected =\n\t\t\targs->check_self_contained_and_connected &&\n\t\t\tret == 0;\n\telse\n\t\tdie(_(\"%s failed\"), cmd_name);\n\tif (use_sideband && finish_async(&demux))\n\t\tdie(_(\"error in sideband demultiplexer\"));\n\treturn 0;\n}\n\nstatic int cmp_ref_by_name(const void *a_, const void *b_)\n{\n\tconst struct ref *a = *((const struct ref **)a_);\n\tconst struct ref *b = *((const struct ref **)b_);\n\treturn strcmp(a->name, b->name);\n}\n\nstatic struct ref *do_fetch_pack(struct fetch_pack_args *args,\n\t\t\t\t int fd[2],\n\t\t\t\t const struct ref *orig_ref,\n\t\t\t\t struct ref **sought, int nr_sought,\n\t\t\t\t struct shallow_info *si,\n\t\t\t\t char **pack_lockfile)\n{\n\tstruct ref *ref = copy_ref_list(orig_ref);\n\tstruct object_id oid;\n\tconst char *agent_feature;\n\tint agent_len;\n\n\tsort_ref_list(&ref, ref_compare_name);\n\tQSORT(sought, nr_sought, cmp_ref_by_name);\n\n\tif ((args->depth > 0 || is_repository_shallow()) && !server_supports(\"shallow\"))\n\t\tdie(_(\"Server does not support shallow clients\"));\n\tif (args->depth > 0 || args->deepen_since || args->deepen_not)\n\t\targs->deepen = 1;\n\tif (server_supports(\"multi_ack_detailed\")) {\n\t\tprint_verbose(args, _(\"Server supports multi_ack_detailed\"));\n\t\tmulti_ack = 2;\n\t\tif (server_supports(\"no-done\")) {\n\t\t\tprint_verbose(args, _(\"Server supports no-done\"));\n\t\t\tif (args->stateless_rpc)\n\t\t\t\tno_done = 1;\n\t\t}\n\t}\n\telse if (server_supports(\"multi_ack\")) {\n\t\tprint_verbose(args, _(\"Server supports multi_ack\"));\n\t\tmulti_ack = 1;\n\t}\n\tif (server_supports(\"side-band-64k\")) {\n\t\tprint_verbose(args, _(\"Server supports side-band-64k\"));\n\t\tuse_sideband = 2;\n\t}\n\telse if (server_supports(\"side-band\")) {\n\t\tprint_verbose(args, _(\"Server supports side-band\"));\n\t\tuse_sideband = 1;\n\t}\n\tif (server_supports(\"allow-tip-sha1-in-want\")) {\n\t\tprint_verbose(args, _(\"Server supports allow-tip-sha1-in-want\"));\n\t\tallow_unadvertised_object_request |= ALLOW_TIP_SHA1;\n\t}\n\tif (server_supports(\"allow-reachable-sha1-in-want\")) {\n\t\tprint_verbose(args, _(\"Server supports allow-reachable-sha1-in-want\"));\n\t\tallow_unadvertised_object_request |= ALLOW_REACHABLE_SHA1;\n\t}\n\tif (!server_supports(\"thin-pack\"))\n\t\targs->use_thin_pack = 0;\n\tif (!server_supports(\"no-progress\"))\n\t\targs->no_progress = 0;\n\tif (!server_supports(\"include-tag\"))\n\t\targs->include_tag = 0;\n\tif (server_supports(\"ofs-delta\"))\n\t\tprint_verbose(args, _(\"Server supports ofs-delta\"));\n\telse\n\t\tprefer_ofs_delta = 0;\n\n\tif ((agent_feature = server_feature_value(\"agent\", &agent_len))) {\n\t\tagent_supported = 1;\n\t\tif (agent_len)\n\t\t\tprint_verbose(args, _(\"Server version is %.*s\"),\n\t\t\t\t      agent_len, agent_feature);\n\t}\n\tif (server_supports(\"deepen-since\"))\n\t\tdeepen_since_ok = 1;\n\telse if (args->deepen_since)\n\t\tdie(_(\"Server does not support --shallow-since\"));\n\tif (server_supports(\"deepen-not\"))\n\t\tdeepen_not_ok = 1;\n\telse if (args->deepen_not)\n\t\tdie(_(\"Server does not support --shallow-exclude\"));\n\tif (!server_supports(\"deepen-relative\") && args->deepen_relative)\n\t\tdie(_(\"Server does not support --deepen\"));\n\n\tif (everything_local(args, &ref, sought, nr_sought)) {\n\t\tpacket_flush(fd[1]);\n\t\tgoto all_done;\n\t}\n\tif (find_common(args, fd, &oid, ref) < 0)\n\t\tif (!args->keep_pack)\n\t\t\t/* When cloning, it is not unusual to have\n\t\t\t * no common commit.\n\t\t\t */\n\t\t\twarning(_(\"no common commits\"));\n\n\tif (args->stateless_rpc)\n\t\tpacket_flush(fd[1]);\n\tif (args->deepen)\n\t\tsetup_alternate_shallow(&shallow_lock, &alternate_shallow_file,\n\t\t\t\t\tNULL);\n\telse if (si->nr_ours || si->nr_theirs)\n\t\talternate_shallow_file = setup_temporary_shallow(si->shallow);\n\telse\n\t\talternate_shallow_file = NULL;\n\tif (get_pack(args, fd, pack_lockfile))\n\t\tdie(_(\"git fetch-pack: fetch failed.\"));\n\n all_done:\n\treturn ref;\n}\n\nstatic void fetch_pack_config(void)\n{\n\tgit_config_get_int(\"fetch.unpacklimit\", &fetch_unpack_limit);\n\tgit_config_get_int(\"transfer.unpacklimit\", &transfer_unpack_limit);\n\tgit_config_get_bool(\"repack.usedeltabaseoffset\", &prefer_ofs_delta);\n\tgit_config_get_bool(\"fetch.fsckobjects\", &fetch_fsck_objects);\n\tgit_config_get_bool(\"transfer.fsckobjects\", &transfer_fsck_objects);\n\n\tgit_config(git_default_config, NULL);\n}\n\nstatic void fetch_pack_setup(void)\n{\n\tstatic int did_setup;\n\tif (did_setup)\n\t\treturn;\n\tfetch_pack_config();\n\tif (0 <= transfer_unpack_limit)\n\t\tunpack_limit = transfer_unpack_limit;\n\telse if (0 <= fetch_unpack_limit)\n\t\tunpack_limit = fetch_unpack_limit;\n\tdid_setup = 1;\n}\n\nstatic int remove_duplicates_in_refs(struct ref **ref, int nr)\n{\n\tstruct string_list names = STRING_LIST_INIT_NODUP;\n\tint src, dst;\n\n\tfor (src = dst = 0; src < nr; src++) {\n\t\tstruct string_list_item *item;\n\t\titem = string_list_insert(&names, ref[src]->name);\n\t\tif (item->util)\n\t\t\tcontinue; /* already have it */\n\t\titem->util = ref[src];\n\t\tif (src != dst)\n\t\t\tref[dst] = ref[src];\n\t\tdst++;\n\t}\n\tfor (src = dst; src < nr; src++)\n\t\tref[src] = NULL;\n\tstring_list_clear(&names, 0);\n\treturn dst;\n}\n\nstatic void update_shallow(struct fetch_pack_args *args,\n\t\t\t   struct ref **sought, int nr_sought,\n\t\t\t   struct shallow_info *si)\n{\n\tstruct oid_array ref = OID_ARRAY_INIT;\n\tint *status;\n\tint i;\n\n\tif (args->deepen && alternate_shallow_file) {\n\t\tif (*alternate_shallow_file == '\\0') { /* --unshallow */\n\t\t\tunlink_or_warn(git_path_shallow());\n\t\t\trollback_lock_file(&shallow_lock);\n\t\t} else\n\t\t\tcommit_lock_file(&shallow_lock);\n\t\treturn;\n\t}\n\n\tif (!si->shallow || !si->shallow->nr)\n\t\treturn;\n\n\tif (args->cloning) {\n\t\t/*\n\t\t * remote is shallow, but this is a clone, there are\n\t\t * no objects in repo to worry about. Accept any\n\t\t * shallow points that exist in the pack (iow in repo\n\t\t * after get_pack() and reprepare_packed_git())\n\t\t */\n\t\tstruct oid_array extra = OID_ARRAY_INIT;\n\t\tstruct object_id *oid = si->shallow->oid;\n\t\tfor (i = 0; i < si->shallow->nr; i++)\n\t\t\tif (has_object_file(&oid[i]))\n\t\t\t\toid_array_append(&extra, &oid[i]);\n\t\tif (extra.nr) {\n\t\t\tsetup_alternate_shallow(&shallow_lock,\n\t\t\t\t\t\t&alternate_shallow_file,\n\t\t\t\t\t\t&extra);\n\t\t\tcommit_lock_file(&shallow_lock);\n\t\t}\n\t\toid_array_clear(&extra);\n\t\treturn;\n\t}\n\n\tif (!si->nr_ours && !si->nr_theirs)\n\t\treturn;\n\n\tremove_nonexistent_theirs_shallow(si);\n\tif (!si->nr_ours && !si->nr_theirs)\n\t\treturn;\n\tfor (i = 0; i < nr_sought; i++)\n\t\toid_array_append(&ref, &sought[i]->old_oid);\n\tsi->ref = &ref;\n\n\tif (args->update_shallow) {\n\t\t/*\n\t\t * remote is also shallow, .git/shallow may be updated\n\t\t * so all refs can be accepted. Make sure we only add\n\t\t * shallow roots that are actually reachable from new\n\t\t * refs.\n\t\t */\n\t\tstruct oid_array extra = OID_ARRAY_INIT;\n\t\tstruct object_id *oid = si->shallow->oid;\n\t\tassign_shallow_commits_to_refs(si, NULL, NULL);\n\t\tif (!si->nr_ours && !si->nr_theirs) {\n\t\t\toid_array_clear(&ref);\n\t\t\treturn;\n\t\t}\n\t\tfor (i = 0; i < si->nr_ours; i++)\n\t\t\toid_array_append(&extra, &oid[si->ours[i]]);\n\t\tfor (i = 0; i < si->nr_theirs; i++)\n\t\t\toid_array_append(&extra, &oid[si->theirs[i]]);\n\t\tsetup_alternate_shallow(&shallow_lock,\n\t\t\t\t\t&alternate_shallow_file,\n\t\t\t\t\t&extra);\n\t\tcommit_lock_file(&shallow_lock);\n\t\toid_array_clear(&extra);\n\t\toid_array_clear(&ref);\n\t\treturn;\n\t}\n\n\t/*\n\t * remote is also shallow, check what ref is safe to update\n\t * without updating .git/shallow\n\t */\n\tstatus = xcalloc(nr_sought, sizeof(*status));\n\tassign_shallow_commits_to_refs(si, NULL, status);\n\tif (si->nr_ours || si->nr_theirs) {\n\t\tfor (i = 0; i < nr_sought; i++)\n\t\t\tif (status[i])\n\t\t\t\tsought[i]->status = REF_STATUS_REJECT_SHALLOW;\n\t}\n\tfree(status);\n\toid_array_clear(&ref);\n}\n\nstruct ref *fetch_pack(struct fetch_pack_args *args,\n\t\t       int fd[], struct child_process *conn,\n\t\t       const struct ref *ref,\n\t\t       const char *dest,\n\t\t       struct ref **sought, int nr_sought,\n\t\t       struct oid_array *shallow,\n\t\t       char **pack_lockfile)\n{\n\tstruct ref *ref_cpy;\n\tstruct shallow_info si;\n\n\tfetch_pack_setup();\n\tif (nr_sought)\n\t\tnr_sought = remove_duplicates_in_refs(sought, nr_sought);\n\n\tif (!ref) {\n\t\tpacket_flush(fd[1]);\n\t\tdie(_(\"no matching remote head\"));\n\t}\n\tprepare_shallow_info(&si, shallow);\n\tref_cpy = do_fetch_pack(args, fd, ref, sought, nr_sought,\n\t\t\t\t&si, pack_lockfile);\n\treprepare_packed_git();\n\tupdate_shallow(args, sought, nr_sought, &si);\n\tclear_shallow_info(&si);\n\treturn ref_cpy;\n}\n\nint report_unmatched_refs(struct ref **sought, int nr_sought)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < nr_sought; i++) {\n\t\tif (!sought[i])\n\t\t\tcontinue;\n\t\tswitch (sought[i]->match_status) {\n\t\tcase REF_MATCHED:\n\t\t\tcontinue;\n\t\tcase REF_NOT_MATCHED:\n\t\t\terror(_(\"no such remote ref %s\"), sought[i]->name);\n\t\t\tbreak;\n\t\tcase REF_UNADVERTISED_NOT_ALLOWED:\n\t\t\terror(_(\"Server does not allow request for unadvertised object %s\"),\n\t\t\t      sought[i]->name);\n\t\t\tbreak;\n\t\t}\n\t\tret = 1;\n\t}\n\treturn ret;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "008b25d3db08726b0fc1569f88fba76694bbcc12",
  "sha1_ok": true,
  "size": 31113
}
