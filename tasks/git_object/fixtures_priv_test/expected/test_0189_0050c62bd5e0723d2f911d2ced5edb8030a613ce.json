{
  "content": {
    "base64": "I2RlZmluZSBVU0VfVEhFX1JFUE9TSVRPUllfVkFSSUFCTEUKI2RlZmluZSBESVNBQkxFX1NJR05fQ09NUEFSRV9XQVJOSU5HUwoKI2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAiYnVuZGxlLXVyaS5oIgojaW5jbHVkZSAiYnVuZGxlLmgiCiNpbmNsdWRlICJjb3B5LmgiCiNpbmNsdWRlICJnZXR0ZXh0LmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAiaGFzaG1hcC5oIgojaW5jbHVkZSAicGt0LWxpbmUuaCIKI2luY2x1ZGUgImNvbmZpZy5oIgojaW5jbHVkZSAiZmV0Y2gtcGFjay5oIgojaW5jbHVkZSAicmVtb3RlLmgiCiNpbmNsdWRlICJ0cmFjZTIuaCIKI2luY2x1ZGUgIm9iamVjdC1zdG9yZS5oIgoKc3RhdGljIHN0cnVjdCB7CgllbnVtIGJ1bmRsZV9saXN0X2hldXJpc3RpYyBoZXVyaXN0aWM7Cgljb25zdCBjaGFyICpuYW1lOwp9IGhldXJpc3RpY3NbQlVORExFX0hFVVJJU1RJQ19fQ09VTlRdID0gewoJeyBCVU5ETEVfSEVVUklTVElDX05PTkUsICIifSwKCXsgQlVORExFX0hFVVJJU1RJQ19DUkVBVElPTlRPS0VOLCAiY3JlYXRpb25Ub2tlbiIgfSwKfTsKCnN0YXRpYyBpbnQgY29tcGFyZV9idW5kbGVzKGNvbnN0IHZvaWQgKmhhc2htYXBfY21wX2ZuX2RhdGEgVU5VU0VELAoJCQkgICBjb25zdCBzdHJ1Y3QgaGFzaG1hcF9lbnRyeSAqaGUxLAoJCQkgICBjb25zdCBzdHJ1Y3QgaGFzaG1hcF9lbnRyeSAqaGUyLAoJCQkgICBjb25zdCB2b2lkICppZCkKewoJY29uc3Qgc3RydWN0IHJlbW90ZV9idW5kbGVfaW5mbyAqZTEgPQoJCWNvbnRhaW5lcl9vZihoZTEsIGNvbnN0IHN0cnVjdCByZW1vdGVfYnVuZGxlX2luZm8sIGVudCk7Cgljb25zdCBzdHJ1Y3QgcmVtb3RlX2J1bmRsZV9pbmZvICplMiA9CgkJY29udGFpbmVyX29mKGhlMiwgY29uc3Qgc3RydWN0IHJlbW90ZV9idW5kbGVfaW5mbywgZW50KTsKCglyZXR1cm4gc3RyY21wKGUxLT5pZCwgaWQgPyAoY29uc3QgY2hhciAqKWlkIDogZTItPmlkKTsKfQoKdm9pZCBpbml0X2J1bmRsZV9saXN0KHN0cnVjdCBidW5kbGVfbGlzdCAqbGlzdCkKewoJbWVtc2V0KGxpc3QsIDAsIHNpemVvZigqbGlzdCkpOwoKCS8qIEltcGxpZWQgZGVmYXVsdHMuICovCglsaXN0LT5tb2RlID0gQlVORExFX01PREVfQUxMOwoJbGlzdC0+dmVyc2lvbiA9IDE7CgoJaGFzaG1hcF9pbml0KCZsaXN0LT5idW5kbGVzLCBjb21wYXJlX2J1bmRsZXMsIE5VTEwsIDApOwp9CgpzdGF0aWMgaW50IGNsZWFyX3JlbW90ZV9idW5kbGVfaW5mbyhzdHJ1Y3QgcmVtb3RlX2J1bmRsZV9pbmZvICpidW5kbGUsCgkJCQkgICAgdm9pZCAqZGF0YSBVTlVTRUQpCnsKCUZSRUVfQU5EX05VTEwoYnVuZGxlLT5pZCk7CglGUkVFX0FORF9OVUxMKGJ1bmRsZS0+dXJpKTsKCUZSRUVfQU5EX05VTEwoYnVuZGxlLT5maWxlKTsKCWJ1bmRsZS0+dW5idW5kbGVkID0gMDsKCXJldHVybiAwOwp9Cgp2b2lkIGNsZWFyX2J1bmRsZV9saXN0KHN0cnVjdCBidW5kbGVfbGlzdCAqbGlzdCkKewoJaWYgKCFsaXN0KQoJCXJldHVybjsKCglmb3JfYWxsX2J1bmRsZXNfaW5fbGlzdChsaXN0LCBjbGVhcl9yZW1vdGVfYnVuZGxlX2luZm8sIE5VTEwpOwoJaGFzaG1hcF9jbGVhcl9hbmRfZnJlZSgmbGlzdC0+YnVuZGxlcywgc3RydWN0IHJlbW90ZV9idW5kbGVfaW5mbywgZW50KTsKCWZyZWUobGlzdC0+YmFzZVVSSSk7Cn0KCmludCBmb3JfYWxsX2J1bmRsZXNfaW5fbGlzdChzdHJ1Y3QgYnVuZGxlX2xpc3QgKmxpc3QsCgkJCSAgICBidW5kbGVfaXRlcmF0b3IgaXRlciwKCQkJICAgIHZvaWQgKmRhdGEpCnsKCXN0cnVjdCByZW1vdGVfYnVuZGxlX2luZm8gKmluZm87CglzdHJ1Y3QgaGFzaG1hcF9pdGVyIGk7CgoJaGFzaG1hcF9mb3JfZWFjaF9lbnRyeSgmbGlzdC0+YnVuZGxlcywgJmksIGluZm8sIGVudCkgewoJCWludCByZXN1bHQgPSBpdGVyKGluZm8sIGRhdGEpOwoKCQlpZiAocmVzdWx0KQoJCQlyZXR1cm4gcmVzdWx0OwoJfQoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHN1bW1hcml6ZV9idW5kbGUoc3RydWN0IHJlbW90ZV9idW5kbGVfaW5mbyAqaW5mbywgdm9pZCAqZGF0YSkKewoJRklMRSAqZnAgPSBkYXRhOwoJZnByaW50ZihmcCwgIltidW5kbGUgXCIlc1wiXVxuIiwgaW5mby0+aWQpOwoJZnByaW50ZihmcCwgIlx0dXJpID0gJXNcbiIsIGluZm8tPnVyaSk7CgoJaWYgKGluZm8tPmNyZWF0aW9uVG9rZW4pCgkJZnByaW50ZihmcCwgIlx0Y3JlYXRpb25Ub2tlbiA9ICUiUFJJdTY0IlxuIiwgaW5mby0+Y3JlYXRpb25Ub2tlbik7CglyZXR1cm4gMDsKfQoKdm9pZCBwcmludF9idW5kbGVfbGlzdChGSUxFICpmcCwgc3RydWN0IGJ1bmRsZV9saXN0ICpsaXN0KQp7Cgljb25zdCBjaGFyICptb2RlOwoKCXN3aXRjaCAobGlzdC0+bW9kZSkgewoJY2FzZSBCVU5ETEVfTU9ERV9BTEw6CgkJbW9kZSA9ICJhbGwiOwoJCWJyZWFrOwoKCWNhc2UgQlVORExFX01PREVfQU5ZOgoJCW1vZGUgPSAiYW55IjsKCQlicmVhazsKCgljYXNlIEJVTkRMRV9NT0RFX05PTkU6CglkZWZhdWx0OgoJCW1vZGUgPSAiPHVua25vd24+IjsKCX0KCglmcHJpbnRmKGZwLCAiW2J1bmRsZV1cbiIpOwoJZnByaW50ZihmcCwgIlx0dmVyc2lvbiA9ICVkXG4iLCBsaXN0LT52ZXJzaW9uKTsKCWZwcmludGYoZnAsICJcdG1vZGUgPSAlc1xuIiwgbW9kZSk7CgoJaWYgKGxpc3QtPmhldXJpc3RpYykgewoJCWludCBpOwoJCWZvciAoaSA9IDA7IGkgPCBCVU5ETEVfSEVVUklTVElDX19DT1VOVDsgaSsrKSB7CgkJCWlmIChoZXVyaXN0aWNzW2ldLmhldXJpc3RpYyA9PSBsaXN0LT5oZXVyaXN0aWMpIHsKCQkJCXByaW50ZigiXHRoZXVyaXN0aWMgPSAlc1xuIiwKCQkJCSAgICAgICBoZXVyaXN0aWNzW2xpc3QtPmhldXJpc3RpY10ubmFtZSk7CgkJCQlicmVhazsKCQkJfQoJCX0KCX0KCglmb3JfYWxsX2J1bmRsZXNfaW5fbGlzdChsaXN0LCBzdW1tYXJpemVfYnVuZGxlLCBmcCk7Cn0KCi8qKgogKiBHaXZlbiBhIGtleS12YWx1ZSBwYWlyLCB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSBnaXZlbiBidW5kbGUgbGlzdC4KICogUmV0dXJucyAwIGlmIHRoZSBrZXktdmFsdWUgcGFpciBpcyB1bmRlcnN0b29kLiBSZXR1cm5zIC0xIGlmIHRoZSBrZXkKICogaXMgbm90IHVuZGVyc3Rvb2Qgb3IgdGhlIHZhbHVlIGlzIG1hbGZvcm1lZC4KICovCnN0YXRpYyBpbnQgYnVuZGxlX2xpc3RfdXBkYXRlKGNvbnN0IGNoYXIgKmtleSwgY29uc3QgY2hhciAqdmFsdWUsCgkJCSAgICAgIHN0cnVjdCBidW5kbGVfbGlzdCAqbGlzdCkKewoJc3RydWN0IHN0cmJ1ZiBpZCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHJlbW90ZV9idW5kbGVfaW5mbyBsb29rdXAgPSBSRU1PVEVfQlVORExFX0lORk9fSU5JVDsKCXN0cnVjdCByZW1vdGVfYnVuZGxlX2luZm8gKmJ1bmRsZTsKCWNvbnN0IGNoYXIgKnN1YnNlY3Rpb24sICpzdWJrZXk7CglzaXplX3Qgc3Vic2VjdGlvbl9sZW47CgoJaWYgKHBhcnNlX2NvbmZpZ19rZXkoa2V5LCAiYnVuZGxlIiwgJnN1YnNlY3Rpb24sICZzdWJzZWN0aW9uX2xlbiwgJnN1YmtleSkpCgkJcmV0dXJuIC0xOwoKCWlmICghc3Vic2VjdGlvbl9sZW4pIHsKCQlpZiAoIXN0cmNtcChzdWJrZXksICJ2ZXJzaW9uIikpIHsKCQkJaW50IHZlcnNpb247CgkJCWlmICghZ2l0X3BhcnNlX2ludCh2YWx1ZSwgJnZlcnNpb24pKQoJCQkJcmV0dXJuIC0xOwoJCQlpZiAodmVyc2lvbiAhPSAxKQoJCQkJcmV0dXJuIC0xOwoKCQkJbGlzdC0+dmVyc2lvbiA9IHZlcnNpb247CgkJCXJldHVybiAwOwoJCX0KCgkJaWYgKCFzdHJjbXAoc3Via2V5LCAibW9kZSIpKSB7CgkJCWlmICghc3RyY21wKHZhbHVlLCAiYWxsIikpCgkJCQlsaXN0LT5tb2RlID0gQlVORExFX01PREVfQUxMOwoJCQllbHNlIGlmICghc3RyY21wKHZhbHVlLCAiYW55IikpCgkJCQlsaXN0LT5tb2RlID0gQlVORExFX01PREVfQU5ZOwoJCQllbHNlCgkJCQlyZXR1cm4gLTE7CgkJCXJldHVybiAwOwoJCX0KCgkJaWYgKCFzdHJjbXAoc3Via2V5LCAiaGV1cmlzdGljIikpIHsKCQkJaW50IGk7CgkJCWZvciAoaSA9IDA7IGkgPCBCVU5ETEVfSEVVUklTVElDX19DT1VOVDsgaSsrKSB7CgkJCQlpZiAoaGV1cmlzdGljc1tpXS5oZXVyaXN0aWMgJiYKCQkJCSAgICBoZXVyaXN0aWNzW2ldLm5hbWUgJiYKCQkJCSAgICAhc3RyY21wKHZhbHVlLCBoZXVyaXN0aWNzW2ldLm5hbWUpKSB7CgkJCQkJbGlzdC0+aGV1cmlzdGljID0gaGV1cmlzdGljc1tpXS5oZXVyaXN0aWM7CgkJCQkJcmV0dXJuIDA7CgkJCQl9CgkJCX0KCgkJCS8qIElnbm9yZSB1bmtub3duIGhldXJpc3RpY3MuICovCgkJCXJldHVybiAwOwoJCX0KCgkJLyogSWdub3JlIG90aGVyIHVua25vd24gZ2xvYmFsIGtleXMuICovCgkJcmV0dXJuIDA7Cgl9CgoJc3RyYnVmX2FkZCgmaWQsIHN1YnNlY3Rpb24sIHN1YnNlY3Rpb25fbGVuKTsKCgkvKgoJICogQ2hlY2sgZm9yIGFuIGV4aXN0aW5nIGJ1bmRsZSB3aXRoIHRoaXMgPGlkPiwgb3IgY3JlYXRlIG9uZQoJICogaWYgbmVjZXNzYXJ5LgoJICovCglsb29rdXAuaWQgPSBpZC5idWY7CgloYXNobWFwX2VudHJ5X2luaXQoJmxvb2t1cC5lbnQsIHN0cmhhc2gobG9va3VwLmlkKSk7CglpZiAoIShidW5kbGUgPSBoYXNobWFwX2dldF9lbnRyeSgmbGlzdC0+YnVuZGxlcywgJmxvb2t1cCwgZW50LCBOVUxMKSkpIHsKCQlDQUxMT0NfQVJSQVkoYnVuZGxlLCAxKTsKCQlidW5kbGUtPmlkID0gc3RyYnVmX2RldGFjaCgmaWQsIE5VTEwpOwoJCWhhc2htYXBfZW50cnlfaW5pdCgmYnVuZGxlLT5lbnQsIHN0cmhhc2goYnVuZGxlLT5pZCkpOwoJCWhhc2htYXBfYWRkKCZsaXN0LT5idW5kbGVzLCAmYnVuZGxlLT5lbnQpOwoJfQoJc3RyYnVmX3JlbGVhc2UoJmlkKTsKCglpZiAoIXN0cmNtcChzdWJrZXksICJ1cmkiKSkgewoJCWlmIChidW5kbGUtPnVyaSkKCQkJcmV0dXJuIC0xOwoJCWJ1bmRsZS0+dXJpID0gcmVsYXRpdmVfdXJsKGxpc3QtPmJhc2VVUkksIHZhbHVlLCBOVUxMKTsKCQlyZXR1cm4gMDsKCX0KCglpZiAoIXN0cmNtcChzdWJrZXksICJjcmVhdGlvbnRva2VuIikpIHsKCQlpZiAoc3NjYW5mKHZhbHVlLCAiJSJQUkl1NjQsICZidW5kbGUtPmNyZWF0aW9uVG9rZW4pICE9IDEpCgkJCXdhcm5pbmcoXygiY291bGQgbm90IHBhcnNlIGJ1bmRsZSBsaXN0IGtleSAlcyB3aXRoIHZhbHVlICclcyciKSwKCQkJCSJjcmVhdGlvblRva2VuIiwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoKCS8qCgkgKiBBdCB0aGlzIHBvaW50LCB3ZSBpZ25vcmUgYW55IGluZm9ybWF0aW9uIHRoYXQgd2UgZG9uJ3QKCSAqIHVuZGVyc3RhbmQsIGFzc3VtaW5nIGl0IHRvIGJlIGhpbnRzIGZvciBhIGhldXJpc3RpYyB0aGUgY2xpZW50CgkgKiBkb2VzIG5vdCBjdXJyZW50bHkgdW5kZXJzdGFuZC4KCSAqLwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgY29uZmlnX3RvX2J1bmRsZV9saXN0KGNvbnN0IGNoYXIgKmtleSwgY29uc3QgY2hhciAqdmFsdWUsCgkJCQkgY29uc3Qgc3RydWN0IGNvbmZpZ19jb250ZXh0ICpjdHggVU5VU0VELAoJCQkJIHZvaWQgKmRhdGEpCnsKCXN0cnVjdCBidW5kbGVfbGlzdCAqbGlzdCA9IGRhdGE7CglyZXR1cm4gYnVuZGxlX2xpc3RfdXBkYXRlKGtleSwgdmFsdWUsIGxpc3QpOwp9CgppbnQgYnVuZGxlX3VyaV9wYXJzZV9jb25maWdfZm9ybWF0KGNvbnN0IGNoYXIgKnVyaSwKCQkJCSAgIGNvbnN0IGNoYXIgKmZpbGVuYW1lLAoJCQkJICAgc3RydWN0IGJ1bmRsZV9saXN0ICpsaXN0KQp7CglpbnQgcmVzdWx0OwoJc3RydWN0IGNvbmZpZ19vcHRpb25zIG9wdHMgPSB7CgkJLmVycm9yX2FjdGlvbiA9IENPTkZJR19FUlJPUl9FUlJPUiwKCX07CgoJaWYgKCFsaXN0LT5iYXNlVVJJKSB7CgkJc3RydWN0IHN0cmJ1ZiBiYXNlVVJJID0gU1RSQlVGX0lOSVQ7CgkJc3RyYnVmX2FkZHN0cigmYmFzZVVSSSwgdXJpKTsKCgkJLyoKCQkgKiBJZiB0aGUgVVJJIGRvZXMgbm90IGVuZCB3aXRoIGEgdHJhaWxpbmcgc2xhc2gsIHRoZW4KCQkgKiByZW1vdmUgdGhlIGZpbGVuYW1lIHBvcnRpb24gb2YgdGhlIHBhdGguIFRoaXMgaXMKCQkgKiBpbXBvcnRhbnQgZm9yIHJlbGF0aXZlIFVSSXMuCgkJICovCgkJc3RyYnVmX3N0cmlwX2ZpbGVfZnJvbV9wYXRoKCZiYXNlVVJJKTsKCQlsaXN0LT5iYXNlVVJJID0gc3RyYnVmX2RldGFjaCgmYmFzZVVSSSwgTlVMTCk7Cgl9CglyZXN1bHQgPSBnaXRfY29uZmlnX2Zyb21fZmlsZV93aXRoX29wdGlvbnMoY29uZmlnX3RvX2J1bmRsZV9saXN0LAoJCQkJCQkgICBmaWxlbmFtZSwgbGlzdCwKCQkJCQkJICAgQ09ORklHX1NDT1BFX1VOS05PV04sCgkJCQkJCSAgICZvcHRzKTsKCglpZiAoIXJlc3VsdCAmJiBsaXN0LT5tb2RlID09IEJVTkRMRV9NT0RFX05PTkUpIHsKCQl3YXJuaW5nKF8oImJ1bmRsZSBsaXN0IGF0ICclcycgaGFzIG5vIG1vZGUiKSwgdXJpKTsKCQlyZXN1bHQgPSAxOwoJfQoKCXJldHVybiByZXN1bHQ7Cn0KCnN0YXRpYyBjaGFyICpmaW5kX3RlbXBfZmlsZW5hbWUodm9pZCkKewoJaW50IGZkOwoJc3RydWN0IHN0cmJ1ZiBuYW1lID0gU1RSQlVGX0lOSVQ7CgkvKgoJICogRmluZCBhIHRlbXBvcmFyeSBmaWxlbmFtZSB0aGF0IGlzIGF2YWlsYWJsZS4gVGhpcyBpcyBicmllZmx5CgkgKiByYWN5LCBidXQgdW5saWtlbHkgdG8gY29sbGlkZS4KCSAqLwoJZmQgPSBvZGJfbWtzdGVtcCgmbmFtZSwgImJ1bmRsZXMvdG1wX3VyaV9YWFhYWFgiKTsKCWlmIChmZCA8IDApIHsKCQl3YXJuaW5nKF8oImZhaWxlZCB0byBjcmVhdGUgdGVtcG9yYXJ5IGZpbGUiKSk7CgkJcmV0dXJuIE5VTEw7Cgl9CgoJY2xvc2UoZmQpOwoJdW5saW5rKG5hbWUuYnVmKTsKCXJldHVybiBzdHJidWZfZGV0YWNoKCZuYW1lLCBOVUxMKTsKfQoKc3RhdGljIGludCBkb3dubG9hZF9odHRwc191cmlfdG9fZmlsZShjb25zdCBjaGFyICpmaWxlLCBjb25zdCBjaGFyICp1cmkpCnsKCWludCByZXN1bHQgPSAwOwoJc3RydWN0IGNoaWxkX3Byb2Nlc3MgY3AgPSBDSElMRF9QUk9DRVNTX0lOSVQ7CglGSUxFICpjaGlsZF9pbiA9IE5VTEwsICpjaGlsZF9vdXQgPSBOVUxMOwoJc3RydWN0IHN0cmJ1ZiBsaW5lID0gU1RSQlVGX0lOSVQ7CglpbnQgZm91bmRfZ2V0ID0gMDsKCgkvKgoJICogVGhlIHByb3RvY29sIHdlIHNwZWFrIHdpdGggZ2l0LXJlbW90ZS1odHRwcygxKSB1c2VzIGEgc3BhY2UgdG8KCSAqIHNlcGFyYXRlIGJldHdlZW4gVVJJIGFuZCBmaWxlLCBzbyB0aGUgVVJJIGl0c2VsZiBtdXN0IG5vdCBjb250YWluIGEKCSAqIHNwYWNlLiBJZiBpdCBkaWQsIGFuIGFkdmVyc2FyeSBjb3VsZCBjaGFuZ2UgdGhlIGxvY2F0aW9uIHdoZXJlIHRoZQoJICogZG93bmxvYWRlZCBmaWxlIGlzIGJlaW5nIHdyaXR0ZW4gdG8uCgkgKgoJICogU2ltaWxhcmx5LCB3ZSB1c2UgbmV3bGluZXMgdG8gc2VwYXJhdGUgY29tbWFuZHMgZnJvbSBvbmUgYW5vdGhlci4KCSAqIENvbnNlcXVlbnRseSwgbmVpdGhlciB0aGUgVVJJIG5vciB0aGUgZmlsZSBtdXN0IGNvbnRhaW4gYSBuZXdsaW5lIG9yCgkgKiBvdGhlcndpc2UgYW4gYWR2ZXJzYXJ5IGNvdWxkIGluamVjdCBhcmJpdHJhcnkgY29tbWFuZHMuCgkgKgoJICogVE9ETzogUmVzdHJpY3RpbmcgbmV3bGluZXMgaW4gdGhlIHRhcmdldCBwYXRocyBtYXkgYnJlYWsgdmFsaWQKCSAqICAgICAgIHVzZWNhc2VzLCBldmVuIGlmIHRob3NlIGFyZSBhIGJpdCBtb3JlIG9uIHRoZSBlc290ZXJpYyBzaWRlLgoJICogICAgICAgSWYgdGhpcyBldmVyIGJlY29tZXMgYSBwcm9ibGVtIHdlIHNob3VsZCBwcm9iYWJseSB0aGluayBhYm91dAoJICogICAgICAgYWx0ZXJuYXRpdmVzLiBPbmUgYWx0ZXJuYXRpdmUgY291bGQgYmUgdG8gdXNlIE5VTC1kZWxpbWl0ZWQKCSAqICAgICAgIHJlcXVlc3RzIGluIGdpdC1yZW1vdGUtaHR0cCgxKS4gQW5vdGhlciBhbHRlcm5hdGl2ZSBjb3VsZCBiZQoJICogICAgICAgdG8gdXNlIFVSTCBxdW90aW5nLgoJICovCglpZiAoc3RycGJyayh1cmksICIgXG4iKSkKCQlyZXR1cm4gZXJyb3IoImJ1bmRsZS11cmk6IFVSSSBpcyBtYWxmb3JtZWQ6ICclcyciLCBmaWxlKTsKCWlmIChzdHJjaHIoZmlsZSwgJ1xuJykpCgkJcmV0dXJuIGVycm9yKCJidW5kbGUtdXJpOiBmaWxlbmFtZSBpcyBtYWxmb3JtZWQ6ICclcyciLCBmaWxlKTsKCglzdHJ2ZWNfcHVzaGwoJmNwLmFyZ3MsICJnaXQtcmVtb3RlLWh0dHBzIiwgdXJpLCBOVUxMKTsKCWNwLmVyciA9IC0xOwoJY3AuaW4gPSAtMTsKCWNwLm91dCA9IC0xOwoKCWlmIChzdGFydF9jb21tYW5kKCZjcCkpCgkJcmV0dXJuIDE7CgoJY2hpbGRfaW4gPSBmZG9wZW4oY3AuaW4sICJ3Iik7CglpZiAoIWNoaWxkX2luKSB7CgkJcmVzdWx0ID0gMTsKCQlnb3RvIGNsZWFudXA7Cgl9CgoJY2hpbGRfb3V0ID0gZmRvcGVuKGNwLm91dCwgInIiKTsKCWlmICghY2hpbGRfb3V0KSB7CgkJcmVzdWx0ID0gMTsKCQlnb3RvIGNsZWFudXA7Cgl9CgoJZnByaW50ZihjaGlsZF9pbiwgImNhcGFiaWxpdGllc1xuIik7CglmZmx1c2goY2hpbGRfaW4pOwoKCXdoaWxlICghc3RyYnVmX2dldGxpbmUoJmxpbmUsIGNoaWxkX291dCkpIHsKCQlpZiAoIWxpbmUubGVuKQoJCQlicmVhazsKCQlpZiAoIXN0cmNtcChsaW5lLmJ1ZiwgImdldCIpKQoJCQlmb3VuZF9nZXQgPSAxOwoJfQoJc3RyYnVmX3JlbGVhc2UoJmxpbmUpOwoKCWlmICghZm91bmRfZ2V0KSB7CgkJcmVzdWx0ID0gZXJyb3IoXygiaW5zdWZmaWNpZW50IGNhcGFiaWxpdGllcyIpKTsKCQlnb3RvIGNsZWFudXA7Cgl9CgoJZnByaW50ZihjaGlsZF9pbiwgImdldCAlcyAlc1xuXG4iLCB1cmksIGZpbGUpOwoKY2xlYW51cDoKCWlmIChjaGlsZF9pbikKCQlmY2xvc2UoY2hpbGRfaW4pOwoJaWYgKGZpbmlzaF9jb21tYW5kKCZjcCkpCgkJcmV0dXJuIDE7CglpZiAoY2hpbGRfb3V0KQoJCWZjbG9zZShjaGlsZF9vdXQpOwoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIGludCBjb3B5X3VyaV90b19maWxlKGNvbnN0IGNoYXIgKmZpbGVuYW1lLCBjb25zdCBjaGFyICp1cmkpCnsKCWNvbnN0IGNoYXIgKm91dDsKCglpZiAoc3RhcnRzX3dpdGgodXJpLCAiaHR0cHM6IikgfHwKCSAgICBzdGFydHNfd2l0aCh1cmksICJodHRwOiIpKQoJCXJldHVybiBkb3dubG9hZF9odHRwc191cmlfdG9fZmlsZShmaWxlbmFtZSwgdXJpKTsKCglpZiAoc2tpcF9wcmVmaXgodXJpLCAiZmlsZTovLyIsICZvdXQpKQoJCXVyaSA9IG91dDsKCgkvKiBDb3B5IGFzIGEgZmlsZSAqLwoJcmV0dXJuIGNvcHlfZmlsZShmaWxlbmFtZSwgdXJpLCAwKTsKfQoKc3RhdGljIGludCB1bmJ1bmRsZV9mcm9tX2ZpbGUoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IGNoYXIgKmZpbGUpCnsKCWludCByZXN1bHQgPSAwOwoJaW50IGJ1bmRsZV9mZDsKCXN0cnVjdCBidW5kbGVfaGVhZGVyIGhlYWRlciA9IEJVTkRMRV9IRUFERVJfSU5JVDsKCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICpyZWZuYW1lOwoJc3RydWN0IHN0cmJ1ZiBidW5kbGVfcmVmID0gU1RSQlVGX0lOSVQ7CglzaXplX3QgYnVuZGxlX3ByZWZpeF9sZW47CglzdHJ1Y3QgdW5idW5kbGVfb3B0cyBvcHRzID0gewoJCS5mbGFncyA9IFZFUklGWV9CVU5ETEVfUVVJRVQgfAoJCQkgKGZldGNoX3BhY2tfZnNja19vYmplY3RzKCkgPyBWRVJJRllfQlVORExFX0ZTQ0sgOiAwKSwKCX07CgoJYnVuZGxlX2ZkID0gcmVhZF9idW5kbGVfaGVhZGVyKGZpbGUsICZoZWFkZXIpOwoJaWYgKGJ1bmRsZV9mZCA8IDApIHsKCQlyZXN1bHQgPSAxOwoJCWdvdG8gY2xlYW51cDsKCX0KCgkvKgoJICogU2tpcCB0aGUgcmVhY2hhYmlsaXR5IHdhbGsgaGVyZSwgc2luY2Ugd2Ugd2lsbCBiZSBhZGRpbmcKCSAqIGEgcmVhY2hhYmxlIHJlZiBwb2ludGluZyB0byB0aGUgbmV3IHRpcHMsIHdoaWNoIHdpbGwgcmVhY2gKCSAqIHRoZSBwcmVyZXF1aXNpdGUgY29tbWl0cy4KCSAqLwoJcmVzdWx0ID0gdW5idW5kbGUociwgJmhlYWRlciwgYnVuZGxlX2ZkLCBOVUxMLCAmb3B0cyk7CglpZiAocmVzdWx0KSB7CgkJcmVzdWx0ID0gMTsKCQlnb3RvIGNsZWFudXA7Cgl9CgoJLyoKCSAqIENvbnZlcnQgYWxsIHJlZnMvaGVhZHMvIGZyb20gdGhlIGJ1bmRsZSBpbnRvIHJlZnMvYnVuZGxlcy8KCSAqIGluIHRoZSBsb2NhbCByZXBvc2l0b3J5LgoJICovCglzdHJidWZfYWRkc3RyKCZidW5kbGVfcmVmLCAicmVmcy9idW5kbGVzLyIpOwoJYnVuZGxlX3ByZWZpeF9sZW4gPSBidW5kbGVfcmVmLmxlbjsKCglmb3JfZWFjaF9zdHJpbmdfbGlzdF9pdGVtKHJlZm5hbWUsICZoZWFkZXIucmVmZXJlbmNlcykgewoJCXN0cnVjdCBvYmplY3RfaWQgKm9pZCA9IHJlZm5hbWUtPnV0aWw7CgkJc3RydWN0IG9iamVjdF9pZCBvbGRfb2lkOwoJCWNvbnN0IGNoYXIgKmJyYW5jaF9uYW1lOwoJCWludCBoYXNfb2xkOwoKCQlpZiAoIXNraXBfcHJlZml4KHJlZm5hbWUtPnN0cmluZywgInJlZnMvIiwgJmJyYW5jaF9uYW1lKSkKCQkJY29udGludWU7CgoJCXN0cmJ1Zl9zZXRsZW4oJmJ1bmRsZV9yZWYsIGJ1bmRsZV9wcmVmaXhfbGVuKTsKCQlzdHJidWZfYWRkc3RyKCZidW5kbGVfcmVmLCBicmFuY2hfbmFtZSk7CgoJCWhhc19vbGQgPSAhcmVmc19yZWFkX3JlZihnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLAoJCQkJCSBidW5kbGVfcmVmLmJ1ZiwgJm9sZF9vaWQpOwoJCXJlZnNfdXBkYXRlX3JlZihnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLAoJCQkJImZldGNoZWQgYnVuZGxlIiwgYnVuZGxlX3JlZi5idWYsIG9pZCwKCQkJCWhhc19vbGQgPyAmb2xkX29pZCA6IE5VTEwsCgkJCQkwLCBVUERBVEVfUkVGU19NU0dfT05fRVJSKTsKCX0KCmNsZWFudXA6CglzdHJidWZfcmVsZWFzZSgmYnVuZGxlX3JlZik7CglidW5kbGVfaGVhZGVyX3JlbGVhc2UoJmhlYWRlcik7CglyZXR1cm4gcmVzdWx0Owp9CgpzdHJ1Y3QgYnVuZGxlX2xpc3RfY29udGV4dCB7CglzdHJ1Y3QgcmVwb3NpdG9yeSAqcjsKCXN0cnVjdCBidW5kbGVfbGlzdCAqbGlzdDsKCWVudW0gYnVuZGxlX2xpc3RfbW9kZSBtb2RlOwoJaW50IGNvdW50OwoJaW50IGRlcHRoOwp9OwoKLyoKICogVGhpcyBlYXJseSBkZWZpbml0aW9uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIHVzZSBpbmRpcmVjdCByZWN1cnNpb246CiAqCiAqIFdoaWxlIGl0ZXJhdGluZyB0aHJvdWdoIGEgYnVuZGxlIGxpc3QgdGhhdCB3YXMgZG93bmxvYWRlZCBhcyBwYXJ0CiAqIG9mIGZldGNoX2J1bmRsZV91cmlfaW50ZXJuYWwoKSwgaXRlcmF0b3IgbWV0aG9kcyBldmVudHVhbGx5IGNhbGwgaXQKICogYWdhaW4sIGJ1dCB3aXRoIGRlcHRoICsgMS4KICovCnN0YXRpYyBpbnQgZmV0Y2hfYnVuZGxlX3VyaV9pbnRlcm5hbChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJCSAgICAgc3RydWN0IHJlbW90ZV9idW5kbGVfaW5mbyAqYnVuZGxlLAoJCQkJICAgICBpbnQgZGVwdGgsCgkJCQkgICAgIHN0cnVjdCBidW5kbGVfbGlzdCAqbGlzdCk7CgpzdGF0aWMgaW50IGRvd25sb2FkX2J1bmRsZV90b19maWxlKHN0cnVjdCByZW1vdGVfYnVuZGxlX2luZm8gKmJ1bmRsZSwgdm9pZCAqZGF0YSkKewoJaW50IHJlczsKCXN0cnVjdCBidW5kbGVfbGlzdF9jb250ZXh0ICpjdHggPSBkYXRhOwoKCWlmIChjdHgtPm1vZGUgPT0gQlVORExFX01PREVfQU5ZICYmIGN0eC0+Y291bnQpCgkJcmV0dXJuIDA7CgoJcmVzID0gZmV0Y2hfYnVuZGxlX3VyaV9pbnRlcm5hbChjdHgtPnIsIGJ1bmRsZSwgY3R4LT5kZXB0aCArIDEsIGN0eC0+bGlzdCk7CgoJLyoKCSAqIE9ubHkgaW5jcmVtZW50IGNvdW50IGlmIHRoZSBkb3dubG9hZCBzdWNjZWVkZWQuIElmIG91ciBtb2RlIGlzCgkgKiBCVU5ETEVfTU9ERV9BTlksIHRoZW4gd2Ugd2lsbCB3YW50IHRvIHRyeSBvdGhlciBVUklzIGluIHRoZQoJICogbGlzdCBpbiBjYXNlIHRoZXkgd29yayBpbnN0ZWFkLgoJICovCglpZiAoIXJlcykKCQljdHgtPmNvdW50Kys7CgoJLyoKCSAqIFRvIGJlIG9wcG9ydHVuaXN0aWMgYXMgcG9zc2libGUsIHdlIGNvbnRpbnVlIGl0ZXJhdGluZyBhbmQKCSAqIGRvd25sb2FkIGFzIG1hbnkgYnVuZGxlcyBhcyB3ZSBjYW4sIHNvIHdlIGNhbiBhcHBseSB0aGUgb25lcwoJICogdGhhdCB3b3JrLCBldmVuIGluIEJVTkRMRV9NT0RFX0FMTCBtb2RlLgoJICovCglyZXR1cm4gMDsKfQoKc3RydWN0IGJ1bmRsZXNfZm9yX3NvcnRpbmcgewoJc3RydWN0IHJlbW90ZV9idW5kbGVfaW5mbyAqKml0ZW1zOwoJc2l6ZV90IGFsbG9jOwoJc2l6ZV90IG5yOwp9OwoKc3RhdGljIGludCBhcHBlbmRfYnVuZGxlKHN0cnVjdCByZW1vdGVfYnVuZGxlX2luZm8gKmJ1bmRsZSwgdm9pZCAqZGF0YSkKewoJc3RydWN0IGJ1bmRsZXNfZm9yX3NvcnRpbmcgKmxpc3QgPSBkYXRhOwoJbGlzdC0+aXRlbXNbbGlzdC0+bnIrK10gPSBidW5kbGU7CglyZXR1cm4gMDsKfQoKLyoqCiAqIEZvciB1c2UgaW4gUVNPUlQoKSB0byBnZXQgYSBsaXN0IHNvcnRlZCBieSBjcmVhdGlvblRva2VuCiAqIGluIGRlY3JlYXNpbmcgb3JkZXIuCiAqLwpzdGF0aWMgaW50IGNvbXBhcmVfY3JlYXRpb25fdG9rZW5fZGVjcmVhc2luZyhjb25zdCB2b2lkICp2YSwgY29uc3Qgdm9pZCAqdmIpCnsKCWNvbnN0IHN0cnVjdCByZW1vdGVfYnVuZGxlX2luZm8gKiBjb25zdCAqYSA9IHZhOwoJY29uc3Qgc3RydWN0IHJlbW90ZV9idW5kbGVfaW5mbyAqIGNvbnN0ICpiID0gdmI7CgoJaWYgKCgqYSktPmNyZWF0aW9uVG9rZW4gPiAoKmIpLT5jcmVhdGlvblRva2VuKQoJCXJldHVybiAtMTsKCWlmICgoKmEpLT5jcmVhdGlvblRva2VuIDwgKCpiKS0+Y3JlYXRpb25Ub2tlbikKCQlyZXR1cm4gMTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGZldGNoX2J1bmRsZXNfYnlfdG9rZW4oc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCQkgIHN0cnVjdCBidW5kbGVfbGlzdCAqbGlzdCkKewoJaW50IGN1cjsKCWludCBtb3ZlX2RpcmVjdGlvbiA9IDA7Cgljb25zdCBjaGFyICpjcmVhdGlvblRva2VuU3RyOwoJdWludDY0X3QgbWF4Q3JlYXRpb25Ub2tlbiA9IDAsIG5ld01heENyZWF0aW9uVG9rZW4gPSAwOwoJc3RydWN0IGJ1bmRsZV9saXN0X2NvbnRleHQgY3R4ID0gewoJCS5yID0gciwKCQkubGlzdCA9IGxpc3QsCgkJLm1vZGUgPSBsaXN0LT5tb2RlLAoJfTsKCXN0cnVjdCBidW5kbGVzX2Zvcl9zb3J0aW5nIGJ1bmRsZXMgPSB7CgkJLmFsbG9jID0gaGFzaG1hcF9nZXRfc2l6ZSgmbGlzdC0+YnVuZGxlcyksCgl9OwoKCUFMTE9DX0FSUkFZKGJ1bmRsZXMuaXRlbXMsIGJ1bmRsZXMuYWxsb2MpOwoKCWZvcl9hbGxfYnVuZGxlc19pbl9saXN0KGxpc3QsIGFwcGVuZF9idW5kbGUsICZidW5kbGVzKTsKCglpZiAoIWJ1bmRsZXMubnIpIHsKCQlmcmVlKGJ1bmRsZXMuaXRlbXMpOwoJCXJldHVybiAwOwoJfQoKCVFTT1JUKGJ1bmRsZXMuaXRlbXMsIGJ1bmRsZXMubnIsIGNvbXBhcmVfY3JlYXRpb25fdG9rZW5fZGVjcmVhc2luZyk7CgoJLyoKCSAqIElmIGZldGNoLmJ1bmRsZUNyZWF0aW9uVG9rZW4gZXhpc3RzLCBwYXJzZXMgdG8gYSB1aW50NjR0LCBhbmQKCSAqIGlzIG5vdCBzdHJpY3RseSBzbWFsbGVyIHRoYW4gdGhlIG1heGltdW0gY3JlYXRpb24gdG9rZW4gaW4gdGhlCgkgKiBidW5kbGUgbGlzdCwgdGhlbiBkbyBub3QgZG93bmxvYWQgYW55IGJ1bmRsZXMuCgkgKi8KCWlmICghcmVwb19jb25maWdfZ2V0X3ZhbHVlKHIsCgkJCQkgICAiZmV0Y2guYnVuZGxlY3JlYXRpb250b2tlbiIsCgkJCQkgICAmY3JlYXRpb25Ub2tlblN0cikpIHsKCQlpZiAoc3NjYW5mKGNyZWF0aW9uVG9rZW5TdHIsICIlIlBSSXU2NCwgJm1heENyZWF0aW9uVG9rZW4pICE9IDEpCgkJCW1heENyZWF0aW9uVG9rZW4gPSAwOwoJCWlmIChidW5kbGVzLml0ZW1zWzBdLT5jcmVhdGlvblRva2VuIDw9IG1heENyZWF0aW9uVG9rZW4pIHsKCQkJZnJlZShidW5kbGVzLml0ZW1zKTsKCQkJcmV0dXJuIDA7CgkJfQoJfQoKCS8qCgkgKiBBdHRlbXB0IHRvIGRvd25sb2FkIGFuZCB1bmJ1bmRsZSB0aGUgbWluaW11bSBudW1iZXIgb2YgYnVuZGxlcyBieQoJICogY3JlYXRpb25Ub2tlbiBpbiBkZWNyZWFzaW5nIG9yZGVyLiBJZiB3ZSBmYWlsIHRvIHVuYnVuZGxlIChhZnRlcgoJICogYSBzdWNjZXNzZnVsIGRvd25sb2FkKSB0aGVuIG1vdmUgdG8gdGhlIG5leHQgbm9uLWRvd25sb2FkZWQgYnVuZGxlCgkgKiBhbmQgYXR0ZW1wdCBkb3dubG9hZGluZy4gT25jZSB3ZSBzdWNjZWVkIGluIGFwcGx5aW5nIGEgYnVuZGxlLAoJICogbW92ZSB0byB0aGUgcHJldmlvdXMgdW5hcHBsaWVkIGJ1bmRsZSBhbmQgYXR0ZW1wdCB0byB1bmJ1bmRsZSBpdAoJICogYWdhaW4uCgkgKgoJICogSW4gdGhlIGNhc2Ugb2YgYSBmcmVzaCBjbG9uZSwgd2Ugd2lsbCBsaWtlbHkgZG93bmxvYWQgYWxsIG9mIHRoZQoJICogYnVuZGxlcyBiZWZvcmUgc3VjY2Vzc2Z1bGx5IHVuYnVuZGxpbmcgdGhlIG9sZGVzdCBvbmUsIHRoZW4gdGhlCgkgKiByZXN0IG9mIHRoZSBidW5kbGVzIHVuYnVuZGxlIHN1Y2Nlc3NmdWxseSBpbiBpbmNyZWFzaW5nIG9yZGVyCgkgKiBvZiBjcmVhdGlvblRva2VuLgoJICoKCSAqIElmIHRoZXJlIGFyZSBleGlzdGluZyBvYmplY3RzLCB0aGVuIHRoaXMgcHJvY2VzcyBtYXkgdGVybWluYXRlCgkgKiBlYXJseSB3aGVuIGFsbCByZXF1aXJlZCBjb21taXRzIGZyb20gIm5ldyIgYnVuZGxlcyBleGlzdCBpbiB0aGUKCSAqIHJlcG8ncyBvYmplY3Qgc3RvcmUuCgkgKi8KCWN1ciA9IDA7Cgl3aGlsZSAoY3VyID49IDAgJiYgY3VyIDwgYnVuZGxlcy5ucikgewoJCXN0cnVjdCByZW1vdGVfYnVuZGxlX2luZm8gKmJ1bmRsZSA9IGJ1bmRsZXMuaXRlbXNbY3VyXTsKCgkJLyoKCQkgKiBJZiB3ZSBuZWVkIHRvIGRpZyBpbnRvIGJ1bmRsZXMgYmVsb3cgdGhlIHByZXZpb3VzCgkJICogY3JlYXRpb24gdG9rZW4gdmFsdWUsIHRoZW4gbGlrZWx5IHdlIGFyZSBpbiBhbiBlcnJvbmVvdXMKCQkgKiBzdGF0ZSBkdWUgdG8gbWlzc2luZyBvciBpbnZhbGlkIGJ1bmRsZXMuIEhhbHQgdGhlIHByb2Nlc3MKCQkgKiBpbnN0ZWFkIG9mIGNvbnRpbnVpbmcgdG8gZG93bmxvYWQgZXh0cmEgZGF0YS4KCQkgKi8KCQlpZiAoYnVuZGxlLT5jcmVhdGlvblRva2VuIDw9IG1heENyZWF0aW9uVG9rZW4pCgkJCWJyZWFrOwoKCQlpZiAoIWJ1bmRsZS0+ZmlsZSkgewoJCQkvKgoJCQkgKiBOb3QgZG93bmxvYWRlZCB5ZXQuIFRyeSBkb3dubG9hZGluZy4KCQkJICoKCQkJICogTm90ZSB0aGF0IGJ1bmRsZS0+ZmlsZSBpcyBub24tTlVMTCBpZiBhIGRvd25sb2FkCgkJCSAqIHdhcyBhdHRlbXB0ZWQsIGV2ZW4gaWYgaXQgZmFpbGVkIHRvIGRvd25sb2FkLgoJCQkgKi8KCQkJaWYgKGZldGNoX2J1bmRsZV91cmlfaW50ZXJuYWwoY3R4LnIsIGJ1bmRsZSwgY3R4LmRlcHRoICsgMSwgY3R4Lmxpc3QpKSB7CgkJCQkvKiBNYXJrIGFzIHVuYnVuZGxlZCBzbyB3ZSBkbyBub3QgcmV0cnkuICovCgkJCQlidW5kbGUtPnVuYnVuZGxlZCA9IDE7CgoJCQkJLyogVHJ5IGxvb2tpbmcgZGVlcGVyIGluIHRoZSBsaXN0LiAqLwoJCQkJbW92ZV9kaXJlY3Rpb24gPSAxOwoJCQkJZ290byBtb3ZlOwoJCQl9CgoJCQkvKiBXZSBleHBlY3QgYnVuZGxlcyB3aGVuIHVzaW5nIGNyZWF0aW9uVG9rZW5zLiAqLwoJCQlpZiAoIWlzX2J1bmRsZShidW5kbGUtPmZpbGUsIDEpKSB7CgkJCQl3YXJuaW5nKF8oImZpbGUgZG93bmxvYWRlZCBmcm9tICclcycgaXMgbm90IGEgYnVuZGxlIiksCgkJCQkJYnVuZGxlLT51cmkpOwoJCQkJYnJlYWs7CgkJCX0KCQl9CgoJCWlmIChidW5kbGUtPmZpbGUgJiYgIWJ1bmRsZS0+dW5idW5kbGVkKSB7CgkJCS8qCgkJCSAqIFRoaXMgd2FzIGRvd25sb2FkZWQsIGJ1dCBub3Qgc3VjY2Vzc2Z1bGx5CgkJCSAqIHVuYnVuZGxlZC4gVHJ5IHVuYnVuZGxpbmcgYWdhaW4uCgkJCSAqLwoJCQlpZiAodW5idW5kbGVfZnJvbV9maWxlKGN0eC5yLCBidW5kbGUtPmZpbGUpKSB7CgkJCQkvKiBUcnkgbG9va2luZyBkZWVwZXIgaW4gdGhlIGxpc3QuICovCgkJCQltb3ZlX2RpcmVjdGlvbiA9IDE7CgkJCX0gZWxzZSB7CgkJCQkvKgoJCQkJICogU3VjY2VlZGVkIGluIHVuYnVuZGxlLiBSZXRyeSBidW5kbGVzCgkJCQkgKiB0aGF0IHByZXZpb3VzbHkgZmFpbGVkIHRvIHVuYnVuZGxlLgoJCQkJICovCgkJCQltb3ZlX2RpcmVjdGlvbiA9IC0xOwoJCQkJYnVuZGxlLT51bmJ1bmRsZWQgPSAxOwoKCQkJCWlmIChidW5kbGUtPmNyZWF0aW9uVG9rZW4gPiBuZXdNYXhDcmVhdGlvblRva2VuKQoJCQkJCW5ld01heENyZWF0aW9uVG9rZW4gPSBidW5kbGUtPmNyZWF0aW9uVG9rZW47CgkJCX0KCQl9CgoJCS8qCgkJICogRWxzZSBjYXNlOiBkb3dubG9hZGVkIGFuZCB1bmJ1bmRsZWQgc3VjY2Vzc2Z1bGx5LgoJCSAqIFNraXAgdGhpcyBieSBtb3ZpbmcgaW4gdGhlIHNhbWUgZGlyZWN0aW9uIGFzIHRoZQoJCSAqIHByZXZpb3VzIHN0ZXAuCgkJICovCgptb3ZlOgoJCS8qIE1vdmUgaW4gdGhlIHNwZWNpZmllZCBkaXJlY3Rpb24gYW5kIHJlcGVhdC4gKi8KCQljdXIgKz0gbW92ZV9kaXJlY3Rpb247Cgl9CgoJLyoKCSAqIFdlIHN1Y2NlZWQgaWYgdGhlIGxvb3AgdGVybWluYXRlcyBiZWNhdXNlICdjdXInIGRyb3BzIGJlbG93CgkgKiB6ZXJvLiBUaGUgb3RoZXIgY2FzZSBpcyB0aGF0IHdlIHRlcm1pbmF0ZSBiZWNhdXNlICdjdXInCgkgKiByZWFjaGVzIHRoZSBlbmQgb2YgdGhlIGxpc3QsIHNvIHdlIGhhdmUgYSBmYWlsdXJlIG5vIG1hdHRlcgoJICogd2hpY2ggYnVuZGxlcyB3ZSBhcHBseSBmcm9tIHRoZSBsaXN0LgoJICovCglpZiAoY3VyIDwgMCkgewoJCXN0cnVjdCBzdHJidWYgdmFsdWUgPSBTVFJCVUZfSU5JVDsKCQlzdHJidWZfYWRkZigmdmFsdWUsICIlIlBSSXU2NCIiLCBuZXdNYXhDcmVhdGlvblRva2VuKTsKCQlpZiAocmVwb19jb25maWdfc2V0X211bHRpdmFyX2dlbnRseShjdHguciwKCQkJCQkJICAgICJmZXRjaC5idW5kbGVDcmVhdGlvblRva2VuIiwKCQkJCQkJICAgIHZhbHVlLmJ1ZiwgTlVMTCwgMCkpCgkJCXdhcm5pbmcoXygiZmFpbGVkIHRvIHN0b3JlIG1heGltdW0gY3JlYXRpb24gdG9rZW4iKSk7CgoJCXN0cmJ1Zl9yZWxlYXNlKCZ2YWx1ZSk7Cgl9CgoJZnJlZShidW5kbGVzLml0ZW1zKTsKCXJldHVybiBjdXIgPj0gMDsKfQoKc3RhdGljIGludCBkb3dubG9hZF9idW5kbGVfbGlzdChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJCXN0cnVjdCBidW5kbGVfbGlzdCAqbG9jYWxfbGlzdCwKCQkJCXN0cnVjdCBidW5kbGVfbGlzdCAqZ2xvYmFsX2xpc3QsCgkJCQlpbnQgZGVwdGgpCnsKCXN0cnVjdCBidW5kbGVfbGlzdF9jb250ZXh0IGN0eCA9IHsKCQkuciA9IHIsCgkJLmxpc3QgPSBnbG9iYWxfbGlzdCwKCQkuZGVwdGggPSBkZXB0aCArIDEsCgkJLm1vZGUgPSBsb2NhbF9saXN0LT5tb2RlLAoJfTsKCglyZXR1cm4gZm9yX2FsbF9idW5kbGVzX2luX2xpc3QobG9jYWxfbGlzdCwgZG93bmxvYWRfYnVuZGxlX3RvX2ZpbGUsICZjdHgpOwp9CgpzdGF0aWMgaW50IGZldGNoX2J1bmRsZV9saXN0X2luX2NvbmZpZ19mb3JtYXQoc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCQkJICAgICAgc3RydWN0IGJ1bmRsZV9saXN0ICpnbG9iYWxfbGlzdCwKCQkJCQkgICAgICBzdHJ1Y3QgcmVtb3RlX2J1bmRsZV9pbmZvICpidW5kbGUsCgkJCQkJICAgICAgaW50IGRlcHRoKQp7CglpbnQgcmVzdWx0OwoJc3RydWN0IGJ1bmRsZV9saXN0IGxpc3RfZnJvbV9idW5kbGU7CgoJaW5pdF9idW5kbGVfbGlzdCgmbGlzdF9mcm9tX2J1bmRsZSk7CgoJaWYgKChyZXN1bHQgPSBidW5kbGVfdXJpX3BhcnNlX2NvbmZpZ19mb3JtYXQoYnVuZGxlLT51cmksCgkJCQkJCSAgICAgYnVuZGxlLT5maWxlLAoJCQkJCQkgICAgICZsaXN0X2Zyb21fYnVuZGxlKSkpCgkJZ290byBjbGVhbnVwOwoKCWlmIChsaXN0X2Zyb21fYnVuZGxlLm1vZGUgPT0gQlVORExFX01PREVfTk9ORSkgewoJCXdhcm5pbmcoXygidW5yZWNvZ25pemVkIGJ1bmRsZSBtb2RlIGZyb20gVVJJICclcyciKSwKCQkJYnVuZGxlLT51cmkpOwoJCXJlc3VsdCA9IC0xOwoJCWdvdG8gY2xlYW51cDsKCX0KCgkvKgoJICogSWYgdGhpcyBsaXN0IHVzZXMgdGhlIGNyZWF0aW9uVG9rZW4gaGV1cmlzdGljLCB0aGVuIHRoZSBVUklzCgkgKiBpdCBhZHZlcnRpc2VzIGFyZSBleHBlY3RlZCB0byBiZSBidW5kbGVzLCBub3QgbmVzdGVkIGxpc3RzLgoJICogV2UgY2FuIGRyb3AgJ2dsb2JhbF9saXN0JyBhbmQgJ2RlcHRoJy4KCSAqLwoJaWYgKGxpc3RfZnJvbV9idW5kbGUuaGV1cmlzdGljID09IEJVTkRMRV9IRVVSSVNUSUNfQ1JFQVRJT05UT0tFTikgewoJCXJlc3VsdCA9IGZldGNoX2J1bmRsZXNfYnlfdG9rZW4ociwgJmxpc3RfZnJvbV9idW5kbGUpOwoJCWdsb2JhbF9saXN0LT5oZXVyaXN0aWMgPSBCVU5ETEVfSEVVUklTVElDX0NSRUFUSU9OVE9LRU47Cgl9IGVsc2UgaWYgKChyZXN1bHQgPSBkb3dubG9hZF9idW5kbGVfbGlzdChyLCAmbGlzdF9mcm9tX2J1bmRsZSwKCQkJCQkgICBnbG9iYWxfbGlzdCwgZGVwdGgpKSkKCQlnb3RvIGNsZWFudXA7CgpjbGVhbnVwOgoJY2xlYXJfYnVuZGxlX2xpc3QoJmxpc3RfZnJvbV9idW5kbGUpOwoJcmV0dXJuIHJlc3VsdDsKfQoKLyoqCiAqIFRoaXMgbGltaXRzIHRoZSByZWN1cnNpb24gb24gZmV0Y2hfYnVuZGxlX3VyaV9pbnRlcm5hbCgpIHdoZW4gZm9sbG93aW5nCiAqIGJ1bmRsZSBsaXN0cy4KICovCnN0YXRpYyBpbnQgbWF4X2J1bmRsZV91cmlfZGVwdGggPSA0OwoKLyoqCiAqIFJlY3Vyc2l2ZWx5IGRvd25sb2FkIGFsbCBidW5kbGVzIGFkdmVydGlzZWQgYXQgdGhlIGdpdmVuIFVSSQogKiB0byBmaWxlcy4gSWYgdGhlIGZpbGUgaXMgYSBidW5kbGUsIHRoZW4gYWRkIGl0IHRvIHRoZSBnaXZlbgogKiAnbGlzdCcuIE90aGVyd2lzZSwgZXhwZWN0IGEgYnVuZGxlIGxpc3QgYW5kIHJlY3Vyc2Ugb24gdGhlCiAqIFVSSXMgaW4gdGhhdCBsaXN0IGFjY29yZGluZyB0byB0aGUgbGlzdCBtb2RlIChBTlkgb3IgQUxMKS4KICovCnN0YXRpYyBpbnQgZmV0Y2hfYnVuZGxlX3VyaV9pbnRlcm5hbChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJCSAgICAgc3RydWN0IHJlbW90ZV9idW5kbGVfaW5mbyAqYnVuZGxlLAoJCQkJICAgICBpbnQgZGVwdGgsCgkJCQkgICAgIHN0cnVjdCBidW5kbGVfbGlzdCAqbGlzdCkKewoJaW50IHJlc3VsdCA9IDA7CglzdHJ1Y3QgcmVtb3RlX2J1bmRsZV9pbmZvICpiY29weTsKCglpZiAoZGVwdGggPj0gbWF4X2J1bmRsZV91cmlfZGVwdGgpIHsKCQl3YXJuaW5nKF8oImV4Y2VlZGVkIGJ1bmRsZSBVUkkgcmVjdXJzaW9uIGxpbWl0ICglZCkiKSwKCQkJbWF4X2J1bmRsZV91cmlfZGVwdGgpOwoJCXJldHVybiAtMTsKCX0KCglpZiAoIWJ1bmRsZS0+ZmlsZSAmJgoJICAgICEoYnVuZGxlLT5maWxlID0gZmluZF90ZW1wX2ZpbGVuYW1lKCkpKSB7CgkJcmVzdWx0ID0gLTE7CgkJZ290byBjbGVhbnVwOwoJfQoKCWlmICgocmVzdWx0ID0gY29weV91cmlfdG9fZmlsZShidW5kbGUtPmZpbGUsIGJ1bmRsZS0+dXJpKSkpIHsKCQl3YXJuaW5nKF8oImZhaWxlZCB0byBkb3dubG9hZCBidW5kbGUgZnJvbSBVUkkgJyVzJyIpLCBidW5kbGUtPnVyaSk7CgkJZ290byBjbGVhbnVwOwoJfQoKCWlmICgocmVzdWx0ID0gIWlzX2J1bmRsZShidW5kbGUtPmZpbGUsIDEpKSkgewoJCXJlc3VsdCA9IGZldGNoX2J1bmRsZV9saXN0X2luX2NvbmZpZ19mb3JtYXQoCgkJCQlyLCBsaXN0LCBidW5kbGUsIGRlcHRoKTsKCQlpZiAocmVzdWx0KQoJCQl3YXJuaW5nKF8oImZpbGUgYXQgVVJJICclcycgaXMgbm90IGEgYnVuZGxlIG9yIGJ1bmRsZSBsaXN0IiksCgkJCQlidW5kbGUtPnVyaSk7CgkJZ290byBjbGVhbnVwOwoJfQoKCS8qIENvcHkgdGhlIGJ1bmRsZSBhbmQgaW5zZXJ0IGl0IGludG8gdGhlIGdsb2JhbCBsaXN0LiAqLwoJQ0FMTE9DX0FSUkFZKGJjb3B5LCAxKTsKCWJjb3B5LT5pZCA9IHhzdHJkdXAoYnVuZGxlLT5pZCk7CgliY29weS0+ZmlsZSA9IHhzdHJkdXAoYnVuZGxlLT5maWxlKTsKCWhhc2htYXBfZW50cnlfaW5pdCgmYmNvcHktPmVudCwgc3RyaGFzaChiY29weS0+aWQpKTsKCWhhc2htYXBfYWRkKCZsaXN0LT5idW5kbGVzLCAmYmNvcHktPmVudCk7CgpjbGVhbnVwOgoJaWYgKHJlc3VsdCAmJiBidW5kbGUtPmZpbGUpCgkJdW5saW5rKGJ1bmRsZS0+ZmlsZSk7CglyZXR1cm4gcmVzdWx0Owp9CgovKioKICogVGhpcyBsb29wIGl0ZXJhdG9yIGJyZWFrcyB0aGUgbG9vcCB3aXRoIG5vbnplcm8gcmV0dXJuIGNvZGUgb24gdGhlCiAqIGZpcnN0IHN1Y2Nlc3NmdWwgdW5idW5kbGluZyBvZiBhIGJ1bmRsZS4KICovCnN0YXRpYyBpbnQgYXR0ZW1wdF91bmJ1bmRsZShzdHJ1Y3QgcmVtb3RlX2J1bmRsZV9pbmZvICppbmZvLCB2b2lkICpkYXRhKQp7CglzdHJ1Y3QgcmVwb3NpdG9yeSAqciA9IGRhdGE7CgoJaWYgKCFpbmZvLT5maWxlIHx8IGluZm8tPnVuYnVuZGxlZCkKCQlyZXR1cm4gMDsKCglpZiAoIXVuYnVuZGxlX2Zyb21fZmlsZShyLCBpbmZvLT5maWxlKSkgewoJCWluZm8tPnVuYnVuZGxlZCA9IDE7CgkJcmV0dXJuIDE7Cgl9CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgdW5idW5kbGVfYWxsX2J1bmRsZXMoc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCQlzdHJ1Y3QgYnVuZGxlX2xpc3QgKmxpc3QpCnsKCS8qCgkgKiBJdGVyYXRlIHRocm91Z2ggYWxsIGJ1bmRsZXMgbG9va2luZyBmb3Igb25lcyB0aGF0IGNhbgoJICogc3VjY2Vzc2Z1bGx5IHVuYnVuZGxlLiBJZiBhbnkgc3VjY2VlZCwgdGhlbiBwZXJoYXBzIGFub3RoZXIKCSAqIHdpbGwgc3VjY2VlZCBpbiB0aGUgbmV4dCBhdHRlbXB0LgoJICoKCSAqIEtlZXAgaW4gbWluZCB0aGF0IGEgbm9uLXplcm8gcmVzdWx0IGZvciB0aGUgbG9vcCBoZXJlIG1lYW5zCgkgKiB0aGUgbG9vcCB0ZXJtaW5hdGVkIGVhcmx5IG9uIGEgc3VjY2Vzc2Z1bCB1bmJ1bmRsaW5nLCB3aGljaAoJICogc2lnbmFscyB0aGF0IHdlIGNhbiB0cnkgYWdhaW4uCgkgKi8KCXdoaWxlIChmb3JfYWxsX2J1bmRsZXNfaW5fbGlzdChsaXN0LCBhdHRlbXB0X3VuYnVuZGxlLCByKSkgOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHVubGlua19idW5kbGUoc3RydWN0IHJlbW90ZV9idW5kbGVfaW5mbyAqaW5mbywgdm9pZCAqZGF0YSBVTlVTRUQpCnsKCWlmIChpbmZvLT5maWxlKQoJCXVubGlua19vcl93YXJuKGluZm8tPmZpbGUpOwoJcmV0dXJuIDA7Cn0KCmludCBmZXRjaF9idW5kbGVfdXJpKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBjb25zdCBjaGFyICp1cmksCgkJICAgICBpbnQgKmhhc19oZXVyaXN0aWMpCnsKCWludCByZXN1bHQ7CglzdHJ1Y3QgYnVuZGxlX2xpc3QgbGlzdDsKCXN0cnVjdCByZW1vdGVfYnVuZGxlX2luZm8gYnVuZGxlID0gewoJCS51cmkgPSB4c3RyZHVwKHVyaSksCgkJLmlkID0geHN0cmR1cCgiIiksCgl9OwoKCXRyYWNlMl9yZWdpb25fZW50ZXIoImZldGNoIiwgImZldGNoLWJ1bmRsZS11cmkiLCB0aGVfcmVwb3NpdG9yeSk7CgoJaW5pdF9idW5kbGVfbGlzdCgmbGlzdCk7CgoJLyoKCSAqIERvIG5vdCBmZXRjaCBhbiBlbXB0eSBidW5kbGUgVVJJLiBBbiBlbXB0eSBidW5kbGUgVVJJCgkgKiBjb3VsZCBzaWduYWwgdGhhdCBhIGNvbmZpZ3VyZWQgYnVuZGxlIFVSSSBoYXMgYmVlbiBkaXNhYmxlZC4KCSAqLwoJaWYgKCEqdXJpKSB7CgkJcmVzdWx0ID0gMDsKCQlnb3RvIGNsZWFudXA7Cgl9CgoJLyogSWYgYSBidW5kbGUgaXMgYWRkZWQgdG8gdGhpcyBnbG9iYWwgbGlzdCwgdGhlbiBpdCBpcyByZXF1aXJlZC4gKi8KCWxpc3QubW9kZSA9IEJVTkRMRV9NT0RFX0FMTDsKCglpZiAoKHJlc3VsdCA9IGZldGNoX2J1bmRsZV91cmlfaW50ZXJuYWwociwgJmJ1bmRsZSwgMCwgJmxpc3QpKSkKCQlnb3RvIGNsZWFudXA7CgoJcmVzdWx0ID0gdW5idW5kbGVfYWxsX2J1bmRsZXMociwgJmxpc3QpOwoKY2xlYW51cDoKCWlmIChoYXNfaGV1cmlzdGljKQoJCSpoYXNfaGV1cmlzdGljID0gKGxpc3QuaGV1cmlzdGljICE9IEJVTkRMRV9IRVVSSVNUSUNfTk9ORSk7Cglmb3JfYWxsX2J1bmRsZXNfaW5fbGlzdCgmbGlzdCwgdW5saW5rX2J1bmRsZSwgTlVMTCk7CgljbGVhcl9idW5kbGVfbGlzdCgmbGlzdCk7CgljbGVhcl9yZW1vdGVfYnVuZGxlX2luZm8oJmJ1bmRsZSwgTlVMTCk7Cgl0cmFjZTJfcmVnaW9uX2xlYXZlKCJmZXRjaCIsICJmZXRjaC1idW5kbGUtdXJpIiwgdGhlX3JlcG9zaXRvcnkpOwoJcmV0dXJuIHJlc3VsdDsKfQoKaW50IGZldGNoX2J1bmRsZV9saXN0KHN0cnVjdCByZXBvc2l0b3J5ICpyLCBzdHJ1Y3QgYnVuZGxlX2xpc3QgKmxpc3QpCnsKCWludCByZXN1bHQ7CglzdHJ1Y3QgYnVuZGxlX2xpc3QgZ2xvYmFsX2xpc3Q7CgoJLyoKCSAqIElmIHRoZSBjcmVhdGlvblRva2VuIGhldXJpc3RpYyBpcyB1c2VkLCB0aGVuIHRoZSBVUklzCgkgKiBhZHZlcnRpc2VkIGJ5ICdsaXN0JyBhcmUgbm90IG5lc3RlZCBsaXN0cyBhbmQgaW5zdGVhZAoJICogZGlyZWN0IGJ1bmRsZXMuIFdlIGRvIG5vdCBuZWVkIHRvIHVzZSBnbG9iYWxfbGlzdC4KCSAqLwoJaWYgKGxpc3QtPmhldXJpc3RpYyA9PSBCVU5ETEVfSEVVUklTVElDX0NSRUFUSU9OVE9LRU4pCgkJcmV0dXJuIGZldGNoX2J1bmRsZXNfYnlfdG9rZW4ociwgbGlzdCk7CgoJaW5pdF9idW5kbGVfbGlzdCgmZ2xvYmFsX2xpc3QpOwoKCS8qIElmIGEgYnVuZGxlIGlzIGFkZGVkIHRvIHRoaXMgZ2xvYmFsIGxpc3QsIHRoZW4gaXQgaXMgcmVxdWlyZWQuICovCglnbG9iYWxfbGlzdC5tb2RlID0gQlVORExFX01PREVfQUxMOwoKCWlmICgocmVzdWx0ID0gZG93bmxvYWRfYnVuZGxlX2xpc3QociwgbGlzdCwgJmdsb2JhbF9saXN0LCAwKSkpCgkJZ290byBjbGVhbnVwOwoKCWlmIChsaXN0LT5oZXVyaXN0aWMgPT0gQlVORExFX0hFVVJJU1RJQ19DUkVBVElPTlRPS0VOKQoJCXJlc3VsdCA9IGZldGNoX2J1bmRsZXNfYnlfdG9rZW4ociwgbGlzdCk7CgllbHNlCgkJcmVzdWx0ID0gdW5idW5kbGVfYWxsX2J1bmRsZXMociwgJmdsb2JhbF9saXN0KTsKCmNsZWFudXA6Cglmb3JfYWxsX2J1bmRsZXNfaW5fbGlzdCgmZ2xvYmFsX2xpc3QsIHVubGlua19idW5kbGUsIE5VTEwpOwoJY2xlYXJfYnVuZGxlX2xpc3QoJmdsb2JhbF9saXN0KTsKCXJldHVybiByZXN1bHQ7Cn0KCi8qKgogKiBBUEkgZm9yIHNlcnZlLmMuCiAqLwoKaW50IGJ1bmRsZV91cmlfYWR2ZXJ0aXNlKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBzdHJ1Y3Qgc3RyYnVmICp2YWx1ZSBVTlVTRUQpCnsKCXN0YXRpYyBpbnQgYWR2ZXJ0aXNlX2J1bmRsZV91cmkgPSAtMTsKCglpZiAoYWR2ZXJ0aXNlX2J1bmRsZV91cmkgIT0gLTEpCgkJZ290byBjYWNoZWQ7CgoJYWR2ZXJ0aXNlX2J1bmRsZV91cmkgPSAwOwoJcmVwb19jb25maWdfZ2V0X21heWJlX2Jvb2wociwgInVwbG9hZHBhY2suYWR2ZXJ0aXNlYnVuZGxldXJpcyIsICZhZHZlcnRpc2VfYnVuZGxlX3VyaSk7CgpjYWNoZWQ6CglyZXR1cm4gYWR2ZXJ0aXNlX2J1bmRsZV91cmk7Cn0KCnN0YXRpYyBpbnQgY29uZmlnX3RvX3BhY2tldF9saW5lKGNvbnN0IGNoYXIgKmtleSwgY29uc3QgY2hhciAqdmFsdWUsCgkJCQkgY29uc3Qgc3RydWN0IGNvbmZpZ19jb250ZXh0ICpjdHggVU5VU0VELAoJCQkJIHZvaWQgKmRhdGEpCnsKCXN0cnVjdCBwYWNrZXRfcmVhZGVyICp3cml0ZXIgPSBkYXRhOwoKCWlmIChzdGFydHNfd2l0aChrZXksICJidW5kbGUuIikpCgkJcGFja2V0X3dyaXRlX2ZtdCh3cml0ZXItPmZkLCAiJXM9JXMiLCBrZXksIHZhbHVlKTsKCglyZXR1cm4gMDsKfQoKaW50IGJ1bmRsZV91cmlfY29tbWFuZChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkgICAgICAgc3RydWN0IHBhY2tldF9yZWFkZXIgKnJlcXVlc3QpCnsKCXN0cnVjdCBwYWNrZXRfd3JpdGVyIHdyaXRlcjsKCXBhY2tldF93cml0ZXJfaW5pdCgmd3JpdGVyLCAxKTsKCgl3aGlsZSAocGFja2V0X3JlYWRlcl9yZWFkKHJlcXVlc3QpID09IFBBQ0tFVF9SRUFEX05PUk1BTCkKCQlkaWUoXygiYnVuZGxlLXVyaTogdW5leHBlY3RlZCBhcmd1bWVudDogJyVzJyIpLCByZXF1ZXN0LT5saW5lKTsKCWlmIChyZXF1ZXN0LT5zdGF0dXMgIT0gUEFDS0VUX1JFQURfRkxVU0gpCgkJZGllKF8oImJ1bmRsZS11cmk6IGV4cGVjdGVkIGZsdXNoIGFmdGVyIGFyZ3VtZW50cyIpKTsKCgkvKgoJICogUmVhZCBhbGwgImJ1bmRsZS4qIiBjb25maWcgbGluZXMgdG8gdGhlIGNsaWVudCBhcyBrZXk9dmFsdWUKCSAqIHBhY2tldCBsaW5lcy4KCSAqLwoJcmVwb19jb25maWcociwgY29uZmlnX3RvX3BhY2tldF9saW5lLCAmd3JpdGVyKTsKCglwYWNrZXRfd3JpdGVyX2ZsdXNoKCZ3cml0ZXIpOwoKCXJldHVybiAwOwp9CgovKioKICogR2VuZXJhbCBBUEkgZm9yIHt0cmFuc3BvcnQsY29ubmVjdH0uYyBldGMuCiAqLwppbnQgYnVuZGxlX3VyaV9wYXJzZV9saW5lKHN0cnVjdCBidW5kbGVfbGlzdCAqbGlzdCwgY29uc3QgY2hhciAqbGluZSkKewoJaW50IHJlc3VsdDsKCWNvbnN0IGNoYXIgKmVxdWFsczsKCXN0cnVjdCBzdHJidWYga2V5ID0gU1RSQlVGX0lOSVQ7CgoJaWYgKCFzdHJsZW4obGluZSkpCgkJcmV0dXJuIGVycm9yKF8oImJ1bmRsZS11cmk6IGdvdCBhbiBlbXB0eSBsaW5lIikpOwoKCWVxdWFscyA9IHN0cmNocihsaW5lLCAnPScpOwoKCWlmICghZXF1YWxzKQoJCXJldHVybiBlcnJvcihfKCJidW5kbGUtdXJpOiBsaW5lIGlzIG5vdCBvZiB0aGUgZm9ybSAna2V5PXZhbHVlJyIpKTsKCWlmIChsaW5lID09IGVxdWFscyB8fCAhKihlcXVhbHMgKyAxKSkKCQlyZXR1cm4gZXJyb3IoXygiYnVuZGxlLXVyaTogbGluZSBoYXMgZW1wdHkga2V5IG9yIHZhbHVlIikpOwoKCXN0cmJ1Zl9hZGQoJmtleSwgbGluZSwgZXF1YWxzIC0gbGluZSk7CglyZXN1bHQgPSBidW5kbGVfbGlzdF91cGRhdGUoa2V5LmJ1ZiwgZXF1YWxzICsgMSwgbGlzdCk7CglzdHJidWZfcmVsZWFzZSgma2V5KTsKCglyZXR1cm4gcmVzdWx0Owp9Cg==",
    "text": "#define USE_THE_REPOSITORY_VARIABLE\n#define DISABLE_SIGN_COMPARE_WARNINGS\n\n#include \"git-compat-util.h\"\n#include \"bundle-uri.h\"\n#include \"bundle.h\"\n#include \"copy.h\"\n#include \"gettext.h\"\n#include \"refs.h\"\n#include \"run-command.h\"\n#include \"hashmap.h\"\n#include \"pkt-line.h\"\n#include \"config.h\"\n#include \"fetch-pack.h\"\n#include \"remote.h\"\n#include \"trace2.h\"\n#include \"object-store.h\"\n\nstatic struct {\n\tenum bundle_list_heuristic heuristic;\n\tconst char *name;\n} heuristics[BUNDLE_HEURISTIC__COUNT] = {\n\t{ BUNDLE_HEURISTIC_NONE, \"\"},\n\t{ BUNDLE_HEURISTIC_CREATIONTOKEN, \"creationToken\" },\n};\n\nstatic int compare_bundles(const void *hashmap_cmp_fn_data UNUSED,\n\t\t\t   const struct hashmap_entry *he1,\n\t\t\t   const struct hashmap_entry *he2,\n\t\t\t   const void *id)\n{\n\tconst struct remote_bundle_info *e1 =\n\t\tcontainer_of(he1, const struct remote_bundle_info, ent);\n\tconst struct remote_bundle_info *e2 =\n\t\tcontainer_of(he2, const struct remote_bundle_info, ent);\n\n\treturn strcmp(e1->id, id ? (const char *)id : e2->id);\n}\n\nvoid init_bundle_list(struct bundle_list *list)\n{\n\tmemset(list, 0, sizeof(*list));\n\n\t/* Implied defaults. */\n\tlist->mode = BUNDLE_MODE_ALL;\n\tlist->version = 1;\n\n\thashmap_init(&list->bundles, compare_bundles, NULL, 0);\n}\n\nstatic int clear_remote_bundle_info(struct remote_bundle_info *bundle,\n\t\t\t\t    void *data UNUSED)\n{\n\tFREE_AND_NULL(bundle->id);\n\tFREE_AND_NULL(bundle->uri);\n\tFREE_AND_NULL(bundle->file);\n\tbundle->unbundled = 0;\n\treturn 0;\n}\n\nvoid clear_bundle_list(struct bundle_list *list)\n{\n\tif (!list)\n\t\treturn;\n\n\tfor_all_bundles_in_list(list, clear_remote_bundle_info, NULL);\n\thashmap_clear_and_free(&list->bundles, struct remote_bundle_info, ent);\n\tfree(list->baseURI);\n}\n\nint for_all_bundles_in_list(struct bundle_list *list,\n\t\t\t    bundle_iterator iter,\n\t\t\t    void *data)\n{\n\tstruct remote_bundle_info *info;\n\tstruct hashmap_iter i;\n\n\thashmap_for_each_entry(&list->bundles, &i, info, ent) {\n\t\tint result = iter(info, data);\n\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\treturn 0;\n}\n\nstatic int summarize_bundle(struct remote_bundle_info *info, void *data)\n{\n\tFILE *fp = data;\n\tfprintf(fp, \"[bundle \\\"%s\\\"]\\n\", info->id);\n\tfprintf(fp, \"\\turi = %s\\n\", info->uri);\n\n\tif (info->creationToken)\n\t\tfprintf(fp, \"\\tcreationToken = %\"PRIu64\"\\n\", info->creationToken);\n\treturn 0;\n}\n\nvoid print_bundle_list(FILE *fp, struct bundle_list *list)\n{\n\tconst char *mode;\n\n\tswitch (list->mode) {\n\tcase BUNDLE_MODE_ALL:\n\t\tmode = \"all\";\n\t\tbreak;\n\n\tcase BUNDLE_MODE_ANY:\n\t\tmode = \"any\";\n\t\tbreak;\n\n\tcase BUNDLE_MODE_NONE:\n\tdefault:\n\t\tmode = \"<unknown>\";\n\t}\n\n\tfprintf(fp, \"[bundle]\\n\");\n\tfprintf(fp, \"\\tversion = %d\\n\", list->version);\n\tfprintf(fp, \"\\tmode = %s\\n\", mode);\n\n\tif (list->heuristic) {\n\t\tint i;\n\t\tfor (i = 0; i < BUNDLE_HEURISTIC__COUNT; i++) {\n\t\t\tif (heuristics[i].heuristic == list->heuristic) {\n\t\t\t\tprintf(\"\\theuristic = %s\\n\",\n\t\t\t\t       heuristics[list->heuristic].name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor_all_bundles_in_list(list, summarize_bundle, fp);\n}\n\n/**\n * Given a key-value pair, update the state of the given bundle list.\n * Returns 0 if the key-value pair is understood. Returns -1 if the key\n * is not understood or the value is malformed.\n */\nstatic int bundle_list_update(const char *key, const char *value,\n\t\t\t      struct bundle_list *list)\n{\n\tstruct strbuf id = STRBUF_INIT;\n\tstruct remote_bundle_info lookup = REMOTE_BUNDLE_INFO_INIT;\n\tstruct remote_bundle_info *bundle;\n\tconst char *subsection, *subkey;\n\tsize_t subsection_len;\n\n\tif (parse_config_key(key, \"bundle\", &subsection, &subsection_len, &subkey))\n\t\treturn -1;\n\n\tif (!subsection_len) {\n\t\tif (!strcmp(subkey, \"version\")) {\n\t\t\tint version;\n\t\t\tif (!git_parse_int(value, &version))\n\t\t\t\treturn -1;\n\t\t\tif (version != 1)\n\t\t\t\treturn -1;\n\n\t\t\tlist->version = version;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!strcmp(subkey, \"mode\")) {\n\t\t\tif (!strcmp(value, \"all\"))\n\t\t\t\tlist->mode = BUNDLE_MODE_ALL;\n\t\t\telse if (!strcmp(value, \"any\"))\n\t\t\t\tlist->mode = BUNDLE_MODE_ANY;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!strcmp(subkey, \"heuristic\")) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < BUNDLE_HEURISTIC__COUNT; i++) {\n\t\t\t\tif (heuristics[i].heuristic &&\n\t\t\t\t    heuristics[i].name &&\n\t\t\t\t    !strcmp(value, heuristics[i].name)) {\n\t\t\t\t\tlist->heuristic = heuristics[i].heuristic;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Ignore unknown heuristics. */\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Ignore other unknown global keys. */\n\t\treturn 0;\n\t}\n\n\tstrbuf_add(&id, subsection, subsection_len);\n\n\t/*\n\t * Check for an existing bundle with this <id>, or create one\n\t * if necessary.\n\t */\n\tlookup.id = id.buf;\n\thashmap_entry_init(&lookup.ent, strhash(lookup.id));\n\tif (!(bundle = hashmap_get_entry(&list->bundles, &lookup, ent, NULL))) {\n\t\tCALLOC_ARRAY(bundle, 1);\n\t\tbundle->id = strbuf_detach(&id, NULL);\n\t\thashmap_entry_init(&bundle->ent, strhash(bundle->id));\n\t\thashmap_add(&list->bundles, &bundle->ent);\n\t}\n\tstrbuf_release(&id);\n\n\tif (!strcmp(subkey, \"uri\")) {\n\t\tif (bundle->uri)\n\t\t\treturn -1;\n\t\tbundle->uri = relative_url(list->baseURI, value, NULL);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(subkey, \"creationtoken\")) {\n\t\tif (sscanf(value, \"%\"PRIu64, &bundle->creationToken) != 1)\n\t\t\twarning(_(\"could not parse bundle list key %s with value '%s'\"),\n\t\t\t\t\"creationToken\", value);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * At this point, we ignore any information that we don't\n\t * understand, assuming it to be hints for a heuristic the client\n\t * does not currently understand.\n\t */\n\treturn 0;\n}\n\nstatic int config_to_bundle_list(const char *key, const char *value,\n\t\t\t\t const struct config_context *ctx UNUSED,\n\t\t\t\t void *data)\n{\n\tstruct bundle_list *list = data;\n\treturn bundle_list_update(key, value, list);\n}\n\nint bundle_uri_parse_config_format(const char *uri,\n\t\t\t\t   const char *filename,\n\t\t\t\t   struct bundle_list *list)\n{\n\tint result;\n\tstruct config_options opts = {\n\t\t.error_action = CONFIG_ERROR_ERROR,\n\t};\n\n\tif (!list->baseURI) {\n\t\tstruct strbuf baseURI = STRBUF_INIT;\n\t\tstrbuf_addstr(&baseURI, uri);\n\n\t\t/*\n\t\t * If the URI does not end with a trailing slash, then\n\t\t * remove the filename portion of the path. This is\n\t\t * important for relative URIs.\n\t\t */\n\t\tstrbuf_strip_file_from_path(&baseURI);\n\t\tlist->baseURI = strbuf_detach(&baseURI, NULL);\n\t}\n\tresult = git_config_from_file_with_options(config_to_bundle_list,\n\t\t\t\t\t\t   filename, list,\n\t\t\t\t\t\t   CONFIG_SCOPE_UNKNOWN,\n\t\t\t\t\t\t   &opts);\n\n\tif (!result && list->mode == BUNDLE_MODE_NONE) {\n\t\twarning(_(\"bundle list at '%s' has no mode\"), uri);\n\t\tresult = 1;\n\t}\n\n\treturn result;\n}\n\nstatic char *find_temp_filename(void)\n{\n\tint fd;\n\tstruct strbuf name = STRBUF_INIT;\n\t/*\n\t * Find a temporary filename that is available. This is briefly\n\t * racy, but unlikely to collide.\n\t */\n\tfd = odb_mkstemp(&name, \"bundles/tmp_uri_XXXXXX\");\n\tif (fd < 0) {\n\t\twarning(_(\"failed to create temporary file\"));\n\t\treturn NULL;\n\t}\n\n\tclose(fd);\n\tunlink(name.buf);\n\treturn strbuf_detach(&name, NULL);\n}\n\nstatic int download_https_uri_to_file(const char *file, const char *uri)\n{\n\tint result = 0;\n\tstruct child_process cp = CHILD_PROCESS_INIT;\n\tFILE *child_in = NULL, *child_out = NULL;\n\tstruct strbuf line = STRBUF_INIT;\n\tint found_get = 0;\n\n\t/*\n\t * The protocol we speak with git-remote-https(1) uses a space to\n\t * separate between URI and file, so the URI itself must not contain a\n\t * space. If it did, an adversary could change the location where the\n\t * downloaded file is being written to.\n\t *\n\t * Similarly, we use newlines to separate commands from one another.\n\t * Consequently, neither the URI nor the file must contain a newline or\n\t * otherwise an adversary could inject arbitrary commands.\n\t *\n\t * TODO: Restricting newlines in the target paths may break valid\n\t *       usecases, even if those are a bit more on the esoteric side.\n\t *       If this ever becomes a problem we should probably think about\n\t *       alternatives. One alternative could be to use NUL-delimited\n\t *       requests in git-remote-http(1). Another alternative could be\n\t *       to use URL quoting.\n\t */\n\tif (strpbrk(uri, \" \\n\"))\n\t\treturn error(\"bundle-uri: URI is malformed: '%s'\", file);\n\tif (strchr(file, '\\n'))\n\t\treturn error(\"bundle-uri: filename is malformed: '%s'\", file);\n\n\tstrvec_pushl(&cp.args, \"git-remote-https\", uri, NULL);\n\tcp.err = -1;\n\tcp.in = -1;\n\tcp.out = -1;\n\n\tif (start_command(&cp))\n\t\treturn 1;\n\n\tchild_in = fdopen(cp.in, \"w\");\n\tif (!child_in) {\n\t\tresult = 1;\n\t\tgoto cleanup;\n\t}\n\n\tchild_out = fdopen(cp.out, \"r\");\n\tif (!child_out) {\n\t\tresult = 1;\n\t\tgoto cleanup;\n\t}\n\n\tfprintf(child_in, \"capabilities\\n\");\n\tfflush(child_in);\n\n\twhile (!strbuf_getline(&line, child_out)) {\n\t\tif (!line.len)\n\t\t\tbreak;\n\t\tif (!strcmp(line.buf, \"get\"))\n\t\t\tfound_get = 1;\n\t}\n\tstrbuf_release(&line);\n\n\tif (!found_get) {\n\t\tresult = error(_(\"insufficient capabilities\"));\n\t\tgoto cleanup;\n\t}\n\n\tfprintf(child_in, \"get %s %s\\n\\n\", uri, file);\n\ncleanup:\n\tif (child_in)\n\t\tfclose(child_in);\n\tif (finish_command(&cp))\n\t\treturn 1;\n\tif (child_out)\n\t\tfclose(child_out);\n\treturn result;\n}\n\nstatic int copy_uri_to_file(const char *filename, const char *uri)\n{\n\tconst char *out;\n\n\tif (starts_with(uri, \"https:\") ||\n\t    starts_with(uri, \"http:\"))\n\t\treturn download_https_uri_to_file(filename, uri);\n\n\tif (skip_prefix(uri, \"file://\", &out))\n\t\turi = out;\n\n\t/* Copy as a file */\n\treturn copy_file(filename, uri, 0);\n}\n\nstatic int unbundle_from_file(struct repository *r, const char *file)\n{\n\tint result = 0;\n\tint bundle_fd;\n\tstruct bundle_header header = BUNDLE_HEADER_INIT;\n\tstruct string_list_item *refname;\n\tstruct strbuf bundle_ref = STRBUF_INIT;\n\tsize_t bundle_prefix_len;\n\tstruct unbundle_opts opts = {\n\t\t.flags = VERIFY_BUNDLE_QUIET |\n\t\t\t (fetch_pack_fsck_objects() ? VERIFY_BUNDLE_FSCK : 0),\n\t};\n\n\tbundle_fd = read_bundle_header(file, &header);\n\tif (bundle_fd < 0) {\n\t\tresult = 1;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Skip the reachability walk here, since we will be adding\n\t * a reachable ref pointing to the new tips, which will reach\n\t * the prerequisite commits.\n\t */\n\tresult = unbundle(r, &header, bundle_fd, NULL, &opts);\n\tif (result) {\n\t\tresult = 1;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Convert all refs/heads/ from the bundle into refs/bundles/\n\t * in the local repository.\n\t */\n\tstrbuf_addstr(&bundle_ref, \"refs/bundles/\");\n\tbundle_prefix_len = bundle_ref.len;\n\n\tfor_each_string_list_item(refname, &header.references) {\n\t\tstruct object_id *oid = refname->util;\n\t\tstruct object_id old_oid;\n\t\tconst char *branch_name;\n\t\tint has_old;\n\n\t\tif (!skip_prefix(refname->string, \"refs/\", &branch_name))\n\t\t\tcontinue;\n\n\t\tstrbuf_setlen(&bundle_ref, bundle_prefix_len);\n\t\tstrbuf_addstr(&bundle_ref, branch_name);\n\n\t\thas_old = !refs_read_ref(get_main_ref_store(the_repository),\n\t\t\t\t\t bundle_ref.buf, &old_oid);\n\t\trefs_update_ref(get_main_ref_store(the_repository),\n\t\t\t\t\"fetched bundle\", bundle_ref.buf, oid,\n\t\t\t\thas_old ? &old_oid : NULL,\n\t\t\t\t0, UPDATE_REFS_MSG_ON_ERR);\n\t}\n\ncleanup:\n\tstrbuf_release(&bundle_ref);\n\tbundle_header_release(&header);\n\treturn result;\n}\n\nstruct bundle_list_context {\n\tstruct repository *r;\n\tstruct bundle_list *list;\n\tenum bundle_list_mode mode;\n\tint count;\n\tint depth;\n};\n\n/*\n * This early definition is necessary because we use indirect recursion:\n *\n * While iterating through a bundle list that was downloaded as part\n * of fetch_bundle_uri_internal(), iterator methods eventually call it\n * again, but with depth + 1.\n */\nstatic int fetch_bundle_uri_internal(struct repository *r,\n\t\t\t\t     struct remote_bundle_info *bundle,\n\t\t\t\t     int depth,\n\t\t\t\t     struct bundle_list *list);\n\nstatic int download_bundle_to_file(struct remote_bundle_info *bundle, void *data)\n{\n\tint res;\n\tstruct bundle_list_context *ctx = data;\n\n\tif (ctx->mode == BUNDLE_MODE_ANY && ctx->count)\n\t\treturn 0;\n\n\tres = fetch_bundle_uri_internal(ctx->r, bundle, ctx->depth + 1, ctx->list);\n\n\t/*\n\t * Only increment count if the download succeeded. If our mode is\n\t * BUNDLE_MODE_ANY, then we will want to try other URIs in the\n\t * list in case they work instead.\n\t */\n\tif (!res)\n\t\tctx->count++;\n\n\t/*\n\t * To be opportunistic as possible, we continue iterating and\n\t * download as many bundles as we can, so we can apply the ones\n\t * that work, even in BUNDLE_MODE_ALL mode.\n\t */\n\treturn 0;\n}\n\nstruct bundles_for_sorting {\n\tstruct remote_bundle_info **items;\n\tsize_t alloc;\n\tsize_t nr;\n};\n\nstatic int append_bundle(struct remote_bundle_info *bundle, void *data)\n{\n\tstruct bundles_for_sorting *list = data;\n\tlist->items[list->nr++] = bundle;\n\treturn 0;\n}\n\n/**\n * For use in QSORT() to get a list sorted by creationToken\n * in decreasing order.\n */\nstatic int compare_creation_token_decreasing(const void *va, const void *vb)\n{\n\tconst struct remote_bundle_info * const *a = va;\n\tconst struct remote_bundle_info * const *b = vb;\n\n\tif ((*a)->creationToken > (*b)->creationToken)\n\t\treturn -1;\n\tif ((*a)->creationToken < (*b)->creationToken)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int fetch_bundles_by_token(struct repository *r,\n\t\t\t\t  struct bundle_list *list)\n{\n\tint cur;\n\tint move_direction = 0;\n\tconst char *creationTokenStr;\n\tuint64_t maxCreationToken = 0, newMaxCreationToken = 0;\n\tstruct bundle_list_context ctx = {\n\t\t.r = r,\n\t\t.list = list,\n\t\t.mode = list->mode,\n\t};\n\tstruct bundles_for_sorting bundles = {\n\t\t.alloc = hashmap_get_size(&list->bundles),\n\t};\n\n\tALLOC_ARRAY(bundles.items, bundles.alloc);\n\n\tfor_all_bundles_in_list(list, append_bundle, &bundles);\n\n\tif (!bundles.nr) {\n\t\tfree(bundles.items);\n\t\treturn 0;\n\t}\n\n\tQSORT(bundles.items, bundles.nr, compare_creation_token_decreasing);\n\n\t/*\n\t * If fetch.bundleCreationToken exists, parses to a uint64t, and\n\t * is not strictly smaller than the maximum creation token in the\n\t * bundle list, then do not download any bundles.\n\t */\n\tif (!repo_config_get_value(r,\n\t\t\t\t   \"fetch.bundlecreationtoken\",\n\t\t\t\t   &creationTokenStr)) {\n\t\tif (sscanf(creationTokenStr, \"%\"PRIu64, &maxCreationToken) != 1)\n\t\t\tmaxCreationToken = 0;\n\t\tif (bundles.items[0]->creationToken <= maxCreationToken) {\n\t\t\tfree(bundles.items);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Attempt to download and unbundle the minimum number of bundles by\n\t * creationToken in decreasing order. If we fail to unbundle (after\n\t * a successful download) then move to the next non-downloaded bundle\n\t * and attempt downloading. Once we succeed in applying a bundle,\n\t * move to the previous unapplied bundle and attempt to unbundle it\n\t * again.\n\t *\n\t * In the case of a fresh clone, we will likely download all of the\n\t * bundles before successfully unbundling the oldest one, then the\n\t * rest of the bundles unbundle successfully in increasing order\n\t * of creationToken.\n\t *\n\t * If there are existing objects, then this process may terminate\n\t * early when all required commits from \"new\" bundles exist in the\n\t * repo's object store.\n\t */\n\tcur = 0;\n\twhile (cur >= 0 && cur < bundles.nr) {\n\t\tstruct remote_bundle_info *bundle = bundles.items[cur];\n\n\t\t/*\n\t\t * If we need to dig into bundles below the previous\n\t\t * creation token value, then likely we are in an erroneous\n\t\t * state due to missing or invalid bundles. Halt the process\n\t\t * instead of continuing to download extra data.\n\t\t */\n\t\tif (bundle->creationToken <= maxCreationToken)\n\t\t\tbreak;\n\n\t\tif (!bundle->file) {\n\t\t\t/*\n\t\t\t * Not downloaded yet. Try downloading.\n\t\t\t *\n\t\t\t * Note that bundle->file is non-NULL if a download\n\t\t\t * was attempted, even if it failed to download.\n\t\t\t */\n\t\t\tif (fetch_bundle_uri_internal(ctx.r, bundle, ctx.depth + 1, ctx.list)) {\n\t\t\t\t/* Mark as unbundled so we do not retry. */\n\t\t\t\tbundle->unbundled = 1;\n\n\t\t\t\t/* Try looking deeper in the list. */\n\t\t\t\tmove_direction = 1;\n\t\t\t\tgoto move;\n\t\t\t}\n\n\t\t\t/* We expect bundles when using creationTokens. */\n\t\t\tif (!is_bundle(bundle->file, 1)) {\n\t\t\t\twarning(_(\"file downloaded from '%s' is not a bundle\"),\n\t\t\t\t\tbundle->uri);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (bundle->file && !bundle->unbundled) {\n\t\t\t/*\n\t\t\t * This was downloaded, but not successfully\n\t\t\t * unbundled. Try unbundling again.\n\t\t\t */\n\t\t\tif (unbundle_from_file(ctx.r, bundle->file)) {\n\t\t\t\t/* Try looking deeper in the list. */\n\t\t\t\tmove_direction = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Succeeded in unbundle. Retry bundles\n\t\t\t\t * that previously failed to unbundle.\n\t\t\t\t */\n\t\t\t\tmove_direction = -1;\n\t\t\t\tbundle->unbundled = 1;\n\n\t\t\t\tif (bundle->creationToken > newMaxCreationToken)\n\t\t\t\t\tnewMaxCreationToken = bundle->creationToken;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Else case: downloaded and unbundled successfully.\n\t\t * Skip this by moving in the same direction as the\n\t\t * previous step.\n\t\t */\n\nmove:\n\t\t/* Move in the specified direction and repeat. */\n\t\tcur += move_direction;\n\t}\n\n\t/*\n\t * We succeed if the loop terminates because 'cur' drops below\n\t * zero. The other case is that we terminate because 'cur'\n\t * reaches the end of the list, so we have a failure no matter\n\t * which bundles we apply from the list.\n\t */\n\tif (cur < 0) {\n\t\tstruct strbuf value = STRBUF_INIT;\n\t\tstrbuf_addf(&value, \"%\"PRIu64\"\", newMaxCreationToken);\n\t\tif (repo_config_set_multivar_gently(ctx.r,\n\t\t\t\t\t\t    \"fetch.bundleCreationToken\",\n\t\t\t\t\t\t    value.buf, NULL, 0))\n\t\t\twarning(_(\"failed to store maximum creation token\"));\n\n\t\tstrbuf_release(&value);\n\t}\n\n\tfree(bundles.items);\n\treturn cur >= 0;\n}\n\nstatic int download_bundle_list(struct repository *r,\n\t\t\t\tstruct bundle_list *local_list,\n\t\t\t\tstruct bundle_list *global_list,\n\t\t\t\tint depth)\n{\n\tstruct bundle_list_context ctx = {\n\t\t.r = r,\n\t\t.list = global_list,\n\t\t.depth = depth + 1,\n\t\t.mode = local_list->mode,\n\t};\n\n\treturn for_all_bundles_in_list(local_list, download_bundle_to_file, &ctx);\n}\n\nstatic int fetch_bundle_list_in_config_format(struct repository *r,\n\t\t\t\t\t      struct bundle_list *global_list,\n\t\t\t\t\t      struct remote_bundle_info *bundle,\n\t\t\t\t\t      int depth)\n{\n\tint result;\n\tstruct bundle_list list_from_bundle;\n\n\tinit_bundle_list(&list_from_bundle);\n\n\tif ((result = bundle_uri_parse_config_format(bundle->uri,\n\t\t\t\t\t\t     bundle->file,\n\t\t\t\t\t\t     &list_from_bundle)))\n\t\tgoto cleanup;\n\n\tif (list_from_bundle.mode == BUNDLE_MODE_NONE) {\n\t\twarning(_(\"unrecognized bundle mode from URI '%s'\"),\n\t\t\tbundle->uri);\n\t\tresult = -1;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * If this list uses the creationToken heuristic, then the URIs\n\t * it advertises are expected to be bundles, not nested lists.\n\t * We can drop 'global_list' and 'depth'.\n\t */\n\tif (list_from_bundle.heuristic == BUNDLE_HEURISTIC_CREATIONTOKEN) {\n\t\tresult = fetch_bundles_by_token(r, &list_from_bundle);\n\t\tglobal_list->heuristic = BUNDLE_HEURISTIC_CREATIONTOKEN;\n\t} else if ((result = download_bundle_list(r, &list_from_bundle,\n\t\t\t\t\t   global_list, depth)))\n\t\tgoto cleanup;\n\ncleanup:\n\tclear_bundle_list(&list_from_bundle);\n\treturn result;\n}\n\n/**\n * This limits the recursion on fetch_bundle_uri_internal() when following\n * bundle lists.\n */\nstatic int max_bundle_uri_depth = 4;\n\n/**\n * Recursively download all bundles advertised at the given URI\n * to files. If the file is a bundle, then add it to the given\n * 'list'. Otherwise, expect a bundle list and recurse on the\n * URIs in that list according to the list mode (ANY or ALL).\n */\nstatic int fetch_bundle_uri_internal(struct repository *r,\n\t\t\t\t     struct remote_bundle_info *bundle,\n\t\t\t\t     int depth,\n\t\t\t\t     struct bundle_list *list)\n{\n\tint result = 0;\n\tstruct remote_bundle_info *bcopy;\n\n\tif (depth >= max_bundle_uri_depth) {\n\t\twarning(_(\"exceeded bundle URI recursion limit (%d)\"),\n\t\t\tmax_bundle_uri_depth);\n\t\treturn -1;\n\t}\n\n\tif (!bundle->file &&\n\t    !(bundle->file = find_temp_filename())) {\n\t\tresult = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((result = copy_uri_to_file(bundle->file, bundle->uri))) {\n\t\twarning(_(\"failed to download bundle from URI '%s'\"), bundle->uri);\n\t\tgoto cleanup;\n\t}\n\n\tif ((result = !is_bundle(bundle->file, 1))) {\n\t\tresult = fetch_bundle_list_in_config_format(\n\t\t\t\tr, list, bundle, depth);\n\t\tif (result)\n\t\t\twarning(_(\"file at URI '%s' is not a bundle or bundle list\"),\n\t\t\t\tbundle->uri);\n\t\tgoto cleanup;\n\t}\n\n\t/* Copy the bundle and insert it into the global list. */\n\tCALLOC_ARRAY(bcopy, 1);\n\tbcopy->id = xstrdup(bundle->id);\n\tbcopy->file = xstrdup(bundle->file);\n\thashmap_entry_init(&bcopy->ent, strhash(bcopy->id));\n\thashmap_add(&list->bundles, &bcopy->ent);\n\ncleanup:\n\tif (result && bundle->file)\n\t\tunlink(bundle->file);\n\treturn result;\n}\n\n/**\n * This loop iterator breaks the loop with nonzero return code on the\n * first successful unbundling of a bundle.\n */\nstatic int attempt_unbundle(struct remote_bundle_info *info, void *data)\n{\n\tstruct repository *r = data;\n\n\tif (!info->file || info->unbundled)\n\t\treturn 0;\n\n\tif (!unbundle_from_file(r, info->file)) {\n\t\tinfo->unbundled = 1;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int unbundle_all_bundles(struct repository *r,\n\t\t\t\tstruct bundle_list *list)\n{\n\t/*\n\t * Iterate through all bundles looking for ones that can\n\t * successfully unbundle. If any succeed, then perhaps another\n\t * will succeed in the next attempt.\n\t *\n\t * Keep in mind that a non-zero result for the loop here means\n\t * the loop terminated early on a successful unbundling, which\n\t * signals that we can try again.\n\t */\n\twhile (for_all_bundles_in_list(list, attempt_unbundle, r)) ;\n\n\treturn 0;\n}\n\nstatic int unlink_bundle(struct remote_bundle_info *info, void *data UNUSED)\n{\n\tif (info->file)\n\t\tunlink_or_warn(info->file);\n\treturn 0;\n}\n\nint fetch_bundle_uri(struct repository *r, const char *uri,\n\t\t     int *has_heuristic)\n{\n\tint result;\n\tstruct bundle_list list;\n\tstruct remote_bundle_info bundle = {\n\t\t.uri = xstrdup(uri),\n\t\t.id = xstrdup(\"\"),\n\t};\n\n\ttrace2_region_enter(\"fetch\", \"fetch-bundle-uri\", the_repository);\n\n\tinit_bundle_list(&list);\n\n\t/*\n\t * Do not fetch an empty bundle URI. An empty bundle URI\n\t * could signal that a configured bundle URI has been disabled.\n\t */\n\tif (!*uri) {\n\t\tresult = 0;\n\t\tgoto cleanup;\n\t}\n\n\t/* If a bundle is added to this global list, then it is required. */\n\tlist.mode = BUNDLE_MODE_ALL;\n\n\tif ((result = fetch_bundle_uri_internal(r, &bundle, 0, &list)))\n\t\tgoto cleanup;\n\n\tresult = unbundle_all_bundles(r, &list);\n\ncleanup:\n\tif (has_heuristic)\n\t\t*has_heuristic = (list.heuristic != BUNDLE_HEURISTIC_NONE);\n\tfor_all_bundles_in_list(&list, unlink_bundle, NULL);\n\tclear_bundle_list(&list);\n\tclear_remote_bundle_info(&bundle, NULL);\n\ttrace2_region_leave(\"fetch\", \"fetch-bundle-uri\", the_repository);\n\treturn result;\n}\n\nint fetch_bundle_list(struct repository *r, struct bundle_list *list)\n{\n\tint result;\n\tstruct bundle_list global_list;\n\n\t/*\n\t * If the creationToken heuristic is used, then the URIs\n\t * advertised by 'list' are not nested lists and instead\n\t * direct bundles. We do not need to use global_list.\n\t */\n\tif (list->heuristic == BUNDLE_HEURISTIC_CREATIONTOKEN)\n\t\treturn fetch_bundles_by_token(r, list);\n\n\tinit_bundle_list(&global_list);\n\n\t/* If a bundle is added to this global list, then it is required. */\n\tglobal_list.mode = BUNDLE_MODE_ALL;\n\n\tif ((result = download_bundle_list(r, list, &global_list, 0)))\n\t\tgoto cleanup;\n\n\tif (list->heuristic == BUNDLE_HEURISTIC_CREATIONTOKEN)\n\t\tresult = fetch_bundles_by_token(r, list);\n\telse\n\t\tresult = unbundle_all_bundles(r, &global_list);\n\ncleanup:\n\tfor_all_bundles_in_list(&global_list, unlink_bundle, NULL);\n\tclear_bundle_list(&global_list);\n\treturn result;\n}\n\n/**\n * API for serve.c.\n */\n\nint bundle_uri_advertise(struct repository *r, struct strbuf *value UNUSED)\n{\n\tstatic int advertise_bundle_uri = -1;\n\n\tif (advertise_bundle_uri != -1)\n\t\tgoto cached;\n\n\tadvertise_bundle_uri = 0;\n\trepo_config_get_maybe_bool(r, \"uploadpack.advertisebundleuris\", &advertise_bundle_uri);\n\ncached:\n\treturn advertise_bundle_uri;\n}\n\nstatic int config_to_packet_line(const char *key, const char *value,\n\t\t\t\t const struct config_context *ctx UNUSED,\n\t\t\t\t void *data)\n{\n\tstruct packet_reader *writer = data;\n\n\tif (starts_with(key, \"bundle.\"))\n\t\tpacket_write_fmt(writer->fd, \"%s=%s\", key, value);\n\n\treturn 0;\n}\n\nint bundle_uri_command(struct repository *r,\n\t\t       struct packet_reader *request)\n{\n\tstruct packet_writer writer;\n\tpacket_writer_init(&writer, 1);\n\n\twhile (packet_reader_read(request) == PACKET_READ_NORMAL)\n\t\tdie(_(\"bundle-uri: unexpected argument: '%s'\"), request->line);\n\tif (request->status != PACKET_READ_FLUSH)\n\t\tdie(_(\"bundle-uri: expected flush after arguments\"));\n\n\t/*\n\t * Read all \"bundle.*\" config lines to the client as key=value\n\t * packet lines.\n\t */\n\trepo_config(r, config_to_packet_line, &writer);\n\n\tpacket_writer_flush(&writer);\n\n\treturn 0;\n}\n\n/**\n * General API for {transport,connect}.c etc.\n */\nint bundle_uri_parse_line(struct bundle_list *list, const char *line)\n{\n\tint result;\n\tconst char *equals;\n\tstruct strbuf key = STRBUF_INIT;\n\n\tif (!strlen(line))\n\t\treturn error(_(\"bundle-uri: got an empty line\"));\n\n\tequals = strchr(line, '=');\n\n\tif (!equals)\n\t\treturn error(_(\"bundle-uri: line is not of the form 'key=value'\"));\n\tif (line == equals || !*(equals + 1))\n\t\treturn error(_(\"bundle-uri: line has empty key or value\"));\n\n\tstrbuf_add(&key, line, equals - line);\n\tresult = bundle_list_update(key.buf, equals + 1, list);\n\tstrbuf_release(&key);\n\n\treturn result;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0050c62bd5e0723d2f911d2ced5edb8030a613ce",
  "sha1_ok": true,
  "size": 24778
}
