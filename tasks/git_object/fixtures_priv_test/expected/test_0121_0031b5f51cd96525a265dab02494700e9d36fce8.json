{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGNsb25lIgogKgogKiBDb3B5cmlnaHQgKGMpIDIwMDcgS3Jpc3RpYW4gSMO4Z3NiZXJnIDxrcmhAcmVkaGF0LmNvbT4sCiAqCQkgMjAwOCBEYW5pZWwgQmFya2Fsb3cgPGJhcmthbG93QGlhYmVydm9uLm9yZz4KICogQmFzZWQgb24gZ2l0LWNvbW1pdC5zaCBieSBKdW5pbyBDIEhhbWFubyBhbmQgTGludXMgVG9ydmFsZHMKICoKICogQ2xvbmUgYSByZXBvc2l0b3J5IGludG8gYSBkaWZmZXJlbnQgZGlyZWN0b3J5IHRoYXQgZG9lcyBub3QgeWV0IGV4aXN0LgogKi8KCiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAiZmV0Y2gtcGFjay5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAidHJlZS5oIgojaW5jbHVkZSAidHJlZS13YWxrLmgiCiNpbmNsdWRlICJ1bnBhY2stdHJlZXMuaCIKI2luY2x1ZGUgInRyYW5zcG9ydC5oIgojaW5jbHVkZSAic3RyYnVmLmgiCiNpbmNsdWRlICJkaXIuaCIKI2luY2x1ZGUgInBhY2stcmVmcy5oIgojaW5jbHVkZSAic2lnY2hhaW4uaCIKI2luY2x1ZGUgImJyYW5jaC5oIgojaW5jbHVkZSAicmVtb3RlLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgoKLyoKICogT3ZlcmFsbCBGSVhNRXM6CiAqICAtIHJlc3BlY3QgREJfRU5WSVJPTk1FTlQgZm9yIC5naXQvb2JqZWN0cy4KICoKICogSW1wbGVtZW50YXRpb24gbm90ZXM6CiAqICAtIGRyb3BwaW5nIHVzZS1zZXBhcmF0ZS1yZW1vdGUgYW5kIG5vLXNlcGFyYXRlLXJlbW90ZSBjb21wYXRpYmlsaXR5CiAqCiAqLwpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGJ1aWx0aW5fY2xvbmVfdXNhZ2VbXSA9IHsKCSJnaXQgY2xvbmUgW29wdGlvbnNdIFstLV0gPHJlcG8+IFs8ZGlyPl0iLAoJTlVMTAp9OwoKc3RhdGljIGludCBvcHRpb25fcXVpZXQsIG9wdGlvbl9ub19jaGVja291dCwgb3B0aW9uX2JhcmUsIG9wdGlvbl9taXJyb3I7CnN0YXRpYyBpbnQgb3B0aW9uX2xvY2FsLCBvcHRpb25fbm9faGFyZGxpbmtzLCBvcHRpb25fc2hhcmVkOwpzdGF0aWMgY2hhciAqb3B0aW9uX3RlbXBsYXRlLCAqb3B0aW9uX3JlZmVyZW5jZSwgKm9wdGlvbl9kZXB0aDsKc3RhdGljIGNoYXIgKm9wdGlvbl9vcmlnaW4gPSBOVUxMOwpzdGF0aWMgY2hhciAqb3B0aW9uX3VwbG9hZF9wYWNrID0gImdpdC11cGxvYWQtcGFjayI7CnN0YXRpYyBpbnQgb3B0aW9uX3ZlcmJvc2U7CgpzdGF0aWMgc3RydWN0IG9wdGlvbiBidWlsdGluX2Nsb25lX29wdGlvbnNbXSA9IHsKCU9QVF9fUVVJRVQoJm9wdGlvbl9xdWlldCksCglPUFRfX1ZFUkJPU0UoJm9wdGlvbl92ZXJib3NlKSwKCU9QVF9CT09MRUFOKCduJywgIm5vLWNoZWNrb3V0IiwgJm9wdGlvbl9ub19jaGVja291dCwKCQkgICAgImRvbid0IGNyZWF0ZSBhIGNoZWNrb3V0IiksCglPUFRfQk9PTEVBTigwLCAiYmFyZSIsICZvcHRpb25fYmFyZSwgImNyZWF0ZSBhIGJhcmUgcmVwb3NpdG9yeSIpLAoJT1BUX0JPT0xFQU4oMCwgIm5ha2VkIiwgJm9wdGlvbl9iYXJlLCAiY3JlYXRlIGEgYmFyZSByZXBvc2l0b3J5IiksCglPUFRfQk9PTEVBTigwLCAibWlycm9yIiwgJm9wdGlvbl9taXJyb3IsCgkJICAgICJjcmVhdGUgYSBtaXJyb3IgcmVwb3NpdG9yeSAoaW1wbGllcyBiYXJlKSIpLAoJT1BUX0JPT0xFQU4oJ2wnLCAibG9jYWwiLCAmb3B0aW9uX2xvY2FsLAoJCSAgICAidG8gY2xvbmUgZnJvbSBhIGxvY2FsIHJlcG9zaXRvcnkiKSwKCU9QVF9CT09MRUFOKDAsICJuby1oYXJkbGlua3MiLCAmb3B0aW9uX25vX2hhcmRsaW5rcywKCQkgICAgImRvbid0IHVzZSBsb2NhbCBoYXJkbGlua3MsIGFsd2F5cyBjb3B5IiksCglPUFRfQk9PTEVBTigncycsICJzaGFyZWQiLCAmb3B0aW9uX3NoYXJlZCwKCQkgICAgInNldHVwIGFzIHNoYXJlZCByZXBvc2l0b3J5IiksCglPUFRfU1RSSU5HKDAsICJ0ZW1wbGF0ZSIsICZvcHRpb25fdGVtcGxhdGUsICJwYXRoIiwKCQkgICAicGF0aCB0aGUgdGVtcGxhdGUgcmVwb3NpdG9yeSIpLAoJT1BUX1NUUklORygwLCAicmVmZXJlbmNlIiwgJm9wdGlvbl9yZWZlcmVuY2UsICJyZXBvIiwKCQkgICAicmVmZXJlbmNlIHJlcG9zaXRvcnkiKSwKCU9QVF9TVFJJTkcoJ28nLCAib3JpZ2luIiwgJm9wdGlvbl9vcmlnaW4sICJicmFuY2giLAoJCSAgICJ1c2UgPGJyYW5jaD4gaW5zdGVhZCBvZiAnb3JpZ2luJyB0byB0cmFjayB1cHN0cmVhbSIpLAoJT1BUX1NUUklORygndScsICJ1cGxvYWQtcGFjayIsICZvcHRpb25fdXBsb2FkX3BhY2ssICJwYXRoIiwKCQkgICAicGF0aCB0byBnaXQtdXBsb2FkLXBhY2sgb24gdGhlIHJlbW90ZSIpLAoJT1BUX1NUUklORygwLCAiZGVwdGgiLCAmb3B0aW9uX2RlcHRoLCAiZGVwdGgiLAoJCSAgICAiY3JlYXRlIGEgc2hhbGxvdyBjbG9uZSBvZiB0aGF0IGRlcHRoIiksCgoJT1BUX0VORCgpCn07CgpzdGF0aWMgY2hhciAqZ2V0X3JlcG9fcGF0aChjb25zdCBjaGFyICpyZXBvLCBpbnQgKmlzX2J1bmRsZSkKewoJc3RhdGljIGNoYXIgKnN1ZmZpeFtdID0geyAiLy5naXQiLCAiLmdpdCIsICIiIH07CglzdGF0aWMgY2hhciAqYnVuZGxlX3N1ZmZpeFtdID0geyAiLmJ1bmRsZSIsICIiIH07CglzdHJ1Y3Qgc3RhdCBzdDsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBBUlJBWV9TSVpFKHN1ZmZpeCk7IGkrKykgewoJCWNvbnN0IGNoYXIgKnBhdGg7CgkJcGF0aCA9IG1rcGF0aCgiJXMlcyIsIHJlcG8sIHN1ZmZpeFtpXSk7CgkJaWYgKGlzX2RpcmVjdG9yeShwYXRoKSkgewoJCQkqaXNfYnVuZGxlID0gMDsKCQkJcmV0dXJuIHhzdHJkdXAobWFrZV9ub25yZWxhdGl2ZV9wYXRoKHBhdGgpKTsKCQl9Cgl9CgoJZm9yIChpID0gMDsgaSA8IEFSUkFZX1NJWkUoYnVuZGxlX3N1ZmZpeCk7IGkrKykgewoJCWNvbnN0IGNoYXIgKnBhdGg7CgkJcGF0aCA9IG1rcGF0aCgiJXMlcyIsIHJlcG8sIGJ1bmRsZV9zdWZmaXhbaV0pOwoJCWlmICghc3RhdChwYXRoLCAmc3QpICYmIFNfSVNSRUcoc3Quc3RfbW9kZSkpIHsKCQkJKmlzX2J1bmRsZSA9IDE7CgkJCXJldHVybiB4c3RyZHVwKG1ha2Vfbm9ucmVsYXRpdmVfcGF0aChwYXRoKSk7CgkJfQoJfQoKCXJldHVybiBOVUxMOwp9CgpzdGF0aWMgY2hhciAqZ3Vlc3NfZGlyX25hbWUoY29uc3QgY2hhciAqcmVwbywgaW50IGlzX2J1bmRsZSwgaW50IGlzX2JhcmUpCnsKCWNvbnN0IGNoYXIgKmVuZCA9IHJlcG8gKyBzdHJsZW4ocmVwbyksICpzdGFydDsKCgkvKgoJICogU3RyaXAgdHJhaWxpbmcgc2xhc2hlcyBhbmQgLy5naXQKCSAqLwoJd2hpbGUgKHJlcG8gPCBlbmQgJiYgaXNfZGlyX3NlcChlbmRbLTFdKSkKCQllbmQtLTsKCWlmIChlbmQgLSByZXBvID4gNSAmJiBpc19kaXJfc2VwKGVuZFstNV0pICYmCgkgICAgIXN0cm5jbXAoZW5kIC0gNCwgIi5naXQiLCA0KSkgewoJCWVuZCAtPSA1OwoJCXdoaWxlIChyZXBvIDwgZW5kICYmIGlzX2Rpcl9zZXAoZW5kWy0xXSkpCgkJCWVuZC0tOwoJfQoKCS8qCgkgKiBGaW5kIGxhc3QgY29tcG9uZW50LCBidXQgYmUgcHJlcGFyZWQgdGhhdCByZXBvIGNvdWxkIGhhdmUKCSAqIHRoZSBmb3JtICAicmVtb3RlLmV4YW1wbGUuY29tOmZvby5naXQiLCBpLmUuIG5vIHNsYXNoCgkgKiBpbiB0aGUgZGlyZWN0b3J5IHBhcnQuCgkgKi8KCXN0YXJ0ID0gZW5kOwoJd2hpbGUgKHJlcG8gPCBzdGFydCAmJiAhaXNfZGlyX3NlcChzdGFydFstMV0pICYmIHN0YXJ0Wy0xXSAhPSAnOicpCgkJc3RhcnQtLTsKCgkvKgoJICogU3RyaXAgLntidW5kbGUsZ2l0fS4KCSAqLwoJaWYgKGlzX2J1bmRsZSkgewoJCWlmIChlbmQgLSBzdGFydCA+IDcgJiYgIXN0cm5jbXAoZW5kIC0gNywgIi5idW5kbGUiLCA3KSkKCQkJZW5kIC09IDc7Cgl9IGVsc2UgewoJCWlmIChlbmQgLSBzdGFydCA+IDQgJiYgIXN0cm5jbXAoZW5kIC0gNCwgIi5naXQiLCA0KSkKCQkJZW5kIC09IDQ7Cgl9CgoJaWYgKGlzX2JhcmUpIHsKCQlzdHJ1Y3Qgc3RyYnVmIHJlc3VsdCA9IFNUUkJVRl9JTklUOwoJCXN0cmJ1Zl9hZGRmKCZyZXN1bHQsICIlLipzLmdpdCIsIChpbnQpKGVuZCAtIHN0YXJ0KSwgc3RhcnQpOwoJCXJldHVybiBzdHJidWZfZGV0YWNoKCZyZXN1bHQsIDApOwoJfQoKCXJldHVybiB4c3RybmR1cChzdGFydCwgZW5kIC0gc3RhcnQpOwp9CgpzdGF0aWMgdm9pZCBzdHJpcF90cmFpbGluZ19zbGFzaGVzKGNoYXIgKmRpcikKewoJY2hhciAqZW5kID0gZGlyICsgc3RybGVuKGRpcik7CgoJd2hpbGUgKGRpciA8IGVuZCAtIDEgJiYgaXNfZGlyX3NlcChlbmRbLTFdKSkKCQllbmQtLTsKCSplbmQgPSAnXDAnOwp9CgpzdGF0aWMgdm9pZCBzZXR1cF9yZWZlcmVuY2UoY29uc3QgY2hhciAqcmVwbykKewoJY29uc3QgY2hhciAqcmVmX2dpdDsKCWNoYXIgKnJlZl9naXRfY29weTsKCglzdHJ1Y3QgcmVtb3RlICpyZW1vdGU7CglzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQ7Cgljb25zdCBzdHJ1Y3QgcmVmICpleHRyYTsKCglyZWZfZ2l0ID0gbWFrZV9hYnNvbHV0ZV9wYXRoKG9wdGlvbl9yZWZlcmVuY2UpOwoKCWlmIChpc19kaXJlY3RvcnkobWtwYXRoKCIlcy8uZ2l0L29iamVjdHMiLCByZWZfZ2l0KSkpCgkJcmVmX2dpdCA9IG1rcGF0aCgiJXMvLmdpdCIsIHJlZl9naXQpOwoJZWxzZSBpZiAoIWlzX2RpcmVjdG9yeShta3BhdGgoIiVzL29iamVjdHMiLCByZWZfZ2l0KSkpCgkJZGllKCJyZWZlcmVuY2UgcmVwb3NpdG9yeSAnJXMnIGlzIG5vdCBhIGxvY2FsIGRpcmVjdG9yeS4iLAoJCSAgICBvcHRpb25fcmVmZXJlbmNlKTsKCglyZWZfZ2l0X2NvcHkgPSB4c3RyZHVwKHJlZl9naXQpOwoKCWFkZF90b19hbHRlcm5hdGVzX2ZpbGUocmVmX2dpdF9jb3B5KTsKCglyZW1vdGUgPSByZW1vdGVfZ2V0KHJlZl9naXRfY29weSk7Cgl0cmFuc3BvcnQgPSB0cmFuc3BvcnRfZ2V0KHJlbW90ZSwgcmVmX2dpdF9jb3B5KTsKCWZvciAoZXh0cmEgPSB0cmFuc3BvcnRfZ2V0X3JlbW90ZV9yZWZzKHRyYW5zcG9ydCk7IGV4dHJhOwoJICAgICBleHRyYSA9IGV4dHJhLT5uZXh0KQoJCWFkZF9leHRyYV9yZWYoZXh0cmEtPm5hbWUsIGV4dHJhLT5vbGRfc2hhMSwgMCk7CgoJdHJhbnNwb3J0X2Rpc2Nvbm5lY3QodHJhbnNwb3J0KTsKCglmcmVlKHJlZl9naXRfY29weSk7Cn0KCnN0YXRpYyB2b2lkIGNvcHlfb3JfbGlua19kaXJlY3Rvcnkoc3RydWN0IHN0cmJ1ZiAqc3JjLCBzdHJ1Y3Qgc3RyYnVmICpkZXN0KQp7CglzdHJ1Y3QgZGlyZW50ICpkZTsKCXN0cnVjdCBzdGF0IGJ1ZjsKCWludCBzcmNfbGVuLCBkZXN0X2xlbjsKCURJUiAqZGlyOwoKCWRpciA9IG9wZW5kaXIoc3JjLT5idWYpOwoJaWYgKCFkaXIpCgkJZGllKCJmYWlsZWQgdG8gb3BlbiAlcyIsIHNyYy0+YnVmKTsKCglpZiAobWtkaXIoZGVzdC0+YnVmLCAwNzc3KSkgewoJCWlmIChlcnJubyAhPSBFRVhJU1QpCgkJCWRpZSgiZmFpbGVkIHRvIGNyZWF0ZSBkaXJlY3RvcnkgJXMiLCBkZXN0LT5idWYpOwoJCWVsc2UgaWYgKHN0YXQoZGVzdC0+YnVmLCAmYnVmKSkKCQkJZGllKCJmYWlsZWQgdG8gc3RhdCAlcyIsIGRlc3QtPmJ1Zik7CgkJZWxzZSBpZiAoIVNfSVNESVIoYnVmLnN0X21vZGUpKQoJCQlkaWUoIiVzIGV4aXN0cyBhbmQgaXMgbm90IGEgZGlyZWN0b3J5IiwgZGVzdC0+YnVmKTsKCX0KCglzdHJidWZfYWRkY2goc3JjLCAnLycpOwoJc3JjX2xlbiA9IHNyYy0+bGVuOwoJc3RyYnVmX2FkZGNoKGRlc3QsICcvJyk7CglkZXN0X2xlbiA9IGRlc3QtPmxlbjsKCgl3aGlsZSAoKGRlID0gcmVhZGRpcihkaXIpKSAhPSBOVUxMKSB7CgkJc3RyYnVmX3NldGxlbihzcmMsIHNyY19sZW4pOwoJCXN0cmJ1Zl9hZGRzdHIoc3JjLCBkZS0+ZF9uYW1lKTsKCQlzdHJidWZfc2V0bGVuKGRlc3QsIGRlc3RfbGVuKTsKCQlzdHJidWZfYWRkc3RyKGRlc3QsIGRlLT5kX25hbWUpOwoJCWlmIChzdGF0KHNyYy0+YnVmLCAmYnVmKSkgewoJCQl3YXJuaW5nICgiZmFpbGVkIHRvIHN0YXQgJXNcbiIsIHNyYy0+YnVmKTsKCQkJY29udGludWU7CgkJfQoJCWlmIChTX0lTRElSKGJ1Zi5zdF9tb2RlKSkgewoJCQlpZiAoZGUtPmRfbmFtZVswXSAhPSAnLicpCgkJCQljb3B5X29yX2xpbmtfZGlyZWN0b3J5KHNyYywgZGVzdCk7CgkJCWNvbnRpbnVlOwoJCX0KCgkJaWYgKHVubGluayhkZXN0LT5idWYpICYmIGVycm5vICE9IEVOT0VOVCkKCQkJZGllKCJmYWlsZWQgdG8gdW5saW5rICVzIiwgZGVzdC0+YnVmKTsKCQlpZiAoIW9wdGlvbl9ub19oYXJkbGlua3MpIHsKCQkJaWYgKCFsaW5rKHNyYy0+YnVmLCBkZXN0LT5idWYpKQoJCQkJY29udGludWU7CgkJCWlmIChvcHRpb25fbG9jYWwpCgkJCQlkaWUoImZhaWxlZCB0byBjcmVhdGUgbGluayAlcyIsIGRlc3QtPmJ1Zik7CgkJCW9wdGlvbl9ub19oYXJkbGlua3MgPSAxOwoJCX0KCQlpZiAoY29weV9maWxlKGRlc3QtPmJ1Ziwgc3JjLT5idWYsIDA2NjYpKQoJCQlkaWUoImZhaWxlZCB0byBjb3B5IGZpbGUgdG8gJXMiLCBkZXN0LT5idWYpOwoJfQoJY2xvc2VkaXIoZGlyKTsKfQoKc3RhdGljIGNvbnN0IHN0cnVjdCByZWYgKmNsb25lX2xvY2FsKGNvbnN0IGNoYXIgKnNyY19yZXBvLAoJCQkJICAgICBjb25zdCBjaGFyICpkZXN0X3JlcG8pCnsKCWNvbnN0IHN0cnVjdCByZWYgKnJldDsKCXN0cnVjdCBzdHJidWYgc3JjID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGRlc3QgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCByZW1vdGUgKnJlbW90ZTsKCXN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydDsKCglpZiAob3B0aW9uX3NoYXJlZCkKCQlhZGRfdG9fYWx0ZXJuYXRlc19maWxlKHNyY19yZXBvKTsKCWVsc2UgewoJCXN0cmJ1Zl9hZGRmKCZzcmMsICIlcy9vYmplY3RzIiwgc3JjX3JlcG8pOwoJCXN0cmJ1Zl9hZGRmKCZkZXN0LCAiJXMvb2JqZWN0cyIsIGRlc3RfcmVwbyk7CgkJY29weV9vcl9saW5rX2RpcmVjdG9yeSgmc3JjLCAmZGVzdCk7CgkJc3RyYnVmX3JlbGVhc2UoJnNyYyk7CgkJc3RyYnVmX3JlbGVhc2UoJmRlc3QpOwoJfQoKCXJlbW90ZSA9IHJlbW90ZV9nZXQoc3JjX3JlcG8pOwoJdHJhbnNwb3J0ID0gdHJhbnNwb3J0X2dldChyZW1vdGUsIHNyY19yZXBvKTsKCXJldCA9IHRyYW5zcG9ydF9nZXRfcmVtb3RlX3JlZnModHJhbnNwb3J0KTsKCXRyYW5zcG9ydF9kaXNjb25uZWN0KHRyYW5zcG9ydCk7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgY29uc3QgY2hhciAqanVua193b3JrX3RyZWU7CnN0YXRpYyBjb25zdCBjaGFyICpqdW5rX2dpdF9kaXI7CnBpZF90IGp1bmtfcGlkOwoKc3RhdGljIHZvaWQgcmVtb3ZlX2p1bmsodm9pZCkKewoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJaWYgKGdldHBpZCgpICE9IGp1bmtfcGlkKQoJCXJldHVybjsKCWlmIChqdW5rX2dpdF9kaXIpIHsKCQlzdHJidWZfYWRkc3RyKCZzYiwganVua19naXRfZGlyKTsKCQlyZW1vdmVfZGlyX3JlY3Vyc2l2ZWx5KCZzYiwgMCk7CgkJc3RyYnVmX3Jlc2V0KCZzYik7Cgl9CglpZiAoanVua193b3JrX3RyZWUpIHsKCQlzdHJidWZfYWRkc3RyKCZzYiwganVua193b3JrX3RyZWUpOwoJCXJlbW92ZV9kaXJfcmVjdXJzaXZlbHkoJnNiLCAwKTsKCQlzdHJidWZfcmVzZXQoJnNiKTsKCX0KfQoKc3RhdGljIHZvaWQgcmVtb3ZlX2p1bmtfb25fc2lnbmFsKGludCBzaWdubykKewoJcmVtb3ZlX2p1bmsoKTsKCXNpZ2NoYWluX3BvcChzaWdubyk7CglyYWlzZShzaWdubyk7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVmICp3cml0ZV9yZW1vdGVfcmVmcyhjb25zdCBzdHJ1Y3QgcmVmICpyZWZzLAoJCXN0cnVjdCByZWZzcGVjICpyZWZzcGVjLCBjb25zdCBjaGFyICpyZWZsb2cpCnsKCXN0cnVjdCByZWYgKmxvY2FsX3JlZnMgPSBOVUxMOwoJc3RydWN0IHJlZiAqKnRhaWwgPSAmbG9jYWxfcmVmczsKCXN0cnVjdCByZWYgKnI7CgoJZ2V0X2ZldGNoX21hcChyZWZzLCByZWZzcGVjLCAmdGFpbCwgMCk7CglpZiAoIW9wdGlvbl9taXJyb3IpCgkJZ2V0X2ZldGNoX21hcChyZWZzLCB0YWdfcmVmc3BlYywgJnRhaWwsIDApOwoKCWZvciAociA9IGxvY2FsX3JlZnM7IHI7IHIgPSByLT5uZXh0KQoJCWFkZF9leHRyYV9yZWYoci0+cGVlcl9yZWYtPm5hbWUsIHItPm9sZF9zaGExLCAwKTsKCglwYWNrX3JlZnMoUEFDS19SRUZTX0FMTCk7CgljbGVhcl9leHRyYV9yZWZzKCk7CgoJcmV0dXJuIGxvY2FsX3JlZnM7Cn0KCmludCBjbWRfY2xvbmUoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCWludCBpc19idW5kbGUgPSAwOwoJc3RydWN0IHN0YXQgYnVmOwoJY29uc3QgY2hhciAqcmVwb19uYW1lLCAqcmVwbywgKndvcmtfdHJlZSwgKmdpdF9kaXI7CgljaGFyICpwYXRoLCAqZGlyOwoJaW50IGRlc3RfZXhpc3RzOwoJY29uc3Qgc3RydWN0IHJlZiAqcmVmcywgKmhlYWRfcG9pbnRzX2F0LCAqcmVtb3RlX2hlYWQsICptYXBwZWRfcmVmczsKCXN0cnVjdCBzdHJidWYga2V5ID0gU1RSQlVGX0lOSVQsIHZhbHVlID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGJyYW5jaF90b3AgPSBTVFJCVUZfSU5JVCwgcmVmbG9nX21zZyA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0ID0gTlVMTDsKCWNoYXIgKnNyY19yZWZfcHJlZml4ID0gInJlZnMvaGVhZHMvIjsKCWludCBlcnIgPSAwOwoKCXN0cnVjdCByZWZzcGVjICpyZWZzcGVjOwoJY29uc3QgY2hhciAqZmV0Y2hfcGF0dGVybjsKCglqdW5rX3BpZCA9IGdldHBpZCgpOwoKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIGJ1aWx0aW5fY2xvbmVfb3B0aW9ucywKCQkJICAgICBidWlsdGluX2Nsb25lX3VzYWdlLCAwKTsKCglpZiAoYXJnYyA9PSAwKQoJCWRpZSgiWW91IG11c3Qgc3BlY2lmeSBhIHJlcG9zaXRvcnkgdG8gY2xvbmUuIik7CgoJaWYgKG9wdGlvbl9taXJyb3IpCgkJb3B0aW9uX2JhcmUgPSAxOwoKCWlmIChvcHRpb25fYmFyZSkgewoJCWlmIChvcHRpb25fb3JpZ2luKQoJCQlkaWUoIi0tYmFyZSBhbmQgLS1vcmlnaW4gJXMgb3B0aW9ucyBhcmUgaW5jb21wYXRpYmxlLiIsCgkJCSAgICBvcHRpb25fb3JpZ2luKTsKCQlvcHRpb25fbm9fY2hlY2tvdXQgPSAxOwoJfQoKCWlmICghb3B0aW9uX29yaWdpbikKCQlvcHRpb25fb3JpZ2luID0gIm9yaWdpbiI7CgoJcmVwb19uYW1lID0gYXJndlswXTsKCglwYXRoID0gZ2V0X3JlcG9fcGF0aChyZXBvX25hbWUsICZpc19idW5kbGUpOwoJaWYgKHBhdGgpCgkJcmVwbyA9IHhzdHJkdXAobWFrZV9ub25yZWxhdGl2ZV9wYXRoKHJlcG9fbmFtZSkpOwoJZWxzZSBpZiAoIXN0cmNocihyZXBvX25hbWUsICc6JykpCgkJcmVwbyA9IHhzdHJkdXAobWFrZV9hYnNvbHV0ZV9wYXRoKHJlcG9fbmFtZSkpOwoJZWxzZQoJCXJlcG8gPSByZXBvX25hbWU7CgoJaWYgKGFyZ2MgPT0gMikKCQlkaXIgPSB4c3RyZHVwKGFyZ3ZbMV0pOwoJZWxzZQoJCWRpciA9IGd1ZXNzX2Rpcl9uYW1lKHJlcG9fbmFtZSwgaXNfYnVuZGxlLCBvcHRpb25fYmFyZSk7CglzdHJpcF90cmFpbGluZ19zbGFzaGVzKGRpcik7CgoJZGVzdF9leGlzdHMgPSAhc3RhdChkaXIsICZidWYpOwoJaWYgKGRlc3RfZXhpc3RzICYmICFpc19lbXB0eV9kaXIoZGlyKSkKCQlkaWUoImRlc3RpbmF0aW9uIHBhdGggJyVzJyBhbHJlYWR5IGV4aXN0cyBhbmQgaXMgbm90ICIKCQkJImFuIGVtcHR5IGRpcmVjdG9yeS4iLCBkaXIpOwoKCXN0cmJ1Zl9hZGRmKCZyZWZsb2dfbXNnLCAiY2xvbmU6IGZyb20gJXMiLCByZXBvKTsKCglpZiAob3B0aW9uX2JhcmUpCgkJd29ya190cmVlID0gTlVMTDsKCWVsc2UgewoJCXdvcmtfdHJlZSA9IGdldGVudigiR0lUX1dPUktfVFJFRSIpOwoJCWlmICh3b3JrX3RyZWUgJiYgIXN0YXQod29ya190cmVlLCAmYnVmKSkKCQkJZGllKCJ3b3JraW5nIHRyZWUgJyVzJyBhbHJlYWR5IGV4aXN0cy4iLCB3b3JrX3RyZWUpOwoJfQoKCWlmIChvcHRpb25fYmFyZSB8fCB3b3JrX3RyZWUpCgkJZ2l0X2RpciA9IHhzdHJkdXAoZGlyKTsKCWVsc2UgewoJCXdvcmtfdHJlZSA9IGRpcjsKCQlnaXRfZGlyID0geHN0cmR1cChta3BhdGgoIiVzLy5naXQiLCBkaXIpKTsKCX0KCglpZiAoIW9wdGlvbl9iYXJlKSB7CgkJanVua193b3JrX3RyZWUgPSB3b3JrX3RyZWU7CgkJaWYgKHNhZmVfY3JlYXRlX2xlYWRpbmdfZGlyZWN0b3JpZXNfY29uc3Qod29ya190cmVlKSA8IDApCgkJCWRpZSgiY291bGQgbm90IGNyZWF0ZSBsZWFkaW5nIGRpcmVjdG9yaWVzIG9mICclcyc6ICVzIiwKCQkJCQl3b3JrX3RyZWUsIHN0cmVycm9yKGVycm5vKSk7CgkJaWYgKCFkZXN0X2V4aXN0cyAmJiBta2Rpcih3b3JrX3RyZWUsIDA3NTUpKQoJCQlkaWUoImNvdWxkIG5vdCBjcmVhdGUgd29yayB0cmVlIGRpciAnJXMnOiAlcy4iLAoJCQkJCXdvcmtfdHJlZSwgc3RyZXJyb3IoZXJybm8pKTsKCQlzZXRfZ2l0X3dvcmtfdHJlZSh3b3JrX3RyZWUpOwoJfQoJanVua19naXRfZGlyID0gZ2l0X2RpcjsKCWF0ZXhpdChyZW1vdmVfanVuayk7CglzaWdjaGFpbl9wdXNoX2NvbW1vbihyZW1vdmVfanVua19vbl9zaWduYWwpOwoKCXNldGVudihDT05GSUdfRU5WSVJPTk1FTlQsIHhzdHJkdXAobWtwYXRoKCIlcy9jb25maWciLCBnaXRfZGlyKSksIDEpOwoKCWlmIChzYWZlX2NyZWF0ZV9sZWFkaW5nX2RpcmVjdG9yaWVzX2NvbnN0KGdpdF9kaXIpIDwgMCkKCQlkaWUoImNvdWxkIG5vdCBjcmVhdGUgbGVhZGluZyBkaXJlY3RvcmllcyBvZiAnJXMnIiwgZ2l0X2Rpcik7CglzZXRfZ2l0X2RpcihtYWtlX2Fic29sdXRlX3BhdGgoZ2l0X2RpcikpOwoKCWluaXRfZGIob3B0aW9uX3RlbXBsYXRlLCBvcHRpb25fcXVpZXQgPyBJTklUX0RCX1FVSUVUIDogMCk7CgoJLyoKCSAqIEF0IHRoaXMgcG9pbnQsIHRoZSBjb25maWcgZXhpc3RzLCBzbyB3ZSBkbyBub3QgbmVlZCB0aGUKCSAqIGVudmlyb25tZW50IHZhcmlhYmxlLiAgV2UgYWN0dWFsbHkgbmVlZCB0byB1bnNldCBpdCwgdG9vLCB0bwoJICogcmUtZW5hYmxlIHBhcnNpbmcgb2YgdGhlIGdsb2JhbCBjb25maWdzLgoJICovCgl1bnNldGVudihDT05GSUdfRU5WSVJPTk1FTlQpOwoKCWlmIChvcHRpb25fcmVmZXJlbmNlKQoJCXNldHVwX3JlZmVyZW5jZShnaXRfZGlyKTsKCglnaXRfY29uZmlnKGdpdF9kZWZhdWx0X2NvbmZpZywgTlVMTCk7CgoJaWYgKG9wdGlvbl9iYXJlKSB7CgkJaWYgKG9wdGlvbl9taXJyb3IpCgkJCXNyY19yZWZfcHJlZml4ID0gInJlZnMvIjsKCQlzdHJidWZfYWRkc3RyKCZicmFuY2hfdG9wLCBzcmNfcmVmX3ByZWZpeCk7CgoJCWdpdF9jb25maWdfc2V0KCJjb3JlLmJhcmUiLCAidHJ1ZSIpOwoJfSBlbHNlIHsKCQlzdHJidWZfYWRkZigmYnJhbmNoX3RvcCwgInJlZnMvcmVtb3Rlcy8lcy8iLCBvcHRpb25fb3JpZ2luKTsKCX0KCglzdHJidWZfYWRkZigmdmFsdWUsICIrJXMqOiVzKiIsIHNyY19yZWZfcHJlZml4LCBicmFuY2hfdG9wLmJ1Zik7CgoJaWYgKG9wdGlvbl9taXJyb3IgfHwgIW9wdGlvbl9iYXJlKSB7CgkJLyogQ29uZmlndXJlIHRoZSByZW1vdGUgKi8KCQlzdHJidWZfYWRkZigma2V5LCAicmVtb3RlLiVzLmZldGNoIiwgb3B0aW9uX29yaWdpbik7CgkJZ2l0X2NvbmZpZ19zZXRfbXVsdGl2YXIoa2V5LmJ1ZiwgdmFsdWUuYnVmLCAiXiQiLCAwKTsKCQlzdHJidWZfcmVzZXQoJmtleSk7CgoJCWlmIChvcHRpb25fbWlycm9yKSB7CgkJCXN0cmJ1Zl9hZGRmKCZrZXksICJyZW1vdGUuJXMubWlycm9yIiwgb3B0aW9uX29yaWdpbik7CgkJCWdpdF9jb25maWdfc2V0KGtleS5idWYsICJ0cnVlIik7CgkJCXN0cmJ1Zl9yZXNldCgma2V5KTsKCQl9CgoJCXN0cmJ1Zl9hZGRmKCZrZXksICJyZW1vdGUuJXMudXJsIiwgb3B0aW9uX29yaWdpbik7CgkJZ2l0X2NvbmZpZ19zZXQoa2V5LmJ1ZiwgcmVwbyk7CgkJc3RyYnVmX3Jlc2V0KCZrZXkpOwoJfQoKCWZldGNoX3BhdHRlcm4gPSB2YWx1ZS5idWY7CglyZWZzcGVjID0gcGFyc2VfZmV0Y2hfcmVmc3BlYygxLCAmZmV0Y2hfcGF0dGVybik7CgoJc3RyYnVmX3Jlc2V0KCZ2YWx1ZSk7CgoJaWYgKHBhdGggJiYgIWlzX2J1bmRsZSkKCQlyZWZzID0gY2xvbmVfbG9jYWwocGF0aCwgZ2l0X2Rpcik7CgllbHNlIHsKCQlzdHJ1Y3QgcmVtb3RlICpyZW1vdGUgPSByZW1vdGVfZ2V0KGFyZ3ZbMF0pOwoJCXRyYW5zcG9ydCA9IHRyYW5zcG9ydF9nZXQocmVtb3RlLCByZW1vdGUtPnVybFswXSk7CgoJCWlmICghdHJhbnNwb3J0LT5nZXRfcmVmc19saXN0IHx8ICF0cmFuc3BvcnQtPmZldGNoKQoJCQlkaWUoIkRvbid0IGtub3cgaG93IHRvIGNsb25lICVzIiwgdHJhbnNwb3J0LT51cmwpOwoKCQl0cmFuc3BvcnRfc2V0X29wdGlvbih0cmFuc3BvcnQsIFRSQU5TX09QVF9LRUVQLCAieWVzIik7CgoJCWlmIChvcHRpb25fZGVwdGgpCgkJCXRyYW5zcG9ydF9zZXRfb3B0aW9uKHRyYW5zcG9ydCwgVFJBTlNfT1BUX0RFUFRILAoJCQkJCSAgICAgb3B0aW9uX2RlcHRoKTsKCgkJaWYgKG9wdGlvbl9xdWlldCkKCQkJdHJhbnNwb3J0LT52ZXJib3NlID0gLTE7CgkJZWxzZSBpZiAob3B0aW9uX3ZlcmJvc2UpCgkJCXRyYW5zcG9ydC0+cHJvZ3Jlc3MgPSAxOwoKCQlpZiAob3B0aW9uX3VwbG9hZF9wYWNrKQoJCQl0cmFuc3BvcnRfc2V0X29wdGlvbih0cmFuc3BvcnQsIFRSQU5TX09QVF9VUExPQURQQUNLLAoJCQkJCSAgICAgb3B0aW9uX3VwbG9hZF9wYWNrKTsKCgkJcmVmcyA9IHRyYW5zcG9ydF9nZXRfcmVtb3RlX3JlZnModHJhbnNwb3J0KTsKCQlpZihyZWZzKQoJCQl0cmFuc3BvcnRfZmV0Y2hfcmVmcyh0cmFuc3BvcnQsIHJlZnMpOwoJfQoKCWlmIChyZWZzKSB7CgkJY2xlYXJfZXh0cmFfcmVmcygpOwoKCQltYXBwZWRfcmVmcyA9IHdyaXRlX3JlbW90ZV9yZWZzKHJlZnMsIHJlZnNwZWMsIHJlZmxvZ19tc2cuYnVmKTsKCgkJcmVtb3RlX2hlYWQgPSBmaW5kX3JlZl9ieV9uYW1lKHJlZnMsICJIRUFEIik7CgkJaGVhZF9wb2ludHNfYXQgPSBndWVzc19yZW1vdGVfaGVhZChyZW1vdGVfaGVhZCwgbWFwcGVkX3JlZnMsIDApOwoJfQoJZWxzZSB7CgkJd2FybmluZygiWW91IGFwcGVhciB0byBoYXZlIGNsb25lZCBhbiBlbXB0eSByZXBvc2l0b3J5LiIpOwoJCWhlYWRfcG9pbnRzX2F0ID0gTlVMTDsKCQlyZW1vdGVfaGVhZCA9IE5VTEw7CgkJb3B0aW9uX25vX2NoZWNrb3V0ID0gMTsKCQlpZiAoIW9wdGlvbl9iYXJlKQoJCQlpbnN0YWxsX2JyYW5jaF9jb25maWcoMCwgIm1hc3RlciIsIG9wdGlvbl9vcmlnaW4sCgkJCQkJICAgICAgInJlZnMvaGVhZHMvbWFzdGVyIik7Cgl9CgoJaWYgKGhlYWRfcG9pbnRzX2F0KSB7CgkJLyogTG9jYWwgZGVmYXVsdCBicmFuY2ggbGluayAqLwoJCWNyZWF0ZV9zeW1yZWYoIkhFQUQiLCBoZWFkX3BvaW50c19hdC0+bmFtZSwgTlVMTCk7CgoJCWlmICghb3B0aW9uX2JhcmUpIHsKCQkJc3RydWN0IHN0cmJ1ZiBoZWFkX3JlZiA9IFNUUkJVRl9JTklUOwoJCQljb25zdCBjaGFyICpoZWFkID0gaGVhZF9wb2ludHNfYXQtPm5hbWU7CgoJCQlpZiAoIXByZWZpeGNtcChoZWFkLCAicmVmcy9oZWFkcy8iKSkKCQkJCWhlYWQgKz0gMTE7CgoJCQkvKiBTZXQgdXAgdGhlIGluaXRpYWwgbG9jYWwgYnJhbmNoICovCgoJCQkvKiBMb2NhbCBicmFuY2ggaW5pdGlhbCB2YWx1ZSAqLwoJCQl1cGRhdGVfcmVmKHJlZmxvZ19tc2cuYnVmLCAiSEVBRCIsCgkJCQkgICBoZWFkX3BvaW50c19hdC0+b2xkX3NoYTEsCgkJCQkgICBOVUxMLCAwLCBESUVfT05fRVJSKTsKCgkJCXN0cmJ1Zl9hZGRzdHIoJmhlYWRfcmVmLCBicmFuY2hfdG9wLmJ1Zik7CgkJCXN0cmJ1Zl9hZGRzdHIoJmhlYWRfcmVmLCAiSEVBRCIpOwoKCQkJLyogUmVtb3RlIGJyYW5jaCBsaW5rICovCgkJCWNyZWF0ZV9zeW1yZWYoaGVhZF9yZWYuYnVmLAoJCQkJICAgICAgaGVhZF9wb2ludHNfYXQtPnBlZXJfcmVmLT5uYW1lLAoJCQkJICAgICAgcmVmbG9nX21zZy5idWYpOwoKCQkJaW5zdGFsbF9icmFuY2hfY29uZmlnKDAsIGhlYWQsIG9wdGlvbl9vcmlnaW4sCgkJCQkJICAgICAgaGVhZF9wb2ludHNfYXQtPm5hbWUpOwoJCX0KCX0gZWxzZSBpZiAocmVtb3RlX2hlYWQpIHsKCQkvKiBTb3VyY2UgaGFkIGRldGFjaGVkIEhFQUQgcG9pbnRpbmcgc29tZXdoZXJlLiAqLwoJCWlmICghb3B0aW9uX2JhcmUpCgkJCXVwZGF0ZV9yZWYocmVmbG9nX21zZy5idWYsICJIRUFEIiwKCQkJCSAgIHJlbW90ZV9oZWFkLT5vbGRfc2hhMSwKCQkJCSAgIE5VTEwsIFJFRl9OT0RFUkVGLCBESUVfT05fRVJSKTsKCX0gZWxzZSB7CgkJLyogTm90aGluZyB0byBjaGVja291dCBvdXQgKi8KCQlpZiAoIW9wdGlvbl9ub19jaGVja291dCkKCQkJd2FybmluZygicmVtb3RlIEhFQUQgcmVmZXJzIHRvIG5vbmV4aXN0ZW50IHJlZiwgIgoJCQkJInVuYWJsZSB0byBjaGVja291dC5cbiIpOwoJCW9wdGlvbl9ub19jaGVja291dCA9IDE7Cgl9CgoJaWYgKHRyYW5zcG9ydCkKCQl0cmFuc3BvcnRfdW5sb2NrX3BhY2sodHJhbnNwb3J0KTsKCglpZiAoIW9wdGlvbl9ub19jaGVja291dCkgewoJCXN0cnVjdCBsb2NrX2ZpbGUgKmxvY2tfZmlsZSA9IHhjYWxsb2MoMSwgc2l6ZW9mKHN0cnVjdCBsb2NrX2ZpbGUpKTsKCQlzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgb3B0czsKCQlzdHJ1Y3QgdHJlZSAqdHJlZTsKCQlzdHJ1Y3QgdHJlZV9kZXNjIHQ7CgkJaW50IGZkOwoKCQkvKiBXZSBuZWVkIHRvIGJlIGluIHRoZSBuZXcgd29yayB0cmVlIGZvciB0aGUgY2hlY2tvdXQgKi8KCQlzZXR1cF93b3JrX3RyZWUoKTsKCgkJZmQgPSBob2xkX2xvY2tlZF9pbmRleChsb2NrX2ZpbGUsIDEpOwoKCQltZW1zZXQoJm9wdHMsIDAsIHNpemVvZiBvcHRzKTsKCQlvcHRzLnVwZGF0ZSA9IDE7CgkJb3B0cy5tZXJnZSA9IDE7CgkJb3B0cy5mbiA9IG9uZXdheV9tZXJnZTsKCQlvcHRzLnZlcmJvc2VfdXBkYXRlID0gIW9wdGlvbl9xdWlldDsKCQlvcHRzLnNyY19pbmRleCA9ICZ0aGVfaW5kZXg7CgkJb3B0cy5kc3RfaW5kZXggPSAmdGhlX2luZGV4OwoKCQl0cmVlID0gcGFyc2VfdHJlZV9pbmRpcmVjdChyZW1vdGVfaGVhZC0+b2xkX3NoYTEpOwoJCXBhcnNlX3RyZWUodHJlZSk7CgkJaW5pdF90cmVlX2Rlc2MoJnQsIHRyZWUtPmJ1ZmZlciwgdHJlZS0+c2l6ZSk7CgkJdW5wYWNrX3RyZWVzKDEsICZ0LCAmb3B0cyk7CgoJCWlmICh3cml0ZV9jYWNoZShmZCwgYWN0aXZlX2NhY2hlLCBhY3RpdmVfbnIpIHx8CgkJICAgIGNvbW1pdF9sb2NrZWRfaW5kZXgobG9ja19maWxlKSkKCQkJZGllKCJ1bmFibGUgdG8gd3JpdGUgbmV3IGluZGV4IGZpbGUiKTsKCgkJZXJyIHw9IHJ1bl9ob29rKE5VTEwsICJwb3N0LWNoZWNrb3V0Iiwgc2hhMV90b19oZXgobnVsbF9zaGExKSwKCQkJCXNoYTFfdG9faGV4KHJlbW90ZV9oZWFkLT5vbGRfc2hhMSksICIxIiwgTlVMTCk7Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJnJlZmxvZ19tc2cpOwoJc3RyYnVmX3JlbGVhc2UoJmJyYW5jaF90b3ApOwoJc3RyYnVmX3JlbGVhc2UoJmtleSk7CglzdHJidWZfcmVsZWFzZSgmdmFsdWUpOwoJanVua19waWQgPSAwOwoJcmV0dXJuIGVycjsKfQo=",
    "text": "/*\n * Builtin \"git clone\"\n *\n * Copyright (c) 2007 Kristian H\u00f8gsberg <krh@redhat.com>,\n *\t\t 2008 Daniel Barkalow <barkalow@iabervon.org>\n * Based on git-commit.sh by Junio C Hamano and Linus Torvalds\n *\n * Clone a repository into a different directory that does not yet exist.\n */\n\n#include \"cache.h\"\n#include \"parse-options.h\"\n#include \"fetch-pack.h\"\n#include \"refs.h\"\n#include \"tree.h\"\n#include \"tree-walk.h\"\n#include \"unpack-trees.h\"\n#include \"transport.h\"\n#include \"strbuf.h\"\n#include \"dir.h\"\n#include \"pack-refs.h\"\n#include \"sigchain.h\"\n#include \"branch.h\"\n#include \"remote.h\"\n#include \"run-command.h\"\n\n/*\n * Overall FIXMEs:\n *  - respect DB_ENVIRONMENT for .git/objects.\n *\n * Implementation notes:\n *  - dropping use-separate-remote and no-separate-remote compatibility\n *\n */\nstatic const char * const builtin_clone_usage[] = {\n\t\"git clone [options] [--] <repo> [<dir>]\",\n\tNULL\n};\n\nstatic int option_quiet, option_no_checkout, option_bare, option_mirror;\nstatic int option_local, option_no_hardlinks, option_shared;\nstatic char *option_template, *option_reference, *option_depth;\nstatic char *option_origin = NULL;\nstatic char *option_upload_pack = \"git-upload-pack\";\nstatic int option_verbose;\n\nstatic struct option builtin_clone_options[] = {\n\tOPT__QUIET(&option_quiet),\n\tOPT__VERBOSE(&option_verbose),\n\tOPT_BOOLEAN('n', \"no-checkout\", &option_no_checkout,\n\t\t    \"don't create a checkout\"),\n\tOPT_BOOLEAN(0, \"bare\", &option_bare, \"create a bare repository\"),\n\tOPT_BOOLEAN(0, \"naked\", &option_bare, \"create a bare repository\"),\n\tOPT_BOOLEAN(0, \"mirror\", &option_mirror,\n\t\t    \"create a mirror repository (implies bare)\"),\n\tOPT_BOOLEAN('l', \"local\", &option_local,\n\t\t    \"to clone from a local repository\"),\n\tOPT_BOOLEAN(0, \"no-hardlinks\", &option_no_hardlinks,\n\t\t    \"don't use local hardlinks, always copy\"),\n\tOPT_BOOLEAN('s', \"shared\", &option_shared,\n\t\t    \"setup as shared repository\"),\n\tOPT_STRING(0, \"template\", &option_template, \"path\",\n\t\t   \"path the template repository\"),\n\tOPT_STRING(0, \"reference\", &option_reference, \"repo\",\n\t\t   \"reference repository\"),\n\tOPT_STRING('o', \"origin\", &option_origin, \"branch\",\n\t\t   \"use <branch> instead of 'origin' to track upstream\"),\n\tOPT_STRING('u', \"upload-pack\", &option_upload_pack, \"path\",\n\t\t   \"path to git-upload-pack on the remote\"),\n\tOPT_STRING(0, \"depth\", &option_depth, \"depth\",\n\t\t    \"create a shallow clone of that depth\"),\n\n\tOPT_END()\n};\n\nstatic char *get_repo_path(const char *repo, int *is_bundle)\n{\n\tstatic char *suffix[] = { \"/.git\", \".git\", \"\" };\n\tstatic char *bundle_suffix[] = { \".bundle\", \"\" };\n\tstruct stat st;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(suffix); i++) {\n\t\tconst char *path;\n\t\tpath = mkpath(\"%s%s\", repo, suffix[i]);\n\t\tif (is_directory(path)) {\n\t\t\t*is_bundle = 0;\n\t\t\treturn xstrdup(make_nonrelative_path(path));\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(bundle_suffix); i++) {\n\t\tconst char *path;\n\t\tpath = mkpath(\"%s%s\", repo, bundle_suffix[i]);\n\t\tif (!stat(path, &st) && S_ISREG(st.st_mode)) {\n\t\t\t*is_bundle = 1;\n\t\t\treturn xstrdup(make_nonrelative_path(path));\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic char *guess_dir_name(const char *repo, int is_bundle, int is_bare)\n{\n\tconst char *end = repo + strlen(repo), *start;\n\n\t/*\n\t * Strip trailing slashes and /.git\n\t */\n\twhile (repo < end && is_dir_sep(end[-1]))\n\t\tend--;\n\tif (end - repo > 5 && is_dir_sep(end[-5]) &&\n\t    !strncmp(end - 4, \".git\", 4)) {\n\t\tend -= 5;\n\t\twhile (repo < end && is_dir_sep(end[-1]))\n\t\t\tend--;\n\t}\n\n\t/*\n\t * Find last component, but be prepared that repo could have\n\t * the form  \"remote.example.com:foo.git\", i.e. no slash\n\t * in the directory part.\n\t */\n\tstart = end;\n\twhile (repo < start && !is_dir_sep(start[-1]) && start[-1] != ':')\n\t\tstart--;\n\n\t/*\n\t * Strip .{bundle,git}.\n\t */\n\tif (is_bundle) {\n\t\tif (end - start > 7 && !strncmp(end - 7, \".bundle\", 7))\n\t\t\tend -= 7;\n\t} else {\n\t\tif (end - start > 4 && !strncmp(end - 4, \".git\", 4))\n\t\t\tend -= 4;\n\t}\n\n\tif (is_bare) {\n\t\tstruct strbuf result = STRBUF_INIT;\n\t\tstrbuf_addf(&result, \"%.*s.git\", (int)(end - start), start);\n\t\treturn strbuf_detach(&result, 0);\n\t}\n\n\treturn xstrndup(start, end - start);\n}\n\nstatic void strip_trailing_slashes(char *dir)\n{\n\tchar *end = dir + strlen(dir);\n\n\twhile (dir < end - 1 && is_dir_sep(end[-1]))\n\t\tend--;\n\t*end = '\\0';\n}\n\nstatic void setup_reference(const char *repo)\n{\n\tconst char *ref_git;\n\tchar *ref_git_copy;\n\n\tstruct remote *remote;\n\tstruct transport *transport;\n\tconst struct ref *extra;\n\n\tref_git = make_absolute_path(option_reference);\n\n\tif (is_directory(mkpath(\"%s/.git/objects\", ref_git)))\n\t\tref_git = mkpath(\"%s/.git\", ref_git);\n\telse if (!is_directory(mkpath(\"%s/objects\", ref_git)))\n\t\tdie(\"reference repository '%s' is not a local directory.\",\n\t\t    option_reference);\n\n\tref_git_copy = xstrdup(ref_git);\n\n\tadd_to_alternates_file(ref_git_copy);\n\n\tremote = remote_get(ref_git_copy);\n\ttransport = transport_get(remote, ref_git_copy);\n\tfor (extra = transport_get_remote_refs(transport); extra;\n\t     extra = extra->next)\n\t\tadd_extra_ref(extra->name, extra->old_sha1, 0);\n\n\ttransport_disconnect(transport);\n\n\tfree(ref_git_copy);\n}\n\nstatic void copy_or_link_directory(struct strbuf *src, struct strbuf *dest)\n{\n\tstruct dirent *de;\n\tstruct stat buf;\n\tint src_len, dest_len;\n\tDIR *dir;\n\n\tdir = opendir(src->buf);\n\tif (!dir)\n\t\tdie(\"failed to open %s\", src->buf);\n\n\tif (mkdir(dest->buf, 0777)) {\n\t\tif (errno != EEXIST)\n\t\t\tdie(\"failed to create directory %s\", dest->buf);\n\t\telse if (stat(dest->buf, &buf))\n\t\t\tdie(\"failed to stat %s\", dest->buf);\n\t\telse if (!S_ISDIR(buf.st_mode))\n\t\t\tdie(\"%s exists and is not a directory\", dest->buf);\n\t}\n\n\tstrbuf_addch(src, '/');\n\tsrc_len = src->len;\n\tstrbuf_addch(dest, '/');\n\tdest_len = dest->len;\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tstrbuf_setlen(src, src_len);\n\t\tstrbuf_addstr(src, de->d_name);\n\t\tstrbuf_setlen(dest, dest_len);\n\t\tstrbuf_addstr(dest, de->d_name);\n\t\tif (stat(src->buf, &buf)) {\n\t\t\twarning (\"failed to stat %s\\n\", src->buf);\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(buf.st_mode)) {\n\t\t\tif (de->d_name[0] != '.')\n\t\t\t\tcopy_or_link_directory(src, dest);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlink(dest->buf) && errno != ENOENT)\n\t\t\tdie(\"failed to unlink %s\", dest->buf);\n\t\tif (!option_no_hardlinks) {\n\t\t\tif (!link(src->buf, dest->buf))\n\t\t\t\tcontinue;\n\t\t\tif (option_local)\n\t\t\t\tdie(\"failed to create link %s\", dest->buf);\n\t\t\toption_no_hardlinks = 1;\n\t\t}\n\t\tif (copy_file(dest->buf, src->buf, 0666))\n\t\t\tdie(\"failed to copy file to %s\", dest->buf);\n\t}\n\tclosedir(dir);\n}\n\nstatic const struct ref *clone_local(const char *src_repo,\n\t\t\t\t     const char *dest_repo)\n{\n\tconst struct ref *ret;\n\tstruct strbuf src = STRBUF_INIT;\n\tstruct strbuf dest = STRBUF_INIT;\n\tstruct remote *remote;\n\tstruct transport *transport;\n\n\tif (option_shared)\n\t\tadd_to_alternates_file(src_repo);\n\telse {\n\t\tstrbuf_addf(&src, \"%s/objects\", src_repo);\n\t\tstrbuf_addf(&dest, \"%s/objects\", dest_repo);\n\t\tcopy_or_link_directory(&src, &dest);\n\t\tstrbuf_release(&src);\n\t\tstrbuf_release(&dest);\n\t}\n\n\tremote = remote_get(src_repo);\n\ttransport = transport_get(remote, src_repo);\n\tret = transport_get_remote_refs(transport);\n\ttransport_disconnect(transport);\n\treturn ret;\n}\n\nstatic const char *junk_work_tree;\nstatic const char *junk_git_dir;\npid_t junk_pid;\n\nstatic void remove_junk(void)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tif (getpid() != junk_pid)\n\t\treturn;\n\tif (junk_git_dir) {\n\t\tstrbuf_addstr(&sb, junk_git_dir);\n\t\tremove_dir_recursively(&sb, 0);\n\t\tstrbuf_reset(&sb);\n\t}\n\tif (junk_work_tree) {\n\t\tstrbuf_addstr(&sb, junk_work_tree);\n\t\tremove_dir_recursively(&sb, 0);\n\t\tstrbuf_reset(&sb);\n\t}\n}\n\nstatic void remove_junk_on_signal(int signo)\n{\n\tremove_junk();\n\tsigchain_pop(signo);\n\traise(signo);\n}\n\nstatic struct ref *write_remote_refs(const struct ref *refs,\n\t\tstruct refspec *refspec, const char *reflog)\n{\n\tstruct ref *local_refs = NULL;\n\tstruct ref **tail = &local_refs;\n\tstruct ref *r;\n\n\tget_fetch_map(refs, refspec, &tail, 0);\n\tif (!option_mirror)\n\t\tget_fetch_map(refs, tag_refspec, &tail, 0);\n\n\tfor (r = local_refs; r; r = r->next)\n\t\tadd_extra_ref(r->peer_ref->name, r->old_sha1, 0);\n\n\tpack_refs(PACK_REFS_ALL);\n\tclear_extra_refs();\n\n\treturn local_refs;\n}\n\nint cmd_clone(int argc, const char **argv, const char *prefix)\n{\n\tint is_bundle = 0;\n\tstruct stat buf;\n\tconst char *repo_name, *repo, *work_tree, *git_dir;\n\tchar *path, *dir;\n\tint dest_exists;\n\tconst struct ref *refs, *head_points_at, *remote_head, *mapped_refs;\n\tstruct strbuf key = STRBUF_INIT, value = STRBUF_INIT;\n\tstruct strbuf branch_top = STRBUF_INIT, reflog_msg = STRBUF_INIT;\n\tstruct transport *transport = NULL;\n\tchar *src_ref_prefix = \"refs/heads/\";\n\tint err = 0;\n\n\tstruct refspec *refspec;\n\tconst char *fetch_pattern;\n\n\tjunk_pid = getpid();\n\n\targc = parse_options(argc, argv, builtin_clone_options,\n\t\t\t     builtin_clone_usage, 0);\n\n\tif (argc == 0)\n\t\tdie(\"You must specify a repository to clone.\");\n\n\tif (option_mirror)\n\t\toption_bare = 1;\n\n\tif (option_bare) {\n\t\tif (option_origin)\n\t\t\tdie(\"--bare and --origin %s options are incompatible.\",\n\t\t\t    option_origin);\n\t\toption_no_checkout = 1;\n\t}\n\n\tif (!option_origin)\n\t\toption_origin = \"origin\";\n\n\trepo_name = argv[0];\n\n\tpath = get_repo_path(repo_name, &is_bundle);\n\tif (path)\n\t\trepo = xstrdup(make_nonrelative_path(repo_name));\n\telse if (!strchr(repo_name, ':'))\n\t\trepo = xstrdup(make_absolute_path(repo_name));\n\telse\n\t\trepo = repo_name;\n\n\tif (argc == 2)\n\t\tdir = xstrdup(argv[1]);\n\telse\n\t\tdir = guess_dir_name(repo_name, is_bundle, option_bare);\n\tstrip_trailing_slashes(dir);\n\n\tdest_exists = !stat(dir, &buf);\n\tif (dest_exists && !is_empty_dir(dir))\n\t\tdie(\"destination path '%s' already exists and is not \"\n\t\t\t\"an empty directory.\", dir);\n\n\tstrbuf_addf(&reflog_msg, \"clone: from %s\", repo);\n\n\tif (option_bare)\n\t\twork_tree = NULL;\n\telse {\n\t\twork_tree = getenv(\"GIT_WORK_TREE\");\n\t\tif (work_tree && !stat(work_tree, &buf))\n\t\t\tdie(\"working tree '%s' already exists.\", work_tree);\n\t}\n\n\tif (option_bare || work_tree)\n\t\tgit_dir = xstrdup(dir);\n\telse {\n\t\twork_tree = dir;\n\t\tgit_dir = xstrdup(mkpath(\"%s/.git\", dir));\n\t}\n\n\tif (!option_bare) {\n\t\tjunk_work_tree = work_tree;\n\t\tif (safe_create_leading_directories_const(work_tree) < 0)\n\t\t\tdie(\"could not create leading directories of '%s': %s\",\n\t\t\t\t\twork_tree, strerror(errno));\n\t\tif (!dest_exists && mkdir(work_tree, 0755))\n\t\t\tdie(\"could not create work tree dir '%s': %s.\",\n\t\t\t\t\twork_tree, strerror(errno));\n\t\tset_git_work_tree(work_tree);\n\t}\n\tjunk_git_dir = git_dir;\n\tatexit(remove_junk);\n\tsigchain_push_common(remove_junk_on_signal);\n\n\tsetenv(CONFIG_ENVIRONMENT, xstrdup(mkpath(\"%s/config\", git_dir)), 1);\n\n\tif (safe_create_leading_directories_const(git_dir) < 0)\n\t\tdie(\"could not create leading directories of '%s'\", git_dir);\n\tset_git_dir(make_absolute_path(git_dir));\n\n\tinit_db(option_template, option_quiet ? INIT_DB_QUIET : 0);\n\n\t/*\n\t * At this point, the config exists, so we do not need the\n\t * environment variable.  We actually need to unset it, too, to\n\t * re-enable parsing of the global configs.\n\t */\n\tunsetenv(CONFIG_ENVIRONMENT);\n\n\tif (option_reference)\n\t\tsetup_reference(git_dir);\n\n\tgit_config(git_default_config, NULL);\n\n\tif (option_bare) {\n\t\tif (option_mirror)\n\t\t\tsrc_ref_prefix = \"refs/\";\n\t\tstrbuf_addstr(&branch_top, src_ref_prefix);\n\n\t\tgit_config_set(\"core.bare\", \"true\");\n\t} else {\n\t\tstrbuf_addf(&branch_top, \"refs/remotes/%s/\", option_origin);\n\t}\n\n\tstrbuf_addf(&value, \"+%s*:%s*\", src_ref_prefix, branch_top.buf);\n\n\tif (option_mirror || !option_bare) {\n\t\t/* Configure the remote */\n\t\tstrbuf_addf(&key, \"remote.%s.fetch\", option_origin);\n\t\tgit_config_set_multivar(key.buf, value.buf, \"^$\", 0);\n\t\tstrbuf_reset(&key);\n\n\t\tif (option_mirror) {\n\t\t\tstrbuf_addf(&key, \"remote.%s.mirror\", option_origin);\n\t\t\tgit_config_set(key.buf, \"true\");\n\t\t\tstrbuf_reset(&key);\n\t\t}\n\n\t\tstrbuf_addf(&key, \"remote.%s.url\", option_origin);\n\t\tgit_config_set(key.buf, repo);\n\t\tstrbuf_reset(&key);\n\t}\n\n\tfetch_pattern = value.buf;\n\trefspec = parse_fetch_refspec(1, &fetch_pattern);\n\n\tstrbuf_reset(&value);\n\n\tif (path && !is_bundle)\n\t\trefs = clone_local(path, git_dir);\n\telse {\n\t\tstruct remote *remote = remote_get(argv[0]);\n\t\ttransport = transport_get(remote, remote->url[0]);\n\n\t\tif (!transport->get_refs_list || !transport->fetch)\n\t\t\tdie(\"Don't know how to clone %s\", transport->url);\n\n\t\ttransport_set_option(transport, TRANS_OPT_KEEP, \"yes\");\n\n\t\tif (option_depth)\n\t\t\ttransport_set_option(transport, TRANS_OPT_DEPTH,\n\t\t\t\t\t     option_depth);\n\n\t\tif (option_quiet)\n\t\t\ttransport->verbose = -1;\n\t\telse if (option_verbose)\n\t\t\ttransport->progress = 1;\n\n\t\tif (option_upload_pack)\n\t\t\ttransport_set_option(transport, TRANS_OPT_UPLOADPACK,\n\t\t\t\t\t     option_upload_pack);\n\n\t\trefs = transport_get_remote_refs(transport);\n\t\tif(refs)\n\t\t\ttransport_fetch_refs(transport, refs);\n\t}\n\n\tif (refs) {\n\t\tclear_extra_refs();\n\n\t\tmapped_refs = write_remote_refs(refs, refspec, reflog_msg.buf);\n\n\t\tremote_head = find_ref_by_name(refs, \"HEAD\");\n\t\thead_points_at = guess_remote_head(remote_head, mapped_refs, 0);\n\t}\n\telse {\n\t\twarning(\"You appear to have cloned an empty repository.\");\n\t\thead_points_at = NULL;\n\t\tremote_head = NULL;\n\t\toption_no_checkout = 1;\n\t\tif (!option_bare)\n\t\t\tinstall_branch_config(0, \"master\", option_origin,\n\t\t\t\t\t      \"refs/heads/master\");\n\t}\n\n\tif (head_points_at) {\n\t\t/* Local default branch link */\n\t\tcreate_symref(\"HEAD\", head_points_at->name, NULL);\n\n\t\tif (!option_bare) {\n\t\t\tstruct strbuf head_ref = STRBUF_INIT;\n\t\t\tconst char *head = head_points_at->name;\n\n\t\t\tif (!prefixcmp(head, \"refs/heads/\"))\n\t\t\t\thead += 11;\n\n\t\t\t/* Set up the initial local branch */\n\n\t\t\t/* Local branch initial value */\n\t\t\tupdate_ref(reflog_msg.buf, \"HEAD\",\n\t\t\t\t   head_points_at->old_sha1,\n\t\t\t\t   NULL, 0, DIE_ON_ERR);\n\n\t\t\tstrbuf_addstr(&head_ref, branch_top.buf);\n\t\t\tstrbuf_addstr(&head_ref, \"HEAD\");\n\n\t\t\t/* Remote branch link */\n\t\t\tcreate_symref(head_ref.buf,\n\t\t\t\t      head_points_at->peer_ref->name,\n\t\t\t\t      reflog_msg.buf);\n\n\t\t\tinstall_branch_config(0, head, option_origin,\n\t\t\t\t\t      head_points_at->name);\n\t\t}\n\t} else if (remote_head) {\n\t\t/* Source had detached HEAD pointing somewhere. */\n\t\tif (!option_bare)\n\t\t\tupdate_ref(reflog_msg.buf, \"HEAD\",\n\t\t\t\t   remote_head->old_sha1,\n\t\t\t\t   NULL, REF_NODEREF, DIE_ON_ERR);\n\t} else {\n\t\t/* Nothing to checkout out */\n\t\tif (!option_no_checkout)\n\t\t\twarning(\"remote HEAD refers to nonexistent ref, \"\n\t\t\t\t\"unable to checkout.\\n\");\n\t\toption_no_checkout = 1;\n\t}\n\n\tif (transport)\n\t\ttransport_unlock_pack(transport);\n\n\tif (!option_no_checkout) {\n\t\tstruct lock_file *lock_file = xcalloc(1, sizeof(struct lock_file));\n\t\tstruct unpack_trees_options opts;\n\t\tstruct tree *tree;\n\t\tstruct tree_desc t;\n\t\tint fd;\n\n\t\t/* We need to be in the new work tree for the checkout */\n\t\tsetup_work_tree();\n\n\t\tfd = hold_locked_index(lock_file, 1);\n\n\t\tmemset(&opts, 0, sizeof opts);\n\t\topts.update = 1;\n\t\topts.merge = 1;\n\t\topts.fn = oneway_merge;\n\t\topts.verbose_update = !option_quiet;\n\t\topts.src_index = &the_index;\n\t\topts.dst_index = &the_index;\n\n\t\ttree = parse_tree_indirect(remote_head->old_sha1);\n\t\tparse_tree(tree);\n\t\tinit_tree_desc(&t, tree->buffer, tree->size);\n\t\tunpack_trees(1, &t, &opts);\n\n\t\tif (write_cache(fd, active_cache, active_nr) ||\n\t\t    commit_locked_index(lock_file))\n\t\t\tdie(\"unable to write new index file\");\n\n\t\terr |= run_hook(NULL, \"post-checkout\", sha1_to_hex(null_sha1),\n\t\t\t\tsha1_to_hex(remote_head->old_sha1), \"1\", NULL);\n\t}\n\n\tstrbuf_release(&reflog_msg);\n\tstrbuf_release(&branch_top);\n\tstrbuf_release(&key);\n\tstrbuf_release(&value);\n\tjunk_pid = 0;\n\treturn err;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0031b5f51cd96525a265dab02494700e9d36fce8",
  "sha1_ok": true,
  "size": 15359
}
