{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJzdHJpbmctbGlzdC5oIgoKdm9pZCBzdHJpbmdfbGlzdF9pbml0KHN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCwgaW50IHN0cmR1cF9zdHJpbmdzKQp7CgltZW1zZXQobGlzdCwgMCwgc2l6ZW9mKCpsaXN0KSk7CglsaXN0LT5zdHJkdXBfc3RyaW5ncyA9IHN0cmR1cF9zdHJpbmdzOwp9CgovKiBpZiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgcG9pbnQgdG8gdGhlIGluZGV4IHdoZXJlIHRoZSBlbnRyeSBjb3VsZCBiZQogKiBpbnNlcnRlZCAqLwpzdGF0aWMgaW50IGdldF9lbnRyeV9pbmRleChjb25zdCBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QsIGNvbnN0IGNoYXIgKnN0cmluZywKCQlpbnQgKmV4YWN0X21hdGNoKQp7CglpbnQgbGVmdCA9IC0xLCByaWdodCA9IGxpc3QtPm5yOwoJY29tcGFyZV9zdHJpbmdzX2ZuIGNtcCA9IGxpc3QtPmNtcCA/IGxpc3QtPmNtcCA6IHN0cmNtcDsKCgl3aGlsZSAobGVmdCArIDEgPCByaWdodCkgewoJCWludCBtaWRkbGUgPSAobGVmdCArIHJpZ2h0KSAvIDI7CgkJaW50IGNvbXBhcmUgPSBjbXAoc3RyaW5nLCBsaXN0LT5pdGVtc1ttaWRkbGVdLnN0cmluZyk7CgkJaWYgKGNvbXBhcmUgPCAwKQoJCQlyaWdodCA9IG1pZGRsZTsKCQllbHNlIGlmIChjb21wYXJlID4gMCkKCQkJbGVmdCA9IG1pZGRsZTsKCQllbHNlIHsKCQkJKmV4YWN0X21hdGNoID0gMTsKCQkJcmV0dXJuIG1pZGRsZTsKCQl9Cgl9CgoJKmV4YWN0X21hdGNoID0gMDsKCXJldHVybiByaWdodDsKfQoKLyogcmV0dXJucyAtMS1pbmRleCBpZiBhbHJlYWR5IGV4aXN0cyAqLwpzdGF0aWMgaW50IGFkZF9lbnRyeShpbnQgaW5zZXJ0X2F0LCBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QsIGNvbnN0IGNoYXIgKnN0cmluZykKewoJaW50IGV4YWN0X21hdGNoID0gMDsKCWludCBpbmRleCA9IGluc2VydF9hdCAhPSAtMSA/IGluc2VydF9hdCA6IGdldF9lbnRyeV9pbmRleChsaXN0LCBzdHJpbmcsICZleGFjdF9tYXRjaCk7CgoJaWYgKGV4YWN0X21hdGNoKQoJCXJldHVybiAtMSAtIGluZGV4OwoKCUFMTE9DX0dST1cobGlzdC0+aXRlbXMsIGxpc3QtPm5yKzEsIGxpc3QtPmFsbG9jKTsKCWlmIChpbmRleCA8IGxpc3QtPm5yKQoJCW1lbW1vdmUobGlzdC0+aXRlbXMgKyBpbmRleCArIDEsIGxpc3QtPml0ZW1zICsgaW5kZXgsCgkJCQkobGlzdC0+bnIgLSBpbmRleCkKCQkJCSogc2l6ZW9mKHN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtKSk7CglsaXN0LT5pdGVtc1tpbmRleF0uc3RyaW5nID0gbGlzdC0+c3RyZHVwX3N0cmluZ3MgPwoJCXhzdHJkdXAoc3RyaW5nKSA6IChjaGFyICopc3RyaW5nOwoJbGlzdC0+aXRlbXNbaW5kZXhdLnV0aWwgPSBOVUxMOwoJbGlzdC0+bnIrKzsKCglyZXR1cm4gaW5kZXg7Cn0KCnN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICpzdHJpbmdfbGlzdF9pbnNlcnQoc3RydWN0IHN0cmluZ19saXN0ICpsaXN0LCBjb25zdCBjaGFyICpzdHJpbmcpCnsKCWludCBpbmRleCA9IGFkZF9lbnRyeSgtMSwgbGlzdCwgc3RyaW5nKTsKCglpZiAoaW5kZXggPCAwKQoJCWluZGV4ID0gLTEgLSBpbmRleDsKCglyZXR1cm4gbGlzdC0+aXRlbXMgKyBpbmRleDsKfQoKaW50IHN0cmluZ19saXN0X2hhc19zdHJpbmcoY29uc3Qgc3RydWN0IHN0cmluZ19saXN0ICpsaXN0LCBjb25zdCBjaGFyICpzdHJpbmcpCnsKCWludCBleGFjdF9tYXRjaDsKCWdldF9lbnRyeV9pbmRleChsaXN0LCBzdHJpbmcsICZleGFjdF9tYXRjaCk7CglyZXR1cm4gZXhhY3RfbWF0Y2g7Cn0KCmludCBzdHJpbmdfbGlzdF9maW5kX2luc2VydF9pbmRleChjb25zdCBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QsIGNvbnN0IGNoYXIgKnN0cmluZywKCQkJCSAgaW50IG5lZ2F0aXZlX2V4aXN0aW5nX2luZGV4KQp7CglpbnQgZXhhY3RfbWF0Y2g7CglpbnQgaW5kZXggPSBnZXRfZW50cnlfaW5kZXgobGlzdCwgc3RyaW5nLCAmZXhhY3RfbWF0Y2gpOwoJaWYgKGV4YWN0X21hdGNoKQoJCWluZGV4ID0gLTEgLSAobmVnYXRpdmVfZXhpc3RpbmdfaW5kZXggPyBpbmRleCA6IDApOwoJcmV0dXJuIGluZGV4Owp9CgpzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqc3RyaW5nX2xpc3RfbG9va3VwKHN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCwgY29uc3QgY2hhciAqc3RyaW5nKQp7CglpbnQgZXhhY3RfbWF0Y2gsIGkgPSBnZXRfZW50cnlfaW5kZXgobGlzdCwgc3RyaW5nLCAmZXhhY3RfbWF0Y2gpOwoJaWYgKCFleGFjdF9tYXRjaCkKCQlyZXR1cm4gTlVMTDsKCXJldHVybiBsaXN0LT5pdGVtcyArIGk7Cn0KCnZvaWQgc3RyaW5nX2xpc3RfcmVtb3ZlX2R1cGxpY2F0ZXMoc3RydWN0IHN0cmluZ19saXN0ICpsaXN0LCBpbnQgZnJlZV91dGlsKQp7CglpZiAobGlzdC0+bnIgPiAxKSB7CgkJaW50IHNyYywgZHN0OwoJCWNvbXBhcmVfc3RyaW5nc19mbiBjbXAgPSBsaXN0LT5jbXAgPyBsaXN0LT5jbXAgOiBzdHJjbXA7CgkJZm9yIChzcmMgPSBkc3QgPSAxOyBzcmMgPCBsaXN0LT5ucjsgc3JjKyspIHsKCQkJaWYgKCFjbXAobGlzdC0+aXRlbXNbZHN0IC0gMV0uc3RyaW5nLCBsaXN0LT5pdGVtc1tzcmNdLnN0cmluZykpIHsKCQkJCWlmIChsaXN0LT5zdHJkdXBfc3RyaW5ncykKCQkJCQlmcmVlKGxpc3QtPml0ZW1zW3NyY10uc3RyaW5nKTsKCQkJCWlmIChmcmVlX3V0aWwpCgkJCQkJZnJlZShsaXN0LT5pdGVtc1tzcmNdLnV0aWwpOwoJCQl9IGVsc2UKCQkJCWxpc3QtPml0ZW1zW2RzdCsrXSA9IGxpc3QtPml0ZW1zW3NyY107CgkJfQoJCWxpc3QtPm5yID0gZHN0OwoJfQp9CgppbnQgZm9yX2VhY2hfc3RyaW5nX2xpc3Qoc3RydWN0IHN0cmluZ19saXN0ICpsaXN0LAoJCQkgc3RyaW5nX2xpc3RfZWFjaF9mdW5jX3QgZm4sIHZvaWQgKmNiX2RhdGEpCnsKCWludCBpLCByZXQgPSAwOwoJZm9yIChpID0gMDsgaSA8IGxpc3QtPm5yOyBpKyspCgkJaWYgKChyZXQgPSBmbigmbGlzdC0+aXRlbXNbaV0sIGNiX2RhdGEpKSkKCQkJYnJlYWs7CglyZXR1cm4gcmV0Owp9Cgp2b2lkIGZpbHRlcl9zdHJpbmdfbGlzdChzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QsIGludCBmcmVlX3V0aWwsCgkJCXN0cmluZ19saXN0X2VhY2hfZnVuY190IHdhbnQsIHZvaWQgKmNiX2RhdGEpCnsKCWludCBzcmMsIGRzdCA9IDA7Cglmb3IgKHNyYyA9IDA7IHNyYyA8IGxpc3QtPm5yOyBzcmMrKykgewoJCWlmICh3YW50KCZsaXN0LT5pdGVtc1tzcmNdLCBjYl9kYXRhKSkgewoJCQlsaXN0LT5pdGVtc1tkc3QrK10gPSBsaXN0LT5pdGVtc1tzcmNdOwoJCX0gZWxzZSB7CgkJCWlmIChsaXN0LT5zdHJkdXBfc3RyaW5ncykKCQkJCWZyZWUobGlzdC0+aXRlbXNbc3JjXS5zdHJpbmcpOwoJCQlpZiAoZnJlZV91dGlsKQoJCQkJZnJlZShsaXN0LT5pdGVtc1tzcmNdLnV0aWwpOwoJCX0KCX0KCWxpc3QtPm5yID0gZHN0Owp9CgpzdGF0aWMgaW50IGl0ZW1faXNfbm90X2VtcHR5KHN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtLCB2b2lkICp1bnVzZWQpCnsKCXJldHVybiAqaXRlbS0+c3RyaW5nICE9ICdcMCc7Cn0KCnZvaWQgc3RyaW5nX2xpc3RfcmVtb3ZlX2VtcHR5X2l0ZW1zKHN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCwgaW50IGZyZWVfdXRpbCkgewoJZmlsdGVyX3N0cmluZ19saXN0KGxpc3QsIGZyZWVfdXRpbCwgaXRlbV9pc19ub3RfZW1wdHksIE5VTEwpOwp9Cgp2b2lkIHN0cmluZ19saXN0X2NsZWFyKHN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCwgaW50IGZyZWVfdXRpbCkKewoJaWYgKGxpc3QtPml0ZW1zKSB7CgkJaW50IGk7CgkJaWYgKGxpc3QtPnN0cmR1cF9zdHJpbmdzKSB7CgkJCWZvciAoaSA9IDA7IGkgPCBsaXN0LT5ucjsgaSsrKQoJCQkJZnJlZShsaXN0LT5pdGVtc1tpXS5zdHJpbmcpOwoJCX0KCQlpZiAoZnJlZV91dGlsKSB7CgkJCWZvciAoaSA9IDA7IGkgPCBsaXN0LT5ucjsgaSsrKQoJCQkJZnJlZShsaXN0LT5pdGVtc1tpXS51dGlsKTsKCQl9CgkJZnJlZShsaXN0LT5pdGVtcyk7Cgl9CglsaXN0LT5pdGVtcyA9IE5VTEw7CglsaXN0LT5uciA9IGxpc3QtPmFsbG9jID0gMDsKfQoKdm9pZCBzdHJpbmdfbGlzdF9jbGVhcl9mdW5jKHN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCwgc3RyaW5nX2xpc3RfY2xlYXJfZnVuY190IGNsZWFyZnVuYykKewoJaWYgKGxpc3QtPml0ZW1zKSB7CgkJaW50IGk7CgkJaWYgKGNsZWFyZnVuYykgewoJCQlmb3IgKGkgPSAwOyBpIDwgbGlzdC0+bnI7IGkrKykKCQkJCWNsZWFyZnVuYyhsaXN0LT5pdGVtc1tpXS51dGlsLCBsaXN0LT5pdGVtc1tpXS5zdHJpbmcpOwoJCX0KCQlpZiAobGlzdC0+c3RyZHVwX3N0cmluZ3MpIHsKCQkJZm9yIChpID0gMDsgaSA8IGxpc3QtPm5yOyBpKyspCgkJCQlmcmVlKGxpc3QtPml0ZW1zW2ldLnN0cmluZyk7CgkJfQoJCWZyZWUobGlzdC0+aXRlbXMpOwoJfQoJbGlzdC0+aXRlbXMgPSBOVUxMOwoJbGlzdC0+bnIgPSBsaXN0LT5hbGxvYyA9IDA7Cn0KCgp2b2lkIHByaW50X3N0cmluZ19saXN0KGNvbnN0IHN0cnVjdCBzdHJpbmdfbGlzdCAqcCwgY29uc3QgY2hhciAqdGV4dCkKewoJaW50IGk7CglpZiAoIHRleHQgKQoJCXByaW50ZigiJXNcbiIsIHRleHQpOwoJZm9yIChpID0gMDsgaSA8IHAtPm5yOyBpKyspCgkJcHJpbnRmKCIlczolcFxuIiwgcC0+aXRlbXNbaV0uc3RyaW5nLCBwLT5pdGVtc1tpXS51dGlsKTsKfQoKc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKnN0cmluZ19saXN0X2FwcGVuZF9ub2R1cChzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QsCgkJCQkJCSAgY2hhciAqc3RyaW5nKQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqcmV0dmFsOwoJQUxMT0NfR1JPVyhsaXN0LT5pdGVtcywgbGlzdC0+bnIgKyAxLCBsaXN0LT5hbGxvYyk7CglyZXR2YWwgPSAmbGlzdC0+aXRlbXNbbGlzdC0+bnIrK107CglyZXR2YWwtPnN0cmluZyA9IHN0cmluZzsKCXJldHZhbC0+dXRpbCA9IE5VTEw7CglyZXR1cm4gcmV0dmFsOwp9CgpzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqc3RyaW5nX2xpc3RfYXBwZW5kKHN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCwKCQkJCQkgICAgY29uc3QgY2hhciAqc3RyaW5nKQp7CglyZXR1cm4gc3RyaW5nX2xpc3RfYXBwZW5kX25vZHVwKAoJCQlsaXN0LAoJCQlsaXN0LT5zdHJkdXBfc3RyaW5ncyA/IHhzdHJkdXAoc3RyaW5nKSA6IChjaGFyICopc3RyaW5nKTsKfQoKc3RhdGljIGludCBjbXBfaXRlbXMoY29uc3Qgdm9pZCAqYSwgY29uc3Qgdm9pZCAqYiwgdm9pZCAqY3R4KQp7Cgljb21wYXJlX3N0cmluZ3NfZm4gY21wID0gY3R4OwoJY29uc3Qgc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKm9uZSA9IGE7Cgljb25zdCBzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqdHdvID0gYjsKCXJldHVybiBjbXAob25lLT5zdHJpbmcsIHR3by0+c3RyaW5nKTsKfQoKdm9pZCBzdHJpbmdfbGlzdF9zb3J0KHN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCkKewoJUVNPUlRfUyhsaXN0LT5pdGVtcywgbGlzdC0+bnIsIGNtcF9pdGVtcywKCQlsaXN0LT5jbXAgPyBsaXN0LT5jbXAgOiBzdHJjbXApOwp9CgpzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqdW5zb3J0ZWRfc3RyaW5nX2xpc3RfbG9va3VwKHN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCwKCQkJCQkJICAgICBjb25zdCBjaGFyICpzdHJpbmcpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoJY29tcGFyZV9zdHJpbmdzX2ZuIGNtcCA9IGxpc3QtPmNtcCA/IGxpc3QtPmNtcCA6IHN0cmNtcDsKCglmb3JfZWFjaF9zdHJpbmdfbGlzdF9pdGVtKGl0ZW0sIGxpc3QpCgkJaWYgKCFjbXAoc3RyaW5nLCBpdGVtLT5zdHJpbmcpKQoJCQlyZXR1cm4gaXRlbTsKCXJldHVybiBOVUxMOwp9CgppbnQgdW5zb3J0ZWRfc3RyaW5nX2xpc3RfaGFzX3N0cmluZyhzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QsCgkJCQkgICAgY29uc3QgY2hhciAqc3RyaW5nKQp7CglyZXR1cm4gdW5zb3J0ZWRfc3RyaW5nX2xpc3RfbG9va3VwKGxpc3QsIHN0cmluZykgIT0gTlVMTDsKfQoKdm9pZCB1bnNvcnRlZF9zdHJpbmdfbGlzdF9kZWxldGVfaXRlbShzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QsIGludCBpLCBpbnQgZnJlZV91dGlsKQp7CglpZiAobGlzdC0+c3RyZHVwX3N0cmluZ3MpCgkJZnJlZShsaXN0LT5pdGVtc1tpXS5zdHJpbmcpOwoJaWYgKGZyZWVfdXRpbCkKCQlmcmVlKGxpc3QtPml0ZW1zW2ldLnV0aWwpOwoJbGlzdC0+aXRlbXNbaV0gPSBsaXN0LT5pdGVtc1tsaXN0LT5uci0xXTsKCWxpc3QtPm5yLS07Cn0KCmludCBzdHJpbmdfbGlzdF9zcGxpdChzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QsIGNvbnN0IGNoYXIgKnN0cmluZywKCQkgICAgICBpbnQgZGVsaW0sIGludCBtYXhzcGxpdCkKewoJaW50IGNvdW50ID0gMDsKCWNvbnN0IGNoYXIgKnAgPSBzdHJpbmcsICplbmQ7CgoJaWYgKCFsaXN0LT5zdHJkdXBfc3RyaW5ncykKCQlkaWUoImludGVybmFsIGVycm9yIGluIHN0cmluZ19saXN0X3NwbGl0KCk6ICIKCQkgICAgImxpc3QtPnN0cmR1cF9zdHJpbmdzIG11c3QgYmUgc2V0Iik7Cglmb3IgKDs7KSB7CgkJY291bnQrKzsKCQlpZiAobWF4c3BsaXQgPj0gMCAmJiBjb3VudCA+IG1heHNwbGl0KSB7CgkJCXN0cmluZ19saXN0X2FwcGVuZChsaXN0LCBwKTsKCQkJcmV0dXJuIGNvdW50OwoJCX0KCQllbmQgPSBzdHJjaHIocCwgZGVsaW0pOwoJCWlmIChlbmQpIHsKCQkJc3RyaW5nX2xpc3RfYXBwZW5kX25vZHVwKGxpc3QsIHhtZW1kdXB6KHAsIGVuZCAtIHApKTsKCQkJcCA9IGVuZCArIDE7CgkJfSBlbHNlIHsKCQkJc3RyaW5nX2xpc3RfYXBwZW5kKGxpc3QsIHApOwoJCQlyZXR1cm4gY291bnQ7CgkJfQoJfQp9CgppbnQgc3RyaW5nX2xpc3Rfc3BsaXRfaW5fcGxhY2Uoc3RydWN0IHN0cmluZ19saXN0ICpsaXN0LCBjaGFyICpzdHJpbmcsCgkJCSAgICAgICBpbnQgZGVsaW0sIGludCBtYXhzcGxpdCkKewoJaW50IGNvdW50ID0gMDsKCWNoYXIgKnAgPSBzdHJpbmcsICplbmQ7CgoJaWYgKGxpc3QtPnN0cmR1cF9zdHJpbmdzKQoJCWRpZSgiaW50ZXJuYWwgZXJyb3IgaW4gc3RyaW5nX2xpc3Rfc3BsaXRfaW5fcGxhY2UoKTogIgoJCSAgICAibGlzdC0+c3RyZHVwX3N0cmluZ3MgbXVzdCBub3QgYmUgc2V0Iik7Cglmb3IgKDs7KSB7CgkJY291bnQrKzsKCQlpZiAobWF4c3BsaXQgPj0gMCAmJiBjb3VudCA+IG1heHNwbGl0KSB7CgkJCXN0cmluZ19saXN0X2FwcGVuZChsaXN0LCBwKTsKCQkJcmV0dXJuIGNvdW50OwoJCX0KCQllbmQgPSBzdHJjaHIocCwgZGVsaW0pOwoJCWlmIChlbmQpIHsKCQkJKmVuZCA9ICdcMCc7CgkJCXN0cmluZ19saXN0X2FwcGVuZChsaXN0LCBwKTsKCQkJcCA9IGVuZCArIDE7CgkJfSBlbHNlIHsKCQkJc3RyaW5nX2xpc3RfYXBwZW5kKGxpc3QsIHApOwoJCQlyZXR1cm4gY291bnQ7CgkJfQoJfQp9Cg==",
    "text": "#include \"cache.h\"\n#include \"string-list.h\"\n\nvoid string_list_init(struct string_list *list, int strdup_strings)\n{\n\tmemset(list, 0, sizeof(*list));\n\tlist->strdup_strings = strdup_strings;\n}\n\n/* if there is no exact match, point to the index where the entry could be\n * inserted */\nstatic int get_entry_index(const struct string_list *list, const char *string,\n\t\tint *exact_match)\n{\n\tint left = -1, right = list->nr;\n\tcompare_strings_fn cmp = list->cmp ? list->cmp : strcmp;\n\n\twhile (left + 1 < right) {\n\t\tint middle = (left + right) / 2;\n\t\tint compare = cmp(string, list->items[middle].string);\n\t\tif (compare < 0)\n\t\t\tright = middle;\n\t\telse if (compare > 0)\n\t\t\tleft = middle;\n\t\telse {\n\t\t\t*exact_match = 1;\n\t\t\treturn middle;\n\t\t}\n\t}\n\n\t*exact_match = 0;\n\treturn right;\n}\n\n/* returns -1-index if already exists */\nstatic int add_entry(int insert_at, struct string_list *list, const char *string)\n{\n\tint exact_match = 0;\n\tint index = insert_at != -1 ? insert_at : get_entry_index(list, string, &exact_match);\n\n\tif (exact_match)\n\t\treturn -1 - index;\n\n\tALLOC_GROW(list->items, list->nr+1, list->alloc);\n\tif (index < list->nr)\n\t\tmemmove(list->items + index + 1, list->items + index,\n\t\t\t\t(list->nr - index)\n\t\t\t\t* sizeof(struct string_list_item));\n\tlist->items[index].string = list->strdup_strings ?\n\t\txstrdup(string) : (char *)string;\n\tlist->items[index].util = NULL;\n\tlist->nr++;\n\n\treturn index;\n}\n\nstruct string_list_item *string_list_insert(struct string_list *list, const char *string)\n{\n\tint index = add_entry(-1, list, string);\n\n\tif (index < 0)\n\t\tindex = -1 - index;\n\n\treturn list->items + index;\n}\n\nint string_list_has_string(const struct string_list *list, const char *string)\n{\n\tint exact_match;\n\tget_entry_index(list, string, &exact_match);\n\treturn exact_match;\n}\n\nint string_list_find_insert_index(const struct string_list *list, const char *string,\n\t\t\t\t  int negative_existing_index)\n{\n\tint exact_match;\n\tint index = get_entry_index(list, string, &exact_match);\n\tif (exact_match)\n\t\tindex = -1 - (negative_existing_index ? index : 0);\n\treturn index;\n}\n\nstruct string_list_item *string_list_lookup(struct string_list *list, const char *string)\n{\n\tint exact_match, i = get_entry_index(list, string, &exact_match);\n\tif (!exact_match)\n\t\treturn NULL;\n\treturn list->items + i;\n}\n\nvoid string_list_remove_duplicates(struct string_list *list, int free_util)\n{\n\tif (list->nr > 1) {\n\t\tint src, dst;\n\t\tcompare_strings_fn cmp = list->cmp ? list->cmp : strcmp;\n\t\tfor (src = dst = 1; src < list->nr; src++) {\n\t\t\tif (!cmp(list->items[dst - 1].string, list->items[src].string)) {\n\t\t\t\tif (list->strdup_strings)\n\t\t\t\t\tfree(list->items[src].string);\n\t\t\t\tif (free_util)\n\t\t\t\t\tfree(list->items[src].util);\n\t\t\t} else\n\t\t\t\tlist->items[dst++] = list->items[src];\n\t\t}\n\t\tlist->nr = dst;\n\t}\n}\n\nint for_each_string_list(struct string_list *list,\n\t\t\t string_list_each_func_t fn, void *cb_data)\n{\n\tint i, ret = 0;\n\tfor (i = 0; i < list->nr; i++)\n\t\tif ((ret = fn(&list->items[i], cb_data)))\n\t\t\tbreak;\n\treturn ret;\n}\n\nvoid filter_string_list(struct string_list *list, int free_util,\n\t\t\tstring_list_each_func_t want, void *cb_data)\n{\n\tint src, dst = 0;\n\tfor (src = 0; src < list->nr; src++) {\n\t\tif (want(&list->items[src], cb_data)) {\n\t\t\tlist->items[dst++] = list->items[src];\n\t\t} else {\n\t\t\tif (list->strdup_strings)\n\t\t\t\tfree(list->items[src].string);\n\t\t\tif (free_util)\n\t\t\t\tfree(list->items[src].util);\n\t\t}\n\t}\n\tlist->nr = dst;\n}\n\nstatic int item_is_not_empty(struct string_list_item *item, void *unused)\n{\n\treturn *item->string != '\\0';\n}\n\nvoid string_list_remove_empty_items(struct string_list *list, int free_util) {\n\tfilter_string_list(list, free_util, item_is_not_empty, NULL);\n}\n\nvoid string_list_clear(struct string_list *list, int free_util)\n{\n\tif (list->items) {\n\t\tint i;\n\t\tif (list->strdup_strings) {\n\t\t\tfor (i = 0; i < list->nr; i++)\n\t\t\t\tfree(list->items[i].string);\n\t\t}\n\t\tif (free_util) {\n\t\t\tfor (i = 0; i < list->nr; i++)\n\t\t\t\tfree(list->items[i].util);\n\t\t}\n\t\tfree(list->items);\n\t}\n\tlist->items = NULL;\n\tlist->nr = list->alloc = 0;\n}\n\nvoid string_list_clear_func(struct string_list *list, string_list_clear_func_t clearfunc)\n{\n\tif (list->items) {\n\t\tint i;\n\t\tif (clearfunc) {\n\t\t\tfor (i = 0; i < list->nr; i++)\n\t\t\t\tclearfunc(list->items[i].util, list->items[i].string);\n\t\t}\n\t\tif (list->strdup_strings) {\n\t\t\tfor (i = 0; i < list->nr; i++)\n\t\t\t\tfree(list->items[i].string);\n\t\t}\n\t\tfree(list->items);\n\t}\n\tlist->items = NULL;\n\tlist->nr = list->alloc = 0;\n}\n\n\nvoid print_string_list(const struct string_list *p, const char *text)\n{\n\tint i;\n\tif ( text )\n\t\tprintf(\"%s\\n\", text);\n\tfor (i = 0; i < p->nr; i++)\n\t\tprintf(\"%s:%p\\n\", p->items[i].string, p->items[i].util);\n}\n\nstruct string_list_item *string_list_append_nodup(struct string_list *list,\n\t\t\t\t\t\t  char *string)\n{\n\tstruct string_list_item *retval;\n\tALLOC_GROW(list->items, list->nr + 1, list->alloc);\n\tretval = &list->items[list->nr++];\n\tretval->string = string;\n\tretval->util = NULL;\n\treturn retval;\n}\n\nstruct string_list_item *string_list_append(struct string_list *list,\n\t\t\t\t\t    const char *string)\n{\n\treturn string_list_append_nodup(\n\t\t\tlist,\n\t\t\tlist->strdup_strings ? xstrdup(string) : (char *)string);\n}\n\nstatic int cmp_items(const void *a, const void *b, void *ctx)\n{\n\tcompare_strings_fn cmp = ctx;\n\tconst struct string_list_item *one = a;\n\tconst struct string_list_item *two = b;\n\treturn cmp(one->string, two->string);\n}\n\nvoid string_list_sort(struct string_list *list)\n{\n\tQSORT_S(list->items, list->nr, cmp_items,\n\t\tlist->cmp ? list->cmp : strcmp);\n}\n\nstruct string_list_item *unsorted_string_list_lookup(struct string_list *list,\n\t\t\t\t\t\t     const char *string)\n{\n\tstruct string_list_item *item;\n\tcompare_strings_fn cmp = list->cmp ? list->cmp : strcmp;\n\n\tfor_each_string_list_item(item, list)\n\t\tif (!cmp(string, item->string))\n\t\t\treturn item;\n\treturn NULL;\n}\n\nint unsorted_string_list_has_string(struct string_list *list,\n\t\t\t\t    const char *string)\n{\n\treturn unsorted_string_list_lookup(list, string) != NULL;\n}\n\nvoid unsorted_string_list_delete_item(struct string_list *list, int i, int free_util)\n{\n\tif (list->strdup_strings)\n\t\tfree(list->items[i].string);\n\tif (free_util)\n\t\tfree(list->items[i].util);\n\tlist->items[i] = list->items[list->nr-1];\n\tlist->nr--;\n}\n\nint string_list_split(struct string_list *list, const char *string,\n\t\t      int delim, int maxsplit)\n{\n\tint count = 0;\n\tconst char *p = string, *end;\n\n\tif (!list->strdup_strings)\n\t\tdie(\"internal error in string_list_split(): \"\n\t\t    \"list->strdup_strings must be set\");\n\tfor (;;) {\n\t\tcount++;\n\t\tif (maxsplit >= 0 && count > maxsplit) {\n\t\t\tstring_list_append(list, p);\n\t\t\treturn count;\n\t\t}\n\t\tend = strchr(p, delim);\n\t\tif (end) {\n\t\t\tstring_list_append_nodup(list, xmemdupz(p, end - p));\n\t\t\tp = end + 1;\n\t\t} else {\n\t\t\tstring_list_append(list, p);\n\t\t\treturn count;\n\t\t}\n\t}\n}\n\nint string_list_split_in_place(struct string_list *list, char *string,\n\t\t\t       int delim, int maxsplit)\n{\n\tint count = 0;\n\tchar *p = string, *end;\n\n\tif (list->strdup_strings)\n\t\tdie(\"internal error in string_list_split_in_place(): \"\n\t\t    \"list->strdup_strings must not be set\");\n\tfor (;;) {\n\t\tcount++;\n\t\tif (maxsplit >= 0 && count > maxsplit) {\n\t\t\tstring_list_append(list, p);\n\t\t\treturn count;\n\t\t}\n\t\tend = strchr(p, delim);\n\t\tif (end) {\n\t\t\t*end = '\\0';\n\t\t\tstring_list_append(list, p);\n\t\t\tp = end + 1;\n\t\t} else {\n\t\t\tstring_list_append(list, p);\n\t\t\treturn count;\n\t\t}\n\t}\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "003ca1879ef560b3db0ad9e1af8022c38800b500",
  "sha1_ok": true,
  "size": 7339
}
