{
  "content": {
    "base64": "LyoKICogQSBnaXQgY3JlZGVudGlhbCBoZWxwZXIgdGhhdCBpbnRlcmZhY2Ugd2l0aCBXaW5kb3dzJyBDcmVkZW50aWFsIE1hbmFnZXIKICoKICovCiNpbmNsdWRlIDx3aW5kb3dzLmg+CiNpbmNsdWRlIDxzdGRpby5oPgojaW5jbHVkZSA8aW8uaD4KI2luY2x1ZGUgPGZjbnRsLmg+CgovKiBjb21tb24gaGVscGVycyAqLwoKI2RlZmluZSBBUlJBWV9TSVpFKHgpIChzaXplb2YoeCkvc2l6ZW9mKHhbMF0pKQoKc3RhdGljIHZvaWQgZGllKGNvbnN0IGNoYXIgKmVyciwgLi4uKQp7CgljaGFyIG1zZ1s0MDk2XTsKCXZhX2xpc3QgcGFyYW1zOwoJdmFfc3RhcnQocGFyYW1zLCBlcnIpOwoJdnNucHJpbnRmKG1zZywgc2l6ZW9mKG1zZyksIGVyciwgcGFyYW1zKTsKCWZwcmludGYoc3RkZXJyLCAiJXNcbiIsIG1zZyk7Cgl2YV9lbmQocGFyYW1zKTsKCWV4aXQoMSk7Cn0KCnN0YXRpYyB2b2lkICp4bWFsbG9jKHNpemVfdCBzaXplKQp7Cgl2b2lkICpyZXQgPSBtYWxsb2Moc2l6ZSk7CglpZiAoIXJldCAmJiAhc2l6ZSkKCQlyZXQgPSBtYWxsb2MoMSk7CglpZiAoIXJldCkKCQkgZGllKCJPdXQgb2YgbWVtb3J5Iik7CglyZXR1cm4gcmV0Owp9CgovKiBNaW5HVyBkb2Vzbid0IGhhdmUgd2luY3JlZC5oLCBzbyB3ZSBuZWVkIHRvIGRlZmluZSBzdHVmZiAqLwoKdHlwZWRlZiBzdHJ1Y3QgX0NSRURFTlRJQUxfQVRUUklCVVRFVyB7CglMUFdTVFIgS2V5d29yZDsKCURXT1JEICBGbGFnczsKCURXT1JEICBWYWx1ZVNpemU7CglMUEJZVEUgVmFsdWU7Cn0gQ1JFREVOVElBTF9BVFRSSUJVVEVXLCAqUENSRURFTlRJQUxfQVRUUklCVVRFVzsKCnR5cGVkZWYgc3RydWN0IF9DUkVERU5USUFMVyB7CglEV09SRCAgICAgICAgICAgICAgICAgIEZsYWdzOwoJRFdPUkQgICAgICAgICAgICAgICAgICBUeXBlOwoJTFBXU1RSICAgICAgICAgICAgICAgICBUYXJnZXROYW1lOwoJTFBXU1RSICAgICAgICAgICAgICAgICBDb21tZW50OwoJRklMRVRJTUUgICAgICAgICAgICAgICBMYXN0V3JpdHRlbjsKCURXT1JEICAgICAgICAgICAgICAgICAgQ3JlZGVudGlhbEJsb2JTaXplOwoJTFBCWVRFICAgICAgICAgICAgICAgICBDcmVkZW50aWFsQmxvYjsKCURXT1JEICAgICAgICAgICAgICAgICAgUGVyc2lzdDsKCURXT1JEICAgICAgICAgICAgICAgICAgQXR0cmlidXRlQ291bnQ7CglQQ1JFREVOVElBTF9BVFRSSUJVVEVXIEF0dHJpYnV0ZXM7CglMUFdTVFIgICAgICAgICAgICAgICAgIFRhcmdldEFsaWFzOwoJTFBXU1RSICAgICAgICAgICAgICAgICBVc2VyTmFtZTsKfSBDUkVERU5USUFMVywgKlBDUkVERU5USUFMVzsKCiNkZWZpbmUgQ1JFRF9UWVBFX0dFTkVSSUMgMQojZGVmaW5lIENSRURfUEVSU0lTVF9MT0NBTF9NQUNISU5FIDIKI2RlZmluZSBDUkVEX01BWF9BVFRSSUJVVEVTIDY0Cgp0eXBlZGVmIEJPT0wgKFdJTkFQSSAqQ3JlZFdyaXRlV1QpKFBDUkVERU5USUFMVywgRFdPUkQpOwp0eXBlZGVmIEJPT0wgKFdJTkFQSSAqQ3JlZEVudW1lcmF0ZVdUKShMUENXU1RSLCBEV09SRCwgRFdPUkQgKiwKICAgIFBDUkVERU5USUFMVyAqKik7CnR5cGVkZWYgVk9JRCAoV0lOQVBJICpDcmVkRnJlZVQpKFBWT0lEKTsKdHlwZWRlZiBCT09MIChXSU5BUEkgKkNyZWREZWxldGVXVCkoTFBDV1NUUiwgRFdPUkQsIERXT1JEKTsKCnN0YXRpYyBITU9EVUxFIGFkdmFwaTsKc3RhdGljIENyZWRXcml0ZVdUIENyZWRXcml0ZVc7CnN0YXRpYyBDcmVkRW51bWVyYXRlV1QgQ3JlZEVudW1lcmF0ZVc7CnN0YXRpYyBDcmVkRnJlZVQgQ3JlZEZyZWU7CnN0YXRpYyBDcmVkRGVsZXRlV1QgQ3JlZERlbGV0ZVc7CgpzdGF0aWMgdm9pZCBsb2FkX2NyZWRfZnVuY3Modm9pZCkKewoJLyogbG9hZCBETExzICovCglhZHZhcGkgPSBMb2FkTGlicmFyeSgiYWR2YXBpMzIuZGxsIik7CglpZiAoIWFkdmFwaSkKCQlkaWUoImZhaWxlZCB0byBsb2FkIGFkdmFwaTMyLmRsbCIpOwoKCS8qIGdldCBmdW5jdGlvbiBwb2ludGVycyAqLwoJQ3JlZFdyaXRlVyA9IChDcmVkV3JpdGVXVClHZXRQcm9jQWRkcmVzcyhhZHZhcGksICJDcmVkV3JpdGVXIik7CglDcmVkRW51bWVyYXRlVyA9IChDcmVkRW51bWVyYXRlV1QpR2V0UHJvY0FkZHJlc3MoYWR2YXBpLAoJICAgICJDcmVkRW51bWVyYXRlVyIpOwoJQ3JlZEZyZWUgPSAoQ3JlZEZyZWVUKUdldFByb2NBZGRyZXNzKGFkdmFwaSwgIkNyZWRGcmVlIik7CglDcmVkRGVsZXRlVyA9IChDcmVkRGVsZXRlV1QpR2V0UHJvY0FkZHJlc3MoYWR2YXBpLCAiQ3JlZERlbGV0ZVciKTsKCWlmICghQ3JlZFdyaXRlVyB8fCAhQ3JlZEVudW1lcmF0ZVcgfHwgIUNyZWRGcmVlIHx8ICFDcmVkRGVsZXRlVykKCQlkaWUoImZhaWxlZCB0byBsb2FkIGZ1bmN0aW9ucyIpOwp9CgpzdGF0aWMgV0NIQVIgKnd1c2VybmFtZSwgKnBhc3N3b3JkLCAqcHJvdG9jb2wsICpob3N0LCAqcGF0aCwgdGFyZ2V0WzEwMjRdOwoKc3RhdGljIHZvaWQgd3JpdGVfaXRlbShjb25zdCBjaGFyICp3aGF0LCBMUENXU1RSIHdidWYsIGludCB3bGVuKQp7CgljaGFyICpidWY7CglpbnQgbGVuID0gV2lkZUNoYXJUb011bHRpQnl0ZShDUF9VVEY4LCAwLCB3YnVmLCB3bGVuLCBOVUxMLCAwLCBOVUxMLAoJICAgIEZBTFNFKTsKCWJ1ZiA9IHhtYWxsb2MobGVuKTsKCglpZiAoIVdpZGVDaGFyVG9NdWx0aUJ5dGUoQ1BfVVRGOCwgMCwgd2J1Ziwgd2xlbiwgYnVmLCBsZW4sIE5VTEwsIEZBTFNFKSkKCQlkaWUoIldpZGVDaGFyVG9NdWx0aUJ5dGUgZmFpbGVkISIpOwoKCXByaW50ZigiJXM9Iiwgd2hhdCk7Cglmd3JpdGUoYnVmLCAxLCBsZW4sIHN0ZG91dCk7CglwdXRjaGFyKCdcbicpOwoJZnJlZShidWYpOwp9CgovKgogKiBNYXRjaCBhbiAob3B0aW9uYWwpIGV4cGVjdGVkIHN0cmluZyBhbmQgYSBkZWxpbWl0ZXIgaW4gdGhlIHRhcmdldCBzdHJpbmcsCiAqIGNvbnN1bWluZyB0aGUgbWF0Y2hlZCB0ZXh0IGJ5IHVwZGF0aW5nIHRoZSB0YXJnZXQgcG9pbnRlci4KICovCgpzdGF0aWMgTFBDV1NUUiB3Y3NzdHJfbGFzdChMUENXU1RSIHN0ciwgTFBDV1NUUiBmaW5kKQp7CglMUENXU1RSIHJlcyA9IE5VTEwsIHBvczsKCWZvciAocG9zID0gd2Nzc3RyKHN0ciwgZmluZCk7IHBvczsgcG9zID0gd2Nzc3RyKHBvcyArIDEsIGZpbmQpKQoJCXJlcyA9IHBvczsKCXJldHVybiByZXM7Cn0KCnN0YXRpYyBpbnQgbWF0Y2hfcGFydF93aXRoX2xhc3QoTFBDV1NUUiAqcHRhcmdldCwgTFBDV1NUUiB3YW50LCBMUENXU1RSIGRlbGltLCBpbnQgbGFzdCkKewoJTFBDV1NUUiBkZWxpbV9wb3MsIHN0YXJ0ID0gKnB0YXJnZXQ7CglpbnQgbGVuOwoKCS8qIGZpbmQgc3RhcnQgb2YgZGVsaW1pdGVyIChvciBlbmQtb2Ytc3RyaW5nIGlmIGRlbGltIGlzIGVtcHR5KSAqLwoJaWYgKCpkZWxpbSkKCQlkZWxpbV9wb3MgPSBsYXN0ID8gd2Nzc3RyX2xhc3Qoc3RhcnQsIGRlbGltKSA6IHdjc3N0cihzdGFydCwgZGVsaW0pOwoJZWxzZQoJCWRlbGltX3BvcyA9IHN0YXJ0ICsgd2NzbGVuKHN0YXJ0KTsKCgkvKgoJICogbWF0Y2ggdGV4dCB1cCB0byBkZWxpbWl0ZXIsIG9yIGVuZCBvZiBzdHJpbmcgKGUuZy4gdGhlICcvJyBhZnRlcgoJICogaG9zdCBpcyBvcHRpb25hbCBpZiBub3QgZm9sbG93ZWQgYnkgYSBwYXRoKQoJICovCglpZiAoZGVsaW1fcG9zKQoJCWxlbiA9IGRlbGltX3BvcyAtIHN0YXJ0OwoJZWxzZQoJCWxlbiA9IHdjc2xlbihzdGFydCk7CgoJLyogdXBkYXRlIHB0YXJnZXQgaWYgd2UgZWl0aGVyIGZvdW5kIGEgZGVsaW1pdGVyIG9yIG5lZWQgYSBtYXRjaCAqLwoJaWYgKGRlbGltX3BvcyB8fCB3YW50KQoJCSpwdGFyZ2V0ID0gZGVsaW1fcG9zID8gZGVsaW1fcG9zICsgd2NzbGVuKGRlbGltKSA6IHN0YXJ0ICsgbGVuOwoKCXJldHVybiAhd2FudCB8fCAoIXdjc25jbXAod2FudCwgc3RhcnQsIGxlbikgJiYgIXdhbnRbbGVuXSk7Cn0KCnN0YXRpYyBpbnQgbWF0Y2hfcGFydChMUENXU1RSICpwdGFyZ2V0LCBMUENXU1RSIHdhbnQsIExQQ1dTVFIgZGVsaW0pCnsKCXJldHVybiBtYXRjaF9wYXJ0X3dpdGhfbGFzdChwdGFyZ2V0LCB3YW50LCBkZWxpbSwgMCk7Cn0KCnN0YXRpYyBpbnQgbWF0Y2hfcGFydF9sYXN0KExQQ1dTVFIgKnB0YXJnZXQsIExQQ1dTVFIgd2FudCwgTFBDV1NUUiBkZWxpbSkKewoJcmV0dXJuIG1hdGNoX3BhcnRfd2l0aF9sYXN0KHB0YXJnZXQsIHdhbnQsIGRlbGltLCAxKTsKfQoKc3RhdGljIGludCBtYXRjaF9jcmVkKGNvbnN0IENSRURFTlRJQUxXICpjcmVkKQp7CglMUENXU1RSIHRhcmdldCA9IGNyZWQtPlRhcmdldE5hbWU7CglpZiAod3VzZXJuYW1lICYmIHdjc2NtcCh3dXNlcm5hbWUsIGNyZWQtPlVzZXJOYW1lKSkKCQlyZXR1cm4gMDsKCglyZXR1cm4gbWF0Y2hfcGFydCgmdGFyZ2V0LCBMImdpdCIsIEwiOiIpICYmCgkJbWF0Y2hfcGFydCgmdGFyZ2V0LCBwcm90b2NvbCwgTCI6Ly8iKSAmJgoJCW1hdGNoX3BhcnRfbGFzdCgmdGFyZ2V0LCB3dXNlcm5hbWUsIEwiQCIpICYmCgkJbWF0Y2hfcGFydCgmdGFyZ2V0LCBob3N0LCBMIi8iKSAmJgoJCW1hdGNoX3BhcnQoJnRhcmdldCwgcGF0aCwgTCIiKTsKfQoKc3RhdGljIHZvaWQgZ2V0X2NyZWRlbnRpYWwodm9pZCkKewoJQ1JFREVOVElBTFcgKipjcmVkczsKCURXT1JEIG51bV9jcmVkczsKCWludCBpOwoKCWlmICghQ3JlZEVudW1lcmF0ZVcoTCJnaXQ6KiIsIDAsICZudW1fY3JlZHMsICZjcmVkcykpCgkJcmV0dXJuOwoKCS8qIHNlYXJjaCBmb3IgdGhlIGZpcnN0IGNyZWRlbnRpYWwgdGhhdCBtYXRjaGVzIHVzZXJuYW1lICovCglmb3IgKGkgPSAwOyBpIDwgbnVtX2NyZWRzOyArK2kpCgkJaWYgKG1hdGNoX2NyZWQoY3JlZHNbaV0pKSB7CgkJCXdyaXRlX2l0ZW0oInVzZXJuYW1lIiwgY3JlZHNbaV0tPlVzZXJOYW1lLAoJCQkJd2NzbGVuKGNyZWRzW2ldLT5Vc2VyTmFtZSkpOwoJCQl3cml0ZV9pdGVtKCJwYXNzd29yZCIsCgkJCQkoTFBDV1NUUiljcmVkc1tpXS0+Q3JlZGVudGlhbEJsb2IsCgkJCQljcmVkc1tpXS0+Q3JlZGVudGlhbEJsb2JTaXplIC8gc2l6ZW9mKFdDSEFSKSk7CgkJCWJyZWFrOwoJCX0KCglDcmVkRnJlZShjcmVkcyk7Cn0KCnN0YXRpYyB2b2lkIHN0b3JlX2NyZWRlbnRpYWwodm9pZCkKewoJQ1JFREVOVElBTFcgY3JlZDsKCglpZiAoIXd1c2VybmFtZSB8fCAhcGFzc3dvcmQpCgkJcmV0dXJuOwoKCWNyZWQuRmxhZ3MgPSAwOwoJY3JlZC5UeXBlID0gQ1JFRF9UWVBFX0dFTkVSSUM7CgljcmVkLlRhcmdldE5hbWUgPSB0YXJnZXQ7CgljcmVkLkNvbW1lbnQgPSBMInNhdmVkIGJ5IGdpdC1jcmVkZW50aWFsLXdpbmNyZWQiOwoJY3JlZC5DcmVkZW50aWFsQmxvYlNpemUgPSAod2NzbGVuKHBhc3N3b3JkKSkgKiBzaXplb2YoV0NIQVIpOwoJY3JlZC5DcmVkZW50aWFsQmxvYiA9IChMUFZPSUQpcGFzc3dvcmQ7CgljcmVkLlBlcnNpc3QgPSBDUkVEX1BFUlNJU1RfTE9DQUxfTUFDSElORTsKCWNyZWQuQXR0cmlidXRlQ291bnQgPSAwOwoJY3JlZC5BdHRyaWJ1dGVzID0gTlVMTDsKCWNyZWQuVGFyZ2V0QWxpYXMgPSBOVUxMOwoJY3JlZC5Vc2VyTmFtZSA9IHd1c2VybmFtZTsKCglpZiAoIUNyZWRXcml0ZVcoJmNyZWQsIDApKQoJCWRpZSgiQ3JlZFdyaXRlIGZhaWxlZCIpOwp9CgpzdGF0aWMgdm9pZCBlcmFzZV9jcmVkZW50aWFsKHZvaWQpCnsKCUNSRURFTlRJQUxXICoqY3JlZHM7CglEV09SRCBudW1fY3JlZHM7CglpbnQgaTsKCglpZiAoIUNyZWRFbnVtZXJhdGVXKEwiZ2l0OioiLCAwLCAmbnVtX2NyZWRzLCAmY3JlZHMpKQoJCXJldHVybjsKCglmb3IgKGkgPSAwOyBpIDwgbnVtX2NyZWRzOyArK2kpIHsKCQlpZiAobWF0Y2hfY3JlZChjcmVkc1tpXSkpCgkJCUNyZWREZWxldGVXKGNyZWRzW2ldLT5UYXJnZXROYW1lLCBjcmVkc1tpXS0+VHlwZSwgMCk7Cgl9CgoJQ3JlZEZyZWUoY3JlZHMpOwp9CgpzdGF0aWMgV0NIQVIgKnV0ZjhfdG9fdXRmMTZfZHVwKGNvbnN0IGNoYXIgKnN0cikKewoJaW50IHdsZW4gPSBNdWx0aUJ5dGVUb1dpZGVDaGFyKENQX1VURjgsIDAsIHN0ciwgLTEsIE5VTEwsIDApOwoJV0NIQVIgKndzdHIgPSB4bWFsbG9jKHNpemVvZihXQ0hBUikgKiB3bGVuKTsKCU11bHRpQnl0ZVRvV2lkZUNoYXIoQ1BfVVRGOCwgMCwgc3RyLCAtMSwgd3N0ciwgd2xlbik7CglyZXR1cm4gd3N0cjsKfQoKc3RhdGljIHZvaWQgcmVhZF9jcmVkZW50aWFsKHZvaWQpCnsKCWNoYXIgYnVmWzEwMjRdOwoKCXdoaWxlIChmZ2V0cyhidWYsIHNpemVvZihidWYpLCBzdGRpbikpIHsKCQljaGFyICp2OwoJCWludCBsZW4gPSBzdHJsZW4oYnVmKTsKCQkvKiBzdHJpcCB0cmFpbGluZyBDUiAvIExGICovCgkJd2hpbGUgKGxlbiAmJiBzdHJjaHIoIlxyXG4iLCBidWZbbGVuIC0gMV0pKQoJCQlidWZbLS1sZW5dID0gMDsKCgkJaWYgKCEqYnVmKQoJCQlicmVhazsKCgkJdiA9IHN0cmNocihidWYsICc9Jyk7CgkJaWYgKCF2KQoJCQlkaWUoImJhZCBpbnB1dDogJXMiLCBidWYpOwoJCSp2KysgPSAnXDAnOwoKCQlpZiAoIXN0cmNtcChidWYsICJwcm90b2NvbCIpKQoJCQlwcm90b2NvbCA9IHV0ZjhfdG9fdXRmMTZfZHVwKHYpOwoJCWVsc2UgaWYgKCFzdHJjbXAoYnVmLCAiaG9zdCIpKQoJCQlob3N0ID0gdXRmOF90b191dGYxNl9kdXAodik7CgkJZWxzZSBpZiAoIXN0cmNtcChidWYsICJwYXRoIikpCgkJCXBhdGggPSB1dGY4X3RvX3V0ZjE2X2R1cCh2KTsKCQllbHNlIGlmICghc3RyY21wKGJ1ZiwgInVzZXJuYW1lIikpIHsKCQkJd3VzZXJuYW1lID0gdXRmOF90b191dGYxNl9kdXAodik7CgkJfSBlbHNlIGlmICghc3RyY21wKGJ1ZiwgInBhc3N3b3JkIikpCgkJCXBhc3N3b3JkID0gdXRmOF90b191dGYxNl9kdXAodik7CgkJZWxzZQoJCQlkaWUoInVucmVjb2duaXplZCBpbnB1dCIpOwoJfQp9CgppbnQgbWFpbihpbnQgYXJnYywgY2hhciAqYXJndltdKQp7Cgljb25zdCBjaGFyICp1c2FnZSA9CgkgICAgInVzYWdlOiBnaXQgY3JlZGVudGlhbC13aW5jcmVkIDxnZXR8c3RvcmV8ZXJhc2U+XG4iOwoKCWlmICghYXJndlsxXSkKCQlkaWUodXNhZ2UpOwoKCS8qIGdpdCB1c2UgYmluYXJ5IHBpcGVzIHRvIGF2b2lkIENSTEYtaXNzdWVzICovCglfc2V0bW9kZShfZmlsZW5vKHN0ZGluKSwgX09fQklOQVJZKTsKCV9zZXRtb2RlKF9maWxlbm8oc3Rkb3V0KSwgX09fQklOQVJZKTsKCglyZWFkX2NyZWRlbnRpYWwoKTsKCglsb2FkX2NyZWRfZnVuY3MoKTsKCglpZiAoIXByb3RvY29sIHx8ICEoaG9zdCB8fCBwYXRoKSkKCQlyZXR1cm4gMDsKCgkvKiBwcmVwYXJlICd0YXJnZXQnLCB0aGUgdW5pcXVlIGtleSBmb3IgdGhlIGNyZWRlbnRpYWwgKi8KCXdjc2NweSh0YXJnZXQsIEwiZ2l0OiIpOwoJd2NzbmNhdCh0YXJnZXQsIHByb3RvY29sLCBBUlJBWV9TSVpFKHRhcmdldCkpOwoJd2NzbmNhdCh0YXJnZXQsIEwiOi8vIiwgQVJSQVlfU0laRSh0YXJnZXQpKTsKCWlmICh3dXNlcm5hbWUpIHsKCQl3Y3NuY2F0KHRhcmdldCwgd3VzZXJuYW1lLCBBUlJBWV9TSVpFKHRhcmdldCkpOwoJCXdjc25jYXQodGFyZ2V0LCBMIkAiLCBBUlJBWV9TSVpFKHRhcmdldCkpOwoJfQoJaWYgKGhvc3QpCgkJd2NzbmNhdCh0YXJnZXQsIGhvc3QsIEFSUkFZX1NJWkUodGFyZ2V0KSk7CglpZiAocGF0aCkgewoJCXdjc25jYXQodGFyZ2V0LCBMIi8iLCBBUlJBWV9TSVpFKHRhcmdldCkpOwoJCXdjc25jYXQodGFyZ2V0LCBwYXRoLCBBUlJBWV9TSVpFKHRhcmdldCkpOwoJfQoKCWlmICghc3RyY21wKGFyZ3ZbMV0sICJnZXQiKSkKCQlnZXRfY3JlZGVudGlhbCgpOwoJZWxzZSBpZiAoIXN0cmNtcChhcmd2WzFdLCAic3RvcmUiKSkKCQlzdG9yZV9jcmVkZW50aWFsKCk7CgllbHNlIGlmICghc3RyY21wKGFyZ3ZbMV0sICJlcmFzZSIpKQoJCWVyYXNlX2NyZWRlbnRpYWwoKTsKCS8qIG90aGVyd2lzZSwgaWdub3JlIHVua25vd24gYWN0aW9uICovCglyZXR1cm4gMDsKfQo=",
    "text": "/*\n * A git credential helper that interface with Windows' Credential Manager\n *\n */\n#include <windows.h>\n#include <stdio.h>\n#include <io.h>\n#include <fcntl.h>\n\n/* common helpers */\n\n#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))\n\nstatic void die(const char *err, ...)\n{\n\tchar msg[4096];\n\tva_list params;\n\tva_start(params, err);\n\tvsnprintf(msg, sizeof(msg), err, params);\n\tfprintf(stderr, \"%s\\n\", msg);\n\tva_end(params);\n\texit(1);\n}\n\nstatic void *xmalloc(size_t size)\n{\n\tvoid *ret = malloc(size);\n\tif (!ret && !size)\n\t\tret = malloc(1);\n\tif (!ret)\n\t\t die(\"Out of memory\");\n\treturn ret;\n}\n\n/* MinGW doesn't have wincred.h, so we need to define stuff */\n\ntypedef struct _CREDENTIAL_ATTRIBUTEW {\n\tLPWSTR Keyword;\n\tDWORD  Flags;\n\tDWORD  ValueSize;\n\tLPBYTE Value;\n} CREDENTIAL_ATTRIBUTEW, *PCREDENTIAL_ATTRIBUTEW;\n\ntypedef struct _CREDENTIALW {\n\tDWORD                  Flags;\n\tDWORD                  Type;\n\tLPWSTR                 TargetName;\n\tLPWSTR                 Comment;\n\tFILETIME               LastWritten;\n\tDWORD                  CredentialBlobSize;\n\tLPBYTE                 CredentialBlob;\n\tDWORD                  Persist;\n\tDWORD                  AttributeCount;\n\tPCREDENTIAL_ATTRIBUTEW Attributes;\n\tLPWSTR                 TargetAlias;\n\tLPWSTR                 UserName;\n} CREDENTIALW, *PCREDENTIALW;\n\n#define CRED_TYPE_GENERIC 1\n#define CRED_PERSIST_LOCAL_MACHINE 2\n#define CRED_MAX_ATTRIBUTES 64\n\ntypedef BOOL (WINAPI *CredWriteWT)(PCREDENTIALW, DWORD);\ntypedef BOOL (WINAPI *CredEnumerateWT)(LPCWSTR, DWORD, DWORD *,\n    PCREDENTIALW **);\ntypedef VOID (WINAPI *CredFreeT)(PVOID);\ntypedef BOOL (WINAPI *CredDeleteWT)(LPCWSTR, DWORD, DWORD);\n\nstatic HMODULE advapi;\nstatic CredWriteWT CredWriteW;\nstatic CredEnumerateWT CredEnumerateW;\nstatic CredFreeT CredFree;\nstatic CredDeleteWT CredDeleteW;\n\nstatic void load_cred_funcs(void)\n{\n\t/* load DLLs */\n\tadvapi = LoadLibrary(\"advapi32.dll\");\n\tif (!advapi)\n\t\tdie(\"failed to load advapi32.dll\");\n\n\t/* get function pointers */\n\tCredWriteW = (CredWriteWT)GetProcAddress(advapi, \"CredWriteW\");\n\tCredEnumerateW = (CredEnumerateWT)GetProcAddress(advapi,\n\t    \"CredEnumerateW\");\n\tCredFree = (CredFreeT)GetProcAddress(advapi, \"CredFree\");\n\tCredDeleteW = (CredDeleteWT)GetProcAddress(advapi, \"CredDeleteW\");\n\tif (!CredWriteW || !CredEnumerateW || !CredFree || !CredDeleteW)\n\t\tdie(\"failed to load functions\");\n}\n\nstatic WCHAR *wusername, *password, *protocol, *host, *path, target[1024];\n\nstatic void write_item(const char *what, LPCWSTR wbuf, int wlen)\n{\n\tchar *buf;\n\tint len = WideCharToMultiByte(CP_UTF8, 0, wbuf, wlen, NULL, 0, NULL,\n\t    FALSE);\n\tbuf = xmalloc(len);\n\n\tif (!WideCharToMultiByte(CP_UTF8, 0, wbuf, wlen, buf, len, NULL, FALSE))\n\t\tdie(\"WideCharToMultiByte failed!\");\n\n\tprintf(\"%s=\", what);\n\tfwrite(buf, 1, len, stdout);\n\tputchar('\\n');\n\tfree(buf);\n}\n\n/*\n * Match an (optional) expected string and a delimiter in the target string,\n * consuming the matched text by updating the target pointer.\n */\n\nstatic LPCWSTR wcsstr_last(LPCWSTR str, LPCWSTR find)\n{\n\tLPCWSTR res = NULL, pos;\n\tfor (pos = wcsstr(str, find); pos; pos = wcsstr(pos + 1, find))\n\t\tres = pos;\n\treturn res;\n}\n\nstatic int match_part_with_last(LPCWSTR *ptarget, LPCWSTR want, LPCWSTR delim, int last)\n{\n\tLPCWSTR delim_pos, start = *ptarget;\n\tint len;\n\n\t/* find start of delimiter (or end-of-string if delim is empty) */\n\tif (*delim)\n\t\tdelim_pos = last ? wcsstr_last(start, delim) : wcsstr(start, delim);\n\telse\n\t\tdelim_pos = start + wcslen(start);\n\n\t/*\n\t * match text up to delimiter, or end of string (e.g. the '/' after\n\t * host is optional if not followed by a path)\n\t */\n\tif (delim_pos)\n\t\tlen = delim_pos - start;\n\telse\n\t\tlen = wcslen(start);\n\n\t/* update ptarget if we either found a delimiter or need a match */\n\tif (delim_pos || want)\n\t\t*ptarget = delim_pos ? delim_pos + wcslen(delim) : start + len;\n\n\treturn !want || (!wcsncmp(want, start, len) && !want[len]);\n}\n\nstatic int match_part(LPCWSTR *ptarget, LPCWSTR want, LPCWSTR delim)\n{\n\treturn match_part_with_last(ptarget, want, delim, 0);\n}\n\nstatic int match_part_last(LPCWSTR *ptarget, LPCWSTR want, LPCWSTR delim)\n{\n\treturn match_part_with_last(ptarget, want, delim, 1);\n}\n\nstatic int match_cred(const CREDENTIALW *cred)\n{\n\tLPCWSTR target = cred->TargetName;\n\tif (wusername && wcscmp(wusername, cred->UserName))\n\t\treturn 0;\n\n\treturn match_part(&target, L\"git\", L\":\") &&\n\t\tmatch_part(&target, protocol, L\"://\") &&\n\t\tmatch_part_last(&target, wusername, L\"@\") &&\n\t\tmatch_part(&target, host, L\"/\") &&\n\t\tmatch_part(&target, path, L\"\");\n}\n\nstatic void get_credential(void)\n{\n\tCREDENTIALW **creds;\n\tDWORD num_creds;\n\tint i;\n\n\tif (!CredEnumerateW(L\"git:*\", 0, &num_creds, &creds))\n\t\treturn;\n\n\t/* search for the first credential that matches username */\n\tfor (i = 0; i < num_creds; ++i)\n\t\tif (match_cred(creds[i])) {\n\t\t\twrite_item(\"username\", creds[i]->UserName,\n\t\t\t\twcslen(creds[i]->UserName));\n\t\t\twrite_item(\"password\",\n\t\t\t\t(LPCWSTR)creds[i]->CredentialBlob,\n\t\t\t\tcreds[i]->CredentialBlobSize / sizeof(WCHAR));\n\t\t\tbreak;\n\t\t}\n\n\tCredFree(creds);\n}\n\nstatic void store_credential(void)\n{\n\tCREDENTIALW cred;\n\n\tif (!wusername || !password)\n\t\treturn;\n\n\tcred.Flags = 0;\n\tcred.Type = CRED_TYPE_GENERIC;\n\tcred.TargetName = target;\n\tcred.Comment = L\"saved by git-credential-wincred\";\n\tcred.CredentialBlobSize = (wcslen(password)) * sizeof(WCHAR);\n\tcred.CredentialBlob = (LPVOID)password;\n\tcred.Persist = CRED_PERSIST_LOCAL_MACHINE;\n\tcred.AttributeCount = 0;\n\tcred.Attributes = NULL;\n\tcred.TargetAlias = NULL;\n\tcred.UserName = wusername;\n\n\tif (!CredWriteW(&cred, 0))\n\t\tdie(\"CredWrite failed\");\n}\n\nstatic void erase_credential(void)\n{\n\tCREDENTIALW **creds;\n\tDWORD num_creds;\n\tint i;\n\n\tif (!CredEnumerateW(L\"git:*\", 0, &num_creds, &creds))\n\t\treturn;\n\n\tfor (i = 0; i < num_creds; ++i) {\n\t\tif (match_cred(creds[i]))\n\t\t\tCredDeleteW(creds[i]->TargetName, creds[i]->Type, 0);\n\t}\n\n\tCredFree(creds);\n}\n\nstatic WCHAR *utf8_to_utf16_dup(const char *str)\n{\n\tint wlen = MultiByteToWideChar(CP_UTF8, 0, str, -1, NULL, 0);\n\tWCHAR *wstr = xmalloc(sizeof(WCHAR) * wlen);\n\tMultiByteToWideChar(CP_UTF8, 0, str, -1, wstr, wlen);\n\treturn wstr;\n}\n\nstatic void read_credential(void)\n{\n\tchar buf[1024];\n\n\twhile (fgets(buf, sizeof(buf), stdin)) {\n\t\tchar *v;\n\t\tint len = strlen(buf);\n\t\t/* strip trailing CR / LF */\n\t\twhile (len && strchr(\"\\r\\n\", buf[len - 1]))\n\t\t\tbuf[--len] = 0;\n\n\t\tif (!*buf)\n\t\t\tbreak;\n\n\t\tv = strchr(buf, '=');\n\t\tif (!v)\n\t\t\tdie(\"bad input: %s\", buf);\n\t\t*v++ = '\\0';\n\n\t\tif (!strcmp(buf, \"protocol\"))\n\t\t\tprotocol = utf8_to_utf16_dup(v);\n\t\telse if (!strcmp(buf, \"host\"))\n\t\t\thost = utf8_to_utf16_dup(v);\n\t\telse if (!strcmp(buf, \"path\"))\n\t\t\tpath = utf8_to_utf16_dup(v);\n\t\telse if (!strcmp(buf, \"username\")) {\n\t\t\twusername = utf8_to_utf16_dup(v);\n\t\t} else if (!strcmp(buf, \"password\"))\n\t\t\tpassword = utf8_to_utf16_dup(v);\n\t\telse\n\t\t\tdie(\"unrecognized input\");\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tconst char *usage =\n\t    \"usage: git credential-wincred <get|store|erase>\\n\";\n\n\tif (!argv[1])\n\t\tdie(usage);\n\n\t/* git use binary pipes to avoid CRLF-issues */\n\t_setmode(_fileno(stdin), _O_BINARY);\n\t_setmode(_fileno(stdout), _O_BINARY);\n\n\tread_credential();\n\n\tload_cred_funcs();\n\n\tif (!protocol || !(host || path))\n\t\treturn 0;\n\n\t/* prepare 'target', the unique key for the credential */\n\twcscpy(target, L\"git:\");\n\twcsncat(target, protocol, ARRAY_SIZE(target));\n\twcsncat(target, L\"://\", ARRAY_SIZE(target));\n\tif (wusername) {\n\t\twcsncat(target, wusername, ARRAY_SIZE(target));\n\t\twcsncat(target, L\"@\", ARRAY_SIZE(target));\n\t}\n\tif (host)\n\t\twcsncat(target, host, ARRAY_SIZE(target));\n\tif (path) {\n\t\twcsncat(target, L\"/\", ARRAY_SIZE(target));\n\t\twcsncat(target, path, ARRAY_SIZE(target));\n\t}\n\n\tif (!strcmp(argv[1], \"get\"))\n\t\tget_credential();\n\telse if (!strcmp(argv[1], \"store\"))\n\t\tstore_credential();\n\telse if (!strcmp(argv[1], \"erase\"))\n\t\terase_credential();\n\t/* otherwise, ignore unknown action */\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "006134043a472edd54720d6d4237e9484476d3a3",
  "sha1_ok": true,
  "size": 7847
}
