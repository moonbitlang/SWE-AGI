{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGNsb25lIgogKgogKiBDb3B5cmlnaHQgKGMpIDIwMDcgS3Jpc3RpYW4gSMO4Z3NiZXJnIDxrcmhAcmVkaGF0LmNvbT4sCiAqCQkgMjAwOCBEYW5pZWwgQmFya2Fsb3cgPGJhcmthbG93QGlhYmVydm9uLm9yZz4KICogQmFzZWQgb24gZ2l0LWNvbW1pdC5zaCBieSBKdW5pbyBDIEhhbWFubyBhbmQgTGludXMgVG9ydmFsZHMKICoKICogQ2xvbmUgYSByZXBvc2l0b3J5IGludG8gYSBkaWZmZXJlbnQgZGlyZWN0b3J5IHRoYXQgZG9lcyBub3QgeWV0IGV4aXN0LgogKi8KCiNkZWZpbmUgVVNFX1RIRV9JTkRFWF9DT01QQVRJQklMSVRZX01BQ1JPUwojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAiY29uZmlnLmgiCiNpbmNsdWRlICJsb2NrZmlsZS5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAiZmV0Y2gtcGFjay5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAicmVmc3BlYy5oIgojaW5jbHVkZSAib2JqZWN0LXN0b3JlLmgiCiNpbmNsdWRlICJ0cmVlLmgiCiNpbmNsdWRlICJ0cmVlLXdhbGsuaCIKI2luY2x1ZGUgInVucGFjay10cmVlcy5oIgojaW5jbHVkZSAidHJhbnNwb3J0LmgiCiNpbmNsdWRlICJzdHJidWYuaCIKI2luY2x1ZGUgImRpci5oIgojaW5jbHVkZSAiZGlyLWl0ZXJhdG9yLmgiCiNpbmNsdWRlICJpdGVyYXRvci5oIgojaW5jbHVkZSAic2lnY2hhaW4uaCIKI2luY2x1ZGUgImJyYW5jaC5oIgojaW5jbHVkZSAicmVtb3RlLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAiY29ubmVjdGVkLmgiCiNpbmNsdWRlICJwYWNrZmlsZS5oIgojaW5jbHVkZSAibGlzdC1vYmplY3RzLWZpbHRlci1vcHRpb25zLmgiCgovKgogKiBPdmVyYWxsIEZJWE1FczoKICogIC0gcmVzcGVjdCBEQl9FTlZJUk9OTUVOVCBmb3IgLmdpdC9vYmplY3RzLgogKgogKiBJbXBsZW1lbnRhdGlvbiBub3RlczoKICogIC0gZHJvcHBpbmcgdXNlLXNlcGFyYXRlLXJlbW90ZSBhbmQgbm8tc2VwYXJhdGUtcmVtb3RlIGNvbXBhdGliaWxpdHkKICoKICovCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgYnVpbHRpbl9jbG9uZV91c2FnZVtdID0gewoJTl8oImdpdCBjbG9uZSBbPG9wdGlvbnM+XSBbLS1dIDxyZXBvPiBbPGRpcj5dIiksCglOVUxMCn07CgpzdGF0aWMgaW50IG9wdGlvbl9ub19jaGVja291dCwgb3B0aW9uX2JhcmUsIG9wdGlvbl9taXJyb3IsIG9wdGlvbl9zaW5nbGVfYnJhbmNoID0gLTE7CnN0YXRpYyBpbnQgb3B0aW9uX2xvY2FsID0gLTEsIG9wdGlvbl9ub19oYXJkbGlua3MsIG9wdGlvbl9zaGFyZWQ7CnN0YXRpYyBpbnQgb3B0aW9uX25vX3RhZ3M7CnN0YXRpYyBpbnQgb3B0aW9uX3NoYWxsb3dfc3VibW9kdWxlczsKc3RhdGljIGludCBkZWVwZW47CnN0YXRpYyBjaGFyICpvcHRpb25fdGVtcGxhdGUsICpvcHRpb25fZGVwdGgsICpvcHRpb25fc2luY2U7CnN0YXRpYyBjaGFyICpvcHRpb25fb3JpZ2luID0gTlVMTDsKc3RhdGljIGNoYXIgKm9wdGlvbl9icmFuY2ggPSBOVUxMOwpzdGF0aWMgc3RydWN0IHN0cmluZ19saXN0IG9wdGlvbl9ub3QgPSBTVFJJTkdfTElTVF9JTklUX05PRFVQOwpzdGF0aWMgY29uc3QgY2hhciAqcmVhbF9naXRfZGlyOwpzdGF0aWMgY2hhciAqb3B0aW9uX3VwbG9hZF9wYWNrID0gImdpdC11cGxvYWQtcGFjayI7CnN0YXRpYyBpbnQgb3B0aW9uX3ZlcmJvc2l0eTsKc3RhdGljIGludCBvcHRpb25fcHJvZ3Jlc3MgPSAtMTsKc3RhdGljIGludCBvcHRpb25fc3BhcnNlX2NoZWNrb3V0OwpzdGF0aWMgZW51bSB0cmFuc3BvcnRfZmFtaWx5IGZhbWlseTsKc3RhdGljIHN0cnVjdCBzdHJpbmdfbGlzdCBvcHRpb25fY29uZmlnID0gU1RSSU5HX0xJU1RfSU5JVF9OT0RVUDsKc3RhdGljIHN0cnVjdCBzdHJpbmdfbGlzdCBvcHRpb25fcmVxdWlyZWRfcmVmZXJlbmNlID0gU1RSSU5HX0xJU1RfSU5JVF9OT0RVUDsKc3RhdGljIHN0cnVjdCBzdHJpbmdfbGlzdCBvcHRpb25fb3B0aW9uYWxfcmVmZXJlbmNlID0gU1RSSU5HX0xJU1RfSU5JVF9OT0RVUDsKc3RhdGljIGludCBvcHRpb25fZGlzc29jaWF0ZTsKc3RhdGljIGludCBtYXhfam9icyA9IC0xOwpzdGF0aWMgc3RydWN0IHN0cmluZ19saXN0IG9wdGlvbl9yZWN1cnNlX3N1Ym1vZHVsZXMgPSBTVFJJTkdfTElTVF9JTklUX05PRFVQOwpzdGF0aWMgc3RydWN0IGxpc3Rfb2JqZWN0c19maWx0ZXJfb3B0aW9ucyBmaWx0ZXJfb3B0aW9uczsKc3RhdGljIHN0cnVjdCBzdHJpbmdfbGlzdCBzZXJ2ZXJfb3B0aW9ucyA9IFNUUklOR19MSVNUX0lOSVRfTk9EVVA7CnN0YXRpYyBpbnQgb3B0aW9uX3JlbW90ZV9zdWJtb2R1bGVzOwoKc3RhdGljIGludCByZWN1cnNlX3N1Ym1vZHVsZXNfY2IoY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LAoJCQkJIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglpZiAodW5zZXQpCgkJc3RyaW5nX2xpc3RfY2xlYXIoKHN0cnVjdCBzdHJpbmdfbGlzdCAqKW9wdC0+dmFsdWUsIDApOwoJZWxzZSBpZiAoYXJnKQoJCXN0cmluZ19saXN0X2FwcGVuZCgoc3RydWN0IHN0cmluZ19saXN0ICopb3B0LT52YWx1ZSwgYXJnKTsKCWVsc2UKCQlzdHJpbmdfbGlzdF9hcHBlbmQoKHN0cnVjdCBzdHJpbmdfbGlzdCAqKW9wdC0+dmFsdWUsCgkJCQkgICAoY29uc3QgY2hhciAqKW9wdC0+ZGVmdmFsKTsKCglyZXR1cm4gMDsKfQoKc3RhdGljIHN0cnVjdCBvcHRpb24gYnVpbHRpbl9jbG9uZV9vcHRpb25zW10gPSB7CglPUFRfX1ZFUkJPU0lUWSgmb3B0aW9uX3ZlcmJvc2l0eSksCglPUFRfQk9PTCgwLCAicHJvZ3Jlc3MiLCAmb3B0aW9uX3Byb2dyZXNzLAoJCSBOXygiZm9yY2UgcHJvZ3Jlc3MgcmVwb3J0aW5nIikpLAoJT1BUX0JPT0woJ24nLCAibm8tY2hlY2tvdXQiLCAmb3B0aW9uX25vX2NoZWNrb3V0LAoJCSBOXygiZG9uJ3QgY3JlYXRlIGEgY2hlY2tvdXQiKSksCglPUFRfQk9PTCgwLCAiYmFyZSIsICZvcHRpb25fYmFyZSwgTl8oImNyZWF0ZSBhIGJhcmUgcmVwb3NpdG9yeSIpKSwKCU9QVF9ISURERU5fQk9PTCgwLCAibmFrZWQiLCAmb3B0aW9uX2JhcmUsCgkJCU5fKCJjcmVhdGUgYSBiYXJlIHJlcG9zaXRvcnkiKSksCglPUFRfQk9PTCgwLCAibWlycm9yIiwgJm9wdGlvbl9taXJyb3IsCgkJIE5fKCJjcmVhdGUgYSBtaXJyb3IgcmVwb3NpdG9yeSAoaW1wbGllcyBiYXJlKSIpKSwKCU9QVF9CT09MKCdsJywgImxvY2FsIiwgJm9wdGlvbl9sb2NhbCwKCQlOXygidG8gY2xvbmUgZnJvbSBhIGxvY2FsIHJlcG9zaXRvcnkiKSksCglPUFRfQk9PTCgwLCAibm8taGFyZGxpbmtzIiwgJm9wdGlvbl9ub19oYXJkbGlua3MsCgkJICAgIE5fKCJkb24ndCB1c2UgbG9jYWwgaGFyZGxpbmtzLCBhbHdheXMgY29weSIpKSwKCU9QVF9CT09MKCdzJywgInNoYXJlZCIsICZvcHRpb25fc2hhcmVkLAoJCSAgICBOXygic2V0dXAgYXMgc2hhcmVkIHJlcG9zaXRvcnkiKSksCglPUFRfQUxJQVMoMCwgInJlY3Vyc2l2ZSIsICJyZWN1cnNlLXN1Ym1vZHVsZXMiKSwKCXsgT1BUSU9OX0NBTExCQUNLLCAwLCAicmVjdXJzZS1zdWJtb2R1bGVzIiwgJm9wdGlvbl9yZWN1cnNlX3N1Ym1vZHVsZXMsCgkgIE5fKCJwYXRoc3BlYyIpLCBOXygiaW5pdGlhbGl6ZSBzdWJtb2R1bGVzIGluIHRoZSBjbG9uZSIpLAoJICBQQVJTRV9PUFRfT1BUQVJHLCByZWN1cnNlX3N1Ym1vZHVsZXNfY2IsIChpbnRwdHJfdCkiLiIgfSwKCU9QVF9JTlRFR0VSKCdqJywgImpvYnMiLCAmbWF4X2pvYnMsCgkJICAgIE5fKCJudW1iZXIgb2Ygc3VibW9kdWxlcyBjbG9uZWQgaW4gcGFyYWxsZWwiKSksCglPUFRfU1RSSU5HKDAsICJ0ZW1wbGF0ZSIsICZvcHRpb25fdGVtcGxhdGUsIE5fKCJ0ZW1wbGF0ZS1kaXJlY3RvcnkiKSwKCQkgICBOXygiZGlyZWN0b3J5IGZyb20gd2hpY2ggdGVtcGxhdGVzIHdpbGwgYmUgdXNlZCIpKSwKCU9QVF9TVFJJTkdfTElTVCgwLCAicmVmZXJlbmNlIiwgJm9wdGlvbl9yZXF1aXJlZF9yZWZlcmVuY2UsIE5fKCJyZXBvIiksCgkJCU5fKCJyZWZlcmVuY2UgcmVwb3NpdG9yeSIpKSwKCU9QVF9TVFJJTkdfTElTVCgwLCAicmVmZXJlbmNlLWlmLWFibGUiLCAmb3B0aW9uX29wdGlvbmFsX3JlZmVyZW5jZSwKCQkJTl8oInJlcG8iKSwgTl8oInJlZmVyZW5jZSByZXBvc2l0b3J5IikpLAoJT1BUX0JPT0woMCwgImRpc3NvY2lhdGUiLCAmb3B0aW9uX2Rpc3NvY2lhdGUsCgkJIE5fKCJ1c2UgLS1yZWZlcmVuY2Ugb25seSB3aGlsZSBjbG9uaW5nIikpLAoJT1BUX1NUUklORygnbycsICJvcmlnaW4iLCAmb3B0aW9uX29yaWdpbiwgTl8oIm5hbWUiKSwKCQkgICBOXygidXNlIDxuYW1lPiBpbnN0ZWFkIG9mICdvcmlnaW4nIHRvIHRyYWNrIHVwc3RyZWFtIikpLAoJT1BUX1NUUklORygnYicsICJicmFuY2giLCAmb3B0aW9uX2JyYW5jaCwgTl8oImJyYW5jaCIpLAoJCSAgIE5fKCJjaGVja291dCA8YnJhbmNoPiBpbnN0ZWFkIG9mIHRoZSByZW1vdGUncyBIRUFEIikpLAoJT1BUX1NUUklORygndScsICJ1cGxvYWQtcGFjayIsICZvcHRpb25fdXBsb2FkX3BhY2ssIE5fKCJwYXRoIiksCgkJICAgTl8oInBhdGggdG8gZ2l0LXVwbG9hZC1wYWNrIG9uIHRoZSByZW1vdGUiKSksCglPUFRfU1RSSU5HKDAsICJkZXB0aCIsICZvcHRpb25fZGVwdGgsIE5fKCJkZXB0aCIpLAoJCSAgICBOXygiY3JlYXRlIGEgc2hhbGxvdyBjbG9uZSBvZiB0aGF0IGRlcHRoIikpLAoJT1BUX1NUUklORygwLCAic2hhbGxvdy1zaW5jZSIsICZvcHRpb25fc2luY2UsIE5fKCJ0aW1lIiksCgkJICAgIE5fKCJjcmVhdGUgYSBzaGFsbG93IGNsb25lIHNpbmNlIGEgc3BlY2lmaWMgdGltZSIpKSwKCU9QVF9TVFJJTkdfTElTVCgwLCAic2hhbGxvdy1leGNsdWRlIiwgJm9wdGlvbl9ub3QsIE5fKCJyZXZpc2lvbiIpLAoJCQlOXygiZGVlcGVuIGhpc3Rvcnkgb2Ygc2hhbGxvdyBjbG9uZSwgZXhjbHVkaW5nIHJldiIpKSwKCU9QVF9CT09MKDAsICJzaW5nbGUtYnJhbmNoIiwgJm9wdGlvbl9zaW5nbGVfYnJhbmNoLAoJCSAgICBOXygiY2xvbmUgb25seSBvbmUgYnJhbmNoLCBIRUFEIG9yIC0tYnJhbmNoIikpLAoJT1BUX0JPT0woMCwgIm5vLXRhZ3MiLCAmb3B0aW9uX25vX3RhZ3MsCgkJIE5fKCJkb24ndCBjbG9uZSBhbnkgdGFncywgYW5kIG1ha2UgbGF0ZXIgZmV0Y2hlcyBub3QgdG8gZm9sbG93IHRoZW0iKSksCglPUFRfQk9PTCgwLCAic2hhbGxvdy1zdWJtb2R1bGVzIiwgJm9wdGlvbl9zaGFsbG93X3N1Ym1vZHVsZXMsCgkJICAgIE5fKCJhbnkgY2xvbmVkIHN1Ym1vZHVsZXMgd2lsbCBiZSBzaGFsbG93IikpLAoJT1BUX1NUUklORygwLCAic2VwYXJhdGUtZ2l0LWRpciIsICZyZWFsX2dpdF9kaXIsIE5fKCJnaXRkaXIiKSwKCQkgICBOXygic2VwYXJhdGUgZ2l0IGRpciBmcm9tIHdvcmtpbmcgdHJlZSIpKSwKCU9QVF9TVFJJTkdfTElTVCgnYycsICJjb25maWciLCAmb3B0aW9uX2NvbmZpZywgTl8oImtleT12YWx1ZSIpLAoJCQlOXygic2V0IGNvbmZpZyBpbnNpZGUgdGhlIG5ldyByZXBvc2l0b3J5IikpLAoJT1BUX1NUUklOR19MSVNUKDAsICJzZXJ2ZXItb3B0aW9uIiwgJnNlcnZlcl9vcHRpb25zLAoJCQlOXygic2VydmVyLXNwZWNpZmljIiksIE5fKCJvcHRpb24gdG8gdHJhbnNtaXQiKSksCglPUFRfU0VUX0lOVCgnNCcsICJpcHY0IiwgJmZhbWlseSwgTl8oInVzZSBJUHY0IGFkZHJlc3NlcyBvbmx5IiksCgkJCVRSQU5TUE9SVF9GQU1JTFlfSVBWNCksCglPUFRfU0VUX0lOVCgnNicsICJpcHY2IiwgJmZhbWlseSwgTl8oInVzZSBJUHY2IGFkZHJlc3NlcyBvbmx5IiksCgkJCVRSQU5TUE9SVF9GQU1JTFlfSVBWNiksCglPUFRfUEFSU0VfTElTVF9PQkpFQ1RTX0ZJTFRFUigmZmlsdGVyX29wdGlvbnMpLAoJT1BUX0JPT0woMCwgInJlbW90ZS1zdWJtb2R1bGVzIiwgJm9wdGlvbl9yZW1vdGVfc3VibW9kdWxlcywKCQkgICAgTl8oImFueSBjbG9uZWQgc3VibW9kdWxlcyB3aWxsIHVzZSB0aGVpciByZW1vdGUtdHJhY2tpbmcgYnJhbmNoIikpLAoJT1BUX0JPT0woMCwgInNwYXJzZSIsICZvcHRpb25fc3BhcnNlX2NoZWNrb3V0LAoJCSAgICBOXygiaW5pdGlhbGl6ZSBzcGFyc2UtY2hlY2tvdXQgZmlsZSB0byBpbmNsdWRlIG9ubHkgZmlsZXMgYXQgcm9vdCIpKSwKCU9QVF9FTkQoKQp9OwoKc3RhdGljIGNvbnN0IGNoYXIgKmdldF9yZXBvX3BhdGhfMShzdHJ1Y3Qgc3RyYnVmICpwYXRoLCBpbnQgKmlzX2J1bmRsZSkKewoJc3RhdGljIGNoYXIgKnN1ZmZpeFtdID0geyAiLy5naXQiLCAiIiwgIi5naXQvLmdpdCIsICIuZ2l0IiB9OwoJc3RhdGljIGNoYXIgKmJ1bmRsZV9zdWZmaXhbXSA9IHsgIi5idW5kbGUiLCAiIiB9OwoJc2l6ZV90IGJhc2VsZW4gPSBwYXRoLT5sZW47CglzdHJ1Y3Qgc3RhdCBzdDsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBBUlJBWV9TSVpFKHN1ZmZpeCk7IGkrKykgewoJCXN0cmJ1Zl9zZXRsZW4ocGF0aCwgYmFzZWxlbik7CgkJc3RyYnVmX2FkZHN0cihwYXRoLCBzdWZmaXhbaV0pOwoJCWlmIChzdGF0KHBhdGgtPmJ1ZiwgJnN0KSkKCQkJY29udGludWU7CgkJaWYgKFNfSVNESVIoc3Quc3RfbW9kZSkgJiYgaXNfZ2l0X2RpcmVjdG9yeShwYXRoLT5idWYpKSB7CgkJCSppc19idW5kbGUgPSAwOwoJCQlyZXR1cm4gcGF0aC0+YnVmOwoJCX0gZWxzZSBpZiAoU19JU1JFRyhzdC5zdF9tb2RlKSAmJiBzdC5zdF9zaXplID4gOCkgewoJCQkvKiBJcyBpdCBhICJnaXRmaWxlIj8gKi8KCQkJY2hhciBzaWduYXR1cmVbOF07CgkJCWNvbnN0IGNoYXIgKmRzdDsKCQkJaW50IGxlbiwgZmQgPSBvcGVuKHBhdGgtPmJ1ZiwgT19SRE9OTFkpOwoJCQlpZiAoZmQgPCAwKQoJCQkJY29udGludWU7CgkJCWxlbiA9IHJlYWRfaW5fZnVsbChmZCwgc2lnbmF0dXJlLCA4KTsKCQkJY2xvc2UoZmQpOwoJCQlpZiAobGVuICE9IDggfHwgc3RybmNtcChzaWduYXR1cmUsICJnaXRkaXI6ICIsIDgpKQoJCQkJY29udGludWU7CgkJCWRzdCA9IHJlYWRfZ2l0ZmlsZShwYXRoLT5idWYpOwoJCQlpZiAoZHN0KSB7CgkJCQkqaXNfYnVuZGxlID0gMDsKCQkJCXJldHVybiBkc3Q7CgkJCX0KCQl9Cgl9CgoJZm9yIChpID0gMDsgaSA8IEFSUkFZX1NJWkUoYnVuZGxlX3N1ZmZpeCk7IGkrKykgewoJCXN0cmJ1Zl9zZXRsZW4ocGF0aCwgYmFzZWxlbik7CgkJc3RyYnVmX2FkZHN0cihwYXRoLCBidW5kbGVfc3VmZml4W2ldKTsKCQlpZiAoIXN0YXQocGF0aC0+YnVmLCAmc3QpICYmIFNfSVNSRUcoc3Quc3RfbW9kZSkpIHsKCQkJKmlzX2J1bmRsZSA9IDE7CgkJCXJldHVybiBwYXRoLT5idWY7CgkJfQoJfQoKCXJldHVybiBOVUxMOwp9CgpzdGF0aWMgY2hhciAqZ2V0X3JlcG9fcGF0aChjb25zdCBjaGFyICpyZXBvLCBpbnQgKmlzX2J1bmRsZSkKewoJc3RydWN0IHN0cmJ1ZiBwYXRoID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpyYXc7CgljaGFyICpjYW5vbjsKCglzdHJidWZfYWRkc3RyKCZwYXRoLCByZXBvKTsKCXJhdyA9IGdldF9yZXBvX3BhdGhfMSgmcGF0aCwgaXNfYnVuZGxlKTsKCWNhbm9uID0gcmF3ID8gYWJzb2x1dGVfcGF0aGR1cChyYXcpIDogTlVMTDsKCXN0cmJ1Zl9yZWxlYXNlKCZwYXRoKTsKCXJldHVybiBjYW5vbjsKfQoKc3RhdGljIGNoYXIgKmd1ZXNzX2Rpcl9uYW1lKGNvbnN0IGNoYXIgKnJlcG8sIGludCBpc19idW5kbGUsIGludCBpc19iYXJlKQp7Cgljb25zdCBjaGFyICplbmQgPSByZXBvICsgc3RybGVuKHJlcG8pLCAqc3RhcnQsICpwdHI7CglzaXplX3QgbGVuOwoJY2hhciAqZGlyOwoKCS8qCgkgKiBTa2lwIHNjaGVtZS4KCSAqLwoJc3RhcnQgPSBzdHJzdHIocmVwbywgIjovLyIpOwoJaWYgKHN0YXJ0ID09IE5VTEwpCgkJc3RhcnQgPSByZXBvOwoJZWxzZQoJCXN0YXJ0ICs9IDM7CgoJLyoKCSAqIFNraXAgYXV0aGVudGljYXRpb24gZGF0YS4gVGhlIHN0cmlwcGluZyBkb2VzIGhhcHBlbgoJICogZ3JlZWRpbHksIHN1Y2ggdGhhdCB3ZSBzdHJpcCB1cCB0byB0aGUgbGFzdCAnQCcgaW5zaWRlCgkgKiB0aGUgaG9zdCBwYXJ0LgoJICovCglmb3IgKHB0ciA9IHN0YXJ0OyBwdHIgPCBlbmQgJiYgIWlzX2Rpcl9zZXAoKnB0cik7IHB0cisrKSB7CgkJaWYgKCpwdHIgPT0gJ0AnKQoJCQlzdGFydCA9IHB0ciArIDE7Cgl9CgoJLyoKCSAqIFN0cmlwIHRyYWlsaW5nIHNwYWNlcywgc2xhc2hlcyBhbmQgLy5naXQKCSAqLwoJd2hpbGUgKHN0YXJ0IDwgZW5kICYmIChpc19kaXJfc2VwKGVuZFstMV0pIHx8IGlzc3BhY2UoZW5kWy0xXSkpKQoJCWVuZC0tOwoJaWYgKGVuZCAtIHN0YXJ0ID4gNSAmJiBpc19kaXJfc2VwKGVuZFstNV0pICYmCgkgICAgIXN0cm5jbXAoZW5kIC0gNCwgIi5naXQiLCA0KSkgewoJCWVuZCAtPSA1OwoJCXdoaWxlIChzdGFydCA8IGVuZCAmJiBpc19kaXJfc2VwKGVuZFstMV0pKQoJCQllbmQtLTsKCX0KCgkvKgoJICogU3RyaXAgdHJhaWxpbmcgcG9ydCBudW1iZXIgaWYgd2UndmUgZ290IG9ubHkgYQoJICogaG9zdG5hbWUgKHRoYXQgaXMsIHRoZXJlIGlzIG5vIGRpciBzZXBhcmF0b3IgYnV0IGEKCSAqIGNvbG9uKS4gVGhpcyBjaGVjayBpcyByZXF1aXJlZCBzdWNoIHRoYXQgd2UgZG8gbm90CgkgKiBzdHJpcCBVUkkncyBsaWtlICcvZm9vL2JhcjoyMjIyLmdpdCcsIHdoaWNoIHNob3VsZAoJICogcmVzdWx0IGluIGEgZGlyICcyMjIyJyBiZWluZyBndWVzc2VkIGR1ZSB0byBiYWNrd2FyZHMKCSAqIGNvbXBhdGliaWxpdHkuCgkgKi8KCWlmIChtZW1jaHIoc3RhcnQsICcvJywgZW5kIC0gc3RhcnQpID09IE5VTEwKCSAgICAmJiBtZW1jaHIoc3RhcnQsICc6JywgZW5kIC0gc3RhcnQpICE9IE5VTEwpIHsKCQlwdHIgPSBlbmQ7CgkJd2hpbGUgKHN0YXJ0IDwgcHRyICYmIGlzZGlnaXQocHRyWy0xXSkgJiYgcHRyWy0xXSAhPSAnOicpCgkJCXB0ci0tOwoJCWlmIChzdGFydCA8IHB0ciAmJiBwdHJbLTFdID09ICc6JykKCQkJZW5kID0gcHRyIC0gMTsKCX0KCgkvKgoJICogRmluZCBsYXN0IGNvbXBvbmVudC4gVG8gcmVtYWluIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdlCgkgKiBhbHNvIHJlZ2FyZCBjb2xvbnMgYXMgcGF0aCBzZXBhcmF0b3JzLCBzdWNoIHRoYXQKCSAqIGNsb25pbmcgYSByZXBvc2l0b3J5ICdmb286YmFyLmdpdCcgd291bGQgcmVzdWx0IGluIGEKCSAqIGRpcmVjdG9yeSAnYmFyJyBiZWluZyBndWVzc2VkLgoJICovCglwdHIgPSBlbmQ7Cgl3aGlsZSAoc3RhcnQgPCBwdHIgJiYgIWlzX2Rpcl9zZXAocHRyWy0xXSkgJiYgcHRyWy0xXSAhPSAnOicpCgkJcHRyLS07CglzdGFydCA9IHB0cjsKCgkvKgoJICogU3RyaXAgLntidW5kbGUsZ2l0fS4KCSAqLwoJbGVuID0gZW5kIC0gc3RhcnQ7CglzdHJpcF9zdWZmaXhfbWVtKHN0YXJ0LCAmbGVuLCBpc19idW5kbGUgPyAiLmJ1bmRsZSIgOiAiLmdpdCIpOwoKCWlmICghbGVuIHx8IChsZW4gPT0gMSAmJiAqc3RhcnQgPT0gJy8nKSkKCQlkaWUoXygiTm8gZGlyZWN0b3J5IG5hbWUgY291bGQgYmUgZ3Vlc3NlZC5cbiIKCQkgICAgICAiUGxlYXNlIHNwZWNpZnkgYSBkaXJlY3Rvcnkgb24gdGhlIGNvbW1hbmQgbGluZSIpKTsKCglpZiAoaXNfYmFyZSkKCQlkaXIgPSB4c3RyZm10KCIlLipzLmdpdCIsIChpbnQpbGVuLCBzdGFydCk7CgllbHNlCgkJZGlyID0geHN0cm5kdXAoc3RhcnQsIGxlbik7CgkvKgoJICogUmVwbGFjZSBzZXF1ZW5jZXMgb2YgJ2NvbnRyb2wnIGNoYXJhY3RlcnMgYW5kIHdoaXRlc3BhY2UKCSAqIHdpdGggb25lIGFzY2lpIHNwYWNlLCByZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzLgoJICovCglpZiAoKmRpcikgewoJCWNoYXIgKm91dCA9IGRpcjsKCQlpbnQgcHJldl9zcGFjZSA9IDEgLyogc3RyaXAgbGVhZGluZyB3aGl0ZXNwYWNlICovOwoJCWZvciAoZW5kID0gZGlyOyAqZW5kOyArK2VuZCkgewoJCQljaGFyIGNoID0gKmVuZDsKCQkJaWYgKCh1bnNpZ25lZCBjaGFyKWNoIDwgJ1x4MjAnKQoJCQkJY2ggPSAnXHgyMCc7CgkJCWlmIChpc3NwYWNlKGNoKSkgewoJCQkJaWYgKHByZXZfc3BhY2UpCgkJCQkJY29udGludWU7CgkJCQlwcmV2X3NwYWNlID0gMTsKCQkJfSBlbHNlCgkJCQlwcmV2X3NwYWNlID0gMDsKCQkJKm91dCsrID0gY2g7CgkJfQoJCSpvdXQgPSAnXDAnOwoJCWlmIChvdXQgPiBkaXIgJiYgcHJldl9zcGFjZSkKCQkJb3V0Wy0xXSA9ICdcMCc7Cgl9CglyZXR1cm4gZGlyOwp9CgpzdGF0aWMgdm9pZCBzdHJpcF90cmFpbGluZ19zbGFzaGVzKGNoYXIgKmRpcikKewoJY2hhciAqZW5kID0gZGlyICsgc3RybGVuKGRpcik7CgoJd2hpbGUgKGRpciA8IGVuZCAtIDEgJiYgaXNfZGlyX3NlcChlbmRbLTFdKSkKCQllbmQtLTsKCSplbmQgPSAnXDAnOwp9CgpzdGF0aWMgaW50IGFkZF9vbmVfcmVmZXJlbmNlKHN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3Qgc3RyYnVmIGVyciA9IFNUUkJVRl9JTklUOwoJaW50ICpyZXF1aXJlZCA9IGNiX2RhdGE7CgljaGFyICpyZWZfZ2l0ID0gY29tcHV0ZV9hbHRlcm5hdGVfcGF0aChpdGVtLT5zdHJpbmcsICZlcnIpOwoKCWlmICghcmVmX2dpdCkgewoJCWlmICgqcmVxdWlyZWQpCgkJCWRpZSgiJXMiLCBlcnIuYnVmKTsKCQllbHNlCgkJCWZwcmludGYoc3RkZXJyLAoJCQkJXygiaW5mbzogQ291bGQgbm90IGFkZCBhbHRlcm5hdGUgZm9yICclcyc6ICVzXG4iKSwKCQkJCWl0ZW0tPnN0cmluZywgZXJyLmJ1Zik7Cgl9IGVsc2UgewoJCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCQlzdHJidWZfYWRkZigmc2IsICIlcy9vYmplY3RzIiwgcmVmX2dpdCk7CgkJYWRkX3RvX2FsdGVybmF0ZXNfZmlsZShzYi5idWYpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZzYik7Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJmVycik7CglmcmVlKHJlZl9naXQpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHNldHVwX3JlZmVyZW5jZSh2b2lkKQp7CglpbnQgcmVxdWlyZWQgPSAxOwoJZm9yX2VhY2hfc3RyaW5nX2xpc3QoJm9wdGlvbl9yZXF1aXJlZF9yZWZlcmVuY2UsCgkJCSAgICAgYWRkX29uZV9yZWZlcmVuY2UsICZyZXF1aXJlZCk7CglyZXF1aXJlZCA9IDA7Cglmb3JfZWFjaF9zdHJpbmdfbGlzdCgmb3B0aW9uX29wdGlvbmFsX3JlZmVyZW5jZSwKCQkJICAgICBhZGRfb25lX3JlZmVyZW5jZSwgJnJlcXVpcmVkKTsKfQoKc3RhdGljIHZvaWQgY29weV9hbHRlcm5hdGVzKHN0cnVjdCBzdHJidWYgKnNyYywgY29uc3QgY2hhciAqc3JjX3JlcG8pCnsKCS8qCgkgKiBSZWFkIGZyb20gdGhlIHNvdXJjZSBvYmplY3RzL2luZm8vYWx0ZXJuYXRlcyBmaWxlCgkgKiBhbmQgY29weSB0aGUgZW50cmllcyB0byBjb3JyZXNwb25kaW5nIGZpbGUgaW4gdGhlCgkgKiBkZXN0aW5hdGlvbiByZXBvc2l0b3J5IHdpdGggYWRkX3RvX2FsdGVybmF0ZXNfZmlsZSgpLgoJICogQm90aCBzcmMgYW5kIGRzdCBoYXZlICIkcGF0aC9vYmplY3RzL2luZm8vYWx0ZXJuYXRlcyIuCgkgKgoJICogSW5zdGVhZCBvZiBjb3B5aW5nIGJpdC1mb3ItYml0IGZyb20gdGhlIG9yaWdpbmFsLAoJICogd2UgbmVlZCB0byBhcHBlbmQgdG8gZXhpc3Rpbmcgb25lIHNvIHRoYXQgdGhlIGFscmVhZHkKCSAqIGNyZWF0ZWQgZW50cnkgdmlhICJjbG9uZSAtcyIgaXMgbm90IGxvc3QsIGFuZCBhbHNvCgkgKiB0byB0dXJuIGVudHJpZXMgd2l0aCBwYXRocyByZWxhdGl2ZSB0byB0aGUgb3JpZ2luYWwKCSAqIGFic29sdXRlLCBzbyB0aGF0IHRoZXkgY2FuIGJlIHVzZWQgaW4gdGhlIG5ldyByZXBvc2l0b3J5LgoJICovCglGSUxFICppbiA9IHhmb3BlbihzcmMtPmJ1ZiwgInIiKTsKCXN0cnVjdCBzdHJidWYgbGluZSA9IFNUUkJVRl9JTklUOwoKCXdoaWxlIChzdHJidWZfZ2V0bGluZSgmbGluZSwgaW4pICE9IEVPRikgewoJCWNoYXIgKmFic19wYXRoOwoJCWlmICghbGluZS5sZW4gfHwgbGluZS5idWZbMF0gPT0gJyMnKQoJCQljb250aW51ZTsKCQlpZiAoaXNfYWJzb2x1dGVfcGF0aChsaW5lLmJ1ZikpIHsKCQkJYWRkX3RvX2FsdGVybmF0ZXNfZmlsZShsaW5lLmJ1Zik7CgkJCWNvbnRpbnVlOwoJCX0KCQlhYnNfcGF0aCA9IG1rcGF0aGR1cCgiJXMvb2JqZWN0cy8lcyIsIHNyY19yZXBvLCBsaW5lLmJ1Zik7CgkJaWYgKCFub3JtYWxpemVfcGF0aF9jb3B5KGFic19wYXRoLCBhYnNfcGF0aCkpCgkJCWFkZF90b19hbHRlcm5hdGVzX2ZpbGUoYWJzX3BhdGgpOwoJCWVsc2UKCQkJd2FybmluZygic2tpcHBpbmcgaW52YWxpZCByZWxhdGl2ZSBhbHRlcm5hdGU6ICVzLyVzIiwKCQkJCXNyY19yZXBvLCBsaW5lLmJ1Zik7CgkJZnJlZShhYnNfcGF0aCk7Cgl9CglzdHJidWZfcmVsZWFzZSgmbGluZSk7CglmY2xvc2UoaW4pOwp9CgpzdGF0aWMgdm9pZCBta2Rpcl9pZl9taXNzaW5nKGNvbnN0IGNoYXIgKnBhdGhuYW1lLCBtb2RlX3QgbW9kZSkKewoJc3RydWN0IHN0YXQgc3Q7CgoJaWYgKCFta2RpcihwYXRobmFtZSwgbW9kZSkpCgkJcmV0dXJuOwoKCWlmIChlcnJubyAhPSBFRVhJU1QpCgkJZGllX2Vycm5vKF8oImZhaWxlZCB0byBjcmVhdGUgZGlyZWN0b3J5ICclcyciKSwgcGF0aG5hbWUpOwoJZWxzZSBpZiAoc3RhdChwYXRobmFtZSwgJnN0KSkKCQlkaWVfZXJybm8oXygiZmFpbGVkIHRvIHN0YXQgJyVzJyIpLCBwYXRobmFtZSk7CgllbHNlIGlmICghU19JU0RJUihzdC5zdF9tb2RlKSkKCQlkaWUoXygiJXMgZXhpc3RzIGFuZCBpcyBub3QgYSBkaXJlY3RvcnkiKSwgcGF0aG5hbWUpOwp9CgpzdGF0aWMgdm9pZCBjb3B5X29yX2xpbmtfZGlyZWN0b3J5KHN0cnVjdCBzdHJidWYgKnNyYywgc3RydWN0IHN0cmJ1ZiAqZGVzdCwKCQkJCSAgIGNvbnN0IGNoYXIgKnNyY19yZXBvKQp7CglpbnQgc3JjX2xlbiwgZGVzdF9sZW47CglzdHJ1Y3QgZGlyX2l0ZXJhdG9yICppdGVyOwoJaW50IGl0ZXJfc3RhdHVzOwoJdW5zaWduZWQgaW50IGZsYWdzOwoKCW1rZGlyX2lmX21pc3NpbmcoZGVzdC0+YnVmLCAwNzc3KTsKCglmbGFncyA9IERJUl9JVEVSQVRPUl9QRURBTlRJQyB8IERJUl9JVEVSQVRPUl9GT0xMT1dfU1lNTElOS1M7CglpdGVyID0gZGlyX2l0ZXJhdG9yX2JlZ2luKHNyYy0+YnVmLCBmbGFncyk7CgoJaWYgKCFpdGVyKQoJCWRpZV9lcnJubyhfKCJmYWlsZWQgdG8gc3RhcnQgaXRlcmF0b3Igb3ZlciAnJXMnIiksIHNyYy0+YnVmKTsKCglzdHJidWZfYWRkY2goc3JjLCAnLycpOwoJc3JjX2xlbiA9IHNyYy0+bGVuOwoJc3RyYnVmX2FkZGNoKGRlc3QsICcvJyk7CglkZXN0X2xlbiA9IGRlc3QtPmxlbjsKCgl3aGlsZSAoKGl0ZXJfc3RhdHVzID0gZGlyX2l0ZXJhdG9yX2FkdmFuY2UoaXRlcikpID09IElURVJfT0spIHsKCQlzdHJidWZfc2V0bGVuKHNyYywgc3JjX2xlbik7CgkJc3RyYnVmX2FkZHN0cihzcmMsIGl0ZXItPnJlbGF0aXZlX3BhdGgpOwoJCXN0cmJ1Zl9zZXRsZW4oZGVzdCwgZGVzdF9sZW4pOwoJCXN0cmJ1Zl9hZGRzdHIoZGVzdCwgaXRlci0+cmVsYXRpdmVfcGF0aCk7CgoJCWlmIChTX0lTRElSKGl0ZXItPnN0LnN0X21vZGUpKSB7CgkJCW1rZGlyX2lmX21pc3NpbmcoZGVzdC0+YnVmLCAwNzc3KTsKCQkJY29udGludWU7CgkJfQoKCQkvKiBGaWxlcyB0aGF0IGNhbm5vdCBiZSBjb3BpZWQgYml0LWZvci1iaXQuLi4gKi8KCQlpZiAoIWZzcGF0aGNtcChpdGVyLT5yZWxhdGl2ZV9wYXRoLCAiaW5mby9hbHRlcm5hdGVzIikpIHsKCQkJY29weV9hbHRlcm5hdGVzKHNyYywgc3JjX3JlcG8pOwoJCQljb250aW51ZTsKCQl9CgoJCWlmICh1bmxpbmsoZGVzdC0+YnVmKSAmJiBlcnJubyAhPSBFTk9FTlQpCgkJCWRpZV9lcnJubyhfKCJmYWlsZWQgdG8gdW5saW5rICclcyciKSwgZGVzdC0+YnVmKTsKCQlpZiAoIW9wdGlvbl9ub19oYXJkbGlua3MpIHsKCQkJaWYgKCFsaW5rKHJlYWxfcGF0aChzcmMtPmJ1ZiksIGRlc3QtPmJ1ZikpCgkJCQljb250aW51ZTsKCQkJaWYgKG9wdGlvbl9sb2NhbCA+IDApCgkJCQlkaWVfZXJybm8oXygiZmFpbGVkIHRvIGNyZWF0ZSBsaW5rICclcyciKSwgZGVzdC0+YnVmKTsKCQkJb3B0aW9uX25vX2hhcmRsaW5rcyA9IDE7CgkJfQoJCWlmIChjb3B5X2ZpbGVfd2l0aF90aW1lKGRlc3QtPmJ1Ziwgc3JjLT5idWYsIDA2NjYpKQoJCQlkaWVfZXJybm8oXygiZmFpbGVkIHRvIGNvcHkgZmlsZSB0byAnJXMnIiksIGRlc3QtPmJ1Zik7Cgl9CgoJaWYgKGl0ZXJfc3RhdHVzICE9IElURVJfRE9ORSkgewoJCXN0cmJ1Zl9zZXRsZW4oc3JjLCBzcmNfbGVuKTsKCQlkaWUoXygiZmFpbGVkIHRvIGl0ZXJhdGUgb3ZlciAnJXMnIiksIHNyYy0+YnVmKTsKCX0KfQoKc3RhdGljIHZvaWQgY2xvbmVfbG9jYWwoY29uc3QgY2hhciAqc3JjX3JlcG8sIGNvbnN0IGNoYXIgKmRlc3RfcmVwbykKewoJaWYgKG9wdGlvbl9zaGFyZWQpIHsKCQlzdHJ1Y3Qgc3RyYnVmIGFsdCA9IFNUUkJVRl9JTklUOwoJCWdldF9jb21tb25fZGlyKCZhbHQsIHNyY19yZXBvKTsKCQlzdHJidWZfYWRkc3RyKCZhbHQsICIvb2JqZWN0cyIpOwoJCWFkZF90b19hbHRlcm5hdGVzX2ZpbGUoYWx0LmJ1Zik7CgkJc3RyYnVmX3JlbGVhc2UoJmFsdCk7Cgl9IGVsc2UgewoJCXN0cnVjdCBzdHJidWYgc3JjID0gU1RSQlVGX0lOSVQ7CgkJc3RydWN0IHN0cmJ1ZiBkZXN0ID0gU1RSQlVGX0lOSVQ7CgkJZ2V0X2NvbW1vbl9kaXIoJnNyYywgc3JjX3JlcG8pOwoJCWdldF9jb21tb25fZGlyKCZkZXN0LCBkZXN0X3JlcG8pOwoJCXN0cmJ1Zl9hZGRzdHIoJnNyYywgIi9vYmplY3RzIik7CgkJc3RyYnVmX2FkZHN0cigmZGVzdCwgIi9vYmplY3RzIik7CgkJY29weV9vcl9saW5rX2RpcmVjdG9yeSgmc3JjLCAmZGVzdCwgc3JjX3JlcG8pOwoJCXN0cmJ1Zl9yZWxlYXNlKCZzcmMpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZkZXN0KTsKCX0KCglpZiAoMCA8PSBvcHRpb25fdmVyYm9zaXR5KQoJCWZwcmludGYoc3RkZXJyLCBfKCJkb25lLlxuIikpOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqanVua193b3JrX3RyZWU7CnN0YXRpYyBpbnQganVua193b3JrX3RyZWVfZmxhZ3M7CnN0YXRpYyBjb25zdCBjaGFyICpqdW5rX2dpdF9kaXI7CnN0YXRpYyBpbnQganVua19naXRfZGlyX2ZsYWdzOwpzdGF0aWMgZW51bSB7CglKVU5LX0xFQVZFX05PTkUsCglKVU5LX0xFQVZFX1JFUE8sCglKVU5LX0xFQVZFX0FMTAp9IGp1bmtfbW9kZSA9IEpVTktfTEVBVkVfTk9ORTsKCnN0YXRpYyBjb25zdCBjaGFyIGp1bmtfbGVhdmVfcmVwb19tc2dbXSA9Ck5fKCJDbG9uZSBzdWNjZWVkZWQsIGJ1dCBjaGVja291dCBmYWlsZWQuXG4iCiAgICJZb3UgY2FuIGluc3BlY3Qgd2hhdCB3YXMgY2hlY2tlZCBvdXQgd2l0aCAnZ2l0IHN0YXR1cydcbiIKICAgImFuZCByZXRyeSB3aXRoICdnaXQgcmVzdG9yZSAtLXNvdXJjZT1IRUFEIDovJ1xuIik7CgpzdGF0aWMgdm9pZCByZW1vdmVfanVuayh2b2lkKQp7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CgoJc3dpdGNoIChqdW5rX21vZGUpIHsKCWNhc2UgSlVOS19MRUFWRV9SRVBPOgoJCXdhcm5pbmcoIiVzIiwgXyhqdW5rX2xlYXZlX3JlcG9fbXNnKSk7CgkJLyogZmFsbC10aHJvdWdoICovCgljYXNlIEpVTktfTEVBVkVfQUxMOgoJCXJldHVybjsKCWRlZmF1bHQ6CgkJLyogcHJvY2VlZCB0byByZW1vdmFsICovCgkJYnJlYWs7Cgl9CgoJaWYgKGp1bmtfZ2l0X2RpcikgewoJCXN0cmJ1Zl9hZGRzdHIoJnNiLCBqdW5rX2dpdF9kaXIpOwoJCXJlbW92ZV9kaXJfcmVjdXJzaXZlbHkoJnNiLCBqdW5rX2dpdF9kaXJfZmxhZ3MpOwoJCXN0cmJ1Zl9yZXNldCgmc2IpOwoJfQoJaWYgKGp1bmtfd29ya190cmVlKSB7CgkJc3RyYnVmX2FkZHN0cigmc2IsIGp1bmtfd29ya190cmVlKTsKCQlyZW1vdmVfZGlyX3JlY3Vyc2l2ZWx5KCZzYiwganVua193b3JrX3RyZWVfZmxhZ3MpOwoJfQoJc3RyYnVmX3JlbGVhc2UoJnNiKTsKfQoKc3RhdGljIHZvaWQgcmVtb3ZlX2p1bmtfb25fc2lnbmFsKGludCBzaWdubykKewoJcmVtb3ZlX2p1bmsoKTsKCXNpZ2NoYWluX3BvcChzaWdubyk7CglyYWlzZShzaWdubyk7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVmICpmaW5kX3JlbW90ZV9icmFuY2goY29uc3Qgc3RydWN0IHJlZiAqcmVmcywgY29uc3QgY2hhciAqYnJhbmNoKQp7CglzdHJ1Y3QgcmVmICpyZWY7CglzdHJ1Y3Qgc3RyYnVmIGhlYWQgPSBTVFJCVUZfSU5JVDsKCXN0cmJ1Zl9hZGRzdHIoJmhlYWQsICJyZWZzL2hlYWRzLyIpOwoJc3RyYnVmX2FkZHN0cigmaGVhZCwgYnJhbmNoKTsKCXJlZiA9IGZpbmRfcmVmX2J5X25hbWUocmVmcywgaGVhZC5idWYpOwoJc3RyYnVmX3JlbGVhc2UoJmhlYWQpOwoKCWlmIChyZWYpCgkJcmV0dXJuIHJlZjsKCglzdHJidWZfYWRkc3RyKCZoZWFkLCAicmVmcy90YWdzLyIpOwoJc3RyYnVmX2FkZHN0cigmaGVhZCwgYnJhbmNoKTsKCXJlZiA9IGZpbmRfcmVmX2J5X25hbWUocmVmcywgaGVhZC5idWYpOwoJc3RyYnVmX3JlbGVhc2UoJmhlYWQpOwoKCXJldHVybiByZWY7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVmICp3YW50ZWRfcGVlcl9yZWZzKGNvbnN0IHN0cnVjdCByZWYgKnJlZnMsCgkJc3RydWN0IHJlZnNwZWMgKnJlZnNwZWMpCnsKCXN0cnVjdCByZWYgKmhlYWQgPSBjb3B5X3JlZihmaW5kX3JlZl9ieV9uYW1lKHJlZnMsICJIRUFEIikpOwoJc3RydWN0IHJlZiAqbG9jYWxfcmVmcyA9IGhlYWQ7CglzdHJ1Y3QgcmVmICoqdGFpbCA9IGhlYWQgPyAmaGVhZC0+bmV4dCA6ICZsb2NhbF9yZWZzOwoKCWlmIChvcHRpb25fc2luZ2xlX2JyYW5jaCkgewoJCXN0cnVjdCByZWYgKnJlbW90ZV9oZWFkID0gTlVMTDsKCgkJaWYgKCFvcHRpb25fYnJhbmNoKQoJCQlyZW1vdGVfaGVhZCA9IGd1ZXNzX3JlbW90ZV9oZWFkKGhlYWQsIHJlZnMsIDApOwoJCWVsc2UgewoJCQlsb2NhbF9yZWZzID0gTlVMTDsKCQkJdGFpbCA9ICZsb2NhbF9yZWZzOwoJCQlyZW1vdGVfaGVhZCA9IGNvcHlfcmVmKGZpbmRfcmVtb3RlX2JyYW5jaChyZWZzLCBvcHRpb25fYnJhbmNoKSk7CgkJfQoKCQlpZiAoIXJlbW90ZV9oZWFkICYmIG9wdGlvbl9icmFuY2gpCgkJCXdhcm5pbmcoXygiQ291bGQgbm90IGZpbmQgcmVtb3RlIGJyYW5jaCAlcyB0byBjbG9uZS4iKSwKCQkJCW9wdGlvbl9icmFuY2gpOwoJCWVsc2UgewoJCQlpbnQgaTsKCQkJZm9yIChpID0gMDsgaSA8IHJlZnNwZWMtPm5yOyBpKyspCgkJCQlnZXRfZmV0Y2hfbWFwKHJlbW90ZV9oZWFkLCAmcmVmc3BlYy0+aXRlbXNbaV0sCgkJCQkJICAgICAgJnRhaWwsIDApOwoKCQkJLyogaWYgLS1icmFuY2g9dGFnLCBwdWxsIHRoZSByZXF1ZXN0ZWQgdGFnIGV4cGxpY2l0bHkgKi8KCQkJZ2V0X2ZldGNoX21hcChyZW1vdGVfaGVhZCwgdGFnX3JlZnNwZWMsICZ0YWlsLCAwKTsKCQl9Cgl9IGVsc2UgewoJCWludCBpOwoJCWZvciAoaSA9IDA7IGkgPCByZWZzcGVjLT5ucjsgaSsrKQoJCQlnZXRfZmV0Y2hfbWFwKHJlZnMsICZyZWZzcGVjLT5pdGVtc1tpXSwgJnRhaWwsIDApOwoJfQoKCWlmICghb3B0aW9uX21pcnJvciAmJiAhb3B0aW9uX3NpbmdsZV9icmFuY2ggJiYgIW9wdGlvbl9ub190YWdzKQoJCWdldF9mZXRjaF9tYXAocmVmcywgdGFnX3JlZnNwZWMsICZ0YWlsLCAwKTsKCglyZXR1cm4gbG9jYWxfcmVmczsKfQoKc3RhdGljIHZvaWQgd3JpdGVfcmVtb3RlX3JlZnMoY29uc3Qgc3RydWN0IHJlZiAqbG9jYWxfcmVmcykKewoJY29uc3Qgc3RydWN0IHJlZiAqcjsKCglzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0OwoJc3RydWN0IHN0cmJ1ZiBlcnIgPSBTVFJCVUZfSU5JVDsKCgl0ID0gcmVmX3RyYW5zYWN0aW9uX2JlZ2luKCZlcnIpOwoJaWYgKCF0KQoJCWRpZSgiJXMiLCBlcnIuYnVmKTsKCglmb3IgKHIgPSBsb2NhbF9yZWZzOyByOyByID0gci0+bmV4dCkgewoJCWlmICghci0+cGVlcl9yZWYpCgkJCWNvbnRpbnVlOwoJCWlmIChyZWZfdHJhbnNhY3Rpb25fY3JlYXRlKHQsIHItPnBlZXJfcmVmLT5uYW1lLCAmci0+b2xkX29pZCwKCQkJCQkgICAwLCBOVUxMLCAmZXJyKSkKCQkJZGllKCIlcyIsIGVyci5idWYpOwoJfQoKCWlmIChpbml0aWFsX3JlZl90cmFuc2FjdGlvbl9jb21taXQodCwgJmVycikpCgkJZGllKCIlcyIsIGVyci5idWYpOwoKCXN0cmJ1Zl9yZWxlYXNlKCZlcnIpOwoJcmVmX3RyYW5zYWN0aW9uX2ZyZWUodCk7Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX2ZvbGxvd3RhZ3MoY29uc3Qgc3RydWN0IHJlZiAqcmVmcywgY29uc3QgY2hhciAqbXNnKQp7Cgljb25zdCBzdHJ1Y3QgcmVmICpyZWY7Cglmb3IgKHJlZiA9IHJlZnM7IHJlZjsgcmVmID0gcmVmLT5uZXh0KSB7CgkJaWYgKCFzdGFydHNfd2l0aChyZWYtPm5hbWUsICJyZWZzL3RhZ3MvIikpCgkJCWNvbnRpbnVlOwoJCWlmIChlbmRzX3dpdGgocmVmLT5uYW1lLCAiXnt9IikpCgkJCWNvbnRpbnVlOwoJCWlmICghaGFzX29iamVjdF9maWxlKCZyZWYtPm9sZF9vaWQpKQoJCQljb250aW51ZTsKCQl1cGRhdGVfcmVmKG1zZywgcmVmLT5uYW1lLCAmcmVmLT5vbGRfb2lkLCBOVUxMLCAwLAoJCQkgICBVUERBVEVfUkVGU19ESUVfT05fRVJSKTsKCX0KfQoKc3RhdGljIGludCBpdGVyYXRlX3JlZl9tYXAodm9pZCAqY2JfZGF0YSwgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglzdHJ1Y3QgcmVmICoqcm0gPSBjYl9kYXRhOwoJc3RydWN0IHJlZiAqcmVmID0gKnJtOwoKCS8qCgkgKiBTa2lwIGFueXRoaW5nIG1pc3NpbmcgYSBwZWVyX3JlZiwgd2hpY2ggd2UgYXJlIG5vdAoJICogYWN0dWFsbHkgZ29pbmcgdG8gd3JpdGUgYSByZWYgZm9yLgoJICovCgl3aGlsZSAocmVmICYmICFyZWYtPnBlZXJfcmVmKQoJCXJlZiA9IHJlZi0+bmV4dDsKCS8qIFJldHVybmluZyAtMSBub3RlcyAiZW5kIG9mIGxpc3QiIHRvIHRoZSBjYWxsZXIuICovCglpZiAoIXJlZikKCQlyZXR1cm4gLTE7CgoJb2lkY3B5KG9pZCwgJnJlZi0+b2xkX29pZCk7Cgkqcm0gPSByZWYtPm5leHQ7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgdXBkYXRlX3JlbW90ZV9yZWZzKGNvbnN0IHN0cnVjdCByZWYgKnJlZnMsCgkJCSAgICAgICBjb25zdCBzdHJ1Y3QgcmVmICptYXBwZWRfcmVmcywKCQkJICAgICAgIGNvbnN0IHN0cnVjdCByZWYgKnJlbW90ZV9oZWFkX3BvaW50c19hdCwKCQkJICAgICAgIGNvbnN0IGNoYXIgKmJyYW5jaF90b3AsCgkJCSAgICAgICBjb25zdCBjaGFyICptc2csCgkJCSAgICAgICBzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsCgkJCSAgICAgICBpbnQgY2hlY2tfY29ubmVjdGl2aXR5LAoJCQkgICAgICAgaW50IGNoZWNrX3JlZnNfYXJlX3Byb21pc29yX29iamVjdHNfb25seSkKewoJY29uc3Qgc3RydWN0IHJlZiAqcm0gPSBtYXBwZWRfcmVmczsKCglpZiAoY2hlY2tfY29ubmVjdGl2aXR5KSB7CgkJc3RydWN0IGNoZWNrX2Nvbm5lY3RlZF9vcHRpb25zIG9wdCA9IENIRUNLX0NPTk5FQ1RFRF9JTklUOwoKCQlvcHQudHJhbnNwb3J0ID0gdHJhbnNwb3J0OwoJCW9wdC5wcm9ncmVzcyA9IHRyYW5zcG9ydC0+cHJvZ3Jlc3M7CgkJb3B0LmNoZWNrX3JlZnNfYXJlX3Byb21pc29yX29iamVjdHNfb25seSA9CgkJCSEhY2hlY2tfcmVmc19hcmVfcHJvbWlzb3Jfb2JqZWN0c19vbmx5OwoKCQlpZiAoY2hlY2tfY29ubmVjdGVkKGl0ZXJhdGVfcmVmX21hcCwgJnJtLCAmb3B0KSkKCQkJZGllKF8oInJlbW90ZSBkaWQgbm90IHNlbmQgYWxsIG5lY2Vzc2FyeSBvYmplY3RzIikpOwoJfQoKCWlmIChyZWZzKSB7CgkJd3JpdGVfcmVtb3RlX3JlZnMobWFwcGVkX3JlZnMpOwoJCWlmIChvcHRpb25fc2luZ2xlX2JyYW5jaCAmJiAhb3B0aW9uX25vX3RhZ3MpCgkJCXdyaXRlX2ZvbGxvd3RhZ3MocmVmcywgbXNnKTsKCX0KCglpZiAocmVtb3RlX2hlYWRfcG9pbnRzX2F0ICYmICFvcHRpb25fYmFyZSkgewoJCXN0cnVjdCBzdHJidWYgaGVhZF9yZWYgPSBTVFJCVUZfSU5JVDsKCQlzdHJidWZfYWRkc3RyKCZoZWFkX3JlZiwgYnJhbmNoX3RvcCk7CgkJc3RyYnVmX2FkZHN0cigmaGVhZF9yZWYsICJIRUFEIik7CgkJaWYgKGNyZWF0ZV9zeW1yZWYoaGVhZF9yZWYuYnVmLAoJCQkJICByZW1vdGVfaGVhZF9wb2ludHNfYXQtPnBlZXJfcmVmLT5uYW1lLAoJCQkJICBtc2cpIDwgMCkKCQkJZGllKF8oInVuYWJsZSB0byB1cGRhdGUgJXMiKSwgaGVhZF9yZWYuYnVmKTsKCQlzdHJidWZfcmVsZWFzZSgmaGVhZF9yZWYpOwoJfQp9CgpzdGF0aWMgdm9pZCB1cGRhdGVfaGVhZChjb25zdCBzdHJ1Y3QgcmVmICpvdXIsIGNvbnN0IHN0cnVjdCByZWYgKnJlbW90ZSwKCQkJY29uc3QgY2hhciAqbXNnKQp7Cgljb25zdCBjaGFyICpoZWFkOwoJaWYgKG91ciAmJiBza2lwX3ByZWZpeChvdXItPm5hbWUsICJyZWZzL2hlYWRzLyIsICZoZWFkKSkgewoJCS8qIExvY2FsIGRlZmF1bHQgYnJhbmNoIGxpbmsgKi8KCQlpZiAoY3JlYXRlX3N5bXJlZigiSEVBRCIsIG91ci0+bmFtZSwgTlVMTCkgPCAwKQoJCQlkaWUoXygidW5hYmxlIHRvIHVwZGF0ZSBIRUFEIikpOwoJCWlmICghb3B0aW9uX2JhcmUpIHsKCQkJdXBkYXRlX3JlZihtc2csICJIRUFEIiwgJm91ci0+b2xkX29pZCwgTlVMTCwgMCwKCQkJCSAgIFVQREFURV9SRUZTX0RJRV9PTl9FUlIpOwoJCQlpbnN0YWxsX2JyYW5jaF9jb25maWcoMCwgaGVhZCwgb3B0aW9uX29yaWdpbiwgb3VyLT5uYW1lKTsKCQl9Cgl9IGVsc2UgaWYgKG91cikgewoJCXN0cnVjdCBjb21taXQgKmMgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZSh0aGVfcmVwb3NpdG9yeSwKCQkJCQkJCSAgICZvdXItPm9sZF9vaWQpOwoJCS8qIC0tYnJhbmNoIHNwZWNpZmllcyBhIG5vbi1icmFuY2ggKGkuZS4gdGFncyksIGRldGFjaCBIRUFEICovCgkJdXBkYXRlX3JlZihtc2csICJIRUFEIiwgJmMtPm9iamVjdC5vaWQsIE5VTEwsIFJFRl9OT19ERVJFRiwKCQkJICAgVVBEQVRFX1JFRlNfRElFX09OX0VSUik7Cgl9IGVsc2UgaWYgKHJlbW90ZSkgewoJCS8qCgkJICogV2Uga25vdyByZW1vdGUgSEVBRCBwb2ludHMgdG8gYSBub24tYnJhbmNoLCBvcgoJCSAqIEhFQUQgcG9pbnRzIHRvIGEgYnJhbmNoIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIG9uZS4KCQkgKiBEZXRhY2ggSEVBRCBpbiBhbGwgdGhlc2UgY2FzZXMuCgkJICovCgkJdXBkYXRlX3JlZihtc2csICJIRUFEIiwgJnJlbW90ZS0+b2xkX29pZCwgTlVMTCwgUkVGX05PX0RFUkVGLAoJCQkgICBVUERBVEVfUkVGU19ESUVfT05fRVJSKTsKCX0KfQoKc3RhdGljIGludCBnaXRfc3BhcnNlX2NoZWNrb3V0X2luaXQoY29uc3QgY2hhciAqcmVwbykKewoJc3RydWN0IGFyZ3ZfYXJyYXkgYXJndiA9IEFSR1ZfQVJSQVlfSU5JVDsKCWludCByZXN1bHQgPSAwOwoJYXJndl9hcnJheV9wdXNobCgmYXJndiwgIi1DIiwgcmVwbywgInNwYXJzZS1jaGVja291dCIsICJpbml0IiwgTlVMTCk7CgoJLyoKCSAqIFdlIG11c3QgYXBwbHkgdGhlIHNldHRpbmcgaW4gdGhlIGN1cnJlbnQgcHJvY2VzcwoJICogZm9yIHRoZSBsYXRlciBjaGVja291dCB0byB1c2UgdGhlIHNwYXJzZS1jaGVja291dCBmaWxlLgoJICovCgljb3JlX2FwcGx5X3NwYXJzZV9jaGVja291dCA9IDE7CgoJaWYgKHJ1bl9jb21tYW5kX3Zfb3B0KGFyZ3YuYXJndiwgUlVOX0dJVF9DTUQpKSB7CgkJZXJyb3IoXygiZmFpbGVkIHRvIGluaXRpYWxpemUgc3BhcnNlLWNoZWNrb3V0IikpOwoJCXJlc3VsdCA9IDE7Cgl9CgoJYXJndl9hcnJheV9jbGVhcigmYXJndik7CglyZXR1cm4gcmVzdWx0Owp9CgpzdGF0aWMgaW50IGNoZWNrb3V0KGludCBzdWJtb2R1bGVfcHJvZ3Jlc3MpCnsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJY2hhciAqaGVhZDsKCXN0cnVjdCBsb2NrX2ZpbGUgbG9ja19maWxlID0gTE9DS19JTklUOwoJc3RydWN0IHVucGFja190cmVlc19vcHRpb25zIG9wdHM7CglzdHJ1Y3QgdHJlZSAqdHJlZTsKCXN0cnVjdCB0cmVlX2Rlc2MgdDsKCWludCBlcnIgPSAwOwoKCWlmIChvcHRpb25fbm9fY2hlY2tvdXQpCgkJcmV0dXJuIDA7CgoJaGVhZCA9IHJlc29sdmVfcmVmZHVwKCJIRUFEIiwgUkVTT0xWRV9SRUZfUkVBRElORywgJm9pZCwgTlVMTCk7CglpZiAoIWhlYWQpIHsKCQl3YXJuaW5nKF8oInJlbW90ZSBIRUFEIHJlZmVycyB0byBub25leGlzdGVudCByZWYsICIKCQkJICAidW5hYmxlIHRvIGNoZWNrb3V0LlxuIikpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaGVhZCwgIkhFQUQiKSkgewoJCWlmIChhZHZpY2VfZGV0YWNoZWRfaGVhZCkKCQkJZGV0YWNoX2FkdmljZShvaWRfdG9faGV4KCZvaWQpKTsKCX0gZWxzZSB7CgkJaWYgKCFzdGFydHNfd2l0aChoZWFkLCAicmVmcy9oZWFkcy8iKSkKCQkJZGllKF8oIkhFQUQgbm90IGZvdW5kIGJlbG93IHJlZnMvaGVhZHMhIikpOwoJfQoJZnJlZShoZWFkKTsKCgkvKiBXZSBuZWVkIHRvIGJlIGluIHRoZSBuZXcgd29yayB0cmVlIGZvciB0aGUgY2hlY2tvdXQgKi8KCXNldHVwX3dvcmtfdHJlZSgpOwoKCWhvbGRfbG9ja2VkX2luZGV4KCZsb2NrX2ZpbGUsIExPQ0tfRElFX09OX0VSUk9SKTsKCgltZW1zZXQoJm9wdHMsIDAsIHNpemVvZiBvcHRzKTsKCW9wdHMudXBkYXRlID0gMTsKCW9wdHMubWVyZ2UgPSAxOwoJb3B0cy5jbG9uZSA9IDE7CglvcHRzLmZuID0gb25ld2F5X21lcmdlOwoJb3B0cy52ZXJib3NlX3VwZGF0ZSA9IChvcHRpb25fdmVyYm9zaXR5ID49IDApOwoJb3B0cy5zcmNfaW5kZXggPSAmdGhlX2luZGV4OwoJb3B0cy5kc3RfaW5kZXggPSAmdGhlX2luZGV4OwoKCXRyZWUgPSBwYXJzZV90cmVlX2luZGlyZWN0KCZvaWQpOwoJcGFyc2VfdHJlZSh0cmVlKTsKCWluaXRfdHJlZV9kZXNjKCZ0LCB0cmVlLT5idWZmZXIsIHRyZWUtPnNpemUpOwoJaWYgKHVucGFja190cmVlcygxLCAmdCwgJm9wdHMpIDwgMCkKCQlkaWUoXygidW5hYmxlIHRvIGNoZWNrb3V0IHdvcmtpbmcgdHJlZSIpKTsKCglpZiAod3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZsb2NrX2ZpbGUsIENPTU1JVF9MT0NLKSkKCQlkaWUoXygidW5hYmxlIHRvIHdyaXRlIG5ldyBpbmRleCBmaWxlIikpOwoKCWVyciB8PSBydW5faG9va19sZShOVUxMLCAicG9zdC1jaGVja291dCIsIG9pZF90b19oZXgoJm51bGxfb2lkKSwKCQkJICAgb2lkX3RvX2hleCgmb2lkKSwgIjEiLCBOVUxMKTsKCglpZiAoIWVyciAmJiAob3B0aW9uX3JlY3Vyc2Vfc3VibW9kdWxlcy5uciA+IDApKSB7CgkJc3RydWN0IGFyZ3ZfYXJyYXkgYXJncyA9IEFSR1ZfQVJSQVlfSU5JVDsKCQlhcmd2X2FycmF5X3B1c2hsKCZhcmdzLCAic3VibW9kdWxlIiwgInVwZGF0ZSIsICItLXJlcXVpcmUtaW5pdCIsICItLXJlY3Vyc2l2ZSIsIE5VTEwpOwoKCQlpZiAob3B0aW9uX3NoYWxsb3dfc3VibW9kdWxlcyA9PSAxKQoJCQlhcmd2X2FycmF5X3B1c2goJmFyZ3MsICItLWRlcHRoPTEiKTsKCgkJaWYgKG1heF9qb2JzICE9IC0xKQoJCQlhcmd2X2FycmF5X3B1c2hmKCZhcmdzLCAiLS1qb2JzPSVkIiwgbWF4X2pvYnMpOwoKCQlpZiAoc3VibW9kdWxlX3Byb2dyZXNzKQoJCQlhcmd2X2FycmF5X3B1c2goJmFyZ3MsICItLXByb2dyZXNzIik7CgoJCWlmIChvcHRpb25fdmVyYm9zaXR5IDwgMCkKCQkJYXJndl9hcnJheV9wdXNoKCZhcmdzLCAiLS1xdWlldCIpOwoKCQlpZiAob3B0aW9uX3JlbW90ZV9zdWJtb2R1bGVzKSB7CgkJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJncywgIi0tcmVtb3RlIik7CgkJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJncywgIi0tbm8tZmV0Y2giKTsKCQl9CgoJCWlmIChvcHRpb25fc2luZ2xlX2JyYW5jaCA+PSAwKQoJCQlhcmd2X2FycmF5X3B1c2goJmFyZ3MsIG9wdGlvbl9zaW5nbGVfYnJhbmNoID8KCQkJCQkgICAgICAgIi0tc2luZ2xlLWJyYW5jaCIgOgoJCQkJCSAgICAgICAiLS1uby1zaW5nbGUtYnJhbmNoIik7CgoJCWVyciA9IHJ1bl9jb21tYW5kX3Zfb3B0KGFyZ3MuYXJndiwgUlVOX0dJVF9DTUQpOwoJCWFyZ3ZfYXJyYXlfY2xlYXIoJmFyZ3MpOwoJfQoKCXJldHVybiBlcnI7Cn0KCnN0YXRpYyBpbnQgd3JpdGVfb25lX2NvbmZpZyhjb25zdCBjaGFyICprZXksIGNvbnN0IGNoYXIgKnZhbHVlLCB2b2lkICpkYXRhKQp7CglyZXR1cm4gZ2l0X2NvbmZpZ19zZXRfbXVsdGl2YXJfZ2VudGx5KGtleSwKCQkJCQkgICAgICB2YWx1ZSA/IHZhbHVlIDogInRydWUiLAoJCQkJCSAgICAgIENPTkZJR19SRUdFWF9OT05FLCAwKTsKfQoKc3RhdGljIHZvaWQgd3JpdGVfY29uZmlnKHN0cnVjdCBzdHJpbmdfbGlzdCAqY29uZmlnKQp7CglpbnQgaTsKCglmb3IgKGkgPSAwOyBpIDwgY29uZmlnLT5ucjsgaSsrKSB7CgkJaWYgKGdpdF9jb25maWdfcGFyc2VfcGFyYW1ldGVyKGNvbmZpZy0+aXRlbXNbaV0uc3RyaW5nLAoJCQkJCSAgICAgICB3cml0ZV9vbmVfY29uZmlnLCBOVUxMKSA8IDApCgkJCWRpZShfKCJ1bmFibGUgdG8gd3JpdGUgcGFyYW1ldGVycyB0byBjb25maWcgZmlsZSIpKTsKCX0KfQoKc3RhdGljIHZvaWQgd3JpdGVfcmVmc3BlY19jb25maWcoY29uc3QgY2hhciAqc3JjX3JlZl9wcmVmaXgsCgkJY29uc3Qgc3RydWN0IHJlZiAqb3VyX2hlYWRfcG9pbnRzX2F0LAoJCWNvbnN0IHN0cnVjdCByZWYgKnJlbW90ZV9oZWFkX3BvaW50c19hdCwKCQlzdHJ1Y3Qgc3RyYnVmICpicmFuY2hfdG9wKQp7CglzdHJ1Y3Qgc3RyYnVmIGtleSA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiB2YWx1ZSA9IFNUUkJVRl9JTklUOwoKCWlmIChvcHRpb25fbWlycm9yIHx8ICFvcHRpb25fYmFyZSkgewoJCWlmIChvcHRpb25fc2luZ2xlX2JyYW5jaCAmJiAhb3B0aW9uX21pcnJvcikgewoJCQlpZiAob3B0aW9uX2JyYW5jaCkgewoJCQkJaWYgKHN0YXJ0c193aXRoKG91cl9oZWFkX3BvaW50c19hdC0+bmFtZSwgInJlZnMvdGFncy8iKSkKCQkJCQlzdHJidWZfYWRkZigmdmFsdWUsICIrJXM6JXMiLCBvdXJfaGVhZF9wb2ludHNfYXQtPm5hbWUsCgkJCQkJCW91cl9oZWFkX3BvaW50c19hdC0+bmFtZSk7CgkJCQllbHNlCgkJCQkJc3RyYnVmX2FkZGYoJnZhbHVlLCAiKyVzOiVzJXMiLCBvdXJfaGVhZF9wb2ludHNfYXQtPm5hbWUsCgkJCQkJCWJyYW5jaF90b3AtPmJ1Ziwgb3B0aW9uX2JyYW5jaCk7CgkJCX0gZWxzZSBpZiAocmVtb3RlX2hlYWRfcG9pbnRzX2F0KSB7CgkJCQljb25zdCBjaGFyICpoZWFkID0gcmVtb3RlX2hlYWRfcG9pbnRzX2F0LT5uYW1lOwoJCQkJaWYgKCFza2lwX3ByZWZpeChoZWFkLCAicmVmcy9oZWFkcy8iLCAmaGVhZCkpCgkJCQkJQlVHKCJyZW1vdGUgSEVBRCBwb2ludHMgYXQgbm9uLWhlYWQ/Iik7CgoJCQkJc3RyYnVmX2FkZGYoJnZhbHVlLCAiKyVzOiVzJXMiLCByZW1vdGVfaGVhZF9wb2ludHNfYXQtPm5hbWUsCgkJCQkJCWJyYW5jaF90b3AtPmJ1ZiwgaGVhZCk7CgkJCX0KCQkJLyoKCQkJICogb3RoZXJ3aXNlLCB0aGUgbmV4dCAiZ2l0IGZldGNoIiB3aWxsCgkJCSAqIHNpbXBseSBmZXRjaCBmcm9tIEhFQUQgd2l0aG91dCB1cGRhdGluZwoJCQkgKiBhbnkgcmVtb3RlLXRyYWNraW5nIGJyYW5jaCwgd2hpY2ggaXMgd2hhdAoJCQkgKiB3ZSB3YW50LgoJCQkgKi8KCQl9IGVsc2UgewoJCQlzdHJidWZfYWRkZigmdmFsdWUsICIrJXMqOiVzKiIsIHNyY19yZWZfcHJlZml4LCBicmFuY2hfdG9wLT5idWYpOwoJCX0KCQkvKiBDb25maWd1cmUgdGhlIHJlbW90ZSAqLwoJCWlmICh2YWx1ZS5sZW4pIHsKCQkJc3RyYnVmX2FkZGYoJmtleSwgInJlbW90ZS4lcy5mZXRjaCIsIG9wdGlvbl9vcmlnaW4pOwoJCQlnaXRfY29uZmlnX3NldF9tdWx0aXZhcihrZXkuYnVmLCB2YWx1ZS5idWYsICJeJCIsIDApOwoJCQlzdHJidWZfcmVzZXQoJmtleSk7CgoJCQlpZiAob3B0aW9uX21pcnJvcikgewoJCQkJc3RyYnVmX2FkZGYoJmtleSwgInJlbW90ZS4lcy5taXJyb3IiLCBvcHRpb25fb3JpZ2luKTsKCQkJCWdpdF9jb25maWdfc2V0KGtleS5idWYsICJ0cnVlIik7CgkJCQlzdHJidWZfcmVzZXQoJmtleSk7CgkJCX0KCQl9Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJmtleSk7CglzdHJidWZfcmVsZWFzZSgmdmFsdWUpOwp9CgpzdGF0aWMgdm9pZCBkaXNzb2NpYXRlX2Zyb21fcmVmZXJlbmNlcyh2b2lkKQp7CglzdGF0aWMgY29uc3QgY2hhciogYXJndltdID0geyAicmVwYWNrIiwgIi1hIiwgIi1kIiwgTlVMTCB9OwoJY2hhciAqYWx0ZXJuYXRlcyA9IGdpdF9wYXRoZHVwKCJvYmplY3RzL2luZm8vYWx0ZXJuYXRlcyIpOwoKCWlmICghYWNjZXNzKGFsdGVybmF0ZXMsIEZfT0spKSB7CgkJaWYgKHJ1bl9jb21tYW5kX3Zfb3B0KGFyZ3YsIFJVTl9HSVRfQ01EfFJVTl9DT01NQU5EX05PX1NURElOKSkKCQkJZGllKF8oImNhbm5vdCByZXBhY2sgdG8gY2xlYW4gdXAiKSk7CgkJaWYgKHVubGluayhhbHRlcm5hdGVzKSAmJiBlcnJubyAhPSBFTk9FTlQpCgkJCWRpZV9lcnJubyhfKCJjYW5ub3QgdW5saW5rIHRlbXBvcmFyeSBhbHRlcm5hdGVzIGZpbGUiKSk7Cgl9CglmcmVlKGFsdGVybmF0ZXMpOwp9CgpzdGF0aWMgaW50IHBhdGhfZXhpc3RzKGNvbnN0IGNoYXIgKnBhdGgpCnsKCXN0cnVjdCBzdGF0IHNiOwoJcmV0dXJuICFzdGF0KHBhdGgsICZzYik7Cn0KCmludCBjbWRfY2xvbmUoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCWludCBpc19idW5kbGUgPSAwLCBpc19sb2NhbDsKCWNvbnN0IGNoYXIgKnJlcG9fbmFtZSwgKnJlcG8sICp3b3JrX3RyZWUsICpnaXRfZGlyOwoJY2hhciAqcGF0aCwgKmRpciwgKmRpc3BsYXlfcmVwbyA9IE5VTEw7CglpbnQgZGVzdF9leGlzdHM7Cgljb25zdCBzdHJ1Y3QgcmVmICpyZWZzLCAqcmVtb3RlX2hlYWQ7Cgljb25zdCBzdHJ1Y3QgcmVmICpyZW1vdGVfaGVhZF9wb2ludHNfYXQ7Cgljb25zdCBzdHJ1Y3QgcmVmICpvdXJfaGVhZF9wb2ludHNfYXQ7CglzdHJ1Y3QgcmVmICptYXBwZWRfcmVmczsKCWNvbnN0IHN0cnVjdCByZWYgKnJlZjsKCXN0cnVjdCBzdHJidWYga2V5ID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGRlZmF1bHRfcmVmc3BlYyA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBicmFuY2hfdG9wID0gU1RSQlVGX0lOSVQsIHJlZmxvZ19tc2cgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCA9IE5VTEw7Cgljb25zdCBjaGFyICpzcmNfcmVmX3ByZWZpeCA9ICJyZWZzL2hlYWRzLyI7CglzdHJ1Y3QgcmVtb3RlICpyZW1vdGU7CglpbnQgZXJyID0gMCwgY29tcGxldGVfcmVmc19iZWZvcmVfZmV0Y2ggPSAxOwoJaW50IHN1Ym1vZHVsZV9wcm9ncmVzczsKCglzdHJ1Y3QgYXJndl9hcnJheSByZWZfcHJlZml4ZXMgPSBBUkdWX0FSUkFZX0lOSVQ7CgoJcGFja2V0X3RyYWNlX2lkZW50aXR5KCJjbG9uZSIpOwoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBidWlsdGluX2Nsb25lX29wdGlvbnMsCgkJCSAgICAgYnVpbHRpbl9jbG9uZV91c2FnZSwgMCk7CgoJaWYgKGFyZ2MgPiAyKQoJCXVzYWdlX21zZ19vcHQoXygiVG9vIG1hbnkgYXJndW1lbnRzLiIpLAoJCQlidWlsdGluX2Nsb25lX3VzYWdlLCBidWlsdGluX2Nsb25lX29wdGlvbnMpOwoKCWlmIChhcmdjID09IDApCgkJdXNhZ2VfbXNnX29wdChfKCJZb3UgbXVzdCBzcGVjaWZ5IGEgcmVwb3NpdG9yeSB0byBjbG9uZS4iKSwKCQkJYnVpbHRpbl9jbG9uZV91c2FnZSwgYnVpbHRpbl9jbG9uZV9vcHRpb25zKTsKCglpZiAob3B0aW9uX2RlcHRoIHx8IG9wdGlvbl9zaW5jZSB8fCBvcHRpb25fbm90Lm5yKQoJCWRlZXBlbiA9IDE7CglpZiAob3B0aW9uX3NpbmdsZV9icmFuY2ggPT0gLTEpCgkJb3B0aW9uX3NpbmdsZV9icmFuY2ggPSBkZWVwZW4gPyAxIDogMDsKCglpZiAob3B0aW9uX21pcnJvcikKCQlvcHRpb25fYmFyZSA9IDE7CgoJaWYgKG9wdGlvbl9iYXJlKSB7CgkJaWYgKG9wdGlvbl9vcmlnaW4pCgkJCWRpZShfKCItLWJhcmUgYW5kIC0tb3JpZ2luICVzIG9wdGlvbnMgYXJlIGluY29tcGF0aWJsZS4iKSwKCQkJICAgIG9wdGlvbl9vcmlnaW4pOwoJCWlmIChyZWFsX2dpdF9kaXIpCgkJCWRpZShfKCItLWJhcmUgYW5kIC0tc2VwYXJhdGUtZ2l0LWRpciBhcmUgaW5jb21wYXRpYmxlLiIpKTsKCQlvcHRpb25fbm9fY2hlY2tvdXQgPSAxOwoJfQoKCWlmICghb3B0aW9uX29yaWdpbikKCQlvcHRpb25fb3JpZ2luID0gIm9yaWdpbiI7CgoJcmVwb19uYW1lID0gYXJndlswXTsKCglwYXRoID0gZ2V0X3JlcG9fcGF0aChyZXBvX25hbWUsICZpc19idW5kbGUpOwoJaWYgKHBhdGgpCgkJcmVwbyA9IGFic29sdXRlX3BhdGhkdXAocmVwb19uYW1lKTsKCWVsc2UgaWYgKHN0cmNocihyZXBvX25hbWUsICc6JykpIHsKCQlyZXBvID0gcmVwb19uYW1lOwoJCWRpc3BsYXlfcmVwbyA9IHRyYW5zcG9ydF9hbm9ueW1pemVfdXJsKHJlcG8pOwoJfSBlbHNlCgkJZGllKF8oInJlcG9zaXRvcnkgJyVzJyBkb2VzIG5vdCBleGlzdCIpLCByZXBvX25hbWUpOwoKCS8qIG5vIG5lZWQgdG8gYmUgc3RyaWN0LCB0cmFuc3BvcnRfc2V0X29wdGlvbigpIHdpbGwgdmFsaWRhdGUgaXQgYWdhaW4gKi8KCWlmIChvcHRpb25fZGVwdGggJiYgYXRvaShvcHRpb25fZGVwdGgpIDwgMSkKCQlkaWUoXygiZGVwdGggJXMgaXMgbm90IGEgcG9zaXRpdmUgbnVtYmVyIiksIG9wdGlvbl9kZXB0aCk7CgoJaWYgKGFyZ2MgPT0gMikKCQlkaXIgPSB4c3RyZHVwKGFyZ3ZbMV0pOwoJZWxzZQoJCWRpciA9IGd1ZXNzX2Rpcl9uYW1lKHJlcG9fbmFtZSwgaXNfYnVuZGxlLCBvcHRpb25fYmFyZSk7CglzdHJpcF90cmFpbGluZ19zbGFzaGVzKGRpcik7CgoJZGVzdF9leGlzdHMgPSBwYXRoX2V4aXN0cyhkaXIpOwoJaWYgKGRlc3RfZXhpc3RzICYmICFpc19lbXB0eV9kaXIoZGlyKSkKCQlkaWUoXygiZGVzdGluYXRpb24gcGF0aCAnJXMnIGFscmVhZHkgZXhpc3RzIGFuZCBpcyBub3QgIgoJCQkiYW4gZW1wdHkgZGlyZWN0b3J5LiIpLCBkaXIpOwoKCXN0cmJ1Zl9hZGRmKCZyZWZsb2dfbXNnLCAiY2xvbmU6IGZyb20gJXMiLAoJCSAgICBkaXNwbGF5X3JlcG8gPyBkaXNwbGF5X3JlcG8gOiByZXBvKTsKCWZyZWUoZGlzcGxheV9yZXBvKTsKCglpZiAob3B0aW9uX2JhcmUpCgkJd29ya190cmVlID0gTlVMTDsKCWVsc2UgewoJCXdvcmtfdHJlZSA9IGdldGVudigiR0lUX1dPUktfVFJFRSIpOwoJCWlmICh3b3JrX3RyZWUgJiYgcGF0aF9leGlzdHMod29ya190cmVlKSkKCQkJZGllKF8oIndvcmtpbmcgdHJlZSAnJXMnIGFscmVhZHkgZXhpc3RzLiIpLCB3b3JrX3RyZWUpOwoJfQoKCWlmIChvcHRpb25fYmFyZSB8fCB3b3JrX3RyZWUpCgkJZ2l0X2RpciA9IHhzdHJkdXAoZGlyKTsKCWVsc2UgewoJCXdvcmtfdHJlZSA9IGRpcjsKCQlnaXRfZGlyID0gbWtwYXRoZHVwKCIlcy8uZ2l0IiwgZGlyKTsKCX0KCglhdGV4aXQocmVtb3ZlX2p1bmspOwoJc2lnY2hhaW5fcHVzaF9jb21tb24ocmVtb3ZlX2p1bmtfb25fc2lnbmFsKTsKCglpZiAoIW9wdGlvbl9iYXJlKSB7CgkJaWYgKHNhZmVfY3JlYXRlX2xlYWRpbmdfZGlyZWN0b3JpZXNfY29uc3Qod29ya190cmVlKSA8IDApCgkJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgY3JlYXRlIGxlYWRpbmcgZGlyZWN0b3JpZXMgb2YgJyVzJyIpLAoJCQkJICB3b3JrX3RyZWUpOwoJCWlmIChkZXN0X2V4aXN0cykKCQkJanVua193b3JrX3RyZWVfZmxhZ3MgfD0gUkVNT1ZFX0RJUl9LRUVQX1RPUExFVkVMOwoJCWVsc2UgaWYgKG1rZGlyKHdvcmtfdHJlZSwgMDc3NykpCgkJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgY3JlYXRlIHdvcmsgdHJlZSBkaXIgJyVzJyIpLAoJCQkJICB3b3JrX3RyZWUpOwoJCWp1bmtfd29ya190cmVlID0gd29ya190cmVlOwoJCXNldF9naXRfd29ya190cmVlKHdvcmtfdHJlZSk7Cgl9CgoJaWYgKHJlYWxfZ2l0X2RpcikgewoJCWlmIChwYXRoX2V4aXN0cyhyZWFsX2dpdF9kaXIpKQoJCQlqdW5rX2dpdF9kaXJfZmxhZ3MgfD0gUkVNT1ZFX0RJUl9LRUVQX1RPUExFVkVMOwoJCWp1bmtfZ2l0X2RpciA9IHJlYWxfZ2l0X2RpcjsKCX0gZWxzZSB7CgkJaWYgKGRlc3RfZXhpc3RzKQoJCQlqdW5rX2dpdF9kaXJfZmxhZ3MgfD0gUkVNT1ZFX0RJUl9LRUVQX1RPUExFVkVMOwoJCWp1bmtfZ2l0X2RpciA9IGdpdF9kaXI7Cgl9CglpZiAoc2FmZV9jcmVhdGVfbGVhZGluZ19kaXJlY3Rvcmllc19jb25zdChnaXRfZGlyKSA8IDApCgkJZGllKF8oImNvdWxkIG5vdCBjcmVhdGUgbGVhZGluZyBkaXJlY3RvcmllcyBvZiAnJXMnIiksIGdpdF9kaXIpOwoKCWlmICgwIDw9IG9wdGlvbl92ZXJib3NpdHkpIHsKCQlpZiAob3B0aW9uX2JhcmUpCgkJCWZwcmludGYoc3RkZXJyLCBfKCJDbG9uaW5nIGludG8gYmFyZSByZXBvc2l0b3J5ICclcycuLi5cbiIpLCBkaXIpOwoJCWVsc2UKCQkJZnByaW50ZihzdGRlcnIsIF8oIkNsb25pbmcgaW50byAnJXMnLi4uXG4iKSwgZGlyKTsKCX0KCglpZiAob3B0aW9uX3JlY3Vyc2Vfc3VibW9kdWxlcy5uciA+IDApIHsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbTsKCQlzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CgoJCS8qIHJlbW92ZSBkdXBsaWNhdGVzICovCgkJc3RyaW5nX2xpc3Rfc29ydCgmb3B0aW9uX3JlY3Vyc2Vfc3VibW9kdWxlcyk7CgkJc3RyaW5nX2xpc3RfcmVtb3ZlX2R1cGxpY2F0ZXMoJm9wdGlvbl9yZWN1cnNlX3N1Ym1vZHVsZXMsIDApOwoKCQkvKgoJCSAqIE5FRURTV09SSzogSW4gYSBtdWx0aS13b3JraW5nLXRyZWUgd29ybGQsIHRoaXMgbmVlZHMgdG8gYmUKCQkgKiBzZXQgaW4gdGhlIHBlci13b3JrdHJlZSBjb25maWcuCgkJICovCgkJZm9yX2VhY2hfc3RyaW5nX2xpc3RfaXRlbShpdGVtLCAmb3B0aW9uX3JlY3Vyc2Vfc3VibW9kdWxlcykgewoJCQlzdHJidWZfYWRkZigmc2IsICJzdWJtb2R1bGUuYWN0aXZlPSVzIiwKCQkJCSAgICBpdGVtLT5zdHJpbmcpOwoJCQlzdHJpbmdfbGlzdF9hcHBlbmQoJm9wdGlvbl9jb25maWcsCgkJCQkJICAgc3RyYnVmX2RldGFjaCgmc2IsIE5VTEwpKTsKCQl9CgoJCWlmIChvcHRpb25fcmVxdWlyZWRfcmVmZXJlbmNlLm5yICYmCgkJICAgIG9wdGlvbl9vcHRpb25hbF9yZWZlcmVuY2UubnIpCgkJCWRpZShfKCJjbG9uZSAtLXJlY3Vyc2l2ZSBpcyBub3QgY29tcGF0aWJsZSB3aXRoICIKCQkJICAgICAgImJvdGggLS1yZWZlcmVuY2UgYW5kIC0tcmVmZXJlbmNlLWlmLWFibGUiKSk7CgkJZWxzZSBpZiAob3B0aW9uX3JlcXVpcmVkX3JlZmVyZW5jZS5ucikgewoJCQlzdHJpbmdfbGlzdF9hcHBlbmQoJm9wdGlvbl9jb25maWcsCgkJCQkic3VibW9kdWxlLmFsdGVybmF0ZUxvY2F0aW9uPXN1cGVycHJvamVjdCIpOwoJCQlzdHJpbmdfbGlzdF9hcHBlbmQoJm9wdGlvbl9jb25maWcsCgkJCQkic3VibW9kdWxlLmFsdGVybmF0ZUVycm9yU3RyYXRlZ3k9ZGllIik7CgkJfSBlbHNlIGlmIChvcHRpb25fb3B0aW9uYWxfcmVmZXJlbmNlLm5yKSB7CgkJCXN0cmluZ19saXN0X2FwcGVuZCgmb3B0aW9uX2NvbmZpZywKCQkJCSJzdWJtb2R1bGUuYWx0ZXJuYXRlTG9jYXRpb249c3VwZXJwcm9qZWN0Iik7CgkJCXN0cmluZ19saXN0X2FwcGVuZCgmb3B0aW9uX2NvbmZpZywKCQkJCSJzdWJtb2R1bGUuYWx0ZXJuYXRlRXJyb3JTdHJhdGVneT1pbmZvIik7CgkJfQoJfQoKCWluaXRfZGIoZ2l0X2RpciwgcmVhbF9naXRfZGlyLCBvcHRpb25fdGVtcGxhdGUsIElOSVRfREJfUVVJRVQpOwoKCWlmIChyZWFsX2dpdF9kaXIpCgkJZ2l0X2RpciA9IHJlYWxfZ2l0X2RpcjsKCgl3cml0ZV9jb25maWcoJm9wdGlvbl9jb25maWcpOwoKCWdpdF9jb25maWcoZ2l0X2RlZmF1bHRfY29uZmlnLCBOVUxMKTsKCglpZiAob3B0aW9uX2JhcmUpIHsKCQlpZiAob3B0aW9uX21pcnJvcikKCQkJc3JjX3JlZl9wcmVmaXggPSAicmVmcy8iOwoJCXN0cmJ1Zl9hZGRzdHIoJmJyYW5jaF90b3AsIHNyY19yZWZfcHJlZml4KTsKCgkJZ2l0X2NvbmZpZ19zZXQoImNvcmUuYmFyZSIsICJ0cnVlIik7Cgl9IGVsc2UgewoJCXN0cmJ1Zl9hZGRmKCZicmFuY2hfdG9wLCAicmVmcy9yZW1vdGVzLyVzLyIsIG9wdGlvbl9vcmlnaW4pOwoJfQoKCXN0cmJ1Zl9hZGRmKCZrZXksICJyZW1vdGUuJXMudXJsIiwgb3B0aW9uX29yaWdpbik7CglnaXRfY29uZmlnX3NldChrZXkuYnVmLCByZXBvKTsKCXN0cmJ1Zl9yZXNldCgma2V5KTsKCglpZiAob3B0aW9uX25vX3RhZ3MpIHsKCQlzdHJidWZfYWRkZigma2V5LCAicmVtb3RlLiVzLnRhZ09wdCIsIG9wdGlvbl9vcmlnaW4pOwoJCWdpdF9jb25maWdfc2V0KGtleS5idWYsICItLW5vLXRhZ3MiKTsKCQlzdHJidWZfcmVzZXQoJmtleSk7Cgl9CgoJaWYgKG9wdGlvbl9yZXF1aXJlZF9yZWZlcmVuY2UubnIgfHwgb3B0aW9uX29wdGlvbmFsX3JlZmVyZW5jZS5ucikKCQlzZXR1cF9yZWZlcmVuY2UoKTsKCglpZiAob3B0aW9uX3NwYXJzZV9jaGVja291dCAmJiBnaXRfc3BhcnNlX2NoZWNrb3V0X2luaXQoZGlyKSkKCQlyZXR1cm4gMTsKCglyZW1vdGUgPSByZW1vdGVfZ2V0KG9wdGlvbl9vcmlnaW4pOwoKCXN0cmJ1Zl9hZGRmKCZkZWZhdWx0X3JlZnNwZWMsICIrJXMqOiVzKiIsIHNyY19yZWZfcHJlZml4LAoJCSAgICBicmFuY2hfdG9wLmJ1Zik7CglyZWZzcGVjX2FwcGVuZCgmcmVtb3RlLT5mZXRjaCwgZGVmYXVsdF9yZWZzcGVjLmJ1Zik7CgoJdHJhbnNwb3J0ID0gdHJhbnNwb3J0X2dldChyZW1vdGUsIHJlbW90ZS0+dXJsWzBdKTsKCXRyYW5zcG9ydF9zZXRfdmVyYm9zaXR5KHRyYW5zcG9ydCwgb3B0aW9uX3ZlcmJvc2l0eSwgb3B0aW9uX3Byb2dyZXNzKTsKCXRyYW5zcG9ydC0+ZmFtaWx5ID0gZmFtaWx5OwoKCXBhdGggPSBnZXRfcmVwb19wYXRoKHJlbW90ZS0+dXJsWzBdLCAmaXNfYnVuZGxlKTsKCWlzX2xvY2FsID0gb3B0aW9uX2xvY2FsICE9IDAgJiYgcGF0aCAmJiAhaXNfYnVuZGxlOwoJaWYgKGlzX2xvY2FsKSB7CgkJaWYgKG9wdGlvbl9kZXB0aCkKCQkJd2FybmluZyhfKCItLWRlcHRoIGlzIGlnbm9yZWQgaW4gbG9jYWwgY2xvbmVzOyB1c2UgZmlsZTovLyBpbnN0ZWFkLiIpKTsKCQlpZiAob3B0aW9uX3NpbmNlKQoJCQl3YXJuaW5nKF8oIi0tc2hhbGxvdy1zaW5jZSBpcyBpZ25vcmVkIGluIGxvY2FsIGNsb25lczsgdXNlIGZpbGU6Ly8gaW5zdGVhZC4iKSk7CgkJaWYgKG9wdGlvbl9ub3QubnIpCgkJCXdhcm5pbmcoXygiLS1zaGFsbG93LWV4Y2x1ZGUgaXMgaWdub3JlZCBpbiBsb2NhbCBjbG9uZXM7IHVzZSBmaWxlOi8vIGluc3RlYWQuIikpOwoJCWlmIChmaWx0ZXJfb3B0aW9ucy5jaG9pY2UpCgkJCXdhcm5pbmcoXygiLS1maWx0ZXIgaXMgaWdub3JlZCBpbiBsb2NhbCBjbG9uZXM7IHVzZSBmaWxlOi8vIGluc3RlYWQuIikpOwoJCWlmICghYWNjZXNzKG1rcGF0aCgiJXMvc2hhbGxvdyIsIHBhdGgpLCBGX09LKSkgewoJCQlpZiAob3B0aW9uX2xvY2FsID4gMCkKCQkJCXdhcm5pbmcoXygic291cmNlIHJlcG9zaXRvcnkgaXMgc2hhbGxvdywgaWdub3JpbmcgLS1sb2NhbCIpKTsKCQkJaXNfbG9jYWwgPSAwOwoJCX0KCX0KCWlmIChvcHRpb25fbG9jYWwgPiAwICYmICFpc19sb2NhbCkKCQl3YXJuaW5nKF8oIi0tbG9jYWwgaXMgaWdub3JlZCIpKTsKCXRyYW5zcG9ydC0+Y2xvbmluZyA9IDE7CgoJdHJhbnNwb3J0X3NldF9vcHRpb24odHJhbnNwb3J0LCBUUkFOU19PUFRfS0VFUCwgInllcyIpOwoKCWlmIChvcHRpb25fZGVwdGgpCgkJdHJhbnNwb3J0X3NldF9vcHRpb24odHJhbnNwb3J0LCBUUkFOU19PUFRfREVQVEgsCgkJCQkgICAgIG9wdGlvbl9kZXB0aCk7CglpZiAob3B0aW9uX3NpbmNlKQoJCXRyYW5zcG9ydF9zZXRfb3B0aW9uKHRyYW5zcG9ydCwgVFJBTlNfT1BUX0RFRVBFTl9TSU5DRSwKCQkJCSAgICAgb3B0aW9uX3NpbmNlKTsKCWlmIChvcHRpb25fbm90Lm5yKQoJCXRyYW5zcG9ydF9zZXRfb3B0aW9uKHRyYW5zcG9ydCwgVFJBTlNfT1BUX0RFRVBFTl9OT1QsCgkJCQkgICAgIChjb25zdCBjaGFyICopJm9wdGlvbl9ub3QpOwoJaWYgKG9wdGlvbl9zaW5nbGVfYnJhbmNoKQoJCXRyYW5zcG9ydF9zZXRfb3B0aW9uKHRyYW5zcG9ydCwgVFJBTlNfT1BUX0ZPTExPV1RBR1MsICIxIik7CgoJaWYgKG9wdGlvbl91cGxvYWRfcGFjaykKCQl0cmFuc3BvcnRfc2V0X29wdGlvbih0cmFuc3BvcnQsIFRSQU5TX09QVF9VUExPQURQQUNLLAoJCQkJICAgICBvcHRpb25fdXBsb2FkX3BhY2spOwoKCWlmIChzZXJ2ZXJfb3B0aW9ucy5ucikKCQl0cmFuc3BvcnQtPnNlcnZlcl9vcHRpb25zID0gJnNlcnZlcl9vcHRpb25zOwoKCWlmIChmaWx0ZXJfb3B0aW9ucy5jaG9pY2UpIHsKCQljb25zdCBjaGFyICpzcGVjID0KCQkJZXhwYW5kX2xpc3Rfb2JqZWN0c19maWx0ZXJfc3BlYygmZmlsdGVyX29wdGlvbnMpOwoJCXRyYW5zcG9ydF9zZXRfb3B0aW9uKHRyYW5zcG9ydCwgVFJBTlNfT1BUX0xJU1RfT0JKRUNUU19GSUxURVIsCgkJCQkgICAgIHNwZWMpOwoJCXRyYW5zcG9ydF9zZXRfb3B0aW9uKHRyYW5zcG9ydCwgVFJBTlNfT1BUX0ZST01fUFJPTUlTT1IsICIxIik7Cgl9CgoJaWYgKHRyYW5zcG9ydC0+c21hcnRfb3B0aW9ucyAmJiAhZGVlcGVuICYmICFmaWx0ZXJfb3B0aW9ucy5jaG9pY2UpCgkJdHJhbnNwb3J0LT5zbWFydF9vcHRpb25zLT5jaGVja19zZWxmX2NvbnRhaW5lZF9hbmRfY29ubmVjdGVkID0gMTsKCgoJYXJndl9hcnJheV9wdXNoKCZyZWZfcHJlZml4ZXMsICJIRUFEIik7CglyZWZzcGVjX3JlZl9wcmVmaXhlcygmcmVtb3RlLT5mZXRjaCwgJnJlZl9wcmVmaXhlcyk7CglpZiAob3B0aW9uX2JyYW5jaCkKCQlleHBhbmRfcmVmX3ByZWZpeCgmcmVmX3ByZWZpeGVzLCBvcHRpb25fYnJhbmNoKTsKCWlmICghb3B0aW9uX25vX3RhZ3MpCgkJYXJndl9hcnJheV9wdXNoKCZyZWZfcHJlZml4ZXMsICJyZWZzL3RhZ3MvIik7CgoJcmVmcyA9IHRyYW5zcG9ydF9nZXRfcmVtb3RlX3JlZnModHJhbnNwb3J0LCAmcmVmX3ByZWZpeGVzKTsKCglpZiAocmVmcykgewoJCW1hcHBlZF9yZWZzID0gd2FudGVkX3BlZXJfcmVmcyhyZWZzLCAmcmVtb3RlLT5mZXRjaCk7CgkJLyoKCQkgKiB0cmFuc3BvcnRfZ2V0X3JlbW90ZV9yZWZzKCkgbWF5IHJldHVybiByZWZzIHdpdGggbnVsbCBzaGEtMQoJCSAqIGluIG1hcHBlZF9yZWZzIChzZWUgc3RydWN0IHRyYW5zcG9ydC0+Z2V0X3JlZnNfbGlzdAoJCSAqIGNvbW1lbnQpLiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCBmZXRjaCBpdCBlYXJseSBiZWNhdXNlCgkJICogcmVtb3RlX2hlYWQgY29kZSBiZWxvdyByZWxpZXMgb24gaXQuCgkJICoKCQkgKiBmb3Igbm9ybWFsIGNsb25lcywgdHJhbnNwb3J0X2dldF9yZW1vdGVfcmVmcygpIHNob3VsZAoJCSAqIHJldHVybiByZWxpYWJsZSByZWYgc2V0LCB3ZSBjYW4gZGVsYXkgY2xvbmluZyB1bnRpbCBhZnRlcgoJCSAqIHJlbW90ZSBIRUFEIGNoZWNrLgoJCSAqLwoJCWZvciAocmVmID0gcmVmczsgcmVmOyByZWYgPSByZWYtPm5leHQpCgkJCWlmIChpc19udWxsX29pZCgmcmVmLT5vbGRfb2lkKSkgewoJCQkJY29tcGxldGVfcmVmc19iZWZvcmVfZmV0Y2ggPSAwOwoJCQkJYnJlYWs7CgkJCX0KCgkJaWYgKCFpc19sb2NhbCAmJiAhY29tcGxldGVfcmVmc19iZWZvcmVfZmV0Y2gpCgkJCXRyYW5zcG9ydF9mZXRjaF9yZWZzKHRyYW5zcG9ydCwgbWFwcGVkX3JlZnMpOwoKCQlyZW1vdGVfaGVhZCA9IGZpbmRfcmVmX2J5X25hbWUocmVmcywgIkhFQUQiKTsKCQlyZW1vdGVfaGVhZF9wb2ludHNfYXQgPQoJCQlndWVzc19yZW1vdGVfaGVhZChyZW1vdGVfaGVhZCwgbWFwcGVkX3JlZnMsIDApOwoKCQlpZiAob3B0aW9uX2JyYW5jaCkgewoJCQlvdXJfaGVhZF9wb2ludHNfYXQgPQoJCQkJZmluZF9yZW1vdGVfYnJhbmNoKG1hcHBlZF9yZWZzLCBvcHRpb25fYnJhbmNoKTsKCgkJCWlmICghb3VyX2hlYWRfcG9pbnRzX2F0KQoJCQkJZGllKF8oIlJlbW90ZSBicmFuY2ggJXMgbm90IGZvdW5kIGluIHVwc3RyZWFtICVzIiksCgkJCQkgICAgb3B0aW9uX2JyYW5jaCwgb3B0aW9uX29yaWdpbik7CgkJfQoJCWVsc2UKCQkJb3VyX2hlYWRfcG9pbnRzX2F0ID0gcmVtb3RlX2hlYWRfcG9pbnRzX2F0OwoJfQoJZWxzZSB7CgkJaWYgKG9wdGlvbl9icmFuY2gpCgkJCWRpZShfKCJSZW1vdGUgYnJhbmNoICVzIG5vdCBmb3VuZCBpbiB1cHN0cmVhbSAlcyIpLAoJCQkJCW9wdGlvbl9icmFuY2gsIG9wdGlvbl9vcmlnaW4pOwoKCQl3YXJuaW5nKF8oIllvdSBhcHBlYXIgdG8gaGF2ZSBjbG9uZWQgYW4gZW1wdHkgcmVwb3NpdG9yeS4iKSk7CgkJbWFwcGVkX3JlZnMgPSBOVUxMOwoJCW91cl9oZWFkX3BvaW50c19hdCA9IE5VTEw7CgkJcmVtb3RlX2hlYWRfcG9pbnRzX2F0ID0gTlVMTDsKCQlyZW1vdGVfaGVhZCA9IE5VTEw7CgkJb3B0aW9uX25vX2NoZWNrb3V0ID0gMTsKCQlpZiAoIW9wdGlvbl9iYXJlKQoJCQlpbnN0YWxsX2JyYW5jaF9jb25maWcoMCwgIm1hc3RlciIsIG9wdGlvbl9vcmlnaW4sCgkJCQkJICAgICAgInJlZnMvaGVhZHMvbWFzdGVyIik7Cgl9CgoJd3JpdGVfcmVmc3BlY19jb25maWcoc3JjX3JlZl9wcmVmaXgsIG91cl9oZWFkX3BvaW50c19hdCwKCQkJcmVtb3RlX2hlYWRfcG9pbnRzX2F0LCAmYnJhbmNoX3RvcCk7CgoJaWYgKGZpbHRlcl9vcHRpb25zLmNob2ljZSkKCQlwYXJ0aWFsX2Nsb25lX3JlZ2lzdGVyKG9wdGlvbl9vcmlnaW4sICZmaWx0ZXJfb3B0aW9ucyk7CgoJaWYgKGlzX2xvY2FsKQoJCWNsb25lX2xvY2FsKHBhdGgsIGdpdF9kaXIpOwoJZWxzZSBpZiAocmVmcyAmJiBjb21wbGV0ZV9yZWZzX2JlZm9yZV9mZXRjaCkKCQl0cmFuc3BvcnRfZmV0Y2hfcmVmcyh0cmFuc3BvcnQsIG1hcHBlZF9yZWZzKTsKCgl1cGRhdGVfcmVtb3RlX3JlZnMocmVmcywgbWFwcGVkX3JlZnMsIHJlbW90ZV9oZWFkX3BvaW50c19hdCwKCQkJICAgYnJhbmNoX3RvcC5idWYsIHJlZmxvZ19tc2cuYnVmLCB0cmFuc3BvcnQsCgkJCSAgICFpc19sb2NhbCwgZmlsdGVyX29wdGlvbnMuY2hvaWNlKTsKCgl1cGRhdGVfaGVhZChvdXJfaGVhZF9wb2ludHNfYXQsIHJlbW90ZV9oZWFkLCByZWZsb2dfbXNnLmJ1Zik7CgoJLyoKCSAqIFdlIHdhbnQgdG8gc2hvdyBwcm9ncmVzcyBmb3IgcmVjdXJzaXZlIHN1Ym1vZHVsZSBjbG9uZXMgaWZmCgkgKiB3ZSBkaWQgc28gZm9yIHRoZSBtYWluIGNsb25lLiBCdXQgb25seSB0aGUgdHJhbnNwb3J0IGtub3dzCgkgKiB0aGUgZmluYWwgZGVjaXNpb24gZm9yIHRoaXMgZmxhZywgc28gd2UgbmVlZCB0byByZXNjdWUgdGhlIHZhbHVlCgkgKiBiZWZvcmUgd2UgZnJlZSB0aGUgdHJhbnNwb3J0LgoJICovCglzdWJtb2R1bGVfcHJvZ3Jlc3MgPSB0cmFuc3BvcnQtPnByb2dyZXNzOwoKCXRyYW5zcG9ydF91bmxvY2tfcGFjayh0cmFuc3BvcnQpOwoJdHJhbnNwb3J0X2Rpc2Nvbm5lY3QodHJhbnNwb3J0KTsKCglpZiAob3B0aW9uX2Rpc3NvY2lhdGUpIHsKCQljbG9zZV9vYmplY3Rfc3RvcmUodGhlX3JlcG9zaXRvcnktPm9iamVjdHMpOwoJCWRpc3NvY2lhdGVfZnJvbV9yZWZlcmVuY2VzKCk7Cgl9CgoJanVua19tb2RlID0gSlVOS19MRUFWRV9SRVBPOwoJZXJyID0gY2hlY2tvdXQoc3VibW9kdWxlX3Byb2dyZXNzKTsKCglzdHJidWZfcmVsZWFzZSgmcmVmbG9nX21zZyk7CglzdHJidWZfcmVsZWFzZSgmYnJhbmNoX3RvcCk7CglzdHJidWZfcmVsZWFzZSgma2V5KTsKCXN0cmJ1Zl9yZWxlYXNlKCZkZWZhdWx0X3JlZnNwZWMpOwoJanVua19tb2RlID0gSlVOS19MRUFWRV9BTEw7CgoJYXJndl9hcnJheV9jbGVhcigmcmVmX3ByZWZpeGVzKTsKCXJldHVybiBlcnI7Cn0K",
    "text": "/*\n * Builtin \"git clone\"\n *\n * Copyright (c) 2007 Kristian H\u00f8gsberg <krh@redhat.com>,\n *\t\t 2008 Daniel Barkalow <barkalow@iabervon.org>\n * Based on git-commit.sh by Junio C Hamano and Linus Torvalds\n *\n * Clone a repository into a different directory that does not yet exist.\n */\n\n#define USE_THE_INDEX_COMPATIBILITY_MACROS\n#include \"builtin.h\"\n#include \"config.h\"\n#include \"lockfile.h\"\n#include \"parse-options.h\"\n#include \"fetch-pack.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"object-store.h\"\n#include \"tree.h\"\n#include \"tree-walk.h\"\n#include \"unpack-trees.h\"\n#include \"transport.h\"\n#include \"strbuf.h\"\n#include \"dir.h\"\n#include \"dir-iterator.h\"\n#include \"iterator.h\"\n#include \"sigchain.h\"\n#include \"branch.h\"\n#include \"remote.h\"\n#include \"run-command.h\"\n#include \"connected.h\"\n#include \"packfile.h\"\n#include \"list-objects-filter-options.h\"\n\n/*\n * Overall FIXMEs:\n *  - respect DB_ENVIRONMENT for .git/objects.\n *\n * Implementation notes:\n *  - dropping use-separate-remote and no-separate-remote compatibility\n *\n */\nstatic const char * const builtin_clone_usage[] = {\n\tN_(\"git clone [<options>] [--] <repo> [<dir>]\"),\n\tNULL\n};\n\nstatic int option_no_checkout, option_bare, option_mirror, option_single_branch = -1;\nstatic int option_local = -1, option_no_hardlinks, option_shared;\nstatic int option_no_tags;\nstatic int option_shallow_submodules;\nstatic int deepen;\nstatic char *option_template, *option_depth, *option_since;\nstatic char *option_origin = NULL;\nstatic char *option_branch = NULL;\nstatic struct string_list option_not = STRING_LIST_INIT_NODUP;\nstatic const char *real_git_dir;\nstatic char *option_upload_pack = \"git-upload-pack\";\nstatic int option_verbosity;\nstatic int option_progress = -1;\nstatic int option_sparse_checkout;\nstatic enum transport_family family;\nstatic struct string_list option_config = STRING_LIST_INIT_NODUP;\nstatic struct string_list option_required_reference = STRING_LIST_INIT_NODUP;\nstatic struct string_list option_optional_reference = STRING_LIST_INIT_NODUP;\nstatic int option_dissociate;\nstatic int max_jobs = -1;\nstatic struct string_list option_recurse_submodules = STRING_LIST_INIT_NODUP;\nstatic struct list_objects_filter_options filter_options;\nstatic struct string_list server_options = STRING_LIST_INIT_NODUP;\nstatic int option_remote_submodules;\n\nstatic int recurse_submodules_cb(const struct option *opt,\n\t\t\t\t const char *arg, int unset)\n{\n\tif (unset)\n\t\tstring_list_clear((struct string_list *)opt->value, 0);\n\telse if (arg)\n\t\tstring_list_append((struct string_list *)opt->value, arg);\n\telse\n\t\tstring_list_append((struct string_list *)opt->value,\n\t\t\t\t   (const char *)opt->defval);\n\n\treturn 0;\n}\n\nstatic struct option builtin_clone_options[] = {\n\tOPT__VERBOSITY(&option_verbosity),\n\tOPT_BOOL(0, \"progress\", &option_progress,\n\t\t N_(\"force progress reporting\")),\n\tOPT_BOOL('n', \"no-checkout\", &option_no_checkout,\n\t\t N_(\"don't create a checkout\")),\n\tOPT_BOOL(0, \"bare\", &option_bare, N_(\"create a bare repository\")),\n\tOPT_HIDDEN_BOOL(0, \"naked\", &option_bare,\n\t\t\tN_(\"create a bare repository\")),\n\tOPT_BOOL(0, \"mirror\", &option_mirror,\n\t\t N_(\"create a mirror repository (implies bare)\")),\n\tOPT_BOOL('l', \"local\", &option_local,\n\t\tN_(\"to clone from a local repository\")),\n\tOPT_BOOL(0, \"no-hardlinks\", &option_no_hardlinks,\n\t\t    N_(\"don't use local hardlinks, always copy\")),\n\tOPT_BOOL('s', \"shared\", &option_shared,\n\t\t    N_(\"setup as shared repository\")),\n\tOPT_ALIAS(0, \"recursive\", \"recurse-submodules\"),\n\t{ OPTION_CALLBACK, 0, \"recurse-submodules\", &option_recurse_submodules,\n\t  N_(\"pathspec\"), N_(\"initialize submodules in the clone\"),\n\t  PARSE_OPT_OPTARG, recurse_submodules_cb, (intptr_t)\".\" },\n\tOPT_INTEGER('j', \"jobs\", &max_jobs,\n\t\t    N_(\"number of submodules cloned in parallel\")),\n\tOPT_STRING(0, \"template\", &option_template, N_(\"template-directory\"),\n\t\t   N_(\"directory from which templates will be used\")),\n\tOPT_STRING_LIST(0, \"reference\", &option_required_reference, N_(\"repo\"),\n\t\t\tN_(\"reference repository\")),\n\tOPT_STRING_LIST(0, \"reference-if-able\", &option_optional_reference,\n\t\t\tN_(\"repo\"), N_(\"reference repository\")),\n\tOPT_BOOL(0, \"dissociate\", &option_dissociate,\n\t\t N_(\"use --reference only while cloning\")),\n\tOPT_STRING('o', \"origin\", &option_origin, N_(\"name\"),\n\t\t   N_(\"use <name> instead of 'origin' to track upstream\")),\n\tOPT_STRING('b', \"branch\", &option_branch, N_(\"branch\"),\n\t\t   N_(\"checkout <branch> instead of the remote's HEAD\")),\n\tOPT_STRING('u', \"upload-pack\", &option_upload_pack, N_(\"path\"),\n\t\t   N_(\"path to git-upload-pack on the remote\")),\n\tOPT_STRING(0, \"depth\", &option_depth, N_(\"depth\"),\n\t\t    N_(\"create a shallow clone of that depth\")),\n\tOPT_STRING(0, \"shallow-since\", &option_since, N_(\"time\"),\n\t\t    N_(\"create a shallow clone since a specific time\")),\n\tOPT_STRING_LIST(0, \"shallow-exclude\", &option_not, N_(\"revision\"),\n\t\t\tN_(\"deepen history of shallow clone, excluding rev\")),\n\tOPT_BOOL(0, \"single-branch\", &option_single_branch,\n\t\t    N_(\"clone only one branch, HEAD or --branch\")),\n\tOPT_BOOL(0, \"no-tags\", &option_no_tags,\n\t\t N_(\"don't clone any tags, and make later fetches not to follow them\")),\n\tOPT_BOOL(0, \"shallow-submodules\", &option_shallow_submodules,\n\t\t    N_(\"any cloned submodules will be shallow\")),\n\tOPT_STRING(0, \"separate-git-dir\", &real_git_dir, N_(\"gitdir\"),\n\t\t   N_(\"separate git dir from working tree\")),\n\tOPT_STRING_LIST('c', \"config\", &option_config, N_(\"key=value\"),\n\t\t\tN_(\"set config inside the new repository\")),\n\tOPT_STRING_LIST(0, \"server-option\", &server_options,\n\t\t\tN_(\"server-specific\"), N_(\"option to transmit\")),\n\tOPT_SET_INT('4', \"ipv4\", &family, N_(\"use IPv4 addresses only\"),\n\t\t\tTRANSPORT_FAMILY_IPV4),\n\tOPT_SET_INT('6', \"ipv6\", &family, N_(\"use IPv6 addresses only\"),\n\t\t\tTRANSPORT_FAMILY_IPV6),\n\tOPT_PARSE_LIST_OBJECTS_FILTER(&filter_options),\n\tOPT_BOOL(0, \"remote-submodules\", &option_remote_submodules,\n\t\t    N_(\"any cloned submodules will use their remote-tracking branch\")),\n\tOPT_BOOL(0, \"sparse\", &option_sparse_checkout,\n\t\t    N_(\"initialize sparse-checkout file to include only files at root\")),\n\tOPT_END()\n};\n\nstatic const char *get_repo_path_1(struct strbuf *path, int *is_bundle)\n{\n\tstatic char *suffix[] = { \"/.git\", \"\", \".git/.git\", \".git\" };\n\tstatic char *bundle_suffix[] = { \".bundle\", \"\" };\n\tsize_t baselen = path->len;\n\tstruct stat st;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(suffix); i++) {\n\t\tstrbuf_setlen(path, baselen);\n\t\tstrbuf_addstr(path, suffix[i]);\n\t\tif (stat(path->buf, &st))\n\t\t\tcontinue;\n\t\tif (S_ISDIR(st.st_mode) && is_git_directory(path->buf)) {\n\t\t\t*is_bundle = 0;\n\t\t\treturn path->buf;\n\t\t} else if (S_ISREG(st.st_mode) && st.st_size > 8) {\n\t\t\t/* Is it a \"gitfile\"? */\n\t\t\tchar signature[8];\n\t\t\tconst char *dst;\n\t\t\tint len, fd = open(path->buf, O_RDONLY);\n\t\t\tif (fd < 0)\n\t\t\t\tcontinue;\n\t\t\tlen = read_in_full(fd, signature, 8);\n\t\t\tclose(fd);\n\t\t\tif (len != 8 || strncmp(signature, \"gitdir: \", 8))\n\t\t\t\tcontinue;\n\t\t\tdst = read_gitfile(path->buf);\n\t\t\tif (dst) {\n\t\t\t\t*is_bundle = 0;\n\t\t\t\treturn dst;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(bundle_suffix); i++) {\n\t\tstrbuf_setlen(path, baselen);\n\t\tstrbuf_addstr(path, bundle_suffix[i]);\n\t\tif (!stat(path->buf, &st) && S_ISREG(st.st_mode)) {\n\t\t\t*is_bundle = 1;\n\t\t\treturn path->buf;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic char *get_repo_path(const char *repo, int *is_bundle)\n{\n\tstruct strbuf path = STRBUF_INIT;\n\tconst char *raw;\n\tchar *canon;\n\n\tstrbuf_addstr(&path, repo);\n\traw = get_repo_path_1(&path, is_bundle);\n\tcanon = raw ? absolute_pathdup(raw) : NULL;\n\tstrbuf_release(&path);\n\treturn canon;\n}\n\nstatic char *guess_dir_name(const char *repo, int is_bundle, int is_bare)\n{\n\tconst char *end = repo + strlen(repo), *start, *ptr;\n\tsize_t len;\n\tchar *dir;\n\n\t/*\n\t * Skip scheme.\n\t */\n\tstart = strstr(repo, \"://\");\n\tif (start == NULL)\n\t\tstart = repo;\n\telse\n\t\tstart += 3;\n\n\t/*\n\t * Skip authentication data. The stripping does happen\n\t * greedily, such that we strip up to the last '@' inside\n\t * the host part.\n\t */\n\tfor (ptr = start; ptr < end && !is_dir_sep(*ptr); ptr++) {\n\t\tif (*ptr == '@')\n\t\t\tstart = ptr + 1;\n\t}\n\n\t/*\n\t * Strip trailing spaces, slashes and /.git\n\t */\n\twhile (start < end && (is_dir_sep(end[-1]) || isspace(end[-1])))\n\t\tend--;\n\tif (end - start > 5 && is_dir_sep(end[-5]) &&\n\t    !strncmp(end - 4, \".git\", 4)) {\n\t\tend -= 5;\n\t\twhile (start < end && is_dir_sep(end[-1]))\n\t\t\tend--;\n\t}\n\n\t/*\n\t * Strip trailing port number if we've got only a\n\t * hostname (that is, there is no dir separator but a\n\t * colon). This check is required such that we do not\n\t * strip URI's like '/foo/bar:2222.git', which should\n\t * result in a dir '2222' being guessed due to backwards\n\t * compatibility.\n\t */\n\tif (memchr(start, '/', end - start) == NULL\n\t    && memchr(start, ':', end - start) != NULL) {\n\t\tptr = end;\n\t\twhile (start < ptr && isdigit(ptr[-1]) && ptr[-1] != ':')\n\t\t\tptr--;\n\t\tif (start < ptr && ptr[-1] == ':')\n\t\t\tend = ptr - 1;\n\t}\n\n\t/*\n\t * Find last component. To remain backwards compatible we\n\t * also regard colons as path separators, such that\n\t * cloning a repository 'foo:bar.git' would result in a\n\t * directory 'bar' being guessed.\n\t */\n\tptr = end;\n\twhile (start < ptr && !is_dir_sep(ptr[-1]) && ptr[-1] != ':')\n\t\tptr--;\n\tstart = ptr;\n\n\t/*\n\t * Strip .{bundle,git}.\n\t */\n\tlen = end - start;\n\tstrip_suffix_mem(start, &len, is_bundle ? \".bundle\" : \".git\");\n\n\tif (!len || (len == 1 && *start == '/'))\n\t\tdie(_(\"No directory name could be guessed.\\n\"\n\t\t      \"Please specify a directory on the command line\"));\n\n\tif (is_bare)\n\t\tdir = xstrfmt(\"%.*s.git\", (int)len, start);\n\telse\n\t\tdir = xstrndup(start, len);\n\t/*\n\t * Replace sequences of 'control' characters and whitespace\n\t * with one ascii space, remove leading and trailing spaces.\n\t */\n\tif (*dir) {\n\t\tchar *out = dir;\n\t\tint prev_space = 1 /* strip leading whitespace */;\n\t\tfor (end = dir; *end; ++end) {\n\t\t\tchar ch = *end;\n\t\t\tif ((unsigned char)ch < '\\x20')\n\t\t\t\tch = '\\x20';\n\t\t\tif (isspace(ch)) {\n\t\t\t\tif (prev_space)\n\t\t\t\t\tcontinue;\n\t\t\t\tprev_space = 1;\n\t\t\t} else\n\t\t\t\tprev_space = 0;\n\t\t\t*out++ = ch;\n\t\t}\n\t\t*out = '\\0';\n\t\tif (out > dir && prev_space)\n\t\t\tout[-1] = '\\0';\n\t}\n\treturn dir;\n}\n\nstatic void strip_trailing_slashes(char *dir)\n{\n\tchar *end = dir + strlen(dir);\n\n\twhile (dir < end - 1 && is_dir_sep(end[-1]))\n\t\tend--;\n\t*end = '\\0';\n}\n\nstatic int add_one_reference(struct string_list_item *item, void *cb_data)\n{\n\tstruct strbuf err = STRBUF_INIT;\n\tint *required = cb_data;\n\tchar *ref_git = compute_alternate_path(item->string, &err);\n\n\tif (!ref_git) {\n\t\tif (*required)\n\t\t\tdie(\"%s\", err.buf);\n\t\telse\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"info: Could not add alternate for '%s': %s\\n\"),\n\t\t\t\titem->string, err.buf);\n\t} else {\n\t\tstruct strbuf sb = STRBUF_INIT;\n\t\tstrbuf_addf(&sb, \"%s/objects\", ref_git);\n\t\tadd_to_alternates_file(sb.buf);\n\t\tstrbuf_release(&sb);\n\t}\n\n\tstrbuf_release(&err);\n\tfree(ref_git);\n\treturn 0;\n}\n\nstatic void setup_reference(void)\n{\n\tint required = 1;\n\tfor_each_string_list(&option_required_reference,\n\t\t\t     add_one_reference, &required);\n\trequired = 0;\n\tfor_each_string_list(&option_optional_reference,\n\t\t\t     add_one_reference, &required);\n}\n\nstatic void copy_alternates(struct strbuf *src, const char *src_repo)\n{\n\t/*\n\t * Read from the source objects/info/alternates file\n\t * and copy the entries to corresponding file in the\n\t * destination repository with add_to_alternates_file().\n\t * Both src and dst have \"$path/objects/info/alternates\".\n\t *\n\t * Instead of copying bit-for-bit from the original,\n\t * we need to append to existing one so that the already\n\t * created entry via \"clone -s\" is not lost, and also\n\t * to turn entries with paths relative to the original\n\t * absolute, so that they can be used in the new repository.\n\t */\n\tFILE *in = xfopen(src->buf, \"r\");\n\tstruct strbuf line = STRBUF_INIT;\n\n\twhile (strbuf_getline(&line, in) != EOF) {\n\t\tchar *abs_path;\n\t\tif (!line.len || line.buf[0] == '#')\n\t\t\tcontinue;\n\t\tif (is_absolute_path(line.buf)) {\n\t\t\tadd_to_alternates_file(line.buf);\n\t\t\tcontinue;\n\t\t}\n\t\tabs_path = mkpathdup(\"%s/objects/%s\", src_repo, line.buf);\n\t\tif (!normalize_path_copy(abs_path, abs_path))\n\t\t\tadd_to_alternates_file(abs_path);\n\t\telse\n\t\t\twarning(\"skipping invalid relative alternate: %s/%s\",\n\t\t\t\tsrc_repo, line.buf);\n\t\tfree(abs_path);\n\t}\n\tstrbuf_release(&line);\n\tfclose(in);\n}\n\nstatic void mkdir_if_missing(const char *pathname, mode_t mode)\n{\n\tstruct stat st;\n\n\tif (!mkdir(pathname, mode))\n\t\treturn;\n\n\tif (errno != EEXIST)\n\t\tdie_errno(_(\"failed to create directory '%s'\"), pathname);\n\telse if (stat(pathname, &st))\n\t\tdie_errno(_(\"failed to stat '%s'\"), pathname);\n\telse if (!S_ISDIR(st.st_mode))\n\t\tdie(_(\"%s exists and is not a directory\"), pathname);\n}\n\nstatic void copy_or_link_directory(struct strbuf *src, struct strbuf *dest,\n\t\t\t\t   const char *src_repo)\n{\n\tint src_len, dest_len;\n\tstruct dir_iterator *iter;\n\tint iter_status;\n\tunsigned int flags;\n\n\tmkdir_if_missing(dest->buf, 0777);\n\n\tflags = DIR_ITERATOR_PEDANTIC | DIR_ITERATOR_FOLLOW_SYMLINKS;\n\titer = dir_iterator_begin(src->buf, flags);\n\n\tif (!iter)\n\t\tdie_errno(_(\"failed to start iterator over '%s'\"), src->buf);\n\n\tstrbuf_addch(src, '/');\n\tsrc_len = src->len;\n\tstrbuf_addch(dest, '/');\n\tdest_len = dest->len;\n\n\twhile ((iter_status = dir_iterator_advance(iter)) == ITER_OK) {\n\t\tstrbuf_setlen(src, src_len);\n\t\tstrbuf_addstr(src, iter->relative_path);\n\t\tstrbuf_setlen(dest, dest_len);\n\t\tstrbuf_addstr(dest, iter->relative_path);\n\n\t\tif (S_ISDIR(iter->st.st_mode)) {\n\t\t\tmkdir_if_missing(dest->buf, 0777);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Files that cannot be copied bit-for-bit... */\n\t\tif (!fspathcmp(iter->relative_path, \"info/alternates\")) {\n\t\t\tcopy_alternates(src, src_repo);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlink(dest->buf) && errno != ENOENT)\n\t\t\tdie_errno(_(\"failed to unlink '%s'\"), dest->buf);\n\t\tif (!option_no_hardlinks) {\n\t\t\tif (!link(real_path(src->buf), dest->buf))\n\t\t\t\tcontinue;\n\t\t\tif (option_local > 0)\n\t\t\t\tdie_errno(_(\"failed to create link '%s'\"), dest->buf);\n\t\t\toption_no_hardlinks = 1;\n\t\t}\n\t\tif (copy_file_with_time(dest->buf, src->buf, 0666))\n\t\t\tdie_errno(_(\"failed to copy file to '%s'\"), dest->buf);\n\t}\n\n\tif (iter_status != ITER_DONE) {\n\t\tstrbuf_setlen(src, src_len);\n\t\tdie(_(\"failed to iterate over '%s'\"), src->buf);\n\t}\n}\n\nstatic void clone_local(const char *src_repo, const char *dest_repo)\n{\n\tif (option_shared) {\n\t\tstruct strbuf alt = STRBUF_INIT;\n\t\tget_common_dir(&alt, src_repo);\n\t\tstrbuf_addstr(&alt, \"/objects\");\n\t\tadd_to_alternates_file(alt.buf);\n\t\tstrbuf_release(&alt);\n\t} else {\n\t\tstruct strbuf src = STRBUF_INIT;\n\t\tstruct strbuf dest = STRBUF_INIT;\n\t\tget_common_dir(&src, src_repo);\n\t\tget_common_dir(&dest, dest_repo);\n\t\tstrbuf_addstr(&src, \"/objects\");\n\t\tstrbuf_addstr(&dest, \"/objects\");\n\t\tcopy_or_link_directory(&src, &dest, src_repo);\n\t\tstrbuf_release(&src);\n\t\tstrbuf_release(&dest);\n\t}\n\n\tif (0 <= option_verbosity)\n\t\tfprintf(stderr, _(\"done.\\n\"));\n}\n\nstatic const char *junk_work_tree;\nstatic int junk_work_tree_flags;\nstatic const char *junk_git_dir;\nstatic int junk_git_dir_flags;\nstatic enum {\n\tJUNK_LEAVE_NONE,\n\tJUNK_LEAVE_REPO,\n\tJUNK_LEAVE_ALL\n} junk_mode = JUNK_LEAVE_NONE;\n\nstatic const char junk_leave_repo_msg[] =\nN_(\"Clone succeeded, but checkout failed.\\n\"\n   \"You can inspect what was checked out with 'git status'\\n\"\n   \"and retry with 'git restore --source=HEAD :/'\\n\");\n\nstatic void remove_junk(void)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tswitch (junk_mode) {\n\tcase JUNK_LEAVE_REPO:\n\t\twarning(\"%s\", _(junk_leave_repo_msg));\n\t\t/* fall-through */\n\tcase JUNK_LEAVE_ALL:\n\t\treturn;\n\tdefault:\n\t\t/* proceed to removal */\n\t\tbreak;\n\t}\n\n\tif (junk_git_dir) {\n\t\tstrbuf_addstr(&sb, junk_git_dir);\n\t\tremove_dir_recursively(&sb, junk_git_dir_flags);\n\t\tstrbuf_reset(&sb);\n\t}\n\tif (junk_work_tree) {\n\t\tstrbuf_addstr(&sb, junk_work_tree);\n\t\tremove_dir_recursively(&sb, junk_work_tree_flags);\n\t}\n\tstrbuf_release(&sb);\n}\n\nstatic void remove_junk_on_signal(int signo)\n{\n\tremove_junk();\n\tsigchain_pop(signo);\n\traise(signo);\n}\n\nstatic struct ref *find_remote_branch(const struct ref *refs, const char *branch)\n{\n\tstruct ref *ref;\n\tstruct strbuf head = STRBUF_INIT;\n\tstrbuf_addstr(&head, \"refs/heads/\");\n\tstrbuf_addstr(&head, branch);\n\tref = find_ref_by_name(refs, head.buf);\n\tstrbuf_release(&head);\n\n\tif (ref)\n\t\treturn ref;\n\n\tstrbuf_addstr(&head, \"refs/tags/\");\n\tstrbuf_addstr(&head, branch);\n\tref = find_ref_by_name(refs, head.buf);\n\tstrbuf_release(&head);\n\n\treturn ref;\n}\n\nstatic struct ref *wanted_peer_refs(const struct ref *refs,\n\t\tstruct refspec *refspec)\n{\n\tstruct ref *head = copy_ref(find_ref_by_name(refs, \"HEAD\"));\n\tstruct ref *local_refs = head;\n\tstruct ref **tail = head ? &head->next : &local_refs;\n\n\tif (option_single_branch) {\n\t\tstruct ref *remote_head = NULL;\n\n\t\tif (!option_branch)\n\t\t\tremote_head = guess_remote_head(head, refs, 0);\n\t\telse {\n\t\t\tlocal_refs = NULL;\n\t\t\ttail = &local_refs;\n\t\t\tremote_head = copy_ref(find_remote_branch(refs, option_branch));\n\t\t}\n\n\t\tif (!remote_head && option_branch)\n\t\t\twarning(_(\"Could not find remote branch %s to clone.\"),\n\t\t\t\toption_branch);\n\t\telse {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < refspec->nr; i++)\n\t\t\t\tget_fetch_map(remote_head, &refspec->items[i],\n\t\t\t\t\t      &tail, 0);\n\n\t\t\t/* if --branch=tag, pull the requested tag explicitly */\n\t\t\tget_fetch_map(remote_head, tag_refspec, &tail, 0);\n\t\t}\n\t} else {\n\t\tint i;\n\t\tfor (i = 0; i < refspec->nr; i++)\n\t\t\tget_fetch_map(refs, &refspec->items[i], &tail, 0);\n\t}\n\n\tif (!option_mirror && !option_single_branch && !option_no_tags)\n\t\tget_fetch_map(refs, tag_refspec, &tail, 0);\n\n\treturn local_refs;\n}\n\nstatic void write_remote_refs(const struct ref *local_refs)\n{\n\tconst struct ref *r;\n\n\tstruct ref_transaction *t;\n\tstruct strbuf err = STRBUF_INIT;\n\n\tt = ref_transaction_begin(&err);\n\tif (!t)\n\t\tdie(\"%s\", err.buf);\n\n\tfor (r = local_refs; r; r = r->next) {\n\t\tif (!r->peer_ref)\n\t\t\tcontinue;\n\t\tif (ref_transaction_create(t, r->peer_ref->name, &r->old_oid,\n\t\t\t\t\t   0, NULL, &err))\n\t\t\tdie(\"%s\", err.buf);\n\t}\n\n\tif (initial_ref_transaction_commit(t, &err))\n\t\tdie(\"%s\", err.buf);\n\n\tstrbuf_release(&err);\n\tref_transaction_free(t);\n}\n\nstatic void write_followtags(const struct ref *refs, const char *msg)\n{\n\tconst struct ref *ref;\n\tfor (ref = refs; ref; ref = ref->next) {\n\t\tif (!starts_with(ref->name, \"refs/tags/\"))\n\t\t\tcontinue;\n\t\tif (ends_with(ref->name, \"^{}\"))\n\t\t\tcontinue;\n\t\tif (!has_object_file(&ref->old_oid))\n\t\t\tcontinue;\n\t\tupdate_ref(msg, ref->name, &ref->old_oid, NULL, 0,\n\t\t\t   UPDATE_REFS_DIE_ON_ERR);\n\t}\n}\n\nstatic int iterate_ref_map(void *cb_data, struct object_id *oid)\n{\n\tstruct ref **rm = cb_data;\n\tstruct ref *ref = *rm;\n\n\t/*\n\t * Skip anything missing a peer_ref, which we are not\n\t * actually going to write a ref for.\n\t */\n\twhile (ref && !ref->peer_ref)\n\t\tref = ref->next;\n\t/* Returning -1 notes \"end of list\" to the caller. */\n\tif (!ref)\n\t\treturn -1;\n\n\toidcpy(oid, &ref->old_oid);\n\t*rm = ref->next;\n\treturn 0;\n}\n\nstatic void update_remote_refs(const struct ref *refs,\n\t\t\t       const struct ref *mapped_refs,\n\t\t\t       const struct ref *remote_head_points_at,\n\t\t\t       const char *branch_top,\n\t\t\t       const char *msg,\n\t\t\t       struct transport *transport,\n\t\t\t       int check_connectivity,\n\t\t\t       int check_refs_are_promisor_objects_only)\n{\n\tconst struct ref *rm = mapped_refs;\n\n\tif (check_connectivity) {\n\t\tstruct check_connected_options opt = CHECK_CONNECTED_INIT;\n\n\t\topt.transport = transport;\n\t\topt.progress = transport->progress;\n\t\topt.check_refs_are_promisor_objects_only =\n\t\t\t!!check_refs_are_promisor_objects_only;\n\n\t\tif (check_connected(iterate_ref_map, &rm, &opt))\n\t\t\tdie(_(\"remote did not send all necessary objects\"));\n\t}\n\n\tif (refs) {\n\t\twrite_remote_refs(mapped_refs);\n\t\tif (option_single_branch && !option_no_tags)\n\t\t\twrite_followtags(refs, msg);\n\t}\n\n\tif (remote_head_points_at && !option_bare) {\n\t\tstruct strbuf head_ref = STRBUF_INIT;\n\t\tstrbuf_addstr(&head_ref, branch_top);\n\t\tstrbuf_addstr(&head_ref, \"HEAD\");\n\t\tif (create_symref(head_ref.buf,\n\t\t\t\t  remote_head_points_at->peer_ref->name,\n\t\t\t\t  msg) < 0)\n\t\t\tdie(_(\"unable to update %s\"), head_ref.buf);\n\t\tstrbuf_release(&head_ref);\n\t}\n}\n\nstatic void update_head(const struct ref *our, const struct ref *remote,\n\t\t\tconst char *msg)\n{\n\tconst char *head;\n\tif (our && skip_prefix(our->name, \"refs/heads/\", &head)) {\n\t\t/* Local default branch link */\n\t\tif (create_symref(\"HEAD\", our->name, NULL) < 0)\n\t\t\tdie(_(\"unable to update HEAD\"));\n\t\tif (!option_bare) {\n\t\t\tupdate_ref(msg, \"HEAD\", &our->old_oid, NULL, 0,\n\t\t\t\t   UPDATE_REFS_DIE_ON_ERR);\n\t\t\tinstall_branch_config(0, head, option_origin, our->name);\n\t\t}\n\t} else if (our) {\n\t\tstruct commit *c = lookup_commit_reference(the_repository,\n\t\t\t\t\t\t\t   &our->old_oid);\n\t\t/* --branch specifies a non-branch (i.e. tags), detach HEAD */\n\t\tupdate_ref(msg, \"HEAD\", &c->object.oid, NULL, REF_NO_DEREF,\n\t\t\t   UPDATE_REFS_DIE_ON_ERR);\n\t} else if (remote) {\n\t\t/*\n\t\t * We know remote HEAD points to a non-branch, or\n\t\t * HEAD points to a branch but we don't know which one.\n\t\t * Detach HEAD in all these cases.\n\t\t */\n\t\tupdate_ref(msg, \"HEAD\", &remote->old_oid, NULL, REF_NO_DEREF,\n\t\t\t   UPDATE_REFS_DIE_ON_ERR);\n\t}\n}\n\nstatic int git_sparse_checkout_init(const char *repo)\n{\n\tstruct argv_array argv = ARGV_ARRAY_INIT;\n\tint result = 0;\n\targv_array_pushl(&argv, \"-C\", repo, \"sparse-checkout\", \"init\", NULL);\n\n\t/*\n\t * We must apply the setting in the current process\n\t * for the later checkout to use the sparse-checkout file.\n\t */\n\tcore_apply_sparse_checkout = 1;\n\n\tif (run_command_v_opt(argv.argv, RUN_GIT_CMD)) {\n\t\terror(_(\"failed to initialize sparse-checkout\"));\n\t\tresult = 1;\n\t}\n\n\targv_array_clear(&argv);\n\treturn result;\n}\n\nstatic int checkout(int submodule_progress)\n{\n\tstruct object_id oid;\n\tchar *head;\n\tstruct lock_file lock_file = LOCK_INIT;\n\tstruct unpack_trees_options opts;\n\tstruct tree *tree;\n\tstruct tree_desc t;\n\tint err = 0;\n\n\tif (option_no_checkout)\n\t\treturn 0;\n\n\thead = resolve_refdup(\"HEAD\", RESOLVE_REF_READING, &oid, NULL);\n\tif (!head) {\n\t\twarning(_(\"remote HEAD refers to nonexistent ref, \"\n\t\t\t  \"unable to checkout.\\n\"));\n\t\treturn 0;\n\t}\n\tif (!strcmp(head, \"HEAD\")) {\n\t\tif (advice_detached_head)\n\t\t\tdetach_advice(oid_to_hex(&oid));\n\t} else {\n\t\tif (!starts_with(head, \"refs/heads/\"))\n\t\t\tdie(_(\"HEAD not found below refs/heads!\"));\n\t}\n\tfree(head);\n\n\t/* We need to be in the new work tree for the checkout */\n\tsetup_work_tree();\n\n\thold_locked_index(&lock_file, LOCK_DIE_ON_ERROR);\n\n\tmemset(&opts, 0, sizeof opts);\n\topts.update = 1;\n\topts.merge = 1;\n\topts.clone = 1;\n\topts.fn = oneway_merge;\n\topts.verbose_update = (option_verbosity >= 0);\n\topts.src_index = &the_index;\n\topts.dst_index = &the_index;\n\n\ttree = parse_tree_indirect(&oid);\n\tparse_tree(tree);\n\tinit_tree_desc(&t, tree->buffer, tree->size);\n\tif (unpack_trees(1, &t, &opts) < 0)\n\t\tdie(_(\"unable to checkout working tree\"));\n\n\tif (write_locked_index(&the_index, &lock_file, COMMIT_LOCK))\n\t\tdie(_(\"unable to write new index file\"));\n\n\terr |= run_hook_le(NULL, \"post-checkout\", oid_to_hex(&null_oid),\n\t\t\t   oid_to_hex(&oid), \"1\", NULL);\n\n\tif (!err && (option_recurse_submodules.nr > 0)) {\n\t\tstruct argv_array args = ARGV_ARRAY_INIT;\n\t\targv_array_pushl(&args, \"submodule\", \"update\", \"--require-init\", \"--recursive\", NULL);\n\n\t\tif (option_shallow_submodules == 1)\n\t\t\targv_array_push(&args, \"--depth=1\");\n\n\t\tif (max_jobs != -1)\n\t\t\targv_array_pushf(&args, \"--jobs=%d\", max_jobs);\n\n\t\tif (submodule_progress)\n\t\t\targv_array_push(&args, \"--progress\");\n\n\t\tif (option_verbosity < 0)\n\t\t\targv_array_push(&args, \"--quiet\");\n\n\t\tif (option_remote_submodules) {\n\t\t\targv_array_push(&args, \"--remote\");\n\t\t\targv_array_push(&args, \"--no-fetch\");\n\t\t}\n\n\t\tif (option_single_branch >= 0)\n\t\t\targv_array_push(&args, option_single_branch ?\n\t\t\t\t\t       \"--single-branch\" :\n\t\t\t\t\t       \"--no-single-branch\");\n\n\t\terr = run_command_v_opt(args.argv, RUN_GIT_CMD);\n\t\targv_array_clear(&args);\n\t}\n\n\treturn err;\n}\n\nstatic int write_one_config(const char *key, const char *value, void *data)\n{\n\treturn git_config_set_multivar_gently(key,\n\t\t\t\t\t      value ? value : \"true\",\n\t\t\t\t\t      CONFIG_REGEX_NONE, 0);\n}\n\nstatic void write_config(struct string_list *config)\n{\n\tint i;\n\n\tfor (i = 0; i < config->nr; i++) {\n\t\tif (git_config_parse_parameter(config->items[i].string,\n\t\t\t\t\t       write_one_config, NULL) < 0)\n\t\t\tdie(_(\"unable to write parameters to config file\"));\n\t}\n}\n\nstatic void write_refspec_config(const char *src_ref_prefix,\n\t\tconst struct ref *our_head_points_at,\n\t\tconst struct ref *remote_head_points_at,\n\t\tstruct strbuf *branch_top)\n{\n\tstruct strbuf key = STRBUF_INIT;\n\tstruct strbuf value = STRBUF_INIT;\n\n\tif (option_mirror || !option_bare) {\n\t\tif (option_single_branch && !option_mirror) {\n\t\t\tif (option_branch) {\n\t\t\t\tif (starts_with(our_head_points_at->name, \"refs/tags/\"))\n\t\t\t\t\tstrbuf_addf(&value, \"+%s:%s\", our_head_points_at->name,\n\t\t\t\t\t\tour_head_points_at->name);\n\t\t\t\telse\n\t\t\t\t\tstrbuf_addf(&value, \"+%s:%s%s\", our_head_points_at->name,\n\t\t\t\t\t\tbranch_top->buf, option_branch);\n\t\t\t} else if (remote_head_points_at) {\n\t\t\t\tconst char *head = remote_head_points_at->name;\n\t\t\t\tif (!skip_prefix(head, \"refs/heads/\", &head))\n\t\t\t\t\tBUG(\"remote HEAD points at non-head?\");\n\n\t\t\t\tstrbuf_addf(&value, \"+%s:%s%s\", remote_head_points_at->name,\n\t\t\t\t\t\tbranch_top->buf, head);\n\t\t\t}\n\t\t\t/*\n\t\t\t * otherwise, the next \"git fetch\" will\n\t\t\t * simply fetch from HEAD without updating\n\t\t\t * any remote-tracking branch, which is what\n\t\t\t * we want.\n\t\t\t */\n\t\t} else {\n\t\t\tstrbuf_addf(&value, \"+%s*:%s*\", src_ref_prefix, branch_top->buf);\n\t\t}\n\t\t/* Configure the remote */\n\t\tif (value.len) {\n\t\t\tstrbuf_addf(&key, \"remote.%s.fetch\", option_origin);\n\t\t\tgit_config_set_multivar(key.buf, value.buf, \"^$\", 0);\n\t\t\tstrbuf_reset(&key);\n\n\t\t\tif (option_mirror) {\n\t\t\t\tstrbuf_addf(&key, \"remote.%s.mirror\", option_origin);\n\t\t\t\tgit_config_set(key.buf, \"true\");\n\t\t\t\tstrbuf_reset(&key);\n\t\t\t}\n\t\t}\n\t}\n\n\tstrbuf_release(&key);\n\tstrbuf_release(&value);\n}\n\nstatic void dissociate_from_references(void)\n{\n\tstatic const char* argv[] = { \"repack\", \"-a\", \"-d\", NULL };\n\tchar *alternates = git_pathdup(\"objects/info/alternates\");\n\n\tif (!access(alternates, F_OK)) {\n\t\tif (run_command_v_opt(argv, RUN_GIT_CMD|RUN_COMMAND_NO_STDIN))\n\t\t\tdie(_(\"cannot repack to clean up\"));\n\t\tif (unlink(alternates) && errno != ENOENT)\n\t\t\tdie_errno(_(\"cannot unlink temporary alternates file\"));\n\t}\n\tfree(alternates);\n}\n\nstatic int path_exists(const char *path)\n{\n\tstruct stat sb;\n\treturn !stat(path, &sb);\n}\n\nint cmd_clone(int argc, const char **argv, const char *prefix)\n{\n\tint is_bundle = 0, is_local;\n\tconst char *repo_name, *repo, *work_tree, *git_dir;\n\tchar *path, *dir, *display_repo = NULL;\n\tint dest_exists;\n\tconst struct ref *refs, *remote_head;\n\tconst struct ref *remote_head_points_at;\n\tconst struct ref *our_head_points_at;\n\tstruct ref *mapped_refs;\n\tconst struct ref *ref;\n\tstruct strbuf key = STRBUF_INIT;\n\tstruct strbuf default_refspec = STRBUF_INIT;\n\tstruct strbuf branch_top = STRBUF_INIT, reflog_msg = STRBUF_INIT;\n\tstruct transport *transport = NULL;\n\tconst char *src_ref_prefix = \"refs/heads/\";\n\tstruct remote *remote;\n\tint err = 0, complete_refs_before_fetch = 1;\n\tint submodule_progress;\n\n\tstruct argv_array ref_prefixes = ARGV_ARRAY_INIT;\n\n\tpacket_trace_identity(\"clone\");\n\targc = parse_options(argc, argv, prefix, builtin_clone_options,\n\t\t\t     builtin_clone_usage, 0);\n\n\tif (argc > 2)\n\t\tusage_msg_opt(_(\"Too many arguments.\"),\n\t\t\tbuiltin_clone_usage, builtin_clone_options);\n\n\tif (argc == 0)\n\t\tusage_msg_opt(_(\"You must specify a repository to clone.\"),\n\t\t\tbuiltin_clone_usage, builtin_clone_options);\n\n\tif (option_depth || option_since || option_not.nr)\n\t\tdeepen = 1;\n\tif (option_single_branch == -1)\n\t\toption_single_branch = deepen ? 1 : 0;\n\n\tif (option_mirror)\n\t\toption_bare = 1;\n\n\tif (option_bare) {\n\t\tif (option_origin)\n\t\t\tdie(_(\"--bare and --origin %s options are incompatible.\"),\n\t\t\t    option_origin);\n\t\tif (real_git_dir)\n\t\t\tdie(_(\"--bare and --separate-git-dir are incompatible.\"));\n\t\toption_no_checkout = 1;\n\t}\n\n\tif (!option_origin)\n\t\toption_origin = \"origin\";\n\n\trepo_name = argv[0];\n\n\tpath = get_repo_path(repo_name, &is_bundle);\n\tif (path)\n\t\trepo = absolute_pathdup(repo_name);\n\telse if (strchr(repo_name, ':')) {\n\t\trepo = repo_name;\n\t\tdisplay_repo = transport_anonymize_url(repo);\n\t} else\n\t\tdie(_(\"repository '%s' does not exist\"), repo_name);\n\n\t/* no need to be strict, transport_set_option() will validate it again */\n\tif (option_depth && atoi(option_depth) < 1)\n\t\tdie(_(\"depth %s is not a positive number\"), option_depth);\n\n\tif (argc == 2)\n\t\tdir = xstrdup(argv[1]);\n\telse\n\t\tdir = guess_dir_name(repo_name, is_bundle, option_bare);\n\tstrip_trailing_slashes(dir);\n\n\tdest_exists = path_exists(dir);\n\tif (dest_exists && !is_empty_dir(dir))\n\t\tdie(_(\"destination path '%s' already exists and is not \"\n\t\t\t\"an empty directory.\"), dir);\n\n\tstrbuf_addf(&reflog_msg, \"clone: from %s\",\n\t\t    display_repo ? display_repo : repo);\n\tfree(display_repo);\n\n\tif (option_bare)\n\t\twork_tree = NULL;\n\telse {\n\t\twork_tree = getenv(\"GIT_WORK_TREE\");\n\t\tif (work_tree && path_exists(work_tree))\n\t\t\tdie(_(\"working tree '%s' already exists.\"), work_tree);\n\t}\n\n\tif (option_bare || work_tree)\n\t\tgit_dir = xstrdup(dir);\n\telse {\n\t\twork_tree = dir;\n\t\tgit_dir = mkpathdup(\"%s/.git\", dir);\n\t}\n\n\tatexit(remove_junk);\n\tsigchain_push_common(remove_junk_on_signal);\n\n\tif (!option_bare) {\n\t\tif (safe_create_leading_directories_const(work_tree) < 0)\n\t\t\tdie_errno(_(\"could not create leading directories of '%s'\"),\n\t\t\t\t  work_tree);\n\t\tif (dest_exists)\n\t\t\tjunk_work_tree_flags |= REMOVE_DIR_KEEP_TOPLEVEL;\n\t\telse if (mkdir(work_tree, 0777))\n\t\t\tdie_errno(_(\"could not create work tree dir '%s'\"),\n\t\t\t\t  work_tree);\n\t\tjunk_work_tree = work_tree;\n\t\tset_git_work_tree(work_tree);\n\t}\n\n\tif (real_git_dir) {\n\t\tif (path_exists(real_git_dir))\n\t\t\tjunk_git_dir_flags |= REMOVE_DIR_KEEP_TOPLEVEL;\n\t\tjunk_git_dir = real_git_dir;\n\t} else {\n\t\tif (dest_exists)\n\t\t\tjunk_git_dir_flags |= REMOVE_DIR_KEEP_TOPLEVEL;\n\t\tjunk_git_dir = git_dir;\n\t}\n\tif (safe_create_leading_directories_const(git_dir) < 0)\n\t\tdie(_(\"could not create leading directories of '%s'\"), git_dir);\n\n\tif (0 <= option_verbosity) {\n\t\tif (option_bare)\n\t\t\tfprintf(stderr, _(\"Cloning into bare repository '%s'...\\n\"), dir);\n\t\telse\n\t\t\tfprintf(stderr, _(\"Cloning into '%s'...\\n\"), dir);\n\t}\n\n\tif (option_recurse_submodules.nr > 0) {\n\t\tstruct string_list_item *item;\n\t\tstruct strbuf sb = STRBUF_INIT;\n\n\t\t/* remove duplicates */\n\t\tstring_list_sort(&option_recurse_submodules);\n\t\tstring_list_remove_duplicates(&option_recurse_submodules, 0);\n\n\t\t/*\n\t\t * NEEDSWORK: In a multi-working-tree world, this needs to be\n\t\t * set in the per-worktree config.\n\t\t */\n\t\tfor_each_string_list_item(item, &option_recurse_submodules) {\n\t\t\tstrbuf_addf(&sb, \"submodule.active=%s\",\n\t\t\t\t    item->string);\n\t\t\tstring_list_append(&option_config,\n\t\t\t\t\t   strbuf_detach(&sb, NULL));\n\t\t}\n\n\t\tif (option_required_reference.nr &&\n\t\t    option_optional_reference.nr)\n\t\t\tdie(_(\"clone --recursive is not compatible with \"\n\t\t\t      \"both --reference and --reference-if-able\"));\n\t\telse if (option_required_reference.nr) {\n\t\t\tstring_list_append(&option_config,\n\t\t\t\t\"submodule.alternateLocation=superproject\");\n\t\t\tstring_list_append(&option_config,\n\t\t\t\t\"submodule.alternateErrorStrategy=die\");\n\t\t} else if (option_optional_reference.nr) {\n\t\t\tstring_list_append(&option_config,\n\t\t\t\t\"submodule.alternateLocation=superproject\");\n\t\t\tstring_list_append(&option_config,\n\t\t\t\t\"submodule.alternateErrorStrategy=info\");\n\t\t}\n\t}\n\n\tinit_db(git_dir, real_git_dir, option_template, INIT_DB_QUIET);\n\n\tif (real_git_dir)\n\t\tgit_dir = real_git_dir;\n\n\twrite_config(&option_config);\n\n\tgit_config(git_default_config, NULL);\n\n\tif (option_bare) {\n\t\tif (option_mirror)\n\t\t\tsrc_ref_prefix = \"refs/\";\n\t\tstrbuf_addstr(&branch_top, src_ref_prefix);\n\n\t\tgit_config_set(\"core.bare\", \"true\");\n\t} else {\n\t\tstrbuf_addf(&branch_top, \"refs/remotes/%s/\", option_origin);\n\t}\n\n\tstrbuf_addf(&key, \"remote.%s.url\", option_origin);\n\tgit_config_set(key.buf, repo);\n\tstrbuf_reset(&key);\n\n\tif (option_no_tags) {\n\t\tstrbuf_addf(&key, \"remote.%s.tagOpt\", option_origin);\n\t\tgit_config_set(key.buf, \"--no-tags\");\n\t\tstrbuf_reset(&key);\n\t}\n\n\tif (option_required_reference.nr || option_optional_reference.nr)\n\t\tsetup_reference();\n\n\tif (option_sparse_checkout && git_sparse_checkout_init(dir))\n\t\treturn 1;\n\n\tremote = remote_get(option_origin);\n\n\tstrbuf_addf(&default_refspec, \"+%s*:%s*\", src_ref_prefix,\n\t\t    branch_top.buf);\n\trefspec_append(&remote->fetch, default_refspec.buf);\n\n\ttransport = transport_get(remote, remote->url[0]);\n\ttransport_set_verbosity(transport, option_verbosity, option_progress);\n\ttransport->family = family;\n\n\tpath = get_repo_path(remote->url[0], &is_bundle);\n\tis_local = option_local != 0 && path && !is_bundle;\n\tif (is_local) {\n\t\tif (option_depth)\n\t\t\twarning(_(\"--depth is ignored in local clones; use file:// instead.\"));\n\t\tif (option_since)\n\t\t\twarning(_(\"--shallow-since is ignored in local clones; use file:// instead.\"));\n\t\tif (option_not.nr)\n\t\t\twarning(_(\"--shallow-exclude is ignored in local clones; use file:// instead.\"));\n\t\tif (filter_options.choice)\n\t\t\twarning(_(\"--filter is ignored in local clones; use file:// instead.\"));\n\t\tif (!access(mkpath(\"%s/shallow\", path), F_OK)) {\n\t\t\tif (option_local > 0)\n\t\t\t\twarning(_(\"source repository is shallow, ignoring --local\"));\n\t\t\tis_local = 0;\n\t\t}\n\t}\n\tif (option_local > 0 && !is_local)\n\t\twarning(_(\"--local is ignored\"));\n\ttransport->cloning = 1;\n\n\ttransport_set_option(transport, TRANS_OPT_KEEP, \"yes\");\n\n\tif (option_depth)\n\t\ttransport_set_option(transport, TRANS_OPT_DEPTH,\n\t\t\t\t     option_depth);\n\tif (option_since)\n\t\ttransport_set_option(transport, TRANS_OPT_DEEPEN_SINCE,\n\t\t\t\t     option_since);\n\tif (option_not.nr)\n\t\ttransport_set_option(transport, TRANS_OPT_DEEPEN_NOT,\n\t\t\t\t     (const char *)&option_not);\n\tif (option_single_branch)\n\t\ttransport_set_option(transport, TRANS_OPT_FOLLOWTAGS, \"1\");\n\n\tif (option_upload_pack)\n\t\ttransport_set_option(transport, TRANS_OPT_UPLOADPACK,\n\t\t\t\t     option_upload_pack);\n\n\tif (server_options.nr)\n\t\ttransport->server_options = &server_options;\n\n\tif (filter_options.choice) {\n\t\tconst char *spec =\n\t\t\texpand_list_objects_filter_spec(&filter_options);\n\t\ttransport_set_option(transport, TRANS_OPT_LIST_OBJECTS_FILTER,\n\t\t\t\t     spec);\n\t\ttransport_set_option(transport, TRANS_OPT_FROM_PROMISOR, \"1\");\n\t}\n\n\tif (transport->smart_options && !deepen && !filter_options.choice)\n\t\ttransport->smart_options->check_self_contained_and_connected = 1;\n\n\n\targv_array_push(&ref_prefixes, \"HEAD\");\n\trefspec_ref_prefixes(&remote->fetch, &ref_prefixes);\n\tif (option_branch)\n\t\texpand_ref_prefix(&ref_prefixes, option_branch);\n\tif (!option_no_tags)\n\t\targv_array_push(&ref_prefixes, \"refs/tags/\");\n\n\trefs = transport_get_remote_refs(transport, &ref_prefixes);\n\n\tif (refs) {\n\t\tmapped_refs = wanted_peer_refs(refs, &remote->fetch);\n\t\t/*\n\t\t * transport_get_remote_refs() may return refs with null sha-1\n\t\t * in mapped_refs (see struct transport->get_refs_list\n\t\t * comment). In that case we need fetch it early because\n\t\t * remote_head code below relies on it.\n\t\t *\n\t\t * for normal clones, transport_get_remote_refs() should\n\t\t * return reliable ref set, we can delay cloning until after\n\t\t * remote HEAD check.\n\t\t */\n\t\tfor (ref = refs; ref; ref = ref->next)\n\t\t\tif (is_null_oid(&ref->old_oid)) {\n\t\t\t\tcomplete_refs_before_fetch = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!is_local && !complete_refs_before_fetch)\n\t\t\ttransport_fetch_refs(transport, mapped_refs);\n\n\t\tremote_head = find_ref_by_name(refs, \"HEAD\");\n\t\tremote_head_points_at =\n\t\t\tguess_remote_head(remote_head, mapped_refs, 0);\n\n\t\tif (option_branch) {\n\t\t\tour_head_points_at =\n\t\t\t\tfind_remote_branch(mapped_refs, option_branch);\n\n\t\t\tif (!our_head_points_at)\n\t\t\t\tdie(_(\"Remote branch %s not found in upstream %s\"),\n\t\t\t\t    option_branch, option_origin);\n\t\t}\n\t\telse\n\t\t\tour_head_points_at = remote_head_points_at;\n\t}\n\telse {\n\t\tif (option_branch)\n\t\t\tdie(_(\"Remote branch %s not found in upstream %s\"),\n\t\t\t\t\toption_branch, option_origin);\n\n\t\twarning(_(\"You appear to have cloned an empty repository.\"));\n\t\tmapped_refs = NULL;\n\t\tour_head_points_at = NULL;\n\t\tremote_head_points_at = NULL;\n\t\tremote_head = NULL;\n\t\toption_no_checkout = 1;\n\t\tif (!option_bare)\n\t\t\tinstall_branch_config(0, \"master\", option_origin,\n\t\t\t\t\t      \"refs/heads/master\");\n\t}\n\n\twrite_refspec_config(src_ref_prefix, our_head_points_at,\n\t\t\tremote_head_points_at, &branch_top);\n\n\tif (filter_options.choice)\n\t\tpartial_clone_register(option_origin, &filter_options);\n\n\tif (is_local)\n\t\tclone_local(path, git_dir);\n\telse if (refs && complete_refs_before_fetch)\n\t\ttransport_fetch_refs(transport, mapped_refs);\n\n\tupdate_remote_refs(refs, mapped_refs, remote_head_points_at,\n\t\t\t   branch_top.buf, reflog_msg.buf, transport,\n\t\t\t   !is_local, filter_options.choice);\n\n\tupdate_head(our_head_points_at, remote_head, reflog_msg.buf);\n\n\t/*\n\t * We want to show progress for recursive submodule clones iff\n\t * we did so for the main clone. But only the transport knows\n\t * the final decision for this flag, so we need to rescue the value\n\t * before we free the transport.\n\t */\n\tsubmodule_progress = transport->progress;\n\n\ttransport_unlock_pack(transport);\n\ttransport_disconnect(transport);\n\n\tif (option_dissociate) {\n\t\tclose_object_store(the_repository->objects);\n\t\tdissociate_from_references();\n\t}\n\n\tjunk_mode = JUNK_LEAVE_REPO;\n\terr = checkout(submodule_progress);\n\n\tstrbuf_release(&reflog_msg);\n\tstrbuf_release(&branch_top);\n\tstrbuf_release(&key);\n\tstrbuf_release(&default_refspec);\n\tjunk_mode = JUNK_LEAVE_ALL;\n\n\targv_array_clear(&ref_prefixes);\n\treturn err;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "002d23ab0a2d56aca497e5fac77c363372db3408",
  "sha1_ok": true,
  "size": 37257
}
