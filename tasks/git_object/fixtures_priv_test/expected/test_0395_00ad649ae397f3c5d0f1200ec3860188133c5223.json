{
  "content": {
    "base64": "LyoKICogQ29weXJpZ2h0IChjKSAyMDExLCBHb29nbGUgSW5jLgogKi8KCiNkZWZpbmUgVVNFX1RIRV9SRVBPU0lUT1JZX1ZBUklBQkxFCgojaW5jbHVkZSAiZ2l0LWNvbXBhdC11dGlsLmgiCiNpbmNsdWRlICJjb252ZXJ0LmgiCiNpbmNsdWRlICJlbnZpcm9ubWVudC5oIgojaW5jbHVkZSAic3RyZWFtaW5nLmgiCiNpbmNsdWRlICJyZXBvc2l0b3J5LmgiCiNpbmNsdWRlICJvYmplY3QtZmlsZS5oIgojaW5jbHVkZSAib2RiLmgiCiNpbmNsdWRlICJyZXBsYWNlLW9iamVjdC5oIgojaW5jbHVkZSAicGFja2ZpbGUuaCIKCnR5cGVkZWYgaW50ICgqb3Blbl9pc3RyZWFtX2ZuKShzdHJ1Y3QgZ2l0X2lzdHJlYW0gKiwKCQkJICAgICAgIHN0cnVjdCByZXBvc2l0b3J5ICosCgkJCSAgICAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICosCgkJCSAgICAgICBlbnVtIG9iamVjdF90eXBlICopOwp0eXBlZGVmIGludCAoKmNsb3NlX2lzdHJlYW1fZm4pKHN0cnVjdCBnaXRfaXN0cmVhbSAqKTsKdHlwZWRlZiBzc2l6ZV90ICgqcmVhZF9pc3RyZWFtX2ZuKShzdHJ1Y3QgZ2l0X2lzdHJlYW0gKiwgY2hhciAqLCBzaXplX3QpOwoKI2RlZmluZSBGSUxURVJfQlVGRkVSICgxMDI0KjE2KQoKc3RydWN0IGZpbHRlcmVkX2lzdHJlYW0gewoJc3RydWN0IGdpdF9pc3RyZWFtICp1cHN0cmVhbTsKCXN0cnVjdCBzdHJlYW1fZmlsdGVyICpmaWx0ZXI7CgljaGFyIGlidWZbRklMVEVSX0JVRkZFUl07CgljaGFyIG9idWZbRklMVEVSX0JVRkZFUl07CglpbnQgaV9lbmQsIGlfcHRyOwoJaW50IG9fZW5kLCBvX3B0cjsKCWludCBpbnB1dF9maW5pc2hlZDsKfTsKCnN0cnVjdCBnaXRfaXN0cmVhbSB7CglvcGVuX2lzdHJlYW1fZm4gb3BlbjsKCWNsb3NlX2lzdHJlYW1fZm4gY2xvc2U7CglyZWFkX2lzdHJlYW1fZm4gcmVhZDsKCgl1bnNpZ25lZCBsb25nIHNpemU7IC8qIGluZmxhdGVkIHNpemUgb2YgZnVsbCBvYmplY3QgKi8KCWdpdF96c3RyZWFtIHo7CgllbnVtIHsgel91bnVzZWQsIHpfdXNlZCwgel9kb25lLCB6X2Vycm9yIH0gel9zdGF0ZTsKCgl1bmlvbiB7CgkJc3RydWN0IHsKCQkJY2hhciAqYnVmOyAvKiBmcm9tIG9kYl9yZWFkX29iamVjdF9pbmZvX2V4dGVuZGVkKCkgKi8KCQkJdW5zaWduZWQgbG9uZyByZWFkX3B0cjsKCQl9IGluY29yZTsKCgkJc3RydWN0IHsKCQkJdm9pZCAqbWFwcGVkOwoJCQl1bnNpZ25lZCBsb25nIG1hcHNpemU7CgkJCWNoYXIgaGRyWzMyXTsKCQkJaW50IGhkcl9hdmFpbDsKCQkJaW50IGhkcl91c2VkOwoJCX0gbG9vc2U7CgoJCXN0cnVjdCB7CgkJCXN0cnVjdCBwYWNrZWRfZ2l0ICpwYWNrOwoJCQlvZmZfdCBwb3M7CgkJfSBpbl9wYWNrOwoKCQlzdHJ1Y3QgZmlsdGVyZWRfaXN0cmVhbSBmaWx0ZXJlZDsKCX0gdTsKfTsKCi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKgogKgogKiBDb21tb24gaGVscGVycwogKgogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovCgpzdGF0aWMgdm9pZCBjbG9zZV9kZWZsYXRlZF9zdHJlYW0oc3RydWN0IGdpdF9pc3RyZWFtICpzdCkKewoJaWYgKHN0LT56X3N0YXRlID09IHpfdXNlZCkKCQlnaXRfaW5mbGF0ZV9lbmQoJnN0LT56KTsKfQoKCi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKgogKgogKiBGaWx0ZXJlZCBzdHJlYW0KICoKICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLwoKc3RhdGljIGludCBjbG9zZV9pc3RyZWFtX2ZpbHRlcmVkKHN0cnVjdCBnaXRfaXN0cmVhbSAqc3QpCnsKCWZyZWVfc3RyZWFtX2ZpbHRlcihzdC0+dS5maWx0ZXJlZC5maWx0ZXIpOwoJcmV0dXJuIGNsb3NlX2lzdHJlYW0oc3QtPnUuZmlsdGVyZWQudXBzdHJlYW0pOwp9CgpzdGF0aWMgc3NpemVfdCByZWFkX2lzdHJlYW1fZmlsdGVyZWQoc3RydWN0IGdpdF9pc3RyZWFtICpzdCwgY2hhciAqYnVmLAoJCQkJICAgICBzaXplX3Qgc3opCnsKCXN0cnVjdCBmaWx0ZXJlZF9pc3RyZWFtICpmcyA9ICYoc3QtPnUuZmlsdGVyZWQpOwoJc2l6ZV90IGZpbGxlZCA9IDA7CgoJd2hpbGUgKHN6KSB7CgkJLyogZG8gd2UgYWxyZWFkeSBoYXZlIGZpbHRlcmVkIG91dHB1dD8gKi8KCQlpZiAoZnMtPm9fcHRyIDwgZnMtPm9fZW5kKSB7CgkJCXNpemVfdCB0b19tb3ZlID0gZnMtPm9fZW5kIC0gZnMtPm9fcHRyOwoJCQlpZiAoc3ogPCB0b19tb3ZlKQoJCQkJdG9fbW92ZSA9IHN6OwoJCQltZW1jcHkoYnVmICsgZmlsbGVkLCBmcy0+b2J1ZiArIGZzLT5vX3B0ciwgdG9fbW92ZSk7CgkJCWZzLT5vX3B0ciArPSB0b19tb3ZlOwoJCQlzeiAtPSB0b19tb3ZlOwoJCQlmaWxsZWQgKz0gdG9fbW92ZTsKCQkJY29udGludWU7CgkJfQoJCWZzLT5vX2VuZCA9IGZzLT5vX3B0ciA9IDA7CgoJCS8qIGRvIHdlIGhhdmUgYW55dGhpbmcgdG8gZmVlZCB0aGUgZmlsdGVyIHdpdGg/ICovCgkJaWYgKGZzLT5pX3B0ciA8IGZzLT5pX2VuZCkgewoJCQlzaXplX3QgdG9fZmVlZCA9IGZzLT5pX2VuZCAtIGZzLT5pX3B0cjsKCQkJc2l6ZV90IHRvX3JlY2VpdmUgPSBGSUxURVJfQlVGRkVSOwoJCQlpZiAoc3RyZWFtX2ZpbHRlcihmcy0+ZmlsdGVyLAoJCQkJCSAgZnMtPmlidWYgKyBmcy0+aV9wdHIsICZ0b19mZWVkLAoJCQkJCSAgZnMtPm9idWYsICZ0b19yZWNlaXZlKSkKCQkJCXJldHVybiAtMTsKCQkJZnMtPmlfcHRyID0gZnMtPmlfZW5kIC0gdG9fZmVlZDsKCQkJZnMtPm9fZW5kID0gRklMVEVSX0JVRkZFUiAtIHRvX3JlY2VpdmU7CgkJCWNvbnRpbnVlOwoJCX0KCgkJLyogdGVsbCB0aGUgZmlsdGVyIHRvIGRyYWluIHVwb24gbm8gbW9yZSBpbnB1dCAqLwoJCWlmIChmcy0+aW5wdXRfZmluaXNoZWQpIHsKCQkJc2l6ZV90IHRvX3JlY2VpdmUgPSBGSUxURVJfQlVGRkVSOwoJCQlpZiAoc3RyZWFtX2ZpbHRlcihmcy0+ZmlsdGVyLAoJCQkJCSAgTlVMTCwgTlVMTCwKCQkJCQkgIGZzLT5vYnVmLCAmdG9fcmVjZWl2ZSkpCgkJCQlyZXR1cm4gLTE7CgkJCWZzLT5vX2VuZCA9IEZJTFRFUl9CVUZGRVIgLSB0b19yZWNlaXZlOwoJCQlpZiAoIWZzLT5vX2VuZCkKCQkJCWJyZWFrOwoJCQljb250aW51ZTsKCQl9CgkJZnMtPmlfZW5kID0gZnMtPmlfcHRyID0gMDsKCgkJLyogcmVmaWxsIHRoZSBpbnB1dCBmcm9tIHRoZSB1cHN0cmVhbSAqLwoJCWlmICghZnMtPmlucHV0X2ZpbmlzaGVkKSB7CgkJCWZzLT5pX2VuZCA9IHJlYWRfaXN0cmVhbShmcy0+dXBzdHJlYW0sIGZzLT5pYnVmLCBGSUxURVJfQlVGRkVSKTsKCQkJaWYgKGZzLT5pX2VuZCA8IDApCgkJCQlyZXR1cm4gLTE7CgkJCWlmIChmcy0+aV9lbmQpCgkJCQljb250aW51ZTsKCQl9CgkJZnMtPmlucHV0X2ZpbmlzaGVkID0gMTsKCX0KCXJldHVybiBmaWxsZWQ7Cn0KCnN0YXRpYyBzdHJ1Y3QgZ2l0X2lzdHJlYW0gKmF0dGFjaF9zdHJlYW1fZmlsdGVyKHN0cnVjdCBnaXRfaXN0cmVhbSAqc3QsCgkJCQkJCXN0cnVjdCBzdHJlYW1fZmlsdGVyICpmaWx0ZXIpCnsKCXN0cnVjdCBnaXRfaXN0cmVhbSAqaWZzID0geG1hbGxvYyhzaXplb2YoKmlmcykpOwoJc3RydWN0IGZpbHRlcmVkX2lzdHJlYW0gKmZzID0gJihpZnMtPnUuZmlsdGVyZWQpOwoKCWlmcy0+Y2xvc2UgPSBjbG9zZV9pc3RyZWFtX2ZpbHRlcmVkOwoJaWZzLT5yZWFkID0gcmVhZF9pc3RyZWFtX2ZpbHRlcmVkOwoJZnMtPnVwc3RyZWFtID0gc3Q7Cglmcy0+ZmlsdGVyID0gZmlsdGVyOwoJZnMtPmlfZW5kID0gZnMtPmlfcHRyID0gMDsKCWZzLT5vX2VuZCA9IGZzLT5vX3B0ciA9IDA7Cglmcy0+aW5wdXRfZmluaXNoZWQgPSAwOwoJaWZzLT5zaXplID0gLTE7IC8qIHVua25vd24gKi8KCXJldHVybiBpZnM7Cn0KCi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKgogKgogKiBMb29zZSBvYmplY3Qgc3RyZWFtCiAqCiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8KCnN0YXRpYyBzc2l6ZV90IHJlYWRfaXN0cmVhbV9sb29zZShzdHJ1Y3QgZ2l0X2lzdHJlYW0gKnN0LCBjaGFyICpidWYsIHNpemVfdCBzeikKewoJc2l6ZV90IHRvdGFsX3JlYWQgPSAwOwoKCXN3aXRjaCAoc3QtPnpfc3RhdGUpIHsKCWNhc2Ugel9kb25lOgoJCXJldHVybiAwOwoJY2FzZSB6X2Vycm9yOgoJCXJldHVybiAtMTsKCWRlZmF1bHQ6CgkJYnJlYWs7Cgl9CgoJaWYgKHN0LT51Lmxvb3NlLmhkcl91c2VkIDwgc3QtPnUubG9vc2UuaGRyX2F2YWlsKSB7CgkJc2l6ZV90IHRvX2NvcHkgPSBzdC0+dS5sb29zZS5oZHJfYXZhaWwgLSBzdC0+dS5sb29zZS5oZHJfdXNlZDsKCQlpZiAoc3ogPCB0b19jb3B5KQoJCQl0b19jb3B5ID0gc3o7CgkJbWVtY3B5KGJ1Ziwgc3QtPnUubG9vc2UuaGRyICsgc3QtPnUubG9vc2UuaGRyX3VzZWQsIHRvX2NvcHkpOwoJCXN0LT51Lmxvb3NlLmhkcl91c2VkICs9IHRvX2NvcHk7CgkJdG90YWxfcmVhZCArPSB0b19jb3B5OwoJfQoKCXdoaWxlICh0b3RhbF9yZWFkIDwgc3opIHsKCQlpbnQgc3RhdHVzOwoKCQlzdC0+ei5uZXh0X291dCA9ICh1bnNpZ25lZCBjaGFyICopYnVmICsgdG90YWxfcmVhZDsKCQlzdC0+ei5hdmFpbF9vdXQgPSBzeiAtIHRvdGFsX3JlYWQ7CgkJc3RhdHVzID0gZ2l0X2luZmxhdGUoJnN0LT56LCBaX0ZJTklTSCk7CgoJCXRvdGFsX3JlYWQgPSBzdC0+ei5uZXh0X291dCAtICh1bnNpZ25lZCBjaGFyICopYnVmOwoKCQlpZiAoc3RhdHVzID09IFpfU1RSRUFNX0VORCkgewoJCQlnaXRfaW5mbGF0ZV9lbmQoJnN0LT56KTsKCQkJc3QtPnpfc3RhdGUgPSB6X2RvbmU7CgkJCWJyZWFrOwoJCX0KCQlpZiAoc3RhdHVzICE9IFpfT0sgJiYgKHN0YXR1cyAhPSBaX0JVRl9FUlJPUiB8fCB0b3RhbF9yZWFkIDwgc3opKSB7CgkJCWdpdF9pbmZsYXRlX2VuZCgmc3QtPnopOwoJCQlzdC0+el9zdGF0ZSA9IHpfZXJyb3I7CgkJCXJldHVybiAtMTsKCQl9Cgl9CglyZXR1cm4gdG90YWxfcmVhZDsKfQoKc3RhdGljIGludCBjbG9zZV9pc3RyZWFtX2xvb3NlKHN0cnVjdCBnaXRfaXN0cmVhbSAqc3QpCnsKCWNsb3NlX2RlZmxhdGVkX3N0cmVhbShzdCk7CgltdW5tYXAoc3QtPnUubG9vc2UubWFwcGVkLCBzdC0+dS5sb29zZS5tYXBzaXplKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IG9wZW5faXN0cmVhbV9sb29zZShzdHJ1Y3QgZ2l0X2lzdHJlYW0gKnN0LCBzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJICAgICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgICAgICBlbnVtIG9iamVjdF90eXBlICp0eXBlKQp7CglzdHJ1Y3Qgb2JqZWN0X2luZm8gb2kgPSBPQkpFQ1RfSU5GT19JTklUOwoJc3RydWN0IG9kYl9zb3VyY2UgKnNvdXJjZTsKCglvaS5zaXplcCA9ICZzdC0+c2l6ZTsKCW9pLnR5cGVwID0gdHlwZTsKCglvZGJfcHJlcGFyZV9hbHRlcm5hdGVzKHItPm9iamVjdHMpOwoJZm9yIChzb3VyY2UgPSByLT5vYmplY3RzLT5zb3VyY2VzOyBzb3VyY2U7IHNvdXJjZSA9IHNvdXJjZS0+bmV4dCkgewoJCXN0LT51Lmxvb3NlLm1hcHBlZCA9IG9kYl9zb3VyY2VfbG9vc2VfbWFwX29iamVjdChzb3VyY2UsIG9pZCwKCQkJCQkJCQkgJnN0LT51Lmxvb3NlLm1hcHNpemUpOwoJCWlmIChzdC0+dS5sb29zZS5tYXBwZWQpCgkJCWJyZWFrOwoJfQoJaWYgKCFzdC0+dS5sb29zZS5tYXBwZWQpCgkJcmV0dXJuIC0xOwoKCXN3aXRjaCAodW5wYWNrX2xvb3NlX2hlYWRlcigmc3QtPnosIHN0LT51Lmxvb3NlLm1hcHBlZCwKCQkJCSAgICBzdC0+dS5sb29zZS5tYXBzaXplLCBzdC0+dS5sb29zZS5oZHIsCgkJCQkgICAgc2l6ZW9mKHN0LT51Lmxvb3NlLmhkcikpKSB7CgljYXNlIFVMSFJfT0s6CgkJYnJlYWs7CgljYXNlIFVMSFJfQkFEOgoJY2FzZSBVTEhSX1RPT19MT05HOgoJCWdvdG8gZXJyb3I7Cgl9CglpZiAocGFyc2VfbG9vc2VfaGVhZGVyKHN0LT51Lmxvb3NlLmhkciwgJm9pKSA8IDAgfHwgKnR5cGUgPCAwKQoJCWdvdG8gZXJyb3I7CgoJc3QtPnUubG9vc2UuaGRyX3VzZWQgPSBzdHJsZW4oc3QtPnUubG9vc2UuaGRyKSArIDE7CglzdC0+dS5sb29zZS5oZHJfYXZhaWwgPSBzdC0+ei50b3RhbF9vdXQ7CglzdC0+el9zdGF0ZSA9IHpfdXNlZDsKCXN0LT5jbG9zZSA9IGNsb3NlX2lzdHJlYW1fbG9vc2U7CglzdC0+cmVhZCA9IHJlYWRfaXN0cmVhbV9sb29zZTsKCglyZXR1cm4gMDsKZXJyb3I6CglnaXRfaW5mbGF0ZV9lbmQoJnN0LT56KTsKCW11bm1hcChzdC0+dS5sb29zZS5tYXBwZWQsIHN0LT51Lmxvb3NlLm1hcHNpemUpOwoJcmV0dXJuIC0xOwp9CgoKLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqCiAqCiAqIE5vbi1kZWx0YSBwYWNrZWQgb2JqZWN0IHN0cmVhbQogKgogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovCgpzdGF0aWMgc3NpemVfdCByZWFkX2lzdHJlYW1fcGFja19ub25fZGVsdGEoc3RydWN0IGdpdF9pc3RyZWFtICpzdCwgY2hhciAqYnVmLAoJCQkJCSAgIHNpemVfdCBzeikKewoJc2l6ZV90IHRvdGFsX3JlYWQgPSAwOwoKCXN3aXRjaCAoc3QtPnpfc3RhdGUpIHsKCWNhc2Ugel91bnVzZWQ6CgkJbWVtc2V0KCZzdC0+eiwgMCwgc2l6ZW9mKHN0LT56KSk7CgkJZ2l0X2luZmxhdGVfaW5pdCgmc3QtPnopOwoJCXN0LT56X3N0YXRlID0gel91c2VkOwoJCWJyZWFrOwoJY2FzZSB6X2RvbmU6CgkJcmV0dXJuIDA7CgljYXNlIHpfZXJyb3I6CgkJcmV0dXJuIC0xOwoJY2FzZSB6X3VzZWQ6CgkJYnJlYWs7Cgl9CgoJd2hpbGUgKHRvdGFsX3JlYWQgPCBzeikgewoJCWludCBzdGF0dXM7CgkJc3RydWN0IHBhY2tfd2luZG93ICp3aW5kb3cgPSBOVUxMOwoJCXVuc2lnbmVkIGNoYXIgKm1hcHBlZDsKCgkJbWFwcGVkID0gdXNlX3BhY2soc3QtPnUuaW5fcGFjay5wYWNrLCAmd2luZG93LAoJCQkJICBzdC0+dS5pbl9wYWNrLnBvcywgJnN0LT56LmF2YWlsX2luKTsKCgkJc3QtPnoubmV4dF9vdXQgPSAodW5zaWduZWQgY2hhciAqKWJ1ZiArIHRvdGFsX3JlYWQ7CgkJc3QtPnouYXZhaWxfb3V0ID0gc3ogLSB0b3RhbF9yZWFkOwoJCXN0LT56Lm5leHRfaW4gPSBtYXBwZWQ7CgkJc3RhdHVzID0gZ2l0X2luZmxhdGUoJnN0LT56LCBaX0ZJTklTSCk7CgoJCXN0LT51LmluX3BhY2sucG9zICs9IHN0LT56Lm5leHRfaW4gLSBtYXBwZWQ7CgkJdG90YWxfcmVhZCA9IHN0LT56Lm5leHRfb3V0IC0gKHVuc2lnbmVkIGNoYXIgKilidWY7CgkJdW51c2VfcGFjaygmd2luZG93KTsKCgkJaWYgKHN0YXR1cyA9PSBaX1NUUkVBTV9FTkQpIHsKCQkJZ2l0X2luZmxhdGVfZW5kKCZzdC0+eik7CgkJCXN0LT56X3N0YXRlID0gel9kb25lOwoJCQlicmVhazsKCQl9CgoJCS8qCgkJICogVW5saWtlIHRoZSBsb29zZSBvYmplY3QgY2FzZSwgd2UgZG8gbm90IGhhdmUgdG8gd29ycnkgaGVyZQoJCSAqIGFib3V0IHJ1bm5pbmcgb3V0IG9mIGlucHV0IGJ5dGVzIGFuZCBzcGlubmluZyBpbmZpbml0ZWx5LiBJZgoJCSAqIHdlIGdldCBaX0JVRl9FUlJPUiBkdWUgdG8gdG9vIGZldyBpbnB1dCBieXRlcywgdGhlbiB3ZSdsbAoJCSAqIHJlcGxlbmlzaCB0aGVtIGluIHRoZSBuZXh0IHVzZV9wYWNrKCkgY2FsbCB3aGVuIHdlIGxvb3AuIElmCgkJICogd2UgdHJ1bHkgaGl0IHRoZSBlbmQgb2YgdGhlIHBhY2sgKGkuZS4sIGJlY2F1c2UgaXQncyBjb3JydXB0CgkJICogb3IgdHJ1bmNhdGVkKSwgdGhlbiB1c2VfcGFjaygpIGNhdGNoZXMgdGhhdCBhbmQgd2lsbCBkaWUoKS4KCQkgKi8KCQlpZiAoc3RhdHVzICE9IFpfT0sgJiYgc3RhdHVzICE9IFpfQlVGX0VSUk9SKSB7CgkJCWdpdF9pbmZsYXRlX2VuZCgmc3QtPnopOwoJCQlzdC0+el9zdGF0ZSA9IHpfZXJyb3I7CgkJCXJldHVybiAtMTsKCQl9Cgl9CglyZXR1cm4gdG90YWxfcmVhZDsKfQoKc3RhdGljIGludCBjbG9zZV9pc3RyZWFtX3BhY2tfbm9uX2RlbHRhKHN0cnVjdCBnaXRfaXN0cmVhbSAqc3QpCnsKCWNsb3NlX2RlZmxhdGVkX3N0cmVhbShzdCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBvcGVuX2lzdHJlYW1fcGFja19ub25fZGVsdGEoc3RydWN0IGdpdF9pc3RyZWFtICpzdCwKCQkJCSAgICAgICBzdHJ1Y3QgcmVwb3NpdG9yeSAqciBVTlVTRUQsCgkJCQkgICAgICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkIFVOVVNFRCwKCQkJCSAgICAgICBlbnVtIG9iamVjdF90eXBlICp0eXBlIFVOVVNFRCkKewoJc3RydWN0IHBhY2tfd2luZG93ICp3aW5kb3c7CgllbnVtIG9iamVjdF90eXBlIGluX3BhY2tfdHlwZTsKCgl3aW5kb3cgPSBOVUxMOwoKCWluX3BhY2tfdHlwZSA9IHVucGFja19vYmplY3RfaGVhZGVyKHN0LT51LmluX3BhY2sucGFjaywKCQkJCQkgICAgJndpbmRvdywKCQkJCQkgICAgJnN0LT51LmluX3BhY2sucG9zLAoJCQkJCSAgICAmc3QtPnNpemUpOwoJdW51c2VfcGFjaygmd2luZG93KTsKCXN3aXRjaCAoaW5fcGFja190eXBlKSB7CglkZWZhdWx0OgoJCXJldHVybiAtMTsgLyogd2UgZG8gbm90IGRvIGRlbHRhcyBmb3Igbm93ICovCgljYXNlIE9CSl9DT01NSVQ6CgljYXNlIE9CSl9UUkVFOgoJY2FzZSBPQkpfQkxPQjoKCWNhc2UgT0JKX1RBRzoKCQlicmVhazsKCX0KCXN0LT56X3N0YXRlID0gel91bnVzZWQ7CglzdC0+Y2xvc2UgPSBjbG9zZV9pc3RyZWFtX3BhY2tfbm9uX2RlbHRhOwoJc3QtPnJlYWQgPSByZWFkX2lzdHJlYW1fcGFja19ub25fZGVsdGE7CgoJcmV0dXJuIDA7Cn0KCgovKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioKICoKICogSW4tY29yZSBzdHJlYW0KICoKICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLwoKc3RhdGljIGludCBjbG9zZV9pc3RyZWFtX2luY29yZShzdHJ1Y3QgZ2l0X2lzdHJlYW0gKnN0KQp7CglmcmVlKHN0LT51LmluY29yZS5idWYpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBzc2l6ZV90IHJlYWRfaXN0cmVhbV9pbmNvcmUoc3RydWN0IGdpdF9pc3RyZWFtICpzdCwgY2hhciAqYnVmLCBzaXplX3Qgc3opCnsKCXNpemVfdCByZWFkX3NpemUgPSBzejsKCXNpemVfdCByZW1haW5kZXIgPSBzdC0+c2l6ZSAtIHN0LT51LmluY29yZS5yZWFkX3B0cjsKCglpZiAocmVtYWluZGVyIDw9IHJlYWRfc2l6ZSkKCQlyZWFkX3NpemUgPSByZW1haW5kZXI7CglpZiAocmVhZF9zaXplKSB7CgkJbWVtY3B5KGJ1Ziwgc3QtPnUuaW5jb3JlLmJ1ZiArIHN0LT51LmluY29yZS5yZWFkX3B0ciwgcmVhZF9zaXplKTsKCQlzdC0+dS5pbmNvcmUucmVhZF9wdHIgKz0gcmVhZF9zaXplOwoJfQoJcmV0dXJuIHJlYWRfc2l6ZTsKfQoKc3RhdGljIGludCBvcGVuX2lzdHJlYW1faW5jb3JlKHN0cnVjdCBnaXRfaXN0cmVhbSAqc3QsIHN0cnVjdCByZXBvc2l0b3J5ICpyLAoJCQkgICAgICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBlbnVtIG9iamVjdF90eXBlICp0eXBlKQp7CglzdHJ1Y3Qgb2JqZWN0X2luZm8gb2kgPSBPQkpFQ1RfSU5GT19JTklUOwoKCXN0LT51LmluY29yZS5yZWFkX3B0ciA9IDA7CglzdC0+Y2xvc2UgPSBjbG9zZV9pc3RyZWFtX2luY29yZTsKCXN0LT5yZWFkID0gcmVhZF9pc3RyZWFtX2luY29yZTsKCglvaS50eXBlcCA9IHR5cGU7CglvaS5zaXplcCA9ICZzdC0+c2l6ZTsKCW9pLmNvbnRlbnRwID0gKHZvaWQgKiopJnN0LT51LmluY29yZS5idWY7CglyZXR1cm4gb2RiX3JlYWRfb2JqZWN0X2luZm9fZXh0ZW5kZWQoci0+b2JqZWN0cywgb2lkLCAmb2ksCgkJCQkJICAgICBPQkpFQ1RfSU5GT19ESUVfSUZfQ09SUlVQVCk7Cn0KCi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKgogKiBzdGF0aWMgaGVscGVycyB2YXJpYWJsZXMgYW5kIGZ1bmN0aW9ucyBmb3IgdXNlcnMgb2Ygc3RyZWFtaW5nIGludGVyZmFjZQogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovCgpzdGF0aWMgaW50IGlzdHJlYW1fc291cmNlKHN0cnVjdCBnaXRfaXN0cmVhbSAqc3QsCgkJCSAgc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCSAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgIGVudW0gb2JqZWN0X3R5cGUgKnR5cGUpCnsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCWludCBzdGF0dXM7CglzdHJ1Y3Qgb2JqZWN0X2luZm8gb2kgPSBPQkpFQ1RfSU5GT19JTklUOwoKCW9pLnR5cGVwID0gdHlwZTsKCW9pLnNpemVwID0gJnNpemU7CglzdGF0dXMgPSBvZGJfcmVhZF9vYmplY3RfaW5mb19leHRlbmRlZChyLT5vYmplY3RzLCBvaWQsICZvaSwgMCk7CglpZiAoc3RhdHVzIDwgMCkKCQlyZXR1cm4gc3RhdHVzOwoKCXN3aXRjaCAob2kud2hlbmNlKSB7CgljYXNlIE9JX0xPT1NFOgoJCXN0LT5vcGVuID0gb3Blbl9pc3RyZWFtX2xvb3NlOwoJCXJldHVybiAwOwoJY2FzZSBPSV9QQUNLRUQ6CgkJaWYgKCFvaS51LnBhY2tlZC5pc19kZWx0YSAmJgoJCSAgICByZXBvX3NldHRpbmdzX2dldF9iaWdfZmlsZV90aHJlc2hvbGQodGhlX3JlcG9zaXRvcnkpIDwgc2l6ZSkgewoJCQlzdC0+dS5pbl9wYWNrLnBhY2sgPSBvaS51LnBhY2tlZC5wYWNrOwoJCQlzdC0+dS5pbl9wYWNrLnBvcyA9IG9pLnUucGFja2VkLm9mZnNldDsKCQkJc3QtPm9wZW4gPSBvcGVuX2lzdHJlYW1fcGFja19ub25fZGVsdGE7CgkJCXJldHVybiAwOwoJCX0KCQkvKiBmYWxsdGhydSAqLwoJZGVmYXVsdDoKCQlzdC0+b3BlbiA9IG9wZW5faXN0cmVhbV9pbmNvcmU7CgkJcmV0dXJuIDA7Cgl9Cn0KCi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqCiAqIFVzZXJzIG9mIHN0cmVhbWluZyBpbnRlcmZhY2UKICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovCgppbnQgY2xvc2VfaXN0cmVhbShzdHJ1Y3QgZ2l0X2lzdHJlYW0gKnN0KQp7CglpbnQgciA9IHN0LT5jbG9zZShzdCk7CglmcmVlKHN0KTsKCXJldHVybiByOwp9Cgpzc2l6ZV90IHJlYWRfaXN0cmVhbShzdHJ1Y3QgZ2l0X2lzdHJlYW0gKnN0LCB2b2lkICpidWYsIHNpemVfdCBzeikKewoJcmV0dXJuIHN0LT5yZWFkKHN0LCBidWYsIHN6KTsKfQoKc3RydWN0IGdpdF9pc3RyZWFtICpvcGVuX2lzdHJlYW0oc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCQkgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkJIGVudW0gb2JqZWN0X3R5cGUgKnR5cGUsCgkJCQkgdW5zaWduZWQgbG9uZyAqc2l6ZSwKCQkJCSBzdHJ1Y3Qgc3RyZWFtX2ZpbHRlciAqZmlsdGVyKQp7CglzdHJ1Y3QgZ2l0X2lzdHJlYW0gKnN0ID0geG1hbGxvYyhzaXplb2YoKnN0KSk7Cgljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpyZWFsID0gbG9va3VwX3JlcGxhY2Vfb2JqZWN0KHIsIG9pZCk7CglpbnQgcmV0ID0gaXN0cmVhbV9zb3VyY2Uoc3QsIHIsIHJlYWwsIHR5cGUpOwoKCWlmIChyZXQpIHsKCQlmcmVlKHN0KTsKCQlyZXR1cm4gTlVMTDsKCX0KCglpZiAoc3QtPm9wZW4oc3QsIHIsIHJlYWwsIHR5cGUpKSB7CgkJaWYgKG9wZW5faXN0cmVhbV9pbmNvcmUoc3QsIHIsIHJlYWwsIHR5cGUpKSB7CgkJCWZyZWUoc3QpOwoJCQlyZXR1cm4gTlVMTDsKCQl9Cgl9CglpZiAoZmlsdGVyKSB7CgkJLyogQWRkICImJiAhaXNfbnVsbF9zdHJlYW1fZmlsdGVyKGZpbHRlcikiIGZvciBwZXJmb3JtYW5jZSAqLwoJCXN0cnVjdCBnaXRfaXN0cmVhbSAqbnN0ID0gYXR0YWNoX3N0cmVhbV9maWx0ZXIoc3QsIGZpbHRlcik7CgkJaWYgKCFuc3QpIHsKCQkJY2xvc2VfaXN0cmVhbShzdCk7CgkJCXJldHVybiBOVUxMOwoJCX0KCQlzdCA9IG5zdDsKCX0KCgkqc2l6ZSA9IHN0LT5zaXplOwoJcmV0dXJuIHN0Owp9CgppbnQgc3RyZWFtX2Jsb2JfdG9fZmQoaW50IGZkLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIHN0cnVjdCBzdHJlYW1fZmlsdGVyICpmaWx0ZXIsCgkJICAgICAgaW50IGNhbl9zZWVrKQp7CglzdHJ1Y3QgZ2l0X2lzdHJlYW0gKnN0OwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJdW5zaWduZWQgbG9uZyBzejsKCXNzaXplX3Qga2VwdCA9IDA7CglpbnQgcmVzdWx0ID0gLTE7CgoJc3QgPSBvcGVuX2lzdHJlYW0odGhlX3JlcG9zaXRvcnksIG9pZCwgJnR5cGUsICZzeiwgZmlsdGVyKTsKCWlmICghc3QpIHsKCQlpZiAoZmlsdGVyKQoJCQlmcmVlX3N0cmVhbV9maWx0ZXIoZmlsdGVyKTsKCQlyZXR1cm4gcmVzdWx0OwoJfQoJaWYgKHR5cGUgIT0gT0JKX0JMT0IpCgkJZ290byBjbG9zZV9hbmRfZXhpdDsKCWZvciAoOzspIHsKCQljaGFyIGJ1ZlsxMDI0ICogMTZdOwoJCXNzaXplX3Qgd3JvdGUsIGhvbGV0bzsKCQlzc2l6ZV90IHJlYWRsZW4gPSByZWFkX2lzdHJlYW0oc3QsIGJ1Ziwgc2l6ZW9mKGJ1ZikpOwoKCQlpZiAocmVhZGxlbiA8IDApCgkJCWdvdG8gY2xvc2VfYW5kX2V4aXQ7CgkJaWYgKCFyZWFkbGVuKQoJCQlicmVhazsKCQlpZiAoY2FuX3NlZWsgJiYgc2l6ZW9mKGJ1ZikgPT0gcmVhZGxlbikgewoJCQlmb3IgKGhvbGV0byA9IDA7IGhvbGV0byA8IHJlYWRsZW47IGhvbGV0bysrKQoJCQkJaWYgKGJ1Zltob2xldG9dKQoJCQkJCWJyZWFrOwoJCQlpZiAocmVhZGxlbiA9PSBob2xldG8pIHsKCQkJCWtlcHQgKz0gaG9sZXRvOwoJCQkJY29udGludWU7CgkJCX0KCQl9CgoJCWlmIChrZXB0ICYmIGxzZWVrKGZkLCBrZXB0LCBTRUVLX0NVUikgPT0gKG9mZl90KSAtMSkKCQkJZ290byBjbG9zZV9hbmRfZXhpdDsKCQllbHNlCgkJCWtlcHQgPSAwOwoJCXdyb3RlID0gd3JpdGVfaW5fZnVsbChmZCwgYnVmLCByZWFkbGVuKTsKCgkJaWYgKHdyb3RlIDwgMCkKCQkJZ290byBjbG9zZV9hbmRfZXhpdDsKCX0KCWlmIChrZXB0ICYmIChsc2VlayhmZCwga2VwdCAtIDEsIFNFRUtfQ1VSKSA9PSAob2ZmX3QpIC0xIHx8CgkJICAgICB4d3JpdGUoZmQsICIiLCAxKSAhPSAxKSkKCQlnb3RvIGNsb3NlX2FuZF9leGl0OwoJcmVzdWx0ID0gMDsKCiBjbG9zZV9hbmRfZXhpdDoKCWNsb3NlX2lzdHJlYW0oc3QpOwoJcmV0dXJuIHJlc3VsdDsKfQo=",
    "text": "/*\n * Copyright (c) 2011, Google Inc.\n */\n\n#define USE_THE_REPOSITORY_VARIABLE\n\n#include \"git-compat-util.h\"\n#include \"convert.h\"\n#include \"environment.h\"\n#include \"streaming.h\"\n#include \"repository.h\"\n#include \"object-file.h\"\n#include \"odb.h\"\n#include \"replace-object.h\"\n#include \"packfile.h\"\n\ntypedef int (*open_istream_fn)(struct git_istream *,\n\t\t\t       struct repository *,\n\t\t\t       const struct object_id *,\n\t\t\t       enum object_type *);\ntypedef int (*close_istream_fn)(struct git_istream *);\ntypedef ssize_t (*read_istream_fn)(struct git_istream *, char *, size_t);\n\n#define FILTER_BUFFER (1024*16)\n\nstruct filtered_istream {\n\tstruct git_istream *upstream;\n\tstruct stream_filter *filter;\n\tchar ibuf[FILTER_BUFFER];\n\tchar obuf[FILTER_BUFFER];\n\tint i_end, i_ptr;\n\tint o_end, o_ptr;\n\tint input_finished;\n};\n\nstruct git_istream {\n\topen_istream_fn open;\n\tclose_istream_fn close;\n\tread_istream_fn read;\n\n\tunsigned long size; /* inflated size of full object */\n\tgit_zstream z;\n\tenum { z_unused, z_used, z_done, z_error } z_state;\n\n\tunion {\n\t\tstruct {\n\t\t\tchar *buf; /* from odb_read_object_info_extended() */\n\t\t\tunsigned long read_ptr;\n\t\t} incore;\n\n\t\tstruct {\n\t\t\tvoid *mapped;\n\t\t\tunsigned long mapsize;\n\t\t\tchar hdr[32];\n\t\t\tint hdr_avail;\n\t\t\tint hdr_used;\n\t\t} loose;\n\n\t\tstruct {\n\t\t\tstruct packed_git *pack;\n\t\t\toff_t pos;\n\t\t} in_pack;\n\n\t\tstruct filtered_istream filtered;\n\t} u;\n};\n\n/*****************************************************************\n *\n * Common helpers\n *\n *****************************************************************/\n\nstatic void close_deflated_stream(struct git_istream *st)\n{\n\tif (st->z_state == z_used)\n\t\tgit_inflate_end(&st->z);\n}\n\n\n/*****************************************************************\n *\n * Filtered stream\n *\n *****************************************************************/\n\nstatic int close_istream_filtered(struct git_istream *st)\n{\n\tfree_stream_filter(st->u.filtered.filter);\n\treturn close_istream(st->u.filtered.upstream);\n}\n\nstatic ssize_t read_istream_filtered(struct git_istream *st, char *buf,\n\t\t\t\t     size_t sz)\n{\n\tstruct filtered_istream *fs = &(st->u.filtered);\n\tsize_t filled = 0;\n\n\twhile (sz) {\n\t\t/* do we already have filtered output? */\n\t\tif (fs->o_ptr < fs->o_end) {\n\t\t\tsize_t to_move = fs->o_end - fs->o_ptr;\n\t\t\tif (sz < to_move)\n\t\t\t\tto_move = sz;\n\t\t\tmemcpy(buf + filled, fs->obuf + fs->o_ptr, to_move);\n\t\t\tfs->o_ptr += to_move;\n\t\t\tsz -= to_move;\n\t\t\tfilled += to_move;\n\t\t\tcontinue;\n\t\t}\n\t\tfs->o_end = fs->o_ptr = 0;\n\n\t\t/* do we have anything to feed the filter with? */\n\t\tif (fs->i_ptr < fs->i_end) {\n\t\t\tsize_t to_feed = fs->i_end - fs->i_ptr;\n\t\t\tsize_t to_receive = FILTER_BUFFER;\n\t\t\tif (stream_filter(fs->filter,\n\t\t\t\t\t  fs->ibuf + fs->i_ptr, &to_feed,\n\t\t\t\t\t  fs->obuf, &to_receive))\n\t\t\t\treturn -1;\n\t\t\tfs->i_ptr = fs->i_end - to_feed;\n\t\t\tfs->o_end = FILTER_BUFFER - to_receive;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* tell the filter to drain upon no more input */\n\t\tif (fs->input_finished) {\n\t\t\tsize_t to_receive = FILTER_BUFFER;\n\t\t\tif (stream_filter(fs->filter,\n\t\t\t\t\t  NULL, NULL,\n\t\t\t\t\t  fs->obuf, &to_receive))\n\t\t\t\treturn -1;\n\t\t\tfs->o_end = FILTER_BUFFER - to_receive;\n\t\t\tif (!fs->o_end)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tfs->i_end = fs->i_ptr = 0;\n\n\t\t/* refill the input from the upstream */\n\t\tif (!fs->input_finished) {\n\t\t\tfs->i_end = read_istream(fs->upstream, fs->ibuf, FILTER_BUFFER);\n\t\t\tif (fs->i_end < 0)\n\t\t\t\treturn -1;\n\t\t\tif (fs->i_end)\n\t\t\t\tcontinue;\n\t\t}\n\t\tfs->input_finished = 1;\n\t}\n\treturn filled;\n}\n\nstatic struct git_istream *attach_stream_filter(struct git_istream *st,\n\t\t\t\t\t\tstruct stream_filter *filter)\n{\n\tstruct git_istream *ifs = xmalloc(sizeof(*ifs));\n\tstruct filtered_istream *fs = &(ifs->u.filtered);\n\n\tifs->close = close_istream_filtered;\n\tifs->read = read_istream_filtered;\n\tfs->upstream = st;\n\tfs->filter = filter;\n\tfs->i_end = fs->i_ptr = 0;\n\tfs->o_end = fs->o_ptr = 0;\n\tfs->input_finished = 0;\n\tifs->size = -1; /* unknown */\n\treturn ifs;\n}\n\n/*****************************************************************\n *\n * Loose object stream\n *\n *****************************************************************/\n\nstatic ssize_t read_istream_loose(struct git_istream *st, char *buf, size_t sz)\n{\n\tsize_t total_read = 0;\n\n\tswitch (st->z_state) {\n\tcase z_done:\n\t\treturn 0;\n\tcase z_error:\n\t\treturn -1;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (st->u.loose.hdr_used < st->u.loose.hdr_avail) {\n\t\tsize_t to_copy = st->u.loose.hdr_avail - st->u.loose.hdr_used;\n\t\tif (sz < to_copy)\n\t\t\tto_copy = sz;\n\t\tmemcpy(buf, st->u.loose.hdr + st->u.loose.hdr_used, to_copy);\n\t\tst->u.loose.hdr_used += to_copy;\n\t\ttotal_read += to_copy;\n\t}\n\n\twhile (total_read < sz) {\n\t\tint status;\n\n\t\tst->z.next_out = (unsigned char *)buf + total_read;\n\t\tst->z.avail_out = sz - total_read;\n\t\tstatus = git_inflate(&st->z, Z_FINISH);\n\n\t\ttotal_read = st->z.next_out - (unsigned char *)buf;\n\n\t\tif (status == Z_STREAM_END) {\n\t\t\tgit_inflate_end(&st->z);\n\t\t\tst->z_state = z_done;\n\t\t\tbreak;\n\t\t}\n\t\tif (status != Z_OK && (status != Z_BUF_ERROR || total_read < sz)) {\n\t\t\tgit_inflate_end(&st->z);\n\t\t\tst->z_state = z_error;\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn total_read;\n}\n\nstatic int close_istream_loose(struct git_istream *st)\n{\n\tclose_deflated_stream(st);\n\tmunmap(st->u.loose.mapped, st->u.loose.mapsize);\n\treturn 0;\n}\n\nstatic int open_istream_loose(struct git_istream *st, struct repository *r,\n\t\t\t      const struct object_id *oid,\n\t\t\t      enum object_type *type)\n{\n\tstruct object_info oi = OBJECT_INFO_INIT;\n\tstruct odb_source *source;\n\n\toi.sizep = &st->size;\n\toi.typep = type;\n\n\todb_prepare_alternates(r->objects);\n\tfor (source = r->objects->sources; source; source = source->next) {\n\t\tst->u.loose.mapped = odb_source_loose_map_object(source, oid,\n\t\t\t\t\t\t\t\t &st->u.loose.mapsize);\n\t\tif (st->u.loose.mapped)\n\t\t\tbreak;\n\t}\n\tif (!st->u.loose.mapped)\n\t\treturn -1;\n\n\tswitch (unpack_loose_header(&st->z, st->u.loose.mapped,\n\t\t\t\t    st->u.loose.mapsize, st->u.loose.hdr,\n\t\t\t\t    sizeof(st->u.loose.hdr))) {\n\tcase ULHR_OK:\n\t\tbreak;\n\tcase ULHR_BAD:\n\tcase ULHR_TOO_LONG:\n\t\tgoto error;\n\t}\n\tif (parse_loose_header(st->u.loose.hdr, &oi) < 0 || *type < 0)\n\t\tgoto error;\n\n\tst->u.loose.hdr_used = strlen(st->u.loose.hdr) + 1;\n\tst->u.loose.hdr_avail = st->z.total_out;\n\tst->z_state = z_used;\n\tst->close = close_istream_loose;\n\tst->read = read_istream_loose;\n\n\treturn 0;\nerror:\n\tgit_inflate_end(&st->z);\n\tmunmap(st->u.loose.mapped, st->u.loose.mapsize);\n\treturn -1;\n}\n\n\n/*****************************************************************\n *\n * Non-delta packed object stream\n *\n *****************************************************************/\n\nstatic ssize_t read_istream_pack_non_delta(struct git_istream *st, char *buf,\n\t\t\t\t\t   size_t sz)\n{\n\tsize_t total_read = 0;\n\n\tswitch (st->z_state) {\n\tcase z_unused:\n\t\tmemset(&st->z, 0, sizeof(st->z));\n\t\tgit_inflate_init(&st->z);\n\t\tst->z_state = z_used;\n\t\tbreak;\n\tcase z_done:\n\t\treturn 0;\n\tcase z_error:\n\t\treturn -1;\n\tcase z_used:\n\t\tbreak;\n\t}\n\n\twhile (total_read < sz) {\n\t\tint status;\n\t\tstruct pack_window *window = NULL;\n\t\tunsigned char *mapped;\n\n\t\tmapped = use_pack(st->u.in_pack.pack, &window,\n\t\t\t\t  st->u.in_pack.pos, &st->z.avail_in);\n\n\t\tst->z.next_out = (unsigned char *)buf + total_read;\n\t\tst->z.avail_out = sz - total_read;\n\t\tst->z.next_in = mapped;\n\t\tstatus = git_inflate(&st->z, Z_FINISH);\n\n\t\tst->u.in_pack.pos += st->z.next_in - mapped;\n\t\ttotal_read = st->z.next_out - (unsigned char *)buf;\n\t\tunuse_pack(&window);\n\n\t\tif (status == Z_STREAM_END) {\n\t\t\tgit_inflate_end(&st->z);\n\t\t\tst->z_state = z_done;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Unlike the loose object case, we do not have to worry here\n\t\t * about running out of input bytes and spinning infinitely. If\n\t\t * we get Z_BUF_ERROR due to too few input bytes, then we'll\n\t\t * replenish them in the next use_pack() call when we loop. If\n\t\t * we truly hit the end of the pack (i.e., because it's corrupt\n\t\t * or truncated), then use_pack() catches that and will die().\n\t\t */\n\t\tif (status != Z_OK && status != Z_BUF_ERROR) {\n\t\t\tgit_inflate_end(&st->z);\n\t\t\tst->z_state = z_error;\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn total_read;\n}\n\nstatic int close_istream_pack_non_delta(struct git_istream *st)\n{\n\tclose_deflated_stream(st);\n\treturn 0;\n}\n\nstatic int open_istream_pack_non_delta(struct git_istream *st,\n\t\t\t\t       struct repository *r UNUSED,\n\t\t\t\t       const struct object_id *oid UNUSED,\n\t\t\t\t       enum object_type *type UNUSED)\n{\n\tstruct pack_window *window;\n\tenum object_type in_pack_type;\n\n\twindow = NULL;\n\n\tin_pack_type = unpack_object_header(st->u.in_pack.pack,\n\t\t\t\t\t    &window,\n\t\t\t\t\t    &st->u.in_pack.pos,\n\t\t\t\t\t    &st->size);\n\tunuse_pack(&window);\n\tswitch (in_pack_type) {\n\tdefault:\n\t\treturn -1; /* we do not do deltas for now */\n\tcase OBJ_COMMIT:\n\tcase OBJ_TREE:\n\tcase OBJ_BLOB:\n\tcase OBJ_TAG:\n\t\tbreak;\n\t}\n\tst->z_state = z_unused;\n\tst->close = close_istream_pack_non_delta;\n\tst->read = read_istream_pack_non_delta;\n\n\treturn 0;\n}\n\n\n/*****************************************************************\n *\n * In-core stream\n *\n *****************************************************************/\n\nstatic int close_istream_incore(struct git_istream *st)\n{\n\tfree(st->u.incore.buf);\n\treturn 0;\n}\n\nstatic ssize_t read_istream_incore(struct git_istream *st, char *buf, size_t sz)\n{\n\tsize_t read_size = sz;\n\tsize_t remainder = st->size - st->u.incore.read_ptr;\n\n\tif (remainder <= read_size)\n\t\tread_size = remainder;\n\tif (read_size) {\n\t\tmemcpy(buf, st->u.incore.buf + st->u.incore.read_ptr, read_size);\n\t\tst->u.incore.read_ptr += read_size;\n\t}\n\treturn read_size;\n}\n\nstatic int open_istream_incore(struct git_istream *st, struct repository *r,\n\t\t\t       const struct object_id *oid, enum object_type *type)\n{\n\tstruct object_info oi = OBJECT_INFO_INIT;\n\n\tst->u.incore.read_ptr = 0;\n\tst->close = close_istream_incore;\n\tst->read = read_istream_incore;\n\n\toi.typep = type;\n\toi.sizep = &st->size;\n\toi.contentp = (void **)&st->u.incore.buf;\n\treturn odb_read_object_info_extended(r->objects, oid, &oi,\n\t\t\t\t\t     OBJECT_INFO_DIE_IF_CORRUPT);\n}\n\n/*****************************************************************************\n * static helpers variables and functions for users of streaming interface\n *****************************************************************************/\n\nstatic int istream_source(struct git_istream *st,\n\t\t\t  struct repository *r,\n\t\t\t  const struct object_id *oid,\n\t\t\t  enum object_type *type)\n{\n\tunsigned long size;\n\tint status;\n\tstruct object_info oi = OBJECT_INFO_INIT;\n\n\toi.typep = type;\n\toi.sizep = &size;\n\tstatus = odb_read_object_info_extended(r->objects, oid, &oi, 0);\n\tif (status < 0)\n\t\treturn status;\n\n\tswitch (oi.whence) {\n\tcase OI_LOOSE:\n\t\tst->open = open_istream_loose;\n\t\treturn 0;\n\tcase OI_PACKED:\n\t\tif (!oi.u.packed.is_delta &&\n\t\t    repo_settings_get_big_file_threshold(the_repository) < size) {\n\t\t\tst->u.in_pack.pack = oi.u.packed.pack;\n\t\t\tst->u.in_pack.pos = oi.u.packed.offset;\n\t\t\tst->open = open_istream_pack_non_delta;\n\t\t\treturn 0;\n\t\t}\n\t\t/* fallthru */\n\tdefault:\n\t\tst->open = open_istream_incore;\n\t\treturn 0;\n\t}\n}\n\n/****************************************************************\n * Users of streaming interface\n ****************************************************************/\n\nint close_istream(struct git_istream *st)\n{\n\tint r = st->close(st);\n\tfree(st);\n\treturn r;\n}\n\nssize_t read_istream(struct git_istream *st, void *buf, size_t sz)\n{\n\treturn st->read(st, buf, sz);\n}\n\nstruct git_istream *open_istream(struct repository *r,\n\t\t\t\t const struct object_id *oid,\n\t\t\t\t enum object_type *type,\n\t\t\t\t unsigned long *size,\n\t\t\t\t struct stream_filter *filter)\n{\n\tstruct git_istream *st = xmalloc(sizeof(*st));\n\tconst struct object_id *real = lookup_replace_object(r, oid);\n\tint ret = istream_source(st, r, real, type);\n\n\tif (ret) {\n\t\tfree(st);\n\t\treturn NULL;\n\t}\n\n\tif (st->open(st, r, real, type)) {\n\t\tif (open_istream_incore(st, r, real, type)) {\n\t\t\tfree(st);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (filter) {\n\t\t/* Add \"&& !is_null_stream_filter(filter)\" for performance */\n\t\tstruct git_istream *nst = attach_stream_filter(st, filter);\n\t\tif (!nst) {\n\t\t\tclose_istream(st);\n\t\t\treturn NULL;\n\t\t}\n\t\tst = nst;\n\t}\n\n\t*size = st->size;\n\treturn st;\n}\n\nint stream_blob_to_fd(int fd, const struct object_id *oid, struct stream_filter *filter,\n\t\t      int can_seek)\n{\n\tstruct git_istream *st;\n\tenum object_type type;\n\tunsigned long sz;\n\tssize_t kept = 0;\n\tint result = -1;\n\n\tst = open_istream(the_repository, oid, &type, &sz, filter);\n\tif (!st) {\n\t\tif (filter)\n\t\t\tfree_stream_filter(filter);\n\t\treturn result;\n\t}\n\tif (type != OBJ_BLOB)\n\t\tgoto close_and_exit;\n\tfor (;;) {\n\t\tchar buf[1024 * 16];\n\t\tssize_t wrote, holeto;\n\t\tssize_t readlen = read_istream(st, buf, sizeof(buf));\n\n\t\tif (readlen < 0)\n\t\t\tgoto close_and_exit;\n\t\tif (!readlen)\n\t\t\tbreak;\n\t\tif (can_seek && sizeof(buf) == readlen) {\n\t\t\tfor (holeto = 0; holeto < readlen; holeto++)\n\t\t\t\tif (buf[holeto])\n\t\t\t\t\tbreak;\n\t\t\tif (readlen == holeto) {\n\t\t\t\tkept += holeto;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (kept && lseek(fd, kept, SEEK_CUR) == (off_t) -1)\n\t\t\tgoto close_and_exit;\n\t\telse\n\t\t\tkept = 0;\n\t\twrote = write_in_full(fd, buf, readlen);\n\n\t\tif (wrote < 0)\n\t\t\tgoto close_and_exit;\n\t}\n\tif (kept && (lseek(fd, kept - 1, SEEK_CUR) == (off_t) -1 ||\n\t\t     xwrite(fd, \"\", 1) != 1))\n\t\tgoto close_and_exit;\n\tresult = 0;\n\n close_and_exit:\n\tclose_istream(st);\n\treturn result;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00ad649ae397f3c5d0f1200ec3860188133c5223",
  "sha1_ok": true,
  "size": 13187
}
