{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJjYWNoZS10cmVlLmgiCiNpbmNsdWRlICJtZXJnZXNvcnQuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgImRpZmZjb3JlLmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgImJsYW1lLmgiCgp2b2lkIGJsYW1lX29yaWdpbl9kZWNyZWYoc3RydWN0IGJsYW1lX29yaWdpbiAqbykKewoJaWYgKG8gJiYgLS1vLT5yZWZjbnQgPD0gMCkgewoJCXN0cnVjdCBibGFtZV9vcmlnaW4gKnAsICpsID0gTlVMTDsKCQlpZiAoby0+cHJldmlvdXMpCgkJCWJsYW1lX29yaWdpbl9kZWNyZWYoby0+cHJldmlvdXMpOwoJCWZyZWUoby0+ZmlsZS5wdHIpOwoJCS8qIFNob3VsZCBiZSBwcmVzZW50IGV4YWN0bHkgb25jZSBpbiBjb21taXQgY2hhaW4gKi8KCQlmb3IgKHAgPSBvLT5jb21taXQtPnV0aWw7IHA7IGwgPSBwLCBwID0gcC0+bmV4dCkgewoJCQlpZiAocCA9PSBvKSB7CgkJCQlpZiAobCkKCQkJCQlsLT5uZXh0ID0gcC0+bmV4dDsKCQkJCWVsc2UKCQkJCQlvLT5jb21taXQtPnV0aWwgPSBwLT5uZXh0OwoJCQkJZnJlZShvKTsKCQkJCXJldHVybjsKCQkJfQoJCX0KCQlkaWUoImludGVybmFsIGVycm9yIGluIGJsYW1lX29yaWdpbl9kZWNyZWYiKTsKCX0KfQoKLyoKICogR2l2ZW4gYSBjb21taXQgYW5kIGEgcGF0aCBpbiBpdCwgY3JlYXRlIGEgbmV3IG9yaWdpbiBzdHJ1Y3R1cmUuCiAqIFRoZSBjYWxsZXJzIHRoYXQgYWRkIGJsYW1lIHRvIHRoZSBzY29yZWJvYXJkIHNob3VsZCB1c2UKICogZ2V0X29yaWdpbigpIHRvIG9idGFpbiBzaGFyZWQsIHJlZmNvdW50ZWQgY29weSBpbnN0ZWFkIG9mIGNhbGxpbmcKICogdGhpcyBmdW5jdGlvbiBkaXJlY3RseS4KICovCnN0YXRpYyBzdHJ1Y3QgYmxhbWVfb3JpZ2luICptYWtlX29yaWdpbihzdHJ1Y3QgY29tbWl0ICpjb21taXQsIGNvbnN0IGNoYXIgKnBhdGgpCnsKCXN0cnVjdCBibGFtZV9vcmlnaW4gKm87CglGTEVYX0FMTE9DX1NUUihvLCBwYXRoLCBwYXRoKTsKCW8tPmNvbW1pdCA9IGNvbW1pdDsKCW8tPnJlZmNudCA9IDE7CglvLT5uZXh0ID0gY29tbWl0LT51dGlsOwoJY29tbWl0LT51dGlsID0gbzsKCXJldHVybiBvOwp9CgovKgogKiBMb2NhdGUgYW4gZXhpc3Rpbmcgb3JpZ2luIG9yIGNyZWF0ZSBhIG5ldyBvbmUuCiAqIFRoaXMgbW92ZXMgdGhlIG9yaWdpbiB0byBmcm9udCBwb3NpdGlvbiBpbiB0aGUgY29tbWl0IHV0aWwgbGlzdC4KICovCnN0YXRpYyBzdHJ1Y3QgYmxhbWVfb3JpZ2luICpnZXRfb3JpZ2luKHN0cnVjdCBjb21taXQgKmNvbW1pdCwgY29uc3QgY2hhciAqcGF0aCkKewoJc3RydWN0IGJsYW1lX29yaWdpbiAqbywgKmw7CgoJZm9yIChvID0gY29tbWl0LT51dGlsLCBsID0gTlVMTDsgbzsgbCA9IG8sIG8gPSBvLT5uZXh0KSB7CgkJaWYgKCFzdHJjbXAoby0+cGF0aCwgcGF0aCkpIHsKCQkJLyogYnVtcCB0byBmcm9udCAqLwoJCQlpZiAobCkgewoJCQkJbC0+bmV4dCA9IG8tPm5leHQ7CgkJCQlvLT5uZXh0ID0gY29tbWl0LT51dGlsOwoJCQkJY29tbWl0LT51dGlsID0gbzsKCQkJfQoJCQlyZXR1cm4gYmxhbWVfb3JpZ2luX2luY3JlZihvKTsKCQl9Cgl9CglyZXR1cm4gbWFrZV9vcmlnaW4oY29tbWl0LCBwYXRoKTsKfQoKCgpzdGF0aWMgdm9pZCB2ZXJpZnlfd29ya2luZ190cmVlX3BhdGgoc3RydWN0IGNvbW1pdCAqd29ya190cmVlLCBjb25zdCBjaGFyICpwYXRoKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHM7CglpbnQgcG9zOwoKCWZvciAocGFyZW50cyA9IHdvcmtfdHJlZS0+cGFyZW50czsgcGFyZW50czsgcGFyZW50cyA9IHBhcmVudHMtPm5leHQpIHsKCQljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpjb21taXRfb2lkID0gJnBhcmVudHMtPml0ZW0tPm9iamVjdC5vaWQ7CgkJc3RydWN0IG9iamVjdF9pZCBibG9iX29pZDsKCQl1bnNpZ25lZCBtb2RlOwoKCQlpZiAoIWdldF90cmVlX2VudHJ5KGNvbW1pdF9vaWQtPmhhc2gsIHBhdGgsIGJsb2Jfb2lkLmhhc2gsICZtb2RlKSAmJgoJCSAgICBvaWRfb2JqZWN0X2luZm8oJmJsb2Jfb2lkLCBOVUxMKSA9PSBPQkpfQkxPQikKCQkJcmV0dXJuOwoJfQoKCXBvcyA9IGNhY2hlX25hbWVfcG9zKHBhdGgsIHN0cmxlbihwYXRoKSk7CglpZiAocG9zID49IDApCgkJOyAvKiBwYXRoIGlzIGluIHRoZSBpbmRleCAqLwoJZWxzZSBpZiAoLTEgLSBwb3MgPCBhY3RpdmVfbnIgJiYKCQkgIXN0cmNtcChhY3RpdmVfY2FjaGVbLTEgLSBwb3NdLT5uYW1lLCBwYXRoKSkKCQk7IC8qIHBhdGggaXMgaW4gdGhlIGluZGV4LCB1bm1lcmdlZCAqLwoJZWxzZQoJCWRpZSgibm8gc3VjaCBwYXRoICclcycgaW4gSEVBRCIsIHBhdGgpOwp9CgpzdGF0aWMgc3RydWN0IGNvbW1pdF9saXN0ICoqYXBwZW5kX3BhcmVudChzdHJ1Y3QgY29tbWl0X2xpc3QgKip0YWlsLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXN0cnVjdCBjb21taXQgKnBhcmVudDsKCglwYXJlbnQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZShvaWQpOwoJaWYgKCFwYXJlbnQpCgkJZGllKCJubyBzdWNoIGNvbW1pdCAlcyIsIG9pZF90b19oZXgob2lkKSk7CglyZXR1cm4gJmNvbW1pdF9saXN0X2luc2VydChwYXJlbnQsIHRhaWwpLT5uZXh0Owp9CgpzdGF0aWMgdm9pZCBhcHBlbmRfbWVyZ2VfcGFyZW50cyhzdHJ1Y3QgY29tbWl0X2xpc3QgKip0YWlsKQp7CglpbnQgbWVyZ2VfaGVhZDsKCXN0cnVjdCBzdHJidWYgbGluZSA9IFNUUkJVRl9JTklUOwoKCW1lcmdlX2hlYWQgPSBvcGVuKGdpdF9wYXRoX21lcmdlX2hlYWQoKSwgT19SRE9OTFkpOwoJaWYgKG1lcmdlX2hlYWQgPCAwKSB7CgkJaWYgKGVycm5vID09IEVOT0VOVCkKCQkJcmV0dXJuOwoJCWRpZSgiY2Fubm90IG9wZW4gJyVzJyBmb3IgcmVhZGluZyIsIGdpdF9wYXRoX21lcmdlX2hlYWQoKSk7Cgl9CgoJd2hpbGUgKCFzdHJidWZfZ2V0d2hvbGVsaW5lX2ZkKCZsaW5lLCBtZXJnZV9oZWFkLCAnXG4nKSkgewoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCWlmIChsaW5lLmxlbiA8IEdJVF9TSEExX0hFWFNaIHx8IGdldF9vaWRfaGV4KGxpbmUuYnVmLCAmb2lkKSkKCQkJZGllKCJ1bmtub3duIGxpbmUgaW4gJyVzJzogJXMiLCBnaXRfcGF0aF9tZXJnZV9oZWFkKCksIGxpbmUuYnVmKTsKCQl0YWlsID0gYXBwZW5kX3BhcmVudCh0YWlsLCAmb2lkKTsKCX0KCWNsb3NlKG1lcmdlX2hlYWQpOwoJc3RyYnVmX3JlbGVhc2UoJmxpbmUpOwp9CgovKgogKiBUaGlzIGlzbid0IGFzIHNpbXBsZSBhcyBwYXNzaW5nIHNiLT5idWYgYW5kIHNiLT5sZW4sIGJlY2F1c2Ugd2UKICogd2FudCB0byB0cmFuc2ZlciBvd25lcnNoaXAgb2YgdGhlIGJ1ZmZlciB0byB0aGUgY29tbWl0IChzbyB3ZQogKiBtdXN0IHVzZSBkZXRhY2gpLgogKi8Kc3RhdGljIHZvaWQgc2V0X2NvbW1pdF9idWZmZXJfZnJvbV9zdHJidWYoc3RydWN0IGNvbW1pdCAqYywgc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCXNpemVfdCBsZW47Cgl2b2lkICpidWYgPSBzdHJidWZfZGV0YWNoKHNiLCAmbGVuKTsKCXNldF9jb21taXRfYnVmZmVyKGMsIGJ1ZiwgbGVuKTsKfQoKLyoKICogUHJlcGFyZSBhIGR1bW15IGNvbW1pdCB0aGF0IHJlcHJlc2VudHMgdGhlIHdvcmsgdHJlZSAob3Igc3RhZ2VkKSBpdGVtLgogKiBOb3RlIHRoYXQgYW5ub3RhdGluZyB3b3JrIHRyZWUgaXRlbSBuZXZlciB3b3JrcyBpbiB0aGUgcmV2ZXJzZS4KICovCnN0YXRpYyBzdHJ1Y3QgY29tbWl0ICpmYWtlX3dvcmtpbmdfdHJlZV9jb21taXQoc3RydWN0IGRpZmZfb3B0aW9ucyAqb3B0LAoJCQkJCSAgICAgICBjb25zdCBjaGFyICpwYXRoLAoJCQkJCSAgICAgICBjb25zdCBjaGFyICpjb250ZW50c19mcm9tKQp7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CglzdHJ1Y3QgYmxhbWVfb3JpZ2luICpvcmlnaW47CglzdHJ1Y3QgY29tbWl0X2xpc3QgKipwYXJlbnRfdGFpbCwgKnBhcmVudDsKCXN0cnVjdCBvYmplY3RfaWQgaGVhZF9vaWQ7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJY29uc3QgY2hhciAqaWRlbnQ7Cgl0aW1lX3Qgbm93OwoJaW50IHNpemUsIGxlbjsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2U7Cgl1bnNpZ25lZCBtb2RlOwoJc3RydWN0IHN0cmJ1ZiBtc2cgPSBTVFJCVUZfSU5JVDsKCglyZWFkX2NhY2hlKCk7Cgl0aW1lKCZub3cpOwoJY29tbWl0ID0gYWxsb2NfY29tbWl0X25vZGUoKTsKCWNvbW1pdC0+b2JqZWN0LnBhcnNlZCA9IDE7Cgljb21taXQtPmRhdGUgPSBub3c7CglwYXJlbnRfdGFpbCA9ICZjb21taXQtPnBhcmVudHM7CgoJaWYgKCFyZXNvbHZlX3JlZl91bnNhZmUoIkhFQUQiLCBSRVNPTFZFX1JFRl9SRUFESU5HLCAmaGVhZF9vaWQsIE5VTEwpKQoJCWRpZSgibm8gc3VjaCByZWY6IEhFQUQiKTsKCglwYXJlbnRfdGFpbCA9IGFwcGVuZF9wYXJlbnQocGFyZW50X3RhaWwsICZoZWFkX29pZCk7CglhcHBlbmRfbWVyZ2VfcGFyZW50cyhwYXJlbnRfdGFpbCk7Cgl2ZXJpZnlfd29ya2luZ190cmVlX3BhdGgoY29tbWl0LCBwYXRoKTsKCglvcmlnaW4gPSBtYWtlX29yaWdpbihjb21taXQsIHBhdGgpOwoKCWlkZW50ID0gZm10X2lkZW50KCJOb3QgQ29tbWl0dGVkIFlldCIsICJub3QuY29tbWl0dGVkLnlldCIsIE5VTEwsIDApOwoJc3RyYnVmX2FkZHN0cigmbXNnLCAidHJlZSAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXG4iKTsKCWZvciAocGFyZW50ID0gY29tbWl0LT5wYXJlbnRzOyBwYXJlbnQ7IHBhcmVudCA9IHBhcmVudC0+bmV4dCkKCQlzdHJidWZfYWRkZigmbXNnLCAicGFyZW50ICVzXG4iLAoJCQkgICAgb2lkX3RvX2hleCgmcGFyZW50LT5pdGVtLT5vYmplY3Qub2lkKSk7CglzdHJidWZfYWRkZigmbXNnLAoJCSAgICAiYXV0aG9yICVzXG4iCgkJICAgICJjb21taXR0ZXIgJXNcblxuIgoJCSAgICAiVmVyc2lvbiBvZiAlcyBmcm9tICVzXG4iLAoJCSAgICBpZGVudCwgaWRlbnQsIHBhdGgsCgkJICAgICghY29udGVudHNfZnJvbSA/IHBhdGggOgoJCSAgICAgKCFzdHJjbXAoY29udGVudHNfZnJvbSwgIi0iKSA/ICJzdGFuZGFyZCBpbnB1dCIgOiBjb250ZW50c19mcm9tKSkpOwoJc2V0X2NvbW1pdF9idWZmZXJfZnJvbV9zdHJidWYoY29tbWl0LCAmbXNnKTsKCglpZiAoIWNvbnRlbnRzX2Zyb20gfHwgc3RyY21wKCItIiwgY29udGVudHNfZnJvbSkpIHsKCQlzdHJ1Y3Qgc3RhdCBzdDsKCQljb25zdCBjaGFyICpyZWFkX2Zyb207CgkJY2hhciAqYnVmX3B0cjsKCQl1bnNpZ25lZCBsb25nIGJ1Zl9sZW47CgoJCWlmIChjb250ZW50c19mcm9tKSB7CgkJCWlmIChzdGF0KGNvbnRlbnRzX2Zyb20sICZzdCkgPCAwKQoJCQkJZGllX2Vycm5vKCJDYW5ub3Qgc3RhdCAnJXMnIiwgY29udGVudHNfZnJvbSk7CgkJCXJlYWRfZnJvbSA9IGNvbnRlbnRzX2Zyb207CgkJfQoJCWVsc2UgewoJCQlpZiAobHN0YXQocGF0aCwgJnN0KSA8IDApCgkJCQlkaWVfZXJybm8oIkNhbm5vdCBsc3RhdCAnJXMnIiwgcGF0aCk7CgkJCXJlYWRfZnJvbSA9IHBhdGg7CgkJfQoJCW1vZGUgPSBjYW5vbl9tb2RlKHN0LnN0X21vZGUpOwoKCQlzd2l0Y2ggKHN0LnN0X21vZGUgJiBTX0lGTVQpIHsKCQljYXNlIFNfSUZSRUc6CgkJCWlmIChvcHQtPmZsYWdzLmFsbG93X3RleHRjb252ICYmCgkJCSAgICB0ZXh0Y29udl9vYmplY3QocmVhZF9mcm9tLCBtb2RlLCAmbnVsbF9vaWQsIDAsICZidWZfcHRyLCAmYnVmX2xlbikpCgkJCQlzdHJidWZfYXR0YWNoKCZidWYsIGJ1Zl9wdHIsIGJ1Zl9sZW4sIGJ1Zl9sZW4gKyAxKTsKCQkJZWxzZSBpZiAoc3RyYnVmX3JlYWRfZmlsZSgmYnVmLCByZWFkX2Zyb20sIHN0LnN0X3NpemUpICE9IHN0LnN0X3NpemUpCgkJCQlkaWVfZXJybm8oImNhbm5vdCBvcGVuIG9yIHJlYWQgJyVzJyIsIHJlYWRfZnJvbSk7CgkJCWJyZWFrOwoJCWNhc2UgU19JRkxOSzoKCQkJaWYgKHN0cmJ1Zl9yZWFkbGluaygmYnVmLCByZWFkX2Zyb20sIHN0LnN0X3NpemUpIDwgMCkKCQkJCWRpZV9lcnJubygiY2Fubm90IHJlYWRsaW5rICclcyciLCByZWFkX2Zyb20pOwoJCQlicmVhazsKCQlkZWZhdWx0OgoJCQlkaWUoInVuc3VwcG9ydGVkIGZpbGUgdHlwZSAlcyIsIHJlYWRfZnJvbSk7CgkJfQoJfQoJZWxzZSB7CgkJLyogUmVhZGluZyBmcm9tIHN0ZGluICovCgkJbW9kZSA9IDA7CgkJaWYgKHN0cmJ1Zl9yZWFkKCZidWYsIDAsIDApIDwgMCkKCQkJZGllX2Vycm5vKCJmYWlsZWQgdG8gcmVhZCBmcm9tIHN0ZGluIik7Cgl9Cgljb252ZXJ0X3RvX2dpdCgmdGhlX2luZGV4LCBwYXRoLCBidWYuYnVmLCBidWYubGVuLCAmYnVmLCAwKTsKCW9yaWdpbi0+ZmlsZS5wdHIgPSBidWYuYnVmOwoJb3JpZ2luLT5maWxlLnNpemUgPSBidWYubGVuOwoJcHJldGVuZF9vYmplY3RfZmlsZShidWYuYnVmLCBidWYubGVuLCBPQkpfQkxPQiwgJm9yaWdpbi0+YmxvYl9vaWQpOwoKCS8qCgkgKiBSZWFkIHRoZSBjdXJyZW50IGluZGV4LCByZXBsYWNlIHRoZSBwYXRoIGVudHJ5IHdpdGgKCSAqIG9yaWdpbi0+YmxvYl9zaGExIHdpdGhvdXQgbXVja2luZyB3aXRoIGl0cyBtb2RlIG9yIHR5cGUKCSAqIGJpdHM7IHdlIGFyZSBub3QgZ29pbmcgdG8gd3JpdGUgdGhpcyBpbmRleCBvdXQgLS0gd2UganVzdAoJICogd2FudCB0byBydW4gImRpZmYtaW5kZXggLS1jYWNoZWQiLgoJICovCglkaXNjYXJkX2NhY2hlKCk7CglyZWFkX2NhY2hlKCk7CgoJbGVuID0gc3RybGVuKHBhdGgpOwoJaWYgKCFtb2RlKSB7CgkJaW50IHBvcyA9IGNhY2hlX25hbWVfcG9zKHBhdGgsIGxlbik7CgkJaWYgKDAgPD0gcG9zKQoJCQltb2RlID0gYWN0aXZlX2NhY2hlW3Bvc10tPmNlX21vZGU7CgkJZWxzZQoJCQkvKiBMZXQncyBub3QgYm90aGVyIHJlYWRpbmcgZnJvbSBIRUFEIHRyZWUgKi8KCQkJbW9kZSA9IFNfSUZSRUcgfCAwNjQ0OwoJfQoJc2l6ZSA9IGNhY2hlX2VudHJ5X3NpemUobGVuKTsKCWNlID0geGNhbGxvYygxLCBzaXplKTsKCW9pZGNweSgmY2UtPm9pZCwgJm9yaWdpbi0+YmxvYl9vaWQpOwoJbWVtY3B5KGNlLT5uYW1lLCBwYXRoLCBsZW4pOwoJY2UtPmNlX2ZsYWdzID0gY3JlYXRlX2NlX2ZsYWdzKDApOwoJY2UtPmNlX25hbWVsZW4gPSBsZW47CgljZS0+Y2VfbW9kZSA9IGNyZWF0ZV9jZV9tb2RlKG1vZGUpOwoJYWRkX2NhY2hlX2VudHJ5KGNlLCBBRERfQ0FDSEVfT0tfVE9fQUREfEFERF9DQUNIRV9PS19UT19SRVBMQUNFKTsKCgljYWNoZV90cmVlX2ludmFsaWRhdGVfcGF0aCgmdGhlX2luZGV4LCBwYXRoKTsKCglyZXR1cm4gY29tbWl0Owp9CgoKCnN0YXRpYyBpbnQgZGlmZl9odW5rcyhtbWZpbGVfdCAqZmlsZV9hLCBtbWZpbGVfdCAqZmlsZV9iLAoJCSAgICAgIHhkbF9lbWl0X2h1bmtfY29uc3VtZV9mdW5jX3QgaHVua19mdW5jLCB2b2lkICpjYl9kYXRhLCBpbnQgeGRsX29wdHMpCnsKCXhwcGFyYW1fdCB4cHAgPSB7MH07Cgl4ZGVtaXRjb25mX3QgeGVjZmcgPSB7MH07Cgl4ZGVtaXRjYl90IGVjYiA9IHtOVUxMfTsKCgl4cHAuZmxhZ3MgPSB4ZGxfb3B0czsKCXhlY2ZnLmh1bmtfZnVuYyA9IGh1bmtfZnVuYzsKCWVjYi5wcml2ID0gY2JfZGF0YTsKCXJldHVybiB4ZGlfZGlmZihmaWxlX2EsIGZpbGVfYiwgJnhwcCwgJnhlY2ZnLCAmZWNiKTsKfQoKLyoKICogR2l2ZW4gYW4gb3JpZ2luLCBwcmVwYXJlIG1tZmlsZV90IHN0cnVjdHVyZSB0byBiZSB1c2VkIGJ5IHRoZQogKiBkaWZmIG1hY2hpbmVyeQogKi8Kc3RhdGljIHZvaWQgZmlsbF9vcmlnaW5fYmxvYihzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHQsCgkJCSAgICAgc3RydWN0IGJsYW1lX29yaWdpbiAqbywgbW1maWxlX3QgKmZpbGUsIGludCAqbnVtX3JlYWRfYmxvYikKewoJaWYgKCFvLT5maWxlLnB0cikgewoJCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCQl1bnNpZ25lZCBsb25nIGZpbGVfc2l6ZTsKCgkJKCpudW1fcmVhZF9ibG9iKSsrOwoJCWlmIChvcHQtPmZsYWdzLmFsbG93X3RleHRjb252ICYmCgkJICAgIHRleHRjb252X29iamVjdChvLT5wYXRoLCBvLT5tb2RlLCAmby0+YmxvYl9vaWQsIDEsICZmaWxlLT5wdHIsICZmaWxlX3NpemUpKQoJCQk7CgkJZWxzZQoJCQlmaWxlLT5wdHIgPSByZWFkX3NoYTFfZmlsZShvLT5ibG9iX29pZC5oYXNoLCAmdHlwZSwKCQkJCQkJICAgJmZpbGVfc2l6ZSk7CgkJZmlsZS0+c2l6ZSA9IGZpbGVfc2l6ZTsKCgkJaWYgKCFmaWxlLT5wdHIpCgkJCWRpZSgiQ2Fubm90IHJlYWQgYmxvYiAlcyBmb3IgcGF0aCAlcyIsCgkJCSAgICBvaWRfdG9faGV4KCZvLT5ibG9iX29pZCksCgkJCSAgICBvLT5wYXRoKTsKCQlvLT5maWxlID0gKmZpbGU7Cgl9CgllbHNlCgkJKmZpbGUgPSBvLT5maWxlOwp9CgpzdGF0aWMgdm9pZCBkcm9wX29yaWdpbl9ibG9iKHN0cnVjdCBibGFtZV9vcmlnaW4gKm8pCnsKCWlmIChvLT5maWxlLnB0cikgewoJCUZSRUVfQU5EX05VTEwoby0+ZmlsZS5wdHIpOwoJfQp9CgovKgogKiBBbnkgbWVyZ2Ugb2YgYmxhbWVzIGhhcHBlbnMgb24gbGlzdHMgb2YgYmxhbWVzIHRoYXQgYXJyaXZlZCB2aWEKICogZGlmZmVyZW50IHBhcmVudHMgaW4gYSBzaW5nbGUgc3VzcGVjdC4gIEluIHRoaXMgY2FzZSwgd2Ugd2FudCB0bwogKiBzb3J0IGFjY29yZGluZyB0byB0aGUgc3VzcGVjdCBsaW5lIG51bWJlcnMgYXMgb3Bwb3NlZCB0byB0aGUgZmluYWwKICogaW1hZ2UgbGluZSBudW1iZXJzLiAgVGhlIGZ1bmN0aW9uIGJvZHkgaXMgc29tZXdoYXQgbG9uZ2lzaCBiZWNhdXNlCiAqIGl0IGF2b2lkcyB1bm5lY2Vzc2FyeSB3cml0ZXMuCiAqLwoKc3RhdGljIHN0cnVjdCBibGFtZV9lbnRyeSAqYmxhbWVfbWVyZ2Uoc3RydWN0IGJsYW1lX2VudHJ5ICpsaXN0MSwKCQkJCSAgICAgICBzdHJ1Y3QgYmxhbWVfZW50cnkgKmxpc3QyKQp7CglzdHJ1Y3QgYmxhbWVfZW50cnkgKnAxID0gbGlzdDEsICpwMiA9IGxpc3QyLAoJCSoqdGFpbCA9ICZsaXN0MTsKCglpZiAoIXAxKQoJCXJldHVybiBwMjsKCWlmICghcDIpCgkJcmV0dXJuIHAxOwoKCWlmIChwMS0+c19sbm8gPD0gcDItPnNfbG5vKSB7CgkJZG8gewoJCQl0YWlsID0gJnAxLT5uZXh0OwoJCQlpZiAoKHAxID0gKnRhaWwpID09IE5VTEwpIHsKCQkJCSp0YWlsID0gcDI7CgkJCQlyZXR1cm4gbGlzdDE7CgkJCX0KCQl9IHdoaWxlIChwMS0+c19sbm8gPD0gcDItPnNfbG5vKTsKCX0KCWZvciAoOzspIHsKCQkqdGFpbCA9IHAyOwoJCWRvIHsKCQkJdGFpbCA9ICZwMi0+bmV4dDsKCQkJaWYgKChwMiA9ICp0YWlsKSA9PSBOVUxMKSAgewoJCQkJKnRhaWwgPSBwMTsKCQkJCXJldHVybiBsaXN0MTsKCQkJfQoJCX0gd2hpbGUgKHAxLT5zX2xubyA+IHAyLT5zX2xubyk7CgkJKnRhaWwgPSBwMTsKCQlkbyB7CgkJCXRhaWwgPSAmcDEtPm5leHQ7CgkJCWlmICgocDEgPSAqdGFpbCkgPT0gTlVMTCkgewoJCQkJKnRhaWwgPSBwMjsKCQkJCXJldHVybiBsaXN0MTsKCQkJfQoJCX0gd2hpbGUgKHAxLT5zX2xubyA8PSBwMi0+c19sbm8pOwoJfQp9CgpzdGF0aWMgdm9pZCAqZ2V0X25leHRfYmxhbWUoY29uc3Qgdm9pZCAqcCkKewoJcmV0dXJuICgoc3RydWN0IGJsYW1lX2VudHJ5ICopcCktPm5leHQ7Cn0KCnN0YXRpYyB2b2lkIHNldF9uZXh0X2JsYW1lKHZvaWQgKnAxLCB2b2lkICpwMikKewoJKChzdHJ1Y3QgYmxhbWVfZW50cnkgKilwMSktPm5leHQgPSBwMjsKfQoKLyoKICogRmluYWwgaW1hZ2UgbGluZSBudW1iZXJzIGFyZSBhbGwgZGlmZmVyZW50LCBzbyB3ZSBkb24ndCBuZWVkIGEKICogdGhyZWUtd2F5IGNvbXBhcmlzb24gaGVyZS4KICovCgpzdGF0aWMgaW50IGNvbXBhcmVfYmxhbWVfZmluYWwoY29uc3Qgdm9pZCAqcDEsIGNvbnN0IHZvaWQgKnAyKQp7CglyZXR1cm4gKChzdHJ1Y3QgYmxhbWVfZW50cnkgKilwMSktPmxubyA+ICgoc3RydWN0IGJsYW1lX2VudHJ5ICopcDIpLT5sbm8KCQk/IDEgOiAtMTsKfQoKc3RhdGljIGludCBjb21wYXJlX2JsYW1lX3N1c3BlY3QoY29uc3Qgdm9pZCAqcDEsIGNvbnN0IHZvaWQgKnAyKQp7Cgljb25zdCBzdHJ1Y3QgYmxhbWVfZW50cnkgKnMxID0gcDEsICpzMiA9IHAyOwoJLyoKCSAqIHRvIGFsbG93IGZvciBjb2xsYXRpbmcgc3VzcGVjdHMsIHdlIHNvcnQgYWNjb3JkaW5nIHRvIHRoZQoJICogcmVzcGVjdGl2ZSBwb2ludGVyIHZhbHVlIGFzIHRoZSBwcmltYXJ5IHNvcnRpbmcgY3JpdGVyaW9uLgoJICogVGhlIGFjdHVhbCByZWxhdGlvbiBpcyBwcmV0dHkgdW5pbXBvcnRhbnQgYXMgbG9uZyBhcyBpdAoJICogZXN0YWJsaXNoZXMgYSB0b3RhbCBvcmRlci4gIENvbXBhcmluZyBhcyBpbnRlZ2VycyBnaXZlcyB1cwoJICogdGhhdC4KCSAqLwoJaWYgKHMxLT5zdXNwZWN0ICE9IHMyLT5zdXNwZWN0KQoJCXJldHVybiAoaW50cHRyX3QpczEtPnN1c3BlY3QgPiAoaW50cHRyX3QpczItPnN1c3BlY3QgPyAxIDogLTE7CglpZiAoczEtPnNfbG5vID09IHMyLT5zX2xubykKCQlyZXR1cm4gMDsKCXJldHVybiBzMS0+c19sbm8gPiBzMi0+c19sbm8gPyAxIDogLTE7Cn0KCnZvaWQgYmxhbWVfc29ydF9maW5hbChzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCAqc2IpCnsKCXNiLT5lbnQgPSBsbGlzdF9tZXJnZXNvcnQoc2ItPmVudCwgZ2V0X25leHRfYmxhbWUsIHNldF9uZXh0X2JsYW1lLAoJCQkJICBjb21wYXJlX2JsYW1lX2ZpbmFsKTsKfQoKc3RhdGljIGludCBjb21wYXJlX2NvbW1pdHNfYnlfcmV2ZXJzZV9jb21taXRfZGF0ZShjb25zdCB2b2lkICphLAoJCQkJCQkgIGNvbnN0IHZvaWQgKmIsCgkJCQkJCSAgdm9pZCAqYykKewoJcmV0dXJuIC1jb21wYXJlX2NvbW1pdHNfYnlfY29tbWl0X2RhdGUoYSwgYiwgYyk7Cn0KCi8qCiAqIEZvciBkZWJ1Z2dpbmcgLS0gb3JpZ2luIGlzIHJlZmNvdW50ZWQsIGFuZCB0aGlzIGFzc2VydHMgdGhhdAogKiB3ZSBkbyBub3QgdW5kZXJmbG93LgogKi8Kc3RhdGljIHZvaWQgc2FuaXR5X2NoZWNrX3JlZmNudChzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCAqc2IpCnsKCWludCBiYWEgPSAwOwoJc3RydWN0IGJsYW1lX2VudHJ5ICplbnQ7CgoJZm9yIChlbnQgPSBzYi0+ZW50OyBlbnQ7IGVudCA9IGVudC0+bmV4dCkgewoJCS8qIE5vYm9keSBzaG91bGQgaGF2ZSB6ZXJvIG9yIG5lZ2F0aXZlIHJlZmNudCAqLwoJCWlmIChlbnQtPnN1c3BlY3QtPnJlZmNudCA8PSAwKSB7CgkJCWZwcmludGYoc3RkZXJyLCAiJXMgaW4gJXMgaGFzIG5lZ2F0aXZlIHJlZmNudCAlZFxuIiwKCQkJCWVudC0+c3VzcGVjdC0+cGF0aCwKCQkJCW9pZF90b19oZXgoJmVudC0+c3VzcGVjdC0+Y29tbWl0LT5vYmplY3Qub2lkKSwKCQkJCWVudC0+c3VzcGVjdC0+cmVmY250KTsKCQkJYmFhID0gMTsKCQl9Cgl9CglpZiAoYmFhKQoJCXNiLT5vbl9zYW5pdHlfZmFpbChzYiwgYmFhKTsKfQoKLyoKICogSWYgdHdvIGJsYW1lIGVudHJpZXMgdGhhdCBhcmUgbmV4dCB0byBlYWNoIG90aGVyIGNhbWUgZnJvbQogKiBjb250aWd1b3VzIGxpbmVzIGluIHRoZSBzYW1lIG9yaWdpbiAoaS5lLiA8Y29tbWl0LCBwYXRoPiBwYWlyKSwKICogbWVyZ2UgdGhlbSB0b2dldGhlci4KICovCnZvaWQgYmxhbWVfY29hbGVzY2Uoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiKQp7CglzdHJ1Y3QgYmxhbWVfZW50cnkgKmVudCwgKm5leHQ7CgoJZm9yIChlbnQgPSBzYi0+ZW50OyBlbnQgJiYgKG5leHQgPSBlbnQtPm5leHQpOyBlbnQgPSBuZXh0KSB7CgkJaWYgKGVudC0+c3VzcGVjdCA9PSBuZXh0LT5zdXNwZWN0ICYmCgkJICAgIGVudC0+c19sbm8gKyBlbnQtPm51bV9saW5lcyA9PSBuZXh0LT5zX2xubykgewoJCQllbnQtPm51bV9saW5lcyArPSBuZXh0LT5udW1fbGluZXM7CgkJCWVudC0+bmV4dCA9IG5leHQtPm5leHQ7CgkJCWJsYW1lX29yaWdpbl9kZWNyZWYobmV4dC0+c3VzcGVjdCk7CgkJCWZyZWUobmV4dCk7CgkJCWVudC0+c2NvcmUgPSAwOwoJCQluZXh0ID0gZW50OyAvKiBhZ2FpbiAqLwoJCX0KCX0KCglpZiAoc2ItPmRlYnVnKSAvKiBzYW5pdHkgKi8KCQlzYW5pdHlfY2hlY2tfcmVmY250KHNiKTsKfQoKLyoKICogTWVyZ2UgdGhlIGdpdmVuIHNvcnRlZCBsaXN0IG9mIGJsYW1lcyBpbnRvIGEgcHJlZXhpc3Rpbmcgb3JpZ2luLgogKiBJZiB0aGVyZSB3ZXJlIG5vIHByZXZpb3VzIGJsYW1lcyB0byB0aGF0IGNvbW1pdCwgaXQgaXMgZW50ZXJlZCBpbnRvCiAqIHRoZSBjb21taXQgcHJpb3JpdHkgcXVldWUgb2YgdGhlIHNjb3JlIGJvYXJkLgogKi8KCnN0YXRpYyB2b2lkIHF1ZXVlX2JsYW1lcyhzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCAqc2IsIHN0cnVjdCBibGFtZV9vcmlnaW4gKnBvcmlnaW4sCgkJCSBzdHJ1Y3QgYmxhbWVfZW50cnkgKnNvcnRlZCkKewoJaWYgKHBvcmlnaW4tPnN1c3BlY3RzKQoJCXBvcmlnaW4tPnN1c3BlY3RzID0gYmxhbWVfbWVyZ2UocG9yaWdpbi0+c3VzcGVjdHMsIHNvcnRlZCk7CgllbHNlIHsKCQlzdHJ1Y3QgYmxhbWVfb3JpZ2luICpvOwoJCWZvciAobyA9IHBvcmlnaW4tPmNvbW1pdC0+dXRpbDsgbzsgbyA9IG8tPm5leHQpIHsKCQkJaWYgKG8tPnN1c3BlY3RzKSB7CgkJCQlwb3JpZ2luLT5zdXNwZWN0cyA9IHNvcnRlZDsKCQkJCXJldHVybjsKCQkJfQoJCX0KCQlwb3JpZ2luLT5zdXNwZWN0cyA9IHNvcnRlZDsKCQlwcmlvX3F1ZXVlX3B1dCgmc2ItPmNvbW1pdHMsIHBvcmlnaW4tPmNvbW1pdCk7Cgl9Cn0KCi8qCiAqIEZpbGwgdGhlIGJsb2Jfc2hhMSBmaWVsZCBvZiBhbiBvcmlnaW4gaWYgaXQgaGFzbid0LCBzbyB0aGF0IGxhdGVyCiAqIGNhbGwgdG8gZmlsbF9vcmlnaW5fYmxvYigpIGNhbiB1c2UgaXQgdG8gbG9jYXRlIHRoZSBkYXRhLiAgYmxvYl9zaGExCiAqIGZvciBhbiBvcmlnaW4gaXMgYWxzbyB1c2VkIHRvIHBhc3MgdGhlIGJsYW1lIGZvciB0aGUgZW50aXJlIGZpbGUgdG8KICogdGhlIHBhcmVudCB0byBkZXRlY3QgdGhlIGNhc2Ugd2hlcmUgYSBjaGlsZCdzIGJsb2IgaXMgaWRlbnRpY2FsIHRvCiAqIHRoYXQgb2YgaXRzIHBhcmVudCdzLgogKgogKiBUaGlzIGFsc28gZmlsbHMgb3JpZ2luLT5tb2RlIGZvciBjb3JyZXNwb25kaW5nIHRyZWUgcGF0aC4KICovCnN0YXRpYyBpbnQgZmlsbF9ibG9iX3NoYTFfYW5kX21vZGUoc3RydWN0IGJsYW1lX29yaWdpbiAqb3JpZ2luKQp7CglpZiAoIWlzX251bGxfb2lkKCZvcmlnaW4tPmJsb2Jfb2lkKSkKCQlyZXR1cm4gMDsKCWlmIChnZXRfdHJlZV9lbnRyeShvcmlnaW4tPmNvbW1pdC0+b2JqZWN0Lm9pZC5oYXNoLAoJCQkgICBvcmlnaW4tPnBhdGgsCgkJCSAgIG9yaWdpbi0+YmxvYl9vaWQuaGFzaCwgJm9yaWdpbi0+bW9kZSkpCgkJZ290byBlcnJvcl9vdXQ7CglpZiAob2lkX29iamVjdF9pbmZvKCZvcmlnaW4tPmJsb2Jfb2lkLCBOVUxMKSAhPSBPQkpfQkxPQikKCQlnb3RvIGVycm9yX291dDsKCXJldHVybiAwOwogZXJyb3Jfb3V0OgoJb2lkY2xyKCZvcmlnaW4tPmJsb2Jfb2lkKTsKCW9yaWdpbi0+bW9kZSA9IFNfSUZJTlZBTElEOwoJcmV0dXJuIC0xOwp9CgovKgogKiBXZSBoYXZlIGFuIG9yaWdpbiAtLSBjaGVjayBpZiB0aGUgc2FtZSBwYXRoIGV4aXN0cyBpbiB0aGUKICogcGFyZW50IGFuZCByZXR1cm4gYW4gb3JpZ2luIHN0cnVjdHVyZSB0byByZXByZXNlbnQgaXQuCiAqLwpzdGF0aWMgc3RydWN0IGJsYW1lX29yaWdpbiAqZmluZF9vcmlnaW4oc3RydWN0IGNvbW1pdCAqcGFyZW50LAoJCQkJICBzdHJ1Y3QgYmxhbWVfb3JpZ2luICpvcmlnaW4pCnsKCXN0cnVjdCBibGFtZV9vcmlnaW4gKnBvcmlnaW47CglzdHJ1Y3QgZGlmZl9vcHRpb25zIGRpZmZfb3B0czsKCWNvbnN0IGNoYXIgKnBhdGhzWzJdOwoKCS8qIEZpcnN0IGNoZWNrIGFueSBleGlzdGluZyBvcmlnaW5zICovCglmb3IgKHBvcmlnaW4gPSBwYXJlbnQtPnV0aWw7IHBvcmlnaW47IHBvcmlnaW4gPSBwb3JpZ2luLT5uZXh0KQoJCWlmICghc3RyY21wKHBvcmlnaW4tPnBhdGgsIG9yaWdpbi0+cGF0aCkpIHsKCQkJLyoKCQkJICogVGhlIHNhbWUgcGF0aCBiZXR3ZWVuIG9yaWdpbiBhbmQgaXRzIHBhcmVudAoJCQkgKiB3aXRob3V0IHJlbmFtaW5nIC0tIHRoZSBtb3N0IGNvbW1vbiBjYXNlLgoJCQkgKi8KCQkJcmV0dXJuIGJsYW1lX29yaWdpbl9pbmNyZWYgKHBvcmlnaW4pOwoJCX0KCgkvKiBTZWUgaWYgdGhlIG9yaWdpbi0+cGF0aCBpcyBkaWZmZXJlbnQgYmV0d2VlbiBwYXJlbnQKCSAqIGFuZCBvcmlnaW4gZmlyc3QuICBNb3N0IG9mIHRoZSB0aW1lIHRoZXkgYXJlIHRoZQoJICogc2FtZSBhbmQgZGlmZi10cmVlIGlzIGZhaXJseSBlZmZpY2llbnQgYWJvdXQgdGhpcy4KCSAqLwoJZGlmZl9zZXR1cCgmZGlmZl9vcHRzKTsKCWRpZmZfb3B0cy5mbGFncy5yZWN1cnNpdmUgPSAxOwoJZGlmZl9vcHRzLmRldGVjdF9yZW5hbWUgPSAwOwoJZGlmZl9vcHRzLm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9OT19PVVRQVVQ7CglwYXRoc1swXSA9IG9yaWdpbi0+cGF0aDsKCXBhdGhzWzFdID0gTlVMTDsKCglwYXJzZV9wYXRoc3BlYygmZGlmZl9vcHRzLnBhdGhzcGVjLAoJCSAgICAgICBQQVRIU1BFQ19BTExfTUFHSUMgJiB+UEFUSFNQRUNfTElURVJBTCwKCQkgICAgICAgUEFUSFNQRUNfTElURVJBTF9QQVRILCAiIiwgcGF0aHMpOwoJZGlmZl9zZXR1cF9kb25lKCZkaWZmX29wdHMpOwoKCWlmIChpc19udWxsX29pZCgmb3JpZ2luLT5jb21taXQtPm9iamVjdC5vaWQpKQoJCWRvX2RpZmZfY2FjaGUoJnBhcmVudC0+dHJlZS0+b2JqZWN0Lm9pZCwgJmRpZmZfb3B0cyk7CgllbHNlCgkJZGlmZl90cmVlX29pZCgmcGFyZW50LT50cmVlLT5vYmplY3Qub2lkLAoJCQkgICAgICAmb3JpZ2luLT5jb21taXQtPnRyZWUtPm9iamVjdC5vaWQsCgkJCSAgICAgICIiLCAmZGlmZl9vcHRzKTsKCWRpZmZjb3JlX3N0ZCgmZGlmZl9vcHRzKTsKCglpZiAoIWRpZmZfcXVldWVkX2RpZmYubnIpIHsKCQkvKiBUaGUgcGF0aCBpcyB0aGUgc2FtZSBhcyBwYXJlbnQgKi8KCQlwb3JpZ2luID0gZ2V0X29yaWdpbihwYXJlbnQsIG9yaWdpbi0+cGF0aCk7CgkJb2lkY3B5KCZwb3JpZ2luLT5ibG9iX29pZCwgJm9yaWdpbi0+YmxvYl9vaWQpOwoJCXBvcmlnaW4tPm1vZGUgPSBvcmlnaW4tPm1vZGU7Cgl9IGVsc2UgewoJCS8qCgkJICogU2luY2Ugb3JpZ2luLT5wYXRoIGlzIGEgcGF0aHNwZWMsIGlmIHRoZSBwYXJlbnQKCQkgKiBjb21taXQgaGFkIGl0IGFzIGEgZGlyZWN0b3J5LCB3ZSB3aWxsIHNlZSBhIHdob2xlCgkJICogYnVuY2ggb2YgZGVsZXRpb24gb2YgZmlsZXMgaW4gdGhlIGRpcmVjdG9yeSB0aGF0IHdlCgkJICogZG8gbm90IGNhcmUgYWJvdXQuCgkJICovCgkJaW50IGk7CgkJc3RydWN0IGRpZmZfZmlsZXBhaXIgKnAgPSBOVUxMOwoJCWZvciAoaSA9IDA7IGkgPCBkaWZmX3F1ZXVlZF9kaWZmLm5yOyBpKyspIHsKCQkJY29uc3QgY2hhciAqbmFtZTsKCQkJcCA9IGRpZmZfcXVldWVkX2RpZmYucXVldWVbaV07CgkJCW5hbWUgPSBwLT5vbmUtPnBhdGggPyBwLT5vbmUtPnBhdGggOiBwLT50d28tPnBhdGg7CgkJCWlmICghc3RyY21wKG5hbWUsIG9yaWdpbi0+cGF0aCkpCgkJCQlicmVhazsKCQl9CgkJaWYgKCFwKQoJCQlkaWUoImludGVybmFsIGVycm9yIGluIGJsYW1lOjpmaW5kX29yaWdpbiIpOwoJCXN3aXRjaCAocC0+c3RhdHVzKSB7CgkJZGVmYXVsdDoKCQkJZGllKCJpbnRlcm5hbCBlcnJvciBpbiBibGFtZTo6ZmluZF9vcmlnaW4gKCVjKSIsCgkJCSAgICBwLT5zdGF0dXMpOwoJCWNhc2UgJ00nOgoJCQlwb3JpZ2luID0gZ2V0X29yaWdpbihwYXJlbnQsIG9yaWdpbi0+cGF0aCk7CgkJCW9pZGNweSgmcG9yaWdpbi0+YmxvYl9vaWQsICZwLT5vbmUtPm9pZCk7CgkJCXBvcmlnaW4tPm1vZGUgPSBwLT5vbmUtPm1vZGU7CgkJCWJyZWFrOwoJCWNhc2UgJ0EnOgoJCWNhc2UgJ1QnOgoJCQkvKiBEaWQgbm90IGV4aXN0IGluIHBhcmVudCwgb3IgdHlwZSBjaGFuZ2VkICovCgkJCWJyZWFrOwoJCX0KCX0KCWRpZmZfZmx1c2goJmRpZmZfb3B0cyk7CgljbGVhcl9wYXRoc3BlYygmZGlmZl9vcHRzLnBhdGhzcGVjKTsKCXJldHVybiBwb3JpZ2luOwp9CgovKgogKiBXZSBoYXZlIGFuIG9yaWdpbiAtLSBmaW5kIHRoZSBwYXRoIHRoYXQgY29ycmVzcG9uZHMgdG8gaXQgaW4gaXRzCiAqIHBhcmVudCBhbmQgcmV0dXJuIGFuIG9yaWdpbiBzdHJ1Y3R1cmUgdG8gcmVwcmVzZW50IGl0LgogKi8Kc3RhdGljIHN0cnVjdCBibGFtZV9vcmlnaW4gKmZpbmRfcmVuYW1lKHN0cnVjdCBjb21taXQgKnBhcmVudCwKCQkJCSAgc3RydWN0IGJsYW1lX29yaWdpbiAqb3JpZ2luKQp7CglzdHJ1Y3QgYmxhbWVfb3JpZ2luICpwb3JpZ2luID0gTlVMTDsKCXN0cnVjdCBkaWZmX29wdGlvbnMgZGlmZl9vcHRzOwoJaW50IGk7CgoJZGlmZl9zZXR1cCgmZGlmZl9vcHRzKTsKCWRpZmZfb3B0cy5mbGFncy5yZWN1cnNpdmUgPSAxOwoJZGlmZl9vcHRzLmRldGVjdF9yZW5hbWUgPSBESUZGX0RFVEVDVF9SRU5BTUU7CglkaWZmX29wdHMub3V0cHV0X2Zvcm1hdCA9IERJRkZfRk9STUFUX05PX09VVFBVVDsKCWRpZmZfb3B0cy5zaW5nbGVfZm9sbG93ID0gb3JpZ2luLT5wYXRoOwoJZGlmZl9zZXR1cF9kb25lKCZkaWZmX29wdHMpOwoKCWlmIChpc19udWxsX29pZCgmb3JpZ2luLT5jb21taXQtPm9iamVjdC5vaWQpKQoJCWRvX2RpZmZfY2FjaGUoJnBhcmVudC0+dHJlZS0+b2JqZWN0Lm9pZCwgJmRpZmZfb3B0cyk7CgllbHNlCgkJZGlmZl90cmVlX29pZCgmcGFyZW50LT50cmVlLT5vYmplY3Qub2lkLAoJCQkgICAgICAmb3JpZ2luLT5jb21taXQtPnRyZWUtPm9iamVjdC5vaWQsCgkJCSAgICAgICIiLCAmZGlmZl9vcHRzKTsKCWRpZmZjb3JlX3N0ZCgmZGlmZl9vcHRzKTsKCglmb3IgKGkgPSAwOyBpIDwgZGlmZl9xdWV1ZWRfZGlmZi5ucjsgaSsrKSB7CgkJc3RydWN0IGRpZmZfZmlsZXBhaXIgKnAgPSBkaWZmX3F1ZXVlZF9kaWZmLnF1ZXVlW2ldOwoJCWlmICgocC0+c3RhdHVzID09ICdSJyB8fCBwLT5zdGF0dXMgPT0gJ0MnKSAmJgoJCSAgICAhc3RyY21wKHAtPnR3by0+cGF0aCwgb3JpZ2luLT5wYXRoKSkgewoJCQlwb3JpZ2luID0gZ2V0X29yaWdpbihwYXJlbnQsIHAtPm9uZS0+cGF0aCk7CgkJCW9pZGNweSgmcG9yaWdpbi0+YmxvYl9vaWQsICZwLT5vbmUtPm9pZCk7CgkJCXBvcmlnaW4tPm1vZGUgPSBwLT5vbmUtPm1vZGU7CgkJCWJyZWFrOwoJCX0KCX0KCWRpZmZfZmx1c2goJmRpZmZfb3B0cyk7CgljbGVhcl9wYXRoc3BlYygmZGlmZl9vcHRzLnBhdGhzcGVjKTsKCXJldHVybiBwb3JpZ2luOwp9CgovKgogKiBBcHBlbmQgYSBuZXcgYmxhbWUgZW50cnkgdG8gYSBnaXZlbiBvdXRwdXQgcXVldWUuCiAqLwpzdGF0aWMgdm9pZCBhZGRfYmxhbWVfZW50cnkoc3RydWN0IGJsYW1lX2VudHJ5ICoqKnF1ZXVlLAoJCQkgICAgY29uc3Qgc3RydWN0IGJsYW1lX2VudHJ5ICpzcmMpCnsKCXN0cnVjdCBibGFtZV9lbnRyeSAqZSA9IHhtYWxsb2Moc2l6ZW9mKCplKSk7CgltZW1jcHkoZSwgc3JjLCBzaXplb2YoKmUpKTsKCWJsYW1lX29yaWdpbl9pbmNyZWYoZS0+c3VzcGVjdCk7CgoJZS0+bmV4dCA9ICoqcXVldWU7CgkqKnF1ZXVlID0gZTsKCSpxdWV1ZSA9ICZlLT5uZXh0Owp9CgovKgogKiBzcmMgdHlwaWNhbGx5IGlzIG9uLXN0YWNrOyB3ZSB3YW50IHRvIGNvcHkgdGhlIGluZm9ybWF0aW9uIGluIGl0IHRvCiAqIGEgbWFsbG9jZWQgYmxhbWVfZW50cnkgdGhhdCBnZXRzIGFkZGVkIHRvIHRoZSBnaXZlbiBxdWV1ZS4gIFRoZQogKiBvcmlnaW4gb2YgZHN0IGxvc2VzIGEgcmVmY250LgogKi8Kc3RhdGljIHZvaWQgZHVwX2VudHJ5KHN0cnVjdCBibGFtZV9lbnRyeSAqKipxdWV1ZSwKCQkgICAgICBzdHJ1Y3QgYmxhbWVfZW50cnkgKmRzdCwgc3RydWN0IGJsYW1lX2VudHJ5ICpzcmMpCnsKCWJsYW1lX29yaWdpbl9pbmNyZWYoc3JjLT5zdXNwZWN0KTsKCWJsYW1lX29yaWdpbl9kZWNyZWYoZHN0LT5zdXNwZWN0KTsKCW1lbWNweShkc3QsIHNyYywgc2l6ZW9mKCpzcmMpKTsKCWRzdC0+bmV4dCA9ICoqcXVldWU7CgkqKnF1ZXVlID0gZHN0OwoJKnF1ZXVlID0gJmRzdC0+bmV4dDsKfQoKY29uc3QgY2hhciAqYmxhbWVfbnRoX2xpbmUoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLCBsb25nIGxubykKewoJcmV0dXJuIHNiLT5maW5hbF9idWYgKyBzYi0+bGluZW5vW2xub107Cn0KCi8qCiAqIEl0IGlzIGtub3duIHRoYXQgbGluZXMgYmV0d2VlbiB0bG5vIHRvIHNhbWUgY2FtZSBmcm9tIHBhcmVudCwgYW5kIGUKICogaGFzIGFuIG92ZXJsYXAgd2l0aCB0aGF0IHJhbmdlLiAgaXQgYWxzbyBpcyBrbm93biB0aGF0IHBhcmVudCdzCiAqIGxpbmUgcGxubyBjb3JyZXNwb25kcyB0byBlJ3MgbGluZSB0bG5vLgogKgogKiAgICAgICAgICAgICAgICA8LS0tLSBlIC0tLS0tPgogKiAgICAgICAgICAgICAgICAgICA8LS0tLS0tPgogKiAgICAgICAgICAgICAgICAgICA8LS0tLS0tLS0tLS0tPgogKiAgICAgICAgICAgICA8LS0tLS0tLS0tLS0tPgogKiAgICAgICAgICAgICA8LS0tLS0tLS0tLS0tLS0tLS0tPgogKgogKiBTcGxpdCBlIGludG8gcG90ZW50aWFsbHkgdGhyZWUgcGFydHM7IGJlZm9yZSB0aGlzIGNodW5rLCB0aGUgY2h1bmsKICogdG8gYmUgYmxhbWVkIGZvciB0aGUgcGFyZW50LCBhbmQgYWZ0ZXIgdGhhdCBwb3J0aW9uLgogKi8Kc3RhdGljIHZvaWQgc3BsaXRfb3ZlcmxhcChzdHJ1Y3QgYmxhbWVfZW50cnkgKnNwbGl0LAoJCQkgIHN0cnVjdCBibGFtZV9lbnRyeSAqZSwKCQkJICBpbnQgdGxubywgaW50IHBsbm8sIGludCBzYW1lLAoJCQkgIHN0cnVjdCBibGFtZV9vcmlnaW4gKnBhcmVudCkKewoJaW50IGNodW5rX2VuZF9sbm87CgltZW1zZXQoc3BsaXQsIDAsIHNpemVvZihzdHJ1Y3QgYmxhbWVfZW50cnkgWzNdKSk7CgoJaWYgKGUtPnNfbG5vIDwgdGxubykgewoJCS8qIHRoZXJlIGlzIGEgcHJlLWNodW5rIHBhcnQgbm90IGJsYW1lZCBvbiBwYXJlbnQgKi8KCQlzcGxpdFswXS5zdXNwZWN0ID0gYmxhbWVfb3JpZ2luX2luY3JlZihlLT5zdXNwZWN0KTsKCQlzcGxpdFswXS5sbm8gPSBlLT5sbm87CgkJc3BsaXRbMF0uc19sbm8gPSBlLT5zX2xubzsKCQlzcGxpdFswXS5udW1fbGluZXMgPSB0bG5vIC0gZS0+c19sbm87CgkJc3BsaXRbMV0ubG5vID0gZS0+bG5vICsgdGxubyAtIGUtPnNfbG5vOwoJCXNwbGl0WzFdLnNfbG5vID0gcGxubzsKCX0KCWVsc2UgewoJCXNwbGl0WzFdLmxubyA9IGUtPmxubzsKCQlzcGxpdFsxXS5zX2xubyA9IHBsbm8gKyAoZS0+c19sbm8gLSB0bG5vKTsKCX0KCglpZiAoc2FtZSA8IGUtPnNfbG5vICsgZS0+bnVtX2xpbmVzKSB7CgkJLyogdGhlcmUgaXMgYSBwb3N0LWNodW5rIHBhcnQgbm90IGJsYW1lZCBvbiBwYXJlbnQgKi8KCQlzcGxpdFsyXS5zdXNwZWN0ID0gYmxhbWVfb3JpZ2luX2luY3JlZihlLT5zdXNwZWN0KTsKCQlzcGxpdFsyXS5sbm8gPSBlLT5sbm8gKyAoc2FtZSAtIGUtPnNfbG5vKTsKCQlzcGxpdFsyXS5zX2xubyA9IGUtPnNfbG5vICsgKHNhbWUgLSBlLT5zX2xubyk7CgkJc3BsaXRbMl0ubnVtX2xpbmVzID0gZS0+c19sbm8gKyBlLT5udW1fbGluZXMgLSBzYW1lOwoJCWNodW5rX2VuZF9sbm8gPSBzcGxpdFsyXS5sbm87Cgl9CgllbHNlCgkJY2h1bmtfZW5kX2xubyA9IGUtPmxubyArIGUtPm51bV9saW5lczsKCXNwbGl0WzFdLm51bV9saW5lcyA9IGNodW5rX2VuZF9sbm8gLSBzcGxpdFsxXS5sbm87CgoJLyoKCSAqIGlmIGl0IHR1cm5zIG91dCB0aGVyZSBpcyBub3RoaW5nIHRvIGJsYW1lIHRoZSBwYXJlbnQgZm9yLAoJICogZm9yZ2V0IGFib3V0IHRoZSBzcGxpdHRpbmcuICAhc3BsaXRbMV0uc3VzcGVjdCBzaWduYWxzIHRoaXMuCgkgKi8KCWlmIChzcGxpdFsxXS5udW1fbGluZXMgPCAxKQoJCXJldHVybjsKCXNwbGl0WzFdLnN1c3BlY3QgPSBibGFtZV9vcmlnaW5faW5jcmVmKHBhcmVudCk7Cn0KCi8qCiAqIHNwbGl0X292ZXJsYXAoKSBkaXZpZGVkIGFuIGV4aXN0aW5nIGJsYW1lIGUgaW50byB1cCB0byB0aHJlZSBwYXJ0cwogKiBpbiBzcGxpdC4gIEFueSBhc3NpZ25lZCBibGFtZSBpcyBtb3ZlZCB0byBxdWV1ZSB0bwogKiByZWZsZWN0IHRoZSBzcGxpdC4KICovCnN0YXRpYyB2b2lkIHNwbGl0X2JsYW1lKHN0cnVjdCBibGFtZV9lbnRyeSAqKipibGFtZWQsCgkJCXN0cnVjdCBibGFtZV9lbnRyeSAqKip1bmJsYW1lZCwKCQkJc3RydWN0IGJsYW1lX2VudHJ5ICpzcGxpdCwKCQkJc3RydWN0IGJsYW1lX2VudHJ5ICplKQp7CglpZiAoc3BsaXRbMF0uc3VzcGVjdCAmJiBzcGxpdFsyXS5zdXNwZWN0KSB7CgkJLyogVGhlIGZpcnN0IHBhcnQgKHJldXNlIHN0b3JhZ2UgZm9yIHRoZSBleGlzdGluZyBlbnRyeSBlKSAqLwoJCWR1cF9lbnRyeSh1bmJsYW1lZCwgZSwgJnNwbGl0WzBdKTsKCgkJLyogVGhlIGxhc3QgcGFydCAtLSBtZSAqLwoJCWFkZF9ibGFtZV9lbnRyeSh1bmJsYW1lZCwgJnNwbGl0WzJdKTsKCgkJLyogLi4uIGFuZCB0aGUgbWlkZGxlIHBhcnQgLS0gcGFyZW50ICovCgkJYWRkX2JsYW1lX2VudHJ5KGJsYW1lZCwgJnNwbGl0WzFdKTsKCX0KCWVsc2UgaWYgKCFzcGxpdFswXS5zdXNwZWN0ICYmICFzcGxpdFsyXS5zdXNwZWN0KQoJCS8qCgkJICogVGhlIHBhcmVudCBjb3ZlcnMgdGhlIGVudGlyZSBhcmVhOyByZXVzZSBzdG9yYWdlIGZvcgoJCSAqIGUgYW5kIHJlcGxhY2UgaXQgd2l0aCB0aGUgcGFyZW50LgoJCSAqLwoJCWR1cF9lbnRyeShibGFtZWQsIGUsICZzcGxpdFsxXSk7CgllbHNlIGlmIChzcGxpdFswXS5zdXNwZWN0KSB7CgkJLyogbWUgYW5kIHRoZW4gcGFyZW50ICovCgkJZHVwX2VudHJ5KHVuYmxhbWVkLCBlLCAmc3BsaXRbMF0pOwoJCWFkZF9ibGFtZV9lbnRyeShibGFtZWQsICZzcGxpdFsxXSk7Cgl9CgllbHNlIHsKCQkvKiBwYXJlbnQgYW5kIHRoZW4gbWUgKi8KCQlkdXBfZW50cnkoYmxhbWVkLCBlLCAmc3BsaXRbMV0pOwoJCWFkZF9ibGFtZV9lbnRyeSh1bmJsYW1lZCwgJnNwbGl0WzJdKTsKCX0KfQoKLyoKICogQWZ0ZXIgc3BsaXR0aW5nIHRoZSBibGFtZSwgdGhlIG9yaWdpbnMgdXNlZCBieSB0aGUKICogb24tc3RhY2sgYmxhbWVfZW50cnkgc2hvdWxkIGxvc2Ugb25lIHJlZmNudCBlYWNoLgogKi8Kc3RhdGljIHZvaWQgZGVjcmVmX3NwbGl0KHN0cnVjdCBibGFtZV9lbnRyeSAqc3BsaXQpCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCAzOyBpKyspCgkJYmxhbWVfb3JpZ2luX2RlY3JlZihzcGxpdFtpXS5zdXNwZWN0KTsKfQoKLyoKICogcmV2ZXJzZV9ibGFtZSByZXZlcnNlcyB0aGUgbGlzdCBnaXZlbiBpbiBoZWFkLCBhcHBlbmRpbmcgdGFpbC4KICogVGhhdCBhbGxvd3MgdXMgdG8gYnVpbGQgbGlzdHMgaW4gcmV2ZXJzZSBvcmRlciwgdGhlbiByZXZlcnNlIHRoZW0KICogYWZ0ZXJ3YXJkcy4gIFRoaXMgY2FuIGJlIGZhc3RlciB0aGFuIGJ1aWxkaW5nIHRoZSBsaXN0IGluIHByb3BlcgogKiBvcmRlciByaWdodCBhd2F5LiAgVGhlIHJlYXNvbiBpcyB0aGF0IGJ1aWxkaW5nIGluIHByb3BlciBvcmRlcgogKiByZXF1aXJlcyB3cml0aW5nIGEgbGluayBpbiB0aGUgX3ByZXZpb3VzXyBlbGVtZW50LCB3aGlsZSBidWlsZGluZwogKiBpbiByZXZlcnNlIG9yZGVyIGp1c3QgcmVxdWlyZXMgcGxhY2luZyB0aGUgbGlzdCBoZWFkIGludG8gdGhlCiAqIF9jdXJyZW50XyBlbGVtZW50LgogKi8KCnN0YXRpYyBzdHJ1Y3QgYmxhbWVfZW50cnkgKnJldmVyc2VfYmxhbWUoc3RydWN0IGJsYW1lX2VudHJ5ICpoZWFkLAoJCQkJCSBzdHJ1Y3QgYmxhbWVfZW50cnkgKnRhaWwpCnsKCXdoaWxlIChoZWFkKSB7CgkJc3RydWN0IGJsYW1lX2VudHJ5ICpuZXh0ID0gaGVhZC0+bmV4dDsKCQloZWFkLT5uZXh0ID0gdGFpbDsKCQl0YWlsID0gaGVhZDsKCQloZWFkID0gbmV4dDsKCX0KCXJldHVybiB0YWlsOwp9CgovKgogKiBQcm9jZXNzIG9uZSBodW5rIGZyb20gdGhlIHBhdGNoIGJldHdlZW4gdGhlIGN1cnJlbnQgc3VzcGVjdCBmb3IKICogYmxhbWVfZW50cnkgZSBhbmQgaXRzIHBhcmVudC4gIFRoaXMgZmlyc3QgYmxhbWVzIGFueSB1bmZpbmlzaGVkCiAqIGVudHJpZXMgYmVmb3JlIHRoZSBjaHVuayAod2hpY2ggaXMgd2hlcmUgdGFyZ2V0IGFuZCBwYXJlbnQgc3RhcnQKICogZGlmZmVyaW5nKSBvbiB0aGUgcGFyZW50LCBhbmQgdGhlbiBzcGxpdHMgYmxhbWUgZW50cmllcyBhdCB0aGUKICogc3RhcnQgYW5kIGF0IHRoZSBlbmQgb2YgdGhlIGRpZmZlcmVuY2UgcmVnaW9uLiAgU2luY2UgdXNlIG9mIC1NIGFuZAogKiAtQyBvcHRpb25zIG1heSBsZWFkIHRvIG92ZXJsYXBwaW5nL2R1cGxpY2F0ZSBzb3VyY2UgbGluZSBudW1iZXIKICogcmFuZ2VzLCBhbGwgd2UgY2FuIHJlbHkgb24gZnJvbSBzb3J0aW5nL21lcmdpbmcgaXMgdGhlIG9yZGVyIG9mIHRoZQogKiBmaXJzdCBzdXNwZWN0IGxpbmUgbnVtYmVyLgogKi8Kc3RhdGljIHZvaWQgYmxhbWVfY2h1bmsoc3RydWN0IGJsYW1lX2VudHJ5ICoqKmRzdHEsIHN0cnVjdCBibGFtZV9lbnRyeSAqKipzcmNxLAoJCQlpbnQgdGxubywgaW50IG9mZnNldCwgaW50IHNhbWUsCgkJCXN0cnVjdCBibGFtZV9vcmlnaW4gKnBhcmVudCkKewoJc3RydWN0IGJsYW1lX2VudHJ5ICplID0gKipzcmNxOwoJc3RydWN0IGJsYW1lX2VudHJ5ICpzYW1lcCA9IE5VTEwsICpkaWZmcCA9IE5VTEw7CgoJd2hpbGUgKGUgJiYgZS0+c19sbm8gPCB0bG5vKSB7CgkJc3RydWN0IGJsYW1lX2VudHJ5ICpuZXh0ID0gZS0+bmV4dDsKCQkvKgoJCSAqIGN1cnJlbnQgcmVjb3JkIHN0YXJ0cyBiZWZvcmUgZGlmZmVyaW5nIHBvcnRpb24uICBJZgoJCSAqIGl0IHJlYWNoZXMgaW50byBpdCwgd2UgbmVlZCB0byBzcGxpdCBpdCB1cCBhbmQKCQkgKiBleGFtaW5lIHRoZSBzZWNvbmQgcGFydCBzZXBhcmF0ZWx5LgoJCSAqLwoJCWlmIChlLT5zX2xubyArIGUtPm51bV9saW5lcyA+IHRsbm8pIHsKCQkJLyogTW92ZSBzZWNvbmQgaGFsZiB0byBhIG5ldyByZWNvcmQgKi8KCQkJaW50IGxlbiA9IHRsbm8gLSBlLT5zX2xubzsKCQkJc3RydWN0IGJsYW1lX2VudHJ5ICpuID0geGNhbGxvYygxLCBzaXplb2YgKHN0cnVjdCBibGFtZV9lbnRyeSkpOwoJCQluLT5zdXNwZWN0ID0gZS0+c3VzcGVjdDsKCQkJbi0+bG5vID0gZS0+bG5vICsgbGVuOwoJCQluLT5zX2xubyA9IGUtPnNfbG5vICsgbGVuOwoJCQluLT5udW1fbGluZXMgPSBlLT5udW1fbGluZXMgLSBsZW47CgkJCWUtPm51bV9saW5lcyA9IGxlbjsKCQkJZS0+c2NvcmUgPSAwOwoJCQkvKiBQdXNoIG5ldyByZWNvcmQgdG8gZGlmZnAgKi8KCQkJbi0+bmV4dCA9IGRpZmZwOwoJCQlkaWZmcCA9IG47CgkJfSBlbHNlCgkJCWJsYW1lX29yaWdpbl9kZWNyZWYoZS0+c3VzcGVjdCk7CgkJLyogUGFzcyBibGFtZSBmb3IgZXZlcnl0aGluZyBiZWZvcmUgdGhlIGRpZmZlcmluZwoJCSAqIGNodW5rIHRvIHRoZSBwYXJlbnQgKi8KCQllLT5zdXNwZWN0ID0gYmxhbWVfb3JpZ2luX2luY3JlZihwYXJlbnQpOwoJCWUtPnNfbG5vICs9IG9mZnNldDsKCQllLT5uZXh0ID0gc2FtZXA7CgkJc2FtZXAgPSBlOwoJCWUgPSBuZXh0OwoJfQoJLyoKCSAqIEFzIHdlIGRvbid0IGtub3cgaG93IG11Y2ggb2YgYSBjb21tb24gc3RyZXRjaCBhZnRlciB0aGlzCgkgKiBkaWZmIHdpbGwgb2NjdXIsIHRoZSBjdXJyZW50bHkgYmxhbWVkIHBhcnRzIGFyZSBhbGwgdGhhdCB3ZQoJICogY2FuIGFzc2lnbiB0byB0aGUgcGFyZW50IGZvciBub3cuCgkgKi8KCglpZiAoc2FtZXApIHsKCQkqKmRzdHEgPSByZXZlcnNlX2JsYW1lKHNhbWVwLCAqKmRzdHEpOwoJCSpkc3RxID0gJnNhbWVwLT5uZXh0OwoJfQoJLyoKCSAqIFByZXBlbmQgdGhlIHNwbGl0IG9mZiBwb3J0aW9uczogZXZlcnl0aGluZyBhZnRlciBlIHN0YXJ0cwoJICogYWZ0ZXIgdGhlIGJsYW1lYWJsZSBwb3J0aW9uLgoJICovCgllID0gcmV2ZXJzZV9ibGFtZShkaWZmcCwgZSk7CgoJLyoKCSAqIE5vdyByZXRhaW4gcmVjb3JkcyBvbiB0aGUgdGFyZ2V0IHdoaWxlIHBhcnRzIGFyZSBkaWZmZXJlbnQKCSAqIGZyb20gdGhlIHBhcmVudC4KCSAqLwoJc2FtZXAgPSBOVUxMOwoJZGlmZnAgPSBOVUxMOwoJd2hpbGUgKGUgJiYgZS0+c19sbm8gPCBzYW1lKSB7CgkJc3RydWN0IGJsYW1lX2VudHJ5ICpuZXh0ID0gZS0+bmV4dDsKCgkJLyoKCQkgKiBJZiBjdXJyZW50IHJlY29yZCBleHRlbmRzIGludG8gc2FtZW5lc3MsIG5lZWQgdG8gc3BsaXQuCgkJICovCgkJaWYgKGUtPnNfbG5vICsgZS0+bnVtX2xpbmVzID4gc2FtZSkgewoJCQkvKgoJCQkgKiBNb3ZlIHNlY29uZCBoYWxmIHRvIGEgbmV3IHJlY29yZCB0byBiZQoJCQkgKiBwcm9jZXNzZWQgYnkgbGF0ZXIgY2h1bmtzCgkJCSAqLwoJCQlpbnQgbGVuID0gc2FtZSAtIGUtPnNfbG5vOwoJCQlzdHJ1Y3QgYmxhbWVfZW50cnkgKm4gPSB4Y2FsbG9jKDEsIHNpemVvZiAoc3RydWN0IGJsYW1lX2VudHJ5KSk7CgkJCW4tPnN1c3BlY3QgPSBibGFtZV9vcmlnaW5faW5jcmVmKGUtPnN1c3BlY3QpOwoJCQluLT5sbm8gPSBlLT5sbm8gKyBsZW47CgkJCW4tPnNfbG5vID0gZS0+c19sbm8gKyBsZW47CgkJCW4tPm51bV9saW5lcyA9IGUtPm51bV9saW5lcyAtIGxlbjsKCQkJZS0+bnVtX2xpbmVzID0gbGVuOwoJCQllLT5zY29yZSA9IDA7CgkJCS8qIFB1c2ggbmV3IHJlY29yZCB0byBzYW1lcCAqLwoJCQluLT5uZXh0ID0gc2FtZXA7CgkJCXNhbWVwID0gbjsKCQl9CgkJZS0+bmV4dCA9IGRpZmZwOwoJCWRpZmZwID0gZTsKCQllID0gbmV4dDsKCX0KCSoqc3JjcSA9IHJldmVyc2VfYmxhbWUoZGlmZnAsIHJldmVyc2VfYmxhbWUoc2FtZXAsIGUpKTsKCS8qIE1vdmUgYWNyb3NzIGVsZW1lbnRzIHRoYXQgYXJlIGluIHRoZSB1bmJsYW1hYmxlIHBvcnRpb24gKi8KCWlmIChkaWZmcCkKCQkqc3JjcSA9ICZkaWZmcC0+bmV4dDsKfQoKc3RydWN0IGJsYW1lX2NodW5rX2NiX2RhdGEgewoJc3RydWN0IGJsYW1lX29yaWdpbiAqcGFyZW50OwoJbG9uZyBvZmZzZXQ7CglzdHJ1Y3QgYmxhbWVfZW50cnkgKipkc3RxOwoJc3RydWN0IGJsYW1lX2VudHJ5ICoqc3JjcTsKfTsKCi8qIGRpZmYgY2h1bmtzIGFyZSBmcm9tIHBhcmVudCB0byB0YXJnZXQgKi8Kc3RhdGljIGludCBibGFtZV9jaHVua19jYihsb25nIHN0YXJ0X2EsIGxvbmcgY291bnRfYSwKCQkJICBsb25nIHN0YXJ0X2IsIGxvbmcgY291bnRfYiwgdm9pZCAqZGF0YSkKewoJc3RydWN0IGJsYW1lX2NodW5rX2NiX2RhdGEgKmQgPSBkYXRhOwoJaWYgKHN0YXJ0X2EgLSBzdGFydF9iICE9IGQtPm9mZnNldCkKCQlkaWUoImludGVybmFsIGVycm9yIGluIGJsYW1lOjpibGFtZV9jaHVua19jYiIpOwoJYmxhbWVfY2h1bmsoJmQtPmRzdHEsICZkLT5zcmNxLCBzdGFydF9iLCBzdGFydF9hIC0gc3RhcnRfYiwKCQkgICAgc3RhcnRfYiArIGNvdW50X2IsIGQtPnBhcmVudCk7CglkLT5vZmZzZXQgPSBzdGFydF9hICsgY291bnRfYSAtIChzdGFydF9iICsgY291bnRfYik7CglyZXR1cm4gMDsKfQoKLyoKICogV2UgYXJlIGxvb2tpbmcgYXQgdGhlIG9yaWdpbiAndGFyZ2V0JyBhbmQgYWltaW5nIHRvIHBhc3MgYmxhbWUKICogZm9yIHRoZSBsaW5lcyBpdCBpcyBzdXNwZWN0ZWQgdG8gaXRzIHBhcmVudC4gIFJ1biBkaWZmIHRvIGZpbmQKICogd2hpY2ggbGluZXMgY2FtZSBmcm9tIHBhcmVudCBhbmQgcGFzcyBibGFtZSBmb3IgdGhlbS4KICovCnN0YXRpYyB2b2lkIHBhc3NfYmxhbWVfdG9fcGFyZW50KHN0cnVjdCBibGFtZV9zY29yZWJvYXJkICpzYiwKCQkJCSBzdHJ1Y3QgYmxhbWVfb3JpZ2luICp0YXJnZXQsCgkJCQkgc3RydWN0IGJsYW1lX29yaWdpbiAqcGFyZW50KQp7CgltbWZpbGVfdCBmaWxlX3AsIGZpbGVfbzsKCXN0cnVjdCBibGFtZV9jaHVua19jYl9kYXRhIGQ7CglzdHJ1Y3QgYmxhbWVfZW50cnkgKm5ld2Rlc3QgPSBOVUxMOwoKCWlmICghdGFyZ2V0LT5zdXNwZWN0cykKCQlyZXR1cm47IC8qIG5vdGhpbmcgcmVtYWlucyBmb3IgdGhpcyB0YXJnZXQgKi8KCglkLnBhcmVudCA9IHBhcmVudDsKCWQub2Zmc2V0ID0gMDsKCWQuZHN0cSA9ICZuZXdkZXN0OyBkLnNyY3EgPSAmdGFyZ2V0LT5zdXNwZWN0czsKCglmaWxsX29yaWdpbl9ibG9iKCZzYi0+cmV2cy0+ZGlmZm9wdCwgcGFyZW50LCAmZmlsZV9wLCAmc2ItPm51bV9yZWFkX2Jsb2IpOwoJZmlsbF9vcmlnaW5fYmxvYigmc2ItPnJldnMtPmRpZmZvcHQsIHRhcmdldCwgJmZpbGVfbywgJnNiLT5udW1fcmVhZF9ibG9iKTsKCXNiLT5udW1fZ2V0X3BhdGNoKys7CgoJaWYgKGRpZmZfaHVua3MoJmZpbGVfcCwgJmZpbGVfbywgYmxhbWVfY2h1bmtfY2IsICZkLCBzYi0+eGRsX29wdHMpKQoJCWRpZSgidW5hYmxlIHRvIGdlbmVyYXRlIGRpZmYgKCVzIC0+ICVzKSIsCgkJICAgIG9pZF90b19oZXgoJnBhcmVudC0+Y29tbWl0LT5vYmplY3Qub2lkKSwKCQkgICAgb2lkX3RvX2hleCgmdGFyZ2V0LT5jb21taXQtPm9iamVjdC5vaWQpKTsKCS8qIFRoZSByZXN0IGFyZSB0aGUgc2FtZSBhcyB0aGUgcGFyZW50ICovCglibGFtZV9jaHVuaygmZC5kc3RxLCAmZC5zcmNxLCBJTlRfTUFYLCBkLm9mZnNldCwgSU5UX01BWCwgcGFyZW50KTsKCSpkLmRzdHEgPSBOVUxMOwoJcXVldWVfYmxhbWVzKHNiLCBwYXJlbnQsIG5ld2Rlc3QpOwoKCXJldHVybjsKfQoKLyoKICogVGhlIGxpbmVzIGluIGJsYW1lX2VudHJ5IGFmdGVyIHNwbGl0dGluZyBibGFtZXMgbWFueSB0aW1lcyBjYW4gYmVjb21lCiAqIHZlcnkgc21hbGwgYW5kIHRyaXZpYWwsIGFuZCBhdCBzb21lIHBvaW50IGl0IGJlY29tZXMgcG9pbnRsZXNzIHRvCiAqIGJsYW1lIHRoZSBwYXJlbnRzLiAgRS5nLiAiXHRcdH1cblx0fVxuXG4iIGFwcGVhcnMgZXZlcnl3aGVyZSBpbiBhbnkKICogb3JkaW5hcnkgQyBwcm9ncmFtLCBhbmQgaXQgaXMgbm90IHdvcnRoIHRvIHNheSBpdCB3YXMgY29waWVkIGZyb20KICogdG90YWxseSB1bnJlbGF0ZWQgZmlsZSBpbiB0aGUgcGFyZW50LgogKgogKiBDb21wdXRlIGhvdyB0cml2aWFsIHRoZSBsaW5lcyBpbiB0aGUgYmxhbWVfZW50cnkgYXJlLgogKi8KdW5zaWduZWQgYmxhbWVfZW50cnlfc2NvcmUoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLCBzdHJ1Y3QgYmxhbWVfZW50cnkgKmUpCnsKCXVuc2lnbmVkIHNjb3JlOwoJY29uc3QgY2hhciAqY3AsICplcDsKCglpZiAoZS0+c2NvcmUpCgkJcmV0dXJuIGUtPnNjb3JlOwoKCXNjb3JlID0gMTsKCWNwID0gYmxhbWVfbnRoX2xpbmUoc2IsIGUtPmxubyk7CgllcCA9IGJsYW1lX250aF9saW5lKHNiLCBlLT5sbm8gKyBlLT5udW1fbGluZXMpOwoJd2hpbGUgKGNwIDwgZXApIHsKCQl1bnNpZ25lZCBjaCA9ICooKHVuc2lnbmVkIGNoYXIgKiljcCk7CgkJaWYgKGlzYWxudW0oY2gpKQoJCQlzY29yZSsrOwoJCWNwKys7Cgl9CgllLT5zY29yZSA9IHNjb3JlOwoJcmV0dXJuIHNjb3JlOwp9CgovKgogKiBiZXN0X3NvX2ZhcltdIGFuZCBwb3RlbnRpYWxbXSBhcmUgYm90aCBhIHNwbGl0IG9mIGFuIGV4aXN0aW5nIGJsYW1lX2VudHJ5CiAqIHRoYXQgcGFzc2VzIGJsYW1lIHRvIHRoZSBwYXJlbnQuICBNYWludGFpbiBiZXN0X3NvX2ZhciB0aGUgYmVzdCBzcGxpdCBzbwogKiBmYXIsIGJ5IGNvbXBhcmluZyBwb3RlbnRpYWwgYW5kIGJlc3Rfc29fZmFyIGFuZCBjb3B5aW5nIHBvdGVudGlhbCBpbnRvCiAqIGJzdF9zb19mYXIgYXMgbmVlZGVkLgogKi8Kc3RhdGljIHZvaWQgY29weV9zcGxpdF9pZl9iZXR0ZXIoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLAoJCQkJIHN0cnVjdCBibGFtZV9lbnRyeSAqYmVzdF9zb19mYXIsCgkJCQkgc3RydWN0IGJsYW1lX2VudHJ5ICpwb3RlbnRpYWwpCnsKCWludCBpOwoKCWlmICghcG90ZW50aWFsWzFdLnN1c3BlY3QpCgkJcmV0dXJuOwoJaWYgKGJlc3Rfc29fZmFyWzFdLnN1c3BlY3QpIHsKCQlpZiAoYmxhbWVfZW50cnlfc2NvcmUoc2IsICZwb3RlbnRpYWxbMV0pIDwKCQkgICAgYmxhbWVfZW50cnlfc2NvcmUoc2IsICZiZXN0X3NvX2ZhclsxXSkpCgkJCXJldHVybjsKCX0KCglmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKQoJCWJsYW1lX29yaWdpbl9pbmNyZWYocG90ZW50aWFsW2ldLnN1c3BlY3QpOwoJZGVjcmVmX3NwbGl0KGJlc3Rfc29fZmFyKTsKCW1lbWNweShiZXN0X3NvX2ZhciwgcG90ZW50aWFsLCBzaXplb2Yoc3RydWN0IGJsYW1lX2VudHJ5WzNdKSk7Cn0KCi8qCiAqIFdlIGFyZSBsb29raW5nIGF0IGEgcGFydCBvZiB0aGUgZmluYWwgaW1hZ2UgcmVwcmVzZW50ZWQgYnkKICogZW50ICh0bG5vIGFuZCBzYW1lIGFyZSBvZmZzZXQgYnkgZW50LT5zX2xubykuCiAqIHRsbm8gaXMgd2hlcmUgd2UgYXJlIGxvb2tpbmcgYXQgaW4gdGhlIGZpbmFsIGltYWdlLgogKiB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHNhbWUgbWF0Y2ggcHJlaW1hZ2UuCiAqIHBsbm8gaXMgd2hlcmUgd2UgYXJlIGxvb2tpbmcgYXQgaW4gdGhlIHByZWltYWdlLgogKgogKiA8LS0tLS0tLS0tLS0tLS0gZmluYWwgaW1hZ2UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT4KICogICAgICAgPC0tLS0tLWVudC0tLS0tLT4KICogICAgICAgICBedGxubyBec2FtZQogKiAgICA8LS0tLS0tLS0tcHJlaW1hZ2UtLS0tLT4KICogICAgICAgICBecGxubwogKgogKiBBbGwgbGluZSBudW1iZXJzIGFyZSAwLWJhc2VkLgogKi8Kc3RhdGljIHZvaWQgaGFuZGxlX3NwbGl0KHN0cnVjdCBibGFtZV9zY29yZWJvYXJkICpzYiwKCQkJIHN0cnVjdCBibGFtZV9lbnRyeSAqZW50LAoJCQkgaW50IHRsbm8sIGludCBwbG5vLCBpbnQgc2FtZSwKCQkJIHN0cnVjdCBibGFtZV9vcmlnaW4gKnBhcmVudCwKCQkJIHN0cnVjdCBibGFtZV9lbnRyeSAqc3BsaXQpCnsKCWlmIChlbnQtPm51bV9saW5lcyA8PSB0bG5vKQoJCXJldHVybjsKCWlmICh0bG5vIDwgc2FtZSkgewoJCXN0cnVjdCBibGFtZV9lbnRyeSBwb3RlbnRpYWxbM107CgkJdGxubyArPSBlbnQtPnNfbG5vOwoJCXNhbWUgKz0gZW50LT5zX2xubzsKCQlzcGxpdF9vdmVybGFwKHBvdGVudGlhbCwgZW50LCB0bG5vLCBwbG5vLCBzYW1lLCBwYXJlbnQpOwoJCWNvcHlfc3BsaXRfaWZfYmV0dGVyKHNiLCBzcGxpdCwgcG90ZW50aWFsKTsKCQlkZWNyZWZfc3BsaXQocG90ZW50aWFsKTsKCX0KfQoKc3RydWN0IGhhbmRsZV9zcGxpdF9jYl9kYXRhIHsKCXN0cnVjdCBibGFtZV9zY29yZWJvYXJkICpzYjsKCXN0cnVjdCBibGFtZV9lbnRyeSAqZW50OwoJc3RydWN0IGJsYW1lX29yaWdpbiAqcGFyZW50OwoJc3RydWN0IGJsYW1lX2VudHJ5ICpzcGxpdDsKCWxvbmcgcGxubzsKCWxvbmcgdGxubzsKfTsKCnN0YXRpYyBpbnQgaGFuZGxlX3NwbGl0X2NiKGxvbmcgc3RhcnRfYSwgbG9uZyBjb3VudF9hLAoJCQkgICBsb25nIHN0YXJ0X2IsIGxvbmcgY291bnRfYiwgdm9pZCAqZGF0YSkKewoJc3RydWN0IGhhbmRsZV9zcGxpdF9jYl9kYXRhICpkID0gZGF0YTsKCWhhbmRsZV9zcGxpdChkLT5zYiwgZC0+ZW50LCBkLT50bG5vLCBkLT5wbG5vLCBzdGFydF9iLCBkLT5wYXJlbnQsCgkJICAgICBkLT5zcGxpdCk7CglkLT5wbG5vID0gc3RhcnRfYSArIGNvdW50X2E7CglkLT50bG5vID0gc3RhcnRfYiArIGNvdW50X2I7CglyZXR1cm4gMDsKfQoKLyoKICogRmluZCB0aGUgbGluZXMgZnJvbSBwYXJlbnQgdGhhdCBhcmUgdGhlIHNhbWUgYXMgZW50IHNvIHRoYXQKICogd2UgY2FuIHBhc3MgYmxhbWVzIHRvIGl0LiAgZmlsZV9wIGhhcyB0aGUgYmxvYiBjb250ZW50cyBmb3IKICogdGhlIHBhcmVudC4KICovCnN0YXRpYyB2b2lkIGZpbmRfY29weV9pbl9ibG9iKHN0cnVjdCBibGFtZV9zY29yZWJvYXJkICpzYiwKCQkJICAgICAgc3RydWN0IGJsYW1lX2VudHJ5ICplbnQsCgkJCSAgICAgIHN0cnVjdCBibGFtZV9vcmlnaW4gKnBhcmVudCwKCQkJICAgICAgc3RydWN0IGJsYW1lX2VudHJ5ICpzcGxpdCwKCQkJICAgICAgbW1maWxlX3QgKmZpbGVfcCkKewoJY29uc3QgY2hhciAqY3A7CgltbWZpbGVfdCBmaWxlX287CglzdHJ1Y3QgaGFuZGxlX3NwbGl0X2NiX2RhdGEgZDsKCgltZW1zZXQoJmQsIDAsIHNpemVvZihkKSk7CglkLnNiID0gc2I7IGQuZW50ID0gZW50OyBkLnBhcmVudCA9IHBhcmVudDsgZC5zcGxpdCA9IHNwbGl0OwoJLyoKCSAqIFByZXBhcmUgbW1maWxlIHRoYXQgY29udGFpbnMgb25seSB0aGUgbGluZXMgaW4gZW50LgoJICovCgljcCA9IGJsYW1lX250aF9saW5lKHNiLCBlbnQtPmxubyk7CglmaWxlX28ucHRyID0gKGNoYXIgKikgY3A7CglmaWxlX28uc2l6ZSA9IGJsYW1lX250aF9saW5lKHNiLCBlbnQtPmxubyArIGVudC0+bnVtX2xpbmVzKSAtIGNwOwoKCS8qCgkgKiBmaWxlX28gaXMgYSBwYXJ0IG9mIGZpbmFsIGltYWdlIHdlIGFyZSBhbm5vdGF0aW5nLgoJICogZmlsZV9wIHBhcnRpYWxseSBtYXkgbWF0Y2ggdGhhdCBpbWFnZS4KCSAqLwoJbWVtc2V0KHNwbGl0LCAwLCBzaXplb2Yoc3RydWN0IGJsYW1lX2VudHJ5IFszXSkpOwoJaWYgKGRpZmZfaHVua3MoZmlsZV9wLCAmZmlsZV9vLCBoYW5kbGVfc3BsaXRfY2IsICZkLCBzYi0+eGRsX29wdHMpKQoJCWRpZSgidW5hYmxlIHRvIGdlbmVyYXRlIGRpZmYgKCVzKSIsCgkJICAgIG9pZF90b19oZXgoJnBhcmVudC0+Y29tbWl0LT5vYmplY3Qub2lkKSk7CgkvKiByZW1haW5kZXIsIGlmIGFueSwgYWxsIG1hdGNoIHRoZSBwcmVpbWFnZSAqLwoJaGFuZGxlX3NwbGl0KHNiLCBlbnQsIGQudGxubywgZC5wbG5vLCBlbnQtPm51bV9saW5lcywgcGFyZW50LCBzcGxpdCk7Cn0KCi8qIE1vdmUgYWxsIGJsYW1lIGVudHJpZXMgZnJvbSBsaXN0ICpzb3VyY2UgdGhhdCBoYXZlIGEgc2NvcmUgc21hbGxlcgogKiB0aGFuIHNjb3JlX21pbiB0byB0aGUgZnJvbnQgb2YgbGlzdCAqc21hbGwuCiAqIFJldHVybnMgYSBwb2ludGVyIHRvIHRoZSBsaW5rIHBvaW50aW5nIHRvIHRoZSBvbGQgaGVhZCBvZiB0aGUgc21hbGwgbGlzdC4KICovCgpzdGF0aWMgc3RydWN0IGJsYW1lX2VudHJ5ICoqZmlsdGVyX3NtYWxsKHN0cnVjdCBibGFtZV9zY29yZWJvYXJkICpzYiwKCQkJCQkgc3RydWN0IGJsYW1lX2VudHJ5ICoqc21hbGwsCgkJCQkJIHN0cnVjdCBibGFtZV9lbnRyeSAqKnNvdXJjZSwKCQkJCQkgdW5zaWduZWQgc2NvcmVfbWluKQp7CglzdHJ1Y3QgYmxhbWVfZW50cnkgKnAgPSAqc291cmNlOwoJc3RydWN0IGJsYW1lX2VudHJ5ICpvbGRzbWFsbCA9ICpzbWFsbDsKCXdoaWxlIChwKSB7CgkJaWYgKGJsYW1lX2VudHJ5X3Njb3JlKHNiLCBwKSA8PSBzY29yZV9taW4pIHsKCQkJKnNtYWxsID0gcDsKCQkJc21hbGwgPSAmcC0+bmV4dDsKCQkJcCA9ICpzbWFsbDsKCQl9IGVsc2UgewoJCQkqc291cmNlID0gcDsKCQkJc291cmNlID0gJnAtPm5leHQ7CgkJCXAgPSAqc291cmNlOwoJCX0KCX0KCSpzbWFsbCA9IG9sZHNtYWxsOwoJKnNvdXJjZSA9IE5VTEw7CglyZXR1cm4gc21hbGw7Cn0KCi8qCiAqIFNlZSBpZiBsaW5lcyBjdXJyZW50bHkgdGFyZ2V0IGlzIHN1c3BlY3RlZCBmb3IgY2FuIGJlIGF0dHJpYnV0ZWQgdG8KICogcGFyZW50LgogKi8Kc3RhdGljIHZvaWQgZmluZF9tb3ZlX2luX3BhcmVudChzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCAqc2IsCgkJCQlzdHJ1Y3QgYmxhbWVfZW50cnkgKioqYmxhbWVkLAoJCQkJc3RydWN0IGJsYW1lX2VudHJ5ICoqdG9vc21hbGwsCgkJCQlzdHJ1Y3QgYmxhbWVfb3JpZ2luICp0YXJnZXQsCgkJCQlzdHJ1Y3QgYmxhbWVfb3JpZ2luICpwYXJlbnQpCnsKCXN0cnVjdCBibGFtZV9lbnRyeSAqZSwgc3BsaXRbM107CglzdHJ1Y3QgYmxhbWVfZW50cnkgKnVuYmxhbWVkID0gdGFyZ2V0LT5zdXNwZWN0czsKCXN0cnVjdCBibGFtZV9lbnRyeSAqbGVmdG92ZXIgPSBOVUxMOwoJbW1maWxlX3QgZmlsZV9wOwoKCWlmICghdW5ibGFtZWQpCgkJcmV0dXJuOyAvKiBub3RoaW5nIHJlbWFpbnMgZm9yIHRoaXMgdGFyZ2V0ICovCgoJZmlsbF9vcmlnaW5fYmxvYigmc2ItPnJldnMtPmRpZmZvcHQsIHBhcmVudCwgJmZpbGVfcCwgJnNiLT5udW1fcmVhZF9ibG9iKTsKCWlmICghZmlsZV9wLnB0cikKCQlyZXR1cm47CgoJLyogQXQgZWFjaCBpdGVyYXRpb24sIHVuYmxhbWVkIGhhcyBhIE5VTEwtdGVybWluYXRlZCBsaXN0IG9mCgkgKiBlbnRyaWVzIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW4gdGVzdGVkIGZvciBibGFtZS4gIGxlZnRvdmVyCgkgKiBjb250YWlucyB0aGUgcmV2ZXJzZWQgbGlzdCBvZiBlbnRyaWVzIHRoYXQgaGF2ZSBiZWVuIHRlc3RlZAoJICogd2l0aG91dCBiZWluZyBhc3NpZ25hYmxlIHRvIHRoZSBwYXJlbnQuCgkgKi8KCWRvIHsKCQlzdHJ1Y3QgYmxhbWVfZW50cnkgKip1bmJsYW1lZHRhaWwgPSAmdW5ibGFtZWQ7CgkJc3RydWN0IGJsYW1lX2VudHJ5ICpuZXh0OwoJCWZvciAoZSA9IHVuYmxhbWVkOyBlOyBlID0gbmV4dCkgewoJCQluZXh0ID0gZS0+bmV4dDsKCQkJZmluZF9jb3B5X2luX2Jsb2Ioc2IsIGUsIHBhcmVudCwgc3BsaXQsICZmaWxlX3ApOwoJCQlpZiAoc3BsaXRbMV0uc3VzcGVjdCAmJgoJCQkgICAgc2ItPm1vdmVfc2NvcmUgPCBibGFtZV9lbnRyeV9zY29yZShzYiwgJnNwbGl0WzFdKSkgewoJCQkJc3BsaXRfYmxhbWUoYmxhbWVkLCAmdW5ibGFtZWR0YWlsLCBzcGxpdCwgZSk7CgkJCX0gZWxzZSB7CgkJCQllLT5uZXh0ID0gbGVmdG92ZXI7CgkJCQlsZWZ0b3ZlciA9IGU7CgkJCX0KCQkJZGVjcmVmX3NwbGl0KHNwbGl0KTsKCQl9CgkJKnVuYmxhbWVkdGFpbCA9IE5VTEw7CgkJdG9vc21hbGwgPSBmaWx0ZXJfc21hbGwoc2IsIHRvb3NtYWxsLCAmdW5ibGFtZWQsIHNiLT5tb3ZlX3Njb3JlKTsKCX0gd2hpbGUgKHVuYmxhbWVkKTsKCXRhcmdldC0+c3VzcGVjdHMgPSByZXZlcnNlX2JsYW1lKGxlZnRvdmVyLCBOVUxMKTsKfQoKc3RydWN0IGJsYW1lX2xpc3QgewoJc3RydWN0IGJsYW1lX2VudHJ5ICplbnQ7CglzdHJ1Y3QgYmxhbWVfZW50cnkgc3BsaXRbM107Cn07CgovKgogKiBDb3VudCB0aGUgbnVtYmVyIG9mIGVudHJpZXMgdGhlIHRhcmdldCBpcyBzdXNwZWN0ZWQgZm9yLAogKiBhbmQgcHJlcGFyZSBhIGxpc3Qgb2YgZW50cnkgYW5kIHRoZSBiZXN0IHNwbGl0LgogKi8Kc3RhdGljIHN0cnVjdCBibGFtZV9saXN0ICpzZXR1cF9ibGFtZV9saXN0KHN0cnVjdCBibGFtZV9lbnRyeSAqdW5ibGFtZWQsCgkJCQkJICAgaW50ICpudW1fZW50c19wKQp7CglzdHJ1Y3QgYmxhbWVfZW50cnkgKmU7CglpbnQgbnVtX2VudHMsIGk7CglzdHJ1Y3QgYmxhbWVfbGlzdCAqYmxhbWVfbGlzdCA9IE5VTEw7CgoJZm9yIChlID0gdW5ibGFtZWQsIG51bV9lbnRzID0gMDsgZTsgZSA9IGUtPm5leHQpCgkJbnVtX2VudHMrKzsKCWlmIChudW1fZW50cykgewoJCWJsYW1lX2xpc3QgPSB4Y2FsbG9jKG51bV9lbnRzLCBzaXplb2Yoc3RydWN0IGJsYW1lX2xpc3QpKTsKCQlmb3IgKGUgPSB1bmJsYW1lZCwgaSA9IDA7IGU7IGUgPSBlLT5uZXh0KQoJCQlibGFtZV9saXN0W2krK10uZW50ID0gZTsKCX0KCSpudW1fZW50c19wID0gbnVtX2VudHM7CglyZXR1cm4gYmxhbWVfbGlzdDsKfQoKLyoKICogRm9yIGxpbmVzIHRhcmdldCBpcyBzdXNwZWN0ZWQgZm9yLCBzZWUgaWYgd2UgY2FuIGZpbmQgY29kZSBtb3ZlbWVudAogKiBhY3Jvc3MgZmlsZSBib3VuZGFyeSBmcm9tIHRoZSBwYXJlbnQgY29tbWl0LiAgcG9yaWdpbiBpcyB0aGUgcGF0aAogKiBpbiB0aGUgcGFyZW50IHdlIGFscmVhZHkgdHJpZWQuCiAqLwpzdGF0aWMgdm9pZCBmaW5kX2NvcHlfaW5fcGFyZW50KHN0cnVjdCBibGFtZV9zY29yZWJvYXJkICpzYiwKCQkJCXN0cnVjdCBibGFtZV9lbnRyeSAqKipibGFtZWQsCgkJCQlzdHJ1Y3QgYmxhbWVfZW50cnkgKip0b29zbWFsbCwKCQkJCXN0cnVjdCBibGFtZV9vcmlnaW4gKnRhcmdldCwKCQkJCXN0cnVjdCBjb21taXQgKnBhcmVudCwKCQkJCXN0cnVjdCBibGFtZV9vcmlnaW4gKnBvcmlnaW4sCgkJCQlpbnQgb3B0KQp7CglzdHJ1Y3QgZGlmZl9vcHRpb25zIGRpZmZfb3B0czsKCWludCBpLCBqOwoJc3RydWN0IGJsYW1lX2xpc3QgKmJsYW1lX2xpc3Q7CglpbnQgbnVtX2VudHM7CglzdHJ1Y3QgYmxhbWVfZW50cnkgKnVuYmxhbWVkID0gdGFyZ2V0LT5zdXNwZWN0czsKCXN0cnVjdCBibGFtZV9lbnRyeSAqbGVmdG92ZXIgPSBOVUxMOwoKCWlmICghdW5ibGFtZWQpCgkJcmV0dXJuOyAvKiBub3RoaW5nIHJlbWFpbnMgZm9yIHRoaXMgdGFyZ2V0ICovCgoJZGlmZl9zZXR1cCgmZGlmZl9vcHRzKTsKCWRpZmZfb3B0cy5mbGFncy5yZWN1cnNpdmUgPSAxOwoJZGlmZl9vcHRzLm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9OT19PVVRQVVQ7CgoJZGlmZl9zZXR1cF9kb25lKCZkaWZmX29wdHMpOwoKCS8qIFRyeSAiZmluZCBjb3BpZXMgaGFyZGVyIiBvbiBuZXcgcGF0aCBpZiByZXF1ZXN0ZWQ7CgkgKiB3ZSBkbyBub3Qgd2FudCB0byB1c2UgZGlmZmNvcmVfcmVuYW1lKCkgYWN0dWFsbHkgdG8KCSAqIG1hdGNoIHRoaW5ncyB1cDsgZmluZF9jb3BpZXNfaGFyZGVyIGlzIHNldCBvbmx5IHRvCgkgKiBmb3JjZSBkaWZmX3RyZWVfb2lkKCkgdG8gZmVlZCBhbGwgZmlsZXBhaXJzIHRvIGRpZmZfcXVldWUsCgkgKiBhbmQgdGhpcyBjb2RlIG5lZWRzIHRvIGJlIGFmdGVyIGRpZmZfc2V0dXBfZG9uZSgpLCB3aGljaAoJICogdXN1YWxseSBtYWtlcyBmaW5kLWNvcGllcy1oYXJkZXIgaW1wbHkgY29weSBkZXRlY3Rpb24uCgkgKi8KCWlmICgob3B0ICYgUElDS0FYRV9CTEFNRV9DT1BZX0hBUkRFU1QpCgkgICAgfHwgKChvcHQgJiBQSUNLQVhFX0JMQU1FX0NPUFlfSEFSREVSKQoJCSYmICghcG9yaWdpbiB8fCBzdHJjbXAodGFyZ2V0LT5wYXRoLCBwb3JpZ2luLT5wYXRoKSkpKQoJCWRpZmZfb3B0cy5mbGFncy5maW5kX2NvcGllc19oYXJkZXIgPSAxOwoKCWlmIChpc19udWxsX29pZCgmdGFyZ2V0LT5jb21taXQtPm9iamVjdC5vaWQpKQoJCWRvX2RpZmZfY2FjaGUoJnBhcmVudC0+dHJlZS0+b2JqZWN0Lm9pZCwgJmRpZmZfb3B0cyk7CgllbHNlCgkJZGlmZl90cmVlX29pZCgmcGFyZW50LT50cmVlLT5vYmplY3Qub2lkLAoJCQkgICAgICAmdGFyZ2V0LT5jb21taXQtPnRyZWUtPm9iamVjdC5vaWQsCgkJCSAgICAgICIiLCAmZGlmZl9vcHRzKTsKCglpZiAoIWRpZmZfb3B0cy5mbGFncy5maW5kX2NvcGllc19oYXJkZXIpCgkJZGlmZmNvcmVfc3RkKCZkaWZmX29wdHMpOwoKCWRvIHsKCQlzdHJ1Y3QgYmxhbWVfZW50cnkgKip1bmJsYW1lZHRhaWwgPSAmdW5ibGFtZWQ7CgkJYmxhbWVfbGlzdCA9IHNldHVwX2JsYW1lX2xpc3QodW5ibGFtZWQsICZudW1fZW50cyk7CgoJCWZvciAoaSA9IDA7IGkgPCBkaWZmX3F1ZXVlZF9kaWZmLm5yOyBpKyspIHsKCQkJc3RydWN0IGRpZmZfZmlsZXBhaXIgKnAgPSBkaWZmX3F1ZXVlZF9kaWZmLnF1ZXVlW2ldOwoJCQlzdHJ1Y3QgYmxhbWVfb3JpZ2luICpub3JpZ2luOwoJCQltbWZpbGVfdCBmaWxlX3A7CgkJCXN0cnVjdCBibGFtZV9lbnRyeSBwb3RlbnRpYWxbM107CgoJCQlpZiAoIURJRkZfRklMRV9WQUxJRChwLT5vbmUpKQoJCQkJY29udGludWU7IC8qIGRvZXMgbm90IGV4aXN0IGluIHBhcmVudCAqLwoJCQlpZiAoU19JU0dJVExJTksocC0+b25lLT5tb2RlKSkKCQkJCWNvbnRpbnVlOyAvKiBpZ25vcmUgZ2l0IGxpbmtzICovCgkJCWlmIChwb3JpZ2luICYmICFzdHJjbXAocC0+b25lLT5wYXRoLCBwb3JpZ2luLT5wYXRoKSkKCQkJCS8qIGZpbmRfbW92ZSBhbHJlYWR5IGRlYWx0IHdpdGggdGhpcyBwYXRoICovCgkJCQljb250aW51ZTsKCgkJCW5vcmlnaW4gPSBnZXRfb3JpZ2luKHBhcmVudCwgcC0+b25lLT5wYXRoKTsKCQkJb2lkY3B5KCZub3JpZ2luLT5ibG9iX29pZCwgJnAtPm9uZS0+b2lkKTsKCQkJbm9yaWdpbi0+bW9kZSA9IHAtPm9uZS0+bW9kZTsKCQkJZmlsbF9vcmlnaW5fYmxvYigmc2ItPnJldnMtPmRpZmZvcHQsIG5vcmlnaW4sICZmaWxlX3AsICZzYi0+bnVtX3JlYWRfYmxvYik7CgkJCWlmICghZmlsZV9wLnB0cikKCQkJCWNvbnRpbnVlOwoKCQkJZm9yIChqID0gMDsgaiA8IG51bV9lbnRzOyBqKyspIHsKCQkJCWZpbmRfY29weV9pbl9ibG9iKHNiLCBibGFtZV9saXN0W2pdLmVudCwKCQkJCQkJICBub3JpZ2luLCBwb3RlbnRpYWwsICZmaWxlX3ApOwoJCQkJY29weV9zcGxpdF9pZl9iZXR0ZXIoc2IsIGJsYW1lX2xpc3Rbal0uc3BsaXQsCgkJCQkJCSAgICAgcG90ZW50aWFsKTsKCQkJCWRlY3JlZl9zcGxpdChwb3RlbnRpYWwpOwoJCQl9CgkJCWJsYW1lX29yaWdpbl9kZWNyZWYobm9yaWdpbik7CgkJfQoKCQlmb3IgKGogPSAwOyBqIDwgbnVtX2VudHM7IGorKykgewoJCQlzdHJ1Y3QgYmxhbWVfZW50cnkgKnNwbGl0ID0gYmxhbWVfbGlzdFtqXS5zcGxpdDsKCQkJaWYgKHNwbGl0WzFdLnN1c3BlY3QgJiYKCQkJICAgIHNiLT5jb3B5X3Njb3JlIDwgYmxhbWVfZW50cnlfc2NvcmUoc2IsICZzcGxpdFsxXSkpIHsKCQkJCXNwbGl0X2JsYW1lKGJsYW1lZCwgJnVuYmxhbWVkdGFpbCwgc3BsaXQsCgkJCQkJICAgIGJsYW1lX2xpc3Rbal0uZW50KTsKCQkJfSBlbHNlIHsKCQkJCWJsYW1lX2xpc3Rbal0uZW50LT5uZXh0ID0gbGVmdG92ZXI7CgkJCQlsZWZ0b3ZlciA9IGJsYW1lX2xpc3Rbal0uZW50OwoJCQl9CgkJCWRlY3JlZl9zcGxpdChzcGxpdCk7CgkJfQoJCWZyZWUoYmxhbWVfbGlzdCk7CgkJKnVuYmxhbWVkdGFpbCA9IE5VTEw7CgkJdG9vc21hbGwgPSBmaWx0ZXJfc21hbGwoc2IsIHRvb3NtYWxsLCAmdW5ibGFtZWQsIHNiLT5jb3B5X3Njb3JlKTsKCX0gd2hpbGUgKHVuYmxhbWVkKTsKCXRhcmdldC0+c3VzcGVjdHMgPSByZXZlcnNlX2JsYW1lKGxlZnRvdmVyLCBOVUxMKTsKCWRpZmZfZmx1c2goJmRpZmZfb3B0cyk7CgljbGVhcl9wYXRoc3BlYygmZGlmZl9vcHRzLnBhdGhzcGVjKTsKfQoKLyoKICogVGhlIGJsb2JzIG9mIG9yaWdpbiBhbmQgcG9yaWdpbiBleGFjdGx5IG1hdGNoLCBzbyBldmVyeXRoaW5nCiAqIG9yaWdpbiBpcyBzdXNwZWN0ZWQgZm9yIGNhbiBiZSBibGFtZWQgb24gdGhlIHBhcmVudC4KICovCnN0YXRpYyB2b2lkIHBhc3Nfd2hvbGVfYmxhbWUoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLAoJCQkgICAgIHN0cnVjdCBibGFtZV9vcmlnaW4gKm9yaWdpbiwgc3RydWN0IGJsYW1lX29yaWdpbiAqcG9yaWdpbikKewoJc3RydWN0IGJsYW1lX2VudHJ5ICplLCAqc3VzcGVjdHM7CgoJaWYgKCFwb3JpZ2luLT5maWxlLnB0ciAmJiBvcmlnaW4tPmZpbGUucHRyKSB7CgkJLyogU3RlYWwgaXRzIGZpbGUgKi8KCQlwb3JpZ2luLT5maWxlID0gb3JpZ2luLT5maWxlOwoJCW9yaWdpbi0+ZmlsZS5wdHIgPSBOVUxMOwoJfQoJc3VzcGVjdHMgPSBvcmlnaW4tPnN1c3BlY3RzOwoJb3JpZ2luLT5zdXNwZWN0cyA9IE5VTEw7Cglmb3IgKGUgPSBzdXNwZWN0czsgZTsgZSA9IGUtPm5leHQpIHsKCQlibGFtZV9vcmlnaW5faW5jcmVmKHBvcmlnaW4pOwoJCWJsYW1lX29yaWdpbl9kZWNyZWYoZS0+c3VzcGVjdCk7CgkJZS0+c3VzcGVjdCA9IHBvcmlnaW47Cgl9CglxdWV1ZV9ibGFtZXMoc2IsIHBvcmlnaW4sIHN1c3BlY3RzKTsKfQoKLyoKICogV2UgcGFzcyBibGFtZSBmcm9tIHRoZSBjdXJyZW50IGNvbW1pdCB0byBpdHMgcGFyZW50cy4gIFdlIGtlZXAgc2F5aW5nCiAqICJwYXJlbnQiIChhbmQgInBvcmlnaW4iKSwgYnV0IHdoYXQgd2UgbWVhbiBpcyB0byBmaW5kIHNjYXBlZ29hdCB0bwogKiBleG9uZXJhdGUgb3Vyc2VsdmVzLgogKi8Kc3RhdGljIHN0cnVjdCBjb21taXRfbGlzdCAqZmlyc3Rfc2NhcGVnb2F0KHN0cnVjdCByZXZfaW5mbyAqcmV2cywgc3RydWN0IGNvbW1pdCAqY29tbWl0LAoJCQkJCWludCByZXZlcnNlKQp7CglpZiAoIXJldmVyc2UpIHsKCQlpZiAocmV2cy0+Zmlyc3RfcGFyZW50X29ubHkgJiYKCQkgICAgY29tbWl0LT5wYXJlbnRzICYmCgkJICAgIGNvbW1pdC0+cGFyZW50cy0+bmV4dCkgewoJCQlmcmVlX2NvbW1pdF9saXN0KGNvbW1pdC0+cGFyZW50cy0+bmV4dCk7CgkJCWNvbW1pdC0+cGFyZW50cy0+bmV4dCA9IE5VTEw7CgkJfQoJCXJldHVybiBjb21taXQtPnBhcmVudHM7Cgl9CglyZXR1cm4gbG9va3VwX2RlY29yYXRpb24oJnJldnMtPmNoaWxkcmVuLCAmY29tbWl0LT5vYmplY3QpOwp9CgpzdGF0aWMgaW50IG51bV9zY2FwZWdvYXRzKHN0cnVjdCByZXZfaW5mbyAqcmV2cywgc3RydWN0IGNvbW1pdCAqY29tbWl0LCBpbnQgcmV2ZXJzZSkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpsID0gZmlyc3Rfc2NhcGVnb2F0KHJldnMsIGNvbW1pdCwgcmV2ZXJzZSk7CglyZXR1cm4gY29tbWl0X2xpc3RfY291bnQobCk7Cn0KCi8qIERpc3RyaWJ1dGUgY29sbGVjdGVkIHVuc29ydGVkIGJsYW1lcyB0byB0aGUgcmVzcGVjdGVkIHNvcnRlZCBsaXN0cwogKiBpbiB0aGUgdmFyaW91cyBvcmlnaW5zLgogKi8Kc3RhdGljIHZvaWQgZGlzdHJpYnV0ZV9ibGFtZShzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCAqc2IsIHN0cnVjdCBibGFtZV9lbnRyeSAqYmxhbWVkKQp7CglibGFtZWQgPSBsbGlzdF9tZXJnZXNvcnQoYmxhbWVkLCBnZXRfbmV4dF9ibGFtZSwgc2V0X25leHRfYmxhbWUsCgkJCQkgY29tcGFyZV9ibGFtZV9zdXNwZWN0KTsKCXdoaWxlIChibGFtZWQpCgl7CgkJc3RydWN0IGJsYW1lX29yaWdpbiAqcG9yaWdpbiA9IGJsYW1lZC0+c3VzcGVjdDsKCQlzdHJ1Y3QgYmxhbWVfZW50cnkgKnN1c3BlY3RzID0gTlVMTDsKCQlkbyB7CgkJCXN0cnVjdCBibGFtZV9lbnRyeSAqbmV4dCA9IGJsYW1lZC0+bmV4dDsKCQkJYmxhbWVkLT5uZXh0ID0gc3VzcGVjdHM7CgkJCXN1c3BlY3RzID0gYmxhbWVkOwoJCQlibGFtZWQgPSBuZXh0OwoJCX0gd2hpbGUgKGJsYW1lZCAmJiBibGFtZWQtPnN1c3BlY3QgPT0gcG9yaWdpbik7CgkJc3VzcGVjdHMgPSByZXZlcnNlX2JsYW1lKHN1c3BlY3RzLCBOVUxMKTsKCQlxdWV1ZV9ibGFtZXMoc2IsIHBvcmlnaW4sIHN1c3BlY3RzKTsKCX0KfQoKI2RlZmluZSBNQVhTRyAxNgoKc3RhdGljIHZvaWQgcGFzc19ibGFtZShzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCAqc2IsIHN0cnVjdCBibGFtZV9vcmlnaW4gKm9yaWdpbiwgaW50IG9wdCkKewoJc3RydWN0IHJldl9pbmZvICpyZXZzID0gc2ItPnJldnM7CglpbnQgaSwgcGFzcywgbnVtX3NnOwoJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gb3JpZ2luLT5jb21taXQ7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnNnOwoJc3RydWN0IGJsYW1lX29yaWdpbiAqc2dfYnVmW01BWFNHXTsKCXN0cnVjdCBibGFtZV9vcmlnaW4gKnBvcmlnaW4sICoqc2dfb3JpZ2luID0gc2dfYnVmOwoJc3RydWN0IGJsYW1lX2VudHJ5ICp0b29zbWFsbCA9IE5VTEw7CglzdHJ1Y3QgYmxhbWVfZW50cnkgKmJsYW1lcywgKipibGFtZXRhaWwgPSAmYmxhbWVzOwoKCW51bV9zZyA9IG51bV9zY2FwZWdvYXRzKHJldnMsIGNvbW1pdCwgc2ItPnJldmVyc2UpOwoJaWYgKCFudW1fc2cpCgkJZ290byBmaW5pc2g7CgllbHNlIGlmIChudW1fc2cgPCBBUlJBWV9TSVpFKHNnX2J1ZikpCgkJbWVtc2V0KHNnX2J1ZiwgMCwgc2l6ZW9mKHNnX2J1ZikpOwoJZWxzZQoJCXNnX29yaWdpbiA9IHhjYWxsb2MobnVtX3NnLCBzaXplb2YoKnNnX29yaWdpbikpOwoKCS8qCgkgKiBUaGUgZmlyc3QgcGFzcyBsb29rcyBmb3IgdW5yZW5hbWVkIHBhdGggdG8gb3B0aW1pemUgZm9yCgkgKiBjb21tb24gY2FzZXMsIHRoZW4gd2UgbG9vayBmb3IgcmVuYW1lcyBpbiB0aGUgc2Vjb25kIHBhc3MuCgkgKi8KCWZvciAocGFzcyA9IDA7IHBhc3MgPCAyIC0gc2ItPm5vX3dob2xlX2ZpbGVfcmVuYW1lOyBwYXNzKyspIHsKCQlzdHJ1Y3QgYmxhbWVfb3JpZ2luICooKmZpbmQpKHN0cnVjdCBjb21taXQgKiwgc3RydWN0IGJsYW1lX29yaWdpbiAqKTsKCQlmaW5kID0gcGFzcyA/IGZpbmRfcmVuYW1lIDogZmluZF9vcmlnaW47CgoJCWZvciAoaSA9IDAsIHNnID0gZmlyc3Rfc2NhcGVnb2F0KHJldnMsIGNvbW1pdCwgc2ItPnJldmVyc2UpOwoJCSAgICAgaSA8IG51bV9zZyAmJiBzZzsKCQkgICAgIHNnID0gc2ctPm5leHQsIGkrKykgewoJCQlzdHJ1Y3QgY29tbWl0ICpwID0gc2ctPml0ZW07CgkJCWludCBqLCBzYW1lOwoKCQkJaWYgKHNnX29yaWdpbltpXSkKCQkJCWNvbnRpbnVlOwoJCQlpZiAocGFyc2VfY29tbWl0KHApKQoJCQkJY29udGludWU7CgkJCXBvcmlnaW4gPSBmaW5kKHAsIG9yaWdpbik7CgkJCWlmICghcG9yaWdpbikKCQkJCWNvbnRpbnVlOwoJCQlpZiAoIW9pZGNtcCgmcG9yaWdpbi0+YmxvYl9vaWQsICZvcmlnaW4tPmJsb2Jfb2lkKSkgewoJCQkJcGFzc193aG9sZV9ibGFtZShzYiwgb3JpZ2luLCBwb3JpZ2luKTsKCQkJCWJsYW1lX29yaWdpbl9kZWNyZWYocG9yaWdpbik7CgkJCQlnb3RvIGZpbmlzaDsKCQkJfQoJCQlmb3IgKGogPSBzYW1lID0gMDsgaiA8IGk7IGorKykKCQkJCWlmIChzZ19vcmlnaW5bal0gJiYKCQkJCSAgICAhb2lkY21wKCZzZ19vcmlnaW5bal0tPmJsb2Jfb2lkLCAmcG9yaWdpbi0+YmxvYl9vaWQpKSB7CgkJCQkJc2FtZSA9IDE7CgkJCQkJYnJlYWs7CgkJCQl9CgkJCWlmICghc2FtZSkKCQkJCXNnX29yaWdpbltpXSA9IHBvcmlnaW47CgkJCWVsc2UKCQkJCWJsYW1lX29yaWdpbl9kZWNyZWYocG9yaWdpbik7CgkJfQoJfQoKCXNiLT5udW1fY29tbWl0cysrOwoJZm9yIChpID0gMCwgc2cgPSBmaXJzdF9zY2FwZWdvYXQocmV2cywgY29tbWl0LCBzYi0+cmV2ZXJzZSk7CgkgICAgIGkgPCBudW1fc2cgJiYgc2c7CgkgICAgIHNnID0gc2ctPm5leHQsIGkrKykgewoJCXN0cnVjdCBibGFtZV9vcmlnaW4gKnBvcmlnaW4gPSBzZ19vcmlnaW5baV07CgkJaWYgKCFwb3JpZ2luKQoJCQljb250aW51ZTsKCQlpZiAoIW9yaWdpbi0+cHJldmlvdXMpIHsKCQkJYmxhbWVfb3JpZ2luX2luY3JlZihwb3JpZ2luKTsKCQkJb3JpZ2luLT5wcmV2aW91cyA9IHBvcmlnaW47CgkJfQoJCXBhc3NfYmxhbWVfdG9fcGFyZW50KHNiLCBvcmlnaW4sIHBvcmlnaW4pOwoJCWlmICghb3JpZ2luLT5zdXNwZWN0cykKCQkJZ290byBmaW5pc2g7Cgl9CgoJLyoKCSAqIE9wdGlvbmFsbHkgZmluZCBtb3ZlcyBpbiBwYXJlbnRzJyBmaWxlcy4KCSAqLwoJaWYgKG9wdCAmIFBJQ0tBWEVfQkxBTUVfTU9WRSkgewoJCWZpbHRlcl9zbWFsbChzYiwgJnRvb3NtYWxsLCAmb3JpZ2luLT5zdXNwZWN0cywgc2ItPm1vdmVfc2NvcmUpOwoJCWlmIChvcmlnaW4tPnN1c3BlY3RzKSB7CgkJCWZvciAoaSA9IDAsIHNnID0gZmlyc3Rfc2NhcGVnb2F0KHJldnMsIGNvbW1pdCwgc2ItPnJldmVyc2UpOwoJCQkgICAgIGkgPCBudW1fc2cgJiYgc2c7CgkJCSAgICAgc2cgPSBzZy0+bmV4dCwgaSsrKSB7CgkJCQlzdHJ1Y3QgYmxhbWVfb3JpZ2luICpwb3JpZ2luID0gc2dfb3JpZ2luW2ldOwoJCQkJaWYgKCFwb3JpZ2luKQoJCQkJCWNvbnRpbnVlOwoJCQkJZmluZF9tb3ZlX2luX3BhcmVudChzYiwgJmJsYW1ldGFpbCwgJnRvb3NtYWxsLCBvcmlnaW4sIHBvcmlnaW4pOwoJCQkJaWYgKCFvcmlnaW4tPnN1c3BlY3RzKQoJCQkJCWJyZWFrOwoJCQl9CgkJfQoJfQoKCS8qCgkgKiBPcHRpb25hbGx5IGZpbmQgY29waWVzIGZyb20gcGFyZW50cycgZmlsZXMuCgkgKi8KCWlmIChvcHQgJiBQSUNLQVhFX0JMQU1FX0NPUFkpIHsKCQlpZiAoc2ItPmNvcHlfc2NvcmUgPiBzYi0+bW92ZV9zY29yZSkKCQkJZmlsdGVyX3NtYWxsKHNiLCAmdG9vc21hbGwsICZvcmlnaW4tPnN1c3BlY3RzLCBzYi0+Y29weV9zY29yZSk7CgkJZWxzZSBpZiAoc2ItPmNvcHlfc2NvcmUgPCBzYi0+bW92ZV9zY29yZSkgewoJCQlvcmlnaW4tPnN1c3BlY3RzID0gYmxhbWVfbWVyZ2Uob3JpZ2luLT5zdXNwZWN0cywgdG9vc21hbGwpOwoJCQl0b29zbWFsbCA9IE5VTEw7CgkJCWZpbHRlcl9zbWFsbChzYiwgJnRvb3NtYWxsLCAmb3JpZ2luLT5zdXNwZWN0cywgc2ItPmNvcHlfc2NvcmUpOwoJCX0KCQlpZiAoIW9yaWdpbi0+c3VzcGVjdHMpCgkJCWdvdG8gZmluaXNoOwoKCQlmb3IgKGkgPSAwLCBzZyA9IGZpcnN0X3NjYXBlZ29hdChyZXZzLCBjb21taXQsIHNiLT5yZXZlcnNlKTsKCQkgICAgIGkgPCBudW1fc2cgJiYgc2c7CgkJICAgICBzZyA9IHNnLT5uZXh0LCBpKyspIHsKCQkJc3RydWN0IGJsYW1lX29yaWdpbiAqcG9yaWdpbiA9IHNnX29yaWdpbltpXTsKCQkJZmluZF9jb3B5X2luX3BhcmVudChzYiwgJmJsYW1ldGFpbCwgJnRvb3NtYWxsLAoJCQkJCSAgICBvcmlnaW4sIHNnLT5pdGVtLCBwb3JpZ2luLCBvcHQpOwoJCQlpZiAoIW9yaWdpbi0+c3VzcGVjdHMpCgkJCQlnb3RvIGZpbmlzaDsKCQl9Cgl9CgpmaW5pc2g6CgkqYmxhbWV0YWlsID0gTlVMTDsKCWRpc3RyaWJ1dGVfYmxhbWUoc2IsIGJsYW1lcyk7CgkvKgoJICogcHJlcGVuZCB0b29zbWFsbCB0byBvcmlnaW4tPnN1c3BlY3RzCgkgKgoJICogVGhlcmUgaXMgbm8gcG9pbnQgaW4gc29ydGluZzogdGhpcyBlbmRzIHVwIG9uIGEgYmlnCgkgKiB1bnNvcnRlZCBsaXN0IGluIHRoZSBjYWxsZXIgYW55d2F5LgoJICovCglpZiAodG9vc21hbGwpIHsKCQlzdHJ1Y3QgYmxhbWVfZW50cnkgKip0YWlsID0gJnRvb3NtYWxsOwoJCXdoaWxlICgqdGFpbCkKCQkJdGFpbCA9ICYoKnRhaWwpLT5uZXh0OwoJCSp0YWlsID0gb3JpZ2luLT5zdXNwZWN0czsKCQlvcmlnaW4tPnN1c3BlY3RzID0gdG9vc21hbGw7Cgl9Cglmb3IgKGkgPSAwOyBpIDwgbnVtX3NnOyBpKyspIHsKCQlpZiAoc2dfb3JpZ2luW2ldKSB7CgkJCWRyb3Bfb3JpZ2luX2Jsb2Ioc2dfb3JpZ2luW2ldKTsKCQkJYmxhbWVfb3JpZ2luX2RlY3JlZihzZ19vcmlnaW5baV0pOwoJCX0KCX0KCWRyb3Bfb3JpZ2luX2Jsb2Iob3JpZ2luKTsKCWlmIChzZ19idWYgIT0gc2dfb3JpZ2luKQoJCWZyZWUoc2dfb3JpZ2luKTsKfQoKLyoKICogVGhlIG1haW4gbG9vcCAtLSB3aGlsZSB3ZSBoYXZlIGJsb2JzIHdpdGggbGluZXMgd2hvc2UgdHJ1ZSBvcmlnaW4KICogaXMgc3RpbGwgdW5rbm93biwgcGljayBvbmUgYmxvYiwgYW5kIGFsbG93IGl0cyBsaW5lcyB0byBwYXNzIGJsYW1lcwogKiB0byBpdHMgcGFyZW50cy4gKi8Kdm9pZCBhc3NpZ25fYmxhbWUoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLCBpbnQgb3B0KQp7CglzdHJ1Y3QgcmV2X2luZm8gKnJldnMgPSBzYi0+cmV2czsKCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IHByaW9fcXVldWVfZ2V0KCZzYi0+Y29tbWl0cyk7CgoJd2hpbGUgKGNvbW1pdCkgewoJCXN0cnVjdCBibGFtZV9lbnRyeSAqZW50OwoJCXN0cnVjdCBibGFtZV9vcmlnaW4gKnN1c3BlY3QgPSBjb21taXQtPnV0aWw7CgoJCS8qIGZpbmQgb25lIHN1c3BlY3QgdG8gYnJlYWsgZG93biAqLwoJCXdoaWxlIChzdXNwZWN0ICYmICFzdXNwZWN0LT5zdXNwZWN0cykKCQkJc3VzcGVjdCA9IHN1c3BlY3QtPm5leHQ7CgoJCWlmICghc3VzcGVjdCkgewoJCQljb21taXQgPSBwcmlvX3F1ZXVlX2dldCgmc2ItPmNvbW1pdHMpOwoJCQljb250aW51ZTsKCQl9CgoJCWFzc2VydChjb21taXQgPT0gc3VzcGVjdC0+Y29tbWl0KTsKCgkJLyoKCQkgKiBXZSB3aWxsIHVzZSB0aGlzIHN1c3BlY3QgbGF0ZXIgaW4gdGhlIGxvb3AsCgkJICogc28gaG9sZCBvbnRvIGl0IGluIHRoZSBtZWFudGltZS4KCQkgKi8KCQlibGFtZV9vcmlnaW5faW5jcmVmKHN1c3BlY3QpOwoJCXBhcnNlX2NvbW1pdChjb21taXQpOwoJCWlmIChzYi0+cmV2ZXJzZSB8fAoJCSAgICAoIShjb21taXQtPm9iamVjdC5mbGFncyAmIFVOSU5URVJFU1RJTkcpICYmCgkJICAgICAhKHJldnMtPm1heF9hZ2UgIT0gLTEgJiYgY29tbWl0LT5kYXRlIDwgcmV2cy0+bWF4X2FnZSkpKQoJCQlwYXNzX2JsYW1lKHNiLCBzdXNwZWN0LCBvcHQpOwoJCWVsc2UgewoJCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBVTklOVEVSRVNUSU5HOwoJCQlpZiAoY29tbWl0LT5vYmplY3QucGFyc2VkKQoJCQkJbWFya19wYXJlbnRzX3VuaW50ZXJlc3RpbmcoY29tbWl0KTsKCQl9CgkJLyogdHJlYXQgcm9vdCBjb21taXQgYXMgYm91bmRhcnkgKi8KCQlpZiAoIWNvbW1pdC0+cGFyZW50cyAmJiAhc2ItPnNob3dfcm9vdCkKCQkJY29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gVU5JTlRFUkVTVElORzsKCgkJLyogVGFrZSByZXNwb25zaWJpbGl0eSBmb3IgdGhlIHJlbWFpbmluZyBlbnRyaWVzICovCgkJZW50ID0gc3VzcGVjdC0+c3VzcGVjdHM7CgkJaWYgKGVudCkgewoJCQlzdXNwZWN0LT5ndWlsdHkgPSAxOwoJCQlmb3IgKDs7KSB7CgkJCQlzdHJ1Y3QgYmxhbWVfZW50cnkgKm5leHQgPSBlbnQtPm5leHQ7CgkJCQlpZiAoc2ItPmZvdW5kX2d1aWx0eV9lbnRyeSkKCQkJCQlzYi0+Zm91bmRfZ3VpbHR5X2VudHJ5KGVudCwgc2ItPmZvdW5kX2d1aWx0eV9lbnRyeV9kYXRhKTsKCQkJCWlmIChuZXh0KSB7CgkJCQkJZW50ID0gbmV4dDsKCQkJCQljb250aW51ZTsKCQkJCX0KCQkJCWVudC0+bmV4dCA9IHNiLT5lbnQ7CgkJCQlzYi0+ZW50ID0gc3VzcGVjdC0+c3VzcGVjdHM7CgkJCQlzdXNwZWN0LT5zdXNwZWN0cyA9IE5VTEw7CgkJCQlicmVhazsKCQkJfQoJCX0KCQlibGFtZV9vcmlnaW5fZGVjcmVmKHN1c3BlY3QpOwoKCQlpZiAoc2ItPmRlYnVnKSAvKiBzYW5pdHkgKi8KCQkJc2FuaXR5X2NoZWNrX3JlZmNudChzYik7Cgl9Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpnZXRfbmV4dF9saW5lKGNvbnN0IGNoYXIgKnN0YXJ0LCBjb25zdCBjaGFyICplbmQpCnsKCWNvbnN0IGNoYXIgKm5sID0gbWVtY2hyKHN0YXJ0LCAnXG4nLCBlbmQgLSBzdGFydCk7CglyZXR1cm4gbmwgPyBubCArIDEgOiBlbmQ7Cn0KCi8qCiAqIFRvIGFsbG93IHF1aWNrIGFjY2VzcyB0byB0aGUgY29udGVudHMgb2YgbnRoIGxpbmUgaW4gdGhlCiAqIGZpbmFsIGltYWdlLCBwcmVwYXJlIGFuIGluZGV4IGluIHRoZSBzY29yZWJvYXJkLgogKi8Kc3RhdGljIGludCBwcmVwYXJlX2xpbmVzKHN0cnVjdCBibGFtZV9zY29yZWJvYXJkICpzYikKewoJY29uc3QgY2hhciAqYnVmID0gc2ItPmZpbmFsX2J1ZjsKCXVuc2lnbmVkIGxvbmcgbGVuID0gc2ItPmZpbmFsX2J1Zl9zaXplOwoJY29uc3QgY2hhciAqZW5kID0gYnVmICsgbGVuOwoJY29uc3QgY2hhciAqcDsKCWludCAqbGluZW5vOwoJaW50IG51bSA9IDA7CgoJZm9yIChwID0gYnVmOyBwIDwgZW5kOyBwID0gZ2V0X25leHRfbGluZShwLCBlbmQpKQoJCW51bSsrOwoKCUFMTE9DX0FSUkFZKHNiLT5saW5lbm8sIG51bSArIDEpOwoJbGluZW5vID0gc2ItPmxpbmVubzsKCglmb3IgKHAgPSBidWY7IHAgPCBlbmQ7IHAgPSBnZXRfbmV4dF9saW5lKHAsIGVuZCkpCgkJKmxpbmVubysrID0gcCAtIGJ1ZjsKCgkqbGluZW5vID0gbGVuOwoKCXNiLT5udW1fbGluZXMgPSBudW07CglyZXR1cm4gc2ItPm51bV9saW5lczsKfQoKc3RhdGljIHN0cnVjdCBjb21taXQgKmZpbmRfc2luZ2xlX2ZpbmFsKHN0cnVjdCByZXZfaW5mbyAqcmV2cywKCQkJCQljb25zdCBjaGFyICoqbmFtZV9wKQp7CglpbnQgaTsKCXN0cnVjdCBjb21taXQgKmZvdW5kID0gTlVMTDsKCWNvbnN0IGNoYXIgKm5hbWUgPSBOVUxMOwoKCWZvciAoaSA9IDA7IGkgPCByZXZzLT5wZW5kaW5nLm5yOyBpKyspIHsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmogPSByZXZzLT5wZW5kaW5nLm9iamVjdHNbaV0uaXRlbTsKCQlpZiAob2JqLT5mbGFncyAmIFVOSU5URVJFU1RJTkcpCgkJCWNvbnRpbnVlOwoJCW9iaiA9IGRlcmVmX3RhZyhvYmosIE5VTEwsIDApOwoJCWlmIChvYmotPnR5cGUgIT0gT0JKX0NPTU1JVCkKCQkJZGllKCJOb24gY29tbWl0ICVzPyIsIHJldnMtPnBlbmRpbmcub2JqZWN0c1tpXS5uYW1lKTsKCQlpZiAoZm91bmQpCgkJCWRpZSgiTW9yZSB0aGFuIG9uZSBjb21taXQgdG8gZGlnIGZyb20gJXMgYW5kICVzPyIsCgkJCSAgICByZXZzLT5wZW5kaW5nLm9iamVjdHNbaV0ubmFtZSwgbmFtZSk7CgkJZm91bmQgPSAoc3RydWN0IGNvbW1pdCAqKW9iajsKCQluYW1lID0gcmV2cy0+cGVuZGluZy5vYmplY3RzW2ldLm5hbWU7Cgl9CglpZiAobmFtZV9wKQoJCSpuYW1lX3AgPSB4c3RyZHVwX29yX251bGwobmFtZSk7CglyZXR1cm4gZm91bmQ7Cn0KCnN0YXRpYyBzdHJ1Y3QgY29tbWl0ICpkd2ltX3JldmVyc2VfaW5pdGlhbChzdHJ1Y3QgcmV2X2luZm8gKnJldnMsCgkJCQkJICAgY29uc3QgY2hhciAqKm5hbWVfcCkKewoJLyoKCSAqIERXSU0gImdpdCBibGFtZSAtLXJldmVyc2UgT05FIC0tIFBBVEgiIGFzCgkgKiAiZ2l0IGJsYW1lIC0tcmV2ZXJzZSBPTkUuLkhFQUQgLS0gUEFUSCIgYnV0IG9ubHkgZG8gc28KCSAqIHdoZW4gaXQgbWFrZXMgc2Vuc2UuCgkgKi8KCXN0cnVjdCBvYmplY3QgKm9iajsKCXN0cnVjdCBjb21taXQgKmhlYWRfY29tbWl0OwoJc3RydWN0IG9iamVjdF9pZCBoZWFkX29pZDsKCglpZiAocmV2cy0+cGVuZGluZy5uciAhPSAxKQoJCXJldHVybiBOVUxMOwoKCS8qIElzIHRoYXQgc29sZSByZXYgYSBjb21taXR0aXNoPyAqLwoJb2JqID0gcmV2cy0+cGVuZGluZy5vYmplY3RzWzBdLml0ZW07CglvYmogPSBkZXJlZl90YWcob2JqLCBOVUxMLCAwKTsKCWlmIChvYmotPnR5cGUgIT0gT0JKX0NPTU1JVCkKCQlyZXR1cm4gTlVMTDsKCgkvKiBEbyB3ZSBoYXZlIEhFQUQ/ICovCglpZiAoIXJlc29sdmVfcmVmX3Vuc2FmZSgiSEVBRCIsIFJFU09MVkVfUkVGX1JFQURJTkcsICZoZWFkX29pZCwgTlVMTCkpCgkJcmV0dXJuIE5VTEw7CgloZWFkX2NvbW1pdCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseSgmaGVhZF9vaWQsIDEpOwoJaWYgKCFoZWFkX2NvbW1pdCkKCQlyZXR1cm4gTlVMTDsKCgkvKiBUdXJuICJPTkUiIGludG8gIk9ORS4uSEVBRCIgdGhlbiAqLwoJb2JqLT5mbGFncyB8PSBVTklOVEVSRVNUSU5HOwoJYWRkX3BlbmRpbmdfb2JqZWN0KHJldnMsICZoZWFkX2NvbW1pdC0+b2JqZWN0LCAiSEVBRCIpOwoKCWlmIChuYW1lX3ApCgkJKm5hbWVfcCA9IHJldnMtPnBlbmRpbmcub2JqZWN0c1swXS5uYW1lOwoJcmV0dXJuIChzdHJ1Y3QgY29tbWl0ICopb2JqOwp9CgpzdGF0aWMgc3RydWN0IGNvbW1pdCAqZmluZF9zaW5nbGVfaW5pdGlhbChzdHJ1Y3QgcmV2X2luZm8gKnJldnMsCgkJCQkJICBjb25zdCBjaGFyICoqbmFtZV9wKQp7CglpbnQgaTsKCXN0cnVjdCBjb21taXQgKmZvdW5kID0gTlVMTDsKCWNvbnN0IGNoYXIgKm5hbWUgPSBOVUxMOwoKCS8qCgkgKiBUaGVyZSBtdXN0IGJlIG9uZSBhbmQgb25seSBvbmUgbmVnYXRpdmUgY29tbWl0LCBhbmQgaXQgbXVzdCBiZQoJICogdGhlIGJvdW5kYXJ5LgoJICovCglmb3IgKGkgPSAwOyBpIDwgcmV2cy0+cGVuZGluZy5ucjsgaSsrKSB7CgkJc3RydWN0IG9iamVjdCAqb2JqID0gcmV2cy0+cGVuZGluZy5vYmplY3RzW2ldLml0ZW07CgkJaWYgKCEob2JqLT5mbGFncyAmIFVOSU5URVJFU1RJTkcpKQoJCQljb250aW51ZTsKCQlvYmogPSBkZXJlZl90YWcob2JqLCBOVUxMLCAwKTsKCQlpZiAob2JqLT50eXBlICE9IE9CSl9DT01NSVQpCgkJCWRpZSgiTm9uIGNvbW1pdCAlcz8iLCByZXZzLT5wZW5kaW5nLm9iamVjdHNbaV0ubmFtZSk7CgkJaWYgKGZvdW5kKQoJCQlkaWUoIk1vcmUgdGhhbiBvbmUgY29tbWl0IHRvIGRpZyB1cCBmcm9tLCAlcyBhbmQgJXM/IiwKCQkJICAgIHJldnMtPnBlbmRpbmcub2JqZWN0c1tpXS5uYW1lLCBuYW1lKTsKCQlmb3VuZCA9IChzdHJ1Y3QgY29tbWl0ICopIG9iajsKCQluYW1lID0gcmV2cy0+cGVuZGluZy5vYmplY3RzW2ldLm5hbWU7Cgl9CgoJaWYgKCFuYW1lKQoJCWZvdW5kID0gZHdpbV9yZXZlcnNlX2luaXRpYWwocmV2cywgJm5hbWUpOwoJaWYgKCFuYW1lKQoJCWRpZSgiTm8gY29tbWl0IHRvIGRpZyB1cCBmcm9tPyIpOwoKCWlmIChuYW1lX3ApCgkJKm5hbWVfcCA9IHhzdHJkdXAobmFtZSk7CglyZXR1cm4gZm91bmQ7Cn0KCnZvaWQgaW5pdF9zY29yZWJvYXJkKHN0cnVjdCBibGFtZV9zY29yZWJvYXJkICpzYikKewoJbWVtc2V0KHNiLCAwLCBzaXplb2Yoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQpKTsKCXNiLT5tb3ZlX3Njb3JlID0gQkxBTUVfREVGQVVMVF9NT1ZFX1NDT1JFOwoJc2ItPmNvcHlfc2NvcmUgPSBCTEFNRV9ERUZBVUxUX0NPUFlfU0NPUkU7Cn0KCnZvaWQgc2V0dXBfc2NvcmVib2FyZChzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCAqc2IsIGNvbnN0IGNoYXIgKnBhdGgsIHN0cnVjdCBibGFtZV9vcmlnaW4gKipvcmlnKQp7Cgljb25zdCBjaGFyICpmaW5hbF9jb21taXRfbmFtZSA9IE5VTEw7CglzdHJ1Y3QgYmxhbWVfb3JpZ2luICpvOwoJc3RydWN0IGNvbW1pdCAqZmluYWxfY29tbWl0ID0gTlVMTDsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCglpZiAoc2ItPnJldmVyc2UgJiYgc2ItPmNvbnRlbnRzX2Zyb20pCgkJZGllKF8oIi0tY29udGVudHMgYW5kIC0tcmV2ZXJzZSBkbyBub3QgYmxlbmQgd2VsbC4iKSk7CgoJaWYgKCFzYi0+cmV2ZXJzZSkgewoJCXNiLT5maW5hbCA9IGZpbmRfc2luZ2xlX2ZpbmFsKHNiLT5yZXZzLCAmZmluYWxfY29tbWl0X25hbWUpOwoJCXNiLT5jb21taXRzLmNvbXBhcmUgPSBjb21wYXJlX2NvbW1pdHNfYnlfY29tbWl0X2RhdGU7Cgl9IGVsc2UgewoJCXNiLT5maW5hbCA9IGZpbmRfc2luZ2xlX2luaXRpYWwoc2ItPnJldnMsICZmaW5hbF9jb21taXRfbmFtZSk7CgkJc2ItPmNvbW1pdHMuY29tcGFyZSA9IGNvbXBhcmVfY29tbWl0c19ieV9yZXZlcnNlX2NvbW1pdF9kYXRlOwoJfQoKCWlmIChzYi0+ZmluYWwgJiYgc2ItPmNvbnRlbnRzX2Zyb20pCgkJZGllKF8oImNhbm5vdCB1c2UgLS1jb250ZW50cyB3aXRoIGZpbmFsIGNvbW1pdCBvYmplY3QgbmFtZSIpKTsKCglpZiAoc2ItPnJldmVyc2UgJiYgc2ItPnJldnMtPmZpcnN0X3BhcmVudF9vbmx5KQoJCXNiLT5yZXZzLT5jaGlsZHJlbi5uYW1lID0gTlVMTDsKCglpZiAoIXNiLT5maW5hbCkgewoJCS8qCgkJICogIi0tbm90IEEgQiAtLSBwYXRoIiB3aXRob3V0IGFueXRoaW5nIHBvc2l0aXZlOwoJCSAqIGRvIG5vdCBkZWZhdWx0IHRvIEhFQUQsIGJ1dCB1c2UgdGhlIHdvcmtpbmcgdHJlZQoJCSAqIG9yICItLWNvbnRlbnRzIi4KCQkgKi8KCQlzZXR1cF93b3JrX3RyZWUoKTsKCQlzYi0+ZmluYWwgPSBmYWtlX3dvcmtpbmdfdHJlZV9jb21taXQoJnNiLT5yZXZzLT5kaWZmb3B0LAoJCQkJCQkgICAgIHBhdGgsIHNiLT5jb250ZW50c19mcm9tKTsKCQlhZGRfcGVuZGluZ19vYmplY3Qoc2ItPnJldnMsICYoc2ItPmZpbmFsLT5vYmplY3QpLCAiOiIpOwoJfQoKCWlmIChzYi0+cmV2ZXJzZSAmJiBzYi0+cmV2cy0+Zmlyc3RfcGFyZW50X29ubHkpIHsKCQlmaW5hbF9jb21taXQgPSBmaW5kX3NpbmdsZV9maW5hbChzYi0+cmV2cywgTlVMTCk7CgkJaWYgKCFmaW5hbF9jb21taXQpCgkJCWRpZShfKCItLXJldmVyc2UgYW5kIC0tZmlyc3QtcGFyZW50IHRvZ2V0aGVyIHJlcXVpcmUgc3BlY2lmaWVkIGxhdGVzdCBjb21taXQiKSk7Cgl9CgoJLyoKCSAqIElmIHdlIGhhdmUgYm90dG9tLCB0aGlzIHdpbGwgbWFyayB0aGUgYW5jZXN0b3JzIG9mIHRoZQoJICogYm90dG9tIGNvbW1pdHMgd2Ugd291bGQgcmVhY2ggd2hpbGUgdHJhdmVyc2luZyBhcwoJICogdW5pbnRlcmVzdGluZy4KCSAqLwoJaWYgKHByZXBhcmVfcmV2aXNpb25fd2FsayhzYi0+cmV2cykpCgkJZGllKF8oInJldmlzaW9uIHdhbGsgc2V0dXAgZmFpbGVkIikpOwoKCWlmIChzYi0+cmV2ZXJzZSAmJiBzYi0+cmV2cy0+Zmlyc3RfcGFyZW50X29ubHkpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjID0gZmluYWxfY29tbWl0OwoKCQlzYi0+cmV2cy0+Y2hpbGRyZW4ubmFtZSA9ICJjaGlsZHJlbiI7CgkJd2hpbGUgKGMtPnBhcmVudHMgJiYKCQkgICAgICAgb2lkY21wKCZjLT5vYmplY3Qub2lkLCAmc2ItPmZpbmFsLT5vYmplY3Qub2lkKSkgewoJCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKmwgPSB4Y2FsbG9jKDEsIHNpemVvZigqbCkpOwoKCQkJbC0+aXRlbSA9IGM7CgkJCWlmIChhZGRfZGVjb3JhdGlvbigmc2ItPnJldnMtPmNoaWxkcmVuLAoJCQkJCSAgICZjLT5wYXJlbnRzLT5pdGVtLT5vYmplY3QsIGwpKQoJCQkJZGllKCJCVUc6IG5vdCB1bmlxdWUgaXRlbSBpbiBmaXJzdC1wYXJlbnQgY2hhaW4iKTsKCQkJYyA9IGMtPnBhcmVudHMtPml0ZW07CgkJfQoKCQlpZiAob2lkY21wKCZjLT5vYmplY3Qub2lkLCAmc2ItPmZpbmFsLT5vYmplY3Qub2lkKSkKCQkJZGllKF8oIi0tcmV2ZXJzZSAtLWZpcnN0LXBhcmVudCB0b2dldGhlciByZXF1aXJlIHJhbmdlIGFsb25nIGZpcnN0LXBhcmVudCBjaGFpbiIpKTsKCX0KCglpZiAoaXNfbnVsbF9vaWQoJnNiLT5maW5hbC0+b2JqZWN0Lm9pZCkpIHsKCQlvID0gc2ItPmZpbmFsLT51dGlsOwoJCXNiLT5maW5hbF9idWYgPSB4bWVtZHVweihvLT5maWxlLnB0ciwgby0+ZmlsZS5zaXplKTsKCQlzYi0+ZmluYWxfYnVmX3NpemUgPSBvLT5maWxlLnNpemU7Cgl9CgllbHNlIHsKCQlvID0gZ2V0X29yaWdpbihzYi0+ZmluYWwsIHBhdGgpOwoJCWlmIChmaWxsX2Jsb2Jfc2hhMV9hbmRfbW9kZShvKSkKCQkJZGllKF8oIm5vIHN1Y2ggcGF0aCAlcyBpbiAlcyIpLCBwYXRoLCBmaW5hbF9jb21taXRfbmFtZSk7CgoJCWlmIChzYi0+cmV2cy0+ZGlmZm9wdC5mbGFncy5hbGxvd190ZXh0Y29udiAmJgoJCSAgICB0ZXh0Y29udl9vYmplY3QocGF0aCwgby0+bW9kZSwgJm8tPmJsb2Jfb2lkLCAxLCAoY2hhciAqKikgJnNiLT5maW5hbF9idWYsCgkJCQkgICAgJnNiLT5maW5hbF9idWZfc2l6ZSkpCgkJCTsKCQllbHNlCgkJCXNiLT5maW5hbF9idWYgPSByZWFkX3NoYTFfZmlsZShvLT5ibG9iX29pZC5oYXNoLCAmdHlwZSwKCQkJCQkJICAgICAgICZzYi0+ZmluYWxfYnVmX3NpemUpOwoKCQlpZiAoIXNiLT5maW5hbF9idWYpCgkJCWRpZShfKCJjYW5ub3QgcmVhZCBibG9iICVzIGZvciBwYXRoICVzIiksCgkJCSAgICBvaWRfdG9faGV4KCZvLT5ibG9iX29pZCksCgkJCSAgICBwYXRoKTsKCX0KCXNiLT5udW1fcmVhZF9ibG9iKys7CglwcmVwYXJlX2xpbmVzKHNiKTsKCglpZiAob3JpZykKCQkqb3JpZyA9IG87CgoJZnJlZSgoY2hhciAqKWZpbmFsX2NvbW1pdF9uYW1lKTsKfQoKCgpzdHJ1Y3QgYmxhbWVfZW50cnkgKmJsYW1lX2VudHJ5X3ByZXBlbmQoc3RydWN0IGJsYW1lX2VudHJ5ICpoZWFkLAoJCQkJCWxvbmcgc3RhcnQsIGxvbmcgZW5kLAoJCQkJCXN0cnVjdCBibGFtZV9vcmlnaW4gKm8pCnsKCXN0cnVjdCBibGFtZV9lbnRyeSAqbmV3X2hlYWQgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3QgYmxhbWVfZW50cnkpKTsKCW5ld19oZWFkLT5sbm8gPSBzdGFydDsKCW5ld19oZWFkLT5udW1fbGluZXMgPSBlbmQgLSBzdGFydDsKCW5ld19oZWFkLT5zdXNwZWN0ID0gbzsKCW5ld19oZWFkLT5zX2xubyA9IHN0YXJ0OwoJbmV3X2hlYWQtPm5leHQgPSBoZWFkOwoJYmxhbWVfb3JpZ2luX2luY3JlZihvKTsKCXJldHVybiBuZXdfaGVhZDsKfQo=",
    "text": "#include \"cache.h\"\n#include \"refs.h\"\n#include \"cache-tree.h\"\n#include \"mergesort.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"tag.h\"\n#include \"blame.h\"\n\nvoid blame_origin_decref(struct blame_origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tstruct blame_origin *p, *l = NULL;\n\t\tif (o->previous)\n\t\t\tblame_origin_decref(o->previous);\n\t\tfree(o->file.ptr);\n\t\t/* Should be present exactly once in commit chain */\n\t\tfor (p = o->commit->util; p; l = p, p = p->next) {\n\t\t\tif (p == o) {\n\t\t\t\tif (l)\n\t\t\t\t\tl->next = p->next;\n\t\t\t\telse\n\t\t\t\t\to->commit->util = p->next;\n\t\t\t\tfree(o);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdie(\"internal error in blame_origin_decref\");\n\t}\n}\n\n/*\n * Given a commit and a path in it, create a new origin structure.\n * The callers that add blame to the scoreboard should use\n * get_origin() to obtain shared, refcounted copy instead of calling\n * this function directly.\n */\nstatic struct blame_origin *make_origin(struct commit *commit, const char *path)\n{\n\tstruct blame_origin *o;\n\tFLEX_ALLOC_STR(o, path, path);\n\to->commit = commit;\n\to->refcnt = 1;\n\to->next = commit->util;\n\tcommit->util = o;\n\treturn o;\n}\n\n/*\n * Locate an existing origin or create a new one.\n * This moves the origin to front position in the commit util list.\n */\nstatic struct blame_origin *get_origin(struct commit *commit, const char *path)\n{\n\tstruct blame_origin *o, *l;\n\n\tfor (o = commit->util, l = NULL; o; l = o, o = o->next) {\n\t\tif (!strcmp(o->path, path)) {\n\t\t\t/* bump to front */\n\t\t\tif (l) {\n\t\t\t\tl->next = o->next;\n\t\t\t\to->next = commit->util;\n\t\t\t\tcommit->util = o;\n\t\t\t}\n\t\t\treturn blame_origin_incref(o);\n\t\t}\n\t}\n\treturn make_origin(commit, path);\n}\n\n\n\nstatic void verify_working_tree_path(struct commit *work_tree, const char *path)\n{\n\tstruct commit_list *parents;\n\tint pos;\n\n\tfor (parents = work_tree->parents; parents; parents = parents->next) {\n\t\tconst struct object_id *commit_oid = &parents->item->object.oid;\n\t\tstruct object_id blob_oid;\n\t\tunsigned mode;\n\n\t\tif (!get_tree_entry(commit_oid->hash, path, blob_oid.hash, &mode) &&\n\t\t    oid_object_info(&blob_oid, NULL) == OBJ_BLOB)\n\t\t\treturn;\n\t}\n\n\tpos = cache_name_pos(path, strlen(path));\n\tif (pos >= 0)\n\t\t; /* path is in the index */\n\telse if (-1 - pos < active_nr &&\n\t\t !strcmp(active_cache[-1 - pos]->name, path))\n\t\t; /* path is in the index, unmerged */\n\telse\n\t\tdie(\"no such path '%s' in HEAD\", path);\n}\n\nstatic struct commit_list **append_parent(struct commit_list **tail, const struct object_id *oid)\n{\n\tstruct commit *parent;\n\n\tparent = lookup_commit_reference(oid);\n\tif (!parent)\n\t\tdie(\"no such commit %s\", oid_to_hex(oid));\n\treturn &commit_list_insert(parent, tail)->next;\n}\n\nstatic void append_merge_parents(struct commit_list **tail)\n{\n\tint merge_head;\n\tstruct strbuf line = STRBUF_INIT;\n\n\tmerge_head = open(git_path_merge_head(), O_RDONLY);\n\tif (merge_head < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn;\n\t\tdie(\"cannot open '%s' for reading\", git_path_merge_head());\n\t}\n\n\twhile (!strbuf_getwholeline_fd(&line, merge_head, '\\n')) {\n\t\tstruct object_id oid;\n\t\tif (line.len < GIT_SHA1_HEXSZ || get_oid_hex(line.buf, &oid))\n\t\t\tdie(\"unknown line in '%s': %s\", git_path_merge_head(), line.buf);\n\t\ttail = append_parent(tail, &oid);\n\t}\n\tclose(merge_head);\n\tstrbuf_release(&line);\n}\n\n/*\n * This isn't as simple as passing sb->buf and sb->len, because we\n * want to transfer ownership of the buffer to the commit (so we\n * must use detach).\n */\nstatic void set_commit_buffer_from_strbuf(struct commit *c, struct strbuf *sb)\n{\n\tsize_t len;\n\tvoid *buf = strbuf_detach(sb, &len);\n\tset_commit_buffer(c, buf, len);\n}\n\n/*\n * Prepare a dummy commit that represents the work tree (or staged) item.\n * Note that annotating work tree item never works in the reverse.\n */\nstatic struct commit *fake_working_tree_commit(struct diff_options *opt,\n\t\t\t\t\t       const char *path,\n\t\t\t\t\t       const char *contents_from)\n{\n\tstruct commit *commit;\n\tstruct blame_origin *origin;\n\tstruct commit_list **parent_tail, *parent;\n\tstruct object_id head_oid;\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *ident;\n\ttime_t now;\n\tint size, len;\n\tstruct cache_entry *ce;\n\tunsigned mode;\n\tstruct strbuf msg = STRBUF_INIT;\n\n\tread_cache();\n\ttime(&now);\n\tcommit = alloc_commit_node();\n\tcommit->object.parsed = 1;\n\tcommit->date = now;\n\tparent_tail = &commit->parents;\n\n\tif (!resolve_ref_unsafe(\"HEAD\", RESOLVE_REF_READING, &head_oid, NULL))\n\t\tdie(\"no such ref: HEAD\");\n\n\tparent_tail = append_parent(parent_tail, &head_oid);\n\tappend_merge_parents(parent_tail);\n\tverify_working_tree_path(commit, path);\n\n\torigin = make_origin(commit, path);\n\n\tident = fmt_ident(\"Not Committed Yet\", \"not.committed.yet\", NULL, 0);\n\tstrbuf_addstr(&msg, \"tree 0000000000000000000000000000000000000000\\n\");\n\tfor (parent = commit->parents; parent; parent = parent->next)\n\t\tstrbuf_addf(&msg, \"parent %s\\n\",\n\t\t\t    oid_to_hex(&parent->item->object.oid));\n\tstrbuf_addf(&msg,\n\t\t    \"author %s\\n\"\n\t\t    \"committer %s\\n\\n\"\n\t\t    \"Version of %s from %s\\n\",\n\t\t    ident, ident, path,\n\t\t    (!contents_from ? path :\n\t\t     (!strcmp(contents_from, \"-\") ? \"standard input\" : contents_from)));\n\tset_commit_buffer_from_strbuf(commit, &msg);\n\n\tif (!contents_from || strcmp(\"-\", contents_from)) {\n\t\tstruct stat st;\n\t\tconst char *read_from;\n\t\tchar *buf_ptr;\n\t\tunsigned long buf_len;\n\n\t\tif (contents_from) {\n\t\t\tif (stat(contents_from, &st) < 0)\n\t\t\t\tdie_errno(\"Cannot stat '%s'\", contents_from);\n\t\t\tread_from = contents_from;\n\t\t}\n\t\telse {\n\t\t\tif (lstat(path, &st) < 0)\n\t\t\t\tdie_errno(\"Cannot lstat '%s'\", path);\n\t\t\tread_from = path;\n\t\t}\n\t\tmode = canon_mode(st.st_mode);\n\n\t\tswitch (st.st_mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tif (opt->flags.allow_textconv &&\n\t\t\t    textconv_object(read_from, mode, &null_oid, 0, &buf_ptr, &buf_len))\n\t\t\t\tstrbuf_attach(&buf, buf_ptr, buf_len, buf_len + 1);\n\t\t\telse if (strbuf_read_file(&buf, read_from, st.st_size) != st.st_size)\n\t\t\t\tdie_errno(\"cannot open or read '%s'\", read_from);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tif (strbuf_readlink(&buf, read_from, st.st_size) < 0)\n\t\t\t\tdie_errno(\"cannot readlink '%s'\", read_from);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdie(\"unsupported file type %s\", read_from);\n\t\t}\n\t}\n\telse {\n\t\t/* Reading from stdin */\n\t\tmode = 0;\n\t\tif (strbuf_read(&buf, 0, 0) < 0)\n\t\t\tdie_errno(\"failed to read from stdin\");\n\t}\n\tconvert_to_git(&the_index, path, buf.buf, buf.len, &buf, 0);\n\torigin->file.ptr = buf.buf;\n\torigin->file.size = buf.len;\n\tpretend_object_file(buf.buf, buf.len, OBJ_BLOB, &origin->blob_oid);\n\n\t/*\n\t * Read the current index, replace the path entry with\n\t * origin->blob_sha1 without mucking with its mode or type\n\t * bits; we are not going to write this index out -- we just\n\t * want to run \"diff-index --cached\".\n\t */\n\tdiscard_cache();\n\tread_cache();\n\n\tlen = strlen(path);\n\tif (!mode) {\n\t\tint pos = cache_name_pos(path, len);\n\t\tif (0 <= pos)\n\t\t\tmode = active_cache[pos]->ce_mode;\n\t\telse\n\t\t\t/* Let's not bother reading from HEAD tree */\n\t\t\tmode = S_IFREG | 0644;\n\t}\n\tsize = cache_entry_size(len);\n\tce = xcalloc(1, size);\n\toidcpy(&ce->oid, &origin->blob_oid);\n\tmemcpy(ce->name, path, len);\n\tce->ce_flags = create_ce_flags(0);\n\tce->ce_namelen = len;\n\tce->ce_mode = create_ce_mode(mode);\n\tadd_cache_entry(ce, ADD_CACHE_OK_TO_ADD|ADD_CACHE_OK_TO_REPLACE);\n\n\tcache_tree_invalidate_path(&the_index, path);\n\n\treturn commit;\n}\n\n\n\nstatic int diff_hunks(mmfile_t *file_a, mmfile_t *file_b,\n\t\t      xdl_emit_hunk_consume_func_t hunk_func, void *cb_data, int xdl_opts)\n{\n\txpparam_t xpp = {0};\n\txdemitconf_t xecfg = {0};\n\txdemitcb_t ecb = {NULL};\n\n\txpp.flags = xdl_opts;\n\txecfg.hunk_func = hunk_func;\n\tecb.priv = cb_data;\n\treturn xdi_diff(file_a, file_b, &xpp, &xecfg, &ecb);\n}\n\n/*\n * Given an origin, prepare mmfile_t structure to be used by the\n * diff machinery\n */\nstatic void fill_origin_blob(struct diff_options *opt,\n\t\t\t     struct blame_origin *o, mmfile_t *file, int *num_read_blob)\n{\n\tif (!o->file.ptr) {\n\t\tenum object_type type;\n\t\tunsigned long file_size;\n\n\t\t(*num_read_blob)++;\n\t\tif (opt->flags.allow_textconv &&\n\t\t    textconv_object(o->path, o->mode, &o->blob_oid, 1, &file->ptr, &file_size))\n\t\t\t;\n\t\telse\n\t\t\tfile->ptr = read_sha1_file(o->blob_oid.hash, &type,\n\t\t\t\t\t\t   &file_size);\n\t\tfile->size = file_size;\n\n\t\tif (!file->ptr)\n\t\t\tdie(\"Cannot read blob %s for path %s\",\n\t\t\t    oid_to_hex(&o->blob_oid),\n\t\t\t    o->path);\n\t\to->file = *file;\n\t}\n\telse\n\t\t*file = o->file;\n}\n\nstatic void drop_origin_blob(struct blame_origin *o)\n{\n\tif (o->file.ptr) {\n\t\tFREE_AND_NULL(o->file.ptr);\n\t}\n}\n\n/*\n * Any merge of blames happens on lists of blames that arrived via\n * different parents in a single suspect.  In this case, we want to\n * sort according to the suspect line numbers as opposed to the final\n * image line numbers.  The function body is somewhat longish because\n * it avoids unnecessary writes.\n */\n\nstatic struct blame_entry *blame_merge(struct blame_entry *list1,\n\t\t\t\t       struct blame_entry *list2)\n{\n\tstruct blame_entry *p1 = list1, *p2 = list2,\n\t\t**tail = &list1;\n\n\tif (!p1)\n\t\treturn p2;\n\tif (!p2)\n\t\treturn p1;\n\n\tif (p1->s_lno <= p2->s_lno) {\n\t\tdo {\n\t\t\ttail = &p1->next;\n\t\t\tif ((p1 = *tail) == NULL) {\n\t\t\t\t*tail = p2;\n\t\t\t\treturn list1;\n\t\t\t}\n\t\t} while (p1->s_lno <= p2->s_lno);\n\t}\n\tfor (;;) {\n\t\t*tail = p2;\n\t\tdo {\n\t\t\ttail = &p2->next;\n\t\t\tif ((p2 = *tail) == NULL)  {\n\t\t\t\t*tail = p1;\n\t\t\t\treturn list1;\n\t\t\t}\n\t\t} while (p1->s_lno > p2->s_lno);\n\t\t*tail = p1;\n\t\tdo {\n\t\t\ttail = &p1->next;\n\t\t\tif ((p1 = *tail) == NULL) {\n\t\t\t\t*tail = p2;\n\t\t\t\treturn list1;\n\t\t\t}\n\t\t} while (p1->s_lno <= p2->s_lno);\n\t}\n}\n\nstatic void *get_next_blame(const void *p)\n{\n\treturn ((struct blame_entry *)p)->next;\n}\n\nstatic void set_next_blame(void *p1, void *p2)\n{\n\t((struct blame_entry *)p1)->next = p2;\n}\n\n/*\n * Final image line numbers are all different, so we don't need a\n * three-way comparison here.\n */\n\nstatic int compare_blame_final(const void *p1, const void *p2)\n{\n\treturn ((struct blame_entry *)p1)->lno > ((struct blame_entry *)p2)->lno\n\t\t? 1 : -1;\n}\n\nstatic int compare_blame_suspect(const void *p1, const void *p2)\n{\n\tconst struct blame_entry *s1 = p1, *s2 = p2;\n\t/*\n\t * to allow for collating suspects, we sort according to the\n\t * respective pointer value as the primary sorting criterion.\n\t * The actual relation is pretty unimportant as long as it\n\t * establishes a total order.  Comparing as integers gives us\n\t * that.\n\t */\n\tif (s1->suspect != s2->suspect)\n\t\treturn (intptr_t)s1->suspect > (intptr_t)s2->suspect ? 1 : -1;\n\tif (s1->s_lno == s2->s_lno)\n\t\treturn 0;\n\treturn s1->s_lno > s2->s_lno ? 1 : -1;\n}\n\nvoid blame_sort_final(struct blame_scoreboard *sb)\n{\n\tsb->ent = llist_mergesort(sb->ent, get_next_blame, set_next_blame,\n\t\t\t\t  compare_blame_final);\n}\n\nstatic int compare_commits_by_reverse_commit_date(const void *a,\n\t\t\t\t\t\t  const void *b,\n\t\t\t\t\t\t  void *c)\n{\n\treturn -compare_commits_by_commit_date(a, b, c);\n}\n\n/*\n * For debugging -- origin is refcounted, and this asserts that\n * we do not underflow.\n */\nstatic void sanity_check_refcnt(struct blame_scoreboard *sb)\n{\n\tint baa = 0;\n\tstruct blame_entry *ent;\n\n\tfor (ent = sb->ent; ent; ent = ent->next) {\n\t\t/* Nobody should have zero or negative refcnt */\n\t\tif (ent->suspect->refcnt <= 0) {\n\t\t\tfprintf(stderr, \"%s in %s has negative refcnt %d\\n\",\n\t\t\t\tent->suspect->path,\n\t\t\t\toid_to_hex(&ent->suspect->commit->object.oid),\n\t\t\t\tent->suspect->refcnt);\n\t\t\tbaa = 1;\n\t\t}\n\t}\n\tif (baa)\n\t\tsb->on_sanity_fail(sb, baa);\n}\n\n/*\n * If two blame entries that are next to each other came from\n * contiguous lines in the same origin (i.e. <commit, path> pair),\n * merge them together.\n */\nvoid blame_coalesce(struct blame_scoreboard *sb)\n{\n\tstruct blame_entry *ent, *next;\n\n\tfor (ent = sb->ent; ent && (next = ent->next); ent = next) {\n\t\tif (ent->suspect == next->suspect &&\n\t\t    ent->s_lno + ent->num_lines == next->s_lno) {\n\t\t\tent->num_lines += next->num_lines;\n\t\t\tent->next = next->next;\n\t\t\tblame_origin_decref(next->suspect);\n\t\t\tfree(next);\n\t\t\tent->score = 0;\n\t\t\tnext = ent; /* again */\n\t\t}\n\t}\n\n\tif (sb->debug) /* sanity */\n\t\tsanity_check_refcnt(sb);\n}\n\n/*\n * Merge the given sorted list of blames into a preexisting origin.\n * If there were no previous blames to that commit, it is entered into\n * the commit priority queue of the score board.\n */\n\nstatic void queue_blames(struct blame_scoreboard *sb, struct blame_origin *porigin,\n\t\t\t struct blame_entry *sorted)\n{\n\tif (porigin->suspects)\n\t\tporigin->suspects = blame_merge(porigin->suspects, sorted);\n\telse {\n\t\tstruct blame_origin *o;\n\t\tfor (o = porigin->commit->util; o; o = o->next) {\n\t\t\tif (o->suspects) {\n\t\t\t\tporigin->suspects = sorted;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tporigin->suspects = sorted;\n\t\tprio_queue_put(&sb->commits, porigin->commit);\n\t}\n}\n\n/*\n * Fill the blob_sha1 field of an origin if it hasn't, so that later\n * call to fill_origin_blob() can use it to locate the data.  blob_sha1\n * for an origin is also used to pass the blame for the entire file to\n * the parent to detect the case where a child's blob is identical to\n * that of its parent's.\n *\n * This also fills origin->mode for corresponding tree path.\n */\nstatic int fill_blob_sha1_and_mode(struct blame_origin *origin)\n{\n\tif (!is_null_oid(&origin->blob_oid))\n\t\treturn 0;\n\tif (get_tree_entry(origin->commit->object.oid.hash,\n\t\t\t   origin->path,\n\t\t\t   origin->blob_oid.hash, &origin->mode))\n\t\tgoto error_out;\n\tif (oid_object_info(&origin->blob_oid, NULL) != OBJ_BLOB)\n\t\tgoto error_out;\n\treturn 0;\n error_out:\n\toidclr(&origin->blob_oid);\n\torigin->mode = S_IFINVALID;\n\treturn -1;\n}\n\n/*\n * We have an origin -- check if the same path exists in the\n * parent and return an origin structure to represent it.\n */\nstatic struct blame_origin *find_origin(struct commit *parent,\n\t\t\t\t  struct blame_origin *origin)\n{\n\tstruct blame_origin *porigin;\n\tstruct diff_options diff_opts;\n\tconst char *paths[2];\n\n\t/* First check any existing origins */\n\tfor (porigin = parent->util; porigin; porigin = porigin->next)\n\t\tif (!strcmp(porigin->path, origin->path)) {\n\t\t\t/*\n\t\t\t * The same path between origin and its parent\n\t\t\t * without renaming -- the most common case.\n\t\t\t */\n\t\t\treturn blame_origin_incref (porigin);\n\t\t}\n\n\t/* See if the origin->path is different between parent\n\t * and origin first.  Most of the time they are the\n\t * same and diff-tree is fairly efficient about this.\n\t */\n\tdiff_setup(&diff_opts);\n\tdiff_opts.flags.recursive = 1;\n\tdiff_opts.detect_rename = 0;\n\tdiff_opts.output_format = DIFF_FORMAT_NO_OUTPUT;\n\tpaths[0] = origin->path;\n\tpaths[1] = NULL;\n\n\tparse_pathspec(&diff_opts.pathspec,\n\t\t       PATHSPEC_ALL_MAGIC & ~PATHSPEC_LITERAL,\n\t\t       PATHSPEC_LITERAL_PATH, \"\", paths);\n\tdiff_setup_done(&diff_opts);\n\n\tif (is_null_oid(&origin->commit->object.oid))\n\t\tdo_diff_cache(&parent->tree->object.oid, &diff_opts);\n\telse\n\t\tdiff_tree_oid(&parent->tree->object.oid,\n\t\t\t      &origin->commit->tree->object.oid,\n\t\t\t      \"\", &diff_opts);\n\tdiffcore_std(&diff_opts);\n\n\tif (!diff_queued_diff.nr) {\n\t\t/* The path is the same as parent */\n\t\tporigin = get_origin(parent, origin->path);\n\t\toidcpy(&porigin->blob_oid, &origin->blob_oid);\n\t\tporigin->mode = origin->mode;\n\t} else {\n\t\t/*\n\t\t * Since origin->path is a pathspec, if the parent\n\t\t * commit had it as a directory, we will see a whole\n\t\t * bunch of deletion of files in the directory that we\n\t\t * do not care about.\n\t\t */\n\t\tint i;\n\t\tstruct diff_filepair *p = NULL;\n\t\tfor (i = 0; i < diff_queued_diff.nr; i++) {\n\t\t\tconst char *name;\n\t\t\tp = diff_queued_diff.queue[i];\n\t\t\tname = p->one->path ? p->one->path : p->two->path;\n\t\t\tif (!strcmp(name, origin->path))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!p)\n\t\t\tdie(\"internal error in blame::find_origin\");\n\t\tswitch (p->status) {\n\t\tdefault:\n\t\t\tdie(\"internal error in blame::find_origin (%c)\",\n\t\t\t    p->status);\n\t\tcase 'M':\n\t\t\tporigin = get_origin(parent, origin->path);\n\t\t\toidcpy(&porigin->blob_oid, &p->one->oid);\n\t\t\tporigin->mode = p->one->mode;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\tcase 'T':\n\t\t\t/* Did not exist in parent, or type changed */\n\t\t\tbreak;\n\t\t}\n\t}\n\tdiff_flush(&diff_opts);\n\tclear_pathspec(&diff_opts.pathspec);\n\treturn porigin;\n}\n\n/*\n * We have an origin -- find the path that corresponds to it in its\n * parent and return an origin structure to represent it.\n */\nstatic struct blame_origin *find_rename(struct commit *parent,\n\t\t\t\t  struct blame_origin *origin)\n{\n\tstruct blame_origin *porigin = NULL;\n\tstruct diff_options diff_opts;\n\tint i;\n\n\tdiff_setup(&diff_opts);\n\tdiff_opts.flags.recursive = 1;\n\tdiff_opts.detect_rename = DIFF_DETECT_RENAME;\n\tdiff_opts.output_format = DIFF_FORMAT_NO_OUTPUT;\n\tdiff_opts.single_follow = origin->path;\n\tdiff_setup_done(&diff_opts);\n\n\tif (is_null_oid(&origin->commit->object.oid))\n\t\tdo_diff_cache(&parent->tree->object.oid, &diff_opts);\n\telse\n\t\tdiff_tree_oid(&parent->tree->object.oid,\n\t\t\t      &origin->commit->tree->object.oid,\n\t\t\t      \"\", &diff_opts);\n\tdiffcore_std(&diff_opts);\n\n\tfor (i = 0; i < diff_queued_diff.nr; i++) {\n\t\tstruct diff_filepair *p = diff_queued_diff.queue[i];\n\t\tif ((p->status == 'R' || p->status == 'C') &&\n\t\t    !strcmp(p->two->path, origin->path)) {\n\t\t\tporigin = get_origin(parent, p->one->path);\n\t\t\toidcpy(&porigin->blob_oid, &p->one->oid);\n\t\t\tporigin->mode = p->one->mode;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdiff_flush(&diff_opts);\n\tclear_pathspec(&diff_opts.pathspec);\n\treturn porigin;\n}\n\n/*\n * Append a new blame entry to a given output queue.\n */\nstatic void add_blame_entry(struct blame_entry ***queue,\n\t\t\t    const struct blame_entry *src)\n{\n\tstruct blame_entry *e = xmalloc(sizeof(*e));\n\tmemcpy(e, src, sizeof(*e));\n\tblame_origin_incref(e->suspect);\n\n\te->next = **queue;\n\t**queue = e;\n\t*queue = &e->next;\n}\n\n/*\n * src typically is on-stack; we want to copy the information in it to\n * a malloced blame_entry that gets added to the given queue.  The\n * origin of dst loses a refcnt.\n */\nstatic void dup_entry(struct blame_entry ***queue,\n\t\t      struct blame_entry *dst, struct blame_entry *src)\n{\n\tblame_origin_incref(src->suspect);\n\tblame_origin_decref(dst->suspect);\n\tmemcpy(dst, src, sizeof(*src));\n\tdst->next = **queue;\n\t**queue = dst;\n\t*queue = &dst->next;\n}\n\nconst char *blame_nth_line(struct blame_scoreboard *sb, long lno)\n{\n\treturn sb->final_buf + sb->lineno[lno];\n}\n\n/*\n * It is known that lines between tlno to same came from parent, and e\n * has an overlap with that range.  it also is known that parent's\n * line plno corresponds to e's line tlno.\n *\n *                <---- e ----->\n *                   <------>\n *                   <------------>\n *             <------------>\n *             <------------------>\n *\n * Split e into potentially three parts; before this chunk, the chunk\n * to be blamed for the parent, and after that portion.\n */\nstatic void split_overlap(struct blame_entry *split,\n\t\t\t  struct blame_entry *e,\n\t\t\t  int tlno, int plno, int same,\n\t\t\t  struct blame_origin *parent)\n{\n\tint chunk_end_lno;\n\tmemset(split, 0, sizeof(struct blame_entry [3]));\n\n\tif (e->s_lno < tlno) {\n\t\t/* there is a pre-chunk part not blamed on parent */\n\t\tsplit[0].suspect = blame_origin_incref(e->suspect);\n\t\tsplit[0].lno = e->lno;\n\t\tsplit[0].s_lno = e->s_lno;\n\t\tsplit[0].num_lines = tlno - e->s_lno;\n\t\tsplit[1].lno = e->lno + tlno - e->s_lno;\n\t\tsplit[1].s_lno = plno;\n\t}\n\telse {\n\t\tsplit[1].lno = e->lno;\n\t\tsplit[1].s_lno = plno + (e->s_lno - tlno);\n\t}\n\n\tif (same < e->s_lno + e->num_lines) {\n\t\t/* there is a post-chunk part not blamed on parent */\n\t\tsplit[2].suspect = blame_origin_incref(e->suspect);\n\t\tsplit[2].lno = e->lno + (same - e->s_lno);\n\t\tsplit[2].s_lno = e->s_lno + (same - e->s_lno);\n\t\tsplit[2].num_lines = e->s_lno + e->num_lines - same;\n\t\tchunk_end_lno = split[2].lno;\n\t}\n\telse\n\t\tchunk_end_lno = e->lno + e->num_lines;\n\tsplit[1].num_lines = chunk_end_lno - split[1].lno;\n\n\t/*\n\t * if it turns out there is nothing to blame the parent for,\n\t * forget about the splitting.  !split[1].suspect signals this.\n\t */\n\tif (split[1].num_lines < 1)\n\t\treturn;\n\tsplit[1].suspect = blame_origin_incref(parent);\n}\n\n/*\n * split_overlap() divided an existing blame e into up to three parts\n * in split.  Any assigned blame is moved to queue to\n * reflect the split.\n */\nstatic void split_blame(struct blame_entry ***blamed,\n\t\t\tstruct blame_entry ***unblamed,\n\t\t\tstruct blame_entry *split,\n\t\t\tstruct blame_entry *e)\n{\n\tif (split[0].suspect && split[2].suspect) {\n\t\t/* The first part (reuse storage for the existing entry e) */\n\t\tdup_entry(unblamed, e, &split[0]);\n\n\t\t/* The last part -- me */\n\t\tadd_blame_entry(unblamed, &split[2]);\n\n\t\t/* ... and the middle part -- parent */\n\t\tadd_blame_entry(blamed, &split[1]);\n\t}\n\telse if (!split[0].suspect && !split[2].suspect)\n\t\t/*\n\t\t * The parent covers the entire area; reuse storage for\n\t\t * e and replace it with the parent.\n\t\t */\n\t\tdup_entry(blamed, e, &split[1]);\n\telse if (split[0].suspect) {\n\t\t/* me and then parent */\n\t\tdup_entry(unblamed, e, &split[0]);\n\t\tadd_blame_entry(blamed, &split[1]);\n\t}\n\telse {\n\t\t/* parent and then me */\n\t\tdup_entry(blamed, e, &split[1]);\n\t\tadd_blame_entry(unblamed, &split[2]);\n\t}\n}\n\n/*\n * After splitting the blame, the origins used by the\n * on-stack blame_entry should lose one refcnt each.\n */\nstatic void decref_split(struct blame_entry *split)\n{\n\tint i;\n\n\tfor (i = 0; i < 3; i++)\n\t\tblame_origin_decref(split[i].suspect);\n}\n\n/*\n * reverse_blame reverses the list given in head, appending tail.\n * That allows us to build lists in reverse order, then reverse them\n * afterwards.  This can be faster than building the list in proper\n * order right away.  The reason is that building in proper order\n * requires writing a link in the _previous_ element, while building\n * in reverse order just requires placing the list head into the\n * _current_ element.\n */\n\nstatic struct blame_entry *reverse_blame(struct blame_entry *head,\n\t\t\t\t\t struct blame_entry *tail)\n{\n\twhile (head) {\n\t\tstruct blame_entry *next = head->next;\n\t\thead->next = tail;\n\t\ttail = head;\n\t\thead = next;\n\t}\n\treturn tail;\n}\n\n/*\n * Process one hunk from the patch between the current suspect for\n * blame_entry e and its parent.  This first blames any unfinished\n * entries before the chunk (which is where target and parent start\n * differing) on the parent, and then splits blame entries at the\n * start and at the end of the difference region.  Since use of -M and\n * -C options may lead to overlapping/duplicate source line number\n * ranges, all we can rely on from sorting/merging is the order of the\n * first suspect line number.\n */\nstatic void blame_chunk(struct blame_entry ***dstq, struct blame_entry ***srcq,\n\t\t\tint tlno, int offset, int same,\n\t\t\tstruct blame_origin *parent)\n{\n\tstruct blame_entry *e = **srcq;\n\tstruct blame_entry *samep = NULL, *diffp = NULL;\n\n\twhile (e && e->s_lno < tlno) {\n\t\tstruct blame_entry *next = e->next;\n\t\t/*\n\t\t * current record starts before differing portion.  If\n\t\t * it reaches into it, we need to split it up and\n\t\t * examine the second part separately.\n\t\t */\n\t\tif (e->s_lno + e->num_lines > tlno) {\n\t\t\t/* Move second half to a new record */\n\t\t\tint len = tlno - e->s_lno;\n\t\t\tstruct blame_entry *n = xcalloc(1, sizeof (struct blame_entry));\n\t\t\tn->suspect = e->suspect;\n\t\t\tn->lno = e->lno + len;\n\t\t\tn->s_lno = e->s_lno + len;\n\t\t\tn->num_lines = e->num_lines - len;\n\t\t\te->num_lines = len;\n\t\t\te->score = 0;\n\t\t\t/* Push new record to diffp */\n\t\t\tn->next = diffp;\n\t\t\tdiffp = n;\n\t\t} else\n\t\t\tblame_origin_decref(e->suspect);\n\t\t/* Pass blame for everything before the differing\n\t\t * chunk to the parent */\n\t\te->suspect = blame_origin_incref(parent);\n\t\te->s_lno += offset;\n\t\te->next = samep;\n\t\tsamep = e;\n\t\te = next;\n\t}\n\t/*\n\t * As we don't know how much of a common stretch after this\n\t * diff will occur, the currently blamed parts are all that we\n\t * can assign to the parent for now.\n\t */\n\n\tif (samep) {\n\t\t**dstq = reverse_blame(samep, **dstq);\n\t\t*dstq = &samep->next;\n\t}\n\t/*\n\t * Prepend the split off portions: everything after e starts\n\t * after the blameable portion.\n\t */\n\te = reverse_blame(diffp, e);\n\n\t/*\n\t * Now retain records on the target while parts are different\n\t * from the parent.\n\t */\n\tsamep = NULL;\n\tdiffp = NULL;\n\twhile (e && e->s_lno < same) {\n\t\tstruct blame_entry *next = e->next;\n\n\t\t/*\n\t\t * If current record extends into sameness, need to split.\n\t\t */\n\t\tif (e->s_lno + e->num_lines > same) {\n\t\t\t/*\n\t\t\t * Move second half to a new record to be\n\t\t\t * processed by later chunks\n\t\t\t */\n\t\t\tint len = same - e->s_lno;\n\t\t\tstruct blame_entry *n = xcalloc(1, sizeof (struct blame_entry));\n\t\t\tn->suspect = blame_origin_incref(e->suspect);\n\t\t\tn->lno = e->lno + len;\n\t\t\tn->s_lno = e->s_lno + len;\n\t\t\tn->num_lines = e->num_lines - len;\n\t\t\te->num_lines = len;\n\t\t\te->score = 0;\n\t\t\t/* Push new record to samep */\n\t\t\tn->next = samep;\n\t\t\tsamep = n;\n\t\t}\n\t\te->next = diffp;\n\t\tdiffp = e;\n\t\te = next;\n\t}\n\t**srcq = reverse_blame(diffp, reverse_blame(samep, e));\n\t/* Move across elements that are in the unblamable portion */\n\tif (diffp)\n\t\t*srcq = &diffp->next;\n}\n\nstruct blame_chunk_cb_data {\n\tstruct blame_origin *parent;\n\tlong offset;\n\tstruct blame_entry **dstq;\n\tstruct blame_entry **srcq;\n};\n\n/* diff chunks are from parent to target */\nstatic int blame_chunk_cb(long start_a, long count_a,\n\t\t\t  long start_b, long count_b, void *data)\n{\n\tstruct blame_chunk_cb_data *d = data;\n\tif (start_a - start_b != d->offset)\n\t\tdie(\"internal error in blame::blame_chunk_cb\");\n\tblame_chunk(&d->dstq, &d->srcq, start_b, start_a - start_b,\n\t\t    start_b + count_b, d->parent);\n\td->offset = start_a + count_a - (start_b + count_b);\n\treturn 0;\n}\n\n/*\n * We are looking at the origin 'target' and aiming to pass blame\n * for the lines it is suspected to its parent.  Run diff to find\n * which lines came from parent and pass blame for them.\n */\nstatic void pass_blame_to_parent(struct blame_scoreboard *sb,\n\t\t\t\t struct blame_origin *target,\n\t\t\t\t struct blame_origin *parent)\n{\n\tmmfile_t file_p, file_o;\n\tstruct blame_chunk_cb_data d;\n\tstruct blame_entry *newdest = NULL;\n\n\tif (!target->suspects)\n\t\treturn; /* nothing remains for this target */\n\n\td.parent = parent;\n\td.offset = 0;\n\td.dstq = &newdest; d.srcq = &target->suspects;\n\n\tfill_origin_blob(&sb->revs->diffopt, parent, &file_p, &sb->num_read_blob);\n\tfill_origin_blob(&sb->revs->diffopt, target, &file_o, &sb->num_read_blob);\n\tsb->num_get_patch++;\n\n\tif (diff_hunks(&file_p, &file_o, blame_chunk_cb, &d, sb->xdl_opts))\n\t\tdie(\"unable to generate diff (%s -> %s)\",\n\t\t    oid_to_hex(&parent->commit->object.oid),\n\t\t    oid_to_hex(&target->commit->object.oid));\n\t/* The rest are the same as the parent */\n\tblame_chunk(&d.dstq, &d.srcq, INT_MAX, d.offset, INT_MAX, parent);\n\t*d.dstq = NULL;\n\tqueue_blames(sb, parent, newdest);\n\n\treturn;\n}\n\n/*\n * The lines in blame_entry after splitting blames many times can become\n * very small and trivial, and at some point it becomes pointless to\n * blame the parents.  E.g. \"\\t\\t}\\n\\t}\\n\\n\" appears everywhere in any\n * ordinary C program, and it is not worth to say it was copied from\n * totally unrelated file in the parent.\n *\n * Compute how trivial the lines in the blame_entry are.\n */\nunsigned blame_entry_score(struct blame_scoreboard *sb, struct blame_entry *e)\n{\n\tunsigned score;\n\tconst char *cp, *ep;\n\n\tif (e->score)\n\t\treturn e->score;\n\n\tscore = 1;\n\tcp = blame_nth_line(sb, e->lno);\n\tep = blame_nth_line(sb, e->lno + e->num_lines);\n\twhile (cp < ep) {\n\t\tunsigned ch = *((unsigned char *)cp);\n\t\tif (isalnum(ch))\n\t\t\tscore++;\n\t\tcp++;\n\t}\n\te->score = score;\n\treturn score;\n}\n\n/*\n * best_so_far[] and potential[] are both a split of an existing blame_entry\n * that passes blame to the parent.  Maintain best_so_far the best split so\n * far, by comparing potential and best_so_far and copying potential into\n * bst_so_far as needed.\n */\nstatic void copy_split_if_better(struct blame_scoreboard *sb,\n\t\t\t\t struct blame_entry *best_so_far,\n\t\t\t\t struct blame_entry *potential)\n{\n\tint i;\n\n\tif (!potential[1].suspect)\n\t\treturn;\n\tif (best_so_far[1].suspect) {\n\t\tif (blame_entry_score(sb, &potential[1]) <\n\t\t    blame_entry_score(sb, &best_so_far[1]))\n\t\t\treturn;\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t\tblame_origin_incref(potential[i].suspect);\n\tdecref_split(best_so_far);\n\tmemcpy(best_so_far, potential, sizeof(struct blame_entry[3]));\n}\n\n/*\n * We are looking at a part of the final image represented by\n * ent (tlno and same are offset by ent->s_lno).\n * tlno is where we are looking at in the final image.\n * up to (but not including) same match preimage.\n * plno is where we are looking at in the preimage.\n *\n * <-------------- final image ---------------------->\n *       <------ent------>\n *         ^tlno ^same\n *    <---------preimage----->\n *         ^plno\n *\n * All line numbers are 0-based.\n */\nstatic void handle_split(struct blame_scoreboard *sb,\n\t\t\t struct blame_entry *ent,\n\t\t\t int tlno, int plno, int same,\n\t\t\t struct blame_origin *parent,\n\t\t\t struct blame_entry *split)\n{\n\tif (ent->num_lines <= tlno)\n\t\treturn;\n\tif (tlno < same) {\n\t\tstruct blame_entry potential[3];\n\t\ttlno += ent->s_lno;\n\t\tsame += ent->s_lno;\n\t\tsplit_overlap(potential, ent, tlno, plno, same, parent);\n\t\tcopy_split_if_better(sb, split, potential);\n\t\tdecref_split(potential);\n\t}\n}\n\nstruct handle_split_cb_data {\n\tstruct blame_scoreboard *sb;\n\tstruct blame_entry *ent;\n\tstruct blame_origin *parent;\n\tstruct blame_entry *split;\n\tlong plno;\n\tlong tlno;\n};\n\nstatic int handle_split_cb(long start_a, long count_a,\n\t\t\t   long start_b, long count_b, void *data)\n{\n\tstruct handle_split_cb_data *d = data;\n\thandle_split(d->sb, d->ent, d->tlno, d->plno, start_b, d->parent,\n\t\t     d->split);\n\td->plno = start_a + count_a;\n\td->tlno = start_b + count_b;\n\treturn 0;\n}\n\n/*\n * Find the lines from parent that are the same as ent so that\n * we can pass blames to it.  file_p has the blob contents for\n * the parent.\n */\nstatic void find_copy_in_blob(struct blame_scoreboard *sb,\n\t\t\t      struct blame_entry *ent,\n\t\t\t      struct blame_origin *parent,\n\t\t\t      struct blame_entry *split,\n\t\t\t      mmfile_t *file_p)\n{\n\tconst char *cp;\n\tmmfile_t file_o;\n\tstruct handle_split_cb_data d;\n\n\tmemset(&d, 0, sizeof(d));\n\td.sb = sb; d.ent = ent; d.parent = parent; d.split = split;\n\t/*\n\t * Prepare mmfile that contains only the lines in ent.\n\t */\n\tcp = blame_nth_line(sb, ent->lno);\n\tfile_o.ptr = (char *) cp;\n\tfile_o.size = blame_nth_line(sb, ent->lno + ent->num_lines) - cp;\n\n\t/*\n\t * file_o is a part of final image we are annotating.\n\t * file_p partially may match that image.\n\t */\n\tmemset(split, 0, sizeof(struct blame_entry [3]));\n\tif (diff_hunks(file_p, &file_o, handle_split_cb, &d, sb->xdl_opts))\n\t\tdie(\"unable to generate diff (%s)\",\n\t\t    oid_to_hex(&parent->commit->object.oid));\n\t/* remainder, if any, all match the preimage */\n\thandle_split(sb, ent, d.tlno, d.plno, ent->num_lines, parent, split);\n}\n\n/* Move all blame entries from list *source that have a score smaller\n * than score_min to the front of list *small.\n * Returns a pointer to the link pointing to the old head of the small list.\n */\n\nstatic struct blame_entry **filter_small(struct blame_scoreboard *sb,\n\t\t\t\t\t struct blame_entry **small,\n\t\t\t\t\t struct blame_entry **source,\n\t\t\t\t\t unsigned score_min)\n{\n\tstruct blame_entry *p = *source;\n\tstruct blame_entry *oldsmall = *small;\n\twhile (p) {\n\t\tif (blame_entry_score(sb, p) <= score_min) {\n\t\t\t*small = p;\n\t\t\tsmall = &p->next;\n\t\t\tp = *small;\n\t\t} else {\n\t\t\t*source = p;\n\t\t\tsource = &p->next;\n\t\t\tp = *source;\n\t\t}\n\t}\n\t*small = oldsmall;\n\t*source = NULL;\n\treturn small;\n}\n\n/*\n * See if lines currently target is suspected for can be attributed to\n * parent.\n */\nstatic void find_move_in_parent(struct blame_scoreboard *sb,\n\t\t\t\tstruct blame_entry ***blamed,\n\t\t\t\tstruct blame_entry **toosmall,\n\t\t\t\tstruct blame_origin *target,\n\t\t\t\tstruct blame_origin *parent)\n{\n\tstruct blame_entry *e, split[3];\n\tstruct blame_entry *unblamed = target->suspects;\n\tstruct blame_entry *leftover = NULL;\n\tmmfile_t file_p;\n\n\tif (!unblamed)\n\t\treturn; /* nothing remains for this target */\n\n\tfill_origin_blob(&sb->revs->diffopt, parent, &file_p, &sb->num_read_blob);\n\tif (!file_p.ptr)\n\t\treturn;\n\n\t/* At each iteration, unblamed has a NULL-terminated list of\n\t * entries that have not yet been tested for blame.  leftover\n\t * contains the reversed list of entries that have been tested\n\t * without being assignable to the parent.\n\t */\n\tdo {\n\t\tstruct blame_entry **unblamedtail = &unblamed;\n\t\tstruct blame_entry *next;\n\t\tfor (e = unblamed; e; e = next) {\n\t\t\tnext = e->next;\n\t\t\tfind_copy_in_blob(sb, e, parent, split, &file_p);\n\t\t\tif (split[1].suspect &&\n\t\t\t    sb->move_score < blame_entry_score(sb, &split[1])) {\n\t\t\t\tsplit_blame(blamed, &unblamedtail, split, e);\n\t\t\t} else {\n\t\t\t\te->next = leftover;\n\t\t\t\tleftover = e;\n\t\t\t}\n\t\t\tdecref_split(split);\n\t\t}\n\t\t*unblamedtail = NULL;\n\t\ttoosmall = filter_small(sb, toosmall, &unblamed, sb->move_score);\n\t} while (unblamed);\n\ttarget->suspects = reverse_blame(leftover, NULL);\n}\n\nstruct blame_list {\n\tstruct blame_entry *ent;\n\tstruct blame_entry split[3];\n};\n\n/*\n * Count the number of entries the target is suspected for,\n * and prepare a list of entry and the best split.\n */\nstatic struct blame_list *setup_blame_list(struct blame_entry *unblamed,\n\t\t\t\t\t   int *num_ents_p)\n{\n\tstruct blame_entry *e;\n\tint num_ents, i;\n\tstruct blame_list *blame_list = NULL;\n\n\tfor (e = unblamed, num_ents = 0; e; e = e->next)\n\t\tnum_ents++;\n\tif (num_ents) {\n\t\tblame_list = xcalloc(num_ents, sizeof(struct blame_list));\n\t\tfor (e = unblamed, i = 0; e; e = e->next)\n\t\t\tblame_list[i++].ent = e;\n\t}\n\t*num_ents_p = num_ents;\n\treturn blame_list;\n}\n\n/*\n * For lines target is suspected for, see if we can find code movement\n * across file boundary from the parent commit.  porigin is the path\n * in the parent we already tried.\n */\nstatic void find_copy_in_parent(struct blame_scoreboard *sb,\n\t\t\t\tstruct blame_entry ***blamed,\n\t\t\t\tstruct blame_entry **toosmall,\n\t\t\t\tstruct blame_origin *target,\n\t\t\t\tstruct commit *parent,\n\t\t\t\tstruct blame_origin *porigin,\n\t\t\t\tint opt)\n{\n\tstruct diff_options diff_opts;\n\tint i, j;\n\tstruct blame_list *blame_list;\n\tint num_ents;\n\tstruct blame_entry *unblamed = target->suspects;\n\tstruct blame_entry *leftover = NULL;\n\n\tif (!unblamed)\n\t\treturn; /* nothing remains for this target */\n\n\tdiff_setup(&diff_opts);\n\tdiff_opts.flags.recursive = 1;\n\tdiff_opts.output_format = DIFF_FORMAT_NO_OUTPUT;\n\n\tdiff_setup_done(&diff_opts);\n\n\t/* Try \"find copies harder\" on new path if requested;\n\t * we do not want to use diffcore_rename() actually to\n\t * match things up; find_copies_harder is set only to\n\t * force diff_tree_oid() to feed all filepairs to diff_queue,\n\t * and this code needs to be after diff_setup_done(), which\n\t * usually makes find-copies-harder imply copy detection.\n\t */\n\tif ((opt & PICKAXE_BLAME_COPY_HARDEST)\n\t    || ((opt & PICKAXE_BLAME_COPY_HARDER)\n\t\t&& (!porigin || strcmp(target->path, porigin->path))))\n\t\tdiff_opts.flags.find_copies_harder = 1;\n\n\tif (is_null_oid(&target->commit->object.oid))\n\t\tdo_diff_cache(&parent->tree->object.oid, &diff_opts);\n\telse\n\t\tdiff_tree_oid(&parent->tree->object.oid,\n\t\t\t      &target->commit->tree->object.oid,\n\t\t\t      \"\", &diff_opts);\n\n\tif (!diff_opts.flags.find_copies_harder)\n\t\tdiffcore_std(&diff_opts);\n\n\tdo {\n\t\tstruct blame_entry **unblamedtail = &unblamed;\n\t\tblame_list = setup_blame_list(unblamed, &num_ents);\n\n\t\tfor (i = 0; i < diff_queued_diff.nr; i++) {\n\t\t\tstruct diff_filepair *p = diff_queued_diff.queue[i];\n\t\t\tstruct blame_origin *norigin;\n\t\t\tmmfile_t file_p;\n\t\t\tstruct blame_entry potential[3];\n\n\t\t\tif (!DIFF_FILE_VALID(p->one))\n\t\t\t\tcontinue; /* does not exist in parent */\n\t\t\tif (S_ISGITLINK(p->one->mode))\n\t\t\t\tcontinue; /* ignore git links */\n\t\t\tif (porigin && !strcmp(p->one->path, porigin->path))\n\t\t\t\t/* find_move already dealt with this path */\n\t\t\t\tcontinue;\n\n\t\t\tnorigin = get_origin(parent, p->one->path);\n\t\t\toidcpy(&norigin->blob_oid, &p->one->oid);\n\t\t\tnorigin->mode = p->one->mode;\n\t\t\tfill_origin_blob(&sb->revs->diffopt, norigin, &file_p, &sb->num_read_blob);\n\t\t\tif (!file_p.ptr)\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; j < num_ents; j++) {\n\t\t\t\tfind_copy_in_blob(sb, blame_list[j].ent,\n\t\t\t\t\t\t  norigin, potential, &file_p);\n\t\t\t\tcopy_split_if_better(sb, blame_list[j].split,\n\t\t\t\t\t\t     potential);\n\t\t\t\tdecref_split(potential);\n\t\t\t}\n\t\t\tblame_origin_decref(norigin);\n\t\t}\n\n\t\tfor (j = 0; j < num_ents; j++) {\n\t\t\tstruct blame_entry *split = blame_list[j].split;\n\t\t\tif (split[1].suspect &&\n\t\t\t    sb->copy_score < blame_entry_score(sb, &split[1])) {\n\t\t\t\tsplit_blame(blamed, &unblamedtail, split,\n\t\t\t\t\t    blame_list[j].ent);\n\t\t\t} else {\n\t\t\t\tblame_list[j].ent->next = leftover;\n\t\t\t\tleftover = blame_list[j].ent;\n\t\t\t}\n\t\t\tdecref_split(split);\n\t\t}\n\t\tfree(blame_list);\n\t\t*unblamedtail = NULL;\n\t\ttoosmall = filter_small(sb, toosmall, &unblamed, sb->copy_score);\n\t} while (unblamed);\n\ttarget->suspects = reverse_blame(leftover, NULL);\n\tdiff_flush(&diff_opts);\n\tclear_pathspec(&diff_opts.pathspec);\n}\n\n/*\n * The blobs of origin and porigin exactly match, so everything\n * origin is suspected for can be blamed on the parent.\n */\nstatic void pass_whole_blame(struct blame_scoreboard *sb,\n\t\t\t     struct blame_origin *origin, struct blame_origin *porigin)\n{\n\tstruct blame_entry *e, *suspects;\n\n\tif (!porigin->file.ptr && origin->file.ptr) {\n\t\t/* Steal its file */\n\t\tporigin->file = origin->file;\n\t\torigin->file.ptr = NULL;\n\t}\n\tsuspects = origin->suspects;\n\torigin->suspects = NULL;\n\tfor (e = suspects; e; e = e->next) {\n\t\tblame_origin_incref(porigin);\n\t\tblame_origin_decref(e->suspect);\n\t\te->suspect = porigin;\n\t}\n\tqueue_blames(sb, porigin, suspects);\n}\n\n/*\n * We pass blame from the current commit to its parents.  We keep saying\n * \"parent\" (and \"porigin\"), but what we mean is to find scapegoat to\n * exonerate ourselves.\n */\nstatic struct commit_list *first_scapegoat(struct rev_info *revs, struct commit *commit,\n\t\t\t\t\tint reverse)\n{\n\tif (!reverse) {\n\t\tif (revs->first_parent_only &&\n\t\t    commit->parents &&\n\t\t    commit->parents->next) {\n\t\t\tfree_commit_list(commit->parents->next);\n\t\t\tcommit->parents->next = NULL;\n\t\t}\n\t\treturn commit->parents;\n\t}\n\treturn lookup_decoration(&revs->children, &commit->object);\n}\n\nstatic int num_scapegoats(struct rev_info *revs, struct commit *commit, int reverse)\n{\n\tstruct commit_list *l = first_scapegoat(revs, commit, reverse);\n\treturn commit_list_count(l);\n}\n\n/* Distribute collected unsorted blames to the respected sorted lists\n * in the various origins.\n */\nstatic void distribute_blame(struct blame_scoreboard *sb, struct blame_entry *blamed)\n{\n\tblamed = llist_mergesort(blamed, get_next_blame, set_next_blame,\n\t\t\t\t compare_blame_suspect);\n\twhile (blamed)\n\t{\n\t\tstruct blame_origin *porigin = blamed->suspect;\n\t\tstruct blame_entry *suspects = NULL;\n\t\tdo {\n\t\t\tstruct blame_entry *next = blamed->next;\n\t\t\tblamed->next = suspects;\n\t\t\tsuspects = blamed;\n\t\t\tblamed = next;\n\t\t} while (blamed && blamed->suspect == porigin);\n\t\tsuspects = reverse_blame(suspects, NULL);\n\t\tqueue_blames(sb, porigin, suspects);\n\t}\n}\n\n#define MAXSG 16\n\nstatic void pass_blame(struct blame_scoreboard *sb, struct blame_origin *origin, int opt)\n{\n\tstruct rev_info *revs = sb->revs;\n\tint i, pass, num_sg;\n\tstruct commit *commit = origin->commit;\n\tstruct commit_list *sg;\n\tstruct blame_origin *sg_buf[MAXSG];\n\tstruct blame_origin *porigin, **sg_origin = sg_buf;\n\tstruct blame_entry *toosmall = NULL;\n\tstruct blame_entry *blames, **blametail = &blames;\n\n\tnum_sg = num_scapegoats(revs, commit, sb->reverse);\n\tif (!num_sg)\n\t\tgoto finish;\n\telse if (num_sg < ARRAY_SIZE(sg_buf))\n\t\tmemset(sg_buf, 0, sizeof(sg_buf));\n\telse\n\t\tsg_origin = xcalloc(num_sg, sizeof(*sg_origin));\n\n\t/*\n\t * The first pass looks for unrenamed path to optimize for\n\t * common cases, then we look for renames in the second pass.\n\t */\n\tfor (pass = 0; pass < 2 - sb->no_whole_file_rename; pass++) {\n\t\tstruct blame_origin *(*find)(struct commit *, struct blame_origin *);\n\t\tfind = pass ? find_rename : find_origin;\n\n\t\tfor (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);\n\t\t     i < num_sg && sg;\n\t\t     sg = sg->next, i++) {\n\t\t\tstruct commit *p = sg->item;\n\t\t\tint j, same;\n\n\t\t\tif (sg_origin[i])\n\t\t\t\tcontinue;\n\t\t\tif (parse_commit(p))\n\t\t\t\tcontinue;\n\t\t\tporigin = find(p, origin);\n\t\t\tif (!porigin)\n\t\t\t\tcontinue;\n\t\t\tif (!oidcmp(&porigin->blob_oid, &origin->blob_oid)) {\n\t\t\t\tpass_whole_blame(sb, origin, porigin);\n\t\t\t\tblame_origin_decref(porigin);\n\t\t\t\tgoto finish;\n\t\t\t}\n\t\t\tfor (j = same = 0; j < i; j++)\n\t\t\t\tif (sg_origin[j] &&\n\t\t\t\t    !oidcmp(&sg_origin[j]->blob_oid, &porigin->blob_oid)) {\n\t\t\t\t\tsame = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (!same)\n\t\t\t\tsg_origin[i] = porigin;\n\t\t\telse\n\t\t\t\tblame_origin_decref(porigin);\n\t\t}\n\t}\n\n\tsb->num_commits++;\n\tfor (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);\n\t     i < num_sg && sg;\n\t     sg = sg->next, i++) {\n\t\tstruct blame_origin *porigin = sg_origin[i];\n\t\tif (!porigin)\n\t\t\tcontinue;\n\t\tif (!origin->previous) {\n\t\t\tblame_origin_incref(porigin);\n\t\t\torigin->previous = porigin;\n\t\t}\n\t\tpass_blame_to_parent(sb, origin, porigin);\n\t\tif (!origin->suspects)\n\t\t\tgoto finish;\n\t}\n\n\t/*\n\t * Optionally find moves in parents' files.\n\t */\n\tif (opt & PICKAXE_BLAME_MOVE) {\n\t\tfilter_small(sb, &toosmall, &origin->suspects, sb->move_score);\n\t\tif (origin->suspects) {\n\t\t\tfor (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);\n\t\t\t     i < num_sg && sg;\n\t\t\t     sg = sg->next, i++) {\n\t\t\t\tstruct blame_origin *porigin = sg_origin[i];\n\t\t\t\tif (!porigin)\n\t\t\t\t\tcontinue;\n\t\t\t\tfind_move_in_parent(sb, &blametail, &toosmall, origin, porigin);\n\t\t\t\tif (!origin->suspects)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Optionally find copies from parents' files.\n\t */\n\tif (opt & PICKAXE_BLAME_COPY) {\n\t\tif (sb->copy_score > sb->move_score)\n\t\t\tfilter_small(sb, &toosmall, &origin->suspects, sb->copy_score);\n\t\telse if (sb->copy_score < sb->move_score) {\n\t\t\torigin->suspects = blame_merge(origin->suspects, toosmall);\n\t\t\ttoosmall = NULL;\n\t\t\tfilter_small(sb, &toosmall, &origin->suspects, sb->copy_score);\n\t\t}\n\t\tif (!origin->suspects)\n\t\t\tgoto finish;\n\n\t\tfor (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);\n\t\t     i < num_sg && sg;\n\t\t     sg = sg->next, i++) {\n\t\t\tstruct blame_origin *porigin = sg_origin[i];\n\t\t\tfind_copy_in_parent(sb, &blametail, &toosmall,\n\t\t\t\t\t    origin, sg->item, porigin, opt);\n\t\t\tif (!origin->suspects)\n\t\t\t\tgoto finish;\n\t\t}\n\t}\n\nfinish:\n\t*blametail = NULL;\n\tdistribute_blame(sb, blames);\n\t/*\n\t * prepend toosmall to origin->suspects\n\t *\n\t * There is no point in sorting: this ends up on a big\n\t * unsorted list in the caller anyway.\n\t */\n\tif (toosmall) {\n\t\tstruct blame_entry **tail = &toosmall;\n\t\twhile (*tail)\n\t\t\ttail = &(*tail)->next;\n\t\t*tail = origin->suspects;\n\t\torigin->suspects = toosmall;\n\t}\n\tfor (i = 0; i < num_sg; i++) {\n\t\tif (sg_origin[i]) {\n\t\t\tdrop_origin_blob(sg_origin[i]);\n\t\t\tblame_origin_decref(sg_origin[i]);\n\t\t}\n\t}\n\tdrop_origin_blob(origin);\n\tif (sg_buf != sg_origin)\n\t\tfree(sg_origin);\n}\n\n/*\n * The main loop -- while we have blobs with lines whose true origin\n * is still unknown, pick one blob, and allow its lines to pass blames\n * to its parents. */\nvoid assign_blame(struct blame_scoreboard *sb, int opt)\n{\n\tstruct rev_info *revs = sb->revs;\n\tstruct commit *commit = prio_queue_get(&sb->commits);\n\n\twhile (commit) {\n\t\tstruct blame_entry *ent;\n\t\tstruct blame_origin *suspect = commit->util;\n\n\t\t/* find one suspect to break down */\n\t\twhile (suspect && !suspect->suspects)\n\t\t\tsuspect = suspect->next;\n\n\t\tif (!suspect) {\n\t\t\tcommit = prio_queue_get(&sb->commits);\n\t\t\tcontinue;\n\t\t}\n\n\t\tassert(commit == suspect->commit);\n\n\t\t/*\n\t\t * We will use this suspect later in the loop,\n\t\t * so hold onto it in the meantime.\n\t\t */\n\t\tblame_origin_incref(suspect);\n\t\tparse_commit(commit);\n\t\tif (sb->reverse ||\n\t\t    (!(commit->object.flags & UNINTERESTING) &&\n\t\t     !(revs->max_age != -1 && commit->date < revs->max_age)))\n\t\t\tpass_blame(sb, suspect, opt);\n\t\telse {\n\t\t\tcommit->object.flags |= UNINTERESTING;\n\t\t\tif (commit->object.parsed)\n\t\t\t\tmark_parents_uninteresting(commit);\n\t\t}\n\t\t/* treat root commit as boundary */\n\t\tif (!commit->parents && !sb->show_root)\n\t\t\tcommit->object.flags |= UNINTERESTING;\n\n\t\t/* Take responsibility for the remaining entries */\n\t\tent = suspect->suspects;\n\t\tif (ent) {\n\t\t\tsuspect->guilty = 1;\n\t\t\tfor (;;) {\n\t\t\t\tstruct blame_entry *next = ent->next;\n\t\t\t\tif (sb->found_guilty_entry)\n\t\t\t\t\tsb->found_guilty_entry(ent, sb->found_guilty_entry_data);\n\t\t\t\tif (next) {\n\t\t\t\t\tent = next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tent->next = sb->ent;\n\t\t\t\tsb->ent = suspect->suspects;\n\t\t\t\tsuspect->suspects = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tblame_origin_decref(suspect);\n\n\t\tif (sb->debug) /* sanity */\n\t\t\tsanity_check_refcnt(sb);\n\t}\n}\n\nstatic const char *get_next_line(const char *start, const char *end)\n{\n\tconst char *nl = memchr(start, '\\n', end - start);\n\treturn nl ? nl + 1 : end;\n}\n\n/*\n * To allow quick access to the contents of nth line in the\n * final image, prepare an index in the scoreboard.\n */\nstatic int prepare_lines(struct blame_scoreboard *sb)\n{\n\tconst char *buf = sb->final_buf;\n\tunsigned long len = sb->final_buf_size;\n\tconst char *end = buf + len;\n\tconst char *p;\n\tint *lineno;\n\tint num = 0;\n\n\tfor (p = buf; p < end; p = get_next_line(p, end))\n\t\tnum++;\n\n\tALLOC_ARRAY(sb->lineno, num + 1);\n\tlineno = sb->lineno;\n\n\tfor (p = buf; p < end; p = get_next_line(p, end))\n\t\t*lineno++ = p - buf;\n\n\t*lineno = len;\n\n\tsb->num_lines = num;\n\treturn sb->num_lines;\n}\n\nstatic struct commit *find_single_final(struct rev_info *revs,\n\t\t\t\t\tconst char **name_p)\n{\n\tint i;\n\tstruct commit *found = NULL;\n\tconst char *name = NULL;\n\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object *obj = revs->pending.objects[i].item;\n\t\tif (obj->flags & UNINTERESTING)\n\t\t\tcontinue;\n\t\tobj = deref_tag(obj, NULL, 0);\n\t\tif (obj->type != OBJ_COMMIT)\n\t\t\tdie(\"Non commit %s?\", revs->pending.objects[i].name);\n\t\tif (found)\n\t\t\tdie(\"More than one commit to dig from %s and %s?\",\n\t\t\t    revs->pending.objects[i].name, name);\n\t\tfound = (struct commit *)obj;\n\t\tname = revs->pending.objects[i].name;\n\t}\n\tif (name_p)\n\t\t*name_p = xstrdup_or_null(name);\n\treturn found;\n}\n\nstatic struct commit *dwim_reverse_initial(struct rev_info *revs,\n\t\t\t\t\t   const char **name_p)\n{\n\t/*\n\t * DWIM \"git blame --reverse ONE -- PATH\" as\n\t * \"git blame --reverse ONE..HEAD -- PATH\" but only do so\n\t * when it makes sense.\n\t */\n\tstruct object *obj;\n\tstruct commit *head_commit;\n\tstruct object_id head_oid;\n\n\tif (revs->pending.nr != 1)\n\t\treturn NULL;\n\n\t/* Is that sole rev a committish? */\n\tobj = revs->pending.objects[0].item;\n\tobj = deref_tag(obj, NULL, 0);\n\tif (obj->type != OBJ_COMMIT)\n\t\treturn NULL;\n\n\t/* Do we have HEAD? */\n\tif (!resolve_ref_unsafe(\"HEAD\", RESOLVE_REF_READING, &head_oid, NULL))\n\t\treturn NULL;\n\thead_commit = lookup_commit_reference_gently(&head_oid, 1);\n\tif (!head_commit)\n\t\treturn NULL;\n\n\t/* Turn \"ONE\" into \"ONE..HEAD\" then */\n\tobj->flags |= UNINTERESTING;\n\tadd_pending_object(revs, &head_commit->object, \"HEAD\");\n\n\tif (name_p)\n\t\t*name_p = revs->pending.objects[0].name;\n\treturn (struct commit *)obj;\n}\n\nstatic struct commit *find_single_initial(struct rev_info *revs,\n\t\t\t\t\t  const char **name_p)\n{\n\tint i;\n\tstruct commit *found = NULL;\n\tconst char *name = NULL;\n\n\t/*\n\t * There must be one and only one negative commit, and it must be\n\t * the boundary.\n\t */\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object *obj = revs->pending.objects[i].item;\n\t\tif (!(obj->flags & UNINTERESTING))\n\t\t\tcontinue;\n\t\tobj = deref_tag(obj, NULL, 0);\n\t\tif (obj->type != OBJ_COMMIT)\n\t\t\tdie(\"Non commit %s?\", revs->pending.objects[i].name);\n\t\tif (found)\n\t\t\tdie(\"More than one commit to dig up from, %s and %s?\",\n\t\t\t    revs->pending.objects[i].name, name);\n\t\tfound = (struct commit *) obj;\n\t\tname = revs->pending.objects[i].name;\n\t}\n\n\tif (!name)\n\t\tfound = dwim_reverse_initial(revs, &name);\n\tif (!name)\n\t\tdie(\"No commit to dig up from?\");\n\n\tif (name_p)\n\t\t*name_p = xstrdup(name);\n\treturn found;\n}\n\nvoid init_scoreboard(struct blame_scoreboard *sb)\n{\n\tmemset(sb, 0, sizeof(struct blame_scoreboard));\n\tsb->move_score = BLAME_DEFAULT_MOVE_SCORE;\n\tsb->copy_score = BLAME_DEFAULT_COPY_SCORE;\n}\n\nvoid setup_scoreboard(struct blame_scoreboard *sb, const char *path, struct blame_origin **orig)\n{\n\tconst char *final_commit_name = NULL;\n\tstruct blame_origin *o;\n\tstruct commit *final_commit = NULL;\n\tenum object_type type;\n\n\tif (sb->reverse && sb->contents_from)\n\t\tdie(_(\"--contents and --reverse do not blend well.\"));\n\n\tif (!sb->reverse) {\n\t\tsb->final = find_single_final(sb->revs, &final_commit_name);\n\t\tsb->commits.compare = compare_commits_by_commit_date;\n\t} else {\n\t\tsb->final = find_single_initial(sb->revs, &final_commit_name);\n\t\tsb->commits.compare = compare_commits_by_reverse_commit_date;\n\t}\n\n\tif (sb->final && sb->contents_from)\n\t\tdie(_(\"cannot use --contents with final commit object name\"));\n\n\tif (sb->reverse && sb->revs->first_parent_only)\n\t\tsb->revs->children.name = NULL;\n\n\tif (!sb->final) {\n\t\t/*\n\t\t * \"--not A B -- path\" without anything positive;\n\t\t * do not default to HEAD, but use the working tree\n\t\t * or \"--contents\".\n\t\t */\n\t\tsetup_work_tree();\n\t\tsb->final = fake_working_tree_commit(&sb->revs->diffopt,\n\t\t\t\t\t\t     path, sb->contents_from);\n\t\tadd_pending_object(sb->revs, &(sb->final->object), \":\");\n\t}\n\n\tif (sb->reverse && sb->revs->first_parent_only) {\n\t\tfinal_commit = find_single_final(sb->revs, NULL);\n\t\tif (!final_commit)\n\t\t\tdie(_(\"--reverse and --first-parent together require specified latest commit\"));\n\t}\n\n\t/*\n\t * If we have bottom, this will mark the ancestors of the\n\t * bottom commits we would reach while traversing as\n\t * uninteresting.\n\t */\n\tif (prepare_revision_walk(sb->revs))\n\t\tdie(_(\"revision walk setup failed\"));\n\n\tif (sb->reverse && sb->revs->first_parent_only) {\n\t\tstruct commit *c = final_commit;\n\n\t\tsb->revs->children.name = \"children\";\n\t\twhile (c->parents &&\n\t\t       oidcmp(&c->object.oid, &sb->final->object.oid)) {\n\t\t\tstruct commit_list *l = xcalloc(1, sizeof(*l));\n\n\t\t\tl->item = c;\n\t\t\tif (add_decoration(&sb->revs->children,\n\t\t\t\t\t   &c->parents->item->object, l))\n\t\t\t\tdie(\"BUG: not unique item in first-parent chain\");\n\t\t\tc = c->parents->item;\n\t\t}\n\n\t\tif (oidcmp(&c->object.oid, &sb->final->object.oid))\n\t\t\tdie(_(\"--reverse --first-parent together require range along first-parent chain\"));\n\t}\n\n\tif (is_null_oid(&sb->final->object.oid)) {\n\t\to = sb->final->util;\n\t\tsb->final_buf = xmemdupz(o->file.ptr, o->file.size);\n\t\tsb->final_buf_size = o->file.size;\n\t}\n\telse {\n\t\to = get_origin(sb->final, path);\n\t\tif (fill_blob_sha1_and_mode(o))\n\t\t\tdie(_(\"no such path %s in %s\"), path, final_commit_name);\n\n\t\tif (sb->revs->diffopt.flags.allow_textconv &&\n\t\t    textconv_object(path, o->mode, &o->blob_oid, 1, (char **) &sb->final_buf,\n\t\t\t\t    &sb->final_buf_size))\n\t\t\t;\n\t\telse\n\t\t\tsb->final_buf = read_sha1_file(o->blob_oid.hash, &type,\n\t\t\t\t\t\t       &sb->final_buf_size);\n\n\t\tif (!sb->final_buf)\n\t\t\tdie(_(\"cannot read blob %s for path %s\"),\n\t\t\t    oid_to_hex(&o->blob_oid),\n\t\t\t    path);\n\t}\n\tsb->num_read_blob++;\n\tprepare_lines(sb);\n\n\tif (orig)\n\t\t*orig = o;\n\n\tfree((char *)final_commit_name);\n}\n\n\n\nstruct blame_entry *blame_entry_prepend(struct blame_entry *head,\n\t\t\t\t\tlong start, long end,\n\t\t\t\t\tstruct blame_origin *o)\n{\n\tstruct blame_entry *new_head = xcalloc(1, sizeof(struct blame_entry));\n\tnew_head->lno = start;\n\tnew_head->num_lines = end - start;\n\tnew_head->suspect = o;\n\tnew_head->s_lno = start;\n\tnew_head->next = head;\n\tblame_origin_incref(o);\n\treturn new_head;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00b97c18986091c50140dd644c9dc2405162c600",
  "sha1_ok": true,
  "size": 50837
}
