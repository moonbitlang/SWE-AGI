{
  "content": {
    "base64": "IyEvYmluL3NoCiMKIyBDb3B5cmlnaHQgKGMpIDIwMDUgSnVuaW8gQyBIYW1hbm8KIwojIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5CiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkKIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAyIG9mIHRoZSBMaWNlbnNlLCBvcgojIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uCiMKIyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwKIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZgojIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUKIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLgojCiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UKIyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gIElmIG5vdCwgc2VlIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8gLgoKIyBpZiAtLXRlZSB3YXMgcGFzc2VkLCB3cml0ZSB0aGUgb3V0cHV0IG5vdCBvbmx5IHRvIHRoZSB0ZXJtaW5hbCwgYnV0CiMgYWRkaXRpb25hbGx5IHRvIHRoZSBmaWxlIHRlc3QtcmVzdWx0cy8kQkFTRU5BTUUub3V0LCB0b28uCmNhc2UgIiRHSVRfVEVTVF9URUVfU1RBUlRFRCwgJCogIiBpbgpkb25lLCopCgkjIGRvIG5vdCByZWRpcmVjdCBhZ2FpbgoJOzsKKicgLS10ZWUgJyp8KicgLS12YScqKQoJbWtkaXIgLXAgdGVzdC1yZXN1bHRzCglCQVNFPXRlc3QtcmVzdWx0cy8kKGJhc2VuYW1lICIkMCIgLnNoKQoJKEdJVF9URVNUX1RFRV9TVEFSVEVEPWRvbmUgJHtTSEVMTC1zaH0gIiQwIiAiJEAiIDI+JjE7CgkgZWNobyAkPyA+ICRCQVNFLmV4aXQpIHwgdGVlICRCQVNFLm91dAoJdGVzdCAiJChjYXQgJEJBU0UuZXhpdCkiID0gMAoJZXhpdAoJOzsKZXNhYwoKIyBLZWVwIHRoZSBvcmlnaW5hbCBURVJNIGZvciBzYXlfY29sb3IKT1JJR0lOQUxfVEVSTT0kVEVSTQoKIyBUZXN0IHRoZSBiaW5hcmllcyB3ZSBoYXZlIGp1c3QgYnVpbHQuICBUaGUgdGVzdHMgYXJlIGtlcHQgaW4KIyB0LyBzdWJkaXJlY3RvcnkgYW5kIGFyZSBydW4gaW4gJ3RyYXNoIGRpcmVjdG9yeScgc3ViZGlyZWN0b3J5LgppZiB0ZXN0IC16ICIkVEVTVF9ESVJFQ1RPUlkiCnRoZW4KCSMgV2UgYWxsb3cgdGVzdHMgdG8gb3ZlcnJpZGUgdGhpcywgaW4gY2FzZSB0aGV5IHdhbnQgdG8gcnVuIHRlc3RzCgkjIG91dHNpZGUgb2YgdC8sIGUuZy4gZm9yIHJ1bm5pbmcgdGVzdHMgb24gdGhlIHRlc3QgbGlicmFyeQoJIyBpdHNlbGYuCglURVNUX0RJUkVDVE9SWT0kKHB3ZCkKZmkKaWYgdGVzdCAteiAiJFRFU1RfT1VUUFVUX0RJUkVDVE9SWSIKdGhlbgoJIyBTaW1pbGFybHksIG92ZXJyaWRlIHRoaXMgdG8gc3RvcmUgdGhlIHRlc3QtcmVzdWx0cyBzdWJkaXIKCSMgZWxzZXdoZXJlCglURVNUX09VVFBVVF9ESVJFQ1RPUlk9JFRFU1RfRElSRUNUT1JZCmZpCkdJVF9CVUlMRF9ESVI9IiRURVNUX0RJUkVDVE9SWSIvLi4KCi4gIiRHSVRfQlVJTERfRElSIi9HSVQtQlVJTEQtT1BUSU9OUwpleHBvcnQgUEVSTF9QQVRIIFNIRUxMX1BBVEgKCiMgRm9yIHJlcGVhdGFiaWxpdHksIHJlc2V0IHRoZSBlbnZpcm9ubWVudCB0byBrbm93biB2YWx1ZS4KTEFORz1DCkxDX0FMTD1DClBBR0VSPWNhdApUWj1VVEMKVEVSTT1kdW1iCmV4cG9ydCBMQU5HIExDX0FMTCBQQUdFUiBURVJNIFRaCkVESVRPUj06CiMgQSBjYWxsIHRvICJ1bnNldCIgd2l0aCBubyBhcmd1bWVudHMgY2F1c2VzIGF0IGxlYXN0IFNvbGFyaXMgMTAKIyAvdXNyL3hwZzQvYmluL3NoIGFuZCAvYmluL2tzaCB0byBiYWlsIG91dC4gIFNvIGtlZXAgdGhlIHVuc2V0cwojIGRlcml2aW5nIGZyb20gdGhlIGNvbW1hbmQgc3Vic3RpdHV0aW9uIGNsdXN0ZXJlZCB3aXRoIHRoZSBvdGhlcgojIG9uZXMuCnVuc2V0IFZJU1VBTCBFTUFJTCBMQU5HVUFHRSBDT0xVTU5TICQoIiRQRVJMX1BBVEgiIC1lICcKCW15IEBlbnYgPSBrZXlzICVFTlY7CglteSAkb2sgPSBqb2luKCJ8IiwgcXcoCgkJVFJBQ0UKCQlERUJVRwoJCVVTRV9MT09LVVAKCQlURVNUCgkJLipfVEVTVAoJCVBST1ZFCgkJVkFMR1JJTkQKCQlQRVJGX0FHR1JFR0FUSU5HX0xBVEVSCgkpKTsKCW15IEB2YXJzID0gZ3JlcCgvXkdJVF8vICYmICEvXkdJVF8oJG9rKS9vLCBAZW52KTsKCXByaW50IGpvaW4oIlxuIiwgQHZhcnMpOwonKQp1bnNldCBYREdfQ09ORklHX0hPTUUKR0lUX0FVVEhPUl9FTUFJTD1hdXRob3JAZXhhbXBsZS5jb20KR0lUX0FVVEhPUl9OQU1FPSdBIFUgVGhvcicKR0lUX0NPTU1JVFRFUl9FTUFJTD1jb21taXR0ZXJAZXhhbXBsZS5jb20KR0lUX0NPTU1JVFRFUl9OQU1FPSdDIE8gTWl0dGVyJwpHSVRfTUVSR0VfVkVSQk9TSVRZPTUKR0lUX01FUkdFX0FVVE9FRElUPW5vCmV4cG9ydCBHSVRfTUVSR0VfVkVSQk9TSVRZIEdJVF9NRVJHRV9BVVRPRURJVApleHBvcnQgR0lUX0FVVEhPUl9FTUFJTCBHSVRfQVVUSE9SX05BTUUKZXhwb3J0IEdJVF9DT01NSVRURVJfRU1BSUwgR0lUX0NPTU1JVFRFUl9OQU1FCmV4cG9ydCBFRElUT1IKCiMgUHJvdGVjdCBvdXJzZWx2ZXMgZnJvbSBjb21tb24gbWlzY29uZmlndXJhdGlvbiB0byBleHBvcnQKIyBDRFBBVEggaW50byB0aGUgZW52aXJvbm1lbnQKdW5zZXQgQ0RQQVRICgp1bnNldCBHUkVQX09QVElPTlMKCmNhc2UgJChlY2hvICRHSVRfVFJBQ0UgfHRyICJbQS1aXSIgIlthLXpdIikgaW4KMXwyfHRydWUpCgllY2hvICIqIHdhcm5pbmc6IFNvbWUgdGVzdHMgd2lsbCBub3Qgd29yayBpZiBHSVRfVFJBQ0UiIFwKCQkiaXMgc2V0IGFzIHRvIHRyYWNlIG9uIFNUREVSUiAhICoiCgllY2hvICIqIHdhcm5pbmc6IFBsZWFzZSBzZXQgR0lUX1RSQUNFIHRvIHNvbWV0aGluZyIgXAoJCSJvdGhlciB0aGFuIDEsIDIgb3IgdHJ1ZSAhICoiCgk7Owplc2FjCgojIENvbnZlbmllbmNlCiMKIyBBIHJlZ2V4cCB0byBtYXRjaCA1IGFuZCA0MCBoZXhkaWdpdHMKX3gwNT0nWzAtOWEtZl1bMC05YS1mXVswLTlhLWZdWzAtOWEtZl1bMC05YS1mXScKX3g0MD0iJF94MDUkX3gwNSRfeDA1JF94MDUkX3gwNSRfeDA1JF94MDUkX3gwNSIKCiMgWmVybyBTSEEtMQpfejQwPTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKCiMgTGluZSBmZWVkCkxGPScKJwoKZXhwb3J0IF94MDUgX3g0MCBfejQwIExGCgojIEVhY2ggdGVzdCBzaG91bGQgc3RhcnQgd2l0aCBzb21ldGhpbmcgbGlrZSB0aGlzLCBhZnRlciBjb3B5cmlnaHQgbm90aWNlczoKIwojIHRlc3RfZGVzY3JpcHRpb249J0Rlc2NyaXB0aW9uIG9mIHRoaXMgdGVzdC4uLgojIFRoaXMgdGVzdCBjaGVja3MgaWYgY29tbWFuZCB4eXp6eSBkb2VzIHRoZSByaWdodCB0aGluZy4uLgojICcKIyAuIC4vdGVzdC1saWIuc2gKWyAieCRPUklHSU5BTF9URVJNIiAhPSAieGR1bWIiIF0gJiYgKAoJCVRFUk09JE9SSUdJTkFMX1RFUk0gJiYKCQlleHBvcnQgVEVSTSAmJgoJCVsgLXQgMSBdICYmCgkJdHB1dCBib2xkID4vZGV2L251bGwgMj4mMSAmJgoJCXRwdXQgc2V0YWYgMSA+L2Rldi9udWxsIDI+JjEgJiYKCQl0cHV0IHNncjAgPi9kZXYvbnVsbCAyPiYxCgkpICYmCgljb2xvcj10Cgp3aGlsZSB0ZXN0ICIkIyIgLW5lIDAKZG8KCWNhc2UgIiQxIiBpbgoJLWR8LS1kfC0tZGV8LS1kZWJ8LS1kZWJ1fC0tZGVidWcpCgkJZGVidWc9dDsgc2hpZnQgOzsKCS1pfC0taXwtLWltfC0taW1tfC0taW1tZXwtLWltbWVkfC0taW1tZWRpfC0taW1tZWRpYXwtLWltbWVkaWF0fC0taW1tZWRpYXRlKQoJCWltbWVkaWF0ZT10OyBzaGlmdCA7OwoJLWx8LS1sfC0tbG98LS1sb258LS1sb25nfC0tbG9uZy18LS1sb25nLXR8LS1sb25nLXRlfC0tbG9uZy10ZXN8LS1sb25nLXRlc3R8LS1sb25nLXRlc3RzKQoJCUdJVF9URVNUX0xPTkc9dDsgZXhwb3J0IEdJVF9URVNUX0xPTkc7IHNoaWZ0IDs7CgktaHwtLWh8LS1oZXwtLWhlbHwtLWhlbHApCgkJaGVscD10OyBzaGlmdCA7OwoJLXZ8LS12fC0tdmV8LS12ZXJ8LS12ZXJifC0tdmVyYm98LS12ZXJib3N8LS12ZXJib3NlKQoJCXZlcmJvc2U9dDsgc2hpZnQgOzsKCS1xfC0tcXwtLXF1fC0tcXVpfC0tcXVpZXwtLXF1aWV0KQoJCSMgSWdub3JlIC0tcXVpZXQgdW5kZXIgYSBUQVA6Okhhcm5lc3MuIFNheWluZyBob3cgbWFueSB0ZXN0cwoJCSMgcGFzc2VkIHdpdGhvdXQgdGhlIG9rL25vdCBvayBkZXRhaWxzIGlzIGFsd2F5cyBhbiBlcnJvci4KCQl0ZXN0IC16ICIkSEFSTkVTU19BQ1RJVkUiICYmIHF1aWV0PXQ7IHNoaWZ0IDs7CgktLXdpdGgtZGFzaGVzKQoJCXdpdGhfZGFzaGVzPXQ7IHNoaWZ0IDs7CgktLW5vLWNvbG9yKQoJCWNvbG9yPTsgc2hpZnQgOzsKCS0tdmF8LS12YWx8LS12YWxnfC0tdmFsZ3J8LS12YWxncml8LS12YWxncmlufC0tdmFsZ3JpbmQpCgkJdmFsZ3JpbmQ9dDsgdmVyYm9zZT10OyBzaGlmdCA7OwoJLS10ZWUpCgkJc2hpZnQgOzsgIyB3YXMgaGFuZGxlZCBhbHJlYWR5CgktLXJvb3Q9KikKCQlyb290PSQoZXhwciAieiQxIiA6ICd6W149XSo9XCguKlwpJykKCQlzaGlmdCA7OwoJKikKCQllY2hvICJlcnJvcjogdW5rbm93biB0ZXN0IG9wdGlvbiAnJDEnIiA+JjI7IGV4aXQgMSA7OwoJZXNhYwpkb25lCgppZiB0ZXN0IC1uICIkY29sb3IiCnRoZW4KCXNheV9jb2xvciAoKSB7CgkJKAoJCVRFUk09JE9SSUdJTkFMX1RFUk0KCQlleHBvcnQgVEVSTQoJCWNhc2UgIiQxIiBpbgoJCWVycm9yKQoJCQl0cHV0IGJvbGQ7IHRwdXQgc2V0YWYgMTs7ICMgYm9sZCByZWQKCQlza2lwKQoJCQl0cHV0IGJvbGQ7IHRwdXQgc2V0YWYgMjs7ICMgYm9sZCBncmVlbgoJCXBhc3MpCgkJCXRwdXQgc2V0YWYgMjs7ICAgICAgICAgICAgIyBncmVlbgoJCWluZm8pCgkJCXRwdXQgc2V0YWYgMzs7ICAgICAgICAgICAgIyBicm93bgoJCSopCgkJCXRlc3QgLW4gIiRxdWlldCIgJiYgcmV0dXJuOzsKCQllc2FjCgkJc2hpZnQKCQlwcmludGYgIiVzIiAiJCoiCgkJdHB1dCBzZ3IwCgkJZWNobwoJCSkKCX0KZWxzZQoJc2F5X2NvbG9yKCkgewoJCXRlc3QgLXogIiQxIiAmJiB0ZXN0IC1uICIkcXVpZXQiICYmIHJldHVybgoJCXNoaWZ0CgkJZWNobyAiJCoiCgl9CmZpCgplcnJvciAoKSB7CglzYXlfY29sb3IgZXJyb3IgImVycm9yOiAkKiIKCUdJVF9FWElUX09LPXQKCWV4aXQgMQp9CgpzYXkgKCkgewoJc2F5X2NvbG9yIGluZm8gIiQqIgp9Cgp0ZXN0ICIke3Rlc3RfZGVzY3JpcHRpb259IiAhPSAiIiB8fAplcnJvciAiVGVzdCBzY3JpcHQgZGlkIG5vdCBzZXQgdGVzdF9kZXNjcmlwdGlvbi4iCgppZiB0ZXN0ICIkaGVscCIgPSAidCIKdGhlbgoJZWNobyAiJHRlc3RfZGVzY3JpcHRpb24iCglleGl0IDAKZmkKCmV4ZWMgNT4mMQpleGVjIDY8JjAKaWYgdGVzdCAiJHZlcmJvc2UiID0gInQiCnRoZW4KCWV4ZWMgND4mMiAzPiYxCmVsc2UKCWV4ZWMgND4vZGV2L251bGwgMz4vZGV2L251bGwKZmkKCnRlc3RfZmFpbHVyZT0wCnRlc3RfY291bnQ9MAp0ZXN0X2ZpeGVkPTAKdGVzdF9icm9rZW49MAp0ZXN0X3N1Y2Nlc3M9MAoKdGVzdF9leHRlcm5hbF9oYXNfdGFwPTAKCmRpZSAoKSB7Cgljb2RlPSQ/CglpZiB0ZXN0IC1uICIkR0lUX0VYSVRfT0siCgl0aGVuCgkJZXhpdCAkY29kZQoJZWxzZQoJCWVjaG8gPiY1ICJGQVRBTDogVW5leHBlY3RlZCBleGl0IHdpdGggY29kZSAkY29kZSIKCQlleGl0IDEKCWZpCn0KCkdJVF9FWElUX09LPQp0cmFwICdkaWUnIEVYSVQKCiMgVGhlIHVzZXItZmFjaW5nIGZ1bmN0aW9ucyBhcmUgbG9hZGVkIGZyb20gYSBzZXBhcmF0ZSBmaWxlIHNvIHRoYXQKIyB0ZXN0X3BlcmYgc3Vic2hlbGxzIGNhbiBoYXZlIHRoZW0gdG9vCi4gIiRURVNUX0RJUkVDVE9SWS90ZXN0LWxpYi1mdW5jdGlvbnMuc2giCgojIFlvdSBhcmUgbm90IGV4cGVjdGVkIHRvIGNhbGwgdGVzdF9va18gYW5kIHRlc3RfZmFpbHVyZV8gZGlyZWN0bHksIHVzZQojIHRoZSB0ZXh0X2V4cGVjdF8qIGZ1bmN0aW9ucyBpbnN0ZWFkLgoKdGVzdF9va18gKCkgewoJdGVzdF9zdWNjZXNzPSQoKCR0ZXN0X3N1Y2Nlc3MgKyAxKSkKCXNheV9jb2xvciAiIiAib2sgJHRlc3RfY291bnQgLSAkQCIKfQoKdGVzdF9mYWlsdXJlXyAoKSB7Cgl0ZXN0X2ZhaWx1cmU9JCgoJHRlc3RfZmFpbHVyZSArIDEpKQoJc2F5X2NvbG9yIGVycm9yICJub3Qgb2sgLSAkdGVzdF9jb3VudCAkMSIKCXNoaWZ0CgllY2hvICIkQCIgfCBzZWQgLWUgJ3MvXi8jCS8nCgl0ZXN0ICIkaW1tZWRpYXRlIiA9ICIiIHx8IHsgR0lUX0VYSVRfT0s9dDsgZXhpdCAxOyB9Cn0KCnRlc3Rfa25vd25fYnJva2VuX29rXyAoKSB7Cgl0ZXN0X2ZpeGVkPSQoKCR0ZXN0X2ZpeGVkKzEpKQoJc2F5X2NvbG9yICIiICJvayAkdGVzdF9jb3VudCAtICRAICMgVE9ETyBrbm93biBicmVha2FnZSIKfQoKdGVzdF9rbm93bl9icm9rZW5fZmFpbHVyZV8gKCkgewoJdGVzdF9icm9rZW49JCgoJHRlc3RfYnJva2VuKzEpKQoJc2F5X2NvbG9yIHNraXAgIm5vdCBvayAkdGVzdF9jb3VudCAtICRAICMgVE9ETyBrbm93biBicmVha2FnZSIKfQoKdGVzdF9kZWJ1ZyAoKSB7Cgl0ZXN0ICIkZGVidWciID0gIiIgfHwgZXZhbCAiJDEiCn0KCnRlc3RfZXZhbF8gKCkgewoJIyBUaGlzIGlzIGEgc2VwYXJhdGUgZnVuY3Rpb24gYmVjYXVzZSBzb21lIHRlc3RzIHVzZQoJIyAicmV0dXJuIiB0byBlbmQgYSB0ZXN0X2V4cGVjdF9zdWNjZXNzIGJsb2NrIGVhcmx5LgoJZXZhbCA8L2Rldi9udWxsID4mMyAyPiY0ICIkKiIKfQoKdGVzdF9ydW5fICgpIHsKCXRlc3RfY2xlYW51cD06CglleHBlY3RpbmdfZmFpbHVyZT0kMgoJdGVzdF9ldmFsXyAiJDEiCglldmFsX3JldD0kPwoKCWlmIHRlc3QgLXogIiRpbW1lZGlhdGUiIHx8IHRlc3QgJGV2YWxfcmV0ID0gMCB8fCB0ZXN0IC1uICIkZXhwZWN0aW5nX2ZhaWx1cmUiCgl0aGVuCgkJdGVzdF9ldmFsXyAiJHRlc3RfY2xlYW51cCIKCWZpCglpZiB0ZXN0ICIkdmVyYm9zZSIgPSAidCIgJiYgdGVzdCAtbiAiJEhBUk5FU1NfQUNUSVZFIgoJdGhlbgoJCWVjaG8gIiIKCWZpCglyZXR1cm4gIiRldmFsX3JldCIKfQoKdGVzdF9za2lwICgpIHsKCXRlc3RfY291bnQ9JCgoJHRlc3RfY291bnQrMSkpCgl0b19za2lwPQoJZm9yIHNrcCBpbiAkR0lUX1NLSVBfVEVTVFMKCWRvCgkJY2FzZSAkdGhpc190ZXN0LiR0ZXN0X2NvdW50IGluCgkJJHNrcCkKCQkJdG9fc2tpcD10CgkJCWJyZWFrCgkJZXNhYwoJZG9uZQoJaWYgdGVzdCAteiAiJHRvX3NraXAiICYmIHRlc3QgLW4gIiR0ZXN0X3ByZXJlcSIgJiYKCSAgICEgdGVzdF9oYXZlX3ByZXJlcSAiJHRlc3RfcHJlcmVxIgoJdGhlbgoJCXRvX3NraXA9dAoJZmkKCWNhc2UgIiR0b19za2lwIiBpbgoJdCkKCQlvZl9wcmVyZXE9CgkJaWYgdGVzdCAiJG1pc3NpbmdfcHJlcmVxIiAhPSAiJHRlc3RfcHJlcmVxIgoJCXRoZW4KCQkJb2ZfcHJlcmVxPSIgb2YgJHRlc3RfcHJlcmVxIgoJCWZpCgoJCXNheV9jb2xvciBza2lwID4mMyAic2tpcHBpbmcgdGVzdDogJEAiCgkJc2F5X2NvbG9yIHNraXAgIm9rICR0ZXN0X2NvdW50ICMgc2tpcCAkMSAobWlzc2luZyAkbWlzc2luZ19wcmVyZXEke29mX3ByZXJlcX0pIgoJCTogdHJ1ZQoJCTs7CgkqKQoJCWZhbHNlCgkJOzsKCWVzYWMKfQoKIyBzdHViOyBwZXJmLWxpYiBvdmVycmlkZXMgaXQKdGVzdF9hdF9lbmRfaG9va18gKCkgewoJOgp9Cgp0ZXN0X2RvbmUgKCkgewoJR0lUX0VYSVRfT0s9dAoKCWlmIHRlc3QgLXogIiRIQVJORVNTX0FDVElWRSIKCXRoZW4KCQl0ZXN0X3Jlc3VsdHNfZGlyPSIkVEVTVF9PVVRQVVRfRElSRUNUT1JZL3Rlc3QtcmVzdWx0cyIKCQlta2RpciAtcCAiJHRlc3RfcmVzdWx0c19kaXIiCgkJdGVzdF9yZXN1bHRzX3BhdGg9IiR0ZXN0X3Jlc3VsdHNfZGlyLyR7MCUuc2h9LSQkLmNvdW50cyIKCgkJY2F0ID4+IiR0ZXN0X3Jlc3VsdHNfcGF0aCIgPDwtRU9GCgkJdG90YWwgJHRlc3RfY291bnQKCQlzdWNjZXNzICR0ZXN0X3N1Y2Nlc3MKCQlmaXhlZCAkdGVzdF9maXhlZAoJCWJyb2tlbiAkdGVzdF9icm9rZW4KCQlmYWlsZWQgJHRlc3RfZmFpbHVyZQoKCQlFT0YKCWZpCgoJaWYgdGVzdCAiJHRlc3RfZml4ZWQiICE9IDAKCXRoZW4KCQlzYXlfY29sb3IgcGFzcyAiIyBmaXhlZCAkdGVzdF9maXhlZCBrbm93biBicmVha2FnZShzKSIKCWZpCglpZiB0ZXN0ICIkdGVzdF9icm9rZW4iICE9IDAKCXRoZW4KCQlzYXlfY29sb3IgZXJyb3IgIiMgc3RpbGwgaGF2ZSAkdGVzdF9icm9rZW4ga25vd24gYnJlYWthZ2UocykiCgkJbXNnPSJyZW1haW5pbmcgJCgoJHRlc3RfY291bnQtJHRlc3RfYnJva2VuKSkgdGVzdChzKSIKCWVsc2UKCQltc2c9IiR0ZXN0X2NvdW50IHRlc3QocykiCglmaQoJY2FzZSAiJHRlc3RfZmFpbHVyZSIgaW4KCTApCgkJIyBNYXliZSBwcmludCBTS0lQIG1lc3NhZ2UKCQlbIC16ICIkc2tpcF9hbGwiIF0gfHwgc2tpcF9hbGw9IiAjIFNLSVAgJHNraXBfYWxsIgoKCQlpZiB0ZXN0ICR0ZXN0X2V4dGVybmFsX2hhc190YXAgLWVxIDAKCQl0aGVuCgkJCXNheV9jb2xvciBwYXNzICIjIHBhc3NlZCBhbGwgJG1zZyIKCQkJc2F5ICIxLi4kdGVzdF9jb3VudCRza2lwX2FsbCIKCQlmaQoKCQl0ZXN0IC1kICIkcmVtb3ZlX3RyYXNoIiAmJgoJCWNkICIkKGRpcm5hbWUgIiRyZW1vdmVfdHJhc2giKSIgJiYKCQlybSAtcmYgIiQoYmFzZW5hbWUgIiRyZW1vdmVfdHJhc2giKSIKCgkJdGVzdF9hdF9lbmRfaG9va18KCgkJZXhpdCAwIDs7CgoJKikKCQlpZiB0ZXN0ICR0ZXN0X2V4dGVybmFsX2hhc190YXAgLWVxIDAKCQl0aGVuCgkJCXNheV9jb2xvciBlcnJvciAiIyBmYWlsZWQgJHRlc3RfZmFpbHVyZSBhbW9uZyAkbXNnIgoJCQlzYXkgIjEuLiR0ZXN0X2NvdW50IgoJCWZpCgoJCWV4aXQgMSA7OwoKCWVzYWMKfQoKaWYgdGVzdCAtbiAiJHZhbGdyaW5kIgp0aGVuCgltYWtlX3N5bWxpbmsgKCkgewoJCXRlc3QgLWggIiQyIiAmJgoJCXRlc3QgIiQxIiA9ICIkKHJlYWRsaW5rICIkMiIpIiB8fCB7CgkJCSMgYmUgc3VwZXIgcGFyYW5vaWQKCQkJaWYgbWtkaXIgIiQyIi5sb2NrCgkJCXRoZW4KCQkJCXJtIC1mICIkMiIgJiYKCQkJCWxuIC1zICIkMSIgIiQyIiAmJgoJCQkJcm0gLXIgIiQyIi5sb2NrCgkJCWVsc2UKCQkJCXdoaWxlIHRlc3QgLWQgIiQyIi5sb2NrCgkJCQlkbwoJCQkJCXNheSAiV2FpdGluZyBmb3IgbG9jayBvbiAkMi4iCgkJCQkJc2xlZXAgMQoJCQkJZG9uZQoJCQlmaQoJCX0KCX0KCgltYWtlX3ZhbGdyaW5kX3N5bWxpbmsgKCkgewoJCSMgaGFuZGxlIG9ubHkgZXhlY3V0YWJsZXMsIHVubGVzcyB0aGV5IGFyZSBzaGVsbCBsaWJyYXJpZXMgdGhhdAoJCSMgbmVlZCB0byBiZSBpbiB0aGUgZXhlYy1wYXRoLiAgV2Ugd2lsbCBqdXN0IHVzZSAiIyEiIGFzIGEKCQkjIGd1ZXNzIGZvciBhIHNoZWxsLXNjcmlwdCwgc2luY2Ugd2UgaGF2ZSBubyBpZGVhIHdoYXQgdGhlIHVzZXIKCQkjIG1heSBoYXZlIGNvbmZpZ3VyZWQgYXMgdGhlIHNoZWxsIHBhdGguCgkJdGVzdCAteCAiJDEiIHx8CgkJdGVzdCAiIyEiID0gIiQoaGVhZCAtYyAyIDwiJDEiKSIgfHwKCQlyZXR1cm47CgoJCWJhc2U9JChiYXNlbmFtZSAiJDEiKQoJCXN5bWxpbmtfdGFyZ2V0PSRHSVRfQlVJTERfRElSLyRiYXNlCgkJIyBkbyBub3Qgb3ZlcnJpZGUgc2NyaXB0cwoJCWlmIHRlc3QgLXggIiRzeW1saW5rX3RhcmdldCIgJiYKCQkgICAgdGVzdCAhIC1kICIkc3ltbGlua190YXJnZXQiICYmCgkJICAgIHRlc3QgIiMhIiAhPSAiJChoZWFkIC1jIDIgPCAiJHN5bWxpbmtfdGFyZ2V0IikiCgkJdGhlbgoJCQlzeW1saW5rX3RhcmdldD0uLi92YWxncmluZC5zaAoJCWZpCgkJY2FzZSAiJGJhc2UiIGluCgkJKi5zaHwqLnBlcmwpCgkJCXN5bWxpbmtfdGFyZ2V0PS4uL3VucHJvY2Vzc2VkLXNjcmlwdAoJCWVzYWMKCQkjIGNyZWF0ZSB0aGUgbGluaywgb3IgcmVwbGFjZSBpdCBpZiBpdCBpcyBvdXQgb2YgZGF0ZQoJCW1ha2Vfc3ltbGluayAiJHN5bWxpbmtfdGFyZ2V0IiAiJEdJVF9WQUxHUklORC9iaW4vJGJhc2UiIHx8IGV4aXQKCX0KCgkjIG92ZXJyaWRlIGFsbCBnaXQgZXhlY3V0YWJsZXMgaW4gVEVTVF9ESVJFQ1RPUlkvLi4KCUdJVF9WQUxHUklORD0kVEVTVF9ESVJFQ1RPUlkvdmFsZ3JpbmQKCW1rZGlyIC1wICIkR0lUX1ZBTEdSSU5EIi9iaW4KCWZvciBmaWxlIGluICRHSVRfQlVJTERfRElSL2dpdCogJEdJVF9CVUlMRF9ESVIvdGVzdC0qCglkbwoJCW1ha2VfdmFsZ3JpbmRfc3ltbGluayAkZmlsZQoJZG9uZQoJIyBzcGVjaWFsLWNhc2UgdGhlIG1lcmdldG9vbHMgbG9hZGFibGVzCgltYWtlX3N5bWxpbmsgIiRHSVRfQlVJTERfRElSIi9tZXJnZXRvb2xzICIkR0lUX1ZBTEdSSU5EL2Jpbi9tZXJnZXRvb2xzIgoJT0xESUZTPSRJRlMKCUlGUz06Cglmb3IgcGF0aCBpbiAkUEFUSAoJZG8KCQlscyAiJHBhdGgiL2dpdC0qIDI+IC9kZXYvbnVsbCB8CgkJd2hpbGUgcmVhZCBmaWxlCgkJZG8KCQkJbWFrZV92YWxncmluZF9zeW1saW5rICIkZmlsZSIKCQlkb25lCglkb25lCglJRlM9JE9MRElGUwoJUEFUSD0kR0lUX1ZBTEdSSU5EL2JpbjokUEFUSAoJR0lUX0VYRUNfUEFUSD0kR0lUX1ZBTEdSSU5EL2JpbgoJZXhwb3J0IEdJVF9WQUxHUklORAplbGlmIHRlc3QgLW4gIiRHSVRfVEVTVF9JTlNUQUxMRUQiCnRoZW4KCUdJVF9FWEVDX1BBVEg9JCgkR0lUX1RFU1RfSU5TVEFMTEVEL2dpdCAtLWV4ZWMtcGF0aCkgIHx8CgllcnJvciAiQ2Fubm90IHJ1biBnaXQgZnJvbSAkR0lUX1RFU1RfSU5TVEFMTEVELiIKCVBBVEg9JEdJVF9URVNUX0lOU1RBTExFRDokR0lUX0JVSUxEX0RJUjokUEFUSAoJR0lUX0VYRUNfUEFUSD0ke0dJVF9URVNUX0VYRUNfUEFUSDotJEdJVF9FWEVDX1BBVEh9CmVsc2UgIyBub3JtYWwgY2FzZSwgdXNlIC4uL2Jpbi13cmFwcGVycyBvbmx5IHVubGVzcyAkd2l0aF9kYXNoZXM6CglnaXRfYmluX2Rpcj0iJEdJVF9CVUlMRF9ESVIvYmluLXdyYXBwZXJzIgoJaWYgISB0ZXN0IC14ICIkZ2l0X2Jpbl9kaXIvZ2l0IgoJdGhlbgoJCWlmIHRlc3QgLXogIiR3aXRoX2Rhc2hlcyIKCQl0aGVuCgkJCXNheSAiJGdpdF9iaW5fZGlyL2dpdCBpcyBub3QgZXhlY3V0YWJsZTsgdXNpbmcgR0lUX0VYRUNfUEFUSCIKCQlmaQoJCXdpdGhfZGFzaGVzPXQKCWZpCglQQVRIPSIkZ2l0X2Jpbl9kaXI6JFBBVEgiCglHSVRfRVhFQ19QQVRIPSRHSVRfQlVJTERfRElSCglpZiB0ZXN0IC1uICIkd2l0aF9kYXNoZXMiCgl0aGVuCgkJUEFUSD0iJEdJVF9CVUlMRF9ESVI6JFBBVEgiCglmaQpmaQpHSVRfVEVNUExBVEVfRElSPSIkR0lUX0JVSUxEX0RJUiIvdGVtcGxhdGVzL2JsdAp1bnNldCBHSVRfQ09ORklHCkdJVF9DT05GSUdfTk9TWVNURU09MQpHSVRfQVRUUl9OT1NZU1RFTT0xCmV4cG9ydCBQQVRIIEdJVF9FWEVDX1BBVEggR0lUX1RFTVBMQVRFX0RJUiBHSVRfQ09ORklHX05PU1lTVEVNIEdJVF9BVFRSX05PU1lTVEVNCgppZiB0ZXN0IC16ICIkR0lUX1RFU1RfQ01QIgp0aGVuCglpZiB0ZXN0IC1uICIkR0lUX1RFU1RfQ01QX1VTRV9DT1BJRURfQ09OVEVYVCIKCXRoZW4KCQlHSVRfVEVTVF9DTVA9IiRESUZGIC1jIgoJZWxzZQoJCUdJVF9URVNUX0NNUD0iJERJRkYgLXUiCglmaQpmaQoKR0lUUEVSTExJQj0iJEdJVF9CVUlMRF9ESVIiL3BlcmwvYmxpYi9saWI6IiRHSVRfQlVJTERfRElSIi9wZXJsL2JsaWIvYXJjaC9hdXRvL0dpdApleHBvcnQgR0lUUEVSTExJQgp0ZXN0IC1kICIkR0lUX0JVSUxEX0RJUiIvdGVtcGxhdGVzL2JsdCB8fCB7CgllcnJvciAiWW91IGhhdmVuJ3QgYnVpbHQgdGhpbmdzIHlldCwgaGF2ZSB5b3U/Igp9CgppZiB0ZXN0IC16ICIkR0lUX1RFU1RfSU5TVEFMTEVEIiAmJiB0ZXN0IC16ICIkTk9fUFlUSE9OIgp0aGVuCglHSVRQWVRIT05MSUI9IiRHSVRfQlVJTERfRElSL2dpdF9yZW1vdGVfaGVscGVycy9idWlsZC9saWIiCglleHBvcnQgR0lUUFlUSE9OTElCCgl0ZXN0IC1kICIkR0lUX0JVSUxEX0RJUiIvZ2l0X3JlbW90ZV9oZWxwZXJzL2J1aWxkIHx8IHsKCQllcnJvciAiWW91IGhhdmVuJ3QgYnVpbHQgZ2l0X3JlbW90ZV9oZWxwZXJzIHlldCwgaGF2ZSB5b3U/IgoJfQpmaQoKaWYgISB0ZXN0IC14ICIkR0lUX0JVSUxEX0RJUiIvdGVzdC1jaG10aW1lCnRoZW4KCWVjaG8gPiYyICdZb3UgbmVlZCB0byBidWlsZCB0ZXN0LWNobXRpbWU6JwoJZWNobyA+JjIgJ1J1biAibWFrZSB0ZXN0LWNobXRpbWUiIGluIHRoZSBzb3VyY2UgKHRvcGxldmVsKSBkaXJlY3RvcnknCglleGl0IDEKZmkKCiMgVGVzdCByZXBvc2l0b3J5CnRlc3Q9InRyYXNoIGRpcmVjdG9yeS4kKGJhc2VuYW1lICIkMCIgLnNoKSIKdGVzdCAtbiAiJHJvb3QiICYmIHRlc3Q9IiRyb290LyR0ZXN0IgpjYXNlICIkdGVzdCIgaW4KLyopIFRSQVNIX0RJUkVDVE9SWT0iJHRlc3QiIDs7CiAqKSBUUkFTSF9ESVJFQ1RPUlk9IiRURVNUX09VVFBVVF9ESVJFQ1RPUlkvJHRlc3QiIDs7CmVzYWMKdGVzdCAhIC16ICIkZGVidWciIHx8IHJlbW92ZV90cmFzaD0kVFJBU0hfRElSRUNUT1JZCnJtIC1mciAiJHRlc3QiIHx8IHsKCUdJVF9FWElUX09LPXQKCWVjaG8gPiY1ICJGQVRBTDogQ2Fubm90IHByZXBhcmUgdGVzdCBhcmVhIgoJZXhpdCAxCn0KCkhPTUU9IiRUUkFTSF9ESVJFQ1RPUlkiCmV4cG9ydCBIT01FCgppZiB0ZXN0IC16ICIkVEVTVF9OT19DUkVBVEVfUkVQTyIKdGhlbgoJdGVzdF9jcmVhdGVfcmVwbyAiJHRlc3QiCmVsc2UKCW1rZGlyIC1wICIkdGVzdCIKZmkKIyBVc2UgLVAgdG8gcmVzb2x2ZSBzeW1saW5rcyBpbiBvdXIgd29ya2luZyBkaXJlY3Rvcnkgc28gdGhhdCB0aGUgY3dkCiMgaW4gc3VicHJvY2Vzc2VzIGxpa2UgZ2l0IGVxdWFscyBvdXIgJFBXRCAoZm9yIHBhdGhuYW1lIGNvbXBhcmlzb25zKS4KY2QgLVAgIiR0ZXN0IiB8fCBleGl0IDEKCnRoaXNfdGVzdD0kezAjIyovfQp0aGlzX3Rlc3Q9JHt0aGlzX3Rlc3QlJS0qfQpmb3Igc2twIGluICRHSVRfU0tJUF9URVNUUwpkbwoJY2FzZSAiJHRoaXNfdGVzdCIgaW4KCSRza3ApCgkJc2F5X2NvbG9yIHNraXAgPiYzICJza2lwcGluZyB0ZXN0ICR0aGlzX3Rlc3QgYWx0b2dldGhlciIKCQlza2lwX2FsbD0ic2tpcCBhbGwgdGVzdHMgaW4gJHRoaXNfdGVzdCIKCQl0ZXN0X2RvbmUKCWVzYWMKZG9uZQoKIyBQcm92aWRlIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSAneWVzJyB1dGlsaXR5CnllcyAoKSB7CglpZiB0ZXN0ICQjID0gMAoJdGhlbgoJCXk9eQoJZWxzZQoJCXk9IiQqIgoJZmkKCgl3aGlsZSBlY2hvICIkeSIKCWRvCgkJOgoJZG9uZQp9CgojIEZpeCBzb21lIGNvbW1hbmRzIG9uIFdpbmRvd3MKY2FzZSAkKHVuYW1lIC1zKSBpbgoqTUlOR1cqKQoJIyBXaW5kb3dzIGhhcyBpdHMgb3duIChpbmNvbXBhdGlibGUpIHNvcnQgYW5kIGZpbmQKCXNvcnQgKCkgewoJCS91c3IvYmluL3NvcnQgIiRAIgoJfQoJZmluZCAoKSB7CgkJL3Vzci9iaW4vZmluZCAiJEAiCgl9CglzdW0gKCkgewoJCW1kNXN1bSAiJEAiCgl9CgkjIGdpdCBzZWVzIFdpbmRvd3Mtc3R5bGUgcHdkCglwd2QgKCkgewoJCWJ1aWx0aW4gcHdkIC1XCgl9CgkjIG5vIFBPU0lYIHBlcm1pc3Npb25zCgkjIGJhY2tzbGFzaGVzIGluIHBhdGhzcGVjIGFyZSBjb252ZXJ0ZWQgdG8gJy8nCgkjIGV4ZWMgZG9lcyBub3QgaW5oZXJpdCB0aGUgUElECgl0ZXN0X3NldF9wcmVyZXEgTUlOR1cKCXRlc3Rfc2V0X3ByZXJlcSBTRURfU1RSSVBTX0NSCgk7OwoqQ1lHV0lOKikKCXRlc3Rfc2V0X3ByZXJlcSBQT1NJWFBFUk0KCXRlc3Rfc2V0X3ByZXJlcSBFWEVDS0VFUFNQSUQKCXRlc3Rfc2V0X3ByZXJlcSBOT1RfTUlOR1cKCXRlc3Rfc2V0X3ByZXJlcSBTRURfU1RSSVBTX0NSCgk7OwoqKQoJdGVzdF9zZXRfcHJlcmVxIFBPU0lYUEVSTQoJdGVzdF9zZXRfcHJlcmVxIEJTTEFTSFBTUEVDCgl0ZXN0X3NldF9wcmVyZXEgRVhFQ0tFRVBTUElECgl0ZXN0X3NldF9wcmVyZXEgTk9UX01JTkdXCgk7Owplc2FjCgooIENPTFVNTlM9MSAmJiB0ZXN0ICRDT0xVTU5TID0gMSApICYmIHRlc3Rfc2V0X3ByZXJlcSBDT0xVTU5TX0NBTl9CRV8xCnRlc3QgLXogIiROT19QRVJMIiAmJiB0ZXN0X3NldF9wcmVyZXEgUEVSTAp0ZXN0IC16ICIkTk9fUFlUSE9OIiAmJiB0ZXN0X3NldF9wcmVyZXEgUFlUSE9OCnRlc3QgLW4gIiRVU0VfTElCUENSRSIgJiYgdGVzdF9zZXRfcHJlcmVxIExJQlBDUkUKdGVzdCAteiAiJE5PX0dFVFRFWFQiICYmIHRlc3Rfc2V0X3ByZXJlcSBHRVRURVhUCgojIENhbiB3ZSByZWx5IG9uIGdpdCdzIG91dHB1dCBpbiB0aGUgQyBsb2NhbGU/CmlmIHRlc3QgLW4gIiRHRVRURVhUX1BPSVNPTiIKdGhlbgoJR0lUX0dFVFRFWFRfUE9JU09OPVllc1BsZWFzZQoJZXhwb3J0IEdJVF9HRVRURVhUX1BPSVNPTgoJdGVzdF9zZXRfcHJlcmVxIEdFVFRFWFRfUE9JU09OCmVsc2UKCXRlc3Rfc2V0X3ByZXJlcSBDX0xPQ0FMRV9PVVRQVVQKZmkKCiMgVXNlIHRoaXMgaW5zdGVhZCBvZiB0ZXN0X2NtcCB0byBjb21wYXJlIGZpbGVzIHRoYXQgY29udGFpbiBleHBlY3RlZCBhbmQKIyBhY3R1YWwgb3V0cHV0IGZyb20gZ2l0IGNvbW1hbmRzIHRoYXQgY2FuIGJlIHRyYW5zbGF0ZWQuICBXaGVuIHJ1bm5pbmcKIyB1bmRlciBHRVRURVhUX1BPSVNPTiB0aGlzIHByZXRlbmRzIHRoYXQgdGhlIGNvbW1hbmQgcHJvZHVjZWQgZXhwZWN0ZWQKIyByZXN1bHRzLgp0ZXN0X2kxOG5jbXAgKCkgewoJdGVzdCAtbiAiJEdFVFRFWFRfUE9JU09OIiB8fCB0ZXN0X2NtcCAiJEAiCn0KCiMgVXNlIHRoaXMgaW5zdGVhZCBvZiAiZ3JlcCBleHBlY3RlZC1zdHJpbmcgYWN0dWFsIiB0byBzZWUgaWYgdGhlCiMgb3V0cHV0IGZyb20gYSBnaXQgY29tbWFuZCB0aGF0IGNhbiBiZSB0cmFuc2xhdGVkIGVpdGhlciBjb250YWlucyBhbgojIGV4cGVjdGVkIHN0cmluZywgb3IgZG9lcyBub3QgY29udGFpbiBhbiB1bndhbnRlZCBvbmUuICBXaGVuIHJ1bm5pbmcKIyB1bmRlciBHRVRURVhUX1BPSVNPTiB0aGlzIHByZXRlbmRzIHRoYXQgdGhlIGNvbW1hbmQgcHJvZHVjZWQgZXhwZWN0ZWQKIyByZXN1bHRzLgp0ZXN0X2kxOG5ncmVwICgpIHsKCWlmIHRlc3QgLW4gIiRHRVRURVhUX1BPSVNPTiIKCXRoZW4KCSAgICA6ICMgcHJldGVuZCBzdWNjZXNzCgllbGlmIHRlc3QgInghIiA9ICJ4JDEiCgl0aGVuCgkJc2hpZnQKCQkhIGdyZXAgIiRAIgoJZWxzZQoJCWdyZXAgIiRAIgoJZmkKfQoKIyB0ZXN0IHdoZXRoZXIgdGhlIGZpbGVzeXN0ZW0gc3VwcG9ydHMgc3ltYm9saWMgbGlua3MKbG4gLXMgeCB5IDI+L2Rldi9udWxsICYmIHRlc3QgLWggeSAyPi9kZXYvbnVsbCAmJiB0ZXN0X3NldF9wcmVyZXEgU1lNTElOS1MKcm0gLWYgeQoKIyBXaGVuIHRoZSB0ZXN0cyBhcmUgcnVuIGFzIHJvb3QsIHBlcm1pc3Npb24gdGVzdHMgd2lsbCByZXBvcnQgdGhhdAojIHRoaW5ncyBhcmUgd3JpdGFibGUgd2hlbiB0aGV5IHNob3VsZG4ndCBiZS4KdGVzdCAtdyAvIHx8IHRlc3Rfc2V0X3ByZXJlcSBTQU5JVFkK",
    "text": "#!/bin/sh\n#\n# Copyright (c) 2005 Junio C Hamano\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see http://www.gnu.org/licenses/ .\n\n# if --tee was passed, write the output not only to the terminal, but\n# additionally to the file test-results/$BASENAME.out, too.\ncase \"$GIT_TEST_TEE_STARTED, $* \" in\ndone,*)\n\t# do not redirect again\n\t;;\n*' --tee '*|*' --va'*)\n\tmkdir -p test-results\n\tBASE=test-results/$(basename \"$0\" .sh)\n\t(GIT_TEST_TEE_STARTED=done ${SHELL-sh} \"$0\" \"$@\" 2>&1;\n\t echo $? > $BASE.exit) | tee $BASE.out\n\ttest \"$(cat $BASE.exit)\" = 0\n\texit\n\t;;\nesac\n\n# Keep the original TERM for say_color\nORIGINAL_TERM=$TERM\n\n# Test the binaries we have just built.  The tests are kept in\n# t/ subdirectory and are run in 'trash directory' subdirectory.\nif test -z \"$TEST_DIRECTORY\"\nthen\n\t# We allow tests to override this, in case they want to run tests\n\t# outside of t/, e.g. for running tests on the test library\n\t# itself.\n\tTEST_DIRECTORY=$(pwd)\nfi\nif test -z \"$TEST_OUTPUT_DIRECTORY\"\nthen\n\t# Similarly, override this to store the test-results subdir\n\t# elsewhere\n\tTEST_OUTPUT_DIRECTORY=$TEST_DIRECTORY\nfi\nGIT_BUILD_DIR=\"$TEST_DIRECTORY\"/..\n\n. \"$GIT_BUILD_DIR\"/GIT-BUILD-OPTIONS\nexport PERL_PATH SHELL_PATH\n\n# For repeatability, reset the environment to known value.\nLANG=C\nLC_ALL=C\nPAGER=cat\nTZ=UTC\nTERM=dumb\nexport LANG LC_ALL PAGER TERM TZ\nEDITOR=:\n# A call to \"unset\" with no arguments causes at least Solaris 10\n# /usr/xpg4/bin/sh and /bin/ksh to bail out.  So keep the unsets\n# deriving from the command substitution clustered with the other\n# ones.\nunset VISUAL EMAIL LANGUAGE COLUMNS $(\"$PERL_PATH\" -e '\n\tmy @env = keys %ENV;\n\tmy $ok = join(\"|\", qw(\n\t\tTRACE\n\t\tDEBUG\n\t\tUSE_LOOKUP\n\t\tTEST\n\t\t.*_TEST\n\t\tPROVE\n\t\tVALGRIND\n\t\tPERF_AGGREGATING_LATER\n\t));\n\tmy @vars = grep(/^GIT_/ && !/^GIT_($ok)/o, @env);\n\tprint join(\"\\n\", @vars);\n')\nunset XDG_CONFIG_HOME\nGIT_AUTHOR_EMAIL=author@example.com\nGIT_AUTHOR_NAME='A U Thor'\nGIT_COMMITTER_EMAIL=committer@example.com\nGIT_COMMITTER_NAME='C O Mitter'\nGIT_MERGE_VERBOSITY=5\nGIT_MERGE_AUTOEDIT=no\nexport GIT_MERGE_VERBOSITY GIT_MERGE_AUTOEDIT\nexport GIT_AUTHOR_EMAIL GIT_AUTHOR_NAME\nexport GIT_COMMITTER_EMAIL GIT_COMMITTER_NAME\nexport EDITOR\n\n# Protect ourselves from common misconfiguration to export\n# CDPATH into the environment\nunset CDPATH\n\nunset GREP_OPTIONS\n\ncase $(echo $GIT_TRACE |tr \"[A-Z]\" \"[a-z]\") in\n1|2|true)\n\techo \"* warning: Some tests will not work if GIT_TRACE\" \\\n\t\t\"is set as to trace on STDERR ! *\"\n\techo \"* warning: Please set GIT_TRACE to something\" \\\n\t\t\"other than 1, 2 or true ! *\"\n\t;;\nesac\n\n# Convenience\n#\n# A regexp to match 5 and 40 hexdigits\n_x05='[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]'\n_x40=\"$_x05$_x05$_x05$_x05$_x05$_x05$_x05$_x05\"\n\n# Zero SHA-1\n_z40=0000000000000000000000000000000000000000\n\n# Line feed\nLF='\n'\n\nexport _x05 _x40 _z40 LF\n\n# Each test should start with something like this, after copyright notices:\n#\n# test_description='Description of this test...\n# This test checks if command xyzzy does the right thing...\n# '\n# . ./test-lib.sh\n[ \"x$ORIGINAL_TERM\" != \"xdumb\" ] && (\n\t\tTERM=$ORIGINAL_TERM &&\n\t\texport TERM &&\n\t\t[ -t 1 ] &&\n\t\ttput bold >/dev/null 2>&1 &&\n\t\ttput setaf 1 >/dev/null 2>&1 &&\n\t\ttput sgr0 >/dev/null 2>&1\n\t) &&\n\tcolor=t\n\nwhile test \"$#\" -ne 0\ndo\n\tcase \"$1\" in\n\t-d|--d|--de|--deb|--debu|--debug)\n\t\tdebug=t; shift ;;\n\t-i|--i|--im|--imm|--imme|--immed|--immedi|--immedia|--immediat|--immediate)\n\t\timmediate=t; shift ;;\n\t-l|--l|--lo|--lon|--long|--long-|--long-t|--long-te|--long-tes|--long-test|--long-tests)\n\t\tGIT_TEST_LONG=t; export GIT_TEST_LONG; shift ;;\n\t-h|--h|--he|--hel|--help)\n\t\thelp=t; shift ;;\n\t-v|--v|--ve|--ver|--verb|--verbo|--verbos|--verbose)\n\t\tverbose=t; shift ;;\n\t-q|--q|--qu|--qui|--quie|--quiet)\n\t\t# Ignore --quiet under a TAP::Harness. Saying how many tests\n\t\t# passed without the ok/not ok details is always an error.\n\t\ttest -z \"$HARNESS_ACTIVE\" && quiet=t; shift ;;\n\t--with-dashes)\n\t\twith_dashes=t; shift ;;\n\t--no-color)\n\t\tcolor=; shift ;;\n\t--va|--val|--valg|--valgr|--valgri|--valgrin|--valgrind)\n\t\tvalgrind=t; verbose=t; shift ;;\n\t--tee)\n\t\tshift ;; # was handled already\n\t--root=*)\n\t\troot=$(expr \"z$1\" : 'z[^=]*=\\(.*\\)')\n\t\tshift ;;\n\t*)\n\t\techo \"error: unknown test option '$1'\" >&2; exit 1 ;;\n\tesac\ndone\n\nif test -n \"$color\"\nthen\n\tsay_color () {\n\t\t(\n\t\tTERM=$ORIGINAL_TERM\n\t\texport TERM\n\t\tcase \"$1\" in\n\t\terror)\n\t\t\ttput bold; tput setaf 1;; # bold red\n\t\tskip)\n\t\t\ttput bold; tput setaf 2;; # bold green\n\t\tpass)\n\t\t\ttput setaf 2;;            # green\n\t\tinfo)\n\t\t\ttput setaf 3;;            # brown\n\t\t*)\n\t\t\ttest -n \"$quiet\" && return;;\n\t\tesac\n\t\tshift\n\t\tprintf \"%s\" \"$*\"\n\t\ttput sgr0\n\t\techo\n\t\t)\n\t}\nelse\n\tsay_color() {\n\t\ttest -z \"$1\" && test -n \"$quiet\" && return\n\t\tshift\n\t\techo \"$*\"\n\t}\nfi\n\nerror () {\n\tsay_color error \"error: $*\"\n\tGIT_EXIT_OK=t\n\texit 1\n}\n\nsay () {\n\tsay_color info \"$*\"\n}\n\ntest \"${test_description}\" != \"\" ||\nerror \"Test script did not set test_description.\"\n\nif test \"$help\" = \"t\"\nthen\n\techo \"$test_description\"\n\texit 0\nfi\n\nexec 5>&1\nexec 6<&0\nif test \"$verbose\" = \"t\"\nthen\n\texec 4>&2 3>&1\nelse\n\texec 4>/dev/null 3>/dev/null\nfi\n\ntest_failure=0\ntest_count=0\ntest_fixed=0\ntest_broken=0\ntest_success=0\n\ntest_external_has_tap=0\n\ndie () {\n\tcode=$?\n\tif test -n \"$GIT_EXIT_OK\"\n\tthen\n\t\texit $code\n\telse\n\t\techo >&5 \"FATAL: Unexpected exit with code $code\"\n\t\texit 1\n\tfi\n}\n\nGIT_EXIT_OK=\ntrap 'die' EXIT\n\n# The user-facing functions are loaded from a separate file so that\n# test_perf subshells can have them too\n. \"$TEST_DIRECTORY/test-lib-functions.sh\"\n\n# You are not expected to call test_ok_ and test_failure_ directly, use\n# the text_expect_* functions instead.\n\ntest_ok_ () {\n\ttest_success=$(($test_success + 1))\n\tsay_color \"\" \"ok $test_count - $@\"\n}\n\ntest_failure_ () {\n\ttest_failure=$(($test_failure + 1))\n\tsay_color error \"not ok - $test_count $1\"\n\tshift\n\techo \"$@\" | sed -e 's/^/#\t/'\n\ttest \"$immediate\" = \"\" || { GIT_EXIT_OK=t; exit 1; }\n}\n\ntest_known_broken_ok_ () {\n\ttest_fixed=$(($test_fixed+1))\n\tsay_color \"\" \"ok $test_count - $@ # TODO known breakage\"\n}\n\ntest_known_broken_failure_ () {\n\ttest_broken=$(($test_broken+1))\n\tsay_color skip \"not ok $test_count - $@ # TODO known breakage\"\n}\n\ntest_debug () {\n\ttest \"$debug\" = \"\" || eval \"$1\"\n}\n\ntest_eval_ () {\n\t# This is a separate function because some tests use\n\t# \"return\" to end a test_expect_success block early.\n\teval </dev/null >&3 2>&4 \"$*\"\n}\n\ntest_run_ () {\n\ttest_cleanup=:\n\texpecting_failure=$2\n\ttest_eval_ \"$1\"\n\teval_ret=$?\n\n\tif test -z \"$immediate\" || test $eval_ret = 0 || test -n \"$expecting_failure\"\n\tthen\n\t\ttest_eval_ \"$test_cleanup\"\n\tfi\n\tif test \"$verbose\" = \"t\" && test -n \"$HARNESS_ACTIVE\"\n\tthen\n\t\techo \"\"\n\tfi\n\treturn \"$eval_ret\"\n}\n\ntest_skip () {\n\ttest_count=$(($test_count+1))\n\tto_skip=\n\tfor skp in $GIT_SKIP_TESTS\n\tdo\n\t\tcase $this_test.$test_count in\n\t\t$skp)\n\t\t\tto_skip=t\n\t\t\tbreak\n\t\tesac\n\tdone\n\tif test -z \"$to_skip\" && test -n \"$test_prereq\" &&\n\t   ! test_have_prereq \"$test_prereq\"\n\tthen\n\t\tto_skip=t\n\tfi\n\tcase \"$to_skip\" in\n\tt)\n\t\tof_prereq=\n\t\tif test \"$missing_prereq\" != \"$test_prereq\"\n\t\tthen\n\t\t\tof_prereq=\" of $test_prereq\"\n\t\tfi\n\n\t\tsay_color skip >&3 \"skipping test: $@\"\n\t\tsay_color skip \"ok $test_count # skip $1 (missing $missing_prereq${of_prereq})\"\n\t\t: true\n\t\t;;\n\t*)\n\t\tfalse\n\t\t;;\n\tesac\n}\n\n# stub; perf-lib overrides it\ntest_at_end_hook_ () {\n\t:\n}\n\ntest_done () {\n\tGIT_EXIT_OK=t\n\n\tif test -z \"$HARNESS_ACTIVE\"\n\tthen\n\t\ttest_results_dir=\"$TEST_OUTPUT_DIRECTORY/test-results\"\n\t\tmkdir -p \"$test_results_dir\"\n\t\ttest_results_path=\"$test_results_dir/${0%.sh}-$$.counts\"\n\n\t\tcat >>\"$test_results_path\" <<-EOF\n\t\ttotal $test_count\n\t\tsuccess $test_success\n\t\tfixed $test_fixed\n\t\tbroken $test_broken\n\t\tfailed $test_failure\n\n\t\tEOF\n\tfi\n\n\tif test \"$test_fixed\" != 0\n\tthen\n\t\tsay_color pass \"# fixed $test_fixed known breakage(s)\"\n\tfi\n\tif test \"$test_broken\" != 0\n\tthen\n\t\tsay_color error \"# still have $test_broken known breakage(s)\"\n\t\tmsg=\"remaining $(($test_count-$test_broken)) test(s)\"\n\telse\n\t\tmsg=\"$test_count test(s)\"\n\tfi\n\tcase \"$test_failure\" in\n\t0)\n\t\t# Maybe print SKIP message\n\t\t[ -z \"$skip_all\" ] || skip_all=\" # SKIP $skip_all\"\n\n\t\tif test $test_external_has_tap -eq 0\n\t\tthen\n\t\t\tsay_color pass \"# passed all $msg\"\n\t\t\tsay \"1..$test_count$skip_all\"\n\t\tfi\n\n\t\ttest -d \"$remove_trash\" &&\n\t\tcd \"$(dirname \"$remove_trash\")\" &&\n\t\trm -rf \"$(basename \"$remove_trash\")\"\n\n\t\ttest_at_end_hook_\n\n\t\texit 0 ;;\n\n\t*)\n\t\tif test $test_external_has_tap -eq 0\n\t\tthen\n\t\t\tsay_color error \"# failed $test_failure among $msg\"\n\t\t\tsay \"1..$test_count\"\n\t\tfi\n\n\t\texit 1 ;;\n\n\tesac\n}\n\nif test -n \"$valgrind\"\nthen\n\tmake_symlink () {\n\t\ttest -h \"$2\" &&\n\t\ttest \"$1\" = \"$(readlink \"$2\")\" || {\n\t\t\t# be super paranoid\n\t\t\tif mkdir \"$2\".lock\n\t\t\tthen\n\t\t\t\trm -f \"$2\" &&\n\t\t\t\tln -s \"$1\" \"$2\" &&\n\t\t\t\trm -r \"$2\".lock\n\t\t\telse\n\t\t\t\twhile test -d \"$2\".lock\n\t\t\t\tdo\n\t\t\t\t\tsay \"Waiting for lock on $2.\"\n\t\t\t\t\tsleep 1\n\t\t\t\tdone\n\t\t\tfi\n\t\t}\n\t}\n\n\tmake_valgrind_symlink () {\n\t\t# handle only executables, unless they are shell libraries that\n\t\t# need to be in the exec-path.  We will just use \"#!\" as a\n\t\t# guess for a shell-script, since we have no idea what the user\n\t\t# may have configured as the shell path.\n\t\ttest -x \"$1\" ||\n\t\ttest \"#!\" = \"$(head -c 2 <\"$1\")\" ||\n\t\treturn;\n\n\t\tbase=$(basename \"$1\")\n\t\tsymlink_target=$GIT_BUILD_DIR/$base\n\t\t# do not override scripts\n\t\tif test -x \"$symlink_target\" &&\n\t\t    test ! -d \"$symlink_target\" &&\n\t\t    test \"#!\" != \"$(head -c 2 < \"$symlink_target\")\"\n\t\tthen\n\t\t\tsymlink_target=../valgrind.sh\n\t\tfi\n\t\tcase \"$base\" in\n\t\t*.sh|*.perl)\n\t\t\tsymlink_target=../unprocessed-script\n\t\tesac\n\t\t# create the link, or replace it if it is out of date\n\t\tmake_symlink \"$symlink_target\" \"$GIT_VALGRIND/bin/$base\" || exit\n\t}\n\n\t# override all git executables in TEST_DIRECTORY/..\n\tGIT_VALGRIND=$TEST_DIRECTORY/valgrind\n\tmkdir -p \"$GIT_VALGRIND\"/bin\n\tfor file in $GIT_BUILD_DIR/git* $GIT_BUILD_DIR/test-*\n\tdo\n\t\tmake_valgrind_symlink $file\n\tdone\n\t# special-case the mergetools loadables\n\tmake_symlink \"$GIT_BUILD_DIR\"/mergetools \"$GIT_VALGRIND/bin/mergetools\"\n\tOLDIFS=$IFS\n\tIFS=:\n\tfor path in $PATH\n\tdo\n\t\tls \"$path\"/git-* 2> /dev/null |\n\t\twhile read file\n\t\tdo\n\t\t\tmake_valgrind_symlink \"$file\"\n\t\tdone\n\tdone\n\tIFS=$OLDIFS\n\tPATH=$GIT_VALGRIND/bin:$PATH\n\tGIT_EXEC_PATH=$GIT_VALGRIND/bin\n\texport GIT_VALGRIND\nelif test -n \"$GIT_TEST_INSTALLED\"\nthen\n\tGIT_EXEC_PATH=$($GIT_TEST_INSTALLED/git --exec-path)  ||\n\terror \"Cannot run git from $GIT_TEST_INSTALLED.\"\n\tPATH=$GIT_TEST_INSTALLED:$GIT_BUILD_DIR:$PATH\n\tGIT_EXEC_PATH=${GIT_TEST_EXEC_PATH:-$GIT_EXEC_PATH}\nelse # normal case, use ../bin-wrappers only unless $with_dashes:\n\tgit_bin_dir=\"$GIT_BUILD_DIR/bin-wrappers\"\n\tif ! test -x \"$git_bin_dir/git\"\n\tthen\n\t\tif test -z \"$with_dashes\"\n\t\tthen\n\t\t\tsay \"$git_bin_dir/git is not executable; using GIT_EXEC_PATH\"\n\t\tfi\n\t\twith_dashes=t\n\tfi\n\tPATH=\"$git_bin_dir:$PATH\"\n\tGIT_EXEC_PATH=$GIT_BUILD_DIR\n\tif test -n \"$with_dashes\"\n\tthen\n\t\tPATH=\"$GIT_BUILD_DIR:$PATH\"\n\tfi\nfi\nGIT_TEMPLATE_DIR=\"$GIT_BUILD_DIR\"/templates/blt\nunset GIT_CONFIG\nGIT_CONFIG_NOSYSTEM=1\nGIT_ATTR_NOSYSTEM=1\nexport PATH GIT_EXEC_PATH GIT_TEMPLATE_DIR GIT_CONFIG_NOSYSTEM GIT_ATTR_NOSYSTEM\n\nif test -z \"$GIT_TEST_CMP\"\nthen\n\tif test -n \"$GIT_TEST_CMP_USE_COPIED_CONTEXT\"\n\tthen\n\t\tGIT_TEST_CMP=\"$DIFF -c\"\n\telse\n\t\tGIT_TEST_CMP=\"$DIFF -u\"\n\tfi\nfi\n\nGITPERLLIB=\"$GIT_BUILD_DIR\"/perl/blib/lib:\"$GIT_BUILD_DIR\"/perl/blib/arch/auto/Git\nexport GITPERLLIB\ntest -d \"$GIT_BUILD_DIR\"/templates/blt || {\n\terror \"You haven't built things yet, have you?\"\n}\n\nif test -z \"$GIT_TEST_INSTALLED\" && test -z \"$NO_PYTHON\"\nthen\n\tGITPYTHONLIB=\"$GIT_BUILD_DIR/git_remote_helpers/build/lib\"\n\texport GITPYTHONLIB\n\ttest -d \"$GIT_BUILD_DIR\"/git_remote_helpers/build || {\n\t\terror \"You haven't built git_remote_helpers yet, have you?\"\n\t}\nfi\n\nif ! test -x \"$GIT_BUILD_DIR\"/test-chmtime\nthen\n\techo >&2 'You need to build test-chmtime:'\n\techo >&2 'Run \"make test-chmtime\" in the source (toplevel) directory'\n\texit 1\nfi\n\n# Test repository\ntest=\"trash directory.$(basename \"$0\" .sh)\"\ntest -n \"$root\" && test=\"$root/$test\"\ncase \"$test\" in\n/*) TRASH_DIRECTORY=\"$test\" ;;\n *) TRASH_DIRECTORY=\"$TEST_OUTPUT_DIRECTORY/$test\" ;;\nesac\ntest ! -z \"$debug\" || remove_trash=$TRASH_DIRECTORY\nrm -fr \"$test\" || {\n\tGIT_EXIT_OK=t\n\techo >&5 \"FATAL: Cannot prepare test area\"\n\texit 1\n}\n\nHOME=\"$TRASH_DIRECTORY\"\nexport HOME\n\nif test -z \"$TEST_NO_CREATE_REPO\"\nthen\n\ttest_create_repo \"$test\"\nelse\n\tmkdir -p \"$test\"\nfi\n# Use -P to resolve symlinks in our working directory so that the cwd\n# in subprocesses like git equals our $PWD (for pathname comparisons).\ncd -P \"$test\" || exit 1\n\nthis_test=${0##*/}\nthis_test=${this_test%%-*}\nfor skp in $GIT_SKIP_TESTS\ndo\n\tcase \"$this_test\" in\n\t$skp)\n\t\tsay_color skip >&3 \"skipping test $this_test altogether\"\n\t\tskip_all=\"skip all tests in $this_test\"\n\t\ttest_done\n\tesac\ndone\n\n# Provide an implementation of the 'yes' utility\nyes () {\n\tif test $# = 0\n\tthen\n\t\ty=y\n\telse\n\t\ty=\"$*\"\n\tfi\n\n\twhile echo \"$y\"\n\tdo\n\t\t:\n\tdone\n}\n\n# Fix some commands on Windows\ncase $(uname -s) in\n*MINGW*)\n\t# Windows has its own (incompatible) sort and find\n\tsort () {\n\t\t/usr/bin/sort \"$@\"\n\t}\n\tfind () {\n\t\t/usr/bin/find \"$@\"\n\t}\n\tsum () {\n\t\tmd5sum \"$@\"\n\t}\n\t# git sees Windows-style pwd\n\tpwd () {\n\t\tbuiltin pwd -W\n\t}\n\t# no POSIX permissions\n\t# backslashes in pathspec are converted to '/'\n\t# exec does not inherit the PID\n\ttest_set_prereq MINGW\n\ttest_set_prereq SED_STRIPS_CR\n\t;;\n*CYGWIN*)\n\ttest_set_prereq POSIXPERM\n\ttest_set_prereq EXECKEEPSPID\n\ttest_set_prereq NOT_MINGW\n\ttest_set_prereq SED_STRIPS_CR\n\t;;\n*)\n\ttest_set_prereq POSIXPERM\n\ttest_set_prereq BSLASHPSPEC\n\ttest_set_prereq EXECKEEPSPID\n\ttest_set_prereq NOT_MINGW\n\t;;\nesac\n\n( COLUMNS=1 && test $COLUMNS = 1 ) && test_set_prereq COLUMNS_CAN_BE_1\ntest -z \"$NO_PERL\" && test_set_prereq PERL\ntest -z \"$NO_PYTHON\" && test_set_prereq PYTHON\ntest -n \"$USE_LIBPCRE\" && test_set_prereq LIBPCRE\ntest -z \"$NO_GETTEXT\" && test_set_prereq GETTEXT\n\n# Can we rely on git's output in the C locale?\nif test -n \"$GETTEXT_POISON\"\nthen\n\tGIT_GETTEXT_POISON=YesPlease\n\texport GIT_GETTEXT_POISON\n\ttest_set_prereq GETTEXT_POISON\nelse\n\ttest_set_prereq C_LOCALE_OUTPUT\nfi\n\n# Use this instead of test_cmp to compare files that contain expected and\n# actual output from git commands that can be translated.  When running\n# under GETTEXT_POISON this pretends that the command produced expected\n# results.\ntest_i18ncmp () {\n\ttest -n \"$GETTEXT_POISON\" || test_cmp \"$@\"\n}\n\n# Use this instead of \"grep expected-string actual\" to see if the\n# output from a git command that can be translated either contains an\n# expected string, or does not contain an unwanted one.  When running\n# under GETTEXT_POISON this pretends that the command produced expected\n# results.\ntest_i18ngrep () {\n\tif test -n \"$GETTEXT_POISON\"\n\tthen\n\t    : # pretend success\n\telif test \"x!\" = \"x$1\"\n\tthen\n\t\tshift\n\t\t! grep \"$@\"\n\telse\n\t\tgrep \"$@\"\n\tfi\n}\n\n# test whether the filesystem supports symbolic links\nln -s x y 2>/dev/null && test -h y 2>/dev/null && test_set_prereq SYMLINKS\nrm -f y\n\n# When the tests are run as root, permission tests will report that\n# things are writable when they shouldn't be.\ntest -w / || test_set_prereq SANITY\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "007d7b20d8fe1be0f69e76215d51632c7df17205",
  "sha1_ok": true,
  "size": 15534
}
