{
  "content": {
    "base64": "I2lmbmRlZiBDQUNIRV9ICiNkZWZpbmUgQ0FDSEVfSAoKI2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAic3RyYnVmLmgiCiNpbmNsdWRlICJoYXNobWFwLmgiCiNpbmNsdWRlICJhZHZpY2UuaCIKI2luY2x1ZGUgImdldHRleHQuaCIKI2luY2x1ZGUgImNvbnZlcnQuaCIKCiNpbmNsdWRlIFNIQTFfSEVBREVSCiNpZm5kZWYgZ2l0X1NIQV9DVFgKI2RlZmluZSBnaXRfU0hBX0NUWAlTSEFfQ1RYCiNkZWZpbmUgZ2l0X1NIQTFfSW5pdAlTSEExX0luaXQKI2RlZmluZSBnaXRfU0hBMV9VcGRhdGUJU0hBMV9VcGRhdGUKI2RlZmluZSBnaXRfU0hBMV9GaW5hbAlTSEExX0ZpbmFsCiNlbmRpZgoKI2luY2x1ZGUgPHpsaWIuaD4KdHlwZWRlZiBzdHJ1Y3QgZ2l0X3pzdHJlYW0gewoJel9zdHJlYW0gejsKCXVuc2lnbmVkIGxvbmcgYXZhaWxfaW47Cgl1bnNpZ25lZCBsb25nIGF2YWlsX291dDsKCXVuc2lnbmVkIGxvbmcgdG90YWxfaW47Cgl1bnNpZ25lZCBsb25nIHRvdGFsX291dDsKCXVuc2lnbmVkIGNoYXIgKm5leHRfaW47Cgl1bnNpZ25lZCBjaGFyICpuZXh0X291dDsKfSBnaXRfenN0cmVhbTsKCnZvaWQgZ2l0X2luZmxhdGVfaW5pdChnaXRfenN0cmVhbSAqKTsKdm9pZCBnaXRfaW5mbGF0ZV9pbml0X2d6aXBfb25seShnaXRfenN0cmVhbSAqKTsKdm9pZCBnaXRfaW5mbGF0ZV9lbmQoZ2l0X3pzdHJlYW0gKik7CmludCBnaXRfaW5mbGF0ZShnaXRfenN0cmVhbSAqLCBpbnQgZmx1c2gpOwoKdm9pZCBnaXRfZGVmbGF0ZV9pbml0KGdpdF96c3RyZWFtICosIGludCBsZXZlbCk7CnZvaWQgZ2l0X2RlZmxhdGVfaW5pdF9nemlwKGdpdF96c3RyZWFtICosIGludCBsZXZlbCk7CnZvaWQgZ2l0X2RlZmxhdGVfaW5pdF9yYXcoZ2l0X3pzdHJlYW0gKiwgaW50IGxldmVsKTsKdm9pZCBnaXRfZGVmbGF0ZV9lbmQoZ2l0X3pzdHJlYW0gKik7CmludCBnaXRfZGVmbGF0ZV9hYm9ydChnaXRfenN0cmVhbSAqKTsKaW50IGdpdF9kZWZsYXRlX2VuZF9nZW50bHkoZ2l0X3pzdHJlYW0gKik7CmludCBnaXRfZGVmbGF0ZShnaXRfenN0cmVhbSAqLCBpbnQgZmx1c2gpOwp1bnNpZ25lZCBsb25nIGdpdF9kZWZsYXRlX2JvdW5kKGdpdF96c3RyZWFtICosIHVuc2lnbmVkIGxvbmcpOwoKI2lmIGRlZmluZWQoRFRfVU5LTk9XTikgJiYgIWRlZmluZWQoTk9fRF9UWVBFX0lOX0RJUkVOVCkKI2RlZmluZSBEVFlQRShkZSkJKChkZSktPmRfdHlwZSkKI2Vsc2UKI3VuZGVmIERUX1VOS05PV04KI3VuZGVmIERUX0RJUgojdW5kZWYgRFRfUkVHCiN1bmRlZiBEVF9MTksKI2RlZmluZSBEVF9VTktOT1dOCTAKI2RlZmluZSBEVF9ESVIJCTEKI2RlZmluZSBEVF9SRUcJCTIKI2RlZmluZSBEVF9MTksJCTMKI2RlZmluZSBEVFlQRShkZSkJRFRfVU5LTk9XTgojZW5kaWYKCi8qIHVua25vd24gbW9kZSAoaW1wb3NzaWJsZSBjb21iaW5hdGlvbiBTX0lGSUZPfFNfSUZDSFIpICovCiNkZWZpbmUgU19JRklOVkFMSUQgICAgIDAwMzAwMDAKCi8qCiAqIEEgImRpcmVjdG9yeSBsaW5rIiBpcyBhIGxpbmsgdG8gYW5vdGhlciBnaXQgZGlyZWN0b3J5LgogKgogKiBUaGUgdmFsdWUgMDE2MDAwMCBpcyBub3Qgbm9ybWFsbHkgYSB2YWxpZCBtb2RlLCBhbmQKICogYWxzbyBqdXN0IGhhcHBlbnMgdG8gYmUgU19JRkRJUiArIFNfSUZMTksKICoKICogTk9URSEgV2UgKnJlYWxseSogc2hvdWxkbid0IGRlcGVuZCBvbiB0aGUgU19JRnh4eCBtYWNyb3MKICogYWx3YXlzIGhhdmluZyB0aGUgc2FtZSB2YWx1ZXMgZXZlcnl3aGVyZS4gV2Ugc2hvdWxkIHVzZQogKiBvdXIgaW50ZXJuYWwgZ2l0IHZhbHVlcyBmb3IgdGhlc2UgdGhpbmdzLCBhbmQgdGhlbiB3ZSBjYW4KICogdHJhbnNsYXRlIHRoYXQgdG8gdGhlIE9TLXNwZWNpZmljIHZhbHVlLiBJdCBqdXN0IHNvCiAqIGhhcHBlbnMgdGhhdCBldmVyeWJvZHkgc2hhcmVzIHRoZSBzYW1lIGJpdCByZXByZXNlbnRhdGlvbgogKiBpbiB0aGUgVU5JWCB3b3JsZCAoYW5kIGFwcGFyZW50bHkgd2lkZXIgdG9vLi4pCiAqLwojZGVmaW5lIFNfSUZHSVRMSU5LCTAxNjAwMDAKI2RlZmluZSBTX0lTR0lUTElOSyhtKQkoKChtKSAmIFNfSUZNVCkgPT0gU19JRkdJVExJTkspCgovKgogKiBJbnRlbnNpdmUgcmVzZWFyY2ggb3ZlciB0aGUgY291cnNlIG9mIG1hbnkgeWVhcnMgaGFzIHNob3duIHRoYXQKICogcG9ydCA5NDE4IGlzIHRvdGFsbHkgdW51c2VkIGJ5IGFueXRoaW5nIGVsc2UuIE9yCiAqCiAqCVlvdXIgc2VhcmNoIC0gInBvcnQgOTQxOCIgLSBkaWQgbm90IG1hdGNoIGFueSBkb2N1bWVudHMuCiAqCiAqIGFzIHd3dy5nb29nbGUuY29tIHB1dHMgaXQuCiAqCiAqIFRoaXMgcG9ydCBoYXMgYmVlbiBwcm9wZXJseSBhc3NpZ25lZCBmb3IgZ2l0IHVzZSBieSBJQU5BOgogKiBnaXQgKEFzc2lnbmVkLTk0MTgpIFtJMDYtMDUwNzI4LTAwMDFdLgogKgogKglnaXQgIDk0MTgvdGNwICAgZ2l0IHBhY2sgdHJhbnNmZXIgc2VydmljZQogKglnaXQgIDk0MTgvdWRwICAgZ2l0IHBhY2sgdHJhbnNmZXIgc2VydmljZQogKgogKiB3aXRoIExpbnVzIFRvcnZhbGRzIDx0b3J2YWxkc0Bvc2RsLm9yZz4gYXMgdGhlIHBvaW50IG9mCiAqIGNvbnRhY3QuIFNlcHRlbWJlciAyMDA1LgogKgogKiBTZWUgaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9wb3J0LW51bWJlcnMKICovCiNkZWZpbmUgREVGQVVMVF9HSVRfUE9SVCA5NDE4CgovKgogKiBCYXNpYyBkYXRhIHN0cnVjdHVyZXMgZm9yIHRoZSBkaXJlY3RvcnkgY2FjaGUKICovCgojZGVmaW5lIENBQ0hFX1NJR05BVFVSRSAweDQ0NDk1MjQzCS8qICJESVJDIiAqLwpzdHJ1Y3QgY2FjaGVfaGVhZGVyIHsKCXVpbnQzMl90IGhkcl9zaWduYXR1cmU7Cgl1aW50MzJfdCBoZHJfdmVyc2lvbjsKCXVpbnQzMl90IGhkcl9lbnRyaWVzOwp9OwoKI2RlZmluZSBJTkRFWF9GT1JNQVRfTEIgMgojZGVmaW5lIElOREVYX0ZPUk1BVF9VQiA0CgovKgogKiBUaGUgImNhY2hlX3RpbWUiIGlzIGp1c3QgdGhlIGxvdyAzMiBiaXRzIG9mIHRoZQogKiB0aW1lLiBJdCBkb2Vzbid0IG1hdHRlciBpZiBpdCBvdmVyZmxvd3MgLSB3ZSBvbmx5CiAqIGNoZWNrIGl0IGZvciBlcXVhbGl0eSBpbiB0aGUgMzIgYml0cyB3ZSBzYXZlLgogKi8Kc3RydWN0IGNhY2hlX3RpbWUgewoJdWludDMyX3Qgc2VjOwoJdWludDMyX3QgbnNlYzsKfTsKCnN0cnVjdCBzdGF0X2RhdGEgewoJc3RydWN0IGNhY2hlX3RpbWUgc2RfY3RpbWU7CglzdHJ1Y3QgY2FjaGVfdGltZSBzZF9tdGltZTsKCXVuc2lnbmVkIGludCBzZF9kZXY7Cgl1bnNpZ25lZCBpbnQgc2RfaW5vOwoJdW5zaWduZWQgaW50IHNkX3VpZDsKCXVuc2lnbmVkIGludCBzZF9naWQ7Cgl1bnNpZ25lZCBpbnQgc2Rfc2l6ZTsKfTsKCnN0cnVjdCBjYWNoZV9lbnRyeSB7CglzdHJ1Y3QgaGFzaG1hcF9lbnRyeSBlbnQ7CglzdHJ1Y3Qgc3RhdF9kYXRhIGNlX3N0YXRfZGF0YTsKCXVuc2lnbmVkIGludCBjZV9tb2RlOwoJdW5zaWduZWQgaW50IGNlX2ZsYWdzOwoJdW5zaWduZWQgaW50IGNlX25hbWVsZW47Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJY2hhciBuYW1lW0ZMRVhfQVJSQVldOyAvKiBtb3JlICovCn07CgojZGVmaW5lIENFX1NUQUdFTUFTSyAoMHgzMDAwKQojZGVmaW5lIENFX0VYVEVOREVEICAoMHg0MDAwKQojZGVmaW5lIENFX1ZBTElEICAgICAoMHg4MDAwKQojZGVmaW5lIENFX1NUQUdFU0hJRlQgMTIKCi8qCiAqIFJhbmdlIDB4RkZGRjAwMDAgaW4gY2VfZmxhZ3MgaXMgZGl2aWRlZCBpbnRvCiAqIHR3byBwYXJ0czogaW4tbWVtb3J5IGZsYWdzIGFuZCBvbi1kaXNrIG9uZXMuCiAqIEZsYWdzIGluIENFX0VYVEVOREVEX0ZMQUdTIHdpbGwgZ2V0IHNhdmVkIG9uLWRpc2sKICogaWYgeW91IHdhbnQgdG8gc2F2ZSBhIG5ldyBmbGFnLCBhZGQgaXQgaW4KICogQ0VfRVhURU5ERURfRkxBR1MKICoKICogSW4tbWVtb3J5IG9ubHkgZmxhZ3MKICovCiNkZWZpbmUgQ0VfVVBEQVRFICAgICAgICAgICAgKDEgPDwgMTYpCiNkZWZpbmUgQ0VfUkVNT1ZFICAgICAgICAgICAgKDEgPDwgMTcpCiNkZWZpbmUgQ0VfVVBUT0RBVEUgICAgICAgICAgKDEgPDwgMTgpCiNkZWZpbmUgQ0VfQURERUQgICAgICAgICAgICAgKDEgPDwgMTkpCgojZGVmaW5lIENFX0hBU0hFRCAgICAgICAgICAgICgxIDw8IDIwKQojZGVmaW5lIENFX1dUX1JFTU9WRSAgICAgICAgICgxIDw8IDIyKSAvKiByZW1vdmUgaW4gd29yayBkaXJlY3RvcnkgKi8KI2RlZmluZSBDRV9DT05GTElDVEVEICAgICAgICAoMSA8PCAyMykKCiNkZWZpbmUgQ0VfVU5QQUNLRUQgICAgICAgICAgKDEgPDwgMjQpCiNkZWZpbmUgQ0VfTkVXX1NLSVBfV09SS1RSRUUgKDEgPDwgMjUpCgovKiB1c2VkIHRvIHRlbXBvcmFyaWx5IG1hcmsgcGF0aHMgbWF0Y2hlZCBieSBwYXRoc3BlY3MgKi8KI2RlZmluZSBDRV9NQVRDSEVEICAgICAgICAgICAoMSA8PCAyNikKCi8qCiAqIEV4dGVuZGVkIG9uLWRpc2sgZmxhZ3MKICovCiNkZWZpbmUgQ0VfSU5URU5UX1RPX0FERCAgICAgKDEgPDwgMjkpCiNkZWZpbmUgQ0VfU0tJUF9XT1JLVFJFRSAgICAgKDEgPDwgMzApCi8qIENFX0VYVEVOREVEMiBpcyBmb3IgZnV0dXJlIGV4dGVuc2lvbiAqLwojZGVmaW5lIENFX0VYVEVOREVEMiAgICAgICAgICgxIDw8IDMxKQoKI2RlZmluZSBDRV9FWFRFTkRFRF9GTEFHUyAoQ0VfSU5URU5UX1RPX0FERCB8IENFX1NLSVBfV09SS1RSRUUpCgovKgogKiBTYWZlZ3VhcmQgdG8gYXZvaWQgc2F2aW5nIHdyb25nIGZsYWdzOgogKiAgLSBDRV9FWFRFTkRFRDIgd29uJ3QgZ2V0IHNhdmVkIHVudGlsIGl0cyBzZW1hbnRpYyBpcyBrbm93bgogKiAgLSBCaXRzIGluIDB4MDAwMEZGRkYgaGF2ZSBiZWVuIHNhdmVkIGluIGNlX2ZsYWdzIGFscmVhZHkKICogIC0gQml0cyBpbiAweDAwM0YwMDAwIGFyZSBjdXJyZW50bHkgaW4tbWVtb3J5IGZsYWdzCiAqLwojaWYgQ0VfRVhURU5ERURfRkxBR1MgJiAweDgwM0ZGRkZGCiNlcnJvciAiQ0VfRVhURU5ERURfRkxBR1Mgb3V0IG9mIHJhbmdlIgojZW5kaWYKCnN0cnVjdCBwYXRoc3BlYzsKCi8qCiAqIENvcHkgdGhlIHNoYTEgYW5kIHN0YXQgc3RhdGUgb2YgYSBjYWNoZSBlbnRyeSBmcm9tIG9uZSB0bwogKiBhbm90aGVyLiBCdXQgd2UgbmV2ZXIgY2hhbmdlIHRoZSBuYW1lLCBvciB0aGUgaGFzaCBzdGF0ZSEKICovCnN0YXRpYyBpbmxpbmUgdm9pZCBjb3B5X2NhY2hlX2VudHJ5KHN0cnVjdCBjYWNoZV9lbnRyeSAqZHN0LAoJCQkJICAgIGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqc3JjKQp7Cgl1bnNpZ25lZCBpbnQgc3RhdGUgPSBkc3QtPmNlX2ZsYWdzICYgQ0VfSEFTSEVEOwoKCS8qIERvbid0IGNvcHkgaGFzaCBjaGFpbiBhbmQgbmFtZSAqLwoJbWVtY3B5KCZkc3QtPmNlX3N0YXRfZGF0YSwgJnNyYy0+Y2Vfc3RhdF9kYXRhLAoJCQlvZmZzZXRvZihzdHJ1Y3QgY2FjaGVfZW50cnksIG5hbWUpIC0KCQkJb2Zmc2V0b2Yoc3RydWN0IGNhY2hlX2VudHJ5LCBjZV9zdGF0X2RhdGEpKTsKCgkvKiBSZXN0b3JlIHRoZSBoYXNoIHN0YXRlICovCglkc3QtPmNlX2ZsYWdzID0gKGRzdC0+Y2VfZmxhZ3MgJiB+Q0VfSEFTSEVEKSB8IHN0YXRlOwp9CgpzdGF0aWMgaW5saW5lIHVuc2lnbmVkIGNyZWF0ZV9jZV9mbGFncyh1bnNpZ25lZCBzdGFnZSkKewoJcmV0dXJuIChzdGFnZSA8PCBDRV9TVEFHRVNISUZUKTsKfQoKI2RlZmluZSBjZV9uYW1lbGVuKGNlKSAoKGNlKS0+Y2VfbmFtZWxlbikKI2RlZmluZSBjZV9zaXplKGNlKSBjYWNoZV9lbnRyeV9zaXplKGNlX25hbWVsZW4oY2UpKQojZGVmaW5lIGNlX3N0YWdlKGNlKSAoKENFX1NUQUdFTUFTSyAmIChjZSktPmNlX2ZsYWdzKSA+PiBDRV9TVEFHRVNISUZUKQojZGVmaW5lIGNlX3VwdG9kYXRlKGNlKSAoKGNlKS0+Y2VfZmxhZ3MgJiBDRV9VUFRPREFURSkKI2RlZmluZSBjZV9za2lwX3dvcmt0cmVlKGNlKSAoKGNlKS0+Y2VfZmxhZ3MgJiBDRV9TS0lQX1dPUktUUkVFKQojZGVmaW5lIGNlX21hcmtfdXB0b2RhdGUoY2UpICgoY2UpLT5jZV9mbGFncyB8PSBDRV9VUFRPREFURSkKCiNkZWZpbmUgY2VfcGVybWlzc2lvbnMobW9kZSkgKCgobW9kZSkgJiAwMTAwKSA/IDA3NTUgOiAwNjQ0KQpzdGF0aWMgaW5saW5lIHVuc2lnbmVkIGludCBjcmVhdGVfY2VfbW9kZSh1bnNpZ25lZCBpbnQgbW9kZSkKewoJaWYgKFNfSVNMTksobW9kZSkpCgkJcmV0dXJuIFNfSUZMTks7CglpZiAoU19JU0RJUihtb2RlKSB8fCBTX0lTR0lUTElOSyhtb2RlKSkKCQlyZXR1cm4gU19JRkdJVExJTks7CglyZXR1cm4gU19JRlJFRyB8IGNlX3Blcm1pc3Npb25zKG1vZGUpOwp9CnN0YXRpYyBpbmxpbmUgdW5zaWduZWQgaW50IGNlX21vZGVfZnJvbV9zdGF0KGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCQkJICAgICB1bnNpZ25lZCBpbnQgbW9kZSkKewoJZXh0ZXJuIGludCB0cnVzdF9leGVjdXRhYmxlX2JpdCwgaGFzX3N5bWxpbmtzOwoJaWYgKCFoYXNfc3ltbGlua3MgJiYgU19JU1JFRyhtb2RlKSAmJgoJICAgIGNlICYmIFNfSVNMTksoY2UtPmNlX21vZGUpKQoJCXJldHVybiBjZS0+Y2VfbW9kZTsKCWlmICghdHJ1c3RfZXhlY3V0YWJsZV9iaXQgJiYgU19JU1JFRyhtb2RlKSkgewoJCWlmIChjZSAmJiBTX0lTUkVHKGNlLT5jZV9tb2RlKSkKCQkJcmV0dXJuIGNlLT5jZV9tb2RlOwoJCXJldHVybiBjcmVhdGVfY2VfbW9kZSgwNjY2KTsKCX0KCXJldHVybiBjcmVhdGVfY2VfbW9kZShtb2RlKTsKfQpzdGF0aWMgaW5saW5lIGludCBjZV90b19kdHlwZShjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKQp7Cgl1bnNpZ25lZCBjZV9tb2RlID0gbnRvaGwoY2UtPmNlX21vZGUpOwoJaWYgKFNfSVNSRUcoY2VfbW9kZSkpCgkJcmV0dXJuIERUX1JFRzsKCWVsc2UgaWYgKFNfSVNESVIoY2VfbW9kZSkgfHwgU19JU0dJVExJTksoY2VfbW9kZSkpCgkJcmV0dXJuIERUX0RJUjsKCWVsc2UgaWYgKFNfSVNMTksoY2VfbW9kZSkpCgkJcmV0dXJuIERUX0xOSzsKCWVsc2UKCQlyZXR1cm4gRFRfVU5LTk9XTjsKfQpzdGF0aWMgaW5saW5lIHVuc2lnbmVkIGludCBjYW5vbl9tb2RlKHVuc2lnbmVkIGludCBtb2RlKQp7CglpZiAoU19JU1JFRyhtb2RlKSkKCQlyZXR1cm4gU19JRlJFRyB8IGNlX3Blcm1pc3Npb25zKG1vZGUpOwoJaWYgKFNfSVNMTksobW9kZSkpCgkJcmV0dXJuIFNfSUZMTks7CglpZiAoU19JU0RJUihtb2RlKSkKCQlyZXR1cm4gU19JRkRJUjsKCXJldHVybiBTX0lGR0lUTElOSzsKfQoKI2RlZmluZSBjYWNoZV9lbnRyeV9zaXplKGxlbikgKG9mZnNldG9mKHN0cnVjdCBjYWNoZV9lbnRyeSxuYW1lKSArIChsZW4pICsgMSkKCnN0cnVjdCBpbmRleF9zdGF0ZSB7CglzdHJ1Y3QgY2FjaGVfZW50cnkgKipjYWNoZTsKCXVuc2lnbmVkIGludCB2ZXJzaW9uOwoJdW5zaWduZWQgaW50IGNhY2hlX25yLCBjYWNoZV9hbGxvYywgY2FjaGVfY2hhbmdlZDsKCXN0cnVjdCBzdHJpbmdfbGlzdCAqcmVzb2x2ZV91bmRvOwoJc3RydWN0IGNhY2hlX3RyZWUgKmNhY2hlX3RyZWU7CglzdHJ1Y3QgY2FjaGVfdGltZSB0aW1lc3RhbXA7Cgl1bnNpZ25lZCBuYW1lX2hhc2hfaW5pdGlhbGl6ZWQgOiAxLAoJCSBpbml0aWFsaXplZCA6IDE7CglzdHJ1Y3QgaGFzaG1hcCBuYW1lX2hhc2g7CglzdHJ1Y3QgaGFzaG1hcCBkaXJfaGFzaDsKfTsKCmV4dGVybiBzdHJ1Y3QgaW5kZXhfc3RhdGUgdGhlX2luZGV4OwoKLyogTmFtZSBoYXNoaW5nICovCmV4dGVybiB2b2lkIGFkZF9uYW1lX2hhc2goc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUsIHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UpOwpleHRlcm4gdm9pZCByZW1vdmVfbmFtZV9oYXNoKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKTsKZXh0ZXJuIHZvaWQgZnJlZV9uYW1lX2hhc2goc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUpOwoKCiNpZm5kZWYgTk9fVEhFX0lOREVYX0NPTVBBVElCSUxJVFlfTUFDUk9TCiNkZWZpbmUgYWN0aXZlX2NhY2hlICh0aGVfaW5kZXguY2FjaGUpCiNkZWZpbmUgYWN0aXZlX25yICh0aGVfaW5kZXguY2FjaGVfbnIpCiNkZWZpbmUgYWN0aXZlX2FsbG9jICh0aGVfaW5kZXguY2FjaGVfYWxsb2MpCiNkZWZpbmUgYWN0aXZlX2NhY2hlX2NoYW5nZWQgKHRoZV9pbmRleC5jYWNoZV9jaGFuZ2VkKQojZGVmaW5lIGFjdGl2ZV9jYWNoZV90cmVlICh0aGVfaW5kZXguY2FjaGVfdHJlZSkKCiNkZWZpbmUgcmVhZF9jYWNoZSgpIHJlYWRfaW5kZXgoJnRoZV9pbmRleCkKI2RlZmluZSByZWFkX2NhY2hlX2Zyb20ocGF0aCkgcmVhZF9pbmRleF9mcm9tKCZ0aGVfaW5kZXgsIChwYXRoKSkKI2RlZmluZSByZWFkX2NhY2hlX3ByZWxvYWQocGF0aHNwZWMpIHJlYWRfaW5kZXhfcHJlbG9hZCgmdGhlX2luZGV4LCAocGF0aHNwZWMpKQojZGVmaW5lIGlzX2NhY2hlX3VuYm9ybigpIGlzX2luZGV4X3VuYm9ybigmdGhlX2luZGV4KQojZGVmaW5lIHJlYWRfY2FjaGVfdW5tZXJnZWQoKSByZWFkX2luZGV4X3VubWVyZ2VkKCZ0aGVfaW5kZXgpCiNkZWZpbmUgd3JpdGVfY2FjaGUobmV3ZmQsIGNhY2hlLCBlbnRyaWVzKSB3cml0ZV9pbmRleCgmdGhlX2luZGV4LCAobmV3ZmQpKQojZGVmaW5lIGRpc2NhcmRfY2FjaGUoKSBkaXNjYXJkX2luZGV4KCZ0aGVfaW5kZXgpCiNkZWZpbmUgdW5tZXJnZWRfY2FjaGUoKSB1bm1lcmdlZF9pbmRleCgmdGhlX2luZGV4KQojZGVmaW5lIGNhY2hlX25hbWVfcG9zKG5hbWUsIG5hbWVsZW4pIGluZGV4X25hbWVfcG9zKCZ0aGVfaW5kZXgsKG5hbWUpLChuYW1lbGVuKSkKI2RlZmluZSBhZGRfY2FjaGVfZW50cnkoY2UsIG9wdGlvbikgYWRkX2luZGV4X2VudHJ5KCZ0aGVfaW5kZXgsIChjZSksIChvcHRpb24pKQojZGVmaW5lIHJlbmFtZV9jYWNoZV9lbnRyeV9hdChwb3MsIG5ld19uYW1lKSByZW5hbWVfaW5kZXhfZW50cnlfYXQoJnRoZV9pbmRleCwgKHBvcyksIChuZXdfbmFtZSkpCiNkZWZpbmUgcmVtb3ZlX2NhY2hlX2VudHJ5X2F0KHBvcykgcmVtb3ZlX2luZGV4X2VudHJ5X2F0KCZ0aGVfaW5kZXgsIChwb3MpKQojZGVmaW5lIHJlbW92ZV9maWxlX2Zyb21fY2FjaGUocGF0aCkgcmVtb3ZlX2ZpbGVfZnJvbV9pbmRleCgmdGhlX2luZGV4LCAocGF0aCkpCiNkZWZpbmUgYWRkX3RvX2NhY2hlKHBhdGgsIHN0LCBmbGFncykgYWRkX3RvX2luZGV4KCZ0aGVfaW5kZXgsIChwYXRoKSwgKHN0KSwgKGZsYWdzKSkKI2RlZmluZSBhZGRfZmlsZV90b19jYWNoZShwYXRoLCBmbGFncykgYWRkX2ZpbGVfdG9faW5kZXgoJnRoZV9pbmRleCwgKHBhdGgpLCAoZmxhZ3MpKQojZGVmaW5lIHJlZnJlc2hfY2FjaGUoZmxhZ3MpIHJlZnJlc2hfaW5kZXgoJnRoZV9pbmRleCwgKGZsYWdzKSwgTlVMTCwgTlVMTCwgTlVMTCkKI2RlZmluZSBjZV9tYXRjaF9zdGF0KGNlLCBzdCwgb3B0aW9ucykgaWVfbWF0Y2hfc3RhdCgmdGhlX2luZGV4LCAoY2UpLCAoc3QpLCAob3B0aW9ucykpCiNkZWZpbmUgY2VfbW9kaWZpZWQoY2UsIHN0LCBvcHRpb25zKSBpZV9tb2RpZmllZCgmdGhlX2luZGV4LCAoY2UpLCAoc3QpLCAob3B0aW9ucykpCiNkZWZpbmUgY2FjaGVfZGlyX2V4aXN0cyhuYW1lLCBuYW1lbGVuKSBpbmRleF9kaXJfZXhpc3RzKCZ0aGVfaW5kZXgsIChuYW1lKSwgKG5hbWVsZW4pKQojZGVmaW5lIGNhY2hlX2ZpbGVfZXhpc3RzKG5hbWUsIG5hbWVsZW4sIGlnbmNhc2UpIGluZGV4X2ZpbGVfZXhpc3RzKCZ0aGVfaW5kZXgsIChuYW1lKSwgKG5hbWVsZW4pLCAoaWduY2FzZSkpCiNkZWZpbmUgY2FjaGVfbmFtZV9pc19vdGhlcihuYW1lLCBuYW1lbGVuKSBpbmRleF9uYW1lX2lzX290aGVyKCZ0aGVfaW5kZXgsIChuYW1lKSwgKG5hbWVsZW4pKQojZGVmaW5lIHJlc29sdmVfdW5kb19jbGVhcigpIHJlc29sdmVfdW5kb19jbGVhcl9pbmRleCgmdGhlX2luZGV4KQojZGVmaW5lIHVubWVyZ2VfY2FjaGVfZW50cnlfYXQoYXQpIHVubWVyZ2VfaW5kZXhfZW50cnlfYXQoJnRoZV9pbmRleCwgYXQpCiNkZWZpbmUgdW5tZXJnZV9jYWNoZShwYXRoc3BlYykgdW5tZXJnZV9pbmRleCgmdGhlX2luZGV4LCBwYXRoc3BlYykKI2RlZmluZSByZWFkX2Jsb2JfZGF0YV9mcm9tX2NhY2hlKHBhdGgsIHN6KSByZWFkX2Jsb2JfZGF0YV9mcm9tX2luZGV4KCZ0aGVfaW5kZXgsIChwYXRoKSwgKHN6KSkKI2VuZGlmCgplbnVtIG9iamVjdF90eXBlIHsKCU9CSl9CQUQgPSAtMSwKCU9CSl9OT05FID0gMCwKCU9CSl9DT01NSVQgPSAxLAoJT0JKX1RSRUUgPSAyLAoJT0JKX0JMT0IgPSAzLAoJT0JKX1RBRyA9IDQsCgkvKiA1IGZvciBmdXR1cmUgZXhwYW5zaW9uICovCglPQkpfT0ZTX0RFTFRBID0gNiwKCU9CSl9SRUZfREVMVEEgPSA3LAoJT0JKX0FOWSwKCU9CSl9NQVgKfTsKCnN0YXRpYyBpbmxpbmUgZW51bSBvYmplY3RfdHlwZSBvYmplY3RfdHlwZSh1bnNpZ25lZCBpbnQgbW9kZSkKewoJcmV0dXJuIFNfSVNESVIobW9kZSkgPyBPQkpfVFJFRSA6CgkJU19JU0dJVExJTksobW9kZSkgPyBPQkpfQ09NTUlUIDoKCQlPQkpfQkxPQjsKfQoKLyogRG91YmxlLWNoZWNrIGxvY2FsX3JlcG9fZW52IGJlbG93IGlmIHlvdSBhZGQgdG8gdGhpcyBsaXN0LiAqLwojZGVmaW5lIEdJVF9ESVJfRU5WSVJPTk1FTlQgIkdJVF9ESVIiCiNkZWZpbmUgR0lUX05BTUVTUEFDRV9FTlZJUk9OTUVOVCAiR0lUX05BTUVTUEFDRSIKI2RlZmluZSBHSVRfV09SS19UUkVFX0VOVklST05NRU5UICJHSVRfV09SS19UUkVFIgojZGVmaW5lIEdJVF9QUkVGSVhfRU5WSVJPTk1FTlQgIkdJVF9QUkVGSVgiCiNkZWZpbmUgREVGQVVMVF9HSVRfRElSX0VOVklST05NRU5UICIuZ2l0IgojZGVmaW5lIERCX0VOVklST05NRU5UICJHSVRfT0JKRUNUX0RJUkVDVE9SWSIKI2RlZmluZSBJTkRFWF9FTlZJUk9OTUVOVCAiR0lUX0lOREVYX0ZJTEUiCiNkZWZpbmUgR1JBRlRfRU5WSVJPTk1FTlQgIkdJVF9HUkFGVF9GSUxFIgojZGVmaW5lIEdJVF9TSEFMTE9XX0ZJTEVfRU5WSVJPTk1FTlQgIkdJVF9TSEFMTE9XX0ZJTEUiCiNkZWZpbmUgVEVNUExBVEVfRElSX0VOVklST05NRU5UICJHSVRfVEVNUExBVEVfRElSIgojZGVmaW5lIENPTkZJR19FTlZJUk9OTUVOVCAiR0lUX0NPTkZJRyIKI2RlZmluZSBDT05GSUdfREFUQV9FTlZJUk9OTUVOVCAiR0lUX0NPTkZJR19QQVJBTUVURVJTIgojZGVmaW5lIEVYRUNfUEFUSF9FTlZJUk9OTUVOVCAiR0lUX0VYRUNfUEFUSCIKI2RlZmluZSBDRUlMSU5HX0RJUkVDVE9SSUVTX0VOVklST05NRU5UICJHSVRfQ0VJTElOR19ESVJFQ1RPUklFUyIKI2RlZmluZSBOT19SRVBMQUNFX09CSkVDVFNfRU5WSVJPTk1FTlQgIkdJVF9OT19SRVBMQUNFX09CSkVDVFMiCiNkZWZpbmUgR0lUQVRUUklCVVRFU19GSUxFICIuZ2l0YXR0cmlidXRlcyIKI2RlZmluZSBJTkZPQVRUUklCVVRFU19GSUxFICJpbmZvL2F0dHJpYnV0ZXMiCiNkZWZpbmUgQVRUUklCVVRFX01BQ1JPX1BSRUZJWCAiW2F0dHJdIgojZGVmaW5lIEdJVF9OT1RFU19SRUZfRU5WSVJPTk1FTlQgIkdJVF9OT1RFU19SRUYiCiNkZWZpbmUgR0lUX05PVEVTX0RFRkFVTFRfUkVGICJyZWZzL25vdGVzL2NvbW1pdHMiCiNkZWZpbmUgR0lUX05PVEVTX0RJU1BMQVlfUkVGX0VOVklST05NRU5UICJHSVRfTk9URVNfRElTUExBWV9SRUYiCiNkZWZpbmUgR0lUX05PVEVTX1JFV1JJVEVfUkVGX0VOVklST05NRU5UICJHSVRfTk9URVNfUkVXUklURV9SRUYiCiNkZWZpbmUgR0lUX05PVEVTX1JFV1JJVEVfTU9ERV9FTlZJUk9OTUVOVCAiR0lUX05PVEVTX1JFV1JJVEVfTU9ERSIKI2RlZmluZSBHSVRfTElURVJBTF9QQVRIU1BFQ1NfRU5WSVJPTk1FTlQgIkdJVF9MSVRFUkFMX1BBVEhTUEVDUyIKI2RlZmluZSBHSVRfR0xPQl9QQVRIU1BFQ1NfRU5WSVJPTk1FTlQgIkdJVF9HTE9CX1BBVEhTUEVDUyIKI2RlZmluZSBHSVRfTk9HTE9CX1BBVEhTUEVDU19FTlZJUk9OTUVOVCAiR0lUX05PR0xPQl9QQVRIU1BFQ1MiCiNkZWZpbmUgR0lUX0lDQVNFX1BBVEhTUEVDU19FTlZJUk9OTUVOVCAiR0lUX0lDQVNFX1BBVEhTUEVDUyIKCi8qCiAqIFRoaXMgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgZXhwZWN0ZWQgdG8gY29udGFpbiBhIGJvb2xlYW4gaW5kaWNhdGluZwogKiB3aGV0aGVyIHdlIHNob3VsZCBvciBzaG91bGQgbm90IHRyZWF0OgogKgogKiAgIEdJVF9ESVI9Zm9vLmdpdCBnaXQgLi4uCiAqCiAqIGFzIGlmIEdJVF9XT1JLX1RSRUU9LiB3YXMgZ2l2ZW4uIEl0J3Mgbm90IGV4cGVjdGVkIHRoYXQgdXNlcnMgd2lsbCBtYWtlIHVzZQogKiBvZiB0aGlzLCBidXQgd2UgdXNlIGl0IGludGVybmFsbHkgdG8gY29tbXVuaWNhdGUgdG8gc3ViLXByb2Nlc3NlcyB0aGF0IHdlCiAqIGFyZSBpbiBhIGJhcmUgcmVwby4gSWYgbm90IHNldCwgZGVmYXVsdHMgdG8gdHJ1ZS4KICovCiNkZWZpbmUgR0lUX0lNUExJQ0lUX1dPUktfVFJFRV9FTlZJUk9OTUVOVCAiR0lUX0lNUExJQ0lUX1dPUktfVFJFRSIKCi8qCiAqIFJlcG9zaXRvcnktbG9jYWwgR0lUXyogZW52aXJvbm1lbnQgdmFyaWFibGVzOyB0aGVzZSB3aWxsIGJlIGNsZWFyZWQKICogd2hlbiBnaXQgc3Bhd25zIGEgc3ViLXByb2Nlc3MgdGhhdCBydW5zIGluc2lkZSBhbm90aGVyIHJlcG9zaXRvcnkuCiAqIFRoZSBhcnJheSBpcyBOVUxMLXRlcm1pbmF0ZWQsIHdoaWNoIG1ha2VzIGl0IGVhc3kgdG8gcGFzcyBpbiB0aGUgImVudiIKICogcGFyYW1ldGVyIG9mIGEgcnVuLWNvbW1hbmQgaW52b2NhdGlvbiwgb3IgdG8gZG8gYSBzaW1wbGUgd2Fsay4KICovCmV4dGVybiBjb25zdCBjaGFyICogY29uc3QgbG9jYWxfcmVwb19lbnZbXTsKCmV4dGVybiBpbnQgaXNfYmFyZV9yZXBvc2l0b3J5X2NmZzsKZXh0ZXJuIGludCBpc19iYXJlX3JlcG9zaXRvcnkodm9pZCk7CmV4dGVybiBpbnQgaXNfaW5zaWRlX2dpdF9kaXIodm9pZCk7CmV4dGVybiBjaGFyICpnaXRfd29ya190cmVlX2NmZzsKZXh0ZXJuIGludCBpc19pbnNpZGVfd29ya190cmVlKHZvaWQpOwpleHRlcm4gY29uc3QgY2hhciAqZ2V0X2dpdF9kaXIodm9pZCk7CmV4dGVybiBpbnQgaXNfZ2l0X2RpcmVjdG9yeShjb25zdCBjaGFyICpwYXRoKTsKZXh0ZXJuIGNoYXIgKmdldF9vYmplY3RfZGlyZWN0b3J5KHZvaWQpOwpleHRlcm4gY2hhciAqZ2V0X2luZGV4X2ZpbGUodm9pZCk7CmV4dGVybiBjaGFyICpnZXRfZ3JhZnRfZmlsZSh2b2lkKTsKZXh0ZXJuIGludCBzZXRfZ2l0X2Rpcihjb25zdCBjaGFyICpwYXRoKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdldF9naXRfbmFtZXNwYWNlKHZvaWQpOwpleHRlcm4gY29uc3QgY2hhciAqc3RyaXBfbmFtZXNwYWNlKGNvbnN0IGNoYXIgKm5hbWVzcGFjZWRfcmVmKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdldF9naXRfd29ya190cmVlKHZvaWQpOwpleHRlcm4gY29uc3QgY2hhciAqcmVhZF9naXRmaWxlKGNvbnN0IGNoYXIgKnBhdGgpOwpleHRlcm4gY29uc3QgY2hhciAqcmVzb2x2ZV9naXRkaXIoY29uc3QgY2hhciAqc3VzcGVjdCk7CmV4dGVybiB2b2lkIHNldF9naXRfd29ya190cmVlKGNvbnN0IGNoYXIgKnRyZWUpOwoKI2RlZmluZSBBTFRFUk5BVEVfREJfRU5WSVJPTk1FTlQgIkdJVF9BTFRFUk5BVEVfT0JKRUNUX0RJUkVDVE9SSUVTIgoKZXh0ZXJuIGNvbnN0IGNoYXIgKipnZXRfcGF0aHNwZWMoY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCBjaGFyICoqcGF0aHNwZWMpOwpleHRlcm4gdm9pZCBzZXR1cF93b3JrX3RyZWUodm9pZCk7CmV4dGVybiBjb25zdCBjaGFyICpzZXR1cF9naXRfZGlyZWN0b3J5X2dlbnRseShpbnQgKik7CmV4dGVybiBjb25zdCBjaGFyICpzZXR1cF9naXRfZGlyZWN0b3J5KHZvaWQpOwpleHRlcm4gY2hhciAqcHJlZml4X3BhdGgoY29uc3QgY2hhciAqcHJlZml4LCBpbnQgbGVuLCBjb25zdCBjaGFyICpwYXRoKTsKZXh0ZXJuIGNoYXIgKnByZWZpeF9wYXRoX2dlbnRseShjb25zdCBjaGFyICpwcmVmaXgsIGludCBsZW4sIGludCAqcmVtYWluaW5nLCBjb25zdCBjaGFyICpwYXRoKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKnByZWZpeF9maWxlbmFtZShjb25zdCBjaGFyICpwcmVmaXgsIGludCBsZW4sIGNvbnN0IGNoYXIgKnBhdGgpOwpleHRlcm4gaW50IGNoZWNrX2ZpbGVuYW1lKGNvbnN0IGNoYXIgKnByZWZpeCwgY29uc3QgY2hhciAqbmFtZSk7CmV4dGVybiB2b2lkIHZlcmlmeV9maWxlbmFtZShjb25zdCBjaGFyICpwcmVmaXgsCgkJCSAgICBjb25zdCBjaGFyICpuYW1lLAoJCQkgICAgaW50IGRpYWdub3NlX21pc3NwZWx0X3Jldik7CmV4dGVybiB2b2lkIHZlcmlmeV9ub25fZmlsZW5hbWUoY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCBjaGFyICpuYW1lKTsKZXh0ZXJuIGludCBwYXRoX2luc2lkZV9yZXBvKGNvbnN0IGNoYXIgKnByZWZpeCwgY29uc3QgY2hhciAqcGF0aCk7CgojZGVmaW5lIElOSVRfREJfUVVJRVQgMHgwMDAxCgpleHRlcm4gaW50IHNldF9naXRfZGlyX2luaXQoY29uc3QgY2hhciAqZ2l0X2RpciwgY29uc3QgY2hhciAqcmVhbF9naXRfZGlyLCBpbnQpOwpleHRlcm4gaW50IGluaXRfZGIoY29uc3QgY2hhciAqdGVtcGxhdGVfZGlyLCB1bnNpZ25lZCBpbnQgZmxhZ3MpOwoKZXh0ZXJuIHZvaWQgc2FuaXRpemVfc3RkZmRzKHZvaWQpOwpleHRlcm4gaW50IGRhZW1vbml6ZSh2b2lkKTsKCiNkZWZpbmUgYWxsb2NfbnIoeCkgKCgoeCkrMTYpKjMvMikKCi8qCiAqIFJlYWxsb2MgdGhlIGJ1ZmZlciBwb2ludGVkIGF0IGJ5IHZhcmlhYmxlICd4JyBzbyB0aGF0IGl0IGNhbiBob2xkCiAqIGF0IGxlYXN0ICducicgZW50cmllczsgdGhlIG51bWJlciBvZiBlbnRyaWVzIGN1cnJlbnRseSBhbGxvY2F0ZWQKICogaXMgJ2FsbG9jJywgdXNpbmcgdGhlIHN0YW5kYXJkIGdyb3dpbmcgZmFjdG9yIGFsbG9jX25yKCkgbWFjcm8uCiAqCiAqIERPIE5PVCBVU0UgYW55IGV4cHJlc3Npb24gd2l0aCBzaWRlLWVmZmVjdCBmb3IgJ3gnLCAnbnInLCBvciAnYWxsb2MnLgogKi8KI2RlZmluZSBBTExPQ19HUk9XKHgsIG5yLCBhbGxvYykgXAoJZG8geyBcCgkJaWYgKChucikgPiBhbGxvYykgeyBcCgkJCWlmIChhbGxvY19ucihhbGxvYykgPCAobnIpKSBcCgkJCQlhbGxvYyA9IChucik7IFwKCQkJZWxzZSBcCgkJCQlhbGxvYyA9IGFsbG9jX25yKGFsbG9jKTsgXAoJCQl4ID0geHJlYWxsb2MoKHgpLCBhbGxvYyAqIHNpemVvZigqKHgpKSk7IFwKCQl9IFwKCX0gd2hpbGUgKDApCgovKiBJbml0aWFsaXplIGFuZCB1c2UgdGhlIGNhY2hlIGluZm9ybWF0aW9uICovCmV4dGVybiBpbnQgcmVhZF9pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKik7CmV4dGVybiBpbnQgcmVhZF9pbmRleF9wcmVsb2FkKHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBhdGhzcGVjKTsKZXh0ZXJuIGludCByZWFkX2luZGV4X2Zyb20oc3RydWN0IGluZGV4X3N0YXRlICosIGNvbnN0IGNoYXIgKnBhdGgpOwpleHRlcm4gaW50IGlzX2luZGV4X3VuYm9ybihzdHJ1Y3QgaW5kZXhfc3RhdGUgKik7CmV4dGVybiBpbnQgcmVhZF9pbmRleF91bm1lcmdlZChzdHJ1Y3QgaW5kZXhfc3RhdGUgKik7CmV4dGVybiBpbnQgd3JpdGVfaW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICosIGludCBuZXdmZCk7CmV4dGVybiBpbnQgZGlzY2FyZF9pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKik7CmV4dGVybiBpbnQgdW5tZXJnZWRfaW5kZXgoY29uc3Qgc3RydWN0IGluZGV4X3N0YXRlICopOwpleHRlcm4gaW50IHZlcmlmeV9wYXRoKGNvbnN0IGNoYXIgKnBhdGgpOwpleHRlcm4gc3RydWN0IGNhY2hlX2VudHJ5ICppbmRleF9kaXJfZXhpc3RzKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbik7CmV4dGVybiBzdHJ1Y3QgY2FjaGVfZW50cnkgKmluZGV4X2ZpbGVfZXhpc3RzKHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlLCBjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbiwgaW50IGlnbmNhc2UpOwpleHRlcm4gaW50IGluZGV4X25hbWVfcG9zKGNvbnN0IHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBjb25zdCBjaGFyICpuYW1lLCBpbnQgbmFtZWxlbik7CiNkZWZpbmUgQUREX0NBQ0hFX09LX1RPX0FERCAxCQkvKiBPayB0byBhZGQgKi8KI2RlZmluZSBBRERfQ0FDSEVfT0tfVE9fUkVQTEFDRSAyCS8qIE9rIHRvIHJlcGxhY2UgZmlsZS9kaXJlY3RvcnkgKi8KI2RlZmluZSBBRERfQ0FDSEVfU0tJUF9ERkNIRUNLIDQJLyogT2sgdG8gc2tpcCBERiBjb25mbGljdCBjaGVja3MgKi8KI2RlZmluZSBBRERfQ0FDSEVfSlVTVF9BUFBFTkQgOAkJLyogQXBwZW5kIG9ubHk7IHRyZWUuYzo6cmVhZF90cmVlKCkgKi8KI2RlZmluZSBBRERfQ0FDSEVfTkVXX09OTFkgMTYJCS8qIERvIG5vdCByZXBsYWNlIGV4aXN0aW5nIG9uZXMgKi8KZXh0ZXJuIGludCBhZGRfaW5kZXhfZW50cnkoc3RydWN0IGluZGV4X3N0YXRlICosIHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIGludCBvcHRpb24pOwpleHRlcm4gdm9pZCByZW5hbWVfaW5kZXhfZW50cnlfYXQoc3RydWN0IGluZGV4X3N0YXRlICosIGludCBwb3MsIGNvbnN0IGNoYXIgKm5ld19uYW1lKTsKZXh0ZXJuIGludCByZW1vdmVfaW5kZXhfZW50cnlfYXQoc3RydWN0IGluZGV4X3N0YXRlICosIGludCBwb3MpOwpleHRlcm4gdm9pZCByZW1vdmVfbWFya2VkX2NhY2hlX2VudHJpZXMoc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUpOwpleHRlcm4gaW50IHJlbW92ZV9maWxlX2Zyb21faW5kZXgoc3RydWN0IGluZGV4X3N0YXRlICosIGNvbnN0IGNoYXIgKnBhdGgpOwojZGVmaW5lIEFERF9DQUNIRV9WRVJCT1NFIDEKI2RlZmluZSBBRERfQ0FDSEVfUFJFVEVORCAyCiNkZWZpbmUgQUREX0NBQ0hFX0lHTk9SRV9FUlJPUlMJNAojZGVmaW5lIEFERF9DQUNIRV9JR05PUkVfUkVNT1ZBTCA4CiNkZWZpbmUgQUREX0NBQ0hFX0lOVEVOVCAxNgpleHRlcm4gaW50IGFkZF90b19pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgY29uc3QgY2hhciAqcGF0aCwgc3RydWN0IHN0YXQgKiwgaW50IGZsYWdzKTsKZXh0ZXJuIGludCBhZGRfZmlsZV90b19pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgY29uc3QgY2hhciAqcGF0aCwgaW50IGZsYWdzKTsKZXh0ZXJuIHN0cnVjdCBjYWNoZV9lbnRyeSAqbWFrZV9jYWNoZV9lbnRyeSh1bnNpZ25lZCBpbnQgbW9kZSwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgY29uc3QgY2hhciAqcGF0aCwgaW50IHN0YWdlLCB1bnNpZ25lZCBpbnQgcmVmcmVzaF9vcHRpb25zKTsKZXh0ZXJuIGludCBjZV9zYW1lX25hbWUoY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICphLCBjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmIpOwpleHRlcm4gdm9pZCBzZXRfb2JqZWN0X25hbWVfZm9yX2ludGVudF90b19hZGRfZW50cnkoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSk7CmV4dGVybiBpbnQgaW5kZXhfbmFtZV9pc19vdGhlcihjb25zdCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgY29uc3QgY2hhciAqLCBpbnQpOwpleHRlcm4gdm9pZCAqcmVhZF9ibG9iX2RhdGFfZnJvbV9pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgY29uc3QgY2hhciAqLCB1bnNpZ25lZCBsb25nICopOwoKLyogZG8gc3RhdCBjb21wYXJpc29uIGV2ZW4gaWYgQ0VfVkFMSUQgaXMgdHJ1ZSAqLwojZGVmaW5lIENFX01BVENIX0lHTk9SRV9WQUxJRAkJMDEKLyogZG8gbm90IGNoZWNrIHRoZSBjb250ZW50cyBidXQgcmVwb3J0IGRpcnR5IG9uIHJhY2lseS1jbGVhbiBlbnRyaWVzICovCiNkZWZpbmUgQ0VfTUFUQ0hfUkFDWV9JU19ESVJUWQkJMDIKLyogZG8gc3RhdCBjb21wYXJpc29uIGV2ZW4gaWYgQ0VfU0tJUF9XT1JLVFJFRSBpcyB0cnVlICovCiNkZWZpbmUgQ0VfTUFUQ0hfSUdOT1JFX1NLSVBfV09SS1RSRUUJMDQKLyogaWdub3JlIG5vbi1leGlzdGVudCBmaWxlcyBkdXJpbmcgc3RhdCB1cGRhdGUgICovCiNkZWZpbmUgQ0VfTUFUQ0hfSUdOT1JFX01JU1NJTkcJCTB4MDgKLyogZW5hYmxlIHN0YXQgcmVmcmVzaCAqLwojZGVmaW5lIENFX01BVENIX1JFRlJFU0gJCTB4MTAKZXh0ZXJuIGludCBpZV9tYXRjaF9zdGF0KGNvbnN0IHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKiwgc3RydWN0IHN0YXQgKiwgdW5zaWduZWQgaW50KTsKZXh0ZXJuIGludCBpZV9tb2RpZmllZChjb25zdCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICosIHN0cnVjdCBzdGF0ICosIHVuc2lnbmVkIGludCk7CgojZGVmaW5lIEhBU0hfV1JJVEVfT0JKRUNUIDEKI2RlZmluZSBIQVNIX0ZPUk1BVF9DSEVDSyAyCmV4dGVybiBpbnQgaW5kZXhfZmQodW5zaWduZWQgY2hhciAqc2hhMSwgaW50IGZkLCBzdHJ1Y3Qgc3RhdCAqc3QsIGVudW0gb2JqZWN0X3R5cGUgdHlwZSwgY29uc3QgY2hhciAqcGF0aCwgdW5zaWduZWQgZmxhZ3MpOwpleHRlcm4gaW50IGluZGV4X3BhdGgodW5zaWduZWQgY2hhciAqc2hhMSwgY29uc3QgY2hhciAqcGF0aCwgc3RydWN0IHN0YXQgKnN0LCB1bnNpZ25lZCBmbGFncyk7CgovKgogKiBSZWNvcmQgdG8gc2QgdGhlIGRhdGEgZnJvbSBzdCB0aGF0IHdlIHVzZSB0byBjaGVjayB3aGV0aGVyIGEgZmlsZQogKiBtaWdodCBoYXZlIGNoYW5nZWQuCiAqLwpleHRlcm4gdm9pZCBmaWxsX3N0YXRfZGF0YShzdHJ1Y3Qgc3RhdF9kYXRhICpzZCwgc3RydWN0IHN0YXQgKnN0KTsKCi8qCiAqIFJldHVybiAwIGlmIHN0IGlzIGNvbnNpc3RlbnQgd2l0aCBhIGZpbGUgbm90IGhhdmluZyBiZWVuIGNoYW5nZWQKICogc2luY2Ugc2Qgd2FzIGZpbGxlZC4gIElmIHRoZXJlIGFyZSBkaWZmZXJlbmNlcywgcmV0dXJuIGEKICogY29tYmluYXRpb24gb2YgTVRJTUVfQ0hBTkdFRCwgQ1RJTUVfQ0hBTkdFRCwgT1dORVJfQ0hBTkdFRCwKICogSU5PREVfQ0hBTkdFRCwgYW5kIERBVEFfQ0hBTkdFRC4KICovCmV4dGVybiBpbnQgbWF0Y2hfc3RhdF9kYXRhKGNvbnN0IHN0cnVjdCBzdGF0X2RhdGEgKnNkLCBzdHJ1Y3Qgc3RhdCAqc3QpOwoKZXh0ZXJuIHZvaWQgZmlsbF9zdGF0X2NhY2hlX2luZm8oc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgc3RydWN0IHN0YXQgKnN0KTsKCiNkZWZpbmUgUkVGUkVTSF9SRUFMTFkJCTB4MDAwMQkvKiBpZ25vcmVfdmFsaWQgKi8KI2RlZmluZSBSRUZSRVNIX1VOTUVSR0VECTB4MDAwMgkvKiBhbGxvdyB1bm1lcmdlZCAqLwojZGVmaW5lIFJFRlJFU0hfUVVJRVQJCTB4MDAwNAkvKiBiZSBxdWlldCBhYm91dCBpdCAqLwojZGVmaW5lIFJFRlJFU0hfSUdOT1JFX01JU1NJTkcJMHgwMDA4CS8qIGlnbm9yZSBub24tZXhpc3RlbnQgKi8KI2RlZmluZSBSRUZSRVNIX0lHTk9SRV9TVUJNT0RVTEVTCTB4MDAxMAkvKiBpZ25vcmUgc3VibW9kdWxlcyAqLwojZGVmaW5lIFJFRlJFU0hfSU5fUE9SQ0VMQUlOCTB4MDAyMAkvKiB1c2VyIGZyaWVuZGx5IG91dHB1dCwgbm90ICJuZWVkcyB1cGRhdGUiICovCmV4dGVybiBpbnQgcmVmcmVzaF9pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKiwgdW5zaWduZWQgaW50IGZsYWdzLCBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBhdGhzcGVjLCBjaGFyICpzZWVuLCBjb25zdCBjaGFyICpoZWFkZXJfbXNnKTsKCnN0cnVjdCBsb2NrX2ZpbGUgewoJc3RydWN0IGxvY2tfZmlsZSAqbmV4dDsKCWludCBmZDsKCXBpZF90IG93bmVyOwoJY2hhciBvbl9saXN0OwoJY2hhciBmaWxlbmFtZVtQQVRIX01BWF07Cn07CiNkZWZpbmUgTE9DS19ESUVfT05fRVJST1IgMQojZGVmaW5lIExPQ0tfTk9ERVJFRiAyCmV4dGVybiBpbnQgdW5hYmxlX3RvX2xvY2tfZXJyb3IoY29uc3QgY2hhciAqcGF0aCwgaW50IGVycik7CmV4dGVybiBOT1JFVFVSTiB2b2lkIHVuYWJsZV90b19sb2NrX2luZGV4X2RpZShjb25zdCBjaGFyICpwYXRoLCBpbnQgZXJyKTsKZXh0ZXJuIGludCBob2xkX2xvY2tfZmlsZV9mb3JfdXBkYXRlKHN0cnVjdCBsb2NrX2ZpbGUgKiwgY29uc3QgY2hhciAqcGF0aCwgaW50KTsKZXh0ZXJuIGludCBob2xkX2xvY2tfZmlsZV9mb3JfYXBwZW5kKHN0cnVjdCBsb2NrX2ZpbGUgKiwgY29uc3QgY2hhciAqcGF0aCwgaW50KTsKZXh0ZXJuIGludCBjb21taXRfbG9ja19maWxlKHN0cnVjdCBsb2NrX2ZpbGUgKik7CmV4dGVybiB2b2lkIHVwZGF0ZV9pbmRleF9pZl9hYmxlKHN0cnVjdCBpbmRleF9zdGF0ZSAqLCBzdHJ1Y3QgbG9ja19maWxlICopOwoKZXh0ZXJuIGludCBob2xkX2xvY2tlZF9pbmRleChzdHJ1Y3QgbG9ja19maWxlICosIGludCk7CmV4dGVybiBpbnQgY29tbWl0X2xvY2tlZF9pbmRleChzdHJ1Y3QgbG9ja19maWxlICopOwpleHRlcm4gdm9pZCBzZXRfYWx0ZXJuYXRlX2luZGV4X291dHB1dChjb25zdCBjaGFyICopOwpleHRlcm4gaW50IGNsb3NlX2xvY2tfZmlsZShzdHJ1Y3QgbG9ja19maWxlICopOwpleHRlcm4gdm9pZCByb2xsYmFja19sb2NrX2ZpbGUoc3RydWN0IGxvY2tfZmlsZSAqKTsKZXh0ZXJuIGludCBkZWxldGVfcmVmKGNvbnN0IGNoYXIgKiwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgaW50IGRlbG9wdCk7CgovKiBFbnZpcm9ubWVudCBiaXRzIGZyb20gY29uZmlndXJhdGlvbiBtZWNoYW5pc20gKi8KZXh0ZXJuIGludCB0cnVzdF9leGVjdXRhYmxlX2JpdDsKZXh0ZXJuIGludCB0cnVzdF9jdGltZTsKZXh0ZXJuIGludCBjaGVja19zdGF0OwpleHRlcm4gaW50IHF1b3RlX3BhdGhfZnVsbHk7CmV4dGVybiBpbnQgaGFzX3N5bWxpbmtzOwpleHRlcm4gaW50IG1pbmltdW1fYWJicmV2LCBkZWZhdWx0X2FiYnJldjsKZXh0ZXJuIGludCBpZ25vcmVfY2FzZTsKZXh0ZXJuIGludCBhc3N1bWVfdW5jaGFuZ2VkOwpleHRlcm4gaW50IHByZWZlcl9zeW1saW5rX3JlZnM7CmV4dGVybiBpbnQgbG9nX2FsbF9yZWZfdXBkYXRlczsKZXh0ZXJuIGludCB3YXJuX2FtYmlndW91c19yZWZzOwpleHRlcm4gaW50IHdhcm5fb25fb2JqZWN0X3JlZm5hbWVfYW1iaWd1aXR5OwpleHRlcm4gaW50IHNoYXJlZF9yZXBvc2l0b3J5OwpleHRlcm4gY29uc3QgY2hhciAqYXBwbHlfZGVmYXVsdF93aGl0ZXNwYWNlOwpleHRlcm4gY29uc3QgY2hhciAqYXBwbHlfZGVmYXVsdF9pZ25vcmV3aGl0ZXNwYWNlOwpleHRlcm4gY29uc3QgY2hhciAqZ2l0X2F0dHJpYnV0ZXNfZmlsZTsKZXh0ZXJuIGludCB6bGliX2NvbXByZXNzaW9uX2xldmVsOwpleHRlcm4gaW50IGNvcmVfY29tcHJlc3Npb25fbGV2ZWw7CmV4dGVybiBpbnQgY29yZV9jb21wcmVzc2lvbl9zZWVuOwpleHRlcm4gc2l6ZV90IHBhY2tlZF9naXRfd2luZG93X3NpemU7CmV4dGVybiBzaXplX3QgcGFja2VkX2dpdF9saW1pdDsKZXh0ZXJuIHNpemVfdCBkZWx0YV9iYXNlX2NhY2hlX2xpbWl0OwpleHRlcm4gdW5zaWduZWQgbG9uZyBiaWdfZmlsZV90aHJlc2hvbGQ7CmV4dGVybiB1bnNpZ25lZCBsb25nIHBhY2tfc2l6ZV9saW1pdF9jZmc7CmV4dGVybiBpbnQgcmVhZF9yZXBsYWNlX3JlZnM7CmV4dGVybiBpbnQgZnN5bmNfb2JqZWN0X2ZpbGVzOwpleHRlcm4gaW50IGNvcmVfcHJlbG9hZF9pbmRleDsKZXh0ZXJuIGludCBjb3JlX2FwcGx5X3NwYXJzZV9jaGVja291dDsKZXh0ZXJuIGludCBwcmVjb21wb3NlZF91bmljb2RlOwoKLyoKICogVGhlIGNoYXJhY3RlciB0aGF0IGJlZ2lucyBhIGNvbW1lbnRlZCBsaW5lIGluIHVzZXItZWRpdGFibGUgZmlsZQogKiB0aGF0IGlzIHN1YmplY3QgdG8gc3RyaXBzcGFjZS4KICovCmV4dGVybiBjaGFyIGNvbW1lbnRfbGluZV9jaGFyOwoKZW51bSBicmFuY2hfdHJhY2sgewoJQlJBTkNIX1RSQUNLX1VOU1BFQ0lGSUVEID0gLTEsCglCUkFOQ0hfVFJBQ0tfTkVWRVIgPSAwLAoJQlJBTkNIX1RSQUNLX1JFTU9URSwKCUJSQU5DSF9UUkFDS19BTFdBWVMsCglCUkFOQ0hfVFJBQ0tfRVhQTElDSVQsCglCUkFOQ0hfVFJBQ0tfT1ZFUlJJREUKfTsKCmVudW0gcmViYXNlX3NldHVwX3R5cGUgewoJQVVUT1JFQkFTRV9ORVZFUiA9IDAsCglBVVRPUkVCQVNFX0xPQ0FMLAoJQVVUT1JFQkFTRV9SRU1PVEUsCglBVVRPUkVCQVNFX0FMV0FZUwp9OwoKZW51bSBwdXNoX2RlZmF1bHRfdHlwZSB7CglQVVNIX0RFRkFVTFRfTk9USElORyA9IDAsCglQVVNIX0RFRkFVTFRfTUFUQ0hJTkcsCglQVVNIX0RFRkFVTFRfU0lNUExFLAoJUFVTSF9ERUZBVUxUX1VQU1RSRUFNLAoJUFVTSF9ERUZBVUxUX0NVUlJFTlQsCglQVVNIX0RFRkFVTFRfVU5TUEVDSUZJRUQKfTsKCmV4dGVybiBlbnVtIGJyYW5jaF90cmFjayBnaXRfYnJhbmNoX3RyYWNrOwpleHRlcm4gZW51bSByZWJhc2Vfc2V0dXBfdHlwZSBhdXRvcmViYXNlOwpleHRlcm4gZW51bSBwdXNoX2RlZmF1bHRfdHlwZSBwdXNoX2RlZmF1bHQ7CgplbnVtIG9iamVjdF9jcmVhdGlvbl9tb2RlIHsKCU9CSkVDVF9DUkVBVElPTl9VU0VTX0hBUkRMSU5LUyA9IDAsCglPQkpFQ1RfQ1JFQVRJT05fVVNFU19SRU5BTUVTID0gMQp9OwoKZXh0ZXJuIGVudW0gb2JqZWN0X2NyZWF0aW9uX21vZGUgb2JqZWN0X2NyZWF0aW9uX21vZGU7CgpleHRlcm4gY2hhciAqbm90ZXNfcmVmX25hbWU7CgpleHRlcm4gaW50IGdyYWZ0c19yZXBsYWNlX3BhcmVudHM7CgojZGVmaW5lIEdJVF9SRVBPX1ZFUlNJT04gMApleHRlcm4gaW50IHJlcG9zaXRvcnlfZm9ybWF0X3ZlcnNpb247CmV4dGVybiBpbnQgY2hlY2tfcmVwb3NpdG9yeV9mb3JtYXQodm9pZCk7CgojZGVmaW5lIE1USU1FX0NIQU5HRUQJMHgwMDAxCiNkZWZpbmUgQ1RJTUVfQ0hBTkdFRAkweDAwMDIKI2RlZmluZSBPV05FUl9DSEFOR0VECTB4MDAwNAojZGVmaW5lIE1PREVfQ0hBTkdFRCAgICAweDAwMDgKI2RlZmluZSBJTk9ERV9DSEFOR0VEICAgMHgwMDEwCiNkZWZpbmUgREFUQV9DSEFOR0VEICAgIDB4MDAyMAojZGVmaW5lIFRZUEVfQ0hBTkdFRCAgICAweDAwNDAKCmV4dGVybiBjaGFyICpta3NucGF0aChjaGFyICpidWYsIHNpemVfdCBuLCBjb25zdCBjaGFyICpmbXQsIC4uLikKCV9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAzLCA0KSkpOwpleHRlcm4gY2hhciAqZ2l0X3NucGF0aChjaGFyICpidWYsIHNpemVfdCBuLCBjb25zdCBjaGFyICpmbXQsIC4uLikKCV9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAzLCA0KSkpOwpleHRlcm4gY2hhciAqZ2l0X3BhdGhkdXAoY29uc3QgY2hhciAqZm10LCAuLi4pCglfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMSwgMikpKTsKZXh0ZXJuIGNoYXIgKm1rcGF0aGR1cChjb25zdCBjaGFyICpmbXQsIC4uLikKCV9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwoKLyogUmV0dXJuIGEgc3RhdGljYWxseSBhbGxvY2F0ZWQgZmlsZW5hbWUgbWF0Y2hpbmcgdGhlIHNoYTEgc2lnbmF0dXJlICovCmV4dGVybiBjaGFyICpta3BhdGgoY29uc3QgY2hhciAqZm10LCAuLi4pIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwpleHRlcm4gY2hhciAqZ2l0X3BhdGgoY29uc3QgY2hhciAqZm10LCAuLi4pIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwpleHRlcm4gY2hhciAqZ2l0X3BhdGhfc3VibW9kdWxlKGNvbnN0IGNoYXIgKnBhdGgsIGNvbnN0IGNoYXIgKmZtdCwgLi4uKQoJX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsIDIsIDMpKSk7CgovKgogKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGZpbGUgaW4gdGhlIGxvY2FsIG9iamVjdCBkYXRhYmFzZSB0aGF0IHdvdWxkCiAqIGJlIHVzZWQgdG8gc3RvcmUgYSBsb29zZSBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIHNoYTEuICBUaGUKICogcmV0dXJuIHZhbHVlIGlzIGEgcG9pbnRlciB0byBhIHN0YXRpY2FsbHkgYWxsb2NhdGVkIGJ1ZmZlciB0aGF0IGlzCiAqIG92ZXJ3cml0dGVuIGVhY2ggdGltZSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLgogKi8KZXh0ZXJuIGNvbnN0IGNoYXIgKnNoYTFfZmlsZV9uYW1lKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpOwoKLyoKICogUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSAobG9jYWwpIHBhY2tmaWxlIHdpdGggdGhlIHNwZWNpZmllZCBzaGExIGluCiAqIGl0cyBuYW1lLiAgVGhlIHJldHVybiB2YWx1ZSBpcyBhIHBvaW50ZXIgdG8gbWVtb3J5IHRoYXQgaXMKICogb3ZlcndyaXR0ZW4gZWFjaCB0aW1lIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLgogKi8KZXh0ZXJuIGNoYXIgKnNoYTFfcGFja19uYW1lKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpOwoKLyoKICogUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSAobG9jYWwpIHBhY2sgaW5kZXggZmlsZSB3aXRoIHRoZSBzcGVjaWZpZWQKICogc2hhMSBpbiBpdHMgbmFtZS4gIFRoZSByZXR1cm4gdmFsdWUgaXMgYSBwb2ludGVyIHRvIG1lbW9yeSB0aGF0IGlzCiAqIG92ZXJ3cml0dGVuIGVhY2ggdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZC4KICovCmV4dGVybiBjaGFyICpzaGExX3BhY2tfaW5kZXhfbmFtZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKTsKCmV4dGVybiBjb25zdCBjaGFyICpmaW5kX3VuaXF1ZV9hYmJyZXYoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgaW50KTsKZXh0ZXJuIGNvbnN0IHVuc2lnbmVkIGNoYXIgbnVsbF9zaGExWzIwXTsKCnN0YXRpYyBpbmxpbmUgaW50IGhhc2hjbXAoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMikKewoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IDIwOyBpKyssIHNoYTErKywgc2hhMisrKSB7CgkJaWYgKCpzaGExICE9ICpzaGEyKQoJCQlyZXR1cm4gKnNoYTEgLSAqc2hhMjsKCX0KCglyZXR1cm4gMDsKfQoKc3RhdGljIGlubGluZSBpbnQgaXNfbnVsbF9zaGExKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXJldHVybiAhaGFzaGNtcChzaGExLCBudWxsX3NoYTEpOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQgaGFzaGNweSh1bnNpZ25lZCBjaGFyICpzaGFfZHN0LCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGFfc3JjKQp7CgltZW1jcHkoc2hhX2RzdCwgc2hhX3NyYywgMjApOwp9CnN0YXRpYyBpbmxpbmUgdm9pZCBoYXNoY2xyKHVuc2lnbmVkIGNoYXIgKmhhc2gpCnsKCW1lbXNldChoYXNoLCAwLCAyMCk7Cn0KCiNkZWZpbmUgRU1QVFlfVFJFRV9TSEExX0hFWCBcCgkiNGI4MjVkYzY0MmNiNmViOWEwNjBlNTRiZjhkNjkyODhmYmVlNDkwNCIKI2RlZmluZSBFTVBUWV9UUkVFX1NIQTFfQklOX0xJVEVSQUwgXAoJICJceDRiXHg4Mlx4NWRceGM2XHg0Mlx4Y2JceDZlXHhiOVx4YTBceDYwIiBcCgkgIlx4ZTVceDRiXHhmOFx4ZDZceDkyXHg4OFx4ZmJceGVlXHg0OVx4MDQiCiNkZWZpbmUgRU1QVFlfVFJFRV9TSEExX0JJTiBcCgkgKChjb25zdCB1bnNpZ25lZCBjaGFyICopIEVNUFRZX1RSRUVfU0hBMV9CSU5fTElURVJBTCkKCiNkZWZpbmUgRU1QVFlfQkxPQl9TSEExX0hFWCBcCgkiZTY5ZGUyOWJiMmQxZDY0MzRiOGIyOWFlNzc1YWQ4YzJlNDhjNTM5MSIKI2RlZmluZSBFTVBUWV9CTE9CX1NIQTFfQklOX0xJVEVSQUwgXAoJIlx4ZTZceDlkXHhlMlx4OWJceGIyXHhkMVx4ZDZceDQzXHg0Ylx4OGIiIFwKCSJceDI5XHhhZVx4NzdceDVhXHhkOFx4YzJceGU0XHg4Y1x4NTNceDkxIgojZGVmaW5lIEVNUFRZX0JMT0JfU0hBMV9CSU4gXAoJKChjb25zdCB1bnNpZ25lZCBjaGFyICopIEVNUFRZX0JMT0JfU0hBMV9CSU5fTElURVJBTCkKCnN0YXRpYyBpbmxpbmUgaW50IGlzX2VtcHR5X2Jsb2Jfc2hhMShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglyZXR1cm4gIWhhc2hjbXAoc2hhMSwgRU1QVFlfQkxPQl9TSEExX0JJTik7Cn0KCmludCBnaXRfbWtzdGVtcChjaGFyICpwYXRoLCBzaXplX3QgbiwgY29uc3QgY2hhciAqdGVtcGxhdGUpOwoKaW50IGdpdF9ta3N0ZW1wcyhjaGFyICpwYXRoLCBzaXplX3QgbiwgY29uc3QgY2hhciAqdGVtcGxhdGUsIGludCBzdWZmaXhfbGVuKTsKCi8qIHNldCBkZWZhdWx0IHBlcm1pc3Npb25zIGJ5IHBhc3NpbmcgbW9kZSBhcmd1bWVudHMgdG8gb3BlbigyKSAqLwppbnQgZ2l0X21rc3RlbXBzX21vZGUoY2hhciAqcGF0dGVybiwgaW50IHN1ZmZpeF9sZW4sIGludCBtb2RlKTsKaW50IGdpdF9ta3N0ZW1wX21vZGUoY2hhciAqcGF0dGVybiwgaW50IG1vZGUpOwoKLyoKICogTk9URSBOT1RFIE5PVEUhIQogKgogKiBQRVJNX1VNQVNLLCBPTERfUEVSTV9HUk9VUCBhbmQgT0xEX1BFUk1fRVZFUllCT0RZIGVudW1lcmF0aW9ucyBtdXN0CiAqIG5vdCBiZSBjaGFuZ2VkLiBPbGQgcmVwb3NpdG9yaWVzIGhhdmUgY29yZS5zaGFyZWRyZXBvc2l0b3J5IHdyaXR0ZW4gaW4KICogbnVtZXJpYyBmb3JtYXQsIGFuZCB0aGVyZWZvcmUgdGhlc2UgdmFsdWVzIGFyZSBwcmVzZXJ2ZWQgZm9yIGNvbXBhdGliaWxpdHkKICogcmVhc29ucy4KICovCmVudW0gc2hhcmVkcmVwbyB7CglQRVJNX1VNQVNLICAgICAgICAgID0gMCwKCU9MRF9QRVJNX0dST1VQICAgICAgPSAxLAoJT0xEX1BFUk1fRVZFUllCT0RZICA9IDIsCglQRVJNX0dST1VQICAgICAgICAgID0gMDY2MCwKCVBFUk1fRVZFUllCT0RZICAgICAgPSAwNjY0Cn07CmludCBnaXRfY29uZmlnX3Blcm0oY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSk7CmludCBhZGp1c3Rfc2hhcmVkX3Blcm0oY29uc3QgY2hhciAqcGF0aCk7CgovKgogKiBDcmVhdGUgdGhlIGRpcmVjdG9yeSBjb250YWluaW5nIHRoZSBuYW1lZCBwYXRoLCB1c2luZyBjYXJlIHRvIGJlCiAqIHNvbWV3aGF0IHNhZmUgYWdhaW5zdCByYWNlcy4gIFJldHVybiBvbmUgb2YgdGhlIHNjbGRfZXJyb3IgdmFsdWVzCiAqIHRvIGluZGljYXRlIHN1Y2Nlc3MvZmFpbHVyZS4KICoKICogU0NMRF9WQU5JU0hFRCBpbmRpY2F0ZXMgdGhhdCBvbmUgb2YgdGhlIGFuY2VzdG9yIGRpcmVjdG9yaWVzIG9mIHRoZQogKiBwYXRoIGV4aXN0ZWQgYXQgb25lIHBvaW50IGR1cmluZyB0aGUgZnVuY3Rpb24gY2FsbCBhbmQgdGhlbgogKiBzdWRkZW5seSB2YW5pc2hlZCwgcHJvYmFibHkgYmVjYXVzZSBhbm90aGVyIHByb2Nlc3MgcHJ1bmVkIHRoZQogKiBkaXJlY3Rvcnkgd2hpbGUgd2Ugd2VyZSB3b3JraW5nLiAgVG8gYmUgcm9idXN0IGFnYWluc3QgdGhpcyBraW5kIG9mCiAqIHJhY2UsIGNhbGxlcnMgbWlnaHQgd2FudCB0byB0cnkgaW52b2tpbmcgdGhlIGZ1bmN0aW9uIGFnYWluIHdoZW4gaXQKICogcmV0dXJucyBTQ0xEX1ZBTklTSEVELgogKi8KZW51bSBzY2xkX2Vycm9yIHsKCVNDTERfT0sgPSAwLAoJU0NMRF9GQUlMRUQgPSAtMSwKCVNDTERfUEVSTVMgPSAtMiwKCVNDTERfRVhJU1RTID0gLTMsCglTQ0xEX1ZBTklTSEVEID0gLTQKfTsKZW51bSBzY2xkX2Vycm9yIHNhZmVfY3JlYXRlX2xlYWRpbmdfZGlyZWN0b3JpZXMoY2hhciAqcGF0aCk7CmVudW0gc2NsZF9lcnJvciBzYWZlX2NyZWF0ZV9sZWFkaW5nX2RpcmVjdG9yaWVzX2NvbnN0KGNvbnN0IGNoYXIgKnBhdGgpOwoKaW50IG1rZGlyX2luX2dpdGRpcihjb25zdCBjaGFyICpwYXRoKTsKZXh0ZXJuIHZvaWQgaG9tZV9jb25maWdfcGF0aHMoY2hhciAqKmdsb2JhbCwgY2hhciAqKnhkZywgY2hhciAqZmlsZSk7CmV4dGVybiBjaGFyICpleHBhbmRfdXNlcl9wYXRoKGNvbnN0IGNoYXIgKnBhdGgpOwpjb25zdCBjaGFyICplbnRlcl9yZXBvKGNvbnN0IGNoYXIgKnBhdGgsIGludCBzdHJpY3QpOwpzdGF0aWMgaW5saW5lIGludCBpc19hYnNvbHV0ZV9wYXRoKGNvbnN0IGNoYXIgKnBhdGgpCnsKCXJldHVybiBpc19kaXJfc2VwKHBhdGhbMF0pIHx8IGhhc19kb3NfZHJpdmVfcHJlZml4KHBhdGgpOwp9CmludCBpc19kaXJlY3RvcnkoY29uc3QgY2hhciAqKTsKY29uc3QgY2hhciAqcmVhbF9wYXRoKGNvbnN0IGNoYXIgKnBhdGgpOwpjb25zdCBjaGFyICpyZWFsX3BhdGhfaWZfdmFsaWQoY29uc3QgY2hhciAqcGF0aCk7CmNvbnN0IGNoYXIgKmFic29sdXRlX3BhdGgoY29uc3QgY2hhciAqcGF0aCk7CmNvbnN0IGNoYXIgKnJlbW92ZV9sZWFkaW5nX3BhdGgoY29uc3QgY2hhciAqaW4sIGNvbnN0IGNoYXIgKnByZWZpeCk7CmNvbnN0IGNoYXIgKnJlbGF0aXZlX3BhdGgoY29uc3QgY2hhciAqaW4sIGNvbnN0IGNoYXIgKnByZWZpeCwgc3RydWN0IHN0cmJ1ZiAqc2IpOwppbnQgbm9ybWFsaXplX3BhdGhfY29weV9sZW4oY2hhciAqZHN0LCBjb25zdCBjaGFyICpzcmMsIGludCAqcHJlZml4X2xlbik7CmludCBub3JtYWxpemVfcGF0aF9jb3B5KGNoYXIgKmRzdCwgY29uc3QgY2hhciAqc3JjKTsKaW50IGxvbmdlc3RfYW5jZXN0b3JfbGVuZ3RoKGNvbnN0IGNoYXIgKnBhdGgsIHN0cnVjdCBzdHJpbmdfbGlzdCAqcHJlZml4ZXMpOwpjaGFyICpzdHJpcF9wYXRoX3N1ZmZpeChjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFyICpzdWZmaXgpOwppbnQgZGFlbW9uX2F2b2lkX2FsaWFzKGNvbnN0IGNoYXIgKnBhdGgpOwppbnQgb2Zmc2V0XzFzdF9jb21wb25lbnQoY29uc3QgY2hhciAqcGF0aCk7CgovKiBvYmplY3QgcmVwbGFjZW1lbnQgKi8KI2RlZmluZSBMT09LVVBfUkVQTEFDRV9PQkpFQ1QgMQpleHRlcm4gdm9pZCAqcmVhZF9zaGExX2ZpbGVfZXh0ZW5kZWQoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgZW51bSBvYmplY3RfdHlwZSAqdHlwZSwgdW5zaWduZWQgbG9uZyAqc2l6ZSwgdW5zaWduZWQgZmxhZyk7CnN0YXRpYyBpbmxpbmUgdm9pZCAqcmVhZF9zaGExX2ZpbGUoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgZW51bSBvYmplY3RfdHlwZSAqdHlwZSwgdW5zaWduZWQgbG9uZyAqc2l6ZSkKewoJcmV0dXJuIHJlYWRfc2hhMV9maWxlX2V4dGVuZGVkKHNoYTEsIHR5cGUsIHNpemUsIExPT0tVUF9SRVBMQUNFX09CSkVDVCk7Cn0KZXh0ZXJuIGNvbnN0IHVuc2lnbmVkIGNoYXIgKmRvX2xvb2t1cF9yZXBsYWNlX29iamVjdChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKTsKc3RhdGljIGlubGluZSBjb25zdCB1bnNpZ25lZCBjaGFyICpsb29rdXBfcmVwbGFjZV9vYmplY3QoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJaWYgKCFyZWFkX3JlcGxhY2VfcmVmcykKCQlyZXR1cm4gc2hhMTsKCXJldHVybiBkb19sb29rdXBfcmVwbGFjZV9vYmplY3Qoc2hhMSk7Cn0Kc3RhdGljIGlubGluZSBjb25zdCB1bnNpZ25lZCBjaGFyICpsb29rdXBfcmVwbGFjZV9vYmplY3RfZXh0ZW5kZWQoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgdW5zaWduZWQgZmxhZykKewoJaWYgKCEoZmxhZyAmIExPT0tVUF9SRVBMQUNFX09CSkVDVCkpCgkJcmV0dXJuIHNoYTE7CglyZXR1cm4gbG9va3VwX3JlcGxhY2Vfb2JqZWN0KHNoYTEpOwp9CgovKiBSZWFkIGFuZCB1bnBhY2sgYSBzaGExIGZpbGUgaW50byBtZW1vcnksIHdyaXRlIG1lbW9yeSB0byBhIHNoYTEgZmlsZSAqLwpleHRlcm4gaW50IHNoYTFfb2JqZWN0X2luZm8oY29uc3QgdW5zaWduZWQgY2hhciAqLCB1bnNpZ25lZCBsb25nICopOwpleHRlcm4gaW50IGhhc2hfc2hhMV9maWxlKGNvbnN0IHZvaWQgKmJ1ZiwgdW5zaWduZWQgbG9uZyBsZW4sIGNvbnN0IGNoYXIgKnR5cGUsIHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpleHRlcm4gaW50IHdyaXRlX3NoYTFfZmlsZShjb25zdCB2b2lkICpidWYsIHVuc2lnbmVkIGxvbmcgbGVuLCBjb25zdCBjaGFyICp0eXBlLCB1bnNpZ25lZCBjaGFyICpyZXR1cm5fc2hhMSk7CmV4dGVybiBpbnQgcHJldGVuZF9zaGExX2ZpbGUodm9pZCAqLCB1bnNpZ25lZCBsb25nLCBlbnVtIG9iamVjdF90eXBlLCB1bnNpZ25lZCBjaGFyICopOwpleHRlcm4gaW50IGZvcmNlX29iamVjdF9sb29zZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCB0aW1lX3QgbXRpbWUpOwpleHRlcm4gaW50IGdpdF9vcGVuX25vYXRpbWUoY29uc3QgY2hhciAqbmFtZSk7CmV4dGVybiB2b2lkICptYXBfc2hhMV9maWxlKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIHVuc2lnbmVkIGxvbmcgKnNpemUpOwpleHRlcm4gaW50IHVucGFja19zaGExX2hlYWRlcihnaXRfenN0cmVhbSAqc3RyZWFtLCB1bnNpZ25lZCBjaGFyICptYXAsIHVuc2lnbmVkIGxvbmcgbWFwc2l6ZSwgdm9pZCAqYnVmZmVyLCB1bnNpZ25lZCBsb25nIGJ1ZnNpeik7CmV4dGVybiBpbnQgcGFyc2Vfc2hhMV9oZWFkZXIoY29uc3QgY2hhciAqaGRyLCB1bnNpZ25lZCBsb25nICpzaXplcCk7CgovKiBnbG9iYWwgZmxhZyB0byBlbmFibGUgZXh0cmEgY2hlY2tzIHdoZW4gYWNjZXNzaW5nIHBhY2tlZCBvYmplY3RzICovCmV4dGVybiBpbnQgZG9fY2hlY2tfcGFja2VkX29iamVjdF9jcmM7CgpleHRlcm4gaW50IGNoZWNrX3NoYTFfc2lnbmF0dXJlKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIHZvaWQgKmJ1ZiwgdW5zaWduZWQgbG9uZyBzaXplLCBjb25zdCBjaGFyICp0eXBlKTsKCmV4dGVybiBpbnQgbW92ZV90ZW1wX3RvX2ZpbGUoY29uc3QgY2hhciAqdG1wZmlsZSwgY29uc3QgY2hhciAqZmlsZW5hbWUpOwoKZXh0ZXJuIGludCBoYXNfc2hhMV9wYWNrKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpOwoKLyoKICogUmV0dXJuIHRydWUgaWZmIHdlIGhhdmUgYW4gb2JqZWN0IG5hbWVkIHNoYTEsIHdoZXRoZXIgbG9jYWwgb3IgaW4KICogYW4gYWx0ZXJuYXRlIG9iamVjdCBkYXRhYmFzZSwgYW5kIHdoZXRoZXIgcGFja2VkIG9yIGxvb3NlLiAgVGhpcwogKiBmdW5jdGlvbiBkb2VzIG5vdCByZXNwZWN0IHJlcGxhY2UgcmVmZXJlbmNlcy4KICovCmV4dGVybiBpbnQgaGFzX3NoYTFfZmlsZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKTsKCi8qCiAqIFJldHVybiB0cnVlIGlmZiBhbiBhbHRlcm5hdGUgb2JqZWN0IGRhdGFiYXNlIGhhcyBhIGxvb3NlIG9iamVjdAogKiB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS4gIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcmVzcGVjdCByZXBsYWNlCiAqIHJlZmVyZW5jZXMuCiAqLwpleHRlcm4gaW50IGhhc19sb29zZV9vYmplY3Rfbm9ubG9jYWwoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSk7CgpleHRlcm4gaW50IGhhc19wYWNrX2luZGV4KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpOwoKZXh0ZXJuIHZvaWQgYXNzZXJ0X3NoYTFfdHlwZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBlbnVtIG9iamVjdF90eXBlIGV4cGVjdCk7CgpleHRlcm4gY29uc3Qgc2lnbmVkIGNoYXIgaGV4dmFsX3RhYmxlWzI1Nl07CnN0YXRpYyBpbmxpbmUgdW5zaWduZWQgaW50IGhleHZhbCh1bnNpZ25lZCBjaGFyIGMpCnsKCXJldHVybiBoZXh2YWxfdGFibGVbY107Cn0KCi8qIENvbnZlcnQgdG8vZnJvbSBoZXgvc2hhMSByZXByZXNlbnRhdGlvbiAqLwojZGVmaW5lIE1JTklNVU1fQUJCUkVWIG1pbmltdW1fYWJicmV2CiNkZWZpbmUgREVGQVVMVF9BQkJSRVYgZGVmYXVsdF9hYmJyZXYKCnN0cnVjdCBvYmplY3RfY29udGV4dCB7Cgl1bnNpZ25lZCBjaGFyIHRyZWVbMjBdOwoJY2hhciBwYXRoW1BBVEhfTUFYXTsKCXVuc2lnbmVkIG1vZGU7Cn07CgojZGVmaW5lIEdFVF9TSEExX1FVSUVUTFkgICAgICAgIDAxCiNkZWZpbmUgR0VUX1NIQTFfQ09NTUlUICAgICAgICAgMDIKI2RlZmluZSBHRVRfU0hBMV9DT01NSVRUSVNIICAgICAwNAojZGVmaW5lIEdFVF9TSEExX1RSRUUgICAgICAgICAgMDEwCiNkZWZpbmUgR0VUX1NIQTFfVFJFRUlTSCAgICAgICAwMjAKI2RlZmluZSBHRVRfU0hBMV9CTE9CCSAgICAgICAwNDAKI2RlZmluZSBHRVRfU0hBMV9PTkxZX1RPX0RJRSAwNDAwMAoKZXh0ZXJuIGludCBnZXRfc2hhMShjb25zdCBjaGFyICpzdHIsIHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpleHRlcm4gaW50IGdldF9zaGExX2NvbW1pdChjb25zdCBjaGFyICpzdHIsIHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpleHRlcm4gaW50IGdldF9zaGExX2NvbW1pdHRpc2goY29uc3QgY2hhciAqc3RyLCB1bnNpZ25lZCBjaGFyICpzaGExKTsKZXh0ZXJuIGludCBnZXRfc2hhMV90cmVlKGNvbnN0IGNoYXIgKnN0ciwgdW5zaWduZWQgY2hhciAqc2hhMSk7CmV4dGVybiBpbnQgZ2V0X3NoYTFfdHJlZWlzaChjb25zdCBjaGFyICpzdHIsIHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpleHRlcm4gaW50IGdldF9zaGExX2Jsb2IoY29uc3QgY2hhciAqc3RyLCB1bnNpZ25lZCBjaGFyICpzaGExKTsKZXh0ZXJuIHZvaWQgbWF5YmVfZGllX29uX21pc3NwZWx0X29iamVjdF9uYW1lKGNvbnN0IGNoYXIgKm5hbWUsIGNvbnN0IGNoYXIgKnByZWZpeCk7CmV4dGVybiBpbnQgZ2V0X3NoYTFfd2l0aF9jb250ZXh0KGNvbnN0IGNoYXIgKnN0ciwgdW5zaWduZWQgZmxhZ3MsIHVuc2lnbmVkIGNoYXIgKnNoYTEsIHN0cnVjdCBvYmplY3RfY29udGV4dCAqb3JjKTsKCnR5cGVkZWYgaW50IGVhY2hfYWJicmV2X2ZuKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIHZvaWQgKik7CmV4dGVybiBpbnQgZm9yX2VhY2hfYWJicmV2KGNvbnN0IGNoYXIgKnByZWZpeCwgZWFjaF9hYmJyZXZfZm4sIHZvaWQgKik7CgovKgogKiBUcnkgdG8gcmVhZCBhIFNIQTEgaW4gaGV4YWRlY2ltYWwgZm9ybWF0IGZyb20gdGhlIDQwIGNoYXJhY3RlcnMKICogc3RhcnRpbmcgYXQgaGV4LiAgV3JpdGUgdGhlIDIwLWJ5dGUgcmVzdWx0IHRvIHNoYTEgaW4gYmluYXJ5IGZvcm0uCiAqIFJldHVybiAwIG9uIHN1Y2Nlc3MuICBSZWFkaW5nIHN0b3BzIGlmIGEgTlVMIGlzIGVuY291bnRlcmVkIGluIHRoZQogKiBpbnB1dCwgc28gaXQgaXMgc2FmZSB0byBwYXNzIHRoaXMgZnVuY3Rpb24gYW4gYXJiaXRyYXJ5CiAqIG51bGwtdGVybWluYXRlZCBzdHJpbmcuCiAqLwpleHRlcm4gaW50IGdldF9zaGExX2hleChjb25zdCBjaGFyICpoZXgsIHVuc2lnbmVkIGNoYXIgKnNoYTEpOwoKZXh0ZXJuIGNoYXIgKnNoYTFfdG9faGV4KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpOwkvKiBzdGF0aWMgYnVmZmVyIHJlc3VsdCEgKi8KZXh0ZXJuIGludCByZWFkX3JlZl9mdWxsKGNvbnN0IGNoYXIgKnJlZm5hbWUsIHVuc2lnbmVkIGNoYXIgKnNoYTEsCgkJCSBpbnQgcmVhZGluZywgaW50ICpmbGFncyk7CmV4dGVybiBpbnQgcmVhZF9yZWYoY29uc3QgY2hhciAqcmVmbmFtZSwgdW5zaWduZWQgY2hhciAqc2hhMSk7CgovKgogKiBSZXNvbHZlIGEgcmVmZXJlbmNlLCByZWN1cnNpdmVseSBmb2xsb3dpbmcgc3ltYm9saWMgcmVmZXJlcmVuY2VzLgogKgogKiBTdG9yZSB0aGUgcmVmZXJyZWQtdG8gb2JqZWN0J3MgbmFtZSBpbiBzaGExIGFuZCByZXR1cm4gdGhlIG5hbWUgb2YKICogdGhlIG5vbi1zeW1ib2xpYyByZWZlcmVuY2UgdGhhdCB1bHRpbWF0ZWx5IHBvaW50ZWQgYXQgaXQuICBUaGUKICogcmV0dXJuIHZhbHVlLCBpZiBub3QgTlVMTCwgaXMgYSBwb2ludGVyIGludG8gZWl0aGVyIGEgc3RhdGljIGJ1ZmZlcgogKiBvciB0aGUgaW5wdXQgcmVmLgogKgogKiBJZiB0aGUgcmVmZXJlbmNlIGNhbm5vdCBiZSByZXNvbHZlZCB0byBhbiBvYmplY3QsIHRoZSBiZWhhdmlvcgogKiBkZXBlbmRzIG9uIHRoZSAicmVhZGluZyIgYXJndW1lbnQ6CiAqCiAqIC0gSWYgcmVhZGluZyBpcyBzZXQsIHJldHVybiBOVUxMLgogKgogKiAtIElmIHJlYWRpbmcgaXMgbm90IHNldCwgY2xlYXIgc2hhMSBhbmQgcmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBsYXN0CiAqICAgcmVmZXJlbmNlIG5hbWUgaW4gdGhlIGNoYWluLCB3aGljaCB3aWxsIGVpdGhlciBiZSBhIG5vbi1zeW1ib2xpYwogKiAgIHJlZmVyZW5jZSBvciBhbiB1bmRlZmluZWQgcmVmZXJlbmNlLiAgSWYgdGhpcyBpcyBhIHByZWx1ZGUgdG8KICogICAid3JpdGluZyIgdG8gdGhlIHJlZiwgdGhlIHJldHVybiB2YWx1ZSBpcyB0aGUgbmFtZSBvZiB0aGUgcmVmCiAqICAgdGhhdCB3aWxsIGFjdHVhbGx5IGJlIGNyZWF0ZWQgb3IgY2hhbmdlZC4KICoKICogSWYgZmxhZyBpcyBub24tTlVMTCwgc2V0IHRoZSB2YWx1ZSB0aGF0IGl0IHBvaW50cyB0byB0aGUKICogY29tYmluYXRpb24gb2YgUkVGX0lTUEFDS0VEIChpZiB0aGUgcmVmZXJlbmNlIHdhcyBmb3VuZCBhbW9uZyB0aGUKICogcGFja2VkIHJlZmVyZW5jZXMpIGFuZCBSRUZfSVNTWU1SRUYgKGlmIHRoZSBpbml0aWFsIHJlZmVyZW5jZSB3YXMgYQogKiBzeW1ib2xpYyByZWZlcmVuY2UpLgogKgogKiBJZiByZWYgaXMgbm90IGEgcHJvcGVybHktZm9ybWF0dGVkLCBub3JtYWxpemVkIHJlZmVyZW5jZSwgcmV0dXJuCiAqIE5VTEwuICBJZiBtb3JlIHRoYW4gTUFYREVQVEggcmVjdXJzaXZlIHN5bWJvbGljIGxvb2t1cHMgYXJlIG5lZWRlZCwKICogZ2l2ZSB1cCBhbmQgcmV0dXJuIE5VTEwuCiAqCiAqIGVycm5vIGlzIHNvbWV0aW1lcyBzZXQgb24gZXJyb3JzLCBidXQgbm90IGFsd2F5cy4KICovCmV4dGVybiBjb25zdCBjaGFyICpyZXNvbHZlX3JlZl91bnNhZmUoY29uc3QgY2hhciAqcmVmLCB1bnNpZ25lZCBjaGFyICpzaGExLCBpbnQgcmVhZGluZywgaW50ICpmbGFnKTsKZXh0ZXJuIGNoYXIgKnJlc29sdmVfcmVmZHVwKGNvbnN0IGNoYXIgKnJlZiwgdW5zaWduZWQgY2hhciAqc2hhMSwgaW50IHJlYWRpbmcsIGludCAqZmxhZyk7CgpleHRlcm4gaW50IGR3aW1fcmVmKGNvbnN0IGNoYXIgKnN0ciwgaW50IGxlbiwgdW5zaWduZWQgY2hhciAqc2hhMSwgY2hhciAqKnJlZik7CmV4dGVybiBpbnQgZHdpbV9sb2coY29uc3QgY2hhciAqc3RyLCBpbnQgbGVuLCB1bnNpZ25lZCBjaGFyICpzaGExLCBjaGFyICoqcmVmKTsKZXh0ZXJuIGludCBpbnRlcnByZXRfYnJhbmNoX25hbWUoY29uc3QgY2hhciAqc3RyLCBpbnQgbGVuLCBzdHJ1Y3Qgc3RyYnVmICopOwpleHRlcm4gaW50IGdldF9zaGExX21iKGNvbnN0IGNoYXIgKnN0ciwgdW5zaWduZWQgY2hhciAqc2hhMSk7CgovKgogKiBSZXR1cm4gdHJ1ZSBpZmYgYWJicmV2X25hbWUgaXMgYSBwb3NzaWJsZSBhYmJyZXZpYXRpb24gZm9yCiAqIGZ1bGxfbmFtZSBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzIGRlZmluZWQgYnkgcmVmX3Jldl9wYXJzZV9ydWxlcyBpbgogKiByZWZzLmMuCiAqLwpleHRlcm4gaW50IHJlZm5hbWVfbWF0Y2goY29uc3QgY2hhciAqYWJicmV2X25hbWUsIGNvbnN0IGNoYXIgKmZ1bGxfbmFtZSk7CgpleHRlcm4gaW50IGNyZWF0ZV9zeW1yZWYoY29uc3QgY2hhciAqcmVmLCBjb25zdCBjaGFyICpyZWZzX2hlYWRzX21hc3RlciwgY29uc3QgY2hhciAqbG9nbXNnKTsKZXh0ZXJuIGludCB2YWxpZGF0ZV9oZWFkcmVmKGNvbnN0IGNoYXIgKnJlZik7CgpleHRlcm4gaW50IGJhc2VfbmFtZV9jb21wYXJlKGNvbnN0IGNoYXIgKm5hbWUxLCBpbnQgbGVuMSwgaW50IG1vZGUxLCBjb25zdCBjaGFyICpuYW1lMiwgaW50IGxlbjIsIGludCBtb2RlMik7CmV4dGVybiBpbnQgZGZfbmFtZV9jb21wYXJlKGNvbnN0IGNoYXIgKm5hbWUxLCBpbnQgbGVuMSwgaW50IG1vZGUxLCBjb25zdCBjaGFyICpuYW1lMiwgaW50IGxlbjIsIGludCBtb2RlMik7CmV4dGVybiBpbnQgY2FjaGVfbmFtZV9jb21wYXJlKGNvbnN0IGNoYXIgKm5hbWUxLCBpbnQgbGVuMSwgY29uc3QgY2hhciAqbmFtZTIsIGludCBsZW4yKTsKZXh0ZXJuIGludCBjYWNoZV9uYW1lX3N0YWdlX2NvbXBhcmUoY29uc3QgY2hhciAqbmFtZTEsIGludCBsZW4xLCBpbnQgc3RhZ2UxLCBjb25zdCBjaGFyICpuYW1lMiwgaW50IGxlbjIsIGludCBzdGFnZTIpOwoKZXh0ZXJuIHZvaWQgKnJlYWRfb2JqZWN0X3dpdGhfcmVmZXJlbmNlKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsCgkJCQkJY29uc3QgY2hhciAqcmVxdWlyZWRfdHlwZSwKCQkJCQl1bnNpZ25lZCBsb25nICpzaXplLAoJCQkJCXVuc2lnbmVkIGNoYXIgKnNoYTFfcmV0KTsKCmV4dGVybiBzdHJ1Y3Qgb2JqZWN0ICpwZWVsX3RvX3R5cGUoY29uc3QgY2hhciAqbmFtZSwgaW50IG5hbWVsZW4sCgkJCQkgICBzdHJ1Y3Qgb2JqZWN0ICpvLCBlbnVtIG9iamVjdF90eXBlKTsKCmVudW0gZGF0ZV9tb2RlIHsKCURBVEVfTk9STUFMID0gMCwKCURBVEVfUkVMQVRJVkUsCglEQVRFX1NIT1JULAoJREFURV9MT0NBTCwKCURBVEVfSVNPODYwMSwKCURBVEVfUkZDMjgyMiwKCURBVEVfUkFXCn07Cgpjb25zdCBjaGFyICpzaG93X2RhdGUodW5zaWduZWQgbG9uZyB0aW1lLCBpbnQgdGltZXpvbmUsIGVudW0gZGF0ZV9tb2RlIG1vZGUpOwp2b2lkIHNob3dfZGF0ZV9yZWxhdGl2ZSh1bnNpZ25lZCBsb25nIHRpbWUsIGludCB0eiwgY29uc3Qgc3RydWN0IHRpbWV2YWwgKm5vdywKCQkJc3RydWN0IHN0cmJ1ZiAqdGltZWJ1Zik7CmludCBwYXJzZV9kYXRlKGNvbnN0IGNoYXIgKmRhdGUsIGNoYXIgKmJ1ZiwgaW50IGJ1ZnNpemUpOwppbnQgcGFyc2VfZGF0ZV9iYXNpYyhjb25zdCBjaGFyICpkYXRlLCB1bnNpZ25lZCBsb25nICp0aW1lc3RhbXAsIGludCAqb2Zmc2V0KTsKaW50IHBhcnNlX2V4cGlyeV9kYXRlKGNvbnN0IGNoYXIgKmRhdGUsIHVuc2lnbmVkIGxvbmcgKnRpbWVzdGFtcCk7CnZvaWQgZGF0ZXN0YW1wKGNoYXIgKmJ1ZiwgaW50IGJ1ZnNpemUpOwojZGVmaW5lIGFwcHJveGlkYXRlKHMpIGFwcHJveGlkYXRlX2NhcmVmdWwoKHMpLCBOVUxMKQp1bnNpZ25lZCBsb25nIGFwcHJveGlkYXRlX2NhcmVmdWwoY29uc3QgY2hhciAqLCBpbnQgKik7CnVuc2lnbmVkIGxvbmcgYXBwcm94aWRhdGVfcmVsYXRpdmUoY29uc3QgY2hhciAqZGF0ZSwgY29uc3Qgc3RydWN0IHRpbWV2YWwgKm5vdyk7CmVudW0gZGF0ZV9tb2RlIHBhcnNlX2RhdGVfZm9ybWF0KGNvbnN0IGNoYXIgKmZvcm1hdCk7CmludCBkYXRlX292ZXJmbG93cyh1bnNpZ25lZCBsb25nIGRhdGUpOwoKI2RlZmluZSBJREVOVF9TVFJJQ1QJICAgICAgIDEKI2RlZmluZSBJREVOVF9OT19EQVRFCSAgICAgICAyCiNkZWZpbmUgSURFTlRfTk9fTkFNRQkgICAgICAgNApleHRlcm4gY29uc3QgY2hhciAqZ2l0X2F1dGhvcl9pbmZvKGludCk7CmV4dGVybiBjb25zdCBjaGFyICpnaXRfY29tbWl0dGVyX2luZm8oaW50KTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmZtdF9pZGVudChjb25zdCBjaGFyICpuYW1lLCBjb25zdCBjaGFyICplbWFpbCwgY29uc3QgY2hhciAqZGF0ZV9zdHIsIGludCk7CmV4dGVybiBjb25zdCBjaGFyICpmbXRfbmFtZShjb25zdCBjaGFyICpuYW1lLCBjb25zdCBjaGFyICplbWFpbCk7CmV4dGVybiBjb25zdCBjaGFyICppZGVudF9kZWZhdWx0X2VtYWlsKHZvaWQpOwpleHRlcm4gY29uc3QgY2hhciAqZ2l0X2VkaXRvcih2b2lkKTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdpdF9wYWdlcihpbnQgc3Rkb3V0X2lzX3R0eSk7CmV4dGVybiBpbnQgZ2l0X2lkZW50X2NvbmZpZyhjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKiwgdm9pZCAqKTsKCnN0cnVjdCBpZGVudF9zcGxpdCB7Cgljb25zdCBjaGFyICpuYW1lX2JlZ2luOwoJY29uc3QgY2hhciAqbmFtZV9lbmQ7Cgljb25zdCBjaGFyICptYWlsX2JlZ2luOwoJY29uc3QgY2hhciAqbWFpbF9lbmQ7Cgljb25zdCBjaGFyICpkYXRlX2JlZ2luOwoJY29uc3QgY2hhciAqZGF0ZV9lbmQ7Cgljb25zdCBjaGFyICp0el9iZWdpbjsKCWNvbnN0IGNoYXIgKnR6X2VuZDsKfTsKLyoKICogU2lnbmFscyBhbiBzdWNjZXNzIHdpdGggMCwgYnV0IHRpbWUgcGFydCBvZiB0aGUgcmVzdWx0IG1heSBiZSBOVUxMCiAqIGlmIHRoZSBpbnB1dCBsYWNrcyB0aW1lc3RhbXAgYW5kIHpvbmUKICovCmV4dGVybiBpbnQgc3BsaXRfaWRlbnRfbGluZShzdHJ1Y3QgaWRlbnRfc3BsaXQgKiwgY29uc3QgY2hhciAqLCBpbnQpOwoKLyoKICogQ29tcGFyZSBzcGxpdCBpZGVudHMgZm9yIGVxdWFsaXR5IG9yIHN0cmljdCBvcmRlcmluZy4gTm90ZSB0aGF0IHdlCiAqIGNvbXBhcmUgb25seSB0aGUgaWRlbnQgcGFydCBvZiB0aGUgbGluZSwgaWdub3JpbmcgYW55IHRpbWVzdGFtcC4KICoKICogQmVjYXVzZSB0aGVyZSBhcmUgdHdvIGZpZWxkcywgd2UgbXVzdCBjaG9vc2Ugb25lIGFzIHRoZSBwcmltYXJ5IGtleTsgd2UKICogY3VycmVudGx5IGFyYml0cmFyaWx5IHBpY2sgdGhlIGVtYWlsLgogKi8KZXh0ZXJuIGludCBpZGVudF9jbXAoY29uc3Qgc3RydWN0IGlkZW50X3NwbGl0ICosIGNvbnN0IHN0cnVjdCBpZGVudF9zcGxpdCAqKTsKCnN0cnVjdCBjaGVja291dCB7Cgljb25zdCBjaGFyICpiYXNlX2RpcjsKCWludCBiYXNlX2Rpcl9sZW47Cgl1bnNpZ25lZCBmb3JjZToxLAoJCSBxdWlldDoxLAoJCSBub3RfbmV3OjEsCgkJIHJlZnJlc2hfY2FjaGU6MTsKfTsKCiNkZWZpbmUgVEVNUE9SQVJZX0ZJTEVOQU1FX0xFTkdUSCAyNQpleHRlcm4gaW50IGNoZWNrb3V0X2VudHJ5KHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIGNvbnN0IHN0cnVjdCBjaGVja291dCAqc3RhdGUsIGNoYXIgKnRvcGF0aCk7CgpzdHJ1Y3QgY2FjaGVfZGVmIHsKCWNoYXIgcGF0aFtQQVRIX01BWCArIDFdOwoJaW50IGxlbjsKCWludCBmbGFnczsKCWludCB0cmFja19mbGFnczsKCWludCBwcmVmaXhfbGVuX3N0YXRfZnVuYzsKfTsKCmV4dGVybiBpbnQgaGFzX3N5bWxpbmtfbGVhZGluZ19wYXRoKGNvbnN0IGNoYXIgKm5hbWUsIGludCBsZW4pOwpleHRlcm4gaW50IHRocmVhZGVkX2hhc19zeW1saW5rX2xlYWRpbmdfcGF0aChzdHJ1Y3QgY2FjaGVfZGVmICosIGNvbnN0IGNoYXIgKiwgaW50KTsKZXh0ZXJuIGludCBjaGVja19sZWFkaW5nX3BhdGgoY29uc3QgY2hhciAqbmFtZSwgaW50IGxlbik7CmV4dGVybiBpbnQgaGFzX2RpcnNfb25seV9wYXRoKGNvbnN0IGNoYXIgKm5hbWUsIGludCBsZW4sIGludCBwcmVmaXhfbGVuKTsKZXh0ZXJuIHZvaWQgc2NoZWR1bGVfZGlyX2Zvcl9yZW1vdmFsKGNvbnN0IGNoYXIgKm5hbWUsIGludCBsZW4pOwpleHRlcm4gdm9pZCByZW1vdmVfc2NoZWR1bGVkX2RpcnModm9pZCk7CgpleHRlcm4gc3RydWN0IGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UgewoJc3RydWN0IGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UgKm5leHQ7CgljaGFyICpuYW1lOwoJY2hhciBiYXNlW0ZMRVhfQVJSQVldOyAvKiBtb3JlICovCn0gKmFsdF9vZGJfbGlzdDsKZXh0ZXJuIHZvaWQgcHJlcGFyZV9hbHRfb2RiKHZvaWQpOwpleHRlcm4gdm9pZCByZWFkX2luZm9fYWx0ZXJuYXRlcyhjb25zdCBjaGFyICogcmVsYXRpdmVfYmFzZSwgaW50IGRlcHRoKTsKZXh0ZXJuIHZvaWQgYWRkX3RvX2FsdGVybmF0ZXNfZmlsZShjb25zdCBjaGFyICpyZWZlcmVuY2UpOwp0eXBlZGVmIGludCBhbHRfb2RiX2ZuKHN0cnVjdCBhbHRlcm5hdGVfb2JqZWN0X2RhdGFiYXNlICosIHZvaWQgKik7CmV4dGVybiB2b2lkIGZvcmVhY2hfYWx0X29kYihhbHRfb2RiX2ZuLCB2b2lkKik7CgpzdHJ1Y3QgcGFja193aW5kb3cgewoJc3RydWN0IHBhY2tfd2luZG93ICpuZXh0OwoJdW5zaWduZWQgY2hhciAqYmFzZTsKCW9mZl90IG9mZnNldDsKCXNpemVfdCBsZW47Cgl1bnNpZ25lZCBpbnQgbGFzdF91c2VkOwoJdW5zaWduZWQgaW50IGludXNlX2NudDsKfTsKCmV4dGVybiBzdHJ1Y3QgcGFja2VkX2dpdCB7CglzdHJ1Y3QgcGFja2VkX2dpdCAqbmV4dDsKCXN0cnVjdCBwYWNrX3dpbmRvdyAqd2luZG93czsKCW9mZl90IHBhY2tfc2l6ZTsKCWNvbnN0IHZvaWQgKmluZGV4X2RhdGE7CglzaXplX3QgaW5kZXhfc2l6ZTsKCXVpbnQzMl90IG51bV9vYmplY3RzOwoJdWludDMyX3QgbnVtX2JhZF9vYmplY3RzOwoJdW5zaWduZWQgY2hhciAqYmFkX29iamVjdF9zaGExOwoJaW50IGluZGV4X3ZlcnNpb247Cgl0aW1lX3QgbXRpbWU7CglpbnQgcGFja19mZDsKCXVuc2lnbmVkIHBhY2tfbG9jYWw6MSwKCQkgcGFja19rZWVwOjEsCgkJIGRvX25vdF9jbG9zZToxOwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCS8qIHNvbWV0aGluZyBsaWtlICIuZ2l0L29iamVjdHMvcGFjay94eHh4eC5wYWNrIiAqLwoJY2hhciBwYWNrX25hbWVbRkxFWF9BUlJBWV07IC8qIG1vcmUgKi8KfSAqcGFja2VkX2dpdDsKCnN0cnVjdCBwYWNrX2VudHJ5IHsKCW9mZl90IG9mZnNldDsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CglzdHJ1Y3QgcGFja2VkX2dpdCAqcDsKfTsKCmV4dGVybiBzdHJ1Y3QgcGFja2VkX2dpdCAqcGFyc2VfcGFja19pbmRleCh1bnNpZ25lZCBjaGFyICpzaGExLCBjb25zdCBjaGFyICppZHhfcGF0aCk7CgovKiBBIGhvb2sgZm9yIGNvdW50LW9iamVjdHMgdG8gcmVwb3J0IGludmFsaWQgZmlsZXMgaW4gcGFjayBkaXJlY3RvcnkgKi8KZXh0ZXJuIHZvaWQgKCpyZXBvcnRfZ2FyYmFnZSkoY29uc3QgY2hhciAqZGVzYywgY29uc3QgY2hhciAqcGF0aCk7CgpleHRlcm4gdm9pZCBwcmVwYXJlX3BhY2tlZF9naXQodm9pZCk7CmV4dGVybiB2b2lkIHJlcHJlcGFyZV9wYWNrZWRfZ2l0KHZvaWQpOwpleHRlcm4gdm9pZCBpbnN0YWxsX3BhY2tlZF9naXQoc3RydWN0IHBhY2tlZF9naXQgKnBhY2spOwoKZXh0ZXJuIHN0cnVjdCBwYWNrZWRfZ2l0ICpmaW5kX3NoYTFfcGFjayhjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCQkJCSBzdHJ1Y3QgcGFja2VkX2dpdCAqcGFja3MpOwoKZXh0ZXJuIHZvaWQgcGFja19yZXBvcnQodm9pZCk7CgovKgogKiBtbWFwIHRoZSBpbmRleCBmaWxlIGZvciB0aGUgc3BlY2lmaWVkIHBhY2tmaWxlIChpZiBpdCBpcyBub3QKICogYWxyZWFkeSBtbWFwcGVkKS4gIFJldHVybiAwIG9uIHN1Y2Nlc3MuCiAqLwpleHRlcm4gaW50IG9wZW5fcGFja19pbmRleChzdHJ1Y3QgcGFja2VkX2dpdCAqKTsKCi8qCiAqIG11bm1hcCB0aGUgaW5kZXggZmlsZSBmb3IgdGhlIHNwZWNpZmllZCBwYWNrZmlsZSAoaWYgaXQgaXMKICogY3VycmVudGx5IG1tYXBwZWQpLgogKi8KZXh0ZXJuIHZvaWQgY2xvc2VfcGFja19pbmRleChzdHJ1Y3QgcGFja2VkX2dpdCAqKTsKCmV4dGVybiB1bnNpZ25lZCBjaGFyICp1c2VfcGFjayhzdHJ1Y3QgcGFja2VkX2dpdCAqLCBzdHJ1Y3QgcGFja193aW5kb3cgKiosIG9mZl90LCB1bnNpZ25lZCBsb25nICopOwpleHRlcm4gdm9pZCBjbG9zZV9wYWNrX3dpbmRvd3Moc3RydWN0IHBhY2tlZF9naXQgKik7CmV4dGVybiB2b2lkIHVudXNlX3BhY2soc3RydWN0IHBhY2tfd2luZG93ICoqKTsKZXh0ZXJuIHZvaWQgZnJlZV9wYWNrX2J5X25hbWUoY29uc3QgY2hhciAqKTsKZXh0ZXJuIHZvaWQgY2xlYXJfZGVsdGFfYmFzZV9jYWNoZSh2b2lkKTsKZXh0ZXJuIHN0cnVjdCBwYWNrZWRfZ2l0ICphZGRfcGFja2VkX2dpdChjb25zdCBjaGFyICosIGludCwgaW50KTsKCi8qCiAqIFJldHVybiB0aGUgU0hBLTEgb2YgdGhlIG50aCBvYmplY3Qgd2l0aGluIHRoZSBzcGVjaWZpZWQgcGFja2ZpbGUuCiAqIE9wZW4gdGhlIGluZGV4IGlmIGl0IGlzIG5vdCBhbHJlYWR5IG9wZW4uICBUaGUgcmV0dXJuIHZhbHVlIHBvaW50cwogKiBhdCB0aGUgU0hBLTEgd2l0aGluIHRoZSBtbWFwcGVkIGluZGV4LiAgUmV0dXJuIE5VTEwgaWYgdGhlcmUgaXMgYW4KICogZXJyb3IuCiAqLwpleHRlcm4gY29uc3QgdW5zaWduZWQgY2hhciAqbnRoX3BhY2tlZF9vYmplY3Rfc2hhMShzdHJ1Y3QgcGFja2VkX2dpdCAqLCB1aW50MzJfdCBuKTsKCi8qCiAqIFJldHVybiB0aGUgb2Zmc2V0IG9mIHRoZSBudGggb2JqZWN0IHdpdGhpbiB0aGUgc3BlY2lmaWVkIHBhY2tmaWxlLgogKiBUaGUgaW5kZXggbXVzdCBhbHJlYWR5IGJlIG9wZW5lZC4KICovCmV4dGVybiBvZmZfdCBudGhfcGFja2VkX29iamVjdF9vZmZzZXQoY29uc3Qgc3RydWN0IHBhY2tlZF9naXQgKiwgdWludDMyX3Qgbik7CgovKgogKiBJZiB0aGUgb2JqZWN0IG5hbWVkIHNoYTEgaXMgcHJlc2VudCBpbiB0aGUgc3BlY2lmaWVkIHBhY2tmaWxlLAogKiByZXR1cm4gaXRzIG9mZnNldCB3aXRoaW4gdGhlIHBhY2tmaWxlOyBvdGhlcndpc2UsIHJldHVybiAwLgogKi8KZXh0ZXJuIG9mZl90IGZpbmRfcGFja19lbnRyeV9vbmUoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgc3RydWN0IHBhY2tlZF9naXQgKik7CgpleHRlcm4gaW50IGlzX3BhY2tfdmFsaWQoc3RydWN0IHBhY2tlZF9naXQgKik7CmV4dGVybiB2b2lkICp1bnBhY2tfZW50cnkoc3RydWN0IHBhY2tlZF9naXQgKiwgb2ZmX3QsIGVudW0gb2JqZWN0X3R5cGUgKiwgdW5zaWduZWQgbG9uZyAqKTsKZXh0ZXJuIHVuc2lnbmVkIGxvbmcgdW5wYWNrX29iamVjdF9oZWFkZXJfYnVmZmVyKGNvbnN0IHVuc2lnbmVkIGNoYXIgKmJ1ZiwgdW5zaWduZWQgbG9uZyBsZW4sIGVudW0gb2JqZWN0X3R5cGUgKnR5cGUsIHVuc2lnbmVkIGxvbmcgKnNpemVwKTsKZXh0ZXJuIHVuc2lnbmVkIGxvbmcgZ2V0X3NpemVfZnJvbV9kZWx0YShzdHJ1Y3QgcGFja2VkX2dpdCAqLCBzdHJ1Y3QgcGFja193aW5kb3cgKiosIG9mZl90KTsKZXh0ZXJuIGludCB1bnBhY2tfb2JqZWN0X2hlYWRlcihzdHJ1Y3QgcGFja2VkX2dpdCAqLCBzdHJ1Y3QgcGFja193aW5kb3cgKiosIG9mZl90ICosIHVuc2lnbmVkIGxvbmcgKik7CgpzdHJ1Y3Qgb2JqZWN0X2luZm8gewoJLyogUmVxdWVzdCAqLwoJZW51bSBvYmplY3RfdHlwZSAqdHlwZXA7Cgl1bnNpZ25lZCBsb25nICpzaXplcDsKCXVuc2lnbmVkIGxvbmcgKmRpc2tfc2l6ZXA7Cgl1bnNpZ25lZCBjaGFyICpkZWx0YV9iYXNlX3NoYTE7CgoJLyogUmVzcG9uc2UgKi8KCWVudW0gewoJCU9JX0NBQ0hFRCwKCQlPSV9MT09TRSwKCQlPSV9QQUNLRUQsCgkJT0lfREJDQUNIRUQKCX0gd2hlbmNlOwoJdW5pb24gewoJCS8qCgkJICogc3RydWN0IHsKCQkgKiAJLi4uIE5vdGhpbmcgdG8gZXhwb3NlIGluIHRoaXMgY2FzZQoJCSAqIH0gY2FjaGVkOwoJCSAqIHN0cnVjdCB7CgkJICogCS4uLiBOb3RoaW5nIHRvIGV4cG9zZSBpbiB0aGlzIGNhc2UKCQkgKiB9IGxvb3NlOwoJCSAqLwoJCXN0cnVjdCB7CgkJCXN0cnVjdCBwYWNrZWRfZ2l0ICpwYWNrOwoJCQlvZmZfdCBvZmZzZXQ7CgkJCXVuc2lnbmVkIGludCBpc19kZWx0YTsKCQl9IHBhY2tlZDsKCX0gdTsKfTsKZXh0ZXJuIGludCBzaGExX29iamVjdF9pbmZvX2V4dGVuZGVkKGNvbnN0IHVuc2lnbmVkIGNoYXIgKiwgc3RydWN0IG9iamVjdF9pbmZvICosIHVuc2lnbmVkIGZsYWdzKTsKCi8qIER1bWIgc2VydmVycyBzdXBwb3J0ICovCmV4dGVybiBpbnQgdXBkYXRlX3NlcnZlcl9pbmZvKGludCk7CgovKiBnaXRfY29uZmlnX3BhcnNlX2tleSgpIHJldHVybnMgdGhlc2UgbmVnYXRlZDogKi8KI2RlZmluZSBDT05GSUdfSU5WQUxJRF9LRVkgMQojZGVmaW5lIENPTkZJR19OT19TRUNUSU9OX09SX05BTUUgMgovKiBnaXRfY29uZmlnX3NldCgpLCBnaXRfY29uZmlnX3NldF9tdWx0aXZhcigpIHJldHVybiB0aGUgYWJvdmUgb3IgdGhlc2U6ICovCiNkZWZpbmUgQ09ORklHX05PX0xPQ0sgLTEKI2RlZmluZSBDT05GSUdfSU5WQUxJRF9GSUxFIDMKI2RlZmluZSBDT05GSUdfTk9fV1JJVEUgNAojZGVmaW5lIENPTkZJR19OT1RISU5HX1NFVCA1CiNkZWZpbmUgQ09ORklHX0lOVkFMSURfUEFUVEVSTiA2CiNkZWZpbmUgQ09ORklHX0dFTkVSSUNfRVJST1IgNwoKc3RydWN0IGdpdF9jb25maWdfc291cmNlIHsKCXVuc2lnbmVkIGludCB1c2Vfc3RkaW46MTsKCWNvbnN0IGNoYXIgKmZpbGU7Cgljb25zdCBjaGFyICpibG9iOwp9OwoKdHlwZWRlZiBpbnQgKCpjb25maWdfZm5fdCkoY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICosIHZvaWQgKik7CmV4dGVybiBpbnQgZ2l0X2RlZmF1bHRfY29uZmlnKGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqLCB2b2lkICopOwpleHRlcm4gaW50IGdpdF9jb25maWdfZnJvbV9maWxlKGNvbmZpZ19mbl90IGZuLCBjb25zdCBjaGFyICosIHZvaWQgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19mcm9tX2J1Zihjb25maWdfZm5fdCBmbiwgY29uc3QgY2hhciAqbmFtZSwKCQkJICAgICAgIGNvbnN0IGNoYXIgKmJ1Ziwgc2l6ZV90IGxlbiwgdm9pZCAqZGF0YSk7CmV4dGVybiB2b2lkIGdpdF9jb25maWdfcHVzaF9wYXJhbWV0ZXIoY29uc3QgY2hhciAqdGV4dCk7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19mcm9tX3BhcmFtZXRlcnMoY29uZmlnX2ZuX3QgZm4sIHZvaWQgKmRhdGEpOwpleHRlcm4gaW50IGdpdF9jb25maWcoY29uZmlnX2ZuX3QgZm4sIHZvaWQgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ193aXRoX29wdGlvbnMoY29uZmlnX2ZuX3QgZm4sIHZvaWQgKiwKCQkJCSAgIHN0cnVjdCBnaXRfY29uZmlnX3NvdXJjZSAqY29uZmlnX3NvdXJjZSwKCQkJCSAgIGludCByZXNwZWN0X2luY2x1ZGVzKTsKZXh0ZXJuIGludCBnaXRfY29uZmlnX2Vhcmx5KGNvbmZpZ19mbl90IGZuLCB2b2lkICosIGNvbnN0IGNoYXIgKnJlcG9fY29uZmlnKTsKZXh0ZXJuIGludCBnaXRfcGFyc2VfdWxvbmcoY29uc3QgY2hhciAqLCB1bnNpZ25lZCBsb25nICopOwpleHRlcm4gaW50IGdpdF9jb25maWdfaW50KGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqKTsKZXh0ZXJuIGludDY0X3QgZ2l0X2NvbmZpZ19pbnQ2NChjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKik7CmV4dGVybiB1bnNpZ25lZCBsb25nIGdpdF9jb25maWdfdWxvbmcoY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICopOwpleHRlcm4gaW50IGdpdF9jb25maWdfYm9vbF9vcl9pbnQoY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICosIGludCAqKTsKZXh0ZXJuIGludCBnaXRfY29uZmlnX2Jvb2woY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICopOwpleHRlcm4gaW50IGdpdF9jb25maWdfbWF5YmVfYm9vbChjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19zdHJpbmcoY29uc3QgY2hhciAqKiwgY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICopOwpleHRlcm4gaW50IGdpdF9jb25maWdfcGF0aG5hbWUoY29uc3QgY2hhciAqKiwgY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICopOwpleHRlcm4gaW50IGdpdF9jb25maWdfc2V0X2luX2ZpbGUoY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19zZXQoY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICopOwpleHRlcm4gaW50IGdpdF9jb25maWdfcGFyc2Vfa2V5KGNvbnN0IGNoYXIgKiwgY2hhciAqKiwgaW50ICopOwpleHRlcm4gaW50IGdpdF9jb25maWdfc2V0X211bHRpdmFyKGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICosIGludCk7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19zZXRfbXVsdGl2YXJfaW5fZmlsZShjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICosIGludCk7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19yZW5hbWVfc2VjdGlvbihjb25zdCBjaGFyICosIGNvbnN0IGNoYXIgKik7CmV4dGVybiBpbnQgZ2l0X2NvbmZpZ19yZW5hbWVfc2VjdGlvbl9pbl9maWxlKGNvbnN0IGNoYXIgKiwgY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICopOwpleHRlcm4gY29uc3QgY2hhciAqZ2l0X2V0Y19naXRjb25maWcodm9pZCk7CmV4dGVybiBpbnQgY2hlY2tfcmVwb3NpdG9yeV9mb3JtYXRfdmVyc2lvbihjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlLCB2b2lkICpjYik7CmV4dGVybiBpbnQgZ2l0X2Vudl9ib29sKGNvbnN0IGNoYXIgKiwgaW50KTsKZXh0ZXJuIGludCBnaXRfY29uZmlnX3N5c3RlbSh2b2lkKTsKZXh0ZXJuIGludCBjb25maWdfZXJyb3Jfbm9uYm9vbChjb25zdCBjaGFyICopOwojaWYgZGVmaW5lZChfX0dOVUNfXykgJiYgISBkZWZpbmVkKF9fY2xhbmdfXykKI2RlZmluZSBjb25maWdfZXJyb3Jfbm9uYm9vbChzKSAoY29uZmlnX2Vycm9yX25vbmJvb2wocyksIC0xKQojZW5kaWYKZXh0ZXJuIGNvbnN0IGNoYXIgKmdldF9sb2dfb3V0cHV0X2VuY29kaW5nKHZvaWQpOwpleHRlcm4gY29uc3QgY2hhciAqZ2V0X2NvbW1pdF9vdXRwdXRfZW5jb2Rpbmcodm9pZCk7CgpleHRlcm4gaW50IGdpdF9jb25maWdfcGFyc2VfcGFyYW1ldGVyKGNvbnN0IGNoYXIgKiwgY29uZmlnX2ZuX3QgZm4sIHZvaWQgKmRhdGEpOwoKc3RydWN0IGNvbmZpZ19pbmNsdWRlX2RhdGEgewoJaW50IGRlcHRoOwoJY29uZmlnX2ZuX3QgZm47Cgl2b2lkICpkYXRhOwp9OwojZGVmaW5lIENPTkZJR19JTkNMVURFX0lOSVQgeyAwIH0KZXh0ZXJuIGludCBnaXRfY29uZmlnX2luY2x1ZGUoY29uc3QgY2hhciAqbmFtZSwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmRhdGEpOwoKLyoKICogTWF0Y2ggYW5kIHBhcnNlIGEgY29uZmlnIGtleSBvZiB0aGUgZm9ybToKICoKICogICBzZWN0aW9uLihzdWJzZWN0aW9uLik/a2V5CiAqCiAqIChpLmUuLCB3aGF0IGdldHMgaGFuZGVkIHRvIGEgY29uZmlnX2ZuX3QpLiBUaGUgY2FsbGVyIHByb3ZpZGVzIHRoZSBzZWN0aW9uOwogKiB3ZSByZXR1cm4gLTEgaWYgaXQgZG9lcyBub3QgbWF0Y2gsIDAgb3RoZXJ3aXNlLiBUaGUgc3Vic2VjdGlvbiBhbmQga2V5CiAqIG91dC1wYXJhbWV0ZXJzIGFyZSBmaWxsZWQgYnkgdGhlIGZ1bmN0aW9uIChhbmQgc3Vic2VjdGlvbiBpcyBOVUxMIGlmIGl0IGlzCiAqIG1pc3NpbmcpLgogKi8KZXh0ZXJuIGludCBwYXJzZV9jb25maWdfa2V5KGNvbnN0IGNoYXIgKnZhciwKCQkJICAgIGNvbnN0IGNoYXIgKnNlY3Rpb24sCgkJCSAgICBjb25zdCBjaGFyICoqc3Vic2VjdGlvbiwgaW50ICpzdWJzZWN0aW9uX2xlbiwKCQkJICAgIGNvbnN0IGNoYXIgKiprZXkpOwoKZXh0ZXJuIGludCBjb21taXR0ZXJfaWRlbnRfc3VmZmljaWVudGx5X2dpdmVuKHZvaWQpOwpleHRlcm4gaW50IGF1dGhvcl9pZGVudF9zdWZmaWNpZW50bHlfZ2l2ZW4odm9pZCk7CgpleHRlcm4gY29uc3QgY2hhciAqZ2l0X2NvbW1pdF9lbmNvZGluZzsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdpdF9sb2dfb3V0cHV0X2VuY29kaW5nOwpleHRlcm4gY29uc3QgY2hhciAqZ2l0X21haWxtYXBfZmlsZTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmdpdF9tYWlsbWFwX2Jsb2I7CgovKiBJTyBoZWxwZXIgZnVuY3Rpb25zICovCmV4dGVybiB2b2lkIG1heWJlX2ZsdXNoX29yX2RpZShGSUxFICosIGNvbnN0IGNoYXIgKik7CmV4dGVybiBpbnQgY29weV9mZChpbnQgaWZkLCBpbnQgb2ZkKTsKZXh0ZXJuIGludCBjb3B5X2ZpbGUoY29uc3QgY2hhciAqZHN0LCBjb25zdCBjaGFyICpzcmMsIGludCBtb2RlKTsKZXh0ZXJuIGludCBjb3B5X2ZpbGVfd2l0aF90aW1lKGNvbnN0IGNoYXIgKmRzdCwgY29uc3QgY2hhciAqc3JjLCBpbnQgbW9kZSk7CmV4dGVybiB2b2lkIHdyaXRlX29yX2RpZShpbnQgZmQsIGNvbnN0IHZvaWQgKmJ1Ziwgc2l6ZV90IGNvdW50KTsKZXh0ZXJuIGludCB3cml0ZV9vcl93aGluZShpbnQgZmQsIGNvbnN0IHZvaWQgKmJ1Ziwgc2l6ZV90IGNvdW50LCBjb25zdCBjaGFyICptc2cpOwpleHRlcm4gaW50IHdyaXRlX29yX3doaW5lX3BpcGUoaW50IGZkLCBjb25zdCB2b2lkICpidWYsIHNpemVfdCBjb3VudCwgY29uc3QgY2hhciAqbXNnKTsKZXh0ZXJuIHZvaWQgZnN5bmNfb3JfZGllKGludCBmZCwgY29uc3QgY2hhciAqKTsKCmV4dGVybiBzc2l6ZV90IHJlYWRfaW5fZnVsbChpbnQgZmQsIHZvaWQgKmJ1Ziwgc2l6ZV90IGNvdW50KTsKZXh0ZXJuIHNzaXplX3Qgd3JpdGVfaW5fZnVsbChpbnQgZmQsIGNvbnN0IHZvaWQgKmJ1Ziwgc2l6ZV90IGNvdW50KTsKc3RhdGljIGlubGluZSBzc2l6ZV90IHdyaXRlX3N0cl9pbl9mdWxsKGludCBmZCwgY29uc3QgY2hhciAqc3RyKQp7CglyZXR1cm4gd3JpdGVfaW5fZnVsbChmZCwgc3RyLCBzdHJsZW4oc3RyKSk7Cn0KCi8qIHBhZ2VyLmMgKi8KZXh0ZXJuIHZvaWQgc2V0dXBfcGFnZXIodm9pZCk7CmV4dGVybiBjb25zdCBjaGFyICpwYWdlcl9wcm9ncmFtOwpleHRlcm4gaW50IHBhZ2VyX2luX3VzZSh2b2lkKTsKZXh0ZXJuIGludCBwYWdlcl91c2VfY29sb3I7CmV4dGVybiBpbnQgdGVybV9jb2x1bW5zKHZvaWQpOwpleHRlcm4gaW50IGRlY2ltYWxfd2lkdGgoaW50KTsKZXh0ZXJuIGludCBjaGVja19wYWdlcl9jb25maWcoY29uc3QgY2hhciAqY21kKTsKCmV4dGVybiBjb25zdCBjaGFyICplZGl0b3JfcHJvZ3JhbTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmFza3Bhc3NfcHJvZ3JhbTsKZXh0ZXJuIGNvbnN0IGNoYXIgKmV4Y2x1ZGVzX2ZpbGU7CgovKiBiYXNlODUgKi8KaW50IGRlY29kZV84NShjaGFyICpkc3QsIGNvbnN0IGNoYXIgKmxpbmUsIGludCBsaW5lbGVuKTsKdm9pZCBlbmNvZGVfODUoY2hhciAqYnVmLCBjb25zdCB1bnNpZ25lZCBjaGFyICpkYXRhLCBpbnQgYnl0ZXMpOwoKLyogYWxsb2MuYyAqLwpleHRlcm4gdm9pZCAqYWxsb2NfYmxvYl9ub2RlKHZvaWQpOwpleHRlcm4gdm9pZCAqYWxsb2NfdHJlZV9ub2RlKHZvaWQpOwpleHRlcm4gdm9pZCAqYWxsb2NfY29tbWl0X25vZGUodm9pZCk7CmV4dGVybiB2b2lkICphbGxvY190YWdfbm9kZSh2b2lkKTsKZXh0ZXJuIHZvaWQgKmFsbG9jX29iamVjdF9ub2RlKHZvaWQpOwpleHRlcm4gdm9pZCBhbGxvY19yZXBvcnQodm9pZCk7CgovKiB0cmFjZS5jICovCl9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpCmV4dGVybiB2b2lkIHRyYWNlX3ByaW50Zihjb25zdCBjaGFyICpmb3JtYXQsIC4uLik7Cl9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAyLCAzKSkpCmV4dGVybiB2b2lkIHRyYWNlX2FyZ3ZfcHJpbnRmKGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpmb3JtYXQsIC4uLik7CmV4dGVybiB2b2lkIHRyYWNlX3JlcG9fc2V0dXAoY29uc3QgY2hhciAqcHJlZml4KTsKZXh0ZXJuIGludCB0cmFjZV93YW50KGNvbnN0IGNoYXIgKmtleSk7Cl9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAyLCAzKSkpCmV4dGVybiB2b2lkIHRyYWNlX3ByaW50Zl9rZXkoY29uc3QgY2hhciAqa2V5LCBjb25zdCBjaGFyICpmbXQsIC4uLik7CmV4dGVybiB2b2lkIHRyYWNlX3N0cmJ1Zihjb25zdCBjaGFyICprZXksIGNvbnN0IHN0cnVjdCBzdHJidWYgKmJ1Zik7Cgp2b2lkIHBhY2tldF90cmFjZV9pZGVudGl0eShjb25zdCBjaGFyICpwcm9nKTsKCi8qIGFkZCAqLwovKgogKiByZXR1cm4gMCBpZiBzdWNjZXNzLCAxIC0gaWYgYWRkaXRpb24gb2YgYSBmaWxlIGZhaWxlZCBhbmQKICogQUREX0ZJTEVTX0lHTk9SRV9FUlJPUlMgd2FzIHNwZWNpZmllZCBpbiBmbGFncwogKi8KaW50IGFkZF9maWxlc190b19jYWNoZShjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcGF0aHNwZWMsIGludCBmbGFncyk7CgovKiBkaWZmLmMgKi8KZXh0ZXJuIGludCBkaWZmX2F1dG9fcmVmcmVzaF9pbmRleDsKCi8qIG1hdGNoLXRyZWVzLmMgKi8Kdm9pZCBzaGlmdF90cmVlKGNvbnN0IHVuc2lnbmVkIGNoYXIgKiwgY29uc3QgdW5zaWduZWQgY2hhciAqLCB1bnNpZ25lZCBjaGFyICosIGludCk7CnZvaWQgc2hpZnRfdHJlZV9ieShjb25zdCB1bnNpZ25lZCBjaGFyICosIGNvbnN0IHVuc2lnbmVkIGNoYXIgKiwgdW5zaWduZWQgY2hhciAqLCBjb25zdCBjaGFyICopOwoKLyoKICogd2hpdGVzcGFjZSBydWxlcy4KICogdXNlZCBieSBib3RoIGRpZmYgYW5kIGFwcGx5CiAqIGxhc3QgdHdvIGRpZ2l0cyBhcmUgdGFiIHdpZHRoCiAqLwojZGVmaW5lIFdTX0JMQU5LX0FUX0VPTCAgICAgICAgIDAxMDAKI2RlZmluZSBXU19TUEFDRV9CRUZPUkVfVEFCICAgICAwMjAwCiNkZWZpbmUgV1NfSU5ERU5UX1dJVEhfTk9OX1RBQiAgMDQwMAojZGVmaW5lIFdTX0NSX0FUX0VPTCAgICAgICAgICAgMDEwMDAKI2RlZmluZSBXU19CTEFOS19BVF9FT0YgICAgICAgIDAyMDAwCiNkZWZpbmUgV1NfVEFCX0lOX0lOREVOVCAgICAgICAwNDAwMAojZGVmaW5lIFdTX1RSQUlMSU5HX1NQQUNFICAgICAgKFdTX0JMQU5LX0FUX0VPTHxXU19CTEFOS19BVF9FT0YpCiNkZWZpbmUgV1NfREVGQVVMVF9SVUxFIChXU19UUkFJTElOR19TUEFDRXxXU19TUEFDRV9CRUZPUkVfVEFCfDgpCiNkZWZpbmUgV1NfVEFCX1dJRFRIX01BU0sgICAgICAgIDA3NwpleHRlcm4gdW5zaWduZWQgd2hpdGVzcGFjZV9ydWxlX2NmZzsKZXh0ZXJuIHVuc2lnbmVkIHdoaXRlc3BhY2VfcnVsZShjb25zdCBjaGFyICopOwpleHRlcm4gdW5zaWduZWQgcGFyc2Vfd2hpdGVzcGFjZV9ydWxlKGNvbnN0IGNoYXIgKik7CmV4dGVybiB1bnNpZ25lZCB3c19jaGVjayhjb25zdCBjaGFyICpsaW5lLCBpbnQgbGVuLCB1bnNpZ25lZCB3c19ydWxlKTsKZXh0ZXJuIHZvaWQgd3NfY2hlY2tfZW1pdChjb25zdCBjaGFyICpsaW5lLCBpbnQgbGVuLCB1bnNpZ25lZCB3c19ydWxlLCBGSUxFICpzdHJlYW0sIGNvbnN0IGNoYXIgKnNldCwgY29uc3QgY2hhciAqcmVzZXQsIGNvbnN0IGNoYXIgKndzKTsKZXh0ZXJuIGNoYXIgKndoaXRlc3BhY2VfZXJyb3Jfc3RyaW5nKHVuc2lnbmVkIHdzKTsKZXh0ZXJuIHZvaWQgd3NfZml4X2NvcHkoc3RydWN0IHN0cmJ1ZiAqLCBjb25zdCBjaGFyICosIGludCwgdW5zaWduZWQsIGludCAqKTsKZXh0ZXJuIGludCB3c19ibGFua19saW5lKGNvbnN0IGNoYXIgKmxpbmUsIGludCBsZW4sIHVuc2lnbmVkIHdzX3J1bGUpOwojZGVmaW5lIHdzX3RhYl93aWR0aChydWxlKSAgICAgKChydWxlKSAmIFdTX1RBQl9XSURUSF9NQVNLKQoKLyogbHMtZmlsZXMgKi8KaW50IHJlcG9ydF9wYXRoX2Vycm9yKGNvbnN0IGNoYXIgKnBzX21hdGNoZWQsIGNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcGF0aHNwZWMsIGNvbnN0IGNoYXIgKnByZWZpeCk7CnZvaWQgb3ZlcmxheV90cmVlX29uX2NhY2hlKGNvbnN0IGNoYXIgKnRyZWVfbmFtZSwgY29uc3QgY2hhciAqcHJlZml4KTsKCmNoYXIgKmFsaWFzX2xvb2t1cChjb25zdCBjaGFyICphbGlhcyk7CmludCBzcGxpdF9jbWRsaW5lKGNoYXIgKmNtZGxpbmUsIGNvbnN0IGNoYXIgKioqYXJndik7Ci8qIFRha2VzIGEgbmVnYXRpdmUgdmFsdWUgcmV0dXJuZWQgYnkgc3BsaXRfY21kbGluZSAqLwpjb25zdCBjaGFyICpzcGxpdF9jbWRsaW5lX3N0cmVycm9yKGludCBjbWRsaW5lX2Vycm5vKTsKCi8qIGdpdC5jICovCnN0cnVjdCBzdGFydHVwX2luZm8gewoJaW50IGhhdmVfcmVwb3NpdG9yeTsKCWNvbnN0IGNoYXIgKnByZWZpeDsKfTsKZXh0ZXJuIHN0cnVjdCBzdGFydHVwX2luZm8gKnN0YXJ0dXBfaW5mbzsKCi8qIG1lcmdlLmMgKi8Kc3RydWN0IGNvbW1pdF9saXN0OwppbnQgdHJ5X21lcmdlX2NvbW1hbmQoY29uc3QgY2hhciAqc3RyYXRlZ3ksIHNpemVfdCB4b3B0c19uciwKCQljb25zdCBjaGFyICoqeG9wdHMsIHN0cnVjdCBjb21taXRfbGlzdCAqY29tbW9uLAoJCWNvbnN0IGNoYXIgKmhlYWRfYXJnLCBzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlbW90ZXMpOwppbnQgY2hlY2tvdXRfZmFzdF9mb3J3YXJkKGNvbnN0IHVuc2lnbmVkIGNoYXIgKmZyb20sCgkJCSAgY29uc3QgdW5zaWduZWQgY2hhciAqdG8sCgkJCSAgaW50IG92ZXJ3cml0ZV9pZ25vcmUpOwoKCmludCBzYW5lX2V4ZWN2cChjb25zdCBjaGFyICpmaWxlLCBjaGFyICpjb25zdCBhcmd2W10pOwoKLyoKICogQSBzdHJ1Y3QgdG8gZW5jYXBzdWxhdGUgdGhlIGNvbmNlcHQgb2Ygd2hldGhlciBhIGZpbGUgaGFzIGNoYW5nZWQKICogc2luY2Ugd2UgbGFzdCBjaGVja2VkIGl0LiBUaGlzIHVzZXMgY3JpdGVyaWEgc2ltaWxhciB0byB0aG9zZSB1c2VkCiAqIGZvciB0aGUgaW5kZXguCiAqLwpzdHJ1Y3Qgc3RhdF92YWxpZGl0eSB7CglzdHJ1Y3Qgc3RhdF9kYXRhICpzZDsKfTsKCnZvaWQgc3RhdF92YWxpZGl0eV9jbGVhcihzdHJ1Y3Qgc3RhdF92YWxpZGl0eSAqc3YpOwoKLyoKICogUmV0dXJucyAxIGlmIHRoZSBwYXRoIGlzIGEgcmVndWxhciBmaWxlIChvciBhIHN5bWxpbmsgdG8gYSByZWd1bGFyCiAqIGZpbGUpIGFuZCBtYXRjaGVzIHRoZSBzYXZlZCBzdGF0X3ZhbGlkaXR5LCAwIG90aGVyd2lzZS4gIEEgbWlzc2luZwogKiBvciBpbmFjY2Vzc2libGUgZmlsZSBpcyBjb25zaWRlcmVkIGEgbWF0Y2ggaWYgdGhlIHN0cnVjdCB3YXMganVzdAogKiBpbml0aWFsaXplZCwgb3IgaWYgdGhlIHByZXZpb3VzIHVwZGF0ZSBmb3VuZCBhbiBpbmFjY2Vzc2libGUgZmlsZS4KICovCmludCBzdGF0X3ZhbGlkaXR5X2NoZWNrKHN0cnVjdCBzdGF0X3ZhbGlkaXR5ICpzdiwgY29uc3QgY2hhciAqcGF0aCk7CgovKgogKiBVcGRhdGUgdGhlIHN0YXRfdmFsaWRpdHkgZnJvbSBhIGZpbGUgb3BlbmVkIGF0IGRlc2NyaXB0b3IgZmQuIElmCiAqIHRoZSBmaWxlIGlzIG1pc3NpbmcsIGluYWNjZXNzaWJsZSwgb3Igbm90IGEgcmVndWxhciBmaWxlLCB0aGVuCiAqIGZ1dHVyZSBjYWxscyB0byBzdGF0X3ZhbGlkaXR5X2NoZWNrIHdpbGwgbWF0Y2ggaWZmIG9uZSBvZiB0aG9zZQogKiBjb25kaXRpb25zIGNvbnRpbnVlcyB0byBiZSB0cnVlLgogKi8Kdm9pZCBzdGF0X3ZhbGlkaXR5X3VwZGF0ZShzdHJ1Y3Qgc3RhdF92YWxpZGl0eSAqc3YsIGludCBmZCk7CgojZW5kaWYgLyogQ0FDSEVfSCAqLwo=",
    "text": "#ifndef CACHE_H\n#define CACHE_H\n\n#include \"git-compat-util.h\"\n#include \"strbuf.h\"\n#include \"hashmap.h\"\n#include \"advice.h\"\n#include \"gettext.h\"\n#include \"convert.h\"\n\n#include SHA1_HEADER\n#ifndef git_SHA_CTX\n#define git_SHA_CTX\tSHA_CTX\n#define git_SHA1_Init\tSHA1_Init\n#define git_SHA1_Update\tSHA1_Update\n#define git_SHA1_Final\tSHA1_Final\n#endif\n\n#include <zlib.h>\ntypedef struct git_zstream {\n\tz_stream z;\n\tunsigned long avail_in;\n\tunsigned long avail_out;\n\tunsigned long total_in;\n\tunsigned long total_out;\n\tunsigned char *next_in;\n\tunsigned char *next_out;\n} git_zstream;\n\nvoid git_inflate_init(git_zstream *);\nvoid git_inflate_init_gzip_only(git_zstream *);\nvoid git_inflate_end(git_zstream *);\nint git_inflate(git_zstream *, int flush);\n\nvoid git_deflate_init(git_zstream *, int level);\nvoid git_deflate_init_gzip(git_zstream *, int level);\nvoid git_deflate_init_raw(git_zstream *, int level);\nvoid git_deflate_end(git_zstream *);\nint git_deflate_abort(git_zstream *);\nint git_deflate_end_gently(git_zstream *);\nint git_deflate(git_zstream *, int flush);\nunsigned long git_deflate_bound(git_zstream *, unsigned long);\n\n#if defined(DT_UNKNOWN) && !defined(NO_D_TYPE_IN_DIRENT)\n#define DTYPE(de)\t((de)->d_type)\n#else\n#undef DT_UNKNOWN\n#undef DT_DIR\n#undef DT_REG\n#undef DT_LNK\n#define DT_UNKNOWN\t0\n#define DT_DIR\t\t1\n#define DT_REG\t\t2\n#define DT_LNK\t\t3\n#define DTYPE(de)\tDT_UNKNOWN\n#endif\n\n/* unknown mode (impossible combination S_IFIFO|S_IFCHR) */\n#define S_IFINVALID     0030000\n\n/*\n * A \"directory link\" is a link to another git directory.\n *\n * The value 0160000 is not normally a valid mode, and\n * also just happens to be S_IFDIR + S_IFLNK\n *\n * NOTE! We *really* shouldn't depend on the S_IFxxx macros\n * always having the same values everywhere. We should use\n * our internal git values for these things, and then we can\n * translate that to the OS-specific value. It just so\n * happens that everybody shares the same bit representation\n * in the UNIX world (and apparently wider too..)\n */\n#define S_IFGITLINK\t0160000\n#define S_ISGITLINK(m)\t(((m) & S_IFMT) == S_IFGITLINK)\n\n/*\n * Intensive research over the course of many years has shown that\n * port 9418 is totally unused by anything else. Or\n *\n *\tYour search - \"port 9418\" - did not match any documents.\n *\n * as www.google.com puts it.\n *\n * This port has been properly assigned for git use by IANA:\n * git (Assigned-9418) [I06-050728-0001].\n *\n *\tgit  9418/tcp   git pack transfer service\n *\tgit  9418/udp   git pack transfer service\n *\n * with Linus Torvalds <torvalds@osdl.org> as the point of\n * contact. September 2005.\n *\n * See http://www.iana.org/assignments/port-numbers\n */\n#define DEFAULT_GIT_PORT 9418\n\n/*\n * Basic data structures for the directory cache\n */\n\n#define CACHE_SIGNATURE 0x44495243\t/* \"DIRC\" */\nstruct cache_header {\n\tuint32_t hdr_signature;\n\tuint32_t hdr_version;\n\tuint32_t hdr_entries;\n};\n\n#define INDEX_FORMAT_LB 2\n#define INDEX_FORMAT_UB 4\n\n/*\n * The \"cache_time\" is just the low 32 bits of the\n * time. It doesn't matter if it overflows - we only\n * check it for equality in the 32 bits we save.\n */\nstruct cache_time {\n\tuint32_t sec;\n\tuint32_t nsec;\n};\n\nstruct stat_data {\n\tstruct cache_time sd_ctime;\n\tstruct cache_time sd_mtime;\n\tunsigned int sd_dev;\n\tunsigned int sd_ino;\n\tunsigned int sd_uid;\n\tunsigned int sd_gid;\n\tunsigned int sd_size;\n};\n\nstruct cache_entry {\n\tstruct hashmap_entry ent;\n\tstruct stat_data ce_stat_data;\n\tunsigned int ce_mode;\n\tunsigned int ce_flags;\n\tunsigned int ce_namelen;\n\tunsigned char sha1[20];\n\tchar name[FLEX_ARRAY]; /* more */\n};\n\n#define CE_STAGEMASK (0x3000)\n#define CE_EXTENDED  (0x4000)\n#define CE_VALID     (0x8000)\n#define CE_STAGESHIFT 12\n\n/*\n * Range 0xFFFF0000 in ce_flags is divided into\n * two parts: in-memory flags and on-disk ones.\n * Flags in CE_EXTENDED_FLAGS will get saved on-disk\n * if you want to save a new flag, add it in\n * CE_EXTENDED_FLAGS\n *\n * In-memory only flags\n */\n#define CE_UPDATE            (1 << 16)\n#define CE_REMOVE            (1 << 17)\n#define CE_UPTODATE          (1 << 18)\n#define CE_ADDED             (1 << 19)\n\n#define CE_HASHED            (1 << 20)\n#define CE_WT_REMOVE         (1 << 22) /* remove in work directory */\n#define CE_CONFLICTED        (1 << 23)\n\n#define CE_UNPACKED          (1 << 24)\n#define CE_NEW_SKIP_WORKTREE (1 << 25)\n\n/* used to temporarily mark paths matched by pathspecs */\n#define CE_MATCHED           (1 << 26)\n\n/*\n * Extended on-disk flags\n */\n#define CE_INTENT_TO_ADD     (1 << 29)\n#define CE_SKIP_WORKTREE     (1 << 30)\n/* CE_EXTENDED2 is for future extension */\n#define CE_EXTENDED2         (1 << 31)\n\n#define CE_EXTENDED_FLAGS (CE_INTENT_TO_ADD | CE_SKIP_WORKTREE)\n\n/*\n * Safeguard to avoid saving wrong flags:\n *  - CE_EXTENDED2 won't get saved until its semantic is known\n *  - Bits in 0x0000FFFF have been saved in ce_flags already\n *  - Bits in 0x003F0000 are currently in-memory flags\n */\n#if CE_EXTENDED_FLAGS & 0x803FFFFF\n#error \"CE_EXTENDED_FLAGS out of range\"\n#endif\n\nstruct pathspec;\n\n/*\n * Copy the sha1 and stat state of a cache entry from one to\n * another. But we never change the name, or the hash state!\n */\nstatic inline void copy_cache_entry(struct cache_entry *dst,\n\t\t\t\t    const struct cache_entry *src)\n{\n\tunsigned int state = dst->ce_flags & CE_HASHED;\n\n\t/* Don't copy hash chain and name */\n\tmemcpy(&dst->ce_stat_data, &src->ce_stat_data,\n\t\t\toffsetof(struct cache_entry, name) -\n\t\t\toffsetof(struct cache_entry, ce_stat_data));\n\n\t/* Restore the hash state */\n\tdst->ce_flags = (dst->ce_flags & ~CE_HASHED) | state;\n}\n\nstatic inline unsigned create_ce_flags(unsigned stage)\n{\n\treturn (stage << CE_STAGESHIFT);\n}\n\n#define ce_namelen(ce) ((ce)->ce_namelen)\n#define ce_size(ce) cache_entry_size(ce_namelen(ce))\n#define ce_stage(ce) ((CE_STAGEMASK & (ce)->ce_flags) >> CE_STAGESHIFT)\n#define ce_uptodate(ce) ((ce)->ce_flags & CE_UPTODATE)\n#define ce_skip_worktree(ce) ((ce)->ce_flags & CE_SKIP_WORKTREE)\n#define ce_mark_uptodate(ce) ((ce)->ce_flags |= CE_UPTODATE)\n\n#define ce_permissions(mode) (((mode) & 0100) ? 0755 : 0644)\nstatic inline unsigned int create_ce_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\tif (S_ISDIR(mode) || S_ISGITLINK(mode))\n\t\treturn S_IFGITLINK;\n\treturn S_IFREG | ce_permissions(mode);\n}\nstatic inline unsigned int ce_mode_from_stat(const struct cache_entry *ce,\n\t\t\t\t\t     unsigned int mode)\n{\n\textern int trust_executable_bit, has_symlinks;\n\tif (!has_symlinks && S_ISREG(mode) &&\n\t    ce && S_ISLNK(ce->ce_mode))\n\t\treturn ce->ce_mode;\n\tif (!trust_executable_bit && S_ISREG(mode)) {\n\t\tif (ce && S_ISREG(ce->ce_mode))\n\t\t\treturn ce->ce_mode;\n\t\treturn create_ce_mode(0666);\n\t}\n\treturn create_ce_mode(mode);\n}\nstatic inline int ce_to_dtype(const struct cache_entry *ce)\n{\n\tunsigned ce_mode = ntohl(ce->ce_mode);\n\tif (S_ISREG(ce_mode))\n\t\treturn DT_REG;\n\telse if (S_ISDIR(ce_mode) || S_ISGITLINK(ce_mode))\n\t\treturn DT_DIR;\n\telse if (S_ISLNK(ce_mode))\n\t\treturn DT_LNK;\n\telse\n\t\treturn DT_UNKNOWN;\n}\nstatic inline unsigned int canon_mode(unsigned int mode)\n{\n\tif (S_ISREG(mode))\n\t\treturn S_IFREG | ce_permissions(mode);\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\tif (S_ISDIR(mode))\n\t\treturn S_IFDIR;\n\treturn S_IFGITLINK;\n}\n\n#define cache_entry_size(len) (offsetof(struct cache_entry,name) + (len) + 1)\n\nstruct index_state {\n\tstruct cache_entry **cache;\n\tunsigned int version;\n\tunsigned int cache_nr, cache_alloc, cache_changed;\n\tstruct string_list *resolve_undo;\n\tstruct cache_tree *cache_tree;\n\tstruct cache_time timestamp;\n\tunsigned name_hash_initialized : 1,\n\t\t initialized : 1;\n\tstruct hashmap name_hash;\n\tstruct hashmap dir_hash;\n};\n\nextern struct index_state the_index;\n\n/* Name hashing */\nextern void add_name_hash(struct index_state *istate, struct cache_entry *ce);\nextern void remove_name_hash(struct index_state *istate, struct cache_entry *ce);\nextern void free_name_hash(struct index_state *istate);\n\n\n#ifndef NO_THE_INDEX_COMPATIBILITY_MACROS\n#define active_cache (the_index.cache)\n#define active_nr (the_index.cache_nr)\n#define active_alloc (the_index.cache_alloc)\n#define active_cache_changed (the_index.cache_changed)\n#define active_cache_tree (the_index.cache_tree)\n\n#define read_cache() read_index(&the_index)\n#define read_cache_from(path) read_index_from(&the_index, (path))\n#define read_cache_preload(pathspec) read_index_preload(&the_index, (pathspec))\n#define is_cache_unborn() is_index_unborn(&the_index)\n#define read_cache_unmerged() read_index_unmerged(&the_index)\n#define write_cache(newfd, cache, entries) write_index(&the_index, (newfd))\n#define discard_cache() discard_index(&the_index)\n#define unmerged_cache() unmerged_index(&the_index)\n#define cache_name_pos(name, namelen) index_name_pos(&the_index,(name),(namelen))\n#define add_cache_entry(ce, option) add_index_entry(&the_index, (ce), (option))\n#define rename_cache_entry_at(pos, new_name) rename_index_entry_at(&the_index, (pos), (new_name))\n#define remove_cache_entry_at(pos) remove_index_entry_at(&the_index, (pos))\n#define remove_file_from_cache(path) remove_file_from_index(&the_index, (path))\n#define add_to_cache(path, st, flags) add_to_index(&the_index, (path), (st), (flags))\n#define add_file_to_cache(path, flags) add_file_to_index(&the_index, (path), (flags))\n#define refresh_cache(flags) refresh_index(&the_index, (flags), NULL, NULL, NULL)\n#define ce_match_stat(ce, st, options) ie_match_stat(&the_index, (ce), (st), (options))\n#define ce_modified(ce, st, options) ie_modified(&the_index, (ce), (st), (options))\n#define cache_dir_exists(name, namelen) index_dir_exists(&the_index, (name), (namelen))\n#define cache_file_exists(name, namelen, igncase) index_file_exists(&the_index, (name), (namelen), (igncase))\n#define cache_name_is_other(name, namelen) index_name_is_other(&the_index, (name), (namelen))\n#define resolve_undo_clear() resolve_undo_clear_index(&the_index)\n#define unmerge_cache_entry_at(at) unmerge_index_entry_at(&the_index, at)\n#define unmerge_cache(pathspec) unmerge_index(&the_index, pathspec)\n#define read_blob_data_from_cache(path, sz) read_blob_data_from_index(&the_index, (path), (sz))\n#endif\n\nenum object_type {\n\tOBJ_BAD = -1,\n\tOBJ_NONE = 0,\n\tOBJ_COMMIT = 1,\n\tOBJ_TREE = 2,\n\tOBJ_BLOB = 3,\n\tOBJ_TAG = 4,\n\t/* 5 for future expansion */\n\tOBJ_OFS_DELTA = 6,\n\tOBJ_REF_DELTA = 7,\n\tOBJ_ANY,\n\tOBJ_MAX\n};\n\nstatic inline enum object_type object_type(unsigned int mode)\n{\n\treturn S_ISDIR(mode) ? OBJ_TREE :\n\t\tS_ISGITLINK(mode) ? OBJ_COMMIT :\n\t\tOBJ_BLOB;\n}\n\n/* Double-check local_repo_env below if you add to this list. */\n#define GIT_DIR_ENVIRONMENT \"GIT_DIR\"\n#define GIT_NAMESPACE_ENVIRONMENT \"GIT_NAMESPACE\"\n#define GIT_WORK_TREE_ENVIRONMENT \"GIT_WORK_TREE\"\n#define GIT_PREFIX_ENVIRONMENT \"GIT_PREFIX\"\n#define DEFAULT_GIT_DIR_ENVIRONMENT \".git\"\n#define DB_ENVIRONMENT \"GIT_OBJECT_DIRECTORY\"\n#define INDEX_ENVIRONMENT \"GIT_INDEX_FILE\"\n#define GRAFT_ENVIRONMENT \"GIT_GRAFT_FILE\"\n#define GIT_SHALLOW_FILE_ENVIRONMENT \"GIT_SHALLOW_FILE\"\n#define TEMPLATE_DIR_ENVIRONMENT \"GIT_TEMPLATE_DIR\"\n#define CONFIG_ENVIRONMENT \"GIT_CONFIG\"\n#define CONFIG_DATA_ENVIRONMENT \"GIT_CONFIG_PARAMETERS\"\n#define EXEC_PATH_ENVIRONMENT \"GIT_EXEC_PATH\"\n#define CEILING_DIRECTORIES_ENVIRONMENT \"GIT_CEILING_DIRECTORIES\"\n#define NO_REPLACE_OBJECTS_ENVIRONMENT \"GIT_NO_REPLACE_OBJECTS\"\n#define GITATTRIBUTES_FILE \".gitattributes\"\n#define INFOATTRIBUTES_FILE \"info/attributes\"\n#define ATTRIBUTE_MACRO_PREFIX \"[attr]\"\n#define GIT_NOTES_REF_ENVIRONMENT \"GIT_NOTES_REF\"\n#define GIT_NOTES_DEFAULT_REF \"refs/notes/commits\"\n#define GIT_NOTES_DISPLAY_REF_ENVIRONMENT \"GIT_NOTES_DISPLAY_REF\"\n#define GIT_NOTES_REWRITE_REF_ENVIRONMENT \"GIT_NOTES_REWRITE_REF\"\n#define GIT_NOTES_REWRITE_MODE_ENVIRONMENT \"GIT_NOTES_REWRITE_MODE\"\n#define GIT_LITERAL_PATHSPECS_ENVIRONMENT \"GIT_LITERAL_PATHSPECS\"\n#define GIT_GLOB_PATHSPECS_ENVIRONMENT \"GIT_GLOB_PATHSPECS\"\n#define GIT_NOGLOB_PATHSPECS_ENVIRONMENT \"GIT_NOGLOB_PATHSPECS\"\n#define GIT_ICASE_PATHSPECS_ENVIRONMENT \"GIT_ICASE_PATHSPECS\"\n\n/*\n * This environment variable is expected to contain a boolean indicating\n * whether we should or should not treat:\n *\n *   GIT_DIR=foo.git git ...\n *\n * as if GIT_WORK_TREE=. was given. It's not expected that users will make use\n * of this, but we use it internally to communicate to sub-processes that we\n * are in a bare repo. If not set, defaults to true.\n */\n#define GIT_IMPLICIT_WORK_TREE_ENVIRONMENT \"GIT_IMPLICIT_WORK_TREE\"\n\n/*\n * Repository-local GIT_* environment variables; these will be cleared\n * when git spawns a sub-process that runs inside another repository.\n * The array is NULL-terminated, which makes it easy to pass in the \"env\"\n * parameter of a run-command invocation, or to do a simple walk.\n */\nextern const char * const local_repo_env[];\n\nextern int is_bare_repository_cfg;\nextern int is_bare_repository(void);\nextern int is_inside_git_dir(void);\nextern char *git_work_tree_cfg;\nextern int is_inside_work_tree(void);\nextern const char *get_git_dir(void);\nextern int is_git_directory(const char *path);\nextern char *get_object_directory(void);\nextern char *get_index_file(void);\nextern char *get_graft_file(void);\nextern int set_git_dir(const char *path);\nextern const char *get_git_namespace(void);\nextern const char *strip_namespace(const char *namespaced_ref);\nextern const char *get_git_work_tree(void);\nextern const char *read_gitfile(const char *path);\nextern const char *resolve_gitdir(const char *suspect);\nextern void set_git_work_tree(const char *tree);\n\n#define ALTERNATE_DB_ENVIRONMENT \"GIT_ALTERNATE_OBJECT_DIRECTORIES\"\n\nextern const char **get_pathspec(const char *prefix, const char **pathspec);\nextern void setup_work_tree(void);\nextern const char *setup_git_directory_gently(int *);\nextern const char *setup_git_directory(void);\nextern char *prefix_path(const char *prefix, int len, const char *path);\nextern char *prefix_path_gently(const char *prefix, int len, int *remaining, const char *path);\nextern const char *prefix_filename(const char *prefix, int len, const char *path);\nextern int check_filename(const char *prefix, const char *name);\nextern void verify_filename(const char *prefix,\n\t\t\t    const char *name,\n\t\t\t    int diagnose_misspelt_rev);\nextern void verify_non_filename(const char *prefix, const char *name);\nextern int path_inside_repo(const char *prefix, const char *path);\n\n#define INIT_DB_QUIET 0x0001\n\nextern int set_git_dir_init(const char *git_dir, const char *real_git_dir, int);\nextern int init_db(const char *template_dir, unsigned int flags);\n\nextern void sanitize_stdfds(void);\nextern int daemonize(void);\n\n#define alloc_nr(x) (((x)+16)*3/2)\n\n/*\n * Realloc the buffer pointed at by variable 'x' so that it can hold\n * at least 'nr' entries; the number of entries currently allocated\n * is 'alloc', using the standard growing factor alloc_nr() macro.\n *\n * DO NOT USE any expression with side-effect for 'x', 'nr', or 'alloc'.\n */\n#define ALLOC_GROW(x, nr, alloc) \\\n\tdo { \\\n\t\tif ((nr) > alloc) { \\\n\t\t\tif (alloc_nr(alloc) < (nr)) \\\n\t\t\t\talloc = (nr); \\\n\t\t\telse \\\n\t\t\t\talloc = alloc_nr(alloc); \\\n\t\t\tx = xrealloc((x), alloc * sizeof(*(x))); \\\n\t\t} \\\n\t} while (0)\n\n/* Initialize and use the cache information */\nextern int read_index(struct index_state *);\nextern int read_index_preload(struct index_state *, const struct pathspec *pathspec);\nextern int read_index_from(struct index_state *, const char *path);\nextern int is_index_unborn(struct index_state *);\nextern int read_index_unmerged(struct index_state *);\nextern int write_index(struct index_state *, int newfd);\nextern int discard_index(struct index_state *);\nextern int unmerged_index(const struct index_state *);\nextern int verify_path(const char *path);\nextern struct cache_entry *index_dir_exists(struct index_state *istate, const char *name, int namelen);\nextern struct cache_entry *index_file_exists(struct index_state *istate, const char *name, int namelen, int igncase);\nextern int index_name_pos(const struct index_state *, const char *name, int namelen);\n#define ADD_CACHE_OK_TO_ADD 1\t\t/* Ok to add */\n#define ADD_CACHE_OK_TO_REPLACE 2\t/* Ok to replace file/directory */\n#define ADD_CACHE_SKIP_DFCHECK 4\t/* Ok to skip DF conflict checks */\n#define ADD_CACHE_JUST_APPEND 8\t\t/* Append only; tree.c::read_tree() */\n#define ADD_CACHE_NEW_ONLY 16\t\t/* Do not replace existing ones */\nextern int add_index_entry(struct index_state *, struct cache_entry *ce, int option);\nextern void rename_index_entry_at(struct index_state *, int pos, const char *new_name);\nextern int remove_index_entry_at(struct index_state *, int pos);\nextern void remove_marked_cache_entries(struct index_state *istate);\nextern int remove_file_from_index(struct index_state *, const char *path);\n#define ADD_CACHE_VERBOSE 1\n#define ADD_CACHE_PRETEND 2\n#define ADD_CACHE_IGNORE_ERRORS\t4\n#define ADD_CACHE_IGNORE_REMOVAL 8\n#define ADD_CACHE_INTENT 16\nextern int add_to_index(struct index_state *, const char *path, struct stat *, int flags);\nextern int add_file_to_index(struct index_state *, const char *path, int flags);\nextern struct cache_entry *make_cache_entry(unsigned int mode, const unsigned char *sha1, const char *path, int stage, unsigned int refresh_options);\nextern int ce_same_name(const struct cache_entry *a, const struct cache_entry *b);\nextern void set_object_name_for_intent_to_add_entry(struct cache_entry *ce);\nextern int index_name_is_other(const struct index_state *, const char *, int);\nextern void *read_blob_data_from_index(struct index_state *, const char *, unsigned long *);\n\n/* do stat comparison even if CE_VALID is true */\n#define CE_MATCH_IGNORE_VALID\t\t01\n/* do not check the contents but report dirty on racily-clean entries */\n#define CE_MATCH_RACY_IS_DIRTY\t\t02\n/* do stat comparison even if CE_SKIP_WORKTREE is true */\n#define CE_MATCH_IGNORE_SKIP_WORKTREE\t04\n/* ignore non-existent files during stat update  */\n#define CE_MATCH_IGNORE_MISSING\t\t0x08\n/* enable stat refresh */\n#define CE_MATCH_REFRESH\t\t0x10\nextern int ie_match_stat(const struct index_state *, const struct cache_entry *, struct stat *, unsigned int);\nextern int ie_modified(const struct index_state *, const struct cache_entry *, struct stat *, unsigned int);\n\n#define HASH_WRITE_OBJECT 1\n#define HASH_FORMAT_CHECK 2\nextern int index_fd(unsigned char *sha1, int fd, struct stat *st, enum object_type type, const char *path, unsigned flags);\nextern int index_path(unsigned char *sha1, const char *path, struct stat *st, unsigned flags);\n\n/*\n * Record to sd the data from st that we use to check whether a file\n * might have changed.\n */\nextern void fill_stat_data(struct stat_data *sd, struct stat *st);\n\n/*\n * Return 0 if st is consistent with a file not having been changed\n * since sd was filled.  If there are differences, return a\n * combination of MTIME_CHANGED, CTIME_CHANGED, OWNER_CHANGED,\n * INODE_CHANGED, and DATA_CHANGED.\n */\nextern int match_stat_data(const struct stat_data *sd, struct stat *st);\n\nextern void fill_stat_cache_info(struct cache_entry *ce, struct stat *st);\n\n#define REFRESH_REALLY\t\t0x0001\t/* ignore_valid */\n#define REFRESH_UNMERGED\t0x0002\t/* allow unmerged */\n#define REFRESH_QUIET\t\t0x0004\t/* be quiet about it */\n#define REFRESH_IGNORE_MISSING\t0x0008\t/* ignore non-existent */\n#define REFRESH_IGNORE_SUBMODULES\t0x0010\t/* ignore submodules */\n#define REFRESH_IN_PORCELAIN\t0x0020\t/* user friendly output, not \"needs update\" */\nextern int refresh_index(struct index_state *, unsigned int flags, const struct pathspec *pathspec, char *seen, const char *header_msg);\n\nstruct lock_file {\n\tstruct lock_file *next;\n\tint fd;\n\tpid_t owner;\n\tchar on_list;\n\tchar filename[PATH_MAX];\n};\n#define LOCK_DIE_ON_ERROR 1\n#define LOCK_NODEREF 2\nextern int unable_to_lock_error(const char *path, int err);\nextern NORETURN void unable_to_lock_index_die(const char *path, int err);\nextern int hold_lock_file_for_update(struct lock_file *, const char *path, int);\nextern int hold_lock_file_for_append(struct lock_file *, const char *path, int);\nextern int commit_lock_file(struct lock_file *);\nextern void update_index_if_able(struct index_state *, struct lock_file *);\n\nextern int hold_locked_index(struct lock_file *, int);\nextern int commit_locked_index(struct lock_file *);\nextern void set_alternate_index_output(const char *);\nextern int close_lock_file(struct lock_file *);\nextern void rollback_lock_file(struct lock_file *);\nextern int delete_ref(const char *, const unsigned char *sha1, int delopt);\n\n/* Environment bits from configuration mechanism */\nextern int trust_executable_bit;\nextern int trust_ctime;\nextern int check_stat;\nextern int quote_path_fully;\nextern int has_symlinks;\nextern int minimum_abbrev, default_abbrev;\nextern int ignore_case;\nextern int assume_unchanged;\nextern int prefer_symlink_refs;\nextern int log_all_ref_updates;\nextern int warn_ambiguous_refs;\nextern int warn_on_object_refname_ambiguity;\nextern int shared_repository;\nextern const char *apply_default_whitespace;\nextern const char *apply_default_ignorewhitespace;\nextern const char *git_attributes_file;\nextern int zlib_compression_level;\nextern int core_compression_level;\nextern int core_compression_seen;\nextern size_t packed_git_window_size;\nextern size_t packed_git_limit;\nextern size_t delta_base_cache_limit;\nextern unsigned long big_file_threshold;\nextern unsigned long pack_size_limit_cfg;\nextern int read_replace_refs;\nextern int fsync_object_files;\nextern int core_preload_index;\nextern int core_apply_sparse_checkout;\nextern int precomposed_unicode;\n\n/*\n * The character that begins a commented line in user-editable file\n * that is subject to stripspace.\n */\nextern char comment_line_char;\n\nenum branch_track {\n\tBRANCH_TRACK_UNSPECIFIED = -1,\n\tBRANCH_TRACK_NEVER = 0,\n\tBRANCH_TRACK_REMOTE,\n\tBRANCH_TRACK_ALWAYS,\n\tBRANCH_TRACK_EXPLICIT,\n\tBRANCH_TRACK_OVERRIDE\n};\n\nenum rebase_setup_type {\n\tAUTOREBASE_NEVER = 0,\n\tAUTOREBASE_LOCAL,\n\tAUTOREBASE_REMOTE,\n\tAUTOREBASE_ALWAYS\n};\n\nenum push_default_type {\n\tPUSH_DEFAULT_NOTHING = 0,\n\tPUSH_DEFAULT_MATCHING,\n\tPUSH_DEFAULT_SIMPLE,\n\tPUSH_DEFAULT_UPSTREAM,\n\tPUSH_DEFAULT_CURRENT,\n\tPUSH_DEFAULT_UNSPECIFIED\n};\n\nextern enum branch_track git_branch_track;\nextern enum rebase_setup_type autorebase;\nextern enum push_default_type push_default;\n\nenum object_creation_mode {\n\tOBJECT_CREATION_USES_HARDLINKS = 0,\n\tOBJECT_CREATION_USES_RENAMES = 1\n};\n\nextern enum object_creation_mode object_creation_mode;\n\nextern char *notes_ref_name;\n\nextern int grafts_replace_parents;\n\n#define GIT_REPO_VERSION 0\nextern int repository_format_version;\nextern int check_repository_format(void);\n\n#define MTIME_CHANGED\t0x0001\n#define CTIME_CHANGED\t0x0002\n#define OWNER_CHANGED\t0x0004\n#define MODE_CHANGED    0x0008\n#define INODE_CHANGED   0x0010\n#define DATA_CHANGED    0x0020\n#define TYPE_CHANGED    0x0040\n\nextern char *mksnpath(char *buf, size_t n, const char *fmt, ...)\n\t__attribute__((format (printf, 3, 4)));\nextern char *git_snpath(char *buf, size_t n, const char *fmt, ...)\n\t__attribute__((format (printf, 3, 4)));\nextern char *git_pathdup(const char *fmt, ...)\n\t__attribute__((format (printf, 1, 2)));\nextern char *mkpathdup(const char *fmt, ...)\n\t__attribute__((format (printf, 1, 2)));\n\n/* Return a statically allocated filename matching the sha1 signature */\nextern char *mkpath(const char *fmt, ...) __attribute__((format (printf, 1, 2)));\nextern char *git_path(const char *fmt, ...) __attribute__((format (printf, 1, 2)));\nextern char *git_path_submodule(const char *path, const char *fmt, ...)\n\t__attribute__((format (printf, 2, 3)));\n\n/*\n * Return the name of the file in the local object database that would\n * be used to store a loose object with the specified sha1.  The\n * return value is a pointer to a statically allocated buffer that is\n * overwritten each time the function is called.\n */\nextern const char *sha1_file_name(const unsigned char *sha1);\n\n/*\n * Return the name of the (local) packfile with the specified sha1 in\n * its name.  The return value is a pointer to memory that is\n * overwritten each time this function is called.\n */\nextern char *sha1_pack_name(const unsigned char *sha1);\n\n/*\n * Return the name of the (local) pack index file with the specified\n * sha1 in its name.  The return value is a pointer to memory that is\n * overwritten each time this function is called.\n */\nextern char *sha1_pack_index_name(const unsigned char *sha1);\n\nextern const char *find_unique_abbrev(const unsigned char *sha1, int);\nextern const unsigned char null_sha1[20];\n\nstatic inline int hashcmp(const unsigned char *sha1, const unsigned char *sha2)\n{\n\tint i;\n\n\tfor (i = 0; i < 20; i++, sha1++, sha2++) {\n\t\tif (*sha1 != *sha2)\n\t\t\treturn *sha1 - *sha2;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int is_null_sha1(const unsigned char *sha1)\n{\n\treturn !hashcmp(sha1, null_sha1);\n}\n\nstatic inline void hashcpy(unsigned char *sha_dst, const unsigned char *sha_src)\n{\n\tmemcpy(sha_dst, sha_src, 20);\n}\nstatic inline void hashclr(unsigned char *hash)\n{\n\tmemset(hash, 0, 20);\n}\n\n#define EMPTY_TREE_SHA1_HEX \\\n\t\"4b825dc642cb6eb9a060e54bf8d69288fbee4904\"\n#define EMPTY_TREE_SHA1_BIN_LITERAL \\\n\t \"\\x4b\\x82\\x5d\\xc6\\x42\\xcb\\x6e\\xb9\\xa0\\x60\" \\\n\t \"\\xe5\\x4b\\xf8\\xd6\\x92\\x88\\xfb\\xee\\x49\\x04\"\n#define EMPTY_TREE_SHA1_BIN \\\n\t ((const unsigned char *) EMPTY_TREE_SHA1_BIN_LITERAL)\n\n#define EMPTY_BLOB_SHA1_HEX \\\n\t\"e69de29bb2d1d6434b8b29ae775ad8c2e48c5391\"\n#define EMPTY_BLOB_SHA1_BIN_LITERAL \\\n\t\"\\xe6\\x9d\\xe2\\x9b\\xb2\\xd1\\xd6\\x43\\x4b\\x8b\" \\\n\t\"\\x29\\xae\\x77\\x5a\\xd8\\xc2\\xe4\\x8c\\x53\\x91\"\n#define EMPTY_BLOB_SHA1_BIN \\\n\t((const unsigned char *) EMPTY_BLOB_SHA1_BIN_LITERAL)\n\nstatic inline int is_empty_blob_sha1(const unsigned char *sha1)\n{\n\treturn !hashcmp(sha1, EMPTY_BLOB_SHA1_BIN);\n}\n\nint git_mkstemp(char *path, size_t n, const char *template);\n\nint git_mkstemps(char *path, size_t n, const char *template, int suffix_len);\n\n/* set default permissions by passing mode arguments to open(2) */\nint git_mkstemps_mode(char *pattern, int suffix_len, int mode);\nint git_mkstemp_mode(char *pattern, int mode);\n\n/*\n * NOTE NOTE NOTE!!\n *\n * PERM_UMASK, OLD_PERM_GROUP and OLD_PERM_EVERYBODY enumerations must\n * not be changed. Old repositories have core.sharedrepository written in\n * numeric format, and therefore these values are preserved for compatibility\n * reasons.\n */\nenum sharedrepo {\n\tPERM_UMASK          = 0,\n\tOLD_PERM_GROUP      = 1,\n\tOLD_PERM_EVERYBODY  = 2,\n\tPERM_GROUP          = 0660,\n\tPERM_EVERYBODY      = 0664\n};\nint git_config_perm(const char *var, const char *value);\nint adjust_shared_perm(const char *path);\n\n/*\n * Create the directory containing the named path, using care to be\n * somewhat safe against races.  Return one of the scld_error values\n * to indicate success/failure.\n *\n * SCLD_VANISHED indicates that one of the ancestor directories of the\n * path existed at one point during the function call and then\n * suddenly vanished, probably because another process pruned the\n * directory while we were working.  To be robust against this kind of\n * race, callers might want to try invoking the function again when it\n * returns SCLD_VANISHED.\n */\nenum scld_error {\n\tSCLD_OK = 0,\n\tSCLD_FAILED = -1,\n\tSCLD_PERMS = -2,\n\tSCLD_EXISTS = -3,\n\tSCLD_VANISHED = -4\n};\nenum scld_error safe_create_leading_directories(char *path);\nenum scld_error safe_create_leading_directories_const(const char *path);\n\nint mkdir_in_gitdir(const char *path);\nextern void home_config_paths(char **global, char **xdg, char *file);\nextern char *expand_user_path(const char *path);\nconst char *enter_repo(const char *path, int strict);\nstatic inline int is_absolute_path(const char *path)\n{\n\treturn is_dir_sep(path[0]) || has_dos_drive_prefix(path);\n}\nint is_directory(const char *);\nconst char *real_path(const char *path);\nconst char *real_path_if_valid(const char *path);\nconst char *absolute_path(const char *path);\nconst char *remove_leading_path(const char *in, const char *prefix);\nconst char *relative_path(const char *in, const char *prefix, struct strbuf *sb);\nint normalize_path_copy_len(char *dst, const char *src, int *prefix_len);\nint normalize_path_copy(char *dst, const char *src);\nint longest_ancestor_length(const char *path, struct string_list *prefixes);\nchar *strip_path_suffix(const char *path, const char *suffix);\nint daemon_avoid_alias(const char *path);\nint offset_1st_component(const char *path);\n\n/* object replacement */\n#define LOOKUP_REPLACE_OBJECT 1\nextern void *read_sha1_file_extended(const unsigned char *sha1, enum object_type *type, unsigned long *size, unsigned flag);\nstatic inline void *read_sha1_file(const unsigned char *sha1, enum object_type *type, unsigned long *size)\n{\n\treturn read_sha1_file_extended(sha1, type, size, LOOKUP_REPLACE_OBJECT);\n}\nextern const unsigned char *do_lookup_replace_object(const unsigned char *sha1);\nstatic inline const unsigned char *lookup_replace_object(const unsigned char *sha1)\n{\n\tif (!read_replace_refs)\n\t\treturn sha1;\n\treturn do_lookup_replace_object(sha1);\n}\nstatic inline const unsigned char *lookup_replace_object_extended(const unsigned char *sha1, unsigned flag)\n{\n\tif (!(flag & LOOKUP_REPLACE_OBJECT))\n\t\treturn sha1;\n\treturn lookup_replace_object(sha1);\n}\n\n/* Read and unpack a sha1 file into memory, write memory to a sha1 file */\nextern int sha1_object_info(const unsigned char *, unsigned long *);\nextern int hash_sha1_file(const void *buf, unsigned long len, const char *type, unsigned char *sha1);\nextern int write_sha1_file(const void *buf, unsigned long len, const char *type, unsigned char *return_sha1);\nextern int pretend_sha1_file(void *, unsigned long, enum object_type, unsigned char *);\nextern int force_object_loose(const unsigned char *sha1, time_t mtime);\nextern int git_open_noatime(const char *name);\nextern void *map_sha1_file(const unsigned char *sha1, unsigned long *size);\nextern int unpack_sha1_header(git_zstream *stream, unsigned char *map, unsigned long mapsize, void *buffer, unsigned long bufsiz);\nextern int parse_sha1_header(const char *hdr, unsigned long *sizep);\n\n/* global flag to enable extra checks when accessing packed objects */\nextern int do_check_packed_object_crc;\n\nextern int check_sha1_signature(const unsigned char *sha1, void *buf, unsigned long size, const char *type);\n\nextern int move_temp_to_file(const char *tmpfile, const char *filename);\n\nextern int has_sha1_pack(const unsigned char *sha1);\n\n/*\n * Return true iff we have an object named sha1, whether local or in\n * an alternate object database, and whether packed or loose.  This\n * function does not respect replace references.\n */\nextern int has_sha1_file(const unsigned char *sha1);\n\n/*\n * Return true iff an alternate object database has a loose object\n * with the specified name.  This function does not respect replace\n * references.\n */\nextern int has_loose_object_nonlocal(const unsigned char *sha1);\n\nextern int has_pack_index(const unsigned char *sha1);\n\nextern void assert_sha1_type(const unsigned char *sha1, enum object_type expect);\n\nextern const signed char hexval_table[256];\nstatic inline unsigned int hexval(unsigned char c)\n{\n\treturn hexval_table[c];\n}\n\n/* Convert to/from hex/sha1 representation */\n#define MINIMUM_ABBREV minimum_abbrev\n#define DEFAULT_ABBREV default_abbrev\n\nstruct object_context {\n\tunsigned char tree[20];\n\tchar path[PATH_MAX];\n\tunsigned mode;\n};\n\n#define GET_SHA1_QUIETLY        01\n#define GET_SHA1_COMMIT         02\n#define GET_SHA1_COMMITTISH     04\n#define GET_SHA1_TREE          010\n#define GET_SHA1_TREEISH       020\n#define GET_SHA1_BLOB\t       040\n#define GET_SHA1_ONLY_TO_DIE 04000\n\nextern int get_sha1(const char *str, unsigned char *sha1);\nextern int get_sha1_commit(const char *str, unsigned char *sha1);\nextern int get_sha1_committish(const char *str, unsigned char *sha1);\nextern int get_sha1_tree(const char *str, unsigned char *sha1);\nextern int get_sha1_treeish(const char *str, unsigned char *sha1);\nextern int get_sha1_blob(const char *str, unsigned char *sha1);\nextern void maybe_die_on_misspelt_object_name(const char *name, const char *prefix);\nextern int get_sha1_with_context(const char *str, unsigned flags, unsigned char *sha1, struct object_context *orc);\n\ntypedef int each_abbrev_fn(const unsigned char *sha1, void *);\nextern int for_each_abbrev(const char *prefix, each_abbrev_fn, void *);\n\n/*\n * Try to read a SHA1 in hexadecimal format from the 40 characters\n * starting at hex.  Write the 20-byte result to sha1 in binary form.\n * Return 0 on success.  Reading stops if a NUL is encountered in the\n * input, so it is safe to pass this function an arbitrary\n * null-terminated string.\n */\nextern int get_sha1_hex(const char *hex, unsigned char *sha1);\n\nextern char *sha1_to_hex(const unsigned char *sha1);\t/* static buffer result! */\nextern int read_ref_full(const char *refname, unsigned char *sha1,\n\t\t\t int reading, int *flags);\nextern int read_ref(const char *refname, unsigned char *sha1);\n\n/*\n * Resolve a reference, recursively following symbolic refererences.\n *\n * Store the referred-to object's name in sha1 and return the name of\n * the non-symbolic reference that ultimately pointed at it.  The\n * return value, if not NULL, is a pointer into either a static buffer\n * or the input ref.\n *\n * If the reference cannot be resolved to an object, the behavior\n * depends on the \"reading\" argument:\n *\n * - If reading is set, return NULL.\n *\n * - If reading is not set, clear sha1 and return the name of the last\n *   reference name in the chain, which will either be a non-symbolic\n *   reference or an undefined reference.  If this is a prelude to\n *   \"writing\" to the ref, the return value is the name of the ref\n *   that will actually be created or changed.\n *\n * If flag is non-NULL, set the value that it points to the\n * combination of REF_ISPACKED (if the reference was found among the\n * packed references) and REF_ISSYMREF (if the initial reference was a\n * symbolic reference).\n *\n * If ref is not a properly-formatted, normalized reference, return\n * NULL.  If more than MAXDEPTH recursive symbolic lookups are needed,\n * give up and return NULL.\n *\n * errno is sometimes set on errors, but not always.\n */\nextern const char *resolve_ref_unsafe(const char *ref, unsigned char *sha1, int reading, int *flag);\nextern char *resolve_refdup(const char *ref, unsigned char *sha1, int reading, int *flag);\n\nextern int dwim_ref(const char *str, int len, unsigned char *sha1, char **ref);\nextern int dwim_log(const char *str, int len, unsigned char *sha1, char **ref);\nextern int interpret_branch_name(const char *str, int len, struct strbuf *);\nextern int get_sha1_mb(const char *str, unsigned char *sha1);\n\n/*\n * Return true iff abbrev_name is a possible abbreviation for\n * full_name according to the rules defined by ref_rev_parse_rules in\n * refs.c.\n */\nextern int refname_match(const char *abbrev_name, const char *full_name);\n\nextern int create_symref(const char *ref, const char *refs_heads_master, const char *logmsg);\nextern int validate_headref(const char *ref);\n\nextern int base_name_compare(const char *name1, int len1, int mode1, const char *name2, int len2, int mode2);\nextern int df_name_compare(const char *name1, int len1, int mode1, const char *name2, int len2, int mode2);\nextern int cache_name_compare(const char *name1, int len1, const char *name2, int len2);\nextern int cache_name_stage_compare(const char *name1, int len1, int stage1, const char *name2, int len2, int stage2);\n\nextern void *read_object_with_reference(const unsigned char *sha1,\n\t\t\t\t\tconst char *required_type,\n\t\t\t\t\tunsigned long *size,\n\t\t\t\t\tunsigned char *sha1_ret);\n\nextern struct object *peel_to_type(const char *name, int namelen,\n\t\t\t\t   struct object *o, enum object_type);\n\nenum date_mode {\n\tDATE_NORMAL = 0,\n\tDATE_RELATIVE,\n\tDATE_SHORT,\n\tDATE_LOCAL,\n\tDATE_ISO8601,\n\tDATE_RFC2822,\n\tDATE_RAW\n};\n\nconst char *show_date(unsigned long time, int timezone, enum date_mode mode);\nvoid show_date_relative(unsigned long time, int tz, const struct timeval *now,\n\t\t\tstruct strbuf *timebuf);\nint parse_date(const char *date, char *buf, int bufsize);\nint parse_date_basic(const char *date, unsigned long *timestamp, int *offset);\nint parse_expiry_date(const char *date, unsigned long *timestamp);\nvoid datestamp(char *buf, int bufsize);\n#define approxidate(s) approxidate_careful((s), NULL)\nunsigned long approxidate_careful(const char *, int *);\nunsigned long approxidate_relative(const char *date, const struct timeval *now);\nenum date_mode parse_date_format(const char *format);\nint date_overflows(unsigned long date);\n\n#define IDENT_STRICT\t       1\n#define IDENT_NO_DATE\t       2\n#define IDENT_NO_NAME\t       4\nextern const char *git_author_info(int);\nextern const char *git_committer_info(int);\nextern const char *fmt_ident(const char *name, const char *email, const char *date_str, int);\nextern const char *fmt_name(const char *name, const char *email);\nextern const char *ident_default_email(void);\nextern const char *git_editor(void);\nextern const char *git_pager(int stdout_is_tty);\nextern int git_ident_config(const char *, const char *, void *);\n\nstruct ident_split {\n\tconst char *name_begin;\n\tconst char *name_end;\n\tconst char *mail_begin;\n\tconst char *mail_end;\n\tconst char *date_begin;\n\tconst char *date_end;\n\tconst char *tz_begin;\n\tconst char *tz_end;\n};\n/*\n * Signals an success with 0, but time part of the result may be NULL\n * if the input lacks timestamp and zone\n */\nextern int split_ident_line(struct ident_split *, const char *, int);\n\n/*\n * Compare split idents for equality or strict ordering. Note that we\n * compare only the ident part of the line, ignoring any timestamp.\n *\n * Because there are two fields, we must choose one as the primary key; we\n * currently arbitrarily pick the email.\n */\nextern int ident_cmp(const struct ident_split *, const struct ident_split *);\n\nstruct checkout {\n\tconst char *base_dir;\n\tint base_dir_len;\n\tunsigned force:1,\n\t\t quiet:1,\n\t\t not_new:1,\n\t\t refresh_cache:1;\n};\n\n#define TEMPORARY_FILENAME_LENGTH 25\nextern int checkout_entry(struct cache_entry *ce, const struct checkout *state, char *topath);\n\nstruct cache_def {\n\tchar path[PATH_MAX + 1];\n\tint len;\n\tint flags;\n\tint track_flags;\n\tint prefix_len_stat_func;\n};\n\nextern int has_symlink_leading_path(const char *name, int len);\nextern int threaded_has_symlink_leading_path(struct cache_def *, const char *, int);\nextern int check_leading_path(const char *name, int len);\nextern int has_dirs_only_path(const char *name, int len, int prefix_len);\nextern void schedule_dir_for_removal(const char *name, int len);\nextern void remove_scheduled_dirs(void);\n\nextern struct alternate_object_database {\n\tstruct alternate_object_database *next;\n\tchar *name;\n\tchar base[FLEX_ARRAY]; /* more */\n} *alt_odb_list;\nextern void prepare_alt_odb(void);\nextern void read_info_alternates(const char * relative_base, int depth);\nextern void add_to_alternates_file(const char *reference);\ntypedef int alt_odb_fn(struct alternate_object_database *, void *);\nextern void foreach_alt_odb(alt_odb_fn, void*);\n\nstruct pack_window {\n\tstruct pack_window *next;\n\tunsigned char *base;\n\toff_t offset;\n\tsize_t len;\n\tunsigned int last_used;\n\tunsigned int inuse_cnt;\n};\n\nextern struct packed_git {\n\tstruct packed_git *next;\n\tstruct pack_window *windows;\n\toff_t pack_size;\n\tconst void *index_data;\n\tsize_t index_size;\n\tuint32_t num_objects;\n\tuint32_t num_bad_objects;\n\tunsigned char *bad_object_sha1;\n\tint index_version;\n\ttime_t mtime;\n\tint pack_fd;\n\tunsigned pack_local:1,\n\t\t pack_keep:1,\n\t\t do_not_close:1;\n\tunsigned char sha1[20];\n\t/* something like \".git/objects/pack/xxxxx.pack\" */\n\tchar pack_name[FLEX_ARRAY]; /* more */\n} *packed_git;\n\nstruct pack_entry {\n\toff_t offset;\n\tunsigned char sha1[20];\n\tstruct packed_git *p;\n};\n\nextern struct packed_git *parse_pack_index(unsigned char *sha1, const char *idx_path);\n\n/* A hook for count-objects to report invalid files in pack directory */\nextern void (*report_garbage)(const char *desc, const char *path);\n\nextern void prepare_packed_git(void);\nextern void reprepare_packed_git(void);\nextern void install_packed_git(struct packed_git *pack);\n\nextern struct packed_git *find_sha1_pack(const unsigned char *sha1,\n\t\t\t\t\t struct packed_git *packs);\n\nextern void pack_report(void);\n\n/*\n * mmap the index file for the specified packfile (if it is not\n * already mmapped).  Return 0 on success.\n */\nextern int open_pack_index(struct packed_git *);\n\n/*\n * munmap the index file for the specified packfile (if it is\n * currently mmapped).\n */\nextern void close_pack_index(struct packed_git *);\n\nextern unsigned char *use_pack(struct packed_git *, struct pack_window **, off_t, unsigned long *);\nextern void close_pack_windows(struct packed_git *);\nextern void unuse_pack(struct pack_window **);\nextern void free_pack_by_name(const char *);\nextern void clear_delta_base_cache(void);\nextern struct packed_git *add_packed_git(const char *, int, int);\n\n/*\n * Return the SHA-1 of the nth object within the specified packfile.\n * Open the index if it is not already open.  The return value points\n * at the SHA-1 within the mmapped index.  Return NULL if there is an\n * error.\n */\nextern const unsigned char *nth_packed_object_sha1(struct packed_git *, uint32_t n);\n\n/*\n * Return the offset of the nth object within the specified packfile.\n * The index must already be opened.\n */\nextern off_t nth_packed_object_offset(const struct packed_git *, uint32_t n);\n\n/*\n * If the object named sha1 is present in the specified packfile,\n * return its offset within the packfile; otherwise, return 0.\n */\nextern off_t find_pack_entry_one(const unsigned char *sha1, struct packed_git *);\n\nextern int is_pack_valid(struct packed_git *);\nextern void *unpack_entry(struct packed_git *, off_t, enum object_type *, unsigned long *);\nextern unsigned long unpack_object_header_buffer(const unsigned char *buf, unsigned long len, enum object_type *type, unsigned long *sizep);\nextern unsigned long get_size_from_delta(struct packed_git *, struct pack_window **, off_t);\nextern int unpack_object_header(struct packed_git *, struct pack_window **, off_t *, unsigned long *);\n\nstruct object_info {\n\t/* Request */\n\tenum object_type *typep;\n\tunsigned long *sizep;\n\tunsigned long *disk_sizep;\n\tunsigned char *delta_base_sha1;\n\n\t/* Response */\n\tenum {\n\t\tOI_CACHED,\n\t\tOI_LOOSE,\n\t\tOI_PACKED,\n\t\tOI_DBCACHED\n\t} whence;\n\tunion {\n\t\t/*\n\t\t * struct {\n\t\t * \t... Nothing to expose in this case\n\t\t * } cached;\n\t\t * struct {\n\t\t * \t... Nothing to expose in this case\n\t\t * } loose;\n\t\t */\n\t\tstruct {\n\t\t\tstruct packed_git *pack;\n\t\t\toff_t offset;\n\t\t\tunsigned int is_delta;\n\t\t} packed;\n\t} u;\n};\nextern int sha1_object_info_extended(const unsigned char *, struct object_info *, unsigned flags);\n\n/* Dumb servers support */\nextern int update_server_info(int);\n\n/* git_config_parse_key() returns these negated: */\n#define CONFIG_INVALID_KEY 1\n#define CONFIG_NO_SECTION_OR_NAME 2\n/* git_config_set(), git_config_set_multivar() return the above or these: */\n#define CONFIG_NO_LOCK -1\n#define CONFIG_INVALID_FILE 3\n#define CONFIG_NO_WRITE 4\n#define CONFIG_NOTHING_SET 5\n#define CONFIG_INVALID_PATTERN 6\n#define CONFIG_GENERIC_ERROR 7\n\nstruct git_config_source {\n\tunsigned int use_stdin:1;\n\tconst char *file;\n\tconst char *blob;\n};\n\ntypedef int (*config_fn_t)(const char *, const char *, void *);\nextern int git_default_config(const char *, const char *, void *);\nextern int git_config_from_file(config_fn_t fn, const char *, void *);\nextern int git_config_from_buf(config_fn_t fn, const char *name,\n\t\t\t       const char *buf, size_t len, void *data);\nextern void git_config_push_parameter(const char *text);\nextern int git_config_from_parameters(config_fn_t fn, void *data);\nextern int git_config(config_fn_t fn, void *);\nextern int git_config_with_options(config_fn_t fn, void *,\n\t\t\t\t   struct git_config_source *config_source,\n\t\t\t\t   int respect_includes);\nextern int git_config_early(config_fn_t fn, void *, const char *repo_config);\nextern int git_parse_ulong(const char *, unsigned long *);\nextern int git_config_int(const char *, const char *);\nextern int64_t git_config_int64(const char *, const char *);\nextern unsigned long git_config_ulong(const char *, const char *);\nextern int git_config_bool_or_int(const char *, const char *, int *);\nextern int git_config_bool(const char *, const char *);\nextern int git_config_maybe_bool(const char *, const char *);\nextern int git_config_string(const char **, const char *, const char *);\nextern int git_config_pathname(const char **, const char *, const char *);\nextern int git_config_set_in_file(const char *, const char *, const char *);\nextern int git_config_set(const char *, const char *);\nextern int git_config_parse_key(const char *, char **, int *);\nextern int git_config_set_multivar(const char *, const char *, const char *, int);\nextern int git_config_set_multivar_in_file(const char *, const char *, const char *, const char *, int);\nextern int git_config_rename_section(const char *, const char *);\nextern int git_config_rename_section_in_file(const char *, const char *, const char *);\nextern const char *git_etc_gitconfig(void);\nextern int check_repository_format_version(const char *var, const char *value, void *cb);\nextern int git_env_bool(const char *, int);\nextern int git_config_system(void);\nextern int config_error_nonbool(const char *);\n#if defined(__GNUC__) && ! defined(__clang__)\n#define config_error_nonbool(s) (config_error_nonbool(s), -1)\n#endif\nextern const char *get_log_output_encoding(void);\nextern const char *get_commit_output_encoding(void);\n\nextern int git_config_parse_parameter(const char *, config_fn_t fn, void *data);\n\nstruct config_include_data {\n\tint depth;\n\tconfig_fn_t fn;\n\tvoid *data;\n};\n#define CONFIG_INCLUDE_INIT { 0 }\nextern int git_config_include(const char *name, const char *value, void *data);\n\n/*\n * Match and parse a config key of the form:\n *\n *   section.(subsection.)?key\n *\n * (i.e., what gets handed to a config_fn_t). The caller provides the section;\n * we return -1 if it does not match, 0 otherwise. The subsection and key\n * out-parameters are filled by the function (and subsection is NULL if it is\n * missing).\n */\nextern int parse_config_key(const char *var,\n\t\t\t    const char *section,\n\t\t\t    const char **subsection, int *subsection_len,\n\t\t\t    const char **key);\n\nextern int committer_ident_sufficiently_given(void);\nextern int author_ident_sufficiently_given(void);\n\nextern const char *git_commit_encoding;\nextern const char *git_log_output_encoding;\nextern const char *git_mailmap_file;\nextern const char *git_mailmap_blob;\n\n/* IO helper functions */\nextern void maybe_flush_or_die(FILE *, const char *);\nextern int copy_fd(int ifd, int ofd);\nextern int copy_file(const char *dst, const char *src, int mode);\nextern int copy_file_with_time(const char *dst, const char *src, int mode);\nextern void write_or_die(int fd, const void *buf, size_t count);\nextern int write_or_whine(int fd, const void *buf, size_t count, const char *msg);\nextern int write_or_whine_pipe(int fd, const void *buf, size_t count, const char *msg);\nextern void fsync_or_die(int fd, const char *);\n\nextern ssize_t read_in_full(int fd, void *buf, size_t count);\nextern ssize_t write_in_full(int fd, const void *buf, size_t count);\nstatic inline ssize_t write_str_in_full(int fd, const char *str)\n{\n\treturn write_in_full(fd, str, strlen(str));\n}\n\n/* pager.c */\nextern void setup_pager(void);\nextern const char *pager_program;\nextern int pager_in_use(void);\nextern int pager_use_color;\nextern int term_columns(void);\nextern int decimal_width(int);\nextern int check_pager_config(const char *cmd);\n\nextern const char *editor_program;\nextern const char *askpass_program;\nextern const char *excludes_file;\n\n/* base85 */\nint decode_85(char *dst, const char *line, int linelen);\nvoid encode_85(char *buf, const unsigned char *data, int bytes);\n\n/* alloc.c */\nextern void *alloc_blob_node(void);\nextern void *alloc_tree_node(void);\nextern void *alloc_commit_node(void);\nextern void *alloc_tag_node(void);\nextern void *alloc_object_node(void);\nextern void alloc_report(void);\n\n/* trace.c */\n__attribute__((format (printf, 1, 2)))\nextern void trace_printf(const char *format, ...);\n__attribute__((format (printf, 2, 3)))\nextern void trace_argv_printf(const char **argv, const char *format, ...);\nextern void trace_repo_setup(const char *prefix);\nextern int trace_want(const char *key);\n__attribute__((format (printf, 2, 3)))\nextern void trace_printf_key(const char *key, const char *fmt, ...);\nextern void trace_strbuf(const char *key, const struct strbuf *buf);\n\nvoid packet_trace_identity(const char *prog);\n\n/* add */\n/*\n * return 0 if success, 1 - if addition of a file failed and\n * ADD_FILES_IGNORE_ERRORS was specified in flags\n */\nint add_files_to_cache(const char *prefix, const struct pathspec *pathspec, int flags);\n\n/* diff.c */\nextern int diff_auto_refresh_index;\n\n/* match-trees.c */\nvoid shift_tree(const unsigned char *, const unsigned char *, unsigned char *, int);\nvoid shift_tree_by(const unsigned char *, const unsigned char *, unsigned char *, const char *);\n\n/*\n * whitespace rules.\n * used by both diff and apply\n * last two digits are tab width\n */\n#define WS_BLANK_AT_EOL         0100\n#define WS_SPACE_BEFORE_TAB     0200\n#define WS_INDENT_WITH_NON_TAB  0400\n#define WS_CR_AT_EOL           01000\n#define WS_BLANK_AT_EOF        02000\n#define WS_TAB_IN_INDENT       04000\n#define WS_TRAILING_SPACE      (WS_BLANK_AT_EOL|WS_BLANK_AT_EOF)\n#define WS_DEFAULT_RULE (WS_TRAILING_SPACE|WS_SPACE_BEFORE_TAB|8)\n#define WS_TAB_WIDTH_MASK        077\nextern unsigned whitespace_rule_cfg;\nextern unsigned whitespace_rule(const char *);\nextern unsigned parse_whitespace_rule(const char *);\nextern unsigned ws_check(const char *line, int len, unsigned ws_rule);\nextern void ws_check_emit(const char *line, int len, unsigned ws_rule, FILE *stream, const char *set, const char *reset, const char *ws);\nextern char *whitespace_error_string(unsigned ws);\nextern void ws_fix_copy(struct strbuf *, const char *, int, unsigned, int *);\nextern int ws_blank_line(const char *line, int len, unsigned ws_rule);\n#define ws_tab_width(rule)     ((rule) & WS_TAB_WIDTH_MASK)\n\n/* ls-files */\nint report_path_error(const char *ps_matched, const struct pathspec *pathspec, const char *prefix);\nvoid overlay_tree_on_cache(const char *tree_name, const char *prefix);\n\nchar *alias_lookup(const char *alias);\nint split_cmdline(char *cmdline, const char ***argv);\n/* Takes a negative value returned by split_cmdline */\nconst char *split_cmdline_strerror(int cmdline_errno);\n\n/* git.c */\nstruct startup_info {\n\tint have_repository;\n\tconst char *prefix;\n};\nextern struct startup_info *startup_info;\n\n/* merge.c */\nstruct commit_list;\nint try_merge_command(const char *strategy, size_t xopts_nr,\n\t\tconst char **xopts, struct commit_list *common,\n\t\tconst char *head_arg, struct commit_list *remotes);\nint checkout_fast_forward(const unsigned char *from,\n\t\t\t  const unsigned char *to,\n\t\t\t  int overwrite_ignore);\n\n\nint sane_execvp(const char *file, char *const argv[]);\n\n/*\n * A struct to encapsulate the concept of whether a file has changed\n * since we last checked it. This uses criteria similar to those used\n * for the index.\n */\nstruct stat_validity {\n\tstruct stat_data *sd;\n};\n\nvoid stat_validity_clear(struct stat_validity *sv);\n\n/*\n * Returns 1 if the path is a regular file (or a symlink to a regular\n * file) and matches the saved stat_validity, 0 otherwise.  A missing\n * or inaccessible file is considered a match if the struct was just\n * initialized, or if the previous update found an inaccessible file.\n */\nint stat_validity_check(struct stat_validity *sv, const char *path);\n\n/*\n * Update the stat_validity from a file opened at descriptor fd. If\n * the file is missing, inaccessible, or not a regular file, then\n * future calls to stat_validity_check will match iff one of those\n * conditions continues to be true.\n */\nvoid stat_validity_update(struct stat_validity *sv, int fd);\n\n#endif /* CACHE_H */\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00ba6bf08eaf0b6f3dbbea709922a6cfce49c86d",
  "sha1_ok": true,
  "size": 51731
}
