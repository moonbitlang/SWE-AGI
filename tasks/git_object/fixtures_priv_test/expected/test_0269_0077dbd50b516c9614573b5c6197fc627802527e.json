{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAidHJlZS5oIgojaW5jbHVkZSAiYmxvYi5oIgojaW5jbHVkZSAidHJlZS13YWxrLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJyZW1vdGUuaCIKCnN0YXRpYyBpbnQgZ2V0X3NoYTFfb25lbGluZShjb25zdCBjaGFyICosIHVuc2lnbmVkIGNoYXIgKiwgc3RydWN0IGNvbW1pdF9saXN0ICopOwoKdHlwZWRlZiBpbnQgKCpkaXNhbWJpZ3VhdGVfaGludF9mbikoY29uc3QgdW5zaWduZWQgY2hhciAqLCB2b2lkICopOwoKc3RydWN0IGRpc2FtYmlndWF0ZV9zdGF0ZSB7CglkaXNhbWJpZ3VhdGVfaGludF9mbiBmbjsKCXZvaWQgKmNiX2RhdGE7Cgl1bnNpZ25lZCBjaGFyIGNhbmRpZGF0ZVsyMF07Cgl1bnNpZ25lZCBjYW5kaWRhdGVfZXhpc3RzOjE7Cgl1bnNpZ25lZCBjYW5kaWRhdGVfY2hlY2tlZDoxOwoJdW5zaWduZWQgY2FuZGlkYXRlX29rOjE7Cgl1bnNpZ25lZCBkaXNhbWJpZ3VhdGVfZm5fdXNlZDoxOwoJdW5zaWduZWQgYW1iaWd1b3VzOjE7Cgl1bnNpZ25lZCBhbHdheXNfY2FsbF9mbjoxOwp9OwoKc3RhdGljIHZvaWQgdXBkYXRlX2NhbmRpZGF0ZXMoc3RydWN0IGRpc2FtYmlndWF0ZV9zdGF0ZSAqZHMsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKmN1cnJlbnQpCnsKCWlmIChkcy0+YWx3YXlzX2NhbGxfZm4pIHsKCQlkcy0+YW1iaWd1b3VzID0gZHMtPmZuKGN1cnJlbnQsIGRzLT5jYl9kYXRhKSA/IDEgOiAwOwoJCXJldHVybjsKCX0KCWlmICghZHMtPmNhbmRpZGF0ZV9leGlzdHMpIHsKCQkvKiB0aGlzIGlzIHRoZSBmaXJzdCBjYW5kaWRhdGUgKi8KCQloYXNoY3B5KGRzLT5jYW5kaWRhdGUsIGN1cnJlbnQpOwoJCWRzLT5jYW5kaWRhdGVfZXhpc3RzID0gMTsKCQlyZXR1cm47Cgl9IGVsc2UgaWYgKCFoYXNoY21wKGRzLT5jYW5kaWRhdGUsIGN1cnJlbnQpKSB7CgkJLyogdGhlIHNhbWUgYXMgd2hhdCB3ZSBhbHJlYWR5IGhhdmUgc2VlbiAqLwoJCXJldHVybjsKCX0KCglpZiAoIWRzLT5mbikgewoJCS8qIGNhbm5vdCBkaXNhbWJpZ3VhdGUgYmV0d2VlbiBkcy0+Y2FuZGlkYXRlIGFuZCBjdXJyZW50ICovCgkJZHMtPmFtYmlndW91cyA9IDE7CgkJcmV0dXJuOwoJfQoKCWlmICghZHMtPmNhbmRpZGF0ZV9jaGVja2VkKSB7CgkJZHMtPmNhbmRpZGF0ZV9vayA9IGRzLT5mbihkcy0+Y2FuZGlkYXRlLCBkcy0+Y2JfZGF0YSk7CgkJZHMtPmRpc2FtYmlndWF0ZV9mbl91c2VkID0gMTsKCQlkcy0+Y2FuZGlkYXRlX2NoZWNrZWQgPSAxOwoJfQoKCWlmICghZHMtPmNhbmRpZGF0ZV9vaykgewoJCS8qIGRpc2NhcmQgdGhlIGNhbmRpZGF0ZTsgd2Uga25vdyBpdCBkb2VzIG5vdCBzYXRpc2lmeSBmbiAqLwoJCWhhc2hjcHkoZHMtPmNhbmRpZGF0ZSwgY3VycmVudCk7CgkJZHMtPmNhbmRpZGF0ZV9jaGVja2VkID0gMDsKCQlyZXR1cm47Cgl9CgoJLyogaWYgd2UgcmVhY2ggdGhpcyBwb2ludCwgd2Uga25vdyBkcy0+Y2FuZGlkYXRlIHNhdGlzZmllcyBmbiAqLwoJaWYgKGRzLT5mbihjdXJyZW50LCBkcy0+Y2JfZGF0YSkpIHsKCQkvKgoJCSAqIGlmIGJvdGggY3VycmVudCBhbmQgY2FuZGlkYXRlIHNhdGlzZnkgZm4sIHdlIGNhbm5vdAoJCSAqIGRpc2FtYmlndWF0ZS4KCQkgKi8KCQlkcy0+Y2FuZGlkYXRlX29rID0gMDsKCQlkcy0+YW1iaWd1b3VzID0gMTsKCX0KCgkvKiBvdGhlcndpc2UsIGN1cnJlbnQgY2FuIGJlIGRpc2NhcmRlZCBhbmQgY2FuZGlkYXRlIGlzIHN0aWxsIGdvb2QgKi8KfQoKc3RhdGljIHZvaWQgZmluZF9zaG9ydF9vYmplY3RfZmlsZW5hbWUoaW50IGxlbiwgY29uc3QgY2hhciAqaGV4X3BmeCwgc3RydWN0IGRpc2FtYmlndWF0ZV9zdGF0ZSAqZHMpCnsKCXN0cnVjdCBhbHRlcm5hdGVfb2JqZWN0X2RhdGFiYXNlICphbHQ7CgljaGFyIGhleFs0MF07CglzdGF0aWMgc3RydWN0IGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UgKmZha2VlbnQ7CgoJaWYgKCFmYWtlZW50KSB7CgkJLyoKCQkgKiBDcmVhdGUgYSAiZmFrZSIgYWx0ZXJuYXRlIG9iamVjdCBkYXRhYmFzZSB0aGF0CgkJICogcG9pbnRzIHRvIG91ciBvd24gb2JqZWN0IGRhdGFiYXNlLCB0byBtYWtlIGl0CgkJICogZWFzaWVyIHRvIGdldCBhIHRlbXBvcmFyeSB3b3JraW5nIHNwYWNlIGluCgkJICogYWx0LT5uYW1lL2FsdC0+YmFzZSB3aGlsZSBpdGVyYXRpbmcgb3ZlciB0aGUKCQkgKiBvYmplY3QgZGF0YWJhc2VzIGluY2x1ZGluZyBvdXIgb3duLgoJCSAqLwoJCWNvbnN0IGNoYXIgKm9iamRpciA9IGdldF9vYmplY3RfZGlyZWN0b3J5KCk7CgkJaW50IG9iamRpcl9sZW4gPSBzdHJsZW4ob2JqZGlyKTsKCQlpbnQgZW50bGVuID0gb2JqZGlyX2xlbiArIDQzOwoJCWZha2VlbnQgPSB4bWFsbG9jKHNpemVvZigqZmFrZWVudCkgKyBlbnRsZW4pOwoJCW1lbWNweShmYWtlZW50LT5iYXNlLCBvYmpkaXIsIG9iamRpcl9sZW4pOwoJCWZha2VlbnQtPm5hbWUgPSBmYWtlZW50LT5iYXNlICsgb2JqZGlyX2xlbiArIDE7CgkJZmFrZWVudC0+bmFtZVstMV0gPSAnLyc7Cgl9CglmYWtlZW50LT5uZXh0ID0gYWx0X29kYl9saXN0OwoKCXNwcmludGYoaGV4LCAiJS4ycyIsIGhleF9wZngpOwoJZm9yIChhbHQgPSBmYWtlZW50OyBhbHQgJiYgIWRzLT5hbWJpZ3VvdXM7IGFsdCA9IGFsdC0+bmV4dCkgewoJCXN0cnVjdCBkaXJlbnQgKmRlOwoJCURJUiAqZGlyOwoJCXNwcmludGYoYWx0LT5uYW1lLCAiJS4ycy8iLCBoZXhfcGZ4KTsKCQlkaXIgPSBvcGVuZGlyKGFsdC0+YmFzZSk7CgkJaWYgKCFkaXIpCgkJCWNvbnRpbnVlOwoKCQl3aGlsZSAoIWRzLT5hbWJpZ3VvdXMgJiYgKGRlID0gcmVhZGRpcihkaXIpKSAhPSBOVUxMKSB7CgkJCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgoJCQlpZiAoc3RybGVuKGRlLT5kX25hbWUpICE9IDM4KQoJCQkJY29udGludWU7CgkJCWlmIChtZW1jbXAoZGUtPmRfbmFtZSwgaGV4X3BmeCArIDIsIGxlbiAtIDIpKQoJCQkJY29udGludWU7CgkJCW1lbWNweShoZXggKyAyLCBkZS0+ZF9uYW1lLCAzOCk7CgkJCWlmICghZ2V0X3NoYTFfaGV4KGhleCwgc2hhMSkpCgkJCQl1cGRhdGVfY2FuZGlkYXRlcyhkcywgc2hhMSk7CgkJfQoJCWNsb3NlZGlyKGRpcik7Cgl9Cn0KCnN0YXRpYyBpbnQgbWF0Y2hfc2hhKHVuc2lnbmVkIGxlbiwgY29uc3QgdW5zaWduZWQgY2hhciAqYSwgY29uc3QgdW5zaWduZWQgY2hhciAqYikKewoJZG8gewoJCWlmICgqYSAhPSAqYikKCQkJcmV0dXJuIDA7CgkJYSsrOwoJCWIrKzsKCQlsZW4gLT0gMjsKCX0gd2hpbGUgKGxlbiA+IDEpOwoJaWYgKGxlbikKCQlpZiAoKCphIF4gKmIpICYgMHhmMCkKCQkJcmV0dXJuIDA7CglyZXR1cm4gMTsKfQoKc3RhdGljIHZvaWQgdW5pcXVlX2luX3BhY2soaW50IGxlbiwKCQkJICBjb25zdCB1bnNpZ25lZCBjaGFyICpiaW5fcGZ4LAoJCQkgICBzdHJ1Y3QgcGFja2VkX2dpdCAqcCwKCQkJICAgc3RydWN0IGRpc2FtYmlndWF0ZV9zdGF0ZSAqZHMpCnsKCXVpbnQzMl90IG51bSwgbGFzdCwgaSwgZmlyc3QgPSAwOwoJY29uc3QgdW5zaWduZWQgY2hhciAqY3VycmVudCA9IE5VTEw7CgoJb3Blbl9wYWNrX2luZGV4KHApOwoJbnVtID0gcC0+bnVtX29iamVjdHM7CglsYXN0ID0gbnVtOwoJd2hpbGUgKGZpcnN0IDwgbGFzdCkgewoJCXVpbnQzMl90IG1pZCA9IChmaXJzdCArIGxhc3QpIC8gMjsKCQljb25zdCB1bnNpZ25lZCBjaGFyICpjdXJyZW50OwoJCWludCBjbXA7CgoJCWN1cnJlbnQgPSBudGhfcGFja2VkX29iamVjdF9zaGExKHAsIG1pZCk7CgkJY21wID0gaGFzaGNtcChiaW5fcGZ4LCBjdXJyZW50KTsKCQlpZiAoIWNtcCkgewoJCQlmaXJzdCA9IG1pZDsKCQkJYnJlYWs7CgkJfQoJCWlmIChjbXAgPiAwKSB7CgkJCWZpcnN0ID0gbWlkKzE7CgkJCWNvbnRpbnVlOwoJCX0KCQlsYXN0ID0gbWlkOwoJfQoKCS8qCgkgKiBBdCB0aGlzIHBvaW50LCAiZmlyc3QiIGlzIHRoZSBsb2NhdGlvbiBvZiB0aGUgbG93ZXN0IG9iamVjdAoJICogd2l0aCBhbiBvYmplY3QgbmFtZSB0aGF0IGNvdWxkIG1hdGNoICJiaW5fcGZ4Ii4gIFNlZSBpZiB3ZSBoYXZlCgkgKiAwLCAxIG9yIG1vcmUgb2JqZWN0cyB0aGF0IGFjdHVhbGx5IG1hdGNoKGVzKS4KCSAqLwoJZm9yIChpID0gZmlyc3Q7IGkgPCBudW0gJiYgIWRzLT5hbWJpZ3VvdXM7IGkrKykgewoJCWN1cnJlbnQgPSBudGhfcGFja2VkX29iamVjdF9zaGExKHAsIGkpOwoJCWlmICghbWF0Y2hfc2hhKGxlbiwgYmluX3BmeCwgY3VycmVudCkpCgkJCWJyZWFrOwoJCXVwZGF0ZV9jYW5kaWRhdGVzKGRzLCBjdXJyZW50KTsKCX0KfQoKc3RhdGljIHZvaWQgZmluZF9zaG9ydF9wYWNrZWRfb2JqZWN0KGludCBsZW4sIGNvbnN0IHVuc2lnbmVkIGNoYXIgKmJpbl9wZngsCgkJCQkgICAgIHN0cnVjdCBkaXNhbWJpZ3VhdGVfc3RhdGUgKmRzKQp7CglzdHJ1Y3QgcGFja2VkX2dpdCAqcDsKCglwcmVwYXJlX3BhY2tlZF9naXQoKTsKCWZvciAocCA9IHBhY2tlZF9naXQ7IHAgJiYgIWRzLT5hbWJpZ3VvdXM7IHAgPSBwLT5uZXh0KQoJCXVuaXF1ZV9pbl9wYWNrKGxlbiwgYmluX3BmeCwgcCwgZHMpOwp9CgojZGVmaW5lIFNIT1JUX05BTUVfTk9UX0ZPVU5EICgtMSkKI2RlZmluZSBTSE9SVF9OQU1FX0FNQklHVU9VUyAoLTIpCgpzdGF0aWMgaW50IGZpbmlzaF9vYmplY3RfZGlzYW1iaWd1YXRpb24oc3RydWN0IGRpc2FtYmlndWF0ZV9zdGF0ZSAqZHMsCgkJCQkJdW5zaWduZWQgY2hhciAqc2hhMSkKewoJaWYgKGRzLT5hbWJpZ3VvdXMpCgkJcmV0dXJuIFNIT1JUX05BTUVfQU1CSUdVT1VTOwoKCWlmICghZHMtPmNhbmRpZGF0ZV9leGlzdHMpCgkJcmV0dXJuIFNIT1JUX05BTUVfTk9UX0ZPVU5EOwoKCWlmICghZHMtPmNhbmRpZGF0ZV9jaGVja2VkKQoJCS8qCgkJICogSWYgdGhpcyBpcyB0aGUgb25seSBjYW5kaWRhdGUsIHRoZXJlIGlzIG5vIHBvaW50CgkJICogY2FsbGluZyB0aGUgZGlzYW1iaWd1YXRpb24gaGludCBjYWxsYmFjay4KCQkgKgoJCSAqIE9uIHRoZSBvdGhlciBoYW5kLCBpZiB0aGUgY3VycmVudCBjYW5kaWRhdGUKCQkgKiByZXBsYWNlZCBhbiBlYXJsaWVyIGNhbmRpZGF0ZSB0aGF0IGRpZCBfbm90XyBwYXNzCgkJICogdGhlIGRpc2FtYmlndWF0aW9uIGhpbnQgY2FsbGJhY2ssIHRoZW4gd2UgZG8gaGF2ZQoJCSAqIG1vcmUgdGhhbiBvbmUgb2JqZWN0cyB0aGF0IG1hdGNoIHRoZSBzaG9ydCBuYW1lCgkJICogZ2l2ZW4sIHNvIHdlIHNob3VsZCBtYWtlIHN1cmUgdGhpcyBvbmUgbWF0Y2hlczsKCQkgKiBvdGhlcndpc2UsIGlmIHdlIGRpc2NvdmVyZWQgdGhpcyBvbmUgYW5kIHRoZSBvbmUKCQkgKiB0aGF0IHdlIHByZXZpb3VzbHkgZGlzY2FyZGVkIGluIHRoZSByZXZlcnNlIG9yZGVyLAoJCSAqIHdlIHdvdWxkIGVuZCB1cCBzaG93aW5nIGRpZmZlcmVudCByZXN1bHRzIGluIHRoZQoJCSAqIHNhbWUgcmVwb3NpdG9yeSEKCQkgKi8KCQlkcy0+Y2FuZGlkYXRlX29rID0gKCFkcy0+ZGlzYW1iaWd1YXRlX2ZuX3VzZWQgfHwKCQkJCSAgICBkcy0+Zm4oZHMtPmNhbmRpZGF0ZSwgZHMtPmNiX2RhdGEpKTsKCglpZiAoIWRzLT5jYW5kaWRhdGVfb2spCgkJcmV0dXJuIFNIT1JUX05BTUVfQU1CSUdVT1VTOwoKCWhhc2hjcHkoc2hhMSwgZHMtPmNhbmRpZGF0ZSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBkaXNhbWJpZ3VhdGVfY29tbWl0X29ubHkoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgdm9pZCAqY2JfZGF0YV91bnVzZWQpCnsKCWludCBraW5kID0gc2hhMV9vYmplY3RfaW5mbyhzaGExLCBOVUxMKTsKCXJldHVybiBraW5kID09IE9CSl9DT01NSVQ7Cn0KCnN0YXRpYyBpbnQgZGlzYW1iaWd1YXRlX2NvbW1pdHRpc2hfb25seShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCB2b2lkICpjYl9kYXRhX3VudXNlZCkKewoJc3RydWN0IG9iamVjdCAqb2JqOwoJaW50IGtpbmQ7CgoJa2luZCA9IHNoYTFfb2JqZWN0X2luZm8oc2hhMSwgTlVMTCk7CglpZiAoa2luZCA9PSBPQkpfQ09NTUlUKQoJCXJldHVybiAxOwoJaWYgKGtpbmQgIT0gT0JKX1RBRykKCQlyZXR1cm4gMDsKCgkvKiBXZSBuZWVkIHRvIGRvIHRoaXMgdGhlIGhhcmQgd2F5Li4uICovCglvYmogPSBkZXJlZl90YWcocGFyc2Vfb2JqZWN0KHNoYTEpLCBOVUxMLCAwKTsKCWlmIChvYmogJiYgb2JqLT50eXBlID09IE9CSl9DT01NSVQpCgkJcmV0dXJuIDE7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBkaXNhbWJpZ3VhdGVfdHJlZV9vbmx5KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIHZvaWQgKmNiX2RhdGFfdW51c2VkKQp7CglpbnQga2luZCA9IHNoYTFfb2JqZWN0X2luZm8oc2hhMSwgTlVMTCk7CglyZXR1cm4ga2luZCA9PSBPQkpfVFJFRTsKfQoKc3RhdGljIGludCBkaXNhbWJpZ3VhdGVfdHJlZWlzaF9vbmx5KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIHZvaWQgKmNiX2RhdGFfdW51c2VkKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmo7CglpbnQga2luZDsKCglraW5kID0gc2hhMV9vYmplY3RfaW5mbyhzaGExLCBOVUxMKTsKCWlmIChraW5kID09IE9CSl9UUkVFIHx8IGtpbmQgPT0gT0JKX0NPTU1JVCkKCQlyZXR1cm4gMTsKCWlmIChraW5kICE9IE9CSl9UQUcpCgkJcmV0dXJuIDA7CgoJLyogV2UgbmVlZCB0byBkbyB0aGlzIHRoZSBoYXJkIHdheS4uLiAqLwoJb2JqID0gZGVyZWZfdGFnKGxvb2t1cF9vYmplY3Qoc2hhMSksIE5VTEwsIDApOwoJaWYgKG9iaiAmJiAob2JqLT50eXBlID09IE9CSl9UUkVFIHx8IG9iai0+dHlwZSA9PSBPQkpfQ09NTUlUKSkKCQlyZXR1cm4gMTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGRpc2FtYmlndWF0ZV9ibG9iX29ubHkoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgdm9pZCAqY2JfZGF0YV91bnVzZWQpCnsKCWludCBraW5kID0gc2hhMV9vYmplY3RfaW5mbyhzaGExLCBOVUxMKTsKCXJldHVybiBraW5kID09IE9CSl9CTE9COwp9CgpzdGF0aWMgaW50IHByZXBhcmVfcHJlZml4ZXMoY29uc3QgY2hhciAqbmFtZSwgaW50IGxlbiwKCQkJICAgIHVuc2lnbmVkIGNoYXIgKmJpbl9wZngsCgkJCSAgICBjaGFyICpoZXhfcGZ4KQp7CglpbnQgaTsKCgloYXNoY2xyKGJpbl9wZngpOwoJbWVtc2V0KGhleF9wZngsICd4JywgNDApOwoJZm9yIChpID0gMDsgaSA8IGxlbiA7aSsrKSB7CgkJdW5zaWduZWQgY2hhciBjID0gbmFtZVtpXTsKCQl1bnNpZ25lZCBjaGFyIHZhbDsKCQlpZiAoYyA+PSAnMCcgJiYgYyA8PSAnOScpCgkJCXZhbCA9IGMgLSAnMCc7CgkJZWxzZSBpZiAoYyA+PSAnYScgJiYgYyA8PSAnZicpCgkJCXZhbCA9IGMgLSAnYScgKyAxMDsKCQllbHNlIGlmIChjID49ICdBJyAmJiBjIDw9J0YnKSB7CgkJCXZhbCA9IGMgLSAnQScgKyAxMDsKCQkJYyAtPSAnQScgLSAnYSc7CgkJfQoJCWVsc2UKCQkJcmV0dXJuIC0xOwoJCWhleF9wZnhbaV0gPSBjOwoJCWlmICghKGkgJiAxKSkKCQkJdmFsIDw8PSA0OwoJCWJpbl9wZnhbaSA+PiAxXSB8PSB2YWw7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBnZXRfc2hvcnRfc2hhMShjb25zdCBjaGFyICpuYW1lLCBpbnQgbGVuLCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCQkgIHVuc2lnbmVkIGZsYWdzKQp7CglpbnQgc3RhdHVzOwoJY2hhciBoZXhfcGZ4WzQwXTsKCXVuc2lnbmVkIGNoYXIgYmluX3BmeFsyMF07CglzdHJ1Y3QgZGlzYW1iaWd1YXRlX3N0YXRlIGRzOwoJaW50IHF1aWV0bHkgPSAhIShmbGFncyAmIEdFVF9TSEExX1FVSUVUTFkpOwoKCWlmIChsZW4gPCBNSU5JTVVNX0FCQlJFViB8fCBsZW4gPiA0MCkKCQlyZXR1cm4gLTE7CglpZiAocHJlcGFyZV9wcmVmaXhlcyhuYW1lLCBsZW4sIGJpbl9wZngsIGhleF9wZngpIDwgMCkKCQlyZXR1cm4gLTE7CgoJcHJlcGFyZV9hbHRfb2RiKCk7CgoJbWVtc2V0KCZkcywgMCwgc2l6ZW9mKGRzKSk7CglpZiAoZmxhZ3MgJiBHRVRfU0hBMV9DT01NSVQpCgkJZHMuZm4gPSBkaXNhbWJpZ3VhdGVfY29tbWl0X29ubHk7CgllbHNlIGlmIChmbGFncyAmIEdFVF9TSEExX0NPTU1JVFRJU0gpCgkJZHMuZm4gPSBkaXNhbWJpZ3VhdGVfY29tbWl0dGlzaF9vbmx5OwoJZWxzZSBpZiAoZmxhZ3MgJiBHRVRfU0hBMV9UUkVFKQoJCWRzLmZuID0gZGlzYW1iaWd1YXRlX3RyZWVfb25seTsKCWVsc2UgaWYgKGZsYWdzICYgR0VUX1NIQTFfVFJFRUlTSCkKCQlkcy5mbiA9IGRpc2FtYmlndWF0ZV90cmVlaXNoX29ubHk7CgllbHNlIGlmIChmbGFncyAmIEdFVF9TSEExX0JMT0IpCgkJZHMuZm4gPSBkaXNhbWJpZ3VhdGVfYmxvYl9vbmx5OwoKCWZpbmRfc2hvcnRfb2JqZWN0X2ZpbGVuYW1lKGxlbiwgaGV4X3BmeCwgJmRzKTsKCWZpbmRfc2hvcnRfcGFja2VkX29iamVjdChsZW4sIGJpbl9wZngsICZkcyk7CglzdGF0dXMgPSBmaW5pc2hfb2JqZWN0X2Rpc2FtYmlndWF0aW9uKCZkcywgc2hhMSk7CgoJaWYgKCFxdWlldGx5ICYmIChzdGF0dXMgPT0gU0hPUlRfTkFNRV9BTUJJR1VPVVMpKQoJCXJldHVybiBlcnJvcigic2hvcnQgU0hBMSAlLipzIGlzIGFtYmlndW91cy4iLCBsZW4sIGhleF9wZngpOwoJcmV0dXJuIHN0YXR1czsKfQoKCmludCBmb3JfZWFjaF9hYmJyZXYoY29uc3QgY2hhciAqcHJlZml4LCBlYWNoX2FiYnJldl9mbiBmbiwgdm9pZCAqY2JfZGF0YSkKewoJY2hhciBoZXhfcGZ4WzQwXTsKCXVuc2lnbmVkIGNoYXIgYmluX3BmeFsyMF07CglzdHJ1Y3QgZGlzYW1iaWd1YXRlX3N0YXRlIGRzOwoJaW50IGxlbiA9IHN0cmxlbihwcmVmaXgpOwoKCWlmIChsZW4gPCBNSU5JTVVNX0FCQlJFViB8fCBsZW4gPiA0MCkKCQlyZXR1cm4gLTE7CglpZiAocHJlcGFyZV9wcmVmaXhlcyhwcmVmaXgsIGxlbiwgYmluX3BmeCwgaGV4X3BmeCkgPCAwKQoJCXJldHVybiAtMTsKCglwcmVwYXJlX2FsdF9vZGIoKTsKCgltZW1zZXQoJmRzLCAwLCBzaXplb2YoZHMpKTsKCWRzLmFsd2F5c19jYWxsX2ZuID0gMTsKCWRzLmNiX2RhdGEgPSBjYl9kYXRhOwoJZHMuZm4gPSBmbjsKCglmaW5kX3Nob3J0X29iamVjdF9maWxlbmFtZShsZW4sIGhleF9wZngsICZkcyk7CglmaW5kX3Nob3J0X3BhY2tlZF9vYmplY3QobGVuLCBiaW5fcGZ4LCAmZHMpOwoJcmV0dXJuIGRzLmFtYmlndW91czsKfQoKY29uc3QgY2hhciAqZmluZF91bmlxdWVfYWJicmV2KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIGludCBsZW4pCnsKCWludCBzdGF0dXMsIGV4aXN0czsKCXN0YXRpYyBjaGFyIGhleFs0MV07CgoJZXhpc3RzID0gaGFzX3NoYTFfZmlsZShzaGExKTsKCW1lbWNweShoZXgsIHNoYTFfdG9faGV4KHNoYTEpLCA0MCk7CglpZiAobGVuID09IDQwIHx8ICFsZW4pCgkJcmV0dXJuIGhleDsKCXdoaWxlIChsZW4gPCA0MCkgewoJCXVuc2lnbmVkIGNoYXIgc2hhMV9yZXRbMjBdOwoJCXN0YXR1cyA9IGdldF9zaG9ydF9zaGExKGhleCwgbGVuLCBzaGExX3JldCwgR0VUX1NIQTFfUVVJRVRMWSk7CgkJaWYgKGV4aXN0cwoJCSAgICA/ICFzdGF0dXMKCQkgICAgOiBzdGF0dXMgPT0gU0hPUlRfTkFNRV9OT1RfRk9VTkQpIHsKCQkJaGV4W2xlbl0gPSAwOwoJCQlyZXR1cm4gaGV4OwoJCX0KCQlsZW4rKzsKCX0KCXJldHVybiBoZXg7Cn0KCnN0YXRpYyBpbnQgYW1iaWd1b3VzX3BhdGgoY29uc3QgY2hhciAqcGF0aCwgaW50IGxlbikKewoJaW50IHNsYXNoID0gMTsKCWludCBjbnQ7CgoJZm9yIChjbnQgPSAwOyBjbnQgPCBsZW47IGNudCsrKSB7CgkJc3dpdGNoICgqcGF0aCsrKSB7CgkJY2FzZSAnXDAnOgoJCQlicmVhazsKCQljYXNlICcvJzoKCQkJaWYgKHNsYXNoKQoJCQkJYnJlYWs7CgkJCXNsYXNoID0gMTsKCQkJY29udGludWU7CgkJY2FzZSAnLic6CgkJCWNvbnRpbnVlOwoJCWRlZmF1bHQ6CgkJCXNsYXNoID0gMDsKCQkJY29udGludWU7CgkJfQoJCWJyZWFrOwoJfQoJcmV0dXJuIHNsYXNoOwp9CgpzdGF0aWMgaW5saW5lIGludCB1cHN0cmVhbV9tYXJrKGNvbnN0IGNoYXIgKnN0cmluZywgaW50IGxlbikKewoJY29uc3QgY2hhciAqc3VmZml4W10gPSB7ICJAe3Vwc3RyZWFtfSIsICJAe3V9IiB9OwoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IEFSUkFZX1NJWkUoc3VmZml4KTsgaSsrKSB7CgkJaW50IHN1ZmZpeF9sZW4gPSBzdHJsZW4oc3VmZml4W2ldKTsKCQlpZiAoc3VmZml4X2xlbiA8PSBsZW4KCQkgICAgJiYgIW1lbWNtcChzdHJpbmcsIHN1ZmZpeFtpXSwgc3VmZml4X2xlbikpCgkJCXJldHVybiBzdWZmaXhfbGVuOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZ2V0X3NoYTFfMShjb25zdCBjaGFyICpuYW1lLCBpbnQgbGVuLCB1bnNpZ25lZCBjaGFyICpzaGExLCB1bnNpZ25lZCBsb29rdXBfZmxhZ3MpOwoKc3RhdGljIGludCBnZXRfc2hhMV9iYXNpYyhjb25zdCBjaGFyICpzdHIsIGludCBsZW4sIHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXN0YXRpYyBjb25zdCBjaGFyICp3YXJuX21zZyA9ICJyZWZuYW1lICclLipzJyBpcyBhbWJpZ3VvdXMuIjsKCWNoYXIgKnJlYWxfcmVmID0gTlVMTDsKCWludCByZWZzX2ZvdW5kID0gMDsKCWludCBhdCwgcmVmbG9nX2xlbjsKCglpZiAobGVuID09IDQwICYmICFnZXRfc2hhMV9oZXgoc3RyLCBzaGExKSkKCQlyZXR1cm4gMDsKCgkvKiBiYXNpY0B7dGltZSBvciBudW1iZXIgb3IgLW51bWJlcn0gZm9ybWF0IHRvIHF1ZXJ5IHJlZi1sb2cgKi8KCXJlZmxvZ19sZW4gPSBhdCA9IDA7CglpZiAobGVuICYmIHN0cltsZW4tMV0gPT0gJ30nKSB7CgkJZm9yIChhdCA9IGxlbi0yOyBhdCA+PSAwOyBhdC0tKSB7CgkJCWlmIChzdHJbYXRdID09ICdAJyAmJiBzdHJbYXQrMV0gPT0gJ3snKSB7CgkJCQlpZiAoIXVwc3RyZWFtX21hcmsoc3RyICsgYXQsIGxlbiAtIGF0KSkgewoJCQkJCXJlZmxvZ19sZW4gPSAobGVuLTEpIC0gKGF0KzIpOwoJCQkJCWxlbiA9IGF0OwoJCQkJfQoJCQkJYnJlYWs7CgkJCX0KCQl9Cgl9CgoJLyogQWNjZXB0IG9ubHkgdW5hbWJpZ3VvdXMgcmVmIHBhdGhzLiAqLwoJaWYgKGxlbiAmJiBhbWJpZ3VvdXNfcGF0aChzdHIsIGxlbikpCgkJcmV0dXJuIC0xOwoKCWlmICghbGVuICYmIHJlZmxvZ19sZW4pIHsKCQlzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJCWludCByZXQ7CgkJLyogdHJ5IHRoZSBAey1OfSBzeW50YXggZm9yIG4tdGggY2hlY2tvdXQgKi8KCQlyZXQgPSBpbnRlcnByZXRfYnJhbmNoX25hbWUoc3RyK2F0LCAmYnVmKTsKCQlpZiAocmV0ID4gMCkgewoJCQkvKiBzdWJzdGl0dXRlIHRoaXMgYnJhbmNoIG5hbWUgYW5kIHJlc3RhcnQgKi8KCQkJcmV0dXJuIGdldF9zaGExXzEoYnVmLmJ1ZiwgYnVmLmxlbiwgc2hhMSwgMCk7CgkJfSBlbHNlIGlmIChyZXQgPT0gMCkgewoJCQlyZXR1cm4gLTE7CgkJfQoJCS8qIGFsbG93ICJAey4uLn0iIHRvIG1lYW4gdGhlIGN1cnJlbnQgYnJhbmNoIHJlZmxvZyAqLwoJCXJlZnNfZm91bmQgPSBkd2ltX3JlZigiSEVBRCIsIDQsIHNoYTEsICZyZWFsX3JlZik7Cgl9IGVsc2UgaWYgKHJlZmxvZ19sZW4pCgkJcmVmc19mb3VuZCA9IGR3aW1fbG9nKHN0ciwgbGVuLCBzaGExLCAmcmVhbF9yZWYpOwoJZWxzZQoJCXJlZnNfZm91bmQgPSBkd2ltX3JlZihzdHIsIGxlbiwgc2hhMSwgJnJlYWxfcmVmKTsKCglpZiAoIXJlZnNfZm91bmQpCgkJcmV0dXJuIC0xOwoKCWlmICh3YXJuX2FtYmlndW91c19yZWZzICYmIHJlZnNfZm91bmQgPiAxKQoJCXdhcm5pbmcod2Fybl9tc2csIGxlbiwgc3RyKTsKCglpZiAocmVmbG9nX2xlbikgewoJCWludCBudGgsIGk7CgkJdW5zaWduZWQgbG9uZyBhdF90aW1lOwoJCXVuc2lnbmVkIGxvbmcgY29fdGltZTsKCQlpbnQgY29fdHosIGNvX2NudDsKCgkJLyogYSBAey1OfSBwbGFjZWQgYW55d2hlcmUgZXhjZXB0IHRoZSBzdGFydCBpcyBhbiBlcnJvciAqLwoJCWlmIChzdHJbYXQrMl0gPT0gJy0nKQoJCQlyZXR1cm4gLTE7CgoJCS8qIElzIGl0IGFza2luZyBmb3IgTi10aCBlbnRyeSwgb3IgYXBwcm94aWRhdGU/ICovCgkJZm9yIChpID0gbnRoID0gMDsgMCA8PSBudGggJiYgaSA8IHJlZmxvZ19sZW47IGkrKykgewoJCQljaGFyIGNoID0gc3RyW2F0KzIraV07CgkJCWlmICgnMCcgPD0gY2ggJiYgY2ggPD0gJzknKQoJCQkJbnRoID0gbnRoICogMTAgKyBjaCAtICcwJzsKCQkJZWxzZQoJCQkJbnRoID0gLTE7CgkJfQoJCWlmICgxMDAwMDAwMDAgPD0gbnRoKSB7CgkJCWF0X3RpbWUgPSBudGg7CgkJCW50aCA9IC0xOwoJCX0gZWxzZSBpZiAoMCA8PSBudGgpCgkJCWF0X3RpbWUgPSAwOwoJCWVsc2UgewoJCQlpbnQgZXJyb3JzID0gMDsKCQkJY2hhciAqdG1wID0geHN0cm5kdXAoc3RyICsgYXQgKyAyLCByZWZsb2dfbGVuKTsKCQkJYXRfdGltZSA9IGFwcHJveGlkYXRlX2NhcmVmdWwodG1wLCAmZXJyb3JzKTsKCQkJZnJlZSh0bXApOwoJCQlpZiAoZXJyb3JzKQoJCQkJcmV0dXJuIC0xOwoJCX0KCQlpZiAocmVhZF9yZWZfYXQocmVhbF9yZWYsIGF0X3RpbWUsIG50aCwgc2hhMSwgTlVMTCwKCQkJCSZjb190aW1lLCAmY29fdHosICZjb19jbnQpKSB7CgkJCWlmICghbGVuKSB7CgkJCQlpZiAoIXByZWZpeGNtcChyZWFsX3JlZiwgInJlZnMvaGVhZHMvIikpIHsKCQkJCQlzdHIgPSByZWFsX3JlZiArIDExOwoJCQkJCWxlbiA9IHN0cmxlbihyZWFsX3JlZiArIDExKTsKCQkJCX0gZWxzZSB7CgkJCQkJLyogZGV0YWNoZWQgSEVBRCAqLwoJCQkJCXN0ciA9ICJIRUFEIjsKCQkJCQlsZW4gPSA0OwoJCQkJfQoJCQl9CgkJCWlmIChhdF90aW1lKQoJCQkJd2FybmluZygiTG9nIGZvciAnJS4qcycgb25seSBnb2VzICIKCQkJCQkiYmFjayB0byAlcy4iLCBsZW4sIHN0ciwKCQkJCQlzaG93X2RhdGUoY29fdGltZSwgY29fdHosIERBVEVfUkZDMjgyMikpOwoJCQllbHNlIHsKCQkJCWRpZSgiTG9nIGZvciAnJS4qcycgb25seSBoYXMgJWQgZW50cmllcy4iLAoJCQkJICAgIGxlbiwgc3RyLCBjb19jbnQpOwoJCQl9CgkJfQoJfQoKCWZyZWUocmVhbF9yZWYpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZ2V0X3BhcmVudChjb25zdCBjaGFyICpuYW1lLCBpbnQgbGVuLAoJCSAgICAgIHVuc2lnbmVkIGNoYXIgKnJlc3VsdCwgaW50IGlkeCkKewoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCWludCByZXQgPSBnZXRfc2hhMV8xKG5hbWUsIGxlbiwgc2hhMSwgR0VUX1NIQTFfQ09NTUlUVElTSCk7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnA7CgoJaWYgKHJldCkKCQlyZXR1cm4gcmV0OwoJY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2Uoc2hhMSk7CglpZiAoIWNvbW1pdCkKCQlyZXR1cm4gLTE7CglpZiAocGFyc2VfY29tbWl0KGNvbW1pdCkpCgkJcmV0dXJuIC0xOwoJaWYgKCFpZHgpIHsKCQloYXNoY3B5KHJlc3VsdCwgY29tbWl0LT5vYmplY3Quc2hhMSk7CgkJcmV0dXJuIDA7Cgl9CglwID0gY29tbWl0LT5wYXJlbnRzOwoJd2hpbGUgKHApIHsKCQlpZiAoIS0taWR4KSB7CgkJCWhhc2hjcHkocmVzdWx0LCBwLT5pdGVtLT5vYmplY3Quc2hhMSk7CgkJCXJldHVybiAwOwoJCX0KCQlwID0gcC0+bmV4dDsKCX0KCXJldHVybiAtMTsKfQoKc3RhdGljIGludCBnZXRfbnRoX2FuY2VzdG9yKGNvbnN0IGNoYXIgKm5hbWUsIGludCBsZW4sCgkJCSAgICB1bnNpZ25lZCBjaGFyICpyZXN1bHQsIGludCBnZW5lcmF0aW9uKQp7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJaW50IHJldDsKCglyZXQgPSBnZXRfc2hhMV8xKG5hbWUsIGxlbiwgc2hhMSwgR0VUX1NIQTFfQ09NTUlUVElTSCk7CglpZiAocmV0KQoJCXJldHVybiByZXQ7Cgljb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZShzaGExKTsKCWlmICghY29tbWl0KQoJCXJldHVybiAtMTsKCgl3aGlsZSAoZ2VuZXJhdGlvbi0tKSB7CgkJaWYgKHBhcnNlX2NvbW1pdChjb21taXQpIHx8ICFjb21taXQtPnBhcmVudHMpCgkJCXJldHVybiAtMTsKCQljb21taXQgPSBjb21taXQtPnBhcmVudHMtPml0ZW07Cgl9CgloYXNoY3B5KHJlc3VsdCwgY29tbWl0LT5vYmplY3Quc2hhMSk7CglyZXR1cm4gMDsKfQoKc3RydWN0IG9iamVjdCAqcGVlbF90b190eXBlKGNvbnN0IGNoYXIgKm5hbWUsIGludCBuYW1lbGVuLAoJCQkgICAgc3RydWN0IG9iamVjdCAqbywgZW51bSBvYmplY3RfdHlwZSBleHBlY3RlZF90eXBlKQp7CglpZiAobmFtZSAmJiAhbmFtZWxlbikKCQluYW1lbGVuID0gc3RybGVuKG5hbWUpOwoJd2hpbGUgKDEpIHsKCQlpZiAoIW8gfHwgKCFvLT5wYXJzZWQgJiYgIXBhcnNlX29iamVjdChvLT5zaGExKSkpCgkJCXJldHVybiBOVUxMOwoJCWlmIChleHBlY3RlZF90eXBlID09IE9CSl9BTlkgfHwgby0+dHlwZSA9PSBleHBlY3RlZF90eXBlKQoJCQlyZXR1cm4gbzsKCQlpZiAoby0+dHlwZSA9PSBPQkpfVEFHKQoJCQlvID0gKChzdHJ1Y3QgdGFnKikgbyktPnRhZ2dlZDsKCQllbHNlIGlmIChvLT50eXBlID09IE9CSl9DT01NSVQpCgkJCW8gPSAmKCgoc3RydWN0IGNvbW1pdCAqKSBvKS0+dHJlZS0+b2JqZWN0KTsKCQllbHNlIHsKCQkJaWYgKG5hbWUpCgkJCQllcnJvcigiJS4qczogZXhwZWN0ZWQgJXMgdHlwZSwgYnV0IHRoZSBvYmplY3QgIgoJCQkJICAgICAgImRlcmVmZXJlbmNlcyB0byAlcyB0eXBlIiwKCQkJCSAgICAgIG5hbWVsZW4sIG5hbWUsIHR5cGVuYW1lKGV4cGVjdGVkX3R5cGUpLAoJCQkJICAgICAgdHlwZW5hbWUoby0+dHlwZSkpOwoJCQlyZXR1cm4gTlVMTDsKCQl9Cgl9Cn0KCnN0YXRpYyBpbnQgcGVlbF9vbmlvbihjb25zdCBjaGFyICpuYW1lLCBpbnQgbGVuLCB1bnNpZ25lZCBjaGFyICpzaGExKQp7Cgl1bnNpZ25lZCBjaGFyIG91dGVyWzIwXTsKCWNvbnN0IGNoYXIgKnNwOwoJdW5zaWduZWQgaW50IGV4cGVjdGVkX3R5cGUgPSAwOwoJdW5zaWduZWQgbG9va3VwX2ZsYWdzID0gMDsKCXN0cnVjdCBvYmplY3QgKm87CgoJLyoKCSAqICJyZWZee3R5cGV9IiBkZXJlZmVyZW5jZXMgcmVmIHJlcGVhdGVkbHkgdW50aWwgeW91IGNhbm5vdAoJICogZGVyZWZlcmVuY2UgYW55bW9yZSwgb3IgeW91IGdldCBhbiBvYmplY3Qgb2YgZ2l2ZW4gdHlwZSwKCSAqIHdoaWNoZXZlciBjb21lcyBmaXJzdC4gICJyZWZee30iIG1lYW5zIGp1c3QgZGVyZWZlcmVuY2UKCSAqIHRhZ3MgdW50aWwgeW91IGdldCBhIG5vbi10YWcuICAicmVmXjAiIGlzIGEgc2hvcnRoYW5kIGZvcgoJICogInJlZl57Y29tbWl0fSIuICAiY29tbWl0Xnt0cmVlfSIgY291bGQgYmUgdXNlZCB0byBmaW5kIHRoZQoJICogdG9wLWxldmVsIHRyZWUgb2YgdGhlIGdpdmVuIGNvbW1pdC4KCSAqLwoJaWYgKGxlbiA8IDQgfHwgbmFtZVtsZW4tMV0gIT0gJ30nKQoJCXJldHVybiAtMTsKCglmb3IgKHNwID0gbmFtZSArIGxlbiAtIDE7IG5hbWUgPD0gc3A7IHNwLS0pIHsKCQlpbnQgY2ggPSAqc3A7CgkJaWYgKGNoID09ICd7JyAmJiBuYW1lIDwgc3AgJiYgc3BbLTFdID09ICdeJykKCQkJYnJlYWs7Cgl9CglpZiAoc3AgPD0gbmFtZSkKCQlyZXR1cm4gLTE7CgoJc3ArKzsgLyogYmVnaW5uaW5nIG9mIHR5cGUgbmFtZSwgb3IgY2xvc2luZyBicmFjZSBmb3IgZW1wdHkgKi8KCWlmICghc3RybmNtcChjb21taXRfdHlwZSwgc3AsIDYpICYmIHNwWzZdID09ICd9JykKCQlleHBlY3RlZF90eXBlID0gT0JKX0NPTU1JVDsKCWVsc2UgaWYgKCFzdHJuY21wKHRyZWVfdHlwZSwgc3AsIDQpICYmIHNwWzRdID09ICd9JykKCQlleHBlY3RlZF90eXBlID0gT0JKX1RSRUU7CgllbHNlIGlmICghc3RybmNtcChibG9iX3R5cGUsIHNwLCA0KSAmJiBzcFs0XSA9PSAnfScpCgkJZXhwZWN0ZWRfdHlwZSA9IE9CSl9CTE9COwoJZWxzZSBpZiAoIXByZWZpeGNtcChzcCwgIm9iamVjdH0iKSkKCQlleHBlY3RlZF90eXBlID0gT0JKX0FOWTsKCWVsc2UgaWYgKHNwWzBdID09ICd9JykKCQlleHBlY3RlZF90eXBlID0gT0JKX05PTkU7CgllbHNlIGlmIChzcFswXSA9PSAnLycpCgkJZXhwZWN0ZWRfdHlwZSA9IE9CSl9DT01NSVQ7CgllbHNlCgkJcmV0dXJuIC0xOwoKCWlmIChleHBlY3RlZF90eXBlID09IE9CSl9DT01NSVQpCgkJbG9va3VwX2ZsYWdzID0gR0VUX1NIQTFfQ09NTUlUVElTSDsKCWVsc2UgaWYgKGV4cGVjdGVkX3R5cGUgPT0gT0JKX1RSRUUpCgkJbG9va3VwX2ZsYWdzID0gR0VUX1NIQTFfVFJFRUlTSDsKCglpZiAoZ2V0X3NoYTFfMShuYW1lLCBzcCAtIG5hbWUgLSAyLCBvdXRlciwgbG9va3VwX2ZsYWdzKSkKCQlyZXR1cm4gLTE7CgoJbyA9IHBhcnNlX29iamVjdChvdXRlcik7CglpZiAoIW8pCgkJcmV0dXJuIC0xOwoJaWYgKCFleHBlY3RlZF90eXBlKSB7CgkJbyA9IGRlcmVmX3RhZyhvLCBuYW1lLCBzcCAtIG5hbWUgLSAyKTsKCQlpZiAoIW8gfHwgKCFvLT5wYXJzZWQgJiYgIXBhcnNlX29iamVjdChvLT5zaGExKSkpCgkJCXJldHVybiAtMTsKCQloYXNoY3B5KHNoYTEsIG8tPnNoYTEpOwoJCXJldHVybiAwOwoJfQoKCS8qCgkgKiBBdCB0aGlzIHBvaW50LCB0aGUgc3ludGF4IGxvb2sgY29ycmVjdCwgc28KCSAqIGlmIHdlIGRvIG5vdCBnZXQgdGhlIG5lZWRlZCBvYmplY3QsIHdlIHNob3VsZAoJICogYmFyZi4KCSAqLwoJbyA9IHBlZWxfdG9fdHlwZShuYW1lLCBsZW4sIG8sIGV4cGVjdGVkX3R5cGUpOwoJaWYgKCFvKQoJCXJldHVybiAtMTsKCgloYXNoY3B5KHNoYTEsIG8tPnNoYTEpOwoJaWYgKHNwWzBdID09ICcvJykgewoJCS8qICIkY29tbWl0XnsvZm9vfSIgKi8KCQljaGFyICpwcmVmaXg7CgkJaW50IHJldDsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QgPSBOVUxMOwoKCQkvKgoJCSAqICRjb21taXReey99LiBTb21lIHJlZ2V4IGltcGxlbWVudGF0aW9uIG1heSByZWplY3QuCgkJICogV2UgZG9uJ3QgbmVlZCByZWdleCBhbnl3YXkuICcnIHBhdHRlcm4gYWx3YXlzIG1hdGNoZXMuCgkJICovCgkJaWYgKHNwWzFdID09ICd9JykKCQkJcmV0dXJuIDA7CgoJCXByZWZpeCA9IHhzdHJuZHVwKHNwICsgMSwgbmFtZSArIGxlbiAtIDEgLSAoc3AgKyAxKSk7CgkJY29tbWl0X2xpc3RfaW5zZXJ0KChzdHJ1Y3QgY29tbWl0ICopbywgJmxpc3QpOwoJCXJldCA9IGdldF9zaGExX29uZWxpbmUocHJlZml4LCBzaGExLCBsaXN0KTsKCQlmcmVlKHByZWZpeCk7CgkJcmV0dXJuIHJldDsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdldF9kZXNjcmliZV9uYW1lKGNvbnN0IGNoYXIgKm5hbWUsIGludCBsZW4sIHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCWNvbnN0IGNoYXIgKmNwOwoJdW5zaWduZWQgZmxhZ3MgPSBHRVRfU0hBMV9RVUlFVExZIHwgR0VUX1NIQTFfQ09NTUlUOwoKCWZvciAoY3AgPSBuYW1lICsgbGVuIC0gMTsgbmFtZSArIDIgPD0gY3A7IGNwLS0pIHsKCQljaGFyIGNoID0gKmNwOwoJCWlmIChoZXh2YWwoY2gpICYgfjAzNzcpIHsKCQkJLyogV2UgbXVzdCBiZSBsb29raW5nIGF0IGcgaW4gIlNPTUVUSElORy1nIgoJCQkgKiBmb3IgaXQgdG8gYmUgZGVzY3JpYmUgb3V0cHV0LgoJCQkgKi8KCQkJaWYgKGNoID09ICdnJyAmJiBjcFstMV0gPT0gJy0nKSB7CgkJCQljcCsrOwoJCQkJbGVuIC09IGNwIC0gbmFtZTsKCQkJCXJldHVybiBnZXRfc2hvcnRfc2hhMShjcCwgbGVuLCBzaGExLCBmbGFncyk7CgkJCX0KCQl9Cgl9CglyZXR1cm4gLTE7Cn0KCnN0YXRpYyBpbnQgZ2V0X3NoYTFfMShjb25zdCBjaGFyICpuYW1lLCBpbnQgbGVuLCB1bnNpZ25lZCBjaGFyICpzaGExLCB1bnNpZ25lZCBsb29rdXBfZmxhZ3MpCnsKCWludCByZXQsIGhhc19zdWZmaXg7Cgljb25zdCBjaGFyICpjcDsKCgkvKgoJICogIm5hbWV+MyIgaXMgIm5hbWVeXl4iLCAibmFtZX4iIGlzICJuYW1lfjEiLCBhbmQgIm5hbWVeIiBpcyAibmFtZV4xIi4KCSAqLwoJaGFzX3N1ZmZpeCA9IDA7Cglmb3IgKGNwID0gbmFtZSArIGxlbiAtIDE7IG5hbWUgPD0gY3A7IGNwLS0pIHsKCQlpbnQgY2ggPSAqY3A7CgkJaWYgKCcwJyA8PSBjaCAmJiBjaCA8PSAnOScpCgkJCWNvbnRpbnVlOwoJCWlmIChjaCA9PSAnficgfHwgY2ggPT0gJ14nKQoJCQloYXNfc3VmZml4ID0gY2g7CgkJYnJlYWs7Cgl9CgoJaWYgKGhhc19zdWZmaXgpIHsKCQlpbnQgbnVtID0gMDsKCQlpbnQgbGVuMSA9IGNwIC0gbmFtZTsKCQljcCsrOwoJCXdoaWxlIChjcCA8IG5hbWUgKyBsZW4pCgkJCW51bSA9IG51bSAqIDEwICsgKmNwKysgLSAnMCc7CgkJaWYgKCFudW0gJiYgbGVuMSA9PSBsZW4gLSAxKQoJCQludW0gPSAxOwoJCWlmIChoYXNfc3VmZml4ID09ICdeJykKCQkJcmV0dXJuIGdldF9wYXJlbnQobmFtZSwgbGVuMSwgc2hhMSwgbnVtKTsKCQkvKiBlbHNlIGlmIChoYXNfc3VmZml4ID09ICd+JykgLS0gZ29lcyB3aXRob3V0IHNheWluZyAqLwoJCXJldHVybiBnZXRfbnRoX2FuY2VzdG9yKG5hbWUsIGxlbjEsIHNoYTEsIG51bSk7Cgl9CgoJcmV0ID0gcGVlbF9vbmlvbihuYW1lLCBsZW4sIHNoYTEpOwoJaWYgKCFyZXQpCgkJcmV0dXJuIDA7CgoJcmV0ID0gZ2V0X3NoYTFfYmFzaWMobmFtZSwgbGVuLCBzaGExKTsKCWlmICghcmV0KQoJCXJldHVybiAwOwoKCS8qIEl0IGNvdWxkIGJlIGRlc2NyaWJlIG91dHB1dCB0aGF0IGlzICJTT01FVEhJTkctZ1hYWFgiICovCglyZXQgPSBnZXRfZGVzY3JpYmVfbmFtZShuYW1lLCBsZW4sIHNoYTEpOwoJaWYgKCFyZXQpCgkJcmV0dXJuIDA7CgoJcmV0dXJuIGdldF9zaG9ydF9zaGExKG5hbWUsIGxlbiwgc2hhMSwgbG9va3VwX2ZsYWdzKTsKfQoKLyoKICogVGhpcyBpbnRlcnByZXRzIG5hbWVzIGxpa2UgJzovSW5pdGlhbCByZXZpc2lvbiBvZiAiZ2l0IicgYnkgc2VhcmNoaW5nCiAqIHRocm91Z2ggaGlzdG9yeSBhbmQgcmV0dXJuaW5nIHRoZSBmaXJzdCBjb21taXQgd2hvc2UgbWVzc2FnZSBzdGFydHMKICogdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi4KICoKICogRm9yIGZ1dHVyZSBleHRlbnNpb24sICc6LyEnIGlzIHJlc2VydmVkLiBJZiB5b3Ugd2FudCB0byBtYXRjaCBhIG1lc3NhZ2UKICogYmVnaW5uaW5nIHdpdGggYSAnIScsIHlvdSBoYXZlIHRvIHJlcGVhdCB0aGUgZXhjbGFtYXRpb24gbWFyay4KICovCiNkZWZpbmUgT05FTElORV9TRUVOICgxdTw8MjApCgpzdGF0aWMgaW50IGhhbmRsZV9vbmVfcmVmKGNvbnN0IGNoYXIgKnBhdGgsCgkJY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgaW50IGZsYWcsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqKmxpc3QgPSBjYl9kYXRhOwoJc3RydWN0IG9iamVjdCAqb2JqZWN0ID0gcGFyc2Vfb2JqZWN0KHNoYTEpOwoJaWYgKCFvYmplY3QpCgkJcmV0dXJuIDA7CglpZiAob2JqZWN0LT50eXBlID09IE9CSl9UQUcpIHsKCQlvYmplY3QgPSBkZXJlZl90YWcob2JqZWN0LCBwYXRoLCBzdHJsZW4ocGF0aCkpOwoJCWlmICghb2JqZWN0KQoJCQlyZXR1cm4gMDsKCX0KCWlmIChvYmplY3QtPnR5cGUgIT0gT0JKX0NPTU1JVCkKCQlyZXR1cm4gMDsKCWNvbW1pdF9saXN0X2luc2VydF9ieV9kYXRlKChzdHJ1Y3QgY29tbWl0ICopb2JqZWN0LCBsaXN0KTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdldF9zaGExX29uZWxpbmUoY29uc3QgY2hhciAqcHJlZml4LCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCQkgICAgc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0KQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKmJhY2t1cCA9IE5VTEwsICpsOwoJaW50IGZvdW5kID0gMDsKCXJlZ2V4X3QgcmVnZXg7CgoJaWYgKHByZWZpeFswXSA9PSAnIScpIHsKCQlpZiAocHJlZml4WzFdICE9ICchJykKCQkJZGllICgiSW52YWxpZCBzZWFyY2ggcGF0dGVybjogJXMiLCBwcmVmaXgpOwoJCXByZWZpeCsrOwoJfQoKCWlmIChyZWdjb21wKCZyZWdleCwgcHJlZml4LCBSRUdfRVhURU5ERUQpKQoJCWRpZSgiSW52YWxpZCBzZWFyY2ggcGF0dGVybjogJXMiLCBwcmVmaXgpOwoKCWZvciAobCA9IGxpc3Q7IGw7IGwgPSBsLT5uZXh0KSB7CgkJbC0+aXRlbS0+b2JqZWN0LmZsYWdzIHw9IE9ORUxJTkVfU0VFTjsKCQljb21taXRfbGlzdF9pbnNlcnQobC0+aXRlbSwgJmJhY2t1cCk7Cgl9Cgl3aGlsZSAobGlzdCkgewoJCWNoYXIgKnAsICp0b19mcmVlID0gTlVMTDsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgkJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCQlpbnQgbWF0Y2hlczsKCgkJY29tbWl0ID0gcG9wX21vc3RfcmVjZW50X2NvbW1pdCgmbGlzdCwgT05FTElORV9TRUVOKTsKCQlpZiAoIXBhcnNlX29iamVjdChjb21taXQtPm9iamVjdC5zaGExKSkKCQkJY29udGludWU7CgkJaWYgKGNvbW1pdC0+YnVmZmVyKQoJCQlwID0gY29tbWl0LT5idWZmZXI7CgkJZWxzZSB7CgkJCXAgPSByZWFkX3NoYTFfZmlsZShjb21taXQtPm9iamVjdC5zaGExLCAmdHlwZSwgJnNpemUpOwoJCQlpZiAoIXApCgkJCQljb250aW51ZTsKCQkJdG9fZnJlZSA9IHA7CgkJfQoKCQlwID0gc3Ryc3RyKHAsICJcblxuIik7CgkJbWF0Y2hlcyA9IHAgJiYgIXJlZ2V4ZWMoJnJlZ2V4LCBwICsgMiwgMCwgTlVMTCwgMCk7CgkJZnJlZSh0b19mcmVlKTsKCgkJaWYgKG1hdGNoZXMpIHsKCQkJaGFzaGNweShzaGExLCBjb21taXQtPm9iamVjdC5zaGExKTsKCQkJZm91bmQgPSAxOwoJCQlicmVhazsKCQl9Cgl9CglyZWdmcmVlKCZyZWdleCk7CglmcmVlX2NvbW1pdF9saXN0KGxpc3QpOwoJZm9yIChsID0gYmFja3VwOyBsOyBsID0gbC0+bmV4dCkKCQljbGVhcl9jb21taXRfbWFya3MobC0+aXRlbSwgT05FTElORV9TRUVOKTsKCWZyZWVfY29tbWl0X2xpc3QoYmFja3VwKTsKCXJldHVybiBmb3VuZCA/IDAgOiAtMTsKfQoKc3RydWN0IGdyYWJfbnRoX2JyYW5jaF9zd2l0Y2hfY2JkYXRhIHsKCWludCByZW1haW5pbmc7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZjsKfTsKCnN0YXRpYyBpbnQgZ3JhYl9udGhfYnJhbmNoX3N3aXRjaCh1bnNpZ25lZCBjaGFyICpvc2hhMSwgdW5zaWduZWQgY2hhciAqbnNoYTEsCgkJCQkgIGNvbnN0IGNoYXIgKmVtYWlsLCB1bnNpZ25lZCBsb25nIHRpbWVzdGFtcCwgaW50IHR6LAoJCQkJICBjb25zdCBjaGFyICptZXNzYWdlLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3QgZ3JhYl9udGhfYnJhbmNoX3N3aXRjaF9jYmRhdGEgKmNiID0gY2JfZGF0YTsKCWNvbnN0IGNoYXIgKm1hdGNoID0gTlVMTCwgKnRhcmdldCA9IE5VTEw7CglzaXplX3QgbGVuOwoKCWlmICghcHJlZml4Y21wKG1lc3NhZ2UsICJjaGVja291dDogbW92aW5nIGZyb20gIikpIHsKCQltYXRjaCA9IG1lc3NhZ2UgKyBzdHJsZW4oImNoZWNrb3V0OiBtb3ZpbmcgZnJvbSAiKTsKCQl0YXJnZXQgPSBzdHJzdHIobWF0Y2gsICIgdG8gIik7Cgl9CgoJaWYgKCFtYXRjaCB8fCAhdGFyZ2V0KQoJCXJldHVybiAwOwoJaWYgKC0tKGNiLT5yZW1haW5pbmcpID09IDApIHsKCQlsZW4gPSB0YXJnZXQgLSBtYXRjaDsKCQlzdHJidWZfcmVzZXQoJmNiLT5idWYpOwoJCXN0cmJ1Zl9hZGQoJmNiLT5idWYsIG1hdGNoLCBsZW4pOwoJCXJldHVybiAxOyAvKiB3ZSBhcmUgZG9uZSAqLwoJfQoJcmV0dXJuIDA7Cn0KCi8qCiAqIFBhcnNlIEB7LU59IHN5bnRheCwgcmV0dXJuIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBwYXJzZWQKICogaWYgc3VjY2Vzc2Z1bDsgb3RoZXJ3aXNlIHNpZ25hbCBhbiBlcnJvciB3aXRoIG5lZ2F0aXZlIHZhbHVlLgogKi8Kc3RhdGljIGludCBpbnRlcnByZXRfbnRoX3ByaW9yX2NoZWNrb3V0KGNvbnN0IGNoYXIgKm5hbWUsIHN0cnVjdCBzdHJidWYgKmJ1ZikKewoJbG9uZyBudGg7CglpbnQgcmV0dmFsOwoJc3RydWN0IGdyYWJfbnRoX2JyYW5jaF9zd2l0Y2hfY2JkYXRhIGNiOwoJY29uc3QgY2hhciAqYnJhY2U7CgljaGFyICpudW1fZW5kOwoKCWlmIChuYW1lWzBdICE9ICdAJyB8fCBuYW1lWzFdICE9ICd7JyB8fCBuYW1lWzJdICE9ICctJykKCQlyZXR1cm4gLTE7CglicmFjZSA9IHN0cmNocihuYW1lLCAnfScpOwoJaWYgKCFicmFjZSkKCQlyZXR1cm4gLTE7CgludGggPSBzdHJ0b2wobmFtZSArIDMsICZudW1fZW5kLCAxMCk7CglpZiAobnVtX2VuZCAhPSBicmFjZSkKCQlyZXR1cm4gLTE7CglpZiAobnRoIDw9IDApCgkJcmV0dXJuIC0xOwoJY2IucmVtYWluaW5nID0gbnRoOwoJc3RyYnVmX2luaXQoJmNiLmJ1ZiwgMjApOwoKCXJldHZhbCA9IDA7CglpZiAoMCA8IGZvcl9lYWNoX3JlZmxvZ19lbnRfcmV2ZXJzZSgiSEVBRCIsIGdyYWJfbnRoX2JyYW5jaF9zd2l0Y2gsICZjYikpIHsKCQlzdHJidWZfcmVzZXQoYnVmKTsKCQlzdHJidWZfYWRkKGJ1ZiwgY2IuYnVmLmJ1ZiwgY2IuYnVmLmxlbik7CgkJcmV0dmFsID0gYnJhY2UgLSBuYW1lICsgMTsKCX0KCglzdHJidWZfcmVsZWFzZSgmY2IuYnVmKTsKCXJldHVybiByZXR2YWw7Cn0KCmludCBnZXRfc2hhMV9tYihjb25zdCBjaGFyICpuYW1lLCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglzdHJ1Y3QgY29tbWl0ICpvbmUsICp0d287CglzdHJ1Y3QgY29tbWl0X2xpc3QgKm1iczsKCXVuc2lnbmVkIGNoYXIgc2hhMV90bXBbMjBdOwoJY29uc3QgY2hhciAqZG90czsKCWludCBzdDsKCglkb3RzID0gc3Ryc3RyKG5hbWUsICIuLi4iKTsKCWlmICghZG90cykKCQlyZXR1cm4gZ2V0X3NoYTEobmFtZSwgc2hhMSk7CglpZiAoZG90cyA9PSBuYW1lKQoJCXN0ID0gZ2V0X3NoYTEoIkhFQUQiLCBzaGExX3RtcCk7CgllbHNlIHsKCQlzdHJ1Y3Qgc3RyYnVmIHNiOwoJCXN0cmJ1Zl9pbml0KCZzYiwgZG90cyAtIG5hbWUpOwoJCXN0cmJ1Zl9hZGQoJnNiLCBuYW1lLCBkb3RzIC0gbmFtZSk7CgkJc3QgPSBnZXRfc2hhMV9jb21taXR0aXNoKHNiLmJ1Ziwgc2hhMV90bXApOwoJCXN0cmJ1Zl9yZWxlYXNlKCZzYik7Cgl9CglpZiAoc3QpCgkJcmV0dXJuIHN0OwoJb25lID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfZ2VudGx5KHNoYTFfdG1wLCAwKTsKCWlmICghb25lKQoJCXJldHVybiAtMTsKCglpZiAoZ2V0X3NoYTFfY29tbWl0dGlzaChkb3RzWzNdID8gKGRvdHMgKyAzKSA6ICJIRUFEIiwgc2hhMV90bXApKQoJCXJldHVybiAtMTsKCXR3byA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseShzaGExX3RtcCwgMCk7CglpZiAoIXR3bykKCQlyZXR1cm4gLTE7CgltYnMgPSBnZXRfbWVyZ2VfYmFzZXMob25lLCB0d28sIDEpOwoJaWYgKCFtYnMgfHwgbWJzLT5uZXh0KQoJCXN0ID0gLTE7CgllbHNlIHsKCQlzdCA9IDA7CgkJaGFzaGNweShzaGExLCBtYnMtPml0ZW0tPm9iamVjdC5zaGExKTsKCX0KCWZyZWVfY29tbWl0X2xpc3QobWJzKTsKCXJldHVybiBzdDsKfQoKLyoKICogVGhpcyByZWFkcyBzaG9ydC1oYW5kIHN5bnRheCB0aGF0IG5vdCBvbmx5IGV2YWx1YXRlcyB0byBhIGNvbW1pdAogKiBvYmplY3QgbmFtZSwgYnV0IGFsc28gY2FuIGFjdCBhcyBpZiB0aGUgZW5kIHVzZXIgc3BlbGxlZCB0aGUgbmFtZQogKiBvZiB0aGUgYnJhbmNoIGZyb20gdGhlIGNvbW1hbmQgbGluZS4KICoKICogLSAiQHstTn0iIGZpbmRzIHRoZSBuYW1lIG9mIHRoZSBOdGggcHJldmlvdXMgYnJhbmNoIHdlIHdlcmUgb24sIGFuZAogKiAgIHBsYWNlcyB0aGUgbmFtZSBvZiB0aGUgYnJhbmNoIGluIHRoZSBnaXZlbiBidWYgYW5kIHJldHVybnMgdGhlCiAqICAgbnVtYmVyIG9mIGNoYXJhY3RlcnMgcGFyc2VkIGlmIHN1Y2Nlc3NmdWwuCiAqCiAqIC0gIjxicmFuY2g+QHt1cHN0cmVhbX0iIGZpbmRzIHRoZSBuYW1lIG9mIHRoZSBvdGhlciByZWYgdGhhdAogKiAgIDxicmFuY2g+IGlzIGNvbmZpZ3VyZWQgdG8gbWVyZ2Ugd2l0aCAobWlzc2luZyA8YnJhbmNoPiBkZWZhdWx0cwogKiAgIHRvIHRoZSBjdXJyZW50IGJyYW5jaCksIGFuZCBwbGFjZXMgdGhlIG5hbWUgb2YgdGhlIGJyYW5jaCBpbiB0aGUKICogICBnaXZlbiBidWYgYW5kIHJldHVybnMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHBhcnNlZCBpZgogKiAgIHN1Y2Nlc3NmdWwuCiAqCiAqIElmIHRoZSBpbnB1dCBpcyBub3Qgb2YgdGhlIGFjY2VwdGVkIGZvcm1hdCwgaXQgcmV0dXJucyBhIG5lZ2F0aXZlCiAqIG51bWJlciB0byBzaWduYWwgYW4gZXJyb3IuCiAqCiAqIElmIHRoZSBpbnB1dCB3YXMgb2sgYnV0IHRoZXJlIGFyZSBub3QgTiBicmFuY2ggc3dpdGNoZXMgaW4gdGhlCiAqIHJlZmxvZywgaXQgcmV0dXJucyAwLgogKi8KaW50IGludGVycHJldF9icmFuY2hfbmFtZShjb25zdCBjaGFyICpuYW1lLCBzdHJ1Y3Qgc3RyYnVmICpidWYpCnsKCWNoYXIgKmNwOwoJc3RydWN0IGJyYW5jaCAqdXBzdHJlYW07CglpbnQgbmFtZWxlbiA9IHN0cmxlbihuYW1lKTsKCWludCBsZW4gPSBpbnRlcnByZXRfbnRoX3ByaW9yX2NoZWNrb3V0KG5hbWUsIGJ1Zik7CglpbnQgdG1wX2xlbjsKCglpZiAoIWxlbikKCQlyZXR1cm4gbGVuOyAvKiBzeW50YXggT2ssIG5vdCBlbm91Z2ggc3dpdGNoZXMgKi8KCWlmICgwIDwgbGVuICYmIGxlbiA9PSBuYW1lbGVuKQoJCXJldHVybiBsZW47IC8qIGNvbnN1bWVkIGFsbCAqLwoJZWxzZSBpZiAoMCA8IGxlbikgewoJCS8qIHdlIGhhdmUgZXh0cmEgZGF0YSwgd2hpY2ggbWlnaHQgbmVlZCBmdXJ0aGVyIHByb2Nlc3NpbmcgKi8KCQlzdHJ1Y3Qgc3RyYnVmIHRtcCA9IFNUUkJVRl9JTklUOwoJCWludCB1c2VkID0gYnVmLT5sZW47CgkJaW50IHJldDsKCgkJc3RyYnVmX2FkZChidWYsIG5hbWUgKyBsZW4sIG5hbWVsZW4gLSBsZW4pOwoJCXJldCA9IGludGVycHJldF9icmFuY2hfbmFtZShidWYtPmJ1ZiwgJnRtcCk7CgkJLyogdGhhdCBkYXRhIHdhcyBub3QgaW50ZXJwcmV0ZWQsIHJlbW92ZSBvdXIgY3J1ZnQgKi8KCQlpZiAocmV0IDwgMCkgewoJCQlzdHJidWZfc2V0bGVuKGJ1ZiwgdXNlZCk7CgkJCXJldHVybiBsZW47CgkJfQoJCXN0cmJ1Zl9yZXNldChidWYpOwoJCXN0cmJ1Zl9hZGRidWYoYnVmLCAmdG1wKTsKCQlzdHJidWZfcmVsZWFzZSgmdG1wKTsKCQkvKiB0d2VhayBmb3Igc2l6ZSBvZiB7LU59IHZlcnN1cyBleHBhbmRlZCByZWYgbmFtZSAqLwoJCXJldHVybiByZXQgLSB1c2VkICsgbGVuOwoJfQoKCWNwID0gc3RyY2hyKG5hbWUsICdAJyk7CglpZiAoIWNwKQoJCXJldHVybiAtMTsKCXRtcF9sZW4gPSB1cHN0cmVhbV9tYXJrKGNwLCBuYW1lbGVuIC0gKGNwIC0gbmFtZSkpOwoJaWYgKCF0bXBfbGVuKQoJCXJldHVybiAtMTsKCWxlbiA9IGNwICsgdG1wX2xlbiAtIG5hbWU7CgljcCA9IHhzdHJuZHVwKG5hbWUsIGNwIC0gbmFtZSk7Cgl1cHN0cmVhbSA9IGJyYW5jaF9nZXQoKmNwID8gY3AgOiBOVUxMKTsKCS8qCgkgKiBVcHN0cmVhbSBjYW4gYmUgTlVMTCBvbmx5IGlmIGNwIHJlZmVycyB0byBIRUFEIGFuZCBIRUFECgkgKiBwb2ludHMgdG8gc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIGEgYnJhbmNoLgoJICovCglpZiAoIXVwc3RyZWFtKQoJCWRpZShfKCJIRUFEIGRvZXMgbm90IHBvaW50IHRvIGEgYnJhbmNoIikpOwoJaWYgKCF1cHN0cmVhbS0+bWVyZ2UgfHwgIXVwc3RyZWFtLT5tZXJnZVswXS0+ZHN0KSB7CgkJaWYgKCFyZWZfZXhpc3RzKHVwc3RyZWFtLT5yZWZuYW1lKSkKCQkJZGllKF8oIk5vIHN1Y2ggYnJhbmNoOiAnJXMnIiksIGNwKTsKCQlpZiAoIXVwc3RyZWFtLT5tZXJnZSkgewoJCQlkaWUoXygiTm8gdXBzdHJlYW0gY29uZmlndXJlZCBmb3IgYnJhbmNoICclcyciKSwKCQkJCXVwc3RyZWFtLT5uYW1lKTsKCQl9CgkJZGllKAoJCQlfKCJVcHN0cmVhbSBicmFuY2ggJyVzJyBub3Qgc3RvcmVkIGFzIGEgcmVtb3RlLXRyYWNraW5nIGJyYW5jaCIpLAoJCQl1cHN0cmVhbS0+bWVyZ2VbMF0tPnNyYyk7Cgl9CglmcmVlKGNwKTsKCWNwID0gc2hvcnRlbl91bmFtYmlndW91c19yZWYodXBzdHJlYW0tPm1lcmdlWzBdLT5kc3QsIDApOwoJc3RyYnVmX3Jlc2V0KGJ1Zik7CglzdHJidWZfYWRkc3RyKGJ1ZiwgY3ApOwoJZnJlZShjcCk7CglyZXR1cm4gbGVuOwp9CgppbnQgc3RyYnVmX2JyYW5jaG5hbWUoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKm5hbWUpCnsKCWludCBsZW4gPSBzdHJsZW4obmFtZSk7CglpbnQgdXNlZCA9IGludGVycHJldF9icmFuY2hfbmFtZShuYW1lLCBzYik7CgoJaWYgKHVzZWQgPT0gbGVuKQoJCXJldHVybiAwOwoJaWYgKHVzZWQgPCAwKQoJCXVzZWQgPSAwOwoJc3RyYnVmX2FkZChzYiwgbmFtZSArIHVzZWQsIGxlbiAtIHVzZWQpOwoJcmV0dXJuIGxlbjsKfQoKaW50IHN0cmJ1Zl9jaGVja19icmFuY2hfcmVmKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpuYW1lKQp7CglzdHJidWZfYnJhbmNobmFtZShzYiwgbmFtZSk7CglpZiAobmFtZVswXSA9PSAnLScpCgkJcmV0dXJuIC0xOwoJc3RyYnVmX3NwbGljZShzYiwgMCwgMCwgInJlZnMvaGVhZHMvIiwgMTEpOwoJcmV0dXJuIGNoZWNrX3JlZm5hbWVfZm9ybWF0KHNiLT5idWYsIDApOwp9CgovKgogKiBUaGlzIGlzIGxpa2UgImdldF9zaGExX2Jhc2ljKCkiLCBleGNlcHQgaXQgYWxsb3dzICJzaGExIGV4cHJlc3Npb25zIiwKICogbm90YWJseSAieHl6XiIgZm9yICJwYXJlbnQgb2YgeHl6IgogKi8KaW50IGdldF9zaGExKGNvbnN0IGNoYXIgKm5hbWUsIHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXN0cnVjdCBvYmplY3RfY29udGV4dCB1bnVzZWQ7CglyZXR1cm4gZ2V0X3NoYTFfd2l0aF9jb250ZXh0KG5hbWUsIDAsIHNoYTEsICZ1bnVzZWQpOwp9CgovKgogKiBNYW55IGNhbGxlcnMga25vdyB0aGF0IHRoZSB1c2VyIG1lYW50IHRvIG5hbWUgYSBjb21taXR0aXNoIGJ5CiAqIHN5bnRhY3RpY2FsIHBvc2l0aW9ucyB3aGVyZSB0aGUgb2JqZWN0IG5hbWUgYXBwZWFycy4gIENhbGxpbmcgdGhpcwogKiBmdW5jdGlvbiBhbGxvd3MgdGhlIG1hY2hpbmVyeSB0byBkaXNhbWJpZ3VhdGUgc2hvcnRlci10aGFuLXVuaXF1ZQogKiBhYmJyZXZpYXRlZCBvYmplY3QgbmFtZXMgYmV0d2VlbiBjb21taXR0aXNoIGFuZCBvdGhlcnMuCiAqCiAqIE5vdGUgdGhhdCB0aGlzIGRvZXMgTk9UIGVycm9yIG91dCB3aGVuIHRoZSBuYW1lZCBvYmplY3QgaXMgbm90IGEKICogY29tbWl0dGlzaC4gSXQgaXMgbWVyZWx5IHRvIGdpdmUgYSBoaW50IHRvIHRoZSBkaXNhbWJpZ3VhdGlvbgogKiBtYWNoaW5lcnkuCiAqLwppbnQgZ2V0X3NoYTFfY29tbWl0dGlzaChjb25zdCBjaGFyICpuYW1lLCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglzdHJ1Y3Qgb2JqZWN0X2NvbnRleHQgdW51c2VkOwoJcmV0dXJuIGdldF9zaGExX3dpdGhfY29udGV4dChuYW1lLCBHRVRfU0hBMV9DT01NSVRUSVNILAoJCQkJICAgICBzaGExLCAmdW51c2VkKTsKfQoKaW50IGdldF9zaGExX3RyZWVpc2goY29uc3QgY2hhciAqbmFtZSwgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJc3RydWN0IG9iamVjdF9jb250ZXh0IHVudXNlZDsKCXJldHVybiBnZXRfc2hhMV93aXRoX2NvbnRleHQobmFtZSwgR0VUX1NIQTFfVFJFRUlTSCwKCQkJCSAgICAgc2hhMSwgJnVudXNlZCk7Cn0KCmludCBnZXRfc2hhMV9jb21taXQoY29uc3QgY2hhciAqbmFtZSwgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJc3RydWN0IG9iamVjdF9jb250ZXh0IHVudXNlZDsKCXJldHVybiBnZXRfc2hhMV93aXRoX2NvbnRleHQobmFtZSwgR0VUX1NIQTFfQ09NTUlULAoJCQkJICAgICBzaGExLCAmdW51c2VkKTsKfQoKaW50IGdldF9zaGExX3RyZWUoY29uc3QgY2hhciAqbmFtZSwgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJc3RydWN0IG9iamVjdF9jb250ZXh0IHVudXNlZDsKCXJldHVybiBnZXRfc2hhMV93aXRoX2NvbnRleHQobmFtZSwgR0VUX1NIQTFfVFJFRSwKCQkJCSAgICAgc2hhMSwgJnVudXNlZCk7Cn0KCmludCBnZXRfc2hhMV9ibG9iKGNvbnN0IGNoYXIgKm5hbWUsIHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXN0cnVjdCBvYmplY3RfY29udGV4dCB1bnVzZWQ7CglyZXR1cm4gZ2V0X3NoYTFfd2l0aF9jb250ZXh0KG5hbWUsIEdFVF9TSEExX0JMT0IsCgkJCQkgICAgIHNoYTEsICZ1bnVzZWQpOwp9CgovKiBNdXN0IGJlIGNhbGxlZCBvbmx5IHdoZW4gb2JqZWN0X25hbWU6ZmlsZW5hbWUgZG9lc24ndCBleGlzdC4gKi8Kc3RhdGljIHZvaWQgZGlhZ25vc2VfaW52YWxpZF9zaGExX3BhdGgoY29uc3QgY2hhciAqcHJlZml4LAoJCQkJICAgICAgIGNvbnN0IGNoYXIgKmZpbGVuYW1lLAoJCQkJICAgICAgIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnRyZWVfc2hhMSwKCQkJCSAgICAgICBjb25zdCBjaGFyICpvYmplY3RfbmFtZSwKCQkJCSAgICAgICBpbnQgb2JqZWN0X25hbWVfbGVuKQp7CglzdHJ1Y3Qgc3RhdCBzdDsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07Cgl1bnNpZ25lZCBtb2RlOwoKCWlmICghcHJlZml4KQoJCXByZWZpeCA9ICIiOwoKCWlmICghbHN0YXQoZmlsZW5hbWUsICZzdCkpCgkJZGllKCJQYXRoICclcycgZXhpc3RzIG9uIGRpc2ssIGJ1dCBub3QgaW4gJyUuKnMnLiIsCgkJICAgIGZpbGVuYW1lLCBvYmplY3RfbmFtZV9sZW4sIG9iamVjdF9uYW1lKTsKCWlmIChlcnJubyA9PSBFTk9FTlQgfHwgZXJybm8gPT0gRU5PVERJUikgewoJCWNoYXIgKmZ1bGxuYW1lID0geG1hbGxvYyhzdHJsZW4oZmlsZW5hbWUpCgkJCQkJICAgICArIHN0cmxlbihwcmVmaXgpICsgMSk7CgkJc3RyY3B5KGZ1bGxuYW1lLCBwcmVmaXgpOwoJCXN0cmNhdChmdWxsbmFtZSwgZmlsZW5hbWUpOwoKCQlpZiAoIWdldF90cmVlX2VudHJ5KHRyZWVfc2hhMSwgZnVsbG5hbWUsCgkJCQkgICAgc2hhMSwgJm1vZGUpKSB7CgkJCWRpZSgiUGF0aCAnJXMnIGV4aXN0cywgYnV0IG5vdCAnJXMnLlxuIgoJCQkgICAgIkRpZCB5b3UgbWVhbiAnJS4qczolcycgYWthICclLipzOi4vJXMnPyIsCgkJCSAgICBmdWxsbmFtZSwKCQkJICAgIGZpbGVuYW1lLAoJCQkgICAgb2JqZWN0X25hbWVfbGVuLCBvYmplY3RfbmFtZSwKCQkJICAgIGZ1bGxuYW1lLAoJCQkgICAgb2JqZWN0X25hbWVfbGVuLCBvYmplY3RfbmFtZSwKCQkJICAgIGZpbGVuYW1lKTsKCQl9CgkJZGllKCJQYXRoICclcycgZG9lcyBub3QgZXhpc3QgaW4gJyUuKnMnIiwKCQkgICAgZmlsZW5hbWUsIG9iamVjdF9uYW1lX2xlbiwgb2JqZWN0X25hbWUpOwoJfQp9CgovKiBNdXN0IGJlIGNhbGxlZCBvbmx5IHdoZW4gOnN0YWdlOmZpbGVuYW1lIGRvZXNuJ3QgZXhpc3QuICovCnN0YXRpYyB2b2lkIGRpYWdub3NlX2ludmFsaWRfaW5kZXhfcGF0aChpbnQgc3RhZ2UsCgkJCQkJY29uc3QgY2hhciAqcHJlZml4LAoJCQkJCWNvbnN0IGNoYXIgKmZpbGVuYW1lKQp7CglzdHJ1Y3Qgc3RhdCBzdDsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2U7CglpbnQgcG9zOwoJdW5zaWduZWQgbmFtZWxlbiA9IHN0cmxlbihmaWxlbmFtZSk7Cgl1bnNpZ25lZCBmdWxsbmFtZWxlbjsKCWNoYXIgKmZ1bGxuYW1lOwoKCWlmICghcHJlZml4KQoJCXByZWZpeCA9ICIiOwoKCS8qIFdyb25nIHN0YWdlIG51bWJlcj8gKi8KCXBvcyA9IGNhY2hlX25hbWVfcG9zKGZpbGVuYW1lLCBuYW1lbGVuKTsKCWlmIChwb3MgPCAwKQoJCXBvcyA9IC1wb3MgLSAxOwoJaWYgKHBvcyA8IGFjdGl2ZV9ucikgewoJCWNlID0gYWN0aXZlX2NhY2hlW3Bvc107CgkJaWYgKGNlX25hbWVsZW4oY2UpID09IG5hbWVsZW4gJiYKCQkgICAgIW1lbWNtcChjZS0+bmFtZSwgZmlsZW5hbWUsIG5hbWVsZW4pKQoJCQlkaWUoIlBhdGggJyVzJyBpcyBpbiB0aGUgaW5kZXgsIGJ1dCBub3QgYXQgc3RhZ2UgJWQuXG4iCgkJCSAgICAiRGlkIHlvdSBtZWFuICc6JWQ6JXMnPyIsCgkJCSAgICBmaWxlbmFtZSwgc3RhZ2UsCgkJCSAgICBjZV9zdGFnZShjZSksIGZpbGVuYW1lKTsKCX0KCgkvKiBDb25mdXNpb24gYmV0d2VlbiByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgZmlsZW5hbWVzPyAqLwoJZnVsbG5hbWVsZW4gPSBuYW1lbGVuICsgc3RybGVuKHByZWZpeCk7CglmdWxsbmFtZSA9IHhtYWxsb2MoZnVsbG5hbWVsZW4gKyAxKTsKCXN0cmNweShmdWxsbmFtZSwgcHJlZml4KTsKCXN0cmNhdChmdWxsbmFtZSwgZmlsZW5hbWUpOwoJcG9zID0gY2FjaGVfbmFtZV9wb3MoZnVsbG5hbWUsIGZ1bGxuYW1lbGVuKTsKCWlmIChwb3MgPCAwKQoJCXBvcyA9IC1wb3MgLSAxOwoJaWYgKHBvcyA8IGFjdGl2ZV9ucikgewoJCWNlID0gYWN0aXZlX2NhY2hlW3Bvc107CgkJaWYgKGNlX25hbWVsZW4oY2UpID09IGZ1bGxuYW1lbGVuICYmCgkJICAgICFtZW1jbXAoY2UtPm5hbWUsIGZ1bGxuYW1lLCBmdWxsbmFtZWxlbikpCgkJCWRpZSgiUGF0aCAnJXMnIGlzIGluIHRoZSBpbmRleCwgYnV0IG5vdCAnJXMnLlxuIgoJCQkgICAgIkRpZCB5b3UgbWVhbiAnOiVkOiVzJyBha2EgJzolZDouLyVzJz8iLAoJCQkgICAgZnVsbG5hbWUsIGZpbGVuYW1lLAoJCQkgICAgY2Vfc3RhZ2UoY2UpLCBmdWxsbmFtZSwKCQkJICAgIGNlX3N0YWdlKGNlKSwgZmlsZW5hbWUpOwoJfQoKCWlmICghbHN0YXQoZmlsZW5hbWUsICZzdCkpCgkJZGllKCJQYXRoICclcycgZXhpc3RzIG9uIGRpc2ssIGJ1dCBub3QgaW4gdGhlIGluZGV4LiIsIGZpbGVuYW1lKTsKCWlmIChlcnJubyA9PSBFTk9FTlQgfHwgZXJybm8gPT0gRU5PVERJUikKCQlkaWUoIlBhdGggJyVzJyBkb2VzIG5vdCBleGlzdCAobmVpdGhlciBvbiBkaXNrIG5vciBpbiB0aGUgaW5kZXgpLiIsCgkJICAgIGZpbGVuYW1lKTsKCglmcmVlKGZ1bGxuYW1lKTsKfQoKCnN0YXRpYyBjaGFyICpyZXNvbHZlX3JlbGF0aXZlX3BhdGgoY29uc3QgY2hhciAqcmVsKQp7CglpZiAocHJlZml4Y21wKHJlbCwgIi4vIikgJiYgcHJlZml4Y21wKHJlbCwgIi4uLyIpKQoJCXJldHVybiBOVUxMOwoKCWlmICghc3RhcnR1cF9pbmZvKQoJCWRpZSgiQlVHOiBzdGFydHVwX2luZm8gc3RydWN0IGlzIG5vdCBpbml0aWFsaXplZC4iKTsKCglpZiAoIWlzX2luc2lkZV93b3JrX3RyZWUoKSkKCQlkaWUoInJlbGF0aXZlIHBhdGggc3ludGF4IGNhbid0IGJlIHVzZWQgb3V0c2lkZSB3b3JraW5nIHRyZWUuIik7CgoJLyogZGllKCkgaW5zaWRlIHByZWZpeF9wYXRoKCkgaWYgcmVzb2x2ZWQgcGF0aCBpcyBvdXRzaWRlIHdvcmt0cmVlICovCglyZXR1cm4gcHJlZml4X3BhdGgoc3RhcnR1cF9pbmZvLT5wcmVmaXgsCgkJCSAgIHN0YXJ0dXBfaW5mby0+cHJlZml4ID8gc3RybGVuKHN0YXJ0dXBfaW5mby0+cHJlZml4KSA6IDAsCgkJCSAgIHJlbCk7Cn0KCnN0YXRpYyBpbnQgZ2V0X3NoYTFfd2l0aF9jb250ZXh0XzEoY29uc3QgY2hhciAqbmFtZSwKCQkJCSAgIHVuc2lnbmVkIGZsYWdzLAoJCQkJICAgY29uc3QgY2hhciAqcHJlZml4LAoJCQkJICAgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkJCSAgIHN0cnVjdCBvYmplY3RfY29udGV4dCAqb2MpCnsKCWludCByZXQsIGJyYWNrZXRfZGVwdGg7CglpbnQgbmFtZWxlbiA9IHN0cmxlbihuYW1lKTsKCWNvbnN0IGNoYXIgKmNwOwoJaW50IG9ubHlfdG9fZGllID0gZmxhZ3MgJiBHRVRfU0hBMV9PTkxZX1RPX0RJRTsKCgltZW1zZXQob2MsIDAsIHNpemVvZigqb2MpKTsKCW9jLT5tb2RlID0gU19JRklOVkFMSUQ7CglyZXQgPSBnZXRfc2hhMV8xKG5hbWUsIG5hbWVsZW4sIHNoYTEsIGZsYWdzKTsKCWlmICghcmV0KQoJCXJldHVybiByZXQ7CgkvKgoJICogc2hhMTpwYXRoIC0tPiBvYmplY3QgbmFtZSBvZiBwYXRoIGluIGVudCBzaGExCgkgKiA6cGF0aCAtPiBvYmplY3QgbmFtZSBvZiBhYnNvbHV0ZSBwYXRoIGluIGluZGV4CgkgKiA6Li9wYXRoIC0+IG9iamVjdCBuYW1lIG9mIHBhdGggcmVsYXRpdmUgdG8gY3dkIGluIGluZGV4CgkgKiA6WzAtM106cGF0aCAtPiBvYmplY3QgbmFtZSBvZiBwYXRoIGluIGluZGV4IGF0IHN0YWdlCgkgKiA6L2ZvbyAtPiByZWNlbnQgY29tbWl0IG1hdGNoaW5nIGZvbwoJICovCglpZiAobmFtZVswXSA9PSAnOicpIHsKCQlpbnQgc3RhZ2UgPSAwOwoJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2U7CgkJY2hhciAqbmV3X3BhdGggPSBOVUxMOwoJCWludCBwb3M7CgkJaWYgKCFvbmx5X3RvX2RpZSAmJiBuYW1lbGVuID4gMiAmJiBuYW1lWzFdID09ICcvJykgewoJCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QgPSBOVUxMOwoJCQlmb3JfZWFjaF9yZWYoaGFuZGxlX29uZV9yZWYsICZsaXN0KTsKCQkJcmV0dXJuIGdldF9zaGExX29uZWxpbmUobmFtZSArIDIsIHNoYTEsIGxpc3QpOwoJCX0KCQlpZiAobmFtZWxlbiA8IDMgfHwKCQkgICAgbmFtZVsyXSAhPSAnOicgfHwKCQkgICAgbmFtZVsxXSA8ICcwJyB8fCAnMycgPCBuYW1lWzFdKQoJCQljcCA9IG5hbWUgKyAxOwoJCWVsc2UgewoJCQlzdGFnZSA9IG5hbWVbMV0gLSAnMCc7CgkJCWNwID0gbmFtZSArIDM7CgkJfQoJCW5ld19wYXRoID0gcmVzb2x2ZV9yZWxhdGl2ZV9wYXRoKGNwKTsKCQlpZiAoIW5ld19wYXRoKSB7CgkJCW5hbWVsZW4gPSBuYW1lbGVuIC0gKGNwIC0gbmFtZSk7CgkJfSBlbHNlIHsKCQkJY3AgPSBuZXdfcGF0aDsKCQkJbmFtZWxlbiA9IHN0cmxlbihjcCk7CgkJfQoKCQlzdHJuY3B5KG9jLT5wYXRoLCBjcCwKCQkJc2l6ZW9mKG9jLT5wYXRoKSk7CgkJb2MtPnBhdGhbc2l6ZW9mKG9jLT5wYXRoKS0xXSA9ICdcMCc7CgoJCWlmICghYWN0aXZlX2NhY2hlKQoJCQlyZWFkX2NhY2hlKCk7CgkJcG9zID0gY2FjaGVfbmFtZV9wb3MoY3AsIG5hbWVsZW4pOwoJCWlmIChwb3MgPCAwKQoJCQlwb3MgPSAtcG9zIC0gMTsKCQl3aGlsZSAocG9zIDwgYWN0aXZlX25yKSB7CgkJCWNlID0gYWN0aXZlX2NhY2hlW3Bvc107CgkJCWlmIChjZV9uYW1lbGVuKGNlKSAhPSBuYW1lbGVuIHx8CgkJCSAgICBtZW1jbXAoY2UtPm5hbWUsIGNwLCBuYW1lbGVuKSkKCQkJCWJyZWFrOwoJCQlpZiAoY2Vfc3RhZ2UoY2UpID09IHN0YWdlKSB7CgkJCQloYXNoY3B5KHNoYTEsIGNlLT5zaGExKTsKCQkJCW9jLT5tb2RlID0gY2UtPmNlX21vZGU7CgkJCQlmcmVlKG5ld19wYXRoKTsKCQkJCXJldHVybiAwOwoJCQl9CgkJCXBvcysrOwoJCX0KCQlpZiAob25seV90b19kaWUgJiYgbmFtZVsxXSAmJiBuYW1lWzFdICE9ICcvJykKCQkJZGlhZ25vc2VfaW52YWxpZF9pbmRleF9wYXRoKHN0YWdlLCBwcmVmaXgsIGNwKTsKCQlmcmVlKG5ld19wYXRoKTsKCQlyZXR1cm4gLTE7Cgl9Cglmb3IgKGNwID0gbmFtZSwgYnJhY2tldF9kZXB0aCA9IDA7ICpjcDsgY3ArKykgewoJCWlmICgqY3AgPT0gJ3snKQoJCQlicmFja2V0X2RlcHRoKys7CgkJZWxzZSBpZiAoYnJhY2tldF9kZXB0aCAmJiAqY3AgPT0gJ30nKQoJCQlicmFja2V0X2RlcHRoLS07CgkJZWxzZSBpZiAoIWJyYWNrZXRfZGVwdGggJiYgKmNwID09ICc6JykKCQkJYnJlYWs7Cgl9CglpZiAoKmNwID09ICc6JykgewoJCXVuc2lnbmVkIGNoYXIgdHJlZV9zaGExWzIwXTsKCQlpbnQgbGVuID0gY3AgLSBuYW1lOwoJCWlmICghZ2V0X3NoYTFfMShuYW1lLCBsZW4sIHRyZWVfc2hhMSwgR0VUX1NIQTFfVFJFRUlTSCkpIHsKCQkJY29uc3QgY2hhciAqZmlsZW5hbWUgPSBjcCsxOwoJCQljaGFyICpuZXdfZmlsZW5hbWUgPSBOVUxMOwoKCQkJbmV3X2ZpbGVuYW1lID0gcmVzb2x2ZV9yZWxhdGl2ZV9wYXRoKGZpbGVuYW1lKTsKCQkJaWYgKG5ld19maWxlbmFtZSkKCQkJCWZpbGVuYW1lID0gbmV3X2ZpbGVuYW1lOwoJCQlyZXQgPSBnZXRfdHJlZV9lbnRyeSh0cmVlX3NoYTEsIGZpbGVuYW1lLCBzaGExLCAmb2MtPm1vZGUpOwoJCQlpZiAocmV0ICYmIG9ubHlfdG9fZGllKSB7CgkJCQlkaWFnbm9zZV9pbnZhbGlkX3NoYTFfcGF0aChwcmVmaXgsIGZpbGVuYW1lLAoJCQkJCQkJICAgdHJlZV9zaGExLAoJCQkJCQkJICAgbmFtZSwgbGVuKTsKCQkJfQoJCQloYXNoY3B5KG9jLT50cmVlLCB0cmVlX3NoYTEpOwoJCQlzdHJuY3B5KG9jLT5wYXRoLCBmaWxlbmFtZSwKCQkJCXNpemVvZihvYy0+cGF0aCkpOwoJCQlvYy0+cGF0aFtzaXplb2Yob2MtPnBhdGgpLTFdID0gJ1wwJzsKCgkJCWZyZWUobmV3X2ZpbGVuYW1lKTsKCQkJcmV0dXJuIHJldDsKCQl9IGVsc2UgewoJCQlpZiAob25seV90b19kaWUpCgkJCQlkaWUoIkludmFsaWQgb2JqZWN0IG5hbWUgJyUuKnMnLiIsIGxlbiwgbmFtZSk7CgkJfQoJfQoJcmV0dXJuIHJldDsKfQoKLyoKICogQ2FsbCB0aGlzIGZ1bmN0aW9uIHdoZW4geW91IGtub3cgIm5hbWUiIGdpdmVuIGJ5IHRoZSBlbmQgdXNlciBtdXN0CiAqIG5hbWUgYW4gb2JqZWN0IGJ1dCBpdCBkb2Vzbid0OyB0aGUgZnVuY3Rpb24gX21heV8gZGllIHdpdGggYSBiZXR0ZXIKICogZGlhZ25vc3RpYyBtZXNzYWdlIHRoYW4gIm5vIHN1Y2ggb2JqZWN0ICduYW1lJyIsIGUuZy4gIlBhdGggJ2RvYycgZG9lcyBub3QKICogZXhpc3QgaW4gJ0hFQUQnIiB3aGVuIGdpdmVuICJIRUFEOmRvYyIsIG9yIGl0IG1heSByZXR1cm4gaW4gd2hpY2ggY2FzZQogKiB5b3UgaGF2ZSBhIGNoYW5jZSB0byBkaWFnbm9zZSB0aGUgZXJyb3IgZnVydGhlci4KICovCnZvaWQgbWF5YmVfZGllX29uX21pc3NwZWx0X29iamVjdF9uYW1lKGNvbnN0IGNoYXIgKm5hbWUsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IG9iamVjdF9jb250ZXh0IG9jOwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCWdldF9zaGExX3dpdGhfY29udGV4dF8xKG5hbWUsIEdFVF9TSEExX09OTFlfVE9fRElFLCBwcmVmaXgsIHNoYTEsICZvYyk7Cn0KCmludCBnZXRfc2hhMV93aXRoX2NvbnRleHQoY29uc3QgY2hhciAqc3RyLCB1bnNpZ25lZCBmbGFncywgdW5zaWduZWQgY2hhciAqc2hhMSwgc3RydWN0IG9iamVjdF9jb250ZXh0ICpvcmMpCnsKCXJldHVybiBnZXRfc2hhMV93aXRoX2NvbnRleHRfMShzdHIsIGZsYWdzLCBOVUxMLCBzaGExLCBvcmMpOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"tree.h\"\n#include \"blob.h\"\n#include \"tree-walk.h\"\n#include \"refs.h\"\n#include \"remote.h\"\n\nstatic int get_sha1_oneline(const char *, unsigned char *, struct commit_list *);\n\ntypedef int (*disambiguate_hint_fn)(const unsigned char *, void *);\n\nstruct disambiguate_state {\n\tdisambiguate_hint_fn fn;\n\tvoid *cb_data;\n\tunsigned char candidate[20];\n\tunsigned candidate_exists:1;\n\tunsigned candidate_checked:1;\n\tunsigned candidate_ok:1;\n\tunsigned disambiguate_fn_used:1;\n\tunsigned ambiguous:1;\n\tunsigned always_call_fn:1;\n};\n\nstatic void update_candidates(struct disambiguate_state *ds, const unsigned char *current)\n{\n\tif (ds->always_call_fn) {\n\t\tds->ambiguous = ds->fn(current, ds->cb_data) ? 1 : 0;\n\t\treturn;\n\t}\n\tif (!ds->candidate_exists) {\n\t\t/* this is the first candidate */\n\t\thashcpy(ds->candidate, current);\n\t\tds->candidate_exists = 1;\n\t\treturn;\n\t} else if (!hashcmp(ds->candidate, current)) {\n\t\t/* the same as what we already have seen */\n\t\treturn;\n\t}\n\n\tif (!ds->fn) {\n\t\t/* cannot disambiguate between ds->candidate and current */\n\t\tds->ambiguous = 1;\n\t\treturn;\n\t}\n\n\tif (!ds->candidate_checked) {\n\t\tds->candidate_ok = ds->fn(ds->candidate, ds->cb_data);\n\t\tds->disambiguate_fn_used = 1;\n\t\tds->candidate_checked = 1;\n\t}\n\n\tif (!ds->candidate_ok) {\n\t\t/* discard the candidate; we know it does not satisify fn */\n\t\thashcpy(ds->candidate, current);\n\t\tds->candidate_checked = 0;\n\t\treturn;\n\t}\n\n\t/* if we reach this point, we know ds->candidate satisfies fn */\n\tif (ds->fn(current, ds->cb_data)) {\n\t\t/*\n\t\t * if both current and candidate satisfy fn, we cannot\n\t\t * disambiguate.\n\t\t */\n\t\tds->candidate_ok = 0;\n\t\tds->ambiguous = 1;\n\t}\n\n\t/* otherwise, current can be discarded and candidate is still good */\n}\n\nstatic void find_short_object_filename(int len, const char *hex_pfx, struct disambiguate_state *ds)\n{\n\tstruct alternate_object_database *alt;\n\tchar hex[40];\n\tstatic struct alternate_object_database *fakeent;\n\n\tif (!fakeent) {\n\t\t/*\n\t\t * Create a \"fake\" alternate object database that\n\t\t * points to our own object database, to make it\n\t\t * easier to get a temporary working space in\n\t\t * alt->name/alt->base while iterating over the\n\t\t * object databases including our own.\n\t\t */\n\t\tconst char *objdir = get_object_directory();\n\t\tint objdir_len = strlen(objdir);\n\t\tint entlen = objdir_len + 43;\n\t\tfakeent = xmalloc(sizeof(*fakeent) + entlen);\n\t\tmemcpy(fakeent->base, objdir, objdir_len);\n\t\tfakeent->name = fakeent->base + objdir_len + 1;\n\t\tfakeent->name[-1] = '/';\n\t}\n\tfakeent->next = alt_odb_list;\n\n\tsprintf(hex, \"%.2s\", hex_pfx);\n\tfor (alt = fakeent; alt && !ds->ambiguous; alt = alt->next) {\n\t\tstruct dirent *de;\n\t\tDIR *dir;\n\t\tsprintf(alt->name, \"%.2s/\", hex_pfx);\n\t\tdir = opendir(alt->base);\n\t\tif (!dir)\n\t\t\tcontinue;\n\n\t\twhile (!ds->ambiguous && (de = readdir(dir)) != NULL) {\n\t\t\tunsigned char sha1[20];\n\n\t\t\tif (strlen(de->d_name) != 38)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(de->d_name, hex_pfx + 2, len - 2))\n\t\t\t\tcontinue;\n\t\t\tmemcpy(hex + 2, de->d_name, 38);\n\t\t\tif (!get_sha1_hex(hex, sha1))\n\t\t\t\tupdate_candidates(ds, sha1);\n\t\t}\n\t\tclosedir(dir);\n\t}\n}\n\nstatic int match_sha(unsigned len, const unsigned char *a, const unsigned char *b)\n{\n\tdo {\n\t\tif (*a != *b)\n\t\t\treturn 0;\n\t\ta++;\n\t\tb++;\n\t\tlen -= 2;\n\t} while (len > 1);\n\tif (len)\n\t\tif ((*a ^ *b) & 0xf0)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic void unique_in_pack(int len,\n\t\t\t  const unsigned char *bin_pfx,\n\t\t\t   struct packed_git *p,\n\t\t\t   struct disambiguate_state *ds)\n{\n\tuint32_t num, last, i, first = 0;\n\tconst unsigned char *current = NULL;\n\n\topen_pack_index(p);\n\tnum = p->num_objects;\n\tlast = num;\n\twhile (first < last) {\n\t\tuint32_t mid = (first + last) / 2;\n\t\tconst unsigned char *current;\n\t\tint cmp;\n\n\t\tcurrent = nth_packed_object_sha1(p, mid);\n\t\tcmp = hashcmp(bin_pfx, current);\n\t\tif (!cmp) {\n\t\t\tfirst = mid;\n\t\t\tbreak;\n\t\t}\n\t\tif (cmp > 0) {\n\t\t\tfirst = mid+1;\n\t\t\tcontinue;\n\t\t}\n\t\tlast = mid;\n\t}\n\n\t/*\n\t * At this point, \"first\" is the location of the lowest object\n\t * with an object name that could match \"bin_pfx\".  See if we have\n\t * 0, 1 or more objects that actually match(es).\n\t */\n\tfor (i = first; i < num && !ds->ambiguous; i++) {\n\t\tcurrent = nth_packed_object_sha1(p, i);\n\t\tif (!match_sha(len, bin_pfx, current))\n\t\t\tbreak;\n\t\tupdate_candidates(ds, current);\n\t}\n}\n\nstatic void find_short_packed_object(int len, const unsigned char *bin_pfx,\n\t\t\t\t     struct disambiguate_state *ds)\n{\n\tstruct packed_git *p;\n\n\tprepare_packed_git();\n\tfor (p = packed_git; p && !ds->ambiguous; p = p->next)\n\t\tunique_in_pack(len, bin_pfx, p, ds);\n}\n\n#define SHORT_NAME_NOT_FOUND (-1)\n#define SHORT_NAME_AMBIGUOUS (-2)\n\nstatic int finish_object_disambiguation(struct disambiguate_state *ds,\n\t\t\t\t\tunsigned char *sha1)\n{\n\tif (ds->ambiguous)\n\t\treturn SHORT_NAME_AMBIGUOUS;\n\n\tif (!ds->candidate_exists)\n\t\treturn SHORT_NAME_NOT_FOUND;\n\n\tif (!ds->candidate_checked)\n\t\t/*\n\t\t * If this is the only candidate, there is no point\n\t\t * calling the disambiguation hint callback.\n\t\t *\n\t\t * On the other hand, if the current candidate\n\t\t * replaced an earlier candidate that did _not_ pass\n\t\t * the disambiguation hint callback, then we do have\n\t\t * more than one objects that match the short name\n\t\t * given, so we should make sure this one matches;\n\t\t * otherwise, if we discovered this one and the one\n\t\t * that we previously discarded in the reverse order,\n\t\t * we would end up showing different results in the\n\t\t * same repository!\n\t\t */\n\t\tds->candidate_ok = (!ds->disambiguate_fn_used ||\n\t\t\t\t    ds->fn(ds->candidate, ds->cb_data));\n\n\tif (!ds->candidate_ok)\n\t\treturn SHORT_NAME_AMBIGUOUS;\n\n\thashcpy(sha1, ds->candidate);\n\treturn 0;\n}\n\nstatic int disambiguate_commit_only(const unsigned char *sha1, void *cb_data_unused)\n{\n\tint kind = sha1_object_info(sha1, NULL);\n\treturn kind == OBJ_COMMIT;\n}\n\nstatic int disambiguate_committish_only(const unsigned char *sha1, void *cb_data_unused)\n{\n\tstruct object *obj;\n\tint kind;\n\n\tkind = sha1_object_info(sha1, NULL);\n\tif (kind == OBJ_COMMIT)\n\t\treturn 1;\n\tif (kind != OBJ_TAG)\n\t\treturn 0;\n\n\t/* We need to do this the hard way... */\n\tobj = deref_tag(parse_object(sha1), NULL, 0);\n\tif (obj && obj->type == OBJ_COMMIT)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int disambiguate_tree_only(const unsigned char *sha1, void *cb_data_unused)\n{\n\tint kind = sha1_object_info(sha1, NULL);\n\treturn kind == OBJ_TREE;\n}\n\nstatic int disambiguate_treeish_only(const unsigned char *sha1, void *cb_data_unused)\n{\n\tstruct object *obj;\n\tint kind;\n\n\tkind = sha1_object_info(sha1, NULL);\n\tif (kind == OBJ_TREE || kind == OBJ_COMMIT)\n\t\treturn 1;\n\tif (kind != OBJ_TAG)\n\t\treturn 0;\n\n\t/* We need to do this the hard way... */\n\tobj = deref_tag(lookup_object(sha1), NULL, 0);\n\tif (obj && (obj->type == OBJ_TREE || obj->type == OBJ_COMMIT))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int disambiguate_blob_only(const unsigned char *sha1, void *cb_data_unused)\n{\n\tint kind = sha1_object_info(sha1, NULL);\n\treturn kind == OBJ_BLOB;\n}\n\nstatic int prepare_prefixes(const char *name, int len,\n\t\t\t    unsigned char *bin_pfx,\n\t\t\t    char *hex_pfx)\n{\n\tint i;\n\n\thashclr(bin_pfx);\n\tmemset(hex_pfx, 'x', 40);\n\tfor (i = 0; i < len ;i++) {\n\t\tunsigned char c = name[i];\n\t\tunsigned char val;\n\t\tif (c >= '0' && c <= '9')\n\t\t\tval = c - '0';\n\t\telse if (c >= 'a' && c <= 'f')\n\t\t\tval = c - 'a' + 10;\n\t\telse if (c >= 'A' && c <='F') {\n\t\t\tval = c - 'A' + 10;\n\t\t\tc -= 'A' - 'a';\n\t\t}\n\t\telse\n\t\t\treturn -1;\n\t\thex_pfx[i] = c;\n\t\tif (!(i & 1))\n\t\t\tval <<= 4;\n\t\tbin_pfx[i >> 1] |= val;\n\t}\n\treturn 0;\n}\n\nstatic int get_short_sha1(const char *name, int len, unsigned char *sha1,\n\t\t\t  unsigned flags)\n{\n\tint status;\n\tchar hex_pfx[40];\n\tunsigned char bin_pfx[20];\n\tstruct disambiguate_state ds;\n\tint quietly = !!(flags & GET_SHA1_QUIETLY);\n\n\tif (len < MINIMUM_ABBREV || len > 40)\n\t\treturn -1;\n\tif (prepare_prefixes(name, len, bin_pfx, hex_pfx) < 0)\n\t\treturn -1;\n\n\tprepare_alt_odb();\n\n\tmemset(&ds, 0, sizeof(ds));\n\tif (flags & GET_SHA1_COMMIT)\n\t\tds.fn = disambiguate_commit_only;\n\telse if (flags & GET_SHA1_COMMITTISH)\n\t\tds.fn = disambiguate_committish_only;\n\telse if (flags & GET_SHA1_TREE)\n\t\tds.fn = disambiguate_tree_only;\n\telse if (flags & GET_SHA1_TREEISH)\n\t\tds.fn = disambiguate_treeish_only;\n\telse if (flags & GET_SHA1_BLOB)\n\t\tds.fn = disambiguate_blob_only;\n\n\tfind_short_object_filename(len, hex_pfx, &ds);\n\tfind_short_packed_object(len, bin_pfx, &ds);\n\tstatus = finish_object_disambiguation(&ds, sha1);\n\n\tif (!quietly && (status == SHORT_NAME_AMBIGUOUS))\n\t\treturn error(\"short SHA1 %.*s is ambiguous.\", len, hex_pfx);\n\treturn status;\n}\n\n\nint for_each_abbrev(const char *prefix, each_abbrev_fn fn, void *cb_data)\n{\n\tchar hex_pfx[40];\n\tunsigned char bin_pfx[20];\n\tstruct disambiguate_state ds;\n\tint len = strlen(prefix);\n\n\tif (len < MINIMUM_ABBREV || len > 40)\n\t\treturn -1;\n\tif (prepare_prefixes(prefix, len, bin_pfx, hex_pfx) < 0)\n\t\treturn -1;\n\n\tprepare_alt_odb();\n\n\tmemset(&ds, 0, sizeof(ds));\n\tds.always_call_fn = 1;\n\tds.cb_data = cb_data;\n\tds.fn = fn;\n\n\tfind_short_object_filename(len, hex_pfx, &ds);\n\tfind_short_packed_object(len, bin_pfx, &ds);\n\treturn ds.ambiguous;\n}\n\nconst char *find_unique_abbrev(const unsigned char *sha1, int len)\n{\n\tint status, exists;\n\tstatic char hex[41];\n\n\texists = has_sha1_file(sha1);\n\tmemcpy(hex, sha1_to_hex(sha1), 40);\n\tif (len == 40 || !len)\n\t\treturn hex;\n\twhile (len < 40) {\n\t\tunsigned char sha1_ret[20];\n\t\tstatus = get_short_sha1(hex, len, sha1_ret, GET_SHA1_QUIETLY);\n\t\tif (exists\n\t\t    ? !status\n\t\t    : status == SHORT_NAME_NOT_FOUND) {\n\t\t\thex[len] = 0;\n\t\t\treturn hex;\n\t\t}\n\t\tlen++;\n\t}\n\treturn hex;\n}\n\nstatic int ambiguous_path(const char *path, int len)\n{\n\tint slash = 1;\n\tint cnt;\n\n\tfor (cnt = 0; cnt < len; cnt++) {\n\t\tswitch (*path++) {\n\t\tcase '\\0':\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tif (slash)\n\t\t\t\tbreak;\n\t\t\tslash = 1;\n\t\t\tcontinue;\n\t\tcase '.':\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tslash = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn slash;\n}\n\nstatic inline int upstream_mark(const char *string, int len)\n{\n\tconst char *suffix[] = { \"@{upstream}\", \"@{u}\" };\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(suffix); i++) {\n\t\tint suffix_len = strlen(suffix[i]);\n\t\tif (suffix_len <= len\n\t\t    && !memcmp(string, suffix[i], suffix_len))\n\t\t\treturn suffix_len;\n\t}\n\treturn 0;\n}\n\nstatic int get_sha1_1(const char *name, int len, unsigned char *sha1, unsigned lookup_flags);\n\nstatic int get_sha1_basic(const char *str, int len, unsigned char *sha1)\n{\n\tstatic const char *warn_msg = \"refname '%.*s' is ambiguous.\";\n\tchar *real_ref = NULL;\n\tint refs_found = 0;\n\tint at, reflog_len;\n\n\tif (len == 40 && !get_sha1_hex(str, sha1))\n\t\treturn 0;\n\n\t/* basic@{time or number or -number} format to query ref-log */\n\treflog_len = at = 0;\n\tif (len && str[len-1] == '}') {\n\t\tfor (at = len-2; at >= 0; at--) {\n\t\t\tif (str[at] == '@' && str[at+1] == '{') {\n\t\t\t\tif (!upstream_mark(str + at, len - at)) {\n\t\t\t\t\treflog_len = (len-1) - (at+2);\n\t\t\t\t\tlen = at;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Accept only unambiguous ref paths. */\n\tif (len && ambiguous_path(str, len))\n\t\treturn -1;\n\n\tif (!len && reflog_len) {\n\t\tstruct strbuf buf = STRBUF_INIT;\n\t\tint ret;\n\t\t/* try the @{-N} syntax for n-th checkout */\n\t\tret = interpret_branch_name(str+at, &buf);\n\t\tif (ret > 0) {\n\t\t\t/* substitute this branch name and restart */\n\t\t\treturn get_sha1_1(buf.buf, buf.len, sha1, 0);\n\t\t} else if (ret == 0) {\n\t\t\treturn -1;\n\t\t}\n\t\t/* allow \"@{...}\" to mean the current branch reflog */\n\t\trefs_found = dwim_ref(\"HEAD\", 4, sha1, &real_ref);\n\t} else if (reflog_len)\n\t\trefs_found = dwim_log(str, len, sha1, &real_ref);\n\telse\n\t\trefs_found = dwim_ref(str, len, sha1, &real_ref);\n\n\tif (!refs_found)\n\t\treturn -1;\n\n\tif (warn_ambiguous_refs && refs_found > 1)\n\t\twarning(warn_msg, len, str);\n\n\tif (reflog_len) {\n\t\tint nth, i;\n\t\tunsigned long at_time;\n\t\tunsigned long co_time;\n\t\tint co_tz, co_cnt;\n\n\t\t/* a @{-N} placed anywhere except the start is an error */\n\t\tif (str[at+2] == '-')\n\t\t\treturn -1;\n\n\t\t/* Is it asking for N-th entry, or approxidate? */\n\t\tfor (i = nth = 0; 0 <= nth && i < reflog_len; i++) {\n\t\t\tchar ch = str[at+2+i];\n\t\t\tif ('0' <= ch && ch <= '9')\n\t\t\t\tnth = nth * 10 + ch - '0';\n\t\t\telse\n\t\t\t\tnth = -1;\n\t\t}\n\t\tif (100000000 <= nth) {\n\t\t\tat_time = nth;\n\t\t\tnth = -1;\n\t\t} else if (0 <= nth)\n\t\t\tat_time = 0;\n\t\telse {\n\t\t\tint errors = 0;\n\t\t\tchar *tmp = xstrndup(str + at + 2, reflog_len);\n\t\t\tat_time = approxidate_careful(tmp, &errors);\n\t\t\tfree(tmp);\n\t\t\tif (errors)\n\t\t\t\treturn -1;\n\t\t}\n\t\tif (read_ref_at(real_ref, at_time, nth, sha1, NULL,\n\t\t\t\t&co_time, &co_tz, &co_cnt)) {\n\t\t\tif (!len) {\n\t\t\t\tif (!prefixcmp(real_ref, \"refs/heads/\")) {\n\t\t\t\t\tstr = real_ref + 11;\n\t\t\t\t\tlen = strlen(real_ref + 11);\n\t\t\t\t} else {\n\t\t\t\t\t/* detached HEAD */\n\t\t\t\t\tstr = \"HEAD\";\n\t\t\t\t\tlen = 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (at_time)\n\t\t\t\twarning(\"Log for '%.*s' only goes \"\n\t\t\t\t\t\"back to %s.\", len, str,\n\t\t\t\t\tshow_date(co_time, co_tz, DATE_RFC2822));\n\t\t\telse {\n\t\t\t\tdie(\"Log for '%.*s' only has %d entries.\",\n\t\t\t\t    len, str, co_cnt);\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(real_ref);\n\treturn 0;\n}\n\nstatic int get_parent(const char *name, int len,\n\t\t      unsigned char *result, int idx)\n{\n\tunsigned char sha1[20];\n\tint ret = get_sha1_1(name, len, sha1, GET_SHA1_COMMITTISH);\n\tstruct commit *commit;\n\tstruct commit_list *p;\n\n\tif (ret)\n\t\treturn ret;\n\tcommit = lookup_commit_reference(sha1);\n\tif (!commit)\n\t\treturn -1;\n\tif (parse_commit(commit))\n\t\treturn -1;\n\tif (!idx) {\n\t\thashcpy(result, commit->object.sha1);\n\t\treturn 0;\n\t}\n\tp = commit->parents;\n\twhile (p) {\n\t\tif (!--idx) {\n\t\t\thashcpy(result, p->item->object.sha1);\n\t\t\treturn 0;\n\t\t}\n\t\tp = p->next;\n\t}\n\treturn -1;\n}\n\nstatic int get_nth_ancestor(const char *name, int len,\n\t\t\t    unsigned char *result, int generation)\n{\n\tunsigned char sha1[20];\n\tstruct commit *commit;\n\tint ret;\n\n\tret = get_sha1_1(name, len, sha1, GET_SHA1_COMMITTISH);\n\tif (ret)\n\t\treturn ret;\n\tcommit = lookup_commit_reference(sha1);\n\tif (!commit)\n\t\treturn -1;\n\n\twhile (generation--) {\n\t\tif (parse_commit(commit) || !commit->parents)\n\t\t\treturn -1;\n\t\tcommit = commit->parents->item;\n\t}\n\thashcpy(result, commit->object.sha1);\n\treturn 0;\n}\n\nstruct object *peel_to_type(const char *name, int namelen,\n\t\t\t    struct object *o, enum object_type expected_type)\n{\n\tif (name && !namelen)\n\t\tnamelen = strlen(name);\n\twhile (1) {\n\t\tif (!o || (!o->parsed && !parse_object(o->sha1)))\n\t\t\treturn NULL;\n\t\tif (expected_type == OBJ_ANY || o->type == expected_type)\n\t\t\treturn o;\n\t\tif (o->type == OBJ_TAG)\n\t\t\to = ((struct tag*) o)->tagged;\n\t\telse if (o->type == OBJ_COMMIT)\n\t\t\to = &(((struct commit *) o)->tree->object);\n\t\telse {\n\t\t\tif (name)\n\t\t\t\terror(\"%.*s: expected %s type, but the object \"\n\t\t\t\t      \"dereferences to %s type\",\n\t\t\t\t      namelen, name, typename(expected_type),\n\t\t\t\t      typename(o->type));\n\t\t\treturn NULL;\n\t\t}\n\t}\n}\n\nstatic int peel_onion(const char *name, int len, unsigned char *sha1)\n{\n\tunsigned char outer[20];\n\tconst char *sp;\n\tunsigned int expected_type = 0;\n\tunsigned lookup_flags = 0;\n\tstruct object *o;\n\n\t/*\n\t * \"ref^{type}\" dereferences ref repeatedly until you cannot\n\t * dereference anymore, or you get an object of given type,\n\t * whichever comes first.  \"ref^{}\" means just dereference\n\t * tags until you get a non-tag.  \"ref^0\" is a shorthand for\n\t * \"ref^{commit}\".  \"commit^{tree}\" could be used to find the\n\t * top-level tree of the given commit.\n\t */\n\tif (len < 4 || name[len-1] != '}')\n\t\treturn -1;\n\n\tfor (sp = name + len - 1; name <= sp; sp--) {\n\t\tint ch = *sp;\n\t\tif (ch == '{' && name < sp && sp[-1] == '^')\n\t\t\tbreak;\n\t}\n\tif (sp <= name)\n\t\treturn -1;\n\n\tsp++; /* beginning of type name, or closing brace for empty */\n\tif (!strncmp(commit_type, sp, 6) && sp[6] == '}')\n\t\texpected_type = OBJ_COMMIT;\n\telse if (!strncmp(tree_type, sp, 4) && sp[4] == '}')\n\t\texpected_type = OBJ_TREE;\n\telse if (!strncmp(blob_type, sp, 4) && sp[4] == '}')\n\t\texpected_type = OBJ_BLOB;\n\telse if (!prefixcmp(sp, \"object}\"))\n\t\texpected_type = OBJ_ANY;\n\telse if (sp[0] == '}')\n\t\texpected_type = OBJ_NONE;\n\telse if (sp[0] == '/')\n\t\texpected_type = OBJ_COMMIT;\n\telse\n\t\treturn -1;\n\n\tif (expected_type == OBJ_COMMIT)\n\t\tlookup_flags = GET_SHA1_COMMITTISH;\n\telse if (expected_type == OBJ_TREE)\n\t\tlookup_flags = GET_SHA1_TREEISH;\n\n\tif (get_sha1_1(name, sp - name - 2, outer, lookup_flags))\n\t\treturn -1;\n\n\to = parse_object(outer);\n\tif (!o)\n\t\treturn -1;\n\tif (!expected_type) {\n\t\to = deref_tag(o, name, sp - name - 2);\n\t\tif (!o || (!o->parsed && !parse_object(o->sha1)))\n\t\t\treturn -1;\n\t\thashcpy(sha1, o->sha1);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * At this point, the syntax look correct, so\n\t * if we do not get the needed object, we should\n\t * barf.\n\t */\n\to = peel_to_type(name, len, o, expected_type);\n\tif (!o)\n\t\treturn -1;\n\n\thashcpy(sha1, o->sha1);\n\tif (sp[0] == '/') {\n\t\t/* \"$commit^{/foo}\" */\n\t\tchar *prefix;\n\t\tint ret;\n\t\tstruct commit_list *list = NULL;\n\n\t\t/*\n\t\t * $commit^{/}. Some regex implementation may reject.\n\t\t * We don't need regex anyway. '' pattern always matches.\n\t\t */\n\t\tif (sp[1] == '}')\n\t\t\treturn 0;\n\n\t\tprefix = xstrndup(sp + 1, name + len - 1 - (sp + 1));\n\t\tcommit_list_insert((struct commit *)o, &list);\n\t\tret = get_sha1_oneline(prefix, sha1, list);\n\t\tfree(prefix);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int get_describe_name(const char *name, int len, unsigned char *sha1)\n{\n\tconst char *cp;\n\tunsigned flags = GET_SHA1_QUIETLY | GET_SHA1_COMMIT;\n\n\tfor (cp = name + len - 1; name + 2 <= cp; cp--) {\n\t\tchar ch = *cp;\n\t\tif (hexval(ch) & ~0377) {\n\t\t\t/* We must be looking at g in \"SOMETHING-g\"\n\t\t\t * for it to be describe output.\n\t\t\t */\n\t\t\tif (ch == 'g' && cp[-1] == '-') {\n\t\t\t\tcp++;\n\t\t\t\tlen -= cp - name;\n\t\t\t\treturn get_short_sha1(cp, len, sha1, flags);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic int get_sha1_1(const char *name, int len, unsigned char *sha1, unsigned lookup_flags)\n{\n\tint ret, has_suffix;\n\tconst char *cp;\n\n\t/*\n\t * \"name~3\" is \"name^^^\", \"name~\" is \"name~1\", and \"name^\" is \"name^1\".\n\t */\n\thas_suffix = 0;\n\tfor (cp = name + len - 1; name <= cp; cp--) {\n\t\tint ch = *cp;\n\t\tif ('0' <= ch && ch <= '9')\n\t\t\tcontinue;\n\t\tif (ch == '~' || ch == '^')\n\t\t\thas_suffix = ch;\n\t\tbreak;\n\t}\n\n\tif (has_suffix) {\n\t\tint num = 0;\n\t\tint len1 = cp - name;\n\t\tcp++;\n\t\twhile (cp < name + len)\n\t\t\tnum = num * 10 + *cp++ - '0';\n\t\tif (!num && len1 == len - 1)\n\t\t\tnum = 1;\n\t\tif (has_suffix == '^')\n\t\t\treturn get_parent(name, len1, sha1, num);\n\t\t/* else if (has_suffix == '~') -- goes without saying */\n\t\treturn get_nth_ancestor(name, len1, sha1, num);\n\t}\n\n\tret = peel_onion(name, len, sha1);\n\tif (!ret)\n\t\treturn 0;\n\n\tret = get_sha1_basic(name, len, sha1);\n\tif (!ret)\n\t\treturn 0;\n\n\t/* It could be describe output that is \"SOMETHING-gXXXX\" */\n\tret = get_describe_name(name, len, sha1);\n\tif (!ret)\n\t\treturn 0;\n\n\treturn get_short_sha1(name, len, sha1, lookup_flags);\n}\n\n/*\n * This interprets names like ':/Initial revision of \"git\"' by searching\n * through history and returning the first commit whose message starts\n * the given regular expression.\n *\n * For future extension, ':/!' is reserved. If you want to match a message\n * beginning with a '!', you have to repeat the exclamation mark.\n */\n#define ONELINE_SEEN (1u<<20)\n\nstatic int handle_one_ref(const char *path,\n\t\tconst unsigned char *sha1, int flag, void *cb_data)\n{\n\tstruct commit_list **list = cb_data;\n\tstruct object *object = parse_object(sha1);\n\tif (!object)\n\t\treturn 0;\n\tif (object->type == OBJ_TAG) {\n\t\tobject = deref_tag(object, path, strlen(path));\n\t\tif (!object)\n\t\t\treturn 0;\n\t}\n\tif (object->type != OBJ_COMMIT)\n\t\treturn 0;\n\tcommit_list_insert_by_date((struct commit *)object, list);\n\treturn 0;\n}\n\nstatic int get_sha1_oneline(const char *prefix, unsigned char *sha1,\n\t\t\t    struct commit_list *list)\n{\n\tstruct commit_list *backup = NULL, *l;\n\tint found = 0;\n\tregex_t regex;\n\n\tif (prefix[0] == '!') {\n\t\tif (prefix[1] != '!')\n\t\t\tdie (\"Invalid search pattern: %s\", prefix);\n\t\tprefix++;\n\t}\n\n\tif (regcomp(&regex, prefix, REG_EXTENDED))\n\t\tdie(\"Invalid search pattern: %s\", prefix);\n\n\tfor (l = list; l; l = l->next) {\n\t\tl->item->object.flags |= ONELINE_SEEN;\n\t\tcommit_list_insert(l->item, &backup);\n\t}\n\twhile (list) {\n\t\tchar *p, *to_free = NULL;\n\t\tstruct commit *commit;\n\t\tenum object_type type;\n\t\tunsigned long size;\n\t\tint matches;\n\n\t\tcommit = pop_most_recent_commit(&list, ONELINE_SEEN);\n\t\tif (!parse_object(commit->object.sha1))\n\t\t\tcontinue;\n\t\tif (commit->buffer)\n\t\t\tp = commit->buffer;\n\t\telse {\n\t\t\tp = read_sha1_file(commit->object.sha1, &type, &size);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\tto_free = p;\n\t\t}\n\n\t\tp = strstr(p, \"\\n\\n\");\n\t\tmatches = p && !regexec(&regex, p + 2, 0, NULL, 0);\n\t\tfree(to_free);\n\n\t\tif (matches) {\n\t\t\thashcpy(sha1, commit->object.sha1);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tregfree(&regex);\n\tfree_commit_list(list);\n\tfor (l = backup; l; l = l->next)\n\t\tclear_commit_marks(l->item, ONELINE_SEEN);\n\tfree_commit_list(backup);\n\treturn found ? 0 : -1;\n}\n\nstruct grab_nth_branch_switch_cbdata {\n\tint remaining;\n\tstruct strbuf buf;\n};\n\nstatic int grab_nth_branch_switch(unsigned char *osha1, unsigned char *nsha1,\n\t\t\t\t  const char *email, unsigned long timestamp, int tz,\n\t\t\t\t  const char *message, void *cb_data)\n{\n\tstruct grab_nth_branch_switch_cbdata *cb = cb_data;\n\tconst char *match = NULL, *target = NULL;\n\tsize_t len;\n\n\tif (!prefixcmp(message, \"checkout: moving from \")) {\n\t\tmatch = message + strlen(\"checkout: moving from \");\n\t\ttarget = strstr(match, \" to \");\n\t}\n\n\tif (!match || !target)\n\t\treturn 0;\n\tif (--(cb->remaining) == 0) {\n\t\tlen = target - match;\n\t\tstrbuf_reset(&cb->buf);\n\t\tstrbuf_add(&cb->buf, match, len);\n\t\treturn 1; /* we are done */\n\t}\n\treturn 0;\n}\n\n/*\n * Parse @{-N} syntax, return the number of characters parsed\n * if successful; otherwise signal an error with negative value.\n */\nstatic int interpret_nth_prior_checkout(const char *name, struct strbuf *buf)\n{\n\tlong nth;\n\tint retval;\n\tstruct grab_nth_branch_switch_cbdata cb;\n\tconst char *brace;\n\tchar *num_end;\n\n\tif (name[0] != '@' || name[1] != '{' || name[2] != '-')\n\t\treturn -1;\n\tbrace = strchr(name, '}');\n\tif (!brace)\n\t\treturn -1;\n\tnth = strtol(name + 3, &num_end, 10);\n\tif (num_end != brace)\n\t\treturn -1;\n\tif (nth <= 0)\n\t\treturn -1;\n\tcb.remaining = nth;\n\tstrbuf_init(&cb.buf, 20);\n\n\tretval = 0;\n\tif (0 < for_each_reflog_ent_reverse(\"HEAD\", grab_nth_branch_switch, &cb)) {\n\t\tstrbuf_reset(buf);\n\t\tstrbuf_add(buf, cb.buf.buf, cb.buf.len);\n\t\tretval = brace - name + 1;\n\t}\n\n\tstrbuf_release(&cb.buf);\n\treturn retval;\n}\n\nint get_sha1_mb(const char *name, unsigned char *sha1)\n{\n\tstruct commit *one, *two;\n\tstruct commit_list *mbs;\n\tunsigned char sha1_tmp[20];\n\tconst char *dots;\n\tint st;\n\n\tdots = strstr(name, \"...\");\n\tif (!dots)\n\t\treturn get_sha1(name, sha1);\n\tif (dots == name)\n\t\tst = get_sha1(\"HEAD\", sha1_tmp);\n\telse {\n\t\tstruct strbuf sb;\n\t\tstrbuf_init(&sb, dots - name);\n\t\tstrbuf_add(&sb, name, dots - name);\n\t\tst = get_sha1_committish(sb.buf, sha1_tmp);\n\t\tstrbuf_release(&sb);\n\t}\n\tif (st)\n\t\treturn st;\n\tone = lookup_commit_reference_gently(sha1_tmp, 0);\n\tif (!one)\n\t\treturn -1;\n\n\tif (get_sha1_committish(dots[3] ? (dots + 3) : \"HEAD\", sha1_tmp))\n\t\treturn -1;\n\ttwo = lookup_commit_reference_gently(sha1_tmp, 0);\n\tif (!two)\n\t\treturn -1;\n\tmbs = get_merge_bases(one, two, 1);\n\tif (!mbs || mbs->next)\n\t\tst = -1;\n\telse {\n\t\tst = 0;\n\t\thashcpy(sha1, mbs->item->object.sha1);\n\t}\n\tfree_commit_list(mbs);\n\treturn st;\n}\n\n/*\n * This reads short-hand syntax that not only evaluates to a commit\n * object name, but also can act as if the end user spelled the name\n * of the branch from the command line.\n *\n * - \"@{-N}\" finds the name of the Nth previous branch we were on, and\n *   places the name of the branch in the given buf and returns the\n *   number of characters parsed if successful.\n *\n * - \"<branch>@{upstream}\" finds the name of the other ref that\n *   <branch> is configured to merge with (missing <branch> defaults\n *   to the current branch), and places the name of the branch in the\n *   given buf and returns the number of characters parsed if\n *   successful.\n *\n * If the input is not of the accepted format, it returns a negative\n * number to signal an error.\n *\n * If the input was ok but there are not N branch switches in the\n * reflog, it returns 0.\n */\nint interpret_branch_name(const char *name, struct strbuf *buf)\n{\n\tchar *cp;\n\tstruct branch *upstream;\n\tint namelen = strlen(name);\n\tint len = interpret_nth_prior_checkout(name, buf);\n\tint tmp_len;\n\n\tif (!len)\n\t\treturn len; /* syntax Ok, not enough switches */\n\tif (0 < len && len == namelen)\n\t\treturn len; /* consumed all */\n\telse if (0 < len) {\n\t\t/* we have extra data, which might need further processing */\n\t\tstruct strbuf tmp = STRBUF_INIT;\n\t\tint used = buf->len;\n\t\tint ret;\n\n\t\tstrbuf_add(buf, name + len, namelen - len);\n\t\tret = interpret_branch_name(buf->buf, &tmp);\n\t\t/* that data was not interpreted, remove our cruft */\n\t\tif (ret < 0) {\n\t\t\tstrbuf_setlen(buf, used);\n\t\t\treturn len;\n\t\t}\n\t\tstrbuf_reset(buf);\n\t\tstrbuf_addbuf(buf, &tmp);\n\t\tstrbuf_release(&tmp);\n\t\t/* tweak for size of {-N} versus expanded ref name */\n\t\treturn ret - used + len;\n\t}\n\n\tcp = strchr(name, '@');\n\tif (!cp)\n\t\treturn -1;\n\ttmp_len = upstream_mark(cp, namelen - (cp - name));\n\tif (!tmp_len)\n\t\treturn -1;\n\tlen = cp + tmp_len - name;\n\tcp = xstrndup(name, cp - name);\n\tupstream = branch_get(*cp ? cp : NULL);\n\t/*\n\t * Upstream can be NULL only if cp refers to HEAD and HEAD\n\t * points to something different than a branch.\n\t */\n\tif (!upstream)\n\t\tdie(_(\"HEAD does not point to a branch\"));\n\tif (!upstream->merge || !upstream->merge[0]->dst) {\n\t\tif (!ref_exists(upstream->refname))\n\t\t\tdie(_(\"No such branch: '%s'\"), cp);\n\t\tif (!upstream->merge) {\n\t\t\tdie(_(\"No upstream configured for branch '%s'\"),\n\t\t\t\tupstream->name);\n\t\t}\n\t\tdie(\n\t\t\t_(\"Upstream branch '%s' not stored as a remote-tracking branch\"),\n\t\t\tupstream->merge[0]->src);\n\t}\n\tfree(cp);\n\tcp = shorten_unambiguous_ref(upstream->merge[0]->dst, 0);\n\tstrbuf_reset(buf);\n\tstrbuf_addstr(buf, cp);\n\tfree(cp);\n\treturn len;\n}\n\nint strbuf_branchname(struct strbuf *sb, const char *name)\n{\n\tint len = strlen(name);\n\tint used = interpret_branch_name(name, sb);\n\n\tif (used == len)\n\t\treturn 0;\n\tif (used < 0)\n\t\tused = 0;\n\tstrbuf_add(sb, name + used, len - used);\n\treturn len;\n}\n\nint strbuf_check_branch_ref(struct strbuf *sb, const char *name)\n{\n\tstrbuf_branchname(sb, name);\n\tif (name[0] == '-')\n\t\treturn -1;\n\tstrbuf_splice(sb, 0, 0, \"refs/heads/\", 11);\n\treturn check_refname_format(sb->buf, 0);\n}\n\n/*\n * This is like \"get_sha1_basic()\", except it allows \"sha1 expressions\",\n * notably \"xyz^\" for \"parent of xyz\"\n */\nint get_sha1(const char *name, unsigned char *sha1)\n{\n\tstruct object_context unused;\n\treturn get_sha1_with_context(name, 0, sha1, &unused);\n}\n\n/*\n * Many callers know that the user meant to name a committish by\n * syntactical positions where the object name appears.  Calling this\n * function allows the machinery to disambiguate shorter-than-unique\n * abbreviated object names between committish and others.\n *\n * Note that this does NOT error out when the named object is not a\n * committish. It is merely to give a hint to the disambiguation\n * machinery.\n */\nint get_sha1_committish(const char *name, unsigned char *sha1)\n{\n\tstruct object_context unused;\n\treturn get_sha1_with_context(name, GET_SHA1_COMMITTISH,\n\t\t\t\t     sha1, &unused);\n}\n\nint get_sha1_treeish(const char *name, unsigned char *sha1)\n{\n\tstruct object_context unused;\n\treturn get_sha1_with_context(name, GET_SHA1_TREEISH,\n\t\t\t\t     sha1, &unused);\n}\n\nint get_sha1_commit(const char *name, unsigned char *sha1)\n{\n\tstruct object_context unused;\n\treturn get_sha1_with_context(name, GET_SHA1_COMMIT,\n\t\t\t\t     sha1, &unused);\n}\n\nint get_sha1_tree(const char *name, unsigned char *sha1)\n{\n\tstruct object_context unused;\n\treturn get_sha1_with_context(name, GET_SHA1_TREE,\n\t\t\t\t     sha1, &unused);\n}\n\nint get_sha1_blob(const char *name, unsigned char *sha1)\n{\n\tstruct object_context unused;\n\treturn get_sha1_with_context(name, GET_SHA1_BLOB,\n\t\t\t\t     sha1, &unused);\n}\n\n/* Must be called only when object_name:filename doesn't exist. */\nstatic void diagnose_invalid_sha1_path(const char *prefix,\n\t\t\t\t       const char *filename,\n\t\t\t\t       const unsigned char *tree_sha1,\n\t\t\t\t       const char *object_name,\n\t\t\t\t       int object_name_len)\n{\n\tstruct stat st;\n\tunsigned char sha1[20];\n\tunsigned mode;\n\n\tif (!prefix)\n\t\tprefix = \"\";\n\n\tif (!lstat(filename, &st))\n\t\tdie(\"Path '%s' exists on disk, but not in '%.*s'.\",\n\t\t    filename, object_name_len, object_name);\n\tif (errno == ENOENT || errno == ENOTDIR) {\n\t\tchar *fullname = xmalloc(strlen(filename)\n\t\t\t\t\t     + strlen(prefix) + 1);\n\t\tstrcpy(fullname, prefix);\n\t\tstrcat(fullname, filename);\n\n\t\tif (!get_tree_entry(tree_sha1, fullname,\n\t\t\t\t    sha1, &mode)) {\n\t\t\tdie(\"Path '%s' exists, but not '%s'.\\n\"\n\t\t\t    \"Did you mean '%.*s:%s' aka '%.*s:./%s'?\",\n\t\t\t    fullname,\n\t\t\t    filename,\n\t\t\t    object_name_len, object_name,\n\t\t\t    fullname,\n\t\t\t    object_name_len, object_name,\n\t\t\t    filename);\n\t\t}\n\t\tdie(\"Path '%s' does not exist in '%.*s'\",\n\t\t    filename, object_name_len, object_name);\n\t}\n}\n\n/* Must be called only when :stage:filename doesn't exist. */\nstatic void diagnose_invalid_index_path(int stage,\n\t\t\t\t\tconst char *prefix,\n\t\t\t\t\tconst char *filename)\n{\n\tstruct stat st;\n\tstruct cache_entry *ce;\n\tint pos;\n\tunsigned namelen = strlen(filename);\n\tunsigned fullnamelen;\n\tchar *fullname;\n\n\tif (!prefix)\n\t\tprefix = \"\";\n\n\t/* Wrong stage number? */\n\tpos = cache_name_pos(filename, namelen);\n\tif (pos < 0)\n\t\tpos = -pos - 1;\n\tif (pos < active_nr) {\n\t\tce = active_cache[pos];\n\t\tif (ce_namelen(ce) == namelen &&\n\t\t    !memcmp(ce->name, filename, namelen))\n\t\t\tdie(\"Path '%s' is in the index, but not at stage %d.\\n\"\n\t\t\t    \"Did you mean ':%d:%s'?\",\n\t\t\t    filename, stage,\n\t\t\t    ce_stage(ce), filename);\n\t}\n\n\t/* Confusion between relative and absolute filenames? */\n\tfullnamelen = namelen + strlen(prefix);\n\tfullname = xmalloc(fullnamelen + 1);\n\tstrcpy(fullname, prefix);\n\tstrcat(fullname, filename);\n\tpos = cache_name_pos(fullname, fullnamelen);\n\tif (pos < 0)\n\t\tpos = -pos - 1;\n\tif (pos < active_nr) {\n\t\tce = active_cache[pos];\n\t\tif (ce_namelen(ce) == fullnamelen &&\n\t\t    !memcmp(ce->name, fullname, fullnamelen))\n\t\t\tdie(\"Path '%s' is in the index, but not '%s'.\\n\"\n\t\t\t    \"Did you mean ':%d:%s' aka ':%d:./%s'?\",\n\t\t\t    fullname, filename,\n\t\t\t    ce_stage(ce), fullname,\n\t\t\t    ce_stage(ce), filename);\n\t}\n\n\tif (!lstat(filename, &st))\n\t\tdie(\"Path '%s' exists on disk, but not in the index.\", filename);\n\tif (errno == ENOENT || errno == ENOTDIR)\n\t\tdie(\"Path '%s' does not exist (neither on disk nor in the index).\",\n\t\t    filename);\n\n\tfree(fullname);\n}\n\n\nstatic char *resolve_relative_path(const char *rel)\n{\n\tif (prefixcmp(rel, \"./\") && prefixcmp(rel, \"../\"))\n\t\treturn NULL;\n\n\tif (!startup_info)\n\t\tdie(\"BUG: startup_info struct is not initialized.\");\n\n\tif (!is_inside_work_tree())\n\t\tdie(\"relative path syntax can't be used outside working tree.\");\n\n\t/* die() inside prefix_path() if resolved path is outside worktree */\n\treturn prefix_path(startup_info->prefix,\n\t\t\t   startup_info->prefix ? strlen(startup_info->prefix) : 0,\n\t\t\t   rel);\n}\n\nstatic int get_sha1_with_context_1(const char *name,\n\t\t\t\t   unsigned flags,\n\t\t\t\t   const char *prefix,\n\t\t\t\t   unsigned char *sha1,\n\t\t\t\t   struct object_context *oc)\n{\n\tint ret, bracket_depth;\n\tint namelen = strlen(name);\n\tconst char *cp;\n\tint only_to_die = flags & GET_SHA1_ONLY_TO_DIE;\n\n\tmemset(oc, 0, sizeof(*oc));\n\toc->mode = S_IFINVALID;\n\tret = get_sha1_1(name, namelen, sha1, flags);\n\tif (!ret)\n\t\treturn ret;\n\t/*\n\t * sha1:path --> object name of path in ent sha1\n\t * :path -> object name of absolute path in index\n\t * :./path -> object name of path relative to cwd in index\n\t * :[0-3]:path -> object name of path in index at stage\n\t * :/foo -> recent commit matching foo\n\t */\n\tif (name[0] == ':') {\n\t\tint stage = 0;\n\t\tstruct cache_entry *ce;\n\t\tchar *new_path = NULL;\n\t\tint pos;\n\t\tif (!only_to_die && namelen > 2 && name[1] == '/') {\n\t\t\tstruct commit_list *list = NULL;\n\t\t\tfor_each_ref(handle_one_ref, &list);\n\t\t\treturn get_sha1_oneline(name + 2, sha1, list);\n\t\t}\n\t\tif (namelen < 3 ||\n\t\t    name[2] != ':' ||\n\t\t    name[1] < '0' || '3' < name[1])\n\t\t\tcp = name + 1;\n\t\telse {\n\t\t\tstage = name[1] - '0';\n\t\t\tcp = name + 3;\n\t\t}\n\t\tnew_path = resolve_relative_path(cp);\n\t\tif (!new_path) {\n\t\t\tnamelen = namelen - (cp - name);\n\t\t} else {\n\t\t\tcp = new_path;\n\t\t\tnamelen = strlen(cp);\n\t\t}\n\n\t\tstrncpy(oc->path, cp,\n\t\t\tsizeof(oc->path));\n\t\toc->path[sizeof(oc->path)-1] = '\\0';\n\n\t\tif (!active_cache)\n\t\t\tread_cache();\n\t\tpos = cache_name_pos(cp, namelen);\n\t\tif (pos < 0)\n\t\t\tpos = -pos - 1;\n\t\twhile (pos < active_nr) {\n\t\t\tce = active_cache[pos];\n\t\t\tif (ce_namelen(ce) != namelen ||\n\t\t\t    memcmp(ce->name, cp, namelen))\n\t\t\t\tbreak;\n\t\t\tif (ce_stage(ce) == stage) {\n\t\t\t\thashcpy(sha1, ce->sha1);\n\t\t\t\toc->mode = ce->ce_mode;\n\t\t\t\tfree(new_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t\tif (only_to_die && name[1] && name[1] != '/')\n\t\t\tdiagnose_invalid_index_path(stage, prefix, cp);\n\t\tfree(new_path);\n\t\treturn -1;\n\t}\n\tfor (cp = name, bracket_depth = 0; *cp; cp++) {\n\t\tif (*cp == '{')\n\t\t\tbracket_depth++;\n\t\telse if (bracket_depth && *cp == '}')\n\t\t\tbracket_depth--;\n\t\telse if (!bracket_depth && *cp == ':')\n\t\t\tbreak;\n\t}\n\tif (*cp == ':') {\n\t\tunsigned char tree_sha1[20];\n\t\tint len = cp - name;\n\t\tif (!get_sha1_1(name, len, tree_sha1, GET_SHA1_TREEISH)) {\n\t\t\tconst char *filename = cp+1;\n\t\t\tchar *new_filename = NULL;\n\n\t\t\tnew_filename = resolve_relative_path(filename);\n\t\t\tif (new_filename)\n\t\t\t\tfilename = new_filename;\n\t\t\tret = get_tree_entry(tree_sha1, filename, sha1, &oc->mode);\n\t\t\tif (ret && only_to_die) {\n\t\t\t\tdiagnose_invalid_sha1_path(prefix, filename,\n\t\t\t\t\t\t\t   tree_sha1,\n\t\t\t\t\t\t\t   name, len);\n\t\t\t}\n\t\t\thashcpy(oc->tree, tree_sha1);\n\t\t\tstrncpy(oc->path, filename,\n\t\t\t\tsizeof(oc->path));\n\t\t\toc->path[sizeof(oc->path)-1] = '\\0';\n\n\t\t\tfree(new_filename);\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tif (only_to_die)\n\t\t\t\tdie(\"Invalid object name '%.*s'.\", len, name);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/*\n * Call this function when you know \"name\" given by the end user must\n * name an object but it doesn't; the function _may_ die with a better\n * diagnostic message than \"no such object 'name'\", e.g. \"Path 'doc' does not\n * exist in 'HEAD'\" when given \"HEAD:doc\", or it may return in which case\n * you have a chance to diagnose the error further.\n */\nvoid maybe_die_on_misspelt_object_name(const char *name, const char *prefix)\n{\n\tstruct object_context oc;\n\tunsigned char sha1[20];\n\tget_sha1_with_context_1(name, GET_SHA1_ONLY_TO_DIE, prefix, sha1, &oc);\n}\n\nint get_sha1_with_context(const char *str, unsigned flags, unsigned char *sha1, struct object_context *orc)\n{\n\treturn get_sha1_with_context_1(str, flags, NULL, sha1, orc);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0077dbd50b516c9614573b5c6197fc627802527e",
  "sha1_ok": true,
  "size": 34300
}
