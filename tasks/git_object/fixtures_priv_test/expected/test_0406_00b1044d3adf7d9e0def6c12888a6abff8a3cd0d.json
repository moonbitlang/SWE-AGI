{
  "content": {
    "base64": "LyoKICogQ29weXJpZ2h0IChDKSAyMDA1IEp1bmlvIEMgSGFtYW5vCiAqLwojaW5jbHVkZSA8c3lzL3R5cGVzLmg+CiNpbmNsdWRlIDxzeXMvd2FpdC5oPgojaW5jbHVkZSA8c2lnbmFsLmg+CiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAicXVvdGUuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgImRpZmZjb3JlLmgiCiNpbmNsdWRlICJkZWx0YS5oIgojaW5jbHVkZSAieGRpZmYtaW50ZXJmYWNlLmgiCgpzdGF0aWMgaW50IHVzZV9zaXplX2NhY2hlOwoKaW50IGRpZmZfcmVuYW1lX2xpbWl0X2RlZmF1bHQgPSAtMTsKCmludCBnaXRfZGlmZl9jb25maWcoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSkKewoJaWYgKCFzdHJjbXAodmFyLCAiZGlmZi5yZW5hbWVsaW1pdCIpKSB7CgkJZGlmZl9yZW5hbWVfbGltaXRfZGVmYXVsdCA9IGdpdF9jb25maWdfaW50KHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoKCXJldHVybiBnaXRfZGVmYXVsdF9jb25maWcodmFyLCB2YWx1ZSk7Cn0KCnN0YXRpYyBjaGFyICpxdW90ZV9vbmUoY29uc3QgY2hhciAqc3RyKQp7CglpbnQgbmVlZGxlbjsKCWNoYXIgKnhwOwoKCWlmICghc3RyKQoJCXJldHVybiBOVUxMOwoJbmVlZGxlbiA9IHF1b3RlX2Nfc3R5bGUoc3RyLCBOVUxMLCBOVUxMLCAwKTsKCWlmICghbmVlZGxlbikKCQlyZXR1cm4gc3RyZHVwKHN0cik7Cgl4cCA9IHhtYWxsb2MobmVlZGxlbiArIDEpOwoJcXVvdGVfY19zdHlsZShzdHIsIHhwLCBOVUxMLCAwKTsKCXJldHVybiB4cDsKfQoKc3RhdGljIGNoYXIgKnF1b3RlX3R3byhjb25zdCBjaGFyICpvbmUsIGNvbnN0IGNoYXIgKnR3bykKewoJaW50IG5lZWRfb25lID0gcXVvdGVfY19zdHlsZShvbmUsIE5VTEwsIE5VTEwsIDEpOwoJaW50IG5lZWRfdHdvID0gcXVvdGVfY19zdHlsZSh0d28sIE5VTEwsIE5VTEwsIDEpOwoJY2hhciAqeHA7CgoJaWYgKG5lZWRfb25lICsgbmVlZF90d28pIHsKCQlpZiAoIW5lZWRfb25lKSBuZWVkX29uZSA9IHN0cmxlbihvbmUpOwoJCWlmICghbmVlZF90d28pIG5lZWRfb25lID0gc3RybGVuKHR3byk7CgoJCXhwID0geG1hbGxvYyhuZWVkX29uZSArIG5lZWRfdHdvICsgMyk7CgkJeHBbMF0gPSAnIic7CgkJcXVvdGVfY19zdHlsZShvbmUsIHhwICsgMSwgTlVMTCwgMSk7CgkJcXVvdGVfY19zdHlsZSh0d28sIHhwICsgbmVlZF9vbmUgKyAxLCBOVUxMLCAxKTsKCQlzdHJjcHkoeHAgKyBuZWVkX29uZSArIG5lZWRfdHdvICsgMSwgIlwiIik7CgkJcmV0dXJuIHhwOwoJfQoJbmVlZF9vbmUgPSBzdHJsZW4ob25lKTsKCW5lZWRfdHdvID0gc3RybGVuKHR3byk7Cgl4cCA9IHhtYWxsb2MobmVlZF9vbmUgKyBuZWVkX3R3byArIDEpOwoJc3RyY3B5KHhwLCBvbmUpOwoJc3RyY3B5KHhwICsgbmVlZF9vbmUsIHR3byk7CglyZXR1cm4geHA7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpleHRlcm5hbF9kaWZmKHZvaWQpCnsKCXN0YXRpYyBjb25zdCBjaGFyICpleHRlcm5hbF9kaWZmX2NtZCA9IE5VTEw7CglzdGF0aWMgaW50IGRvbmVfcHJlcGFyaW5nID0gMDsKCglpZiAoZG9uZV9wcmVwYXJpbmcpCgkJcmV0dXJuIGV4dGVybmFsX2RpZmZfY21kOwoJZXh0ZXJuYWxfZGlmZl9jbWQgPSBnZXRlbnYoIkdJVF9FWFRFUk5BTF9ESUZGIik7Cglkb25lX3ByZXBhcmluZyA9IDE7CglyZXR1cm4gZXh0ZXJuYWxfZGlmZl9jbWQ7Cn0KCiNkZWZpbmUgVEVNUEZJTEVfUEFUSF9MRU4JCTUwCgpzdGF0aWMgc3RydWN0IGRpZmZfdGVtcGZpbGUgewoJY29uc3QgY2hhciAqbmFtZTsgLyogZmlsZW5hbWUgZXh0ZXJuYWwgZGlmZiBzaG91bGQgcmVhZCBmcm9tICovCgljaGFyIGhleFs0MV07CgljaGFyIG1vZGVbMTBdOwoJY2hhciB0bXBfcGF0aFtURU1QRklMRV9QQVRIX0xFTl07Cn0gZGlmZl90ZW1wWzJdOwoKc3RhdGljIGludCBjb3VudF9saW5lcyhjb25zdCBjaGFyICpkYXRhLCBpbnQgc2l6ZSkKewoJaW50IGNvdW50LCBjaCwgY29tcGxldGVseV9lbXB0eSA9IDEsIG5sX2p1c3Rfc2VlbiA9IDA7Cgljb3VudCA9IDA7Cgl3aGlsZSAoMCA8IHNpemUtLSkgewoJCWNoID0gKmRhdGErKzsKCQlpZiAoY2ggPT0gJ1xuJykgewoJCQljb3VudCsrOwoJCQlubF9qdXN0X3NlZW4gPSAxOwoJCQljb21wbGV0ZWx5X2VtcHR5ID0gMDsKCQl9CgkJZWxzZSB7CgkJCW5sX2p1c3Rfc2VlbiA9IDA7CgkJCWNvbXBsZXRlbHlfZW1wdHkgPSAwOwoJCX0KCX0KCWlmIChjb21wbGV0ZWx5X2VtcHR5KQoJCXJldHVybiAwOwoJaWYgKCFubF9qdXN0X3NlZW4pCgkJY291bnQrKzsgLyogbm8gdHJhaWxpbmcgbmV3bGluZSAqLwoJcmV0dXJuIGNvdW50Owp9CgpzdGF0aWMgdm9pZCBwcmludF9saW5lX2NvdW50KGludCBjb3VudCkKewoJc3dpdGNoIChjb3VudCkgewoJY2FzZSAwOgoJCXByaW50ZigiMCwwIik7CgkJYnJlYWs7CgljYXNlIDE6CgkJcHJpbnRmKCIxIik7CgkJYnJlYWs7CglkZWZhdWx0OgoJCXByaW50ZigiMSwlZCIsIGNvdW50KTsKCQlicmVhazsKCX0KfQoKc3RhdGljIHZvaWQgY29weV9maWxlKGludCBwcmVmaXgsIGNvbnN0IGNoYXIgKmRhdGEsIGludCBzaXplKQp7CglpbnQgY2gsIG5sX2p1c3Rfc2VlbiA9IDE7Cgl3aGlsZSAoMCA8IHNpemUtLSkgewoJCWNoID0gKmRhdGErKzsKCQlpZiAobmxfanVzdF9zZWVuKQoJCQlwdXRjaGFyKHByZWZpeCk7CgkJcHV0Y2hhcihjaCk7CgkJaWYgKGNoID09ICdcbicpCgkJCW5sX2p1c3Rfc2VlbiA9IDE7CgkJZWxzZQoJCQlubF9qdXN0X3NlZW4gPSAwOwoJfQoJaWYgKCFubF9qdXN0X3NlZW4pCgkJcHJpbnRmKCJcblxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGVcbiIpOwp9CgpzdGF0aWMgdm9pZCBlbWl0X3Jld3JpdGVfZGlmZihjb25zdCBjaGFyICpuYW1lX2EsCgkJCSAgICAgIGNvbnN0IGNoYXIgKm5hbWVfYiwKCQkJICAgICAgc3RydWN0IGRpZmZfZmlsZXNwZWMgKm9uZSwKCQkJICAgICAgc3RydWN0IGRpZmZfZmlsZXNwZWMgKnR3bykKewoJaW50IGxjX2EsIGxjX2I7CglkaWZmX3BvcHVsYXRlX2ZpbGVzcGVjKG9uZSwgMCk7CglkaWZmX3BvcHVsYXRlX2ZpbGVzcGVjKHR3bywgMCk7CglsY19hID0gY291bnRfbGluZXMob25lLT5kYXRhLCBvbmUtPnNpemUpOwoJbGNfYiA9IGNvdW50X2xpbmVzKHR3by0+ZGF0YSwgdHdvLT5zaXplKTsKCXByaW50ZigiLS0tICVzXG4rKysgJXNcbkBAIC0iLCBuYW1lX2EsIG5hbWVfYik7CglwcmludF9saW5lX2NvdW50KGxjX2EpOwoJcHJpbnRmKCIgKyIpOwoJcHJpbnRfbGluZV9jb3VudChsY19iKTsKCXByaW50ZigiIEBAXG4iKTsKCWlmIChsY19hKQoJCWNvcHlfZmlsZSgnLScsIG9uZS0+ZGF0YSwgb25lLT5zaXplKTsKCWlmIChsY19iKQoJCWNvcHlfZmlsZSgnKycsIHR3by0+ZGF0YSwgdHdvLT5zaXplKTsKfQoKc3RhdGljIGludCBmaWxsX21tZmlsZShtbWZpbGVfdCAqbWYsIHN0cnVjdCBkaWZmX2ZpbGVzcGVjICpvbmUpCnsKCWlmICghRElGRl9GSUxFX1ZBTElEKG9uZSkpIHsKCQltZi0+cHRyID0gIiI7IC8qIGRvZXMgbm90IG1hdHRlciAqLwoJCW1mLT5zaXplID0gMDsKCQlyZXR1cm4gMDsKCX0KCWVsc2UgaWYgKGRpZmZfcG9wdWxhdGVfZmlsZXNwZWMob25lLCAwKSkKCQlyZXR1cm4gLTE7CgltZi0+cHRyID0gb25lLT5kYXRhOwoJbWYtPnNpemUgPSBvbmUtPnNpemU7CglyZXR1cm4gMDsKfQoKc3RydWN0IGVtaXRfY2FsbGJhY2sgewoJY29uc3QgY2hhciAqKmxhYmVsX3BhdGg7Cn07CgpzdGF0aWMgaW50IGZuX291dCh2b2lkICpwcml2LCBtbWJ1ZmZlcl90ICptYiwgaW50IG5idWYpCnsKCWludCBpOwoJc3RydWN0IGVtaXRfY2FsbGJhY2sgKmVjYmRhdGEgPSBwcml2OwoKCWlmIChlY2JkYXRhLT5sYWJlbF9wYXRoWzBdKSB7CgkJcHJpbnRmKCItLS0gJXNcbiIsIGVjYmRhdGEtPmxhYmVsX3BhdGhbMF0pOwoJCXByaW50ZigiKysrICVzXG4iLCBlY2JkYXRhLT5sYWJlbF9wYXRoWzFdKTsKCQllY2JkYXRhLT5sYWJlbF9wYXRoWzBdID0gZWNiZGF0YS0+bGFiZWxfcGF0aFsxXSA9IE5VTEw7Cgl9Cglmb3IgKGkgPSAwOyBpIDwgbmJ1ZjsgaSsrKQoJCWlmICghZndyaXRlKG1iW2ldLnB0ciwgbWJbaV0uc2l6ZSwgMSwgc3Rkb3V0KSkKCQkJcmV0dXJuIC0xOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBjaGFyICpwcHJpbnRfcmVuYW1lKGNvbnN0IGNoYXIgKmEsIGNvbnN0IGNoYXIgKmIpCnsKCWNvbnN0IGNoYXIgKm9sZCA9IGE7Cgljb25zdCBjaGFyICpuZXcgPSBiOwoJY2hhciAqbmFtZSA9IE5VTEw7CglpbnQgcGZ4X2xlbmd0aCwgc2Z4X2xlbmd0aDsKCWludCBsZW5fYSA9IHN0cmxlbihhKTsKCWludCBsZW5fYiA9IHN0cmxlbihiKTsKCgkvKiBGaW5kIGNvbW1vbiBwcmVmaXggKi8KCXBmeF9sZW5ndGggPSAwOwoJd2hpbGUgKCpvbGQgJiYgKm5ldyAmJiAqb2xkID09ICpuZXcpIHsKCQlpZiAoKm9sZCA9PSAnLycpCgkJCXBmeF9sZW5ndGggPSBvbGQgLSBhICsgMTsKCQlvbGQrKzsKCQluZXcrKzsKCX0KCgkvKiBGaW5kIGNvbW1vbiBzdWZmaXggKi8KCW9sZCA9IGEgKyBsZW5fYTsKCW5ldyA9IGIgKyBsZW5fYjsKCXNmeF9sZW5ndGggPSAwOwoJd2hpbGUgKGEgPD0gb2xkICYmIGIgPD0gbmV3ICYmICpvbGQgPT0gKm5ldykgewoJCWlmICgqb2xkID09ICcvJykKCQkJc2Z4X2xlbmd0aCA9IGxlbl9hIC0gKG9sZCAtIGEpOwoJCW9sZC0tOwoJCW5ldy0tOwoJfQoKCS8qCgkgKiBwZnh7bWlkLWEgPT4gbWlkLWJ9c2Z4CgkgKiB7cGZ4LWEgPT4gcGZ4LWJ9c2Z4CgkgKiBwZnh7c2Z4LWEgPT4gc2Z4LWJ9CgkgKiBuYW1lLWEgPT4gbmFtZS1iCgkgKi8KCWlmIChwZnhfbGVuZ3RoICsgc2Z4X2xlbmd0aCkgewoJCW5hbWUgPSB4bWFsbG9jKGxlbl9hICsgbGVuX2IgLSBwZnhfbGVuZ3RoIC0gc2Z4X2xlbmd0aCArIDcpOwoJCXNwcmludGYobmFtZSwgIiUuKnN7JS4qcyA9PiAlLipzfSVzIiwKCQkJcGZ4X2xlbmd0aCwgYSwKCQkJbGVuX2EgLSBwZnhfbGVuZ3RoIC0gc2Z4X2xlbmd0aCwgYSArIHBmeF9sZW5ndGgsCgkJCWxlbl9iIC0gcGZ4X2xlbmd0aCAtIHNmeF9sZW5ndGgsIGIgKyBwZnhfbGVuZ3RoLAoJCQlhICsgbGVuX2EgLSBzZnhfbGVuZ3RoKTsKCX0KCWVsc2UgewoJCW5hbWUgPSB4bWFsbG9jKGxlbl9hICsgbGVuX2IgKyA1KTsKCQlzcHJpbnRmKG5hbWUsICIlcyA9PiAlcyIsIGEsIGIpOwoJfQoJcmV0dXJuIG5hbWU7Cn0KCnN0cnVjdCBkaWZmc3RhdF90IHsKCXN0cnVjdCB4ZGlmZl9lbWl0X3N0YXRlIHhtOwoKCWludCBucjsKCWludCBhbGxvYzsKCXN0cnVjdCBkaWZmc3RhdF9maWxlIHsKCQljaGFyICpuYW1lOwoJCXVuc2lnbmVkIGlzX3VubWVyZ2VkOjE7CgkJdW5zaWduZWQgaXNfYmluYXJ5OjE7CgkJdW5zaWduZWQgaXNfcmVuYW1lZDoxOwoJCXVuc2lnbmVkIGludCBhZGRlZCwgZGVsZXRlZDsKCX0gKipmaWxlczsKfTsKCnN0YXRpYyBzdHJ1Y3QgZGlmZnN0YXRfZmlsZSAqZGlmZnN0YXRfYWRkKHN0cnVjdCBkaWZmc3RhdF90ICpkaWZmc3RhdCwKCQkJCQkgIGNvbnN0IGNoYXIgKm5hbWVfYSwKCQkJCQkgIGNvbnN0IGNoYXIgKm5hbWVfYikKewoJc3RydWN0IGRpZmZzdGF0X2ZpbGUgKng7Cgl4ID0geGNhbGxvYyhzaXplb2YgKCp4KSwgMSk7CglpZiAoZGlmZnN0YXQtPm5yID09IGRpZmZzdGF0LT5hbGxvYykgewoJCWRpZmZzdGF0LT5hbGxvYyA9IGFsbG9jX25yKGRpZmZzdGF0LT5hbGxvYyk7CgkJZGlmZnN0YXQtPmZpbGVzID0geHJlYWxsb2MoZGlmZnN0YXQtPmZpbGVzLAoJCQkJZGlmZnN0YXQtPmFsbG9jICogc2l6ZW9mKHgpKTsKCX0KCWRpZmZzdGF0LT5maWxlc1tkaWZmc3RhdC0+bnIrK10gPSB4OwoJaWYgKG5hbWVfYikgewoJCXgtPm5hbWUgPSBwcHJpbnRfcmVuYW1lKG5hbWVfYSwgbmFtZV9iKTsKCQl4LT5pc19yZW5hbWVkID0gMTsKCX0KCWVsc2UKCQl4LT5uYW1lID0gc3RyZHVwKG5hbWVfYSk7CglyZXR1cm4geDsKfQoKc3RhdGljIHZvaWQgZGlmZnN0YXRfY29uc3VtZSh2b2lkICpwcml2LCBjaGFyICpsaW5lLCB1bnNpZ25lZCBsb25nIGxlbikKewoJc3RydWN0IGRpZmZzdGF0X3QgKmRpZmZzdGF0ID0gcHJpdjsKCXN0cnVjdCBkaWZmc3RhdF9maWxlICp4ID0gZGlmZnN0YXQtPmZpbGVzW2RpZmZzdGF0LT5uciAtIDFdOwoKCWlmIChsaW5lWzBdID09ICcrJykKCQl4LT5hZGRlZCsrOwoJZWxzZSBpZiAobGluZVswXSA9PSAnLScpCgkJeC0+ZGVsZXRlZCsrOwp9CgpzdGF0aWMgY29uc3QgY2hhciBwbHVzZXNbXSA9ICIrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrIjsKc3RhdGljIGNvbnN0IGNoYXIgbWludXNlc1tdPSAiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSI7CgpzdGF0aWMgdm9pZCBzaG93X3N0YXRzKHN0cnVjdCBkaWZmc3RhdF90KiBkYXRhKQp7CglpbnQgaSwgbGVuLCBhZGQsIGRlbCwgdG90YWwsIGFkZHMgPSAwLCBkZWxzID0gMDsKCWludCBtYXgsIG1heF9jaGFuZ2UgPSAwLCBtYXhfbGVuID0gMDsKCWludCB0b3RhbF9maWxlcyA9IGRhdGEtPm5yOwoKCWlmIChkYXRhLT5uciA9PSAwKQoJCXJldHVybjsKCglmb3IgKGkgPSAwOyBpIDwgZGF0YS0+bnI7IGkrKykgewoJCXN0cnVjdCBkaWZmc3RhdF9maWxlICpmaWxlID0gZGF0YS0+ZmlsZXNbaV07CgoJCWxlbiA9IHN0cmxlbihmaWxlLT5uYW1lKTsKCQlpZiAobWF4X2xlbiA8IGxlbikKCQkJbWF4X2xlbiA9IGxlbjsKCgkJaWYgKGZpbGUtPmlzX2JpbmFyeSB8fCBmaWxlLT5pc191bm1lcmdlZCkKCQkJY29udGludWU7CgkJaWYgKG1heF9jaGFuZ2UgPCBmaWxlLT5hZGRlZCArIGZpbGUtPmRlbGV0ZWQpCgkJCW1heF9jaGFuZ2UgPSBmaWxlLT5hZGRlZCArIGZpbGUtPmRlbGV0ZWQ7Cgl9CgoJZm9yIChpID0gMDsgaSA8IGRhdGEtPm5yOyBpKyspIHsKCQljaGFyICpwcmVmaXggPSAiIjsKCQljaGFyICpuYW1lID0gZGF0YS0+ZmlsZXNbaV0tPm5hbWU7CgkJaW50IGFkZGVkID0gZGF0YS0+ZmlsZXNbaV0tPmFkZGVkOwoJCWludCBkZWxldGVkID0gZGF0YS0+ZmlsZXNbaV0tPmRlbGV0ZWQ7CgoJCWlmICgwIDwgKGxlbiA9IHF1b3RlX2Nfc3R5bGUobmFtZSwgTlVMTCwgTlVMTCwgMCkpKSB7CgkJCWNoYXIgKnFuYW1lID0geG1hbGxvYyhsZW4gKyAxKTsKCQkJcXVvdGVfY19zdHlsZShuYW1lLCBxbmFtZSwgTlVMTCwgMCk7CgkJCWZyZWUobmFtZSk7CgkJCWRhdGEtPmZpbGVzW2ldLT5uYW1lID0gbmFtZSA9IHFuYW1lOwoJCX0KCgkJLyoKCQkgKiAic2NhbGUiIHRoZSBmaWxlbmFtZQoJCSAqLwoJCWxlbiA9IHN0cmxlbihuYW1lKTsKCQltYXggPSBtYXhfbGVuOwoJCWlmIChtYXggPiA1MCkKCQkJbWF4ID0gNTA7CgkJaWYgKGxlbiA+IG1heCkgewoJCQljaGFyICpzbGFzaDsKCQkJcHJlZml4ID0gIi4uLiI7CgkJCW1heCAtPSAzOwoJCQluYW1lICs9IGxlbiAtIG1heDsKCQkJc2xhc2ggPSBzdHJjaHIobmFtZSwgJy8nKTsKCQkJaWYgKHNsYXNoKQoJCQkJbmFtZSA9IHNsYXNoOwoJCX0KCQlsZW4gPSBtYXg7CgoJCS8qCgkJICogc2NhbGUgdGhlIGFkZC9kZWxldGUKCQkgKi8KCQltYXggPSBtYXhfY2hhbmdlOwoJCWlmIChtYXggKyBsZW4gPiA3MCkKCQkJbWF4ID0gNzAgLSBsZW47CgoJCWlmIChkYXRhLT5maWxlc1tpXS0+aXNfYmluYXJ5KSB7CgkJCXByaW50ZigiICVzJS0qcyB8ICBCaW5cbiIsIHByZWZpeCwgbGVuLCBuYW1lKTsKCQkJZ290byBmcmVlX2RpZmZzdGF0X2ZpbGU7CgkJfQoJCWVsc2UgaWYgKGRhdGEtPmZpbGVzW2ldLT5pc191bm1lcmdlZCkgewoJCQlwcmludGYoIiAlcyUtKnMgfCAgVW5tZXJnZWRcbiIsIHByZWZpeCwgbGVuLCBuYW1lKTsKCQkJZ290byBmcmVlX2RpZmZzdGF0X2ZpbGU7CgkJfQoJCWVsc2UgaWYgKCFkYXRhLT5maWxlc1tpXS0+aXNfcmVuYW1lZCAmJgoJCQkgKGFkZGVkICsgZGVsZXRlZCA9PSAwKSkgewoJCQl0b3RhbF9maWxlcy0tOwoJCQlnb3RvIGZyZWVfZGlmZnN0YXRfZmlsZTsKCQl9CgoJCWFkZCA9IGFkZGVkOwoJCWRlbCA9IGRlbGV0ZWQ7CgkJdG90YWwgPSBhZGQgKyBkZWw7CgkJYWRkcyArPSBhZGQ7CgkJZGVscyArPSBkZWw7CgoJCWlmIChtYXhfY2hhbmdlID4gMCkgewoJCQl0b3RhbCA9ICh0b3RhbCAqIG1heCArIG1heF9jaGFuZ2UgLyAyKSAvIG1heF9jaGFuZ2U7CgkJCWFkZCA9IChhZGQgKiBtYXggKyBtYXhfY2hhbmdlIC8gMikgLyBtYXhfY2hhbmdlOwoJCQlkZWwgPSB0b3RhbCAtIGFkZDsKCQl9CgkJcHJpbnRmKCIgJXMlLSpzIHwlNWQgJS4qcyUuKnNcbiIsIHByZWZpeCwKCQkJCWxlbiwgbmFtZSwgYWRkZWQgKyBkZWxldGVkLAoJCQkJYWRkLCBwbHVzZXMsIGRlbCwgbWludXNlcyk7CglmcmVlX2RpZmZzdGF0X2ZpbGU6CgkJZnJlZShkYXRhLT5maWxlc1tpXS0+bmFtZSk7CgkJZnJlZShkYXRhLT5maWxlc1tpXSk7Cgl9CglmcmVlKGRhdGEtPmZpbGVzKTsKCXByaW50ZigiICVkIGZpbGVzIGNoYW5nZWQsICVkIGluc2VydGlvbnMoKyksICVkIGRlbGV0aW9ucygtKVxuIiwKCQkJdG90YWxfZmlsZXMsIGFkZHMsIGRlbHMpOwp9CgpzdGF0aWMgdW5zaWduZWQgY2hhciAqZGVmbGF0ZV9pdChjaGFyICpkYXRhLAoJCQkJIHVuc2lnbmVkIGxvbmcgc2l6ZSwKCQkJCSB1bnNpZ25lZCBsb25nICpyZXN1bHRfc2l6ZSkKewoJaW50IGJvdW5kOwoJdW5zaWduZWQgY2hhciAqZGVmbGF0ZWQ7Cgl6X3N0cmVhbSBzdHJlYW07CgoJbWVtc2V0KCZzdHJlYW0sIDAsIHNpemVvZihzdHJlYW0pKTsKCWRlZmxhdGVJbml0KCZzdHJlYW0sIFpfQkVTVF9DT01QUkVTU0lPTik7Cglib3VuZCA9IGRlZmxhdGVCb3VuZCgmc3RyZWFtLCBzaXplKTsKCWRlZmxhdGVkID0geG1hbGxvYyhib3VuZCk7CglzdHJlYW0ubmV4dF9vdXQgPSBkZWZsYXRlZDsKCXN0cmVhbS5hdmFpbF9vdXQgPSBib3VuZDsKCglzdHJlYW0ubmV4dF9pbiA9ICh1bnNpZ25lZCBjaGFyICopZGF0YTsKCXN0cmVhbS5hdmFpbF9pbiA9IHNpemU7Cgl3aGlsZSAoZGVmbGF0ZSgmc3RyZWFtLCBaX0ZJTklTSCkgPT0gWl9PSykKCQk7IC8qIG5vdGhpbmcgKi8KCWRlZmxhdGVFbmQoJnN0cmVhbSk7CgkqcmVzdWx0X3NpemUgPSBzdHJlYW0udG90YWxfb3V0OwoJcmV0dXJuIGRlZmxhdGVkOwp9CgpzdGF0aWMgdm9pZCBlbWl0X2JpbmFyeV9kaWZmKG1tZmlsZV90ICpvbmUsIG1tZmlsZV90ICp0d28pCnsKCXZvaWQgKmNwOwoJdm9pZCAqZGVsdGE7Cgl2b2lkICpkZWZsYXRlZDsKCXZvaWQgKmRhdGE7Cgl1bnNpZ25lZCBsb25nIG9yaWdfc2l6ZTsKCXVuc2lnbmVkIGxvbmcgZGVsdGFfc2l6ZTsKCXVuc2lnbmVkIGxvbmcgZGVmbGF0ZV9zaXplOwoJdW5zaWduZWQgbG9uZyBkYXRhX3NpemU7CgoJcHJpbnRmKCJHSVQgYmluYXJ5IHBhdGNoXG4iKTsKCS8qIFdlIGNvdWxkIGRvIGRlZmxhdGVkIGRlbHRhLCBvciB3ZSBjb3VsZCBkbyBqdXN0IGRlZmxhdGVkIHR3bywKCSAqIHdoaWNoZXZlciBpcyBzbWFsbGVyLgoJICovCglkZWx0YSA9IE5VTEw7CglkZWZsYXRlZCA9IGRlZmxhdGVfaXQodHdvLT5wdHIsIHR3by0+c2l6ZSwgJmRlZmxhdGVfc2l6ZSk7CglpZiAob25lLT5zaXplICYmIHR3by0+c2l6ZSkgewoJCWRlbHRhID0gZGlmZl9kZWx0YShvbmUtPnB0ciwgb25lLT5zaXplLAoJCQkJICAgdHdvLT5wdHIsIHR3by0+c2l6ZSwKCQkJCSAgICZkZWx0YV9zaXplLCBkZWZsYXRlX3NpemUpOwoJCWlmIChkZWx0YSkgewoJCQl2b2lkICp0b19mcmVlID0gZGVsdGE7CgkJCW9yaWdfc2l6ZSA9IGRlbHRhX3NpemU7CgkJCWRlbHRhID0gZGVmbGF0ZV9pdChkZWx0YSwgZGVsdGFfc2l6ZSwgJmRlbHRhX3NpemUpOwoJCQlmcmVlKHRvX2ZyZWUpOwoJCX0KCX0KCglpZiAoZGVsdGEgJiYgZGVsdGFfc2l6ZSA8IGRlZmxhdGVfc2l6ZSkgewoJCXByaW50ZigiZGVsdGEgJWx1XG4iLCBvcmlnX3NpemUpOwoJCWZyZWUoZGVmbGF0ZWQpOwoJCWRhdGEgPSBkZWx0YTsKCQlkYXRhX3NpemUgPSBkZWx0YV9zaXplOwoJfQoJZWxzZSB7CgkJcHJpbnRmKCJsaXRlcmFsICVsdVxuIiwgdHdvLT5zaXplKTsKCQlmcmVlKGRlbHRhKTsKCQlkYXRhID0gZGVmbGF0ZWQ7CgkJZGF0YV9zaXplID0gZGVmbGF0ZV9zaXplOwoJfQoKCS8qIGVtaXQgZGF0YSBlbmNvZGVkIGluIGJhc2U4NSAqLwoJY3AgPSBkYXRhOwoJd2hpbGUgKGRhdGFfc2l6ZSkgewoJCWludCBieXRlcyA9ICg1MiA8IGRhdGFfc2l6ZSkgPyA1MiA6IGRhdGFfc2l6ZTsKCQljaGFyIGxpbmVbNzBdOwoJCWRhdGFfc2l6ZSAtPSBieXRlczsKCQlpZiAoYnl0ZXMgPD0gMjYpCgkJCWxpbmVbMF0gPSBieXRlcyArICdBJyAtIDE7CgkJZWxzZQoJCQlsaW5lWzBdID0gYnl0ZXMgLSAyNiArICdhJyAtIDE7CgkJZW5jb2RlXzg1KGxpbmUgKyAxLCBjcCwgYnl0ZXMpOwoJCWNwICs9IGJ5dGVzOwoJCXB1dHMobGluZSk7Cgl9CglwcmludGYoIlxuIik7CglmcmVlKGRhdGEpOwp9CgojZGVmaW5lIEZJUlNUX0ZFV19CWVRFUyA4MDAwCnN0YXRpYyBpbnQgbW1maWxlX2lzX2JpbmFyeShtbWZpbGVfdCAqbWYpCnsKCWxvbmcgc3ogPSBtZi0+c2l6ZTsKCWlmIChGSVJTVF9GRVdfQllURVMgPCBzeikKCQlzeiA9IEZJUlNUX0ZFV19CWVRFUzsKCWlmIChtZW1jaHIobWYtPnB0ciwgMCwgc3opKQoJCXJldHVybiAxOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGJ1aWx0aW5fZGlmZihjb25zdCBjaGFyICpuYW1lX2EsCgkJCSBjb25zdCBjaGFyICpuYW1lX2IsCgkJCSBzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqb25lLAoJCQkgc3RydWN0IGRpZmZfZmlsZXNwZWMgKnR3bywKCQkJIGNvbnN0IGNoYXIgKnhmcm1fbXNnLAoJCQkgc3RydWN0IGRpZmZfb3B0aW9ucyAqbywKCQkJIGludCBjb21wbGV0ZV9yZXdyaXRlKQp7CgltbWZpbGVfdCBtZjEsIG1mMjsKCWNvbnN0IGNoYXIgKmxibFsyXTsKCWNoYXIgKmFfb25lLCAqYl90d287CgoJYV9vbmUgPSBxdW90ZV90d28oImEvIiwgbmFtZV9hKTsKCWJfdHdvID0gcXVvdGVfdHdvKCJiLyIsIG5hbWVfYik7CglsYmxbMF0gPSBESUZGX0ZJTEVfVkFMSUQob25lKSA/IGFfb25lIDogIi9kZXYvbnVsbCI7CglsYmxbMV0gPSBESUZGX0ZJTEVfVkFMSUQodHdvKSA/IGJfdHdvIDogIi9kZXYvbnVsbCI7CglwcmludGYoImRpZmYgLS1naXQgJXMgJXNcbiIsIGFfb25lLCBiX3R3byk7CglpZiAobGJsWzBdWzBdID09ICcvJykgewoJCS8qIC9kZXYvbnVsbCAqLwoJCXByaW50ZigibmV3IGZpbGUgbW9kZSAlMDZvXG4iLCB0d28tPm1vZGUpOwoJCWlmICh4ZnJtX21zZyAmJiB4ZnJtX21zZ1swXSkKCQkJcHV0cyh4ZnJtX21zZyk7Cgl9CgllbHNlIGlmIChsYmxbMV1bMF0gPT0gJy8nKSB7CgkJcHJpbnRmKCJkZWxldGVkIGZpbGUgbW9kZSAlMDZvXG4iLCBvbmUtPm1vZGUpOwoJCWlmICh4ZnJtX21zZyAmJiB4ZnJtX21zZ1swXSkKCQkJcHV0cyh4ZnJtX21zZyk7Cgl9CgllbHNlIHsKCQlpZiAob25lLT5tb2RlICE9IHR3by0+bW9kZSkgewoJCQlwcmludGYoIm9sZCBtb2RlICUwNm9cbiIsIG9uZS0+bW9kZSk7CgkJCXByaW50ZigibmV3IG1vZGUgJTA2b1xuIiwgdHdvLT5tb2RlKTsKCQl9CgkJaWYgKHhmcm1fbXNnICYmIHhmcm1fbXNnWzBdKQoJCQlwdXRzKHhmcm1fbXNnKTsKCQkvKgoJCSAqIHdlIGRvIG5vdCBydW4gZGlmZiBiZXR3ZWVuIGRpZmZlcmVudCBraW5kCgkJICogb2Ygb2JqZWN0cy4KCQkgKi8KCQlpZiAoKG9uZS0+bW9kZSBeIHR3by0+bW9kZSkgJiBTX0lGTVQpCgkJCWdvdG8gZnJlZV9hYl9hbmRfcmV0dXJuOwoJCWlmIChjb21wbGV0ZV9yZXdyaXRlKSB7CgkJCWVtaXRfcmV3cml0ZV9kaWZmKG5hbWVfYSwgbmFtZV9iLCBvbmUsIHR3byk7CgkJCWdvdG8gZnJlZV9hYl9hbmRfcmV0dXJuOwoJCX0KCX0KCglpZiAoZmlsbF9tbWZpbGUoJm1mMSwgb25lKSA8IDAgfHwgZmlsbF9tbWZpbGUoJm1mMiwgdHdvKSA8IDApCgkJZGllKCJ1bmFibGUgdG8gcmVhZCBmaWxlcyB0byBkaWZmIik7CgoJaWYgKG1tZmlsZV9pc19iaW5hcnkoJm1mMSkgfHwgbW1maWxlX2lzX2JpbmFyeSgmbWYyKSkgewoJCS8qIFF1aXRlIGNvbW1vbiBjb25mdXNpbmcgY2FzZSAqLwoJCWlmIChtZjEuc2l6ZSA9PSBtZjIuc2l6ZSAmJgoJCSAgICAhbWVtY21wKG1mMS5wdHIsIG1mMi5wdHIsIG1mMS5zaXplKSkKCQkJZ290byBmcmVlX2FiX2FuZF9yZXR1cm47CgkJaWYgKG8tPmJpbmFyeSkKCQkJZW1pdF9iaW5hcnlfZGlmZigmbWYxLCAmbWYyKTsKCQllbHNlCgkJCXByaW50ZigiQmluYXJ5IGZpbGVzICVzIGFuZCAlcyBkaWZmZXJcbiIsCgkJCSAgICAgICBsYmxbMF0sIGxibFsxXSk7Cgl9CgllbHNlIHsKCQkvKiBDcmF6eSB4ZGwgaW50ZXJmYWNlcy4uICovCgkJY29uc3QgY2hhciAqZGlmZm9wdHMgPSBnZXRlbnYoIkdJVF9ESUZGX09QVFMiKTsKCQl4cHBhcmFtX3QgeHBwOwoJCXhkZW1pdGNvbmZfdCB4ZWNmZzsKCQl4ZGVtaXRjYl90IGVjYjsKCQlzdHJ1Y3QgZW1pdF9jYWxsYmFjayBlY2JkYXRhOwoKCQllY2JkYXRhLmxhYmVsX3BhdGggPSBsYmw7CgkJeHBwLmZsYWdzID0gWERGX05FRURfTUlOSU1BTDsKCQl4ZWNmZy5jdHhsZW4gPSAzOwoJCXhlY2ZnLmZsYWdzID0gWERMX0VNSVRfRlVOQ05BTUVTOwoJCWlmICghZGlmZm9wdHMpCgkJCTsKCQllbHNlIGlmICghc3RybmNtcChkaWZmb3B0cywgIi0tdW5pZmllZD0iLCAxMCkpCgkJCXhlY2ZnLmN0eGxlbiA9IHN0cnRvdWwoZGlmZm9wdHMgKyAxMCwgTlVMTCwgMTApOwoJCWVsc2UgaWYgKCFzdHJuY21wKGRpZmZvcHRzLCAiLXUiLCAyKSkKCQkJeGVjZmcuY3R4bGVuID0gc3RydG91bChkaWZmb3B0cyArIDIsIE5VTEwsIDEwKTsKCQllY2Iub3V0ZiA9IGZuX291dDsKCQllY2IucHJpdiA9ICZlY2JkYXRhOwoJCXhkbF9kaWZmKCZtZjEsICZtZjIsICZ4cHAsICZ4ZWNmZywgJmVjYik7Cgl9CgogZnJlZV9hYl9hbmRfcmV0dXJuOgoJZnJlZShhX29uZSk7CglmcmVlKGJfdHdvKTsKCXJldHVybjsKfQoKc3RhdGljIHZvaWQgYnVpbHRpbl9kaWZmc3RhdChjb25zdCBjaGFyICpuYW1lX2EsIGNvbnN0IGNoYXIgKm5hbWVfYiwKCQkJICAgICBzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqb25lLAoJCQkgICAgIHN0cnVjdCBkaWZmX2ZpbGVzcGVjICp0d28sCgkJCSAgICAgc3RydWN0IGRpZmZzdGF0X3QgKmRpZmZzdGF0LAoJCQkgICAgIGludCBjb21wbGV0ZV9yZXdyaXRlKQp7CgltbWZpbGVfdCBtZjEsIG1mMjsKCXN0cnVjdCBkaWZmc3RhdF9maWxlICpkYXRhOwoKCWRhdGEgPSBkaWZmc3RhdF9hZGQoZGlmZnN0YXQsIG5hbWVfYSwgbmFtZV9iKTsKCglpZiAoIW9uZSB8fCAhdHdvKSB7CgkJZGF0YS0+aXNfdW5tZXJnZWQgPSAxOwoJCXJldHVybjsKCX0KCWlmIChjb21wbGV0ZV9yZXdyaXRlKSB7CgkJZGlmZl9wb3B1bGF0ZV9maWxlc3BlYyhvbmUsIDApOwoJCWRpZmZfcG9wdWxhdGVfZmlsZXNwZWModHdvLCAwKTsKCQlkYXRhLT5kZWxldGVkID0gY291bnRfbGluZXMob25lLT5kYXRhLCBvbmUtPnNpemUpOwoJCWRhdGEtPmFkZGVkID0gY291bnRfbGluZXModHdvLT5kYXRhLCB0d28tPnNpemUpOwoJCXJldHVybjsKCX0KCWlmIChmaWxsX21tZmlsZSgmbWYxLCBvbmUpIDwgMCB8fCBmaWxsX21tZmlsZSgmbWYyLCB0d28pIDwgMCkKCQlkaWUoInVuYWJsZSB0byByZWFkIGZpbGVzIHRvIGRpZmYiKTsKCglpZiAobW1maWxlX2lzX2JpbmFyeSgmbWYxKSB8fCBtbWZpbGVfaXNfYmluYXJ5KCZtZjIpKQoJCWRhdGEtPmlzX2JpbmFyeSA9IDE7CgllbHNlIHsKCQkvKiBDcmF6eSB4ZGwgaW50ZXJmYWNlcy4uICovCgkJeHBwYXJhbV90IHhwcDsKCQl4ZGVtaXRjb25mX3QgeGVjZmc7CgkJeGRlbWl0Y2JfdCBlY2I7CgoJCXhwcC5mbGFncyA9IFhERl9ORUVEX01JTklNQUw7CgkJeGVjZmcuY3R4bGVuID0gMDsKCQl4ZWNmZy5mbGFncyA9IDA7CgkJZWNiLm91dGYgPSB4ZGlmZl9vdXRmOwoJCWVjYi5wcml2ID0gZGlmZnN0YXQ7CgkJeGRsX2RpZmYoJm1mMSwgJm1mMiwgJnhwcCwgJnhlY2ZnLCAmZWNiKTsKCX0KfQoKc3RydWN0IGRpZmZfZmlsZXNwZWMgKmFsbG9jX2ZpbGVzcGVjKGNvbnN0IGNoYXIgKnBhdGgpCnsKCWludCBuYW1lbGVuID0gc3RybGVuKHBhdGgpOwoJc3RydWN0IGRpZmZfZmlsZXNwZWMgKnNwZWMgPSB4bWFsbG9jKHNpemVvZigqc3BlYykgKyBuYW1lbGVuICsgMSk7CgoJbWVtc2V0KHNwZWMsIDAsIHNpemVvZigqc3BlYykpOwoJc3BlYy0+cGF0aCA9IChjaGFyICopKHNwZWMgKyAxKTsKCW1lbWNweShzcGVjLT5wYXRoLCBwYXRoLCBuYW1lbGVuKzEpOwoJcmV0dXJuIHNwZWM7Cn0KCnZvaWQgZmlsbF9maWxlc3BlYyhzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqc3BlYywgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkgICB1bnNpZ25lZCBzaG9ydCBtb2RlKQp7CglpZiAobW9kZSkgewoJCXNwZWMtPm1vZGUgPSBjYW5vbl9tb2RlKG1vZGUpOwoJCW1lbWNweShzcGVjLT5zaGExLCBzaGExLCAyMCk7CgkJc3BlYy0+c2hhMV92YWxpZCA9ICEhbWVtY21wKHNoYTEsIG51bGxfc2hhMSwgMjApOwoJfQp9CgovKgogKiBHaXZlbiBhIG5hbWUgYW5kIHNoYTEgcGFpciwgaWYgdGhlIGRpcmNhY2hlIHRlbGxzIHVzIHRoZSBmaWxlIGluCiAqIHRoZSB3b3JrIHRyZWUgaGFzIHRoYXQgb2JqZWN0IGNvbnRlbnRzLCByZXR1cm4gdHJ1ZSwgc28gdGhhdAogKiBwcmVwYXJlX3RlbXBfZmlsZSgpIGRvZXMgbm90IGhhdmUgdG8gaW5mbGF0ZSBhbmQgZXh0cmFjdC4KICovCnN0YXRpYyBpbnQgd29ya190cmVlX21hdGNoZXMoY29uc3QgY2hhciAqbmFtZSwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJc3RydWN0IGNhY2hlX2VudHJ5ICpjZTsKCXN0cnVjdCBzdGF0IHN0OwoJaW50IHBvcywgbGVuOwoKCS8qIFdlIGRvIG5vdCByZWFkIHRoZSBjYWNoZSBvdXJzZWx2ZXMgaGVyZSwgYmVjYXVzZSB0aGUKCSAqIGJlbmNobWFyayB3aXRoIG15IHByZXZpb3VzIHZlcnNpb24gdGhhdCBhbHdheXMgcmVhZHMgY2FjaGUKCSAqIHNob3dzIHRoYXQgaXQgbWFrZXMgdGhpbmdzIHdvcnNlIGZvciBkaWZmLXRyZWUgY29tcGFyaW5nCgkgKiB0d28gbGludXgtMi42IGtlcm5lbCB0cmVlcyBpbiBhbiBhbHJlYWR5IGNoZWNrZWQgb3V0IHdvcmsKCSAqIHRyZWUuICBUaGlzIGlzIGJlY2F1c2UgbW9zdCBkaWZmLXRyZWUgY29tcGFyaXNvbnMgZGVhbCB3aXRoCgkgKiBvbmx5IGEgc21hbGwgbnVtYmVyIG9mIGZpbGVzLCB3aGlsZSByZWFkaW5nIHRoZSBjYWNoZSBpcwoJICogZXhwZW5zaXZlIGZvciBhIGxhcmdlIHByb2plY3QsIGFuZCBpdHMgY29zdCBvdXR3ZWlnaHMgdGhlCgkgKiBzYXZpbmdzIHdlIGdldCBieSBub3QgaW5mbGF0aW5nIHRoZSBvYmplY3QgdG8gYSB0ZW1wb3JhcnkKCSAqIGZpbGUuICBQcmFjdGljYWxseSwgdGhpcyBjb2RlIG9ubHkgaGVscHMgd2hlbiB3ZSBhcmUgdXNlZAoJICogYnkgZGlmZi1jYWNoZSAtLWNhY2hlZCwgd2hpY2ggZG9lcyByZWFkIHRoZSBjYWNoZSBiZWZvcmUKCSAqIGNhbGxpbmcgdXMuCgkgKi8KCWlmICghYWN0aXZlX2NhY2hlKQoJCXJldHVybiAwOwoKCWxlbiA9IHN0cmxlbihuYW1lKTsKCXBvcyA9IGNhY2hlX25hbWVfcG9zKG5hbWUsIGxlbik7CglpZiAocG9zIDwgMCkKCQlyZXR1cm4gMDsKCWNlID0gYWN0aXZlX2NhY2hlW3Bvc107CglpZiAoKGxzdGF0KG5hbWUsICZzdCkgPCAwKSB8fAoJICAgICFTX0lTUkVHKHN0LnN0X21vZGUpIHx8IC8qIGNhcmVmdWwhICovCgkgICAgY2VfbWF0Y2hfc3RhdChjZSwgJnN0LCAwKSB8fAoJICAgIG1lbWNtcChzaGExLCBjZS0+c2hhMSwgMjApKQoJCXJldHVybiAwOwoJLyogd2UgcmV0dXJuIDEgb25seSB3aGVuIHdlIGNhbiBzdGF0LCBpdCBpcyBhIHJlZ3VsYXIgZmlsZSwKCSAqIHN0YXQgaW5mb3JtYXRpb24gbWF0Y2hlcywgYW5kIHNoYTEgcmVjb3JkZWQgaW4gdGhlIGNhY2hlCgkgKiBtYXRjaGVzLiAgSS5lLiB3ZSBrbm93IHRoZSBmaWxlIGluIHRoZSB3b3JrIHRyZWUgcmVhbGx5IGlzCgkgKiB0aGUgc2FtZSBhcyB0aGUgPG5hbWUsIHNoYTE+IHBhaXIuCgkgKi8KCXJldHVybiAxOwp9CgpzdGF0aWMgc3RydWN0IHNoYTFfc2l6ZV9jYWNoZSB7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJdW5zaWduZWQgbG9uZyBzaXplOwp9ICoqc2hhMV9zaXplX2NhY2hlOwpzdGF0aWMgaW50IHNoYTFfc2l6ZV9jYWNoZV9uciwgc2hhMV9zaXplX2NhY2hlX2FsbG9jOwoKc3RhdGljIHN0cnVjdCBzaGExX3NpemVfY2FjaGUgKmxvY2F0ZV9zaXplX2NhY2hlKHVuc2lnbmVkIGNoYXIgKnNoYTEsCgkJCQkJCSBpbnQgZmluZF9vbmx5LAoJCQkJCQkgdW5zaWduZWQgbG9uZyBzaXplKQp7CglpbnQgZmlyc3QsIGxhc3Q7CglzdHJ1Y3Qgc2hhMV9zaXplX2NhY2hlICplOwoKCWZpcnN0ID0gMDsKCWxhc3QgPSBzaGExX3NpemVfY2FjaGVfbnI7Cgl3aGlsZSAobGFzdCA+IGZpcnN0KSB7CgkJaW50IGNtcCwgbmV4dCA9IChsYXN0ICsgZmlyc3QpID4+IDE7CgkJZSA9IHNoYTFfc2l6ZV9jYWNoZVtuZXh0XTsKCQljbXAgPSBtZW1jbXAoZS0+c2hhMSwgc2hhMSwgMjApOwoJCWlmICghY21wKQoJCQlyZXR1cm4gZTsKCQlpZiAoY21wIDwgMCkgewoJCQlsYXN0ID0gbmV4dDsKCQkJY29udGludWU7CgkJfQoJCWZpcnN0ID0gbmV4dCsxOwoJfQoJLyogbm90IGZvdW5kICovCglpZiAoZmluZF9vbmx5KQoJCXJldHVybiBOVUxMOwoJLyogaW5zZXJ0IHRvIG1ha2UgaXQgYXQgImZpcnN0IiAqLwoJaWYgKHNoYTFfc2l6ZV9jYWNoZV9hbGxvYyA8PSBzaGExX3NpemVfY2FjaGVfbnIpIHsKCQlzaGExX3NpemVfY2FjaGVfYWxsb2MgPSBhbGxvY19ucihzaGExX3NpemVfY2FjaGVfYWxsb2MpOwoJCXNoYTFfc2l6ZV9jYWNoZSA9IHhyZWFsbG9jKHNoYTFfc2l6ZV9jYWNoZSwKCQkJCQkgICBzaGExX3NpemVfY2FjaGVfYWxsb2MgKgoJCQkJCSAgIHNpemVvZigqc2hhMV9zaXplX2NhY2hlKSk7Cgl9CglzaGExX3NpemVfY2FjaGVfbnIrKzsKCWlmIChmaXJzdCA8IHNoYTFfc2l6ZV9jYWNoZV9ucikKCQltZW1tb3ZlKHNoYTFfc2l6ZV9jYWNoZSArIGZpcnN0ICsgMSwgc2hhMV9zaXplX2NhY2hlICsgZmlyc3QsCgkJCShzaGExX3NpemVfY2FjaGVfbnIgLSBmaXJzdCAtIDEpICoKCQkJc2l6ZW9mKCpzaGExX3NpemVfY2FjaGUpKTsKCWUgPSB4bWFsbG9jKHNpemVvZihzdHJ1Y3Qgc2hhMV9zaXplX2NhY2hlKSk7CglzaGExX3NpemVfY2FjaGVbZmlyc3RdID0gZTsKCW1lbWNweShlLT5zaGExLCBzaGExLCAyMCk7CgllLT5zaXplID0gc2l6ZTsKCXJldHVybiBlOwp9CgovKgogKiBXaGlsZSBkb2luZyByZW5hbWUgZGV0ZWN0aW9uIGFuZCBwaWNrYXhlIG9wZXJhdGlvbiwgd2UgbWF5IG5lZWQgdG8KICogZ3JhYiB0aGUgZGF0YSBmb3IgdGhlIGJsb2IgKG9yIGZpbGUpIGZvciBvdXIgb3duIGluLWNvcmUgY29tcGFyaXNvbi4KICogZGlmZl9maWxlc3BlYyBoYXMgZGF0YSBhbmQgc2l6ZSBmaWVsZHMgZm9yIHRoaXMgcHVycG9zZS4KICovCmludCBkaWZmX3BvcHVsYXRlX2ZpbGVzcGVjKHN0cnVjdCBkaWZmX2ZpbGVzcGVjICpzLCBpbnQgc2l6ZV9vbmx5KQp7CglpbnQgZXJyID0gMDsKCWlmICghRElGRl9GSUxFX1ZBTElEKHMpKQoJCWRpZSgiaW50ZXJuYWwgZXJyb3I6IGFza2luZyB0byBwb3B1bGF0ZSBpbnZhbGlkIGZpbGUuIik7CglpZiAoU19JU0RJUihzLT5tb2RlKSkKCQlyZXR1cm4gLTE7CgoJaWYgKCF1c2Vfc2l6ZV9jYWNoZSkKCQlzaXplX29ubHkgPSAwOwoKCWlmIChzLT5kYXRhKQoJCXJldHVybiBlcnI7CglpZiAoIXMtPnNoYTFfdmFsaWQgfHwKCSAgICB3b3JrX3RyZWVfbWF0Y2hlcyhzLT5wYXRoLCBzLT5zaGExKSkgewoJCXN0cnVjdCBzdGF0IHN0OwoJCWludCBmZDsKCQlpZiAobHN0YXQocy0+cGF0aCwgJnN0KSA8IDApIHsKCQkJaWYgKGVycm5vID09IEVOT0VOVCkgewoJCQllcnJfZW1wdHk6CgkJCQllcnIgPSAtMTsKCQkJZW1wdHk6CgkJCQlzLT5kYXRhID0gIiI7CgkJCQlzLT5zaXplID0gMDsKCQkJCXJldHVybiBlcnI7CgkJCX0KCQl9CgkJcy0+c2l6ZSA9IHN0LnN0X3NpemU7CgkJaWYgKCFzLT5zaXplKQoJCQlnb3RvIGVtcHR5OwoJCWlmIChzaXplX29ubHkpCgkJCXJldHVybiAwOwoJCWlmIChTX0lTTE5LKHN0LnN0X21vZGUpKSB7CgkJCWludCByZXQ7CgkJCXMtPmRhdGEgPSB4bWFsbG9jKHMtPnNpemUpOwoJCQlzLT5zaG91bGRfZnJlZSA9IDE7CgkJCXJldCA9IHJlYWRsaW5rKHMtPnBhdGgsIHMtPmRhdGEsIHMtPnNpemUpOwoJCQlpZiAocmV0IDwgMCkgewoJCQkJZnJlZShzLT5kYXRhKTsKCQkJCWdvdG8gZXJyX2VtcHR5OwoJCQl9CgkJCXJldHVybiAwOwoJCX0KCQlmZCA9IG9wZW4ocy0+cGF0aCwgT19SRE9OTFkpOwoJCWlmIChmZCA8IDApCgkJCWdvdG8gZXJyX2VtcHR5OwoJCXMtPmRhdGEgPSBtbWFwKE5VTEwsIHMtPnNpemUsIFBST1RfUkVBRCwgTUFQX1BSSVZBVEUsIGZkLCAwKTsKCQljbG9zZShmZCk7CgkJaWYgKHMtPmRhdGEgPT0gTUFQX0ZBSUxFRCkKCQkJZ290byBlcnJfZW1wdHk7CgkJcy0+c2hvdWxkX211bm1hcCA9IDE7Cgl9CgllbHNlIHsKCQljaGFyIHR5cGVbMjBdOwoJCXN0cnVjdCBzaGExX3NpemVfY2FjaGUgKmU7CgoJCWlmIChzaXplX29ubHkpIHsKCQkJZSA9IGxvY2F0ZV9zaXplX2NhY2hlKHMtPnNoYTEsIDEsIDApOwoJCQlpZiAoZSkgewoJCQkJcy0+c2l6ZSA9IGUtPnNpemU7CgkJCQlyZXR1cm4gMDsKCQkJfQoJCQlpZiAoIXNoYTFfb2JqZWN0X2luZm8ocy0+c2hhMSwgdHlwZSwgJnMtPnNpemUpKQoJCQkJbG9jYXRlX3NpemVfY2FjaGUocy0+c2hhMSwgMCwgcy0+c2l6ZSk7CgkJfQoJCWVsc2UgewoJCQlzLT5kYXRhID0gcmVhZF9zaGExX2ZpbGUocy0+c2hhMSwgdHlwZSwgJnMtPnNpemUpOwoJCQlzLT5zaG91bGRfZnJlZSA9IDE7CgkJfQoJfQoJcmV0dXJuIDA7Cn0KCnZvaWQgZGlmZl9mcmVlX2ZpbGVzcGVjX2RhdGEoc3RydWN0IGRpZmZfZmlsZXNwZWMgKnMpCnsKCWlmIChzLT5zaG91bGRfZnJlZSkKCQlmcmVlKHMtPmRhdGEpOwoJZWxzZSBpZiAocy0+c2hvdWxkX211bm1hcCkKCQltdW5tYXAocy0+ZGF0YSwgcy0+c2l6ZSk7CglzLT5zaG91bGRfZnJlZSA9IHMtPnNob3VsZF9tdW5tYXAgPSAwOwoJcy0+ZGF0YSA9IE5VTEw7CglmcmVlKHMtPmNudF9kYXRhKTsKCXMtPmNudF9kYXRhID0gTlVMTDsKfQoKc3RhdGljIHZvaWQgcHJlcF90ZW1wX2Jsb2Ioc3RydWN0IGRpZmZfdGVtcGZpbGUgKnRlbXAsCgkJCSAgIHZvaWQgKmJsb2IsCgkJCSAgIHVuc2lnbmVkIGxvbmcgc2l6ZSwKCQkJICAgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkJICAgaW50IG1vZGUpCnsKCWludCBmZDsKCglmZCA9IGdpdF9ta3N0ZW1wKHRlbXAtPnRtcF9wYXRoLCBURU1QRklMRV9QQVRIX0xFTiwgIi5kaWZmX1hYWFhYWCIpOwoJaWYgKGZkIDwgMCkKCQlkaWUoInVuYWJsZSB0byBjcmVhdGUgdGVtcC1maWxlIik7CglpZiAod3JpdGUoZmQsIGJsb2IsIHNpemUpICE9IHNpemUpCgkJZGllKCJ1bmFibGUgdG8gd3JpdGUgdGVtcC1maWxlIik7CgljbG9zZShmZCk7Cgl0ZW1wLT5uYW1lID0gdGVtcC0+dG1wX3BhdGg7CglzdHJjcHkodGVtcC0+aGV4LCBzaGExX3RvX2hleChzaGExKSk7Cgl0ZW1wLT5oZXhbNDBdID0gMDsKCXNwcmludGYodGVtcC0+bW9kZSwgIiUwNm8iLCBtb2RlKTsKfQoKc3RhdGljIHZvaWQgcHJlcGFyZV90ZW1wX2ZpbGUoY29uc3QgY2hhciAqbmFtZSwKCQkJICAgICAgc3RydWN0IGRpZmZfdGVtcGZpbGUgKnRlbXAsCgkJCSAgICAgIHN0cnVjdCBkaWZmX2ZpbGVzcGVjICpvbmUpCnsKCWlmICghRElGRl9GSUxFX1ZBTElEKG9uZSkpIHsKCW5vdF9hX3ZhbGlkX2ZpbGU6CgkJLyogQSAnLScgZW50cnkgcHJvZHVjZXMgdGhpcyBmb3IgZmlsZS0yLCBhbmQKCQkgKiBhICcrJyBlbnRyeSBwcm9kdWNlcyB0aGlzIGZvciBmaWxlLTEuCgkJICovCgkJdGVtcC0+bmFtZSA9ICIvZGV2L251bGwiOwoJCXN0cmNweSh0ZW1wLT5oZXgsICIuIik7CgkJc3RyY3B5KHRlbXAtPm1vZGUsICIuIik7CgkJcmV0dXJuOwoJfQoKCWlmICghb25lLT5zaGExX3ZhbGlkIHx8CgkgICAgd29ya190cmVlX21hdGNoZXMobmFtZSwgb25lLT5zaGExKSkgewoJCXN0cnVjdCBzdGF0IHN0OwoJCWlmIChsc3RhdChuYW1lLCAmc3QpIDwgMCkgewoJCQlpZiAoZXJybm8gPT0gRU5PRU5UKQoJCQkJZ290byBub3RfYV92YWxpZF9maWxlOwoJCQlkaWUoInN0YXQoJXMpOiAlcyIsIG5hbWUsIHN0cmVycm9yKGVycm5vKSk7CgkJfQoJCWlmIChTX0lTTE5LKHN0LnN0X21vZGUpKSB7CgkJCWludCByZXQ7CgkJCWNoYXIgYnVmW1BBVEhfTUFYICsgMV07IC8qIG91Z2h0IHRvIGJlIFNZTUxJTktfTUFYICovCgkJCWlmIChzaXplb2YoYnVmKSA8PSBzdC5zdF9zaXplKQoJCQkJZGllKCJzeW1saW5rIHRvbyBsb25nOiAlcyIsIG5hbWUpOwoJCQlyZXQgPSByZWFkbGluayhuYW1lLCBidWYsIHN0LnN0X3NpemUpOwoJCQlpZiAocmV0IDwgMCkKCQkJCWRpZSgicmVhZGxpbmsoJXMpIiwgbmFtZSk7CgkJCXByZXBfdGVtcF9ibG9iKHRlbXAsIGJ1Ziwgc3Quc3Rfc2l6ZSwKCQkJCSAgICAgICAob25lLT5zaGExX3ZhbGlkID8KCQkJCQlvbmUtPnNoYTEgOiBudWxsX3NoYTEpLAoJCQkJICAgICAgIChvbmUtPnNoYTFfdmFsaWQgPwoJCQkJCW9uZS0+bW9kZSA6IFNfSUZMTkspKTsKCQl9CgkJZWxzZSB7CgkJCS8qIHdlIGNhbiBib3Jyb3cgZnJvbSB0aGUgZmlsZSBpbiB0aGUgd29yayB0cmVlICovCgkJCXRlbXAtPm5hbWUgPSBuYW1lOwoJCQlpZiAoIW9uZS0+c2hhMV92YWxpZCkKCQkJCXN0cmNweSh0ZW1wLT5oZXgsIHNoYTFfdG9faGV4KG51bGxfc2hhMSkpOwoJCQllbHNlCgkJCQlzdHJjcHkodGVtcC0+aGV4LCBzaGExX3RvX2hleChvbmUtPnNoYTEpKTsKCQkJLyogRXZlbiB0aG91Z2ggd2UgbWF5IHNvbWV0aW1lcyBib3Jyb3cgdGhlCgkJCSAqIGNvbnRlbnRzIGZyb20gdGhlIHdvcmsgdHJlZSwgd2UgYWx3YXlzIHdhbnQKCQkJICogb25lLT5tb2RlLiAgbW9kZSBpcyB0cnVzdHdvcnRoeSBldmVuIHdoZW4KCQkJICogIShvbmUtPnNoYTFfdmFsaWQpLCBhcyBsb25nIGFzCgkJCSAqIERJRkZfRklMRV9WQUxJRChvbmUpLgoJCQkgKi8KCQkJc3ByaW50Zih0ZW1wLT5tb2RlLCAiJTA2byIsIG9uZS0+bW9kZSk7CgkJfQoJCXJldHVybjsKCX0KCWVsc2UgewoJCWlmIChkaWZmX3BvcHVsYXRlX2ZpbGVzcGVjKG9uZSwgMCkpCgkJCWRpZSgiY2Fubm90IHJlYWQgZGF0YSBibG9iIGZvciAlcyIsIG9uZS0+cGF0aCk7CgkJcHJlcF90ZW1wX2Jsb2IodGVtcCwgb25lLT5kYXRhLCBvbmUtPnNpemUsCgkJCSAgICAgICBvbmUtPnNoYTEsIG9uZS0+bW9kZSk7Cgl9Cn0KCnN0YXRpYyB2b2lkIHJlbW92ZV90ZW1wZmlsZSh2b2lkKQp7CglpbnQgaTsKCglmb3IgKGkgPSAwOyBpIDwgMjsgaSsrKQoJCWlmIChkaWZmX3RlbXBbaV0ubmFtZSA9PSBkaWZmX3RlbXBbaV0udG1wX3BhdGgpIHsKCQkJdW5saW5rKGRpZmZfdGVtcFtpXS5uYW1lKTsKCQkJZGlmZl90ZW1wW2ldLm5hbWUgPSBOVUxMOwoJCX0KfQoKc3RhdGljIHZvaWQgcmVtb3ZlX3RlbXBmaWxlX29uX3NpZ25hbChpbnQgc2lnbm8pCnsKCXJlbW92ZV90ZW1wZmlsZSgpOwoJc2lnbmFsKFNJR0lOVCwgU0lHX0RGTCk7CglyYWlzZShzaWdubyk7Cn0KCnN0YXRpYyBpbnQgc3Bhd25fcHJvZyhjb25zdCBjaGFyICpwZ20sIGNvbnN0IGNoYXIgKiphcmcpCnsKCXBpZF90IHBpZDsKCWludCBzdGF0dXM7CgoJZmZsdXNoKE5VTEwpOwoJcGlkID0gZm9yaygpOwoJaWYgKHBpZCA8IDApCgkJZGllKCJ1bmFibGUgdG8gZm9yayIpOwoJaWYgKCFwaWQpIHsKCQlleGVjdnAocGdtLCAoY2hhciAqY29uc3QqKSBhcmcpOwoJCWV4aXQoMjU1KTsKCX0KCgl3aGlsZSAod2FpdHBpZChwaWQsICZzdGF0dXMsIDApIDwgMCkgewoJCWlmIChlcnJubyA9PSBFSU5UUikKCQkJY29udGludWU7CgkJcmV0dXJuIC0xOwoJfQoKCS8qIEVhcmxpZXIgd2UgZGlkIG5vdCBjaGVjayB0aGUgZXhpdCBzdGF0dXMgYmVjYXVzZQoJICogZGlmZiBleGl0cyBub24temVybyBpZiBmaWxlcyBhcmUgZGlmZmVyZW50LCBhbmQKCSAqIHdlIGFyZSBub3QgaW50ZXJlc3RlZCBpbiBrbm93aW5nIHRoYXQuICBJdCB3YXMgYQoJICogbWlzdGFrZSB3aGljaCBtYWRlIGl0IGhhcmRlciB0byBxdWl0IGEgZGlmZi0qCgkgKiBzZXNzaW9uIHRoYXQgdXNlcyB0aGUgZ2l0LWFwcGx5LXBhdGNoLXNjcmlwdCBhcwoJICogdGhlIEdJVF9FWFRFUk5BTF9ESUZGLiAgQSBjdXN0b20gR0lUX0VYVEVSTkFMX0RJRkYKCSAqIHNob3VsZCBhbHNvIGV4aXQgbm9uLXplcm8gb25seSB3aGVuIGl0IHdhbnRzIHRvCgkgKiBhYm9ydCB0aGUgZW50aXJlIGRpZmYtKiBzZXNzaW9uLgoJICovCglpZiAoV0lGRVhJVEVEKHN0YXR1cykgJiYgIVdFWElUU1RBVFVTKHN0YXR1cykpCgkJcmV0dXJuIDA7CglyZXR1cm4gLTE7Cn0KCi8qIEFuIGV4dGVybmFsIGRpZmYgY29tbWFuZCB0YWtlczoKICoKICogZGlmZi1jbWQgbmFtZSBpbmZpbGUxIGluZmlsZTEtc2hhMSBpbmZpbGUxLW1vZGUgXAogKiAgICAgICAgICAgICAgIGluZmlsZTIgaW5maWxlMi1zaGExIGluZmlsZTItbW9kZSBbIHJlbmFtZS10byBdCiAqCiAqLwpzdGF0aWMgdm9pZCBydW5fZXh0ZXJuYWxfZGlmZihjb25zdCBjaGFyICpwZ20sCgkJCSAgICAgIGNvbnN0IGNoYXIgKm5hbWUsCgkJCSAgICAgIGNvbnN0IGNoYXIgKm90aGVyLAoJCQkgICAgICBzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqb25lLAoJCQkgICAgICBzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqdHdvLAoJCQkgICAgICBjb25zdCBjaGFyICp4ZnJtX21zZywKCQkJICAgICAgaW50IGNvbXBsZXRlX3Jld3JpdGUpCnsKCWNvbnN0IGNoYXIgKnNwYXduX2FyZ1sxMF07CglzdHJ1Y3QgZGlmZl90ZW1wZmlsZSAqdGVtcCA9IGRpZmZfdGVtcDsKCWludCByZXR2YWw7CglzdGF0aWMgaW50IGF0ZXhpdF9hc2tlZCA9IDA7Cgljb25zdCBjaGFyICpvdGhlcm5hbWU7Cgljb25zdCBjaGFyICoqYXJnID0gJnNwYXduX2FyZ1swXTsKCglvdGhlcm5hbWUgPSAob3RoZXI/IG90aGVyIDogbmFtZSk7CglpZiAob25lICYmIHR3bykgewoJCXByZXBhcmVfdGVtcF9maWxlKG5hbWUsICZ0ZW1wWzBdLCBvbmUpOwoJCXByZXBhcmVfdGVtcF9maWxlKG90aGVybmFtZSwgJnRlbXBbMV0sIHR3byk7CgkJaWYgKCEgYXRleGl0X2Fza2VkICYmCgkJICAgICh0ZW1wWzBdLm5hbWUgPT0gdGVtcFswXS50bXBfcGF0aCB8fAoJCSAgICAgdGVtcFsxXS5uYW1lID09IHRlbXBbMV0udG1wX3BhdGgpKSB7CgkJCWF0ZXhpdF9hc2tlZCA9IDE7CgkJCWF0ZXhpdChyZW1vdmVfdGVtcGZpbGUpOwoJCX0KCQlzaWduYWwoU0lHSU5ULCByZW1vdmVfdGVtcGZpbGVfb25fc2lnbmFsKTsKCX0KCglpZiAob25lICYmIHR3bykgewoJCSphcmcrKyA9IHBnbTsKCQkqYXJnKysgPSBuYW1lOwoJCSphcmcrKyA9IHRlbXBbMF0ubmFtZTsKCQkqYXJnKysgPSB0ZW1wWzBdLmhleDsKCQkqYXJnKysgPSB0ZW1wWzBdLm1vZGU7CgkJKmFyZysrID0gdGVtcFsxXS5uYW1lOwoJCSphcmcrKyA9IHRlbXBbMV0uaGV4OwoJCSphcmcrKyA9IHRlbXBbMV0ubW9kZTsKCQlpZiAob3RoZXIpIHsKCQkJKmFyZysrID0gb3RoZXI7CgkJCSphcmcrKyA9IHhmcm1fbXNnOwoJCX0KCX0gZWxzZSB7CgkJKmFyZysrID0gcGdtOwoJCSphcmcrKyA9IG5hbWU7Cgl9CgkqYXJnID0gTlVMTDsKCXJldHZhbCA9IHNwYXduX3Byb2cocGdtLCBzcGF3bl9hcmcpOwoJcmVtb3ZlX3RlbXBmaWxlKCk7CglpZiAocmV0dmFsKSB7CgkJZnByaW50ZihzdGRlcnIsICJleHRlcm5hbCBkaWZmIGRpZWQsIHN0b3BwaW5nIGF0ICVzLlxuIiwgbmFtZSk7CgkJZXhpdCgxKTsKCX0KfQoKc3RhdGljIHZvaWQgcnVuX2RpZmZfY21kKGNvbnN0IGNoYXIgKnBnbSwKCQkJIGNvbnN0IGNoYXIgKm5hbWUsCgkJCSBjb25zdCBjaGFyICpvdGhlciwKCQkJIHN0cnVjdCBkaWZmX2ZpbGVzcGVjICpvbmUsCgkJCSBzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqdHdvLAoJCQkgY29uc3QgY2hhciAqeGZybV9tc2csCgkJCSBzdHJ1Y3QgZGlmZl9vcHRpb25zICpvLAoJCQkgaW50IGNvbXBsZXRlX3Jld3JpdGUpCnsKCWlmIChwZ20pIHsKCQlydW5fZXh0ZXJuYWxfZGlmZihwZ20sIG5hbWUsIG90aGVyLCBvbmUsIHR3bywgeGZybV9tc2csCgkJCQkgIGNvbXBsZXRlX3Jld3JpdGUpOwoJCXJldHVybjsKCX0KCWlmIChvbmUgJiYgdHdvKQoJCWJ1aWx0aW5fZGlmZihuYW1lLCBvdGhlciA/IG90aGVyIDogbmFtZSwKCQkJICAgICBvbmUsIHR3bywgeGZybV9tc2csIG8sIGNvbXBsZXRlX3Jld3JpdGUpOwoJZWxzZQoJCXByaW50ZigiKiBVbm1lcmdlZCBwYXRoICVzXG4iLCBuYW1lKTsKfQoKc3RhdGljIHZvaWQgZGlmZl9maWxsX3NoYTFfaW5mbyhzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqb25lKQp7CglpZiAoRElGRl9GSUxFX1ZBTElEKG9uZSkpIHsKCQlpZiAoIW9uZS0+c2hhMV92YWxpZCkgewoJCQlzdHJ1Y3Qgc3RhdCBzdDsKCQkJaWYgKGxzdGF0KG9uZS0+cGF0aCwgJnN0KSA8IDApCgkJCQlkaWUoInN0YXQgJXMiLCBvbmUtPnBhdGgpOwoJCQlpZiAoaW5kZXhfcGF0aChvbmUtPnNoYTEsIG9uZS0+cGF0aCwgJnN0LCAwKSkKCQkJCWRpZSgiY2Fubm90IGhhc2ggJXNcbiIsIG9uZS0+cGF0aCk7CgkJfQoJfQoJZWxzZQoJCW1lbXNldChvbmUtPnNoYTEsIDAsIDIwKTsKfQoKc3RhdGljIHZvaWQgcnVuX2RpZmYoc3RydWN0IGRpZmZfZmlsZXBhaXIgKnAsIHN0cnVjdCBkaWZmX29wdGlvbnMgKm8pCnsKCWNvbnN0IGNoYXIgKnBnbSA9IGV4dGVybmFsX2RpZmYoKTsKCWNoYXIgbXNnW1BBVEhfTUFYKjIrMzAwXSwgKnhmcm1fbXNnOwoJc3RydWN0IGRpZmZfZmlsZXNwZWMgKm9uZTsKCXN0cnVjdCBkaWZmX2ZpbGVzcGVjICp0d287Cgljb25zdCBjaGFyICpuYW1lOwoJY29uc3QgY2hhciAqb3RoZXI7CgljaGFyICpuYW1lX211bmdlZCwgKm90aGVyX211bmdlZDsKCWludCBjb21wbGV0ZV9yZXdyaXRlID0gMDsKCWludCBsZW47CgoJaWYgKERJRkZfUEFJUl9VTk1FUkdFRChwKSkgewoJCS8qIHVubWVyZ2VkICovCgkJcnVuX2RpZmZfY21kKHBnbSwgcC0+b25lLT5wYXRoLCBOVUxMLCBOVUxMLCBOVUxMLCBOVUxMLCBvLCAwKTsKCQlyZXR1cm47Cgl9CgoJbmFtZSA9IHAtPm9uZS0+cGF0aDsKCW90aGVyID0gKHN0cmNtcChuYW1lLCBwLT50d28tPnBhdGgpID8gcC0+dHdvLT5wYXRoIDogTlVMTCk7CgluYW1lX211bmdlZCA9IHF1b3RlX29uZShuYW1lKTsKCW90aGVyX211bmdlZCA9IHF1b3RlX29uZShvdGhlcik7CglvbmUgPSBwLT5vbmU7IHR3byA9IHAtPnR3bzsKCglkaWZmX2ZpbGxfc2hhMV9pbmZvKG9uZSk7CglkaWZmX2ZpbGxfc2hhMV9pbmZvKHR3byk7CgoJbGVuID0gMDsKCXN3aXRjaCAocC0+c3RhdHVzKSB7CgljYXNlIERJRkZfU1RBVFVTX0NPUElFRDoKCQlsZW4gKz0gc25wcmludGYobXNnICsgbGVuLCBzaXplb2YobXNnKSAtIGxlbiwKCQkJCSJzaW1pbGFyaXR5IGluZGV4ICVkJSVcbiIKCQkJCSJjb3B5IGZyb20gJXNcbiIKCQkJCSJjb3B5IHRvICVzXG4iLAoJCQkJKGludCkoMC41ICsgcC0+c2NvcmUgKiAxMDAuMC9NQVhfU0NPUkUpLAoJCQkJbmFtZV9tdW5nZWQsIG90aGVyX211bmdlZCk7CgkJYnJlYWs7CgljYXNlIERJRkZfU1RBVFVTX1JFTkFNRUQ6CgkJbGVuICs9IHNucHJpbnRmKG1zZyArIGxlbiwgc2l6ZW9mKG1zZykgLSBsZW4sCgkJCQkic2ltaWxhcml0eSBpbmRleCAlZCUlXG4iCgkJCQkicmVuYW1lIGZyb20gJXNcbiIKCQkJCSJyZW5hbWUgdG8gJXNcbiIsCgkJCQkoaW50KSgwLjUgKyBwLT5zY29yZSAqIDEwMC4wL01BWF9TQ09SRSksCgkJCQluYW1lX211bmdlZCwgb3RoZXJfbXVuZ2VkKTsKCQlicmVhazsKCWNhc2UgRElGRl9TVEFUVVNfTU9ESUZJRUQ6CgkJaWYgKHAtPnNjb3JlKSB7CgkJCWxlbiArPSBzbnByaW50Zihtc2cgKyBsZW4sIHNpemVvZihtc2cpIC0gbGVuLAoJCQkJCSJkaXNzaW1pbGFyaXR5IGluZGV4ICVkJSVcbiIsCgkJCQkJKGludCkoMC41ICsgcC0+c2NvcmUgKgoJCQkJCSAgICAgIDEwMC4wL01BWF9TQ09SRSkpOwoJCQljb21wbGV0ZV9yZXdyaXRlID0gMTsKCQkJYnJlYWs7CgkJfQoJCS8qIGZhbGx0aHJ1ICovCglkZWZhdWx0OgoJCS8qIG5vdGhpbmcgKi8KCQk7Cgl9CgoJaWYgKG1lbWNtcChvbmUtPnNoYTEsIHR3by0+c2hhMSwgMjApKSB7CgkJaW50IGFiYnJldiA9IG8tPmZ1bGxfaW5kZXggPyA0MCA6IERFRkFVTFRfQUJCUkVWOwoKCQlsZW4gKz0gc25wcmludGYobXNnICsgbGVuLCBzaXplb2YobXNnKSAtIGxlbiwKCQkJCSJpbmRleCAlLipzLi4lLipzIiwKCQkJCWFiYnJldiwgc2hhMV90b19oZXgob25lLT5zaGExKSwKCQkJCWFiYnJldiwgc2hhMV90b19oZXgodHdvLT5zaGExKSk7CgkJaWYgKG9uZS0+bW9kZSA9PSB0d28tPm1vZGUpCgkJCWxlbiArPSBzbnByaW50Zihtc2cgKyBsZW4sIHNpemVvZihtc2cpIC0gbGVuLAoJCQkJCSIgJTA2byIsIG9uZS0+bW9kZSk7CgkJbGVuICs9IHNucHJpbnRmKG1zZyArIGxlbiwgc2l6ZW9mKG1zZykgLSBsZW4sICJcbiIpOwoJfQoKCWlmIChsZW4pCgkJbXNnWy0tbGVuXSA9IDA7Cgl4ZnJtX21zZyA9IGxlbiA/IG1zZyA6IE5VTEw7CgoJaWYgKCFwZ20gJiYKCSAgICBESUZGX0ZJTEVfVkFMSUQob25lKSAmJiBESUZGX0ZJTEVfVkFMSUQodHdvKSAmJgoJICAgIChTX0lGTVQgJiBvbmUtPm1vZGUpICE9IChTX0lGTVQgJiB0d28tPm1vZGUpKSB7CgkJLyogYSBmaWxlcGFpciB0aGF0IGNoYW5nZXMgYmV0d2VlbiBmaWxlIGFuZCBzeW1saW5rCgkJICogbmVlZHMgdG8gYmUgc3BsaXQgaW50byBkZWxldGlvbiBhbmQgY3JlYXRpb24uCgkJICovCgkJc3RydWN0IGRpZmZfZmlsZXNwZWMgKm51bGwgPSBhbGxvY19maWxlc3BlYyh0d28tPnBhdGgpOwoJCXJ1bl9kaWZmX2NtZChOVUxMLCBuYW1lLCBvdGhlciwgb25lLCBudWxsLCB4ZnJtX21zZywgbywgMCk7CgkJZnJlZShudWxsKTsKCQludWxsID0gYWxsb2NfZmlsZXNwZWMob25lLT5wYXRoKTsKCQlydW5fZGlmZl9jbWQoTlVMTCwgbmFtZSwgb3RoZXIsIG51bGwsIHR3bywgeGZybV9tc2csIG8sIDApOwoJCWZyZWUobnVsbCk7Cgl9CgllbHNlCgkJcnVuX2RpZmZfY21kKHBnbSwgbmFtZSwgb3RoZXIsIG9uZSwgdHdvLCB4ZnJtX21zZywgbywKCQkJICAgICBjb21wbGV0ZV9yZXdyaXRlKTsKCglmcmVlKG5hbWVfbXVuZ2VkKTsKCWZyZWUob3RoZXJfbXVuZ2VkKTsKfQoKc3RhdGljIHZvaWQgcnVuX2RpZmZzdGF0KHN0cnVjdCBkaWZmX2ZpbGVwYWlyICpwLCBzdHJ1Y3QgZGlmZl9vcHRpb25zICpvLAoJCQkgc3RydWN0IGRpZmZzdGF0X3QgKmRpZmZzdGF0KQp7Cgljb25zdCBjaGFyICpuYW1lOwoJY29uc3QgY2hhciAqb3RoZXI7CglpbnQgY29tcGxldGVfcmV3cml0ZSA9IDA7CgoJaWYgKERJRkZfUEFJUl9VTk1FUkdFRChwKSkgewoJCS8qIHVubWVyZ2VkICovCgkJYnVpbHRpbl9kaWZmc3RhdChwLT5vbmUtPnBhdGgsIE5VTEwsIE5VTEwsIE5VTEwsIGRpZmZzdGF0LCAwKTsKCQlyZXR1cm47Cgl9CgoJbmFtZSA9IHAtPm9uZS0+cGF0aDsKCW90aGVyID0gKHN0cmNtcChuYW1lLCBwLT50d28tPnBhdGgpID8gcC0+dHdvLT5wYXRoIDogTlVMTCk7CgoJZGlmZl9maWxsX3NoYTFfaW5mbyhwLT5vbmUpOwoJZGlmZl9maWxsX3NoYTFfaW5mbyhwLT50d28pOwoKCWlmIChwLT5zdGF0dXMgPT0gRElGRl9TVEFUVVNfTU9ESUZJRUQgJiYgcC0+c2NvcmUpCgkJY29tcGxldGVfcmV3cml0ZSA9IDE7CglidWlsdGluX2RpZmZzdGF0KG5hbWUsIG90aGVyLCBwLT5vbmUsIHAtPnR3bywgZGlmZnN0YXQsIGNvbXBsZXRlX3Jld3JpdGUpOwp9Cgp2b2lkIGRpZmZfc2V0dXAoc3RydWN0IGRpZmZfb3B0aW9ucyAqb3B0aW9ucykKewoJbWVtc2V0KG9wdGlvbnMsIDAsIHNpemVvZigqb3B0aW9ucykpOwoJb3B0aW9ucy0+b3V0cHV0X2Zvcm1hdCA9IERJRkZfRk9STUFUX1JBVzsKCW9wdGlvbnMtPmxpbmVfdGVybWluYXRpb24gPSAnXG4nOwoJb3B0aW9ucy0+YnJlYWtfb3B0ID0gLTE7CglvcHRpb25zLT5yZW5hbWVfbGltaXQgPSAtMTsKCglvcHRpb25zLT5jaGFuZ2UgPSBkaWZmX2NoYW5nZTsKCW9wdGlvbnMtPmFkZF9yZW1vdmUgPSBkaWZmX2FkZHJlbW92ZTsKfQoKaW50IGRpZmZfc2V0dXBfZG9uZShzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHRpb25zKQp7CglpZiAoKG9wdGlvbnMtPmZpbmRfY29waWVzX2hhcmRlciAmJgoJICAgICBvcHRpb25zLT5kZXRlY3RfcmVuYW1lICE9IERJRkZfREVURUNUX0NPUFkpIHx8CgkgICAgKDAgPD0gb3B0aW9ucy0+cmVuYW1lX2xpbWl0ICYmICFvcHRpb25zLT5kZXRlY3RfcmVuYW1lKSkKCQlyZXR1cm4gLTE7CgoJLyoKCSAqIFRoZXNlIGNhc2VzIGFsd2F5cyBuZWVkIHJlY3Vyc2l2ZTsgd2UgZG8gbm90IGRyb3AgY2FsbGVyLXN1cHBsaWVkCgkgKiByZWN1cnNpdmUgYml0cyBmb3Igb3RoZXIgZm9ybWF0cyBoZXJlLgoJICovCglpZiAoKG9wdGlvbnMtPm91dHB1dF9mb3JtYXQgPT0gRElGRl9GT1JNQVRfUEFUQ0gpIHx8CgkgICAgKG9wdGlvbnMtPm91dHB1dF9mb3JtYXQgPT0gRElGRl9GT1JNQVRfRElGRlNUQVQpKQoJCW9wdGlvbnMtPnJlY3Vyc2l2ZSA9IDE7CgoJaWYgKG9wdGlvbnMtPmRldGVjdF9yZW5hbWUgJiYgb3B0aW9ucy0+cmVuYW1lX2xpbWl0IDwgMCkKCQlvcHRpb25zLT5yZW5hbWVfbGltaXQgPSBkaWZmX3JlbmFtZV9saW1pdF9kZWZhdWx0OwoJaWYgKG9wdGlvbnMtPnNldHVwICYgRElGRl9TRVRVUF9VU0VfQ0FDSEUpIHsKCQlpZiAoIWFjdGl2ZV9jYWNoZSkKCQkJLyogcmVhZC1jYWNoZSBkb2VzIG5vdCBkaWUgZXZlbiB3aGVuIGl0IGZhaWxzCgkJCSAqIHNvIGl0IGlzIHNhZmUgZm9yIHVzIHRvIGRvIHRoaXMgaGVyZS4gIEFsc28KCQkJICogaXQgZG9lcyBub3Qgc211ZGdlIGFjdGl2ZV9jYWNoZSBvciBhY3RpdmVfbnIKCQkJICogd2hlbiBpdCBmYWlscywgc28gd2UgZG8gbm90IGhhdmUgdG8gd29ycnkgYWJvdXQKCQkJICogY2xlYW5pbmcgaXQgdXAgb3Vyc2VsdmVzIGVpdGhlci4KCQkJICovCgkJCXJlYWRfY2FjaGUoKTsKCX0KCWlmIChvcHRpb25zLT5zZXR1cCAmIERJRkZfU0VUVVBfVVNFX1NJWkVfQ0FDSEUpCgkJdXNlX3NpemVfY2FjaGUgPSAxOwoJaWYgKG9wdGlvbnMtPmFiYnJldiA8PSAwIHx8IDQwIDwgb3B0aW9ucy0+YWJicmV2KQoJCW9wdGlvbnMtPmFiYnJldiA9IDQwOyAvKiBmdWxsICovCgoJcmV0dXJuIDA7Cn0KCmludCBkaWZmX29wdF9wYXJzZShzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHRpb25zLCBjb25zdCBjaGFyICoqYXYsIGludCBhYykKewoJY29uc3QgY2hhciAqYXJnID0gYXZbMF07CglpZiAoIXN0cmNtcChhcmcsICItcCIpIHx8ICFzdHJjbXAoYXJnLCAiLXUiKSkKCQlvcHRpb25zLT5vdXRwdXRfZm9ybWF0ID0gRElGRl9GT1JNQVRfUEFUQ0g7CgllbHNlIGlmICghc3RyY21wKGFyZywgIi0tcGF0Y2gtd2l0aC1yYXciKSkgewoJCW9wdGlvbnMtPm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9QQVRDSDsKCQlvcHRpb25zLT53aXRoX3JhdyA9IDE7Cgl9CgllbHNlIGlmICghc3RyY21wKGFyZywgIi0tc3RhdCIpKQoJCW9wdGlvbnMtPm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9ESUZGU1RBVDsKCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS1zdW1tYXJ5IikpCgkJb3B0aW9ucy0+c3VtbWFyeSA9IDE7CgllbHNlIGlmICghc3RyY21wKGFyZywgIi0tcGF0Y2gtd2l0aC1zdGF0IikpIHsKCQlvcHRpb25zLT5vdXRwdXRfZm9ybWF0ID0gRElGRl9GT1JNQVRfUEFUQ0g7CgkJb3B0aW9ucy0+d2l0aF9zdGF0ID0gMTsKCX0KCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLXoiKSkKCQlvcHRpb25zLT5saW5lX3Rlcm1pbmF0aW9uID0gMDsKCWVsc2UgaWYgKCFzdHJuY21wKGFyZywgIi1sIiwgMikpCgkJb3B0aW9ucy0+cmVuYW1lX2xpbWl0ID0gc3RydG91bChhcmcrMiwgTlVMTCwgMTApOwoJZWxzZSBpZiAoIXN0cmNtcChhcmcsICItLWZ1bGwtaW5kZXgiKSkKCQlvcHRpb25zLT5mdWxsX2luZGV4ID0gMTsKCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS1iaW5hcnkiKSkgewoJCW9wdGlvbnMtPm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9QQVRDSDsKCQlvcHRpb25zLT5mdWxsX2luZGV4ID0gb3B0aW9ucy0+YmluYXJ5ID0gMTsKCX0KCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS1uYW1lLW9ubHkiKSkKCQlvcHRpb25zLT5vdXRwdXRfZm9ybWF0ID0gRElGRl9GT1JNQVRfTkFNRTsKCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS1uYW1lLXN0YXR1cyIpKQoJCW9wdGlvbnMtPm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9OQU1FX1NUQVRVUzsKCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLVIiKSkKCQlvcHRpb25zLT5yZXZlcnNlX2RpZmYgPSAxOwoJZWxzZSBpZiAoIXN0cm5jbXAoYXJnLCAiLVMiLCAyKSkKCQlvcHRpb25zLT5waWNrYXhlID0gYXJnICsgMjsKCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLXMiKSkKCQlvcHRpb25zLT5vdXRwdXRfZm9ybWF0ID0gRElGRl9GT1JNQVRfTk9fT1VUUFVUOwoJZWxzZSBpZiAoIXN0cm5jbXAoYXJnLCAiLU8iLCAyKSkKCQlvcHRpb25zLT5vcmRlcmZpbGUgPSBhcmcgKyAyOwoJZWxzZSBpZiAoIXN0cm5jbXAoYXJnLCAiLS1kaWZmLWZpbHRlcj0iLCAxNCkpCgkJb3B0aW9ucy0+ZmlsdGVyID0gYXJnICsgMTQ7CgllbHNlIGlmICghc3RyY21wKGFyZywgIi0tcGlja2F4ZS1hbGwiKSkKCQlvcHRpb25zLT5waWNrYXhlX29wdHMgPSBESUZGX1BJQ0tBWEVfQUxMOwoJZWxzZSBpZiAoIXN0cmNtcChhcmcsICItLXBpY2theGUtcmVnZXgiKSkKCQlvcHRpb25zLT5waWNrYXhlX29wdHMgPSBESUZGX1BJQ0tBWEVfUkVHRVg7CgllbHNlIGlmICghc3RybmNtcChhcmcsICItQiIsIDIpKSB7CgkJaWYgKChvcHRpb25zLT5icmVha19vcHQgPQoJCSAgICAgZGlmZl9zY29yZW9wdF9wYXJzZShhcmcpKSA9PSAtMSkKCQkJcmV0dXJuIC0xOwoJfQoJZWxzZSBpZiAoIXN0cm5jbXAoYXJnLCAiLU0iLCAyKSkgewoJCWlmICgob3B0aW9ucy0+cmVuYW1lX3Njb3JlID0KCQkgICAgIGRpZmZfc2NvcmVvcHRfcGFyc2UoYXJnKSkgPT0gLTEpCgkJCXJldHVybiAtMTsKCQlvcHRpb25zLT5kZXRlY3RfcmVuYW1lID0gRElGRl9ERVRFQ1RfUkVOQU1FOwoJfQoJZWxzZSBpZiAoIXN0cm5jbXAoYXJnLCAiLUMiLCAyKSkgewoJCWlmICgob3B0aW9ucy0+cmVuYW1lX3Njb3JlID0KCQkgICAgIGRpZmZfc2NvcmVvcHRfcGFyc2UoYXJnKSkgPT0gLTEpCgkJCXJldHVybiAtMTsKCQlvcHRpb25zLT5kZXRlY3RfcmVuYW1lID0gRElGRl9ERVRFQ1RfQ09QWTsKCX0KCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS1maW5kLWNvcGllcy1oYXJkZXIiKSkKCQlvcHRpb25zLT5maW5kX2NvcGllc19oYXJkZXIgPSAxOwoJZWxzZSBpZiAoIXN0cmNtcChhcmcsICItLWFiYnJldiIpKQoJCW9wdGlvbnMtPmFiYnJldiA9IERFRkFVTFRfQUJCUkVWOwoJZWxzZSBpZiAoIXN0cm5jbXAoYXJnLCAiLS1hYmJyZXY9IiwgOSkpIHsKCQlvcHRpb25zLT5hYmJyZXYgPSBzdHJ0b3VsKGFyZyArIDksIE5VTEwsIDEwKTsKCQlpZiAob3B0aW9ucy0+YWJicmV2IDwgTUlOSU1VTV9BQkJSRVYpCgkJCW9wdGlvbnMtPmFiYnJldiA9IE1JTklNVU1fQUJCUkVWOwoJCWVsc2UgaWYgKDQwIDwgb3B0aW9ucy0+YWJicmV2KQoJCQlvcHRpb25zLT5hYmJyZXYgPSA0MDsKCX0KCWVsc2UKCQlyZXR1cm4gMDsKCXJldHVybiAxOwp9CgpzdGF0aWMgaW50IHBhcnNlX251bShjb25zdCBjaGFyICoqY3BfcCkKewoJdW5zaWduZWQgbG9uZyBudW0sIHNjYWxlOwoJaW50IGNoLCBkb3Q7Cgljb25zdCBjaGFyICpjcCA9ICpjcF9wOwoKCW51bSA9IDA7CglzY2FsZSA9IDE7Cglkb3QgPSAwOwoJZm9yKDs7KSB7CgkJY2ggPSAqY3A7CgkJaWYgKCAhZG90ICYmIGNoID09ICcuJyApIHsKCQkJc2NhbGUgPSAxOwoJCQlkb3QgPSAxOwoJCX0gZWxzZSBpZiAoIGNoID09ICclJyApIHsKCQkJc2NhbGUgPSBkb3QgPyBzY2FsZSoxMDAgOiAxMDA7CgkJCWNwKys7CS8qICUgaXMgYWx3YXlzIGF0IHRoZSBlbmQgKi8KCQkJYnJlYWs7CgkJfSBlbHNlIGlmICggY2ggPj0gJzAnICYmIGNoIDw9ICc5JyApIHsKCQkJaWYgKCBzY2FsZSA8IDEwMDAwMCApIHsKCQkJCXNjYWxlICo9IDEwOwoJCQkJbnVtID0gKG51bSoxMCkgKyAoY2gtJzAnKTsKCQkJfQoJCX0gZWxzZSB7CgkJCWJyZWFrOwoJCX0KCQljcCsrOwoJfQoJKmNwX3AgPSBjcDsKCgkvKiB1c2VyIHNheXMgbnVtIGRpdmlkZWQgYnkgc2NhbGUgYW5kIHdlIHNheSBpbnRlcm5hbGx5IHRoYXQKCSAqIGlzIE1BWF9TQ09SRSAqIG51bSAvIHNjYWxlLgoJICovCglyZXR1cm4gKG51bSA+PSBzY2FsZSkgPyBNQVhfU0NPUkUgOiAoTUFYX1NDT1JFICogbnVtIC8gc2NhbGUpOwp9CgppbnQgZGlmZl9zY29yZW9wdF9wYXJzZShjb25zdCBjaGFyICpvcHQpCnsKCWludCBvcHQxLCBvcHQyLCBjbWQ7CgoJaWYgKCpvcHQrKyAhPSAnLScpCgkJcmV0dXJuIC0xOwoJY21kID0gKm9wdCsrOwoJaWYgKGNtZCAhPSAnTScgJiYgY21kICE9ICdDJyAmJiBjbWQgIT0gJ0InKQoJCXJldHVybiAtMTsgLyogdGhhdCBpcyBub3QgYSAtTSwgLUMgbm9yIC1CIG9wdGlvbiAqLwoKCW9wdDEgPSBwYXJzZV9udW0oJm9wdCk7CglpZiAoY21kICE9ICdCJykKCQlvcHQyID0gMDsKCWVsc2UgewoJCWlmICgqb3B0ID09IDApCgkJCW9wdDIgPSAwOwoJCWVsc2UgaWYgKCpvcHQgIT0gJy8nKQoJCQlyZXR1cm4gLTE7IC8qIHdlIGV4cGVjdCAtQjgwLzk5IG9yIC1CODAgKi8KCQllbHNlIHsKCQkJb3B0Kys7CgkJCW9wdDIgPSBwYXJzZV9udW0oJm9wdCk7CgkJfQoJfQoJaWYgKCpvcHQgIT0gMCkKCQlyZXR1cm4gLTE7CglyZXR1cm4gb3B0MSB8IChvcHQyIDw8IDE2KTsKfQoKc3RydWN0IGRpZmZfcXVldWVfc3RydWN0IGRpZmZfcXVldWVkX2RpZmY7Cgp2b2lkIGRpZmZfcShzdHJ1Y3QgZGlmZl9xdWV1ZV9zdHJ1Y3QgKnF1ZXVlLCBzdHJ1Y3QgZGlmZl9maWxlcGFpciAqZHApCnsKCWlmIChxdWV1ZS0+YWxsb2MgPD0gcXVldWUtPm5yKSB7CgkJcXVldWUtPmFsbG9jID0gYWxsb2NfbnIocXVldWUtPmFsbG9jKTsKCQlxdWV1ZS0+cXVldWUgPSB4cmVhbGxvYyhxdWV1ZS0+cXVldWUsCgkJCQkJc2l6ZW9mKGRwKSAqIHF1ZXVlLT5hbGxvYyk7Cgl9CglxdWV1ZS0+cXVldWVbcXVldWUtPm5yKytdID0gZHA7Cn0KCnN0cnVjdCBkaWZmX2ZpbGVwYWlyICpkaWZmX3F1ZXVlKHN0cnVjdCBkaWZmX3F1ZXVlX3N0cnVjdCAqcXVldWUsCgkJCQkgc3RydWN0IGRpZmZfZmlsZXNwZWMgKm9uZSwKCQkJCSBzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqdHdvKQp7CglzdHJ1Y3QgZGlmZl9maWxlcGFpciAqZHAgPSB4bWFsbG9jKHNpemVvZigqZHApKTsKCWRwLT5vbmUgPSBvbmU7CglkcC0+dHdvID0gdHdvOwoJZHAtPnNjb3JlID0gMDsKCWRwLT5zdGF0dXMgPSAwOwoJZHAtPnNvdXJjZV9zdGF5cyA9IDA7CglkcC0+YnJva2VuX3BhaXIgPSAwOwoJaWYgKHF1ZXVlKQoJCWRpZmZfcShxdWV1ZSwgZHApOwoJcmV0dXJuIGRwOwp9Cgp2b2lkIGRpZmZfZnJlZV9maWxlcGFpcihzdHJ1Y3QgZGlmZl9maWxlcGFpciAqcCkKewoJZGlmZl9mcmVlX2ZpbGVzcGVjX2RhdGEocC0+b25lKTsKCWRpZmZfZnJlZV9maWxlc3BlY19kYXRhKHAtPnR3byk7CglmcmVlKHAtPm9uZSk7CglmcmVlKHAtPnR3byk7CglmcmVlKHApOwp9CgovKiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIGZpbmRfdW5pcXVlX2FiYnJldigpIGluIHRoYXQKICogaXQgc3R1ZmZzIHRoZSByZXN1bHQgd2l0aCBkb3RzIGZvciBhbGlnbm1lbnQuCiAqLwpjb25zdCBjaGFyICpkaWZmX3VuaXF1ZV9hYmJyZXYoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgaW50IGxlbikKewoJaW50IGFiYmxlbjsKCWNvbnN0IGNoYXIgKmFiYnJldjsKCWlmIChsZW4gPT0gNDApCgkJcmV0dXJuIHNoYTFfdG9faGV4KHNoYTEpOwoKCWFiYnJldiA9IGZpbmRfdW5pcXVlX2FiYnJldihzaGExLCBsZW4pOwoJaWYgKCFhYmJyZXYpCgkJcmV0dXJuIHNoYTFfdG9faGV4KHNoYTEpOwoJYWJibGVuID0gc3RybGVuKGFiYnJldik7CglpZiAoYWJibGVuIDwgMzcpIHsKCQlzdGF0aWMgY2hhciBoZXhbNDFdOwoJCWlmIChsZW4gPCBhYmJsZW4gJiYgYWJibGVuIDw9IGxlbiArIDIpCgkJCXNwcmludGYoaGV4LCAiJXMlLipzIiwgYWJicmV2LCBsZW4rMy1hYmJsZW4sICIuLiIpOwoJCWVsc2UKCQkJc3ByaW50ZihoZXgsICIlcy4uLiIsIGFiYnJldik7CgkJcmV0dXJuIGhleDsKCX0KCXJldHVybiBzaGExX3RvX2hleChzaGExKTsKfQoKc3RhdGljIHZvaWQgZGlmZl9mbHVzaF9yYXcoc3RydWN0IGRpZmZfZmlsZXBhaXIgKnAsCgkJCSAgIGludCBsaW5lX3Rlcm1pbmF0aW9uLAoJCQkgICBpbnQgaW50ZXJfbmFtZV90ZXJtaW5hdGlvbiwKCQkJICAgc3RydWN0IGRpZmZfb3B0aW9ucyAqb3B0aW9ucywKCQkJICAgaW50IG91dHB1dF9mb3JtYXQpCnsKCWludCB0d29fcGF0aHM7CgljaGFyIHN0YXR1c1sxMF07CglpbnQgYWJicmV2ID0gb3B0aW9ucy0+YWJicmV2OwoJY29uc3QgY2hhciAqcGF0aF9vbmUsICpwYXRoX3R3bzsKCglwYXRoX29uZSA9IHAtPm9uZS0+cGF0aDsKCXBhdGhfdHdvID0gcC0+dHdvLT5wYXRoOwoJaWYgKGxpbmVfdGVybWluYXRpb24pIHsKCQlwYXRoX29uZSA9IHF1b3RlX29uZShwYXRoX29uZSk7CgkJcGF0aF90d28gPSBxdW90ZV9vbmUocGF0aF90d28pOwoJfQoKCWlmIChwLT5zY29yZSkKCQlzcHJpbnRmKHN0YXR1cywgIiVjJTAzZCIsIHAtPnN0YXR1cywKCQkJKGludCkoMC41ICsgcC0+c2NvcmUgKiAxMDAuMC9NQVhfU0NPUkUpKTsKCWVsc2UgewoJCXN0YXR1c1swXSA9IHAtPnN0YXR1czsKCQlzdGF0dXNbMV0gPSAwOwoJfQoJc3dpdGNoIChwLT5zdGF0dXMpIHsKCWNhc2UgRElGRl9TVEFUVVNfQ09QSUVEOgoJY2FzZSBESUZGX1NUQVRVU19SRU5BTUVEOgoJCXR3b19wYXRocyA9IDE7CgkJYnJlYWs7CgljYXNlIERJRkZfU1RBVFVTX0FEREVEOgoJY2FzZSBESUZGX1NUQVRVU19ERUxFVEVEOgoJCXR3b19wYXRocyA9IDA7CgkJYnJlYWs7CglkZWZhdWx0OgoJCXR3b19wYXRocyA9IDA7CgkJYnJlYWs7Cgl9CglpZiAob3V0cHV0X2Zvcm1hdCAhPSBESUZGX0ZPUk1BVF9OQU1FX1NUQVRVUykgewoJCXByaW50ZigiOiUwNm8gJTA2byAlcyAiLAoJCSAgICAgICBwLT5vbmUtPm1vZGUsIHAtPnR3by0+bW9kZSwKCQkgICAgICAgZGlmZl91bmlxdWVfYWJicmV2KHAtPm9uZS0+c2hhMSwgYWJicmV2KSk7CgkJcHJpbnRmKCIlcyAiLAoJCSAgICAgICBkaWZmX3VuaXF1ZV9hYmJyZXYocC0+dHdvLT5zaGExLCBhYmJyZXYpKTsKCX0KCXByaW50ZigiJXMlYyVzIiwgc3RhdHVzLCBpbnRlcl9uYW1lX3Rlcm1pbmF0aW9uLCBwYXRoX29uZSk7CglpZiAodHdvX3BhdGhzKQoJCXByaW50ZigiJWMlcyIsIGludGVyX25hbWVfdGVybWluYXRpb24sIHBhdGhfdHdvKTsKCXB1dGNoYXIobGluZV90ZXJtaW5hdGlvbik7CglpZiAocGF0aF9vbmUgIT0gcC0+b25lLT5wYXRoKQoJCWZyZWUoKHZvaWQqKXBhdGhfb25lKTsKCWlmIChwYXRoX3R3byAhPSBwLT50d28tPnBhdGgpCgkJZnJlZSgodm9pZCopcGF0aF90d28pOwp9CgpzdGF0aWMgdm9pZCBkaWZmX2ZsdXNoX25hbWUoc3RydWN0IGRpZmZfZmlsZXBhaXIgKnAsCgkJCSAgICBpbnQgaW50ZXJfbmFtZV90ZXJtaW5hdGlvbiwKCQkJICAgIGludCBsaW5lX3Rlcm1pbmF0aW9uKQp7CgljaGFyICpwYXRoID0gcC0+dHdvLT5wYXRoOwoKCWlmIChsaW5lX3Rlcm1pbmF0aW9uKQoJCXBhdGggPSBxdW90ZV9vbmUocC0+dHdvLT5wYXRoKTsKCWVsc2UKCQlwYXRoID0gcC0+dHdvLT5wYXRoOwoJcHJpbnRmKCIlcyVjIiwgcGF0aCwgbGluZV90ZXJtaW5hdGlvbik7CglpZiAocC0+dHdvLT5wYXRoICE9IHBhdGgpCgkJZnJlZShwYXRoKTsKfQoKaW50IGRpZmZfdW5tb2RpZmllZF9wYWlyKHN0cnVjdCBkaWZmX2ZpbGVwYWlyICpwKQp7CgkvKiBUaGlzIGZ1bmN0aW9uIGlzIHdyaXR0ZW4gc3RyaWN0ZXIgdGhhbiBuZWNlc3NhcnkgdG8gc3VwcG9ydAoJICogdGhlIGN1cnJlbnRseSBpbXBsZW1lbnRlZCB0cmFuc2Zvcm1lcnMsIGJ1dCB0aGUgaWRlYSBpcyB0bwoJICogbGV0IHRyYW5zZm9ybWVycyB0byBwcm9kdWNlIGRpZmZfZmlsZXBhaXJzIGFueSB3YXkgdGhleSB3YW50LAoJICogYW5kIGZpbHRlciBhbmQgY2xlYW4gdGhlbSB1cCBoZXJlIGJlZm9yZSBwcm9kdWNpbmcgdGhlIG91dHB1dC4KCSAqLwoJc3RydWN0IGRpZmZfZmlsZXNwZWMgKm9uZSwgKnR3bzsKCglpZiAoRElGRl9QQUlSX1VOTUVSR0VEKHApKQoJCXJldHVybiAwOyAvKiB1bm1lcmdlZCBpcyBpbnRlcmVzdGluZyAqLwoKCW9uZSA9IHAtPm9uZTsKCXR3byA9IHAtPnR3bzsKCgkvKiBkZWxldGlvbiwgYWRkaXRpb24sIG1vZGUgb3IgdHlwZSBjaGFuZ2UKCSAqIGFuZCByZW5hbWUgYXJlIGFsbCBpbnRlcmVzdGluZy4KCSAqLwoJaWYgKERJRkZfRklMRV9WQUxJRChvbmUpICE9IERJRkZfRklMRV9WQUxJRCh0d28pIHx8CgkgICAgRElGRl9QQUlSX01PREVfQ0hBTkdFRChwKSB8fAoJICAgIHN0cmNtcChvbmUtPnBhdGgsIHR3by0+cGF0aCkpCgkJcmV0dXJuIDA7CgoJLyogYm90aCBhcmUgdmFsaWQgYW5kIHBvaW50IGF0IHRoZSBzYW1lIHBhdGguICB0aGF0IGlzLCB3ZSBhcmUKCSAqIGRlYWxpbmcgd2l0aCBhIGNoYW5nZS4KCSAqLwoJaWYgKG9uZS0+c2hhMV92YWxpZCAmJiB0d28tPnNoYTFfdmFsaWQgJiYKCSAgICAhbWVtY21wKG9uZS0+c2hhMSwgdHdvLT5zaGExLCBzaXplb2Yob25lLT5zaGExKSkpCgkJcmV0dXJuIDE7IC8qIG5vIGNoYW5nZSAqLwoJaWYgKCFvbmUtPnNoYTFfdmFsaWQgJiYgIXR3by0+c2hhMV92YWxpZCkKCQlyZXR1cm4gMTsgLyogYm90aCBsb29rIGF0IHRoZSBzYW1lIGZpbGUgb24gdGhlIGZpbGVzeXN0ZW0uICovCglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgZGlmZl9mbHVzaF9wYXRjaChzdHJ1Y3QgZGlmZl9maWxlcGFpciAqcCwgc3RydWN0IGRpZmZfb3B0aW9ucyAqbykKewoJaWYgKGRpZmZfdW5tb2RpZmllZF9wYWlyKHApKQoJCXJldHVybjsKCglpZiAoKERJRkZfRklMRV9WQUxJRChwLT5vbmUpICYmIFNfSVNESVIocC0+b25lLT5tb2RlKSkgfHwKCSAgICAoRElGRl9GSUxFX1ZBTElEKHAtPnR3bykgJiYgU19JU0RJUihwLT50d28tPm1vZGUpKSkKCQlyZXR1cm47IC8qIG5vIHRyZWUgZGlmZnMgaW4gcGF0Y2ggZm9ybWF0ICovCgoJcnVuX2RpZmYocCwgbyk7Cn0KCnN0YXRpYyB2b2lkIGRpZmZfZmx1c2hfc3RhdChzdHJ1Y3QgZGlmZl9maWxlcGFpciAqcCwgc3RydWN0IGRpZmZfb3B0aW9ucyAqbywKCQkJICAgIHN0cnVjdCBkaWZmc3RhdF90ICpkaWZmc3RhdCkKewoJaWYgKGRpZmZfdW5tb2RpZmllZF9wYWlyKHApKQoJCXJldHVybjsKCglpZiAoKERJRkZfRklMRV9WQUxJRChwLT5vbmUpICYmIFNfSVNESVIocC0+b25lLT5tb2RlKSkgfHwKCSAgICAoRElGRl9GSUxFX1ZBTElEKHAtPnR3bykgJiYgU19JU0RJUihwLT50d28tPm1vZGUpKSkKCQlyZXR1cm47IC8qIG5vIHRyZWUgZGlmZnMgaW4gcGF0Y2ggZm9ybWF0ICovCgoJcnVuX2RpZmZzdGF0KHAsIG8sIGRpZmZzdGF0KTsKfQoKaW50IGRpZmZfcXVldWVfaXNfZW1wdHkodm9pZCkKewoJc3RydWN0IGRpZmZfcXVldWVfc3RydWN0ICpxID0gJmRpZmZfcXVldWVkX2RpZmY7CglpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCBxLT5ucjsgaSsrKQoJCWlmICghZGlmZl91bm1vZGlmaWVkX3BhaXIocS0+cXVldWVbaV0pKQoJCQlyZXR1cm4gMDsKCXJldHVybiAxOwp9CgojaWYgRElGRl9ERUJVRwp2b2lkIGRpZmZfZGVidWdfZmlsZXNwZWMoc3RydWN0IGRpZmZfZmlsZXNwZWMgKnMsIGludCB4LCBjb25zdCBjaGFyICpvbmUpCnsKCWZwcmludGYoc3RkZXJyLCAicXVldWVbJWRdICVzICglcykgJXMgJTA2byAlc1xuIiwKCQl4LCBvbmUgPyBvbmUgOiAiIiwKCQlzLT5wYXRoLAoJCURJRkZfRklMRV9WQUxJRChzKSA/ICJ2YWxpZCIgOiAiaW52YWxpZCIsCgkJcy0+bW9kZSwKCQlzLT5zaGExX3ZhbGlkID8gc2hhMV90b19oZXgocy0+c2hhMSkgOiAiIik7CglmcHJpbnRmKHN0ZGVyciwgInF1ZXVlWyVkXSAlcyBzaXplICVsdSBmbGFncyAlZFxuIiwKCQl4LCBvbmUgPyBvbmUgOiAiIiwKCQlzLT5zaXplLCBzLT54ZnJtX2ZsYWdzKTsKfQoKdm9pZCBkaWZmX2RlYnVnX2ZpbGVwYWlyKGNvbnN0IHN0cnVjdCBkaWZmX2ZpbGVwYWlyICpwLCBpbnQgaSkKewoJZGlmZl9kZWJ1Z19maWxlc3BlYyhwLT5vbmUsIGksICJvbmUiKTsKCWRpZmZfZGVidWdfZmlsZXNwZWMocC0+dHdvLCBpLCAidHdvIik7CglmcHJpbnRmKHN0ZGVyciwgInNjb3JlICVkLCBzdGF0dXMgJWMgc3RheXMgJWQgYnJva2VuICVkXG4iLAoJCXAtPnNjb3JlLCBwLT5zdGF0dXMgPyBwLT5zdGF0dXMgOiAnPycsCgkJcC0+c291cmNlX3N0YXlzLCBwLT5icm9rZW5fcGFpcik7Cn0KCnZvaWQgZGlmZl9kZWJ1Z19xdWV1ZShjb25zdCBjaGFyICptc2csIHN0cnVjdCBkaWZmX3F1ZXVlX3N0cnVjdCAqcSkKewoJaW50IGk7CglpZiAobXNnKQoJCWZwcmludGYoc3RkZXJyLCAiJXNcbiIsIG1zZyk7CglmcHJpbnRmKHN0ZGVyciwgInEtPm5yID0gJWRcbiIsIHEtPm5yKTsKCWZvciAoaSA9IDA7IGkgPCBxLT5ucjsgaSsrKSB7CgkJc3RydWN0IGRpZmZfZmlsZXBhaXIgKnAgPSBxLT5xdWV1ZVtpXTsKCQlkaWZmX2RlYnVnX2ZpbGVwYWlyKHAsIGkpOwoJfQp9CiNlbmRpZgoKc3RhdGljIHZvaWQgZGlmZl9yZXNvbHZlX3JlbmFtZV9jb3B5KHZvaWQpCnsKCWludCBpLCBqOwoJc3RydWN0IGRpZmZfZmlsZXBhaXIgKnAsICpwcDsKCXN0cnVjdCBkaWZmX3F1ZXVlX3N0cnVjdCAqcSA9ICZkaWZmX3F1ZXVlZF9kaWZmOwoKCWRpZmZfZGVidWdfcXVldWUoInJlc29sdmUtcmVuYW1lLWNvcHkiLCBxKTsKCglmb3IgKGkgPSAwOyBpIDwgcS0+bnI7IGkrKykgewoJCXAgPSBxLT5xdWV1ZVtpXTsKCQlwLT5zdGF0dXMgPSAwOyAvKiB1bmRlY2lkZWQgKi8KCQlpZiAoRElGRl9QQUlSX1VOTUVSR0VEKHApKQoJCQlwLT5zdGF0dXMgPSBESUZGX1NUQVRVU19VTk1FUkdFRDsKCQllbHNlIGlmICghRElGRl9GSUxFX1ZBTElEKHAtPm9uZSkpCgkJCXAtPnN0YXR1cyA9IERJRkZfU1RBVFVTX0FEREVEOwoJCWVsc2UgaWYgKCFESUZGX0ZJTEVfVkFMSUQocC0+dHdvKSkKCQkJcC0+c3RhdHVzID0gRElGRl9TVEFUVVNfREVMRVRFRDsKCQllbHNlIGlmIChESUZGX1BBSVJfVFlQRV9DSEFOR0VEKHApKQoJCQlwLT5zdGF0dXMgPSBESUZGX1NUQVRVU19UWVBFX0NIQU5HRUQ7CgoJCS8qIGZyb20gdGhpcyBwb2ludCBvbiwgd2UgYXJlIGRlYWxpbmcgd2l0aCBhIHBhaXIKCQkgKiB3aG9zZSBib3RoIHNpZGVzIGFyZSB2YWxpZCBhbmQgb2YgdGhlIHNhbWUgdHlwZSwgaS5lLgoJCSAqIGVpdGhlciBpbi1wbGFjZSBlZGl0IG9yIHJlbmFtZS9jb3B5IGVkaXQuCgkJICovCgkJZWxzZSBpZiAoRElGRl9QQUlSX1JFTkFNRShwKSkgewoJCQlpZiAocC0+c291cmNlX3N0YXlzKSB7CgkJCQlwLT5zdGF0dXMgPSBESUZGX1NUQVRVU19DT1BJRUQ7CgkJCQljb250aW51ZTsKCQkJfQoJCQkvKiBTZWUgaWYgdGhlcmUgaXMgc29tZSBvdGhlciBmaWxlcGFpciB0aGF0CgkJCSAqIGNvcGllcyBmcm9tIHRoZSBzYW1lIHNvdXJjZSBhcyB1cy4gIElmIHNvCgkJCSAqIHdlIGFyZSBhIGNvcHkuICBPdGhlcndpc2Ugd2UgYXJlIGVpdGhlciBhCgkJCSAqIGNvcHkgaWYgdGhlIHBhdGggc3RheXMsIG9yIGEgcmVuYW1lIGlmIGl0CgkJCSAqIGRvZXMgbm90LCBidXQgd2UgYWxyZWFkeSBoYW5kbGVkICJzdGF5cyIgY2FzZS4KCQkJICovCgkJCWZvciAoaiA9IGkgKyAxOyBqIDwgcS0+bnI7IGorKykgewoJCQkJcHAgPSBxLT5xdWV1ZVtqXTsKCQkJCWlmIChzdHJjbXAocHAtPm9uZS0+cGF0aCwgcC0+b25lLT5wYXRoKSkKCQkJCQljb250aW51ZTsgLyogbm90IHVzICovCgkJCQlpZiAoIURJRkZfUEFJUl9SRU5BTUUocHApKQoJCQkJCWNvbnRpbnVlOyAvKiBub3QgYSByZW5hbWUvY29weSAqLwoJCQkJLyogcHAgaXMgYSByZW5hbWUvY29weSBmcm9tIHRoZSBzYW1lIHNvdXJjZSAqLwoJCQkJcC0+c3RhdHVzID0gRElGRl9TVEFUVVNfQ09QSUVEOwoJCQkJYnJlYWs7CgkJCX0KCQkJaWYgKCFwLT5zdGF0dXMpCgkJCQlwLT5zdGF0dXMgPSBESUZGX1NUQVRVU19SRU5BTUVEOwoJCX0KCQllbHNlIGlmIChtZW1jbXAocC0+b25lLT5zaGExLCBwLT50d28tPnNoYTEsIDIwKSB8fAoJCQkgcC0+b25lLT5tb2RlICE9IHAtPnR3by0+bW9kZSkKCQkJcC0+c3RhdHVzID0gRElGRl9TVEFUVVNfTU9ESUZJRUQ7CgkJZWxzZSB7CgkJCS8qIFRoaXMgaXMgYSAibm8tY2hhbmdlIiBlbnRyeSBhbmQgc2hvdWxkIG5vdAoJCQkgKiBoYXBwZW4gYW55bW9yZSwgYnV0IHByZXBhcmUgZm9yIGJyb2tlbiBjYWxsZXJzLgoJCQkgKi8KCQkJZXJyb3IoImZlZWRpbmcgdW5tb2RpZmllZCAlcyB0byBkaWZmY29yZSIsCgkJCSAgICAgIHAtPm9uZS0+cGF0aCk7CgkJCXAtPnN0YXR1cyA9IERJRkZfU1RBVFVTX1VOS05PV047CgkJfQoJfQoJZGlmZl9kZWJ1Z19xdWV1ZSgicmVzb2x2ZS1yZW5hbWUtY29weSBkb25lIiwgcSk7Cn0KCnN0YXRpYyB2b2lkIGZsdXNoX29uZV9wYWlyKHN0cnVjdCBkaWZmX2ZpbGVwYWlyICpwLAoJCQkgICBpbnQgZGlmZl9vdXRwdXRfZm9ybWF0LAoJCQkgICBzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHRpb25zLAoJCQkgICBzdHJ1Y3QgZGlmZnN0YXRfdCAqZGlmZnN0YXQpCnsKCWludCBpbnRlcl9uYW1lX3Rlcm1pbmF0aW9uID0gJ1x0JzsKCWludCBsaW5lX3Rlcm1pbmF0aW9uID0gb3B0aW9ucy0+bGluZV90ZXJtaW5hdGlvbjsKCWlmICghbGluZV90ZXJtaW5hdGlvbikKCQlpbnRlcl9uYW1lX3Rlcm1pbmF0aW9uID0gMDsKCglzd2l0Y2ggKHAtPnN0YXR1cykgewoJY2FzZSBESUZGX1NUQVRVU19VTktOT1dOOgoJCWJyZWFrOwoJY2FzZSAwOgoJCWRpZSgiaW50ZXJuYWwgZXJyb3IgaW4gZGlmZi1yZXNvbHZlLXJlbmFtZS1jb3B5Iik7CgkJYnJlYWs7CglkZWZhdWx0OgoJCXN3aXRjaCAoZGlmZl9vdXRwdXRfZm9ybWF0KSB7CgkJY2FzZSBESUZGX0ZPUk1BVF9ESUZGU1RBVDoKCQkJZGlmZl9mbHVzaF9zdGF0KHAsIG9wdGlvbnMsIGRpZmZzdGF0KTsKCQkJYnJlYWs7CgkJY2FzZSBESUZGX0ZPUk1BVF9QQVRDSDoKCQkJZGlmZl9mbHVzaF9wYXRjaChwLCBvcHRpb25zKTsKCQkJYnJlYWs7CgkJY2FzZSBESUZGX0ZPUk1BVF9SQVc6CgkJY2FzZSBESUZGX0ZPUk1BVF9OQU1FX1NUQVRVUzoKCQkJZGlmZl9mbHVzaF9yYXcocCwgbGluZV90ZXJtaW5hdGlvbiwKCQkJCSAgICAgICBpbnRlcl9uYW1lX3Rlcm1pbmF0aW9uLAoJCQkJICAgICAgIG9wdGlvbnMsIGRpZmZfb3V0cHV0X2Zvcm1hdCk7CgkJCWJyZWFrOwoJCWNhc2UgRElGRl9GT1JNQVRfTkFNRToKCQkJZGlmZl9mbHVzaF9uYW1lKHAsCgkJCQkJaW50ZXJfbmFtZV90ZXJtaW5hdGlvbiwKCQkJCQlsaW5lX3Rlcm1pbmF0aW9uKTsKCQkJYnJlYWs7CgkJY2FzZSBESUZGX0ZPUk1BVF9OT19PVVRQVVQ6CgkJCWJyZWFrOwoJCX0KCX0KfQoKc3RhdGljIHZvaWQgc2hvd19maWxlX21vZGVfbmFtZShjb25zdCBjaGFyICpuZXdkZWxldGUsIHN0cnVjdCBkaWZmX2ZpbGVzcGVjICpmcykKewoJaWYgKGZzLT5tb2RlKQoJCXByaW50ZigiICVzIG1vZGUgJTA2byAlc1xuIiwgbmV3ZGVsZXRlLCBmcy0+bW9kZSwgZnMtPnBhdGgpOwoJZWxzZQoJCXByaW50ZigiICVzICVzXG4iLCBuZXdkZWxldGUsIGZzLT5wYXRoKTsKfQoKCnN0YXRpYyB2b2lkIHNob3dfbW9kZV9jaGFuZ2Uoc3RydWN0IGRpZmZfZmlsZXBhaXIgKnAsIGludCBzaG93X25hbWUpCnsKCWlmIChwLT5vbmUtPm1vZGUgJiYgcC0+dHdvLT5tb2RlICYmIHAtPm9uZS0+bW9kZSAhPSBwLT50d28tPm1vZGUpIHsKCQlpZiAoc2hvd19uYW1lKQoJCQlwcmludGYoIiBtb2RlIGNoYW5nZSAlMDZvID0+ICUwNm8gJXNcbiIsCgkJCSAgICAgICBwLT5vbmUtPm1vZGUsIHAtPnR3by0+bW9kZSwgcC0+dHdvLT5wYXRoKTsKCQllbHNlCgkJCXByaW50ZigiIG1vZGUgY2hhbmdlICUwNm8gPT4gJTA2b1xuIiwKCQkJICAgICAgIHAtPm9uZS0+bW9kZSwgcC0+dHdvLT5tb2RlKTsKCX0KfQoKc3RhdGljIHZvaWQgc2hvd19yZW5hbWVfY29weShjb25zdCBjaGFyICpyZW5hbWVjb3B5LCBzdHJ1Y3QgZGlmZl9maWxlcGFpciAqcCkKewoJY29uc3QgY2hhciAqb2xkLCAqbmV3OwoKCS8qIEZpbmQgY29tbW9uIHByZWZpeCAqLwoJb2xkID0gcC0+b25lLT5wYXRoOwoJbmV3ID0gcC0+dHdvLT5wYXRoOwoJd2hpbGUgKDEpIHsKCQljb25zdCBjaGFyICpzbGFzaF9vbGQsICpzbGFzaF9uZXc7CgkJc2xhc2hfb2xkID0gc3RyY2hyKG9sZCwgJy8nKTsKCQlzbGFzaF9uZXcgPSBzdHJjaHIobmV3LCAnLycpOwoJCWlmICghc2xhc2hfb2xkIHx8CgkJICAgICFzbGFzaF9uZXcgfHwKCQkgICAgc2xhc2hfb2xkIC0gb2xkICE9IHNsYXNoX25ldyAtIG5ldyB8fAoJCSAgICBtZW1jbXAob2xkLCBuZXcsIHNsYXNoX25ldyAtIG5ldykpCgkJCWJyZWFrOwoJCW9sZCA9IHNsYXNoX29sZCArIDE7CgkJbmV3ID0gc2xhc2hfbmV3ICsgMTsKCX0KCS8qIHAtPm9uZS0+cGF0aCB0aHJ1IG9sZCBpcyB0aGUgY29tbW9uIHByZWZpeCwgYW5kIG9sZCBhbmQgbmV3CgkgKiB0aHJvdWdoIHRoZSBlbmQgb2YgbmFtZXMgYXJlIHJlbmFtZXMKCSAqLwoJaWYgKG9sZCAhPSBwLT5vbmUtPnBhdGgpCgkJcHJpbnRmKCIgJXMgJS4qc3slcyA9PiAlc30gKCVkJSUpXG4iLCByZW5hbWVjb3B5LAoJCSAgICAgICAoaW50KShvbGQgLSBwLT5vbmUtPnBhdGgpLCBwLT5vbmUtPnBhdGgsCgkJICAgICAgIG9sZCwgbmV3LCAoaW50KSgwLjUgKyBwLT5zY29yZSAqIDEwMC4wL01BWF9TQ09SRSkpOwoJZWxzZQoJCXByaW50ZigiICVzICVzID0+ICVzICglZCUlKVxuIiwgcmVuYW1lY29weSwKCQkgICAgICAgcC0+b25lLT5wYXRoLCBwLT50d28tPnBhdGgsCgkJICAgICAgIChpbnQpKDAuNSArIHAtPnNjb3JlICogMTAwLjAvTUFYX1NDT1JFKSk7CglzaG93X21vZGVfY2hhbmdlKHAsIDApOwp9CgpzdGF0aWMgdm9pZCBkaWZmX3N1bW1hcnkoc3RydWN0IGRpZmZfZmlsZXBhaXIgKnApCnsKCXN3aXRjaChwLT5zdGF0dXMpIHsKCWNhc2UgRElGRl9TVEFUVVNfREVMRVRFRDoKCQlzaG93X2ZpbGVfbW9kZV9uYW1lKCJkZWxldGUiLCBwLT5vbmUpOwoJCWJyZWFrOwoJY2FzZSBESUZGX1NUQVRVU19BRERFRDoKCQlzaG93X2ZpbGVfbW9kZV9uYW1lKCJjcmVhdGUiLCBwLT50d28pOwoJCWJyZWFrOwoJY2FzZSBESUZGX1NUQVRVU19DT1BJRUQ6CgkJc2hvd19yZW5hbWVfY29weSgiY29weSIsIHApOwoJCWJyZWFrOwoJY2FzZSBESUZGX1NUQVRVU19SRU5BTUVEOgoJCXNob3dfcmVuYW1lX2NvcHkoInJlbmFtZSIsIHApOwoJCWJyZWFrOwoJZGVmYXVsdDoKCQlpZiAocC0+c2NvcmUpIHsKCQkJcHJpbnRmKCIgcmV3cml0ZSAlcyAoJWQlJSlcbiIsIHAtPnR3by0+cGF0aCwKCQkJCShpbnQpKDAuNSArIHAtPnNjb3JlICogMTAwLjAvTUFYX1NDT1JFKSk7CgkJCXNob3dfbW9kZV9jaGFuZ2UocCwgMCk7CgkJfSBlbHNlCXNob3dfbW9kZV9jaGFuZ2UocCwgMSk7CgkJYnJlYWs7Cgl9Cn0KCnZvaWQgZGlmZl9mbHVzaChzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHRpb25zKQp7CglzdHJ1Y3QgZGlmZl9xdWV1ZV9zdHJ1Y3QgKnEgPSAmZGlmZl9xdWV1ZWRfZGlmZjsKCWludCBpOwoJaW50IGRpZmZfb3V0cHV0X2Zvcm1hdCA9IG9wdGlvbnMtPm91dHB1dF9mb3JtYXQ7CglzdHJ1Y3QgZGlmZnN0YXRfdCAqZGlmZnN0YXQgPSBOVUxMOwoKCWlmIChkaWZmX291dHB1dF9mb3JtYXQgPT0gRElGRl9GT1JNQVRfRElGRlNUQVQgfHwgb3B0aW9ucy0+d2l0aF9zdGF0KSB7CgkJZGlmZnN0YXQgPSB4Y2FsbG9jKHNpemVvZiAoc3RydWN0IGRpZmZzdGF0X3QpLCAxKTsKCQlkaWZmc3RhdC0+eG0uY29uc3VtZSA9IGRpZmZzdGF0X2NvbnN1bWU7Cgl9CgoJaWYgKG9wdGlvbnMtPndpdGhfcmF3KSB7CgkJZm9yIChpID0gMDsgaSA8IHEtPm5yOyBpKyspIHsKCQkJc3RydWN0IGRpZmZfZmlsZXBhaXIgKnAgPSBxLT5xdWV1ZVtpXTsKCQkJZmx1c2hfb25lX3BhaXIocCwgRElGRl9GT1JNQVRfUkFXLCBvcHRpb25zLCBOVUxMKTsKCQl9CgkJcHV0Y2hhcihvcHRpb25zLT5saW5lX3Rlcm1pbmF0aW9uKTsKCX0KCWlmIChvcHRpb25zLT53aXRoX3N0YXQpIHsKCQlmb3IgKGkgPSAwOyBpIDwgcS0+bnI7IGkrKykgewoJCQlzdHJ1Y3QgZGlmZl9maWxlcGFpciAqcCA9IHEtPnF1ZXVlW2ldOwoJCQlmbHVzaF9vbmVfcGFpcihwLCBESUZGX0ZPUk1BVF9ESUZGU1RBVCwgb3B0aW9ucywKCQkJCSAgICAgICBkaWZmc3RhdCk7CgkJfQoJCXNob3dfc3RhdHMoZGlmZnN0YXQpOwoJCWZyZWUoZGlmZnN0YXQpOwoJCWRpZmZzdGF0ID0gTlVMTDsKCQlwdXRjaGFyKG9wdGlvbnMtPmxpbmVfdGVybWluYXRpb24pOwoJfQoJZm9yIChpID0gMDsgaSA8IHEtPm5yOyBpKyspIHsKCQlzdHJ1Y3QgZGlmZl9maWxlcGFpciAqcCA9IHEtPnF1ZXVlW2ldOwoJCWZsdXNoX29uZV9wYWlyKHAsIGRpZmZfb3V0cHV0X2Zvcm1hdCwgb3B0aW9ucywgZGlmZnN0YXQpOwoJfQoKCWlmIChkaWZmc3RhdCkgewoJCXNob3dfc3RhdHMoZGlmZnN0YXQpOwoJCWZyZWUoZGlmZnN0YXQpOwoJfQoKCWZvciAoaSA9IDA7IGkgPCBxLT5ucjsgaSsrKSB7CgkJaWYgKG9wdGlvbnMtPnN1bW1hcnkpCgkJCWRpZmZfc3VtbWFyeShxLT5xdWV1ZVtpXSk7CgkJZGlmZl9mcmVlX2ZpbGVwYWlyKHEtPnF1ZXVlW2ldKTsKCX0KCglmcmVlKHEtPnF1ZXVlKTsKCXEtPnF1ZXVlID0gTlVMTDsKCXEtPm5yID0gcS0+YWxsb2MgPSAwOwp9CgpzdGF0aWMgdm9pZCBkaWZmY29yZV9hcHBseV9maWx0ZXIoY29uc3QgY2hhciAqZmlsdGVyKQp7CglpbnQgaTsKCXN0cnVjdCBkaWZmX3F1ZXVlX3N0cnVjdCAqcSA9ICZkaWZmX3F1ZXVlZF9kaWZmOwoJc3RydWN0IGRpZmZfcXVldWVfc3RydWN0IG91dHE7CglvdXRxLnF1ZXVlID0gTlVMTDsKCW91dHEubnIgPSBvdXRxLmFsbG9jID0gMDsKCglpZiAoIWZpbHRlcikKCQlyZXR1cm47CgoJaWYgKHN0cmNocihmaWx0ZXIsIERJRkZfU1RBVFVTX0ZJTFRFUl9BT04pKSB7CgkJaW50IGZvdW5kOwoJCWZvciAoaSA9IGZvdW5kID0gMDsgIWZvdW5kICYmIGkgPCBxLT5ucjsgaSsrKSB7CgkJCXN0cnVjdCBkaWZmX2ZpbGVwYWlyICpwID0gcS0+cXVldWVbaV07CgkJCWlmICgoKHAtPnN0YXR1cyA9PSBESUZGX1NUQVRVU19NT0RJRklFRCkgJiYKCQkJICAgICAoKHAtPnNjb3JlICYmCgkJCSAgICAgICBzdHJjaHIoZmlsdGVyLCBESUZGX1NUQVRVU19GSUxURVJfQlJPS0VOKSkgfHwKCQkJICAgICAgKCFwLT5zY29yZSAmJgoJCQkgICAgICAgc3RyY2hyKGZpbHRlciwgRElGRl9TVEFUVVNfTU9ESUZJRUQpKSkpIHx8CgkJCSAgICAoKHAtPnN0YXR1cyAhPSBESUZGX1NUQVRVU19NT0RJRklFRCkgJiYKCQkJICAgICBzdHJjaHIoZmlsdGVyLCBwLT5zdGF0dXMpKSkKCQkJCWZvdW5kKys7CgkJfQoJCWlmIChmb3VuZCkKCQkJcmV0dXJuOwoKCQkvKiBvdGhlcndpc2Ugd2Ugd2lsbCBjbGVhciB0aGUgd2hvbGUgcXVldWUKCQkgKiBieSBjb3B5aW5nIHRoZSBlbXB0eSBvdXRxIGF0IHRoZSBlbmQgb2YgdGhpcwoJCSAqIGZ1bmN0aW9uLCBidXQgZmlyc3QgY2xlYXIgdGhlIGN1cnJlbnQgZW50cmllcwoJCSAqIGluIHRoZSBxdWV1ZS4KCQkgKi8KCQlmb3IgKGkgPSAwOyBpIDwgcS0+bnI7IGkrKykKCQkJZGlmZl9mcmVlX2ZpbGVwYWlyKHEtPnF1ZXVlW2ldKTsKCX0KCWVsc2UgewoJCS8qIE9ubHkgdGhlIG1hdGNoaW5nIG9uZXMgKi8KCQlmb3IgKGkgPSAwOyBpIDwgcS0+bnI7IGkrKykgewoJCQlzdHJ1Y3QgZGlmZl9maWxlcGFpciAqcCA9IHEtPnF1ZXVlW2ldOwoKCQkJaWYgKCgocC0+c3RhdHVzID09IERJRkZfU1RBVFVTX01PRElGSUVEKSAmJgoJCQkgICAgICgocC0+c2NvcmUgJiYKCQkJICAgICAgIHN0cmNocihmaWx0ZXIsIERJRkZfU1RBVFVTX0ZJTFRFUl9CUk9LRU4pKSB8fAoJCQkgICAgICAoIXAtPnNjb3JlICYmCgkJCSAgICAgICBzdHJjaHIoZmlsdGVyLCBESUZGX1NUQVRVU19NT0RJRklFRCkpKSkgfHwKCQkJICAgICgocC0+c3RhdHVzICE9IERJRkZfU1RBVFVTX01PRElGSUVEKSAmJgoJCQkgICAgIHN0cmNocihmaWx0ZXIsIHAtPnN0YXR1cykpKQoJCQkJZGlmZl9xKCZvdXRxLCBwKTsKCQkJZWxzZQoJCQkJZGlmZl9mcmVlX2ZpbGVwYWlyKHApOwoJCX0KCX0KCWZyZWUocS0+cXVldWUpOwoJKnEgPSBvdXRxOwp9Cgp2b2lkIGRpZmZjb3JlX3N0ZChzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHRpb25zKQp7CglpZiAob3B0aW9ucy0+YnJlYWtfb3B0ICE9IC0xKQoJCWRpZmZjb3JlX2JyZWFrKG9wdGlvbnMtPmJyZWFrX29wdCk7CglpZiAob3B0aW9ucy0+ZGV0ZWN0X3JlbmFtZSkKCQlkaWZmY29yZV9yZW5hbWUob3B0aW9ucyk7CglpZiAob3B0aW9ucy0+YnJlYWtfb3B0ICE9IC0xKQoJCWRpZmZjb3JlX21lcmdlX2Jyb2tlbigpOwoJaWYgKG9wdGlvbnMtPnBpY2theGUpCgkJZGlmZmNvcmVfcGlja2F4ZShvcHRpb25zLT5waWNrYXhlLCBvcHRpb25zLT5waWNrYXhlX29wdHMpOwoJaWYgKG9wdGlvbnMtPm9yZGVyZmlsZSkKCQlkaWZmY29yZV9vcmRlcihvcHRpb25zLT5vcmRlcmZpbGUpOwoJZGlmZl9yZXNvbHZlX3JlbmFtZV9jb3B5KCk7CglkaWZmY29yZV9hcHBseV9maWx0ZXIob3B0aW9ucy0+ZmlsdGVyKTsKfQoKCnZvaWQgZGlmZmNvcmVfc3RkX25vX3Jlc29sdmUoc3RydWN0IGRpZmZfb3B0aW9ucyAqb3B0aW9ucykKewoJaWYgKG9wdGlvbnMtPnBpY2theGUpCgkJZGlmZmNvcmVfcGlja2F4ZShvcHRpb25zLT5waWNrYXhlLCBvcHRpb25zLT5waWNrYXhlX29wdHMpOwoJaWYgKG9wdGlvbnMtPm9yZGVyZmlsZSkKCQlkaWZmY29yZV9vcmRlcihvcHRpb25zLT5vcmRlcmZpbGUpOwoJZGlmZmNvcmVfYXBwbHlfZmlsdGVyKG9wdGlvbnMtPmZpbHRlcik7Cn0KCnZvaWQgZGlmZl9hZGRyZW1vdmUoc3RydWN0IGRpZmZfb3B0aW9ucyAqb3B0aW9ucywKCQkgICAgaW50IGFkZHJlbW92ZSwgdW5zaWduZWQgbW9kZSwKCQkgICAgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkgICAgY29uc3QgY2hhciAqYmFzZSwgY29uc3QgY2hhciAqcGF0aCkKewoJY2hhciBjb25jYXRwYXRoW1BBVEhfTUFYXTsKCXN0cnVjdCBkaWZmX2ZpbGVzcGVjICpvbmUsICp0d287CgoJLyogVGhpcyBtYXkgbG9vayBvZGQsIGJ1dCBpdCBpcyBhIHByZXBhcmF0aW9uIGZvcgoJICogZmVlZGluZyAidGhlcmUgYXJlIHVuY2hhbmdlZCBmaWxlcyB3aGljaCBzaG91bGQKCSAqIG5vdCBwcm9kdWNlIGRpZmZzLCBidXQgd2hlbiB5b3UgYXJlIGRvaW5nIGNvcHkKCSAqIGRldGVjdGlvbiB5b3Ugd291bGQgbmVlZCB0aGVtLCBzbyBoZXJlIHRoZXkgYXJlIgoJICogZW50cmllcyB0byB0aGUgZGlmZi1jb3JlLiAgVGhleSB3aWxsIGJlIHByZWZpeGVkCgkgKiB3aXRoIHNvbWV0aGluZyBsaWtlICc9JyBvciAnKicgKEkgaGF2ZW4ndCBkZWNpZGVkCgkgKiB3aGljaCBidXQgc2hvdWxkIG5vdCBtYWtlIGFueSBkaWZmZXJlbmNlKS4KCSAqIEZlZWRpbmcgdGhlIHNhbWUgbmV3IGFuZCBvbGQgdG8gZGlmZl9jaGFuZ2UoKSAKCSAqIGFsc28gaGFzIHRoZSBzYW1lIGVmZmVjdC4KCSAqIEJlZm9yZSB0aGUgZmluYWwgb3V0cHV0IGhhcHBlbnMsIHRoZXkgYXJlIHBydW5lZCBhZnRlcgoJICogbWVyZ2VkIGludG8gcmVuYW1lL2NvcHkgcGFpcnMgYXMgYXBwcm9wcmlhdGUuCgkgKi8KCWlmIChvcHRpb25zLT5yZXZlcnNlX2RpZmYpCgkJYWRkcmVtb3ZlID0gKGFkZHJlbW92ZSA9PSAnKycgPyAnLScgOgoJCQkgICAgIGFkZHJlbW92ZSA9PSAnLScgPyAnKycgOiBhZGRyZW1vdmUpOwoKCWlmICghcGF0aCkgcGF0aCA9ICIiOwoJc3ByaW50Zihjb25jYXRwYXRoLCAiJXMlcyIsIGJhc2UsIHBhdGgpOwoJb25lID0gYWxsb2NfZmlsZXNwZWMoY29uY2F0cGF0aCk7Cgl0d28gPSBhbGxvY19maWxlc3BlYyhjb25jYXRwYXRoKTsKCglpZiAoYWRkcmVtb3ZlICE9ICcrJykKCQlmaWxsX2ZpbGVzcGVjKG9uZSwgc2hhMSwgbW9kZSk7CglpZiAoYWRkcmVtb3ZlICE9ICctJykKCQlmaWxsX2ZpbGVzcGVjKHR3bywgc2hhMSwgbW9kZSk7CgoJZGlmZl9xdWV1ZSgmZGlmZl9xdWV1ZWRfZGlmZiwgb25lLCB0d28pOwp9Cgp2b2lkIGRpZmZfY2hhbmdlKHN0cnVjdCBkaWZmX29wdGlvbnMgKm9wdGlvbnMsCgkJIHVuc2lnbmVkIG9sZF9tb2RlLCB1bnNpZ25lZCBuZXdfbW9kZSwKCQkgY29uc3QgdW5zaWduZWQgY2hhciAqb2xkX3NoYTEsCgkJIGNvbnN0IHVuc2lnbmVkIGNoYXIgKm5ld19zaGExLAoJCSBjb25zdCBjaGFyICpiYXNlLCBjb25zdCBjaGFyICpwYXRoKSAKewoJY2hhciBjb25jYXRwYXRoW1BBVEhfTUFYXTsKCXN0cnVjdCBkaWZmX2ZpbGVzcGVjICpvbmUsICp0d287CgoJaWYgKG9wdGlvbnMtPnJldmVyc2VfZGlmZikgewoJCXVuc2lnbmVkIHRtcDsKCQljb25zdCB1bnNpZ25lZCBjaGFyICp0bXBfYzsKCQl0bXAgPSBvbGRfbW9kZTsgb2xkX21vZGUgPSBuZXdfbW9kZTsgbmV3X21vZGUgPSB0bXA7CgkJdG1wX2MgPSBvbGRfc2hhMTsgb2xkX3NoYTEgPSBuZXdfc2hhMTsgbmV3X3NoYTEgPSB0bXBfYzsKCX0KCWlmICghcGF0aCkgcGF0aCA9ICIiOwoJc3ByaW50Zihjb25jYXRwYXRoLCAiJXMlcyIsIGJhc2UsIHBhdGgpOwoJb25lID0gYWxsb2NfZmlsZXNwZWMoY29uY2F0cGF0aCk7Cgl0d28gPSBhbGxvY19maWxlc3BlYyhjb25jYXRwYXRoKTsKCWZpbGxfZmlsZXNwZWMob25lLCBvbGRfc2hhMSwgb2xkX21vZGUpOwoJZmlsbF9maWxlc3BlYyh0d28sIG5ld19zaGExLCBuZXdfbW9kZSk7CgoJZGlmZl9xdWV1ZSgmZGlmZl9xdWV1ZWRfZGlmZiwgb25lLCB0d28pOwp9Cgp2b2lkIGRpZmZfdW5tZXJnZShzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHRpb25zLAoJCSAgY29uc3QgY2hhciAqcGF0aCkKewoJc3RydWN0IGRpZmZfZmlsZXNwZWMgKm9uZSwgKnR3bzsKCW9uZSA9IGFsbG9jX2ZpbGVzcGVjKHBhdGgpOwoJdHdvID0gYWxsb2NfZmlsZXNwZWMocGF0aCk7CglkaWZmX3F1ZXVlKCZkaWZmX3F1ZXVlZF9kaWZmLCBvbmUsIHR3byk7Cn0K",
    "text": "/*\n * Copyright (C) 2005 Junio C Hamano\n */\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include \"cache.h\"\n#include \"quote.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"delta.h\"\n#include \"xdiff-interface.h\"\n\nstatic int use_size_cache;\n\nint diff_rename_limit_default = -1;\n\nint git_diff_config(const char *var, const char *value)\n{\n\tif (!strcmp(var, \"diff.renamelimit\")) {\n\t\tdiff_rename_limit_default = git_config_int(var, value);\n\t\treturn 0;\n\t}\n\n\treturn git_default_config(var, value);\n}\n\nstatic char *quote_one(const char *str)\n{\n\tint needlen;\n\tchar *xp;\n\n\tif (!str)\n\t\treturn NULL;\n\tneedlen = quote_c_style(str, NULL, NULL, 0);\n\tif (!needlen)\n\t\treturn strdup(str);\n\txp = xmalloc(needlen + 1);\n\tquote_c_style(str, xp, NULL, 0);\n\treturn xp;\n}\n\nstatic char *quote_two(const char *one, const char *two)\n{\n\tint need_one = quote_c_style(one, NULL, NULL, 1);\n\tint need_two = quote_c_style(two, NULL, NULL, 1);\n\tchar *xp;\n\n\tif (need_one + need_two) {\n\t\tif (!need_one) need_one = strlen(one);\n\t\tif (!need_two) need_one = strlen(two);\n\n\t\txp = xmalloc(need_one + need_two + 3);\n\t\txp[0] = '\"';\n\t\tquote_c_style(one, xp + 1, NULL, 1);\n\t\tquote_c_style(two, xp + need_one + 1, NULL, 1);\n\t\tstrcpy(xp + need_one + need_two + 1, \"\\\"\");\n\t\treturn xp;\n\t}\n\tneed_one = strlen(one);\n\tneed_two = strlen(two);\n\txp = xmalloc(need_one + need_two + 1);\n\tstrcpy(xp, one);\n\tstrcpy(xp + need_one, two);\n\treturn xp;\n}\n\nstatic const char *external_diff(void)\n{\n\tstatic const char *external_diff_cmd = NULL;\n\tstatic int done_preparing = 0;\n\n\tif (done_preparing)\n\t\treturn external_diff_cmd;\n\texternal_diff_cmd = getenv(\"GIT_EXTERNAL_DIFF\");\n\tdone_preparing = 1;\n\treturn external_diff_cmd;\n}\n\n#define TEMPFILE_PATH_LEN\t\t50\n\nstatic struct diff_tempfile {\n\tconst char *name; /* filename external diff should read from */\n\tchar hex[41];\n\tchar mode[10];\n\tchar tmp_path[TEMPFILE_PATH_LEN];\n} diff_temp[2];\n\nstatic int count_lines(const char *data, int size)\n{\n\tint count, ch, completely_empty = 1, nl_just_seen = 0;\n\tcount = 0;\n\twhile (0 < size--) {\n\t\tch = *data++;\n\t\tif (ch == '\\n') {\n\t\t\tcount++;\n\t\t\tnl_just_seen = 1;\n\t\t\tcompletely_empty = 0;\n\t\t}\n\t\telse {\n\t\t\tnl_just_seen = 0;\n\t\t\tcompletely_empty = 0;\n\t\t}\n\t}\n\tif (completely_empty)\n\t\treturn 0;\n\tif (!nl_just_seen)\n\t\tcount++; /* no trailing newline */\n\treturn count;\n}\n\nstatic void print_line_count(int count)\n{\n\tswitch (count) {\n\tcase 0:\n\t\tprintf(\"0,0\");\n\t\tbreak;\n\tcase 1:\n\t\tprintf(\"1\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"1,%d\", count);\n\t\tbreak;\n\t}\n}\n\nstatic void copy_file(int prefix, const char *data, int size)\n{\n\tint ch, nl_just_seen = 1;\n\twhile (0 < size--) {\n\t\tch = *data++;\n\t\tif (nl_just_seen)\n\t\t\tputchar(prefix);\n\t\tputchar(ch);\n\t\tif (ch == '\\n')\n\t\t\tnl_just_seen = 1;\n\t\telse\n\t\t\tnl_just_seen = 0;\n\t}\n\tif (!nl_just_seen)\n\t\tprintf(\"\\n\\\\ No newline at end of file\\n\");\n}\n\nstatic void emit_rewrite_diff(const char *name_a,\n\t\t\t      const char *name_b,\n\t\t\t      struct diff_filespec *one,\n\t\t\t      struct diff_filespec *two)\n{\n\tint lc_a, lc_b;\n\tdiff_populate_filespec(one, 0);\n\tdiff_populate_filespec(two, 0);\n\tlc_a = count_lines(one->data, one->size);\n\tlc_b = count_lines(two->data, two->size);\n\tprintf(\"--- %s\\n+++ %s\\n@@ -\", name_a, name_b);\n\tprint_line_count(lc_a);\n\tprintf(\" +\");\n\tprint_line_count(lc_b);\n\tprintf(\" @@\\n\");\n\tif (lc_a)\n\t\tcopy_file('-', one->data, one->size);\n\tif (lc_b)\n\t\tcopy_file('+', two->data, two->size);\n}\n\nstatic int fill_mmfile(mmfile_t *mf, struct diff_filespec *one)\n{\n\tif (!DIFF_FILE_VALID(one)) {\n\t\tmf->ptr = \"\"; /* does not matter */\n\t\tmf->size = 0;\n\t\treturn 0;\n\t}\n\telse if (diff_populate_filespec(one, 0))\n\t\treturn -1;\n\tmf->ptr = one->data;\n\tmf->size = one->size;\n\treturn 0;\n}\n\nstruct emit_callback {\n\tconst char **label_path;\n};\n\nstatic int fn_out(void *priv, mmbuffer_t *mb, int nbuf)\n{\n\tint i;\n\tstruct emit_callback *ecbdata = priv;\n\n\tif (ecbdata->label_path[0]) {\n\t\tprintf(\"--- %s\\n\", ecbdata->label_path[0]);\n\t\tprintf(\"+++ %s\\n\", ecbdata->label_path[1]);\n\t\tecbdata->label_path[0] = ecbdata->label_path[1] = NULL;\n\t}\n\tfor (i = 0; i < nbuf; i++)\n\t\tif (!fwrite(mb[i].ptr, mb[i].size, 1, stdout))\n\t\t\treturn -1;\n\treturn 0;\n}\n\nstatic char *pprint_rename(const char *a, const char *b)\n{\n\tconst char *old = a;\n\tconst char *new = b;\n\tchar *name = NULL;\n\tint pfx_length, sfx_length;\n\tint len_a = strlen(a);\n\tint len_b = strlen(b);\n\n\t/* Find common prefix */\n\tpfx_length = 0;\n\twhile (*old && *new && *old == *new) {\n\t\tif (*old == '/')\n\t\t\tpfx_length = old - a + 1;\n\t\told++;\n\t\tnew++;\n\t}\n\n\t/* Find common suffix */\n\told = a + len_a;\n\tnew = b + len_b;\n\tsfx_length = 0;\n\twhile (a <= old && b <= new && *old == *new) {\n\t\tif (*old == '/')\n\t\t\tsfx_length = len_a - (old - a);\n\t\told--;\n\t\tnew--;\n\t}\n\n\t/*\n\t * pfx{mid-a => mid-b}sfx\n\t * {pfx-a => pfx-b}sfx\n\t * pfx{sfx-a => sfx-b}\n\t * name-a => name-b\n\t */\n\tif (pfx_length + sfx_length) {\n\t\tname = xmalloc(len_a + len_b - pfx_length - sfx_length + 7);\n\t\tsprintf(name, \"%.*s{%.*s => %.*s}%s\",\n\t\t\tpfx_length, a,\n\t\t\tlen_a - pfx_length - sfx_length, a + pfx_length,\n\t\t\tlen_b - pfx_length - sfx_length, b + pfx_length,\n\t\t\ta + len_a - sfx_length);\n\t}\n\telse {\n\t\tname = xmalloc(len_a + len_b + 5);\n\t\tsprintf(name, \"%s => %s\", a, b);\n\t}\n\treturn name;\n}\n\nstruct diffstat_t {\n\tstruct xdiff_emit_state xm;\n\n\tint nr;\n\tint alloc;\n\tstruct diffstat_file {\n\t\tchar *name;\n\t\tunsigned is_unmerged:1;\n\t\tunsigned is_binary:1;\n\t\tunsigned is_renamed:1;\n\t\tunsigned int added, deleted;\n\t} **files;\n};\n\nstatic struct diffstat_file *diffstat_add(struct diffstat_t *diffstat,\n\t\t\t\t\t  const char *name_a,\n\t\t\t\t\t  const char *name_b)\n{\n\tstruct diffstat_file *x;\n\tx = xcalloc(sizeof (*x), 1);\n\tif (diffstat->nr == diffstat->alloc) {\n\t\tdiffstat->alloc = alloc_nr(diffstat->alloc);\n\t\tdiffstat->files = xrealloc(diffstat->files,\n\t\t\t\tdiffstat->alloc * sizeof(x));\n\t}\n\tdiffstat->files[diffstat->nr++] = x;\n\tif (name_b) {\n\t\tx->name = pprint_rename(name_a, name_b);\n\t\tx->is_renamed = 1;\n\t}\n\telse\n\t\tx->name = strdup(name_a);\n\treturn x;\n}\n\nstatic void diffstat_consume(void *priv, char *line, unsigned long len)\n{\n\tstruct diffstat_t *diffstat = priv;\n\tstruct diffstat_file *x = diffstat->files[diffstat->nr - 1];\n\n\tif (line[0] == '+')\n\t\tx->added++;\n\telse if (line[0] == '-')\n\t\tx->deleted++;\n}\n\nstatic const char pluses[] = \"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\";\nstatic const char minuses[]= \"----------------------------------------------------------------------\";\n\nstatic void show_stats(struct diffstat_t* data)\n{\n\tint i, len, add, del, total, adds = 0, dels = 0;\n\tint max, max_change = 0, max_len = 0;\n\tint total_files = data->nr;\n\n\tif (data->nr == 0)\n\t\treturn;\n\n\tfor (i = 0; i < data->nr; i++) {\n\t\tstruct diffstat_file *file = data->files[i];\n\n\t\tlen = strlen(file->name);\n\t\tif (max_len < len)\n\t\t\tmax_len = len;\n\n\t\tif (file->is_binary || file->is_unmerged)\n\t\t\tcontinue;\n\t\tif (max_change < file->added + file->deleted)\n\t\t\tmax_change = file->added + file->deleted;\n\t}\n\n\tfor (i = 0; i < data->nr; i++) {\n\t\tchar *prefix = \"\";\n\t\tchar *name = data->files[i]->name;\n\t\tint added = data->files[i]->added;\n\t\tint deleted = data->files[i]->deleted;\n\n\t\tif (0 < (len = quote_c_style(name, NULL, NULL, 0))) {\n\t\t\tchar *qname = xmalloc(len + 1);\n\t\t\tquote_c_style(name, qname, NULL, 0);\n\t\t\tfree(name);\n\t\t\tdata->files[i]->name = name = qname;\n\t\t}\n\n\t\t/*\n\t\t * \"scale\" the filename\n\t\t */\n\t\tlen = strlen(name);\n\t\tmax = max_len;\n\t\tif (max > 50)\n\t\t\tmax = 50;\n\t\tif (len > max) {\n\t\t\tchar *slash;\n\t\t\tprefix = \"...\";\n\t\t\tmax -= 3;\n\t\t\tname += len - max;\n\t\t\tslash = strchr(name, '/');\n\t\t\tif (slash)\n\t\t\t\tname = slash;\n\t\t}\n\t\tlen = max;\n\n\t\t/*\n\t\t * scale the add/delete\n\t\t */\n\t\tmax = max_change;\n\t\tif (max + len > 70)\n\t\t\tmax = 70 - len;\n\n\t\tif (data->files[i]->is_binary) {\n\t\t\tprintf(\" %s%-*s |  Bin\\n\", prefix, len, name);\n\t\t\tgoto free_diffstat_file;\n\t\t}\n\t\telse if (data->files[i]->is_unmerged) {\n\t\t\tprintf(\" %s%-*s |  Unmerged\\n\", prefix, len, name);\n\t\t\tgoto free_diffstat_file;\n\t\t}\n\t\telse if (!data->files[i]->is_renamed &&\n\t\t\t (added + deleted == 0)) {\n\t\t\ttotal_files--;\n\t\t\tgoto free_diffstat_file;\n\t\t}\n\n\t\tadd = added;\n\t\tdel = deleted;\n\t\ttotal = add + del;\n\t\tadds += add;\n\t\tdels += del;\n\n\t\tif (max_change > 0) {\n\t\t\ttotal = (total * max + max_change / 2) / max_change;\n\t\t\tadd = (add * max + max_change / 2) / max_change;\n\t\t\tdel = total - add;\n\t\t}\n\t\tprintf(\" %s%-*s |%5d %.*s%.*s\\n\", prefix,\n\t\t\t\tlen, name, added + deleted,\n\t\t\t\tadd, pluses, del, minuses);\n\tfree_diffstat_file:\n\t\tfree(data->files[i]->name);\n\t\tfree(data->files[i]);\n\t}\n\tfree(data->files);\n\tprintf(\" %d files changed, %d insertions(+), %d deletions(-)\\n\",\n\t\t\ttotal_files, adds, dels);\n}\n\nstatic unsigned char *deflate_it(char *data,\n\t\t\t\t unsigned long size,\n\t\t\t\t unsigned long *result_size)\n{\n\tint bound;\n\tunsigned char *deflated;\n\tz_stream stream;\n\n\tmemset(&stream, 0, sizeof(stream));\n\tdeflateInit(&stream, Z_BEST_COMPRESSION);\n\tbound = deflateBound(&stream, size);\n\tdeflated = xmalloc(bound);\n\tstream.next_out = deflated;\n\tstream.avail_out = bound;\n\n\tstream.next_in = (unsigned char *)data;\n\tstream.avail_in = size;\n\twhile (deflate(&stream, Z_FINISH) == Z_OK)\n\t\t; /* nothing */\n\tdeflateEnd(&stream);\n\t*result_size = stream.total_out;\n\treturn deflated;\n}\n\nstatic void emit_binary_diff(mmfile_t *one, mmfile_t *two)\n{\n\tvoid *cp;\n\tvoid *delta;\n\tvoid *deflated;\n\tvoid *data;\n\tunsigned long orig_size;\n\tunsigned long delta_size;\n\tunsigned long deflate_size;\n\tunsigned long data_size;\n\n\tprintf(\"GIT binary patch\\n\");\n\t/* We could do deflated delta, or we could do just deflated two,\n\t * whichever is smaller.\n\t */\n\tdelta = NULL;\n\tdeflated = deflate_it(two->ptr, two->size, &deflate_size);\n\tif (one->size && two->size) {\n\t\tdelta = diff_delta(one->ptr, one->size,\n\t\t\t\t   two->ptr, two->size,\n\t\t\t\t   &delta_size, deflate_size);\n\t\tif (delta) {\n\t\t\tvoid *to_free = delta;\n\t\t\torig_size = delta_size;\n\t\t\tdelta = deflate_it(delta, delta_size, &delta_size);\n\t\t\tfree(to_free);\n\t\t}\n\t}\n\n\tif (delta && delta_size < deflate_size) {\n\t\tprintf(\"delta %lu\\n\", orig_size);\n\t\tfree(deflated);\n\t\tdata = delta;\n\t\tdata_size = delta_size;\n\t}\n\telse {\n\t\tprintf(\"literal %lu\\n\", two->size);\n\t\tfree(delta);\n\t\tdata = deflated;\n\t\tdata_size = deflate_size;\n\t}\n\n\t/* emit data encoded in base85 */\n\tcp = data;\n\twhile (data_size) {\n\t\tint bytes = (52 < data_size) ? 52 : data_size;\n\t\tchar line[70];\n\t\tdata_size -= bytes;\n\t\tif (bytes <= 26)\n\t\t\tline[0] = bytes + 'A' - 1;\n\t\telse\n\t\t\tline[0] = bytes - 26 + 'a' - 1;\n\t\tencode_85(line + 1, cp, bytes);\n\t\tcp += bytes;\n\t\tputs(line);\n\t}\n\tprintf(\"\\n\");\n\tfree(data);\n}\n\n#define FIRST_FEW_BYTES 8000\nstatic int mmfile_is_binary(mmfile_t *mf)\n{\n\tlong sz = mf->size;\n\tif (FIRST_FEW_BYTES < sz)\n\t\tsz = FIRST_FEW_BYTES;\n\tif (memchr(mf->ptr, 0, sz))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void builtin_diff(const char *name_a,\n\t\t\t const char *name_b,\n\t\t\t struct diff_filespec *one,\n\t\t\t struct diff_filespec *two,\n\t\t\t const char *xfrm_msg,\n\t\t\t struct diff_options *o,\n\t\t\t int complete_rewrite)\n{\n\tmmfile_t mf1, mf2;\n\tconst char *lbl[2];\n\tchar *a_one, *b_two;\n\n\ta_one = quote_two(\"a/\", name_a);\n\tb_two = quote_two(\"b/\", name_b);\n\tlbl[0] = DIFF_FILE_VALID(one) ? a_one : \"/dev/null\";\n\tlbl[1] = DIFF_FILE_VALID(two) ? b_two : \"/dev/null\";\n\tprintf(\"diff --git %s %s\\n\", a_one, b_two);\n\tif (lbl[0][0] == '/') {\n\t\t/* /dev/null */\n\t\tprintf(\"new file mode %06o\\n\", two->mode);\n\t\tif (xfrm_msg && xfrm_msg[0])\n\t\t\tputs(xfrm_msg);\n\t}\n\telse if (lbl[1][0] == '/') {\n\t\tprintf(\"deleted file mode %06o\\n\", one->mode);\n\t\tif (xfrm_msg && xfrm_msg[0])\n\t\t\tputs(xfrm_msg);\n\t}\n\telse {\n\t\tif (one->mode != two->mode) {\n\t\t\tprintf(\"old mode %06o\\n\", one->mode);\n\t\t\tprintf(\"new mode %06o\\n\", two->mode);\n\t\t}\n\t\tif (xfrm_msg && xfrm_msg[0])\n\t\t\tputs(xfrm_msg);\n\t\t/*\n\t\t * we do not run diff between different kind\n\t\t * of objects.\n\t\t */\n\t\tif ((one->mode ^ two->mode) & S_IFMT)\n\t\t\tgoto free_ab_and_return;\n\t\tif (complete_rewrite) {\n\t\t\temit_rewrite_diff(name_a, name_b, one, two);\n\t\t\tgoto free_ab_and_return;\n\t\t}\n\t}\n\n\tif (fill_mmfile(&mf1, one) < 0 || fill_mmfile(&mf2, two) < 0)\n\t\tdie(\"unable to read files to diff\");\n\n\tif (mmfile_is_binary(&mf1) || mmfile_is_binary(&mf2)) {\n\t\t/* Quite common confusing case */\n\t\tif (mf1.size == mf2.size &&\n\t\t    !memcmp(mf1.ptr, mf2.ptr, mf1.size))\n\t\t\tgoto free_ab_and_return;\n\t\tif (o->binary)\n\t\t\temit_binary_diff(&mf1, &mf2);\n\t\telse\n\t\t\tprintf(\"Binary files %s and %s differ\\n\",\n\t\t\t       lbl[0], lbl[1]);\n\t}\n\telse {\n\t\t/* Crazy xdl interfaces.. */\n\t\tconst char *diffopts = getenv(\"GIT_DIFF_OPTS\");\n\t\txpparam_t xpp;\n\t\txdemitconf_t xecfg;\n\t\txdemitcb_t ecb;\n\t\tstruct emit_callback ecbdata;\n\n\t\tecbdata.label_path = lbl;\n\t\txpp.flags = XDF_NEED_MINIMAL;\n\t\txecfg.ctxlen = 3;\n\t\txecfg.flags = XDL_EMIT_FUNCNAMES;\n\t\tif (!diffopts)\n\t\t\t;\n\t\telse if (!strncmp(diffopts, \"--unified=\", 10))\n\t\t\txecfg.ctxlen = strtoul(diffopts + 10, NULL, 10);\n\t\telse if (!strncmp(diffopts, \"-u\", 2))\n\t\t\txecfg.ctxlen = strtoul(diffopts + 2, NULL, 10);\n\t\tecb.outf = fn_out;\n\t\tecb.priv = &ecbdata;\n\t\txdl_diff(&mf1, &mf2, &xpp, &xecfg, &ecb);\n\t}\n\n free_ab_and_return:\n\tfree(a_one);\n\tfree(b_two);\n\treturn;\n}\n\nstatic void builtin_diffstat(const char *name_a, const char *name_b,\n\t\t\t     struct diff_filespec *one,\n\t\t\t     struct diff_filespec *two,\n\t\t\t     struct diffstat_t *diffstat,\n\t\t\t     int complete_rewrite)\n{\n\tmmfile_t mf1, mf2;\n\tstruct diffstat_file *data;\n\n\tdata = diffstat_add(diffstat, name_a, name_b);\n\n\tif (!one || !two) {\n\t\tdata->is_unmerged = 1;\n\t\treturn;\n\t}\n\tif (complete_rewrite) {\n\t\tdiff_populate_filespec(one, 0);\n\t\tdiff_populate_filespec(two, 0);\n\t\tdata->deleted = count_lines(one->data, one->size);\n\t\tdata->added = count_lines(two->data, two->size);\n\t\treturn;\n\t}\n\tif (fill_mmfile(&mf1, one) < 0 || fill_mmfile(&mf2, two) < 0)\n\t\tdie(\"unable to read files to diff\");\n\n\tif (mmfile_is_binary(&mf1) || mmfile_is_binary(&mf2))\n\t\tdata->is_binary = 1;\n\telse {\n\t\t/* Crazy xdl interfaces.. */\n\t\txpparam_t xpp;\n\t\txdemitconf_t xecfg;\n\t\txdemitcb_t ecb;\n\n\t\txpp.flags = XDF_NEED_MINIMAL;\n\t\txecfg.ctxlen = 0;\n\t\txecfg.flags = 0;\n\t\tecb.outf = xdiff_outf;\n\t\tecb.priv = diffstat;\n\t\txdl_diff(&mf1, &mf2, &xpp, &xecfg, &ecb);\n\t}\n}\n\nstruct diff_filespec *alloc_filespec(const char *path)\n{\n\tint namelen = strlen(path);\n\tstruct diff_filespec *spec = xmalloc(sizeof(*spec) + namelen + 1);\n\n\tmemset(spec, 0, sizeof(*spec));\n\tspec->path = (char *)(spec + 1);\n\tmemcpy(spec->path, path, namelen+1);\n\treturn spec;\n}\n\nvoid fill_filespec(struct diff_filespec *spec, const unsigned char *sha1,\n\t\t   unsigned short mode)\n{\n\tif (mode) {\n\t\tspec->mode = canon_mode(mode);\n\t\tmemcpy(spec->sha1, sha1, 20);\n\t\tspec->sha1_valid = !!memcmp(sha1, null_sha1, 20);\n\t}\n}\n\n/*\n * Given a name and sha1 pair, if the dircache tells us the file in\n * the work tree has that object contents, return true, so that\n * prepare_temp_file() does not have to inflate and extract.\n */\nstatic int work_tree_matches(const char *name, const unsigned char *sha1)\n{\n\tstruct cache_entry *ce;\n\tstruct stat st;\n\tint pos, len;\n\n\t/* We do not read the cache ourselves here, because the\n\t * benchmark with my previous version that always reads cache\n\t * shows that it makes things worse for diff-tree comparing\n\t * two linux-2.6 kernel trees in an already checked out work\n\t * tree.  This is because most diff-tree comparisons deal with\n\t * only a small number of files, while reading the cache is\n\t * expensive for a large project, and its cost outweighs the\n\t * savings we get by not inflating the object to a temporary\n\t * file.  Practically, this code only helps when we are used\n\t * by diff-cache --cached, which does read the cache before\n\t * calling us.\n\t */\n\tif (!active_cache)\n\t\treturn 0;\n\n\tlen = strlen(name);\n\tpos = cache_name_pos(name, len);\n\tif (pos < 0)\n\t\treturn 0;\n\tce = active_cache[pos];\n\tif ((lstat(name, &st) < 0) ||\n\t    !S_ISREG(st.st_mode) || /* careful! */\n\t    ce_match_stat(ce, &st, 0) ||\n\t    memcmp(sha1, ce->sha1, 20))\n\t\treturn 0;\n\t/* we return 1 only when we can stat, it is a regular file,\n\t * stat information matches, and sha1 recorded in the cache\n\t * matches.  I.e. we know the file in the work tree really is\n\t * the same as the <name, sha1> pair.\n\t */\n\treturn 1;\n}\n\nstatic struct sha1_size_cache {\n\tunsigned char sha1[20];\n\tunsigned long size;\n} **sha1_size_cache;\nstatic int sha1_size_cache_nr, sha1_size_cache_alloc;\n\nstatic struct sha1_size_cache *locate_size_cache(unsigned char *sha1,\n\t\t\t\t\t\t int find_only,\n\t\t\t\t\t\t unsigned long size)\n{\n\tint first, last;\n\tstruct sha1_size_cache *e;\n\n\tfirst = 0;\n\tlast = sha1_size_cache_nr;\n\twhile (last > first) {\n\t\tint cmp, next = (last + first) >> 1;\n\t\te = sha1_size_cache[next];\n\t\tcmp = memcmp(e->sha1, sha1, 20);\n\t\tif (!cmp)\n\t\t\treturn e;\n\t\tif (cmp < 0) {\n\t\t\tlast = next;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst = next+1;\n\t}\n\t/* not found */\n\tif (find_only)\n\t\treturn NULL;\n\t/* insert to make it at \"first\" */\n\tif (sha1_size_cache_alloc <= sha1_size_cache_nr) {\n\t\tsha1_size_cache_alloc = alloc_nr(sha1_size_cache_alloc);\n\t\tsha1_size_cache = xrealloc(sha1_size_cache,\n\t\t\t\t\t   sha1_size_cache_alloc *\n\t\t\t\t\t   sizeof(*sha1_size_cache));\n\t}\n\tsha1_size_cache_nr++;\n\tif (first < sha1_size_cache_nr)\n\t\tmemmove(sha1_size_cache + first + 1, sha1_size_cache + first,\n\t\t\t(sha1_size_cache_nr - first - 1) *\n\t\t\tsizeof(*sha1_size_cache));\n\te = xmalloc(sizeof(struct sha1_size_cache));\n\tsha1_size_cache[first] = e;\n\tmemcpy(e->sha1, sha1, 20);\n\te->size = size;\n\treturn e;\n}\n\n/*\n * While doing rename detection and pickaxe operation, we may need to\n * grab the data for the blob (or file) for our own in-core comparison.\n * diff_filespec has data and size fields for this purpose.\n */\nint diff_populate_filespec(struct diff_filespec *s, int size_only)\n{\n\tint err = 0;\n\tif (!DIFF_FILE_VALID(s))\n\t\tdie(\"internal error: asking to populate invalid file.\");\n\tif (S_ISDIR(s->mode))\n\t\treturn -1;\n\n\tif (!use_size_cache)\n\t\tsize_only = 0;\n\n\tif (s->data)\n\t\treturn err;\n\tif (!s->sha1_valid ||\n\t    work_tree_matches(s->path, s->sha1)) {\n\t\tstruct stat st;\n\t\tint fd;\n\t\tif (lstat(s->path, &st) < 0) {\n\t\t\tif (errno == ENOENT) {\n\t\t\terr_empty:\n\t\t\t\terr = -1;\n\t\t\tempty:\n\t\t\t\ts->data = \"\";\n\t\t\t\ts->size = 0;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\ts->size = st.st_size;\n\t\tif (!s->size)\n\t\t\tgoto empty;\n\t\tif (size_only)\n\t\t\treturn 0;\n\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\tint ret;\n\t\t\ts->data = xmalloc(s->size);\n\t\t\ts->should_free = 1;\n\t\t\tret = readlink(s->path, s->data, s->size);\n\t\t\tif (ret < 0) {\n\t\t\t\tfree(s->data);\n\t\t\t\tgoto err_empty;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tfd = open(s->path, O_RDONLY);\n\t\tif (fd < 0)\n\t\t\tgoto err_empty;\n\t\ts->data = mmap(NULL, s->size, PROT_READ, MAP_PRIVATE, fd, 0);\n\t\tclose(fd);\n\t\tif (s->data == MAP_FAILED)\n\t\t\tgoto err_empty;\n\t\ts->should_munmap = 1;\n\t}\n\telse {\n\t\tchar type[20];\n\t\tstruct sha1_size_cache *e;\n\n\t\tif (size_only) {\n\t\t\te = locate_size_cache(s->sha1, 1, 0);\n\t\t\tif (e) {\n\t\t\t\ts->size = e->size;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!sha1_object_info(s->sha1, type, &s->size))\n\t\t\t\tlocate_size_cache(s->sha1, 0, s->size);\n\t\t}\n\t\telse {\n\t\t\ts->data = read_sha1_file(s->sha1, type, &s->size);\n\t\t\ts->should_free = 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid diff_free_filespec_data(struct diff_filespec *s)\n{\n\tif (s->should_free)\n\t\tfree(s->data);\n\telse if (s->should_munmap)\n\t\tmunmap(s->data, s->size);\n\ts->should_free = s->should_munmap = 0;\n\ts->data = NULL;\n\tfree(s->cnt_data);\n\ts->cnt_data = NULL;\n}\n\nstatic void prep_temp_blob(struct diff_tempfile *temp,\n\t\t\t   void *blob,\n\t\t\t   unsigned long size,\n\t\t\t   const unsigned char *sha1,\n\t\t\t   int mode)\n{\n\tint fd;\n\n\tfd = git_mkstemp(temp->tmp_path, TEMPFILE_PATH_LEN, \".diff_XXXXXX\");\n\tif (fd < 0)\n\t\tdie(\"unable to create temp-file\");\n\tif (write(fd, blob, size) != size)\n\t\tdie(\"unable to write temp-file\");\n\tclose(fd);\n\ttemp->name = temp->tmp_path;\n\tstrcpy(temp->hex, sha1_to_hex(sha1));\n\ttemp->hex[40] = 0;\n\tsprintf(temp->mode, \"%06o\", mode);\n}\n\nstatic void prepare_temp_file(const char *name,\n\t\t\t      struct diff_tempfile *temp,\n\t\t\t      struct diff_filespec *one)\n{\n\tif (!DIFF_FILE_VALID(one)) {\n\tnot_a_valid_file:\n\t\t/* A '-' entry produces this for file-2, and\n\t\t * a '+' entry produces this for file-1.\n\t\t */\n\t\ttemp->name = \"/dev/null\";\n\t\tstrcpy(temp->hex, \".\");\n\t\tstrcpy(temp->mode, \".\");\n\t\treturn;\n\t}\n\n\tif (!one->sha1_valid ||\n\t    work_tree_matches(name, one->sha1)) {\n\t\tstruct stat st;\n\t\tif (lstat(name, &st) < 0) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tgoto not_a_valid_file;\n\t\t\tdie(\"stat(%s): %s\", name, strerror(errno));\n\t\t}\n\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\tint ret;\n\t\t\tchar buf[PATH_MAX + 1]; /* ought to be SYMLINK_MAX */\n\t\t\tif (sizeof(buf) <= st.st_size)\n\t\t\t\tdie(\"symlink too long: %s\", name);\n\t\t\tret = readlink(name, buf, st.st_size);\n\t\t\tif (ret < 0)\n\t\t\t\tdie(\"readlink(%s)\", name);\n\t\t\tprep_temp_blob(temp, buf, st.st_size,\n\t\t\t\t       (one->sha1_valid ?\n\t\t\t\t\tone->sha1 : null_sha1),\n\t\t\t\t       (one->sha1_valid ?\n\t\t\t\t\tone->mode : S_IFLNK));\n\t\t}\n\t\telse {\n\t\t\t/* we can borrow from the file in the work tree */\n\t\t\ttemp->name = name;\n\t\t\tif (!one->sha1_valid)\n\t\t\t\tstrcpy(temp->hex, sha1_to_hex(null_sha1));\n\t\t\telse\n\t\t\t\tstrcpy(temp->hex, sha1_to_hex(one->sha1));\n\t\t\t/* Even though we may sometimes borrow the\n\t\t\t * contents from the work tree, we always want\n\t\t\t * one->mode.  mode is trustworthy even when\n\t\t\t * !(one->sha1_valid), as long as\n\t\t\t * DIFF_FILE_VALID(one).\n\t\t\t */\n\t\t\tsprintf(temp->mode, \"%06o\", one->mode);\n\t\t}\n\t\treturn;\n\t}\n\telse {\n\t\tif (diff_populate_filespec(one, 0))\n\t\t\tdie(\"cannot read data blob for %s\", one->path);\n\t\tprep_temp_blob(temp, one->data, one->size,\n\t\t\t       one->sha1, one->mode);\n\t}\n}\n\nstatic void remove_tempfile(void)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++)\n\t\tif (diff_temp[i].name == diff_temp[i].tmp_path) {\n\t\t\tunlink(diff_temp[i].name);\n\t\t\tdiff_temp[i].name = NULL;\n\t\t}\n}\n\nstatic void remove_tempfile_on_signal(int signo)\n{\n\tremove_tempfile();\n\tsignal(SIGINT, SIG_DFL);\n\traise(signo);\n}\n\nstatic int spawn_prog(const char *pgm, const char **arg)\n{\n\tpid_t pid;\n\tint status;\n\n\tfflush(NULL);\n\tpid = fork();\n\tif (pid < 0)\n\t\tdie(\"unable to fork\");\n\tif (!pid) {\n\t\texecvp(pgm, (char *const*) arg);\n\t\texit(255);\n\t}\n\n\twhile (waitpid(pid, &status, 0) < 0) {\n\t\tif (errno == EINTR)\n\t\t\tcontinue;\n\t\treturn -1;\n\t}\n\n\t/* Earlier we did not check the exit status because\n\t * diff exits non-zero if files are different, and\n\t * we are not interested in knowing that.  It was a\n\t * mistake which made it harder to quit a diff-*\n\t * session that uses the git-apply-patch-script as\n\t * the GIT_EXTERNAL_DIFF.  A custom GIT_EXTERNAL_DIFF\n\t * should also exit non-zero only when it wants to\n\t * abort the entire diff-* session.\n\t */\n\tif (WIFEXITED(status) && !WEXITSTATUS(status))\n\t\treturn 0;\n\treturn -1;\n}\n\n/* An external diff command takes:\n *\n * diff-cmd name infile1 infile1-sha1 infile1-mode \\\n *               infile2 infile2-sha1 infile2-mode [ rename-to ]\n *\n */\nstatic void run_external_diff(const char *pgm,\n\t\t\t      const char *name,\n\t\t\t      const char *other,\n\t\t\t      struct diff_filespec *one,\n\t\t\t      struct diff_filespec *two,\n\t\t\t      const char *xfrm_msg,\n\t\t\t      int complete_rewrite)\n{\n\tconst char *spawn_arg[10];\n\tstruct diff_tempfile *temp = diff_temp;\n\tint retval;\n\tstatic int atexit_asked = 0;\n\tconst char *othername;\n\tconst char **arg = &spawn_arg[0];\n\n\tothername = (other? other : name);\n\tif (one && two) {\n\t\tprepare_temp_file(name, &temp[0], one);\n\t\tprepare_temp_file(othername, &temp[1], two);\n\t\tif (! atexit_asked &&\n\t\t    (temp[0].name == temp[0].tmp_path ||\n\t\t     temp[1].name == temp[1].tmp_path)) {\n\t\t\tatexit_asked = 1;\n\t\t\tatexit(remove_tempfile);\n\t\t}\n\t\tsignal(SIGINT, remove_tempfile_on_signal);\n\t}\n\n\tif (one && two) {\n\t\t*arg++ = pgm;\n\t\t*arg++ = name;\n\t\t*arg++ = temp[0].name;\n\t\t*arg++ = temp[0].hex;\n\t\t*arg++ = temp[0].mode;\n\t\t*arg++ = temp[1].name;\n\t\t*arg++ = temp[1].hex;\n\t\t*arg++ = temp[1].mode;\n\t\tif (other) {\n\t\t\t*arg++ = other;\n\t\t\t*arg++ = xfrm_msg;\n\t\t}\n\t} else {\n\t\t*arg++ = pgm;\n\t\t*arg++ = name;\n\t}\n\t*arg = NULL;\n\tretval = spawn_prog(pgm, spawn_arg);\n\tremove_tempfile();\n\tif (retval) {\n\t\tfprintf(stderr, \"external diff died, stopping at %s.\\n\", name);\n\t\texit(1);\n\t}\n}\n\nstatic void run_diff_cmd(const char *pgm,\n\t\t\t const char *name,\n\t\t\t const char *other,\n\t\t\t struct diff_filespec *one,\n\t\t\t struct diff_filespec *two,\n\t\t\t const char *xfrm_msg,\n\t\t\t struct diff_options *o,\n\t\t\t int complete_rewrite)\n{\n\tif (pgm) {\n\t\trun_external_diff(pgm, name, other, one, two, xfrm_msg,\n\t\t\t\t  complete_rewrite);\n\t\treturn;\n\t}\n\tif (one && two)\n\t\tbuiltin_diff(name, other ? other : name,\n\t\t\t     one, two, xfrm_msg, o, complete_rewrite);\n\telse\n\t\tprintf(\"* Unmerged path %s\\n\", name);\n}\n\nstatic void diff_fill_sha1_info(struct diff_filespec *one)\n{\n\tif (DIFF_FILE_VALID(one)) {\n\t\tif (!one->sha1_valid) {\n\t\t\tstruct stat st;\n\t\t\tif (lstat(one->path, &st) < 0)\n\t\t\t\tdie(\"stat %s\", one->path);\n\t\t\tif (index_path(one->sha1, one->path, &st, 0))\n\t\t\t\tdie(\"cannot hash %s\\n\", one->path);\n\t\t}\n\t}\n\telse\n\t\tmemset(one->sha1, 0, 20);\n}\n\nstatic void run_diff(struct diff_filepair *p, struct diff_options *o)\n{\n\tconst char *pgm = external_diff();\n\tchar msg[PATH_MAX*2+300], *xfrm_msg;\n\tstruct diff_filespec *one;\n\tstruct diff_filespec *two;\n\tconst char *name;\n\tconst char *other;\n\tchar *name_munged, *other_munged;\n\tint complete_rewrite = 0;\n\tint len;\n\n\tif (DIFF_PAIR_UNMERGED(p)) {\n\t\t/* unmerged */\n\t\trun_diff_cmd(pgm, p->one->path, NULL, NULL, NULL, NULL, o, 0);\n\t\treturn;\n\t}\n\n\tname = p->one->path;\n\tother = (strcmp(name, p->two->path) ? p->two->path : NULL);\n\tname_munged = quote_one(name);\n\tother_munged = quote_one(other);\n\tone = p->one; two = p->two;\n\n\tdiff_fill_sha1_info(one);\n\tdiff_fill_sha1_info(two);\n\n\tlen = 0;\n\tswitch (p->status) {\n\tcase DIFF_STATUS_COPIED:\n\t\tlen += snprintf(msg + len, sizeof(msg) - len,\n\t\t\t\t\"similarity index %d%%\\n\"\n\t\t\t\t\"copy from %s\\n\"\n\t\t\t\t\"copy to %s\\n\",\n\t\t\t\t(int)(0.5 + p->score * 100.0/MAX_SCORE),\n\t\t\t\tname_munged, other_munged);\n\t\tbreak;\n\tcase DIFF_STATUS_RENAMED:\n\t\tlen += snprintf(msg + len, sizeof(msg) - len,\n\t\t\t\t\"similarity index %d%%\\n\"\n\t\t\t\t\"rename from %s\\n\"\n\t\t\t\t\"rename to %s\\n\",\n\t\t\t\t(int)(0.5 + p->score * 100.0/MAX_SCORE),\n\t\t\t\tname_munged, other_munged);\n\t\tbreak;\n\tcase DIFF_STATUS_MODIFIED:\n\t\tif (p->score) {\n\t\t\tlen += snprintf(msg + len, sizeof(msg) - len,\n\t\t\t\t\t\"dissimilarity index %d%%\\n\",\n\t\t\t\t\t(int)(0.5 + p->score *\n\t\t\t\t\t      100.0/MAX_SCORE));\n\t\t\tcomplete_rewrite = 1;\n\t\t\tbreak;\n\t\t}\n\t\t/* fallthru */\n\tdefault:\n\t\t/* nothing */\n\t\t;\n\t}\n\n\tif (memcmp(one->sha1, two->sha1, 20)) {\n\t\tint abbrev = o->full_index ? 40 : DEFAULT_ABBREV;\n\n\t\tlen += snprintf(msg + len, sizeof(msg) - len,\n\t\t\t\t\"index %.*s..%.*s\",\n\t\t\t\tabbrev, sha1_to_hex(one->sha1),\n\t\t\t\tabbrev, sha1_to_hex(two->sha1));\n\t\tif (one->mode == two->mode)\n\t\t\tlen += snprintf(msg + len, sizeof(msg) - len,\n\t\t\t\t\t\" %06o\", one->mode);\n\t\tlen += snprintf(msg + len, sizeof(msg) - len, \"\\n\");\n\t}\n\n\tif (len)\n\t\tmsg[--len] = 0;\n\txfrm_msg = len ? msg : NULL;\n\n\tif (!pgm &&\n\t    DIFF_FILE_VALID(one) && DIFF_FILE_VALID(two) &&\n\t    (S_IFMT & one->mode) != (S_IFMT & two->mode)) {\n\t\t/* a filepair that changes between file and symlink\n\t\t * needs to be split into deletion and creation.\n\t\t */\n\t\tstruct diff_filespec *null = alloc_filespec(two->path);\n\t\trun_diff_cmd(NULL, name, other, one, null, xfrm_msg, o, 0);\n\t\tfree(null);\n\t\tnull = alloc_filespec(one->path);\n\t\trun_diff_cmd(NULL, name, other, null, two, xfrm_msg, o, 0);\n\t\tfree(null);\n\t}\n\telse\n\t\trun_diff_cmd(pgm, name, other, one, two, xfrm_msg, o,\n\t\t\t     complete_rewrite);\n\n\tfree(name_munged);\n\tfree(other_munged);\n}\n\nstatic void run_diffstat(struct diff_filepair *p, struct diff_options *o,\n\t\t\t struct diffstat_t *diffstat)\n{\n\tconst char *name;\n\tconst char *other;\n\tint complete_rewrite = 0;\n\n\tif (DIFF_PAIR_UNMERGED(p)) {\n\t\t/* unmerged */\n\t\tbuiltin_diffstat(p->one->path, NULL, NULL, NULL, diffstat, 0);\n\t\treturn;\n\t}\n\n\tname = p->one->path;\n\tother = (strcmp(name, p->two->path) ? p->two->path : NULL);\n\n\tdiff_fill_sha1_info(p->one);\n\tdiff_fill_sha1_info(p->two);\n\n\tif (p->status == DIFF_STATUS_MODIFIED && p->score)\n\t\tcomplete_rewrite = 1;\n\tbuiltin_diffstat(name, other, p->one, p->two, diffstat, complete_rewrite);\n}\n\nvoid diff_setup(struct diff_options *options)\n{\n\tmemset(options, 0, sizeof(*options));\n\toptions->output_format = DIFF_FORMAT_RAW;\n\toptions->line_termination = '\\n';\n\toptions->break_opt = -1;\n\toptions->rename_limit = -1;\n\n\toptions->change = diff_change;\n\toptions->add_remove = diff_addremove;\n}\n\nint diff_setup_done(struct diff_options *options)\n{\n\tif ((options->find_copies_harder &&\n\t     options->detect_rename != DIFF_DETECT_COPY) ||\n\t    (0 <= options->rename_limit && !options->detect_rename))\n\t\treturn -1;\n\n\t/*\n\t * These cases always need recursive; we do not drop caller-supplied\n\t * recursive bits for other formats here.\n\t */\n\tif ((options->output_format == DIFF_FORMAT_PATCH) ||\n\t    (options->output_format == DIFF_FORMAT_DIFFSTAT))\n\t\toptions->recursive = 1;\n\n\tif (options->detect_rename && options->rename_limit < 0)\n\t\toptions->rename_limit = diff_rename_limit_default;\n\tif (options->setup & DIFF_SETUP_USE_CACHE) {\n\t\tif (!active_cache)\n\t\t\t/* read-cache does not die even when it fails\n\t\t\t * so it is safe for us to do this here.  Also\n\t\t\t * it does not smudge active_cache or active_nr\n\t\t\t * when it fails, so we do not have to worry about\n\t\t\t * cleaning it up ourselves either.\n\t\t\t */\n\t\t\tread_cache();\n\t}\n\tif (options->setup & DIFF_SETUP_USE_SIZE_CACHE)\n\t\tuse_size_cache = 1;\n\tif (options->abbrev <= 0 || 40 < options->abbrev)\n\t\toptions->abbrev = 40; /* full */\n\n\treturn 0;\n}\n\nint diff_opt_parse(struct diff_options *options, const char **av, int ac)\n{\n\tconst char *arg = av[0];\n\tif (!strcmp(arg, \"-p\") || !strcmp(arg, \"-u\"))\n\t\toptions->output_format = DIFF_FORMAT_PATCH;\n\telse if (!strcmp(arg, \"--patch-with-raw\")) {\n\t\toptions->output_format = DIFF_FORMAT_PATCH;\n\t\toptions->with_raw = 1;\n\t}\n\telse if (!strcmp(arg, \"--stat\"))\n\t\toptions->output_format = DIFF_FORMAT_DIFFSTAT;\n\telse if (!strcmp(arg, \"--summary\"))\n\t\toptions->summary = 1;\n\telse if (!strcmp(arg, \"--patch-with-stat\")) {\n\t\toptions->output_format = DIFF_FORMAT_PATCH;\n\t\toptions->with_stat = 1;\n\t}\n\telse if (!strcmp(arg, \"-z\"))\n\t\toptions->line_termination = 0;\n\telse if (!strncmp(arg, \"-l\", 2))\n\t\toptions->rename_limit = strtoul(arg+2, NULL, 10);\n\telse if (!strcmp(arg, \"--full-index\"))\n\t\toptions->full_index = 1;\n\telse if (!strcmp(arg, \"--binary\")) {\n\t\toptions->output_format = DIFF_FORMAT_PATCH;\n\t\toptions->full_index = options->binary = 1;\n\t}\n\telse if (!strcmp(arg, \"--name-only\"))\n\t\toptions->output_format = DIFF_FORMAT_NAME;\n\telse if (!strcmp(arg, \"--name-status\"))\n\t\toptions->output_format = DIFF_FORMAT_NAME_STATUS;\n\telse if (!strcmp(arg, \"-R\"))\n\t\toptions->reverse_diff = 1;\n\telse if (!strncmp(arg, \"-S\", 2))\n\t\toptions->pickaxe = arg + 2;\n\telse if (!strcmp(arg, \"-s\"))\n\t\toptions->output_format = DIFF_FORMAT_NO_OUTPUT;\n\telse if (!strncmp(arg, \"-O\", 2))\n\t\toptions->orderfile = arg + 2;\n\telse if (!strncmp(arg, \"--diff-filter=\", 14))\n\t\toptions->filter = arg + 14;\n\telse if (!strcmp(arg, \"--pickaxe-all\"))\n\t\toptions->pickaxe_opts = DIFF_PICKAXE_ALL;\n\telse if (!strcmp(arg, \"--pickaxe-regex\"))\n\t\toptions->pickaxe_opts = DIFF_PICKAXE_REGEX;\n\telse if (!strncmp(arg, \"-B\", 2)) {\n\t\tif ((options->break_opt =\n\t\t     diff_scoreopt_parse(arg)) == -1)\n\t\t\treturn -1;\n\t}\n\telse if (!strncmp(arg, \"-M\", 2)) {\n\t\tif ((options->rename_score =\n\t\t     diff_scoreopt_parse(arg)) == -1)\n\t\t\treturn -1;\n\t\toptions->detect_rename = DIFF_DETECT_RENAME;\n\t}\n\telse if (!strncmp(arg, \"-C\", 2)) {\n\t\tif ((options->rename_score =\n\t\t     diff_scoreopt_parse(arg)) == -1)\n\t\t\treturn -1;\n\t\toptions->detect_rename = DIFF_DETECT_COPY;\n\t}\n\telse if (!strcmp(arg, \"--find-copies-harder\"))\n\t\toptions->find_copies_harder = 1;\n\telse if (!strcmp(arg, \"--abbrev\"))\n\t\toptions->abbrev = DEFAULT_ABBREV;\n\telse if (!strncmp(arg, \"--abbrev=\", 9)) {\n\t\toptions->abbrev = strtoul(arg + 9, NULL, 10);\n\t\tif (options->abbrev < MINIMUM_ABBREV)\n\t\t\toptions->abbrev = MINIMUM_ABBREV;\n\t\telse if (40 < options->abbrev)\n\t\t\toptions->abbrev = 40;\n\t}\n\telse\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int parse_num(const char **cp_p)\n{\n\tunsigned long num, scale;\n\tint ch, dot;\n\tconst char *cp = *cp_p;\n\n\tnum = 0;\n\tscale = 1;\n\tdot = 0;\n\tfor(;;) {\n\t\tch = *cp;\n\t\tif ( !dot && ch == '.' ) {\n\t\t\tscale = 1;\n\t\t\tdot = 1;\n\t\t} else if ( ch == '%' ) {\n\t\t\tscale = dot ? scale*100 : 100;\n\t\t\tcp++;\t/* % is always at the end */\n\t\t\tbreak;\n\t\t} else if ( ch >= '0' && ch <= '9' ) {\n\t\t\tif ( scale < 100000 ) {\n\t\t\t\tscale *= 10;\n\t\t\t\tnum = (num*10) + (ch-'0');\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tcp++;\n\t}\n\t*cp_p = cp;\n\n\t/* user says num divided by scale and we say internally that\n\t * is MAX_SCORE * num / scale.\n\t */\n\treturn (num >= scale) ? MAX_SCORE : (MAX_SCORE * num / scale);\n}\n\nint diff_scoreopt_parse(const char *opt)\n{\n\tint opt1, opt2, cmd;\n\n\tif (*opt++ != '-')\n\t\treturn -1;\n\tcmd = *opt++;\n\tif (cmd != 'M' && cmd != 'C' && cmd != 'B')\n\t\treturn -1; /* that is not a -M, -C nor -B option */\n\n\topt1 = parse_num(&opt);\n\tif (cmd != 'B')\n\t\topt2 = 0;\n\telse {\n\t\tif (*opt == 0)\n\t\t\topt2 = 0;\n\t\telse if (*opt != '/')\n\t\t\treturn -1; /* we expect -B80/99 or -B80 */\n\t\telse {\n\t\t\topt++;\n\t\t\topt2 = parse_num(&opt);\n\t\t}\n\t}\n\tif (*opt != 0)\n\t\treturn -1;\n\treturn opt1 | (opt2 << 16);\n}\n\nstruct diff_queue_struct diff_queued_diff;\n\nvoid diff_q(struct diff_queue_struct *queue, struct diff_filepair *dp)\n{\n\tif (queue->alloc <= queue->nr) {\n\t\tqueue->alloc = alloc_nr(queue->alloc);\n\t\tqueue->queue = xrealloc(queue->queue,\n\t\t\t\t\tsizeof(dp) * queue->alloc);\n\t}\n\tqueue->queue[queue->nr++] = dp;\n}\n\nstruct diff_filepair *diff_queue(struct diff_queue_struct *queue,\n\t\t\t\t struct diff_filespec *one,\n\t\t\t\t struct diff_filespec *two)\n{\n\tstruct diff_filepair *dp = xmalloc(sizeof(*dp));\n\tdp->one = one;\n\tdp->two = two;\n\tdp->score = 0;\n\tdp->status = 0;\n\tdp->source_stays = 0;\n\tdp->broken_pair = 0;\n\tif (queue)\n\t\tdiff_q(queue, dp);\n\treturn dp;\n}\n\nvoid diff_free_filepair(struct diff_filepair *p)\n{\n\tdiff_free_filespec_data(p->one);\n\tdiff_free_filespec_data(p->two);\n\tfree(p->one);\n\tfree(p->two);\n\tfree(p);\n}\n\n/* This is different from find_unique_abbrev() in that\n * it stuffs the result with dots for alignment.\n */\nconst char *diff_unique_abbrev(const unsigned char *sha1, int len)\n{\n\tint abblen;\n\tconst char *abbrev;\n\tif (len == 40)\n\t\treturn sha1_to_hex(sha1);\n\n\tabbrev = find_unique_abbrev(sha1, len);\n\tif (!abbrev)\n\t\treturn sha1_to_hex(sha1);\n\tabblen = strlen(abbrev);\n\tif (abblen < 37) {\n\t\tstatic char hex[41];\n\t\tif (len < abblen && abblen <= len + 2)\n\t\t\tsprintf(hex, \"%s%.*s\", abbrev, len+3-abblen, \"..\");\n\t\telse\n\t\t\tsprintf(hex, \"%s...\", abbrev);\n\t\treturn hex;\n\t}\n\treturn sha1_to_hex(sha1);\n}\n\nstatic void diff_flush_raw(struct diff_filepair *p,\n\t\t\t   int line_termination,\n\t\t\t   int inter_name_termination,\n\t\t\t   struct diff_options *options,\n\t\t\t   int output_format)\n{\n\tint two_paths;\n\tchar status[10];\n\tint abbrev = options->abbrev;\n\tconst char *path_one, *path_two;\n\n\tpath_one = p->one->path;\n\tpath_two = p->two->path;\n\tif (line_termination) {\n\t\tpath_one = quote_one(path_one);\n\t\tpath_two = quote_one(path_two);\n\t}\n\n\tif (p->score)\n\t\tsprintf(status, \"%c%03d\", p->status,\n\t\t\t(int)(0.5 + p->score * 100.0/MAX_SCORE));\n\telse {\n\t\tstatus[0] = p->status;\n\t\tstatus[1] = 0;\n\t}\n\tswitch (p->status) {\n\tcase DIFF_STATUS_COPIED:\n\tcase DIFF_STATUS_RENAMED:\n\t\ttwo_paths = 1;\n\t\tbreak;\n\tcase DIFF_STATUS_ADDED:\n\tcase DIFF_STATUS_DELETED:\n\t\ttwo_paths = 0;\n\t\tbreak;\n\tdefault:\n\t\ttwo_paths = 0;\n\t\tbreak;\n\t}\n\tif (output_format != DIFF_FORMAT_NAME_STATUS) {\n\t\tprintf(\":%06o %06o %s \",\n\t\t       p->one->mode, p->two->mode,\n\t\t       diff_unique_abbrev(p->one->sha1, abbrev));\n\t\tprintf(\"%s \",\n\t\t       diff_unique_abbrev(p->two->sha1, abbrev));\n\t}\n\tprintf(\"%s%c%s\", status, inter_name_termination, path_one);\n\tif (two_paths)\n\t\tprintf(\"%c%s\", inter_name_termination, path_two);\n\tputchar(line_termination);\n\tif (path_one != p->one->path)\n\t\tfree((void*)path_one);\n\tif (path_two != p->two->path)\n\t\tfree((void*)path_two);\n}\n\nstatic void diff_flush_name(struct diff_filepair *p,\n\t\t\t    int inter_name_termination,\n\t\t\t    int line_termination)\n{\n\tchar *path = p->two->path;\n\n\tif (line_termination)\n\t\tpath = quote_one(p->two->path);\n\telse\n\t\tpath = p->two->path;\n\tprintf(\"%s%c\", path, line_termination);\n\tif (p->two->path != path)\n\t\tfree(path);\n}\n\nint diff_unmodified_pair(struct diff_filepair *p)\n{\n\t/* This function is written stricter than necessary to support\n\t * the currently implemented transformers, but the idea is to\n\t * let transformers to produce diff_filepairs any way they want,\n\t * and filter and clean them up here before producing the output.\n\t */\n\tstruct diff_filespec *one, *two;\n\n\tif (DIFF_PAIR_UNMERGED(p))\n\t\treturn 0; /* unmerged is interesting */\n\n\tone = p->one;\n\ttwo = p->two;\n\n\t/* deletion, addition, mode or type change\n\t * and rename are all interesting.\n\t */\n\tif (DIFF_FILE_VALID(one) != DIFF_FILE_VALID(two) ||\n\t    DIFF_PAIR_MODE_CHANGED(p) ||\n\t    strcmp(one->path, two->path))\n\t\treturn 0;\n\n\t/* both are valid and point at the same path.  that is, we are\n\t * dealing with a change.\n\t */\n\tif (one->sha1_valid && two->sha1_valid &&\n\t    !memcmp(one->sha1, two->sha1, sizeof(one->sha1)))\n\t\treturn 1; /* no change */\n\tif (!one->sha1_valid && !two->sha1_valid)\n\t\treturn 1; /* both look at the same file on the filesystem. */\n\treturn 0;\n}\n\nstatic void diff_flush_patch(struct diff_filepair *p, struct diff_options *o)\n{\n\tif (diff_unmodified_pair(p))\n\t\treturn;\n\n\tif ((DIFF_FILE_VALID(p->one) && S_ISDIR(p->one->mode)) ||\n\t    (DIFF_FILE_VALID(p->two) && S_ISDIR(p->two->mode)))\n\t\treturn; /* no tree diffs in patch format */\n\n\trun_diff(p, o);\n}\n\nstatic void diff_flush_stat(struct diff_filepair *p, struct diff_options *o,\n\t\t\t    struct diffstat_t *diffstat)\n{\n\tif (diff_unmodified_pair(p))\n\t\treturn;\n\n\tif ((DIFF_FILE_VALID(p->one) && S_ISDIR(p->one->mode)) ||\n\t    (DIFF_FILE_VALID(p->two) && S_ISDIR(p->two->mode)))\n\t\treturn; /* no tree diffs in patch format */\n\n\trun_diffstat(p, o, diffstat);\n}\n\nint diff_queue_is_empty(void)\n{\n\tstruct diff_queue_struct *q = &diff_queued_diff;\n\tint i;\n\tfor (i = 0; i < q->nr; i++)\n\t\tif (!diff_unmodified_pair(q->queue[i]))\n\t\t\treturn 0;\n\treturn 1;\n}\n\n#if DIFF_DEBUG\nvoid diff_debug_filespec(struct diff_filespec *s, int x, const char *one)\n{\n\tfprintf(stderr, \"queue[%d] %s (%s) %s %06o %s\\n\",\n\t\tx, one ? one : \"\",\n\t\ts->path,\n\t\tDIFF_FILE_VALID(s) ? \"valid\" : \"invalid\",\n\t\ts->mode,\n\t\ts->sha1_valid ? sha1_to_hex(s->sha1) : \"\");\n\tfprintf(stderr, \"queue[%d] %s size %lu flags %d\\n\",\n\t\tx, one ? one : \"\",\n\t\ts->size, s->xfrm_flags);\n}\n\nvoid diff_debug_filepair(const struct diff_filepair *p, int i)\n{\n\tdiff_debug_filespec(p->one, i, \"one\");\n\tdiff_debug_filespec(p->two, i, \"two\");\n\tfprintf(stderr, \"score %d, status %c stays %d broken %d\\n\",\n\t\tp->score, p->status ? p->status : '?',\n\t\tp->source_stays, p->broken_pair);\n}\n\nvoid diff_debug_queue(const char *msg, struct diff_queue_struct *q)\n{\n\tint i;\n\tif (msg)\n\t\tfprintf(stderr, \"%s\\n\", msg);\n\tfprintf(stderr, \"q->nr = %d\\n\", q->nr);\n\tfor (i = 0; i < q->nr; i++) {\n\t\tstruct diff_filepair *p = q->queue[i];\n\t\tdiff_debug_filepair(p, i);\n\t}\n}\n#endif\n\nstatic void diff_resolve_rename_copy(void)\n{\n\tint i, j;\n\tstruct diff_filepair *p, *pp;\n\tstruct diff_queue_struct *q = &diff_queued_diff;\n\n\tdiff_debug_queue(\"resolve-rename-copy\", q);\n\n\tfor (i = 0; i < q->nr; i++) {\n\t\tp = q->queue[i];\n\t\tp->status = 0; /* undecided */\n\t\tif (DIFF_PAIR_UNMERGED(p))\n\t\t\tp->status = DIFF_STATUS_UNMERGED;\n\t\telse if (!DIFF_FILE_VALID(p->one))\n\t\t\tp->status = DIFF_STATUS_ADDED;\n\t\telse if (!DIFF_FILE_VALID(p->two))\n\t\t\tp->status = DIFF_STATUS_DELETED;\n\t\telse if (DIFF_PAIR_TYPE_CHANGED(p))\n\t\t\tp->status = DIFF_STATUS_TYPE_CHANGED;\n\n\t\t/* from this point on, we are dealing with a pair\n\t\t * whose both sides are valid and of the same type, i.e.\n\t\t * either in-place edit or rename/copy edit.\n\t\t */\n\t\telse if (DIFF_PAIR_RENAME(p)) {\n\t\t\tif (p->source_stays) {\n\t\t\t\tp->status = DIFF_STATUS_COPIED;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* See if there is some other filepair that\n\t\t\t * copies from the same source as us.  If so\n\t\t\t * we are a copy.  Otherwise we are either a\n\t\t\t * copy if the path stays, or a rename if it\n\t\t\t * does not, but we already handled \"stays\" case.\n\t\t\t */\n\t\t\tfor (j = i + 1; j < q->nr; j++) {\n\t\t\t\tpp = q->queue[j];\n\t\t\t\tif (strcmp(pp->one->path, p->one->path))\n\t\t\t\t\tcontinue; /* not us */\n\t\t\t\tif (!DIFF_PAIR_RENAME(pp))\n\t\t\t\t\tcontinue; /* not a rename/copy */\n\t\t\t\t/* pp is a rename/copy from the same source */\n\t\t\t\tp->status = DIFF_STATUS_COPIED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!p->status)\n\t\t\t\tp->status = DIFF_STATUS_RENAMED;\n\t\t}\n\t\telse if (memcmp(p->one->sha1, p->two->sha1, 20) ||\n\t\t\t p->one->mode != p->two->mode)\n\t\t\tp->status = DIFF_STATUS_MODIFIED;\n\t\telse {\n\t\t\t/* This is a \"no-change\" entry and should not\n\t\t\t * happen anymore, but prepare for broken callers.\n\t\t\t */\n\t\t\terror(\"feeding unmodified %s to diffcore\",\n\t\t\t      p->one->path);\n\t\t\tp->status = DIFF_STATUS_UNKNOWN;\n\t\t}\n\t}\n\tdiff_debug_queue(\"resolve-rename-copy done\", q);\n}\n\nstatic void flush_one_pair(struct diff_filepair *p,\n\t\t\t   int diff_output_format,\n\t\t\t   struct diff_options *options,\n\t\t\t   struct diffstat_t *diffstat)\n{\n\tint inter_name_termination = '\\t';\n\tint line_termination = options->line_termination;\n\tif (!line_termination)\n\t\tinter_name_termination = 0;\n\n\tswitch (p->status) {\n\tcase DIFF_STATUS_UNKNOWN:\n\t\tbreak;\n\tcase 0:\n\t\tdie(\"internal error in diff-resolve-rename-copy\");\n\t\tbreak;\n\tdefault:\n\t\tswitch (diff_output_format) {\n\t\tcase DIFF_FORMAT_DIFFSTAT:\n\t\t\tdiff_flush_stat(p, options, diffstat);\n\t\t\tbreak;\n\t\tcase DIFF_FORMAT_PATCH:\n\t\t\tdiff_flush_patch(p, options);\n\t\t\tbreak;\n\t\tcase DIFF_FORMAT_RAW:\n\t\tcase DIFF_FORMAT_NAME_STATUS:\n\t\t\tdiff_flush_raw(p, line_termination,\n\t\t\t\t       inter_name_termination,\n\t\t\t\t       options, diff_output_format);\n\t\t\tbreak;\n\t\tcase DIFF_FORMAT_NAME:\n\t\t\tdiff_flush_name(p,\n\t\t\t\t\tinter_name_termination,\n\t\t\t\t\tline_termination);\n\t\t\tbreak;\n\t\tcase DIFF_FORMAT_NO_OUTPUT:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void show_file_mode_name(const char *newdelete, struct diff_filespec *fs)\n{\n\tif (fs->mode)\n\t\tprintf(\" %s mode %06o %s\\n\", newdelete, fs->mode, fs->path);\n\telse\n\t\tprintf(\" %s %s\\n\", newdelete, fs->path);\n}\n\n\nstatic void show_mode_change(struct diff_filepair *p, int show_name)\n{\n\tif (p->one->mode && p->two->mode && p->one->mode != p->two->mode) {\n\t\tif (show_name)\n\t\t\tprintf(\" mode change %06o => %06o %s\\n\",\n\t\t\t       p->one->mode, p->two->mode, p->two->path);\n\t\telse\n\t\t\tprintf(\" mode change %06o => %06o\\n\",\n\t\t\t       p->one->mode, p->two->mode);\n\t}\n}\n\nstatic void show_rename_copy(const char *renamecopy, struct diff_filepair *p)\n{\n\tconst char *old, *new;\n\n\t/* Find common prefix */\n\told = p->one->path;\n\tnew = p->two->path;\n\twhile (1) {\n\t\tconst char *slash_old, *slash_new;\n\t\tslash_old = strchr(old, '/');\n\t\tslash_new = strchr(new, '/');\n\t\tif (!slash_old ||\n\t\t    !slash_new ||\n\t\t    slash_old - old != slash_new - new ||\n\t\t    memcmp(old, new, slash_new - new))\n\t\t\tbreak;\n\t\told = slash_old + 1;\n\t\tnew = slash_new + 1;\n\t}\n\t/* p->one->path thru old is the common prefix, and old and new\n\t * through the end of names are renames\n\t */\n\tif (old != p->one->path)\n\t\tprintf(\" %s %.*s{%s => %s} (%d%%)\\n\", renamecopy,\n\t\t       (int)(old - p->one->path), p->one->path,\n\t\t       old, new, (int)(0.5 + p->score * 100.0/MAX_SCORE));\n\telse\n\t\tprintf(\" %s %s => %s (%d%%)\\n\", renamecopy,\n\t\t       p->one->path, p->two->path,\n\t\t       (int)(0.5 + p->score * 100.0/MAX_SCORE));\n\tshow_mode_change(p, 0);\n}\n\nstatic void diff_summary(struct diff_filepair *p)\n{\n\tswitch(p->status) {\n\tcase DIFF_STATUS_DELETED:\n\t\tshow_file_mode_name(\"delete\", p->one);\n\t\tbreak;\n\tcase DIFF_STATUS_ADDED:\n\t\tshow_file_mode_name(\"create\", p->two);\n\t\tbreak;\n\tcase DIFF_STATUS_COPIED:\n\t\tshow_rename_copy(\"copy\", p);\n\t\tbreak;\n\tcase DIFF_STATUS_RENAMED:\n\t\tshow_rename_copy(\"rename\", p);\n\t\tbreak;\n\tdefault:\n\t\tif (p->score) {\n\t\t\tprintf(\" rewrite %s (%d%%)\\n\", p->two->path,\n\t\t\t\t(int)(0.5 + p->score * 100.0/MAX_SCORE));\n\t\t\tshow_mode_change(p, 0);\n\t\t} else\tshow_mode_change(p, 1);\n\t\tbreak;\n\t}\n}\n\nvoid diff_flush(struct diff_options *options)\n{\n\tstruct diff_queue_struct *q = &diff_queued_diff;\n\tint i;\n\tint diff_output_format = options->output_format;\n\tstruct diffstat_t *diffstat = NULL;\n\n\tif (diff_output_format == DIFF_FORMAT_DIFFSTAT || options->with_stat) {\n\t\tdiffstat = xcalloc(sizeof (struct diffstat_t), 1);\n\t\tdiffstat->xm.consume = diffstat_consume;\n\t}\n\n\tif (options->with_raw) {\n\t\tfor (i = 0; i < q->nr; i++) {\n\t\t\tstruct diff_filepair *p = q->queue[i];\n\t\t\tflush_one_pair(p, DIFF_FORMAT_RAW, options, NULL);\n\t\t}\n\t\tputchar(options->line_termination);\n\t}\n\tif (options->with_stat) {\n\t\tfor (i = 0; i < q->nr; i++) {\n\t\t\tstruct diff_filepair *p = q->queue[i];\n\t\t\tflush_one_pair(p, DIFF_FORMAT_DIFFSTAT, options,\n\t\t\t\t       diffstat);\n\t\t}\n\t\tshow_stats(diffstat);\n\t\tfree(diffstat);\n\t\tdiffstat = NULL;\n\t\tputchar(options->line_termination);\n\t}\n\tfor (i = 0; i < q->nr; i++) {\n\t\tstruct diff_filepair *p = q->queue[i];\n\t\tflush_one_pair(p, diff_output_format, options, diffstat);\n\t}\n\n\tif (diffstat) {\n\t\tshow_stats(diffstat);\n\t\tfree(diffstat);\n\t}\n\n\tfor (i = 0; i < q->nr; i++) {\n\t\tif (options->summary)\n\t\t\tdiff_summary(q->queue[i]);\n\t\tdiff_free_filepair(q->queue[i]);\n\t}\n\n\tfree(q->queue);\n\tq->queue = NULL;\n\tq->nr = q->alloc = 0;\n}\n\nstatic void diffcore_apply_filter(const char *filter)\n{\n\tint i;\n\tstruct diff_queue_struct *q = &diff_queued_diff;\n\tstruct diff_queue_struct outq;\n\toutq.queue = NULL;\n\toutq.nr = outq.alloc = 0;\n\n\tif (!filter)\n\t\treturn;\n\n\tif (strchr(filter, DIFF_STATUS_FILTER_AON)) {\n\t\tint found;\n\t\tfor (i = found = 0; !found && i < q->nr; i++) {\n\t\t\tstruct diff_filepair *p = q->queue[i];\n\t\t\tif (((p->status == DIFF_STATUS_MODIFIED) &&\n\t\t\t     ((p->score &&\n\t\t\t       strchr(filter, DIFF_STATUS_FILTER_BROKEN)) ||\n\t\t\t      (!p->score &&\n\t\t\t       strchr(filter, DIFF_STATUS_MODIFIED)))) ||\n\t\t\t    ((p->status != DIFF_STATUS_MODIFIED) &&\n\t\t\t     strchr(filter, p->status)))\n\t\t\t\tfound++;\n\t\t}\n\t\tif (found)\n\t\t\treturn;\n\n\t\t/* otherwise we will clear the whole queue\n\t\t * by copying the empty outq at the end of this\n\t\t * function, but first clear the current entries\n\t\t * in the queue.\n\t\t */\n\t\tfor (i = 0; i < q->nr; i++)\n\t\t\tdiff_free_filepair(q->queue[i]);\n\t}\n\telse {\n\t\t/* Only the matching ones */\n\t\tfor (i = 0; i < q->nr; i++) {\n\t\t\tstruct diff_filepair *p = q->queue[i];\n\n\t\t\tif (((p->status == DIFF_STATUS_MODIFIED) &&\n\t\t\t     ((p->score &&\n\t\t\t       strchr(filter, DIFF_STATUS_FILTER_BROKEN)) ||\n\t\t\t      (!p->score &&\n\t\t\t       strchr(filter, DIFF_STATUS_MODIFIED)))) ||\n\t\t\t    ((p->status != DIFF_STATUS_MODIFIED) &&\n\t\t\t     strchr(filter, p->status)))\n\t\t\t\tdiff_q(&outq, p);\n\t\t\telse\n\t\t\t\tdiff_free_filepair(p);\n\t\t}\n\t}\n\tfree(q->queue);\n\t*q = outq;\n}\n\nvoid diffcore_std(struct diff_options *options)\n{\n\tif (options->break_opt != -1)\n\t\tdiffcore_break(options->break_opt);\n\tif (options->detect_rename)\n\t\tdiffcore_rename(options);\n\tif (options->break_opt != -1)\n\t\tdiffcore_merge_broken();\n\tif (options->pickaxe)\n\t\tdiffcore_pickaxe(options->pickaxe, options->pickaxe_opts);\n\tif (options->orderfile)\n\t\tdiffcore_order(options->orderfile);\n\tdiff_resolve_rename_copy();\n\tdiffcore_apply_filter(options->filter);\n}\n\n\nvoid diffcore_std_no_resolve(struct diff_options *options)\n{\n\tif (options->pickaxe)\n\t\tdiffcore_pickaxe(options->pickaxe, options->pickaxe_opts);\n\tif (options->orderfile)\n\t\tdiffcore_order(options->orderfile);\n\tdiffcore_apply_filter(options->filter);\n}\n\nvoid diff_addremove(struct diff_options *options,\n\t\t    int addremove, unsigned mode,\n\t\t    const unsigned char *sha1,\n\t\t    const char *base, const char *path)\n{\n\tchar concatpath[PATH_MAX];\n\tstruct diff_filespec *one, *two;\n\n\t/* This may look odd, but it is a preparation for\n\t * feeding \"there are unchanged files which should\n\t * not produce diffs, but when you are doing copy\n\t * detection you would need them, so here they are\"\n\t * entries to the diff-core.  They will be prefixed\n\t * with something like '=' or '*' (I haven't decided\n\t * which but should not make any difference).\n\t * Feeding the same new and old to diff_change() \n\t * also has the same effect.\n\t * Before the final output happens, they are pruned after\n\t * merged into rename/copy pairs as appropriate.\n\t */\n\tif (options->reverse_diff)\n\t\taddremove = (addremove == '+' ? '-' :\n\t\t\t     addremove == '-' ? '+' : addremove);\n\n\tif (!path) path = \"\";\n\tsprintf(concatpath, \"%s%s\", base, path);\n\tone = alloc_filespec(concatpath);\n\ttwo = alloc_filespec(concatpath);\n\n\tif (addremove != '+')\n\t\tfill_filespec(one, sha1, mode);\n\tif (addremove != '-')\n\t\tfill_filespec(two, sha1, mode);\n\n\tdiff_queue(&diff_queued_diff, one, two);\n}\n\nvoid diff_change(struct diff_options *options,\n\t\t unsigned old_mode, unsigned new_mode,\n\t\t const unsigned char *old_sha1,\n\t\t const unsigned char *new_sha1,\n\t\t const char *base, const char *path) \n{\n\tchar concatpath[PATH_MAX];\n\tstruct diff_filespec *one, *two;\n\n\tif (options->reverse_diff) {\n\t\tunsigned tmp;\n\t\tconst unsigned char *tmp_c;\n\t\ttmp = old_mode; old_mode = new_mode; new_mode = tmp;\n\t\ttmp_c = old_sha1; old_sha1 = new_sha1; new_sha1 = tmp_c;\n\t}\n\tif (!path) path = \"\";\n\tsprintf(concatpath, \"%s%s\", base, path);\n\tone = alloc_filespec(concatpath);\n\ttwo = alloc_filespec(concatpath);\n\tfill_filespec(one, old_sha1, old_mode);\n\tfill_filespec(two, new_sha1, new_mode);\n\n\tdiff_queue(&diff_queued_diff, one, two);\n}\n\nvoid diff_unmerge(struct diff_options *options,\n\t\t  const char *path)\n{\n\tstruct diff_filespec *one, *two;\n\tone = alloc_filespec(path);\n\ttwo = alloc_filespec(path);\n\tdiff_queue(&diff_queued_diff, one, two);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00b1044d3adf7d9e0def6c12888a6abff8a3cd0d",
  "sha1_ok": true,
  "size": 48888
}
