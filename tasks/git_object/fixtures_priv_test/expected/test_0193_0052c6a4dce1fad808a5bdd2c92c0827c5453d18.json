{
  "content": {
    "base64": "I2RlZmluZSBVU0VfVEhFX1JFUE9TSVRPUllfVkFSSUFCTEUKCiNpbmNsdWRlICJnaXQtY29tcGF0LXV0aWwuaCIKI2luY2x1ZGUgImNvbmZpZy5oIgojaW5jbHVkZSAiZW52aXJvbm1lbnQuaCIKI2luY2x1ZGUgImdldHRleHQuaCIKI2luY2x1ZGUgImhleC5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAicGt0LWxpbmUuaCIKI2luY2x1ZGUgInNpZGViYW5kLmgiCiNpbmNsdWRlICJyZXBvc2l0b3J5LmgiCiNpbmNsdWRlICJvYmplY3Qtc3RvcmUtbGwuaCIKI2luY2x1ZGUgIm9pZC1hcnJheS5oIgojaW5jbHVkZSAib2JqZWN0LmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgInJldmlzaW9uLmgiCiNpbmNsdWRlICJsaXN0LW9iamVjdHMtZmlsdGVyLW9wdGlvbnMuaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJjb25uZWN0LmgiCiNpbmNsdWRlICJzaWdjaGFpbi5oIgojaW5jbHVkZSAidmVyc2lvbi5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgInN0cnZlYy5oIgojaW5jbHVkZSAidHJhY2UyLmgiCiNpbmNsdWRlICJwcm90b2NvbC5oIgojaW5jbHVkZSAidXBsb2FkLXBhY2suaCIKI2luY2x1ZGUgImNvbW1pdC1ncmFwaC5oIgojaW5jbHVkZSAiY29tbWl0LXJlYWNoLmgiCiNpbmNsdWRlICJzaGFsbG93LmgiCiNpbmNsdWRlICJ3cml0ZS1vci1kaWUuaCIKI2luY2x1ZGUgImpzb24td3JpdGVyLmgiCiNpbmNsdWRlICJzdHJtYXAuaCIKCi8qIFJlbWVtYmVyIHRvIHVwZGF0ZSBvYmplY3QgZmxhZyBhbGxvY2F0aW9uIGluIG9iamVjdC5oICovCiNkZWZpbmUgVEhFWV9IQVZFCSgxdSA8PCAxMSkKI2RlZmluZSBPVVJfUkVGCQkoMXUgPDwgMTIpCiNkZWZpbmUgV0FOVEVECQkoMXUgPDwgMTMpCiNkZWZpbmUgQ09NTU9OX0tOT1dOCSgxdSA8PCAxNCkKCiNkZWZpbmUgU0hBTExPVwkJKDF1IDw8IDE2KQojZGVmaW5lIE5PVF9TSEFMTE9XCSgxdSA8PCAxNykKI2RlZmluZSBDTElFTlRfU0hBTExPVwkoMXUgPDwgMTgpCiNkZWZpbmUgSElEREVOX1JFRgkoMXUgPDwgMTkpCgojZGVmaW5lIEFMTF9GTEFHUyAoVEhFWV9IQVZFIHwgT1VSX1JFRiB8IFdBTlRFRCB8IENPTU1PTl9LTk9XTiB8IFNIQUxMT1cgfCBcCgkJTk9UX1NIQUxMT1cgfCBDTElFTlRfU0hBTExPVyB8IEhJRERFTl9SRUYpCgovKiBFbnVtIGZvciBhbGxvd2VkIHVuYWR2ZXJ0aXNlZCBvYmplY3QgcmVxdWVzdCAoVU9SKSAqLwplbnVtIGFsbG93X3VvciB7CgkvKiBBbGxvdyBzcGVjaWZ5aW5nIHNoYTEgaWYgaXQgaXMgYSByZWYgdGlwLiAqLwoJQUxMT1dfVElQX1NIQTEgPSAweDAxLAoJLyogQWxsb3cgcmVxdWVzdCBvZiBhIHNoYTEgaWYgaXQgaXMgcmVhY2hhYmxlIGZyb20gYSByZWYgKHBvc3NpYmx5IGhpZGRlbiByZWYpLiAqLwoJQUxMT1dfUkVBQ0hBQkxFX1NIQTEgPSAweDAyLAoJLyogQWxsb3cgcmVxdWVzdCBvZiBhbnkgc2hhMS4gSW1wbGllcyBBTExPV19USVBfU0hBMSBhbmQgQUxMT1dfUkVBQ0hBQkxFX1NIQTEuICovCglBTExPV19BTllfU0hBMSA9IDB4MDcKfTsKCi8qCiAqIFBsZWFzZSBhbm5vdGF0ZSwgYW5kIGlmIHBvc3NpYmxlIGdyb3VwIHRvZ2V0aGVyLCBmaWVsZHMgdXNlZCBvbmx5CiAqIGZvciBwcm90b2NvbCB2MCBvciBvbmx5IGZvciBwcm90b2NvbCB2Mi4KICovCnN0cnVjdCB1cGxvYWRfcGFja19kYXRhIHsKCXN0cnVjdCBzdHJpbmdfbGlzdCBzeW1yZWY7CQkJCS8qIHYwIG9ubHkgKi8KCXN0cnVjdCBvYmplY3RfYXJyYXkgd2FudF9vYmo7CglzdHJ1Y3Qgb2JqZWN0X2FycmF5IGhhdmVfb2JqOwoJc3RydWN0IHN0cm1hcCB3YW50ZWRfcmVmczsJCQkJLyogdjIgb25seSAqLwoJc3RydWN0IHN0cnZlYyBoaWRkZW5fcmVmczsKCglzdHJ1Y3Qgb2JqZWN0X2FycmF5IHNoYWxsb3dzOwoJc3RydWN0IG9pZHNldCBkZWVwZW5fbm90OwoJc3RydWN0IG9iamVjdF9hcnJheSBleHRyYV9lZGdlX29iajsKCWludCBkZXB0aDsKCXRpbWVzdGFtcF90IGRlZXBlbl9zaW5jZTsKCWludCBkZWVwZW5fcmV2X2xpc3Q7CglpbnQgZGVlcGVuX3JlbGF0aXZlOwoJaW50IGtlZXBhbGl2ZTsKCWludCBzaGFsbG93X25yOwoJdGltZXN0YW1wX3Qgb2xkZXN0X2hhdmU7CgoJdW5zaWduZWQgaW50IHRpbWVvdXQ7CQkJCQkvKiB2MCBvbmx5ICovCgllbnVtIHsKCQlOT19NVUxUSV9BQ0sgPSAwLAoJCU1VTFRJX0FDSyA9IDEsCgkJTVVMVElfQUNLX0RFVEFJTEVEID0gMgoJfSBtdWx0aV9hY2s7CQkJCQkJLyogdjAgb25seSAqLwoKCS8qIDAgZm9yIG5vIHNpZGViYW5kLCBvdGhlcndpc2UgREVGQVVMVF9QQUNLRVRfTUFYIG9yIExBUkdFX1BBQ0tFVF9NQVggKi8KCWludCB1c2Vfc2lkZWJhbmQ7CgoJc3RydWN0IHN0cmluZ19saXN0IHVyaV9wcm90b2NvbHM7CgllbnVtIGFsbG93X3VvciBhbGxvd191b3I7CgoJc3RydWN0IGxpc3Rfb2JqZWN0c19maWx0ZXJfb3B0aW9ucyBmaWx0ZXJfb3B0aW9uczsKCXN0cnVjdCBzdHJpbmdfbGlzdCBhbGxvd2VkX2ZpbHRlcnM7CgoJc3RydWN0IHBhY2tldF93cml0ZXIgd3JpdGVyOwoKCWNoYXIgKnBhY2tfb2JqZWN0c19ob29rOwoKCXVuc2lnbmVkIHN0YXRlbGVzc19ycGMgOiAxOwkJCQkvKiB2MCBvbmx5ICovCgl1bnNpZ25lZCBub19kb25lIDogMTsJCQkJCS8qIHYwIG9ubHkgKi8KCXVuc2lnbmVkIGRhZW1vbl9tb2RlIDogMTsJCQkJLyogdjAgb25seSAqLwoJdW5zaWduZWQgZmlsdGVyX2NhcGFiaWxpdHlfcmVxdWVzdGVkIDogMTsJCS8qIHYwIG9ubHkgKi8KCgl1bnNpZ25lZCB1c2VfdGhpbl9wYWNrIDogMTsKCXVuc2lnbmVkIHVzZV9vZnNfZGVsdGEgOiAxOwoJdW5zaWduZWQgbm9fcHJvZ3Jlc3MgOiAxOwoJdW5zaWduZWQgdXNlX2luY2x1ZGVfdGFnIDogMTsKCXVuc2lnbmVkIHdhaXRfZm9yX2RvbmUgOiAxOwoJdW5zaWduZWQgYWxsb3dfZmlsdGVyIDogMTsKCXVuc2lnbmVkIGFsbG93X2ZpbHRlcl9mYWxsYmFjayA6IDE7Cgl1bnNpZ25lZCBsb25nIHRyZWVfZmlsdGVyX21heF9kZXB0aDsKCgl1bnNpZ25lZCBkb25lIDogMTsJCQkJCS8qIHYyIG9ubHkgKi8KCXVuc2lnbmVkIGFsbG93X3JlZl9pbl93YW50IDogMTsJCQkJLyogdjIgb25seSAqLwoJdW5zaWduZWQgYWxsb3dfc2lkZWJhbmRfYWxsIDogMTsJCQkvKiB2MiBvbmx5ICovCgl1bnNpZ25lZCBzZWVuX2hhdmVzIDogMTsJCQkJLyogdjIgb25seSAqLwoJdW5zaWduZWQgYWxsb3dfcGFja2ZpbGVfdXJpcyA6IDE7CQkJLyogdjIgb25seSAqLwoJdW5zaWduZWQgYWR2ZXJ0aXNlX3NpZCA6IDE7Cgl1bnNpZ25lZCBzZW50X2NhcGFiaWxpdGllcyA6IDE7Cn07CgpzdGF0aWMgdm9pZCB1cGxvYWRfcGFja19kYXRhX2luaXQoc3RydWN0IHVwbG9hZF9wYWNrX2RhdGEgKmRhdGEpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdCBzeW1yZWYgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCXN0cnVjdCBzdHJtYXAgd2FudGVkX3JlZnMgPSBTVFJNQVBfSU5JVDsKCXN0cnVjdCBzdHJ2ZWMgaGlkZGVuX3JlZnMgPSBTVFJWRUNfSU5JVDsKCXN0cnVjdCBvYmplY3RfYXJyYXkgd2FudF9vYmogPSBPQkpFQ1RfQVJSQVlfSU5JVDsKCXN0cnVjdCBvYmplY3RfYXJyYXkgaGF2ZV9vYmogPSBPQkpFQ1RfQVJSQVlfSU5JVDsKCXN0cnVjdCBvYmplY3RfYXJyYXkgc2hhbGxvd3MgPSBPQkpFQ1RfQVJSQVlfSU5JVDsKCXN0cnVjdCBvaWRzZXQgZGVlcGVuX25vdCA9IE9JRF9BUlJBWV9JTklUOwoJc3RydWN0IHN0cmluZ19saXN0IHVyaV9wcm90b2NvbHMgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCXN0cnVjdCBvYmplY3RfYXJyYXkgZXh0cmFfZWRnZV9vYmogPSBPQkpFQ1RfQVJSQVlfSU5JVDsKCXN0cnVjdCBzdHJpbmdfbGlzdCBhbGxvd2VkX2ZpbHRlcnMgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCgltZW1zZXQoZGF0YSwgMCwgc2l6ZW9mKCpkYXRhKSk7CglkYXRhLT5zeW1yZWYgPSBzeW1yZWY7CglkYXRhLT53YW50ZWRfcmVmcyA9IHdhbnRlZF9yZWZzOwoJZGF0YS0+aGlkZGVuX3JlZnMgPSBoaWRkZW5fcmVmczsKCWRhdGEtPndhbnRfb2JqID0gd2FudF9vYmo7CglkYXRhLT5oYXZlX29iaiA9IGhhdmVfb2JqOwoJZGF0YS0+c2hhbGxvd3MgPSBzaGFsbG93czsKCWRhdGEtPmRlZXBlbl9ub3QgPSBkZWVwZW5fbm90OwoJZGF0YS0+dXJpX3Byb3RvY29scyA9IHVyaV9wcm90b2NvbHM7CglkYXRhLT5leHRyYV9lZGdlX29iaiA9IGV4dHJhX2VkZ2Vfb2JqOwoJZGF0YS0+YWxsb3dlZF9maWx0ZXJzID0gYWxsb3dlZF9maWx0ZXJzOwoJZGF0YS0+YWxsb3dfZmlsdGVyX2ZhbGxiYWNrID0gMTsKCWRhdGEtPnRyZWVfZmlsdGVyX21heF9kZXB0aCA9IFVMT05HX01BWDsKCXBhY2tldF93cml0ZXJfaW5pdCgmZGF0YS0+d3JpdGVyLCAxKTsKCWxpc3Rfb2JqZWN0c19maWx0ZXJfaW5pdCgmZGF0YS0+ZmlsdGVyX29wdGlvbnMpOwoKCWRhdGEtPmtlZXBhbGl2ZSA9IDU7CglkYXRhLT5hZHZlcnRpc2Vfc2lkID0gMDsKfQoKc3RhdGljIHZvaWQgdXBsb2FkX3BhY2tfZGF0YV9jbGVhcihzdHJ1Y3QgdXBsb2FkX3BhY2tfZGF0YSAqZGF0YSkKewoJc3RyaW5nX2xpc3RfY2xlYXIoJmRhdGEtPnN5bXJlZiwgMSk7CglzdHJtYXBfY2xlYXIoJmRhdGEtPndhbnRlZF9yZWZzLCAxKTsKCXN0cnZlY19jbGVhcigmZGF0YS0+aGlkZGVuX3JlZnMpOwoJb2JqZWN0X2FycmF5X2NsZWFyKCZkYXRhLT53YW50X29iaik7CglvYmplY3RfYXJyYXlfY2xlYXIoJmRhdGEtPmhhdmVfb2JqKTsKCW9iamVjdF9hcnJheV9jbGVhcigmZGF0YS0+c2hhbGxvd3MpOwoJb2lkc2V0X2NsZWFyKCZkYXRhLT5kZWVwZW5fbm90KTsKCW9iamVjdF9hcnJheV9jbGVhcigmZGF0YS0+ZXh0cmFfZWRnZV9vYmopOwoJbGlzdF9vYmplY3RzX2ZpbHRlcl9yZWxlYXNlKCZkYXRhLT5maWx0ZXJfb3B0aW9ucyk7CglzdHJpbmdfbGlzdF9jbGVhcigmZGF0YS0+YWxsb3dlZF9maWx0ZXJzLCAwKTsKCglmcmVlKChjaGFyICopZGF0YS0+cGFja19vYmplY3RzX2hvb2spOwp9CgpzdGF0aWMgdm9pZCByZXNldF90aW1lb3V0KHVuc2lnbmVkIGludCB0aW1lb3V0KQp7CglhbGFybSh0aW1lb3V0KTsKfQoKc3RhdGljIHZvaWQgc2VuZF9jbGllbnRfZGF0YShpbnQgZmQsIGNvbnN0IGNoYXIgKmRhdGEsIHNzaXplX3Qgc3osCgkJCSAgICAgaW50IHVzZV9zaWRlYmFuZCkKewoJaWYgKHVzZV9zaWRlYmFuZCkgewoJCXNlbmRfc2lkZWJhbmQoMSwgZmQsIGRhdGEsIHN6LCB1c2Vfc2lkZWJhbmQpOwoJCXJldHVybjsKCX0KCWlmIChmZCA9PSAzKQoJCS8qIGVtZXJnZW5jeSBxdWl0ICovCgkJZmQgPSAyOwoJaWYgKGZkID09IDIpIHsKCQkvKiBYWFg6IGFyZSB3ZSBoYXBweSB0byBsb3NlIHN0dWZmIGhlcmU/ICovCgkJeHdyaXRlKGZkLCBkYXRhLCBzeik7CgkJcmV0dXJuOwoJfQoJd3JpdGVfb3JfZGllKGZkLCBkYXRhLCBzeik7Cn0KCnN0YXRpYyBpbnQgd3JpdGVfb25lX3NoYWxsb3coY29uc3Qgc3RydWN0IGNvbW1pdF9ncmFmdCAqZ3JhZnQsIHZvaWQgKmNiX2RhdGEpCnsKCUZJTEUgKmZwID0gY2JfZGF0YTsKCWlmIChncmFmdC0+bnJfcGFyZW50ID09IC0xKQoJCWZwcmludGYoZnAsICItLXNoYWxsb3cgJXNcbiIsIG9pZF90b19oZXgoJmdyYWZ0LT5vaWQpKTsKCXJldHVybiAwOwp9CgpzdHJ1Y3Qgb3V0cHV0X3N0YXRlIHsKCS8qCgkgKiBXZSBkbyB3cml0ZXMgbm8gYmlnZ2VyIHRoYW4gTEFSR0VfUEFDS0VUX0RBVEFfTUFYIC0gMSwgYmVjYXVzZSB3aXRoCgkgKiBzaWRlYmFuZC02NGsgdGhlIGJhbmQgZGVzaWduYXRvciB0YWtlcyB1cCAxIGJ5dGUgb2Ygc3BhY2UuIEJlY2F1c2UKCSAqIHJlbGF5X3BhY2tfZGF0YSBrZWVwcyB0aGUgbGFzdCBieXRlIHRvIGl0c2VsZiwgd2UgbWFrZSB0aGUgYnVmZmVyIDEKCSAqIGJ5dGUgYmlnZ2VyIHRoYW4gdGhlIGludGVuZGVkIG1heGltdW0gd3JpdGUgc2l6ZS4KCSAqLwoJY2hhciBidWZmZXJbKExBUkdFX1BBQ0tFVF9EQVRBX01BWCAtIDEpICsgMV07CglpbnQgdXNlZDsKCXVuc2lnbmVkIHBhY2tmaWxlX3VyaXNfc3RhcnRlZCA6IDE7Cgl1bnNpZ25lZCBwYWNrZmlsZV9zdGFydGVkIDogMTsKfTsKCnN0YXRpYyBpbnQgcmVsYXlfcGFja19kYXRhKGludCBwYWNrX29iamVjdHNfb3V0LCBzdHJ1Y3Qgb3V0cHV0X3N0YXRlICpvcywKCQkJICAgaW50IHVzZV9zaWRlYmFuZCwgaW50IHdyaXRlX3BhY2tmaWxlX2xpbmUpCnsKCS8qCgkgKiBXZSBrZWVwIHRoZSBsYXN0IGJ5dGUgdG8gb3Vyc2VsdmVzCgkgKiBpbiBjYXNlIHdlIGRldGVjdCBicm9rZW4gcmV2LWxpc3QsIHNvIHRoYXQgd2UKCSAqIGNhbiBsZWF2ZSB0aGUgc3RyZWFtIGNvcnJ1cHRlZC4gIFRoaXMgaXMKCSAqIHVuZm9ydHVuYXRlIC0tIHVucGFjay1vYmplY3RzIHdvdWxkIGhhcHBpbHkKCSAqIGFjY2VwdCBhIHZhbGlkIHBhY2tkYXRhIHdpdGggdHJhaWxpbmcgZ2FyYmFnZSwKCSAqIHNvIGFwcGVuZGluZyBnYXJiYWdlIGFmdGVyIHdlIHBhc3MgYWxsIHRoZQoJICogcGFjayBkYXRhIGlzIG5vdCBnb29kIGVub3VnaCB0byBzaWduYWwKCSAqIGJyZWFrYWdlIHRvIGRvd25zdHJlYW0uCgkgKi8KCXNzaXplX3QgcmVhZHN6OwoKCXJlYWRzeiA9IHhyZWFkKHBhY2tfb2JqZWN0c19vdXQsIG9zLT5idWZmZXIgKyBvcy0+dXNlZCwKCQkgICAgICAgc2l6ZW9mKG9zLT5idWZmZXIpIC0gb3MtPnVzZWQpOwoJaWYgKHJlYWRzeiA8IDApIHsKCQlyZXR1cm4gcmVhZHN6OwoJfQoJb3MtPnVzZWQgKz0gcmVhZHN6OwoKCXdoaWxlICghb3MtPnBhY2tmaWxlX3N0YXJ0ZWQpIHsKCQljaGFyICpwOwoJCWlmIChvcy0+dXNlZCA+PSA0ICYmICFtZW1jbXAob3MtPmJ1ZmZlciwgIlBBQ0siLCA0KSkgewoJCQlvcy0+cGFja2ZpbGVfc3RhcnRlZCA9IDE7CgkJCWlmICh3cml0ZV9wYWNrZmlsZV9saW5lKSB7CgkJCQlpZiAob3MtPnBhY2tmaWxlX3VyaXNfc3RhcnRlZCkKCQkJCQlwYWNrZXRfZGVsaW0oMSk7CgkJCQlwYWNrZXRfd3JpdGVfZm10KDEsICJcMXBhY2tmaWxlXG4iKTsKCQkJfQoJCQlicmVhazsKCQl9CgkJaWYgKChwID0gbWVtY2hyKG9zLT5idWZmZXIsICdcbicsIG9zLT51c2VkKSkpIHsKCQkJaWYgKCFvcy0+cGFja2ZpbGVfdXJpc19zdGFydGVkKSB7CgkJCQlvcy0+cGFja2ZpbGVfdXJpc19zdGFydGVkID0gMTsKCQkJCWlmICghd3JpdGVfcGFja2ZpbGVfbGluZSkKCQkJCQlCVUcoInBhY2tmaWxlX3VyaXMgcmVxdWlyZXMgc2lkZWJhbmQtYWxsIik7CgkJCQlwYWNrZXRfd3JpdGVfZm10KDEsICJcMXBhY2tmaWxlLXVyaXNcbiIpOwoJCQl9CgkJCSpwID0gJ1wwJzsKCQkJcGFja2V0X3dyaXRlX2ZtdCgxLCAiXDElc1xuIiwgb3MtPmJ1ZmZlcik7CgoJCQlvcy0+dXNlZCAtPSBwIC0gb3MtPmJ1ZmZlciArIDE7CgkJCW1lbW1vdmUob3MtPmJ1ZmZlciwgcCArIDEsIG9zLT51c2VkKTsKCQl9IGVsc2UgewoJCQkvKgoJCQkgKiBJbmNvbXBsZXRlIGxpbmUuCgkJCSAqLwoJCQlyZXR1cm4gcmVhZHN6OwoJCX0KCX0KCglpZiAob3MtPnVzZWQgPiAxKSB7CgkJc2VuZF9jbGllbnRfZGF0YSgxLCBvcy0+YnVmZmVyLCBvcy0+dXNlZCAtIDEsIHVzZV9zaWRlYmFuZCk7CgkJb3MtPmJ1ZmZlclswXSA9IG9zLT5idWZmZXJbb3MtPnVzZWQgLSAxXTsKCQlvcy0+dXNlZCA9IDE7Cgl9IGVsc2UgewoJCXNlbmRfY2xpZW50X2RhdGEoMSwgb3MtPmJ1ZmZlciwgb3MtPnVzZWQsIHVzZV9zaWRlYmFuZCk7CgkJb3MtPnVzZWQgPSAwOwoJfQoKCXJldHVybiByZWFkc3o7Cn0KCnN0YXRpYyB2b2lkIGNyZWF0ZV9wYWNrX2ZpbGUoc3RydWN0IHVwbG9hZF9wYWNrX2RhdGEgKnBhY2tfZGF0YSwKCQkJICAgICBjb25zdCBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnVyaV9wcm90b2NvbHMpCnsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIHBhY2tfb2JqZWN0cyA9IENISUxEX1BST0NFU1NfSU5JVDsKCXN0cnVjdCBvdXRwdXRfc3RhdGUgKm91dHB1dF9zdGF0ZSA9IHhjYWxsb2MoMSwgc2l6ZW9mKHN0cnVjdCBvdXRwdXRfc3RhdGUpKTsKCWNoYXIgcHJvZ3Jlc3NbMTI4XTsKCWNoYXIgYWJvcnRfbXNnW10gPSAiYWJvcnRpbmcgZHVlIHRvIHBvc3NpYmxlIHJlcG9zaXRvcnkgIgoJCSJjb3JydXB0aW9uIG9uIHRoZSByZW1vdGUgc2lkZS4iOwoJc3NpemVfdCBzejsKCWludCBpOwoJRklMRSAqcGlwZV9mZDsKCglpZiAoIXBhY2tfZGF0YS0+cGFja19vYmplY3RzX2hvb2spCgkJcGFja19vYmplY3RzLmdpdF9jbWQgPSAxOwoJZWxzZSB7CgkJc3RydmVjX3B1c2goJnBhY2tfb2JqZWN0cy5hcmdzLCBwYWNrX2RhdGEtPnBhY2tfb2JqZWN0c19ob29rKTsKCQlzdHJ2ZWNfcHVzaCgmcGFja19vYmplY3RzLmFyZ3MsICJnaXQiKTsKCQlwYWNrX29iamVjdHMudXNlX3NoZWxsID0gMTsKCX0KCglpZiAocGFja19kYXRhLT5zaGFsbG93X25yKSB7CgkJc3RydmVjX3B1c2goJnBhY2tfb2JqZWN0cy5hcmdzLCAiLS1zaGFsbG93LWZpbGUiKTsKCQlzdHJ2ZWNfcHVzaCgmcGFja19vYmplY3RzLmFyZ3MsICIiKTsKCX0KCXN0cnZlY19wdXNoKCZwYWNrX29iamVjdHMuYXJncywgInBhY2stb2JqZWN0cyIpOwoJc3RydmVjX3B1c2goJnBhY2tfb2JqZWN0cy5hcmdzLCAiLS1yZXZzIik7CglpZiAocGFja19kYXRhLT51c2VfdGhpbl9wYWNrKQoJCXN0cnZlY19wdXNoKCZwYWNrX29iamVjdHMuYXJncywgIi0tdGhpbiIpOwoKCXN0cnZlY19wdXNoKCZwYWNrX29iamVjdHMuYXJncywgIi0tc3Rkb3V0Iik7CglpZiAocGFja19kYXRhLT5zaGFsbG93X25yKQoJCXN0cnZlY19wdXNoKCZwYWNrX29iamVjdHMuYXJncywgIi0tc2hhbGxvdyIpOwoJaWYgKCFwYWNrX2RhdGEtPm5vX3Byb2dyZXNzKQoJCXN0cnZlY19wdXNoKCZwYWNrX29iamVjdHMuYXJncywgIi0tcHJvZ3Jlc3MiKTsKCWlmIChwYWNrX2RhdGEtPnVzZV9vZnNfZGVsdGEpCgkJc3RydmVjX3B1c2goJnBhY2tfb2JqZWN0cy5hcmdzLCAiLS1kZWx0YS1iYXNlLW9mZnNldCIpOwoJaWYgKHBhY2tfZGF0YS0+dXNlX2luY2x1ZGVfdGFnKQoJCXN0cnZlY19wdXNoKCZwYWNrX29iamVjdHMuYXJncywgIi0taW5jbHVkZS10YWciKTsKCWlmIChwYWNrX2RhdGEtPmZpbHRlcl9vcHRpb25zLmNob2ljZSkgewoJCWNvbnN0IGNoYXIgKnNwZWMgPQoJCQlleHBhbmRfbGlzdF9vYmplY3RzX2ZpbHRlcl9zcGVjKCZwYWNrX2RhdGEtPmZpbHRlcl9vcHRpb25zKTsKCQlzdHJ2ZWNfcHVzaGYoJnBhY2tfb2JqZWN0cy5hcmdzLCAiLS1maWx0ZXI9JXMiLCBzcGVjKTsKCX0KCWlmICh1cmlfcHJvdG9jb2xzKSB7CgkJZm9yIChpID0gMDsgaSA8IHVyaV9wcm90b2NvbHMtPm5yOyBpKyspCgkJCXN0cnZlY19wdXNoZigmcGFja19vYmplY3RzLmFyZ3MsICItLXVyaS1wcm90b2NvbD0lcyIsCgkJCQkJIHVyaV9wcm90b2NvbHMtPml0ZW1zW2ldLnN0cmluZyk7Cgl9CgoJcGFja19vYmplY3RzLmluID0gLTE7CglwYWNrX29iamVjdHMub3V0ID0gLTE7CglwYWNrX29iamVjdHMuZXJyID0gLTE7CglwYWNrX29iamVjdHMuY2xlYW5fb25fZXhpdCA9IDE7CgoJaWYgKHN0YXJ0X2NvbW1hbmQoJnBhY2tfb2JqZWN0cykpCgkJZGllKCJnaXQgdXBsb2FkLXBhY2s6IHVuYWJsZSB0byBmb3JrIGdpdC1wYWNrLW9iamVjdHMiKTsKCglwaXBlX2ZkID0geGZkb3BlbihwYWNrX29iamVjdHMuaW4sICJ3Iik7CgoJaWYgKHBhY2tfZGF0YS0+c2hhbGxvd19ucikKCQlmb3JfZWFjaF9jb21taXRfZ3JhZnQod3JpdGVfb25lX3NoYWxsb3csIHBpcGVfZmQpOwoKCWZvciAoaSA9IDA7IGkgPCBwYWNrX2RhdGEtPndhbnRfb2JqLm5yOyBpKyspCgkJZnByaW50ZihwaXBlX2ZkLCAiJXNcbiIsCgkJCW9pZF90b19oZXgoJnBhY2tfZGF0YS0+d2FudF9vYmoub2JqZWN0c1tpXS5pdGVtLT5vaWQpKTsKCWZwcmludGYocGlwZV9mZCwgIi0tbm90XG4iKTsKCWZvciAoaSA9IDA7IGkgPCBwYWNrX2RhdGEtPmhhdmVfb2JqLm5yOyBpKyspCgkJZnByaW50ZihwaXBlX2ZkLCAiJXNcbiIsCgkJCW9pZF90b19oZXgoJnBhY2tfZGF0YS0+aGF2ZV9vYmoub2JqZWN0c1tpXS5pdGVtLT5vaWQpKTsKCWZvciAoaSA9IDA7IGkgPCBwYWNrX2RhdGEtPmV4dHJhX2VkZ2Vfb2JqLm5yOyBpKyspCgkJZnByaW50ZihwaXBlX2ZkLCAiJXNcbiIsCgkJCW9pZF90b19oZXgoJnBhY2tfZGF0YS0+ZXh0cmFfZWRnZV9vYmoub2JqZWN0c1tpXS5pdGVtLT5vaWQpKTsKCWZwcmludGYocGlwZV9mZCwgIlxuIik7CglmZmx1c2gocGlwZV9mZCk7CglmY2xvc2UocGlwZV9mZCk7CgoJLyogV2UgcmVhZCBmcm9tIHBhY2tfb2JqZWN0cy5lcnIgdG8gY2FwdHVyZSBzdGRlcnIgb3V0cHV0IGZvcgoJICogcHJvZ3Jlc3MgYmFyLCBhbmQgcGFja19vYmplY3RzLm91dCB0byBjYXB0dXJlIHRoZSBwYWNrIGRhdGEuCgkgKi8KCgl3aGlsZSAoMSkgewoJCXN0cnVjdCBwb2xsZmQgcGZkWzJdOwoJCWludCBwZSwgcHUsIHBvbGxzaXplLCBwb2xsdGltZW91dDsKCQlpbnQgcmV0OwoKCQlyZXNldF90aW1lb3V0KHBhY2tfZGF0YS0+dGltZW91dCk7CgoJCXBvbGxzaXplID0gMDsKCQlwZSA9IHB1ID0gLTE7CgoJCWlmICgwIDw9IHBhY2tfb2JqZWN0cy5vdXQpIHsKCQkJcGZkW3BvbGxzaXplXS5mZCA9IHBhY2tfb2JqZWN0cy5vdXQ7CgkJCXBmZFtwb2xsc2l6ZV0uZXZlbnRzID0gUE9MTElOOwoJCQlwdSA9IHBvbGxzaXplOwoJCQlwb2xsc2l6ZSsrOwoJCX0KCQlpZiAoMCA8PSBwYWNrX29iamVjdHMuZXJyKSB7CgkJCXBmZFtwb2xsc2l6ZV0uZmQgPSBwYWNrX29iamVjdHMuZXJyOwoJCQlwZmRbcG9sbHNpemVdLmV2ZW50cyA9IFBPTExJTjsKCQkJcGUgPSBwb2xsc2l6ZTsKCQkJcG9sbHNpemUrKzsKCQl9CgoJCWlmICghcG9sbHNpemUpCgkJCWJyZWFrOwoKCQlwb2xsdGltZW91dCA9IHBhY2tfZGF0YS0+a2VlcGFsaXZlIDwgMAoJCQk/IC0xCgkJCTogMTAwMCAqIHBhY2tfZGF0YS0+a2VlcGFsaXZlOwoKCQlyZXQgPSBwb2xsKHBmZCwgcG9sbHNpemUsIHBvbGx0aW1lb3V0KTsKCgkJaWYgKHJldCA8IDApIHsKCQkJaWYgKGVycm5vICE9IEVJTlRSKSB7CgkJCQllcnJvcl9lcnJubygicG9sbCBmYWlsZWQsIHJlc3VtaW5nIik7CgkJCQlzbGVlcCgxKTsKCQkJfQoJCQljb250aW51ZTsKCQl9CgkJaWYgKDAgPD0gcGUgJiYgKHBmZFtwZV0ucmV2ZW50cyAmIChQT0xMSU58UE9MTEhVUCkpKSB7CgkJCS8qIFN0YXR1cyByZWFkeTsgd2Ugc2hpcCB0aGF0IGluIHRoZSBzaWRlLWJhbmQKCQkJICogb3IgZHVtcCB0byB0aGUgc3RhbmRhcmQgZXJyb3IuCgkJCSAqLwoJCQlzeiA9IHhyZWFkKHBhY2tfb2JqZWN0cy5lcnIsIHByb2dyZXNzLAoJCQkJICBzaXplb2YocHJvZ3Jlc3MpKTsKCQkJaWYgKDAgPCBzeikKCQkJCXNlbmRfY2xpZW50X2RhdGEoMiwgcHJvZ3Jlc3MsIHN6LAoJCQkJCQkgcGFja19kYXRhLT51c2Vfc2lkZWJhbmQpOwoJCQllbHNlIGlmIChzeiA9PSAwKSB7CgkJCQljbG9zZShwYWNrX29iamVjdHMuZXJyKTsKCQkJCXBhY2tfb2JqZWN0cy5lcnIgPSAtMTsKCQkJfQoJCQllbHNlCgkJCQlnb3RvIGZhaWw7CgkJCS8qIGdpdmUgcHJpb3JpdHkgdG8gc3RhdHVzIG1lc3NhZ2VzICovCgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoMCA8PSBwdSAmJiAocGZkW3B1XS5yZXZlbnRzICYgKFBPTExJTnxQT0xMSFVQKSkpIHsKCQkJaW50IHJlc3VsdCA9IHJlbGF5X3BhY2tfZGF0YShwYWNrX29iamVjdHMub3V0LAoJCQkJCQkgICAgIG91dHB1dF9zdGF0ZSwKCQkJCQkJICAgICBwYWNrX2RhdGEtPnVzZV9zaWRlYmFuZCwKCQkJCQkJICAgICAhIXVyaV9wcm90b2NvbHMpOwoKCQkJaWYgKHJlc3VsdCA9PSAwKSB7CgkJCQljbG9zZShwYWNrX29iamVjdHMub3V0KTsKCQkJCXBhY2tfb2JqZWN0cy5vdXQgPSAtMTsKCQkJfSBlbHNlIGlmIChyZXN1bHQgPCAwKSB7CgkJCQlnb3RvIGZhaWw7CgkJCX0KCQl9CgoJCS8qCgkJICogV2UgaGl0IHRoZSBrZWVwYWxpdmUgdGltZW91dCB3aXRob3V0IHNheWluZyBhbnl0aGluZzsgc2VuZAoJCSAqIGFuIGVtcHR5IG1lc3NhZ2Ugb24gdGhlIGRhdGEgc2lkZWJhbmQganVzdCB0byBsZXQgdGhlIG90aGVyCgkJICogc2lkZSBrbm93IHdlJ3JlIHN0aWxsIHdvcmtpbmcgb24gaXQsIGJ1dCBkb24ndCBoYXZlIGFueSBkYXRhCgkJICogeWV0LgoJCSAqCgkJICogSWYgd2UgZG9uJ3QgaGF2ZSBhIHNpZGViYW5kIGNoYW5uZWwsIHRoZXJlJ3Mgbm8gcm9vbSBpbiB0aGUKCQkgKiBwcm90b2NvbCB0byBzYXkgYW55dGhpbmcsIHNvIHRob3NlIGNsaWVudHMgYXJlIGp1c3Qgb3V0IG9mCgkJICogbHVjay4KCQkgKi8KCQlpZiAoIXJldCAmJiBwYWNrX2RhdGEtPnVzZV9zaWRlYmFuZCkgewoJCQlzdGF0aWMgY29uc3QgY2hhciBidWZbXSA9ICIwMDA1XDEiOwoJCQl3cml0ZV9vcl9kaWUoMSwgYnVmLCA1KTsKCQl9Cgl9CgoJaWYgKGZpbmlzaF9jb21tYW5kKCZwYWNrX29iamVjdHMpKSB7CgkJZXJyb3IoImdpdCB1cGxvYWQtcGFjazogZ2l0LXBhY2stb2JqZWN0cyBkaWVkIHdpdGggZXJyb3IuIik7CgkJZ290byBmYWlsOwoJfQoKCS8qIGZsdXNoIHRoZSBkYXRhICovCglpZiAob3V0cHV0X3N0YXRlLT51c2VkID4gMCkgewoJCXNlbmRfY2xpZW50X2RhdGEoMSwgb3V0cHV0X3N0YXRlLT5idWZmZXIsIG91dHB1dF9zdGF0ZS0+dXNlZCwKCQkJCSBwYWNrX2RhdGEtPnVzZV9zaWRlYmFuZCk7CgkJZnByaW50ZihzdGRlcnIsICJmbHVzaGVkLlxuIik7Cgl9CglmcmVlKG91dHB1dF9zdGF0ZSk7CglpZiAocGFja19kYXRhLT51c2Vfc2lkZWJhbmQpCgkJcGFja2V0X2ZsdXNoKDEpOwoJcmV0dXJuOwoKIGZhaWw6CglmcmVlKG91dHB1dF9zdGF0ZSk7CglzZW5kX2NsaWVudF9kYXRhKDMsIGFib3J0X21zZywgc3RybGVuKGFib3J0X21zZyksCgkJCSBwYWNrX2RhdGEtPnVzZV9zaWRlYmFuZCk7CglkaWUoImdpdCB1cGxvYWQtcGFjazogJXMiLCBhYm9ydF9tc2cpOwp9CgpzdGF0aWMgaW50IGRvX2dvdF9vaWQoc3RydWN0IHVwbG9hZF9wYWNrX2RhdGEgKmRhdGEsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJaW50IHdlX2tuZXdfdGhleV9oYXZlID0gMDsKCXN0cnVjdCBvYmplY3QgKm8gPSBwYXJzZV9vYmplY3Rfd2l0aF9mbGFncyh0aGVfcmVwb3NpdG9yeSwgb2lkLAoJCQkJCQkgICBQQVJTRV9PQkpFQ1RfU0tJUF9IQVNIX0NIRUNLIHwKCQkJCQkJICAgUEFSU0VfT0JKRUNUX0RJU0NBUkRfVFJFRSk7CgoJaWYgKCFvKQoJCWRpZSgib29wcyAoJXMpIiwgb2lkX3RvX2hleChvaWQpKTsKCWlmIChvLT50eXBlID09IE9CSl9DT01NSVQpIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHM7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gKHN0cnVjdCBjb21taXQgKilvOwoJCWlmIChvLT5mbGFncyAmIFRIRVlfSEFWRSkKCQkJd2Vfa25ld190aGV5X2hhdmUgPSAxOwoJCWVsc2UKCQkJby0+ZmxhZ3MgfD0gVEhFWV9IQVZFOwoJCWlmICghZGF0YS0+b2xkZXN0X2hhdmUgfHwgKGNvbW1pdC0+ZGF0ZSA8IGRhdGEtPm9sZGVzdF9oYXZlKSkKCQkJZGF0YS0+b2xkZXN0X2hhdmUgPSBjb21taXQtPmRhdGU7CgkJZm9yIChwYXJlbnRzID0gY29tbWl0LT5wYXJlbnRzOwoJCSAgICAgcGFyZW50czsKCQkgICAgIHBhcmVudHMgPSBwYXJlbnRzLT5uZXh0KQoJCQlwYXJlbnRzLT5pdGVtLT5vYmplY3QuZmxhZ3MgfD0gVEhFWV9IQVZFOwoJfQoJaWYgKCF3ZV9rbmV3X3RoZXlfaGF2ZSkgewoJCWFkZF9vYmplY3RfYXJyYXkobywgTlVMTCwgJmRhdGEtPmhhdmVfb2JqKTsKCQlyZXR1cm4gMTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdvdF9vaWQoc3RydWN0IHVwbG9hZF9wYWNrX2RhdGEgKmRhdGEsCgkJICAgY29uc3QgY2hhciAqaGV4LCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCWlmIChnZXRfb2lkX2hleChoZXgsIG9pZCkpCgkJZGllKCJnaXQgdXBsb2FkLXBhY2s6IGV4cGVjdGVkIFNIQTEgb2JqZWN0LCBnb3QgJyVzJyIsIGhleCk7CglpZiAoIXJlcG9faGFzX29iamVjdF9maWxlX3dpdGhfZmxhZ3ModGhlX3JlcG9zaXRvcnksIG9pZCwKCQkJCQkgICAgIE9CSkVDVF9JTkZPX1FVSUNLIHwgT0JKRUNUX0lORk9fU0tJUF9GRVRDSF9PQkpFQ1QpKQoJCXJldHVybiAtMTsKCXJldHVybiBkb19nb3Rfb2lkKGRhdGEsIG9pZCk7Cn0KCnN0YXRpYyBpbnQgb2tfdG9fZ2l2ZV91cChzdHJ1Y3QgdXBsb2FkX3BhY2tfZGF0YSAqZGF0YSkKewoJdGltZXN0YW1wX3QgbWluX2dlbmVyYXRpb24gPSBHRU5FUkFUSU9OX05VTUJFUl9aRVJPOwoKCWlmICghZGF0YS0+aGF2ZV9vYmoubnIpCgkJcmV0dXJuIDA7CgoJcmV0dXJuIGNhbl9hbGxfZnJvbV9yZWFjaF93aXRoX2ZsYWcoJmRhdGEtPndhbnRfb2JqLCBUSEVZX0hBVkUsCgkJCQkJICAgIENPTU1PTl9LTk9XTiwgZGF0YS0+b2xkZXN0X2hhdmUsCgkJCQkJICAgIG1pbl9nZW5lcmF0aW9uKTsKfQoKc3RhdGljIGludCBnZXRfY29tbW9uX2NvbW1pdHMoc3RydWN0IHVwbG9hZF9wYWNrX2RhdGEgKmRhdGEsCgkJCSAgICAgIHN0cnVjdCBwYWNrZXRfcmVhZGVyICpyZWFkZXIpCnsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJY2hhciBsYXN0X2hleFtHSVRfTUFYX0hFWFNaICsgMV07CglpbnQgZ290X2NvbW1vbiA9IDA7CglpbnQgZ290X290aGVyID0gMDsKCWludCBzZW50X3JlYWR5ID0gMDsKCglmb3IgKDs7KSB7CgkJY29uc3QgY2hhciAqYXJnOwoKCQlyZXNldF90aW1lb3V0KGRhdGEtPnRpbWVvdXQpOwoKCQlpZiAocGFja2V0X3JlYWRlcl9yZWFkKHJlYWRlcikgIT0gUEFDS0VUX1JFQURfTk9STUFMKSB7CgkJCWlmIChkYXRhLT5tdWx0aV9hY2sgPT0gTVVMVElfQUNLX0RFVEFJTEVECgkJCSAgICAmJiBnb3RfY29tbW9uCgkJCSAgICAmJiAhZ290X290aGVyCgkJCSAgICAmJiBva190b19naXZlX3VwKGRhdGEpKSB7CgkJCQlzZW50X3JlYWR5ID0gMTsKCQkJCXBhY2tldF93cml0ZV9mbXQoMSwgIkFDSyAlcyByZWFkeVxuIiwgbGFzdF9oZXgpOwoJCQl9CgkJCWlmIChkYXRhLT5oYXZlX29iai5uciA9PSAwIHx8IGRhdGEtPm11bHRpX2FjaykKCQkJCXBhY2tldF93cml0ZV9mbXQoMSwgIk5BS1xuIik7CgoJCQlpZiAoZGF0YS0+bm9fZG9uZSAmJiBzZW50X3JlYWR5KSB7CgkJCQlwYWNrZXRfd3JpdGVfZm10KDEsICJBQ0sgJXNcbiIsIGxhc3RfaGV4KTsKCQkJCXJldHVybiAwOwoJCQl9CgkJCWlmIChkYXRhLT5zdGF0ZWxlc3NfcnBjKQoJCQkJZXhpdCgwKTsKCQkJZ290X2NvbW1vbiA9IDA7CgkJCWdvdF9vdGhlciA9IDA7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoc2tpcF9wcmVmaXgocmVhZGVyLT5saW5lLCAiaGF2ZSAiLCAmYXJnKSkgewoJCQlzd2l0Y2ggKGdvdF9vaWQoZGF0YSwgYXJnLCAmb2lkKSkgewoJCQljYXNlIC0xOiAvKiB0aGV5IGhhdmUgd2hhdCB3ZSBkbyBub3QgKi8KCQkJCWdvdF9vdGhlciA9IDE7CgkJCQlpZiAoZGF0YS0+bXVsdGlfYWNrCgkJCQkgICAgJiYgb2tfdG9fZ2l2ZV91cChkYXRhKSkgewoJCQkJCWNvbnN0IGNoYXIgKmhleCA9IG9pZF90b19oZXgoJm9pZCk7CgkJCQkJaWYgKGRhdGEtPm11bHRpX2FjayA9PSBNVUxUSV9BQ0tfREVUQUlMRUQpIHsKCQkJCQkJc2VudF9yZWFkeSA9IDE7CgkJCQkJCXBhY2tldF93cml0ZV9mbXQoMSwgIkFDSyAlcyByZWFkeVxuIiwgaGV4KTsKCQkJCQl9IGVsc2UKCQkJCQkJcGFja2V0X3dyaXRlX2ZtdCgxLCAiQUNLICVzIGNvbnRpbnVlXG4iLCBoZXgpOwoJCQkJfQoJCQkJYnJlYWs7CgkJCWRlZmF1bHQ6CgkJCQlnb3RfY29tbW9uID0gMTsKCQkJCW9pZF90b19oZXhfcihsYXN0X2hleCwgJm9pZCk7CgkJCQlpZiAoZGF0YS0+bXVsdGlfYWNrID09IE1VTFRJX0FDS19ERVRBSUxFRCkKCQkJCQlwYWNrZXRfd3JpdGVfZm10KDEsICJBQ0sgJXMgY29tbW9uXG4iLCBsYXN0X2hleCk7CgkJCQllbHNlIGlmIChkYXRhLT5tdWx0aV9hY2spCgkJCQkJcGFja2V0X3dyaXRlX2ZtdCgxLCAiQUNLICVzIGNvbnRpbnVlXG4iLCBsYXN0X2hleCk7CgkJCQllbHNlIGlmIChkYXRhLT5oYXZlX29iai5uciA9PSAxKQoJCQkJCXBhY2tldF93cml0ZV9mbXQoMSwgIkFDSyAlc1xuIiwgbGFzdF9oZXgpOwoJCQkJYnJlYWs7CgkJCX0KCQkJY29udGludWU7CgkJfQoJCWlmICghc3RyY21wKHJlYWRlci0+bGluZSwgImRvbmUiKSkgewoJCQlpZiAoZGF0YS0+aGF2ZV9vYmoubnIgPiAwKSB7CgkJCQlpZiAoZGF0YS0+bXVsdGlfYWNrKQoJCQkJCXBhY2tldF93cml0ZV9mbXQoMSwgIkFDSyAlc1xuIiwgbGFzdF9oZXgpOwoJCQkJcmV0dXJuIDA7CgkJCX0KCQkJcGFja2V0X3dyaXRlX2ZtdCgxLCAiTkFLXG4iKTsKCQkJcmV0dXJuIC0xOwoJCX0KCQlkaWUoImdpdCB1cGxvYWQtcGFjazogZXhwZWN0ZWQgU0hBMSBsaXN0LCBnb3QgJyVzJyIsIHJlYWRlci0+bGluZSk7Cgl9Cn0KCnN0YXRpYyBpbnQgYWxsb3dfaGlkZGVuX3JlZnMoZW51bSBhbGxvd191b3IgYWxsb3dfdW9yKQp7CglpZiAoKGFsbG93X3VvciAmIEFMTE9XX0FOWV9TSEExKSA9PSBBTExPV19BTllfU0hBMSkKCQlyZXR1cm4gMTsKCXJldHVybiAhKGFsbG93X3VvciAmIChBTExPV19USVBfU0hBMSB8IEFMTE9XX1JFQUNIQUJMRV9TSEExKSk7Cn0KCnN0YXRpYyB2b2lkIGZvcl9lYWNoX25hbWVzcGFjZWRfcmVmXzEoZWFjaF9yZWZfZm4gZm4sCgkJCQkgICAgICBzdHJ1Y3QgdXBsb2FkX3BhY2tfZGF0YSAqZGF0YSkKewoJY29uc3QgY2hhciAqKmV4Y2x1ZGVzID0gTlVMTDsKCS8qCgkgKiBJZiBgZGF0YS0+YWxsb3dfdW9yYCBhbGxvd3MgZmV0Y2hpbmcgaGlkZGVuIHJlZnMsIHdlIG5lZWQgdG8KCSAqIG1hcmsgYWxsIHJlZmVyZW5jZXMgKGluY2x1ZGluZyBoaWRkZW4gb25lcyksIHRvIGNoZWNrIGluCgkgKiBgaXNfb3VyX3JlZigpYCBiZWxvdy4KCSAqCgkgKiBPdGhlcndpc2UsIHdlIG9ubHkgY2FyZSBhYm91dCB3aGV0aGVyIGVhY2ggcmVmZXJlbmNlJ3Mgb2JqZWN0CgkgKiBoYXMgdGhlIE9VUl9SRUYgYml0IHNldCBvciBub3QsIHNvIGRvIG5vdCBuZWVkIHRvIHZpc2l0CgkgKiBoaWRkZW4gcmVmZXJlbmNlcy4KCSAqLwoJaWYgKGFsbG93X2hpZGRlbl9yZWZzKGRhdGEtPmFsbG93X3VvcikpCgkJZXhjbHVkZXMgPSBoaWRkZW5fcmVmc190b19leGNsdWRlcygmZGF0YS0+aGlkZGVuX3JlZnMpOwoKCXJlZnNfZm9yX2VhY2hfbmFtZXNwYWNlZF9yZWYoZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KSwKCQkJCSAgICAgZXhjbHVkZXMsIGZuLCBkYXRhKTsKfQoKCnN0YXRpYyBpbnQgaXNfb3VyX3JlZihzdHJ1Y3Qgb2JqZWN0ICpvLCBlbnVtIGFsbG93X3VvciBhbGxvd191b3IpCnsKCXJldHVybiBvLT5mbGFncyAmICgoYWxsb3dfaGlkZGVuX3JlZnMoYWxsb3dfdW9yKSA/IDAgOiBISURERU5fUkVGKSB8IE9VUl9SRUYpOwp9CgovKgogKiBvbiBzdWNjZXNzZnVsIGNhc2UsIGl0J3MgdXAgdG8gdGhlIGNhbGxlciB0byBjbG9zZSBjbWQtPm91dAogKi8Kc3RhdGljIGludCBkb19yZWFjaGFibGVfcmV2bGlzdChzdHJ1Y3QgY2hpbGRfcHJvY2VzcyAqY21kLAoJCQkJc3RydWN0IG9iamVjdF9hcnJheSAqc3JjLAoJCQkJc3RydWN0IG9iamVjdF9hcnJheSAqcmVhY2hhYmxlLAoJCQkJZW51bSBhbGxvd191b3IgYWxsb3dfdW9yKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvOwoJRklMRSAqY21kX2luID0gTlVMTDsKCWludCBpOwoKCXN0cnZlY19wdXNobCgmY21kLT5hcmdzLCAicmV2LWxpc3QiLCAiLS1zdGRpbiIsIE5VTEwpOwoJY21kLT5naXRfY21kID0gMTsKCWNtZC0+bm9fc3RkZXJyID0gMTsKCWNtZC0+aW4gPSAtMTsKCWNtZC0+b3V0ID0gLTE7CgoJLyoKCSAqIElmIHRoZSBuZXh0IHJldi1saXN0IC0tc3RkaW4gZW5jb3VudGVycyBhbiB1bmtub3duIGNvbW1pdCwKCSAqIGl0IHRlcm1pbmF0ZXMsIHdoaWNoIHdpbGwgY2F1c2UgU0lHUElQRSBpbiB0aGUgd3JpdGUgbG9vcAoJICogYmVsb3cuCgkgKi8KCXNpZ2NoYWluX3B1c2goU0lHUElQRSwgU0lHX0lHTik7CgoJaWYgKHN0YXJ0X2NvbW1hbmQoY21kKSkKCQlnb3RvIGVycm9yOwoKCWNtZF9pbiA9IHhmZG9wZW4oY21kLT5pbiwgInciKTsKCglmb3IgKGkgPSBnZXRfbWF4X29iamVjdF9pbmRleCgpOyAwIDwgaTsgKSB7CgkJbyA9IGdldF9pbmRleGVkX29iamVjdCgtLWkpOwoJCWlmICghbykKCQkJY29udGludWU7CgkJaWYgKHJlYWNoYWJsZSAmJiBvLT50eXBlID09IE9CSl9DT01NSVQpCgkJCW8tPmZsYWdzICY9IH5UTVBfTUFSSzsKCQlpZiAoIWlzX291cl9yZWYobywgYWxsb3dfdW9yKSkKCQkJY29udGludWU7CgkJaWYgKGZwcmludGYoY21kX2luLCAiXiVzXG4iLCBvaWRfdG9faGV4KCZvLT5vaWQpKSA8IDApCgkJCWdvdG8gZXJyb3I7Cgl9Cglmb3IgKGkgPSAwOyBpIDwgc3JjLT5ucjsgaSsrKSB7CgkJbyA9IHNyYy0+b2JqZWN0c1tpXS5pdGVtOwoJCWlmIChpc19vdXJfcmVmKG8sIGFsbG93X3VvcikpIHsKCQkJaWYgKHJlYWNoYWJsZSkKCQkJCWFkZF9vYmplY3RfYXJyYXkobywgTlVMTCwgcmVhY2hhYmxlKTsKCQkJY29udGludWU7CgkJfQoJCWlmIChyZWFjaGFibGUgJiYgby0+dHlwZSA9PSBPQkpfQ09NTUlUKQoJCQlvLT5mbGFncyB8PSBUTVBfTUFSSzsKCQlpZiAoZnByaW50ZihjbWRfaW4sICIlc1xuIiwgb2lkX3RvX2hleCgmby0+b2lkKSkgPCAwKQoJCQlnb3RvIGVycm9yOwoJfQoJaWYgKGZlcnJvcihjbWRfaW4pIHx8IGZmbHVzaChjbWRfaW4pKQoJCWdvdG8gZXJyb3I7CglmY2xvc2UoY21kX2luKTsKCWNtZC0+aW4gPSAtMTsKCXNpZ2NoYWluX3BvcChTSUdQSVBFKTsKCglyZXR1cm4gMDsKCmVycm9yOgoJc2lnY2hhaW5fcG9wKFNJR1BJUEUpOwoKCWlmIChjbWRfaW4pCgkJZmNsb3NlKGNtZF9pbik7CglpZiAoY21kLT5vdXQgPj0gMCkKCQljbG9zZShjbWQtPm91dCk7CglyZXR1cm4gLTE7Cn0KCnN0YXRpYyBpbnQgZ2V0X3JlYWNoYWJsZV9saXN0KHN0cnVjdCB1cGxvYWRfcGFja19kYXRhICpkYXRhLAoJCQkgICAgICBzdHJ1Y3Qgb2JqZWN0X2FycmF5ICpyZWFjaGFibGUpCnsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGNtZCA9IENISUxEX1BST0NFU1NfSU5JVDsKCWludCBpOwoJc3RydWN0IG9iamVjdCAqbzsKCWNoYXIgbmFtZWJ1ZltHSVRfTUFYX0hFWFNaICsgMl07IC8qIF4gKyBoYXNoICsgTEYgKi8KCWNvbnN0IHVuc2lnbmVkIGhleHN6ID0gdGhlX2hhc2hfYWxnby0+aGV4c3o7CgoJaWYgKGRvX3JlYWNoYWJsZV9yZXZsaXN0KCZjbWQsICZkYXRhLT5zaGFsbG93cywgcmVhY2hhYmxlLAoJCQkJIGRhdGEtPmFsbG93X3VvcikgPCAwKQoJCXJldHVybiAtMTsKCgl3aGlsZSAoKGkgPSByZWFkX2luX2Z1bGwoY21kLm91dCwgbmFtZWJ1ZiwgaGV4c3ogKyAxKSkgPT0gaGV4c3ogKyAxKSB7CgkJc3RydWN0IG9iamVjdF9pZCBvaWQ7CgkJY29uc3QgY2hhciAqcDsKCgkJaWYgKHBhcnNlX29pZF9oZXgobmFtZWJ1ZiwgJm9pZCwgJnApIHx8ICpwICE9ICdcbicpCgkJCWJyZWFrOwoKCQlvID0gbG9va3VwX29iamVjdCh0aGVfcmVwb3NpdG9yeSwgJm9pZCk7CgkJaWYgKG8gJiYgby0+dHlwZSA9PSBPQkpfQ09NTUlUKSB7CgkJCW8tPmZsYWdzICY9IH5UTVBfTUFSSzsKCQl9Cgl9Cglmb3IgKGkgPSBnZXRfbWF4X29iamVjdF9pbmRleCgpOyAwIDwgaTsgaS0tKSB7CgkJbyA9IGdldF9pbmRleGVkX29iamVjdChpIC0gMSk7CgkJaWYgKG8gJiYgby0+dHlwZSA9PSBPQkpfQ09NTUlUICYmCgkJICAgIChvLT5mbGFncyAmIFRNUF9NQVJLKSkgewoJCQlhZGRfb2JqZWN0X2FycmF5KG8sIE5VTEwsIHJlYWNoYWJsZSk7CgkJCQlvLT5mbGFncyAmPSB+VE1QX01BUks7CgkJfQoJfQoJY2xvc2UoY21kLm91dCk7CgoJaWYgKGZpbmlzaF9jb21tYW5kKCZjbWQpKQoJCXJldHVybiAtMTsKCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBoYXNfdW5yZWFjaGFibGUoc3RydWN0IG9iamVjdF9hcnJheSAqc3JjLCBlbnVtIGFsbG93X3VvciBhbGxvd191b3IpCnsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGNtZCA9IENISUxEX1BST0NFU1NfSU5JVDsKCWNoYXIgYnVmWzFdOwoJaW50IGk7CgoJaWYgKGRvX3JlYWNoYWJsZV9yZXZsaXN0KCZjbWQsIHNyYywgTlVMTCwgYWxsb3dfdW9yKSA8IDApCgkJcmV0dXJuIDE7CgoJLyoKCSAqIFRoZSBjb21taXRzIG91dCBvZiB0aGUgcmV2LWxpc3QgYXJlIG5vdCBhbmNlc3RvcnMgb2YKCSAqIG91ciByZWYuCgkgKi8KCWkgPSByZWFkX2luX2Z1bGwoY21kLm91dCwgYnVmLCAxKTsKCWlmIChpKQoJCWdvdG8gZXJyb3I7CgljbG9zZShjbWQub3V0KTsKCWNtZC5vdXQgPSAtMTsKCgkvKgoJICogcmV2LWxpc3QgbWF5IGhhdmUgZGllZCBieSBlbmNvdW50ZXJpbmcgYSBiYWQgY29tbWl0CgkgKiBpbiB0aGUgaGlzdG9yeSwgaW4gd2hpY2ggY2FzZSB3ZSBkbyB3YW50IHRvIGJhaWwgb3V0CgkgKiBldmVuIHdoZW4gaXQgc2hvd2VkIG5vIGNvbW1pdC4KCSAqLwoJaWYgKGZpbmlzaF9jb21tYW5kKCZjbWQpKQoJCWdvdG8gZXJyb3I7CgoJLyogQWxsIHRoZSBub24tdGlwIG9uZXMgYXJlIGFuY2VzdG9ycyBvZiB3aGF0IHdlIGFkdmVydGlzZWQgKi8KCXJldHVybiAwOwoKZXJyb3I6CglpZiAoY21kLm91dCA+PSAwKQoJCWNsb3NlKGNtZC5vdXQpOwoJcmV0dXJuIDE7Cn0KCnN0YXRpYyB2b2lkIGNoZWNrX25vbl90aXAoc3RydWN0IHVwbG9hZF9wYWNrX2RhdGEgKmRhdGEpCnsKCWludCBpOwoKCS8qCgkgKiBJbiB0aGUgbm9ybWFsIGluLXByb2Nlc3MgY2FzZSB3aXRob3V0CgkgKiB1cGxvYWRwYWNrLmFsbG93UmVhY2hhYmxlU0hBMUluV2FudCwKCSAqIG5vbi10aXAgcmVxdWVzdHMgY2FuIG5ldmVyIGhhcHBlbi4KCSAqLwoJaWYgKCFkYXRhLT5zdGF0ZWxlc3NfcnBjICYmICEoZGF0YS0+YWxsb3dfdW9yICYgQUxMT1dfUkVBQ0hBQkxFX1NIQTEpKQoJCWdvdG8gZXJyb3I7CglpZiAoIWhhc191bnJlYWNoYWJsZSgmZGF0YS0+d2FudF9vYmosIGRhdGEtPmFsbG93X3VvcikpCgkJLyogQWxsIHRoZSBub24tdGlwIG9uZXMgYXJlIGFuY2VzdG9ycyBvZiB3aGF0IHdlIGFkdmVydGlzZWQgKi8KCQlyZXR1cm47CgplcnJvcjoKCS8qIFBpY2sgb25lIG9mIHRoZW0gKHdlIGtub3cgdGhlcmUgYXQgbGVhc3QgaXMgb25lKSAqLwoJZm9yIChpID0gMDsgaSA8IGRhdGEtPndhbnRfb2JqLm5yOyBpKyspIHsKCQlzdHJ1Y3Qgb2JqZWN0ICpvID0gZGF0YS0+d2FudF9vYmoub2JqZWN0c1tpXS5pdGVtOwoJCWlmICghaXNfb3VyX3JlZihvLCBkYXRhLT5hbGxvd191b3IpKSB7CgkJCWVycm9yKCJnaXQgdXBsb2FkLXBhY2s6IG5vdCBvdXIgcmVmICVzIiwKCQkJICAgICAgb2lkX3RvX2hleCgmby0+b2lkKSk7CgkJCXBhY2tldF93cml0ZXJfZXJyb3IoJmRhdGEtPndyaXRlciwKCQkJCQkgICAgInVwbG9hZC1wYWNrOiBub3Qgb3VyIHJlZiAlcyIsCgkJCQkJICAgIG9pZF90b19oZXgoJm8tPm9pZCkpOwoJCQlleGl0KDEyOCk7CgkJfQoJfQp9CgpzdGF0aWMgdm9pZCBzZW5kX3NoYWxsb3coc3RydWN0IHVwbG9hZF9wYWNrX2RhdGEgKmRhdGEsCgkJCSBzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlc3VsdCkKewoJd2hpbGUgKHJlc3VsdCkgewoJCXN0cnVjdCBvYmplY3QgKm9iamVjdCA9ICZyZXN1bHQtPml0ZW0tPm9iamVjdDsKCQlpZiAoIShvYmplY3QtPmZsYWdzICYgKENMSUVOVF9TSEFMTE9XfE5PVF9TSEFMTE9XKSkpIHsKCQkJcGFja2V0X3dyaXRlcl93cml0ZSgmZGF0YS0+d3JpdGVyLCAic2hhbGxvdyAlcyIsCgkJCQkJICAgIG9pZF90b19oZXgoJm9iamVjdC0+b2lkKSk7CgkJCXJlZ2lzdGVyX3NoYWxsb3codGhlX3JlcG9zaXRvcnksICZvYmplY3QtPm9pZCk7CgkJCWRhdGEtPnNoYWxsb3dfbnIrKzsKCQl9CgkJcmVzdWx0ID0gcmVzdWx0LT5uZXh0OwoJfQp9CgpzdGF0aWMgdm9pZCBzZW5kX3Vuc2hhbGxvdyhzdHJ1Y3QgdXBsb2FkX3BhY2tfZGF0YSAqZGF0YSkKewoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IGRhdGEtPnNoYWxsb3dzLm5yOyBpKyspIHsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmplY3QgPSBkYXRhLT5zaGFsbG93cy5vYmplY3RzW2ldLml0ZW07CgkJaWYgKG9iamVjdC0+ZmxhZ3MgJiBOT1RfU0hBTExPVykgewoJCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHM7CgkJCXBhY2tldF93cml0ZXJfd3JpdGUoJmRhdGEtPndyaXRlciwgInVuc2hhbGxvdyAlcyIsCgkJCQkJICAgIG9pZF90b19oZXgoJm9iamVjdC0+b2lkKSk7CgkJCW9iamVjdC0+ZmxhZ3MgJj0gfkNMSUVOVF9TSEFMTE9XOwoJCQkvKgoJCQkgKiBXZSB3YW50IHRvIF9yZWdpc3Rlcl8gIm9iamVjdCIgYXMgc2hhbGxvdywgYnV0IHdlCgkJCSAqIGFsc28gbmVlZCB0byB0cmF2ZXJzZSBvYmplY3QncyBwYXJlbnRzIHRvIGRlZXBlbiBhCgkJCSAqIHNoYWxsb3cgY2xvbmUuIFVucmVnaXN0ZXIgaXQgZm9yIG5vdyBzbyB3ZSBjYW4KCQkJICogcGFyc2UgYW5kIGFkZCB0aGUgcGFyZW50cyB0byB0aGUgd2FudCBsaXN0LCB0aGVuCgkJCSAqIHJlLXJlZ2lzdGVyIGl0LgoJCQkgKi8KCQkJdW5yZWdpc3Rlcl9zaGFsbG93KCZvYmplY3QtPm9pZCk7CgkJCW9iamVjdC0+cGFyc2VkID0gMDsKCQkJcGFyc2VfY29tbWl0X29yX2RpZSgoc3RydWN0IGNvbW1pdCAqKW9iamVjdCk7CgkJCXBhcmVudHMgPSAoKHN0cnVjdCBjb21taXQgKilvYmplY3QpLT5wYXJlbnRzOwoJCQl3aGlsZSAocGFyZW50cykgewoJCQkJYWRkX29iamVjdF9hcnJheSgmcGFyZW50cy0+aXRlbS0+b2JqZWN0LAoJCQkJCQkgTlVMTCwgJmRhdGEtPndhbnRfb2JqKTsKCQkJCXBhcmVudHMgPSBwYXJlbnRzLT5uZXh0OwoJCQl9CgkJCWFkZF9vYmplY3RfYXJyYXkob2JqZWN0LCBOVUxMLCAmZGF0YS0+ZXh0cmFfZWRnZV9vYmopOwoJCX0KCQkvKiBtYWtlIHN1cmUgY29tbWl0IHRyYXZlcnNhbCBjb25mb3JtcyB0byBjbGllbnQgKi8KCQlyZWdpc3Rlcl9zaGFsbG93KHRoZV9yZXBvc2l0b3J5LCAmb2JqZWN0LT5vaWQpOwoJfQp9CgpzdGF0aWMgaW50IGNoZWNrX3JlZihjb25zdCBjaGFyICpyZWZuYW1lX2Z1bGwsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkgICAgIGludCBmbGFnLCB2b2lkICpjYl9kYXRhKTsKc3RhdGljIHZvaWQgZGVlcGVuKHN0cnVjdCB1cGxvYWRfcGFja19kYXRhICpkYXRhLCBpbnQgZGVwdGgpCnsKCWlmIChkZXB0aCA9PSBJTkZJTklURV9ERVBUSCAmJiAhaXNfcmVwb3NpdG9yeV9zaGFsbG93KHRoZV9yZXBvc2l0b3J5KSkgewoJCWludCBpOwoKCQlmb3IgKGkgPSAwOyBpIDwgZGF0YS0+c2hhbGxvd3MubnI7IGkrKykgewoJCQlzdHJ1Y3Qgb2JqZWN0ICpvYmplY3QgPSBkYXRhLT5zaGFsbG93cy5vYmplY3RzW2ldLml0ZW07CgkJCW9iamVjdC0+ZmxhZ3MgfD0gTk9UX1NIQUxMT1c7CgkJfQoJfSBlbHNlIGlmIChkYXRhLT5kZWVwZW5fcmVsYXRpdmUpIHsKCQlzdHJ1Y3Qgb2JqZWN0X2FycmF5IHJlYWNoYWJsZV9zaGFsbG93cyA9IE9CSkVDVF9BUlJBWV9JTklUOwoJCXN0cnVjdCBjb21taXRfbGlzdCAqcmVzdWx0OwoKCQkvKgoJCSAqIENoZWNraW5nIGZvciByZWFjaGFibGUgc2hhbGxvd3MgcmVxdWlyZXMgdGhhdCBvdXIgcmVmcyBiZQoJCSAqIG1hcmtlZCB3aXRoIE9VUl9SRUYuCgkJICovCgkJcmVmc19oZWFkX3JlZl9uYW1lc3BhY2VkKGdldF9tYWluX3JlZl9zdG9yZSh0aGVfcmVwb3NpdG9yeSksCgkJCQkJIGNoZWNrX3JlZiwgZGF0YSk7CgkJZm9yX2VhY2hfbmFtZXNwYWNlZF9yZWZfMShjaGVja19yZWYsIGRhdGEpOwoKCQlnZXRfcmVhY2hhYmxlX2xpc3QoZGF0YSwgJnJlYWNoYWJsZV9zaGFsbG93cyk7CgkJcmVzdWx0ID0gZ2V0X3NoYWxsb3dfY29tbWl0cygmcmVhY2hhYmxlX3NoYWxsb3dzLAoJCQkJCSAgICAgZGVwdGggKyAxLAoJCQkJCSAgICAgU0hBTExPVywgTk9UX1NIQUxMT1cpOwoJCXNlbmRfc2hhbGxvdyhkYXRhLCByZXN1bHQpOwoJCWZyZWVfY29tbWl0X2xpc3QocmVzdWx0KTsKCQlvYmplY3RfYXJyYXlfY2xlYXIoJnJlYWNoYWJsZV9zaGFsbG93cyk7Cgl9IGVsc2UgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqcmVzdWx0OwoKCQlyZXN1bHQgPSBnZXRfc2hhbGxvd19jb21taXRzKCZkYXRhLT53YW50X29iaiwgZGVwdGgsCgkJCQkJICAgICBTSEFMTE9XLCBOT1RfU0hBTExPVyk7CgkJc2VuZF9zaGFsbG93KGRhdGEsIHJlc3VsdCk7CgkJZnJlZV9jb21taXRfbGlzdChyZXN1bHQpOwoJfQoKCXNlbmRfdW5zaGFsbG93KGRhdGEpOwp9CgpzdGF0aWMgdm9pZCBkZWVwZW5fYnlfcmV2X2xpc3Qoc3RydWN0IHVwbG9hZF9wYWNrX2RhdGEgKmRhdGEsCgkJCSAgICAgICBpbnQgYWMsCgkJCSAgICAgICBjb25zdCBjaGFyICoqYXYpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqcmVzdWx0OwoKCWRpc2FibGVfY29tbWl0X2dyYXBoKHRoZV9yZXBvc2l0b3J5KTsKCXJlc3VsdCA9IGdldF9zaGFsbG93X2NvbW1pdHNfYnlfcmV2X2xpc3QoYWMsIGF2LCBTSEFMTE9XLCBOT1RfU0hBTExPVyk7CglzZW5kX3NoYWxsb3coZGF0YSwgcmVzdWx0KTsKCWZyZWVfY29tbWl0X2xpc3QocmVzdWx0KTsKCXNlbmRfdW5zaGFsbG93KGRhdGEpOwp9CgovKiBSZXR1cm5zIDEgaWYgYSBzaGFsbG93IGxpc3QgaXMgc2VudCBvciAwIG90aGVyd2lzZSAqLwpzdGF0aWMgaW50IHNlbmRfc2hhbGxvd19saXN0KHN0cnVjdCB1cGxvYWRfcGFja19kYXRhICpkYXRhKQp7CglpbnQgcmV0ID0gMDsKCglpZiAoZGF0YS0+ZGVwdGggPiAwICYmIGRhdGEtPmRlZXBlbl9yZXZfbGlzdCkKCQlkaWUoImdpdCB1cGxvYWQtcGFjazogZGVlcGVuIGFuZCBkZWVwZW4tc2luY2UgKG9yIGRlZXBlbi1ub3QpIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIik7CglpZiAoZGF0YS0+ZGVwdGggPiAwKSB7CgkJZGVlcGVuKGRhdGEsIGRhdGEtPmRlcHRoKTsKCQlyZXQgPSAxOwoJfSBlbHNlIGlmIChkYXRhLT5kZWVwZW5fcmV2X2xpc3QpIHsKCQlzdHJ1Y3Qgc3RydmVjIGF2ID0gU1RSVkVDX0lOSVQ7CgkJaW50IGk7CgoJCXN0cnZlY19wdXNoKCZhdiwgInJldi1saXN0Iik7CgkJaWYgKGRhdGEtPmRlZXBlbl9zaW5jZSkKCQkJc3RydmVjX3B1c2hmKCZhdiwgIi0tbWF4LWFnZT0lIlBSSXRpbWUsIGRhdGEtPmRlZXBlbl9zaW5jZSk7CgkJaWYgKG9pZHNldF9zaXplKCZkYXRhLT5kZWVwZW5fbm90KSkgewoJCQljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQ7CgkJCXN0cnVjdCBvaWRzZXRfaXRlciBpdGVyOwoJCQlzdHJ2ZWNfcHVzaCgmYXYsICItLW5vdCIpOwoJCQlvaWRzZXRfaXRlcl9pbml0KCZkYXRhLT5kZWVwZW5fbm90LCAmaXRlcik7CgkJCXdoaWxlICgob2lkID0gb2lkc2V0X2l0ZXJfbmV4dCgmaXRlcikpKQoJCQkJc3RydmVjX3B1c2goJmF2LCBvaWRfdG9faGV4KG9pZCkpOwoJCQlzdHJ2ZWNfcHVzaCgmYXYsICItLW5vdCIpOwoJCX0KCQlmb3IgKGkgPSAwOyBpIDwgZGF0YS0+d2FudF9vYmoubnI7IGkrKykgewoJCQlzdHJ1Y3Qgb2JqZWN0ICpvID0gZGF0YS0+d2FudF9vYmoub2JqZWN0c1tpXS5pdGVtOwoJCQlzdHJ2ZWNfcHVzaCgmYXYsIG9pZF90b19oZXgoJm8tPm9pZCkpOwoJCX0KCQlkZWVwZW5fYnlfcmV2X2xpc3QoZGF0YSwgYXYubnIsIGF2LnYpOwoJCXN0cnZlY19jbGVhcigmYXYpOwoJCXJldCA9IDE7Cgl9IGVsc2UgewoJCWlmIChkYXRhLT5zaGFsbG93cy5uciA+IDApIHsKCQkJaW50IGk7CgkJCWZvciAoaSA9IDA7IGkgPCBkYXRhLT5zaGFsbG93cy5ucjsgaSsrKQoJCQkJcmVnaXN0ZXJfc2hhbGxvdyh0aGVfcmVwb3NpdG9yeSwKCQkJCQkJICZkYXRhLT5zaGFsbG93cy5vYmplY3RzW2ldLml0ZW0tPm9pZCk7CgkJfQoJfQoKCWRhdGEtPnNoYWxsb3dfbnIgKz0gZGF0YS0+c2hhbGxvd3MubnI7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IHByb2Nlc3Nfc2hhbGxvdyhjb25zdCBjaGFyICpsaW5lLCBzdHJ1Y3Qgb2JqZWN0X2FycmF5ICpzaGFsbG93cykKewoJY29uc3QgY2hhciAqYXJnOwoJaWYgKHNraXBfcHJlZml4KGxpbmUsICJzaGFsbG93ICIsICZhcmcpKSB7CgkJc3RydWN0IG9iamVjdF9pZCBvaWQ7CgkJc3RydWN0IG9iamVjdCAqb2JqZWN0OwoJCWlmIChnZXRfb2lkX2hleChhcmcsICZvaWQpKQoJCQlkaWUoImludmFsaWQgc2hhbGxvdyBsaW5lOiAlcyIsIGxpbmUpOwoJCW9iamVjdCA9IHBhcnNlX29iamVjdCh0aGVfcmVwb3NpdG9yeSwgJm9pZCk7CgkJaWYgKCFvYmplY3QpCgkJCXJldHVybiAxOwoJCWlmIChvYmplY3QtPnR5cGUgIT0gT0JKX0NPTU1JVCkKCQkJZGllKCJpbnZhbGlkIHNoYWxsb3cgb2JqZWN0ICVzIiwgb2lkX3RvX2hleCgmb2lkKSk7CgkJaWYgKCEob2JqZWN0LT5mbGFncyAmIENMSUVOVF9TSEFMTE9XKSkgewoJCQlvYmplY3QtPmZsYWdzIHw9IENMSUVOVF9TSEFMTE9XOwoJCQlhZGRfb2JqZWN0X2FycmF5KG9iamVjdCwgTlVMTCwgc2hhbGxvd3MpOwoJCX0KCQlyZXR1cm4gMTsKCX0KCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBwcm9jZXNzX2RlZXBlbihjb25zdCBjaGFyICpsaW5lLCBpbnQgKmRlcHRoKQp7Cgljb25zdCBjaGFyICphcmc7CglpZiAoc2tpcF9wcmVmaXgobGluZSwgImRlZXBlbiAiLCAmYXJnKSkgewoJCWNoYXIgKmVuZCA9IE5VTEw7CgkJKmRlcHRoID0gKGludClzdHJ0b2woYXJnLCAmZW5kLCAwKTsKCQlpZiAoIWVuZCB8fCAqZW5kIHx8ICpkZXB0aCA8PSAwKQoJCQlkaWUoIkludmFsaWQgZGVlcGVuOiAlcyIsIGxpbmUpOwoJCXJldHVybiAxOwoJfQoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHByb2Nlc3NfZGVlcGVuX3NpbmNlKGNvbnN0IGNoYXIgKmxpbmUsIHRpbWVzdGFtcF90ICpkZWVwZW5fc2luY2UsIGludCAqZGVlcGVuX3Jldl9saXN0KQp7Cgljb25zdCBjaGFyICphcmc7CglpZiAoc2tpcF9wcmVmaXgobGluZSwgImRlZXBlbi1zaW5jZSAiLCAmYXJnKSkgewoJCWNoYXIgKmVuZCA9IE5VTEw7CgkJKmRlZXBlbl9zaW5jZSA9IHBhcnNlX3RpbWVzdGFtcChhcmcsICZlbmQsIDApOwoJCWlmICghZW5kIHx8ICplbmQgfHwgIWRlZXBlbl9zaW5jZSB8fAoJCSAgICAvKiByZXZpc2lvbnMuYydzIG1heF9hZ2UgLTEgaXMgc3BlY2lhbCAqLwoJCSAgICAqZGVlcGVuX3NpbmNlID09IC0xKQoJCQlkaWUoIkludmFsaWQgZGVlcGVuLXNpbmNlOiAlcyIsIGxpbmUpOwoJCSpkZWVwZW5fcmV2X2xpc3QgPSAxOwoJCXJldHVybiAxOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgcHJvY2Vzc19kZWVwZW5fbm90KGNvbnN0IGNoYXIgKmxpbmUsIHN0cnVjdCBvaWRzZXQgKmRlZXBlbl9ub3QsIGludCAqZGVlcGVuX3Jldl9saXN0KQp7Cgljb25zdCBjaGFyICphcmc7CglpZiAoc2tpcF9wcmVmaXgobGluZSwgImRlZXBlbi1ub3QgIiwgJmFyZykpIHsKCQljaGFyICpyZWYgPSBOVUxMOwoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCWlmIChleHBhbmRfcmVmKHRoZV9yZXBvc2l0b3J5LCBhcmcsIHN0cmxlbihhcmcpLCAmb2lkLCAmcmVmKSAhPSAxKQoJCQlkaWUoImdpdCB1cGxvYWQtcGFjazogYW1iaWd1b3VzIGRlZXBlbi1ub3Q6ICVzIiwgbGluZSk7CgkJb2lkc2V0X2luc2VydChkZWVwZW5fbm90LCAmb2lkKTsKCQlmcmVlKHJlZik7CgkJKmRlZXBlbl9yZXZfbGlzdCA9IDE7CgkJcmV0dXJuIDE7Cgl9CglyZXR1cm4gMDsKfQoKTk9SRVRVUk4gX19hdHRyaWJ1dGVfXygoZm9ybWF0KHByaW50ZiwyLDMpKSkKc3RhdGljIHZvaWQgc2VuZF9lcnJfYW5kX2RpZShzdHJ1Y3QgdXBsb2FkX3BhY2tfZGF0YSAqZGF0YSwKCQkJICAgICBjb25zdCBjaGFyICpmbXQsIC4uLikKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCXZhX2xpc3QgYXA7CgoJdmFfc3RhcnQoYXAsIGZtdCk7CglzdHJidWZfdmFkZGYoJmJ1ZiwgZm10LCBhcCk7Cgl2YV9lbmQoYXApOwoKCXBhY2tldF93cml0ZXJfZXJyb3IoJmRhdGEtPndyaXRlciwgIiVzIiwgYnVmLmJ1Zik7CglkaWUoIiVzIiwgYnVmLmJ1Zik7Cn0KCnN0YXRpYyB2b2lkIGNoZWNrX29uZV9maWx0ZXIoc3RydWN0IHVwbG9hZF9wYWNrX2RhdGEgKmRhdGEsCgkJCSAgICAgc3RydWN0IGxpc3Rfb2JqZWN0c19maWx0ZXJfb3B0aW9ucyAqb3B0cykKewoJY29uc3QgY2hhciAqa2V5ID0gbGlzdF9vYmplY3RfZmlsdGVyX2NvbmZpZ19uYW1lKG9wdHMtPmNob2ljZSk7CglzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbSA9IHN0cmluZ19saXN0X2xvb2t1cCgmZGF0YS0+YWxsb3dlZF9maWx0ZXJzLAoJCQkJCQkJICAga2V5KTsKCWludCBhbGxvd2VkOwoKCWlmIChpdGVtKQoJCWFsbG93ZWQgPSAoaW50cHRyX3QpaXRlbS0+dXRpbDsKCWVsc2UKCQlhbGxvd2VkID0gZGF0YS0+YWxsb3dfZmlsdGVyX2ZhbGxiYWNrOwoKCWlmICghYWxsb3dlZCkKCQlzZW5kX2Vycl9hbmRfZGllKGRhdGEsICJmaWx0ZXIgJyVzJyBub3Qgc3VwcG9ydGVkIiwga2V5KTsKCglpZiAob3B0cy0+Y2hvaWNlID09IExPRkNfVFJFRV9ERVBUSCAmJgoJICAgIG9wdHMtPnRyZWVfZXhjbHVkZV9kZXB0aCA+IGRhdGEtPnRyZWVfZmlsdGVyX21heF9kZXB0aCkKCQlzZW5kX2Vycl9hbmRfZGllKGRhdGEsCgkJCQkgInRyZWUgZmlsdGVyIGFsbG93cyBtYXggZGVwdGggJWx1LCBidXQgZ290ICVsdSIsCgkJCQkgZGF0YS0+dHJlZV9maWx0ZXJfbWF4X2RlcHRoLAoJCQkJIG9wdHMtPnRyZWVfZXhjbHVkZV9kZXB0aCk7Cn0KCnN0YXRpYyB2b2lkIGNoZWNrX2ZpbHRlcl9yZWN1cnNlKHN0cnVjdCB1cGxvYWRfcGFja19kYXRhICpkYXRhLAoJCQkJIHN0cnVjdCBsaXN0X29iamVjdHNfZmlsdGVyX29wdGlvbnMgKm9wdHMpCnsKCXNpemVfdCBpOwoKCWNoZWNrX29uZV9maWx0ZXIoZGF0YSwgb3B0cyk7CglpZiAob3B0cy0+Y2hvaWNlICE9IExPRkNfQ09NQklORSkKCQlyZXR1cm47CgoJZm9yIChpID0gMDsgaSA8IG9wdHMtPnN1Yl9ucjsgaSsrKQoJCWNoZWNrX2ZpbHRlcl9yZWN1cnNlKGRhdGEsICZvcHRzLT5zdWJbaV0pOwp9CgpzdGF0aWMgdm9pZCBkaWVfaWZfdXNpbmdfYmFubmVkX2ZpbHRlcihzdHJ1Y3QgdXBsb2FkX3BhY2tfZGF0YSAqZGF0YSkKewoJY2hlY2tfZmlsdGVyX3JlY3Vyc2UoZGF0YSwgJmRhdGEtPmZpbHRlcl9vcHRpb25zKTsKfQoKc3RhdGljIHZvaWQgcmVjZWl2ZV9uZWVkcyhzdHJ1Y3QgdXBsb2FkX3BhY2tfZGF0YSAqZGF0YSwKCQkJICBzdHJ1Y3QgcGFja2V0X3JlYWRlciAqcmVhZGVyKQp7CglpbnQgaGFzX25vbl90aXAgPSAwOwoKCWRhdGEtPnNoYWxsb3dfbnIgPSAwOwoJZm9yICg7OykgewoJCXN0cnVjdCBvYmplY3QgKm87CgkJY29uc3QgY2hhciAqZmVhdHVyZXM7CgkJc3RydWN0IG9iamVjdF9pZCBvaWRfYnVmOwoJCWNvbnN0IGNoYXIgKmFyZzsKCQlzaXplX3QgZmVhdHVyZV9sZW47CgoJCXJlc2V0X3RpbWVvdXQoZGF0YS0+dGltZW91dCk7CgkJaWYgKHBhY2tldF9yZWFkZXJfcmVhZChyZWFkZXIpICE9IFBBQ0tFVF9SRUFEX05PUk1BTCkKCQkJYnJlYWs7CgoJCWlmIChwcm9jZXNzX3NoYWxsb3cocmVhZGVyLT5saW5lLCAmZGF0YS0+c2hhbGxvd3MpKQoJCQljb250aW51ZTsKCQlpZiAocHJvY2Vzc19kZWVwZW4ocmVhZGVyLT5saW5lLCAmZGF0YS0+ZGVwdGgpKQoJCQljb250aW51ZTsKCQlpZiAocHJvY2Vzc19kZWVwZW5fc2luY2UocmVhZGVyLT5saW5lLCAmZGF0YS0+ZGVlcGVuX3NpbmNlLCAmZGF0YS0+ZGVlcGVuX3Jldl9saXN0KSkKCQkJY29udGludWU7CgkJaWYgKHByb2Nlc3NfZGVlcGVuX25vdChyZWFkZXItPmxpbmUsICZkYXRhLT5kZWVwZW5fbm90LCAmZGF0YS0+ZGVlcGVuX3Jldl9saXN0KSkKCQkJY29udGludWU7CgoJCWlmIChza2lwX3ByZWZpeChyZWFkZXItPmxpbmUsICJmaWx0ZXIgIiwgJmFyZykpIHsKCQkJaWYgKCFkYXRhLT5maWx0ZXJfY2FwYWJpbGl0eV9yZXF1ZXN0ZWQpCgkJCQlkaWUoImdpdCB1cGxvYWQtcGFjazogZmlsdGVyaW5nIGNhcGFiaWxpdHkgbm90IG5lZ290aWF0ZWQiKTsKCQkJbGlzdF9vYmplY3RzX2ZpbHRlcl9kaWVfaWZfcG9wdWxhdGVkKCZkYXRhLT5maWx0ZXJfb3B0aW9ucyk7CgkJCXBhcnNlX2xpc3Rfb2JqZWN0c19maWx0ZXIoJmRhdGEtPmZpbHRlcl9vcHRpb25zLCBhcmcpOwoJCQlkaWVfaWZfdXNpbmdfYmFubmVkX2ZpbHRlcihkYXRhKTsKCQkJY29udGludWU7CgkJfQoKCQlpZiAoIXNraXBfcHJlZml4KHJlYWRlci0+bGluZSwgIndhbnQgIiwgJmFyZykgfHwKCQkgICAgcGFyc2Vfb2lkX2hleChhcmcsICZvaWRfYnVmLCAmZmVhdHVyZXMpKQoJCQlkaWUoImdpdCB1cGxvYWQtcGFjazogcHJvdG9jb2wgZXJyb3IsICIKCQkJICAgICJleHBlY3RlZCB0byBnZXQgb2JqZWN0IElELCBub3QgJyVzJyIsIHJlYWRlci0+bGluZSk7CgoJCWlmIChwYXJzZV9mZWF0dXJlX3JlcXVlc3QoZmVhdHVyZXMsICJkZWVwZW4tcmVsYXRpdmUiKSkKCQkJZGF0YS0+ZGVlcGVuX3JlbGF0aXZlID0gMTsKCQlpZiAocGFyc2VfZmVhdHVyZV9yZXF1ZXN0KGZlYXR1cmVzLCAibXVsdGlfYWNrX2RldGFpbGVkIikpCgkJCWRhdGEtPm11bHRpX2FjayA9IE1VTFRJX0FDS19ERVRBSUxFRDsKCQllbHNlIGlmIChwYXJzZV9mZWF0dXJlX3JlcXVlc3QoZmVhdHVyZXMsICJtdWx0aV9hY2siKSkKCQkJZGF0YS0+bXVsdGlfYWNrID0gTVVMVElfQUNLOwoJCWlmIChwYXJzZV9mZWF0dXJlX3JlcXVlc3QoZmVhdHVyZXMsICJuby1kb25lIikpCgkJCWRhdGEtPm5vX2RvbmUgPSAxOwoJCWlmIChwYXJzZV9mZWF0dXJlX3JlcXVlc3QoZmVhdHVyZXMsICJ0aGluLXBhY2siKSkKCQkJZGF0YS0+dXNlX3RoaW5fcGFjayA9IDE7CgkJaWYgKHBhcnNlX2ZlYXR1cmVfcmVxdWVzdChmZWF0dXJlcywgIm9mcy1kZWx0YSIpKQoJCQlkYXRhLT51c2Vfb2ZzX2RlbHRhID0gMTsKCQlpZiAocGFyc2VfZmVhdHVyZV9yZXF1ZXN0KGZlYXR1cmVzLCAic2lkZS1iYW5kLTY0ayIpKQoJCQlkYXRhLT51c2Vfc2lkZWJhbmQgPSBMQVJHRV9QQUNLRVRfTUFYOwoJCWVsc2UgaWYgKHBhcnNlX2ZlYXR1cmVfcmVxdWVzdChmZWF0dXJlcywgInNpZGUtYmFuZCIpKQoJCQlkYXRhLT51c2Vfc2lkZWJhbmQgPSBERUZBVUxUX1BBQ0tFVF9NQVg7CgkJaWYgKHBhcnNlX2ZlYXR1cmVfcmVxdWVzdChmZWF0dXJlcywgIm5vLXByb2dyZXNzIikpCgkJCWRhdGEtPm5vX3Byb2dyZXNzID0gMTsKCQlpZiAocGFyc2VfZmVhdHVyZV9yZXF1ZXN0KGZlYXR1cmVzLCAiaW5jbHVkZS10YWciKSkKCQkJZGF0YS0+dXNlX2luY2x1ZGVfdGFnID0gMTsKCQlpZiAoZGF0YS0+YWxsb3dfZmlsdGVyICYmCgkJICAgIHBhcnNlX2ZlYXR1cmVfcmVxdWVzdChmZWF0dXJlcywgImZpbHRlciIpKQoJCQlkYXRhLT5maWx0ZXJfY2FwYWJpbGl0eV9yZXF1ZXN0ZWQgPSAxOwoKCQlhcmcgPSBwYXJzZV9mZWF0dXJlX3ZhbHVlKGZlYXR1cmVzLCAic2Vzc2lvbi1pZCIsICZmZWF0dXJlX2xlbiwgTlVMTCk7CgkJaWYgKGFyZykgewoJCQljaGFyICpjbGllbnRfc2lkID0geHN0cm5kdXAoYXJnLCBmZWF0dXJlX2xlbik7CgkJCXRyYWNlMl9kYXRhX3N0cmluZygidHJhbnNmZXIiLCBOVUxMLCAiY2xpZW50LXNpZCIsIGNsaWVudF9zaWQpOwoJCQlmcmVlKGNsaWVudF9zaWQpOwoJCX0KCgkJbyA9IHBhcnNlX29iamVjdF93aXRoX2ZsYWdzKHRoZV9yZXBvc2l0b3J5LCAmb2lkX2J1ZiwKCQkJCQkgICAgUEFSU0VfT0JKRUNUX1NLSVBfSEFTSF9DSEVDSyB8CgkJCQkJICAgIFBBUlNFX09CSkVDVF9ESVNDQVJEX1RSRUUpOwoJCWlmICghbykgewoJCQlwYWNrZXRfd3JpdGVyX2Vycm9yKCZkYXRhLT53cml0ZXIsCgkJCQkJICAgICJ1cGxvYWQtcGFjazogbm90IG91ciByZWYgJXMiLAoJCQkJCSAgICBvaWRfdG9faGV4KCZvaWRfYnVmKSk7CgkJCWRpZSgiZ2l0IHVwbG9hZC1wYWNrOiBub3Qgb3VyIHJlZiAlcyIsCgkJCSAgICBvaWRfdG9faGV4KCZvaWRfYnVmKSk7CgkJfQoJCWlmICghKG8tPmZsYWdzICYgV0FOVEVEKSkgewoJCQlvLT5mbGFncyB8PSBXQU5URUQ7CgkJCWlmICghKChkYXRhLT5hbGxvd191b3IgJiBBTExPV19BTllfU0hBMSkgPT0gQUxMT1dfQU5ZX1NIQTEKCQkJICAgICAgfHwgaXNfb3VyX3JlZihvLCBkYXRhLT5hbGxvd191b3IpKSkKCQkJCWhhc19ub25fdGlwID0gMTsKCQkJYWRkX29iamVjdF9hcnJheShvLCBOVUxMLCAmZGF0YS0+d2FudF9vYmopOwoJCX0KCX0KCgkvKgoJICogV2UgaGF2ZSBzZW50IGFsbCBvdXIgcmVmcyBhbHJlYWR5LCBhbmQgdGhlIG90aGVyIGVuZAoJICogc2hvdWxkIGhhdmUgY2hvc2VuIG91dCBvZiB0aGVtLiBXaGVuIHdlIGFyZSBvcGVyYXRpbmcKCSAqIGluIHRoZSBzdGF0ZWxlc3MgUlBDIG1vZGUsIGhvd2V2ZXIsIHRoZWlyIGNob2ljZSBtYXkKCSAqIGhhdmUgYmVlbiBiYXNlZCBvbiB0aGUgc2V0IG9mIG9sZGVyIHJlZnMgYWR2ZXJ0aXNlZAoJICogYnkgYW5vdGhlciBwcm9jZXNzIHRoYXQgaGFuZGxlZCB0aGUgaW5pdGlhbCByZXF1ZXN0LgoJICovCglpZiAoaGFzX25vbl90aXApCgkJY2hlY2tfbm9uX3RpcChkYXRhKTsKCglpZiAoIWRhdGEtPnVzZV9zaWRlYmFuZCAmJiBkYXRhLT5kYWVtb25fbW9kZSkKCQlkYXRhLT5ub19wcm9ncmVzcyA9IDE7CgoJaWYgKGRhdGEtPmRlcHRoID09IDAgJiYgIWRhdGEtPmRlZXBlbl9yZXZfbGlzdCAmJiBkYXRhLT5zaGFsbG93cy5uciA9PSAwKQoJCXJldHVybjsKCglpZiAoc2VuZF9zaGFsbG93X2xpc3QoZGF0YSkpCgkJcGFja2V0X2ZsdXNoKDEpOwp9CgovKiByZXR1cm4gbm9uLXplcm8gaWYgdGhlIHJlZiBpcyBoaWRkZW4sIG90aGVyd2lzZSAwICovCnN0YXRpYyBpbnQgbWFya19vdXJfcmVmKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IGNoYXIgKnJlZm5hbWVfZnVsbCwKCQkJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBjb25zdCBzdHJ1Y3Qgc3RydmVjICpoaWRkZW5fcmVmcykKewoJc3RydWN0IG9iamVjdCAqbyA9IGxvb2t1cF91bmtub3duX29iamVjdCh0aGVfcmVwb3NpdG9yeSwgb2lkKTsKCglpZiAocmVmX2lzX2hpZGRlbihyZWZuYW1lLCByZWZuYW1lX2Z1bGwsIGhpZGRlbl9yZWZzKSkgewoJCW8tPmZsYWdzIHw9IEhJRERFTl9SRUY7CgkJcmV0dXJuIDE7Cgl9CglvLT5mbGFncyB8PSBPVVJfUkVGOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgY2hlY2tfcmVmKGNvbnN0IGNoYXIgKnJlZm5hbWVfZnVsbCwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCSAgICAgaW50IGZsYWcgVU5VU0VELCB2b2lkICpjYl9kYXRhKQp7Cgljb25zdCBjaGFyICpyZWZuYW1lID0gc3RyaXBfbmFtZXNwYWNlKHJlZm5hbWVfZnVsbCk7CglzdHJ1Y3QgdXBsb2FkX3BhY2tfZGF0YSAqZGF0YSA9IGNiX2RhdGE7CgoJbWFya19vdXJfcmVmKHJlZm5hbWUsIHJlZm5hbWVfZnVsbCwgb2lkLCAmZGF0YS0+aGlkZGVuX3JlZnMpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGZvcm1hdF9zeW1yZWZfaW5mbyhzdHJ1Y3Qgc3RyYnVmICpidWYsIHN0cnVjdCBzdHJpbmdfbGlzdCAqc3ltcmVmKQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbTsKCglpZiAoIXN5bXJlZi0+bnIpCgkJcmV0dXJuOwoJZm9yX2VhY2hfc3RyaW5nX2xpc3RfaXRlbShpdGVtLCBzeW1yZWYpCgkJc3RyYnVmX2FkZGYoYnVmLCAiIHN5bXJlZj0lczolcyIsIGl0ZW0tPnN0cmluZywgKGNoYXIgKilpdGVtLT51dGlsKTsKfQoKc3RhdGljIHZvaWQgZm9ybWF0X3Nlc3Npb25faWQoc3RydWN0IHN0cmJ1ZiAqYnVmLCBzdHJ1Y3QgdXBsb2FkX3BhY2tfZGF0YSAqZCkgewoJaWYgKGQtPmFkdmVydGlzZV9zaWQpCgkJc3RyYnVmX2FkZGYoYnVmLCAiIHNlc3Npb24taWQ9JXMiLCB0cmFjZTJfc2Vzc2lvbl9pZCgpKTsKfQoKc3RhdGljIHZvaWQgd3JpdGVfdjBfcmVmKHN0cnVjdCB1cGxvYWRfcGFja19kYXRhICpkYXRhLAoJCQljb25zdCBjaGFyICpyZWZuYW1lLCBjb25zdCBjaGFyICpyZWZuYW1lX25vbnMsCgkJCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJc3RhdGljIGNvbnN0IGNoYXIgKmNhcGFiaWxpdGllcyA9ICJtdWx0aV9hY2sgdGhpbi1wYWNrIHNpZGUtYmFuZCIKCQkiIHNpZGUtYmFuZC02NGsgb2ZzLWRlbHRhIHNoYWxsb3cgZGVlcGVuLXNpbmNlIGRlZXBlbi1ub3QiCgkJIiBkZWVwZW4tcmVsYXRpdmUgbm8tcHJvZ3Jlc3MgaW5jbHVkZS10YWcgbXVsdGlfYWNrX2RldGFpbGVkIjsKCXN0cnVjdCBvYmplY3RfaWQgcGVlbGVkOwoKCWlmIChtYXJrX291cl9yZWYocmVmbmFtZV9ub25zLCByZWZuYW1lLCBvaWQsICZkYXRhLT5oaWRkZW5fcmVmcykpCgkJcmV0dXJuOwoKCWlmIChjYXBhYmlsaXRpZXMpIHsKCQlzdHJ1Y3Qgc3RyYnVmIHN5bXJlZl9pbmZvID0gU1RSQlVGX0lOSVQ7CgkJc3RydWN0IHN0cmJ1ZiBzZXNzaW9uX2lkID0gU1RSQlVGX0lOSVQ7CgoJCWZvcm1hdF9zeW1yZWZfaW5mbygmc3ltcmVmX2luZm8sICZkYXRhLT5zeW1yZWYpOwoJCWZvcm1hdF9zZXNzaW9uX2lkKCZzZXNzaW9uX2lkLCBkYXRhKTsKCQlwYWNrZXRfZndyaXRlX2ZtdChzdGRvdXQsICIlcyAlcyVjJXMlcyVzJXMlcyVzJXMgb2JqZWN0LWZvcm1hdD0lcyBhZ2VudD0lc1xuIiwKCQkJICAgICBvaWRfdG9faGV4KG9pZCksIHJlZm5hbWVfbm9ucywKCQkJICAgICAwLCBjYXBhYmlsaXRpZXMsCgkJCSAgICAgKGRhdGEtPmFsbG93X3VvciAmIEFMTE9XX1RJUF9TSEExKSA/CgkJCQkgICAgICIgYWxsb3ctdGlwLXNoYTEtaW4td2FudCIgOiAiIiwKCQkJICAgICAoZGF0YS0+YWxsb3dfdW9yICYgQUxMT1dfUkVBQ0hBQkxFX1NIQTEpID8KCQkJCSAgICAgIiBhbGxvdy1yZWFjaGFibGUtc2hhMS1pbi13YW50IiA6ICIiLAoJCQkgICAgIGRhdGEtPm5vX2RvbmUgPyAiIG5vLWRvbmUiIDogIiIsCgkJCSAgICAgc3ltcmVmX2luZm8uYnVmLAoJCQkgICAgIGRhdGEtPmFsbG93X2ZpbHRlciA/ICIgZmlsdGVyIiA6ICIiLAoJCQkgICAgIHNlc3Npb25faWQuYnVmLAoJCQkgICAgIHRoZV9oYXNoX2FsZ28tPm5hbWUsCgkJCSAgICAgZ2l0X3VzZXJfYWdlbnRfc2FuaXRpemVkKCkpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZzeW1yZWZfaW5mbyk7CgkJc3RyYnVmX3JlbGVhc2UoJnNlc3Npb25faWQpOwoJCWRhdGEtPnNlbnRfY2FwYWJpbGl0aWVzID0gMTsKCX0gZWxzZSB7CgkJcGFja2V0X2Z3cml0ZV9mbXQoc3Rkb3V0LCAiJXMgJXNcbiIsIG9pZF90b19oZXgob2lkKSwgcmVmbmFtZV9ub25zKTsKCX0KCWNhcGFiaWxpdGllcyA9IE5VTEw7CglpZiAoIXBlZWxfaXRlcmF0ZWRfb2lkKHRoZV9yZXBvc2l0b3J5LCBvaWQsICZwZWVsZWQpKQoJCXBhY2tldF9md3JpdGVfZm10KHN0ZG91dCwgIiVzICVzXnt9XG4iLCBvaWRfdG9faGV4KCZwZWVsZWQpLCByZWZuYW1lX25vbnMpOwoJcmV0dXJuOwp9CgpzdGF0aWMgaW50IHNlbmRfcmVmKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkgICAgaW50IGZsYWcgVU5VU0VELCB2b2lkICpjYl9kYXRhKQp7Cgl3cml0ZV92MF9yZWYoY2JfZGF0YSwgcmVmbmFtZSwgc3RyaXBfbmFtZXNwYWNlKHJlZm5hbWUpLCBvaWQpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZmluZF9zeW1yZWYoY29uc3QgY2hhciAqcmVmbmFtZSwKCQkgICAgICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkIFVOVVNFRCwKCQkgICAgICAgaW50IGZsYWcsIHZvaWQgKmNiX2RhdGEpCnsKCWNvbnN0IGNoYXIgKnN5bXJlZl90YXJnZXQ7CglzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbTsKCglpZiAoKGZsYWcgJiBSRUZfSVNTWU1SRUYpID09IDApCgkJcmV0dXJuIDA7CglzeW1yZWZfdGFyZ2V0ID0gcmVmc19yZXNvbHZlX3JlZl91bnNhZmUoZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KSwKCQkJCQkJcmVmbmFtZSwgMCwgTlVMTCwgJmZsYWcpOwoJaWYgKCFzeW1yZWZfdGFyZ2V0IHx8IChmbGFnICYgUkVGX0lTU1lNUkVGKSA9PSAwKQoJCWRpZSgiJyVzJyBpcyBhIHN5bXJlZiBidXQgaXQgaXMgbm90PyIsIHJlZm5hbWUpOwoJaXRlbSA9IHN0cmluZ19saXN0X2FwcGVuZChjYl9kYXRhLCBzdHJpcF9uYW1lc3BhY2UocmVmbmFtZSkpOwoJaXRlbS0+dXRpbCA9IHhzdHJkdXAoc3RyaXBfbmFtZXNwYWNlKHN5bXJlZl90YXJnZXQpKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHBhcnNlX29iamVjdF9maWx0ZXJfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsCgkJCQkgICAgICBjb25zdCBzdHJ1Y3Qga2V5X3ZhbHVlX2luZm8gKmt2aSwKCQkJCSAgICAgIHN0cnVjdCB1cGxvYWRfcGFja19kYXRhICpkYXRhKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJY29uc3QgY2hhciAqc3ViLCAqa2V5OwoJc2l6ZV90IHN1Yl9sZW47CgoJaWYgKHBhcnNlX2NvbmZpZ19rZXkodmFyLCAidXBsb2FkcGFja2ZpbHRlciIsICZzdWIsICZzdWJfbGVuLCAma2V5KSkKCQlyZXR1cm4gMDsKCglpZiAoIXN1YikgewoJCWlmICghc3RyY21wKGtleSwgImFsbG93IikpCgkJCWRhdGEtPmFsbG93X2ZpbHRlcl9mYWxsYmFjayA9IGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCglzdHJidWZfYWRkKCZidWYsIHN1Yiwgc3ViX2xlbik7CgoJaWYgKCFzdHJjbXAoa2V5LCAiYWxsb3ciKSkKCQlzdHJpbmdfbGlzdF9pbnNlcnQoJmRhdGEtPmFsbG93ZWRfZmlsdGVycywgYnVmLmJ1ZiktPnV0aWwgPQoJCQkodm9pZCAqKShpbnRwdHJfdClnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7CgllbHNlIGlmICghc3RyY21wKGJ1Zi5idWYsICJ0cmVlIikgJiYgIXN0cmNtcChrZXksICJtYXhkZXB0aCIpKSB7CgkJaWYgKCF2YWx1ZSkgewoJCQlzdHJidWZfcmVsZWFzZSgmYnVmKTsKCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKHZhcik7CgkJfQoJCXN0cmluZ19saXN0X2luc2VydCgmZGF0YS0+YWxsb3dlZF9maWx0ZXJzLCBidWYuYnVmKS0+dXRpbCA9CgkJCSh2b2lkICopKGludHB0cl90KTE7CgkJZGF0YS0+dHJlZV9maWx0ZXJfbWF4X2RlcHRoID0gZ2l0X2NvbmZpZ191bG9uZyh2YXIsIHZhbHVlLAoJCQkJCQkJICAgICAgIGt2aSk7Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCB1cGxvYWRfcGFja19jb25maWcoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSwKCQkJICAgICAgY29uc3Qgc3RydWN0IGNvbmZpZ19jb250ZXh0ICpjdHgsCgkJCSAgICAgIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCB1cGxvYWRfcGFja19kYXRhICpkYXRhID0gY2JfZGF0YTsKCglpZiAoIXN0cmNtcCgidXBsb2FkcGFjay5hbGxvd3RpcHNoYTFpbndhbnQiLCB2YXIpKSB7CgkJaWYgKGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKSkKCQkJZGF0YS0+YWxsb3dfdW9yIHw9IEFMTE9XX1RJUF9TSEExOwoJCWVsc2UKCQkJZGF0YS0+YWxsb3dfdW9yICY9IH5BTExPV19USVBfU0hBMTsKCX0gZWxzZSBpZiAoIXN0cmNtcCgidXBsb2FkcGFjay5hbGxvd3JlYWNoYWJsZXNoYTFpbndhbnQiLCB2YXIpKSB7CgkJaWYgKGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKSkKCQkJZGF0YS0+YWxsb3dfdW9yIHw9IEFMTE9XX1JFQUNIQUJMRV9TSEExOwoJCWVsc2UKCQkJZGF0YS0+YWxsb3dfdW9yICY9IH5BTExPV19SRUFDSEFCTEVfU0hBMTsKCX0gZWxzZSBpZiAoIXN0cmNtcCgidXBsb2FkcGFjay5hbGxvd2FueXNoYTFpbndhbnQiLCB2YXIpKSB7CgkJaWYgKGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKSkKCQkJZGF0YS0+YWxsb3dfdW9yIHw9IEFMTE9XX0FOWV9TSEExOwoJCWVsc2UKCQkJZGF0YS0+YWxsb3dfdW9yICY9IH5BTExPV19BTllfU0hBMTsKCX0gZWxzZSBpZiAoIXN0cmNtcCgidXBsb2FkcGFjay5rZWVwYWxpdmUiLCB2YXIpKSB7CgkJZGF0YS0+a2VlcGFsaXZlID0gZ2l0X2NvbmZpZ19pbnQodmFyLCB2YWx1ZSwgY3R4LT5rdmkpOwoJCWlmICghZGF0YS0+a2VlcGFsaXZlKQoJCQlkYXRhLT5rZWVwYWxpdmUgPSAtMTsKCX0gZWxzZSBpZiAoIXN0cmNtcCgidXBsb2FkcGFjay5hbGxvd2ZpbHRlciIsIHZhcikpIHsKCQlkYXRhLT5hbGxvd19maWx0ZXIgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7Cgl9IGVsc2UgaWYgKCFzdHJjbXAoInVwbG9hZHBhY2suYWxsb3dyZWZpbndhbnQiLCB2YXIpKSB7CgkJZGF0YS0+YWxsb3dfcmVmX2luX3dhbnQgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7Cgl9IGVsc2UgaWYgKCFzdHJjbXAoInVwbG9hZHBhY2suYWxsb3dzaWRlYmFuZGFsbCIsIHZhcikpIHsKCQlkYXRhLT5hbGxvd19zaWRlYmFuZF9hbGwgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7Cgl9IGVsc2UgaWYgKCFzdHJjbXAoInVwbG9hZHBhY2suYmxvYnBhY2tmaWxldXJpIiwgdmFyKSkgewoJCWlmICh2YWx1ZSkKCQkJZGF0YS0+YWxsb3dfcGFja2ZpbGVfdXJpcyA9IDE7Cgl9IGVsc2UgaWYgKCFzdHJjbXAoImNvcmUucHJlY29tcG9zZXVuaWNvZGUiLCB2YXIpKSB7CgkJcHJlY29tcG9zZWRfdW5pY29kZSA9IGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKTsKCX0gZWxzZSBpZiAoIXN0cmNtcCgidHJhbnNmZXIuYWR2ZXJ0aXNlc2lkIiwgdmFyKSkgewoJCWRhdGEtPmFkdmVydGlzZV9zaWQgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7Cgl9CgoJaWYgKHBhcnNlX29iamVjdF9maWx0ZXJfY29uZmlnKHZhciwgdmFsdWUsIGN0eC0+a3ZpLCBkYXRhKSA8IDApCgkJcmV0dXJuIC0xOwoKCXJldHVybiBwYXJzZV9oaWRlX3JlZnNfY29uZmlnKHZhciwgdmFsdWUsICJ1cGxvYWRwYWNrIiwgJmRhdGEtPmhpZGRlbl9yZWZzKTsKfQoKc3RhdGljIGludCB1cGxvYWRfcGFja19wcm90ZWN0ZWRfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsCgkJCQkJY29uc3Qgc3RydWN0IGNvbmZpZ19jb250ZXh0ICpjdHggVU5VU0VELAoJCQkJCXZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCB1cGxvYWRfcGFja19kYXRhICpkYXRhID0gY2JfZGF0YTsKCglpZiAoIXN0cmNtcCgidXBsb2FkcGFjay5wYWNrb2JqZWN0c2hvb2siLCB2YXIpKQoJCXJldHVybiBnaXRfY29uZmlnX3N0cmluZygmZGF0YS0+cGFja19vYmplY3RzX2hvb2ssIHZhciwgdmFsdWUpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGdldF91cGxvYWRfcGFja19jb25maWcoc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCQkgICBzdHJ1Y3QgdXBsb2FkX3BhY2tfZGF0YSAqZGF0YSkKewoJcmVwb19jb25maWcociwgdXBsb2FkX3BhY2tfY29uZmlnLCBkYXRhKTsKCWdpdF9wcm90ZWN0ZWRfY29uZmlnKHVwbG9hZF9wYWNrX3Byb3RlY3RlZF9jb25maWcsIGRhdGEpOwoKCWRhdGEtPmFsbG93X3NpZGViYW5kX2FsbCB8PSBnaXRfZW52X2Jvb2woIkdJVF9URVNUX1NJREVCQU5EX0FMTCIsIDApOwp9Cgp2b2lkIHVwbG9hZF9wYWNrKGNvbnN0IGludCBhZHZlcnRpc2VfcmVmcywgY29uc3QgaW50IHN0YXRlbGVzc19ycGMsCgkJIGNvbnN0IGludCB0aW1lb3V0KQp7CglzdHJ1Y3QgcGFja2V0X3JlYWRlciByZWFkZXI7CglzdHJ1Y3QgdXBsb2FkX3BhY2tfZGF0YSBkYXRhOwoKCXVwbG9hZF9wYWNrX2RhdGFfaW5pdCgmZGF0YSk7CglnZXRfdXBsb2FkX3BhY2tfY29uZmlnKHRoZV9yZXBvc2l0b3J5LCAmZGF0YSk7CgoJZGF0YS5zdGF0ZWxlc3NfcnBjID0gc3RhdGVsZXNzX3JwYzsKCWRhdGEudGltZW91dCA9IHRpbWVvdXQ7CglpZiAoZGF0YS50aW1lb3V0KQoJCWRhdGEuZGFlbW9uX21vZGUgPSAxOwoKCXJlZnNfaGVhZF9yZWZfbmFtZXNwYWNlZChnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLAoJCQkJIGZpbmRfc3ltcmVmLCAmZGF0YS5zeW1yZWYpOwoKCWlmIChhZHZlcnRpc2VfcmVmcyB8fCAhZGF0YS5zdGF0ZWxlc3NfcnBjKSB7CgkJcmVzZXRfdGltZW91dChkYXRhLnRpbWVvdXQpOwoJCWlmIChhZHZlcnRpc2VfcmVmcykKCQkJZGF0YS5ub19kb25lID0gMTsKCQlyZWZzX2hlYWRfcmVmX25hbWVzcGFjZWQoZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KSwKCQkJCQkgc2VuZF9yZWYsICZkYXRhKTsKCQlmb3JfZWFjaF9uYW1lc3BhY2VkX3JlZl8xKHNlbmRfcmVmLCAmZGF0YSk7CgkJaWYgKCFkYXRhLnNlbnRfY2FwYWJpbGl0aWVzKSB7CgkJCWNvbnN0IGNoYXIgKnJlZm5hbWUgPSAiY2FwYWJpbGl0aWVzXnt9IjsKCQkJd3JpdGVfdjBfcmVmKCZkYXRhLCByZWZuYW1lLCByZWZuYW1lLCBudWxsX29pZCgpKTsKCQl9CgkJLyoKCQkgKiBmZmx1c2ggc3Rkb3V0IGJlZm9yZSBjYWxsaW5nIGFkdmVydGlzZV9zaGFsbG93X2dyYWZ0cyBiZWNhdXNlIHNlbmRfcmVmCgkJICogdXNlcyBzdGRpby4KCQkgKi8KCQlmZmx1c2hfb3JfZGllKHN0ZG91dCk7CgkJYWR2ZXJ0aXNlX3NoYWxsb3dfZ3JhZnRzKDEpOwoJCXBhY2tldF9mbHVzaCgxKTsKCX0gZWxzZSB7CgkJcmVmc19oZWFkX3JlZl9uYW1lc3BhY2VkKGdldF9tYWluX3JlZl9zdG9yZSh0aGVfcmVwb3NpdG9yeSksCgkJCQkJIGNoZWNrX3JlZiwgJmRhdGEpOwoJCWZvcl9lYWNoX25hbWVzcGFjZWRfcmVmXzEoY2hlY2tfcmVmLCAmZGF0YSk7Cgl9CgoJaWYgKCFhZHZlcnRpc2VfcmVmcykgewoJCXBhY2tldF9yZWFkZXJfaW5pdCgmcmVhZGVyLCAwLCBOVUxMLCAwLAoJCQkJICAgUEFDS0VUX1JFQURfQ0hPTVBfTkVXTElORSB8CgkJCQkgICBQQUNLRVRfUkVBRF9ESUVfT05fRVJSX1BBQ0tFVCk7CgoJCXJlY2VpdmVfbmVlZHMoJmRhdGEsICZyZWFkZXIpOwoKCQkvKgoJCSAqIEFuIEVPRiBhdCB0aGlzIGV4YWN0IHBvaW50IGluIG5lZ290aWF0aW9uIHNob3VsZCBiZQoJCSAqIGFjY2VwdGFibGUgZnJvbSBzdGF0ZWxlc3MgY2xpZW50cyBhcyB0aGV5IHdpbGwgY29uc3VtZSB0aGUKCQkgKiBzaGFsbG93IGxpc3QgYmVmb3JlIGRvaW5nIHN1YnNlcXVlbnQgcnBjIHdpdGggaGF2ZXMvZXRjLgoJCSAqLwoJCWlmIChkYXRhLnN0YXRlbGVzc19ycGMpCgkJCXJlYWRlci5vcHRpb25zIHw9IFBBQ0tFVF9SRUFEX0dFTlRMRV9PTl9FT0Y7CgoJCWlmIChkYXRhLndhbnRfb2JqLm5yICYmCgkJICAgIHBhY2tldF9yZWFkZXJfcGVlaygmcmVhZGVyKSAhPSBQQUNLRVRfUkVBRF9FT0YpIHsKCQkJcmVhZGVyLm9wdGlvbnMgJj0gflBBQ0tFVF9SRUFEX0dFTlRMRV9PTl9FT0Y7CgkJCWdldF9jb21tb25fY29tbWl0cygmZGF0YSwgJnJlYWRlcik7CgkJCWNyZWF0ZV9wYWNrX2ZpbGUoJmRhdGEsIE5VTEwpOwoJCX0KCX0KCgl1cGxvYWRfcGFja19kYXRhX2NsZWFyKCZkYXRhKTsKfQoKc3RhdGljIGludCBwYXJzZV93YW50KHN0cnVjdCBwYWNrZXRfd3JpdGVyICp3cml0ZXIsIGNvbnN0IGNoYXIgKmxpbmUsCgkJICAgICAgc3RydWN0IG9iamVjdF9hcnJheSAqd2FudF9vYmopCnsKCWNvbnN0IGNoYXIgKmFyZzsKCWlmIChza2lwX3ByZWZpeChsaW5lLCAid2FudCAiLCAmYXJnKSkgewoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCXN0cnVjdCBvYmplY3QgKm87CgoJCWlmIChnZXRfb2lkX2hleChhcmcsICZvaWQpKQoJCQlkaWUoImdpdCB1cGxvYWQtcGFjazogcHJvdG9jb2wgZXJyb3IsICIKCQkJICAgICJleHBlY3RlZCB0byBnZXQgb2lkLCBub3QgJyVzJyIsIGxpbmUpOwoKCQlvID0gcGFyc2Vfb2JqZWN0X3dpdGhfZmxhZ3ModGhlX3JlcG9zaXRvcnksICZvaWQsCgkJCQkJICAgIFBBUlNFX09CSkVDVF9TS0lQX0hBU0hfQ0hFQ0sgfAoJCQkJCSAgICBQQVJTRV9PQkpFQ1RfRElTQ0FSRF9UUkVFKTsKCgkJaWYgKCFvKSB7CgkJCXBhY2tldF93cml0ZXJfZXJyb3Iod3JpdGVyLAoJCQkJCSAgICAidXBsb2FkLXBhY2s6IG5vdCBvdXIgcmVmICVzIiwKCQkJCQkgICAgb2lkX3RvX2hleCgmb2lkKSk7CgkJCWRpZSgiZ2l0IHVwbG9hZC1wYWNrOiBub3Qgb3VyIHJlZiAlcyIsCgkJCSAgICBvaWRfdG9faGV4KCZvaWQpKTsKCQl9CgoJCWlmICghKG8tPmZsYWdzICYgV0FOVEVEKSkgewoJCQlvLT5mbGFncyB8PSBXQU5URUQ7CgkJCWFkZF9vYmplY3RfYXJyYXkobywgTlVMTCwgd2FudF9vYmopOwoJCX0KCgkJcmV0dXJuIDE7Cgl9CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgcGFyc2Vfd2FudF9yZWYoc3RydWN0IHBhY2tldF93cml0ZXIgKndyaXRlciwgY29uc3QgY2hhciAqbGluZSwKCQkJICBzdHJ1Y3Qgc3RybWFwICp3YW50ZWRfcmVmcywKCQkJICBzdHJ1Y3Qgc3RydmVjICpoaWRkZW5fcmVmcywKCQkJICBzdHJ1Y3Qgb2JqZWN0X2FycmF5ICp3YW50X29iaikKewoJY29uc3QgY2hhciAqcmVmbmFtZV9ub25zOwoJaWYgKHNraXBfcHJlZml4KGxpbmUsICJ3YW50LXJlZiAiLCAmcmVmbmFtZV9ub25zKSkgewoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCXN0cnVjdCBvYmplY3QgKm8gPSBOVUxMOwoJCXN0cnVjdCBzdHJidWYgcmVmbmFtZSA9IFNUUkJVRl9JTklUOwoKCQlzdHJidWZfYWRkZigmcmVmbmFtZSwgIiVzJXMiLCBnZXRfZ2l0X25hbWVzcGFjZSgpLCByZWZuYW1lX25vbnMpOwoJCWlmIChyZWZfaXNfaGlkZGVuKHJlZm5hbWVfbm9ucywgcmVmbmFtZS5idWYsIGhpZGRlbl9yZWZzKSB8fAoJCSAgICByZWZzX3JlYWRfcmVmKGdldF9tYWluX3JlZl9zdG9yZSh0aGVfcmVwb3NpdG9yeSksIHJlZm5hbWUuYnVmLCAmb2lkKSkgewoJCQlwYWNrZXRfd3JpdGVyX2Vycm9yKHdyaXRlciwgInVua25vd24gcmVmICVzIiwgcmVmbmFtZV9ub25zKTsKCQkJZGllKCJ1bmtub3duIHJlZiAlcyIsIHJlZm5hbWVfbm9ucyk7CgkJfQoJCXN0cmJ1Zl9yZWxlYXNlKCZyZWZuYW1lKTsKCgkJaWYgKHN0cm1hcF9wdXQod2FudGVkX3JlZnMsIHJlZm5hbWVfbm9ucywgb2lkZHVwKCZvaWQpKSkgewoJCQlwYWNrZXRfd3JpdGVyX2Vycm9yKHdyaXRlciwgImR1cGxpY2F0ZSB3YW50LXJlZiAlcyIsCgkJCQkJICAgIHJlZm5hbWVfbm9ucyk7CgkJCWRpZSgiZHVwbGljYXRlIHdhbnQtcmVmICVzIiwgcmVmbmFtZV9ub25zKTsKCQl9CgoJCWlmICghc3RhcnRzX3dpdGgocmVmbmFtZV9ub25zLCAicmVmcy90YWdzLyIpKSB7CgkJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IGxvb2t1cF9jb21taXRfaW5fZ3JhcGgodGhlX3JlcG9zaXRvcnksICZvaWQpOwoJCQlpZiAoY29tbWl0KQoJCQkJbyA9ICZjb21taXQtPm9iamVjdDsKCQl9CgoJCWlmICghbykKCQkJbyA9IHBhcnNlX29iamVjdF9vcl9kaWUoJm9pZCwgcmVmbmFtZV9ub25zKTsKCgkJaWYgKCEoby0+ZmxhZ3MgJiBXQU5URUQpKSB7CgkJCW8tPmZsYWdzIHw9IFdBTlRFRDsKCQkJYWRkX29iamVjdF9hcnJheShvLCBOVUxMLCB3YW50X29iaik7CgkJfQoKCQlyZXR1cm4gMTsKCX0KCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBwYXJzZV9oYXZlKGNvbnN0IGNoYXIgKmxpbmUsIHN0cnVjdCB1cGxvYWRfcGFja19kYXRhICpkYXRhKQp7Cgljb25zdCBjaGFyICphcmc7CglpZiAoc2tpcF9wcmVmaXgobGluZSwgImhhdmUgIiwgJmFyZykpIHsKCQlzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCgkJZ290X29pZChkYXRhLCBhcmcsICZvaWQpOwoJCWRhdGEtPnNlZW5faGF2ZXMgPSAxOwoJCXJldHVybiAxOwoJfQoKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCB0cmFjZTJfZmV0Y2hfaW5mbyhzdHJ1Y3QgdXBsb2FkX3BhY2tfZGF0YSAqZGF0YSkKewoJc3RydWN0IGpzb25fd3JpdGVyIGp3ID0gSlNPTl9XUklURVJfSU5JVDsKCglqd19vYmplY3RfYmVnaW4oJmp3LCAwKTsKCWp3X29iamVjdF9pbnRtYXgoJmp3LCAiaGF2ZXMiLCBkYXRhLT5oYXZlX29iai5ucik7Cglqd19vYmplY3RfaW50bWF4KCZqdywgIndhbnRzIiwgZGF0YS0+d2FudF9vYmoubnIpOwoJandfb2JqZWN0X2ludG1heCgmancsICJ3YW50LXJlZnMiLCBzdHJtYXBfZ2V0X3NpemUoJmRhdGEtPndhbnRlZF9yZWZzKSk7Cglqd19vYmplY3RfaW50bWF4KCZqdywgImRlcHRoIiwgZGF0YS0+ZGVwdGgpOwoJandfb2JqZWN0X2ludG1heCgmancsICJzaGFsbG93cyIsIGRhdGEtPnNoYWxsb3dzLm5yKTsKCWp3X29iamVjdF9ib29sKCZqdywgImRlZXBlbi1zaW5jZSIsIGRhdGEtPmRlZXBlbl9zaW5jZSk7Cglqd19vYmplY3RfaW50bWF4KCZqdywgImRlZXBlbi1ub3QiLCBvaWRzZXRfc2l6ZSgmZGF0YS0+ZGVlcGVuX25vdCkpOwoJandfb2JqZWN0X2Jvb2woJmp3LCAiZGVlcGVuLXJlbGF0aXZlIiwgZGF0YS0+ZGVlcGVuX3JlbGF0aXZlKTsKCWlmIChkYXRhLT5maWx0ZXJfb3B0aW9ucy5jaG9pY2UpCgkJandfb2JqZWN0X3N0cmluZygmancsICJmaWx0ZXIiLCBsaXN0X29iamVjdF9maWx0ZXJfY29uZmlnX25hbWUoZGF0YS0+ZmlsdGVyX29wdGlvbnMuY2hvaWNlKSk7CgllbHNlCgkJandfb2JqZWN0X251bGwoJmp3LCAiZmlsdGVyIik7Cglqd19lbmQoJmp3KTsKCgl0cmFjZTJfZGF0YV9qc29uKCJ1cGxvYWQtcGFjayIsIHRoZV9yZXBvc2l0b3J5LCAiZmV0Y2gtaW5mbyIsICZqdyk7CgoJandfcmVsZWFzZSgmancpOwp9CgpzdGF0aWMgdm9pZCBwcm9jZXNzX2FyZ3Moc3RydWN0IHBhY2tldF9yZWFkZXIgKnJlcXVlc3QsCgkJCSBzdHJ1Y3QgdXBsb2FkX3BhY2tfZGF0YSAqZGF0YSkKewoJd2hpbGUgKHBhY2tldF9yZWFkZXJfcmVhZChyZXF1ZXN0KSA9PSBQQUNLRVRfUkVBRF9OT1JNQUwpIHsKCQljb25zdCBjaGFyICphcmcgPSByZXF1ZXN0LT5saW5lOwoJCWNvbnN0IGNoYXIgKnA7CgoJCS8qIHByb2Nlc3Mgd2FudCAqLwoJCWlmIChwYXJzZV93YW50KCZkYXRhLT53cml0ZXIsIGFyZywgJmRhdGEtPndhbnRfb2JqKSkKCQkJY29udGludWU7CgkJaWYgKGRhdGEtPmFsbG93X3JlZl9pbl93YW50ICYmCgkJICAgIHBhcnNlX3dhbnRfcmVmKCZkYXRhLT53cml0ZXIsIGFyZywgJmRhdGEtPndhbnRlZF9yZWZzLAoJCQkJICAgJmRhdGEtPmhpZGRlbl9yZWZzLCAmZGF0YS0+d2FudF9vYmopKQoJCQljb250aW51ZTsKCQkvKiBwcm9jZXNzIGhhdmUgbGluZSAqLwoJCWlmIChwYXJzZV9oYXZlKGFyZywgZGF0YSkpCgkJCWNvbnRpbnVlOwoKCQkvKiBwcm9jZXNzIGFyZ3MgbGlrZSB0aGluLXBhY2sgKi8KCQlpZiAoIXN0cmNtcChhcmcsICJ0aGluLXBhY2siKSkgewoJCQlkYXRhLT51c2VfdGhpbl9wYWNrID0gMTsKCQkJY29udGludWU7CgkJfQoJCWlmICghc3RyY21wKGFyZywgIm9mcy1kZWx0YSIpKSB7CgkJCWRhdGEtPnVzZV9vZnNfZGVsdGEgPSAxOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKCFzdHJjbXAoYXJnLCAibm8tcHJvZ3Jlc3MiKSkgewoJCQlkYXRhLT5ub19wcm9ncmVzcyA9IDE7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoIXN0cmNtcChhcmcsICJpbmNsdWRlLXRhZyIpKSB7CgkJCWRhdGEtPnVzZV9pbmNsdWRlX3RhZyA9IDE7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoIXN0cmNtcChhcmcsICJkb25lIikpIHsKCQkJZGF0YS0+ZG9uZSA9IDE7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoIXN0cmNtcChhcmcsICJ3YWl0LWZvci1kb25lIikpIHsKCQkJZGF0YS0+d2FpdF9mb3JfZG9uZSA9IDE7CgkJCWNvbnRpbnVlOwoJCX0KCgkJLyogU2hhbGxvdyByZWxhdGVkIGFyZ3VtZW50cyAqLwoJCWlmIChwcm9jZXNzX3NoYWxsb3coYXJnLCAmZGF0YS0+c2hhbGxvd3MpKQoJCQljb250aW51ZTsKCQlpZiAocHJvY2Vzc19kZWVwZW4oYXJnLCAmZGF0YS0+ZGVwdGgpKQoJCQljb250aW51ZTsKCQlpZiAocHJvY2Vzc19kZWVwZW5fc2luY2UoYXJnLCAmZGF0YS0+ZGVlcGVuX3NpbmNlLAoJCQkJCSAmZGF0YS0+ZGVlcGVuX3Jldl9saXN0KSkKCQkJY29udGludWU7CgkJaWYgKHByb2Nlc3NfZGVlcGVuX25vdChhcmcsICZkYXRhLT5kZWVwZW5fbm90LAoJCQkJICAgICAgICZkYXRhLT5kZWVwZW5fcmV2X2xpc3QpKQoJCQljb250aW51ZTsKCQlpZiAoIXN0cmNtcChhcmcsICJkZWVwZW4tcmVsYXRpdmUiKSkgewoJCQlkYXRhLT5kZWVwZW5fcmVsYXRpdmUgPSAxOwoJCQljb250aW51ZTsKCQl9CgoJCWlmIChkYXRhLT5hbGxvd19maWx0ZXIgJiYgc2tpcF9wcmVmaXgoYXJnLCAiZmlsdGVyICIsICZwKSkgewoJCQlsaXN0X29iamVjdHNfZmlsdGVyX2RpZV9pZl9wb3B1bGF0ZWQoJmRhdGEtPmZpbHRlcl9vcHRpb25zKTsKCQkJcGFyc2VfbGlzdF9vYmplY3RzX2ZpbHRlcigmZGF0YS0+ZmlsdGVyX29wdGlvbnMsIHApOwoJCQlkaWVfaWZfdXNpbmdfYmFubmVkX2ZpbHRlcihkYXRhKTsKCQkJY29udGludWU7CgkJfQoKCQlpZiAoZGF0YS0+YWxsb3dfc2lkZWJhbmRfYWxsICYmCgkJICAgICFzdHJjbXAoYXJnLCAic2lkZWJhbmQtYWxsIikpIHsKCQkJZGF0YS0+d3JpdGVyLnVzZV9zaWRlYmFuZCA9IDE7CgkJCWNvbnRpbnVlOwoJCX0KCgkJaWYgKGRhdGEtPmFsbG93X3BhY2tmaWxlX3VyaXMgJiYKCQkgICAgc2tpcF9wcmVmaXgoYXJnLCAicGFja2ZpbGUtdXJpcyAiLCAmcCkpIHsKCQkJaWYgKGRhdGEtPnVyaV9wcm90b2NvbHMubnIpCgkJCQlzZW5kX2Vycl9hbmRfZGllKGRhdGEsCgkJCQkJCSAibXVsdGlwbGUgcGFja2ZpbGUtdXJpcyBsaW5lcyBmb3JiaWRkZW4iKTsKCQkJc3RyaW5nX2xpc3Rfc3BsaXQoJmRhdGEtPnVyaV9wcm90b2NvbHMsIHAsICcsJywgLTEpOwoJCQljb250aW51ZTsKCQl9CgoJCS8qIGlnbm9yZSB1bmtub3duIGxpbmVzIG1heWJlPyAqLwoJCWRpZSgidW5leHBlY3RlZCBsaW5lOiAnJXMnIiwgYXJnKTsKCX0KCglpZiAoZGF0YS0+dXJpX3Byb3RvY29scy5uciAmJiAhZGF0YS0+d3JpdGVyLnVzZV9zaWRlYmFuZCkKCQlzdHJpbmdfbGlzdF9jbGVhcigmZGF0YS0+dXJpX3Byb3RvY29scywgMCk7CgoJaWYgKHJlcXVlc3QtPnN0YXR1cyAhPSBQQUNLRVRfUkVBRF9GTFVTSCkKCQlkaWUoXygiZXhwZWN0ZWQgZmx1c2ggYWZ0ZXIgZmV0Y2ggYXJndW1lbnRzIikpOwoKCWlmICh0cmFjZTJfaXNfZW5hYmxlZCgpKQoJCXRyYWNlMl9mZXRjaF9pbmZvKGRhdGEpOwp9CgpzdGF0aWMgaW50IHNlbmRfYWNrcyhzdHJ1Y3QgdXBsb2FkX3BhY2tfZGF0YSAqZGF0YSwgc3RydWN0IG9iamVjdF9hcnJheSAqYWNrcykKewoJaW50IGk7CgoJcGFja2V0X3dyaXRlcl93cml0ZSgmZGF0YS0+d3JpdGVyLCAiYWNrbm93bGVkZ21lbnRzXG4iKTsKCgkvKiBTZW5kIEFja3MgKi8KCWlmICghYWNrcy0+bnIpCgkJcGFja2V0X3dyaXRlcl93cml0ZSgmZGF0YS0+d3JpdGVyLCAiTkFLXG4iKTsKCglmb3IgKGkgPSAwOyBpIDwgYWNrcy0+bnI7IGkrKykgewoJCXBhY2tldF93cml0ZXJfd3JpdGUoJmRhdGEtPndyaXRlciwgIkFDSyAlc1xuIiwKCQkJCSAgICBvaWRfdG9faGV4KCZhY2tzLT5vYmplY3RzW2ldLml0ZW0tPm9pZCkpOwoJfQoKCWlmICghZGF0YS0+d2FpdF9mb3JfZG9uZSAmJiBva190b19naXZlX3VwKGRhdGEpKSB7CgkJLyogU2VuZCBSZWFkeSAqLwoJCXBhY2tldF93cml0ZXJfd3JpdGUoJmRhdGEtPndyaXRlciwgInJlYWR5XG4iKTsKCQlyZXR1cm4gMTsKCX0KCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBwcm9jZXNzX2hhdmVzX2FuZF9zZW5kX2Fja3Moc3RydWN0IHVwbG9hZF9wYWNrX2RhdGEgKmRhdGEpCnsKCWludCByZXQgPSAwOwoKCWlmIChkYXRhLT5kb25lKSB7CgkJcmV0ID0gMTsKCX0gZWxzZSBpZiAoc2VuZF9hY2tzKGRhdGEsICZkYXRhLT5oYXZlX29iaikpIHsKCQlwYWNrZXRfd3JpdGVyX2RlbGltKCZkYXRhLT53cml0ZXIpOwoJCXJldCA9IDE7Cgl9IGVsc2UgewoJCS8qIEFkZCBGbHVzaCAqLwoJCXBhY2tldF93cml0ZXJfZmx1c2goJmRhdGEtPndyaXRlcik7CgkJcmV0ID0gMDsKCX0KCglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgdm9pZCBzZW5kX3dhbnRlZF9yZWZfaW5mbyhzdHJ1Y3QgdXBsb2FkX3BhY2tfZGF0YSAqZGF0YSkKewoJc3RydWN0IGhhc2htYXBfaXRlciBpdGVyOwoJY29uc3Qgc3RydWN0IHN0cm1hcF9lbnRyeSAqZTsKCglpZiAoc3RybWFwX2VtcHR5KCZkYXRhLT53YW50ZWRfcmVmcykpCgkJcmV0dXJuOwoKCXBhY2tldF93cml0ZXJfd3JpdGUoJmRhdGEtPndyaXRlciwgIndhbnRlZC1yZWZzXG4iKTsKCglzdHJtYXBfZm9yX2VhY2hfZW50cnkoJmRhdGEtPndhbnRlZF9yZWZzLCAmaXRlciwgZSkgewoJCXBhY2tldF93cml0ZXJfd3JpdGUoJmRhdGEtPndyaXRlciwgIiVzICVzXG4iLAoJCQkJICAgIG9pZF90b19oZXgoZS0+dmFsdWUpLAoJCQkJICAgIGUtPmtleSk7Cgl9CgoJcGFja2V0X3dyaXRlcl9kZWxpbSgmZGF0YS0+d3JpdGVyKTsKfQoKc3RhdGljIHZvaWQgc2VuZF9zaGFsbG93X2luZm8oc3RydWN0IHVwbG9hZF9wYWNrX2RhdGEgKmRhdGEpCnsKCS8qIE5vIHNoYWxsb3cgaW5mbyBuZWVkcyB0byBiZSBzZW50ICovCglpZiAoIWRhdGEtPmRlcHRoICYmICFkYXRhLT5kZWVwZW5fcmV2X2xpc3QgJiYgIWRhdGEtPnNoYWxsb3dzLm5yICYmCgkgICAgIWlzX3JlcG9zaXRvcnlfc2hhbGxvdyh0aGVfcmVwb3NpdG9yeSkpCgkJcmV0dXJuOwoKCXBhY2tldF93cml0ZXJfd3JpdGUoJmRhdGEtPndyaXRlciwgInNoYWxsb3ctaW5mb1xuIik7CgoJaWYgKCFzZW5kX3NoYWxsb3dfbGlzdChkYXRhKSAmJgoJICAgIGlzX3JlcG9zaXRvcnlfc2hhbGxvdyh0aGVfcmVwb3NpdG9yeSkpCgkJZGVlcGVuKGRhdGEsIElORklOSVRFX0RFUFRIKTsKCglwYWNrZXRfZGVsaW0oMSk7Cn0KCmVudW0gZmV0Y2hfc3RhdGUgewoJRkVUQ0hfUFJPQ0VTU19BUkdTID0gMCwKCUZFVENIX1NFTkRfQUNLUywKCUZFVENIX1NFTkRfUEFDSywKCUZFVENIX0RPTkUsCn07CgppbnQgdXBsb2FkX3BhY2tfdjIoc3RydWN0IHJlcG9zaXRvcnkgKnIsIHN0cnVjdCBwYWNrZXRfcmVhZGVyICpyZXF1ZXN0KQp7CgllbnVtIGZldGNoX3N0YXRlIHN0YXRlID0gRkVUQ0hfUFJPQ0VTU19BUkdTOwoJc3RydWN0IHVwbG9hZF9wYWNrX2RhdGEgZGF0YTsKCgljbGVhcl9vYmplY3RfZmxhZ3MoQUxMX0ZMQUdTKTsKCgl1cGxvYWRfcGFja19kYXRhX2luaXQoJmRhdGEpOwoJZGF0YS51c2Vfc2lkZWJhbmQgPSBMQVJHRV9QQUNLRVRfTUFYOwoJZ2V0X3VwbG9hZF9wYWNrX2NvbmZpZyhyLCAmZGF0YSk7CgoJd2hpbGUgKHN0YXRlICE9IEZFVENIX0RPTkUpIHsKCQlzd2l0Y2ggKHN0YXRlKSB7CgkJY2FzZSBGRVRDSF9QUk9DRVNTX0FSR1M6CgkJCXByb2Nlc3NfYXJncyhyZXF1ZXN0LCAmZGF0YSk7CgoJCQlpZiAoIWRhdGEud2FudF9vYmoubnIgJiYgIWRhdGEud2FpdF9mb3JfZG9uZSkgewoJCQkJLyoKCQkJCSAqIFJlcXVlc3QgZGlkbid0IGNvbnRhaW4gYW55ICd3YW50JyBsaW5lcyAoYW5kCgkJCQkgKiB0aGUgcmVxdWVzdCBkb2VzIG5vdCBjb250YWluCgkJCQkgKiAid2FpdC1mb3ItZG9uZSIsIGluIHdoaWNoIGl0IGlzIHJlYXNvbmFibGUKCQkJCSAqIHRvIGp1c3Qgc2VuZCAnaGF2ZSdzIHdpdGhvdXQgJ3dhbnQncyk7IGd1ZXNzCgkJCQkgKiB0aGV5IGRpZG4ndCB3YW50IGFueXRoaW5nLgoJCQkJICovCgkJCQlzdGF0ZSA9IEZFVENIX0RPTkU7CgkJCX0gZWxzZSBpZiAoZGF0YS5zZWVuX2hhdmVzKSB7CgkJCQkvKgoJCQkJICogUmVxdWVzdCBoYWQgJ2hhdmUnIGxpbmVzLCBzbyBsZXRzIEFDSyB0aGVtLgoJCQkJICovCgkJCQlzdGF0ZSA9IEZFVENIX1NFTkRfQUNLUzsKCQkJfSBlbHNlIHsKCQkJCS8qCgkJCQkgKiBSZXF1ZXN0IGhhZCAnd2FudCdzIGJ1dCBubyAnaGF2ZSdzIHNvIHdlIGNhbgoJCQkJICogaW1tZWRpZXRseSBnbyB0byBjb25zdHJ1Y3QgYW5kIHNlbmQgYSBwYWNrLgoJCQkJICovCgkJCQlzdGF0ZSA9IEZFVENIX1NFTkRfUEFDSzsKCQkJfQoJCQlicmVhazsKCQljYXNlIEZFVENIX1NFTkRfQUNLUzoKCQkJaWYgKHByb2Nlc3NfaGF2ZXNfYW5kX3NlbmRfYWNrcygmZGF0YSkpCgkJCQlzdGF0ZSA9IEZFVENIX1NFTkRfUEFDSzsKCQkJZWxzZQoJCQkJc3RhdGUgPSBGRVRDSF9ET05FOwoJCQlicmVhazsKCQljYXNlIEZFVENIX1NFTkRfUEFDSzoKCQkJc2VuZF93YW50ZWRfcmVmX2luZm8oJmRhdGEpOwoJCQlzZW5kX3NoYWxsb3dfaW5mbygmZGF0YSk7CgoJCQlpZiAoZGF0YS51cmlfcHJvdG9jb2xzLm5yKSB7CgkJCQljcmVhdGVfcGFja19maWxlKCZkYXRhLCAmZGF0YS51cmlfcHJvdG9jb2xzKTsKCQkJfSBlbHNlIHsKCQkJCXBhY2tldF93cml0ZXJfd3JpdGUoJmRhdGEud3JpdGVyLCAicGFja2ZpbGVcbiIpOwoJCQkJY3JlYXRlX3BhY2tfZmlsZSgmZGF0YSwgTlVMTCk7CgkJCX0KCQkJc3RhdGUgPSBGRVRDSF9ET05FOwoJCQlicmVhazsKCQljYXNlIEZFVENIX0RPTkU6CgkJCWNvbnRpbnVlOwoJCX0KCX0KCgl1cGxvYWRfcGFja19kYXRhX2NsZWFyKCZkYXRhKTsKCXJldHVybiAwOwp9CgppbnQgdXBsb2FkX3BhY2tfYWR2ZXJ0aXNlKHN0cnVjdCByZXBvc2l0b3J5ICpyLAoJCQkgIHN0cnVjdCBzdHJidWYgKnZhbHVlKQp7CglzdHJ1Y3QgdXBsb2FkX3BhY2tfZGF0YSBkYXRhOwoKCXVwbG9hZF9wYWNrX2RhdGFfaW5pdCgmZGF0YSk7CglnZXRfdXBsb2FkX3BhY2tfY29uZmlnKHIsICZkYXRhKTsKCglpZiAodmFsdWUpIHsKCQlzdHJidWZfYWRkc3RyKHZhbHVlLCAic2hhbGxvdyB3YWl0LWZvci1kb25lIik7CgoJCWlmIChkYXRhLmFsbG93X2ZpbHRlcikKCQkJc3RyYnVmX2FkZHN0cih2YWx1ZSwgIiBmaWx0ZXIiKTsKCgkJaWYgKGRhdGEuYWxsb3dfcmVmX2luX3dhbnQpCgkJCXN0cmJ1Zl9hZGRzdHIodmFsdWUsICIgcmVmLWluLXdhbnQiKTsKCgkJaWYgKGRhdGEuYWxsb3dfc2lkZWJhbmRfYWxsKQoJCQlzdHJidWZfYWRkc3RyKHZhbHVlLCAiIHNpZGViYW5kLWFsbCIpOwoKCQlpZiAoZGF0YS5hbGxvd19wYWNrZmlsZV91cmlzKQoJCQlzdHJidWZfYWRkc3RyKHZhbHVlLCAiIHBhY2tmaWxlLXVyaXMiKTsKCX0KCgl1cGxvYWRfcGFja19kYXRhX2NsZWFyKCZkYXRhKTsKCglyZXR1cm4gMTsKfQo=",
    "text": "#define USE_THE_REPOSITORY_VARIABLE\n\n#include \"git-compat-util.h\"\n#include \"config.h\"\n#include \"environment.h\"\n#include \"gettext.h\"\n#include \"hex.h\"\n#include \"refs.h\"\n#include \"pkt-line.h\"\n#include \"sideband.h\"\n#include \"repository.h\"\n#include \"object-store-ll.h\"\n#include \"oid-array.h\"\n#include \"object.h\"\n#include \"commit.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"list-objects-filter-options.h\"\n#include \"run-command.h\"\n#include \"connect.h\"\n#include \"sigchain.h\"\n#include \"version.h\"\n#include \"string-list.h\"\n#include \"strvec.h\"\n#include \"trace2.h\"\n#include \"protocol.h\"\n#include \"upload-pack.h\"\n#include \"commit-graph.h\"\n#include \"commit-reach.h\"\n#include \"shallow.h\"\n#include \"write-or-die.h\"\n#include \"json-writer.h\"\n#include \"strmap.h\"\n\n/* Remember to update object flag allocation in object.h */\n#define THEY_HAVE\t(1u << 11)\n#define OUR_REF\t\t(1u << 12)\n#define WANTED\t\t(1u << 13)\n#define COMMON_KNOWN\t(1u << 14)\n\n#define SHALLOW\t\t(1u << 16)\n#define NOT_SHALLOW\t(1u << 17)\n#define CLIENT_SHALLOW\t(1u << 18)\n#define HIDDEN_REF\t(1u << 19)\n\n#define ALL_FLAGS (THEY_HAVE | OUR_REF | WANTED | COMMON_KNOWN | SHALLOW | \\\n\t\tNOT_SHALLOW | CLIENT_SHALLOW | HIDDEN_REF)\n\n/* Enum for allowed unadvertised object request (UOR) */\nenum allow_uor {\n\t/* Allow specifying sha1 if it is a ref tip. */\n\tALLOW_TIP_SHA1 = 0x01,\n\t/* Allow request of a sha1 if it is reachable from a ref (possibly hidden ref). */\n\tALLOW_REACHABLE_SHA1 = 0x02,\n\t/* Allow request of any sha1. Implies ALLOW_TIP_SHA1 and ALLOW_REACHABLE_SHA1. */\n\tALLOW_ANY_SHA1 = 0x07\n};\n\n/*\n * Please annotate, and if possible group together, fields used only\n * for protocol v0 or only for protocol v2.\n */\nstruct upload_pack_data {\n\tstruct string_list symref;\t\t\t\t/* v0 only */\n\tstruct object_array want_obj;\n\tstruct object_array have_obj;\n\tstruct strmap wanted_refs;\t\t\t\t/* v2 only */\n\tstruct strvec hidden_refs;\n\n\tstruct object_array shallows;\n\tstruct oidset deepen_not;\n\tstruct object_array extra_edge_obj;\n\tint depth;\n\ttimestamp_t deepen_since;\n\tint deepen_rev_list;\n\tint deepen_relative;\n\tint keepalive;\n\tint shallow_nr;\n\ttimestamp_t oldest_have;\n\n\tunsigned int timeout;\t\t\t\t\t/* v0 only */\n\tenum {\n\t\tNO_MULTI_ACK = 0,\n\t\tMULTI_ACK = 1,\n\t\tMULTI_ACK_DETAILED = 2\n\t} multi_ack;\t\t\t\t\t\t/* v0 only */\n\n\t/* 0 for no sideband, otherwise DEFAULT_PACKET_MAX or LARGE_PACKET_MAX */\n\tint use_sideband;\n\n\tstruct string_list uri_protocols;\n\tenum allow_uor allow_uor;\n\n\tstruct list_objects_filter_options filter_options;\n\tstruct string_list allowed_filters;\n\n\tstruct packet_writer writer;\n\n\tchar *pack_objects_hook;\n\n\tunsigned stateless_rpc : 1;\t\t\t\t/* v0 only */\n\tunsigned no_done : 1;\t\t\t\t\t/* v0 only */\n\tunsigned daemon_mode : 1;\t\t\t\t/* v0 only */\n\tunsigned filter_capability_requested : 1;\t\t/* v0 only */\n\n\tunsigned use_thin_pack : 1;\n\tunsigned use_ofs_delta : 1;\n\tunsigned no_progress : 1;\n\tunsigned use_include_tag : 1;\n\tunsigned wait_for_done : 1;\n\tunsigned allow_filter : 1;\n\tunsigned allow_filter_fallback : 1;\n\tunsigned long tree_filter_max_depth;\n\n\tunsigned done : 1;\t\t\t\t\t/* v2 only */\n\tunsigned allow_ref_in_want : 1;\t\t\t\t/* v2 only */\n\tunsigned allow_sideband_all : 1;\t\t\t/* v2 only */\n\tunsigned seen_haves : 1;\t\t\t\t/* v2 only */\n\tunsigned allow_packfile_uris : 1;\t\t\t/* v2 only */\n\tunsigned advertise_sid : 1;\n\tunsigned sent_capabilities : 1;\n};\n\nstatic void upload_pack_data_init(struct upload_pack_data *data)\n{\n\tstruct string_list symref = STRING_LIST_INIT_DUP;\n\tstruct strmap wanted_refs = STRMAP_INIT;\n\tstruct strvec hidden_refs = STRVEC_INIT;\n\tstruct object_array want_obj = OBJECT_ARRAY_INIT;\n\tstruct object_array have_obj = OBJECT_ARRAY_INIT;\n\tstruct object_array shallows = OBJECT_ARRAY_INIT;\n\tstruct oidset deepen_not = OID_ARRAY_INIT;\n\tstruct string_list uri_protocols = STRING_LIST_INIT_DUP;\n\tstruct object_array extra_edge_obj = OBJECT_ARRAY_INIT;\n\tstruct string_list allowed_filters = STRING_LIST_INIT_DUP;\n\n\tmemset(data, 0, sizeof(*data));\n\tdata->symref = symref;\n\tdata->wanted_refs = wanted_refs;\n\tdata->hidden_refs = hidden_refs;\n\tdata->want_obj = want_obj;\n\tdata->have_obj = have_obj;\n\tdata->shallows = shallows;\n\tdata->deepen_not = deepen_not;\n\tdata->uri_protocols = uri_protocols;\n\tdata->extra_edge_obj = extra_edge_obj;\n\tdata->allowed_filters = allowed_filters;\n\tdata->allow_filter_fallback = 1;\n\tdata->tree_filter_max_depth = ULONG_MAX;\n\tpacket_writer_init(&data->writer, 1);\n\tlist_objects_filter_init(&data->filter_options);\n\n\tdata->keepalive = 5;\n\tdata->advertise_sid = 0;\n}\n\nstatic void upload_pack_data_clear(struct upload_pack_data *data)\n{\n\tstring_list_clear(&data->symref, 1);\n\tstrmap_clear(&data->wanted_refs, 1);\n\tstrvec_clear(&data->hidden_refs);\n\tobject_array_clear(&data->want_obj);\n\tobject_array_clear(&data->have_obj);\n\tobject_array_clear(&data->shallows);\n\toidset_clear(&data->deepen_not);\n\tobject_array_clear(&data->extra_edge_obj);\n\tlist_objects_filter_release(&data->filter_options);\n\tstring_list_clear(&data->allowed_filters, 0);\n\n\tfree((char *)data->pack_objects_hook);\n}\n\nstatic void reset_timeout(unsigned int timeout)\n{\n\talarm(timeout);\n}\n\nstatic void send_client_data(int fd, const char *data, ssize_t sz,\n\t\t\t     int use_sideband)\n{\n\tif (use_sideband) {\n\t\tsend_sideband(1, fd, data, sz, use_sideband);\n\t\treturn;\n\t}\n\tif (fd == 3)\n\t\t/* emergency quit */\n\t\tfd = 2;\n\tif (fd == 2) {\n\t\t/* XXX: are we happy to lose stuff here? */\n\t\txwrite(fd, data, sz);\n\t\treturn;\n\t}\n\twrite_or_die(fd, data, sz);\n}\n\nstatic int write_one_shallow(const struct commit_graft *graft, void *cb_data)\n{\n\tFILE *fp = cb_data;\n\tif (graft->nr_parent == -1)\n\t\tfprintf(fp, \"--shallow %s\\n\", oid_to_hex(&graft->oid));\n\treturn 0;\n}\n\nstruct output_state {\n\t/*\n\t * We do writes no bigger than LARGE_PACKET_DATA_MAX - 1, because with\n\t * sideband-64k the band designator takes up 1 byte of space. Because\n\t * relay_pack_data keeps the last byte to itself, we make the buffer 1\n\t * byte bigger than the intended maximum write size.\n\t */\n\tchar buffer[(LARGE_PACKET_DATA_MAX - 1) + 1];\n\tint used;\n\tunsigned packfile_uris_started : 1;\n\tunsigned packfile_started : 1;\n};\n\nstatic int relay_pack_data(int pack_objects_out, struct output_state *os,\n\t\t\t   int use_sideband, int write_packfile_line)\n{\n\t/*\n\t * We keep the last byte to ourselves\n\t * in case we detect broken rev-list, so that we\n\t * can leave the stream corrupted.  This is\n\t * unfortunate -- unpack-objects would happily\n\t * accept a valid packdata with trailing garbage,\n\t * so appending garbage after we pass all the\n\t * pack data is not good enough to signal\n\t * breakage to downstream.\n\t */\n\tssize_t readsz;\n\n\treadsz = xread(pack_objects_out, os->buffer + os->used,\n\t\t       sizeof(os->buffer) - os->used);\n\tif (readsz < 0) {\n\t\treturn readsz;\n\t}\n\tos->used += readsz;\n\n\twhile (!os->packfile_started) {\n\t\tchar *p;\n\t\tif (os->used >= 4 && !memcmp(os->buffer, \"PACK\", 4)) {\n\t\t\tos->packfile_started = 1;\n\t\t\tif (write_packfile_line) {\n\t\t\t\tif (os->packfile_uris_started)\n\t\t\t\t\tpacket_delim(1);\n\t\t\t\tpacket_write_fmt(1, \"\\1packfile\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif ((p = memchr(os->buffer, '\\n', os->used))) {\n\t\t\tif (!os->packfile_uris_started) {\n\t\t\t\tos->packfile_uris_started = 1;\n\t\t\t\tif (!write_packfile_line)\n\t\t\t\t\tBUG(\"packfile_uris requires sideband-all\");\n\t\t\t\tpacket_write_fmt(1, \"\\1packfile-uris\\n\");\n\t\t\t}\n\t\t\t*p = '\\0';\n\t\t\tpacket_write_fmt(1, \"\\1%s\\n\", os->buffer);\n\n\t\t\tos->used -= p - os->buffer + 1;\n\t\t\tmemmove(os->buffer, p + 1, os->used);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Incomplete line.\n\t\t\t */\n\t\t\treturn readsz;\n\t\t}\n\t}\n\n\tif (os->used > 1) {\n\t\tsend_client_data(1, os->buffer, os->used - 1, use_sideband);\n\t\tos->buffer[0] = os->buffer[os->used - 1];\n\t\tos->used = 1;\n\t} else {\n\t\tsend_client_data(1, os->buffer, os->used, use_sideband);\n\t\tos->used = 0;\n\t}\n\n\treturn readsz;\n}\n\nstatic void create_pack_file(struct upload_pack_data *pack_data,\n\t\t\t     const struct string_list *uri_protocols)\n{\n\tstruct child_process pack_objects = CHILD_PROCESS_INIT;\n\tstruct output_state *output_state = xcalloc(1, sizeof(struct output_state));\n\tchar progress[128];\n\tchar abort_msg[] = \"aborting due to possible repository \"\n\t\t\"corruption on the remote side.\";\n\tssize_t sz;\n\tint i;\n\tFILE *pipe_fd;\n\n\tif (!pack_data->pack_objects_hook)\n\t\tpack_objects.git_cmd = 1;\n\telse {\n\t\tstrvec_push(&pack_objects.args, pack_data->pack_objects_hook);\n\t\tstrvec_push(&pack_objects.args, \"git\");\n\t\tpack_objects.use_shell = 1;\n\t}\n\n\tif (pack_data->shallow_nr) {\n\t\tstrvec_push(&pack_objects.args, \"--shallow-file\");\n\t\tstrvec_push(&pack_objects.args, \"\");\n\t}\n\tstrvec_push(&pack_objects.args, \"pack-objects\");\n\tstrvec_push(&pack_objects.args, \"--revs\");\n\tif (pack_data->use_thin_pack)\n\t\tstrvec_push(&pack_objects.args, \"--thin\");\n\n\tstrvec_push(&pack_objects.args, \"--stdout\");\n\tif (pack_data->shallow_nr)\n\t\tstrvec_push(&pack_objects.args, \"--shallow\");\n\tif (!pack_data->no_progress)\n\t\tstrvec_push(&pack_objects.args, \"--progress\");\n\tif (pack_data->use_ofs_delta)\n\t\tstrvec_push(&pack_objects.args, \"--delta-base-offset\");\n\tif (pack_data->use_include_tag)\n\t\tstrvec_push(&pack_objects.args, \"--include-tag\");\n\tif (pack_data->filter_options.choice) {\n\t\tconst char *spec =\n\t\t\texpand_list_objects_filter_spec(&pack_data->filter_options);\n\t\tstrvec_pushf(&pack_objects.args, \"--filter=%s\", spec);\n\t}\n\tif (uri_protocols) {\n\t\tfor (i = 0; i < uri_protocols->nr; i++)\n\t\t\tstrvec_pushf(&pack_objects.args, \"--uri-protocol=%s\",\n\t\t\t\t\t uri_protocols->items[i].string);\n\t}\n\n\tpack_objects.in = -1;\n\tpack_objects.out = -1;\n\tpack_objects.err = -1;\n\tpack_objects.clean_on_exit = 1;\n\n\tif (start_command(&pack_objects))\n\t\tdie(\"git upload-pack: unable to fork git-pack-objects\");\n\n\tpipe_fd = xfdopen(pack_objects.in, \"w\");\n\n\tif (pack_data->shallow_nr)\n\t\tfor_each_commit_graft(write_one_shallow, pipe_fd);\n\n\tfor (i = 0; i < pack_data->want_obj.nr; i++)\n\t\tfprintf(pipe_fd, \"%s\\n\",\n\t\t\toid_to_hex(&pack_data->want_obj.objects[i].item->oid));\n\tfprintf(pipe_fd, \"--not\\n\");\n\tfor (i = 0; i < pack_data->have_obj.nr; i++)\n\t\tfprintf(pipe_fd, \"%s\\n\",\n\t\t\toid_to_hex(&pack_data->have_obj.objects[i].item->oid));\n\tfor (i = 0; i < pack_data->extra_edge_obj.nr; i++)\n\t\tfprintf(pipe_fd, \"%s\\n\",\n\t\t\toid_to_hex(&pack_data->extra_edge_obj.objects[i].item->oid));\n\tfprintf(pipe_fd, \"\\n\");\n\tfflush(pipe_fd);\n\tfclose(pipe_fd);\n\n\t/* We read from pack_objects.err to capture stderr output for\n\t * progress bar, and pack_objects.out to capture the pack data.\n\t */\n\n\twhile (1) {\n\t\tstruct pollfd pfd[2];\n\t\tint pe, pu, pollsize, polltimeout;\n\t\tint ret;\n\n\t\treset_timeout(pack_data->timeout);\n\n\t\tpollsize = 0;\n\t\tpe = pu = -1;\n\n\t\tif (0 <= pack_objects.out) {\n\t\t\tpfd[pollsize].fd = pack_objects.out;\n\t\t\tpfd[pollsize].events = POLLIN;\n\t\t\tpu = pollsize;\n\t\t\tpollsize++;\n\t\t}\n\t\tif (0 <= pack_objects.err) {\n\t\t\tpfd[pollsize].fd = pack_objects.err;\n\t\t\tpfd[pollsize].events = POLLIN;\n\t\t\tpe = pollsize;\n\t\t\tpollsize++;\n\t\t}\n\n\t\tif (!pollsize)\n\t\t\tbreak;\n\n\t\tpolltimeout = pack_data->keepalive < 0\n\t\t\t? -1\n\t\t\t: 1000 * pack_data->keepalive;\n\n\t\tret = poll(pfd, pollsize, polltimeout);\n\n\t\tif (ret < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\terror_errno(\"poll failed, resuming\");\n\t\t\t\tsleep(1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (0 <= pe && (pfd[pe].revents & (POLLIN|POLLHUP))) {\n\t\t\t/* Status ready; we ship that in the side-band\n\t\t\t * or dump to the standard error.\n\t\t\t */\n\t\t\tsz = xread(pack_objects.err, progress,\n\t\t\t\t  sizeof(progress));\n\t\t\tif (0 < sz)\n\t\t\t\tsend_client_data(2, progress, sz,\n\t\t\t\t\t\t pack_data->use_sideband);\n\t\t\telse if (sz == 0) {\n\t\t\t\tclose(pack_objects.err);\n\t\t\t\tpack_objects.err = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto fail;\n\t\t\t/* give priority to status messages */\n\t\t\tcontinue;\n\t\t}\n\t\tif (0 <= pu && (pfd[pu].revents & (POLLIN|POLLHUP))) {\n\t\t\tint result = relay_pack_data(pack_objects.out,\n\t\t\t\t\t\t     output_state,\n\t\t\t\t\t\t     pack_data->use_sideband,\n\t\t\t\t\t\t     !!uri_protocols);\n\n\t\t\tif (result == 0) {\n\t\t\t\tclose(pack_objects.out);\n\t\t\t\tpack_objects.out = -1;\n\t\t\t} else if (result < 0) {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We hit the keepalive timeout without saying anything; send\n\t\t * an empty message on the data sideband just to let the other\n\t\t * side know we're still working on it, but don't have any data\n\t\t * yet.\n\t\t *\n\t\t * If we don't have a sideband channel, there's no room in the\n\t\t * protocol to say anything, so those clients are just out of\n\t\t * luck.\n\t\t */\n\t\tif (!ret && pack_data->use_sideband) {\n\t\t\tstatic const char buf[] = \"0005\\1\";\n\t\t\twrite_or_die(1, buf, 5);\n\t\t}\n\t}\n\n\tif (finish_command(&pack_objects)) {\n\t\terror(\"git upload-pack: git-pack-objects died with error.\");\n\t\tgoto fail;\n\t}\n\n\t/* flush the data */\n\tif (output_state->used > 0) {\n\t\tsend_client_data(1, output_state->buffer, output_state->used,\n\t\t\t\t pack_data->use_sideband);\n\t\tfprintf(stderr, \"flushed.\\n\");\n\t}\n\tfree(output_state);\n\tif (pack_data->use_sideband)\n\t\tpacket_flush(1);\n\treturn;\n\n fail:\n\tfree(output_state);\n\tsend_client_data(3, abort_msg, strlen(abort_msg),\n\t\t\t pack_data->use_sideband);\n\tdie(\"git upload-pack: %s\", abort_msg);\n}\n\nstatic int do_got_oid(struct upload_pack_data *data, const struct object_id *oid)\n{\n\tint we_knew_they_have = 0;\n\tstruct object *o = parse_object_with_flags(the_repository, oid,\n\t\t\t\t\t\t   PARSE_OBJECT_SKIP_HASH_CHECK |\n\t\t\t\t\t\t   PARSE_OBJECT_DISCARD_TREE);\n\n\tif (!o)\n\t\tdie(\"oops (%s)\", oid_to_hex(oid));\n\tif (o->type == OBJ_COMMIT) {\n\t\tstruct commit_list *parents;\n\t\tstruct commit *commit = (struct commit *)o;\n\t\tif (o->flags & THEY_HAVE)\n\t\t\twe_knew_they_have = 1;\n\t\telse\n\t\t\to->flags |= THEY_HAVE;\n\t\tif (!data->oldest_have || (commit->date < data->oldest_have))\n\t\t\tdata->oldest_have = commit->date;\n\t\tfor (parents = commit->parents;\n\t\t     parents;\n\t\t     parents = parents->next)\n\t\t\tparents->item->object.flags |= THEY_HAVE;\n\t}\n\tif (!we_knew_they_have) {\n\t\tadd_object_array(o, NULL, &data->have_obj);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int got_oid(struct upload_pack_data *data,\n\t\t   const char *hex, struct object_id *oid)\n{\n\tif (get_oid_hex(hex, oid))\n\t\tdie(\"git upload-pack: expected SHA1 object, got '%s'\", hex);\n\tif (!repo_has_object_file_with_flags(the_repository, oid,\n\t\t\t\t\t     OBJECT_INFO_QUICK | OBJECT_INFO_SKIP_FETCH_OBJECT))\n\t\treturn -1;\n\treturn do_got_oid(data, oid);\n}\n\nstatic int ok_to_give_up(struct upload_pack_data *data)\n{\n\ttimestamp_t min_generation = GENERATION_NUMBER_ZERO;\n\n\tif (!data->have_obj.nr)\n\t\treturn 0;\n\n\treturn can_all_from_reach_with_flag(&data->want_obj, THEY_HAVE,\n\t\t\t\t\t    COMMON_KNOWN, data->oldest_have,\n\t\t\t\t\t    min_generation);\n}\n\nstatic int get_common_commits(struct upload_pack_data *data,\n\t\t\t      struct packet_reader *reader)\n{\n\tstruct object_id oid;\n\tchar last_hex[GIT_MAX_HEXSZ + 1];\n\tint got_common = 0;\n\tint got_other = 0;\n\tint sent_ready = 0;\n\n\tfor (;;) {\n\t\tconst char *arg;\n\n\t\treset_timeout(data->timeout);\n\n\t\tif (packet_reader_read(reader) != PACKET_READ_NORMAL) {\n\t\t\tif (data->multi_ack == MULTI_ACK_DETAILED\n\t\t\t    && got_common\n\t\t\t    && !got_other\n\t\t\t    && ok_to_give_up(data)) {\n\t\t\t\tsent_ready = 1;\n\t\t\t\tpacket_write_fmt(1, \"ACK %s ready\\n\", last_hex);\n\t\t\t}\n\t\t\tif (data->have_obj.nr == 0 || data->multi_ack)\n\t\t\t\tpacket_write_fmt(1, \"NAK\\n\");\n\n\t\t\tif (data->no_done && sent_ready) {\n\t\t\t\tpacket_write_fmt(1, \"ACK %s\\n\", last_hex);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (data->stateless_rpc)\n\t\t\t\texit(0);\n\t\t\tgot_common = 0;\n\t\t\tgot_other = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (skip_prefix(reader->line, \"have \", &arg)) {\n\t\t\tswitch (got_oid(data, arg, &oid)) {\n\t\t\tcase -1: /* they have what we do not */\n\t\t\t\tgot_other = 1;\n\t\t\t\tif (data->multi_ack\n\t\t\t\t    && ok_to_give_up(data)) {\n\t\t\t\t\tconst char *hex = oid_to_hex(&oid);\n\t\t\t\t\tif (data->multi_ack == MULTI_ACK_DETAILED) {\n\t\t\t\t\t\tsent_ready = 1;\n\t\t\t\t\t\tpacket_write_fmt(1, \"ACK %s ready\\n\", hex);\n\t\t\t\t\t} else\n\t\t\t\t\t\tpacket_write_fmt(1, \"ACK %s continue\\n\", hex);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgot_common = 1;\n\t\t\t\toid_to_hex_r(last_hex, &oid);\n\t\t\t\tif (data->multi_ack == MULTI_ACK_DETAILED)\n\t\t\t\t\tpacket_write_fmt(1, \"ACK %s common\\n\", last_hex);\n\t\t\t\telse if (data->multi_ack)\n\t\t\t\t\tpacket_write_fmt(1, \"ACK %s continue\\n\", last_hex);\n\t\t\t\telse if (data->have_obj.nr == 1)\n\t\t\t\t\tpacket_write_fmt(1, \"ACK %s\\n\", last_hex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(reader->line, \"done\")) {\n\t\t\tif (data->have_obj.nr > 0) {\n\t\t\t\tif (data->multi_ack)\n\t\t\t\t\tpacket_write_fmt(1, \"ACK %s\\n\", last_hex);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpacket_write_fmt(1, \"NAK\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tdie(\"git upload-pack: expected SHA1 list, got '%s'\", reader->line);\n\t}\n}\n\nstatic int allow_hidden_refs(enum allow_uor allow_uor)\n{\n\tif ((allow_uor & ALLOW_ANY_SHA1) == ALLOW_ANY_SHA1)\n\t\treturn 1;\n\treturn !(allow_uor & (ALLOW_TIP_SHA1 | ALLOW_REACHABLE_SHA1));\n}\n\nstatic void for_each_namespaced_ref_1(each_ref_fn fn,\n\t\t\t\t      struct upload_pack_data *data)\n{\n\tconst char **excludes = NULL;\n\t/*\n\t * If `data->allow_uor` allows fetching hidden refs, we need to\n\t * mark all references (including hidden ones), to check in\n\t * `is_our_ref()` below.\n\t *\n\t * Otherwise, we only care about whether each reference's object\n\t * has the OUR_REF bit set or not, so do not need to visit\n\t * hidden references.\n\t */\n\tif (allow_hidden_refs(data->allow_uor))\n\t\texcludes = hidden_refs_to_excludes(&data->hidden_refs);\n\n\trefs_for_each_namespaced_ref(get_main_ref_store(the_repository),\n\t\t\t\t     excludes, fn, data);\n}\n\n\nstatic int is_our_ref(struct object *o, enum allow_uor allow_uor)\n{\n\treturn o->flags & ((allow_hidden_refs(allow_uor) ? 0 : HIDDEN_REF) | OUR_REF);\n}\n\n/*\n * on successful case, it's up to the caller to close cmd->out\n */\nstatic int do_reachable_revlist(struct child_process *cmd,\n\t\t\t\tstruct object_array *src,\n\t\t\t\tstruct object_array *reachable,\n\t\t\t\tenum allow_uor allow_uor)\n{\n\tstruct object *o;\n\tFILE *cmd_in = NULL;\n\tint i;\n\n\tstrvec_pushl(&cmd->args, \"rev-list\", \"--stdin\", NULL);\n\tcmd->git_cmd = 1;\n\tcmd->no_stderr = 1;\n\tcmd->in = -1;\n\tcmd->out = -1;\n\n\t/*\n\t * If the next rev-list --stdin encounters an unknown commit,\n\t * it terminates, which will cause SIGPIPE in the write loop\n\t * below.\n\t */\n\tsigchain_push(SIGPIPE, SIG_IGN);\n\n\tif (start_command(cmd))\n\t\tgoto error;\n\n\tcmd_in = xfdopen(cmd->in, \"w\");\n\n\tfor (i = get_max_object_index(); 0 < i; ) {\n\t\to = get_indexed_object(--i);\n\t\tif (!o)\n\t\t\tcontinue;\n\t\tif (reachable && o->type == OBJ_COMMIT)\n\t\t\to->flags &= ~TMP_MARK;\n\t\tif (!is_our_ref(o, allow_uor))\n\t\t\tcontinue;\n\t\tif (fprintf(cmd_in, \"^%s\\n\", oid_to_hex(&o->oid)) < 0)\n\t\t\tgoto error;\n\t}\n\tfor (i = 0; i < src->nr; i++) {\n\t\to = src->objects[i].item;\n\t\tif (is_our_ref(o, allow_uor)) {\n\t\t\tif (reachable)\n\t\t\t\tadd_object_array(o, NULL, reachable);\n\t\t\tcontinue;\n\t\t}\n\t\tif (reachable && o->type == OBJ_COMMIT)\n\t\t\to->flags |= TMP_MARK;\n\t\tif (fprintf(cmd_in, \"%s\\n\", oid_to_hex(&o->oid)) < 0)\n\t\t\tgoto error;\n\t}\n\tif (ferror(cmd_in) || fflush(cmd_in))\n\t\tgoto error;\n\tfclose(cmd_in);\n\tcmd->in = -1;\n\tsigchain_pop(SIGPIPE);\n\n\treturn 0;\n\nerror:\n\tsigchain_pop(SIGPIPE);\n\n\tif (cmd_in)\n\t\tfclose(cmd_in);\n\tif (cmd->out >= 0)\n\t\tclose(cmd->out);\n\treturn -1;\n}\n\nstatic int get_reachable_list(struct upload_pack_data *data,\n\t\t\t      struct object_array *reachable)\n{\n\tstruct child_process cmd = CHILD_PROCESS_INIT;\n\tint i;\n\tstruct object *o;\n\tchar namebuf[GIT_MAX_HEXSZ + 2]; /* ^ + hash + LF */\n\tconst unsigned hexsz = the_hash_algo->hexsz;\n\n\tif (do_reachable_revlist(&cmd, &data->shallows, reachable,\n\t\t\t\t data->allow_uor) < 0)\n\t\treturn -1;\n\n\twhile ((i = read_in_full(cmd.out, namebuf, hexsz + 1)) == hexsz + 1) {\n\t\tstruct object_id oid;\n\t\tconst char *p;\n\n\t\tif (parse_oid_hex(namebuf, &oid, &p) || *p != '\\n')\n\t\t\tbreak;\n\n\t\to = lookup_object(the_repository, &oid);\n\t\tif (o && o->type == OBJ_COMMIT) {\n\t\t\to->flags &= ~TMP_MARK;\n\t\t}\n\t}\n\tfor (i = get_max_object_index(); 0 < i; i--) {\n\t\to = get_indexed_object(i - 1);\n\t\tif (o && o->type == OBJ_COMMIT &&\n\t\t    (o->flags & TMP_MARK)) {\n\t\t\tadd_object_array(o, NULL, reachable);\n\t\t\t\to->flags &= ~TMP_MARK;\n\t\t}\n\t}\n\tclose(cmd.out);\n\n\tif (finish_command(&cmd))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int has_unreachable(struct object_array *src, enum allow_uor allow_uor)\n{\n\tstruct child_process cmd = CHILD_PROCESS_INIT;\n\tchar buf[1];\n\tint i;\n\n\tif (do_reachable_revlist(&cmd, src, NULL, allow_uor) < 0)\n\t\treturn 1;\n\n\t/*\n\t * The commits out of the rev-list are not ancestors of\n\t * our ref.\n\t */\n\ti = read_in_full(cmd.out, buf, 1);\n\tif (i)\n\t\tgoto error;\n\tclose(cmd.out);\n\tcmd.out = -1;\n\n\t/*\n\t * rev-list may have died by encountering a bad commit\n\t * in the history, in which case we do want to bail out\n\t * even when it showed no commit.\n\t */\n\tif (finish_command(&cmd))\n\t\tgoto error;\n\n\t/* All the non-tip ones are ancestors of what we advertised */\n\treturn 0;\n\nerror:\n\tif (cmd.out >= 0)\n\t\tclose(cmd.out);\n\treturn 1;\n}\n\nstatic void check_non_tip(struct upload_pack_data *data)\n{\n\tint i;\n\n\t/*\n\t * In the normal in-process case without\n\t * uploadpack.allowReachableSHA1InWant,\n\t * non-tip requests can never happen.\n\t */\n\tif (!data->stateless_rpc && !(data->allow_uor & ALLOW_REACHABLE_SHA1))\n\t\tgoto error;\n\tif (!has_unreachable(&data->want_obj, data->allow_uor))\n\t\t/* All the non-tip ones are ancestors of what we advertised */\n\t\treturn;\n\nerror:\n\t/* Pick one of them (we know there at least is one) */\n\tfor (i = 0; i < data->want_obj.nr; i++) {\n\t\tstruct object *o = data->want_obj.objects[i].item;\n\t\tif (!is_our_ref(o, data->allow_uor)) {\n\t\t\terror(\"git upload-pack: not our ref %s\",\n\t\t\t      oid_to_hex(&o->oid));\n\t\t\tpacket_writer_error(&data->writer,\n\t\t\t\t\t    \"upload-pack: not our ref %s\",\n\t\t\t\t\t    oid_to_hex(&o->oid));\n\t\t\texit(128);\n\t\t}\n\t}\n}\n\nstatic void send_shallow(struct upload_pack_data *data,\n\t\t\t struct commit_list *result)\n{\n\twhile (result) {\n\t\tstruct object *object = &result->item->object;\n\t\tif (!(object->flags & (CLIENT_SHALLOW|NOT_SHALLOW))) {\n\t\t\tpacket_writer_write(&data->writer, \"shallow %s\",\n\t\t\t\t\t    oid_to_hex(&object->oid));\n\t\t\tregister_shallow(the_repository, &object->oid);\n\t\t\tdata->shallow_nr++;\n\t\t}\n\t\tresult = result->next;\n\t}\n}\n\nstatic void send_unshallow(struct upload_pack_data *data)\n{\n\tint i;\n\n\tfor (i = 0; i < data->shallows.nr; i++) {\n\t\tstruct object *object = data->shallows.objects[i].item;\n\t\tif (object->flags & NOT_SHALLOW) {\n\t\t\tstruct commit_list *parents;\n\t\t\tpacket_writer_write(&data->writer, \"unshallow %s\",\n\t\t\t\t\t    oid_to_hex(&object->oid));\n\t\t\tobject->flags &= ~CLIENT_SHALLOW;\n\t\t\t/*\n\t\t\t * We want to _register_ \"object\" as shallow, but we\n\t\t\t * also need to traverse object's parents to deepen a\n\t\t\t * shallow clone. Unregister it for now so we can\n\t\t\t * parse and add the parents to the want list, then\n\t\t\t * re-register it.\n\t\t\t */\n\t\t\tunregister_shallow(&object->oid);\n\t\t\tobject->parsed = 0;\n\t\t\tparse_commit_or_die((struct commit *)object);\n\t\t\tparents = ((struct commit *)object)->parents;\n\t\t\twhile (parents) {\n\t\t\t\tadd_object_array(&parents->item->object,\n\t\t\t\t\t\t NULL, &data->want_obj);\n\t\t\t\tparents = parents->next;\n\t\t\t}\n\t\t\tadd_object_array(object, NULL, &data->extra_edge_obj);\n\t\t}\n\t\t/* make sure commit traversal conforms to client */\n\t\tregister_shallow(the_repository, &object->oid);\n\t}\n}\n\nstatic int check_ref(const char *refname_full, const struct object_id *oid,\n\t\t     int flag, void *cb_data);\nstatic void deepen(struct upload_pack_data *data, int depth)\n{\n\tif (depth == INFINITE_DEPTH && !is_repository_shallow(the_repository)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < data->shallows.nr; i++) {\n\t\t\tstruct object *object = data->shallows.objects[i].item;\n\t\t\tobject->flags |= NOT_SHALLOW;\n\t\t}\n\t} else if (data->deepen_relative) {\n\t\tstruct object_array reachable_shallows = OBJECT_ARRAY_INIT;\n\t\tstruct commit_list *result;\n\n\t\t/*\n\t\t * Checking for reachable shallows requires that our refs be\n\t\t * marked with OUR_REF.\n\t\t */\n\t\trefs_head_ref_namespaced(get_main_ref_store(the_repository),\n\t\t\t\t\t check_ref, data);\n\t\tfor_each_namespaced_ref_1(check_ref, data);\n\n\t\tget_reachable_list(data, &reachable_shallows);\n\t\tresult = get_shallow_commits(&reachable_shallows,\n\t\t\t\t\t     depth + 1,\n\t\t\t\t\t     SHALLOW, NOT_SHALLOW);\n\t\tsend_shallow(data, result);\n\t\tfree_commit_list(result);\n\t\tobject_array_clear(&reachable_shallows);\n\t} else {\n\t\tstruct commit_list *result;\n\n\t\tresult = get_shallow_commits(&data->want_obj, depth,\n\t\t\t\t\t     SHALLOW, NOT_SHALLOW);\n\t\tsend_shallow(data, result);\n\t\tfree_commit_list(result);\n\t}\n\n\tsend_unshallow(data);\n}\n\nstatic void deepen_by_rev_list(struct upload_pack_data *data,\n\t\t\t       int ac,\n\t\t\t       const char **av)\n{\n\tstruct commit_list *result;\n\n\tdisable_commit_graph(the_repository);\n\tresult = get_shallow_commits_by_rev_list(ac, av, SHALLOW, NOT_SHALLOW);\n\tsend_shallow(data, result);\n\tfree_commit_list(result);\n\tsend_unshallow(data);\n}\n\n/* Returns 1 if a shallow list is sent or 0 otherwise */\nstatic int send_shallow_list(struct upload_pack_data *data)\n{\n\tint ret = 0;\n\n\tif (data->depth > 0 && data->deepen_rev_list)\n\t\tdie(\"git upload-pack: deepen and deepen-since (or deepen-not) cannot be used together\");\n\tif (data->depth > 0) {\n\t\tdeepen(data, data->depth);\n\t\tret = 1;\n\t} else if (data->deepen_rev_list) {\n\t\tstruct strvec av = STRVEC_INIT;\n\t\tint i;\n\n\t\tstrvec_push(&av, \"rev-list\");\n\t\tif (data->deepen_since)\n\t\t\tstrvec_pushf(&av, \"--max-age=%\"PRItime, data->deepen_since);\n\t\tif (oidset_size(&data->deepen_not)) {\n\t\t\tconst struct object_id *oid;\n\t\t\tstruct oidset_iter iter;\n\t\t\tstrvec_push(&av, \"--not\");\n\t\t\toidset_iter_init(&data->deepen_not, &iter);\n\t\t\twhile ((oid = oidset_iter_next(&iter)))\n\t\t\t\tstrvec_push(&av, oid_to_hex(oid));\n\t\t\tstrvec_push(&av, \"--not\");\n\t\t}\n\t\tfor (i = 0; i < data->want_obj.nr; i++) {\n\t\t\tstruct object *o = data->want_obj.objects[i].item;\n\t\t\tstrvec_push(&av, oid_to_hex(&o->oid));\n\t\t}\n\t\tdeepen_by_rev_list(data, av.nr, av.v);\n\t\tstrvec_clear(&av);\n\t\tret = 1;\n\t} else {\n\t\tif (data->shallows.nr > 0) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < data->shallows.nr; i++)\n\t\t\t\tregister_shallow(the_repository,\n\t\t\t\t\t\t &data->shallows.objects[i].item->oid);\n\t\t}\n\t}\n\n\tdata->shallow_nr += data->shallows.nr;\n\treturn ret;\n}\n\nstatic int process_shallow(const char *line, struct object_array *shallows)\n{\n\tconst char *arg;\n\tif (skip_prefix(line, \"shallow \", &arg)) {\n\t\tstruct object_id oid;\n\t\tstruct object *object;\n\t\tif (get_oid_hex(arg, &oid))\n\t\t\tdie(\"invalid shallow line: %s\", line);\n\t\tobject = parse_object(the_repository, &oid);\n\t\tif (!object)\n\t\t\treturn 1;\n\t\tif (object->type != OBJ_COMMIT)\n\t\t\tdie(\"invalid shallow object %s\", oid_to_hex(&oid));\n\t\tif (!(object->flags & CLIENT_SHALLOW)) {\n\t\t\tobject->flags |= CLIENT_SHALLOW;\n\t\t\tadd_object_array(object, NULL, shallows);\n\t\t}\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int process_deepen(const char *line, int *depth)\n{\n\tconst char *arg;\n\tif (skip_prefix(line, \"deepen \", &arg)) {\n\t\tchar *end = NULL;\n\t\t*depth = (int)strtol(arg, &end, 0);\n\t\tif (!end || *end || *depth <= 0)\n\t\t\tdie(\"Invalid deepen: %s\", line);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int process_deepen_since(const char *line, timestamp_t *deepen_since, int *deepen_rev_list)\n{\n\tconst char *arg;\n\tif (skip_prefix(line, \"deepen-since \", &arg)) {\n\t\tchar *end = NULL;\n\t\t*deepen_since = parse_timestamp(arg, &end, 0);\n\t\tif (!end || *end || !deepen_since ||\n\t\t    /* revisions.c's max_age -1 is special */\n\t\t    *deepen_since == -1)\n\t\t\tdie(\"Invalid deepen-since: %s\", line);\n\t\t*deepen_rev_list = 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int process_deepen_not(const char *line, struct oidset *deepen_not, int *deepen_rev_list)\n{\n\tconst char *arg;\n\tif (skip_prefix(line, \"deepen-not \", &arg)) {\n\t\tchar *ref = NULL;\n\t\tstruct object_id oid;\n\t\tif (expand_ref(the_repository, arg, strlen(arg), &oid, &ref) != 1)\n\t\t\tdie(\"git upload-pack: ambiguous deepen-not: %s\", line);\n\t\toidset_insert(deepen_not, &oid);\n\t\tfree(ref);\n\t\t*deepen_rev_list = 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nNORETURN __attribute__((format(printf,2,3)))\nstatic void send_err_and_die(struct upload_pack_data *data,\n\t\t\t     const char *fmt, ...)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tstrbuf_vaddf(&buf, fmt, ap);\n\tva_end(ap);\n\n\tpacket_writer_error(&data->writer, \"%s\", buf.buf);\n\tdie(\"%s\", buf.buf);\n}\n\nstatic void check_one_filter(struct upload_pack_data *data,\n\t\t\t     struct list_objects_filter_options *opts)\n{\n\tconst char *key = list_object_filter_config_name(opts->choice);\n\tstruct string_list_item *item = string_list_lookup(&data->allowed_filters,\n\t\t\t\t\t\t\t   key);\n\tint allowed;\n\n\tif (item)\n\t\tallowed = (intptr_t)item->util;\n\telse\n\t\tallowed = data->allow_filter_fallback;\n\n\tif (!allowed)\n\t\tsend_err_and_die(data, \"filter '%s' not supported\", key);\n\n\tif (opts->choice == LOFC_TREE_DEPTH &&\n\t    opts->tree_exclude_depth > data->tree_filter_max_depth)\n\t\tsend_err_and_die(data,\n\t\t\t\t \"tree filter allows max depth %lu, but got %lu\",\n\t\t\t\t data->tree_filter_max_depth,\n\t\t\t\t opts->tree_exclude_depth);\n}\n\nstatic void check_filter_recurse(struct upload_pack_data *data,\n\t\t\t\t struct list_objects_filter_options *opts)\n{\n\tsize_t i;\n\n\tcheck_one_filter(data, opts);\n\tif (opts->choice != LOFC_COMBINE)\n\t\treturn;\n\n\tfor (i = 0; i < opts->sub_nr; i++)\n\t\tcheck_filter_recurse(data, &opts->sub[i]);\n}\n\nstatic void die_if_using_banned_filter(struct upload_pack_data *data)\n{\n\tcheck_filter_recurse(data, &data->filter_options);\n}\n\nstatic void receive_needs(struct upload_pack_data *data,\n\t\t\t  struct packet_reader *reader)\n{\n\tint has_non_tip = 0;\n\n\tdata->shallow_nr = 0;\n\tfor (;;) {\n\t\tstruct object *o;\n\t\tconst char *features;\n\t\tstruct object_id oid_buf;\n\t\tconst char *arg;\n\t\tsize_t feature_len;\n\n\t\treset_timeout(data->timeout);\n\t\tif (packet_reader_read(reader) != PACKET_READ_NORMAL)\n\t\t\tbreak;\n\n\t\tif (process_shallow(reader->line, &data->shallows))\n\t\t\tcontinue;\n\t\tif (process_deepen(reader->line, &data->depth))\n\t\t\tcontinue;\n\t\tif (process_deepen_since(reader->line, &data->deepen_since, &data->deepen_rev_list))\n\t\t\tcontinue;\n\t\tif (process_deepen_not(reader->line, &data->deepen_not, &data->deepen_rev_list))\n\t\t\tcontinue;\n\n\t\tif (skip_prefix(reader->line, \"filter \", &arg)) {\n\t\t\tif (!data->filter_capability_requested)\n\t\t\t\tdie(\"git upload-pack: filtering capability not negotiated\");\n\t\t\tlist_objects_filter_die_if_populated(&data->filter_options);\n\t\t\tparse_list_objects_filter(&data->filter_options, arg);\n\t\t\tdie_if_using_banned_filter(data);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!skip_prefix(reader->line, \"want \", &arg) ||\n\t\t    parse_oid_hex(arg, &oid_buf, &features))\n\t\t\tdie(\"git upload-pack: protocol error, \"\n\t\t\t    \"expected to get object ID, not '%s'\", reader->line);\n\n\t\tif (parse_feature_request(features, \"deepen-relative\"))\n\t\t\tdata->deepen_relative = 1;\n\t\tif (parse_feature_request(features, \"multi_ack_detailed\"))\n\t\t\tdata->multi_ack = MULTI_ACK_DETAILED;\n\t\telse if (parse_feature_request(features, \"multi_ack\"))\n\t\t\tdata->multi_ack = MULTI_ACK;\n\t\tif (parse_feature_request(features, \"no-done\"))\n\t\t\tdata->no_done = 1;\n\t\tif (parse_feature_request(features, \"thin-pack\"))\n\t\t\tdata->use_thin_pack = 1;\n\t\tif (parse_feature_request(features, \"ofs-delta\"))\n\t\t\tdata->use_ofs_delta = 1;\n\t\tif (parse_feature_request(features, \"side-band-64k\"))\n\t\t\tdata->use_sideband = LARGE_PACKET_MAX;\n\t\telse if (parse_feature_request(features, \"side-band\"))\n\t\t\tdata->use_sideband = DEFAULT_PACKET_MAX;\n\t\tif (parse_feature_request(features, \"no-progress\"))\n\t\t\tdata->no_progress = 1;\n\t\tif (parse_feature_request(features, \"include-tag\"))\n\t\t\tdata->use_include_tag = 1;\n\t\tif (data->allow_filter &&\n\t\t    parse_feature_request(features, \"filter\"))\n\t\t\tdata->filter_capability_requested = 1;\n\n\t\targ = parse_feature_value(features, \"session-id\", &feature_len, NULL);\n\t\tif (arg) {\n\t\t\tchar *client_sid = xstrndup(arg, feature_len);\n\t\t\ttrace2_data_string(\"transfer\", NULL, \"client-sid\", client_sid);\n\t\t\tfree(client_sid);\n\t\t}\n\n\t\to = parse_object_with_flags(the_repository, &oid_buf,\n\t\t\t\t\t    PARSE_OBJECT_SKIP_HASH_CHECK |\n\t\t\t\t\t    PARSE_OBJECT_DISCARD_TREE);\n\t\tif (!o) {\n\t\t\tpacket_writer_error(&data->writer,\n\t\t\t\t\t    \"upload-pack: not our ref %s\",\n\t\t\t\t\t    oid_to_hex(&oid_buf));\n\t\t\tdie(\"git upload-pack: not our ref %s\",\n\t\t\t    oid_to_hex(&oid_buf));\n\t\t}\n\t\tif (!(o->flags & WANTED)) {\n\t\t\to->flags |= WANTED;\n\t\t\tif (!((data->allow_uor & ALLOW_ANY_SHA1) == ALLOW_ANY_SHA1\n\t\t\t      || is_our_ref(o, data->allow_uor)))\n\t\t\t\thas_non_tip = 1;\n\t\t\tadd_object_array(o, NULL, &data->want_obj);\n\t\t}\n\t}\n\n\t/*\n\t * We have sent all our refs already, and the other end\n\t * should have chosen out of them. When we are operating\n\t * in the stateless RPC mode, however, their choice may\n\t * have been based on the set of older refs advertised\n\t * by another process that handled the initial request.\n\t */\n\tif (has_non_tip)\n\t\tcheck_non_tip(data);\n\n\tif (!data->use_sideband && data->daemon_mode)\n\t\tdata->no_progress = 1;\n\n\tif (data->depth == 0 && !data->deepen_rev_list && data->shallows.nr == 0)\n\t\treturn;\n\n\tif (send_shallow_list(data))\n\t\tpacket_flush(1);\n}\n\n/* return non-zero if the ref is hidden, otherwise 0 */\nstatic int mark_our_ref(const char *refname, const char *refname_full,\n\t\t\tconst struct object_id *oid, const struct strvec *hidden_refs)\n{\n\tstruct object *o = lookup_unknown_object(the_repository, oid);\n\n\tif (ref_is_hidden(refname, refname_full, hidden_refs)) {\n\t\to->flags |= HIDDEN_REF;\n\t\treturn 1;\n\t}\n\to->flags |= OUR_REF;\n\treturn 0;\n}\n\nstatic int check_ref(const char *refname_full, const struct object_id *oid,\n\t\t     int flag UNUSED, void *cb_data)\n{\n\tconst char *refname = strip_namespace(refname_full);\n\tstruct upload_pack_data *data = cb_data;\n\n\tmark_our_ref(refname, refname_full, oid, &data->hidden_refs);\n\treturn 0;\n}\n\nstatic void format_symref_info(struct strbuf *buf, struct string_list *symref)\n{\n\tstruct string_list_item *item;\n\n\tif (!symref->nr)\n\t\treturn;\n\tfor_each_string_list_item(item, symref)\n\t\tstrbuf_addf(buf, \" symref=%s:%s\", item->string, (char *)item->util);\n}\n\nstatic void format_session_id(struct strbuf *buf, struct upload_pack_data *d) {\n\tif (d->advertise_sid)\n\t\tstrbuf_addf(buf, \" session-id=%s\", trace2_session_id());\n}\n\nstatic void write_v0_ref(struct upload_pack_data *data,\n\t\t\tconst char *refname, const char *refname_nons,\n\t\t\tconst struct object_id *oid)\n{\n\tstatic const char *capabilities = \"multi_ack thin-pack side-band\"\n\t\t\" side-band-64k ofs-delta shallow deepen-since deepen-not\"\n\t\t\" deepen-relative no-progress include-tag multi_ack_detailed\";\n\tstruct object_id peeled;\n\n\tif (mark_our_ref(refname_nons, refname, oid, &data->hidden_refs))\n\t\treturn;\n\n\tif (capabilities) {\n\t\tstruct strbuf symref_info = STRBUF_INIT;\n\t\tstruct strbuf session_id = STRBUF_INIT;\n\n\t\tformat_symref_info(&symref_info, &data->symref);\n\t\tformat_session_id(&session_id, data);\n\t\tpacket_fwrite_fmt(stdout, \"%s %s%c%s%s%s%s%s%s%s object-format=%s agent=%s\\n\",\n\t\t\t     oid_to_hex(oid), refname_nons,\n\t\t\t     0, capabilities,\n\t\t\t     (data->allow_uor & ALLOW_TIP_SHA1) ?\n\t\t\t\t     \" allow-tip-sha1-in-want\" : \"\",\n\t\t\t     (data->allow_uor & ALLOW_REACHABLE_SHA1) ?\n\t\t\t\t     \" allow-reachable-sha1-in-want\" : \"\",\n\t\t\t     data->no_done ? \" no-done\" : \"\",\n\t\t\t     symref_info.buf,\n\t\t\t     data->allow_filter ? \" filter\" : \"\",\n\t\t\t     session_id.buf,\n\t\t\t     the_hash_algo->name,\n\t\t\t     git_user_agent_sanitized());\n\t\tstrbuf_release(&symref_info);\n\t\tstrbuf_release(&session_id);\n\t\tdata->sent_capabilities = 1;\n\t} else {\n\t\tpacket_fwrite_fmt(stdout, \"%s %s\\n\", oid_to_hex(oid), refname_nons);\n\t}\n\tcapabilities = NULL;\n\tif (!peel_iterated_oid(the_repository, oid, &peeled))\n\t\tpacket_fwrite_fmt(stdout, \"%s %s^{}\\n\", oid_to_hex(&peeled), refname_nons);\n\treturn;\n}\n\nstatic int send_ref(const char *refname, const struct object_id *oid,\n\t\t    int flag UNUSED, void *cb_data)\n{\n\twrite_v0_ref(cb_data, refname, strip_namespace(refname), oid);\n\treturn 0;\n}\n\nstatic int find_symref(const char *refname,\n\t\t       const struct object_id *oid UNUSED,\n\t\t       int flag, void *cb_data)\n{\n\tconst char *symref_target;\n\tstruct string_list_item *item;\n\n\tif ((flag & REF_ISSYMREF) == 0)\n\t\treturn 0;\n\tsymref_target = refs_resolve_ref_unsafe(get_main_ref_store(the_repository),\n\t\t\t\t\t\trefname, 0, NULL, &flag);\n\tif (!symref_target || (flag & REF_ISSYMREF) == 0)\n\t\tdie(\"'%s' is a symref but it is not?\", refname);\n\titem = string_list_append(cb_data, strip_namespace(refname));\n\titem->util = xstrdup(strip_namespace(symref_target));\n\treturn 0;\n}\n\nstatic int parse_object_filter_config(const char *var, const char *value,\n\t\t\t\t      const struct key_value_info *kvi,\n\t\t\t\t      struct upload_pack_data *data)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *sub, *key;\n\tsize_t sub_len;\n\n\tif (parse_config_key(var, \"uploadpackfilter\", &sub, &sub_len, &key))\n\t\treturn 0;\n\n\tif (!sub) {\n\t\tif (!strcmp(key, \"allow\"))\n\t\t\tdata->allow_filter_fallback = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tstrbuf_add(&buf, sub, sub_len);\n\n\tif (!strcmp(key, \"allow\"))\n\t\tstring_list_insert(&data->allowed_filters, buf.buf)->util =\n\t\t\t(void *)(intptr_t)git_config_bool(var, value);\n\telse if (!strcmp(buf.buf, \"tree\") && !strcmp(key, \"maxdepth\")) {\n\t\tif (!value) {\n\t\t\tstrbuf_release(&buf);\n\t\t\treturn config_error_nonbool(var);\n\t\t}\n\t\tstring_list_insert(&data->allowed_filters, buf.buf)->util =\n\t\t\t(void *)(intptr_t)1;\n\t\tdata->tree_filter_max_depth = git_config_ulong(var, value,\n\t\t\t\t\t\t\t       kvi);\n\t}\n\n\tstrbuf_release(&buf);\n\treturn 0;\n}\n\nstatic int upload_pack_config(const char *var, const char *value,\n\t\t\t      const struct config_context *ctx,\n\t\t\t      void *cb_data)\n{\n\tstruct upload_pack_data *data = cb_data;\n\n\tif (!strcmp(\"uploadpack.allowtipsha1inwant\", var)) {\n\t\tif (git_config_bool(var, value))\n\t\t\tdata->allow_uor |= ALLOW_TIP_SHA1;\n\t\telse\n\t\t\tdata->allow_uor &= ~ALLOW_TIP_SHA1;\n\t} else if (!strcmp(\"uploadpack.allowreachablesha1inwant\", var)) {\n\t\tif (git_config_bool(var, value))\n\t\t\tdata->allow_uor |= ALLOW_REACHABLE_SHA1;\n\t\telse\n\t\t\tdata->allow_uor &= ~ALLOW_REACHABLE_SHA1;\n\t} else if (!strcmp(\"uploadpack.allowanysha1inwant\", var)) {\n\t\tif (git_config_bool(var, value))\n\t\t\tdata->allow_uor |= ALLOW_ANY_SHA1;\n\t\telse\n\t\t\tdata->allow_uor &= ~ALLOW_ANY_SHA1;\n\t} else if (!strcmp(\"uploadpack.keepalive\", var)) {\n\t\tdata->keepalive = git_config_int(var, value, ctx->kvi);\n\t\tif (!data->keepalive)\n\t\t\tdata->keepalive = -1;\n\t} else if (!strcmp(\"uploadpack.allowfilter\", var)) {\n\t\tdata->allow_filter = git_config_bool(var, value);\n\t} else if (!strcmp(\"uploadpack.allowrefinwant\", var)) {\n\t\tdata->allow_ref_in_want = git_config_bool(var, value);\n\t} else if (!strcmp(\"uploadpack.allowsidebandall\", var)) {\n\t\tdata->allow_sideband_all = git_config_bool(var, value);\n\t} else if (!strcmp(\"uploadpack.blobpackfileuri\", var)) {\n\t\tif (value)\n\t\t\tdata->allow_packfile_uris = 1;\n\t} else if (!strcmp(\"core.precomposeunicode\", var)) {\n\t\tprecomposed_unicode = git_config_bool(var, value);\n\t} else if (!strcmp(\"transfer.advertisesid\", var)) {\n\t\tdata->advertise_sid = git_config_bool(var, value);\n\t}\n\n\tif (parse_object_filter_config(var, value, ctx->kvi, data) < 0)\n\t\treturn -1;\n\n\treturn parse_hide_refs_config(var, value, \"uploadpack\", &data->hidden_refs);\n}\n\nstatic int upload_pack_protected_config(const char *var, const char *value,\n\t\t\t\t\tconst struct config_context *ctx UNUSED,\n\t\t\t\t\tvoid *cb_data)\n{\n\tstruct upload_pack_data *data = cb_data;\n\n\tif (!strcmp(\"uploadpack.packobjectshook\", var))\n\t\treturn git_config_string(&data->pack_objects_hook, var, value);\n\treturn 0;\n}\n\nstatic void get_upload_pack_config(struct repository *r,\n\t\t\t\t   struct upload_pack_data *data)\n{\n\trepo_config(r, upload_pack_config, data);\n\tgit_protected_config(upload_pack_protected_config, data);\n\n\tdata->allow_sideband_all |= git_env_bool(\"GIT_TEST_SIDEBAND_ALL\", 0);\n}\n\nvoid upload_pack(const int advertise_refs, const int stateless_rpc,\n\t\t const int timeout)\n{\n\tstruct packet_reader reader;\n\tstruct upload_pack_data data;\n\n\tupload_pack_data_init(&data);\n\tget_upload_pack_config(the_repository, &data);\n\n\tdata.stateless_rpc = stateless_rpc;\n\tdata.timeout = timeout;\n\tif (data.timeout)\n\t\tdata.daemon_mode = 1;\n\n\trefs_head_ref_namespaced(get_main_ref_store(the_repository),\n\t\t\t\t find_symref, &data.symref);\n\n\tif (advertise_refs || !data.stateless_rpc) {\n\t\treset_timeout(data.timeout);\n\t\tif (advertise_refs)\n\t\t\tdata.no_done = 1;\n\t\trefs_head_ref_namespaced(get_main_ref_store(the_repository),\n\t\t\t\t\t send_ref, &data);\n\t\tfor_each_namespaced_ref_1(send_ref, &data);\n\t\tif (!data.sent_capabilities) {\n\t\t\tconst char *refname = \"capabilities^{}\";\n\t\t\twrite_v0_ref(&data, refname, refname, null_oid());\n\t\t}\n\t\t/*\n\t\t * fflush stdout before calling advertise_shallow_grafts because send_ref\n\t\t * uses stdio.\n\t\t */\n\t\tfflush_or_die(stdout);\n\t\tadvertise_shallow_grafts(1);\n\t\tpacket_flush(1);\n\t} else {\n\t\trefs_head_ref_namespaced(get_main_ref_store(the_repository),\n\t\t\t\t\t check_ref, &data);\n\t\tfor_each_namespaced_ref_1(check_ref, &data);\n\t}\n\n\tif (!advertise_refs) {\n\t\tpacket_reader_init(&reader, 0, NULL, 0,\n\t\t\t\t   PACKET_READ_CHOMP_NEWLINE |\n\t\t\t\t   PACKET_READ_DIE_ON_ERR_PACKET);\n\n\t\treceive_needs(&data, &reader);\n\n\t\t/*\n\t\t * An EOF at this exact point in negotiation should be\n\t\t * acceptable from stateless clients as they will consume the\n\t\t * shallow list before doing subsequent rpc with haves/etc.\n\t\t */\n\t\tif (data.stateless_rpc)\n\t\t\treader.options |= PACKET_READ_GENTLE_ON_EOF;\n\n\t\tif (data.want_obj.nr &&\n\t\t    packet_reader_peek(&reader) != PACKET_READ_EOF) {\n\t\t\treader.options &= ~PACKET_READ_GENTLE_ON_EOF;\n\t\t\tget_common_commits(&data, &reader);\n\t\t\tcreate_pack_file(&data, NULL);\n\t\t}\n\t}\n\n\tupload_pack_data_clear(&data);\n}\n\nstatic int parse_want(struct packet_writer *writer, const char *line,\n\t\t      struct object_array *want_obj)\n{\n\tconst char *arg;\n\tif (skip_prefix(line, \"want \", &arg)) {\n\t\tstruct object_id oid;\n\t\tstruct object *o;\n\n\t\tif (get_oid_hex(arg, &oid))\n\t\t\tdie(\"git upload-pack: protocol error, \"\n\t\t\t    \"expected to get oid, not '%s'\", line);\n\n\t\to = parse_object_with_flags(the_repository, &oid,\n\t\t\t\t\t    PARSE_OBJECT_SKIP_HASH_CHECK |\n\t\t\t\t\t    PARSE_OBJECT_DISCARD_TREE);\n\n\t\tif (!o) {\n\t\t\tpacket_writer_error(writer,\n\t\t\t\t\t    \"upload-pack: not our ref %s\",\n\t\t\t\t\t    oid_to_hex(&oid));\n\t\t\tdie(\"git upload-pack: not our ref %s\",\n\t\t\t    oid_to_hex(&oid));\n\t\t}\n\n\t\tif (!(o->flags & WANTED)) {\n\t\t\to->flags |= WANTED;\n\t\t\tadd_object_array(o, NULL, want_obj);\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_want_ref(struct packet_writer *writer, const char *line,\n\t\t\t  struct strmap *wanted_refs,\n\t\t\t  struct strvec *hidden_refs,\n\t\t\t  struct object_array *want_obj)\n{\n\tconst char *refname_nons;\n\tif (skip_prefix(line, \"want-ref \", &refname_nons)) {\n\t\tstruct object_id oid;\n\t\tstruct object *o = NULL;\n\t\tstruct strbuf refname = STRBUF_INIT;\n\n\t\tstrbuf_addf(&refname, \"%s%s\", get_git_namespace(), refname_nons);\n\t\tif (ref_is_hidden(refname_nons, refname.buf, hidden_refs) ||\n\t\t    refs_read_ref(get_main_ref_store(the_repository), refname.buf, &oid)) {\n\t\t\tpacket_writer_error(writer, \"unknown ref %s\", refname_nons);\n\t\t\tdie(\"unknown ref %s\", refname_nons);\n\t\t}\n\t\tstrbuf_release(&refname);\n\n\t\tif (strmap_put(wanted_refs, refname_nons, oiddup(&oid))) {\n\t\t\tpacket_writer_error(writer, \"duplicate want-ref %s\",\n\t\t\t\t\t    refname_nons);\n\t\t\tdie(\"duplicate want-ref %s\", refname_nons);\n\t\t}\n\n\t\tif (!starts_with(refname_nons, \"refs/tags/\")) {\n\t\t\tstruct commit *commit = lookup_commit_in_graph(the_repository, &oid);\n\t\t\tif (commit)\n\t\t\t\to = &commit->object;\n\t\t}\n\n\t\tif (!o)\n\t\t\to = parse_object_or_die(&oid, refname_nons);\n\n\t\tif (!(o->flags & WANTED)) {\n\t\t\to->flags |= WANTED;\n\t\t\tadd_object_array(o, NULL, want_obj);\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_have(const char *line, struct upload_pack_data *data)\n{\n\tconst char *arg;\n\tif (skip_prefix(line, \"have \", &arg)) {\n\t\tstruct object_id oid;\n\n\t\tgot_oid(data, arg, &oid);\n\t\tdata->seen_haves = 1;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void trace2_fetch_info(struct upload_pack_data *data)\n{\n\tstruct json_writer jw = JSON_WRITER_INIT;\n\n\tjw_object_begin(&jw, 0);\n\tjw_object_intmax(&jw, \"haves\", data->have_obj.nr);\n\tjw_object_intmax(&jw, \"wants\", data->want_obj.nr);\n\tjw_object_intmax(&jw, \"want-refs\", strmap_get_size(&data->wanted_refs));\n\tjw_object_intmax(&jw, \"depth\", data->depth);\n\tjw_object_intmax(&jw, \"shallows\", data->shallows.nr);\n\tjw_object_bool(&jw, \"deepen-since\", data->deepen_since);\n\tjw_object_intmax(&jw, \"deepen-not\", oidset_size(&data->deepen_not));\n\tjw_object_bool(&jw, \"deepen-relative\", data->deepen_relative);\n\tif (data->filter_options.choice)\n\t\tjw_object_string(&jw, \"filter\", list_object_filter_config_name(data->filter_options.choice));\n\telse\n\t\tjw_object_null(&jw, \"filter\");\n\tjw_end(&jw);\n\n\ttrace2_data_json(\"upload-pack\", the_repository, \"fetch-info\", &jw);\n\n\tjw_release(&jw);\n}\n\nstatic void process_args(struct packet_reader *request,\n\t\t\t struct upload_pack_data *data)\n{\n\twhile (packet_reader_read(request) == PACKET_READ_NORMAL) {\n\t\tconst char *arg = request->line;\n\t\tconst char *p;\n\n\t\t/* process want */\n\t\tif (parse_want(&data->writer, arg, &data->want_obj))\n\t\t\tcontinue;\n\t\tif (data->allow_ref_in_want &&\n\t\t    parse_want_ref(&data->writer, arg, &data->wanted_refs,\n\t\t\t\t   &data->hidden_refs, &data->want_obj))\n\t\t\tcontinue;\n\t\t/* process have line */\n\t\tif (parse_have(arg, data))\n\t\t\tcontinue;\n\n\t\t/* process args like thin-pack */\n\t\tif (!strcmp(arg, \"thin-pack\")) {\n\t\t\tdata->use_thin_pack = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"ofs-delta\")) {\n\t\t\tdata->use_ofs_delta = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"no-progress\")) {\n\t\t\tdata->no_progress = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"include-tag\")) {\n\t\t\tdata->use_include_tag = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"done\")) {\n\t\t\tdata->done = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"wait-for-done\")) {\n\t\t\tdata->wait_for_done = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Shallow related arguments */\n\t\tif (process_shallow(arg, &data->shallows))\n\t\t\tcontinue;\n\t\tif (process_deepen(arg, &data->depth))\n\t\t\tcontinue;\n\t\tif (process_deepen_since(arg, &data->deepen_since,\n\t\t\t\t\t &data->deepen_rev_list))\n\t\t\tcontinue;\n\t\tif (process_deepen_not(arg, &data->deepen_not,\n\t\t\t\t       &data->deepen_rev_list))\n\t\t\tcontinue;\n\t\tif (!strcmp(arg, \"deepen-relative\")) {\n\t\t\tdata->deepen_relative = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (data->allow_filter && skip_prefix(arg, \"filter \", &p)) {\n\t\t\tlist_objects_filter_die_if_populated(&data->filter_options);\n\t\t\tparse_list_objects_filter(&data->filter_options, p);\n\t\t\tdie_if_using_banned_filter(data);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (data->allow_sideband_all &&\n\t\t    !strcmp(arg, \"sideband-all\")) {\n\t\t\tdata->writer.use_sideband = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (data->allow_packfile_uris &&\n\t\t    skip_prefix(arg, \"packfile-uris \", &p)) {\n\t\t\tif (data->uri_protocols.nr)\n\t\t\t\tsend_err_and_die(data,\n\t\t\t\t\t\t \"multiple packfile-uris lines forbidden\");\n\t\t\tstring_list_split(&data->uri_protocols, p, ',', -1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* ignore unknown lines maybe? */\n\t\tdie(\"unexpected line: '%s'\", arg);\n\t}\n\n\tif (data->uri_protocols.nr && !data->writer.use_sideband)\n\t\tstring_list_clear(&data->uri_protocols, 0);\n\n\tif (request->status != PACKET_READ_FLUSH)\n\t\tdie(_(\"expected flush after fetch arguments\"));\n\n\tif (trace2_is_enabled())\n\t\ttrace2_fetch_info(data);\n}\n\nstatic int send_acks(struct upload_pack_data *data, struct object_array *acks)\n{\n\tint i;\n\n\tpacket_writer_write(&data->writer, \"acknowledgments\\n\");\n\n\t/* Send Acks */\n\tif (!acks->nr)\n\t\tpacket_writer_write(&data->writer, \"NAK\\n\");\n\n\tfor (i = 0; i < acks->nr; i++) {\n\t\tpacket_writer_write(&data->writer, \"ACK %s\\n\",\n\t\t\t\t    oid_to_hex(&acks->objects[i].item->oid));\n\t}\n\n\tif (!data->wait_for_done && ok_to_give_up(data)) {\n\t\t/* Send Ready */\n\t\tpacket_writer_write(&data->writer, \"ready\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int process_haves_and_send_acks(struct upload_pack_data *data)\n{\n\tint ret = 0;\n\n\tif (data->done) {\n\t\tret = 1;\n\t} else if (send_acks(data, &data->have_obj)) {\n\t\tpacket_writer_delim(&data->writer);\n\t\tret = 1;\n\t} else {\n\t\t/* Add Flush */\n\t\tpacket_writer_flush(&data->writer);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic void send_wanted_ref_info(struct upload_pack_data *data)\n{\n\tstruct hashmap_iter iter;\n\tconst struct strmap_entry *e;\n\n\tif (strmap_empty(&data->wanted_refs))\n\t\treturn;\n\n\tpacket_writer_write(&data->writer, \"wanted-refs\\n\");\n\n\tstrmap_for_each_entry(&data->wanted_refs, &iter, e) {\n\t\tpacket_writer_write(&data->writer, \"%s %s\\n\",\n\t\t\t\t    oid_to_hex(e->value),\n\t\t\t\t    e->key);\n\t}\n\n\tpacket_writer_delim(&data->writer);\n}\n\nstatic void send_shallow_info(struct upload_pack_data *data)\n{\n\t/* No shallow info needs to be sent */\n\tif (!data->depth && !data->deepen_rev_list && !data->shallows.nr &&\n\t    !is_repository_shallow(the_repository))\n\t\treturn;\n\n\tpacket_writer_write(&data->writer, \"shallow-info\\n\");\n\n\tif (!send_shallow_list(data) &&\n\t    is_repository_shallow(the_repository))\n\t\tdeepen(data, INFINITE_DEPTH);\n\n\tpacket_delim(1);\n}\n\nenum fetch_state {\n\tFETCH_PROCESS_ARGS = 0,\n\tFETCH_SEND_ACKS,\n\tFETCH_SEND_PACK,\n\tFETCH_DONE,\n};\n\nint upload_pack_v2(struct repository *r, struct packet_reader *request)\n{\n\tenum fetch_state state = FETCH_PROCESS_ARGS;\n\tstruct upload_pack_data data;\n\n\tclear_object_flags(ALL_FLAGS);\n\n\tupload_pack_data_init(&data);\n\tdata.use_sideband = LARGE_PACKET_MAX;\n\tget_upload_pack_config(r, &data);\n\n\twhile (state != FETCH_DONE) {\n\t\tswitch (state) {\n\t\tcase FETCH_PROCESS_ARGS:\n\t\t\tprocess_args(request, &data);\n\n\t\t\tif (!data.want_obj.nr && !data.wait_for_done) {\n\t\t\t\t/*\n\t\t\t\t * Request didn't contain any 'want' lines (and\n\t\t\t\t * the request does not contain\n\t\t\t\t * \"wait-for-done\", in which it is reasonable\n\t\t\t\t * to just send 'have's without 'want's); guess\n\t\t\t\t * they didn't want anything.\n\t\t\t\t */\n\t\t\t\tstate = FETCH_DONE;\n\t\t\t} else if (data.seen_haves) {\n\t\t\t\t/*\n\t\t\t\t * Request had 'have' lines, so lets ACK them.\n\t\t\t\t */\n\t\t\t\tstate = FETCH_SEND_ACKS;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Request had 'want's but no 'have's so we can\n\t\t\t\t * immedietly go to construct and send a pack.\n\t\t\t\t */\n\t\t\t\tstate = FETCH_SEND_PACK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FETCH_SEND_ACKS:\n\t\t\tif (process_haves_and_send_acks(&data))\n\t\t\t\tstate = FETCH_SEND_PACK;\n\t\t\telse\n\t\t\t\tstate = FETCH_DONE;\n\t\t\tbreak;\n\t\tcase FETCH_SEND_PACK:\n\t\t\tsend_wanted_ref_info(&data);\n\t\t\tsend_shallow_info(&data);\n\n\t\t\tif (data.uri_protocols.nr) {\n\t\t\t\tcreate_pack_file(&data, &data.uri_protocols);\n\t\t\t} else {\n\t\t\t\tpacket_writer_write(&data.writer, \"packfile\\n\");\n\t\t\t\tcreate_pack_file(&data, NULL);\n\t\t\t}\n\t\t\tstate = FETCH_DONE;\n\t\t\tbreak;\n\t\tcase FETCH_DONE:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tupload_pack_data_clear(&data);\n\treturn 0;\n}\n\nint upload_pack_advertise(struct repository *r,\n\t\t\t  struct strbuf *value)\n{\n\tstruct upload_pack_data data;\n\n\tupload_pack_data_init(&data);\n\tget_upload_pack_config(r, &data);\n\n\tif (value) {\n\t\tstrbuf_addstr(value, \"shallow wait-for-done\");\n\n\t\tif (data.allow_filter)\n\t\t\tstrbuf_addstr(value, \" filter\");\n\n\t\tif (data.allow_ref_in_want)\n\t\t\tstrbuf_addstr(value, \" ref-in-want\");\n\n\t\tif (data.allow_sideband_all)\n\t\t\tstrbuf_addstr(value, \" sideband-all\");\n\n\t\tif (data.allow_packfile_uris)\n\t\t\tstrbuf_addstr(value, \" packfile-uris\");\n\t}\n\n\tupload_pack_data_clear(&data);\n\n\treturn 1;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0052c6a4dce1fad808a5bdd2c92c0827c5453d18",
  "sha1_ok": true,
  "size": 50261
}
