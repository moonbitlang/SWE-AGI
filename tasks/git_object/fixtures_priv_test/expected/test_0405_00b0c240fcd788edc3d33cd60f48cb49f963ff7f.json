{
  "content": {
    "base64": "I2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb2xvci5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAidXJsbWF0Y2guaCIKCnN0YXRpYyBjb25zdCBjaGFyICpjb25zdCBidWlsdGluX2NvbmZpZ191c2FnZVtdID0gewoJTl8oImdpdCBjb25maWcgW29wdGlvbnNdIiksCglOVUxMCn07CgpzdGF0aWMgY2hhciAqa2V5OwpzdGF0aWMgcmVnZXhfdCAqa2V5X3JlZ2V4cDsKc3RhdGljIHJlZ2V4X3QgKnJlZ2V4cDsKc3RhdGljIGludCBzaG93X2tleXM7CnN0YXRpYyBpbnQgdXNlX2tleV9yZWdleHA7CnN0YXRpYyBpbnQgZG9fYWxsOwpzdGF0aWMgaW50IGRvX25vdF9tYXRjaDsKc3RhdGljIGNoYXIgZGVsaW0gPSAnPSc7CnN0YXRpYyBjaGFyIGtleV9kZWxpbSA9ICcgJzsKc3RhdGljIGNoYXIgdGVybSA9ICdcbic7CgpzdGF0aWMgaW50IHVzZV9nbG9iYWxfY29uZmlnLCB1c2Vfc3lzdGVtX2NvbmZpZywgdXNlX2xvY2FsX2NvbmZpZzsKc3RhdGljIGNvbnN0IGNoYXIgKmdpdmVuX2NvbmZpZ19maWxlOwpzdGF0aWMgY29uc3QgY2hhciAqZ2l2ZW5fY29uZmlnX2Jsb2I7CnN0YXRpYyBpbnQgYWN0aW9ucywgdHlwZXM7CnN0YXRpYyBjb25zdCBjaGFyICpnZXRfY29sb3Jfc2xvdCwgKmdldF9jb2xvcmJvb2xfc2xvdDsKc3RhdGljIGludCBlbmRfbnVsbDsKc3RhdGljIGludCByZXNwZWN0X2luY2x1ZGVzID0gLTE7CgojZGVmaW5lIEFDVElPTl9HRVQgKDE8PDApCiNkZWZpbmUgQUNUSU9OX0dFVF9BTEwgKDE8PDEpCiNkZWZpbmUgQUNUSU9OX0dFVF9SRUdFWFAgKDE8PDIpCiNkZWZpbmUgQUNUSU9OX1JFUExBQ0VfQUxMICgxPDwzKQojZGVmaW5lIEFDVElPTl9BREQgKDE8PDQpCiNkZWZpbmUgQUNUSU9OX1VOU0VUICgxPDw1KQojZGVmaW5lIEFDVElPTl9VTlNFVF9BTEwgKDE8PDYpCiNkZWZpbmUgQUNUSU9OX1JFTkFNRV9TRUNUSU9OICgxPDw3KQojZGVmaW5lIEFDVElPTl9SRU1PVkVfU0VDVElPTiAoMTw8OCkKI2RlZmluZSBBQ1RJT05fTElTVCAoMTw8OSkKI2RlZmluZSBBQ1RJT05fRURJVCAoMTw8MTApCiNkZWZpbmUgQUNUSU9OX1NFVCAoMTw8MTEpCiNkZWZpbmUgQUNUSU9OX1NFVF9BTEwgKDE8PDEyKQojZGVmaW5lIEFDVElPTl9HRVRfQ09MT1IgKDE8PDEzKQojZGVmaW5lIEFDVElPTl9HRVRfQ09MT1JCT09MICgxPDwxNCkKI2RlZmluZSBBQ1RJT05fR0VUX1VSTE1BVENIICgxPDwxNSkKCiNkZWZpbmUgVFlQRV9CT09MICgxPDwwKQojZGVmaW5lIFRZUEVfSU5UICgxPDwxKQojZGVmaW5lIFRZUEVfQk9PTF9PUl9JTlQgKDE8PDIpCiNkZWZpbmUgVFlQRV9QQVRIICgxPDwzKQoKc3RhdGljIHN0cnVjdCBvcHRpb24gYnVpbHRpbl9jb25maWdfb3B0aW9uc1tdID0gewoJT1BUX0dST1VQKE5fKCJDb25maWcgZmlsZSBsb2NhdGlvbiIpKSwKCU9QVF9CT09MKDAsICJnbG9iYWwiLCAmdXNlX2dsb2JhbF9jb25maWcsIE5fKCJ1c2UgZ2xvYmFsIGNvbmZpZyBmaWxlIikpLAoJT1BUX0JPT0woMCwgInN5c3RlbSIsICZ1c2Vfc3lzdGVtX2NvbmZpZywgTl8oInVzZSBzeXN0ZW0gY29uZmlnIGZpbGUiKSksCglPUFRfQk9PTCgwLCAibG9jYWwiLCAmdXNlX2xvY2FsX2NvbmZpZywgTl8oInVzZSByZXBvc2l0b3J5IGNvbmZpZyBmaWxlIikpLAoJT1BUX1NUUklORygnZicsICJmaWxlIiwgJmdpdmVuX2NvbmZpZ19maWxlLCBOXygiZmlsZSIpLCBOXygidXNlIGdpdmVuIGNvbmZpZyBmaWxlIikpLAoJT1BUX1NUUklORygwLCAiYmxvYiIsICZnaXZlbl9jb25maWdfYmxvYiwgTl8oImJsb2ItaWQiKSwgTl8oInJlYWQgY29uZmlnIGZyb20gZ2l2ZW4gYmxvYiBvYmplY3QiKSksCglPUFRfR1JPVVAoTl8oIkFjdGlvbiIpKSwKCU9QVF9CSVQoMCwgImdldCIsICZhY3Rpb25zLCBOXygiZ2V0IHZhbHVlOiBuYW1lIFt2YWx1ZS1yZWdleF0iKSwgQUNUSU9OX0dFVCksCglPUFRfQklUKDAsICJnZXQtYWxsIiwgJmFjdGlvbnMsIE5fKCJnZXQgYWxsIHZhbHVlczoga2V5IFt2YWx1ZS1yZWdleF0iKSwgQUNUSU9OX0dFVF9BTEwpLAoJT1BUX0JJVCgwLCAiZ2V0LXJlZ2V4cCIsICZhY3Rpb25zLCBOXygiZ2V0IHZhbHVlcyBmb3IgcmVnZXhwOiBuYW1lLXJlZ2V4IFt2YWx1ZS1yZWdleF0iKSwgQUNUSU9OX0dFVF9SRUdFWFApLAoJT1BUX0JJVCgwLCAiZ2V0LXVybG1hdGNoIiwgJmFjdGlvbnMsIE5fKCJnZXQgdmFsdWUgc3BlY2lmaWMgZm9yIHRoZSBVUkw6IHNlY3Rpb25bLnZhcl0gVVJMIiksIEFDVElPTl9HRVRfVVJMTUFUQ0gpLAoJT1BUX0JJVCgwLCAicmVwbGFjZS1hbGwiLCAmYWN0aW9ucywgTl8oInJlcGxhY2UgYWxsIG1hdGNoaW5nIHZhcmlhYmxlczogbmFtZSB2YWx1ZSBbdmFsdWVfcmVnZXhdIiksIEFDVElPTl9SRVBMQUNFX0FMTCksCglPUFRfQklUKDAsICJhZGQiLCAmYWN0aW9ucywgTl8oImFkZCBhIG5ldyB2YXJpYWJsZTogbmFtZSB2YWx1ZSIpLCBBQ1RJT05fQUREKSwKCU9QVF9CSVQoMCwgInVuc2V0IiwgJmFjdGlvbnMsIE5fKCJyZW1vdmUgYSB2YXJpYWJsZTogbmFtZSBbdmFsdWUtcmVnZXhdIiksIEFDVElPTl9VTlNFVCksCglPUFRfQklUKDAsICJ1bnNldC1hbGwiLCAmYWN0aW9ucywgTl8oInJlbW92ZSBhbGwgbWF0Y2hlczogbmFtZSBbdmFsdWUtcmVnZXhdIiksIEFDVElPTl9VTlNFVF9BTEwpLAoJT1BUX0JJVCgwLCAicmVuYW1lLXNlY3Rpb24iLCAmYWN0aW9ucywgTl8oInJlbmFtZSBzZWN0aW9uOiBvbGQtbmFtZSBuZXctbmFtZSIpLCBBQ1RJT05fUkVOQU1FX1NFQ1RJT04pLAoJT1BUX0JJVCgwLCAicmVtb3ZlLXNlY3Rpb24iLCAmYWN0aW9ucywgTl8oInJlbW92ZSBhIHNlY3Rpb246IG5hbWUiKSwgQUNUSU9OX1JFTU9WRV9TRUNUSU9OKSwKCU9QVF9CSVQoJ2wnLCAibGlzdCIsICZhY3Rpb25zLCBOXygibGlzdCBhbGwiKSwgQUNUSU9OX0xJU1QpLAoJT1BUX0JJVCgnZScsICJlZGl0IiwgJmFjdGlvbnMsIE5fKCJvcGVuIGFuIGVkaXRvciIpLCBBQ1RJT05fRURJVCksCglPUFRfU1RSSU5HKDAsICJnZXQtY29sb3IiLCAmZ2V0X2NvbG9yX3Nsb3QsIE5fKCJzbG90IiksIE5fKCJmaW5kIHRoZSBjb2xvciBjb25maWd1cmVkOiBbZGVmYXVsdF0iKSksCglPUFRfU1RSSU5HKDAsICJnZXQtY29sb3Jib29sIiwgJmdldF9jb2xvcmJvb2xfc2xvdCwgTl8oInNsb3QiKSwgTl8oImZpbmQgdGhlIGNvbG9yIHNldHRpbmc6IFtzdGRvdXQtaXMtdHR5XSIpKSwKCU9QVF9HUk9VUChOXygiVHlwZSIpKSwKCU9QVF9CSVQoMCwgImJvb2wiLCAmdHlwZXMsIE5fKCJ2YWx1ZSBpcyBcInRydWVcIiBvciBcImZhbHNlXCIiKSwgVFlQRV9CT09MKSwKCU9QVF9CSVQoMCwgImludCIsICZ0eXBlcywgTl8oInZhbHVlIGlzIGRlY2ltYWwgbnVtYmVyIiksIFRZUEVfSU5UKSwKCU9QVF9CSVQoMCwgImJvb2wtb3ItaW50IiwgJnR5cGVzLCBOXygidmFsdWUgaXMgLS1ib29sIG9yIC0taW50IiksIFRZUEVfQk9PTF9PUl9JTlQpLAoJT1BUX0JJVCgwLCAicGF0aCIsICZ0eXBlcywgTl8oInZhbHVlIGlzIGEgcGF0aCAoZmlsZSBvciBkaXJlY3RvcnkgbmFtZSkiKSwgVFlQRV9QQVRIKSwKCU9QVF9HUk9VUChOXygiT3RoZXIiKSksCglPUFRfQk9PTCgneicsICJudWxsIiwgJmVuZF9udWxsLCBOXygidGVybWluYXRlIHZhbHVlcyB3aXRoIE5VTCBieXRlIikpLAoJT1BUX0JPT0woMCwgImluY2x1ZGVzIiwgJnJlc3BlY3RfaW5jbHVkZXMsIE5fKCJyZXNwZWN0IGluY2x1ZGUgZGlyZWN0aXZlcyBvbiBsb29rdXAiKSksCglPUFRfRU5EKCksCn07CgpzdGF0aWMgdm9pZCBjaGVja19hcmdjKGludCBhcmdjLCBpbnQgbWluLCBpbnQgbWF4KSB7CglpZiAoYXJnYyA+PSBtaW4gJiYgYXJnYyA8PSBtYXgpCgkJcmV0dXJuOwoJZXJyb3IoIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMiKTsKCXVzYWdlX3dpdGhfb3B0aW9ucyhidWlsdGluX2NvbmZpZ191c2FnZSwgYnVpbHRpbl9jb25maWdfb3B0aW9ucyk7Cn0KCnN0YXRpYyBpbnQgc2hvd19hbGxfY29uZmlnKGNvbnN0IGNoYXIgKmtleV8sIGNvbnN0IGNoYXIgKnZhbHVlXywgdm9pZCAqY2IpCnsKCWlmICh2YWx1ZV8pCgkJcHJpbnRmKCIlcyVjJXMlYyIsIGtleV8sIGRlbGltLCB2YWx1ZV8sIHRlcm0pOwoJZWxzZQoJCXByaW50ZigiJXMlYyIsIGtleV8sIHRlcm0pOwoJcmV0dXJuIDA7Cn0KCnN0cnVjdCBzdHJidWZfbGlzdCB7CglzdHJ1Y3Qgc3RyYnVmICppdGVtczsKCWludCBucjsKCWludCBhbGxvYzsKfTsKCnN0YXRpYyBpbnQgZm9ybWF0X2NvbmZpZyhzdHJ1Y3Qgc3RyYnVmICpidWYsIGNvbnN0IGNoYXIgKmtleV8sIGNvbnN0IGNoYXIgKnZhbHVlXykKewoJaW50IG11c3RfZnJlZV92cHRyID0gMDsKCWludCBtdXN0X3ByaW50X2RlbGltID0gMDsKCWNoYXIgdmFsdWVbMjU2XTsKCWNvbnN0IGNoYXIgKnZwdHIgPSB2YWx1ZTsKCglzdHJidWZfaW5pdChidWYsIDApOwoKCWlmIChzaG93X2tleXMpIHsKCQlzdHJidWZfYWRkc3RyKGJ1Ziwga2V5Xyk7CgkJbXVzdF9wcmludF9kZWxpbSA9IDE7Cgl9CglpZiAodHlwZXMgPT0gVFlQRV9JTlQpCgkJc3ByaW50Zih2YWx1ZSwgIiUiUFJJZDY0LAoJCQlnaXRfY29uZmlnX2ludDY0KGtleV8sIHZhbHVlXyA/IHZhbHVlXyA6ICIiKSk7CgllbHNlIGlmICh0eXBlcyA9PSBUWVBFX0JPT0wpCgkJdnB0ciA9IGdpdF9jb25maWdfYm9vbChrZXlfLCB2YWx1ZV8pID8gInRydWUiIDogImZhbHNlIjsKCWVsc2UgaWYgKHR5cGVzID09IFRZUEVfQk9PTF9PUl9JTlQpIHsKCQlpbnQgaXNfYm9vbCwgdjsKCQl2ID0gZ2l0X2NvbmZpZ19ib29sX29yX2ludChrZXlfLCB2YWx1ZV8sICZpc19ib29sKTsKCQlpZiAoaXNfYm9vbCkKCQkJdnB0ciA9IHYgPyAidHJ1ZSIgOiAiZmFsc2UiOwoJCWVsc2UKCQkJc3ByaW50Zih2YWx1ZSwgIiVkIiwgdik7Cgl9IGVsc2UgaWYgKHR5cGVzID09IFRZUEVfUEFUSCkgewoJCWlmIChnaXRfY29uZmlnX3BhdGhuYW1lKCZ2cHRyLCBrZXlfLCB2YWx1ZV8pIDwgMCkKCQkJcmV0dXJuIC0xOwoJCW11c3RfZnJlZV92cHRyID0gMTsKCX0gZWxzZSBpZiAodmFsdWVfKSB7CgkJdnB0ciA9IHZhbHVlXzsKCX0gZWxzZSB7CgkJLyogSnVzdCBzaG93IHRoZSBrZXkgbmFtZSAqLwoJCXZwdHIgPSAiIjsKCQltdXN0X3ByaW50X2RlbGltID0gMDsKCX0KCglpZiAobXVzdF9wcmludF9kZWxpbSkKCQlzdHJidWZfYWRkY2goYnVmLCBrZXlfZGVsaW0pOwoJc3RyYnVmX2FkZHN0cihidWYsIHZwdHIpOwoJc3RyYnVmX2FkZGNoKGJ1ZiwgdGVybSk7CgoJaWYgKG11c3RfZnJlZV92cHRyKQoJCWZyZWUoKGNoYXIgKil2cHRyKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGNvbGxlY3RfY29uZmlnKGNvbnN0IGNoYXIgKmtleV8sIGNvbnN0IGNoYXIgKnZhbHVlXywgdm9pZCAqY2IpCnsKCXN0cnVjdCBzdHJidWZfbGlzdCAqdmFsdWVzID0gY2I7CgoJaWYgKCF1c2Vfa2V5X3JlZ2V4cCAmJiBzdHJjbXAoa2V5Xywga2V5KSkKCQlyZXR1cm4gMDsKCWlmICh1c2Vfa2V5X3JlZ2V4cCAmJiByZWdleGVjKGtleV9yZWdleHAsIGtleV8sIDAsIE5VTEwsIDApKQoJCXJldHVybiAwOwoJaWYgKHJlZ2V4cCAhPSBOVUxMICYmCgkgICAgKGRvX25vdF9tYXRjaCBeICEhcmVnZXhlYyhyZWdleHAsICh2YWx1ZV8/dmFsdWVfOiIiKSwgMCwgTlVMTCwgMCkpKQoJCXJldHVybiAwOwoKCUFMTE9DX0dST1codmFsdWVzLT5pdGVtcywgdmFsdWVzLT5uciArIDEsIHZhbHVlcy0+YWxsb2MpOwoKCXJldHVybiBmb3JtYXRfY29uZmlnKCZ2YWx1ZXMtPml0ZW1zW3ZhbHVlcy0+bnIrK10sIGtleV8sIHZhbHVlXyk7Cn0KCnN0YXRpYyBpbnQgZ2V0X3ZhbHVlKGNvbnN0IGNoYXIgKmtleV8sIGNvbnN0IGNoYXIgKnJlZ2V4XykKewoJaW50IHJldCA9IENPTkZJR19HRU5FUklDX0VSUk9SOwoJc3RydWN0IHN0cmJ1Zl9saXN0IHZhbHVlcyA9IHtOVUxMfTsKCWludCBpOwoKCWlmICh1c2Vfa2V5X3JlZ2V4cCkgewoJCWNoYXIgKnRsOwoKCQkvKgoJCSAqIE5FRURTV09SSzogdGhpcyBuYWl2ZSBwYXR0ZXJuIGxvd2VyY2FzaW5nIG9idmlvdXNseSBkb2VzIG5vdAoJCSAqIHdvcmsgZm9yIG1vcmUgY29tcGxleCBwYXR0ZXJucyBsaWtlICJeW14uXSpGb28uKmJhciIuCgkJICogUGVyaGFwcyB3ZSBzaG91bGQgZGVwcmVjYXRlIHRoaXMgYWx0b2dldGhlciBzb21lZGF5LgoJCSAqLwoKCQlrZXkgPSB4c3RyZHVwKGtleV8pOwoJCWZvciAodGwgPSBrZXkgKyBzdHJsZW4oa2V5KSAtIDE7CgkJICAgICB0bCA+PSBrZXkgJiYgKnRsICE9ICcuJzsKCQkgICAgIHRsLS0pCgkJCSp0bCA9IHRvbG93ZXIoKnRsKTsKCQlmb3IgKHRsID0ga2V5OyAqdGwgJiYgKnRsICE9ICcuJzsgdGwrKykKCQkJKnRsID0gdG9sb3dlcigqdGwpOwoKCQlrZXlfcmVnZXhwID0gKHJlZ2V4X3QqKXhtYWxsb2Moc2l6ZW9mKHJlZ2V4X3QpKTsKCQlpZiAocmVnY29tcChrZXlfcmVnZXhwLCBrZXksIFJFR19FWFRFTkRFRCkpIHsKCQkJZnByaW50ZihzdGRlcnIsICJJbnZhbGlkIGtleSBwYXR0ZXJuOiAlc1xuIiwga2V5Xyk7CgkJCWZyZWUoa2V5X3JlZ2V4cCk7CgkJCWtleV9yZWdleHAgPSBOVUxMOwoJCQlyZXQgPSBDT05GSUdfSU5WQUxJRF9QQVRURVJOOwoJCQlnb3RvIGZyZWVfc3RyaW5nczsKCQl9Cgl9IGVsc2UgewoJCWlmIChnaXRfY29uZmlnX3BhcnNlX2tleShrZXlfLCAma2V5LCBOVUxMKSkgewoJCQlyZXQgPSBDT05GSUdfSU5WQUxJRF9LRVk7CgkJCWdvdG8gZnJlZV9zdHJpbmdzOwoJCX0KCX0KCglpZiAocmVnZXhfKSB7CgkJaWYgKHJlZ2V4X1swXSA9PSAnIScpIHsKCQkJZG9fbm90X21hdGNoID0gMTsKCQkJcmVnZXhfKys7CgkJfQoKCQlyZWdleHAgPSAocmVnZXhfdCopeG1hbGxvYyhzaXplb2YocmVnZXhfdCkpOwoJCWlmIChyZWdjb21wKHJlZ2V4cCwgcmVnZXhfLCBSRUdfRVhURU5ERUQpKSB7CgkJCWZwcmludGYoc3RkZXJyLCAiSW52YWxpZCBwYXR0ZXJuOiAlc1xuIiwgcmVnZXhfKTsKCQkJZnJlZShyZWdleHApOwoJCQlyZWdleHAgPSBOVUxMOwoJCQlyZXQgPSBDT05GSUdfSU5WQUxJRF9QQVRURVJOOwoJCQlnb3RvIGZyZWVfc3RyaW5nczsKCQl9Cgl9CgoJZ2l0X2NvbmZpZ193aXRoX29wdGlvbnMoY29sbGVjdF9jb25maWcsICZ2YWx1ZXMsCgkJCQlnaXZlbl9jb25maWdfZmlsZSwgZ2l2ZW5fY29uZmlnX2Jsb2IsCgkJCQlyZXNwZWN0X2luY2x1ZGVzKTsKCglyZXQgPSAhdmFsdWVzLm5yOwoKCWZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubnI7IGkrKykgewoJCXN0cnVjdCBzdHJidWYgKmJ1ZiA9IHZhbHVlcy5pdGVtcyArIGk7CgkJaWYgKGRvX2FsbCB8fCBpID09IHZhbHVlcy5uciAtIDEpCgkJCWZ3cml0ZShidWYtPmJ1ZiwgMSwgYnVmLT5sZW4sIHN0ZG91dCk7CgkJc3RyYnVmX3JlbGVhc2UoYnVmKTsKCX0KCWZyZWUodmFsdWVzLml0ZW1zKTsKCmZyZWVfc3RyaW5nczoKCWZyZWUoa2V5KTsKCWlmIChrZXlfcmVnZXhwKSB7CgkJcmVnZnJlZShrZXlfcmVnZXhwKTsKCQlmcmVlKGtleV9yZWdleHApOwoJfQoJaWYgKHJlZ2V4cCkgewoJCXJlZ2ZyZWUocmVnZXhwKTsKCQlmcmVlKHJlZ2V4cCk7Cgl9CgoJcmV0dXJuIHJldDsKfQoKc3RhdGljIGNoYXIgKm5vcm1hbGl6ZV92YWx1ZShjb25zdCBjaGFyICprZXksIGNvbnN0IGNoYXIgKnZhbHVlKQp7CgljaGFyICpub3JtYWxpemVkOwoKCWlmICghdmFsdWUpCgkJcmV0dXJuIE5VTEw7CgoJaWYgKHR5cGVzID09IDAgfHwgdHlwZXMgPT0gVFlQRV9QQVRIKQoJCS8qCgkJICogV2UgZG9uJ3QgZG8gbm9ybWFsaXphdGlvbiBmb3IgVFlQRV9QQVRIIGhlcmU6IElmCgkJICogdGhlIHBhdGggaXMgbGlrZSB+L2Zvb2Jhci8sIHdlIHByZWZlciB0byBzdG9yZQoJCSAqICJ+L2Zvb2Jhci8iIGluIHRoZSBjb25maWcgZmlsZSwgYW5kIHRvIGV4cGFuZCB0aGUgfgoJCSAqIHdoZW4gcmV0cmlldmluZyB0aGUgdmFsdWUuCgkJICovCgkJbm9ybWFsaXplZCA9IHhzdHJkdXAodmFsdWUpOwoJZWxzZSB7CgkJbm9ybWFsaXplZCA9IHhtYWxsb2MoNjQpOwoJCWlmICh0eXBlcyA9PSBUWVBFX0lOVCkgewoJCQlpbnQ2NF90IHYgPSBnaXRfY29uZmlnX2ludDY0KGtleSwgdmFsdWUpOwoJCQlzcHJpbnRmKG5vcm1hbGl6ZWQsICIlIlBSSWQ2NCwgdik7CgkJfQoJCWVsc2UgaWYgKHR5cGVzID09IFRZUEVfQk9PTCkKCQkJc3ByaW50Zihub3JtYWxpemVkLCAiJXMiLAoJCQkJZ2l0X2NvbmZpZ19ib29sKGtleSwgdmFsdWUpID8gInRydWUiIDogImZhbHNlIik7CgkJZWxzZSBpZiAodHlwZXMgPT0gVFlQRV9CT09MX09SX0lOVCkgewoJCQlpbnQgaXNfYm9vbCwgdjsKCQkJdiA9IGdpdF9jb25maWdfYm9vbF9vcl9pbnQoa2V5LCB2YWx1ZSwgJmlzX2Jvb2wpOwoJCQlpZiAoIWlzX2Jvb2wpCgkJCQlzcHJpbnRmKG5vcm1hbGl6ZWQsICIlZCIsIHYpOwoJCQllbHNlCgkJCQlzcHJpbnRmKG5vcm1hbGl6ZWQsICIlcyIsIHYgPyAidHJ1ZSIgOiAiZmFsc2UiKTsKCQl9Cgl9CgoJcmV0dXJuIG5vcm1hbGl6ZWQ7Cn0KCnN0YXRpYyBpbnQgZ2V0X2NvbG9yX2ZvdW5kOwpzdGF0aWMgY29uc3QgY2hhciAqZ2V0X2NvbG9yX3Nsb3Q7CnN0YXRpYyBjb25zdCBjaGFyICpnZXRfY29sb3Jib29sX3Nsb3Q7CnN0YXRpYyBjaGFyIHBhcnNlZF9jb2xvcltDT0xPUl9NQVhMRU5dOwoKc3RhdGljIGludCBnaXRfZ2V0X2NvbG9yX2NvbmZpZyhjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlLCB2b2lkICpjYikKewoJaWYgKCFzdHJjbXAodmFyLCBnZXRfY29sb3Jfc2xvdCkpIHsKCQlpZiAoIXZhbHVlKQoJCQljb25maWdfZXJyb3Jfbm9uYm9vbCh2YXIpOwoJCWNvbG9yX3BhcnNlKHZhbHVlLCB2YXIsIHBhcnNlZF9jb2xvcik7CgkJZ2V0X2NvbG9yX2ZvdW5kID0gMTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBnZXRfY29sb3IoY29uc3QgY2hhciAqZGVmX2NvbG9yKQp7CglnZXRfY29sb3JfZm91bmQgPSAwOwoJcGFyc2VkX2NvbG9yWzBdID0gJ1wwJzsKCWdpdF9jb25maWdfd2l0aF9vcHRpb25zKGdpdF9nZXRfY29sb3JfY29uZmlnLCBOVUxMLAoJCQkJZ2l2ZW5fY29uZmlnX2ZpbGUsIGdpdmVuX2NvbmZpZ19ibG9iLAoJCQkJcmVzcGVjdF9pbmNsdWRlcyk7CgoJaWYgKCFnZXRfY29sb3JfZm91bmQgJiYgZGVmX2NvbG9yKQoJCWNvbG9yX3BhcnNlKGRlZl9jb2xvciwgImNvbW1hbmQgbGluZSIsIHBhcnNlZF9jb2xvcik7CgoJZnB1dHMocGFyc2VkX2NvbG9yLCBzdGRvdXQpOwp9CgpzdGF0aWMgaW50IGdldF9jb2xvcmJvb2xfZm91bmQ7CnN0YXRpYyBpbnQgZ2V0X2RpZmZfY29sb3JfZm91bmQ7CnN0YXRpYyBpbnQgZ2V0X2NvbG9yX3VpX2ZvdW5kOwpzdGF0aWMgaW50IGdpdF9nZXRfY29sb3Jib29sX2NvbmZpZyhjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlLAoJCXZvaWQgKmNiKQp7CglpZiAoIXN0cmNtcCh2YXIsIGdldF9jb2xvcmJvb2xfc2xvdCkpCgkJZ2V0X2NvbG9yYm9vbF9mb3VuZCA9IGdpdF9jb25maWdfY29sb3Jib29sKHZhciwgdmFsdWUpOwoJZWxzZSBpZiAoIXN0cmNtcCh2YXIsICJkaWZmLmNvbG9yIikpCgkJZ2V0X2RpZmZfY29sb3JfZm91bmQgPSBnaXRfY29uZmlnX2NvbG9yYm9vbCh2YXIsIHZhbHVlKTsKCWVsc2UgaWYgKCFzdHJjbXAodmFyLCAiY29sb3IudWkiKSkKCQlnZXRfY29sb3JfdWlfZm91bmQgPSBnaXRfY29uZmlnX2NvbG9yYm9vbCh2YXIsIHZhbHVlKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdldF9jb2xvcmJvb2woaW50IHByaW50KQp7CglnZXRfY29sb3Jib29sX2ZvdW5kID0gLTE7CglnZXRfZGlmZl9jb2xvcl9mb3VuZCA9IC0xOwoJZ2V0X2NvbG9yX3VpX2ZvdW5kID0gLTE7CglnaXRfY29uZmlnX3dpdGhfb3B0aW9ucyhnaXRfZ2V0X2NvbG9yYm9vbF9jb25maWcsIE5VTEwsCgkJCQlnaXZlbl9jb25maWdfZmlsZSwgZ2l2ZW5fY29uZmlnX2Jsb2IsCgkJCQlyZXNwZWN0X2luY2x1ZGVzKTsKCglpZiAoZ2V0X2NvbG9yYm9vbF9mb3VuZCA8IDApIHsKCQlpZiAoIXN0cmNtcChnZXRfY29sb3Jib29sX3Nsb3QsICJjb2xvci5kaWZmIikpCgkJCWdldF9jb2xvcmJvb2xfZm91bmQgPSBnZXRfZGlmZl9jb2xvcl9mb3VuZDsKCQlpZiAoZ2V0X2NvbG9yYm9vbF9mb3VuZCA8IDApCgkJCWdldF9jb2xvcmJvb2xfZm91bmQgPSBnZXRfY29sb3JfdWlfZm91bmQ7Cgl9CgoJaWYgKGdldF9jb2xvcmJvb2xfZm91bmQgPCAwKQoJCS8qIGRlZmF1bHQgdmFsdWUgaWYgbm9uZSBmb3VuZCBpbiBjb25maWcgKi8KCQlnZXRfY29sb3Jib29sX2ZvdW5kID0gR0lUX0NPTE9SX0FVVE87CgoJZ2V0X2NvbG9yYm9vbF9mb3VuZCA9IHdhbnRfY29sb3IoZ2V0X2NvbG9yYm9vbF9mb3VuZCk7CgoJaWYgKHByaW50KSB7CgkJcHJpbnRmKCIlc1xuIiwgZ2V0X2NvbG9yYm9vbF9mb3VuZCA/ICJ0cnVlIiA6ICJmYWxzZSIpOwoJCXJldHVybiAwOwoJfSBlbHNlCgkJcmV0dXJuIGdldF9jb2xvcmJvb2xfZm91bmQgPyAwIDogMTsKfQoKc3RhdGljIHZvaWQgY2hlY2tfYmxvYl93cml0ZSh2b2lkKQp7CglpZiAoZ2l2ZW5fY29uZmlnX2Jsb2IpCgkJZGllKCJ3cml0aW5nIGNvbmZpZyBibG9icyBpcyBub3Qgc3VwcG9ydGVkIik7Cn0KCnN0cnVjdCB1cmxtYXRjaF9jdXJyZW50X2NhbmRpZGF0ZV92YWx1ZSB7CgljaGFyIHZhbHVlX2lzX251bGw7CglzdHJ1Y3Qgc3RyYnVmIHZhbHVlOwp9OwoKc3RhdGljIGludCB1cmxtYXRjaF9jb2xsZWN0X2ZuKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmNiKQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnZhbHVlcyA9IGNiOwoJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW0gPSBzdHJpbmdfbGlzdF9pbnNlcnQodmFsdWVzLCB2YXIpOwoJc3RydWN0IHVybG1hdGNoX2N1cnJlbnRfY2FuZGlkYXRlX3ZhbHVlICptYXRjaGVkID0gaXRlbS0+dXRpbDsKCglpZiAoIW1hdGNoZWQpIHsKCQltYXRjaGVkID0geG1hbGxvYyhzaXplb2YoKm1hdGNoZWQpKTsKCQlzdHJidWZfaW5pdCgmbWF0Y2hlZC0+dmFsdWUsIDApOwoJCWl0ZW0tPnV0aWwgPSBtYXRjaGVkOwoJfSBlbHNlIHsKCQlzdHJidWZfcmVzZXQoJm1hdGNoZWQtPnZhbHVlKTsKCX0KCglpZiAodmFsdWUpIHsKCQlzdHJidWZfYWRkc3RyKCZtYXRjaGVkLT52YWx1ZSwgdmFsdWUpOwoJCW1hdGNoZWQtPnZhbHVlX2lzX251bGwgPSAwOwoJfSBlbHNlIHsKCQltYXRjaGVkLT52YWx1ZV9pc19udWxsID0gMTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdldF91cmxtYXRjaChjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnVybCkKewoJY2hhciAqc2VjdGlvbl90YWlsOwoJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW07CglzdHJ1Y3QgdXJsbWF0Y2hfY29uZmlnIGNvbmZpZyA9IHsgU1RSSU5HX0xJU1RfSU5JVF9EVVAgfTsKCXN0cnVjdCBzdHJpbmdfbGlzdCB2YWx1ZXMgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCgljb25maWcuY29sbGVjdF9mbiA9IHVybG1hdGNoX2NvbGxlY3RfZm47Cgljb25maWcuY2FzY2FkZV9mbiA9IE5VTEw7Cgljb25maWcuY2IgPSAmdmFsdWVzOwoKCWlmICghdXJsX25vcm1hbGl6ZSh1cmwsICZjb25maWcudXJsKSkKCQlkaWUoIiVzIiwgY29uZmlnLnVybC5lcnIpOwoKCWNvbmZpZy5zZWN0aW9uID0geHN0cmR1cF90b2xvd2VyKHZhcik7CglzZWN0aW9uX3RhaWwgPSBzdHJjaHIoY29uZmlnLnNlY3Rpb24sICcuJyk7CglpZiAoc2VjdGlvbl90YWlsKSB7CgkJKnNlY3Rpb25fdGFpbCA9ICdcMCc7CgkJY29uZmlnLmtleSA9IHNlY3Rpb25fdGFpbCArIDE7CgkJc2hvd19rZXlzID0gMDsKCX0gZWxzZSB7CgkJY29uZmlnLmtleSA9IE5VTEw7CgkJc2hvd19rZXlzID0gMTsKCX0KCglnaXRfY29uZmlnX3dpdGhfb3B0aW9ucyh1cmxtYXRjaF9jb25maWdfZW50cnksICZjb25maWcsCgkJCQlnaXZlbl9jb25maWdfZmlsZSwgTlVMTCwgcmVzcGVjdF9pbmNsdWRlcyk7CgoJZm9yX2VhY2hfc3RyaW5nX2xpc3RfaXRlbShpdGVtLCAmdmFsdWVzKSB7CgkJc3RydWN0IHVybG1hdGNoX2N1cnJlbnRfY2FuZGlkYXRlX3ZhbHVlICptYXRjaGVkID0gaXRlbS0+dXRpbDsKCQlzdHJ1Y3Qgc3RyYnVmIGtleSA9IFNUUkJVRl9JTklUOwoJCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJCXN0cmJ1Zl9hZGRzdHIoJmtleSwgaXRlbS0+c3RyaW5nKTsKCQlmb3JtYXRfY29uZmlnKCZidWYsIGtleS5idWYsCgkJCSAgICAgIG1hdGNoZWQtPnZhbHVlX2lzX251bGwgPyBOVUxMIDogbWF0Y2hlZC0+dmFsdWUuYnVmKTsKCQlmd3JpdGUoYnVmLmJ1ZiwgMSwgYnVmLmxlbiwgc3Rkb3V0KTsKCQlzdHJidWZfcmVsZWFzZSgma2V5KTsKCQlzdHJidWZfcmVsZWFzZSgmYnVmKTsKCgkJc3RyYnVmX3JlbGVhc2UoJm1hdGNoZWQtPnZhbHVlKTsKCX0KCXN0cmluZ19saXN0X2NsZWFyKCZjb25maWcudmFycywgMSk7CglzdHJpbmdfbGlzdF9jbGVhcigmdmFsdWVzLCAxKTsKCWZyZWUoY29uZmlnLnVybC51cmwpOwoKCWZyZWUoKHZvaWQgKiljb25maWcuc2VjdGlvbik7CglyZXR1cm4gMDsKfQoKaW50IGNtZF9jb25maWcoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCWludCBub25naXQgPSAhc3RhcnR1cF9pbmZvLT5oYXZlX3JlcG9zaXRvcnk7CgljaGFyICp2YWx1ZTsKCglnaXZlbl9jb25maWdfZmlsZSA9IGdldGVudihDT05GSUdfRU5WSVJPTk1FTlQpOwoKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgYnVpbHRpbl9jb25maWdfb3B0aW9ucywKCQkJICAgICBidWlsdGluX2NvbmZpZ191c2FnZSwKCQkJICAgICBQQVJTRV9PUFRfU1RPUF9BVF9OT05fT1BUSU9OKTsKCglpZiAodXNlX2dsb2JhbF9jb25maWcgKyB1c2Vfc3lzdGVtX2NvbmZpZyArIHVzZV9sb2NhbF9jb25maWcgKwoJICAgICEhZ2l2ZW5fY29uZmlnX2ZpbGUgKyAhIWdpdmVuX2NvbmZpZ19ibG9iID4gMSkgewoJCWVycm9yKCJvbmx5IG9uZSBjb25maWcgZmlsZSBhdCBhIHRpbWUuIik7CgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGJ1aWx0aW5fY29uZmlnX3VzYWdlLCBidWlsdGluX2NvbmZpZ19vcHRpb25zKTsKCX0KCglpZiAodXNlX2dsb2JhbF9jb25maWcpIHsKCQljaGFyICp1c2VyX2NvbmZpZyA9IE5VTEw7CgkJY2hhciAqeGRnX2NvbmZpZyA9IE5VTEw7CgoJCWhvbWVfY29uZmlnX3BhdGhzKCZ1c2VyX2NvbmZpZywgJnhkZ19jb25maWcsICJjb25maWciKTsKCgkJaWYgKCF1c2VyX2NvbmZpZykKCQkJLyoKCQkJICogSXQgaXMgdW5rbm93biBpZiBIT01FLy5naXRjb25maWcgZXhpc3RzLCBzbwoJCQkgKiB3ZSBkbyBub3Qga25vdyBpZiB3ZSBzaG91bGQgd3JpdGUgdG8gWERHCgkJCSAqIGxvY2F0aW9uOyBlcnJvciBvdXQgZXZlbiBpZiBYREdfQ09ORklHX0hPTUUKCQkJICogaXMgc2V0IGFuZCBwb2ludHMgYXQgYSBzYW5lIGxvY2F0aW9uLgoJCQkgKi8KCQkJZGllKCIkSE9NRSBub3Qgc2V0Iik7CgoJCWlmIChhY2Nlc3Nfb3Jfd2Fybih1c2VyX2NvbmZpZywgUl9PSywgMCkgJiYKCQkgICAgeGRnX2NvbmZpZyAmJiAhYWNjZXNzX29yX3dhcm4oeGRnX2NvbmZpZywgUl9PSywgMCkpCgkJCWdpdmVuX2NvbmZpZ19maWxlID0geGRnX2NvbmZpZzsKCQllbHNlCgkJCWdpdmVuX2NvbmZpZ19maWxlID0gdXNlcl9jb25maWc7Cgl9CgllbHNlIGlmICh1c2Vfc3lzdGVtX2NvbmZpZykKCQlnaXZlbl9jb25maWdfZmlsZSA9IGdpdF9ldGNfZ2l0Y29uZmlnKCk7CgllbHNlIGlmICh1c2VfbG9jYWxfY29uZmlnKQoJCWdpdmVuX2NvbmZpZ19maWxlID0gZ2l0X3BhdGhkdXAoImNvbmZpZyIpOwoJZWxzZSBpZiAoZ2l2ZW5fY29uZmlnX2ZpbGUpIHsKCQlpZiAoIWlzX2Fic29sdXRlX3BhdGgoZ2l2ZW5fY29uZmlnX2ZpbGUpICYmIHByZWZpeCkKCQkJZ2l2ZW5fY29uZmlnX2ZpbGUgPQoJCQkJeHN0cmR1cChwcmVmaXhfZmlsZW5hbWUocHJlZml4LAoJCQkJCQkJc3RybGVuKHByZWZpeCksCgkJCQkJCQlnaXZlbl9jb25maWdfZmlsZSkpOwoJfQoKCWlmIChyZXNwZWN0X2luY2x1ZGVzID09IC0xKQoJCXJlc3BlY3RfaW5jbHVkZXMgPSAhZ2l2ZW5fY29uZmlnX2ZpbGU7CgoJaWYgKGVuZF9udWxsKSB7CgkJdGVybSA9ICdcMCc7CgkJZGVsaW0gPSAnXG4nOwoJCWtleV9kZWxpbSA9ICdcbic7Cgl9CgoJaWYgKEhBU19NVUxUSV9CSVRTKHR5cGVzKSkgewoJCWVycm9yKCJvbmx5IG9uZSB0eXBlIGF0IGEgdGltZS4iKTsKCQl1c2FnZV93aXRoX29wdGlvbnMoYnVpbHRpbl9jb25maWdfdXNhZ2UsIGJ1aWx0aW5fY29uZmlnX29wdGlvbnMpOwoJfQoKCWlmIChnZXRfY29sb3Jfc2xvdCkKCSAgICBhY3Rpb25zIHw9IEFDVElPTl9HRVRfQ09MT1I7CglpZiAoZ2V0X2NvbG9yYm9vbF9zbG90KQoJICAgIGFjdGlvbnMgfD0gQUNUSU9OX0dFVF9DT0xPUkJPT0w7CgoJaWYgKChnZXRfY29sb3Jfc2xvdCB8fCBnZXRfY29sb3Jib29sX3Nsb3QpICYmIHR5cGVzKSB7CgkJZXJyb3IoIi0tZ2V0LWNvbG9yIGFuZCB2YXJpYWJsZSB0eXBlIGFyZSBpbmNvaGVyZW50Iik7CgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGJ1aWx0aW5fY29uZmlnX3VzYWdlLCBidWlsdGluX2NvbmZpZ19vcHRpb25zKTsKCX0KCglpZiAoSEFTX01VTFRJX0JJVFMoYWN0aW9ucykpIHsKCQllcnJvcigib25seSBvbmUgYWN0aW9uIGF0IGEgdGltZS4iKTsKCQl1c2FnZV93aXRoX29wdGlvbnMoYnVpbHRpbl9jb25maWdfdXNhZ2UsIGJ1aWx0aW5fY29uZmlnX29wdGlvbnMpOwoJfQoJaWYgKGFjdGlvbnMgPT0gMCkKCQlzd2l0Y2ggKGFyZ2MpIHsKCQljYXNlIDE6IGFjdGlvbnMgPSBBQ1RJT05fR0VUOyBicmVhazsKCQljYXNlIDI6IGFjdGlvbnMgPSBBQ1RJT05fU0VUOyBicmVhazsKCQljYXNlIDM6IGFjdGlvbnMgPSBBQ1RJT05fU0VUX0FMTDsgYnJlYWs7CgkJZGVmYXVsdDoKCQkJdXNhZ2Vfd2l0aF9vcHRpb25zKGJ1aWx0aW5fY29uZmlnX3VzYWdlLCBidWlsdGluX2NvbmZpZ19vcHRpb25zKTsKCQl9CgoJaWYgKGFjdGlvbnMgPT0gQUNUSU9OX0xJU1QpIHsKCQljaGVja19hcmdjKGFyZ2MsIDAsIDApOwoJCWlmIChnaXRfY29uZmlnX3dpdGhfb3B0aW9ucyhzaG93X2FsbF9jb25maWcsIE5VTEwsCgkJCQkJICAgIGdpdmVuX2NvbmZpZ19maWxlLAoJCQkJCSAgICBnaXZlbl9jb25maWdfYmxvYiwKCQkJCQkgICAgcmVzcGVjdF9pbmNsdWRlcykgPCAwKSB7CgkJCWlmIChnaXZlbl9jb25maWdfZmlsZSkKCQkJCWRpZV9lcnJubygidW5hYmxlIHRvIHJlYWQgY29uZmlnIGZpbGUgJyVzJyIsCgkJCQkJICBnaXZlbl9jb25maWdfZmlsZSk7CgkJCWVsc2UKCQkJCWRpZSgiZXJyb3IgcHJvY2Vzc2luZyBjb25maWcgZmlsZShzKSIpOwoJCX0KCX0KCWVsc2UgaWYgKGFjdGlvbnMgPT0gQUNUSU9OX0VESVQpIHsKCQljaGVja19hcmdjKGFyZ2MsIDAsIDApOwoJCWlmICghZ2l2ZW5fY29uZmlnX2ZpbGUgJiYgbm9uZ2l0KQoJCQlkaWUoIm5vdCBpbiBhIGdpdCBkaXJlY3RvcnkiKTsKCQlpZiAoZ2l2ZW5fY29uZmlnX2Jsb2IpCgkJCWRpZSgiZWRpdGluZyBibG9icyBpcyBub3Qgc3VwcG9ydGVkIik7CgkJZ2l0X2NvbmZpZyhnaXRfZGVmYXVsdF9jb25maWcsIE5VTEwpOwoJCWxhdW5jaF9lZGl0b3IoZ2l2ZW5fY29uZmlnX2ZpbGUgPwoJCQkgICAgICBnaXZlbl9jb25maWdfZmlsZSA6IGdpdF9wYXRoKCJjb25maWciKSwKCQkJICAgICAgTlVMTCwgTlVMTCk7Cgl9CgllbHNlIGlmIChhY3Rpb25zID09IEFDVElPTl9TRVQpIHsKCQlpbnQgcmV0OwoJCWNoZWNrX2Jsb2Jfd3JpdGUoKTsKCQljaGVja19hcmdjKGFyZ2MsIDIsIDIpOwoJCXZhbHVlID0gbm9ybWFsaXplX3ZhbHVlKGFyZ3ZbMF0sIGFyZ3ZbMV0pOwoJCXJldCA9IGdpdF9jb25maWdfc2V0X2luX2ZpbGUoZ2l2ZW5fY29uZmlnX2ZpbGUsIGFyZ3ZbMF0sIHZhbHVlKTsKCQlpZiAocmV0ID09IENPTkZJR19OT1RISU5HX1NFVCkKCQkJZXJyb3IoImNhbm5vdCBvdmVyd3JpdGUgbXVsdGlwbGUgdmFsdWVzIHdpdGggYSBzaW5nbGUgdmFsdWVcbiIKCQkJIiAgICAgICBVc2UgYSByZWdleHAsIC0tYWRkIG9yIC0tcmVwbGFjZS1hbGwgdG8gY2hhbmdlICVzLiIsIGFyZ3ZbMF0pOwoJCXJldHVybiByZXQ7Cgl9CgllbHNlIGlmIChhY3Rpb25zID09IEFDVElPTl9TRVRfQUxMKSB7CgkJY2hlY2tfYmxvYl93cml0ZSgpOwoJCWNoZWNrX2FyZ2MoYXJnYywgMiwgMyk7CgkJdmFsdWUgPSBub3JtYWxpemVfdmFsdWUoYXJndlswXSwgYXJndlsxXSk7CgkJcmV0dXJuIGdpdF9jb25maWdfc2V0X211bHRpdmFyX2luX2ZpbGUoZ2l2ZW5fY29uZmlnX2ZpbGUsCgkJCQkJCSAgICAgICBhcmd2WzBdLCB2YWx1ZSwgYXJndlsyXSwgMCk7Cgl9CgllbHNlIGlmIChhY3Rpb25zID09IEFDVElPTl9BREQpIHsKCQljaGVja19ibG9iX3dyaXRlKCk7CgkJY2hlY2tfYXJnYyhhcmdjLCAyLCAyKTsKCQl2YWx1ZSA9IG5vcm1hbGl6ZV92YWx1ZShhcmd2WzBdLCBhcmd2WzFdKTsKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zZXRfbXVsdGl2YXJfaW5fZmlsZShnaXZlbl9jb25maWdfZmlsZSwKCQkJCQkJICAgICAgIGFyZ3ZbMF0sIHZhbHVlLCAiXiQiLCAwKTsKCX0KCWVsc2UgaWYgKGFjdGlvbnMgPT0gQUNUSU9OX1JFUExBQ0VfQUxMKSB7CgkJY2hlY2tfYmxvYl93cml0ZSgpOwoJCWNoZWNrX2FyZ2MoYXJnYywgMiwgMyk7CgkJdmFsdWUgPSBub3JtYWxpemVfdmFsdWUoYXJndlswXSwgYXJndlsxXSk7CgkJcmV0dXJuIGdpdF9jb25maWdfc2V0X211bHRpdmFyX2luX2ZpbGUoZ2l2ZW5fY29uZmlnX2ZpbGUsCgkJCQkJCSAgICAgICBhcmd2WzBdLCB2YWx1ZSwgYXJndlsyXSwgMSk7Cgl9CgllbHNlIGlmIChhY3Rpb25zID09IEFDVElPTl9HRVQpIHsKCQljaGVja19hcmdjKGFyZ2MsIDEsIDIpOwoJCXJldHVybiBnZXRfdmFsdWUoYXJndlswXSwgYXJndlsxXSk7Cgl9CgllbHNlIGlmIChhY3Rpb25zID09IEFDVElPTl9HRVRfQUxMKSB7CgkJZG9fYWxsID0gMTsKCQljaGVja19hcmdjKGFyZ2MsIDEsIDIpOwoJCXJldHVybiBnZXRfdmFsdWUoYXJndlswXSwgYXJndlsxXSk7Cgl9CgllbHNlIGlmIChhY3Rpb25zID09IEFDVElPTl9HRVRfUkVHRVhQKSB7CgkJc2hvd19rZXlzID0gMTsKCQl1c2Vfa2V5X3JlZ2V4cCA9IDE7CgkJZG9fYWxsID0gMTsKCQljaGVja19hcmdjKGFyZ2MsIDEsIDIpOwoJCXJldHVybiBnZXRfdmFsdWUoYXJndlswXSwgYXJndlsxXSk7Cgl9CgllbHNlIGlmIChhY3Rpb25zID09IEFDVElPTl9HRVRfVVJMTUFUQ0gpIHsKCQljaGVja19hcmdjKGFyZ2MsIDIsIDIpOwoJCXJldHVybiBnZXRfdXJsbWF0Y2goYXJndlswXSwgYXJndlsxXSk7Cgl9CgllbHNlIGlmIChhY3Rpb25zID09IEFDVElPTl9VTlNFVCkgewoJCWNoZWNrX2Jsb2Jfd3JpdGUoKTsKCQljaGVja19hcmdjKGFyZ2MsIDEsIDIpOwoJCWlmIChhcmdjID09IDIpCgkJCXJldHVybiBnaXRfY29uZmlnX3NldF9tdWx0aXZhcl9pbl9maWxlKGdpdmVuX2NvbmZpZ19maWxlLAoJCQkJCQkJICAgICAgIGFyZ3ZbMF0sIE5VTEwsIGFyZ3ZbMV0sIDApOwoJCWVsc2UKCQkJcmV0dXJuIGdpdF9jb25maWdfc2V0X2luX2ZpbGUoZ2l2ZW5fY29uZmlnX2ZpbGUsCgkJCQkJCSAgICAgIGFyZ3ZbMF0sIE5VTEwpOwoJfQoJZWxzZSBpZiAoYWN0aW9ucyA9PSBBQ1RJT05fVU5TRVRfQUxMKSB7CgkJY2hlY2tfYmxvYl93cml0ZSgpOwoJCWNoZWNrX2FyZ2MoYXJnYywgMSwgMik7CgkJcmV0dXJuIGdpdF9jb25maWdfc2V0X211bHRpdmFyX2luX2ZpbGUoZ2l2ZW5fY29uZmlnX2ZpbGUsCgkJCQkJCSAgICAgICBhcmd2WzBdLCBOVUxMLCBhcmd2WzFdLCAxKTsKCX0KCWVsc2UgaWYgKGFjdGlvbnMgPT0gQUNUSU9OX1JFTkFNRV9TRUNUSU9OKSB7CgkJaW50IHJldDsKCQljaGVja19ibG9iX3dyaXRlKCk7CgkJY2hlY2tfYXJnYyhhcmdjLCAyLCAyKTsKCQlyZXQgPSBnaXRfY29uZmlnX3JlbmFtZV9zZWN0aW9uX2luX2ZpbGUoZ2l2ZW5fY29uZmlnX2ZpbGUsCgkJCQkJCQlhcmd2WzBdLCBhcmd2WzFdKTsKCQlpZiAocmV0IDwgMCkKCQkJcmV0dXJuIHJldDsKCQlpZiAocmV0ID09IDApCgkJCWRpZSgiTm8gc3VjaCBzZWN0aW9uISIpOwoJfQoJZWxzZSBpZiAoYWN0aW9ucyA9PSBBQ1RJT05fUkVNT1ZFX1NFQ1RJT04pIHsKCQlpbnQgcmV0OwoJCWNoZWNrX2Jsb2Jfd3JpdGUoKTsKCQljaGVja19hcmdjKGFyZ2MsIDEsIDEpOwoJCXJldCA9IGdpdF9jb25maWdfcmVuYW1lX3NlY3Rpb25faW5fZmlsZShnaXZlbl9jb25maWdfZmlsZSwKCQkJCQkJCWFyZ3ZbMF0sIE5VTEwpOwoJCWlmIChyZXQgPCAwKQoJCQlyZXR1cm4gcmV0OwoJCWlmIChyZXQgPT0gMCkKCQkJZGllKCJObyBzdWNoIHNlY3Rpb24hIik7Cgl9CgllbHNlIGlmIChhY3Rpb25zID09IEFDVElPTl9HRVRfQ09MT1IpIHsKCQlnZXRfY29sb3IoYXJndlswXSk7Cgl9CgllbHNlIGlmIChhY3Rpb25zID09IEFDVElPTl9HRVRfQ09MT1JCT09MKSB7CgkJaWYgKGFyZ2MgPT0gMSkKCQkJY29sb3Jfc3Rkb3V0X2lzX3R0eSA9IGdpdF9jb25maWdfYm9vbCgiY29tbWFuZCBsaW5lIiwgYXJndlswXSk7CgkJcmV0dXJuIGdldF9jb2xvcmJvb2woYXJnYyAhPSAwKTsKCX0KCglyZXR1cm4gMDsKfQoKaW50IGNtZF9yZXBvX2NvbmZpZyhpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJZnByaW50ZihzdGRlcnIsICJXQVJOSU5HOiBnaXQgcmVwby1jb25maWcgaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBnaXQgY29uZmlnLlxuIik7CglyZXR1cm4gY21kX2NvbmZpZyhhcmdjLCBhcmd2LCBwcmVmaXgpOwp9Cg==",
    "text": "#include \"builtin.h\"\n#include \"cache.h\"\n#include \"color.h\"\n#include \"parse-options.h\"\n#include \"urlmatch.h\"\n\nstatic const char *const builtin_config_usage[] = {\n\tN_(\"git config [options]\"),\n\tNULL\n};\n\nstatic char *key;\nstatic regex_t *key_regexp;\nstatic regex_t *regexp;\nstatic int show_keys;\nstatic int use_key_regexp;\nstatic int do_all;\nstatic int do_not_match;\nstatic char delim = '=';\nstatic char key_delim = ' ';\nstatic char term = '\\n';\n\nstatic int use_global_config, use_system_config, use_local_config;\nstatic const char *given_config_file;\nstatic const char *given_config_blob;\nstatic int actions, types;\nstatic const char *get_color_slot, *get_colorbool_slot;\nstatic int end_null;\nstatic int respect_includes = -1;\n\n#define ACTION_GET (1<<0)\n#define ACTION_GET_ALL (1<<1)\n#define ACTION_GET_REGEXP (1<<2)\n#define ACTION_REPLACE_ALL (1<<3)\n#define ACTION_ADD (1<<4)\n#define ACTION_UNSET (1<<5)\n#define ACTION_UNSET_ALL (1<<6)\n#define ACTION_RENAME_SECTION (1<<7)\n#define ACTION_REMOVE_SECTION (1<<8)\n#define ACTION_LIST (1<<9)\n#define ACTION_EDIT (1<<10)\n#define ACTION_SET (1<<11)\n#define ACTION_SET_ALL (1<<12)\n#define ACTION_GET_COLOR (1<<13)\n#define ACTION_GET_COLORBOOL (1<<14)\n#define ACTION_GET_URLMATCH (1<<15)\n\n#define TYPE_BOOL (1<<0)\n#define TYPE_INT (1<<1)\n#define TYPE_BOOL_OR_INT (1<<2)\n#define TYPE_PATH (1<<3)\n\nstatic struct option builtin_config_options[] = {\n\tOPT_GROUP(N_(\"Config file location\")),\n\tOPT_BOOL(0, \"global\", &use_global_config, N_(\"use global config file\")),\n\tOPT_BOOL(0, \"system\", &use_system_config, N_(\"use system config file\")),\n\tOPT_BOOL(0, \"local\", &use_local_config, N_(\"use repository config file\")),\n\tOPT_STRING('f', \"file\", &given_config_file, N_(\"file\"), N_(\"use given config file\")),\n\tOPT_STRING(0, \"blob\", &given_config_blob, N_(\"blob-id\"), N_(\"read config from given blob object\")),\n\tOPT_GROUP(N_(\"Action\")),\n\tOPT_BIT(0, \"get\", &actions, N_(\"get value: name [value-regex]\"), ACTION_GET),\n\tOPT_BIT(0, \"get-all\", &actions, N_(\"get all values: key [value-regex]\"), ACTION_GET_ALL),\n\tOPT_BIT(0, \"get-regexp\", &actions, N_(\"get values for regexp: name-regex [value-regex]\"), ACTION_GET_REGEXP),\n\tOPT_BIT(0, \"get-urlmatch\", &actions, N_(\"get value specific for the URL: section[.var] URL\"), ACTION_GET_URLMATCH),\n\tOPT_BIT(0, \"replace-all\", &actions, N_(\"replace all matching variables: name value [value_regex]\"), ACTION_REPLACE_ALL),\n\tOPT_BIT(0, \"add\", &actions, N_(\"add a new variable: name value\"), ACTION_ADD),\n\tOPT_BIT(0, \"unset\", &actions, N_(\"remove a variable: name [value-regex]\"), ACTION_UNSET),\n\tOPT_BIT(0, \"unset-all\", &actions, N_(\"remove all matches: name [value-regex]\"), ACTION_UNSET_ALL),\n\tOPT_BIT(0, \"rename-section\", &actions, N_(\"rename section: old-name new-name\"), ACTION_RENAME_SECTION),\n\tOPT_BIT(0, \"remove-section\", &actions, N_(\"remove a section: name\"), ACTION_REMOVE_SECTION),\n\tOPT_BIT('l', \"list\", &actions, N_(\"list all\"), ACTION_LIST),\n\tOPT_BIT('e', \"edit\", &actions, N_(\"open an editor\"), ACTION_EDIT),\n\tOPT_STRING(0, \"get-color\", &get_color_slot, N_(\"slot\"), N_(\"find the color configured: [default]\")),\n\tOPT_STRING(0, \"get-colorbool\", &get_colorbool_slot, N_(\"slot\"), N_(\"find the color setting: [stdout-is-tty]\")),\n\tOPT_GROUP(N_(\"Type\")),\n\tOPT_BIT(0, \"bool\", &types, N_(\"value is \\\"true\\\" or \\\"false\\\"\"), TYPE_BOOL),\n\tOPT_BIT(0, \"int\", &types, N_(\"value is decimal number\"), TYPE_INT),\n\tOPT_BIT(0, \"bool-or-int\", &types, N_(\"value is --bool or --int\"), TYPE_BOOL_OR_INT),\n\tOPT_BIT(0, \"path\", &types, N_(\"value is a path (file or directory name)\"), TYPE_PATH),\n\tOPT_GROUP(N_(\"Other\")),\n\tOPT_BOOL('z', \"null\", &end_null, N_(\"terminate values with NUL byte\")),\n\tOPT_BOOL(0, \"includes\", &respect_includes, N_(\"respect include directives on lookup\")),\n\tOPT_END(),\n};\n\nstatic void check_argc(int argc, int min, int max) {\n\tif (argc >= min && argc <= max)\n\t\treturn;\n\terror(\"wrong number of arguments\");\n\tusage_with_options(builtin_config_usage, builtin_config_options);\n}\n\nstatic int show_all_config(const char *key_, const char *value_, void *cb)\n{\n\tif (value_)\n\t\tprintf(\"%s%c%s%c\", key_, delim, value_, term);\n\telse\n\t\tprintf(\"%s%c\", key_, term);\n\treturn 0;\n}\n\nstruct strbuf_list {\n\tstruct strbuf *items;\n\tint nr;\n\tint alloc;\n};\n\nstatic int format_config(struct strbuf *buf, const char *key_, const char *value_)\n{\n\tint must_free_vptr = 0;\n\tint must_print_delim = 0;\n\tchar value[256];\n\tconst char *vptr = value;\n\n\tstrbuf_init(buf, 0);\n\n\tif (show_keys) {\n\t\tstrbuf_addstr(buf, key_);\n\t\tmust_print_delim = 1;\n\t}\n\tif (types == TYPE_INT)\n\t\tsprintf(value, \"%\"PRId64,\n\t\t\tgit_config_int64(key_, value_ ? value_ : \"\"));\n\telse if (types == TYPE_BOOL)\n\t\tvptr = git_config_bool(key_, value_) ? \"true\" : \"false\";\n\telse if (types == TYPE_BOOL_OR_INT) {\n\t\tint is_bool, v;\n\t\tv = git_config_bool_or_int(key_, value_, &is_bool);\n\t\tif (is_bool)\n\t\t\tvptr = v ? \"true\" : \"false\";\n\t\telse\n\t\t\tsprintf(value, \"%d\", v);\n\t} else if (types == TYPE_PATH) {\n\t\tif (git_config_pathname(&vptr, key_, value_) < 0)\n\t\t\treturn -1;\n\t\tmust_free_vptr = 1;\n\t} else if (value_) {\n\t\tvptr = value_;\n\t} else {\n\t\t/* Just show the key name */\n\t\tvptr = \"\";\n\t\tmust_print_delim = 0;\n\t}\n\n\tif (must_print_delim)\n\t\tstrbuf_addch(buf, key_delim);\n\tstrbuf_addstr(buf, vptr);\n\tstrbuf_addch(buf, term);\n\n\tif (must_free_vptr)\n\t\tfree((char *)vptr);\n\treturn 0;\n}\n\nstatic int collect_config(const char *key_, const char *value_, void *cb)\n{\n\tstruct strbuf_list *values = cb;\n\n\tif (!use_key_regexp && strcmp(key_, key))\n\t\treturn 0;\n\tif (use_key_regexp && regexec(key_regexp, key_, 0, NULL, 0))\n\t\treturn 0;\n\tif (regexp != NULL &&\n\t    (do_not_match ^ !!regexec(regexp, (value_?value_:\"\"), 0, NULL, 0)))\n\t\treturn 0;\n\n\tALLOC_GROW(values->items, values->nr + 1, values->alloc);\n\n\treturn format_config(&values->items[values->nr++], key_, value_);\n}\n\nstatic int get_value(const char *key_, const char *regex_)\n{\n\tint ret = CONFIG_GENERIC_ERROR;\n\tstruct strbuf_list values = {NULL};\n\tint i;\n\n\tif (use_key_regexp) {\n\t\tchar *tl;\n\n\t\t/*\n\t\t * NEEDSWORK: this naive pattern lowercasing obviously does not\n\t\t * work for more complex patterns like \"^[^.]*Foo.*bar\".\n\t\t * Perhaps we should deprecate this altogether someday.\n\t\t */\n\n\t\tkey = xstrdup(key_);\n\t\tfor (tl = key + strlen(key) - 1;\n\t\t     tl >= key && *tl != '.';\n\t\t     tl--)\n\t\t\t*tl = tolower(*tl);\n\t\tfor (tl = key; *tl && *tl != '.'; tl++)\n\t\t\t*tl = tolower(*tl);\n\n\t\tkey_regexp = (regex_t*)xmalloc(sizeof(regex_t));\n\t\tif (regcomp(key_regexp, key, REG_EXTENDED)) {\n\t\t\tfprintf(stderr, \"Invalid key pattern: %s\\n\", key_);\n\t\t\tfree(key_regexp);\n\t\t\tkey_regexp = NULL;\n\t\t\tret = CONFIG_INVALID_PATTERN;\n\t\t\tgoto free_strings;\n\t\t}\n\t} else {\n\t\tif (git_config_parse_key(key_, &key, NULL)) {\n\t\t\tret = CONFIG_INVALID_KEY;\n\t\t\tgoto free_strings;\n\t\t}\n\t}\n\n\tif (regex_) {\n\t\tif (regex_[0] == '!') {\n\t\t\tdo_not_match = 1;\n\t\t\tregex_++;\n\t\t}\n\n\t\tregexp = (regex_t*)xmalloc(sizeof(regex_t));\n\t\tif (regcomp(regexp, regex_, REG_EXTENDED)) {\n\t\t\tfprintf(stderr, \"Invalid pattern: %s\\n\", regex_);\n\t\t\tfree(regexp);\n\t\t\tregexp = NULL;\n\t\t\tret = CONFIG_INVALID_PATTERN;\n\t\t\tgoto free_strings;\n\t\t}\n\t}\n\n\tgit_config_with_options(collect_config, &values,\n\t\t\t\tgiven_config_file, given_config_blob,\n\t\t\t\trespect_includes);\n\n\tret = !values.nr;\n\n\tfor (i = 0; i < values.nr; i++) {\n\t\tstruct strbuf *buf = values.items + i;\n\t\tif (do_all || i == values.nr - 1)\n\t\t\tfwrite(buf->buf, 1, buf->len, stdout);\n\t\tstrbuf_release(buf);\n\t}\n\tfree(values.items);\n\nfree_strings:\n\tfree(key);\n\tif (key_regexp) {\n\t\tregfree(key_regexp);\n\t\tfree(key_regexp);\n\t}\n\tif (regexp) {\n\t\tregfree(regexp);\n\t\tfree(regexp);\n\t}\n\n\treturn ret;\n}\n\nstatic char *normalize_value(const char *key, const char *value)\n{\n\tchar *normalized;\n\n\tif (!value)\n\t\treturn NULL;\n\n\tif (types == 0 || types == TYPE_PATH)\n\t\t/*\n\t\t * We don't do normalization for TYPE_PATH here: If\n\t\t * the path is like ~/foobar/, we prefer to store\n\t\t * \"~/foobar/\" in the config file, and to expand the ~\n\t\t * when retrieving the value.\n\t\t */\n\t\tnormalized = xstrdup(value);\n\telse {\n\t\tnormalized = xmalloc(64);\n\t\tif (types == TYPE_INT) {\n\t\t\tint64_t v = git_config_int64(key, value);\n\t\t\tsprintf(normalized, \"%\"PRId64, v);\n\t\t}\n\t\telse if (types == TYPE_BOOL)\n\t\t\tsprintf(normalized, \"%s\",\n\t\t\t\tgit_config_bool(key, value) ? \"true\" : \"false\");\n\t\telse if (types == TYPE_BOOL_OR_INT) {\n\t\t\tint is_bool, v;\n\t\t\tv = git_config_bool_or_int(key, value, &is_bool);\n\t\t\tif (!is_bool)\n\t\t\t\tsprintf(normalized, \"%d\", v);\n\t\t\telse\n\t\t\t\tsprintf(normalized, \"%s\", v ? \"true\" : \"false\");\n\t\t}\n\t}\n\n\treturn normalized;\n}\n\nstatic int get_color_found;\nstatic const char *get_color_slot;\nstatic const char *get_colorbool_slot;\nstatic char parsed_color[COLOR_MAXLEN];\n\nstatic int git_get_color_config(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(var, get_color_slot)) {\n\t\tif (!value)\n\t\t\tconfig_error_nonbool(var);\n\t\tcolor_parse(value, var, parsed_color);\n\t\tget_color_found = 1;\n\t}\n\treturn 0;\n}\n\nstatic void get_color(const char *def_color)\n{\n\tget_color_found = 0;\n\tparsed_color[0] = '\\0';\n\tgit_config_with_options(git_get_color_config, NULL,\n\t\t\t\tgiven_config_file, given_config_blob,\n\t\t\t\trespect_includes);\n\n\tif (!get_color_found && def_color)\n\t\tcolor_parse(def_color, \"command line\", parsed_color);\n\n\tfputs(parsed_color, stdout);\n}\n\nstatic int get_colorbool_found;\nstatic int get_diff_color_found;\nstatic int get_color_ui_found;\nstatic int git_get_colorbool_config(const char *var, const char *value,\n\t\tvoid *cb)\n{\n\tif (!strcmp(var, get_colorbool_slot))\n\t\tget_colorbool_found = git_config_colorbool(var, value);\n\telse if (!strcmp(var, \"diff.color\"))\n\t\tget_diff_color_found = git_config_colorbool(var, value);\n\telse if (!strcmp(var, \"color.ui\"))\n\t\tget_color_ui_found = git_config_colorbool(var, value);\n\treturn 0;\n}\n\nstatic int get_colorbool(int print)\n{\n\tget_colorbool_found = -1;\n\tget_diff_color_found = -1;\n\tget_color_ui_found = -1;\n\tgit_config_with_options(git_get_colorbool_config, NULL,\n\t\t\t\tgiven_config_file, given_config_blob,\n\t\t\t\trespect_includes);\n\n\tif (get_colorbool_found < 0) {\n\t\tif (!strcmp(get_colorbool_slot, \"color.diff\"))\n\t\t\tget_colorbool_found = get_diff_color_found;\n\t\tif (get_colorbool_found < 0)\n\t\t\tget_colorbool_found = get_color_ui_found;\n\t}\n\n\tif (get_colorbool_found < 0)\n\t\t/* default value if none found in config */\n\t\tget_colorbool_found = GIT_COLOR_AUTO;\n\n\tget_colorbool_found = want_color(get_colorbool_found);\n\n\tif (print) {\n\t\tprintf(\"%s\\n\", get_colorbool_found ? \"true\" : \"false\");\n\t\treturn 0;\n\t} else\n\t\treturn get_colorbool_found ? 0 : 1;\n}\n\nstatic void check_blob_write(void)\n{\n\tif (given_config_blob)\n\t\tdie(\"writing config blobs is not supported\");\n}\n\nstruct urlmatch_current_candidate_value {\n\tchar value_is_null;\n\tstruct strbuf value;\n};\n\nstatic int urlmatch_collect_fn(const char *var, const char *value, void *cb)\n{\n\tstruct string_list *values = cb;\n\tstruct string_list_item *item = string_list_insert(values, var);\n\tstruct urlmatch_current_candidate_value *matched = item->util;\n\n\tif (!matched) {\n\t\tmatched = xmalloc(sizeof(*matched));\n\t\tstrbuf_init(&matched->value, 0);\n\t\titem->util = matched;\n\t} else {\n\t\tstrbuf_reset(&matched->value);\n\t}\n\n\tif (value) {\n\t\tstrbuf_addstr(&matched->value, value);\n\t\tmatched->value_is_null = 0;\n\t} else {\n\t\tmatched->value_is_null = 1;\n\t}\n\treturn 0;\n}\n\nstatic int get_urlmatch(const char *var, const char *url)\n{\n\tchar *section_tail;\n\tstruct string_list_item *item;\n\tstruct urlmatch_config config = { STRING_LIST_INIT_DUP };\n\tstruct string_list values = STRING_LIST_INIT_DUP;\n\n\tconfig.collect_fn = urlmatch_collect_fn;\n\tconfig.cascade_fn = NULL;\n\tconfig.cb = &values;\n\n\tif (!url_normalize(url, &config.url))\n\t\tdie(\"%s\", config.url.err);\n\n\tconfig.section = xstrdup_tolower(var);\n\tsection_tail = strchr(config.section, '.');\n\tif (section_tail) {\n\t\t*section_tail = '\\0';\n\t\tconfig.key = section_tail + 1;\n\t\tshow_keys = 0;\n\t} else {\n\t\tconfig.key = NULL;\n\t\tshow_keys = 1;\n\t}\n\n\tgit_config_with_options(urlmatch_config_entry, &config,\n\t\t\t\tgiven_config_file, NULL, respect_includes);\n\n\tfor_each_string_list_item(item, &values) {\n\t\tstruct urlmatch_current_candidate_value *matched = item->util;\n\t\tstruct strbuf key = STRBUF_INIT;\n\t\tstruct strbuf buf = STRBUF_INIT;\n\n\t\tstrbuf_addstr(&key, item->string);\n\t\tformat_config(&buf, key.buf,\n\t\t\t      matched->value_is_null ? NULL : matched->value.buf);\n\t\tfwrite(buf.buf, 1, buf.len, stdout);\n\t\tstrbuf_release(&key);\n\t\tstrbuf_release(&buf);\n\n\t\tstrbuf_release(&matched->value);\n\t}\n\tstring_list_clear(&config.vars, 1);\n\tstring_list_clear(&values, 1);\n\tfree(config.url.url);\n\n\tfree((void *)config.section);\n\treturn 0;\n}\n\nint cmd_config(int argc, const char **argv, const char *prefix)\n{\n\tint nongit = !startup_info->have_repository;\n\tchar *value;\n\n\tgiven_config_file = getenv(CONFIG_ENVIRONMENT);\n\n\targc = parse_options(argc, argv, prefix, builtin_config_options,\n\t\t\t     builtin_config_usage,\n\t\t\t     PARSE_OPT_STOP_AT_NON_OPTION);\n\n\tif (use_global_config + use_system_config + use_local_config +\n\t    !!given_config_file + !!given_config_blob > 1) {\n\t\terror(\"only one config file at a time.\");\n\t\tusage_with_options(builtin_config_usage, builtin_config_options);\n\t}\n\n\tif (use_global_config) {\n\t\tchar *user_config = NULL;\n\t\tchar *xdg_config = NULL;\n\n\t\thome_config_paths(&user_config, &xdg_config, \"config\");\n\n\t\tif (!user_config)\n\t\t\t/*\n\t\t\t * It is unknown if HOME/.gitconfig exists, so\n\t\t\t * we do not know if we should write to XDG\n\t\t\t * location; error out even if XDG_CONFIG_HOME\n\t\t\t * is set and points at a sane location.\n\t\t\t */\n\t\t\tdie(\"$HOME not set\");\n\n\t\tif (access_or_warn(user_config, R_OK, 0) &&\n\t\t    xdg_config && !access_or_warn(xdg_config, R_OK, 0))\n\t\t\tgiven_config_file = xdg_config;\n\t\telse\n\t\t\tgiven_config_file = user_config;\n\t}\n\telse if (use_system_config)\n\t\tgiven_config_file = git_etc_gitconfig();\n\telse if (use_local_config)\n\t\tgiven_config_file = git_pathdup(\"config\");\n\telse if (given_config_file) {\n\t\tif (!is_absolute_path(given_config_file) && prefix)\n\t\t\tgiven_config_file =\n\t\t\t\txstrdup(prefix_filename(prefix,\n\t\t\t\t\t\t\tstrlen(prefix),\n\t\t\t\t\t\t\tgiven_config_file));\n\t}\n\n\tif (respect_includes == -1)\n\t\trespect_includes = !given_config_file;\n\n\tif (end_null) {\n\t\tterm = '\\0';\n\t\tdelim = '\\n';\n\t\tkey_delim = '\\n';\n\t}\n\n\tif (HAS_MULTI_BITS(types)) {\n\t\terror(\"only one type at a time.\");\n\t\tusage_with_options(builtin_config_usage, builtin_config_options);\n\t}\n\n\tif (get_color_slot)\n\t    actions |= ACTION_GET_COLOR;\n\tif (get_colorbool_slot)\n\t    actions |= ACTION_GET_COLORBOOL;\n\n\tif ((get_color_slot || get_colorbool_slot) && types) {\n\t\terror(\"--get-color and variable type are incoherent\");\n\t\tusage_with_options(builtin_config_usage, builtin_config_options);\n\t}\n\n\tif (HAS_MULTI_BITS(actions)) {\n\t\terror(\"only one action at a time.\");\n\t\tusage_with_options(builtin_config_usage, builtin_config_options);\n\t}\n\tif (actions == 0)\n\t\tswitch (argc) {\n\t\tcase 1: actions = ACTION_GET; break;\n\t\tcase 2: actions = ACTION_SET; break;\n\t\tcase 3: actions = ACTION_SET_ALL; break;\n\t\tdefault:\n\t\t\tusage_with_options(builtin_config_usage, builtin_config_options);\n\t\t}\n\n\tif (actions == ACTION_LIST) {\n\t\tcheck_argc(argc, 0, 0);\n\t\tif (git_config_with_options(show_all_config, NULL,\n\t\t\t\t\t    given_config_file,\n\t\t\t\t\t    given_config_blob,\n\t\t\t\t\t    respect_includes) < 0) {\n\t\t\tif (given_config_file)\n\t\t\t\tdie_errno(\"unable to read config file '%s'\",\n\t\t\t\t\t  given_config_file);\n\t\t\telse\n\t\t\t\tdie(\"error processing config file(s)\");\n\t\t}\n\t}\n\telse if (actions == ACTION_EDIT) {\n\t\tcheck_argc(argc, 0, 0);\n\t\tif (!given_config_file && nongit)\n\t\t\tdie(\"not in a git directory\");\n\t\tif (given_config_blob)\n\t\t\tdie(\"editing blobs is not supported\");\n\t\tgit_config(git_default_config, NULL);\n\t\tlaunch_editor(given_config_file ?\n\t\t\t      given_config_file : git_path(\"config\"),\n\t\t\t      NULL, NULL);\n\t}\n\telse if (actions == ACTION_SET) {\n\t\tint ret;\n\t\tcheck_blob_write();\n\t\tcheck_argc(argc, 2, 2);\n\t\tvalue = normalize_value(argv[0], argv[1]);\n\t\tret = git_config_set_in_file(given_config_file, argv[0], value);\n\t\tif (ret == CONFIG_NOTHING_SET)\n\t\t\terror(\"cannot overwrite multiple values with a single value\\n\"\n\t\t\t\"       Use a regexp, --add or --replace-all to change %s.\", argv[0]);\n\t\treturn ret;\n\t}\n\telse if (actions == ACTION_SET_ALL) {\n\t\tcheck_blob_write();\n\t\tcheck_argc(argc, 2, 3);\n\t\tvalue = normalize_value(argv[0], argv[1]);\n\t\treturn git_config_set_multivar_in_file(given_config_file,\n\t\t\t\t\t\t       argv[0], value, argv[2], 0);\n\t}\n\telse if (actions == ACTION_ADD) {\n\t\tcheck_blob_write();\n\t\tcheck_argc(argc, 2, 2);\n\t\tvalue = normalize_value(argv[0], argv[1]);\n\t\treturn git_config_set_multivar_in_file(given_config_file,\n\t\t\t\t\t\t       argv[0], value, \"^$\", 0);\n\t}\n\telse if (actions == ACTION_REPLACE_ALL) {\n\t\tcheck_blob_write();\n\t\tcheck_argc(argc, 2, 3);\n\t\tvalue = normalize_value(argv[0], argv[1]);\n\t\treturn git_config_set_multivar_in_file(given_config_file,\n\t\t\t\t\t\t       argv[0], value, argv[2], 1);\n\t}\n\telse if (actions == ACTION_GET) {\n\t\tcheck_argc(argc, 1, 2);\n\t\treturn get_value(argv[0], argv[1]);\n\t}\n\telse if (actions == ACTION_GET_ALL) {\n\t\tdo_all = 1;\n\t\tcheck_argc(argc, 1, 2);\n\t\treturn get_value(argv[0], argv[1]);\n\t}\n\telse if (actions == ACTION_GET_REGEXP) {\n\t\tshow_keys = 1;\n\t\tuse_key_regexp = 1;\n\t\tdo_all = 1;\n\t\tcheck_argc(argc, 1, 2);\n\t\treturn get_value(argv[0], argv[1]);\n\t}\n\telse if (actions == ACTION_GET_URLMATCH) {\n\t\tcheck_argc(argc, 2, 2);\n\t\treturn get_urlmatch(argv[0], argv[1]);\n\t}\n\telse if (actions == ACTION_UNSET) {\n\t\tcheck_blob_write();\n\t\tcheck_argc(argc, 1, 2);\n\t\tif (argc == 2)\n\t\t\treturn git_config_set_multivar_in_file(given_config_file,\n\t\t\t\t\t\t\t       argv[0], NULL, argv[1], 0);\n\t\telse\n\t\t\treturn git_config_set_in_file(given_config_file,\n\t\t\t\t\t\t      argv[0], NULL);\n\t}\n\telse if (actions == ACTION_UNSET_ALL) {\n\t\tcheck_blob_write();\n\t\tcheck_argc(argc, 1, 2);\n\t\treturn git_config_set_multivar_in_file(given_config_file,\n\t\t\t\t\t\t       argv[0], NULL, argv[1], 1);\n\t}\n\telse if (actions == ACTION_RENAME_SECTION) {\n\t\tint ret;\n\t\tcheck_blob_write();\n\t\tcheck_argc(argc, 2, 2);\n\t\tret = git_config_rename_section_in_file(given_config_file,\n\t\t\t\t\t\t\targv[0], argv[1]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\n\t\t\tdie(\"No such section!\");\n\t}\n\telse if (actions == ACTION_REMOVE_SECTION) {\n\t\tint ret;\n\t\tcheck_blob_write();\n\t\tcheck_argc(argc, 1, 1);\n\t\tret = git_config_rename_section_in_file(given_config_file,\n\t\t\t\t\t\t\targv[0], NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\n\t\t\tdie(\"No such section!\");\n\t}\n\telse if (actions == ACTION_GET_COLOR) {\n\t\tget_color(argv[0]);\n\t}\n\telse if (actions == ACTION_GET_COLORBOOL) {\n\t\tif (argc == 1)\n\t\t\tcolor_stdout_is_tty = git_config_bool(\"command line\", argv[0]);\n\t\treturn get_colorbool(argc != 0);\n\t}\n\n\treturn 0;\n}\n\nint cmd_repo_config(int argc, const char **argv, const char *prefix)\n{\n\tfprintf(stderr, \"WARNING: git repo-config is deprecated in favor of git config.\\n\");\n\treturn cmd_config(argc, argv, prefix);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00b0c240fcd788edc3d33cd60f48cb49f963ff7f",
  "sha1_ok": true,
  "size": 18658
}
