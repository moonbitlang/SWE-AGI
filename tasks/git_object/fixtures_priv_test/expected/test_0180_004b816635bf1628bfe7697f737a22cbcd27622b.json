{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGNvbW1pdCIKICoKICogQ29weXJpZ2h0IChjKSAyMDA3IEtyaXN0aWFuIEjDuGdzYmVyZyA8a3JoQHJlZGhhdC5jb20+CiAqIEJhc2VkIG9uIGdpdC1jb21taXQuc2ggYnkgSnVuaW8gQyBIYW1hbm8gYW5kIExpbnVzIFRvcnZhbGRzCiAqLwoKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImxvY2tmaWxlLmgiCiNpbmNsdWRlICJjYWNoZS10cmVlLmgiCiNpbmNsdWRlICJjb2xvci5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJkaWZmLmgiCiNpbmNsdWRlICJkaWZmY29yZS5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAid3Qtc3RhdHVzLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAibG9nLXRyZWUuaCIKI2luY2x1ZGUgInN0cmJ1Zi5oIgojaW5jbHVkZSAidXRmOC5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgInJlcmVyZS5oIgojaW5jbHVkZSAidW5wYWNrLXRyZWVzLmgiCiNpbmNsdWRlICJxdW90ZS5oIgojaW5jbHVkZSAic3VibW9kdWxlLmgiCiNpbmNsdWRlICJncGctaW50ZXJmYWNlLmgiCiNpbmNsdWRlICJjb2x1bW4uaCIKI2luY2x1ZGUgInNlcXVlbmNlci5oIgojaW5jbHVkZSAibWFpbG1hcC5oIgojaW5jbHVkZSAiaGVscC5oIgojaW5jbHVkZSAiY29tbWl0LXJlYWNoLmgiCiNpbmNsdWRlICJjb21taXQtZ3JhcGguaCIKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgYnVpbHRpbl9jb21taXRfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgY29tbWl0IFs8b3B0aW9ucz5dIFstLV0gPHBhdGhzcGVjPi4uLiIpLAoJTlVMTAp9OwoKc3RhdGljIGNvbnN0IGNoYXIgKiBjb25zdCBidWlsdGluX3N0YXR1c191c2FnZVtdID0gewoJTl8oImdpdCBzdGF0dXMgWzxvcHRpb25zPl0gWy0tXSA8cGF0aHNwZWM+Li4uIiksCglOVUxMCn07CgpzdGF0aWMgY29uc3QgY2hhciBlbXB0eV9hbWVuZF9hZHZpY2VbXSA9Ck5fKCJZb3UgYXNrZWQgdG8gYW1lbmQgdGhlIG1vc3QgcmVjZW50IGNvbW1pdCwgYnV0IGRvaW5nIHNvIHdvdWxkIG1ha2VcbiIKIml0IGVtcHR5LiBZb3UgY2FuIHJlcGVhdCB5b3VyIGNvbW1hbmQgd2l0aCAtLWFsbG93LWVtcHR5LCBvciB5b3UgY2FuXG4iCiJyZW1vdmUgdGhlIGNvbW1pdCBlbnRpcmVseSB3aXRoIFwiZ2l0IHJlc2V0IEhFQUReXCIuXG4iKTsKCnN0YXRpYyBjb25zdCBjaGFyIGVtcHR5X2NoZXJyeV9waWNrX2FkdmljZVtdID0KTl8oIlRoZSBwcmV2aW91cyBjaGVycnktcGljayBpcyBub3cgZW1wdHksIHBvc3NpYmx5IGR1ZSB0byBjb25mbGljdCByZXNvbHV0aW9uLlxuIgoiSWYgeW91IHdpc2ggdG8gY29tbWl0IGl0IGFueXdheSwgdXNlOlxuIgoiXG4iCiIgICAgZ2l0IGNvbW1pdCAtLWFsbG93LWVtcHR5XG4iCiJcbiIpOwoKc3RhdGljIGNvbnN0IGNoYXIgZW1wdHlfY2hlcnJ5X3BpY2tfYWR2aWNlX3NpbmdsZVtdID0KTl8oIk90aGVyd2lzZSwgcGxlYXNlIHVzZSAnZ2l0IHJlc2V0J1xuIik7CgpzdGF0aWMgY29uc3QgY2hhciBlbXB0eV9jaGVycnlfcGlja19hZHZpY2VfbXVsdGlbXSA9Ck5fKCJJZiB5b3Ugd2lzaCB0byBza2lwIHRoaXMgY29tbWl0LCB1c2U6XG4iCiJcbiIKIiAgICBnaXQgcmVzZXRcbiIKIlxuIgoiVGhlbiBcImdpdCBjaGVycnktcGljayAtLWNvbnRpbnVlXCIgd2lsbCByZXN1bWUgY2hlcnJ5LXBpY2tpbmdcbiIKInRoZSByZW1haW5pbmcgY29tbWl0cy5cbiIpOwoKc3RhdGljIGNvbnN0IGNoYXIgKmNvbG9yX3N0YXR1c19zbG90c1tdID0gewoJW1dUX1NUQVRVU19IRUFERVJdCSAgPSAiaGVhZGVyIiwKCVtXVF9TVEFUVVNfVVBEQVRFRF0JICA9ICJ1cGRhdGVkIiwKCVtXVF9TVEFUVVNfQ0hBTkdFRF0JICA9ICJjaGFuZ2VkIiwKCVtXVF9TVEFUVVNfVU5UUkFDS0VEXQkgID0gInVudHJhY2tlZCIsCglbV1RfU1RBVFVTX05PQlJBTkNIXQkgID0gIm5vQnJhbmNoIiwKCVtXVF9TVEFUVVNfVU5NRVJHRURdCSAgPSAidW5tZXJnZWQiLAoJW1dUX1NUQVRVU19MT0NBTF9CUkFOQ0hdICA9ICJsb2NhbEJyYW5jaCIsCglbV1RfU1RBVFVTX1JFTU9URV9CUkFOQ0hdID0gInJlbW90ZUJyYW5jaCIsCglbV1RfU1RBVFVTX09OQlJBTkNIXQkgID0gImJyYW5jaCIsCn07CgpzdGF0aWMgY29uc3QgY2hhciAqdXNlX21lc3NhZ2VfYnVmZmVyOwpzdGF0aWMgc3RydWN0IGxvY2tfZmlsZSBpbmRleF9sb2NrOyAvKiByZWFsIGluZGV4ICovCnN0YXRpYyBzdHJ1Y3QgbG9ja19maWxlIGZhbHNlX2xvY2s7IC8qIHVzZWQgb25seSBmb3IgcGFydGlhbCBjb21taXRzICovCnN0YXRpYyBlbnVtIHsKCUNPTU1JVF9BU19JUyA9IDEsCglDT01NSVRfTk9STUFMLAoJQ09NTUlUX1BBUlRJQUwKfSBjb21taXRfc3R5bGU7CgpzdGF0aWMgY29uc3QgY2hhciAqbG9nZmlsZSwgKmZvcmNlX2F1dGhvcjsKc3RhdGljIGNvbnN0IGNoYXIgKnRlbXBsYXRlX2ZpbGU7Ci8qCiAqIFRoZSBfbWVzc2FnZSB2YXJpYWJsZXMgYXJlIGNvbW1pdCBuYW1lcyBmcm9tIHdoaWNoIHRvIHRha2UKICogdGhlIGNvbW1pdCBtZXNzYWdlIGFuZC9vciBhdXRob3JzaGlwLgogKi8Kc3RhdGljIGNvbnN0IGNoYXIgKmF1dGhvcl9tZXNzYWdlLCAqYXV0aG9yX21lc3NhZ2VfYnVmZmVyOwpzdGF0aWMgY2hhciAqZWRpdF9tZXNzYWdlLCAqdXNlX21lc3NhZ2U7CnN0YXRpYyBjaGFyICpmaXh1cF9tZXNzYWdlLCAqc3F1YXNoX21lc3NhZ2U7CnN0YXRpYyBpbnQgYWxsLCBhbHNvLCBpbnRlcmFjdGl2ZSwgcGF0Y2hfaW50ZXJhY3RpdmUsIG9ubHksIGFtZW5kLCBzaWdub2ZmOwpzdGF0aWMgaW50IGVkaXRfZmxhZyA9IC0xOyAvKiB1bnNwZWNpZmllZCAqLwpzdGF0aWMgaW50IHF1aWV0LCB2ZXJib3NlLCBub192ZXJpZnksIGFsbG93X2VtcHR5LCBkcnlfcnVuLCByZW5ld19hdXRob3JzaGlwOwpzdGF0aWMgaW50IGNvbmZpZ19jb21taXRfdmVyYm9zZSA9IC0xOyAvKiB1bnNwZWNpZmllZCAqLwpzdGF0aWMgaW50IG5vX3Bvc3RfcmV3cml0ZSwgYWxsb3dfZW1wdHlfbWVzc2FnZTsKc3RhdGljIGNoYXIgKnVudHJhY2tlZF9maWxlc19hcmcsICpmb3JjZV9kYXRlLCAqaWdub3JlX3N1Ym1vZHVsZV9hcmcsICppZ25vcmVkX2FyZzsKc3RhdGljIGNoYXIgKnNpZ25fY29tbWl0OwoKLyoKICogVGhlIGRlZmF1bHQgY29tbWl0IG1lc3NhZ2UgY2xlYW51cCBtb2RlIHdpbGwgcmVtb3ZlIHRoZSBsaW5lcwogKiBiZWdpbm5pbmcgd2l0aCAjIChzaGVsbCBjb21tZW50cykgYW5kIGxlYWRpbmcgYW5kIHRyYWlsaW5nCiAqIHdoaXRlc3BhY2VzIChlbXB0eSBsaW5lcyBvciBjb250YWluaW5nIG9ubHkgd2hpdGVzcGFjZXMpCiAqIGlmIGVkaXRvciBpcyB1c2VkLCBhbmQgb25seSB0aGUgd2hpdGVzcGFjZXMgaWYgdGhlIG1lc3NhZ2UKICogaXMgc3BlY2lmaWVkIGV4cGxpY2l0bHkuCiAqLwpzdGF0aWMgZW51bSBjb21taXRfbXNnX2NsZWFudXBfbW9kZSBjbGVhbnVwX21vZGU7CnN0YXRpYyBjb25zdCBjaGFyICpjbGVhbnVwX2FyZzsKCnN0YXRpYyBlbnVtIGNvbW1pdF93aGVuY2Ugd2hlbmNlOwpzdGF0aWMgaW50IHNlcXVlbmNlcl9pbl91c2U7CnN0YXRpYyBpbnQgdXNlX2VkaXRvciA9IDEsIGluY2x1ZGVfc3RhdHVzID0gMTsKc3RhdGljIGludCBoYXZlX29wdGlvbl9tOwpzdGF0aWMgc3RydWN0IHN0cmJ1ZiBtZXNzYWdlID0gU1RSQlVGX0lOSVQ7CgpzdGF0aWMgZW51bSB3dF9zdGF0dXNfZm9ybWF0IHN0YXR1c19mb3JtYXQgPSBTVEFUVVNfRk9STUFUX1VOU1BFQ0lGSUVEOwoKc3RhdGljIGludCBvcHRfcGFyc2VfcG9yY2VsYWluKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCWVudW0gd3Rfc3RhdHVzX2Zvcm1hdCAqdmFsdWUgPSAoZW51bSB3dF9zdGF0dXNfZm9ybWF0ICopb3B0LT52YWx1ZTsKCWlmICh1bnNldCkKCQkqdmFsdWUgPSBTVEFUVVNfRk9STUFUX05PTkU7CgllbHNlIGlmICghYXJnKQoJCSp2YWx1ZSA9IFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOOwoJZWxzZSBpZiAoIXN0cmNtcChhcmcsICJ2MSIpIHx8ICFzdHJjbXAoYXJnLCAiMSIpKQoJCSp2YWx1ZSA9IFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOOwoJZWxzZSBpZiAoIXN0cmNtcChhcmcsICJ2MiIpIHx8ICFzdHJjbXAoYXJnLCAiMiIpKQoJCSp2YWx1ZSA9IFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOX1YyOwoJZWxzZQoJCWRpZSgidW5zdXBwb3J0ZWQgcG9yY2VsYWluIHZlcnNpb24gJyVzJyIsIGFyZyk7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgb3B0X3BhcnNlX20oY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJc3RydWN0IHN0cmJ1ZiAqYnVmID0gb3B0LT52YWx1ZTsKCWlmICh1bnNldCkgewoJCWhhdmVfb3B0aW9uX20gPSAwOwoJCXN0cmJ1Zl9zZXRsZW4oYnVmLCAwKTsKCX0gZWxzZSB7CgkJaGF2ZV9vcHRpb25fbSA9IDE7CgkJaWYgKGJ1Zi0+bGVuKQoJCQlzdHJidWZfYWRkY2goYnVmLCAnXG4nKTsKCQlzdHJidWZfYWRkc3RyKGJ1ZiwgYXJnKTsKCQlzdHJidWZfY29tcGxldGVfbGluZShidWYpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgb3B0X3BhcnNlX3JlbmFtZV9zY29yZShjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7Cgljb25zdCBjaGFyICoqdmFsdWUgPSBvcHQtPnZhbHVlOwoKCUJVR19PTl9PUFRfTkVHKHVuc2V0KTsKCglpZiAoYXJnICE9IE5VTEwgJiYgKmFyZyA9PSAnPScpCgkJYXJnID0gYXJnICsgMTsKCgkqdmFsdWUgPSBhcmc7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgZGV0ZXJtaW5lX3doZW5jZShzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglpZiAoZmlsZV9leGlzdHMoZ2l0X3BhdGhfbWVyZ2VfaGVhZCh0aGVfcmVwb3NpdG9yeSkpKQoJCXdoZW5jZSA9IEZST01fTUVSR0U7CgllbHNlIGlmIChmaWxlX2V4aXN0cyhnaXRfcGF0aF9jaGVycnlfcGlja19oZWFkKHRoZV9yZXBvc2l0b3J5KSkpIHsKCQl3aGVuY2UgPSBGUk9NX0NIRVJSWV9QSUNLOwoJCWlmIChmaWxlX2V4aXN0cyhnaXRfcGF0aF9zZXFfZGlyKCkpKQoJCQlzZXF1ZW5jZXJfaW5fdXNlID0gMTsKCX0KCWVsc2UKCQl3aGVuY2UgPSBGUk9NX0NPTU1JVDsKCWlmIChzKQoJCXMtPndoZW5jZSA9IHdoZW5jZTsKfQoKc3RhdGljIHZvaWQgc3RhdHVzX2luaXRfY29uZmlnKHN0cnVjdCB3dF9zdGF0dXMgKnMsIGNvbmZpZ19mbl90IGZuKQp7Cgl3dF9zdGF0dXNfcHJlcGFyZSh0aGVfcmVwb3NpdG9yeSwgcyk7Cglpbml0X2RpZmZfdWlfZGVmYXVsdHMoKTsKCWdpdF9jb25maWcoZm4sIHMpOwoJZGV0ZXJtaW5lX3doZW5jZShzKTsKCXMtPmhpbnRzID0gYWR2aWNlX3N0YXR1c19oaW50czsgLyogbXVzdCBjb21lIGFmdGVyIGdpdF9jb25maWcoKSAqLwp9CgpzdGF0aWMgdm9pZCByb2xsYmFja19pbmRleF9maWxlcyh2b2lkKQp7Cglzd2l0Y2ggKGNvbW1pdF9zdHlsZSkgewoJY2FzZSBDT01NSVRfQVNfSVM6CgkJYnJlYWs7IC8qIG5vdGhpbmcgdG8gZG8gKi8KCWNhc2UgQ09NTUlUX05PUk1BTDoKCQlyb2xsYmFja19sb2NrX2ZpbGUoJmluZGV4X2xvY2spOwoJCWJyZWFrOwoJY2FzZSBDT01NSVRfUEFSVElBTDoKCQlyb2xsYmFja19sb2NrX2ZpbGUoJmluZGV4X2xvY2spOwoJCXJvbGxiYWNrX2xvY2tfZmlsZSgmZmFsc2VfbG9jayk7CgkJYnJlYWs7Cgl9Cn0KCnN0YXRpYyBpbnQgY29tbWl0X2luZGV4X2ZpbGVzKHZvaWQpCnsKCWludCBlcnIgPSAwOwoKCXN3aXRjaCAoY29tbWl0X3N0eWxlKSB7CgljYXNlIENPTU1JVF9BU19JUzoKCQlicmVhazsgLyogbm90aGluZyB0byBkbyAqLwoJY2FzZSBDT01NSVRfTk9STUFMOgoJCWVyciA9IGNvbW1pdF9sb2NrX2ZpbGUoJmluZGV4X2xvY2spOwoJCWJyZWFrOwoJY2FzZSBDT01NSVRfUEFSVElBTDoKCQllcnIgPSBjb21taXRfbG9ja19maWxlKCZpbmRleF9sb2NrKTsKCQlyb2xsYmFja19sb2NrX2ZpbGUoJmZhbHNlX2xvY2spOwoJCWJyZWFrOwoJfQoKCXJldHVybiBlcnI7Cn0KCi8qCiAqIFRha2UgYSB1bmlvbiBvZiBwYXRocyBpbiB0aGUgaW5kZXggYW5kIHRoZSBuYW1lZCB0cmVlICh0eXBpY2FsbHksICJIRUFEIiksCiAqIGFuZCByZXR1cm4gdGhlIHBhdGhzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHBhdHRlcm4gaW4gbGlzdC4KICovCnN0YXRpYyBpbnQgbGlzdF9wYXRocyhzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QsIGNvbnN0IGNoYXIgKndpdGhfdHJlZSwKCQkgICAgICBjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcGF0dGVybikKewoJaW50IGksIHJldDsKCWNoYXIgKm07CgoJaWYgKCFwYXR0ZXJuLT5ucikKCQlyZXR1cm4gMDsKCgltID0geGNhbGxvYygxLCBwYXR0ZXJuLT5ucik7CgoJaWYgKHdpdGhfdHJlZSkgewoJCWNoYXIgKm1heF9wcmVmaXggPSBjb21tb25fcHJlZml4KHBhdHRlcm4pOwoJCW92ZXJsYXlfdHJlZV9vbl9pbmRleCgmdGhlX2luZGV4LCB3aXRoX3RyZWUsIG1heF9wcmVmaXgpOwoJCWZyZWUobWF4X3ByZWZpeCk7Cgl9CgoJZm9yIChpID0gMDsgaSA8IGFjdGl2ZV9ucjsgaSsrKSB7CgkJY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGFjdGl2ZV9jYWNoZVtpXTsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbTsKCgkJaWYgKGNlLT5jZV9mbGFncyAmIENFX1VQREFURSkKCQkJY29udGludWU7CgkJaWYgKCFjZV9wYXRoX21hdGNoKCZ0aGVfaW5kZXgsIGNlLCBwYXR0ZXJuLCBtKSkKCQkJY29udGludWU7CgkJaXRlbSA9IHN0cmluZ19saXN0X2luc2VydChsaXN0LCBjZS0+bmFtZSk7CgkJaWYgKGNlX3NraXBfd29ya3RyZWUoY2UpKQoJCQlpdGVtLT51dGlsID0gaXRlbTsgLyogYmV0dGVyIGEgdmFsaWQgcG9pbnRlciB0aGFuIGEgZmFrZSBvbmUgKi8KCX0KCglyZXQgPSByZXBvcnRfcGF0aF9lcnJvcihtLCBwYXR0ZXJuLCBwcmVmaXgpOwoJZnJlZShtKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyB2b2lkIGFkZF9yZW1vdmVfZmlsZXMoc3RydWN0IHN0cmluZ19saXN0ICpsaXN0KQp7CglpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCBsaXN0LT5ucjsgaSsrKSB7CgkJc3RydWN0IHN0YXQgc3Q7CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKnAgPSAmKGxpc3QtPml0ZW1zW2ldKTsKCgkJLyogcC0+dXRpbCBpcyBza2lwLXdvcmt0cmVlICovCgkJaWYgKHAtPnV0aWwpCgkJCWNvbnRpbnVlOwoKCQlpZiAoIWxzdGF0KHAtPnN0cmluZywgJnN0KSkgewoJCQlpZiAoYWRkX3RvX2NhY2hlKHAtPnN0cmluZywgJnN0LCAwKSkKCQkJCWRpZShfKCJ1cGRhdGluZyBmaWxlcyBmYWlsZWQiKSk7CgkJfSBlbHNlCgkJCXJlbW92ZV9maWxlX2Zyb21fY2FjaGUocC0+c3RyaW5nKTsKCX0KfQoKc3RhdGljIHZvaWQgY3JlYXRlX2Jhc2VfaW5kZXgoY29uc3Qgc3RydWN0IGNvbW1pdCAqY3VycmVudF9oZWFkKQp7CglzdHJ1Y3QgdHJlZSAqdHJlZTsKCXN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyBvcHRzOwoJc3RydWN0IHRyZWVfZGVzYyB0OwoKCWlmICghY3VycmVudF9oZWFkKSB7CgkJZGlzY2FyZF9jYWNoZSgpOwoJCXJldHVybjsKCX0KCgltZW1zZXQoJm9wdHMsIDAsIHNpemVvZihvcHRzKSk7CglvcHRzLmhlYWRfaWR4ID0gMTsKCW9wdHMuaW5kZXhfb25seSA9IDE7CglvcHRzLm1lcmdlID0gMTsKCW9wdHMuc3JjX2luZGV4ID0gJnRoZV9pbmRleDsKCW9wdHMuZHN0X2luZGV4ID0gJnRoZV9pbmRleDsKCglvcHRzLmZuID0gb25ld2F5X21lcmdlOwoJdHJlZSA9IHBhcnNlX3RyZWVfaW5kaXJlY3QoJmN1cnJlbnRfaGVhZC0+b2JqZWN0Lm9pZCk7CglpZiAoIXRyZWUpCgkJZGllKF8oImZhaWxlZCB0byB1bnBhY2sgSEVBRCB0cmVlIG9iamVjdCIpKTsKCXBhcnNlX3RyZWUodHJlZSk7Cglpbml0X3RyZWVfZGVzYygmdCwgdHJlZS0+YnVmZmVyLCB0cmVlLT5zaXplKTsKCWlmICh1bnBhY2tfdHJlZXMoMSwgJnQsICZvcHRzKSkKCQlleGl0KDEyOCk7IC8qIFdlJ3ZlIGFscmVhZHkgcmVwb3J0ZWQgdGhlIGVycm9yLCBmaW5pc2ggZHlpbmcgKi8KfQoKc3RhdGljIHZvaWQgcmVmcmVzaF9jYWNoZV9vcl9kaWUoaW50IHJlZnJlc2hfZmxhZ3MpCnsKCS8qCgkgKiByZWZyZXNoX2ZsYWdzIGNvbnRhaW5zIFJFRlJFU0hfUVVJRVQsIHNvIHRoZSBvbmx5IGVycm9ycwoJICogYXJlIGZvciB1bm1lcmdlZCBlbnRyaWVzLgoJICovCglpZiAocmVmcmVzaF9jYWNoZShyZWZyZXNoX2ZsYWdzIHwgUkVGUkVTSF9JTl9QT1JDRUxBSU4pKQoJCWRpZV9yZXNvbHZlX2NvbmZsaWN0KCJjb21taXQiKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnByZXBhcmVfaW5kZXgoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgsCgkJCQkgY29uc3Qgc3RydWN0IGNvbW1pdCAqY3VycmVudF9oZWFkLCBpbnQgaXNfc3RhdHVzKQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgcGFydGlhbCA9IFNUUklOR19MSVNUX0lOSVRfRFVQOwoJc3RydWN0IHBhdGhzcGVjIHBhdGhzcGVjOwoJaW50IHJlZnJlc2hfZmxhZ3MgPSBSRUZSRVNIX1FVSUVUOwoJY29uc3QgY2hhciAqcmV0OwoKCWlmIChpc19zdGF0dXMpCgkJcmVmcmVzaF9mbGFncyB8PSBSRUZSRVNIX1VOTUVSR0VEOwoJcGFyc2VfcGF0aHNwZWMoJnBhdGhzcGVjLCAwLAoJCSAgICAgICBQQVRIU1BFQ19QUkVGRVJfRlVMTCwKCQkgICAgICAgcHJlZml4LCBhcmd2KTsKCglpZiAocmVhZF9jYWNoZV9wcmVsb2FkKCZwYXRoc3BlYykgPCAwKQoJCWRpZShfKCJpbmRleCBmaWxlIGNvcnJ1cHQiKSk7CgoJaWYgKGludGVyYWN0aXZlKSB7CgkJY2hhciAqb2xkX2luZGV4X2VudiA9IE5VTEw7CgkJaG9sZF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2ssIExPQ0tfRElFX09OX0VSUk9SKTsKCgkJcmVmcmVzaF9jYWNoZV9vcl9kaWUocmVmcmVzaF9mbGFncyk7CgoJCWlmICh3cml0ZV9sb2NrZWRfaW5kZXgoJnRoZV9pbmRleCwgJmluZGV4X2xvY2ssIDApKQoJCQlkaWUoXygidW5hYmxlIHRvIGNyZWF0ZSB0ZW1wb3JhcnkgaW5kZXgiKSk7CgoJCW9sZF9pbmRleF9lbnYgPSBnZXRlbnYoSU5ERVhfRU5WSVJPTk1FTlQpOwoJCXNldGVudihJTkRFWF9FTlZJUk9OTUVOVCwgZ2V0X2xvY2tfZmlsZV9wYXRoKCZpbmRleF9sb2NrKSwgMSk7CgoJCWlmIChpbnRlcmFjdGl2ZV9hZGQoYXJnYywgYXJndiwgcHJlZml4LCBwYXRjaF9pbnRlcmFjdGl2ZSkgIT0gMCkKCQkJZGllKF8oImludGVyYWN0aXZlIGFkZCBmYWlsZWQiKSk7CgoJCWlmIChvbGRfaW5kZXhfZW52ICYmICpvbGRfaW5kZXhfZW52KQoJCQlzZXRlbnYoSU5ERVhfRU5WSVJPTk1FTlQsIG9sZF9pbmRleF9lbnYsIDEpOwoJCWVsc2UKCQkJdW5zZXRlbnYoSU5ERVhfRU5WSVJPTk1FTlQpOwoKCQlkaXNjYXJkX2NhY2hlKCk7CgkJcmVhZF9jYWNoZV9mcm9tKGdldF9sb2NrX2ZpbGVfcGF0aCgmaW5kZXhfbG9jaykpOwoJCWlmICh1cGRhdGVfbWFpbl9jYWNoZV90cmVlKFdSSVRFX1RSRUVfU0lMRU5UKSA9PSAwKSB7CgkJCWlmIChyZW9wZW5fbG9ja19maWxlKCZpbmRleF9sb2NrKSA8IDApCgkJCQlkaWUoXygidW5hYmxlIHRvIHdyaXRlIGluZGV4IGZpbGUiKSk7CgkJCWlmICh3cml0ZV9sb2NrZWRfaW5kZXgoJnRoZV9pbmRleCwgJmluZGV4X2xvY2ssIDApKQoJCQkJZGllKF8oInVuYWJsZSB0byB1cGRhdGUgdGVtcG9yYXJ5IGluZGV4IikpOwoJCX0gZWxzZQoJCQl3YXJuaW5nKF8oIkZhaWxlZCB0byB1cGRhdGUgbWFpbiBjYWNoZSB0cmVlIikpOwoKCQljb21taXRfc3R5bGUgPSBDT01NSVRfTk9STUFMOwoJCXJldCA9IGdldF9sb2NrX2ZpbGVfcGF0aCgmaW5kZXhfbG9jayk7CgkJZ290byBvdXQ7Cgl9CgoJLyoKCSAqIE5vbiBwYXJ0aWFsLCBub24gYXMtaXMgY29tbWl0LgoJICoKCSAqICgxKSBnZXQgdGhlIHJlYWwgaW5kZXg7CgkgKiAoMikgdXBkYXRlIHRoZV9pbmRleCBhcyBuZWNlc3Nhcnk7CgkgKiAoMykgd3JpdGUgdGhlX2luZGV4IG91dCB0byB0aGUgcmVhbCBpbmRleCAoc3RpbGwgbG9ja2VkKTsKCSAqICg0KSByZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGxvY2tlZCBpbmRleCBmaWxlLgoJICoKCSAqIFRoZSBjYWxsZXIgc2hvdWxkIHJ1biBob29rcyBvbiB0aGUgbG9ja2VkIHJlYWwgaW5kZXgsIGFuZAoJICogKEEpIGlmIGFsbCBnb2VzIHdlbGwsIGNvbW1pdCB0aGUgcmVhbCBpbmRleDsKCSAqIChCKSBvbiBmYWlsdXJlLCByb2xsYmFjayB0aGUgcmVhbCBpbmRleC4KCSAqLwoJaWYgKGFsbCB8fCAoYWxzbyAmJiBwYXRoc3BlYy5ucikpIHsKCQlob2xkX2xvY2tlZF9pbmRleCgmaW5kZXhfbG9jaywgTE9DS19ESUVfT05fRVJST1IpOwoJCWFkZF9maWxlc190b19jYWNoZShhbHNvID8gcHJlZml4IDogTlVMTCwgJnBhdGhzcGVjLCAwKTsKCQlyZWZyZXNoX2NhY2hlX29yX2RpZShyZWZyZXNoX2ZsYWdzKTsKCQl1cGRhdGVfbWFpbl9jYWNoZV90cmVlKFdSSVRFX1RSRUVfU0lMRU5UKTsKCQlpZiAod3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZpbmRleF9sb2NrLCAwKSkKCQkJZGllKF8oInVuYWJsZSB0byB3cml0ZSBuZXdfaW5kZXggZmlsZSIpKTsKCQljb21taXRfc3R5bGUgPSBDT01NSVRfTk9STUFMOwoJCXJldCA9IGdldF9sb2NrX2ZpbGVfcGF0aCgmaW5kZXhfbG9jayk7CgkJZ290byBvdXQ7Cgl9CgoJLyoKCSAqIEFzLWlzIGNvbW1pdC4KCSAqCgkgKiAoMSkgcmV0dXJuIHRoZSBuYW1lIG9mIHRoZSByZWFsIGluZGV4IGZpbGUuCgkgKgoJICogVGhlIGNhbGxlciBzaG91bGQgcnVuIGhvb2tzIG9uIHRoZSByZWFsIGluZGV4LAoJICogYW5kIGNyZWF0ZSBjb21taXQgZnJvbSB0aGVfaW5kZXguCgkgKiBXZSBzdGlsbCBuZWVkIHRvIHJlZnJlc2ggdGhlIGluZGV4IGhlcmUuCgkgKi8KCWlmICghb25seSAmJiAhcGF0aHNwZWMubnIpIHsKCQlob2xkX2xvY2tlZF9pbmRleCgmaW5kZXhfbG9jaywgTE9DS19ESUVfT05fRVJST1IpOwoJCXJlZnJlc2hfY2FjaGVfb3JfZGllKHJlZnJlc2hfZmxhZ3MpOwoJCWlmIChhY3RpdmVfY2FjaGVfY2hhbmdlZAoJCSAgICB8fCAhY2FjaGVfdHJlZV9mdWxseV92YWxpZChhY3RpdmVfY2FjaGVfdHJlZSkpCgkJCXVwZGF0ZV9tYWluX2NhY2hlX3RyZWUoV1JJVEVfVFJFRV9TSUxFTlQpOwoJCWlmICh3cml0ZV9sb2NrZWRfaW5kZXgoJnRoZV9pbmRleCwgJmluZGV4X2xvY2ssCgkJCQkgICAgICAgQ09NTUlUX0xPQ0sgfCBTS0lQX0lGX1VOQ0hBTkdFRCkpCgkJCWRpZShfKCJ1bmFibGUgdG8gd3JpdGUgbmV3X2luZGV4IGZpbGUiKSk7CgkJY29tbWl0X3N0eWxlID0gQ09NTUlUX0FTX0lTOwoJCXJldCA9IGdldF9pbmRleF9maWxlKCk7CgkJZ290byBvdXQ7Cgl9CgoJLyoKCSAqIEEgcGFydGlhbCBjb21taXQuCgkgKgoJICogKDApIGZpbmQgdGhlIHNldCBvZiBhZmZlY3RlZCBwYXRoczsKCSAqICgxKSBnZXQgbG9jayBvbiB0aGUgcmVhbCBpbmRleCBmaWxlOwoJICogKDIpIHVwZGF0ZSB0aGVfaW5kZXggd2l0aCB0aGUgZ2l2ZW4gcGF0aHM7CgkgKiAoMykgd3JpdGUgdGhlX2luZGV4IG91dCB0byB0aGUgcmVhbCBpbmRleCAoc3RpbGwgbG9ja2VkKTsKCSAqICg0KSBnZXQgbG9jayBvbiB0aGUgZmFsc2UgaW5kZXggZmlsZTsKCSAqICg1KSByZXNldCB0aGVfaW5kZXggZnJvbSBIRUFEOwoJICogKDYpIHVwZGF0ZSB0aGVfaW5kZXggdGhlIHNhbWUgd2F5IGFzICgyKTsKCSAqICg3KSB3cml0ZSB0aGVfaW5kZXggb3V0IHRvIHRoZSBmYWxzZSBpbmRleCBmaWxlOwoJICogKDgpIHJldHVybiB0aGUgbmFtZSBvZiB0aGUgZmFsc2UgaW5kZXggZmlsZSAoc3RpbGwgbG9ja2VkKTsKCSAqCgkgKiBUaGUgY2FsbGVyIHNob3VsZCBydW4gaG9va3Mgb24gdGhlIGxvY2tlZCBmYWxzZSBpbmRleCwgYW5kCgkgKiBjcmVhdGUgY29tbWl0IGZyb20gaXQuICBUaGVuCgkgKiAoQSkgaWYgYWxsIGdvZXMgd2VsbCwgY29tbWl0IHRoZSByZWFsIGluZGV4OwoJICogKEIpIG9uIGZhaWx1cmUsIHJvbGxiYWNrIHRoZSByZWFsIGluZGV4OwoJICogSW4gZWl0aGVyIGNhc2UsIHJvbGxiYWNrIHRoZSBmYWxzZSBpbmRleC4KCSAqLwoJY29tbWl0X3N0eWxlID0gQ09NTUlUX1BBUlRJQUw7CgoJaWYgKHdoZW5jZSAhPSBGUk9NX0NPTU1JVCkgewoJCWlmICh3aGVuY2UgPT0gRlJPTV9NRVJHRSkKCQkJZGllKF8oImNhbm5vdCBkbyBhIHBhcnRpYWwgY29tbWl0IGR1cmluZyBhIG1lcmdlLiIpKTsKCQllbHNlIGlmICh3aGVuY2UgPT0gRlJPTV9DSEVSUllfUElDSykKCQkJZGllKF8oImNhbm5vdCBkbyBhIHBhcnRpYWwgY29tbWl0IGR1cmluZyBhIGNoZXJyeS1waWNrLiIpKTsKCX0KCglpZiAobGlzdF9wYXRocygmcGFydGlhbCwgIWN1cnJlbnRfaGVhZCA/IE5VTEwgOiAiSEVBRCIsIHByZWZpeCwgJnBhdGhzcGVjKSkKCQlleGl0KDEpOwoKCWRpc2NhcmRfY2FjaGUoKTsKCWlmIChyZWFkX2NhY2hlKCkgPCAwKQoJCWRpZShfKCJjYW5ub3QgcmVhZCB0aGUgaW5kZXgiKSk7CgoJaG9sZF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2ssIExPQ0tfRElFX09OX0VSUk9SKTsKCWFkZF9yZW1vdmVfZmlsZXMoJnBhcnRpYWwpOwoJcmVmcmVzaF9jYWNoZShSRUZSRVNIX1FVSUVUKTsKCXVwZGF0ZV9tYWluX2NhY2hlX3RyZWUoV1JJVEVfVFJFRV9TSUxFTlQpOwoJaWYgKHdyaXRlX2xvY2tlZF9pbmRleCgmdGhlX2luZGV4LCAmaW5kZXhfbG9jaywgMCkpCgkJZGllKF8oInVuYWJsZSB0byB3cml0ZSBuZXdfaW5kZXggZmlsZSIpKTsKCglob2xkX2xvY2tfZmlsZV9mb3JfdXBkYXRlKCZmYWxzZV9sb2NrLAoJCQkJICBnaXRfcGF0aCgibmV4dC1pbmRleC0lIlBSSXVNQVgsCgkJCQkJICAgKHVpbnRtYXhfdCkgZ2V0cGlkKCkpLAoJCQkJICBMT0NLX0RJRV9PTl9FUlJPUik7CgoJY3JlYXRlX2Jhc2VfaW5kZXgoY3VycmVudF9oZWFkKTsKCWFkZF9yZW1vdmVfZmlsZXMoJnBhcnRpYWwpOwoJcmVmcmVzaF9jYWNoZShSRUZSRVNIX1FVSUVUKTsKCglpZiAod3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZmYWxzZV9sb2NrLCAwKSkKCQlkaWUoXygidW5hYmxlIHRvIHdyaXRlIHRlbXBvcmFyeSBpbmRleCBmaWxlIikpOwoKCWRpc2NhcmRfY2FjaGUoKTsKCXJldCA9IGdldF9sb2NrX2ZpbGVfcGF0aCgmZmFsc2VfbG9jayk7CglyZWFkX2NhY2hlX2Zyb20ocmV0KTsKb3V0OgoJc3RyaW5nX2xpc3RfY2xlYXIoJnBhcnRpYWwsIDApOwoJY2xlYXJfcGF0aHNwZWMoJnBhdGhzcGVjKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQgcnVuX3N0YXR1cyhGSUxFICpmcCwgY29uc3QgY2hhciAqaW5kZXhfZmlsZSwgY29uc3QgY2hhciAqcHJlZml4LCBpbnQgbm93YXJuLAoJCSAgICAgIHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoKCWlmIChzLT5yZWxhdGl2ZV9wYXRocykKCQlzLT5wcmVmaXggPSBwcmVmaXg7CgoJaWYgKGFtZW5kKSB7CgkJcy0+YW1lbmQgPSAxOwoJCXMtPnJlZmVyZW5jZSA9ICJIRUFEXjEiOwoJfQoJcy0+dmVyYm9zZSA9IHZlcmJvc2U7CglzLT5pbmRleF9maWxlID0gaW5kZXhfZmlsZTsKCXMtPmZwID0gZnA7CglzLT5ub3dhcm4gPSBub3dhcm47CglzLT5pc19pbml0aWFsID0gZ2V0X29pZChzLT5yZWZlcmVuY2UsICZvaWQpID8gMSA6IDA7CglpZiAoIXMtPmlzX2luaXRpYWwpCgkJaGFzaGNweShzLT5zaGExX2NvbW1pdCwgb2lkLmhhc2gpOwoJcy0+c3RhdHVzX2Zvcm1hdCA9IHN0YXR1c19mb3JtYXQ7CglzLT5pZ25vcmVfc3VibW9kdWxlX2FyZyA9IGlnbm9yZV9zdWJtb2R1bGVfYXJnOwoKCXd0X3N0YXR1c19jb2xsZWN0KHMpOwoJd3Rfc3RhdHVzX3ByaW50KHMpOwoJd3Rfc3RhdHVzX2NvbGxlY3RfZnJlZV9idWZmZXJzKHMpOwoKCXJldHVybiBzLT5jb21taXR0YWJsZTsKfQoKc3RhdGljIGludCBpc19hX21lcmdlKGNvbnN0IHN0cnVjdCBjb21taXQgKmN1cnJlbnRfaGVhZCkKewoJcmV0dXJuICEhKGN1cnJlbnRfaGVhZC0+cGFyZW50cyAmJiBjdXJyZW50X2hlYWQtPnBhcmVudHMtPm5leHQpOwp9CgpzdGF0aWMgdm9pZCBhc3NlcnRfc3BsaXRfaWRlbnQoc3RydWN0IGlkZW50X3NwbGl0ICppZCwgY29uc3Qgc3RydWN0IHN0cmJ1ZiAqYnVmKQp7CglpZiAoc3BsaXRfaWRlbnRfbGluZShpZCwgYnVmLT5idWYsIGJ1Zi0+bGVuKSB8fCAhaWQtPmRhdGVfYmVnaW4pCgkJQlVHKCJ1bmFibGUgdG8gcGFyc2Ugb3VyIG93biBpZGVudDogJXMiLCBidWYtPmJ1Zik7Cn0KCnN0YXRpYyB2b2lkIGV4cG9ydF9vbmUoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICpzLCBjb25zdCBjaGFyICplLCBpbnQgaGFjaykKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWlmIChoYWNrKQoJCXN0cmJ1Zl9hZGRjaCgmYnVmLCBoYWNrKTsKCXN0cmJ1Zl9hZGRmKCZidWYsICIlLipzIiwgKGludCkoZSAtIHMpLCBzKTsKCXNldGVudih2YXIsIGJ1Zi5idWYsIDEpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7Cn0KCnN0YXRpYyBpbnQgcGFyc2VfZm9yY2VfZGF0ZShjb25zdCBjaGFyICppbiwgc3RydWN0IHN0cmJ1ZiAqb3V0KQp7CglzdHJidWZfYWRkY2gob3V0LCAnQCcpOwoKCWlmIChwYXJzZV9kYXRlKGluLCBvdXQpIDwgMCkgewoJCWludCBlcnJvcnMgPSAwOwoJCXVuc2lnbmVkIGxvbmcgdCA9IGFwcHJveGlkYXRlX2NhcmVmdWwoaW4sICZlcnJvcnMpOwoJCWlmIChlcnJvcnMpCgkJCXJldHVybiAtMTsKCQlzdHJidWZfYWRkZihvdXQsICIlbHUiLCB0KTsKCX0KCglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgc2V0X2lkZW50X3ZhcihjaGFyICoqYnVmLCBjaGFyICp2YWwpCnsKCWZyZWUoKmJ1Zik7CgkqYnVmID0gdmFsOwp9CgpzdGF0aWMgdm9pZCBkZXRlcm1pbmVfYXV0aG9yX2luZm8oc3RydWN0IHN0cmJ1ZiAqYXV0aG9yX2lkZW50KQp7CgljaGFyICpuYW1lLCAqZW1haWwsICpkYXRlOwoJc3RydWN0IGlkZW50X3NwbGl0IGF1dGhvcjsKCgluYW1lID0geHN0cmR1cF9vcl9udWxsKGdldGVudigiR0lUX0FVVEhPUl9OQU1FIikpOwoJZW1haWwgPSB4c3RyZHVwX29yX251bGwoZ2V0ZW52KCJHSVRfQVVUSE9SX0VNQUlMIikpOwoJZGF0ZSA9IHhzdHJkdXBfb3JfbnVsbChnZXRlbnYoIkdJVF9BVVRIT1JfREFURSIpKTsKCglpZiAoYXV0aG9yX21lc3NhZ2UpIHsKCQlzdHJ1Y3QgaWRlbnRfc3BsaXQgaWRlbnQ7CgkJc2l6ZV90IGxlbjsKCQljb25zdCBjaGFyICphOwoKCQlhID0gZmluZF9jb21taXRfaGVhZGVyKGF1dGhvcl9tZXNzYWdlX2J1ZmZlciwgImF1dGhvciIsICZsZW4pOwoJCWlmICghYSkKCQkJZGllKF8oImNvbW1pdCAnJXMnIGxhY2tzIGF1dGhvciBoZWFkZXIiKSwgYXV0aG9yX21lc3NhZ2UpOwoJCWlmIChzcGxpdF9pZGVudF9saW5lKCZpZGVudCwgYSwgbGVuKSA8IDApCgkJCWRpZShfKCJjb21taXQgJyVzJyBoYXMgbWFsZm9ybWVkIGF1dGhvciBsaW5lIiksIGF1dGhvcl9tZXNzYWdlKTsKCgkJc2V0X2lkZW50X3ZhcigmbmFtZSwgeG1lbWR1cHooaWRlbnQubmFtZV9iZWdpbiwgaWRlbnQubmFtZV9lbmQgLSBpZGVudC5uYW1lX2JlZ2luKSk7CgkJc2V0X2lkZW50X3ZhcigmZW1haWwsIHhtZW1kdXB6KGlkZW50Lm1haWxfYmVnaW4sIGlkZW50Lm1haWxfZW5kIC0gaWRlbnQubWFpbF9iZWdpbikpOwoKCQlpZiAoaWRlbnQuZGF0ZV9iZWdpbikgewoJCQlzdHJ1Y3Qgc3RyYnVmIGRhdGVfYnVmID0gU1RSQlVGX0lOSVQ7CgkJCXN0cmJ1Zl9hZGRjaCgmZGF0ZV9idWYsICdAJyk7CgkJCXN0cmJ1Zl9hZGQoJmRhdGVfYnVmLCBpZGVudC5kYXRlX2JlZ2luLCBpZGVudC5kYXRlX2VuZCAtIGlkZW50LmRhdGVfYmVnaW4pOwoJCQlzdHJidWZfYWRkY2goJmRhdGVfYnVmLCAnICcpOwoJCQlzdHJidWZfYWRkKCZkYXRlX2J1ZiwgaWRlbnQudHpfYmVnaW4sIGlkZW50LnR6X2VuZCAtIGlkZW50LnR6X2JlZ2luKTsKCQkJc2V0X2lkZW50X3ZhcigmZGF0ZSwgc3RyYnVmX2RldGFjaCgmZGF0ZV9idWYsIE5VTEwpKTsKCQl9Cgl9CgoJaWYgKGZvcmNlX2F1dGhvcikgewoJCXN0cnVjdCBpZGVudF9zcGxpdCBpZGVudDsKCgkJaWYgKHNwbGl0X2lkZW50X2xpbmUoJmlkZW50LCBmb3JjZV9hdXRob3IsIHN0cmxlbihmb3JjZV9hdXRob3IpKSA8IDApCgkJCWRpZShfKCJtYWxmb3JtZWQgLS1hdXRob3IgcGFyYW1ldGVyIikpOwoJCXNldF9pZGVudF92YXIoJm5hbWUsIHhtZW1kdXB6KGlkZW50Lm5hbWVfYmVnaW4sIGlkZW50Lm5hbWVfZW5kIC0gaWRlbnQubmFtZV9iZWdpbikpOwoJCXNldF9pZGVudF92YXIoJmVtYWlsLCB4bWVtZHVweihpZGVudC5tYWlsX2JlZ2luLCBpZGVudC5tYWlsX2VuZCAtIGlkZW50Lm1haWxfYmVnaW4pKTsKCX0KCglpZiAoZm9yY2VfZGF0ZSkgewoJCXN0cnVjdCBzdHJidWYgZGF0ZV9idWYgPSBTVFJCVUZfSU5JVDsKCQlpZiAocGFyc2VfZm9yY2VfZGF0ZShmb3JjZV9kYXRlLCAmZGF0ZV9idWYpKQoJCQlkaWUoXygiaW52YWxpZCBkYXRlIGZvcm1hdDogJXMiKSwgZm9yY2VfZGF0ZSk7CgkJc2V0X2lkZW50X3ZhcigmZGF0ZSwgc3RyYnVmX2RldGFjaCgmZGF0ZV9idWYsIE5VTEwpKTsKCX0KCglzdHJidWZfYWRkc3RyKGF1dGhvcl9pZGVudCwgZm10X2lkZW50KG5hbWUsIGVtYWlsLCBkYXRlLCBJREVOVF9TVFJJQ1QpKTsKCWFzc2VydF9zcGxpdF9pZGVudCgmYXV0aG9yLCBhdXRob3JfaWRlbnQpOwoJZXhwb3J0X29uZSgiR0lUX0FVVEhPUl9OQU1FIiwgYXV0aG9yLm5hbWVfYmVnaW4sIGF1dGhvci5uYW1lX2VuZCwgMCk7CglleHBvcnRfb25lKCJHSVRfQVVUSE9SX0VNQUlMIiwgYXV0aG9yLm1haWxfYmVnaW4sIGF1dGhvci5tYWlsX2VuZCwgMCk7CglleHBvcnRfb25lKCJHSVRfQVVUSE9SX0RBVEUiLCBhdXRob3IuZGF0ZV9iZWdpbiwgYXV0aG9yLnR6X2VuZCwgJ0AnKTsKCWZyZWUobmFtZSk7CglmcmVlKGVtYWlsKTsKCWZyZWUoZGF0ZSk7Cn0KCnN0YXRpYyBpbnQgYXV0aG9yX2RhdGVfaXNfaW50ZXJlc3Rpbmcodm9pZCkKewoJcmV0dXJuIGF1dGhvcl9tZXNzYWdlIHx8IGZvcmNlX2RhdGU7Cn0KCnN0YXRpYyB2b2lkIGFkanVzdF9jb21tZW50X2xpbmVfY2hhcihjb25zdCBzdHJ1Y3Qgc3RyYnVmICpzYikKewoJY2hhciBjYW5kaWRhdGVzW10gPSAiIztAISQlXiZ8OiI7CgljaGFyICpjYW5kaWRhdGU7Cgljb25zdCBjaGFyICpwOwoKCWNvbW1lbnRfbGluZV9jaGFyID0gY2FuZGlkYXRlc1swXTsKCWlmICghbWVtY2hyKHNiLT5idWYsIGNvbW1lbnRfbGluZV9jaGFyLCBzYi0+bGVuKSkKCQlyZXR1cm47CgoJcCA9IHNiLT5idWY7CgljYW5kaWRhdGUgPSBzdHJjaHIoY2FuZGlkYXRlcywgKnApOwoJaWYgKGNhbmRpZGF0ZSkKCQkqY2FuZGlkYXRlID0gJyAnOwoJZm9yIChwID0gc2ItPmJ1ZjsgKnA7IHArKykgewoJCWlmICgocFswXSA9PSAnXG4nIHx8IHBbMF0gPT0gJ1xyJykgJiYgcFsxXSkgewoJCQljYW5kaWRhdGUgPSBzdHJjaHIoY2FuZGlkYXRlcywgcFsxXSk7CgkJCWlmIChjYW5kaWRhdGUpCgkJCQkqY2FuZGlkYXRlID0gJyAnOwoJCX0KCX0KCglmb3IgKHAgPSBjYW5kaWRhdGVzOyAqcCA9PSAnICc7IHArKykKCQk7CglpZiAoISpwKQoJCWRpZShfKCJ1bmFibGUgdG8gc2VsZWN0IGEgY29tbWVudCBjaGFyYWN0ZXIgdGhhdCBpcyBub3QgdXNlZFxuIgoJCSAgICAgICJpbiB0aGUgY3VycmVudCBjb21taXQgbWVzc2FnZSIpKTsKCWNvbW1lbnRfbGluZV9jaGFyID0gKnA7Cn0KCnN0YXRpYyBpbnQgcHJlcGFyZV90b19jb21taXQoY29uc3QgY2hhciAqaW5kZXhfZmlsZSwgY29uc3QgY2hhciAqcHJlZml4LAoJCQkgICAgIHN0cnVjdCBjb21taXQgKmN1cnJlbnRfaGVhZCwKCQkJICAgICBzdHJ1Y3Qgd3Rfc3RhdHVzICpzLAoJCQkgICAgIHN0cnVjdCBzdHJidWYgKmF1dGhvcl9pZGVudCkKewoJc3RydWN0IHN0YXQgc3RhdGJ1ZjsKCXN0cnVjdCBzdHJidWYgY29tbWl0dGVyX2lkZW50ID0gU1RSQlVGX0lOSVQ7CglpbnQgY29tbWl0dGFibGU7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpob29rX2FyZzEgPSBOVUxMOwoJY29uc3QgY2hhciAqaG9va19hcmcyID0gTlVMTDsKCWludCBjbGVhbl9tZXNzYWdlX2NvbnRlbnRzID0gKGNsZWFudXBfbW9kZSAhPSBDT01NSVRfTVNHX0NMRUFOVVBfTk9ORSk7CglpbnQgb2xkX2Rpc3BsYXlfY29tbWVudF9wcmVmaXg7CgoJLyogVGhpcyBjaGVja3MgYW5kIGJhcmZzIGlmIGF1dGhvciBpcyBiYWRseSBzcGVjaWZpZWQgKi8KCWRldGVybWluZV9hdXRob3JfaW5mbyhhdXRob3JfaWRlbnQpOwoKCWlmICghbm9fdmVyaWZ5ICYmIHJ1bl9jb21taXRfaG9vayh1c2VfZWRpdG9yLCBpbmRleF9maWxlLCAicHJlLWNvbW1pdCIsIE5VTEwpKQoJCXJldHVybiAwOwoKCWlmIChzcXVhc2hfbWVzc2FnZSkgewoJCS8qCgkJICogSW5zZXJ0IHRoZSBwcm9wZXIgc3ViamVjdCBsaW5lIGJlZm9yZSBvdGhlciBjb21taXQKCQkgKiBtZXNzYWdlIG9wdGlvbnMgYWRkIHRoZWlyIGNvbnRlbnQuCgkJICovCgkJaWYgKHVzZV9tZXNzYWdlICYmICFzdHJjbXAodXNlX21lc3NhZ2UsIHNxdWFzaF9tZXNzYWdlKSkKCQkJc3RyYnVmX2FkZHN0cigmc2IsICJzcXVhc2ghICIpOwoJCWVsc2UgewoJCQlzdHJ1Y3QgcHJldHR5X3ByaW50X2NvbnRleHQgY3R4ID0gezB9OwoJCQlzdHJ1Y3QgY29tbWl0ICpjOwoJCQljID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfYnlfbmFtZShzcXVhc2hfbWVzc2FnZSk7CgkJCWlmICghYykKCQkJCWRpZShfKCJjb3VsZCBub3QgbG9va3VwIGNvbW1pdCAlcyIpLCBzcXVhc2hfbWVzc2FnZSk7CgkJCWN0eC5vdXRwdXRfZW5jb2RpbmcgPSBnZXRfY29tbWl0X291dHB1dF9lbmNvZGluZygpOwoJCQlmb3JtYXRfY29tbWl0X21lc3NhZ2UoYywgInNxdWFzaCEgJXNcblxuIiwgJnNiLAoJCQkJCSAgICAgICZjdHgpOwoJCX0KCX0KCglpZiAoaGF2ZV9vcHRpb25fbSAmJiAhZml4dXBfbWVzc2FnZSkgewoJCXN0cmJ1Zl9hZGRidWYoJnNiLCAmbWVzc2FnZSk7CgkJaG9va19hcmcxID0gIm1lc3NhZ2UiOwoJfSBlbHNlIGlmIChsb2dmaWxlICYmICFzdHJjbXAobG9nZmlsZSwgIi0iKSkgewoJCWlmIChpc2F0dHkoMCkpCgkJCWZwcmludGYoc3RkZXJyLCBfKCIocmVhZGluZyBsb2cgbWVzc2FnZSBmcm9tIHN0YW5kYXJkIGlucHV0KVxuIikpOwoJCWlmIChzdHJidWZfcmVhZCgmc2IsIDAsIDApIDwgMCkKCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkIGxvZyBmcm9tIHN0YW5kYXJkIGlucHV0IikpOwoJCWhvb2tfYXJnMSA9ICJtZXNzYWdlIjsKCX0gZWxzZSBpZiAobG9nZmlsZSkgewoJCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgbG9nZmlsZSwgMCkgPCAwKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlYWQgbG9nIGZpbGUgJyVzJyIpLAoJCQkJICBsb2dmaWxlKTsKCQlob29rX2FyZzEgPSAibWVzc2FnZSI7Cgl9IGVsc2UgaWYgKHVzZV9tZXNzYWdlKSB7CgkJY2hhciAqYnVmZmVyOwoJCWJ1ZmZlciA9IHN0cnN0cih1c2VfbWVzc2FnZV9idWZmZXIsICJcblxuIik7CgkJaWYgKGJ1ZmZlcikKCQkJc3RyYnVmX2FkZHN0cigmc2IsIHNraXBfYmxhbmtfbGluZXMoYnVmZmVyICsgMikpOwoJCWhvb2tfYXJnMSA9ICJjb21taXQiOwoJCWhvb2tfYXJnMiA9IHVzZV9tZXNzYWdlOwoJfSBlbHNlIGlmIChmaXh1cF9tZXNzYWdlKSB7CgkJc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0IGN0eCA9IHswfTsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgkJY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfYnlfbmFtZShmaXh1cF9tZXNzYWdlKTsKCQlpZiAoIWNvbW1pdCkKCQkJZGllKF8oImNvdWxkIG5vdCBsb29rdXAgY29tbWl0ICVzIiksIGZpeHVwX21lc3NhZ2UpOwoJCWN0eC5vdXRwdXRfZW5jb2RpbmcgPSBnZXRfY29tbWl0X291dHB1dF9lbmNvZGluZygpOwoJCWZvcm1hdF9jb21taXRfbWVzc2FnZShjb21taXQsICJmaXh1cCEgJXNcblxuIiwKCQkJCSAgICAgICZzYiwgJmN0eCk7CgkJaWYgKGhhdmVfb3B0aW9uX20pCgkJCXN0cmJ1Zl9hZGRidWYoJnNiLCAmbWVzc2FnZSk7CgkJaG9va19hcmcxID0gIm1lc3NhZ2UiOwoJfSBlbHNlIGlmICghc3RhdChnaXRfcGF0aF9tZXJnZV9tc2codGhlX3JlcG9zaXRvcnkpLCAmc3RhdGJ1ZikpIHsKCQkvKgoJCSAqIHByZXBlbmQgU1FVQVNIX01TRyBoZXJlIGlmIGl0IGV4aXN0cyBhbmQgYQoJCSAqICJtZXJnZSAtLXNxdWFzaCIgd2FzIG9yaWdpbmFsbHkgcGVyZm9ybWVkCgkJICovCgkJaWYgKCFzdGF0KGdpdF9wYXRoX3NxdWFzaF9tc2codGhlX3JlcG9zaXRvcnkpLCAmc3RhdGJ1ZikpIHsKCQkJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJnNiLCBnaXRfcGF0aF9zcXVhc2hfbXNnKHRoZV9yZXBvc2l0b3J5KSwgMCkgPCAwKQoJCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkIFNRVUFTSF9NU0ciKSk7CgkJCWhvb2tfYXJnMSA9ICJzcXVhc2giOwoJCX0gZWxzZQoJCQlob29rX2FyZzEgPSAibWVyZ2UiOwoJCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgZ2l0X3BhdGhfbWVyZ2VfbXNnKHRoZV9yZXBvc2l0b3J5KSwgMCkgPCAwKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlYWQgTUVSR0VfTVNHIikpOwoJfSBlbHNlIGlmICghc3RhdChnaXRfcGF0aF9zcXVhc2hfbXNnKHRoZV9yZXBvc2l0b3J5KSwgJnN0YXRidWYpKSB7CgkJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJnNiLCBnaXRfcGF0aF9zcXVhc2hfbXNnKHRoZV9yZXBvc2l0b3J5KSwgMCkgPCAwKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlYWQgU1FVQVNIX01TRyIpKTsKCQlob29rX2FyZzEgPSAic3F1YXNoIjsKCX0gZWxzZSBpZiAodGVtcGxhdGVfZmlsZSkgewoJCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgdGVtcGxhdGVfZmlsZSwgMCkgPCAwKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlYWQgJyVzJyIpLCB0ZW1wbGF0ZV9maWxlKTsKCQlob29rX2FyZzEgPSAidGVtcGxhdGUiOwoJCWNsZWFuX21lc3NhZ2VfY29udGVudHMgPSAwOwoJfQoKCS8qCgkgKiBUaGUgcmVtYWluaW5nIGNhc2VzIGRvbid0IG1vZGlmeSB0aGUgdGVtcGxhdGUgbWVzc2FnZSwgYnV0CgkgKiBqdXN0IHNldCB0aGUgYXJndW1lbnQocykgdG8gdGhlIHByZXBhcmUtY29tbWl0LW1zZyBob29rLgoJICovCgllbHNlIGlmICh3aGVuY2UgPT0gRlJPTV9NRVJHRSkKCQlob29rX2FyZzEgPSAibWVyZ2UiOwoJZWxzZSBpZiAod2hlbmNlID09IEZST01fQ0hFUlJZX1BJQ0spIHsKCQlob29rX2FyZzEgPSAiY29tbWl0IjsKCQlob29rX2FyZzIgPSAiQ0hFUlJZX1BJQ0tfSEVBRCI7Cgl9CgoJaWYgKHNxdWFzaF9tZXNzYWdlKSB7CgkJLyoKCQkgKiBJZiBzcXVhc2hfY29tbWl0IHdhcyB1c2VkIGZvciB0aGUgY29tbWl0IHN1YmplY3QsCgkJICogdGhlbiB3ZSdyZSBwb3NzaWJseSBoaWphY2tpbmcgb3RoZXIgY29tbWl0IGxvZyBvcHRpb25zLgoJCSAqIFJlc2V0IHRoZSBob29rIGFyZ3MgdG8gdGVsbCB0aGUgcmVhbCBzdG9yeS4KCQkgKi8KCQlob29rX2FyZzEgPSAibWVzc2FnZSI7CgkJaG9va19hcmcyID0gIiI7Cgl9CgoJcy0+ZnAgPSBmb3Blbl9mb3Jfd3JpdGluZyhnaXRfcGF0aF9jb21taXRfZWRpdG1zZygpKTsKCWlmIChzLT5mcCA9PSBOVUxMKQoJCWRpZV9lcnJubyhfKCJjb3VsZCBub3Qgb3BlbiAnJXMnIiksIGdpdF9wYXRoX2NvbW1pdF9lZGl0bXNnKCkpOwoKCS8qIElnbm9yZSBzdGF0dXMuZGlzcGxheUNvbW1lbnRQcmVmaXg6IHdlIGRvIG5lZWQgY29tbWVudHMgaW4gQ09NTUlUX0VESVRNU0cuICovCglvbGRfZGlzcGxheV9jb21tZW50X3ByZWZpeCA9IHMtPmRpc3BsYXlfY29tbWVudF9wcmVmaXg7CglzLT5kaXNwbGF5X2NvbW1lbnRfcHJlZml4ID0gMTsKCgkvKgoJICogTW9zdCBoaW50cyBhcmUgY291bnRlci1wcm9kdWN0aXZlIHdoZW4gdGhlIGNvbW1pdCBoYXMKCSAqIGFscmVhZHkgc3RhcnRlZC4KCSAqLwoJcy0+aGludHMgPSAwOwoKCWlmIChjbGVhbl9tZXNzYWdlX2NvbnRlbnRzKQoJCXN0cmJ1Zl9zdHJpcHNwYWNlKCZzYiwgMCk7CgoJaWYgKHNpZ25vZmYpCgkJYXBwZW5kX3NpZ25vZmYoJnNiLCBpZ25vcmVfbm9uX3RyYWlsZXIoc2IuYnVmLCBzYi5sZW4pLCAwKTsKCglpZiAoZndyaXRlKHNiLmJ1ZiwgMSwgc2IubGVuLCBzLT5mcCkgPCBzYi5sZW4pCgkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCB3cml0ZSBjb21taXQgdGVtcGxhdGUiKSk7CgoJaWYgKGF1dG9fY29tbWVudF9saW5lX2NoYXIpCgkJYWRqdXN0X2NvbW1lbnRfbGluZV9jaGFyKCZzYik7CglzdHJidWZfcmVsZWFzZSgmc2IpOwoKCS8qIFRoaXMgY2hlY2tzIGlmIGNvbW1pdHRlciBpZGVudCBpcyBleHBsaWNpdGx5IGdpdmVuICovCglzdHJidWZfYWRkc3RyKCZjb21taXR0ZXJfaWRlbnQsIGdpdF9jb21taXR0ZXJfaW5mbyhJREVOVF9TVFJJQ1QpKTsKCWlmICh1c2VfZWRpdG9yICYmIGluY2x1ZGVfc3RhdHVzKSB7CgkJaW50IGlkZW50X3Nob3duID0gMDsKCQlpbnQgc2F2ZWRfY29sb3Jfc2V0dGluZzsKCQlzdHJ1Y3QgaWRlbnRfc3BsaXQgY2ksIGFpOwoKCQlpZiAod2hlbmNlICE9IEZST01fQ09NTUlUKSB7CgkJCWlmIChjbGVhbnVwX21vZGUgPT0gQ09NTUlUX01TR19DTEVBTlVQX1NDSVNTT1JTKQoJCQkJd3Rfc3RhdHVzX2FkZF9jdXRfbGluZShzLT5mcCk7CgkJCXN0YXR1c19wcmludGZfbG4ocywgR0lUX0NPTE9SX05PUk1BTCwKCQkJICAgIHdoZW5jZSA9PSBGUk9NX01FUkdFCgkJCQk/IF8oIlxuIgoJCQkJCSJJdCBsb29rcyBsaWtlIHlvdSBtYXkgYmUgY29tbWl0dGluZyBhIG1lcmdlLlxuIgoJCQkJCSJJZiB0aGlzIGlzIG5vdCBjb3JyZWN0LCBwbGVhc2UgcmVtb3ZlIHRoZSBmaWxlXG4iCgkJCQkJIgklc1xuIgoJCQkJCSJhbmQgdHJ5IGFnYWluLlxuIikKCQkJCTogXygiXG4iCgkJCQkJIkl0IGxvb2tzIGxpa2UgeW91IG1heSBiZSBjb21taXR0aW5nIGEgY2hlcnJ5LXBpY2suXG4iCgkJCQkJIklmIHRoaXMgaXMgbm90IGNvcnJlY3QsIHBsZWFzZSByZW1vdmUgdGhlIGZpbGVcbiIKCQkJCQkiCSVzXG4iCgkJCQkJImFuZCB0cnkgYWdhaW4uXG4iKSwKCQkJCXdoZW5jZSA9PSBGUk9NX01FUkdFID8KCQkJCQlnaXRfcGF0aF9tZXJnZV9oZWFkKHRoZV9yZXBvc2l0b3J5KSA6CgkJCQkJZ2l0X3BhdGhfY2hlcnJ5X3BpY2tfaGVhZCh0aGVfcmVwb3NpdG9yeSkpOwoJCX0KCgkJZnByaW50ZihzLT5mcCwgIlxuIik7CgkJaWYgKGNsZWFudXBfbW9kZSA9PSBDT01NSVRfTVNHX0NMRUFOVVBfQUxMKQoJCQlzdGF0dXNfcHJpbnRmKHMsIEdJVF9DT0xPUl9OT1JNQUwsCgkJCQlfKCJQbGVhc2UgZW50ZXIgdGhlIGNvbW1pdCBtZXNzYWdlIGZvciB5b3VyIGNoYW5nZXMuIgoJCQkJICAiIExpbmVzIHN0YXJ0aW5nXG53aXRoICclYycgd2lsbCBiZSBpZ25vcmVkLCBhbmQgYW4gZW1wdHkiCgkJCQkgICIgbWVzc2FnZSBhYm9ydHMgdGhlIGNvbW1pdC5cbiIpLCBjb21tZW50X2xpbmVfY2hhcik7CgkJZWxzZSBpZiAoY2xlYW51cF9tb2RlID09IENPTU1JVF9NU0dfQ0xFQU5VUF9TQ0lTU09SUyAmJgoJCQkgd2hlbmNlID09IEZST01fQ09NTUlUKQoJCQl3dF9zdGF0dXNfYWRkX2N1dF9saW5lKHMtPmZwKTsKCQllbHNlIC8qIENPTU1JVF9NU0dfQ0xFQU5VUF9TUEFDRSwgdGhhdCBpcy4gKi8KCQkJc3RhdHVzX3ByaW50ZihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJXygiUGxlYXNlIGVudGVyIHRoZSBjb21taXQgbWVzc2FnZSBmb3IgeW91ciBjaGFuZ2VzLiIKCQkJCSAgIiBMaW5lcyBzdGFydGluZ1xuIgoJCQkJICAid2l0aCAnJWMnIHdpbGwgYmUga2VwdDsgeW91IG1heSByZW1vdmUgdGhlbSIKCQkJCSAgIiB5b3Vyc2VsZiBpZiB5b3Ugd2FudCB0by5cbiIKCQkJCSAgIkFuIGVtcHR5IG1lc3NhZ2UgYWJvcnRzIHRoZSBjb21taXQuXG4iKSwgY29tbWVudF9saW5lX2NoYXIpOwoKCQkvKgoJCSAqIFRoZXNlIHNob3VsZCBuZXZlciBmYWlsIGJlY2F1c2UgdGhleSBjb21lIGZyb20gb3VyIG93bgoJCSAqIGZtdF9pZGVudC4gVGhleSBtYXkgZmFpbCB0aGUgc2FuZV9pZGVudCB0ZXN0LCBidXQgd2Uga25vdwoJCSAqIHRoYXQgdGhlIG5hbWUgYW5kIG1haWwgcG9pbnRlcnMgd2lsbCBhdCBsZWFzdCBiZSB2YWxpZCwKCQkgKiB3aGljaCBpcyBlbm91Z2ggZm9yIG91ciB0ZXN0cyBhbmQgcHJpbnRpbmcgaGVyZS4KCQkgKi8KCQlhc3NlcnRfc3BsaXRfaWRlbnQoJmFpLCBhdXRob3JfaWRlbnQpOwoJCWFzc2VydF9zcGxpdF9pZGVudCgmY2ksICZjb21taXR0ZXJfaWRlbnQpOwoKCQlpZiAoaWRlbnRfY21wKCZhaSwgJmNpKSkKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJXygiJXMiCgkJCQkiQXV0aG9yOiAgICAlLipzIDwlLipzPiIpLAoJCQkJaWRlbnRfc2hvd24rKyA/ICIiIDogIlxuIiwKCQkJCShpbnQpKGFpLm5hbWVfZW5kIC0gYWkubmFtZV9iZWdpbiksIGFpLm5hbWVfYmVnaW4sCgkJCQkoaW50KShhaS5tYWlsX2VuZCAtIGFpLm1haWxfYmVnaW4pLCBhaS5tYWlsX2JlZ2luKTsKCgkJaWYgKGF1dGhvcl9kYXRlX2lzX2ludGVyZXN0aW5nKCkpCgkJCXN0YXR1c19wcmludGZfbG4ocywgR0lUX0NPTE9SX05PUk1BTCwKCQkJCV8oIiVzIgoJCQkJIkRhdGU6ICAgICAgJXMiKSwKCQkJCWlkZW50X3Nob3duKysgPyAiIiA6ICJcbiIsCgkJCQlzaG93X2lkZW50X2RhdGUoJmFpLCBEQVRFX01PREUoTk9STUFMKSkpOwoKCQlpZiAoIWNvbW1pdHRlcl9pZGVudF9zdWZmaWNpZW50bHlfZ2l2ZW4oKSkKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJXygiJXMiCgkJCQkiQ29tbWl0dGVyOiAlLipzIDwlLipzPiIpLAoJCQkJaWRlbnRfc2hvd24rKyA/ICIiIDogIlxuIiwKCQkJCShpbnQpKGNpLm5hbWVfZW5kIC0gY2kubmFtZV9iZWdpbiksIGNpLm5hbWVfYmVnaW4sCgkJCQkoaW50KShjaS5tYWlsX2VuZCAtIGNpLm1haWxfYmVnaW4pLCBjaS5tYWlsX2JlZ2luKTsKCgkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLCAiJXMiLCAiIik7IC8qIEFkZCBuZXcgbGluZSBmb3IgY2xhcml0eSAqLwoKCQlzYXZlZF9jb2xvcl9zZXR0aW5nID0gcy0+dXNlX2NvbG9yOwoJCXMtPnVzZV9jb2xvciA9IDA7CgkJY29tbWl0dGFibGUgPSBydW5fc3RhdHVzKHMtPmZwLCBpbmRleF9maWxlLCBwcmVmaXgsIDEsIHMpOwoJCXMtPnVzZV9jb2xvciA9IHNhdmVkX2NvbG9yX3NldHRpbmc7CgkJc3RyaW5nX2xpc3RfY2xlYXIoJnMtPmNoYW5nZSwgMSk7Cgl9IGVsc2UgewoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCWNvbnN0IGNoYXIgKnBhcmVudCA9ICJIRUFEIjsKCgkJaWYgKCFhY3RpdmVfbnIgJiYgcmVhZF9jYWNoZSgpIDwgMCkKCQkJZGllKF8oIkNhbm5vdCByZWFkIGluZGV4IikpOwoKCQlpZiAoYW1lbmQpCgkJCXBhcmVudCA9ICJIRUFEXjEiOwoKCQlpZiAoZ2V0X29pZChwYXJlbnQsICZvaWQpKSB7CgkJCWludCBpLCBpdGFfbnIgPSAwOwoKCQkJZm9yIChpID0gMDsgaSA8IGFjdGl2ZV9ucjsgaSsrKQoJCQkJaWYgKGNlX2ludGVudF90b19hZGQoYWN0aXZlX2NhY2hlW2ldKSkKCQkJCQlpdGFfbnIrKzsKCQkJY29tbWl0dGFibGUgPSBhY3RpdmVfbnIgLSBpdGFfbnIgPiAwOwoJCX0gZWxzZSB7CgkJCS8qCgkJCSAqIFVubGVzcyB0aGUgdXNlciBkaWQgZXhwbGljaXRseSByZXF1ZXN0IGEgc3VibW9kdWxlCgkJCSAqIGlnbm9yZSBtb2RlIGJ5IHBhc3NpbmcgYSBjb21tYW5kIGxpbmUgb3B0aW9uIHdlIGRvCgkJCSAqIG5vdCBpZ25vcmUgYW55IGNoYW5nZWQgc3VibW9kdWxlIFNIQS0xcyB3aGVuCgkJCSAqIGNvbXBhcmluZyBpbmRleCBhbmQgcGFyZW50LCBubyBtYXR0ZXIgd2hhdCBpcwoJCQkgKiBjb25maWd1cmVkLiBPdGhlcndpc2Ugd2Ugd29uJ3QgY29tbWl0IGFueQoJCQkgKiBzdWJtb2R1bGVzIHdoaWNoIHdlcmUgbWFudWFsbHkgc3RhZ2VkLCB3aGljaCB3b3VsZAoJCQkgKiBiZSByZWFsbHkgY29uZnVzaW5nLgoJCQkgKi8KCQkJc3RydWN0IGRpZmZfZmxhZ3MgZmxhZ3MgPSBESUZGX0ZMQUdTX0lOSVQ7CgkJCWZsYWdzLm92ZXJyaWRlX3N1Ym1vZHVsZV9jb25maWcgPSAxOwoJCQlpZiAoaWdub3JlX3N1Ym1vZHVsZV9hcmcgJiYKCQkJICAgICFzdHJjbXAoaWdub3JlX3N1Ym1vZHVsZV9hcmcsICJhbGwiKSkKCQkJCWZsYWdzLmlnbm9yZV9zdWJtb2R1bGVzID0gMTsKCQkJY29tbWl0dGFibGUgPSBpbmRleF9kaWZmZXJzX2Zyb20odGhlX3JlcG9zaXRvcnksCgkJCQkJCQkgcGFyZW50LCAmZmxhZ3MsIDEpOwoJCX0KCX0KCXN0cmJ1Zl9yZWxlYXNlKCZjb21taXR0ZXJfaWRlbnQpOwoKCWZjbG9zZShzLT5mcCk7CgoJLyoKCSAqIFJlamVjdCBhbiBhdHRlbXB0IHRvIHJlY29yZCBhIG5vbi1tZXJnZSBlbXB0eSBjb21taXQgd2l0aG91dAoJICogZXhwbGljaXQgLS1hbGxvdy1lbXB0eS4gSW4gdGhlIGNoZXJyeS1waWNrIGNhc2UsIGl0IG1heSBiZQoJICogZW1wdHkgZHVlIHRvIGNvbmZsaWN0IHJlc29sdXRpb24sIHdoaWNoIHRoZSB1c2VyIHNob3VsZCBva2F5LgoJICovCglpZiAoIWNvbW1pdHRhYmxlICYmIHdoZW5jZSAhPSBGUk9NX01FUkdFICYmICFhbGxvd19lbXB0eSAmJgoJICAgICEoYW1lbmQgJiYgaXNfYV9tZXJnZShjdXJyZW50X2hlYWQpKSkgewoJCXMtPmRpc3BsYXlfY29tbWVudF9wcmVmaXggPSBvbGRfZGlzcGxheV9jb21tZW50X3ByZWZpeDsKCQlydW5fc3RhdHVzKHN0ZG91dCwgaW5kZXhfZmlsZSwgcHJlZml4LCAwLCBzKTsKCQlpZiAoYW1lbmQpCgkJCWZwdXRzKF8oZW1wdHlfYW1lbmRfYWR2aWNlKSwgc3RkZXJyKTsKCQllbHNlIGlmICh3aGVuY2UgPT0gRlJPTV9DSEVSUllfUElDSykgewoJCQlmcHV0cyhfKGVtcHR5X2NoZXJyeV9waWNrX2FkdmljZSksIHN0ZGVycik7CgkJCWlmICghc2VxdWVuY2VyX2luX3VzZSkKCQkJCWZwdXRzKF8oZW1wdHlfY2hlcnJ5X3BpY2tfYWR2aWNlX3NpbmdsZSksIHN0ZGVycik7CgkJCWVsc2UKCQkJCWZwdXRzKF8oZW1wdHlfY2hlcnJ5X3BpY2tfYWR2aWNlX211bHRpKSwgc3RkZXJyKTsKCQl9CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKCFub192ZXJpZnkgJiYgZmluZF9ob29rKCJwcmUtY29tbWl0IikpIHsKCQkvKgoJCSAqIFJlLXJlYWQgdGhlIGluZGV4IGFzIHByZS1jb21taXQgaG9vayBjb3VsZCBoYXZlIHVwZGF0ZWQgaXQsCgkJICogYW5kIHdyaXRlIGl0IG91dCBhcyBhIHRyZWUuICBXZSBtdXN0IGRvIHRoaXMgYmVmb3JlIHdlIGludm9rZQoJCSAqIHRoZSBlZGl0b3IgYW5kIGFmdGVyIHdlIGludm9rZSBydW5fc3RhdHVzIGFib3ZlLgoJCSAqLwoJCWRpc2NhcmRfY2FjaGUoKTsKCX0KCXJlYWRfY2FjaGVfZnJvbShpbmRleF9maWxlKTsKCglpZiAodXBkYXRlX21haW5fY2FjaGVfdHJlZSgwKSkgewoJCWVycm9yKF8oIkVycm9yIGJ1aWxkaW5nIHRyZWVzIikpOwoJCXJldHVybiAwOwoJfQoKCWlmIChydW5fY29tbWl0X2hvb2sodXNlX2VkaXRvciwgaW5kZXhfZmlsZSwgInByZXBhcmUtY29tbWl0LW1zZyIsCgkJCSAgICBnaXRfcGF0aF9jb21taXRfZWRpdG1zZygpLCBob29rX2FyZzEsIGhvb2tfYXJnMiwgTlVMTCkpCgkJcmV0dXJuIDA7CgoJaWYgKHVzZV9lZGl0b3IpIHsKCQlzdHJ1Y3QgYXJndl9hcnJheSBlbnYgPSBBUkdWX0FSUkFZX0lOSVQ7CgoJCWFyZ3ZfYXJyYXlfcHVzaGYoJmVudiwgIkdJVF9JTkRFWF9GSUxFPSVzIiwgaW5kZXhfZmlsZSk7CgkJaWYgKGxhdW5jaF9lZGl0b3IoZ2l0X3BhdGhfY29tbWl0X2VkaXRtc2coKSwgTlVMTCwgZW52LmFyZ3YpKSB7CgkJCWZwcmludGYoc3RkZXJyLAoJCQlfKCJQbGVhc2Ugc3VwcGx5IHRoZSBtZXNzYWdlIHVzaW5nIGVpdGhlciAtbSBvciAtRiBvcHRpb24uXG4iKSk7CgkJCWV4aXQoMSk7CgkJfQoJCWFyZ3ZfYXJyYXlfY2xlYXIoJmVudik7Cgl9CgoJaWYgKCFub192ZXJpZnkgJiYKCSAgICBydW5fY29tbWl0X2hvb2sodXNlX2VkaXRvciwgaW5kZXhfZmlsZSwgImNvbW1pdC1tc2ciLCBnaXRfcGF0aF9jb21taXRfZWRpdG1zZygpLCBOVUxMKSkgewoJCXJldHVybiAwOwoJfQoKCXJldHVybiAxOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqZmluZF9hdXRob3JfYnlfbmlja25hbWUoY29uc3QgY2hhciAqbmFtZSkKewoJc3RydWN0IHJldl9pbmZvIHJldnM7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmluZ19saXN0IG1haWxtYXAgPSBTVFJJTkdfTElTVF9JTklUX05PRFVQOwoJY29uc3QgY2hhciAqYXZbMjBdOwoJaW50IGFjID0gMDsKCglyZXBvX2luaXRfcmV2aXNpb25zKHRoZV9yZXBvc2l0b3J5LCAmcmV2cywgTlVMTCk7CglzdHJidWZfYWRkZigmYnVmLCAiLS1hdXRob3I9JXMiLCBuYW1lKTsKCWF2WysrYWNdID0gIi0tYWxsIjsKCWF2WysrYWNdID0gIi1pIjsKCWF2WysrYWNdID0gYnVmLmJ1ZjsKCWF2WysrYWNdID0gTlVMTDsKCXNldHVwX3JldmlzaW9ucyhhYywgYXYsICZyZXZzLCBOVUxMKTsKCXJldnMubWFpbG1hcCA9ICZtYWlsbWFwOwoJcmVhZF9tYWlsbWFwKHJldnMubWFpbG1hcCwgTlVMTCk7CgoJaWYgKHByZXBhcmVfcmV2aXNpb25fd2FsaygmcmV2cykpCgkJZGllKF8oInJldmlzaW9uIHdhbGsgc2V0dXAgZmFpbGVkIikpOwoJY29tbWl0ID0gZ2V0X3JldmlzaW9uKCZyZXZzKTsKCWlmIChjb21taXQpIHsKCQlzdHJ1Y3QgcHJldHR5X3ByaW50X2NvbnRleHQgY3R4ID0gezB9OwoJCWN0eC5kYXRlX21vZGUudHlwZSA9IERBVEVfTk9STUFMOwoJCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJCWZvcm1hdF9jb21taXRfbWVzc2FnZShjb21taXQsICIlYU4gPCVhRT4iLCAmYnVmLCAmY3R4KTsKCQljbGVhcl9tYWlsbWFwKCZtYWlsbWFwKTsKCQlyZXR1cm4gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCX0KCWRpZShfKCItLWF1dGhvciAnJXMnIGlzIG5vdCAnTmFtZSA8ZW1haWw+JyBhbmQgbWF0Y2hlcyBubyBleGlzdGluZyBhdXRob3IiKSwgbmFtZSk7Cn0KCnN0YXRpYyB2b2lkIGhhbmRsZV9pZ25vcmVkX2FyZyhzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglpZiAoIWlnbm9yZWRfYXJnKQoJCTsgLyogZGVmYXVsdCBhbHJlYWR5IGluaXRpYWxpemVkICovCgllbHNlIGlmICghc3RyY21wKGlnbm9yZWRfYXJnLCAidHJhZGl0aW9uYWwiKSkKCQlzLT5zaG93X2lnbm9yZWRfbW9kZSA9IFNIT1dfVFJBRElUSU9OQUxfSUdOT1JFRDsKCWVsc2UgaWYgKCFzdHJjbXAoaWdub3JlZF9hcmcsICJubyIpKQoJCXMtPnNob3dfaWdub3JlZF9tb2RlID0gU0hPV19OT19JR05PUkVEOwoJZWxzZSBpZiAoIXN0cmNtcChpZ25vcmVkX2FyZywgIm1hdGNoaW5nIikpCgkJcy0+c2hvd19pZ25vcmVkX21vZGUgPSBTSE9XX01BVENISU5HX0lHTk9SRUQ7CgllbHNlCgkJZGllKF8oIkludmFsaWQgaWdub3JlZCBtb2RlICclcyciKSwgaWdub3JlZF9hcmcpOwp9CgpzdGF0aWMgdm9pZCBoYW5kbGVfdW50cmFja2VkX2ZpbGVzX2FyZyhzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglpZiAoIXVudHJhY2tlZF9maWxlc19hcmcpCgkJOyAvKiBkZWZhdWx0IGFscmVhZHkgaW5pdGlhbGl6ZWQgKi8KCWVsc2UgaWYgKCFzdHJjbXAodW50cmFja2VkX2ZpbGVzX2FyZywgIm5vIikpCgkJcy0+c2hvd191bnRyYWNrZWRfZmlsZXMgPSBTSE9XX05PX1VOVFJBQ0tFRF9GSUxFUzsKCWVsc2UgaWYgKCFzdHJjbXAodW50cmFja2VkX2ZpbGVzX2FyZywgIm5vcm1hbCIpKQoJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19OT1JNQUxfVU5UUkFDS0VEX0ZJTEVTOwoJZWxzZSBpZiAoIXN0cmNtcCh1bnRyYWNrZWRfZmlsZXNfYXJnLCAiYWxsIikpCgkJcy0+c2hvd191bnRyYWNrZWRfZmlsZXMgPSBTSE9XX0FMTF9VTlRSQUNLRURfRklMRVM7CgllbHNlCgkJZGllKF8oIkludmFsaWQgdW50cmFja2VkIGZpbGVzIG1vZGUgJyVzJyIpLCB1bnRyYWNrZWRfZmlsZXNfYXJnKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnJlYWRfY29tbWl0X21lc3NhZ2UoY29uc3QgY2hhciAqbmFtZSkKewoJY29uc3QgY2hhciAqb3V0X2VuYzsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCgljb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9ieV9uYW1lKG5hbWUpOwoJaWYgKCFjb21taXQpCgkJZGllKF8oImNvdWxkIG5vdCBsb29rdXAgY29tbWl0ICVzIiksIG5hbWUpOwoJb3V0X2VuYyA9IGdldF9jb21taXRfb3V0cHV0X2VuY29kaW5nKCk7CglyZXR1cm4gbG9nbXNnX3JlZW5jb2RlKGNvbW1pdCwgTlVMTCwgb3V0X2VuYyk7Cn0KCi8qCiAqIEVudW1lcmF0ZSB3aGF0IG5lZWRzIHRvIGJlIHByb3BhZ2F0ZWQgd2hlbiAtLXBvcmNlbGFpbgogKiBpcyBub3QgaW4gZWZmZWN0IGhlcmUuCiAqLwpzdGF0aWMgc3RydWN0IHN0YXR1c19kZWZlcnJlZF9jb25maWcgewoJZW51bSB3dF9zdGF0dXNfZm9ybWF0IHN0YXR1c19mb3JtYXQ7CglpbnQgc2hvd19icmFuY2g7Cn0gc3RhdHVzX2RlZmVycmVkX2NvbmZpZyA9IHsKCVNUQVRVU19GT1JNQVRfVU5TUEVDSUZJRUQsCgktMSAvKiB1bnNwZWNpZmllZCAqLwp9OwoKc3RhdGljIHZvaWQgZmluYWxpemVfZGVmZXJyZWRfY29uZmlnKHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWludCB1c2VfZGVmZXJyZWRfY29uZmlnID0gKHN0YXR1c19mb3JtYXQgIT0gU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU4gJiYKCQkJCSAgIHN0YXR1c19mb3JtYXQgIT0gU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU5fVjIgJiYKCQkJCSAgICFzLT5udWxsX3Rlcm1pbmF0aW9uKTsKCglpZiAocy0+bnVsbF90ZXJtaW5hdGlvbikgewoJCWlmIChzdGF0dXNfZm9ybWF0ID09IFNUQVRVU19GT1JNQVRfTk9ORSB8fAoJCSAgICBzdGF0dXNfZm9ybWF0ID09IFNUQVRVU19GT1JNQVRfVU5TUEVDSUZJRUQpCgkJCXN0YXR1c19mb3JtYXQgPSBTVEFUVVNfRk9STUFUX1BPUkNFTEFJTjsKCQllbHNlIGlmIChzdGF0dXNfZm9ybWF0ID09IFNUQVRVU19GT1JNQVRfTE9ORykKCQkJZGllKF8oIi0tbG9uZyBhbmQgLXogYXJlIGluY29tcGF0aWJsZSIpKTsKCX0KCglpZiAodXNlX2RlZmVycmVkX2NvbmZpZyAmJiBzdGF0dXNfZm9ybWF0ID09IFNUQVRVU19GT1JNQVRfVU5TUEVDSUZJRUQpCgkJc3RhdHVzX2Zvcm1hdCA9IHN0YXR1c19kZWZlcnJlZF9jb25maWcuc3RhdHVzX2Zvcm1hdDsKCWlmIChzdGF0dXNfZm9ybWF0ID09IFNUQVRVU19GT1JNQVRfVU5TUEVDSUZJRUQpCgkJc3RhdHVzX2Zvcm1hdCA9IFNUQVRVU19GT1JNQVRfTk9ORTsKCglpZiAodXNlX2RlZmVycmVkX2NvbmZpZyAmJiBzLT5zaG93X2JyYW5jaCA8IDApCgkJcy0+c2hvd19icmFuY2ggPSBzdGF0dXNfZGVmZXJyZWRfY29uZmlnLnNob3dfYnJhbmNoOwoJaWYgKHMtPnNob3dfYnJhbmNoIDwgMCkKCQlzLT5zaG93X2JyYW5jaCA9IDA7CgoJaWYgKHMtPmFoZWFkX2JlaGluZF9mbGFncyA9PSBBSEVBRF9CRUhJTkRfVU5TUEVDSUZJRUQpCgkJcy0+YWhlYWRfYmVoaW5kX2ZsYWdzID0gQUhFQURfQkVISU5EX0ZVTEw7Cn0KCnN0YXRpYyBpbnQgcGFyc2VfYW5kX3ZhbGlkYXRlX29wdGlvbnMoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKmFyZ3ZbXSwKCQkJCSAgICAgIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdGlvbnMsCgkJCQkgICAgICBjb25zdCBjaGFyICogY29uc3QgdXNhZ2VbXSwKCQkJCSAgICAgIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJCSAgICAgIHN0cnVjdCBjb21taXQgKmN1cnJlbnRfaGVhZCwKCQkJCSAgICAgIHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWludCBmID0gMDsKCglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIG9wdGlvbnMsIHVzYWdlLCAwKTsKCWZpbmFsaXplX2RlZmVycmVkX2NvbmZpZyhzKTsKCglpZiAoZm9yY2VfYXV0aG9yICYmICFzdHJjaHIoZm9yY2VfYXV0aG9yLCAnPicpKQoJCWZvcmNlX2F1dGhvciA9IGZpbmRfYXV0aG9yX2J5X25pY2tuYW1lKGZvcmNlX2F1dGhvcik7CgoJaWYgKGZvcmNlX2F1dGhvciAmJiByZW5ld19hdXRob3JzaGlwKQoJCWRpZShfKCJVc2luZyBib3RoIC0tcmVzZXQtYXV0aG9yIGFuZCAtLWF1dGhvciBkb2VzIG5vdCBtYWtlIHNlbnNlIikpOwoKCWlmIChsb2dmaWxlIHx8IGhhdmVfb3B0aW9uX20gfHwgdXNlX21lc3NhZ2UgfHwgZml4dXBfbWVzc2FnZSkKCQl1c2VfZWRpdG9yID0gMDsKCWlmICgwIDw9IGVkaXRfZmxhZykKCQl1c2VfZWRpdG9yID0gZWRpdF9mbGFnOwoKCS8qIFNhbml0eSBjaGVjayBvcHRpb25zICovCglpZiAoYW1lbmQgJiYgIWN1cnJlbnRfaGVhZCkKCQlkaWUoXygiWW91IGhhdmUgbm90aGluZyB0byBhbWVuZC4iKSk7CglpZiAoYW1lbmQgJiYgd2hlbmNlICE9IEZST01fQ09NTUlUKSB7CgkJaWYgKHdoZW5jZSA9PSBGUk9NX01FUkdFKQoJCQlkaWUoXygiWW91IGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgbWVyZ2UgLS0gY2Fubm90IGFtZW5kLiIpKTsKCQllbHNlIGlmICh3aGVuY2UgPT0gRlJPTV9DSEVSUllfUElDSykKCQkJZGllKF8oIllvdSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBhIGNoZXJyeS1waWNrIC0tIGNhbm5vdCBhbWVuZC4iKSk7Cgl9CglpZiAoZml4dXBfbWVzc2FnZSAmJiBzcXVhc2hfbWVzc2FnZSkKCQlkaWUoXygiT3B0aW9ucyAtLXNxdWFzaCBhbmQgLS1maXh1cCBjYW5ub3QgYmUgdXNlZCB0b2dldGhlciIpKTsKCWlmICh1c2VfbWVzc2FnZSkKCQlmKys7CglpZiAoZWRpdF9tZXNzYWdlKQoJCWYrKzsKCWlmIChmaXh1cF9tZXNzYWdlKQoJCWYrKzsKCWlmIChsb2dmaWxlKQoJCWYrKzsKCWlmIChmID4gMSkKCQlkaWUoXygiT25seSBvbmUgb2YgLWMvLUMvLUYvLS1maXh1cCBjYW4gYmUgdXNlZC4iKSk7CglpZiAoaGF2ZV9vcHRpb25fbSAmJiAoZWRpdF9tZXNzYWdlIHx8IHVzZV9tZXNzYWdlIHx8IGxvZ2ZpbGUpKQoJCWRpZSgoXygiT3B0aW9uIC1tIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIC1jLy1DLy1GLiIpKSk7CglpZiAoZiB8fCBoYXZlX29wdGlvbl9tKQoJCXRlbXBsYXRlX2ZpbGUgPSBOVUxMOwoJaWYgKGVkaXRfbWVzc2FnZSkKCQl1c2VfbWVzc2FnZSA9IGVkaXRfbWVzc2FnZTsKCWlmIChhbWVuZCAmJiAhdXNlX21lc3NhZ2UgJiYgIWZpeHVwX21lc3NhZ2UpCgkJdXNlX21lc3NhZ2UgPSAiSEVBRCI7CglpZiAoIXVzZV9tZXNzYWdlICYmIHdoZW5jZSAhPSBGUk9NX0NIRVJSWV9QSUNLICYmIHJlbmV3X2F1dGhvcnNoaXApCgkJZGllKF8oIi0tcmVzZXQtYXV0aG9yIGNhbiBiZSB1c2VkIG9ubHkgd2l0aCAtQywgLWMgb3IgLS1hbWVuZC4iKSk7CglpZiAodXNlX21lc3NhZ2UpIHsKCQl1c2VfbWVzc2FnZV9idWZmZXIgPSByZWFkX2NvbW1pdF9tZXNzYWdlKHVzZV9tZXNzYWdlKTsKCQlpZiAoIXJlbmV3X2F1dGhvcnNoaXApIHsKCQkJYXV0aG9yX21lc3NhZ2UgPSB1c2VfbWVzc2FnZTsKCQkJYXV0aG9yX21lc3NhZ2VfYnVmZmVyID0gdXNlX21lc3NhZ2VfYnVmZmVyOwoJCX0KCX0KCWlmICh3aGVuY2UgPT0gRlJPTV9DSEVSUllfUElDSyAmJiAhcmVuZXdfYXV0aG9yc2hpcCkgewoJCWF1dGhvcl9tZXNzYWdlID0gIkNIRVJSWV9QSUNLX0hFQUQiOwoJCWF1dGhvcl9tZXNzYWdlX2J1ZmZlciA9IHJlYWRfY29tbWl0X21lc3NhZ2UoYXV0aG9yX21lc3NhZ2UpOwoJfQoKCWlmIChwYXRjaF9pbnRlcmFjdGl2ZSkKCQlpbnRlcmFjdGl2ZSA9IDE7CgoJaWYgKGFsc28gKyBvbmx5ICsgYWxsICsgaW50ZXJhY3RpdmUgPiAxKQoJCWRpZShfKCJPbmx5IG9uZSBvZiAtLWluY2x1ZGUvLS1vbmx5Ly0tYWxsLy0taW50ZXJhY3RpdmUvLS1wYXRjaCBjYW4gYmUgdXNlZC4iKSk7CglpZiAoYXJnYyA9PSAwICYmIChhbHNvIHx8IChvbmx5ICYmICFhbWVuZCAmJiAhYWxsb3dfZW1wdHkpKSkKCQlkaWUoXygiTm8gcGF0aHMgd2l0aCAtLWluY2x1ZGUvLS1vbmx5IGRvZXMgbm90IG1ha2Ugc2Vuc2UuIikpOwoJaWYgKCFjbGVhbnVwX2FyZyB8fCAhc3RyY21wKGNsZWFudXBfYXJnLCAiZGVmYXVsdCIpKQoJCWNsZWFudXBfbW9kZSA9IHVzZV9lZGl0b3IgPyBDT01NSVRfTVNHX0NMRUFOVVBfQUxMIDoKCQkJCQkgICAgQ09NTUlUX01TR19DTEVBTlVQX1NQQUNFOwoJZWxzZSBpZiAoIXN0cmNtcChjbGVhbnVwX2FyZywgInZlcmJhdGltIikpCgkJY2xlYW51cF9tb2RlID0gQ09NTUlUX01TR19DTEVBTlVQX05PTkU7CgllbHNlIGlmICghc3RyY21wKGNsZWFudXBfYXJnLCAid2hpdGVzcGFjZSIpKQoJCWNsZWFudXBfbW9kZSA9IENPTU1JVF9NU0dfQ0xFQU5VUF9TUEFDRTsKCWVsc2UgaWYgKCFzdHJjbXAoY2xlYW51cF9hcmcsICJzdHJpcCIpKQoJCWNsZWFudXBfbW9kZSA9IENPTU1JVF9NU0dfQ0xFQU5VUF9BTEw7CgllbHNlIGlmICghc3RyY21wKGNsZWFudXBfYXJnLCAic2Npc3NvcnMiKSkKCQljbGVhbnVwX21vZGUgPSB1c2VfZWRpdG9yID8gQ09NTUlUX01TR19DTEVBTlVQX1NDSVNTT1JTIDoKCQkJCQkgICAgQ09NTUlUX01TR19DTEVBTlVQX1NQQUNFOwoJZWxzZQoJCWRpZShfKCJJbnZhbGlkIGNsZWFudXAgbW9kZSAlcyIpLCBjbGVhbnVwX2FyZyk7CgoJaGFuZGxlX3VudHJhY2tlZF9maWxlc19hcmcocyk7CgoJaWYgKGFsbCAmJiBhcmdjID4gMCkKCQlkaWUoXygiUGF0aHMgd2l0aCAtYSBkb2VzIG5vdCBtYWtlIHNlbnNlLiIpKTsKCglpZiAoc3RhdHVzX2Zvcm1hdCAhPSBTVEFUVVNfRk9STUFUX05PTkUpCgkJZHJ5X3J1biA9IDE7CgoJcmV0dXJuIGFyZ2M7Cn0KCnN0YXRpYyBpbnQgZHJ5X3J1bl9jb21taXQoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgsCgkJCSAgY29uc3Qgc3RydWN0IGNvbW1pdCAqY3VycmVudF9oZWFkLCBzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglpbnQgY29tbWl0dGFibGU7Cgljb25zdCBjaGFyICppbmRleF9maWxlOwoKCWluZGV4X2ZpbGUgPSBwcmVwYXJlX2luZGV4KGFyZ2MsIGFyZ3YsIHByZWZpeCwgY3VycmVudF9oZWFkLCAxKTsKCWNvbW1pdHRhYmxlID0gcnVuX3N0YXR1cyhzdGRvdXQsIGluZGV4X2ZpbGUsIHByZWZpeCwgMCwgcyk7Cglyb2xsYmFja19pbmRleF9maWxlcygpOwoKCXJldHVybiBjb21taXR0YWJsZSA/IDAgOiAxOwp9CgpkZWZpbmVfbGlzdF9jb25maWdfYXJyYXlfZXh0cmEoY29sb3Jfc3RhdHVzX3Nsb3RzLCB7ImFkZGVkIn0pOwoKc3RhdGljIGludCBwYXJzZV9zdGF0dXNfc2xvdChjb25zdCBjaGFyICpzbG90KQp7CglpZiAoIXN0cmNhc2VjbXAoc2xvdCwgImFkZGVkIikpCgkJcmV0dXJuIFdUX1NUQVRVU19VUERBVEVEOwoKCXJldHVybiBMT09LVVBfQ09ORklHKGNvbG9yX3N0YXR1c19zbG90cywgc2xvdCk7Cn0KCnN0YXRpYyBpbnQgZ2l0X3N0YXR1c19jb25maWcoY29uc3QgY2hhciAqaywgY29uc3QgY2hhciAqdiwgdm9pZCAqY2IpCnsKCXN0cnVjdCB3dF9zdGF0dXMgKnMgPSBjYjsKCWNvbnN0IGNoYXIgKnNsb3RfbmFtZTsKCglpZiAoc3RhcnRzX3dpdGgoaywgImNvbHVtbi4iKSkKCQlyZXR1cm4gZ2l0X2NvbHVtbl9jb25maWcoaywgdiwgInN0YXR1cyIsICZzLT5jb2xvcHRzKTsKCWlmICghc3RyY21wKGssICJzdGF0dXMuc3VibW9kdWxlc3VtbWFyeSIpKSB7CgkJaW50IGlzX2Jvb2w7CgkJcy0+c3VibW9kdWxlX3N1bW1hcnkgPSBnaXRfY29uZmlnX2Jvb2xfb3JfaW50KGssIHYsICZpc19ib29sKTsKCQlpZiAoaXNfYm9vbCAmJiBzLT5zdWJtb2R1bGVfc3VtbWFyeSkKCQkJcy0+c3VibW9kdWxlX3N1bW1hcnkgPSAtMTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMuc2hvcnQiKSkgewoJCWlmIChnaXRfY29uZmlnX2Jvb2woaywgdikpCgkJCXN0YXR1c19kZWZlcnJlZF9jb25maWcuc3RhdHVzX2Zvcm1hdCA9IFNUQVRVU19GT1JNQVRfU0hPUlQ7CgkJZWxzZQoJCQlzdGF0dXNfZGVmZXJyZWRfY29uZmlnLnN0YXR1c19mb3JtYXQgPSBTVEFUVVNfRk9STUFUX05PTkU7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAic3RhdHVzLmJyYW5jaCIpKSB7CgkJc3RhdHVzX2RlZmVycmVkX2NvbmZpZy5zaG93X2JyYW5jaCA9IGdpdF9jb25maWdfYm9vbChrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMuc2hvd3N0YXNoIikpIHsKCQlzLT5zaG93X3N0YXNoID0gZ2l0X2NvbmZpZ19ib29sKGssIHYpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaywgInN0YXR1cy5jb2xvciIpIHx8ICFzdHJjbXAoaywgImNvbG9yLnN0YXR1cyIpKSB7CgkJcy0+dXNlX2NvbG9yID0gZ2l0X2NvbmZpZ19jb2xvcmJvb2woaywgdik7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAic3RhdHVzLmRpc3BsYXljb21tZW50cHJlZml4IikpIHsKCQlzLT5kaXNwbGF5X2NvbW1lbnRfcHJlZml4ID0gZ2l0X2NvbmZpZ19ib29sKGssIHYpOwoJCXJldHVybiAwOwoJfQoJaWYgKHNraXBfcHJlZml4KGssICJzdGF0dXMuY29sb3IuIiwgJnNsb3RfbmFtZSkgfHwKCSAgICBza2lwX3ByZWZpeChrLCAiY29sb3Iuc3RhdHVzLiIsICZzbG90X25hbWUpKSB7CgkJaW50IHNsb3QgPSBwYXJzZV9zdGF0dXNfc2xvdChzbG90X25hbWUpOwoJCWlmIChzbG90IDwgMCkKCQkJcmV0dXJuIDA7CgkJaWYgKCF2KQoJCQlyZXR1cm4gY29uZmlnX2Vycm9yX25vbmJvb2woayk7CgkJcmV0dXJuIGNvbG9yX3BhcnNlKHYsIHMtPmNvbG9yX3BhbGV0dGVbc2xvdF0pOwoJfQoJaWYgKCFzdHJjbXAoaywgInN0YXR1cy5yZWxhdGl2ZXBhdGhzIikpIHsKCQlzLT5yZWxhdGl2ZV9wYXRocyA9IGdpdF9jb25maWdfYm9vbChrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMuc2hvd3VudHJhY2tlZGZpbGVzIikpIHsKCQlpZiAoIXYpCgkJCXJldHVybiBjb25maWdfZXJyb3Jfbm9uYm9vbChrKTsKCQllbHNlIGlmICghc3RyY21wKHYsICJubyIpKQoJCQlzLT5zaG93X3VudHJhY2tlZF9maWxlcyA9IFNIT1dfTk9fVU5UUkFDS0VEX0ZJTEVTOwoJCWVsc2UgaWYgKCFzdHJjbXAodiwgIm5vcm1hbCIpKQoJCQlzLT5zaG93X3VudHJhY2tlZF9maWxlcyA9IFNIT1dfTk9STUFMX1VOVFJBQ0tFRF9GSUxFUzsKCQllbHNlIGlmICghc3RyY21wKHYsICJhbGwiKSkKCQkJcy0+c2hvd191bnRyYWNrZWRfZmlsZXMgPSBTSE9XX0FMTF9VTlRSQUNLRURfRklMRVM7CgkJZWxzZQoJCQlyZXR1cm4gZXJyb3IoXygiSW52YWxpZCB1bnRyYWNrZWQgZmlsZXMgbW9kZSAnJXMnIiksIHYpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaywgImRpZmYucmVuYW1lbGltaXQiKSkgewoJCWlmIChzLT5yZW5hbWVfbGltaXQgPT0gLTEpCgkJCXMtPnJlbmFtZV9saW1pdCA9IGdpdF9jb25maWdfaW50KGssIHYpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaywgInN0YXR1cy5yZW5hbWVsaW1pdCIpKSB7CgkJcy0+cmVuYW1lX2xpbWl0ID0gZ2l0X2NvbmZpZ19pbnQoaywgdik7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAiZGlmZi5yZW5hbWVzIikpIHsKCQlpZiAocy0+ZGV0ZWN0X3JlbmFtZSA9PSAtMSkKCQkJcy0+ZGV0ZWN0X3JlbmFtZSA9IGdpdF9jb25maWdfcmVuYW1lKGssIHYpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaywgInN0YXR1cy5yZW5hbWVzIikpIHsKCQlzLT5kZXRlY3RfcmVuYW1lID0gZ2l0X2NvbmZpZ19yZW5hbWUoaywgdik7CgkJcmV0dXJuIDA7Cgl9CglyZXR1cm4gZ2l0X2RpZmZfdWlfY29uZmlnKGssIHYsIE5VTEwpOwp9CgppbnQgY21kX3N0YXR1cyhpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RhdGljIGludCBub19yZW5hbWVzID0gLTE7CglzdGF0aWMgY29uc3QgY2hhciAqcmVuYW1lX3Njb3JlX2FyZyA9IChjb25zdCBjaGFyICopLTE7CglzdGF0aWMgc3RydWN0IHd0X3N0YXR1cyBzOwoJdW5zaWduZWQgaW50IHByb2dyZXNzX2ZsYWcgPSAwOwoJaW50IGZkOwoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CglzdGF0aWMgc3RydWN0IG9wdGlvbiBidWlsdGluX3N0YXR1c19vcHRpb25zW10gPSB7CgkJT1BUX19WRVJCT1NFKCZ2ZXJib3NlLCBOXygiYmUgdmVyYm9zZSIpKSwKCQlPUFRfU0VUX0lOVCgncycsICJzaG9ydCIsICZzdGF0dXNfZm9ybWF0LAoJCQkgICAgTl8oInNob3cgc3RhdHVzIGNvbmNpc2VseSIpLCBTVEFUVVNfRk9STUFUX1NIT1JUKSwKCQlPUFRfQk9PTCgnYicsICJicmFuY2giLCAmcy5zaG93X2JyYW5jaCwKCQkJIE5fKCJzaG93IGJyYW5jaCBpbmZvcm1hdGlvbiIpKSwKCQlPUFRfQk9PTCgwLCAic2hvdy1zdGFzaCIsICZzLnNob3dfc3Rhc2gsCgkJCSBOXygic2hvdyBzdGFzaCBpbmZvcm1hdGlvbiIpKSwKCQlPUFRfQk9PTCgwLCAiYWhlYWQtYmVoaW5kIiwgJnMuYWhlYWRfYmVoaW5kX2ZsYWdzLAoJCQkgTl8oImNvbXB1dGUgZnVsbCBhaGVhZC9iZWhpbmQgdmFsdWVzIikpLAoJCXsgT1BUSU9OX0NBTExCQUNLLCAwLCAicG9yY2VsYWluIiwgJnN0YXR1c19mb3JtYXQsCgkJICBOXygidmVyc2lvbiIpLCBOXygibWFjaGluZS1yZWFkYWJsZSBvdXRwdXQiKSwKCQkgIFBBUlNFX09QVF9PUFRBUkcsIG9wdF9wYXJzZV9wb3JjZWxhaW4gfSwKCQlPUFRfU0VUX0lOVCgwLCAibG9uZyIsICZzdGF0dXNfZm9ybWF0LAoJCQkgICAgTl8oInNob3cgc3RhdHVzIGluIGxvbmcgZm9ybWF0IChkZWZhdWx0KSIpLAoJCQkgICAgU1RBVFVTX0ZPUk1BVF9MT05HKSwKCQlPUFRfQk9PTCgneicsICJudWxsIiwgJnMubnVsbF90ZXJtaW5hdGlvbiwKCQkJIE5fKCJ0ZXJtaW5hdGUgZW50cmllcyB3aXRoIE5VTCIpKSwKCQl7IE9QVElPTl9TVFJJTkcsICd1JywgInVudHJhY2tlZC1maWxlcyIsICZ1bnRyYWNrZWRfZmlsZXNfYXJnLAoJCSAgTl8oIm1vZGUiKSwKCQkgIE5fKCJzaG93IHVudHJhY2tlZCBmaWxlcywgb3B0aW9uYWwgbW9kZXM6IGFsbCwgbm9ybWFsLCBuby4gKERlZmF1bHQ6IGFsbCkiKSwKCQkgIFBBUlNFX09QVF9PUFRBUkcsIE5VTEwsIChpbnRwdHJfdCkiYWxsIiB9LAoJCXsgT1BUSU9OX1NUUklORywgMCwgImlnbm9yZWQiLCAmaWdub3JlZF9hcmcsCgkJICBOXygibW9kZSIpLAoJCSAgTl8oInNob3cgaWdub3JlZCBmaWxlcywgb3B0aW9uYWwgbW9kZXM6IHRyYWRpdGlvbmFsLCBtYXRjaGluZywgbm8uIChEZWZhdWx0OiB0cmFkaXRpb25hbCkiKSwKCQkgIFBBUlNFX09QVF9PUFRBUkcsIE5VTEwsIChpbnRwdHJfdCkidHJhZGl0aW9uYWwiIH0sCgkJeyBPUFRJT05fU1RSSU5HLCAwLCAiaWdub3JlLXN1Ym1vZHVsZXMiLCAmaWdub3JlX3N1Ym1vZHVsZV9hcmcsIE5fKCJ3aGVuIiksCgkJICBOXygiaWdub3JlIGNoYW5nZXMgdG8gc3VibW9kdWxlcywgb3B0aW9uYWwgd2hlbjogYWxsLCBkaXJ0eSwgdW50cmFja2VkLiAoRGVmYXVsdDogYWxsKSIpLAoJCSAgUEFSU0VfT1BUX09QVEFSRywgTlVMTCwgKGludHB0cl90KSJhbGwiIH0sCgkJT1BUX0NPTFVNTigwLCAiY29sdW1uIiwgJnMuY29sb3B0cywgTl8oImxpc3QgdW50cmFja2VkIGZpbGVzIGluIGNvbHVtbnMiKSksCgkJT1BUX0JPT0woMCwgIm5vLXJlbmFtZXMiLCAmbm9fcmVuYW1lcywgTl8oImRvIG5vdCBkZXRlY3QgcmVuYW1lcyIpKSwKCQl7IE9QVElPTl9DQUxMQkFDSywgJ00nLCAiZmluZC1yZW5hbWVzIiwgJnJlbmFtZV9zY29yZV9hcmcsCgkJICBOXygibiIpLCBOXygiZGV0ZWN0IHJlbmFtZXMsIG9wdGlvbmFsbHkgc2V0IHNpbWlsYXJpdHkgaW5kZXgiKSwKCQkgIFBBUlNFX09QVF9PUFRBUkcgfCBQQVJTRV9PUFRfTk9ORUcsIG9wdF9wYXJzZV9yZW5hbWVfc2NvcmUgfSwKCQlPUFRfRU5EKCksCgl9OwoKCWlmIChhcmdjID09IDIgJiYgIXN0cmNtcChhcmd2WzFdLCAiLWgiKSkKCQl1c2FnZV93aXRoX29wdGlvbnMoYnVpbHRpbl9zdGF0dXNfdXNhZ2UsIGJ1aWx0aW5fc3RhdHVzX29wdGlvbnMpOwoKCXN0YXR1c19pbml0X2NvbmZpZygmcywgZ2l0X3N0YXR1c19jb25maWcpOwoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LAoJCQkgICAgIGJ1aWx0aW5fc3RhdHVzX29wdGlvbnMsCgkJCSAgICAgYnVpbHRpbl9zdGF0dXNfdXNhZ2UsIDApOwoJZmluYWxpemVfY29sb3B0cygmcy5jb2xvcHRzLCAtMSk7CglmaW5hbGl6ZV9kZWZlcnJlZF9jb25maWcoJnMpOwoKCWhhbmRsZV91bnRyYWNrZWRfZmlsZXNfYXJnKCZzKTsKCWhhbmRsZV9pZ25vcmVkX2FyZygmcyk7CgoJaWYgKHMuc2hvd19pZ25vcmVkX21vZGUgPT0gU0hPV19NQVRDSElOR19JR05PUkVEICYmCgkgICAgcy5zaG93X3VudHJhY2tlZF9maWxlcyA9PSBTSE9XX05PX1VOVFJBQ0tFRF9GSUxFUykKCQlkaWUoXygiVW5zdXBwb3J0ZWQgY29tYmluYXRpb24gb2YgaWdub3JlZCBhbmQgdW50cmFja2VkLWZpbGVzIGFyZ3VtZW50cyIpKTsKCglwYXJzZV9wYXRoc3BlYygmcy5wYXRoc3BlYywgMCwKCQkgICAgICAgUEFUSFNQRUNfUFJFRkVSX0ZVTEwsCgkJICAgICAgIHByZWZpeCwgYXJndik7CgoJaWYgKHN0YXR1c19mb3JtYXQgIT0gU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU4gJiYKCSAgICBzdGF0dXNfZm9ybWF0ICE9IFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOX1YyKQoJCXByb2dyZXNzX2ZsYWcgPSBSRUZSRVNIX1BST0dSRVNTOwoJcmVhZF9pbmRleCgmdGhlX2luZGV4KTsKCXJlZnJlc2hfaW5kZXgoJnRoZV9pbmRleCwKCQkgICAgICBSRUZSRVNIX1FVSUVUfFJFRlJFU0hfVU5NRVJHRUR8cHJvZ3Jlc3NfZmxhZywKCQkgICAgICAmcy5wYXRoc3BlYywgTlVMTCwgTlVMTCk7CgoJaWYgKHVzZV9vcHRpb25hbF9sb2NrcygpKQoJCWZkID0gaG9sZF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2ssIDApOwoJZWxzZQoJCWZkID0gLTE7CgoJcy5pc19pbml0aWFsID0gZ2V0X29pZChzLnJlZmVyZW5jZSwgJm9pZCkgPyAxIDogMDsKCWlmICghcy5pc19pbml0aWFsKQoJCWhhc2hjcHkocy5zaGExX2NvbW1pdCwgb2lkLmhhc2gpOwoKCXMuaWdub3JlX3N1Ym1vZHVsZV9hcmcgPSBpZ25vcmVfc3VibW9kdWxlX2FyZzsKCXMuc3RhdHVzX2Zvcm1hdCA9IHN0YXR1c19mb3JtYXQ7CglzLnZlcmJvc2UgPSB2ZXJib3NlOwoJaWYgKG5vX3JlbmFtZXMgIT0gLTEpCgkJcy5kZXRlY3RfcmVuYW1lID0gIW5vX3JlbmFtZXM7CglpZiAoKGludHB0cl90KXJlbmFtZV9zY29yZV9hcmcgIT0gLTEpIHsKCQlpZiAocy5kZXRlY3RfcmVuYW1lIDwgRElGRl9ERVRFQ1RfUkVOQU1FKQoJCQlzLmRldGVjdF9yZW5hbWUgPSBESUZGX0RFVEVDVF9SRU5BTUU7CgkJaWYgKHJlbmFtZV9zY29yZV9hcmcpCgkJCXMucmVuYW1lX3Njb3JlID0gcGFyc2VfcmVuYW1lX3Njb3JlKCZyZW5hbWVfc2NvcmVfYXJnKTsKCX0KCgl3dF9zdGF0dXNfY29sbGVjdCgmcyk7CgoJaWYgKDAgPD0gZmQpCgkJdXBkYXRlX2luZGV4X2lmX2FibGUoJnRoZV9pbmRleCwgJmluZGV4X2xvY2spOwoKCWlmIChzLnJlbGF0aXZlX3BhdGhzKQoJCXMucHJlZml4ID0gcHJlZml4OwoKCXd0X3N0YXR1c19wcmludCgmcyk7Cgl3dF9zdGF0dXNfY29sbGVjdF9mcmVlX2J1ZmZlcnMoJnMpOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdpdF9jb21taXRfY29uZmlnKGNvbnN0IGNoYXIgKmssIGNvbnN0IGNoYXIgKnYsIHZvaWQgKmNiKQp7CglzdHJ1Y3Qgd3Rfc3RhdHVzICpzID0gY2I7CglpbnQgc3RhdHVzOwoKCWlmICghc3RyY21wKGssICJjb21taXQudGVtcGxhdGUiKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19wYXRobmFtZSgmdGVtcGxhdGVfZmlsZSwgaywgdik7CglpZiAoIXN0cmNtcChrLCAiY29tbWl0LnN0YXR1cyIpKSB7CgkJaW5jbHVkZV9zdGF0dXMgPSBnaXRfY29uZmlnX2Jvb2woaywgdik7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAiY29tbWl0LmNsZWFudXAiKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJmNsZWFudXBfYXJnLCBrLCB2KTsKCWlmICghc3RyY21wKGssICJjb21taXQuZ3Bnc2lnbiIpKSB7CgkJc2lnbl9jb21taXQgPSBnaXRfY29uZmlnX2Jvb2woaywgdikgPyAiIiA6IE5VTEw7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAiY29tbWl0LnZlcmJvc2UiKSkgewoJCWludCBpc19ib29sOwoJCWNvbmZpZ19jb21taXRfdmVyYm9zZSA9IGdpdF9jb25maWdfYm9vbF9vcl9pbnQoaywgdiwgJmlzX2Jvb2wpOwoJCXJldHVybiAwOwoJfQoKCXN0YXR1cyA9IGdpdF9ncGdfY29uZmlnKGssIHYsIE5VTEwpOwoJaWYgKHN0YXR1cykKCQlyZXR1cm4gc3RhdHVzOwoJcmV0dXJuIGdpdF9zdGF0dXNfY29uZmlnKGssIHYsIHMpOwp9CgppbnQgcnVuX2NvbW1pdF9ob29rKGludCBlZGl0b3JfaXNfdXNlZCwgY29uc3QgY2hhciAqaW5kZXhfZmlsZSwgY29uc3QgY2hhciAqbmFtZSwgLi4uKQp7CglzdHJ1Y3QgYXJndl9hcnJheSBob29rX2VudiA9IEFSR1ZfQVJSQVlfSU5JVDsKCXZhX2xpc3QgYXJnczsKCWludCByZXQ7CgoJYXJndl9hcnJheV9wdXNoZigmaG9va19lbnYsICJHSVRfSU5ERVhfRklMRT0lcyIsIGluZGV4X2ZpbGUpOwoKCS8qCgkgKiBMZXQgdGhlIGhvb2sga25vdyB0aGF0IG5vIGVkaXRvciB3aWxsIGJlIGxhdW5jaGVkLgoJICovCglpZiAoIWVkaXRvcl9pc191c2VkKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmaG9va19lbnYsICJHSVRfRURJVE9SPToiKTsKCgl2YV9zdGFydChhcmdzLCBuYW1lKTsKCXJldCA9IHJ1bl9ob29rX3ZlKGhvb2tfZW52LmFyZ3YsbmFtZSwgYXJncyk7Cgl2YV9lbmQoYXJncyk7Cglhcmd2X2FycmF5X2NsZWFyKCZob29rX2Vudik7CgoJcmV0dXJuIHJldDsKfQoKaW50IGNtZF9jb21taXQoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCWNvbnN0IGNoYXIgKmFyZ3ZfZ2NfYXV0b1tdID0geyJnYyIsICItLWF1dG8iLCBOVUxMfTsKCXN0YXRpYyBzdHJ1Y3Qgd3Rfc3RhdHVzIHM7CglzdGF0aWMgc3RydWN0IG9wdGlvbiBidWlsdGluX2NvbW1pdF9vcHRpb25zW10gPSB7CgkJT1BUX19RVUlFVCgmcXVpZXQsIE5fKCJzdXBwcmVzcyBzdW1tYXJ5IGFmdGVyIHN1Y2Nlc3NmdWwgY29tbWl0IikpLAoJCU9QVF9fVkVSQk9TRSgmdmVyYm9zZSwgTl8oInNob3cgZGlmZiBpbiBjb21taXQgbWVzc2FnZSB0ZW1wbGF0ZSIpKSwKCgkJT1BUX0dST1VQKE5fKCJDb21taXQgbWVzc2FnZSBvcHRpb25zIikpLAoJCU9QVF9GSUxFTkFNRSgnRicsICJmaWxlIiwgJmxvZ2ZpbGUsIE5fKCJyZWFkIG1lc3NhZ2UgZnJvbSBmaWxlIikpLAoJCU9QVF9TVFJJTkcoMCwgImF1dGhvciIsICZmb3JjZV9hdXRob3IsIE5fKCJhdXRob3IiKSwgTl8oIm92ZXJyaWRlIGF1dGhvciBmb3IgY29tbWl0IikpLAoJCU9QVF9TVFJJTkcoMCwgImRhdGUiLCAmZm9yY2VfZGF0ZSwgTl8oImRhdGUiKSwgTl8oIm92ZXJyaWRlIGRhdGUgZm9yIGNvbW1pdCIpKSwKCQlPUFRfQ0FMTEJBQ0soJ20nLCAibWVzc2FnZSIsICZtZXNzYWdlLCBOXygibWVzc2FnZSIpLCBOXygiY29tbWl0IG1lc3NhZ2UiKSwgb3B0X3BhcnNlX20pLAoJCU9QVF9TVFJJTkcoJ2MnLCAicmVlZGl0LW1lc3NhZ2UiLCAmZWRpdF9tZXNzYWdlLCBOXygiY29tbWl0IiksIE5fKCJyZXVzZSBhbmQgZWRpdCBtZXNzYWdlIGZyb20gc3BlY2lmaWVkIGNvbW1pdCIpKSwKCQlPUFRfU1RSSU5HKCdDJywgInJldXNlLW1lc3NhZ2UiLCAmdXNlX21lc3NhZ2UsIE5fKCJjb21taXQiKSwgTl8oInJldXNlIG1lc3NhZ2UgZnJvbSBzcGVjaWZpZWQgY29tbWl0IikpLAoJCU9QVF9TVFJJTkcoMCwgImZpeHVwIiwgJmZpeHVwX21lc3NhZ2UsIE5fKCJjb21taXQiKSwgTl8oInVzZSBhdXRvc3F1YXNoIGZvcm1hdHRlZCBtZXNzYWdlIHRvIGZpeHVwIHNwZWNpZmllZCBjb21taXQiKSksCgkJT1BUX1NUUklORygwLCAic3F1YXNoIiwgJnNxdWFzaF9tZXNzYWdlLCBOXygiY29tbWl0IiksIE5fKCJ1c2UgYXV0b3NxdWFzaCBmb3JtYXR0ZWQgbWVzc2FnZSB0byBzcXVhc2ggc3BlY2lmaWVkIGNvbW1pdCIpKSwKCQlPUFRfQk9PTCgwLCAicmVzZXQtYXV0aG9yIiwgJnJlbmV3X2F1dGhvcnNoaXAsIE5fKCJ0aGUgY29tbWl0IGlzIGF1dGhvcmVkIGJ5IG1lIG5vdyAodXNlZCB3aXRoIC1DLy1jLy0tYW1lbmQpIikpLAoJCU9QVF9CT09MKCdzJywgInNpZ25vZmYiLCAmc2lnbm9mZiwgTl8oImFkZCBTaWduZWQtb2ZmLWJ5OiIpKSwKCQlPUFRfRklMRU5BTUUoJ3QnLCAidGVtcGxhdGUiLCAmdGVtcGxhdGVfZmlsZSwgTl8oInVzZSBzcGVjaWZpZWQgdGVtcGxhdGUgZmlsZSIpKSwKCQlPUFRfQk9PTCgnZScsICJlZGl0IiwgJmVkaXRfZmxhZywgTl8oImZvcmNlIGVkaXQgb2YgY29tbWl0IikpLAoJCU9QVF9TVFJJTkcoMCwgImNsZWFudXAiLCAmY2xlYW51cF9hcmcsIE5fKCJkZWZhdWx0IiksIE5fKCJob3cgdG8gc3RyaXAgc3BhY2VzIGFuZCAjY29tbWVudHMgZnJvbSBtZXNzYWdlIikpLAoJCU9QVF9CT09MKDAsICJzdGF0dXMiLCAmaW5jbHVkZV9zdGF0dXMsIE5fKCJpbmNsdWRlIHN0YXR1cyBpbiBjb21taXQgbWVzc2FnZSB0ZW1wbGF0ZSIpKSwKCQl7IE9QVElPTl9TVFJJTkcsICdTJywgImdwZy1zaWduIiwgJnNpZ25fY29tbWl0LCBOXygia2V5LWlkIiksCgkJICBOXygiR1BHIHNpZ24gY29tbWl0IiksIFBBUlNFX09QVF9PUFRBUkcsIE5VTEwsIChpbnRwdHJfdCkgIiIgfSwKCQkvKiBlbmQgY29tbWl0IG1lc3NhZ2Ugb3B0aW9ucyAqLwoKCQlPUFRfR1JPVVAoTl8oIkNvbW1pdCBjb250ZW50cyBvcHRpb25zIikpLAoJCU9QVF9CT09MKCdhJywgImFsbCIsICZhbGwsIE5fKCJjb21taXQgYWxsIGNoYW5nZWQgZmlsZXMiKSksCgkJT1BUX0JPT0woJ2knLCAiaW5jbHVkZSIsICZhbHNvLCBOXygiYWRkIHNwZWNpZmllZCBmaWxlcyB0byBpbmRleCBmb3IgY29tbWl0IikpLAoJCU9QVF9CT09MKDAsICJpbnRlcmFjdGl2ZSIsICZpbnRlcmFjdGl2ZSwgTl8oImludGVyYWN0aXZlbHkgYWRkIGZpbGVzIikpLAoJCU9QVF9CT09MKCdwJywgInBhdGNoIiwgJnBhdGNoX2ludGVyYWN0aXZlLCBOXygiaW50ZXJhY3RpdmVseSBhZGQgY2hhbmdlcyIpKSwKCQlPUFRfQk9PTCgnbycsICJvbmx5IiwgJm9ubHksIE5fKCJjb21taXQgb25seSBzcGVjaWZpZWQgZmlsZXMiKSksCgkJT1BUX0JPT0woJ24nLCAibm8tdmVyaWZ5IiwgJm5vX3ZlcmlmeSwgTl8oImJ5cGFzcyBwcmUtY29tbWl0IGFuZCBjb21taXQtbXNnIGhvb2tzIikpLAoJCU9QVF9CT09MKDAsICJkcnktcnVuIiwgJmRyeV9ydW4sIE5fKCJzaG93IHdoYXQgd291bGQgYmUgY29tbWl0dGVkIikpLAoJCU9QVF9TRVRfSU5UKDAsICJzaG9ydCIsICZzdGF0dXNfZm9ybWF0LCBOXygic2hvdyBzdGF0dXMgY29uY2lzZWx5IiksCgkJCSAgICBTVEFUVVNfRk9STUFUX1NIT1JUKSwKCQlPUFRfQk9PTCgwLCAiYnJhbmNoIiwgJnMuc2hvd19icmFuY2gsIE5fKCJzaG93IGJyYW5jaCBpbmZvcm1hdGlvbiIpKSwKCQlPUFRfQk9PTCgwLCAiYWhlYWQtYmVoaW5kIiwgJnMuYWhlYWRfYmVoaW5kX2ZsYWdzLAoJCQkgTl8oImNvbXB1dGUgZnVsbCBhaGVhZC9iZWhpbmQgdmFsdWVzIikpLAoJCU9QVF9TRVRfSU5UKDAsICJwb3JjZWxhaW4iLCAmc3RhdHVzX2Zvcm1hdCwKCQkJICAgIE5fKCJtYWNoaW5lLXJlYWRhYmxlIG91dHB1dCIpLCBTVEFUVVNfRk9STUFUX1BPUkNFTEFJTiksCgkJT1BUX1NFVF9JTlQoMCwgImxvbmciLCAmc3RhdHVzX2Zvcm1hdCwKCQkJICAgIE5fKCJzaG93IHN0YXR1cyBpbiBsb25nIGZvcm1hdCAoZGVmYXVsdCkiKSwKCQkJICAgIFNUQVRVU19GT1JNQVRfTE9ORyksCgkJT1BUX0JPT0woJ3onLCAibnVsbCIsICZzLm51bGxfdGVybWluYXRpb24sCgkJCSBOXygidGVybWluYXRlIGVudHJpZXMgd2l0aCBOVUwiKSksCgkJT1BUX0JPT0woMCwgImFtZW5kIiwgJmFtZW5kLCBOXygiYW1lbmQgcHJldmlvdXMgY29tbWl0IikpLAoJCU9QVF9CT09MKDAsICJuby1wb3N0LXJld3JpdGUiLCAmbm9fcG9zdF9yZXdyaXRlLCBOXygiYnlwYXNzIHBvc3QtcmV3cml0ZSBob29rIikpLAoJCXsgT1BUSU9OX1NUUklORywgJ3UnLCAidW50cmFja2VkLWZpbGVzIiwgJnVudHJhY2tlZF9maWxlc19hcmcsIE5fKCJtb2RlIiksIE5fKCJzaG93IHVudHJhY2tlZCBmaWxlcywgb3B0aW9uYWwgbW9kZXM6IGFsbCwgbm9ybWFsLCBuby4gKERlZmF1bHQ6IGFsbCkiKSwgUEFSU0VfT1BUX09QVEFSRywgTlVMTCwgKGludHB0cl90KSJhbGwiIH0sCgkJLyogZW5kIGNvbW1pdCBjb250ZW50cyBvcHRpb25zICovCgoJCU9QVF9ISURERU5fQk9PTCgwLCAiYWxsb3ctZW1wdHkiLCAmYWxsb3dfZW1wdHksCgkJCQlOXygib2sgdG8gcmVjb3JkIGFuIGVtcHR5IGNoYW5nZSIpKSwKCQlPUFRfSElEREVOX0JPT0woMCwgImFsbG93LWVtcHR5LW1lc3NhZ2UiLCAmYWxsb3dfZW1wdHlfbWVzc2FnZSwKCQkJCU5fKCJvayB0byByZWNvcmQgYSBjaGFuZ2Ugd2l0aCBhbiBlbXB0eSBtZXNzYWdlIikpLAoKCQlPUFRfRU5EKCkKCX07CgoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBhdXRob3JfaWRlbnQgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKmluZGV4X2ZpbGUsICpyZWZsb2dfbXNnOwoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMgPSBOVUxMOwoJc3RydWN0IHN0YXQgc3RhdGJ1ZjsKCXN0cnVjdCBjb21taXQgKmN1cnJlbnRfaGVhZCA9IE5VTEw7CglzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqZXh0cmEgPSBOVUxMOwoJc3RydWN0IHN0cmJ1ZiBlcnIgPSBTVFJCVUZfSU5JVDsKCglpZiAoYXJnYyA9PSAyICYmICFzdHJjbXAoYXJndlsxXSwgIi1oIikpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGJ1aWx0aW5fY29tbWl0X3VzYWdlLCBidWlsdGluX2NvbW1pdF9vcHRpb25zKTsKCglzdGF0dXNfaW5pdF9jb25maWcoJnMsIGdpdF9jb21taXRfY29uZmlnKTsKCXMuY29tbWl0X3RlbXBsYXRlID0gMTsKCXN0YXR1c19mb3JtYXQgPSBTVEFUVVNfRk9STUFUX05PTkU7IC8qIElnbm9yZSBzdGF0dXMuc2hvcnQgKi8KCXMuY29sb3B0cyA9IDA7CgoJaWYgKGdldF9vaWQoIkhFQUQiLCAmb2lkKSkKCQljdXJyZW50X2hlYWQgPSBOVUxMOwoJZWxzZSB7CgkJY3VycmVudF9oZWFkID0gbG9va3VwX2NvbW1pdF9vcl9kaWUoJm9pZCwgIkhFQUQiKTsKCQlpZiAocGFyc2VfY29tbWl0KGN1cnJlbnRfaGVhZCkpCgkJCWRpZShfKCJjb3VsZCBub3QgcGFyc2UgSEVBRCBjb21taXQiKSk7Cgl9Cgl2ZXJib3NlID0gLTE7IC8qIHVuc3BlY2lmaWVkICovCglhcmdjID0gcGFyc2VfYW5kX3ZhbGlkYXRlX29wdGlvbnMoYXJnYywgYXJndiwgYnVpbHRpbl9jb21taXRfb3B0aW9ucywKCQkJCQkgIGJ1aWx0aW5fY29tbWl0X3VzYWdlLAoJCQkJCSAgcHJlZml4LCBjdXJyZW50X2hlYWQsICZzKTsKCWlmICh2ZXJib3NlID09IC0xKQoJCXZlcmJvc2UgPSAoY29uZmlnX2NvbW1pdF92ZXJib3NlIDwgMCkgPyAwIDogY29uZmlnX2NvbW1pdF92ZXJib3NlOwoKCWlmIChkcnlfcnVuKQoJCXJldHVybiBkcnlfcnVuX2NvbW1pdChhcmdjLCBhcmd2LCBwcmVmaXgsIGN1cnJlbnRfaGVhZCwgJnMpOwoJaW5kZXhfZmlsZSA9IHByZXBhcmVfaW5kZXgoYXJnYywgYXJndiwgcHJlZml4LCBjdXJyZW50X2hlYWQsIDApOwoKCS8qIFNldCB1cCBldmVyeXRoaW5nIGZvciB3cml0aW5nIHRoZSBjb21taXQgb2JqZWN0LiAgVGhpcyBpbmNsdWRlcwoJICAgcnVubmluZyBob29rcywgd3JpdGluZyB0aGUgdHJlZXMsIGFuZCBpbnRlcmFjdGluZyB3aXRoIHRoZSB1c2VyLiAgKi8KCWlmICghcHJlcGFyZV90b19jb21taXQoaW5kZXhfZmlsZSwgcHJlZml4LAoJCQkgICAgICAgY3VycmVudF9oZWFkLCAmcywgJmF1dGhvcl9pZGVudCkpIHsKCQlyb2xsYmFja19pbmRleF9maWxlcygpOwoJCXJldHVybiAxOwoJfQoKCS8qIERldGVybWluZSBwYXJlbnRzICovCglyZWZsb2dfbXNnID0gZ2V0ZW52KCJHSVRfUkVGTE9HX0FDVElPTiIpOwoJaWYgKCFjdXJyZW50X2hlYWQpIHsKCQlpZiAoIXJlZmxvZ19tc2cpCgkJCXJlZmxvZ19tc2cgPSAiY29tbWl0IChpbml0aWFsKSI7Cgl9IGVsc2UgaWYgKGFtZW5kKSB7CgkJaWYgKCFyZWZsb2dfbXNnKQoJCQlyZWZsb2dfbXNnID0gImNvbW1pdCAoYW1lbmQpIjsKCQlwYXJlbnRzID0gY29weV9jb21taXRfbGlzdChjdXJyZW50X2hlYWQtPnBhcmVudHMpOwoJfSBlbHNlIGlmICh3aGVuY2UgPT0gRlJPTV9NRVJHRSkgewoJCXN0cnVjdCBzdHJidWYgbSA9IFNUUkJVRl9JTklUOwoJCUZJTEUgKmZwOwoJCWludCBhbGxvd19mYXN0X2ZvcndhcmQgPSAxOwoJCXN0cnVjdCBjb21taXRfbGlzdCAqKnBwdHIgPSAmcGFyZW50czsKCgkJaWYgKCFyZWZsb2dfbXNnKQoJCQlyZWZsb2dfbXNnID0gImNvbW1pdCAobWVyZ2UpIjsKCQlwcHRyID0gY29tbWl0X2xpc3RfYXBwZW5kKGN1cnJlbnRfaGVhZCwgcHB0cik7CgkJZnAgPSB4Zm9wZW4oZ2l0X3BhdGhfbWVyZ2VfaGVhZCh0aGVfcmVwb3NpdG9yeSksICJyIik7CgkJd2hpbGUgKHN0cmJ1Zl9nZXRsaW5lX2xmKCZtLCBmcCkgIT0gRU9GKSB7CgkJCXN0cnVjdCBjb21taXQgKnBhcmVudDsKCgkJCXBhcmVudCA9IGdldF9tZXJnZV9wYXJlbnQobS5idWYpOwoJCQlpZiAoIXBhcmVudCkKCQkJCWRpZShfKCJDb3JydXB0IE1FUkdFX0hFQUQgZmlsZSAoJXMpIiksIG0uYnVmKTsKCQkJcHB0ciA9IGNvbW1pdF9saXN0X2FwcGVuZChwYXJlbnQsIHBwdHIpOwoJCX0KCQlmY2xvc2UoZnApOwoJCXN0cmJ1Zl9yZWxlYXNlKCZtKTsKCQlpZiAoIXN0YXQoZ2l0X3BhdGhfbWVyZ2VfbW9kZSh0aGVfcmVwb3NpdG9yeSksICZzdGF0YnVmKSkgewoJCQlpZiAoc3RyYnVmX3JlYWRfZmlsZSgmc2IsIGdpdF9wYXRoX21lcmdlX21vZGUodGhlX3JlcG9zaXRvcnkpLCAwKSA8IDApCgkJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlYWQgTUVSR0VfTU9ERSIpKTsKCQkJaWYgKCFzdHJjbXAoc2IuYnVmLCAibm8tZmYiKSkKCQkJCWFsbG93X2Zhc3RfZm9yd2FyZCA9IDA7CgkJfQoJCWlmIChhbGxvd19mYXN0X2ZvcndhcmQpCgkJCXJlZHVjZV9oZWFkc19yZXBsYWNlKCZwYXJlbnRzKTsKCX0gZWxzZSB7CgkJaWYgKCFyZWZsb2dfbXNnKQoJCQlyZWZsb2dfbXNnID0gKHdoZW5jZSA9PSBGUk9NX0NIRVJSWV9QSUNLKQoJCQkJCT8gImNvbW1pdCAoY2hlcnJ5LXBpY2spIgoJCQkJCTogImNvbW1pdCI7CgkJY29tbWl0X2xpc3RfaW5zZXJ0KGN1cnJlbnRfaGVhZCwgJnBhcmVudHMpOwoJfQoKCS8qIEZpbmFsbHksIGdldCB0aGUgY29tbWl0IG1lc3NhZ2UgKi8KCXN0cmJ1Zl9yZXNldCgmc2IpOwoJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJnNiLCBnaXRfcGF0aF9jb21taXRfZWRpdG1zZygpLCAwKSA8IDApIHsKCQlpbnQgc2F2ZWRfZXJybm8gPSBlcnJubzsKCQlyb2xsYmFja19pbmRleF9maWxlcygpOwoJCWRpZShfKCJjb3VsZCBub3QgcmVhZCBjb21taXQgbWVzc2FnZTogJXMiKSwgc3RyZXJyb3Ioc2F2ZWRfZXJybm8pKTsKCX0KCglpZiAodmVyYm9zZSB8fCAvKiBUcnVuY2F0ZSB0aGUgbWVzc2FnZSBqdXN0IGJlZm9yZSB0aGUgZGlmZiwgaWYgYW55LiAqLwoJICAgIGNsZWFudXBfbW9kZSA9PSBDT01NSVRfTVNHX0NMRUFOVVBfU0NJU1NPUlMpCgkJc3RyYnVmX3NldGxlbigmc2IsIHd0X3N0YXR1c19sb2NhdGVfZW5kKHNiLmJ1Ziwgc2IubGVuKSk7CglpZiAoY2xlYW51cF9tb2RlICE9IENPTU1JVF9NU0dfQ0xFQU5VUF9OT05FKQoJCXN0cmJ1Zl9zdHJpcHNwYWNlKCZzYiwgY2xlYW51cF9tb2RlID09IENPTU1JVF9NU0dfQ0xFQU5VUF9BTEwpOwoKCWlmIChtZXNzYWdlX2lzX2VtcHR5KCZzYiwgY2xlYW51cF9tb2RlKSAmJiAhYWxsb3dfZW1wdHlfbWVzc2FnZSkgewoJCXJvbGxiYWNrX2luZGV4X2ZpbGVzKCk7CgkJZnByaW50ZihzdGRlcnIsIF8oIkFib3J0aW5nIGNvbW1pdCBkdWUgdG8gZW1wdHkgY29tbWl0IG1lc3NhZ2UuXG4iKSk7CgkJZXhpdCgxKTsKCX0KCWlmICh0ZW1wbGF0ZV91bnRvdWNoZWQoJnNiLCB0ZW1wbGF0ZV9maWxlLCBjbGVhbnVwX21vZGUpICYmICFhbGxvd19lbXB0eV9tZXNzYWdlKSB7CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlmcHJpbnRmKHN0ZGVyciwgXygiQWJvcnRpbmcgY29tbWl0OyB5b3UgZGlkIG5vdCBlZGl0IHRoZSBtZXNzYWdlLlxuIikpOwoJCWV4aXQoMSk7Cgl9CgoJaWYgKGFtZW5kKSB7CgkJY29uc3QgY2hhciAqZXhjbHVkZV9ncGdzaWdbMl0gPSB7ICJncGdzaWciLCBOVUxMIH07CgkJZXh0cmEgPSByZWFkX2NvbW1pdF9leHRyYV9oZWFkZXJzKGN1cnJlbnRfaGVhZCwgZXhjbHVkZV9ncGdzaWcpOwoJfSBlbHNlIHsKCQlzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqKnRhaWwgPSAmZXh0cmE7CgkJYXBwZW5kX21lcmdlX3RhZ19oZWFkZXJzKHBhcmVudHMsICZ0YWlsKTsKCX0KCglpZiAoY29tbWl0X3RyZWVfZXh0ZW5kZWQoc2IuYnVmLCBzYi5sZW4sICZhY3RpdmVfY2FjaGVfdHJlZS0+b2lkLAoJCQkJIHBhcmVudHMsICZvaWQsIGF1dGhvcl9pZGVudC5idWYsIHNpZ25fY29tbWl0LAoJCQkJIGV4dHJhKSkgewoJCXJvbGxiYWNrX2luZGV4X2ZpbGVzKCk7CgkJZGllKF8oImZhaWxlZCB0byB3cml0ZSBjb21taXQgb2JqZWN0IikpOwoJfQoJc3RyYnVmX3JlbGVhc2UoJmF1dGhvcl9pZGVudCk7CglmcmVlX2NvbW1pdF9leHRyYV9oZWFkZXJzKGV4dHJhKTsKCglpZiAodXBkYXRlX2hlYWRfd2l0aF9yZWZsb2coY3VycmVudF9oZWFkLCAmb2lkLCByZWZsb2dfbXNnLCAmc2IsCgkJCQkgICAgJmVycikpIHsKCQlyb2xsYmFja19pbmRleF9maWxlcygpOwoJCWRpZSgiJXMiLCBlcnIuYnVmKTsKCX0KCgl1bmxpbmsoZ2l0X3BhdGhfY2hlcnJ5X3BpY2tfaGVhZCh0aGVfcmVwb3NpdG9yeSkpOwoJdW5saW5rKGdpdF9wYXRoX3JldmVydF9oZWFkKHRoZV9yZXBvc2l0b3J5KSk7Cgl1bmxpbmsoZ2l0X3BhdGhfbWVyZ2VfaGVhZCh0aGVfcmVwb3NpdG9yeSkpOwoJdW5saW5rKGdpdF9wYXRoX21lcmdlX21zZyh0aGVfcmVwb3NpdG9yeSkpOwoJdW5saW5rKGdpdF9wYXRoX21lcmdlX21vZGUodGhlX3JlcG9zaXRvcnkpKTsKCXVubGluayhnaXRfcGF0aF9zcXVhc2hfbXNnKHRoZV9yZXBvc2l0b3J5KSk7CgoJaWYgKGNvbW1pdF9pbmRleF9maWxlcygpKQoJCWRpZShfKCJyZXBvc2l0b3J5IGhhcyBiZWVuIHVwZGF0ZWQsIGJ1dCB1bmFibGUgdG8gd3JpdGVcbiIKCQkgICAgICAibmV3X2luZGV4IGZpbGUuIENoZWNrIHRoYXQgZGlzayBpcyBub3QgZnVsbCBhbmQgcXVvdGEgaXNcbiIKCQkgICAgICAibm90IGV4Y2VlZGVkLCBhbmQgdGhlbiBcImdpdCByZXNldCBIRUFEXCIgdG8gcmVjb3Zlci4iKSk7CgoJaWYgKGdpdF9lbnZfYm9vbChHSVRfVEVTVF9DT01NSVRfR1JBUEgsIDApKQoJCXdyaXRlX2NvbW1pdF9ncmFwaF9yZWFjaGFibGUoZ2V0X29iamVjdF9kaXJlY3RvcnkoKSwgMCwgMCk7CgoJcmVwb19yZXJlcmUodGhlX3JlcG9zaXRvcnksIDApOwoJcnVuX2NvbW1hbmRfdl9vcHQoYXJndl9nY19hdXRvLCBSVU5fR0lUX0NNRCk7CglydW5fY29tbWl0X2hvb2sodXNlX2VkaXRvciwgZ2V0X2luZGV4X2ZpbGUoKSwgInBvc3QtY29tbWl0IiwgTlVMTCk7CglpZiAoYW1lbmQgJiYgIW5vX3Bvc3RfcmV3cml0ZSkgewoJCWNvbW1pdF9wb3N0X3Jld3JpdGUoY3VycmVudF9oZWFkLCAmb2lkKTsKCX0KCWlmICghcXVpZXQpIHsKCQl1bnNpZ25lZCBpbnQgZmxhZ3MgPSAwOwoKCQlpZiAoIWN1cnJlbnRfaGVhZCkKCQkJZmxhZ3MgfD0gU1VNTUFSWV9JTklUSUFMX0NPTU1JVDsKCQlpZiAoYXV0aG9yX2RhdGVfaXNfaW50ZXJlc3RpbmcoKSkKCQkJZmxhZ3MgfD0gU1VNTUFSWV9TSE9XX0FVVEhPUl9EQVRFOwoJCXByaW50X2NvbW1pdF9zdW1tYXJ5KHRoZV9yZXBvc2l0b3J5LCBwcmVmaXgsCgkJCQkgICAgICZvaWQsIGZsYWdzKTsKCX0KCglVTkxFQUsoZXJyKTsKCVVOTEVBSyhzYik7CglyZXR1cm4gMDsKfQo=",
    "text": "/*\n * Builtin \"git commit\"\n *\n * Copyright (c) 2007 Kristian H\u00f8gsberg <krh@redhat.com>\n * Based on git-commit.sh by Junio C Hamano and Linus Torvalds\n */\n\n#include \"cache.h\"\n#include \"config.h\"\n#include \"lockfile.h\"\n#include \"cache-tree.h\"\n#include \"color.h\"\n#include \"dir.h\"\n#include \"builtin.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"commit.h\"\n#include \"revision.h\"\n#include \"wt-status.h\"\n#include \"run-command.h\"\n#include \"refs.h\"\n#include \"log-tree.h\"\n#include \"strbuf.h\"\n#include \"utf8.h\"\n#include \"parse-options.h\"\n#include \"string-list.h\"\n#include \"rerere.h\"\n#include \"unpack-trees.h\"\n#include \"quote.h\"\n#include \"submodule.h\"\n#include \"gpg-interface.h\"\n#include \"column.h\"\n#include \"sequencer.h\"\n#include \"mailmap.h\"\n#include \"help.h\"\n#include \"commit-reach.h\"\n#include \"commit-graph.h\"\n\nstatic const char * const builtin_commit_usage[] = {\n\tN_(\"git commit [<options>] [--] <pathspec>...\"),\n\tNULL\n};\n\nstatic const char * const builtin_status_usage[] = {\n\tN_(\"git status [<options>] [--] <pathspec>...\"),\n\tNULL\n};\n\nstatic const char empty_amend_advice[] =\nN_(\"You asked to amend the most recent commit, but doing so would make\\n\"\n\"it empty. You can repeat your command with --allow-empty, or you can\\n\"\n\"remove the commit entirely with \\\"git reset HEAD^\\\".\\n\");\n\nstatic const char empty_cherry_pick_advice[] =\nN_(\"The previous cherry-pick is now empty, possibly due to conflict resolution.\\n\"\n\"If you wish to commit it anyway, use:\\n\"\n\"\\n\"\n\"    git commit --allow-empty\\n\"\n\"\\n\");\n\nstatic const char empty_cherry_pick_advice_single[] =\nN_(\"Otherwise, please use 'git reset'\\n\");\n\nstatic const char empty_cherry_pick_advice_multi[] =\nN_(\"If you wish to skip this commit, use:\\n\"\n\"\\n\"\n\"    git reset\\n\"\n\"\\n\"\n\"Then \\\"git cherry-pick --continue\\\" will resume cherry-picking\\n\"\n\"the remaining commits.\\n\");\n\nstatic const char *color_status_slots[] = {\n\t[WT_STATUS_HEADER]\t  = \"header\",\n\t[WT_STATUS_UPDATED]\t  = \"updated\",\n\t[WT_STATUS_CHANGED]\t  = \"changed\",\n\t[WT_STATUS_UNTRACKED]\t  = \"untracked\",\n\t[WT_STATUS_NOBRANCH]\t  = \"noBranch\",\n\t[WT_STATUS_UNMERGED]\t  = \"unmerged\",\n\t[WT_STATUS_LOCAL_BRANCH]  = \"localBranch\",\n\t[WT_STATUS_REMOTE_BRANCH] = \"remoteBranch\",\n\t[WT_STATUS_ONBRANCH]\t  = \"branch\",\n};\n\nstatic const char *use_message_buffer;\nstatic struct lock_file index_lock; /* real index */\nstatic struct lock_file false_lock; /* used only for partial commits */\nstatic enum {\n\tCOMMIT_AS_IS = 1,\n\tCOMMIT_NORMAL,\n\tCOMMIT_PARTIAL\n} commit_style;\n\nstatic const char *logfile, *force_author;\nstatic const char *template_file;\n/*\n * The _message variables are commit names from which to take\n * the commit message and/or authorship.\n */\nstatic const char *author_message, *author_message_buffer;\nstatic char *edit_message, *use_message;\nstatic char *fixup_message, *squash_message;\nstatic int all, also, interactive, patch_interactive, only, amend, signoff;\nstatic int edit_flag = -1; /* unspecified */\nstatic int quiet, verbose, no_verify, allow_empty, dry_run, renew_authorship;\nstatic int config_commit_verbose = -1; /* unspecified */\nstatic int no_post_rewrite, allow_empty_message;\nstatic char *untracked_files_arg, *force_date, *ignore_submodule_arg, *ignored_arg;\nstatic char *sign_commit;\n\n/*\n * The default commit message cleanup mode will remove the lines\n * beginning with # (shell comments) and leading and trailing\n * whitespaces (empty lines or containing only whitespaces)\n * if editor is used, and only the whitespaces if the message\n * is specified explicitly.\n */\nstatic enum commit_msg_cleanup_mode cleanup_mode;\nstatic const char *cleanup_arg;\n\nstatic enum commit_whence whence;\nstatic int sequencer_in_use;\nstatic int use_editor = 1, include_status = 1;\nstatic int have_option_m;\nstatic struct strbuf message = STRBUF_INIT;\n\nstatic enum wt_status_format status_format = STATUS_FORMAT_UNSPECIFIED;\n\nstatic int opt_parse_porcelain(const struct option *opt, const char *arg, int unset)\n{\n\tenum wt_status_format *value = (enum wt_status_format *)opt->value;\n\tif (unset)\n\t\t*value = STATUS_FORMAT_NONE;\n\telse if (!arg)\n\t\t*value = STATUS_FORMAT_PORCELAIN;\n\telse if (!strcmp(arg, \"v1\") || !strcmp(arg, \"1\"))\n\t\t*value = STATUS_FORMAT_PORCELAIN;\n\telse if (!strcmp(arg, \"v2\") || !strcmp(arg, \"2\"))\n\t\t*value = STATUS_FORMAT_PORCELAIN_V2;\n\telse\n\t\tdie(\"unsupported porcelain version '%s'\", arg);\n\n\treturn 0;\n}\n\nstatic int opt_parse_m(const struct option *opt, const char *arg, int unset)\n{\n\tstruct strbuf *buf = opt->value;\n\tif (unset) {\n\t\thave_option_m = 0;\n\t\tstrbuf_setlen(buf, 0);\n\t} else {\n\t\thave_option_m = 1;\n\t\tif (buf->len)\n\t\t\tstrbuf_addch(buf, '\\n');\n\t\tstrbuf_addstr(buf, arg);\n\t\tstrbuf_complete_line(buf);\n\t}\n\treturn 0;\n}\n\nstatic int opt_parse_rename_score(const struct option *opt, const char *arg, int unset)\n{\n\tconst char **value = opt->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tif (arg != NULL && *arg == '=')\n\t\targ = arg + 1;\n\n\t*value = arg;\n\treturn 0;\n}\n\nstatic void determine_whence(struct wt_status *s)\n{\n\tif (file_exists(git_path_merge_head(the_repository)))\n\t\twhence = FROM_MERGE;\n\telse if (file_exists(git_path_cherry_pick_head(the_repository))) {\n\t\twhence = FROM_CHERRY_PICK;\n\t\tif (file_exists(git_path_seq_dir()))\n\t\t\tsequencer_in_use = 1;\n\t}\n\telse\n\t\twhence = FROM_COMMIT;\n\tif (s)\n\t\ts->whence = whence;\n}\n\nstatic void status_init_config(struct wt_status *s, config_fn_t fn)\n{\n\twt_status_prepare(the_repository, s);\n\tinit_diff_ui_defaults();\n\tgit_config(fn, s);\n\tdetermine_whence(s);\n\ts->hints = advice_status_hints; /* must come after git_config() */\n}\n\nstatic void rollback_index_files(void)\n{\n\tswitch (commit_style) {\n\tcase COMMIT_AS_IS:\n\t\tbreak; /* nothing to do */\n\tcase COMMIT_NORMAL:\n\t\trollback_lock_file(&index_lock);\n\t\tbreak;\n\tcase COMMIT_PARTIAL:\n\t\trollback_lock_file(&index_lock);\n\t\trollback_lock_file(&false_lock);\n\t\tbreak;\n\t}\n}\n\nstatic int commit_index_files(void)\n{\n\tint err = 0;\n\n\tswitch (commit_style) {\n\tcase COMMIT_AS_IS:\n\t\tbreak; /* nothing to do */\n\tcase COMMIT_NORMAL:\n\t\terr = commit_lock_file(&index_lock);\n\t\tbreak;\n\tcase COMMIT_PARTIAL:\n\t\terr = commit_lock_file(&index_lock);\n\t\trollback_lock_file(&false_lock);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/*\n * Take a union of paths in the index and the named tree (typically, \"HEAD\"),\n * and return the paths that match the given pattern in list.\n */\nstatic int list_paths(struct string_list *list, const char *with_tree,\n\t\t      const char *prefix, const struct pathspec *pattern)\n{\n\tint i, ret;\n\tchar *m;\n\n\tif (!pattern->nr)\n\t\treturn 0;\n\n\tm = xcalloc(1, pattern->nr);\n\n\tif (with_tree) {\n\t\tchar *max_prefix = common_prefix(pattern);\n\t\toverlay_tree_on_index(&the_index, with_tree, max_prefix);\n\t\tfree(max_prefix);\n\t}\n\n\tfor (i = 0; i < active_nr; i++) {\n\t\tconst struct cache_entry *ce = active_cache[i];\n\t\tstruct string_list_item *item;\n\n\t\tif (ce->ce_flags & CE_UPDATE)\n\t\t\tcontinue;\n\t\tif (!ce_path_match(&the_index, ce, pattern, m))\n\t\t\tcontinue;\n\t\titem = string_list_insert(list, ce->name);\n\t\tif (ce_skip_worktree(ce))\n\t\t\titem->util = item; /* better a valid pointer than a fake one */\n\t}\n\n\tret = report_path_error(m, pattern, prefix);\n\tfree(m);\n\treturn ret;\n}\n\nstatic void add_remove_files(struct string_list *list)\n{\n\tint i;\n\tfor (i = 0; i < list->nr; i++) {\n\t\tstruct stat st;\n\t\tstruct string_list_item *p = &(list->items[i]);\n\n\t\t/* p->util is skip-worktree */\n\t\tif (p->util)\n\t\t\tcontinue;\n\n\t\tif (!lstat(p->string, &st)) {\n\t\t\tif (add_to_cache(p->string, &st, 0))\n\t\t\t\tdie(_(\"updating files failed\"));\n\t\t} else\n\t\t\tremove_file_from_cache(p->string);\n\t}\n}\n\nstatic void create_base_index(const struct commit *current_head)\n{\n\tstruct tree *tree;\n\tstruct unpack_trees_options opts;\n\tstruct tree_desc t;\n\n\tif (!current_head) {\n\t\tdiscard_cache();\n\t\treturn;\n\t}\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.head_idx = 1;\n\topts.index_only = 1;\n\topts.merge = 1;\n\topts.src_index = &the_index;\n\topts.dst_index = &the_index;\n\n\topts.fn = oneway_merge;\n\ttree = parse_tree_indirect(&current_head->object.oid);\n\tif (!tree)\n\t\tdie(_(\"failed to unpack HEAD tree object\"));\n\tparse_tree(tree);\n\tinit_tree_desc(&t, tree->buffer, tree->size);\n\tif (unpack_trees(1, &t, &opts))\n\t\texit(128); /* We've already reported the error, finish dying */\n}\n\nstatic void refresh_cache_or_die(int refresh_flags)\n{\n\t/*\n\t * refresh_flags contains REFRESH_QUIET, so the only errors\n\t * are for unmerged entries.\n\t */\n\tif (refresh_cache(refresh_flags | REFRESH_IN_PORCELAIN))\n\t\tdie_resolve_conflict(\"commit\");\n}\n\nstatic const char *prepare_index(int argc, const char **argv, const char *prefix,\n\t\t\t\t const struct commit *current_head, int is_status)\n{\n\tstruct string_list partial = STRING_LIST_INIT_DUP;\n\tstruct pathspec pathspec;\n\tint refresh_flags = REFRESH_QUIET;\n\tconst char *ret;\n\n\tif (is_status)\n\t\trefresh_flags |= REFRESH_UNMERGED;\n\tparse_pathspec(&pathspec, 0,\n\t\t       PATHSPEC_PREFER_FULL,\n\t\t       prefix, argv);\n\n\tif (read_cache_preload(&pathspec) < 0)\n\t\tdie(_(\"index file corrupt\"));\n\n\tif (interactive) {\n\t\tchar *old_index_env = NULL;\n\t\thold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);\n\n\t\trefresh_cache_or_die(refresh_flags);\n\n\t\tif (write_locked_index(&the_index, &index_lock, 0))\n\t\t\tdie(_(\"unable to create temporary index\"));\n\n\t\told_index_env = getenv(INDEX_ENVIRONMENT);\n\t\tsetenv(INDEX_ENVIRONMENT, get_lock_file_path(&index_lock), 1);\n\n\t\tif (interactive_add(argc, argv, prefix, patch_interactive) != 0)\n\t\t\tdie(_(\"interactive add failed\"));\n\n\t\tif (old_index_env && *old_index_env)\n\t\t\tsetenv(INDEX_ENVIRONMENT, old_index_env, 1);\n\t\telse\n\t\t\tunsetenv(INDEX_ENVIRONMENT);\n\n\t\tdiscard_cache();\n\t\tread_cache_from(get_lock_file_path(&index_lock));\n\t\tif (update_main_cache_tree(WRITE_TREE_SILENT) == 0) {\n\t\t\tif (reopen_lock_file(&index_lock) < 0)\n\t\t\t\tdie(_(\"unable to write index file\"));\n\t\t\tif (write_locked_index(&the_index, &index_lock, 0))\n\t\t\t\tdie(_(\"unable to update temporary index\"));\n\t\t} else\n\t\t\twarning(_(\"Failed to update main cache tree\"));\n\n\t\tcommit_style = COMMIT_NORMAL;\n\t\tret = get_lock_file_path(&index_lock);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Non partial, non as-is commit.\n\t *\n\t * (1) get the real index;\n\t * (2) update the_index as necessary;\n\t * (3) write the_index out to the real index (still locked);\n\t * (4) return the name of the locked index file.\n\t *\n\t * The caller should run hooks on the locked real index, and\n\t * (A) if all goes well, commit the real index;\n\t * (B) on failure, rollback the real index.\n\t */\n\tif (all || (also && pathspec.nr)) {\n\t\thold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);\n\t\tadd_files_to_cache(also ? prefix : NULL, &pathspec, 0);\n\t\trefresh_cache_or_die(refresh_flags);\n\t\tupdate_main_cache_tree(WRITE_TREE_SILENT);\n\t\tif (write_locked_index(&the_index, &index_lock, 0))\n\t\t\tdie(_(\"unable to write new_index file\"));\n\t\tcommit_style = COMMIT_NORMAL;\n\t\tret = get_lock_file_path(&index_lock);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * As-is commit.\n\t *\n\t * (1) return the name of the real index file.\n\t *\n\t * The caller should run hooks on the real index,\n\t * and create commit from the_index.\n\t * We still need to refresh the index here.\n\t */\n\tif (!only && !pathspec.nr) {\n\t\thold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);\n\t\trefresh_cache_or_die(refresh_flags);\n\t\tif (active_cache_changed\n\t\t    || !cache_tree_fully_valid(active_cache_tree))\n\t\t\tupdate_main_cache_tree(WRITE_TREE_SILENT);\n\t\tif (write_locked_index(&the_index, &index_lock,\n\t\t\t\t       COMMIT_LOCK | SKIP_IF_UNCHANGED))\n\t\t\tdie(_(\"unable to write new_index file\"));\n\t\tcommit_style = COMMIT_AS_IS;\n\t\tret = get_index_file();\n\t\tgoto out;\n\t}\n\n\t/*\n\t * A partial commit.\n\t *\n\t * (0) find the set of affected paths;\n\t * (1) get lock on the real index file;\n\t * (2) update the_index with the given paths;\n\t * (3) write the_index out to the real index (still locked);\n\t * (4) get lock on the false index file;\n\t * (5) reset the_index from HEAD;\n\t * (6) update the_index the same way as (2);\n\t * (7) write the_index out to the false index file;\n\t * (8) return the name of the false index file (still locked);\n\t *\n\t * The caller should run hooks on the locked false index, and\n\t * create commit from it.  Then\n\t * (A) if all goes well, commit the real index;\n\t * (B) on failure, rollback the real index;\n\t * In either case, rollback the false index.\n\t */\n\tcommit_style = COMMIT_PARTIAL;\n\n\tif (whence != FROM_COMMIT) {\n\t\tif (whence == FROM_MERGE)\n\t\t\tdie(_(\"cannot do a partial commit during a merge.\"));\n\t\telse if (whence == FROM_CHERRY_PICK)\n\t\t\tdie(_(\"cannot do a partial commit during a cherry-pick.\"));\n\t}\n\n\tif (list_paths(&partial, !current_head ? NULL : \"HEAD\", prefix, &pathspec))\n\t\texit(1);\n\n\tdiscard_cache();\n\tif (read_cache() < 0)\n\t\tdie(_(\"cannot read the index\"));\n\n\thold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);\n\tadd_remove_files(&partial);\n\trefresh_cache(REFRESH_QUIET);\n\tupdate_main_cache_tree(WRITE_TREE_SILENT);\n\tif (write_locked_index(&the_index, &index_lock, 0))\n\t\tdie(_(\"unable to write new_index file\"));\n\n\thold_lock_file_for_update(&false_lock,\n\t\t\t\t  git_path(\"next-index-%\"PRIuMAX,\n\t\t\t\t\t   (uintmax_t) getpid()),\n\t\t\t\t  LOCK_DIE_ON_ERROR);\n\n\tcreate_base_index(current_head);\n\tadd_remove_files(&partial);\n\trefresh_cache(REFRESH_QUIET);\n\n\tif (write_locked_index(&the_index, &false_lock, 0))\n\t\tdie(_(\"unable to write temporary index file\"));\n\n\tdiscard_cache();\n\tret = get_lock_file_path(&false_lock);\n\tread_cache_from(ret);\nout:\n\tstring_list_clear(&partial, 0);\n\tclear_pathspec(&pathspec);\n\treturn ret;\n}\n\nstatic int run_status(FILE *fp, const char *index_file, const char *prefix, int nowarn,\n\t\t      struct wt_status *s)\n{\n\tstruct object_id oid;\n\n\tif (s->relative_paths)\n\t\ts->prefix = prefix;\n\n\tif (amend) {\n\t\ts->amend = 1;\n\t\ts->reference = \"HEAD^1\";\n\t}\n\ts->verbose = verbose;\n\ts->index_file = index_file;\n\ts->fp = fp;\n\ts->nowarn = nowarn;\n\ts->is_initial = get_oid(s->reference, &oid) ? 1 : 0;\n\tif (!s->is_initial)\n\t\thashcpy(s->sha1_commit, oid.hash);\n\ts->status_format = status_format;\n\ts->ignore_submodule_arg = ignore_submodule_arg;\n\n\twt_status_collect(s);\n\twt_status_print(s);\n\twt_status_collect_free_buffers(s);\n\n\treturn s->committable;\n}\n\nstatic int is_a_merge(const struct commit *current_head)\n{\n\treturn !!(current_head->parents && current_head->parents->next);\n}\n\nstatic void assert_split_ident(struct ident_split *id, const struct strbuf *buf)\n{\n\tif (split_ident_line(id, buf->buf, buf->len) || !id->date_begin)\n\t\tBUG(\"unable to parse our own ident: %s\", buf->buf);\n}\n\nstatic void export_one(const char *var, const char *s, const char *e, int hack)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tif (hack)\n\t\tstrbuf_addch(&buf, hack);\n\tstrbuf_addf(&buf, \"%.*s\", (int)(e - s), s);\n\tsetenv(var, buf.buf, 1);\n\tstrbuf_release(&buf);\n}\n\nstatic int parse_force_date(const char *in, struct strbuf *out)\n{\n\tstrbuf_addch(out, '@');\n\n\tif (parse_date(in, out) < 0) {\n\t\tint errors = 0;\n\t\tunsigned long t = approxidate_careful(in, &errors);\n\t\tif (errors)\n\t\t\treturn -1;\n\t\tstrbuf_addf(out, \"%lu\", t);\n\t}\n\n\treturn 0;\n}\n\nstatic void set_ident_var(char **buf, char *val)\n{\n\tfree(*buf);\n\t*buf = val;\n}\n\nstatic void determine_author_info(struct strbuf *author_ident)\n{\n\tchar *name, *email, *date;\n\tstruct ident_split author;\n\n\tname = xstrdup_or_null(getenv(\"GIT_AUTHOR_NAME\"));\n\temail = xstrdup_or_null(getenv(\"GIT_AUTHOR_EMAIL\"));\n\tdate = xstrdup_or_null(getenv(\"GIT_AUTHOR_DATE\"));\n\n\tif (author_message) {\n\t\tstruct ident_split ident;\n\t\tsize_t len;\n\t\tconst char *a;\n\n\t\ta = find_commit_header(author_message_buffer, \"author\", &len);\n\t\tif (!a)\n\t\t\tdie(_(\"commit '%s' lacks author header\"), author_message);\n\t\tif (split_ident_line(&ident, a, len) < 0)\n\t\t\tdie(_(\"commit '%s' has malformed author line\"), author_message);\n\n\t\tset_ident_var(&name, xmemdupz(ident.name_begin, ident.name_end - ident.name_begin));\n\t\tset_ident_var(&email, xmemdupz(ident.mail_begin, ident.mail_end - ident.mail_begin));\n\n\t\tif (ident.date_begin) {\n\t\t\tstruct strbuf date_buf = STRBUF_INIT;\n\t\t\tstrbuf_addch(&date_buf, '@');\n\t\t\tstrbuf_add(&date_buf, ident.date_begin, ident.date_end - ident.date_begin);\n\t\t\tstrbuf_addch(&date_buf, ' ');\n\t\t\tstrbuf_add(&date_buf, ident.tz_begin, ident.tz_end - ident.tz_begin);\n\t\t\tset_ident_var(&date, strbuf_detach(&date_buf, NULL));\n\t\t}\n\t}\n\n\tif (force_author) {\n\t\tstruct ident_split ident;\n\n\t\tif (split_ident_line(&ident, force_author, strlen(force_author)) < 0)\n\t\t\tdie(_(\"malformed --author parameter\"));\n\t\tset_ident_var(&name, xmemdupz(ident.name_begin, ident.name_end - ident.name_begin));\n\t\tset_ident_var(&email, xmemdupz(ident.mail_begin, ident.mail_end - ident.mail_begin));\n\t}\n\n\tif (force_date) {\n\t\tstruct strbuf date_buf = STRBUF_INIT;\n\t\tif (parse_force_date(force_date, &date_buf))\n\t\t\tdie(_(\"invalid date format: %s\"), force_date);\n\t\tset_ident_var(&date, strbuf_detach(&date_buf, NULL));\n\t}\n\n\tstrbuf_addstr(author_ident, fmt_ident(name, email, date, IDENT_STRICT));\n\tassert_split_ident(&author, author_ident);\n\texport_one(\"GIT_AUTHOR_NAME\", author.name_begin, author.name_end, 0);\n\texport_one(\"GIT_AUTHOR_EMAIL\", author.mail_begin, author.mail_end, 0);\n\texport_one(\"GIT_AUTHOR_DATE\", author.date_begin, author.tz_end, '@');\n\tfree(name);\n\tfree(email);\n\tfree(date);\n}\n\nstatic int author_date_is_interesting(void)\n{\n\treturn author_message || force_date;\n}\n\nstatic void adjust_comment_line_char(const struct strbuf *sb)\n{\n\tchar candidates[] = \"#;@!$%^&|:\";\n\tchar *candidate;\n\tconst char *p;\n\n\tcomment_line_char = candidates[0];\n\tif (!memchr(sb->buf, comment_line_char, sb->len))\n\t\treturn;\n\n\tp = sb->buf;\n\tcandidate = strchr(candidates, *p);\n\tif (candidate)\n\t\t*candidate = ' ';\n\tfor (p = sb->buf; *p; p++) {\n\t\tif ((p[0] == '\\n' || p[0] == '\\r') && p[1]) {\n\t\t\tcandidate = strchr(candidates, p[1]);\n\t\t\tif (candidate)\n\t\t\t\t*candidate = ' ';\n\t\t}\n\t}\n\n\tfor (p = candidates; *p == ' '; p++)\n\t\t;\n\tif (!*p)\n\t\tdie(_(\"unable to select a comment character that is not used\\n\"\n\t\t      \"in the current commit message\"));\n\tcomment_line_char = *p;\n}\n\nstatic int prepare_to_commit(const char *index_file, const char *prefix,\n\t\t\t     struct commit *current_head,\n\t\t\t     struct wt_status *s,\n\t\t\t     struct strbuf *author_ident)\n{\n\tstruct stat statbuf;\n\tstruct strbuf committer_ident = STRBUF_INIT;\n\tint committable;\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *hook_arg1 = NULL;\n\tconst char *hook_arg2 = NULL;\n\tint clean_message_contents = (cleanup_mode != COMMIT_MSG_CLEANUP_NONE);\n\tint old_display_comment_prefix;\n\n\t/* This checks and barfs if author is badly specified */\n\tdetermine_author_info(author_ident);\n\n\tif (!no_verify && run_commit_hook(use_editor, index_file, \"pre-commit\", NULL))\n\t\treturn 0;\n\n\tif (squash_message) {\n\t\t/*\n\t\t * Insert the proper subject line before other commit\n\t\t * message options add their content.\n\t\t */\n\t\tif (use_message && !strcmp(use_message, squash_message))\n\t\t\tstrbuf_addstr(&sb, \"squash! \");\n\t\telse {\n\t\t\tstruct pretty_print_context ctx = {0};\n\t\t\tstruct commit *c;\n\t\t\tc = lookup_commit_reference_by_name(squash_message);\n\t\t\tif (!c)\n\t\t\t\tdie(_(\"could not lookup commit %s\"), squash_message);\n\t\t\tctx.output_encoding = get_commit_output_encoding();\n\t\t\tformat_commit_message(c, \"squash! %s\\n\\n\", &sb,\n\t\t\t\t\t      &ctx);\n\t\t}\n\t}\n\n\tif (have_option_m && !fixup_message) {\n\t\tstrbuf_addbuf(&sb, &message);\n\t\thook_arg1 = \"message\";\n\t} else if (logfile && !strcmp(logfile, \"-\")) {\n\t\tif (isatty(0))\n\t\t\tfprintf(stderr, _(\"(reading log message from standard input)\\n\"));\n\t\tif (strbuf_read(&sb, 0, 0) < 0)\n\t\t\tdie_errno(_(\"could not read log from standard input\"));\n\t\thook_arg1 = \"message\";\n\t} else if (logfile) {\n\t\tif (strbuf_read_file(&sb, logfile, 0) < 0)\n\t\t\tdie_errno(_(\"could not read log file '%s'\"),\n\t\t\t\t  logfile);\n\t\thook_arg1 = \"message\";\n\t} else if (use_message) {\n\t\tchar *buffer;\n\t\tbuffer = strstr(use_message_buffer, \"\\n\\n\");\n\t\tif (buffer)\n\t\t\tstrbuf_addstr(&sb, skip_blank_lines(buffer + 2));\n\t\thook_arg1 = \"commit\";\n\t\thook_arg2 = use_message;\n\t} else if (fixup_message) {\n\t\tstruct pretty_print_context ctx = {0};\n\t\tstruct commit *commit;\n\t\tcommit = lookup_commit_reference_by_name(fixup_message);\n\t\tif (!commit)\n\t\t\tdie(_(\"could not lookup commit %s\"), fixup_message);\n\t\tctx.output_encoding = get_commit_output_encoding();\n\t\tformat_commit_message(commit, \"fixup! %s\\n\\n\",\n\t\t\t\t      &sb, &ctx);\n\t\tif (have_option_m)\n\t\t\tstrbuf_addbuf(&sb, &message);\n\t\thook_arg1 = \"message\";\n\t} else if (!stat(git_path_merge_msg(the_repository), &statbuf)) {\n\t\t/*\n\t\t * prepend SQUASH_MSG here if it exists and a\n\t\t * \"merge --squash\" was originally performed\n\t\t */\n\t\tif (!stat(git_path_squash_msg(the_repository), &statbuf)) {\n\t\t\tif (strbuf_read_file(&sb, git_path_squash_msg(the_repository), 0) < 0)\n\t\t\t\tdie_errno(_(\"could not read SQUASH_MSG\"));\n\t\t\thook_arg1 = \"squash\";\n\t\t} else\n\t\t\thook_arg1 = \"merge\";\n\t\tif (strbuf_read_file(&sb, git_path_merge_msg(the_repository), 0) < 0)\n\t\t\tdie_errno(_(\"could not read MERGE_MSG\"));\n\t} else if (!stat(git_path_squash_msg(the_repository), &statbuf)) {\n\t\tif (strbuf_read_file(&sb, git_path_squash_msg(the_repository), 0) < 0)\n\t\t\tdie_errno(_(\"could not read SQUASH_MSG\"));\n\t\thook_arg1 = \"squash\";\n\t} else if (template_file) {\n\t\tif (strbuf_read_file(&sb, template_file, 0) < 0)\n\t\t\tdie_errno(_(\"could not read '%s'\"), template_file);\n\t\thook_arg1 = \"template\";\n\t\tclean_message_contents = 0;\n\t}\n\n\t/*\n\t * The remaining cases don't modify the template message, but\n\t * just set the argument(s) to the prepare-commit-msg hook.\n\t */\n\telse if (whence == FROM_MERGE)\n\t\thook_arg1 = \"merge\";\n\telse if (whence == FROM_CHERRY_PICK) {\n\t\thook_arg1 = \"commit\";\n\t\thook_arg2 = \"CHERRY_PICK_HEAD\";\n\t}\n\n\tif (squash_message) {\n\t\t/*\n\t\t * If squash_commit was used for the commit subject,\n\t\t * then we're possibly hijacking other commit log options.\n\t\t * Reset the hook args to tell the real story.\n\t\t */\n\t\thook_arg1 = \"message\";\n\t\thook_arg2 = \"\";\n\t}\n\n\ts->fp = fopen_for_writing(git_path_commit_editmsg());\n\tif (s->fp == NULL)\n\t\tdie_errno(_(\"could not open '%s'\"), git_path_commit_editmsg());\n\n\t/* Ignore status.displayCommentPrefix: we do need comments in COMMIT_EDITMSG. */\n\told_display_comment_prefix = s->display_comment_prefix;\n\ts->display_comment_prefix = 1;\n\n\t/*\n\t * Most hints are counter-productive when the commit has\n\t * already started.\n\t */\n\ts->hints = 0;\n\n\tif (clean_message_contents)\n\t\tstrbuf_stripspace(&sb, 0);\n\n\tif (signoff)\n\t\tappend_signoff(&sb, ignore_non_trailer(sb.buf, sb.len), 0);\n\n\tif (fwrite(sb.buf, 1, sb.len, s->fp) < sb.len)\n\t\tdie_errno(_(\"could not write commit template\"));\n\n\tif (auto_comment_line_char)\n\t\tadjust_comment_line_char(&sb);\n\tstrbuf_release(&sb);\n\n\t/* This checks if committer ident is explicitly given */\n\tstrbuf_addstr(&committer_ident, git_committer_info(IDENT_STRICT));\n\tif (use_editor && include_status) {\n\t\tint ident_shown = 0;\n\t\tint saved_color_setting;\n\t\tstruct ident_split ci, ai;\n\n\t\tif (whence != FROM_COMMIT) {\n\t\t\tif (cleanup_mode == COMMIT_MSG_CLEANUP_SCISSORS)\n\t\t\t\twt_status_add_cut_line(s->fp);\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t    whence == FROM_MERGE\n\t\t\t\t? _(\"\\n\"\n\t\t\t\t\t\"It looks like you may be committing a merge.\\n\"\n\t\t\t\t\t\"If this is not correct, please remove the file\\n\"\n\t\t\t\t\t\"\t%s\\n\"\n\t\t\t\t\t\"and try again.\\n\")\n\t\t\t\t: _(\"\\n\"\n\t\t\t\t\t\"It looks like you may be committing a cherry-pick.\\n\"\n\t\t\t\t\t\"If this is not correct, please remove the file\\n\"\n\t\t\t\t\t\"\t%s\\n\"\n\t\t\t\t\t\"and try again.\\n\"),\n\t\t\t\twhence == FROM_MERGE ?\n\t\t\t\t\tgit_path_merge_head(the_repository) :\n\t\t\t\t\tgit_path_cherry_pick_head(the_repository));\n\t\t}\n\n\t\tfprintf(s->fp, \"\\n\");\n\t\tif (cleanup_mode == COMMIT_MSG_CLEANUP_ALL)\n\t\t\tstatus_printf(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"Please enter the commit message for your changes.\"\n\t\t\t\t  \" Lines starting\\nwith '%c' will be ignored, and an empty\"\n\t\t\t\t  \" message aborts the commit.\\n\"), comment_line_char);\n\t\telse if (cleanup_mode == COMMIT_MSG_CLEANUP_SCISSORS &&\n\t\t\t whence == FROM_COMMIT)\n\t\t\twt_status_add_cut_line(s->fp);\n\t\telse /* COMMIT_MSG_CLEANUP_SPACE, that is. */\n\t\t\tstatus_printf(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"Please enter the commit message for your changes.\"\n\t\t\t\t  \" Lines starting\\n\"\n\t\t\t\t  \"with '%c' will be kept; you may remove them\"\n\t\t\t\t  \" yourself if you want to.\\n\"\n\t\t\t\t  \"An empty message aborts the commit.\\n\"), comment_line_char);\n\n\t\t/*\n\t\t * These should never fail because they come from our own\n\t\t * fmt_ident. They may fail the sane_ident test, but we know\n\t\t * that the name and mail pointers will at least be valid,\n\t\t * which is enough for our tests and printing here.\n\t\t */\n\t\tassert_split_ident(&ai, author_ident);\n\t\tassert_split_ident(&ci, &committer_ident);\n\n\t\tif (ident_cmp(&ai, &ci))\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"%s\"\n\t\t\t\t\"Author:    %.*s <%.*s>\"),\n\t\t\t\tident_shown++ ? \"\" : \"\\n\",\n\t\t\t\t(int)(ai.name_end - ai.name_begin), ai.name_begin,\n\t\t\t\t(int)(ai.mail_end - ai.mail_begin), ai.mail_begin);\n\n\t\tif (author_date_is_interesting())\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"%s\"\n\t\t\t\t\"Date:      %s\"),\n\t\t\t\tident_shown++ ? \"\" : \"\\n\",\n\t\t\t\tshow_ident_date(&ai, DATE_MODE(NORMAL)));\n\n\t\tif (!committer_ident_sufficiently_given())\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"%s\"\n\t\t\t\t\"Committer: %.*s <%.*s>\"),\n\t\t\t\tident_shown++ ? \"\" : \"\\n\",\n\t\t\t\t(int)(ci.name_end - ci.name_begin), ci.name_begin,\n\t\t\t\t(int)(ci.mail_end - ci.mail_begin), ci.mail_begin);\n\n\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL, \"%s\", \"\"); /* Add new line for clarity */\n\n\t\tsaved_color_setting = s->use_color;\n\t\ts->use_color = 0;\n\t\tcommittable = run_status(s->fp, index_file, prefix, 1, s);\n\t\ts->use_color = saved_color_setting;\n\t\tstring_list_clear(&s->change, 1);\n\t} else {\n\t\tstruct object_id oid;\n\t\tconst char *parent = \"HEAD\";\n\n\t\tif (!active_nr && read_cache() < 0)\n\t\t\tdie(_(\"Cannot read index\"));\n\n\t\tif (amend)\n\t\t\tparent = \"HEAD^1\";\n\n\t\tif (get_oid(parent, &oid)) {\n\t\t\tint i, ita_nr = 0;\n\n\t\t\tfor (i = 0; i < active_nr; i++)\n\t\t\t\tif (ce_intent_to_add(active_cache[i]))\n\t\t\t\t\tita_nr++;\n\t\t\tcommittable = active_nr - ita_nr > 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Unless the user did explicitly request a submodule\n\t\t\t * ignore mode by passing a command line option we do\n\t\t\t * not ignore any changed submodule SHA-1s when\n\t\t\t * comparing index and parent, no matter what is\n\t\t\t * configured. Otherwise we won't commit any\n\t\t\t * submodules which were manually staged, which would\n\t\t\t * be really confusing.\n\t\t\t */\n\t\t\tstruct diff_flags flags = DIFF_FLAGS_INIT;\n\t\t\tflags.override_submodule_config = 1;\n\t\t\tif (ignore_submodule_arg &&\n\t\t\t    !strcmp(ignore_submodule_arg, \"all\"))\n\t\t\t\tflags.ignore_submodules = 1;\n\t\t\tcommittable = index_differs_from(the_repository,\n\t\t\t\t\t\t\t parent, &flags, 1);\n\t\t}\n\t}\n\tstrbuf_release(&committer_ident);\n\n\tfclose(s->fp);\n\n\t/*\n\t * Reject an attempt to record a non-merge empty commit without\n\t * explicit --allow-empty. In the cherry-pick case, it may be\n\t * empty due to conflict resolution, which the user should okay.\n\t */\n\tif (!committable && whence != FROM_MERGE && !allow_empty &&\n\t    !(amend && is_a_merge(current_head))) {\n\t\ts->display_comment_prefix = old_display_comment_prefix;\n\t\trun_status(stdout, index_file, prefix, 0, s);\n\t\tif (amend)\n\t\t\tfputs(_(empty_amend_advice), stderr);\n\t\telse if (whence == FROM_CHERRY_PICK) {\n\t\t\tfputs(_(empty_cherry_pick_advice), stderr);\n\t\t\tif (!sequencer_in_use)\n\t\t\t\tfputs(_(empty_cherry_pick_advice_single), stderr);\n\t\t\telse\n\t\t\t\tfputs(_(empty_cherry_pick_advice_multi), stderr);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!no_verify && find_hook(\"pre-commit\")) {\n\t\t/*\n\t\t * Re-read the index as pre-commit hook could have updated it,\n\t\t * and write it out as a tree.  We must do this before we invoke\n\t\t * the editor and after we invoke run_status above.\n\t\t */\n\t\tdiscard_cache();\n\t}\n\tread_cache_from(index_file);\n\n\tif (update_main_cache_tree(0)) {\n\t\terror(_(\"Error building trees\"));\n\t\treturn 0;\n\t}\n\n\tif (run_commit_hook(use_editor, index_file, \"prepare-commit-msg\",\n\t\t\t    git_path_commit_editmsg(), hook_arg1, hook_arg2, NULL))\n\t\treturn 0;\n\n\tif (use_editor) {\n\t\tstruct argv_array env = ARGV_ARRAY_INIT;\n\n\t\targv_array_pushf(&env, \"GIT_INDEX_FILE=%s\", index_file);\n\t\tif (launch_editor(git_path_commit_editmsg(), NULL, env.argv)) {\n\t\t\tfprintf(stderr,\n\t\t\t_(\"Please supply the message using either -m or -F option.\\n\"));\n\t\t\texit(1);\n\t\t}\n\t\targv_array_clear(&env);\n\t}\n\n\tif (!no_verify &&\n\t    run_commit_hook(use_editor, index_file, \"commit-msg\", git_path_commit_editmsg(), NULL)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic const char *find_author_by_nickname(const char *name)\n{\n\tstruct rev_info revs;\n\tstruct commit *commit;\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct string_list mailmap = STRING_LIST_INIT_NODUP;\n\tconst char *av[20];\n\tint ac = 0;\n\n\trepo_init_revisions(the_repository, &revs, NULL);\n\tstrbuf_addf(&buf, \"--author=%s\", name);\n\tav[++ac] = \"--all\";\n\tav[++ac] = \"-i\";\n\tav[++ac] = buf.buf;\n\tav[++ac] = NULL;\n\tsetup_revisions(ac, av, &revs, NULL);\n\trevs.mailmap = &mailmap;\n\tread_mailmap(revs.mailmap, NULL);\n\n\tif (prepare_revision_walk(&revs))\n\t\tdie(_(\"revision walk setup failed\"));\n\tcommit = get_revision(&revs);\n\tif (commit) {\n\t\tstruct pretty_print_context ctx = {0};\n\t\tctx.date_mode.type = DATE_NORMAL;\n\t\tstrbuf_release(&buf);\n\t\tformat_commit_message(commit, \"%aN <%aE>\", &buf, &ctx);\n\t\tclear_mailmap(&mailmap);\n\t\treturn strbuf_detach(&buf, NULL);\n\t}\n\tdie(_(\"--author '%s' is not 'Name <email>' and matches no existing author\"), name);\n}\n\nstatic void handle_ignored_arg(struct wt_status *s)\n{\n\tif (!ignored_arg)\n\t\t; /* default already initialized */\n\telse if (!strcmp(ignored_arg, \"traditional\"))\n\t\ts->show_ignored_mode = SHOW_TRADITIONAL_IGNORED;\n\telse if (!strcmp(ignored_arg, \"no\"))\n\t\ts->show_ignored_mode = SHOW_NO_IGNORED;\n\telse if (!strcmp(ignored_arg, \"matching\"))\n\t\ts->show_ignored_mode = SHOW_MATCHING_IGNORED;\n\telse\n\t\tdie(_(\"Invalid ignored mode '%s'\"), ignored_arg);\n}\n\nstatic void handle_untracked_files_arg(struct wt_status *s)\n{\n\tif (!untracked_files_arg)\n\t\t; /* default already initialized */\n\telse if (!strcmp(untracked_files_arg, \"no\"))\n\t\ts->show_untracked_files = SHOW_NO_UNTRACKED_FILES;\n\telse if (!strcmp(untracked_files_arg, \"normal\"))\n\t\ts->show_untracked_files = SHOW_NORMAL_UNTRACKED_FILES;\n\telse if (!strcmp(untracked_files_arg, \"all\"))\n\t\ts->show_untracked_files = SHOW_ALL_UNTRACKED_FILES;\n\telse\n\t\tdie(_(\"Invalid untracked files mode '%s'\"), untracked_files_arg);\n}\n\nstatic const char *read_commit_message(const char *name)\n{\n\tconst char *out_enc;\n\tstruct commit *commit;\n\n\tcommit = lookup_commit_reference_by_name(name);\n\tif (!commit)\n\t\tdie(_(\"could not lookup commit %s\"), name);\n\tout_enc = get_commit_output_encoding();\n\treturn logmsg_reencode(commit, NULL, out_enc);\n}\n\n/*\n * Enumerate what needs to be propagated when --porcelain\n * is not in effect here.\n */\nstatic struct status_deferred_config {\n\tenum wt_status_format status_format;\n\tint show_branch;\n} status_deferred_config = {\n\tSTATUS_FORMAT_UNSPECIFIED,\n\t-1 /* unspecified */\n};\n\nstatic void finalize_deferred_config(struct wt_status *s)\n{\n\tint use_deferred_config = (status_format != STATUS_FORMAT_PORCELAIN &&\n\t\t\t\t   status_format != STATUS_FORMAT_PORCELAIN_V2 &&\n\t\t\t\t   !s->null_termination);\n\n\tif (s->null_termination) {\n\t\tif (status_format == STATUS_FORMAT_NONE ||\n\t\t    status_format == STATUS_FORMAT_UNSPECIFIED)\n\t\t\tstatus_format = STATUS_FORMAT_PORCELAIN;\n\t\telse if (status_format == STATUS_FORMAT_LONG)\n\t\t\tdie(_(\"--long and -z are incompatible\"));\n\t}\n\n\tif (use_deferred_config && status_format == STATUS_FORMAT_UNSPECIFIED)\n\t\tstatus_format = status_deferred_config.status_format;\n\tif (status_format == STATUS_FORMAT_UNSPECIFIED)\n\t\tstatus_format = STATUS_FORMAT_NONE;\n\n\tif (use_deferred_config && s->show_branch < 0)\n\t\ts->show_branch = status_deferred_config.show_branch;\n\tif (s->show_branch < 0)\n\t\ts->show_branch = 0;\n\n\tif (s->ahead_behind_flags == AHEAD_BEHIND_UNSPECIFIED)\n\t\ts->ahead_behind_flags = AHEAD_BEHIND_FULL;\n}\n\nstatic int parse_and_validate_options(int argc, const char *argv[],\n\t\t\t\t      const struct option *options,\n\t\t\t\t      const char * const usage[],\n\t\t\t\t      const char *prefix,\n\t\t\t\t      struct commit *current_head,\n\t\t\t\t      struct wt_status *s)\n{\n\tint f = 0;\n\n\targc = parse_options(argc, argv, prefix, options, usage, 0);\n\tfinalize_deferred_config(s);\n\n\tif (force_author && !strchr(force_author, '>'))\n\t\tforce_author = find_author_by_nickname(force_author);\n\n\tif (force_author && renew_authorship)\n\t\tdie(_(\"Using both --reset-author and --author does not make sense\"));\n\n\tif (logfile || have_option_m || use_message || fixup_message)\n\t\tuse_editor = 0;\n\tif (0 <= edit_flag)\n\t\tuse_editor = edit_flag;\n\n\t/* Sanity check options */\n\tif (amend && !current_head)\n\t\tdie(_(\"You have nothing to amend.\"));\n\tif (amend && whence != FROM_COMMIT) {\n\t\tif (whence == FROM_MERGE)\n\t\t\tdie(_(\"You are in the middle of a merge -- cannot amend.\"));\n\t\telse if (whence == FROM_CHERRY_PICK)\n\t\t\tdie(_(\"You are in the middle of a cherry-pick -- cannot amend.\"));\n\t}\n\tif (fixup_message && squash_message)\n\t\tdie(_(\"Options --squash and --fixup cannot be used together\"));\n\tif (use_message)\n\t\tf++;\n\tif (edit_message)\n\t\tf++;\n\tif (fixup_message)\n\t\tf++;\n\tif (logfile)\n\t\tf++;\n\tif (f > 1)\n\t\tdie(_(\"Only one of -c/-C/-F/--fixup can be used.\"));\n\tif (have_option_m && (edit_message || use_message || logfile))\n\t\tdie((_(\"Option -m cannot be combined with -c/-C/-F.\")));\n\tif (f || have_option_m)\n\t\ttemplate_file = NULL;\n\tif (edit_message)\n\t\tuse_message = edit_message;\n\tif (amend && !use_message && !fixup_message)\n\t\tuse_message = \"HEAD\";\n\tif (!use_message && whence != FROM_CHERRY_PICK && renew_authorship)\n\t\tdie(_(\"--reset-author can be used only with -C, -c or --amend.\"));\n\tif (use_message) {\n\t\tuse_message_buffer = read_commit_message(use_message);\n\t\tif (!renew_authorship) {\n\t\t\tauthor_message = use_message;\n\t\t\tauthor_message_buffer = use_message_buffer;\n\t\t}\n\t}\n\tif (whence == FROM_CHERRY_PICK && !renew_authorship) {\n\t\tauthor_message = \"CHERRY_PICK_HEAD\";\n\t\tauthor_message_buffer = read_commit_message(author_message);\n\t}\n\n\tif (patch_interactive)\n\t\tinteractive = 1;\n\n\tif (also + only + all + interactive > 1)\n\t\tdie(_(\"Only one of --include/--only/--all/--interactive/--patch can be used.\"));\n\tif (argc == 0 && (also || (only && !amend && !allow_empty)))\n\t\tdie(_(\"No paths with --include/--only does not make sense.\"));\n\tif (!cleanup_arg || !strcmp(cleanup_arg, \"default\"))\n\t\tcleanup_mode = use_editor ? COMMIT_MSG_CLEANUP_ALL :\n\t\t\t\t\t    COMMIT_MSG_CLEANUP_SPACE;\n\telse if (!strcmp(cleanup_arg, \"verbatim\"))\n\t\tcleanup_mode = COMMIT_MSG_CLEANUP_NONE;\n\telse if (!strcmp(cleanup_arg, \"whitespace\"))\n\t\tcleanup_mode = COMMIT_MSG_CLEANUP_SPACE;\n\telse if (!strcmp(cleanup_arg, \"strip\"))\n\t\tcleanup_mode = COMMIT_MSG_CLEANUP_ALL;\n\telse if (!strcmp(cleanup_arg, \"scissors\"))\n\t\tcleanup_mode = use_editor ? COMMIT_MSG_CLEANUP_SCISSORS :\n\t\t\t\t\t    COMMIT_MSG_CLEANUP_SPACE;\n\telse\n\t\tdie(_(\"Invalid cleanup mode %s\"), cleanup_arg);\n\n\thandle_untracked_files_arg(s);\n\n\tif (all && argc > 0)\n\t\tdie(_(\"Paths with -a does not make sense.\"));\n\n\tif (status_format != STATUS_FORMAT_NONE)\n\t\tdry_run = 1;\n\n\treturn argc;\n}\n\nstatic int dry_run_commit(int argc, const char **argv, const char *prefix,\n\t\t\t  const struct commit *current_head, struct wt_status *s)\n{\n\tint committable;\n\tconst char *index_file;\n\n\tindex_file = prepare_index(argc, argv, prefix, current_head, 1);\n\tcommittable = run_status(stdout, index_file, prefix, 0, s);\n\trollback_index_files();\n\n\treturn committable ? 0 : 1;\n}\n\ndefine_list_config_array_extra(color_status_slots, {\"added\"});\n\nstatic int parse_status_slot(const char *slot)\n{\n\tif (!strcasecmp(slot, \"added\"))\n\t\treturn WT_STATUS_UPDATED;\n\n\treturn LOOKUP_CONFIG(color_status_slots, slot);\n}\n\nstatic int git_status_config(const char *k, const char *v, void *cb)\n{\n\tstruct wt_status *s = cb;\n\tconst char *slot_name;\n\n\tif (starts_with(k, \"column.\"))\n\t\treturn git_column_config(k, v, \"status\", &s->colopts);\n\tif (!strcmp(k, \"status.submodulesummary\")) {\n\t\tint is_bool;\n\t\ts->submodule_summary = git_config_bool_or_int(k, v, &is_bool);\n\t\tif (is_bool && s->submodule_summary)\n\t\t\ts->submodule_summary = -1;\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.short\")) {\n\t\tif (git_config_bool(k, v))\n\t\t\tstatus_deferred_config.status_format = STATUS_FORMAT_SHORT;\n\t\telse\n\t\t\tstatus_deferred_config.status_format = STATUS_FORMAT_NONE;\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.branch\")) {\n\t\tstatus_deferred_config.show_branch = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.showstash\")) {\n\t\ts->show_stash = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.color\") || !strcmp(k, \"color.status\")) {\n\t\ts->use_color = git_config_colorbool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.displaycommentprefix\")) {\n\t\ts->display_comment_prefix = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (skip_prefix(k, \"status.color.\", &slot_name) ||\n\t    skip_prefix(k, \"color.status.\", &slot_name)) {\n\t\tint slot = parse_status_slot(slot_name);\n\t\tif (slot < 0)\n\t\t\treturn 0;\n\t\tif (!v)\n\t\t\treturn config_error_nonbool(k);\n\t\treturn color_parse(v, s->color_palette[slot]);\n\t}\n\tif (!strcmp(k, \"status.relativepaths\")) {\n\t\ts->relative_paths = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.showuntrackedfiles\")) {\n\t\tif (!v)\n\t\t\treturn config_error_nonbool(k);\n\t\telse if (!strcmp(v, \"no\"))\n\t\t\ts->show_untracked_files = SHOW_NO_UNTRACKED_FILES;\n\t\telse if (!strcmp(v, \"normal\"))\n\t\t\ts->show_untracked_files = SHOW_NORMAL_UNTRACKED_FILES;\n\t\telse if (!strcmp(v, \"all\"))\n\t\t\ts->show_untracked_files = SHOW_ALL_UNTRACKED_FILES;\n\t\telse\n\t\t\treturn error(_(\"Invalid untracked files mode '%s'\"), v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"diff.renamelimit\")) {\n\t\tif (s->rename_limit == -1)\n\t\t\ts->rename_limit = git_config_int(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.renamelimit\")) {\n\t\ts->rename_limit = git_config_int(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"diff.renames\")) {\n\t\tif (s->detect_rename == -1)\n\t\t\ts->detect_rename = git_config_rename(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.renames\")) {\n\t\ts->detect_rename = git_config_rename(k, v);\n\t\treturn 0;\n\t}\n\treturn git_diff_ui_config(k, v, NULL);\n}\n\nint cmd_status(int argc, const char **argv, const char *prefix)\n{\n\tstatic int no_renames = -1;\n\tstatic const char *rename_score_arg = (const char *)-1;\n\tstatic struct wt_status s;\n\tunsigned int progress_flag = 0;\n\tint fd;\n\tstruct object_id oid;\n\tstatic struct option builtin_status_options[] = {\n\t\tOPT__VERBOSE(&verbose, N_(\"be verbose\")),\n\t\tOPT_SET_INT('s', \"short\", &status_format,\n\t\t\t    N_(\"show status concisely\"), STATUS_FORMAT_SHORT),\n\t\tOPT_BOOL('b', \"branch\", &s.show_branch,\n\t\t\t N_(\"show branch information\")),\n\t\tOPT_BOOL(0, \"show-stash\", &s.show_stash,\n\t\t\t N_(\"show stash information\")),\n\t\tOPT_BOOL(0, \"ahead-behind\", &s.ahead_behind_flags,\n\t\t\t N_(\"compute full ahead/behind values\")),\n\t\t{ OPTION_CALLBACK, 0, \"porcelain\", &status_format,\n\t\t  N_(\"version\"), N_(\"machine-readable output\"),\n\t\t  PARSE_OPT_OPTARG, opt_parse_porcelain },\n\t\tOPT_SET_INT(0, \"long\", &status_format,\n\t\t\t    N_(\"show status in long format (default)\"),\n\t\t\t    STATUS_FORMAT_LONG),\n\t\tOPT_BOOL('z', \"null\", &s.null_termination,\n\t\t\t N_(\"terminate entries with NUL\")),\n\t\t{ OPTION_STRING, 'u', \"untracked-files\", &untracked_files_arg,\n\t\t  N_(\"mode\"),\n\t\t  N_(\"show untracked files, optional modes: all, normal, no. (Default: all)\"),\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\t{ OPTION_STRING, 0, \"ignored\", &ignored_arg,\n\t\t  N_(\"mode\"),\n\t\t  N_(\"show ignored files, optional modes: traditional, matching, no. (Default: traditional)\"),\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"traditional\" },\n\t\t{ OPTION_STRING, 0, \"ignore-submodules\", &ignore_submodule_arg, N_(\"when\"),\n\t\t  N_(\"ignore changes to submodules, optional when: all, dirty, untracked. (Default: all)\"),\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\tOPT_COLUMN(0, \"column\", &s.colopts, N_(\"list untracked files in columns\")),\n\t\tOPT_BOOL(0, \"no-renames\", &no_renames, N_(\"do not detect renames\")),\n\t\t{ OPTION_CALLBACK, 'M', \"find-renames\", &rename_score_arg,\n\t\t  N_(\"n\"), N_(\"detect renames, optionally set similarity index\"),\n\t\t  PARSE_OPT_OPTARG | PARSE_OPT_NONEG, opt_parse_rename_score },\n\t\tOPT_END(),\n\t};\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_status_usage, builtin_status_options);\n\n\tstatus_init_config(&s, git_status_config);\n\targc = parse_options(argc, argv, prefix,\n\t\t\t     builtin_status_options,\n\t\t\t     builtin_status_usage, 0);\n\tfinalize_colopts(&s.colopts, -1);\n\tfinalize_deferred_config(&s);\n\n\thandle_untracked_files_arg(&s);\n\thandle_ignored_arg(&s);\n\n\tif (s.show_ignored_mode == SHOW_MATCHING_IGNORED &&\n\t    s.show_untracked_files == SHOW_NO_UNTRACKED_FILES)\n\t\tdie(_(\"Unsupported combination of ignored and untracked-files arguments\"));\n\n\tparse_pathspec(&s.pathspec, 0,\n\t\t       PATHSPEC_PREFER_FULL,\n\t\t       prefix, argv);\n\n\tif (status_format != STATUS_FORMAT_PORCELAIN &&\n\t    status_format != STATUS_FORMAT_PORCELAIN_V2)\n\t\tprogress_flag = REFRESH_PROGRESS;\n\tread_index(&the_index);\n\trefresh_index(&the_index,\n\t\t      REFRESH_QUIET|REFRESH_UNMERGED|progress_flag,\n\t\t      &s.pathspec, NULL, NULL);\n\n\tif (use_optional_locks())\n\t\tfd = hold_locked_index(&index_lock, 0);\n\telse\n\t\tfd = -1;\n\n\ts.is_initial = get_oid(s.reference, &oid) ? 1 : 0;\n\tif (!s.is_initial)\n\t\thashcpy(s.sha1_commit, oid.hash);\n\n\ts.ignore_submodule_arg = ignore_submodule_arg;\n\ts.status_format = status_format;\n\ts.verbose = verbose;\n\tif (no_renames != -1)\n\t\ts.detect_rename = !no_renames;\n\tif ((intptr_t)rename_score_arg != -1) {\n\t\tif (s.detect_rename < DIFF_DETECT_RENAME)\n\t\t\ts.detect_rename = DIFF_DETECT_RENAME;\n\t\tif (rename_score_arg)\n\t\t\ts.rename_score = parse_rename_score(&rename_score_arg);\n\t}\n\n\twt_status_collect(&s);\n\n\tif (0 <= fd)\n\t\tupdate_index_if_able(&the_index, &index_lock);\n\n\tif (s.relative_paths)\n\t\ts.prefix = prefix;\n\n\twt_status_print(&s);\n\twt_status_collect_free_buffers(&s);\n\n\treturn 0;\n}\n\nstatic int git_commit_config(const char *k, const char *v, void *cb)\n{\n\tstruct wt_status *s = cb;\n\tint status;\n\n\tif (!strcmp(k, \"commit.template\"))\n\t\treturn git_config_pathname(&template_file, k, v);\n\tif (!strcmp(k, \"commit.status\")) {\n\t\tinclude_status = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"commit.cleanup\"))\n\t\treturn git_config_string(&cleanup_arg, k, v);\n\tif (!strcmp(k, \"commit.gpgsign\")) {\n\t\tsign_commit = git_config_bool(k, v) ? \"\" : NULL;\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"commit.verbose\")) {\n\t\tint is_bool;\n\t\tconfig_commit_verbose = git_config_bool_or_int(k, v, &is_bool);\n\t\treturn 0;\n\t}\n\n\tstatus = git_gpg_config(k, v, NULL);\n\tif (status)\n\t\treturn status;\n\treturn git_status_config(k, v, s);\n}\n\nint run_commit_hook(int editor_is_used, const char *index_file, const char *name, ...)\n{\n\tstruct argv_array hook_env = ARGV_ARRAY_INIT;\n\tva_list args;\n\tint ret;\n\n\targv_array_pushf(&hook_env, \"GIT_INDEX_FILE=%s\", index_file);\n\n\t/*\n\t * Let the hook know that no editor will be launched.\n\t */\n\tif (!editor_is_used)\n\t\targv_array_push(&hook_env, \"GIT_EDITOR=:\");\n\n\tva_start(args, name);\n\tret = run_hook_ve(hook_env.argv,name, args);\n\tva_end(args);\n\targv_array_clear(&hook_env);\n\n\treturn ret;\n}\n\nint cmd_commit(int argc, const char **argv, const char *prefix)\n{\n\tconst char *argv_gc_auto[] = {\"gc\", \"--auto\", NULL};\n\tstatic struct wt_status s;\n\tstatic struct option builtin_commit_options[] = {\n\t\tOPT__QUIET(&quiet, N_(\"suppress summary after successful commit\")),\n\t\tOPT__VERBOSE(&verbose, N_(\"show diff in commit message template\")),\n\n\t\tOPT_GROUP(N_(\"Commit message options\")),\n\t\tOPT_FILENAME('F', \"file\", &logfile, N_(\"read message from file\")),\n\t\tOPT_STRING(0, \"author\", &force_author, N_(\"author\"), N_(\"override author for commit\")),\n\t\tOPT_STRING(0, \"date\", &force_date, N_(\"date\"), N_(\"override date for commit\")),\n\t\tOPT_CALLBACK('m', \"message\", &message, N_(\"message\"), N_(\"commit message\"), opt_parse_m),\n\t\tOPT_STRING('c', \"reedit-message\", &edit_message, N_(\"commit\"), N_(\"reuse and edit message from specified commit\")),\n\t\tOPT_STRING('C', \"reuse-message\", &use_message, N_(\"commit\"), N_(\"reuse message from specified commit\")),\n\t\tOPT_STRING(0, \"fixup\", &fixup_message, N_(\"commit\"), N_(\"use autosquash formatted message to fixup specified commit\")),\n\t\tOPT_STRING(0, \"squash\", &squash_message, N_(\"commit\"), N_(\"use autosquash formatted message to squash specified commit\")),\n\t\tOPT_BOOL(0, \"reset-author\", &renew_authorship, N_(\"the commit is authored by me now (used with -C/-c/--amend)\")),\n\t\tOPT_BOOL('s', \"signoff\", &signoff, N_(\"add Signed-off-by:\")),\n\t\tOPT_FILENAME('t', \"template\", &template_file, N_(\"use specified template file\")),\n\t\tOPT_BOOL('e', \"edit\", &edit_flag, N_(\"force edit of commit\")),\n\t\tOPT_STRING(0, \"cleanup\", &cleanup_arg, N_(\"default\"), N_(\"how to strip spaces and #comments from message\")),\n\t\tOPT_BOOL(0, \"status\", &include_status, N_(\"include status in commit message template\")),\n\t\t{ OPTION_STRING, 'S', \"gpg-sign\", &sign_commit, N_(\"key-id\"),\n\t\t  N_(\"GPG sign commit\"), PARSE_OPT_OPTARG, NULL, (intptr_t) \"\" },\n\t\t/* end commit message options */\n\n\t\tOPT_GROUP(N_(\"Commit contents options\")),\n\t\tOPT_BOOL('a', \"all\", &all, N_(\"commit all changed files\")),\n\t\tOPT_BOOL('i', \"include\", &also, N_(\"add specified files to index for commit\")),\n\t\tOPT_BOOL(0, \"interactive\", &interactive, N_(\"interactively add files\")),\n\t\tOPT_BOOL('p', \"patch\", &patch_interactive, N_(\"interactively add changes\")),\n\t\tOPT_BOOL('o', \"only\", &only, N_(\"commit only specified files\")),\n\t\tOPT_BOOL('n', \"no-verify\", &no_verify, N_(\"bypass pre-commit and commit-msg hooks\")),\n\t\tOPT_BOOL(0, \"dry-run\", &dry_run, N_(\"show what would be committed\")),\n\t\tOPT_SET_INT(0, \"short\", &status_format, N_(\"show status concisely\"),\n\t\t\t    STATUS_FORMAT_SHORT),\n\t\tOPT_BOOL(0, \"branch\", &s.show_branch, N_(\"show branch information\")),\n\t\tOPT_BOOL(0, \"ahead-behind\", &s.ahead_behind_flags,\n\t\t\t N_(\"compute full ahead/behind values\")),\n\t\tOPT_SET_INT(0, \"porcelain\", &status_format,\n\t\t\t    N_(\"machine-readable output\"), STATUS_FORMAT_PORCELAIN),\n\t\tOPT_SET_INT(0, \"long\", &status_format,\n\t\t\t    N_(\"show status in long format (default)\"),\n\t\t\t    STATUS_FORMAT_LONG),\n\t\tOPT_BOOL('z', \"null\", &s.null_termination,\n\t\t\t N_(\"terminate entries with NUL\")),\n\t\tOPT_BOOL(0, \"amend\", &amend, N_(\"amend previous commit\")),\n\t\tOPT_BOOL(0, \"no-post-rewrite\", &no_post_rewrite, N_(\"bypass post-rewrite hook\")),\n\t\t{ OPTION_STRING, 'u', \"untracked-files\", &untracked_files_arg, N_(\"mode\"), N_(\"show untracked files, optional modes: all, normal, no. (Default: all)\"), PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\t/* end commit contents options */\n\n\t\tOPT_HIDDEN_BOOL(0, \"allow-empty\", &allow_empty,\n\t\t\t\tN_(\"ok to record an empty change\")),\n\t\tOPT_HIDDEN_BOOL(0, \"allow-empty-message\", &allow_empty_message,\n\t\t\t\tN_(\"ok to record a change with an empty message\")),\n\n\t\tOPT_END()\n\t};\n\n\tstruct strbuf sb = STRBUF_INIT;\n\tstruct strbuf author_ident = STRBUF_INIT;\n\tconst char *index_file, *reflog_msg;\n\tstruct object_id oid;\n\tstruct commit_list *parents = NULL;\n\tstruct stat statbuf;\n\tstruct commit *current_head = NULL;\n\tstruct commit_extra_header *extra = NULL;\n\tstruct strbuf err = STRBUF_INIT;\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_commit_usage, builtin_commit_options);\n\n\tstatus_init_config(&s, git_commit_config);\n\ts.commit_template = 1;\n\tstatus_format = STATUS_FORMAT_NONE; /* Ignore status.short */\n\ts.colopts = 0;\n\n\tif (get_oid(\"HEAD\", &oid))\n\t\tcurrent_head = NULL;\n\telse {\n\t\tcurrent_head = lookup_commit_or_die(&oid, \"HEAD\");\n\t\tif (parse_commit(current_head))\n\t\t\tdie(_(\"could not parse HEAD commit\"));\n\t}\n\tverbose = -1; /* unspecified */\n\targc = parse_and_validate_options(argc, argv, builtin_commit_options,\n\t\t\t\t\t  builtin_commit_usage,\n\t\t\t\t\t  prefix, current_head, &s);\n\tif (verbose == -1)\n\t\tverbose = (config_commit_verbose < 0) ? 0 : config_commit_verbose;\n\n\tif (dry_run)\n\t\treturn dry_run_commit(argc, argv, prefix, current_head, &s);\n\tindex_file = prepare_index(argc, argv, prefix, current_head, 0);\n\n\t/* Set up everything for writing the commit object.  This includes\n\t   running hooks, writing the trees, and interacting with the user.  */\n\tif (!prepare_to_commit(index_file, prefix,\n\t\t\t       current_head, &s, &author_ident)) {\n\t\trollback_index_files();\n\t\treturn 1;\n\t}\n\n\t/* Determine parents */\n\treflog_msg = getenv(\"GIT_REFLOG_ACTION\");\n\tif (!current_head) {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (initial)\";\n\t} else if (amend) {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (amend)\";\n\t\tparents = copy_commit_list(current_head->parents);\n\t} else if (whence == FROM_MERGE) {\n\t\tstruct strbuf m = STRBUF_INIT;\n\t\tFILE *fp;\n\t\tint allow_fast_forward = 1;\n\t\tstruct commit_list **pptr = &parents;\n\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (merge)\";\n\t\tpptr = commit_list_append(current_head, pptr);\n\t\tfp = xfopen(git_path_merge_head(the_repository), \"r\");\n\t\twhile (strbuf_getline_lf(&m, fp) != EOF) {\n\t\t\tstruct commit *parent;\n\n\t\t\tparent = get_merge_parent(m.buf);\n\t\t\tif (!parent)\n\t\t\t\tdie(_(\"Corrupt MERGE_HEAD file (%s)\"), m.buf);\n\t\t\tpptr = commit_list_append(parent, pptr);\n\t\t}\n\t\tfclose(fp);\n\t\tstrbuf_release(&m);\n\t\tif (!stat(git_path_merge_mode(the_repository), &statbuf)) {\n\t\t\tif (strbuf_read_file(&sb, git_path_merge_mode(the_repository), 0) < 0)\n\t\t\t\tdie_errno(_(\"could not read MERGE_MODE\"));\n\t\t\tif (!strcmp(sb.buf, \"no-ff\"))\n\t\t\t\tallow_fast_forward = 0;\n\t\t}\n\t\tif (allow_fast_forward)\n\t\t\treduce_heads_replace(&parents);\n\t} else {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = (whence == FROM_CHERRY_PICK)\n\t\t\t\t\t? \"commit (cherry-pick)\"\n\t\t\t\t\t: \"commit\";\n\t\tcommit_list_insert(current_head, &parents);\n\t}\n\n\t/* Finally, get the commit message */\n\tstrbuf_reset(&sb);\n\tif (strbuf_read_file(&sb, git_path_commit_editmsg(), 0) < 0) {\n\t\tint saved_errno = errno;\n\t\trollback_index_files();\n\t\tdie(_(\"could not read commit message: %s\"), strerror(saved_errno));\n\t}\n\n\tif (verbose || /* Truncate the message just before the diff, if any. */\n\t    cleanup_mode == COMMIT_MSG_CLEANUP_SCISSORS)\n\t\tstrbuf_setlen(&sb, wt_status_locate_end(sb.buf, sb.len));\n\tif (cleanup_mode != COMMIT_MSG_CLEANUP_NONE)\n\t\tstrbuf_stripspace(&sb, cleanup_mode == COMMIT_MSG_CLEANUP_ALL);\n\n\tif (message_is_empty(&sb, cleanup_mode) && !allow_empty_message) {\n\t\trollback_index_files();\n\t\tfprintf(stderr, _(\"Aborting commit due to empty commit message.\\n\"));\n\t\texit(1);\n\t}\n\tif (template_untouched(&sb, template_file, cleanup_mode) && !allow_empty_message) {\n\t\trollback_index_files();\n\t\tfprintf(stderr, _(\"Aborting commit; you did not edit the message.\\n\"));\n\t\texit(1);\n\t}\n\n\tif (amend) {\n\t\tconst char *exclude_gpgsig[2] = { \"gpgsig\", NULL };\n\t\textra = read_commit_extra_headers(current_head, exclude_gpgsig);\n\t} else {\n\t\tstruct commit_extra_header **tail = &extra;\n\t\tappend_merge_tag_headers(parents, &tail);\n\t}\n\n\tif (commit_tree_extended(sb.buf, sb.len, &active_cache_tree->oid,\n\t\t\t\t parents, &oid, author_ident.buf, sign_commit,\n\t\t\t\t extra)) {\n\t\trollback_index_files();\n\t\tdie(_(\"failed to write commit object\"));\n\t}\n\tstrbuf_release(&author_ident);\n\tfree_commit_extra_headers(extra);\n\n\tif (update_head_with_reflog(current_head, &oid, reflog_msg, &sb,\n\t\t\t\t    &err)) {\n\t\trollback_index_files();\n\t\tdie(\"%s\", err.buf);\n\t}\n\n\tunlink(git_path_cherry_pick_head(the_repository));\n\tunlink(git_path_revert_head(the_repository));\n\tunlink(git_path_merge_head(the_repository));\n\tunlink(git_path_merge_msg(the_repository));\n\tunlink(git_path_merge_mode(the_repository));\n\tunlink(git_path_squash_msg(the_repository));\n\n\tif (commit_index_files())\n\t\tdie(_(\"repository has been updated, but unable to write\\n\"\n\t\t      \"new_index file. Check that disk is not full and quota is\\n\"\n\t\t      \"not exceeded, and then \\\"git reset HEAD\\\" to recover.\"));\n\n\tif (git_env_bool(GIT_TEST_COMMIT_GRAPH, 0))\n\t\twrite_commit_graph_reachable(get_object_directory(), 0, 0);\n\n\trepo_rerere(the_repository, 0);\n\trun_command_v_opt(argv_gc_auto, RUN_GIT_CMD);\n\trun_commit_hook(use_editor, get_index_file(), \"post-commit\", NULL);\n\tif (amend && !no_post_rewrite) {\n\t\tcommit_post_rewrite(current_head, &oid);\n\t}\n\tif (!quiet) {\n\t\tunsigned int flags = 0;\n\n\t\tif (!current_head)\n\t\t\tflags |= SUMMARY_INITIAL_COMMIT;\n\t\tif (author_date_is_interesting())\n\t\t\tflags |= SUMMARY_SHOW_AUTHOR_DATE;\n\t\tprint_commit_summary(the_repository, prefix,\n\t\t\t\t     &oid, flags);\n\t}\n\n\tUNLEAK(err);\n\tUNLEAK(sb);\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "004b816635bf1628bfe7697f737a22cbcd27622b",
  "sha1_ok": true,
  "size": 51614
}
