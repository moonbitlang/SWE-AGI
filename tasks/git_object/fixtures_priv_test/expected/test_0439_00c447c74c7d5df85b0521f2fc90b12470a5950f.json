{
  "content": {
    "base64": "cGFyc2Utb3B0aW9ucyBBUEkKPT09PT09PT09PT09PT09PT0KClRoZSBwYXJzZS1vcHRpb25zIEFQSSBpcyB1c2VkIHRvIHBhcnNlIGFuZCBtYXNzYWdlIG9wdGlvbnMgaW4gZ2l0CmFuZCB0byBwcm92aWRlIGEgdXNhZ2UgaGVscCB3aXRoIGNvbnNpc3RlbnQgbG9vay4KCkJhc2ljcwotLS0tLS0KClRoZSBhcmd1bWVudCB2ZWN0b3IgYGFyZ3ZbXWAgbWF5IHVzdWFsbHkgY29udGFpbiBtYW5kYXRvcnkgb3Igb3B0aW9uYWwKJ25vbi1vcHRpb24gYXJndW1lbnRzJywgZS5nLiBhIGZpbGVuYW1lIG9yIGEgYnJhbmNoLCBhbmQgJ29wdGlvbnMnLgpPcHRpb25zIGFyZSBvcHRpb25hbCBhcmd1bWVudHMgdGhhdCBzdGFydCB3aXRoIGEgZGFzaCBhbmQKdGhhdCBhbGxvdyB0byBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIGEgY29tbWFuZC4KCiogVGhlcmUgYXJlIGJhc2ljYWxseSB0aHJlZSB0eXBlcyBvZiBvcHRpb25zOgogICdib29sZWFuJyBvcHRpb25zLAogIG9wdGlvbnMgd2l0aCAobWFuZGF0b3J5KSAnYXJndW1lbnRzJyBhbmQKICBvcHRpb25zIHdpdGggJ29wdGlvbmFsIGFyZ3VtZW50cycKICAoaS5lLiBhIGJvb2xlYW4gb3B0aW9uIHRoYXQgY2FuIGJlIGFkanVzdGVkKS4KCiogVGhlcmUgYXJlIGJhc2ljYWxseSB0d28gZm9ybXMgb2Ygb3B0aW9uczoKICAnU2hvcnQgb3B0aW9ucycgY29uc2lzdCBvZiBvbmUgZGFzaCAoYC1gKSBhbmQgb25lIGFscGhhbnVtZXJpYwogIGNoYXJhY3Rlci4KICAnTG9uZyBvcHRpb25zJyBiZWdpbiB3aXRoIHR3byBkYXNoZXMgKGBcLS1gKSBhbmQgc29tZQogIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLgoKKiBPcHRpb25zIGFyZSBjYXNlLXNlbnNpdGl2ZS4KICBQbGVhc2UgZGVmaW5lICdsb3dlci1jYXNlIGxvbmcgb3B0aW9ucycgb25seS4KClRoZSBwYXJzZS1vcHRpb25zIEFQSSBhbGxvd3M6CgoqICdzdGlja2VkJyBhbmQgJ3NlcGFyYXRlIGZvcm0nIG9mIG9wdGlvbnMgd2l0aCBhcmd1bWVudHMuCiAgYC1vQXJnYCBpcyBzdGlja2VkLCBgLW8gQXJnYCBpcyBzZXBhcmF0ZSBmb3JtLgogIGBcLS1vcHRpb249QXJnYCBpcyBzdGlja2VkLCBgXC0tb3B0aW9uIEFyZ2AgaXMgc2VwYXJhdGUgZm9ybS4KCiogTG9uZyBvcHRpb25zIG1heSBiZSAnYWJicmV2aWF0ZWQnLCBhcyBsb25nIGFzIHRoZSBhYmJyZXZpYXRpb24KICBpcyB1bmFtYmlndW91cy4KCiogU2hvcnQgb3B0aW9ucyBtYXkgYmUgYnVuZGxlZCwgZS5nLiBgLWEgLWJgIGNhbiBiZSBzcGVjaWZpZWQgYXMgYC1hYmAuCgoqIEJvb2xlYW4gbG9uZyBvcHRpb25zIGNhbiBiZSAnbmVnYXRlZCcgKG9yICd1bnNldCcpIGJ5IHByZXBlbmRpbmcKICBgbm8tYCwgZS5nLiBgXC0tbm8tYWJicmV2YCBpbnN0ZWFkIG9mIGBcLS1hYmJyZXZgLgoKKiBPcHRpb25zIGFuZCBub24tb3B0aW9uIGFyZ3VtZW50cyBjYW4gY2xlYXJseSBiZSBzZXBhcmF0ZWQgdXNpbmcgdGhlIGBcLS1gCiAgb3B0aW9uLCBlLmcuIGAtYSAtYiBcLS1vcHRpb24gXC0tIFwtLXRoaXMtaXMtYS1maWxlYCBpbmRpY2F0ZXMgdGhhdAogIGBcLS10aGlzLWlzLWEtZmlsZWAgbXVzdCBub3QgYmUgcHJvY2Vzc2VkIGFzIGFuIG9wdGlvbi4KClN0ZXBzIHRvIHBhcnNlIG9wdGlvbnMKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKLiBgI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCJgCgouIGRlZmluZSBhIE5VTEwtdGVybWluYXRlZAogIGBzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGJ1aWx0aW5fZm9vX3VzYWdlW11gIGFycmF5CiAgY29udGFpbmluZyBhbHRlcm5hdGl2ZSB1c2FnZSBzdHJpbmdzCgouIGRlZmluZSBgYnVpbHRpbl9mb29fb3B0aW9uc2AgYXJyYXkgYXMgZGVzY3JpYmVkIGJlbG93CiAgaW4gc2VjdGlvbiAnRGF0YSBTdHJ1Y3R1cmUnLgoKLiBpbiBgY21kX2ZvbyhpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeClgCiAgY2FsbAoKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgYnVpbHRpbl9mb29fb3B0aW9ucywgYnVpbHRpbl9mb29fdXNhZ2UsIGZsYWdzKTsKKwpgcGFyc2Vfb3B0aW9ucygpYCB3aWxsIGZpbHRlciBvdXQgdGhlIHByb2Nlc3NlZCBvcHRpb25zIG9mIGBhcmd2W11gIGFuZCBsZWF2ZSB0aGUKbm9uLW9wdGlvbiBhcmd1bWVudHMgaW4gYGFyZ3ZbXWAuCmBhcmdjYCBpcyB1cGRhdGVkIGFwcHJvcHJpYXRlbHkgYmVjYXVzZSBvZiB0aGUgYXNzaWdubWVudC4KKwpZb3UgY2FuIGFsc28gcGFzcyBOVUxMIGluc3RlYWQgb2YgYSB1c2FnZSBhcnJheSBhcyB0aGUgZmlmdGggcGFyYW1ldGVyIG9mCnBhcnNlX29wdGlvbnMoKSwgdG8gYXZvaWQgZGlzcGxheWluZyBhIGhlbHAgc2NyZWVuIHdpdGggdXNhZ2UgaW5mbyBhbmQKb3B0aW9uIGxpc3QuICBUaGlzIHNob3VsZCBvbmx5IGJlIGRvbmUgaWYgbmVjZXNzYXJ5LCBlLmcuIHRvIGltcGxlbWVudAphIGxpbWl0ZWQgcGFyc2VyIGZvciBvbmx5IGEgc3Vic2V0IG9mIHRoZSBvcHRpb25zIHRoYXQgbmVlZHMgdG8gYmUgcnVuCmJlZm9yZSB0aGUgZnVsbCBwYXJzZXIsIHdoaWNoIGluIHR1cm4gc2hvd3MgdGhlIGZ1bGwgaGVscCBtZXNzYWdlLgorCkZsYWdzIGFyZSB0aGUgYml0d2lzZS1vciBvZjoKCmBQQVJTRV9PUFRfS0VFUF9EQVNIREFTSGA6OgoJS2VlcCB0aGUgYFwtLWAgdGhhdCB1c3VhbGx5IHNlcGFyYXRlcyBvcHRpb25zIGZyb20KCW5vbi1vcHRpb24gYXJndW1lbnRzLgoKYFBBUlNFX09QVF9TVE9QX0FUX05PTl9PUFRJT05gOjoKCVVzdWFsbHkgdGhlIHdob2xlIGFyZ3VtZW50IHZlY3RvciBpcyBtYXNzYWdlZCBhbmQgcmVvcmRlcmVkLgoJVXNpbmcgdGhpcyBmbGFnLCBwcm9jZXNzaW5nIGlzIHN0b3BwZWQgYXQgdGhlIGZpcnN0IG5vbi1vcHRpb24KCWFyZ3VtZW50LgoKYFBBUlNFX09QVF9LRUVQX0FSR1YwYDo6CglLZWVwIHRoZSBmaXJzdCBhcmd1bWVudCwgd2hpY2ggY29udGFpbnMgdGhlIHByb2dyYW0gbmFtZS4gIEl0J3MKCXJlbW92ZWQgZnJvbSBhcmd2W10gYnkgZGVmYXVsdC4KCmBQQVJTRV9PUFRfS0VFUF9VTktOT1dOYDo6CglLZWVwIHVua25vd24gYXJndW1lbnRzIGluc3RlYWQgb2YgZXJyb3Jpbmcgb3V0LiAgVGhpcyBkb2Vzbid0Cgl3b3JrIGZvciBhbGwgY29tYmluYXRpb25zIG9mIGFyZ3VtZW50cyBhcyB1c2VycyBtaWdodCBleHBlY3QKCWl0IHRvIGRvLiAgRS5nLiBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaW4gYC0tdW5rbm93biAtLWtub3duYAoJdGFrZXMgYSB2YWx1ZSAod2hpY2ggd2UgY2FuJ3Qga25vdyksIHRoZSBzZWNvbmQgb25lIGlzCgltaXN0YWtlbmx5IGludGVycHJldGVkIGFzIGEga25vd24gb3B0aW9uLiAgU2ltaWxhcmx5LCBpZgoJYFBBUlNFX09QVF9TVE9QX0FUX05PTl9PUFRJT05gIGlzIHNldCwgdGhlIHNlY29uZCBhcmd1bWVudCBpbgoJYC0tdW5rbm93biB2YWx1ZWAgd2lsbCBiZSBtaXN0YWtlbmx5IGludGVycHJldGVkIGFzIGEKCW5vbi1vcHRpb24sIG5vdCBhcyBhIHZhbHVlIGJlbG9uZ2luZyB0byB0aGUgdW5rbm93biBvcHRpb24sCgl0aGUgcGFyc2VyIGVhcmx5LiAgVGhhdCdzIHdoeSBwYXJzZV9vcHRpb25zKCkgZXJyb3JzIG91dCBpZgoJYm90aCBvcHRpb25zIGFyZSBzZXQuCgpgUEFSU0VfT1BUX05PX0lOVEVSTkFMX0hFTFBgOjoKCUJ5IGRlZmF1bHQsIHBhcnNlX29wdGlvbnMoKSBoYW5kbGVzIGAtaGAsIGAtLWhlbHBgIGFuZAoJYC0taGVscC1hbGxgIGludGVybmFsbHksIGJ5IHNob3dpbmcgYSBoZWxwIHNjcmVlbi4gIFRoaXMgb3B0aW9uCgl0dXJucyBpdCBvZmYgYW5kIGFsbG93cyBvbmUgdG8gYWRkIGN1c3RvbSBoYW5kbGVycyBmb3IgdGhlc2UKCW9wdGlvbnMsIG9yIHRvIGp1c3QgbGVhdmUgdGhlbSB1bmtub3duLgoKRGF0YSBTdHJ1Y3R1cmUKLS0tLS0tLS0tLS0tLS0KClRoZSBtYWluIGRhdGEgc3RydWN0dXJlIGlzIGFuIGFycmF5IG9mIHRoZSBgb3B0aW9uYCBzdHJ1Y3QsCnNheSBgc3RhdGljIHN0cnVjdCBvcHRpb24gYnVpbHRpbl9hZGRfb3B0aW9uc1tdYC4KVGhlcmUgYXJlIHNvbWUgbWFjcm9zIHRvIGVhc2lseSBkZWZpbmUgb3B0aW9uczoKCmBPUFRfX0FCQlJFVigmaW50X3ZhcilgOjoKCUFkZCBgXC0tYWJicmV2Wz08bj5dYC4KCmBPUFRfX0NPTE9SKCZpbnRfdmFyLCBkZXNjcmlwdGlvbilgOjoKCUFkZCBgXC0tY29sb3JbPTx3aGVuPl1gIGFuZCBgLS1uby1jb2xvcmAuCgpgT1BUX19EUllfUlVOKCZpbnRfdmFyLCBkZXNjcmlwdGlvbilgOjoKCUFkZCBgLW4sIFwtLWRyeS1ydW5gLgoKYE9QVF9fUVVJRVQoJmludF92YXIpYDo6CglBZGQgYC1xLCBcLS1xdWlldGAuCgpgT1BUX19WRVJCT1NFKCZpbnRfdmFyLCBkZXNjcmlwdGlvbilgOjoKCUFkZCBgLXYsIFwtLXZlcmJvc2VgLgoKYE9QVF9HUk9VUChkZXNjcmlwdGlvbilgOjoKCVN0YXJ0IGFuIG9wdGlvbiBncm91cC4gYGRlc2NyaXB0aW9uYCBpcyBhIHNob3J0IHN0cmluZyB0aGF0CglkZXNjcmliZXMgdGhlIGdyb3VwIG9yIGFuIGVtcHR5IHN0cmluZy4KCVN0YXJ0IHRoZSBkZXNjcmlwdGlvbiB3aXRoIGFuIHVwcGVyLWNhc2UgbGV0dGVyLgoKYE9QVF9CT09MRUFOKHNob3J0LCBsb25nLCAmaW50X3ZhciwgZGVzY3JpcHRpb24pYDo6CglJbnRyb2R1Y2UgYSBib29sZWFuIG9wdGlvbi4KCWBpbnRfdmFyYCBpcyBpbmNyZW1lbnRlZCBvbiBlYWNoIHVzZS4KCmBPUFRfQklUKHNob3J0LCBsb25nLCAmaW50X3ZhciwgZGVzY3JpcHRpb24sIG1hc2spYDo6CglJbnRyb2R1Y2UgYSBib29sZWFuIG9wdGlvbi4KCUlmIHVzZWQsIGBpbnRfdmFyYCBpcyBiaXR3aXNlLW9yZWQgd2l0aCBgbWFza2AuCgpgT1BUX05FR0JJVChzaG9ydCwgbG9uZywgJmludF92YXIsIGRlc2NyaXB0aW9uLCBtYXNrKWA6OgoJSW50cm9kdWNlIGEgYm9vbGVhbiBvcHRpb24uCglJZiB1c2VkLCBgaW50X3ZhcmAgaXMgYml0d2lzZS1hbmRlZCB3aXRoIHRoZSBpbnZlcnRlZCBgbWFza2AuCgpgT1BUX1NFVF9JTlQoc2hvcnQsIGxvbmcsICZpbnRfdmFyLCBkZXNjcmlwdGlvbiwgaW50ZWdlcilgOjoKCUludHJvZHVjZSBhIGJvb2xlYW4gb3B0aW9uLgoJSWYgdXNlZCwgc2V0IGBpbnRfdmFyYCB0byBgaW50ZWdlcmAuCgpgT1BUX1NFVF9QVFIoc2hvcnQsIGxvbmcsICZwdHJfdmFyLCBkZXNjcmlwdGlvbiwgcHRyKWA6OgoJSW50cm9kdWNlIGEgYm9vbGVhbiBvcHRpb24uCglJZiB1c2VkLCBzZXQgYHB0cl92YXJgIHRvIGBwdHJgLgoKYE9QVF9TVFJJTkcoc2hvcnQsIGxvbmcsICZzdHJfdmFyLCBhcmdfc3RyLCBkZXNjcmlwdGlvbilgOjoKCUludHJvZHVjZSBhbiBvcHRpb24gd2l0aCBzdHJpbmcgYXJndW1lbnQuCglUaGUgc3RyaW5nIGFyZ3VtZW50IGlzIHB1dCBpbnRvIGBzdHJfdmFyYC4KCmBPUFRfSU5URUdFUihzaG9ydCwgbG9uZywgJmludF92YXIsIGRlc2NyaXB0aW9uKWA6OgoJSW50cm9kdWNlIGFuIG9wdGlvbiB3aXRoIGludGVnZXIgYXJndW1lbnQuCglUaGUgaW50ZWdlciBpcyBwdXQgaW50byBgaW50X3ZhcmAuCgpgT1BUX0RBVEUoc2hvcnQsIGxvbmcsICZpbnRfdmFyLCBkZXNjcmlwdGlvbilgOjoKCUludHJvZHVjZSBhbiBvcHRpb24gd2l0aCBkYXRlIGFyZ3VtZW50LCBzZWUgYGFwcHJveGlkYXRlKClgLgoJVGhlIHRpbWVzdGFtcCBpcyBwdXQgaW50byBgaW50X3ZhcmAuCgpgT1BUX0NBTExCQUNLKHNob3J0LCBsb25nLCAmdmFyLCBhcmdfc3RyLCBkZXNjcmlwdGlvbiwgZnVuY19wdHIpYDo6CglJbnRyb2R1Y2UgYW4gb3B0aW9uIHdpdGggYXJndW1lbnQuCglUaGUgYXJndW1lbnQgd2lsbCBiZSBmZWQgaW50byB0aGUgZnVuY3Rpb24gZ2l2ZW4gYnkgYGZ1bmNfcHRyYAoJYW5kIHRoZSByZXN1bHQgd2lsbCBiZSBwdXQgaW50byBgdmFyYC4KCVNlZSAnT3B0aW9uIENhbGxiYWNrcycgYmVsb3cgZm9yIGEgbW9yZSBlbGFib3JhdGUgZGVzY3JpcHRpb24uCgpgT1BUX0ZJTEVOQU1FKHNob3J0LCBsb25nLCAmdmFyLCBkZXNjcmlwdGlvbilgOjoKCUludHJvZHVjZSBhbiBvcHRpb24gd2l0aCBhIGZpbGVuYW1lIGFyZ3VtZW50LgoJVGhlIGZpbGVuYW1lIHdpbGwgYmUgcHJlZml4ZWQgYnkgcGFzc2luZyB0aGUgZmlsZW5hbWUgYWxvbmcgd2l0aAoJdGhlIHByZWZpeCBhcmd1bWVudCBvZiBgcGFyc2Vfb3B0aW9ucygpYCB0byBgcHJlZml4X2ZpbGVuYW1lKClgLgoKYE9QVF9BUkdVTUVOVChsb25nLCBkZXNjcmlwdGlvbilgOjoKCUludHJvZHVjZSBhIGxvbmctb3B0aW9uIGFyZ3VtZW50IHRoYXQgd2lsbCBiZSBrZXB0IGluIGBhcmd2W11gLgoKYE9QVF9OVU1CRVJfQ0FMTEJBQ0soJnZhciwgZGVzY3JpcHRpb24sIGZ1bmNfcHRyKWA6OgoJUmVjb2duaXplIG51bWVyaWNhbCBvcHRpb25zIGxpa2UgLTEyMyBhbmQgZmVlZCB0aGUgaW50ZWdlciBhcwoJaWYgaXQgd2FzIGFuIGFyZ3VtZW50IHRvIHRoZSBmdW5jdGlvbiBnaXZlbiBieSBgZnVuY19wdHJgLgoJVGhlIHJlc3VsdCB3aWxsIGJlIHB1dCBpbnRvIGB2YXJgLiAgVGhlcmUgY2FuIGJlIG9ubHkgb25lIHN1Y2gKCW9wdGlvbiBkZWZpbml0aW9uLiAgSXQgY2Fubm90IGJlIG5lZ2F0ZWQgYW5kIGl0IHRha2VzIG5vCglhcmd1bWVudHMuICBTaG9ydCBvcHRpb25zIHRoYXQgaGFwcGVuIHRvIGJlIGRpZ2l0cyB0YWtlCglwcmVjZWRlbmNlIG92ZXIgaXQuCgpgT1BUX0NPTE9SX0ZMQUcoc2hvcnQsIGxvbmcsICZpbnRfdmFyLCBkZXNjcmlwdGlvbilgOjoKCUludHJvZHVjZSBhbiBvcHRpb24gdGhhdCB0YWtlcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGNhbgoJaGF2ZSBvbmUgb2YgdGhyZWUgdmFsdWVzOiAiYWx3YXlzIiwgIm5ldmVyIiwgb3IgImF1dG8iLiAgSWYgdGhlCglhcmd1bWVudCBpcyBub3QgZ2l2ZW4sIGl0IGRlZmF1bHRzIHRvICJhbHdheXMiLiAgVGhlIGAtLW5vLWAgZm9ybQoJd29ya3MgbGlrZSBgLS1sb25nPW5ldmVyYDsgaXQgY2Fubm90IHRha2UgYW4gYXJndW1lbnQuICBJZgoJImFsd2F5cyIsIHNldCBgaW50X3ZhcmAgdG8gMTsgaWYgIm5ldmVyIiwgc2V0IGBpbnRfdmFyYCB0byAwOyBpZgoJImF1dG8iLCBzZXQgYGludF92YXJgIHRvIDEgaWYgc3Rkb3V0IGlzIGEgdHR5IG9yIGEgcGFnZXIsCgkwIG90aGVyd2lzZS4KCgpUaGUgbGFzdCBlbGVtZW50IG9mIHRoZSBhcnJheSBtdXN0IGJlIGBPUFRfRU5EKClgLgoKSWYgbm90IHN0YXRlZCBvdGhlcndpc2UsIGludGVycHJldCB0aGUgYXJndW1lbnRzIGFzIGZvbGxvd3M6CgoqIGBzaG9ydGAgaXMgYSBjaGFyYWN0ZXIgZm9yIHRoZSBzaG9ydCBvcHRpb24KICAoZS5nLiBge2Fwb3N0cm9waGV9ZXthcG9zdHJvcGhlfWAgZm9yIGAtZWAsIHVzZSBgMGAgdG8gb21pdCksCgoqIGBsb25nYCBpcyBhIHN0cmluZyBmb3IgdGhlIGxvbmcgb3B0aW9uCiAgKGUuZy4gYCJleGFtcGxlImAgZm9yIGBcLS1leGFtcGxlYCwgdXNlIGBOVUxMYCB0byBvbWl0KSwKCiogYGludF92YXJgIGlzIGFuIGludGVnZXIgdmFyaWFibGUsCgoqIGBzdHJfdmFyYCBpcyBhIHN0cmluZyB2YXJpYWJsZSAoYGNoYXIgKmApLAoKKiBgYXJnX3N0cmAgaXMgdGhlIHN0cmluZyB0aGF0IGlzIHNob3duIGFzIGFyZ3VtZW50CiAgKGUuZy4gYCJicmFuY2giYCB3aWxsIHJlc3VsdCBpbiBgPGJyYW5jaD5gKS4KICBJZiBzZXQgdG8gYE5VTExgLCB0aHJlZSBkb3RzIChgLi4uYCkgd2lsbCBiZSBkaXNwbGF5ZWQuCgoqIGBkZXNjcmlwdGlvbmAgaXMgYSBzaG9ydCBzdHJpbmcgdG8gZGVzY3JpYmUgdGhlIGVmZmVjdCBvZiB0aGUgb3B0aW9uLgogIEl0IHNoYWxsIGJlZ2luIHdpdGggYSBsb3dlci1jYXNlIGxldHRlciBhbmQgYSBmdWxsIHN0b3AgKGAuYCkgc2hhbGwgYmUKICBvbWl0dGVkIGF0IHRoZSBlbmQuCgpPcHRpb24gQ2FsbGJhY2tzCi0tLS0tLS0tLS0tLS0tLS0KClRoZSBmdW5jdGlvbiBtdXN0IGJlIGRlZmluZWQgaW4gdGhpcyBmb3JtOgoKCWludCBmdW5jKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCgpUaGUgY2FsbGJhY2sgbWVjaGFuaXNtIGlzIGFzIGZvbGxvd3M6CgoqIEluc2lkZSBgZnVuY2AsIHRoZSBvbmx5IGludGVyZXN0aW5nIG1lbWJlciBvZiB0aGUgc3RydWN0dXJlCiAgZ2l2ZW4gYnkgYG9wdGAgaXMgdGhlIHZvaWQgcG9pbnRlciBgb3B0XC0+dmFsdWVgLgogIGBcKm9wdFwtPnZhbHVlYCB3aWxsIGJlIHRoZSB2YWx1ZSB0aGF0IGlzIHNhdmVkIGludG8gYHZhcmAsIGlmIHlvdQogIHVzZSBgT1BUX0NBTExCQUNLKClgLgogIEZvciBleGFtcGxlLCBkbyBgKih1bnNpZ25lZCBsb25nICopb3B0XC0+dmFsdWUgPSA0MjtgIHRvIGdldCA0MgogIGludG8gYW4gYHVuc2lnbmVkIGxvbmdgIHZhcmlhYmxlLgoKKiBSZXR1cm4gdmFsdWUgYDBgIGluZGljYXRlcyBzdWNjZXNzIGFuZCBub24temVybyByZXR1cm4KICB2YWx1ZSB3aWxsIGludm9rZSBgdXNhZ2Vfd2l0aF9vcHRpb25zKClgIGFuZCwgdGh1cywgZGllLgoKKiBJZiB0aGUgdXNlciBuZWdhdGVzIHRoZSBvcHRpb24sIGBhcmdgIGlzIGBOVUxMYCBhbmQgYHVuc2V0YCBpcyAxLgoKU29waGlzdGljYXRlZCBvcHRpb24gcGFyc2luZwotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpJZiB5b3UgbmVlZCwgZm9yIGV4YW1wbGUsIG9wdGlvbiBjYWxsYmFja3Mgd2l0aCBvcHRpb25hbCBhcmd1bWVudHMKb3Igd2l0aG91dCBhcmd1bWVudHMgYXQgYWxsLCBvciBpZiB5b3UgbmVlZCBvdGhlciBzcGVjaWFsIGNhc2VzLAp0aGF0IGFyZSBub3QgaGFuZGxlZCBieSB0aGUgbWFjcm9zIGFib3ZlLCB5b3UgbmVlZCB0byBzcGVjaWZ5IHRoZQptZW1iZXJzIG9mIHRoZSBgb3B0aW9uYCBzdHJ1Y3R1cmUgbWFudWFsbHkuCgpUaGlzIGlzIG5vdCBjb3ZlcmVkIGluIHRoaXMgZG9jdW1lbnQsIGJ1dCB3ZWxsIGRvY3VtZW50ZWQKaW4gYHBhcnNlLW9wdGlvbnMuaGAgaXRzZWxmLgoKRXhhbXBsZXMKLS0tLS0tLS0KClNlZSBgdGVzdC1wYXJzZS1vcHRpb25zLmNgIGFuZApgYnVpbHRpbi1hZGQuY2AsCmBidWlsdGluLWNsb25lLmNgLApgYnVpbHRpbi1jb21taXQuY2AsCmBidWlsdGluLWZldGNoLmNgLApgYnVpbHRpbi1mc2NrLmNgLApgYnVpbHRpbi1ybS5jYApmb3IgcmVhbC13b3JsZCBleGFtcGxlcy4K",
    "text": "parse-options API\n=================\n\nThe parse-options API is used to parse and massage options in git\nand to provide a usage help with consistent look.\n\nBasics\n------\n\nThe argument vector `argv[]` may usually contain mandatory or optional\n'non-option arguments', e.g. a filename or a branch, and 'options'.\nOptions are optional arguments that start with a dash and\nthat allow to change the behavior of a command.\n\n* There are basically three types of options:\n  'boolean' options,\n  options with (mandatory) 'arguments' and\n  options with 'optional arguments'\n  (i.e. a boolean option that can be adjusted).\n\n* There are basically two forms of options:\n  'Short options' consist of one dash (`-`) and one alphanumeric\n  character.\n  'Long options' begin with two dashes (`\\--`) and some\n  alphanumeric characters.\n\n* Options are case-sensitive.\n  Please define 'lower-case long options' only.\n\nThe parse-options API allows:\n\n* 'sticked' and 'separate form' of options with arguments.\n  `-oArg` is sticked, `-o Arg` is separate form.\n  `\\--option=Arg` is sticked, `\\--option Arg` is separate form.\n\n* Long options may be 'abbreviated', as long as the abbreviation\n  is unambiguous.\n\n* Short options may be bundled, e.g. `-a -b` can be specified as `-ab`.\n\n* Boolean long options can be 'negated' (or 'unset') by prepending\n  `no-`, e.g. `\\--no-abbrev` instead of `\\--abbrev`.\n\n* Options and non-option arguments can clearly be separated using the `\\--`\n  option, e.g. `-a -b \\--option \\-- \\--this-is-a-file` indicates that\n  `\\--this-is-a-file` must not be processed as an option.\n\nSteps to parse options\n----------------------\n\n. `#include \"parse-options.h\"`\n\n. define a NULL-terminated\n  `static const char * const builtin_foo_usage[]` array\n  containing alternative usage strings\n\n. define `builtin_foo_options` array as described below\n  in section 'Data Structure'.\n\n. in `cmd_foo(int argc, const char **argv, const char *prefix)`\n  call\n\n\targc = parse_options(argc, argv, prefix, builtin_foo_options, builtin_foo_usage, flags);\n+\n`parse_options()` will filter out the processed options of `argv[]` and leave the\nnon-option arguments in `argv[]`.\n`argc` is updated appropriately because of the assignment.\n+\nYou can also pass NULL instead of a usage array as the fifth parameter of\nparse_options(), to avoid displaying a help screen with usage info and\noption list.  This should only be done if necessary, e.g. to implement\na limited parser for only a subset of the options that needs to be run\nbefore the full parser, which in turn shows the full help message.\n+\nFlags are the bitwise-or of:\n\n`PARSE_OPT_KEEP_DASHDASH`::\n\tKeep the `\\--` that usually separates options from\n\tnon-option arguments.\n\n`PARSE_OPT_STOP_AT_NON_OPTION`::\n\tUsually the whole argument vector is massaged and reordered.\n\tUsing this flag, processing is stopped at the first non-option\n\targument.\n\n`PARSE_OPT_KEEP_ARGV0`::\n\tKeep the first argument, which contains the program name.  It's\n\tremoved from argv[] by default.\n\n`PARSE_OPT_KEEP_UNKNOWN`::\n\tKeep unknown arguments instead of erroring out.  This doesn't\n\twork for all combinations of arguments as users might expect\n\tit to do.  E.g. if the first argument in `--unknown --known`\n\ttakes a value (which we can't know), the second one is\n\tmistakenly interpreted as a known option.  Similarly, if\n\t`PARSE_OPT_STOP_AT_NON_OPTION` is set, the second argument in\n\t`--unknown value` will be mistakenly interpreted as a\n\tnon-option, not as a value belonging to the unknown option,\n\tthe parser early.  That's why parse_options() errors out if\n\tboth options are set.\n\n`PARSE_OPT_NO_INTERNAL_HELP`::\n\tBy default, parse_options() handles `-h`, `--help` and\n\t`--help-all` internally, by showing a help screen.  This option\n\tturns it off and allows one to add custom handlers for these\n\toptions, or to just leave them unknown.\n\nData Structure\n--------------\n\nThe main data structure is an array of the `option` struct,\nsay `static struct option builtin_add_options[]`.\nThere are some macros to easily define options:\n\n`OPT__ABBREV(&int_var)`::\n\tAdd `\\--abbrev[=<n>]`.\n\n`OPT__COLOR(&int_var, description)`::\n\tAdd `\\--color[=<when>]` and `--no-color`.\n\n`OPT__DRY_RUN(&int_var, description)`::\n\tAdd `-n, \\--dry-run`.\n\n`OPT__QUIET(&int_var)`::\n\tAdd `-q, \\--quiet`.\n\n`OPT__VERBOSE(&int_var, description)`::\n\tAdd `-v, \\--verbose`.\n\n`OPT_GROUP(description)`::\n\tStart an option group. `description` is a short string that\n\tdescribes the group or an empty string.\n\tStart the description with an upper-case letter.\n\n`OPT_BOOLEAN(short, long, &int_var, description)`::\n\tIntroduce a boolean option.\n\t`int_var` is incremented on each use.\n\n`OPT_BIT(short, long, &int_var, description, mask)`::\n\tIntroduce a boolean option.\n\tIf used, `int_var` is bitwise-ored with `mask`.\n\n`OPT_NEGBIT(short, long, &int_var, description, mask)`::\n\tIntroduce a boolean option.\n\tIf used, `int_var` is bitwise-anded with the inverted `mask`.\n\n`OPT_SET_INT(short, long, &int_var, description, integer)`::\n\tIntroduce a boolean option.\n\tIf used, set `int_var` to `integer`.\n\n`OPT_SET_PTR(short, long, &ptr_var, description, ptr)`::\n\tIntroduce a boolean option.\n\tIf used, set `ptr_var` to `ptr`.\n\n`OPT_STRING(short, long, &str_var, arg_str, description)`::\n\tIntroduce an option with string argument.\n\tThe string argument is put into `str_var`.\n\n`OPT_INTEGER(short, long, &int_var, description)`::\n\tIntroduce an option with integer argument.\n\tThe integer is put into `int_var`.\n\n`OPT_DATE(short, long, &int_var, description)`::\n\tIntroduce an option with date argument, see `approxidate()`.\n\tThe timestamp is put into `int_var`.\n\n`OPT_CALLBACK(short, long, &var, arg_str, description, func_ptr)`::\n\tIntroduce an option with argument.\n\tThe argument will be fed into the function given by `func_ptr`\n\tand the result will be put into `var`.\n\tSee 'Option Callbacks' below for a more elaborate description.\n\n`OPT_FILENAME(short, long, &var, description)`::\n\tIntroduce an option with a filename argument.\n\tThe filename will be prefixed by passing the filename along with\n\tthe prefix argument of `parse_options()` to `prefix_filename()`.\n\n`OPT_ARGUMENT(long, description)`::\n\tIntroduce a long-option argument that will be kept in `argv[]`.\n\n`OPT_NUMBER_CALLBACK(&var, description, func_ptr)`::\n\tRecognize numerical options like -123 and feed the integer as\n\tif it was an argument to the function given by `func_ptr`.\n\tThe result will be put into `var`.  There can be only one such\n\toption definition.  It cannot be negated and it takes no\n\targuments.  Short options that happen to be digits take\n\tprecedence over it.\n\n`OPT_COLOR_FLAG(short, long, &int_var, description)`::\n\tIntroduce an option that takes an optional argument that can\n\thave one of three values: \"always\", \"never\", or \"auto\".  If the\n\targument is not given, it defaults to \"always\".  The `--no-` form\n\tworks like `--long=never`; it cannot take an argument.  If\n\t\"always\", set `int_var` to 1; if \"never\", set `int_var` to 0; if\n\t\"auto\", set `int_var` to 1 if stdout is a tty or a pager,\n\t0 otherwise.\n\n\nThe last element of the array must be `OPT_END()`.\n\nIf not stated otherwise, interpret the arguments as follows:\n\n* `short` is a character for the short option\n  (e.g. `{apostrophe}e{apostrophe}` for `-e`, use `0` to omit),\n\n* `long` is a string for the long option\n  (e.g. `\"example\"` for `\\--example`, use `NULL` to omit),\n\n* `int_var` is an integer variable,\n\n* `str_var` is a string variable (`char *`),\n\n* `arg_str` is the string that is shown as argument\n  (e.g. `\"branch\"` will result in `<branch>`).\n  If set to `NULL`, three dots (`...`) will be displayed.\n\n* `description` is a short string to describe the effect of the option.\n  It shall begin with a lower-case letter and a full stop (`.`) shall be\n  omitted at the end.\n\nOption Callbacks\n----------------\n\nThe function must be defined in this form:\n\n\tint func(const struct option *opt, const char *arg, int unset)\n\nThe callback mechanism is as follows:\n\n* Inside `func`, the only interesting member of the structure\n  given by `opt` is the void pointer `opt\\->value`.\n  `\\*opt\\->value` will be the value that is saved into `var`, if you\n  use `OPT_CALLBACK()`.\n  For example, do `*(unsigned long *)opt\\->value = 42;` to get 42\n  into an `unsigned long` variable.\n\n* Return value `0` indicates success and non-zero return\n  value will invoke `usage_with_options()` and, thus, die.\n\n* If the user negates the option, `arg` is `NULL` and `unset` is 1.\n\nSophisticated option parsing\n----------------------------\n\nIf you need, for example, option callbacks with optional arguments\nor without arguments at all, or if you need other special cases,\nthat are not handled by the macros above, you need to specify the\nmembers of the `option` structure manually.\n\nThis is not covered in this document, but well documented\nin `parse-options.h` itself.\n\nExamples\n--------\n\nSee `test-parse-options.c` and\n`builtin-add.c`,\n`builtin-clone.c`,\n`builtin-commit.c`,\n`builtin-fetch.c`,\n`builtin-fsck.c`,\n`builtin-rm.c`\nfor real-world examples.\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00c447c74c7d5df85b0521f2fc90b12470a5950f",
  "sha1_ok": true,
  "size": 9027
}
