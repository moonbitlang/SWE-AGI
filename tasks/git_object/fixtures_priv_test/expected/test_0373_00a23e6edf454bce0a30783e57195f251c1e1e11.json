{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJkaXIuaCIKI2luY2x1ZGUgInN0cmluZy1saXN0LmgiCgpzdGF0aWMgaW50IGluc2lkZV9naXRfZGlyID0gLTE7CnN0YXRpYyBpbnQgaW5zaWRlX3dvcmtfdHJlZSA9IC0xOwoKLyoKICogVGhlIGlucHV0IHBhcmFtZXRlciBtdXN0IGNvbnRhaW4gYW4gYWJzb2x1dGUgcGF0aCwgYW5kIGl0IG11c3QgYWxyZWFkeSBiZQogKiBub3JtYWxpemVkLgogKgogKiBGaW5kIHRoZSBwYXJ0IG9mIGFuIGFic29sdXRlIHBhdGggdGhhdCBsaWVzIGluc2lkZSB0aGUgd29yayB0cmVlIGJ5CiAqIGRlcmVmZXJlbmNpbmcgc3ltbGlua3Mgb3V0c2lkZSB0aGUgd29yayB0cmVlLCBmb3IgZXhhbXBsZToKICogL2RpcjEvcmVwby9kaXIyL2ZpbGUgICAod29yayB0cmVlIGlzIC9kaXIxL3JlcG8pICAgICAgLT4gZGlyMi9maWxlCiAqIC9kaXIvZmlsZSAgICAgICAgICAgICAgKHdvcmsgdHJlZSBpcyAvKSAgICAgICAgICAgICAgIC0+IGRpci9maWxlCiAqIC9kaXIvc3ltbGluazEvc3ltbGluazIgKHN5bWxpbmsxIHBvaW50cyB0byB3b3JrIHRyZWUpIC0+IHN5bWxpbmsyCiAqIC9kaXIvcmVwb2xpbmsvZmlsZSAgICAgKHJlcG9saW5rIHBvaW50cyB0byAvZGlyL3JlcG8pIC0+IGZpbGUKICogL2Rpci9yZXBvICAgICAgICAgICAgICAoZXhhY3RseSBlcXVhbCB0byB3b3JrIHRyZWUpICAgLT4gKGVtcHR5IHN0cmluZykKICovCnN0YXRpYyBpbnQgYWJzcGF0aF9wYXJ0X2luc2lkZV9yZXBvKGNoYXIgKnBhdGgpCnsKCXNpemVfdCBsZW47CglzaXplX3Qgd3RsZW47CgljaGFyICpwYXRoMDsKCWludCBvZmY7Cgljb25zdCBjaGFyICp3b3JrX3RyZWUgPSBnZXRfZ2l0X3dvcmtfdHJlZSgpOwoKCWlmICghd29ya190cmVlKQoJCXJldHVybiAtMTsKCXd0bGVuID0gc3RybGVuKHdvcmtfdHJlZSk7CglsZW4gPSBzdHJsZW4ocGF0aCk7CglvZmYgPSBvZmZzZXRfMXN0X2NvbXBvbmVudChwYXRoKTsKCgkvKiBjaGVjayBpZiB3b3JrIHRyZWUgaXMgYWxyZWFkeSB0aGUgcHJlZml4ICovCglpZiAod3RsZW4gPD0gbGVuICYmICFzdHJuY21wKHBhdGgsIHdvcmtfdHJlZSwgd3RsZW4pKSB7CgkJaWYgKHBhdGhbd3RsZW5dID09ICcvJykgewoJCQltZW1tb3ZlKHBhdGgsIHBhdGggKyB3dGxlbiArIDEsIGxlbiAtIHd0bGVuKTsKCQkJcmV0dXJuIDA7CgkJfSBlbHNlIGlmIChwYXRoW3d0bGVuIC0gMV0gPT0gJy8nIHx8IHBhdGhbd3RsZW5dID09ICdcMCcpIHsKCQkJLyogd29yayB0cmVlIGlzIHRoZSByb290LCBvciB0aGUgd2hvbGUgcGF0aCAqLwoJCQltZW1tb3ZlKHBhdGgsIHBhdGggKyB3dGxlbiwgbGVuIC0gd3RsZW4gKyAxKTsKCQkJcmV0dXJuIDA7CgkJfQoJCS8qIHdvcmsgdHJlZSBtaWdodCBtYXRjaCBiZWdpbm5pbmcgb2YgYSBzeW1saW5rIHRvIHdvcmsgdHJlZSAqLwoJCW9mZiA9IHd0bGVuOwoJfQoJcGF0aDAgPSBwYXRoOwoJcGF0aCArPSBvZmY7CgoJLyogY2hlY2sgZWFjaCAnLyctdGVybWluYXRlZCBsZXZlbCAqLwoJd2hpbGUgKCpwYXRoKSB7CgkJcGF0aCsrOwoJCWlmICgqcGF0aCA9PSAnLycpIHsKCQkJKnBhdGggPSAnXDAnOwoJCQlpZiAoc3RyY21wKHJlYWxfcGF0aChwYXRoMCksIHdvcmtfdHJlZSkgPT0gMCkgewoJCQkJbWVtbW92ZShwYXRoMCwgcGF0aCArIDEsIGxlbiAtIChwYXRoIC0gcGF0aDApKTsKCQkJCXJldHVybiAwOwoJCQl9CgkJCSpwYXRoID0gJy8nOwoJCX0KCX0KCgkvKiBjaGVjayB3aG9sZSBwYXRoICovCglpZiAoc3RyY21wKHJlYWxfcGF0aChwYXRoMCksIHdvcmtfdHJlZSkgPT0gMCkgewoJCSpwYXRoMCA9ICdcMCc7CgkJcmV0dXJuIDA7Cgl9CgoJcmV0dXJuIC0xOwp9CgovKgogKiBOb3JtYWxpemUgInBhdGgiLCBwcmVwZW5kaW5nIHRoZSAicHJlZml4IiBmb3IgcmVsYXRpdmUgcGF0aHMuIElmCiAqIHJlbWFpbmluZ19wcmVmaXggaXMgbm90IE5VTEwsIHJldHVybiB0aGUgYWN0dWFsIHByZWZpeCBzdGlsbAogKiByZW1haW5zIGluIHRoZSBwYXRoLiBGb3IgZXhhbXBsZSwgcHJlZml4ID0gc3ViMS9zdWIyLyBhbmQgcGF0aCBpcwogKgogKiAgZm9vICAgICAgICAgIC0+IHN1YjEvc3ViMi9mb28gIChmdWxsIHByZWZpeCkKICogIC4uL2ZvbyAgICAgICAtPiBzdWIxL2ZvbyAgICAgICAocmVtYWluaW5nIHByZWZpeCBpcyBzdWIxLykKICogIC4uLy4uL2JhciAgICAtPiBiYXIgICAgICAgICAgICAobm8gcmVtYWluaW5nIHByZWZpeCkKICogIC4uLy4uL3N1YjEvc3ViMi9mb28gLT4gc3ViMS9zdWIyL2ZvbyAoYnV0IG5vIHJlbWFpbmluZyBwcmVmaXgpCiAqICBgcHdkYC8uLi9iYXIgLT4gc3ViMS9iYXIgICAgICAgKG5vIHJlbWFpbmluZyBwcmVmaXgpCiAqLwpjaGFyICpwcmVmaXhfcGF0aF9nZW50bHkoY29uc3QgY2hhciAqcHJlZml4LCBpbnQgbGVuLAoJCQkgaW50ICpyZW1haW5pbmdfcHJlZml4LCBjb25zdCBjaGFyICpwYXRoKQp7Cgljb25zdCBjaGFyICpvcmlnID0gcGF0aDsKCWNoYXIgKnNhbml0aXplZDsKCWlmIChpc19hYnNvbHV0ZV9wYXRoKG9yaWcpKSB7CgkJc2FuaXRpemVkID0geG1hbGxvYyhzdHJsZW4ocGF0aCkgKyAxKTsKCQlpZiAocmVtYWluaW5nX3ByZWZpeCkKCQkJKnJlbWFpbmluZ19wcmVmaXggPSAwOwoJCWlmIChub3JtYWxpemVfcGF0aF9jb3B5X2xlbihzYW5pdGl6ZWQsIHBhdGgsIHJlbWFpbmluZ19wcmVmaXgpKSB7CgkJCWZyZWUoc2FuaXRpemVkKTsKCQkJcmV0dXJuIE5VTEw7CgkJfQoJCWlmIChhYnNwYXRoX3BhcnRfaW5zaWRlX3JlcG8oc2FuaXRpemVkKSkgewoJCQlmcmVlKHNhbml0aXplZCk7CgkJCXJldHVybiBOVUxMOwoJCX0KCX0gZWxzZSB7CgkJc2FuaXRpemVkID0geG1hbGxvYyhsZW4gKyBzdHJsZW4ocGF0aCkgKyAxKTsKCQlpZiAobGVuKQoJCQltZW1jcHkoc2FuaXRpemVkLCBwcmVmaXgsIGxlbik7CgkJc3RyY3B5KHNhbml0aXplZCArIGxlbiwgcGF0aCk7CgkJaWYgKHJlbWFpbmluZ19wcmVmaXgpCgkJCSpyZW1haW5pbmdfcHJlZml4ID0gbGVuOwoJCWlmIChub3JtYWxpemVfcGF0aF9jb3B5X2xlbihzYW5pdGl6ZWQsIHNhbml0aXplZCwgcmVtYWluaW5nX3ByZWZpeCkpIHsKCQkJZnJlZShzYW5pdGl6ZWQpOwoJCQlyZXR1cm4gTlVMTDsKCQl9Cgl9CglyZXR1cm4gc2FuaXRpemVkOwp9CgpjaGFyICpwcmVmaXhfcGF0aChjb25zdCBjaGFyICpwcmVmaXgsIGludCBsZW4sIGNvbnN0IGNoYXIgKnBhdGgpCnsKCWNoYXIgKnIgPSBwcmVmaXhfcGF0aF9nZW50bHkocHJlZml4LCBsZW4sIE5VTEwsIHBhdGgpOwoJaWYgKCFyKQoJCWRpZSgiJyVzJyBpcyBvdXRzaWRlIHJlcG9zaXRvcnkiLCBwYXRoKTsKCXJldHVybiByOwp9CgppbnQgcGF0aF9pbnNpZGVfcmVwbyhjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IGNoYXIgKnBhdGgpCnsKCWludCBsZW4gPSBwcmVmaXggPyBzdHJsZW4ocHJlZml4KSA6IDA7CgljaGFyICpyID0gcHJlZml4X3BhdGhfZ2VudGx5KHByZWZpeCwgbGVuLCBOVUxMLCBwYXRoKTsKCWlmIChyKSB7CgkJZnJlZShyKTsKCQlyZXR1cm4gMTsKCX0KCXJldHVybiAwOwp9CgppbnQgY2hlY2tfZmlsZW5hbWUoY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCBjaGFyICphcmcpCnsKCWNvbnN0IGNoYXIgKm5hbWU7CglzdHJ1Y3Qgc3RhdCBzdDsKCglpZiAoc3RhcnRzX3dpdGgoYXJnLCAiOi8iKSkgewoJCWlmIChhcmdbMl0gPT0gJ1wwJykgLyogIjovIiBpcyByb290IGRpciwgYWx3YXlzIGV4aXN0cyAqLwoJCQlyZXR1cm4gMTsKCQluYW1lID0gYXJnICsgMjsKCX0gZWxzZSBpZiAocHJlZml4KQoJCW5hbWUgPSBwcmVmaXhfZmlsZW5hbWUocHJlZml4LCBzdHJsZW4ocHJlZml4KSwgYXJnKTsKCWVsc2UKCQluYW1lID0gYXJnOwoJaWYgKCFsc3RhdChuYW1lLCAmc3QpKQoJCXJldHVybiAxOyAvKiBmaWxlIGV4aXN0cyAqLwoJaWYgKGVycm5vID09IEVOT0VOVCB8fCBlcnJubyA9PSBFTk9URElSKQoJCXJldHVybiAwOyAvKiBmaWxlIGRvZXMgbm90IGV4aXN0ICovCglkaWVfZXJybm8oImZhaWxlZCB0byBzdGF0ICclcyciLCBhcmcpOwp9CgpzdGF0aWMgdm9pZCBOT1JFVFVSTiBkaWVfdmVyaWZ5X2ZpbGVuYW1lKGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJCQkgY29uc3QgY2hhciAqYXJnLAoJCQkJCSBpbnQgZGlhZ25vc2VfbWlzc3BlbHRfcmV2KQp7CglpZiAoIWRpYWdub3NlX21pc3NwZWx0X3JldikKCQlkaWUoIiVzOiBubyBzdWNoIHBhdGggaW4gdGhlIHdvcmtpbmcgdHJlZS5cbiIKCQkgICAgIlVzZSAnZ2l0IDxjb21tYW5kPiAtLSA8cGF0aD4uLi4nIHRvIHNwZWNpZnkgcGF0aHMgdGhhdCBkbyBub3QgZXhpc3QgbG9jYWxseS4iLAoJCSAgICBhcmcpOwoJLyoKCSAqIFNheWluZyAiJyhpY2FzZSlmb28nIGRvZXMgbm90IGV4aXN0IGluIHRoZSBpbmRleCIgd2hlbiB0aGUKCSAqIHVzZXIgZ2F2ZSB1cyAiOihpY2FzZSlmb28iIGlzIGp1c3Qgc3R1cGlkLiAgQSBtYWdpYyBwYXRoc3BlYwoJICogYmVnaW5zIHdpdGggYSBjb2xvbiBhbmQgaXMgZm9sbG93ZWQgYnkgYSBub24tYWxudW07IGRvIG5vdAoJICogbGV0IG1heWJlX2RpZV9vbl9taXNzcGVsdF9vYmplY3RfbmFtZSgpIGV2ZW4gdHJpZ2dlci4KCSAqLwoJaWYgKCEoYXJnWzBdID09ICc6JyAmJiAhaXNhbG51bShhcmdbMV0pKSkKCQltYXliZV9kaWVfb25fbWlzc3BlbHRfb2JqZWN0X25hbWUoYXJnLCBwcmVmaXgpOwoKCS8qIC4uLiBvciBmYWxsIGJhY2sgdGhlIG1vc3QgZ2VuZXJhbCBtZXNzYWdlLiAqLwoJZGllKCJhbWJpZ3VvdXMgYXJndW1lbnQgJyVzJzogdW5rbm93biByZXZpc2lvbiBvciBwYXRoIG5vdCBpbiB0aGUgd29ya2luZyB0cmVlLlxuIgoJICAgICJVc2UgJy0tJyB0byBzZXBhcmF0ZSBwYXRocyBmcm9tIHJldmlzaW9ucywgbGlrZSB0aGlzOlxuIgoJICAgICInZ2l0IDxjb21tYW5kPiBbPHJldmlzaW9uPi4uLl0gLS0gWzxmaWxlPi4uLl0nIiwgYXJnKTsKCn0KCi8qCiAqIFZlcmlmeSBhIGZpbGVuYW1lIHRoYXQgd2UgZ290IGFzIGFuIGFyZ3VtZW50IGZvciBhIHBhdGhzcGVjCiAqIGVudHJ5LiBOb3RlIHRoYXQgYSBmaWxlbmFtZSB0aGF0IGJlZ2lucyB3aXRoICItIiBuZXZlciB2ZXJpZmllcwogKiBhcyB0cnVlLCBiZWNhdXNlIGV2ZW4gaWYgc3VjaCBhIGZpbGVuYW1lIHdlcmUgdG8gZXhpc3QsIHdlIHdhbnQKICogaXQgdG8gYmUgcHJlY2VkZWQgYnkgdGhlICItLSIgbWFya2VyIChvciB3ZSB3YW50IHRoZSB1c2VyIHRvCiAqIHVzZSBhIGZvcm1hdCBsaWtlICIuLy1maWxlbmFtZSIpCiAqCiAqIFRoZSAiZGlhZ25vc2VfbWlzc3BlbHRfcmV2IiBpcyB1c2VkIHRvIHByb3ZpZGUgYSB1c2VyLWZyaWVuZGx5CiAqIGRpYWdub3NpcyB3aGVuIGR5aW5nIHVwb24gZmluZGluZyB0aGF0ICJuYW1lIiBpcyBub3QgYSBwYXRobmFtZS4KICogSWYgc2V0IHRvIDEsIHRoZSBkaWFnbm9zaXMgd2lsbCB0cnkgdG8gZGlhZ25vc2UgIm5hbWUiIGFzIGFuCiAqIGludmFsaWQgb2JqZWN0IG5hbWUgKGUuZy4gSEVBRDpmb28pLiBJZiBzZXQgdG8gMCwgdGhlIGRpYWdub3NpcwogKiB3aWxsIG9ubHkgY29tcGxhaW4gYWJvdXQgYW4gaW5leGlzdGluZyBmaWxlLgogKgogKiBUaGlzIGZ1bmN0aW9uIGlzIHR5cGljYWxseSBjYWxsZWQgdG8gY2hlY2sgdGhhdCBhICJmaWxlIG9yIHJldiIKICogYXJndW1lbnQgaXMgdW5hbWJpZ3VvdXMuIEluIHRoaXMgY2FzZSwgdGhlIGNhbGxlciB3aWxsIHdhbnQKICogZGlhZ25vc2VfbWlzc3BlbHRfcmV2ID09IDEgd2hlbiB2ZXJpZnlpbmcgdGhlIGZpcnN0IG5vbi1yZXYKICogYXJndW1lbnQgKHdoaWNoIGNvdWxkIGhhdmUgYmVlbiBhIHJldmlzaW9uKSwgYW5kCiAqIGRpYWdub3NlX21pc3NwZWx0X3JldiA9PSAwIGZvciB0aGUgbmV4dCBvbmVzIChiZWNhdXNlIHdlIGFscmVhZHkKICogc2F3IGEgZmlsZW5hbWUsIHRoZXJlJ3Mgbm90IGFtYmlndWl0eSBhbnltb3JlKS4KICovCnZvaWQgdmVyaWZ5X2ZpbGVuYW1lKGNvbnN0IGNoYXIgKnByZWZpeCwKCQkgICAgIGNvbnN0IGNoYXIgKmFyZywKCQkgICAgIGludCBkaWFnbm9zZV9taXNzcGVsdF9yZXYpCnsKCWlmICgqYXJnID09ICctJykKCQlkaWUoImJhZCBmbGFnICclcycgdXNlZCBhZnRlciBmaWxlbmFtZSIsIGFyZyk7CglpZiAoY2hlY2tfZmlsZW5hbWUocHJlZml4LCBhcmcpKQoJCXJldHVybjsKCWRpZV92ZXJpZnlfZmlsZW5hbWUocHJlZml4LCBhcmcsIGRpYWdub3NlX21pc3NwZWx0X3Jldik7Cn0KCi8qCiAqIE9wcG9zaXRlIG9mIHRoZSBhYm92ZTogdGhlIGNvbW1hbmQgbGluZSBkaWQgbm90IGhhdmUgLS0gbWFya2VyCiAqIGFuZCB3ZSBwYXJzZWQgdGhlIGFyZyBhcyBhIHJlZm5hbWUuICBJdCBzaG91bGQgbm90IGJlIGludGVycHJldGFibGUKICogYXMgYSBmaWxlbmFtZS4KICovCnZvaWQgdmVyaWZ5X25vbl9maWxlbmFtZShjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IGNoYXIgKmFyZykKewoJaWYgKCFpc19pbnNpZGVfd29ya190cmVlKCkgfHwgaXNfaW5zaWRlX2dpdF9kaXIoKSkKCQlyZXR1cm47CglpZiAoKmFyZyA9PSAnLScpCgkJcmV0dXJuOyAvKiBmbGFnICovCglpZiAoIWNoZWNrX2ZpbGVuYW1lKHByZWZpeCwgYXJnKSkKCQlyZXR1cm47CglkaWUoImFtYmlndW91cyBhcmd1bWVudCAnJXMnOiBib3RoIHJldmlzaW9uIGFuZCBmaWxlbmFtZVxuIgoJICAgICJVc2UgJy0tJyB0byBzZXBhcmF0ZSBwYXRocyBmcm9tIHJldmlzaW9ucywgbGlrZSB0aGlzOlxuIgoJICAgICInZ2l0IDxjb21tYW5kPiBbPHJldmlzaW9uPi4uLl0gLS0gWzxmaWxlPi4uLl0nIiwgYXJnKTsKfQoKc3RhdGljIHZvaWQgZ2V0X2NvbW1vbl9kaXIoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKmdpdGRpcikKewoJc3RydWN0IHN0cmJ1ZiBkYXRhID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIHBhdGggPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKmdpdF9jb21tb25fZGlyID0gZ2V0ZW52KEdJVF9DT01NT05fRElSX0VOVklST05NRU5UKTsKCWlmIChnaXRfY29tbW9uX2RpcikgewoJCXN0cmJ1Zl9hZGRzdHIoc2IsIGdpdF9jb21tb25fZGlyKTsKCQlyZXR1cm47Cgl9CglzdHJidWZfYWRkZigmcGF0aCwgIiVzL2NvbW1vbmRpciIsIGdpdGRpcik7CglpZiAoZmlsZV9leGlzdHMocGF0aC5idWYpKSB7CgkJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJmRhdGEsIHBhdGguYnVmLCAwKSA8PSAwKQoJCQlkaWVfZXJybm8oXygiZmFpbGVkIHRvIHJlYWQgJXMiKSwgcGF0aC5idWYpOwoJCXdoaWxlIChkYXRhLmxlbiAmJiAoZGF0YS5idWZbZGF0YS5sZW4gLSAxXSA9PSAnXG4nIHx8CgkJCQkgICAgZGF0YS5idWZbZGF0YS5sZW4gLSAxXSA9PSAnXHInKSkKCQkJZGF0YS5sZW4tLTsKCQlkYXRhLmJ1ZltkYXRhLmxlbl0gPSAnXDAnOwoJCXN0cmJ1Zl9yZXNldCgmcGF0aCk7CgkJaWYgKCFpc19hYnNvbHV0ZV9wYXRoKGRhdGEuYnVmKSkKCQkJc3RyYnVmX2FkZGYoJnBhdGgsICIlcy8iLCBnaXRkaXIpOwoJCXN0cmJ1Zl9hZGRidWYoJnBhdGgsICZkYXRhKTsKCQlzdHJidWZfYWRkc3RyKHNiLCByZWFsX3BhdGgocGF0aC5idWYpKTsKCX0gZWxzZQoJCXN0cmJ1Zl9hZGRzdHIoc2IsIGdpdGRpcik7CglzdHJidWZfcmVsZWFzZSgmZGF0YSk7CglzdHJidWZfcmVsZWFzZSgmcGF0aCk7Cn0KCi8qCiAqIFRlc3QgaWYgaXQgbG9va3MgbGlrZSB3ZSdyZSBhdCBhIGdpdCBkaXJlY3RvcnkuCiAqIFdlIHdhbnQgdG8gc2VlOgogKgogKiAgLSBlaXRoZXIgYW4gb2JqZWN0cy8gZGlyZWN0b3J5IF9vcl8gdGhlIHByb3BlcgogKiAgICBHSVRfT0JKRUNUX0RJUkVDVE9SWSBlbnZpcm9ubWVudCB2YXJpYWJsZQogKiAgLSBhIHJlZnMvIGRpcmVjdG9yeQogKiAgLSBlaXRoZXIgYSBIRUFEIHN5bWxpbmsgb3IgYSBIRUFEIGZpbGUgdGhhdCBpcyBmb3JtYXR0ZWQgYXMKICogICAgYSBwcm9wZXIgInJlZjoiLCBvciBhIHJlZ3VsYXIgZmlsZSBIRUFEIHRoYXQgaGFzIGEgcHJvcGVybHkKICogICAgZm9ybWF0dGVkIHNoYTEgb2JqZWN0IG5hbWUuCiAqLwppbnQgaXNfZ2l0X2RpcmVjdG9yeShjb25zdCBjaGFyICpzdXNwZWN0KQp7CglzdHJ1Y3Qgc3RyYnVmIHBhdGggPSBTVFJCVUZfSU5JVDsKCWludCByZXQgPSAwOwoJc2l6ZV90IGxlbjsKCgkvKiBDaGVjayB3b3JrdHJlZS1yZWxhdGVkIHNpZ25hdHVyZXMgKi8KCXN0cmJ1Zl9hZGRmKCZwYXRoLCAiJXMvSEVBRCIsIHN1c3BlY3QpOwoJaWYgKHZhbGlkYXRlX2hlYWRyZWYocGF0aC5idWYpKQoJCWdvdG8gZG9uZTsKCglzdHJidWZfcmVzZXQoJnBhdGgpOwoJZ2V0X2NvbW1vbl9kaXIoJnBhdGgsIHN1c3BlY3QpOwoJbGVuID0gcGF0aC5sZW47CgoJLyogQ2hlY2sgbm9uLXdvcmt0cmVlLXJlbGF0ZWQgc2lnbmF0dXJlcyAqLwoJaWYgKGdldGVudihEQl9FTlZJUk9OTUVOVCkpIHsKCQlpZiAoYWNjZXNzKGdldGVudihEQl9FTlZJUk9OTUVOVCksIFhfT0spKQoJCQlnb3RvIGRvbmU7Cgl9CgllbHNlIHsKCQlzdHJidWZfc2V0bGVuKCZwYXRoLCBsZW4pOwoJCXN0cmJ1Zl9hZGRzdHIoJnBhdGgsICIvb2JqZWN0cyIpOwoJCWlmIChhY2Nlc3MocGF0aC5idWYsIFhfT0spKQoJCQlnb3RvIGRvbmU7Cgl9CgoJc3RyYnVmX3NldGxlbigmcGF0aCwgbGVuKTsKCXN0cmJ1Zl9hZGRzdHIoJnBhdGgsICIvcmVmcyIpOwoJaWYgKGFjY2VzcyhwYXRoLmJ1ZiwgWF9PSykpCgkJZ290byBkb25lOwoKCXJldCA9IDE7CmRvbmU6CglzdHJidWZfcmVsZWFzZSgmcGF0aCk7CglyZXR1cm4gcmV0Owp9CgppbnQgaXNfaW5zaWRlX2dpdF9kaXIodm9pZCkKewoJaWYgKGluc2lkZV9naXRfZGlyIDwgMCkKCQlpbnNpZGVfZ2l0X2RpciA9IGlzX2luc2lkZV9kaXIoZ2V0X2dpdF9kaXIoKSk7CglyZXR1cm4gaW5zaWRlX2dpdF9kaXI7Cn0KCmludCBpc19pbnNpZGVfd29ya190cmVlKHZvaWQpCnsKCWlmIChpbnNpZGVfd29ya190cmVlIDwgMCkKCQlpbnNpZGVfd29ya190cmVlID0gaXNfaW5zaWRlX2RpcihnZXRfZ2l0X3dvcmtfdHJlZSgpKTsKCXJldHVybiBpbnNpZGVfd29ya190cmVlOwp9Cgp2b2lkIHNldHVwX3dvcmtfdHJlZSh2b2lkKQp7Cgljb25zdCBjaGFyICp3b3JrX3RyZWUsICpnaXRfZGlyOwoJc3RhdGljIGludCBpbml0aWFsaXplZCA9IDA7CgoJaWYgKGluaXRpYWxpemVkKQoJCXJldHVybjsKCXdvcmtfdHJlZSA9IGdldF9naXRfd29ya190cmVlKCk7CglnaXRfZGlyID0gZ2V0X2dpdF9kaXIoKTsKCWlmICghaXNfYWJzb2x1dGVfcGF0aChnaXRfZGlyKSkKCQlnaXRfZGlyID0gcmVhbF9wYXRoKGdldF9naXRfZGlyKCkpOwoJaWYgKCF3b3JrX3RyZWUgfHwgY2hkaXIod29ya190cmVlKSkKCQlkaWUoIlRoaXMgb3BlcmF0aW9uIG11c3QgYmUgcnVuIGluIGEgd29yayB0cmVlIik7CgoJLyoKCSAqIE1ha2Ugc3VyZSBzdWJzZXF1ZW50IGdpdCBwcm9jZXNzZXMgZmluZCBjb3JyZWN0IHdvcmt0cmVlCgkgKiBpZiAkR0lUX1dPUktfVFJFRSBpcyBzZXQgcmVsYXRpdmUKCSAqLwoJaWYgKGdldGVudihHSVRfV09SS19UUkVFX0VOVklST05NRU5UKSkKCQlzZXRlbnYoR0lUX1dPUktfVFJFRV9FTlZJUk9OTUVOVCwgIi4iLCAxKTsKCglzZXRfZ2l0X2RpcihyZW1vdmVfbGVhZGluZ19wYXRoKGdpdF9kaXIsIHdvcmtfdHJlZSkpOwoJaW5pdGlhbGl6ZWQgPSAxOwp9CgpzdGF0aWMgaW50IGNoZWNrX3JlcG9zaXRvcnlfZm9ybWF0X2dlbnRseShjb25zdCBjaGFyICpnaXRkaXIsIGludCAqbm9uZ2l0X29rKQp7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpyZXBvX2NvbmZpZzsKCWludCByZXQgPSAwOwoKCS8qCgkgKiBnaXRfY29uZmlnKCkgY2FuJ3QgYmUgdXNlZCBoZXJlIGJlY2F1c2UgaXQgY2FsbHMgZ2l0X3BhdGhkdXAoKQoJICogdG8gZ2V0ICRHSVRfQ09ORklHL2NvbmZpZy4gVGhhdCBjYWxsIHdpbGwgbWFrZSBzZXR1cF9naXRfZW52KCkKCSAqIHNldCBnaXRfZGlyIHRvICIuZ2l0Ii4KCSAqCgkgKiBXZSBhcmUgaW4gZ2l0ZGlyIHNldHVwLCBubyBnaXQgZGlyIGhhcyBiZWVuIGZvdW5kIHVzZWFibGUgeWV0LgoJICogVXNlIGEgZ2VudGxlciB2ZXJzaW9uIG9mIGdpdF9jb25maWcoKSB0byBjaGVjayBpZiB0aGlzIHJlcG8KCSAqIGlzIGEgZ29vZCBvbmUuCgkgKi8KCXN0cmJ1Zl9hZGRmKCZzYiwgIiVzL2NvbmZpZyIsIGdpdGRpcik7CglyZXBvX2NvbmZpZyA9IHNiLmJ1ZjsKCWdpdF9jb25maWdfZWFybHkoY2hlY2tfcmVwb3NpdG9yeV9mb3JtYXRfdmVyc2lvbiwgTlVMTCwgcmVwb19jb25maWcpOwoJaWYgKEdJVF9SRVBPX1ZFUlNJT04gPCByZXBvc2l0b3J5X2Zvcm1hdF92ZXJzaW9uKSB7CgkJaWYgKCFub25naXRfb2spCgkJCWRpZSAoIkV4cGVjdGVkIGdpdCByZXBvIHZlcnNpb24gPD0gJWQsIGZvdW5kICVkIiwKCQkJICAgICBHSVRfUkVQT19WRVJTSU9OLCByZXBvc2l0b3J5X2Zvcm1hdF92ZXJzaW9uKTsKCQl3YXJuaW5nKCJFeHBlY3RlZCBnaXQgcmVwbyB2ZXJzaW9uIDw9ICVkLCBmb3VuZCAlZCIsCgkJCUdJVF9SRVBPX1ZFUlNJT04sIHJlcG9zaXRvcnlfZm9ybWF0X3ZlcnNpb24pOwoJCXdhcm5pbmcoIlBsZWFzZSB1cGdyYWRlIEdpdCIpOwoJCSpub25naXRfb2sgPSAtMTsKCQlyZXQgPSAtMTsKCX0KCXN0cmJ1Zl9yZWxlYXNlKCZzYik7CglyZXR1cm4gcmV0Owp9CgovKgogKiBUcnkgdG8gcmVhZCB0aGUgbG9jYXRpb24gb2YgdGhlIGdpdCBkaXJlY3RvcnkgZnJvbSB0aGUgLmdpdCBmaWxlLAogKiByZXR1cm4gcGF0aCB0byBnaXQgZGlyZWN0b3J5IGlmIGZvdW5kLgogKi8KY29uc3QgY2hhciAqcmVhZF9naXRmaWxlKGNvbnN0IGNoYXIgKnBhdGgpCnsKCWNoYXIgKmJ1ZjsKCWNoYXIgKmRpcjsKCWNvbnN0IGNoYXIgKnNsYXNoOwoJc3RydWN0IHN0YXQgc3Q7CglpbnQgZmQ7Cglzc2l6ZV90IGxlbjsKCglpZiAoc3RhdChwYXRoLCAmc3QpKQoJCXJldHVybiBOVUxMOwoJaWYgKCFTX0lTUkVHKHN0LnN0X21vZGUpKQoJCXJldHVybiBOVUxMOwoJZmQgPSBvcGVuKHBhdGgsIE9fUkRPTkxZKTsKCWlmIChmZCA8IDApCgkJZGllX2Vycm5vKCJFcnJvciBvcGVuaW5nICclcyciLCBwYXRoKTsKCWJ1ZiA9IHhtYWxsb2Moc3Quc3Rfc2l6ZSArIDEpOwoJbGVuID0gcmVhZF9pbl9mdWxsKGZkLCBidWYsIHN0LnN0X3NpemUpOwoJY2xvc2UoZmQpOwoJaWYgKGxlbiAhPSBzdC5zdF9zaXplKQoJCWRpZSgiRXJyb3IgcmVhZGluZyAlcyIsIHBhdGgpOwoJYnVmW2xlbl0gPSAnXDAnOwoJaWYgKCFzdGFydHNfd2l0aChidWYsICJnaXRkaXI6ICIpKQoJCWRpZSgiSW52YWxpZCBnaXRmaWxlIGZvcm1hdDogJXMiLCBwYXRoKTsKCXdoaWxlIChidWZbbGVuIC0gMV0gPT0gJ1xuJyB8fCBidWZbbGVuIC0gMV0gPT0gJ1xyJykKCQlsZW4tLTsKCWlmIChsZW4gPCA5KQoJCWRpZSgiTm8gcGF0aCBpbiBnaXRmaWxlOiAlcyIsIHBhdGgpOwoJYnVmW2xlbl0gPSAnXDAnOwoJZGlyID0gYnVmICsgODsKCglpZiAoIWlzX2Fic29sdXRlX3BhdGgoZGlyKSAmJiAoc2xhc2ggPSBzdHJyY2hyKHBhdGgsICcvJykpKSB7CgkJc2l6ZV90IHBhdGhsZW4gPSBzbGFzaCsxIC0gcGF0aDsKCQlzaXplX3QgZGlybGVuID0gcGF0aGxlbiArIGxlbiAtIDg7CgkJZGlyID0geG1hbGxvYyhkaXJsZW4gKyAxKTsKCQlzdHJuY3B5KGRpciwgcGF0aCwgcGF0aGxlbik7CgkJc3RybmNweShkaXIgKyBwYXRobGVuLCBidWYgKyA4LCBsZW4gLSA4KTsKCQlkaXJbZGlybGVuXSA9ICdcMCc7CgkJZnJlZShidWYpOwoJCWJ1ZiA9IGRpcjsKCX0KCglpZiAoIWlzX2dpdF9kaXJlY3RvcnkoZGlyKSkKCQlkaWUoIk5vdCBhIGdpdCByZXBvc2l0b3J5OiAlcyIsIGRpcik7CglwYXRoID0gcmVhbF9wYXRoKGRpcik7CgoJZnJlZShidWYpOwoJcmV0dXJuIHBhdGg7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpzZXR1cF9leHBsaWNpdF9naXRfZGlyKGNvbnN0IGNoYXIgKmdpdGRpcmVudiwKCQkJCQkgIHN0cnVjdCBzdHJidWYgKmN3ZCwKCQkJCQkgIGludCAqbm9uZ2l0X29rKQp7Cgljb25zdCBjaGFyICp3b3JrX3RyZWVfZW52ID0gZ2V0ZW52KEdJVF9XT1JLX1RSRUVfRU5WSVJPTk1FTlQpOwoJY29uc3QgY2hhciAqd29ya3RyZWU7CgljaGFyICpnaXRmaWxlOwoJaW50IG9mZnNldDsKCglpZiAoUEFUSF9NQVggLSA0MCA8IHN0cmxlbihnaXRkaXJlbnYpKQoJCWRpZSgiJyQlcycgdG9vIGJpZyIsIEdJVF9ESVJfRU5WSVJPTk1FTlQpOwoKCWdpdGZpbGUgPSAoY2hhciopcmVhZF9naXRmaWxlKGdpdGRpcmVudik7CglpZiAoZ2l0ZmlsZSkgewoJCWdpdGZpbGUgPSB4c3RyZHVwKGdpdGZpbGUpOwoJCWdpdGRpcmVudiA9IGdpdGZpbGU7Cgl9CgoJaWYgKCFpc19naXRfZGlyZWN0b3J5KGdpdGRpcmVudikpIHsKCQlpZiAobm9uZ2l0X29rKSB7CgkJCSpub25naXRfb2sgPSAxOwoJCQlmcmVlKGdpdGZpbGUpOwoJCQlyZXR1cm4gTlVMTDsKCQl9CgkJZGllKCJOb3QgYSBnaXQgcmVwb3NpdG9yeTogJyVzJyIsIGdpdGRpcmVudik7Cgl9CgoJaWYgKGNoZWNrX3JlcG9zaXRvcnlfZm9ybWF0X2dlbnRseShnaXRkaXJlbnYsIG5vbmdpdF9vaykpIHsKCQlmcmVlKGdpdGZpbGUpOwoJCXJldHVybiBOVUxMOwoJfQoKCS8qICMzLCAjNywgIzExLCAjMTUsICMxOSwgIzIzLCAjMjcsICMzMSAoc2VlIHQxNTEwKSAqLwoJaWYgKHdvcmtfdHJlZV9lbnYpCgkJc2V0X2dpdF93b3JrX3RyZWUod29ya190cmVlX2Vudik7CgllbHNlIGlmIChpc19iYXJlX3JlcG9zaXRvcnlfY2ZnID4gMCkgewoJCWlmIChnaXRfd29ya190cmVlX2NmZykgLyogIzIyLjIsICMzMCAqLwoJCQlkaWUoImNvcmUuYmFyZSBhbmQgY29yZS53b3JrdHJlZSBkbyBub3QgbWFrZSBzZW5zZSIpOwoKCQkvKiAjMTgsICMyNiAqLwoJCXNldF9naXRfZGlyKGdpdGRpcmVudik7CgkJZnJlZShnaXRmaWxlKTsKCQlyZXR1cm4gTlVMTDsKCX0KCWVsc2UgaWYgKGdpdF93b3JrX3RyZWVfY2ZnKSB7IC8qICM2LCAjMTQgKi8KCQlpZiAoaXNfYWJzb2x1dGVfcGF0aChnaXRfd29ya190cmVlX2NmZykpCgkJCXNldF9naXRfd29ya190cmVlKGdpdF93b3JrX3RyZWVfY2ZnKTsKCQllbHNlIHsKCQkJY2hhciAqY29yZV93b3JrdHJlZTsKCQkJaWYgKGNoZGlyKGdpdGRpcmVudikpCgkJCQlkaWVfZXJybm8oIkNvdWxkIG5vdCBjaGRpciB0byAnJXMnIiwgZ2l0ZGlyZW52KTsKCQkJaWYgKGNoZGlyKGdpdF93b3JrX3RyZWVfY2ZnKSkKCQkJCWRpZV9lcnJubygiQ291bGQgbm90IGNoZGlyIHRvICclcyciLCBnaXRfd29ya190cmVlX2NmZyk7CgkJCWNvcmVfd29ya3RyZWUgPSB4Z2V0Y3dkKCk7CgkJCWlmIChjaGRpcihjd2QtPmJ1ZikpCgkJCQlkaWVfZXJybm8oIkNvdWxkIG5vdCBjb21lIGJhY2sgdG8gY3dkIik7CgkJCXNldF9naXRfd29ya190cmVlKGNvcmVfd29ya3RyZWUpOwoJCQlmcmVlKGNvcmVfd29ya3RyZWUpOwoJCX0KCX0KCWVsc2UgaWYgKCFnaXRfZW52X2Jvb2woR0lUX0lNUExJQ0lUX1dPUktfVFJFRV9FTlZJUk9OTUVOVCwgMSkpIHsKCQkvKiAjMTZkICovCgkJc2V0X2dpdF9kaXIoZ2l0ZGlyZW52KTsKCQlmcmVlKGdpdGZpbGUpOwoJCXJldHVybiBOVUxMOwoJfQoJZWxzZSAvKiAjMiwgIzEwICovCgkJc2V0X2dpdF93b3JrX3RyZWUoIi4iKTsKCgkvKiBzZXRfZ2l0X3dvcmtfdHJlZSgpIG11c3QgaGF2ZSBiZWVuIGNhbGxlZCBieSBub3cgKi8KCXdvcmt0cmVlID0gZ2V0X2dpdF93b3JrX3RyZWUoKTsKCgkvKiBib3RoIGdldF9naXRfd29ya190cmVlKCkgYW5kIGN3ZCBhcmUgYWxyZWFkeSBub3JtYWxpemVkICovCglpZiAoIXN0cmNtcChjd2QtPmJ1Ziwgd29ya3RyZWUpKSB7IC8qIGN3ZCA9PSB3b3JrdHJlZSAqLwoJCXNldF9naXRfZGlyKGdpdGRpcmVudik7CgkJZnJlZShnaXRmaWxlKTsKCQlyZXR1cm4gTlVMTDsKCX0KCglvZmZzZXQgPSBkaXJfaW5zaWRlX29mKGN3ZC0+YnVmLCB3b3JrdHJlZSk7CglpZiAob2Zmc2V0ID49IDApIHsJLyogY3dkIGluc2lkZSB3b3JrdHJlZT8gKi8KCQlzZXRfZ2l0X2RpcihyZWFsX3BhdGgoZ2l0ZGlyZW52KSk7CgkJaWYgKGNoZGlyKHdvcmt0cmVlKSkKCQkJZGllX2Vycm5vKCJDb3VsZCBub3QgY2hkaXIgdG8gJyVzJyIsIHdvcmt0cmVlKTsKCQlzdHJidWZfYWRkY2goY3dkLCAnLycpOwoJCWZyZWUoZ2l0ZmlsZSk7CgkJcmV0dXJuIGN3ZC0+YnVmICsgb2Zmc2V0OwoJfQoKCS8qIGN3ZCBvdXRzaWRlIHdvcmt0cmVlICovCglzZXRfZ2l0X2RpcihnaXRkaXJlbnYpOwoJZnJlZShnaXRmaWxlKTsKCXJldHVybiBOVUxMOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqc2V0dXBfZGlzY292ZXJlZF9naXRfZGlyKGNvbnN0IGNoYXIgKmdpdGRpciwKCQkJCQkgICAgc3RydWN0IHN0cmJ1ZiAqY3dkLCBpbnQgb2Zmc2V0LAoJCQkJCSAgICBpbnQgKm5vbmdpdF9vaykKewoJaWYgKGNoZWNrX3JlcG9zaXRvcnlfZm9ybWF0X2dlbnRseShnaXRkaXIsIG5vbmdpdF9vaykpCgkJcmV0dXJuIE5VTEw7CgoJLyogLS13b3JrLXRyZWUgaXMgc2V0IHdpdGhvdXQgLS1naXQtZGlyOyB1c2UgZGlzY292ZXJlZCBvbmUgKi8KCWlmIChnZXRlbnYoR0lUX1dPUktfVFJFRV9FTlZJUk9OTUVOVCkgfHwgZ2l0X3dvcmtfdHJlZV9jZmcpIHsKCQlpZiAob2Zmc2V0ICE9IGN3ZC0+bGVuICYmICFpc19hYnNvbHV0ZV9wYXRoKGdpdGRpcikpCgkJCWdpdGRpciA9IHhzdHJkdXAocmVhbF9wYXRoKGdpdGRpcikpOwoJCWlmIChjaGRpcihjd2QtPmJ1ZikpCgkJCWRpZV9lcnJubygiQ291bGQgbm90IGNvbWUgYmFjayB0byBjd2QiKTsKCQlyZXR1cm4gc2V0dXBfZXhwbGljaXRfZ2l0X2RpcihnaXRkaXIsIGN3ZCwgbm9uZ2l0X29rKTsKCX0KCgkvKiAjMTYuMiwgIzE3LjIsICMyMC4yLCAjMjEuMiwgIzI0LCAjMjUsICMyOCwgIzI5IChzZWUgdDE1MTApICovCglpZiAoaXNfYmFyZV9yZXBvc2l0b3J5X2NmZyA+IDApIHsKCQlzZXRfZ2l0X2RpcihvZmZzZXQgPT0gY3dkLT5sZW4gPyBnaXRkaXIgOiByZWFsX3BhdGgoZ2l0ZGlyKSk7CgkJaWYgKGNoZGlyKGN3ZC0+YnVmKSkKCQkJZGllX2Vycm5vKCJDb3VsZCBub3QgY29tZSBiYWNrIHRvIGN3ZCIpOwoJCXJldHVybiBOVUxMOwoJfQoKCS8qICMwLCAjMSwgIzUsICM4LCAjOSwgIzEyLCAjMTMgKi8KCXNldF9naXRfd29ya190cmVlKCIuIik7CglpZiAoc3RyY21wKGdpdGRpciwgREVGQVVMVF9HSVRfRElSX0VOVklST05NRU5UKSkKCQlzZXRfZ2l0X2RpcihnaXRkaXIpOwoJaW5zaWRlX2dpdF9kaXIgPSAwOwoJaW5zaWRlX3dvcmtfdHJlZSA9IDE7CglpZiAob2Zmc2V0ID09IGN3ZC0+bGVuKQoJCXJldHVybiBOVUxMOwoKCS8qIE1ha2UgIm9mZnNldCIgcG9pbnQgdG8gcGFzdCB0aGUgJy8nLCBhbmQgYWRkIGEgJy8nIGF0IHRoZSBlbmQgKi8KCW9mZnNldCsrOwoJc3RyYnVmX2FkZGNoKGN3ZCwgJy8nKTsKCXJldHVybiBjd2QtPmJ1ZiArIG9mZnNldDsKfQoKLyogIzE2LjEsICMxNy4xLCAjMjAuMSwgIzIxLjEsICMyMi4xIChzZWUgdDE1MTApICovCnN0YXRpYyBjb25zdCBjaGFyICpzZXR1cF9iYXJlX2dpdF9kaXIoc3RydWN0IHN0cmJ1ZiAqY3dkLCBpbnQgb2Zmc2V0LAoJCQkJICAgICAgaW50ICpub25naXRfb2spCnsKCWludCByb290X2xlbjsKCglpZiAoY2hlY2tfcmVwb3NpdG9yeV9mb3JtYXRfZ2VudGx5KCIuIiwgbm9uZ2l0X29rKSkKCQlyZXR1cm4gTlVMTDsKCglzZXRlbnYoR0lUX0lNUExJQ0lUX1dPUktfVFJFRV9FTlZJUk9OTUVOVCwgIjAiLCAxKTsKCgkvKiAtLXdvcmstdHJlZSBpcyBzZXQgd2l0aG91dCAtLWdpdC1kaXI7IHVzZSBkaXNjb3ZlcmVkIG9uZSAqLwoJaWYgKGdldGVudihHSVRfV09SS19UUkVFX0VOVklST05NRU5UKSB8fCBnaXRfd29ya190cmVlX2NmZykgewoJCWNvbnN0IGNoYXIgKmdpdGRpcjsKCgkJZ2l0ZGlyID0gb2Zmc2V0ID09IGN3ZC0+bGVuID8gIi4iIDogeG1lbWR1cHooY3dkLT5idWYsIG9mZnNldCk7CgkJaWYgKGNoZGlyKGN3ZC0+YnVmKSkKCQkJZGllX2Vycm5vKCJDb3VsZCBub3QgY29tZSBiYWNrIHRvIGN3ZCIpOwoJCXJldHVybiBzZXR1cF9leHBsaWNpdF9naXRfZGlyKGdpdGRpciwgY3dkLCBub25naXRfb2spOwoJfQoKCWluc2lkZV9naXRfZGlyID0gMTsKCWluc2lkZV93b3JrX3RyZWUgPSAwOwoJaWYgKG9mZnNldCAhPSBjd2QtPmxlbikgewoJCWlmIChjaGRpcihjd2QtPmJ1ZikpCgkJCWRpZV9lcnJubygiQ2Fubm90IGNvbWUgYmFjayB0byBjd2QiKTsKCQlyb290X2xlbiA9IG9mZnNldF8xc3RfY29tcG9uZW50KGN3ZC0+YnVmKTsKCQlzdHJidWZfc2V0bGVuKGN3ZCwgb2Zmc2V0ID4gcm9vdF9sZW4gPyBvZmZzZXQgOiByb290X2xlbik7CgkJc2V0X2dpdF9kaXIoY3dkLT5idWYpOwoJfQoJZWxzZQoJCXNldF9naXRfZGlyKCIuIik7CglyZXR1cm4gTlVMTDsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnNldHVwX25vbmdpdChjb25zdCBjaGFyICpjd2QsIGludCAqbm9uZ2l0X29rKQp7CglpZiAoIW5vbmdpdF9vaykKCQlkaWUoIk5vdCBhIGdpdCByZXBvc2l0b3J5IChvciBhbnkgb2YgdGhlIHBhcmVudCBkaXJlY3Rvcmllcyk6ICVzIiwgREVGQVVMVF9HSVRfRElSX0VOVklST05NRU5UKTsKCWlmIChjaGRpcihjd2QpKQoJCWRpZV9lcnJubygiQ2Fubm90IGNvbWUgYmFjayB0byBjd2QiKTsKCSpub25naXRfb2sgPSAxOwoJcmV0dXJuIE5VTEw7Cn0KCnN0YXRpYyBkZXZfdCBnZXRfZGV2aWNlX29yX2RpZShjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFyICpwcmVmaXgsIGludCBwcmVmaXhfbGVuKQp7CglzdHJ1Y3Qgc3RhdCBidWY7CglpZiAoc3RhdChwYXRoLCAmYnVmKSkgewoJCWRpZV9lcnJubygiZmFpbGVkIHRvIHN0YXQgJyUqcyVzJXMnIiwKCQkJCXByZWZpeF9sZW4sCgkJCQlwcmVmaXggPyBwcmVmaXggOiAiIiwKCQkJCXByZWZpeCA/ICIvIiA6ICIiLCBwYXRoKTsKCX0KCXJldHVybiBidWYuc3RfZGV2Owp9CgovKgogKiBBICJzdHJpbmdfbGlzdF9lYWNoX2Z1bmNfdCIgZnVuY3Rpb24gdGhhdCBjYW5vbmljYWxpemVzIGFuIGVudHJ5CiAqIGZyb20gR0lUX0NFSUxJTkdfRElSRUNUT1JJRVMgdXNpbmcgcmVhbF9wYXRoX2lmX3ZhbGlkKCksIG9yCiAqIGRpc2NhcmRzIGl0IGlmIHVudXNhYmxlLiAgVGhlIHByZXNlbmNlIG9mIGFuIGVtcHR5IGVudHJ5IGluCiAqIEdJVF9DRUlMSU5HX0RJUkVDVE9SSUVTIHR1cm5zIG9mZiBjYW5vbmljYWxpemF0aW9uIGZvciBhbGwKICogc3Vic2VxdWVudCBlbnRyaWVzLgogKi8Kc3RhdGljIGludCBjYW5vbmljYWxpemVfY2VpbGluZ19lbnRyeShzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbSwKCQkJCSAgICAgIHZvaWQgKmNiX2RhdGEpCnsKCWludCAqZW1wdHlfZW50cnlfZm91bmQgPSBjYl9kYXRhOwoJY2hhciAqY2VpbCA9IGl0ZW0tPnN0cmluZzsKCglpZiAoISpjZWlsKSB7CgkJKmVtcHR5X2VudHJ5X2ZvdW5kID0gMTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIWlzX2Fic29sdXRlX3BhdGgoY2VpbCkpIHsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoKmVtcHR5X2VudHJ5X2ZvdW5kKSB7CgkJLyogS2VlcCBlbnRyeSBidXQgZG8gbm90IGNhbm9uaWNhbGl6ZSBpdCAqLwoJCXJldHVybiAxOwoJfSBlbHNlIHsKCQljb25zdCBjaGFyICpyZWFsX3BhdGggPSByZWFsX3BhdGhfaWZfdmFsaWQoY2VpbCk7CgkJaWYgKCFyZWFsX3BhdGgpCgkJCXJldHVybiAwOwoJCWZyZWUoaXRlbS0+c3RyaW5nKTsKCQlpdGVtLT5zdHJpbmcgPSB4c3RyZHVwKHJlYWxfcGF0aCk7CgkJcmV0dXJuIDE7Cgl9Cn0KCi8qCiAqIFdlIGNhbm5vdCBkZWNpZGUgaW4gdGhpcyBmdW5jdGlvbiB3aGV0aGVyIHdlIGFyZSBpbiB0aGUgd29yayB0cmVlIG9yCiAqIG5vdCwgc2luY2UgdGhlIGNvbmZpZyBjYW4gb25seSBiZSByZWFkIF9hZnRlcl8gdGhpcyBmdW5jdGlvbiB3YXMgY2FsbGVkLgogKi8Kc3RhdGljIGNvbnN0IGNoYXIgKnNldHVwX2dpdF9kaXJlY3RvcnlfZ2VudGx5XzEoaW50ICpub25naXRfb2spCnsKCWNvbnN0IGNoYXIgKmVudl9jZWlsaW5nX2RpcnMgPSBnZXRlbnYoQ0VJTElOR19ESVJFQ1RPUklFU19FTlZJUk9OTUVOVCk7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgY2VpbGluZ19kaXJzID0gU1RSSU5HX0xJU1RfSU5JVF9EVVA7CglzdGF0aWMgc3RydWN0IHN0cmJ1ZiBjd2QgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKmdpdGRpcmVudiwgKnJldDsKCWNoYXIgKmdpdGZpbGU7CglpbnQgb2Zmc2V0LCBvZmZzZXRfcGFyZW50LCBjZWlsX29mZnNldCA9IC0xOwoJZGV2X3QgY3VycmVudF9kZXZpY2UgPSAwOwoJaW50IG9uZV9maWxlc3lzdGVtID0gMTsKCgkvKgoJICogV2UgbWF5IGhhdmUgcmVhZCBhbiBpbmNvbXBsZXRlIGNvbmZpZ3VyYXRpb24gYmVmb3JlCgkgKiBzZXR0aW5nLXVwIHRoZSBnaXQgZGlyZWN0b3J5LiBJZiBzbywgY2xlYXIgdGhlIGNhY2hlIHNvCgkgKiB0aGF0IHRoZSBuZXh0IHF1ZXJpZXMgdG8gdGhlIGNvbmZpZ3VyYXRpb24gcmVsb2FkIGNvbXBsZXRlCgkgKiBjb25maWd1cmF0aW9uIChpbmNsdWRpbmcgdGhlIHBlci1yZXBvIGNvbmZpZyBmaWxlIHRoYXQgd2UKCSAqIGlnbm9yZWQgcHJldmlvdXNseSkuCgkgKi8KCWdpdF9jb25maWdfY2xlYXIoKTsKCgkvKgoJICogTGV0J3MgYXNzdW1lIHRoYXQgd2UgYXJlIGluIGEgZ2l0IHJlcG9zaXRvcnkuCgkgKiBJZiBpdCB0dXJucyBvdXQgbGF0ZXIgdGhhdCB3ZSBhcmUgc29tZXdoZXJlIGVsc2UsIHRoZSB2YWx1ZSB3aWxsIGJlCgkgKiB1cGRhdGVkIGFjY29yZGluZ2x5LgoJICovCglpZiAobm9uZ2l0X29rKQoJCSpub25naXRfb2sgPSAwOwoKCWlmIChzdHJidWZfZ2V0Y3dkKCZjd2QpKQoJCWRpZV9lcnJubygiVW5hYmxlIHRvIHJlYWQgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSIpOwoJb2Zmc2V0ID0gY3dkLmxlbjsKCgkvKgoJICogSWYgR0lUX0RJUiBpcyBzZXQgZXhwbGljaXRseSwgd2UncmUgbm90IGdvaW5nCgkgKiB0byBkbyBhbnkgZGlzY292ZXJ5LCBidXQgd2Ugc3RpbGwgZG8gcmVwb3NpdG9yeQoJICogdmFsaWRhdGlvbi4KCSAqLwoJZ2l0ZGlyZW52ID0gZ2V0ZW52KEdJVF9ESVJfRU5WSVJPTk1FTlQpOwoJaWYgKGdpdGRpcmVudikKCQlyZXR1cm4gc2V0dXBfZXhwbGljaXRfZ2l0X2RpcihnaXRkaXJlbnYsICZjd2QsIG5vbmdpdF9vayk7CgoJaWYgKGVudl9jZWlsaW5nX2RpcnMpIHsKCQlpbnQgZW1wdHlfZW50cnlfZm91bmQgPSAwOwoKCQlzdHJpbmdfbGlzdF9zcGxpdCgmY2VpbGluZ19kaXJzLCBlbnZfY2VpbGluZ19kaXJzLCBQQVRIX1NFUCwgLTEpOwoJCWZpbHRlcl9zdHJpbmdfbGlzdCgmY2VpbGluZ19kaXJzLCAwLAoJCQkJICAgY2Fub25pY2FsaXplX2NlaWxpbmdfZW50cnksICZlbXB0eV9lbnRyeV9mb3VuZCk7CgkJY2VpbF9vZmZzZXQgPSBsb25nZXN0X2FuY2VzdG9yX2xlbmd0aChjd2QuYnVmLCAmY2VpbGluZ19kaXJzKTsKCQlzdHJpbmdfbGlzdF9jbGVhcigmY2VpbGluZ19kaXJzLCAwKTsKCX0KCglpZiAoY2VpbF9vZmZzZXQgPCAwICYmIGhhc19kb3NfZHJpdmVfcHJlZml4KGN3ZC5idWYpKQoJCWNlaWxfb2Zmc2V0ID0gMTsKCgkvKgoJICogVGVzdCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyIChyZWxhdGl2ZSB0byB0aGUgY3dkKToKCSAqIC0gLmdpdCAoZmlsZSBjb250YWluaW5nICJnaXRkaXI6IDxwYXRoPiIpCgkgKiAtIC5naXQvCgkgKiAtIC4vIChiYXJlKQoJICogLSAuLi8uZ2l0CgkgKiAtIC4uLy5naXQvCgkgKiAtIC4uLyAoYmFyZSkKCSAqIC0gLi4vLi4vLmdpdC8KCSAqICAgZXRjLgoJICovCglvbmVfZmlsZXN5c3RlbSA9ICFnaXRfZW52X2Jvb2woIkdJVF9ESVNDT1ZFUllfQUNST1NTX0ZJTEVTWVNURU0iLCAwKTsKCWlmIChvbmVfZmlsZXN5c3RlbSkKCQljdXJyZW50X2RldmljZSA9IGdldF9kZXZpY2Vfb3JfZGllKCIuIiwgTlVMTCwgMCk7Cglmb3IgKDs7KSB7CgkJZ2l0ZmlsZSA9IChjaGFyKilyZWFkX2dpdGZpbGUoREVGQVVMVF9HSVRfRElSX0VOVklST05NRU5UKTsKCQlpZiAoZ2l0ZmlsZSkKCQkJZ2l0ZGlyZW52ID0gZ2l0ZmlsZSA9IHhzdHJkdXAoZ2l0ZmlsZSk7CgkJZWxzZSB7CgkJCWlmIChpc19naXRfZGlyZWN0b3J5KERFRkFVTFRfR0lUX0RJUl9FTlZJUk9OTUVOVCkpCgkJCQlnaXRkaXJlbnYgPSBERUZBVUxUX0dJVF9ESVJfRU5WSVJPTk1FTlQ7CgkJfQoKCQlpZiAoZ2l0ZGlyZW52KSB7CgkJCXJldCA9IHNldHVwX2Rpc2NvdmVyZWRfZ2l0X2RpcihnaXRkaXJlbnYsCgkJCQkJCSAgICAgICAmY3dkLCBvZmZzZXQsCgkJCQkJCSAgICAgICBub25naXRfb2spOwoJCQlmcmVlKGdpdGZpbGUpOwoJCQlyZXR1cm4gcmV0OwoJCX0KCQlmcmVlKGdpdGZpbGUpOwoKCQlpZiAoaXNfZ2l0X2RpcmVjdG9yeSgiLiIpKQoJCQlyZXR1cm4gc2V0dXBfYmFyZV9naXRfZGlyKCZjd2QsIG9mZnNldCwgbm9uZ2l0X29rKTsKCgkJb2Zmc2V0X3BhcmVudCA9IG9mZnNldDsKCQl3aGlsZSAoLS1vZmZzZXRfcGFyZW50ID4gY2VpbF9vZmZzZXQgJiYgY3dkLmJ1ZltvZmZzZXRfcGFyZW50XSAhPSAnLycpOwoJCWlmIChvZmZzZXRfcGFyZW50IDw9IGNlaWxfb2Zmc2V0KQoJCQlyZXR1cm4gc2V0dXBfbm9uZ2l0KGN3ZC5idWYsIG5vbmdpdF9vayk7CgkJaWYgKG9uZV9maWxlc3lzdGVtKSB7CgkJCWRldl90IHBhcmVudF9kZXZpY2UgPSBnZXRfZGV2aWNlX29yX2RpZSgiLi4iLCBjd2QuYnVmLAoJCQkJCQkJCW9mZnNldCk7CgkJCWlmIChwYXJlbnRfZGV2aWNlICE9IGN1cnJlbnRfZGV2aWNlKSB7CgkJCQlpZiAobm9uZ2l0X29rKSB7CgkJCQkJaWYgKGNoZGlyKGN3ZC5idWYpKQoJCQkJCQlkaWVfZXJybm8oIkNhbm5vdCBjb21lIGJhY2sgdG8gY3dkIik7CgkJCQkJKm5vbmdpdF9vayA9IDE7CgkJCQkJcmV0dXJuIE5VTEw7CgkJCQl9CgkJCQlzdHJidWZfc2V0bGVuKCZjd2QsIG9mZnNldCk7CgkJCQlkaWUoIk5vdCBhIGdpdCByZXBvc2l0b3J5IChvciBhbnkgcGFyZW50IHVwIHRvIG1vdW50IHBvaW50ICVzKVxuIgoJCQkJIlN0b3BwaW5nIGF0IGZpbGVzeXN0ZW0gYm91bmRhcnkgKEdJVF9ESVNDT1ZFUllfQUNST1NTX0ZJTEVTWVNURU0gbm90IHNldCkuIiwKCQkJCSAgICBjd2QuYnVmKTsKCQkJfQoJCX0KCQlpZiAoY2hkaXIoIi4uIikpIHsKCQkJc3RyYnVmX3NldGxlbigmY3dkLCBvZmZzZXQpOwoJCQlkaWVfZXJybm8oIkNhbm5vdCBjaGFuZ2UgdG8gJyVzLy4uJyIsIGN3ZC5idWYpOwoJCX0KCQlvZmZzZXQgPSBvZmZzZXRfcGFyZW50OwoJfQp9Cgpjb25zdCBjaGFyICpzZXR1cF9naXRfZGlyZWN0b3J5X2dlbnRseShpbnQgKm5vbmdpdF9vaykKewoJY29uc3QgY2hhciAqcHJlZml4OwoKCXByZWZpeCA9IHNldHVwX2dpdF9kaXJlY3RvcnlfZ2VudGx5XzEobm9uZ2l0X29rKTsKCWlmIChwcmVmaXgpCgkJc2V0ZW52KEdJVF9QUkVGSVhfRU5WSVJPTk1FTlQsIHByZWZpeCwgMSk7CgllbHNlCgkJc2V0ZW52KEdJVF9QUkVGSVhfRU5WSVJPTk1FTlQsICIiLCAxKTsKCglpZiAoc3RhcnR1cF9pbmZvKSB7CgkJc3RhcnR1cF9pbmZvLT5oYXZlX3JlcG9zaXRvcnkgPSAhbm9uZ2l0X29rIHx8ICEqbm9uZ2l0X29rOwoJCXN0YXJ0dXBfaW5mby0+cHJlZml4ID0gcHJlZml4OwoJfQoJcmV0dXJuIHByZWZpeDsKfQoKaW50IGdpdF9jb25maWdfcGVybShjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlKQp7CglpbnQgaTsKCWNoYXIgKmVuZHB0cjsKCglpZiAodmFsdWUgPT0gTlVMTCkKCQlyZXR1cm4gUEVSTV9HUk9VUDsKCglpZiAoIXN0cmNtcCh2YWx1ZSwgInVtYXNrIikpCgkJcmV0dXJuIFBFUk1fVU1BU0s7CglpZiAoIXN0cmNtcCh2YWx1ZSwgImdyb3VwIikpCgkJcmV0dXJuIFBFUk1fR1JPVVA7CglpZiAoIXN0cmNtcCh2YWx1ZSwgImFsbCIpIHx8CgkgICAgIXN0cmNtcCh2YWx1ZSwgIndvcmxkIikgfHwKCSAgICAhc3RyY21wKHZhbHVlLCAiZXZlcnlib2R5IikpCgkJcmV0dXJuIFBFUk1fRVZFUllCT0RZOwoKCS8qIFBhcnNlIG9jdGFsIG51bWJlcnMgKi8KCWkgPSBzdHJ0b2wodmFsdWUsICZlbmRwdHIsIDgpOwoKCS8qIElmIG5vdCBhbiBvY3RhbCBudW1iZXIsIG1heWJlIHRydWUvZmFsc2U/ICovCglpZiAoKmVuZHB0ciAhPSAwKQoJCXJldHVybiBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSkgPyBQRVJNX0dST1VQIDogUEVSTV9VTUFTSzsKCgkvKgoJICogVHJlYXQgdmFsdWVzIDAsIDEgYW5kIDIgYXMgY29tcGF0aWJpbGl0eSBjYXNlcywgb3RoZXJ3aXNlIGl0IGlzCgkgKiBhIGNobW9kIHZhbHVlIHRvIHJlc3RyaWN0IHRvLgoJICovCglzd2l0Y2ggKGkpIHsKCWNhc2UgUEVSTV9VTUFTSzogICAgICAgICAgICAgICAvKiAwICovCgkJcmV0dXJuIFBFUk1fVU1BU0s7CgljYXNlIE9MRF9QRVJNX0dST1VQOiAgICAgICAgICAgLyogMSAqLwoJCXJldHVybiBQRVJNX0dST1VQOwoJY2FzZSBPTERfUEVSTV9FVkVSWUJPRFk6ICAgICAgIC8qIDIgKi8KCQlyZXR1cm4gUEVSTV9FVkVSWUJPRFk7Cgl9CgoJLyogQSBmaWxlbW9kZSB2YWx1ZSB3YXMgZ2l2ZW46IDB4eHggKi8KCglpZiAoKGkgJiAwNjAwKSAhPSAwNjAwKQoJCWRpZSgiUHJvYmxlbSB3aXRoIGNvcmUuc2hhcmVkUmVwb3NpdG9yeSBmaWxlbW9kZSB2YWx1ZSAiCgkJICAgICIoMCUuM28pLlxuVGhlIG93bmVyIG9mIGZpbGVzIG11c3QgYWx3YXlzIGhhdmUgIgoJCSAgICAicmVhZCBhbmQgd3JpdGUgcGVybWlzc2lvbnMuIiwgaSk7CgoJLyoKCSAqIE1hc2sgZmlsZW1vZGUgdmFsdWUuIE90aGVycyBjYW4gbm90IGdldCB3cml0ZSBwZXJtaXNzaW9uLgoJICogeCBmbGFncyBmb3IgZGlyZWN0b3JpZXMgYXJlIGhhbmRsZWQgc2VwYXJhdGVseS4KCSAqLwoJcmV0dXJuIC0oaSAmIDA2NjYpOwp9CgppbnQgY2hlY2tfcmVwb3NpdG9yeV9mb3JtYXRfdmVyc2lvbihjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlLCB2b2lkICpjYikKewoJaWYgKHN0cmNtcCh2YXIsICJjb3JlLnJlcG9zaXRvcnlmb3JtYXR2ZXJzaW9uIikgPT0gMCkKCQlyZXBvc2l0b3J5X2Zvcm1hdF92ZXJzaW9uID0gZ2l0X2NvbmZpZ19pbnQodmFyLCB2YWx1ZSk7CgllbHNlIGlmIChzdHJjbXAodmFyLCAiY29yZS5zaGFyZWRyZXBvc2l0b3J5IikgPT0gMCkKCQlzaGFyZWRfcmVwb3NpdG9yeSA9IGdpdF9jb25maWdfcGVybSh2YXIsIHZhbHVlKTsKCWVsc2UgaWYgKHN0cmNtcCh2YXIsICJjb3JlLmJhcmUiKSA9PSAwKSB7CgkJaXNfYmFyZV9yZXBvc2l0b3J5X2NmZyA9IGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKTsKCQlpZiAoaXNfYmFyZV9yZXBvc2l0b3J5X2NmZyA9PSAxKQoJCQlpbnNpZGVfd29ya190cmVlID0gLTE7Cgl9IGVsc2UgaWYgKHN0cmNtcCh2YXIsICJjb3JlLndvcmt0cmVlIikgPT0gMCkgewoJCWlmICghdmFsdWUpCgkJCXJldHVybiBjb25maWdfZXJyb3Jfbm9uYm9vbCh2YXIpOwoJCWZyZWUoZ2l0X3dvcmtfdHJlZV9jZmcpOwoJCWdpdF93b3JrX3RyZWVfY2ZnID0geHN0cmR1cCh2YWx1ZSk7CgkJaW5zaWRlX3dvcmtfdHJlZSA9IC0xOwoJfQoJcmV0dXJuIDA7Cn0KCmludCBjaGVja19yZXBvc2l0b3J5X2Zvcm1hdCh2b2lkKQp7CglyZXR1cm4gY2hlY2tfcmVwb3NpdG9yeV9mb3JtYXRfZ2VudGx5KGdldF9naXRfZGlyKCksIE5VTEwpOwp9CgovKgogKiBSZXR1cm5zIHRoZSAicHJlZml4IiwgYSBwYXRoIHRvIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5CiAqIHJlbGF0aXZlIHRvIHRoZSB3b3JrIHRyZWUgcm9vdCwgb3IgTlVMTCwgaWYgdGhlIGN1cnJlbnQgd29ya2luZwogKiBkaXJlY3RvcnkgaXMgbm90IGEgc3RyaWN0IHN1YmRpcmVjdG9yeSBvZiB0aGUgd29yayB0cmVlIHJvb3QuIFRoZQogKiBwcmVmaXggYWx3YXlzIGVuZHMgd2l0aCBhICcvJyBjaGFyYWN0ZXIuCiAqLwpjb25zdCBjaGFyICpzZXR1cF9naXRfZGlyZWN0b3J5KHZvaWQpCnsKCXJldHVybiBzZXR1cF9naXRfZGlyZWN0b3J5X2dlbnRseShOVUxMKTsKfQoKY29uc3QgY2hhciAqcmVzb2x2ZV9naXRkaXIoY29uc3QgY2hhciAqc3VzcGVjdCkKewoJaWYgKGlzX2dpdF9kaXJlY3Rvcnkoc3VzcGVjdCkpCgkJcmV0dXJuIHN1c3BlY3Q7CglyZXR1cm4gcmVhZF9naXRmaWxlKHN1c3BlY3QpOwp9CgovKiBpZiBhbnkgc3RhbmRhcmQgZmlsZSBkZXNjcmlwdG9yIGlzIG1pc3Npbmcgb3BlbiBpdCB0byAvZGV2L251bGwgKi8Kdm9pZCBzYW5pdGl6ZV9zdGRmZHModm9pZCkKewoJaW50IGZkID0gb3BlbigiL2Rldi9udWxsIiwgT19SRFdSLCAwKTsKCXdoaWxlIChmZCAhPSAtMSAmJiBmZCA8IDIpCgkJZmQgPSBkdXAoZmQpOwoJaWYgKGZkID09IC0xKQoJCWRpZV9lcnJubygib3BlbiAvZGV2L251bGwgb3IgZHVwIGZhaWxlZCIpOwoJaWYgKGZkID4gMikKCQljbG9zZShmZCk7Cn0KCmludCBkYWVtb25pemUodm9pZCkKewojaWZkZWYgTk9fUE9TSVhfR09PRElFUwoJZXJybm8gPSBFTk9TWVM7CglyZXR1cm4gLTE7CiNlbHNlCglzd2l0Y2ggKGZvcmsoKSkgewoJCWNhc2UgMDoKCQkJYnJlYWs7CgkJY2FzZSAtMToKCQkJZGllX2Vycm5vKCJmb3JrIGZhaWxlZCIpOwoJCWRlZmF1bHQ6CgkJCWV4aXQoMCk7Cgl9CglpZiAoc2V0c2lkKCkgPT0gLTEpCgkJZGllX2Vycm5vKCJzZXRzaWQgZmFpbGVkIik7CgljbG9zZSgwKTsKCWNsb3NlKDEpOwoJY2xvc2UoMik7CglzYW5pdGl6ZV9zdGRmZHMoKTsKCXJldHVybiAwOwojZW5kaWYKfQo=",
    "text": "#include \"cache.h\"\n#include \"dir.h\"\n#include \"string-list.h\"\n\nstatic int inside_git_dir = -1;\nstatic int inside_work_tree = -1;\n\n/*\n * The input parameter must contain an absolute path, and it must already be\n * normalized.\n *\n * Find the part of an absolute path that lies inside the work tree by\n * dereferencing symlinks outside the work tree, for example:\n * /dir1/repo/dir2/file   (work tree is /dir1/repo)      -> dir2/file\n * /dir/file              (work tree is /)               -> dir/file\n * /dir/symlink1/symlink2 (symlink1 points to work tree) -> symlink2\n * /dir/repolink/file     (repolink points to /dir/repo) -> file\n * /dir/repo              (exactly equal to work tree)   -> (empty string)\n */\nstatic int abspath_part_inside_repo(char *path)\n{\n\tsize_t len;\n\tsize_t wtlen;\n\tchar *path0;\n\tint off;\n\tconst char *work_tree = get_git_work_tree();\n\n\tif (!work_tree)\n\t\treturn -1;\n\twtlen = strlen(work_tree);\n\tlen = strlen(path);\n\toff = offset_1st_component(path);\n\n\t/* check if work tree is already the prefix */\n\tif (wtlen <= len && !strncmp(path, work_tree, wtlen)) {\n\t\tif (path[wtlen] == '/') {\n\t\t\tmemmove(path, path + wtlen + 1, len - wtlen);\n\t\t\treturn 0;\n\t\t} else if (path[wtlen - 1] == '/' || path[wtlen] == '\\0') {\n\t\t\t/* work tree is the root, or the whole path */\n\t\t\tmemmove(path, path + wtlen, len - wtlen + 1);\n\t\t\treturn 0;\n\t\t}\n\t\t/* work tree might match beginning of a symlink to work tree */\n\t\toff = wtlen;\n\t}\n\tpath0 = path;\n\tpath += off;\n\n\t/* check each '/'-terminated level */\n\twhile (*path) {\n\t\tpath++;\n\t\tif (*path == '/') {\n\t\t\t*path = '\\0';\n\t\t\tif (strcmp(real_path(path0), work_tree) == 0) {\n\t\t\t\tmemmove(path0, path + 1, len - (path - path0));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*path = '/';\n\t\t}\n\t}\n\n\t/* check whole path */\n\tif (strcmp(real_path(path0), work_tree) == 0) {\n\t\t*path0 = '\\0';\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\n/*\n * Normalize \"path\", prepending the \"prefix\" for relative paths. If\n * remaining_prefix is not NULL, return the actual prefix still\n * remains in the path. For example, prefix = sub1/sub2/ and path is\n *\n *  foo          -> sub1/sub2/foo  (full prefix)\n *  ../foo       -> sub1/foo       (remaining prefix is sub1/)\n *  ../../bar    -> bar            (no remaining prefix)\n *  ../../sub1/sub2/foo -> sub1/sub2/foo (but no remaining prefix)\n *  `pwd`/../bar -> sub1/bar       (no remaining prefix)\n */\nchar *prefix_path_gently(const char *prefix, int len,\n\t\t\t int *remaining_prefix, const char *path)\n{\n\tconst char *orig = path;\n\tchar *sanitized;\n\tif (is_absolute_path(orig)) {\n\t\tsanitized = xmalloc(strlen(path) + 1);\n\t\tif (remaining_prefix)\n\t\t\t*remaining_prefix = 0;\n\t\tif (normalize_path_copy_len(sanitized, path, remaining_prefix)) {\n\t\t\tfree(sanitized);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (abspath_part_inside_repo(sanitized)) {\n\t\t\tfree(sanitized);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tsanitized = xmalloc(len + strlen(path) + 1);\n\t\tif (len)\n\t\t\tmemcpy(sanitized, prefix, len);\n\t\tstrcpy(sanitized + len, path);\n\t\tif (remaining_prefix)\n\t\t\t*remaining_prefix = len;\n\t\tif (normalize_path_copy_len(sanitized, sanitized, remaining_prefix)) {\n\t\t\tfree(sanitized);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn sanitized;\n}\n\nchar *prefix_path(const char *prefix, int len, const char *path)\n{\n\tchar *r = prefix_path_gently(prefix, len, NULL, path);\n\tif (!r)\n\t\tdie(\"'%s' is outside repository\", path);\n\treturn r;\n}\n\nint path_inside_repo(const char *prefix, const char *path)\n{\n\tint len = prefix ? strlen(prefix) : 0;\n\tchar *r = prefix_path_gently(prefix, len, NULL, path);\n\tif (r) {\n\t\tfree(r);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint check_filename(const char *prefix, const char *arg)\n{\n\tconst char *name;\n\tstruct stat st;\n\n\tif (starts_with(arg, \":/\")) {\n\t\tif (arg[2] == '\\0') /* \":/\" is root dir, always exists */\n\t\t\treturn 1;\n\t\tname = arg + 2;\n\t} else if (prefix)\n\t\tname = prefix_filename(prefix, strlen(prefix), arg);\n\telse\n\t\tname = arg;\n\tif (!lstat(name, &st))\n\t\treturn 1; /* file exists */\n\tif (errno == ENOENT || errno == ENOTDIR)\n\t\treturn 0; /* file does not exist */\n\tdie_errno(\"failed to stat '%s'\", arg);\n}\n\nstatic void NORETURN die_verify_filename(const char *prefix,\n\t\t\t\t\t const char *arg,\n\t\t\t\t\t int diagnose_misspelt_rev)\n{\n\tif (!diagnose_misspelt_rev)\n\t\tdie(\"%s: no such path in the working tree.\\n\"\n\t\t    \"Use 'git <command> -- <path>...' to specify paths that do not exist locally.\",\n\t\t    arg);\n\t/*\n\t * Saying \"'(icase)foo' does not exist in the index\" when the\n\t * user gave us \":(icase)foo\" is just stupid.  A magic pathspec\n\t * begins with a colon and is followed by a non-alnum; do not\n\t * let maybe_die_on_misspelt_object_name() even trigger.\n\t */\n\tif (!(arg[0] == ':' && !isalnum(arg[1])))\n\t\tmaybe_die_on_misspelt_object_name(arg, prefix);\n\n\t/* ... or fall back the most general message. */\n\tdie(\"ambiguous argument '%s': unknown revision or path not in the working tree.\\n\"\n\t    \"Use '--' to separate paths from revisions, like this:\\n\"\n\t    \"'git <command> [<revision>...] -- [<file>...]'\", arg);\n\n}\n\n/*\n * Verify a filename that we got as an argument for a pathspec\n * entry. Note that a filename that begins with \"-\" never verifies\n * as true, because even if such a filename were to exist, we want\n * it to be preceded by the \"--\" marker (or we want the user to\n * use a format like \"./-filename\")\n *\n * The \"diagnose_misspelt_rev\" is used to provide a user-friendly\n * diagnosis when dying upon finding that \"name\" is not a pathname.\n * If set to 1, the diagnosis will try to diagnose \"name\" as an\n * invalid object name (e.g. HEAD:foo). If set to 0, the diagnosis\n * will only complain about an inexisting file.\n *\n * This function is typically called to check that a \"file or rev\"\n * argument is unambiguous. In this case, the caller will want\n * diagnose_misspelt_rev == 1 when verifying the first non-rev\n * argument (which could have been a revision), and\n * diagnose_misspelt_rev == 0 for the next ones (because we already\n * saw a filename, there's not ambiguity anymore).\n */\nvoid verify_filename(const char *prefix,\n\t\t     const char *arg,\n\t\t     int diagnose_misspelt_rev)\n{\n\tif (*arg == '-')\n\t\tdie(\"bad flag '%s' used after filename\", arg);\n\tif (check_filename(prefix, arg))\n\t\treturn;\n\tdie_verify_filename(prefix, arg, diagnose_misspelt_rev);\n}\n\n/*\n * Opposite of the above: the command line did not have -- marker\n * and we parsed the arg as a refname.  It should not be interpretable\n * as a filename.\n */\nvoid verify_non_filename(const char *prefix, const char *arg)\n{\n\tif (!is_inside_work_tree() || is_inside_git_dir())\n\t\treturn;\n\tif (*arg == '-')\n\t\treturn; /* flag */\n\tif (!check_filename(prefix, arg))\n\t\treturn;\n\tdie(\"ambiguous argument '%s': both revision and filename\\n\"\n\t    \"Use '--' to separate paths from revisions, like this:\\n\"\n\t    \"'git <command> [<revision>...] -- [<file>...]'\", arg);\n}\n\nstatic void get_common_dir(struct strbuf *sb, const char *gitdir)\n{\n\tstruct strbuf data = STRBUF_INIT;\n\tstruct strbuf path = STRBUF_INIT;\n\tconst char *git_common_dir = getenv(GIT_COMMON_DIR_ENVIRONMENT);\n\tif (git_common_dir) {\n\t\tstrbuf_addstr(sb, git_common_dir);\n\t\treturn;\n\t}\n\tstrbuf_addf(&path, \"%s/commondir\", gitdir);\n\tif (file_exists(path.buf)) {\n\t\tif (strbuf_read_file(&data, path.buf, 0) <= 0)\n\t\t\tdie_errno(_(\"failed to read %s\"), path.buf);\n\t\twhile (data.len && (data.buf[data.len - 1] == '\\n' ||\n\t\t\t\t    data.buf[data.len - 1] == '\\r'))\n\t\t\tdata.len--;\n\t\tdata.buf[data.len] = '\\0';\n\t\tstrbuf_reset(&path);\n\t\tif (!is_absolute_path(data.buf))\n\t\t\tstrbuf_addf(&path, \"%s/\", gitdir);\n\t\tstrbuf_addbuf(&path, &data);\n\t\tstrbuf_addstr(sb, real_path(path.buf));\n\t} else\n\t\tstrbuf_addstr(sb, gitdir);\n\tstrbuf_release(&data);\n\tstrbuf_release(&path);\n}\n\n/*\n * Test if it looks like we're at a git directory.\n * We want to see:\n *\n *  - either an objects/ directory _or_ the proper\n *    GIT_OBJECT_DIRECTORY environment variable\n *  - a refs/ directory\n *  - either a HEAD symlink or a HEAD file that is formatted as\n *    a proper \"ref:\", or a regular file HEAD that has a properly\n *    formatted sha1 object name.\n */\nint is_git_directory(const char *suspect)\n{\n\tstruct strbuf path = STRBUF_INIT;\n\tint ret = 0;\n\tsize_t len;\n\n\t/* Check worktree-related signatures */\n\tstrbuf_addf(&path, \"%s/HEAD\", suspect);\n\tif (validate_headref(path.buf))\n\t\tgoto done;\n\n\tstrbuf_reset(&path);\n\tget_common_dir(&path, suspect);\n\tlen = path.len;\n\n\t/* Check non-worktree-related signatures */\n\tif (getenv(DB_ENVIRONMENT)) {\n\t\tif (access(getenv(DB_ENVIRONMENT), X_OK))\n\t\t\tgoto done;\n\t}\n\telse {\n\t\tstrbuf_setlen(&path, len);\n\t\tstrbuf_addstr(&path, \"/objects\");\n\t\tif (access(path.buf, X_OK))\n\t\t\tgoto done;\n\t}\n\n\tstrbuf_setlen(&path, len);\n\tstrbuf_addstr(&path, \"/refs\");\n\tif (access(path.buf, X_OK))\n\t\tgoto done;\n\n\tret = 1;\ndone:\n\tstrbuf_release(&path);\n\treturn ret;\n}\n\nint is_inside_git_dir(void)\n{\n\tif (inside_git_dir < 0)\n\t\tinside_git_dir = is_inside_dir(get_git_dir());\n\treturn inside_git_dir;\n}\n\nint is_inside_work_tree(void)\n{\n\tif (inside_work_tree < 0)\n\t\tinside_work_tree = is_inside_dir(get_git_work_tree());\n\treturn inside_work_tree;\n}\n\nvoid setup_work_tree(void)\n{\n\tconst char *work_tree, *git_dir;\n\tstatic int initialized = 0;\n\n\tif (initialized)\n\t\treturn;\n\twork_tree = get_git_work_tree();\n\tgit_dir = get_git_dir();\n\tif (!is_absolute_path(git_dir))\n\t\tgit_dir = real_path(get_git_dir());\n\tif (!work_tree || chdir(work_tree))\n\t\tdie(\"This operation must be run in a work tree\");\n\n\t/*\n\t * Make sure subsequent git processes find correct worktree\n\t * if $GIT_WORK_TREE is set relative\n\t */\n\tif (getenv(GIT_WORK_TREE_ENVIRONMENT))\n\t\tsetenv(GIT_WORK_TREE_ENVIRONMENT, \".\", 1);\n\n\tset_git_dir(remove_leading_path(git_dir, work_tree));\n\tinitialized = 1;\n}\n\nstatic int check_repository_format_gently(const char *gitdir, int *nongit_ok)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *repo_config;\n\tint ret = 0;\n\n\t/*\n\t * git_config() can't be used here because it calls git_pathdup()\n\t * to get $GIT_CONFIG/config. That call will make setup_git_env()\n\t * set git_dir to \".git\".\n\t *\n\t * We are in gitdir setup, no git dir has been found useable yet.\n\t * Use a gentler version of git_config() to check if this repo\n\t * is a good one.\n\t */\n\tstrbuf_addf(&sb, \"%s/config\", gitdir);\n\trepo_config = sb.buf;\n\tgit_config_early(check_repository_format_version, NULL, repo_config);\n\tif (GIT_REPO_VERSION < repository_format_version) {\n\t\tif (!nongit_ok)\n\t\t\tdie (\"Expected git repo version <= %d, found %d\",\n\t\t\t     GIT_REPO_VERSION, repository_format_version);\n\t\twarning(\"Expected git repo version <= %d, found %d\",\n\t\t\tGIT_REPO_VERSION, repository_format_version);\n\t\twarning(\"Please upgrade Git\");\n\t\t*nongit_ok = -1;\n\t\tret = -1;\n\t}\n\tstrbuf_release(&sb);\n\treturn ret;\n}\n\n/*\n * Try to read the location of the git directory from the .git file,\n * return path to git directory if found.\n */\nconst char *read_gitfile(const char *path)\n{\n\tchar *buf;\n\tchar *dir;\n\tconst char *slash;\n\tstruct stat st;\n\tint fd;\n\tssize_t len;\n\n\tif (stat(path, &st))\n\t\treturn NULL;\n\tif (!S_ISREG(st.st_mode))\n\t\treturn NULL;\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tdie_errno(\"Error opening '%s'\", path);\n\tbuf = xmalloc(st.st_size + 1);\n\tlen = read_in_full(fd, buf, st.st_size);\n\tclose(fd);\n\tif (len != st.st_size)\n\t\tdie(\"Error reading %s\", path);\n\tbuf[len] = '\\0';\n\tif (!starts_with(buf, \"gitdir: \"))\n\t\tdie(\"Invalid gitfile format: %s\", path);\n\twhile (buf[len - 1] == '\\n' || buf[len - 1] == '\\r')\n\t\tlen--;\n\tif (len < 9)\n\t\tdie(\"No path in gitfile: %s\", path);\n\tbuf[len] = '\\0';\n\tdir = buf + 8;\n\n\tif (!is_absolute_path(dir) && (slash = strrchr(path, '/'))) {\n\t\tsize_t pathlen = slash+1 - path;\n\t\tsize_t dirlen = pathlen + len - 8;\n\t\tdir = xmalloc(dirlen + 1);\n\t\tstrncpy(dir, path, pathlen);\n\t\tstrncpy(dir + pathlen, buf + 8, len - 8);\n\t\tdir[dirlen] = '\\0';\n\t\tfree(buf);\n\t\tbuf = dir;\n\t}\n\n\tif (!is_git_directory(dir))\n\t\tdie(\"Not a git repository: %s\", dir);\n\tpath = real_path(dir);\n\n\tfree(buf);\n\treturn path;\n}\n\nstatic const char *setup_explicit_git_dir(const char *gitdirenv,\n\t\t\t\t\t  struct strbuf *cwd,\n\t\t\t\t\t  int *nongit_ok)\n{\n\tconst char *work_tree_env = getenv(GIT_WORK_TREE_ENVIRONMENT);\n\tconst char *worktree;\n\tchar *gitfile;\n\tint offset;\n\n\tif (PATH_MAX - 40 < strlen(gitdirenv))\n\t\tdie(\"'$%s' too big\", GIT_DIR_ENVIRONMENT);\n\n\tgitfile = (char*)read_gitfile(gitdirenv);\n\tif (gitfile) {\n\t\tgitfile = xstrdup(gitfile);\n\t\tgitdirenv = gitfile;\n\t}\n\n\tif (!is_git_directory(gitdirenv)) {\n\t\tif (nongit_ok) {\n\t\t\t*nongit_ok = 1;\n\t\t\tfree(gitfile);\n\t\t\treturn NULL;\n\t\t}\n\t\tdie(\"Not a git repository: '%s'\", gitdirenv);\n\t}\n\n\tif (check_repository_format_gently(gitdirenv, nongit_ok)) {\n\t\tfree(gitfile);\n\t\treturn NULL;\n\t}\n\n\t/* #3, #7, #11, #15, #19, #23, #27, #31 (see t1510) */\n\tif (work_tree_env)\n\t\tset_git_work_tree(work_tree_env);\n\telse if (is_bare_repository_cfg > 0) {\n\t\tif (git_work_tree_cfg) /* #22.2, #30 */\n\t\t\tdie(\"core.bare and core.worktree do not make sense\");\n\n\t\t/* #18, #26 */\n\t\tset_git_dir(gitdirenv);\n\t\tfree(gitfile);\n\t\treturn NULL;\n\t}\n\telse if (git_work_tree_cfg) { /* #6, #14 */\n\t\tif (is_absolute_path(git_work_tree_cfg))\n\t\t\tset_git_work_tree(git_work_tree_cfg);\n\t\telse {\n\t\t\tchar *core_worktree;\n\t\t\tif (chdir(gitdirenv))\n\t\t\t\tdie_errno(\"Could not chdir to '%s'\", gitdirenv);\n\t\t\tif (chdir(git_work_tree_cfg))\n\t\t\t\tdie_errno(\"Could not chdir to '%s'\", git_work_tree_cfg);\n\t\t\tcore_worktree = xgetcwd();\n\t\t\tif (chdir(cwd->buf))\n\t\t\t\tdie_errno(\"Could not come back to cwd\");\n\t\t\tset_git_work_tree(core_worktree);\n\t\t\tfree(core_worktree);\n\t\t}\n\t}\n\telse if (!git_env_bool(GIT_IMPLICIT_WORK_TREE_ENVIRONMENT, 1)) {\n\t\t/* #16d */\n\t\tset_git_dir(gitdirenv);\n\t\tfree(gitfile);\n\t\treturn NULL;\n\t}\n\telse /* #2, #10 */\n\t\tset_git_work_tree(\".\");\n\n\t/* set_git_work_tree() must have been called by now */\n\tworktree = get_git_work_tree();\n\n\t/* both get_git_work_tree() and cwd are already normalized */\n\tif (!strcmp(cwd->buf, worktree)) { /* cwd == worktree */\n\t\tset_git_dir(gitdirenv);\n\t\tfree(gitfile);\n\t\treturn NULL;\n\t}\n\n\toffset = dir_inside_of(cwd->buf, worktree);\n\tif (offset >= 0) {\t/* cwd inside worktree? */\n\t\tset_git_dir(real_path(gitdirenv));\n\t\tif (chdir(worktree))\n\t\t\tdie_errno(\"Could not chdir to '%s'\", worktree);\n\t\tstrbuf_addch(cwd, '/');\n\t\tfree(gitfile);\n\t\treturn cwd->buf + offset;\n\t}\n\n\t/* cwd outside worktree */\n\tset_git_dir(gitdirenv);\n\tfree(gitfile);\n\treturn NULL;\n}\n\nstatic const char *setup_discovered_git_dir(const char *gitdir,\n\t\t\t\t\t    struct strbuf *cwd, int offset,\n\t\t\t\t\t    int *nongit_ok)\n{\n\tif (check_repository_format_gently(gitdir, nongit_ok))\n\t\treturn NULL;\n\n\t/* --work-tree is set without --git-dir; use discovered one */\n\tif (getenv(GIT_WORK_TREE_ENVIRONMENT) || git_work_tree_cfg) {\n\t\tif (offset != cwd->len && !is_absolute_path(gitdir))\n\t\t\tgitdir = xstrdup(real_path(gitdir));\n\t\tif (chdir(cwd->buf))\n\t\t\tdie_errno(\"Could not come back to cwd\");\n\t\treturn setup_explicit_git_dir(gitdir, cwd, nongit_ok);\n\t}\n\n\t/* #16.2, #17.2, #20.2, #21.2, #24, #25, #28, #29 (see t1510) */\n\tif (is_bare_repository_cfg > 0) {\n\t\tset_git_dir(offset == cwd->len ? gitdir : real_path(gitdir));\n\t\tif (chdir(cwd->buf))\n\t\t\tdie_errno(\"Could not come back to cwd\");\n\t\treturn NULL;\n\t}\n\n\t/* #0, #1, #5, #8, #9, #12, #13 */\n\tset_git_work_tree(\".\");\n\tif (strcmp(gitdir, DEFAULT_GIT_DIR_ENVIRONMENT))\n\t\tset_git_dir(gitdir);\n\tinside_git_dir = 0;\n\tinside_work_tree = 1;\n\tif (offset == cwd->len)\n\t\treturn NULL;\n\n\t/* Make \"offset\" point to past the '/', and add a '/' at the end */\n\toffset++;\n\tstrbuf_addch(cwd, '/');\n\treturn cwd->buf + offset;\n}\n\n/* #16.1, #17.1, #20.1, #21.1, #22.1 (see t1510) */\nstatic const char *setup_bare_git_dir(struct strbuf *cwd, int offset,\n\t\t\t\t      int *nongit_ok)\n{\n\tint root_len;\n\n\tif (check_repository_format_gently(\".\", nongit_ok))\n\t\treturn NULL;\n\n\tsetenv(GIT_IMPLICIT_WORK_TREE_ENVIRONMENT, \"0\", 1);\n\n\t/* --work-tree is set without --git-dir; use discovered one */\n\tif (getenv(GIT_WORK_TREE_ENVIRONMENT) || git_work_tree_cfg) {\n\t\tconst char *gitdir;\n\n\t\tgitdir = offset == cwd->len ? \".\" : xmemdupz(cwd->buf, offset);\n\t\tif (chdir(cwd->buf))\n\t\t\tdie_errno(\"Could not come back to cwd\");\n\t\treturn setup_explicit_git_dir(gitdir, cwd, nongit_ok);\n\t}\n\n\tinside_git_dir = 1;\n\tinside_work_tree = 0;\n\tif (offset != cwd->len) {\n\t\tif (chdir(cwd->buf))\n\t\t\tdie_errno(\"Cannot come back to cwd\");\n\t\troot_len = offset_1st_component(cwd->buf);\n\t\tstrbuf_setlen(cwd, offset > root_len ? offset : root_len);\n\t\tset_git_dir(cwd->buf);\n\t}\n\telse\n\t\tset_git_dir(\".\");\n\treturn NULL;\n}\n\nstatic const char *setup_nongit(const char *cwd, int *nongit_ok)\n{\n\tif (!nongit_ok)\n\t\tdie(\"Not a git repository (or any of the parent directories): %s\", DEFAULT_GIT_DIR_ENVIRONMENT);\n\tif (chdir(cwd))\n\t\tdie_errno(\"Cannot come back to cwd\");\n\t*nongit_ok = 1;\n\treturn NULL;\n}\n\nstatic dev_t get_device_or_die(const char *path, const char *prefix, int prefix_len)\n{\n\tstruct stat buf;\n\tif (stat(path, &buf)) {\n\t\tdie_errno(\"failed to stat '%*s%s%s'\",\n\t\t\t\tprefix_len,\n\t\t\t\tprefix ? prefix : \"\",\n\t\t\t\tprefix ? \"/\" : \"\", path);\n\t}\n\treturn buf.st_dev;\n}\n\n/*\n * A \"string_list_each_func_t\" function that canonicalizes an entry\n * from GIT_CEILING_DIRECTORIES using real_path_if_valid(), or\n * discards it if unusable.  The presence of an empty entry in\n * GIT_CEILING_DIRECTORIES turns off canonicalization for all\n * subsequent entries.\n */\nstatic int canonicalize_ceiling_entry(struct string_list_item *item,\n\t\t\t\t      void *cb_data)\n{\n\tint *empty_entry_found = cb_data;\n\tchar *ceil = item->string;\n\n\tif (!*ceil) {\n\t\t*empty_entry_found = 1;\n\t\treturn 0;\n\t} else if (!is_absolute_path(ceil)) {\n\t\treturn 0;\n\t} else if (*empty_entry_found) {\n\t\t/* Keep entry but do not canonicalize it */\n\t\treturn 1;\n\t} else {\n\t\tconst char *real_path = real_path_if_valid(ceil);\n\t\tif (!real_path)\n\t\t\treturn 0;\n\t\tfree(item->string);\n\t\titem->string = xstrdup(real_path);\n\t\treturn 1;\n\t}\n}\n\n/*\n * We cannot decide in this function whether we are in the work tree or\n * not, since the config can only be read _after_ this function was called.\n */\nstatic const char *setup_git_directory_gently_1(int *nongit_ok)\n{\n\tconst char *env_ceiling_dirs = getenv(CEILING_DIRECTORIES_ENVIRONMENT);\n\tstruct string_list ceiling_dirs = STRING_LIST_INIT_DUP;\n\tstatic struct strbuf cwd = STRBUF_INIT;\n\tconst char *gitdirenv, *ret;\n\tchar *gitfile;\n\tint offset, offset_parent, ceil_offset = -1;\n\tdev_t current_device = 0;\n\tint one_filesystem = 1;\n\n\t/*\n\t * We may have read an incomplete configuration before\n\t * setting-up the git directory. If so, clear the cache so\n\t * that the next queries to the configuration reload complete\n\t * configuration (including the per-repo config file that we\n\t * ignored previously).\n\t */\n\tgit_config_clear();\n\n\t/*\n\t * Let's assume that we are in a git repository.\n\t * If it turns out later that we are somewhere else, the value will be\n\t * updated accordingly.\n\t */\n\tif (nongit_ok)\n\t\t*nongit_ok = 0;\n\n\tif (strbuf_getcwd(&cwd))\n\t\tdie_errno(\"Unable to read current working directory\");\n\toffset = cwd.len;\n\n\t/*\n\t * If GIT_DIR is set explicitly, we're not going\n\t * to do any discovery, but we still do repository\n\t * validation.\n\t */\n\tgitdirenv = getenv(GIT_DIR_ENVIRONMENT);\n\tif (gitdirenv)\n\t\treturn setup_explicit_git_dir(gitdirenv, &cwd, nongit_ok);\n\n\tif (env_ceiling_dirs) {\n\t\tint empty_entry_found = 0;\n\n\t\tstring_list_split(&ceiling_dirs, env_ceiling_dirs, PATH_SEP, -1);\n\t\tfilter_string_list(&ceiling_dirs, 0,\n\t\t\t\t   canonicalize_ceiling_entry, &empty_entry_found);\n\t\tceil_offset = longest_ancestor_length(cwd.buf, &ceiling_dirs);\n\t\tstring_list_clear(&ceiling_dirs, 0);\n\t}\n\n\tif (ceil_offset < 0 && has_dos_drive_prefix(cwd.buf))\n\t\tceil_offset = 1;\n\n\t/*\n\t * Test in the following order (relative to the cwd):\n\t * - .git (file containing \"gitdir: <path>\")\n\t * - .git/\n\t * - ./ (bare)\n\t * - ../.git\n\t * - ../.git/\n\t * - ../ (bare)\n\t * - ../../.git/\n\t *   etc.\n\t */\n\tone_filesystem = !git_env_bool(\"GIT_DISCOVERY_ACROSS_FILESYSTEM\", 0);\n\tif (one_filesystem)\n\t\tcurrent_device = get_device_or_die(\".\", NULL, 0);\n\tfor (;;) {\n\t\tgitfile = (char*)read_gitfile(DEFAULT_GIT_DIR_ENVIRONMENT);\n\t\tif (gitfile)\n\t\t\tgitdirenv = gitfile = xstrdup(gitfile);\n\t\telse {\n\t\t\tif (is_git_directory(DEFAULT_GIT_DIR_ENVIRONMENT))\n\t\t\t\tgitdirenv = DEFAULT_GIT_DIR_ENVIRONMENT;\n\t\t}\n\n\t\tif (gitdirenv) {\n\t\t\tret = setup_discovered_git_dir(gitdirenv,\n\t\t\t\t\t\t       &cwd, offset,\n\t\t\t\t\t\t       nongit_ok);\n\t\t\tfree(gitfile);\n\t\t\treturn ret;\n\t\t}\n\t\tfree(gitfile);\n\n\t\tif (is_git_directory(\".\"))\n\t\t\treturn setup_bare_git_dir(&cwd, offset, nongit_ok);\n\n\t\toffset_parent = offset;\n\t\twhile (--offset_parent > ceil_offset && cwd.buf[offset_parent] != '/');\n\t\tif (offset_parent <= ceil_offset)\n\t\t\treturn setup_nongit(cwd.buf, nongit_ok);\n\t\tif (one_filesystem) {\n\t\t\tdev_t parent_device = get_device_or_die(\"..\", cwd.buf,\n\t\t\t\t\t\t\t\toffset);\n\t\t\tif (parent_device != current_device) {\n\t\t\t\tif (nongit_ok) {\n\t\t\t\t\tif (chdir(cwd.buf))\n\t\t\t\t\t\tdie_errno(\"Cannot come back to cwd\");\n\t\t\t\t\t*nongit_ok = 1;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tstrbuf_setlen(&cwd, offset);\n\t\t\t\tdie(\"Not a git repository (or any parent up to mount point %s)\\n\"\n\t\t\t\t\"Stopping at filesystem boundary (GIT_DISCOVERY_ACROSS_FILESYSTEM not set).\",\n\t\t\t\t    cwd.buf);\n\t\t\t}\n\t\t}\n\t\tif (chdir(\"..\")) {\n\t\t\tstrbuf_setlen(&cwd, offset);\n\t\t\tdie_errno(\"Cannot change to '%s/..'\", cwd.buf);\n\t\t}\n\t\toffset = offset_parent;\n\t}\n}\n\nconst char *setup_git_directory_gently(int *nongit_ok)\n{\n\tconst char *prefix;\n\n\tprefix = setup_git_directory_gently_1(nongit_ok);\n\tif (prefix)\n\t\tsetenv(GIT_PREFIX_ENVIRONMENT, prefix, 1);\n\telse\n\t\tsetenv(GIT_PREFIX_ENVIRONMENT, \"\", 1);\n\n\tif (startup_info) {\n\t\tstartup_info->have_repository = !nongit_ok || !*nongit_ok;\n\t\tstartup_info->prefix = prefix;\n\t}\n\treturn prefix;\n}\n\nint git_config_perm(const char *var, const char *value)\n{\n\tint i;\n\tchar *endptr;\n\n\tif (value == NULL)\n\t\treturn PERM_GROUP;\n\n\tif (!strcmp(value, \"umask\"))\n\t\treturn PERM_UMASK;\n\tif (!strcmp(value, \"group\"))\n\t\treturn PERM_GROUP;\n\tif (!strcmp(value, \"all\") ||\n\t    !strcmp(value, \"world\") ||\n\t    !strcmp(value, \"everybody\"))\n\t\treturn PERM_EVERYBODY;\n\n\t/* Parse octal numbers */\n\ti = strtol(value, &endptr, 8);\n\n\t/* If not an octal number, maybe true/false? */\n\tif (*endptr != 0)\n\t\treturn git_config_bool(var, value) ? PERM_GROUP : PERM_UMASK;\n\n\t/*\n\t * Treat values 0, 1 and 2 as compatibility cases, otherwise it is\n\t * a chmod value to restrict to.\n\t */\n\tswitch (i) {\n\tcase PERM_UMASK:               /* 0 */\n\t\treturn PERM_UMASK;\n\tcase OLD_PERM_GROUP:           /* 1 */\n\t\treturn PERM_GROUP;\n\tcase OLD_PERM_EVERYBODY:       /* 2 */\n\t\treturn PERM_EVERYBODY;\n\t}\n\n\t/* A filemode value was given: 0xxx */\n\n\tif ((i & 0600) != 0600)\n\t\tdie(\"Problem with core.sharedRepository filemode value \"\n\t\t    \"(0%.3o).\\nThe owner of files must always have \"\n\t\t    \"read and write permissions.\", i);\n\n\t/*\n\t * Mask filemode value. Others can not get write permission.\n\t * x flags for directories are handled separately.\n\t */\n\treturn -(i & 0666);\n}\n\nint check_repository_format_version(const char *var, const char *value, void *cb)\n{\n\tif (strcmp(var, \"core.repositoryformatversion\") == 0)\n\t\trepository_format_version = git_config_int(var, value);\n\telse if (strcmp(var, \"core.sharedrepository\") == 0)\n\t\tshared_repository = git_config_perm(var, value);\n\telse if (strcmp(var, \"core.bare\") == 0) {\n\t\tis_bare_repository_cfg = git_config_bool(var, value);\n\t\tif (is_bare_repository_cfg == 1)\n\t\t\tinside_work_tree = -1;\n\t} else if (strcmp(var, \"core.worktree\") == 0) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tfree(git_work_tree_cfg);\n\t\tgit_work_tree_cfg = xstrdup(value);\n\t\tinside_work_tree = -1;\n\t}\n\treturn 0;\n}\n\nint check_repository_format(void)\n{\n\treturn check_repository_format_gently(get_git_dir(), NULL);\n}\n\n/*\n * Returns the \"prefix\", a path to the current working directory\n * relative to the work tree root, or NULL, if the current working\n * directory is not a strict subdirectory of the work tree root. The\n * prefix always ends with a '/' character.\n */\nconst char *setup_git_directory(void)\n{\n\treturn setup_git_directory_gently(NULL);\n}\n\nconst char *resolve_gitdir(const char *suspect)\n{\n\tif (is_git_directory(suspect))\n\t\treturn suspect;\n\treturn read_gitfile(suspect);\n}\n\n/* if any standard file descriptor is missing open it to /dev/null */\nvoid sanitize_stdfds(void)\n{\n\tint fd = open(\"/dev/null\", O_RDWR, 0);\n\twhile (fd != -1 && fd < 2)\n\t\tfd = dup(fd);\n\tif (fd == -1)\n\t\tdie_errno(\"open /dev/null or dup failed\");\n\tif (fd > 2)\n\t\tclose(fd);\n}\n\nint daemonize(void)\n{\n#ifdef NO_POSIX_GOODIES\n\terrno = ENOSYS;\n\treturn -1;\n#else\n\tswitch (fork()) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tdie_errno(\"fork failed\");\n\t\tdefault:\n\t\t\texit(0);\n\t}\n\tif (setsid() == -1)\n\t\tdie_errno(\"setsid failed\");\n\tclose(0);\n\tclose(1);\n\tclose(2);\n\tsanitize_stdfds();\n\treturn 0;\n#endif\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00a23e6edf454bce0a30783e57195f251c1e1e11",
  "sha1_ok": true,
  "size": 24452
}
