{
  "content": {
    "base64": "LyoKICogImdpdCBmZXRjaCIKICovCiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJwYXRoLWxpc3QuaCIKI2luY2x1ZGUgInJlbW90ZS5oIgojaW5jbHVkZSAidHJhbnNwb3J0LmgiCgpzdGF0aWMgY29uc3QgY2hhciBmZXRjaF91c2FnZVtdID0gImdpdC1mZXRjaCBbLWEgfCAtLWFwcGVuZF0gWy0tdXBsb2FkLXBhY2sgPHVwbG9hZC1wYWNrPl0gWy1mIHwgLS1mb3JjZV0gWy0tbm8tdGFnc10gWy10IHwgLS10YWdzXSBbLWsgfCAtLWtlZXBdIFstdSB8IC0tdXBkYXRlLWhlYWQtb2tdIFstLWRlcHRoIDxkZXB0aD5dIFstdiB8IC0tdmVyYm9zZV0gWzxyZXBvc2l0b3J5PiA8cmVmc3BlYz4uLi5dIjsKCnN0YXRpYyBpbnQgYXBwZW5kLCBmb3JjZSwgdGFncywgbm9fdGFncywgdXBkYXRlX2hlYWRfb2ssIHZlcmJvc2UsIHF1aWV0OwpzdGF0aWMgY2hhciAqZGVmYXVsdF9ybGEgPSBOVUxMOwpzdGF0aWMgc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0OwoKc3RhdGljIHZvaWQgdW5sb2NrX3BhY2sodm9pZCkKewoJaWYgKHRyYW5zcG9ydCkKCQl0cmFuc3BvcnRfdW5sb2NrX3BhY2sodHJhbnNwb3J0KTsKfQoKc3RhdGljIHZvaWQgdW5sb2NrX3BhY2tfb25fc2lnbmFsKGludCBzaWdubykKewoJdW5sb2NrX3BhY2soKTsKCXNpZ25hbChTSUdJTlQsIFNJR19ERkwpOwoJcmFpc2Uoc2lnbm8pOwp9CgpzdGF0aWMgdm9pZCBhZGRfbWVyZ2VfY29uZmlnKHN0cnVjdCByZWYgKipoZWFkLAoJCSAgICAgICAgICAgc3RydWN0IHJlZiAqcmVtb3RlX3JlZnMsCgkJICAgICAgICAgICBzdHJ1Y3QgYnJhbmNoICpicmFuY2gsCgkJICAgICAgICAgICBzdHJ1Y3QgcmVmICoqKnRhaWwpCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBicmFuY2gtPm1lcmdlX25yOyBpKyspIHsKCQlzdHJ1Y3QgcmVmICpybSwgKipvbGRfdGFpbCA9ICp0YWlsOwoJCXN0cnVjdCByZWZzcGVjIHJlZnNwZWM7CgoJCWZvciAocm0gPSAqaGVhZDsgcm07IHJtID0gcm0tPm5leHQpIHsKCQkJaWYgKGJyYW5jaF9tZXJnZV9tYXRjaGVzKGJyYW5jaCwgaSwgcm0tPm5hbWUpKSB7CgkJCQlybS0+bWVyZ2UgPSAxOwoJCQkJYnJlYWs7CgkJCX0KCQl9CgkJaWYgKHJtKQoJCQljb250aW51ZTsKCgkJLyoKCQkgKiBOb3QgZmV0Y2hlZCB0byBhIHRyYWNraW5nIGJyYW5jaD8gIFdlIG5lZWQgdG8gZmV0Y2gKCQkgKiBpdCBhbnl3YXkgdG8gYWxsb3cgdGhpcyBicmFuY2gncyAiYnJhbmNoLiRuYW1lLm1lcmdlIgoJCSAqIHRvIGJlIGhvbm9yZWQgYnkgZ2l0LXB1bGwsIGJ1dCB3ZSBkbyBub3QgaGF2ZSB0bwoJCSAqIGZhaWwgaWYgYnJhbmNoLiRuYW1lLm1lcmdlIGlzIG1pc2NvbmZpZ3VyZWQgdG8gcG9pbnQKCQkgKiBhdCBhIG5vbmV4aXN0aW5nIGJyYW5jaC4gIElmIHdlIHdlcmUgaW5kZWVkIGNhbGxlZCBieQoJCSAqIGdpdC1wdWxsLCBpdCB3aWxsIG5vdGljZSB0aGUgbWlzY29uZmlndXJhdGlvbiBiZWNhdXNlCgkJICogdGhlcmUgaXMgbm8gZW50cnkgaW4gdGhlIHJlc3VsdGluZyBGRVRDSF9IRUFEIG1hcmtlZAoJCSAqIGZvciBtZXJnaW5nLgoJCSAqLwoJCXJlZnNwZWMuc3JjID0gYnJhbmNoLT5tZXJnZVtpXS0+c3JjOwoJCXJlZnNwZWMuZHN0ID0gTlVMTDsKCQlyZWZzcGVjLnBhdHRlcm4gPSAwOwoJCXJlZnNwZWMuZm9yY2UgPSAwOwoJCWdldF9mZXRjaF9tYXAocmVtb3RlX3JlZnMsICZyZWZzcGVjLCB0YWlsLCAxKTsKCQlmb3IgKHJtID0gKm9sZF90YWlsOyBybTsgcm0gPSBybS0+bmV4dCkKCQkJcm0tPm1lcmdlID0gMTsKCX0KfQoKc3RhdGljIHN0cnVjdCByZWYgKmdldF9yZWZfbWFwKHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCwKCQkJICAgICAgIHN0cnVjdCByZWZzcGVjICpyZWZzLCBpbnQgcmVmX2NvdW50LCBpbnQgdGFncywKCQkJICAgICAgIGludCAqYXV0b3RhZ3MpCnsKCWludCBpOwoJc3RydWN0IHJlZiAqcm07CglzdHJ1Y3QgcmVmICpyZWZfbWFwID0gTlVMTDsKCXN0cnVjdCByZWYgKip0YWlsID0gJnJlZl9tYXA7CgoJc3RydWN0IHJlZiAqcmVtb3RlX3JlZnMgPSB0cmFuc3BvcnRfZ2V0X3JlbW90ZV9yZWZzKHRyYW5zcG9ydCk7CgoJaWYgKHJlZl9jb3VudCB8fCB0YWdzKSB7CgkJZm9yIChpID0gMDsgaSA8IHJlZl9jb3VudDsgaSsrKSB7CgkJCWdldF9mZXRjaF9tYXAocmVtb3RlX3JlZnMsICZyZWZzW2ldLCAmdGFpbCwgMCk7CgkJCWlmIChyZWZzW2ldLmRzdCAmJiByZWZzW2ldLmRzdFswXSkKCQkJCSphdXRvdGFncyA9IDE7CgkJfQoJCS8qIE1lcmdlIGV2ZXJ5dGhpbmcgb24gdGhlIGNvbW1hbmQgbGluZSwgYnV0IG5vdCAtLXRhZ3MgKi8KCQlmb3IgKHJtID0gcmVmX21hcDsgcm07IHJtID0gcm0tPm5leHQpCgkJCXJtLT5tZXJnZSA9IDE7CgkJaWYgKHRhZ3MpIHsKCQkJc3RydWN0IHJlZnNwZWMgcmVmc3BlYzsKCQkJcmVmc3BlYy5zcmMgPSAicmVmcy90YWdzLyI7CgkJCXJlZnNwZWMuZHN0ID0gInJlZnMvdGFncy8iOwoJCQlyZWZzcGVjLnBhdHRlcm4gPSAxOwoJCQlyZWZzcGVjLmZvcmNlID0gMDsKCQkJZ2V0X2ZldGNoX21hcChyZW1vdGVfcmVmcywgJnJlZnNwZWMsICZ0YWlsLCAwKTsKCQl9Cgl9IGVsc2UgewoJCS8qIFVzZSB0aGUgZGVmYXVsdHMgKi8KCQlzdHJ1Y3QgcmVtb3RlICpyZW1vdGUgPSB0cmFuc3BvcnQtPnJlbW90ZTsKCQlzdHJ1Y3QgYnJhbmNoICpicmFuY2ggPSBicmFuY2hfZ2V0KE5VTEwpOwoJCWludCBoYXNfbWVyZ2UgPSBicmFuY2hfaGFzX21lcmdlX2NvbmZpZyhicmFuY2gpOwoJCWlmIChyZW1vdGUgJiYgKHJlbW90ZS0+ZmV0Y2hfcmVmc3BlY19uciB8fCBoYXNfbWVyZ2UpKSB7CgkJCWZvciAoaSA9IDA7IGkgPCByZW1vdGUtPmZldGNoX3JlZnNwZWNfbnI7IGkrKykgewoJCQkJZ2V0X2ZldGNoX21hcChyZW1vdGVfcmVmcywgJnJlbW90ZS0+ZmV0Y2hbaV0sICZ0YWlsLCAwKTsKCQkJCWlmIChyZW1vdGUtPmZldGNoW2ldLmRzdCAmJgoJCQkJICAgIHJlbW90ZS0+ZmV0Y2hbaV0uZHN0WzBdKQoJCQkJCSphdXRvdGFncyA9IDE7CgkJCQlpZiAoIWkgJiYgIWhhc19tZXJnZSAmJiByZWZfbWFwICYmCgkJCQkgICAgIXJlbW90ZS0+ZmV0Y2hbMF0ucGF0dGVybikKCQkJCQlyZWZfbWFwLT5tZXJnZSA9IDE7CgkJCX0KCQkJLyoKCQkJICogaWYgdGhlIHJlbW90ZSB3ZSdyZSBmZXRjaGluZyBmcm9tIGlzIHRoZSBzYW1lCgkJCSAqIGFzIGdpdmVuIGluIGJyYW5jaC48bmFtZT4ucmVtb3RlLCB3ZSBhZGQgdGhlCgkJCSAqIHJlZiBnaXZlbiBpbiBicmFuY2guPG5hbWU+Lm1lcmdlLCB0b28uCgkJCSAqLwoJCQlpZiAoaGFzX21lcmdlICYmCgkJCSAgICAhc3RyY21wKGJyYW5jaC0+cmVtb3RlX25hbWUsIHJlbW90ZS0+bmFtZSkpCgkJCQlhZGRfbWVyZ2VfY29uZmlnKCZyZWZfbWFwLCByZW1vdGVfcmVmcywgYnJhbmNoLCAmdGFpbCk7CgkJfSBlbHNlIHsKCQkJcmVmX21hcCA9IGdldF9yZW1vdGVfcmVmKHJlbW90ZV9yZWZzLCAiSEVBRCIpOwoJCQlpZiAoIXJlZl9tYXApCgkJCQlkaWUoIkNvdWxkbid0IGZpbmQgcmVtb3RlIHJlZiBIRUFEIik7CgkJCXJlZl9tYXAtPm1lcmdlID0gMTsKCQl9Cgl9CglyZWZfcmVtb3ZlX2R1cGxpY2F0ZXMocmVmX21hcCk7CgoJcmV0dXJuIHJlZl9tYXA7Cn0KCnN0YXRpYyB2b2lkIHNob3dfbmV3KGVudW0gb2JqZWN0X3R5cGUgdHlwZSwgdW5zaWduZWQgY2hhciAqc2hhMV9uZXcpCnsKCWZwcmludGYoc3RkZXJyLCAiICAlczogJXNcbiIsIHR5cGVuYW1lKHR5cGUpLAoJCWZpbmRfdW5pcXVlX2FiYnJldihzaGExX25ldywgREVGQVVMVF9BQkJSRVYpKTsKfQoKc3RhdGljIGludCBzX3VwZGF0ZV9yZWYoY29uc3QgY2hhciAqYWN0aW9uLAoJCQlzdHJ1Y3QgcmVmICpyZWYsCgkJCWludCBjaGVja19vbGQpCnsKCWNoYXIgbXNnWzEwMjRdOwoJY2hhciAqcmxhID0gZ2V0ZW52KCJHSVRfUkVGTE9HX0FDVElPTiIpOwoJc3RhdGljIHN0cnVjdCByZWZfbG9jayAqbG9jazsKCglpZiAoIXJsYSkKCQlybGEgPSBkZWZhdWx0X3JsYTsKCXNucHJpbnRmKG1zZywgc2l6ZW9mKG1zZyksICIlczogJXMiLCBybGEsIGFjdGlvbik7Cglsb2NrID0gbG9ja19hbnlfcmVmX2Zvcl91cGRhdGUocmVmLT5uYW1lLAoJCQkJICAgICAgIGNoZWNrX29sZCA/IHJlZi0+b2xkX3NoYTEgOiBOVUxMLCAwKTsKCWlmICghbG9jaykKCQlyZXR1cm4gMTsKCWlmICh3cml0ZV9yZWZfc2hhMShsb2NrLCByZWYtPm5ld19zaGExLCBtc2cpIDwgMCkKCQlyZXR1cm4gMTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHVwZGF0ZV9sb2NhbF9yZWYoc3RydWN0IHJlZiAqcmVmLAoJCQkgICAgY29uc3QgY2hhciAqbm90ZSwKCQkJICAgIGludCB2ZXJib3NlKQp7CgljaGFyIG9sZGhbNDFdLCBuZXdoWzQxXTsKCXN0cnVjdCBjb21taXQgKmN1cnJlbnQgPSBOVUxMLCAqdXBkYXRlZDsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCXN0cnVjdCBicmFuY2ggKmN1cnJlbnRfYnJhbmNoID0gYnJhbmNoX2dldChOVUxMKTsKCgl0eXBlID0gc2hhMV9vYmplY3RfaW5mbyhyZWYtPm5ld19zaGExLCBOVUxMKTsKCWlmICh0eXBlIDwgMCkKCQlkaWUoIm9iamVjdCAlcyBub3QgZm91bmQiLCBzaGExX3RvX2hleChyZWYtPm5ld19zaGExKSk7CgoJaWYgKCEqcmVmLT5uYW1lKSB7CgkJLyogTm90IHN0b3JpbmcgKi8KCQlpZiAodmVyYm9zZSkgewoJCQlmcHJpbnRmKHN0ZGVyciwgIiogZmV0Y2hlZCAlc1xuIiwgbm90ZSk7CgkJCXNob3dfbmV3KHR5cGUsIHJlZi0+bmV3X3NoYTEpOwoJCX0KCQlyZXR1cm4gMDsKCX0KCglpZiAoIWhhc2hjbXAocmVmLT5vbGRfc2hhMSwgcmVmLT5uZXdfc2hhMSkpIHsKCQlpZiAodmVyYm9zZSkgewoJCQlmcHJpbnRmKHN0ZGVyciwgIiogJXM6IHNhbWUgYXMgJXNcbiIsCgkJCQlyZWYtPm5hbWUsIG5vdGUpOwoJCQlzaG93X25ldyh0eXBlLCByZWYtPm5ld19zaGExKTsKCQl9CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKGN1cnJlbnRfYnJhbmNoICYmCgkgICAgIXN0cmNtcChyZWYtPm5hbWUsIGN1cnJlbnRfYnJhbmNoLT5uYW1lKSAmJgoJICAgICEodXBkYXRlX2hlYWRfb2sgfHwgaXNfYmFyZV9yZXBvc2l0b3J5KCkpICYmCgkgICAgIWlzX251bGxfc2hhMShyZWYtPm9sZF9zaGExKSkgewoJCS8qCgkJICogSWYgdGhpcyBpcyB0aGUgaGVhZCwgYW5kIGl0J3Mgbm90IG9rYXkgdG8gdXBkYXRlCgkJICogdGhlIGhlYWQsIGFuZCB0aGUgb2xkIHZhbHVlIG9mIHRoZSBoZWFkIGlzbid0IGVtcHR5Li4uCgkJICovCgkJZnByaW50ZihzdGRlcnIsCgkJCSIgKiAlczogQ2Fubm90IGZldGNoIGludG8gdGhlIGN1cnJlbnQgYnJhbmNoLlxuIiwKCQkJcmVmLT5uYW1lKTsKCQlyZXR1cm4gMTsKCX0KCglpZiAoIWlzX251bGxfc2hhMShyZWYtPm9sZF9zaGExKSAmJgoJICAgICFwcmVmaXhjbXAocmVmLT5uYW1lLCAicmVmcy90YWdzLyIpKSB7CgkJZnByaW50ZihzdGRlcnIsICIqICVzOiB1cGRhdGluZyB3aXRoICVzXG4iLAoJCQlyZWYtPm5hbWUsIG5vdGUpOwoJCXNob3dfbmV3KHR5cGUsIHJlZi0+bmV3X3NoYTEpOwoJCXJldHVybiBzX3VwZGF0ZV9yZWYoInVwZGF0aW5nIHRhZyIsIHJlZiwgMCk7Cgl9CgoJY3VycmVudCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseShyZWYtPm9sZF9zaGExLCAxKTsKCXVwZGF0ZWQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkocmVmLT5uZXdfc2hhMSwgMSk7CglpZiAoIWN1cnJlbnQgfHwgIXVwZGF0ZWQpIHsKCQljaGFyICptc2c7CgkJaWYgKCFzdHJuY21wKHJlZi0+bmFtZSwgInJlZnMvdGFncy8iLCAxMCkpCgkJCW1zZyA9ICJzdG9yaW5nIHRhZyI7CgkJZWxzZQoJCQltc2cgPSAic3RvcmluZyBoZWFkIjsKCQlmcHJpbnRmKHN0ZGVyciwgIiogJXM6IHN0b3JpbmcgJXNcbiIsCgkJCXJlZi0+bmFtZSwgbm90ZSk7CgkJc2hvd19uZXcodHlwZSwgcmVmLT5uZXdfc2hhMSk7CgkJcmV0dXJuIHNfdXBkYXRlX3JlZihtc2csIHJlZiwgMCk7Cgl9CgoJc3RyY3B5KG9sZGgsIGZpbmRfdW5pcXVlX2FiYnJldihjdXJyZW50LT5vYmplY3Quc2hhMSwgREVGQVVMVF9BQkJSRVYpKTsKCXN0cmNweShuZXdoLCBmaW5kX3VuaXF1ZV9hYmJyZXYocmVmLT5uZXdfc2hhMSwgREVGQVVMVF9BQkJSRVYpKTsKCglpZiAoaW5fbWVyZ2VfYmFzZXMoY3VycmVudCwgJnVwZGF0ZWQsIDEpKSB7CgkJZnByaW50ZihzdGRlcnIsICIqICVzOiBmYXN0IGZvcndhcmQgdG8gJXNcbiIsCgkJCXJlZi0+bmFtZSwgbm90ZSk7CgkJZnByaW50ZihzdGRlcnIsICIgIG9sZC4ubmV3OiAlcy4uJXNcbiIsIG9sZGgsIG5ld2gpOwoJCXJldHVybiBzX3VwZGF0ZV9yZWYoImZhc3QgZm9yd2FyZCIsIHJlZiwgMSk7Cgl9CglpZiAoIWZvcmNlICYmICFyZWYtPmZvcmNlKSB7CgkJZnByaW50ZihzdGRlcnIsCgkJCSIqICVzOiBub3QgdXBkYXRpbmcgdG8gbm9uLWZhc3QgZm9yd2FyZCAlc1xuIiwKCQkJcmVmLT5uYW1lLCBub3RlKTsKCQlmcHJpbnRmKHN0ZGVyciwKCQkJIiAgb2xkLi4ubmV3OiAlcy4uLiVzXG4iLCBvbGRoLCBuZXdoKTsKCQlyZXR1cm4gMTsKCX0KCWZwcmludGYoc3RkZXJyLAoJCSIqICVzOiBmb3JjaW5nIHVwZGF0ZSB0byBub24tZmFzdCBmb3J3YXJkICVzXG4iLAoJCXJlZi0+bmFtZSwgbm90ZSk7CglmcHJpbnRmKHN0ZGVyciwgIiAgb2xkLi4ubmV3OiAlcy4uLiVzXG4iLCBvbGRoLCBuZXdoKTsKCXJldHVybiBzX3VwZGF0ZV9yZWYoImZvcmNlZC11cGRhdGUiLCByZWYsIDEpOwp9CgpzdGF0aWMgdm9pZCBzdG9yZV91cGRhdGVkX3JlZnMoY29uc3QgY2hhciAqdXJsLCBzdHJ1Y3QgcmVmICpyZWZfbWFwKQp7CglGSUxFICpmcDsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCWludCB1cmxfbGVuLCBpLCBub3RlX2xlbjsKCWNoYXIgbm90ZVsxMDI0XTsKCWNvbnN0IGNoYXIgKndoYXQsICpraW5kOwoJc3RydWN0IHJlZiAqcm07CgoJZnAgPSBmb3BlbihnaXRfcGF0aCgiRkVUQ0hfSEVBRCIpLCAiYSIpOwoJZm9yIChybSA9IHJlZl9tYXA7IHJtOyBybSA9IHJtLT5uZXh0KSB7CgkJc3RydWN0IHJlZiAqcmVmID0gTlVMTDsKCgkJaWYgKHJtLT5wZWVyX3JlZikgewoJCQlyZWYgPSB4Y2FsbG9jKDEsIHNpemVvZigqcmVmKSArIHN0cmxlbihybS0+cGVlcl9yZWYtPm5hbWUpICsgMSk7CgkJCXN0cmNweShyZWYtPm5hbWUsIHJtLT5wZWVyX3JlZi0+bmFtZSk7CgkJCWhhc2hjcHkocmVmLT5vbGRfc2hhMSwgcm0tPnBlZXJfcmVmLT5vbGRfc2hhMSk7CgkJCWhhc2hjcHkocmVmLT5uZXdfc2hhMSwgcm0tPm9sZF9zaGExKTsKCQkJcmVmLT5mb3JjZSA9IHJtLT5wZWVyX3JlZi0+Zm9yY2U7CgkJfQoKCQljb21taXQgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkocm0tPm9sZF9zaGExLCAxKTsKCQlpZiAoIWNvbW1pdCkKCQkJcm0tPm1lcmdlID0gMDsKCgkJaWYgKCFzdHJjbXAocm0tPm5hbWUsICJIRUFEIikpIHsKCQkJa2luZCA9ICIiOwoJCQl3aGF0ID0gIiI7CgkJfQoJCWVsc2UgaWYgKCFwcmVmaXhjbXAocm0tPm5hbWUsICJyZWZzL2hlYWRzLyIpKSB7CgkJCWtpbmQgPSAiYnJhbmNoIjsKCQkJd2hhdCA9IHJtLT5uYW1lICsgMTE7CgkJfQoJCWVsc2UgaWYgKCFwcmVmaXhjbXAocm0tPm5hbWUsICJyZWZzL3RhZ3MvIikpIHsKCQkJa2luZCA9ICJ0YWciOwoJCQl3aGF0ID0gcm0tPm5hbWUgKyAxMDsKCQl9CgkJZWxzZSBpZiAoIXByZWZpeGNtcChybS0+bmFtZSwgInJlZnMvcmVtb3Rlcy8iKSkgewoJCQlraW5kID0gInJlbW90ZSBicmFuY2giOwoJCQl3aGF0ID0gcm0tPm5hbWUgKyAxMzsKCQl9CgkJZWxzZSB7CgkJCWtpbmQgPSAiIjsKCQkJd2hhdCA9IHJtLT5uYW1lOwoJCX0KCgkJdXJsX2xlbiA9IHN0cmxlbih1cmwpOwoJCWZvciAoaSA9IHVybF9sZW4gLSAxOyB1cmxbaV0gPT0gJy8nICYmIDAgPD0gaTsgaS0tKQoJCQk7CgkJdXJsX2xlbiA9IGkgKyAxOwoJCWlmICg0IDwgaSAmJiAhc3RybmNtcCgiLmdpdCIsIHVybCArIGkgLSAzLCA0KSkKCQkJdXJsX2xlbiA9IGkgLSAzOwoKCQlub3RlX2xlbiA9IDA7CgkJaWYgKCp3aGF0KSB7CgkJCWlmICgqa2luZCkKCQkJCW5vdGVfbGVuICs9IHNwcmludGYobm90ZSArIG5vdGVfbGVuLCAiJXMgIiwKCQkJCQkJICAgIGtpbmQpOwoJCQlub3RlX2xlbiArPSBzcHJpbnRmKG5vdGUgKyBub3RlX2xlbiwgIiclcycgb2YgIiwgd2hhdCk7CgkJfQoJCW5vdGVfbGVuICs9IHNwcmludGYobm90ZSArIG5vdGVfbGVuLCAiJS4qcyIsIHVybF9sZW4sIHVybCk7CgkJZnByaW50ZihmcCwgIiVzXHQlc1x0JXNcbiIsCgkJCXNoYTFfdG9faGV4KGNvbW1pdCA/IGNvbW1pdC0+b2JqZWN0LnNoYTEgOgoJCQkJICAgIHJtLT5vbGRfc2hhMSksCgkJCXJtLT5tZXJnZSA/ICIiIDogIm5vdC1mb3ItbWVyZ2UiLAoJCQlub3RlKTsKCgkJaWYgKHJlZikKCQkJdXBkYXRlX2xvY2FsX3JlZihyZWYsIG5vdGUsIHZlcmJvc2UpOwoJfQoJZmNsb3NlKGZwKTsKfQoKc3RhdGljIGludCBmZXRjaF9yZWZzKHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCwgc3RydWN0IHJlZiAqcmVmX21hcCkKewoJaW50IHJldCA9IHRyYW5zcG9ydF9mZXRjaF9yZWZzKHRyYW5zcG9ydCwgcmVmX21hcCk7CglpZiAoIXJldCkKCQlzdG9yZV91cGRhdGVkX3JlZnModHJhbnNwb3J0LT51cmwsIHJlZl9tYXApOwoJdHJhbnNwb3J0X3VubG9ja19wYWNrKHRyYW5zcG9ydCk7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IGFkZF9leGlzdGluZyhjb25zdCBjaGFyICpyZWZuYW1lLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCQlpbnQgZmxhZywgdm9pZCAqY2JkYXRhKQp7CglzdHJ1Y3QgcGF0aF9saXN0ICpsaXN0ID0gKHN0cnVjdCBwYXRoX2xpc3QgKiljYmRhdGE7CglwYXRoX2xpc3RfaW5zZXJ0KHJlZm5hbWUsIGxpc3QpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVmICpmaW5kX25vbl9sb2NhbF90YWdzKHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCwKCQkJCSAgICAgICBzdHJ1Y3QgcmVmICpmZXRjaF9tYXApCnsKCXN0YXRpYyBzdHJ1Y3QgcGF0aF9saXN0IGV4aXN0aW5nX3JlZnMgPSB7IE5VTEwsIDAsIDAsIDAgfTsKCXN0cnVjdCBwYXRoX2xpc3QgbmV3X3JlZnMgPSB7IE5VTEwsIDAsIDAsIDEgfTsKCWNoYXIgKnJlZl9uYW1lOwoJaW50IHJlZl9uYW1lX2xlbjsKCXVuc2lnbmVkIGNoYXIgKnJlZl9zaGExOwoJc3RydWN0IHJlZiAqdGFnX3JlZjsKCXN0cnVjdCByZWYgKnJtID0gTlVMTDsKCXN0cnVjdCByZWYgKnJlZl9tYXAgPSBOVUxMOwoJc3RydWN0IHJlZiAqKnRhaWwgPSAmcmVmX21hcDsKCXN0cnVjdCByZWYgKnJlZjsKCglmb3JfZWFjaF9yZWYoYWRkX2V4aXN0aW5nLCAmZXhpc3RpbmdfcmVmcyk7Cglmb3IgKHJlZiA9IHRyYW5zcG9ydF9nZXRfcmVtb3RlX3JlZnModHJhbnNwb3J0KTsgcmVmOyByZWYgPSByZWYtPm5leHQpIHsKCQlpZiAocHJlZml4Y21wKHJlZi0+bmFtZSwgInJlZnMvdGFncyIpKQoJCQljb250aW51ZTsKCgkJcmVmX25hbWUgPSB4c3RyZHVwKHJlZi0+bmFtZSk7CgkJcmVmX25hbWVfbGVuID0gc3RybGVuKHJlZl9uYW1lKTsKCQlyZWZfc2hhMSA9IHJlZi0+b2xkX3NoYTE7CgoJCWlmICghc3RyY21wKHJlZl9uYW1lICsgcmVmX25hbWVfbGVuIC0gMywgIl57fSIpKSB7CgkJCXJlZl9uYW1lW3JlZl9uYW1lX2xlbiAtIDNdID0gMDsKCQkJdGFnX3JlZiA9IHRyYW5zcG9ydF9nZXRfcmVtb3RlX3JlZnModHJhbnNwb3J0KTsKCQkJd2hpbGUgKHRhZ19yZWYpIHsKCQkJCWlmICghc3RyY21wKHRhZ19yZWYtPm5hbWUsIHJlZl9uYW1lKSkgewoJCQkJCXJlZl9zaGExID0gdGFnX3JlZi0+b2xkX3NoYTE7CgkJCQkJYnJlYWs7CgkJCQl9CgkJCQl0YWdfcmVmID0gdGFnX3JlZi0+bmV4dDsKCQkJfQoJCX0KCgkJaWYgKCFwYXRoX2xpc3RfaGFzX3BhdGgoJmV4aXN0aW5nX3JlZnMsIHJlZl9uYW1lKSAmJgoJCSAgICAhcGF0aF9saXN0X2hhc19wYXRoKCZuZXdfcmVmcywgcmVmX25hbWUpICYmCgkJICAgIGxvb2t1cF9vYmplY3QocmVmLT5vbGRfc2hhMSkpIHsKCQkJZnByaW50ZihzdGRlcnIsICJBdXRvLWZvbGxvd2luZyAlc1xuIiwKCQkJCXJlZl9uYW1lKTsKCgkJCXBhdGhfbGlzdF9pbnNlcnQocmVmX25hbWUsICZuZXdfcmVmcyk7CgoJCQlybSA9IGFsbG9jX3JlZihzdHJsZW4ocmVmX25hbWUpICsgMSk7CgkJCXN0cmNweShybS0+bmFtZSwgcmVmX25hbWUpOwoJCQlybS0+cGVlcl9yZWYgPSBhbGxvY19yZWYoc3RybGVuKHJlZl9uYW1lKSArIDEpOwoJCQlzdHJjcHkocm0tPnBlZXJfcmVmLT5uYW1lLCByZWZfbmFtZSk7CgkJCWhhc2hjcHkocm0tPm9sZF9zaGExLCByZWZfc2hhMSk7CgoJCQkqdGFpbCA9IHJtOwoJCQl0YWlsID0gJnJtLT5uZXh0OwoJCX0KCQlmcmVlKHJlZl9uYW1lKTsKCX0KCglyZXR1cm4gcmVmX21hcDsKfQoKc3RhdGljIGludCBkb19mZXRjaChzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsCgkJICAgIHN0cnVjdCByZWZzcGVjICpyZWZzLCBpbnQgcmVmX2NvdW50KQp7CglzdHJ1Y3QgcmVmICpyZWZfbWFwLCAqZmV0Y2hfbWFwOwoJc3RydWN0IHJlZiAqcm07CglpbnQgYXV0b3RhZ3MgPSAodHJhbnNwb3J0LT5yZW1vdGUtPmZldGNoX3RhZ3MgPT0gMSk7CglpZiAodHJhbnNwb3J0LT5yZW1vdGUtPmZldGNoX3RhZ3MgPT0gMiAmJiAhbm9fdGFncykKCQl0YWdzID0gMTsKCWlmICh0cmFuc3BvcnQtPnJlbW90ZS0+ZmV0Y2hfdGFncyA9PSAtMSkKCQlub190YWdzID0gMTsKCglpZiAoIXRyYW5zcG9ydC0+Z2V0X3JlZnNfbGlzdCB8fCAhdHJhbnNwb3J0LT5mZXRjaCkKCQlkaWUoIkRvbid0IGtub3cgaG93IHRvIGZldGNoIGZyb20gJXMiLCB0cmFuc3BvcnQtPnVybCk7CgoJLyogaWYgbm90IGFwcGVuZGluZywgdHJ1bmNhdGUgRkVUQ0hfSEVBRCAqLwoJaWYgKCFhcHBlbmQpCgkJZmNsb3NlKGZvcGVuKGdpdF9wYXRoKCJGRVRDSF9IRUFEIiksICJ3IikpOwoKCXJlZl9tYXAgPSBnZXRfcmVmX21hcCh0cmFuc3BvcnQsIHJlZnMsIHJlZl9jb3VudCwgdGFncywgJmF1dG90YWdzKTsKCglmb3IgKHJtID0gcmVmX21hcDsgcm07IHJtID0gcm0tPm5leHQpIHsKCQlpZiAocm0tPnBlZXJfcmVmKQoJCQlyZWFkX3JlZihybS0+cGVlcl9yZWYtPm5hbWUsIHJtLT5wZWVyX3JlZi0+b2xkX3NoYTEpOwoJfQoKCWlmIChmZXRjaF9yZWZzKHRyYW5zcG9ydCwgcmVmX21hcCkpIHsKCQlmcmVlX3JlZnMocmVmX21hcCk7CgkJcmV0dXJuIDE7Cgl9CgoJZmV0Y2hfbWFwID0gcmVmX21hcDsKCgkvKiBpZiBuZWl0aGVyIC0tbm8tdGFncyBub3IgLS10YWdzIHdhcyBzcGVjaWZpZWQsIGRvIGF1dG9tYXRlZCB0YWcKCSAqIGZvbGxvd2luZyAuLi4gKi8KCWlmICghKHRhZ3MgfHwgbm9fdGFncykgJiYgYXV0b3RhZ3MpIHsKCQlyZWZfbWFwID0gZmluZF9ub25fbG9jYWxfdGFncyh0cmFuc3BvcnQsIGZldGNoX21hcCk7CgkJaWYgKHJlZl9tYXApIHsKCQkJdHJhbnNwb3J0X3NldF9vcHRpb24odHJhbnNwb3J0LCBUUkFOU19PUFRfREVQVEgsICIwIik7CgkJCWZldGNoX3JlZnModHJhbnNwb3J0LCByZWZfbWFwKTsKCQl9CgkJZnJlZV9yZWZzKHJlZl9tYXApOwoJfQoKCWZyZWVfcmVmcyhmZXRjaF9tYXApOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBzZXRfb3B0aW9uKGNvbnN0IGNoYXIgKm5hbWUsIGNvbnN0IGNoYXIgKnZhbHVlKQp7CglpbnQgciA9IHRyYW5zcG9ydF9zZXRfb3B0aW9uKHRyYW5zcG9ydCwgbmFtZSwgdmFsdWUpOwoJaWYgKHIgPCAwKQoJCWRpZSgiT3B0aW9uIFwiJXNcIiB2YWx1ZSBcIiVzXCIgaXMgbm90IHZhbGlkIGZvciAlc1xuIiwKCQkJbmFtZSwgdmFsdWUsIHRyYW5zcG9ydC0+dXJsKTsKCWlmIChyID4gMCkKCQl3YXJuaW5nKCJPcHRpb24gXCIlc1wiIGlzIGlnbm9yZWQgZm9yICVzXG4iLAoJCQluYW1lLCB0cmFuc3BvcnQtPnVybCk7Cn0KCmludCBjbWRfZmV0Y2goaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0cnVjdCByZW1vdGUgKnJlbW90ZTsKCWludCBpLCBqLCBybGFfb2Zmc2V0OwoJc3RhdGljIGNvbnN0IGNoYXIgKipyZWZzID0gTlVMTDsKCWludCByZWZfbnIgPSAwOwoJaW50IGNtZF9sZW4gPSAwOwoJY29uc3QgY2hhciAqZGVwdGggPSBOVUxMLCAqdXBsb2FkX3BhY2sgPSBOVUxMOwoJaW50IGtlZXAgPSAwOwoKCWZvciAoaSA9IDE7IGkgPCBhcmdjOyBpKyspIHsKCQljb25zdCBjaGFyICphcmcgPSBhcmd2W2ldOwoJCWNtZF9sZW4gKz0gc3RybGVuKGFyZyk7CgoJCWlmIChhcmdbMF0gIT0gJy0nKQoJCQlicmVhazsKCQlpZiAoIXN0cmNtcChhcmcsICItLWFwcGVuZCIpIHx8ICFzdHJjbXAoYXJnLCAiLWEiKSkgewoJCQlhcHBlbmQgPSAxOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKCFwcmVmaXhjbXAoYXJnLCAiLS11cGxvYWQtcGFjaz0iKSkgewoJCQl1cGxvYWRfcGFjayA9IGFyZyArIDE0OwoJCQljb250aW51ZTsKCQl9CgkJaWYgKCFzdHJjbXAoYXJnLCAiLS11cGxvYWQtcGFjayIpKSB7CgkJCWkrKzsKCQkJaWYgKGkgPT0gYXJnYykKCQkJCXVzYWdlKGZldGNoX3VzYWdlKTsKCQkJdXBsb2FkX3BhY2sgPSBhcmd2W2ldOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKCFzdHJjbXAoYXJnLCAiLS1mb3JjZSIpIHx8ICFzdHJjbXAoYXJnLCAiLWYiKSkgewoJCQlmb3JjZSA9IDE7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoIXN0cmNtcChhcmcsICItLW5vLXRhZ3MiKSkgewoJCQlub190YWdzID0gMTsKCQkJY29udGludWU7CgkJfQoJCWlmICghc3RyY21wKGFyZywgIi0tdGFncyIpIHx8ICFzdHJjbXAoYXJnLCAiLXQiKSkgewoJCQl0YWdzID0gMTsKCQkJY29udGludWU7CgkJfQoJCWlmICghc3RyY21wKGFyZywgIi0ta2VlcCIpIHx8ICFzdHJjbXAoYXJnLCAiLWsiKSkgewoJCQlrZWVwID0gMTsKCQkJY29udGludWU7CgkJfQoJCWlmICghc3RyY21wKGFyZywgIi0tdXBkYXRlLWhlYWQtb2siKSB8fCAhc3RyY21wKGFyZywgIi11IikpIHsKCQkJdXBkYXRlX2hlYWRfb2sgPSAxOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKCFwcmVmaXhjbXAoYXJnLCAiLS1kZXB0aD0iKSkgewoJCQlkZXB0aCA9IGFyZyArIDg7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoIXN0cmNtcChhcmcsICItLWRlcHRoIikpIHsKCQkJaSsrOwoJCQlpZiAoaSA9PSBhcmdjKQoJCQkJdXNhZ2UoZmV0Y2hfdXNhZ2UpOwoJCQlkZXB0aCA9IGFyZ3ZbaV07CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoIXN0cmNtcChhcmcsICItLXF1aWV0IikpIHsKCQkJcXVpZXQgPSAxOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKCFzdHJjbXAoYXJnLCAiLS12ZXJib3NlIikgfHwgIXN0cmNtcChhcmcsICItdiIpKSB7CgkJCXZlcmJvc2UrKzsKCQkJY29udGludWU7CgkJfQoJCXVzYWdlKGZldGNoX3VzYWdlKTsKCX0KCglmb3IgKGogPSBpOyBqIDwgYXJnYzsgaisrKQoJCWNtZF9sZW4gKz0gc3RybGVuKGFyZ3Zbal0pOwoKCWRlZmF1bHRfcmxhID0geG1hbGxvYyhjbWRfbGVuICsgNSArIGFyZ2MgKyAxKTsKCXNwcmludGYoZGVmYXVsdF9ybGEsICJmZXRjaCIpOwoJcmxhX29mZnNldCA9IHN0cmxlbihkZWZhdWx0X3JsYSk7Cglmb3IgKGogPSAxOyBqIDwgYXJnYzsgaisrKSB7CgkJc3ByaW50ZihkZWZhdWx0X3JsYSArIHJsYV9vZmZzZXQsICIgJXMiLCBhcmd2W2pdKTsKCQlybGFfb2Zmc2V0ICs9IHN0cmxlbihhcmd2W2pdKSArIDE7Cgl9CgoJaWYgKGkgPT0gYXJnYykKCQlyZW1vdGUgPSByZW1vdGVfZ2V0KE5VTEwpOwoJZWxzZQoJCXJlbW90ZSA9IHJlbW90ZV9nZXQoYXJndltpKytdKTsKCgl0cmFuc3BvcnQgPSB0cmFuc3BvcnRfZ2V0KHJlbW90ZSwgcmVtb3RlLT51cmxbMF0pOwoJaWYgKHZlcmJvc2UgPj0gMikKCQl0cmFuc3BvcnQtPnZlcmJvc2UgPSAxOwoJaWYgKHF1aWV0KQoJCXRyYW5zcG9ydC0+dmVyYm9zZSA9IC0xOwoJaWYgKHVwbG9hZF9wYWNrKQoJCXNldF9vcHRpb24oVFJBTlNfT1BUX1VQTE9BRFBBQ0ssIHVwbG9hZF9wYWNrKTsKCWlmIChrZWVwKQoJCXNldF9vcHRpb24oVFJBTlNfT1BUX0tFRVAsICJ5ZXMiKTsKCWlmIChkZXB0aCkKCQlzZXRfb3B0aW9uKFRSQU5TX09QVF9ERVBUSCwgZGVwdGgpOwoKCWlmICghdHJhbnNwb3J0LT51cmwpCgkJZGllKCJXaGVyZSBkbyB5b3Ugd2FudCB0byBmZXRjaCBmcm9tIHRvZGF5PyIpOwoKCWlmIChpIDwgYXJnYykgewoJCWludCBqID0gMDsKCQlyZWZzID0geGNhbGxvYyhhcmdjIC0gaSArIDEsIHNpemVvZihjb25zdCBjaGFyICopKTsKCQl3aGlsZSAoaSA8IGFyZ2MpIHsKCQkJaWYgKCFzdHJjbXAoYXJndltpXSwgInRhZyIpKSB7CgkJCQljaGFyICpyZWY7CgkJCQlpKys7CgkJCQlyZWYgPSB4bWFsbG9jKHN0cmxlbihhcmd2W2ldKSAqIDIgKyAyMik7CgkJCQlzdHJjcHkocmVmLCAicmVmcy90YWdzLyIpOwoJCQkJc3RyY2F0KHJlZiwgYXJndltpXSk7CgkJCQlzdHJjYXQocmVmLCAiOnJlZnMvdGFncy8iKTsKCQkJCXN0cmNhdChyZWYsIGFyZ3ZbaV0pOwoJCQkJcmVmc1tqKytdID0gcmVmOwoJCQl9IGVsc2UKCQkJCXJlZnNbaisrXSA9IGFyZ3ZbaV07CgkJCWkrKzsKCQl9CgkJcmVmc1tqXSA9IE5VTEw7CgkJcmVmX25yID0gajsKCX0KCglzaWduYWwoU0lHSU5ULCB1bmxvY2tfcGFja19vbl9zaWduYWwpOwoJYXRleGl0KHVubG9ja19wYWNrKTsKCXJldHVybiBkb19mZXRjaCh0cmFuc3BvcnQsIHBhcnNlX3JlZl9zcGVjKHJlZl9uciwgcmVmcyksIHJlZl9ucik7Cn0K",
    "text": "/*\n * \"git fetch\"\n */\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"commit.h\"\n#include \"builtin.h\"\n#include \"path-list.h\"\n#include \"remote.h\"\n#include \"transport.h\"\n\nstatic const char fetch_usage[] = \"git-fetch [-a | --append] [--upload-pack <upload-pack>] [-f | --force] [--no-tags] [-t | --tags] [-k | --keep] [-u | --update-head-ok] [--depth <depth>] [-v | --verbose] [<repository> <refspec>...]\";\n\nstatic int append, force, tags, no_tags, update_head_ok, verbose, quiet;\nstatic char *default_rla = NULL;\nstatic struct transport *transport;\n\nstatic void unlock_pack(void)\n{\n\tif (transport)\n\t\ttransport_unlock_pack(transport);\n}\n\nstatic void unlock_pack_on_signal(int signo)\n{\n\tunlock_pack();\n\tsignal(SIGINT, SIG_DFL);\n\traise(signo);\n}\n\nstatic void add_merge_config(struct ref **head,\n\t\t           struct ref *remote_refs,\n\t\t           struct branch *branch,\n\t\t           struct ref ***tail)\n{\n\tint i;\n\n\tfor (i = 0; i < branch->merge_nr; i++) {\n\t\tstruct ref *rm, **old_tail = *tail;\n\t\tstruct refspec refspec;\n\n\t\tfor (rm = *head; rm; rm = rm->next) {\n\t\t\tif (branch_merge_matches(branch, i, rm->name)) {\n\t\t\t\trm->merge = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (rm)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Not fetched to a tracking branch?  We need to fetch\n\t\t * it anyway to allow this branch's \"branch.$name.merge\"\n\t\t * to be honored by git-pull, but we do not have to\n\t\t * fail if branch.$name.merge is misconfigured to point\n\t\t * at a nonexisting branch.  If we were indeed called by\n\t\t * git-pull, it will notice the misconfiguration because\n\t\t * there is no entry in the resulting FETCH_HEAD marked\n\t\t * for merging.\n\t\t */\n\t\trefspec.src = branch->merge[i]->src;\n\t\trefspec.dst = NULL;\n\t\trefspec.pattern = 0;\n\t\trefspec.force = 0;\n\t\tget_fetch_map(remote_refs, &refspec, tail, 1);\n\t\tfor (rm = *old_tail; rm; rm = rm->next)\n\t\t\trm->merge = 1;\n\t}\n}\n\nstatic struct ref *get_ref_map(struct transport *transport,\n\t\t\t       struct refspec *refs, int ref_count, int tags,\n\t\t\t       int *autotags)\n{\n\tint i;\n\tstruct ref *rm;\n\tstruct ref *ref_map = NULL;\n\tstruct ref **tail = &ref_map;\n\n\tstruct ref *remote_refs = transport_get_remote_refs(transport);\n\n\tif (ref_count || tags) {\n\t\tfor (i = 0; i < ref_count; i++) {\n\t\t\tget_fetch_map(remote_refs, &refs[i], &tail, 0);\n\t\t\tif (refs[i].dst && refs[i].dst[0])\n\t\t\t\t*autotags = 1;\n\t\t}\n\t\t/* Merge everything on the command line, but not --tags */\n\t\tfor (rm = ref_map; rm; rm = rm->next)\n\t\t\trm->merge = 1;\n\t\tif (tags) {\n\t\t\tstruct refspec refspec;\n\t\t\trefspec.src = \"refs/tags/\";\n\t\t\trefspec.dst = \"refs/tags/\";\n\t\t\trefspec.pattern = 1;\n\t\t\trefspec.force = 0;\n\t\t\tget_fetch_map(remote_refs, &refspec, &tail, 0);\n\t\t}\n\t} else {\n\t\t/* Use the defaults */\n\t\tstruct remote *remote = transport->remote;\n\t\tstruct branch *branch = branch_get(NULL);\n\t\tint has_merge = branch_has_merge_config(branch);\n\t\tif (remote && (remote->fetch_refspec_nr || has_merge)) {\n\t\t\tfor (i = 0; i < remote->fetch_refspec_nr; i++) {\n\t\t\t\tget_fetch_map(remote_refs, &remote->fetch[i], &tail, 0);\n\t\t\t\tif (remote->fetch[i].dst &&\n\t\t\t\t    remote->fetch[i].dst[0])\n\t\t\t\t\t*autotags = 1;\n\t\t\t\tif (!i && !has_merge && ref_map &&\n\t\t\t\t    !remote->fetch[0].pattern)\n\t\t\t\t\tref_map->merge = 1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * if the remote we're fetching from is the same\n\t\t\t * as given in branch.<name>.remote, we add the\n\t\t\t * ref given in branch.<name>.merge, too.\n\t\t\t */\n\t\t\tif (has_merge &&\n\t\t\t    !strcmp(branch->remote_name, remote->name))\n\t\t\t\tadd_merge_config(&ref_map, remote_refs, branch, &tail);\n\t\t} else {\n\t\t\tref_map = get_remote_ref(remote_refs, \"HEAD\");\n\t\t\tif (!ref_map)\n\t\t\t\tdie(\"Couldn't find remote ref HEAD\");\n\t\t\tref_map->merge = 1;\n\t\t}\n\t}\n\tref_remove_duplicates(ref_map);\n\n\treturn ref_map;\n}\n\nstatic void show_new(enum object_type type, unsigned char *sha1_new)\n{\n\tfprintf(stderr, \"  %s: %s\\n\", typename(type),\n\t\tfind_unique_abbrev(sha1_new, DEFAULT_ABBREV));\n}\n\nstatic int s_update_ref(const char *action,\n\t\t\tstruct ref *ref,\n\t\t\tint check_old)\n{\n\tchar msg[1024];\n\tchar *rla = getenv(\"GIT_REFLOG_ACTION\");\n\tstatic struct ref_lock *lock;\n\n\tif (!rla)\n\t\trla = default_rla;\n\tsnprintf(msg, sizeof(msg), \"%s: %s\", rla, action);\n\tlock = lock_any_ref_for_update(ref->name,\n\t\t\t\t       check_old ? ref->old_sha1 : NULL, 0);\n\tif (!lock)\n\t\treturn 1;\n\tif (write_ref_sha1(lock, ref->new_sha1, msg) < 0)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int update_local_ref(struct ref *ref,\n\t\t\t    const char *note,\n\t\t\t    int verbose)\n{\n\tchar oldh[41], newh[41];\n\tstruct commit *current = NULL, *updated;\n\tenum object_type type;\n\tstruct branch *current_branch = branch_get(NULL);\n\n\ttype = sha1_object_info(ref->new_sha1, NULL);\n\tif (type < 0)\n\t\tdie(\"object %s not found\", sha1_to_hex(ref->new_sha1));\n\n\tif (!*ref->name) {\n\t\t/* Not storing */\n\t\tif (verbose) {\n\t\t\tfprintf(stderr, \"* fetched %s\\n\", note);\n\t\t\tshow_new(type, ref->new_sha1);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!hashcmp(ref->old_sha1, ref->new_sha1)) {\n\t\tif (verbose) {\n\t\t\tfprintf(stderr, \"* %s: same as %s\\n\",\n\t\t\t\tref->name, note);\n\t\t\tshow_new(type, ref->new_sha1);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (current_branch &&\n\t    !strcmp(ref->name, current_branch->name) &&\n\t    !(update_head_ok || is_bare_repository()) &&\n\t    !is_null_sha1(ref->old_sha1)) {\n\t\t/*\n\t\t * If this is the head, and it's not okay to update\n\t\t * the head, and the old value of the head isn't empty...\n\t\t */\n\t\tfprintf(stderr,\n\t\t\t\" * %s: Cannot fetch into the current branch.\\n\",\n\t\t\tref->name);\n\t\treturn 1;\n\t}\n\n\tif (!is_null_sha1(ref->old_sha1) &&\n\t    !prefixcmp(ref->name, \"refs/tags/\")) {\n\t\tfprintf(stderr, \"* %s: updating with %s\\n\",\n\t\t\tref->name, note);\n\t\tshow_new(type, ref->new_sha1);\n\t\treturn s_update_ref(\"updating tag\", ref, 0);\n\t}\n\n\tcurrent = lookup_commit_reference_gently(ref->old_sha1, 1);\n\tupdated = lookup_commit_reference_gently(ref->new_sha1, 1);\n\tif (!current || !updated) {\n\t\tchar *msg;\n\t\tif (!strncmp(ref->name, \"refs/tags/\", 10))\n\t\t\tmsg = \"storing tag\";\n\t\telse\n\t\t\tmsg = \"storing head\";\n\t\tfprintf(stderr, \"* %s: storing %s\\n\",\n\t\t\tref->name, note);\n\t\tshow_new(type, ref->new_sha1);\n\t\treturn s_update_ref(msg, ref, 0);\n\t}\n\n\tstrcpy(oldh, find_unique_abbrev(current->object.sha1, DEFAULT_ABBREV));\n\tstrcpy(newh, find_unique_abbrev(ref->new_sha1, DEFAULT_ABBREV));\n\n\tif (in_merge_bases(current, &updated, 1)) {\n\t\tfprintf(stderr, \"* %s: fast forward to %s\\n\",\n\t\t\tref->name, note);\n\t\tfprintf(stderr, \"  old..new: %s..%s\\n\", oldh, newh);\n\t\treturn s_update_ref(\"fast forward\", ref, 1);\n\t}\n\tif (!force && !ref->force) {\n\t\tfprintf(stderr,\n\t\t\t\"* %s: not updating to non-fast forward %s\\n\",\n\t\t\tref->name, note);\n\t\tfprintf(stderr,\n\t\t\t\"  old...new: %s...%s\\n\", oldh, newh);\n\t\treturn 1;\n\t}\n\tfprintf(stderr,\n\t\t\"* %s: forcing update to non-fast forward %s\\n\",\n\t\tref->name, note);\n\tfprintf(stderr, \"  old...new: %s...%s\\n\", oldh, newh);\n\treturn s_update_ref(\"forced-update\", ref, 1);\n}\n\nstatic void store_updated_refs(const char *url, struct ref *ref_map)\n{\n\tFILE *fp;\n\tstruct commit *commit;\n\tint url_len, i, note_len;\n\tchar note[1024];\n\tconst char *what, *kind;\n\tstruct ref *rm;\n\n\tfp = fopen(git_path(\"FETCH_HEAD\"), \"a\");\n\tfor (rm = ref_map; rm; rm = rm->next) {\n\t\tstruct ref *ref = NULL;\n\n\t\tif (rm->peer_ref) {\n\t\t\tref = xcalloc(1, sizeof(*ref) + strlen(rm->peer_ref->name) + 1);\n\t\t\tstrcpy(ref->name, rm->peer_ref->name);\n\t\t\thashcpy(ref->old_sha1, rm->peer_ref->old_sha1);\n\t\t\thashcpy(ref->new_sha1, rm->old_sha1);\n\t\t\tref->force = rm->peer_ref->force;\n\t\t}\n\n\t\tcommit = lookup_commit_reference_gently(rm->old_sha1, 1);\n\t\tif (!commit)\n\t\t\trm->merge = 0;\n\n\t\tif (!strcmp(rm->name, \"HEAD\")) {\n\t\t\tkind = \"\";\n\t\t\twhat = \"\";\n\t\t}\n\t\telse if (!prefixcmp(rm->name, \"refs/heads/\")) {\n\t\t\tkind = \"branch\";\n\t\t\twhat = rm->name + 11;\n\t\t}\n\t\telse if (!prefixcmp(rm->name, \"refs/tags/\")) {\n\t\t\tkind = \"tag\";\n\t\t\twhat = rm->name + 10;\n\t\t}\n\t\telse if (!prefixcmp(rm->name, \"refs/remotes/\")) {\n\t\t\tkind = \"remote branch\";\n\t\t\twhat = rm->name + 13;\n\t\t}\n\t\telse {\n\t\t\tkind = \"\";\n\t\t\twhat = rm->name;\n\t\t}\n\n\t\turl_len = strlen(url);\n\t\tfor (i = url_len - 1; url[i] == '/' && 0 <= i; i--)\n\t\t\t;\n\t\turl_len = i + 1;\n\t\tif (4 < i && !strncmp(\".git\", url + i - 3, 4))\n\t\t\turl_len = i - 3;\n\n\t\tnote_len = 0;\n\t\tif (*what) {\n\t\t\tif (*kind)\n\t\t\t\tnote_len += sprintf(note + note_len, \"%s \",\n\t\t\t\t\t\t    kind);\n\t\t\tnote_len += sprintf(note + note_len, \"'%s' of \", what);\n\t\t}\n\t\tnote_len += sprintf(note + note_len, \"%.*s\", url_len, url);\n\t\tfprintf(fp, \"%s\\t%s\\t%s\\n\",\n\t\t\tsha1_to_hex(commit ? commit->object.sha1 :\n\t\t\t\t    rm->old_sha1),\n\t\t\trm->merge ? \"\" : \"not-for-merge\",\n\t\t\tnote);\n\n\t\tif (ref)\n\t\t\tupdate_local_ref(ref, note, verbose);\n\t}\n\tfclose(fp);\n}\n\nstatic int fetch_refs(struct transport *transport, struct ref *ref_map)\n{\n\tint ret = transport_fetch_refs(transport, ref_map);\n\tif (!ret)\n\t\tstore_updated_refs(transport->url, ref_map);\n\ttransport_unlock_pack(transport);\n\treturn ret;\n}\n\nstatic int add_existing(const char *refname, const unsigned char *sha1,\n\t\t\tint flag, void *cbdata)\n{\n\tstruct path_list *list = (struct path_list *)cbdata;\n\tpath_list_insert(refname, list);\n\treturn 0;\n}\n\nstatic struct ref *find_non_local_tags(struct transport *transport,\n\t\t\t\t       struct ref *fetch_map)\n{\n\tstatic struct path_list existing_refs = { NULL, 0, 0, 0 };\n\tstruct path_list new_refs = { NULL, 0, 0, 1 };\n\tchar *ref_name;\n\tint ref_name_len;\n\tunsigned char *ref_sha1;\n\tstruct ref *tag_ref;\n\tstruct ref *rm = NULL;\n\tstruct ref *ref_map = NULL;\n\tstruct ref **tail = &ref_map;\n\tstruct ref *ref;\n\n\tfor_each_ref(add_existing, &existing_refs);\n\tfor (ref = transport_get_remote_refs(transport); ref; ref = ref->next) {\n\t\tif (prefixcmp(ref->name, \"refs/tags\"))\n\t\t\tcontinue;\n\n\t\tref_name = xstrdup(ref->name);\n\t\tref_name_len = strlen(ref_name);\n\t\tref_sha1 = ref->old_sha1;\n\n\t\tif (!strcmp(ref_name + ref_name_len - 3, \"^{}\")) {\n\t\t\tref_name[ref_name_len - 3] = 0;\n\t\t\ttag_ref = transport_get_remote_refs(transport);\n\t\t\twhile (tag_ref) {\n\t\t\t\tif (!strcmp(tag_ref->name, ref_name)) {\n\t\t\t\t\tref_sha1 = tag_ref->old_sha1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttag_ref = tag_ref->next;\n\t\t\t}\n\t\t}\n\n\t\tif (!path_list_has_path(&existing_refs, ref_name) &&\n\t\t    !path_list_has_path(&new_refs, ref_name) &&\n\t\t    lookup_object(ref->old_sha1)) {\n\t\t\tfprintf(stderr, \"Auto-following %s\\n\",\n\t\t\t\tref_name);\n\n\t\t\tpath_list_insert(ref_name, &new_refs);\n\n\t\t\trm = alloc_ref(strlen(ref_name) + 1);\n\t\t\tstrcpy(rm->name, ref_name);\n\t\t\trm->peer_ref = alloc_ref(strlen(ref_name) + 1);\n\t\t\tstrcpy(rm->peer_ref->name, ref_name);\n\t\t\thashcpy(rm->old_sha1, ref_sha1);\n\n\t\t\t*tail = rm;\n\t\t\ttail = &rm->next;\n\t\t}\n\t\tfree(ref_name);\n\t}\n\n\treturn ref_map;\n}\n\nstatic int do_fetch(struct transport *transport,\n\t\t    struct refspec *refs, int ref_count)\n{\n\tstruct ref *ref_map, *fetch_map;\n\tstruct ref *rm;\n\tint autotags = (transport->remote->fetch_tags == 1);\n\tif (transport->remote->fetch_tags == 2 && !no_tags)\n\t\ttags = 1;\n\tif (transport->remote->fetch_tags == -1)\n\t\tno_tags = 1;\n\n\tif (!transport->get_refs_list || !transport->fetch)\n\t\tdie(\"Don't know how to fetch from %s\", transport->url);\n\n\t/* if not appending, truncate FETCH_HEAD */\n\tif (!append)\n\t\tfclose(fopen(git_path(\"FETCH_HEAD\"), \"w\"));\n\n\tref_map = get_ref_map(transport, refs, ref_count, tags, &autotags);\n\n\tfor (rm = ref_map; rm; rm = rm->next) {\n\t\tif (rm->peer_ref)\n\t\t\tread_ref(rm->peer_ref->name, rm->peer_ref->old_sha1);\n\t}\n\n\tif (fetch_refs(transport, ref_map)) {\n\t\tfree_refs(ref_map);\n\t\treturn 1;\n\t}\n\n\tfetch_map = ref_map;\n\n\t/* if neither --no-tags nor --tags was specified, do automated tag\n\t * following ... */\n\tif (!(tags || no_tags) && autotags) {\n\t\tref_map = find_non_local_tags(transport, fetch_map);\n\t\tif (ref_map) {\n\t\t\ttransport_set_option(transport, TRANS_OPT_DEPTH, \"0\");\n\t\t\tfetch_refs(transport, ref_map);\n\t\t}\n\t\tfree_refs(ref_map);\n\t}\n\n\tfree_refs(fetch_map);\n\n\treturn 0;\n}\n\nstatic void set_option(const char *name, const char *value)\n{\n\tint r = transport_set_option(transport, name, value);\n\tif (r < 0)\n\t\tdie(\"Option \\\"%s\\\" value \\\"%s\\\" is not valid for %s\\n\",\n\t\t\tname, value, transport->url);\n\tif (r > 0)\n\t\twarning(\"Option \\\"%s\\\" is ignored for %s\\n\",\n\t\t\tname, transport->url);\n}\n\nint cmd_fetch(int argc, const char **argv, const char *prefix)\n{\n\tstruct remote *remote;\n\tint i, j, rla_offset;\n\tstatic const char **refs = NULL;\n\tint ref_nr = 0;\n\tint cmd_len = 0;\n\tconst char *depth = NULL, *upload_pack = NULL;\n\tint keep = 0;\n\n\tfor (i = 1; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\t\tcmd_len += strlen(arg);\n\n\t\tif (arg[0] != '-')\n\t\t\tbreak;\n\t\tif (!strcmp(arg, \"--append\") || !strcmp(arg, \"-a\")) {\n\t\t\tappend = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!prefixcmp(arg, \"--upload-pack=\")) {\n\t\t\tupload_pack = arg + 14;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--upload-pack\")) {\n\t\t\ti++;\n\t\t\tif (i == argc)\n\t\t\t\tusage(fetch_usage);\n\t\t\tupload_pack = argv[i];\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--force\") || !strcmp(arg, \"-f\")) {\n\t\t\tforce = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--no-tags\")) {\n\t\t\tno_tags = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--tags\") || !strcmp(arg, \"-t\")) {\n\t\t\ttags = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--keep\") || !strcmp(arg, \"-k\")) {\n\t\t\tkeep = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--update-head-ok\") || !strcmp(arg, \"-u\")) {\n\t\t\tupdate_head_ok = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!prefixcmp(arg, \"--depth=\")) {\n\t\t\tdepth = arg + 8;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--depth\")) {\n\t\t\ti++;\n\t\t\tif (i == argc)\n\t\t\t\tusage(fetch_usage);\n\t\t\tdepth = argv[i];\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--quiet\")) {\n\t\t\tquiet = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(arg, \"--verbose\") || !strcmp(arg, \"-v\")) {\n\t\t\tverbose++;\n\t\t\tcontinue;\n\t\t}\n\t\tusage(fetch_usage);\n\t}\n\n\tfor (j = i; j < argc; j++)\n\t\tcmd_len += strlen(argv[j]);\n\n\tdefault_rla = xmalloc(cmd_len + 5 + argc + 1);\n\tsprintf(default_rla, \"fetch\");\n\trla_offset = strlen(default_rla);\n\tfor (j = 1; j < argc; j++) {\n\t\tsprintf(default_rla + rla_offset, \" %s\", argv[j]);\n\t\trla_offset += strlen(argv[j]) + 1;\n\t}\n\n\tif (i == argc)\n\t\tremote = remote_get(NULL);\n\telse\n\t\tremote = remote_get(argv[i++]);\n\n\ttransport = transport_get(remote, remote->url[0]);\n\tif (verbose >= 2)\n\t\ttransport->verbose = 1;\n\tif (quiet)\n\t\ttransport->verbose = -1;\n\tif (upload_pack)\n\t\tset_option(TRANS_OPT_UPLOADPACK, upload_pack);\n\tif (keep)\n\t\tset_option(TRANS_OPT_KEEP, \"yes\");\n\tif (depth)\n\t\tset_option(TRANS_OPT_DEPTH, depth);\n\n\tif (!transport->url)\n\t\tdie(\"Where do you want to fetch from today?\");\n\n\tif (i < argc) {\n\t\tint j = 0;\n\t\trefs = xcalloc(argc - i + 1, sizeof(const char *));\n\t\twhile (i < argc) {\n\t\t\tif (!strcmp(argv[i], \"tag\")) {\n\t\t\t\tchar *ref;\n\t\t\t\ti++;\n\t\t\t\tref = xmalloc(strlen(argv[i]) * 2 + 22);\n\t\t\t\tstrcpy(ref, \"refs/tags/\");\n\t\t\t\tstrcat(ref, argv[i]);\n\t\t\t\tstrcat(ref, \":refs/tags/\");\n\t\t\t\tstrcat(ref, argv[i]);\n\t\t\t\trefs[j++] = ref;\n\t\t\t} else\n\t\t\t\trefs[j++] = argv[i];\n\t\t\ti++;\n\t\t}\n\t\trefs[j] = NULL;\n\t\tref_nr = j;\n\t}\n\n\tsignal(SIGINT, unlock_pack_on_signal);\n\tatexit(unlock_pack);\n\treturn do_fetch(transport, parse_ref_spec(ref_nr, refs), ref_nr);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "003ed76d16236ec6857a19d6223518e6e73bdc93",
  "sha1_ok": true,
  "size": 14649
}
