{
  "content": {
    "base64": "LyoKICogaWRlbnQuYwogKgogKiBjcmVhdGUgZ2l0IGlkZW50aWZpZXIgbGluZXMgb2YgdGhlIGZvcm0gIm5hbWUgPGVtYWlsPiBkYXRlIgogKgogKiBDb3B5cmlnaHQgKEMpIDIwMDUgTGludXMgVG9ydmFsZHMKICovCiNpbmNsdWRlICJjYWNoZS5oIgoKc3RhdGljIHN0cnVjdCBzdHJidWYgZ2l0X2RlZmF1bHRfbmFtZSA9IFNUUkJVRl9JTklUOwpzdGF0aWMgc3RydWN0IHN0cmJ1ZiBnaXRfZGVmYXVsdF9lbWFpbCA9IFNUUkJVRl9JTklUOwpzdGF0aWMgc3RydWN0IHN0cmJ1ZiBnaXRfZGVmYXVsdF9kYXRlID0gU1RSQlVGX0lOSVQ7CgojZGVmaW5lIElERU5UX05BTUVfR0lWRU4gMDEKI2RlZmluZSBJREVOVF9NQUlMX0dJVkVOIDAyCiNkZWZpbmUgSURFTlRfQUxMX0dJVkVOIChJREVOVF9OQU1FX0dJVkVOfElERU5UX01BSUxfR0lWRU4pCnN0YXRpYyBpbnQgY29tbWl0dGVyX2lkZW50X2V4cGxpY2l0bHlfZ2l2ZW47CnN0YXRpYyBpbnQgYXV0aG9yX2lkZW50X2V4cGxpY2l0bHlfZ2l2ZW47CgojaWZkZWYgTk9fR0VDT1NfSU5fUFdFTlQKI2RlZmluZSBnZXRfZ2Vjb3MoaWdub3JlZCkgIiYiCiNlbHNlCiNkZWZpbmUgZ2V0X2dlY29zKHN0cnVjdF9wYXNzd2QpICgoc3RydWN0X3Bhc3N3ZCktPnB3X2dlY29zKQojZW5kaWYKCnN0YXRpYyB2b2lkIGNvcHlfZ2Vjb3MoY29uc3Qgc3RydWN0IHBhc3N3ZCAqdywgc3RydWN0IHN0cmJ1ZiAqbmFtZSkKewoJY2hhciAqc3JjOwoKCS8qIFRyYWRpdGlvbmFsbHkgR0VDT1MgZmllbGQgaGFkIG9mZmljZSBwaG9uZSBudW1iZXJzIGV0Yywgc2VwYXJhdGVkCgkgKiB3aXRoIGNvbW1hcy4gIEFsc28gJiBzdGFuZHMgZm9yIGNhcGl0YWxpemVkIGZvcm0gb2YgdGhlIGxvZ2luIG5hbWUuCgkgKi8KCglmb3IgKHNyYyA9IGdldF9nZWNvcyh3KTsgKnNyYyAmJiAqc3JjICE9ICcsJzsgc3JjKyspIHsKCQlpbnQgY2ggPSAqc3JjOwoJCWlmIChjaCAhPSAnJicpCgkJCXN0cmJ1Zl9hZGRjaChuYW1lLCBjaCk7CgkJZWxzZSB7CgkJCS8qIFNvcnJ5LCBNci4gTWNEb25hbGQuLi4gKi8KCQkJc3RyYnVmX2FkZGNoKG5hbWUsIHRvdXBwZXIoKnctPnB3X25hbWUpKTsKCQkJc3RyYnVmX2FkZHN0cihuYW1lLCB3LT5wd19uYW1lICsgMSk7CgkJfQoJfQp9CgpzdGF0aWMgaW50IGFkZF9tYWlsbmFtZV9ob3N0KHN0cnVjdCBzdHJidWYgKmJ1ZikKewoJRklMRSAqbWFpbG5hbWU7CglzdHJ1Y3Qgc3RyYnVmIG1haWxuYW1lYnVmID0gU1RSQlVGX0lOSVQ7CgoJbWFpbG5hbWUgPSBmb3BlbigiL2V0Yy9tYWlsbmFtZSIsICJyIik7CglpZiAoIW1haWxuYW1lKSB7CgkJaWYgKGVycm5vICE9IEVOT0VOVCkKCQkJd2FybmluZygiY2Fubm90IG9wZW4gL2V0Yy9tYWlsbmFtZTogJXMiLAoJCQkJc3RyZXJyb3IoZXJybm8pKTsKCQlyZXR1cm4gLTE7Cgl9CglpZiAoc3RyYnVmX2dldGxpbmUoJm1haWxuYW1lYnVmLCBtYWlsbmFtZSwgJ1xuJykgPT0gRU9GKSB7CgkJaWYgKGZlcnJvcihtYWlsbmFtZSkpCgkJCXdhcm5pbmcoImNhbm5vdCByZWFkIC9ldGMvbWFpbG5hbWU6ICVzIiwKCQkJCXN0cmVycm9yKGVycm5vKSk7CgkJc3RyYnVmX3JlbGVhc2UoJm1haWxuYW1lYnVmKTsKCQlmY2xvc2UobWFpbG5hbWUpOwoJCXJldHVybiAtMTsKCX0KCS8qIHN1Y2Nlc3MhICovCglzdHJidWZfYWRkYnVmKGJ1ZiwgJm1haWxuYW1lYnVmKTsKCXN0cmJ1Zl9yZWxlYXNlKCZtYWlsbmFtZWJ1Zik7CglmY2xvc2UobWFpbG5hbWUpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgY2Fub25pY2FsX25hbWUoY29uc3QgY2hhciAqaG9zdCwgc3RydWN0IHN0cmJ1ZiAqb3V0KQp7CglpbnQgc3RhdHVzID0gLTE7CgojaWZuZGVmIE5PX0lQVjYKCXN0cnVjdCBhZGRyaW5mbyBoaW50cywgKmFpOwoJbWVtc2V0ICgmaGludHMsICdcMCcsIHNpemVvZiAoaGludHMpKTsKCWhpbnRzLmFpX2ZsYWdzID0gQUlfQ0FOT05OQU1FOwoJaWYgKCFnZXRhZGRyaW5mbyhob3N0LCBOVUxMLCAmaGludHMsICZhaSkpIHsKCQlpZiAoYWkgJiYgc3RyY2hyKGFpLT5haV9jYW5vbm5hbWUsICcuJykpIHsKCQkJc3RyYnVmX2FkZHN0cihvdXQsIGFpLT5haV9jYW5vbm5hbWUpOwoJCQlzdGF0dXMgPSAwOwoJCX0KCQlmcmVlYWRkcmluZm8oYWkpOwoJfQojZWxzZQoJc3RydWN0IGhvc3RlbnQgKmhlID0gZ2V0aG9zdGJ5bmFtZShob3N0KTsKCWlmIChoZSAmJiBzdHJjaHIoaGUtPmhfbmFtZSwgJy4nKSkgewoJCXN0cmJ1Zl9hZGRzdHIob3V0LCBoZS0+aF9uYW1lKTsKCQlzdGF0dXMgPSAwOwoJfQojZW5kaWYgLyogTk9fSVBWNiAqLwoKCXJldHVybiBzdGF0dXM7Cn0KCnN0YXRpYyB2b2lkIGFkZF9kb21haW5uYW1lKHN0cnVjdCBzdHJidWYgKm91dCkKewoJY2hhciBidWZbMTAyNF07CgoJaWYgKGdldGhvc3RuYW1lKGJ1Ziwgc2l6ZW9mKGJ1ZikpKSB7CgkJd2FybmluZygiY2Fubm90IGdldCBob3N0IG5hbWU6ICVzIiwgc3RyZXJyb3IoZXJybm8pKTsKCQlzdHJidWZfYWRkc3RyKG91dCwgIihub25lKSIpOwoJCXJldHVybjsKCX0KCWlmIChzdHJjaHIoYnVmLCAnLicpKQoJCXN0cmJ1Zl9hZGRzdHIob3V0LCBidWYpOwoJZWxzZSBpZiAoY2Fub25pY2FsX25hbWUoYnVmLCBvdXQpIDwgMCkKCQlzdHJidWZfYWRkZihvdXQsICIlcy4obm9uZSkiLCBidWYpOwp9CgpzdGF0aWMgdm9pZCBjb3B5X2VtYWlsKGNvbnN0IHN0cnVjdCBwYXNzd2QgKnB3LCBzdHJ1Y3Qgc3RyYnVmICplbWFpbCkKewoJLyoKCSAqIE1ha2UgdXAgYSBmYWtlIGVtYWlsIGFkZHJlc3MKCSAqIChuYW1lICsgJ0AnICsgaG9zdG5hbWUgWysgJy4nICsgZG9tYWlubmFtZV0pCgkgKi8KCXN0cmJ1Zl9hZGRzdHIoZW1haWwsIHB3LT5wd19uYW1lKTsKCXN0cmJ1Zl9hZGRjaChlbWFpbCwgJ0AnKTsKCglpZiAoIWFkZF9tYWlsbmFtZV9ob3N0KGVtYWlsKSkKCQlyZXR1cm47CS8qIHJlYWQgZnJvbSAiL2V0Yy9tYWlsbmFtZSIgKERlYmlhbikgKi8KCWFkZF9kb21haW5uYW1lKGVtYWlsKTsKfQoKY29uc3QgY2hhciAqaWRlbnRfZGVmYXVsdF9uYW1lKHZvaWQpCnsKCWlmICghZ2l0X2RlZmF1bHRfbmFtZS5sZW4pIHsKCQljb3B5X2dlY29zKHhnZXRwd3VpZF9zZWxmKCksICZnaXRfZGVmYXVsdF9uYW1lKTsKCQlzdHJidWZfdHJpbSgmZ2l0X2RlZmF1bHRfbmFtZSk7Cgl9CglyZXR1cm4gZ2l0X2RlZmF1bHRfbmFtZS5idWY7Cn0KCmNvbnN0IGNoYXIgKmlkZW50X2RlZmF1bHRfZW1haWwodm9pZCkKewoJaWYgKCFnaXRfZGVmYXVsdF9lbWFpbC5sZW4pIHsKCQljb25zdCBjaGFyICplbWFpbCA9IGdldGVudigiRU1BSUwiKTsKCgkJaWYgKGVtYWlsICYmIGVtYWlsWzBdKSB7CgkJCXN0cmJ1Zl9hZGRzdHIoJmdpdF9kZWZhdWx0X2VtYWlsLCBlbWFpbCk7CgkJCWNvbW1pdHRlcl9pZGVudF9leHBsaWNpdGx5X2dpdmVuIHw9IElERU5UX01BSUxfR0lWRU47CgkJCWF1dGhvcl9pZGVudF9leHBsaWNpdGx5X2dpdmVuIHw9IElERU5UX01BSUxfR0lWRU47CgkJfSBlbHNlCgkJCWNvcHlfZW1haWwoeGdldHB3dWlkX3NlbGYoKSwgJmdpdF9kZWZhdWx0X2VtYWlsKTsKCQlzdHJidWZfdHJpbSgmZ2l0X2RlZmF1bHRfZW1haWwpOwoJfQoJcmV0dXJuIGdpdF9kZWZhdWx0X2VtYWlsLmJ1ZjsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKmlkZW50X2RlZmF1bHRfZGF0ZSh2b2lkKQp7CglpZiAoIWdpdF9kZWZhdWx0X2RhdGUubGVuKQoJCWRhdGVzdGFtcCgmZ2l0X2RlZmF1bHRfZGF0ZSk7CglyZXR1cm4gZ2l0X2RlZmF1bHRfZGF0ZS5idWY7Cn0KCnN0YXRpYyBpbnQgY3J1ZCh1bnNpZ25lZCBjaGFyIGMpCnsKCXJldHVybiAgYyA8PSAzMiAgfHwKCQljID09ICcuJyB8fAoJCWMgPT0gJywnIHx8CgkJYyA9PSAnOicgfHwKCQljID09ICc7JyB8fAoJCWMgPT0gJzwnIHx8CgkJYyA9PSAnPicgfHwKCQljID09ICciJyB8fAoJCWMgPT0gJ1xcJyB8fAoJCWMgPT0gJ1wnJzsKfQoKLyoKICogQ29weSBvdmVyIGEgc3RyaW5nIHRvIHRoZSBkZXN0aW5hdGlvbiwgYnV0IGF2b2lkIHNwZWNpYWwKICogY2hhcmFjdGVycyAoJ1xuJywgJzwnIGFuZCAnPicpIGFuZCByZW1vdmUgY3J1ZCBhdCB0aGUgZW5kCiAqLwpzdGF0aWMgdm9pZCBzdHJidWZfYWRkc3RyX3dpdGhvdXRfY3J1ZChzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqc3JjKQp7CglzaXplX3QgaSwgbGVuOwoJdW5zaWduZWQgY2hhciBjOwoKCS8qIFJlbW92ZSBjcnVkIGZyb20gdGhlIGJlZ2lubmluZy4uICovCgl3aGlsZSAoKGMgPSAqc3JjKSAhPSAwKSB7CgkJaWYgKCFjcnVkKGMpKQoJCQlicmVhazsKCQlzcmMrKzsKCX0KCgkvKiBSZW1vdmUgY3J1ZCBmcm9tIHRoZSBlbmQuLiAqLwoJbGVuID0gc3RybGVuKHNyYyk7Cgl3aGlsZSAobGVuID4gMCkgewoJCWMgPSBzcmNbbGVuLTFdOwoJCWlmICghY3J1ZChjKSkKCQkJYnJlYWs7CgkJLS1sZW47Cgl9CgoJLyoKCSAqIENvcHkgdGhlIHJlc3QgdG8gdGhlIGJ1ZmZlciwgYnV0IGF2b2lkIHRoZSBzcGVjaWFsCgkgKiBjaGFyYWN0ZXJzICdcbicgJzwnIGFuZCAnPicgdGhhdCBhY3QgYXMgZGVsaW1pdGVycyBvbgoJICogYW4gaWRlbnRpZmljYXRpb24gbGluZS4gV2UgY2FuIG9ubHkgcmVtb3ZlIGNydWQsIG5ldmVyIGFkZCBpdCwKCSAqIHNvICdsZW4nIGlzIG91ciBtYXhpbXVtLgoJICovCglzdHJidWZfZ3JvdyhzYiwgbGVuKTsKCWZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykgewoJCWMgPSAqc3JjKys7CgkJc3dpdGNoIChjKSB7CgkJY2FzZSAnXG4nOiBjYXNlICc8JzogY2FzZSAnPic6CgkJCWNvbnRpbnVlOwoJCX0KCQlzYi0+YnVmW3NiLT5sZW4rK10gPSBjOwoJfQoJc2ItPmJ1ZltzYi0+bGVuXSA9ICdcMCc7Cn0KCi8qCiAqIFJldmVyc2Ugb2YgZm10X2lkZW50KCk7IGdpdmVuIGFuIGlkZW50IGxpbmUsIHNwbGl0IHRoZSBmaWVsZHMKICogdG8gYWxsb3cgdGhlIGNhbGxlciB0byBwYXJzZSBpdC4KICogU2lnbmFsIGEgc3VjY2VzcyBieSByZXR1cm5pbmcgMCwgYnV0IGRhdGUvdHogZmllbGRzIG9mIHRoZSByZXN1bHQKICogY2FuIHN0aWxsIGJlIE5VTEwgaWYgdGhlIGlucHV0IGxpbmUgb25seSBoYXMgdGhlIG5hbWUvZW1haWwgcGFydAogKiAoZS5nLiByZWFkaW5nIGZyb20gYSByZWZsb2cgZW50cnkpLgogKi8KaW50IHNwbGl0X2lkZW50X2xpbmUoc3RydWN0IGlkZW50X3NwbGl0ICpzcGxpdCwgY29uc3QgY2hhciAqbGluZSwgaW50IGxlbikKewoJY29uc3QgY2hhciAqY3A7CglzaXplX3Qgc3BhbjsKCWludCBzdGF0dXMgPSAtMTsKCgltZW1zZXQoc3BsaXQsIDAsIHNpemVvZigqc3BsaXQpKTsKCglzcGxpdC0+bmFtZV9iZWdpbiA9IGxpbmU7Cglmb3IgKGNwID0gbGluZTsgKmNwICYmIGNwIDwgbGluZSArIGxlbjsgY3ArKykKCQlpZiAoKmNwID09ICc8JykgewoJCQlzcGxpdC0+bWFpbF9iZWdpbiA9IGNwICsgMTsKCQkJYnJlYWs7CgkJfQoJaWYgKCFzcGxpdC0+bWFpbF9iZWdpbikKCQlyZXR1cm4gc3RhdHVzOwoKCWZvciAoY3AgPSBzcGxpdC0+bWFpbF9iZWdpbiAtIDI7IGxpbmUgPD0gY3A7IGNwLS0pCgkJaWYgKCFpc3NwYWNlKCpjcCkpIHsKCQkJc3BsaXQtPm5hbWVfZW5kID0gY3AgKyAxOwoJCQlicmVhazsKCQl9CglpZiAoIXNwbGl0LT5uYW1lX2VuZCkgewoJCS8qIG5vIGh1bWFuIHJlYWRhYmxlIG5hbWUgKi8KCQlzcGxpdC0+bmFtZV9lbmQgPSBzcGxpdC0+bmFtZV9iZWdpbjsKCX0KCglmb3IgKGNwID0gc3BsaXQtPm1haWxfYmVnaW47IGNwIDwgbGluZSArIGxlbjsgY3ArKykKCQlpZiAoKmNwID09ICc+JykgewoJCQlzcGxpdC0+bWFpbF9lbmQgPSBjcDsKCQkJYnJlYWs7CgkJfQoJaWYgKCFzcGxpdC0+bWFpbF9lbmQpCgkJcmV0dXJuIHN0YXR1czsKCgkvKgoJICogTG9vayBmcm9tIHRoZSBlbmQtb2YtbGluZSB0byBmaW5kIHRoZSB0cmFpbGluZyAiPiIgb2YgdGhlIG1haWwKCSAqIGFkZHJlc3MsIGV2ZW4gdGhvdWdoIHdlIHNob3VsZCBhbHJlYWR5IGtub3cgaXQgYXMgc3BsaXQtPm1haWxfZW5kLgoJICogVGhpcyBjYW4gaGVscCBpbiBjYXNlcyBvZiBicm9rZW4gaWRlbnRzIHdpdGggYW4gZXh0cmEgIj4iIHNvbWV3aGVyZQoJICogaW4gdGhlIGVtYWlsIGFkZHJlc3MuICBOb3RlIHRoYXQgd2UgYXJlIGFzc3VtaW5nIHRoZSB0aW1lc3RhbXAgd2lsbAoJICogbmV2ZXIgaGF2ZSBhICI+IiBpbiBpdC4KCSAqCgkgKiBOb3RlIHRoYXQgd2Ugd2lsbCBhbHdheXMgZmluZCBzb21lICI+IiBiZWZvcmUgZ29pbmcgb2ZmIHRoZSBmcm9udCBvZgoJICogdGhlIHN0cmluZywgYmVjYXVzZSB3aWxsIGFsd2F5cyBoaXQgdGhlIHNwbGl0LT5tYWlsX2VuZCBjbG9zaW5nCgkgKiBicmFja2V0LgoJICovCglmb3IgKGNwID0gbGluZSArIGxlbiAtIDE7ICpjcCAhPSAnPic7IGNwLS0pCgkJOwoKCWZvciAoY3AgPSBjcCArIDE7IGNwIDwgbGluZSArIGxlbiAmJiBpc3NwYWNlKCpjcCk7IGNwKyspCgkJOwoJaWYgKGxpbmUgKyBsZW4gPD0gY3ApCgkJZ290byBwZXJzb25fb25seTsKCXNwbGl0LT5kYXRlX2JlZ2luID0gY3A7CglzcGFuID0gc3Ryc3BuKGNwLCAiMDEyMzQ1Njc4OSIpOwoJaWYgKCFzcGFuKQoJCWdvdG8gcGVyc29uX29ubHk7CglzcGxpdC0+ZGF0ZV9lbmQgPSBzcGxpdC0+ZGF0ZV9iZWdpbiArIHNwYW47Cglmb3IgKGNwID0gc3BsaXQtPmRhdGVfZW5kOyBjcCA8IGxpbmUgKyBsZW4gJiYgaXNzcGFjZSgqY3ApOyBjcCsrKQoJCTsKCWlmIChsaW5lICsgbGVuIDw9IGNwIHx8ICgqY3AgIT0gJysnICYmICpjcCAhPSAnLScpKQoJCWdvdG8gcGVyc29uX29ubHk7CglzcGxpdC0+dHpfYmVnaW4gPSBjcDsKCXNwYW4gPSBzdHJzcG4oY3AgKyAxLCAiMDEyMzQ1Njc4OSIpOwoJaWYgKCFzcGFuKQoJCWdvdG8gcGVyc29uX29ubHk7CglzcGxpdC0+dHpfZW5kID0gc3BsaXQtPnR6X2JlZ2luICsgMSArIHNwYW47CglyZXR1cm4gMDsKCnBlcnNvbl9vbmx5OgoJc3BsaXQtPmRhdGVfYmVnaW4gPSBOVUxMOwoJc3BsaXQtPmRhdGVfZW5kID0gTlVMTDsKCXNwbGl0LT50el9iZWdpbiA9IE5VTEw7CglzcGxpdC0+dHpfZW5kID0gTlVMTDsKCXJldHVybiAwOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqZW52X2hpbnQgPQoiXG4iCiIqKiogUGxlYXNlIHRlbGwgbWUgd2hvIHlvdSBhcmUuXG4iCiJcbiIKIlJ1blxuIgoiXG4iCiIgIGdpdCBjb25maWcgLS1nbG9iYWwgdXNlci5lbWFpbCBcInlvdUBleGFtcGxlLmNvbVwiXG4iCiIgIGdpdCBjb25maWcgLS1nbG9iYWwgdXNlci5uYW1lIFwiWW91ciBOYW1lXCJcbiIKIlxuIgoidG8gc2V0IHlvdXIgYWNjb3VudFwncyBkZWZhdWx0IGlkZW50aXR5LlxuIgoiT21pdCAtLWdsb2JhbCB0byBzZXQgdGhlIGlkZW50aXR5IG9ubHkgaW4gdGhpcyByZXBvc2l0b3J5LlxuIgoiXG4iOwoKY29uc3QgY2hhciAqZm10X2lkZW50KGNvbnN0IGNoYXIgKm5hbWUsIGNvbnN0IGNoYXIgKmVtYWlsLAoJCSAgICAgIGNvbnN0IGNoYXIgKmRhdGVfc3RyLCBpbnQgZmxhZykKewoJc3RhdGljIHN0cnVjdCBzdHJidWYgaWRlbnQgPSBTVFJCVUZfSU5JVDsKCWludCBzdHJpY3QgPSAoZmxhZyAmIElERU5UX1NUUklDVCk7CglpbnQgd2FudF9kYXRlID0gIShmbGFnICYgSURFTlRfTk9fREFURSk7CglpbnQgd2FudF9uYW1lID0gIShmbGFnICYgSURFTlRfTk9fTkFNRSk7CgoJaWYgKHdhbnRfbmFtZSAmJiAhbmFtZSkKCQluYW1lID0gaWRlbnRfZGVmYXVsdF9uYW1lKCk7CglpZiAoIWVtYWlsKQoJCWVtYWlsID0gaWRlbnRfZGVmYXVsdF9lbWFpbCgpOwoKCWlmICh3YW50X25hbWUgJiYgISpuYW1lKSB7CgkJc3RydWN0IHBhc3N3ZCAqcHc7CgoJCWlmIChzdHJpY3QpIHsKCQkJaWYgKG5hbWUgPT0gZ2l0X2RlZmF1bHRfbmFtZS5idWYpCgkJCQlmcHV0cyhlbnZfaGludCwgc3RkZXJyKTsKCQkJZGllKCJlbXB0eSBpZGVudCBuYW1lIChmb3IgPCVzPikgbm90IGFsbG93ZWQiLCBlbWFpbCk7CgkJfQoJCXB3ID0geGdldHB3dWlkX3NlbGYoKTsKCQluYW1lID0gcHctPnB3X25hbWU7Cgl9CgoJaWYgKHN0cmljdCAmJiBlbWFpbCA9PSBnaXRfZGVmYXVsdF9lbWFpbC5idWYgJiYKCSAgICBzdHJzdHIoZW1haWwsICIobm9uZSkiKSkgewoJCWZwdXRzKGVudl9oaW50LCBzdGRlcnIpOwoJCWRpZSgidW5hYmxlIHRvIGF1dG8tZGV0ZWN0IGVtYWlsIGFkZHJlc3MgKGdvdCAnJXMnKSIsIGVtYWlsKTsKCX0KCglzdHJidWZfcmVzZXQoJmlkZW50KTsKCWlmICh3YW50X25hbWUpIHsKCQlzdHJidWZfYWRkc3RyX3dpdGhvdXRfY3J1ZCgmaWRlbnQsIG5hbWUpOwoJCXN0cmJ1Zl9hZGRzdHIoJmlkZW50LCAiIDwiKTsKCX0KCXN0cmJ1Zl9hZGRzdHJfd2l0aG91dF9jcnVkKCZpZGVudCwgZW1haWwpOwoJaWYgKHdhbnRfbmFtZSkKCQkJc3RyYnVmX2FkZGNoKCZpZGVudCwgJz4nKTsKCWlmICh3YW50X2RhdGUpIHsKCQlzdHJidWZfYWRkY2goJmlkZW50LCAnICcpOwoJCWlmIChkYXRlX3N0ciAmJiBkYXRlX3N0clswXSkgewoJCQlpZiAocGFyc2VfZGF0ZShkYXRlX3N0ciwgJmlkZW50KSA8IDApCgkJCQlkaWUoImludmFsaWQgZGF0ZSBmb3JtYXQ6ICVzIiwgZGF0ZV9zdHIpOwoJCX0KCQllbHNlCgkJCXN0cmJ1Zl9hZGRzdHIoJmlkZW50LCBpZGVudF9kZWZhdWx0X2RhdGUoKSk7Cgl9CgoJcmV0dXJuIGlkZW50LmJ1ZjsKfQoKY29uc3QgY2hhciAqZm10X25hbWUoY29uc3QgY2hhciAqbmFtZSwgY29uc3QgY2hhciAqZW1haWwpCnsKCXJldHVybiBmbXRfaWRlbnQobmFtZSwgZW1haWwsIE5VTEwsIElERU5UX1NUUklDVCB8IElERU5UX05PX0RBVEUpOwp9Cgpjb25zdCBjaGFyICpnaXRfYXV0aG9yX2luZm8oaW50IGZsYWcpCnsKCWlmIChnZXRlbnYoIkdJVF9BVVRIT1JfTkFNRSIpKQoJCWF1dGhvcl9pZGVudF9leHBsaWNpdGx5X2dpdmVuIHw9IElERU5UX05BTUVfR0lWRU47CglpZiAoZ2V0ZW52KCJHSVRfQVVUSE9SX0VNQUlMIikpCgkJYXV0aG9yX2lkZW50X2V4cGxpY2l0bHlfZ2l2ZW4gfD0gSURFTlRfTUFJTF9HSVZFTjsKCXJldHVybiBmbXRfaWRlbnQoZ2V0ZW52KCJHSVRfQVVUSE9SX05BTUUiKSwKCQkJIGdldGVudigiR0lUX0FVVEhPUl9FTUFJTCIpLAoJCQkgZ2V0ZW52KCJHSVRfQVVUSE9SX0RBVEUiKSwKCQkJIGZsYWcpOwp9Cgpjb25zdCBjaGFyICpnaXRfY29tbWl0dGVyX2luZm8oaW50IGZsYWcpCnsKCWlmIChnZXRlbnYoIkdJVF9DT01NSVRURVJfTkFNRSIpKQoJCWNvbW1pdHRlcl9pZGVudF9leHBsaWNpdGx5X2dpdmVuIHw9IElERU5UX05BTUVfR0lWRU47CglpZiAoZ2V0ZW52KCJHSVRfQ09NTUlUVEVSX0VNQUlMIikpCgkJY29tbWl0dGVyX2lkZW50X2V4cGxpY2l0bHlfZ2l2ZW4gfD0gSURFTlRfTUFJTF9HSVZFTjsKCXJldHVybiBmbXRfaWRlbnQoZ2V0ZW52KCJHSVRfQ09NTUlUVEVSX05BTUUiKSwKCQkJIGdldGVudigiR0lUX0NPTU1JVFRFUl9FTUFJTCIpLAoJCQkgZ2V0ZW52KCJHSVRfQ09NTUlUVEVSX0RBVEUiKSwKCQkJIGZsYWcpOwp9CgpzdGF0aWMgaW50IGlkZW50X2lzX3N1ZmZpY2llbnQoaW50IHVzZXJfaWRlbnRfZXhwbGljaXRseV9naXZlbikKewojaWZuZGVmIFdJTkRPV1MKCXJldHVybiAodXNlcl9pZGVudF9leHBsaWNpdGx5X2dpdmVuICYgSURFTlRfTUFJTF9HSVZFTik7CiNlbHNlCglyZXR1cm4gKHVzZXJfaWRlbnRfZXhwbGljaXRseV9naXZlbiA9PSBJREVOVF9BTExfR0lWRU4pOwojZW5kaWYKfQoKaW50IGNvbW1pdHRlcl9pZGVudF9zdWZmaWNpZW50bHlfZ2l2ZW4odm9pZCkKewoJcmV0dXJuIGlkZW50X2lzX3N1ZmZpY2llbnQoY29tbWl0dGVyX2lkZW50X2V4cGxpY2l0bHlfZ2l2ZW4pOwp9CgppbnQgYXV0aG9yX2lkZW50X3N1ZmZpY2llbnRseV9naXZlbih2b2lkKQp7CglyZXR1cm4gaWRlbnRfaXNfc3VmZmljaWVudChhdXRob3JfaWRlbnRfZXhwbGljaXRseV9naXZlbik7Cn0KCmludCBnaXRfaWRlbnRfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmRhdGEpCnsKCWlmICghc3RyY21wKHZhciwgInVzZXIubmFtZSIpKSB7CgkJaWYgKCF2YWx1ZSkKCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKHZhcik7CgkJc3RyYnVmX3Jlc2V0KCZnaXRfZGVmYXVsdF9uYW1lKTsKCQlzdHJidWZfYWRkc3RyKCZnaXRfZGVmYXVsdF9uYW1lLCB2YWx1ZSk7CgkJY29tbWl0dGVyX2lkZW50X2V4cGxpY2l0bHlfZ2l2ZW4gfD0gSURFTlRfTkFNRV9HSVZFTjsKCQlhdXRob3JfaWRlbnRfZXhwbGljaXRseV9naXZlbiB8PSBJREVOVF9OQU1FX0dJVkVOOwoJCXJldHVybiAwOwoJfQoKCWlmICghc3RyY21wKHZhciwgInVzZXIuZW1haWwiKSkgewoJCWlmICghdmFsdWUpCgkJCXJldHVybiBjb25maWdfZXJyb3Jfbm9uYm9vbCh2YXIpOwoJCXN0cmJ1Zl9yZXNldCgmZ2l0X2RlZmF1bHRfZW1haWwpOwoJCXN0cmJ1Zl9hZGRzdHIoJmdpdF9kZWZhdWx0X2VtYWlsLCB2YWx1ZSk7CgkJY29tbWl0dGVyX2lkZW50X2V4cGxpY2l0bHlfZ2l2ZW4gfD0gSURFTlRfTUFJTF9HSVZFTjsKCQlhdXRob3JfaWRlbnRfZXhwbGljaXRseV9naXZlbiB8PSBJREVOVF9NQUlMX0dJVkVOOwoJCXJldHVybiAwOwoJfQoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGJ1Zl9jbXAoY29uc3QgY2hhciAqYV9iZWdpbiwgY29uc3QgY2hhciAqYV9lbmQsCgkJICAgY29uc3QgY2hhciAqYl9iZWdpbiwgY29uc3QgY2hhciAqYl9lbmQpCnsKCWludCBhX2xlbiA9IGFfZW5kIC0gYV9iZWdpbjsKCWludCBiX2xlbiA9IGJfZW5kIC0gYl9iZWdpbjsKCWludCBtaW4gPSBhX2xlbiA8IGJfbGVuID8gYV9sZW4gOiBiX2xlbjsKCWludCBjbXA7CgoJY21wID0gbWVtY21wKGFfYmVnaW4sIGJfYmVnaW4sIG1pbik7CglpZiAoY21wKQoJCXJldHVybiBjbXA7CgoJcmV0dXJuIGFfbGVuIC0gYl9sZW47Cn0KCmludCBpZGVudF9jbXAoY29uc3Qgc3RydWN0IGlkZW50X3NwbGl0ICphLAoJICAgICAgY29uc3Qgc3RydWN0IGlkZW50X3NwbGl0ICpiKQp7CglpbnQgY21wOwoKCWNtcCA9IGJ1Zl9jbXAoYS0+bWFpbF9iZWdpbiwgYS0+bWFpbF9lbmQsCgkJICAgICAgYi0+bWFpbF9iZWdpbiwgYi0+bWFpbF9lbmQpOwoJaWYgKGNtcCkKCQlyZXR1cm4gY21wOwoKCXJldHVybiBidWZfY21wKGEtPm5hbWVfYmVnaW4sIGEtPm5hbWVfZW5kLAoJCSAgICAgICBiLT5uYW1lX2JlZ2luLCBiLT5uYW1lX2VuZCk7Cn0K",
    "text": "/*\n * ident.c\n *\n * create git identifier lines of the form \"name <email> date\"\n *\n * Copyright (C) 2005 Linus Torvalds\n */\n#include \"cache.h\"\n\nstatic struct strbuf git_default_name = STRBUF_INIT;\nstatic struct strbuf git_default_email = STRBUF_INIT;\nstatic struct strbuf git_default_date = STRBUF_INIT;\n\n#define IDENT_NAME_GIVEN 01\n#define IDENT_MAIL_GIVEN 02\n#define IDENT_ALL_GIVEN (IDENT_NAME_GIVEN|IDENT_MAIL_GIVEN)\nstatic int committer_ident_explicitly_given;\nstatic int author_ident_explicitly_given;\n\n#ifdef NO_GECOS_IN_PWENT\n#define get_gecos(ignored) \"&\"\n#else\n#define get_gecos(struct_passwd) ((struct_passwd)->pw_gecos)\n#endif\n\nstatic void copy_gecos(const struct passwd *w, struct strbuf *name)\n{\n\tchar *src;\n\n\t/* Traditionally GECOS field had office phone numbers etc, separated\n\t * with commas.  Also & stands for capitalized form of the login name.\n\t */\n\n\tfor (src = get_gecos(w); *src && *src != ','; src++) {\n\t\tint ch = *src;\n\t\tif (ch != '&')\n\t\t\tstrbuf_addch(name, ch);\n\t\telse {\n\t\t\t/* Sorry, Mr. McDonald... */\n\t\t\tstrbuf_addch(name, toupper(*w->pw_name));\n\t\t\tstrbuf_addstr(name, w->pw_name + 1);\n\t\t}\n\t}\n}\n\nstatic int add_mailname_host(struct strbuf *buf)\n{\n\tFILE *mailname;\n\tstruct strbuf mailnamebuf = STRBUF_INIT;\n\n\tmailname = fopen(\"/etc/mailname\", \"r\");\n\tif (!mailname) {\n\t\tif (errno != ENOENT)\n\t\t\twarning(\"cannot open /etc/mailname: %s\",\n\t\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\tif (strbuf_getline(&mailnamebuf, mailname, '\\n') == EOF) {\n\t\tif (ferror(mailname))\n\t\t\twarning(\"cannot read /etc/mailname: %s\",\n\t\t\t\tstrerror(errno));\n\t\tstrbuf_release(&mailnamebuf);\n\t\tfclose(mailname);\n\t\treturn -1;\n\t}\n\t/* success! */\n\tstrbuf_addbuf(buf, &mailnamebuf);\n\tstrbuf_release(&mailnamebuf);\n\tfclose(mailname);\n\treturn 0;\n}\n\nstatic int canonical_name(const char *host, struct strbuf *out)\n{\n\tint status = -1;\n\n#ifndef NO_IPV6\n\tstruct addrinfo hints, *ai;\n\tmemset (&hints, '\\0', sizeof (hints));\n\thints.ai_flags = AI_CANONNAME;\n\tif (!getaddrinfo(host, NULL, &hints, &ai)) {\n\t\tif (ai && strchr(ai->ai_canonname, '.')) {\n\t\t\tstrbuf_addstr(out, ai->ai_canonname);\n\t\t\tstatus = 0;\n\t\t}\n\t\tfreeaddrinfo(ai);\n\t}\n#else\n\tstruct hostent *he = gethostbyname(host);\n\tif (he && strchr(he->h_name, '.')) {\n\t\tstrbuf_addstr(out, he->h_name);\n\t\tstatus = 0;\n\t}\n#endif /* NO_IPV6 */\n\n\treturn status;\n}\n\nstatic void add_domainname(struct strbuf *out)\n{\n\tchar buf[1024];\n\n\tif (gethostname(buf, sizeof(buf))) {\n\t\twarning(\"cannot get host name: %s\", strerror(errno));\n\t\tstrbuf_addstr(out, \"(none)\");\n\t\treturn;\n\t}\n\tif (strchr(buf, '.'))\n\t\tstrbuf_addstr(out, buf);\n\telse if (canonical_name(buf, out) < 0)\n\t\tstrbuf_addf(out, \"%s.(none)\", buf);\n}\n\nstatic void copy_email(const struct passwd *pw, struct strbuf *email)\n{\n\t/*\n\t * Make up a fake email address\n\t * (name + '@' + hostname [+ '.' + domainname])\n\t */\n\tstrbuf_addstr(email, pw->pw_name);\n\tstrbuf_addch(email, '@');\n\n\tif (!add_mailname_host(email))\n\t\treturn;\t/* read from \"/etc/mailname\" (Debian) */\n\tadd_domainname(email);\n}\n\nconst char *ident_default_name(void)\n{\n\tif (!git_default_name.len) {\n\t\tcopy_gecos(xgetpwuid_self(), &git_default_name);\n\t\tstrbuf_trim(&git_default_name);\n\t}\n\treturn git_default_name.buf;\n}\n\nconst char *ident_default_email(void)\n{\n\tif (!git_default_email.len) {\n\t\tconst char *email = getenv(\"EMAIL\");\n\n\t\tif (email && email[0]) {\n\t\t\tstrbuf_addstr(&git_default_email, email);\n\t\t\tcommitter_ident_explicitly_given |= IDENT_MAIL_GIVEN;\n\t\t\tauthor_ident_explicitly_given |= IDENT_MAIL_GIVEN;\n\t\t} else\n\t\t\tcopy_email(xgetpwuid_self(), &git_default_email);\n\t\tstrbuf_trim(&git_default_email);\n\t}\n\treturn git_default_email.buf;\n}\n\nstatic const char *ident_default_date(void)\n{\n\tif (!git_default_date.len)\n\t\tdatestamp(&git_default_date);\n\treturn git_default_date.buf;\n}\n\nstatic int crud(unsigned char c)\n{\n\treturn  c <= 32  ||\n\t\tc == '.' ||\n\t\tc == ',' ||\n\t\tc == ':' ||\n\t\tc == ';' ||\n\t\tc == '<' ||\n\t\tc == '>' ||\n\t\tc == '\"' ||\n\t\tc == '\\\\' ||\n\t\tc == '\\'';\n}\n\n/*\n * Copy over a string to the destination, but avoid special\n * characters ('\\n', '<' and '>') and remove crud at the end\n */\nstatic void strbuf_addstr_without_crud(struct strbuf *sb, const char *src)\n{\n\tsize_t i, len;\n\tunsigned char c;\n\n\t/* Remove crud from the beginning.. */\n\twhile ((c = *src) != 0) {\n\t\tif (!crud(c))\n\t\t\tbreak;\n\t\tsrc++;\n\t}\n\n\t/* Remove crud from the end.. */\n\tlen = strlen(src);\n\twhile (len > 0) {\n\t\tc = src[len-1];\n\t\tif (!crud(c))\n\t\t\tbreak;\n\t\t--len;\n\t}\n\n\t/*\n\t * Copy the rest to the buffer, but avoid the special\n\t * characters '\\n' '<' and '>' that act as delimiters on\n\t * an identification line. We can only remove crud, never add it,\n\t * so 'len' is our maximum.\n\t */\n\tstrbuf_grow(sb, len);\n\tfor (i = 0; i < len; i++) {\n\t\tc = *src++;\n\t\tswitch (c) {\n\t\tcase '\\n': case '<': case '>':\n\t\t\tcontinue;\n\t\t}\n\t\tsb->buf[sb->len++] = c;\n\t}\n\tsb->buf[sb->len] = '\\0';\n}\n\n/*\n * Reverse of fmt_ident(); given an ident line, split the fields\n * to allow the caller to parse it.\n * Signal a success by returning 0, but date/tz fields of the result\n * can still be NULL if the input line only has the name/email part\n * (e.g. reading from a reflog entry).\n */\nint split_ident_line(struct ident_split *split, const char *line, int len)\n{\n\tconst char *cp;\n\tsize_t span;\n\tint status = -1;\n\n\tmemset(split, 0, sizeof(*split));\n\n\tsplit->name_begin = line;\n\tfor (cp = line; *cp && cp < line + len; cp++)\n\t\tif (*cp == '<') {\n\t\t\tsplit->mail_begin = cp + 1;\n\t\t\tbreak;\n\t\t}\n\tif (!split->mail_begin)\n\t\treturn status;\n\n\tfor (cp = split->mail_begin - 2; line <= cp; cp--)\n\t\tif (!isspace(*cp)) {\n\t\t\tsplit->name_end = cp + 1;\n\t\t\tbreak;\n\t\t}\n\tif (!split->name_end) {\n\t\t/* no human readable name */\n\t\tsplit->name_end = split->name_begin;\n\t}\n\n\tfor (cp = split->mail_begin; cp < line + len; cp++)\n\t\tif (*cp == '>') {\n\t\t\tsplit->mail_end = cp;\n\t\t\tbreak;\n\t\t}\n\tif (!split->mail_end)\n\t\treturn status;\n\n\t/*\n\t * Look from the end-of-line to find the trailing \">\" of the mail\n\t * address, even though we should already know it as split->mail_end.\n\t * This can help in cases of broken idents with an extra \">\" somewhere\n\t * in the email address.  Note that we are assuming the timestamp will\n\t * never have a \">\" in it.\n\t *\n\t * Note that we will always find some \">\" before going off the front of\n\t * the string, because will always hit the split->mail_end closing\n\t * bracket.\n\t */\n\tfor (cp = line + len - 1; *cp != '>'; cp--)\n\t\t;\n\n\tfor (cp = cp + 1; cp < line + len && isspace(*cp); cp++)\n\t\t;\n\tif (line + len <= cp)\n\t\tgoto person_only;\n\tsplit->date_begin = cp;\n\tspan = strspn(cp, \"0123456789\");\n\tif (!span)\n\t\tgoto person_only;\n\tsplit->date_end = split->date_begin + span;\n\tfor (cp = split->date_end; cp < line + len && isspace(*cp); cp++)\n\t\t;\n\tif (line + len <= cp || (*cp != '+' && *cp != '-'))\n\t\tgoto person_only;\n\tsplit->tz_begin = cp;\n\tspan = strspn(cp + 1, \"0123456789\");\n\tif (!span)\n\t\tgoto person_only;\n\tsplit->tz_end = split->tz_begin + 1 + span;\n\treturn 0;\n\nperson_only:\n\tsplit->date_begin = NULL;\n\tsplit->date_end = NULL;\n\tsplit->tz_begin = NULL;\n\tsplit->tz_end = NULL;\n\treturn 0;\n}\n\nstatic const char *env_hint =\n\"\\n\"\n\"*** Please tell me who you are.\\n\"\n\"\\n\"\n\"Run\\n\"\n\"\\n\"\n\"  git config --global user.email \\\"you@example.com\\\"\\n\"\n\"  git config --global user.name \\\"Your Name\\\"\\n\"\n\"\\n\"\n\"to set your account\\'s default identity.\\n\"\n\"Omit --global to set the identity only in this repository.\\n\"\n\"\\n\";\n\nconst char *fmt_ident(const char *name, const char *email,\n\t\t      const char *date_str, int flag)\n{\n\tstatic struct strbuf ident = STRBUF_INIT;\n\tint strict = (flag & IDENT_STRICT);\n\tint want_date = !(flag & IDENT_NO_DATE);\n\tint want_name = !(flag & IDENT_NO_NAME);\n\n\tif (want_name && !name)\n\t\tname = ident_default_name();\n\tif (!email)\n\t\temail = ident_default_email();\n\n\tif (want_name && !*name) {\n\t\tstruct passwd *pw;\n\n\t\tif (strict) {\n\t\t\tif (name == git_default_name.buf)\n\t\t\t\tfputs(env_hint, stderr);\n\t\t\tdie(\"empty ident name (for <%s>) not allowed\", email);\n\t\t}\n\t\tpw = xgetpwuid_self();\n\t\tname = pw->pw_name;\n\t}\n\n\tif (strict && email == git_default_email.buf &&\n\t    strstr(email, \"(none)\")) {\n\t\tfputs(env_hint, stderr);\n\t\tdie(\"unable to auto-detect email address (got '%s')\", email);\n\t}\n\n\tstrbuf_reset(&ident);\n\tif (want_name) {\n\t\tstrbuf_addstr_without_crud(&ident, name);\n\t\tstrbuf_addstr(&ident, \" <\");\n\t}\n\tstrbuf_addstr_without_crud(&ident, email);\n\tif (want_name)\n\t\t\tstrbuf_addch(&ident, '>');\n\tif (want_date) {\n\t\tstrbuf_addch(&ident, ' ');\n\t\tif (date_str && date_str[0]) {\n\t\t\tif (parse_date(date_str, &ident) < 0)\n\t\t\t\tdie(\"invalid date format: %s\", date_str);\n\t\t}\n\t\telse\n\t\t\tstrbuf_addstr(&ident, ident_default_date());\n\t}\n\n\treturn ident.buf;\n}\n\nconst char *fmt_name(const char *name, const char *email)\n{\n\treturn fmt_ident(name, email, NULL, IDENT_STRICT | IDENT_NO_DATE);\n}\n\nconst char *git_author_info(int flag)\n{\n\tif (getenv(\"GIT_AUTHOR_NAME\"))\n\t\tauthor_ident_explicitly_given |= IDENT_NAME_GIVEN;\n\tif (getenv(\"GIT_AUTHOR_EMAIL\"))\n\t\tauthor_ident_explicitly_given |= IDENT_MAIL_GIVEN;\n\treturn fmt_ident(getenv(\"GIT_AUTHOR_NAME\"),\n\t\t\t getenv(\"GIT_AUTHOR_EMAIL\"),\n\t\t\t getenv(\"GIT_AUTHOR_DATE\"),\n\t\t\t flag);\n}\n\nconst char *git_committer_info(int flag)\n{\n\tif (getenv(\"GIT_COMMITTER_NAME\"))\n\t\tcommitter_ident_explicitly_given |= IDENT_NAME_GIVEN;\n\tif (getenv(\"GIT_COMMITTER_EMAIL\"))\n\t\tcommitter_ident_explicitly_given |= IDENT_MAIL_GIVEN;\n\treturn fmt_ident(getenv(\"GIT_COMMITTER_NAME\"),\n\t\t\t getenv(\"GIT_COMMITTER_EMAIL\"),\n\t\t\t getenv(\"GIT_COMMITTER_DATE\"),\n\t\t\t flag);\n}\n\nstatic int ident_is_sufficient(int user_ident_explicitly_given)\n{\n#ifndef WINDOWS\n\treturn (user_ident_explicitly_given & IDENT_MAIL_GIVEN);\n#else\n\treturn (user_ident_explicitly_given == IDENT_ALL_GIVEN);\n#endif\n}\n\nint committer_ident_sufficiently_given(void)\n{\n\treturn ident_is_sufficient(committer_ident_explicitly_given);\n}\n\nint author_ident_sufficiently_given(void)\n{\n\treturn ident_is_sufficient(author_ident_explicitly_given);\n}\n\nint git_ident_config(const char *var, const char *value, void *data)\n{\n\tif (!strcmp(var, \"user.name\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tstrbuf_reset(&git_default_name);\n\t\tstrbuf_addstr(&git_default_name, value);\n\t\tcommitter_ident_explicitly_given |= IDENT_NAME_GIVEN;\n\t\tauthor_ident_explicitly_given |= IDENT_NAME_GIVEN;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"user.email\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tstrbuf_reset(&git_default_email);\n\t\tstrbuf_addstr(&git_default_email, value);\n\t\tcommitter_ident_explicitly_given |= IDENT_MAIL_GIVEN;\n\t\tauthor_ident_explicitly_given |= IDENT_MAIL_GIVEN;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int buf_cmp(const char *a_begin, const char *a_end,\n\t\t   const char *b_begin, const char *b_end)\n{\n\tint a_len = a_end - a_begin;\n\tint b_len = b_end - b_begin;\n\tint min = a_len < b_len ? a_len : b_len;\n\tint cmp;\n\n\tcmp = memcmp(a_begin, b_begin, min);\n\tif (cmp)\n\t\treturn cmp;\n\n\treturn a_len - b_len;\n}\n\nint ident_cmp(const struct ident_split *a,\n\t      const struct ident_split *b)\n{\n\tint cmp;\n\n\tcmp = buf_cmp(a->mail_begin, a->mail_end,\n\t\t      b->mail_begin, b->mail_end);\n\tif (cmp)\n\t\treturn cmp;\n\n\treturn buf_cmp(a->name_begin, a->name_end,\n\t\t       b->name_begin, b->name_end);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00a62e0c4276fb8889a0b158c9e71a22e3be092c",
  "sha1_ok": true,
  "size": 11049
}
