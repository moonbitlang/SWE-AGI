{
  "content": {
    "base64": "I2luY2x1ZGUgImh0dHAuaCIKI2luY2x1ZGUgInBhY2suaCIKI2luY2x1ZGUgInNpZGViYW5kLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAidXJsLmgiCgppbnQgZGF0YV9yZWNlaXZlZDsKaW50IGFjdGl2ZV9yZXF1ZXN0czsKaW50IGh0dHBfaXNfdmVyYm9zZTsKc2l6ZV90IGh0dHBfcG9zdF9idWZmZXIgPSAxNiAqIExBUkdFX1BBQ0tFVF9NQVg7CgojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MGEwNgojZGVmaW5lIExJQkNVUkxfQ0FOX0hBTkRMRV9BVVRIX0FOWQojZW5kaWYKCnN0YXRpYyBpbnQgbWluX2N1cmxfc2Vzc2lvbnMgPSAxOwpzdGF0aWMgaW50IGN1cmxfc2Vzc2lvbl9jb3VudDsKI2lmZGVmIFVTRV9DVVJMX01VTFRJCnN0YXRpYyBpbnQgbWF4X3JlcXVlc3RzID0gLTE7CnN0YXRpYyBDVVJMTSAqY3VybG07CiNlbmRpZgojaWZuZGVmIE5PX0NVUkxfRUFTWV9EVVBIQU5ETEUKc3RhdGljIENVUkwgKmN1cmxfZGVmYXVsdDsKI2VuZGlmCgojZGVmaW5lIFBSRVZfQlVGX1NJWkUgNDA5NgojZGVmaW5lIFJBTkdFX0hFQURFUl9TSVpFIDMwCgpjaGFyIGN1cmxfZXJyb3JzdHJbQ1VSTF9FUlJPUl9TSVpFXTsKCnN0YXRpYyBpbnQgY3VybF9zc2xfdmVyaWZ5ID0gLTE7CnN0YXRpYyBjb25zdCBjaGFyICpzc2xfY2VydDsKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzA5MDMKc3RhdGljIGNvbnN0IGNoYXIgKnNzbF9rZXk7CiNlbmRpZgojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MDkwOApzdGF0aWMgY29uc3QgY2hhciAqc3NsX2NhcGF0aDsKI2VuZGlmCnN0YXRpYyBjb25zdCBjaGFyICpzc2xfY2FpbmZvOwpzdGF0aWMgbG9uZyBjdXJsX2xvd19zcGVlZF9saW1pdCA9IC0xOwpzdGF0aWMgbG9uZyBjdXJsX2xvd19zcGVlZF90aW1lID0gLTE7CnN0YXRpYyBpbnQgY3VybF9mdHBfbm9fZXBzdjsKc3RhdGljIGNvbnN0IGNoYXIgKmN1cmxfaHR0cF9wcm94eTsKc3RhdGljIGNvbnN0IGNoYXIgKmN1cmxfY29va2llX2ZpbGU7CnN0YXRpYyBjaGFyICp1c2VyX25hbWUsICp1c2VyX3Bhc3MsICpkZXNjcmlwdGlvbjsKc3RhdGljIGNvbnN0IGNoYXIgKnVzZXJfYWdlbnQ7CgojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MTcwMAovKiBVc2UgQ1VSTE9QVF9LRVlQQVNTV0QgYXMgaXMgKi8KI2VsaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MDkwMwojZGVmaW5lIENVUkxPUFRfS0VZUEFTU1dEIENVUkxPUFRfU1NMS0VZUEFTU1dECiNlbHNlCiNkZWZpbmUgQ1VSTE9QVF9LRVlQQVNTV0QgQ1VSTE9QVF9TU0xDRVJUUEFTU1dECiNlbmRpZgoKc3RhdGljIGNoYXIgKnNzbF9jZXJ0X3Bhc3N3b3JkOwpzdGF0aWMgaW50IHNzbF9jZXJ0X3Bhc3N3b3JkX3JlcXVpcmVkOwoKc3RhdGljIHN0cnVjdCBjdXJsX3NsaXN0ICpwcmFnbWFfaGVhZGVyOwpzdGF0aWMgc3RydWN0IGN1cmxfc2xpc3QgKm5vX3ByYWdtYV9oZWFkZXI7CgpzdGF0aWMgc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKmFjdGl2ZV9xdWV1ZV9oZWFkOwoKc2l6ZV90IGZyZWFkX2J1ZmZlcihjaGFyICpwdHIsIHNpemVfdCBlbHRzaXplLCBzaXplX3Qgbm1lbWIsIHZvaWQgKmJ1ZmZlcl8pCnsKCXNpemVfdCBzaXplID0gZWx0c2l6ZSAqIG5tZW1iOwoJc3RydWN0IGJ1ZmZlciAqYnVmZmVyID0gYnVmZmVyXzsKCglpZiAoc2l6ZSA+IGJ1ZmZlci0+YnVmLmxlbiAtIGJ1ZmZlci0+cG9zbikKCQlzaXplID0gYnVmZmVyLT5idWYubGVuIC0gYnVmZmVyLT5wb3NuOwoJbWVtY3B5KHB0ciwgYnVmZmVyLT5idWYuYnVmICsgYnVmZmVyLT5wb3NuLCBzaXplKTsKCWJ1ZmZlci0+cG9zbiArPSBzaXplOwoKCXJldHVybiBzaXplOwp9CgojaWZuZGVmIE5PX0NVUkxfSU9DVEwKY3VybGlvZXJyIGlvY3RsX2J1ZmZlcihDVVJMICpoYW5kbGUsIGludCBjbWQsIHZvaWQgKmNsaWVudHApCnsKCXN0cnVjdCBidWZmZXIgKmJ1ZmZlciA9IGNsaWVudHA7CgoJc3dpdGNoIChjbWQpIHsKCWNhc2UgQ1VSTElPQ01EX05PUDoKCQlyZXR1cm4gQ1VSTElPRV9PSzsKCgljYXNlIENVUkxJT0NNRF9SRVNUQVJUUkVBRDoKCQlidWZmZXItPnBvc24gPSAwOwoJCXJldHVybiBDVVJMSU9FX09LOwoKCWRlZmF1bHQ6CgkJcmV0dXJuIENVUkxJT0VfVU5LTk9XTkNNRDsKCX0KfQojZW5kaWYKCnNpemVfdCBmd3JpdGVfYnVmZmVyKGNoYXIgKnB0ciwgc2l6ZV90IGVsdHNpemUsIHNpemVfdCBubWVtYiwgdm9pZCAqYnVmZmVyXykKewoJc2l6ZV90IHNpemUgPSBlbHRzaXplICogbm1lbWI7CglzdHJ1Y3Qgc3RyYnVmICpidWZmZXIgPSBidWZmZXJfOwoKCXN0cmJ1Zl9hZGQoYnVmZmVyLCBwdHIsIHNpemUpOwoJZGF0YV9yZWNlaXZlZCsrOwoJcmV0dXJuIHNpemU7Cn0KCnNpemVfdCBmd3JpdGVfbnVsbChjaGFyICpwdHIsIHNpemVfdCBlbHRzaXplLCBzaXplX3Qgbm1lbWIsIHZvaWQgKnN0cmJ1ZikKewoJZGF0YV9yZWNlaXZlZCsrOwoJcmV0dXJuIGVsdHNpemUgKiBubWVtYjsKfQoKI2lmZGVmIFVTRV9DVVJMX01VTFRJCnN0YXRpYyB2b2lkIHByb2Nlc3NfY3VybF9tZXNzYWdlcyh2b2lkKQp7CglpbnQgbnVtX21lc3NhZ2VzOwoJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3Q7CglDVVJMTXNnICpjdXJsX21lc3NhZ2UgPSBjdXJsX211bHRpX2luZm9fcmVhZChjdXJsbSwgJm51bV9tZXNzYWdlcyk7CgoJd2hpbGUgKGN1cmxfbWVzc2FnZSAhPSBOVUxMKSB7CgkJaWYgKGN1cmxfbWVzc2FnZS0+bXNnID09IENVUkxNU0dfRE9ORSkgewoJCQlpbnQgY3VybF9yZXN1bHQgPSBjdXJsX21lc3NhZ2UtPmRhdGEucmVzdWx0OwoJCQlzbG90ID0gYWN0aXZlX3F1ZXVlX2hlYWQ7CgkJCXdoaWxlIChzbG90ICE9IE5VTEwgJiYKCQkJICAgICAgIHNsb3QtPmN1cmwgIT0gY3VybF9tZXNzYWdlLT5lYXN5X2hhbmRsZSkKCQkJCXNsb3QgPSBzbG90LT5uZXh0OwoJCQlpZiAoc2xvdCAhPSBOVUxMKSB7CgkJCQljdXJsX211bHRpX3JlbW92ZV9oYW5kbGUoY3VybG0sIHNsb3QtPmN1cmwpOwoJCQkJc2xvdC0+Y3VybF9yZXN1bHQgPSBjdXJsX3Jlc3VsdDsKCQkJCWZpbmlzaF9hY3RpdmVfc2xvdChzbG90KTsKCQkJfSBlbHNlIHsKCQkJCWZwcmludGYoc3RkZXJyLCAiUmVjZWl2ZWQgRE9ORSBtZXNzYWdlIGZvciB1bmtub3duIHJlcXVlc3QhXG4iKTsKCQkJfQoJCX0gZWxzZSB7CgkJCWZwcmludGYoc3RkZXJyLCAiVW5rbm93biBDVVJMIG1lc3NhZ2UgcmVjZWl2ZWQ6ICVkXG4iLAoJCQkJKGludCljdXJsX21lc3NhZ2UtPm1zZyk7CgkJfQoJCWN1cmxfbWVzc2FnZSA9IGN1cmxfbXVsdGlfaW5mb19yZWFkKGN1cmxtLCAmbnVtX21lc3NhZ2VzKTsKCX0KfQojZW5kaWYKCnN0YXRpYyBjaGFyICpnaXRfZ2V0cGFzc193aXRoX2Rlc2NyaXB0aW9uKGNvbnN0IGNoYXIgKndoYXQsIGNvbnN0IGNoYXIgKmRlc2MpCnsKCXN0cnVjdCBzdHJidWYgcHJvbXB0ID0gU1RSQlVGX0lOSVQ7CgljaGFyICpyOwoKCWlmIChkZXNjKQoJCXN0cmJ1Zl9hZGRmKCZwcm9tcHQsICIlcyBmb3IgJyVzJzogIiwgd2hhdCwgZGVzYyk7CgllbHNlCgkJc3RyYnVmX2FkZGYoJnByb21wdCwgIiVzOiAiLCB3aGF0KTsKCS8qCgkgKiBORUVEU1dPUks6IGZvciB1c2VybmFtZXMsIHdlIHNob3VsZCBkbyBzb21ldGhpbmcgbGVzcyBtYWdpY2FsIHRoYXQKCSAqIGFjdHVhbGx5IGVjaG9lcyB0aGUgY2hhcmFjdGVycy4gSG93ZXZlciwgd2UgbmVlZCB0byByZWFkIGZyb20KCSAqIC9kZXYvdHR5IGFuZCBub3Qgc3RkaW8sIHdoaWNoIGlzIG5vdCBwb3J0YWJsZSAoYnV0IGdldHBhc3Mgd2lsbCBkbwoJICogaXQgZm9yIHVzKS4gaHR0cC5jIHVzZXMgdGhlIHNhbWUgd29ya2Fyb3VuZC4KCSAqLwoJciA9IGdpdF9nZXRwYXNzKHByb21wdC5idWYpOwoKCXN0cmJ1Zl9yZWxlYXNlKCZwcm9tcHQpOwoJcmV0dXJuIHhzdHJkdXAocik7Cn0KCnN0YXRpYyBpbnQgaHR0cF9vcHRpb25zKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmNiKQp7CglpZiAoIXN0cmNtcCgiaHR0cC5zc2x2ZXJpZnkiLCB2YXIpKSB7CgkJY3VybF9zc2xfdmVyaWZ5ID0gZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoImh0dHAuc3NsY2VydCIsIHZhcikpCgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZzc2xfY2VydCwgdmFyLCB2YWx1ZSk7CiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwOTAzCglpZiAoIXN0cmNtcCgiaHR0cC5zc2xrZXkiLCB2YXIpKQoJCXJldHVybiBnaXRfY29uZmlnX3N0cmluZygmc3NsX2tleSwgdmFyLCB2YWx1ZSk7CiNlbmRpZgojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MDkwOAoJaWYgKCFzdHJjbXAoImh0dHAuc3NsY2FwYXRoIiwgdmFyKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJnNzbF9jYXBhdGgsIHZhciwgdmFsdWUpOwojZW5kaWYKCWlmICghc3RyY21wKCJodHRwLnNzbGNhaW5mbyIsIHZhcikpCgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZzc2xfY2FpbmZvLCB2YXIsIHZhbHVlKTsKCWlmICghc3RyY21wKCJodHRwLnNzbGNlcnRwYXNzd29yZHByb3RlY3RlZCIsIHZhcikpIHsKCQlpZiAoZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpKQoJCQlzc2xfY2VydF9wYXNzd29yZF9yZXF1aXJlZCA9IDE7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCgiaHR0cC5taW5zZXNzaW9ucyIsIHZhcikpIHsKCQltaW5fY3VybF9zZXNzaW9ucyA9IGdpdF9jb25maWdfaW50KHZhciwgdmFsdWUpOwojaWZuZGVmIFVTRV9DVVJMX01VTFRJCgkJaWYgKG1pbl9jdXJsX3Nlc3Npb25zID4gMSkKCQkJbWluX2N1cmxfc2Vzc2lvbnMgPSAxOwojZW5kaWYKCQlyZXR1cm4gMDsKCX0KI2lmZGVmIFVTRV9DVVJMX01VTFRJCglpZiAoIXN0cmNtcCgiaHR0cC5tYXhyZXF1ZXN0cyIsIHZhcikpIHsKCQltYXhfcmVxdWVzdHMgPSBnaXRfY29uZmlnX2ludCh2YXIsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KI2VuZGlmCglpZiAoIXN0cmNtcCgiaHR0cC5sb3dzcGVlZGxpbWl0IiwgdmFyKSkgewoJCWN1cmxfbG93X3NwZWVkX2xpbWl0ID0gKGxvbmcpZ2l0X2NvbmZpZ19pbnQodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCgiaHR0cC5sb3dzcGVlZHRpbWUiLCB2YXIpKSB7CgkJY3VybF9sb3dfc3BlZWRfdGltZSA9IChsb25nKWdpdF9jb25maWdfaW50KHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoKCWlmICghc3RyY21wKCJodHRwLm5vZXBzdiIsIHZhcikpIHsKCQljdXJsX2Z0cF9ub19lcHN2ID0gZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoImh0dHAucHJveHkiLCB2YXIpKQoJCXJldHVybiBnaXRfY29uZmlnX3N0cmluZygmY3VybF9odHRwX3Byb3h5LCB2YXIsIHZhbHVlKTsKCglpZiAoIXN0cmNtcCgiaHR0cC5jb29raWVmaWxlIiwgdmFyKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJmN1cmxfY29va2llX2ZpbGUsIHZhciwgdmFsdWUpOwoKCWlmICghc3RyY21wKCJodHRwLnBvc3RidWZmZXIiLCB2YXIpKSB7CgkJaHR0cF9wb3N0X2J1ZmZlciA9IGdpdF9jb25maWdfaW50KHZhciwgdmFsdWUpOwoJCWlmIChodHRwX3Bvc3RfYnVmZmVyIDwgTEFSR0VfUEFDS0VUX01BWCkKCQkJaHR0cF9wb3N0X2J1ZmZlciA9IExBUkdFX1BBQ0tFVF9NQVg7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKCFzdHJjbXAoImh0dHAudXNlcmFnZW50IiwgdmFyKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJnVzZXJfYWdlbnQsIHZhciwgdmFsdWUpOwoKCS8qIEZhbGwgYmFjayBvbiB0aGUgZGVmYXVsdCBvbmVzICovCglyZXR1cm4gZ2l0X2RlZmF1bHRfY29uZmlnKHZhciwgdmFsdWUsIGNiKTsKfQoKc3RhdGljIHZvaWQgaW5pdF9jdXJsX2h0dHBfYXV0aChDVVJMICpyZXN1bHQpCnsKCWlmICh1c2VyX25hbWUpIHsKCQlzdHJ1Y3Qgc3RyYnVmIHVwID0gU1RSQlVGX0lOSVQ7CgkJaWYgKCF1c2VyX3Bhc3MpCgkJCXVzZXJfcGFzcyA9IHhzdHJkdXAoZ2l0X2dldHBhc3Nfd2l0aF9kZXNjcmlwdGlvbigiUGFzc3dvcmQiLCBkZXNjcmlwdGlvbikpOwoJCXN0cmJ1Zl9hZGRmKCZ1cCwgIiVzOiVzIiwgdXNlcl9uYW1lLCB1c2VyX3Bhc3MpOwoJCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX1VTRVJQV0QsCgkJCQkgc3RyYnVmX2RldGFjaCgmdXAsIE5VTEwpKTsKCX0KfQoKc3RhdGljIGludCBoYXNfY2VydF9wYXNzd29yZCh2b2lkKQp7CglpZiAoc3NsX2NlcnRfcGFzc3dvcmQgIT0gTlVMTCkKCQlyZXR1cm4gMTsKCWlmIChzc2xfY2VydCA9PSBOVUxMIHx8IHNzbF9jZXJ0X3Bhc3N3b3JkX3JlcXVpcmVkICE9IDEpCgkJcmV0dXJuIDA7CgkvKiBPbmx5IHByb21wdCB0aGUgdXNlciBvbmNlLiAqLwoJc3NsX2NlcnRfcGFzc3dvcmRfcmVxdWlyZWQgPSAtMTsKCXNzbF9jZXJ0X3Bhc3N3b3JkID0gZ2l0X2dldHBhc3Nfd2l0aF9kZXNjcmlwdGlvbigiQ2VydGlmaWNhdGUgUGFzc3dvcmQiLCBkZXNjcmlwdGlvbik7CglpZiAoc3NsX2NlcnRfcGFzc3dvcmQgIT0gTlVMTCkgewoJCXNzbF9jZXJ0X3Bhc3N3b3JkID0geHN0cmR1cChzc2xfY2VydF9wYXNzd29yZCk7CgkJcmV0dXJuIDE7Cgl9IGVsc2UKCQlyZXR1cm4gMDsKfQoKc3RhdGljIENVUkwgKmdldF9jdXJsX2hhbmRsZSh2b2lkKQp7CglDVVJMICpyZXN1bHQgPSBjdXJsX2Vhc3lfaW5pdCgpOwoKCWlmICghY3VybF9zc2xfdmVyaWZ5KSB7CgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfU1NMX1ZFUklGWVBFRVIsIDApOwoJCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX1NTTF9WRVJJRllIT1NULCAwKTsKCX0gZWxzZSB7CgkJLyogVmVyaWZ5IGF1dGhlbnRpY2l0eSBvZiB0aGUgcGVlcidzIGNlcnRpZmljYXRlICovCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfU1NMX1ZFUklGWVBFRVIsIDEpOwoJCS8qIFRoZSBuYW1lIGluIHRoZSBjZXJ0IG11c3QgbWF0Y2ggd2hvbSB3ZSB0cmllZCB0byBjb25uZWN0ICovCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfU1NMX1ZFUklGWUhPU1QsIDIpOwoJfQoKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzA5MDcKCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX05FVFJDLCBDVVJMX05FVFJDX09QVElPTkFMKTsKI2VuZGlmCiNpZmRlZiBMSUJDVVJMX0NBTl9IQU5ETEVfQVVUSF9BTlkKCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX0hUVFBBVVRILCBDVVJMQVVUSF9BTlkpOwojZW5kaWYKCglpbml0X2N1cmxfaHR0cF9hdXRoKHJlc3VsdCk7CgoJaWYgKHNzbF9jZXJ0ICE9IE5VTEwpCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfU1NMQ0VSVCwgc3NsX2NlcnQpOwoJaWYgKGhhc19jZXJ0X3Bhc3N3b3JkKCkpCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfS0VZUEFTU1dELCBzc2xfY2VydF9wYXNzd29yZCk7CiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwOTAzCglpZiAoc3NsX2tleSAhPSBOVUxMKQoJCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX1NTTEtFWSwgc3NsX2tleSk7CiNlbmRpZgojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MDkwOAoJaWYgKHNzbF9jYXBhdGggIT0gTlVMTCkKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9DQVBBVEgsIHNzbF9jYXBhdGgpOwojZW5kaWYKCWlmIChzc2xfY2FpbmZvICE9IE5VTEwpCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfQ0FJTkZPLCBzc2xfY2FpbmZvKTsKCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX0ZBSUxPTkVSUk9SLCAxKTsKCglpZiAoY3VybF9sb3dfc3BlZWRfbGltaXQgPiAwICYmIGN1cmxfbG93X3NwZWVkX3RpbWUgPiAwKSB7CgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfTE9XX1NQRUVEX0xJTUlULAoJCQkJIGN1cmxfbG93X3NwZWVkX2xpbWl0KTsKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9MT1dfU1BFRURfVElNRSwKCQkJCSBjdXJsX2xvd19zcGVlZF90aW1lKTsKCX0KCgljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9GT0xMT1dMT0NBVElPTiwgMSk7CiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcxMzAxCgljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9QT1NUUkVESVIsIENVUkxfUkVESVJfUE9TVF9BTEwpOwojZWxpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcxMTAxCgljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9QT1NUMzAxLCAxKTsKI2VuZGlmCgoJaWYgKGdldGVudigiR0lUX0NVUkxfVkVSQk9TRSIpKQoJCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX1ZFUkJPU0UsIDEpOwoKCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX1VTRVJBR0VOVCwKCQl1c2VyX2FnZW50ID8gdXNlcl9hZ2VudCA6IEdJVF9IVFRQX1VTRVJfQUdFTlQpOwoKCWlmIChjdXJsX2Z0cF9ub19lcHN2KQoJCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX0ZUUF9VU0VfRVBTViwgMCk7CgoJaWYgKGN1cmxfaHR0cF9wcm94eSkKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9QUk9YWSwgY3VybF9odHRwX3Byb3h5KTsKCglyZXR1cm4gcmVzdWx0Owp9CgpzdGF0aWMgdm9pZCBodHRwX2F1dGhfaW5pdChjb25zdCBjaGFyICp1cmwpCnsKCWNvbnN0IGNoYXIgKmF0LCAqY29sb24sICpjcCwgKnNsYXNoLCAqaG9zdDsKCgljcCA9IHN0cnN0cih1cmwsICI6Ly8iKTsKCWlmICghY3ApCgkJcmV0dXJuOwoKCS8qCgkgKiBPaywgdGhlIFVSTCBsb29rcyBsaWtlICJwcm90bzovL3NvbWV0aGluZyIuICBXaGljaCBvbmU/CgkgKiAicHJvdG86Ly88dXNlcj46PHBhc3M+QDxob3N0Pi8uLi4iLAoJICogInByb3RvOi8vPHVzZXI+QDxob3N0Pi8uLi4iLCBvciBqdXN0CgkgKiAicHJvdG86Ly88aG9zdD4vLi4uIj8KCSAqLwoJY3AgKz0gMzsKCWF0ID0gc3RyY2hyKGNwLCAnQCcpOwoJY29sb24gPSBzdHJjaHIoY3AsICc6Jyk7CglzbGFzaCA9IHN0cmNocm51bChjcCwgJy8nKTsKCWlmICghYXQgfHwgc2xhc2ggPD0gYXQpIHsKCQkvKiBObyBjcmVkZW50aWFscywgYnV0IHdlIG1heSBoYXZlIHRvIGFzayBmb3Igc29tZSBsYXRlciAqLwoJCWhvc3QgPSBjcDsKCX0KCWVsc2UgaWYgKCFjb2xvbiB8fCBhdCA8PSBjb2xvbikgewoJCS8qIE9ubHkgdXNlcm5hbWUgKi8KCQl1c2VyX25hbWUgPSB1cmxfZGVjb2RlX21lbShjcCwgYXQgLSBjcCk7CgkJdXNlcl9wYXNzID0gTlVMTDsKCQlob3N0ID0gYXQgKyAxOwoJfSBlbHNlIHsKCQl1c2VyX25hbWUgPSB1cmxfZGVjb2RlX21lbShjcCwgY29sb24gLSBjcCk7CgkJdXNlcl9wYXNzID0gdXJsX2RlY29kZV9tZW0oY29sb24gKyAxLCBhdCAtIChjb2xvbiArIDEpKTsKCQlob3N0ID0gYXQgKyAxOwoJfQoKCWRlc2NyaXB0aW9uID0gdXJsX2RlY29kZV9tZW0oaG9zdCwgc2xhc2ggLSBob3N0KTsKfQoKc3RhdGljIHZvaWQgc2V0X2Zyb21fZW52KGNvbnN0IGNoYXIgKip2YXIsIGNvbnN0IGNoYXIgKmVudm5hbWUpCnsKCWNvbnN0IGNoYXIgKnZhbCA9IGdldGVudihlbnZuYW1lKTsKCWlmICh2YWwpCgkJKnZhciA9IHZhbDsKfQoKdm9pZCBodHRwX2luaXQoc3RydWN0IHJlbW90ZSAqcmVtb3RlLCBjb25zdCBjaGFyICp1cmwpCnsKCWNoYXIgKmxvd19zcGVlZF9saW1pdDsKCWNoYXIgKmxvd19zcGVlZF90aW1lOwoKCWh0dHBfaXNfdmVyYm9zZSA9IDA7CgoJZ2l0X2NvbmZpZyhodHRwX29wdGlvbnMsIE5VTEwpOwoKCWN1cmxfZ2xvYmFsX2luaXQoQ1VSTF9HTE9CQUxfQUxMKTsKCglpZiAocmVtb3RlICYmIHJlbW90ZS0+aHR0cF9wcm94eSkKCQljdXJsX2h0dHBfcHJveHkgPSB4c3RyZHVwKHJlbW90ZS0+aHR0cF9wcm94eSk7CgoJcHJhZ21hX2hlYWRlciA9IGN1cmxfc2xpc3RfYXBwZW5kKHByYWdtYV9oZWFkZXIsICJQcmFnbWE6IG5vLWNhY2hlIik7Cglub19wcmFnbWFfaGVhZGVyID0gY3VybF9zbGlzdF9hcHBlbmQobm9fcHJhZ21hX2hlYWRlciwgIlByYWdtYToiKTsKCiNpZmRlZiBVU0VfQ1VSTF9NVUxUSQoJewoJCWNoYXIgKmh0dHBfbWF4X3JlcXVlc3RzID0gZ2V0ZW52KCJHSVRfSFRUUF9NQVhfUkVRVUVTVFMiKTsKCQlpZiAoaHR0cF9tYXhfcmVxdWVzdHMgIT0gTlVMTCkKCQkJbWF4X3JlcXVlc3RzID0gYXRvaShodHRwX21heF9yZXF1ZXN0cyk7Cgl9CgoJY3VybG0gPSBjdXJsX211bHRpX2luaXQoKTsKCWlmIChjdXJsbSA9PSBOVUxMKSB7CgkJZnByaW50ZihzdGRlcnIsICJFcnJvciBjcmVhdGluZyBjdXJsIG11bHRpIGhhbmRsZS5cbiIpOwoJCWV4aXQoMSk7Cgl9CiNlbmRpZgoKCWlmIChnZXRlbnYoIkdJVF9TU0xfTk9fVkVSSUZZIikpCgkJY3VybF9zc2xfdmVyaWZ5ID0gMDsKCglzZXRfZnJvbV9lbnYoJnNzbF9jZXJ0LCAiR0lUX1NTTF9DRVJUIik7CiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwOTAzCglzZXRfZnJvbV9lbnYoJnNzbF9rZXksICJHSVRfU1NMX0tFWSIpOwojZW5kaWYKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzA5MDgKCXNldF9mcm9tX2Vudigmc3NsX2NhcGF0aCwgIkdJVF9TU0xfQ0FQQVRIIik7CiNlbmRpZgoJc2V0X2Zyb21fZW52KCZzc2xfY2FpbmZvLCAiR0lUX1NTTF9DQUlORk8iKTsKCglzZXRfZnJvbV9lbnYoJnVzZXJfYWdlbnQsICJHSVRfSFRUUF9VU0VSX0FHRU5UIik7CgoJbG93X3NwZWVkX2xpbWl0ID0gZ2V0ZW52KCJHSVRfSFRUUF9MT1dfU1BFRURfTElNSVQiKTsKCWlmIChsb3dfc3BlZWRfbGltaXQgIT0gTlVMTCkKCQljdXJsX2xvd19zcGVlZF9saW1pdCA9IHN0cnRvbChsb3dfc3BlZWRfbGltaXQsIE5VTEwsIDEwKTsKCWxvd19zcGVlZF90aW1lID0gZ2V0ZW52KCJHSVRfSFRUUF9MT1dfU1BFRURfVElNRSIpOwoJaWYgKGxvd19zcGVlZF90aW1lICE9IE5VTEwpCgkJY3VybF9sb3dfc3BlZWRfdGltZSA9IHN0cnRvbChsb3dfc3BlZWRfdGltZSwgTlVMTCwgMTApOwoKCWlmIChjdXJsX3NzbF92ZXJpZnkgPT0gLTEpCgkJY3VybF9zc2xfdmVyaWZ5ID0gMTsKCgljdXJsX3Nlc3Npb25fY291bnQgPSAwOwojaWZkZWYgVVNFX0NVUkxfTVVMVEkKCWlmIChtYXhfcmVxdWVzdHMgPCAxKQoJCW1heF9yZXF1ZXN0cyA9IERFRkFVTFRfTUFYX1JFUVVFU1RTOwojZW5kaWYKCglpZiAoZ2V0ZW52KCJHSVRfQ1VSTF9GVFBfTk9fRVBTViIpKQoJCWN1cmxfZnRwX25vX2Vwc3YgPSAxOwoKCWlmICh1cmwpIHsKCQlodHRwX2F1dGhfaW5pdCh1cmwpOwoJCWlmICghc3NsX2NlcnRfcGFzc3dvcmRfcmVxdWlyZWQgJiYKCQkgICAgZ2V0ZW52KCJHSVRfU1NMX0NFUlRfUEFTU1dPUkRfUFJPVEVDVEVEIikgJiYKCQkgICAgIXByZWZpeGNtcCh1cmwsICJodHRwczovLyIpKQoJCQlzc2xfY2VydF9wYXNzd29yZF9yZXF1aXJlZCA9IDE7Cgl9CgojaWZuZGVmIE5PX0NVUkxfRUFTWV9EVVBIQU5ETEUKCWN1cmxfZGVmYXVsdCA9IGdldF9jdXJsX2hhbmRsZSgpOwojZW5kaWYKfQoKdm9pZCBodHRwX2NsZWFudXAodm9pZCkKewoJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3QgPSBhY3RpdmVfcXVldWVfaGVhZDsKCgl3aGlsZSAoc2xvdCAhPSBOVUxMKSB7CgkJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKm5leHQgPSBzbG90LT5uZXh0OwoJCWlmIChzbG90LT5jdXJsICE9IE5VTEwpIHsKI2lmZGVmIFVTRV9DVVJMX01VTFRJCgkJCWN1cmxfbXVsdGlfcmVtb3ZlX2hhbmRsZShjdXJsbSwgc2xvdC0+Y3VybCk7CiNlbmRpZgoJCQljdXJsX2Vhc3lfY2xlYW51cChzbG90LT5jdXJsKTsKCQl9CgkJZnJlZShzbG90KTsKCQlzbG90ID0gbmV4dDsKCX0KCWFjdGl2ZV9xdWV1ZV9oZWFkID0gTlVMTDsKCiNpZm5kZWYgTk9fQ1VSTF9FQVNZX0RVUEhBTkRMRQoJY3VybF9lYXN5X2NsZWFudXAoY3VybF9kZWZhdWx0KTsKI2VuZGlmCgojaWZkZWYgVVNFX0NVUkxfTVVMVEkKCWN1cmxfbXVsdGlfY2xlYW51cChjdXJsbSk7CiNlbmRpZgoJY3VybF9nbG9iYWxfY2xlYW51cCgpOwoKCWN1cmxfc2xpc3RfZnJlZV9hbGwocHJhZ21hX2hlYWRlcik7CglwcmFnbWFfaGVhZGVyID0gTlVMTDsKCgljdXJsX3NsaXN0X2ZyZWVfYWxsKG5vX3ByYWdtYV9oZWFkZXIpOwoJbm9fcHJhZ21hX2hlYWRlciA9IE5VTEw7CgoJaWYgKGN1cmxfaHR0cF9wcm94eSkgewoJCWZyZWUoKHZvaWQgKiljdXJsX2h0dHBfcHJveHkpOwoJCWN1cmxfaHR0cF9wcm94eSA9IE5VTEw7Cgl9CgoJaWYgKHNzbF9jZXJ0X3Bhc3N3b3JkICE9IE5VTEwpIHsKCQltZW1zZXQoc3NsX2NlcnRfcGFzc3dvcmQsIDAsIHN0cmxlbihzc2xfY2VydF9wYXNzd29yZCkpOwoJCWZyZWUoc3NsX2NlcnRfcGFzc3dvcmQpOwoJCXNzbF9jZXJ0X3Bhc3N3b3JkID0gTlVMTDsKCX0KCXNzbF9jZXJ0X3Bhc3N3b3JkX3JlcXVpcmVkID0gMDsKfQoKc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKmdldF9hY3RpdmVfc2xvdCh2b2lkKQp7CglzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdCA9IGFjdGl2ZV9xdWV1ZV9oZWFkOwoJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKm5ld3Nsb3Q7CgojaWZkZWYgVVNFX0NVUkxfTVVMVEkKCWludCBudW1fdHJhbnNmZXJzOwoKCS8qIFdhaXQgZm9yIGEgc2xvdCB0byBvcGVuIHVwIGlmIHRoZSBxdWV1ZSBpcyBmdWxsICovCgl3aGlsZSAoYWN0aXZlX3JlcXVlc3RzID49IG1heF9yZXF1ZXN0cykgewoJCWN1cmxfbXVsdGlfcGVyZm9ybShjdXJsbSwgJm51bV90cmFuc2ZlcnMpOwoJCWlmIChudW1fdHJhbnNmZXJzIDwgYWN0aXZlX3JlcXVlc3RzKQoJCQlwcm9jZXNzX2N1cmxfbWVzc2FnZXMoKTsKCX0KI2VuZGlmCgoJd2hpbGUgKHNsb3QgIT0gTlVMTCAmJiBzbG90LT5pbl91c2UpCgkJc2xvdCA9IHNsb3QtPm5leHQ7CgoJaWYgKHNsb3QgPT0gTlVMTCkgewoJCW5ld3Nsb3QgPSB4bWFsbG9jKHNpemVvZigqbmV3c2xvdCkpOwoJCW5ld3Nsb3QtPmN1cmwgPSBOVUxMOwoJCW5ld3Nsb3QtPmluX3VzZSA9IDA7CgkJbmV3c2xvdC0+bmV4dCA9IE5VTEw7CgoJCXNsb3QgPSBhY3RpdmVfcXVldWVfaGVhZDsKCQlpZiAoc2xvdCA9PSBOVUxMKSB7CgkJCWFjdGl2ZV9xdWV1ZV9oZWFkID0gbmV3c2xvdDsKCQl9IGVsc2UgewoJCQl3aGlsZSAoc2xvdC0+bmV4dCAhPSBOVUxMKQoJCQkJc2xvdCA9IHNsb3QtPm5leHQ7CgkJCXNsb3QtPm5leHQgPSBuZXdzbG90OwoJCX0KCQlzbG90ID0gbmV3c2xvdDsKCX0KCglpZiAoc2xvdC0+Y3VybCA9PSBOVUxMKSB7CiNpZmRlZiBOT19DVVJMX0VBU1lfRFVQSEFORExFCgkJc2xvdC0+Y3VybCA9IGdldF9jdXJsX2hhbmRsZSgpOwojZWxzZQoJCXNsb3QtPmN1cmwgPSBjdXJsX2Vhc3lfZHVwaGFuZGxlKGN1cmxfZGVmYXVsdCk7CiNlbmRpZgoJCWN1cmxfc2Vzc2lvbl9jb3VudCsrOwoJfQoKCWFjdGl2ZV9yZXF1ZXN0cysrOwoJc2xvdC0+aW5fdXNlID0gMTsKCXNsb3QtPmxvY2FsID0gTlVMTDsKCXNsb3QtPnJlc3VsdHMgPSBOVUxMOwoJc2xvdC0+ZmluaXNoZWQgPSBOVUxMOwoJc2xvdC0+Y2FsbGJhY2tfZGF0YSA9IE5VTEw7CglzbG90LT5jYWxsYmFja19mdW5jID0gTlVMTDsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9DT09LSUVGSUxFLCBjdXJsX2Nvb2tpZV9maWxlKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9IVFRQSEVBREVSLCBwcmFnbWFfaGVhZGVyKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9FUlJPUkJVRkZFUiwgY3VybF9lcnJvcnN0cik7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfQ1VTVE9NUkVRVUVTVCwgTlVMTCk7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfUkVBREZVTkNUSU9OLCBOVUxMKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9XUklURUZVTkNUSU9OLCBOVUxMKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NURklFTERTLCBOVUxMKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9VUExPQUQsIDApOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0hUVFBHRVQsIDEpOwoKCXJldHVybiBzbG90Owp9CgppbnQgc3RhcnRfYWN0aXZlX3Nsb3Qoc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3QpCnsKI2lmZGVmIFVTRV9DVVJMX01VTFRJCglDVVJMTWNvZGUgY3VybG1fcmVzdWx0ID0gY3VybF9tdWx0aV9hZGRfaGFuZGxlKGN1cmxtLCBzbG90LT5jdXJsKTsKCWludCBudW1fdHJhbnNmZXJzOwoKCWlmIChjdXJsbV9yZXN1bHQgIT0gQ1VSTE1fT0sgJiYKCSAgICBjdXJsbV9yZXN1bHQgIT0gQ1VSTE1fQ0FMTF9NVUxUSV9QRVJGT1JNKSB7CgkJYWN0aXZlX3JlcXVlc3RzLS07CgkJc2xvdC0+aW5fdXNlID0gMDsKCQlyZXR1cm4gMDsKCX0KCgkvKgoJICogV2Uga25vdyB0aGVyZSBtdXN0IGJlIHNvbWV0aGluZyB0byBkbywgc2luY2Ugd2UganVzdCBhZGRlZAoJICogc29tZXRoaW5nLgoJICovCgljdXJsX211bHRpX3BlcmZvcm0oY3VybG0sICZudW1fdHJhbnNmZXJzKTsKI2VuZGlmCglyZXR1cm4gMTsKfQoKI2lmZGVmIFVTRV9DVVJMX01VTFRJCnN0cnVjdCBmaWxsX2NoYWluIHsKCXZvaWQgKmRhdGE7CglpbnQgKCpmaWxsKSh2b2lkICopOwoJc3RydWN0IGZpbGxfY2hhaW4gKm5leHQ7Cn07CgpzdGF0aWMgc3RydWN0IGZpbGxfY2hhaW4gKmZpbGxfY2ZnOwoKdm9pZCBhZGRfZmlsbF9mdW5jdGlvbih2b2lkICpkYXRhLCBpbnQgKCpmaWxsKSh2b2lkICopKQp7CglzdHJ1Y3QgZmlsbF9jaGFpbiAqbmV3ID0geG1hbGxvYyhzaXplb2YoKm5ldykpOwoJc3RydWN0IGZpbGxfY2hhaW4gKipsaW5rcCA9ICZmaWxsX2NmZzsKCW5ldy0+ZGF0YSA9IGRhdGE7CgluZXctPmZpbGwgPSBmaWxsOwoJbmV3LT5uZXh0ID0gTlVMTDsKCXdoaWxlICgqbGlua3ApCgkJbGlua3AgPSAmKCpsaW5rcCktPm5leHQ7CgkqbGlua3AgPSBuZXc7Cn0KCnZvaWQgZmlsbF9hY3RpdmVfc2xvdHModm9pZCkKewoJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3QgPSBhY3RpdmVfcXVldWVfaGVhZDsKCgl3aGlsZSAoYWN0aXZlX3JlcXVlc3RzIDwgbWF4X3JlcXVlc3RzKSB7CgkJc3RydWN0IGZpbGxfY2hhaW4gKmZpbGw7CgkJZm9yIChmaWxsID0gZmlsbF9jZmc7IGZpbGw7IGZpbGwgPSBmaWxsLT5uZXh0KQoJCQlpZiAoZmlsbC0+ZmlsbChmaWxsLT5kYXRhKSkKCQkJCWJyZWFrOwoKCQlpZiAoIWZpbGwpCgkJCWJyZWFrOwoJfQoKCXdoaWxlIChzbG90ICE9IE5VTEwpIHsKCQlpZiAoIXNsb3QtPmluX3VzZSAmJiBzbG90LT5jdXJsICE9IE5VTEwKCQkJJiYgY3VybF9zZXNzaW9uX2NvdW50ID4gbWluX2N1cmxfc2Vzc2lvbnMpIHsKCQkJY3VybF9lYXN5X2NsZWFudXAoc2xvdC0+Y3VybCk7CgkJCXNsb3QtPmN1cmwgPSBOVUxMOwoJCQljdXJsX3Nlc3Npb25fY291bnQtLTsKCQl9CgkJc2xvdCA9IHNsb3QtPm5leHQ7Cgl9Cn0KCnZvaWQgc3RlcF9hY3RpdmVfc2xvdHModm9pZCkKewoJaW50IG51bV90cmFuc2ZlcnM7CglDVVJMTWNvZGUgY3VybG1fcmVzdWx0OwoKCWRvIHsKCQljdXJsbV9yZXN1bHQgPSBjdXJsX211bHRpX3BlcmZvcm0oY3VybG0sICZudW1fdHJhbnNmZXJzKTsKCX0gd2hpbGUgKGN1cmxtX3Jlc3VsdCA9PSBDVVJMTV9DQUxMX01VTFRJX1BFUkZPUk0pOwoJaWYgKG51bV90cmFuc2ZlcnMgPCBhY3RpdmVfcmVxdWVzdHMpIHsKCQlwcm9jZXNzX2N1cmxfbWVzc2FnZXMoKTsKCQlmaWxsX2FjdGl2ZV9zbG90cygpOwoJfQp9CiNlbmRpZgoKdm9pZCBydW5fYWN0aXZlX3Nsb3Qoc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3QpCnsKI2lmZGVmIFVTRV9DVVJMX01VTFRJCglsb25nIGxhc3RfcG9zID0gMDsKCWxvbmcgY3VycmVudF9wb3M7CglmZF9zZXQgcmVhZGZkczsKCWZkX3NldCB3cml0ZWZkczsKCWZkX3NldCBleGNmZHM7CglpbnQgbWF4X2ZkOwoJc3RydWN0IHRpbWV2YWwgc2VsZWN0X3RpbWVvdXQ7CglpbnQgZmluaXNoZWQgPSAwOwoKCXNsb3QtPmZpbmlzaGVkID0gJmZpbmlzaGVkOwoJd2hpbGUgKCFmaW5pc2hlZCkgewoJCWRhdGFfcmVjZWl2ZWQgPSAwOwoJCXN0ZXBfYWN0aXZlX3Nsb3RzKCk7CgoJCWlmICghZGF0YV9yZWNlaXZlZCAmJiBzbG90LT5sb2NhbCAhPSBOVUxMKSB7CgkJCWN1cnJlbnRfcG9zID0gZnRlbGwoc2xvdC0+bG9jYWwpOwoJCQlpZiAoY3VycmVudF9wb3MgPiBsYXN0X3BvcykKCQkJCWRhdGFfcmVjZWl2ZWQrKzsKCQkJbGFzdF9wb3MgPSBjdXJyZW50X3BvczsKCQl9CgoJCWlmIChzbG90LT5pbl91c2UgJiYgIWRhdGFfcmVjZWl2ZWQpIHsKCQkJbWF4X2ZkID0gMDsKCQkJRkRfWkVSTygmcmVhZGZkcyk7CgkJCUZEX1pFUk8oJndyaXRlZmRzKTsKCQkJRkRfWkVSTygmZXhjZmRzKTsKCQkJc2VsZWN0X3RpbWVvdXQudHZfc2VjID0gMDsKCQkJc2VsZWN0X3RpbWVvdXQudHZfdXNlYyA9IDUwMDAwOwoJCQlzZWxlY3QobWF4X2ZkLCAmcmVhZGZkcywgJndyaXRlZmRzLAoJCQkgICAgICAgJmV4Y2ZkcywgJnNlbGVjdF90aW1lb3V0KTsKCQl9Cgl9CiNlbHNlCgl3aGlsZSAoc2xvdC0+aW5fdXNlKSB7CgkJc2xvdC0+Y3VybF9yZXN1bHQgPSBjdXJsX2Vhc3lfcGVyZm9ybShzbG90LT5jdXJsKTsKCQlmaW5pc2hfYWN0aXZlX3Nsb3Qoc2xvdCk7Cgl9CiNlbmRpZgp9CgpzdGF0aWMgdm9pZCBjbG9zZWRvd25fYWN0aXZlX3Nsb3Qoc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3QpCnsKCWFjdGl2ZV9yZXF1ZXN0cy0tOwoJc2xvdC0+aW5fdXNlID0gMDsKfQoKc3RhdGljIHZvaWQgcmVsZWFzZV9hY3RpdmVfc2xvdChzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdCkKewoJY2xvc2Vkb3duX2FjdGl2ZV9zbG90KHNsb3QpOwoJaWYgKHNsb3QtPmN1cmwgJiYgY3VybF9zZXNzaW9uX2NvdW50ID4gbWluX2N1cmxfc2Vzc2lvbnMpIHsKI2lmZGVmIFVTRV9DVVJMX01VTFRJCgkJY3VybF9tdWx0aV9yZW1vdmVfaGFuZGxlKGN1cmxtLCBzbG90LT5jdXJsKTsKI2VuZGlmCgkJY3VybF9lYXN5X2NsZWFudXAoc2xvdC0+Y3VybCk7CgkJc2xvdC0+Y3VybCA9IE5VTEw7CgkJY3VybF9zZXNzaW9uX2NvdW50LS07Cgl9CiNpZmRlZiBVU0VfQ1VSTF9NVUxUSQoJZmlsbF9hY3RpdmVfc2xvdHMoKTsKI2VuZGlmCn0KCnZvaWQgZmluaXNoX2FjdGl2ZV9zbG90KHN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90KQp7CgljbG9zZWRvd25fYWN0aXZlX3Nsb3Qoc2xvdCk7CgljdXJsX2Vhc3lfZ2V0aW5mbyhzbG90LT5jdXJsLCBDVVJMSU5GT19IVFRQX0NPREUsICZzbG90LT5odHRwX2NvZGUpOwoKCWlmIChzbG90LT5maW5pc2hlZCAhPSBOVUxMKQoJCSgqc2xvdC0+ZmluaXNoZWQpID0gMTsKCgkvKiBTdG9yZSBzbG90IHJlc3VsdHMgc28gdGhleSBjYW4gYmUgcmVhZCBhZnRlciB0aGUgc2xvdCBpcyByZXVzZWQgKi8KCWlmIChzbG90LT5yZXN1bHRzICE9IE5VTEwpIHsKCQlzbG90LT5yZXN1bHRzLT5jdXJsX3Jlc3VsdCA9IHNsb3QtPmN1cmxfcmVzdWx0OwoJCXNsb3QtPnJlc3VsdHMtPmh0dHBfY29kZSA9IHNsb3QtPmh0dHBfY29kZTsKCX0KCgkvKiBSdW4gY2FsbGJhY2sgaWYgYXBwcm9wcmlhdGUgKi8KCWlmIChzbG90LT5jYWxsYmFja19mdW5jICE9IE5VTEwpCgkJc2xvdC0+Y2FsbGJhY2tfZnVuYyhzbG90LT5jYWxsYmFja19kYXRhKTsKfQoKdm9pZCBmaW5pc2hfYWxsX2FjdGl2ZV9zbG90cyh2b2lkKQp7CglzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdCA9IGFjdGl2ZV9xdWV1ZV9oZWFkOwoKCXdoaWxlIChzbG90ICE9IE5VTEwpCgkJaWYgKHNsb3QtPmluX3VzZSkgewoJCQlydW5fYWN0aXZlX3Nsb3Qoc2xvdCk7CgkJCXNsb3QgPSBhY3RpdmVfcXVldWVfaGVhZDsKCQl9IGVsc2UgewoJCQlzbG90ID0gc2xvdC0+bmV4dDsKCQl9Cn0KCi8qIEhlbHBlcnMgZm9yIG1vZGlmeWluZyBhbmQgY3JlYXRpbmcgVVJMcyAqLwpzdGF0aWMgaW5saW5lIGludCBuZWVkc19xdW90ZShpbnQgY2gpCnsKCWlmICgoKGNoID49ICdBJykgJiYgKGNoIDw9ICdaJykpCgkJCXx8ICgoY2ggPj0gJ2EnKSAmJiAoY2ggPD0gJ3onKSkKCQkJfHwgKChjaCA+PSAnMCcpICYmIChjaCA8PSAnOScpKQoJCQl8fCAoY2ggPT0gJy8nKQoJCQl8fCAoY2ggPT0gJy0nKQoJCQl8fCAoY2ggPT0gJy4nKSkKCQlyZXR1cm4gMDsKCXJldHVybiAxOwp9CgpzdGF0aWMgaW5saW5lIGludCBoZXgoaW50IHYpCnsKCWlmICh2IDwgMTApCgkJcmV0dXJuICcwJyArIHY7CgllbHNlCgkJcmV0dXJuICdBJyArIHYgLSAxMDsKfQoKc3RhdGljIGNoYXIgKnF1b3RlX3JlZl91cmwoY29uc3QgY2hhciAqYmFzZSwgY29uc3QgY2hhciAqcmVmKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJY29uc3QgY2hhciAqY3A7CglpbnQgY2g7CgoJZW5kX3VybF93aXRoX3NsYXNoKCZidWYsIGJhc2UpOwoKCWZvciAoY3AgPSByZWY7IChjaCA9ICpjcCkgIT0gMDsgY3ArKykKCQlpZiAobmVlZHNfcXVvdGUoY2gpKQoJCQlzdHJidWZfYWRkZigmYnVmLCAiJSUlMDJ4IiwgY2gpOwoJCWVsc2UKCQkJc3RyYnVmX2FkZGNoKCZidWYsICpjcCk7CgoJcmV0dXJuIHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7Cn0KCnZvaWQgYXBwZW5kX3JlbW90ZV9vYmplY3RfdXJsKHN0cnVjdCBzdHJidWYgKmJ1ZiwgY29uc3QgY2hhciAqdXJsLAoJCQkgICAgICBjb25zdCBjaGFyICpoZXgsCgkJCSAgICAgIGludCBvbmx5X3R3b19kaWdpdF9wcmVmaXgpCnsKCWVuZF91cmxfd2l0aF9zbGFzaChidWYsIHVybCk7CgoJc3RyYnVmX2FkZGYoYnVmLCAib2JqZWN0cy8lLipzLyIsIDIsIGhleCk7CglpZiAoIW9ubHlfdHdvX2RpZ2l0X3ByZWZpeCkKCQlzdHJidWZfYWRkZihidWYsICIlcyIsIGhleCsyKTsKfQoKY2hhciAqZ2V0X3JlbW90ZV9vYmplY3RfdXJsKGNvbnN0IGNoYXIgKnVybCwgY29uc3QgY2hhciAqaGV4LAoJCQkgICAgaW50IG9ubHlfdHdvX2RpZ2l0X3ByZWZpeCkKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWFwcGVuZF9yZW1vdGVfb2JqZWN0X3VybCgmYnVmLCB1cmwsIGhleCwgb25seV90d29fZGlnaXRfcHJlZml4KTsKCXJldHVybiBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpOwp9CgovKiBodHRwX3JlcXVlc3QoKSB0YXJnZXRzICovCiNkZWZpbmUgSFRUUF9SRVFVRVNUX1NUUkJVRgkwCiNkZWZpbmUgSFRUUF9SRVFVRVNUX0ZJTEUJMQoKc3RhdGljIGludCBodHRwX3JlcXVlc3QoY29uc3QgY2hhciAqdXJsLCB2b2lkICpyZXN1bHQsIGludCB0YXJnZXQsIGludCBvcHRpb25zKQp7CglzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdDsKCXN0cnVjdCBzbG90X3Jlc3VsdHMgcmVzdWx0czsKCXN0cnVjdCBjdXJsX3NsaXN0ICpoZWFkZXJzID0gTlVMTDsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglpbnQgcmV0OwoKCXNsb3QgPSBnZXRfYWN0aXZlX3Nsb3QoKTsKCXNsb3QtPnJlc3VsdHMgPSAmcmVzdWx0czsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9IVFRQR0VULCAxKTsKCglpZiAocmVzdWx0ID09IE5VTEwpIHsKCQljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfTk9CT0RZLCAxKTsKCX0gZWxzZSB7CgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX05PQk9EWSwgMCk7CgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0ZJTEUsIHJlc3VsdCk7CgoJCWlmICh0YXJnZXQgPT0gSFRUUF9SRVFVRVNUX0ZJTEUpIHsKCQkJbG9uZyBwb3NuID0gZnRlbGwocmVzdWx0KTsKCQkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1dSSVRFRlVOQ1RJT04sCgkJCQkJIGZ3cml0ZSk7CgkJCWlmIChwb3NuID4gMCkgewoJCQkJc3RyYnVmX2FkZGYoJmJ1ZiwgIlJhbmdlOiBieXRlcz0lbGQtIiwgcG9zbik7CgkJCQloZWFkZXJzID0gY3VybF9zbGlzdF9hcHBlbmQoaGVhZGVycywgYnVmLmJ1Zik7CgkJCQlzdHJidWZfcmVzZXQoJmJ1Zik7CgkJCX0KCQkJc2xvdC0+bG9jYWwgPSByZXN1bHQ7CgkJfSBlbHNlCgkJCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9XUklURUZVTkNUSU9OLAoJCQkJCSBmd3JpdGVfYnVmZmVyKTsKCX0KCglzdHJidWZfYWRkc3RyKCZidWYsICJQcmFnbWE6Iik7CglpZiAob3B0aW9ucyAmIEhUVFBfTk9fQ0FDSEUpCgkJc3RyYnVmX2FkZHN0cigmYnVmLCAiIG5vLWNhY2hlIik7CgoJaGVhZGVycyA9IGN1cmxfc2xpc3RfYXBwZW5kKGhlYWRlcnMsIGJ1Zi5idWYpOwoKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9VUkwsIHVybCk7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfSFRUUEhFQURFUiwgaGVhZGVycyk7CgoJaWYgKHN0YXJ0X2FjdGl2ZV9zbG90KHNsb3QpKSB7CgkJcnVuX2FjdGl2ZV9zbG90KHNsb3QpOwoJCWlmIChyZXN1bHRzLmN1cmxfcmVzdWx0ID09IENVUkxFX09LKQoJCQlyZXQgPSBIVFRQX09LOwoJCWVsc2UgaWYgKG1pc3NpbmdfdGFyZ2V0KCZyZXN1bHRzKSkKCQkJcmV0ID0gSFRUUF9NSVNTSU5HX1RBUkdFVDsKCQllbHNlIGlmIChyZXN1bHRzLmh0dHBfY29kZSA9PSA0MDEpIHsKCQkJaWYgKHVzZXJfbmFtZSkgewoJCQkJcmV0ID0gSFRUUF9OT0FVVEg7CgkJCX0gZWxzZSB7CgkJCQkvKgoJCQkJICogZ2l0X2dldHBhc3MgaXMgbmVlZGVkIGhlcmUgYmVjYXVzZSBpdHMgdmVyeSBsaWtlbHkgc3RkaW4vc3Rkb3V0IGFyZQoJCQkJICogcGlwZXMgdG8gb3VyIHBhcmVudCBwcm9jZXNzLiAgU28gd2UgaW5zdGVhZCBuZWVkIHRvIHVzZSAvZGV2L3R0eSwKCQkJCSAqIGJ1dCB0aGF0IGlzIG5vbi1wb3J0YWJsZS4gIFVzaW5nIGdpdF9nZXRwYXNzKCkgY2FuIGF0IGxlYXN0IGJlIHN0dWJiZWQKCQkJCSAqIG9uIG90aGVyIHBsYXRmb3JtcyB3aXRoIGEgZGlmZmVyZW50IGltcGxlbWVudGF0aW9uIGlmL3doZW4gbmVjZXNzYXJ5LgoJCQkJICovCgkJCQl1c2VyX25hbWUgPSB4c3RyZHVwKGdpdF9nZXRwYXNzX3dpdGhfZGVzY3JpcHRpb24oIlVzZXJuYW1lIiwgZGVzY3JpcHRpb24pKTsKCQkJCWluaXRfY3VybF9odHRwX2F1dGgoc2xvdC0+Y3VybCk7CgkJCQlyZXQgPSBIVFRQX1JFQVVUSDsKCQkJfQoJCX0gZWxzZQoJCQlyZXQgPSBIVFRQX0VSUk9SOwoJfSBlbHNlIHsKCQllcnJvcigiVW5hYmxlIHRvIHN0YXJ0IEhUVFAgcmVxdWVzdCBmb3IgJXMiLCB1cmwpOwoJCXJldCA9IEhUVFBfU1RBUlRfRkFJTEVEOwoJfQoKCXNsb3QtPmxvY2FsID0gTlVMTDsKCWN1cmxfc2xpc3RfZnJlZV9hbGwoaGVhZGVycyk7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IGh0dHBfcmVxdWVzdF9yZWF1dGgoY29uc3QgY2hhciAqdXJsLCB2b2lkICpyZXN1bHQsIGludCB0YXJnZXQsCgkJCSAgICAgICBpbnQgb3B0aW9ucykKewoJaW50IHJldCA9IGh0dHBfcmVxdWVzdCh1cmwsIHJlc3VsdCwgdGFyZ2V0LCBvcHRpb25zKTsKCWlmIChyZXQgIT0gSFRUUF9SRUFVVEgpCgkJcmV0dXJuIHJldDsKCXJldHVybiBodHRwX3JlcXVlc3QodXJsLCByZXN1bHQsIHRhcmdldCwgb3B0aW9ucyk7Cn0KCmludCBodHRwX2dldF9zdHJidWYoY29uc3QgY2hhciAqdXJsLCBzdHJ1Y3Qgc3RyYnVmICpyZXN1bHQsIGludCBvcHRpb25zKQp7CglyZXR1cm4gaHR0cF9yZXF1ZXN0X3JlYXV0aCh1cmwsIHJlc3VsdCwgSFRUUF9SRVFVRVNUX1NUUkJVRiwgb3B0aW9ucyk7Cn0KCi8qCiAqIERvd25sb2FkcyBhbiB1cmwgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSBnaXZlbiBmaWxlLgogKgogKiBJZiBhIHByZXZpb3VzIGludGVycnVwdGVkIGRvd25sb2FkIGlzIGRldGVjdGVkIChpLmUuIGEgcHJldmlvdXMgdGVtcG9yYXJ5CiAqIGZpbGUgaXMgc3RpbGwgYXJvdW5kKSB0aGUgZG93bmxvYWQgaXMgcmVzdW1lZC4KICovCnN0YXRpYyBpbnQgaHR0cF9nZXRfZmlsZShjb25zdCBjaGFyICp1cmwsIGNvbnN0IGNoYXIgKmZpbGVuYW1lLCBpbnQgb3B0aW9ucykKewoJaW50IHJldDsKCXN0cnVjdCBzdHJidWYgdG1wZmlsZSA9IFNUUkJVRl9JTklUOwoJRklMRSAqcmVzdWx0OwoKCXN0cmJ1Zl9hZGRmKCZ0bXBmaWxlLCAiJXMudGVtcCIsIGZpbGVuYW1lKTsKCXJlc3VsdCA9IGZvcGVuKHRtcGZpbGUuYnVmLCAiYSIpOwoJaWYgKCEgcmVzdWx0KSB7CgkJZXJyb3IoIlVuYWJsZSB0byBvcGVuIGxvY2FsIGZpbGUgJXMiLCB0bXBmaWxlLmJ1Zik7CgkJcmV0ID0gSFRUUF9FUlJPUjsKCQlnb3RvIGNsZWFudXA7Cgl9CgoJcmV0ID0gaHR0cF9yZXF1ZXN0X3JlYXV0aCh1cmwsIHJlc3VsdCwgSFRUUF9SRVFVRVNUX0ZJTEUsIG9wdGlvbnMpOwoJZmNsb3NlKHJlc3VsdCk7CgoJaWYgKChyZXQgPT0gSFRUUF9PSykgJiYgbW92ZV90ZW1wX3RvX2ZpbGUodG1wZmlsZS5idWYsIGZpbGVuYW1lKSkKCQlyZXQgPSBIVFRQX0VSUk9SOwpjbGVhbnVwOgoJc3RyYnVmX3JlbGVhc2UoJnRtcGZpbGUpOwoJcmV0dXJuIHJldDsKfQoKaW50IGh0dHBfZXJyb3IoY29uc3QgY2hhciAqdXJsLCBpbnQgcmV0KQp7CgkvKiBodHRwX3JlcXVlc3QgaGFzIGFscmVhZHkgaGFuZGxlZCBIVFRQX1NUQVJUX0ZBSUxFRC4gKi8KCWlmIChyZXQgIT0gSFRUUF9TVEFSVF9GQUlMRUQpCgkJZXJyb3IoIiVzIHdoaWxlIGFjY2Vzc2luZyAlc1xuIiwgY3VybF9lcnJvcnN0ciwgdXJsKTsKCglyZXR1cm4gcmV0Owp9CgppbnQgaHR0cF9mZXRjaF9yZWYoY29uc3QgY2hhciAqYmFzZSwgc3RydWN0IHJlZiAqcmVmKQp7CgljaGFyICp1cmw7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZmZlciA9IFNUUkJVRl9JTklUOwoJaW50IHJldCA9IC0xOwoKCXVybCA9IHF1b3RlX3JlZl91cmwoYmFzZSwgcmVmLT5uYW1lKTsKCWlmIChodHRwX2dldF9zdHJidWYodXJsLCAmYnVmZmVyLCBIVFRQX05PX0NBQ0hFKSA9PSBIVFRQX09LKSB7CgkJc3RyYnVmX3J0cmltKCZidWZmZXIpOwoJCWlmIChidWZmZXIubGVuID09IDQwKQoJCQlyZXQgPSBnZXRfc2hhMV9oZXgoYnVmZmVyLmJ1ZiwgcmVmLT5vbGRfc2hhMSk7CgkJZWxzZSBpZiAoIXByZWZpeGNtcChidWZmZXIuYnVmLCAicmVmOiAiKSkgewoJCQlyZWYtPnN5bXJlZiA9IHhzdHJkdXAoYnVmZmVyLmJ1ZiArIDUpOwoJCQlyZXQgPSAwOwoJCX0KCX0KCglzdHJidWZfcmVsZWFzZSgmYnVmZmVyKTsKCWZyZWUodXJsKTsKCXJldHVybiByZXQ7Cn0KCi8qIEhlbHBlcnMgZm9yIGZldGNoaW5nIHBhY2tzICovCnN0YXRpYyBjaGFyICpmZXRjaF9wYWNrX2luZGV4KHVuc2lnbmVkIGNoYXIgKnNoYTEsIGNvbnN0IGNoYXIgKmJhc2VfdXJsKQp7CgljaGFyICp1cmwsICp0bXA7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoKCWlmIChodHRwX2lzX3ZlcmJvc2UpCgkJZnByaW50ZihzdGRlcnIsICJHZXR0aW5nIGluZGV4IGZvciBwYWNrICVzXG4iLCBzaGExX3RvX2hleChzaGExKSk7CgoJZW5kX3VybF93aXRoX3NsYXNoKCZidWYsIGJhc2VfdXJsKTsKCXN0cmJ1Zl9hZGRmKCZidWYsICJvYmplY3RzL3BhY2svcGFjay0lcy5pZHgiLCBzaGExX3RvX2hleChzaGExKSk7Cgl1cmwgPSBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpOwoKCXN0cmJ1Zl9hZGRmKCZidWYsICIlcy50ZW1wIiwgc2hhMV9wYWNrX2luZGV4X25hbWUoc2hhMSkpOwoJdG1wID0gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCglpZiAoaHR0cF9nZXRfZmlsZSh1cmwsIHRtcCwgMCkgIT0gSFRUUF9PSykgewoJCWVycm9yKCJVbmFibGUgdG8gZ2V0IHBhY2sgaW5kZXggJXNcbiIsIHVybCk7CgkJZnJlZSh0bXApOwoJCXRtcCA9IE5VTEw7Cgl9CgoJZnJlZSh1cmwpOwoJcmV0dXJuIHRtcDsKfQoKc3RhdGljIGludCBmZXRjaF9hbmRfc2V0dXBfcGFja19pbmRleChzdHJ1Y3QgcGFja2VkX2dpdCAqKnBhY2tzX2hlYWQsCgl1bnNpZ25lZCBjaGFyICpzaGExLCBjb25zdCBjaGFyICpiYXNlX3VybCkKewoJc3RydWN0IHBhY2tlZF9naXQgKm5ld19wYWNrOwoJY2hhciAqdG1wX2lkeCA9IE5VTEw7CglpbnQgcmV0OwoKCWlmIChoYXNfcGFja19pbmRleChzaGExKSkgewoJCW5ld19wYWNrID0gcGFyc2VfcGFja19pbmRleChzaGExLCBOVUxMKTsKCQlpZiAoIW5ld19wYWNrKQoJCQlyZXR1cm4gLTE7IC8qIHBhcnNlX3BhY2tfaW5kZXgoKSBhbHJlYWR5IGlzc3VlZCBlcnJvciBtZXNzYWdlICovCgkJZ290byBhZGRfcGFjazsKCX0KCgl0bXBfaWR4ID0gZmV0Y2hfcGFja19pbmRleChzaGExLCBiYXNlX3VybCk7CglpZiAoIXRtcF9pZHgpCgkJcmV0dXJuIC0xOwoKCW5ld19wYWNrID0gcGFyc2VfcGFja19pbmRleChzaGExLCB0bXBfaWR4KTsKCWlmICghbmV3X3BhY2spIHsKCQl1bmxpbmsodG1wX2lkeCk7CgkJZnJlZSh0bXBfaWR4KTsKCgkJcmV0dXJuIC0xOyAvKiBwYXJzZV9wYWNrX2luZGV4KCkgYWxyZWFkeSBpc3N1ZWQgZXJyb3IgbWVzc2FnZSAqLwoJfQoKCXJldCA9IHZlcmlmeV9wYWNrX2luZGV4KG5ld19wYWNrKTsKCWlmICghcmV0KSB7CgkJY2xvc2VfcGFja19pbmRleChuZXdfcGFjayk7CgkJcmV0ID0gbW92ZV90ZW1wX3RvX2ZpbGUodG1wX2lkeCwgc2hhMV9wYWNrX2luZGV4X25hbWUoc2hhMSkpOwoJfQoJZnJlZSh0bXBfaWR4KTsKCWlmIChyZXQpCgkJcmV0dXJuIC0xOwoKYWRkX3BhY2s6CgluZXdfcGFjay0+bmV4dCA9ICpwYWNrc19oZWFkOwoJKnBhY2tzX2hlYWQgPSBuZXdfcGFjazsKCXJldHVybiAwOwp9CgppbnQgaHR0cF9nZXRfaW5mb19wYWNrcyhjb25zdCBjaGFyICpiYXNlX3VybCwgc3RydWN0IHBhY2tlZF9naXQgKipwYWNrc19oZWFkKQp7CglpbnQgcmV0ID0gMCwgaSA9IDA7CgljaGFyICp1cmwsICpkYXRhOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgoJZW5kX3VybF93aXRoX3NsYXNoKCZidWYsIGJhc2VfdXJsKTsKCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgIm9iamVjdHMvaW5mby9wYWNrcyIpOwoJdXJsID0gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCglyZXQgPSBodHRwX2dldF9zdHJidWYodXJsLCAmYnVmLCBIVFRQX05PX0NBQ0hFKTsKCWlmIChyZXQgIT0gSFRUUF9PSykKCQlnb3RvIGNsZWFudXA7CgoJZGF0YSA9IGJ1Zi5idWY7Cgl3aGlsZSAoaSA8IGJ1Zi5sZW4pIHsKCQlzd2l0Y2ggKGRhdGFbaV0pIHsKCQljYXNlICdQJzoKCQkJaSsrOwoJCQlpZiAoaSArIDUyIDw9IGJ1Zi5sZW4gJiYKCQkJICAgICFwcmVmaXhjbXAoZGF0YSArIGksICIgcGFjay0iKSAmJgoJCQkgICAgIXByZWZpeGNtcChkYXRhICsgaSArIDQ2LCAiLnBhY2tcbiIpKSB7CgkJCQlnZXRfc2hhMV9oZXgoZGF0YSArIGkgKyA2LCBzaGExKTsKCQkJCWZldGNoX2FuZF9zZXR1cF9wYWNrX2luZGV4KHBhY2tzX2hlYWQsIHNoYTEsCgkJCQkJCSAgICAgIGJhc2VfdXJsKTsKCQkJCWkgKz0gNTE7CgkJCQlicmVhazsKCQkJfQoJCWRlZmF1bHQ6CgkJCXdoaWxlIChpIDwgYnVmLmxlbiAmJiBkYXRhW2ldICE9ICdcbicpCgkJCQlpKys7CgkJfQoJCWkrKzsKCX0KCmNsZWFudXA6CglmcmVlKHVybCk7CglyZXR1cm4gcmV0Owp9Cgp2b2lkIHJlbGVhc2VfaHR0cF9wYWNrX3JlcXVlc3Qoc3RydWN0IGh0dHBfcGFja19yZXF1ZXN0ICpwcmVxKQp7CglpZiAocHJlcS0+cGFja2ZpbGUgIT0gTlVMTCkgewoJCWZjbG9zZShwcmVxLT5wYWNrZmlsZSk7CgkJcHJlcS0+cGFja2ZpbGUgPSBOVUxMOwoJCXByZXEtPnNsb3QtPmxvY2FsID0gTlVMTDsKCX0KCWlmIChwcmVxLT5yYW5nZV9oZWFkZXIgIT0gTlVMTCkgewoJCWN1cmxfc2xpc3RfZnJlZV9hbGwocHJlcS0+cmFuZ2VfaGVhZGVyKTsKCQlwcmVxLT5yYW5nZV9oZWFkZXIgPSBOVUxMOwoJfQoJcHJlcS0+c2xvdCA9IE5VTEw7CglmcmVlKHByZXEtPnVybCk7Cn0KCmludCBmaW5pc2hfaHR0cF9wYWNrX3JlcXVlc3Qoc3RydWN0IGh0dHBfcGFja19yZXF1ZXN0ICpwcmVxKQp7CglzdHJ1Y3QgcGFja2VkX2dpdCAqKmxzdDsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwID0gcHJlcS0+dGFyZ2V0OwoJY2hhciAqdG1wX2lkeDsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGlwOwoJY29uc3QgY2hhciAqaXBfYXJndls4XTsKCgljbG9zZV9wYWNrX2luZGV4KHApOwoKCWZjbG9zZShwcmVxLT5wYWNrZmlsZSk7CglwcmVxLT5wYWNrZmlsZSA9IE5VTEw7CglwcmVxLT5zbG90LT5sb2NhbCA9IE5VTEw7CgoJbHN0ID0gcHJlcS0+bHN0OwoJd2hpbGUgKCpsc3QgIT0gcCkKCQlsc3QgPSAmKCgqbHN0KS0+bmV4dCk7CgkqbHN0ID0gKCpsc3QpLT5uZXh0OwoKCXRtcF9pZHggPSB4c3RyZHVwKHByZXEtPnRtcGZpbGUpOwoJc3RyY3B5KHRtcF9pZHggKyBzdHJsZW4odG1wX2lkeCkgLSBzdHJsZW4oIi5wYWNrLnRlbXAiKSwKCSAgICAgICAiLmlkeC50ZW1wIik7CgoJaXBfYXJndlswXSA9ICJpbmRleC1wYWNrIjsKCWlwX2FyZ3ZbMV0gPSAiLW8iOwoJaXBfYXJndlsyXSA9IHRtcF9pZHg7CglpcF9hcmd2WzNdID0gcHJlcS0+dG1wZmlsZTsKCWlwX2FyZ3ZbNF0gPSBOVUxMOwoKCW1lbXNldCgmaXAsIDAsIHNpemVvZihpcCkpOwoJaXAuYXJndiA9IGlwX2FyZ3Y7CglpcC5naXRfY21kID0gMTsKCWlwLm5vX3N0ZGluID0gMTsKCWlwLm5vX3N0ZG91dCA9IDE7CgoJaWYgKHJ1bl9jb21tYW5kKCZpcCkpIHsKCQl1bmxpbmsocHJlcS0+dG1wZmlsZSk7CgkJdW5saW5rKHRtcF9pZHgpOwoJCWZyZWUodG1wX2lkeCk7CgkJcmV0dXJuIC0xOwoJfQoKCXVubGluayhzaGExX3BhY2tfaW5kZXhfbmFtZShwLT5zaGExKSk7CgoJaWYgKG1vdmVfdGVtcF90b19maWxlKHByZXEtPnRtcGZpbGUsIHNoYTFfcGFja19uYW1lKHAtPnNoYTEpKQoJIHx8IG1vdmVfdGVtcF90b19maWxlKHRtcF9pZHgsIHNoYTFfcGFja19pbmRleF9uYW1lKHAtPnNoYTEpKSkgewoJCWZyZWUodG1wX2lkeCk7CgkJcmV0dXJuIC0xOwoJfQoKCWluc3RhbGxfcGFja2VkX2dpdChwKTsKCWZyZWUodG1wX2lkeCk7CglyZXR1cm4gMDsKfQoKc3RydWN0IGh0dHBfcGFja19yZXF1ZXN0ICpuZXdfaHR0cF9wYWNrX3JlcXVlc3QoCglzdHJ1Y3QgcGFja2VkX2dpdCAqdGFyZ2V0LCBjb25zdCBjaGFyICpiYXNlX3VybCkKewoJbG9uZyBwcmV2X3Bvc24gPSAwOwoJY2hhciByYW5nZVtSQU5HRV9IRUFERVJfU0laRV07CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJc3RydWN0IGh0dHBfcGFja19yZXF1ZXN0ICpwcmVxOwoKCXByZXEgPSB4bWFsbG9jKHNpemVvZigqcHJlcSkpOwoJcHJlcS0+dGFyZ2V0ID0gdGFyZ2V0OwoJcHJlcS0+cmFuZ2VfaGVhZGVyID0gTlVMTDsKCgllbmRfdXJsX3dpdGhfc2xhc2goJmJ1ZiwgYmFzZV91cmwpOwoJc3RyYnVmX2FkZGYoJmJ1ZiwgIm9iamVjdHMvcGFjay9wYWNrLSVzLnBhY2siLAoJCXNoYTFfdG9faGV4KHRhcmdldC0+c2hhMSkpOwoJcHJlcS0+dXJsID0gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCglzbnByaW50ZihwcmVxLT50bXBmaWxlLCBzaXplb2YocHJlcS0+dG1wZmlsZSksICIlcy50ZW1wIiwKCQlzaGExX3BhY2tfbmFtZSh0YXJnZXQtPnNoYTEpKTsKCXByZXEtPnBhY2tmaWxlID0gZm9wZW4ocHJlcS0+dG1wZmlsZSwgImEiKTsKCWlmICghcHJlcS0+cGFja2ZpbGUpIHsKCQllcnJvcigiVW5hYmxlIHRvIG9wZW4gbG9jYWwgZmlsZSAlcyBmb3IgcGFjayIsCgkJICAgICAgcHJlcS0+dG1wZmlsZSk7CgkJZ290byBhYm9ydDsKCX0KCglwcmVxLT5zbG90ID0gZ2V0X2FjdGl2ZV9zbG90KCk7CglwcmVxLT5zbG90LT5sb2NhbCA9IHByZXEtPnBhY2tmaWxlOwoJY3VybF9lYXN5X3NldG9wdChwcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX0ZJTEUsIHByZXEtPnBhY2tmaWxlKTsKCWN1cmxfZWFzeV9zZXRvcHQocHJlcS0+c2xvdC0+Y3VybCwgQ1VSTE9QVF9XUklURUZVTkNUSU9OLCBmd3JpdGUpOwoJY3VybF9lYXN5X3NldG9wdChwcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX1VSTCwgcHJlcS0+dXJsKTsKCWN1cmxfZWFzeV9zZXRvcHQocHJlcS0+c2xvdC0+Y3VybCwgQ1VSTE9QVF9IVFRQSEVBREVSLAoJCW5vX3ByYWdtYV9oZWFkZXIpOwoKCS8qCgkgKiBJZiB0aGVyZSBpcyBkYXRhIHByZXNlbnQgZnJvbSBhIHByZXZpb3VzIHRyYW5zZmVyIGF0dGVtcHQsCgkgKiByZXN1bWUgd2hlcmUgaXQgbGVmdCBvZmYKCSAqLwoJcHJldl9wb3NuID0gZnRlbGwocHJlcS0+cGFja2ZpbGUpOwoJaWYgKHByZXZfcG9zbj4wKSB7CgkJaWYgKGh0dHBfaXNfdmVyYm9zZSkKCQkJZnByaW50ZihzdGRlcnIsCgkJCQkiUmVzdW1pbmcgZmV0Y2ggb2YgcGFjayAlcyBhdCBieXRlICVsZFxuIiwKCQkJCXNoYTFfdG9faGV4KHRhcmdldC0+c2hhMSksIHByZXZfcG9zbik7CgkJc3ByaW50ZihyYW5nZSwgIlJhbmdlOiBieXRlcz0lbGQtIiwgcHJldl9wb3NuKTsKCQlwcmVxLT5yYW5nZV9oZWFkZXIgPSBjdXJsX3NsaXN0X2FwcGVuZChOVUxMLCByYW5nZSk7CgkJY3VybF9lYXN5X3NldG9wdChwcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX0hUVFBIRUFERVIsCgkJCXByZXEtPnJhbmdlX2hlYWRlcik7Cgl9CgoJcmV0dXJuIHByZXE7CgphYm9ydDoKCWZyZWUocHJlcS0+dXJsKTsKCWZyZWUocHJlcSk7CglyZXR1cm4gTlVMTDsKfQoKLyogSGVscGVycyBmb3IgZmV0Y2hpbmcgb2JqZWN0cyAobG9vc2UpICovCnN0YXRpYyBzaXplX3QgZndyaXRlX3NoYTFfZmlsZShjaGFyICpwdHIsIHNpemVfdCBlbHRzaXplLCBzaXplX3Qgbm1lbWIsCgkJCSAgICAgICB2b2lkICpkYXRhKQp7Cgl1bnNpZ25lZCBjaGFyIGV4cG5bNDA5Nl07CglzaXplX3Qgc2l6ZSA9IGVsdHNpemUgKiBubWVtYjsKCWludCBwb3NuID0gMDsKCXN0cnVjdCBodHRwX29iamVjdF9yZXF1ZXN0ICpmcmVxID0KCQkoc3RydWN0IGh0dHBfb2JqZWN0X3JlcXVlc3QgKilkYXRhOwoJZG8gewoJCXNzaXplX3QgcmV0dmFsID0geHdyaXRlKGZyZXEtPmxvY2FsZmlsZSwKCQkJCQkoY2hhciAqKSBwdHIgKyBwb3NuLCBzaXplIC0gcG9zbik7CgkJaWYgKHJldHZhbCA8IDApCgkJCXJldHVybiBwb3NuOwoJCXBvc24gKz0gcmV0dmFsOwoJfSB3aGlsZSAocG9zbiA8IHNpemUpOwoKCWZyZXEtPnN0cmVhbS5hdmFpbF9pbiA9IHNpemU7CglmcmVxLT5zdHJlYW0ubmV4dF9pbiA9ICh2b2lkICopcHRyOwoJZG8gewoJCWZyZXEtPnN0cmVhbS5uZXh0X291dCA9IGV4cG47CgkJZnJlcS0+c3RyZWFtLmF2YWlsX291dCA9IHNpemVvZihleHBuKTsKCQlmcmVxLT56cmV0ID0gZ2l0X2luZmxhdGUoJmZyZXEtPnN0cmVhbSwgWl9TWU5DX0ZMVVNIKTsKCQlnaXRfU0hBMV9VcGRhdGUoJmZyZXEtPmMsIGV4cG4sCgkJCQlzaXplb2YoZXhwbikgLSBmcmVxLT5zdHJlYW0uYXZhaWxfb3V0KTsKCX0gd2hpbGUgKGZyZXEtPnN0cmVhbS5hdmFpbF9pbiAmJiBmcmVxLT56cmV0ID09IFpfT0spOwoJZGF0YV9yZWNlaXZlZCsrOwoJcmV0dXJuIHNpemU7Cn0KCnN0cnVjdCBodHRwX29iamVjdF9yZXF1ZXN0ICpuZXdfaHR0cF9vYmplY3RfcmVxdWVzdChjb25zdCBjaGFyICpiYXNlX3VybCwKCXVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCWNoYXIgKmhleCA9IHNoYTFfdG9faGV4KHNoYTEpOwoJY2hhciAqZmlsZW5hbWU7CgljaGFyIHByZXZmaWxlW1BBVEhfTUFYXTsKCWludCBwcmV2bG9jYWw7CgljaGFyIHByZXZfYnVmW1BSRVZfQlVGX1NJWkVdOwoJc3NpemVfdCBwcmV2X3JlYWQgPSAwOwoJbG9uZyBwcmV2X3Bvc24gPSAwOwoJY2hhciByYW5nZVtSQU5HRV9IRUFERVJfU0laRV07CglzdHJ1Y3QgY3VybF9zbGlzdCAqcmFuZ2VfaGVhZGVyID0gTlVMTDsKCXN0cnVjdCBodHRwX29iamVjdF9yZXF1ZXN0ICpmcmVxOwoKCWZyZXEgPSB4bWFsbG9jKHNpemVvZigqZnJlcSkpOwoJaGFzaGNweShmcmVxLT5zaGExLCBzaGExKTsKCWZyZXEtPmxvY2FsZmlsZSA9IC0xOwoKCWZpbGVuYW1lID0gc2hhMV9maWxlX25hbWUoc2hhMSk7CglzbnByaW50ZihmcmVxLT50bXBmaWxlLCBzaXplb2YoZnJlcS0+dG1wZmlsZSksCgkJICIlcy50ZW1wIiwgZmlsZW5hbWUpOwoKCXNucHJpbnRmKHByZXZmaWxlLCBzaXplb2YocHJldmZpbGUpLCAiJXMucHJldiIsIGZpbGVuYW1lKTsKCXVubGlua19vcl93YXJuKHByZXZmaWxlKTsKCXJlbmFtZShmcmVxLT50bXBmaWxlLCBwcmV2ZmlsZSk7Cgl1bmxpbmtfb3Jfd2FybihmcmVxLT50bXBmaWxlKTsKCglpZiAoZnJlcS0+bG9jYWxmaWxlICE9IC0xKQoJCWVycm9yKCJmZCBsZWFrYWdlIGluIHN0YXJ0OiAlZCIsIGZyZXEtPmxvY2FsZmlsZSk7CglmcmVxLT5sb2NhbGZpbGUgPSBvcGVuKGZyZXEtPnRtcGZpbGUsCgkJCSAgICAgICBPX1dST05MWSB8IE9fQ1JFQVQgfCBPX0VYQ0wsIDA2NjYpOwoJLyoKCSAqIFRoaXMgY291bGQgaGF2ZSBmYWlsZWQgZHVlIHRvIHRoZSAibGF6eSBkaXJlY3RvcnkgY3JlYXRpb24iOwoJICogdHJ5IHRvIG1rZGlyIHRoZSBsYXN0IHBhdGggY29tcG9uZW50LgoJICovCglpZiAoZnJlcS0+bG9jYWxmaWxlIDwgMCAmJiBlcnJubyA9PSBFTk9FTlQpIHsKCQljaGFyICpkaXIgPSBzdHJyY2hyKGZyZXEtPnRtcGZpbGUsICcvJyk7CgkJaWYgKGRpcikgewoJCQkqZGlyID0gMDsKCQkJbWtkaXIoZnJlcS0+dG1wZmlsZSwgMDc3Nyk7CgkJCSpkaXIgPSAnLyc7CgkJfQoJCWZyZXEtPmxvY2FsZmlsZSA9IG9wZW4oZnJlcS0+dG1wZmlsZSwKCQkJCSAgICAgICBPX1dST05MWSB8IE9fQ1JFQVQgfCBPX0VYQ0wsIDA2NjYpOwoJfQoKCWlmIChmcmVxLT5sb2NhbGZpbGUgPCAwKSB7CgkJZXJyb3IoIkNvdWxkbid0IGNyZWF0ZSB0ZW1wb3JhcnkgZmlsZSAlczogJXMiLAoJCSAgICAgIGZyZXEtPnRtcGZpbGUsIHN0cmVycm9yKGVycm5vKSk7CgkJZ290byBhYm9ydDsKCX0KCgltZW1zZXQoJmZyZXEtPnN0cmVhbSwgMCwgc2l6ZW9mKGZyZXEtPnN0cmVhbSkpOwoKCWdpdF9pbmZsYXRlX2luaXQoJmZyZXEtPnN0cmVhbSk7CgoJZ2l0X1NIQTFfSW5pdCgmZnJlcS0+Yyk7CgoJZnJlcS0+dXJsID0gZ2V0X3JlbW90ZV9vYmplY3RfdXJsKGJhc2VfdXJsLCBoZXgsIDApOwoKCS8qCgkgKiBJZiBhIHByZXZpb3VzIHRlbXAgZmlsZSBpcyBwcmVzZW50LCBwcm9jZXNzIHdoYXQgd2FzIGFscmVhZHkKCSAqIGZldGNoZWQuCgkgKi8KCXByZXZsb2NhbCA9IG9wZW4ocHJldmZpbGUsIE9fUkRPTkxZKTsKCWlmIChwcmV2bG9jYWwgIT0gLTEpIHsKCQlkbyB7CgkJCXByZXZfcmVhZCA9IHhyZWFkKHByZXZsb2NhbCwgcHJldl9idWYsIFBSRVZfQlVGX1NJWkUpOwoJCQlpZiAocHJldl9yZWFkPjApIHsKCQkJCWlmIChmd3JpdGVfc2hhMV9maWxlKHByZXZfYnVmLAoJCQkJCQkgICAgIDEsCgkJCQkJCSAgICAgcHJldl9yZWFkLAoJCQkJCQkgICAgIGZyZXEpID09IHByZXZfcmVhZCkgewoJCQkJCXByZXZfcG9zbiArPSBwcmV2X3JlYWQ7CgkJCQl9IGVsc2UgewoJCQkJCXByZXZfcmVhZCA9IC0xOwoJCQkJfQoJCQl9CgkJfSB3aGlsZSAocHJldl9yZWFkID4gMCk7CgkJY2xvc2UocHJldmxvY2FsKTsKCX0KCXVubGlua19vcl93YXJuKHByZXZmaWxlKTsKCgkvKgoJICogUmVzZXQgaW5mbGF0ZS9TSEExIGlmIHRoZXJlIHdhcyBhbiBlcnJvciByZWFkaW5nIHRoZSBwcmV2aW91cyB0ZW1wCgkgKiBmaWxlOyBhbHNvIHJld2luZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsb2NhbCBmaWxlLgoJICovCglpZiAocHJldl9yZWFkID09IC0xKSB7CgkJbWVtc2V0KCZmcmVxLT5zdHJlYW0sIDAsIHNpemVvZihmcmVxLT5zdHJlYW0pKTsKCQlnaXRfaW5mbGF0ZV9pbml0KCZmcmVxLT5zdHJlYW0pOwoJCWdpdF9TSEExX0luaXQoJmZyZXEtPmMpOwoJCWlmIChwcmV2X3Bvc24+MCkgewoJCQlwcmV2X3Bvc24gPSAwOwoJCQlsc2VlayhmcmVxLT5sb2NhbGZpbGUsIDAsIFNFRUtfU0VUKTsKCQkJaWYgKGZ0cnVuY2F0ZShmcmVxLT5sb2NhbGZpbGUsIDApIDwgMCkgewoJCQkJZXJyb3IoIkNvdWxkbid0IHRydW5jYXRlIHRlbXBvcmFyeSBmaWxlICVzOiAlcyIsCgkJCQkJICBmcmVxLT50bXBmaWxlLCBzdHJlcnJvcihlcnJubykpOwoJCQkJZ290byBhYm9ydDsKCQkJfQoJCX0KCX0KCglmcmVxLT5zbG90ID0gZ2V0X2FjdGl2ZV9zbG90KCk7CgoJY3VybF9lYXN5X3NldG9wdChmcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX0ZJTEUsIGZyZXEpOwoJY3VybF9lYXN5X3NldG9wdChmcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX1dSSVRFRlVOQ1RJT04sIGZ3cml0ZV9zaGExX2ZpbGUpOwoJY3VybF9lYXN5X3NldG9wdChmcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX0VSUk9SQlVGRkVSLCBmcmVxLT5lcnJvcnN0cik7CgljdXJsX2Vhc3lfc2V0b3B0KGZyZXEtPnNsb3QtPmN1cmwsIENVUkxPUFRfVVJMLCBmcmVxLT51cmwpOwoJY3VybF9lYXN5X3NldG9wdChmcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX0hUVFBIRUFERVIsIG5vX3ByYWdtYV9oZWFkZXIpOwoKCS8qCgkgKiBJZiB3ZSBoYXZlIHN1Y2Nlc3NmdWxseSBwcm9jZXNzZWQgZGF0YSBmcm9tIGEgcHJldmlvdXMgZmV0Y2gKCSAqIGF0dGVtcHQsIG9ubHkgZmV0Y2ggdGhlIGRhdGEgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlLgoJICovCglpZiAocHJldl9wb3NuPjApIHsKCQlpZiAoaHR0cF9pc192ZXJib3NlKQoJCQlmcHJpbnRmKHN0ZGVyciwKCQkJCSJSZXN1bWluZyBmZXRjaCBvZiBvYmplY3QgJXMgYXQgYnl0ZSAlbGRcbiIsCgkJCQloZXgsIHByZXZfcG9zbik7CgkJc3ByaW50ZihyYW5nZSwgIlJhbmdlOiBieXRlcz0lbGQtIiwgcHJldl9wb3NuKTsKCQlyYW5nZV9oZWFkZXIgPSBjdXJsX3NsaXN0X2FwcGVuZChyYW5nZV9oZWFkZXIsIHJhbmdlKTsKCQljdXJsX2Vhc3lfc2V0b3B0KGZyZXEtPnNsb3QtPmN1cmwsCgkJCQkgQ1VSTE9QVF9IVFRQSEVBREVSLCByYW5nZV9oZWFkZXIpOwoJfQoKCXJldHVybiBmcmVxOwoKYWJvcnQ6CglmcmVlKGZpbGVuYW1lKTsKCWZyZWUoZnJlcS0+dXJsKTsKCWZyZWUoZnJlcSk7CglyZXR1cm4gTlVMTDsKfQoKdm9pZCBwcm9jZXNzX2h0dHBfb2JqZWN0X3JlcXVlc3Qoc3RydWN0IGh0dHBfb2JqZWN0X3JlcXVlc3QgKmZyZXEpCnsKCWlmIChmcmVxLT5zbG90ID09IE5VTEwpCgkJcmV0dXJuOwoJZnJlcS0+Y3VybF9yZXN1bHQgPSBmcmVxLT5zbG90LT5jdXJsX3Jlc3VsdDsKCWZyZXEtPmh0dHBfY29kZSA9IGZyZXEtPnNsb3QtPmh0dHBfY29kZTsKCWZyZXEtPnNsb3QgPSBOVUxMOwp9CgppbnQgZmluaXNoX2h0dHBfb2JqZWN0X3JlcXVlc3Qoc3RydWN0IGh0dHBfb2JqZWN0X3JlcXVlc3QgKmZyZXEpCnsKCXN0cnVjdCBzdGF0IHN0OwoKCWNsb3NlKGZyZXEtPmxvY2FsZmlsZSk7CglmcmVxLT5sb2NhbGZpbGUgPSAtMTsKCglwcm9jZXNzX2h0dHBfb2JqZWN0X3JlcXVlc3QoZnJlcSk7CgoJaWYgKGZyZXEtPmh0dHBfY29kZSA9PSA0MTYpIHsKCQl3YXJuaW5nKCJyZXF1ZXN0ZWQgcmFuZ2UgaW52YWxpZDsgd2UgbWF5IGFscmVhZHkgaGF2ZSBhbGwgdGhlIGRhdGEuIik7Cgl9IGVsc2UgaWYgKGZyZXEtPmN1cmxfcmVzdWx0ICE9IENVUkxFX09LKSB7CgkJaWYgKHN0YXQoZnJlcS0+dG1wZmlsZSwgJnN0KSA9PSAwKQoJCQlpZiAoc3Quc3Rfc2l6ZSA9PSAwKQoJCQkJdW5saW5rX29yX3dhcm4oZnJlcS0+dG1wZmlsZSk7CgkJcmV0dXJuIC0xOwoJfQoKCWdpdF9pbmZsYXRlX2VuZCgmZnJlcS0+c3RyZWFtKTsKCWdpdF9TSEExX0ZpbmFsKGZyZXEtPnJlYWxfc2hhMSwgJmZyZXEtPmMpOwoJaWYgKGZyZXEtPnpyZXQgIT0gWl9TVFJFQU1fRU5EKSB7CgkJdW5saW5rX29yX3dhcm4oZnJlcS0+dG1wZmlsZSk7CgkJcmV0dXJuIC0xOwoJfQoJaWYgKGhhc2hjbXAoZnJlcS0+c2hhMSwgZnJlcS0+cmVhbF9zaGExKSkgewoJCXVubGlua19vcl93YXJuKGZyZXEtPnRtcGZpbGUpOwoJCXJldHVybiAtMTsKCX0KCWZyZXEtPnJlbmFtZSA9CgkJbW92ZV90ZW1wX3RvX2ZpbGUoZnJlcS0+dG1wZmlsZSwgc2hhMV9maWxlX25hbWUoZnJlcS0+c2hhMSkpOwoKCXJldHVybiBmcmVxLT5yZW5hbWU7Cn0KCnZvaWQgYWJvcnRfaHR0cF9vYmplY3RfcmVxdWVzdChzdHJ1Y3QgaHR0cF9vYmplY3RfcmVxdWVzdCAqZnJlcSkKewoJdW5saW5rX29yX3dhcm4oZnJlcS0+dG1wZmlsZSk7CgoJcmVsZWFzZV9odHRwX29iamVjdF9yZXF1ZXN0KGZyZXEpOwp9Cgp2b2lkIHJlbGVhc2VfaHR0cF9vYmplY3RfcmVxdWVzdChzdHJ1Y3QgaHR0cF9vYmplY3RfcmVxdWVzdCAqZnJlcSkKewoJaWYgKGZyZXEtPmxvY2FsZmlsZSAhPSAtMSkgewoJCWNsb3NlKGZyZXEtPmxvY2FsZmlsZSk7CgkJZnJlcS0+bG9jYWxmaWxlID0gLTE7Cgl9CglpZiAoZnJlcS0+dXJsICE9IE5VTEwpIHsKCQlmcmVlKGZyZXEtPnVybCk7CgkJZnJlcS0+dXJsID0gTlVMTDsKCX0KCWlmIChmcmVxLT5zbG90ICE9IE5VTEwpIHsKCQlmcmVxLT5zbG90LT5jYWxsYmFja19mdW5jID0gTlVMTDsKCQlmcmVxLT5zbG90LT5jYWxsYmFja19kYXRhID0gTlVMTDsKCQlyZWxlYXNlX2FjdGl2ZV9zbG90KGZyZXEtPnNsb3QpOwoJCWZyZXEtPnNsb3QgPSBOVUxMOwoJfQp9Cg==",
    "text": "#include \"http.h\"\n#include \"pack.h\"\n#include \"sideband.h\"\n#include \"run-command.h\"\n#include \"url.h\"\n\nint data_received;\nint active_requests;\nint http_is_verbose;\nsize_t http_post_buffer = 16 * LARGE_PACKET_MAX;\n\n#if LIBCURL_VERSION_NUM >= 0x070a06\n#define LIBCURL_CAN_HANDLE_AUTH_ANY\n#endif\n\nstatic int min_curl_sessions = 1;\nstatic int curl_session_count;\n#ifdef USE_CURL_MULTI\nstatic int max_requests = -1;\nstatic CURLM *curlm;\n#endif\n#ifndef NO_CURL_EASY_DUPHANDLE\nstatic CURL *curl_default;\n#endif\n\n#define PREV_BUF_SIZE 4096\n#define RANGE_HEADER_SIZE 30\n\nchar curl_errorstr[CURL_ERROR_SIZE];\n\nstatic int curl_ssl_verify = -1;\nstatic const char *ssl_cert;\n#if LIBCURL_VERSION_NUM >= 0x070903\nstatic const char *ssl_key;\n#endif\n#if LIBCURL_VERSION_NUM >= 0x070908\nstatic const char *ssl_capath;\n#endif\nstatic const char *ssl_cainfo;\nstatic long curl_low_speed_limit = -1;\nstatic long curl_low_speed_time = -1;\nstatic int curl_ftp_no_epsv;\nstatic const char *curl_http_proxy;\nstatic const char *curl_cookie_file;\nstatic char *user_name, *user_pass, *description;\nstatic const char *user_agent;\n\n#if LIBCURL_VERSION_NUM >= 0x071700\n/* Use CURLOPT_KEYPASSWD as is */\n#elif LIBCURL_VERSION_NUM >= 0x070903\n#define CURLOPT_KEYPASSWD CURLOPT_SSLKEYPASSWD\n#else\n#define CURLOPT_KEYPASSWD CURLOPT_SSLCERTPASSWD\n#endif\n\nstatic char *ssl_cert_password;\nstatic int ssl_cert_password_required;\n\nstatic struct curl_slist *pragma_header;\nstatic struct curl_slist *no_pragma_header;\n\nstatic struct active_request_slot *active_queue_head;\n\nsize_t fread_buffer(char *ptr, size_t eltsize, size_t nmemb, void *buffer_)\n{\n\tsize_t size = eltsize * nmemb;\n\tstruct buffer *buffer = buffer_;\n\n\tif (size > buffer->buf.len - buffer->posn)\n\t\tsize = buffer->buf.len - buffer->posn;\n\tmemcpy(ptr, buffer->buf.buf + buffer->posn, size);\n\tbuffer->posn += size;\n\n\treturn size;\n}\n\n#ifndef NO_CURL_IOCTL\ncurlioerr ioctl_buffer(CURL *handle, int cmd, void *clientp)\n{\n\tstruct buffer *buffer = clientp;\n\n\tswitch (cmd) {\n\tcase CURLIOCMD_NOP:\n\t\treturn CURLIOE_OK;\n\n\tcase CURLIOCMD_RESTARTREAD:\n\t\tbuffer->posn = 0;\n\t\treturn CURLIOE_OK;\n\n\tdefault:\n\t\treturn CURLIOE_UNKNOWNCMD;\n\t}\n}\n#endif\n\nsize_t fwrite_buffer(char *ptr, size_t eltsize, size_t nmemb, void *buffer_)\n{\n\tsize_t size = eltsize * nmemb;\n\tstruct strbuf *buffer = buffer_;\n\n\tstrbuf_add(buffer, ptr, size);\n\tdata_received++;\n\treturn size;\n}\n\nsize_t fwrite_null(char *ptr, size_t eltsize, size_t nmemb, void *strbuf)\n{\n\tdata_received++;\n\treturn eltsize * nmemb;\n}\n\n#ifdef USE_CURL_MULTI\nstatic void process_curl_messages(void)\n{\n\tint num_messages;\n\tstruct active_request_slot *slot;\n\tCURLMsg *curl_message = curl_multi_info_read(curlm, &num_messages);\n\n\twhile (curl_message != NULL) {\n\t\tif (curl_message->msg == CURLMSG_DONE) {\n\t\t\tint curl_result = curl_message->data.result;\n\t\t\tslot = active_queue_head;\n\t\t\twhile (slot != NULL &&\n\t\t\t       slot->curl != curl_message->easy_handle)\n\t\t\t\tslot = slot->next;\n\t\t\tif (slot != NULL) {\n\t\t\t\tcurl_multi_remove_handle(curlm, slot->curl);\n\t\t\t\tslot->curl_result = curl_result;\n\t\t\t\tfinish_active_slot(slot);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Received DONE message for unknown request!\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown CURL message received: %d\\n\",\n\t\t\t\t(int)curl_message->msg);\n\t\t}\n\t\tcurl_message = curl_multi_info_read(curlm, &num_messages);\n\t}\n}\n#endif\n\nstatic char *git_getpass_with_description(const char *what, const char *desc)\n{\n\tstruct strbuf prompt = STRBUF_INIT;\n\tchar *r;\n\n\tif (desc)\n\t\tstrbuf_addf(&prompt, \"%s for '%s': \", what, desc);\n\telse\n\t\tstrbuf_addf(&prompt, \"%s: \", what);\n\t/*\n\t * NEEDSWORK: for usernames, we should do something less magical that\n\t * actually echoes the characters. However, we need to read from\n\t * /dev/tty and not stdio, which is not portable (but getpass will do\n\t * it for us). http.c uses the same workaround.\n\t */\n\tr = git_getpass(prompt.buf);\n\n\tstrbuf_release(&prompt);\n\treturn xstrdup(r);\n}\n\nstatic int http_options(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(\"http.sslverify\", var)) {\n\t\tcurl_ssl_verify = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.sslcert\", var))\n\t\treturn git_config_string(&ssl_cert, var, value);\n#if LIBCURL_VERSION_NUM >= 0x070903\n\tif (!strcmp(\"http.sslkey\", var))\n\t\treturn git_config_string(&ssl_key, var, value);\n#endif\n#if LIBCURL_VERSION_NUM >= 0x070908\n\tif (!strcmp(\"http.sslcapath\", var))\n\t\treturn git_config_string(&ssl_capath, var, value);\n#endif\n\tif (!strcmp(\"http.sslcainfo\", var))\n\t\treturn git_config_string(&ssl_cainfo, var, value);\n\tif (!strcmp(\"http.sslcertpasswordprotected\", var)) {\n\t\tif (git_config_bool(var, value))\n\t\t\tssl_cert_password_required = 1;\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.minsessions\", var)) {\n\t\tmin_curl_sessions = git_config_int(var, value);\n#ifndef USE_CURL_MULTI\n\t\tif (min_curl_sessions > 1)\n\t\t\tmin_curl_sessions = 1;\n#endif\n\t\treturn 0;\n\t}\n#ifdef USE_CURL_MULTI\n\tif (!strcmp(\"http.maxrequests\", var)) {\n\t\tmax_requests = git_config_int(var, value);\n\t\treturn 0;\n\t}\n#endif\n\tif (!strcmp(\"http.lowspeedlimit\", var)) {\n\t\tcurl_low_speed_limit = (long)git_config_int(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.lowspeedtime\", var)) {\n\t\tcurl_low_speed_time = (long)git_config_int(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(\"http.noepsv\", var)) {\n\t\tcurl_ftp_no_epsv = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.proxy\", var))\n\t\treturn git_config_string(&curl_http_proxy, var, value);\n\n\tif (!strcmp(\"http.cookiefile\", var))\n\t\treturn git_config_string(&curl_cookie_file, var, value);\n\n\tif (!strcmp(\"http.postbuffer\", var)) {\n\t\thttp_post_buffer = git_config_int(var, value);\n\t\tif (http_post_buffer < LARGE_PACKET_MAX)\n\t\t\thttp_post_buffer = LARGE_PACKET_MAX;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(\"http.useragent\", var))\n\t\treturn git_config_string(&user_agent, var, value);\n\n\t/* Fall back on the default ones */\n\treturn git_default_config(var, value, cb);\n}\n\nstatic void init_curl_http_auth(CURL *result)\n{\n\tif (user_name) {\n\t\tstruct strbuf up = STRBUF_INIT;\n\t\tif (!user_pass)\n\t\t\tuser_pass = xstrdup(git_getpass_with_description(\"Password\", description));\n\t\tstrbuf_addf(&up, \"%s:%s\", user_name, user_pass);\n\t\tcurl_easy_setopt(result, CURLOPT_USERPWD,\n\t\t\t\t strbuf_detach(&up, NULL));\n\t}\n}\n\nstatic int has_cert_password(void)\n{\n\tif (ssl_cert_password != NULL)\n\t\treturn 1;\n\tif (ssl_cert == NULL || ssl_cert_password_required != 1)\n\t\treturn 0;\n\t/* Only prompt the user once. */\n\tssl_cert_password_required = -1;\n\tssl_cert_password = git_getpass_with_description(\"Certificate Password\", description);\n\tif (ssl_cert_password != NULL) {\n\t\tssl_cert_password = xstrdup(ssl_cert_password);\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}\n\nstatic CURL *get_curl_handle(void)\n{\n\tCURL *result = curl_easy_init();\n\n\tif (!curl_ssl_verify) {\n\t\tcurl_easy_setopt(result, CURLOPT_SSL_VERIFYPEER, 0);\n\t\tcurl_easy_setopt(result, CURLOPT_SSL_VERIFYHOST, 0);\n\t} else {\n\t\t/* Verify authenticity of the peer's certificate */\n\t\tcurl_easy_setopt(result, CURLOPT_SSL_VERIFYPEER, 1);\n\t\t/* The name in the cert must match whom we tried to connect */\n\t\tcurl_easy_setopt(result, CURLOPT_SSL_VERIFYHOST, 2);\n\t}\n\n#if LIBCURL_VERSION_NUM >= 0x070907\n\tcurl_easy_setopt(result, CURLOPT_NETRC, CURL_NETRC_OPTIONAL);\n#endif\n#ifdef LIBCURL_CAN_HANDLE_AUTH_ANY\n\tcurl_easy_setopt(result, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n#endif\n\n\tinit_curl_http_auth(result);\n\n\tif (ssl_cert != NULL)\n\t\tcurl_easy_setopt(result, CURLOPT_SSLCERT, ssl_cert);\n\tif (has_cert_password())\n\t\tcurl_easy_setopt(result, CURLOPT_KEYPASSWD, ssl_cert_password);\n#if LIBCURL_VERSION_NUM >= 0x070903\n\tif (ssl_key != NULL)\n\t\tcurl_easy_setopt(result, CURLOPT_SSLKEY, ssl_key);\n#endif\n#if LIBCURL_VERSION_NUM >= 0x070908\n\tif (ssl_capath != NULL)\n\t\tcurl_easy_setopt(result, CURLOPT_CAPATH, ssl_capath);\n#endif\n\tif (ssl_cainfo != NULL)\n\t\tcurl_easy_setopt(result, CURLOPT_CAINFO, ssl_cainfo);\n\tcurl_easy_setopt(result, CURLOPT_FAILONERROR, 1);\n\n\tif (curl_low_speed_limit > 0 && curl_low_speed_time > 0) {\n\t\tcurl_easy_setopt(result, CURLOPT_LOW_SPEED_LIMIT,\n\t\t\t\t curl_low_speed_limit);\n\t\tcurl_easy_setopt(result, CURLOPT_LOW_SPEED_TIME,\n\t\t\t\t curl_low_speed_time);\n\t}\n\n\tcurl_easy_setopt(result, CURLOPT_FOLLOWLOCATION, 1);\n#if LIBCURL_VERSION_NUM >= 0x071301\n\tcurl_easy_setopt(result, CURLOPT_POSTREDIR, CURL_REDIR_POST_ALL);\n#elif LIBCURL_VERSION_NUM >= 0x071101\n\tcurl_easy_setopt(result, CURLOPT_POST301, 1);\n#endif\n\n\tif (getenv(\"GIT_CURL_VERBOSE\"))\n\t\tcurl_easy_setopt(result, CURLOPT_VERBOSE, 1);\n\n\tcurl_easy_setopt(result, CURLOPT_USERAGENT,\n\t\tuser_agent ? user_agent : GIT_HTTP_USER_AGENT);\n\n\tif (curl_ftp_no_epsv)\n\t\tcurl_easy_setopt(result, CURLOPT_FTP_USE_EPSV, 0);\n\n\tif (curl_http_proxy)\n\t\tcurl_easy_setopt(result, CURLOPT_PROXY, curl_http_proxy);\n\n\treturn result;\n}\n\nstatic void http_auth_init(const char *url)\n{\n\tconst char *at, *colon, *cp, *slash, *host;\n\n\tcp = strstr(url, \"://\");\n\tif (!cp)\n\t\treturn;\n\n\t/*\n\t * Ok, the URL looks like \"proto://something\".  Which one?\n\t * \"proto://<user>:<pass>@<host>/...\",\n\t * \"proto://<user>@<host>/...\", or just\n\t * \"proto://<host>/...\"?\n\t */\n\tcp += 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\tif (!at || slash <= at) {\n\t\t/* No credentials, but we may have to ask for some later */\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\t/* Only username */\n\t\tuser_name = url_decode_mem(cp, at - cp);\n\t\tuser_pass = NULL;\n\t\thost = at + 1;\n\t} else {\n\t\tuser_name = url_decode_mem(cp, colon - cp);\n\t\tuser_pass = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\n\tdescription = url_decode_mem(host, slash - host);\n}\n\nstatic void set_from_env(const char **var, const char *envname)\n{\n\tconst char *val = getenv(envname);\n\tif (val)\n\t\t*var = val;\n}\n\nvoid http_init(struct remote *remote, const char *url)\n{\n\tchar *low_speed_limit;\n\tchar *low_speed_time;\n\n\thttp_is_verbose = 0;\n\n\tgit_config(http_options, NULL);\n\n\tcurl_global_init(CURL_GLOBAL_ALL);\n\n\tif (remote && remote->http_proxy)\n\t\tcurl_http_proxy = xstrdup(remote->http_proxy);\n\n\tpragma_header = curl_slist_append(pragma_header, \"Pragma: no-cache\");\n\tno_pragma_header = curl_slist_append(no_pragma_header, \"Pragma:\");\n\n#ifdef USE_CURL_MULTI\n\t{\n\t\tchar *http_max_requests = getenv(\"GIT_HTTP_MAX_REQUESTS\");\n\t\tif (http_max_requests != NULL)\n\t\t\tmax_requests = atoi(http_max_requests);\n\t}\n\n\tcurlm = curl_multi_init();\n\tif (curlm == NULL) {\n\t\tfprintf(stderr, \"Error creating curl multi handle.\\n\");\n\t\texit(1);\n\t}\n#endif\n\n\tif (getenv(\"GIT_SSL_NO_VERIFY\"))\n\t\tcurl_ssl_verify = 0;\n\n\tset_from_env(&ssl_cert, \"GIT_SSL_CERT\");\n#if LIBCURL_VERSION_NUM >= 0x070903\n\tset_from_env(&ssl_key, \"GIT_SSL_KEY\");\n#endif\n#if LIBCURL_VERSION_NUM >= 0x070908\n\tset_from_env(&ssl_capath, \"GIT_SSL_CAPATH\");\n#endif\n\tset_from_env(&ssl_cainfo, \"GIT_SSL_CAINFO\");\n\n\tset_from_env(&user_agent, \"GIT_HTTP_USER_AGENT\");\n\n\tlow_speed_limit = getenv(\"GIT_HTTP_LOW_SPEED_LIMIT\");\n\tif (low_speed_limit != NULL)\n\t\tcurl_low_speed_limit = strtol(low_speed_limit, NULL, 10);\n\tlow_speed_time = getenv(\"GIT_HTTP_LOW_SPEED_TIME\");\n\tif (low_speed_time != NULL)\n\t\tcurl_low_speed_time = strtol(low_speed_time, NULL, 10);\n\n\tif (curl_ssl_verify == -1)\n\t\tcurl_ssl_verify = 1;\n\n\tcurl_session_count = 0;\n#ifdef USE_CURL_MULTI\n\tif (max_requests < 1)\n\t\tmax_requests = DEFAULT_MAX_REQUESTS;\n#endif\n\n\tif (getenv(\"GIT_CURL_FTP_NO_EPSV\"))\n\t\tcurl_ftp_no_epsv = 1;\n\n\tif (url) {\n\t\thttp_auth_init(url);\n\t\tif (!ssl_cert_password_required &&\n\t\t    getenv(\"GIT_SSL_CERT_PASSWORD_PROTECTED\") &&\n\t\t    !prefixcmp(url, \"https://\"))\n\t\t\tssl_cert_password_required = 1;\n\t}\n\n#ifndef NO_CURL_EASY_DUPHANDLE\n\tcurl_default = get_curl_handle();\n#endif\n}\n\nvoid http_cleanup(void)\n{\n\tstruct active_request_slot *slot = active_queue_head;\n\n\twhile (slot != NULL) {\n\t\tstruct active_request_slot *next = slot->next;\n\t\tif (slot->curl != NULL) {\n#ifdef USE_CURL_MULTI\n\t\t\tcurl_multi_remove_handle(curlm, slot->curl);\n#endif\n\t\t\tcurl_easy_cleanup(slot->curl);\n\t\t}\n\t\tfree(slot);\n\t\tslot = next;\n\t}\n\tactive_queue_head = NULL;\n\n#ifndef NO_CURL_EASY_DUPHANDLE\n\tcurl_easy_cleanup(curl_default);\n#endif\n\n#ifdef USE_CURL_MULTI\n\tcurl_multi_cleanup(curlm);\n#endif\n\tcurl_global_cleanup();\n\n\tcurl_slist_free_all(pragma_header);\n\tpragma_header = NULL;\n\n\tcurl_slist_free_all(no_pragma_header);\n\tno_pragma_header = NULL;\n\n\tif (curl_http_proxy) {\n\t\tfree((void *)curl_http_proxy);\n\t\tcurl_http_proxy = NULL;\n\t}\n\n\tif (ssl_cert_password != NULL) {\n\t\tmemset(ssl_cert_password, 0, strlen(ssl_cert_password));\n\t\tfree(ssl_cert_password);\n\t\tssl_cert_password = NULL;\n\t}\n\tssl_cert_password_required = 0;\n}\n\nstruct active_request_slot *get_active_slot(void)\n{\n\tstruct active_request_slot *slot = active_queue_head;\n\tstruct active_request_slot *newslot;\n\n#ifdef USE_CURL_MULTI\n\tint num_transfers;\n\n\t/* Wait for a slot to open up if the queue is full */\n\twhile (active_requests >= max_requests) {\n\t\tcurl_multi_perform(curlm, &num_transfers);\n\t\tif (num_transfers < active_requests)\n\t\t\tprocess_curl_messages();\n\t}\n#endif\n\n\twhile (slot != NULL && slot->in_use)\n\t\tslot = slot->next;\n\n\tif (slot == NULL) {\n\t\tnewslot = xmalloc(sizeof(*newslot));\n\t\tnewslot->curl = NULL;\n\t\tnewslot->in_use = 0;\n\t\tnewslot->next = NULL;\n\n\t\tslot = active_queue_head;\n\t\tif (slot == NULL) {\n\t\t\tactive_queue_head = newslot;\n\t\t} else {\n\t\t\twhile (slot->next != NULL)\n\t\t\t\tslot = slot->next;\n\t\t\tslot->next = newslot;\n\t\t}\n\t\tslot = newslot;\n\t}\n\n\tif (slot->curl == NULL) {\n#ifdef NO_CURL_EASY_DUPHANDLE\n\t\tslot->curl = get_curl_handle();\n#else\n\t\tslot->curl = curl_easy_duphandle(curl_default);\n#endif\n\t\tcurl_session_count++;\n\t}\n\n\tactive_requests++;\n\tslot->in_use = 1;\n\tslot->local = NULL;\n\tslot->results = NULL;\n\tslot->finished = NULL;\n\tslot->callback_data = NULL;\n\tslot->callback_func = NULL;\n\tcurl_easy_setopt(slot->curl, CURLOPT_COOKIEFILE, curl_cookie_file);\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, pragma_header);\n\tcurl_easy_setopt(slot->curl, CURLOPT_ERRORBUFFER, curl_errorstr);\n\tcurl_easy_setopt(slot->curl, CURLOPT_CUSTOMREQUEST, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_READFUNCTION, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_UPLOAD, 0);\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPGET, 1);\n\n\treturn slot;\n}\n\nint start_active_slot(struct active_request_slot *slot)\n{\n#ifdef USE_CURL_MULTI\n\tCURLMcode curlm_result = curl_multi_add_handle(curlm, slot->curl);\n\tint num_transfers;\n\n\tif (curlm_result != CURLM_OK &&\n\t    curlm_result != CURLM_CALL_MULTI_PERFORM) {\n\t\tactive_requests--;\n\t\tslot->in_use = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We know there must be something to do, since we just added\n\t * something.\n\t */\n\tcurl_multi_perform(curlm, &num_transfers);\n#endif\n\treturn 1;\n}\n\n#ifdef USE_CURL_MULTI\nstruct fill_chain {\n\tvoid *data;\n\tint (*fill)(void *);\n\tstruct fill_chain *next;\n};\n\nstatic struct fill_chain *fill_cfg;\n\nvoid add_fill_function(void *data, int (*fill)(void *))\n{\n\tstruct fill_chain *new = xmalloc(sizeof(*new));\n\tstruct fill_chain **linkp = &fill_cfg;\n\tnew->data = data;\n\tnew->fill = fill;\n\tnew->next = NULL;\n\twhile (*linkp)\n\t\tlinkp = &(*linkp)->next;\n\t*linkp = new;\n}\n\nvoid fill_active_slots(void)\n{\n\tstruct active_request_slot *slot = active_queue_head;\n\n\twhile (active_requests < max_requests) {\n\t\tstruct fill_chain *fill;\n\t\tfor (fill = fill_cfg; fill; fill = fill->next)\n\t\t\tif (fill->fill(fill->data))\n\t\t\t\tbreak;\n\n\t\tif (!fill)\n\t\t\tbreak;\n\t}\n\n\twhile (slot != NULL) {\n\t\tif (!slot->in_use && slot->curl != NULL\n\t\t\t&& curl_session_count > min_curl_sessions) {\n\t\t\tcurl_easy_cleanup(slot->curl);\n\t\t\tslot->curl = NULL;\n\t\t\tcurl_session_count--;\n\t\t}\n\t\tslot = slot->next;\n\t}\n}\n\nvoid step_active_slots(void)\n{\n\tint num_transfers;\n\tCURLMcode curlm_result;\n\n\tdo {\n\t\tcurlm_result = curl_multi_perform(curlm, &num_transfers);\n\t} while (curlm_result == CURLM_CALL_MULTI_PERFORM);\n\tif (num_transfers < active_requests) {\n\t\tprocess_curl_messages();\n\t\tfill_active_slots();\n\t}\n}\n#endif\n\nvoid run_active_slot(struct active_request_slot *slot)\n{\n#ifdef USE_CURL_MULTI\n\tlong last_pos = 0;\n\tlong current_pos;\n\tfd_set readfds;\n\tfd_set writefds;\n\tfd_set excfds;\n\tint max_fd;\n\tstruct timeval select_timeout;\n\tint finished = 0;\n\n\tslot->finished = &finished;\n\twhile (!finished) {\n\t\tdata_received = 0;\n\t\tstep_active_slots();\n\n\t\tif (!data_received && slot->local != NULL) {\n\t\t\tcurrent_pos = ftell(slot->local);\n\t\t\tif (current_pos > last_pos)\n\t\t\t\tdata_received++;\n\t\t\tlast_pos = current_pos;\n\t\t}\n\n\t\tif (slot->in_use && !data_received) {\n\t\t\tmax_fd = 0;\n\t\t\tFD_ZERO(&readfds);\n\t\t\tFD_ZERO(&writefds);\n\t\t\tFD_ZERO(&excfds);\n\t\t\tselect_timeout.tv_sec = 0;\n\t\t\tselect_timeout.tv_usec = 50000;\n\t\t\tselect(max_fd, &readfds, &writefds,\n\t\t\t       &excfds, &select_timeout);\n\t\t}\n\t}\n#else\n\twhile (slot->in_use) {\n\t\tslot->curl_result = curl_easy_perform(slot->curl);\n\t\tfinish_active_slot(slot);\n\t}\n#endif\n}\n\nstatic void closedown_active_slot(struct active_request_slot *slot)\n{\n\tactive_requests--;\n\tslot->in_use = 0;\n}\n\nstatic void release_active_slot(struct active_request_slot *slot)\n{\n\tclosedown_active_slot(slot);\n\tif (slot->curl && curl_session_count > min_curl_sessions) {\n#ifdef USE_CURL_MULTI\n\t\tcurl_multi_remove_handle(curlm, slot->curl);\n#endif\n\t\tcurl_easy_cleanup(slot->curl);\n\t\tslot->curl = NULL;\n\t\tcurl_session_count--;\n\t}\n#ifdef USE_CURL_MULTI\n\tfill_active_slots();\n#endif\n}\n\nvoid finish_active_slot(struct active_request_slot *slot)\n{\n\tclosedown_active_slot(slot);\n\tcurl_easy_getinfo(slot->curl, CURLINFO_HTTP_CODE, &slot->http_code);\n\n\tif (slot->finished != NULL)\n\t\t(*slot->finished) = 1;\n\n\t/* Store slot results so they can be read after the slot is reused */\n\tif (slot->results != NULL) {\n\t\tslot->results->curl_result = slot->curl_result;\n\t\tslot->results->http_code = slot->http_code;\n\t}\n\n\t/* Run callback if appropriate */\n\tif (slot->callback_func != NULL)\n\t\tslot->callback_func(slot->callback_data);\n}\n\nvoid finish_all_active_slots(void)\n{\n\tstruct active_request_slot *slot = active_queue_head;\n\n\twhile (slot != NULL)\n\t\tif (slot->in_use) {\n\t\t\trun_active_slot(slot);\n\t\t\tslot = active_queue_head;\n\t\t} else {\n\t\t\tslot = slot->next;\n\t\t}\n}\n\n/* Helpers for modifying and creating URLs */\nstatic inline int needs_quote(int ch)\n{\n\tif (((ch >= 'A') && (ch <= 'Z'))\n\t\t\t|| ((ch >= 'a') && (ch <= 'z'))\n\t\t\t|| ((ch >= '0') && (ch <= '9'))\n\t\t\t|| (ch == '/')\n\t\t\t|| (ch == '-')\n\t\t\t|| (ch == '.'))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic inline int hex(int v)\n{\n\tif (v < 10)\n\t\treturn '0' + v;\n\telse\n\t\treturn 'A' + v - 10;\n}\n\nstatic char *quote_ref_url(const char *base, const char *ref)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *cp;\n\tint ch;\n\n\tend_url_with_slash(&buf, base);\n\n\tfor (cp = ref; (ch = *cp) != 0; cp++)\n\t\tif (needs_quote(ch))\n\t\t\tstrbuf_addf(&buf, \"%%%02x\", ch);\n\t\telse\n\t\t\tstrbuf_addch(&buf, *cp);\n\n\treturn strbuf_detach(&buf, NULL);\n}\n\nvoid append_remote_object_url(struct strbuf *buf, const char *url,\n\t\t\t      const char *hex,\n\t\t\t      int only_two_digit_prefix)\n{\n\tend_url_with_slash(buf, url);\n\n\tstrbuf_addf(buf, \"objects/%.*s/\", 2, hex);\n\tif (!only_two_digit_prefix)\n\t\tstrbuf_addf(buf, \"%s\", hex+2);\n}\n\nchar *get_remote_object_url(const char *url, const char *hex,\n\t\t\t    int only_two_digit_prefix)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tappend_remote_object_url(&buf, url, hex, only_two_digit_prefix);\n\treturn strbuf_detach(&buf, NULL);\n}\n\n/* http_request() targets */\n#define HTTP_REQUEST_STRBUF\t0\n#define HTTP_REQUEST_FILE\t1\n\nstatic int http_request(const char *url, void *result, int target, int options)\n{\n\tstruct active_request_slot *slot;\n\tstruct slot_results results;\n\tstruct curl_slist *headers = NULL;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint ret;\n\n\tslot = get_active_slot();\n\tslot->results = &results;\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPGET, 1);\n\n\tif (result == NULL) {\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_NOBODY, 1);\n\t} else {\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_NOBODY, 0);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_FILE, result);\n\n\t\tif (target == HTTP_REQUEST_FILE) {\n\t\t\tlong posn = ftell(result);\n\t\t\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION,\n\t\t\t\t\t fwrite);\n\t\t\tif (posn > 0) {\n\t\t\t\tstrbuf_addf(&buf, \"Range: bytes=%ld-\", posn);\n\t\t\t\theaders = curl_slist_append(headers, buf.buf);\n\t\t\t\tstrbuf_reset(&buf);\n\t\t\t}\n\t\t\tslot->local = result;\n\t\t} else\n\t\t\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION,\n\t\t\t\t\t fwrite_buffer);\n\t}\n\n\tstrbuf_addstr(&buf, \"Pragma:\");\n\tif (options & HTTP_NO_CACHE)\n\t\tstrbuf_addstr(&buf, \" no-cache\");\n\n\theaders = curl_slist_append(headers, buf.buf);\n\n\tcurl_easy_setopt(slot->curl, CURLOPT_URL, url);\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, headers);\n\n\tif (start_active_slot(slot)) {\n\t\trun_active_slot(slot);\n\t\tif (results.curl_result == CURLE_OK)\n\t\t\tret = HTTP_OK;\n\t\telse if (missing_target(&results))\n\t\t\tret = HTTP_MISSING_TARGET;\n\t\telse if (results.http_code == 401) {\n\t\t\tif (user_name) {\n\t\t\t\tret = HTTP_NOAUTH;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * git_getpass is needed here because its very likely stdin/stdout are\n\t\t\t\t * pipes to our parent process.  So we instead need to use /dev/tty,\n\t\t\t\t * but that is non-portable.  Using git_getpass() can at least be stubbed\n\t\t\t\t * on other platforms with a different implementation if/when necessary.\n\t\t\t\t */\n\t\t\t\tuser_name = xstrdup(git_getpass_with_description(\"Username\", description));\n\t\t\t\tinit_curl_http_auth(slot->curl);\n\t\t\t\tret = HTTP_REAUTH;\n\t\t\t}\n\t\t} else\n\t\t\tret = HTTP_ERROR;\n\t} else {\n\t\terror(\"Unable to start HTTP request for %s\", url);\n\t\tret = HTTP_START_FAILED;\n\t}\n\n\tslot->local = NULL;\n\tcurl_slist_free_all(headers);\n\tstrbuf_release(&buf);\n\n\treturn ret;\n}\n\nstatic int http_request_reauth(const char *url, void *result, int target,\n\t\t\t       int options)\n{\n\tint ret = http_request(url, result, target, options);\n\tif (ret != HTTP_REAUTH)\n\t\treturn ret;\n\treturn http_request(url, result, target, options);\n}\n\nint http_get_strbuf(const char *url, struct strbuf *result, int options)\n{\n\treturn http_request_reauth(url, result, HTTP_REQUEST_STRBUF, options);\n}\n\n/*\n * Downloads an url and stores the result in the given file.\n *\n * If a previous interrupted download is detected (i.e. a previous temporary\n * file is still around) the download is resumed.\n */\nstatic int http_get_file(const char *url, const char *filename, int options)\n{\n\tint ret;\n\tstruct strbuf tmpfile = STRBUF_INIT;\n\tFILE *result;\n\n\tstrbuf_addf(&tmpfile, \"%s.temp\", filename);\n\tresult = fopen(tmpfile.buf, \"a\");\n\tif (! result) {\n\t\terror(\"Unable to open local file %s\", tmpfile.buf);\n\t\tret = HTTP_ERROR;\n\t\tgoto cleanup;\n\t}\n\n\tret = http_request_reauth(url, result, HTTP_REQUEST_FILE, options);\n\tfclose(result);\n\n\tif ((ret == HTTP_OK) && move_temp_to_file(tmpfile.buf, filename))\n\t\tret = HTTP_ERROR;\ncleanup:\n\tstrbuf_release(&tmpfile);\n\treturn ret;\n}\n\nint http_error(const char *url, int ret)\n{\n\t/* http_request has already handled HTTP_START_FAILED. */\n\tif (ret != HTTP_START_FAILED)\n\t\terror(\"%s while accessing %s\\n\", curl_errorstr, url);\n\n\treturn ret;\n}\n\nint http_fetch_ref(const char *base, struct ref *ref)\n{\n\tchar *url;\n\tstruct strbuf buffer = STRBUF_INIT;\n\tint ret = -1;\n\n\turl = quote_ref_url(base, ref->name);\n\tif (http_get_strbuf(url, &buffer, HTTP_NO_CACHE) == HTTP_OK) {\n\t\tstrbuf_rtrim(&buffer);\n\t\tif (buffer.len == 40)\n\t\t\tret = get_sha1_hex(buffer.buf, ref->old_sha1);\n\t\telse if (!prefixcmp(buffer.buf, \"ref: \")) {\n\t\t\tref->symref = xstrdup(buffer.buf + 5);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tstrbuf_release(&buffer);\n\tfree(url);\n\treturn ret;\n}\n\n/* Helpers for fetching packs */\nstatic char *fetch_pack_index(unsigned char *sha1, const char *base_url)\n{\n\tchar *url, *tmp;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tif (http_is_verbose)\n\t\tfprintf(stderr, \"Getting index for pack %s\\n\", sha1_to_hex(sha1));\n\n\tend_url_with_slash(&buf, base_url);\n\tstrbuf_addf(&buf, \"objects/pack/pack-%s.idx\", sha1_to_hex(sha1));\n\turl = strbuf_detach(&buf, NULL);\n\n\tstrbuf_addf(&buf, \"%s.temp\", sha1_pack_index_name(sha1));\n\ttmp = strbuf_detach(&buf, NULL);\n\n\tif (http_get_file(url, tmp, 0) != HTTP_OK) {\n\t\terror(\"Unable to get pack index %s\\n\", url);\n\t\tfree(tmp);\n\t\ttmp = NULL;\n\t}\n\n\tfree(url);\n\treturn tmp;\n}\n\nstatic int fetch_and_setup_pack_index(struct packed_git **packs_head,\n\tunsigned char *sha1, const char *base_url)\n{\n\tstruct packed_git *new_pack;\n\tchar *tmp_idx = NULL;\n\tint ret;\n\n\tif (has_pack_index(sha1)) {\n\t\tnew_pack = parse_pack_index(sha1, NULL);\n\t\tif (!new_pack)\n\t\t\treturn -1; /* parse_pack_index() already issued error message */\n\t\tgoto add_pack;\n\t}\n\n\ttmp_idx = fetch_pack_index(sha1, base_url);\n\tif (!tmp_idx)\n\t\treturn -1;\n\n\tnew_pack = parse_pack_index(sha1, tmp_idx);\n\tif (!new_pack) {\n\t\tunlink(tmp_idx);\n\t\tfree(tmp_idx);\n\n\t\treturn -1; /* parse_pack_index() already issued error message */\n\t}\n\n\tret = verify_pack_index(new_pack);\n\tif (!ret) {\n\t\tclose_pack_index(new_pack);\n\t\tret = move_temp_to_file(tmp_idx, sha1_pack_index_name(sha1));\n\t}\n\tfree(tmp_idx);\n\tif (ret)\n\t\treturn -1;\n\nadd_pack:\n\tnew_pack->next = *packs_head;\n\t*packs_head = new_pack;\n\treturn 0;\n}\n\nint http_get_info_packs(const char *base_url, struct packed_git **packs_head)\n{\n\tint ret = 0, i = 0;\n\tchar *url, *data;\n\tstruct strbuf buf = STRBUF_INIT;\n\tunsigned char sha1[20];\n\n\tend_url_with_slash(&buf, base_url);\n\tstrbuf_addstr(&buf, \"objects/info/packs\");\n\turl = strbuf_detach(&buf, NULL);\n\n\tret = http_get_strbuf(url, &buf, HTTP_NO_CACHE);\n\tif (ret != HTTP_OK)\n\t\tgoto cleanup;\n\n\tdata = buf.buf;\n\twhile (i < buf.len) {\n\t\tswitch (data[i]) {\n\t\tcase 'P':\n\t\t\ti++;\n\t\t\tif (i + 52 <= buf.len &&\n\t\t\t    !prefixcmp(data + i, \" pack-\") &&\n\t\t\t    !prefixcmp(data + i + 46, \".pack\\n\")) {\n\t\t\t\tget_sha1_hex(data + i + 6, sha1);\n\t\t\t\tfetch_and_setup_pack_index(packs_head, sha1,\n\t\t\t\t\t\t      base_url);\n\t\t\t\ti += 51;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\twhile (i < buf.len && data[i] != '\\n')\n\t\t\t\ti++;\n\t\t}\n\t\ti++;\n\t}\n\ncleanup:\n\tfree(url);\n\treturn ret;\n}\n\nvoid release_http_pack_request(struct http_pack_request *preq)\n{\n\tif (preq->packfile != NULL) {\n\t\tfclose(preq->packfile);\n\t\tpreq->packfile = NULL;\n\t\tpreq->slot->local = NULL;\n\t}\n\tif (preq->range_header != NULL) {\n\t\tcurl_slist_free_all(preq->range_header);\n\t\tpreq->range_header = NULL;\n\t}\n\tpreq->slot = NULL;\n\tfree(preq->url);\n}\n\nint finish_http_pack_request(struct http_pack_request *preq)\n{\n\tstruct packed_git **lst;\n\tstruct packed_git *p = preq->target;\n\tchar *tmp_idx;\n\tstruct child_process ip;\n\tconst char *ip_argv[8];\n\n\tclose_pack_index(p);\n\n\tfclose(preq->packfile);\n\tpreq->packfile = NULL;\n\tpreq->slot->local = NULL;\n\n\tlst = preq->lst;\n\twhile (*lst != p)\n\t\tlst = &((*lst)->next);\n\t*lst = (*lst)->next;\n\n\ttmp_idx = xstrdup(preq->tmpfile);\n\tstrcpy(tmp_idx + strlen(tmp_idx) - strlen(\".pack.temp\"),\n\t       \".idx.temp\");\n\n\tip_argv[0] = \"index-pack\";\n\tip_argv[1] = \"-o\";\n\tip_argv[2] = tmp_idx;\n\tip_argv[3] = preq->tmpfile;\n\tip_argv[4] = NULL;\n\n\tmemset(&ip, 0, sizeof(ip));\n\tip.argv = ip_argv;\n\tip.git_cmd = 1;\n\tip.no_stdin = 1;\n\tip.no_stdout = 1;\n\n\tif (run_command(&ip)) {\n\t\tunlink(preq->tmpfile);\n\t\tunlink(tmp_idx);\n\t\tfree(tmp_idx);\n\t\treturn -1;\n\t}\n\n\tunlink(sha1_pack_index_name(p->sha1));\n\n\tif (move_temp_to_file(preq->tmpfile, sha1_pack_name(p->sha1))\n\t || move_temp_to_file(tmp_idx, sha1_pack_index_name(p->sha1))) {\n\t\tfree(tmp_idx);\n\t\treturn -1;\n\t}\n\n\tinstall_packed_git(p);\n\tfree(tmp_idx);\n\treturn 0;\n}\n\nstruct http_pack_request *new_http_pack_request(\n\tstruct packed_git *target, const char *base_url)\n{\n\tlong prev_posn = 0;\n\tchar range[RANGE_HEADER_SIZE];\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct http_pack_request *preq;\n\n\tpreq = xmalloc(sizeof(*preq));\n\tpreq->target = target;\n\tpreq->range_header = NULL;\n\n\tend_url_with_slash(&buf, base_url);\n\tstrbuf_addf(&buf, \"objects/pack/pack-%s.pack\",\n\t\tsha1_to_hex(target->sha1));\n\tpreq->url = strbuf_detach(&buf, NULL);\n\n\tsnprintf(preq->tmpfile, sizeof(preq->tmpfile), \"%s.temp\",\n\t\tsha1_pack_name(target->sha1));\n\tpreq->packfile = fopen(preq->tmpfile, \"a\");\n\tif (!preq->packfile) {\n\t\terror(\"Unable to open local file %s for pack\",\n\t\t      preq->tmpfile);\n\t\tgoto abort;\n\t}\n\n\tpreq->slot = get_active_slot();\n\tpreq->slot->local = preq->packfile;\n\tcurl_easy_setopt(preq->slot->curl, CURLOPT_FILE, preq->packfile);\n\tcurl_easy_setopt(preq->slot->curl, CURLOPT_WRITEFUNCTION, fwrite);\n\tcurl_easy_setopt(preq->slot->curl, CURLOPT_URL, preq->url);\n\tcurl_easy_setopt(preq->slot->curl, CURLOPT_HTTPHEADER,\n\t\tno_pragma_header);\n\n\t/*\n\t * If there is data present from a previous transfer attempt,\n\t * resume where it left off\n\t */\n\tprev_posn = ftell(preq->packfile);\n\tif (prev_posn>0) {\n\t\tif (http_is_verbose)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Resuming fetch of pack %s at byte %ld\\n\",\n\t\t\t\tsha1_to_hex(target->sha1), prev_posn);\n\t\tsprintf(range, \"Range: bytes=%ld-\", prev_posn);\n\t\tpreq->range_header = curl_slist_append(NULL, range);\n\t\tcurl_easy_setopt(preq->slot->curl, CURLOPT_HTTPHEADER,\n\t\t\tpreq->range_header);\n\t}\n\n\treturn preq;\n\nabort:\n\tfree(preq->url);\n\tfree(preq);\n\treturn NULL;\n}\n\n/* Helpers for fetching objects (loose) */\nstatic size_t fwrite_sha1_file(char *ptr, size_t eltsize, size_t nmemb,\n\t\t\t       void *data)\n{\n\tunsigned char expn[4096];\n\tsize_t size = eltsize * nmemb;\n\tint posn = 0;\n\tstruct http_object_request *freq =\n\t\t(struct http_object_request *)data;\n\tdo {\n\t\tssize_t retval = xwrite(freq->localfile,\n\t\t\t\t\t(char *) ptr + posn, size - posn);\n\t\tif (retval < 0)\n\t\t\treturn posn;\n\t\tposn += retval;\n\t} while (posn < size);\n\n\tfreq->stream.avail_in = size;\n\tfreq->stream.next_in = (void *)ptr;\n\tdo {\n\t\tfreq->stream.next_out = expn;\n\t\tfreq->stream.avail_out = sizeof(expn);\n\t\tfreq->zret = git_inflate(&freq->stream, Z_SYNC_FLUSH);\n\t\tgit_SHA1_Update(&freq->c, expn,\n\t\t\t\tsizeof(expn) - freq->stream.avail_out);\n\t} while (freq->stream.avail_in && freq->zret == Z_OK);\n\tdata_received++;\n\treturn size;\n}\n\nstruct http_object_request *new_http_object_request(const char *base_url,\n\tunsigned char *sha1)\n{\n\tchar *hex = sha1_to_hex(sha1);\n\tchar *filename;\n\tchar prevfile[PATH_MAX];\n\tint prevlocal;\n\tchar prev_buf[PREV_BUF_SIZE];\n\tssize_t prev_read = 0;\n\tlong prev_posn = 0;\n\tchar range[RANGE_HEADER_SIZE];\n\tstruct curl_slist *range_header = NULL;\n\tstruct http_object_request *freq;\n\n\tfreq = xmalloc(sizeof(*freq));\n\thashcpy(freq->sha1, sha1);\n\tfreq->localfile = -1;\n\n\tfilename = sha1_file_name(sha1);\n\tsnprintf(freq->tmpfile, sizeof(freq->tmpfile),\n\t\t \"%s.temp\", filename);\n\n\tsnprintf(prevfile, sizeof(prevfile), \"%s.prev\", filename);\n\tunlink_or_warn(prevfile);\n\trename(freq->tmpfile, prevfile);\n\tunlink_or_warn(freq->tmpfile);\n\n\tif (freq->localfile != -1)\n\t\terror(\"fd leakage in start: %d\", freq->localfile);\n\tfreq->localfile = open(freq->tmpfile,\n\t\t\t       O_WRONLY | O_CREAT | O_EXCL, 0666);\n\t/*\n\t * This could have failed due to the \"lazy directory creation\";\n\t * try to mkdir the last path component.\n\t */\n\tif (freq->localfile < 0 && errno == ENOENT) {\n\t\tchar *dir = strrchr(freq->tmpfile, '/');\n\t\tif (dir) {\n\t\t\t*dir = 0;\n\t\t\tmkdir(freq->tmpfile, 0777);\n\t\t\t*dir = '/';\n\t\t}\n\t\tfreq->localfile = open(freq->tmpfile,\n\t\t\t\t       O_WRONLY | O_CREAT | O_EXCL, 0666);\n\t}\n\n\tif (freq->localfile < 0) {\n\t\terror(\"Couldn't create temporary file %s: %s\",\n\t\t      freq->tmpfile, strerror(errno));\n\t\tgoto abort;\n\t}\n\n\tmemset(&freq->stream, 0, sizeof(freq->stream));\n\n\tgit_inflate_init(&freq->stream);\n\n\tgit_SHA1_Init(&freq->c);\n\n\tfreq->url = get_remote_object_url(base_url, hex, 0);\n\n\t/*\n\t * If a previous temp file is present, process what was already\n\t * fetched.\n\t */\n\tprevlocal = open(prevfile, O_RDONLY);\n\tif (prevlocal != -1) {\n\t\tdo {\n\t\t\tprev_read = xread(prevlocal, prev_buf, PREV_BUF_SIZE);\n\t\t\tif (prev_read>0) {\n\t\t\t\tif (fwrite_sha1_file(prev_buf,\n\t\t\t\t\t\t     1,\n\t\t\t\t\t\t     prev_read,\n\t\t\t\t\t\t     freq) == prev_read) {\n\t\t\t\t\tprev_posn += prev_read;\n\t\t\t\t} else {\n\t\t\t\t\tprev_read = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (prev_read > 0);\n\t\tclose(prevlocal);\n\t}\n\tunlink_or_warn(prevfile);\n\n\t/*\n\t * Reset inflate/SHA1 if there was an error reading the previous temp\n\t * file; also rewind to the beginning of the local file.\n\t */\n\tif (prev_read == -1) {\n\t\tmemset(&freq->stream, 0, sizeof(freq->stream));\n\t\tgit_inflate_init(&freq->stream);\n\t\tgit_SHA1_Init(&freq->c);\n\t\tif (prev_posn>0) {\n\t\t\tprev_posn = 0;\n\t\t\tlseek(freq->localfile, 0, SEEK_SET);\n\t\t\tif (ftruncate(freq->localfile, 0) < 0) {\n\t\t\t\terror(\"Couldn't truncate temporary file %s: %s\",\n\t\t\t\t\t  freq->tmpfile, strerror(errno));\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\t}\n\n\tfreq->slot = get_active_slot();\n\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_FILE, freq);\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_WRITEFUNCTION, fwrite_sha1_file);\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_ERRORBUFFER, freq->errorstr);\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_URL, freq->url);\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_HTTPHEADER, no_pragma_header);\n\n\t/*\n\t * If we have successfully processed data from a previous fetch\n\t * attempt, only fetch the data we don't already have.\n\t */\n\tif (prev_posn>0) {\n\t\tif (http_is_verbose)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Resuming fetch of object %s at byte %ld\\n\",\n\t\t\t\thex, prev_posn);\n\t\tsprintf(range, \"Range: bytes=%ld-\", prev_posn);\n\t\trange_header = curl_slist_append(range_header, range);\n\t\tcurl_easy_setopt(freq->slot->curl,\n\t\t\t\t CURLOPT_HTTPHEADER, range_header);\n\t}\n\n\treturn freq;\n\nabort:\n\tfree(filename);\n\tfree(freq->url);\n\tfree(freq);\n\treturn NULL;\n}\n\nvoid process_http_object_request(struct http_object_request *freq)\n{\n\tif (freq->slot == NULL)\n\t\treturn;\n\tfreq->curl_result = freq->slot->curl_result;\n\tfreq->http_code = freq->slot->http_code;\n\tfreq->slot = NULL;\n}\n\nint finish_http_object_request(struct http_object_request *freq)\n{\n\tstruct stat st;\n\n\tclose(freq->localfile);\n\tfreq->localfile = -1;\n\n\tprocess_http_object_request(freq);\n\n\tif (freq->http_code == 416) {\n\t\twarning(\"requested range invalid; we may already have all the data.\");\n\t} else if (freq->curl_result != CURLE_OK) {\n\t\tif (stat(freq->tmpfile, &st) == 0)\n\t\t\tif (st.st_size == 0)\n\t\t\t\tunlink_or_warn(freq->tmpfile);\n\t\treturn -1;\n\t}\n\n\tgit_inflate_end(&freq->stream);\n\tgit_SHA1_Final(freq->real_sha1, &freq->c);\n\tif (freq->zret != Z_STREAM_END) {\n\t\tunlink_or_warn(freq->tmpfile);\n\t\treturn -1;\n\t}\n\tif (hashcmp(freq->sha1, freq->real_sha1)) {\n\t\tunlink_or_warn(freq->tmpfile);\n\t\treturn -1;\n\t}\n\tfreq->rename =\n\t\tmove_temp_to_file(freq->tmpfile, sha1_file_name(freq->sha1));\n\n\treturn freq->rename;\n}\n\nvoid abort_http_object_request(struct http_object_request *freq)\n{\n\tunlink_or_warn(freq->tmpfile);\n\n\trelease_http_object_request(freq);\n}\n\nvoid release_http_object_request(struct http_object_request *freq)\n{\n\tif (freq->localfile != -1) {\n\t\tclose(freq->localfile);\n\t\tfreq->localfile = -1;\n\t}\n\tif (freq->url != NULL) {\n\t\tfree(freq->url);\n\t\tfreq->url = NULL;\n\t}\n\tif (freq->slot != NULL) {\n\t\tfreq->slot->callback_func = NULL;\n\t\tfreq->slot->callback_data = NULL;\n\t\trelease_active_slot(freq->slot);\n\t\tfreq->slot = NULL;\n\t}\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00a8553fcc10af2c37520d4a0eaae9e50f8e504c",
  "sha1_ok": true,
  "size": 34438
}
