{
  "content": {
    "base64": "LyoKICogU2ltcGxlIHRleHQtYmFzZWQgcHJvZ3Jlc3MgZGlzcGxheSBtb2R1bGUgZm9yIEdJVAogKgogKiBDb3B5cmlnaHQgKGMpIDIwMDcgYnkgTmljb2xhcyBQaXRyZSA8bmljb0BmbHV4bmljLm5ldD4KICoKICogVGhpcyBjb2RlIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkKICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgYXMKICogcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24uCiAqLwoKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJnZXR0ZXh0LmgiCiNpbmNsdWRlICJwcm9ncmVzcy5oIgojaW5jbHVkZSAic3RyYnVmLmgiCiNpbmNsdWRlICJ0cmFjZS5oIgojaW5jbHVkZSAidXRmOC5oIgoKI2RlZmluZSBUUF9JRFhfTUFYICAgICAgOAoKc3RydWN0IHRocm91Z2hwdXQgewoJb2ZmX3QgY3Vycl90b3RhbDsKCW9mZl90IHByZXZfdG90YWw7Cgl1aW50NjRfdCBwcmV2X25zOwoJdW5zaWduZWQgaW50IGF2Z19ieXRlczsKCXVuc2lnbmVkIGludCBhdmdfbWlzZWNzOwoJdW5zaWduZWQgaW50IGxhc3RfYnl0ZXNbVFBfSURYX01BWF07Cgl1bnNpZ25lZCBpbnQgbGFzdF9taXNlY3NbVFBfSURYX01BWF07Cgl1bnNpZ25lZCBpbnQgaWR4OwoJc3RydWN0IHN0cmJ1ZiBkaXNwbGF5Owp9OwoKc3RydWN0IHByb2dyZXNzIHsKCWNvbnN0IGNoYXIgKnRpdGxlOwoJdWludDY0X3QgbGFzdF92YWx1ZTsKCXVpbnQ2NF90IHRvdGFsOwoJdW5zaWduZWQgbGFzdF9wZXJjZW50OwoJdW5zaWduZWQgZGVsYXk7Cgl1bnNpZ25lZCBzcGFyc2U7CglzdHJ1Y3QgdGhyb3VnaHB1dCAqdGhyb3VnaHB1dDsKCXVpbnQ2NF90IHN0YXJ0X25zOwoJc3RydWN0IHN0cmJ1ZiBjb3VudGVyc19zYjsKCWludCB0aXRsZV9sZW47CglpbnQgc3BsaXQ7Cn07CgpzdGF0aWMgdm9sYXRpbGUgc2lnX2F0b21pY190IHByb2dyZXNzX3VwZGF0ZTsKCi8qCiAqIFRoZXNlIGFyZSBvbmx5IGludGVuZGVkIGZvciB0ZXN0aW5nIHRoZSBwcm9ncmVzcyBvdXRwdXQsIGkuZS4gZXhjbHVzaXZlbHkKICogZm9yICd0ZXN0LXRvb2wgcHJvZ3Jlc3MnLgogKi8KaW50IHByb2dyZXNzX3Rlc3Rpbmc7CnVpbnQ2NF90IHByb2dyZXNzX3Rlc3RfbnMgPSAwOwp2b2lkIHByb2dyZXNzX3Rlc3RfZm9yY2VfdXBkYXRlKHZvaWQpOyAvKiBUbyBzaWxlbmNlIC1XbWlzc2luZy1wcm90b3R5cGVzICovCnZvaWQgcHJvZ3Jlc3NfdGVzdF9mb3JjZV91cGRhdGUodm9pZCkKewoJcHJvZ3Jlc3NfdXBkYXRlID0gMTsKfQoKCnN0YXRpYyB2b2lkIHByb2dyZXNzX2ludGVydmFsKGludCBzaWdudW0pCnsKCXByb2dyZXNzX3VwZGF0ZSA9IDE7Cn0KCnN0YXRpYyB2b2lkIHNldF9wcm9ncmVzc19zaWduYWwodm9pZCkKewoJc3RydWN0IHNpZ2FjdGlvbiBzYTsKCXN0cnVjdCBpdGltZXJ2YWwgdjsKCglpZiAocHJvZ3Jlc3NfdGVzdGluZykKCQlyZXR1cm47CgoJcHJvZ3Jlc3NfdXBkYXRlID0gMDsKCgltZW1zZXQoJnNhLCAwLCBzaXplb2Yoc2EpKTsKCXNhLnNhX2hhbmRsZXIgPSBwcm9ncmVzc19pbnRlcnZhbDsKCXNpZ2VtcHR5c2V0KCZzYS5zYV9tYXNrKTsKCXNhLnNhX2ZsYWdzID0gU0FfUkVTVEFSVDsKCXNpZ2FjdGlvbihTSUdBTFJNLCAmc2EsIE5VTEwpOwoKCXYuaXRfaW50ZXJ2YWwudHZfc2VjID0gMTsKCXYuaXRfaW50ZXJ2YWwudHZfdXNlYyA9IDA7Cgl2Lml0X3ZhbHVlID0gdi5pdF9pbnRlcnZhbDsKCXNldGl0aW1lcihJVElNRVJfUkVBTCwgJnYsIE5VTEwpOwp9CgpzdGF0aWMgdm9pZCBjbGVhcl9wcm9ncmVzc19zaWduYWwodm9pZCkKewoJc3RydWN0IGl0aW1lcnZhbCB2ID0ge3swLH0sfTsKCglpZiAocHJvZ3Jlc3NfdGVzdGluZykKCQlyZXR1cm47CgoJc2V0aXRpbWVyKElUSU1FUl9SRUFMLCAmdiwgTlVMTCk7CglzaWduYWwoU0lHQUxSTSwgU0lHX0lHTik7Cglwcm9ncmVzc191cGRhdGUgPSAwOwp9CgpzdGF0aWMgaW50IGlzX2ZvcmVncm91bmRfZmQoaW50IGZkKQp7CglpbnQgdHBncnAgPSB0Y2dldHBncnAoZmQpOwoJcmV0dXJuIHRwZ3JwIDwgMCB8fCB0cGdycCA9PSBnZXRwZ2lkKDApOwp9CgpzdGF0aWMgdm9pZCBkaXNwbGF5KHN0cnVjdCBwcm9ncmVzcyAqcHJvZ3Jlc3MsIHVpbnQ2NF90IG4sIGNvbnN0IGNoYXIgKmRvbmUpCnsKCWNvbnN0IGNoYXIgKnRwOwoJc3RydWN0IHN0cmJ1ZiAqY291bnRlcnNfc2IgPSAmcHJvZ3Jlc3MtPmNvdW50ZXJzX3NiOwoJaW50IHNob3dfdXBkYXRlID0gMDsKCWludCBsYXN0X2NvdW50X2xlbiA9IGNvdW50ZXJzX3NiLT5sZW47CgoJaWYgKHByb2dyZXNzLT5kZWxheSAmJiAoIXByb2dyZXNzX3VwZGF0ZSB8fCAtLXByb2dyZXNzLT5kZWxheSkpCgkJcmV0dXJuOwoKCXByb2dyZXNzLT5sYXN0X3ZhbHVlID0gbjsKCXRwID0gKHByb2dyZXNzLT50aHJvdWdocHV0KSA/IHByb2dyZXNzLT50aHJvdWdocHV0LT5kaXNwbGF5LmJ1ZiA6ICIiOwoJaWYgKHByb2dyZXNzLT50b3RhbCkgewoJCXVuc2lnbmVkIHBlcmNlbnQgPSBuICogMTAwIC8gcHJvZ3Jlc3MtPnRvdGFsOwoJCWlmIChwZXJjZW50ICE9IHByb2dyZXNzLT5sYXN0X3BlcmNlbnQgfHwgcHJvZ3Jlc3NfdXBkYXRlKSB7CgkJCXByb2dyZXNzLT5sYXN0X3BlcmNlbnQgPSBwZXJjZW50OwoKCQkJc3RyYnVmX3Jlc2V0KGNvdW50ZXJzX3NiKTsKCQkJc3RyYnVmX2FkZGYoY291bnRlcnNfc2IsCgkJCQkgICAgIiUzdSUlICglIlBSSXVNQVgiLyUiUFJJdU1BWCIpJXMiLCBwZXJjZW50LAoJCQkJICAgICh1aW50bWF4X3QpbiwgKHVpbnRtYXhfdClwcm9ncmVzcy0+dG90YWwsCgkJCQkgICAgdHApOwoJCQlzaG93X3VwZGF0ZSA9IDE7CgkJfQoJfSBlbHNlIGlmIChwcm9ncmVzc191cGRhdGUpIHsKCQlzdHJidWZfcmVzZXQoY291bnRlcnNfc2IpOwoJCXN0cmJ1Zl9hZGRmKGNvdW50ZXJzX3NiLCAiJSJQUkl1TUFYIiVzIiwgKHVpbnRtYXhfdCluLCB0cCk7CgkJc2hvd191cGRhdGUgPSAxOwoJfQoKCWlmIChzaG93X3VwZGF0ZSkgewoJCWlmIChpc19mb3JlZ3JvdW5kX2ZkKGZpbGVubyhzdGRlcnIpKSB8fCBkb25lKSB7CgkJCWNvbnN0IGNoYXIgKmVvbCA9IGRvbmUgPyBkb25lIDogIlxyIjsKCQkJc2l6ZV90IGNsZWFyX2xlbiA9IGNvdW50ZXJzX3NiLT5sZW4gPCBsYXN0X2NvdW50X2xlbiA/CgkJCQkJbGFzdF9jb3VudF9sZW4gLSBjb3VudGVyc19zYi0+bGVuICsgMSA6CgkJCQkJMDsKCQkJLyogVGhlICIrIDIiIGFjY291bnRzIGZvciB0aGUgIjogIi4gKi8KCQkJc2l6ZV90IHByb2dyZXNzX2xpbmVfbGVuID0gcHJvZ3Jlc3MtPnRpdGxlX2xlbiArCgkJCQkJCWNvdW50ZXJzX3NiLT5sZW4gKyAyOwoJCQlpbnQgY29scyA9IHRlcm1fY29sdW1ucygpOwoKCQkJaWYgKHByb2dyZXNzLT5zcGxpdCkgewoJCQkJZnByaW50ZihzdGRlcnIsICIgICVzJSpzIiwgY291bnRlcnNfc2ItPmJ1ZiwKCQkJCQkoaW50KSBjbGVhcl9sZW4sIGVvbCk7CgkJCX0gZWxzZSBpZiAoIWRvbmUgJiYgY29scyA8IHByb2dyZXNzX2xpbmVfbGVuKSB7CgkJCQljbGVhcl9sZW4gPSBwcm9ncmVzcy0+dGl0bGVfbGVuICsgMSA8IGNvbHMgPwoJCQkJCSAgICBjb2xzIC0gcHJvZ3Jlc3MtPnRpdGxlX2xlbiAtIDEgOiAwOwoJCQkJZnByaW50ZihzdGRlcnIsICIlczolKnNcbiAgJXMlcyIsCgkJCQkJcHJvZ3Jlc3MtPnRpdGxlLCAoaW50KSBjbGVhcl9sZW4sICIiLAoJCQkJCWNvdW50ZXJzX3NiLT5idWYsIGVvbCk7CgkJCQlwcm9ncmVzcy0+c3BsaXQgPSAxOwoJCQl9IGVsc2UgewoJCQkJZnByaW50ZihzdGRlcnIsICIlczogJXMlKnMiLCBwcm9ncmVzcy0+dGl0bGUsCgkJCQkJY291bnRlcnNfc2ItPmJ1ZiwgKGludCkgY2xlYXJfbGVuLCBlb2wpOwoJCQl9CgkJCWZmbHVzaChzdGRlcnIpOwoJCX0KCQlwcm9ncmVzc191cGRhdGUgPSAwOwoJfQp9CgpzdGF0aWMgdm9pZCB0aHJvdWdocHV0X3N0cmluZyhzdHJ1Y3Qgc3RyYnVmICpidWYsIHVpbnQ2NF90IHRvdGFsLAoJCQkgICAgICB1bnNpZ25lZCBpbnQgcmF0ZSkKewoJc3RyYnVmX3Jlc2V0KGJ1Zik7CglzdHJidWZfYWRkc3RyKGJ1ZiwgIiwgIik7CglzdHJidWZfaHVtYW5pc2VfYnl0ZXMoYnVmLCB0b3RhbCk7CglzdHJidWZfYWRkc3RyKGJ1ZiwgIiB8ICIpOwoJc3RyYnVmX2h1bWFuaXNlX3JhdGUoYnVmLCByYXRlICogMTAyNCk7Cn0KCnN0YXRpYyB1aW50NjRfdCBwcm9ncmVzc19nZXRuYW5vdGltZShzdHJ1Y3QgcHJvZ3Jlc3MgKnByb2dyZXNzKQp7CglpZiAocHJvZ3Jlc3NfdGVzdGluZykKCQlyZXR1cm4gcHJvZ3Jlc3MtPnN0YXJ0X25zICsgcHJvZ3Jlc3NfdGVzdF9uczsKCWVsc2UKCQlyZXR1cm4gZ2V0bmFub3RpbWUoKTsKfQoKdm9pZCBkaXNwbGF5X3Rocm91Z2hwdXQoc3RydWN0IHByb2dyZXNzICpwcm9ncmVzcywgdWludDY0X3QgdG90YWwpCnsKCXN0cnVjdCB0aHJvdWdocHV0ICp0cDsKCXVpbnQ2NF90IG5vd19uczsKCXVuc2lnbmVkIGludCBtaXNlY3MsIGNvdW50LCByYXRlOwoKCWlmICghcHJvZ3Jlc3MpCgkJcmV0dXJuOwoJdHAgPSBwcm9ncmVzcy0+dGhyb3VnaHB1dDsKCglub3dfbnMgPSBwcm9ncmVzc19nZXRuYW5vdGltZShwcm9ncmVzcyk7CgoJaWYgKCF0cCkgewoJCXByb2dyZXNzLT50aHJvdWdocHV0ID0gdHAgPSB4Y2FsbG9jKDEsIHNpemVvZigqdHApKTsKCQl0cC0+cHJldl90b3RhbCA9IHRwLT5jdXJyX3RvdGFsID0gdG90YWw7CgkJdHAtPnByZXZfbnMgPSBub3dfbnM7CgkJc3RyYnVmX2luaXQoJnRwLT5kaXNwbGF5LCAwKTsKCQlyZXR1cm47Cgl9Cgl0cC0+Y3Vycl90b3RhbCA9IHRvdGFsOwoKCS8qIG9ubHkgdXBkYXRlIHRocm91Z2hwdXQgZXZlcnkgMC41IHMgKi8KCWlmIChub3dfbnMgLSB0cC0+cHJldl9ucyA8PSA1MDAwMDAwMDApCgkJcmV0dXJuOwoKCS8qCgkgKiBXZSBoYXZlIHggPSBieXRlcyBhbmQgeSA9IG5hbm9zZWNzLiAgV2Ugd2FudCB6ID0gS2lCL3M6CgkgKgoJICoJeiA9ICh4IC8gMTAyNCkgLyAoeSAvIDEwMDAwMDAwMDApCgkgKgl6ID0geCAvIHkgKiAxMDAwMDAwMDAwIC8gMTAyNAoJICoJeiA9IHggLyAoeSAqIDEwMjQgLyAxMDAwMDAwMDAwKQoJICoJeiA9IHggLyB5JwoJICoKCSAqIFRvIHNpbXBsaWZ5IHRoaW5ncyB3ZSdsbCBrZWVwIHRyYWNrIG9mIG1pc2Vjcywgb3IgMTAyNHRoIG9mIGEgc2VjCgkgKiBvYnRhaW5lZCB3aXRoOgoJICoKCSAqCXknID0geSAqIDEwMjQgLyAxMDAwMDAwMDAwCgkgKgl5JyA9IHkgKiAoMl4xMCAvIDJeNDIpICogKDJeNDIgLyAxMDAwMDAwMDAwKQoJICoJeScgPSB5IC8gMl4zMiAqIDQzOTgKCSAqCXknID0gKHkgKiA0Mzk4KSA+PiAzMgoJICovCgltaXNlY3MgPSAoKG5vd19ucyAtIHRwLT5wcmV2X25zKSAqIDQzOTgpID4+IDMyOwoKCWNvdW50ID0gdG90YWwgLSB0cC0+cHJldl90b3RhbDsKCXRwLT5wcmV2X3RvdGFsID0gdG90YWw7Cgl0cC0+cHJldl9ucyA9IG5vd19uczsKCXRwLT5hdmdfYnl0ZXMgKz0gY291bnQ7Cgl0cC0+YXZnX21pc2VjcyArPSBtaXNlY3M7CglyYXRlID0gdHAtPmF2Z19ieXRlcyAvIHRwLT5hdmdfbWlzZWNzOwoJdHAtPmF2Z19ieXRlcyAtPSB0cC0+bGFzdF9ieXRlc1t0cC0+aWR4XTsKCXRwLT5hdmdfbWlzZWNzIC09IHRwLT5sYXN0X21pc2Vjc1t0cC0+aWR4XTsKCXRwLT5sYXN0X2J5dGVzW3RwLT5pZHhdID0gY291bnQ7Cgl0cC0+bGFzdF9taXNlY3NbdHAtPmlkeF0gPSBtaXNlY3M7Cgl0cC0+aWR4ID0gKHRwLT5pZHggKyAxKSAlIFRQX0lEWF9NQVg7CgoJdGhyb3VnaHB1dF9zdHJpbmcoJnRwLT5kaXNwbGF5LCB0b3RhbCwgcmF0ZSk7CglpZiAocHJvZ3Jlc3MtPmxhc3RfdmFsdWUgIT0gLTEgJiYgcHJvZ3Jlc3NfdXBkYXRlKQoJCWRpc3BsYXkocHJvZ3Jlc3MsIHByb2dyZXNzLT5sYXN0X3ZhbHVlLCBOVUxMKTsKfQoKdm9pZCBkaXNwbGF5X3Byb2dyZXNzKHN0cnVjdCBwcm9ncmVzcyAqcHJvZ3Jlc3MsIHVpbnQ2NF90IG4pCnsKCWlmIChwcm9ncmVzcykKCQlkaXNwbGF5KHByb2dyZXNzLCBuLCBOVUxMKTsKfQoKc3RhdGljIHN0cnVjdCBwcm9ncmVzcyAqc3RhcnRfcHJvZ3Jlc3NfZGVsYXkoY29uc3QgY2hhciAqdGl0bGUsIHVpbnQ2NF90IHRvdGFsLAoJCQkJCSAgICAgdW5zaWduZWQgZGVsYXksIHVuc2lnbmVkIHNwYXJzZSkKewoJc3RydWN0IHByb2dyZXNzICpwcm9ncmVzcyA9IHhtYWxsb2Moc2l6ZW9mKCpwcm9ncmVzcykpOwoJcHJvZ3Jlc3MtPnRpdGxlID0gdGl0bGU7Cglwcm9ncmVzcy0+dG90YWwgPSB0b3RhbDsKCXByb2dyZXNzLT5sYXN0X3ZhbHVlID0gLTE7Cglwcm9ncmVzcy0+bGFzdF9wZXJjZW50ID0gLTE7Cglwcm9ncmVzcy0+ZGVsYXkgPSBkZWxheTsKCXByb2dyZXNzLT5zcGFyc2UgPSBzcGFyc2U7Cglwcm9ncmVzcy0+dGhyb3VnaHB1dCA9IE5VTEw7Cglwcm9ncmVzcy0+c3RhcnRfbnMgPSBnZXRuYW5vdGltZSgpOwoJc3RyYnVmX2luaXQoJnByb2dyZXNzLT5jb3VudGVyc19zYiwgMCk7Cglwcm9ncmVzcy0+dGl0bGVfbGVuID0gdXRmOF9zdHJ3aWR0aCh0aXRsZSk7Cglwcm9ncmVzcy0+c3BsaXQgPSAwOwoJc2V0X3Byb2dyZXNzX3NpZ25hbCgpOwoJcmV0dXJuIHByb2dyZXNzOwp9CgpzdHJ1Y3QgcHJvZ3Jlc3MgKnN0YXJ0X2RlbGF5ZWRfcHJvZ3Jlc3MoY29uc3QgY2hhciAqdGl0bGUsIHVpbnQ2NF90IHRvdGFsKQp7CglyZXR1cm4gc3RhcnRfcHJvZ3Jlc3NfZGVsYXkodGl0bGUsIHRvdGFsLCAyLCAwKTsKfQoKc3RydWN0IHByb2dyZXNzICpzdGFydF9wcm9ncmVzcyhjb25zdCBjaGFyICp0aXRsZSwgdWludDY0X3QgdG90YWwpCnsKCXJldHVybiBzdGFydF9wcm9ncmVzc19kZWxheSh0aXRsZSwgdG90YWwsIDAsIDApOwp9CgovKgogKiBIZXJlICJzcGFyc2UiIG1lYW5zIHRoYXQgdGhlIGNhbGxlciBtaWdodCB1c2Ugc29tZSBzYW1wbGluZyBjcml0ZXJpYSB0bwogKiBkZWNpZGUgd2hlbiB0byBjYWxsIGRpc3BsYXlfcHJvZ3Jlc3MoKSByYXRoZXIgdGhhbiBjYWxsaW5nIGl0IGZvciBldmVyeQogKiBpbnRlZ2VyIHZhbHVlIGluWzAgLi4gdG90YWwpLiAgSW4gcGFydGljdWxhciwgdGhlIGNhbGxlciBtaWdodCBub3QgY2FsbAogKiBkaXNwbGF5X3Byb2dyZXNzKCkgZm9yIHRoZSBsYXN0IHZhbHVlIGluIHRoZSByYW5nZS4KICoKICogV2hlbiAic3BhcnNlIiBpcyBzZXQsIHN0b3BfcHJvZ3Jlc3MoKSB3aWxsIGF1dG9tYXRpY2FsbHkgZm9yY2UgdGhlIGRvbmUKICogbWVzc2FnZSB0byBzaG93IDEwMCUuCiAqLwpzdHJ1Y3QgcHJvZ3Jlc3MgKnN0YXJ0X3NwYXJzZV9wcm9ncmVzcyhjb25zdCBjaGFyICp0aXRsZSwgdWludDY0X3QgdG90YWwpCnsKCXJldHVybiBzdGFydF9wcm9ncmVzc19kZWxheSh0aXRsZSwgdG90YWwsIDAsIDEpOwp9CgpzdHJ1Y3QgcHJvZ3Jlc3MgKnN0YXJ0X2RlbGF5ZWRfc3BhcnNlX3Byb2dyZXNzKGNvbnN0IGNoYXIgKnRpdGxlLAoJCQkJCSAgICAgICB1aW50NjRfdCB0b3RhbCkKewoJcmV0dXJuIHN0YXJ0X3Byb2dyZXNzX2RlbGF5KHRpdGxlLCB0b3RhbCwgMiwgMSk7Cn0KCnN0YXRpYyB2b2lkIGZpbmlzaF9pZl9zcGFyc2Uoc3RydWN0IHByb2dyZXNzICpwcm9ncmVzcykKewoJaWYgKHByb2dyZXNzICYmCgkgICAgcHJvZ3Jlc3MtPnNwYXJzZSAmJgoJICAgIHByb2dyZXNzLT5sYXN0X3ZhbHVlICE9IHByb2dyZXNzLT50b3RhbCkKCQlkaXNwbGF5X3Byb2dyZXNzKHByb2dyZXNzLCBwcm9ncmVzcy0+dG90YWwpOwp9Cgp2b2lkIHN0b3BfcHJvZ3Jlc3Moc3RydWN0IHByb2dyZXNzICoqcF9wcm9ncmVzcykKewoJZmluaXNoX2lmX3NwYXJzZSgqcF9wcm9ncmVzcyk7CgoJc3RvcF9wcm9ncmVzc19tc2cocF9wcm9ncmVzcywgXygiZG9uZSIpKTsKfQoKdm9pZCBzdG9wX3Byb2dyZXNzX21zZyhzdHJ1Y3QgcHJvZ3Jlc3MgKipwX3Byb2dyZXNzLCBjb25zdCBjaGFyICptc2cpCnsKCXN0cnVjdCBwcm9ncmVzcyAqcHJvZ3Jlc3MgPSAqcF9wcm9ncmVzczsKCWlmICghcHJvZ3Jlc3MpCgkJcmV0dXJuOwoJKnBfcHJvZ3Jlc3MgPSBOVUxMOwoJaWYgKHByb2dyZXNzLT5sYXN0X3ZhbHVlICE9IC0xKSB7CgkJLyogRm9yY2UgdGhlIGxhc3QgdXBkYXRlICovCgkJY2hhciAqYnVmOwoJCXN0cnVjdCB0aHJvdWdocHV0ICp0cCA9IHByb2dyZXNzLT50aHJvdWdocHV0OwoKCQlpZiAodHApIHsKCQkJdWludDY0X3Qgbm93X25zID0gcHJvZ3Jlc3NfZ2V0bmFub3RpbWUocHJvZ3Jlc3MpOwoJCQl1bnNpZ25lZCBpbnQgbWlzZWNzLCByYXRlOwoJCQltaXNlY3MgPSAoKG5vd19ucyAtIHByb2dyZXNzLT5zdGFydF9ucykgKiA0Mzk4KSA+PiAzMjsKCQkJcmF0ZSA9IHRwLT5jdXJyX3RvdGFsIC8gKG1pc2VjcyA/IG1pc2VjcyA6IDEpOwoJCQl0aHJvdWdocHV0X3N0cmluZygmdHAtPmRpc3BsYXksIHRwLT5jdXJyX3RvdGFsLCByYXRlKTsKCQl9CgkJcHJvZ3Jlc3NfdXBkYXRlID0gMTsKCQlidWYgPSB4c3RyZm10KCIsICVzLlxuIiwgbXNnKTsKCQlkaXNwbGF5KHByb2dyZXNzLCBwcm9ncmVzcy0+bGFzdF92YWx1ZSwgYnVmKTsKCQlmcmVlKGJ1Zik7Cgl9CgljbGVhcl9wcm9ncmVzc19zaWduYWwoKTsKCXN0cmJ1Zl9yZWxlYXNlKCZwcm9ncmVzcy0+Y291bnRlcnNfc2IpOwoJaWYgKHByb2dyZXNzLT50aHJvdWdocHV0KQoJCXN0cmJ1Zl9yZWxlYXNlKCZwcm9ncmVzcy0+dGhyb3VnaHB1dC0+ZGlzcGxheSk7CglmcmVlKHByb2dyZXNzLT50aHJvdWdocHV0KTsKCWZyZWUocHJvZ3Jlc3MpOwp9Cg==",
    "text": "/*\n * Simple text-based progress display module for GIT\n *\n * Copyright (c) 2007 by Nicolas Pitre <nico@fluxnic.net>\n *\n * This code is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n\n#include \"cache.h\"\n#include \"gettext.h\"\n#include \"progress.h\"\n#include \"strbuf.h\"\n#include \"trace.h\"\n#include \"utf8.h\"\n\n#define TP_IDX_MAX      8\n\nstruct throughput {\n\toff_t curr_total;\n\toff_t prev_total;\n\tuint64_t prev_ns;\n\tunsigned int avg_bytes;\n\tunsigned int avg_misecs;\n\tunsigned int last_bytes[TP_IDX_MAX];\n\tunsigned int last_misecs[TP_IDX_MAX];\n\tunsigned int idx;\n\tstruct strbuf display;\n};\n\nstruct progress {\n\tconst char *title;\n\tuint64_t last_value;\n\tuint64_t total;\n\tunsigned last_percent;\n\tunsigned delay;\n\tunsigned sparse;\n\tstruct throughput *throughput;\n\tuint64_t start_ns;\n\tstruct strbuf counters_sb;\n\tint title_len;\n\tint split;\n};\n\nstatic volatile sig_atomic_t progress_update;\n\n/*\n * These are only intended for testing the progress output, i.e. exclusively\n * for 'test-tool progress'.\n */\nint progress_testing;\nuint64_t progress_test_ns = 0;\nvoid progress_test_force_update(void); /* To silence -Wmissing-prototypes */\nvoid progress_test_force_update(void)\n{\n\tprogress_update = 1;\n}\n\n\nstatic void progress_interval(int signum)\n{\n\tprogress_update = 1;\n}\n\nstatic void set_progress_signal(void)\n{\n\tstruct sigaction sa;\n\tstruct itimerval v;\n\n\tif (progress_testing)\n\t\treturn;\n\n\tprogress_update = 0;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = progress_interval;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = SA_RESTART;\n\tsigaction(SIGALRM, &sa, NULL);\n\n\tv.it_interval.tv_sec = 1;\n\tv.it_interval.tv_usec = 0;\n\tv.it_value = v.it_interval;\n\tsetitimer(ITIMER_REAL, &v, NULL);\n}\n\nstatic void clear_progress_signal(void)\n{\n\tstruct itimerval v = {{0,},};\n\n\tif (progress_testing)\n\t\treturn;\n\n\tsetitimer(ITIMER_REAL, &v, NULL);\n\tsignal(SIGALRM, SIG_IGN);\n\tprogress_update = 0;\n}\n\nstatic int is_foreground_fd(int fd)\n{\n\tint tpgrp = tcgetpgrp(fd);\n\treturn tpgrp < 0 || tpgrp == getpgid(0);\n}\n\nstatic void display(struct progress *progress, uint64_t n, const char *done)\n{\n\tconst char *tp;\n\tstruct strbuf *counters_sb = &progress->counters_sb;\n\tint show_update = 0;\n\tint last_count_len = counters_sb->len;\n\n\tif (progress->delay && (!progress_update || --progress->delay))\n\t\treturn;\n\n\tprogress->last_value = n;\n\ttp = (progress->throughput) ? progress->throughput->display.buf : \"\";\n\tif (progress->total) {\n\t\tunsigned percent = n * 100 / progress->total;\n\t\tif (percent != progress->last_percent || progress_update) {\n\t\t\tprogress->last_percent = percent;\n\n\t\t\tstrbuf_reset(counters_sb);\n\t\t\tstrbuf_addf(counters_sb,\n\t\t\t\t    \"%3u%% (%\"PRIuMAX\"/%\"PRIuMAX\")%s\", percent,\n\t\t\t\t    (uintmax_t)n, (uintmax_t)progress->total,\n\t\t\t\t    tp);\n\t\t\tshow_update = 1;\n\t\t}\n\t} else if (progress_update) {\n\t\tstrbuf_reset(counters_sb);\n\t\tstrbuf_addf(counters_sb, \"%\"PRIuMAX\"%s\", (uintmax_t)n, tp);\n\t\tshow_update = 1;\n\t}\n\n\tif (show_update) {\n\t\tif (is_foreground_fd(fileno(stderr)) || done) {\n\t\t\tconst char *eol = done ? done : \"\\r\";\n\t\t\tsize_t clear_len = counters_sb->len < last_count_len ?\n\t\t\t\t\tlast_count_len - counters_sb->len + 1 :\n\t\t\t\t\t0;\n\t\t\t/* The \"+ 2\" accounts for the \": \". */\n\t\t\tsize_t progress_line_len = progress->title_len +\n\t\t\t\t\t\tcounters_sb->len + 2;\n\t\t\tint cols = term_columns();\n\n\t\t\tif (progress->split) {\n\t\t\t\tfprintf(stderr, \"  %s%*s\", counters_sb->buf,\n\t\t\t\t\t(int) clear_len, eol);\n\t\t\t} else if (!done && cols < progress_line_len) {\n\t\t\t\tclear_len = progress->title_len + 1 < cols ?\n\t\t\t\t\t    cols - progress->title_len - 1 : 0;\n\t\t\t\tfprintf(stderr, \"%s:%*s\\n  %s%s\",\n\t\t\t\t\tprogress->title, (int) clear_len, \"\",\n\t\t\t\t\tcounters_sb->buf, eol);\n\t\t\t\tprogress->split = 1;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: %s%*s\", progress->title,\n\t\t\t\t\tcounters_sb->buf, (int) clear_len, eol);\n\t\t\t}\n\t\t\tfflush(stderr);\n\t\t}\n\t\tprogress_update = 0;\n\t}\n}\n\nstatic void throughput_string(struct strbuf *buf, uint64_t total,\n\t\t\t      unsigned int rate)\n{\n\tstrbuf_reset(buf);\n\tstrbuf_addstr(buf, \", \");\n\tstrbuf_humanise_bytes(buf, total);\n\tstrbuf_addstr(buf, \" | \");\n\tstrbuf_humanise_rate(buf, rate * 1024);\n}\n\nstatic uint64_t progress_getnanotime(struct progress *progress)\n{\n\tif (progress_testing)\n\t\treturn progress->start_ns + progress_test_ns;\n\telse\n\t\treturn getnanotime();\n}\n\nvoid display_throughput(struct progress *progress, uint64_t total)\n{\n\tstruct throughput *tp;\n\tuint64_t now_ns;\n\tunsigned int misecs, count, rate;\n\n\tif (!progress)\n\t\treturn;\n\ttp = progress->throughput;\n\n\tnow_ns = progress_getnanotime(progress);\n\n\tif (!tp) {\n\t\tprogress->throughput = tp = xcalloc(1, sizeof(*tp));\n\t\ttp->prev_total = tp->curr_total = total;\n\t\ttp->prev_ns = now_ns;\n\t\tstrbuf_init(&tp->display, 0);\n\t\treturn;\n\t}\n\ttp->curr_total = total;\n\n\t/* only update throughput every 0.5 s */\n\tif (now_ns - tp->prev_ns <= 500000000)\n\t\treturn;\n\n\t/*\n\t * We have x = bytes and y = nanosecs.  We want z = KiB/s:\n\t *\n\t *\tz = (x / 1024) / (y / 1000000000)\n\t *\tz = x / y * 1000000000 / 1024\n\t *\tz = x / (y * 1024 / 1000000000)\n\t *\tz = x / y'\n\t *\n\t * To simplify things we'll keep track of misecs, or 1024th of a sec\n\t * obtained with:\n\t *\n\t *\ty' = y * 1024 / 1000000000\n\t *\ty' = y * (2^10 / 2^42) * (2^42 / 1000000000)\n\t *\ty' = y / 2^32 * 4398\n\t *\ty' = (y * 4398) >> 32\n\t */\n\tmisecs = ((now_ns - tp->prev_ns) * 4398) >> 32;\n\n\tcount = total - tp->prev_total;\n\ttp->prev_total = total;\n\ttp->prev_ns = now_ns;\n\ttp->avg_bytes += count;\n\ttp->avg_misecs += misecs;\n\trate = tp->avg_bytes / tp->avg_misecs;\n\ttp->avg_bytes -= tp->last_bytes[tp->idx];\n\ttp->avg_misecs -= tp->last_misecs[tp->idx];\n\ttp->last_bytes[tp->idx] = count;\n\ttp->last_misecs[tp->idx] = misecs;\n\ttp->idx = (tp->idx + 1) % TP_IDX_MAX;\n\n\tthroughput_string(&tp->display, total, rate);\n\tif (progress->last_value != -1 && progress_update)\n\t\tdisplay(progress, progress->last_value, NULL);\n}\n\nvoid display_progress(struct progress *progress, uint64_t n)\n{\n\tif (progress)\n\t\tdisplay(progress, n, NULL);\n}\n\nstatic struct progress *start_progress_delay(const char *title, uint64_t total,\n\t\t\t\t\t     unsigned delay, unsigned sparse)\n{\n\tstruct progress *progress = xmalloc(sizeof(*progress));\n\tprogress->title = title;\n\tprogress->total = total;\n\tprogress->last_value = -1;\n\tprogress->last_percent = -1;\n\tprogress->delay = delay;\n\tprogress->sparse = sparse;\n\tprogress->throughput = NULL;\n\tprogress->start_ns = getnanotime();\n\tstrbuf_init(&progress->counters_sb, 0);\n\tprogress->title_len = utf8_strwidth(title);\n\tprogress->split = 0;\n\tset_progress_signal();\n\treturn progress;\n}\n\nstruct progress *start_delayed_progress(const char *title, uint64_t total)\n{\n\treturn start_progress_delay(title, total, 2, 0);\n}\n\nstruct progress *start_progress(const char *title, uint64_t total)\n{\n\treturn start_progress_delay(title, total, 0, 0);\n}\n\n/*\n * Here \"sparse\" means that the caller might use some sampling criteria to\n * decide when to call display_progress() rather than calling it for every\n * integer value in[0 .. total).  In particular, the caller might not call\n * display_progress() for the last value in the range.\n *\n * When \"sparse\" is set, stop_progress() will automatically force the done\n * message to show 100%.\n */\nstruct progress *start_sparse_progress(const char *title, uint64_t total)\n{\n\treturn start_progress_delay(title, total, 0, 1);\n}\n\nstruct progress *start_delayed_sparse_progress(const char *title,\n\t\t\t\t\t       uint64_t total)\n{\n\treturn start_progress_delay(title, total, 2, 1);\n}\n\nstatic void finish_if_sparse(struct progress *progress)\n{\n\tif (progress &&\n\t    progress->sparse &&\n\t    progress->last_value != progress->total)\n\t\tdisplay_progress(progress, progress->total);\n}\n\nvoid stop_progress(struct progress **p_progress)\n{\n\tfinish_if_sparse(*p_progress);\n\n\tstop_progress_msg(p_progress, _(\"done\"));\n}\n\nvoid stop_progress_msg(struct progress **p_progress, const char *msg)\n{\n\tstruct progress *progress = *p_progress;\n\tif (!progress)\n\t\treturn;\n\t*p_progress = NULL;\n\tif (progress->last_value != -1) {\n\t\t/* Force the last update */\n\t\tchar *buf;\n\t\tstruct throughput *tp = progress->throughput;\n\n\t\tif (tp) {\n\t\t\tuint64_t now_ns = progress_getnanotime(progress);\n\t\t\tunsigned int misecs, rate;\n\t\t\tmisecs = ((now_ns - progress->start_ns) * 4398) >> 32;\n\t\t\trate = tp->curr_total / (misecs ? misecs : 1);\n\t\t\tthroughput_string(&tp->display, tp->curr_total, rate);\n\t\t}\n\t\tprogress_update = 1;\n\t\tbuf = xstrfmt(\", %s.\\n\", msg);\n\t\tdisplay(progress, progress->last_value, buf);\n\t\tfree(buf);\n\t}\n\tclear_progress_signal();\n\tstrbuf_release(&progress->counters_sb);\n\tif (progress->throughput)\n\t\tstrbuf_release(&progress->throughput->display);\n\tfree(progress->throughput);\n\tfree(progress);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0063559aab6e233abd0a69aef6cead9d01e39948",
  "sha1_ok": true,
  "size": 8674
}
