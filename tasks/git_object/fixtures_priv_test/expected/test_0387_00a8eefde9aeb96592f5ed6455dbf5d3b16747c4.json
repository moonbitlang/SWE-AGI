{
  "content": {
    "base64": "LyoKICogImRpZmYgLS1uby1pbmRleCIgc3VwcG9ydAogKiBDb3B5cmlnaHQgKGMpIDIwMDcgYnkgSm9oYW5uZXMgU2NoaW5kZWxpbgogKiBDb3B5cmlnaHQgKGMpIDIwMDggYnkgSnVuaW8gQyBIYW1hbm8KICovCgojaW5jbHVkZSAiY2FjaGUuaCIKI2luY2x1ZGUgImNvbG9yLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgImJsb2IuaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAiZGlmZmNvcmUuaCIKI2luY2x1ZGUgInJldmlzaW9uLmgiCiNpbmNsdWRlICJsb2ctdHJlZS5oIgojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKCnN0YXRpYyBpbnQgcmVhZF9kaXJlY3RvcnkoY29uc3QgY2hhciAqcGF0aCwgc3RydWN0IHN0cmluZ19saXN0ICpsaXN0KQp7CglESVIgKmRpcjsKCXN0cnVjdCBkaXJlbnQgKmU7CgoJaWYgKCEoZGlyID0gb3BlbmRpcihwYXRoKSkpCgkJcmV0dXJuIGVycm9yKCJDb3VsZCBub3Qgb3BlbiBkaXJlY3RvcnkgJXMiLCBwYXRoKTsKCgl3aGlsZSAoKGUgPSByZWFkZGlyKGRpcikpKQoJCWlmIChzdHJjbXAoIi4iLCBlLT5kX25hbWUpICYmIHN0cmNtcCgiLi4iLCBlLT5kX25hbWUpKQoJCQlzdHJpbmdfbGlzdF9pbnNlcnQobGlzdCwgZS0+ZF9uYW1lKTsKCgljbG9zZWRpcihkaXIpOwoJcmV0dXJuIDA7Cn0KCi8qCiAqIFRoaXMgc2hvdWxkIGJlICIoc3RhbmRhcmQgaW5wdXQpIiBvciBzb21ldGhpbmcsIGJ1dCBpdCB3aWxsCiAqIHByb2JhYmx5IGV4cG9zZSBtYW55IG1vcmUgYnJlYWthZ2VzIGluIHRoZSB3YXkgbm8taW5kZXggY29kZQogKiBpcyBib2x0ZWQgb250byB0aGUgZGlmZiBjYWxsY2hhaW4uCiAqLwpzdGF0aWMgY29uc3QgY2hhciBmaWxlX2Zyb21fc3RhbmRhcmRfaW5wdXRbXSA9ICItIjsKCnN0YXRpYyBpbnQgZ2V0X21vZGUoY29uc3QgY2hhciAqcGF0aCwgaW50ICptb2RlKQp7CglzdHJ1Y3Qgc3RhdCBzdDsKCglpZiAoIXBhdGggfHwgIXN0cmNtcChwYXRoLCAiL2Rldi9udWxsIikpCgkJKm1vZGUgPSAwOwojaWZkZWYgR0lUX1dJTkRPV1NfTkFUSVZFCgllbHNlIGlmICghc3RyY2FzZWNtcChwYXRoLCAibnVsIikpCgkJKm1vZGUgPSAwOwojZW5kaWYKCWVsc2UgaWYgKHBhdGggPT0gZmlsZV9mcm9tX3N0YW5kYXJkX2lucHV0KQoJCSptb2RlID0gY3JlYXRlX2NlX21vZGUoMDY2Nik7CgllbHNlIGlmIChsc3RhdChwYXRoLCAmc3QpKQoJCXJldHVybiBlcnJvcigiQ291bGQgbm90IGFjY2VzcyAnJXMnIiwgcGF0aCk7CgllbHNlCgkJKm1vZGUgPSBzdC5zdF9tb2RlOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgcG9wdWxhdGVfZnJvbV9zdGRpbihzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqcykKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCXNpemVfdCBzaXplID0gMDsKCglpZiAoc3RyYnVmX3JlYWQoJmJ1ZiwgMCwgMCkgPCAwKQoJCXJldHVybiBlcnJvcigiZXJyb3Igd2hpbGUgcmVhZGluZyBmcm9tIHN0ZGluICVzIiwKCQkJCSAgICAgc3RyZXJyb3IoZXJybm8pKTsKCglzLT5zaG91bGRfbXVubWFwID0gMDsKCXMtPmRhdGEgPSBzdHJidWZfZGV0YWNoKCZidWYsICZzaXplKTsKCXMtPnNpemUgPSBzaXplOwoJcy0+c2hvdWxkX2ZyZWUgPSAxOwoJcy0+aXNfc3RkaW4gPSAxOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqbm9pbmRleF9maWxlc3BlYyhjb25zdCBjaGFyICpuYW1lLCBpbnQgbW9kZSkKewoJc3RydWN0IGRpZmZfZmlsZXNwZWMgKnM7CgoJaWYgKCFuYW1lKQoJCW5hbWUgPSAiL2Rldi9udWxsIjsKCXMgPSBhbGxvY19maWxlc3BlYyhuYW1lKTsKCWZpbGxfZmlsZXNwZWMocywgbnVsbF9zaGExLCAwLCBtb2RlKTsKCWlmIChuYW1lID09IGZpbGVfZnJvbV9zdGFuZGFyZF9pbnB1dCkKCQlwb3B1bGF0ZV9mcm9tX3N0ZGluKHMpOwoJcmV0dXJuIHM7Cn0KCnN0YXRpYyBpbnQgcXVldWVfZGlmZihzdHJ1Y3QgZGlmZl9vcHRpb25zICpvLAoJCSAgICAgIGNvbnN0IGNoYXIgKm5hbWUxLCBjb25zdCBjaGFyICpuYW1lMikKewoJaW50IG1vZGUxID0gMCwgbW9kZTIgPSAwOwoKCWlmIChnZXRfbW9kZShuYW1lMSwgJm1vZGUxKSB8fCBnZXRfbW9kZShuYW1lMiwgJm1vZGUyKSkKCQlyZXR1cm4gLTE7CgoJaWYgKG1vZGUxICYmIG1vZGUyICYmIFNfSVNESVIobW9kZTEpICE9IFNfSVNESVIobW9kZTIpKQoJCXJldHVybiBlcnJvcigiZmlsZS9kaXJlY3RvcnkgY29uZmxpY3Q6ICVzLCAlcyIsIG5hbWUxLCBuYW1lMik7CgoJaWYgKFNfSVNESVIobW9kZTEpIHx8IFNfSVNESVIobW9kZTIpKSB7CgkJc3RydWN0IHN0cmJ1ZiBidWZmZXIxID0gU1RSQlVGX0lOSVQ7CgkJc3RydWN0IHN0cmJ1ZiBidWZmZXIyID0gU1RSQlVGX0lOSVQ7CgkJc3RydWN0IHN0cmluZ19saXN0IHAxID0gU1RSSU5HX0xJU1RfSU5JVF9EVVA7CgkJc3RydWN0IHN0cmluZ19saXN0IHAyID0gU1RSSU5HX0xJU1RfSU5JVF9EVVA7CgkJaW50IGkxLCBpMiwgcmV0ID0gMDsKCQlzaXplX3QgbGVuMSA9IDAsIGxlbjIgPSAwOwoKCQlpZiAobmFtZTEgJiYgcmVhZF9kaXJlY3RvcnkobmFtZTEsICZwMSkpCgkJCXJldHVybiAtMTsKCQlpZiAobmFtZTIgJiYgcmVhZF9kaXJlY3RvcnkobmFtZTIsICZwMikpIHsKCQkJc3RyaW5nX2xpc3RfY2xlYXIoJnAxLCAwKTsKCQkJcmV0dXJuIC0xOwoJCX0KCgkJaWYgKG5hbWUxKSB7CgkJCXN0cmJ1Zl9hZGRzdHIoJmJ1ZmZlcjEsIG5hbWUxKTsKCQkJaWYgKGJ1ZmZlcjEubGVuICYmIGJ1ZmZlcjEuYnVmW2J1ZmZlcjEubGVuIC0gMV0gIT0gJy8nKQoJCQkJc3RyYnVmX2FkZGNoKCZidWZmZXIxLCAnLycpOwoJCQlsZW4xID0gYnVmZmVyMS5sZW47CgkJfQoKCQlpZiAobmFtZTIpIHsKCQkJc3RyYnVmX2FkZHN0cigmYnVmZmVyMiwgbmFtZTIpOwoJCQlpZiAoYnVmZmVyMi5sZW4gJiYgYnVmZmVyMi5idWZbYnVmZmVyMi5sZW4gLSAxXSAhPSAnLycpCgkJCQlzdHJidWZfYWRkY2goJmJ1ZmZlcjIsICcvJyk7CgkJCWxlbjIgPSBidWZmZXIyLmxlbjsKCQl9CgoJCWZvciAoaTEgPSBpMiA9IDA7ICFyZXQgJiYgKGkxIDwgcDEubnIgfHwgaTIgPCBwMi5ucik7ICkgewoJCQljb25zdCBjaGFyICpuMSwgKm4yOwoJCQlpbnQgY29tcDsKCgkJCXN0cmJ1Zl9zZXRsZW4oJmJ1ZmZlcjEsIGxlbjEpOwoJCQlzdHJidWZfc2V0bGVuKCZidWZmZXIyLCBsZW4yKTsKCgkJCWlmIChpMSA9PSBwMS5ucikKCQkJCWNvbXAgPSAxOwoJCQllbHNlIGlmIChpMiA9PSBwMi5ucikKCQkJCWNvbXAgPSAtMTsKCQkJZWxzZQoJCQkJY29tcCA9IHN0cmNtcChwMS5pdGVtc1tpMV0uc3RyaW5nLCBwMi5pdGVtc1tpMl0uc3RyaW5nKTsKCgkJCWlmIChjb21wID4gMCkKCQkJCW4xID0gTlVMTDsKCQkJZWxzZSB7CgkJCQlzdHJidWZfYWRkc3RyKCZidWZmZXIxLCBwMS5pdGVtc1tpMSsrXS5zdHJpbmcpOwoJCQkJbjEgPSBidWZmZXIxLmJ1ZjsKCQkJfQoKCQkJaWYgKGNvbXAgPCAwKQoJCQkJbjIgPSBOVUxMOwoJCQllbHNlIHsKCQkJCXN0cmJ1Zl9hZGRzdHIoJmJ1ZmZlcjIsIHAyLml0ZW1zW2kyKytdLnN0cmluZyk7CgkJCQluMiA9IGJ1ZmZlcjIuYnVmOwoJCQl9CgoJCQlyZXQgPSBxdWV1ZV9kaWZmKG8sIG4xLCBuMik7CgkJfQoJCXN0cmluZ19saXN0X2NsZWFyKCZwMSwgMCk7CgkJc3RyaW5nX2xpc3RfY2xlYXIoJnAyLCAwKTsKCQlzdHJidWZfcmVsZWFzZSgmYnVmZmVyMSk7CgkJc3RyYnVmX3JlbGVhc2UoJmJ1ZmZlcjIpOwoKCQlyZXR1cm4gcmV0OwoJfSBlbHNlIHsKCQlzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqZDEsICpkMjsKCgkJaWYgKERJRkZfT1BUX1RTVChvLCBSRVZFUlNFX0RJRkYpKSB7CgkJCXVuc2lnbmVkIHRtcDsKCQkJY29uc3QgY2hhciAqdG1wX2M7CgkJCXRtcCA9IG1vZGUxOyBtb2RlMSA9IG1vZGUyOyBtb2RlMiA9IHRtcDsKCQkJdG1wX2MgPSBuYW1lMTsgbmFtZTEgPSBuYW1lMjsgbmFtZTIgPSB0bXBfYzsKCQl9CgoJCWQxID0gbm9pbmRleF9maWxlc3BlYyhuYW1lMSwgbW9kZTEpOwoJCWQyID0gbm9pbmRleF9maWxlc3BlYyhuYW1lMiwgbW9kZTIpOwoJCWRpZmZfcXVldWUoJmRpZmZfcXVldWVkX2RpZmYsIGQxLCBkMik7CgkJcmV0dXJuIDA7Cgl9Cn0KCnZvaWQgZGlmZl9ub19pbmRleChzdHJ1Y3QgcmV2X2luZm8gKnJldnMsCgkJICAgaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LAoJCSAgIGludCBub25naXQsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJaW50IGksIHByZWZpeGxlbjsKCWludCBub19pbmRleCA9IDA7Cgl1bnNpZ25lZCBkZXByZWNhdGVkX3Nob3dfZGlmZl9xX29wdGlvbl91c2VkID0gMDsKCWNvbnN0IGNoYXIgKnBhdGhzWzJdOwoKCS8qIFdlcmUgd2UgYXNrZWQgdG8gZG8gLS1uby1pbmRleCBleHBsaWNpdGx5PyAqLwoJZm9yIChpID0gMTsgaSA8IGFyZ2M7IGkrKykgewoJCWlmICghc3RyY21wKGFyZ3ZbaV0sICItLSIpKSB7CgkJCWkrKzsKCQkJYnJlYWs7CgkJfQoJCWlmICghc3RyY21wKGFyZ3ZbaV0sICItLW5vLWluZGV4IikpCgkJCW5vX2luZGV4ID0gMTsKCQlpZiAoYXJndltpXVswXSAhPSAnLScpCgkJCWJyZWFrOwoJfQoKCWlmICghbm9faW5kZXggJiYgIW5vbmdpdCkgewoJCS8qCgkJICogSW5zaWRlIGEgZ2l0IHJlcG9zaXRvcnksIHdpdGhvdXQgLS1uby1pbmRleC4gIE9ubHkKCQkgKiB3aGVuIGEgcGF0aCBvdXRzaWRlIHRoZSByZXBvc2l0b3J5IGlzIGdpdmVuLAoJCSAqIGUuZy4gImdpdCBkaWZmIC92YXIvdG1wL1sxMl0iLCBvciAiZ2l0IGRpZmYKCQkgKiBNYWtlZmlsZSAvdmFyL3RtcC9NYWtlZmlsZSIsIGFsbG93IGl0IHRvIGJlIHVzZWQgYXMKCQkgKiBhIGNvbG91cmZ1bCAiZGlmZiIgcmVwbGFjZW1lbnQuCgkJICovCgkJaWYgKChhcmdjICE9IGkgKyAyKSB8fAoJCSAgICAocGF0aF9pbnNpZGVfcmVwbyhwcmVmaXgsIGFyZ3ZbaV0pICYmCgkJICAgICBwYXRoX2luc2lkZV9yZXBvKHByZWZpeCwgYXJndltpKzFdKSkpCgkJCXJldHVybjsKCX0KCWlmIChhcmdjICE9IGkgKyAyKSB7CgkJaWYgKCFub19pbmRleCkgewoJCQkvKgoJCQkgKiBUaGVyZSB3YXMgbm8gLS1uby1pbmRleCBhbmQgdGhlcmUgd2VyZSBub3QgdHdvCgkJCSAqIHBhdGhzLiBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSB1c2VyIGludGVuZGVkCgkJCSAqIHRvIGRvIGFuIGluc2lkZS1yZXBvc2l0b3J5IG9wZXJhdGlvbi4KCQkJICovCgkJCWZwcmludGYoc3RkZXJyLCAiTm90IGEgZ2l0IHJlcG9zaXRvcnlcbiIpOwoJCQlmcHJpbnRmKHN0ZGVyciwKCQkJCSJUbyBjb21wYXJlIHR3byBwYXRocyBvdXRzaWRlIGEgd29ya2luZyB0cmVlOlxuIik7CgkJfQoJCS8qIEdpdmUgdGhlIHVzYWdlIG1lc3NhZ2UgZm9yIG5vbi1yZXBvc2l0b3J5IHVzYWdlIGFuZCBleGl0LiAqLwoJCXVzYWdlZigiZ2l0IGRpZmYgJXMgPHBhdGg+IDxwYXRoPiIsCgkJICAgICAgIG5vX2luZGV4ID8gIi0tbm8taW5kZXgiIDogIlstLW5vLWluZGV4XSIpOwoJfQoKCWRpZmZfc2V0dXAoJnJldnMtPmRpZmZvcHQpOwoJZm9yIChpID0gMTsgaSA8IGFyZ2MgLSAyOyApIHsKCQlpbnQgajsKCQlpZiAoIXN0cmNtcChhcmd2W2ldLCAiLS1uby1pbmRleCIpKQoJCQlpKys7CgkJZWxzZSBpZiAoIXN0cmNtcChhcmd2W2ldLCAiLXEiKSkgewoJCQlkZXByZWNhdGVkX3Nob3dfZGlmZl9xX29wdGlvbl91c2VkID0gMTsKCQkJaSsrOwoJCX0KCQllbHNlIGlmICghc3RyY21wKGFyZ3ZbaV0sICItLSIpKQoJCQlpKys7CgkJZWxzZSB7CgkJCWogPSBkaWZmX29wdF9wYXJzZSgmcmV2cy0+ZGlmZm9wdCwgYXJndiArIGksIGFyZ2MgLSBpKTsKCQkJaWYgKCFqKQoJCQkJZGllKCJpbnZhbGlkIGRpZmYgb3B0aW9uL3ZhbHVlOiAlcyIsIGFyZ3ZbaV0pOwoJCQlpICs9IGo7CgkJfQoJfQoKCXByZWZpeGxlbiA9IHByZWZpeCA/IHN0cmxlbihwcmVmaXgpIDogMDsKCWZvciAoaSA9IDA7IGkgPCAyOyBpKyspIHsKCQljb25zdCBjaGFyICpwID0gYXJndlthcmdjIC0gMiArIGldOwoJCWlmICghc3RyY21wKHAsICItIikpCgkJCS8qCgkJCSAqIHN0ZGluIHNob3VsZCBiZSBzcGVsbGVkIGFzICItIjsgaWYgeW91IGhhdmUKCQkJICogcGF0aCB0aGF0IGlzICItIiwgc3BlbGwgaXQgYXMgIi4vLSIuCgkJCSAqLwoJCQlwID0gZmlsZV9mcm9tX3N0YW5kYXJkX2lucHV0OwoJCWVsc2UgaWYgKHByZWZpeGxlbikKCQkJcCA9IHhzdHJkdXAocHJlZml4X2ZpbGVuYW1lKHByZWZpeCwgcHJlZml4bGVuLCBwKSk7CgkJcGF0aHNbaV0gPSBwOwoJfQoJcmV2cy0+ZGlmZm9wdC5za2lwX3N0YXRfdW5tYXRjaCA9IDE7CglpZiAoIXJldnMtPmRpZmZvcHQub3V0cHV0X2Zvcm1hdCkKCQlyZXZzLT5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9QQVRDSDsKCglESUZGX09QVF9TRVQoJnJldnMtPmRpZmZvcHQsIE5PX0lOREVYKTsKCglyZXZzLT5tYXhfY291bnQgPSAtMjsKCWRpZmZfc2V0dXBfZG9uZSgmcmV2cy0+ZGlmZm9wdCk7CgoJaWYgKGRlcHJlY2F0ZWRfc2hvd19kaWZmX3Ffb3B0aW9uX3VzZWQpCgkJaGFuZGxlX2RlcHJlY2F0ZWRfc2hvd19kaWZmX3EoJnJldnMtPmRpZmZvcHQpOwoKCXNldHVwX2RpZmZfcGFnZXIoJnJldnMtPmRpZmZvcHQpOwoJRElGRl9PUFRfU0VUKCZyZXZzLT5kaWZmb3B0LCBFWElUX1dJVEhfU1RBVFVTKTsKCglpZiAocXVldWVfZGlmZigmcmV2cy0+ZGlmZm9wdCwgcGF0aHNbMF0sIHBhdGhzWzFdKSkKCQlleGl0KDEpOwoJZGlmZl9zZXRfbW5lbW9uaWNfcHJlZml4KCZyZXZzLT5kaWZmb3B0LCAiMS8iLCAiMi8iKTsKCWRpZmZjb3JlX3N0ZCgmcmV2cy0+ZGlmZm9wdCk7CglkaWZmX2ZsdXNoKCZyZXZzLT5kaWZmb3B0KTsKCgkvKgoJICogVGhlIHJldHVybiBjb2RlIGZvciAtLW5vLWluZGV4IGltaXRhdGVzIGRpZmYoMSk6CgkgKiAwID0gbm8gY2hhbmdlcywgMSA9IGNoYW5nZXMsIGVsc2UgZXJyb3IKCSAqLwoJZXhpdChkaWZmX3Jlc3VsdF9jb2RlKCZyZXZzLT5kaWZmb3B0LCAwKSk7Cn0K",
    "text": "/*\n * \"diff --no-index\" support\n * Copyright (c) 2007 by Johannes Schindelin\n * Copyright (c) 2008 by Junio C Hamano\n */\n\n#include \"cache.h\"\n#include \"color.h\"\n#include \"commit.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"revision.h\"\n#include \"log-tree.h\"\n#include \"builtin.h\"\n#include \"string-list.h\"\n\nstatic int read_directory(const char *path, struct string_list *list)\n{\n\tDIR *dir;\n\tstruct dirent *e;\n\n\tif (!(dir = opendir(path)))\n\t\treturn error(\"Could not open directory %s\", path);\n\n\twhile ((e = readdir(dir)))\n\t\tif (strcmp(\".\", e->d_name) && strcmp(\"..\", e->d_name))\n\t\t\tstring_list_insert(list, e->d_name);\n\n\tclosedir(dir);\n\treturn 0;\n}\n\n/*\n * This should be \"(standard input)\" or something, but it will\n * probably expose many more breakages in the way no-index code\n * is bolted onto the diff callchain.\n */\nstatic const char file_from_standard_input[] = \"-\";\n\nstatic int get_mode(const char *path, int *mode)\n{\n\tstruct stat st;\n\n\tif (!path || !strcmp(path, \"/dev/null\"))\n\t\t*mode = 0;\n#ifdef GIT_WINDOWS_NATIVE\n\telse if (!strcasecmp(path, \"nul\"))\n\t\t*mode = 0;\n#endif\n\telse if (path == file_from_standard_input)\n\t\t*mode = create_ce_mode(0666);\n\telse if (lstat(path, &st))\n\t\treturn error(\"Could not access '%s'\", path);\n\telse\n\t\t*mode = st.st_mode;\n\treturn 0;\n}\n\nstatic int populate_from_stdin(struct diff_filespec *s)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tsize_t size = 0;\n\n\tif (strbuf_read(&buf, 0, 0) < 0)\n\t\treturn error(\"error while reading from stdin %s\",\n\t\t\t\t     strerror(errno));\n\n\ts->should_munmap = 0;\n\ts->data = strbuf_detach(&buf, &size);\n\ts->size = size;\n\ts->should_free = 1;\n\ts->is_stdin = 1;\n\treturn 0;\n}\n\nstatic struct diff_filespec *noindex_filespec(const char *name, int mode)\n{\n\tstruct diff_filespec *s;\n\n\tif (!name)\n\t\tname = \"/dev/null\";\n\ts = alloc_filespec(name);\n\tfill_filespec(s, null_sha1, 0, mode);\n\tif (name == file_from_standard_input)\n\t\tpopulate_from_stdin(s);\n\treturn s;\n}\n\nstatic int queue_diff(struct diff_options *o,\n\t\t      const char *name1, const char *name2)\n{\n\tint mode1 = 0, mode2 = 0;\n\n\tif (get_mode(name1, &mode1) || get_mode(name2, &mode2))\n\t\treturn -1;\n\n\tif (mode1 && mode2 && S_ISDIR(mode1) != S_ISDIR(mode2))\n\t\treturn error(\"file/directory conflict: %s, %s\", name1, name2);\n\n\tif (S_ISDIR(mode1) || S_ISDIR(mode2)) {\n\t\tstruct strbuf buffer1 = STRBUF_INIT;\n\t\tstruct strbuf buffer2 = STRBUF_INIT;\n\t\tstruct string_list p1 = STRING_LIST_INIT_DUP;\n\t\tstruct string_list p2 = STRING_LIST_INIT_DUP;\n\t\tint i1, i2, ret = 0;\n\t\tsize_t len1 = 0, len2 = 0;\n\n\t\tif (name1 && read_directory(name1, &p1))\n\t\t\treturn -1;\n\t\tif (name2 && read_directory(name2, &p2)) {\n\t\t\tstring_list_clear(&p1, 0);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (name1) {\n\t\t\tstrbuf_addstr(&buffer1, name1);\n\t\t\tif (buffer1.len && buffer1.buf[buffer1.len - 1] != '/')\n\t\t\t\tstrbuf_addch(&buffer1, '/');\n\t\t\tlen1 = buffer1.len;\n\t\t}\n\n\t\tif (name2) {\n\t\t\tstrbuf_addstr(&buffer2, name2);\n\t\t\tif (buffer2.len && buffer2.buf[buffer2.len - 1] != '/')\n\t\t\t\tstrbuf_addch(&buffer2, '/');\n\t\t\tlen2 = buffer2.len;\n\t\t}\n\n\t\tfor (i1 = i2 = 0; !ret && (i1 < p1.nr || i2 < p2.nr); ) {\n\t\t\tconst char *n1, *n2;\n\t\t\tint comp;\n\n\t\t\tstrbuf_setlen(&buffer1, len1);\n\t\t\tstrbuf_setlen(&buffer2, len2);\n\n\t\t\tif (i1 == p1.nr)\n\t\t\t\tcomp = 1;\n\t\t\telse if (i2 == p2.nr)\n\t\t\t\tcomp = -1;\n\t\t\telse\n\t\t\t\tcomp = strcmp(p1.items[i1].string, p2.items[i2].string);\n\n\t\t\tif (comp > 0)\n\t\t\t\tn1 = NULL;\n\t\t\telse {\n\t\t\t\tstrbuf_addstr(&buffer1, p1.items[i1++].string);\n\t\t\t\tn1 = buffer1.buf;\n\t\t\t}\n\n\t\t\tif (comp < 0)\n\t\t\t\tn2 = NULL;\n\t\t\telse {\n\t\t\t\tstrbuf_addstr(&buffer2, p2.items[i2++].string);\n\t\t\t\tn2 = buffer2.buf;\n\t\t\t}\n\n\t\t\tret = queue_diff(o, n1, n2);\n\t\t}\n\t\tstring_list_clear(&p1, 0);\n\t\tstring_list_clear(&p2, 0);\n\t\tstrbuf_release(&buffer1);\n\t\tstrbuf_release(&buffer2);\n\n\t\treturn ret;\n\t} else {\n\t\tstruct diff_filespec *d1, *d2;\n\n\t\tif (DIFF_OPT_TST(o, REVERSE_DIFF)) {\n\t\t\tunsigned tmp;\n\t\t\tconst char *tmp_c;\n\t\t\ttmp = mode1; mode1 = mode2; mode2 = tmp;\n\t\t\ttmp_c = name1; name1 = name2; name2 = tmp_c;\n\t\t}\n\n\t\td1 = noindex_filespec(name1, mode1);\n\t\td2 = noindex_filespec(name2, mode2);\n\t\tdiff_queue(&diff_queued_diff, d1, d2);\n\t\treturn 0;\n\t}\n}\n\nvoid diff_no_index(struct rev_info *revs,\n\t\t   int argc, const char **argv,\n\t\t   int nongit, const char *prefix)\n{\n\tint i, prefixlen;\n\tint no_index = 0;\n\tunsigned deprecated_show_diff_q_option_used = 0;\n\tconst char *paths[2];\n\n\t/* Were we asked to do --no-index explicitly? */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"--\")) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\tif (!strcmp(argv[i], \"--no-index\"))\n\t\t\tno_index = 1;\n\t\tif (argv[i][0] != '-')\n\t\t\tbreak;\n\t}\n\n\tif (!no_index && !nongit) {\n\t\t/*\n\t\t * Inside a git repository, without --no-index.  Only\n\t\t * when a path outside the repository is given,\n\t\t * e.g. \"git diff /var/tmp/[12]\", or \"git diff\n\t\t * Makefile /var/tmp/Makefile\", allow it to be used as\n\t\t * a colourful \"diff\" replacement.\n\t\t */\n\t\tif ((argc != i + 2) ||\n\t\t    (path_inside_repo(prefix, argv[i]) &&\n\t\t     path_inside_repo(prefix, argv[i+1])))\n\t\t\treturn;\n\t}\n\tif (argc != i + 2) {\n\t\tif (!no_index) {\n\t\t\t/*\n\t\t\t * There was no --no-index and there were not two\n\t\t\t * paths. It is possible that the user intended\n\t\t\t * to do an inside-repository operation.\n\t\t\t */\n\t\t\tfprintf(stderr, \"Not a git repository\\n\");\n\t\t\tfprintf(stderr,\n\t\t\t\t\"To compare two paths outside a working tree:\\n\");\n\t\t}\n\t\t/* Give the usage message for non-repository usage and exit. */\n\t\tusagef(\"git diff %s <path> <path>\",\n\t\t       no_index ? \"--no-index\" : \"[--no-index]\");\n\t}\n\n\tdiff_setup(&revs->diffopt);\n\tfor (i = 1; i < argc - 2; ) {\n\t\tint j;\n\t\tif (!strcmp(argv[i], \"--no-index\"))\n\t\t\ti++;\n\t\telse if (!strcmp(argv[i], \"-q\")) {\n\t\t\tdeprecated_show_diff_q_option_used = 1;\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"--\"))\n\t\t\ti++;\n\t\telse {\n\t\t\tj = diff_opt_parse(&revs->diffopt, argv + i, argc - i);\n\t\t\tif (!j)\n\t\t\t\tdie(\"invalid diff option/value: %s\", argv[i]);\n\t\t\ti += j;\n\t\t}\n\t}\n\n\tprefixlen = prefix ? strlen(prefix) : 0;\n\tfor (i = 0; i < 2; i++) {\n\t\tconst char *p = argv[argc - 2 + i];\n\t\tif (!strcmp(p, \"-\"))\n\t\t\t/*\n\t\t\t * stdin should be spelled as \"-\"; if you have\n\t\t\t * path that is \"-\", spell it as \"./-\".\n\t\t\t */\n\t\t\tp = file_from_standard_input;\n\t\telse if (prefixlen)\n\t\t\tp = xstrdup(prefix_filename(prefix, prefixlen, p));\n\t\tpaths[i] = p;\n\t}\n\trevs->diffopt.skip_stat_unmatch = 1;\n\tif (!revs->diffopt.output_format)\n\t\trevs->diffopt.output_format = DIFF_FORMAT_PATCH;\n\n\tDIFF_OPT_SET(&revs->diffopt, NO_INDEX);\n\n\trevs->max_count = -2;\n\tdiff_setup_done(&revs->diffopt);\n\n\tif (deprecated_show_diff_q_option_used)\n\t\thandle_deprecated_show_diff_q(&revs->diffopt);\n\n\tsetup_diff_pager(&revs->diffopt);\n\tDIFF_OPT_SET(&revs->diffopt, EXIT_WITH_STATUS);\n\n\tif (queue_diff(&revs->diffopt, paths[0], paths[1]))\n\t\texit(1);\n\tdiff_set_mnemonic_prefix(&revs->diffopt, \"1/\", \"2/\");\n\tdiffcore_std(&revs->diffopt);\n\tdiff_flush(&revs->diffopt);\n\n\t/*\n\t * The return code for --no-index imitates diff(1):\n\t * 0 = no changes, 1 = changes, else error\n\t */\n\texit(diff_result_code(&revs->diffopt, 0));\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00a8eefde9aeb96592f5ed6455dbf5d3b16747c4",
  "sha1_ok": true,
  "size": 6957
}
