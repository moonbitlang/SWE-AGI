{
  "content": {
    "base64": "LyoKQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQwoKVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUKbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0Cmh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL29wZW4tc291cmNlL2xpY2Vuc2VzL2JzZAoqLwoKI2luY2x1ZGUgInJlYWRlci5oIgoKI2luY2x1ZGUgInN5c3RlbS5oIgojaW5jbHVkZSAiYmxvY2suaCIKI2luY2x1ZGUgImNvbnN0YW50cy5oIgojaW5jbHVkZSAiZ2VuZXJpYy5oIgojaW5jbHVkZSAiaXRlci5oIgojaW5jbHVkZSAicmVjb3JkLmgiCiNpbmNsdWRlICJyZWZ0YWJsZS1lcnJvci5oIgojaW5jbHVkZSAicmVmdGFibGUtZ2VuZXJpYy5oIgojaW5jbHVkZSAidHJlZS5oIgoKdWludDY0X3QgYmxvY2tfc291cmNlX3NpemUoc3RydWN0IHJlZnRhYmxlX2Jsb2NrX3NvdXJjZSAqc291cmNlKQp7CglyZXR1cm4gc291cmNlLT5vcHMtPnNpemUoc291cmNlLT5hcmcpOwp9CgppbnQgYmxvY2tfc291cmNlX3JlYWRfYmxvY2soc3RydWN0IHJlZnRhYmxlX2Jsb2NrX3NvdXJjZSAqc291cmNlLAoJCQkgICAgc3RydWN0IHJlZnRhYmxlX2Jsb2NrICpkZXN0LCB1aW50NjRfdCBvZmYsCgkJCSAgICB1aW50MzJfdCBzaXplKQp7CglpbnQgcmVzdWx0ID0gc291cmNlLT5vcHMtPnJlYWRfYmxvY2soc291cmNlLT5hcmcsIGRlc3QsIG9mZiwgc2l6ZSk7CglkZXN0LT5zb3VyY2UgPSAqc291cmNlOwoJcmV0dXJuIHJlc3VsdDsKfQoKdm9pZCBibG9ja19zb3VyY2VfY2xvc2Uoc3RydWN0IHJlZnRhYmxlX2Jsb2NrX3NvdXJjZSAqc291cmNlKQp7CglpZiAoIXNvdXJjZS0+b3BzKSB7CgkJcmV0dXJuOwoJfQoKCXNvdXJjZS0+b3BzLT5jbG9zZShzb3VyY2UtPmFyZyk7Cglzb3VyY2UtPm9wcyA9IE5VTEw7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyX29mZnNldHMgKgpyZWFkZXJfb2Zmc2V0c19mb3Ioc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqciwgdWludDhfdCB0eXApCnsKCXN3aXRjaCAodHlwKSB7CgljYXNlIEJMT0NLX1RZUEVfUkVGOgoJCXJldHVybiAmci0+cmVmX29mZnNldHM7CgljYXNlIEJMT0NLX1RZUEVfTE9HOgoJCXJldHVybiAmci0+bG9nX29mZnNldHM7CgljYXNlIEJMT0NLX1RZUEVfT0JKOgoJCXJldHVybiAmci0+b2JqX29mZnNldHM7Cgl9CglhYm9ydCgpOwp9CgpzdGF0aWMgaW50IHJlYWRlcl9nZXRfYmxvY2soc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqciwKCQkJICAgIHN0cnVjdCByZWZ0YWJsZV9ibG9jayAqZGVzdCwgdWludDY0X3Qgb2ZmLAoJCQkgICAgdWludDMyX3Qgc3opCnsKCWlmIChvZmYgPj0gci0+c2l6ZSkKCQlyZXR1cm4gMDsKCglpZiAob2ZmICsgc3ogPiByLT5zaXplKSB7CgkJc3ogPSByLT5zaXplIC0gb2ZmOwoJfQoKCXJldHVybiBibG9ja19zb3VyY2VfcmVhZF9ibG9jaygmci0+c291cmNlLCBkZXN0LCBvZmYsIHN6KTsKfQoKdWludDMyX3QgcmVmdGFibGVfcmVhZGVyX2hhc2hfaWQoc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqcikKewoJcmV0dXJuIHItPmhhc2hfaWQ7Cn0KCmNvbnN0IGNoYXIgKnJlYWRlcl9uYW1lKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnIpCnsKCXJldHVybiByLT5uYW1lOwp9CgpzdGF0aWMgaW50IHBhcnNlX2Zvb3RlcihzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyLCB1aW50OF90ICpmb290ZXIsCgkJCXVpbnQ4X3QgKmhlYWRlcikKewoJdWludDhfdCAqZiA9IGZvb3RlcjsKCXVpbnQ4X3QgZmlyc3RfYmxvY2tfdHlwOwoJaW50IGVyciA9IDA7Cgl1aW50MzJfdCBjb21wdXRlZF9jcmM7Cgl1aW50MzJfdCBmaWxlX2NyYzsKCglpZiAobWVtY21wKGYsICJSRUZUIiwgNCkpIHsKCQllcnIgPSBSRUZUQUJMRV9GT1JNQVRfRVJST1I7CgkJZ290byBkb25lOwoJfQoJZiArPSA0OwoKCWlmIChtZW1jbXAoZm9vdGVyLCBoZWFkZXIsIGhlYWRlcl9zaXplKHItPnZlcnNpb24pKSkgewoJCWVyciA9IFJFRlRBQkxFX0ZPUk1BVF9FUlJPUjsKCQlnb3RvIGRvbmU7Cgl9CgoJZisrOwoJci0+YmxvY2tfc2l6ZSA9IGdldF9iZTI0KGYpOwoKCWYgKz0gMzsKCXItPm1pbl91cGRhdGVfaW5kZXggPSBnZXRfYmU2NChmKTsKCWYgKz0gODsKCXItPm1heF91cGRhdGVfaW5kZXggPSBnZXRfYmU2NChmKTsKCWYgKz0gODsKCglpZiAoci0+dmVyc2lvbiA9PSAxKSB7CgkJci0+aGFzaF9pZCA9IEdJVF9TSEExX0ZPUk1BVF9JRDsKCX0gZWxzZSB7CgkJci0+aGFzaF9pZCA9IGdldF9iZTMyKGYpOwoJCXN3aXRjaCAoci0+aGFzaF9pZCkgewoJCWNhc2UgR0lUX1NIQTFfRk9STUFUX0lEOgoJCQlicmVhazsKCQljYXNlIEdJVF9TSEEyNTZfRk9STUFUX0lEOgoJCQlicmVhazsKCQlkZWZhdWx0OgoJCQllcnIgPSBSRUZUQUJMRV9GT1JNQVRfRVJST1I7CgkJCWdvdG8gZG9uZTsKCQl9CgkJZiArPSA0OwoJfQoKCXItPnJlZl9vZmZzZXRzLmluZGV4X29mZnNldCA9IGdldF9iZTY0KGYpOwoJZiArPSA4OwoKCXItPm9ial9vZmZzZXRzLm9mZnNldCA9IGdldF9iZTY0KGYpOwoJZiArPSA4OwoKCXItPm9iamVjdF9pZF9sZW4gPSByLT5vYmpfb2Zmc2V0cy5vZmZzZXQgJiAoKDEgPDwgNSkgLSAxKTsKCXItPm9ial9vZmZzZXRzLm9mZnNldCA+Pj0gNTsKCglyLT5vYmpfb2Zmc2V0cy5pbmRleF9vZmZzZXQgPSBnZXRfYmU2NChmKTsKCWYgKz0gODsKCXItPmxvZ19vZmZzZXRzLm9mZnNldCA9IGdldF9iZTY0KGYpOwoJZiArPSA4OwoJci0+bG9nX29mZnNldHMuaW5kZXhfb2Zmc2V0ID0gZ2V0X2JlNjQoZik7CglmICs9IDg7CgoJY29tcHV0ZWRfY3JjID0gY3JjMzIoMCwgZm9vdGVyLCBmIC0gZm9vdGVyKTsKCWZpbGVfY3JjID0gZ2V0X2JlMzIoZik7CglmICs9IDQ7CglpZiAoY29tcHV0ZWRfY3JjICE9IGZpbGVfY3JjKSB7CgkJZXJyID0gUkVGVEFCTEVfRk9STUFUX0VSUk9SOwoJCWdvdG8gZG9uZTsKCX0KCglmaXJzdF9ibG9ja190eXAgPSBoZWFkZXJbaGVhZGVyX3NpemUoci0+dmVyc2lvbildOwoJci0+cmVmX29mZnNldHMuaXNfcHJlc2VudCA9IChmaXJzdF9ibG9ja190eXAgPT0gQkxPQ0tfVFlQRV9SRUYpOwoJci0+cmVmX29mZnNldHMub2Zmc2V0ID0gMDsKCXItPmxvZ19vZmZzZXRzLmlzX3ByZXNlbnQgPSAoZmlyc3RfYmxvY2tfdHlwID09IEJMT0NLX1RZUEVfTE9HIHx8CgkJCQkgICAgIHItPmxvZ19vZmZzZXRzLm9mZnNldCA+IDApOwoJci0+b2JqX29mZnNldHMuaXNfcHJlc2VudCA9IHItPm9ial9vZmZzZXRzLm9mZnNldCA+IDA7CgllcnIgPSAwOwpkb25lOgoJcmV0dXJuIGVycjsKfQoKaW50IGluaXRfcmVhZGVyKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnIsIHN0cnVjdCByZWZ0YWJsZV9ibG9ja19zb3VyY2UgKnNvdXJjZSwKCQljb25zdCBjaGFyICpuYW1lKQp7CglzdHJ1Y3QgcmVmdGFibGVfYmxvY2sgZm9vdGVyID0geyBOVUxMIH07CglzdHJ1Y3QgcmVmdGFibGVfYmxvY2sgaGVhZGVyID0geyBOVUxMIH07CglpbnQgZXJyID0gMDsKCXVpbnQ2NF90IGZpbGVfc2l6ZSA9IGJsb2NrX3NvdXJjZV9zaXplKHNvdXJjZSk7CgoJLyogTmVlZCArMSB0byByZWFkIHR5cGUgb2YgZmlyc3QgYmxvY2suICovCgl1aW50MzJfdCByZWFkX3NpemUgPSBoZWFkZXJfc2l6ZSgyKSArIDE7IC8qIHJlYWQgdjIgYmVjYXVzZSBpdCdzIGxhcmdlci4gICovCgltZW1zZXQociwgMCwgc2l6ZW9mKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIpKTsKCglpZiAocmVhZF9zaXplID4gZmlsZV9zaXplKSB7CgkJZXJyID0gUkVGVEFCTEVfRk9STUFUX0VSUk9SOwoJCWdvdG8gZG9uZTsKCX0KCgllcnIgPSBibG9ja19zb3VyY2VfcmVhZF9ibG9jayhzb3VyY2UsICZoZWFkZXIsIDAsIHJlYWRfc2l6ZSk7CglpZiAoZXJyICE9IHJlYWRfc2l6ZSkgewoJCWVyciA9IFJFRlRBQkxFX0lPX0VSUk9SOwoJCWdvdG8gZG9uZTsKCX0KCglpZiAobWVtY21wKGhlYWRlci5kYXRhLCAiUkVGVCIsIDQpKSB7CgkJZXJyID0gUkVGVEFCTEVfRk9STUFUX0VSUk9SOwoJCWdvdG8gZG9uZTsKCX0KCXItPnZlcnNpb24gPSBoZWFkZXIuZGF0YVs0XTsKCWlmIChyLT52ZXJzaW9uICE9IDEgJiYgci0+dmVyc2lvbiAhPSAyKSB7CgkJZXJyID0gUkVGVEFCTEVfRk9STUFUX0VSUk9SOwoJCWdvdG8gZG9uZTsKCX0KCglyLT5zaXplID0gZmlsZV9zaXplIC0gZm9vdGVyX3NpemUoci0+dmVyc2lvbik7CglyLT5zb3VyY2UgPSAqc291cmNlOwoJci0+bmFtZSA9IHhzdHJkdXAobmFtZSk7CglyLT5oYXNoX2lkID0gMDsKCgllcnIgPSBibG9ja19zb3VyY2VfcmVhZF9ibG9jayhzb3VyY2UsICZmb290ZXIsIHItPnNpemUsCgkJCQkgICAgICBmb290ZXJfc2l6ZShyLT52ZXJzaW9uKSk7CglpZiAoZXJyICE9IGZvb3Rlcl9zaXplKHItPnZlcnNpb24pKSB7CgkJZXJyID0gUkVGVEFCTEVfSU9fRVJST1I7CgkJZ290byBkb25lOwoJfQoKCWVyciA9IHBhcnNlX2Zvb3RlcihyLCBmb290ZXIuZGF0YSwgaGVhZGVyLmRhdGEpOwpkb25lOgoJcmVmdGFibGVfYmxvY2tfZG9uZSgmZm9vdGVyKTsKCXJlZnRhYmxlX2Jsb2NrX2RvbmUoJmhlYWRlcik7CglyZXR1cm4gZXJyOwp9CgpzdHJ1Y3QgdGFibGVfaXRlciB7CglzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyOwoJdWludDhfdCB0eXA7Cgl1aW50NjRfdCBibG9ja19vZmY7CglzdHJ1Y3QgYmxvY2tfaXRlciBiaTsKCWludCBpc19maW5pc2hlZDsKfTsKI2RlZmluZSBUQUJMRV9JVEVSX0lOSVQgICAgICAgICAgICAgICAgICAgICAgICAgIFwKCXsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAoJCS5iaSA9IHsubGFzdF9rZXkgPSBTVFJCVUZfSU5JVCB9IFwKCX0KCnN0YXRpYyB2b2lkIHRhYmxlX2l0ZXJfY29weV9mcm9tKHN0cnVjdCB0YWJsZV9pdGVyICpkZXN0LAoJCQkJIHN0cnVjdCB0YWJsZV9pdGVyICpzcmMpCnsKCWRlc3QtPnIgPSBzcmMtPnI7CglkZXN0LT50eXAgPSBzcmMtPnR5cDsKCWRlc3QtPmJsb2NrX29mZiA9IHNyYy0+YmxvY2tfb2ZmOwoJZGVzdC0+aXNfZmluaXNoZWQgPSBzcmMtPmlzX2ZpbmlzaGVkOwoJYmxvY2tfaXRlcl9jb3B5X2Zyb20oJmRlc3QtPmJpLCAmc3JjLT5iaSk7Cn0KCnN0YXRpYyBpbnQgdGFibGVfaXRlcl9uZXh0X2luX2Jsb2NrKHN0cnVjdCB0YWJsZV9pdGVyICp0aSwKCQkJCSAgICBzdHJ1Y3QgcmVmdGFibGVfcmVjb3JkICpyZWMpCnsKCWludCByZXMgPSBibG9ja19pdGVyX25leHQoJnRpLT5iaSwgcmVjKTsKCWlmIChyZXMgPT0gMCAmJiByZWZ0YWJsZV9yZWNvcmRfdHlwZShyZWMpID09IEJMT0NLX1RZUEVfUkVGKSB7CgkJcmVjLT51LnJlZi51cGRhdGVfaW5kZXggKz0gdGktPnItPm1pbl91cGRhdGVfaW5kZXg7Cgl9CgoJcmV0dXJuIHJlczsKfQoKc3RhdGljIHZvaWQgdGFibGVfaXRlcl9ibG9ja19kb25lKHN0cnVjdCB0YWJsZV9pdGVyICp0aSkKewoJaWYgKCF0aS0+YmkuYnIpIHsKCQlyZXR1cm47Cgl9CglyZWZ0YWJsZV9ibG9ja19kb25lKCZ0aS0+YmkuYnItPmJsb2NrKTsKCUZSRUVfQU5EX05VTEwodGktPmJpLmJyKTsKCgl0aS0+YmkubGFzdF9rZXkubGVuID0gMDsKCXRpLT5iaS5uZXh0X29mZiA9IDA7Cn0KCnN0YXRpYyBpbnQzMl90IGV4dHJhY3RfYmxvY2tfc2l6ZSh1aW50OF90ICpkYXRhLCB1aW50OF90ICp0eXAsIHVpbnQ2NF90IG9mZiwKCQkJCSAgaW50IHZlcnNpb24pCnsKCWludDMyX3QgcmVzdWx0ID0gMDsKCglpZiAob2ZmID09IDApIHsKCQlkYXRhICs9IGhlYWRlcl9zaXplKHZlcnNpb24pOwoJfQoKCSp0eXAgPSBkYXRhWzBdOwoJaWYgKHJlZnRhYmxlX2lzX2Jsb2NrX3R5cGUoKnR5cCkpIHsKCQlyZXN1bHQgPSBnZXRfYmUyNChkYXRhICsgMSk7Cgl9CglyZXR1cm4gcmVzdWx0Owp9CgppbnQgcmVhZGVyX2luaXRfYmxvY2tfcmVhZGVyKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnIsIHN0cnVjdCBibG9ja19yZWFkZXIgKmJyLAoJCQkgICAgIHVpbnQ2NF90IG5leHRfb2ZmLCB1aW50OF90IHdhbnRfdHlwKQp7CglpbnQzMl90IGd1ZXNzX2Jsb2NrX3NpemUgPSByLT5ibG9ja19zaXplID8gci0+YmxvY2tfc2l6ZSA6CgkJCQkJCQkgREVGQVVMVF9CTE9DS19TSVpFOwoJc3RydWN0IHJlZnRhYmxlX2Jsb2NrIGJsb2NrID0geyBOVUxMIH07Cgl1aW50OF90IGJsb2NrX3R5cCA9IDA7CglpbnQgZXJyID0gMDsKCXVpbnQzMl90IGhlYWRlcl9vZmYgPSBuZXh0X29mZiA/IDAgOiBoZWFkZXJfc2l6ZShyLT52ZXJzaW9uKTsKCWludDMyX3QgYmxvY2tfc2l6ZSA9IDA7CgoJaWYgKG5leHRfb2ZmID49IHItPnNpemUpCgkJcmV0dXJuIDE7CgoJZXJyID0gcmVhZGVyX2dldF9ibG9jayhyLCAmYmxvY2ssIG5leHRfb2ZmLCBndWVzc19ibG9ja19zaXplKTsKCWlmIChlcnIgPCAwKQoJCWdvdG8gZG9uZTsKCglibG9ja19zaXplID0gZXh0cmFjdF9ibG9ja19zaXplKGJsb2NrLmRhdGEsICZibG9ja190eXAsIG5leHRfb2ZmLAoJCQkJCXItPnZlcnNpb24pOwoJaWYgKGJsb2NrX3NpemUgPCAwKSB7CgkJZXJyID0gYmxvY2tfc2l6ZTsKCQlnb3RvIGRvbmU7Cgl9CglpZiAod2FudF90eXAgIT0gQkxPQ0tfVFlQRV9BTlkgJiYgYmxvY2tfdHlwICE9IHdhbnRfdHlwKSB7CgkJZXJyID0gMTsKCQlnb3RvIGRvbmU7Cgl9CgoJaWYgKGJsb2NrX3NpemUgPiBndWVzc19ibG9ja19zaXplKSB7CgkJcmVmdGFibGVfYmxvY2tfZG9uZSgmYmxvY2spOwoJCWVyciA9IHJlYWRlcl9nZXRfYmxvY2sociwgJmJsb2NrLCBuZXh0X29mZiwgYmxvY2tfc2l6ZSk7CgkJaWYgKGVyciA8IDApIHsKCQkJZ290byBkb25lOwoJCX0KCX0KCgllcnIgPSBibG9ja19yZWFkZXJfaW5pdChiciwgJmJsb2NrLCBoZWFkZXJfb2ZmLCByLT5ibG9ja19zaXplLAoJCQkJaGFzaF9zaXplKHItPmhhc2hfaWQpKTsKZG9uZToKCXJlZnRhYmxlX2Jsb2NrX2RvbmUoJmJsb2NrKTsKCglyZXR1cm4gZXJyOwp9CgpzdGF0aWMgaW50IHRhYmxlX2l0ZXJfbmV4dF9ibG9jayhzdHJ1Y3QgdGFibGVfaXRlciAqZGVzdCwKCQkJCSBzdHJ1Y3QgdGFibGVfaXRlciAqc3JjKQp7Cgl1aW50NjRfdCBuZXh0X2Jsb2NrX29mZiA9IHNyYy0+YmxvY2tfb2ZmICsgc3JjLT5iaS5ici0+ZnVsbF9ibG9ja19zaXplOwoJc3RydWN0IGJsb2NrX3JlYWRlciBiciA9IHsgMCB9OwoJaW50IGVyciA9IDA7CgoJZGVzdC0+ciA9IHNyYy0+cjsKCWRlc3QtPnR5cCA9IHNyYy0+dHlwOwoJZGVzdC0+YmxvY2tfb2ZmID0gbmV4dF9ibG9ja19vZmY7CgoJZXJyID0gcmVhZGVyX2luaXRfYmxvY2tfcmVhZGVyKHNyYy0+ciwgJmJyLCBuZXh0X2Jsb2NrX29mZiwgc3JjLT50eXApOwoJaWYgKGVyciA+IDApIHsKCQlkZXN0LT5pc19maW5pc2hlZCA9IDE7CgkJcmV0dXJuIDE7Cgl9CglpZiAoZXJyICE9IDApCgkJcmV0dXJuIGVycjsKCWVsc2UgewoJCXN0cnVjdCBibG9ja19yZWFkZXIgKmJycCA9CgkJCXJlZnRhYmxlX21hbGxvYyhzaXplb2Yoc3RydWN0IGJsb2NrX3JlYWRlcikpOwoJCSpicnAgPSBicjsKCgkJZGVzdC0+aXNfZmluaXNoZWQgPSAwOwoJCWJsb2NrX3JlYWRlcl9zdGFydChicnAsICZkZXN0LT5iaSk7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCB0YWJsZV9pdGVyX25leHQoc3RydWN0IHRhYmxlX2l0ZXIgKnRpLCBzdHJ1Y3QgcmVmdGFibGVfcmVjb3JkICpyZWMpCnsKCWlmIChyZWZ0YWJsZV9yZWNvcmRfdHlwZShyZWMpICE9IHRpLT50eXApCgkJcmV0dXJuIFJFRlRBQkxFX0FQSV9FUlJPUjsKCgl3aGlsZSAoMSkgewoJCXN0cnVjdCB0YWJsZV9pdGVyIG5leHQgPSBUQUJMRV9JVEVSX0lOSVQ7CgkJaW50IGVyciA9IDA7CgkJaWYgKHRpLT5pc19maW5pc2hlZCkgewoJCQlyZXR1cm4gMTsKCQl9CgoJCWVyciA9IHRhYmxlX2l0ZXJfbmV4dF9pbl9ibG9jayh0aSwgcmVjKTsKCQlpZiAoZXJyIDw9IDApIHsKCQkJcmV0dXJuIGVycjsKCQl9CgoJCWVyciA9IHRhYmxlX2l0ZXJfbmV4dF9ibG9jaygmbmV4dCwgdGkpOwoJCWlmIChlcnIgIT0gMCkgewoJCQl0aS0+aXNfZmluaXNoZWQgPSAxOwoJCX0KCQl0YWJsZV9pdGVyX2Jsb2NrX2RvbmUodGkpOwoJCWlmIChlcnIgIT0gMCkgewoJCQlyZXR1cm4gZXJyOwoJCX0KCQl0YWJsZV9pdGVyX2NvcHlfZnJvbSh0aSwgJm5leHQpOwoJCWJsb2NrX2l0ZXJfY2xvc2UoJm5leHQuYmkpOwoJfQp9CgpzdGF0aWMgaW50IHRhYmxlX2l0ZXJfbmV4dF92b2lkKHZvaWQgKnRpLCBzdHJ1Y3QgcmVmdGFibGVfcmVjb3JkICpyZWMpCnsKCXJldHVybiB0YWJsZV9pdGVyX25leHQodGksIHJlYyk7Cn0KCnN0YXRpYyB2b2lkIHRhYmxlX2l0ZXJfY2xvc2Uodm9pZCAqcCkKewoJc3RydWN0IHRhYmxlX2l0ZXIgKnRpID0gcDsKCXRhYmxlX2l0ZXJfYmxvY2tfZG9uZSh0aSk7CglibG9ja19pdGVyX2Nsb3NlKCZ0aS0+YmkpOwp9CgpzdGF0aWMgc3RydWN0IHJlZnRhYmxlX2l0ZXJhdG9yX3Z0YWJsZSB0YWJsZV9pdGVyX3Z0YWJsZSA9IHsKCS5uZXh0ID0gJnRhYmxlX2l0ZXJfbmV4dF92b2lkLAoJLmNsb3NlID0gJnRhYmxlX2l0ZXJfY2xvc2UsCn07CgpzdGF0aWMgdm9pZCBpdGVyYXRvcl9mcm9tX3RhYmxlX2l0ZXIoc3RydWN0IHJlZnRhYmxlX2l0ZXJhdG9yICppdCwKCQkJCSAgICAgc3RydWN0IHRhYmxlX2l0ZXIgKnRpKQp7Cglhc3NlcnQoIWl0LT5vcHMpOwoJaXQtPml0ZXJfYXJnID0gdGk7CglpdC0+b3BzID0gJnRhYmxlX2l0ZXJfdnRhYmxlOwp9CgpzdGF0aWMgaW50IHJlYWRlcl90YWJsZV9pdGVyX2F0KHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnIsCgkJCQlzdHJ1Y3QgdGFibGVfaXRlciAqdGksIHVpbnQ2NF90IG9mZiwKCQkJCXVpbnQ4X3QgdHlwKQp7CglzdHJ1Y3QgYmxvY2tfcmVhZGVyIGJyID0geyAwIH07CglzdHJ1Y3QgYmxvY2tfcmVhZGVyICpicnAgPSBOVUxMOwoKCWludCBlcnIgPSByZWFkZXJfaW5pdF9ibG9ja19yZWFkZXIociwgJmJyLCBvZmYsIHR5cCk7CglpZiAoZXJyICE9IDApCgkJcmV0dXJuIGVycjsKCglicnAgPSByZWZ0YWJsZV9tYWxsb2Moc2l6ZW9mKHN0cnVjdCBibG9ja19yZWFkZXIpKTsKCSpicnAgPSBicjsKCXRpLT5yID0gcjsKCXRpLT50eXAgPSBibG9ja19yZWFkZXJfdHlwZShicnApOwoJdGktPmJsb2NrX29mZiA9IG9mZjsKCWJsb2NrX3JlYWRlcl9zdGFydChicnAsICZ0aS0+YmkpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgcmVhZGVyX3N0YXJ0KHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnIsIHN0cnVjdCB0YWJsZV9pdGVyICp0aSwKCQkJdWludDhfdCB0eXAsIGludCBpbmRleCkKewoJc3RydWN0IHJlZnRhYmxlX3JlYWRlcl9vZmZzZXRzICpvZmZzID0gcmVhZGVyX29mZnNldHNfZm9yKHIsIHR5cCk7Cgl1aW50NjRfdCBvZmYgPSBvZmZzLT5vZmZzZXQ7CglpZiAoaW5kZXgpIHsKCQlvZmYgPSBvZmZzLT5pbmRleF9vZmZzZXQ7CgkJaWYgKG9mZiA9PSAwKSB7CgkJCXJldHVybiAxOwoJCX0KCQl0eXAgPSBCTE9DS19UWVBFX0lOREVYOwoJfQoKCXJldHVybiByZWFkZXJfdGFibGVfaXRlcl9hdChyLCB0aSwgb2ZmLCB0eXApOwp9CgpzdGF0aWMgaW50IHJlYWRlcl9zZWVrX2xpbmVhcihzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyLCBzdHJ1Y3QgdGFibGVfaXRlciAqdGksCgkJCSAgICAgIHN0cnVjdCByZWZ0YWJsZV9yZWNvcmQgKndhbnQpCnsKCXN0cnVjdCByZWZ0YWJsZV9yZWNvcmQgcmVjID0KCQlyZWZ0YWJsZV9uZXdfcmVjb3JkKHJlZnRhYmxlX3JlY29yZF90eXBlKHdhbnQpKTsKCXN0cnVjdCBzdHJidWYgd2FudF9rZXkgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgZ290X2tleSA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHRhYmxlX2l0ZXIgbmV4dCA9IFRBQkxFX0lURVJfSU5JVDsKCWludCBlcnIgPSAtMTsKCglyZWZ0YWJsZV9yZWNvcmRfa2V5KHdhbnQsICZ3YW50X2tleSk7CgoJd2hpbGUgKDEpIHsKCQllcnIgPSB0YWJsZV9pdGVyX25leHRfYmxvY2soJm5leHQsIHRpKTsKCQlpZiAoZXJyIDwgMCkKCQkJZ290byBkb25lOwoKCQlpZiAoZXJyID4gMCkgewoJCQlicmVhazsKCQl9CgoJCWVyciA9IGJsb2NrX3JlYWRlcl9maXJzdF9rZXkobmV4dC5iaS5iciwgJmdvdF9rZXkpOwoJCWlmIChlcnIgPCAwKQoJCQlnb3RvIGRvbmU7CgoJCWlmIChzdHJidWZfY21wKCZnb3Rfa2V5LCAmd2FudF9rZXkpID4gMCkgewoJCQl0YWJsZV9pdGVyX2Jsb2NrX2RvbmUoJm5leHQpOwoJCQlicmVhazsKCQl9CgoJCXRhYmxlX2l0ZXJfYmxvY2tfZG9uZSh0aSk7CgkJdGFibGVfaXRlcl9jb3B5X2Zyb20odGksICZuZXh0KTsKCX0KCgllcnIgPSBibG9ja19pdGVyX3NlZWsoJnRpLT5iaSwgJndhbnRfa2V5KTsKCWlmIChlcnIgPCAwKQoJCWdvdG8gZG9uZTsKCWVyciA9IDA7Cgpkb25lOgoJYmxvY2tfaXRlcl9jbG9zZSgmbmV4dC5iaSk7CglyZWZ0YWJsZV9yZWNvcmRfcmVsZWFzZSgmcmVjKTsKCXN0cmJ1Zl9yZWxlYXNlKCZ3YW50X2tleSk7CglzdHJidWZfcmVsZWFzZSgmZ290X2tleSk7CglyZXR1cm4gZXJyOwp9CgpzdGF0aWMgaW50IHJlYWRlcl9zZWVrX2luZGV4ZWQoc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqciwKCQkJICAgICAgIHN0cnVjdCByZWZ0YWJsZV9pdGVyYXRvciAqaXQsCgkJCSAgICAgICBzdHJ1Y3QgcmVmdGFibGVfcmVjb3JkICpyZWMpCnsKCXN0cnVjdCByZWZ0YWJsZV9yZWNvcmQgd2FudF9pbmRleCA9IHsKCQkudHlwZSA9IEJMT0NLX1RZUEVfSU5ERVgsIC51LmlkeCA9IHsgLmxhc3Rfa2V5ID0gU1RSQlVGX0lOSVQgfQoJfTsKCXN0cnVjdCByZWZ0YWJsZV9yZWNvcmQgaW5kZXhfcmVzdWx0ID0gewoJCS50eXBlID0gQkxPQ0tfVFlQRV9JTkRFWCwKCQkudS5pZHggPSB7IC5sYXN0X2tleSA9IFNUUkJVRl9JTklUIH0sCgl9OwoJc3RydWN0IHRhYmxlX2l0ZXIgaW5kZXhfaXRlciA9IFRBQkxFX0lURVJfSU5JVDsKCXN0cnVjdCB0YWJsZV9pdGVyIG5leHQgPSBUQUJMRV9JVEVSX0lOSVQ7CglpbnQgZXJyID0gMDsKCglyZWZ0YWJsZV9yZWNvcmRfa2V5KHJlYywgJndhbnRfaW5kZXgudS5pZHgubGFzdF9rZXkpOwoJZXJyID0gcmVhZGVyX3N0YXJ0KHIsICZpbmRleF9pdGVyLCByZWZ0YWJsZV9yZWNvcmRfdHlwZShyZWMpLCAxKTsKCWlmIChlcnIgPCAwKQoJCWdvdG8gZG9uZTsKCgllcnIgPSByZWFkZXJfc2Vla19saW5lYXIociwgJmluZGV4X2l0ZXIsICZ3YW50X2luZGV4KTsKCXdoaWxlICgxKSB7CgkJZXJyID0gdGFibGVfaXRlcl9uZXh0KCZpbmRleF9pdGVyLCAmaW5kZXhfcmVzdWx0KTsKCQl0YWJsZV9pdGVyX2Jsb2NrX2RvbmUoJmluZGV4X2l0ZXIpOwoJCWlmIChlcnIgIT0gMCkKCQkJZ290byBkb25lOwoKCQllcnIgPSByZWFkZXJfdGFibGVfaXRlcl9hdChyLCAmbmV4dCwgaW5kZXhfcmVzdWx0LnUuaWR4Lm9mZnNldCwKCQkJCQkgICAwKTsKCQlpZiAoZXJyICE9IDApCgkJCWdvdG8gZG9uZTsKCgkJZXJyID0gYmxvY2tfaXRlcl9zZWVrKCZuZXh0LmJpLCAmd2FudF9pbmRleC51LmlkeC5sYXN0X2tleSk7CgkJaWYgKGVyciA8IDApCgkJCWdvdG8gZG9uZTsKCgkJaWYgKG5leHQudHlwID09IHJlZnRhYmxlX3JlY29yZF90eXBlKHJlYykpIHsKCQkJZXJyID0gMDsKCQkJYnJlYWs7CgkJfQoKCQlpZiAobmV4dC50eXAgIT0gQkxPQ0tfVFlQRV9JTkRFWCkgewoJCQllcnIgPSBSRUZUQUJMRV9GT1JNQVRfRVJST1I7CgkJCWJyZWFrOwoJCX0KCgkJdGFibGVfaXRlcl9jb3B5X2Zyb20oJmluZGV4X2l0ZXIsICZuZXh0KTsKCX0KCglpZiAoZXJyID09IDApIHsKCQlzdHJ1Y3QgdGFibGVfaXRlciBlbXB0eSA9IFRBQkxFX0lURVJfSU5JVDsKCQlzdHJ1Y3QgdGFibGVfaXRlciAqbWFsbG9jZWQgPQoJCQlyZWZ0YWJsZV9jYWxsb2Moc2l6ZW9mKHN0cnVjdCB0YWJsZV9pdGVyKSk7CgkJKm1hbGxvY2VkID0gZW1wdHk7CgkJdGFibGVfaXRlcl9jb3B5X2Zyb20obWFsbG9jZWQsICZuZXh0KTsKCQlpdGVyYXRvcl9mcm9tX3RhYmxlX2l0ZXIoaXQsIG1hbGxvY2VkKTsKCX0KZG9uZToKCWJsb2NrX2l0ZXJfY2xvc2UoJm5leHQuYmkpOwoJdGFibGVfaXRlcl9jbG9zZSgmaW5kZXhfaXRlcik7CglyZWZ0YWJsZV9yZWNvcmRfcmVsZWFzZSgmd2FudF9pbmRleCk7CglyZWZ0YWJsZV9yZWNvcmRfcmVsZWFzZSgmaW5kZXhfcmVzdWx0KTsKCXJldHVybiBlcnI7Cn0KCnN0YXRpYyBpbnQgcmVhZGVyX3NlZWtfaW50ZXJuYWwoc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqciwKCQkJCXN0cnVjdCByZWZ0YWJsZV9pdGVyYXRvciAqaXQsCgkJCQlzdHJ1Y3QgcmVmdGFibGVfcmVjb3JkICpyZWMpCnsKCXN0cnVjdCByZWZ0YWJsZV9yZWFkZXJfb2Zmc2V0cyAqb2ZmcyA9CgkJcmVhZGVyX29mZnNldHNfZm9yKHIsIHJlZnRhYmxlX3JlY29yZF90eXBlKHJlYykpOwoJdWludDY0X3QgaWR4ID0gb2Zmcy0+aW5kZXhfb2Zmc2V0OwoJc3RydWN0IHRhYmxlX2l0ZXIgdGkgPSBUQUJMRV9JVEVSX0lOSVQ7CglpbnQgZXJyID0gMDsKCWlmIChpZHggPiAwKQoJCXJldHVybiByZWFkZXJfc2Vla19pbmRleGVkKHIsIGl0LCByZWMpOwoKCWVyciA9IHJlYWRlcl9zdGFydChyLCAmdGksIHJlZnRhYmxlX3JlY29yZF90eXBlKHJlYyksIDApOwoJaWYgKGVyciA8IDApCgkJcmV0dXJuIGVycjsKCWVyciA9IHJlYWRlcl9zZWVrX2xpbmVhcihyLCAmdGksIHJlYyk7CglpZiAoZXJyIDwgMCkKCQlyZXR1cm4gZXJyOwoJZWxzZSB7CgkJc3RydWN0IHRhYmxlX2l0ZXIgKnAgPQoJCQlyZWZ0YWJsZV9tYWxsb2Moc2l6ZW9mKHN0cnVjdCB0YWJsZV9pdGVyKSk7CgkJKnAgPSB0aTsKCQlpdGVyYXRvcl9mcm9tX3RhYmxlX2l0ZXIoaXQsIHApOwoJfQoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHJlYWRlcl9zZWVrKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnIsIHN0cnVjdCByZWZ0YWJsZV9pdGVyYXRvciAqaXQsCgkJICAgICAgIHN0cnVjdCByZWZ0YWJsZV9yZWNvcmQgKnJlYykKewoJdWludDhfdCB0eXAgPSByZWZ0YWJsZV9yZWNvcmRfdHlwZShyZWMpOwoKCXN0cnVjdCByZWZ0YWJsZV9yZWFkZXJfb2Zmc2V0cyAqb2ZmcyA9IHJlYWRlcl9vZmZzZXRzX2ZvcihyLCB0eXApOwoJaWYgKCFvZmZzLT5pc19wcmVzZW50KSB7CgkJaXRlcmF0b3Jfc2V0X2VtcHR5KGl0KTsKCQlyZXR1cm4gMDsKCX0KCglyZXR1cm4gcmVhZGVyX3NlZWtfaW50ZXJuYWwociwgaXQsIHJlYyk7Cn0KCmludCByZWZ0YWJsZV9yZWFkZXJfc2Vla19yZWYoc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqciwKCQkJICAgICBzdHJ1Y3QgcmVmdGFibGVfaXRlcmF0b3IgKml0LCBjb25zdCBjaGFyICpuYW1lKQp7CglzdHJ1Y3QgcmVmdGFibGVfcmVjb3JkIHJlYyA9IHsKCQkudHlwZSA9IEJMT0NLX1RZUEVfUkVGLAoJCS51LnJlZiA9IHsKCQkJLnJlZm5hbWUgPSAoY2hhciAqKW5hbWUsCgkJfSwKCX07CglyZXR1cm4gcmVhZGVyX3NlZWsociwgaXQsICZyZWMpOwp9CgppbnQgcmVmdGFibGVfcmVhZGVyX3NlZWtfbG9nX2F0KHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnIsCgkJCQlzdHJ1Y3QgcmVmdGFibGVfaXRlcmF0b3IgKml0LCBjb25zdCBjaGFyICpuYW1lLAoJCQkJdWludDY0X3QgdXBkYXRlX2luZGV4KQp7CglzdHJ1Y3QgcmVmdGFibGVfcmVjb3JkIHJlYyA9IHsgLnR5cGUgPSBCTE9DS19UWVBFX0xPRywKCQkJCSAgICAgICAudS5sb2cgPSB7CgkJCQkJICAgICAgIC5yZWZuYW1lID0gKGNoYXIgKiluYW1lLAoJCQkJCSAgICAgICAudXBkYXRlX2luZGV4ID0gdXBkYXRlX2luZGV4LAoJCQkJICAgICAgIH0gfTsKCXJldHVybiByZWFkZXJfc2VlayhyLCBpdCwgJnJlYyk7Cn0KCmludCByZWZ0YWJsZV9yZWFkZXJfc2Vla19sb2coc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqciwKCQkJICAgICBzdHJ1Y3QgcmVmdGFibGVfaXRlcmF0b3IgKml0LCBjb25zdCBjaGFyICpuYW1lKQp7Cgl1aW50NjRfdCBtYXggPSB+KCh1aW50NjRfdCkwKTsKCXJldHVybiByZWZ0YWJsZV9yZWFkZXJfc2Vla19sb2dfYXQociwgaXQsIG5hbWUsIG1heCk7Cn0KCnZvaWQgcmVhZGVyX2Nsb3NlKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnIpCnsKCWJsb2NrX3NvdXJjZV9jbG9zZSgmci0+c291cmNlKTsKCUZSRUVfQU5EX05VTEwoci0+bmFtZSk7Cn0KCmludCByZWZ0YWJsZV9uZXdfcmVhZGVyKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKipwLAoJCQlzdHJ1Y3QgcmVmdGFibGVfYmxvY2tfc291cmNlICpzcmMsIGNoYXIgY29uc3QgKm5hbWUpCnsKCXN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnJkID0KCQlyZWZ0YWJsZV9jYWxsb2Moc2l6ZW9mKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIpKTsKCWludCBlcnIgPSBpbml0X3JlYWRlcihyZCwgc3JjLCBuYW1lKTsKCWlmIChlcnIgPT0gMCkgewoJCSpwID0gcmQ7Cgl9IGVsc2UgewoJCWJsb2NrX3NvdXJjZV9jbG9zZShzcmMpOwoJCXJlZnRhYmxlX2ZyZWUocmQpOwoJfQoJcmV0dXJuIGVycjsKfQoKdm9pZCByZWZ0YWJsZV9yZWFkZXJfZnJlZShzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyKQp7CglpZiAoIXIpCgkJcmV0dXJuOwoJcmVhZGVyX2Nsb3NlKHIpOwoJcmVmdGFibGVfZnJlZShyKTsKfQoKc3RhdGljIGludCByZWZ0YWJsZV9yZWFkZXJfcmVmc19mb3JfaW5kZXhlZChzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyLAoJCQkJCSAgICBzdHJ1Y3QgcmVmdGFibGVfaXRlcmF0b3IgKml0LAoJCQkJCSAgICB1aW50OF90ICpvaWQpCnsKCXN0cnVjdCByZWZ0YWJsZV9yZWNvcmQgd2FudCA9IHsKCQkudHlwZSA9IEJMT0NLX1RZUEVfT0JKLAoJCS51Lm9iaiA9IHsKCQkJLmhhc2hfcHJlZml4ID0gb2lkLAoJCQkuaGFzaF9wcmVmaXhfbGVuID0gci0+b2JqZWN0X2lkX2xlbiwKCQl9LAoJfTsKCXN0cnVjdCByZWZ0YWJsZV9pdGVyYXRvciBvaXQgPSB7IE5VTEwgfTsKCXN0cnVjdCByZWZ0YWJsZV9yZWNvcmQgZ290ID0gewoJCS50eXBlID0gQkxPQ0tfVFlQRV9PQkosCgkJLnUub2JqID0geyAwIH0sCgl9OwoJaW50IGVyciA9IDA7CglzdHJ1Y3QgaW5kZXhlZF90YWJsZV9yZWZfaXRlciAqaXRyID0gTlVMTDsKCgkvKiBMb29rIHRocm91Z2ggdGhlIHJldmVyc2UgaW5kZXguICovCgllcnIgPSByZWFkZXJfc2VlayhyLCAmb2l0LCAmd2FudCk7CglpZiAoZXJyICE9IDApCgkJZ290byBkb25lOwoKCS8qIHJlYWQgb3V0IHRoZSByZWZ0YWJsZV9vYmpfcmVjb3JkICovCgllcnIgPSBpdGVyYXRvcl9uZXh0KCZvaXQsICZnb3QpOwoJaWYgKGVyciA8IDApCgkJZ290byBkb25lOwoKCWlmIChlcnIgPiAwIHx8IG1lbWNtcCh3YW50LnUub2JqLmhhc2hfcHJlZml4LCBnb3QudS5vYmouaGFzaF9wcmVmaXgsCgkJCSAgICAgIHItPm9iamVjdF9pZF9sZW4pKSB7CgkJLyogZGlkbid0IGZpbmQgaXQ7IHJldHVybiBlbXB0eSBpdGVyYXRvciAqLwoJCWl0ZXJhdG9yX3NldF9lbXB0eShpdCk7CgkJZXJyID0gMDsKCQlnb3RvIGRvbmU7Cgl9CgoJZXJyID0gbmV3X2luZGV4ZWRfdGFibGVfcmVmX2l0ZXIoJml0ciwgciwgb2lkLCBoYXNoX3NpemUoci0+aGFzaF9pZCksCgkJCQkJIGdvdC51Lm9iai5vZmZzZXRzLAoJCQkJCSBnb3QudS5vYmoub2Zmc2V0X2xlbik7CglpZiAoZXJyIDwgMCkKCQlnb3RvIGRvbmU7Cglnb3QudS5vYmoub2Zmc2V0cyA9IE5VTEw7CglpdGVyYXRvcl9mcm9tX2luZGV4ZWRfdGFibGVfcmVmX2l0ZXIoaXQsIGl0cik7Cgpkb25lOgoJcmVmdGFibGVfaXRlcmF0b3JfZGVzdHJveSgmb2l0KTsKCXJlZnRhYmxlX3JlY29yZF9yZWxlYXNlKCZnb3QpOwoJcmV0dXJuIGVycjsKfQoKc3RhdGljIGludCByZWZ0YWJsZV9yZWFkZXJfcmVmc19mb3JfdW5pbmRleGVkKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnIsCgkJCQkJICAgICAgc3RydWN0IHJlZnRhYmxlX2l0ZXJhdG9yICppdCwKCQkJCQkgICAgICB1aW50OF90ICpvaWQpCnsKCXN0cnVjdCB0YWJsZV9pdGVyIHRpX2VtcHR5ID0gVEFCTEVfSVRFUl9JTklUOwoJc3RydWN0IHRhYmxlX2l0ZXIgKnRpID0gcmVmdGFibGVfY2FsbG9jKHNpemVvZihzdHJ1Y3QgdGFibGVfaXRlcikpOwoJc3RydWN0IGZpbHRlcmluZ19yZWZfaXRlcmF0b3IgKmZpbHRlciA9IE5VTEw7CglzdHJ1Y3QgZmlsdGVyaW5nX3JlZl9pdGVyYXRvciBlbXB0eSA9IEZJTFRFUklOR19SRUZfSVRFUkFUT1JfSU5JVDsKCWludCBvaWRfbGVuID0gaGFzaF9zaXplKHItPmhhc2hfaWQpOwoJaW50IGVycjsKCgkqdGkgPSB0aV9lbXB0eTsKCWVyciA9IHJlYWRlcl9zdGFydChyLCB0aSwgQkxPQ0tfVFlQRV9SRUYsIDApOwoJaWYgKGVyciA8IDApIHsKCQlyZWZ0YWJsZV9mcmVlKHRpKTsKCQlyZXR1cm4gZXJyOwoJfQoKCWZpbHRlciA9IHJlZnRhYmxlX21hbGxvYyhzaXplb2Yoc3RydWN0IGZpbHRlcmluZ19yZWZfaXRlcmF0b3IpKTsKCSpmaWx0ZXIgPSBlbXB0eTsKCglzdHJidWZfYWRkKCZmaWx0ZXItPm9pZCwgb2lkLCBvaWRfbGVuKTsKCXJlZnRhYmxlX3RhYmxlX2Zyb21fcmVhZGVyKCZmaWx0ZXItPnRhYiwgcik7CglmaWx0ZXItPmRvdWJsZV9jaGVjayA9IDA7CglpdGVyYXRvcl9mcm9tX3RhYmxlX2l0ZXIoJmZpbHRlci0+aXQsIHRpKTsKCglpdGVyYXRvcl9mcm9tX2ZpbHRlcmluZ19yZWZfaXRlcmF0b3IoaXQsIGZpbHRlcik7CglyZXR1cm4gMDsKfQoKaW50IHJlZnRhYmxlX3JlYWRlcl9yZWZzX2ZvcihzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyLAoJCQkgICAgIHN0cnVjdCByZWZ0YWJsZV9pdGVyYXRvciAqaXQsIHVpbnQ4X3QgKm9pZCkKewoJaWYgKHItPm9ial9vZmZzZXRzLmlzX3ByZXNlbnQpCgkJcmV0dXJuIHJlZnRhYmxlX3JlYWRlcl9yZWZzX2Zvcl9pbmRleGVkKHIsIGl0LCBvaWQpOwoJcmV0dXJuIHJlZnRhYmxlX3JlYWRlcl9yZWZzX2Zvcl91bmluZGV4ZWQociwgaXQsIG9pZCk7Cn0KCnVpbnQ2NF90IHJlZnRhYmxlX3JlYWRlcl9tYXhfdXBkYXRlX2luZGV4KHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnIpCnsKCXJldHVybiByLT5tYXhfdXBkYXRlX2luZGV4Owp9Cgp1aW50NjRfdCByZWZ0YWJsZV9yZWFkZXJfbWluX3VwZGF0ZV9pbmRleChzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyKQp7CglyZXR1cm4gci0+bWluX3VwZGF0ZV9pbmRleDsKfQoKLyogZ2VuZXJpYyB0YWJsZSBpbnRlcmZhY2UuICovCgpzdGF0aWMgaW50IHJlZnRhYmxlX3JlYWRlcl9zZWVrX3ZvaWQodm9pZCAqdGFiLCBzdHJ1Y3QgcmVmdGFibGVfaXRlcmF0b3IgKml0LAoJCQkJICAgICBzdHJ1Y3QgcmVmdGFibGVfcmVjb3JkICpyZWMpCnsKCXJldHVybiByZWFkZXJfc2Vlayh0YWIsIGl0LCByZWMpOwp9CgpzdGF0aWMgdWludDMyX3QgcmVmdGFibGVfcmVhZGVyX2hhc2hfaWRfdm9pZCh2b2lkICp0YWIpCnsKCXJldHVybiByZWZ0YWJsZV9yZWFkZXJfaGFzaF9pZCh0YWIpOwp9CgpzdGF0aWMgdWludDY0X3QgcmVmdGFibGVfcmVhZGVyX21pbl91cGRhdGVfaW5kZXhfdm9pZCh2b2lkICp0YWIpCnsKCXJldHVybiByZWZ0YWJsZV9yZWFkZXJfbWluX3VwZGF0ZV9pbmRleCh0YWIpOwp9CgpzdGF0aWMgdWludDY0X3QgcmVmdGFibGVfcmVhZGVyX21heF91cGRhdGVfaW5kZXhfdm9pZCh2b2lkICp0YWIpCnsKCXJldHVybiByZWZ0YWJsZV9yZWFkZXJfbWF4X3VwZGF0ZV9pbmRleCh0YWIpOwp9CgpzdGF0aWMgc3RydWN0IHJlZnRhYmxlX3RhYmxlX3Z0YWJsZSByZWFkZXJfdnRhYmxlID0gewoJLnNlZWtfcmVjb3JkID0gcmVmdGFibGVfcmVhZGVyX3NlZWtfdm9pZCwKCS5oYXNoX2lkID0gcmVmdGFibGVfcmVhZGVyX2hhc2hfaWRfdm9pZCwKCS5taW5fdXBkYXRlX2luZGV4ID0gcmVmdGFibGVfcmVhZGVyX21pbl91cGRhdGVfaW5kZXhfdm9pZCwKCS5tYXhfdXBkYXRlX2luZGV4ID0gcmVmdGFibGVfcmVhZGVyX21heF91cGRhdGVfaW5kZXhfdm9pZCwKfTsKCnZvaWQgcmVmdGFibGVfdGFibGVfZnJvbV9yZWFkZXIoc3RydWN0IHJlZnRhYmxlX3RhYmxlICp0YWIsCgkJCQlzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyZWFkZXIpCnsKCWFzc2VydCghdGFiLT5vcHMpOwoJdGFiLT5vcHMgPSAmcmVhZGVyX3Z0YWJsZTsKCXRhYi0+dGFibGVfYXJnID0gcmVhZGVyOwp9CgoKaW50IHJlZnRhYmxlX3JlYWRlcl9wcmludF9maWxlKGNvbnN0IGNoYXIgKnRhYmxlbmFtZSkKewoJc3RydWN0IHJlZnRhYmxlX2Jsb2NrX3NvdXJjZSBzcmMgPSB7IE5VTEwgfTsKCWludCBlcnIgPSByZWZ0YWJsZV9ibG9ja19zb3VyY2VfZnJvbV9maWxlKCZzcmMsIHRhYmxlbmFtZSk7CglzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyID0gTlVMTDsKCXN0cnVjdCByZWZ0YWJsZV90YWJsZSB0YWIgPSB7IE5VTEwgfTsKCWlmIChlcnIgPCAwKQoJCWdvdG8gZG9uZTsKCgllcnIgPSByZWZ0YWJsZV9uZXdfcmVhZGVyKCZyLCAmc3JjLCB0YWJsZW5hbWUpOwoJaWYgKGVyciA8IDApCgkJZ290byBkb25lOwoKCXJlZnRhYmxlX3RhYmxlX2Zyb21fcmVhZGVyKCZ0YWIsIHIpOwoJZXJyID0gcmVmdGFibGVfdGFibGVfcHJpbnQoJnRhYik7CmRvbmU6CglyZWZ0YWJsZV9yZWFkZXJfZnJlZShyKTsKCXJldHVybiBlcnI7Cn0K",
    "text": "/*\nCopyright 2020 Google LLC\n\nUse of this source code is governed by a BSD-style\nlicense that can be found in the LICENSE file or at\nhttps://developers.google.com/open-source/licenses/bsd\n*/\n\n#include \"reader.h\"\n\n#include \"system.h\"\n#include \"block.h\"\n#include \"constants.h\"\n#include \"generic.h\"\n#include \"iter.h\"\n#include \"record.h\"\n#include \"reftable-error.h\"\n#include \"reftable-generic.h\"\n#include \"tree.h\"\n\nuint64_t block_source_size(struct reftable_block_source *source)\n{\n\treturn source->ops->size(source->arg);\n}\n\nint block_source_read_block(struct reftable_block_source *source,\n\t\t\t    struct reftable_block *dest, uint64_t off,\n\t\t\t    uint32_t size)\n{\n\tint result = source->ops->read_block(source->arg, dest, off, size);\n\tdest->source = *source;\n\treturn result;\n}\n\nvoid block_source_close(struct reftable_block_source *source)\n{\n\tif (!source->ops) {\n\t\treturn;\n\t}\n\n\tsource->ops->close(source->arg);\n\tsource->ops = NULL;\n}\n\nstatic struct reftable_reader_offsets *\nreader_offsets_for(struct reftable_reader *r, uint8_t typ)\n{\n\tswitch (typ) {\n\tcase BLOCK_TYPE_REF:\n\t\treturn &r->ref_offsets;\n\tcase BLOCK_TYPE_LOG:\n\t\treturn &r->log_offsets;\n\tcase BLOCK_TYPE_OBJ:\n\t\treturn &r->obj_offsets;\n\t}\n\tabort();\n}\n\nstatic int reader_get_block(struct reftable_reader *r,\n\t\t\t    struct reftable_block *dest, uint64_t off,\n\t\t\t    uint32_t sz)\n{\n\tif (off >= r->size)\n\t\treturn 0;\n\n\tif (off + sz > r->size) {\n\t\tsz = r->size - off;\n\t}\n\n\treturn block_source_read_block(&r->source, dest, off, sz);\n}\n\nuint32_t reftable_reader_hash_id(struct reftable_reader *r)\n{\n\treturn r->hash_id;\n}\n\nconst char *reader_name(struct reftable_reader *r)\n{\n\treturn r->name;\n}\n\nstatic int parse_footer(struct reftable_reader *r, uint8_t *footer,\n\t\t\tuint8_t *header)\n{\n\tuint8_t *f = footer;\n\tuint8_t first_block_typ;\n\tint err = 0;\n\tuint32_t computed_crc;\n\tuint32_t file_crc;\n\n\tif (memcmp(f, \"REFT\", 4)) {\n\t\terr = REFTABLE_FORMAT_ERROR;\n\t\tgoto done;\n\t}\n\tf += 4;\n\n\tif (memcmp(footer, header, header_size(r->version))) {\n\t\terr = REFTABLE_FORMAT_ERROR;\n\t\tgoto done;\n\t}\n\n\tf++;\n\tr->block_size = get_be24(f);\n\n\tf += 3;\n\tr->min_update_index = get_be64(f);\n\tf += 8;\n\tr->max_update_index = get_be64(f);\n\tf += 8;\n\n\tif (r->version == 1) {\n\t\tr->hash_id = GIT_SHA1_FORMAT_ID;\n\t} else {\n\t\tr->hash_id = get_be32(f);\n\t\tswitch (r->hash_id) {\n\t\tcase GIT_SHA1_FORMAT_ID:\n\t\t\tbreak;\n\t\tcase GIT_SHA256_FORMAT_ID:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = REFTABLE_FORMAT_ERROR;\n\t\t\tgoto done;\n\t\t}\n\t\tf += 4;\n\t}\n\n\tr->ref_offsets.index_offset = get_be64(f);\n\tf += 8;\n\n\tr->obj_offsets.offset = get_be64(f);\n\tf += 8;\n\n\tr->object_id_len = r->obj_offsets.offset & ((1 << 5) - 1);\n\tr->obj_offsets.offset >>= 5;\n\n\tr->obj_offsets.index_offset = get_be64(f);\n\tf += 8;\n\tr->log_offsets.offset = get_be64(f);\n\tf += 8;\n\tr->log_offsets.index_offset = get_be64(f);\n\tf += 8;\n\n\tcomputed_crc = crc32(0, footer, f - footer);\n\tfile_crc = get_be32(f);\n\tf += 4;\n\tif (computed_crc != file_crc) {\n\t\terr = REFTABLE_FORMAT_ERROR;\n\t\tgoto done;\n\t}\n\n\tfirst_block_typ = header[header_size(r->version)];\n\tr->ref_offsets.is_present = (first_block_typ == BLOCK_TYPE_REF);\n\tr->ref_offsets.offset = 0;\n\tr->log_offsets.is_present = (first_block_typ == BLOCK_TYPE_LOG ||\n\t\t\t\t     r->log_offsets.offset > 0);\n\tr->obj_offsets.is_present = r->obj_offsets.offset > 0;\n\terr = 0;\ndone:\n\treturn err;\n}\n\nint init_reader(struct reftable_reader *r, struct reftable_block_source *source,\n\t\tconst char *name)\n{\n\tstruct reftable_block footer = { NULL };\n\tstruct reftable_block header = { NULL };\n\tint err = 0;\n\tuint64_t file_size = block_source_size(source);\n\n\t/* Need +1 to read type of first block. */\n\tuint32_t read_size = header_size(2) + 1; /* read v2 because it's larger.  */\n\tmemset(r, 0, sizeof(struct reftable_reader));\n\n\tif (read_size > file_size) {\n\t\terr = REFTABLE_FORMAT_ERROR;\n\t\tgoto done;\n\t}\n\n\terr = block_source_read_block(source, &header, 0, read_size);\n\tif (err != read_size) {\n\t\terr = REFTABLE_IO_ERROR;\n\t\tgoto done;\n\t}\n\n\tif (memcmp(header.data, \"REFT\", 4)) {\n\t\terr = REFTABLE_FORMAT_ERROR;\n\t\tgoto done;\n\t}\n\tr->version = header.data[4];\n\tif (r->version != 1 && r->version != 2) {\n\t\terr = REFTABLE_FORMAT_ERROR;\n\t\tgoto done;\n\t}\n\n\tr->size = file_size - footer_size(r->version);\n\tr->source = *source;\n\tr->name = xstrdup(name);\n\tr->hash_id = 0;\n\n\terr = block_source_read_block(source, &footer, r->size,\n\t\t\t\t      footer_size(r->version));\n\tif (err != footer_size(r->version)) {\n\t\terr = REFTABLE_IO_ERROR;\n\t\tgoto done;\n\t}\n\n\terr = parse_footer(r, footer.data, header.data);\ndone:\n\treftable_block_done(&footer);\n\treftable_block_done(&header);\n\treturn err;\n}\n\nstruct table_iter {\n\tstruct reftable_reader *r;\n\tuint8_t typ;\n\tuint64_t block_off;\n\tstruct block_iter bi;\n\tint is_finished;\n};\n#define TABLE_ITER_INIT                          \\\n\t{                                        \\\n\t\t.bi = {.last_key = STRBUF_INIT } \\\n\t}\n\nstatic void table_iter_copy_from(struct table_iter *dest,\n\t\t\t\t struct table_iter *src)\n{\n\tdest->r = src->r;\n\tdest->typ = src->typ;\n\tdest->block_off = src->block_off;\n\tdest->is_finished = src->is_finished;\n\tblock_iter_copy_from(&dest->bi, &src->bi);\n}\n\nstatic int table_iter_next_in_block(struct table_iter *ti,\n\t\t\t\t    struct reftable_record *rec)\n{\n\tint res = block_iter_next(&ti->bi, rec);\n\tif (res == 0 && reftable_record_type(rec) == BLOCK_TYPE_REF) {\n\t\trec->u.ref.update_index += ti->r->min_update_index;\n\t}\n\n\treturn res;\n}\n\nstatic void table_iter_block_done(struct table_iter *ti)\n{\n\tif (!ti->bi.br) {\n\t\treturn;\n\t}\n\treftable_block_done(&ti->bi.br->block);\n\tFREE_AND_NULL(ti->bi.br);\n\n\tti->bi.last_key.len = 0;\n\tti->bi.next_off = 0;\n}\n\nstatic int32_t extract_block_size(uint8_t *data, uint8_t *typ, uint64_t off,\n\t\t\t\t  int version)\n{\n\tint32_t result = 0;\n\n\tif (off == 0) {\n\t\tdata += header_size(version);\n\t}\n\n\t*typ = data[0];\n\tif (reftable_is_block_type(*typ)) {\n\t\tresult = get_be24(data + 1);\n\t}\n\treturn result;\n}\n\nint reader_init_block_reader(struct reftable_reader *r, struct block_reader *br,\n\t\t\t     uint64_t next_off, uint8_t want_typ)\n{\n\tint32_t guess_block_size = r->block_size ? r->block_size :\n\t\t\t\t\t\t\t DEFAULT_BLOCK_SIZE;\n\tstruct reftable_block block = { NULL };\n\tuint8_t block_typ = 0;\n\tint err = 0;\n\tuint32_t header_off = next_off ? 0 : header_size(r->version);\n\tint32_t block_size = 0;\n\n\tif (next_off >= r->size)\n\t\treturn 1;\n\n\terr = reader_get_block(r, &block, next_off, guess_block_size);\n\tif (err < 0)\n\t\tgoto done;\n\n\tblock_size = extract_block_size(block.data, &block_typ, next_off,\n\t\t\t\t\tr->version);\n\tif (block_size < 0) {\n\t\terr = block_size;\n\t\tgoto done;\n\t}\n\tif (want_typ != BLOCK_TYPE_ANY && block_typ != want_typ) {\n\t\terr = 1;\n\t\tgoto done;\n\t}\n\n\tif (block_size > guess_block_size) {\n\t\treftable_block_done(&block);\n\t\terr = reader_get_block(r, &block, next_off, block_size);\n\t\tif (err < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\terr = block_reader_init(br, &block, header_off, r->block_size,\n\t\t\t\thash_size(r->hash_id));\ndone:\n\treftable_block_done(&block);\n\n\treturn err;\n}\n\nstatic int table_iter_next_block(struct table_iter *dest,\n\t\t\t\t struct table_iter *src)\n{\n\tuint64_t next_block_off = src->block_off + src->bi.br->full_block_size;\n\tstruct block_reader br = { 0 };\n\tint err = 0;\n\n\tdest->r = src->r;\n\tdest->typ = src->typ;\n\tdest->block_off = next_block_off;\n\n\terr = reader_init_block_reader(src->r, &br, next_block_off, src->typ);\n\tif (err > 0) {\n\t\tdest->is_finished = 1;\n\t\treturn 1;\n\t}\n\tif (err != 0)\n\t\treturn err;\n\telse {\n\t\tstruct block_reader *brp =\n\t\t\treftable_malloc(sizeof(struct block_reader));\n\t\t*brp = br;\n\n\t\tdest->is_finished = 0;\n\t\tblock_reader_start(brp, &dest->bi);\n\t}\n\treturn 0;\n}\n\nstatic int table_iter_next(struct table_iter *ti, struct reftable_record *rec)\n{\n\tif (reftable_record_type(rec) != ti->typ)\n\t\treturn REFTABLE_API_ERROR;\n\n\twhile (1) {\n\t\tstruct table_iter next = TABLE_ITER_INIT;\n\t\tint err = 0;\n\t\tif (ti->is_finished) {\n\t\t\treturn 1;\n\t\t}\n\n\t\terr = table_iter_next_in_block(ti, rec);\n\t\tif (err <= 0) {\n\t\t\treturn err;\n\t\t}\n\n\t\terr = table_iter_next_block(&next, ti);\n\t\tif (err != 0) {\n\t\t\tti->is_finished = 1;\n\t\t}\n\t\ttable_iter_block_done(ti);\n\t\tif (err != 0) {\n\t\t\treturn err;\n\t\t}\n\t\ttable_iter_copy_from(ti, &next);\n\t\tblock_iter_close(&next.bi);\n\t}\n}\n\nstatic int table_iter_next_void(void *ti, struct reftable_record *rec)\n{\n\treturn table_iter_next(ti, rec);\n}\n\nstatic void table_iter_close(void *p)\n{\n\tstruct table_iter *ti = p;\n\ttable_iter_block_done(ti);\n\tblock_iter_close(&ti->bi);\n}\n\nstatic struct reftable_iterator_vtable table_iter_vtable = {\n\t.next = &table_iter_next_void,\n\t.close = &table_iter_close,\n};\n\nstatic void iterator_from_table_iter(struct reftable_iterator *it,\n\t\t\t\t     struct table_iter *ti)\n{\n\tassert(!it->ops);\n\tit->iter_arg = ti;\n\tit->ops = &table_iter_vtable;\n}\n\nstatic int reader_table_iter_at(struct reftable_reader *r,\n\t\t\t\tstruct table_iter *ti, uint64_t off,\n\t\t\t\tuint8_t typ)\n{\n\tstruct block_reader br = { 0 };\n\tstruct block_reader *brp = NULL;\n\n\tint err = reader_init_block_reader(r, &br, off, typ);\n\tif (err != 0)\n\t\treturn err;\n\n\tbrp = reftable_malloc(sizeof(struct block_reader));\n\t*brp = br;\n\tti->r = r;\n\tti->typ = block_reader_type(brp);\n\tti->block_off = off;\n\tblock_reader_start(brp, &ti->bi);\n\treturn 0;\n}\n\nstatic int reader_start(struct reftable_reader *r, struct table_iter *ti,\n\t\t\tuint8_t typ, int index)\n{\n\tstruct reftable_reader_offsets *offs = reader_offsets_for(r, typ);\n\tuint64_t off = offs->offset;\n\tif (index) {\n\t\toff = offs->index_offset;\n\t\tif (off == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\ttyp = BLOCK_TYPE_INDEX;\n\t}\n\n\treturn reader_table_iter_at(r, ti, off, typ);\n}\n\nstatic int reader_seek_linear(struct reftable_reader *r, struct table_iter *ti,\n\t\t\t      struct reftable_record *want)\n{\n\tstruct reftable_record rec =\n\t\treftable_new_record(reftable_record_type(want));\n\tstruct strbuf want_key = STRBUF_INIT;\n\tstruct strbuf got_key = STRBUF_INIT;\n\tstruct table_iter next = TABLE_ITER_INIT;\n\tint err = -1;\n\n\treftable_record_key(want, &want_key);\n\n\twhile (1) {\n\t\terr = table_iter_next_block(&next, ti);\n\t\tif (err < 0)\n\t\t\tgoto done;\n\n\t\tif (err > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\terr = block_reader_first_key(next.bi.br, &got_key);\n\t\tif (err < 0)\n\t\t\tgoto done;\n\n\t\tif (strbuf_cmp(&got_key, &want_key) > 0) {\n\t\t\ttable_iter_block_done(&next);\n\t\t\tbreak;\n\t\t}\n\n\t\ttable_iter_block_done(ti);\n\t\ttable_iter_copy_from(ti, &next);\n\t}\n\n\terr = block_iter_seek(&ti->bi, &want_key);\n\tif (err < 0)\n\t\tgoto done;\n\terr = 0;\n\ndone:\n\tblock_iter_close(&next.bi);\n\treftable_record_release(&rec);\n\tstrbuf_release(&want_key);\n\tstrbuf_release(&got_key);\n\treturn err;\n}\n\nstatic int reader_seek_indexed(struct reftable_reader *r,\n\t\t\t       struct reftable_iterator *it,\n\t\t\t       struct reftable_record *rec)\n{\n\tstruct reftable_record want_index = {\n\t\t.type = BLOCK_TYPE_INDEX, .u.idx = { .last_key = STRBUF_INIT }\n\t};\n\tstruct reftable_record index_result = {\n\t\t.type = BLOCK_TYPE_INDEX,\n\t\t.u.idx = { .last_key = STRBUF_INIT },\n\t};\n\tstruct table_iter index_iter = TABLE_ITER_INIT;\n\tstruct table_iter next = TABLE_ITER_INIT;\n\tint err = 0;\n\n\treftable_record_key(rec, &want_index.u.idx.last_key);\n\terr = reader_start(r, &index_iter, reftable_record_type(rec), 1);\n\tif (err < 0)\n\t\tgoto done;\n\n\terr = reader_seek_linear(r, &index_iter, &want_index);\n\twhile (1) {\n\t\terr = table_iter_next(&index_iter, &index_result);\n\t\ttable_iter_block_done(&index_iter);\n\t\tif (err != 0)\n\t\t\tgoto done;\n\n\t\terr = reader_table_iter_at(r, &next, index_result.u.idx.offset,\n\t\t\t\t\t   0);\n\t\tif (err != 0)\n\t\t\tgoto done;\n\n\t\terr = block_iter_seek(&next.bi, &want_index.u.idx.last_key);\n\t\tif (err < 0)\n\t\t\tgoto done;\n\n\t\tif (next.typ == reftable_record_type(rec)) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (next.typ != BLOCK_TYPE_INDEX) {\n\t\t\terr = REFTABLE_FORMAT_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\ttable_iter_copy_from(&index_iter, &next);\n\t}\n\n\tif (err == 0) {\n\t\tstruct table_iter empty = TABLE_ITER_INIT;\n\t\tstruct table_iter *malloced =\n\t\t\treftable_calloc(sizeof(struct table_iter));\n\t\t*malloced = empty;\n\t\ttable_iter_copy_from(malloced, &next);\n\t\titerator_from_table_iter(it, malloced);\n\t}\ndone:\n\tblock_iter_close(&next.bi);\n\ttable_iter_close(&index_iter);\n\treftable_record_release(&want_index);\n\treftable_record_release(&index_result);\n\treturn err;\n}\n\nstatic int reader_seek_internal(struct reftable_reader *r,\n\t\t\t\tstruct reftable_iterator *it,\n\t\t\t\tstruct reftable_record *rec)\n{\n\tstruct reftable_reader_offsets *offs =\n\t\treader_offsets_for(r, reftable_record_type(rec));\n\tuint64_t idx = offs->index_offset;\n\tstruct table_iter ti = TABLE_ITER_INIT;\n\tint err = 0;\n\tif (idx > 0)\n\t\treturn reader_seek_indexed(r, it, rec);\n\n\terr = reader_start(r, &ti, reftable_record_type(rec), 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = reader_seek_linear(r, &ti, rec);\n\tif (err < 0)\n\t\treturn err;\n\telse {\n\t\tstruct table_iter *p =\n\t\t\treftable_malloc(sizeof(struct table_iter));\n\t\t*p = ti;\n\t\titerator_from_table_iter(it, p);\n\t}\n\n\treturn 0;\n}\n\nstatic int reader_seek(struct reftable_reader *r, struct reftable_iterator *it,\n\t\t       struct reftable_record *rec)\n{\n\tuint8_t typ = reftable_record_type(rec);\n\n\tstruct reftable_reader_offsets *offs = reader_offsets_for(r, typ);\n\tif (!offs->is_present) {\n\t\titerator_set_empty(it);\n\t\treturn 0;\n\t}\n\n\treturn reader_seek_internal(r, it, rec);\n}\n\nint reftable_reader_seek_ref(struct reftable_reader *r,\n\t\t\t     struct reftable_iterator *it, const char *name)\n{\n\tstruct reftable_record rec = {\n\t\t.type = BLOCK_TYPE_REF,\n\t\t.u.ref = {\n\t\t\t.refname = (char *)name,\n\t\t},\n\t};\n\treturn reader_seek(r, it, &rec);\n}\n\nint reftable_reader_seek_log_at(struct reftable_reader *r,\n\t\t\t\tstruct reftable_iterator *it, const char *name,\n\t\t\t\tuint64_t update_index)\n{\n\tstruct reftable_record rec = { .type = BLOCK_TYPE_LOG,\n\t\t\t\t       .u.log = {\n\t\t\t\t\t       .refname = (char *)name,\n\t\t\t\t\t       .update_index = update_index,\n\t\t\t\t       } };\n\treturn reader_seek(r, it, &rec);\n}\n\nint reftable_reader_seek_log(struct reftable_reader *r,\n\t\t\t     struct reftable_iterator *it, const char *name)\n{\n\tuint64_t max = ~((uint64_t)0);\n\treturn reftable_reader_seek_log_at(r, it, name, max);\n}\n\nvoid reader_close(struct reftable_reader *r)\n{\n\tblock_source_close(&r->source);\n\tFREE_AND_NULL(r->name);\n}\n\nint reftable_new_reader(struct reftable_reader **p,\n\t\t\tstruct reftable_block_source *src, char const *name)\n{\n\tstruct reftable_reader *rd =\n\t\treftable_calloc(sizeof(struct reftable_reader));\n\tint err = init_reader(rd, src, name);\n\tif (err == 0) {\n\t\t*p = rd;\n\t} else {\n\t\tblock_source_close(src);\n\t\treftable_free(rd);\n\t}\n\treturn err;\n}\n\nvoid reftable_reader_free(struct reftable_reader *r)\n{\n\tif (!r)\n\t\treturn;\n\treader_close(r);\n\treftable_free(r);\n}\n\nstatic int reftable_reader_refs_for_indexed(struct reftable_reader *r,\n\t\t\t\t\t    struct reftable_iterator *it,\n\t\t\t\t\t    uint8_t *oid)\n{\n\tstruct reftable_record want = {\n\t\t.type = BLOCK_TYPE_OBJ,\n\t\t.u.obj = {\n\t\t\t.hash_prefix = oid,\n\t\t\t.hash_prefix_len = r->object_id_len,\n\t\t},\n\t};\n\tstruct reftable_iterator oit = { NULL };\n\tstruct reftable_record got = {\n\t\t.type = BLOCK_TYPE_OBJ,\n\t\t.u.obj = { 0 },\n\t};\n\tint err = 0;\n\tstruct indexed_table_ref_iter *itr = NULL;\n\n\t/* Look through the reverse index. */\n\terr = reader_seek(r, &oit, &want);\n\tif (err != 0)\n\t\tgoto done;\n\n\t/* read out the reftable_obj_record */\n\terr = iterator_next(&oit, &got);\n\tif (err < 0)\n\t\tgoto done;\n\n\tif (err > 0 || memcmp(want.u.obj.hash_prefix, got.u.obj.hash_prefix,\n\t\t\t      r->object_id_len)) {\n\t\t/* didn't find it; return empty iterator */\n\t\titerator_set_empty(it);\n\t\terr = 0;\n\t\tgoto done;\n\t}\n\n\terr = new_indexed_table_ref_iter(&itr, r, oid, hash_size(r->hash_id),\n\t\t\t\t\t got.u.obj.offsets,\n\t\t\t\t\t got.u.obj.offset_len);\n\tif (err < 0)\n\t\tgoto done;\n\tgot.u.obj.offsets = NULL;\n\titerator_from_indexed_table_ref_iter(it, itr);\n\ndone:\n\treftable_iterator_destroy(&oit);\n\treftable_record_release(&got);\n\treturn err;\n}\n\nstatic int reftable_reader_refs_for_unindexed(struct reftable_reader *r,\n\t\t\t\t\t      struct reftable_iterator *it,\n\t\t\t\t\t      uint8_t *oid)\n{\n\tstruct table_iter ti_empty = TABLE_ITER_INIT;\n\tstruct table_iter *ti = reftable_calloc(sizeof(struct table_iter));\n\tstruct filtering_ref_iterator *filter = NULL;\n\tstruct filtering_ref_iterator empty = FILTERING_REF_ITERATOR_INIT;\n\tint oid_len = hash_size(r->hash_id);\n\tint err;\n\n\t*ti = ti_empty;\n\terr = reader_start(r, ti, BLOCK_TYPE_REF, 0);\n\tif (err < 0) {\n\t\treftable_free(ti);\n\t\treturn err;\n\t}\n\n\tfilter = reftable_malloc(sizeof(struct filtering_ref_iterator));\n\t*filter = empty;\n\n\tstrbuf_add(&filter->oid, oid, oid_len);\n\treftable_table_from_reader(&filter->tab, r);\n\tfilter->double_check = 0;\n\titerator_from_table_iter(&filter->it, ti);\n\n\titerator_from_filtering_ref_iterator(it, filter);\n\treturn 0;\n}\n\nint reftable_reader_refs_for(struct reftable_reader *r,\n\t\t\t     struct reftable_iterator *it, uint8_t *oid)\n{\n\tif (r->obj_offsets.is_present)\n\t\treturn reftable_reader_refs_for_indexed(r, it, oid);\n\treturn reftable_reader_refs_for_unindexed(r, it, oid);\n}\n\nuint64_t reftable_reader_max_update_index(struct reftable_reader *r)\n{\n\treturn r->max_update_index;\n}\n\nuint64_t reftable_reader_min_update_index(struct reftable_reader *r)\n{\n\treturn r->min_update_index;\n}\n\n/* generic table interface. */\n\nstatic int reftable_reader_seek_void(void *tab, struct reftable_iterator *it,\n\t\t\t\t     struct reftable_record *rec)\n{\n\treturn reader_seek(tab, it, rec);\n}\n\nstatic uint32_t reftable_reader_hash_id_void(void *tab)\n{\n\treturn reftable_reader_hash_id(tab);\n}\n\nstatic uint64_t reftable_reader_min_update_index_void(void *tab)\n{\n\treturn reftable_reader_min_update_index(tab);\n}\n\nstatic uint64_t reftable_reader_max_update_index_void(void *tab)\n{\n\treturn reftable_reader_max_update_index(tab);\n}\n\nstatic struct reftable_table_vtable reader_vtable = {\n\t.seek_record = reftable_reader_seek_void,\n\t.hash_id = reftable_reader_hash_id_void,\n\t.min_update_index = reftable_reader_min_update_index_void,\n\t.max_update_index = reftable_reader_max_update_index_void,\n};\n\nvoid reftable_table_from_reader(struct reftable_table *tab,\n\t\t\t\tstruct reftable_reader *reader)\n{\n\tassert(!tab->ops);\n\ttab->ops = &reader_vtable;\n\ttab->table_arg = reader;\n}\n\n\nint reftable_reader_print_file(const char *tablename)\n{\n\tstruct reftable_block_source src = { NULL };\n\tint err = reftable_block_source_from_file(&src, tablename);\n\tstruct reftable_reader *r = NULL;\n\tstruct reftable_table tab = { NULL };\n\tif (err < 0)\n\t\tgoto done;\n\n\terr = reftable_new_reader(&r, &src, tablename);\n\tif (err < 0)\n\t\tgoto done;\n\n\treftable_table_from_reader(&tab, r);\n\terr = reftable_table_print(&tab);\ndone:\n\treftable_reader_free(r);\n\treturn err;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00906e7a2de218085eaec3c8488365cb2da0a0a8",
  "sha1_ok": true,
  "size": 18324
}
