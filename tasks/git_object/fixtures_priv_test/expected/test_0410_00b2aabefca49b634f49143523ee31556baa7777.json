{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJidW5kbGUuaCIKI2luY2x1ZGUgIm9iamVjdC5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJkaWZmLmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAibGlzdC1vYmplY3RzLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAicmVmcy5oIgoKc3RhdGljIGNvbnN0IGNoYXIgYnVuZGxlX3NpZ25hdHVyZVtdID0gIiMgdjIgZ2l0IGJ1bmRsZVxuIjsKCnN0YXRpYyB2b2lkIGFkZF90b19yZWZfbGlzdChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBjb25zdCBjaGFyICpuYW1lLAoJCXN0cnVjdCByZWZfbGlzdCAqbGlzdCkKewoJaWYgKGxpc3QtPm5yICsgMSA+PSBsaXN0LT5hbGxvYykgewoJCWxpc3QtPmFsbG9jID0gYWxsb2NfbnIobGlzdC0+bnIgKyAxKTsKCQlsaXN0LT5saXN0ID0geHJlYWxsb2MobGlzdC0+bGlzdCwKCQkJCWxpc3QtPmFsbG9jICogc2l6ZW9mKGxpc3QtPmxpc3RbMF0pKTsKCX0KCW1lbWNweShsaXN0LT5saXN0W2xpc3QtPm5yXS5zaGExLCBzaGExLCAyMCk7CglsaXN0LT5saXN0W2xpc3QtPm5yXS5uYW1lID0geHN0cmR1cChuYW1lKTsKCWxpc3QtPm5yKys7Cn0KCi8qIHJldHVybnMgYW4gZmQgKi8KaW50IHJlYWRfYnVuZGxlX2hlYWRlcihjb25zdCBjaGFyICpwYXRoLCBzdHJ1Y3QgYnVuZGxlX2hlYWRlciAqaGVhZGVyKQp7CgljaGFyIGJ1ZmZlclsxMDI0XTsKCWludCBmZDsKCWxvbmcgZnBvczsKCUZJTEUgKmZmZCA9IGZvcGVuKHBhdGgsICJyYiIpOwoKCWlmICghZmZkKQoJCXJldHVybiBlcnJvcigiY291bGQgbm90IG9wZW4gJyVzJyIsIHBhdGgpOwoJaWYgKCFmZ2V0cyhidWZmZXIsIHNpemVvZihidWZmZXIpLCBmZmQpIHx8CgkJCXN0cmNtcChidWZmZXIsIGJ1bmRsZV9zaWduYXR1cmUpKSB7CgkJZmNsb3NlKGZmZCk7CgkJcmV0dXJuIGVycm9yKCInJXMnIGRvZXMgbm90IGxvb2sgbGlrZSBhIHYyIGJ1bmRsZSBmaWxlIiwgcGF0aCk7Cgl9Cgl3aGlsZSAoZmdldHMoYnVmZmVyLCBzaXplb2YoYnVmZmVyKSwgZmZkKQoJCQkmJiBidWZmZXJbMF0gIT0gJ1xuJykgewoJCWludCBpc19wcmVyZXEgPSBidWZmZXJbMF0gPT0gJy0nOwoJCWludCBvZmZzZXQgPSBpc19wcmVyZXEgPyAxIDogMDsKCQlpbnQgbGVuID0gc3RybGVuKGJ1ZmZlcik7CgkJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCQlzdHJ1Y3QgcmVmX2xpc3QgKmxpc3QgPSBpc19wcmVyZXEgPyAmaGVhZGVyLT5wcmVyZXF1aXNpdGVzCgkJCTogJmhlYWRlci0+cmVmZXJlbmNlczsKCQljaGFyIGRlbGltOwoKCQlpZiAobGVuICYmIGJ1ZmZlcltsZW4gLSAxXSA9PSAnXG4nKQoJCQlidWZmZXJbbGVuIC0gMV0gPSAnXDAnOwoJCWlmIChnZXRfc2hhMV9oZXgoYnVmZmVyICsgb2Zmc2V0LCBzaGExKSkgewoJCQl3YXJuaW5nKCJ1bnJlY29nbml6ZWQgaGVhZGVyOiAlcyIsIGJ1ZmZlcik7CgkJCWNvbnRpbnVlOwoJCX0KCQlkZWxpbSA9IGJ1ZmZlcls0MCArIG9mZnNldF07CgkJaWYgKCFpc3NwYWNlKGRlbGltKSAmJiAoZGVsaW0gIT0gJ1wwJyB8fCAhaXNfcHJlcmVxKSkKCQkJZGllICgiaW52YWxpZCBoZWFkZXI6ICVzIiwgYnVmZmVyKTsKCQlhZGRfdG9fcmVmX2xpc3Qoc2hhMSwgaXNzcGFjZShkZWxpbSkgPwoJCQkJYnVmZmVyICsgNDEgKyBvZmZzZXQgOiAiIiwgbGlzdCk7Cgl9CglmcG9zID0gZnRlbGwoZmZkKTsKCWZjbG9zZShmZmQpOwoJZmQgPSBvcGVuKHBhdGgsIE9fUkRPTkxZKTsKCWlmIChmZCA8IDApCgkJcmV0dXJuIGVycm9yKCJjb3VsZCBub3Qgb3BlbiAnJXMnIiwgcGF0aCk7Cglsc2VlayhmZCwgZnBvcywgU0VFS19TRVQpOwoJcmV0dXJuIGZkOwp9CgpzdGF0aWMgaW50IGxpc3RfcmVmcyhzdHJ1Y3QgcmVmX2xpc3QgKnIsIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndikKewoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IHItPm5yOyBpKyspIHsKCQlpZiAoYXJnYyA+IDEpIHsKCQkJaW50IGo7CgkJCWZvciAoaiA9IDE7IGogPCBhcmdjOyBqKyspCgkJCQlpZiAoIXN0cmNtcChyLT5saXN0W2ldLm5hbWUsIGFyZ3Zbal0pKQoJCQkJCWJyZWFrOwoJCQlpZiAoaiA9PSBhcmdjKQoJCQkJY29udGludWU7CgkJfQoJCXByaW50ZigiJXMgJXNcbiIsIHNoYTFfdG9faGV4KHItPmxpc3RbaV0uc2hhMSksCgkJCQlyLT5saXN0W2ldLm5hbWUpOwoJfQoJcmV0dXJuIDA7Cn0KCiNkZWZpbmUgUFJFUkVRX01BUksgKDF1PDwxNikKCmludCB2ZXJpZnlfYnVuZGxlKHN0cnVjdCBidW5kbGVfaGVhZGVyICpoZWFkZXIsIGludCB2ZXJib3NlKQp7CgkvKgoJICogRG8gZmFzdCBjaGVjaywgdGhlbiBpZiBhbnkgcHJlcmVxcyBhcmUgbWlzc2luZyB0aGVuIGdvIGxpbmUgYnkgbGluZQoJICogdG8gYmUgdmVyYm9zZSBhYm91dCB0aGUgZXJyb3JzCgkgKi8KCXN0cnVjdCByZWZfbGlzdCAqcCA9ICZoZWFkZXItPnByZXJlcXVpc2l0ZXM7CglzdHJ1Y3QgcmV2X2luZm8gcmV2czsKCWNvbnN0IGNoYXIgKmFyZ3ZbXSA9IHtOVUxMLCAiLS1hbGwifTsKCXN0cnVjdCBvYmplY3RfYXJyYXkgcmVmczsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCWludCBpLCByZXQgPSAwLCByZXFfbnI7Cgljb25zdCBjaGFyICptZXNzYWdlID0gIlJlcG9zaXRvcnkgbGFja3MgdGhlc2UgcHJlcmVxdWlzaXRlIGNvbW1pdHM6IjsKCglpbml0X3JldmlzaW9ucygmcmV2cywgTlVMTCk7Cglmb3IgKGkgPSAwOyBpIDwgcC0+bnI7IGkrKykgewoJCXN0cnVjdCByZWZfbGlzdF9lbnRyeSAqZSA9IHAtPmxpc3QgKyBpOwoJCXN0cnVjdCBvYmplY3QgKm8gPSBwYXJzZV9vYmplY3QoZS0+c2hhMSk7CgkJaWYgKG8pIHsKCQkJby0+ZmxhZ3MgfD0gUFJFUkVRX01BUks7CgkJCWFkZF9wZW5kaW5nX29iamVjdCgmcmV2cywgbywgZS0+bmFtZSk7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoKytyZXQgPT0gMSkKCQkJZXJyb3IobWVzc2FnZSk7CgkJZXJyb3IoIiVzICVzIiwgc2hhMV90b19oZXgoZS0+c2hhMSksIGUtPm5hbWUpOwoJfQoJaWYgKHJldnMucGVuZGluZy5uciAhPSBwLT5ucikKCQlyZXR1cm4gcmV0OwoJcmVxX25yID0gcmV2cy5wZW5kaW5nLm5yOwoJc2V0dXBfcmV2aXNpb25zKDIsIGFyZ3YsICZyZXZzLCBOVUxMKTsKCgltZW1zZXQoJnJlZnMsIDAsIHNpemVvZihzdHJ1Y3Qgb2JqZWN0X2FycmF5KSk7Cglmb3IgKGkgPSAwOyBpIDwgcmV2cy5wZW5kaW5nLm5yOyBpKyspIHsKCQlzdHJ1Y3Qgb2JqZWN0X2FycmF5X2VudHJ5ICplID0gcmV2cy5wZW5kaW5nLm9iamVjdHMgKyBpOwoJCWFkZF9vYmplY3RfYXJyYXkoZS0+aXRlbSwgZS0+bmFtZSwgJnJlZnMpOwoJfQoKCWlmIChwcmVwYXJlX3JldmlzaW9uX3dhbGsoJnJldnMpKQoJCWRpZSgicmV2aXNpb24gd2FsayBzZXR1cCBmYWlsZWQiKTsKCglpID0gcmVxX25yOwoJd2hpbGUgKGkgJiYgKGNvbW1pdCA9IGdldF9yZXZpc2lvbigmcmV2cykpKQoJCWlmIChjb21taXQtPm9iamVjdC5mbGFncyAmIFBSRVJFUV9NQVJLKQoJCQlpLS07CgoJZm9yIChpID0gMDsgaSA8IHJlcV9ucjsgaSsrKQoJCWlmICghKHJlZnMub2JqZWN0c1tpXS5pdGVtLT5mbGFncyAmIFNIT1dOKSkgewoJCQlpZiAoKytyZXQgPT0gMSkKCQkJCWVycm9yKG1lc3NhZ2UpOwoJCQllcnJvcigiJXMgJXMiLCBzaGExX3RvX2hleChyZWZzLm9iamVjdHNbaV0uaXRlbS0+c2hhMSksCgkJCQlyZWZzLm9iamVjdHNbaV0ubmFtZSk7CgkJfQoKCWZvciAoaSA9IDA7IGkgPCByZWZzLm5yOyBpKyspCgkJY2xlYXJfY29tbWl0X21hcmtzKChzdHJ1Y3QgY29tbWl0ICopcmVmcy5vYmplY3RzW2ldLml0ZW0sIC0xKTsKCglpZiAodmVyYm9zZSkgewoJCXN0cnVjdCByZWZfbGlzdCAqcjsKCgkJciA9ICZoZWFkZXItPnJlZmVyZW5jZXM7CgkJcHJpbnRmKCJUaGUgYnVuZGxlIGNvbnRhaW5zICVkIHJlZiVzXG4iLAoJCSAgICAgICByLT5uciwgKDEgPCByLT5ucikgPyAicyIgOiAiIik7CgkJbGlzdF9yZWZzKHIsIDAsIE5VTEwpOwoJCXIgPSAmaGVhZGVyLT5wcmVyZXF1aXNpdGVzOwoJCXByaW50ZigiVGhlIGJ1bmRsZSByZXF1aXJlcyB0aGVzZSAlZCByZWYlc1xuIiwKCQkgICAgICAgci0+bnIsICgxIDwgci0+bnIpID8gInMiIDogIiIpOwoJCWxpc3RfcmVmcyhyLCAwLCBOVUxMKTsKCX0KCXJldHVybiByZXQ7Cn0KCmludCBsaXN0X2J1bmRsZV9yZWZzKHN0cnVjdCBidW5kbGVfaGVhZGVyICpoZWFkZXIsIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndikKewoJcmV0dXJuIGxpc3RfcmVmcygmaGVhZGVyLT5yZWZlcmVuY2VzLCBhcmdjLCBhcmd2KTsKfQoKaW50IGNyZWF0ZV9idW5kbGUoc3RydWN0IGJ1bmRsZV9oZWFkZXIgKmhlYWRlciwgY29uc3QgY2hhciAqcGF0aCwKCQlpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YpCnsKCXN0YXRpYyBzdHJ1Y3QgbG9ja19maWxlIGxvY2s7CglpbnQgYnVuZGxlX2ZkID0gLTE7CglpbnQgYnVuZGxlX3RvX3N0ZG91dDsKCWNvbnN0IGNoYXIgKiphcmd2X2JvdW5kYXJ5ID0geG1hbGxvYygoYXJnYyArIDQpICogc2l6ZW9mKGNvbnN0IGNoYXIgKikpOwoJY29uc3QgY2hhciAqKmFyZ3ZfcGFjayA9IHhtYWxsb2MoNSAqIHNpemVvZihjb25zdCBjaGFyICopKTsKCWludCBpLCByZWZfY291bnQgPSAwOwoJY2hhciBidWZmZXJbMTAyNF07CglzdHJ1Y3QgcmV2X2luZm8gcmV2czsKCWludCByZWFkX2Zyb21fc3RkaW4gPSAwOwoJc3RydWN0IGNoaWxkX3Byb2Nlc3MgcmxzOwoJRklMRSAqcmxzX2ZvdXQ7CgoJYnVuZGxlX3RvX3N0ZG91dCA9ICFzdHJjbXAocGF0aCwgIi0iKTsKCWlmIChidW5kbGVfdG9fc3Rkb3V0KQoJCWJ1bmRsZV9mZCA9IDE7CgllbHNlCgkJYnVuZGxlX2ZkID0gaG9sZF9sb2NrX2ZpbGVfZm9yX3VwZGF0ZSgmbG9jaywgcGF0aCwgMSk7CgoJLyogd3JpdGUgc2lnbmF0dXJlICovCgl3cml0ZV9vcl9kaWUoYnVuZGxlX2ZkLCBidW5kbGVfc2lnbmF0dXJlLCBzdHJsZW4oYnVuZGxlX3NpZ25hdHVyZSkpOwoKCS8qIGluaXQgcmV2cyB0byBsaXN0IG9iamVjdHMgZm9yIHBhY2stb2JqZWN0cyBsYXRlciAqLwoJc2F2ZV9jb21taXRfYnVmZmVyID0gMDsKCWluaXRfcmV2aXNpb25zKCZyZXZzLCBOVUxMKTsKCgkvKiB3cml0ZSBwcmVyZXF1aXNpdGVzICovCgltZW1jcHkoYXJndl9ib3VuZGFyeSArIDMsIGFyZ3YgKyAxLCBhcmdjICogc2l6ZW9mKGNvbnN0IGNoYXIgKikpOwoJYXJndl9ib3VuZGFyeVswXSA9ICJyZXYtbGlzdCI7Cglhcmd2X2JvdW5kYXJ5WzFdID0gIi0tYm91bmRhcnkiOwoJYXJndl9ib3VuZGFyeVsyXSA9ICItLXByZXR0eT1vbmVsaW5lIjsKCWFyZ3ZfYm91bmRhcnlbYXJnYyArIDJdID0gTlVMTDsKCW1lbXNldCgmcmxzLCAwLCBzaXplb2YocmxzKSk7CglybHMuYXJndiA9IGFyZ3ZfYm91bmRhcnk7CglybHMub3V0ID0gLTE7CglybHMuZ2l0X2NtZCA9IDE7CglpZiAoc3RhcnRfY29tbWFuZCgmcmxzKSkKCQlyZXR1cm4gLTE7CglybHNfZm91dCA9IGZkb3BlbihybHMub3V0LCAiciIpOwoJd2hpbGUgKGZnZXRzKGJ1ZmZlciwgc2l6ZW9mKGJ1ZmZlciksIHJsc19mb3V0KSkgewoJCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgkJaWYgKGJ1ZmZlclswXSA9PSAnLScpIHsKCQkJd3JpdGVfb3JfZGllKGJ1bmRsZV9mZCwgYnVmZmVyLCBzdHJsZW4oYnVmZmVyKSk7CgkJCWlmICghZ2V0X3NoYTFfaGV4KGJ1ZmZlciArIDEsIHNoYTEpKSB7CgkJCQlzdHJ1Y3Qgb2JqZWN0ICpvYmplY3QgPSBwYXJzZV9vYmplY3Qoc2hhMSk7CgkJCQlvYmplY3QtPmZsYWdzIHw9IFVOSU5URVJFU1RJTkc7CgkJCQlhZGRfcGVuZGluZ19vYmplY3QoJnJldnMsIG9iamVjdCwgYnVmZmVyKTsKCQkJfQoJCX0gZWxzZSBpZiAoIWdldF9zaGExX2hleChidWZmZXIsIHNoYTEpKSB7CgkJCXN0cnVjdCBvYmplY3QgKm9iamVjdCA9IHBhcnNlX29iamVjdChzaGExKTsKCQkJb2JqZWN0LT5mbGFncyB8PSBTSE9XTjsKCQl9Cgl9CglmY2xvc2UocmxzX2ZvdXQpOwoJaWYgKGZpbmlzaF9jb21tYW5kKCZybHMpKQoJCXJldHVybiBlcnJvcigicmV2LWxpc3QgZGllZCIpOwoKCS8qIHdyaXRlIHJlZmVyZW5jZXMgKi8KCWFyZ2MgPSBzZXR1cF9yZXZpc2lvbnMoYXJnYywgYXJndiwgJnJldnMsIE5VTEwpOwoKCWZvciAoaSA9IDE7IGkgPCBhcmdjOyBpKyspIHsKCQlpZiAoIXN0cmNtcChhcmd2W2ldLCAiLS1zdGRpbiIpKSB7CgkJCWlmIChyZWFkX2Zyb21fc3RkaW4rKykKCQkJCWRpZSgiLS1zdGRpbiBnaXZlbiB0d2ljZT8iKTsKCQkJcmVhZF9yZXZpc2lvbnNfZnJvbV9zdGRpbigmcmV2cyk7CgkJCWNvbnRpbnVlOwoJCX0KCQlyZXR1cm4gZXJyb3IoInVucmVjb2duaXplZCBhcmd1bWVudDogJXMnIiwgYXJndltpXSk7Cgl9CgoJZm9yIChpID0gMDsgaSA8IHJldnMucGVuZGluZy5ucjsgaSsrKSB7CgkJc3RydWN0IG9iamVjdF9hcnJheV9lbnRyeSAqZSA9IHJldnMucGVuZGluZy5vYmplY3RzICsgaTsKCQl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJCWNoYXIgKnJlZjsKCQljb25zdCBjaGFyICpkaXNwbGF5X3JlZjsKCQlpbnQgZmxhZzsKCgkJaWYgKGUtPml0ZW0tPmZsYWdzICYgVU5JTlRFUkVTVElORykKCQkJY29udGludWU7CgkJaWYgKGR3aW1fcmVmKGUtPm5hbWUsIHN0cmxlbihlLT5uYW1lKSwgc2hhMSwgJnJlZikgIT0gMSkKCQkJY29udGludWU7CgkJaWYgKCFyZXNvbHZlX3JlZihlLT5uYW1lLCBzaGExLCAxLCAmZmxhZykpCgkJCWZsYWcgPSAwOwoJCWRpc3BsYXlfcmVmID0gKGZsYWcgJiBSRUZfSVNTWU1SRUYpID8gZS0+bmFtZSA6IHJlZjsKCgkJLyoKCQkgKiBNYWtlIHN1cmUgdGhlIHJlZnMgd2Ugd3JvdGUgb3V0IGlzIGNvcnJlY3Q7IC0tbWF4LWNvdW50IGFuZAoJCSAqIG90aGVyIGxpbWl0aW5nIG9wdGlvbnMgY291bGQgaGF2ZSBwcmV2ZW50ZWQgYWxsIHRoZSB0aXBzCgkJICogZnJvbSBnZXR0aW5nIG91dHB1dC4KCQkgKgoJCSAqIE5vbiBjb21taXQgb2JqZWN0cyBzdWNoIGFzIHRhZ3MgYW5kIGJsb2JzIGRvIG5vdCBoYXZlCgkJICogdGhpcyBpc3N1ZSBhcyB0aGV5IGFyZSBub3QgYWZmZWN0ZWQgYnkgdGhvc2UgZXh0cmEKCQkgKiBjb25zdHJhaW50cy4KCQkgKi8KCQlpZiAoIShlLT5pdGVtLT5mbGFncyAmIFNIT1dOKSAmJiBlLT5pdGVtLT50eXBlID09IE9CSl9DT01NSVQpIHsKCQkJd2FybmluZygicmVmICclcycgaXMgZXhjbHVkZWQgYnkgdGhlIHJldi1saXN0IG9wdGlvbnMiLAoJCQkJZS0+bmFtZSk7CgkJCWZyZWUocmVmKTsKCQkJY29udGludWU7CgkJfQoJCS8qCgkJICogSWYgeW91IHJ1biAiZ2l0IGJ1bmRsZSBjcmVhdGUgYm5kbCB2MS4wLi52Mi4wIiwgdGhlCgkJICogbmFtZSBvZiB0aGUgcG9zaXRpdmUgcmVmIGlzICJ2Mi4wIiBidXQgdGhhdCBpcyB0aGUKCQkgKiBjb21taXQgdGhhdCBpcyByZWZlcmVuY2VkIGJ5IHRoZSB0YWcsIGFuZCBub3QgdGhlIHRhZwoJCSAqIGl0c2VsZi4KCQkgKi8KCQlpZiAoaGFzaGNtcChzaGExLCBlLT5pdGVtLT5zaGExKSkgewoJCQkvKgoJCQkgKiBJcyB0aGlzIHRoZSBwb3NpdGl2ZSBlbmQgb2YgYSByYW5nZSBleHByZXNzZWQKCQkJICogaW4gdGVybXMgb2YgYSB0YWcgKGUuZy4gdjIuMCBmcm9tIHRoZSByYW5nZQoJCQkgKiAidjEuMC4udjIuMCIpPwoJCQkgKi8KCQkJc3RydWN0IGNvbW1pdCAqb25lID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2Uoc2hhMSk7CgkJCXN0cnVjdCBvYmplY3QgKm9iajsKCgkJCWlmIChlLT5pdGVtID09ICYob25lLT5vYmplY3QpKSB7CgkJCQkvKgoJCQkJICogTmVlZCB0byBpbmNsdWRlIGUtPm5hbWUgYXMgYW4KCQkJCSAqIGluZGVwZW5kZW50IHJlZiB0byB0aGUgcGFjay1vYmplY3RzCgkJCQkgKiBpbnB1dCwgc28gdGhhdCB0aGUgdGFnIGlzIGluY2x1ZGVkCgkJCQkgKiBpbiB0aGUgb3V0cHV0OyBvdGhlcndpc2Ugd2Ugd291bGQKCQkJCSAqIGVuZCB1cCB0cmlnZ2VyaW5nICJlbXB0eSBidW5kbGUiCgkJCQkgKiBlcnJvci4KCQkJCSAqLwoJCQkJb2JqID0gcGFyc2Vfb2JqZWN0KHNoYTEpOwoJCQkJb2JqLT5mbGFncyB8PSBTSE9XTjsKCQkJCWFkZF9wZW5kaW5nX29iamVjdCgmcmV2cywgb2JqLCBlLT5uYW1lKTsKCQkJfQoJCQlmcmVlKHJlZik7CgkJCWNvbnRpbnVlOwoJCX0KCgkJcmVmX2NvdW50Kys7CgkJd3JpdGVfb3JfZGllKGJ1bmRsZV9mZCwgc2hhMV90b19oZXgoZS0+aXRlbS0+c2hhMSksIDQwKTsKCQl3cml0ZV9vcl9kaWUoYnVuZGxlX2ZkLCAiICIsIDEpOwoJCXdyaXRlX29yX2RpZShidW5kbGVfZmQsIGRpc3BsYXlfcmVmLCBzdHJsZW4oZGlzcGxheV9yZWYpKTsKCQl3cml0ZV9vcl9kaWUoYnVuZGxlX2ZkLCAiXG4iLCAxKTsKCQlmcmVlKHJlZik7Cgl9CglpZiAoIXJlZl9jb3VudCkKCQlkaWUgKCJSZWZ1c2luZyB0byBjcmVhdGUgZW1wdHkgYnVuZGxlLiIpOwoKCS8qIGVuZCBoZWFkZXIgKi8KCXdyaXRlX29yX2RpZShidW5kbGVfZmQsICJcbiIsIDEpOwoKCS8qIHdyaXRlIHBhY2sgKi8KCWFyZ3ZfcGFja1swXSA9ICJwYWNrLW9iamVjdHMiOwoJYXJndl9wYWNrWzFdID0gIi0tYWxsLXByb2dyZXNzIjsKCWFyZ3ZfcGFja1syXSA9ICItLXN0ZG91dCI7Cglhcmd2X3BhY2tbM10gPSAiLS10aGluIjsKCWFyZ3ZfcGFja1s0XSA9IE5VTEw7CgltZW1zZXQoJnJscywgMCwgc2l6ZW9mKHJscykpOwoJcmxzLmFyZ3YgPSBhcmd2X3BhY2s7CglybHMuaW4gPSAtMTsKCXJscy5vdXQgPSBidW5kbGVfZmQ7CglybHMuZ2l0X2NtZCA9IDE7CglpZiAoc3RhcnRfY29tbWFuZCgmcmxzKSkKCQlyZXR1cm4gZXJyb3IoIkNvdWxkIG5vdCBzcGF3biBwYWNrLW9iamVjdHMiKTsKCgkvKgoJICogc3RhcnRfY29tbWFuZCBjbG9zZWQgYnVuZGxlX2ZkIGlmIGl0IHdhcyA+IDEKCSAqIHNvIHNldCB0aGUgbG9jayBmZCB0byAtMSBzbyBjb21taXRfbG9ja19maWxlKCkKCSAqIHdvbid0IGZhaWwgdHJ5aW5nIHRvIGNsb3NlIGl0LgoJICovCglsb2NrLmZkID0gLTE7CgoJZm9yIChpID0gMDsgaSA8IHJldnMucGVuZGluZy5ucjsgaSsrKSB7CgkJc3RydWN0IG9iamVjdCAqb2JqZWN0ID0gcmV2cy5wZW5kaW5nLm9iamVjdHNbaV0uaXRlbTsKCQlpZiAob2JqZWN0LT5mbGFncyAmIFVOSU5URVJFU1RJTkcpCgkJCXdyaXRlX29yX2RpZShybHMuaW4sICJeIiwgMSk7CgkJd3JpdGVfb3JfZGllKHJscy5pbiwgc2hhMV90b19oZXgob2JqZWN0LT5zaGExKSwgNDApOwoJCXdyaXRlX29yX2RpZShybHMuaW4sICJcbiIsIDEpOwoJfQoJY2xvc2UocmxzLmluKTsKCWlmIChmaW5pc2hfY29tbWFuZCgmcmxzKSkKCQlyZXR1cm4gZXJyb3IgKCJwYWNrLW9iamVjdHMgZGllZCIpOwoJaWYgKCFidW5kbGVfdG9fc3Rkb3V0KQoJCWNvbW1pdF9sb2NrX2ZpbGUoJmxvY2spOwoJcmV0dXJuIDA7Cn0KCmludCB1bmJ1bmRsZShzdHJ1Y3QgYnVuZGxlX2hlYWRlciAqaGVhZGVyLCBpbnQgYnVuZGxlX2ZkKQp7Cgljb25zdCBjaGFyICphcmd2X2luZGV4X3BhY2tbXSA9IHsiaW5kZXgtcGFjayIsCgkJIi0tZml4LXRoaW4iLCAiLS1zdGRpbiIsIE5VTEx9OwoJc3RydWN0IGNoaWxkX3Byb2Nlc3MgaXA7CgoJaWYgKHZlcmlmeV9idW5kbGUoaGVhZGVyLCAwKSkKCQlyZXR1cm4gLTE7CgltZW1zZXQoJmlwLCAwLCBzaXplb2YoaXApKTsKCWlwLmFyZ3YgPSBhcmd2X2luZGV4X3BhY2s7CglpcC5pbiA9IGJ1bmRsZV9mZDsKCWlwLm5vX3N0ZG91dCA9IDE7CglpcC5naXRfY21kID0gMTsKCWlmIChydW5fY29tbWFuZCgmaXApKQoJCXJldHVybiBlcnJvcigiaW5kZXgtcGFjayBkaWVkIik7CglyZXR1cm4gMDsKfQo=",
    "text": "#include \"cache.h\"\n#include \"bundle.h\"\n#include \"object.h\"\n#include \"commit.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"list-objects.h\"\n#include \"run-command.h\"\n#include \"refs.h\"\n\nstatic const char bundle_signature[] = \"# v2 git bundle\\n\";\n\nstatic void add_to_ref_list(const unsigned char *sha1, const char *name,\n\t\tstruct ref_list *list)\n{\n\tif (list->nr + 1 >= list->alloc) {\n\t\tlist->alloc = alloc_nr(list->nr + 1);\n\t\tlist->list = xrealloc(list->list,\n\t\t\t\tlist->alloc * sizeof(list->list[0]));\n\t}\n\tmemcpy(list->list[list->nr].sha1, sha1, 20);\n\tlist->list[list->nr].name = xstrdup(name);\n\tlist->nr++;\n}\n\n/* returns an fd */\nint read_bundle_header(const char *path, struct bundle_header *header)\n{\n\tchar buffer[1024];\n\tint fd;\n\tlong fpos;\n\tFILE *ffd = fopen(path, \"rb\");\n\n\tif (!ffd)\n\t\treturn error(\"could not open '%s'\", path);\n\tif (!fgets(buffer, sizeof(buffer), ffd) ||\n\t\t\tstrcmp(buffer, bundle_signature)) {\n\t\tfclose(ffd);\n\t\treturn error(\"'%s' does not look like a v2 bundle file\", path);\n\t}\n\twhile (fgets(buffer, sizeof(buffer), ffd)\n\t\t\t&& buffer[0] != '\\n') {\n\t\tint is_prereq = buffer[0] == '-';\n\t\tint offset = is_prereq ? 1 : 0;\n\t\tint len = strlen(buffer);\n\t\tunsigned char sha1[20];\n\t\tstruct ref_list *list = is_prereq ? &header->prerequisites\n\t\t\t: &header->references;\n\t\tchar delim;\n\n\t\tif (len && buffer[len - 1] == '\\n')\n\t\t\tbuffer[len - 1] = '\\0';\n\t\tif (get_sha1_hex(buffer + offset, sha1)) {\n\t\t\twarning(\"unrecognized header: %s\", buffer);\n\t\t\tcontinue;\n\t\t}\n\t\tdelim = buffer[40 + offset];\n\t\tif (!isspace(delim) && (delim != '\\0' || !is_prereq))\n\t\t\tdie (\"invalid header: %s\", buffer);\n\t\tadd_to_ref_list(sha1, isspace(delim) ?\n\t\t\t\tbuffer + 41 + offset : \"\", list);\n\t}\n\tfpos = ftell(ffd);\n\tfclose(ffd);\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn error(\"could not open '%s'\", path);\n\tlseek(fd, fpos, SEEK_SET);\n\treturn fd;\n}\n\nstatic int list_refs(struct ref_list *r, int argc, const char **argv)\n{\n\tint i;\n\n\tfor (i = 0; i < r->nr; i++) {\n\t\tif (argc > 1) {\n\t\t\tint j;\n\t\t\tfor (j = 1; j < argc; j++)\n\t\t\t\tif (!strcmp(r->list[i].name, argv[j]))\n\t\t\t\t\tbreak;\n\t\t\tif (j == argc)\n\t\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"%s %s\\n\", sha1_to_hex(r->list[i].sha1),\n\t\t\t\tr->list[i].name);\n\t}\n\treturn 0;\n}\n\n#define PREREQ_MARK (1u<<16)\n\nint verify_bundle(struct bundle_header *header, int verbose)\n{\n\t/*\n\t * Do fast check, then if any prereqs are missing then go line by line\n\t * to be verbose about the errors\n\t */\n\tstruct ref_list *p = &header->prerequisites;\n\tstruct rev_info revs;\n\tconst char *argv[] = {NULL, \"--all\"};\n\tstruct object_array refs;\n\tstruct commit *commit;\n\tint i, ret = 0, req_nr;\n\tconst char *message = \"Repository lacks these prerequisite commits:\";\n\n\tinit_revisions(&revs, NULL);\n\tfor (i = 0; i < p->nr; i++) {\n\t\tstruct ref_list_entry *e = p->list + i;\n\t\tstruct object *o = parse_object(e->sha1);\n\t\tif (o) {\n\t\t\to->flags |= PREREQ_MARK;\n\t\t\tadd_pending_object(&revs, o, e->name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (++ret == 1)\n\t\t\terror(message);\n\t\terror(\"%s %s\", sha1_to_hex(e->sha1), e->name);\n\t}\n\tif (revs.pending.nr != p->nr)\n\t\treturn ret;\n\treq_nr = revs.pending.nr;\n\tsetup_revisions(2, argv, &revs, NULL);\n\n\tmemset(&refs, 0, sizeof(struct object_array));\n\tfor (i = 0; i < revs.pending.nr; i++) {\n\t\tstruct object_array_entry *e = revs.pending.objects + i;\n\t\tadd_object_array(e->item, e->name, &refs);\n\t}\n\n\tif (prepare_revision_walk(&revs))\n\t\tdie(\"revision walk setup failed\");\n\n\ti = req_nr;\n\twhile (i && (commit = get_revision(&revs)))\n\t\tif (commit->object.flags & PREREQ_MARK)\n\t\t\ti--;\n\n\tfor (i = 0; i < req_nr; i++)\n\t\tif (!(refs.objects[i].item->flags & SHOWN)) {\n\t\t\tif (++ret == 1)\n\t\t\t\terror(message);\n\t\t\terror(\"%s %s\", sha1_to_hex(refs.objects[i].item->sha1),\n\t\t\t\trefs.objects[i].name);\n\t\t}\n\n\tfor (i = 0; i < refs.nr; i++)\n\t\tclear_commit_marks((struct commit *)refs.objects[i].item, -1);\n\n\tif (verbose) {\n\t\tstruct ref_list *r;\n\n\t\tr = &header->references;\n\t\tprintf(\"The bundle contains %d ref%s\\n\",\n\t\t       r->nr, (1 < r->nr) ? \"s\" : \"\");\n\t\tlist_refs(r, 0, NULL);\n\t\tr = &header->prerequisites;\n\t\tprintf(\"The bundle requires these %d ref%s\\n\",\n\t\t       r->nr, (1 < r->nr) ? \"s\" : \"\");\n\t\tlist_refs(r, 0, NULL);\n\t}\n\treturn ret;\n}\n\nint list_bundle_refs(struct bundle_header *header, int argc, const char **argv)\n{\n\treturn list_refs(&header->references, argc, argv);\n}\n\nint create_bundle(struct bundle_header *header, const char *path,\n\t\tint argc, const char **argv)\n{\n\tstatic struct lock_file lock;\n\tint bundle_fd = -1;\n\tint bundle_to_stdout;\n\tconst char **argv_boundary = xmalloc((argc + 4) * sizeof(const char *));\n\tconst char **argv_pack = xmalloc(5 * sizeof(const char *));\n\tint i, ref_count = 0;\n\tchar buffer[1024];\n\tstruct rev_info revs;\n\tint read_from_stdin = 0;\n\tstruct child_process rls;\n\tFILE *rls_fout;\n\n\tbundle_to_stdout = !strcmp(path, \"-\");\n\tif (bundle_to_stdout)\n\t\tbundle_fd = 1;\n\telse\n\t\tbundle_fd = hold_lock_file_for_update(&lock, path, 1);\n\n\t/* write signature */\n\twrite_or_die(bundle_fd, bundle_signature, strlen(bundle_signature));\n\n\t/* init revs to list objects for pack-objects later */\n\tsave_commit_buffer = 0;\n\tinit_revisions(&revs, NULL);\n\n\t/* write prerequisites */\n\tmemcpy(argv_boundary + 3, argv + 1, argc * sizeof(const char *));\n\targv_boundary[0] = \"rev-list\";\n\targv_boundary[1] = \"--boundary\";\n\targv_boundary[2] = \"--pretty=oneline\";\n\targv_boundary[argc + 2] = NULL;\n\tmemset(&rls, 0, sizeof(rls));\n\trls.argv = argv_boundary;\n\trls.out = -1;\n\trls.git_cmd = 1;\n\tif (start_command(&rls))\n\t\treturn -1;\n\trls_fout = fdopen(rls.out, \"r\");\n\twhile (fgets(buffer, sizeof(buffer), rls_fout)) {\n\t\tunsigned char sha1[20];\n\t\tif (buffer[0] == '-') {\n\t\t\twrite_or_die(bundle_fd, buffer, strlen(buffer));\n\t\t\tif (!get_sha1_hex(buffer + 1, sha1)) {\n\t\t\t\tstruct object *object = parse_object(sha1);\n\t\t\t\tobject->flags |= UNINTERESTING;\n\t\t\t\tadd_pending_object(&revs, object, buffer);\n\t\t\t}\n\t\t} else if (!get_sha1_hex(buffer, sha1)) {\n\t\t\tstruct object *object = parse_object(sha1);\n\t\t\tobject->flags |= SHOWN;\n\t\t}\n\t}\n\tfclose(rls_fout);\n\tif (finish_command(&rls))\n\t\treturn error(\"rev-list died\");\n\n\t/* write references */\n\targc = setup_revisions(argc, argv, &revs, NULL);\n\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"--stdin\")) {\n\t\t\tif (read_from_stdin++)\n\t\t\t\tdie(\"--stdin given twice?\");\n\t\t\tread_revisions_from_stdin(&revs);\n\t\t\tcontinue;\n\t\t}\n\t\treturn error(\"unrecognized argument: %s'\", argv[i]);\n\t}\n\n\tfor (i = 0; i < revs.pending.nr; i++) {\n\t\tstruct object_array_entry *e = revs.pending.objects + i;\n\t\tunsigned char sha1[20];\n\t\tchar *ref;\n\t\tconst char *display_ref;\n\t\tint flag;\n\n\t\tif (e->item->flags & UNINTERESTING)\n\t\t\tcontinue;\n\t\tif (dwim_ref(e->name, strlen(e->name), sha1, &ref) != 1)\n\t\t\tcontinue;\n\t\tif (!resolve_ref(e->name, sha1, 1, &flag))\n\t\t\tflag = 0;\n\t\tdisplay_ref = (flag & REF_ISSYMREF) ? e->name : ref;\n\n\t\t/*\n\t\t * Make sure the refs we wrote out is correct; --max-count and\n\t\t * other limiting options could have prevented all the tips\n\t\t * from getting output.\n\t\t *\n\t\t * Non commit objects such as tags and blobs do not have\n\t\t * this issue as they are not affected by those extra\n\t\t * constraints.\n\t\t */\n\t\tif (!(e->item->flags & SHOWN) && e->item->type == OBJ_COMMIT) {\n\t\t\twarning(\"ref '%s' is excluded by the rev-list options\",\n\t\t\t\te->name);\n\t\t\tfree(ref);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If you run \"git bundle create bndl v1.0..v2.0\", the\n\t\t * name of the positive ref is \"v2.0\" but that is the\n\t\t * commit that is referenced by the tag, and not the tag\n\t\t * itself.\n\t\t */\n\t\tif (hashcmp(sha1, e->item->sha1)) {\n\t\t\t/*\n\t\t\t * Is this the positive end of a range expressed\n\t\t\t * in terms of a tag (e.g. v2.0 from the range\n\t\t\t * \"v1.0..v2.0\")?\n\t\t\t */\n\t\t\tstruct commit *one = lookup_commit_reference(sha1);\n\t\t\tstruct object *obj;\n\n\t\t\tif (e->item == &(one->object)) {\n\t\t\t\t/*\n\t\t\t\t * Need to include e->name as an\n\t\t\t\t * independent ref to the pack-objects\n\t\t\t\t * input, so that the tag is included\n\t\t\t\t * in the output; otherwise we would\n\t\t\t\t * end up triggering \"empty bundle\"\n\t\t\t\t * error.\n\t\t\t\t */\n\t\t\t\tobj = parse_object(sha1);\n\t\t\t\tobj->flags |= SHOWN;\n\t\t\t\tadd_pending_object(&revs, obj, e->name);\n\t\t\t}\n\t\t\tfree(ref);\n\t\t\tcontinue;\n\t\t}\n\n\t\tref_count++;\n\t\twrite_or_die(bundle_fd, sha1_to_hex(e->item->sha1), 40);\n\t\twrite_or_die(bundle_fd, \" \", 1);\n\t\twrite_or_die(bundle_fd, display_ref, strlen(display_ref));\n\t\twrite_or_die(bundle_fd, \"\\n\", 1);\n\t\tfree(ref);\n\t}\n\tif (!ref_count)\n\t\tdie (\"Refusing to create empty bundle.\");\n\n\t/* end header */\n\twrite_or_die(bundle_fd, \"\\n\", 1);\n\n\t/* write pack */\n\targv_pack[0] = \"pack-objects\";\n\targv_pack[1] = \"--all-progress\";\n\targv_pack[2] = \"--stdout\";\n\targv_pack[3] = \"--thin\";\n\targv_pack[4] = NULL;\n\tmemset(&rls, 0, sizeof(rls));\n\trls.argv = argv_pack;\n\trls.in = -1;\n\trls.out = bundle_fd;\n\trls.git_cmd = 1;\n\tif (start_command(&rls))\n\t\treturn error(\"Could not spawn pack-objects\");\n\n\t/*\n\t * start_command closed bundle_fd if it was > 1\n\t * so set the lock fd to -1 so commit_lock_file()\n\t * won't fail trying to close it.\n\t */\n\tlock.fd = -1;\n\n\tfor (i = 0; i < revs.pending.nr; i++) {\n\t\tstruct object *object = revs.pending.objects[i].item;\n\t\tif (object->flags & UNINTERESTING)\n\t\t\twrite_or_die(rls.in, \"^\", 1);\n\t\twrite_or_die(rls.in, sha1_to_hex(object->sha1), 40);\n\t\twrite_or_die(rls.in, \"\\n\", 1);\n\t}\n\tclose(rls.in);\n\tif (finish_command(&rls))\n\t\treturn error (\"pack-objects died\");\n\tif (!bundle_to_stdout)\n\t\tcommit_lock_file(&lock);\n\treturn 0;\n}\n\nint unbundle(struct bundle_header *header, int bundle_fd)\n{\n\tconst char *argv_index_pack[] = {\"index-pack\",\n\t\t\"--fix-thin\", \"--stdin\", NULL};\n\tstruct child_process ip;\n\n\tif (verify_bundle(header, 0))\n\t\treturn -1;\n\tmemset(&ip, 0, sizeof(ip));\n\tip.argv = argv_index_pack;\n\tip.in = bundle_fd;\n\tip.no_stdout = 1;\n\tip.git_cmd = 1;\n\tif (run_command(&ip))\n\t\treturn error(\"index-pack died\");\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00b2aabefca49b634f49143523ee31556baa7777",
  "sha1_ok": true,
  "size": 9695
}
