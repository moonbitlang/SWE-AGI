{
  "content": {
    "base64": "LyoKICogVmFyaW91cyB0cml2aWFsIGhlbHBlciB3cmFwcGVycyBhcm91bmQgc3RhbmRhcmQgZnVuY3Rpb25zCiAqLwojaW5jbHVkZSAiY2FjaGUuaCIKCnN0YXRpYyB2b2lkIGRvX25vdGhpbmcoc2l6ZV90IHNpemUpCnsKfQoKc3RhdGljIHZvaWQgKCp0cnlfdG9fZnJlZV9yb3V0aW5lKShzaXplX3Qgc2l6ZSkgPSBkb19ub3RoaW5nOwoKc3RhdGljIGludCBtZW1vcnlfbGltaXRfY2hlY2soc2l6ZV90IHNpemUsIGludCBnZW50bGUpCnsKCXN0YXRpYyBzaXplX3QgbGltaXQgPSAwOwoJaWYgKCFsaW1pdCkgewoJCWxpbWl0ID0gZ2l0X2Vudl91bG9uZygiR0lUX0FMTE9DX0xJTUlUIiwgMCk7CgkJaWYgKCFsaW1pdCkKCQkJbGltaXQgPSBTSVpFX01BWDsKCX0KCWlmIChzaXplID4gbGltaXQpIHsKCQlpZiAoZ2VudGxlKSB7CgkJCWVycm9yKCJhdHRlbXB0aW5nIHRvIGFsbG9jYXRlICUiUFJJdU1BWCIgb3ZlciBsaW1pdCAlIlBSSXVNQVgsCgkJCSAgICAgICh1aW50bWF4X3Qpc2l6ZSwgKHVpbnRtYXhfdClsaW1pdCk7CgkJCXJldHVybiAtMTsKCQl9IGVsc2UKCQkJZGllKCJhdHRlbXB0aW5nIHRvIGFsbG9jYXRlICUiUFJJdU1BWCIgb3ZlciBsaW1pdCAlIlBSSXVNQVgsCgkJCSAgICAodWludG1heF90KXNpemUsICh1aW50bWF4X3QpbGltaXQpOwoJfQoJcmV0dXJuIDA7Cn0KCnRyeV90b19mcmVlX3Qgc2V0X3RyeV90b19mcmVlX3JvdXRpbmUodHJ5X3RvX2ZyZWVfdCByb3V0aW5lKQp7Cgl0cnlfdG9fZnJlZV90IG9sZCA9IHRyeV90b19mcmVlX3JvdXRpbmU7CglpZiAoIXJvdXRpbmUpCgkJcm91dGluZSA9IGRvX25vdGhpbmc7Cgl0cnlfdG9fZnJlZV9yb3V0aW5lID0gcm91dGluZTsKCXJldHVybiBvbGQ7Cn0KCmNoYXIgKnhzdHJkdXAoY29uc3QgY2hhciAqc3RyKQp7CgljaGFyICpyZXQgPSBzdHJkdXAoc3RyKTsKCWlmICghcmV0KSB7CgkJdHJ5X3RvX2ZyZWVfcm91dGluZShzdHJsZW4oc3RyKSArIDEpOwoJCXJldCA9IHN0cmR1cChzdHIpOwoJCWlmICghcmV0KQoJCQlkaWUoIk91dCBvZiBtZW1vcnksIHN0cmR1cCBmYWlsZWQiKTsKCX0KCXJldHVybiByZXQ7Cn0KCnN0YXRpYyB2b2lkICpkb194bWFsbG9jKHNpemVfdCBzaXplLCBpbnQgZ2VudGxlKQp7Cgl2b2lkICpyZXQ7CgoJaWYgKG1lbW9yeV9saW1pdF9jaGVjayhzaXplLCBnZW50bGUpKQoJCXJldHVybiBOVUxMOwoJcmV0ID0gbWFsbG9jKHNpemUpOwoJaWYgKCFyZXQgJiYgIXNpemUpCgkJcmV0ID0gbWFsbG9jKDEpOwoJaWYgKCFyZXQpIHsKCQl0cnlfdG9fZnJlZV9yb3V0aW5lKHNpemUpOwoJCXJldCA9IG1hbGxvYyhzaXplKTsKCQlpZiAoIXJldCAmJiAhc2l6ZSkKCQkJcmV0ID0gbWFsbG9jKDEpOwoJCWlmICghcmV0KSB7CgkJCWlmICghZ2VudGxlKQoJCQkJZGllKCJPdXQgb2YgbWVtb3J5LCBtYWxsb2MgZmFpbGVkICh0cmllZCB0byBhbGxvY2F0ZSAlbHUgYnl0ZXMpIiwKCQkJCSAgICAodW5zaWduZWQgbG9uZylzaXplKTsKCQkJZWxzZSB7CgkJCQllcnJvcigiT3V0IG9mIG1lbW9yeSwgbWFsbG9jIGZhaWxlZCAodHJpZWQgdG8gYWxsb2NhdGUgJWx1IGJ5dGVzKSIsCgkJCQkgICAgICAodW5zaWduZWQgbG9uZylzaXplKTsKCQkJCXJldHVybiBOVUxMOwoJCQl9CgkJfQoJfQojaWZkZWYgWE1BTExPQ19QT0lTT04KCW1lbXNldChyZXQsIDB4QTUsIHNpemUpOwojZW5kaWYKCXJldHVybiByZXQ7Cn0KCnZvaWQgKnhtYWxsb2Moc2l6ZV90IHNpemUpCnsKCXJldHVybiBkb194bWFsbG9jKHNpemUsIDApOwp9CgpzdGF0aWMgdm9pZCAqZG9feG1hbGxvY3ooc2l6ZV90IHNpemUsIGludCBnZW50bGUpCnsKCXZvaWQgKnJldDsKCWlmICh1bnNpZ25lZF9hZGRfb3ZlcmZsb3dzKHNpemUsIDEpKSB7CgkJaWYgKGdlbnRsZSkgewoJCQllcnJvcigiRGF0YSB0b28gbGFyZ2UgdG8gZml0IGludG8gdmlydHVhbCBtZW1vcnkgc3BhY2UuIik7CgkJCXJldHVybiBOVUxMOwoJCX0gZWxzZQoJCQlkaWUoIkRhdGEgdG9vIGxhcmdlIHRvIGZpdCBpbnRvIHZpcnR1YWwgbWVtb3J5IHNwYWNlLiIpOwoJfQoJcmV0ID0gZG9feG1hbGxvYyhzaXplICsgMSwgZ2VudGxlKTsKCWlmIChyZXQpCgkJKChjaGFyKilyZXQpW3NpemVdID0gMDsKCXJldHVybiByZXQ7Cn0KCnZvaWQgKnhtYWxsb2N6KHNpemVfdCBzaXplKQp7CglyZXR1cm4gZG9feG1hbGxvY3ooc2l6ZSwgMCk7Cn0KCnZvaWQgKnhtYWxsb2N6X2dlbnRseShzaXplX3Qgc2l6ZSkKewoJcmV0dXJuIGRvX3htYWxsb2N6KHNpemUsIDEpOwp9CgovKgogKiB4bWVtZHVweigpIGFsbG9jYXRlcyAobGVuICsgMSkgYnl0ZXMgb2YgbWVtb3J5LCBkdXBsaWNhdGVzICJsZW4iIGJ5dGVzIG9mCiAqICJkYXRhIiB0byB0aGUgYWxsb2NhdGVkIG1lbW9yeSwgemVybyB0ZXJtaW5hdGVzIHRoZSBhbGxvY2F0ZWQgbWVtb3J5LAogKiBhbmQgcmV0dXJucyBhIHBvaW50ZXIgdG8gdGhlIGFsbG9jYXRlZCBtZW1vcnkuIElmIHRoZSBhbGxvY2F0aW9uIGZhaWxzLAogKiB0aGUgcHJvZ3JhbSBkaWVzLgogKi8Kdm9pZCAqeG1lbWR1cHooY29uc3Qgdm9pZCAqZGF0YSwgc2l6ZV90IGxlbikKewoJcmV0dXJuIG1lbWNweSh4bWFsbG9jeihsZW4pLCBkYXRhLCBsZW4pOwp9CgpjaGFyICp4c3RybmR1cChjb25zdCBjaGFyICpzdHIsIHNpemVfdCBsZW4pCnsKCWNoYXIgKnAgPSBtZW1jaHIoc3RyLCAnXDAnLCBsZW4pOwoJcmV0dXJuIHhtZW1kdXB6KHN0ciwgcCA/IHAgLSBzdHIgOiBsZW4pOwp9Cgp2b2lkICp4cmVhbGxvYyh2b2lkICpwdHIsIHNpemVfdCBzaXplKQp7Cgl2b2lkICpyZXQ7CgoJbWVtb3J5X2xpbWl0X2NoZWNrKHNpemUsIDApOwoJcmV0ID0gcmVhbGxvYyhwdHIsIHNpemUpOwoJaWYgKCFyZXQgJiYgIXNpemUpCgkJcmV0ID0gcmVhbGxvYyhwdHIsIDEpOwoJaWYgKCFyZXQpIHsKCQl0cnlfdG9fZnJlZV9yb3V0aW5lKHNpemUpOwoJCXJldCA9IHJlYWxsb2MocHRyLCBzaXplKTsKCQlpZiAoIXJldCAmJiAhc2l6ZSkKCQkJcmV0ID0gcmVhbGxvYyhwdHIsIDEpOwoJCWlmICghcmV0KQoJCQlkaWUoIk91dCBvZiBtZW1vcnksIHJlYWxsb2MgZmFpbGVkIik7Cgl9CglyZXR1cm4gcmV0Owp9Cgp2b2lkICp4Y2FsbG9jKHNpemVfdCBubWVtYiwgc2l6ZV90IHNpemUpCnsKCXZvaWQgKnJldDsKCgltZW1vcnlfbGltaXRfY2hlY2soc2l6ZSAqIG5tZW1iLCAwKTsKCXJldCA9IGNhbGxvYyhubWVtYiwgc2l6ZSk7CglpZiAoIXJldCAmJiAoIW5tZW1iIHx8ICFzaXplKSkKCQlyZXQgPSBjYWxsb2MoMSwgMSk7CglpZiAoIXJldCkgewoJCXRyeV90b19mcmVlX3JvdXRpbmUobm1lbWIgKiBzaXplKTsKCQlyZXQgPSBjYWxsb2Mobm1lbWIsIHNpemUpOwoJCWlmICghcmV0ICYmICghbm1lbWIgfHwgIXNpemUpKQoJCQlyZXQgPSBjYWxsb2MoMSwgMSk7CgkJaWYgKCFyZXQpCgkJCWRpZSgiT3V0IG9mIG1lbW9yeSwgY2FsbG9jIGZhaWxlZCIpOwoJfQoJcmV0dXJuIHJldDsKfQoKLyoKICogTGltaXQgc2l6ZSBvZiBJTyBjaHVua3MsIGJlY2F1c2UgaHVnZSBjaHVua3Mgb25seSBjYXVzZSBwYWluLiAgT1MgWAogKiA2NC1iaXQgaXMgYnVnZ3ksIHJldHVybmluZyBFSU5WQUwgaWYgbGVuID49IElOVF9NQVg7IGFuZCBldmVuIGluCiAqIHRoZSBhYnNlbmNlIG9mIGJ1Z3MsIGxhcmdlIGNodW5rcyBjYW4gcmVzdWx0IGluIGJhZCBsYXRlbmNpZXMgd2hlbgogKiB5b3UgZGVjaWRlIHRvIGtpbGwgdGhlIHByb2Nlc3MuCiAqLwojZGVmaW5lIE1BWF9JT19TSVpFICg4KjEwMjQqMTAyNCkKCi8qCiAqIHhyZWFkKCkgaXMgdGhlIHNhbWUgYSByZWFkKCksIGJ1dCBpdCBhdXRvbWF0aWNhbGx5IHJlc3RhcnRzIHJlYWQoKQogKiBvcGVyYXRpb25zIHdpdGggYSByZWNvdmVyYWJsZSBlcnJvciAoRUFHQUlOIGFuZCBFSU5UUikuIHhyZWFkKCkKICogRE9FUyBOT1QgR1VBUkFOVEVFIHRoYXQgImxlbiIgYnl0ZXMgaXMgcmVhZCBldmVuIGlmIHRoZSBkYXRhIGlzIGF2YWlsYWJsZS4KICovCnNzaXplX3QgeHJlYWQoaW50IGZkLCB2b2lkICpidWYsIHNpemVfdCBsZW4pCnsKCXNzaXplX3QgbnI7CglpZiAobGVuID4gTUFYX0lPX1NJWkUpCgkgICAgbGVuID0gTUFYX0lPX1NJWkU7Cgl3aGlsZSAoMSkgewoJCW5yID0gcmVhZChmZCwgYnVmLCBsZW4pOwoJCWlmICgobnIgPCAwKSAmJiAoZXJybm8gPT0gRUFHQUlOIHx8IGVycm5vID09IEVJTlRSKSkKCQkJY29udGludWU7CgkJcmV0dXJuIG5yOwoJfQp9CgovKgogKiB4d3JpdGUoKSBpcyB0aGUgc2FtZSBhIHdyaXRlKCksIGJ1dCBpdCBhdXRvbWF0aWNhbGx5IHJlc3RhcnRzIHdyaXRlKCkKICogb3BlcmF0aW9ucyB3aXRoIGEgcmVjb3ZlcmFibGUgZXJyb3IgKEVBR0FJTiBhbmQgRUlOVFIpLiB4d3JpdGUoKSBET0VTIE5PVAogKiBHVUFSQU5URUUgdGhhdCAibGVuIiBieXRlcyBpcyB3cml0dGVuIGV2ZW4gaWYgdGhlIG9wZXJhdGlvbiBpcyBzdWNjZXNzZnVsLgogKi8Kc3NpemVfdCB4d3JpdGUoaW50IGZkLCBjb25zdCB2b2lkICpidWYsIHNpemVfdCBsZW4pCnsKCXNzaXplX3QgbnI7CglpZiAobGVuID4gTUFYX0lPX1NJWkUpCgkgICAgbGVuID0gTUFYX0lPX1NJWkU7Cgl3aGlsZSAoMSkgewoJCW5yID0gd3JpdGUoZmQsIGJ1ZiwgbGVuKTsKCQlpZiAoKG5yIDwgMCkgJiYgKGVycm5vID09IEVBR0FJTiB8fCBlcnJubyA9PSBFSU5UUikpCgkJCWNvbnRpbnVlOwoJCXJldHVybiBucjsKCX0KfQoKLyoKICogeHByZWFkKCkgaXMgdGhlIHNhbWUgYXMgcHJlYWQoKSwgYnV0IGl0IGF1dG9tYXRpY2FsbHkgcmVzdGFydHMgcHJlYWQoKQogKiBvcGVyYXRpb25zIHdpdGggYSByZWNvdmVyYWJsZSBlcnJvciAoRUFHQUlOIGFuZCBFSU5UUikuIHhwcmVhZCgpIERPRVMKICogTk9UIEdVQVJBTlRFRSB0aGF0ICJsZW4iIGJ5dGVzIGlzIHJlYWQgZXZlbiBpZiB0aGUgZGF0YSBpcyBhdmFpbGFibGUuCiAqLwpzc2l6ZV90IHhwcmVhZChpbnQgZmQsIHZvaWQgKmJ1Ziwgc2l6ZV90IGxlbiwgb2ZmX3Qgb2Zmc2V0KQp7Cglzc2l6ZV90IG5yOwoJaWYgKGxlbiA+IE1BWF9JT19TSVpFKQoJCWxlbiA9IE1BWF9JT19TSVpFOwoJd2hpbGUgKDEpIHsKCQluciA9IHByZWFkKGZkLCBidWYsIGxlbiwgb2Zmc2V0KTsKCQlpZiAoKG5yIDwgMCkgJiYgKGVycm5vID09IEVBR0FJTiB8fCBlcnJubyA9PSBFSU5UUikpCgkJCWNvbnRpbnVlOwoJCXJldHVybiBucjsKCX0KfQoKc3NpemVfdCByZWFkX2luX2Z1bGwoaW50IGZkLCB2b2lkICpidWYsIHNpemVfdCBjb3VudCkKewoJY2hhciAqcCA9IGJ1ZjsKCXNzaXplX3QgdG90YWwgPSAwOwoKCXdoaWxlIChjb3VudCA+IDApIHsKCQlzc2l6ZV90IGxvYWRlZCA9IHhyZWFkKGZkLCBwLCBjb3VudCk7CgkJaWYgKGxvYWRlZCA8IDApCgkJCXJldHVybiAtMTsKCQlpZiAobG9hZGVkID09IDApCgkJCXJldHVybiB0b3RhbDsKCQljb3VudCAtPSBsb2FkZWQ7CgkJcCArPSBsb2FkZWQ7CgkJdG90YWwgKz0gbG9hZGVkOwoJfQoKCXJldHVybiB0b3RhbDsKfQoKc3NpemVfdCB3cml0ZV9pbl9mdWxsKGludCBmZCwgY29uc3Qgdm9pZCAqYnVmLCBzaXplX3QgY291bnQpCnsKCWNvbnN0IGNoYXIgKnAgPSBidWY7Cglzc2l6ZV90IHRvdGFsID0gMDsKCgl3aGlsZSAoY291bnQgPiAwKSB7CgkJc3NpemVfdCB3cml0dGVuID0geHdyaXRlKGZkLCBwLCBjb3VudCk7CgkJaWYgKHdyaXR0ZW4gPCAwKQoJCQlyZXR1cm4gLTE7CgkJaWYgKCF3cml0dGVuKSB7CgkJCWVycm5vID0gRU5PU1BDOwoJCQlyZXR1cm4gLTE7CgkJfQoJCWNvdW50IC09IHdyaXR0ZW47CgkJcCArPSB3cml0dGVuOwoJCXRvdGFsICs9IHdyaXR0ZW47Cgl9CgoJcmV0dXJuIHRvdGFsOwp9Cgpzc2l6ZV90IHByZWFkX2luX2Z1bGwoaW50IGZkLCB2b2lkICpidWYsIHNpemVfdCBjb3VudCwgb2ZmX3Qgb2Zmc2V0KQp7CgljaGFyICpwID0gYnVmOwoJc3NpemVfdCB0b3RhbCA9IDA7CgoJd2hpbGUgKGNvdW50ID4gMCkgewoJCXNzaXplX3QgbG9hZGVkID0geHByZWFkKGZkLCBwLCBjb3VudCwgb2Zmc2V0KTsKCQlpZiAobG9hZGVkIDwgMCkKCQkJcmV0dXJuIC0xOwoJCWlmIChsb2FkZWQgPT0gMCkKCQkJcmV0dXJuIHRvdGFsOwoJCWNvdW50IC09IGxvYWRlZDsKCQlwICs9IGxvYWRlZDsKCQl0b3RhbCArPSBsb2FkZWQ7CgkJb2Zmc2V0ICs9IGxvYWRlZDsKCX0KCglyZXR1cm4gdG90YWw7Cn0KCmludCB4ZHVwKGludCBmZCkKewoJaW50IHJldCA9IGR1cChmZCk7CglpZiAocmV0IDwgMCkKCQlkaWVfZXJybm8oImR1cCBmYWlsZWQiKTsKCXJldHVybiByZXQ7Cn0KCkZJTEUgKnhmZG9wZW4oaW50IGZkLCBjb25zdCBjaGFyICptb2RlKQp7CglGSUxFICpzdHJlYW0gPSBmZG9wZW4oZmQsIG1vZGUpOwoJaWYgKHN0cmVhbSA9PSBOVUxMKQoJCWRpZV9lcnJubygiT3V0IG9mIG1lbW9yeT8gZmRvcGVuIGZhaWxlZCIpOwoJcmV0dXJuIHN0cmVhbTsKfQoKaW50IHhta3N0ZW1wKGNoYXIgKnRlbXBsYXRlKQp7CglpbnQgZmQ7CgljaGFyIG9yaWd0ZW1wbGF0ZVtQQVRIX01BWF07CglzdHJsY3B5KG9yaWd0ZW1wbGF0ZSwgdGVtcGxhdGUsIHNpemVvZihvcmlndGVtcGxhdGUpKTsKCglmZCA9IG1rc3RlbXAodGVtcGxhdGUpOwoJaWYgKGZkIDwgMCkgewoJCWludCBzYXZlZF9lcnJubyA9IGVycm5vOwoJCWNvbnN0IGNoYXIgKm5vbnJlbGF0aXZlX3RlbXBsYXRlOwoKCQlpZiAoc3RybGVuKHRlbXBsYXRlKSAhPSBzdHJsZW4ob3JpZ3RlbXBsYXRlKSkKCQkJdGVtcGxhdGUgPSBvcmlndGVtcGxhdGU7CgoJCW5vbnJlbGF0aXZlX3RlbXBsYXRlID0gYWJzb2x1dGVfcGF0aCh0ZW1wbGF0ZSk7CgkJZXJybm8gPSBzYXZlZF9lcnJubzsKCQlkaWVfZXJybm8oIlVuYWJsZSB0byBjcmVhdGUgdGVtcG9yYXJ5IGZpbGUgJyVzJyIsCgkJCW5vbnJlbGF0aXZlX3RlbXBsYXRlKTsKCX0KCXJldHVybiBmZDsKfQoKLyogZ2l0X21rc3RlbXAoKSAtIGNyZWF0ZSB0bXAgZmlsZSBob25vcmluZyBUTVBESVIgdmFyaWFibGUgKi8KaW50IGdpdF9ta3N0ZW1wKGNoYXIgKnBhdGgsIHNpemVfdCBsZW4sIGNvbnN0IGNoYXIgKnRlbXBsYXRlKQp7Cgljb25zdCBjaGFyICp0bXA7CglzaXplX3QgbjsKCgl0bXAgPSBnZXRlbnYoIlRNUERJUiIpOwoJaWYgKCF0bXApCgkJdG1wID0gIi90bXAiOwoJbiA9IHNucHJpbnRmKHBhdGgsIGxlbiwgIiVzLyVzIiwgdG1wLCB0ZW1wbGF0ZSk7CglpZiAobGVuIDw9IG4pIHsKCQllcnJubyA9IEVOQU1FVE9PTE9ORzsKCQlyZXR1cm4gLTE7Cgl9CglyZXR1cm4gbWtzdGVtcChwYXRoKTsKfQoKLyogZ2l0X21rc3RlbXBzKCkgLSBjcmVhdGUgdG1wIGZpbGUgd2l0aCBzdWZmaXggaG9ub3JpbmcgVE1QRElSIHZhcmlhYmxlLiAqLwppbnQgZ2l0X21rc3RlbXBzKGNoYXIgKnBhdGgsIHNpemVfdCBsZW4sIGNvbnN0IGNoYXIgKnRlbXBsYXRlLCBpbnQgc3VmZml4X2xlbikKewoJY29uc3QgY2hhciAqdG1wOwoJc2l6ZV90IG47CgoJdG1wID0gZ2V0ZW52KCJUTVBESVIiKTsKCWlmICghdG1wKQoJCXRtcCA9ICIvdG1wIjsKCW4gPSBzbnByaW50ZihwYXRoLCBsZW4sICIlcy8lcyIsIHRtcCwgdGVtcGxhdGUpOwoJaWYgKGxlbiA8PSBuKSB7CgkJZXJybm8gPSBFTkFNRVRPT0xPTkc7CgkJcmV0dXJuIC0xOwoJfQoJcmV0dXJuIG1rc3RlbXBzKHBhdGgsIHN1ZmZpeF9sZW4pOwp9CgovKiBBZGFwdGVkIGZyb20gbGliaWJlcnR5J3MgbWtzdGVtcC5jLiAqLwoKI3VuZGVmIFRNUF9NQVgKI2RlZmluZSBUTVBfTUFYIDE2Mzg0CgppbnQgZ2l0X21rc3RlbXBzX21vZGUoY2hhciAqcGF0dGVybiwgaW50IHN1ZmZpeF9sZW4sIGludCBtb2RlKQp7CglzdGF0aWMgY29uc3QgY2hhciBsZXR0ZXJzW10gPQoJCSJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eiIKCQkiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoiCgkJIjAxMjM0NTY3ODkiOwoJc3RhdGljIGNvbnN0IGludCBudW1fbGV0dGVycyA9IDYyOwoJdWludDY0X3QgdmFsdWU7CglzdHJ1Y3QgdGltZXZhbCB0djsKCWNoYXIgKnRlbXBsYXRlOwoJc2l6ZV90IGxlbjsKCWludCBmZCwgY291bnQ7CgoJbGVuID0gc3RybGVuKHBhdHRlcm4pOwoKCWlmIChsZW4gPCA2ICsgc3VmZml4X2xlbikgewoJCWVycm5vID0gRUlOVkFMOwoJCXJldHVybiAtMTsKCX0KCglpZiAoc3RybmNtcCgmcGF0dGVybltsZW4gLSA2IC0gc3VmZml4X2xlbl0sICJYWFhYWFgiLCA2KSkgewoJCWVycm5vID0gRUlOVkFMOwoJCXJldHVybiAtMTsKCX0KCgkvKgoJICogUmVwbGFjZSBwYXR0ZXJuJ3MgWFhYWFhYIGNoYXJhY3RlcnMgd2l0aCByYW5kb21uZXNzLgoJICogVHJ5IFRNUF9NQVggZGlmZmVyZW50IGZpbGVuYW1lcy4KCSAqLwoJZ2V0dGltZW9mZGF5KCZ0diwgTlVMTCk7Cgl2YWx1ZSA9ICgoc2l6ZV90KSh0di50dl91c2VjIDw8IDE2KSkgXiB0di50dl9zZWMgXiBnZXRwaWQoKTsKCXRlbXBsYXRlID0gJnBhdHRlcm5bbGVuIC0gNiAtIHN1ZmZpeF9sZW5dOwoJZm9yIChjb3VudCA9IDA7IGNvdW50IDwgVE1QX01BWDsgKytjb3VudCkgewoJCXVpbnQ2NF90IHYgPSB2YWx1ZTsKCQkvKiBGaWxsIGluIHRoZSByYW5kb20gYml0cy4gKi8KCQl0ZW1wbGF0ZVswXSA9IGxldHRlcnNbdiAlIG51bV9sZXR0ZXJzXTsgdiAvPSBudW1fbGV0dGVyczsKCQl0ZW1wbGF0ZVsxXSA9IGxldHRlcnNbdiAlIG51bV9sZXR0ZXJzXTsgdiAvPSBudW1fbGV0dGVyczsKCQl0ZW1wbGF0ZVsyXSA9IGxldHRlcnNbdiAlIG51bV9sZXR0ZXJzXTsgdiAvPSBudW1fbGV0dGVyczsKCQl0ZW1wbGF0ZVszXSA9IGxldHRlcnNbdiAlIG51bV9sZXR0ZXJzXTsgdiAvPSBudW1fbGV0dGVyczsKCQl0ZW1wbGF0ZVs0XSA9IGxldHRlcnNbdiAlIG51bV9sZXR0ZXJzXTsgdiAvPSBudW1fbGV0dGVyczsKCQl0ZW1wbGF0ZVs1XSA9IGxldHRlcnNbdiAlIG51bV9sZXR0ZXJzXTsgdiAvPSBudW1fbGV0dGVyczsKCgkJZmQgPSBvcGVuKHBhdHRlcm4sIE9fQ1JFQVQgfCBPX0VYQ0wgfCBPX1JEV1IsIG1vZGUpOwoJCWlmIChmZCA+PSAwKQoJCQlyZXR1cm4gZmQ7CgkJLyoKCQkgKiBGYXRhbCBlcnJvciAoRVBFUk0sIEVOT1NQQyBldGMpLgoJCSAqIEl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBsb29wLgoJCSAqLwoJCWlmIChlcnJubyAhPSBFRVhJU1QpCgkJCWJyZWFrOwoJCS8qCgkJICogVGhpcyBpcyBhIHJhbmRvbSB2YWx1ZS4gIEl0IGlzIG9ubHkgbmVjZXNzYXJ5IHRoYXQKCQkgKiB0aGUgbmV4dCBUTVBfTUFYIHZhbHVlcyBnZW5lcmF0ZWQgYnkgYWRkaW5nIDc3NzcgdG8KCQkgKiBWQUxVRSBhcmUgZGlmZmVyZW50IHdpdGggKG1vZHVsZSAyXjMyKS4KCQkgKi8KCQl2YWx1ZSArPSA3Nzc3OwoJfQoJLyogV2UgcmV0dXJuIHRoZSBudWxsIHN0cmluZyBpZiB3ZSBjYW4ndCBmaW5kIGEgdW5pcXVlIGZpbGUgbmFtZS4gICovCglwYXR0ZXJuWzBdID0gJ1wwJzsKCXJldHVybiAtMTsKfQoKaW50IGdpdF9ta3N0ZW1wX21vZGUoY2hhciAqcGF0dGVybiwgaW50IG1vZGUpCnsKCS8qIG1rc3RlbXAgaXMganVzdCBta3N0ZW1wcyB3aXRoIG5vIHN1ZmZpeCAqLwoJcmV0dXJuIGdpdF9ta3N0ZW1wc19tb2RlKHBhdHRlcm4sIDAsIG1vZGUpOwp9CgojaWZkZWYgTk9fTUtTVEVNUFMKaW50IGdpdG1rc3RlbXBzKGNoYXIgKnBhdHRlcm4sIGludCBzdWZmaXhfbGVuKQp7CglyZXR1cm4gZ2l0X21rc3RlbXBzX21vZGUocGF0dGVybiwgc3VmZml4X2xlbiwgMDYwMCk7Cn0KI2VuZGlmCgppbnQgeG1rc3RlbXBfbW9kZShjaGFyICp0ZW1wbGF0ZSwgaW50IG1vZGUpCnsKCWludCBmZDsKCWNoYXIgb3JpZ3RlbXBsYXRlW1BBVEhfTUFYXTsKCXN0cmxjcHkob3JpZ3RlbXBsYXRlLCB0ZW1wbGF0ZSwgc2l6ZW9mKG9yaWd0ZW1wbGF0ZSkpOwoKCWZkID0gZ2l0X21rc3RlbXBfbW9kZSh0ZW1wbGF0ZSwgbW9kZSk7CglpZiAoZmQgPCAwKSB7CgkJaW50IHNhdmVkX2Vycm5vID0gZXJybm87CgkJY29uc3QgY2hhciAqbm9ucmVsYXRpdmVfdGVtcGxhdGU7CgoJCWlmICghdGVtcGxhdGVbMF0pCgkJCXRlbXBsYXRlID0gb3JpZ3RlbXBsYXRlOwoKCQlub25yZWxhdGl2ZV90ZW1wbGF0ZSA9IGFic29sdXRlX3BhdGgodGVtcGxhdGUpOwoJCWVycm5vID0gc2F2ZWRfZXJybm87CgkJZGllX2Vycm5vKCJVbmFibGUgdG8gY3JlYXRlIHRlbXBvcmFyeSBmaWxlICclcyciLAoJCQlub25yZWxhdGl2ZV90ZW1wbGF0ZSk7Cgl9CglyZXR1cm4gZmQ7Cn0KCnN0YXRpYyBpbnQgd2Fybl9pZl91bnJlbW92YWJsZShjb25zdCBjaGFyICpvcCwgY29uc3QgY2hhciAqZmlsZSwgaW50IHJjKQp7CglpbnQgZXJyOwoJaWYgKCFyYyB8fCBlcnJubyA9PSBFTk9FTlQpCgkJcmV0dXJuIDA7CgllcnIgPSBlcnJubzsKCXdhcm5pbmcoInVuYWJsZSB0byAlcyAlczogJXMiLCBvcCwgZmlsZSwgc3RyZXJyb3IoZXJybm8pKTsKCWVycm5vID0gZXJyOwoJcmV0dXJuIHJjOwp9CgppbnQgdW5saW5rX29yX21zZyhjb25zdCBjaGFyICpmaWxlLCBzdHJ1Y3Qgc3RyYnVmICplcnIpCnsKCWludCByYyA9IHVubGluayhmaWxlKTsKCglhc3NlcnQoZXJyKTsKCglpZiAoIXJjIHx8IGVycm5vID09IEVOT0VOVCkKCQlyZXR1cm4gMDsKCglzdHJidWZfYWRkZihlcnIsICJ1bmFibGUgdG8gdW5saW5rICVzOiAlcyIsCgkJICAgIGZpbGUsIHN0cmVycm9yKGVycm5vKSk7CglyZXR1cm4gLTE7Cn0KCmludCB1bmxpbmtfb3Jfd2Fybihjb25zdCBjaGFyICpmaWxlKQp7CglyZXR1cm4gd2Fybl9pZl91bnJlbW92YWJsZSgidW5saW5rIiwgZmlsZSwgdW5saW5rKGZpbGUpKTsKfQoKaW50IHJtZGlyX29yX3dhcm4oY29uc3QgY2hhciAqZmlsZSkKewoJcmV0dXJuIHdhcm5faWZfdW5yZW1vdmFibGUoInJtZGlyIiwgZmlsZSwgcm1kaXIoZmlsZSkpOwp9CgppbnQgcmVtb3ZlX29yX3dhcm4odW5zaWduZWQgaW50IG1vZGUsIGNvbnN0IGNoYXIgKmZpbGUpCnsKCXJldHVybiBTX0lTR0lUTElOSyhtb2RlKSA/IHJtZGlyX29yX3dhcm4oZmlsZSkgOiB1bmxpbmtfb3Jfd2FybihmaWxlKTsKfQoKdm9pZCB3YXJuX29uX2luYWNjZXNzaWJsZShjb25zdCBjaGFyICpwYXRoKQp7Cgl3YXJuaW5nKF8oInVuYWJsZSB0byBhY2Nlc3MgJyVzJzogJXMiKSwgcGF0aCwgc3RyZXJyb3IoZXJybm8pKTsKfQoKc3RhdGljIGludCBhY2Nlc3NfZXJyb3JfaXNfb2soaW50IGVyciwgdW5zaWduZWQgZmxhZykKewoJcmV0dXJuIGVyciA9PSBFTk9FTlQgfHwgZXJyID09IEVOT1RESVIgfHwKCQkoKGZsYWcgJiBBQ0NFU1NfRUFDQ0VTX09LKSAmJiBlcnIgPT0gRUFDQ0VTKTsKfQoKaW50IGFjY2Vzc19vcl93YXJuKGNvbnN0IGNoYXIgKnBhdGgsIGludCBtb2RlLCB1bnNpZ25lZCBmbGFnKQp7CglpbnQgcmV0ID0gYWNjZXNzKHBhdGgsIG1vZGUpOwoJaWYgKHJldCAmJiAhYWNjZXNzX2Vycm9yX2lzX29rKGVycm5vLCBmbGFnKSkKCQl3YXJuX29uX2luYWNjZXNzaWJsZShwYXRoKTsKCXJldHVybiByZXQ7Cn0KCmludCBhY2Nlc3Nfb3JfZGllKGNvbnN0IGNoYXIgKnBhdGgsIGludCBtb2RlLCB1bnNpZ25lZCBmbGFnKQp7CglpbnQgcmV0ID0gYWNjZXNzKHBhdGgsIG1vZGUpOwoJaWYgKHJldCAmJiAhYWNjZXNzX2Vycm9yX2lzX29rKGVycm5vLCBmbGFnKSkKCQlkaWVfZXJybm8oXygidW5hYmxlIHRvIGFjY2VzcyAnJXMnIiksIHBhdGgpOwoJcmV0dXJuIHJldDsKfQoKc3RydWN0IHBhc3N3ZCAqeGdldHB3dWlkX3NlbGYodm9pZCkKewoJc3RydWN0IHBhc3N3ZCAqcHc7CgoJZXJybm8gPSAwOwoJcHcgPSBnZXRwd3VpZChnZXR1aWQoKSk7CglpZiAoIXB3KQoJCWRpZShfKCJ1bmFibGUgdG8gbG9vayB1cCBjdXJyZW50IHVzZXIgaW4gdGhlIHBhc3N3ZCBmaWxlOiAlcyIpLAoJCSAgICBlcnJubyA/IHN0cmVycm9yKGVycm5vKSA6IF8oIm5vIHN1Y2ggdXNlciIpKTsKCXJldHVybiBwdzsKfQoKY2hhciAqeGdldGN3ZCh2b2lkKQp7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CglpZiAoc3RyYnVmX2dldGN3ZCgmc2IpKQoJCWRpZV9lcnJubyhfKCJ1bmFibGUgdG8gZ2V0IGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkiKSk7CglyZXR1cm4gc3RyYnVmX2RldGFjaCgmc2IsIE5VTEwpOwp9Cg==",
    "text": "/*\n * Various trivial helper wrappers around standard functions\n */\n#include \"cache.h\"\n\nstatic void do_nothing(size_t size)\n{\n}\n\nstatic void (*try_to_free_routine)(size_t size) = do_nothing;\n\nstatic int memory_limit_check(size_t size, int gentle)\n{\n\tstatic size_t limit = 0;\n\tif (!limit) {\n\t\tlimit = git_env_ulong(\"GIT_ALLOC_LIMIT\", 0);\n\t\tif (!limit)\n\t\t\tlimit = SIZE_MAX;\n\t}\n\tif (size > limit) {\n\t\tif (gentle) {\n\t\t\terror(\"attempting to allocate %\"PRIuMAX\" over limit %\"PRIuMAX,\n\t\t\t      (uintmax_t)size, (uintmax_t)limit);\n\t\t\treturn -1;\n\t\t} else\n\t\t\tdie(\"attempting to allocate %\"PRIuMAX\" over limit %\"PRIuMAX,\n\t\t\t    (uintmax_t)size, (uintmax_t)limit);\n\t}\n\treturn 0;\n}\n\ntry_to_free_t set_try_to_free_routine(try_to_free_t routine)\n{\n\ttry_to_free_t old = try_to_free_routine;\n\tif (!routine)\n\t\troutine = do_nothing;\n\ttry_to_free_routine = routine;\n\treturn old;\n}\n\nchar *xstrdup(const char *str)\n{\n\tchar *ret = strdup(str);\n\tif (!ret) {\n\t\ttry_to_free_routine(strlen(str) + 1);\n\t\tret = strdup(str);\n\t\tif (!ret)\n\t\t\tdie(\"Out of memory, strdup failed\");\n\t}\n\treturn ret;\n}\n\nstatic void *do_xmalloc(size_t size, int gentle)\n{\n\tvoid *ret;\n\n\tif (memory_limit_check(size, gentle))\n\t\treturn NULL;\n\tret = malloc(size);\n\tif (!ret && !size)\n\t\tret = malloc(1);\n\tif (!ret) {\n\t\ttry_to_free_routine(size);\n\t\tret = malloc(size);\n\t\tif (!ret && !size)\n\t\t\tret = malloc(1);\n\t\tif (!ret) {\n\t\t\tif (!gentle)\n\t\t\t\tdie(\"Out of memory, malloc failed (tried to allocate %lu bytes)\",\n\t\t\t\t    (unsigned long)size);\n\t\t\telse {\n\t\t\t\terror(\"Out of memory, malloc failed (tried to allocate %lu bytes)\",\n\t\t\t\t      (unsigned long)size);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n#ifdef XMALLOC_POISON\n\tmemset(ret, 0xA5, size);\n#endif\n\treturn ret;\n}\n\nvoid *xmalloc(size_t size)\n{\n\treturn do_xmalloc(size, 0);\n}\n\nstatic void *do_xmallocz(size_t size, int gentle)\n{\n\tvoid *ret;\n\tif (unsigned_add_overflows(size, 1)) {\n\t\tif (gentle) {\n\t\t\terror(\"Data too large to fit into virtual memory space.\");\n\t\t\treturn NULL;\n\t\t} else\n\t\t\tdie(\"Data too large to fit into virtual memory space.\");\n\t}\n\tret = do_xmalloc(size + 1, gentle);\n\tif (ret)\n\t\t((char*)ret)[size] = 0;\n\treturn ret;\n}\n\nvoid *xmallocz(size_t size)\n{\n\treturn do_xmallocz(size, 0);\n}\n\nvoid *xmallocz_gently(size_t size)\n{\n\treturn do_xmallocz(size, 1);\n}\n\n/*\n * xmemdupz() allocates (len + 1) bytes of memory, duplicates \"len\" bytes of\n * \"data\" to the allocated memory, zero terminates the allocated memory,\n * and returns a pointer to the allocated memory. If the allocation fails,\n * the program dies.\n */\nvoid *xmemdupz(const void *data, size_t len)\n{\n\treturn memcpy(xmallocz(len), data, len);\n}\n\nchar *xstrndup(const char *str, size_t len)\n{\n\tchar *p = memchr(str, '\\0', len);\n\treturn xmemdupz(str, p ? p - str : len);\n}\n\nvoid *xrealloc(void *ptr, size_t size)\n{\n\tvoid *ret;\n\n\tmemory_limit_check(size, 0);\n\tret = realloc(ptr, size);\n\tif (!ret && !size)\n\t\tret = realloc(ptr, 1);\n\tif (!ret) {\n\t\ttry_to_free_routine(size);\n\t\tret = realloc(ptr, size);\n\t\tif (!ret && !size)\n\t\t\tret = realloc(ptr, 1);\n\t\tif (!ret)\n\t\t\tdie(\"Out of memory, realloc failed\");\n\t}\n\treturn ret;\n}\n\nvoid *xcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ret;\n\n\tmemory_limit_check(size * nmemb, 0);\n\tret = calloc(nmemb, size);\n\tif (!ret && (!nmemb || !size))\n\t\tret = calloc(1, 1);\n\tif (!ret) {\n\t\ttry_to_free_routine(nmemb * size);\n\t\tret = calloc(nmemb, size);\n\t\tif (!ret && (!nmemb || !size))\n\t\t\tret = calloc(1, 1);\n\t\tif (!ret)\n\t\t\tdie(\"Out of memory, calloc failed\");\n\t}\n\treturn ret;\n}\n\n/*\n * Limit size of IO chunks, because huge chunks only cause pain.  OS X\n * 64-bit is buggy, returning EINVAL if len >= INT_MAX; and even in\n * the absence of bugs, large chunks can result in bad latencies when\n * you decide to kill the process.\n */\n#define MAX_IO_SIZE (8*1024*1024)\n\n/*\n * xread() is the same a read(), but it automatically restarts read()\n * operations with a recoverable error (EAGAIN and EINTR). xread()\n * DOES NOT GUARANTEE that \"len\" bytes is read even if the data is available.\n */\nssize_t xread(int fd, void *buf, size_t len)\n{\n\tssize_t nr;\n\tif (len > MAX_IO_SIZE)\n\t    len = MAX_IO_SIZE;\n\twhile (1) {\n\t\tnr = read(fd, buf, len);\n\t\tif ((nr < 0) && (errno == EAGAIN || errno == EINTR))\n\t\t\tcontinue;\n\t\treturn nr;\n\t}\n}\n\n/*\n * xwrite() is the same a write(), but it automatically restarts write()\n * operations with a recoverable error (EAGAIN and EINTR). xwrite() DOES NOT\n * GUARANTEE that \"len\" bytes is written even if the operation is successful.\n */\nssize_t xwrite(int fd, const void *buf, size_t len)\n{\n\tssize_t nr;\n\tif (len > MAX_IO_SIZE)\n\t    len = MAX_IO_SIZE;\n\twhile (1) {\n\t\tnr = write(fd, buf, len);\n\t\tif ((nr < 0) && (errno == EAGAIN || errno == EINTR))\n\t\t\tcontinue;\n\t\treturn nr;\n\t}\n}\n\n/*\n * xpread() is the same as pread(), but it automatically restarts pread()\n * operations with a recoverable error (EAGAIN and EINTR). xpread() DOES\n * NOT GUARANTEE that \"len\" bytes is read even if the data is available.\n */\nssize_t xpread(int fd, void *buf, size_t len, off_t offset)\n{\n\tssize_t nr;\n\tif (len > MAX_IO_SIZE)\n\t\tlen = MAX_IO_SIZE;\n\twhile (1) {\n\t\tnr = pread(fd, buf, len, offset);\n\t\tif ((nr < 0) && (errno == EAGAIN || errno == EINTR))\n\t\t\tcontinue;\n\t\treturn nr;\n\t}\n}\n\nssize_t read_in_full(int fd, void *buf, size_t count)\n{\n\tchar *p = buf;\n\tssize_t total = 0;\n\n\twhile (count > 0) {\n\t\tssize_t loaded = xread(fd, p, count);\n\t\tif (loaded < 0)\n\t\t\treturn -1;\n\t\tif (loaded == 0)\n\t\t\treturn total;\n\t\tcount -= loaded;\n\t\tp += loaded;\n\t\ttotal += loaded;\n\t}\n\n\treturn total;\n}\n\nssize_t write_in_full(int fd, const void *buf, size_t count)\n{\n\tconst char *p = buf;\n\tssize_t total = 0;\n\n\twhile (count > 0) {\n\t\tssize_t written = xwrite(fd, p, count);\n\t\tif (written < 0)\n\t\t\treturn -1;\n\t\tif (!written) {\n\t\t\terrno = ENOSPC;\n\t\t\treturn -1;\n\t\t}\n\t\tcount -= written;\n\t\tp += written;\n\t\ttotal += written;\n\t}\n\n\treturn total;\n}\n\nssize_t pread_in_full(int fd, void *buf, size_t count, off_t offset)\n{\n\tchar *p = buf;\n\tssize_t total = 0;\n\n\twhile (count > 0) {\n\t\tssize_t loaded = xpread(fd, p, count, offset);\n\t\tif (loaded < 0)\n\t\t\treturn -1;\n\t\tif (loaded == 0)\n\t\t\treturn total;\n\t\tcount -= loaded;\n\t\tp += loaded;\n\t\ttotal += loaded;\n\t\toffset += loaded;\n\t}\n\n\treturn total;\n}\n\nint xdup(int fd)\n{\n\tint ret = dup(fd);\n\tif (ret < 0)\n\t\tdie_errno(\"dup failed\");\n\treturn ret;\n}\n\nFILE *xfdopen(int fd, const char *mode)\n{\n\tFILE *stream = fdopen(fd, mode);\n\tif (stream == NULL)\n\t\tdie_errno(\"Out of memory? fdopen failed\");\n\treturn stream;\n}\n\nint xmkstemp(char *template)\n{\n\tint fd;\n\tchar origtemplate[PATH_MAX];\n\tstrlcpy(origtemplate, template, sizeof(origtemplate));\n\n\tfd = mkstemp(template);\n\tif (fd < 0) {\n\t\tint saved_errno = errno;\n\t\tconst char *nonrelative_template;\n\n\t\tif (strlen(template) != strlen(origtemplate))\n\t\t\ttemplate = origtemplate;\n\n\t\tnonrelative_template = absolute_path(template);\n\t\terrno = saved_errno;\n\t\tdie_errno(\"Unable to create temporary file '%s'\",\n\t\t\tnonrelative_template);\n\t}\n\treturn fd;\n}\n\n/* git_mkstemp() - create tmp file honoring TMPDIR variable */\nint git_mkstemp(char *path, size_t len, const char *template)\n{\n\tconst char *tmp;\n\tsize_t n;\n\n\ttmp = getenv(\"TMPDIR\");\n\tif (!tmp)\n\t\ttmp = \"/tmp\";\n\tn = snprintf(path, len, \"%s/%s\", tmp, template);\n\tif (len <= n) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\treturn mkstemp(path);\n}\n\n/* git_mkstemps() - create tmp file with suffix honoring TMPDIR variable. */\nint git_mkstemps(char *path, size_t len, const char *template, int suffix_len)\n{\n\tconst char *tmp;\n\tsize_t n;\n\n\ttmp = getenv(\"TMPDIR\");\n\tif (!tmp)\n\t\ttmp = \"/tmp\";\n\tn = snprintf(path, len, \"%s/%s\", tmp, template);\n\tif (len <= n) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\treturn mkstemps(path, suffix_len);\n}\n\n/* Adapted from libiberty's mkstemp.c. */\n\n#undef TMP_MAX\n#define TMP_MAX 16384\n\nint git_mkstemps_mode(char *pattern, int suffix_len, int mode)\n{\n\tstatic const char letters[] =\n\t\t\"abcdefghijklmnopqrstuvwxyz\"\n\t\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t\"0123456789\";\n\tstatic const int num_letters = 62;\n\tuint64_t value;\n\tstruct timeval tv;\n\tchar *template;\n\tsize_t len;\n\tint fd, count;\n\n\tlen = strlen(pattern);\n\n\tif (len < 6 + suffix_len) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (strncmp(&pattern[len - 6 - suffix_len], \"XXXXXX\", 6)) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Replace pattern's XXXXXX characters with randomness.\n\t * Try TMP_MAX different filenames.\n\t */\n\tgettimeofday(&tv, NULL);\n\tvalue = ((size_t)(tv.tv_usec << 16)) ^ tv.tv_sec ^ getpid();\n\ttemplate = &pattern[len - 6 - suffix_len];\n\tfor (count = 0; count < TMP_MAX; ++count) {\n\t\tuint64_t v = value;\n\t\t/* Fill in the random bits. */\n\t\ttemplate[0] = letters[v % num_letters]; v /= num_letters;\n\t\ttemplate[1] = letters[v % num_letters]; v /= num_letters;\n\t\ttemplate[2] = letters[v % num_letters]; v /= num_letters;\n\t\ttemplate[3] = letters[v % num_letters]; v /= num_letters;\n\t\ttemplate[4] = letters[v % num_letters]; v /= num_letters;\n\t\ttemplate[5] = letters[v % num_letters]; v /= num_letters;\n\n\t\tfd = open(pattern, O_CREAT | O_EXCL | O_RDWR, mode);\n\t\tif (fd >= 0)\n\t\t\treturn fd;\n\t\t/*\n\t\t * Fatal error (EPERM, ENOSPC etc).\n\t\t * It doesn't make sense to loop.\n\t\t */\n\t\tif (errno != EEXIST)\n\t\t\tbreak;\n\t\t/*\n\t\t * This is a random value.  It is only necessary that\n\t\t * the next TMP_MAX values generated by adding 7777 to\n\t\t * VALUE are different with (module 2^32).\n\t\t */\n\t\tvalue += 7777;\n\t}\n\t/* We return the null string if we can't find a unique file name.  */\n\tpattern[0] = '\\0';\n\treturn -1;\n}\n\nint git_mkstemp_mode(char *pattern, int mode)\n{\n\t/* mkstemp is just mkstemps with no suffix */\n\treturn git_mkstemps_mode(pattern, 0, mode);\n}\n\n#ifdef NO_MKSTEMPS\nint gitmkstemps(char *pattern, int suffix_len)\n{\n\treturn git_mkstemps_mode(pattern, suffix_len, 0600);\n}\n#endif\n\nint xmkstemp_mode(char *template, int mode)\n{\n\tint fd;\n\tchar origtemplate[PATH_MAX];\n\tstrlcpy(origtemplate, template, sizeof(origtemplate));\n\n\tfd = git_mkstemp_mode(template, mode);\n\tif (fd < 0) {\n\t\tint saved_errno = errno;\n\t\tconst char *nonrelative_template;\n\n\t\tif (!template[0])\n\t\t\ttemplate = origtemplate;\n\n\t\tnonrelative_template = absolute_path(template);\n\t\terrno = saved_errno;\n\t\tdie_errno(\"Unable to create temporary file '%s'\",\n\t\t\tnonrelative_template);\n\t}\n\treturn fd;\n}\n\nstatic int warn_if_unremovable(const char *op, const char *file, int rc)\n{\n\tint err;\n\tif (!rc || errno == ENOENT)\n\t\treturn 0;\n\terr = errno;\n\twarning(\"unable to %s %s: %s\", op, file, strerror(errno));\n\terrno = err;\n\treturn rc;\n}\n\nint unlink_or_msg(const char *file, struct strbuf *err)\n{\n\tint rc = unlink(file);\n\n\tassert(err);\n\n\tif (!rc || errno == ENOENT)\n\t\treturn 0;\n\n\tstrbuf_addf(err, \"unable to unlink %s: %s\",\n\t\t    file, strerror(errno));\n\treturn -1;\n}\n\nint unlink_or_warn(const char *file)\n{\n\treturn warn_if_unremovable(\"unlink\", file, unlink(file));\n}\n\nint rmdir_or_warn(const char *file)\n{\n\treturn warn_if_unremovable(\"rmdir\", file, rmdir(file));\n}\n\nint remove_or_warn(unsigned int mode, const char *file)\n{\n\treturn S_ISGITLINK(mode) ? rmdir_or_warn(file) : unlink_or_warn(file);\n}\n\nvoid warn_on_inaccessible(const char *path)\n{\n\twarning(_(\"unable to access '%s': %s\"), path, strerror(errno));\n}\n\nstatic int access_error_is_ok(int err, unsigned flag)\n{\n\treturn err == ENOENT || err == ENOTDIR ||\n\t\t((flag & ACCESS_EACCES_OK) && err == EACCES);\n}\n\nint access_or_warn(const char *path, int mode, unsigned flag)\n{\n\tint ret = access(path, mode);\n\tif (ret && !access_error_is_ok(errno, flag))\n\t\twarn_on_inaccessible(path);\n\treturn ret;\n}\n\nint access_or_die(const char *path, int mode, unsigned flag)\n{\n\tint ret = access(path, mode);\n\tif (ret && !access_error_is_ok(errno, flag))\n\t\tdie_errno(_(\"unable to access '%s'\"), path);\n\treturn ret;\n}\n\nstruct passwd *xgetpwuid_self(void)\n{\n\tstruct passwd *pw;\n\n\terrno = 0;\n\tpw = getpwuid(getuid());\n\tif (!pw)\n\t\tdie(_(\"unable to look up current user in the passwd file: %s\"),\n\t\t    errno ? strerror(errno) : _(\"no such user\"));\n\treturn pw;\n}\n\nchar *xgetcwd(void)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tif (strbuf_getcwd(&sb))\n\t\tdie_errno(_(\"unable to get current working directory\"));\n\treturn strbuf_detach(&sb, NULL);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "007ec0d8eac529579cc00b14f9baaddb7ac68487",
  "sha1_ok": true,
  "size": 11950
}
