{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJnZXR0ZXh0LmgiCiNpbmNsdWRlICJwYWNrLXJldmluZGV4LmgiCiNpbmNsdWRlICJvYmplY3Qtc3RvcmUuaCIKI2luY2x1ZGUgInBhY2tmaWxlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgIm1pZHguaCIKI2luY2x1ZGUgImNzdW0tZmlsZS5oIgoKc3RydWN0IHJldmluZGV4X2VudHJ5IHsKCW9mZl90IG9mZnNldDsKCXVuc2lnbmVkIGludCBucjsKfTsKCi8qCiAqIFBhY2sgaW5kZXggZm9yIGV4aXN0aW5nIHBhY2tzIGdpdmUgdXMgZWFzeSBhY2Nlc3MgdG8gdGhlIG9mZnNldHMgaW50bwogKiBjb3JyZXNwb25kaW5nIHBhY2sgZmlsZSB3aGVyZSBlYWNoIG9iamVjdCdzIGRhdGEgc3RhcnRzLCBidXQgdGhlIGVudHJpZXMKICogZG8gbm90IHN0b3JlIHRoZSBzaXplIG9mIHRoZSBjb21wcmVzc2VkIHJlcHJlc2VudGF0aW9uICh1bmNvbXByZXNzZWQKICogc2l6ZSBpcyBlYXNpbHkgYXZhaWxhYmxlIGJ5IGV4YW1pbmluZyB0aGUgcGFjayBlbnRyeSBoZWFkZXIpLiAgSXQgaXMKICogYWxzbyByYXRoZXIgZXhwZW5zaXZlIHRvIGZpbmQgdGhlIHNoYTEgZm9yIGFuIG9iamVjdCBnaXZlbiBpdHMgb2Zmc2V0LgogKgogKiBUaGUgcGFjayBpbmRleCBmaWxlIGlzIHNvcnRlZCBieSBvYmplY3QgbmFtZSBtYXBwaW5nIHRvIG9mZnNldDsKICogdGhpcyByZXZpbmRleCBhcnJheSBpcyBhIGxpc3Qgb2Ygb2Zmc2V0L2luZGV4X25yIHBhaXJzCiAqIG9yZGVyZWQgYnkgb2Zmc2V0LCBzbyBpZiB5b3Uga25vdyB0aGUgb2Zmc2V0IG9mIGFuIG9iamVjdCwgbmV4dCBvZmZzZXQKICogaXMgd2hlcmUgaXRzIHBhY2tlZCByZXByZXNlbnRhdGlvbiBlbmRzIGFuZCB0aGUgaW5kZXhfbnIgY2FuIGJlIHVzZWQgdG8KICogZ2V0IHRoZSBvYmplY3Qgc2hhMSBmcm9tIHRoZSBtYWluIGluZGV4LgogKi8KCi8qCiAqIFRoaXMgaXMgYSBsZWFzdC1zaWduaWZpY2FudC1kaWdpdCByYWRpeCBzb3J0LgogKgogKiBJdCBzb3J0cyBlYWNoIG9mIHRoZSAibiIgaXRlbXMgaW4gImVudHJpZXMiIGJ5IGl0cyBvZmZzZXQgZmllbGQuIFRoZSAibWF4IgogKiBwYXJhbWV0ZXIgbXVzdCBiZSBhdCBsZWFzdCBhcyBsYXJnZSBhcyB0aGUgbGFyZ2VzdCBvZmZzZXQgaW4gdGhlIGFycmF5LAogKiBhbmQgbGV0cyB1cyBxdWl0IHRoZSBzb3J0IGVhcmx5LgogKi8Kc3RhdGljIHZvaWQgc29ydF9yZXZpbmRleChzdHJ1Y3QgcmV2aW5kZXhfZW50cnkgKmVudHJpZXMsIHVuc2lnbmVkIG4sIG9mZl90IG1heCkKewoJLyoKCSAqIFdlIHVzZSBhICJkaWdpdCIgc2l6ZSBvZiAxNiBiaXRzLiBUaGF0IGtlZXBzIG91ciBtZW1vcnkKCSAqIHVzYWdlIHJlYXNvbmFibGUsIGFuZCB3ZSBjYW4gZ2VuZXJhbGx5IChmb3IgYSA0RyBvciBzbWFsbGVyCgkgKiBwYWNrZmlsZSkgcXVpdCBhZnRlciB0d28gcm91bmRzIG9mIHJhZGl4LXNvcnRpbmcuCgkgKi8KI2RlZmluZSBESUdJVF9TSVpFICgxNikKI2RlZmluZSBCVUNLRVRTICgxIDw8IERJR0lUX1NJWkUpCgkvKgoJICogV2Ugd2FudCB0byBrbm93IHRoZSBidWNrZXQgdGhhdCBhW2ldIHdpbGwgZ28gaW50byB3aGVuIHdlIGFyZSB1c2luZwoJICogdGhlIGRpZ2l0IHRoYXQgaXMgTiBiaXRzIGZyb20gdGhlIChsZWFzdCBzaWduaWZpY2FudCkgZW5kLgoJICovCiNkZWZpbmUgQlVDS0VUX0ZPUihhLCBpLCBiaXRzKSAoKChhKVsoaSldLm9mZnNldCA+PiAoYml0cykpICYgKEJVQ0tFVFMtMSkpCgoJLyoKCSAqIFdlIG5lZWQgTyhuKSB0ZW1wb3Jhcnkgc3RvcmFnZS4gUmF0aGVyIHRoYW4gZG8gYW4gZXh0cmEgY29weSBvZiB0aGUKCSAqIHBhcnRpYWwgcmVzdWx0cyBpbnRvICJlbnRyaWVzIiwgd2Ugc29ydCBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZQoJICogcmVhbCBhcnJheSBhbmQgdGVtcG9yYXJ5IHN0b3JhZ2UuIEluIGVhY2ggaXRlcmF0aW9uIG9mIHRoZSBsb29wLCB3ZQoJICoga2VlcCB0cmFjayBvZiB0aGVtIHdpdGggYWxpYXMgcG9pbnRlcnMsIGFsd2F5cyBzb3J0aW5nIGZyb20gImZyb20iCgkgKiB0byAidG8iLgoJICovCglzdHJ1Y3QgcmV2aW5kZXhfZW50cnkgKnRtcCwgKmZyb20sICp0bzsKCWludCBiaXRzOwoJdW5zaWduZWQgKnBvczsKCglBTExPQ19BUlJBWShwb3MsIEJVQ0tFVFMpOwoJQUxMT0NfQVJSQVkodG1wLCBuKTsKCWZyb20gPSBlbnRyaWVzOwoJdG8gPSB0bXA7CgoJLyoKCSAqIElmIChtYXggPj4gYml0cykgaXMgemVybywgdGhlbiB3ZSBrbm93IHRoYXQgdGhlIHJhZGl4IGRpZ2l0IHdlIGFyZQoJICogb24gKGFuZCBhbnkgaGlnaGVyKSB3aWxsIGJlIHplcm8gZm9yIGFsbCBlbnRyaWVzLCBhbmQgb3VyIGxvb3Agd2lsbAoJICogYmUgYSBuby1vcCwgYXMgZXZlcnlib2R5IGxhbmRzIGluIHRoZSBzYW1lIHplcm8tdGggYnVja2V0LgoJICovCglmb3IgKGJpdHMgPSAwOyBtYXggPj4gYml0czsgYml0cyArPSBESUdJVF9TSVpFKSB7CgkJdW5zaWduZWQgaTsKCgkJbWVtc2V0KHBvcywgMCwgQlVDS0VUUyAqIHNpemVvZigqcG9zKSk7CgoJCS8qCgkJICogV2Ugd2FudCBwb3NbaV0gdG8gc3RvcmUgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGVsZW1lbnQgdGhhdAoJCSAqIHdpbGwgZ28gaW4gYnVja2V0ICJpIiAoYWN0dWFsbHkgb25lIHBhc3QgdGhlIGxhc3QgZWxlbWVudCkuCgkJICogVG8gZG8gdGhpcywgd2UgZmlyc3QgY291bnQgdGhlIGl0ZW1zIHRoYXQgd2lsbCBnbyBpbiBlYWNoCgkJICogYnVja2V0LCB3aGljaCBnaXZlcyB1cyBhIHJlbGF0aXZlIG9mZnNldCBmcm9tIHRoZSBsYXN0CgkJICogYnVja2V0LiBXZSBjYW4gdGhlbiBjdW11bGF0aXZlbHkgYWRkIHRoZSBpbmRleCBmcm9tIHRoZQoJCSAqIHByZXZpb3VzIGJ1Y2tldCB0byBnZXQgdGhlIHRydWUgaW5kZXguCgkJICovCgkJZm9yIChpID0gMDsgaSA8IG47IGkrKykKCQkJcG9zW0JVQ0tFVF9GT1IoZnJvbSwgaSwgYml0cyldKys7CgkJZm9yIChpID0gMTsgaSA8IEJVQ0tFVFM7IGkrKykKCQkJcG9zW2ldICs9IHBvc1tpLTFdOwoKCQkvKgoJCSAqIE5vdyB3ZSBjYW4gZHJvcCB0aGUgZWxlbWVudHMgaW50byB0aGVpciBjb3JyZWN0IGJ1Y2tldHMgKGluCgkJICogb3VyIHRlbXBvcmFyeSBhcnJheSkuICBXZSBpdGVyYXRlIHRoZSBwb3MgY291bnRlciBiYWNrd2FyZHMKCQkgKiB0byBhdm9pZCB1c2luZyBhbiBleHRyYSBpbmRleCB0byBjb3VudCB1cC4gQW5kIHNpbmNlIHdlIGFyZQoJCSAqIGdvaW5nIGJhY2t3YXJkcyB0aGVyZSwgd2UgbXVzdCBhbHNvIGdvIGJhY2t3YXJkcyB0aHJvdWdoIHRoZQoJCSAqIGFycmF5IGl0c2VsZiwgdG8ga2VlcCB0aGUgc29ydCBzdGFibGUuCgkJICoKCQkgKiBOb3RlIHRoYXQgd2UgdXNlIGFuIHVuc2lnbmVkIGl0ZXJhdG9yIHRvIG1ha2Ugc3VyZSB3ZSBjYW4KCQkgKiBoYW5kbGUgMl4zMi0xIG9iamVjdHMsIGV2ZW4gb24gYSAzMi1iaXQgc3lzdGVtLiBCdXQgdGhpcwoJCSAqIG1lYW5zIHdlIGNhbm5vdCB1c2UgdGhlIG1vcmUgb2J2aW91cyAiaSA+PSAwIiBsb29wIGNvbmRpdGlvbgoJCSAqIGZvciBjb3VudGluZyBiYWNrd2FyZHMsIGFuZCBtdXN0IGluc3RlYWQgY2hlY2sgZm9yCgkJICogd3JhcC1hcm91bmQgd2l0aCBVSU5UX01BWC4KCQkgKi8KCQlmb3IgKGkgPSBuIC0gMTsgaSAhPSBVSU5UX01BWDsgaS0tKQoJCQl0b1stLXBvc1tCVUNLRVRfRk9SKGZyb20sIGksIGJpdHMpXV0gPSBmcm9tW2ldOwoKCQkvKgoJCSAqIE5vdyAidG8iIGNvbnRhaW5zIHRoZSBtb3N0IHNvcnRlZCBsaXN0LCBzbyB3ZSBzd2FwICJmcm9tIiBhbmQKCQkgKiAidG8iIGZvciB0aGUgbmV4dCBpdGVyYXRpb24uCgkJICovCgkJU1dBUChmcm9tLCB0byk7Cgl9CgoJLyoKCSAqIElmIHdlIGVuZGVkIHdpdGggb3VyIGRhdGEgaW4gdGhlIG9yaWdpbmFsIGFycmF5LCBncmVhdC4gSWYgbm90LAoJICogd2UgaGF2ZSB0byBtb3ZlIGl0IGJhY2sgZnJvbSB0aGUgdGVtcG9yYXJ5IHN0b3JhZ2UuCgkgKi8KCWlmIChmcm9tICE9IGVudHJpZXMpCgkJQ09QWV9BUlJBWShlbnRyaWVzLCB0bXAsIG4pOwoJZnJlZSh0bXApOwoJZnJlZShwb3MpOwoKI3VuZGVmIEJVQ0tFVF9GT1IKI3VuZGVmIEJVQ0tFVFMKI3VuZGVmIERJR0lUX1NJWkUKfQoKLyoKICogT3JkZXJlZCBsaXN0IG9mIG9mZnNldHMgb2Ygb2JqZWN0cyBpbiB0aGUgcGFjay4KICovCnN0YXRpYyB2b2lkIGNyZWF0ZV9wYWNrX3JldmluZGV4KHN0cnVjdCBwYWNrZWRfZ2l0ICpwKQp7Cgljb25zdCB1bnNpZ25lZCBudW1fZW50ID0gcC0+bnVtX29iamVjdHM7Cgl1bnNpZ25lZCBpOwoJY29uc3QgY2hhciAqaW5kZXggPSBwLT5pbmRleF9kYXRhOwoJY29uc3QgdW5zaWduZWQgaGFzaHN6ID0gdGhlX2hhc2hfYWxnby0+cmF3c3o7CgoJQUxMT0NfQVJSQVkocC0+cmV2aW5kZXgsIG51bV9lbnQgKyAxKTsKCWluZGV4ICs9IDQgKiAyNTY7CgoJaWYgKHAtPmluZGV4X3ZlcnNpb24gPiAxKSB7CgkJY29uc3QgdWludDMyX3QgKm9mZl8zMiA9CgkJCSh1aW50MzJfdCAqKShpbmRleCArIDggKyAoc2l6ZV90KXAtPm51bV9vYmplY3RzICogKGhhc2hzeiArIDQpKTsKCQljb25zdCB1aW50MzJfdCAqb2ZmXzY0ID0gb2ZmXzMyICsgcC0+bnVtX29iamVjdHM7CgkJZm9yIChpID0gMDsgaSA8IG51bV9lbnQ7IGkrKykgewoJCQljb25zdCB1aW50MzJfdCBvZmYgPSBudG9obCgqb2ZmXzMyKyspOwoJCQlpZiAoIShvZmYgJiAweDgwMDAwMDAwKSkgewoJCQkJcC0+cmV2aW5kZXhbaV0ub2Zmc2V0ID0gb2ZmOwoJCQl9IGVsc2UgewoJCQkJcC0+cmV2aW5kZXhbaV0ub2Zmc2V0ID0gZ2V0X2JlNjQob2ZmXzY0KTsKCQkJCW9mZl82NCArPSAyOwoJCQl9CgkJCXAtPnJldmluZGV4W2ldLm5yID0gaTsKCQl9Cgl9IGVsc2UgewoJCWZvciAoaSA9IDA7IGkgPCBudW1fZW50OyBpKyspIHsKCQkJY29uc3QgdWludDMyX3QgaGwgPSAqKCh1aW50MzJfdCAqKShpbmRleCArIChoYXNoc3ogKyA0KSAqIGkpKTsKCQkJcC0+cmV2aW5kZXhbaV0ub2Zmc2V0ID0gbnRvaGwoaGwpOwoJCQlwLT5yZXZpbmRleFtpXS5uciA9IGk7CgkJfQoJfQoKCS8qCgkgKiBUaGlzIGtub3dzIHRoZSBwYWNrIGZvcm1hdCAtLSB0aGUgaGFzaCB0cmFpbGVyCgkgKiBmb2xsb3dzIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBsYXN0IG9iamVjdCBkYXRhLgoJICovCglwLT5yZXZpbmRleFtudW1fZW50XS5vZmZzZXQgPSBwLT5wYWNrX3NpemUgLSBoYXNoc3o7CglwLT5yZXZpbmRleFtudW1fZW50XS5uciA9IC0xOwoJc29ydF9yZXZpbmRleChwLT5yZXZpbmRleCwgbnVtX2VudCwgcC0+cGFja19zaXplKTsKfQoKc3RhdGljIGludCBjcmVhdGVfcGFja19yZXZpbmRleF9pbl9tZW1vcnkoc3RydWN0IHBhY2tlZF9naXQgKnApCnsKCWlmIChnaXRfZW52X2Jvb2woR0lUX1RFU1RfUkVWX0lOREVYX0RJRV9JTl9NRU1PUlksIDApKQoJCWRpZSgiZHlpbmcgYXMgcmVxdWVzdGVkIGJ5ICclcyciLAoJCSAgICBHSVRfVEVTVF9SRVZfSU5ERVhfRElFX0lOX01FTU9SWSk7CglpZiAob3Blbl9wYWNrX2luZGV4KHApKQoJCXJldHVybiAtMTsKCWNyZWF0ZV9wYWNrX3JldmluZGV4KHApOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBjaGFyICpwYWNrX3JldmluZGV4X2ZpbGVuYW1lKHN0cnVjdCBwYWNrZWRfZ2l0ICpwKQp7CglzaXplX3QgbGVuOwoJaWYgKCFzdHJpcF9zdWZmaXgocC0+cGFja19uYW1lLCAiLnBhY2siLCAmbGVuKSkKCQlCVUcoInBhY2tfbmFtZSBkb2VzIG5vdCBlbmQgaW4gLnBhY2siKTsKCXJldHVybiB4c3RyZm10KCIlLipzLnJldiIsIChpbnQpbGVuLCBwLT5wYWNrX25hbWUpOwp9CgojZGVmaW5lIFJJRFhfSEVBREVSX1NJWkUgKDEyKQojZGVmaW5lIFJJRFhfTUlOX1NJWkUgKFJJRFhfSEVBREVSX1NJWkUgKyAoMiAqIHRoZV9oYXNoX2FsZ28tPnJhd3N6KSkKCnN0cnVjdCByZXZpbmRleF9oZWFkZXIgewoJdWludDMyX3Qgc2lnbmF0dXJlOwoJdWludDMyX3QgdmVyc2lvbjsKCXVpbnQzMl90IGhhc2hfaWQ7Cn07CgpzdGF0aWMgaW50IGxvYWRfcmV2aW5kZXhfZnJvbV9kaXNrKGNoYXIgKnJldmluZGV4X25hbWUsCgkJCQkgICB1aW50MzJfdCBudW1fb2JqZWN0cywKCQkJCSAgIGNvbnN0IHVpbnQzMl90ICoqZGF0YV9wLCBzaXplX3QgKmxlbl9wKQp7CglpbnQgZmQsIHJldCA9IDA7CglzdHJ1Y3Qgc3RhdCBzdDsKCXZvaWQgKmRhdGEgPSBOVUxMOwoJc2l6ZV90IHJldmluZGV4X3NpemU7CglzdHJ1Y3QgcmV2aW5kZXhfaGVhZGVyICpoZHI7CgoJaWYgKGdpdF9lbnZfYm9vbChHSVRfVEVTVF9SRVZfSU5ERVhfRElFX09OX0RJU0ssIDApKQoJCWRpZSgiZHlpbmcgYXMgcmVxdWVzdGVkIGJ5ICclcyciLCBHSVRfVEVTVF9SRVZfSU5ERVhfRElFX09OX0RJU0spOwoKCWZkID0gZ2l0X29wZW4ocmV2aW5kZXhfbmFtZSk7CgoJaWYgKGZkIDwgMCkgewoJCXJldCA9IC0xOwoJCWdvdG8gY2xlYW51cDsKCX0KCWlmIChmc3RhdChmZCwgJnN0KSkgewoJCXJldCA9IGVycm9yX2Vycm5vKF8oImZhaWxlZCB0byByZWFkICVzIiksIHJldmluZGV4X25hbWUpOwoJCWdvdG8gY2xlYW51cDsKCX0KCglyZXZpbmRleF9zaXplID0geHNpemVfdChzdC5zdF9zaXplKTsKCglpZiAocmV2aW5kZXhfc2l6ZSA8IFJJRFhfTUlOX1NJWkUpIHsKCQlyZXQgPSBlcnJvcihfKCJyZXZlcnNlLWluZGV4IGZpbGUgJXMgaXMgdG9vIHNtYWxsIiksIHJldmluZGV4X25hbWUpOwoJCWdvdG8gY2xlYW51cDsKCX0KCglpZiAocmV2aW5kZXhfc2l6ZSAtIFJJRFhfTUlOX1NJWkUgIT0gc3RfbXVsdChzaXplb2YodWludDMyX3QpLCBudW1fb2JqZWN0cykpIHsKCQlyZXQgPSBlcnJvcihfKCJyZXZlcnNlLWluZGV4IGZpbGUgJXMgaXMgY29ycnVwdCIpLCByZXZpbmRleF9uYW1lKTsKCQlnb3RvIGNsZWFudXA7Cgl9CgoJZGF0YSA9IHhtbWFwKE5VTEwsIHJldmluZGV4X3NpemUsIFBST1RfUkVBRCwgTUFQX1BSSVZBVEUsIGZkLCAwKTsKCWhkciA9IGRhdGE7CgoJaWYgKG50b2hsKGhkci0+c2lnbmF0dXJlKSAhPSBSSURYX1NJR05BVFVSRSkgewoJCXJldCA9IGVycm9yKF8oInJldmVyc2UtaW5kZXggZmlsZSAlcyBoYXMgdW5rbm93biBzaWduYXR1cmUiKSwgcmV2aW5kZXhfbmFtZSk7CgkJZ290byBjbGVhbnVwOwoJfQoJaWYgKG50b2hsKGhkci0+dmVyc2lvbikgIT0gMSkgewoJCXJldCA9IGVycm9yKF8oInJldmVyc2UtaW5kZXggZmlsZSAlcyBoYXMgdW5zdXBwb3J0ZWQgdmVyc2lvbiAlIlBSSXUzMiksCgkJCSAgICByZXZpbmRleF9uYW1lLCBudG9obChoZHItPnZlcnNpb24pKTsKCQlnb3RvIGNsZWFudXA7Cgl9CglpZiAoIShudG9obChoZHItPmhhc2hfaWQpID09IDEgfHwgbnRvaGwoaGRyLT5oYXNoX2lkKSA9PSAyKSkgewoJCXJldCA9IGVycm9yKF8oInJldmVyc2UtaW5kZXggZmlsZSAlcyBoYXMgdW5zdXBwb3J0ZWQgaGFzaCBpZCAlIlBSSXUzMiksCgkJCSAgICByZXZpbmRleF9uYW1lLCBudG9obChoZHItPmhhc2hfaWQpKTsKCQlnb3RvIGNsZWFudXA7Cgl9CgpjbGVhbnVwOgoJaWYgKHJldCkgewoJCWlmIChkYXRhKQoJCQltdW5tYXAoZGF0YSwgcmV2aW5kZXhfc2l6ZSk7Cgl9IGVsc2UgewoJCSpsZW5fcCA9IHJldmluZGV4X3NpemU7CgkJKmRhdGFfcCA9IChjb25zdCB1aW50MzJfdCAqKWRhdGE7Cgl9CgoJaWYgKGZkID49IDApCgkJY2xvc2UoZmQpOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIGludCBsb2FkX3BhY2tfcmV2aW5kZXhfZnJvbV9kaXNrKHN0cnVjdCBwYWNrZWRfZ2l0ICpwKQp7CgljaGFyICpyZXZpbmRleF9uYW1lOwoJaW50IHJldDsKCWlmIChvcGVuX3BhY2tfaW5kZXgocCkpCgkJcmV0dXJuIC0xOwoKCXJldmluZGV4X25hbWUgPSBwYWNrX3JldmluZGV4X2ZpbGVuYW1lKHApOwoKCXJldCA9IGxvYWRfcmV2aW5kZXhfZnJvbV9kaXNrKHJldmluZGV4X25hbWUsCgkJCQkgICAgICBwLT5udW1fb2JqZWN0cywKCQkJCSAgICAgICZwLT5yZXZpbmRleF9tYXAsCgkJCQkgICAgICAmcC0+cmV2aW5kZXhfc2l6ZSk7CglpZiAocmV0KQoJCWdvdG8gY2xlYW51cDsKCglwLT5yZXZpbmRleF9kYXRhID0gKGNvbnN0IHVpbnQzMl90ICopKChjb25zdCBjaGFyICopcC0+cmV2aW5kZXhfbWFwICsgUklEWF9IRUFERVJfU0laRSk7CgpjbGVhbnVwOgoJZnJlZShyZXZpbmRleF9uYW1lKTsKCXJldHVybiByZXQ7Cn0KCmludCBsb2FkX3BhY2tfcmV2aW5kZXgoc3RydWN0IHJlcG9zaXRvcnkgKnIsIHN0cnVjdCBwYWNrZWRfZ2l0ICpwKQp7CglpZiAocC0+cmV2aW5kZXggfHwgcC0+cmV2aW5kZXhfZGF0YSkKCQlyZXR1cm4gMDsKCglwcmVwYXJlX3JlcG9fc2V0dGluZ3Mocik7CgoJaWYgKHItPnNldHRpbmdzLnBhY2tfcmVhZF9yZXZlcnNlX2luZGV4ICYmCgkgICAgIWxvYWRfcGFja19yZXZpbmRleF9mcm9tX2Rpc2socCkpCgkJcmV0dXJuIDA7CgllbHNlIGlmICghY3JlYXRlX3BhY2tfcmV2aW5kZXhfaW5fbWVtb3J5KHApKQoJCXJldHVybiAwOwoJcmV0dXJuIC0xOwp9CgovKgogKiB2ZXJpZnlfcGFja19yZXZpbmRleCB2ZXJpZmllcyB0aGF0IHRoZSBvbi1kaXNrIHJldi1pbmRleCBmb3IgdGhlIGdpdmVuCiAqIHBhY2stZmlsZSBpcyB0aGUgc2FtZSB0aGF0IHdvdWxkIGJlIGNyZWF0ZWQgaWYgd3JpdHRlbiBmcm9tIHNjcmF0Y2guCiAqCiAqIEEgbmVnYXRpdmUgbnVtYmVyIGlzIHJldHVybmVkIG9uIGVycm9yLgogKi8KaW50IHZlcmlmeV9wYWNrX3JldmluZGV4KHN0cnVjdCBwYWNrZWRfZ2l0ICpwKQp7CgkvKiBEbyBub3QgYm90aGVyIGNoZWNraW5nIGlmIG5vdCBpbml0aWFsaXplZC4gKi8KCWlmICghcC0+cmV2aW5kZXhfbWFwKQoJCXJldHVybiAwOwoKCWlmICghaGFzaGZpbGVfY2hlY2tzdW1fdmFsaWQoKGNvbnN0IHVuc2lnbmVkIGNoYXIgKilwLT5yZXZpbmRleF9tYXAsIHAtPnJldmluZGV4X3NpemUpKSB7CgkJZXJyb3IoXygiaW52YWxpZCBjaGVja3N1bSIpKTsKCQlyZXR1cm4gLTE7Cgl9CgoJcmV0dXJuIDA7Cn0KCmludCBsb2FkX21pZHhfcmV2aW5kZXgoc3RydWN0IG11bHRpX3BhY2tfaW5kZXggKm0pCnsKCXN0cnVjdCBzdHJidWYgcmV2aW5kZXhfbmFtZSA9IFNUUkJVRl9JTklUOwoJaW50IHJldDsKCglpZiAobS0+cmV2aW5kZXhfZGF0YSkKCQlyZXR1cm4gMDsKCglpZiAobS0+Y2h1bmtfcmV2aW5kZXgpIHsKCQkvKgoJCSAqIElmIHRoZSBNSURYIGBtYCBoYXMgYSBgUklEWGAgY2h1bmssIHRoZW4gdXNlIGl0cyBjb250ZW50cyBmb3IKCQkgKiB0aGUgcmV2ZXJzZSBpbmRleCBpbnN0ZWFkIG9mIHRyeWluZyB0byBsb2FkIGEgc2VwYXJhdGUgYC5yZXZgCgkJICogZmlsZS4KCQkgKgoJCSAqIE5vdGUgdGhhdCB3ZSBkbyAqbm90KiBzZXQgYG0tPnJldmluZGV4X21hcGAgaGVyZSwgc2luY2Ugd2UgZG8KCQkgKiBub3Qgd2FudCB0byBhY2NpZGVudGFsbHkgY2FsbCBtdW5tYXAoKSBpbiB0aGUgbWlkZGxlIG9mIHRoZQoJCSAqIE1JRFguCgkJICovCgkJdHJhY2UyX2RhdGFfc3RyaW5nKCJsb2FkX21pZHhfcmV2aW5kZXgiLCB0aGVfcmVwb3NpdG9yeSwKCQkJCSAgICJzb3VyY2UiLCAibWlkeCIpOwoJCW0tPnJldmluZGV4X2RhdGEgPSAoY29uc3QgdWludDMyX3QgKiltLT5jaHVua19yZXZpbmRleDsKCQlyZXR1cm4gMDsKCX0KCgl0cmFjZTJfZGF0YV9zdHJpbmcoImxvYWRfbWlkeF9yZXZpbmRleCIsIHRoZV9yZXBvc2l0b3J5LAoJCQkgICAic291cmNlIiwgInJldiIpOwoKCWdldF9taWR4X3Jldl9maWxlbmFtZSgmcmV2aW5kZXhfbmFtZSwgbSk7CgoJcmV0ID0gbG9hZF9yZXZpbmRleF9mcm9tX2Rpc2socmV2aW5kZXhfbmFtZS5idWYsCgkJCQkgICAgICBtLT5udW1fb2JqZWN0cywKCQkJCSAgICAgICZtLT5yZXZpbmRleF9tYXAsCgkJCQkgICAgICAmbS0+cmV2aW5kZXhfbGVuKTsKCWlmIChyZXQpCgkJZ290byBjbGVhbnVwOwoKCW0tPnJldmluZGV4X2RhdGEgPSAoY29uc3QgdWludDMyX3QgKikoKGNvbnN0IGNoYXIgKiltLT5yZXZpbmRleF9tYXAgKyBSSURYX0hFQURFUl9TSVpFKTsKCmNsZWFudXA6CglzdHJidWZfcmVsZWFzZSgmcmV2aW5kZXhfbmFtZSk7CglyZXR1cm4gcmV0Owp9CgppbnQgY2xvc2VfbWlkeF9yZXZpbmRleChzdHJ1Y3QgbXVsdGlfcGFja19pbmRleCAqbSkKewoJaWYgKCFtIHx8ICFtLT5yZXZpbmRleF9tYXApCgkJcmV0dXJuIDA7CgoJbXVubWFwKCh2b2lkKiltLT5yZXZpbmRleF9tYXAsIG0tPnJldmluZGV4X2xlbik7CgoJbS0+cmV2aW5kZXhfbWFwID0gTlVMTDsKCW0tPnJldmluZGV4X2RhdGEgPSBOVUxMOwoJbS0+cmV2aW5kZXhfbGVuID0gMDsKCglyZXR1cm4gMDsKfQoKaW50IG9mZnNldF90b19wYWNrX3BvcyhzdHJ1Y3QgcGFja2VkX2dpdCAqcCwgb2ZmX3Qgb2ZzLCB1aW50MzJfdCAqcG9zKQp7Cgl1bnNpZ25lZCBsbywgaGk7CgoJaWYgKGxvYWRfcGFja19yZXZpbmRleCh0aGVfcmVwb3NpdG9yeSwgcCkgPCAwKQoJCXJldHVybiAtMTsKCglsbyA9IDA7CgloaSA9IHAtPm51bV9vYmplY3RzICsgMTsKCglkbyB7CgkJY29uc3QgdW5zaWduZWQgbWkgPSBsbyArIChoaSAtIGxvKSAvIDI7CgkJb2ZmX3QgZ290ID0gcGFja19wb3NfdG9fb2Zmc2V0KHAsIG1pKTsKCgkJaWYgKGdvdCA9PSBvZnMpIHsKCQkJKnBvcyA9IG1pOwoJCQlyZXR1cm4gMDsKCQl9IGVsc2UgaWYgKG9mcyA8IGdvdCkKCQkJaGkgPSBtaTsKCQllbHNlCgkJCWxvID0gbWkgKyAxOwoJfSB3aGlsZSAobG8gPCBoaSk7CgoJZXJyb3IoImJhZCBvZmZzZXQgZm9yIHJldmluZGV4Iik7CglyZXR1cm4gLTE7Cn0KCnVpbnQzMl90IHBhY2tfcG9zX3RvX2luZGV4KHN0cnVjdCBwYWNrZWRfZ2l0ICpwLCB1aW50MzJfdCBwb3MpCnsKCWlmICghKHAtPnJldmluZGV4IHx8IHAtPnJldmluZGV4X2RhdGEpKQoJCUJVRygicGFja19wb3NfdG9faW5kZXg6IHJldmVyc2UgaW5kZXggbm90IHlldCBsb2FkZWQiKTsKCWlmIChwLT5udW1fb2JqZWN0cyA8PSBwb3MpCgkJQlVHKCJwYWNrX3Bvc190b19pbmRleDogb3V0LW9mLWJvdW5kcyBvYmplY3QgYXQgJSJQUkl1MzIsIHBvcyk7CgoJaWYgKHAtPnJldmluZGV4KQoJCXJldHVybiBwLT5yZXZpbmRleFtwb3NdLm5yOwoJZWxzZQoJCXJldHVybiBnZXRfYmUzMihwLT5yZXZpbmRleF9kYXRhICsgcG9zKTsKfQoKb2ZmX3QgcGFja19wb3NfdG9fb2Zmc2V0KHN0cnVjdCBwYWNrZWRfZ2l0ICpwLCB1aW50MzJfdCBwb3MpCnsKCWlmICghKHAtPnJldmluZGV4IHx8IHAtPnJldmluZGV4X2RhdGEpKQoJCUJVRygicGFja19wb3NfdG9faW5kZXg6IHJldmVyc2UgaW5kZXggbm90IHlldCBsb2FkZWQiKTsKCWlmIChwLT5udW1fb2JqZWN0cyA8IHBvcykKCQlCVUcoInBhY2tfcG9zX3RvX29mZnNldDogb3V0LW9mLWJvdW5kcyBvYmplY3QgYXQgJSJQUkl1MzIsIHBvcyk7CgoJaWYgKHAtPnJldmluZGV4KQoJCXJldHVybiBwLT5yZXZpbmRleFtwb3NdLm9mZnNldDsKCWVsc2UgaWYgKHBvcyA9PSBwLT5udW1fb2JqZWN0cykKCQlyZXR1cm4gcC0+cGFja19zaXplIC0gdGhlX2hhc2hfYWxnby0+cmF3c3o7CgllbHNlCgkJcmV0dXJuIG50aF9wYWNrZWRfb2JqZWN0X29mZnNldChwLCBwYWNrX3Bvc190b19pbmRleChwLCBwb3MpKTsKfQoKdWludDMyX3QgcGFja19wb3NfdG9fbWlkeChzdHJ1Y3QgbXVsdGlfcGFja19pbmRleCAqbSwgdWludDMyX3QgcG9zKQp7CglpZiAoIW0tPnJldmluZGV4X2RhdGEpCgkJQlVHKCJwYWNrX3Bvc190b19taWR4OiByZXZlcnNlIGluZGV4IG5vdCB5ZXQgbG9hZGVkIik7CglpZiAobS0+bnVtX29iamVjdHMgPD0gcG9zKQoJCUJVRygicGFja19wb3NfdG9fbWlkeDogb3V0LW9mLWJvdW5kcyBvYmplY3QgYXQgJSJQUkl1MzIsIHBvcyk7CglyZXR1cm4gZ2V0X2JlMzIobS0+cmV2aW5kZXhfZGF0YSArIHBvcyk7Cn0KCnN0cnVjdCBtaWR4X3BhY2tfa2V5IHsKCXVpbnQzMl90IHBhY2s7CglvZmZfdCBvZmZzZXQ7CgoJdWludDMyX3QgcHJlZmVycmVkX3BhY2s7CglzdHJ1Y3QgbXVsdGlfcGFja19pbmRleCAqbWlkeDsKfTsKCnN0YXRpYyBpbnQgbWlkeF9wYWNrX29yZGVyX2NtcChjb25zdCB2b2lkICp2YSwgY29uc3Qgdm9pZCAqdmIpCnsKCWNvbnN0IHN0cnVjdCBtaWR4X3BhY2tfa2V5ICprZXkgPSB2YTsKCXN0cnVjdCBtdWx0aV9wYWNrX2luZGV4ICptaWR4ID0ga2V5LT5taWR4OwoKCXVpbnQzMl90IHZlcnN1cyA9IHBhY2tfcG9zX3RvX21pZHgobWlkeCwgKHVpbnQzMl90Kil2YiAtIChjb25zdCB1aW50MzJfdCAqKW1pZHgtPnJldmluZGV4X2RhdGEpOwoJdWludDMyX3QgdmVyc3VzX3BhY2sgPSBudGhfbWlkeGVkX3BhY2tfaW50X2lkKG1pZHgsIHZlcnN1cyk7CglvZmZfdCB2ZXJzdXNfb2Zmc2V0OwoKCXVpbnQzMl90IGtleV9wcmVmZXJyZWQgPSBrZXktPnBhY2sgPT0ga2V5LT5wcmVmZXJyZWRfcGFjazsKCXVpbnQzMl90IHZlcnN1c19wcmVmZXJyZWQgPSB2ZXJzdXNfcGFjayA9PSBrZXktPnByZWZlcnJlZF9wYWNrOwoKCS8qCgkgKiBGaXJzdCwgY29tcGFyZSB0aGUgcHJlZmVycmVkLW5lc3MsIG5vdGluZyB0aGF0IHRoZSBwcmVmZXJyZWQgcGFjawoJICogY29tZXMgZmlyc3QuCgkgKi8KCWlmIChrZXlfcHJlZmVycmVkICYmICF2ZXJzdXNfcHJlZmVycmVkKQoJCXJldHVybiAtMTsKCWVsc2UgaWYgKCFrZXlfcHJlZmVycmVkICYmIHZlcnN1c19wcmVmZXJyZWQpCgkJcmV0dXJuIDE7CgoJLyogVGhlbiwgYnJlYWsgdGllcyBmaXJzdCBieSBjb21wYXJpbmcgdGhlIHBhY2sgSURzLiAqLwoJaWYgKGtleS0+cGFjayA8IHZlcnN1c19wYWNrKQoJCXJldHVybiAtMTsKCWVsc2UgaWYgKGtleS0+cGFjayA+IHZlcnN1c19wYWNrKQoJCXJldHVybiAxOwoKCS8qIEZpbmFsbHksIGJyZWFrIHRpZXMgYnkgY29tcGFyaW5nIG9mZnNldHMgd2l0aGluIGEgcGFjay4gKi8KCXZlcnN1c19vZmZzZXQgPSBudGhfbWlkeGVkX29mZnNldChtaWR4LCB2ZXJzdXMpOwoJaWYgKGtleS0+b2Zmc2V0IDwgdmVyc3VzX29mZnNldCkKCQlyZXR1cm4gLTE7CgllbHNlIGlmIChrZXktPm9mZnNldCA+IHZlcnN1c19vZmZzZXQpCgkJcmV0dXJuIDE7CgoJcmV0dXJuIDA7Cn0KCmludCBtaWR4X3RvX3BhY2tfcG9zKHN0cnVjdCBtdWx0aV9wYWNrX2luZGV4ICptLCB1aW50MzJfdCBhdCwgdWludDMyX3QgKnBvcykKewoJc3RydWN0IG1pZHhfcGFja19rZXkga2V5OwoJdWludDMyX3QgKmZvdW5kOwoKCWlmICghbS0+cmV2aW5kZXhfZGF0YSkKCQlCVUcoIm1pZHhfdG9fcGFja19wb3M6IHJldmVyc2UgaW5kZXggbm90IHlldCBsb2FkZWQiKTsKCWlmIChtLT5udW1fb2JqZWN0cyA8PSBhdCkKCQlCVUcoIm1pZHhfdG9fcGFja19wb3M6IG91dC1vZi1ib3VuZHMgb2JqZWN0IGF0ICUiUFJJdTMyLCBhdCk7CgoJa2V5LnBhY2sgPSBudGhfbWlkeGVkX3BhY2tfaW50X2lkKG0sIGF0KTsKCWtleS5vZmZzZXQgPSBudGhfbWlkeGVkX29mZnNldChtLCBhdCk7CglrZXkubWlkeCA9IG07CgkvKgoJICogVGhlIHByZWZlcnJlZCBwYWNrIHNvcnRzIGZpcnN0LCBzbyBkZXRlcm1pbmUgaXRzIGlkZW50aWZpZXIgYnkKCSAqIGxvb2tpbmcgYXQgdGhlIGZpcnN0IG9iamVjdCBpbiBwc2V1ZG8tcGFjayBvcmRlci4KCSAqCgkgKiBOb3RlIHRoYXQgaWYgbm8gLS1wcmVmZXJyZWQtcGFjayBpcyBleHBsaWNpdGx5IGdpdmVuIHdoZW4gd3JpdGluZyBhCgkgKiBtdWx0aS1wYWNrIGluZGV4LCB0aGVuIHdoaWNoZXZlciBwYWNrIGhhcyB0aGUgbG93ZXN0IGlkZW50aWZpZXIKCSAqIGltcGxpY2l0bHkgaXMgcHJlZmVycmVkIChhbmQgaW5jbHVkZXMgYWxsIGl0cyBvYmplY3RzLCBzaW5jZSB0aWVzIGFyZQoJICogYnJva2VuIGZpcnN0IGJ5IHBhY2sgaWRlbnRpZmllcikuCgkgKi8KCWtleS5wcmVmZXJyZWRfcGFjayA9IG50aF9taWR4ZWRfcGFja19pbnRfaWQobSwgcGFja19wb3NfdG9fbWlkeChtLCAwKSk7CgoJZm91bmQgPSBic2VhcmNoKCZrZXksIG0tPnJldmluZGV4X2RhdGEsIG0tPm51bV9vYmplY3RzLAoJCQlzaXplb2YoKm0tPnJldmluZGV4X2RhdGEpLCBtaWR4X3BhY2tfb3JkZXJfY21wKTsKCglpZiAoIWZvdW5kKQoJCXJldHVybiBlcnJvcigiYmFkIG9mZnNldCBmb3IgcmV2aW5kZXgiKTsKCgkqcG9zID0gZm91bmQgLSBtLT5yZXZpbmRleF9kYXRhOwoJcmV0dXJuIDA7Cn0K",
    "text": "#include \"cache.h\"\n#include \"gettext.h\"\n#include \"pack-revindex.h\"\n#include \"object-store.h\"\n#include \"packfile.h\"\n#include \"config.h\"\n#include \"midx.h\"\n#include \"csum-file.h\"\n\nstruct revindex_entry {\n\toff_t offset;\n\tunsigned int nr;\n};\n\n/*\n * Pack index for existing packs give us easy access to the offsets into\n * corresponding pack file where each object's data starts, but the entries\n * do not store the size of the compressed representation (uncompressed\n * size is easily available by examining the pack entry header).  It is\n * also rather expensive to find the sha1 for an object given its offset.\n *\n * The pack index file is sorted by object name mapping to offset;\n * this revindex array is a list of offset/index_nr pairs\n * ordered by offset, so if you know the offset of an object, next offset\n * is where its packed representation ends and the index_nr can be used to\n * get the object sha1 from the main index.\n */\n\n/*\n * This is a least-significant-digit radix sort.\n *\n * It sorts each of the \"n\" items in \"entries\" by its offset field. The \"max\"\n * parameter must be at least as large as the largest offset in the array,\n * and lets us quit the sort early.\n */\nstatic void sort_revindex(struct revindex_entry *entries, unsigned n, off_t max)\n{\n\t/*\n\t * We use a \"digit\" size of 16 bits. That keeps our memory\n\t * usage reasonable, and we can generally (for a 4G or smaller\n\t * packfile) quit after two rounds of radix-sorting.\n\t */\n#define DIGIT_SIZE (16)\n#define BUCKETS (1 << DIGIT_SIZE)\n\t/*\n\t * We want to know the bucket that a[i] will go into when we are using\n\t * the digit that is N bits from the (least significant) end.\n\t */\n#define BUCKET_FOR(a, i, bits) (((a)[(i)].offset >> (bits)) & (BUCKETS-1))\n\n\t/*\n\t * We need O(n) temporary storage. Rather than do an extra copy of the\n\t * partial results into \"entries\", we sort back and forth between the\n\t * real array and temporary storage. In each iteration of the loop, we\n\t * keep track of them with alias pointers, always sorting from \"from\"\n\t * to \"to\".\n\t */\n\tstruct revindex_entry *tmp, *from, *to;\n\tint bits;\n\tunsigned *pos;\n\n\tALLOC_ARRAY(pos, BUCKETS);\n\tALLOC_ARRAY(tmp, n);\n\tfrom = entries;\n\tto = tmp;\n\n\t/*\n\t * If (max >> bits) is zero, then we know that the radix digit we are\n\t * on (and any higher) will be zero for all entries, and our loop will\n\t * be a no-op, as everybody lands in the same zero-th bucket.\n\t */\n\tfor (bits = 0; max >> bits; bits += DIGIT_SIZE) {\n\t\tunsigned i;\n\n\t\tmemset(pos, 0, BUCKETS * sizeof(*pos));\n\n\t\t/*\n\t\t * We want pos[i] to store the index of the last element that\n\t\t * will go in bucket \"i\" (actually one past the last element).\n\t\t * To do this, we first count the items that will go in each\n\t\t * bucket, which gives us a relative offset from the last\n\t\t * bucket. We can then cumulatively add the index from the\n\t\t * previous bucket to get the true index.\n\t\t */\n\t\tfor (i = 0; i < n; i++)\n\t\t\tpos[BUCKET_FOR(from, i, bits)]++;\n\t\tfor (i = 1; i < BUCKETS; i++)\n\t\t\tpos[i] += pos[i-1];\n\n\t\t/*\n\t\t * Now we can drop the elements into their correct buckets (in\n\t\t * our temporary array).  We iterate the pos counter backwards\n\t\t * to avoid using an extra index to count up. And since we are\n\t\t * going backwards there, we must also go backwards through the\n\t\t * array itself, to keep the sort stable.\n\t\t *\n\t\t * Note that we use an unsigned iterator to make sure we can\n\t\t * handle 2^32-1 objects, even on a 32-bit system. But this\n\t\t * means we cannot use the more obvious \"i >= 0\" loop condition\n\t\t * for counting backwards, and must instead check for\n\t\t * wrap-around with UINT_MAX.\n\t\t */\n\t\tfor (i = n - 1; i != UINT_MAX; i--)\n\t\t\tto[--pos[BUCKET_FOR(from, i, bits)]] = from[i];\n\n\t\t/*\n\t\t * Now \"to\" contains the most sorted list, so we swap \"from\" and\n\t\t * \"to\" for the next iteration.\n\t\t */\n\t\tSWAP(from, to);\n\t}\n\n\t/*\n\t * If we ended with our data in the original array, great. If not,\n\t * we have to move it back from the temporary storage.\n\t */\n\tif (from != entries)\n\t\tCOPY_ARRAY(entries, tmp, n);\n\tfree(tmp);\n\tfree(pos);\n\n#undef BUCKET_FOR\n#undef BUCKETS\n#undef DIGIT_SIZE\n}\n\n/*\n * Ordered list of offsets of objects in the pack.\n */\nstatic void create_pack_revindex(struct packed_git *p)\n{\n\tconst unsigned num_ent = p->num_objects;\n\tunsigned i;\n\tconst char *index = p->index_data;\n\tconst unsigned hashsz = the_hash_algo->rawsz;\n\n\tALLOC_ARRAY(p->revindex, num_ent + 1);\n\tindex += 4 * 256;\n\n\tif (p->index_version > 1) {\n\t\tconst uint32_t *off_32 =\n\t\t\t(uint32_t *)(index + 8 + (size_t)p->num_objects * (hashsz + 4));\n\t\tconst uint32_t *off_64 = off_32 + p->num_objects;\n\t\tfor (i = 0; i < num_ent; i++) {\n\t\t\tconst uint32_t off = ntohl(*off_32++);\n\t\t\tif (!(off & 0x80000000)) {\n\t\t\t\tp->revindex[i].offset = off;\n\t\t\t} else {\n\t\t\t\tp->revindex[i].offset = get_be64(off_64);\n\t\t\t\toff_64 += 2;\n\t\t\t}\n\t\t\tp->revindex[i].nr = i;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < num_ent; i++) {\n\t\t\tconst uint32_t hl = *((uint32_t *)(index + (hashsz + 4) * i));\n\t\t\tp->revindex[i].offset = ntohl(hl);\n\t\t\tp->revindex[i].nr = i;\n\t\t}\n\t}\n\n\t/*\n\t * This knows the pack format -- the hash trailer\n\t * follows immediately after the last object data.\n\t */\n\tp->revindex[num_ent].offset = p->pack_size - hashsz;\n\tp->revindex[num_ent].nr = -1;\n\tsort_revindex(p->revindex, num_ent, p->pack_size);\n}\n\nstatic int create_pack_revindex_in_memory(struct packed_git *p)\n{\n\tif (git_env_bool(GIT_TEST_REV_INDEX_DIE_IN_MEMORY, 0))\n\t\tdie(\"dying as requested by '%s'\",\n\t\t    GIT_TEST_REV_INDEX_DIE_IN_MEMORY);\n\tif (open_pack_index(p))\n\t\treturn -1;\n\tcreate_pack_revindex(p);\n\treturn 0;\n}\n\nstatic char *pack_revindex_filename(struct packed_git *p)\n{\n\tsize_t len;\n\tif (!strip_suffix(p->pack_name, \".pack\", &len))\n\t\tBUG(\"pack_name does not end in .pack\");\n\treturn xstrfmt(\"%.*s.rev\", (int)len, p->pack_name);\n}\n\n#define RIDX_HEADER_SIZE (12)\n#define RIDX_MIN_SIZE (RIDX_HEADER_SIZE + (2 * the_hash_algo->rawsz))\n\nstruct revindex_header {\n\tuint32_t signature;\n\tuint32_t version;\n\tuint32_t hash_id;\n};\n\nstatic int load_revindex_from_disk(char *revindex_name,\n\t\t\t\t   uint32_t num_objects,\n\t\t\t\t   const uint32_t **data_p, size_t *len_p)\n{\n\tint fd, ret = 0;\n\tstruct stat st;\n\tvoid *data = NULL;\n\tsize_t revindex_size;\n\tstruct revindex_header *hdr;\n\n\tif (git_env_bool(GIT_TEST_REV_INDEX_DIE_ON_DISK, 0))\n\t\tdie(\"dying as requested by '%s'\", GIT_TEST_REV_INDEX_DIE_ON_DISK);\n\n\tfd = git_open(revindex_name);\n\n\tif (fd < 0) {\n\t\tret = -1;\n\t\tgoto cleanup;\n\t}\n\tif (fstat(fd, &st)) {\n\t\tret = error_errno(_(\"failed to read %s\"), revindex_name);\n\t\tgoto cleanup;\n\t}\n\n\trevindex_size = xsize_t(st.st_size);\n\n\tif (revindex_size < RIDX_MIN_SIZE) {\n\t\tret = error(_(\"reverse-index file %s is too small\"), revindex_name);\n\t\tgoto cleanup;\n\t}\n\n\tif (revindex_size - RIDX_MIN_SIZE != st_mult(sizeof(uint32_t), num_objects)) {\n\t\tret = error(_(\"reverse-index file %s is corrupt\"), revindex_name);\n\t\tgoto cleanup;\n\t}\n\n\tdata = xmmap(NULL, revindex_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\thdr = data;\n\n\tif (ntohl(hdr->signature) != RIDX_SIGNATURE) {\n\t\tret = error(_(\"reverse-index file %s has unknown signature\"), revindex_name);\n\t\tgoto cleanup;\n\t}\n\tif (ntohl(hdr->version) != 1) {\n\t\tret = error(_(\"reverse-index file %s has unsupported version %\"PRIu32),\n\t\t\t    revindex_name, ntohl(hdr->version));\n\t\tgoto cleanup;\n\t}\n\tif (!(ntohl(hdr->hash_id) == 1 || ntohl(hdr->hash_id) == 2)) {\n\t\tret = error(_(\"reverse-index file %s has unsupported hash id %\"PRIu32),\n\t\t\t    revindex_name, ntohl(hdr->hash_id));\n\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tif (ret) {\n\t\tif (data)\n\t\t\tmunmap(data, revindex_size);\n\t} else {\n\t\t*len_p = revindex_size;\n\t\t*data_p = (const uint32_t *)data;\n\t}\n\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn ret;\n}\n\nstatic int load_pack_revindex_from_disk(struct packed_git *p)\n{\n\tchar *revindex_name;\n\tint ret;\n\tif (open_pack_index(p))\n\t\treturn -1;\n\n\trevindex_name = pack_revindex_filename(p);\n\n\tret = load_revindex_from_disk(revindex_name,\n\t\t\t\t      p->num_objects,\n\t\t\t\t      &p->revindex_map,\n\t\t\t\t      &p->revindex_size);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tp->revindex_data = (const uint32_t *)((const char *)p->revindex_map + RIDX_HEADER_SIZE);\n\ncleanup:\n\tfree(revindex_name);\n\treturn ret;\n}\n\nint load_pack_revindex(struct repository *r, struct packed_git *p)\n{\n\tif (p->revindex || p->revindex_data)\n\t\treturn 0;\n\n\tprepare_repo_settings(r);\n\n\tif (r->settings.pack_read_reverse_index &&\n\t    !load_pack_revindex_from_disk(p))\n\t\treturn 0;\n\telse if (!create_pack_revindex_in_memory(p))\n\t\treturn 0;\n\treturn -1;\n}\n\n/*\n * verify_pack_revindex verifies that the on-disk rev-index for the given\n * pack-file is the same that would be created if written from scratch.\n *\n * A negative number is returned on error.\n */\nint verify_pack_revindex(struct packed_git *p)\n{\n\t/* Do not bother checking if not initialized. */\n\tif (!p->revindex_map)\n\t\treturn 0;\n\n\tif (!hashfile_checksum_valid((const unsigned char *)p->revindex_map, p->revindex_size)) {\n\t\terror(_(\"invalid checksum\"));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint load_midx_revindex(struct multi_pack_index *m)\n{\n\tstruct strbuf revindex_name = STRBUF_INIT;\n\tint ret;\n\n\tif (m->revindex_data)\n\t\treturn 0;\n\n\tif (m->chunk_revindex) {\n\t\t/*\n\t\t * If the MIDX `m` has a `RIDX` chunk, then use its contents for\n\t\t * the reverse index instead of trying to load a separate `.rev`\n\t\t * file.\n\t\t *\n\t\t * Note that we do *not* set `m->revindex_map` here, since we do\n\t\t * not want to accidentally call munmap() in the middle of the\n\t\t * MIDX.\n\t\t */\n\t\ttrace2_data_string(\"load_midx_revindex\", the_repository,\n\t\t\t\t   \"source\", \"midx\");\n\t\tm->revindex_data = (const uint32_t *)m->chunk_revindex;\n\t\treturn 0;\n\t}\n\n\ttrace2_data_string(\"load_midx_revindex\", the_repository,\n\t\t\t   \"source\", \"rev\");\n\n\tget_midx_rev_filename(&revindex_name, m);\n\n\tret = load_revindex_from_disk(revindex_name.buf,\n\t\t\t\t      m->num_objects,\n\t\t\t\t      &m->revindex_map,\n\t\t\t\t      &m->revindex_len);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tm->revindex_data = (const uint32_t *)((const char *)m->revindex_map + RIDX_HEADER_SIZE);\n\ncleanup:\n\tstrbuf_release(&revindex_name);\n\treturn ret;\n}\n\nint close_midx_revindex(struct multi_pack_index *m)\n{\n\tif (!m || !m->revindex_map)\n\t\treturn 0;\n\n\tmunmap((void*)m->revindex_map, m->revindex_len);\n\n\tm->revindex_map = NULL;\n\tm->revindex_data = NULL;\n\tm->revindex_len = 0;\n\n\treturn 0;\n}\n\nint offset_to_pack_pos(struct packed_git *p, off_t ofs, uint32_t *pos)\n{\n\tunsigned lo, hi;\n\n\tif (load_pack_revindex(the_repository, p) < 0)\n\t\treturn -1;\n\n\tlo = 0;\n\thi = p->num_objects + 1;\n\n\tdo {\n\t\tconst unsigned mi = lo + (hi - lo) / 2;\n\t\toff_t got = pack_pos_to_offset(p, mi);\n\n\t\tif (got == ofs) {\n\t\t\t*pos = mi;\n\t\t\treturn 0;\n\t\t} else if (ofs < got)\n\t\t\thi = mi;\n\t\telse\n\t\t\tlo = mi + 1;\n\t} while (lo < hi);\n\n\terror(\"bad offset for revindex\");\n\treturn -1;\n}\n\nuint32_t pack_pos_to_index(struct packed_git *p, uint32_t pos)\n{\n\tif (!(p->revindex || p->revindex_data))\n\t\tBUG(\"pack_pos_to_index: reverse index not yet loaded\");\n\tif (p->num_objects <= pos)\n\t\tBUG(\"pack_pos_to_index: out-of-bounds object at %\"PRIu32, pos);\n\n\tif (p->revindex)\n\t\treturn p->revindex[pos].nr;\n\telse\n\t\treturn get_be32(p->revindex_data + pos);\n}\n\noff_t pack_pos_to_offset(struct packed_git *p, uint32_t pos)\n{\n\tif (!(p->revindex || p->revindex_data))\n\t\tBUG(\"pack_pos_to_index: reverse index not yet loaded\");\n\tif (p->num_objects < pos)\n\t\tBUG(\"pack_pos_to_offset: out-of-bounds object at %\"PRIu32, pos);\n\n\tif (p->revindex)\n\t\treturn p->revindex[pos].offset;\n\telse if (pos == p->num_objects)\n\t\treturn p->pack_size - the_hash_algo->rawsz;\n\telse\n\t\treturn nth_packed_object_offset(p, pack_pos_to_index(p, pos));\n}\n\nuint32_t pack_pos_to_midx(struct multi_pack_index *m, uint32_t pos)\n{\n\tif (!m->revindex_data)\n\t\tBUG(\"pack_pos_to_midx: reverse index not yet loaded\");\n\tif (m->num_objects <= pos)\n\t\tBUG(\"pack_pos_to_midx: out-of-bounds object at %\"PRIu32, pos);\n\treturn get_be32(m->revindex_data + pos);\n}\n\nstruct midx_pack_key {\n\tuint32_t pack;\n\toff_t offset;\n\n\tuint32_t preferred_pack;\n\tstruct multi_pack_index *midx;\n};\n\nstatic int midx_pack_order_cmp(const void *va, const void *vb)\n{\n\tconst struct midx_pack_key *key = va;\n\tstruct multi_pack_index *midx = key->midx;\n\n\tuint32_t versus = pack_pos_to_midx(midx, (uint32_t*)vb - (const uint32_t *)midx->revindex_data);\n\tuint32_t versus_pack = nth_midxed_pack_int_id(midx, versus);\n\toff_t versus_offset;\n\n\tuint32_t key_preferred = key->pack == key->preferred_pack;\n\tuint32_t versus_preferred = versus_pack == key->preferred_pack;\n\n\t/*\n\t * First, compare the preferred-ness, noting that the preferred pack\n\t * comes first.\n\t */\n\tif (key_preferred && !versus_preferred)\n\t\treturn -1;\n\telse if (!key_preferred && versus_preferred)\n\t\treturn 1;\n\n\t/* Then, break ties first by comparing the pack IDs. */\n\tif (key->pack < versus_pack)\n\t\treturn -1;\n\telse if (key->pack > versus_pack)\n\t\treturn 1;\n\n\t/* Finally, break ties by comparing offsets within a pack. */\n\tversus_offset = nth_midxed_offset(midx, versus);\n\tif (key->offset < versus_offset)\n\t\treturn -1;\n\telse if (key->offset > versus_offset)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint midx_to_pack_pos(struct multi_pack_index *m, uint32_t at, uint32_t *pos)\n{\n\tstruct midx_pack_key key;\n\tuint32_t *found;\n\n\tif (!m->revindex_data)\n\t\tBUG(\"midx_to_pack_pos: reverse index not yet loaded\");\n\tif (m->num_objects <= at)\n\t\tBUG(\"midx_to_pack_pos: out-of-bounds object at %\"PRIu32, at);\n\n\tkey.pack = nth_midxed_pack_int_id(m, at);\n\tkey.offset = nth_midxed_offset(m, at);\n\tkey.midx = m;\n\t/*\n\t * The preferred pack sorts first, so determine its identifier by\n\t * looking at the first object in pseudo-pack order.\n\t *\n\t * Note that if no --preferred-pack is explicitly given when writing a\n\t * multi-pack index, then whichever pack has the lowest identifier\n\t * implicitly is preferred (and includes all its objects, since ties are\n\t * broken first by pack identifier).\n\t */\n\tkey.preferred_pack = nth_midxed_pack_int_id(m, pack_pos_to_midx(m, 0));\n\n\tfound = bsearch(&key, m->revindex_data, m->num_objects,\n\t\t\tsizeof(*m->revindex_data), midx_pack_order_cmp);\n\n\tif (!found)\n\t\treturn error(\"bad offset for revindex\");\n\n\t*pos = found - m->revindex_data;\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "007a806994fd606984f9b28c51a61eee16bc9140",
  "sha1_ok": true,
  "size": 13992
}
