{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImdyZXAuaCIKI2luY2x1ZGUgIm9iamVjdC1zdG9yZS5oIgojaW5jbHVkZSAidXNlcmRpZmYuaCIKI2luY2x1ZGUgInhkaWZmLWludGVyZmFjZS5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAiZGlmZmNvcmUuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAicXVvdGUuaCIKI2luY2x1ZGUgImhlbHAuaCIKCnN0YXRpYyBpbnQgZ3JlcF9zb3VyY2VfbG9hZChzdHJ1Y3QgZ3JlcF9zb3VyY2UgKmdzKTsKc3RhdGljIGludCBncmVwX3NvdXJjZV9pc19iaW5hcnkoc3RydWN0IGdyZXBfc291cmNlICpncywKCQkJCSBzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSk7CgpzdGF0aWMgdm9pZCBzdGRfb3V0cHV0KHN0cnVjdCBncmVwX29wdCAqb3B0LCBjb25zdCB2b2lkICpidWYsIHNpemVfdCBzaXplKQp7Cglmd3JpdGUoYnVmLCBzaXplLCAxLCBzdGRvdXQpOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqY29sb3JfZ3JlcF9zbG90c1tdID0gewoJW0dSRVBfQ09MT1JfQ09OVEVYVF0JICAgID0gImNvbnRleHQiLAoJW0dSRVBfQ09MT1JfRklMRU5BTUVdCSAgICA9ICJmaWxlbmFtZSIsCglbR1JFUF9DT0xPUl9GVU5DVElPTl0JICAgID0gImZ1bmN0aW9uIiwKCVtHUkVQX0NPTE9SX0xJTkVOT10JICAgID0gImxpbmVOdW1iZXIiLAoJW0dSRVBfQ09MT1JfQ09MVU1OTk9dCSAgICA9ICJjb2x1bW4iLAoJW0dSRVBfQ09MT1JfTUFUQ0hfQ09OVEVYVF0gID0gIm1hdGNoQ29udGV4dCIsCglbR1JFUF9DT0xPUl9NQVRDSF9TRUxFQ1RFRF0gPSAibWF0Y2hTZWxlY3RlZCIsCglbR1JFUF9DT0xPUl9TRUxFQ1RFRF0JICAgID0gInNlbGVjdGVkIiwKCVtHUkVQX0NPTE9SX1NFUF0JICAgID0gInNlcGFyYXRvciIsCn07CgpzdGF0aWMgaW50IHBhcnNlX3BhdHRlcm5fdHlwZV9hcmcoY29uc3QgY2hhciAqb3B0LCBjb25zdCBjaGFyICphcmcpCnsKCWlmICghc3RyY21wKGFyZywgImRlZmF1bHQiKSkKCQlyZXR1cm4gR1JFUF9QQVRURVJOX1RZUEVfVU5TUEVDSUZJRUQ7CgllbHNlIGlmICghc3RyY21wKGFyZywgImJhc2ljIikpCgkJcmV0dXJuIEdSRVBfUEFUVEVSTl9UWVBFX0JSRTsKCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiZXh0ZW5kZWQiKSkKCQlyZXR1cm4gR1JFUF9QQVRURVJOX1RZUEVfRVJFOwoJZWxzZSBpZiAoIXN0cmNtcChhcmcsICJmaXhlZCIpKQoJCXJldHVybiBHUkVQX1BBVFRFUk5fVFlQRV9GSVhFRDsKCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAicGVybCIpKQoJCXJldHVybiBHUkVQX1BBVFRFUk5fVFlQRV9QQ1JFOwoJZGllKCJiYWQgJXMgYXJndW1lbnQ6ICVzIiwgb3B0LCBhcmcpOwp9CgpkZWZpbmVfbGlzdF9jb25maWdfYXJyYXlfZXh0cmEoY29sb3JfZ3JlcF9zbG90cywgeyJtYXRjaCJ9KTsKCi8qCiAqIFJlYWQgdGhlIGNvbmZpZ3VyYXRpb24gZmlsZSBvbmNlIGFuZCBzdG9yZSBpdCBpbgogKiB0aGUgZ3JlcF9kZWZhdWx0cyB0ZW1wbGF0ZS4KICovCmludCBncmVwX2NvbmZpZyhjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlLCB2b2lkICpjYikKewoJc3RydWN0IGdyZXBfb3B0ICpvcHQgPSBjYjsKCWNvbnN0IGNoYXIgKnNsb3Q7CgoJaWYgKHVzZXJkaWZmX2NvbmZpZyh2YXIsIHZhbHVlKSA8IDApCgkJcmV0dXJuIC0xOwoKCWlmICghc3RyY21wKHZhciwgImdyZXAuZXh0ZW5kZWRyZWdleHAiKSkgewoJCW9wdC0+ZXh0ZW5kZWRfcmVnZXhwX29wdGlvbiA9IGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCglpZiAoIXN0cmNtcCh2YXIsICJncmVwLnBhdHRlcm50eXBlIikpIHsKCQlvcHQtPnBhdHRlcm5fdHlwZV9vcHRpb24gPSBwYXJzZV9wYXR0ZXJuX3R5cGVfYXJnKHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoKCWlmICghc3RyY21wKHZhciwgImdyZXAubGluZW51bWJlciIpKSB7CgkJb3B0LT5saW5lbnVtID0gZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAodmFyLCAiZ3JlcC5jb2x1bW4iKSkgewoJCW9wdC0+Y29sdW1ubnVtID0gZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoKCWlmICghc3RyY21wKHZhciwgImdyZXAuZnVsbG5hbWUiKSkgewoJCW9wdC0+cmVsYXRpdmUgPSAhZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoKCWlmICghc3RyY21wKHZhciwgImNvbG9yLmdyZXAiKSkKCQlvcHQtPmNvbG9yID0gZ2l0X2NvbmZpZ19jb2xvcmJvb2wodmFyLCB2YWx1ZSk7CglpZiAoIXN0cmNtcCh2YXIsICJjb2xvci5ncmVwLm1hdGNoIikpIHsKCQlpZiAoZ3JlcF9jb25maWcoImNvbG9yLmdyZXAubWF0Y2hjb250ZXh0IiwgdmFsdWUsIGNiKSA8IDApCgkJCXJldHVybiAtMTsKCQlpZiAoZ3JlcF9jb25maWcoImNvbG9yLmdyZXAubWF0Y2hzZWxlY3RlZCIsIHZhbHVlLCBjYikgPCAwKQoJCQlyZXR1cm4gLTE7Cgl9IGVsc2UgaWYgKHNraXBfcHJlZml4KHZhciwgImNvbG9yLmdyZXAuIiwgJnNsb3QpKSB7CgkJaW50IGkgPSBMT09LVVBfQ09ORklHKGNvbG9yX2dyZXBfc2xvdHMsIHNsb3QpOwoJCWNoYXIgKmNvbG9yOwoKCQlpZiAoaSA8IDApCgkJCXJldHVybiAtMTsKCQljb2xvciA9IG9wdC0+Y29sb3JzW2ldOwoJCWlmICghdmFsdWUpCgkJCXJldHVybiBjb25maWdfZXJyb3Jfbm9uYm9vbCh2YXIpOwoJCXJldHVybiBjb2xvcl9wYXJzZSh2YWx1ZSwgY29sb3IpOwoJfQoJcmV0dXJuIDA7Cn0KCnZvaWQgZ3JlcF9pbml0KHN0cnVjdCBncmVwX29wdCAqb3B0LCBzdHJ1Y3QgcmVwb3NpdG9yeSAqcmVwbykKewoJc3RydWN0IGdyZXBfb3B0IGJsYW5rID0gR1JFUF9PUFRfSU5JVDsKCW1lbWNweShvcHQsICZibGFuaywgc2l6ZW9mKCpvcHQpKTsKCglvcHQtPnJlcG8gPSByZXBvOwoJb3B0LT5wYXR0ZXJuX3RhaWwgPSAmb3B0LT5wYXR0ZXJuX2xpc3Q7CglvcHQtPmhlYWRlcl90YWlsID0gJm9wdC0+aGVhZGVyX2xpc3Q7Cn0KCnN0YXRpYyBzdHJ1Y3QgZ3JlcF9wYXQgKmNyZWF0ZV9ncmVwX3BhdChjb25zdCBjaGFyICpwYXQsIHNpemVfdCBwYXRsZW4sCgkJCQkJY29uc3QgY2hhciAqb3JpZ2luLCBpbnQgbm8sCgkJCQkJZW51bSBncmVwX3BhdF90b2tlbiB0LAoJCQkJCWVudW0gZ3JlcF9oZWFkZXJfZmllbGQgZmllbGQpCnsKCXN0cnVjdCBncmVwX3BhdCAqcCA9IHhjYWxsb2MoMSwgc2l6ZW9mKCpwKSk7CglwLT5wYXR0ZXJuID0geG1lbWR1cHoocGF0LCBwYXRsZW4pOwoJcC0+cGF0dGVybmxlbiA9IHBhdGxlbjsKCXAtPm9yaWdpbiA9IG9yaWdpbjsKCXAtPm5vID0gbm87CglwLT50b2tlbiA9IHQ7CglwLT5maWVsZCA9IGZpZWxkOwoJcmV0dXJuIHA7Cn0KCnN0YXRpYyB2b2lkIGRvX2FwcGVuZF9ncmVwX3BhdChzdHJ1Y3QgZ3JlcF9wYXQgKioqdGFpbCwgc3RydWN0IGdyZXBfcGF0ICpwKQp7CgkqKnRhaWwgPSBwOwoJKnRhaWwgPSAmcC0+bmV4dDsKCXAtPm5leHQgPSBOVUxMOwoKCXN3aXRjaCAocC0+dG9rZW4pIHsKCWNhc2UgR1JFUF9QQVRURVJOOiAvKiBhdG9tICovCgljYXNlIEdSRVBfUEFUVEVSTl9IRUFEOgoJY2FzZSBHUkVQX1BBVFRFUk5fQk9EWToKCQlmb3IgKDs7KSB7CgkJCXN0cnVjdCBncmVwX3BhdCAqbmV3X3BhdDsKCQkJc2l6ZV90IGxlbiA9IDA7CgkJCWNoYXIgKmNwID0gcC0+cGF0dGVybiArIHAtPnBhdHRlcm5sZW4sICpubCA9IE5VTEw7CgkJCXdoaWxlICgrK2xlbiA8PSBwLT5wYXR0ZXJubGVuKSB7CgkJCQlpZiAoKigtLWNwKSA9PSAnXG4nKSB7CgkJCQkJbmwgPSBjcDsKCQkJCQlicmVhazsKCQkJCX0KCQkJfQoJCQlpZiAoIW5sKQoJCQkJYnJlYWs7CgkJCW5ld19wYXQgPSBjcmVhdGVfZ3JlcF9wYXQobmwgKyAxLCBsZW4gLSAxLCBwLT5vcmlnaW4sCgkJCQkJCSAgcC0+bm8sIHAtPnRva2VuLCBwLT5maWVsZCk7CgkJCW5ld19wYXQtPm5leHQgPSBwLT5uZXh0OwoJCQlpZiAoIXAtPm5leHQpCgkJCQkqdGFpbCA9ICZuZXdfcGF0LT5uZXh0OwoJCQlwLT5uZXh0ID0gbmV3X3BhdDsKCQkJKm5sID0gJ1wwJzsKCQkJcC0+cGF0dGVybmxlbiAtPSBsZW47CgkJfQoJCWJyZWFrOwoJZGVmYXVsdDoKCQlicmVhazsKCX0KfQoKdm9pZCBhcHBlbmRfaGVhZGVyX2dyZXBfcGF0dGVybihzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCwKCQkJCWVudW0gZ3JlcF9oZWFkZXJfZmllbGQgZmllbGQsIGNvbnN0IGNoYXIgKnBhdCkKewoJc3RydWN0IGdyZXBfcGF0ICpwID0gY3JlYXRlX2dyZXBfcGF0KHBhdCwgc3RybGVuKHBhdCksICJoZWFkZXIiLCAwLAoJCQkJCSAgICAgR1JFUF9QQVRURVJOX0hFQUQsIGZpZWxkKTsKCWlmIChmaWVsZCA9PSBHUkVQX0hFQURFUl9SRUZMT0cpCgkJb3B0LT51c2VfcmVmbG9nX2ZpbHRlciA9IDE7Cglkb19hcHBlbmRfZ3JlcF9wYXQoJm9wdC0+aGVhZGVyX3RhaWwsIHApOwp9Cgp2b2lkIGFwcGVuZF9ncmVwX3BhdHRlcm4oc3RydWN0IGdyZXBfb3B0ICpvcHQsIGNvbnN0IGNoYXIgKnBhdCwKCQkJIGNvbnN0IGNoYXIgKm9yaWdpbiwgaW50IG5vLCBlbnVtIGdyZXBfcGF0X3Rva2VuIHQpCnsKCWFwcGVuZF9ncmVwX3BhdChvcHQsIHBhdCwgc3RybGVuKHBhdCksIG9yaWdpbiwgbm8sIHQpOwp9Cgp2b2lkIGFwcGVuZF9ncmVwX3BhdChzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCwgY29uc3QgY2hhciAqcGF0LCBzaXplX3QgcGF0bGVuLAoJCSAgICAgY29uc3QgY2hhciAqb3JpZ2luLCBpbnQgbm8sIGVudW0gZ3JlcF9wYXRfdG9rZW4gdCkKewoJc3RydWN0IGdyZXBfcGF0ICpwID0gY3JlYXRlX2dyZXBfcGF0KHBhdCwgcGF0bGVuLCBvcmlnaW4sIG5vLCB0LCAwKTsKCWRvX2FwcGVuZF9ncmVwX3BhdCgmb3B0LT5wYXR0ZXJuX3RhaWwsIHApOwp9CgpzdHJ1Y3QgZ3JlcF9vcHQgKmdyZXBfb3B0X2R1cChjb25zdCBzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCkKewoJc3RydWN0IGdyZXBfcGF0ICpwYXQ7CglzdHJ1Y3QgZ3JlcF9vcHQgKnJldCA9IHhtYWxsb2Moc2l6ZW9mKHN0cnVjdCBncmVwX29wdCkpOwoJKnJldCA9ICpvcHQ7CgoJcmV0LT5wYXR0ZXJuX2xpc3QgPSBOVUxMOwoJcmV0LT5wYXR0ZXJuX3RhaWwgPSAmcmV0LT5wYXR0ZXJuX2xpc3Q7CgoJZm9yKHBhdCA9IG9wdC0+cGF0dGVybl9saXN0OyBwYXQgIT0gTlVMTDsgcGF0ID0gcGF0LT5uZXh0KQoJewoJCWlmKHBhdC0+dG9rZW4gPT0gR1JFUF9QQVRURVJOX0hFQUQpCgkJCWFwcGVuZF9oZWFkZXJfZ3JlcF9wYXR0ZXJuKHJldCwgcGF0LT5maWVsZCwKCQkJCQkJICAgcGF0LT5wYXR0ZXJuKTsKCQllbHNlCgkJCWFwcGVuZF9ncmVwX3BhdChyZXQsIHBhdC0+cGF0dGVybiwgcGF0LT5wYXR0ZXJubGVuLAoJCQkJCXBhdC0+b3JpZ2luLCBwYXQtPm5vLCBwYXQtPnRva2VuKTsKCX0KCglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgTk9SRVRVUk4gdm9pZCBjb21waWxlX3JlZ2V4cF9mYWlsZWQoY29uc3Qgc3RydWN0IGdyZXBfcGF0ICpwLAoJCWNvbnN0IGNoYXIgKmVycm9yKQp7CgljaGFyIHdoZXJlWzEwMjRdOwoKCWlmIChwLT5ubykKCQl4c25wcmludGYod2hlcmUsIHNpemVvZih3aGVyZSksICJJbiAnJXMnIGF0ICVkLCAiLCBwLT5vcmlnaW4sIHAtPm5vKTsKCWVsc2UgaWYgKHAtPm9yaWdpbikKCQl4c25wcmludGYod2hlcmUsIHNpemVvZih3aGVyZSksICIlcywgIiwgcC0+b3JpZ2luKTsKCWVsc2UKCQl3aGVyZVswXSA9IDA7CgoJZGllKCIlcyclcyc6ICVzIiwgd2hlcmUsIHAtPnBhdHRlcm4sIGVycm9yKTsKfQoKc3RhdGljIGludCBpc19maXhlZChjb25zdCBjaGFyICpzLCBzaXplX3QgbGVuKQp7CglzaXplX3QgaTsKCglmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKCQlpZiAoaXNfcmVnZXhfc3BlY2lhbChzW2ldKSkKCQkJcmV0dXJuIDA7Cgl9CgoJcmV0dXJuIDE7Cn0KCiNpZmRlZiBVU0VfTElCUENSRTIKI2RlZmluZSBHUkVQX1BDUkUyX0RFQlVHX01BTExPQyAwCgpzdGF0aWMgdm9pZCAqcGNyZTJfbWFsbG9jKFBDUkUyX1NJWkUgc2l6ZSwgTUFZQkVfVU5VU0VEIHZvaWQgKm1lbW9yeV9kYXRhKQp7Cgl2b2lkICpwb2ludGVyID0gbWFsbG9jKHNpemUpOwojaWYgR1JFUF9QQ1JFMl9ERUJVR19NQUxMT0MKCXN0YXRpYyBpbnQgY291bnQgPSAxOwoJZnByaW50ZihzdGRlcnIsICJQQ1JFMjolcCAtPiAjJTAyZDogYWxsb2MoJWx1KVxuIiwgcG9pbnRlciwgY291bnQrKywgc2l6ZSk7CiNlbmRpZgoJcmV0dXJuIHBvaW50ZXI7Cn0KCnN0YXRpYyB2b2lkIHBjcmUyX2ZyZWUodm9pZCAqcG9pbnRlciwgTUFZQkVfVU5VU0VEIHZvaWQgKm1lbW9yeV9kYXRhKQp7CiNpZiBHUkVQX1BDUkUyX0RFQlVHX01BTExPQwoJc3RhdGljIGludCBjb3VudCA9IDE7CglpZiAocG9pbnRlcikKCQlmcHJpbnRmKHN0ZGVyciwgIlBDUkUyOiVwIC0+ICMlMDJkOiBmcmVlKClcbiIsIHBvaW50ZXIsIGNvdW50KyspOwojZW5kaWYKCWZyZWUocG9pbnRlcik7Cn0KCnN0YXRpYyB2b2lkIGNvbXBpbGVfcGNyZTJfcGF0dGVybihzdHJ1Y3QgZ3JlcF9wYXQgKnAsIGNvbnN0IHN0cnVjdCBncmVwX29wdCAqb3B0KQp7CglpbnQgZXJyb3I7CglQQ1JFMl9VQ0hBUiBlcnJidWZbMjU2XTsKCVBDUkUyX1NJWkUgZXJyb2Zmc2V0OwoJaW50IG9wdGlvbnMgPSBQQ1JFMl9NVUxUSUxJTkU7CglpbnQgaml0cmV0OwoJaW50IHBhdGluZm9yZXQ7CglzaXplX3Qgaml0c2l6ZWFyZzsKCWludCBsaXRlcmFsID0gIW9wdC0+aWdub3JlX2Nhc2UgJiYgKHAtPmZpeGVkIHx8IHAtPmlzX2ZpeGVkKTsKCgkvKgoJICogQ2FsbCBwY3JlMl9nZW5lcmFsX2NvbnRleHRfY3JlYXRlKCkgYmVmb3JlIGNhbGxpbmcgYW55CgkgKiBvdGhlciBwY3JlMl8qKCkuIEl0IHNldHMgdXAgb3VyIG1hbGxvYygpL2ZyZWUoKSBmdW5jdGlvbnMKCSAqIHdpdGggd2hpY2ggZXZlcnl0aGluZyBlbHNlIGlzIGFsbG9jYXRlZC4KCSAqLwoJcC0+cGNyZTJfZ2VuZXJhbF9jb250ZXh0ID0gcGNyZTJfZ2VuZXJhbF9jb250ZXh0X2NyZWF0ZSgKCQlwY3JlMl9tYWxsb2MsIHBjcmUyX2ZyZWUsIE5VTEwpOwoJaWYgKCFwLT5wY3JlMl9nZW5lcmFsX2NvbnRleHQpCgkJZGllKCJDb3VsZG4ndCBhbGxvY2F0ZSBQQ1JFMiBnZW5lcmFsIGNvbnRleHQiKTsKCglpZiAob3B0LT5pZ25vcmVfY2FzZSkgewoJCWlmICghb3B0LT5pZ25vcmVfbG9jYWxlICYmIGhhc19ub25fYXNjaWkocC0+cGF0dGVybikpIHsKCQkJcC0+cGNyZTJfdGFibGVzID0gcGNyZTJfbWFrZXRhYmxlcyhwLT5wY3JlMl9nZW5lcmFsX2NvbnRleHQpOwoJCQlwLT5wY3JlMl9jb21waWxlX2NvbnRleHQgPSBwY3JlMl9jb21waWxlX2NvbnRleHRfY3JlYXRlKHAtPnBjcmUyX2dlbmVyYWxfY29udGV4dCk7CgkJCXBjcmUyX3NldF9jaGFyYWN0ZXJfdGFibGVzKHAtPnBjcmUyX2NvbXBpbGVfY29udGV4dCwKCQkJCQkJCXAtPnBjcmUyX3RhYmxlcyk7CgkJfQoJCW9wdGlvbnMgfD0gUENSRTJfQ0FTRUxFU1M7Cgl9CglpZiAoIW9wdC0+aWdub3JlX2xvY2FsZSAmJiBpc191dGY4X2xvY2FsZSgpICYmICFsaXRlcmFsKQoJCW9wdGlvbnMgfD0gKFBDUkUyX1VURiB8IFBDUkUyX1VDUCB8IFBDUkUyX01BVENIX0lOVkFMSURfVVRGKTsKCiNpZm5kZWYgR0lUX1BDUkUyX1ZFUlNJT05fMTBfMzVfT1JfSElHSEVSCgkvKgoJICogV29yayBhcm91bmQgYSBKSVQgYnVnIHJlbGF0ZWQgdG8gaW52YWxpZCBVbmljb2RlIGNoYXJhY3RlciBoYW5kbGluZwoJICogZml4ZWQgaW4gMTAuMzU6CgkgKiBodHRwczovL2dpdGh1Yi5jb20vUENSRTJQcm9qZWN0L3BjcmUyL2NvbW1pdC9jMjFiZDk3NzU0N2QKCSAqLwoJb3B0aW9ucyAmPSB+UENSRTJfVUNQOwojZW5kaWYKCiNpZm5kZWYgR0lUX1BDUkUyX1ZFUlNJT05fMTBfMzZfT1JfSElHSEVSCgkvKiBXb3JrIGFyb3VuZCBodHRwczovL2J1Z3MuZXhpbS5vcmcvc2hvd19idWcuY2dpP2lkPTI2NDIgZml4ZWQgaW4gMTAuMzYgKi8KCWlmIChQQ1JFMl9NQVRDSF9JTlZBTElEX1VURiAmJiBvcHRpb25zICYgKFBDUkUyX1VURiB8IFBDUkUyX0NBU0VMRVNTKSkKCQlvcHRpb25zIHw9IFBDUkUyX05PX1NUQVJUX09QVElNSVpFOwojZW5kaWYKCglwLT5wY3JlMl9wYXR0ZXJuID0gcGNyZTJfY29tcGlsZSgoUENSRTJfU1BUUilwLT5wYXR0ZXJuLAoJCQkJCSBwLT5wYXR0ZXJubGVuLCBvcHRpb25zLCAmZXJyb3IsICZlcnJvZmZzZXQsCgkJCQkJIHAtPnBjcmUyX2NvbXBpbGVfY29udGV4dCk7CgoJaWYgKHAtPnBjcmUyX3BhdHRlcm4pIHsKCQlwLT5wY3JlMl9tYXRjaF9kYXRhID0gcGNyZTJfbWF0Y2hfZGF0YV9jcmVhdGVfZnJvbV9wYXR0ZXJuKHAtPnBjcmUyX3BhdHRlcm4sIHAtPnBjcmUyX2dlbmVyYWxfY29udGV4dCk7CgkJaWYgKCFwLT5wY3JlMl9tYXRjaF9kYXRhKQoJCQlkaWUoIkNvdWxkbid0IGFsbG9jYXRlIFBDUkUyIG1hdGNoIGRhdGEiKTsKCX0gZWxzZSB7CgkJcGNyZTJfZ2V0X2Vycm9yX21lc3NhZ2UoZXJyb3IsIGVycmJ1Ziwgc2l6ZW9mKGVycmJ1ZikpOwoJCWNvbXBpbGVfcmVnZXhwX2ZhaWxlZChwLCAoY29uc3QgY2hhciAqKSZlcnJidWYpOwoJfQoKCXBjcmUyX2NvbmZpZyhQQ1JFMl9DT05GSUdfSklULCAmcC0+cGNyZTJfaml0X29uKTsKCWlmIChwLT5wY3JlMl9qaXRfb24pIHsKCQlqaXRyZXQgPSBwY3JlMl9qaXRfY29tcGlsZShwLT5wY3JlMl9wYXR0ZXJuLCBQQ1JFMl9KSVRfQ09NUExFVEUpOwoJCWlmIChqaXRyZXQpCgkJCWRpZSgiQ291bGRuJ3QgSklUIHRoZSBQQ1JFMiBwYXR0ZXJuICclcycsIGdvdCAnJWQnXG4iLCBwLT5wYXR0ZXJuLCBqaXRyZXQpOwoKCQkvKgoJCSAqIFRoZSBwY3JlMl9jb25maWcoUENSRTJfQ09ORklHX0pJVCwgLi4uKSBjYWxsIGp1c3QKCQkgKiB0ZWxscyB1cyB3aGV0aGVyIHRoZSBsaWJyYXJ5IGl0c2VsZiBzdXBwb3J0cyBKSVQsCgkJICogYnV0IHRvIHNlZSB3aGV0aGVyIHdlJ3JlIGdvaW5nIHRvIGJlIGFjdHVhbGx5IHVzaW5nCgkJICogSklUIHdlIG5lZWQgdG8gZXh0cmFjdCBQQ1JFMl9JTkZPX0pJVFNJWkUgZnJvbSB0aGUKCQkgKiBwYXR0ZXJuICphZnRlciogd2UgZG8gcGNyZTJfaml0X2NvbXBpbGUoKSBhYm92ZS4KCQkgKgoJCSAqIFRoaXMgaXMgYmVjYXVzZSBpZiB0aGUgcGF0dGVybiBjb250YWlucyB0aGUKCQkgKiAoKk5PX0pJVCkgdmVyYiAoc2VlIHBjcmUyc3ludGF4KDMpKQoJCSAqIHBjcmUyX2ppdF9jb21waWxlKCkgd2lsbCBleGl0IGVhcmx5IHdpdGggMC4gSWYgd2UKCQkgKiB0aGVuIHByb2NlZWQgdG8gY2FsbCBwY3JlMl9qaXRfbWF0Y2goKSBmdXJ0aGVyIGRvd24KCQkgKiB0aGUgbGluZSBpbnN0ZWFkIG9mIHBjcmUyX21hdGNoKCkgd2UnbGwgZWl0aGVyCgkJICogc2VnZmF1bHQgKHByZSBQQ1JFIDEwLjMxKSBvciBydW4gaW50byBhIGZhdGFsIGVycm9yCgkJICogKHBvc3QgUENSRTIgMTAuMzEpCgkJICovCgkJcGF0aW5mb3JldCA9IHBjcmUyX3BhdHRlcm5faW5mbyhwLT5wY3JlMl9wYXR0ZXJuLCBQQ1JFMl9JTkZPX0pJVFNJWkUsICZqaXRzaXplYXJnKTsKCQlpZiAocGF0aW5mb3JldCkKCQkJQlVHKCJwY3JlMl9wYXR0ZXJuX2luZm8oKSBmYWlsZWQ6ICVkIiwgcGF0aW5mb3JldCk7CgkJaWYgKGppdHNpemVhcmcgPT0gMCkgewoJCQlwLT5wY3JlMl9qaXRfb24gPSAwOwoJCQlyZXR1cm47CgkJfQoJfQp9CgpzdGF0aWMgaW50IHBjcmUybWF0Y2goc3RydWN0IGdyZXBfcGF0ICpwLCBjb25zdCBjaGFyICpsaW5lLCBjb25zdCBjaGFyICplb2wsCgkJcmVnbWF0Y2hfdCAqbWF0Y2gsIGludCBlZmxhZ3MpCnsKCWludCByZXQsIGZsYWdzID0gMDsKCVBDUkUyX1NJWkUgKm92ZWN0b3I7CglQQ1JFMl9VQ0hBUiBlcnJidWZbMjU2XTsKCglpZiAoZWZsYWdzICYgUkVHX05PVEJPTCkKCQlmbGFncyB8PSBQQ1JFMl9OT1RCT0w7CgoJaWYgKHAtPnBjcmUyX2ppdF9vbikKCQlyZXQgPSBwY3JlMl9qaXRfbWF0Y2gocC0+cGNyZTJfcGF0dGVybiwgKHVuc2lnbmVkIGNoYXIgKilsaW5lLAoJCQkJICAgICAgZW9sIC0gbGluZSwgMCwgZmxhZ3MsIHAtPnBjcmUyX21hdGNoX2RhdGEsCgkJCQkgICAgICBOVUxMKTsKCWVsc2UKCQlyZXQgPSBwY3JlMl9tYXRjaChwLT5wY3JlMl9wYXR0ZXJuLCAodW5zaWduZWQgY2hhciAqKWxpbmUsCgkJCQkgIGVvbCAtIGxpbmUsIDAsIGZsYWdzLCBwLT5wY3JlMl9tYXRjaF9kYXRhLAoJCQkJICBOVUxMKTsKCglpZiAocmV0IDwgMCAmJiByZXQgIT0gUENSRTJfRVJST1JfTk9NQVRDSCkgewoJCXBjcmUyX2dldF9lcnJvcl9tZXNzYWdlKHJldCwgZXJyYnVmLCBzaXplb2YoZXJyYnVmKSk7CgkJZGllKCIlcyBmYWlsZWQgd2l0aCBlcnJvciBjb2RlICVkOiAlcyIsCgkJICAgIChwLT5wY3JlMl9qaXRfb24gPyAicGNyZTJfaml0X21hdGNoIiA6ICJwY3JlMl9tYXRjaCIpLCByZXQsCgkJICAgIGVycmJ1Zik7Cgl9CglpZiAocmV0ID4gMCkgewoJCW92ZWN0b3IgPSBwY3JlMl9nZXRfb3ZlY3Rvcl9wb2ludGVyKHAtPnBjcmUyX21hdGNoX2RhdGEpOwoJCXJldCA9IDA7CgkJbWF0Y2gtPnJtX3NvID0gKGludClvdmVjdG9yWzBdOwoJCW1hdGNoLT5ybV9lbyA9IChpbnQpb3ZlY3RvclsxXTsKCX0KCglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgdm9pZCBmcmVlX3BjcmUyX3BhdHRlcm4oc3RydWN0IGdyZXBfcGF0ICpwKQp7CglwY3JlMl9jb21waWxlX2NvbnRleHRfZnJlZShwLT5wY3JlMl9jb21waWxlX2NvbnRleHQpOwoJcGNyZTJfY29kZV9mcmVlKHAtPnBjcmUyX3BhdHRlcm4pOwoJcGNyZTJfbWF0Y2hfZGF0YV9mcmVlKHAtPnBjcmUyX21hdGNoX2RhdGEpOwojaWZkZWYgR0lUX1BDUkUyX1ZFUlNJT05fMTBfMzRfT1JfSElHSEVSCglwY3JlMl9tYWtldGFibGVzX2ZyZWUocC0+cGNyZTJfZ2VuZXJhbF9jb250ZXh0LCBwLT5wY3JlMl90YWJsZXMpOwojZWxzZQoJZnJlZSgodm9pZCAqKXAtPnBjcmUyX3RhYmxlcyk7CiNlbmRpZgoJcGNyZTJfZ2VuZXJhbF9jb250ZXh0X2ZyZWUocC0+cGNyZTJfZ2VuZXJhbF9jb250ZXh0KTsKfQojZWxzZSAvKiAhVVNFX0xJQlBDUkUyICovCnN0YXRpYyB2b2lkIGNvbXBpbGVfcGNyZTJfcGF0dGVybihzdHJ1Y3QgZ3JlcF9wYXQgKnAsIGNvbnN0IHN0cnVjdCBncmVwX29wdCAqb3B0KQp7CglkaWUoImNhbm5vdCB1c2UgUGVybC1jb21wYXRpYmxlIHJlZ2V4ZXMgd2hlbiBub3QgY29tcGlsZWQgd2l0aCBVU0VfTElCUENSRSIpOwp9CgpzdGF0aWMgaW50IHBjcmUybWF0Y2goc3RydWN0IGdyZXBfcGF0ICpwLCBjb25zdCBjaGFyICpsaW5lLCBjb25zdCBjaGFyICplb2wsCgkJcmVnbWF0Y2hfdCAqbWF0Y2gsIGludCBlZmxhZ3MpCnsKCXJldHVybiAxOwp9CgpzdGF0aWMgdm9pZCBmcmVlX3BjcmUyX3BhdHRlcm4oc3RydWN0IGdyZXBfcGF0ICpwKQp7Cn0KCnN0YXRpYyB2b2lkIGNvbXBpbGVfZml4ZWRfcmVnZXhwKHN0cnVjdCBncmVwX3BhdCAqcCwgc3RydWN0IGdyZXBfb3B0ICpvcHQpCnsKCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCWludCBlcnI7CglpbnQgcmVnZmxhZ3MgPSAwOwoKCWJhc2ljX3JlZ2V4X3F1b3RlX2J1Zigmc2IsIHAtPnBhdHRlcm4pOwoJaWYgKG9wdC0+aWdub3JlX2Nhc2UpCgkJcmVnZmxhZ3MgfD0gUkVHX0lDQVNFOwoJZXJyID0gcmVnY29tcCgmcC0+cmVnZXhwLCBzYi5idWYsIHJlZ2ZsYWdzKTsKCXN0cmJ1Zl9yZWxlYXNlKCZzYik7CglpZiAoZXJyKSB7CgkJY2hhciBlcnJidWZbMTAyNF07CgkJcmVnZXJyb3IoZXJyLCAmcC0+cmVnZXhwLCBlcnJidWYsIHNpemVvZihlcnJidWYpKTsKCQljb21waWxlX3JlZ2V4cF9mYWlsZWQocCwgZXJyYnVmKTsKCX0KfQojZW5kaWYgLyogIVVTRV9MSUJQQ1JFMiAqLwoKc3RhdGljIHZvaWQgY29tcGlsZV9yZWdleHAoc3RydWN0IGdyZXBfcGF0ICpwLCBzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCkKewoJaW50IGVycjsKCWludCByZWdmbGFncyA9IFJFR19ORVdMSU5FOwoKCWlmIChvcHQtPnBhdHRlcm5fdHlwZV9vcHRpb24gPT0gR1JFUF9QQVRURVJOX1RZUEVfVU5TUEVDSUZJRUQpCgkJb3B0LT5wYXR0ZXJuX3R5cGVfb3B0aW9uID0gKG9wdC0+ZXh0ZW5kZWRfcmVnZXhwX29wdGlvbgoJCQkJCSAgICA/IEdSRVBfUEFUVEVSTl9UWVBFX0VSRQoJCQkJCSAgICA6IEdSRVBfUEFUVEVSTl9UWVBFX0JSRSk7CgoJcC0+d29yZF9yZWdleHAgPSBvcHQtPndvcmRfcmVnZXhwOwoJcC0+aWdub3JlX2Nhc2UgPSBvcHQtPmlnbm9yZV9jYXNlOwoJcC0+Zml4ZWQgPSBvcHQtPnBhdHRlcm5fdHlwZV9vcHRpb24gPT0gR1JFUF9QQVRURVJOX1RZUEVfRklYRUQ7CgoJaWYgKG9wdC0+cGF0dGVybl90eXBlX29wdGlvbiAhPSBHUkVQX1BBVFRFUk5fVFlQRV9QQ1JFICYmCgkgICAgbWVtY2hyKHAtPnBhdHRlcm4sIDAsIHAtPnBhdHRlcm5sZW4pKQoJCWRpZShfKCJnaXZlbiBwYXR0ZXJuIGNvbnRhaW5zIE5VTEwgYnl0ZSAodmlhIC1mIDxmaWxlPikuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgd2l0aCAtUCB1bmRlciBQQ1JFIHYyIikpOwoKCXAtPmlzX2ZpeGVkID0gaXNfZml4ZWQocC0+cGF0dGVybiwgcC0+cGF0dGVybmxlbik7CiNpZmRlZiBVU0VfTElCUENSRTIKICAgICAgIGlmICghcC0+Zml4ZWQgJiYgIXAtPmlzX2ZpeGVkKSB7CgkgICAgICAgY29uc3QgY2hhciAqbm9faml0ID0gIigqTk9fSklUKSI7CgkgICAgICAgY29uc3QgaW50IG5vX2ppdF9sZW4gPSBzdHJsZW4obm9faml0KTsKCSAgICAgICBpZiAoc3RhcnRzX3dpdGgocC0+cGF0dGVybiwgbm9faml0KSAmJgoJCSAgIGlzX2ZpeGVkKHAtPnBhdHRlcm4gKyBub19qaXRfbGVuLAoJCQkgICAgcC0+cGF0dGVybmxlbiAtIG5vX2ppdF9sZW4pKQoJCSAgICAgICBwLT5pc19maXhlZCA9IDE7CiAgICAgICB9CiNlbmRpZgoJaWYgKHAtPmZpeGVkIHx8IHAtPmlzX2ZpeGVkKSB7CiNpZmRlZiBVU0VfTElCUENSRTIKCQlpZiAocC0+aXNfZml4ZWQpIHsKCQkJY29tcGlsZV9wY3JlMl9wYXR0ZXJuKHAsIG9wdCk7CgkJfSBlbHNlIHsKCQkJLyoKCQkJICogRS5nLiB0NzgxMS1ncmVwLW9wZW4uc2ggcmVsaWVzIG9uIHRoZQoJCQkgKiBwYXR0ZXJuIGJlaW5nIHJlc3RvcmVkLgoJCQkgKi8KCQkJY2hhciAqb2xkX3BhdHRlcm4gPSBwLT5wYXR0ZXJuOwoJCQlzaXplX3Qgb2xkX3BhdHRlcm5sZW4gPSBwLT5wYXR0ZXJubGVuOwoJCQlzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CgoJCQkvKgoJCQkgKiBUaGVyZSBpcyB0aGUgUENSRTJfTElURVJBTCBmbGFnLCBidXQgaXQncwoJCQkgKiBvbmx5IGluIFBDUkUgdjIgMTAuMzAgYW5kIGxhdGVyLiBOZWVkaW5nIHRvCgkJCSAqIGlmZGVmIG91ciB3YXkgYXJvdW5kIHRoYXQgYW5kIGRlYWxpbmcgd2l0aAoJCQkgKiBpdCArIFBDUkUyX01VTFRJTElORSBiZWluZyBhbiBlcnJvciBpcyBtb3JlCgkJCSAqIGNvbXBsZXggdGhhbiBqdXN0IHF1b3RpbmcgdGhpcyBvdXJzZWx2ZXMuCgkJCSovCgkJCXN0cmJ1Zl9hZGQoJnNiLCAiXFxRIiwgMik7CgkJCXN0cmJ1Zl9hZGQoJnNiLCBwLT5wYXR0ZXJuLCBwLT5wYXR0ZXJubGVuKTsKCQkJc3RyYnVmX2FkZCgmc2IsICJcXEUiLCAyKTsKCgkJCXAtPnBhdHRlcm4gPSBzYi5idWY7CgkJCXAtPnBhdHRlcm5sZW4gPSBzYi5sZW47CgkJCWNvbXBpbGVfcGNyZTJfcGF0dGVybihwLCBvcHQpOwoJCQlwLT5wYXR0ZXJuID0gb2xkX3BhdHRlcm47CgkJCXAtPnBhdHRlcm5sZW4gPSBvbGRfcGF0dGVybmxlbjsKCQkJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCQl9CiNlbHNlIC8qICFVU0VfTElCUENSRTIgKi8KCQljb21waWxlX2ZpeGVkX3JlZ2V4cChwLCBvcHQpOwojZW5kaWYgLyogIVVTRV9MSUJQQ1JFMiAqLwoJCXJldHVybjsKCX0KCglpZiAob3B0LT5wYXR0ZXJuX3R5cGVfb3B0aW9uID09IEdSRVBfUEFUVEVSTl9UWVBFX1BDUkUpIHsKCQljb21waWxlX3BjcmUyX3BhdHRlcm4ocCwgb3B0KTsKCQlyZXR1cm47Cgl9CgoJaWYgKHAtPmlnbm9yZV9jYXNlKQoJCXJlZ2ZsYWdzIHw9IFJFR19JQ0FTRTsKCWlmIChvcHQtPnBhdHRlcm5fdHlwZV9vcHRpb24gPT0gR1JFUF9QQVRURVJOX1RZUEVfRVJFKQoJCXJlZ2ZsYWdzIHw9IFJFR19FWFRFTkRFRDsKCWVyciA9IHJlZ2NvbXAoJnAtPnJlZ2V4cCwgcC0+cGF0dGVybiwgcmVnZmxhZ3MpOwoJaWYgKGVycikgewoJCWNoYXIgZXJyYnVmWzEwMjRdOwoJCXJlZ2Vycm9yKGVyciwgJnAtPnJlZ2V4cCwgZXJyYnVmLCAxMDI0KTsKCQljb21waWxlX3JlZ2V4cF9mYWlsZWQocCwgZXJyYnVmKTsKCX0KfQoKc3RhdGljIHN0cnVjdCBncmVwX2V4cHIgKmdyZXBfbm90X2V4cHIoc3RydWN0IGdyZXBfZXhwciAqZXhwcikKewoJc3RydWN0IGdyZXBfZXhwciAqeiA9IHhjYWxsb2MoMSwgc2l6ZW9mKCp6KSk7Cgl6LT5ub2RlID0gR1JFUF9OT0RFX05PVDsKCXotPnUudW5hcnkgPSBleHByOwoJcmV0dXJuIHo7Cn0KCnN0YXRpYyBzdHJ1Y3QgZ3JlcF9leHByICpncmVwX2JpbmV4cChlbnVtIGdyZXBfZXhwcl9ub2RlIGtpbmQsCgkJCQkgICAgIHN0cnVjdCBncmVwX2V4cHIgKmxlZnQsCgkJCQkgICAgIHN0cnVjdCBncmVwX2V4cHIgKnJpZ2h0KQp7CglzdHJ1Y3QgZ3JlcF9leHByICp6ID0geGNhbGxvYygxLCBzaXplb2YoKnopKTsKCXotPm5vZGUgPSBraW5kOwoJei0+dS5iaW5hcnkubGVmdCA9IGxlZnQ7Cgl6LT51LmJpbmFyeS5yaWdodCA9IHJpZ2h0OwoJcmV0dXJuIHo7Cn0KCnN0YXRpYyBzdHJ1Y3QgZ3JlcF9leHByICpncmVwX29yX2V4cHIoc3RydWN0IGdyZXBfZXhwciAqbGVmdCwgc3RydWN0IGdyZXBfZXhwciAqcmlnaHQpCnsKCXJldHVybiBncmVwX2JpbmV4cChHUkVQX05PREVfT1IsIGxlZnQsIHJpZ2h0KTsKfQoKc3RhdGljIHN0cnVjdCBncmVwX2V4cHIgKmdyZXBfYW5kX2V4cHIoc3RydWN0IGdyZXBfZXhwciAqbGVmdCwgc3RydWN0IGdyZXBfZXhwciAqcmlnaHQpCnsKCXJldHVybiBncmVwX2JpbmV4cChHUkVQX05PREVfQU5ELCBsZWZ0LCByaWdodCk7Cn0KCnN0YXRpYyBzdHJ1Y3QgZ3JlcF9leHByICpjb21waWxlX3BhdHRlcm5fb3Ioc3RydWN0IGdyZXBfcGF0ICoqKTsKc3RhdGljIHN0cnVjdCBncmVwX2V4cHIgKmNvbXBpbGVfcGF0dGVybl9hdG9tKHN0cnVjdCBncmVwX3BhdCAqKmxpc3QpCnsKCXN0cnVjdCBncmVwX3BhdCAqcDsKCXN0cnVjdCBncmVwX2V4cHIgKng7CgoJcCA9ICpsaXN0OwoJaWYgKCFwKQoJCXJldHVybiBOVUxMOwoJc3dpdGNoIChwLT50b2tlbikgewoJY2FzZSBHUkVQX1BBVFRFUk46IC8qIGF0b20gKi8KCWNhc2UgR1JFUF9QQVRURVJOX0hFQUQ6CgljYXNlIEdSRVBfUEFUVEVSTl9CT0RZOgoJCUNBTExPQ19BUlJBWSh4LCAxKTsKCQl4LT5ub2RlID0gR1JFUF9OT0RFX0FUT007CgkJeC0+dS5hdG9tID0gcDsKCQkqbGlzdCA9IHAtPm5leHQ7CgkJcmV0dXJuIHg7CgljYXNlIEdSRVBfT1BFTl9QQVJFTjoKCQkqbGlzdCA9IHAtPm5leHQ7CgkJeCA9IGNvbXBpbGVfcGF0dGVybl9vcihsaXN0KTsKCQlpZiAoISpsaXN0IHx8ICgqbGlzdCktPnRva2VuICE9IEdSRVBfQ0xPU0VfUEFSRU4pCgkJCWRpZSgidW5tYXRjaGVkIHBhcmVudGhlc2lzIik7CgkJKmxpc3QgPSAoKmxpc3QpLT5uZXh0OwoJCXJldHVybiB4OwoJZGVmYXVsdDoKCQlyZXR1cm4gTlVMTDsKCX0KfQoKc3RhdGljIHN0cnVjdCBncmVwX2V4cHIgKmNvbXBpbGVfcGF0dGVybl9ub3Qoc3RydWN0IGdyZXBfcGF0ICoqbGlzdCkKewoJc3RydWN0IGdyZXBfcGF0ICpwOwoJc3RydWN0IGdyZXBfZXhwciAqeDsKCglwID0gKmxpc3Q7CglpZiAoIXApCgkJcmV0dXJuIE5VTEw7Cglzd2l0Y2ggKHAtPnRva2VuKSB7CgljYXNlIEdSRVBfTk9UOgoJCWlmICghcC0+bmV4dCkKCQkJZGllKCItLW5vdCBub3QgZm9sbG93ZWQgYnkgcGF0dGVybiBleHByZXNzaW9uIik7CgkJKmxpc3QgPSBwLT5uZXh0OwoJCXggPSBjb21waWxlX3BhdHRlcm5fbm90KGxpc3QpOwoJCWlmICgheCkKCQkJZGllKCItLW5vdCBmb2xsb3dlZCBieSBub24gcGF0dGVybiBleHByZXNzaW9uIik7CgkJcmV0dXJuIGdyZXBfbm90X2V4cHIoeCk7CglkZWZhdWx0OgoJCXJldHVybiBjb21waWxlX3BhdHRlcm5fYXRvbShsaXN0KTsKCX0KfQoKc3RhdGljIHN0cnVjdCBncmVwX2V4cHIgKmNvbXBpbGVfcGF0dGVybl9hbmQoc3RydWN0IGdyZXBfcGF0ICoqbGlzdCkKewoJc3RydWN0IGdyZXBfcGF0ICpwOwoJc3RydWN0IGdyZXBfZXhwciAqeCwgKnk7CgoJeCA9IGNvbXBpbGVfcGF0dGVybl9ub3QobGlzdCk7CglwID0gKmxpc3Q7CglpZiAocCAmJiBwLT50b2tlbiA9PSBHUkVQX0FORCkgewoJCWlmICgheCkKCQkJZGllKCItLWFuZCBub3QgcHJlY2VkZWQgYnkgcGF0dGVybiBleHByZXNzaW9uIik7CgkJaWYgKCFwLT5uZXh0KQoJCQlkaWUoIi0tYW5kIG5vdCBmb2xsb3dlZCBieSBwYXR0ZXJuIGV4cHJlc3Npb24iKTsKCQkqbGlzdCA9IHAtPm5leHQ7CgkJeSA9IGNvbXBpbGVfcGF0dGVybl9hbmQobGlzdCk7CgkJaWYgKCF5KQoJCQlkaWUoIi0tYW5kIG5vdCBmb2xsb3dlZCBieSBwYXR0ZXJuIGV4cHJlc3Npb24iKTsKCQlyZXR1cm4gZ3JlcF9hbmRfZXhwcih4LCB5KTsKCX0KCXJldHVybiB4Owp9CgpzdGF0aWMgc3RydWN0IGdyZXBfZXhwciAqY29tcGlsZV9wYXR0ZXJuX29yKHN0cnVjdCBncmVwX3BhdCAqKmxpc3QpCnsKCXN0cnVjdCBncmVwX3BhdCAqcDsKCXN0cnVjdCBncmVwX2V4cHIgKngsICp5OwoKCXggPSBjb21waWxlX3BhdHRlcm5fYW5kKGxpc3QpOwoJcCA9ICpsaXN0OwoJaWYgKHggJiYgcCAmJiBwLT50b2tlbiAhPSBHUkVQX0NMT1NFX1BBUkVOKSB7CgkJeSA9IGNvbXBpbGVfcGF0dGVybl9vcihsaXN0KTsKCQlpZiAoIXkpCgkJCWRpZSgibm90IGEgcGF0dGVybiBleHByZXNzaW9uICVzIiwgcC0+cGF0dGVybik7CgkJcmV0dXJuIGdyZXBfb3JfZXhwcih4LCB5KTsKCX0KCXJldHVybiB4Owp9CgpzdGF0aWMgc3RydWN0IGdyZXBfZXhwciAqY29tcGlsZV9wYXR0ZXJuX2V4cHIoc3RydWN0IGdyZXBfcGF0ICoqbGlzdCkKewoJcmV0dXJuIGNvbXBpbGVfcGF0dGVybl9vcihsaXN0KTsKfQoKc3RhdGljIHN0cnVjdCBncmVwX2V4cHIgKmdyZXBfdHJ1ZV9leHByKHZvaWQpCnsKCXN0cnVjdCBncmVwX2V4cHIgKnogPSB4Y2FsbG9jKDEsIHNpemVvZigqeikpOwoJei0+bm9kZSA9IEdSRVBfTk9ERV9UUlVFOwoJcmV0dXJuIHo7Cn0KCnN0YXRpYyBzdHJ1Y3QgZ3JlcF9leHByICpwcmVwX2hlYWRlcl9wYXR0ZXJucyhzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCkKewoJc3RydWN0IGdyZXBfcGF0ICpwOwoJc3RydWN0IGdyZXBfZXhwciAqaGVhZGVyX2V4cHI7CglzdHJ1Y3QgZ3JlcF9leHByICooaGVhZGVyX2dyb3VwW0dSRVBfSEVBREVSX0ZJRUxEX01BWF0pOwoJZW51bSBncmVwX2hlYWRlcl9maWVsZCBmbGQ7CgoJaWYgKCFvcHQtPmhlYWRlcl9saXN0KQoJCXJldHVybiBOVUxMOwoKCWZvciAocCA9IG9wdC0+aGVhZGVyX2xpc3Q7IHA7IHAgPSBwLT5uZXh0KSB7CgkJaWYgKHAtPnRva2VuICE9IEdSRVBfUEFUVEVSTl9IRUFEKQoJCQlCVUcoImEgbm9uLWhlYWRlciBwYXR0ZXJuIGluIGdyZXAgaGVhZGVyIGxpc3QuIik7CgkJaWYgKHAtPmZpZWxkIDwgR1JFUF9IRUFERVJfRklFTERfTUlOIHx8CgkJICAgIEdSRVBfSEVBREVSX0ZJRUxEX01BWCA8PSBwLT5maWVsZCkKCQkJQlVHKCJ1bmtub3duIGhlYWRlciBmaWVsZCAlZCIsIHAtPmZpZWxkKTsKCQljb21waWxlX3JlZ2V4cChwLCBvcHQpOwoJfQoKCWZvciAoZmxkID0gMDsgZmxkIDwgR1JFUF9IRUFERVJfRklFTERfTUFYOyBmbGQrKykKCQloZWFkZXJfZ3JvdXBbZmxkXSA9IE5VTEw7CgoJZm9yIChwID0gb3B0LT5oZWFkZXJfbGlzdDsgcDsgcCA9IHAtPm5leHQpIHsKCQlzdHJ1Y3QgZ3JlcF9leHByICpoOwoJCXN0cnVjdCBncmVwX3BhdCAqcHAgPSBwOwoKCQloID0gY29tcGlsZV9wYXR0ZXJuX2F0b20oJnBwKTsKCQlpZiAoIWggfHwgcHAgIT0gcC0+bmV4dCkKCQkJQlVHKCJtYWxmb3JtZWQgaGVhZGVyIGV4cHIiKTsKCQlpZiAoIWhlYWRlcl9ncm91cFtwLT5maWVsZF0pIHsKCQkJaGVhZGVyX2dyb3VwW3AtPmZpZWxkXSA9IGg7CgkJCWNvbnRpbnVlOwoJCX0KCQloZWFkZXJfZ3JvdXBbcC0+ZmllbGRdID0gZ3JlcF9vcl9leHByKGgsIGhlYWRlcl9ncm91cFtwLT5maWVsZF0pOwoJfQoKCWhlYWRlcl9leHByID0gTlVMTDsKCglmb3IgKGZsZCA9IDA7IGZsZCA8IEdSRVBfSEVBREVSX0ZJRUxEX01BWDsgZmxkKyspIHsKCQlpZiAoIWhlYWRlcl9ncm91cFtmbGRdKQoJCQljb250aW51ZTsKCQlpZiAoIWhlYWRlcl9leHByKQoJCQloZWFkZXJfZXhwciA9IGdyZXBfdHJ1ZV9leHByKCk7CgkJaGVhZGVyX2V4cHIgPSBncmVwX29yX2V4cHIoaGVhZGVyX2dyb3VwW2ZsZF0sIGhlYWRlcl9leHByKTsKCX0KCXJldHVybiBoZWFkZXJfZXhwcjsKfQoKc3RhdGljIHN0cnVjdCBncmVwX2V4cHIgKmdyZXBfc3BsaWNlX29yKHN0cnVjdCBncmVwX2V4cHIgKngsIHN0cnVjdCBncmVwX2V4cHIgKnkpCnsKCXN0cnVjdCBncmVwX2V4cHIgKnogPSB4OwoKCXdoaWxlICh4KSB7CgkJYXNzZXJ0KHgtPm5vZGUgPT0gR1JFUF9OT0RFX09SKTsKCQlpZiAoeC0+dS5iaW5hcnkucmlnaHQgJiYKCQkgICAgeC0+dS5iaW5hcnkucmlnaHQtPm5vZGUgPT0gR1JFUF9OT0RFX1RSVUUpIHsKCQkJeC0+dS5iaW5hcnkucmlnaHQgPSB5OwoJCQlicmVhazsKCQl9CgkJeCA9IHgtPnUuYmluYXJ5LnJpZ2h0OwoJfQoJcmV0dXJuIHo7Cn0KCnZvaWQgY29tcGlsZV9ncmVwX3BhdHRlcm5zKHN0cnVjdCBncmVwX29wdCAqb3B0KQp7CglzdHJ1Y3QgZ3JlcF9wYXQgKnA7CglzdHJ1Y3QgZ3JlcF9leHByICpoZWFkZXJfZXhwciA9IHByZXBfaGVhZGVyX3BhdHRlcm5zKG9wdCk7CglpbnQgZXh0ZW5kZWQgPSAwOwoKCWZvciAocCA9IG9wdC0+cGF0dGVybl9saXN0OyBwOyBwID0gcC0+bmV4dCkgewoJCXN3aXRjaCAocC0+dG9rZW4pIHsKCQljYXNlIEdSRVBfUEFUVEVSTjogLyogYXRvbSAqLwoJCWNhc2UgR1JFUF9QQVRURVJOX0hFQUQ6CgkJY2FzZSBHUkVQX1BBVFRFUk5fQk9EWToKCQkJY29tcGlsZV9yZWdleHAocCwgb3B0KTsKCQkJYnJlYWs7CgkJZGVmYXVsdDoKCQkJZXh0ZW5kZWQgPSAxOwoJCQlicmVhazsKCQl9Cgl9CgoJaWYgKG9wdC0+YWxsX21hdGNoIHx8IG9wdC0+bm9fYm9keV9tYXRjaCB8fCBoZWFkZXJfZXhwcikKCQlleHRlbmRlZCA9IDE7CgllbHNlIGlmICghZXh0ZW5kZWQpCgkJcmV0dXJuOwoKCXAgPSBvcHQtPnBhdHRlcm5fbGlzdDsKCWlmIChwKQoJCW9wdC0+cGF0dGVybl9leHByZXNzaW9uID0gY29tcGlsZV9wYXR0ZXJuX2V4cHIoJnApOwoJaWYgKHApCgkJZGllKCJpbmNvbXBsZXRlIHBhdHRlcm4gZXhwcmVzc2lvbjogJXMiLCBwLT5wYXR0ZXJuKTsKCglpZiAob3B0LT5ub19ib2R5X21hdGNoICYmIG9wdC0+cGF0dGVybl9leHByZXNzaW9uKQoJCW9wdC0+cGF0dGVybl9leHByZXNzaW9uID0gZ3JlcF9ub3RfZXhwcihvcHQtPnBhdHRlcm5fZXhwcmVzc2lvbik7CgoJaWYgKCFoZWFkZXJfZXhwcikKCQlyZXR1cm47CgoJaWYgKCFvcHQtPnBhdHRlcm5fZXhwcmVzc2lvbikKCQlvcHQtPnBhdHRlcm5fZXhwcmVzc2lvbiA9IGhlYWRlcl9leHByOwoJZWxzZSBpZiAob3B0LT5hbGxfbWF0Y2gpCgkJb3B0LT5wYXR0ZXJuX2V4cHJlc3Npb24gPSBncmVwX3NwbGljZV9vcihoZWFkZXJfZXhwciwKCQkJCQkJCSBvcHQtPnBhdHRlcm5fZXhwcmVzc2lvbik7CgllbHNlCgkJb3B0LT5wYXR0ZXJuX2V4cHJlc3Npb24gPSBncmVwX29yX2V4cHIob3B0LT5wYXR0ZXJuX2V4cHJlc3Npb24sCgkJCQkJCSAgICAgICBoZWFkZXJfZXhwcik7CglvcHQtPmFsbF9tYXRjaCA9IDE7Cn0KCnN0YXRpYyB2b2lkIGZyZWVfcGF0dGVybl9leHByKHN0cnVjdCBncmVwX2V4cHIgKngpCnsKCXN3aXRjaCAoeC0+bm9kZSkgewoJY2FzZSBHUkVQX05PREVfVFJVRToKCWNhc2UgR1JFUF9OT0RFX0FUT006CgkJYnJlYWs7CgljYXNlIEdSRVBfTk9ERV9OT1Q6CgkJZnJlZV9wYXR0ZXJuX2V4cHIoeC0+dS51bmFyeSk7CgkJYnJlYWs7CgljYXNlIEdSRVBfTk9ERV9BTkQ6CgljYXNlIEdSRVBfTk9ERV9PUjoKCQlmcmVlX3BhdHRlcm5fZXhwcih4LT51LmJpbmFyeS5sZWZ0KTsKCQlmcmVlX3BhdHRlcm5fZXhwcih4LT51LmJpbmFyeS5yaWdodCk7CgkJYnJlYWs7Cgl9CglmcmVlKHgpOwp9Cgp2b2lkIGZyZWVfZ3JlcF9wYXR0ZXJucyhzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCkKewoJc3RydWN0IGdyZXBfcGF0ICpwLCAqbjsKCglmb3IgKHAgPSBvcHQtPnBhdHRlcm5fbGlzdDsgcDsgcCA9IG4pIHsKCQluID0gcC0+bmV4dDsKCQlzd2l0Y2ggKHAtPnRva2VuKSB7CgkJY2FzZSBHUkVQX1BBVFRFUk46IC8qIGF0b20gKi8KCQljYXNlIEdSRVBfUEFUVEVSTl9IRUFEOgoJCWNhc2UgR1JFUF9QQVRURVJOX0JPRFk6CgkJCWlmIChwLT5wY3JlMl9wYXR0ZXJuKQoJCQkJZnJlZV9wY3JlMl9wYXR0ZXJuKHApOwoJCQllbHNlCgkJCQlyZWdmcmVlKCZwLT5yZWdleHApOwoJCQlmcmVlKHAtPnBhdHRlcm4pOwoJCQlicmVhazsKCQlkZWZhdWx0OgoJCQlicmVhazsKCQl9CgkJZnJlZShwKTsKCX0KCglpZiAoIW9wdC0+cGF0dGVybl9leHByZXNzaW9uKQoJCXJldHVybjsKCWZyZWVfcGF0dGVybl9leHByKG9wdC0+cGF0dGVybl9leHByZXNzaW9uKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKmVuZF9vZl9saW5lKGNvbnN0IGNoYXIgKmNwLCB1bnNpZ25lZCBsb25nICpsZWZ0KQp7Cgl1bnNpZ25lZCBsb25nIGwgPSAqbGVmdDsKCXdoaWxlIChsICYmICpjcCAhPSAnXG4nKSB7CgkJbC0tOwoJCWNwKys7Cgl9CgkqbGVmdCA9IGw7CglyZXR1cm4gY3A7Cn0KCnN0YXRpYyBpbnQgd29yZF9jaGFyKGNoYXIgY2gpCnsKCXJldHVybiBpc2FsbnVtKGNoKSB8fCBjaCA9PSAnXyc7Cn0KCnN0YXRpYyB2b2lkIG91dHB1dF9jb2xvcihzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCwgY29uc3Qgdm9pZCAqZGF0YSwgc2l6ZV90IHNpemUsCgkJCSBjb25zdCBjaGFyICpjb2xvcikKewoJaWYgKHdhbnRfY29sb3Iob3B0LT5jb2xvcikgJiYgY29sb3IgJiYgY29sb3JbMF0pIHsKCQlvcHQtPm91dHB1dChvcHQsIGNvbG9yLCBzdHJsZW4oY29sb3IpKTsKCQlvcHQtPm91dHB1dChvcHQsIGRhdGEsIHNpemUpOwoJCW9wdC0+b3V0cHV0KG9wdCwgR0lUX0NPTE9SX1JFU0VULCBzdHJsZW4oR0lUX0NPTE9SX1JFU0VUKSk7Cgl9IGVsc2UKCQlvcHQtPm91dHB1dChvcHQsIGRhdGEsIHNpemUpOwp9CgpzdGF0aWMgdm9pZCBvdXRwdXRfc2VwKHN0cnVjdCBncmVwX29wdCAqb3B0LCBjaGFyIHNpZ24pCnsKCWlmIChvcHQtPm51bGxfZm9sbG93aW5nX25hbWUpCgkJb3B0LT5vdXRwdXQob3B0LCAiXDAiLCAxKTsKCWVsc2UKCQlvdXRwdXRfY29sb3Iob3B0LCAmc2lnbiwgMSwgb3B0LT5jb2xvcnNbR1JFUF9DT0xPUl9TRVBdKTsKfQoKc3RhdGljIHZvaWQgc2hvd19uYW1lKHN0cnVjdCBncmVwX29wdCAqb3B0LCBjb25zdCBjaGFyICpuYW1lKQp7CglvdXRwdXRfY29sb3Iob3B0LCBuYW1lLCBzdHJsZW4obmFtZSksIG9wdC0+Y29sb3JzW0dSRVBfQ09MT1JfRklMRU5BTUVdKTsKCW9wdC0+b3V0cHV0KG9wdCwgb3B0LT5udWxsX2ZvbGxvd2luZ19uYW1lID8gIlwwIiA6ICJcbiIsIDEpOwp9CgpzdGF0aWMgaW50IHBhdG1hdGNoKHN0cnVjdCBncmVwX3BhdCAqcCwKCQkgICAgY29uc3QgY2hhciAqbGluZSwgY29uc3QgY2hhciAqZW9sLAoJCSAgICByZWdtYXRjaF90ICptYXRjaCwgaW50IGVmbGFncykKewoJaW50IGhpdDsKCglpZiAocC0+cGNyZTJfcGF0dGVybikKCQloaXQgPSAhcGNyZTJtYXRjaChwLCBsaW5lLCBlb2wsIG1hdGNoLCBlZmxhZ3MpOwoJZWxzZQoJCWhpdCA9ICFyZWdleGVjX2J1ZigmcC0+cmVnZXhwLCBsaW5lLCBlb2wgLSBsaW5lLCAxLCBtYXRjaCwKCQkJCSAgIGVmbGFncyk7CgoJcmV0dXJuIGhpdDsKfQoKc3RhdGljIHZvaWQgc3RyaXBfdGltZXN0YW1wKGNvbnN0IGNoYXIgKmJvbCwgY29uc3QgY2hhciAqKmVvbF9wKQp7Cgljb25zdCBjaGFyICplb2wgPSAqZW9sX3A7CgoJd2hpbGUgKGJvbCA8IC0tZW9sKSB7CgkJaWYgKCplb2wgIT0gJz4nKQoJCQljb250aW51ZTsKCQkqZW9sX3AgPSArK2VvbDsKCQlicmVhazsKCX0KfQoKc3RhdGljIHN0cnVjdCB7Cgljb25zdCBjaGFyICpmaWVsZDsKCXNpemVfdCBsZW47Cn0gaGVhZGVyX2ZpZWxkW10gPSB7Cgl7ICJhdXRob3IgIiwgNyB9LAoJeyAiY29tbWl0dGVyICIsIDEwIH0sCgl7ICJyZWZsb2cgIiwgNyB9LAp9OwoKc3RhdGljIGludCBoZWFkZXJsZXNzX21hdGNoX29uZV9wYXR0ZXJuKHN0cnVjdCBncmVwX3BhdCAqcCwKCQkJCQljb25zdCBjaGFyICpib2wsIGNvbnN0IGNoYXIgKmVvbCwKCQkJCQllbnVtIGdyZXBfY29udGV4dCBjdHgsCgkJCQkJcmVnbWF0Y2hfdCAqcG1hdGNoLCBpbnQgZWZsYWdzKQp7CglpbnQgaGl0ID0gMDsKCWNvbnN0IGNoYXIgKnN0YXJ0ID0gYm9sOwoKCWlmICgocC0+dG9rZW4gIT0gR1JFUF9QQVRURVJOKSAmJgoJICAgICgocC0+dG9rZW4gPT0gR1JFUF9QQVRURVJOX0hFQUQpICE9IChjdHggPT0gR1JFUF9DT05URVhUX0hFQUQpKSkKCQlyZXR1cm4gMDsKCiBhZ2FpbjoKCWhpdCA9IHBhdG1hdGNoKHAsIGJvbCwgZW9sLCBwbWF0Y2gsIGVmbGFncyk7CgoJaWYgKGhpdCAmJiBwLT53b3JkX3JlZ2V4cCkgewoJCWlmICgocG1hdGNoWzBdLnJtX3NvIDwgMCkgfHwKCQkgICAgKGVvbCAtIGJvbCkgPCBwbWF0Y2hbMF0ucm1fc28gfHwKCQkgICAgKHBtYXRjaFswXS5ybV9lbyA8IDApIHx8CgkJICAgIChlb2wgLSBib2wpIDwgcG1hdGNoWzBdLnJtX2VvKQoJCQlkaWUoInJlZ2V4cCByZXR1cm5lZCBub25zZW5zZSIpOwoKCQkvKiBNYXRjaCBiZWdpbm5pbmcgbXVzdCBiZSBlaXRoZXIgYmVnaW5uaW5nIG9mIHRoZQoJCSAqIGxpbmUsIG9yIGF0IHdvcmQgYm91bmRhcnkgKGkuZS4gdGhlIGxhc3QgY2hhciBtdXN0CgkJICogbm90IGJlIGEgd29yZCBjaGFyKS4gIFNpbWlsYXJseSwgbWF0Y2ggZW5kIG11c3QgYmUKCQkgKiBlaXRoZXIgZW5kIG9mIHRoZSBsaW5lLCBvciBhdCB3b3JkIGJvdW5kYXJ5CgkJICogKGkuZS4gdGhlIG5leHQgY2hhciBtdXN0IG5vdCBiZSBhIHdvcmQgY2hhcikuCgkJICovCgkJaWYgKCAoKHBtYXRjaFswXS5ybV9zbyA9PSAwKSB8fAoJCSAgICAgICF3b3JkX2NoYXIoYm9sW3BtYXRjaFswXS5ybV9zby0xXSkpICYmCgkJICAgICAoKHBtYXRjaFswXS5ybV9lbyA9PSAoZW9sLWJvbCkpIHx8CgkJICAgICAgIXdvcmRfY2hhcihib2xbcG1hdGNoWzBdLnJtX2VvXSkpICkKCQkJOwoJCWVsc2UKCQkJaGl0ID0gMDsKCgkJLyogV29yZHMgY29uc2lzdCBvZiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyLiAqLwoJCWlmIChwbWF0Y2gtPnJtX3NvID09IHBtYXRjaC0+cm1fZW8pCgkJCWhpdCA9IDA7CgoJCWlmICghaGl0ICYmIHBtYXRjaFswXS5ybV9zbyArIGJvbCArIDEgPCBlb2wpIHsKCQkJLyogVGhlcmUgY291bGQgYmUgbW9yZSB0aGFuIG9uZSBtYXRjaCBvbiB0aGUKCQkJICogbGluZSwgYW5kIHRoZSBmaXJzdCBtYXRjaCBtaWdodCBub3QgYmUKCQkJICogc3RyaWN0IHdvcmQgbWF0Y2guICBCdXQgbGF0ZXIgb25lcyBjb3VsZCBiZSEKCQkJICogRm9yd2FyZCB0byB0aGUgbmV4dCBwb3NzaWJsZSBzdGFydCwgaS5lLiB0aGUKCQkJICogbmV4dCBwb3NpdGlvbiBmb2xsb3dpbmcgYSBub24td29yZCBjaGFyLgoJCQkgKi8KCQkJYm9sID0gcG1hdGNoWzBdLnJtX3NvICsgYm9sICsgMTsKCQkJd2hpbGUgKHdvcmRfY2hhcihib2xbLTFdKSAmJiBib2wgPCBlb2wpCgkJCQlib2wrKzsKCQkJZWZsYWdzIHw9IFJFR19OT1RCT0w7CgkJCWlmIChib2wgPCBlb2wpCgkJCQlnb3RvIGFnYWluOwoJCX0KCX0KCWlmIChoaXQpIHsKCQlwbWF0Y2hbMF0ucm1fc28gKz0gYm9sIC0gc3RhcnQ7CgkJcG1hdGNoWzBdLnJtX2VvICs9IGJvbCAtIHN0YXJ0OwoJfQoJcmV0dXJuIGhpdDsKfQoKc3RhdGljIGludCBtYXRjaF9vbmVfcGF0dGVybihzdHJ1Y3QgZ3JlcF9wYXQgKnAsCgkJCSAgICAgY29uc3QgY2hhciAqYm9sLCBjb25zdCBjaGFyICplb2wsCgkJCSAgICAgZW51bSBncmVwX2NvbnRleHQgY3R4LCByZWdtYXRjaF90ICpwbWF0Y2gsCgkJCSAgICAgaW50IGVmbGFncykKewoJY29uc3QgY2hhciAqZmllbGQ7CglzaXplX3QgbGVuOwoKCWlmIChwLT50b2tlbiA9PSBHUkVQX1BBVFRFUk5fSEVBRCkgewoJCWFzc2VydChwLT5maWVsZCA8IEFSUkFZX1NJWkUoaGVhZGVyX2ZpZWxkKSk7CgkJZmllbGQgPSBoZWFkZXJfZmllbGRbcC0+ZmllbGRdLmZpZWxkOwoJCWxlbiA9IGhlYWRlcl9maWVsZFtwLT5maWVsZF0ubGVuOwoJCWlmIChzdHJuY21wKGJvbCwgZmllbGQsIGxlbikpCgkJCXJldHVybiAwOwoJCWJvbCArPSBsZW47CgoJCXN3aXRjaCAocC0+ZmllbGQpIHsKCQljYXNlIEdSRVBfSEVBREVSX0FVVEhPUjoKCQljYXNlIEdSRVBfSEVBREVSX0NPTU1JVFRFUjoKCQkJc3RyaXBfdGltZXN0YW1wKGJvbCwgJmVvbCk7CgkJCWJyZWFrOwoJCWRlZmF1bHQ6CgkJCWJyZWFrOwoJCX0KCX0KCglyZXR1cm4gaGVhZGVybGVzc19tYXRjaF9vbmVfcGF0dGVybihwLCBib2wsIGVvbCwgY3R4LCBwbWF0Y2gsIGVmbGFncyk7Cn0KCgpzdGF0aWMgaW50IG1hdGNoX2V4cHJfZXZhbChzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCwgc3RydWN0IGdyZXBfZXhwciAqeCwKCQkJICAgY29uc3QgY2hhciAqYm9sLCBjb25zdCBjaGFyICplb2wsCgkJCSAgIGVudW0gZ3JlcF9jb250ZXh0IGN0eCwgc3NpemVfdCAqY29sLAoJCQkgICBzc2l6ZV90ICppY29sLCBpbnQgY29sbGVjdF9oaXRzKQp7CglpbnQgaCA9IDA7CgoJc3dpdGNoICh4LT5ub2RlKSB7CgljYXNlIEdSRVBfTk9ERV9UUlVFOgoJCWggPSAxOwoJCWJyZWFrOwoJY2FzZSBHUkVQX05PREVfQVRPTToKCQl7CgkJCXJlZ21hdGNoX3QgdG1wOwoJCQloID0gbWF0Y2hfb25lX3BhdHRlcm4oeC0+dS5hdG9tLCBib2wsIGVvbCwgY3R4LAoJCQkJCSAgICAgICZ0bXAsIDApOwoJCQlpZiAoaCAmJiAoKmNvbCA8IDAgfHwgdG1wLnJtX3NvIDwgKmNvbCkpCgkJCQkqY29sID0gdG1wLnJtX3NvOwoJCX0KCQlpZiAoeC0+dS5hdG9tLT50b2tlbiA9PSBHUkVQX1BBVFRFUk5fQk9EWSkKCQkJb3B0LT5ib2R5X2hpdCB8PSBoOwoJCWJyZWFrOwoJY2FzZSBHUkVQX05PREVfTk9UOgoJCS8qCgkJICogVXBvbiB2aXNpdGluZyBhIEdSRVBfTk9ERV9OT1QsIGNvbCBhbmQgaWNvbCBiZWNvbWUgc3dhcHBlZC4KCQkgKi8KCQloID0gIW1hdGNoX2V4cHJfZXZhbChvcHQsIHgtPnUudW5hcnksIGJvbCwgZW9sLCBjdHgsIGljb2wsIGNvbCwKCQkJCSAgICAgMCk7CgkJYnJlYWs7CgljYXNlIEdSRVBfTk9ERV9BTkQ6CgkJaCA9IG1hdGNoX2V4cHJfZXZhbChvcHQsIHgtPnUuYmluYXJ5LmxlZnQsIGJvbCwgZW9sLCBjdHgsIGNvbCwKCQkJCSAgICBpY29sLCAwKTsKCQlpZiAoaCB8fCBvcHQtPmNvbHVtbm51bSkgewoJCQkvKgoJCQkgKiBEb24ndCBzaG9ydC1jaXJjdWl0IEFORCB3aGVuIGdpdmVuIC0tY29sdW1uLCBzaW5jZSBhCgkJCSAqIE5PVCBlYXJsaWVyIGluIHRoZSB0cmVlIG1heSB0dXJuIHRoaXMgaW50byBhbiBPUi4gSW4KCQkJICogdGhpcyBjYXNlLCBzZWUgdGhlIGJlbG93IGNvbW1lbnQuCgkJCSAqLwoJCQloICY9IG1hdGNoX2V4cHJfZXZhbChvcHQsIHgtPnUuYmluYXJ5LnJpZ2h0LCBib2wsIGVvbCwKCQkJCQkgICAgIGN0eCwgY29sLCBpY29sLCAwKTsKCQl9CgkJYnJlYWs7CgljYXNlIEdSRVBfTk9ERV9PUjoKCQlpZiAoIShjb2xsZWN0X2hpdHMgfHwgb3B0LT5jb2x1bW5udW0pKSB7CgkJCS8qCgkJCSAqIERvbid0IHNob3J0LWNpcmN1aXQgT1Igd2hlbiBnaXZlbiAtLWNvbHVtbiAob3IKCQkJICogY29sbGVjdGluZyBoaXRzKSB0byBlbnN1cmUgd2UgZG9uJ3Qgc2tpcCBhIGxhdGVyCgkJCSAqIGNoaWxkIHRoYXQgd291bGQgcHJvZHVjZSBhbiBlYXJsaWVyIG1hdGNoLgoJCQkgKi8KCQkJcmV0dXJuIChtYXRjaF9leHByX2V2YWwob3B0LCB4LT51LmJpbmFyeS5sZWZ0LCBib2wsIGVvbCwKCQkJCQkJY3R4LCBjb2wsIGljb2wsIDApIHx8CgkJCQltYXRjaF9leHByX2V2YWwob3B0LCB4LT51LmJpbmFyeS5yaWdodCwgYm9sLAoJCQkJCQllb2wsIGN0eCwgY29sLCBpY29sLCAwKSk7CgkJfQoJCWggPSBtYXRjaF9leHByX2V2YWwob3B0LCB4LT51LmJpbmFyeS5sZWZ0LCBib2wsIGVvbCwgY3R4LCBjb2wsCgkJCQkgICAgaWNvbCwgMCk7CgkJaWYgKGNvbGxlY3RfaGl0cykKCQkJeC0+dS5iaW5hcnkubGVmdC0+aGl0IHw9IGg7CgkJaCB8PSBtYXRjaF9leHByX2V2YWwob3B0LCB4LT51LmJpbmFyeS5yaWdodCwgYm9sLCBlb2wsIGN0eCwgY29sLAoJCQkJICAgICBpY29sLCBjb2xsZWN0X2hpdHMpOwoJCWJyZWFrOwoJZGVmYXVsdDoKCQlkaWUoIlVuZXhwZWN0ZWQgbm9kZSB0eXBlIChpbnRlcm5hbCBlcnJvcikgJWQiLCB4LT5ub2RlKTsKCX0KCWlmIChjb2xsZWN0X2hpdHMpCgkJeC0+aGl0IHw9IGg7CglyZXR1cm4gaDsKfQoKc3RhdGljIGludCBtYXRjaF9leHByKHN0cnVjdCBncmVwX29wdCAqb3B0LAoJCSAgICAgIGNvbnN0IGNoYXIgKmJvbCwgY29uc3QgY2hhciAqZW9sLAoJCSAgICAgIGVudW0gZ3JlcF9jb250ZXh0IGN0eCwgc3NpemVfdCAqY29sLAoJCSAgICAgIHNzaXplX3QgKmljb2wsIGludCBjb2xsZWN0X2hpdHMpCnsKCXN0cnVjdCBncmVwX2V4cHIgKnggPSBvcHQtPnBhdHRlcm5fZXhwcmVzc2lvbjsKCXJldHVybiBtYXRjaF9leHByX2V2YWwob3B0LCB4LCBib2wsIGVvbCwgY3R4LCBjb2wsIGljb2wsIGNvbGxlY3RfaGl0cyk7Cn0KCnN0YXRpYyBpbnQgbWF0Y2hfbGluZShzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCwKCQkgICAgICBjb25zdCBjaGFyICpib2wsIGNvbnN0IGNoYXIgKmVvbCwKCQkgICAgICBzc2l6ZV90ICpjb2wsIHNzaXplX3QgKmljb2wsCgkJICAgICAgZW51bSBncmVwX2NvbnRleHQgY3R4LCBpbnQgY29sbGVjdF9oaXRzKQp7CglzdHJ1Y3QgZ3JlcF9wYXQgKnA7CglpbnQgaGl0ID0gMDsKCglpZiAob3B0LT5wYXR0ZXJuX2V4cHJlc3Npb24pCgkJcmV0dXJuIG1hdGNoX2V4cHIob3B0LCBib2wsIGVvbCwgY3R4LCBjb2wsIGljb2wsCgkJCQkgIGNvbGxlY3RfaGl0cyk7CgoJLyogd2UgZG8gbm90IGNhbGwgd2l0aCBjb2xsZWN0X2hpdHMgd2l0aG91dCBiZWluZyBleHRlbmRlZCAqLwoJZm9yIChwID0gb3B0LT5wYXR0ZXJuX2xpc3Q7IHA7IHAgPSBwLT5uZXh0KSB7CgkJcmVnbWF0Y2hfdCB0bXA7CgkJaWYgKG1hdGNoX29uZV9wYXR0ZXJuKHAsIGJvbCwgZW9sLCBjdHgsICZ0bXAsIDApKSB7CgkJCWhpdCB8PSAxOwoJCQlpZiAoIW9wdC0+Y29sdW1ubnVtKSB7CgkJCQkvKgoJCQkJICogV2l0aG91dCAtLWNvbHVtbiwgYW55IHNpbmdsZSBtYXRjaCBvbiBhIGxpbmUKCQkJCSAqIGlzIGVub3VnaCB0byBrbm93IHRoYXQgaXQgbmVlZHMgdG8gYmUKCQkJCSAqIHByaW50ZWQuIFdpdGggLS1jb2x1bW4sIHNjYW4gX2FsbF8gcGF0dGVybnMKCQkJCSAqIHRvIGZpbmQgdGhlIGVhcmxpZXN0LgoJCQkJICovCgkJCQlicmVhazsKCQkJfQoJCQlpZiAoKmNvbCA8IDAgfHwgdG1wLnJtX3NvIDwgKmNvbCkKCQkJCSpjb2wgPSB0bXAucm1fc287CgkJfQoJfQoJcmV0dXJuIGhpdDsKfQoKc3RhdGljIGludCBtYXRjaF9uZXh0X3BhdHRlcm4oc3RydWN0IGdyZXBfcGF0ICpwLAoJCQkgICAgICBjb25zdCBjaGFyICpib2wsIGNvbnN0IGNoYXIgKmVvbCwKCQkJICAgICAgZW51bSBncmVwX2NvbnRleHQgY3R4LAoJCQkgICAgICByZWdtYXRjaF90ICpwbWF0Y2gsIGludCBlZmxhZ3MpCnsKCXJlZ21hdGNoX3QgbWF0Y2g7CgoJaWYgKCFoZWFkZXJsZXNzX21hdGNoX29uZV9wYXR0ZXJuKHAsIGJvbCwgZW9sLCBjdHgsICZtYXRjaCwgZWZsYWdzKSkKCQlyZXR1cm4gMDsKCWlmIChtYXRjaC5ybV9zbyA8IDAgfHwgbWF0Y2gucm1fZW8gPCAwKQoJCXJldHVybiAwOwoJaWYgKHBtYXRjaC0+cm1fc28gPj0gMCAmJiBwbWF0Y2gtPnJtX2VvID49IDApIHsKCQlpZiAobWF0Y2gucm1fc28gPiBwbWF0Y2gtPnJtX3NvKQoJCQlyZXR1cm4gMTsKCQlpZiAobWF0Y2gucm1fc28gPT0gcG1hdGNoLT5ybV9zbyAmJiBtYXRjaC5ybV9lbyA8IHBtYXRjaC0+cm1fZW8pCgkJCXJldHVybiAxOwoJfQoJcG1hdGNoLT5ybV9zbyA9IG1hdGNoLnJtX3NvOwoJcG1hdGNoLT5ybV9lbyA9IG1hdGNoLnJtX2VvOwoJcmV0dXJuIDE7Cn0KCmludCBncmVwX25leHRfbWF0Y2goc3RydWN0IGdyZXBfb3B0ICpvcHQsCgkJICAgIGNvbnN0IGNoYXIgKmJvbCwgY29uc3QgY2hhciAqZW9sLAoJCSAgICBlbnVtIGdyZXBfY29udGV4dCBjdHgsIHJlZ21hdGNoX3QgKnBtYXRjaCwKCQkgICAgZW51bSBncmVwX2hlYWRlcl9maWVsZCBmaWVsZCwgaW50IGVmbGFncykKewoJc3RydWN0IGdyZXBfcGF0ICpwOwoJaW50IGhpdCA9IDA7CgoJcG1hdGNoLT5ybV9zbyA9IHBtYXRjaC0+cm1fZW8gPSAtMTsKCWlmIChib2wgPCBlb2wpIHsKCQlmb3IgKHAgPSAoKGN0eCA9PSBHUkVQX0NPTlRFWFRfSEVBRCkKCQkJICAgPyBvcHQtPmhlYWRlcl9saXN0IDogb3B0LT5wYXR0ZXJuX2xpc3QpOwoJCQkgIHA7IHAgPSBwLT5uZXh0KSB7CgkJCXN3aXRjaCAocC0+dG9rZW4pIHsKCQkJY2FzZSBHUkVQX1BBVFRFUk5fSEVBRDoKCQkJCWlmICgoZmllbGQgIT0gR1JFUF9IRUFERVJfRklFTERfTUFYKSAmJgoJCQkJICAgIChwLT5maWVsZCAhPSBmaWVsZCkpCgkJCQkJY29udGludWU7CgkJCQkvKiBmYWxsIHRocnUgKi8KCQkJY2FzZSBHUkVQX1BBVFRFUk46IC8qIGF0b20gKi8KCQkJY2FzZSBHUkVQX1BBVFRFUk5fQk9EWToKCQkJCWhpdCB8PSBtYXRjaF9uZXh0X3BhdHRlcm4ocCwgYm9sLCBlb2wsIGN0eCwKCQkJCQkJCSAgcG1hdGNoLCBlZmxhZ3MpOwoJCQkJYnJlYWs7CgkJCWRlZmF1bHQ6CgkJCQlicmVhazsKCQkJfQoJCX0KCX0KCXJldHVybiBoaXQ7Cn0KCnN0YXRpYyB2b2lkIHNob3dfbGluZV9oZWFkZXIoc3RydWN0IGdyZXBfb3B0ICpvcHQsIGNvbnN0IGNoYXIgKm5hbWUsCgkJCSAgICAgdW5zaWduZWQgbG5vLCBzc2l6ZV90IGNubywgY2hhciBzaWduKQp7CglpZiAob3B0LT5oZWFkaW5nICYmIG9wdC0+bGFzdF9zaG93biA9PSAwKSB7CgkJb3V0cHV0X2NvbG9yKG9wdCwgbmFtZSwgc3RybGVuKG5hbWUpLCBvcHQtPmNvbG9yc1tHUkVQX0NPTE9SX0ZJTEVOQU1FXSk7CgkJb3B0LT5vdXRwdXQob3B0LCAiXG4iLCAxKTsKCX0KCW9wdC0+bGFzdF9zaG93biA9IGxubzsKCglpZiAoIW9wdC0+aGVhZGluZyAmJiBvcHQtPnBhdGhuYW1lKSB7CgkJb3V0cHV0X2NvbG9yKG9wdCwgbmFtZSwgc3RybGVuKG5hbWUpLCBvcHQtPmNvbG9yc1tHUkVQX0NPTE9SX0ZJTEVOQU1FXSk7CgkJb3V0cHV0X3NlcChvcHQsIHNpZ24pOwoJfQoJaWYgKG9wdC0+bGluZW51bSkgewoJCWNoYXIgYnVmWzMyXTsKCQl4c25wcmludGYoYnVmLCBzaXplb2YoYnVmKSwgIiVkIiwgbG5vKTsKCQlvdXRwdXRfY29sb3Iob3B0LCBidWYsIHN0cmxlbihidWYpLCBvcHQtPmNvbG9yc1tHUkVQX0NPTE9SX0xJTkVOT10pOwoJCW91dHB1dF9zZXAob3B0LCBzaWduKTsKCX0KCS8qCgkgKiBUcmVhdCAnY25vJyBhcyB0aGUgMS1pbmRleGVkIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiBhIG5vbi1jb250ZXh0CgkgKiBsaW5lIHRvIGl0cyBmaXJzdCBtYXRjaC4gT3RoZXJ3aXNlLCAnY25vJyBpcyAwIGluZGljYXRpbmcgdGhhdCB3ZSBhcmUKCSAqIGJlaW5nIGNhbGxlZCB3aXRoIGEgY29udGV4dCBsaW5lLgoJICovCglpZiAob3B0LT5jb2x1bW5udW0gJiYgY25vKSB7CgkJY2hhciBidWZbMzJdOwoJCXhzbnByaW50ZihidWYsIHNpemVvZihidWYpLCAiJSJQUkl1TUFYLCAodWludG1heF90KWNubyk7CgkJb3V0cHV0X2NvbG9yKG9wdCwgYnVmLCBzdHJsZW4oYnVmKSwgb3B0LT5jb2xvcnNbR1JFUF9DT0xPUl9DT0xVTU5OT10pOwoJCW91dHB1dF9zZXAob3B0LCBzaWduKTsKCX0KfQoKc3RhdGljIHZvaWQgc2hvd19saW5lKHN0cnVjdCBncmVwX29wdCAqb3B0LAoJCSAgICAgIGNvbnN0IGNoYXIgKmJvbCwgY29uc3QgY2hhciAqZW9sLAoJCSAgICAgIGNvbnN0IGNoYXIgKm5hbWUsIHVuc2lnbmVkIGxubywgc3NpemVfdCBjbm8sIGNoYXIgc2lnbikKewoJaW50IHJlc3QgPSBlb2wgLSBib2w7Cgljb25zdCBjaGFyICptYXRjaF9jb2xvciA9IE5VTEw7Cgljb25zdCBjaGFyICpsaW5lX2NvbG9yID0gTlVMTDsKCglpZiAob3B0LT5maWxlX2JyZWFrICYmIG9wdC0+bGFzdF9zaG93biA9PSAwKSB7CgkJaWYgKG9wdC0+c2hvd19odW5rX21hcmspCgkJCW9wdC0+b3V0cHV0KG9wdCwgIlxuIiwgMSk7Cgl9IGVsc2UgaWYgKG9wdC0+cHJlX2NvbnRleHQgfHwgb3B0LT5wb3N0X2NvbnRleHQgfHwgb3B0LT5mdW5jYm9keSkgewoJCWlmIChvcHQtPmxhc3Rfc2hvd24gPT0gMCkgewoJCQlpZiAob3B0LT5zaG93X2h1bmtfbWFyaykgewoJCQkJb3V0cHV0X2NvbG9yKG9wdCwgIi0tIiwgMiwgb3B0LT5jb2xvcnNbR1JFUF9DT0xPUl9TRVBdKTsKCQkJCW9wdC0+b3V0cHV0KG9wdCwgIlxuIiwgMSk7CgkJCX0KCQl9IGVsc2UgaWYgKGxubyA+IG9wdC0+bGFzdF9zaG93biArIDEpIHsKCQkJb3V0cHV0X2NvbG9yKG9wdCwgIi0tIiwgMiwgb3B0LT5jb2xvcnNbR1JFUF9DT0xPUl9TRVBdKTsKCQkJb3B0LT5vdXRwdXQob3B0LCAiXG4iLCAxKTsKCQl9Cgl9CglpZiAoIW9wdC0+b25seV9tYXRjaGluZykgewoJCS8qCgkJICogSW4gY2FzZSB0aGUgbGluZSB3ZSdyZSBiZWluZyBjYWxsZWQgd2l0aCBjb250YWlucyBtb3JlIHRoYW4KCQkgKiBvbmUgbWF0Y2gsIGxlYXZlIHByaW50aW5nIGVhY2ggaGVhZGVyIHRvIHRoZSBsb29wIGJlbG93LgoJCSAqLwoJCXNob3dfbGluZV9oZWFkZXIob3B0LCBuYW1lLCBsbm8sIGNubywgc2lnbik7Cgl9CglpZiAob3B0LT5jb2xvciB8fCBvcHQtPm9ubHlfbWF0Y2hpbmcpIHsKCQlyZWdtYXRjaF90IG1hdGNoOwoJCWVudW0gZ3JlcF9jb250ZXh0IGN0eCA9IEdSRVBfQ09OVEVYVF9CT0RZOwoJCWludCBlZmxhZ3MgPSAwOwoKCQlpZiAob3B0LT5jb2xvcikgewoJCQlpZiAoc2lnbiA9PSAnOicpCgkJCQltYXRjaF9jb2xvciA9IG9wdC0+Y29sb3JzW0dSRVBfQ09MT1JfTUFUQ0hfU0VMRUNURURdOwoJCQllbHNlCgkJCQltYXRjaF9jb2xvciA9IG9wdC0+Y29sb3JzW0dSRVBfQ09MT1JfTUFUQ0hfQ09OVEVYVF07CgkJCWlmIChzaWduID09ICc6JykKCQkJCWxpbmVfY29sb3IgPSBvcHQtPmNvbG9yc1tHUkVQX0NPTE9SX1NFTEVDVEVEXTsKCQkJZWxzZSBpZiAoc2lnbiA9PSAnLScpCgkJCQlsaW5lX2NvbG9yID0gb3B0LT5jb2xvcnNbR1JFUF9DT0xPUl9DT05URVhUXTsKCQkJZWxzZSBpZiAoc2lnbiA9PSAnPScpCgkJCQlsaW5lX2NvbG9yID0gb3B0LT5jb2xvcnNbR1JFUF9DT0xPUl9GVU5DVElPTl07CgkJfQoJCXdoaWxlIChncmVwX25leHRfbWF0Y2gob3B0LCBib2wsIGVvbCwgY3R4LCAmbWF0Y2gsCgkJCQkgICAgICAgR1JFUF9IRUFERVJfRklFTERfTUFYLCBlZmxhZ3MpKSB7CgkJCWlmIChtYXRjaC5ybV9zbyA9PSBtYXRjaC5ybV9lbykKCQkJCWJyZWFrOwoKCQkJaWYgKG9wdC0+b25seV9tYXRjaGluZykKCQkJCXNob3dfbGluZV9oZWFkZXIob3B0LCBuYW1lLCBsbm8sIGNubywgc2lnbik7CgkJCWVsc2UKCQkJCW91dHB1dF9jb2xvcihvcHQsIGJvbCwgbWF0Y2gucm1fc28sIGxpbmVfY29sb3IpOwoJCQlvdXRwdXRfY29sb3Iob3B0LCBib2wgKyBtYXRjaC5ybV9zbywKCQkJCSAgICAgbWF0Y2gucm1fZW8gLSBtYXRjaC5ybV9zbywgbWF0Y2hfY29sb3IpOwoJCQlpZiAob3B0LT5vbmx5X21hdGNoaW5nKQoJCQkJb3B0LT5vdXRwdXQob3B0LCAiXG4iLCAxKTsKCQkJYm9sICs9IG1hdGNoLnJtX2VvOwoJCQljbm8gKz0gbWF0Y2gucm1fZW87CgkJCXJlc3QgLT0gbWF0Y2gucm1fZW87CgkJCWVmbGFncyA9IFJFR19OT1RCT0w7CgkJfQoJfQoJaWYgKCFvcHQtPm9ubHlfbWF0Y2hpbmcpIHsKCQlvdXRwdXRfY29sb3Iob3B0LCBib2wsIHJlc3QsIGxpbmVfY29sb3IpOwoJCW9wdC0+b3V0cHV0KG9wdCwgIlxuIiwgMSk7Cgl9Cn0KCmludCBncmVwX3VzZV9sb2NrczsKCi8qCiAqIFRoaXMgbG9jayBwcm90ZWN0cyBhY2Nlc3MgdG8gdGhlIGdpdGF0dHJpYnV0ZXMgbWFjaGluZXJ5LCB3aGljaCBpcwogKiBub3QgdGhyZWFkLXNhZmUuCiAqLwpwdGhyZWFkX211dGV4X3QgZ3JlcF9hdHRyX211dGV4OwoKc3RhdGljIGlubGluZSB2b2lkIGdyZXBfYXR0cl9sb2NrKHZvaWQpCnsKCWlmIChncmVwX3VzZV9sb2NrcykKCQlwdGhyZWFkX211dGV4X2xvY2soJmdyZXBfYXR0cl9tdXRleCk7Cn0KCnN0YXRpYyBpbmxpbmUgdm9pZCBncmVwX2F0dHJfdW5sb2NrKHZvaWQpCnsKCWlmIChncmVwX3VzZV9sb2NrcykKCQlwdGhyZWFkX211dGV4X3VubG9jaygmZ3JlcF9hdHRyX211dGV4KTsKfQoKc3RhdGljIGludCBtYXRjaF9mdW5jbmFtZShzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCwgc3RydWN0IGdyZXBfc291cmNlICpncywKCQkJICBjb25zdCBjaGFyICpib2wsIGNvbnN0IGNoYXIgKmVvbCkKewoJeGRlbWl0Y29uZl90ICp4ZWNmZyA9IG9wdC0+cHJpdjsKCWlmICh4ZWNmZyAmJiAheGVjZmctPmZpbmRfZnVuYykgewoJCWdyZXBfc291cmNlX2xvYWRfZHJpdmVyKGdzLCBvcHQtPnJlcG8tPmluZGV4KTsKCQlpZiAoZ3MtPmRyaXZlci0+ZnVuY25hbWUucGF0dGVybikgewoJCQljb25zdCBzdHJ1Y3QgdXNlcmRpZmZfZnVuY25hbWUgKnBlID0gJmdzLT5kcml2ZXItPmZ1bmNuYW1lOwoJCQl4ZGlmZl9zZXRfZmluZF9mdW5jKHhlY2ZnLCBwZS0+cGF0dGVybiwgcGUtPmNmbGFncyk7CgkJfSBlbHNlIHsKCQkJeGVjZmcgPSBvcHQtPnByaXYgPSBOVUxMOwoJCX0KCX0KCglpZiAoeGVjZmcpIHsKCQljaGFyIGJ1ZlsxXTsKCQlyZXR1cm4geGVjZmctPmZpbmRfZnVuYyhib2wsIGVvbCAtIGJvbCwgYnVmLCAxLAoJCQkJCXhlY2ZnLT5maW5kX2Z1bmNfcHJpdikgPj0gMDsKCX0KCglpZiAoYm9sID09IGVvbCkKCQlyZXR1cm4gMDsKCWlmIChpc2FscGhhKCpib2wpIHx8ICpib2wgPT0gJ18nIHx8ICpib2wgPT0gJyQnKQoJCXJldHVybiAxOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHNob3dfZnVuY25hbWVfbGluZShzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCwgc3RydWN0IGdyZXBfc291cmNlICpncywKCQkJICAgICAgIGNvbnN0IGNoYXIgKmJvbCwgdW5zaWduZWQgbG5vKQp7Cgl3aGlsZSAoYm9sID4gZ3MtPmJ1ZikgewoJCWNvbnN0IGNoYXIgKmVvbCA9IC0tYm9sOwoKCQl3aGlsZSAoYm9sID4gZ3MtPmJ1ZiAmJiBib2xbLTFdICE9ICdcbicpCgkJCWJvbC0tOwoJCWxuby0tOwoKCQlpZiAobG5vIDw9IG9wdC0+bGFzdF9zaG93bikKCQkJYnJlYWs7CgoJCWlmIChtYXRjaF9mdW5jbmFtZShvcHQsIGdzLCBib2wsIGVvbCkpIHsKCQkJc2hvd19saW5lKG9wdCwgYm9sLCBlb2wsIGdzLT5uYW1lLCBsbm8sIDAsICc9Jyk7CgkJCWJyZWFrOwoJCX0KCX0KfQoKc3RhdGljIGludCBpc19lbXB0eV9saW5lKGNvbnN0IGNoYXIgKmJvbCwgY29uc3QgY2hhciAqZW9sKTsKCnN0YXRpYyB2b2lkIHNob3dfcHJlX2NvbnRleHQoc3RydWN0IGdyZXBfb3B0ICpvcHQsIHN0cnVjdCBncmVwX3NvdXJjZSAqZ3MsCgkJCSAgICAgY29uc3QgY2hhciAqYm9sLCBjb25zdCBjaGFyICplbmQsIHVuc2lnbmVkIGxubykKewoJdW5zaWduZWQgY3VyID0gbG5vLCBmcm9tID0gMSwgZnVuY25hbWVfbG5vID0gMCwgb3JpZ19mcm9tOwoJaW50IGZ1bmNuYW1lX25lZWRlZCA9ICEhb3B0LT5mdW5jbmFtZSwgY29tbWVudF9uZWVkZWQgPSAwOwoKCWlmIChvcHQtPnByZV9jb250ZXh0IDwgbG5vKQoJCWZyb20gPSBsbm8gLSBvcHQtPnByZV9jb250ZXh0OwoJaWYgKGZyb20gPD0gb3B0LT5sYXN0X3Nob3duKQoJCWZyb20gPSBvcHQtPmxhc3Rfc2hvd24gKyAxOwoJb3JpZ19mcm9tID0gZnJvbTsKCWlmIChvcHQtPmZ1bmNib2R5KSB7CgkJaWYgKG1hdGNoX2Z1bmNuYW1lKG9wdCwgZ3MsIGJvbCwgZW5kKSkKCQkJY29tbWVudF9uZWVkZWQgPSAxOwoJCWVsc2UKCQkJZnVuY25hbWVfbmVlZGVkID0gMTsKCQlmcm9tID0gb3B0LT5sYXN0X3Nob3duICsgMTsKCX0KCgkvKiBSZXdpbmQuICovCgl3aGlsZSAoYm9sID4gZ3MtPmJ1ZiAmJiBjdXIgPiBmcm9tKSB7CgkJY29uc3QgY2hhciAqbmV4dF9ib2wgPSBib2w7CgkJY29uc3QgY2hhciAqZW9sID0gLS1ib2w7CgoJCXdoaWxlIChib2wgPiBncy0+YnVmICYmIGJvbFstMV0gIT0gJ1xuJykKCQkJYm9sLS07CgkJY3VyLS07CgkJaWYgKGNvbW1lbnRfbmVlZGVkICYmIChpc19lbXB0eV9saW5lKGJvbCwgZW9sKSB8fAoJCQkJICAgICAgIG1hdGNoX2Z1bmNuYW1lKG9wdCwgZ3MsIGJvbCwgZW9sKSkpIHsKCQkJY29tbWVudF9uZWVkZWQgPSAwOwoJCQlmcm9tID0gb3JpZ19mcm9tOwoJCQlpZiAoY3VyIDwgZnJvbSkgewoJCQkJY3VyKys7CgkJCQlib2wgPSBuZXh0X2JvbDsKCQkJCWJyZWFrOwoJCQl9CgkJfQoJCWlmIChmdW5jbmFtZV9uZWVkZWQgJiYgbWF0Y2hfZnVuY25hbWUob3B0LCBncywgYm9sLCBlb2wpKSB7CgkJCWZ1bmNuYW1lX2xubyA9IGN1cjsKCQkJZnVuY25hbWVfbmVlZGVkID0gMDsKCQkJaWYgKG9wdC0+ZnVuY2JvZHkpCgkJCQljb21tZW50X25lZWRlZCA9IDE7CgkJCWVsc2UKCQkJCWZyb20gPSBvcmlnX2Zyb207CgkJfQoJfQoKCS8qIFdlIG5lZWQgdG8gbG9vayBldmVuIGZ1cnRoZXIgYmFjayB0byBmaW5kIGEgZnVuY3Rpb24gc2lnbmF0dXJlLiAqLwoJaWYgKG9wdC0+ZnVuY25hbWUgJiYgZnVuY25hbWVfbmVlZGVkKQoJCXNob3dfZnVuY25hbWVfbGluZShvcHQsIGdzLCBib2wsIGN1cik7CgoJLyogQmFjayBmb3J3YXJkLiAqLwoJd2hpbGUgKGN1ciA8IGxubykgewoJCWNvbnN0IGNoYXIgKmVvbCA9IGJvbCwgc2lnbiA9IChjdXIgPT0gZnVuY25hbWVfbG5vKSA/ICc9JyA6ICctJzsKCgkJd2hpbGUgKCplb2wgIT0gJ1xuJykKCQkJZW9sKys7CgkJc2hvd19saW5lKG9wdCwgYm9sLCBlb2wsIGdzLT5uYW1lLCBjdXIsIDAsIHNpZ24pOwoJCWJvbCA9IGVvbCArIDE7CgkJY3VyKys7Cgl9Cn0KCnN0YXRpYyBpbnQgc2hvdWxkX2xvb2thaGVhZChzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCkKewoJc3RydWN0IGdyZXBfcGF0ICpwOwoKCWlmIChvcHQtPnBhdHRlcm5fZXhwcmVzc2lvbikKCQlyZXR1cm4gMDsgLyogcHVudCBmb3IgdG9vIGNvbXBsZXggc3R1ZmYgKi8KCWlmIChvcHQtPmludmVydCkKCQlyZXR1cm4gMDsKCWZvciAocCA9IG9wdC0+cGF0dGVybl9saXN0OyBwOyBwID0gcC0+bmV4dCkgewoJCWlmIChwLT50b2tlbiAhPSBHUkVQX1BBVFRFUk4pCgkJCXJldHVybiAwOyAvKiBwdW50IGZvciAiaGVhZGVyIG9ubHkiIGFuZCBzdHVmZiAqLwoJfQoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBpbnQgbG9va19haGVhZChzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCwKCQkgICAgICB1bnNpZ25lZCBsb25nICpsZWZ0X3AsCgkJICAgICAgdW5zaWduZWQgKmxub19wLAoJCSAgICAgIGNvbnN0IGNoYXIgKipib2xfcCkKewoJdW5zaWduZWQgbG5vID0gKmxub19wOwoJY29uc3QgY2hhciAqYm9sID0gKmJvbF9wOwoJc3RydWN0IGdyZXBfcGF0ICpwOwoJY29uc3QgY2hhciAqc3AsICpsYXN0X2JvbDsKCXJlZ29mZl90IGVhcmxpZXN0ID0gLTE7CgoJZm9yIChwID0gb3B0LT5wYXR0ZXJuX2xpc3Q7IHA7IHAgPSBwLT5uZXh0KSB7CgkJaW50IGhpdDsKCQlyZWdtYXRjaF90IG07CgoJCWhpdCA9IHBhdG1hdGNoKHAsIGJvbCwgYm9sICsgKmxlZnRfcCwgJm0sIDApOwoJCWlmICghaGl0IHx8IG0ucm1fc28gPCAwIHx8IG0ucm1fZW8gPCAwKQoJCQljb250aW51ZTsKCQlpZiAoZWFybGllc3QgPCAwIHx8IG0ucm1fc28gPCBlYXJsaWVzdCkKCQkJZWFybGllc3QgPSBtLnJtX3NvOwoJfQoKCWlmIChlYXJsaWVzdCA8IDApIHsKCQkqYm9sX3AgPSBib2wgKyAqbGVmdF9wOwoJCSpsZWZ0X3AgPSAwOwoJCXJldHVybiAxOwoJfQoJZm9yIChzcCA9IGJvbCArIGVhcmxpZXN0OyBib2wgPCBzcCAmJiBzcFstMV0gIT0gJ1xuJzsgc3AtLSkKCQk7IC8qIGZpbmQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZSAqLwoJbGFzdF9ib2wgPSBzcDsKCglmb3IgKHNwID0gYm9sOyBzcCA8IGxhc3RfYm9sOyBzcCsrKSB7CgkJaWYgKCpzcCA9PSAnXG4nKQoJCQlsbm8rKzsKCX0KCSpsZWZ0X3AgLT0gbGFzdF9ib2wgLSBib2w7CgkqYm9sX3AgPSBsYXN0X2JvbDsKCSpsbm9fcCA9IGxubzsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGZpbGxfdGV4dGNvbnZfZ3JlcChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJICAgICAgc3RydWN0IHVzZXJkaWZmX2RyaXZlciAqZHJpdmVyLAoJCQkgICAgICBzdHJ1Y3QgZ3JlcF9zb3VyY2UgKmdzKQp7CglzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqZGY7CgljaGFyICpidWY7CglzaXplX3Qgc2l6ZTsKCglpZiAoIWRyaXZlciB8fCAhZHJpdmVyLT50ZXh0Y29udikKCQlyZXR1cm4gZ3JlcF9zb3VyY2VfbG9hZChncyk7CgoJLyoKCSAqIFRoZSB0ZXh0Y29udiBpbnRlcmZhY2UgaXMgaW50aW1hdGVseSB0aWVkIHRvIGRpZmZfZmlsZXNwZWNzLCBzbyB3ZQoJICogaGF2ZSB0byBwcmV0ZW5kIHRvIGJlIG9uZS4gSWYgd2UgY291bGQgdW5pZnkgdGhlIGdyZXBfc291cmNlCgkgKiBhbmQgZGlmZl9maWxlc3BlYyBzdHJ1Y3RzLCB0aGlzIG1lc3MgY291bGQganVzdCBnbyBhd2F5LgoJICovCglkZiA9IGFsbG9jX2ZpbGVzcGVjKGdzLT5wYXRoKTsKCXN3aXRjaCAoZ3MtPnR5cGUpIHsKCWNhc2UgR1JFUF9TT1VSQ0VfT0lEOgoJCWZpbGxfZmlsZXNwZWMoZGYsIGdzLT5pZGVudGlmaWVyLCAxLCAwMTAwNjQ0KTsKCQlicmVhazsKCWNhc2UgR1JFUF9TT1VSQ0VfRklMRToKCQlmaWxsX2ZpbGVzcGVjKGRmLCBudWxsX29pZCgpLCAwLCAwMTAwNjQ0KTsKCQlicmVhazsKCWRlZmF1bHQ6CgkJQlVHKCJhdHRlbXB0IHRvIHRleHRjb252IHNvbWV0aGluZyB3aXRob3V0IGEgcGF0aD8iKTsKCX0KCgkvKgoJICogZmlsbF90ZXh0Y29udiBpcyBub3QgcmVtb3RlbHkgdGhyZWFkLXNhZmU7IGl0IG1vZGlmaWVzIHRoZSBnbG9iYWwKCSAqIGRpZmYgdGVtcGZpbGUgc3RydWN0dXJlLCB3cml0ZXMgdG8gdGhlX3JlcG8ncyBvZGIgYW5kIG1pZ2h0CgkgKiBpbnRlcm5hbGx5IGNhbGwgdGhyZWFkLXVuc2FmZSBmdW5jdGlvbnMgc3VjaCBhcyB0aGUKCSAqIHByZXBhcmVfcGFja2VkX2dpdCgpIGxhenktaW5pdGlhbGl6YXRvci4gQmVjYXVzZSBvZiB0aGUgbGFzdCB0d28sIHdlCgkgKiBtdXN0IGVuc3VyZSBtdXR1YWwgZXhjbHVzaW9uIGJldHdlZW4gdGhpcyBjYWxsIGFuZCB0aGUgb2JqZWN0IHJlYWRpbmcKCSAqIEFQSSwgdGh1cyB3ZSB1c2Ugb2JqX3JlYWRfbG9jaygpIGhlcmUuCgkgKgoJICogVE9ETzogYWxsb3dpbmcgdGV4dCBjb252ZXJzaW9uIHRvIHJ1biBpbiBwYXJhbGxlbCB3aXRoIG9iamVjdAoJICogcmVhZGluZyBvcGVyYXRpb25zIG1pZ2h0IGluY3JlYXNlIHBlcmZvcm1hbmNlIGluIHRoZSBtdWx0aXRocmVhZGVkCgkgKiBub24td29ya3RyZWVlIGdpdC1ncmVwIHdpdGggLS10ZXh0Y29udi4KCSAqLwoJb2JqX3JlYWRfbG9jaygpOwoJc2l6ZSA9IGZpbGxfdGV4dGNvbnYociwgZHJpdmVyLCBkZiwgJmJ1Zik7CglvYmpfcmVhZF91bmxvY2soKTsKCWZyZWVfZmlsZXNwZWMoZGYpOwoKCS8qCgkgKiBUaGUgbm9ybWFsIGZpbGxfdGV4dGNvbnYgdXNhZ2UgYnkgdGhlIGRpZmYgbWFjaGluZXJ5IHdvdWxkIGp1c3Qga2VlcAoJICogdGhlIHRleHRjb252J2QgYnVmIHNlcGFyYXRlIGZyb20gdGhlIGRpZmZfZmlsZXNwZWMuIEJ1dCBtdWNoIG9mIHRoZQoJICogZ3JlcCBjb2RlIHBhc3NlcyBhcm91bmQgYSBncmVwX3NvdXJjZSBhbmQgYXNzdW1lcyB0aGF0IGl0cyAiYnVmIgoJICogcG9pbnRlciBpcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0aGluZyB3ZSBhcmUgc2VhcmNoaW5nLiBTbyBsZXQncwoJICogaW5zdGFsbCBvdXIgdGV4dGNvbnYnZCB2ZXJzaW9uIGludG8gdGhlIGdyZXBfc291cmNlLCB0YWtpbmcgY2FyZSBub3QKCSAqIHRvIGxlYWsgYW55IGV4aXN0aW5nIGJ1ZmZlci4KCSAqLwoJZ3JlcF9zb3VyY2VfY2xlYXJfZGF0YShncyk7Cglncy0+YnVmID0gYnVmOwoJZ3MtPnNpemUgPSBzaXplOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGlzX2VtcHR5X2xpbmUoY29uc3QgY2hhciAqYm9sLCBjb25zdCBjaGFyICplb2wpCnsKCXdoaWxlIChib2wgPCBlb2wgJiYgaXNzcGFjZSgqYm9sKSkKCQlib2wrKzsKCXJldHVybiBib2wgPT0gZW9sOwp9CgpzdGF0aWMgaW50IGdyZXBfc291cmNlXzEoc3RydWN0IGdyZXBfb3B0ICpvcHQsIHN0cnVjdCBncmVwX3NvdXJjZSAqZ3MsIGludCBjb2xsZWN0X2hpdHMpCnsKCWNvbnN0IGNoYXIgKmJvbDsKCWNvbnN0IGNoYXIgKnBlZWtfYm9sID0gTlVMTDsKCXVuc2lnbmVkIGxvbmcgbGVmdDsKCXVuc2lnbmVkIGxubyA9IDE7Cgl1bnNpZ25lZCBsYXN0X2hpdCA9IDA7CglpbnQgYmluYXJ5X21hdGNoX29ubHkgPSAwOwoJdW5zaWduZWQgY291bnQgPSAwOwoJaW50IHRyeV9sb29rYWhlYWQgPSAwOwoJaW50IHNob3dfZnVuY3Rpb24gPSAwOwoJc3RydWN0IHVzZXJkaWZmX2RyaXZlciAqdGV4dGNvbnYgPSBOVUxMOwoJZW51bSBncmVwX2NvbnRleHQgY3R4ID0gR1JFUF9DT05URVhUX0hFQUQ7Cgl4ZGVtaXRjb25mX3QgeGVjZmc7CgoJaWYgKCFvcHQtPnN0YXR1c19vbmx5ICYmIGdzLT5uYW1lID09IE5VTEwpCgkJQlVHKCJncmVwIGNhbGwgd2hpY2ggY291bGQgcHJpbnQgYSBuYW1lIHJlcXVpcmVzICIKCQkgICAgImdyZXBfc291cmNlLm5hbWUgYmUgbm9uLU5VTEwiKTsKCglpZiAoIW9wdC0+b3V0cHV0KQoJCW9wdC0+b3V0cHV0ID0gc3RkX291dHB1dDsKCglpZiAob3B0LT5wcmVfY29udGV4dCB8fCBvcHQtPnBvc3RfY29udGV4dCB8fCBvcHQtPmZpbGVfYnJlYWsgfHwKCSAgICBvcHQtPmZ1bmNib2R5KSB7CgkJLyogU2hvdyBodW5rIG1hcmtzLCBleGNlcHQgZm9yIHRoZSBmaXJzdCBmaWxlLiAqLwoJCWlmIChvcHQtPmxhc3Rfc2hvd24pCgkJCW9wdC0+c2hvd19odW5rX21hcmsgPSAxOwoJCS8qCgkJICogSWYgd2UncmUgdXNpbmcgdGhyZWFkcyB0aGVuIHdlIGNhbid0IGVhc2lseSBpZGVudGlmeQoJCSAqIHRoZSBmaXJzdCBmaWxlLiAgQWx3YXlzIHB1dCBodW5rIG1hcmtzIGluIHRoYXQgY2FzZQoJCSAqIGFuZCBza2lwIHRoZSB2ZXJ5IGZpcnN0IG9uZSBsYXRlciBpbiB3b3JrX2RvbmUoKS4KCQkgKi8KCQlpZiAob3B0LT5vdXRwdXQgIT0gc3RkX291dHB1dCkKCQkJb3B0LT5zaG93X2h1bmtfbWFyayA9IDE7Cgl9CglvcHQtPmxhc3Rfc2hvd24gPSAwOwoKCWlmIChvcHQtPmFsbG93X3RleHRjb252KSB7CgkJZ3JlcF9zb3VyY2VfbG9hZF9kcml2ZXIoZ3MsIG9wdC0+cmVwby0+aW5kZXgpOwoJCS8qCgkJICogV2UgbWlnaHQgc2V0IHVwIHRoZSBzaGFyZWQgdGV4dGNvbnYgY2FjaGUgZGF0YSBoZXJlLCB3aGljaAoJCSAqIGlzIG5vdCB0aHJlYWQtc2FmZS4gQWxzbywgZ2V0X29pZF93aXRoX2NvbnRleHQoKSBhbmQKCQkgKiBwYXJzZV9vYmplY3QoKSBtaWdodCBiZSBpbnRlcm5hbGx5IGNhbGxlZC4gQXMgdGhleSBhcmUgbm90CgkJICogY3VycmVudGx5IHRocmVhZC1zYWZlIGFuZCBtaWdodCBiZSByYWN5IHdpdGggb2JqZWN0IHJlYWRpbmcsCgkJICogb2JqX3JlYWRfbG9jaygpIG11c3QgYmUgY2FsbGVkLgoJCSAqLwoJCWdyZXBfYXR0cl9sb2NrKCk7CgkJb2JqX3JlYWRfbG9jaygpOwoJCXRleHRjb252ID0gdXNlcmRpZmZfZ2V0X3RleHRjb252KG9wdC0+cmVwbywgZ3MtPmRyaXZlcik7CgkJb2JqX3JlYWRfdW5sb2NrKCk7CgkJZ3JlcF9hdHRyX3VubG9jaygpOwoJfQoKCS8qCgkgKiBXZSBrbm93IHRoZSByZXN1bHQgb2YgYSB0ZXh0Y29udiBpcyB0ZXh0LCBzbyB3ZSBvbmx5IGhhdmUgdG8gY2FyZQoJICogYWJvdXQgYmluYXJ5IGhhbmRsaW5nIGlmIHdlIGFyZSBub3QgdXNpbmcgaXQuCgkgKi8KCWlmICghdGV4dGNvbnYpIHsKCQlzd2l0Y2ggKG9wdC0+YmluYXJ5KSB7CgkJY2FzZSBHUkVQX0JJTkFSWV9ERUZBVUxUOgoJCQlpZiAoZ3JlcF9zb3VyY2VfaXNfYmluYXJ5KGdzLCBvcHQtPnJlcG8tPmluZGV4KSkKCQkJCWJpbmFyeV9tYXRjaF9vbmx5ID0gMTsKCQkJYnJlYWs7CgkJY2FzZSBHUkVQX0JJTkFSWV9OT01BVENIOgoJCQlpZiAoZ3JlcF9zb3VyY2VfaXNfYmluYXJ5KGdzLCBvcHQtPnJlcG8tPmluZGV4KSkKCQkJCXJldHVybiAwOyAvKiBBc3N1bWUgdW5tYXRjaCAqLwoJCQlicmVhazsKCQljYXNlIEdSRVBfQklOQVJZX1RFWFQ6CgkJCWJyZWFrOwoJCWRlZmF1bHQ6CgkJCUJVRygidW5rbm93biBiaW5hcnkgaGFuZGxpbmcgbW9kZSIpOwoJCX0KCX0KCgltZW1zZXQoJnhlY2ZnLCAwLCBzaXplb2YoeGVjZmcpKTsKCW9wdC0+cHJpdiA9ICZ4ZWNmZzsKCgl0cnlfbG9va2FoZWFkID0gc2hvdWxkX2xvb2thaGVhZChvcHQpOwoKCWlmIChmaWxsX3RleHRjb252X2dyZXAob3B0LT5yZXBvLCB0ZXh0Y29udiwgZ3MpIDwgMCkKCQlyZXR1cm4gMDsKCglib2wgPSBncy0+YnVmOwoJbGVmdCA9IGdzLT5zaXplOwoJd2hpbGUgKGxlZnQpIHsKCQljb25zdCBjaGFyICplb2w7CgkJaW50IGhpdDsKCQlzc2l6ZV90IGNubzsKCQlzc2l6ZV90IGNvbCA9IC0xLCBpY29sID0gLTE7CgoJCS8qCgkJICogbG9va19haGVhZCgpIHNraXBzIHF1aWNrbHkgdG8gdGhlIGxpbmUgdGhhdCBwb3NzaWJseQoJCSAqIGhhcyB0aGUgbmV4dCBoaXQ7IGRvbid0IGNhbGwgaXQgaWYgd2UgbmVlZCB0byBkbwoJCSAqIHNvbWV0aGluZyBtb3JlIHRoYW4ganVzdCBza2lwcGluZyB0aGUgY3VycmVudCBsaW5lCgkJICogaW4gcmVzcG9uc2UgdG8gYW4gdW5tYXRjaCBmb3IgdGhlIGN1cnJlbnQgbGluZS4gIEUuZy4KCQkgKiBpbnNpZGUgYSBwb3N0LWNvbnRleHQgd2luZG93LCB3ZSB3aWxsIHNob3cgdGhlIGN1cnJlbnQKCQkgKiBsaW5lIGFzIGEgY29udGV4dCBhcm91bmQgdGhlIHByZXZpb3VzIGhpdCB3aGVuIGl0CgkJICogZG9lc24ndCBoaXQuCgkJICovCgkJaWYgKHRyeV9sb29rYWhlYWQKCQkgICAgJiYgIShsYXN0X2hpdAoJCQkgJiYgKHNob3dfZnVuY3Rpb24gfHwKCQkJICAgICBsbm8gPD0gbGFzdF9oaXQgKyBvcHQtPnBvc3RfY29udGV4dCkpCgkJICAgICYmIGxvb2tfYWhlYWQob3B0LCAmbGVmdCwgJmxubywgJmJvbCkpCgkJCWJyZWFrOwoJCWVvbCA9IGVuZF9vZl9saW5lKGJvbCwgJmxlZnQpOwoKCQlpZiAoKGN0eCA9PSBHUkVQX0NPTlRFWFRfSEVBRCkgJiYgKGVvbCA9PSBib2wpKQoJCQljdHggPSBHUkVQX0NPTlRFWFRfQk9EWTsKCgkJaGl0ID0gbWF0Y2hfbGluZShvcHQsIGJvbCwgZW9sLCAmY29sLCAmaWNvbCwgY3R4LCBjb2xsZWN0X2hpdHMpOwoKCQlpZiAoY29sbGVjdF9oaXRzKQoJCQlnb3RvIG5leHRfbGluZTsKCgkJLyogImdyZXAgLXYgLWUgZm9vIC1lIGJsYSIgc2hvdWxkIGxpc3QgbGluZXMKCQkgKiB0aGF0IGRvIG5vdCBoYXZlIGVpdGhlciwgc28gaW52ZXJzaW9uIHNob3VsZAoJCSAqIGJlIGRvbmUgb3V0c2lkZS4KCQkgKi8KCQlpZiAob3B0LT5pbnZlcnQpCgkJCWhpdCA9ICFoaXQ7CgkJaWYgKG9wdC0+dW5tYXRjaF9uYW1lX29ubHkpIHsKCQkJaWYgKGhpdCkKCQkJCXJldHVybiAwOwoJCQlnb3RvIG5leHRfbGluZTsKCQl9CgkJaWYgKGhpdCAmJiAob3B0LT5tYXhfY291bnQgPCAwIHx8IGNvdW50IDwgb3B0LT5tYXhfY291bnQpKSB7CgkJCWNvdW50Kys7CgkJCWlmIChvcHQtPnN0YXR1c19vbmx5KQoJCQkJcmV0dXJuIDE7CgkJCWlmIChvcHQtPm5hbWVfb25seSkgewoJCQkJc2hvd19uYW1lKG9wdCwgZ3MtPm5hbWUpOwoJCQkJcmV0dXJuIDE7CgkJCX0KCQkJaWYgKG9wdC0+Y291bnQpCgkJCQlnb3RvIG5leHRfbGluZTsKCQkJaWYgKGJpbmFyeV9tYXRjaF9vbmx5KSB7CgkJCQlvcHQtPm91dHB1dChvcHQsICJCaW5hcnkgZmlsZSAiLCAxMik7CgkJCQlvdXRwdXRfY29sb3Iob3B0LCBncy0+bmFtZSwgc3RybGVuKGdzLT5uYW1lKSwKCQkJCQkgICAgIG9wdC0+Y29sb3JzW0dSRVBfQ09MT1JfRklMRU5BTUVdKTsKCQkJCW9wdC0+b3V0cHV0KG9wdCwgIiBtYXRjaGVzXG4iLCA5KTsKCQkJCXJldHVybiAxOwoJCQl9CgkJCS8qIEhpdCBhdCB0aGlzIGxpbmUuICBJZiB3ZSBoYXZlbid0IHNob3duIHRoZQoJCQkgKiBwcmUtY29udGV4dCBsaW5lcywgd2Ugd291bGQgbmVlZCB0byBzaG93IHRoZW0uCgkJCSAqLwoJCQlpZiAob3B0LT5wcmVfY29udGV4dCB8fCBvcHQtPmZ1bmNib2R5KQoJCQkJc2hvd19wcmVfY29udGV4dChvcHQsIGdzLCBib2wsIGVvbCwgbG5vKTsKCQkJZWxzZSBpZiAob3B0LT5mdW5jbmFtZSkKCQkJCXNob3dfZnVuY25hbWVfbGluZShvcHQsIGdzLCBib2wsIGxubyk7CgkJCWNubyA9IG9wdC0+aW52ZXJ0ID8gaWNvbCA6IGNvbDsKCQkJaWYgKGNubyA8IDApIHsKCQkJCS8qCgkJCQkgKiBBIG5lZ2F0aXZlIGNubyBpbmRpY2F0ZXMgdGhhdCB0aGVyZSB3YXMgbm8KCQkJCSAqIG1hdGNoIG9uIHRoZSBsaW5lLiBXZSBhcmUgdGh1cyBpbnZlcnRlZCBhbmQKCQkJCSAqIGJlaW5nIGFza2VkIHRvIHNob3cgYWxsIGxpbmVzIHRoYXQgX2Rvbid0XwoJCQkJICogbWF0Y2ggYSBnaXZlbiBleHByZXNzaW9uLiBUaGVyZWZvcmUsIHNldCBjbm8KCQkJCSAqIHRvIDAgdG8gc3VnZ2VzdCB0aGUgd2hvbGUgbGluZSBtYXRjaGVzLgoJCQkJICovCgkJCQljbm8gPSAwOwoJCQl9CgkJCXNob3dfbGluZShvcHQsIGJvbCwgZW9sLCBncy0+bmFtZSwgbG5vLCBjbm8gKyAxLCAnOicpOwoJCQlsYXN0X2hpdCA9IGxubzsKCQkJaWYgKG9wdC0+ZnVuY2JvZHkpCgkJCQlzaG93X2Z1bmN0aW9uID0gMTsKCQkJZ290byBuZXh0X2xpbmU7CgkJfQoJCWlmIChzaG93X2Z1bmN0aW9uICYmICghcGVla19ib2wgfHwgcGVla19ib2wgPCBib2wpKSB7CgkJCXVuc2lnbmVkIGxvbmcgcGVla19sZWZ0ID0gbGVmdDsKCQkJY29uc3QgY2hhciAqcGVla19lb2wgPSBlb2w7CgoJCQkvKgoJCQkgKiBUcmFpbGluZyBlbXB0eSBsaW5lcyBhcmUgbm90IGludGVyZXN0aW5nLgoJCQkgKiBQZWVrIHBhc3QgdGhlbSB0byBzZWUgaWYgdGhleSBiZWxvbmcgdG8gdGhlCgkJCSAqIGJvZHkgb2YgdGhlIGN1cnJlbnQgZnVuY3Rpb24uCgkJCSAqLwoJCQlwZWVrX2JvbCA9IGJvbDsKCQkJd2hpbGUgKGlzX2VtcHR5X2xpbmUocGVla19ib2wsIHBlZWtfZW9sKSkgewoJCQkJcGVla19ib2wgPSBwZWVrX2VvbCArIDE7CgkJCQlwZWVrX2VvbCA9IGVuZF9vZl9saW5lKHBlZWtfYm9sLCAmcGVla19sZWZ0KTsKCQkJfQoKCQkJaWYgKG1hdGNoX2Z1bmNuYW1lKG9wdCwgZ3MsIHBlZWtfYm9sLCBwZWVrX2VvbCkpCgkJCQlzaG93X2Z1bmN0aW9uID0gMDsKCQl9CgkJaWYgKHNob3dfZnVuY3Rpb24gfHwKCQkgICAgKGxhc3RfaGl0ICYmIGxubyA8PSBsYXN0X2hpdCArIG9wdC0+cG9zdF9jb250ZXh0KSkgewoJCQkvKiBJZiB0aGUgbGFzdCBoaXQgaXMgd2l0aGluIHRoZSBwb3N0IGNvbnRleHQsCgkJCSAqIHdlIG5lZWQgdG8gc2hvdyB0aGlzIGxpbmUuCgkJCSAqLwoJCQlzaG93X2xpbmUob3B0LCBib2wsIGVvbCwgZ3MtPm5hbWUsIGxubywgY29sICsgMSwgJy0nKTsKCQl9CgoJbmV4dF9saW5lOgoJCWJvbCA9IGVvbCArIDE7CgkJaWYgKCFsZWZ0KQoJCQlicmVhazsKCQlsZWZ0LS07CgkJbG5vKys7Cgl9CgoJaWYgKGNvbGxlY3RfaGl0cykKCQlyZXR1cm4gMDsKCglpZiAob3B0LT5zdGF0dXNfb25seSkKCQlyZXR1cm4gb3B0LT51bm1hdGNoX25hbWVfb25seTsKCWlmIChvcHQtPnVubWF0Y2hfbmFtZV9vbmx5KSB7CgkJLyogV2UgZGlkIG5vdCBzZWUgYW55IGhpdCwgc28gd2Ugd2FudCB0byBzaG93IHRoaXMgKi8KCQlzaG93X25hbWUob3B0LCBncy0+bmFtZSk7CgkJcmV0dXJuIDE7Cgl9CgoJeGRpZmZfY2xlYXJfZmluZF9mdW5jKCZ4ZWNmZyk7CglvcHQtPnByaXYgPSBOVUxMOwoKCS8qIE5FRURTV09SSzoKCSAqIFRoZSByZWFsICJncmVwIC1jIGZvbyAqLmMiIGdpdmVzIG1hbnkgImJhci5jOjAiIGxpbmVzLAoJICogd2hpY2ggZmVlbHMgbW9zdGx5IHVzZWxlc3MgYnV0IHNvbWV0aW1lcyB1c2VmdWwuICBNYXliZQoJICogbWFrZSBpdCBhbm90aGVyIG9wdGlvbj8gIEZvciBub3cgc3VwcHJlc3MgdGhlbS4KCSAqLwoJaWYgKG9wdC0+Y291bnQgJiYgY291bnQpIHsKCQljaGFyIGJ1ZlszMl07CgkJaWYgKG9wdC0+cGF0aG5hbWUpIHsKCQkJb3V0cHV0X2NvbG9yKG9wdCwgZ3MtPm5hbWUsIHN0cmxlbihncy0+bmFtZSksCgkJCQkgICAgIG9wdC0+Y29sb3JzW0dSRVBfQ09MT1JfRklMRU5BTUVdKTsKCQkJb3V0cHV0X3NlcChvcHQsICc6Jyk7CgkJfQoJCXhzbnByaW50ZihidWYsIHNpemVvZihidWYpLCAiJXVcbiIsIGNvdW50KTsKCQlvcHQtPm91dHB1dChvcHQsIGJ1Ziwgc3RybGVuKGJ1ZikpOwoJCXJldHVybiAxOwoJfQoJcmV0dXJuICEhbGFzdF9oaXQ7Cn0KCnN0YXRpYyB2b2lkIGNscl9oaXRfbWFya2VyKHN0cnVjdCBncmVwX2V4cHIgKngpCnsKCS8qIEFsbC1oaXQgbWFya2VycyBhcmUgbWVhbmluZ2Z1bCBvbmx5IGF0IHRoZSB2ZXJ5IHRvcCBsZXZlbAoJICogT1Igbm9kZS4KCSAqLwoJd2hpbGUgKDEpIHsKCQl4LT5oaXQgPSAwOwoJCWlmICh4LT5ub2RlICE9IEdSRVBfTk9ERV9PUikKCQkJcmV0dXJuOwoJCXgtPnUuYmluYXJ5LmxlZnQtPmhpdCA9IDA7CgkJeCA9IHgtPnUuYmluYXJ5LnJpZ2h0OwoJfQp9CgpzdGF0aWMgaW50IGNoa19oaXRfbWFya2VyKHN0cnVjdCBncmVwX2V4cHIgKngpCnsKCS8qIFRvcCBsZXZlbCBub2RlcyBoYXZlIGhpdCBtYXJrZXJzLiAgU2VlIGlmIHRoZXkgYWxsIGFyZSBoaXRzICovCgl3aGlsZSAoMSkgewoJCWlmICh4LT5ub2RlICE9IEdSRVBfTk9ERV9PUikKCQkJcmV0dXJuIHgtPmhpdDsKCQlpZiAoIXgtPnUuYmluYXJ5LmxlZnQtPmhpdCkKCQkJcmV0dXJuIDA7CgkJeCA9IHgtPnUuYmluYXJ5LnJpZ2h0OwoJfQp9CgppbnQgZ3JlcF9zb3VyY2Uoc3RydWN0IGdyZXBfb3B0ICpvcHQsIHN0cnVjdCBncmVwX3NvdXJjZSAqZ3MpCnsKCS8qCgkgKiB3ZSBkbyBub3QgaGF2ZSB0byBkbyB0aGUgdHdvLXBhc3MgZ3JlcCB3aGVuIHdlIGRvIG5vdCBjaGVjawoJICogYnVmZmVyLXdpZGUgImFsbC1tYXRjaCIuCgkgKi8KCWlmICghb3B0LT5hbGxfbWF0Y2ggJiYgIW9wdC0+bm9fYm9keV9tYXRjaCkKCQlyZXR1cm4gZ3JlcF9zb3VyY2VfMShvcHQsIGdzLCAwKTsKCgkvKiBPdGhlcndpc2UgdGhlIHRvcGxldmVsICJvciIgdGVybXMgaGl0IGEgYml0IGRpZmZlcmVudGx5LgoJICogV2UgZmlyc3QgY2xlYXIgaGl0IG1hcmtlcnMgZnJvbSB0aGVtLgoJICovCgljbHJfaGl0X21hcmtlcihvcHQtPnBhdHRlcm5fZXhwcmVzc2lvbik7CglvcHQtPmJvZHlfaGl0ID0gMDsKCWdyZXBfc291cmNlXzEob3B0LCBncywgMSk7CgoJaWYgKG9wdC0+YWxsX21hdGNoICYmICFjaGtfaGl0X21hcmtlcihvcHQtPnBhdHRlcm5fZXhwcmVzc2lvbikpCgkJcmV0dXJuIDA7CglpZiAob3B0LT5ub19ib2R5X21hdGNoICYmIG9wdC0+Ym9keV9oaXQpCgkJcmV0dXJuIDA7CgoJcmV0dXJuIGdyZXBfc291cmNlXzEob3B0LCBncywgMCk7Cn0KCnN0YXRpYyB2b2lkIGdyZXBfc291cmNlX2luaXRfYnVmKHN0cnVjdCBncmVwX3NvdXJjZSAqZ3MsCgkJCQkgY29uc3QgY2hhciAqYnVmLAoJCQkJIHVuc2lnbmVkIGxvbmcgc2l6ZSkKewoJZ3MtPnR5cGUgPSBHUkVQX1NPVVJDRV9CVUY7Cglncy0+bmFtZSA9IE5VTEw7Cglncy0+cGF0aCA9IE5VTEw7Cglncy0+YnVmID0gYnVmOwoJZ3MtPnNpemUgPSBzaXplOwoJZ3MtPmRyaXZlciA9IE5VTEw7Cglncy0+aWRlbnRpZmllciA9IE5VTEw7Cn0KCmludCBncmVwX2J1ZmZlcihzdHJ1Y3QgZ3JlcF9vcHQgKm9wdCwgY29uc3QgY2hhciAqYnVmLCB1bnNpZ25lZCBsb25nIHNpemUpCnsKCXN0cnVjdCBncmVwX3NvdXJjZSBnczsKCWludCByOwoKCWdyZXBfc291cmNlX2luaXRfYnVmKCZncywgYnVmLCBzaXplKTsKCglyID0gZ3JlcF9zb3VyY2Uob3B0LCAmZ3MpOwoKCWdyZXBfc291cmNlX2NsZWFyKCZncyk7CglyZXR1cm4gcjsKfQoKdm9pZCBncmVwX3NvdXJjZV9pbml0X2ZpbGUoc3RydWN0IGdyZXBfc291cmNlICpncywgY29uc3QgY2hhciAqbmFtZSwKCQkJICAgY29uc3QgY2hhciAqcGF0aCkKewoJZ3MtPnR5cGUgPSBHUkVQX1NPVVJDRV9GSUxFOwoJZ3MtPm5hbWUgPSB4c3RyZHVwX29yX251bGwobmFtZSk7Cglncy0+cGF0aCA9IHhzdHJkdXBfb3JfbnVsbChwYXRoKTsKCWdzLT5idWYgPSBOVUxMOwoJZ3MtPnNpemUgPSAwOwoJZ3MtPmRyaXZlciA9IE5VTEw7Cglncy0+aWRlbnRpZmllciA9IHhzdHJkdXAocGF0aCk7Cn0KCnZvaWQgZ3JlcF9zb3VyY2VfaW5pdF9vaWQoc3RydWN0IGdyZXBfc291cmNlICpncywgY29uc3QgY2hhciAqbmFtZSwKCQkJICBjb25zdCBjaGFyICpwYXRoLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCSAgc3RydWN0IHJlcG9zaXRvcnkgKnJlcG8pCnsKCWdzLT50eXBlID0gR1JFUF9TT1VSQ0VfT0lEOwoJZ3MtPm5hbWUgPSB4c3RyZHVwX29yX251bGwobmFtZSk7Cglncy0+cGF0aCA9IHhzdHJkdXBfb3JfbnVsbChwYXRoKTsKCWdzLT5idWYgPSBOVUxMOwoJZ3MtPnNpemUgPSAwOwoJZ3MtPmRyaXZlciA9IE5VTEw7Cglncy0+aWRlbnRpZmllciA9IG9pZGR1cChvaWQpOwoJZ3MtPnJlcG8gPSByZXBvOwp9Cgp2b2lkIGdyZXBfc291cmNlX2NsZWFyKHN0cnVjdCBncmVwX3NvdXJjZSAqZ3MpCnsKCUZSRUVfQU5EX05VTEwoZ3MtPm5hbWUpOwoJRlJFRV9BTkRfTlVMTChncy0+cGF0aCk7CglGUkVFX0FORF9OVUxMKGdzLT5pZGVudGlmaWVyKTsKCWdyZXBfc291cmNlX2NsZWFyX2RhdGEoZ3MpOwp9Cgp2b2lkIGdyZXBfc291cmNlX2NsZWFyX2RhdGEoc3RydWN0IGdyZXBfc291cmNlICpncykKewoJc3dpdGNoIChncy0+dHlwZSkgewoJY2FzZSBHUkVQX1NPVVJDRV9GSUxFOgoJY2FzZSBHUkVQX1NPVVJDRV9PSUQ6CgkJLyogdGhlc2UgdHlwZXMgb3duIHRoZSBidWZmZXIgKi8KCQlmcmVlKChjaGFyICopZ3MtPmJ1Zik7CgkJZ3MtPmJ1ZiA9IE5VTEw7CgkJZ3MtPnNpemUgPSAwOwoJCWJyZWFrOwoJY2FzZSBHUkVQX1NPVVJDRV9CVUY6CgkJLyogbGVhdmUgdXNlci1wcm92aWRlZCBidWYgaW50YWN0ICovCgkJYnJlYWs7Cgl9Cn0KCnN0YXRpYyBpbnQgZ3JlcF9zb3VyY2VfbG9hZF9vaWQoc3RydWN0IGdyZXBfc291cmNlICpncykKewoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoKCWdzLT5idWYgPSByZXBvX3JlYWRfb2JqZWN0X2ZpbGUoZ3MtPnJlcG8sIGdzLT5pZGVudGlmaWVyLCAmdHlwZSwKCQkJCQkmZ3MtPnNpemUpOwoJaWYgKCFncy0+YnVmKQoJCXJldHVybiBlcnJvcihfKCInJXMnOiB1bmFibGUgdG8gcmVhZCAlcyIpLAoJCQkgICAgIGdzLT5uYW1lLAoJCQkgICAgIG9pZF90b19oZXgoZ3MtPmlkZW50aWZpZXIpKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdyZXBfc291cmNlX2xvYWRfZmlsZShzdHJ1Y3QgZ3JlcF9zb3VyY2UgKmdzKQp7Cgljb25zdCBjaGFyICpmaWxlbmFtZSA9IGdzLT5pZGVudGlmaWVyOwoJc3RydWN0IHN0YXQgc3Q7CgljaGFyICpkYXRhOwoJc2l6ZV90IHNpemU7CglpbnQgaTsKCglpZiAobHN0YXQoZmlsZW5hbWUsICZzdCkgPCAwKSB7CgllcnJfcmV0OgoJCWlmIChlcnJubyAhPSBFTk9FTlQpCgkJCWVycm9yX2Vycm5vKF8oImZhaWxlZCB0byBzdGF0ICclcyciKSwgZmlsZW5hbWUpOwoJCXJldHVybiAtMTsKCX0KCWlmICghU19JU1JFRyhzdC5zdF9tb2RlKSkKCQlyZXR1cm4gLTE7CglzaXplID0geHNpemVfdChzdC5zdF9zaXplKTsKCWkgPSBvcGVuKGZpbGVuYW1lLCBPX1JET05MWSk7CglpZiAoaSA8IDApCgkJZ290byBlcnJfcmV0OwoJZGF0YSA9IHhtYWxsb2N6KHNpemUpOwoJaWYgKHN0LnN0X3NpemUgIT0gcmVhZF9pbl9mdWxsKGksIGRhdGEsIHNpemUpKSB7CgkJZXJyb3JfZXJybm8oXygiJyVzJzogc2hvcnQgcmVhZCIpLCBmaWxlbmFtZSk7CgkJY2xvc2UoaSk7CgkJZnJlZShkYXRhKTsKCQlyZXR1cm4gLTE7Cgl9CgljbG9zZShpKTsKCglncy0+YnVmID0gZGF0YTsKCWdzLT5zaXplID0gc2l6ZTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdyZXBfc291cmNlX2xvYWQoc3RydWN0IGdyZXBfc291cmNlICpncykKewoJaWYgKGdzLT5idWYpCgkJcmV0dXJuIDA7CgoJc3dpdGNoIChncy0+dHlwZSkgewoJY2FzZSBHUkVQX1NPVVJDRV9GSUxFOgoJCXJldHVybiBncmVwX3NvdXJjZV9sb2FkX2ZpbGUoZ3MpOwoJY2FzZSBHUkVQX1NPVVJDRV9PSUQ6CgkJcmV0dXJuIGdyZXBfc291cmNlX2xvYWRfb2lkKGdzKTsKCWNhc2UgR1JFUF9TT1VSQ0VfQlVGOgoJCXJldHVybiBncy0+YnVmID8gMCA6IC0xOwoJfQoJQlVHKCJpbnZhbGlkIGdyZXBfc291cmNlIHR5cGUgdG8gbG9hZCIpOwp9Cgp2b2lkIGdyZXBfc291cmNlX2xvYWRfZHJpdmVyKHN0cnVjdCBncmVwX3NvdXJjZSAqZ3MsCgkJCSAgICAgc3RydWN0IGluZGV4X3N0YXRlICppc3RhdGUpCnsKCWlmIChncy0+ZHJpdmVyKQoJCXJldHVybjsKCglncmVwX2F0dHJfbG9jaygpOwoJaWYgKGdzLT5wYXRoKQoJCWdzLT5kcml2ZXIgPSB1c2VyZGlmZl9maW5kX2J5X3BhdGgoaXN0YXRlLCBncy0+cGF0aCk7CglpZiAoIWdzLT5kcml2ZXIpCgkJZ3MtPmRyaXZlciA9IHVzZXJkaWZmX2ZpbmRfYnlfbmFtZSgiZGVmYXVsdCIpOwoJZ3JlcF9hdHRyX3VubG9jaygpOwp9CgpzdGF0aWMgaW50IGdyZXBfc291cmNlX2lzX2JpbmFyeShzdHJ1Y3QgZ3JlcF9zb3VyY2UgKmdzLAoJCQkJIHN0cnVjdCBpbmRleF9zdGF0ZSAqaXN0YXRlKQp7CglncmVwX3NvdXJjZV9sb2FkX2RyaXZlcihncywgaXN0YXRlKTsKCWlmIChncy0+ZHJpdmVyLT5iaW5hcnkgIT0gLTEpCgkJcmV0dXJuIGdzLT5kcml2ZXItPmJpbmFyeTsKCglpZiAoIWdyZXBfc291cmNlX2xvYWQoZ3MpKQoJCXJldHVybiBidWZmZXJfaXNfYmluYXJ5KGdzLT5idWYsIGdzLT5zaXplKTsKCglyZXR1cm4gMDsKfQo=",
    "text": "#include \"cache.h\"\n#include \"config.h\"\n#include \"grep.h\"\n#include \"object-store.h\"\n#include \"userdiff.h\"\n#include \"xdiff-interface.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"commit.h\"\n#include \"quote.h\"\n#include \"help.h\"\n\nstatic int grep_source_load(struct grep_source *gs);\nstatic int grep_source_is_binary(struct grep_source *gs,\n\t\t\t\t struct index_state *istate);\n\nstatic void std_output(struct grep_opt *opt, const void *buf, size_t size)\n{\n\tfwrite(buf, size, 1, stdout);\n}\n\nstatic const char *color_grep_slots[] = {\n\t[GREP_COLOR_CONTEXT]\t    = \"context\",\n\t[GREP_COLOR_FILENAME]\t    = \"filename\",\n\t[GREP_COLOR_FUNCTION]\t    = \"function\",\n\t[GREP_COLOR_LINENO]\t    = \"lineNumber\",\n\t[GREP_COLOR_COLUMNNO]\t    = \"column\",\n\t[GREP_COLOR_MATCH_CONTEXT]  = \"matchContext\",\n\t[GREP_COLOR_MATCH_SELECTED] = \"matchSelected\",\n\t[GREP_COLOR_SELECTED]\t    = \"selected\",\n\t[GREP_COLOR_SEP]\t    = \"separator\",\n};\n\nstatic int parse_pattern_type_arg(const char *opt, const char *arg)\n{\n\tif (!strcmp(arg, \"default\"))\n\t\treturn GREP_PATTERN_TYPE_UNSPECIFIED;\n\telse if (!strcmp(arg, \"basic\"))\n\t\treturn GREP_PATTERN_TYPE_BRE;\n\telse if (!strcmp(arg, \"extended\"))\n\t\treturn GREP_PATTERN_TYPE_ERE;\n\telse if (!strcmp(arg, \"fixed\"))\n\t\treturn GREP_PATTERN_TYPE_FIXED;\n\telse if (!strcmp(arg, \"perl\"))\n\t\treturn GREP_PATTERN_TYPE_PCRE;\n\tdie(\"bad %s argument: %s\", opt, arg);\n}\n\ndefine_list_config_array_extra(color_grep_slots, {\"match\"});\n\n/*\n * Read the configuration file once and store it in\n * the grep_defaults template.\n */\nint grep_config(const char *var, const char *value, void *cb)\n{\n\tstruct grep_opt *opt = cb;\n\tconst char *slot;\n\n\tif (userdiff_config(var, value) < 0)\n\t\treturn -1;\n\n\tif (!strcmp(var, \"grep.extendedregexp\")) {\n\t\topt->extended_regexp_option = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"grep.patterntype\")) {\n\t\topt->pattern_type_option = parse_pattern_type_arg(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"grep.linenumber\")) {\n\t\topt->linenum = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"grep.column\")) {\n\t\topt->columnnum = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"grep.fullname\")) {\n\t\topt->relative = !git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"color.grep\"))\n\t\topt->color = git_config_colorbool(var, value);\n\tif (!strcmp(var, \"color.grep.match\")) {\n\t\tif (grep_config(\"color.grep.matchcontext\", value, cb) < 0)\n\t\t\treturn -1;\n\t\tif (grep_config(\"color.grep.matchselected\", value, cb) < 0)\n\t\t\treturn -1;\n\t} else if (skip_prefix(var, \"color.grep.\", &slot)) {\n\t\tint i = LOOKUP_CONFIG(color_grep_slots, slot);\n\t\tchar *color;\n\n\t\tif (i < 0)\n\t\t\treturn -1;\n\t\tcolor = opt->colors[i];\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\treturn color_parse(value, color);\n\t}\n\treturn 0;\n}\n\nvoid grep_init(struct grep_opt *opt, struct repository *repo)\n{\n\tstruct grep_opt blank = GREP_OPT_INIT;\n\tmemcpy(opt, &blank, sizeof(*opt));\n\n\topt->repo = repo;\n\topt->pattern_tail = &opt->pattern_list;\n\topt->header_tail = &opt->header_list;\n}\n\nstatic struct grep_pat *create_grep_pat(const char *pat, size_t patlen,\n\t\t\t\t\tconst char *origin, int no,\n\t\t\t\t\tenum grep_pat_token t,\n\t\t\t\t\tenum grep_header_field field)\n{\n\tstruct grep_pat *p = xcalloc(1, sizeof(*p));\n\tp->pattern = xmemdupz(pat, patlen);\n\tp->patternlen = patlen;\n\tp->origin = origin;\n\tp->no = no;\n\tp->token = t;\n\tp->field = field;\n\treturn p;\n}\n\nstatic void do_append_grep_pat(struct grep_pat ***tail, struct grep_pat *p)\n{\n\t**tail = p;\n\t*tail = &p->next;\n\tp->next = NULL;\n\n\tswitch (p->token) {\n\tcase GREP_PATTERN: /* atom */\n\tcase GREP_PATTERN_HEAD:\n\tcase GREP_PATTERN_BODY:\n\t\tfor (;;) {\n\t\t\tstruct grep_pat *new_pat;\n\t\t\tsize_t len = 0;\n\t\t\tchar *cp = p->pattern + p->patternlen, *nl = NULL;\n\t\t\twhile (++len <= p->patternlen) {\n\t\t\t\tif (*(--cp) == '\\n') {\n\t\t\t\t\tnl = cp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!nl)\n\t\t\t\tbreak;\n\t\t\tnew_pat = create_grep_pat(nl + 1, len - 1, p->origin,\n\t\t\t\t\t\t  p->no, p->token, p->field);\n\t\t\tnew_pat->next = p->next;\n\t\t\tif (!p->next)\n\t\t\t\t*tail = &new_pat->next;\n\t\t\tp->next = new_pat;\n\t\t\t*nl = '\\0';\n\t\t\tp->patternlen -= len;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid append_header_grep_pattern(struct grep_opt *opt,\n\t\t\t\tenum grep_header_field field, const char *pat)\n{\n\tstruct grep_pat *p = create_grep_pat(pat, strlen(pat), \"header\", 0,\n\t\t\t\t\t     GREP_PATTERN_HEAD, field);\n\tif (field == GREP_HEADER_REFLOG)\n\t\topt->use_reflog_filter = 1;\n\tdo_append_grep_pat(&opt->header_tail, p);\n}\n\nvoid append_grep_pattern(struct grep_opt *opt, const char *pat,\n\t\t\t const char *origin, int no, enum grep_pat_token t)\n{\n\tappend_grep_pat(opt, pat, strlen(pat), origin, no, t);\n}\n\nvoid append_grep_pat(struct grep_opt *opt, const char *pat, size_t patlen,\n\t\t     const char *origin, int no, enum grep_pat_token t)\n{\n\tstruct grep_pat *p = create_grep_pat(pat, patlen, origin, no, t, 0);\n\tdo_append_grep_pat(&opt->pattern_tail, p);\n}\n\nstruct grep_opt *grep_opt_dup(const struct grep_opt *opt)\n{\n\tstruct grep_pat *pat;\n\tstruct grep_opt *ret = xmalloc(sizeof(struct grep_opt));\n\t*ret = *opt;\n\n\tret->pattern_list = NULL;\n\tret->pattern_tail = &ret->pattern_list;\n\n\tfor(pat = opt->pattern_list; pat != NULL; pat = pat->next)\n\t{\n\t\tif(pat->token == GREP_PATTERN_HEAD)\n\t\t\tappend_header_grep_pattern(ret, pat->field,\n\t\t\t\t\t\t   pat->pattern);\n\t\telse\n\t\t\tappend_grep_pat(ret, pat->pattern, pat->patternlen,\n\t\t\t\t\tpat->origin, pat->no, pat->token);\n\t}\n\n\treturn ret;\n}\n\nstatic NORETURN void compile_regexp_failed(const struct grep_pat *p,\n\t\tconst char *error)\n{\n\tchar where[1024];\n\n\tif (p->no)\n\t\txsnprintf(where, sizeof(where), \"In '%s' at %d, \", p->origin, p->no);\n\telse if (p->origin)\n\t\txsnprintf(where, sizeof(where), \"%s, \", p->origin);\n\telse\n\t\twhere[0] = 0;\n\n\tdie(\"%s'%s': %s\", where, p->pattern, error);\n}\n\nstatic int is_fixed(const char *s, size_t len)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (is_regex_special(s[i]))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n#ifdef USE_LIBPCRE2\n#define GREP_PCRE2_DEBUG_MALLOC 0\n\nstatic void *pcre2_malloc(PCRE2_SIZE size, MAYBE_UNUSED void *memory_data)\n{\n\tvoid *pointer = malloc(size);\n#if GREP_PCRE2_DEBUG_MALLOC\n\tstatic int count = 1;\n\tfprintf(stderr, \"PCRE2:%p -> #%02d: alloc(%lu)\\n\", pointer, count++, size);\n#endif\n\treturn pointer;\n}\n\nstatic void pcre2_free(void *pointer, MAYBE_UNUSED void *memory_data)\n{\n#if GREP_PCRE2_DEBUG_MALLOC\n\tstatic int count = 1;\n\tif (pointer)\n\t\tfprintf(stderr, \"PCRE2:%p -> #%02d: free()\\n\", pointer, count++);\n#endif\n\tfree(pointer);\n}\n\nstatic void compile_pcre2_pattern(struct grep_pat *p, const struct grep_opt *opt)\n{\n\tint error;\n\tPCRE2_UCHAR errbuf[256];\n\tPCRE2_SIZE erroffset;\n\tint options = PCRE2_MULTILINE;\n\tint jitret;\n\tint patinforet;\n\tsize_t jitsizearg;\n\tint literal = !opt->ignore_case && (p->fixed || p->is_fixed);\n\n\t/*\n\t * Call pcre2_general_context_create() before calling any\n\t * other pcre2_*(). It sets up our malloc()/free() functions\n\t * with which everything else is allocated.\n\t */\n\tp->pcre2_general_context = pcre2_general_context_create(\n\t\tpcre2_malloc, pcre2_free, NULL);\n\tif (!p->pcre2_general_context)\n\t\tdie(\"Couldn't allocate PCRE2 general context\");\n\n\tif (opt->ignore_case) {\n\t\tif (!opt->ignore_locale && has_non_ascii(p->pattern)) {\n\t\t\tp->pcre2_tables = pcre2_maketables(p->pcre2_general_context);\n\t\t\tp->pcre2_compile_context = pcre2_compile_context_create(p->pcre2_general_context);\n\t\t\tpcre2_set_character_tables(p->pcre2_compile_context,\n\t\t\t\t\t\t\tp->pcre2_tables);\n\t\t}\n\t\toptions |= PCRE2_CASELESS;\n\t}\n\tif (!opt->ignore_locale && is_utf8_locale() && !literal)\n\t\toptions |= (PCRE2_UTF | PCRE2_UCP | PCRE2_MATCH_INVALID_UTF);\n\n#ifndef GIT_PCRE2_VERSION_10_35_OR_HIGHER\n\t/*\n\t * Work around a JIT bug related to invalid Unicode character handling\n\t * fixed in 10.35:\n\t * https://github.com/PCRE2Project/pcre2/commit/c21bd977547d\n\t */\n\toptions &= ~PCRE2_UCP;\n#endif\n\n#ifndef GIT_PCRE2_VERSION_10_36_OR_HIGHER\n\t/* Work around https://bugs.exim.org/show_bug.cgi?id=2642 fixed in 10.36 */\n\tif (PCRE2_MATCH_INVALID_UTF && options & (PCRE2_UTF | PCRE2_CASELESS))\n\t\toptions |= PCRE2_NO_START_OPTIMIZE;\n#endif\n\n\tp->pcre2_pattern = pcre2_compile((PCRE2_SPTR)p->pattern,\n\t\t\t\t\t p->patternlen, options, &error, &erroffset,\n\t\t\t\t\t p->pcre2_compile_context);\n\n\tif (p->pcre2_pattern) {\n\t\tp->pcre2_match_data = pcre2_match_data_create_from_pattern(p->pcre2_pattern, p->pcre2_general_context);\n\t\tif (!p->pcre2_match_data)\n\t\t\tdie(\"Couldn't allocate PCRE2 match data\");\n\t} else {\n\t\tpcre2_get_error_message(error, errbuf, sizeof(errbuf));\n\t\tcompile_regexp_failed(p, (const char *)&errbuf);\n\t}\n\n\tpcre2_config(PCRE2_CONFIG_JIT, &p->pcre2_jit_on);\n\tif (p->pcre2_jit_on) {\n\t\tjitret = pcre2_jit_compile(p->pcre2_pattern, PCRE2_JIT_COMPLETE);\n\t\tif (jitret)\n\t\t\tdie(\"Couldn't JIT the PCRE2 pattern '%s', got '%d'\\n\", p->pattern, jitret);\n\n\t\t/*\n\t\t * The pcre2_config(PCRE2_CONFIG_JIT, ...) call just\n\t\t * tells us whether the library itself supports JIT,\n\t\t * but to see whether we're going to be actually using\n\t\t * JIT we need to extract PCRE2_INFO_JITSIZE from the\n\t\t * pattern *after* we do pcre2_jit_compile() above.\n\t\t *\n\t\t * This is because if the pattern contains the\n\t\t * (*NO_JIT) verb (see pcre2syntax(3))\n\t\t * pcre2_jit_compile() will exit early with 0. If we\n\t\t * then proceed to call pcre2_jit_match() further down\n\t\t * the line instead of pcre2_match() we'll either\n\t\t * segfault (pre PCRE 10.31) or run into a fatal error\n\t\t * (post PCRE2 10.31)\n\t\t */\n\t\tpatinforet = pcre2_pattern_info(p->pcre2_pattern, PCRE2_INFO_JITSIZE, &jitsizearg);\n\t\tif (patinforet)\n\t\t\tBUG(\"pcre2_pattern_info() failed: %d\", patinforet);\n\t\tif (jitsizearg == 0) {\n\t\t\tp->pcre2_jit_on = 0;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int pcre2match(struct grep_pat *p, const char *line, const char *eol,\n\t\tregmatch_t *match, int eflags)\n{\n\tint ret, flags = 0;\n\tPCRE2_SIZE *ovector;\n\tPCRE2_UCHAR errbuf[256];\n\n\tif (eflags & REG_NOTBOL)\n\t\tflags |= PCRE2_NOTBOL;\n\n\tif (p->pcre2_jit_on)\n\t\tret = pcre2_jit_match(p->pcre2_pattern, (unsigned char *)line,\n\t\t\t\t      eol - line, 0, flags, p->pcre2_match_data,\n\t\t\t\t      NULL);\n\telse\n\t\tret = pcre2_match(p->pcre2_pattern, (unsigned char *)line,\n\t\t\t\t  eol - line, 0, flags, p->pcre2_match_data,\n\t\t\t\t  NULL);\n\n\tif (ret < 0 && ret != PCRE2_ERROR_NOMATCH) {\n\t\tpcre2_get_error_message(ret, errbuf, sizeof(errbuf));\n\t\tdie(\"%s failed with error code %d: %s\",\n\t\t    (p->pcre2_jit_on ? \"pcre2_jit_match\" : \"pcre2_match\"), ret,\n\t\t    errbuf);\n\t}\n\tif (ret > 0) {\n\t\tovector = pcre2_get_ovector_pointer(p->pcre2_match_data);\n\t\tret = 0;\n\t\tmatch->rm_so = (int)ovector[0];\n\t\tmatch->rm_eo = (int)ovector[1];\n\t}\n\n\treturn ret;\n}\n\nstatic void free_pcre2_pattern(struct grep_pat *p)\n{\n\tpcre2_compile_context_free(p->pcre2_compile_context);\n\tpcre2_code_free(p->pcre2_pattern);\n\tpcre2_match_data_free(p->pcre2_match_data);\n#ifdef GIT_PCRE2_VERSION_10_34_OR_HIGHER\n\tpcre2_maketables_free(p->pcre2_general_context, p->pcre2_tables);\n#else\n\tfree((void *)p->pcre2_tables);\n#endif\n\tpcre2_general_context_free(p->pcre2_general_context);\n}\n#else /* !USE_LIBPCRE2 */\nstatic void compile_pcre2_pattern(struct grep_pat *p, const struct grep_opt *opt)\n{\n\tdie(\"cannot use Perl-compatible regexes when not compiled with USE_LIBPCRE\");\n}\n\nstatic int pcre2match(struct grep_pat *p, const char *line, const char *eol,\n\t\tregmatch_t *match, int eflags)\n{\n\treturn 1;\n}\n\nstatic void free_pcre2_pattern(struct grep_pat *p)\n{\n}\n\nstatic void compile_fixed_regexp(struct grep_pat *p, struct grep_opt *opt)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tint err;\n\tint regflags = 0;\n\n\tbasic_regex_quote_buf(&sb, p->pattern);\n\tif (opt->ignore_case)\n\t\tregflags |= REG_ICASE;\n\terr = regcomp(&p->regexp, sb.buf, regflags);\n\tstrbuf_release(&sb);\n\tif (err) {\n\t\tchar errbuf[1024];\n\t\tregerror(err, &p->regexp, errbuf, sizeof(errbuf));\n\t\tcompile_regexp_failed(p, errbuf);\n\t}\n}\n#endif /* !USE_LIBPCRE2 */\n\nstatic void compile_regexp(struct grep_pat *p, struct grep_opt *opt)\n{\n\tint err;\n\tint regflags = REG_NEWLINE;\n\n\tif (opt->pattern_type_option == GREP_PATTERN_TYPE_UNSPECIFIED)\n\t\topt->pattern_type_option = (opt->extended_regexp_option\n\t\t\t\t\t    ? GREP_PATTERN_TYPE_ERE\n\t\t\t\t\t    : GREP_PATTERN_TYPE_BRE);\n\n\tp->word_regexp = opt->word_regexp;\n\tp->ignore_case = opt->ignore_case;\n\tp->fixed = opt->pattern_type_option == GREP_PATTERN_TYPE_FIXED;\n\n\tif (opt->pattern_type_option != GREP_PATTERN_TYPE_PCRE &&\n\t    memchr(p->pattern, 0, p->patternlen))\n\t\tdie(_(\"given pattern contains NULL byte (via -f <file>). This is only supported with -P under PCRE v2\"));\n\n\tp->is_fixed = is_fixed(p->pattern, p->patternlen);\n#ifdef USE_LIBPCRE2\n       if (!p->fixed && !p->is_fixed) {\n\t       const char *no_jit = \"(*NO_JIT)\";\n\t       const int no_jit_len = strlen(no_jit);\n\t       if (starts_with(p->pattern, no_jit) &&\n\t\t   is_fixed(p->pattern + no_jit_len,\n\t\t\t    p->patternlen - no_jit_len))\n\t\t       p->is_fixed = 1;\n       }\n#endif\n\tif (p->fixed || p->is_fixed) {\n#ifdef USE_LIBPCRE2\n\t\tif (p->is_fixed) {\n\t\t\tcompile_pcre2_pattern(p, opt);\n\t\t} else {\n\t\t\t/*\n\t\t\t * E.g. t7811-grep-open.sh relies on the\n\t\t\t * pattern being restored.\n\t\t\t */\n\t\t\tchar *old_pattern = p->pattern;\n\t\t\tsize_t old_patternlen = p->patternlen;\n\t\t\tstruct strbuf sb = STRBUF_INIT;\n\n\t\t\t/*\n\t\t\t * There is the PCRE2_LITERAL flag, but it's\n\t\t\t * only in PCRE v2 10.30 and later. Needing to\n\t\t\t * ifdef our way around that and dealing with\n\t\t\t * it + PCRE2_MULTILINE being an error is more\n\t\t\t * complex than just quoting this ourselves.\n\t\t\t*/\n\t\t\tstrbuf_add(&sb, \"\\\\Q\", 2);\n\t\t\tstrbuf_add(&sb, p->pattern, p->patternlen);\n\t\t\tstrbuf_add(&sb, \"\\\\E\", 2);\n\n\t\t\tp->pattern = sb.buf;\n\t\t\tp->patternlen = sb.len;\n\t\t\tcompile_pcre2_pattern(p, opt);\n\t\t\tp->pattern = old_pattern;\n\t\t\tp->patternlen = old_patternlen;\n\t\t\tstrbuf_release(&sb);\n\t\t}\n#else /* !USE_LIBPCRE2 */\n\t\tcompile_fixed_regexp(p, opt);\n#endif /* !USE_LIBPCRE2 */\n\t\treturn;\n\t}\n\n\tif (opt->pattern_type_option == GREP_PATTERN_TYPE_PCRE) {\n\t\tcompile_pcre2_pattern(p, opt);\n\t\treturn;\n\t}\n\n\tif (p->ignore_case)\n\t\tregflags |= REG_ICASE;\n\tif (opt->pattern_type_option == GREP_PATTERN_TYPE_ERE)\n\t\tregflags |= REG_EXTENDED;\n\terr = regcomp(&p->regexp, p->pattern, regflags);\n\tif (err) {\n\t\tchar errbuf[1024];\n\t\tregerror(err, &p->regexp, errbuf, 1024);\n\t\tcompile_regexp_failed(p, errbuf);\n\t}\n}\n\nstatic struct grep_expr *grep_not_expr(struct grep_expr *expr)\n{\n\tstruct grep_expr *z = xcalloc(1, sizeof(*z));\n\tz->node = GREP_NODE_NOT;\n\tz->u.unary = expr;\n\treturn z;\n}\n\nstatic struct grep_expr *grep_binexp(enum grep_expr_node kind,\n\t\t\t\t     struct grep_expr *left,\n\t\t\t\t     struct grep_expr *right)\n{\n\tstruct grep_expr *z = xcalloc(1, sizeof(*z));\n\tz->node = kind;\n\tz->u.binary.left = left;\n\tz->u.binary.right = right;\n\treturn z;\n}\n\nstatic struct grep_expr *grep_or_expr(struct grep_expr *left, struct grep_expr *right)\n{\n\treturn grep_binexp(GREP_NODE_OR, left, right);\n}\n\nstatic struct grep_expr *grep_and_expr(struct grep_expr *left, struct grep_expr *right)\n{\n\treturn grep_binexp(GREP_NODE_AND, left, right);\n}\n\nstatic struct grep_expr *compile_pattern_or(struct grep_pat **);\nstatic struct grep_expr *compile_pattern_atom(struct grep_pat **list)\n{\n\tstruct grep_pat *p;\n\tstruct grep_expr *x;\n\n\tp = *list;\n\tif (!p)\n\t\treturn NULL;\n\tswitch (p->token) {\n\tcase GREP_PATTERN: /* atom */\n\tcase GREP_PATTERN_HEAD:\n\tcase GREP_PATTERN_BODY:\n\t\tCALLOC_ARRAY(x, 1);\n\t\tx->node = GREP_NODE_ATOM;\n\t\tx->u.atom = p;\n\t\t*list = p->next;\n\t\treturn x;\n\tcase GREP_OPEN_PAREN:\n\t\t*list = p->next;\n\t\tx = compile_pattern_or(list);\n\t\tif (!*list || (*list)->token != GREP_CLOSE_PAREN)\n\t\t\tdie(\"unmatched parenthesis\");\n\t\t*list = (*list)->next;\n\t\treturn x;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic struct grep_expr *compile_pattern_not(struct grep_pat **list)\n{\n\tstruct grep_pat *p;\n\tstruct grep_expr *x;\n\n\tp = *list;\n\tif (!p)\n\t\treturn NULL;\n\tswitch (p->token) {\n\tcase GREP_NOT:\n\t\tif (!p->next)\n\t\t\tdie(\"--not not followed by pattern expression\");\n\t\t*list = p->next;\n\t\tx = compile_pattern_not(list);\n\t\tif (!x)\n\t\t\tdie(\"--not followed by non pattern expression\");\n\t\treturn grep_not_expr(x);\n\tdefault:\n\t\treturn compile_pattern_atom(list);\n\t}\n}\n\nstatic struct grep_expr *compile_pattern_and(struct grep_pat **list)\n{\n\tstruct grep_pat *p;\n\tstruct grep_expr *x, *y;\n\n\tx = compile_pattern_not(list);\n\tp = *list;\n\tif (p && p->token == GREP_AND) {\n\t\tif (!x)\n\t\t\tdie(\"--and not preceded by pattern expression\");\n\t\tif (!p->next)\n\t\t\tdie(\"--and not followed by pattern expression\");\n\t\t*list = p->next;\n\t\ty = compile_pattern_and(list);\n\t\tif (!y)\n\t\t\tdie(\"--and not followed by pattern expression\");\n\t\treturn grep_and_expr(x, y);\n\t}\n\treturn x;\n}\n\nstatic struct grep_expr *compile_pattern_or(struct grep_pat **list)\n{\n\tstruct grep_pat *p;\n\tstruct grep_expr *x, *y;\n\n\tx = compile_pattern_and(list);\n\tp = *list;\n\tif (x && p && p->token != GREP_CLOSE_PAREN) {\n\t\ty = compile_pattern_or(list);\n\t\tif (!y)\n\t\t\tdie(\"not a pattern expression %s\", p->pattern);\n\t\treturn grep_or_expr(x, y);\n\t}\n\treturn x;\n}\n\nstatic struct grep_expr *compile_pattern_expr(struct grep_pat **list)\n{\n\treturn compile_pattern_or(list);\n}\n\nstatic struct grep_expr *grep_true_expr(void)\n{\n\tstruct grep_expr *z = xcalloc(1, sizeof(*z));\n\tz->node = GREP_NODE_TRUE;\n\treturn z;\n}\n\nstatic struct grep_expr *prep_header_patterns(struct grep_opt *opt)\n{\n\tstruct grep_pat *p;\n\tstruct grep_expr *header_expr;\n\tstruct grep_expr *(header_group[GREP_HEADER_FIELD_MAX]);\n\tenum grep_header_field fld;\n\n\tif (!opt->header_list)\n\t\treturn NULL;\n\n\tfor (p = opt->header_list; p; p = p->next) {\n\t\tif (p->token != GREP_PATTERN_HEAD)\n\t\t\tBUG(\"a non-header pattern in grep header list.\");\n\t\tif (p->field < GREP_HEADER_FIELD_MIN ||\n\t\t    GREP_HEADER_FIELD_MAX <= p->field)\n\t\t\tBUG(\"unknown header field %d\", p->field);\n\t\tcompile_regexp(p, opt);\n\t}\n\n\tfor (fld = 0; fld < GREP_HEADER_FIELD_MAX; fld++)\n\t\theader_group[fld] = NULL;\n\n\tfor (p = opt->header_list; p; p = p->next) {\n\t\tstruct grep_expr *h;\n\t\tstruct grep_pat *pp = p;\n\n\t\th = compile_pattern_atom(&pp);\n\t\tif (!h || pp != p->next)\n\t\t\tBUG(\"malformed header expr\");\n\t\tif (!header_group[p->field]) {\n\t\t\theader_group[p->field] = h;\n\t\t\tcontinue;\n\t\t}\n\t\theader_group[p->field] = grep_or_expr(h, header_group[p->field]);\n\t}\n\n\theader_expr = NULL;\n\n\tfor (fld = 0; fld < GREP_HEADER_FIELD_MAX; fld++) {\n\t\tif (!header_group[fld])\n\t\t\tcontinue;\n\t\tif (!header_expr)\n\t\t\theader_expr = grep_true_expr();\n\t\theader_expr = grep_or_expr(header_group[fld], header_expr);\n\t}\n\treturn header_expr;\n}\n\nstatic struct grep_expr *grep_splice_or(struct grep_expr *x, struct grep_expr *y)\n{\n\tstruct grep_expr *z = x;\n\n\twhile (x) {\n\t\tassert(x->node == GREP_NODE_OR);\n\t\tif (x->u.binary.right &&\n\t\t    x->u.binary.right->node == GREP_NODE_TRUE) {\n\t\t\tx->u.binary.right = y;\n\t\t\tbreak;\n\t\t}\n\t\tx = x->u.binary.right;\n\t}\n\treturn z;\n}\n\nvoid compile_grep_patterns(struct grep_opt *opt)\n{\n\tstruct grep_pat *p;\n\tstruct grep_expr *header_expr = prep_header_patterns(opt);\n\tint extended = 0;\n\n\tfor (p = opt->pattern_list; p; p = p->next) {\n\t\tswitch (p->token) {\n\t\tcase GREP_PATTERN: /* atom */\n\t\tcase GREP_PATTERN_HEAD:\n\t\tcase GREP_PATTERN_BODY:\n\t\t\tcompile_regexp(p, opt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\textended = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (opt->all_match || opt->no_body_match || header_expr)\n\t\textended = 1;\n\telse if (!extended)\n\t\treturn;\n\n\tp = opt->pattern_list;\n\tif (p)\n\t\topt->pattern_expression = compile_pattern_expr(&p);\n\tif (p)\n\t\tdie(\"incomplete pattern expression: %s\", p->pattern);\n\n\tif (opt->no_body_match && opt->pattern_expression)\n\t\topt->pattern_expression = grep_not_expr(opt->pattern_expression);\n\n\tif (!header_expr)\n\t\treturn;\n\n\tif (!opt->pattern_expression)\n\t\topt->pattern_expression = header_expr;\n\telse if (opt->all_match)\n\t\topt->pattern_expression = grep_splice_or(header_expr,\n\t\t\t\t\t\t\t opt->pattern_expression);\n\telse\n\t\topt->pattern_expression = grep_or_expr(opt->pattern_expression,\n\t\t\t\t\t\t       header_expr);\n\topt->all_match = 1;\n}\n\nstatic void free_pattern_expr(struct grep_expr *x)\n{\n\tswitch (x->node) {\n\tcase GREP_NODE_TRUE:\n\tcase GREP_NODE_ATOM:\n\t\tbreak;\n\tcase GREP_NODE_NOT:\n\t\tfree_pattern_expr(x->u.unary);\n\t\tbreak;\n\tcase GREP_NODE_AND:\n\tcase GREP_NODE_OR:\n\t\tfree_pattern_expr(x->u.binary.left);\n\t\tfree_pattern_expr(x->u.binary.right);\n\t\tbreak;\n\t}\n\tfree(x);\n}\n\nvoid free_grep_patterns(struct grep_opt *opt)\n{\n\tstruct grep_pat *p, *n;\n\n\tfor (p = opt->pattern_list; p; p = n) {\n\t\tn = p->next;\n\t\tswitch (p->token) {\n\t\tcase GREP_PATTERN: /* atom */\n\t\tcase GREP_PATTERN_HEAD:\n\t\tcase GREP_PATTERN_BODY:\n\t\t\tif (p->pcre2_pattern)\n\t\t\t\tfree_pcre2_pattern(p);\n\t\t\telse\n\t\t\t\tregfree(&p->regexp);\n\t\t\tfree(p->pattern);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tfree(p);\n\t}\n\n\tif (!opt->pattern_expression)\n\t\treturn;\n\tfree_pattern_expr(opt->pattern_expression);\n}\n\nstatic const char *end_of_line(const char *cp, unsigned long *left)\n{\n\tunsigned long l = *left;\n\twhile (l && *cp != '\\n') {\n\t\tl--;\n\t\tcp++;\n\t}\n\t*left = l;\n\treturn cp;\n}\n\nstatic int word_char(char ch)\n{\n\treturn isalnum(ch) || ch == '_';\n}\n\nstatic void output_color(struct grep_opt *opt, const void *data, size_t size,\n\t\t\t const char *color)\n{\n\tif (want_color(opt->color) && color && color[0]) {\n\t\topt->output(opt, color, strlen(color));\n\t\topt->output(opt, data, size);\n\t\topt->output(opt, GIT_COLOR_RESET, strlen(GIT_COLOR_RESET));\n\t} else\n\t\topt->output(opt, data, size);\n}\n\nstatic void output_sep(struct grep_opt *opt, char sign)\n{\n\tif (opt->null_following_name)\n\t\topt->output(opt, \"\\0\", 1);\n\telse\n\t\toutput_color(opt, &sign, 1, opt->colors[GREP_COLOR_SEP]);\n}\n\nstatic void show_name(struct grep_opt *opt, const char *name)\n{\n\toutput_color(opt, name, strlen(name), opt->colors[GREP_COLOR_FILENAME]);\n\topt->output(opt, opt->null_following_name ? \"\\0\" : \"\\n\", 1);\n}\n\nstatic int patmatch(struct grep_pat *p,\n\t\t    const char *line, const char *eol,\n\t\t    regmatch_t *match, int eflags)\n{\n\tint hit;\n\n\tif (p->pcre2_pattern)\n\t\thit = !pcre2match(p, line, eol, match, eflags);\n\telse\n\t\thit = !regexec_buf(&p->regexp, line, eol - line, 1, match,\n\t\t\t\t   eflags);\n\n\treturn hit;\n}\n\nstatic void strip_timestamp(const char *bol, const char **eol_p)\n{\n\tconst char *eol = *eol_p;\n\n\twhile (bol < --eol) {\n\t\tif (*eol != '>')\n\t\t\tcontinue;\n\t\t*eol_p = ++eol;\n\t\tbreak;\n\t}\n}\n\nstatic struct {\n\tconst char *field;\n\tsize_t len;\n} header_field[] = {\n\t{ \"author \", 7 },\n\t{ \"committer \", 10 },\n\t{ \"reflog \", 7 },\n};\n\nstatic int headerless_match_one_pattern(struct grep_pat *p,\n\t\t\t\t\tconst char *bol, const char *eol,\n\t\t\t\t\tenum grep_context ctx,\n\t\t\t\t\tregmatch_t *pmatch, int eflags)\n{\n\tint hit = 0;\n\tconst char *start = bol;\n\n\tif ((p->token != GREP_PATTERN) &&\n\t    ((p->token == GREP_PATTERN_HEAD) != (ctx == GREP_CONTEXT_HEAD)))\n\t\treturn 0;\n\n again:\n\thit = patmatch(p, bol, eol, pmatch, eflags);\n\n\tif (hit && p->word_regexp) {\n\t\tif ((pmatch[0].rm_so < 0) ||\n\t\t    (eol - bol) < pmatch[0].rm_so ||\n\t\t    (pmatch[0].rm_eo < 0) ||\n\t\t    (eol - bol) < pmatch[0].rm_eo)\n\t\t\tdie(\"regexp returned nonsense\");\n\n\t\t/* Match beginning must be either beginning of the\n\t\t * line, or at word boundary (i.e. the last char must\n\t\t * not be a word char).  Similarly, match end must be\n\t\t * either end of the line, or at word boundary\n\t\t * (i.e. the next char must not be a word char).\n\t\t */\n\t\tif ( ((pmatch[0].rm_so == 0) ||\n\t\t      !word_char(bol[pmatch[0].rm_so-1])) &&\n\t\t     ((pmatch[0].rm_eo == (eol-bol)) ||\n\t\t      !word_char(bol[pmatch[0].rm_eo])) )\n\t\t\t;\n\t\telse\n\t\t\thit = 0;\n\n\t\t/* Words consist of at least one character. */\n\t\tif (pmatch->rm_so == pmatch->rm_eo)\n\t\t\thit = 0;\n\n\t\tif (!hit && pmatch[0].rm_so + bol + 1 < eol) {\n\t\t\t/* There could be more than one match on the\n\t\t\t * line, and the first match might not be\n\t\t\t * strict word match.  But later ones could be!\n\t\t\t * Forward to the next possible start, i.e. the\n\t\t\t * next position following a non-word char.\n\t\t\t */\n\t\t\tbol = pmatch[0].rm_so + bol + 1;\n\t\t\twhile (word_char(bol[-1]) && bol < eol)\n\t\t\t\tbol++;\n\t\t\teflags |= REG_NOTBOL;\n\t\t\tif (bol < eol)\n\t\t\t\tgoto again;\n\t\t}\n\t}\n\tif (hit) {\n\t\tpmatch[0].rm_so += bol - start;\n\t\tpmatch[0].rm_eo += bol - start;\n\t}\n\treturn hit;\n}\n\nstatic int match_one_pattern(struct grep_pat *p,\n\t\t\t     const char *bol, const char *eol,\n\t\t\t     enum grep_context ctx, regmatch_t *pmatch,\n\t\t\t     int eflags)\n{\n\tconst char *field;\n\tsize_t len;\n\n\tif (p->token == GREP_PATTERN_HEAD) {\n\t\tassert(p->field < ARRAY_SIZE(header_field));\n\t\tfield = header_field[p->field].field;\n\t\tlen = header_field[p->field].len;\n\t\tif (strncmp(bol, field, len))\n\t\t\treturn 0;\n\t\tbol += len;\n\n\t\tswitch (p->field) {\n\t\tcase GREP_HEADER_AUTHOR:\n\t\tcase GREP_HEADER_COMMITTER:\n\t\t\tstrip_timestamp(bol, &eol);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn headerless_match_one_pattern(p, bol, eol, ctx, pmatch, eflags);\n}\n\n\nstatic int match_expr_eval(struct grep_opt *opt, struct grep_expr *x,\n\t\t\t   const char *bol, const char *eol,\n\t\t\t   enum grep_context ctx, ssize_t *col,\n\t\t\t   ssize_t *icol, int collect_hits)\n{\n\tint h = 0;\n\n\tswitch (x->node) {\n\tcase GREP_NODE_TRUE:\n\t\th = 1;\n\t\tbreak;\n\tcase GREP_NODE_ATOM:\n\t\t{\n\t\t\tregmatch_t tmp;\n\t\t\th = match_one_pattern(x->u.atom, bol, eol, ctx,\n\t\t\t\t\t      &tmp, 0);\n\t\t\tif (h && (*col < 0 || tmp.rm_so < *col))\n\t\t\t\t*col = tmp.rm_so;\n\t\t}\n\t\tif (x->u.atom->token == GREP_PATTERN_BODY)\n\t\t\topt->body_hit |= h;\n\t\tbreak;\n\tcase GREP_NODE_NOT:\n\t\t/*\n\t\t * Upon visiting a GREP_NODE_NOT, col and icol become swapped.\n\t\t */\n\t\th = !match_expr_eval(opt, x->u.unary, bol, eol, ctx, icol, col,\n\t\t\t\t     0);\n\t\tbreak;\n\tcase GREP_NODE_AND:\n\t\th = match_expr_eval(opt, x->u.binary.left, bol, eol, ctx, col,\n\t\t\t\t    icol, 0);\n\t\tif (h || opt->columnnum) {\n\t\t\t/*\n\t\t\t * Don't short-circuit AND when given --column, since a\n\t\t\t * NOT earlier in the tree may turn this into an OR. In\n\t\t\t * this case, see the below comment.\n\t\t\t */\n\t\t\th &= match_expr_eval(opt, x->u.binary.right, bol, eol,\n\t\t\t\t\t     ctx, col, icol, 0);\n\t\t}\n\t\tbreak;\n\tcase GREP_NODE_OR:\n\t\tif (!(collect_hits || opt->columnnum)) {\n\t\t\t/*\n\t\t\t * Don't short-circuit OR when given --column (or\n\t\t\t * collecting hits) to ensure we don't skip a later\n\t\t\t * child that would produce an earlier match.\n\t\t\t */\n\t\t\treturn (match_expr_eval(opt, x->u.binary.left, bol, eol,\n\t\t\t\t\t\tctx, col, icol, 0) ||\n\t\t\t\tmatch_expr_eval(opt, x->u.binary.right, bol,\n\t\t\t\t\t\teol, ctx, col, icol, 0));\n\t\t}\n\t\th = match_expr_eval(opt, x->u.binary.left, bol, eol, ctx, col,\n\t\t\t\t    icol, 0);\n\t\tif (collect_hits)\n\t\t\tx->u.binary.left->hit |= h;\n\t\th |= match_expr_eval(opt, x->u.binary.right, bol, eol, ctx, col,\n\t\t\t\t     icol, collect_hits);\n\t\tbreak;\n\tdefault:\n\t\tdie(\"Unexpected node type (internal error) %d\", x->node);\n\t}\n\tif (collect_hits)\n\t\tx->hit |= h;\n\treturn h;\n}\n\nstatic int match_expr(struct grep_opt *opt,\n\t\t      const char *bol, const char *eol,\n\t\t      enum grep_context ctx, ssize_t *col,\n\t\t      ssize_t *icol, int collect_hits)\n{\n\tstruct grep_expr *x = opt->pattern_expression;\n\treturn match_expr_eval(opt, x, bol, eol, ctx, col, icol, collect_hits);\n}\n\nstatic int match_line(struct grep_opt *opt,\n\t\t      const char *bol, const char *eol,\n\t\t      ssize_t *col, ssize_t *icol,\n\t\t      enum grep_context ctx, int collect_hits)\n{\n\tstruct grep_pat *p;\n\tint hit = 0;\n\n\tif (opt->pattern_expression)\n\t\treturn match_expr(opt, bol, eol, ctx, col, icol,\n\t\t\t\t  collect_hits);\n\n\t/* we do not call with collect_hits without being extended */\n\tfor (p = opt->pattern_list; p; p = p->next) {\n\t\tregmatch_t tmp;\n\t\tif (match_one_pattern(p, bol, eol, ctx, &tmp, 0)) {\n\t\t\thit |= 1;\n\t\t\tif (!opt->columnnum) {\n\t\t\t\t/*\n\t\t\t\t * Without --column, any single match on a line\n\t\t\t\t * is enough to know that it needs to be\n\t\t\t\t * printed. With --column, scan _all_ patterns\n\t\t\t\t * to find the earliest.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*col < 0 || tmp.rm_so < *col)\n\t\t\t\t*col = tmp.rm_so;\n\t\t}\n\t}\n\treturn hit;\n}\n\nstatic int match_next_pattern(struct grep_pat *p,\n\t\t\t      const char *bol, const char *eol,\n\t\t\t      enum grep_context ctx,\n\t\t\t      regmatch_t *pmatch, int eflags)\n{\n\tregmatch_t match;\n\n\tif (!headerless_match_one_pattern(p, bol, eol, ctx, &match, eflags))\n\t\treturn 0;\n\tif (match.rm_so < 0 || match.rm_eo < 0)\n\t\treturn 0;\n\tif (pmatch->rm_so >= 0 && pmatch->rm_eo >= 0) {\n\t\tif (match.rm_so > pmatch->rm_so)\n\t\t\treturn 1;\n\t\tif (match.rm_so == pmatch->rm_so && match.rm_eo < pmatch->rm_eo)\n\t\t\treturn 1;\n\t}\n\tpmatch->rm_so = match.rm_so;\n\tpmatch->rm_eo = match.rm_eo;\n\treturn 1;\n}\n\nint grep_next_match(struct grep_opt *opt,\n\t\t    const char *bol, const char *eol,\n\t\t    enum grep_context ctx, regmatch_t *pmatch,\n\t\t    enum grep_header_field field, int eflags)\n{\n\tstruct grep_pat *p;\n\tint hit = 0;\n\n\tpmatch->rm_so = pmatch->rm_eo = -1;\n\tif (bol < eol) {\n\t\tfor (p = ((ctx == GREP_CONTEXT_HEAD)\n\t\t\t   ? opt->header_list : opt->pattern_list);\n\t\t\t  p; p = p->next) {\n\t\t\tswitch (p->token) {\n\t\t\tcase GREP_PATTERN_HEAD:\n\t\t\t\tif ((field != GREP_HEADER_FIELD_MAX) &&\n\t\t\t\t    (p->field != field))\n\t\t\t\t\tcontinue;\n\t\t\t\t/* fall thru */\n\t\t\tcase GREP_PATTERN: /* atom */\n\t\t\tcase GREP_PATTERN_BODY:\n\t\t\t\thit |= match_next_pattern(p, bol, eol, ctx,\n\t\t\t\t\t\t\t  pmatch, eflags);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn hit;\n}\n\nstatic void show_line_header(struct grep_opt *opt, const char *name,\n\t\t\t     unsigned lno, ssize_t cno, char sign)\n{\n\tif (opt->heading && opt->last_shown == 0) {\n\t\toutput_color(opt, name, strlen(name), opt->colors[GREP_COLOR_FILENAME]);\n\t\topt->output(opt, \"\\n\", 1);\n\t}\n\topt->last_shown = lno;\n\n\tif (!opt->heading && opt->pathname) {\n\t\toutput_color(opt, name, strlen(name), opt->colors[GREP_COLOR_FILENAME]);\n\t\toutput_sep(opt, sign);\n\t}\n\tif (opt->linenum) {\n\t\tchar buf[32];\n\t\txsnprintf(buf, sizeof(buf), \"%d\", lno);\n\t\toutput_color(opt, buf, strlen(buf), opt->colors[GREP_COLOR_LINENO]);\n\t\toutput_sep(opt, sign);\n\t}\n\t/*\n\t * Treat 'cno' as the 1-indexed offset from the start of a non-context\n\t * line to its first match. Otherwise, 'cno' is 0 indicating that we are\n\t * being called with a context line.\n\t */\n\tif (opt->columnnum && cno) {\n\t\tchar buf[32];\n\t\txsnprintf(buf, sizeof(buf), \"%\"PRIuMAX, (uintmax_t)cno);\n\t\toutput_color(opt, buf, strlen(buf), opt->colors[GREP_COLOR_COLUMNNO]);\n\t\toutput_sep(opt, sign);\n\t}\n}\n\nstatic void show_line(struct grep_opt *opt,\n\t\t      const char *bol, const char *eol,\n\t\t      const char *name, unsigned lno, ssize_t cno, char sign)\n{\n\tint rest = eol - bol;\n\tconst char *match_color = NULL;\n\tconst char *line_color = NULL;\n\n\tif (opt->file_break && opt->last_shown == 0) {\n\t\tif (opt->show_hunk_mark)\n\t\t\topt->output(opt, \"\\n\", 1);\n\t} else if (opt->pre_context || opt->post_context || opt->funcbody) {\n\t\tif (opt->last_shown == 0) {\n\t\t\tif (opt->show_hunk_mark) {\n\t\t\t\toutput_color(opt, \"--\", 2, opt->colors[GREP_COLOR_SEP]);\n\t\t\t\topt->output(opt, \"\\n\", 1);\n\t\t\t}\n\t\t} else if (lno > opt->last_shown + 1) {\n\t\t\toutput_color(opt, \"--\", 2, opt->colors[GREP_COLOR_SEP]);\n\t\t\topt->output(opt, \"\\n\", 1);\n\t\t}\n\t}\n\tif (!opt->only_matching) {\n\t\t/*\n\t\t * In case the line we're being called with contains more than\n\t\t * one match, leave printing each header to the loop below.\n\t\t */\n\t\tshow_line_header(opt, name, lno, cno, sign);\n\t}\n\tif (opt->color || opt->only_matching) {\n\t\tregmatch_t match;\n\t\tenum grep_context ctx = GREP_CONTEXT_BODY;\n\t\tint eflags = 0;\n\n\t\tif (opt->color) {\n\t\t\tif (sign == ':')\n\t\t\t\tmatch_color = opt->colors[GREP_COLOR_MATCH_SELECTED];\n\t\t\telse\n\t\t\t\tmatch_color = opt->colors[GREP_COLOR_MATCH_CONTEXT];\n\t\t\tif (sign == ':')\n\t\t\t\tline_color = opt->colors[GREP_COLOR_SELECTED];\n\t\t\telse if (sign == '-')\n\t\t\t\tline_color = opt->colors[GREP_COLOR_CONTEXT];\n\t\t\telse if (sign == '=')\n\t\t\t\tline_color = opt->colors[GREP_COLOR_FUNCTION];\n\t\t}\n\t\twhile (grep_next_match(opt, bol, eol, ctx, &match,\n\t\t\t\t       GREP_HEADER_FIELD_MAX, eflags)) {\n\t\t\tif (match.rm_so == match.rm_eo)\n\t\t\t\tbreak;\n\n\t\t\tif (opt->only_matching)\n\t\t\t\tshow_line_header(opt, name, lno, cno, sign);\n\t\t\telse\n\t\t\t\toutput_color(opt, bol, match.rm_so, line_color);\n\t\t\toutput_color(opt, bol + match.rm_so,\n\t\t\t\t     match.rm_eo - match.rm_so, match_color);\n\t\t\tif (opt->only_matching)\n\t\t\t\topt->output(opt, \"\\n\", 1);\n\t\t\tbol += match.rm_eo;\n\t\t\tcno += match.rm_eo;\n\t\t\trest -= match.rm_eo;\n\t\t\teflags = REG_NOTBOL;\n\t\t}\n\t}\n\tif (!opt->only_matching) {\n\t\toutput_color(opt, bol, rest, line_color);\n\t\topt->output(opt, \"\\n\", 1);\n\t}\n}\n\nint grep_use_locks;\n\n/*\n * This lock protects access to the gitattributes machinery, which is\n * not thread-safe.\n */\npthread_mutex_t grep_attr_mutex;\n\nstatic inline void grep_attr_lock(void)\n{\n\tif (grep_use_locks)\n\t\tpthread_mutex_lock(&grep_attr_mutex);\n}\n\nstatic inline void grep_attr_unlock(void)\n{\n\tif (grep_use_locks)\n\t\tpthread_mutex_unlock(&grep_attr_mutex);\n}\n\nstatic int match_funcname(struct grep_opt *opt, struct grep_source *gs,\n\t\t\t  const char *bol, const char *eol)\n{\n\txdemitconf_t *xecfg = opt->priv;\n\tif (xecfg && !xecfg->find_func) {\n\t\tgrep_source_load_driver(gs, opt->repo->index);\n\t\tif (gs->driver->funcname.pattern) {\n\t\t\tconst struct userdiff_funcname *pe = &gs->driver->funcname;\n\t\t\txdiff_set_find_func(xecfg, pe->pattern, pe->cflags);\n\t\t} else {\n\t\t\txecfg = opt->priv = NULL;\n\t\t}\n\t}\n\n\tif (xecfg) {\n\t\tchar buf[1];\n\t\treturn xecfg->find_func(bol, eol - bol, buf, 1,\n\t\t\t\t\txecfg->find_func_priv) >= 0;\n\t}\n\n\tif (bol == eol)\n\t\treturn 0;\n\tif (isalpha(*bol) || *bol == '_' || *bol == '$')\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void show_funcname_line(struct grep_opt *opt, struct grep_source *gs,\n\t\t\t       const char *bol, unsigned lno)\n{\n\twhile (bol > gs->buf) {\n\t\tconst char *eol = --bol;\n\n\t\twhile (bol > gs->buf && bol[-1] != '\\n')\n\t\t\tbol--;\n\t\tlno--;\n\n\t\tif (lno <= opt->last_shown)\n\t\t\tbreak;\n\n\t\tif (match_funcname(opt, gs, bol, eol)) {\n\t\t\tshow_line(opt, bol, eol, gs->name, lno, 0, '=');\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int is_empty_line(const char *bol, const char *eol);\n\nstatic void show_pre_context(struct grep_opt *opt, struct grep_source *gs,\n\t\t\t     const char *bol, const char *end, unsigned lno)\n{\n\tunsigned cur = lno, from = 1, funcname_lno = 0, orig_from;\n\tint funcname_needed = !!opt->funcname, comment_needed = 0;\n\n\tif (opt->pre_context < lno)\n\t\tfrom = lno - opt->pre_context;\n\tif (from <= opt->last_shown)\n\t\tfrom = opt->last_shown + 1;\n\torig_from = from;\n\tif (opt->funcbody) {\n\t\tif (match_funcname(opt, gs, bol, end))\n\t\t\tcomment_needed = 1;\n\t\telse\n\t\t\tfuncname_needed = 1;\n\t\tfrom = opt->last_shown + 1;\n\t}\n\n\t/* Rewind. */\n\twhile (bol > gs->buf && cur > from) {\n\t\tconst char *next_bol = bol;\n\t\tconst char *eol = --bol;\n\n\t\twhile (bol > gs->buf && bol[-1] != '\\n')\n\t\t\tbol--;\n\t\tcur--;\n\t\tif (comment_needed && (is_empty_line(bol, eol) ||\n\t\t\t\t       match_funcname(opt, gs, bol, eol))) {\n\t\t\tcomment_needed = 0;\n\t\t\tfrom = orig_from;\n\t\t\tif (cur < from) {\n\t\t\t\tcur++;\n\t\t\t\tbol = next_bol;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (funcname_needed && match_funcname(opt, gs, bol, eol)) {\n\t\t\tfuncname_lno = cur;\n\t\t\tfuncname_needed = 0;\n\t\t\tif (opt->funcbody)\n\t\t\t\tcomment_needed = 1;\n\t\t\telse\n\t\t\t\tfrom = orig_from;\n\t\t}\n\t}\n\n\t/* We need to look even further back to find a function signature. */\n\tif (opt->funcname && funcname_needed)\n\t\tshow_funcname_line(opt, gs, bol, cur);\n\n\t/* Back forward. */\n\twhile (cur < lno) {\n\t\tconst char *eol = bol, sign = (cur == funcname_lno) ? '=' : '-';\n\n\t\twhile (*eol != '\\n')\n\t\t\teol++;\n\t\tshow_line(opt, bol, eol, gs->name, cur, 0, sign);\n\t\tbol = eol + 1;\n\t\tcur++;\n\t}\n}\n\nstatic int should_lookahead(struct grep_opt *opt)\n{\n\tstruct grep_pat *p;\n\n\tif (opt->pattern_expression)\n\t\treturn 0; /* punt for too complex stuff */\n\tif (opt->invert)\n\t\treturn 0;\n\tfor (p = opt->pattern_list; p; p = p->next) {\n\t\tif (p->token != GREP_PATTERN)\n\t\t\treturn 0; /* punt for \"header only\" and stuff */\n\t}\n\treturn 1;\n}\n\nstatic int look_ahead(struct grep_opt *opt,\n\t\t      unsigned long *left_p,\n\t\t      unsigned *lno_p,\n\t\t      const char **bol_p)\n{\n\tunsigned lno = *lno_p;\n\tconst char *bol = *bol_p;\n\tstruct grep_pat *p;\n\tconst char *sp, *last_bol;\n\tregoff_t earliest = -1;\n\n\tfor (p = opt->pattern_list; p; p = p->next) {\n\t\tint hit;\n\t\tregmatch_t m;\n\n\t\thit = patmatch(p, bol, bol + *left_p, &m, 0);\n\t\tif (!hit || m.rm_so < 0 || m.rm_eo < 0)\n\t\t\tcontinue;\n\t\tif (earliest < 0 || m.rm_so < earliest)\n\t\t\tearliest = m.rm_so;\n\t}\n\n\tif (earliest < 0) {\n\t\t*bol_p = bol + *left_p;\n\t\t*left_p = 0;\n\t\treturn 1;\n\t}\n\tfor (sp = bol + earliest; bol < sp && sp[-1] != '\\n'; sp--)\n\t\t; /* find the beginning of the line */\n\tlast_bol = sp;\n\n\tfor (sp = bol; sp < last_bol; sp++) {\n\t\tif (*sp == '\\n')\n\t\t\tlno++;\n\t}\n\t*left_p -= last_bol - bol;\n\t*bol_p = last_bol;\n\t*lno_p = lno;\n\treturn 0;\n}\n\nstatic int fill_textconv_grep(struct repository *r,\n\t\t\t      struct userdiff_driver *driver,\n\t\t\t      struct grep_source *gs)\n{\n\tstruct diff_filespec *df;\n\tchar *buf;\n\tsize_t size;\n\n\tif (!driver || !driver->textconv)\n\t\treturn grep_source_load(gs);\n\n\t/*\n\t * The textconv interface is intimately tied to diff_filespecs, so we\n\t * have to pretend to be one. If we could unify the grep_source\n\t * and diff_filespec structs, this mess could just go away.\n\t */\n\tdf = alloc_filespec(gs->path);\n\tswitch (gs->type) {\n\tcase GREP_SOURCE_OID:\n\t\tfill_filespec(df, gs->identifier, 1, 0100644);\n\t\tbreak;\n\tcase GREP_SOURCE_FILE:\n\t\tfill_filespec(df, null_oid(), 0, 0100644);\n\t\tbreak;\n\tdefault:\n\t\tBUG(\"attempt to textconv something without a path?\");\n\t}\n\n\t/*\n\t * fill_textconv is not remotely thread-safe; it modifies the global\n\t * diff tempfile structure, writes to the_repo's odb and might\n\t * internally call thread-unsafe functions such as the\n\t * prepare_packed_git() lazy-initializator. Because of the last two, we\n\t * must ensure mutual exclusion between this call and the object reading\n\t * API, thus we use obj_read_lock() here.\n\t *\n\t * TODO: allowing text conversion to run in parallel with object\n\t * reading operations might increase performance in the multithreaded\n\t * non-worktreee git-grep with --textconv.\n\t */\n\tobj_read_lock();\n\tsize = fill_textconv(r, driver, df, &buf);\n\tobj_read_unlock();\n\tfree_filespec(df);\n\n\t/*\n\t * The normal fill_textconv usage by the diff machinery would just keep\n\t * the textconv'd buf separate from the diff_filespec. But much of the\n\t * grep code passes around a grep_source and assumes that its \"buf\"\n\t * pointer is the beginning of the thing we are searching. So let's\n\t * install our textconv'd version into the grep_source, taking care not\n\t * to leak any existing buffer.\n\t */\n\tgrep_source_clear_data(gs);\n\tgs->buf = buf;\n\tgs->size = size;\n\n\treturn 0;\n}\n\nstatic int is_empty_line(const char *bol, const char *eol)\n{\n\twhile (bol < eol && isspace(*bol))\n\t\tbol++;\n\treturn bol == eol;\n}\n\nstatic int grep_source_1(struct grep_opt *opt, struct grep_source *gs, int collect_hits)\n{\n\tconst char *bol;\n\tconst char *peek_bol = NULL;\n\tunsigned long left;\n\tunsigned lno = 1;\n\tunsigned last_hit = 0;\n\tint binary_match_only = 0;\n\tunsigned count = 0;\n\tint try_lookahead = 0;\n\tint show_function = 0;\n\tstruct userdiff_driver *textconv = NULL;\n\tenum grep_context ctx = GREP_CONTEXT_HEAD;\n\txdemitconf_t xecfg;\n\n\tif (!opt->status_only && gs->name == NULL)\n\t\tBUG(\"grep call which could print a name requires \"\n\t\t    \"grep_source.name be non-NULL\");\n\n\tif (!opt->output)\n\t\topt->output = std_output;\n\n\tif (opt->pre_context || opt->post_context || opt->file_break ||\n\t    opt->funcbody) {\n\t\t/* Show hunk marks, except for the first file. */\n\t\tif (opt->last_shown)\n\t\t\topt->show_hunk_mark = 1;\n\t\t/*\n\t\t * If we're using threads then we can't easily identify\n\t\t * the first file.  Always put hunk marks in that case\n\t\t * and skip the very first one later in work_done().\n\t\t */\n\t\tif (opt->output != std_output)\n\t\t\topt->show_hunk_mark = 1;\n\t}\n\topt->last_shown = 0;\n\n\tif (opt->allow_textconv) {\n\t\tgrep_source_load_driver(gs, opt->repo->index);\n\t\t/*\n\t\t * We might set up the shared textconv cache data here, which\n\t\t * is not thread-safe. Also, get_oid_with_context() and\n\t\t * parse_object() might be internally called. As they are not\n\t\t * currently thread-safe and might be racy with object reading,\n\t\t * obj_read_lock() must be called.\n\t\t */\n\t\tgrep_attr_lock();\n\t\tobj_read_lock();\n\t\ttextconv = userdiff_get_textconv(opt->repo, gs->driver);\n\t\tobj_read_unlock();\n\t\tgrep_attr_unlock();\n\t}\n\n\t/*\n\t * We know the result of a textconv is text, so we only have to care\n\t * about binary handling if we are not using it.\n\t */\n\tif (!textconv) {\n\t\tswitch (opt->binary) {\n\t\tcase GREP_BINARY_DEFAULT:\n\t\t\tif (grep_source_is_binary(gs, opt->repo->index))\n\t\t\t\tbinary_match_only = 1;\n\t\t\tbreak;\n\t\tcase GREP_BINARY_NOMATCH:\n\t\t\tif (grep_source_is_binary(gs, opt->repo->index))\n\t\t\t\treturn 0; /* Assume unmatch */\n\t\t\tbreak;\n\t\tcase GREP_BINARY_TEXT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG(\"unknown binary handling mode\");\n\t\t}\n\t}\n\n\tmemset(&xecfg, 0, sizeof(xecfg));\n\topt->priv = &xecfg;\n\n\ttry_lookahead = should_lookahead(opt);\n\n\tif (fill_textconv_grep(opt->repo, textconv, gs) < 0)\n\t\treturn 0;\n\n\tbol = gs->buf;\n\tleft = gs->size;\n\twhile (left) {\n\t\tconst char *eol;\n\t\tint hit;\n\t\tssize_t cno;\n\t\tssize_t col = -1, icol = -1;\n\n\t\t/*\n\t\t * look_ahead() skips quickly to the line that possibly\n\t\t * has the next hit; don't call it if we need to do\n\t\t * something more than just skipping the current line\n\t\t * in response to an unmatch for the current line.  E.g.\n\t\t * inside a post-context window, we will show the current\n\t\t * line as a context around the previous hit when it\n\t\t * doesn't hit.\n\t\t */\n\t\tif (try_lookahead\n\t\t    && !(last_hit\n\t\t\t && (show_function ||\n\t\t\t     lno <= last_hit + opt->post_context))\n\t\t    && look_ahead(opt, &left, &lno, &bol))\n\t\t\tbreak;\n\t\teol = end_of_line(bol, &left);\n\n\t\tif ((ctx == GREP_CONTEXT_HEAD) && (eol == bol))\n\t\t\tctx = GREP_CONTEXT_BODY;\n\n\t\thit = match_line(opt, bol, eol, &col, &icol, ctx, collect_hits);\n\n\t\tif (collect_hits)\n\t\t\tgoto next_line;\n\n\t\t/* \"grep -v -e foo -e bla\" should list lines\n\t\t * that do not have either, so inversion should\n\t\t * be done outside.\n\t\t */\n\t\tif (opt->invert)\n\t\t\thit = !hit;\n\t\tif (opt->unmatch_name_only) {\n\t\t\tif (hit)\n\t\t\t\treturn 0;\n\t\t\tgoto next_line;\n\t\t}\n\t\tif (hit && (opt->max_count < 0 || count < opt->max_count)) {\n\t\t\tcount++;\n\t\t\tif (opt->status_only)\n\t\t\t\treturn 1;\n\t\t\tif (opt->name_only) {\n\t\t\t\tshow_name(opt, gs->name);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (opt->count)\n\t\t\t\tgoto next_line;\n\t\t\tif (binary_match_only) {\n\t\t\t\topt->output(opt, \"Binary file \", 12);\n\t\t\t\toutput_color(opt, gs->name, strlen(gs->name),\n\t\t\t\t\t     opt->colors[GREP_COLOR_FILENAME]);\n\t\t\t\topt->output(opt, \" matches\\n\", 9);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t/* Hit at this line.  If we haven't shown the\n\t\t\t * pre-context lines, we would need to show them.\n\t\t\t */\n\t\t\tif (opt->pre_context || opt->funcbody)\n\t\t\t\tshow_pre_context(opt, gs, bol, eol, lno);\n\t\t\telse if (opt->funcname)\n\t\t\t\tshow_funcname_line(opt, gs, bol, lno);\n\t\t\tcno = opt->invert ? icol : col;\n\t\t\tif (cno < 0) {\n\t\t\t\t/*\n\t\t\t\t * A negative cno indicates that there was no\n\t\t\t\t * match on the line. We are thus inverted and\n\t\t\t\t * being asked to show all lines that _don't_\n\t\t\t\t * match a given expression. Therefore, set cno\n\t\t\t\t * to 0 to suggest the whole line matches.\n\t\t\t\t */\n\t\t\t\tcno = 0;\n\t\t\t}\n\t\t\tshow_line(opt, bol, eol, gs->name, lno, cno + 1, ':');\n\t\t\tlast_hit = lno;\n\t\t\tif (opt->funcbody)\n\t\t\t\tshow_function = 1;\n\t\t\tgoto next_line;\n\t\t}\n\t\tif (show_function && (!peek_bol || peek_bol < bol)) {\n\t\t\tunsigned long peek_left = left;\n\t\t\tconst char *peek_eol = eol;\n\n\t\t\t/*\n\t\t\t * Trailing empty lines are not interesting.\n\t\t\t * Peek past them to see if they belong to the\n\t\t\t * body of the current function.\n\t\t\t */\n\t\t\tpeek_bol = bol;\n\t\t\twhile (is_empty_line(peek_bol, peek_eol)) {\n\t\t\t\tpeek_bol = peek_eol + 1;\n\t\t\t\tpeek_eol = end_of_line(peek_bol, &peek_left);\n\t\t\t}\n\n\t\t\tif (match_funcname(opt, gs, peek_bol, peek_eol))\n\t\t\t\tshow_function = 0;\n\t\t}\n\t\tif (show_function ||\n\t\t    (last_hit && lno <= last_hit + opt->post_context)) {\n\t\t\t/* If the last hit is within the post context,\n\t\t\t * we need to show this line.\n\t\t\t */\n\t\t\tshow_line(opt, bol, eol, gs->name, lno, col + 1, '-');\n\t\t}\n\n\tnext_line:\n\t\tbol = eol + 1;\n\t\tif (!left)\n\t\t\tbreak;\n\t\tleft--;\n\t\tlno++;\n\t}\n\n\tif (collect_hits)\n\t\treturn 0;\n\n\tif (opt->status_only)\n\t\treturn opt->unmatch_name_only;\n\tif (opt->unmatch_name_only) {\n\t\t/* We did not see any hit, so we want to show this */\n\t\tshow_name(opt, gs->name);\n\t\treturn 1;\n\t}\n\n\txdiff_clear_find_func(&xecfg);\n\topt->priv = NULL;\n\n\t/* NEEDSWORK:\n\t * The real \"grep -c foo *.c\" gives many \"bar.c:0\" lines,\n\t * which feels mostly useless but sometimes useful.  Maybe\n\t * make it another option?  For now suppress them.\n\t */\n\tif (opt->count && count) {\n\t\tchar buf[32];\n\t\tif (opt->pathname) {\n\t\t\toutput_color(opt, gs->name, strlen(gs->name),\n\t\t\t\t     opt->colors[GREP_COLOR_FILENAME]);\n\t\t\toutput_sep(opt, ':');\n\t\t}\n\t\txsnprintf(buf, sizeof(buf), \"%u\\n\", count);\n\t\topt->output(opt, buf, strlen(buf));\n\t\treturn 1;\n\t}\n\treturn !!last_hit;\n}\n\nstatic void clr_hit_marker(struct grep_expr *x)\n{\n\t/* All-hit markers are meaningful only at the very top level\n\t * OR node.\n\t */\n\twhile (1) {\n\t\tx->hit = 0;\n\t\tif (x->node != GREP_NODE_OR)\n\t\t\treturn;\n\t\tx->u.binary.left->hit = 0;\n\t\tx = x->u.binary.right;\n\t}\n}\n\nstatic int chk_hit_marker(struct grep_expr *x)\n{\n\t/* Top level nodes have hit markers.  See if they all are hits */\n\twhile (1) {\n\t\tif (x->node != GREP_NODE_OR)\n\t\t\treturn x->hit;\n\t\tif (!x->u.binary.left->hit)\n\t\t\treturn 0;\n\t\tx = x->u.binary.right;\n\t}\n}\n\nint grep_source(struct grep_opt *opt, struct grep_source *gs)\n{\n\t/*\n\t * we do not have to do the two-pass grep when we do not check\n\t * buffer-wide \"all-match\".\n\t */\n\tif (!opt->all_match && !opt->no_body_match)\n\t\treturn grep_source_1(opt, gs, 0);\n\n\t/* Otherwise the toplevel \"or\" terms hit a bit differently.\n\t * We first clear hit markers from them.\n\t */\n\tclr_hit_marker(opt->pattern_expression);\n\topt->body_hit = 0;\n\tgrep_source_1(opt, gs, 1);\n\n\tif (opt->all_match && !chk_hit_marker(opt->pattern_expression))\n\t\treturn 0;\n\tif (opt->no_body_match && opt->body_hit)\n\t\treturn 0;\n\n\treturn grep_source_1(opt, gs, 0);\n}\n\nstatic void grep_source_init_buf(struct grep_source *gs,\n\t\t\t\t const char *buf,\n\t\t\t\t unsigned long size)\n{\n\tgs->type = GREP_SOURCE_BUF;\n\tgs->name = NULL;\n\tgs->path = NULL;\n\tgs->buf = buf;\n\tgs->size = size;\n\tgs->driver = NULL;\n\tgs->identifier = NULL;\n}\n\nint grep_buffer(struct grep_opt *opt, const char *buf, unsigned long size)\n{\n\tstruct grep_source gs;\n\tint r;\n\n\tgrep_source_init_buf(&gs, buf, size);\n\n\tr = grep_source(opt, &gs);\n\n\tgrep_source_clear(&gs);\n\treturn r;\n}\n\nvoid grep_source_init_file(struct grep_source *gs, const char *name,\n\t\t\t   const char *path)\n{\n\tgs->type = GREP_SOURCE_FILE;\n\tgs->name = xstrdup_or_null(name);\n\tgs->path = xstrdup_or_null(path);\n\tgs->buf = NULL;\n\tgs->size = 0;\n\tgs->driver = NULL;\n\tgs->identifier = xstrdup(path);\n}\n\nvoid grep_source_init_oid(struct grep_source *gs, const char *name,\n\t\t\t  const char *path, const struct object_id *oid,\n\t\t\t  struct repository *repo)\n{\n\tgs->type = GREP_SOURCE_OID;\n\tgs->name = xstrdup_or_null(name);\n\tgs->path = xstrdup_or_null(path);\n\tgs->buf = NULL;\n\tgs->size = 0;\n\tgs->driver = NULL;\n\tgs->identifier = oiddup(oid);\n\tgs->repo = repo;\n}\n\nvoid grep_source_clear(struct grep_source *gs)\n{\n\tFREE_AND_NULL(gs->name);\n\tFREE_AND_NULL(gs->path);\n\tFREE_AND_NULL(gs->identifier);\n\tgrep_source_clear_data(gs);\n}\n\nvoid grep_source_clear_data(struct grep_source *gs)\n{\n\tswitch (gs->type) {\n\tcase GREP_SOURCE_FILE:\n\tcase GREP_SOURCE_OID:\n\t\t/* these types own the buffer */\n\t\tfree((char *)gs->buf);\n\t\tgs->buf = NULL;\n\t\tgs->size = 0;\n\t\tbreak;\n\tcase GREP_SOURCE_BUF:\n\t\t/* leave user-provided buf intact */\n\t\tbreak;\n\t}\n}\n\nstatic int grep_source_load_oid(struct grep_source *gs)\n{\n\tenum object_type type;\n\n\tgs->buf = repo_read_object_file(gs->repo, gs->identifier, &type,\n\t\t\t\t\t&gs->size);\n\tif (!gs->buf)\n\t\treturn error(_(\"'%s': unable to read %s\"),\n\t\t\t     gs->name,\n\t\t\t     oid_to_hex(gs->identifier));\n\treturn 0;\n}\n\nstatic int grep_source_load_file(struct grep_source *gs)\n{\n\tconst char *filename = gs->identifier;\n\tstruct stat st;\n\tchar *data;\n\tsize_t size;\n\tint i;\n\n\tif (lstat(filename, &st) < 0) {\n\terr_ret:\n\t\tif (errno != ENOENT)\n\t\t\terror_errno(_(\"failed to stat '%s'\"), filename);\n\t\treturn -1;\n\t}\n\tif (!S_ISREG(st.st_mode))\n\t\treturn -1;\n\tsize = xsize_t(st.st_size);\n\ti = open(filename, O_RDONLY);\n\tif (i < 0)\n\t\tgoto err_ret;\n\tdata = xmallocz(size);\n\tif (st.st_size != read_in_full(i, data, size)) {\n\t\terror_errno(_(\"'%s': short read\"), filename);\n\t\tclose(i);\n\t\tfree(data);\n\t\treturn -1;\n\t}\n\tclose(i);\n\n\tgs->buf = data;\n\tgs->size = size;\n\treturn 0;\n}\n\nstatic int grep_source_load(struct grep_source *gs)\n{\n\tif (gs->buf)\n\t\treturn 0;\n\n\tswitch (gs->type) {\n\tcase GREP_SOURCE_FILE:\n\t\treturn grep_source_load_file(gs);\n\tcase GREP_SOURCE_OID:\n\t\treturn grep_source_load_oid(gs);\n\tcase GREP_SOURCE_BUF:\n\t\treturn gs->buf ? 0 : -1;\n\t}\n\tBUG(\"invalid grep_source type to load\");\n}\n\nvoid grep_source_load_driver(struct grep_source *gs,\n\t\t\t     struct index_state *istate)\n{\n\tif (gs->driver)\n\t\treturn;\n\n\tgrep_attr_lock();\n\tif (gs->path)\n\t\tgs->driver = userdiff_find_by_path(istate, gs->path);\n\tif (!gs->driver)\n\t\tgs->driver = userdiff_find_by_name(\"default\");\n\tgrep_attr_unlock();\n}\n\nstatic int grep_source_is_binary(struct grep_source *gs,\n\t\t\t\t struct index_state *istate)\n{\n\tgrep_source_load_driver(gs, istate);\n\tif (gs->driver->binary != -1)\n\t\treturn gs->driver->binary;\n\n\tif (!grep_source_load(gs))\n\t\treturn buffer_is_binary(gs->buf, gs->size);\n\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00b3cf0e1872f6dabe6428b3283540b63b7ef939",
  "sha1_ok": true,
  "size": 48677
}
