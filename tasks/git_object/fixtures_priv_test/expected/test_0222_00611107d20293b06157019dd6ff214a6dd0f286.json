{
  "content": {
    "base64": "I2RlZmluZSBVU0VfVEhFX1JFUE9TSVRPUllfVkFSSUFCTEUKCiNpbmNsdWRlICJnaXQtY29tcGF0LXV0aWwuaCIKI2luY2x1ZGUgImNvbmZpZy5oIgojaW5jbHVkZSAiZ2V0dGV4dC5oIgojaW5jbHVkZSAibGlzdC1vYmplY3RzLWZpbHRlci1vcHRpb25zLmgiCiNpbmNsdWRlICJwcm9taXNvci1yZW1vdGUuaCIKI2luY2x1ZGUgInRyYWNlLmgiCiNpbmNsdWRlICJ1cmwuaCIKI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCIKCnN0YXRpYyBpbnQgcGFyc2VfY29tYmluZV9maWx0ZXIoCglzdHJ1Y3QgbGlzdF9vYmplY3RzX2ZpbHRlcl9vcHRpb25zICpmaWx0ZXJfb3B0aW9ucywKCWNvbnN0IGNoYXIgKmFyZywKCXN0cnVjdCBzdHJidWYgKmVycmJ1Zik7Cgpjb25zdCBjaGFyICpsaXN0X29iamVjdF9maWx0ZXJfY29uZmlnX25hbWUoZW51bSBsaXN0X29iamVjdHNfZmlsdGVyX2Nob2ljZSBjKQp7Cglzd2l0Y2ggKGMpIHsKCWNhc2UgTE9GQ19ESVNBQkxFRDoKCQkvKiB3ZSBoYXZlIG5vIG5hbWUgZm9yICJubyBmaWx0ZXIgYXQgYWxsIiAqLwoJCWJyZWFrOwoJY2FzZSBMT0ZDX0JMT0JfTk9ORToKCQlyZXR1cm4gImJsb2I6bm9uZSI7CgljYXNlIExPRkNfQkxPQl9MSU1JVDoKCQlyZXR1cm4gImJsb2I6bGltaXQiOwoJY2FzZSBMT0ZDX1RSRUVfREVQVEg6CgkJcmV0dXJuICJ0cmVlIjsKCWNhc2UgTE9GQ19TUEFSU0VfT0lEOgoJCXJldHVybiAic3BhcnNlOm9pZCI7CgljYXNlIExPRkNfT0JKRUNUX1RZUEU6CgkJcmV0dXJuICJvYmplY3Q6dHlwZSI7CgljYXNlIExPRkNfQ09NQklORToKCQlyZXR1cm4gImNvbWJpbmUiOwoJY2FzZSBMT0ZDX19DT1VOVDoKCQkvKiBub3QgYSByZWFsIGZpbHRlciB0eXBlOyBqdXN0IHRoZSBjb3VudCBvZiBhbGwgZmlsdGVycyAqLwoJCWJyZWFrOwoJfQoJQlVHKCJsaXN0X29iamVjdF9maWx0ZXJfY29uZmlnX25hbWU6IGludmFsaWQgYXJndW1lbnQgJyVkJyIsIGMpOwp9CgppbnQgZ2VudGx5X3BhcnNlX2xpc3Rfb2JqZWN0c19maWx0ZXIoCglzdHJ1Y3QgbGlzdF9vYmplY3RzX2ZpbHRlcl9vcHRpb25zICpmaWx0ZXJfb3B0aW9ucywKCWNvbnN0IGNoYXIgKmFyZywKCXN0cnVjdCBzdHJidWYgKmVycmJ1ZikKewoJY29uc3QgY2hhciAqdjA7CgoJaWYgKCFhcmcpCgkJcmV0dXJuIDA7CgoJaWYgKGZpbHRlcl9vcHRpb25zLT5jaG9pY2UpCgkJQlVHKCJmaWx0ZXJfb3B0aW9ucyBhbHJlYWR5IHBvcHVsYXRlZCIpOwoKCWlmICghc3RyY21wKGFyZywgImJsb2I6bm9uZSIpKSB7CgkJZmlsdGVyX29wdGlvbnMtPmNob2ljZSA9IExPRkNfQkxPQl9OT05FOwoJCXJldHVybiAwOwoKCX0gZWxzZSBpZiAoc2tpcF9wcmVmaXgoYXJnLCAiYmxvYjpsaW1pdD0iLCAmdjApKSB7CgkJaWYgKGdpdF9wYXJzZV91bG9uZyh2MCwgJmZpbHRlcl9vcHRpb25zLT5ibG9iX2xpbWl0X3ZhbHVlKSkgewoJCQlmaWx0ZXJfb3B0aW9ucy0+Y2hvaWNlID0gTE9GQ19CTE9CX0xJTUlUOwoJCQlyZXR1cm4gMDsKCQl9CgoJfSBlbHNlIGlmIChza2lwX3ByZWZpeChhcmcsICJ0cmVlOiIsICZ2MCkpIHsKCQlpZiAoIWdpdF9wYXJzZV91bG9uZyh2MCwgJmZpbHRlcl9vcHRpb25zLT50cmVlX2V4Y2x1ZGVfZGVwdGgpKSB7CgkJCXN0cmJ1Zl9hZGRzdHIoZXJyYnVmLCBfKCJleHBlY3RlZCAndHJlZTo8ZGVwdGg+JyIpKTsKCQkJcmV0dXJuIDE7CgkJfQoJCWZpbHRlcl9vcHRpb25zLT5jaG9pY2UgPSBMT0ZDX1RSRUVfREVQVEg7CgkJcmV0dXJuIDA7CgoJfSBlbHNlIGlmIChza2lwX3ByZWZpeChhcmcsICJzcGFyc2U6b2lkPSIsICZ2MCkpIHsKCQlmaWx0ZXJfb3B0aW9ucy0+c3BhcnNlX29pZF9uYW1lID0geHN0cmR1cCh2MCk7CgkJZmlsdGVyX29wdGlvbnMtPmNob2ljZSA9IExPRkNfU1BBUlNFX09JRDsKCQlyZXR1cm4gMDsKCgl9IGVsc2UgaWYgKHNraXBfcHJlZml4KGFyZywgInNwYXJzZTpwYXRoPSIsICZ2MCkpIHsKCQlpZiAoZXJyYnVmKSB7CgkJCXN0cmJ1Zl9hZGRzdHIoCgkJCQllcnJidWYsCgkJCQlfKCJzcGFyc2U6cGF0aCBmaWx0ZXJzIHN1cHBvcnQgaGFzIGJlZW4gZHJvcHBlZCIpKTsKCQl9CgkJcmV0dXJuIDE7CgoJfSBlbHNlIGlmIChza2lwX3ByZWZpeChhcmcsICJvYmplY3Q6dHlwZT0iLCAmdjApKSB7CgkJaW50IHR5cGUgPSB0eXBlX2Zyb21fc3RyaW5nX2dlbnRseSh2MCwgc3RybGVuKHYwKSwgMSk7CgkJaWYgKHR5cGUgPCAwKSB7CgkJCXN0cmJ1Zl9hZGRmKGVycmJ1ZiwgXygiJyVzJyBmb3IgJ29iamVjdDp0eXBlPTx0eXBlPicgaXMgIgoJCQkJCSAgICAgICJub3QgYSB2YWxpZCBvYmplY3QgdHlwZSIpLCB2MCk7CgkJCXJldHVybiAxOwoJCX0KCgkJZmlsdGVyX29wdGlvbnMtPm9iamVjdF90eXBlID0gdHlwZTsKCQlmaWx0ZXJfb3B0aW9ucy0+Y2hvaWNlID0gTE9GQ19PQkpFQ1RfVFlQRTsKCgkJcmV0dXJuIDA7CgoJfSBlbHNlIGlmIChza2lwX3ByZWZpeChhcmcsICJjb21iaW5lOiIsICZ2MCkpIHsKCQlyZXR1cm4gcGFyc2VfY29tYmluZV9maWx0ZXIoZmlsdGVyX29wdGlvbnMsIHYwLCBlcnJidWYpOwoKCX0KCS8qCgkgKiBQbGVhc2UgdXBkYXRlIF9naXRfZmV0Y2goKSBpbiBnaXQtY29tcGxldGlvbi5iYXNoIHdoZW4geW91CgkgKiBhZGQgbmV3IGZpbHRlcnMKCSAqLwoKCXN0cmJ1Zl9hZGRmKGVycmJ1ZiwgXygiaW52YWxpZCBmaWx0ZXItc3BlYyAnJXMnIiksIGFyZyk7CgoJbGlzdF9vYmplY3RzX2ZpbHRlcl9pbml0KGZpbHRlcl9vcHRpb25zKTsKCXJldHVybiAxOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqUkVTRVJWRURfTk9OX1dTID0gIn5gIUAjJF4mKigpW117fVxcOydcIiw8Pj8iOwoKc3RhdGljIGludCBoYXNfcmVzZXJ2ZWRfY2hhcmFjdGVyKAoJc3RydWN0IHN0cmJ1ZiAqc3ViX3NwZWMsIHN0cnVjdCBzdHJidWYgKmVycmJ1ZikKewoJY29uc3QgY2hhciAqYyA9IHN1Yl9zcGVjLT5idWY7Cgl3aGlsZSAoKmMpIHsKCQlpZiAoKmMgPD0gJyAnIHx8IHN0cmNocihSRVNFUlZFRF9OT05fV1MsICpjKSkgewoJCQlzdHJidWZfYWRkZigKCQkJCWVycmJ1ZiwKCQkJCV8oIm11c3QgZXNjYXBlIGNoYXIgaW4gc3ViLWZpbHRlci1zcGVjOiAnJWMnIiksCgkJCQkqYyk7CgkJCXJldHVybiAxOwoJCX0KCQljKys7Cgl9CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgcGFyc2VfY29tYmluZV9zdWJmaWx0ZXIoCglzdHJ1Y3QgbGlzdF9vYmplY3RzX2ZpbHRlcl9vcHRpb25zICpmaWx0ZXJfb3B0aW9ucywKCXN0cnVjdCBzdHJidWYgKnN1YnNwZWMsCglzdHJ1Y3Qgc3RyYnVmICplcnJidWYpCnsKCXNpemVfdCBuZXdfaW5kZXggPSBmaWx0ZXJfb3B0aW9ucy0+c3ViX25yOwoJY2hhciAqZGVjb2RlZDsKCWludCByZXN1bHQ7CgoJQUxMT0NfR1JPV19CWShmaWx0ZXJfb3B0aW9ucy0+c3ViLCBmaWx0ZXJfb3B0aW9ucy0+c3ViX25yLCAxLAoJCSAgICAgIGZpbHRlcl9vcHRpb25zLT5zdWJfYWxsb2MpOwoJbGlzdF9vYmplY3RzX2ZpbHRlcl9pbml0KCZmaWx0ZXJfb3B0aW9ucy0+c3ViW25ld19pbmRleF0pOwoKCWRlY29kZWQgPSB1cmxfcGVyY2VudF9kZWNvZGUoc3Vic3BlYy0+YnVmKTsKCglyZXN1bHQgPSBoYXNfcmVzZXJ2ZWRfY2hhcmFjdGVyKHN1YnNwZWMsIGVycmJ1ZikgfHwKCQlnZW50bHlfcGFyc2VfbGlzdF9vYmplY3RzX2ZpbHRlcigKCQkJJmZpbHRlcl9vcHRpb25zLT5zdWJbbmV3X2luZGV4XSwgZGVjb2RlZCwgZXJyYnVmKTsKCglmcmVlKGRlY29kZWQpOwoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIGludCBwYXJzZV9jb21iaW5lX2ZpbHRlcigKCXN0cnVjdCBsaXN0X29iamVjdHNfZmlsdGVyX29wdGlvbnMgKmZpbHRlcl9vcHRpb25zLAoJY29uc3QgY2hhciAqYXJnLAoJc3RydWN0IHN0cmJ1ZiAqZXJyYnVmKQp7CglzdHJ1Y3Qgc3RyYnVmICoqc3Vic3BlY3MgPSBzdHJidWZfc3BsaXRfc3RyKGFyZywgJysnLCAwKTsKCXNpemVfdCBzdWI7CglpbnQgcmVzdWx0ID0gMDsKCglpZiAoIXN1YnNwZWNzWzBdKSB7CgkJc3RyYnVmX2FkZHN0cihlcnJidWYsIF8oImV4cGVjdGVkIHNvbWV0aGluZyBhZnRlciBjb21iaW5lOiIpKTsKCQlyZXN1bHQgPSAxOwoJCWdvdG8gY2xlYW51cDsKCX0KCglmb3IgKHN1YiA9IDA7IHN1YnNwZWNzW3N1Yl0gJiYgIXJlc3VsdDsgc3ViKyspIHsKCQlpZiAoc3Vic3BlY3Nbc3ViICsgMV0pIHsKCQkJLyoKCQkJICogVGhpcyBpcyBub3QgdGhlIGxhc3Qgc3Vic3BlYy4gUmVtb3ZlIHRyYWlsaW5nICIrIiBzbwoJCQkgKiB3ZSBjYW4gcGFyc2UgaXQuCgkJCSAqLwoJCQlzaXplX3QgbGFzdCA9IHN1YnNwZWNzW3N1Yl0tPmxlbiAtIDE7CgkJCWFzc2VydChzdWJzcGVjc1tzdWJdLT5idWZbbGFzdF0gPT0gJysnKTsKCQkJc3RyYnVmX3JlbW92ZShzdWJzcGVjc1tzdWJdLCBsYXN0LCAxKTsKCQl9CgkJcmVzdWx0ID0gcGFyc2VfY29tYmluZV9zdWJmaWx0ZXIoCgkJCWZpbHRlcl9vcHRpb25zLCBzdWJzcGVjc1tzdWJdLCBlcnJidWYpOwoJfQoKCWZpbHRlcl9vcHRpb25zLT5jaG9pY2UgPSBMT0ZDX0NPTUJJTkU7CgpjbGVhbnVwOgoJc3RyYnVmX2xpc3RfZnJlZShzdWJzcGVjcyk7CglpZiAocmVzdWx0KQoJCWxpc3Rfb2JqZWN0c19maWx0ZXJfcmVsZWFzZShmaWx0ZXJfb3B0aW9ucyk7CglyZXR1cm4gcmVzdWx0Owp9CgpzdGF0aWMgaW50IGFsbG93X3VuZW5jb2RlZChjaGFyIGNoKQp7CglpZiAoY2ggPD0gJyAnIHx8IGNoID09ICclJyB8fCBjaCA9PSAnKycpCgkJcmV0dXJuIDA7CglyZXR1cm4gIXN0cmNocihSRVNFUlZFRF9OT05fV1MsIGNoKTsKfQoKc3RhdGljIHZvaWQgZmlsdGVyX3NwZWNfYXBwZW5kX3VybGVuY29kZSgKCXN0cnVjdCBsaXN0X29iamVjdHNfZmlsdGVyX29wdGlvbnMgKmZpbHRlciwgY29uc3QgY2hhciAqcmF3KQp7CglzaXplX3Qgb3JpZ19sZW4gPSBmaWx0ZXItPmZpbHRlcl9zcGVjLmxlbjsKCXN0cmJ1Zl9hZGRzdHJfdXJsZW5jb2RlKCZmaWx0ZXItPmZpbHRlcl9zcGVjLCByYXcsIGFsbG93X3VuZW5jb2RlZCk7Cgl0cmFjZV9wcmludGYoIkFkZCB0byBjb21iaW5lIGZpbHRlci1zcGVjOiAlc1xuIiwKCQkgICAgIGZpbHRlci0+ZmlsdGVyX3NwZWMuYnVmICsgb3JpZ19sZW4pOwp9CgovKgogKiBDaGFuZ2VzIGZpbHRlcl9vcHRpb25zIGludG8gYW4gZXF1aXZhbGVudCBMT0ZDX0NPTUJJTkUgZmlsdGVyIG9wdGlvbnMKICogaW5zdGFuY2UuIERvZXMgbm90IGRvIGFueXRoaW5nIGlmIGZpbHRlcl9vcHRpb25zIGlzIGFscmVhZHkgTE9GQ19DT01CSU5FLgogKi8Kc3RhdGljIHZvaWQgdHJhbnNmb3JtX3RvX2NvbWJpbmVfdHlwZSgKCXN0cnVjdCBsaXN0X29iamVjdHNfZmlsdGVyX29wdGlvbnMgKmZpbHRlcl9vcHRpb25zKQp7Cglhc3NlcnQoZmlsdGVyX29wdGlvbnMtPmNob2ljZSk7CglpZiAoZmlsdGVyX29wdGlvbnMtPmNob2ljZSA9PSBMT0ZDX0NPTUJJTkUpCgkJcmV0dXJuOwoJewoJCWNvbnN0IGludCBpbml0aWFsX3N1Yl9hbGxvYyA9IDI7CgkJc3RydWN0IGxpc3Rfb2JqZWN0c19maWx0ZXJfb3B0aW9ucyAqc3ViX2FycmF5ID0KCQkJeGNhbGxvYyhpbml0aWFsX3N1Yl9hbGxvYywgc2l6ZW9mKCpzdWJfYXJyYXkpKTsKCQlzdWJfYXJyYXlbMF0gPSAqZmlsdGVyX29wdGlvbnM7CgkJbGlzdF9vYmplY3RzX2ZpbHRlcl9pbml0KGZpbHRlcl9vcHRpb25zKTsKCQlmaWx0ZXJfb3B0aW9ucy0+c3ViID0gc3ViX2FycmF5OwoJCWZpbHRlcl9vcHRpb25zLT5zdWJfYWxsb2MgPSBpbml0aWFsX3N1Yl9hbGxvYzsKCX0KCWZpbHRlcl9vcHRpb25zLT5zdWJfbnIgPSAxOwoJZmlsdGVyX29wdGlvbnMtPmNob2ljZSA9IExPRkNfQ09NQklORTsKCXN0cmJ1Zl9hZGRzdHIoJmZpbHRlcl9vcHRpb25zLT5maWx0ZXJfc3BlYywgImNvbWJpbmU6Iik7CglmaWx0ZXJfc3BlY19hcHBlbmRfdXJsZW5jb2RlKAoJCWZpbHRlcl9vcHRpb25zLAoJCWxpc3Rfb2JqZWN0c19maWx0ZXJfc3BlYygmZmlsdGVyX29wdGlvbnMtPnN1YlswXSkpOwoJLyoKCSAqIFdlIGRvbid0IG5lZWQgdGhlIGZpbHRlcl9zcGVjIHN0cmluZ3MgZm9yIHN1YmZpbHRlciBzcGVjcywgb25seSB0aGUKCSAqIHRvcCBsZXZlbC4KCSAqLwoJc3RyYnVmX3JlbGVhc2UoJmZpbHRlcl9vcHRpb25zLT5zdWJbMF0uZmlsdGVyX3NwZWMpOwp9Cgp2b2lkIGxpc3Rfb2JqZWN0c19maWx0ZXJfZGllX2lmX3BvcHVsYXRlZCgKCXN0cnVjdCBsaXN0X29iamVjdHNfZmlsdGVyX29wdGlvbnMgKmZpbHRlcl9vcHRpb25zKQp7CglpZiAoZmlsdGVyX29wdGlvbnMtPmNob2ljZSkKCQlkaWUoXygibXVsdGlwbGUgZmlsdGVyLXNwZWNzIGNhbm5vdCBiZSBjb21iaW5lZCIpKTsKfQoKdm9pZCBwYXJzZV9saXN0X29iamVjdHNfZmlsdGVyKAoJc3RydWN0IGxpc3Rfb2JqZWN0c19maWx0ZXJfb3B0aW9ucyAqZmlsdGVyX29wdGlvbnMsCgljb25zdCBjaGFyICphcmcpCnsKCXN0cnVjdCBzdHJidWYgZXJyYnVmID0gU1RSQlVGX0lOSVQ7CglpbnQgcGFyc2VfZXJyb3I7CgoJaWYgKCFmaWx0ZXJfb3B0aW9ucy0+ZmlsdGVyX3NwZWMuYnVmKQoJCUJVRygiZmlsdGVyX29wdGlvbnMgbm90IHByb3Blcmx5IGluaXRpYWxpemVkIik7CgoJaWYgKCFmaWx0ZXJfb3B0aW9ucy0+Y2hvaWNlKSB7CgkJc3RyYnVmX2FkZHN0cigmZmlsdGVyX29wdGlvbnMtPmZpbHRlcl9zcGVjLCBhcmcpOwoKCQlwYXJzZV9lcnJvciA9IGdlbnRseV9wYXJzZV9saXN0X29iamVjdHNfZmlsdGVyKAoJCQlmaWx0ZXJfb3B0aW9ucywgYXJnLCAmZXJyYnVmKTsKCX0gZWxzZSB7CgkJc3RydWN0IGxpc3Rfb2JqZWN0c19maWx0ZXJfb3B0aW9ucyAqc3ViOwoKCQkvKgoJCSAqIE1ha2UgZmlsdGVyX29wdGlvbnMgYW4gTE9GQ19DT01CSU5FIHNwZWMgc28gd2UgY2FuIHRyaXZpYWxseQoJCSAqIGFkZCBzdWJzcGVjcyB0byBpdC4KCQkgKi8KCQl0cmFuc2Zvcm1fdG9fY29tYmluZV90eXBlKGZpbHRlcl9vcHRpb25zKTsKCgkJc3RyYnVmX2FkZGNoKCZmaWx0ZXJfb3B0aW9ucy0+ZmlsdGVyX3NwZWMsICcrJyk7CgkJZmlsdGVyX3NwZWNfYXBwZW5kX3VybGVuY29kZShmaWx0ZXJfb3B0aW9ucywgYXJnKTsKCQlBTExPQ19HUk9XX0JZKGZpbHRlcl9vcHRpb25zLT5zdWIsIGZpbHRlcl9vcHRpb25zLT5zdWJfbnIsIDEsCgkJCSAgICAgIGZpbHRlcl9vcHRpb25zLT5zdWJfYWxsb2MpOwoJCXN1YiA9ICZmaWx0ZXJfb3B0aW9ucy0+c3ViW2ZpbHRlcl9vcHRpb25zLT5zdWJfbnIgLSAxXTsKCgkJbGlzdF9vYmplY3RzX2ZpbHRlcl9pbml0KHN1Yik7CgkJcGFyc2VfZXJyb3IgPSBnZW50bHlfcGFyc2VfbGlzdF9vYmplY3RzX2ZpbHRlcihzdWIsIGFyZywKCQkJCQkJCSAgICAgICAmZXJyYnVmKTsKCX0KCWlmIChwYXJzZV9lcnJvcikKCQlkaWUoIiVzIiwgZXJyYnVmLmJ1Zik7Cn0KCmludCBvcHRfcGFyc2VfbGlzdF9vYmplY3RzX2ZpbHRlcihjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsCgkJCQkgIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglzdHJ1Y3QgbGlzdF9vYmplY3RzX2ZpbHRlcl9vcHRpb25zICpmaWx0ZXJfb3B0aW9ucyA9IG9wdC0+dmFsdWU7CgoJaWYgKHVuc2V0IHx8ICFhcmcpCgkJbGlzdF9vYmplY3RzX2ZpbHRlcl9zZXRfbm9fZmlsdGVyKGZpbHRlcl9vcHRpb25zKTsKCWVsc2UKCQlwYXJzZV9saXN0X29iamVjdHNfZmlsdGVyKGZpbHRlcl9vcHRpb25zLCBhcmcpOwoJcmV0dXJuIDA7Cn0KCmNvbnN0IGNoYXIgKmxpc3Rfb2JqZWN0c19maWx0ZXJfc3BlYyhzdHJ1Y3QgbGlzdF9vYmplY3RzX2ZpbHRlcl9vcHRpb25zICpmaWx0ZXIpCnsKCWlmICghZmlsdGVyLT5maWx0ZXJfc3BlYy5sZW4pCgkJQlVHKCJubyBmaWx0ZXJfc3BlYyBhdmFpbGFibGUgZm9yIHRoaXMgZmlsdGVyIik7CglyZXR1cm4gZmlsdGVyLT5maWx0ZXJfc3BlYy5idWY7Cn0KCmNvbnN0IGNoYXIgKmV4cGFuZF9saXN0X29iamVjdHNfZmlsdGVyX3NwZWMoCglzdHJ1Y3QgbGlzdF9vYmplY3RzX2ZpbHRlcl9vcHRpb25zICpmaWx0ZXIpCnsKCWlmIChmaWx0ZXItPmNob2ljZSA9PSBMT0ZDX0JMT0JfTElNSVQpIHsKCQlzdHJidWZfcmVsZWFzZSgmZmlsdGVyLT5maWx0ZXJfc3BlYyk7CgkJc3RyYnVmX2FkZGYoJmZpbHRlci0+ZmlsdGVyX3NwZWMsICJibG9iOmxpbWl0PSVsdSIsCgkJCSAgICBmaWx0ZXItPmJsb2JfbGltaXRfdmFsdWUpOwoJfQoKCXJldHVybiBsaXN0X29iamVjdHNfZmlsdGVyX3NwZWMoZmlsdGVyKTsKfQoKdm9pZCBsaXN0X29iamVjdHNfZmlsdGVyX3JlbGVhc2UoCglzdHJ1Y3QgbGlzdF9vYmplY3RzX2ZpbHRlcl9vcHRpb25zICpmaWx0ZXJfb3B0aW9ucykKewoJc2l6ZV90IHN1YjsKCglpZiAoIWZpbHRlcl9vcHRpb25zKQoJCXJldHVybjsKCXN0cmJ1Zl9yZWxlYXNlKCZmaWx0ZXJfb3B0aW9ucy0+ZmlsdGVyX3NwZWMpOwoJZnJlZShmaWx0ZXJfb3B0aW9ucy0+c3BhcnNlX29pZF9uYW1lKTsKCWZvciAoc3ViID0gMDsgc3ViIDwgZmlsdGVyX29wdGlvbnMtPnN1Yl9ucjsgc3ViKyspCgkJbGlzdF9vYmplY3RzX2ZpbHRlcl9yZWxlYXNlKCZmaWx0ZXJfb3B0aW9ucy0+c3ViW3N1Yl0pOwoJZnJlZShmaWx0ZXJfb3B0aW9ucy0+c3ViKTsKCWxpc3Rfb2JqZWN0c19maWx0ZXJfaW5pdChmaWx0ZXJfb3B0aW9ucyk7Cn0KCnZvaWQgcGFydGlhbF9jbG9uZV9yZWdpc3RlcigKCWNvbnN0IGNoYXIgKnJlbW90ZSwKCXN0cnVjdCBsaXN0X29iamVjdHNfZmlsdGVyX29wdGlvbnMgKmZpbHRlcl9vcHRpb25zKQp7CglzdHJ1Y3QgcHJvbWlzb3JfcmVtb3RlICpwcm9taXNvcl9yZW1vdGU7CgljaGFyICpjZmdfbmFtZTsKCWNoYXIgKmZpbHRlcl9uYW1lOwoKCS8qIENoZWNrIGlmIGl0IGlzIGFscmVhZHkgcmVnaXN0ZXJlZCAqLwoJaWYgKChwcm9taXNvcl9yZW1vdGUgPSByZXBvX3Byb21pc29yX3JlbW90ZV9maW5kKHRoZV9yZXBvc2l0b3J5LCByZW1vdGUpKSkgewoJCWlmIChwcm9taXNvcl9yZW1vdGUtPnBhcnRpYWxfY2xvbmVfZmlsdGVyKQoJCQkvKgoJCQkgKiBSZW1vdGUgaXMgYWxyZWFkeSByZWdpc3RlcmVkIGFuZCBhIGZpbHRlciBpcyBhbHJlYWR5CgkJCSAqIHNldCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyBoZXJlLgoJCQkgKi8KCQkJcmV0dXJuOwoJfSBlbHNlIHsKCQlpZiAodXBncmFkZV9yZXBvc2l0b3J5X2Zvcm1hdCgxKSA8IDApCgkJCWRpZShfKCJ1bmFibGUgdG8gdXBncmFkZSByZXBvc2l0b3J5IGZvcm1hdCB0byBzdXBwb3J0IHBhcnRpYWwgY2xvbmUiKSk7CgoJCS8qIEFkZCBwcm9taXNvciBjb25maWcgZm9yIHRoZSByZW1vdGUgKi8KCQljZmdfbmFtZSA9IHhzdHJmbXQoInJlbW90ZS4lcy5wcm9taXNvciIsIHJlbW90ZSk7CgkJZ2l0X2NvbmZpZ19zZXQoY2ZnX25hbWUsICJ0cnVlIik7CgkJZnJlZShjZmdfbmFtZSk7Cgl9CgoJLyoKCSAqIFJlY29yZCB0aGUgaW5pdGlhbCBmaWx0ZXItc3BlYyBpbiB0aGUgY29uZmlnIGFzCgkgKiB0aGUgZGVmYXVsdCBmb3Igc3Vic2VxdWVudCBmZXRjaGVzIGZyb20gdGhpcyByZW1vdGUuCgkgKi8KCWZpbHRlcl9uYW1lID0geHN0cmZtdCgicmVtb3RlLiVzLnBhcnRpYWxjbG9uZWZpbHRlciIsIHJlbW90ZSk7CgkvKiBORUVEU1dPUks6ICdleHBhbmQnIHJlc3VsdCBsZWFraW5nPz8/ICovCglnaXRfY29uZmlnX3NldChmaWx0ZXJfbmFtZSwKCQkgICAgICAgZXhwYW5kX2xpc3Rfb2JqZWN0c19maWx0ZXJfc3BlYyhmaWx0ZXJfb3B0aW9ucykpOwoJZnJlZShmaWx0ZXJfbmFtZSk7CgoJLyogTWFrZSBzdXJlIHRoZSBjb25maWcgaW5mbyBhcmUgcmVzZXQgKi8KCXJlcG9fcHJvbWlzb3JfcmVtb3RlX3JlaW5pdCh0aGVfcmVwb3NpdG9yeSk7Cn0KCnZvaWQgcGFydGlhbF9jbG9uZV9nZXRfZGVmYXVsdF9maWx0ZXJfc3BlYygKCXN0cnVjdCBsaXN0X29iamVjdHNfZmlsdGVyX29wdGlvbnMgKmZpbHRlcl9vcHRpb25zLAoJY29uc3QgY2hhciAqcmVtb3RlKQp7CglzdHJ1Y3QgcHJvbWlzb3JfcmVtb3RlICpwcm9taXNvciA9IHJlcG9fcHJvbWlzb3JfcmVtb3RlX2ZpbmQodGhlX3JlcG9zaXRvcnksCgkJCQkJCQkJICAgICByZW1vdGUpOwoJc3RydWN0IHN0cmJ1ZiBlcnJidWYgPSBTVFJCVUZfSU5JVDsKCgkvKgoJICogUGFyc2UgZGVmYXVsdCB2YWx1ZSwgYnV0IHNpbGVudGx5IGlnbm9yZSBpdCBpZiBpdCBpcyBpbnZhbGlkLgoJICovCglpZiAoIXByb21pc29yIHx8ICFwcm9taXNvci0+cGFydGlhbF9jbG9uZV9maWx0ZXIpCgkJcmV0dXJuOwoKCXN0cmJ1Zl9hZGRzdHIoJmZpbHRlcl9vcHRpb25zLT5maWx0ZXJfc3BlYywKCQkgICAgICBwcm9taXNvci0+cGFydGlhbF9jbG9uZV9maWx0ZXIpOwoJZ2VudGx5X3BhcnNlX2xpc3Rfb2JqZWN0c19maWx0ZXIoZmlsdGVyX29wdGlvbnMsCgkJCQkJIHByb21pc29yLT5wYXJ0aWFsX2Nsb25lX2ZpbHRlciwKCQkJCQkgJmVycmJ1Zik7CglzdHJidWZfcmVsZWFzZSgmZXJyYnVmKTsKfQoKdm9pZCBsaXN0X29iamVjdHNfZmlsdGVyX2NvcHkoCglzdHJ1Y3QgbGlzdF9vYmplY3RzX2ZpbHRlcl9vcHRpb25zICpkZXN0LAoJY29uc3Qgc3RydWN0IGxpc3Rfb2JqZWN0c19maWx0ZXJfb3B0aW9ucyAqc3JjKQp7CglpbnQgaTsKCgkvKiBDb3B5IGV2ZXJ5dGhpbmcuIFdlIHdpbGwgb3ZlcndyaXRlIHRoZSBwb2ludGVycyBzaG9ydGx5LiAqLwoJbWVtY3B5KGRlc3QsIHNyYywgc2l6ZW9mKHN0cnVjdCBsaXN0X29iamVjdHNfZmlsdGVyX29wdGlvbnMpKTsKCglzdHJidWZfaW5pdCgmZGVzdC0+ZmlsdGVyX3NwZWMsIDApOwoJc3RyYnVmX2FkZGJ1ZigmZGVzdC0+ZmlsdGVyX3NwZWMsICZzcmMtPmZpbHRlcl9zcGVjKTsKCWRlc3QtPnNwYXJzZV9vaWRfbmFtZSA9IHhzdHJkdXBfb3JfbnVsbChzcmMtPnNwYXJzZV9vaWRfbmFtZSk7CgoJQUxMT0NfQVJSQVkoZGVzdC0+c3ViLCBkZXN0LT5zdWJfYWxsb2MpOwoJZm9yIChpID0gMDsgaSA8IHNyYy0+c3ViX25yOyBpKyspCgkJbGlzdF9vYmplY3RzX2ZpbHRlcl9jb3B5KCZkZXN0LT5zdWJbaV0sICZzcmMtPnN1YltpXSk7Cn0KCnZvaWQgbGlzdF9vYmplY3RzX2ZpbHRlcl9pbml0KHN0cnVjdCBsaXN0X29iamVjdHNfZmlsdGVyX29wdGlvbnMgKmZpbHRlcl9vcHRpb25zKQp7CglzdHJ1Y3QgbGlzdF9vYmplY3RzX2ZpbHRlcl9vcHRpb25zIGJsYW5rID0gTElTVF9PQkpFQ1RTX0ZJTFRFUl9JTklUOwoJbWVtY3B5KGZpbHRlcl9vcHRpb25zLCAmYmxhbmssIHNpemVvZigqZmlsdGVyX29wdGlvbnMpKTsKfQo=",
    "text": "#define USE_THE_REPOSITORY_VARIABLE\n\n#include \"git-compat-util.h\"\n#include \"config.h\"\n#include \"gettext.h\"\n#include \"list-objects-filter-options.h\"\n#include \"promisor-remote.h\"\n#include \"trace.h\"\n#include \"url.h\"\n#include \"parse-options.h\"\n\nstatic int parse_combine_filter(\n\tstruct list_objects_filter_options *filter_options,\n\tconst char *arg,\n\tstruct strbuf *errbuf);\n\nconst char *list_object_filter_config_name(enum list_objects_filter_choice c)\n{\n\tswitch (c) {\n\tcase LOFC_DISABLED:\n\t\t/* we have no name for \"no filter at all\" */\n\t\tbreak;\n\tcase LOFC_BLOB_NONE:\n\t\treturn \"blob:none\";\n\tcase LOFC_BLOB_LIMIT:\n\t\treturn \"blob:limit\";\n\tcase LOFC_TREE_DEPTH:\n\t\treturn \"tree\";\n\tcase LOFC_SPARSE_OID:\n\t\treturn \"sparse:oid\";\n\tcase LOFC_OBJECT_TYPE:\n\t\treturn \"object:type\";\n\tcase LOFC_COMBINE:\n\t\treturn \"combine\";\n\tcase LOFC__COUNT:\n\t\t/* not a real filter type; just the count of all filters */\n\t\tbreak;\n\t}\n\tBUG(\"list_object_filter_config_name: invalid argument '%d'\", c);\n}\n\nint gently_parse_list_objects_filter(\n\tstruct list_objects_filter_options *filter_options,\n\tconst char *arg,\n\tstruct strbuf *errbuf)\n{\n\tconst char *v0;\n\n\tif (!arg)\n\t\treturn 0;\n\n\tif (filter_options->choice)\n\t\tBUG(\"filter_options already populated\");\n\n\tif (!strcmp(arg, \"blob:none\")) {\n\t\tfilter_options->choice = LOFC_BLOB_NONE;\n\t\treturn 0;\n\n\t} else if (skip_prefix(arg, \"blob:limit=\", &v0)) {\n\t\tif (git_parse_ulong(v0, &filter_options->blob_limit_value)) {\n\t\t\tfilter_options->choice = LOFC_BLOB_LIMIT;\n\t\t\treturn 0;\n\t\t}\n\n\t} else if (skip_prefix(arg, \"tree:\", &v0)) {\n\t\tif (!git_parse_ulong(v0, &filter_options->tree_exclude_depth)) {\n\t\t\tstrbuf_addstr(errbuf, _(\"expected 'tree:<depth>'\"));\n\t\t\treturn 1;\n\t\t}\n\t\tfilter_options->choice = LOFC_TREE_DEPTH;\n\t\treturn 0;\n\n\t} else if (skip_prefix(arg, \"sparse:oid=\", &v0)) {\n\t\tfilter_options->sparse_oid_name = xstrdup(v0);\n\t\tfilter_options->choice = LOFC_SPARSE_OID;\n\t\treturn 0;\n\n\t} else if (skip_prefix(arg, \"sparse:path=\", &v0)) {\n\t\tif (errbuf) {\n\t\t\tstrbuf_addstr(\n\t\t\t\terrbuf,\n\t\t\t\t_(\"sparse:path filters support has been dropped\"));\n\t\t}\n\t\treturn 1;\n\n\t} else if (skip_prefix(arg, \"object:type=\", &v0)) {\n\t\tint type = type_from_string_gently(v0, strlen(v0), 1);\n\t\tif (type < 0) {\n\t\t\tstrbuf_addf(errbuf, _(\"'%s' for 'object:type=<type>' is \"\n\t\t\t\t\t      \"not a valid object type\"), v0);\n\t\t\treturn 1;\n\t\t}\n\n\t\tfilter_options->object_type = type;\n\t\tfilter_options->choice = LOFC_OBJECT_TYPE;\n\n\t\treturn 0;\n\n\t} else if (skip_prefix(arg, \"combine:\", &v0)) {\n\t\treturn parse_combine_filter(filter_options, v0, errbuf);\n\n\t}\n\t/*\n\t * Please update _git_fetch() in git-completion.bash when you\n\t * add new filters\n\t */\n\n\tstrbuf_addf(errbuf, _(\"invalid filter-spec '%s'\"), arg);\n\n\tlist_objects_filter_init(filter_options);\n\treturn 1;\n}\n\nstatic const char *RESERVED_NON_WS = \"~`!@#$^&*()[]{}\\\\;'\\\",<>?\";\n\nstatic int has_reserved_character(\n\tstruct strbuf *sub_spec, struct strbuf *errbuf)\n{\n\tconst char *c = sub_spec->buf;\n\twhile (*c) {\n\t\tif (*c <= ' ' || strchr(RESERVED_NON_WS, *c)) {\n\t\t\tstrbuf_addf(\n\t\t\t\terrbuf,\n\t\t\t\t_(\"must escape char in sub-filter-spec: '%c'\"),\n\t\t\t\t*c);\n\t\t\treturn 1;\n\t\t}\n\t\tc++;\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_combine_subfilter(\n\tstruct list_objects_filter_options *filter_options,\n\tstruct strbuf *subspec,\n\tstruct strbuf *errbuf)\n{\n\tsize_t new_index = filter_options->sub_nr;\n\tchar *decoded;\n\tint result;\n\n\tALLOC_GROW_BY(filter_options->sub, filter_options->sub_nr, 1,\n\t\t      filter_options->sub_alloc);\n\tlist_objects_filter_init(&filter_options->sub[new_index]);\n\n\tdecoded = url_percent_decode(subspec->buf);\n\n\tresult = has_reserved_character(subspec, errbuf) ||\n\t\tgently_parse_list_objects_filter(\n\t\t\t&filter_options->sub[new_index], decoded, errbuf);\n\n\tfree(decoded);\n\treturn result;\n}\n\nstatic int parse_combine_filter(\n\tstruct list_objects_filter_options *filter_options,\n\tconst char *arg,\n\tstruct strbuf *errbuf)\n{\n\tstruct strbuf **subspecs = strbuf_split_str(arg, '+', 0);\n\tsize_t sub;\n\tint result = 0;\n\n\tif (!subspecs[0]) {\n\t\tstrbuf_addstr(errbuf, _(\"expected something after combine:\"));\n\t\tresult = 1;\n\t\tgoto cleanup;\n\t}\n\n\tfor (sub = 0; subspecs[sub] && !result; sub++) {\n\t\tif (subspecs[sub + 1]) {\n\t\t\t/*\n\t\t\t * This is not the last subspec. Remove trailing \"+\" so\n\t\t\t * we can parse it.\n\t\t\t */\n\t\t\tsize_t last = subspecs[sub]->len - 1;\n\t\t\tassert(subspecs[sub]->buf[last] == '+');\n\t\t\tstrbuf_remove(subspecs[sub], last, 1);\n\t\t}\n\t\tresult = parse_combine_subfilter(\n\t\t\tfilter_options, subspecs[sub], errbuf);\n\t}\n\n\tfilter_options->choice = LOFC_COMBINE;\n\ncleanup:\n\tstrbuf_list_free(subspecs);\n\tif (result)\n\t\tlist_objects_filter_release(filter_options);\n\treturn result;\n}\n\nstatic int allow_unencoded(char ch)\n{\n\tif (ch <= ' ' || ch == '%' || ch == '+')\n\t\treturn 0;\n\treturn !strchr(RESERVED_NON_WS, ch);\n}\n\nstatic void filter_spec_append_urlencode(\n\tstruct list_objects_filter_options *filter, const char *raw)\n{\n\tsize_t orig_len = filter->filter_spec.len;\n\tstrbuf_addstr_urlencode(&filter->filter_spec, raw, allow_unencoded);\n\ttrace_printf(\"Add to combine filter-spec: %s\\n\",\n\t\t     filter->filter_spec.buf + orig_len);\n}\n\n/*\n * Changes filter_options into an equivalent LOFC_COMBINE filter options\n * instance. Does not do anything if filter_options is already LOFC_COMBINE.\n */\nstatic void transform_to_combine_type(\n\tstruct list_objects_filter_options *filter_options)\n{\n\tassert(filter_options->choice);\n\tif (filter_options->choice == LOFC_COMBINE)\n\t\treturn;\n\t{\n\t\tconst int initial_sub_alloc = 2;\n\t\tstruct list_objects_filter_options *sub_array =\n\t\t\txcalloc(initial_sub_alloc, sizeof(*sub_array));\n\t\tsub_array[0] = *filter_options;\n\t\tlist_objects_filter_init(filter_options);\n\t\tfilter_options->sub = sub_array;\n\t\tfilter_options->sub_alloc = initial_sub_alloc;\n\t}\n\tfilter_options->sub_nr = 1;\n\tfilter_options->choice = LOFC_COMBINE;\n\tstrbuf_addstr(&filter_options->filter_spec, \"combine:\");\n\tfilter_spec_append_urlencode(\n\t\tfilter_options,\n\t\tlist_objects_filter_spec(&filter_options->sub[0]));\n\t/*\n\t * We don't need the filter_spec strings for subfilter specs, only the\n\t * top level.\n\t */\n\tstrbuf_release(&filter_options->sub[0].filter_spec);\n}\n\nvoid list_objects_filter_die_if_populated(\n\tstruct list_objects_filter_options *filter_options)\n{\n\tif (filter_options->choice)\n\t\tdie(_(\"multiple filter-specs cannot be combined\"));\n}\n\nvoid parse_list_objects_filter(\n\tstruct list_objects_filter_options *filter_options,\n\tconst char *arg)\n{\n\tstruct strbuf errbuf = STRBUF_INIT;\n\tint parse_error;\n\n\tif (!filter_options->filter_spec.buf)\n\t\tBUG(\"filter_options not properly initialized\");\n\n\tif (!filter_options->choice) {\n\t\tstrbuf_addstr(&filter_options->filter_spec, arg);\n\n\t\tparse_error = gently_parse_list_objects_filter(\n\t\t\tfilter_options, arg, &errbuf);\n\t} else {\n\t\tstruct list_objects_filter_options *sub;\n\n\t\t/*\n\t\t * Make filter_options an LOFC_COMBINE spec so we can trivially\n\t\t * add subspecs to it.\n\t\t */\n\t\ttransform_to_combine_type(filter_options);\n\n\t\tstrbuf_addch(&filter_options->filter_spec, '+');\n\t\tfilter_spec_append_urlencode(filter_options, arg);\n\t\tALLOC_GROW_BY(filter_options->sub, filter_options->sub_nr, 1,\n\t\t\t      filter_options->sub_alloc);\n\t\tsub = &filter_options->sub[filter_options->sub_nr - 1];\n\n\t\tlist_objects_filter_init(sub);\n\t\tparse_error = gently_parse_list_objects_filter(sub, arg,\n\t\t\t\t\t\t\t       &errbuf);\n\t}\n\tif (parse_error)\n\t\tdie(\"%s\", errbuf.buf);\n}\n\nint opt_parse_list_objects_filter(const struct option *opt,\n\t\t\t\t  const char *arg, int unset)\n{\n\tstruct list_objects_filter_options *filter_options = opt->value;\n\n\tif (unset || !arg)\n\t\tlist_objects_filter_set_no_filter(filter_options);\n\telse\n\t\tparse_list_objects_filter(filter_options, arg);\n\treturn 0;\n}\n\nconst char *list_objects_filter_spec(struct list_objects_filter_options *filter)\n{\n\tif (!filter->filter_spec.len)\n\t\tBUG(\"no filter_spec available for this filter\");\n\treturn filter->filter_spec.buf;\n}\n\nconst char *expand_list_objects_filter_spec(\n\tstruct list_objects_filter_options *filter)\n{\n\tif (filter->choice == LOFC_BLOB_LIMIT) {\n\t\tstrbuf_release(&filter->filter_spec);\n\t\tstrbuf_addf(&filter->filter_spec, \"blob:limit=%lu\",\n\t\t\t    filter->blob_limit_value);\n\t}\n\n\treturn list_objects_filter_spec(filter);\n}\n\nvoid list_objects_filter_release(\n\tstruct list_objects_filter_options *filter_options)\n{\n\tsize_t sub;\n\n\tif (!filter_options)\n\t\treturn;\n\tstrbuf_release(&filter_options->filter_spec);\n\tfree(filter_options->sparse_oid_name);\n\tfor (sub = 0; sub < filter_options->sub_nr; sub++)\n\t\tlist_objects_filter_release(&filter_options->sub[sub]);\n\tfree(filter_options->sub);\n\tlist_objects_filter_init(filter_options);\n}\n\nvoid partial_clone_register(\n\tconst char *remote,\n\tstruct list_objects_filter_options *filter_options)\n{\n\tstruct promisor_remote *promisor_remote;\n\tchar *cfg_name;\n\tchar *filter_name;\n\n\t/* Check if it is already registered */\n\tif ((promisor_remote = repo_promisor_remote_find(the_repository, remote))) {\n\t\tif (promisor_remote->partial_clone_filter)\n\t\t\t/*\n\t\t\t * Remote is already registered and a filter is already\n\t\t\t * set, so we don't need to do anything here.\n\t\t\t */\n\t\t\treturn;\n\t} else {\n\t\tif (upgrade_repository_format(1) < 0)\n\t\t\tdie(_(\"unable to upgrade repository format to support partial clone\"));\n\n\t\t/* Add promisor config for the remote */\n\t\tcfg_name = xstrfmt(\"remote.%s.promisor\", remote);\n\t\tgit_config_set(cfg_name, \"true\");\n\t\tfree(cfg_name);\n\t}\n\n\t/*\n\t * Record the initial filter-spec in the config as\n\t * the default for subsequent fetches from this remote.\n\t */\n\tfilter_name = xstrfmt(\"remote.%s.partialclonefilter\", remote);\n\t/* NEEDSWORK: 'expand' result leaking??? */\n\tgit_config_set(filter_name,\n\t\t       expand_list_objects_filter_spec(filter_options));\n\tfree(filter_name);\n\n\t/* Make sure the config info are reset */\n\trepo_promisor_remote_reinit(the_repository);\n}\n\nvoid partial_clone_get_default_filter_spec(\n\tstruct list_objects_filter_options *filter_options,\n\tconst char *remote)\n{\n\tstruct promisor_remote *promisor = repo_promisor_remote_find(the_repository,\n\t\t\t\t\t\t\t\t     remote);\n\tstruct strbuf errbuf = STRBUF_INIT;\n\n\t/*\n\t * Parse default value, but silently ignore it if it is invalid.\n\t */\n\tif (!promisor || !promisor->partial_clone_filter)\n\t\treturn;\n\n\tstrbuf_addstr(&filter_options->filter_spec,\n\t\t      promisor->partial_clone_filter);\n\tgently_parse_list_objects_filter(filter_options,\n\t\t\t\t\t promisor->partial_clone_filter,\n\t\t\t\t\t &errbuf);\n\tstrbuf_release(&errbuf);\n}\n\nvoid list_objects_filter_copy(\n\tstruct list_objects_filter_options *dest,\n\tconst struct list_objects_filter_options *src)\n{\n\tint i;\n\n\t/* Copy everything. We will overwrite the pointers shortly. */\n\tmemcpy(dest, src, sizeof(struct list_objects_filter_options));\n\n\tstrbuf_init(&dest->filter_spec, 0);\n\tstrbuf_addbuf(&dest->filter_spec, &src->filter_spec);\n\tdest->sparse_oid_name = xstrdup_or_null(src->sparse_oid_name);\n\n\tALLOC_ARRAY(dest->sub, dest->sub_alloc);\n\tfor (i = 0; i < src->sub_nr; i++)\n\t\tlist_objects_filter_copy(&dest->sub[i], &src->sub[i]);\n}\n\nvoid list_objects_filter_init(struct list_objects_filter_options *filter_options)\n{\n\tstruct list_objects_filter_options blank = LIST_OBJECTS_FILTER_INIT;\n\tmemcpy(filter_options, &blank, sizeof(*filter_options));\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00611107d20293b06157019dd6ff214a6dd0f286",
  "sha1_ok": true,
  "size": 11099
}
