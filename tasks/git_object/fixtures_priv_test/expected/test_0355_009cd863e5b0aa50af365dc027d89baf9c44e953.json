{
  "content": {
    "base64": "I2lmbmRlZiBQQVJTRV9PUFRJT05TX0gKI2RlZmluZSBQQVJTRV9PUFRJT05TX0gKCmVudW0gcGFyc2Vfb3B0X3R5cGUgewoJLyogc3BlY2lhbCB0eXBlcyAqLwoJT1BUSU9OX0VORCwKCU9QVElPTl9BUkdVTUVOVCwKCU9QVElPTl9HUk9VUCwKCU9QVElPTl9OVU1CRVIsCgkvKiBvcHRpb25zIHdpdGggbm8gYXJndW1lbnRzICovCglPUFRJT05fQklULAoJT1BUSU9OX05FR0JJVCwKCU9QVElPTl9DT1VOVFVQLAoJT1BUSU9OX1NFVF9JTlQsCglPUFRJT05fQ01ETU9ERSwKCS8qIG9wdGlvbnMgd2l0aCBhcmd1bWVudHMgKHVzdWFsbHkpICovCglPUFRJT05fU1RSSU5HLAoJT1BUSU9OX0lOVEVHRVIsCglPUFRJT05fTUFHTklUVURFLAoJT1BUSU9OX0NBTExCQUNLLAoJT1BUSU9OX0xPV0xFVkVMX0NBTExCQUNLLAoJT1BUSU9OX0ZJTEVOQU1FCn07CgplbnVtIHBhcnNlX29wdF9mbGFncyB7CglQQVJTRV9PUFRfS0VFUF9EQVNIREFTSCA9IDEsCglQQVJTRV9PUFRfU1RPUF9BVF9OT05fT1BUSU9OID0gMiwKCVBBUlNFX09QVF9LRUVQX0FSR1YwID0gNCwKCVBBUlNFX09QVF9LRUVQX1VOS05PV04gPSA4LAoJUEFSU0VfT1BUX05PX0lOVEVSTkFMX0hFTFAgPSAxNgp9OwoKZW51bSBwYXJzZV9vcHRfb3B0aW9uX2ZsYWdzIHsKCVBBUlNFX09QVF9PUFRBUkcgID0gMSwKCVBBUlNFX09QVF9OT0FSRyAgID0gMiwKCVBBUlNFX09QVF9OT05FRyAgID0gNCwKCVBBUlNFX09QVF9ISURERU4gID0gOCwKCVBBUlNFX09QVF9MQVNUQVJHX0RFRkFVTFQgPSAxNiwKCVBBUlNFX09QVF9OT0RBU0ggPSAzMiwKCVBBUlNFX09QVF9MSVRFUkFMX0FSR0hFTFAgPSA2NCwKCVBBUlNFX09QVF9TSEVMTF9FVkFMID0gMjU2LAoJUEFSU0VfT1BUX05PQ09NUExFVEUgPSA1MTIKfTsKCnN0cnVjdCBvcHRpb247CnR5cGVkZWYgaW50IHBhcnNlX29wdF9jYihjb25zdCBzdHJ1Y3Qgb3B0aW9uICosIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KTsKCnN0cnVjdCBwYXJzZV9vcHRfY3R4X3Q7CnR5cGVkZWYgaW50IHBhcnNlX29wdF9sbF9jYihzdHJ1Y3QgcGFyc2Vfb3B0X2N0eF90ICpjdHgsCgkJCQljb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGludCB1bnNldCk7CgovKgogKiBgdHlwZWA6OgogKiAgIGhvbGRzIHRoZSB0eXBlIG9mIHRoZSBvcHRpb24sIHlvdSBtdXN0IGhhdmUgYW4gT1BUSU9OX0VORCBsYXN0IGluIHlvdXIKICogICBhcnJheS4KICoKICogYHNob3J0X25hbWVgOjoKICogICB0aGUgY2hhcmFjdGVyIHRvIHVzZSBhcyBhIHNob3J0IG9wdGlvbiBuYW1lLCAnXDAnIGlmIG5vbmUuCiAqCiAqIGBsb25nX25hbWVgOjoKICogICB0aGUgbG9uZyBvcHRpb24gbmFtZSwgd2l0aG91dCB0aGUgbGVhZGluZyBkYXNoZXMsIE5VTEwgaWYgbm9uZS4KICoKICogYHZhbHVlYDo6CiAqICAgc3RvcmVzIHBvaW50ZXJzIHRvIHRoZSB2YWx1ZXMgdG8gYmUgZmlsbGVkLgogKgogKiBgYXJnaGA6OgogKiAgIHRva2VuIHRvIGV4cGxhaW4gdGhlIGtpbmQgb2YgYXJndW1lbnQgdGhpcyBvcHRpb24gd2FudHMuIEtlZXAgaXQKICogICBob21vZ2VuZW91cyBhY3Jvc3MgdGhlIHJlcG9zaXRvcnkuIFNob3VsZCBiZSB3cmFwcGVkIGJ5IE5fKCkgZm9yCiAqICAgdHJhbnNsYXRpb24uCiAqCiAqIGBoZWxwYDo6CiAqICAgdGhlIHNob3J0IGhlbHAgYXNzb2NpYXRlZCB0byB3aGF0IHRoZSBvcHRpb24gZG9lcy4KICogICBNdXN0IG5ldmVyIGJlIE5VTEwgKGV4Y2VwdCBmb3IgT1BUSU9OX0VORCkuCiAqICAgT1BUSU9OX0dST1VQIHVzZXMgdGhpcyBwb2ludGVyIHRvIHN0b3JlIHRoZSBncm91cCBoZWFkZXIuCiAqICAgU2hvdWxkIGJlIHdyYXBwZWQgYnkgTl8oKSBmb3IgdHJhbnNsYXRpb24uCiAqCiAqIGBmbGFnc2A6OgogKiAgIG1hc2sgb2YgcGFyc2Vfb3B0X29wdGlvbl9mbGFncy4KICogICBQQVJTRV9PUFRfT1BUQVJHOiBzYXlzIHRoYXQgdGhlIGFyZ3VtZW50IGlzIG9wdGlvbmFsIChub3QgZm9yIEJPT0xFQU5zKQogKiAgIFBBUlNFX09QVF9OT0FSRzogc2F5cyB0aGF0IHRoaXMgb3B0aW9uIGRvZXMgbm90IHRha2UgYW4gYXJndW1lbnQKICogICBQQVJTRV9PUFRfTk9ORUc6IHNheXMgdGhhdCB0aGlzIG9wdGlvbiBjYW5ub3QgYmUgbmVnYXRlZAogKiAgIFBBUlNFX09QVF9ISURERU46IHRoaXMgb3B0aW9uIGlzIHNraXBwZWQgaW4gdGhlIGRlZmF1bHQgdXNhZ2UsIGFuZAogKiAgICAgICAgICAgICAgICAgICAgIHNob3duIG9ubHkgaW4gdGhlIGZ1bGwgdXNhZ2UuCiAqICAgUEFSU0VfT1BUX0xBU1RBUkdfREVGQVVMVDogc2F5cyB0aGF0IHRoaXMgb3B0aW9uIHdpbGwgdGFrZSB0aGUgZGVmYXVsdAogKgkJCQl2YWx1ZSBpZiBubyBhcmd1bWVudCBpcyBnaXZlbiB3aGVuIHRoZSBvcHRpb24KICoJCQkJaXMgbGFzdCBvbiB0aGUgY29tbWFuZCBsaW5lLiBJZiB0aGUgb3B0aW9uIGlzCiAqCQkJCW5vdCBsYXN0IGl0IHdpbGwgcmVxdWlyZSBhbiBhcmd1bWVudC4KICoJCQkJU2hvdWxkIG5vdCBiZSB1c2VkIHdpdGggUEFSU0VfT1BUX09QVEFSRy4KICogICBQQVJTRV9PUFRfTk9EQVNIOiB0aGlzIG9wdGlvbiBkb2Vzbid0IHN0YXJ0IHdpdGggYSBkYXNoLgogKiAgIFBBUlNFX09QVF9MSVRFUkFMX0FSR0hFTFA6IHNheXMgdGhhdCBhcmdoIHNob3VsZG4ndCBiZSBlbmNsb3NlZCBpbiBicmFja2V0cwogKgkJCQkoaS5lLiAnPGFyZ2g+JykgaW4gdGhlIGhlbHAgbWVzc2FnZS4KICoJCQkJVXNlZnVsIGZvciBvcHRpb25zIHdpdGggbXVsdGlwbGUgcGFyYW1ldGVycy4KICogICBQQVJTRV9PUFRfTk9DT01QTEVURTogYnkgZGVmYXVsdCBhbGwgdmlzaWJsZSBvcHRpb25zIGFyZSBjb21wbGV0YWJsZQogKgkJCSAgIGJ5IGdpdC1jb21wbGV0aW9uLmJhc2guIFRoaXMgb3B0aW9uIHN1cHByZXNzZXMgdGhhdC4KICoKICogYGNhbGxiYWNrYDo6CiAqICAgcG9pbnRlciB0byB0aGUgY2FsbGJhY2sgdG8gdXNlIGZvciBPUFRJT05fQ0FMTEJBQ0sgb3IKICogICBPUFRJT05fTE9XTEVWRUxfQ0FMTEJBQ0suCiAqCiAqIGBkZWZ2YWxgOjoKICogICBkZWZhdWx0IHZhbHVlIHRvIGZpbGwgKCotPnZhbHVlKSB3aXRoIGZvciBQQVJTRV9PUFRfT1BUQVJHLgogKiAgIE9QVElPTl97QklULFNFVF9JTlR9IHN0b3JlIHRoZSB7bWFzayxpbnRlZ2VyfSB0byBwdXQgaW4gdGhlIHZhbHVlIHdoZW4gbWV0LgogKiAgIENBTExCQUNLUyBjYW4gdXNlIGl0IGxpa2UgdGhleSB3YW50LgogKi8Kc3RydWN0IG9wdGlvbiB7CgllbnVtIHBhcnNlX29wdF90eXBlIHR5cGU7CglpbnQgc2hvcnRfbmFtZTsKCWNvbnN0IGNoYXIgKmxvbmdfbmFtZTsKCXZvaWQgKnZhbHVlOwoJY29uc3QgY2hhciAqYXJnaDsKCWNvbnN0IGNoYXIgKmhlbHA7CgoJaW50IGZsYWdzOwoJcGFyc2Vfb3B0X2NiICpjYWxsYmFjazsKCWludHB0cl90IGRlZnZhbDsKfTsKCiNkZWZpbmUgT1BUX0JJVF9GKHMsIGwsIHYsIGgsIGIsIGYpIHsgT1BUSU9OX0JJVCwgKHMpLCAobCksICh2KSwgTlVMTCwgKGgpLCBcCgkJCQkgICAgICBQQVJTRV9PUFRfTk9BUkd8KGYpLCBOVUxMLCAoYikgfQojZGVmaW5lIE9QVF9DT1VOVFVQX0YocywgbCwgdiwgaCwgZikgeyBPUFRJT05fQ09VTlRVUCwgKHMpLCAobCksICh2KSwgTlVMTCwgXAoJCQkJICAgICAgIChoKSwgUEFSU0VfT1BUX05PQVJHfChmKSB9CiNkZWZpbmUgT1BUX1NFVF9JTlRfRihzLCBsLCB2LCBoLCBpLCBmKSB7IE9QVElPTl9TRVRfSU5ULCAocyksIChsKSwgKHYpLCBOVUxMLCBcCgkJCQkJICAoaCksIFBBUlNFX09QVF9OT0FSRyB8IChmKSwgTlVMTCwgKGkpIH0KI2RlZmluZSBPUFRfQk9PTF9GKHMsIGwsIHYsIGgsIGYpICAgT1BUX1NFVF9JTlRfRihzLCBsLCB2LCBoLCAxLCBmKQoKI2RlZmluZSBPUFRfRU5EKCkgICAgICAgICAgICAgICAgICAgeyBPUFRJT05fRU5EIH0KI2RlZmluZSBPUFRfQVJHVU1FTlQobCwgaCkgICAgICAgICAgeyBPUFRJT05fQVJHVU1FTlQsIDAsIChsKSwgTlVMTCwgTlVMTCwgXAoJCQkJICAgICAgKGgpLCBQQVJTRV9PUFRfTk9BUkd9CiNkZWZpbmUgT1BUX0dST1VQKGgpICAgICAgICAgICAgICAgIHsgT1BUSU9OX0dST1VQLCAwLCBOVUxMLCBOVUxMLCBOVUxMLCAoaCkgfQojZGVmaW5lIE9QVF9CSVQocywgbCwgdiwgaCwgYikgICAgICBPUFRfQklUX0YocywgbCwgdiwgaCwgYiwgMCkKI2RlZmluZSBPUFRfTkVHQklUKHMsIGwsIHYsIGgsIGIpICAgeyBPUFRJT05fTkVHQklULCAocyksIChsKSwgKHYpLCBOVUxMLCBcCgkJCQkgICAgICAoaCksIFBBUlNFX09QVF9OT0FSRywgTlVMTCwgKGIpIH0KI2RlZmluZSBPUFRfQ09VTlRVUChzLCBsLCB2LCBoKSAgICAgT1BUX0NPVU5UVVBfRihzLCBsLCB2LCBoLCAwKQojZGVmaW5lIE9QVF9TRVRfSU5UKHMsIGwsIHYsIGgsIGkpICBPUFRfU0VUX0lOVF9GKHMsIGwsIHYsIGgsIGksIDApCiNkZWZpbmUgT1BUX0JPT0wocywgbCwgdiwgaCkgICAgICAgIE9QVF9CT09MX0YocywgbCwgdiwgaCwgMCkKI2RlZmluZSBPUFRfSElEREVOX0JPT0wocywgbCwgdiwgaCkgeyBPUFRJT05fU0VUX0lOVCwgKHMpLCAobCksICh2KSwgTlVMTCwgXAoJCQkJICAgICAgKGgpLCBQQVJTRV9PUFRfTk9BUkcgfCBQQVJTRV9PUFRfSElEREVOLCBOVUxMLCAxfQojZGVmaW5lIE9QVF9DTURNT0RFKHMsIGwsIHYsIGgsIGkpICB7IE9QVElPTl9DTURNT0RFLCAocyksIChsKSwgKHYpLCBOVUxMLCBcCgkJCQkgICAgICAoaCksIFBBUlNFX09QVF9OT0FSR3xQQVJTRV9PUFRfTk9ORUcsIE5VTEwsIChpKSB9CiNkZWZpbmUgT1BUX0lOVEVHRVIocywgbCwgdiwgaCkgICAgIHsgT1BUSU9OX0lOVEVHRVIsIChzKSwgKGwpLCAodiksIE5fKCJuIiksIChoKSB9CiNkZWZpbmUgT1BUX01BR05JVFVERShzLCBsLCB2LCBoKSAgIHsgT1BUSU9OX01BR05JVFVERSwgKHMpLCAobCksICh2KSwgXAoJCQkJICAgICAgTl8oIm4iKSwgKGgpLCBQQVJTRV9PUFRfTk9ORUcgfQojZGVmaW5lIE9QVF9TVFJJTkcocywgbCwgdiwgYSwgaCkgICB7IE9QVElPTl9TVFJJTkcsICAocyksIChsKSwgKHYpLCAoYSksIChoKSB9CiNkZWZpbmUgT1BUX1NUUklOR19MSVNUKHMsIGwsIHYsIGEsIGgpIFwKCQkJCSAgICB7IE9QVElPTl9DQUxMQkFDSywgKHMpLCAobCksICh2KSwgKGEpLCBcCgkJCQkgICAgICAoaCksIDAsICZwYXJzZV9vcHRfc3RyaW5nX2xpc3QgfQojZGVmaW5lIE9QVF9VWU4ocywgbCwgdiwgaCwgZikgICAgICB7IE9QVElPTl9DQUxMQkFDSywgKHMpLCAobCksICh2KSwgTlVMTCwgXAoJCQkJICAgICAgKGgpLCBQQVJTRV9PUFRfTk9BUkd8KGYpLCAmcGFyc2Vfb3B0X3RlcnRpYXJ5IH0KI2RlZmluZSBPUFRfREFURShzLCBsLCB2LCBoKSBcCgl7IE9QVElPTl9DQUxMQkFDSywgKHMpLCAobCksICh2KSwgTl8oInRpbWUiKSwoaCksIDAsCVwKCSAgcGFyc2Vfb3B0X2FwcHJveGlkYXRlX2NiIH0KI2RlZmluZSBPUFRfRVhQSVJZX0RBVEUocywgbCwgdiwgaCkgXAoJeyBPUFRJT05fQ0FMTEJBQ0ssIChzKSwgKGwpLCAodiksIE5fKCJleHBpcnktZGF0ZSIpLChoKSwgMCwJXAoJICBwYXJzZV9vcHRfZXhwaXJ5X2RhdGVfY2IgfQojZGVmaW5lIE9QVF9DQUxMQkFDSyhzLCBsLCB2LCBhLCBoLCBmKSBcCgl7IE9QVElPTl9DQUxMQkFDSywgKHMpLCAobCksICh2KSwgKGEpLCAoaCksIDAsIChmKSB9CiNkZWZpbmUgT1BUX05VTUJFUl9DQUxMQkFDSyh2LCBoLCBmKSBcCgl7IE9QVElPTl9OVU1CRVIsIDAsIE5VTEwsICh2KSwgTlVMTCwgKGgpLCBcCgkgIFBBUlNFX09QVF9OT0FSRyB8IFBBUlNFX09QVF9OT05FRywgKGYpIH0KI2RlZmluZSBPUFRfRklMRU5BTUUocywgbCwgdiwgaCkgICAgeyBPUFRJT05fRklMRU5BTUUsIChzKSwgKGwpLCAodiksIFwKCQkJCSAgICAgICBOXygiZmlsZSIpLCAoaCkgfQojZGVmaW5lIE9QVF9DT0xPUl9GTEFHKHMsIGwsIHYsIGgpIFwKCXsgT1BUSU9OX0NBTExCQUNLLCAocyksIChsKSwgKHYpLCBOXygid2hlbiIpLCAoaCksIFBBUlNFX09QVF9PUFRBUkcsIFwKCQlwYXJzZV9vcHRfY29sb3JfZmxhZ19jYiwgKGludHB0cl90KSJhbHdheXMiIH0KCiNkZWZpbmUgT1BUX05PT1BfTk9BUkcocywgbCkgXAoJeyBPUFRJT05fQ0FMTEJBQ0ssIChzKSwgKGwpLCBOVUxMLCBOVUxMLCBcCgkgIE5fKCJuby1vcCAoYmFja3dhcmQgY29tcGF0aWJpbGl0eSkiKSwJCVwKCSAgUEFSU0VfT1BUX0hJRERFTiB8IFBBUlNFX09QVF9OT0FSRywgcGFyc2Vfb3B0X25vb3BfY2IgfQoKLyogcGFyc2Vfb3B0aW9ucygpIHdpbGwgZmlsdGVyIG91dCB0aGUgcHJvY2Vzc2VkIG9wdGlvbnMgYW5kIGxlYXZlIHRoZQogKiBub24tb3B0aW9uIGFyZ3VtZW50cyBpbiBhcmd2W10uIHVzYWdlc3RyIHN0cmluZ3Mgc2hvdWxkIGJlIG1hcmtlZAogKiBmb3IgdHJhbnNsYXRpb24gd2l0aCBOXygpLgogKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGxlZnQgaW4gYXJndltdLgogKi8KZXh0ZXJuIGludCBwYXJzZV9vcHRpb25zKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4LAogICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0aW9ucywKICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYXIgKiBjb25zdCB1c2FnZXN0cltdLCBpbnQgZmxhZ3MpOwoKZXh0ZXJuIE5PUkVUVVJOIHZvaWQgdXNhZ2Vfd2l0aF9vcHRpb25zKGNvbnN0IGNoYXIgKiBjb25zdCAqdXNhZ2VzdHIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRpb25zKTsKCmV4dGVybiBOT1JFVFVSTiB2b2lkIHVzYWdlX21zZ19vcHQoY29uc3QgY2hhciAqbXNnLAoJCQkJICAgY29uc3QgY2hhciAqIGNvbnN0ICp1c2FnZXN0ciwKCQkJCSAgIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdGlvbnMpOwoKZXh0ZXJuIGludCBvcHRidWcoY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICpyZWFzb24pOwpleHRlcm4gaW50IG9wdGVycm9yKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqcmVhc29uLCBpbnQgZmxhZ3MpOwojaWYgZGVmaW5lZChfX0dOVUNfXykKI2RlZmluZSBvcHRlcnJvcihvLHIsZikgKG9wdGVycm9yKChvKSwociksKGYpKSwgY29uc3RfZXJyb3IoKSkKI2VuZGlmCgovKi0tLS0tIGluY3JlbWVudGFsIGFkdmFuY2VkIEFQSXMgLS0tLS0qLwoKZW51bSB7CglQQVJTRV9PUFRfSEVMUCA9IC0xLAoJUEFSU0VfT1BUX0RPTkUsCglQQVJTRV9PUFRfTk9OX09QVElPTiwKCVBBUlNFX09QVF9VTktOT1dOCn07CgovKgogKiBJdCdzIG9rYXkgZm9yIHRoZSBjYWxsZXIgdG8gY29uc3VtZSBhcmd2L2FyZ2MgaW4gdGhlIHVzdWFsIHdheS4KICogT3RoZXIgZmllbGRzIG9mIHRoYXQgc3RydWN0dXJlIGFyZSBwcml2YXRlIHRvIHBhcnNlLW9wdGlvbnMgYW5kIHNob3VsZCBub3QKICogYmUgbW9kaWZpZWQgaW4gYW55IHdheS4KICovCnN0cnVjdCBwYXJzZV9vcHRfY3R4X3QgewoJY29uc3QgY2hhciAqKmFyZ3Y7Cgljb25zdCBjaGFyICoqb3V0OwoJaW50IGFyZ2MsIGNwaWR4LCB0b3RhbDsKCWNvbnN0IGNoYXIgKm9wdDsKCWludCBmbGFnczsKCWNvbnN0IGNoYXIgKnByZWZpeDsKfTsKCmV4dGVybiB2b2lkIHBhcnNlX29wdGlvbnNfc3RhcnQoc3RydWN0IHBhcnNlX29wdF9jdHhfdCAqY3R4LAoJCQkJaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgsCgkJCQljb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRpb25zLCBpbnQgZmxhZ3MpOwoKZXh0ZXJuIGludCBwYXJzZV9vcHRpb25zX3N0ZXAoc3RydWN0IHBhcnNlX29wdF9jdHhfdCAqY3R4LAoJCQkgICAgICBjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRpb25zLAoJCQkgICAgICBjb25zdCBjaGFyICogY29uc3QgdXNhZ2VzdHJbXSk7CgpleHRlcm4gaW50IHBhcnNlX29wdGlvbnNfZW5kKHN0cnVjdCBwYXJzZV9vcHRfY3R4X3QgKmN0eCk7CgpleHRlcm4gc3RydWN0IG9wdGlvbiAqcGFyc2Vfb3B0aW9uc19jb25jYXQoc3RydWN0IG9wdGlvbiAqYSwgc3RydWN0IG9wdGlvbiAqYik7CgovKi0tLS0tIHNvbWUgb2Z0ZW4gdXNlZCBvcHRpb25zIC0tLS0tKi8KZXh0ZXJuIGludCBwYXJzZV9vcHRfYWJicmV2X2NiKGNvbnN0IHN0cnVjdCBvcHRpb24gKiwgY29uc3QgY2hhciAqLCBpbnQpOwpleHRlcm4gaW50IHBhcnNlX29wdF9hcHByb3hpZGF0ZV9jYihjb25zdCBzdHJ1Y3Qgb3B0aW9uICosIGNvbnN0IGNoYXIgKiwgaW50KTsKZXh0ZXJuIGludCBwYXJzZV9vcHRfZXhwaXJ5X2RhdGVfY2IoY29uc3Qgc3RydWN0IG9wdGlvbiAqLCBjb25zdCBjaGFyICosIGludCk7CmV4dGVybiBpbnQgcGFyc2Vfb3B0X2NvbG9yX2ZsYWdfY2IoY29uc3Qgc3RydWN0IG9wdGlvbiAqLCBjb25zdCBjaGFyICosIGludCk7CmV4dGVybiBpbnQgcGFyc2Vfb3B0X3ZlcmJvc2l0eV9jYihjb25zdCBzdHJ1Y3Qgb3B0aW9uICosIGNvbnN0IGNoYXIgKiwgaW50KTsKZXh0ZXJuIGludCBwYXJzZV9vcHRfb2JqZWN0X25hbWUoY29uc3Qgc3RydWN0IG9wdGlvbiAqLCBjb25zdCBjaGFyICosIGludCk7CmV4dGVybiBpbnQgcGFyc2Vfb3B0X2NvbW1pdHMoY29uc3Qgc3RydWN0IG9wdGlvbiAqLCBjb25zdCBjaGFyICosIGludCk7CmV4dGVybiBpbnQgcGFyc2Vfb3B0X3RlcnRpYXJ5KGNvbnN0IHN0cnVjdCBvcHRpb24gKiwgY29uc3QgY2hhciAqLCBpbnQpOwpleHRlcm4gaW50IHBhcnNlX29wdF9zdHJpbmdfbGlzdChjb25zdCBzdHJ1Y3Qgb3B0aW9uICosIGNvbnN0IGNoYXIgKiwgaW50KTsKZXh0ZXJuIGludCBwYXJzZV9vcHRfbm9vcF9jYihjb25zdCBzdHJ1Y3Qgb3B0aW9uICosIGNvbnN0IGNoYXIgKiwgaW50KTsKZXh0ZXJuIGludCBwYXJzZV9vcHRfdW5rbm93bl9jYihjb25zdCBzdHJ1Y3Qgb3B0aW9uICosIGNvbnN0IGNoYXIgKiwgaW50KTsKZXh0ZXJuIGludCBwYXJzZV9vcHRfcGFzc3RocnUoY29uc3Qgc3RydWN0IG9wdGlvbiAqLCBjb25zdCBjaGFyICosIGludCk7CmV4dGVybiBpbnQgcGFyc2Vfb3B0X3Bhc3N0aHJ1X2FyZ3YoY29uc3Qgc3RydWN0IG9wdGlvbiAqLCBjb25zdCBjaGFyICosIGludCk7CgojZGVmaW5lIE9QVF9fVkVSQk9TRSh2YXIsIGgpICBPUFRfQ09VTlRVUCgndicsICJ2ZXJib3NlIiwgKHZhciksIChoKSkKI2RlZmluZSBPUFRfX1FVSUVUKHZhciwgaCkgICAgT1BUX0NPVU5UVVAoJ3EnLCAicXVpZXQiLCAgICh2YXIpLCAoaCkpCiNkZWZpbmUgT1BUX19WRVJCT1NJVFkodmFyKSBcCgl7IE9QVElPTl9DQUxMQkFDSywgJ3YnLCAidmVyYm9zZSIsICh2YXIpLCBOVUxMLCBOXygiYmUgbW9yZSB2ZXJib3NlIiksIFwKCSAgUEFSU0VfT1BUX05PQVJHLCAmcGFyc2Vfb3B0X3ZlcmJvc2l0eV9jYiwgMCB9LCBcCgl7IE9QVElPTl9DQUxMQkFDSywgJ3EnLCAicXVpZXQiLCAodmFyKSwgTlVMTCwgTl8oImJlIG1vcmUgcXVpZXQiKSwgXAoJICBQQVJTRV9PUFRfTk9BUkcsICZwYXJzZV9vcHRfdmVyYm9zaXR5X2NiLCAwIH0KI2RlZmluZSBPUFRfX0RSWV9SVU4odmFyLCBoKSAgT1BUX0JPT0woJ24nLCAiZHJ5LXJ1biIsICh2YXIpLCAoaCkpCiNkZWZpbmUgT1BUX19GT1JDRSh2YXIsIGgsIGYpIE9QVF9DT1VOVFVQX0YoJ2YnLCAiZm9yY2UiLCAgICh2YXIpLCAoaCksIChmKSkKI2RlZmluZSBPUFRfX0FCQlJFVih2YXIpICBcCgl7IE9QVElPTl9DQUxMQkFDSywgMCwgImFiYnJldiIsICh2YXIpLCBOXygibiIpLAlcCgkgIE5fKCJ1c2UgPG4+IGRpZ2l0cyB0byBkaXNwbGF5IFNIQS0xcyIpLAlcCgkgIFBBUlNFX09QVF9PUFRBUkcsICZwYXJzZV9vcHRfYWJicmV2X2NiLCAwIH0KI2RlZmluZSBPUFRfX0NPTE9SKHZhciwgaCkgXAoJT1BUX0NPTE9SX0ZMQUcoMCwgImNvbG9yIiwgKHZhciksIChoKSkKI2RlZmluZSBPUFRfQ09MVU1OKHMsIGwsIHYsIGgpIFwKCXsgT1BUSU9OX0NBTExCQUNLLCAocyksIChsKSwgKHYpLCBOXygic3R5bGUiKSwgKGgpLCBQQVJTRV9PUFRfT1BUQVJHLCBwYXJzZW9wdF9jb2x1bW5fY2FsbGJhY2sgfQojZGVmaW5lIE9QVF9QQVNTVEhSVShzLCBsLCB2LCBhLCBoLCBmKSBcCgl7IE9QVElPTl9DQUxMQkFDSywgKHMpLCAobCksICh2KSwgKGEpLCAoaCksIChmKSwgcGFyc2Vfb3B0X3Bhc3N0aHJ1IH0KI2RlZmluZSBPUFRfUEFTU1RIUlVfQVJHVihzLCBsLCB2LCBhLCBoLCBmKSBcCgl7IE9QVElPTl9DQUxMQkFDSywgKHMpLCAobCksICh2KSwgKGEpLCAoaCksIChmKSwgcGFyc2Vfb3B0X3Bhc3N0aHJ1X2FyZ3YgfQojZGVmaW5lIF9PUFRfQ09OVEFJTlNfT1JfV0lUSChuYW1lLCB2YXJpYWJsZSwgaGVscCwgZmxhZykgXAoJeyBPUFRJT05fQ0FMTEJBQ0ssIDAsIG5hbWUsICh2YXJpYWJsZSksIE5fKCJjb21taXQiKSwgKGhlbHApLCBcCgkgIFBBUlNFX09QVF9MQVNUQVJHX0RFRkFVTFQgfCBmbGFnLCBcCgkgIHBhcnNlX29wdF9jb21taXRzLCAoaW50cHRyX3QpICJIRUFEIiBcCgl9CiNkZWZpbmUgT1BUX0NPTlRBSU5TKHYsIGgpIF9PUFRfQ09OVEFJTlNfT1JfV0lUSCgiY29udGFpbnMiLCB2LCBoLCBQQVJTRV9PUFRfTk9ORUcpCiNkZWZpbmUgT1BUX05PX0NPTlRBSU5TKHYsIGgpIF9PUFRfQ09OVEFJTlNfT1JfV0lUSCgibm8tY29udGFpbnMiLCB2LCBoLCBQQVJTRV9PUFRfTk9ORUcpCiNkZWZpbmUgT1BUX1dJVEgodiwgaCkgX09QVF9DT05UQUlOU19PUl9XSVRIKCJ3aXRoIiwgdiwgaCwgUEFSU0VfT1BUX0hJRERFTiB8IFBBUlNFX09QVF9OT05FRykKI2RlZmluZSBPUFRfV0lUSE9VVCh2LCBoKSBfT1BUX0NPTlRBSU5TX09SX1dJVEgoIndpdGhvdXQiLCB2LCBoLCBQQVJTRV9PUFRfSElEREVOIHwgUEFSU0VfT1BUX05PTkVHKQoKI2VuZGlmCg==",
    "text": "#ifndef PARSE_OPTIONS_H\n#define PARSE_OPTIONS_H\n\nenum parse_opt_type {\n\t/* special types */\n\tOPTION_END,\n\tOPTION_ARGUMENT,\n\tOPTION_GROUP,\n\tOPTION_NUMBER,\n\t/* options with no arguments */\n\tOPTION_BIT,\n\tOPTION_NEGBIT,\n\tOPTION_COUNTUP,\n\tOPTION_SET_INT,\n\tOPTION_CMDMODE,\n\t/* options with arguments (usually) */\n\tOPTION_STRING,\n\tOPTION_INTEGER,\n\tOPTION_MAGNITUDE,\n\tOPTION_CALLBACK,\n\tOPTION_LOWLEVEL_CALLBACK,\n\tOPTION_FILENAME\n};\n\nenum parse_opt_flags {\n\tPARSE_OPT_KEEP_DASHDASH = 1,\n\tPARSE_OPT_STOP_AT_NON_OPTION = 2,\n\tPARSE_OPT_KEEP_ARGV0 = 4,\n\tPARSE_OPT_KEEP_UNKNOWN = 8,\n\tPARSE_OPT_NO_INTERNAL_HELP = 16\n};\n\nenum parse_opt_option_flags {\n\tPARSE_OPT_OPTARG  = 1,\n\tPARSE_OPT_NOARG   = 2,\n\tPARSE_OPT_NONEG   = 4,\n\tPARSE_OPT_HIDDEN  = 8,\n\tPARSE_OPT_LASTARG_DEFAULT = 16,\n\tPARSE_OPT_NODASH = 32,\n\tPARSE_OPT_LITERAL_ARGHELP = 64,\n\tPARSE_OPT_SHELL_EVAL = 256,\n\tPARSE_OPT_NOCOMPLETE = 512\n};\n\nstruct option;\ntypedef int parse_opt_cb(const struct option *, const char *arg, int unset);\n\nstruct parse_opt_ctx_t;\ntypedef int parse_opt_ll_cb(struct parse_opt_ctx_t *ctx,\n\t\t\t\tconst struct option *opt, int unset);\n\n/*\n * `type`::\n *   holds the type of the option, you must have an OPTION_END last in your\n *   array.\n *\n * `short_name`::\n *   the character to use as a short option name, '\\0' if none.\n *\n * `long_name`::\n *   the long option name, without the leading dashes, NULL if none.\n *\n * `value`::\n *   stores pointers to the values to be filled.\n *\n * `argh`::\n *   token to explain the kind of argument this option wants. Keep it\n *   homogeneous across the repository. Should be wrapped by N_() for\n *   translation.\n *\n * `help`::\n *   the short help associated to what the option does.\n *   Must never be NULL (except for OPTION_END).\n *   OPTION_GROUP uses this pointer to store the group header.\n *   Should be wrapped by N_() for translation.\n *\n * `flags`::\n *   mask of parse_opt_option_flags.\n *   PARSE_OPT_OPTARG: says that the argument is optional (not for BOOLEANs)\n *   PARSE_OPT_NOARG: says that this option does not take an argument\n *   PARSE_OPT_NONEG: says that this option cannot be negated\n *   PARSE_OPT_HIDDEN: this option is skipped in the default usage, and\n *                     shown only in the full usage.\n *   PARSE_OPT_LASTARG_DEFAULT: says that this option will take the default\n *\t\t\t\tvalue if no argument is given when the option\n *\t\t\t\tis last on the command line. If the option is\n *\t\t\t\tnot last it will require an argument.\n *\t\t\t\tShould not be used with PARSE_OPT_OPTARG.\n *   PARSE_OPT_NODASH: this option doesn't start with a dash.\n *   PARSE_OPT_LITERAL_ARGHELP: says that argh shouldn't be enclosed in brackets\n *\t\t\t\t(i.e. '<argh>') in the help message.\n *\t\t\t\tUseful for options with multiple parameters.\n *   PARSE_OPT_NOCOMPLETE: by default all visible options are completable\n *\t\t\t   by git-completion.bash. This option suppresses that.\n *\n * `callback`::\n *   pointer to the callback to use for OPTION_CALLBACK or\n *   OPTION_LOWLEVEL_CALLBACK.\n *\n * `defval`::\n *   default value to fill (*->value) with for PARSE_OPT_OPTARG.\n *   OPTION_{BIT,SET_INT} store the {mask,integer} to put in the value when met.\n *   CALLBACKS can use it like they want.\n */\nstruct option {\n\tenum parse_opt_type type;\n\tint short_name;\n\tconst char *long_name;\n\tvoid *value;\n\tconst char *argh;\n\tconst char *help;\n\n\tint flags;\n\tparse_opt_cb *callback;\n\tintptr_t defval;\n};\n\n#define OPT_BIT_F(s, l, v, h, b, f) { OPTION_BIT, (s), (l), (v), NULL, (h), \\\n\t\t\t\t      PARSE_OPT_NOARG|(f), NULL, (b) }\n#define OPT_COUNTUP_F(s, l, v, h, f) { OPTION_COUNTUP, (s), (l), (v), NULL, \\\n\t\t\t\t       (h), PARSE_OPT_NOARG|(f) }\n#define OPT_SET_INT_F(s, l, v, h, i, f) { OPTION_SET_INT, (s), (l), (v), NULL, \\\n\t\t\t\t\t  (h), PARSE_OPT_NOARG | (f), NULL, (i) }\n#define OPT_BOOL_F(s, l, v, h, f)   OPT_SET_INT_F(s, l, v, h, 1, f)\n\n#define OPT_END()                   { OPTION_END }\n#define OPT_ARGUMENT(l, h)          { OPTION_ARGUMENT, 0, (l), NULL, NULL, \\\n\t\t\t\t      (h), PARSE_OPT_NOARG}\n#define OPT_GROUP(h)                { OPTION_GROUP, 0, NULL, NULL, NULL, (h) }\n#define OPT_BIT(s, l, v, h, b)      OPT_BIT_F(s, l, v, h, b, 0)\n#define OPT_NEGBIT(s, l, v, h, b)   { OPTION_NEGBIT, (s), (l), (v), NULL, \\\n\t\t\t\t      (h), PARSE_OPT_NOARG, NULL, (b) }\n#define OPT_COUNTUP(s, l, v, h)     OPT_COUNTUP_F(s, l, v, h, 0)\n#define OPT_SET_INT(s, l, v, h, i)  OPT_SET_INT_F(s, l, v, h, i, 0)\n#define OPT_BOOL(s, l, v, h)        OPT_BOOL_F(s, l, v, h, 0)\n#define OPT_HIDDEN_BOOL(s, l, v, h) { OPTION_SET_INT, (s), (l), (v), NULL, \\\n\t\t\t\t      (h), PARSE_OPT_NOARG | PARSE_OPT_HIDDEN, NULL, 1}\n#define OPT_CMDMODE(s, l, v, h, i)  { OPTION_CMDMODE, (s), (l), (v), NULL, \\\n\t\t\t\t      (h), PARSE_OPT_NOARG|PARSE_OPT_NONEG, NULL, (i) }\n#define OPT_INTEGER(s, l, v, h)     { OPTION_INTEGER, (s), (l), (v), N_(\"n\"), (h) }\n#define OPT_MAGNITUDE(s, l, v, h)   { OPTION_MAGNITUDE, (s), (l), (v), \\\n\t\t\t\t      N_(\"n\"), (h), PARSE_OPT_NONEG }\n#define OPT_STRING(s, l, v, a, h)   { OPTION_STRING,  (s), (l), (v), (a), (h) }\n#define OPT_STRING_LIST(s, l, v, a, h) \\\n\t\t\t\t    { OPTION_CALLBACK, (s), (l), (v), (a), \\\n\t\t\t\t      (h), 0, &parse_opt_string_list }\n#define OPT_UYN(s, l, v, h, f)      { OPTION_CALLBACK, (s), (l), (v), NULL, \\\n\t\t\t\t      (h), PARSE_OPT_NOARG|(f), &parse_opt_tertiary }\n#define OPT_DATE(s, l, v, h) \\\n\t{ OPTION_CALLBACK, (s), (l), (v), N_(\"time\"),(h), 0,\t\\\n\t  parse_opt_approxidate_cb }\n#define OPT_EXPIRY_DATE(s, l, v, h) \\\n\t{ OPTION_CALLBACK, (s), (l), (v), N_(\"expiry-date\"),(h), 0,\t\\\n\t  parse_opt_expiry_date_cb }\n#define OPT_CALLBACK(s, l, v, a, h, f) \\\n\t{ OPTION_CALLBACK, (s), (l), (v), (a), (h), 0, (f) }\n#define OPT_NUMBER_CALLBACK(v, h, f) \\\n\t{ OPTION_NUMBER, 0, NULL, (v), NULL, (h), \\\n\t  PARSE_OPT_NOARG | PARSE_OPT_NONEG, (f) }\n#define OPT_FILENAME(s, l, v, h)    { OPTION_FILENAME, (s), (l), (v), \\\n\t\t\t\t       N_(\"file\"), (h) }\n#define OPT_COLOR_FLAG(s, l, v, h) \\\n\t{ OPTION_CALLBACK, (s), (l), (v), N_(\"when\"), (h), PARSE_OPT_OPTARG, \\\n\t\tparse_opt_color_flag_cb, (intptr_t)\"always\" }\n\n#define OPT_NOOP_NOARG(s, l) \\\n\t{ OPTION_CALLBACK, (s), (l), NULL, NULL, \\\n\t  N_(\"no-op (backward compatibility)\"),\t\t\\\n\t  PARSE_OPT_HIDDEN | PARSE_OPT_NOARG, parse_opt_noop_cb }\n\n/* parse_options() will filter out the processed options and leave the\n * non-option arguments in argv[]. usagestr strings should be marked\n * for translation with N_().\n * Returns the number of arguments left in argv[].\n */\nextern int parse_options(int argc, const char **argv, const char *prefix,\n                         const struct option *options,\n                         const char * const usagestr[], int flags);\n\nextern NORETURN void usage_with_options(const char * const *usagestr,\n                                        const struct option *options);\n\nextern NORETURN void usage_msg_opt(const char *msg,\n\t\t\t\t   const char * const *usagestr,\n\t\t\t\t   const struct option *options);\n\nextern int optbug(const struct option *opt, const char *reason);\nextern int opterror(const struct option *opt, const char *reason, int flags);\n#if defined(__GNUC__)\n#define opterror(o,r,f) (opterror((o),(r),(f)), const_error())\n#endif\n\n/*----- incremental advanced APIs -----*/\n\nenum {\n\tPARSE_OPT_HELP = -1,\n\tPARSE_OPT_DONE,\n\tPARSE_OPT_NON_OPTION,\n\tPARSE_OPT_UNKNOWN\n};\n\n/*\n * It's okay for the caller to consume argv/argc in the usual way.\n * Other fields of that structure are private to parse-options and should not\n * be modified in any way.\n */\nstruct parse_opt_ctx_t {\n\tconst char **argv;\n\tconst char **out;\n\tint argc, cpidx, total;\n\tconst char *opt;\n\tint flags;\n\tconst char *prefix;\n};\n\nextern void parse_options_start(struct parse_opt_ctx_t *ctx,\n\t\t\t\tint argc, const char **argv, const char *prefix,\n\t\t\t\tconst struct option *options, int flags);\n\nextern int parse_options_step(struct parse_opt_ctx_t *ctx,\n\t\t\t      const struct option *options,\n\t\t\t      const char * const usagestr[]);\n\nextern int parse_options_end(struct parse_opt_ctx_t *ctx);\n\nextern struct option *parse_options_concat(struct option *a, struct option *b);\n\n/*----- some often used options -----*/\nextern int parse_opt_abbrev_cb(const struct option *, const char *, int);\nextern int parse_opt_approxidate_cb(const struct option *, const char *, int);\nextern int parse_opt_expiry_date_cb(const struct option *, const char *, int);\nextern int parse_opt_color_flag_cb(const struct option *, const char *, int);\nextern int parse_opt_verbosity_cb(const struct option *, const char *, int);\nextern int parse_opt_object_name(const struct option *, const char *, int);\nextern int parse_opt_commits(const struct option *, const char *, int);\nextern int parse_opt_tertiary(const struct option *, const char *, int);\nextern int parse_opt_string_list(const struct option *, const char *, int);\nextern int parse_opt_noop_cb(const struct option *, const char *, int);\nextern int parse_opt_unknown_cb(const struct option *, const char *, int);\nextern int parse_opt_passthru(const struct option *, const char *, int);\nextern int parse_opt_passthru_argv(const struct option *, const char *, int);\n\n#define OPT__VERBOSE(var, h)  OPT_COUNTUP('v', \"verbose\", (var), (h))\n#define OPT__QUIET(var, h)    OPT_COUNTUP('q', \"quiet\",   (var), (h))\n#define OPT__VERBOSITY(var) \\\n\t{ OPTION_CALLBACK, 'v', \"verbose\", (var), NULL, N_(\"be more verbose\"), \\\n\t  PARSE_OPT_NOARG, &parse_opt_verbosity_cb, 0 }, \\\n\t{ OPTION_CALLBACK, 'q', \"quiet\", (var), NULL, N_(\"be more quiet\"), \\\n\t  PARSE_OPT_NOARG, &parse_opt_verbosity_cb, 0 }\n#define OPT__DRY_RUN(var, h)  OPT_BOOL('n', \"dry-run\", (var), (h))\n#define OPT__FORCE(var, h, f) OPT_COUNTUP_F('f', \"force\",   (var), (h), (f))\n#define OPT__ABBREV(var)  \\\n\t{ OPTION_CALLBACK, 0, \"abbrev\", (var), N_(\"n\"),\t\\\n\t  N_(\"use <n> digits to display SHA-1s\"),\t\\\n\t  PARSE_OPT_OPTARG, &parse_opt_abbrev_cb, 0 }\n#define OPT__COLOR(var, h) \\\n\tOPT_COLOR_FLAG(0, \"color\", (var), (h))\n#define OPT_COLUMN(s, l, v, h) \\\n\t{ OPTION_CALLBACK, (s), (l), (v), N_(\"style\"), (h), PARSE_OPT_OPTARG, parseopt_column_callback }\n#define OPT_PASSTHRU(s, l, v, a, h, f) \\\n\t{ OPTION_CALLBACK, (s), (l), (v), (a), (h), (f), parse_opt_passthru }\n#define OPT_PASSTHRU_ARGV(s, l, v, a, h, f) \\\n\t{ OPTION_CALLBACK, (s), (l), (v), (a), (h), (f), parse_opt_passthru_argv }\n#define _OPT_CONTAINS_OR_WITH(name, variable, help, flag) \\\n\t{ OPTION_CALLBACK, 0, name, (variable), N_(\"commit\"), (help), \\\n\t  PARSE_OPT_LASTARG_DEFAULT | flag, \\\n\t  parse_opt_commits, (intptr_t) \"HEAD\" \\\n\t}\n#define OPT_CONTAINS(v, h) _OPT_CONTAINS_OR_WITH(\"contains\", v, h, PARSE_OPT_NONEG)\n#define OPT_NO_CONTAINS(v, h) _OPT_CONTAINS_OR_WITH(\"no-contains\", v, h, PARSE_OPT_NONEG)\n#define OPT_WITH(v, h) _OPT_CONTAINS_OR_WITH(\"with\", v, h, PARSE_OPT_HIDDEN | PARSE_OPT_NONEG)\n#define OPT_WITHOUT(v, h) _OPT_CONTAINS_OR_WITH(\"without\", v, h, PARSE_OPT_HIDDEN | PARSE_OPT_NONEG)\n\n#endif\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "009cd863e5b0aa50af365dc027d89baf9c44e953",
  "sha1_ok": true,
  "size": 10777
}
