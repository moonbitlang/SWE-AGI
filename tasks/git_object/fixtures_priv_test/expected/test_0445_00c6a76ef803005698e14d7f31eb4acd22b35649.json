{
  "content": {
    "base64": "I2lmbmRlZiBSRU1PVEVfSAojZGVmaW5lIFJFTU9URV9ICgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgoKZW51bSB7CglSRU1PVEVfQ09ORklHLAoJUkVNT1RFX1JFTU9URVMsCglSRU1PVEVfQlJBTkNIRVMKfTsKCnN0cnVjdCByZW1vdGUgewoJY29uc3QgY2hhciAqbmFtZTsKCWludCBvcmlnaW47CgoJY29uc3QgY2hhciAqZm9yZWlnbl92Y3M7CgoJY29uc3QgY2hhciAqKnVybDsKCWludCB1cmxfbnI7CglpbnQgdXJsX2FsbG9jOwoKCWNvbnN0IGNoYXIgKipwdXNodXJsOwoJaW50IHB1c2h1cmxfbnI7CglpbnQgcHVzaHVybF9hbGxvYzsKCgljb25zdCBjaGFyICoqcHVzaF9yZWZzcGVjOwoJc3RydWN0IHJlZnNwZWMgKnB1c2g7CglpbnQgcHVzaF9yZWZzcGVjX25yOwoJaW50IHB1c2hfcmVmc3BlY19hbGxvYzsKCgljb25zdCBjaGFyICoqZmV0Y2hfcmVmc3BlYzsKCXN0cnVjdCByZWZzcGVjICpmZXRjaDsKCWludCBmZXRjaF9yZWZzcGVjX25yOwoJaW50IGZldGNoX3JlZnNwZWNfYWxsb2M7CgoJLyoKCSAqIC0xIHRvIG5ldmVyIGZldGNoIHRhZ3MKCSAqIDAgdG8gYXV0by1mb2xsb3cgdGFncyBvbiBoZXVyaXN0aWMgKGRlZmF1bHQpCgkgKiAxIHRvIGFsd2F5cyBhdXRvLWZvbGxvdyB0YWdzCgkgKiAyIHRvIGFsd2F5cyBmZXRjaCB0YWdzCgkgKi8KCWludCBmZXRjaF90YWdzOwoJaW50IHNraXBfZGVmYXVsdF91cGRhdGU7CglpbnQgbWlycm9yOwoJaW50IHBydW5lOwoKCWNvbnN0IGNoYXIgKnJlY2VpdmVwYWNrOwoJY29uc3QgY2hhciAqdXBsb2FkcGFjazsKCgkvKgoJICogZm9yIGN1cmwgcmVtb3RlcyBvbmx5CgkgKi8KCWNoYXIgKmh0dHBfcHJveHk7Cn07CgpzdHJ1Y3QgcmVtb3RlICpyZW1vdGVfZ2V0KGNvbnN0IGNoYXIgKm5hbWUpOwpzdHJ1Y3QgcmVtb3RlICpwdXNocmVtb3RlX2dldChjb25zdCBjaGFyICpuYW1lKTsKaW50IHJlbW90ZV9pc19jb25maWd1cmVkKGNvbnN0IGNoYXIgKm5hbWUpOwoKdHlwZWRlZiBpbnQgZWFjaF9yZW1vdGVfZm4oc3RydWN0IHJlbW90ZSAqcmVtb3RlLCB2b2lkICpwcml2KTsKaW50IGZvcl9lYWNoX3JlbW90ZShlYWNoX3JlbW90ZV9mbiBmbiwgdm9pZCAqcHJpdik7CgppbnQgcmVtb3RlX2hhc191cmwoc3RydWN0IHJlbW90ZSAqcmVtb3RlLCBjb25zdCBjaGFyICp1cmwpOwoKc3RydWN0IHJlZnNwZWMgewoJdW5zaWduZWQgZm9yY2UgOiAxOwoJdW5zaWduZWQgcGF0dGVybiA6IDE7Cgl1bnNpZ25lZCBtYXRjaGluZyA6IDE7Cgl1bnNpZ25lZCBleGFjdF9zaGExIDogMTsKCgljaGFyICpzcmM7CgljaGFyICpkc3Q7Cn07CgpleHRlcm4gY29uc3Qgc3RydWN0IHJlZnNwZWMgKnRhZ19yZWZzcGVjOwoKc3RydWN0IHJlZiB7CglzdHJ1Y3QgcmVmICpuZXh0OwoJdW5zaWduZWQgY2hhciBvbGRfc2hhMVsyMF07Cgl1bnNpZ25lZCBjaGFyIG5ld19zaGExWzIwXTsKCXVuc2lnbmVkIGNoYXIgb2xkX3NoYTFfZXhwZWN0WzIwXTsgLyogdXNlZCBieSBleHBlY3Qtb2xkICovCgljaGFyICpzeW1yZWY7Cgl1bnNpZ25lZCBpbnQKCQlmb3JjZToxLAoJCWZvcmNlZF91cGRhdGU6MSwKCQlleHBlY3Rfb2xkX3NoYTE6MSwKCQlleHBlY3Rfb2xkX25vX3RyYWNrYmFjazoxLAoJCWRlbGV0aW9uOjEsCgkJbWF0Y2hlZDoxOwoKCS8qCgkgKiBPcmRlciBpcyBpbXBvcnRhbnQgaGVyZSwgYXMgd2Ugd3JpdGUgdG8gRkVUQ0hfSEVBRAoJICogaW4gbnVtZXJpYyBvcmRlci4gQW5kIHRoZSBkZWZhdWx0IE5PVF9GT1JfTUVSR0UKCSAqIHNob3VsZCBiZSAwLCBzbyB0aGF0IHhjYWxsb2MnZCBzdHJ1Y3R1cmVzIGdldCBpdAoJICogYnkgZGVmYXVsdC4KCSAqLwoJZW51bSB7CgkJRkVUQ0hfSEVBRF9NRVJHRSA9IC0xLAoJCUZFVENIX0hFQURfTk9UX0ZPUl9NRVJHRSA9IDAsCgkJRkVUQ0hfSEVBRF9JR05PUkUgPSAxCgl9IGZldGNoX2hlYWRfc3RhdHVzOwoKCWVudW0gewoJCVJFRl9TVEFUVVNfTk9ORSA9IDAsCgkJUkVGX1NUQVRVU19PSywKCQlSRUZfU1RBVFVTX1JFSkVDVF9OT05GQVNURk9SV0FSRCwKCQlSRUZfU1RBVFVTX1JFSkVDVF9BTFJFQURZX0VYSVNUUywKCQlSRUZfU1RBVFVTX1JFSkVDVF9OT0RFTEVURSwKCQlSRUZfU1RBVFVTX1JFSkVDVF9GRVRDSF9GSVJTVCwKCQlSRUZfU1RBVFVTX1JFSkVDVF9ORUVEU19GT1JDRSwKCQlSRUZfU1RBVFVTX1JFSkVDVF9TVEFMRSwKCQlSRUZfU1RBVFVTX1VQVE9EQVRFLAoJCVJFRl9TVEFUVVNfUkVNT1RFX1JFSkVDVCwKCQlSRUZfU1RBVFVTX0VYUEVDVElOR19SRVBPUlQKCX0gc3RhdHVzOwoJY2hhciAqcmVtb3RlX3N0YXR1czsKCXN0cnVjdCByZWYgKnBlZXJfcmVmOyAvKiB3aGVuIHJlbmFtaW5nICovCgljaGFyIG5hbWVbRkxFWF9BUlJBWV07IC8qIG1vcmUgKi8KfTsKCiNkZWZpbmUgUkVGX05PUk1BTAkoMXUgPDwgMCkKI2RlZmluZSBSRUZfSEVBRFMJKDF1IDw8IDEpCiNkZWZpbmUgUkVGX1RBR1MJKDF1IDw8IDIpCgpleHRlcm4gc3RydWN0IHJlZiAqZmluZF9yZWZfYnlfbmFtZShjb25zdCBzdHJ1Y3QgcmVmICpsaXN0LCBjb25zdCBjaGFyICpuYW1lKTsKCnN0cnVjdCByZWYgKmFsbG9jX3JlZihjb25zdCBjaGFyICpuYW1lKTsKc3RydWN0IHJlZiAqY29weV9yZWYoY29uc3Qgc3RydWN0IHJlZiAqcmVmKTsKc3RydWN0IHJlZiAqY29weV9yZWZfbGlzdChjb25zdCBzdHJ1Y3QgcmVmICpyZWYpOwp2b2lkIHNvcnRfcmVmX2xpc3Qoc3RydWN0IHJlZiAqKiwgaW50ICgqY21wKShjb25zdCB2b2lkICosIGNvbnN0IHZvaWQgKikpOwpleHRlcm4gaW50IGNvdW50X3JlZnNwZWNfbWF0Y2goY29uc3QgY2hhciAqLCBzdHJ1Y3QgcmVmICpyZWZzLCBzdHJ1Y3QgcmVmICoqbWF0Y2hlZF9yZWYpOwppbnQgcmVmX2NvbXBhcmVfbmFtZShjb25zdCB2b2lkICosIGNvbnN0IHZvaWQgKik7CgppbnQgY2hlY2tfcmVmX3R5cGUoY29uc3Qgc3RydWN0IHJlZiAqcmVmLCBpbnQgZmxhZ3MpOwoKLyoKICogRnJlZXMgdGhlIGVudGlyZSBsaXN0IGFuZCBwZWVycyBvZiBlbGVtZW50cy4KICovCnZvaWQgZnJlZV9yZWZzKHN0cnVjdCByZWYgKnJlZik7CgpzdHJ1Y3QgZXh0cmFfaGF2ZV9vYmplY3RzIHsKCWludCBuciwgYWxsb2M7Cgl1bnNpZ25lZCBjaGFyICgqYXJyYXkpWzIwXTsKfTsKZXh0ZXJuIHN0cnVjdCByZWYgKipnZXRfcmVtb3RlX2hlYWRzKGludCBpbiwgY2hhciAqc3JjX2J1Ziwgc2l6ZV90IHNyY19sZW4sCgkJCQkgICAgIHN0cnVjdCByZWYgKipsaXN0LCB1bnNpZ25lZCBpbnQgZmxhZ3MsCgkJCQkgICAgIHN0cnVjdCBleHRyYV9oYXZlX29iamVjdHMgKik7CgppbnQgcmVzb2x2ZV9yZW1vdGVfc3ltcmVmKHN0cnVjdCByZWYgKnJlZiwgc3RydWN0IHJlZiAqbGlzdCk7CmludCByZWZfbmV3ZXIoY29uc3QgdW5zaWduZWQgY2hhciAqbmV3X3NoYTEsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKm9sZF9zaGExKTsKCi8qCiAqIFJlbW92ZSBhbmQgZnJlZSBhbGwgYnV0IHRoZSBmaXJzdCBvZiBhbnkgZW50cmllcyBpbiB0aGUgaW5wdXQgbGlzdAogKiB0aGF0IG1hcCB0aGUgc2FtZSByZW1vdGUgcmVmZXJlbmNlIHRvIHRoZSBzYW1lIGxvY2FsIHJlZmVyZW5jZS4gIElmCiAqIHRoZXJlIGFyZSB0d28gZW50cmllcyB0aGF0IG1hcCBkaWZmZXJlbnQgcmVtb3RlIHJlZmVyZW5jZXMgdG8gdGhlCiAqIHNhbWUgbG9jYWwgcmVmZXJlbmNlLCBlbWl0IGFuIGVycm9yIG1lc3NhZ2UgYW5kIGRpZS4gIFJldHVybiBhCiAqIHBvaW50ZXIgdG8gdGhlIGhlYWQgb2YgdGhlIHJlc3VsdGluZyBsaXN0LgogKi8Kc3RydWN0IHJlZiAqcmVmX3JlbW92ZV9kdXBsaWNhdGVzKHN0cnVjdCByZWYgKnJlZl9tYXApOwoKaW50IHZhbGlkX2ZldGNoX3JlZnNwZWMoY29uc3QgY2hhciAqcmVmc3BlYyk7CnN0cnVjdCByZWZzcGVjICpwYXJzZV9mZXRjaF9yZWZzcGVjKGludCBucl9yZWZzcGVjLCBjb25zdCBjaGFyICoqcmVmc3BlYyk7Cgp2b2lkIGZyZWVfcmVmc3BlYyhpbnQgbnJfcmVmc3BlYywgc3RydWN0IHJlZnNwZWMgKnJlZnNwZWMpOwoKZXh0ZXJuIGludCBxdWVyeV9yZWZzcGVjcyhzdHJ1Y3QgcmVmc3BlYyAqc3BlY3MsIGludCBuciwgc3RydWN0IHJlZnNwZWMgKnF1ZXJ5KTsKY2hhciAqYXBwbHlfcmVmc3BlY3Moc3RydWN0IHJlZnNwZWMgKnJlZnNwZWNzLCBpbnQgbnJfcmVmc3BlYywKCQkgICAgIGNvbnN0IGNoYXIgKm5hbWUpOwoKaW50IG1hdGNoX3B1c2hfcmVmcyhzdHJ1Y3QgcmVmICpzcmMsIHN0cnVjdCByZWYgKipkc3QsCgkJICAgIGludCBucl9yZWZzcGVjLCBjb25zdCBjaGFyICoqcmVmc3BlYywgaW50IGFsbCk7CnZvaWQgc2V0X3JlZl9zdGF0dXNfZm9yX3B1c2goc3RydWN0IHJlZiAqcmVtb3RlX3JlZnMsIGludCBzZW5kX21pcnJvciwKCWludCBmb3JjZV91cGRhdGUpOwoKLyoKICogR2l2ZW4gYSBsaXN0IG9mIHRoZSByZW1vdGUgcmVmcyBhbmQgdGhlIHNwZWNpZmljYXRpb24gb2YgdGhpbmdzIHRvCiAqIGZldGNoLCBtYWtlcyBhIChzZXBhcmF0ZSkgbGlzdCBvZiB0aGUgcmVmcyB0byBmZXRjaCBhbmQgdGhlIGxvY2FsCiAqIHJlZnMgdG8gc3RvcmUgaW50by4KICoKICogKnRhaWwgaXMgdGhlIHBvaW50ZXIgdG8gdGhlIHRhaWwgcG9pbnRlciBvZiB0aGUgbGlzdCBvZiByZXN1bHRzCiAqIGJlZm9yZWhhbmQsIGFuZCB3aWxsIGJlIHNldCB0byB0aGUgdGFpbCBwb2ludGVyIG9mIHRoZSBsaXN0IG9mCiAqIHJlc3VsdHMgYWZ0ZXJ3YXJkLgogKgogKiBtaXNzaW5nX29rIGlzIHVzdWFsbHkgZmFsc2UsIGJ1dCB3aGVuIHdlIGFyZSBhZGRpbmcgYnJhbmNoLiRuYW1lLm1lcmdlCiAqIGl0IGlzIE9rIGlmIHRoZSBicmFuY2ggaXMgbm90IGF0IHRoZSByZW1vdGUgYW55bW9yZS4KICovCmludCBnZXRfZmV0Y2hfbWFwKGNvbnN0IHN0cnVjdCByZWYgKnJlbW90ZV9yZWZzLCBjb25zdCBzdHJ1Y3QgcmVmc3BlYyAqcmVmc3BlYywKCQkgIHN0cnVjdCByZWYgKioqdGFpbCwgaW50IG1pc3Npbmdfb2spOwoKc3RydWN0IHJlZiAqZ2V0X3JlbW90ZV9yZWYoY29uc3Qgc3RydWN0IHJlZiAqcmVtb3RlX3JlZnMsIGNvbnN0IGNoYXIgKm5hbWUpOwoKLyoKICogRm9yIHRoZSBnaXZlbiByZW1vdGUsIHJlYWRzIHRoZSByZWZzcGVjJ3Mgc3JjIGFuZCBzZXRzIHRoZSBvdGhlciBmaWVsZHMuCiAqLwppbnQgcmVtb3RlX2ZpbmRfdHJhY2tpbmcoc3RydWN0IHJlbW90ZSAqcmVtb3RlLCBzdHJ1Y3QgcmVmc3BlYyAqcmVmc3BlYyk7CgpzdHJ1Y3QgYnJhbmNoIHsKCWNvbnN0IGNoYXIgKm5hbWU7Cgljb25zdCBjaGFyICpyZWZuYW1lOwoKCWNvbnN0IGNoYXIgKnJlbW90ZV9uYW1lOwoJc3RydWN0IHJlbW90ZSAqcmVtb3RlOwoKCWNvbnN0IGNoYXIgKiptZXJnZV9uYW1lOwoJc3RydWN0IHJlZnNwZWMgKiptZXJnZTsKCWludCBtZXJnZV9ucjsKCWludCBtZXJnZV9hbGxvYzsKfTsKCnN0cnVjdCBicmFuY2ggKmJyYW5jaF9nZXQoY29uc3QgY2hhciAqbmFtZSk7CgppbnQgYnJhbmNoX2hhc19tZXJnZV9jb25maWcoc3RydWN0IGJyYW5jaCAqYnJhbmNoKTsKaW50IGJyYW5jaF9tZXJnZV9tYXRjaGVzKHN0cnVjdCBicmFuY2ggKiwgaW50IG4sIGNvbnN0IGNoYXIgKik7CgovKiBGbGFncyB0byBtYXRjaF9yZWZzLiAqLwplbnVtIG1hdGNoX3JlZnNfZmxhZ3MgewoJTUFUQ0hfUkVGU19OT05FCQk9IDAsCglNQVRDSF9SRUZTX0FMTCAJCT0gKDEgPDwgMCksCglNQVRDSF9SRUZTX01JUlJPUgk9ICgxIDw8IDEpLAoJTUFUQ0hfUkVGU19QUlVORQk9ICgxIDw8IDIpLAoJTUFUQ0hfUkVGU19GT0xMT1dfVEFHUwk9ICgxIDw8IDMpCn07CgovKiBSZXBvcnRpbmcgb2YgdHJhY2tpbmcgaW5mbyAqLwppbnQgc3RhdF90cmFja2luZ19pbmZvKHN0cnVjdCBicmFuY2ggKmJyYW5jaCwgaW50ICpudW1fb3VycywgaW50ICpudW1fdGhlaXJzKTsKaW50IGZvcm1hdF90cmFja2luZ19pbmZvKHN0cnVjdCBicmFuY2ggKmJyYW5jaCwgc3RydWN0IHN0cmJ1ZiAqc2IpOwoKc3RydWN0IHJlZiAqZ2V0X2xvY2FsX2hlYWRzKHZvaWQpOwovKgogKiBGaW5kIHJlZnMgZnJvbSBhIGxpc3Qgd2hpY2ggYXJlIGxpa2VseSB0byBiZSBwb2ludGVkIHRvIGJ5IHRoZSBnaXZlbiBIRUFECiAqIHJlZi4gSWYgJ2FsbCcgaXMgZmFsc2UsIHJldHVybnMgdGhlIG1vc3QgbGlrZWx5IHJlZjsgb3RoZXJ3aXNlLCByZXR1cm5zIGEKICogbGlzdCBvZiBhbGwgY2FuZGlkYXRlIHJlZnMuIElmIG5vIG1hdGNoIGlzIGZvdW5kIChvciAnaGVhZCcgaXMgTlVMTCksCiAqIHJldHVybnMgTlVMTC4gQWxsIHJldHVybnMgYXJlIG5ld2x5IGFsbG9jYXRlZCBhbmQgc2hvdWxkIGJlIGZyZWVkLgogKi8Kc3RydWN0IHJlZiAqZ3Vlc3NfcmVtb3RlX2hlYWQoY29uc3Qgc3RydWN0IHJlZiAqaGVhZCwKCQkJICAgICAgY29uc3Qgc3RydWN0IHJlZiAqcmVmcywKCQkJICAgICAgaW50IGFsbCk7CgovKiBSZXR1cm4gcmVmcyB3aGljaCBubyBsb25nZXIgZXhpc3Qgb24gcmVtb3RlICovCnN0cnVjdCByZWYgKmdldF9zdGFsZV9oZWFkcyhzdHJ1Y3QgcmVmc3BlYyAqcmVmcywgaW50IHJlZl9jb3VudCwgc3RydWN0IHJlZiAqZmV0Y2hfbWFwKTsKCi8qCiAqIENvbXBhcmUtYW5kLXN3YXAKICovCiNkZWZpbmUgQ0FTX09QVF9OQU1FICJmb3JjZS13aXRoLWxlYXNlIgoKc3RydWN0IHB1c2hfY2FzX29wdGlvbiB7Cgl1bnNpZ25lZCB1c2VfdHJhY2tpbmdfZm9yX3Jlc3Q6MTsKCXN0cnVjdCBwdXNoX2NhcyB7CgkJdW5zaWduZWQgY2hhciBleHBlY3RbMjBdOwoJCXVuc2lnbmVkIHVzZV90cmFja2luZzoxOwoJCWNoYXIgKnJlZm5hbWU7Cgl9ICplbnRyeTsKCWludCBucjsKCWludCBhbGxvYzsKfTsKCmV4dGVybiBpbnQgcGFyc2VvcHRfcHVzaF9jYXNfb3B0aW9uKGNvbnN0IHN0cnVjdCBvcHRpb24gKiwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpOwpleHRlcm4gaW50IHBhcnNlX3B1c2hfY2FzX29wdGlvbihzdHJ1Y3QgcHVzaF9jYXNfb3B0aW9uICosIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KTsKZXh0ZXJuIHZvaWQgY2xlYXJfY2FzX29wdGlvbihzdHJ1Y3QgcHVzaF9jYXNfb3B0aW9uICopOwoKZXh0ZXJuIGludCBpc19lbXB0eV9jYXMoY29uc3Qgc3RydWN0IHB1c2hfY2FzX29wdGlvbiAqKTsKdm9pZCBhcHBseV9wdXNoX2NhcyhzdHJ1Y3QgcHVzaF9jYXNfb3B0aW9uICosIHN0cnVjdCByZW1vdGUgKiwgc3RydWN0IHJlZiAqKTsKCiNlbmRpZgo=",
    "text": "#ifndef REMOTE_H\n#define REMOTE_H\n\n#include \"parse-options.h\"\n\nenum {\n\tREMOTE_CONFIG,\n\tREMOTE_REMOTES,\n\tREMOTE_BRANCHES\n};\n\nstruct remote {\n\tconst char *name;\n\tint origin;\n\n\tconst char *foreign_vcs;\n\n\tconst char **url;\n\tint url_nr;\n\tint url_alloc;\n\n\tconst char **pushurl;\n\tint pushurl_nr;\n\tint pushurl_alloc;\n\n\tconst char **push_refspec;\n\tstruct refspec *push;\n\tint push_refspec_nr;\n\tint push_refspec_alloc;\n\n\tconst char **fetch_refspec;\n\tstruct refspec *fetch;\n\tint fetch_refspec_nr;\n\tint fetch_refspec_alloc;\n\n\t/*\n\t * -1 to never fetch tags\n\t * 0 to auto-follow tags on heuristic (default)\n\t * 1 to always auto-follow tags\n\t * 2 to always fetch tags\n\t */\n\tint fetch_tags;\n\tint skip_default_update;\n\tint mirror;\n\tint prune;\n\n\tconst char *receivepack;\n\tconst char *uploadpack;\n\n\t/*\n\t * for curl remotes only\n\t */\n\tchar *http_proxy;\n};\n\nstruct remote *remote_get(const char *name);\nstruct remote *pushremote_get(const char *name);\nint remote_is_configured(const char *name);\n\ntypedef int each_remote_fn(struct remote *remote, void *priv);\nint for_each_remote(each_remote_fn fn, void *priv);\n\nint remote_has_url(struct remote *remote, const char *url);\n\nstruct refspec {\n\tunsigned force : 1;\n\tunsigned pattern : 1;\n\tunsigned matching : 1;\n\tunsigned exact_sha1 : 1;\n\n\tchar *src;\n\tchar *dst;\n};\n\nextern const struct refspec *tag_refspec;\n\nstruct ref {\n\tstruct ref *next;\n\tunsigned char old_sha1[20];\n\tunsigned char new_sha1[20];\n\tunsigned char old_sha1_expect[20]; /* used by expect-old */\n\tchar *symref;\n\tunsigned int\n\t\tforce:1,\n\t\tforced_update:1,\n\t\texpect_old_sha1:1,\n\t\texpect_old_no_trackback:1,\n\t\tdeletion:1,\n\t\tmatched:1;\n\n\t/*\n\t * Order is important here, as we write to FETCH_HEAD\n\t * in numeric order. And the default NOT_FOR_MERGE\n\t * should be 0, so that xcalloc'd structures get it\n\t * by default.\n\t */\n\tenum {\n\t\tFETCH_HEAD_MERGE = -1,\n\t\tFETCH_HEAD_NOT_FOR_MERGE = 0,\n\t\tFETCH_HEAD_IGNORE = 1\n\t} fetch_head_status;\n\n\tenum {\n\t\tREF_STATUS_NONE = 0,\n\t\tREF_STATUS_OK,\n\t\tREF_STATUS_REJECT_NONFASTFORWARD,\n\t\tREF_STATUS_REJECT_ALREADY_EXISTS,\n\t\tREF_STATUS_REJECT_NODELETE,\n\t\tREF_STATUS_REJECT_FETCH_FIRST,\n\t\tREF_STATUS_REJECT_NEEDS_FORCE,\n\t\tREF_STATUS_REJECT_STALE,\n\t\tREF_STATUS_UPTODATE,\n\t\tREF_STATUS_REMOTE_REJECT,\n\t\tREF_STATUS_EXPECTING_REPORT\n\t} status;\n\tchar *remote_status;\n\tstruct ref *peer_ref; /* when renaming */\n\tchar name[FLEX_ARRAY]; /* more */\n};\n\n#define REF_NORMAL\t(1u << 0)\n#define REF_HEADS\t(1u << 1)\n#define REF_TAGS\t(1u << 2)\n\nextern struct ref *find_ref_by_name(const struct ref *list, const char *name);\n\nstruct ref *alloc_ref(const char *name);\nstruct ref *copy_ref(const struct ref *ref);\nstruct ref *copy_ref_list(const struct ref *ref);\nvoid sort_ref_list(struct ref **, int (*cmp)(const void *, const void *));\nextern int count_refspec_match(const char *, struct ref *refs, struct ref **matched_ref);\nint ref_compare_name(const void *, const void *);\n\nint check_ref_type(const struct ref *ref, int flags);\n\n/*\n * Frees the entire list and peers of elements.\n */\nvoid free_refs(struct ref *ref);\n\nstruct extra_have_objects {\n\tint nr, alloc;\n\tunsigned char (*array)[20];\n};\nextern struct ref **get_remote_heads(int in, char *src_buf, size_t src_len,\n\t\t\t\t     struct ref **list, unsigned int flags,\n\t\t\t\t     struct extra_have_objects *);\n\nint resolve_remote_symref(struct ref *ref, struct ref *list);\nint ref_newer(const unsigned char *new_sha1, const unsigned char *old_sha1);\n\n/*\n * Remove and free all but the first of any entries in the input list\n * that map the same remote reference to the same local reference.  If\n * there are two entries that map different remote references to the\n * same local reference, emit an error message and die.  Return a\n * pointer to the head of the resulting list.\n */\nstruct ref *ref_remove_duplicates(struct ref *ref_map);\n\nint valid_fetch_refspec(const char *refspec);\nstruct refspec *parse_fetch_refspec(int nr_refspec, const char **refspec);\n\nvoid free_refspec(int nr_refspec, struct refspec *refspec);\n\nextern int query_refspecs(struct refspec *specs, int nr, struct refspec *query);\nchar *apply_refspecs(struct refspec *refspecs, int nr_refspec,\n\t\t     const char *name);\n\nint match_push_refs(struct ref *src, struct ref **dst,\n\t\t    int nr_refspec, const char **refspec, int all);\nvoid set_ref_status_for_push(struct ref *remote_refs, int send_mirror,\n\tint force_update);\n\n/*\n * Given a list of the remote refs and the specification of things to\n * fetch, makes a (separate) list of the refs to fetch and the local\n * refs to store into.\n *\n * *tail is the pointer to the tail pointer of the list of results\n * beforehand, and will be set to the tail pointer of the list of\n * results afterward.\n *\n * missing_ok is usually false, but when we are adding branch.$name.merge\n * it is Ok if the branch is not at the remote anymore.\n */\nint get_fetch_map(const struct ref *remote_refs, const struct refspec *refspec,\n\t\t  struct ref ***tail, int missing_ok);\n\nstruct ref *get_remote_ref(const struct ref *remote_refs, const char *name);\n\n/*\n * For the given remote, reads the refspec's src and sets the other fields.\n */\nint remote_find_tracking(struct remote *remote, struct refspec *refspec);\n\nstruct branch {\n\tconst char *name;\n\tconst char *refname;\n\n\tconst char *remote_name;\n\tstruct remote *remote;\n\n\tconst char **merge_name;\n\tstruct refspec **merge;\n\tint merge_nr;\n\tint merge_alloc;\n};\n\nstruct branch *branch_get(const char *name);\n\nint branch_has_merge_config(struct branch *branch);\nint branch_merge_matches(struct branch *, int n, const char *);\n\n/* Flags to match_refs. */\nenum match_refs_flags {\n\tMATCH_REFS_NONE\t\t= 0,\n\tMATCH_REFS_ALL \t\t= (1 << 0),\n\tMATCH_REFS_MIRROR\t= (1 << 1),\n\tMATCH_REFS_PRUNE\t= (1 << 2),\n\tMATCH_REFS_FOLLOW_TAGS\t= (1 << 3)\n};\n\n/* Reporting of tracking info */\nint stat_tracking_info(struct branch *branch, int *num_ours, int *num_theirs);\nint format_tracking_info(struct branch *branch, struct strbuf *sb);\n\nstruct ref *get_local_heads(void);\n/*\n * Find refs from a list which are likely to be pointed to by the given HEAD\n * ref. If 'all' is false, returns the most likely ref; otherwise, returns a\n * list of all candidate refs. If no match is found (or 'head' is NULL),\n * returns NULL. All returns are newly allocated and should be freed.\n */\nstruct ref *guess_remote_head(const struct ref *head,\n\t\t\t      const struct ref *refs,\n\t\t\t      int all);\n\n/* Return refs which no longer exist on remote */\nstruct ref *get_stale_heads(struct refspec *refs, int ref_count, struct ref *fetch_map);\n\n/*\n * Compare-and-swap\n */\n#define CAS_OPT_NAME \"force-with-lease\"\n\nstruct push_cas_option {\n\tunsigned use_tracking_for_rest:1;\n\tstruct push_cas {\n\t\tunsigned char expect[20];\n\t\tunsigned use_tracking:1;\n\t\tchar *refname;\n\t} *entry;\n\tint nr;\n\tint alloc;\n};\n\nextern int parseopt_push_cas_option(const struct option *, const char *arg, int unset);\nextern int parse_push_cas_option(struct push_cas_option *, const char *arg, int unset);\nextern void clear_cas_option(struct push_cas_option *);\n\nextern int is_empty_cas(const struct push_cas_option *);\nvoid apply_push_cas(struct push_cas_option *, struct remote *, struct ref *);\n\n#endif\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00c6a76ef803005698e14d7f31eb4acd22b35649",
  "sha1_ok": true,
  "size": 7121
}
